α : Type u,	x : α,	concat : dlist α → dlist α,	xs : list α → list α,	h : ∀ (l : list α), xs l = xs list.nil ++ l	⊢ ∀ (l : list α), (xs ∘ x::_) l = (xs ∘ x::_) list.nil ++ l
α : Type u,	x : α,	concat : dlist α → dlist α,	xs : list α → list α,	h : ∀ (l : list α), xs l = xs list.nil ++ l	⊢ ∀ (l : list α), (xs ∘ x::_) l = (xs ∘ x::_) list.nil ++ l
α : Type u,	x : α,	concat : dlist α → dlist α,	xs : list α → list α,	h : ∀ (l : list α), xs l = xs list.nil ++ l,	l : list α	⊢ (xs ∘ x::_) l = (xs ∘ x::_) list.nil ++ l
α : Type u,	x : α,	concat : dlist α → dlist α,	xs : list α → list α,	h : ∀ (l : list α), xs l = xs list.nil ++ l,	l : list α	⊢ xs (x :: l) = xs [x] ++ l
α : Type u,	x : α,	concat : dlist α → dlist α,	xs : list α → list α,	h : ∀ (l : list α), xs l = xs list.nil ++ l,	l : list α	⊢ xs list.nil ++ x :: l = xs list.nil ++ [x] ++ l
α : Type u,	β : Type v,	f : α → β,	a : α,	s : stream α,	_x : a ∈ s,	_fun_match : a ∈ s → f a ∈ stream.map f s,	n : ℕ,	h : (λ (b : α), a = b) (stream.nth n s)	⊢ f a = stream.nth n (stream.map f s)
α : Type u,	s : stream α	⊢ (stream.corec (λ (s : stream α), s.head) (λ (s : stream α), s.tail.tail) s).tail = stream.corec (λ (s : stream α), s.head) (λ (s : stream α), s.tail.tail) s.tail.tail
α : Type u,	s : stream α	⊢ (s.head::stream.corec (λ (s : stream α), s.head) (λ (s : stream α), s.tail.tail) s.tail.tail).tail = stream.corec (λ (s : stream α), s.head) (λ (s : stream α), s.tail.tail) s.tail.tail
α : Type u,	s : stream α	⊢ s.even.tail = s.tail.tail.even
n : ℕ,	α β σ φ : Type,	f : α → β → σ → σ × φ,	map_accumr₂ : vector α n → vector β n → σ → σ × vector φ n,	x : list α,	px : x.length = n,	y : list β,	py : y.length = n,	c : σ,	res : σ × list φ := list.map_accumr₂ f x y c	⊢ res.snd.length = n
α : Type u,	_inst_1 : linear_order α,	a b : α	⊢ linear_order.min a b ≤ b
α : Type u,	n : ℕ,	a : array n α,	m : ℕ,	h : m ≤ n	⊢ array (m - 0) α = array m α
n : ℕ,	a b : fin n	⊢ (a.add b).val = (a.val + b.val) % n
n : ℕ,	a b : fin n	⊢ (a.add b).val = (a.val + b.val) % n
n : ℕ,	b : fin n,	a_val : ℕ,	a_property : a_val < n	⊢ (fin.add ⟨a_val, a_property⟩ b).val = (⟨a_val, a_property⟩.val + b.val) % n
n a_val : ℕ,	a_property : a_val < n,	b_val : ℕ,	b_property : b_val < n	⊢ (fin.add ⟨a_val, a_property⟩ ⟨b_val, b_property⟩).val = (⟨a_val, a_property⟩.val + ⟨b_val, b_property⟩.val) % n
n : ℕ,	a b : fin n	⊢ (a.add b).val = (a.val + b.val) % n
m n : ℕ	⊢ int.neg_of_nat m + int.neg_of_nat n = int.neg_of_nat (m + n)
n : ℕ	⊢ int.neg_of_nat 0 + int.neg_of_nat n = int.neg_of_nat (0 + n)
⊢ int.neg_of_nat 0 + int.neg_of_nat 0 = int.neg_of_nat (0 + 0)
⊢ int.neg_of_nat 0 + int.neg_of_nat 0 = int.neg_of_nat (0 + 0)		case nat.zero, nat.succ	n : ℕ	⊢ int.neg_of_nat 0 + int.neg_of_nat n.succ = int.neg_of_nat (0 + n.succ)
⊢ int.neg_of_nat 0 + int.neg_of_nat 0 = int.neg_of_nat (0 + 0)
n : ℕ	⊢ int.neg_of_nat 0 + int.neg_of_nat n.succ = int.neg_of_nat n.succ
n : ℕ	⊢ int.neg_of_nat 0 + int.neg_of_nat n = int.neg_of_nat (0 + n)		case nat.succ	n m : ℕ	⊢ int.neg_of_nat m.succ + int.neg_of_nat n = int.neg_of_nat (m.succ + n)
n : ℕ	⊢ int.neg_of_nat 0 + int.neg_of_nat n.succ = int.neg_of_nat (0 + n.succ)
n m : ℕ	⊢ int.neg_of_nat m.succ + int.neg_of_nat n = int.neg_of_nat (m.succ + n)
m : ℕ	⊢ int.neg_of_nat m.succ + int.neg_of_nat 0 = int.neg_of_nat (m.succ + 0)
m : ℕ	⊢ int.neg_of_nat m.succ + int.neg_of_nat 0 = int.neg_of_nat (m.succ + 0)		case nat.succ, nat.succ	m n : ℕ	⊢ int.neg_of_nat m.succ + int.neg_of_nat n.succ = int.neg_of_nat (m.succ + n.succ)
m : ℕ	⊢ int.neg_of_nat m.succ + int.neg_of_nat 0 = int.neg_of_nat (m.succ + 0)
m n : ℕ	⊢ int.neg_of_nat m.succ + int.neg_of_nat n.succ = int.neg_of_nat (m + n.succ).succ
m n : ℕ	⊢ int.neg_of_nat m.succ + int.neg_of_nat n.succ = int.neg_of_nat (m.succ + n.succ)
n : ℕ	⊢ -[1+ n] + ↑(n.succ) = 0
a b : ℤ	⊢ -a * b = a * -b
a b : ℤ,	h : a ≤ b,	this : 0 ≤ -a + b,	this : 0 + -b ≤ -a + b + -b	⊢ -b ≤ -a
a b : ℤ,	h : 0 ≤ a - b	⊢ b ≤ a
a b : ℤ,	h : 0 ≤ a - b,	h : 0 + b ≤ a - b + b	⊢ b ≤ a
a b : ℤ,	ha : a ≤ 0,	hb : 0 ≤ b,	h : a * b ≤ 0 * b	⊢ a * b ≤ 0
a b : ℤ,	ha : a ≤ 0,	hb : b ≤ 0,	this : 0 * b ≤ a * b	⊢ 0 ≤ a * b
b : bool,	n : ℕ	⊢ (nat.bit b n).div2 = n
b : bool,	n : ℕ	⊢ (nat.bit b n).div2 = n
b : bool,	n : ℕ	⊢ (nat.bit b n).div2 = n
n : ℕ	⊢ cond bool.ff 1 0 < 2
n : ℕ	⊢ cond bool.tt 1 0 < 2
n : ℕ	⊢ 0 < 2
b : bool,	n : ℕ	⊢ cond b 1 0 < 2
b : bool,	n : ℕ	⊢ 0 < 2
m n : ℕ	⊢ m * n % m = 0
m n : ℕ,	H : 0 < n,	t : (0 + m * n) / n = 0 / n + m := 0.add_mul_div_right m H	⊢ m * n / n = m
k m n : ℕ,	H : n ≤ m,	h₁ : k ∣ m,	h₂ : k ∣ n	⊢ k ∣ m - n + n
k m n : ℕ,	H : n ≤ m,	h₁ : k ∣ m,	h₂ : k ∣ n	⊢ k ∣ m - n + n
k m n : ℕ,	H : n ≤ m,	h₁ : k ∣ m,	h₂ : k ∣ n	⊢ k ∣ m
k n m : ℕ,	h : k + n < k + m,	h' : k + n ≤ k + m := nat.le_of_lt h,	heq : n = m	⊢ k + m < k + m
k n m : ℕ,	h : k + n < k + m,	h' : k + n ≤ k + m := nat.le_of_lt h,	heq : n = m,	h : k + m < k + m	⊢ k + m < k + m
n m : ℕ,	h : n ≤ m,	k : ℕ,	hk : n + k = m	⊢ n + (m - n) = m
y : ℕ	⊢ 0 % y = ite (0 < y ∧ y ≤ 0) ((0 - y) % y) 0
y : ℕ	⊢ 0 % y = ite (0 < y ∧ y ≤ 0) ((0 - y) % y) 0
⊢ 0 % 0 = ite (0 < 0 ∧ 0 ≤ 0) ((0 - 0) % 0) 0
y : ℕ	⊢ 0 % y.succ = ite (0 < y.succ ∧ y.succ ≤ 0) ((0 - y.succ) % y.succ) 0
y : ℕ	⊢ 0 % y = ite (0 < y ∧ y ≤ 0) ((0 - y) % y) 0		case nat.succ	y x : ℕ	⊢ x.succ % y = ite (0 < y ∧ y ≤ x.succ) ((x.succ - y) % y) x.succ
x y : ℕ	⊢ x % y = ite (0 < y ∧ y ≤ x) ((x - y) % y) x
x : ℕ	⊢ x.succ % 0 = ite (0 < 0 ∧ 0 ≤ x.succ) ((x.succ - 0) % 0) x.succ
x : ℕ	⊢ x.succ % 0 = ite (0 < 0 ∧ 0 ≤ x.succ) ((x.succ - 0) % 0) x.succ		case nat.succ, nat.succ	x y : ℕ	⊢ x.succ % y.succ = ite (0 < y.succ ∧ y.succ ≤ x.succ) ((x.succ - y.succ) % y.succ) x.succ
y x : ℕ	⊢ x.succ % y = ite (0 < y ∧ y ≤ x.succ) ((x.succ - y) % y) x.succ
x y : ℕ	⊢ x.succ % y.succ = ite (0 < y.succ ∧ y.succ ≤ x.succ) ((x.succ - y.succ) % y.succ) x.succ
x y : ℕ	⊢ x.succ % y.succ = ite (0 < y.succ ∧ y.succ ≤ x.succ) ((x.succ - y.succ) % y.succ) x.succ
x y : ℕ	⊢ x.succ - y.succ ≤ x
x y : ℕ	⊢ x.succ - y.succ ≤ x.succ - y.succ
n : ℕ	⊢ n = 0 ∨ n = n.pred.succ
⊢ 0 = 0 ∨ 0 = 0.pred.succ
n : ℕ	⊢ n.succ = 0 ∨ n.succ = n.succ.pred.succ
n : ℕ	⊢ n = 0 ∨ n = n.pred.succ
right_distrib : ∀ (n m k : ℕ), (n + m) * k = n * k + m * k,	n m k : ℕ	⊢ n * k + m * k + (n + m) = n * k + n + (m * k + m)
right_distrib : ∀ (n m k : ℕ), (n + m) * k = n * k + m * k,	n m k : ℕ	⊢ (n + m) * k.succ = n * k.succ + m * k.succ
G : Type u_1,	P : Type u_2,	_inst_1 : add_comm_group G,	_inst_2 : add_torsor G P,	p₁ p₂ p₃ p₄ : P	⊢ p₁ -ᵥ p₂ - (p₃ -ᵥ p₄) = p₁ -ᵥ p₃ - (p₂ -ᵥ p₄)
R : Type ?,	_inst_7 : comm_semiring R,	A : Type ?,	_inst_8 : semiring A,	P Q : algebra R A,	r : R	⊢ ?m_1
R : Type ?,	_inst_7 : comm_semiring R,	A : Type ?,	_inst_8 : semiring A,	P Q : algebra R A,	r : R,	_inst : algebra R A	⊢ ?m_1
R : Type ?,	_inst_7 : comm_semiring R,	A : Type ?,	_inst_8 : semiring A,	P Q : algebra R A,	r : R	⊢ A
R : Type ?,	_inst_7 : comm_semiring R,	A : Type ?,	_inst_8 : semiring A,	P Q : algebra R A,	r : R,	_inst : algebra R A	⊢ A
R : Type u_1,	_inst_7 : comm_semiring R,	A : Type u_2,	_inst_8 : semiring A,	P Q : algebra R A,	w : ∀ (r : R), ⇑(algebra_map R A) r = ⇑(algebra_map R A) r	⊢ P = Q
R : Type u_1,	_inst_7 : comm_semiring R,	A : Type u_2,	_inst_8 : semiring A,	Q : algebra R A,	P__to_ring_hom : R →+* A,	P_commutes' : ∀ (r : R) (x : A), P__to_ring_hom.to_fun r * x = x * P__to_ring_hom.to_fun r,	P : R → A → A,	P_smul_def' : ∀ (r : R) (x : A), r • x = P__to_ring_hom.to_fun r * x,	w : ∀ (r : R), ⇑(algebra_map R A) r = ⇑(algebra_map R A) r	⊢ {to_has_scalar := {smul := P}, to_ring_hom := P__to_ring_hom, commutes' := P_commutes', smul_def' := P_smul_def'} = Q
R : Type u_1,	_inst_7 : comm_semiring R,	A : Type u_2,	_inst_8 : semiring A,	P Q : algebra R A,	w : ∀ (r : R), ⇑(algebra_map R A) r = ⇑(algebra_map R A) r	⊢ P = Q
R : Type u_1,	_inst_1 : comm_semiring R,	A : Type u_2,	_inst_2 : semiring A,	_inst_3 : algebra R A,	M : Type u_3,	_inst_4 : add_comm_monoid M,	_inst_5 : module A M,	_inst_6 : module R M,	_inst_7 : is_scalar_tower R A M,	r : R,	a : A,	m : M	⊢ r • a • m = a • r • m
R : Type u_1,	_inst_7 : comm_semiring R,	A : Type u_2,	_inst_8 : semiring A,	P__to_ring_hom : R →+* A,	P_commutes' : ∀ (r : R) (x : A), P__to_ring_hom.to_fun r * x = x * P__to_ring_hom.to_fun r,	P : R → A → A,	P_smul_def' : ∀ (r : R) (x : A), r • x = P__to_ring_hom.to_fun r * x,	Q__to_ring_hom : R →+* A,	Q_commutes' : ∀ (r : R) (x : A), Q__to_ring_hom.to_fun r * x = x * Q__to_ring_hom.to_fun r,	Q : R → A → A,	Q_smul_def' : ∀ (r : R) (x : A), r • x = Q__to_ring_hom.to_fun r * x,	w : ∀ (r : R), ⇑(algebra_map R A) r = ⇑(algebra_map R A) r	⊢ {to_has_scalar := {smul := P}, to_ring_hom := P__to_ring_hom, commutes' := P_commutes', smul_def' := P_smul_def'} = {to_has_scalar := {smul := Q}, to_ring_hom := Q__to_ring_hom, commutes' := Q_commutes', smul_def' := Q_smul_def'}
R : Type u_1,	_inst_7 : comm_semiring R,	A : Type u_2,	_inst_8 : semiring A,	P__to_ring_hom : R →+* A,	P_commutes' : ∀ (r : R) (x : A), P__to_ring_hom.to_fun r * x = x * P__to_ring_hom.to_fun r,	P : R → A → A,	P_smul_def' : ∀ (r : R) (x : A), r • x = P__to_ring_hom.to_fun r * x,	Q__to_ring_hom : R →+* A,	Q_commutes' : ∀ (r : R) (x : A), Q__to_ring_hom.to_fun r * x = x * Q__to_ring_hom.to_fun r,	Q : R → A → A,	Q_smul_def' : ∀ (r : R) (x : A), r • x = Q__to_ring_hom.to_fun r * x,	w : ∀ (r : R), ⇑(algebra_map R A) r = ⇑(algebra_map R A) r	⊢ P = Q
R : Type u_1,	_inst_7 : comm_semiring R,	A : Type u_2,	_inst_8 : semiring A,	P__to_ring_hom : R →+* A,	P_commutes' : ∀ (r : R) (x : A), P__to_ring_hom.to_fun r * x = x * P__to_ring_hom.to_fun r,	P : R → A → A,	P_smul_def' : ∀ (r : R) (x : A), r • x = P__to_ring_hom.to_fun r * x,	Q__to_ring_hom : R →+* A,	Q_commutes' : ∀ (r : R) (x : A), Q__to_ring_hom.to_fun r * x = x * Q__to_ring_hom.to_fun r,	Q : R → A → A,	Q_smul_def' : ∀ (r : R) (x : A), r • x = Q__to_ring_hom.to_fun r * x,	w : ∀ (r : R), ⇑(algebra_map R A) r = ⇑(algebra_map R A) r,	r : R,	a : A	⊢ P r a = Q r a
R : Type u_1,	_inst_7 : comm_semiring R,	A : Type u_2,	_inst_8 : semiring A,	P__to_ring_hom : R →+* A,	P_commutes' : ∀ (r : R) (x : A), P__to_ring_hom.to_fun r * x = x * P__to_ring_hom.to_fun r,	P : R → A → A,	P_smul_def' : ∀ (r : R) (x : A), r • x = P__to_ring_hom.to_fun r * x,	Q__to_ring_hom : R →+* A,	Q_commutes' : ∀ (r : R) (x : A), Q__to_ring_hom.to_fun r * x = x * Q__to_ring_hom.to_fun r,	Q : R → A → A,	Q_smul_def' : ∀ (r : R) (x : A), r • x = Q__to_ring_hom.to_fun r * x,	r : R,	a : A,	w : (λ (s : A), s * a) (⇑(algebra_map R A) r) = (λ (s : A), s * a) (⇑(algebra_map R A) r)	⊢ P r a = Q r a
R : Type u_1,	_inst_7 : comm_semiring R,	A : Type u_2,	_inst_8 : semiring A,	P__to_ring_hom : R →+* A,	P_commutes' : ∀ (r : R) (x : A), P__to_ring_hom.to_fun r * x = x * P__to_ring_hom.to_fun r,	P : R → A → A,	P_smul_def' : ∀ (r : R) (x : A), r • x = P__to_ring_hom.to_fun r * x,	Q__to_ring_hom : R →+* A,	Q_commutes' : ∀ (r : R) (x : A), Q__to_ring_hom.to_fun r * x = x * Q__to_ring_hom.to_fun r,	Q : R → A → A,	Q_smul_def' : ∀ (r : R) (x : A), r • x = Q__to_ring_hom.to_fun r * x,	w : ∀ (r : R), ⇑(algebra_map R A) r = ⇑(algebra_map R A) r	⊢ P = Q		R : Type u_1,	_inst_7 : comm_semiring R,	A : Type u_2,	_inst_8 : semiring A,	P__to_ring_hom : R →+* A,	P_commutes' : ∀ (r : R) (x : A), P__to_ring_hom.to_fun r * x = x * P__to_ring_hom.to_fun r,	P : R → A → A,	P_smul_def' : ∀ (r : R) (x : A), r • x = P__to_ring_hom.to_fun r * x,	Q__to_ring_hom : R →+* A,	Q_commutes' : ∀ (r : R) (x : A), Q__to_ring_hom.to_fun r * x = x * Q__to_ring_hom.to_fun r,	Q : R → A → A,	Q_smul_def' : ∀ (r : R) (x : A), r • x = Q__to_ring_hom.to_fun r * x,	w : ∀ (r : R), ⇑(algebra_map R A) r = ⇑(algebra_map R A) r	⊢ P__to_ring_hom = Q__to_ring_hom		R : Type u_1,	_inst_7 : comm_semiring R,	A : Type u_2,	_inst_8 : semiring A,	P__to_ring_hom : R →+* A,	P_commutes' : ∀ (r : R) (x : A), P__to_ring_hom.to_fun r * x = x * P__to_ring_hom.to_fun r,	P : R → A → A,	P_smul_def' : ∀ (r : R) (x : A), r • x = P__to_ring_hom.to_fun r * x,	Q__to_ring_hom : R →+* A,	Q_commutes' : ∀ (r : R) (x : A), Q__to_ring_hom.to_fun r * x = x * Q__to_ring_hom.to_fun r,	Q : R → A → A,	Q_smul_def' : ∀ (r : R) (x : A), r • x = Q__to_ring_hom.to_fun r * x,	w : ∀ (r : R), ⇑(algebra_map R A) r = ⇑(algebra_map R A) r	⊢ P_commutes' == Q_commutes'		R : Type u_1,	_inst_7 : comm_semiring R,	A : Type u_2,	_inst_8 : semiring A,	P__to_ring_hom : R →+* A,	P_commutes' : ∀ (r : R) (x : A), P__to_ring_hom.to_fun r * x = x * P__to_ring_hom.to_fun r,	P : R → A → A,	P_smul_def' : ∀ (r : R) (x : A), r • x = P__to_ring_hom.to_fun r * x,	Q__to_ring_hom : R →+* A,	Q_commutes' : ∀ (r : R) (x : A), Q__to_ring_hom.to_fun r * x = x * Q__to_ring_hom.to_fun r,	Q : R → A → A,	Q_smul_def' : ∀ (r : R) (x : A), r • x = Q__to_ring_hom.to_fun r * x,	w : ∀ (r : R), ⇑(algebra_map R A) r = ⇑(algebra_map R A) r	⊢ P_smul_def' == Q_smul_def'
R : Type u_1,	_inst_7 : comm_semiring R,	A : Type u_2,	_inst_8 : semiring A,	P__to_ring_hom : R →+* A,	P_commutes' : ∀ (r : R) (x : A), P__to_ring_hom.to_fun r * x = x * P__to_ring_hom.to_fun r,	P : R → A → A,	P_smul_def' : ∀ (r : R) (x : A), r • x = P__to_ring_hom.to_fun r * x,	Q__to_ring_hom : R →+* A,	Q_commutes' : ∀ (r : R) (x : A), Q__to_ring_hom.to_fun r * x = x * Q__to_ring_hom.to_fun r,	Q : R → A → A,	Q_smul_def' : ∀ (r : R) (x : A), r • x = Q__to_ring_hom.to_fun r * x,	r : R,	a : A,	w : P r a = Q r a	⊢ P r a = Q r a
R : Type u_1,	_inst_7 : comm_semiring R,	A : Type u_2,	_inst_8 : semiring A,	P__to_ring_hom : R →+* A,	P_commutes' : ∀ (r : R) (x : A), P__to_ring_hom.to_fun r * x = x * P__to_ring_hom.to_fun r,	P : R → A → A,	P_smul_def' : ∀ (r : R) (x : A), r • x = P__to_ring_hom.to_fun r * x,	Q__to_ring_hom : R →+* A,	Q_commutes' : ∀ (r : R) (x : A), Q__to_ring_hom.to_fun r * x = x * Q__to_ring_hom.to_fun r,	Q : R → A → A,	Q_smul_def' : ∀ (r : R) (x : A), r • x = Q__to_ring_hom.to_fun r * x,	w : ∀ (r : R), ⇑(algebra_map R A) r = ⇑(algebra_map R A) r	⊢ P__to_ring_hom = Q__to_ring_hom
R : Type u_1,	_inst_7 : comm_semiring R,	A : Type u_2,	_inst_8 : semiring A,	P__to_ring_hom : R →+* A,	P_commutes' : ∀ (r : R) (x : A), P__to_ring_hom.to_fun r * x = x * P__to_ring_hom.to_fun r,	P : R → A → A,	P_smul_def' : ∀ (r : R) (x : A), r • x = P__to_ring_hom.to_fun r * x,	Q__to_ring_hom : R →+* A,	Q_commutes' : ∀ (r : R) (x : A), Q__to_ring_hom.to_fun r * x = x * Q__to_ring_hom.to_fun r,	Q : R → A → A,	Q_smul_def' : ∀ (r : R) (x : A), r • x = Q__to_ring_hom.to_fun r * x,	w : ∀ (r : R), ⇑(algebra_map R A) r = ⇑(algebra_map R A) r	⊢ P__to_ring_hom = Q__to_ring_hom		R : Type u_1,	_inst_7 : comm_semiring R,	A : Type u_2,	_inst_8 : semiring A,	P__to_ring_hom : R →+* A,	P_commutes' : ∀ (r : R) (x : A), P__to_ring_hom.to_fun r * x = x * P__to_ring_hom.to_fun r,	P : R → A → A,	P_smul_def' : ∀ (r : R) (x : A), r • x = P__to_ring_hom.to_fun r * x,	Q__to_ring_hom : R →+* A,	Q_commutes' : ∀ (r : R) (x : A), Q__to_ring_hom.to_fun r * x = x * Q__to_ring_hom.to_fun r,	Q : R → A → A,	Q_smul_def' : ∀ (r : R) (x : A), r • x = Q__to_ring_hom.to_fun r * x,	w : ∀ (r : R), ⇑(algebra_map R A) r = ⇑(algebra_map R A) r	⊢ P_commutes' == Q_commutes'		R : Type u_1,	_inst_7 : comm_semiring R,	A : Type u_2,	_inst_8 : semiring A,	P__to_ring_hom : R →+* A,	P_commutes' : ∀ (r : R) (x : A), P__to_ring_hom.to_fun r * x = x * P__to_ring_hom.to_fun r,	P : R → A → A,	P_smul_def' : ∀ (r : R) (x : A), r • x = P__to_ring_hom.to_fun r * x,	Q__to_ring_hom : R →+* A,	Q_commutes' : ∀ (r : R) (x : A), Q__to_ring_hom.to_fun r * x = x * Q__to_ring_hom.to_fun r,	Q : R → A → A,	Q_smul_def' : ∀ (r : R) (x : A), r • x = Q__to_ring_hom.to_fun r * x,	w : ∀ (r : R), ⇑(algebra_map R A) r = ⇑(algebra_map R A) r	⊢ P_smul_def' == Q_smul_def'
R : Type u_1,	_inst_7 : comm_semiring R,	A : Type u_2,	_inst_8 : semiring A,	P__to_ring_hom : R →+* A,	P_commutes' : ∀ (r : R) (x : A), P__to_ring_hom.to_fun r * x = x * P__to_ring_hom.to_fun r,	P : R → A → A,	P_smul_def' : ∀ (r : R) (x : A), r • x = P__to_ring_hom.to_fun r * x,	Q__to_ring_hom : R →+* A,	Q_commutes' : ∀ (r : R) (x : A), Q__to_ring_hom.to_fun r * x = x * Q__to_ring_hom.to_fun r,	Q : R → A → A,	Q_smul_def' : ∀ (r : R) (x : A), r • x = Q__to_ring_hom.to_fun r * x,	w : ∀ (r : R), ⇑(algebra_map R A) r = ⇑(algebra_map R A) r,	r : R	⊢ ⇑P__to_ring_hom r = ⇑Q__to_ring_hom r
R : Type u_1,	_inst_7 : comm_semiring R,	A : Type u_2,	_inst_8 : semiring A,	P__to_ring_hom : R →+* A,	P_commutes' : ∀ (r : R) (x : A), P__to_ring_hom.to_fun r * x = x * P__to_ring_hom.to_fun r,	P : R → A → A,	P_smul_def' : ∀ (r : R) (x : A), r • x = P__to_ring_hom.to_fun r * x,	Q__to_ring_hom : R →+* A,	Q_commutes' : ∀ (r : R) (x : A), Q__to_ring_hom.to_fun r * x = x * Q__to_ring_hom.to_fun r,	Q : R → A → A,	Q_smul_def' : ∀ (r : R) (x : A), r • x = Q__to_ring_hom.to_fun r * x,	w : ∀ (r : R), ⇑(algebra_map R A) r = ⇑(algebra_map R A) r	⊢ P_commutes' == Q_commutes'		R : Type u_1,	_inst_7 : comm_semiring R,	A : Type u_2,	_inst_8 : semiring A,	P__to_ring_hom : R →+* A,	P_commutes' : ∀ (r : R) (x : A), P__to_ring_hom.to_fun r * x = x * P__to_ring_hom.to_fun r,	P : R → A → A,	P_smul_def' : ∀ (r : R) (x : A), r • x = P__to_ring_hom.to_fun r * x,	Q__to_ring_hom : R →+* A,	Q_commutes' : ∀ (r : R) (x : A), Q__to_ring_hom.to_fun r * x = x * Q__to_ring_hom.to_fun r,	Q : R → A → A,	Q_smul_def' : ∀ (r : R) (x : A), r • x = Q__to_ring_hom.to_fun r * x,	w : ∀ (r : R), ⇑(algebra_map R A) r = ⇑(algebra_map R A) r	⊢ P_smul_def' == Q_smul_def'
R : Type u_1,	_inst_7 : comm_semiring R,	A : Type u_2,	_inst_8 : semiring A,	P__to_ring_hom : R →+* A,	P_commutes' : ∀ (r : R) (x : A), P__to_ring_hom.to_fun r * x = x * P__to_ring_hom.to_fun r,	P : R → A → A,	P_smul_def' : ∀ (r : R) (x : A), r • x = P__to_ring_hom.to_fun r * x,	Q__to_ring_hom : R →+* A,	Q_commutes' : ∀ (r : R) (x : A), Q__to_ring_hom.to_fun r * x = x * Q__to_ring_hom.to_fun r,	Q : R → A → A,	Q_smul_def' : ∀ (r : R) (x : A), r • x = Q__to_ring_hom.to_fun r * x,	w : ∀ (r : R), ⇑(algebra_map R A) r = ⇑(algebra_map R A) r	⊢ P_commutes' == Q_commutes'
R : Type u_1,	_inst_7 : comm_semiring R,	A : Type u_2,	_inst_8 : semiring A,	P__to_ring_hom : R →+* A,	P_commutes' : ∀ (r : R) (x : A), P__to_ring_hom.to_fun r * x = x * P__to_ring_hom.to_fun r,	P : R → A → A,	P_smul_def' : ∀ (r : R) (x : A), r • x = P__to_ring_hom.to_fun r * x,	Q__to_ring_hom : R →+* A,	Q_commutes' : ∀ (r : R) (x : A), Q__to_ring_hom.to_fun r * x = x * Q__to_ring_hom.to_fun r,	Q : R → A → A,	Q_smul_def' : ∀ (r : R) (x : A), r • x = Q__to_ring_hom.to_fun r * x,	w : ∀ (r : R), ⇑(algebra_map R A) r = ⇑(algebra_map R A) r	⊢ P_smul_def' == Q_smul_def'
R : Type u,	A : Type w,	_inst_1 : comm_semiring R,	_inst_3 : semiring A,	_inst_4 : algebra R A,	x : A,	r : R,	y : A	⊢ x * (⇑(algebra_map R A) r * y) = ⇑(algebra_map R A) r * (x * y)
R : Type u,	A : Type w,	_inst_1 : comm_semiring R,	_inst_3 : semiring A,	_inst_4 : algebra R A,	r : R	⊢ bit1 r • 1 = bit1 (r • 1)
α : Type u_1,	_inst_1 : linear_ordered_field α,	_inst_2 : floor_ring α	⊢ ↑0 ≤ 0 + 1 / 2 ∧ 0 + 1 / 2 < ↑0 + 1
α : Type u_1,	_inst_1 : comm_monoid α,	a : α,	n : ℕ	⊢ associates.mk (a ^ n) = associates.mk a ^ n
α : Type u_1,	_inst_1 : comm_monoid α,	a : α	⊢ associates.mk (a ^ 0) = associates.mk a ^ 0
α : Type u_1,	_inst_1 : comm_monoid α,	a : α,	n_n : ℕ,	n_ih : associates.mk (a ^ n_n) = associates.mk a ^ n_n	⊢ associates.mk (a ^ n_n.succ) = associates.mk a ^ n_n.succ
α : Type u_1,	_inst_1 : comm_monoid α,	a : α,	n : ℕ	⊢ associates.mk (a ^ n) = associates.mk a ^ n
α : Type u_1,	_inst_1 : comm_monoid_with_zero α,	a b : α	⊢ dvd_not_unit (associates.mk a) (associates.mk b) ↔ dvd_not_unit a b
α : Type u_1,	_inst_1 : comm_monoid_with_zero α,	a b : α	⊢ ¬a = 0 → ((∃ (x : associates α), ¬is_unit x ∧ associates.mk b = associates.mk a * x) ↔ ∃ (x : α), ¬is_unit x ∧ b = a * x)
α : Type u_1,	_inst_1 : comm_monoid_with_zero α,	a b : α	⊢ (¬a = 0 ∧ ∃ (x : associates α), ¬is_unit x ∧ associates.mk b = associates.mk a * x) ↔ ¬a = 0 ∧ ∃ (x : α), ¬is_unit x ∧ b = a * x
α : Type u_1,	_inst_1 : comm_monoid_with_zero α,	a b : α,	ane0 : ¬a = 0	⊢ (∃ (x : associates α), ¬is_unit x ∧ associates.mk b = associates.mk a * x) ↔ ∃ (x : α), ¬is_unit x ∧ b = a * x
α : Type u_1,	_inst_1 : comm_monoid_with_zero α,	a b : α,	ane0 : ¬a = 0	⊢ (∀ (x : α), ¬is_unit x → b ≠ a * x) → ∀ (x : associates α), ¬is_unit x → associates.mk b ≠ associates.mk a * x
α : Type u_1,	_inst_1 : comm_monoid_with_zero α,	a b : α,	ane0 : ¬a = 0	⊢ (∃ (x : associates α), ¬is_unit x ∧ associates.mk b = associates.mk a * x) → (∃ (x : α), ¬is_unit x ∧ b = a * x)
α : Type u_1,	_inst_1 : comm_monoid_with_zero α,	a b : α,	ane0 : ¬a = 0	⊢ (∀ (x : α), ¬is_unit x → b ≠ a * x) → ∀ (a_1 : α), ¬is_unit (associates.mk a_1) → associates.mk b ≠ associates.mk a * associates.mk a_1
α : Type u_1,	_inst_1 : comm_monoid_with_zero α,	a b : α,	ane0 : ¬a = 0,	h : ∀ (x : α), ¬is_unit x → b ≠ a * x,	x : α,	hx : ¬is_unit (associates.mk x),	hbax : associates.mk b = associates.mk a * associates.mk x	⊢ false
α : Type u_1,	_inst_1 : comm_monoid_with_zero α,	a b : α,	ane0 : ¬a = 0,	h : ∀ (x : α), ¬is_unit x → b ≠ a * x,	x : α,	hx : ¬is_unit (associates.mk x),	hbax : b ~ᵤ a * x	⊢ false
α : Type u_1,	_inst_1 : comm_monoid_with_zero α,	a b : α,	ane0 : ¬a = 0,	h : ∀ (x : α), ¬is_unit x → b ≠ a * x,	x : α,	hx : ¬is_unit (associates.mk x),	u : units α,	hu : b * ↑u = a * x	⊢ false
α : Type u_1,	_inst_1 : comm_monoid_with_zero α,	a b : α,	ane0 : ¬a = 0,	h : ∀ (x : α), ¬is_unit x → b ≠ a * x,	x : α,	hx : ¬is_unit (associates.mk x),	u : units α,	hu : b * ↑u = a * x	⊢ ¬is_unit (x * ↑u⁻¹)
α : Type u_1,	_inst_1 : comm_monoid_with_zero α,	a b : α,	ane0 : ¬a = 0,	h : ∀ (x : α), ¬is_unit x → b ≠ a * x,	x : α,	u : units α,	hu : b * ↑u = a * x,	hx : ¬is_unit x	⊢ ¬is_unit (x * ↑u⁻¹)
α : Type u_1,	_inst_1 : comm_monoid_with_zero α,	a b : α,	ane0 : ¬a = 0,	h : ∀ (x : α), ¬is_unit x → b ≠ a * x,	x : α,	u : units α,	hu : b * ↑u = a * x,	hx : ¬is_unit x	⊢ ¬is_unit ?m_1		α : Type u_1,	_inst_1 : comm_monoid_with_zero α,	a b : α,	ane0 : ¬a = 0,	h : ∀ (x : α), ¬is_unit x → b ≠ a * x,	x : α,	u : units α,	hu : b * ↑u = a * x,	hx : ¬is_unit x	⊢ x * ↑u⁻¹ ~ᵤ ?m_1		α : Type u_1,	_inst_1 : comm_monoid_with_zero α,	a b : α,	ane0 : ¬a = 0,	h : ∀ (x : α), ¬is_unit x → b ≠ a * x,	x : α,	u : units α,	hu : b * ↑u = a * x,	hx : ¬is_unit x	⊢ α
α : Type u_1,	_inst_1 : comm_monoid_with_zero α,	a b : α,	ane0 : ¬a = 0,	h : ∀ (x : α), ¬is_unit x → b ≠ a * x,	x : α,	u : units α,	hu : b * ↑u = a * x,	hx : ¬is_unit x	⊢ x * ↑u⁻¹ ~ᵤ x
α : Type u_1,	_inst_1 : comm_monoid_with_zero α,	a b : α,	ane0 : ¬a = 0,	h : ∀ (x : α), ¬is_unit x → b ≠ a * x,	x : α,	hx : ¬is_unit (associates.mk x),	u : units α,	hu : b * ↑u = a * x	⊢ ¬is_unit (x * ↑u⁻¹)		α : Type u_1,	_inst_1 : comm_monoid_with_zero α,	a b : α,	ane0 : ¬a = 0,	h : ∀ (x : α), ¬is_unit x → b ≠ a * x,	x : α,	hx : ¬is_unit (associates.mk x),	u : units α,	hu : b * ↑u = a * x	⊢ b = a * (x * ↑u⁻¹)
α : Type u_1,	_inst_1 : comm_monoid_with_zero α,	a b : α,	ane0 : ¬a = 0,	h : ∀ (x : α), ¬is_unit x → b ≠ a * x,	x : α,	u : units α,	hu : b * ↑u = a * x,	hx : ¬is_unit x	⊢ x * ↑u⁻¹ * ↑u = x
α : Type u_1,	_inst_1 : comm_monoid_with_zero α,	a b : α,	ane0 : ¬a = 0	⊢ (∃ (x : associates α), ¬is_unit x ∧ associates.mk b = associates.mk a * x) → (∃ (x : α), ¬is_unit x ∧ b = a * x)		α : Type u_1,	_inst_1 : comm_monoid_with_zero α,	a b : α,	ane0 : ¬a = 0	⊢ (∃ (x : α), ¬is_unit x ∧ b = a * x) → (∃ (x : associates α), ¬is_unit x ∧ associates.mk b = associates.mk a * x)
α : Type u_1,	_inst_1 : comm_monoid_with_zero α,	a b : α,	ane0 : ¬a = 0,	h : ∀ (x : α), ¬is_unit x → b ≠ a * x,	x : α,	hx : ¬is_unit (associates.mk x),	u : units α,	hu : b * ↑u = a * x	⊢ b = a * (x * ↑u⁻¹)
α : Type u_1,	_inst_1 : comm_monoid_with_zero α,	a b : α,	ane0 : ¬a = 0	⊢ (∃ (x : α), ¬is_unit x ∧ b = a * x) → (∃ (x : associates α), ¬is_unit x ∧ associates.mk b = associates.mk a * x)
α : Type u_1,	_inst_1 : comm_monoid_with_zero α,	a : α,	ane0 : ¬a = 0,	x : α,	hx : ¬is_unit x	⊢ ∃ (x_1 : associates α), ¬is_unit x_1 ∧ associates.mk (a * x) = associates.mk a * x_1
α : Type u_1,	_inst_1 : comm_monoid_with_zero α,	a : α,	ane0 : ¬a = 0,	x : α,	hx : ¬is_unit x	⊢ ¬is_unit (associates.mk x) ∧ associates.mk (a * x) = associates.mk a * associates.mk x
β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	_inst_2 : decidable_eq α,	s : finset α,	f : α → β,	a : α,	h : a ∈ s	⊢ (∏ (x : α) in s.erase a, f x) * f a = ∏ (x : α) in s, f x
α : Type v,	M : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : comm_monoid M,	f : α → M,	prod_to_finset : ∀ {l : list α}, l.nodup → l.to_finset.prod f = (list.map f l).prod,	_x : list.nil.nodup	⊢ list.nil.to_finset.prod f = (list.map f list.nil).prod
α : Type v,	M : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : comm_monoid M,	f : α → M,	prod_to_finset : ∀ {l : list α}, l.nodup → l.to_finset.prod f = (list.map f l).prod,	a : α,	l : list α,	hl : (a :: l).nodup,	_let_match : a ∉ l ∧ l.nodup → (a :: l).to_finset.prod f = (list.map f (a :: l)).prod,	not_mem : a ∉ l,	hl : l.nodup	⊢ (a :: l).to_finset.prod f = (list.map f (a :: l)).prod
β : Type u,	α : Type v,	γ : Type w,	_inst_1 : comm_monoid β,	s : finset γ,	t : finset α,	f : γ → α → β	⊢ ∏ (x : γ) in s, ∏ (y : α) in t, f x y = ∏ (y : α) in t, ∏ (x : γ) in s, f x y
β : Type u,	α : Type v,	γ : Type w,	_inst_1 : comm_monoid β,	s : finset γ,	t : finset α,	f : γ → α → β,	_inst : Π (a : Prop), decidable a	⊢ ∏ (x : γ) in s, ∏ (y : α) in t, f x y = ∏ (y : α) in t, ∏ (x : γ) in s, f x y
β : Type u,	α : Type v,	γ : Type w,	_inst_1 : comm_monoid β,	s : finset γ,	t : finset α,	f : γ → α → β,	_inst : Π (a : Prop), decidable a	⊢ ∏ (x : γ) in ∅, ∏ (y : α) in t, f x y = ∏ (y : α) in t, ∏ (x : γ) in ∅, f x y		β : Type u,	α : Type v,	γ : Type w,	_inst_1 : comm_monoid β,	s : finset γ,	t : finset α,	f : γ → α → β,	_inst : Π (a : Prop), decidable a	⊢ ∀ ⦃a : γ⦄ {s : finset γ}, a ∉ s → ∏ (x : γ) in s, ∏ (y : α) in t, f x y = ∏ (y : α) in t, ∏ (x : γ) in s, f x y → ∏ (x : γ) in has_insert.insert a s, ∏ (y : α) in t, f x y = ∏ (y : α) in t, ∏ (x : γ) in has_insert.insert a s, f x y
β : Type u,	α : Type v,	γ : Type w,	_inst_1 : comm_monoid β,	s : finset γ,	t : finset α,	f : γ → α → β,	_inst : Π (a : Prop), decidable a	⊢ ∏ (x : γ) in ∅, ∏ (y : α) in t, f x y = ∏ (y : α) in t, ∏ (x : γ) in ∅, f x y
β : Type u,	α : Type v,	γ : Type w,	_inst_1 : comm_monoid β,	s : finset γ,	t : finset α,	f : γ → α → β,	_inst : Π (a : Prop), decidable a	⊢ ∀ ⦃a : γ⦄ {s : finset γ}, a ∉ s → ∏ (x : γ) in s, ∏ (y : α) in t, f x y = ∏ (y : α) in t, ∏ (x : γ) in s, f x y → ∏ (x : γ) in has_insert.insert a s, ∏ (y : α) in t, f x y = ∏ (y : α) in t, ∏ (x : γ) in has_insert.insert a s, f x y
β : Type u,	α : Type v,	γ : Type w,	_inst_1 : comm_monoid β,	s : finset γ,	t : finset α,	f : γ → α → β,	_inst : Π (a : Prop), decidable a,	a : γ,	s_1 : finset γ,	H : a ∉ s_1,	ih : ∏ (x : γ) in s_1, ∏ (y : α) in t, f x y = ∏ (y : α) in t, ∏ (x : γ) in s_1, f x y	⊢ ∏ (x : γ) in has_insert.insert a s_1, ∏ (y : α) in t, f x y = ∏ (y : α) in t, ∏ (x : γ) in has_insert.insert a s_1, f x y
β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	s : finset α,	f : α → β,	a b : α,	hn : a ≠ b,	h₀ : ∀ (c : α), c ∈ s → c ≠ a ∧ c ≠ b → f c = 1,	ha : a ∉ s → f a = 1,	hb : b ∉ s → f b = 1	⊢ ∏ (x : α) in s, f x = f a * f b
β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	s : finset α,	f : α → β,	a b : α,	hn : a ≠ b,	h₀ : ∀ (c : α), c ∈ s → c ≠ a ∧ c ≠ b → f c = 1,	ha : a ∉ s → f a = 1,	hb : b ∉ s → f b = 1	⊢ ∏ (x : α) in s, f x = f a * f b
β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	s : finset α,	f : α → β,	a b : α,	hn : a ≠ b,	h₀ : ∀ (c : α), c ∈ s → c ≠ a ∧ c ≠ b → f c = 1,	ha : a ∉ s → f a = 1,	hb : b ∉ s → f b = 1	⊢ ∏ (x : α) in s, f x = f a * f b
β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	s : finset α,	f : α → β,	a b : α,	hn : a ≠ b,	h₀ : ∀ (c : α), c ∈ s → c ≠ a ∧ c ≠ b → f c = 1,	ha : a ∉ s → f a = 1,	hb : b ∉ s → f b = 1,	_inst : decidable_eq α,	h₁ : a ∈ s	⊢ ∏ (x : α) in s, f x = f a * f b
β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	s : finset α,	f : α → β,	a b : α,	hn : a ≠ b,	h₀ : ∀ (c : α), c ∈ s → c ≠ a ∧ c ≠ b → f c = 1,	ha : a ∉ s → f a = 1,	hb : b ∉ s → f b = 1,	_inst : decidable_eq α,	h₁ : a ∉ s	⊢ ∏ (x : α) in s, f x = f a * f b
β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	s : finset α,	f : α → β,	a b : α,	hn : a ≠ b,	h₀ : ∀ (c : α), c ∈ s → c ≠ a ∧ c ≠ b → f c = 1,	ha : a ∉ s → f a = 1,	hb : b ∉ s → f b = 1,	_inst : decidable_eq α	⊢ ∏ (x : α) in s, f x = f a * f b
β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	s : finset α,	f : α → β,	a b : α,	hn : a ≠ b,	h₀ : ∀ (c : α), c ∈ s → c ≠ a ∧ c ≠ b → f c = 1,	ha : a ∉ s → f a = 1,	hb : b ∉ s → f b = 1,	_inst : decidable_eq α,	h₁ : a ∈ s,	h₂ : b ∈ s	⊢ ∏ (x : α) in s, f x = f a * f b		β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	s : finset α,	f : α → β,	a b : α,	hn : a ≠ b,	h₀ : ∀ (c : α), c ∈ s → c ≠ a ∧ c ≠ b → f c = 1,	ha : a ∉ s → f a = 1,	hb : b ∉ s → f b = 1,	_inst : decidable_eq α,	h₁ : a ∈ s,	h₂ : b ∉ s	⊢ ∏ (x : α) in s, f x = f a * f b		β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	s : finset α,	f : α → β,	a b : α,	hn : a ≠ b,	h₀ : ∀ (c : α), c ∈ s → c ≠ a ∧ c ≠ b → f c = 1,	ha : a ∉ s → f a = 1,	hb : b ∉ s → f b = 1,	_inst : decidable_eq α,	h₁ : a ∉ s,	h₂ : b ∈ s	⊢ ∏ (x : α) in s, f x = f a * f b		β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	s : finset α,	f : α → β,	a b : α,	hn : a ≠ b,	h₀ : ∀ (c : α), c ∈ s → c ≠ a ∧ c ≠ b → f c = 1,	ha : a ∉ s → f a = 1,	hb : b ∉ s → f b = 1,	_inst : decidable_eq α,	h₁ : a ∉ s,	h₂ : b ∉ s	⊢ ∏ (x : α) in s, f x = f a * f b
β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	s : finset α,	f : α → β,	a b : α,	hn : a ≠ b,	h₀ : ∀ (c : α), c ∈ s → c ≠ a ∧ c ≠ b → f c = 1,	ha : a ∉ s → f a = 1,	hb : b ∉ s → f b = 1,	_inst : decidable_eq α,	h₁ : a ∈ s,	h₂ : b ∈ s	⊢ ∏ (x : α) in s, f x = f a * f b
β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	s : finset α,	f : α → β,	a b : α,	hn : a ≠ b,	h₀ : ∀ (c : α), c ∈ s → c ≠ a ∧ c ≠ b → f c = 1,	ha : a ∉ s → f a = 1,	hb : b ∉ s → f b = 1,	_inst : decidable_eq α,	h₁ : a ∈ s,	h₂ : b ∉ s	⊢ ∏ (x : α) in s, f x = f a * f b
β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	s : finset α,	f : α → β,	a b : α,	hn : a ≠ b,	h₀ : ∀ (c : α), c ∈ s → c ≠ a ∧ c ≠ b → f c = 1,	ha : a ∉ s → f a = 1,	hb : b ∉ s → f b = 1,	_inst : decidable_eq α,	h₁ : a ∈ s,	h₂ : b ∉ s	⊢ ∏ (x : α) in s, f x = f a
β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	s : finset α,	f : α → β,	a b : α,	hn : a ≠ b,	h₀ : ∀ (c : α), c ∈ s → c ≠ a ∧ c ≠ b → f c = 1,	ha : a ∉ s → f a = 1,	hb : b ∉ s → f b = 1,	_inst : decidable_eq α,	h₁ : a ∈ s,	h₂ : b ∉ s	⊢ ∀ (b : α), b ∈ s → b ≠ a → f b = 1
β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	s : finset α,	f : α → β,	a b : α,	hn : a ≠ b,	h₀ : ∀ (c : α), c ∈ s → c ≠ a ∧ c ≠ b → f c = 1,	ha : a ∉ s → f a = 1,	hb : b ∉ s → f b = 1,	_inst : decidable_eq α,	h₁ : a ∈ s,	h₂ : b ∉ s	⊢ ∏ (x : α) in s, f x = f a * f b		β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	s : finset α,	f : α → β,	a b : α,	hn : a ≠ b,	h₀ : ∀ (c : α), c ∈ s → c ≠ a ∧ c ≠ b → f c = 1,	ha : a ∉ s → f a = 1,	hb : b ∉ s → f b = 1,	_inst : decidable_eq α,	h₁ : a ∉ s,	h₂ : b ∈ s	⊢ ∏ (x : α) in s, f x = f a * f b		β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	s : finset α,	f : α → β,	a b : α,	hn : a ≠ b,	h₀ : ∀ (c : α), c ∈ s → c ≠ a ∧ c ≠ b → f c = 1,	ha : a ∉ s → f a = 1,	hb : b ∉ s → f b = 1,	_inst : decidable_eq α,	h₁ : a ∉ s,	h₂ : b ∉ s	⊢ ∏ (x : α) in s, f x = f a * f b
β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	s : finset α,	f : α → β,	a b : α,	hn : a ≠ b,	h₀ : ∀ (c : α), c ∈ s → c ≠ a ∧ c ≠ b → f c = 1,	ha : a ∉ s → f a = 1,	hb : b ∉ s → f b = 1,	_inst : decidable_eq α,	h₁ : a ∉ s,	h₂ : b ∈ s	⊢ ∏ (x : α) in s, f x = f a * f b
β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	s : finset α,	f : α → β,	a b : α,	hn : a ≠ b,	h₀ : ∀ (c : α), c ∈ s → c ≠ a ∧ c ≠ b → f c = 1,	ha : a ∉ s → f a = 1,	hb : b ∉ s → f b = 1,	_inst : decidable_eq α,	h₁ : a ∉ s,	h₂ : b ∈ s	⊢ ∏ (x : α) in s, f x = f b
β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	s : finset α,	f : α → β,	a b : α,	hn : a ≠ b,	h₀ : ∀ (c : α), c ∈ s → c ≠ a ∧ c ≠ b → f c = 1,	ha : a ∉ s → f a = 1,	hb : b ∉ s → f b = 1,	_inst : decidable_eq α,	h₁ : a ∉ s,	h₂ : b ∈ s	⊢ ∀ (b_1 : α), b_1 ∈ s → b_1 ≠ b → f b_1 = 1
β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	s : finset α,	f : α → β,	a b : α,	hn : a ≠ b,	h₀ : ∀ (c : α), c ∈ s → c ≠ a ∧ c ≠ b → f c = 1,	ha : a ∉ s → f a = 1,	hb : b ∉ s → f b = 1,	_inst : decidable_eq α,	h₁ : a ∉ s,	h₂ : b ∈ s	⊢ ∏ (x : α) in s, f x = f a * f b		β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	s : finset α,	f : α → β,	a b : α,	hn : a ≠ b,	h₀ : ∀ (c : α), c ∈ s → c ≠ a ∧ c ≠ b → f c = 1,	ha : a ∉ s → f a = 1,	hb : b ∉ s → f b = 1,	_inst : decidable_eq α,	h₁ : a ∉ s,	h₂ : b ∉ s	⊢ ∏ (x : α) in s, f x = f a * f b
β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	s : finset α,	f : α → β,	a b : α,	hn : a ≠ b,	h₀ : ∀ (c : α), c ∈ s → c ≠ a ∧ c ≠ b → f c = 1,	ha : a ∉ s → f a = 1,	hb : b ∉ s → f b = 1,	_inst : decidable_eq α,	h₁ : a ∉ s,	h₂ : b ∉ s	⊢ ∏ (x : α) in s, f x = f a * f b
β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	s : finset α,	f : α → β,	a b : α,	hn : a ≠ b,	h₀ : ∀ (c : α), c ∈ s → c ≠ a ∧ c ≠ b → f c = 1,	ha : a ∉ s → f a = 1,	hb : b ∉ s → f b = 1,	_inst : decidable_eq α,	h₁ : a ∉ s,	h₂ : b ∉ s	⊢ ∏ (x : α) in s, f x = 1
β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	_inst_2 : decidable_eq α,	s : finset α,	a : α,	b : Π (x : α), x = a → β	⊢ ∏ (x : α) in s, dite (x = a) (λ (h : x = a), b x h) (λ (h : ¬x = a), 1) = ite (a ∈ s) (b a rfl) 1
β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	_inst_2 : decidable_eq α,	s : finset α,	a : α,	b : Π (x : α), x = a → β,	h : a ∈ s	⊢ ∏ (x : α) in s, dite (x = a) (b x) (λ (h : ¬x = a), 1) = b a rfl
β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	_inst_2 : decidable_eq α,	s : finset α,	a : α,	b : Π (x : α), x = a → β,	h : a ∈ s,	b_1 : α,	H : b_1 ∈ s,	ᾰ : b_1 ≠ a	⊢ dite (b_1 = a) (b b_1) (λ (h : ¬b_1 = a), 1) = 1
β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	_inst_2 : decidable_eq α,	s : finset α,	a : α,	b : Π (x : α), x = a → β,	h : a ∈ s,	b_1 : α,	H : b_1 ∈ s,	ᾰ : b_1 ≠ a	⊢ ¬b_1 = a
β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	_inst_2 : decidable_eq α,	s : finset α,	a : α,	b : Π (x : α), x = a → β,	h : a ∈ s	⊢ ∀ (b_1 : α), b_1 ∈ s → b_1 ≠ a → dite (b_1 = a) (b b_1) (λ (h : ¬b_1 = a), 1) = 1		β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	_inst_2 : decidable_eq α,	s : finset α,	a : α,	b : Π (x : α), x = a → β,	h : a ∈ s	⊢ a ∉ s → dite (a = a) (b a) (λ (h : ¬a = a), 1) = 1
β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	_inst_2 : decidable_eq α,	s : finset α,	a : α,	b : Π (x : α), x = a → β,	h : a ∈ s	⊢ ∀ (b_1 : α), b_1 ∈ s → b_1 ≠ a → dite (b_1 = a) (b b_1) (λ (h : ¬b_1 = a), 1) = 1
β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	_inst_2 : decidable_eq α,	s : finset α,	a : α,	b : Π (x : α), x = a → β,	h : a ∈ s	⊢ ∏ (x : α) in s, dite (x = a) (b x) (λ (h : ¬x = a), 1) = b a rfl		β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	_inst_2 : decidable_eq α,	s : finset α,	a : α,	b : Π (x : α), x = a → β,	h : a ∉ s	⊢ ∏ (x : α) in s, dite (x = a) (b x) (λ (h : ¬x = a), 1) = 1
β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	_inst_2 : decidable_eq α,	s : finset α,	a : α,	b : Π (x : α), x = a → β,	h : a ∈ s	⊢ a ∉ s → dite (a = a) (b a) (λ (h : ¬a = a), 1) = 1
β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	_inst_2 : decidable_eq α,	s : finset α,	a : α,	b : Π (x : α), x = a → β,	h : a ∉ s	⊢ ∏ (x : α) in s, dite (x = a) (b x) (λ (h : ¬x = a), 1) = 1
β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	_inst_2 : decidable_eq α,	s : finset α,	a : α,	b : Π (x : α), x = a → β,	h : a ∉ s,	x : α,	H : x ∈ s	⊢ dite (x = a) (b x) (λ (h : ¬x = a), 1) = 1
β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	_inst_2 : decidable_eq α,	s : finset α,	a : α,	b : Π (x : α), x = a → β,	h : a ∉ s,	x : α,	H : x ∈ s	⊢ ¬x = a
β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	_inst_2 : decidable_eq α,	s : finset α,	a : α,	b : Π (x : α), x = a → β,	h : a ∉ s,	x : α,	H : x ∈ s,	ᾰ : x = a	⊢ false
β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	_inst_2 : decidable_eq α,	s : finset α,	a : α,	b : Π (x : α), x = a → β,	h : a ∉ s	⊢ ∀ (x : α), x ∈ s → dite (x = a) (b x) (λ (h : ¬x = a), 1) = 1
M : Type u_1,	_inst_1 : add_comm_monoid M,	n : ℕ,	v : fin n.succ → M	⊢ ∑ (i : fin n.succ) in finset.filter (λ (i : fin n.succ), 0 < i) finset.univ, v i = ∑ (j : fin n), v j.succ
ι : Sort u_5,	R : Type u_1,	M : Type u_2,	_inst_3 : ring R,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	_inst_6 : no_zero_smul_divisors R M,	f : ι → R	⊢ (∑ᶠ (i : ι), f i) • 0 = ∑ᶠ (i : ι), f i • 0
ι : Sort u_5,	R : Type u_1,	M : Type u_2,	_inst_3 : ring R,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	_inst_6 : no_zero_smul_divisors R M,	f : ι → R,	x : M	⊢ (∑ᶠ (i : ι), f i) • x = ∑ᶠ (i : ι), f i • x
ι : Sort u_5,	R : Type u_1,	M : Type u_2,	_inst_3 : ring R,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	_inst_6 : no_zero_smul_divisors R M,	f : ι → R	⊢ (∑ᶠ (i : ι), f i) • 0 = ∑ᶠ (i : ι), f i • 0		ι : Sort u_5,	R : Type u_1,	M : Type u_2,	_inst_3 : ring R,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	_inst_6 : no_zero_smul_divisors R M,	f : ι → R,	x : M,	hx : x ≠ 0	⊢ (∑ᶠ (i : ι), f i) • x = ∑ᶠ (i : ι), f i • x
ι : Sort u_5,	R : Type u_1,	M : Type u_2,	_inst_3 : ring R,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	_inst_6 : no_zero_smul_divisors R M,	f : ι → R,	x : M,	hx : x ≠ 0	⊢ (∑ᶠ (i : ι), f i) • x = ∑ᶠ (i : ι), f i • x
α : Type u_1,	M : Type u_4,	_inst_1 : comm_monoid M,	f : α → M,	t : set α,	ht : t.finite,	s : finset α	⊢ (∏ᶠ (i : α) (H : i ∈ ↑s ∪ t), f i) * ∏ᶠ (i : α) (H : i ∈ ↑s ∩ t), f i = (∏ᶠ (i : α) (H : i ∈ ↑s), f i) * ∏ᶠ (i : α) (H : i ∈ t), f i
α : Type u_1,	M : Type u_4,	_inst_1 : comm_monoid M,	f : α → M,	s t : set α,	hs : s.finite,	ht : t.finite	⊢ (∏ᶠ (i : α) (H : i ∈ s ∪ t), f i) * ∏ᶠ (i : α) (H : i ∈ s ∩ t), f i = (∏ᶠ (i : α) (H : i ∈ s), f i) * ∏ᶠ (i : α) (H : i ∈ t), f i
α : Type u_1,	M : Type u_4,	_inst_1 : comm_monoid M,	f : α → M,	s t : finset α	⊢ (∏ᶠ (i : α) (H : i ∈ ↑s ∪ ↑t), f i) * ∏ᶠ (i : α) (H : i ∈ ↑s ∩ ↑t), f i = (∏ᶠ (i : α) (H : i ∈ ↑s), f i) * ∏ᶠ (i : α) (H : i ∈ ↑t), f i
α : Type u_1,	M : Type u_4,	_inst_1 : comm_monoid M,	f : α → M,	s t : finset α,	_inst : Π (a : Prop), decidable a	⊢ (∏ᶠ (i : α) (H : i ∈ ↑s ∪ ↑t), f i) * ∏ᶠ (i : α) (H : i ∈ ↑s ∩ ↑t), f i = (∏ᶠ (i : α) (H : i ∈ ↑s), f i) * ∏ᶠ (i : α) (H : i ∈ ↑t), f i
α : Type u_1,	M : Type u_4,	_inst_1 : comm_monoid M,	f : α → M,	s t : finset α,	_inst : Π (a : Prop), decidable a	⊢ (∏ᶠ (i : α) (H : i ∈ ↑(s ∪ t)), f i) * ∏ᶠ (i : α) (H : i ∈ ↑(s ∩ t)), f i = (∏ᶠ (i : α) (H : i ∈ ↑s), f i) * ∏ᶠ (i : α) (H : i ∈ ↑t), f i
M : Type u_1,	_inst_1 : comm_monoid M,	n : ℕ,	f : ℕ × ℕ → M	⊢ ∏ (p : ℕ × ℕ) in finset.nat.antidiagonal (n + 1), f p = f (n + 1, 0) * ∏ (p : ℕ × ℕ) in finset.nat.antidiagonal n, f (p.fst, p.snd + 1)
M : Type u_1,	_inst_1 : comm_monoid M,	n : ℕ,	f : ℕ × ℕ → M	⊢ f (0, n + 1).swap * ∏ (p : ℕ × ℕ) in finset.nat.antidiagonal n, f (p.swap.fst + 1, p.swap.snd).swap = f (n + 1, 0) * ∏ (p : ℕ × ℕ) in finset.nat.antidiagonal n, f (p.fst, p.snd + 1)
α : Type u_1,	β : Type u_2,	_inst_2 : ordered_comm_monoid β,	s : finset α,	f : α → β,	n : β,	h : ∀ (x : α), x ∈ s → f x ≤ n	⊢ s.prod f ≤ n ^ s.card
α : Type u_1,	β : Type u_2,	_inst_2 : ordered_comm_monoid β,	s : finset α,	f : α → β,	n : β,	h : ∀ (x : α), x ∈ s → f x ≤ n	⊢ ∀ (x : β), x ∈ multiset.map f s.val → x ≤ n		α : Type u_1,	β : Type u_2,	_inst_2 : ordered_comm_monoid β,	s : finset α,	f : α → β,	n : β,	h : ∀ (x : α), x ∈ s → f x ≤ n	⊢ n ^ ⇑multiset.card (multiset.map f s.val) ≤ n ^ s.card
α : Type u_1,	β : Type u_2,	_inst_2 : ordered_comm_monoid β,	s : finset α,	f : α → β,	n : β,	h : ∀ (x : α), x ∈ s → f x ≤ n	⊢ ∀ (x : β), x ∈ multiset.map f s.val → x ≤ n
α : Type u_1,	β : Type u_2,	_inst_2 : ordered_comm_monoid β,	s : finset α,	f : α → β,	n : β,	h : ∀ (x : α), x ∈ s → f x ≤ n	⊢ n ^ ⇑multiset.card (multiset.map f s.val) ≤ n ^ s.card
ι : Type u_1,	M : Type u_4,	_inst_1 : ordered_add_comm_monoid M,	s : finset ι,	f : ι → with_top M	⊢ ∑ (i : ι) in s, f i = ⊤ ↔ ∃ (i : ι) (H : i ∈ s), f i = ⊤
ι : Type u_1,	M : Type u_4,	_inst_1 : ordered_add_comm_monoid M,	s : finset ι,	f : ι → with_top M,	_inst : Π (a : Prop), decidable a	⊢ ∑ (i : ι) in s, f i = ⊤ ↔ ∃ (i : ι) (H : i ∈ s), f i = ⊤
ι : Type u_1,	M : Type u_4,	_inst_1 : ordered_add_comm_monoid M,	s : finset ι,	f : ι → with_top M,	_inst : Π (a : Prop), decidable a	⊢ ∑ (i : ι) in s, f i = ⊤ → (∃ (i : ι) (H : i ∈ s), f i = ⊤)
ι : Type u_1,	M : Type u_4,	_inst_1 : ordered_add_comm_monoid M,	s : finset ι,	f : ι → with_top M,	_inst : Π (a : Prop), decidable a	⊢ ∑ (i : ι) in s, f i = ⊤ → (∃ (i : ι) (H : i ∈ s), f i = ⊤)		ι : Type u_1,	M : Type u_4,	_inst_1 : ordered_add_comm_monoid M,	s : finset ι,	f : ι → with_top M,	_inst : Π (a : Prop), decidable a	⊢ (∃ (i : ι) (H : i ∈ s), f i = ⊤) → ∑ (i : ι) in s, f i = ⊤
ι : Type u_1,	M : Type u_4,	_inst_1 : ordered_add_comm_monoid M,	s : finset ι,	f : ι → with_top M,	_inst : Π (a : Prop), decidable a	⊢ (∀ (i : ι), i ∈ s → f i ≠ ⊤) → ∑ (i : ι) in s, f i ≠ ⊤
ι : Type u_1,	M : Type u_4,	_inst_1 : ordered_add_comm_monoid M,	s : finset ι,	f : ι → with_top M,	_inst : Π (a : Prop), decidable a	⊢ (∃ (i : ι) (H : i ∈ s), f i = ⊤) → ∑ (i : ι) in s, f i = ⊤
ι : Type u_1,	M : Type u_4,	_inst_1 : ordered_add_comm_monoid M,	s : finset ι,	f : ι → with_top M,	_inst : Π (a : Prop), decidable a,	i : ι,	his : i ∈ s,	hi : f i = ⊤	⊢ ∑ (i : ι) in s, f i = ⊤
ι : Type u_1,	M : Type u_4,	_inst_1 : ordered_add_comm_monoid M,	s : finset ι,	f : ι → with_top M	⊢ ∑ (i : ι) in s, f i < ⊤ ↔ ∀ (i : ι), i ∈ s → f i < ⊤
R : Type u,	_inst_1 : comm_ring R,	X Y : Algebra R,	f : X ⟶ Y,	_x : category_theory.is_iso ((category_theory.forget (Algebra R)).map f)	⊢ category_theory.is_iso f
R : Type u,	_inst_1 : comm_ring R,	X Y : Algebra R,	f : X ⟶ Y,	_x : category_theory.is_iso ((category_theory.forget (Algebra R)).map f)	⊢ category_theory.is_iso f
R : Type u,	_inst_1 : comm_ring R,	X Y : Algebra R,	f : X ⟶ Y,	_x : category_theory.is_iso ((category_theory.forget (Algebra R)).map f),	i : (category_theory.forget (Algebra R)).obj X ≅ (category_theory.forget (Algebra R)).obj Y := category_theory.as_iso ((category_theory.forget (Algebra R)).map f)	⊢ category_theory.is_iso f
R : Type u,	_inst_1 : comm_ring R,	X Y : Algebra R,	f : X ⟶ Y,	_x : category_theory.is_iso ((category_theory.forget (Algebra R)).map f),	i : (category_theory.forget (Algebra R)).obj X ≅ (category_theory.forget (Algebra R)).obj Y := category_theory.as_iso ((category_theory.forget (Algebra R)).map f),	e : ↥X ≃ₐ[R] ↥Y := {to_fun := f.to_fun, inv_fun := i.to_equiv.inv_fun, left_inv := _, right_inv := _, map_mul' := _, map_add' := _, commutes' := _}	⊢ category_theory.is_iso f
R : Type u,	_inst_1 : comm_ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Algebra R	⊢ category_theory.limits.is_limit (Algebra.has_limits.limit_cone F)
R : Type u,	_inst_1 : comm_ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Algebra R,	s : category_theory.limits.cone F	⊢ ⟨λ (j : J), ((category_theory.forget (Algebra R)).map_cone s).π.app j 1, _⟩ = 1
R : Type u,	_inst_1 : comm_ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Algebra R,	s : category_theory.limits.cone F	⊢ ⟨λ (j : J), 1, _⟩ = 1
R : Type u,	_inst_1 : comm_ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Algebra R,	s : category_theory.limits.cone F	⊢ ⟨λ (j : J), ((category_theory.forget (Algebra R)).map_cone s).π.app j 1, _⟩ = 1		R : Type u,	_inst_1 : comm_ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Algebra R,	s : category_theory.limits.cone F	⊢ ∀ (x y : ↥(s.X)), ⟨λ (j : J), ((category_theory.forget (Algebra R)).map_cone s).π.app j (x * y), _⟩ = ⟨λ (j : J), ((category_theory.forget (Algebra R)).map_cone s).π.app j x, _⟩ * ⟨λ (j : J), ((category_theory.forget (Algebra R)).map_cone s).π.app j y, _⟩		R : Type u,	_inst_1 : comm_ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Algebra R,	s : category_theory.limits.cone F	⊢ ⟨λ (j : J), ((category_theory.forget (Algebra R)).map_cone s).π.app j 0, _⟩ = 0		R : Type u,	_inst_1 : comm_ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Algebra R,	s : category_theory.limits.cone F	⊢ ∀ (x y : ↥(s.X)), ⟨λ (j : J), ((category_theory.forget (Algebra R)).map_cone s).π.app j (x + y), _⟩ = ⟨λ (j : J), ((category_theory.forget (Algebra R)).map_cone s).π.app j x, _⟩ + ⟨λ (j : J), ((category_theory.forget (Algebra R)).map_cone s).π.app j y, _⟩		R : Type u,	_inst_1 : comm_ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Algebra R,	s : category_theory.limits.cone F	⊢ ∀ (r : R), ⟨λ (j : J), ((category_theory.forget (Algebra R)).map_cone s).π.app j (⇑(algebra_map R ↥(s.X)) r), _⟩ = ⇑(algebra_map R ↥((Algebra.has_limits.limit_cone F).X)) r
R : Type u,	_inst_1 : comm_ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Algebra R,	s : category_theory.limits.cone F,	x y : ↥(s.X)	⊢ ⟨λ (j : J), ((category_theory.forget (Algebra R)).map_cone s).π.app j (x * y), _⟩ = ⟨λ (j : J), ((category_theory.forget (Algebra R)).map_cone s).π.app j x, _⟩ * ⟨λ (j : J), ((category_theory.forget (Algebra R)).map_cone s).π.app j y, _⟩
R : Type u,	_inst_1 : comm_ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Algebra R,	s : category_theory.limits.cone F	⊢ ∀ (x y : ↥(s.X)), ⟨λ (j : J), ((category_theory.forget (Algebra R)).map_cone s).π.app j (x * y), _⟩ = ⟨λ (j : J), ((category_theory.forget (Algebra R)).map_cone s).π.app j x, _⟩ * ⟨λ (j : J), ((category_theory.forget (Algebra R)).map_cone s).π.app j y, _⟩
R : Type u,	_inst_1 : comm_ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Algebra R,	s : category_theory.limits.cone F,	x y : ↥(s.X)	⊢ ⟨λ (j : J), ⇑(s.π.app j) x * ⇑(s.π.app j) y, _⟩ = ⟨λ (j : J), ⇑(s.π.app j) x, _⟩ * ⟨λ (j : J), ⇑(s.π.app j) y, _⟩
R : Type u,	_inst_1 : comm_ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Algebra R,	s : category_theory.limits.cone F	⊢ ∀ (x y : ↥(s.X)), ⟨λ (j : J), ((category_theory.forget (Algebra R)).map_cone s).π.app j (x * y), _⟩ = ⟨λ (j : J), ((category_theory.forget (Algebra R)).map_cone s).π.app j x, _⟩ * ⟨λ (j : J), ((category_theory.forget (Algebra R)).map_cone s).π.app j y, _⟩		R : Type u,	_inst_1 : comm_ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Algebra R,	s : category_theory.limits.cone F	⊢ ⟨λ (j : J), ((category_theory.forget (Algebra R)).map_cone s).π.app j 0, _⟩ = 0		R : Type u,	_inst_1 : comm_ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Algebra R,	s : category_theory.limits.cone F	⊢ ∀ (x y : ↥(s.X)), ⟨λ (j : J), ((category_theory.forget (Algebra R)).map_cone s).π.app j (x + y), _⟩ = ⟨λ (j : J), ((category_theory.forget (Algebra R)).map_cone s).π.app j x, _⟩ + ⟨λ (j : J), ((category_theory.forget (Algebra R)).map_cone s).π.app j y, _⟩		R : Type u,	_inst_1 : comm_ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Algebra R,	s : category_theory.limits.cone F	⊢ ∀ (r : R), ⟨λ (j : J), ((category_theory.forget (Algebra R)).map_cone s).π.app j (⇑(algebra_map R ↥(s.X)) r), _⟩ = ⇑(algebra_map R ↥((Algebra.has_limits.limit_cone F).X)) r
R : Type u,	_inst_1 : comm_ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Algebra R,	s : category_theory.limits.cone F	⊢ ⟨λ (j : J), ((category_theory.forget (Algebra R)).map_cone s).π.app j 0, _⟩ = 0
R : Type u,	_inst_1 : comm_ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Algebra R,	s : category_theory.limits.cone F	⊢ ⟨λ (j : J), 0, _⟩ = 0
R : Type u,	_inst_1 : comm_ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Algebra R,	s : category_theory.limits.cone F	⊢ ⟨λ (j : J), ((category_theory.forget (Algebra R)).map_cone s).π.app j 0, _⟩ = 0		R : Type u,	_inst_1 : comm_ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Algebra R,	s : category_theory.limits.cone F	⊢ ∀ (x y : ↥(s.X)), ⟨λ (j : J), ((category_theory.forget (Algebra R)).map_cone s).π.app j (x + y), _⟩ = ⟨λ (j : J), ((category_theory.forget (Algebra R)).map_cone s).π.app j x, _⟩ + ⟨λ (j : J), ((category_theory.forget (Algebra R)).map_cone s).π.app j y, _⟩		R : Type u,	_inst_1 : comm_ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Algebra R,	s : category_theory.limits.cone F	⊢ ∀ (r : R), ⟨λ (j : J), ((category_theory.forget (Algebra R)).map_cone s).π.app j (⇑(algebra_map R ↥(s.X)) r), _⟩ = ⇑(algebra_map R ↥((Algebra.has_limits.limit_cone F).X)) r
R : Type u,	_inst_1 : comm_ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Algebra R,	s : category_theory.limits.cone F,	x y : ↥(s.X)	⊢ ⟨λ (j : J), ((category_theory.forget (Algebra R)).map_cone s).π.app j (x + y), _⟩ = ⟨λ (j : J), ((category_theory.forget (Algebra R)).map_cone s).π.app j x, _⟩ + ⟨λ (j : J), ((category_theory.forget (Algebra R)).map_cone s).π.app j y, _⟩
R : Type u,	_inst_1 : comm_ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Algebra R,	s : category_theory.limits.cone F	⊢ ∀ (x y : ↥(s.X)), ⟨λ (j : J), ((category_theory.forget (Algebra R)).map_cone s).π.app j (x + y), _⟩ = ⟨λ (j : J), ((category_theory.forget (Algebra R)).map_cone s).π.app j x, _⟩ + ⟨λ (j : J), ((category_theory.forget (Algebra R)).map_cone s).π.app j y, _⟩
R : Type u,	_inst_1 : comm_ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Algebra R,	s : category_theory.limits.cone F,	x y : ↥(s.X)	⊢ ⟨λ (j : J), ⇑(s.π.app j) x + ⇑(s.π.app j) y, _⟩ = ⟨λ (j : J), ⇑(s.π.app j) x, _⟩ + ⟨λ (j : J), ⇑(s.π.app j) y, _⟩
R : Type u,	_inst_1 : comm_ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Algebra R,	s : category_theory.limits.cone F	⊢ ∀ (x y : ↥(s.X)), ⟨λ (j : J), ((category_theory.forget (Algebra R)).map_cone s).π.app j (x + y), _⟩ = ⟨λ (j : J), ((category_theory.forget (Algebra R)).map_cone s).π.app j x, _⟩ + ⟨λ (j : J), ((category_theory.forget (Algebra R)).map_cone s).π.app j y, _⟩		R : Type u,	_inst_1 : comm_ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Algebra R,	s : category_theory.limits.cone F	⊢ ∀ (r : R), ⟨λ (j : J), ((category_theory.forget (Algebra R)).map_cone s).π.app j (⇑(algebra_map R ↥(s.X)) r), _⟩ = ⇑(algebra_map R ↥((Algebra.has_limits.limit_cone F).X)) r
R : Type u,	_inst_1 : comm_ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Algebra R,	s : category_theory.limits.cone F,	r : R	⊢ ⟨λ (j : J), ((category_theory.forget (Algebra R)).map_cone s).π.app j (⇑(algebra_map R ↥(s.X)) r), _⟩ = ⇑(algebra_map R ↥((Algebra.has_limits.limit_cone F).X)) r
R : Type u,	_inst_1 : comm_ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Algebra R,	s : category_theory.limits.cone F,	r : R,	j : J	⊢ ↑⟨λ (j : J), ((category_theory.forget (Algebra R)).map_cone s).π.app j (⇑(algebra_map R ↥(s.X)) r), _⟩ j = ↑(⇑(algebra_map R ↥((Algebra.has_limits.limit_cone F).X)) r) j
R : Type u,	_inst_1 : comm_ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Algebra R,	s : category_theory.limits.cone F	⊢ ∀ (r : R), ⟨λ (j : J), ((category_theory.forget (Algebra R)).map_cone s).π.app j (⇑(algebra_map R ↥(s.X)) r), _⟩ = ⇑(algebra_map R ↥((Algebra.has_limits.limit_cone F).X)) r
R S : CommRing,	i : R ⟶ S,	r : ↥R,	h : r = 0	⊢ ⇑i r = 0
⊢ category_theory.reflects_isomorphisms (category_theory.forget₂ Ring AddCommGroup)
J : Type v,	_inst_1 : category_theory.small_category J,	F : J ⥤ CommRing,	s : category_theory.limits.cocone F,	m : (CommRing.colimits.colimit_cocone F).X ⟶ s.X,	w : ∀ (j : J), (CommRing.colimits.colimit_cocone F).ι.app j ≫ m = s.ι.app j	⊢ m = CommRing.colimits.desc_morphism F s
J : Type v,	_inst_1 : category_theory.small_category J,	F : J ⥤ CommRing,	s : category_theory.limits.cocone F,	m : (CommRing.colimits.colimit_cocone F).X ⟶ s.X,	w : ∀ (j : J), (CommRing.colimits.colimit_cocone F).ι.app j ≫ m = s.ι.app j,	x : ↥((CommRing.colimits.colimit_cocone F).X)	⊢ ⇑m x = ⇑(CommRing.colimits.desc_morphism F s) x
J : Type v,	_inst_1 : category_theory.small_category J,	F : J ⥤ CommRing,	s : category_theory.limits.cocone F,	m : (CommRing.colimits.colimit_cocone F).X ⟶ s.X,	w : ∀ (j : J), (CommRing.colimits.colimit_cocone F).ι.app j ≫ m = s.ι.app j,	x : CommRing.colimits.prequotient F	⊢ ⇑m (quot.mk setoid.r x) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r x)		case h	J : Type v,	_inst_1 : category_theory.small_category J,	F : J ⥤ CommRing,	s : category_theory.limits.cocone F,	m : (CommRing.colimits.colimit_cocone F).X ⟶ s.X,	w : ∀ (j : J), (CommRing.colimits.colimit_cocone F).ι.app j ≫ m = s.ι.app j,	x_a x_b : CommRing.colimits.prequotient F,	x_p : setoid.r x_a x_b	⊢ _ = ?m_1[x_b]
J : Type v,	_inst_1 : category_theory.small_category J,	F : J ⥤ CommRing,	s : category_theory.limits.cocone F,	m : (CommRing.colimits.colimit_cocone F).X ⟶ s.X,	w : ∀ (j : J), (CommRing.colimits.colimit_cocone F).ι.app j ≫ m = s.ι.app j,	x_j : J,	x_x : ↥(F.obj x_j)	⊢ ⇑m (quot.mk setoid.r (CommRing.colimits.prequotient.of x_j x_x)) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r (CommRing.colimits.prequotient.of x_j x_x))
J : Type v,	_inst_1 : category_theory.small_category J,	F : J ⥤ CommRing,	s : category_theory.limits.cocone F,	m : (CommRing.colimits.colimit_cocone F).X ⟶ s.X,	w : ∀ (j : J), (CommRing.colimits.colimit_cocone F).ι.app j ≫ m = s.ι.app j,	x_j : J,	x_x : ↥(F.obj x_j),	w' : ⇑((CommRing.colimits.colimit_cocone F).ι.app x_j ≫ m) x_x = ⇑(s.ι.app x_j) x_x	⊢ ⇑m (quot.mk setoid.r (CommRing.colimits.prequotient.of x_j x_x)) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r (CommRing.colimits.prequotient.of x_j x_x))
J : Type v,	_inst_1 : category_theory.small_category J,	F : J ⥤ CommRing,	s : category_theory.limits.cocone F,	m : (CommRing.colimits.colimit_cocone F).X ⟶ s.X,	w : ∀ (j : J), (CommRing.colimits.colimit_cocone F).ι.app j ≫ m = s.ι.app j,	x_j : J,	x_x : ↥(F.obj x_j)	⊢ ⇑m (quot.mk setoid.r (CommRing.colimits.prequotient.of x_j x_x)) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r (CommRing.colimits.prequotient.of x_j x_x))		case f, CommRing.colimits.prequotient.zero	J : Type v,	_inst_1 : category_theory.small_category J,	F : J ⥤ CommRing,	s : category_theory.limits.cocone F,	m : (CommRing.colimits.colimit_cocone F).X ⟶ s.X,	w : ∀ (j : J), (CommRing.colimits.colimit_cocone F).ι.app j ≫ m = s.ι.app j	⊢ ⇑m (quot.mk setoid.r CommRing.colimits.prequotient.zero) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r CommRing.colimits.prequotient.zero)		case f, CommRing.colimits.prequotient.one	J : Type v,	_inst_1 : category_theory.small_category J,	F : J ⥤ CommRing,	s : category_theory.limits.cocone F,	m : (CommRing.colimits.colimit_cocone F).X ⟶ s.X,	w : ∀ (j : J), (CommRing.colimits.colimit_cocone F).ι.app j ≫ m = s.ι.app j	⊢ ⇑m (quot.mk setoid.r CommRing.colimits.prequotient.one) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r CommRing.colimits.prequotient.one)		case f, CommRing.colimits.prequotient.neg	J : Type v,	_inst_1 : category_theory.small_category J,	F : J ⥤ CommRing,	s : category_theory.limits.cocone F,	m : (CommRing.colimits.colimit_cocone F).X ⟶ s.X,	w : ∀ (j : J), (CommRing.colimits.colimit_cocone F).ι.app j ≫ m = s.ι.app j,	x_ᾰ : CommRing.colimits.prequotient F,	x_ih : ⇑m (quot.mk setoid.r x_ᾰ) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r x_ᾰ)	⊢ ⇑m (quot.mk setoid.r x_ᾰ.neg) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r x_ᾰ.neg)		case f, CommRing.colimits.prequotient.add	J : Type v,	_inst_1 : category_theory.small_category J,	F : J ⥤ CommRing,	s : category_theory.limits.cocone F,	m : (CommRing.colimits.colimit_cocone F).X ⟶ s.X,	w : ∀ (j : J), (CommRing.colimits.colimit_cocone F).ι.app j ≫ m = s.ι.app j,	x_ᾰ x_ᾰ_1 : CommRing.colimits.prequotient F,	x_ih_ᾰ : ⇑m (quot.mk setoid.r x_ᾰ) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r x_ᾰ),	x_ih_ᾰ_1 : ⇑m (quot.mk setoid.r x_ᾰ_1) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r x_ᾰ_1)	⊢ ⇑m (quot.mk setoid.r (x_ᾰ.add x_ᾰ_1)) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r (x_ᾰ.add x_ᾰ_1))		case f, CommRing.colimits.prequotient.mul	J : Type v,	_inst_1 : category_theory.small_category J,	F : J ⥤ CommRing,	s : category_theory.limits.cocone F,	m : (CommRing.colimits.colimit_cocone F).X ⟶ s.X,	w : ∀ (j : J), (CommRing.colimits.colimit_cocone F).ι.app j ≫ m = s.ι.app j,	x_ᾰ x_ᾰ_1 : CommRing.colimits.prequotient F,	x_ih_ᾰ : ⇑m (quot.mk setoid.r x_ᾰ) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r x_ᾰ),	x_ih_ᾰ_1 : ⇑m (quot.mk setoid.r x_ᾰ_1) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r x_ᾰ_1)	⊢ ⇑m (quot.mk setoid.r (x_ᾰ.mul x_ᾰ_1)) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r (x_ᾰ.mul x_ᾰ_1))		case h	J : Type v,	_inst_1 : category_theory.small_category J,	F : J ⥤ CommRing,	s : category_theory.limits.cocone F,	m : (CommRing.colimits.colimit_cocone F).X ⟶ s.X,	w : ∀ (j : J), (CommRing.colimits.colimit_cocone F).ι.app j ≫ m = s.ι.app j,	x_a x_b : CommRing.colimits.prequotient F,	x_p : setoid.r x_a x_b	⊢ _ = _
J : Type v,	_inst_1 : category_theory.small_category J,	F : J ⥤ CommRing,	s : category_theory.limits.cocone F,	m : (CommRing.colimits.colimit_cocone F).X ⟶ s.X,	w : ∀ (j : J), (CommRing.colimits.colimit_cocone F).ι.app j ≫ m = s.ι.app j,	x_j : J,	x_x : ↥(F.obj x_j),	w' : ⇑((CommRing.colimits.colimit_cocone F).ι.app x_j ≫ m) x_x = ⇑(s.ι.app x_j) x_x	⊢ ⇑(s.ι.app x_j) x_x = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r (CommRing.colimits.prequotient.of x_j x_x))
J : Type v,	_inst_1 : category_theory.small_category J,	F : J ⥤ CommRing,	s : category_theory.limits.cocone F,	m : (CommRing.colimits.colimit_cocone F).X ⟶ s.X,	w : ∀ (j : J), (CommRing.colimits.colimit_cocone F).ι.app j ≫ m = s.ι.app j	⊢ ⇑m (quot.mk setoid.r CommRing.colimits.prequotient.zero) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r CommRing.colimits.prequotient.zero)		case f, CommRing.colimits.prequotient.one	J : Type v,	_inst_1 : category_theory.small_category J,	F : J ⥤ CommRing,	s : category_theory.limits.cocone F,	m : (CommRing.colimits.colimit_cocone F).X ⟶ s.X,	w : ∀ (j : J), (CommRing.colimits.colimit_cocone F).ι.app j ≫ m = s.ι.app j	⊢ ⇑m (quot.mk setoid.r CommRing.colimits.prequotient.one) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r CommRing.colimits.prequotient.one)		case f, CommRing.colimits.prequotient.neg	J : Type v,	_inst_1 : category_theory.small_category J,	F : J ⥤ CommRing,	s : category_theory.limits.cocone F,	m : (CommRing.colimits.colimit_cocone F).X ⟶ s.X,	w : ∀ (j : J), (CommRing.colimits.colimit_cocone F).ι.app j ≫ m = s.ι.app j,	x_ᾰ : CommRing.colimits.prequotient F,	x_ih : ⇑m (quot.mk setoid.r x_ᾰ) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r x_ᾰ)	⊢ ⇑m (quot.mk setoid.r x_ᾰ.neg) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r x_ᾰ.neg)		case f, CommRing.colimits.prequotient.add	J : Type v,	_inst_1 : category_theory.small_category J,	F : J ⥤ CommRing,	s : category_theory.limits.cocone F,	m : (CommRing.colimits.colimit_cocone F).X ⟶ s.X,	w : ∀ (j : J), (CommRing.colimits.colimit_cocone F).ι.app j ≫ m = s.ι.app j,	x_ᾰ x_ᾰ_1 : CommRing.colimits.prequotient F,	x_ih_ᾰ : ⇑m (quot.mk setoid.r x_ᾰ) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r x_ᾰ),	x_ih_ᾰ_1 : ⇑m (quot.mk setoid.r x_ᾰ_1) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r x_ᾰ_1)	⊢ ⇑m (quot.mk setoid.r (x_ᾰ.add x_ᾰ_1)) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r (x_ᾰ.add x_ᾰ_1))		case f, CommRing.colimits.prequotient.mul	J : Type v,	_inst_1 : category_theory.small_category J,	F : J ⥤ CommRing,	s : category_theory.limits.cocone F,	m : (CommRing.colimits.colimit_cocone F).X ⟶ s.X,	w : ∀ (j : J), (CommRing.colimits.colimit_cocone F).ι.app j ≫ m = s.ι.app j,	x_ᾰ x_ᾰ_1 : CommRing.colimits.prequotient F,	x_ih_ᾰ : ⇑m (quot.mk setoid.r x_ᾰ) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r x_ᾰ),	x_ih_ᾰ_1 : ⇑m (quot.mk setoid.r x_ᾰ_1) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r x_ᾰ_1)	⊢ ⇑m (quot.mk setoid.r (x_ᾰ.mul x_ᾰ_1)) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r (x_ᾰ.mul x_ᾰ_1))		case h	J : Type v,	_inst_1 : category_theory.small_category J,	F : J ⥤ CommRing,	s : category_theory.limits.cocone F,	m : (CommRing.colimits.colimit_cocone F).X ⟶ s.X,	w : ∀ (j : J), (CommRing.colimits.colimit_cocone F).ι.app j ≫ m = s.ι.app j,	x_a x_b : CommRing.colimits.prequotient F,	x_p : setoid.r x_a x_b	⊢ _ = _
J : Type v,	_inst_1 : category_theory.small_category J,	F : J ⥤ CommRing,	s : category_theory.limits.cocone F,	m : (CommRing.colimits.colimit_cocone F).X ⟶ s.X,	w : ∀ (j : J), (CommRing.colimits.colimit_cocone F).ι.app j ≫ m = s.ι.app j	⊢ ⇑m (quot.mk setoid.r CommRing.colimits.prequotient.zero) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r CommRing.colimits.prequotient.zero)
J : Type v,	_inst_1 : category_theory.small_category J,	F : J ⥤ CommRing,	s : category_theory.limits.cocone F,	m : (CommRing.colimits.colimit_cocone F).X ⟶ s.X,	w : ∀ (j : J), (CommRing.colimits.colimit_cocone F).ι.app j ≫ m = s.ι.app j	⊢ ⇑m (quot.mk setoid.r CommRing.colimits.prequotient.one) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r CommRing.colimits.prequotient.one)		case f, CommRing.colimits.prequotient.neg	J : Type v,	_inst_1 : category_theory.small_category J,	F : J ⥤ CommRing,	s : category_theory.limits.cocone F,	m : (CommRing.colimits.colimit_cocone F).X ⟶ s.X,	w : ∀ (j : J), (CommRing.colimits.colimit_cocone F).ι.app j ≫ m = s.ι.app j,	x_ᾰ : CommRing.colimits.prequotient F,	x_ih : ⇑m (quot.mk setoid.r x_ᾰ) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r x_ᾰ)	⊢ ⇑m (quot.mk setoid.r x_ᾰ.neg) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r x_ᾰ.neg)		case f, CommRing.colimits.prequotient.add	J : Type v,	_inst_1 : category_theory.small_category J,	F : J ⥤ CommRing,	s : category_theory.limits.cocone F,	m : (CommRing.colimits.colimit_cocone F).X ⟶ s.X,	w : ∀ (j : J), (CommRing.colimits.colimit_cocone F).ι.app j ≫ m = s.ι.app j,	x_ᾰ x_ᾰ_1 : CommRing.colimits.prequotient F,	x_ih_ᾰ : ⇑m (quot.mk setoid.r x_ᾰ) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r x_ᾰ),	x_ih_ᾰ_1 : ⇑m (quot.mk setoid.r x_ᾰ_1) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r x_ᾰ_1)	⊢ ⇑m (quot.mk setoid.r (x_ᾰ.add x_ᾰ_1)) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r (x_ᾰ.add x_ᾰ_1))		case f, CommRing.colimits.prequotient.mul	J : Type v,	_inst_1 : category_theory.small_category J,	F : J ⥤ CommRing,	s : category_theory.limits.cocone F,	m : (CommRing.colimits.colimit_cocone F).X ⟶ s.X,	w : ∀ (j : J), (CommRing.colimits.colimit_cocone F).ι.app j ≫ m = s.ι.app j,	x_ᾰ x_ᾰ_1 : CommRing.colimits.prequotient F,	x_ih_ᾰ : ⇑m (quot.mk setoid.r x_ᾰ) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r x_ᾰ),	x_ih_ᾰ_1 : ⇑m (quot.mk setoid.r x_ᾰ_1) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r x_ᾰ_1)	⊢ ⇑m (quot.mk setoid.r (x_ᾰ.mul x_ᾰ_1)) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r (x_ᾰ.mul x_ᾰ_1))		case h	J : Type v,	_inst_1 : category_theory.small_category J,	F : J ⥤ CommRing,	s : category_theory.limits.cocone F,	m : (CommRing.colimits.colimit_cocone F).X ⟶ s.X,	w : ∀ (j : J), (CommRing.colimits.colimit_cocone F).ι.app j ≫ m = s.ι.app j,	x_a x_b : CommRing.colimits.prequotient F,	x_p : setoid.r x_a x_b	⊢ _ = _
J : Type v,	_inst_1 : category_theory.small_category J,	F : J ⥤ CommRing,	s : category_theory.limits.cocone F,	m : (CommRing.colimits.colimit_cocone F).X ⟶ s.X,	w : ∀ (j : J), (CommRing.colimits.colimit_cocone F).ι.app j ≫ m = s.ι.app j	⊢ ⇑m (quot.mk setoid.r CommRing.colimits.prequotient.one) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r CommRing.colimits.prequotient.one)
J : Type v,	_inst_1 : category_theory.small_category J,	F : J ⥤ CommRing,	s : category_theory.limits.cocone F,	m : (CommRing.colimits.colimit_cocone F).X ⟶ s.X,	w : ∀ (j : J), (CommRing.colimits.colimit_cocone F).ι.app j ≫ m = s.ι.app j,	x_ᾰ : CommRing.colimits.prequotient F,	x_ih : ⇑m (quot.mk setoid.r x_ᾰ) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r x_ᾰ)	⊢ ⇑m (quot.mk setoid.r x_ᾰ.neg) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r x_ᾰ.neg)		case f, CommRing.colimits.prequotient.add	J : Type v,	_inst_1 : category_theory.small_category J,	F : J ⥤ CommRing,	s : category_theory.limits.cocone F,	m : (CommRing.colimits.colimit_cocone F).X ⟶ s.X,	w : ∀ (j : J), (CommRing.colimits.colimit_cocone F).ι.app j ≫ m = s.ι.app j,	x_ᾰ x_ᾰ_1 : CommRing.colimits.prequotient F,	x_ih_ᾰ : ⇑m (quot.mk setoid.r x_ᾰ) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r x_ᾰ),	x_ih_ᾰ_1 : ⇑m (quot.mk setoid.r x_ᾰ_1) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r x_ᾰ_1)	⊢ ⇑m (quot.mk setoid.r (x_ᾰ.add x_ᾰ_1)) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r (x_ᾰ.add x_ᾰ_1))		case f, CommRing.colimits.prequotient.mul	J : Type v,	_inst_1 : category_theory.small_category J,	F : J ⥤ CommRing,	s : category_theory.limits.cocone F,	m : (CommRing.colimits.colimit_cocone F).X ⟶ s.X,	w : ∀ (j : J), (CommRing.colimits.colimit_cocone F).ι.app j ≫ m = s.ι.app j,	x_ᾰ x_ᾰ_1 : CommRing.colimits.prequotient F,	x_ih_ᾰ : ⇑m (quot.mk setoid.r x_ᾰ) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r x_ᾰ),	x_ih_ᾰ_1 : ⇑m (quot.mk setoid.r x_ᾰ_1) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r x_ᾰ_1)	⊢ ⇑m (quot.mk setoid.r (x_ᾰ.mul x_ᾰ_1)) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r (x_ᾰ.mul x_ᾰ_1))		case h	J : Type v,	_inst_1 : category_theory.small_category J,	F : J ⥤ CommRing,	s : category_theory.limits.cocone F,	m : (CommRing.colimits.colimit_cocone F).X ⟶ s.X,	w : ∀ (j : J), (CommRing.colimits.colimit_cocone F).ι.app j ≫ m = s.ι.app j,	x_a x_b : CommRing.colimits.prequotient F,	x_p : setoid.r x_a x_b	⊢ _ = _
J : Type v,	_inst_1 : category_theory.small_category J,	F : J ⥤ CommRing,	s : category_theory.limits.cocone F,	m : (CommRing.colimits.colimit_cocone F).X ⟶ s.X,	w : ∀ (j : J), (CommRing.colimits.colimit_cocone F).ι.app j ≫ m = s.ι.app j,	x_ᾰ : CommRing.colimits.prequotient F,	x_ih : ⇑m (quot.mk setoid.r x_ᾰ) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r x_ᾰ)	⊢ ⇑m (quot.mk setoid.r x_ᾰ.neg) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r x_ᾰ.neg)
J : Type v,	_inst_1 : category_theory.small_category J,	F : J ⥤ CommRing,	s : category_theory.limits.cocone F,	m : (CommRing.colimits.colimit_cocone F).X ⟶ s.X,	w : ∀ (j : J), (CommRing.colimits.colimit_cocone F).ι.app j ≫ m = s.ι.app j,	x_ᾰ x_ᾰ_1 : CommRing.colimits.prequotient F,	x_ih_ᾰ : ⇑m (quot.mk setoid.r x_ᾰ) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r x_ᾰ),	x_ih_ᾰ_1 : ⇑m (quot.mk setoid.r x_ᾰ_1) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r x_ᾰ_1)	⊢ ⇑m (quot.mk setoid.r (x_ᾰ.add x_ᾰ_1)) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r (x_ᾰ.add x_ᾰ_1))		case f, CommRing.colimits.prequotient.mul	J : Type v,	_inst_1 : category_theory.small_category J,	F : J ⥤ CommRing,	s : category_theory.limits.cocone F,	m : (CommRing.colimits.colimit_cocone F).X ⟶ s.X,	w : ∀ (j : J), (CommRing.colimits.colimit_cocone F).ι.app j ≫ m = s.ι.app j,	x_ᾰ x_ᾰ_1 : CommRing.colimits.prequotient F,	x_ih_ᾰ : ⇑m (quot.mk setoid.r x_ᾰ) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r x_ᾰ),	x_ih_ᾰ_1 : ⇑m (quot.mk setoid.r x_ᾰ_1) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r x_ᾰ_1)	⊢ ⇑m (quot.mk setoid.r (x_ᾰ.mul x_ᾰ_1)) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r (x_ᾰ.mul x_ᾰ_1))		case h	J : Type v,	_inst_1 : category_theory.small_category J,	F : J ⥤ CommRing,	s : category_theory.limits.cocone F,	m : (CommRing.colimits.colimit_cocone F).X ⟶ s.X,	w : ∀ (j : J), (CommRing.colimits.colimit_cocone F).ι.app j ≫ m = s.ι.app j,	x_a x_b : CommRing.colimits.prequotient F,	x_p : setoid.r x_a x_b	⊢ _ = _
J : Type v,	_inst_1 : category_theory.small_category J,	F : J ⥤ CommRing,	s : category_theory.limits.cocone F,	m : (CommRing.colimits.colimit_cocone F).X ⟶ s.X,	w : ∀ (j : J), (CommRing.colimits.colimit_cocone F).ι.app j ≫ m = s.ι.app j,	x_ᾰ x_ᾰ_1 : CommRing.colimits.prequotient F,	x_ih_ᾰ : ⇑m (quot.mk setoid.r x_ᾰ) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r x_ᾰ),	x_ih_ᾰ_1 : ⇑m (quot.mk setoid.r x_ᾰ_1) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r x_ᾰ_1)	⊢ ⇑m (quot.mk setoid.r (x_ᾰ.add x_ᾰ_1)) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r (x_ᾰ.add x_ᾰ_1))
J : Type v,	_inst_1 : category_theory.small_category J,	F : J ⥤ CommRing,	s : category_theory.limits.cocone F,	m : (CommRing.colimits.colimit_cocone F).X ⟶ s.X,	w : ∀ (j : J), (CommRing.colimits.colimit_cocone F).ι.app j ≫ m = s.ι.app j,	x_ᾰ x_ᾰ_1 : CommRing.colimits.prequotient F,	x_ih_ᾰ : ⇑m (quot.mk setoid.r x_ᾰ) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r x_ᾰ),	x_ih_ᾰ_1 : ⇑m (quot.mk setoid.r x_ᾰ_1) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r x_ᾰ_1)	⊢ ⇑m (quot.mk setoid.r (x_ᾰ.mul x_ᾰ_1)) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r (x_ᾰ.mul x_ᾰ_1))		case h	J : Type v,	_inst_1 : category_theory.small_category J,	F : J ⥤ CommRing,	s : category_theory.limits.cocone F,	m : (CommRing.colimits.colimit_cocone F).X ⟶ s.X,	w : ∀ (j : J), (CommRing.colimits.colimit_cocone F).ι.app j ≫ m = s.ι.app j,	x_a x_b : CommRing.colimits.prequotient F,	x_p : setoid.r x_a x_b	⊢ _ = _
J : Type v,	_inst_1 : category_theory.small_category J,	F : J ⥤ CommRing,	s : category_theory.limits.cocone F,	m : (CommRing.colimits.colimit_cocone F).X ⟶ s.X,	w : ∀ (j : J), (CommRing.colimits.colimit_cocone F).ι.app j ≫ m = s.ι.app j,	x_ᾰ x_ᾰ_1 : CommRing.colimits.prequotient F,	x_ih_ᾰ : ⇑m (quot.mk setoid.r x_ᾰ) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r x_ᾰ),	x_ih_ᾰ_1 : ⇑m (quot.mk setoid.r x_ᾰ_1) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r x_ᾰ_1)	⊢ ⇑m (quot.mk setoid.r (x_ᾰ.mul x_ᾰ_1)) = ⇑(CommRing.colimits.desc_morphism F s) (quot.mk setoid.r (x_ᾰ.mul x_ᾰ_1))
J : Type v,	_inst_1 : category_theory.small_category J,	F : J ⥤ CommRing,	s : category_theory.limits.cocone F,	m : (CommRing.colimits.colimit_cocone F).X ⟶ s.X,	w : ∀ (j : J), (CommRing.colimits.colimit_cocone F).ι.app j ≫ m = s.ι.app j,	x_a x_b : CommRing.colimits.prequotient F,	x_p : setoid.r x_a x_b	⊢ _ = _
J : Type ?,	𝒥 : category_theory.small_category J	⊢ category_theory.limits.preserves_limits_of_shape J (category_theory.forget Ring)
J : Type u,	_inst_1 : category_theory.small_category J,	F : J ⥤ CommRing,	j : J	⊢ comm_ring ↥(F.obj j)
J : Type u,	_inst_1 : category_theory.small_category J,	F : J ⥤ CommRing,	j : J	⊢ comm_ring ((F ⋙ category_theory.forget CommRing).obj j)
⊢ ∀ (J : Type u) [_inst_2 : decidable_eq J] [_inst_3 : fintype J], category_theory.limits.has_limits_of_shape (category_theory.discrete J) AddCommGroup
⊢ ∀ (P Q R : AddCommGroup) (f f' : P ⟶ Q) (g : Q ⟶ R), (f + f') ≫ g = f ≫ g + f' ≫ g
P Q R : AddCommGroup,	f f' : P ⟶ Q,	g : Q ⟶ R	⊢ (f + f') ≫ g = f ≫ g + f' ≫ g
⊢ ∀ (P Q R : AddCommGroup) (f : P ⟶ Q) (g g' : Q ⟶ R), f ≫ (g + g') = f ≫ g + f ≫ g'
P Q R : AddCommGroup,	f : P ⟶ Q,	g g' : Q ⟶ R	⊢ f ≫ (g + g') = f ≫ g + f ≫ g'
G H : AddCommGroup,	f : G ⟶ H,	_inst_1 : category_theory.mono f	⊢ category_theory.mono f
R S : CommGroup,	i : R ⟶ S,	r : ↥R,	h : r = 1	⊢ ⇑i r = 1
G H : AddCommGroup	⊢ category_theory.limits.has_colimit (category_theory.limits.pair G H)
R : Type u,	_inst_1 : ring R,	X : Module R,	_x : 0 ⟶ X,	x : ↥0,	h : x = 0	⊢ ⇑_x x = ⇑(inhabited.default (0 ⟶ X)) x
R : Type u,	_inst_1 : ring R,	X₂ : Type v,	X₁ : Module R,	g₂ : add_comm_group X₂,	m₂ : module R X₂,	e : ↥X₁ ≃ₗ[R] X₂,	x : ↥X₁	⊢ ⇑(↑e ≫ ↑(e.symm)) x = ⇑(𝟙 X₁) x
R : Type u,	_inst_1 : ring R,	X₂ : Type v,	X₁ : Module R,	g₂ : add_comm_group X₂,	m₂ : module R X₂,	e : ↥X₁ ≃ₗ[R] X₂,	x : ↥(Module.of R X₂)	⊢ ⇑(↑(e.symm) ≫ ↑e) x = ⇑(𝟙 (Module.of R X₂)) x
R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	s : R	⊢ Module.colimits.colimit_type F → Module.colimits.colimit_type F
R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	s : R	⊢ Module.colimits.prequotient F → Module.colimits.colimit_type F
R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	s : R	⊢ Module.colimits.prequotient F → Module.colimits.colimit_type F		R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	s : R	⊢ ∀ (a b : Module.colimits.prequotient F), setoid.r a b → ?m_1 a = ?m_1 b
R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	s : R,	x : Module.colimits.prequotient F	⊢ Module.colimits.colimit_type F
R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	s : R	⊢ ∀ (a b : Module.colimits.prequotient F), setoid.r a b → quot.mk setoid.r (Module.colimits.prequotient.smul s a) = quot.mk setoid.r (Module.colimits.prequotient.smul s b)
R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	s : R,	x x' : Module.colimits.prequotient F,	r : setoid.r x x'	⊢ quot.mk setoid.r (Module.colimits.prequotient.smul s x) = quot.mk setoid.r (Module.colimits.prequotient.smul s x')
R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	s : R,	x x' : Module.colimits.prequotient F,	r : setoid.r x x'	⊢ setoid.r (Module.colimits.prequotient.smul s x) (Module.colimits.prequotient.smul s x')
R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	x : Module.colimits.colimit_type F	⊢ 1 • x = x
R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	x : Module.colimits.prequotient F	⊢ 1 • quot.mk setoid.r x = quot.mk setoid.r x		case h	R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	x_a x_b : Module.colimits.prequotient F,	x_p : setoid.r x_a x_b	⊢ _ = ?m_1[x_b]
R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	x : Module.colimits.prequotient F	⊢ quot.mk setoid.r (Module.colimits.prequotient.smul 1 x) = quot.mk setoid.r x		case h	R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	x_a x_b : Module.colimits.prequotient F,	x_p : setoid.r x_a x_b	⊢ _ = _
R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	x : Module.colimits.prequotient F	⊢ setoid.r (Module.colimits.prequotient.smul 1 x) x		case h	R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	x_a x_b : Module.colimits.prequotient F,	x_p : setoid.r x_a x_b	⊢ _ = _
R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	x_a x_b : Module.colimits.prequotient F,	x_p : setoid.r x_a x_b	⊢ _ = _
R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	s t : R,	x : Module.colimits.colimit_type F	⊢ (s * t) • x = s • t • x
R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	s t : R,	x : Module.colimits.prequotient F	⊢ (s * t) • quot.mk setoid.r x = s • t • quot.mk setoid.r x		case h	R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	s t : R,	x_a x_b : Module.colimits.prequotient F,	x_p : setoid.r x_a x_b	⊢ _ = ?m_1[x_b]
R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	s t : R,	x : Module.colimits.prequotient F	⊢ quot.mk setoid.r (Module.colimits.prequotient.smul (s * t) x) = quot.mk setoid.r (Module.colimits.prequotient.smul s (Module.colimits.prequotient.smul t x))		case h	R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	s t : R,	x_a x_b : Module.colimits.prequotient F,	x_p : setoid.r x_a x_b	⊢ _ = _
R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	s t : R,	x : Module.colimits.prequotient F	⊢ setoid.r (Module.colimits.prequotient.smul (s * t) x) (Module.colimits.prequotient.smul s (Module.colimits.prequotient.smul t x))		case h	R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	s t : R,	x_a x_b : Module.colimits.prequotient F,	x_p : setoid.r x_a x_b	⊢ _ = _
R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	s t : R,	x_a x_b : Module.colimits.prequotient F,	x_p : setoid.r x_a x_b	⊢ _ = _
R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	s : R,	x y : Module.colimits.colimit_type F	⊢ s • (x + y) = s • x + s • y
R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	s : R,	y : Module.colimits.colimit_type F,	x : Module.colimits.prequotient F	⊢ s • (quot.mk setoid.r x + y) = s • quot.mk setoid.r x + s • y		case h	R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	s : R,	y : Module.colimits.colimit_type F,	x_a x_b : Module.colimits.prequotient F,	x_p : setoid.r x_a x_b	⊢ _ = ?m_1[x_b]
R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	s : R,	x y : Module.colimits.prequotient F	⊢ s • (quot.mk setoid.r x + quot.mk setoid.r y) = s • quot.mk setoid.r x + s • quot.mk setoid.r y		case f, h	R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	s : R,	x y_a y_b : Module.colimits.prequotient F,	y_p : setoid.r y_a y_b	⊢ _ = ?m_1[y_b]		case h	R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	s : R,	y : Module.colimits.colimit_type F,	x_a x_b : Module.colimits.prequotient F,	x_p : setoid.r x_a x_b	⊢ _ = _
R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	s : R,	x y : Module.colimits.prequotient F	⊢ quot.lift (λ (x : Module.colimits.prequotient F), quot.mk setoid.r (Module.colimits.prequotient.smul s x)) _ (quot.mk setoid.r x + quot.mk setoid.r y) = quot.mk setoid.r (Module.colimits.prequotient.smul s x) + quot.mk setoid.r (Module.colimits.prequotient.smul s y)		case f, h	R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	s : R,	x y_a y_b : Module.colimits.prequotient F,	y_p : setoid.r y_a y_b	⊢ _ = _		case h	R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	s : R,	y : Module.colimits.colimit_type F,	x_a x_b : Module.colimits.prequotient F,	x_p : setoid.r x_a x_b	⊢ _ = _
R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	s : R,	x y : Module.colimits.prequotient F	⊢ setoid.r (Module.colimits.prequotient.smul s (x.add y)) ((Module.colimits.prequotient.smul s x).add (Module.colimits.prequotient.smul s y))		case f, h	R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	s : R,	x y_a y_b : Module.colimits.prequotient F,	y_p : setoid.r y_a y_b	⊢ _ = _		case h	R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	s : R,	y : Module.colimits.colimit_type F,	x_a x_b : Module.colimits.prequotient F,	x_p : setoid.r x_a x_b	⊢ _ = _
R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	s : R,	x y_a y_b : Module.colimits.prequotient F,	y_p : setoid.r y_a y_b	⊢ _ = _		case h	R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	s : R,	y : Module.colimits.colimit_type F,	x_a x_b : Module.colimits.prequotient F,	x_p : setoid.r x_a x_b	⊢ _ = _
R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	s : R,	y : Module.colimits.colimit_type F,	x_a x_b : Module.colimits.prequotient F,	x_p : setoid.r x_a x_b	⊢ _ = _
R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	s : R	⊢ s • 0 = 0
R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	s : R	⊢ setoid.r (Module.colimits.prequotient.smul s Module.colimits.prequotient.zero) Module.colimits.prequotient.zero
R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	s t : R,	x : Module.colimits.colimit_type F	⊢ (s + t) • x = s • x + t • x
R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	s t : R,	x : Module.colimits.prequotient F	⊢ (s + t) • quot.mk setoid.r x = s • quot.mk setoid.r x + t • quot.mk setoid.r x		case h	R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	s t : R,	x_a x_b : Module.colimits.prequotient F,	x_p : setoid.r x_a x_b	⊢ _ = ?m_1[x_b]
R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	s t : R,	x : Module.colimits.prequotient F	⊢ quot.mk setoid.r (Module.colimits.prequotient.smul (s + t) x) = quot.mk setoid.r (Module.colimits.prequotient.smul s x) + quot.mk setoid.r (Module.colimits.prequotient.smul t x)		case h	R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	s t : R,	x_a x_b : Module.colimits.prequotient F,	x_p : setoid.r x_a x_b	⊢ _ = _
R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	s t : R,	x : Module.colimits.prequotient F	⊢ setoid.r (Module.colimits.prequotient.smul (s + t) x) ((Module.colimits.prequotient.smul s x).add (Module.colimits.prequotient.smul t x))		case h	R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	s t : R,	x_a x_b : Module.colimits.prequotient F,	x_p : setoid.r x_a x_b	⊢ _ = _
R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	x : Module.colimits.colimit_type F	⊢ 0 • x = 0
R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	x : Module.colimits.prequotient F	⊢ 0 • quot.mk setoid.r x = 0		case h	R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	x_a x_b : Module.colimits.prequotient F,	x_p : setoid.r x_a x_b	⊢ _ = ?m_1[x_b]
R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	x : Module.colimits.prequotient F	⊢ quot.mk setoid.r (Module.colimits.prequotient.smul 0 x) = 0		case h	R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	x_a x_b : Module.colimits.prequotient F,	x_p : setoid.r x_a x_b	⊢ _ = _
R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	x : Module.colimits.prequotient F	⊢ setoid.r (Module.colimits.prequotient.smul 0 x) Module.colimits.prequotient.zero		case h	R : Type v,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Module R,	x_a x_b : Module.colimits.prequotient F,	x_p : setoid.r x_a x_b	⊢ _ = _
R : Type u,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	_inst_3 : category_theory.is_filtered J,	F : J ⥤ Module R,	r : R,	x y : Σ (j : J), ↥(F.obj j),	h : category_theory.limits.types.filtered_colimit.rel (F ⋙ category_theory.forget (Module R)) x y	⊢ Module.filtered_colimits.colimit_smul_aux r x = Module.filtered_colimits.colimit_smul_aux r y
R : Type u,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	_inst_3 : category_theory.is_filtered J,	F : J ⥤ Module R,	r : R,	x y : Σ (j : J), ↥(F.obj j),	h : category_theory.limits.types.filtered_colimit.rel (F ⋙ category_theory.forget (Module R)) x y	⊢ ∃ (k : J) (f : ⟨x.fst, r • x.snd⟩.fst ⟶ k) (g : ⟨y.fst, r • y.snd⟩.fst ⟶ k), ⇑(F.map f) ⟨x.fst, r • x.snd⟩.snd = ⇑(F.map g) ⟨y.fst, r • y.snd⟩.snd
R : Type u,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	_inst_3 : category_theory.is_filtered J,	F : J ⥤ Module R,	r : R,	x y : Σ (j : J), ↥(F.obj j),	k : J,	f : x.fst ⟶ k,	g : y.fst ⟶ k,	hfg : (F ⋙ category_theory.forget (Module R)).map f x.snd = (F ⋙ category_theory.forget (Module R)).map g y.snd	⊢ ∃ (k : J) (f : ⟨x.fst, r • x.snd⟩.fst ⟶ k) (g : ⟨y.fst, r • y.snd⟩.fst ⟶ k), ⇑(F.map f) ⟨x.fst, r • x.snd⟩.snd = ⇑(F.map g) ⟨y.fst, r • y.snd⟩.snd
R : Type u,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	_inst_3 : category_theory.is_filtered J,	F : J ⥤ Module R,	r : R,	x y : Σ (j : J), ↥(F.obj j),	k : J,	f : x.fst ⟶ k,	g : y.fst ⟶ k,	hfg : (F ⋙ category_theory.forget (Module R)).map f x.snd = (F ⋙ category_theory.forget (Module R)).map g y.snd	⊢ ⇑(F.map f) ⟨x.fst, r • x.snd⟩.snd = ⇑(F.map g) ⟨y.fst, r • y.snd⟩.snd
R : Type u,	_inst_1 : ring R,	J : Type v,	_inst_2 : category_theory.small_category J,	_inst_3 : category_theory.is_filtered J,	F : J ⥤ Module R,	r : R,	x y : Σ (j : J), ↥(F.obj j),	k : J,	f : x.fst ⟶ k,	g : y.fst ⟶ k,	hfg : ⇑(F.map f) x.snd = ⇑(F.map g) y.snd	⊢ ⇑(F.map f) ⟨x.fst, r • x.snd⟩.snd = ⇑(F.map g) ⟨y.fst, r • y.snd⟩.snd
R : Type u,	_inst_1 : ring R,	G H : Module R,	f : G ⟶ H	⊢ category_theory.limits.cokernel.π f ≫ (Module.cokernel_iso_range_quotient f).hom = (linear_map.range f).mkq
R : Type u,	_inst_1 : ring R,	G H : Module R,	f : G ⟶ H	⊢ H = (category_theory.limits.parallel_pair f 0).obj category_theory.limits.walking_parallel_pair.one
R : Type u,	_inst_1 : ring R,	G H : Module R,	f : G ⟶ H	⊢ Module.of R (linear_map.range f).quotient = {cocone := Module.cokernel_cocone f, is_colimit := Module.cokernel_is_colimit f}.cocone.X
R : Type u,	_inst_1 : ring R,	G H : Module R,	f : G ⟶ H	⊢ category_theory.limits.cokernel.π f ≫ (Module.cokernel_iso_range_quotient f).hom = (linear_map.range f).mkq
R : Type u,	_inst_1 : comm_ring R,	X₁ Y₁ Z₁ : Module R,	X₂ Y₂ Z₂ : Module R,	f₁ : X₁ ⟶ Y₁,	f₂ : X₂ ⟶ Y₂,	g₁ : Y₁ ⟶ Z₁,	g₂ : Y₂ ⟶ Z₂	⊢ Module.monoidal_category.tensor_hom (f₁ ≫ g₁) (f₂ ≫ g₂) = Module.monoidal_category.tensor_hom f₁ f₂ ≫ Module.monoidal_category.tensor_hom g₁ g₂
R : CommMon,	x : ↥R	⊢ ↥R
R : CommMon,	x : ↥R	⊢ ↥R
R : CommMon,	x : ↥R	⊢ ↥R
R : CommMon	⊢ 1 * 1 = 1
R : CommMon,	x y : ↥R	⊢ x * y * (x * y) = x * x * (y * y)
⊢ category_theory.reflects_isomorphisms (category_theory.forget₂ CommMon Mon)
X Y : Magma,	i : X ≅ Y	⊢ function.left_inverse ⇑(i.inv) ⇑(i.hom)
X Y : Magma,	i : X ≅ Y	⊢ ∀ (x : ↥X), ⇑(i.inv) (⇑(i.hom) x) = x
X Y : Magma,	i : X ≅ Y	⊢ function.right_inverse ⇑(i.inv) ⇑(i.hom)
X Y : Magma,	i : X ≅ Y	⊢ function.left_inverse ⇑(i.hom) ⇑(i.inv)
X Y : Magma,	i : X ≅ Y	⊢ ∀ (x : ↥Y), ⇑(i.hom) (⇑(i.inv) x) = x
X Y : Magma,	i : X ≅ Y	⊢ ∀ (x y : ↥X), ⇑(i.hom) (x * y) = ⇑(i.hom) x * ⇑(i.hom) y
⊢ category_theory.reflects_isomorphisms (category_theory.forget₂ Semigroup Magma)
R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y	⊢ (x + y) ^ p = x ^ p + y ^ p
R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y	⊢ x ^ p * 1 * ↑1 + (finset.range p).sum (λ (x_1 : ℕ), x ^ x_1 * y ^ (p - x_1) * ↑(p.choose x_1)) = x ^ p + y ^ p
R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y	⊢ x ^ p + (finset.range p).sum (λ (x_1 : ℕ), x ^ x_1 * y ^ (p - x_1) * ↑(p.choose x_1)) = x ^ p + y ^ p
R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y	⊢ (finset.range p).sum (λ (x_1 : ℕ), x ^ x_1 * y ^ (p - x_1) * ↑(p.choose x_1)) = y ^ p
R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y	⊢ y ^ p = x ^ 0 * y ^ (p - 0) * ↑(p.choose 0)
R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y	⊢ y ^ p = x ^ 0 * y ^ (p - 0) * ↑(p.choose 0)		R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y	⊢ ∀ (b : ℕ), b ∈ finset.range p → b ≠ 0 → x ^ b * y ^ (p - b) * ↑(p.choose b) = 0		R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y	⊢ 0 ∉ finset.range p → x ^ 0 * y ^ (p - 0) * ↑(p.choose 0) = 0
R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y	⊢ ∀ (b : ℕ), b ∈ finset.range p → b ≠ 0 → x ^ b * y ^ (p - b) * ↑(p.choose b) = 0
R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y,	b : ℕ,	h1 : b ∈ finset.range p,	h2 : b ≠ 0,	this : ↑(p.choose b) = 0	⊢ x ^ b * y ^ (p - b) * ↑(p.choose b) = 0
R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y,	b : ℕ,	h1 : b ∈ finset.range p,	h2 : b ≠ 0,	this : ↑(p.choose b) = 0	⊢ x ^ b * y ^ (p - b) * 0 = 0
R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y,	b : ℕ,	h1 : b ∈ finset.range p,	h2 : b ≠ 0,	this : ↑(p.choose b) = 0	⊢ x ^ b * y ^ (p - b) * ↑(p.choose b) = 0		R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y,	b : ℕ,	h1 : b ∈ finset.range p,	h2 : b ≠ 0	⊢ ↑(p.choose b) = 0
R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y,	b : ℕ,	h1 : b ∈ finset.range p,	h2 : b ≠ 0	⊢ x ^ b * y ^ (p - b) * ↑(p.choose b) = 0
R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y,	b : ℕ,	h1 : b ∈ finset.range p,	h2 : b ≠ 0	⊢ ↑(p.choose b) = 0
R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y,	b : ℕ,	h1 : b ∈ finset.range p,	h2 : b ≠ 0	⊢ p ∣ p.choose b
R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y	⊢ ∀ (b : ℕ), b ∈ finset.range p → b ≠ 0 → x ^ b * y ^ (p - b) * ↑(p.choose b) = 0		R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y	⊢ 0 ∉ finset.range p → x ^ 0 * y ^ (p - 0) * ↑(p.choose 0) = 0
R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y,	b : ℕ,	h1 : b ∈ finset.range p,	h2 : b ≠ 0	⊢ b < p
R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y	⊢ 0 ∉ finset.range p → x ^ 0 * y ^ (p - 0) * ↑(p.choose 0) = 0
R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y,	h1 : 0 ∉ finset.range p	⊢ x ^ 0 * y ^ (p - 0) * ↑(p.choose 0) = 0
R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y,	h1 : x ^ 0 * y ^ (p - 0) * ↑(p.choose 0) ≠ 0	⊢ 0 ∈ finset.range p
R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y,	h1 : x ^ 0 * y ^ (p - 0) * ↑(p.choose 0) ≠ 0	⊢ 0 < p
R : Type u,	S : Type v,	_inst_1 : semiring R,	_inst_2 : semiring S,	p : ℕ,	_inst_3 : char_p R p,	_inst_4 : char_p S p	⊢ char_p (R × S) p
R : Type u,	S : Type v,	_inst_1 : semiring R,	_inst_2 : semiring S,	p : ℕ,	_inst_3 : char_p R p,	_inst_4 : char_p S p	⊢ p = p.lcm p
R : Type u,	S : Type v,	_inst_1 : semiring R,	_inst_2 : semiring S,	p : ℕ,	_inst_3 : char_p R p,	_inst_4 : char_p S p	⊢ char_p (R × S) p
M : Type u_1,	_inst_1 : add_monoid M,	_inst_2 : has_one M,	_inst_3 : char_zero M,	this : ↑2 ≠ 0	⊢ 2 ≠ 0
R : Type u_1,	_inst_1 : ring R,	_inst_2 : no_zero_divisors R,	_inst_3 : char_zero R,	a b : R,	h : bit0 a = bit0 b	⊢ a = b
R : Type u_1,	_inst_1 : ring R,	_inst_2 : no_zero_divisors R,	_inst_3 : char_zero R,	a b : R,	h : a + a = b + b	⊢ a = b
R : Type u_1,	_inst_1 : ring R,	_inst_2 : no_zero_divisors R,	_inst_3 : char_zero R,	a b : R,	h : 2 * a = 2 * b	⊢ a = b
R : Type u_1,	_inst_1 : ring R,	_inst_2 : no_zero_divisors R,	_inst_3 : char_zero R,	a b : R,	h : 2 * a = 2 * b	⊢ ↑2 * a = ↑2 * b
K : Type u_1,	_inst_1 : linear_ordered_field K,	_inst_2 : floor_ring K,	v : K,	q : ℚ,	v_eq_q : v = ↑q	⊢ generalized_continued_fraction.int_fract_pair.mapFr coe (generalized_continued_fraction.int_fract_pair.of q) = generalized_continued_fraction.int_fract_pair.of v
ι : Type u_1,	_inst_1 : decidable_eq ι,	R : Type ?,	_inst_2 : add_monoid ι,	_inst_3 : semiring R,	i j : ι,	a b : R	⊢ R
ι : Type u_1,	_inst_1 : decidable_eq ι,	R : Type ?,	_inst_2 : add_monoid ι,	_inst_3 : semiring R,	i j : ι,	a b : R	⊢ ⇑(direct_sum.of (λ (i : ι), R) i) a * ⇑(direct_sum.of (λ (j : ι), R) j) b = ⇑(direct_sum.of (λ (i : ι), R) (i + j)) (a * b)
α : Type u_1,	_inst_1 : monoid α,	a b : α,	u : units α	⊢ a ∣ b * ↑u ↔ a ∣ b
α : Type u_1,	_inst_1 : monoid α,	a b u : α,	hu : is_unit u	⊢ a ∣ b * u ↔ a ∣ b
R : Type u,	_inst_1 : euclidean_domain R,	_inst_2 : decidable_eq R,	a b b : R	⊢ euclidean_domain.gcd 0 b ∣ 0 ∧ euclidean_domain.gcd 0 b ∣ b
R : Type u,	_inst_1 : euclidean_domain R,	_inst_2 : decidable_eq R,	a b b : R	⊢ b ∣ 0 ∧ b ∣ b
R : Type u,	_inst_1 : euclidean_domain R,	_inst_2 : decidable_eq R,	a b a b : R,	aneq : a ≠ 0,	_x : euclidean_domain.gcd (b % a) a ∣ b % a ∧ euclidean_domain.gcd (b % a) a ∣ a,	_fun_match : euclidean_domain.gcd (b % a) a ∣ b % a ∧ euclidean_domain.gcd (b % a) a ∣ a → euclidean_domain.gcd a b ∣ a ∧ euclidean_domain.gcd a b ∣ b,	IH₁ : euclidean_domain.gcd (b % a) a ∣ b % a,	IH₂ : euclidean_domain.gcd (b % a) a ∣ a	⊢ euclidean_domain.gcd a b ∣ a ∧ euclidean_domain.gcd a b ∣ b
R : Type u,	_inst_1 : euclidean_domain R,	_inst_2 : decidable_eq R,	a b a b : R,	aneq : a ≠ 0,	_x : euclidean_domain.gcd (b % a) a ∣ b % a ∧ euclidean_domain.gcd (b % a) a ∣ a,	_fun_match : euclidean_domain.gcd (b % a) a ∣ b % a ∧ euclidean_domain.gcd (b % a) a ∣ a → euclidean_domain.gcd a b ∣ a ∧ euclidean_domain.gcd a b ∣ b,	IH₁ : euclidean_domain.gcd (b % a) a ∣ b % a,	IH₂ : euclidean_domain.gcd (b % a) a ∣ a	⊢ euclidean_domain.gcd (b % a) a ∣ a ∧ euclidean_domain.gcd (b % a) a ∣ b
R : Type u,	_inst_1 : euclidean_domain R,	_inst_2 : decidable_eq R,	a b : R	⊢ euclidean_domain.gcd a b = a * euclidean_domain.gcd_a a b + b * euclidean_domain.gcd_b a b
R : Type u,	_inst_1 : euclidean_domain R,	_inst_2 : decidable_eq R,	a b : R	⊢ P a b (b, 0, 1)
R : Type u,	_inst_1 : euclidean_domain R,	_inst_2 : decidable_eq R,	a b : R	⊢ P a b (a, 1, 0)
R : Type u,	_inst_1 : euclidean_domain R,	_inst_2 : decidable_eq R,	a b : R,	this : P a b (euclidean_domain.xgcd_aux a 1 0 b 0 1)	⊢ euclidean_domain.gcd a b = a * euclidean_domain.gcd_a a b + b * euclidean_domain.gcd_b a b
K : Type u_1,	_inst_1 : linear_ordered_field K,	x : K,	h₀ : 0 < x,	h₁ : x ≠ 1	⊢ function.injective (has_pow.pow x)
K : Type u_1,	_inst_1 : linear_ordered_field K,	x : K,	h₀ : 0 < x,	h₁ : x ≠ 1,	m n : ℤ,	h : x ^ m = x ^ n	⊢ m = n
K : Type u_1,	_inst_1 : linear_ordered_field K,	x : K,	h₀ : 0 < x,	h₁ : x ≠ 1,	m n : ℤ,	h : x ^ m = x ^ n,	H : x < 1	⊢ m = n
K : Type u_1,	_inst_1 : linear_ordered_field K,	x : K,	h₀ : 0 < x,	h₁ : x ≠ 1,	m n : ℤ,	h : x ^ m = x ^ n,	H : x < 1	⊢ (λ (n : ℤ), x⁻¹ ^ n) m = (λ (n : ℤ), x⁻¹ ^ n) n
K : Type u_1,	_inst_1 : linear_ordered_field K,	x : K,	h₀ : 0 < x,	h₁ : x ≠ 1,	m n : ℤ,	h : x ^ m = x ^ n,	H : x < 1	⊢ x⁻¹ ^ m = x⁻¹ ^ n
K : Type u_1,	_inst_1 : linear_ordered_field K,	x : K,	h₀ : 0 < x,	h₁ : x ≠ 1,	m n : ℤ,	h : x ^ m = x ^ n,	H : x < 1	⊢ m = n		K : Type u_1,	_inst_1 : linear_ordered_field K,	x : K,	h₀ : 0 < x,	h₁ : x ≠ 1,	m n : ℤ,	h : x ^ m = x ^ n,	H : 1 < x	⊢ m = n
K : Type u_1,	_inst_1 : linear_ordered_field K,	x : K,	h₀ : 0 < x,	h₁ : x ≠ 1,	m n : ℤ,	h : x ^ m = x ^ n,	H : 1 < x	⊢ m = n
α : Type u_1,	_inst_1 : linear_ordered_ring α,	_inst_2 : floor_ring α,	z : ℤ,	x : α	⊢ ⌈x⌉ ≤ z ↔ x ≤ ↑z
R : Type u,	X : Type v,	_inst_1 : semiring R,	A : Type w,	_inst_2 : non_unital_non_assoc_semiring A,	_inst_3 : module R A,	_inst_4 : is_scalar_tower R A A,	_inst_5 : smul_comm_class R A A,	F₁ F₂ : non_unital_alg_hom R (free_non_unital_non_assoc_algebra R X) A,	h : ∀ (x : X), ⇑F₁ (free_non_unital_non_assoc_algebra.of R x) = ⇑F₂ (free_non_unital_non_assoc_algebra.of R x)	⊢ ⇑((free_non_unital_non_assoc_algebra.lift R).symm) F₁ = ⇑((free_non_unital_non_assoc_algebra.lift R).symm) F₂
R : Type u,	X : Type v,	_inst_1 : semiring R,	A : Type w,	_inst_2 : non_unital_non_assoc_semiring A,	_inst_3 : module R A,	_inst_4 : is_scalar_tower R A A,	_inst_5 : smul_comm_class R A A,	F₁ F₂ : non_unital_alg_hom R (free_non_unital_non_assoc_algebra R X) A,	h : ∀ (x : X), ⇑F₁ (free_non_unital_non_assoc_algebra.of R x) = ⇑F₂ (free_non_unital_non_assoc_algebra.of R x),	x : X	⊢ ⇑((free_non_unital_non_assoc_algebra.lift R).symm) F₁ x = ⇑((free_non_unital_non_assoc_algebra.lift R).symm) F₂ x
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : gcd_monoid α,	a b c d₁ d₂ : α,	ha : a ≠ 0,	hab : gcd_monoid.gcd a b = 1,	k : ℕ,	h : a * b = c ^ k,	hc : c = d₁ * d₂,	hd₁ : d₁ ∣ a	⊢ d₁ ^ k ≠ 0 ∧ d₁ ^ k ∣ a
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : gcd_monoid α,	a b c d₁ d₂ : α,	ha : a ≠ 0,	hab : gcd_monoid.gcd a b = 1,	k : ℕ,	h : a * b = c ^ k,	hc : c = d₁ * d₂,	hd₁ : d₁ ∣ a	⊢ ⇑normalize (gcd_monoid.gcd (d₁ ^ k) b) = 1
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : gcd_monoid α,	a b c d₁ d₂ : α,	ha : a ≠ 0,	hab : gcd_monoid.gcd a b = 1,	k : ℕ,	h : a * b = c ^ k,	hc : c = d₁ * d₂,	hd₁ : d₁ ∣ a	⊢ gcd_monoid.gcd (d₁ ^ k) b = 1
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : gcd_monoid α,	a b c d₁ d₂ : α,	ha : a ≠ 0,	hab : gcd_monoid.gcd a b = 1,	k : ℕ,	h : a * b = c ^ k,	hc : c = d₁ * d₂,	hd₁ : d₁ ∣ a	⊢ is_unit (gcd_monoid.gcd (d₁ ^ k) b)
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : gcd_monoid α,	a b c d₁ d₂ : α,	ha : a ≠ 0,	hab : gcd_monoid.gcd a b = 1,	k : ℕ,	h : a * b = c ^ k,	hc : c = d₁ * d₂,	hd₁ : d₁ ∣ a	⊢ gcd_monoid.gcd (d₁ ^ k) b ∣ 1
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : gcd_monoid α,	a b c d₁ d₂ : α,	ha : a ≠ 0,	hab : gcd_monoid.gcd a b = 1,	k : ℕ,	h : a * b = c ^ k,	hc : c = d₁ * d₂,	hd₁ : d₁ ∣ a	⊢ gcd_monoid.gcd (d₁ ^ k) b ∣ gcd_monoid.gcd d₁ b ^ k		α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : gcd_monoid α,	a b c d₁ d₂ : α,	ha : a ≠ 0,	hab : gcd_monoid.gcd a b = 1,	k : ℕ,	h : a * b = c ^ k,	hc : c = d₁ * d₂,	hd₁ : d₁ ∣ a	⊢ gcd_monoid.gcd d₁ b ^ k ∣ 1
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : gcd_monoid α,	a b c d₁ d₂ : α,	ha : a ≠ 0,	hab : gcd_monoid.gcd a b = 1,	k : ℕ,	h : a * b = c ^ k,	hc : c = d₁ * d₂,	hd₁ : d₁ ∣ a	⊢ gcd_monoid.gcd (d₁ ^ k) b ∣ gcd_monoid.gcd d₁ b ^ k
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : gcd_monoid α,	a b c d₁ d₂ : α,	ha : a ≠ 0,	hab : gcd_monoid.gcd a b = 1,	k : ℕ,	h : a * b = c ^ k,	hc : c = d₁ * d₂,	hd₁ : d₁ ∣ a	⊢ is_unit (gcd_monoid.gcd d₁ b ^ k)
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : gcd_monoid α,	a b c d₁ d₂ : α,	ha : a ≠ 0,	hab : gcd_monoid.gcd a b = 1,	k : ℕ,	h : a * b = c ^ k,	hc : c = d₁ * d₂,	hd₁ : d₁ ∣ a	⊢ is_unit (gcd_monoid.gcd d₁ b)
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : gcd_monoid α,	a b c d₁ d₂ : α,	ha : a ≠ 0,	hab : gcd_monoid.gcd a b = 1,	k : ℕ,	h : a * b = c ^ k,	hc : c = d₁ * d₂,	hd₁ : d₁ ∣ a	⊢ gcd_monoid.gcd d₁ b ^ k ∣ 1
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : gcd_monoid α,	a b c d₁ d₂ : α,	ha : a ≠ 0,	hab : gcd_monoid.gcd a b = 1,	k : ℕ,	h : a * b = c ^ k,	hc : c = d₁ * d₂,	hd₁ : d₁ ∣ a	⊢ gcd_monoid.gcd d₁ b ∣ gcd_monoid.gcd a b
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : gcd_monoid α,	a b c d₁ d₂ : α,	ha : a ≠ 0,	hab : gcd_monoid.gcd a b = 1,	k : ℕ,	h : a * b = c ^ k,	hc : c = d₁ * d₂,	hd₁ : d₁ ∣ a	⊢ gcd_monoid.gcd (d₁ ^ k) b = 1		α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : gcd_monoid α,	a b c d₁ d₂ : α,	ha : a ≠ 0,	hab : gcd_monoid.gcd a b = 1,	k : ℕ,	h : a * b = c ^ k,	hc : c = d₁ * d₂,	hd₁ : d₁ ∣ a,	h1 : gcd_monoid.gcd (d₁ ^ k) b = 1	⊢ d₁ ^ k ≠ 0 ∧ d₁ ^ k ∣ a
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : gcd_monoid α,	a b c d₁ d₂ : α,	ha : a ≠ 0,	hab : gcd_monoid.gcd a b = 1,	k : ℕ,	h : a * b = c ^ k,	hc : c = d₁ * d₂,	hd₁ : d₁ ∣ a	⊢ gcd_monoid.gcd d₁ b ∣ 1
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : gcd_monoid α,	a b c d₁ d₂ : α,	ha : a ≠ 0,	hab : gcd_monoid.gcd a b = 1,	k : ℕ,	h : a * b = c ^ k,	hc : c = d₁ * d₂,	hd₁ : d₁ ∣ a,	h1 : gcd_monoid.gcd (d₁ ^ k) b = 1	⊢ d₁ ^ k ∣ a * b
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : gcd_monoid α,	a b c d₁ d₂ : α,	ha : a ≠ 0,	hab : gcd_monoid.gcd a b = 1,	k : ℕ,	h : a * b = c ^ k,	hc : c = d₁ * d₂,	hd₁ : d₁ ∣ a,	h1 : gcd_monoid.gcd (d₁ ^ k) b = 1	⊢ d₁ ^ k ≠ 0 ∧ d₁ ^ k ∣ a
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : gcd_monoid α,	a b c d₁ d₂ : α,	ha : a ≠ 0,	hab : gcd_monoid.gcd a b = 1,	k : ℕ,	h : a * b = c ^ k,	hc : c = d₁ * d₂,	hd₁ : d₁ ∣ a,	h1 : gcd_monoid.gcd (d₁ ^ k) b = 1	⊢ a * b = d₁ ^ k * d₂ ^ k
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : gcd_monoid α,	a b c d₁ d₂ : α,	ha : a ≠ 0,	hab : gcd_monoid.gcd a b = 1,	k : ℕ,	h : a * b = c ^ k,	hc : c = d₁ * d₂,	hd₁ : d₁ ∣ a,	h1 : gcd_monoid.gcd (d₁ ^ k) b = 1	⊢ (d₁ * d₂) ^ k = d₁ ^ k * d₂ ^ k
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : gcd_monoid α,	a b c d₁ d₂ : α,	ha : a ≠ 0,	hab : gcd_monoid.gcd a b = 1,	k : ℕ,	h : a * b = c ^ k,	hc : c = d₁ * d₂,	hd₁ : d₁ ∣ a,	h1 : gcd_monoid.gcd (d₁ ^ k) b = 1	⊢ d₁ ^ k ∣ a * b		α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : gcd_monoid α,	a b c d₁ d₂ : α,	ha : a ≠ 0,	hab : gcd_monoid.gcd a b = 1,	k : ℕ,	h : a * b = c ^ k,	hc : c = d₁ * d₂,	hd₁ : d₁ ∣ a,	h1 : gcd_monoid.gcd (d₁ ^ k) b = 1,	h2 : d₁ ^ k ∣ a * b	⊢ d₁ ^ k ≠ 0 ∧ d₁ ^ k ∣ a
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : gcd_monoid α,	a b c d₁ d₂ : α,	ha : a ≠ 0,	hab : gcd_monoid.gcd a b = 1,	k : ℕ,	h : a * b = c ^ k,	hc : c = d₁ * d₂,	hd₁ : d₁ ∣ a,	h1 : gcd_monoid.gcd (d₁ ^ k) b = 1,	h2 : d₁ ^ k ∣ a * b	⊢ d₁ ^ k ≠ 0 ∧ d₁ ^ k ∣ a
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : gcd_monoid α,	a b c d₁ d₂ : α,	ha : a ≠ 0,	hab : gcd_monoid.gcd a b = 1,	k : ℕ,	h : a * b = c ^ k,	hc : c = d₁ * d₂,	hd₁ : d₁ ∣ a,	h1 : gcd_monoid.gcd (d₁ ^ k) b = 1,	h2 : d₁ ^ k ∣ b * a	⊢ d₁ ^ k ∣ a
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : gcd_monoid α,	a b c d₁ d₂ : α,	ha : a ≠ 0,	hab : gcd_monoid.gcd a b = 1,	k : ℕ,	h : a * b = c ^ k,	hc : c = d₁ * d₂,	hd₁ : d₁ ∣ a,	h1 : gcd_monoid.gcd (d₁ ^ k) b = 1,	h2 : d₁ ^ k ∣ b * a	⊢ d₁ ^ k ≠ 0 ∧ d₁ ^ k ∣ a
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : gcd_monoid α,	a b c d₁ d₂ : α,	ha : a ≠ 0,	hab : gcd_monoid.gcd a b = 1,	k : ℕ,	h : a * b = c ^ k,	hc : c = d₁ * d₂,	hd₁ : d₁ ∣ a,	h1 : gcd_monoid.gcd (d₁ ^ k) b = 1,	h2 : d₁ ^ k ∣ b * a	⊢ d₁ ^ k ∣ gcd_monoid.gcd (d₁ ^ k) b * a
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : gcd_monoid α,	a b c d₁ d₂ : α,	ha : a ≠ 0,	hab : gcd_monoid.gcd a b = 1,	k : ℕ,	h : a * b = c ^ k,	hc : c = d₁ * d₂,	hd₁ : d₁ ∣ a,	h1 : gcd_monoid.gcd (d₁ ^ k) b = 1,	h2 : d₁ ^ k ∣ b * a	⊢ d₁ ^ k ∣ a		α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : gcd_monoid α,	a b c d₁ d₂ : α,	ha : a ≠ 0,	hab : gcd_monoid.gcd a b = 1,	k : ℕ,	h : a * b = c ^ k,	hc : c = d₁ * d₂,	hd₁ : d₁ ∣ a,	h1 : gcd_monoid.gcd (d₁ ^ k) b = 1,	h2 : d₁ ^ k ∣ b * a,	h3 : d₁ ^ k ∣ a	⊢ d₁ ^ k ≠ 0 ∧ d₁ ^ k ∣ a
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : gcd_monoid α,	a b c d₁ d₂ : α,	ha : a ≠ 0,	hab : gcd_monoid.gcd a b = 1,	k : ℕ,	h : a * b = c ^ k,	hc : c = d₁ * d₂,	hd₁ : d₁ ∣ a,	h1 : gcd_monoid.gcd (d₁ ^ k) b = 1,	h2 : d₁ ^ k ∣ b * a,	h3 : d₁ ^ k ∣ a	⊢ d₁ ^ k ≠ 0 ∧ d₁ ^ k ∣ a
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : gcd_monoid α,	a b c d₁ d₂ : α,	ha : a ≠ 0,	hab : gcd_monoid.gcd a b = 1,	k : ℕ,	h : a * b = c ^ k,	hc : c = d₁ * d₂,	hd₁ : d₁ ∣ a,	h1 : gcd_monoid.gcd (d₁ ^ k) b = 1,	h2 : d₁ ^ k ∣ b * a,	h3 : d₁ ^ k ∣ a,	hdk : d₁ ^ k = 0	⊢ false
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : gcd_monoid α,	a b c d₁ d₂ : α,	ha : a ≠ 0,	hab : gcd_monoid.gcd a b = 1,	k : ℕ,	h : a * b = c ^ k,	hc : c = d₁ * d₂,	hd₁ : d₁ ∣ a,	h1 : gcd_monoid.gcd (d₁ ^ k) b = 1,	h2 : d₁ ^ k ∣ b * a,	hdk : d₁ ^ k = 0,	h3 : 0 ∣ a	⊢ false
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : gcd_monoid α,	a b c d₁ d₂ : α,	ha : a ≠ 0,	hab : gcd_monoid.gcd a b = 1,	k : ℕ,	h : a * b = c ^ k,	hc : c = d₁ * d₂,	hd₁ : d₁ ∣ a,	h1 : gcd_monoid.gcd (d₁ ^ k) b = 1,	h2 : d₁ ^ k ∣ b * a,	h3 : d₁ ^ k ∣ a	⊢ d₁ ^ k ≠ 0
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : gcd_monoid α,	a b c d₁ d₂ : α,	ha : a ≠ 0,	hab : gcd_monoid.gcd a b = 1,	k : ℕ,	h : a * b = c ^ k,	hc : c = d₁ * d₂,	hd₁ : d₁ ∣ a,	h1 : gcd_monoid.gcd (d₁ ^ k) b = 1,	h2 : d₁ ^ k ∣ b * a,	h3 : d₁ ^ k ∣ a	⊢ d₁ ^ k ≠ 0		α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : gcd_monoid α,	a b c d₁ d₂ : α,	ha : a ≠ 0,	hab : gcd_monoid.gcd a b = 1,	k : ℕ,	h : a * b = c ^ k,	hc : c = d₁ * d₂,	hd₁ : d₁ ∣ a,	h1 : gcd_monoid.gcd (d₁ ^ k) b = 1,	h2 : d₁ ^ k ∣ b * a,	h3 : d₁ ^ k ∣ a,	h4 : d₁ ^ k ≠ 0	⊢ d₁ ^ k ≠ 0 ∧ d₁ ^ k ∣ a
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : gcd_monoid α,	a b c d₁ d₂ : α,	ha : a ≠ 0,	hab : gcd_monoid.gcd a b = 1,	k : ℕ,	h : a * b = c ^ k,	hc : c = d₁ * d₂,	hd₁ : d₁ ∣ a,	h1 : gcd_monoid.gcd (d₁ ^ k) b = 1,	h2 : d₁ ^ k ∣ b * a,	h3 : d₁ ^ k ∣ a,	h4 : d₁ ^ k ≠ 0	⊢ d₁ ^ k ≠ 0 ∧ d₁ ^ k ∣ a
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : gcd_monoid α,	_inst_4 : decidable_eq α,	s : multiset α	⊢ 0.erase_dup.lcm = 0.lcm
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : gcd_monoid α,	_inst_4 : decidable_eq α,	s : multiset α,	a : α,	s : multiset α,	IH : s.erase_dup.lcm = s.lcm	⊢ (a ::ₘ s).erase_dup.lcm = (a ::ₘ s).lcm
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : gcd_monoid α,	_inst_4 : decidable_eq α,	s : multiset α,	a : α,	s : multiset α,	IH : s.erase_dup.lcm = s.lcm,	h : a ∈ s	⊢ (a ::ₘ s).erase_dup.lcm = (a ::ₘ s).lcm
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : gcd_monoid α,	_inst_4 : decidable_eq α,	s : multiset α,	a : α,	s : multiset α,	IH : s.erase_dup.lcm = s.lcm,	h : a ∉ s	⊢ (a ::ₘ s).erase_dup.lcm = (a ::ₘ s).lcm
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : gcd_monoid α,	_inst_4 : decidable_eq α,	s : multiset α,	a : α,	s : multiset α,	IH : s.erase_dup.lcm = s.lcm	⊢ (a ::ₘ s).erase_dup.lcm = (a ::ₘ s).lcm
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : gcd_monoid α,	_inst_4 : decidable_eq α,	s : multiset α,	a : α,	s : multiset α,	IH : s.erase_dup.lcm = s.lcm,	h : a ∈ s	⊢ s.lcm = gcd_monoid.lcm a s.lcm
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : gcd_monoid α,	_inst_4 : decidable_eq α,	s : multiset α,	a : α,	s : multiset α,	IH : s.erase_dup.lcm = s.lcm,	h : a ∈ s	⊢ multiset.fold gcd_monoid.lcm 1 s = gcd_monoid.lcm a (multiset.fold gcd_monoid.lcm 1 s)
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : gcd_monoid α,	_inst_4 : decidable_eq α,	s : multiset α,	a : α,	s : multiset α,	IH : s.erase_dup.lcm = s.lcm,	h : a ∈ s	⊢ gcd_monoid.lcm a (multiset.fold gcd_monoid.lcm 1 (s.erase a)) = gcd_monoid.lcm (⇑normalize a) (multiset.fold gcd_monoid.lcm 1 (s.erase a))
α : Type u,	_inst_1 : semiring α,	x y : α,	h : commute x y,	f : ℕ → ℕ → α := λ (m i : ℕ), (x + y) ^ i * y ^ (m - 1 - i),	n : ℕ,	ih : (∑ (i : ℕ) in finset.range n, f n i) * x + y ^ n = (x + y) ^ n	⊢ (∑ (i : ℕ) in finset.range n.succ, f n.succ i) * x + y ^ n.succ = (x + y) ^ n.succ
α : Type u,	_inst_1 : semiring α,	x y : α,	h : commute x y,	f : ℕ → ℕ → α := λ (m i : ℕ), (x + y) ^ i * y ^ (m - 1 - i),	n : ℕ,	ih : (∑ (i : ℕ) in finset.range n, f n i) * x + y ^ n = (x + y) ^ n	⊢ f (n + 1) n = (x + y) ^ n
α : Type u,	_inst_1 : semiring α,	x y : α,	h : commute x y,	f : ℕ → ℕ → α := λ (m i : ℕ), (x + y) ^ i * y ^ (m - 1 - i),	n : ℕ,	ih : (∑ (i : ℕ) in finset.range n, f n i) * x + y ^ n = (x + y) ^ n	⊢ (x + y) ^ n * y ^ (n + 1 - 1 - n) = (x + y) ^ n
α : Type u,	_inst_1 : semiring α,	x y : α,	h : commute x y,	f : ℕ → ℕ → α := λ (m i : ℕ), (x + y) ^ i * y ^ (m - 1 - i),	n : ℕ,	ih : (∑ (i : ℕ) in finset.range n, f n i) * x + y ^ n = (x + y) ^ n,	f_last : f (n + 1) n = (x + y) ^ n	⊢ (∑ (i : ℕ) in finset.range n.succ, f n.succ i) * x + y ^ n.succ = (x + y) ^ n.succ
α : Type u,	_inst_1 : semiring α,	x y : α,	h : commute x y,	f : ℕ → ℕ → α := λ (m i : ℕ), (x + y) ^ i * y ^ (m - 1 - i),	n : ℕ,	ih : (∑ (i : ℕ) in finset.range n, f n i) * x + y ^ n = (x + y) ^ n,	f_last : f (n + 1) n = (x + y) ^ n,	i : ℕ,	hi : i ∈ finset.range n	⊢ f (n + 1) i = y * f n i
α : Type u,	_inst_1 : semiring α,	x y : α,	h : commute x y,	f : ℕ → ℕ → α := λ (m i : ℕ), (x + y) ^ i * y ^ (m - 1 - i),	n : ℕ,	ih : (∑ (i : ℕ) in finset.range n, f n i) * x + y ^ n = (x + y) ^ n,	f_last : f (n + 1) n = (x + y) ^ n,	i : ℕ,	hi : i ∈ finset.range n	⊢ (x + y) ^ i * y ^ (n + 1 - 1 - i) = y * ((x + y) ^ i * y ^ (n - 1 - i))
α : Type u,	_inst_1 : semiring α,	x y : α,	h : commute x y,	f : ℕ → ℕ → α := λ (m i : ℕ), (x + y) ^ i * y ^ (m - 1 - i),	n : ℕ,	ih : (∑ (i : ℕ) in finset.range n, f n i) * x + y ^ n = (x + y) ^ n,	f_last : f (n + 1) n = (x + y) ^ n,	i : ℕ,	hi : i ∈ finset.range n,	this : commute y ((x + y) ^ i)	⊢ (x + y) ^ i * y ^ (n + 1 - 1 - i) = y * ((x + y) ^ i * y ^ (n - 1 - i))
α : Type u,	_inst_1 : semiring α,	x y : α,	h : commute x y,	f : ℕ → ℕ → α := λ (m i : ℕ), (x + y) ^ i * y ^ (m - 1 - i),	n : ℕ,	ih : (∑ (i : ℕ) in finset.range n, f n i) * x + y ^ n = (x + y) ^ n,	f_last : f (n + 1) n = (x + y) ^ n,	i : ℕ,	hi : i ∈ finset.range n,	this : commute y ((x + y) ^ i)	⊢ (x + y) ^ i * y ^ (n + 1 - 1 - i) = (x + y) ^ i * y ^ (n - 1 - i + 1)
α : Type u,	_inst_1 : semiring α,	x y : α,	h : commute x y,	f : ℕ → ℕ → α := λ (m i : ℕ), (x + y) ^ i * y ^ (m - 1 - i),	n : ℕ,	ih : (∑ (i : ℕ) in finset.range n, f n i) * x + y ^ n = (x + y) ^ n,	f_last : f (n + 1) n = (x + y) ^ n,	i : ℕ,	hi : i ∈ finset.range n,	this : commute y ((x + y) ^ i)	⊢ n + 1 - 1 - i = n - 1 - i + 1
α : Type u,	_inst_1 : semiring α,	x y : α,	h : commute x y,	f : ℕ → ℕ → α := λ (m i : ℕ), (x + y) ^ i * y ^ (m - 1 - i),	n : ℕ,	ih : (∑ (i : ℕ) in finset.range n, f n i) * x + y ^ n = (x + y) ^ n,	f_last : f (n + 1) n = (x + y) ^ n,	i : ℕ,	hi : i ∈ finset.range n,	this : commute y ((x + y) ^ i)	⊢ n - i = n - (i + 1) + 1
α : Type u,	_inst_1 : semiring α,	x y : α,	h : commute x y,	f : ℕ → ℕ → α := λ (m i : ℕ), (x + y) ^ i * y ^ (m - 1 - i),	n : ℕ,	ih : (∑ (i : ℕ) in finset.range n, f n i) * x + y ^ n = (x + y) ^ n,	f_last : f (n + 1) n = (x + y) ^ n,	i : ℕ,	hi : i ∈ finset.range n,	this : commute y ((x + y) ^ i),	this : i + 1 + (n - (i + 1)) = n	⊢ n - i = n - (i + 1) + 1
α : Type u,	_inst_1 : semiring α,	x y : α,	h : commute x y,	f : ℕ → ℕ → α := λ (m i : ℕ), (x + y) ^ i * y ^ (m - 1 - i),	n : ℕ,	ih : (∑ (i : ℕ) in finset.range n, f n i) * x + y ^ n = (x + y) ^ n,	f_last : f (n + 1) n = (x + y) ^ n,	i : ℕ,	hi : i ∈ finset.range n,	this : commute y ((x + y) ^ i),	this : n - (i + 1) + (i + 1) = n	⊢ n - i = n - (i + 1) + 1
α : Type u,	_inst_1 : semiring α,	x y : α,	h : commute x y,	f : ℕ → ℕ → α := λ (m i : ℕ), (x + y) ^ i * y ^ (m - 1 - i),	n : ℕ,	ih : (∑ (i : ℕ) in finset.range n, f n i) * x + y ^ n = (x + y) ^ n,	f_last : f (n + 1) n = (x + y) ^ n,	f_succ : ∀ (i : ℕ), i ∈ finset.range n → f (n + 1) i = y * f n i	⊢ (∑ (i : ℕ) in finset.range n.succ, f n.succ i) * x + y ^ n.succ = (x + y) ^ n.succ
α : Type u,	_inst_1 : semiring α,	x y : α,	h : commute x y,	f : ℕ → ℕ → α := λ (m i : ℕ), (x + y) ^ i * y ^ (m - 1 - i),	n : ℕ,	ih : (∑ (i : ℕ) in finset.range n, f n i) * x + y ^ n = (x + y) ^ n,	f_last : f (n + 1) n = (x + y) ^ n,	f_succ : ∀ (i : ℕ), i ∈ finset.range n → f (n + 1) i = y * f n i	⊢ (x + y) ^ n * x + ((∑ (x : ℕ) in finset.range n, f n.succ x) * x + y ^ n.succ) = x * (x + y) ^ n + y * (x + y) ^ n
α : Type u,	_inst_1 : semiring α,	x y : α,	h : commute x y,	f : ℕ → ℕ → α := λ (m i : ℕ), (x + y) ^ i * y ^ (m - 1 - i),	n : ℕ,	ih : (∑ (i : ℕ) in finset.range n, f n i) * x + y ^ n = (x + y) ^ n,	f_last : f (n + 1) n = (x + y) ^ n,	f_succ : ∀ (i : ℕ), i ∈ finset.range n → f (n + 1) i = y * f n i	⊢ (x + y) ^ n * x + ((∑ (x : ℕ) in finset.range n, f n.succ x) * x + y ^ n.succ) = (x + y) ^ n * x + y * (x + y) ^ n
α : Type u,	_inst_1 : semiring α,	x y : α,	h : commute x y,	f : ℕ → ℕ → α := λ (m i : ℕ), (x + y) ^ i * y ^ (m - 1 - i),	n : ℕ,	ih : (∑ (i : ℕ) in finset.range n, f n i) * x + y ^ n = (x + y) ^ n,	f_last : f (n + 1) n = (x + y) ^ n,	f_succ : ∀ (i : ℕ), i ∈ finset.range n → f (n + 1) i = y * f n i	⊢ (∑ (x : ℕ) in finset.range n, f n.succ x) * x + y ^ n.succ = y * (x + y) ^ n
α : Type u,	_inst_1 : division_ring α,	x : α,	hx : x ≠ 1,	m n : ℕ,	hmn : m ≤ n	⊢ (x ^ n - x ^ m) / (x - 1) = (x ^ m - x ^ n) / (1 - x)
α : Type u,	_inst_1 : division_ring α,	x : α,	hx : x ≠ 1,	m n : ℕ,	hmn : m ≤ n	⊢ ∑ (i : ℕ) in finset.Ico m n, x ^ i = (x ^ m - x ^ n) / (1 - x)
α : Type u,	_inst_1 : division_ring α,	x : α,	hx : x ≠ 1,	m n : ℕ,	hmn : m ≤ n	⊢ (x ^ n - x ^ m) / (x - 1) = (x ^ m - x ^ n) / (1 - x)
α : Type u,	_inst_1 : division_ring α,	x : α,	hx : x ≠ 1,	m n : ℕ,	hmn : m ≤ n	⊢ x ^ n - x ^ m = -(x ^ m - x ^ n)
α : Type u,	_inst_1 : division_ring α,	x : α,	hx : x ≠ 1,	m n : ℕ,	hmn : m ≤ n	⊢ x - 1 = -(1 - x)
α : Type u,	_inst_1 : semiring α,	x y : α,	h : commute x y,	n : ℕ	⊢ geom_sum₂ (x + y) y n * x + y ^ n = (x + y) ^ n
α : Type u,	_inst_1 : semiring α,	x y : α,	h : commute x y,	n : ℕ,	f : ℕ → ℕ → α := λ (m i : ℕ), (x + y) ^ i * y ^ (m - 1 - i)	⊢ geom_sum₂ (x + y) y n * x + y ^ n = (x + y) ^ n
α : Type u,	_inst_1 : semiring α,	x y : α,	h : commute x y,	n : ℕ,	f : ℕ → ℕ → α := λ (m i : ℕ), (x + y) ^ i * y ^ (m - 1 - i)	⊢ (∑ (i : ℕ) in finset.range n, f n i) * x + y ^ n = (x + y) ^ n
α : Type u,	_inst_1 : semiring α,	x y : α,	h : commute x y,	f : ℕ → ℕ → α := λ (m i : ℕ), (x + y) ^ i * y ^ (m - 1 - i)	⊢ (∑ (i : ℕ) in finset.range 0, f 0 i) * x + y ^ 0 = (x + y) ^ 0
α : Type u,	_inst_1 : semiring α,	x y : α,	h : commute x y,	f : ℕ → ℕ → α := λ (m i : ℕ), (x + y) ^ i * y ^ (m - 1 - i)	⊢ (∑ (i : ℕ) in finset.range 0, f 0 i) * x + y ^ 0 = (x + y) ^ 0		case nat.succ	α : Type u,	_inst_1 : semiring α,	x y : α,	h : commute x y,	f : ℕ → ℕ → α := λ (m i : ℕ), (x + y) ^ i * y ^ (m - 1 - i),	n : ℕ,	ih : (∑ (i : ℕ) in finset.range n, f n i) * x + y ^ n = (x + y) ^ n	⊢ (∑ (i : ℕ) in finset.range n.succ, f n.succ i) * x + y ^ n.succ = (x + y) ^ n.succ
M : Type u,	_inst_1 : right_cancel_monoid M,	a b : M	⊢ a * b = b ↔ a * b = 1 * b
G : Type u,	_inst_1 : add_comm_group G,	a b c d : G	⊢ a - b = c - d ↔ a - c = b - d
M : Type u,	_inst_1 : mul_one_class M,	P : Prop,	_inst_2 : decidable P,	a b : M	⊢ ite P (a * b) 1 = ite P a 1 * ite P b 1
M : Type u,	_inst_1 : mul_one_class M,	P : Prop,	_inst_2 : decidable P,	a b : M,	h : P	⊢ ite P (a * b) 1 = ite P a 1 * ite P b 1
M : Type u,	_inst_1 : mul_one_class M,	P : Prop,	_inst_2 : decidable P,	a b : M,	h : ¬P	⊢ ite P (a * b) 1 = ite P a 1 * ite P b 1
M : Type u,	_inst_1 : mul_one_class M,	P : Prop,	_inst_2 : decidable P,	a b : M	⊢ ite P (a * b) 1 = ite P a 1 * ite P b 1
α : Type u_1,	_inst_3 : comm_monoid α,	a b : α,	_x : is_conj a b,	_fun_match : is_conj a b → a = b,	c : units α,	hc : semiconj_by ↑c a b	⊢ a = b
α : Type u_1,	_inst_3 : comm_monoid α,	a b : α,	_x : is_conj a b,	_fun_match : is_conj a b → a = b,	c : units α,	hc : a = b	⊢ a = b
α : Type u_1,	_inst_3 : comm_monoid α,	a b : α,	h : a = b	⊢ is_conj a b
M : Type u_1,	m₁ m₂ : div_inv_monoid M,	h_mul : div_inv_monoid.mul = div_inv_monoid.mul,	h_inv : div_inv_monoid.inv = div_inv_monoid.inv	⊢ m₁ = m₂
M : Type u_1,	m₁ m₂ : div_inv_monoid M,	h_mul : div_inv_monoid.mul = div_inv_monoid.mul,	h_inv : div_inv_monoid.inv = div_inv_monoid.inv,	iM : div_inv_monoid M := m₁	⊢ m₁ = m₂
M : Type u_1,	m₁ m₂ : div_inv_monoid M,	h_mul : div_inv_monoid.mul = div_inv_monoid.mul,	h_inv : div_inv_monoid.inv = div_inv_monoid.inv,	iM : div_inv_monoid M := m₁	⊢ m₁ = m₂
M : Type u_1,	m₂ : div_inv_monoid M,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	h_mul : div_inv_monoid.mul = div_inv_monoid.mul,	h_inv : div_inv_monoid.inv = div_inv_monoid.inv,	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁}	⊢ {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁} = m₂
M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	mul₂ : M → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₂ : M,	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow₂ : ℕ → M → M,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₂ : M → M,	div₂ : M → M → M,	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₂ : ℤ → M → M,	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	h_mul : div_inv_monoid.mul = div_inv_monoid.mul,	h_inv : div_inv_monoid.inv = div_inv_monoid.inv	⊢ {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁} = {mul := mul₂, mul_assoc := m₂_mul_assoc, one := one₂, one_mul := one_mul₂, mul_one := mul_one₂, npow := npow₂, npow_zero' := npow_zero₂, npow_succ' := npow_succ₂, inv := inv₂, div := div₂, div_eq_mul_inv := div_eq_mul_inv₂, gpow := gpow₂, gpow_zero' := gpow_zero'₂, gpow_succ' := gpow_succ'₂, gpow_neg' := gpow_neg'₂}
M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	mul₂ : M → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₂ : M,	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow₂ : ℕ → M → M,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₂ : M → M,	div₂ : M → M → M,	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₂ : ℤ → M → M,	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	h_inv : div_inv_monoid.inv = div_inv_monoid.inv,	h_mul : mul₁ = mul₂	⊢ {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁} = {mul := mul₂, mul_assoc := m₂_mul_assoc, one := one₂, one_mul := one_mul₂, mul_one := mul_one₂, npow := npow₂, npow_zero' := npow_zero₂, npow_succ' := npow_succ₂, inv := inv₂, div := div₂, div_eq_mul_inv := div_eq_mul_inv₂, gpow := gpow₂, gpow_zero' := gpow_zero'₂, gpow_succ' := gpow_succ'₂, gpow_neg' := gpow_neg'₂}
M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	one₂ : M,	npow₂ : ℕ → M → M,	inv₂ : M → M,	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	h_inv : div_inv_monoid.inv = div_inv_monoid.inv	⊢ {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁} = {mul := mul₁, mul_assoc := m₂_mul_assoc, one := one₂, one_mul := one_mul₂, mul_one := mul_one₂, npow := npow₂, npow_zero' := npow_zero₂, npow_succ' := npow_succ₂, inv := inv₂, div := div₂, div_eq_mul_inv := div_eq_mul_inv₂, gpow := gpow₂, gpow_zero' := gpow_zero'₂, gpow_succ' := gpow_succ'₂, gpow_neg' := gpow_neg'₂}
M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	one₂ : M,	npow₂ : ℕ → M → M,	inv₂ : M → M,	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	h_inv : div_inv_monoid.inv = div_inv_monoid.inv	⊢ one₁ = one₂
M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	one₂ : M,	npow₂ : ℕ → M → M,	inv₂ : M → M,	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	h_inv : div_inv_monoid.inv = div_inv_monoid.inv	⊢ one₁ = one₂		M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	one₂ : M,	npow₂ : ℕ → M → M,	inv₂ : M → M,	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	h_inv : div_inv_monoid.inv = div_inv_monoid.inv,	h_one : one₁ = one₂	⊢ {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁} = {mul := mul₁, mul_assoc := m₂_mul_assoc, one := one₂, one_mul := one_mul₂, mul_one := mul_one₂, npow := npow₂, npow_zero' := npow_zero₂, npow_succ' := npow_succ₂, inv := inv₂, div := div₂, div_eq_mul_inv := div_eq_mul_inv₂, gpow := gpow₂, gpow_zero' := gpow_zero'₂, gpow_succ' := gpow_succ'₂, gpow_neg' := gpow_neg'₂}
M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	one₂ : M,	npow₂ : ℕ → M → M,	inv₂ : M → M,	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	h_inv : div_inv_monoid.inv = div_inv_monoid.inv	⊢ 1 * one₁ = one₂
M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	one₂ : M,	npow₂ : ℕ → M → M,	inv₂ : M → M,	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	h_inv : div_inv_monoid.inv = div_inv_monoid.inv,	h_one : one₁ = one₂	⊢ {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁} = {mul := mul₁, mul_assoc := m₂_mul_assoc, one := one₂, one_mul := one_mul₂, mul_one := mul_one₂, npow := npow₂, npow_zero' := npow_zero₂, npow_succ' := npow_succ₂, inv := inv₂, div := div₂, div_eq_mul_inv := div_eq_mul_inv₂, gpow := gpow₂, gpow_zero' := gpow_zero'₂, gpow_succ' := gpow_succ'₂, gpow_neg' := gpow_neg'₂}
M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	npow₂ : ℕ → M → M,	inv₂ : M → M,	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	h_inv : div_inv_monoid.inv = div_inv_monoid.inv	⊢ {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁} = {mul := mul₁, mul_assoc := m₂_mul_assoc, one := one₁, one_mul := one_mul₂, mul_one := mul_one₂, npow := npow₂, npow_zero' := npow_zero₂, npow_succ' := npow_succ₂, inv := inv₂, div := div₂, div_eq_mul_inv := div_eq_mul_inv₂, gpow := gpow₂, gpow_zero' := gpow_zero'₂, gpow_succ' := gpow_succ'₂, gpow_neg' := gpow_neg'₂}
M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	npow₂ : ℕ → M → M,	inv₂ : M → M,	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	h_inv : div_inv_monoid.inv = div_inv_monoid.inv	⊢ npow₁ = npow₂
M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	npow₂ : ℕ → M → M,	inv₂ : M → M,	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	h_inv : div_inv_monoid.inv = div_inv_monoid.inv,	n : ℕ,	x : M	⊢ npow₁ n x = npow₂ n x
M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	npow₂ : ℕ → M → M,	inv₂ : M → M,	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	h_inv : div_inv_monoid.inv = div_inv_monoid.inv,	x : M	⊢ npow₁ 0 x = npow₂ 0 x		case nat.succ	M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	npow₂ : ℕ → M → M,	inv₂ : M → M,	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	h_inv : div_inv_monoid.inv = div_inv_monoid.inv,	x : M,	d : ℕ,	hd : npow₁ d x = npow₂ d x	⊢ npow₁ d.succ x = npow₂ d.succ x
M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	npow₂ : ℕ → M → M,	inv₂ : M → M,	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	h_inv : div_inv_monoid.inv = div_inv_monoid.inv,	x : M	⊢ npow₁ 0 x = npow₂ 0 x
M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	npow₂ : ℕ → M → M,	inv₂ : M → M,	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	h_inv : div_inv_monoid.inv = div_inv_monoid.inv	⊢ npow₁ = npow₂		M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	npow₂ : ℕ → M → M,	inv₂ : M → M,	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	h_inv : div_inv_monoid.inv = div_inv_monoid.inv,	h_npow : npow₁ = npow₂	⊢ {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁} = {mul := mul₁, mul_assoc := m₂_mul_assoc, one := one₁, one_mul := one_mul₂, mul_one := mul_one₂, npow := npow₂, npow_zero' := npow_zero₂, npow_succ' := npow_succ₂, inv := inv₂, div := div₂, div_eq_mul_inv := div_eq_mul_inv₂, gpow := gpow₂, gpow_zero' := gpow_zero'₂, gpow_succ' := gpow_succ'₂, gpow_neg' := gpow_neg'₂}
M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	npow₂ : ℕ → M → M,	inv₂ : M → M,	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	h_inv : div_inv_monoid.inv = div_inv_monoid.inv,	x : M,	d : ℕ,	hd : npow₁ d x = npow₂ d x	⊢ npow₁ d.succ x = npow₂ d.succ x
M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	npow₂ : ℕ → M → M,	inv₂ : M → M,	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	h_inv : div_inv_monoid.inv = div_inv_monoid.inv,	h_npow : npow₁ = npow₂	⊢ {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁} = {mul := mul₁, mul_assoc := m₂_mul_assoc, one := one₁, one_mul := one_mul₂, mul_one := mul_one₂, npow := npow₂, npow_zero' := npow_zero₂, npow_succ' := npow_succ₂, inv := inv₂, div := div₂, div_eq_mul_inv := div_eq_mul_inv₂, gpow := gpow₂, gpow_zero' := gpow_zero'₂, gpow_succ' := gpow_succ'₂, gpow_neg' := gpow_neg'₂}
M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	inv₂ : M → M,	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	h_inv : div_inv_monoid.inv = div_inv_monoid.inv	⊢ {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁} = {mul := mul₁, mul_assoc := m₂_mul_assoc, one := one₁, one_mul := one_mul₂, mul_one := mul_one₂, npow := npow₁, npow_zero' := npow_zero₂, npow_succ' := npow_succ₂, inv := inv₂, div := div₂, div_eq_mul_inv := div_eq_mul_inv₂, gpow := gpow₂, gpow_zero' := gpow_zero'₂, gpow_succ' := gpow_succ'₂, gpow_neg' := gpow_neg'₂}
M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	inv₂ : M → M,	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	h_inv : inv₁ = inv₂	⊢ {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁} = {mul := mul₁, mul_assoc := m₂_mul_assoc, one := one₁, one_mul := one_mul₂, mul_one := mul_one₂, npow := npow₁, npow_zero' := npow_zero₂, npow_succ' := npow_succ₂, inv := inv₂, div := div₂, div_eq_mul_inv := div_eq_mul_inv₂, gpow := gpow₂, gpow_zero' := gpow_zero'₂, gpow_succ' := gpow_succ'₂, gpow_neg' := gpow_neg'₂}
M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous)	⊢ {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁} = {mul := mul₁, mul_assoc := m₂_mul_assoc, one := one₁, one_mul := one_mul₂, mul_one := mul_one₂, npow := npow₁, npow_zero' := npow_zero₂, npow_succ' := npow_succ₂, inv := inv₁, div := div₂, div_eq_mul_inv := div_eq_mul_inv₂, gpow := gpow₂, gpow_zero' := gpow_zero'₂, gpow_succ' := gpow_succ'₂, gpow_neg' := gpow_neg'₂}
M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous)	⊢ div₁ = div₂
M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	a b : M	⊢ div₁ a b = div₂ a b
M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	a b : M	⊢ div₁ a b = a * b⁻¹		M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	a b : M	⊢ div₂ a b = a * b⁻¹
M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	a b : M	⊢ div₁ a b = a * b⁻¹
M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous)	⊢ div₁ = div₂		M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	h_div : div₁ = div₂	⊢ {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁} = {mul := mul₁, mul_assoc := m₂_mul_assoc, one := one₁, one_mul := one_mul₂, mul_one := mul_one₂, npow := npow₁, npow_zero' := npow_zero₂, npow_succ' := npow_succ₂, inv := inv₁, div := div₂, div_eq_mul_inv := div_eq_mul_inv₂, gpow := gpow₂, gpow_zero' := gpow_zero'₂, gpow_succ' := gpow_succ'₂, gpow_neg' := gpow_neg'₂}
M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	a b : M	⊢ div₂ a b = a * b⁻¹
M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	h_div : div₁ = div₂	⊢ {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁} = {mul := mul₁, mul_assoc := m₂_mul_assoc, one := one₁, one_mul := one_mul₂, mul_one := mul_one₂, npow := npow₁, npow_zero' := npow_zero₂, npow_succ' := npow_succ₂, inv := inv₁, div := div₂, div_eq_mul_inv := div_eq_mul_inv₂, gpow := gpow₂, gpow_zero' := gpow_zero'₂, gpow_succ' := gpow_succ'₂, gpow_neg' := gpow_neg'₂}
M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous)	⊢ {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁} = {mul := mul₁, mul_assoc := m₂_mul_assoc, one := one₁, one_mul := one_mul₂, mul_one := mul_one₂, npow := npow₁, npow_zero' := npow_zero₂, npow_succ' := npow_succ₂, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₂, gpow := gpow₂, gpow_zero' := gpow_zero'₂, gpow_succ' := gpow_succ'₂, gpow_neg' := gpow_neg'₂}
M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous)	⊢ ∀ (n : ℕ) (g : M), gpow₁ (int.of_nat n) g = gpow₂ (int.of_nat n) g
M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	n : ℕ,	g : M	⊢ gpow₁ (int.of_nat n) g = gpow₂ (int.of_nat n) g
M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	g : M	⊢ gpow₁ (int.of_nat 0) g = gpow₂ (int.of_nat 0) g
M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	g : M	⊢ gpow₁ (int.of_nat 0) g = 1		M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	g : M	⊢ gpow₂ (int.of_nat 0) g = 1
M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	g : M	⊢ gpow₁ (int.of_nat 0) g = 1
M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	g : M	⊢ gpow₁ (int.of_nat 0) g = gpow₂ (int.of_nat 0) g		case nat.succ	M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	g : M,	n : ℕ,	IH : gpow₁ (int.of_nat n) g = gpow₂ (int.of_nat n) g	⊢ gpow₁ (int.of_nat n.succ) g = gpow₂ (int.of_nat n.succ) g
M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	g : M	⊢ gpow₂ (int.of_nat 0) g = 1
M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous)	⊢ ∀ (n : ℕ) (g : M), gpow₁ (int.of_nat n) g = gpow₂ (int.of_nat n) g		M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	h_gpow_aux : ∀ (n : ℕ) (g : M), gpow₁ (int.of_nat n) g = gpow₂ (int.of_nat n) g	⊢ {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁} = {mul := mul₁, mul_assoc := m₂_mul_assoc, one := one₁, one_mul := one_mul₂, mul_one := mul_one₂, npow := npow₁, npow_zero' := npow_zero₂, npow_succ' := npow_succ₂, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₂, gpow := gpow₂, gpow_zero' := gpow_zero'₂, gpow_succ' := gpow_succ'₂, gpow_neg' := gpow_neg'₂}
M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	g : M,	n : ℕ,	IH : gpow₁ (int.of_nat n) g = gpow₂ (int.of_nat n) g	⊢ gpow₁ (int.of_nat n.succ) g = gpow₂ (int.of_nat n.succ) g
M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	h_gpow_aux : ∀ (n : ℕ) (g : M), gpow₁ (int.of_nat n) g = gpow₂ (int.of_nat n) g	⊢ {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁} = {mul := mul₁, mul_assoc := m₂_mul_assoc, one := one₁, one_mul := one_mul₂, mul_one := mul_one₂, npow := npow₁, npow_zero' := npow_zero₂, npow_succ' := npow_succ₂, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₂, gpow := gpow₂, gpow_zero' := gpow_zero'₂, gpow_succ' := gpow_succ'₂, gpow_neg' := gpow_neg'₂}
M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	h_gpow_aux : ∀ (n : ℕ) (g : M), gpow₁ (int.of_nat n) g = gpow₂ (int.of_nat n) g	⊢ gpow₁ = gpow₂
M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	h_gpow_aux : ∀ (n : ℕ) (g : M), gpow₁ (int.of_nat n) g = gpow₂ (int.of_nat n) g,	z : ℤ,	x : M	⊢ gpow₁ z x = gpow₂ z x
M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	h_gpow_aux : ∀ (n : ℕ) (g : M), gpow₁ (int.of_nat n) g = gpow₂ (int.of_nat n) g,	x : M,	z : ℕ	⊢ gpow₁ (int.of_nat z) x = gpow₂ (int.of_nat z) x		case int.neg_succ_of_nat	M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	h_gpow_aux : ∀ (n : ℕ) (g : M), gpow₁ (int.of_nat n) g = gpow₂ (int.of_nat n) g,	x : M,	z : ℕ	⊢ gpow₁ -[1+ z] x = gpow₂ -[1+ z] x
M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	h_gpow_aux : ∀ (n : ℕ) (g : M), gpow₁ (int.of_nat n) g = gpow₂ (int.of_nat n) g,	x : M,	z : ℕ	⊢ gpow₁ (int.of_nat z) x = gpow₂ (int.of_nat z) x
M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	h_gpow_aux : ∀ (n : ℕ) (g : M), gpow₁ (int.of_nat n) g = gpow₂ (int.of_nat n) g,	x : M,	z : ℕ	⊢ gpow₁ -[1+ z] x = gpow₂ -[1+ z] x
M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	h_gpow_aux : ∀ (n : ℕ) (g : M), gpow₁ (int.of_nat n) g = gpow₂ (int.of_nat n) g,	x : M,	z : ℕ	⊢ (gpow₁ ↑(z.succ) x)⁻¹ = (gpow₂ ↑(z.succ) x)⁻¹
M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	h_gpow_aux : ∀ (n : ℕ) (g : M), gpow₁ (int.of_nat n) g = gpow₂ (int.of_nat n) g	⊢ gpow₁ = gpow₂		M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	h_gpow_aux : ∀ (n : ℕ) (g : M), gpow₁ (int.of_nat n) g = gpow₂ (int.of_nat n) g,	h_gpow : gpow₁ = gpow₂	⊢ {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁} = {mul := mul₁, mul_assoc := m₂_mul_assoc, one := one₁, one_mul := one_mul₂, mul_one := mul_one₂, npow := npow₁, npow_zero' := npow_zero₂, npow_succ' := npow_succ₂, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₂, gpow := gpow₂, gpow_zero' := gpow_zero'₂, gpow_succ' := gpow_succ'₂, gpow_neg' := gpow_neg'₂}
M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	h_gpow_aux : ∀ (n : ℕ) (g : M), gpow₁ (int.of_nat n) g = gpow₂ (int.of_nat n) g,	x : M,	z : ℕ	⊢ gpow₁ ↑(z.succ) x = gpow₂ ↑(z.succ) x
M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ : auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M := {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ : auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a) (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ : auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	h_gpow_aux : ∀ (n : ℕ) (g : M), gpow₁ (int.of_nat n) g = gpow₂ (int.of_nat n) g,	h_gpow : gpow₁ = gpow₂	⊢ {mul := mul₁, mul_assoc := m₁_mul_assoc, one := one₁, one_mul := one_mul₁, mul_one := mul_one₁, npow := npow₁, npow_zero' := npow_zero₁, npow_succ' := npow_succ₁, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₁, gpow := gpow₁, gpow_zero' := gpow_zero'₁, gpow_succ' := gpow_succ'₁, gpow_neg' := gpow_neg'₁} = {mul := mul₁, mul_assoc := m₂_mul_assoc, one := one₁, one_mul := one_mul₂, mul_one := mul_one₂, npow := npow₁, npow_zero' := npow_zero₂, npow_succ' := npow_succ₂, inv := inv₁, div := div₁, div_eq_mul_inv := div_eq_mul_inv₂, gpow := gpow₂, gpow_zero' := gpow_zero'₂, gpow_succ' := gpow_succ'₂, gpow_neg' := gpow_neg'₂}
M : Type u_1,	N : Type u_2,	_inst_1 : mul_zero_one_class M,	_inst_2 : mul_zero_one_class N,	f g : monoid_with_zero_hom M N,	h : ⇑f = ⇑g	⊢ f = g
M : Type u_1,	N : Type u_2,	_inst_1 : mul_zero_one_class M,	_inst_2 : mul_zero_one_class N,	f g : monoid_with_zero_hom M N,	h : ⇑f = ⇑g	⊢ f = g
M : Type u_1,	N : Type u_2,	_inst_1 : mul_zero_one_class M,	_inst_2 : mul_zero_one_class N,	f g : monoid_with_zero_hom M N,	h : ⇑f = ⇑g	⊢ f = g
M : Type u_1,	N : Type u_2,	_inst_1 : mul_zero_one_class M,	_inst_2 : mul_zero_one_class N,	g : monoid_with_zero_hom M N,	f_to_fun : M → N,	f_map_zero' : f_to_fun 0 = 0,	f_map_one' : f_to_fun 1 = 1,	f_map_mul' : ∀ (x y : M), f_to_fun (x * y) = f_to_fun x * f_to_fun y,	h : ⇑{to_fun := f_to_fun, map_zero' := f_map_zero', map_one' := f_map_one', map_mul' := f_map_mul'} = ⇑g	⊢ {to_fun := f_to_fun, map_zero' := f_map_zero', map_one' := f_map_one', map_mul' := f_map_mul'} = g
M : Type u_1,	N : Type u_2,	_inst_1 : mul_zero_one_class M,	_inst_2 : mul_zero_one_class N,	f_to_fun : M → N,	f_map_zero' : f_to_fun 0 = 0,	f_map_one' : f_to_fun 1 = 1,	f_map_mul' : ∀ (x y : M), f_to_fun (x * y) = f_to_fun x * f_to_fun y,	g_to_fun : M → N,	g_map_zero' : g_to_fun 0 = 0,	g_map_one' : g_to_fun 1 = 1,	g_map_mul' : ∀ (x y : M), g_to_fun (x * y) = g_to_fun x * g_to_fun y,	h : ⇑{to_fun := f_to_fun, map_zero' := f_map_zero', map_one' := f_map_one', map_mul' := f_map_mul'} = ⇑{to_fun := g_to_fun, map_zero' := g_map_zero', map_one' := g_map_one', map_mul' := g_map_mul'}	⊢ {to_fun := f_to_fun, map_zero' := f_map_zero', map_one' := f_map_one', map_mul' := f_map_mul'} = {to_fun := g_to_fun, map_zero' := g_map_zero', map_one' := g_map_one', map_mul' := g_map_mul'}
M : Type u_1,	N : Type u_2,	_inst_1 : mul_zero_one_class M,	_inst_2 : mul_zero_one_class N,	f_to_fun : M → N,	f_map_zero' : f_to_fun 0 = 0,	f_map_one' : f_to_fun 1 = 1,	f_map_mul' : ∀ (x y : M), f_to_fun (x * y) = f_to_fun x * f_to_fun y,	g_map_zero' : f_to_fun 0 = 0,	g_map_one' : f_to_fun 1 = 1,	g_map_mul' : ∀ (x y : M), f_to_fun (x * y) = f_to_fun x * f_to_fun y,	h : ⇑{to_fun := f_to_fun, map_zero' := f_map_zero', map_one' := f_map_one', map_mul' := f_map_mul'} = ⇑{to_fun := f_to_fun, map_zero' := g_map_zero', map_one' := g_map_one', map_mul' := g_map_mul'}	⊢ {to_fun := f_to_fun, map_zero' := f_map_zero', map_one' := f_map_one', map_mul' := f_map_mul'} = {to_fun := f_to_fun, map_zero' := g_map_zero', map_one' := g_map_one', map_mul' := g_map_mul'}
M : Type u_1,	N : Type u_2,	_inst_1 : mul_zero_one_class M,	_inst_2 : mul_zero_one_class N,	f g : monoid_with_zero_hom M N,	h : ⇑f = ⇑g	⊢ f = g
M : Type u_1,	N : Type u_2,	P : Type u_3,	_inst_1 : has_one M,	_inst_2 : has_one N,	_inst_3 : has_one P,	g : one_hom N P,	f₁ f₂ : one_hom M N,	hg : function.injective ⇑g,	h : g.comp f₁ = g.comp f₂,	x : M	⊢ ⇑g (⇑f₁ x) = ⇑g (⇑f₂ x)
M : Type u_1,	N : Type u_2,	P : Type u_3,	_inst_1 : has_one M,	_inst_2 : has_one N,	_inst_3 : has_one P,	f : one_hom N P,	x : M	⊢ ⇑(f.comp 1) x = ⇑1 x
M : Type u_1,	N : Type u_2,	P : Type u_3,	_inst_1 : has_one M,	_inst_2 : has_one N,	_inst_3 : has_one P,	f : one_hom N P	⊢ f.comp 1 = 1
M : Type u_1,	N : Type u_2,	P : Type u_3,	_inst_3 : mul_one_class M,	_inst_4 : mul_one_class N,	_inst_5 : mul_one_class P,	f : N →* P,	x : M	⊢ ⇑(f.comp 1) x = ⇑1 x
M : Type u_1,	N : Type u_2,	P : Type u_3,	_inst_3 : mul_one_class M,	_inst_4 : mul_one_class N,	_inst_5 : mul_one_class P,	f : N →* P	⊢ f.comp 1 = 1
I : Type u,	f : I → Type v,	_inst_1 : Π (i : I), comm_semigroup (f i)	⊢ comm_semigroup (Π (i : I), f i)
I : Type u,	f : I → Type v,	_inst_1 : Π (i : I), comm_semigroup (f i)	⊢ ∀ (a b c : Π (i : I), f i), a * b * c = a * (b * c)
I : Type u,	f : I → Type v,	_inst_1 : Π (i : I), comm_semigroup (f i)	⊢ ∀ (a b : Π (i : I), f i), a * b = b * a
I : Type u,	f : I → Type v,	_inst_1 : Π (i : I), comm_semigroup (f i)	⊢ comm_semigroup (Π (i : I), f i)
M : Type u_5,	N : Type u_6,	P : Type u_7,	_inst_1 : mul_one_class M,	_inst_2 : mul_one_class N,	_inst_3 : comm_monoid P,	f : M × N →* P,	x : M × N	⊢ ⇑((f.comp (monoid_hom.inl M N)).coprod (f.comp (monoid_hom.inr M N))) x = ⇑f x
α : Type u,	_inst_1 : mul_one_class α	⊢ mul_one_class (ulift α)
α : Type u,	_inst_1 : mul_one_class α	⊢ mul_one_class (ulift α)
α : Type u,	_inst_1 : mul_one_class α	⊢ ∀ (a : ulift α), 1 * a = a
α : Type u,	_inst_1 : mul_one_class α	⊢ ∀ (a : ulift α), a * 1 = a
α : Type u,	_inst_1 : monoid α,	a : α,	u : units α	⊢ a * (↑u⁻¹ * ↑u) = a
α : Type u,	_inst_1 : group α	⊢ ↑1⁻¹ = 1
M : Type u_5,	_inst_4 : monoid M,	A : Type u_6,	_inst_5 : add_monoid A,	_inst_6 : distrib_mul_action M A,	B : Type u_8,	_inst_9 : add_monoid B,	_inst_10 : distrib_mul_action M B	⊢ ∀ (m : M) (x : A), 0.to_fun (m • x) = m • 0.to_fun x
M : Type u,	_inst_1 : monoid M,	a b : M,	h : commute a b,	n : ℕ	⊢ (a * b) ^ 0 = a ^ 0 * b ^ 0
M : Type u,	_inst_1 : monoid M,	a b : M,	h : commute a b,	n n : ℕ,	ihn : (a * b) ^ n = a ^ n * b ^ n	⊢ (a * b) ^ n.succ = a ^ n.succ * b ^ n.succ
G : Type w,	_inst_1 : group G,	a : G,	n : ℤ	⊢ a ^ bit1 n = a ^ n * a ^ n * a
R : Type u₁,	_inst_1 : ring R,	n r : R	⊢ r * (n + n) = (1 + 1) • (r * n)
R : Type u₁,	_inst_1 : ring R,	n r : R	⊢ r * bit0 n = 2 • (r * n)
R : Type u₁,	_inst_1 : ordered_semiring R,	x : R,	pow_le_one : ∀ (n : ℕ), 0 ≤ x → x ≤ 1 → x ^ n ≤ 1,	h0 : 0 ≤ x,	h1 : x ≤ 1	⊢ x ^ 0 ≤ 1
R : Type u₁,	_inst_1 : ordered_semiring R,	x : R,	pow_le_one : ∀ (n : ℕ), 0 ≤ x → x ≤ 1 → x ^ n ≤ 1,	n : ℕ,	h0 : 0 ≤ x,	h1 : x ≤ 1	⊢ x ^ (n + 1) ≤ 1
R : Type u₁,	_inst_1 : ordered_semiring R,	x : R,	pow_le_one : ∀ (n : ℕ), 0 ≤ x → x ≤ 1 → x ^ n ≤ 1,	n : ℕ,	h0 : 0 ≤ x,	h1 : x ≤ 1	⊢ x * x ^ n ≤ 1
R : Type u₁,	_inst_3 : ring R,	a : R,	m : ℤ	⊢ commute (↑m * 1) a
R : Type u₁,	_inst_3 : ring R,	a : R,	m : ℤ	⊢ commute ↑m a
R : Type u_4,	_inst_1 : linear_ordered_ring R,	x y : R,	h : x ^ 2 < y ^ 2,	hy : 0 ≤ y	⊢ abs x < y
R : Type u_4,	_inst_1 : linear_ordered_ring R,	x y : R,	h : x ^ 2 < y ^ 2,	hy : 0 ≤ y	⊢ abs x < abs y
G₀ : Type u_2,	_inst_1 : group_with_zero G₀,	a b : G₀,	h : b = 0 → a = 0,	hb : b = 0	⊢ a / b * b = a
G₀ : Type u_2,	_inst_1 : group_with_zero G₀,	a b : G₀	⊢ a⁻¹ / b = (b * a)⁻¹
G₀ : Type u_2,	_inst_1 : comm_group_with_zero G₀,	a b c : G₀	⊢ a * b / c = a / c * b
G₀ : Type u_2,	_inst_1 : comm_group_with_zero G₀,	a b c : G₀	⊢ a * (b / c) = b * (a / c)
G₀ : Type u_1,	_inst_1 : group_with_zero G₀,	a : G₀,	fpow_mul : ∀ (m n : ℤ), a ^ (m * n) = (a ^ m) ^ n,	m n : ℕ	⊢ a ^ (↑m * ↑n) = (a ^ ↑m) ^ ↑n
G₀ : Type u_1,	_inst_1 : group_with_zero G₀,	a : G₀,	fpow_mul : ∀ (m n : ℤ), a ^ (m * n) = (a ^ m) ^ n,	m n : ℕ	⊢ a ^ (↑m * ↑n) = a ^ ↑(m * n)
G₀ : Type u_1,	_inst_1 : group_with_zero G₀,	a : G₀,	fpow_mul : ∀ (m n : ℤ), a ^ (m * n) = (a ^ m) ^ n,	m n : ℕ	⊢ a ^ (↑m * -[1+ n]) = (a ^ ↑m) ^ -[1+ n]
G₀ : Type u_1,	_inst_1 : group_with_zero G₀,	a : G₀,	fpow_mul : ∀ (m n : ℤ), a ^ (m * n) = (a ^ m) ^ n,	m n : ℕ	⊢ a ^ (↑m * ↑(n.succ)) = a ^ ↑(m * n.succ)
G₀ : Type u_1,	_inst_1 : group_with_zero G₀,	a : G₀,	fpow_mul : ∀ (m n : ℤ), a ^ (m * n) = (a ^ m) ^ n,	m n : ℕ	⊢ a ^ (-[1+ m] * ↑n) = (a ^ -[1+ m]) ^ ↑n
G₀ : Type u_1,	_inst_1 : group_with_zero G₀,	a : G₀,	fpow_mul : ∀ (m n : ℤ), a ^ (m * n) = (a ^ m) ^ n,	m n : ℕ	⊢ a ^ (↑(m.succ) * ↑n) = a ^ ↑(m.succ * n)
G₀ : Type u_1,	_inst_1 : group_with_zero G₀,	a : G₀,	fpow_mul : ∀ (m n : ℤ), a ^ (m * n) = (a ^ m) ^ n,	m n : ℕ	⊢ a ^ (-[1+ m] * -[1+ n]) = (a ^ -[1+ m]) ^ -[1+ n]
G₀ : Type u_1,	_inst_1 : group_with_zero G₀,	a : G₀,	fpow_mul : ∀ (m n : ℤ), a ^ (m * n) = (a ^ m) ^ n,	m n : ℕ	⊢ a ^ (↑(m.succ) * ↑(n.succ)) = a ^ ↑(m.succ * n.succ)
G₀ : Type u_1,	_inst_1 : group_with_zero G₀,	x : G₀	⊢ x ^ -1 = x⁻¹
G₀ : Type u_1,	_inst_1 : group_with_zero G₀,	x : G₀	⊢ (x ^ 1)⁻¹ = (x ^ ↑1)⁻¹
ι : Type u_1,	V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.preadditive V,	c : complex_shape ι,	_inst_3 : category_theory.limits.has_zero_object V,	W : Type u_2,	_inst_4 : category_theory.category W,	_inst_5 : category_theory.preadditive W,	_inst_6 : category_theory.limits.has_zero_object W,	F : V ⥤ W,	_inst_7 : F.additive,	i j : ι,	h : i ≠ j,	X : V	⊢ ((homological_complex.single_map_homological_complex F c j).inv.app X).f i = 0
ι : Type u_1,	V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.preadditive V,	c : complex_shape ι,	i : ι,	_inst_3 : category_theory.limits.has_zero_object V,	_inst_4 : category_theory.limits.has_images V,	_inst_5 : category_theory.limits.has_image_maps V,	_inst_6 : category_theory.limits.has_equalizers V,	_inst_7 : category_theory.limits.has_cokernels V,	C D : homological_complex V c	⊢ (homology_functor V c i).map 0 = 0
ι : Type u_1,	V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.preadditive V,	c : complex_shape ι,	i : ι,	_inst_3 : category_theory.limits.has_zero_object V,	_inst_4 : category_theory.limits.has_images V,	_inst_5 : category_theory.limits.has_image_maps V,	_inst_6 : category_theory.limits.has_equalizers V,	_inst_7 : category_theory.limits.has_cokernels V,	C D : homological_complex V c	⊢ homology.map _ _ (homological_complex.hom.sq_to 0 i) (homological_complex.hom.sq_from 0 i) _ = 0
ι : Type u_1,	V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.preadditive V,	c : complex_shape ι,	i : ι,	_inst_3 : category_theory.limits.has_zero_object V,	_inst_4 : category_theory.limits.has_images V,	_inst_5 : category_theory.limits.has_image_maps V,	_inst_6 : category_theory.limits.has_equalizers V,	_inst_7 : category_theory.limits.has_cokernels V,	C D : homological_complex V c	⊢ homology.π (C.d_to i) (C.d_from i) _ ≫ homology.map _ _ (homological_complex.hom.sq_to 0 i) (homological_complex.hom.sq_from 0 i) _ = homology.π (C.d_to i) (C.d_from i) _ ≫ 0
ι : Type u_1,	V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.preadditive V,	c : complex_shape ι,	i : ι,	_inst_3 : category_theory.limits.has_zero_object V,	_inst_4 : category_theory.limits.has_images V,	_inst_5 : category_theory.limits.has_image_maps V,	_inst_6 : category_theory.limits.has_equalizers V,	_inst_7 : category_theory.limits.has_cokernels V,	C D : homological_complex V c	⊢ category_theory.limits.kernel_subobject_map (homological_complex.hom.sq_from 0 i) ≫ homology.π (D.d_to i) (D.d_from i) _ = 0
ι : Type u_1,	V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.preadditive V,	c : complex_shape ι,	i : ι,	_inst_3 : category_theory.limits.has_zero_object V,	_inst_4 : category_theory.limits.has_images V,	_inst_5 : category_theory.limits.has_image_maps V,	_inst_6 : category_theory.limits.has_equalizers V,	_inst_7 : category_theory.limits.has_cokernels V,	C D : homological_complex V c	⊢ category_theory.limits.kernel_subobject_map (homological_complex.hom.sq_from 0 i) = 0
ι : Type u_1,	V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.preadditive V,	c : complex_shape ι,	i : ι,	_inst_3 : category_theory.limits.has_zero_object V,	_inst_4 : category_theory.limits.has_images V,	_inst_5 : category_theory.limits.has_image_maps V,	_inst_6 : category_theory.limits.has_equalizers V,	_inst_7 : category_theory.limits.has_cokernels V,	C D : homological_complex V c	⊢ category_theory.limits.kernel_subobject_map (homological_complex.hom.sq_from 0 i) ≫ (category_theory.limits.kernel_subobject (D.d_from i)).arrow = 0 ≫ (category_theory.limits.kernel_subobject (D.d_from i)).arrow
ι : Type u_1,	V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.preadditive V,	c : complex_shape ι,	i : ι,	_inst_3 : category_theory.limits.has_zero_object V,	_inst_4 : category_theory.limits.has_images V,	_inst_5 : category_theory.limits.has_image_maps V,	_inst_6 : category_theory.limits.has_equalizers V,	_inst_7 : category_theory.limits.has_cokernels V,	C D : homological_complex V c,	f g : C ⟶ D	⊢ (homology_functor V c i).map (f + g) = (homology_functor V c i).map f + (homology_functor V c i).map g
ι : Type u_1,	V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.preadditive V,	c : complex_shape ι,	i : ι,	_inst_3 : category_theory.limits.has_zero_object V,	_inst_4 : category_theory.limits.has_images V,	_inst_5 : category_theory.limits.has_image_maps V,	_inst_6 : category_theory.limits.has_equalizers V,	_inst_7 : category_theory.limits.has_cokernels V,	C D : homological_complex V c,	f g : C ⟶ D	⊢ homology.map _ _ (homological_complex.hom.sq_to (f + g) i) (homological_complex.hom.sq_from (f + g) i) _ = homology.map _ _ (homological_complex.hom.sq_to f i) (homological_complex.hom.sq_from f i) _ + homology.map _ _ (homological_complex.hom.sq_to g i) (homological_complex.hom.sq_from g i) _
ι : Type u_1,	V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.preadditive V,	c : complex_shape ι,	i : ι,	_inst_3 : category_theory.limits.has_zero_object V,	_inst_4 : category_theory.limits.has_images V,	_inst_5 : category_theory.limits.has_image_maps V,	_inst_6 : category_theory.limits.has_equalizers V,	_inst_7 : category_theory.limits.has_cokernels V,	C D : homological_complex V c,	f g : C ⟶ D	⊢ homology.π (C.d_to i) (C.d_from i) _ ≫ homology.map _ _ (homological_complex.hom.sq_to (f + g) i) (homological_complex.hom.sq_from (f + g) i) _ = homology.π (C.d_to i) (C.d_from i) _ ≫ (homology.map _ _ (homological_complex.hom.sq_to f i) (homological_complex.hom.sq_from f i) _ + homology.map _ _ (homological_complex.hom.sq_to g i) (homological_complex.hom.sq_from g i) _)
ι : Type u_1,	V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.preadditive V,	c : complex_shape ι,	i : ι,	_inst_3 : category_theory.limits.has_zero_object V,	_inst_4 : category_theory.limits.has_images V,	_inst_5 : category_theory.limits.has_image_maps V,	_inst_6 : category_theory.limits.has_equalizers V,	_inst_7 : category_theory.limits.has_cokernels V,	C D : homological_complex V c,	f g : C ⟶ D	⊢ category_theory.limits.kernel_subobject_map (homological_complex.hom.sq_from (f + g) i) ≫ homology.π (D.d_to i) (D.d_from i) _ = (category_theory.limits.kernel_subobject_map (homological_complex.hom.sq_from f i) + category_theory.limits.kernel_subobject_map (homological_complex.hom.sq_from g i)) ≫ homology.π (D.d_to i) (D.d_from i) _
ι : Type u_1,	V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.preadditive V,	c : complex_shape ι,	i : ι,	_inst_3 : category_theory.limits.has_zero_object V,	_inst_4 : category_theory.limits.has_images V,	_inst_5 : category_theory.limits.has_image_maps V,	_inst_6 : category_theory.limits.has_equalizers V,	_inst_7 : category_theory.limits.has_cokernels V,	C D : homological_complex V c,	f g : C ⟶ D	⊢ category_theory.limits.kernel_subobject_map (homological_complex.hom.sq_from (f + g) i) ≫ (category_theory.limits.kernel_subobject (D.d_from i)).arrow = (category_theory.limits.kernel_subobject_map (homological_complex.hom.sq_from f i) + category_theory.limits.kernel_subobject_map (homological_complex.hom.sq_from g i)) ≫ (category_theory.limits.kernel_subobject (D.d_from i)).arrow
ι : Type u_1,	V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.preadditive V,	c : complex_shape ι,	i : ι,	_inst_3 : category_theory.limits.has_zero_object V,	_inst_4 : category_theory.limits.has_images V,	_inst_5 : category_theory.limits.has_image_maps V,	_inst_6 : category_theory.limits.has_equalizers V,	_inst_7 : category_theory.limits.has_cokernels V,	C D : homological_complex V c,	f g : C ⟶ D	⊢ category_theory.limits.kernel_subobject_map (homological_complex.hom.sq_from (f + g) i) = category_theory.limits.kernel_subobject_map (homological_complex.hom.sq_from f i) + category_theory.limits.kernel_subobject_map (homological_complex.hom.sq_from g i)
ι : Type u_1,	c₁ c₂ : complex_shape ι,	i j j' : ι,	w : relation.comp c₁.rel c₂.rel i j,	w' : relation.comp c₁.rel c₂.rel i j'	⊢ j = j'
ι : Type u_1,	c₁ c₂ : complex_shape ι,	i j j' : ι,	w' : relation.comp c₁.rel c₂.rel i j',	k : ι,	w₁ : c₁.rel i k,	w₂ : c₂.rel k j	⊢ j = j'
ι : Type u_1,	c₁ c₂ : complex_shape ι,	i j j' k : ι,	w₁ : c₁.rel i k,	w₂ : c₂.rel k j,	k' : ι,	w₁' : c₁.rel i k',	w₂' : c₂.rel k' j'	⊢ j = j'
ι : Type u_1,	c₁ c₂ : complex_shape ι,	i j j' k : ι,	w₁ : c₁.rel i k,	k' : ι,	w₁' : c₁.rel i k',	w₂' : c₂.rel k' j',	w₂ : c₂.rel k' j	⊢ j = j'
ι : Type u_1,	c₁ c₂ : complex_shape ι,	i i' j : ι,	w : relation.comp c₁.rel c₂.rel i j,	w' : relation.comp c₁.rel c₂.rel i' j	⊢ i = i'
ι : Type u_1,	c₁ c₂ : complex_shape ι,	i i' j : ι,	w' : relation.comp c₁.rel c₂.rel i' j,	k : ι,	w₁ : c₁.rel i k,	w₂ : c₂.rel k j	⊢ i = i'
ι : Type u_1,	c₁ c₂ : complex_shape ι,	i i' j k : ι,	w₁ : c₁.rel i k,	w₂ : c₂.rel k j,	k' : ι,	w₁' : c₁.rel i' k',	w₂' : c₂.rel k' j	⊢ i = i'
ι : Type u_1,	c₁ c₂ : complex_shape ι,	i i' j k : ι,	w₂ : c₂.rel k j,	k' : ι,	w₁' : c₁.rel i' k',	w₂' : c₂.rel k' j,	w₁ : c₁.rel i k'	⊢ i = i'
ι : Type u_1,	V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.limits.has_zero_morphisms V,	c : complex_shape ι,	C₁ C₂ C₃ : homological_complex V c,	_inst_3 : category_theory.limits.has_zero_object V,	f : C₁ ⟶ C₂,	g : C₂ ⟶ C₃,	i : ι	⊢ homological_complex.hom.sq_from (f ≫ g) i = homological_complex.hom.sq_from f i ≫ homological_complex.hom.sq_from g i
ι : Type u_1,	V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.limits.has_zero_morphisms V,	c : complex_shape ι,	C₁ C₂ C₃ : homological_complex V c,	_inst_3 : category_theory.limits.has_zero_object V,	f : C₁ ⟶ C₂,	g : C₂ ⟶ C₃,	i : ι,	h : c.next i = option.none	⊢ homological_complex.hom.sq_from (f ≫ g) i = homological_complex.hom.sq_from f i ≫ homological_complex.hom.sq_from g i
ι : Type u_1,	V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.limits.has_zero_morphisms V,	c : complex_shape ι,	C₁ C₂ C₃ : homological_complex V c,	_inst_3 : category_theory.limits.has_zero_object V,	f : C₁ ⟶ C₂,	g : C₂ ⟶ C₃,	i : ι,	h : c.next i = option.none	⊢ (homological_complex.hom.sq_from (f ≫ g) i).left = (homological_complex.hom.sq_from f i ≫ homological_complex.hom.sq_from g i).left		ι : Type u_1,	V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.limits.has_zero_morphisms V,	c : complex_shape ι,	C₁ C₂ C₃ : homological_complex V c,	_inst_3 : category_theory.limits.has_zero_object V,	f : C₁ ⟶ C₂,	g : C₂ ⟶ C₃,	i : ι,	h : c.next i = option.none	⊢ (homological_complex.hom.sq_from (f ≫ g) i).right = (homological_complex.hom.sq_from f i ≫ homological_complex.hom.sq_from g i).right
ι : Type u_1,	V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.limits.has_zero_morphisms V,	c : complex_shape ι,	C₁ C₂ C₃ : homological_complex V c,	_inst_3 : category_theory.limits.has_zero_object V,	f : C₁ ⟶ C₂,	g : C₂ ⟶ C₃,	i : ι,	h : c.next i = option.none	⊢ (homological_complex.hom.sq_from (f ≫ g) i).left = (homological_complex.hom.sq_from f i ≫ homological_complex.hom.sq_from g i).left
ι : Type u_1,	V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.limits.has_zero_morphisms V,	c : complex_shape ι,	C₁ C₂ C₃ : homological_complex V c,	_inst_3 : category_theory.limits.has_zero_object V,	f : C₁ ⟶ C₂,	g : C₂ ⟶ C₃,	i : ι,	h : c.next i = option.none	⊢ homological_complex.hom.next (f ≫ g) i = homological_complex.hom.next f i ≫ homological_complex.hom.next g i
ι : Type u_1,	V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.limits.has_zero_morphisms V,	c : complex_shape ι,	C₁ C₂ C₃ : homological_complex V c,	_inst_3 : category_theory.limits.has_zero_object V,	f : C₁ ⟶ C₂,	g : C₂ ⟶ C₃,	i : ι,	h : c.next i = option.none	⊢ (homological_complex.hom.sq_from (f ≫ g) i).right = (homological_complex.hom.sq_from f i ≫ homological_complex.hom.sq_from g i).right
ι : Type u_1,	V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.limits.has_zero_morphisms V,	c : complex_shape ι,	C₁ C₂ C₃ : homological_complex V c,	_inst_3 : category_theory.limits.has_zero_object V,	f : C₁ ⟶ C₂,	g : C₂ ⟶ C₃,	i : ι,	h : c.next i = option.none	⊢ 0 = 0 ≫ 0
ι : Type u_1,	V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.limits.has_zero_morphisms V,	c : complex_shape ι,	C₁ C₂ C₃ : homological_complex V c,	_inst_3 : category_theory.limits.has_zero_object V,	f : C₁ ⟶ C₂,	g : C₂ ⟶ C₃,	i : ι,	h : c.next i = option.none	⊢ 0 ≫ 0 = 0
ι : Type u_1,	V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.limits.has_zero_morphisms V,	c : complex_shape ι,	C₁ C₂ C₃ : homological_complex V c,	_inst_3 : category_theory.limits.has_zero_object V,	f : C₁ ⟶ C₂,	g : C₂ ⟶ C₃,	i : ι,	h : c.next i = option.none	⊢ homological_complex.hom.sq_from (f ≫ g) i = homological_complex.hom.sq_from f i ≫ homological_complex.hom.sq_from g i		ι : Type u_1,	V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.limits.has_zero_morphisms V,	c : complex_shape ι,	C₁ C₂ C₃ : homological_complex V c,	_inst_3 : category_theory.limits.has_zero_object V,	f : C₁ ⟶ C₂,	g : C₂ ⟶ C₃,	i j : ι,	w : c.rel i j,	h : c.next i = option.some ⟨j, w⟩	⊢ homological_complex.hom.sq_from (f ≫ g) i = homological_complex.hom.sq_from f i ≫ homological_complex.hom.sq_from g i
ι : Type u_1,	V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.limits.has_zero_morphisms V,	c : complex_shape ι,	C₁ C₂ C₃ : homological_complex V c,	_inst_3 : category_theory.limits.has_zero_object V,	f : C₁ ⟶ C₂,	g : C₂ ⟶ C₃,	i : ι,	h : c.next i = option.none	⊢ C₃.X_next i ≅ 0
ι : Type u_1,	V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.limits.has_zero_morphisms V,	c : complex_shape ι,	C₁ C₂ C₃ : homological_complex V c,	_inst_3 : category_theory.limits.has_zero_object V,	f : C₁ ⟶ C₂,	g : C₂ ⟶ C₃,	i j : ι,	w : c.rel i j,	h : c.next i = option.some ⟨j, w⟩	⊢ (homological_complex.hom.sq_from (f ≫ g) i).left = (homological_complex.hom.sq_from f i ≫ homological_complex.hom.sq_from g i).left		ι : Type u_1,	V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.limits.has_zero_morphisms V,	c : complex_shape ι,	C₁ C₂ C₃ : homological_complex V c,	_inst_3 : category_theory.limits.has_zero_object V,	f : C₁ ⟶ C₂,	g : C₂ ⟶ C₃,	i j : ι,	w : c.rel i j,	h : c.next i = option.some ⟨j, w⟩	⊢ (homological_complex.hom.sq_from (f ≫ g) i).right = (homological_complex.hom.sq_from f i ≫ homological_complex.hom.sq_from g i).right
ι : Type u_1,	V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.limits.has_zero_morphisms V,	c : complex_shape ι,	C₁ C₂ C₃ : homological_complex V c,	_inst_3 : category_theory.limits.has_zero_object V,	f : C₁ ⟶ C₂,	g : C₂ ⟶ C₃,	i j : ι,	w : c.rel i j,	h : c.next i = option.some ⟨j, w⟩	⊢ (homological_complex.hom.sq_from (f ≫ g) i).right = (homological_complex.hom.sq_from f i ≫ homological_complex.hom.sq_from g i).right
ι : Type u_1,	V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.limits.has_zero_morphisms V,	c : complex_shape ι,	C₁ C₂ C₃ : homological_complex V c,	_inst_3 : category_theory.limits.has_zero_object V,	f : C₁ ⟶ C₂,	g : C₂ ⟶ C₃,	i j : ι,	w : c.rel i j,	h : c.next i = option.some ⟨j, w⟩	⊢ homological_complex.hom.next (f ≫ g) i = homological_complex.hom.next f i ≫ homological_complex.hom.next g i
ι : Type u_1,	V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.limits.has_zero_morphisms V,	c : complex_shape ι,	C₁ C₂ C₃ : homological_complex V c,	_inst_3 : category_theory.limits.has_zero_object V,	f : C₁ ⟶ C₂,	g : C₂ ⟶ C₃,	i j : ι,	w : c.rel i j,	h : c.next i = option.some ⟨j, w⟩	⊢ homological_complex.hom.sq_from (f ≫ g) i = homological_complex.hom.sq_from f i ≫ homological_complex.hom.sq_from g i
V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.limits.has_zero_morphisms V,	X₀ X₁ X₂ : V,	d₀ : X₁ ⟶ X₀,	d₁ : X₂ ⟶ X₁,	s : d₁ ≫ d₀ = 0,	succ : Π (t : Σ' (X₀ X₁ X₂ : V) (d₀ : X₁ ⟶ X₀) (d₁ : X₂ ⟶ X₁), d₁ ≫ d₀ = 0), Σ' (X₃ : V) (d₂ : X₃ ⟶ t.snd.snd.fst), d₂ ≫ t.snd.snd.snd.snd.fst = 0	⊢ ite (1 = 0 + 1) (𝟙 X₁ ≫ d₀) 0 = d₀
V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.limits.has_zero_morphisms V,	X₀ X₁ X₂ : V,	d₀ : X₁ ⟶ X₀,	d₁ : X₂ ⟶ X₁,	s : d₁ ≫ d₀ = 0,	succ : Π (t : Σ' (X₀ X₁ X₂ : V) (d₀ : X₁ ⟶ X₀) (d₁ : X₂ ⟶ X₁), d₁ ≫ d₀ = 0), Σ' (X₃ : V) (d₂ : X₃ ⟶ t.snd.snd.fst), d₂ ≫ t.snd.snd.snd.snd.fst = 0	⊢ (chain_complex.mk X₀ X₁ X₂ d₀ d₁ s succ).d 1 0 = d₀
ι : Type u_1,	V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.preadditive V,	c : complex_shape ι,	C D E : homological_complex V c,	f : Π (i j : ι), C.X i ⟶ D.X j,	g : D ⟶ E,	j : ι	⊢ ⇑(prev_d j) (λ (i j : ι), f i j ≫ g.f j) = ⇑(prev_d j) f ≫ g.f j
ι : Type u_1,	V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.preadditive V,	c : complex_shape ι,	C D E : homological_complex V c,	f : Π (i j : ι), C.X i ⟶ D.X j,	g : D ⟶ E,	j : ι	⊢ prev_d._match_1 j (λ (i j : ι), f i j ≫ g.f j) (c.prev j) = prev_d._match_1 j f (c.prev j) ≫ g.f j
ι : Type u_1,	V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.preadditive V,	c : complex_shape ι,	C D E : homological_complex V c,	f : Π (i j : ι), C.X i ⟶ D.X j,	g : D ⟶ E,	j : ι	⊢ prev_d._match_1 j (λ (i j : ι), f i j ≫ g.f j) option.none = prev_d._match_1 j f option.none ≫ g.f j		ι : Type u_1,	V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.preadditive V,	c : complex_shape ι,	C D E : homological_complex V c,	f : Π (i j : ι), C.X i ⟶ D.X j,	g : D ⟶ E,	j j' : ι,	w : c.rel j' j	⊢ prev_d._match_1 j (λ (i j : ι), f i j ≫ g.f j) (option.some ⟨j', w⟩) = prev_d._match_1 j f (option.some ⟨j', w⟩) ≫ g.f j
ι : Type u_1,	V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.preadditive V,	c : complex_shape ι,	C D E : homological_complex V c,	f : Π (i j : ι), C.X i ⟶ D.X j,	g : D ⟶ E,	j : ι	⊢ prev_d._match_1 j (λ (i j : ι), f i j ≫ g.f j) option.none = prev_d._match_1 j f option.none ≫ g.f j
ι : Type u_1,	V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.preadditive V,	c : complex_shape ι,	C D E : homological_complex V c,	f : Π (i j : ι), C.X i ⟶ D.X j,	g : D ⟶ E,	j j' : ι,	w : c.rel j' j	⊢ prev_d._match_1 j (λ (i j : ι), f i j ≫ g.f j) (option.some ⟨j', w⟩) = prev_d._match_1 j f (option.some ⟨j', w⟩) ≫ g.f j
ι : Type u_1,	V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.preadditive V,	c : complex_shape ι,	C D E : homological_complex V c,	f : Π (i j : ι), C.X i ⟶ D.X j,	g : D ⟶ E,	j j' : ι,	w : c.rel j' j	⊢ (f j j' ≫ g.f j') ≫ E.d j' j = (f j j' ≫ D.d j' j) ≫ g.f j
ι : Type u_1,	V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.preadditive V,	c : complex_shape ι,	C D : homological_complex V c,	i : (homotopy_category.quotient V c).obj C ≅ (homotopy_category.quotient V c).obj D	⊢ (homotopy_category.quotient V c).map (quot.out i.hom ≫ quot.out i.inv) = (homotopy_category.quotient V c).map (𝟙 C)
ι : Type u_1,	V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.preadditive V,	c : complex_shape ι,	C D : homological_complex V c,	i : (homotopy_category.quotient V c).obj C ≅ (homotopy_category.quotient V c).obj D	⊢ 𝟙 ((homotopy_category.quotient V c).obj ((homotopy_category.quotient V c).obj C).as) = 𝟙 ((homotopy_category.quotient V c).obj C)
ι : Type u_1,	V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.preadditive V,	c : complex_shape ι,	C D : homological_complex V c,	i : (homotopy_category.quotient V c).obj C ≅ (homotopy_category.quotient V c).obj D	⊢ (homotopy_category.quotient V c).map (quot.out i.inv ≫ quot.out i.hom) = (homotopy_category.quotient V c).map (𝟙 D)
ι : Type u_1,	V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.preadditive V,	c : complex_shape ι,	C D : homological_complex V c,	i : (homotopy_category.quotient V c).obj C ≅ (homotopy_category.quotient V c).obj D	⊢ 𝟙 ((homotopy_category.quotient V c).obj ((homotopy_category.quotient V c).obj D).as) = 𝟙 ((homotopy_category.quotient V c).obj D)
V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.limits.has_zero_morphisms V,	A B C : V,	f : A ⟶ B,	g : B ⟶ C,	_inst_3 : category_theory.limits.has_kernels V,	_inst_4 : category_theory.limits.has_images V,	Z : V,	h : Z ⟶ A,	_inst_5 : category_theory.epi h,	w : (h ≫ f) ≫ g = 0	⊢ h ≫ f ≫ g = h ≫ 0
V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.limits.has_zero_morphisms V,	A B C : V,	f : A ⟶ B,	g : B ⟶ C,	_inst_3 : category_theory.limits.has_kernels V,	_inst_4 : category_theory.limits.has_images V,	Z : V,	h : Z ⟶ A,	_inst_5 : category_theory.epi h,	w : (h ≫ f) ≫ g = 0	⊢ image_to_kernel (h ≫ f) g w ≫ (category_theory.limits.kernel_subobject g).arrow = ((category_theory.limits.image_subobject (h ≫ f)).of_le (category_theory.limits.image_subobject f) _ ≫ image_to_kernel f g _) ≫ (category_theory.limits.kernel_subobject g).arrow
V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.limits.has_zero_morphisms V,	A B C : V,	f : A ⟶ B,	g : B ⟶ C,	_inst_3 : category_theory.limits.has_kernels V,	_inst_4 : category_theory.limits.has_images V,	Z : V,	h : Z ⟶ A,	_inst_5 : category_theory.epi h,	w : (h ≫ f) ≫ g = 0	⊢ image_to_kernel (h ≫ f) g w = (category_theory.limits.image_subobject (h ≫ f)).of_le (category_theory.limits.image_subobject f) _ ≫ image_to_kernel f g _
V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.limits.has_zero_morphisms V,	A B C : V,	_inst_6 : category_theory.limits.has_zero_object V,	_inst_7 : category_theory.limits.has_image 0	⊢ 0 ≫ 0 = 0
V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.limits.has_zero_morphisms V,	A B C : V,	_inst_6 : category_theory.limits.has_zero_object V,	_inst_7 : category_theory.limits.has_image 0,	_inst_8 : category_theory.limits.has_cokernel (image_to_kernel 0 0 _)	⊢ 0 ≫ 0 = 0
V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.limits.has_zero_morphisms V,	A B C : V,	_inst_6 : category_theory.limits.has_zero_object V,	_inst_7 : category_theory.limits.has_image 0,	_inst_8 : category_theory.limits.has_cokernel (image_to_kernel 0 0 _)	⊢ image_to_kernel 0 0 _ ≫ (category_theory.limits.kernel_subobject 0).arrow = 0
V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.limits.has_zero_morphisms V,	A B C : V,	f : A ⟶ B,	_inst_3 : category_theory.limits.has_image f,	g : B ⟶ C,	_inst_4 : category_theory.limits.has_kernel g,	w : f ≫ g = 0	⊢ (category_theory.limits.factor_thru_image_subobject f ≫ image_to_kernel f g w) ≫ (category_theory.limits.kernel_subobject g).arrow = category_theory.limits.factor_thru_kernel_subobject g f w ≫ (category_theory.limits.kernel_subobject g).arrow
V : Type u,	_inst_1 : category_theory.category V,	_inst_2 : category_theory.limits.has_zero_morphisms V,	A B C : V,	f : A ⟶ B,	_inst_3 : category_theory.limits.has_image f,	g : B ⟶ C,	_inst_4 : category_theory.limits.has_kernel g,	w : f ≫ g = 0	⊢ category_theory.limits.factor_thru_image_subobject f ≫ image_to_kernel f g w = category_theory.limits.factor_thru_kernel_subobject g f w
α : Type u_1,	M : Type u_4,	_inst_1 : mul_zero_class M,	s : set α,	f g : α → M,	x : α	⊢ s.indicator (λ (a : α), f a * g a) x = s.indicator f x * s.indicator g x
α : Type u_1,	M : Type u_4,	_inst_1 : mul_zero_class M,	s : set α,	f g : α → M,	x : α	⊢ ite (x ∈ s) (f x * g x) 0 = ite (x ∈ s) (f x) 0 * ite (x ∈ s) (g x) 0
α : Type u_1,	M : Type u_4,	_inst_1 : mul_zero_class M,	s : set α,	f g : α → M,	x : α,	h : x ∈ s	⊢ f x * g x = f x * g x
α : Type u_1,	M : Type u_4,	_inst_1 : mul_zero_class M,	s : set α,	f g : α → M,	x : α,	h : x ∈ s	⊢ f x * g x = f x * g x		α : Type u_1,	M : Type u_4,	_inst_1 : mul_zero_class M,	s : set α,	f g : α → M,	x : α,	h : x ∉ s	⊢ 0 = 0 * 0
α : Type u_1,	M : Type u_4,	_inst_1 : mul_zero_class M,	s : set α,	f g : α → M,	x : α,	h : x ∉ s	⊢ 0 = 0 * 0
α : Type u_1,	M : Type u_4,	_inst_1 : mul_zero_class M,	s : set α,	f g : α → M	⊢ s.indicator (λ (a : α), f a * g a) = λ (a : α), s.indicator f a * s.indicator g a
α : Type u_1,	M : Type u_4,	_inst_1 : has_one M,	_inst_2 : preorder M,	s : set α,	f : α → M,	a : α,	y : M,	hfg : a ∈ s → f a ≤ y,	hg : a ∉ s → 1 ≤ y,	ha : a ∈ s	⊢ s.mul_indicator f a ≤ y
α : Type u_1,	M : Type u_4,	_inst_1 : has_one M,	_inst_2 : preorder M,	s : set α,	f : α → M,	a : α,	y : M,	hfg : a ∈ s → f a ≤ y,	hg : a ∉ s → 1 ≤ y,	ha : a ∉ s	⊢ s.mul_indicator f a ≤ y
α : Type u_1,	M : Type u_4,	_inst_1 : has_one M,	s t : set α,	f : α → M,	h2 : s ⊆ t,	h1 : function.mul_support f ⊆ s	⊢ function.mul_support f ⊆ t
α : Type u_1,	M : Type u_4,	_inst_1 : has_one M,	s t : set α,	f : α → M,	h1 : s.mul_indicator f = f,	h2 : s ⊆ t	⊢ t.mul_indicator f = f
α : Type u,	_inst_1 : monoid α,	a b : α,	_inst_2 : invertible a,	_inst_3 : invertible b,	_inst_4 : invertible (a * b)	⊢ a * b * (⅟ b * ⅟ a) = 1
R : Type ?,	S : Type ?,	_inst_1 : monoid R,	_inst_2 : monoid S,	f : R →* S,	r : R,	_inst_3 : invertible r	⊢ ⇑f (⅟ r) * ⇑f r = 1
R : Type ?,	S : Type ?,	_inst_1 : monoid R,	_inst_2 : monoid S,	f : R →* S,	r : R,	_inst_3 : invertible r	⊢ ⇑f r * ⇑f (⅟ r) = 1
α : Type u,	_inst_1 : lattice α,	_inst_2 : comm_group α,	_inst_3 : covariant_class α α has_mul.mul has_le.le,	a b : α	⊢ a ⊓ b = a * 1 ⊓ (a * (b / a))
α : Type u,	_inst_1 : lattice α,	_inst_2 : comm_group α,	_inst_3 : covariant_class α α has_mul.mul has_le.le,	a b : α	⊢ a * 1 ⊓ (a * (b / a)) = a * (1 ⊓ (b / a))
α : Type u,	_inst_1 : lattice α,	_inst_2 : comm_group α,	_inst_3 : covariant_class α α has_mul.mul has_le.le,	a b : α	⊢ a * (1 ⊓ (b / a)) = a * (b / a ⊓ 1)
α : Type u,	_inst_1 : lattice α,	_inst_2 : comm_group α,	_inst_3 : covariant_class α α has_mul.mul has_le.le,	a b : α	⊢ a * (b / a ⊓ 1) = a * ((a / b)⁻¹ ⊓ 1)
α : Type u,	_inst_1 : lattice α,	_inst_2 : comm_group α,	_inst_3 : covariant_class α α has_mul.mul has_le.le,	a b : α	⊢ a * (b * a⁻¹ ⊓ 1) = a * ((a / b)⁻¹ ⊓ 1)
α : Type u,	_inst_1 : lattice α,	_inst_2 : comm_group α,	_inst_3 : covariant_class α α has_mul.mul has_le.le,	a b : α	⊢ a * (b⁻¹⁻¹ * a⁻¹ ⊓ 1) = a * ((a / b)⁻¹ ⊓ 1)
α : Type u,	_inst_1 : lattice α,	_inst_2 : comm_group α,	_inst_3 : covariant_class α α has_mul.mul has_le.le,	a b : α	⊢ a * ((a / b)⁻¹ ⊓ 1) = a * ((a / b)⁻¹ ⊓ 1⁻¹)
α : Type u,	_inst_1 : lattice α,	_inst_2 : comm_group α,	_inst_3 : covariant_class α α has_mul.mul has_le.le,	a b : α	⊢ a * ((a / b)⁻¹ ⊓ 1⁻¹) = a / (a / b ⊔ 1)
R : Type u,	L : Type v,	M : Type w,	N : Type w₁,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : add_comm_group M,	_inst_5 : add_comm_group N,	_inst_7 : module R M,	_inst_8 : module R N,	_inst_10 : lie_ring_module L M,	_inst_11 : lie_ring_module L N,	_inst_13 : lie_module R L M,	_inst_14 : lie_module R L N,	n : ℕ,	f : M →ₗ⁅R,L⁆ N,	x : L,	m : M	⊢ (n • ↑f).to_fun ⁅x,m⁆ = ⁅x,(n • ↑f).to_fun m⁆
R : Type u,	L : Type v,	M : Type w,	N : Type w₁,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : add_comm_group M,	_inst_5 : add_comm_group N,	_inst_7 : module R M,	_inst_8 : module R N,	_inst_10 : lie_ring_module L M,	_inst_11 : lie_ring_module L N,	_inst_13 : lie_module R L M,	_inst_14 : lie_module R L N,	f : M →ₗ⁅R,L⁆ N	⊢ {to_fun := (0 • ↑f).to_fun, map_add' := _, map_smul' := _, map_lie' := _} = 0
R : Type u,	L : Type v,	M : Type w,	N : Type w₁,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : add_comm_group M,	_inst_5 : add_comm_group N,	_inst_7 : module R M,	_inst_8 : module R N,	_inst_10 : lie_ring_module L M,	_inst_11 : lie_ring_module L N,	_inst_13 : lie_module R L M,	_inst_14 : lie_module R L N,	f : M →ₗ⁅R,L⁆ N,	m : M	⊢ ⇑{to_fun := (0 • ↑f).to_fun, map_add' := _, map_smul' := _, map_lie' := _} m = ⇑0 m
R : Type u,	L : Type v,	M : Type w,	N : Type w₁,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : add_comm_group M,	_inst_5 : add_comm_group N,	_inst_7 : module R M,	_inst_8 : module R N,	_inst_10 : lie_ring_module L M,	_inst_11 : lie_ring_module L N,	_inst_13 : lie_module R L M,	_inst_14 : lie_module R L N,	n : ℕ,	f : M →ₗ⁅R,L⁆ N	⊢ {to_fun := (n.succ • ↑f).to_fun, map_add' := _, map_smul' := _, map_lie' := _} = f + {to_fun := (n • ↑f).to_fun, map_add' := _, map_smul' := _, map_lie' := _}
R : Type u,	L : Type v,	M : Type w,	N : Type w₁,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : add_comm_group M,	_inst_5 : add_comm_group N,	_inst_7 : module R M,	_inst_8 : module R N,	_inst_10 : lie_ring_module L M,	_inst_11 : lie_ring_module L N,	_inst_13 : lie_module R L M,	_inst_14 : lie_module R L N,	n : ℕ,	f : M →ₗ⁅R,L⁆ N,	m : M	⊢ ⇑{to_fun := (n.succ • ↑f).to_fun, map_add' := _, map_smul' := _, map_lie' := _} m = ⇑(f + {to_fun := (n • ↑f).to_fun, map_add' := _, map_smul' := _, map_lie' := _}) m
R : Type u,	L : Type v,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : is_lie_abelian L,	ψ : module.dual R L,	x y : L	⊢ ψ.to_fun ⁅x,y⁆ = ⁅ψ.to_fun x,ψ.to_fun y⁆
R : Type u,	L : Type v,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : is_lie_abelian L,	χ : lie_algebra.lie_character R L	⊢ (λ (ψ : module.dual R L), {to_fun := ψ.to_fun, map_add' := _, map_smul' := _, map_lie' := _}) ((λ (χ : lie_algebra.lie_character R L), ↑χ) χ) = χ
R : Type u,	L : Type v,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : is_lie_abelian L,	χ : lie_algebra.lie_character R L,	x : L	⊢ ⇑((λ (ψ : module.dual R L), {to_fun := ψ.to_fun, map_add' := _, map_smul' := _, map_lie' := _}) ((λ (χ : lie_algebra.lie_character R L), ↑χ) χ)) x = ⇑χ x
R : Type u,	L : Type v,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : is_lie_abelian L,	ψ : module.dual R L	⊢ (λ (χ : lie_algebra.lie_character R L), ↑χ) ((λ (ψ : module.dual R L), {to_fun := ψ.to_fun, map_add' := _, map_smul' := _, map_lie' := _}) ψ) = ψ
R : Type u,	L : Type v,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : is_lie_abelian L,	ψ : module.dual R L,	x : L	⊢ ⇑((λ (χ : lie_algebra.lie_character R L), ↑χ) ((λ (ψ : module.dual R L), {to_fun := ψ.to_fun, map_add' := _, map_smul' := _, map_lie' := _}) ψ)) x = ⇑ψ x
n : Type u_1,	R : Type u₂,	_inst_1 : decidable_eq n,	_inst_5 : comm_ring R,	_inst_6 : fintype n,	A : matrix n n R	⊢ A ∈ lie_algebra.orthogonal.so n R ↔ Aᵀ = -A
n : Type u_1,	R : Type u₂,	_inst_1 : decidable_eq n,	_inst_5 : comm_ring R,	_inst_6 : fintype n,	A : matrix n n R	⊢ 1.is_skew_adjoint A ↔ Aᵀ = -A
l : Type u_4,	R : Type u₂,	_inst_4 : decidable_eq l,	_inst_5 : comm_ring R,	_inst_8 : fintype l,	_inst_9 : invertible 2	⊢ 1.from_blocks 0 0 (lie_algebra.orthogonal.PD l R)⁻¹ * lie_algebra.orthogonal.PB l R = 1
l : Type u_4,	R : Type u₂,	_inst_4 : decidable_eq l,	_inst_5 : comm_ring R,	_inst_8 : fintype l,	_inst_9 : invertible 2	⊢ ((λ (j k : unit ⊕ l ⊕ l), lie_algebra.orthogonal.PB l R j k) ⬝ λ (i j : unit ⊕ l ⊕ l), 1.from_blocks 0 0 (lie_algebra.orthogonal.PD l R)⁻¹ i j) = 1
l : Type u_4,	R : Type u₂,	_inst_4 : decidable_eq l,	_inst_5 : comm_ring R,	_inst_8 : fintype l	⊢ lie_algebra.orthogonal.indefinite_diagonal (unit ⊕ l) l R = ⇑(matrix.reindex_lie_equiv (equiv.sum_assoc unit l l).symm) (1.from_blocks 0 0 (lie_algebra.orthogonal.indefinite_diagonal l l R))
l : Type u_4,	R : Type u₂,	_inst_4 : decidable_eq l,	_inst_5 : comm_ring R,	_inst_8 : fintype l,	i j : (unit ⊕ l) ⊕ l	⊢ lie_algebra.orthogonal.indefinite_diagonal (unit ⊕ l) l R i j = ⇑(matrix.reindex_lie_equiv (equiv.sum_assoc unit l l).symm) (1.from_blocks 0 0 (lie_algebra.orthogonal.indefinite_diagonal l l R)) i j
l : Type u_4,	R : Type u₂,	_inst_4 : decidable_eq l,	_inst_5 : comm_ring R,	_inst_8 : fintype l,	i j : (unit ⊕ l) ⊕ l	⊢ lie_algebra.orthogonal.indefinite_diagonal (unit ⊕ l) l R i j = ⇑(matrix.reindex_lie_equiv (equiv.sum_assoc unit l l).symm) (1.from_blocks 0 0 (lie_algebra.orthogonal.indefinite_diagonal l l R)) i j
l : Type u_4,	R : Type u₂,	_inst_4 : decidable_eq l,	_inst_5 : comm_ring R,	_inst_8 : fintype l,	i j : (unit ⊕ l) ⊕ l	⊢ lie_algebra.orthogonal.indefinite_diagonal (unit ⊕ l) l R i j = ⇑(matrix.reindex_lie_equiv (equiv.sum_assoc unit l l).symm) (1.from_blocks 0 0 (lie_algebra.orthogonal.indefinite_diagonal l l R)) i j
l : Type u_4,	R : Type u₂,	_inst_4 : decidable_eq l,	_inst_5 : comm_ring R,	_inst_8 : fintype l,	i j : (unit ⊕ l) ⊕ l	⊢ lie_algebra.orthogonal.indefinite_diagonal (unit ⊕ l) l R i j = ⇑(matrix.reindex_lie_equiv (equiv.sum_assoc unit l l).symm) (1.from_blocks 0 0 (lie_algebra.orthogonal.indefinite_diagonal l l R)) i j
l : Type u_4,	R : Type u₂,	_inst_4 : decidable_eq l,	_inst_5 : comm_ring R,	_inst_8 : fintype l,	j : (unit ⊕ l) ⊕ l	⊢ lie_algebra.orthogonal.indefinite_diagonal (unit ⊕ l) l R (sum.inl (sum.inl punit.star)) j = ⇑(matrix.reindex_lie_equiv (equiv.sum_assoc unit l l).symm) (1.from_blocks 0 0 (lie_algebra.orthogonal.indefinite_diagonal l l R)) (sum.inl (sum.inl punit.star)) j
l : Type u_4,	R : Type u₂,	_inst_4 : decidable_eq l,	_inst_5 : comm_ring R,	_inst_8 : fintype l,	j : (unit ⊕ l) ⊕ l,	i₃ : l	⊢ lie_algebra.orthogonal.indefinite_diagonal (unit ⊕ l) l R (sum.inl (sum.inr i₃)) j = ⇑(matrix.reindex_lie_equiv (equiv.sum_assoc unit l l).symm) (1.from_blocks 0 0 (lie_algebra.orthogonal.indefinite_diagonal l l R)) (sum.inl (sum.inr i₃)) j
l : Type u_4,	R : Type u₂,	_inst_4 : decidable_eq l,	_inst_5 : comm_ring R,	_inst_8 : fintype l,	j : (unit ⊕ l) ⊕ l,	i : l	⊢ lie_algebra.orthogonal.indefinite_diagonal (unit ⊕ l) l R (sum.inr i) j = ⇑(matrix.reindex_lie_equiv (equiv.sum_assoc unit l l).symm) (1.from_blocks 0 0 (lie_algebra.orthogonal.indefinite_diagonal l l R)) (sum.inr i) j
l : Type u_4,	R : Type u₂,	_inst_4 : decidable_eq l,	_inst_5 : comm_ring R,	_inst_8 : fintype l	⊢ lie_algebra.orthogonal.indefinite_diagonal (unit ⊕ l) l R (sum.inl (sum.inl punit.star)) (sum.inl (sum.inl punit.star)) = ⇑(matrix.reindex_lie_equiv (equiv.sum_assoc unit l l).symm) (1.from_blocks 0 0 (lie_algebra.orthogonal.indefinite_diagonal l l R)) (sum.inl (sum.inl punit.star)) (sum.inl (sum.inl punit.star))
l : Type u_4,	R : Type u₂,	_inst_4 : decidable_eq l,	_inst_5 : comm_ring R,	_inst_8 : fintype l,	j₃ : l	⊢ lie_algebra.orthogonal.indefinite_diagonal (unit ⊕ l) l R (sum.inl (sum.inl punit.star)) (sum.inl (sum.inr j₃)) = ⇑(matrix.reindex_lie_equiv (equiv.sum_assoc unit l l).symm) (1.from_blocks 0 0 (lie_algebra.orthogonal.indefinite_diagonal l l R)) (sum.inl (sum.inl punit.star)) (sum.inl (sum.inr j₃))
l : Type u_4,	R : Type u₂,	_inst_4 : decidable_eq l,	_inst_5 : comm_ring R,	_inst_8 : fintype l,	j : l	⊢ lie_algebra.orthogonal.indefinite_diagonal (unit ⊕ l) l R (sum.inl (sum.inl punit.star)) (sum.inr j) = ⇑(matrix.reindex_lie_equiv (equiv.sum_assoc unit l l).symm) (1.from_blocks 0 0 (lie_algebra.orthogonal.indefinite_diagonal l l R)) (sum.inl (sum.inl punit.star)) (sum.inr j)
l : Type u_4,	R : Type u₂,	_inst_4 : decidable_eq l,	_inst_5 : comm_ring R,	_inst_8 : fintype l,	i₃ : l	⊢ lie_algebra.orthogonal.indefinite_diagonal (unit ⊕ l) l R (sum.inl (sum.inr i₃)) (sum.inl (sum.inl punit.star)) = ⇑(matrix.reindex_lie_equiv (equiv.sum_assoc unit l l).symm) (1.from_blocks 0 0 (lie_algebra.orthogonal.indefinite_diagonal l l R)) (sum.inl (sum.inr i₃)) (sum.inl (sum.inl punit.star))
l : Type u_4,	R : Type u₂,	_inst_4 : decidable_eq l,	_inst_5 : comm_ring R,	_inst_8 : fintype l,	i₃ j₃ : l	⊢ lie_algebra.orthogonal.indefinite_diagonal (unit ⊕ l) l R (sum.inl (sum.inr i₃)) (sum.inl (sum.inr j₃)) = ⇑(matrix.reindex_lie_equiv (equiv.sum_assoc unit l l).symm) (1.from_blocks 0 0 (lie_algebra.orthogonal.indefinite_diagonal l l R)) (sum.inl (sum.inr i₃)) (sum.inl (sum.inr j₃))
l : Type u_4,	R : Type u₂,	_inst_4 : decidable_eq l,	_inst_5 : comm_ring R,	_inst_8 : fintype l,	i₃ j : l	⊢ lie_algebra.orthogonal.indefinite_diagonal (unit ⊕ l) l R (sum.inl (sum.inr i₃)) (sum.inr j) = ⇑(matrix.reindex_lie_equiv (equiv.sum_assoc unit l l).symm) (1.from_blocks 0 0 (lie_algebra.orthogonal.indefinite_diagonal l l R)) (sum.inl (sum.inr i₃)) (sum.inr j)
l : Type u_4,	R : Type u₂,	_inst_4 : decidable_eq l,	_inst_5 : comm_ring R,	_inst_8 : fintype l,	i : l	⊢ lie_algebra.orthogonal.indefinite_diagonal (unit ⊕ l) l R (sum.inr i) (sum.inl (sum.inl punit.star)) = ⇑(matrix.reindex_lie_equiv (equiv.sum_assoc unit l l).symm) (1.from_blocks 0 0 (lie_algebra.orthogonal.indefinite_diagonal l l R)) (sum.inr i) (sum.inl (sum.inl punit.star))
l : Type u_4,	R : Type u₂,	_inst_4 : decidable_eq l,	_inst_5 : comm_ring R,	_inst_8 : fintype l,	i j₃ : l	⊢ lie_algebra.orthogonal.indefinite_diagonal (unit ⊕ l) l R (sum.inr i) (sum.inl (sum.inr j₃)) = ⇑(matrix.reindex_lie_equiv (equiv.sum_assoc unit l l).symm) (1.from_blocks 0 0 (lie_algebra.orthogonal.indefinite_diagonal l l R)) (sum.inr i) (sum.inl (sum.inr j₃))
l : Type u_4,	R : Type u₂,	_inst_4 : decidable_eq l,	_inst_5 : comm_ring R,	_inst_8 : fintype l,	i j : l	⊢ lie_algebra.orthogonal.indefinite_diagonal (unit ⊕ l) l R (sum.inr i) (sum.inr j) = ⇑(matrix.reindex_lie_equiv (equiv.sum_assoc unit l l).symm) (1.from_blocks 0 0 (lie_algebra.orthogonal.indefinite_diagonal l l R)) (sum.inr i) (sum.inr j)
l : Type u_4,	R : Type u₂,	_inst_4 : decidable_eq l,	_inst_5 : comm_ring R,	_inst_8 : fintype l,	i₃ j₃ : l	⊢ ite (i₃ = j₃) 1 0 = ite (i₃ = j₃) 1 0
l : Type u_4,	R : Type u₂,	_inst_4 : decidable_eq l,	_inst_5 : comm_ring R,	_inst_8 : fintype l,	i j : l	⊢ ite (i = j) (-1) 0 = ite (i = j) (-1) 0
R : Type u,	L : Type v,	L' : Type w₂,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	f : L →ₗ⁅R⁆ L',	I₁ I₂ : lie_ideal R L	⊢ ⁅I₁,I₂⁆ ≤ lie_ideal.comap f ⁅lie_ideal.map f I₁,lie_ideal.map f I₂⁆
R : Type u,	L : Type v,	L' : Type w₂,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	f : L →ₗ⁅R⁆ L',	I₁ I₂ : lie_ideal R L	⊢ lie_ideal.map f ⁅I₁,I₂⁆ ≤ ⁅lie_ideal.map f I₁,lie_ideal.map f I₂⁆
R : Type u,	L : Type v,	L' : Type w₂,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	f : L →ₗ⁅R⁆ L',	I₁ I₂ : lie_ideal R L,	x : L,	hx : x ∈ {m : L | ∃ (x : ↥I₁) (n : ↥I₂), ⁅↑x,↑n⁆ = m}	⊢ x ∈ ↑(lie_ideal.comap f ⁅lie_ideal.map f I₁,lie_ideal.map f I₂⁆)
R : Type u,	L : Type v,	L' : Type w₂,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	f : L →ₗ⁅R⁆ L',	I₁ I₂ : lie_ideal R L	⊢ {m : L | ∃ (x : ↥I₁) (n : ↥I₂), ⁅↑x,↑n⁆ = m} ⊆ ↑(lie_ideal.comap f ⁅lie_ideal.map f I₁,lie_ideal.map f I₂⁆)
R : Type u,	L : Type v,	L' : Type w₂,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	f : L →ₗ⁅R⁆ L',	I₁ I₂ : lie_ideal R L,	x y₁ : L,	hy₁ : y₁ ∈ has_coe_t_aux.coe (has_coe_t_aux.coe I₁),	y₂ : L,	hy₂ : y₂ ∈ has_coe_t_aux.coe I₂,	hx : ⁅↑⟨y₁, hy₁⟩,↑⟨y₂, hy₂⟩⁆ = x	⊢ x ∈ ↑(lie_ideal.comap f ⁅lie_ideal.map f I₁,lie_ideal.map f I₂⁆)
R : Type u,	L : Type v,	L' : Type w₂,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	f : L →ₗ⁅R⁆ L',	I₁ I₂ : lie_ideal R L,	x y₁ : L,	hy₁ : y₁ ∈ has_coe_t_aux.coe (has_coe_t_aux.coe I₁),	y₂ : L,	hy₂ : y₂ ∈ has_coe_t_aux.coe I₂,	hx : ⁅↑⟨y₁, hy₁⟩,↑⟨y₂, hy₂⟩⁆ = x	⊢ ⁅↑⟨y₁, hy₁⟩,↑⟨y₂, hy₂⟩⁆ ∈ ↑(lie_ideal.comap f ⁅lie_ideal.map f I₁,lie_ideal.map f I₂⁆)
R : Type u,	L : Type v,	L' : Type w₂,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	f : L →ₗ⁅R⁆ L',	I₁ I₂ : lie_ideal R L,	x y₁ : L,	hy₁ : y₁ ∈ has_coe_t_aux.coe (has_coe_t_aux.coe I₁),	y₂ : L,	hy₂ : y₂ ∈ has_coe_t_aux.coe I₂,	hx : ⁅↑⟨y₁, hy₁⟩,↑⟨y₂, hy₂⟩⁆ = x,	fy₁ : ↥(lie_ideal.map f I₁) := ⟨⇑f y₁, _⟩	⊢ ⁅↑⟨y₁, hy₁⟩,↑⟨y₂, hy₂⟩⁆ ∈ ↑(lie_ideal.comap f ⁅lie_ideal.map f I₁,lie_ideal.map f I₂⁆)
R : Type u,	L : Type v,	L' : Type w₂,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	f : L →ₗ⁅R⁆ L',	I₁ I₂ : lie_ideal R L,	x y₁ : L,	hy₁ : y₁ ∈ has_coe_t_aux.coe (has_coe_t_aux.coe I₁),	y₂ : L,	hy₂ : y₂ ∈ has_coe_t_aux.coe I₂,	hx : ⁅↑⟨y₁, hy₁⟩,↑⟨y₂, hy₂⟩⁆ = x,	fy₁ : ↥(lie_ideal.map f I₁) := ⟨⇑f y₁, _⟩,	fy₂ : ↥(lie_ideal.map f I₂) := ⟨⇑f y₂, _⟩	⊢ ⁅↑⟨y₁, hy₁⟩,↑⟨y₂, hy₂⟩⁆ ∈ ↑(lie_ideal.comap f ⁅lie_ideal.map f I₁,lie_ideal.map f I₂⁆)
R : Type u,	L : Type v,	L' : Type w₂,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	f : L →ₗ⁅R⁆ L',	I₁ I₂ : lie_ideal R L,	x y₁ : L,	hy₁ : y₁ ∈ has_coe_t_aux.coe (has_coe_t_aux.coe I₁),	y₂ : L,	hy₂ : y₂ ∈ has_coe_t_aux.coe I₂,	hx : ⁅↑⟨y₁, hy₁⟩,↑⟨y₂, hy₂⟩⁆ = x,	fy₁ : ↥(lie_ideal.map f I₁) := ⟨⇑f y₁, _⟩,	fy₂ : ↥(lie_ideal.map f I₂) := ⟨⇑f y₂, _⟩	⊢ ⁅↑⟨y₁, hy₁⟩,↑⟨y₂, hy₂⟩⁆ ∈ lie_ideal.comap f ⁅lie_ideal.map f I₁,lie_ideal.map f I₂⁆
R : Type u,	L : Type v,	L' : Type w₂,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	f : L →ₗ⁅R⁆ L',	I₁ I₂ : lie_ideal R L,	x y₁ : L,	hy₁ : y₁ ∈ has_coe_t_aux.coe (has_coe_t_aux.coe I₁),	y₂ : L,	hy₂ : y₂ ∈ has_coe_t_aux.coe I₂,	hx : ⁅↑⟨y₁, hy₁⟩,↑⟨y₂, hy₂⟩⁆ = x,	fy₁ : ↥(lie_ideal.map f I₁) := ⟨⇑f y₁, _⟩,	fy₂ : ↥(lie_ideal.map f I₂) := ⟨⇑f y₂, _⟩	⊢ ⁅⇑f y₁,⇑f y₂⁆ ∈ ⁅lie_ideal.map f I₁,lie_ideal.map f I₂⁆
R : Type u,	L : Type v,	M : Type w,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	_inst_6 : lie_ring_module L M,	_inst_7 : lie_module R L M,	N : lie_submodule R L M,	x y : L	⊢ ((↑N.mapq_linear ↑N).comp lie_submodule.quotient.lie_submodule_invariant).to_fun ⁅x,y⁆ = ⁅((↑N.mapq_linear ↑N).comp lie_submodule.quotient.lie_submodule_invariant).to_fun x,((↑N.mapq_linear ↑N).comp lie_submodule.quotient.lie_submodule_invariant).to_fun y⁆
R : Type u,	L : Type v,	M : Type w,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	_inst_6 : lie_ring_module L M,	_inst_7 : lie_module R L M,	N : lie_submodule R L M,	x y : L,	m : M	⊢ ⇑((((↑N.mapq_linear ↑N).comp lie_submodule.quotient.lie_submodule_invariant).to_fun ⁅x,y⁆).comp ↑N.mkq) m = ⇑(linear_map.comp ⁅((↑N.mapq_linear ↑N).comp lie_submodule.quotient.lie_submodule_invariant).to_fun x,((↑N.mapq_linear ↑N).comp lie_submodule.quotient.lie_submodule_invariant).to_fun y⁆ ↑N.mkq) m
R : Type u,	L : Type v,	M : Type w,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	_inst_6 : lie_ring_module L M,	_inst_7 : lie_module R L M,	N : lie_submodule R L M,	x y : L,	m : M	⊢ lie_submodule.quotient.mk ⁅⁅x,y⁆,m⁆ = lie_submodule.quotient.mk (⁅x,⁅y,m⁆⁆ - ⁅y,⁅x,m⁆⁆)
R : Type u,	L : Type v,	M : Type w,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	_inst_6 : lie_ring_module L M,	_inst_7 : lie_module R L M,	N : lie_submodule R L M,	x y : L,	m : M	⊢ ⁅⁅x,y⁆,m⁆ = ⁅x,⁅y,m⁆⁆ - ⁅y,⁅x,m⁆⁆
R : Type u,	L : Type v,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_algebra.is_semisimple R L,	h : is_lie_abelian L	⊢ subsingleton L
R : Type u,	L : Type v,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_algebra.is_semisimple R L,	h : ⊥ = ⊤	⊢ subsingleton L
R : Type u,	L : Type v,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	S : set (lie_subalgebra R L)	⊢ ↑(has_Inf.Inf S) = ⋂ (s : lie_subalgebra R L) (H : s ∈ S), ↑s
R : Type u,	L : Type v,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	S : set (lie_subalgebra R L)	⊢ (⋂ (p : submodule R L) (H : p ∈ {_x : submodule R L | ∃ (s : lie_subalgebra R L) (H : s ∈ S), ↑s = _x}), ↑p) = ⋂ (s : lie_subalgebra R L) (H : s ∈ S), ↑s
R : Type u,	L : Type v,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	S : set (lie_subalgebra R L),	x : L	⊢ (x ∈ ⋂ (p : submodule R L) (H : p ∈ {_x : submodule R L | ∃ (s : lie_subalgebra R L) (H : s ∈ S), ↑s = _x}), ↑p) ↔ x ∈ ⋂ (s : lie_subalgebra R L) (H : s ∈ S), ↑s
R : Type u,	L₁ : Type v,	L₂ : Type w,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L₁,	_inst_3 : lie_ring L₂,	_inst_4 : lie_algebra R L₁,	_inst_5 : lie_algebra R L₂,	L₁' : lie_subalgebra R L₁,	L₂' : lie_subalgebra R L₂,	e : L₁ ≃ₗ⁅R⁆ L₂,	h : lie_subalgebra.map ↑e L₁' = L₂',	x y : ↥L₁'	⊢ (↑e.of_submodules ↑L₁' ↑L₂' _).to_fun ⁅x,y⁆ = ⁅(↑e.of_submodules ↑L₁' ↑L₂' _).to_fun x,(↑e.of_submodules ↑L₁' ↑L₂' _).to_fun y⁆
R : Type u,	L₁ : Type v,	L₂ : Type w,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L₁,	_inst_3 : lie_ring L₂,	_inst_4 : lie_algebra R L₁,	_inst_5 : lie_algebra R L₂,	L₁' : lie_subalgebra R L₁,	L₂' : lie_subalgebra R L₂,	e : L₁ ≃ₗ⁅R⁆ L₂,	h : lie_subalgebra.map ↑e L₁' = L₂',	x y : ↥L₁'	⊢ ↑((↑e.of_submodules ↑L₁' ↑L₂' _).to_fun ⁅x,y⁆) = ↑⁅(↑e.of_submodules ↑L₁' ↑L₂' _).to_fun x,(↑e.of_submodules ↑L₁' ↑L₂' _).to_fun y⁆
R : Type u,	L₁ : Type v,	L₂ : Type w,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L₁,	_inst_3 : lie_ring L₂,	_inst_4 : lie_algebra R L₁,	_inst_5 : lie_algebra R L₂,	L₁' : lie_subalgebra R L₁,	L₂' : lie_subalgebra R L₂,	e : L₁ ≃ₗ⁅R⁆ L₂,	h : lie_subalgebra.map ↑e L₁' = L₂'	⊢ submodule.map ↑↑e ↑L₁' = ↑L₂'
R : Type u,	L₁ : Type v,	L₂ : Type w,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L₁,	_inst_3 : lie_ring L₂,	_inst_4 : lie_algebra R L₁,	_inst_5 : lie_algebra R L₂,	L₁' : lie_subalgebra R L₁,	L₂' : lie_subalgebra R L₂,	e : L₁ ≃ₗ⁅R⁆ L₂,	h : lie_subalgebra.map ↑e L₁' = L₂'	⊢ submodule.map ↑↑e ↑L₁' = ↑(lie_subalgebra.map ↑e L₁')
R : Type u,	L : Type v,	L' : Type w₂,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	f : L →ₗ⁅R⁆ L',	I : lie_ideal R L	⊢ I ≤ f.ker → ∀ (x : L), x ∈ I → ⇑f x = 0
R : Type u,	L : Type v,	L' : Type w₂,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	f : L →ₗ⁅R⁆ L',	I : lie_ideal R L	⊢ (∀ (x : L), x ∈ I → ⇑f x = 0) → I ≤ f.ker
R : Type u,	L : Type v,	L' : Type w₂,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	f : L →ₗ⁅R⁆ L',	I : lie_ideal R L	⊢ I ≤ f.ker ↔ ∀ (x : L), x ∈ I → ⇑f x = 0
R : Type u,	L : Type v,	L' : Type w₂,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	f : L →ₗ⁅R⁆ L',	I : lie_ideal R L	⊢ I ≤ f.ker ↔ ∀ (x : L), x ∈ I → ⇑f x = 0
R : Type u,	L : Type v,	L' : Type w₂,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	f : L →ₗ⁅R⁆ L',	I : lie_ideal R L,	x : L,	hx : x ∈ I,	h : x ∈ f.ker	⊢ ⇑f x = 0
R : Type u,	L : Type v,	L' : Type w₂,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	f : L →ₗ⁅R⁆ L',	I : lie_ideal R L,	x : L,	hx : x ∈ I,	h : ⇑f x = 0	⊢ ⇑f x = 0
R : Type u,	L : Type v,	L' : Type w₂,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	f : L →ₗ⁅R⁆ L',	I : lie_ideal R L,	h : I ≤ f.ker,	x : L,	hx : x ∈ I	⊢ ⇑f x = 0		R : Type u,	L : Type v,	L' : Type w₂,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	f : L →ₗ⁅R⁆ L',	I : lie_ideal R L,	h : ∀ (x : L), x ∈ I → ⇑f x = 0,	x : L,	hx : x ∈ I	⊢ x ∈ f.ker
R : Type u,	L : Type v,	L' : Type w₂,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	f : L →ₗ⁅R⁆ L',	I : lie_ideal R L,	h : I ≤ f.ker,	x : L,	hx : x ∈ I	⊢ ⇑f x = 0
R : Type u,	L : Type v,	L' : Type w₂,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	f : L →ₗ⁅R⁆ L',	I : lie_ideal R L,	h : ∀ (x : L), x ∈ I → ⇑f x = 0,	x : L,	hx : x ∈ I	⊢ ⇑f x = 0
R : Type u,	L : Type v,	L' : Type w₂,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	f : L →ₗ⁅R⁆ L',	I : lie_ideal R L,	h : ∀ (x : L), x ∈ I → ⇑f x = 0,	x : L,	hx : x ∈ I	⊢ x ∈ f.ker
R : Type u,	_inst_1 : comm_ring R,	L : Type v,	M : Type w,	N : Type w₁,	P : Type w₂,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	_inst_6 : lie_ring_module L M,	_inst_7 : lie_module R L M,	_inst_8 : add_comm_group N,	_inst_9 : module R N,	_inst_10 : lie_ring_module L N,	_inst_11 : lie_module R L N,	_inst_12 : add_comm_group P,	_inst_13 : module R P,	_inst_14 : lie_ring_module L P,	_inst_15 : lie_module R L P,	f : M →ₗ⁅R,L⁆ N →ₗ[R] P	⊢ ⇑(⇑(tensor_product.lie_module.lift_lie R L M N P) f) = ⇑(⇑(tensor_product.lie_module.lift R L M N P) ↑f)
R : Type u,	_inst_1 : comm_ring R,	L : Type v,	M : Type w,	N : Type w₁,	P : Type w₂,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	_inst_6 : lie_ring_module L M,	_inst_7 : lie_module R L M,	_inst_8 : add_comm_group N,	_inst_9 : module R N,	_inst_10 : lie_ring_module L N,	_inst_11 : lie_module R L N,	_inst_12 : add_comm_group P,	_inst_13 : module R P,	_inst_14 : lie_ring_module L P,	_inst_15 : lie_module R L P,	f : M →ₗ⁅R,L⁆ N →ₗ[R] P,	this : ↑(⇑(tensor_product.lie_module.lift_lie R L M N P) f) = ⇑(tensor_product.lie_module.lift R L M N P) ↑f	⊢ ⇑(⇑(tensor_product.lie_module.lift_lie R L M N P) f) = ⇑(⇑(tensor_product.lie_module.lift R L M N P) ↑f)		R : Type u,	_inst_1 : comm_ring R,	L : Type v,	M : Type w,	N : Type w₁,	P : Type w₂,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	_inst_6 : lie_ring_module L M,	_inst_7 : lie_module R L M,	_inst_8 : add_comm_group N,	_inst_9 : module R N,	_inst_10 : lie_ring_module L N,	_inst_11 : lie_module R L N,	_inst_12 : add_comm_group P,	_inst_13 : module R P,	_inst_14 : lie_ring_module L P,	_inst_15 : lie_module R L P,	f : M →ₗ⁅R,L⁆ N →ₗ[R] P	⊢ ↑(⇑(tensor_product.lie_module.lift_lie R L M N P) f) = ⇑(tensor_product.lie_module.lift R L M N P) ↑f
R : Type u,	_inst_1 : comm_ring R,	L : Type v,	M : Type w,	N : Type w₁,	P : Type w₂,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	_inst_6 : lie_ring_module L M,	_inst_7 : lie_module R L M,	_inst_8 : add_comm_group N,	_inst_9 : module R N,	_inst_10 : lie_ring_module L N,	_inst_11 : lie_module R L N,	_inst_12 : add_comm_group P,	_inst_13 : module R P,	_inst_14 : lie_ring_module L P,	_inst_15 : lie_module R L P,	f : M →ₗ⁅R,L⁆ N →ₗ[R] P,	this : ↑(⇑(tensor_product.lie_module.lift_lie R L M N P) f) = ⇑(tensor_product.lie_module.lift R L M N P) ↑f	⊢ ⇑(⇑(tensor_product.lie_module.lift_lie R L M N P) f) = ⇑(⇑(tensor_product.lie_module.lift R L M N P) ↑f)
R : Type u,	_inst_1 : comm_ring R,	L : Type v,	M : Type w,	N : Type w₁,	P : Type w₂,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	_inst_6 : lie_ring_module L M,	_inst_7 : lie_module R L M,	_inst_8 : add_comm_group N,	_inst_9 : module R N,	_inst_10 : lie_ring_module L N,	_inst_11 : lie_module R L N,	_inst_12 : add_comm_group P,	_inst_13 : module R P,	_inst_14 : lie_ring_module L P,	_inst_15 : lie_module R L P,	f : M →ₗ⁅R,L⁆ N →ₗ[R] P	⊢ ↑(⇑(tensor_product.lie_module.lift_lie R L M N P) f) = ⇑(tensor_product.lie_module.lift R L M N P) ↑f
R : Type u,	_inst_1 : comm_ring R,	L : Type v,	M : Type w,	N : Type w₁,	P : Type w₂,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	_inst_6 : lie_ring_module L M,	_inst_7 : lie_module R L M,	_inst_8 : add_comm_group N,	_inst_9 : module R N,	_inst_10 : lie_ring_module L N,	_inst_11 : lie_module R L N,	_inst_12 : add_comm_group P,	_inst_13 : module R P,	_inst_14 : lie_ring_module L P,	_inst_15 : lie_module R L P,	f : M →ₗ⁅R,L⁆ N →ₗ[R] P,	m : M,	n : N	⊢ ⇑(⇑((tensor_product.mk R M N).compr₂ ↑(⇑(tensor_product.lie_module.lift_lie R L M N P) f)) m) n = ⇑(⇑((tensor_product.mk R M N).compr₂ (⇑(tensor_product.lie_module.lift R L M N P) ↑f)) m) n
R : Type u,	_inst_1 : comm_ring R,	L : Type v,	M : Type w,	N : Type w₁,	P : Type w₂,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	_inst_6 : lie_ring_module L M,	_inst_7 : lie_module R L M,	_inst_8 : add_comm_group N,	_inst_9 : module R N,	_inst_10 : lie_ring_module L N,	_inst_11 : lie_module R L N,	_inst_12 : add_comm_group P,	_inst_13 : module R P,	_inst_14 : lie_ring_module L P,	_inst_15 : lie_module R L P,	f : M →ₗ⁅R,L⁆ N →ₗ[R] P,	m : M,	n : N	⊢ ⇑(⇑(tensor_product.lie_module.lift_lie R L M N P) f) (m ⊗ₜ[R] n) = ⇑(⇑f m) n
R : Type u₁,	L : Type u₂,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	A : Type u₃,	_inst_4 : ring A,	_inst_5 : algebra R A,	f : L →ₗ⁅R⁆ A,	x : L	⊢ ⇑(⇑(universal_enveloping_algebra.lift R) f) (⇑(universal_enveloping_algebra.ι R) x) = ⇑f x
R : Type u,	L : Type v,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	M : Type w,	_inst_5 : add_comm_group M,	_inst_6 : module R M,	_inst_7 : lie_ring_module L M,	_inst_8 : lie_module R L M,	_inst_9 : lie_algebra.is_nilpotent R L,	_inst_10 : lie_module.is_nilpotent R L M	⊢ lie_module.weight_space M 0 = ⊤
R : Type u,	L : Type v,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	M : Type w,	_inst_5 : add_comm_group M,	_inst_6 : module R M,	_inst_7 : lie_ring_module L M,	_inst_8 : lie_module R L M,	_inst_9 : lie_algebra.is_nilpotent R L,	_inst_10 : lie_module.is_nilpotent R L M	⊢ 0 ∘ ⇑(⊤.incl) = 0
R : Type u,	L : Type v,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	M : Type w,	_inst_5 : add_comm_group M,	_inst_6 : module R M,	_inst_7 : lie_ring_module L M,	_inst_8 : lie_module R L M,	_inst_9 : lie_algebra.is_nilpotent R L,	_inst_10 : lie_module.is_nilpotent R L M,	x : ↥⊤	⊢ (0 ∘ ⇑(⊤.incl)) x = 0 x
R : Type u,	L : Type v,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	M : Type w,	_inst_5 : add_comm_group M,	_inst_6 : module R M,	_inst_7 : lie_ring_module L M,	_inst_8 : lie_module R L M,	_inst_9 : lie_algebra.is_nilpotent R L,	_inst_10 : lie_module.is_nilpotent R L M	⊢ 0 ∘ ⇑(⊤.incl) = 0		R : Type u,	L : Type v,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	M : Type w,	_inst_5 : add_comm_group M,	_inst_6 : module R M,	_inst_7 : lie_ring_module L M,	_inst_8 : lie_module R L M,	_inst_9 : lie_algebra.is_nilpotent R L,	_inst_10 : lie_module.is_nilpotent R L M,	h₀ : 0 ∘ ⇑(⊤.incl) = 0	⊢ lie_module.weight_space M 0 = ⊤
R : Type u,	L : Type v,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	M : Type w,	_inst_5 : add_comm_group M,	_inst_6 : module R M,	_inst_7 : lie_ring_module L M,	_inst_8 : lie_module R L M,	_inst_9 : lie_algebra.is_nilpotent R L,	_inst_10 : lie_module.is_nilpotent R L M,	h₀ : 0 ∘ ⇑(⊤.incl) = 0	⊢ lie_module.weight_space M 0 = ⊤
R : Type u,	L : Type v,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	M : Type w,	_inst_5 : add_comm_group M,	_inst_6 : module R M,	_inst_7 : lie_ring_module L M,	_inst_8 : lie_module R L M,	_inst_9 : lie_algebra.is_nilpotent R L,	_inst_10 : lie_module.is_nilpotent R L M,	h₀ : 0 ∘ ⇑(⊤.incl) = 0	⊢ ↑(lie_module.weight_space M 0) = ⨅ (x : L), (⇑(lie_module.to_endomorphism R L M) x).maximal_generalized_eigenspace 0
R : Type u,	M : Type w,	_inst_2 : ring R,	_inst_3 : add_comm_group M,	_inst_5 : module R M,	n : ℤ,	x : R,	y : M	⊢ (0 • x) • y = 0 • x • y
R : Type u,	M : Type w,	_inst_2 : ring R,	_inst_3 : add_comm_group M,	_inst_5 : module R M,	n : ℤ,	x : R,	y : M,	n : ℕ,	ih : (↑n • x) • y = ↑n • x • y	⊢ ((↑n + 1) • x) • y = (↑n + 1) • x • y
R : Type u,	M : Type w,	_inst_2 : ring R,	_inst_3 : add_comm_group M,	_inst_5 : module R M,	n : ℤ,	x : R,	y : M,	n : ℕ,	ih : (-↑n • x) • y = -↑n • x • y	⊢ ((-↑n - 1) • x) • y = (-↑n - 1) • x • y
R : Type u,	M : Type w,	M₂ : Type x,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : add_comm_group M₂,	_inst_4 : module R M,	_inst_5 : module R M₂,	f : M →+ M₂,	x : ℤ,	a : M	⊢ ⇑f (↑x • a) = ↑x • ⇑f a
k : Type u_1,	M : Type u_2,	_inst_1 : ordered_ring k,	_inst_2 : ordered_add_comm_group M,	_inst_3 : module k M,	_inst_4 : ordered_smul k M,	a b : M,	c : k,	h : a < b,	hc : c < 0	⊢ c • b < c • a
k : Type u_1,	M : Type u_2,	_inst_1 : ordered_ring k,	_inst_2 : ordered_add_comm_group M,	_inst_3 : module k M,	_inst_4 : ordered_smul k M,	a b : M,	c : k,	h : a < b,	hc : c < 0	⊢ -c • a < -c • b
k : Type u_1,	M : Type u_2,	_inst_1 : ordered_ring k,	_inst_2 : ordered_add_comm_group M,	_inst_3 : module k M,	_inst_4 : ordered_smul k M,	a b : M,	c : k,	hc : c < 0	⊢ c • a < c • b ↔ b < a
k : Type u_1,	M : Type u_2,	_inst_1 : ordered_ring k,	_inst_2 : ordered_add_comm_group M,	_inst_3 : module k M,	_inst_4 : ordered_smul k M,	a b : M,	c : k,	hc : c < 0	⊢ -c • b < -c • a ↔ b < a
I : Type u,	f : I → Type v,	g : I → Type ?,	m : Π (i : I), monoid (f i),	n : Π (i : I), add_monoid (g i),	_inst_1 : Π (i : I), distrib_mul_action (f i) (g i)	⊢ ∀ (r : Π (i : I), f i) (x y : Π (i : I), g i), r • (x + y) = r • x + r • y
I : Type u,	f : I → Type v,	g : I → Type ?,	m : Π (i : I), monoid (f i),	n : Π (i : I), add_monoid (g i),	_inst_1 : Π (i : I), distrib_mul_action (f i) (g i),	r : Π (i : I), f i,	x y : Π (i : I), g i	⊢ r • (x + y) = r • x + r • y
I : Type u,	f : I → Type v,	g : I → Type ?,	m : Π (i : I), monoid (f i),	n : Π (i : I), add_monoid (g i),	_inst_1 : Π (i : I), distrib_mul_action (f i) (g i),	r : Π (i : I), f i,	x y : Π (i : I), g i,	x : I	⊢ (r • (x + y)) x = (r • x + r • y) x
I : Type u,	f : I → Type v,	g : I → Type ?,	m : Π (i : I), monoid (f i),	n : Π (i : I), add_monoid (g i),	_inst_1 : Π (i : I), distrib_mul_action (f i) (g i)	⊢ ∀ (r : Π (i : I), f i), r • 0 = 0
I : Type u,	f : I → Type v,	g : I → Type ?,	m : Π (i : I), monoid (f i),	n : Π (i : I), add_monoid (g i),	_inst_1 : Π (i : I), distrib_mul_action (f i) (g i),	r : Π (i : I), f i	⊢ r • 0 = 0
I : Type u,	f : I → Type v,	g : I → Type ?,	m : Π (i : I), monoid (f i),	n : Π (i : I), add_monoid (g i),	_inst_1 : Π (i : I), distrib_mul_action (f i) (g i),	r : Π (i : I), f i,	x : I	⊢ (r • 0) x = 0 x
K : Type u_1,	ι : Type u_2,	R : ι → Type u_3,	_inst_1 : Π (i : ι), has_scalar K (R i),	r : K,	s : set ι,	t : Π (i : ι), set (R i)	⊢ r • s.pi t ⊆ s.pi (r • t)
K : Type u_1,	ι : Type u_2,	R : ι → Type u_3,	_inst_1 : Π (i : ι), has_scalar K (R i),	r : K,	s : set ι,	t : Π (i : ι), set (R i),	i : ι,	hi : i ∈ s,	y : Π (i : ι), R i,	h : y ∈ s.pi t	⊢ (r • y) i ∈ (r • t) i
R : Type u_1,	M : Type u_3,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	ι : Sort u_2,	p : ι → submodule R M	⊢ (↑⨅ (i : ι), p i) = ⋂ (i : ι), ↑(p i)
R : Type u_1,	M : Type u_3,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	ι : Sort u_2,	p : ι → submodule R M	⊢ (↑⨅ (i : ι), p i) = ⋂ (i : ι), ↑(p i)
R : Type u_1,	M : Type u_3,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	ι : Sort u_2,	p : ι → submodule R M	⊢ (↑⨅ (i : ι), p i) = ⋂ (i : ι), ↑(p i)
R : Type u_1,	M : Type u_3,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	ι : Sort u_2,	p : ι → submodule R M	⊢ (⋂ (p_1 : submodule R M) (H : p_1 ∈ set.range (λ (i : ι), p i)), ↑p_1) = ⋂ (i : ι), ↑(p i)
R : Type u_1,	M : Type u_3,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	ι : Sort u_2,	p : ι → submodule R M,	a : M	⊢ (a ∈ ⋂ (p_1 : submodule R M) (H : p_1 ∈ set.range (λ (i : ι), p i)), ↑p_1) ↔ a ∈ ⋂ (i : ι), ↑(p i)
R : Type u_1,	M : Type u_3,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	ι : Sort u_2,	p : ι → submodule R M	⊢ (↑⨅ (i : ι), p i) = ⋂ (i : ι), ↑(p i)
R : Type u,	M : Type v,	_inst_1 : monoid R,	_inst_2 : add_monoid M,	_inst_3 : distrib_mul_action R M,	c : R	⊢ c • 0 = 0
R : Type u,	M : Type v,	_inst_1 : monoid R,	_inst_2 : add_monoid M,	_inst_3 : distrib_mul_action R M,	c : R	⊢ (c • 0).down = 0.down
R : Type u,	M : Type v,	_inst_1 : monoid R,	_inst_2 : add_monoid M,	_inst_3 : distrib_mul_action R M,	c : R,	f g : ulift M	⊢ c • (f + g) = c • f + c • g
R : Type u,	M : Type v,	_inst_1 : monoid R,	_inst_2 : add_monoid M,	_inst_3 : distrib_mul_action R M,	c : R,	f g : ulift M	⊢ (c • (f + g)).down = (c • f + c • g).down
k : Type u₁,	G : Type u₂,	_inst_1 : semiring k,	_inst_2 : has_mul G,	f g : monoid_algebra k G,	x : G,	s : finset (G × G),	hs : ∀ {p : G × G}, p ∈ s ↔ p.fst * p.snd = x,	F : G × G → k := λ (p : G × G), ite (p.fst * p.snd = x) (⇑f p.fst * ⇑g p.snd) 0	⊢ finset.filter (λ (p : G × G), p.fst * p.snd = x) (f.support.product g.support) = finset.filter (λ (p : G × G), p.fst ∈ f.support ∧ p.snd ∈ g.support) s
k : Type u₁,	G : Type u₂,	_inst_1 : semiring k,	_inst_2 : has_mul G,	f g : monoid_algebra k G,	x : G,	s : finset (G × G),	hs : ∀ {p : G × G}, p ∈ s ↔ p.fst * p.snd = x,	F : G × G → k := λ (p : G × G), ite (p.fst * p.snd = x) (⇑f p.fst * ⇑g p.snd) 0,	a : G × G	⊢ a ∈ finset.filter (λ (p : G × G), p.fst * p.snd = x) (f.support.product g.support) ↔ a ∈ finset.filter (λ (p : G × G), p.fst ∈ f.support ∧ p.snd ∈ g.support) s
k : Type u₁,	G : Type u₂,	_inst_1 : semiring k,	_inst_2 : has_mul G,	f g : monoid_algebra k G,	x : G,	s : finset (G × G),	hs : ∀ {p : G × G}, p ∈ s ↔ p.fst * p.snd = x,	F : G × G → k := λ (p : G × G), ite (p.fst * p.snd = x) (⇑f p.fst * ⇑g p.snd) 0,	p : G × G,	hps : p ∈ s,	hp : p ∉ finset.filter (λ (p : G × G), p.fst ∈ f.support ∧ p.snd ∈ g.support) s	⊢ ⇑f p.fst * ⇑g p.snd = 0
k : Type u₁,	G : Type u₂,	_inst_1 : semiring k,	_inst_2 : has_mul G,	f g : monoid_algebra k G,	x : G,	s : finset (G × G),	hs : ∀ {p : G × G}, p ∈ s ↔ p.fst * p.snd = x,	F : G × G → k := λ (p : G × G), ite (p.fst * p.snd = x) (⇑f p.fst * ⇑g p.snd) 0,	p : G × G,	hps : p ∈ s,	hp : p ∈ s → ⇑f p.fst ≠ 0 → ⇑g p.snd = 0	⊢ ⇑f p.fst * ⇑g p.snd = 0
k : Type u₁,	G : Type u₂,	_inst_1 : semiring k,	_inst_2 : has_mul G,	f g : monoid_algebra k G,	x : G,	s : finset (G × G),	hs : ∀ {p : G × G}, p ∈ s ↔ p.fst * p.snd = x,	F : G × G → k := λ (p : G × G), ite (p.fst * p.snd = x) (⇑f p.fst * ⇑g p.snd) 0,	p : G × G,	hps : p ∈ s,	hp : p ∈ s → ⇑f p.fst ≠ 0 → ⇑g p.snd = 0,	h1 : ⇑f p.fst = 0	⊢ ⇑f p.fst * ⇑g p.snd = 0		k : Type u₁,	G : Type u₂,	_inst_1 : semiring k,	_inst_2 : has_mul G,	f g : monoid_algebra k G,	x : G,	s : finset (G × G),	hs : ∀ {p : G × G}, p ∈ s ↔ p.fst * p.snd = x,	F : G × G → k := λ (p : G × G), ite (p.fst * p.snd = x) (⇑f p.fst * ⇑g p.snd) 0,	p : G × G,	hps : p ∈ s,	hp : p ∈ s → ⇑f p.fst ≠ 0 → ⇑g p.snd = 0,	h1 : ¬⇑f p.fst = 0	⊢ ⇑f p.fst * ⇑g p.snd = 0
k : Type u₁,	G : Type u₂,	_inst_1 : semiring k,	_inst_2 : has_mul G,	f g : monoid_algebra k G,	x : G,	s : finset (G × G),	hs : ∀ {p : G × G}, p ∈ s ↔ p.fst * p.snd = x,	F : G × G → k := λ (p : G × G), ite (p.fst * p.snd = x) (⇑f p.fst * ⇑g p.snd) 0,	p : G × G,	hps : p ∈ s,	hp : p ∈ s → ⇑f p.fst ≠ 0 → ⇑g p.snd = 0,	h1 : ⇑f p.fst = 0	⊢ ⇑f p.fst * ⇑g p.snd = 0
k : Type u₁,	G : Type u₂,	_inst_1 : semiring k,	_inst_2 : has_mul G,	f g : monoid_algebra k G,	x : G,	s : finset (G × G),	hs : ∀ {p : G × G}, p ∈ s ↔ p.fst * p.snd = x,	F : G × G → k := λ (p : G × G), ite (p.fst * p.snd = x) (⇑f p.fst * ⇑g p.snd) 0,	p : G × G,	hps : p ∈ s,	hp : p ∈ s → ⇑f p.fst ≠ 0 → ⇑g p.snd = 0,	h1 : ¬⇑f p.fst = 0	⊢ ⇑f p.fst * ⇑g p.snd = 0
R : Type u_1,	S : Type u_2,	_inst_1 : ring R,	_inst_2 : linear_ordered_comm_ring S,	abv : absolute_value R S,	a : R,	ha : a = 0	⊢ ⇑abv (-a) = ⇑abv a
R : Type u_1,	S : Type u_2,	_inst_1 : ring R,	_inst_2 : linear_ordered_comm_ring S,	abv : absolute_value R S,	a : R,	ha : a = 0	⊢ ⇑abv (-a) = ⇑abv a		R : Type u_1,	S : Type u_2,	_inst_1 : ring R,	_inst_2 : linear_ordered_comm_ring S,	abv : absolute_value R S,	a : R,	ha : ¬a = 0	⊢ ⇑abv (-a) = ⇑abv a
R : Type u_1,	S : Type u_2,	_inst_1 : ring R,	_inst_2 : linear_ordered_comm_ring S,	abv : absolute_value R S,	a : R	⊢ ⇑abv (-a) = ⇑abv a
R : Type u_1,	S : Type u_2,	_inst_1 : ring R,	_inst_2 : linear_ordered_comm_ring S,	abv : absolute_value R S,	a : R,	ha : ¬a = 0	⊢ ⇑abv (-a) = ⇑abv a
R : Type u_1,	S : Type u_2,	_inst_1 : ring R,	_inst_2 : linear_ordered_comm_ring S,	abv : absolute_value R S,	a : R,	ha : ¬a = 0	⊢ ⇑abv (-a) * ⇑abv (-a) = ⇑abv a * ⇑abv a
R : Type u_1,	S : Type u_2,	_inst_1 : ring R,	_inst_2 : linear_ordered_comm_ring S,	abv : absolute_value R S,	a : R,	ha : ¬a = 0	⊢ ¬⇑abv (-a) = -⇑abv a
S : Type u_1,	_inst_1 : linear_ordered_field S,	R : Type u_2,	_inst_2 : ring R,	abv : R → S,	_inst_3 : is_absolute_value abv,	a b : R	⊢ abv (a - b) = abv (b - a)
α : Type u,	_inst_1 : has_lt α,	a b : α	⊢ ordering.lt.swap.compares a b ↔ ordering.lt.compares b a		case ordering.eq	α : Type u,	_inst_1 : has_lt α,	a b : α	⊢ ordering.eq.swap.compares a b ↔ ordering.eq.compares b a		case ordering.gt	α : Type u,	_inst_1 : has_lt α,	a b : α	⊢ ordering.gt.swap.compares a b ↔ ordering.gt.compares b a
α : Type u,	_inst_1 : has_lt α,	a b : α,	o : ordering	⊢ o.swap.compares a b ↔ o.compares b a
α : Type u_1,	_inst_1 : linear_ordered_field α,	a b c : α,	hc : 0 < c	⊢ a ≤ b / c ↔ c * a ≤ b
α : Type u_1,	_inst_1 : linear_ordered_field α,	a b c : α,	hc : 0 ≤ c,	h : a ≤ b	⊢ a / c ≤ b / c
α : Type u_1,	_inst_1 : linear_ordered_field α,	a b c : α,	hc : 0 ≤ c,	h : a ≤ b	⊢ a * (1 / c) ≤ b * (1 / c)
α : Type u_1,	_inst_1 : linear_ordered_field α,	a b : α	⊢ a / b < 1 ↔ 0 < b ∧ a < b ∨ b = 0 ∨ b < 0 ∧ b < a
α : Type u_1,	_inst_1 : linear_ordered_field α,	a b : α,	hb : b < 0	⊢ a / b < 1 ↔ 0 < b ∧ a < b ∨ b = 0 ∨ b < 0 ∧ b < a		α : Type u_1,	_inst_1 : linear_ordered_field α,	a : α	⊢ a / 0 < 1 ↔ 0 < 0 ∧ a < 0 ∨ 0 = 0 ∨ 0 < 0 ∧ 0 < a		α : Type u_1,	_inst_1 : linear_ordered_field α,	a b : α,	hb : 0 < b	⊢ a / b < 1 ↔ 0 < b ∧ a < b ∨ b = 0 ∨ b < 0 ∧ b < a
α : Type u_1,	_inst_1 : linear_ordered_field α,	a b : α,	hb : b < 0	⊢ a / b < 1 ↔ 0 < b ∧ a < b ∨ b = 0 ∨ b < 0 ∧ b < a
α : Type u_1,	_inst_1 : linear_ordered_field α,	a : α	⊢ a / 0 < 1 ↔ 0 < 0 ∧ a < 0 ∨ 0 = 0 ∨ 0 < 0 ∧ 0 < a		α : Type u_1,	_inst_1 : linear_ordered_field α,	a b : α,	hb : 0 < b	⊢ a / b < 1 ↔ 0 < b ∧ a < b ∨ b = 0 ∨ b < 0 ∧ b < a
α : Type u_1,	_inst_1 : linear_ordered_field α,	a : α	⊢ a / 0 < 1 ↔ 0 < 0 ∧ a < 0 ∨ 0 = 0 ∨ 0 < 0 ∧ 0 < a
α : Type u_1,	_inst_1 : linear_ordered_field α,	a b : α,	hb : 0 < b	⊢ a / b < 1 ↔ 0 < b ∧ a < b ∨ b = 0 ∨ b < 0 ∧ b < a
α : Type u_1,	_inst_1 : linear_ordered_field α,	a b : α,	ha : 0 < a,	h : a ≤ b	⊢ 1 / b ≤ 1 / a
α : Type u_1,	_inst_1 : linear_ordered_field α,	a : α,	this : a / 2 - (a / 2 + a / 2) = -(a / 2)	⊢ a / 2 - a = -(a / 2)
α : Type u_1,	_inst_1 : linear_ordered_field α,	a : α	⊢ a / 2 - (a / 2 + a / 2) = -(a / 2)
α : Type u,	_inst_1 : add_comm_group α,	_inst_2 : linear_order α,	_inst_3 : covariant_class α α has_add.add has_le.le,	a b : α,	hb : 0 ≤ b	⊢ abs a = b ↔ a = b ∨ a = -b
α : Type u,	_inst_1 : add_comm_group α,	_inst_2 : linear_order α,	_inst_3 : covariant_class α α has_add.add has_le.le,	a b : α,	hb : 0 ≤ b	⊢ a = b ∨ a = -b → abs a = b
α : Type u,	_inst_1 : add_comm_group α,	_inst_2 : linear_order α,	_inst_3 : covariant_class α α has_add.add has_le.le,	a : α,	hb : 0 ≤ a	⊢ abs a = a
α : Type u,	_inst_1 : add_comm_group α,	_inst_2 : linear_order α,	_inst_3 : covariant_class α α has_add.add has_le.le,	b : α,	hb : 0 ≤ b	⊢ abs (-b) = b
α : Type u,	_inst_1 : add_comm_group α,	_inst_2 : linear_order α,	_inst_3 : covariant_class α α has_add.add has_le.le,	a b : α,	hb : 0 ≤ b	⊢ a = b ∨ a = -b → abs a = b
α : Type u,	_inst_1 : group α,	_inst_2 : has_lt α,	_inst_3 : covariant_class α α (function.swap has_mul.mul) has_lt.lt,	a : α	⊢ 1 < a⁻¹ ↔ a < 1
α : Type u,	_inst_1 : comm_group α,	_inst_2 : has_le α,	_inst_3 : covariant_class α α has_mul.mul has_le.le,	a b c : α	⊢ a / b ≤ c ↔ a ≤ b * c
α : Type u_1,	_inst_3 : has_neg α,	_inst_4 : linear_order α,	a : α	⊢ abs a = linear_order.max a (-a)
α : Type u,	_inst_1 : add_monoid α	⊢ ∀ (a : with_top α), 0 + a = a
α : Type u,	_inst_1 : add_monoid α	⊢ 0 + ⊤ = ⊤		α : Type u,	_inst_1 : add_monoid α	⊢ ∀ (a : α), 0 + ↑a = ↑a
α : Type u,	_inst_1 : add_monoid α	⊢ 0 + ⊤ = ⊤
α : Type u,	_inst_1 : add_monoid α	⊢ ∀ (a : α), 0 + ↑a = ↑a
α : Type u,	_inst_1 : add_monoid α,	a : α	⊢ 0 + ↑a = ↑a
α : Type u,	_inst_1 : add_monoid α	⊢ ∀ (a : with_top α), a + 0 = a
α : Type u,	_inst_1 : add_monoid α	⊢ ⊤ + 0 = ⊤		α : Type u,	_inst_1 : add_monoid α	⊢ ∀ (a : α), ↑a + 0 = ↑a
α : Type u,	_inst_1 : add_monoid α	⊢ ⊤ + 0 = ⊤
α : Type u,	_inst_1 : add_monoid α	⊢ ∀ (a : α), ↑a + 0 = ↑a
α : Type u,	_inst_1 : add_monoid α,	a : α	⊢ ↑a + 0 = ↑a
α : Type u,	_inst_1 : linear_ordered_ring α,	a b : α	⊢ 0 ≤ a * b ↔ 0 ≤ a ∧ 0 ≤ b ∨ a ≤ 0 ∧ b ≤ 0
α : Type u,	_inst_1 : linear_ordered_ring α,	a b : α,	_inst : decidable_rel has_le.le	⊢ 0 ≤ a * b ↔ 0 ≤ a ∧ 0 ≤ b ∨ a ≤ 0 ∧ b ≤ 0
α : Type u,	_inst_1 : linear_ordered_ring α,	a b : α	⊢ 0 ≤ a * b ↔ 0 ≤ a ∧ 0 ≤ b ∨ a ≤ 0 ∧ b ≤ 0
α : Type u,	_inst_1 : linear_ordered_ring α,	a b : α	⊢ abs a ≤ abs b ↔ a * a ≤ b * b
α : Type u,	_inst_1 : linear_ordered_ring α,	a b : α	⊢ abs a ≤ abs b ↔ abs a * abs a ≤ abs b * abs b
α : Type u,	_inst_1 : ring α,	_inst_2 : linear_order α,	a b : α	⊢ a ∣ abs b ↔ a ∣ b
α : Type u,	_inst_1 : ring α,	_inst_2 : linear_order α,	a b : α,	h : abs b = b	⊢ a ∣ abs b ↔ a ∣ b
α : Type u,	_inst_1 : ring α,	_inst_2 : linear_order α,	a b : α,	h : abs b = -b	⊢ a ∣ abs b ↔ a ∣ b
α : Type u,	_inst_1 : ring α,	_inst_2 : linear_order α,	a b : α	⊢ a ∣ abs b ↔ a ∣ b
α : Type u,	_inst_1 : ordered_semiring α,	_inst_2 : decidable_rel has_le.le,	a b : α,	a2 : 2 ≤ a,	b0 : 0 ≤ b	⊢ a + (a + a * b) ≤ a * (2 + b)
α : Type u,	_inst_1 : linear_ordered_semiring α,	a b c : α,	h : c * a < c * b,	hc : 0 ≤ c	⊢ a < b
α : Type u,	_inst_1 : linear_ordered_semiring α,	a b c : α,	h : c * a < c * b,	hc : 0 ≤ c,	_inst : decidable_rel has_le.le	⊢ a < b
α : Type u,	_inst_1 : linear_ordered_semiring α,	a b c : α,	h : c * a < c * b,	hc : 0 ≤ c	⊢ a < b
α : Type u,	_inst_1 : linear_ordered_semiring α,	a b c : α,	h : a * c < b * c,	hc : 0 ≤ c	⊢ a < b
α : Type u,	_inst_1 : linear_ordered_semiring α,	a b c : α,	h : a * c < b * c,	hc : 0 ≤ c,	_inst : decidable_rel has_le.le	⊢ a < b
α : Type u,	_inst_1 : linear_ordered_semiring α,	a b c : α,	h : a * c < b * c,	hc : 0 ≤ c	⊢ a < b
α : Type u,	_inst_1 : linear_ordered_semiring α,	a b : α,	ha : 0 < a	⊢ 0 ≤ b * a ↔ 0 ≤ b
α : Type u,	_inst_1 : linear_ordered_semiring α,	a b : α,	ha : 0 < a,	_inst : decidable_rel has_le.le	⊢ 0 ≤ b * a ↔ 0 ≤ b
α : Type u,	_inst_1 : linear_ordered_semiring α,	a b : α,	ha : 0 < a	⊢ 0 ≤ b * a ↔ 0 ≤ b
α : Type u,	_inst_1 : ordered_ring α,	a b c : α	⊢ b ≤ a → c ≤ 0 → a * c ≤ b * c
α : Type u,	_inst_1 : ordered_ring α,	a b c : α,	_inst : Π (a : Prop), decidable a	⊢ b ≤ a → c ≤ 0 → a * c ≤ b * c
α : Type u,	_inst_1 : ordered_ring α,	a b c : α	⊢ b ≤ a → c ≤ 0 → a * c ≤ b * c
R : Type u_1,	M : Type u_2,	_inst_1 : ordered_semiring R,	_inst_2 : ordered_add_comm_monoid M,	_inst_3 : smul_with_zero R M,	_inst_4 : ordered_smul R M,	a b : M,	c : R,	h : c • a < c • b,	hc : 0 ≤ c,	hc : 0 = c	⊢ 0 < 0
α : Type u_1,	_inst_1 : canonically_ordered_add_monoid α,	_inst_2 : has_sub α,	_inst_3 : has_ordered_sub α,	a b c : α,	h : c ≤ b	⊢ a - c - (b - c) = a - b
α : Type u_1,	_inst_1 : canonically_ordered_add_monoid α,	_inst_2 : has_sub α,	_inst_3 : has_ordered_sub α,	a b c : α,	hc : add_le_cancellable c,	h : c ≤ b	⊢ a < b - c ↔ a + c < b
α : Type u_1,	_inst_1 : canonically_ordered_add_monoid α,	_inst_2 : has_sub α,	_inst_3 : has_ordered_sub α,	a b c : α,	hc : add_le_cancellable c,	h : c ≤ b	⊢ a < b - c ↔ c + a < b
α : Type u_1,	_inst_1 : canonically_linear_ordered_add_monoid α,	_inst_2 : has_sub α,	_inst_3 : has_ordered_sub α,	a b c : α,	hc : add_le_cancellable c,	h : c ≤ a	⊢ a - c < b - c ↔ a < b
α : Type u_1,	_inst_1 : canonically_linear_ordered_add_monoid α,	_inst_2 : has_sub α,	_inst_3 : has_ordered_sub α,	a b : α,	ha : add_le_cancellable a,	hb : add_le_cancellable b	⊢ a - b < a ↔ 0 < a ∧ 0 < b
α : Type u_1,	_inst_1 : canonically_linear_ordered_add_monoid α,	_inst_2 : has_sub α,	_inst_3 : has_ordered_sub α,	a b : α,	ha : add_le_cancellable a,	hb : add_le_cancellable b	⊢ a - b < a → 0 < a ∧ 0 < b
α : Type u_1,	_inst_1 : canonically_linear_ordered_add_monoid α,	_inst_2 : has_sub α,	_inst_3 : has_ordered_sub α,	a b : α,	ha : add_le_cancellable a,	hb : add_le_cancellable b,	h : a - b < a	⊢ 0 < a ∧ 0 < b
α : Type u_1,	_inst_1 : canonically_linear_ordered_add_monoid α,	_inst_2 : has_sub α,	_inst_3 : has_ordered_sub α,	a b : α,	ha : add_le_cancellable a,	hb : add_le_cancellable b,	h : a - b < a	⊢ 0 ≠ b
α : Type u_1,	_inst_1 : canonically_linear_ordered_add_monoid α,	_inst_2 : has_sub α,	_inst_3 : has_ordered_sub α,	a : α,	ha : add_le_cancellable a,	hb : add_le_cancellable 0,	h : a - 0 < a	⊢ false
α : Type u_1,	_inst_1 : canonically_linear_ordered_add_monoid α,	_inst_2 : has_sub α,	_inst_3 : has_ordered_sub α,	a : α,	ha : add_le_cancellable a,	hb : add_le_cancellable 0,	h : a < a	⊢ false
α : Type u_1,	_inst_1 : canonically_linear_ordered_add_monoid α,	_inst_2 : has_sub α,	_inst_3 : has_ordered_sub α,	a b : α	⊢ linear_order.min a b ≤ a
α : Type u_1,	_inst_1 : canonically_linear_ordered_add_monoid α,	_inst_2 : has_sub α,	_inst_3 : has_ordered_sub α,	a b : α	⊢ a - b + linear_order.min a b = a
R : Type u,	ι : Type w,	s : finset ι,	_inst_1 : comm_semiring R,	f : ι → polynomial R,	h : ∏ (i : ι) in s, (f i).leading_coeff ≠ 0	⊢ (∏ (i : ι) in s, f i).leading_coeff = ∏ (i : ι) in s, (f i).leading_coeff
R : Type u,	ι : Type w,	s : finset ι,	_inst_1 : comm_semiring R,	f : ι → polynomial R,	h : ∏ (i : ι) in s, (f i).leading_coeff ≠ 0	⊢ (multiset.map polynomial.leading_coeff (multiset.map f s.val)).prod ≠ 0
⊢ canonically_ordered_add_monoid punit
⊢ canonically_ordered_add_monoid punit
⊢ canonically_ordered_add_monoid punit
⊢ ∀ (a b : punit), a ≤ b → ∀ (c : punit), c + a ≤ c + b
_x _x : punit	⊢ _x ≤ _x
a b : punit,	ᾰ : a ≤ b,	c : punit	⊢ c + a ≤ c + b
_x _x : punit	⊢ _x ≤ _x
R : Type u_1,	_inst_1 : rack R,	x y y' : R	⊢ x ◃⁻¹ y = x ◃⁻¹ y' → y = y'		R : Type u_1,	_inst_1 : rack R,	x y y' : R	⊢ y = y' → x ◃⁻¹ y = x ◃⁻¹ y'
R : Type u_1,	_inst_1 : rack R,	x y y' : R	⊢ y = y' → x ◃⁻¹ y = x ◃⁻¹ y'
R : Type u_1,	_inst_1 : rack R,	x y : R	⊢ x ◃⁻¹ y = x ◃⁻¹ y
R : Type u_1,	_inst_1 : rack R,	x y y' : R	⊢ x ◃⁻¹ y = x ◃⁻¹ y' ↔ y = y'
Q : Type u_1,	_inst_1 : quandle Q,	x : Qᵒᵖ	⊢ x ◃ x = x
Q : Type u_1,	_inst_1 : quandle Q,	x : Q	⊢ opposite.op x ◃ opposite.op x = opposite.op x
R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R,	a b : ℍ[R,c₁,c₂]	⊢ ⇑quaternion_algebra.conj (a * b) = ⇑quaternion_algebra.conj b * ⇑quaternion_algebra.conj a
R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R,	a b : ℍ[R,c₁,c₂]	⊢ ⇑quaternion_algebra.conj (a * b) = ⇑quaternion_algebra.conj b * ⇑quaternion_algebra.conj a
R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R,	a b : ℍ[R,c₁,c₂]	⊢ ⇑quaternion_algebra.conj (a * b) = ⇑quaternion_algebra.conj b * ⇑quaternion_algebra.conj a
R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R,	a b : ℍ[R,c₁,c₂]	⊢ (⇑quaternion_algebra.conj (a * b)).re = (⇑quaternion_algebra.conj b * ⇑quaternion_algebra.conj a).re
R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R,	a b : ℍ[R,c₁,c₂]	⊢ (⇑quaternion_algebra.conj (a * b)).im_i = (⇑quaternion_algebra.conj b * ⇑quaternion_algebra.conj a).im_i
R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R,	a b : ℍ[R,c₁,c₂]	⊢ (⇑quaternion_algebra.conj (a * b)).im_j = (⇑quaternion_algebra.conj b * ⇑quaternion_algebra.conj a).im_j
R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R,	a b : ℍ[R,c₁,c₂]	⊢ (⇑quaternion_algebra.conj (a * b)).im_k = (⇑quaternion_algebra.conj b * ⇑quaternion_algebra.conj a).im_k
R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R,	a b : ℍ[R,c₁,c₂]	⊢ a.re * b.re + c₁ * a.im_i * b.im_i + c₂ * a.im_j * b.im_j - c₁ * c₂ * a.im_k * b.im_k = b.re * a.re + c₁ * b.im_i * a.im_i + c₂ * b.im_j * a.im_j - c₁ * c₂ * b.im_k * a.im_k
R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R,	a b : ℍ[R,c₁,c₂]	⊢ -(c₂ * a.im_k * b.im_j) + (c₂ * a.im_j * b.im_k - (a.re * b.im_i + a.im_i * b.re)) = -(b.re * a.im_i) + -(b.im_i * a.re) - c₂ * b.im_j * a.im_k + c₂ * b.im_k * a.im_j
R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R,	a b : ℍ[R,c₁,c₂]	⊢ c₁ * a.im_k * b.im_i - (a.re * b.im_j + c₁ * a.im_i * b.im_k + a.im_j * b.re) = -(b.re * a.im_j) + c₁ * b.im_i * a.im_k + -(b.im_j * a.re) - c₁ * b.im_k * a.im_i
R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R,	a b : ℍ[R,c₁,c₂]	⊢ -(a.im_k * b.re) + (a.im_j * b.im_i - (a.re * b.im_k + a.im_i * b.im_j)) = -(b.re * a.im_k) + b.im_i * a.im_j - b.im_j * a.im_i + -(b.im_k * a.re)
R : Type u_1,	_inst_1 : linear_ordered_comm_ring R,	a : ℍ[R]	⊢ ⇑quaternion.norm_sq a ≤ 0 ↔ a = 0
R : Type u_1,	A : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : ring A,	_inst_4 : algebra R A,	c₁ c₂ : R,	q : quaternion_algebra.basis A c₁ c₂,	x y : ℍ[R,c₁,c₂]	⊢ q.lift (x * y) = q.lift x * q.lift y
R : Type u_1,	A : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : ring A,	_inst_4 : algebra R A,	c₁ c₂ : R,	q : quaternion_algebra.basis A c₁ c₂,	x y : ℍ[R,c₁,c₂]	⊢ (x * y).re • 1 + (x * y).im_i • q.i + (x * y).im_j • q.j + (x * y).im_k • q.k = (x.re • 1 + x.im_i • q.i + x.im_j • q.j + x.im_k • q.k) * (y.re • 1 + y.im_i • q.i + y.im_j • q.j + y.im_k • q.k)
R : Type u_1,	A : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : ring A,	_inst_4 : algebra R A,	c₁ c₂ : R,	q : quaternion_algebra.basis A c₁ c₂,	x y : ℍ[R,c₁,c₂]	⊢ (x * y).re • 1 + (x * y).im_i • q.i + (x * y).im_j • q.j + (x * y).im_k • q.k = x.re • 1 * (y.re • 1 + y.im_i • q.i + y.im_j • q.j + y.im_k • q.k) + x.im_i • q.i * (y.re • 1 + y.im_i • q.i + y.im_j • q.j + y.im_k • q.k) + x.im_j • q.j * (y.re • 1 + y.im_i • q.i + y.im_j • q.j + y.im_k • q.k) + x.im_k • q.k * (y.re • 1 + y.im_i • q.i + y.im_j • q.j + y.im_k • q.k)
R : Type u_1,	A : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : ring A,	_inst_4 : algebra R A,	c₁ c₂ : R,	q : quaternion_algebra.basis A c₁ c₂,	x y : ℍ[R,c₁,c₂]	⊢ (x * y).re • 1 + (x * y).im_i • q.i + (x * y).im_j • q.j + (x * y).im_k • q.k = (x.re * y.re) • 1 + (x.re * y.im_i) • q.i + (x.re * y.im_j) • q.j + (x.re * y.im_k) • q.k + ((x.im_i * y.re) • q.i + (x.im_i * y.im_i) • (q.i * q.i) + (x.im_i * y.im_j) • (q.i * q.j) + (x.im_i * y.im_k) • (q.i * q.k)) + ((x.im_j * y.re) • q.j + (x.im_j * y.im_i) • (q.j * q.i) + (x.im_j * y.im_j) • (q.j * q.j) + (x.im_j * y.im_k) • (q.j * q.k)) + ((x.im_k * y.re) • q.k + (x.im_k * y.im_i) • (q.k * q.i) + (x.im_k * y.im_j) • (q.k * q.j) + (x.im_k * y.im_k) • (q.k * q.k))
R : Type u_1,	A : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : ring A,	_inst_4 : algebra R A,	c₁ c₂ : R,	q : quaternion_algebra.basis A c₁ c₂,	x y : ℍ[R,c₁,c₂]	⊢ (x * y).re • 1 + (x * y).im_i • q.i + (x * y).im_j • q.j + (x * y).im_k • q.k = (x.re * y.re) • 1 + (x.re * y.im_i) • q.i + (x.re * y.im_j) • q.j + (x.re * y.im_k) • q.k + ((x.im_i * y.re) • q.i + (x.im_i * y.im_i) • c₁ • 1 + (x.im_i * y.im_j) • q.k + (x.im_i * y.im_k) • c₁ • q.j) + ((x.im_j * y.re) • q.j + (x.im_j * y.im_i) • -q.k + (x.im_j * y.im_j) • c₂ • 1 + (x.im_j * y.im_k) • -c₂ • q.i) + ((x.im_k * y.re) • q.k + (x.im_k * y.im_i) • -c₁ • q.j + (x.im_k * y.im_j) • c₂ • q.i + (x.im_k * y.im_k) • -((c₁ * c₂) • 1))
R : Type u_1,	A : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : ring A,	_inst_4 : algebra R A,	c₁ c₂ : R,	q : quaternion_algebra.basis A c₁ c₂,	x y : ℍ[R,c₁,c₂]	⊢ (x * y).re • 1 + (x * y).im_i • q.i + (x * y).im_j • q.j + (x * y).im_k • q.k = (x.re * y.re) • 1 + (x.re * y.im_i) • q.i + (x.re * y.im_j) • q.j + (x.re * y.im_k) • q.k + (x.im_i * y.re) • q.i + (x.im_i * y.im_i * c₁) • 1 + (x.im_i * y.im_j) • q.k + (x.im_i * y.im_k * c₁) • q.j + (x.im_j * y.re) • q.j + -((x.im_j * y.im_i) • q.k) + (x.im_j * y.im_j * c₂) • 1 + -((x.im_j * y.im_k * c₂) • q.i) + (x.im_k * y.re) • q.k + -((x.im_k * y.im_i * c₁) • q.j) + (x.im_k * y.im_j * c₂) • q.i + -((x.im_k * y.im_k * (c₁ * c₂)) • 1)
R : Type u_1,	A : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : ring A,	_inst_4 : algebra R A,	c₁ c₂ : R,	q : quaternion_algebra.basis A c₁ c₂,	x y : ℍ[R,c₁,c₂]	⊢ (x * y).re • 1 + (x * y).im_i • q.i + (x * y).im_j • q.j + (x * y).im_k • q.k = (x.re * y.re) • 1 + (x.re * y.im_i) • q.i + (x.re * y.im_j) • q.j + (x.re * y.im_k) • q.k + (x.im_i * y.re) • q.i + (x.im_i * y.im_i * c₁) • 1 + (x.im_i * y.im_j) • q.k + (x.im_i * y.im_k * c₁) • q.j + (x.im_j * y.re) • q.j + -((x.im_j * y.im_i) • q.k) + (x.im_j * y.im_j * c₂) • 1 + -((x.im_j * y.im_k * c₂) • q.i) + (x.im_k * y.re) • q.k + -((x.im_k * y.im_i * c₁) • q.j) + (x.im_k * y.im_j * c₂) • q.i + -((c₁ * c₂ * (x.im_k * y.im_k)) • 1)
R : Type u_1,	A : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : ring A,	_inst_4 : algebra R A,	c₁ c₂ : R,	q : quaternion_algebra.basis A c₁ c₂,	x y : ℍ[R,c₁,c₂]	⊢ (x * y).re • 1 + (x * y).im_i • q.i + (x * y).im_j • q.j + (x * y).im_k • q.k = (x.re * y.re) • 1 + (x.re * y.im_i) • q.i + (x.re * y.im_j) • q.j + (x.re * y.im_k) • q.k + (x.im_i * y.re) • q.i + (c₁ * x.im_i * y.im_i) • 1 + (x.im_i * y.im_j) • q.k + (c₁ * x.im_i * y.im_k) • q.j + (x.im_j * y.re) • q.j + -((x.im_j * y.im_i) • q.k) + (x.im_j * y.im_j * c₂) • 1 + -((x.im_j * y.im_k * c₂) • q.i) + (x.im_k * y.re) • q.k + -((c₁ * x.im_k * y.im_i) • q.j) + (x.im_k * y.im_j * c₂) • q.i + -((c₁ * c₂ * (x.im_k * y.im_k)) • 1)
R : Type u_1,	A : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : ring A,	_inst_4 : algebra R A,	c₁ c₂ : R,	q : quaternion_algebra.basis A c₁ c₂,	x y : ℍ[R,c₁,c₂]	⊢ (x * y).re • 1 + (x * y).im_i • q.i + (x * y).im_j • q.j + (x * y).im_k • q.k = (x.re * y.re) • 1 + (x.re * y.im_i) • q.i + (x.re * y.im_j) • q.j + (x.re * y.im_k) • q.k + (x.im_i * y.re) • q.i + (c₁ * x.im_i * y.im_i) • 1 + (x.im_i * y.im_j) • q.k + (c₁ * x.im_i * y.im_k) • q.j + (x.im_j * y.re) • q.j + -((x.im_j * y.im_i) • q.k) + (c₂ * x.im_j * y.im_j) • 1 + -((c₂ * x.im_j * y.im_k) • q.i) + (x.im_k * y.re) • q.k + -((c₁ * x.im_k * y.im_i) • q.j) + (c₂ * x.im_k * y.im_j) • q.i + -((c₂ * c₁ * (x.im_k * y.im_k)) • 1)
R : Type u_1,	A : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : ring A,	_inst_4 : algebra R A,	c₁ c₂ : R,	q : quaternion_algebra.basis A c₁ c₂,	x y : ℍ[R,c₁,c₂]	⊢ (x * y).re • 1 + (x * y).im_i • q.i + (x * y).im_j • q.j + (x * y).im_k • q.k = (x.re * y.re) • 1 + (x.re * y.im_i) • q.i + (x.re * y.im_j) • q.j + (x.re * y.im_k) • q.k + (x.im_i * y.re) • q.i + (c₁ * x.im_i * y.im_i) • 1 + (x.im_i * y.im_j) • q.k + (c₁ * x.im_i * y.im_k) • q.j + (x.im_j * y.re) • q.j + -((x.im_j * y.im_i) • q.k) + (c₂ * x.im_j * y.im_j) • 1 + -((c₂ * x.im_j * y.im_k) • q.i) + (x.im_k * y.re) • q.k + -((c₁ * x.im_k * y.im_i) • q.j) + (c₂ * x.im_k * y.im_j) • q.i + -((c₁ * c₂ * x.im_k * y.im_k) • 1)
R : Type u_1,	A : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : ring A,	_inst_4 : algebra R A,	c₁ c₂ : R,	q : quaternion_algebra.basis A c₁ c₂,	x y : ℍ[R,c₁,c₂]	⊢ (x.re * y.re) • 1 + (c₁ * x.im_i * y.im_i) • 1 + (c₂ * x.im_j * y.im_j) • 1 + -((c₁ * c₂ * x.im_k * y.im_k) • 1) + (x.re * y.im_i) • q.i + (x.im_i * y.re) • q.i + -((c₂ * x.im_j * y.im_k) • q.i) + (c₂ * x.im_k * y.im_j) • q.i + (x.re * y.im_j) • q.j + (c₁ * x.im_i * y.im_k) • q.j + (x.im_j * y.re) • q.j + -((c₁ * x.im_k * y.im_i) • q.j) + (x.re * y.im_k) • q.k + (x.im_i * y.im_j) • q.k + -((x.im_j * y.im_i) • q.k) + (x.im_k * y.re) • q.k = (x.re * y.re) • 1 + (x.re * y.im_i) • q.i + (x.re * y.im_j) • q.j + (x.re * y.im_k) • q.k + (x.im_i * y.re) • q.i + (c₁ * x.im_i * y.im_i) • 1 + (x.im_i * y.im_j) • q.k + (c₁ * x.im_i * y.im_k) • q.j + (x.im_j * y.re) • q.j + -((x.im_j * y.im_i) • q.k) + (c₂ * x.im_j * y.im_j) • 1 + -((c₂ * x.im_j * y.im_k) • q.i) + (x.im_k * y.re) • q.k + -((c₁ * x.im_k * y.im_i) • q.j) + (c₂ * x.im_k * y.im_j) • q.i + -((c₁ * c₂ * x.im_k * y.im_k) • 1)
R : Type x,	_inst_1 : distrib R,	a b x y : R,	ha : semiconj_by a x y,	hb : semiconj_by b x y	⊢ semiconj_by (a + b) x y
R : Type x,	_inst_1 : ring R,	a x y : R,	h : semiconj_by a x y	⊢ semiconj_by (-a) x y
α : Type u_1,	_inst_2 : mul_zero_class α,	P : Prop,	_inst_3 : decidable P,	a b : α	⊢ ite P (a * b) 0 = ite P a 0 * b
α : Type u_1,	_inst_2 : mul_zero_class α,	P : Prop,	_inst_3 : decidable P,	a b : α,	h : P	⊢ ite P (a * b) 0 = ite P a 0 * b
α : Type u_1,	_inst_2 : mul_zero_class α,	P : Prop,	_inst_3 : decidable P,	a b : α,	h : ¬P	⊢ ite P (a * b) 0 = ite P a 0 * b
α : Type u_1,	_inst_2 : mul_zero_class α,	P : Prop,	_inst_3 : decidable P,	a b : α	⊢ ite P (a * b) 0 = ite P a 0 * b
α : Type u,	_inst_1 : semiring α,	a : α	⊢ bit1 a = 2 * a + 1
α : Type u,	_inst_1 : ring α,	a b c : α	⊢ (a - b) * c = a * c - b * c
α : Type u_1,	_inst_1 : boolean_ring α,	a : α	⊢ a * (1 + a) = 0
α : Type u_1,	_inst_1 : boolean_ring α,	a b : α	⊢ a * b = b * a
R : Type u_1,	S : Type u_3,	_inst_1 : non_assoc_semiring R,	_inst_2 : non_assoc_semiring S,	_inst_3 : subsingleton S	⊢ ∀ (x y : R), (x + y, 0) = (x, 0) + (y, 0)
R : Type u_1,	S : Type u_3,	_inst_1 : non_assoc_semiring R,	_inst_2 : non_assoc_semiring S,	_inst_3 : subsingleton S	⊢ ∀ (x y : R), (x * y, 0) = (x, 0) * (y, 0)
R : Type u_1,	S : Type u_3,	_inst_1 : non_assoc_semiring R,	_inst_2 : non_assoc_semiring S,	_inst_3 : subsingleton S,	x : R × S	⊢ (λ (x : R), (x, 0)) x.fst = x
R : Type u_1,	S : Type u_3,	_inst_1 : non_assoc_semiring R,	_inst_2 : non_assoc_semiring S,	_inst_3 : subsingleton S,	x : R × S	⊢ (λ (x : R), (x, 0)) x.fst = x
R : Type u_1,	S : Type u_3,	_inst_1 : non_assoc_semiring R,	_inst_2 : non_assoc_semiring S,	_inst_3 : subsingleton S,	x_fst : R,	x_snd : S	⊢ (λ (x : R), (x, 0)) (x_fst, x_snd).fst = (x_fst, x_snd)
R : Type u₁,	_inst_1 : semiring R,	T : Type u₄,	_inst_5 : semiring T,	r : R → R → Prop,	f : ring_quot r →+* T,	x y : R,	h : ?m_1 x y	⊢ ⇑(f.comp (ring_quot.mk_ring_hom r)) x = ⇑(f.comp (ring_quot.mk_ring_hom r)) y
R : Type u₁,	_inst_1 : semiring R,	T : Type u₄,	_inst_5 : semiring T,	r : R → R → Prop,	f : ring_quot r →+* T,	x y : R,	h : ?m_1 x y	⊢ ⇑f (⇑(ring_quot.mk_ring_hom r) x) = ⇑f (⇑(ring_quot.mk_ring_hom r) y)
A : Type u_1,	B : Type u_2,	_inst_1 : decidable_eq A,	_inst_2 : has_zero B,	a : A,	b : B	⊢ function.support (pi.single a b) ⊆ {a}
A : Type u_1,	B : Type u_2,	_inst_1 : decidable_eq A,	_inst_2 : has_zero B,	a : A,	b : B,	_inst : Π (a : Prop), decidable a	⊢ function.support (pi.single a b) ⊆ {a}
A : Type u_1,	B : Type u_2,	_inst_1 : decidable_eq A,	_inst_2 : has_zero B,	a : A,	b : B,	_inst : Π (a : Prop), decidable a	⊢ ite (b = 0) ∅ {a} ⊆ {a}
A : Type u_1,	B : Type u_2,	_inst_1 : decidable_eq A,	_inst_2 : has_zero B,	a : A,	b : B,	_inst : Π (a : Prop), decidable a,	h : b = 0	⊢ ∅ ⊆ {a}
A : Type u_1,	B : Type u_2,	_inst_1 : decidable_eq A,	_inst_2 : has_zero B,	a : A,	b : B,	_inst : Π (a : Prop), decidable a,	h : ¬b = 0	⊢ {a} ⊆ {a}
A : Type u_1,	B : Type u_2,	_inst_1 : decidable_eq A,	_inst_2 : has_zero B,	a : A,	b : B,	_inst : Π (a : Prop), decidable a	⊢ ite (b = 0) ∅ {a} ⊆ {a}
R : Type u,	_inst_1 : linear_order R,	x y : tropical R,	h : x ≤ y	⊢ tropical.untrop (x + y) = tropical.untrop x
R : Type u,	_inst_1 : linear_order R,	_inst_2 : add_monoid R,	_inst_3 : covariant_class R R has_add.add has_le.le,	_inst_4 : covariant_class R R (function.swap has_add.add) has_le.le,	x y : tropical R,	n : ℕ	⊢ (x + y) ^ n = x ^ n + y ^ n
R : Type u,	_inst_1 : linear_order R,	_inst_2 : add_monoid R,	_inst_3 : covariant_class R R has_add.add has_le.le,	_inst_4 : covariant_class R R (function.swap has_add.add) has_le.le,	x y : tropical R,	n : ℕ,	h : x ≤ y	⊢ (x + y) ^ n = x ^ n + y ^ n
R : Type u,	_inst_1 : linear_order R,	_inst_2 : add_monoid R,	_inst_3 : covariant_class R R has_add.add has_le.le,	_inst_4 : covariant_class R R (function.swap has_add.add) has_le.le,	x y : tropical R,	n : ℕ,	h : x ≤ y	⊢ (x + y) ^ n = x ^ n + y ^ n		case or.inr	R : Type u,	_inst_1 : linear_order R,	_inst_2 : add_monoid R,	_inst_3 : covariant_class R R has_add.add has_le.le,	_inst_4 : covariant_class R R (function.swap has_add.add) has_le.le,	x y : tropical R,	n : ℕ,	h : y ≤ x	⊢ (x + y) ^ n = x ^ n + y ^ n
R : Type u,	_inst_1 : linear_order R,	_inst_2 : add_monoid R,	_inst_3 : covariant_class R R has_add.add has_le.le,	_inst_4 : covariant_class R R (function.swap has_add.add) has_le.le,	x y : tropical R,	n : ℕ,	h : y ≤ x	⊢ (x + y) ^ n = x ^ n + y ^ n
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.limits.has_colimits C,	U : Top,	X : algebraic_geometry.PresheafedSpace C,	f : U ⟶ ↑X,	h : open_embedding ⇑f,	V : topological_space.opens ↥U,	x : ↥U,	hx : x ∈ V	⊢ X.presheaf.germ ⟨⇑f x, _⟩ ≫ (X.restrict_stalk_iso f h x).inv = (X.restrict f h).presheaf.germ ⟨x, hx⟩
C : Type u,	_inst_1 : category_theory.category C,	X : category_theory.cosimplicial_object C,	X₀ : C,	f : X₀ ⟶ X.obj [0],	w : ∀ (i : simplex_category) (g₁ g₂ : [0] ⟶ i), f ≫ X.map g₁ = f ≫ X.map g₂	⊢ f ≫ X.map ([0].const 0) = f
C : Type u,	_inst_1 : category_theory.category C,	X : category_theory.cosimplicial_object C,	X₀ : C,	f : X₀ ⟶ X.obj [0],	w : ∀ (i : simplex_category) (g₁ g₂ : [0] ⟶ i), f ≫ X.map g₁ = f ≫ X.map g₂	⊢ (X.augment X₀ f w).hom.app [0] = f
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	p : formal_multilinear_series 𝕜 E F,	k l : ℕ	⊢ ∑ (a : {s // s.card = l}), ∥p.change_origin_series_term k l ↑a _∥₊ = ∑' (x : {s // s.card = l}), ∥p (k + l)∥₊
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	p : formal_multilinear_series 𝕜 E F,	i : E ≃L[𝕜] F	⊢ p.right_inv i 0 = 0
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	p : formal_multilinear_series 𝕜 E F,	i : E ≃L[𝕜] F,	hn : 2 ≤ 0	⊢ p.right_inv i 0 = -↑(i.symm).comp_continuous_multilinear_map (∑ (c : composition 0) in {c : composition 0 | 1 < c.length}.to_finset, p.comp_along_composition (p.right_inv i) c)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	p : formal_multilinear_series 𝕜 E F,	i : E ≃L[𝕜] F,	n : ℕ,	hn : 2 ≤ n	⊢ p.right_inv i n = -↑(i.symm).comp_continuous_multilinear_map (∑ (c : composition n) in {c : composition n | 1 < c.length}.to_finset, p.comp_along_composition (p.right_inv i) c)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	p : formal_multilinear_series 𝕜 E F,	i : E ≃L[𝕜] F,	hn : 2 ≤ 0	⊢ p.right_inv i 0 = -↑(i.symm).comp_continuous_multilinear_map (∑ (c : composition 0) in {c : composition 0 | 1 < c.length}.to_finset, p.comp_along_composition (p.right_inv i) c)		case nat.succ	𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	p : formal_multilinear_series 𝕜 E F,	i : E ≃L[𝕜] F,	n : ℕ,	hn : 2 ≤ n.succ	⊢ p.right_inv i n.succ = -↑(i.symm).comp_continuous_multilinear_map (∑ (c : composition n.succ) in {c : composition n.succ | 1 < c.length}.to_finset, p.comp_along_composition (p.right_inv i) c)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	p : formal_multilinear_series 𝕜 E F,	i : E ≃L[𝕜] F,	hn : 2 ≤ 1	⊢ p.right_inv i 1 = -↑(i.symm).comp_continuous_multilinear_map (∑ (c : composition 1) in {c : composition 1 | 1 < c.length}.to_finset, p.comp_along_composition (p.right_inv i) c)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	p : formal_multilinear_series 𝕜 E F,	i : E ≃L[𝕜] F,	n : ℕ,	hn : 2 ≤ n.succ	⊢ p.right_inv i n.succ = -↑(i.symm).comp_continuous_multilinear_map (∑ (c : composition n.succ) in {c : composition n.succ | 1 < c.length}.to_finset, p.comp_along_composition (p.right_inv i) c)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	p : formal_multilinear_series 𝕜 E F,	i : E ≃L[𝕜] F,	hn : 2 ≤ 1	⊢ p.right_inv i 1 = -↑(i.symm).comp_continuous_multilinear_map (∑ (c : composition 1) in {c : composition 1 | 1 < c.length}.to_finset, p.comp_along_composition (p.right_inv i) c)		case nat.succ, nat.succ	𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	p : formal_multilinear_series 𝕜 E F,	i : E ≃L[𝕜] F,	n : ℕ,	hn : 2 ≤ n.succ.succ	⊢ p.right_inv i n.succ.succ = -↑(i.symm).comp_continuous_multilinear_map (∑ (c : composition n.succ.succ) in {c : composition n.succ.succ | 1 < c.length}.to_finset, p.comp_along_composition (p.right_inv i) c)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	p : formal_multilinear_series 𝕜 E F,	i : E ≃L[𝕜] F,	n : ℕ,	hn : 2 ≤ n.succ.succ	⊢ p.right_inv i n.succ.succ = -↑(i.symm).comp_continuous_multilinear_map (∑ (c : composition n.succ.succ) in {c : composition n.succ.succ | 1 < c.length}.to_finset, p.comp_along_composition (p.right_inv i) c)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	p : formal_multilinear_series 𝕜 E F,	i : E ≃L[𝕜] F,	n : ℕ,	hn : 2 ≤ n.succ.succ	⊢ ↑(i.symm).comp_continuous_multilinear_map (p.comp (λ (k : ℕ), ite (k < n + 2) (p.right_inv i k) 0) (n + 2)) = ↑(i.symm).comp_continuous_multilinear_map ({c : composition n.succ.succ | 1 < c.length}.to_finset.sum (p.comp_along_composition (p.right_inv i)))
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	p : formal_multilinear_series 𝕜 E F,	i : E ≃L[𝕜] F,	n : ℕ,	hn : 2 ≤ n.succ.succ	⊢ p.comp (λ (k : ℕ), ite (k < n + 2) (p.right_inv i k) 0) (n + 2) = {c : composition n.succ.succ | 1 < c.length}.to_finset.sum (p.comp_along_composition (p.right_inv i))
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	p : formal_multilinear_series 𝕜 E F,	i : E ≃L[𝕜] F,	n : ℕ,	hn : 2 ≤ n.succ.succ,	v : fin (n + 2) → F	⊢ 0 < n + 2
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	p : formal_multilinear_series 𝕜 E F,	i : E ≃L[𝕜] F,	n : ℕ,	hn : 2 ≤ n.succ.succ,	v : fin (n + 2) → F	⊢ ⇑(p.comp (λ (k : ℕ), ite (k < n + 2) (p.right_inv i k) 0) (n + 2)) v = ⇑({c : composition n.succ.succ | 1 < c.length}.to_finset.sum (p.comp_along_composition (p.right_inv i))) v
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	p : formal_multilinear_series 𝕜 E F,	i : E ≃L[𝕜] F,	n : ℕ,	hn : 2 ≤ n.succ.succ,	v : fin (n + 2) → F,	N : 0 < n + 2	⊢ ⇑(p.comp (λ (k : ℕ), ite (k < n + 2) (p.right_inv i k) 0) (n + 2)) v = ⇑({c : composition n.succ.succ | 1 < c.length}.to_finset.sum (p.comp_along_composition (p.right_inv i))) v
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	p : formal_multilinear_series 𝕜 E F,	i : E ≃L[𝕜] F,	n : ℕ,	hn : 2 ≤ n.succ.succ,	v : fin (n + 2) → F,	N : 0 < n + 2,	this : ⇑(p 1) (λ (i : fin 1), 0) = 0	⊢ ⇑(p.comp (λ (k : ℕ), ite (k < n + 2) (p.right_inv i k) 0) (n + 2)) v = ⇑({c : composition n.succ.succ | 1 < c.length}.to_finset.sum (p.comp_along_composition (p.right_inv i))) v
α : Type u_1,	β : Type u_2,	_inst_1 : normed_group β,	u : α → β,	l : filter α,	c : β,	h : c ≠ 0	⊢ u ~[l] function.const α c ↔ filter.tendsto u l (𝓝 c)
α : Type u_1,	β : Type u_2,	_inst_1 : normed_group β,	u : α → β,	l : filter α,	c : β,	h : c ≠ 0	⊢ filter.tendsto (u - function.const α c) l (𝓝 0) → filter.tendsto u l (𝓝 c)
α : Type u_1,	β : Type u_2,	_inst_1 : normed_group β,	u : α → β,	l : filter α,	c : β,	h : c ≠ 0	⊢ filter.tendsto u l (𝓝 c) → filter.tendsto (u - function.const α c) l (𝓝 0)
α : Type u_1,	β : Type u_2,	_inst_1 : normed_group β,	u : α → β,	l : filter α,	c : β,	h : c ≠ 0	⊢ filter.tendsto (u - function.const α c) l (𝓝 0) ↔ filter.tendsto u l (𝓝 c)
α : Type u_1,	β : Type u_2,	_inst_1 : normed_group β,	u : α → β,	l : filter α,	c : β,	h : c ≠ 0	⊢ filter.tendsto (u - function.const α c) l (𝓝 0) ↔ filter.tendsto u l (𝓝 c)
α : Type u_1,	β : Type u_2,	_inst_1 : normed_group β,	u : α → β,	l : filter α,	c : β,	h : c ≠ 0	⊢ filter.tendsto (u - function.const α c) l (𝓝 0) ↔ filter.tendsto u l (𝓝 c)
α : Type u_1,	β : Type u_2,	_inst_1 : normed_group β,	u : α → β,	l : filter α,	c : β,	h : c ≠ 0	⊢ filter.tendsto (u - function.const α c) l (𝓝 0) ↔ filter.tendsto u l (𝓝 c)
α : Type u_1,	β : Type u_2,	_inst_1 : normed_group β,	u : α → β,	l : filter α,	c : β,	h : c ≠ 0	⊢ filter.tendsto (u - function.const α c) l (𝓝 0) ↔ filter.tendsto u l (𝓝 c)
α : Type u_1,	β : Type u_2,	_inst_1 : normed_group β,	u : α → β,	l : filter α,	c : β,	h : c ≠ 0	⊢ filter.tendsto (u - function.const α c) l (𝓝 0) ↔ filter.tendsto u l (𝓝 c)
α : Type u_1,	β : Type u_2,	_inst_1 : normed_group β,	u : α → β,	l : filter α,	c : β,	h : c ≠ 0,	h : filter.tendsto (u - function.const α c) l (𝓝 0),	this : filter.tendsto (λ (x : α), (u - function.const α c) x - (λ (b : α), ?m_1) x) l (𝓝 (0 - ?m_1))	⊢ filter.tendsto u l (𝓝 c)		α : Type u_1,	β : Type u_2,	_inst_1 : normed_group β,	u : α → β,	l : filter α,	c : β,	h : c ≠ 0,	h : filter.tendsto (u - function.const α c) l (𝓝 0)	⊢ β
α : Type u_1,	β : Type u_2,	_inst_1 : normed_group β,	u : α → β,	l : filter α,	c : β,	h : c ≠ 0,	h : filter.tendsto (u - function.const α c) l (𝓝 0)	⊢ filter.tendsto u l (𝓝 c)
α : Type u_1,	β : Type u_2,	_inst_1 : normed_group β,	u : α → β,	l : filter α,	c : β,	h : c ≠ 0,	h : filter.tendsto u l (𝓝 c),	this : filter.tendsto (λ (x : α), u x - (λ (b : α), ?m_1) x) l (𝓝 (c - ?m_1))	⊢ filter.tendsto (u - function.const α c) l (𝓝 0)		α : Type u_1,	β : Type u_2,	_inst_1 : normed_group β,	u : α → β,	l : filter α,	c : β,	h : c ≠ 0,	h : filter.tendsto u l (𝓝 c)	⊢ β
α : Type u_1,	β : Type u_2,	_inst_1 : normed_group β,	u : α → β,	l : filter α,	c : β,	h : c ≠ 0,	h : filter.tendsto u l (𝓝 c)	⊢ filter.tendsto (u - function.const α c) l (𝓝 0)
α : Type u_1,	β : Type u_2,	_inst_1 : normed_group β,	u : α → β,	l : filter α,	c : β,	h : c ≠ 0,	h : filter.tendsto (u - function.const α c) l (𝓝 0),	this : filter.tendsto (λ (x : α), (u - function.const α c) x - (λ (b : α), -c) x) l (𝓝 (- -c))	⊢ u = λ (x : α), (u - function.const α c) x - -c
α : Type u_1,	β : Type u_2,	_inst_1 : normed_group β,	u : α → β,	l : filter α,	c : β,	h : c ≠ 0,	h : filter.tendsto (u - function.const α c) l (𝓝 0),	this : filter.tendsto (λ (x : α), (u - function.const α c) x - (λ (b : α), -c) x) l (𝓝 (- -c))	⊢ c = - -c
α : Type u_1,	β : Type u_2,	_inst_1 : normed_group β,	u : α → β,	l : filter α,	c : β,	h : c ≠ 0,	h : filter.tendsto (u - function.const α c) l (𝓝 0),	this : filter.tendsto (λ (x : α), (u - function.const α c) x - (λ (b : α), -c) x) l (𝓝 (- -c))	⊢ c = - -c
α : Type u_1,	β : Type u_2,	_inst_1 : normed_group β,	u : α → β,	l : filter α,	c : β,	h : c ≠ 0,	h : filter.tendsto (u - function.const α c) l (𝓝 0),	this : filter.tendsto (λ (x : α), (u - function.const α c) x - (λ (b : α), -c) x) l (𝓝 (- -c)),	x : α	⊢ u x = (u - function.const α c) x - -c
α : Type u_1,	β : Type u_2,	_inst_1 : normed_group β,	u : α → β,	l : filter α,	c : β,	h : c ≠ 0,	h : filter.tendsto (u - function.const α c) l (𝓝 0),	this : filter.tendsto (λ (x : α), (u - function.const α c) x - (λ (b : α), -c) x) l (𝓝 (- -c))	⊢ c = - -c
α : Type u_1,	β : Type u_2,	_inst_1 : normed_group β,	u : α → β,	l : filter α,	c : β,	h : c ≠ 0,	h : filter.tendsto (u - function.const α c) l (𝓝 0),	this : filter.tendsto (λ (x : α), (u - function.const α c) x - (λ (b : α), -c) x) l (𝓝 (- -c))	⊢ filter.tendsto u l (𝓝 c)
α : Type u_1,	β : Type u_2,	_inst_1 : normed_group β,	u : α → β,	l : filter α,	c : β,	h : c ≠ 0,	h : filter.tendsto u l (𝓝 c),	this : filter.tendsto (λ (x : α), u x - (λ (b : α), ?m_1) x) l (𝓝 (c - ?m_1))	⊢ filter.tendsto (u - function.const α c) l (𝓝 (c - c))
α : Type u_1,	β : Type u_2,	_inst_1 : normed_group β,	u : α → β,	l : filter α,	c : β,	hu : u ~[l] function.const α c	⊢ filter.tendsto u l (𝓝 c)
α : Type u_1,	β : Type u_2,	_inst_1 : normed_group β,	u : α → β,	l : filter α,	hu : u ~[l] function.const α add_comm_group.zero,	h : add_comm_group.zero = 0	⊢ filter.tendsto u l (𝓝 add_comm_group.zero)
α : Type u_1,	β : Type u_2,	_inst_1 : normed_group β,	u : α → β,	l : filter α,	hu : u ~[l] function.const α add_comm_group.zero,	h : add_comm_group.zero = 0	⊢ filter.tendsto u l (𝓝 add_comm_group.zero)		α : Type u_1,	β : Type u_2,	_inst_1 : normed_group β,	u : α → β,	l : filter α,	c : β,	hu : u ~[l] function.const α c,	h : ¬c = 0	⊢ filter.tendsto u l (𝓝 c)
α : Type u_1,	β : Type u_2,	_inst_1 : normed_group β,	u : α → β,	l : filter α,	c : β,	hu : u ~[l] function.const α c,	h : ¬c = 0	⊢ filter.tendsto u l (𝓝 c)
α : Type u_1,	F : Type u_4,	E' : Type u_6,	𝕜 : Type u_11,	_inst_2 : has_norm F,	_inst_4 : normed_group E',	_inst_9 : normed_field 𝕜,	g : α → F,	f' : α → E',	l : filter α,	_inst_11 : normed_space 𝕜 E',	c : 𝕜,	hc : c ≠ 0	⊢ ∥c∥ ≠ 0		α : Type u_1,	F : Type u_4,	E' : Type u_6,	𝕜 : Type u_11,	_inst_2 : has_norm F,	_inst_4 : normed_group E',	_inst_9 : normed_field 𝕜,	g : α → F,	f' : α → E',	l : filter α,	_inst_11 : normed_space 𝕜 E',	c : 𝕜,	hc : c ≠ 0,	cne0 : ∥c∥ ≠ 0	⊢ asymptotics.is_O (λ (x : α), c • f' x) g l ↔ asymptotics.is_O f' g l
α : Type u_1,	F : Type u_4,	E' : Type u_6,	𝕜 : Type u_11,	_inst_2 : has_norm F,	_inst_4 : normed_group E',	_inst_9 : normed_field 𝕜,	g : α → F,	f' : α → E',	l : filter α,	_inst_11 : normed_space 𝕜 E',	c : 𝕜,	hc : c ≠ 0	⊢ asymptotics.is_O (λ (x : α), c • f' x) g l ↔ asymptotics.is_O f' g l
α : Type u_1,	F : Type u_4,	E' : Type u_6,	𝕜 : Type u_11,	_inst_2 : has_norm F,	_inst_4 : normed_group E',	_inst_9 : normed_field 𝕜,	g : α → F,	f' : α → E',	l : filter α,	_inst_11 : normed_space 𝕜 E',	c : 𝕜,	hc : c ≠ 0,	cne0 : ∥c∥ ≠ 0	⊢ asymptotics.is_O (λ (x : α), ∥c • f' x∥) g l ↔ asymptotics.is_O f' g l
α : Type u_1,	F : Type u_4,	E' : Type u_6,	𝕜 : Type u_11,	_inst_2 : has_norm F,	_inst_4 : normed_group E',	_inst_9 : normed_field 𝕜,	g : α → F,	f' : α → E',	l : filter α,	_inst_11 : normed_space 𝕜 E',	c : 𝕜,	hc : c ≠ 0,	cne0 : ∥c∥ ≠ 0	⊢ asymptotics.is_O (λ (x : α), c • f' x) g l ↔ asymptotics.is_O f' g l
α : Type u_1,	F : Type u_4,	E' : Type u_6,	𝕜 : Type u_11,	_inst_2 : has_norm F,	_inst_4 : normed_group E',	_inst_9 : normed_field 𝕜,	g : α → F,	f' : α → E',	l : filter α,	_inst_11 : normed_space 𝕜 E',	c : 𝕜,	hc : c ≠ 0,	cne0 : ∥c∥ ≠ 0	⊢ asymptotics.is_O (λ (x : α), ∥c∥ * ∥f' x∥) g l ↔ asymptotics.is_O f' g l
α : Type u_1,	F' : Type u_7,	_inst_5 : normed_group F',	g' : α → F',	l : filter α,	ι : Type u_2,	_inst_11 : fintype ι,	E' : ι → Type u_3,	_inst_12 : Π (i : ι), normed_group (E' i),	f : α → Π (i : ι), E' i	⊢ asymptotics.is_o f g' l ↔ ∀ (i : ι), asymptotics.is_o (λ (x : α), f x i) g' l
α : Type u_1,	F' : Type u_7,	_inst_5 : normed_group F',	g' : α → F',	l : filter α,	ι : Type u_2,	_inst_11 : fintype ι,	E' : ι → Type u_3,	_inst_12 : Π (i : ι), normed_group (E' i),	f : α → Π (i : ι), E' i	⊢ (∀ ⦃c : ℝ⦄, 0 < c → ∀ (i : ι), asymptotics.is_O_with c (λ (x : α), f x i) g' l) ↔ ∀ (i : ι) ⦃c : ℝ⦄, 0 < c → asymptotics.is_O_with c (λ (x : α), f x i) g' l
α : Type u_1,	E : Type u_3,	F : Type u_4,	_inst_1 : has_norm E,	_inst_2 : has_norm F,	c₁ c₂ : ℝ,	f₁ f₂ : α → E,	g₁ g₂ : α → F,	l : filter α,	hc : c₁ = c₂,	hf : f₁ =ᶠ[l] f₂,	hg : g₁ =ᶠ[l] g₂	⊢ asymptotics.is_O_with c₁ f₁ g₁ l ↔ asymptotics.is_O_with c₂ f₂ g₂ l
α : Type u_1,	E : Type u_3,	F : Type u_4,	_inst_1 : has_norm E,	_inst_2 : has_norm F,	c₁ c₂ : ℝ,	f₁ f₂ : α → E,	g₁ g₂ : α → F,	l : filter α,	hc : c₁ = c₂,	hf : f₁ =ᶠ[l] f₂,	hg : g₁ =ᶠ[l] g₂	⊢ (∀ᶠ (x : α) in l, ∥f₁ x∥ ≤ c₁ * ∥g₁ x∥) ↔ ∀ᶠ (x : α) in l, ∥f₂ x∥ ≤ c₂ * ∥g₂ x∥
α : Type u_1,	E : Type u_3,	F : Type u_4,	_inst_1 : has_norm E,	_inst_2 : has_norm F,	c₁ : ℝ,	f₁ f₂ : α → E,	g₁ g₂ : α → F,	l : filter α,	hf : f₁ =ᶠ[l] f₂,	hg : g₁ =ᶠ[l] g₂	⊢ (∀ᶠ (x : α) in l, ∥f₁ x∥ ≤ c₁ * ∥g₁ x∥) ↔ ∀ᶠ (x : α) in l, ∥f₂ x∥ ≤ c₁ * ∥g₂ x∥
α : Type u_1,	E : Type u_3,	F : Type u_4,	_inst_1 : has_norm E,	_inst_2 : has_norm F,	c₁ : ℝ,	f₁ f₂ : α → E,	g₁ g₂ : α → F,	l : filter α,	hf : f₁ =ᶠ[l] f₂,	hg : g₁ =ᶠ[l] g₂	⊢ ∀ᶠ (x : α) in l, ∥f₁ x∥ ≤ c₁ * ∥g₁ x∥ ↔ ∥f₂ x∥ ≤ c₁ * ∥g₂ x∥
α : Type u_1,	E : Type u_3,	F : Type u_4,	_inst_1 : has_norm E,	_inst_2 : has_norm F,	c₁ : ℝ,	f₁ f₂ : α → E,	g₁ g₂ : α → F,	l : filter α,	hf : f₁ =ᶠ[l] f₂,	hg : g₁ =ᶠ[l] g₂	⊢ ∀ (a : α), f₁ a = f₂ a → g₁ a = g₂ a → (∥f₁ a∥ ≤ c₁ * ∥g₁ a∥ ↔ ∥f₂ a∥ ≤ c₁ * ∥g₂ a∥)
α : Type u_1,	E : Type u_3,	F : Type u_4,	_inst_1 : has_norm E,	_inst_2 : has_norm F,	c₁ : ℝ,	f₁ f₂ : α → E,	g₁ g₂ : α → F,	l : filter α,	hf : f₁ =ᶠ[l] f₂,	hg : g₁ =ᶠ[l] g₂,	x : α,	e₁ : f₁ x = f₂ x,	e₂ : g₁ x = g₂ x	⊢ ∥f₁ x∥ ≤ c₁ * ∥g₁ x∥ ↔ ∥f₂ x∥ ≤ c₁ * ∥g₂ x∥
α : Type u_1,	F : Type u_4,	E' : Type u_6,	_inst_2 : has_norm F,	_inst_4 : normed_group E',	g : α → F,	f' : α → E',	l : filter α	⊢ (∀ ⦃c : ℝ⦄, 0 < c → asymptotics.is_O_with c (λ (x : α), -f' x) g l) ↔ ∀ ⦃c : ℝ⦄, 0 < c → asymptotics.is_O_with c f' g l
α : Type u_1,	F : Type u_4,	E' : Type u_6,	_inst_2 : has_norm F,	_inst_4 : normed_group E',	g : α → F,	f' : α → E',	l : filter α	⊢ asymptotics.is_o (λ (x : α), -f' x) g l ↔ asymptotics.is_o f' g l
𝕜 : Type u_1,	_inst_1 : linear_ordered_field 𝕜,	p q : ℕ,	hpq : q < p	⊢ filter.tendsto (λ (x : 𝕜), x ^ p / x ^ q) filter.at_top filter.at_top
𝕜 : Type u_1,	_inst_1 : linear_ordered_field 𝕜,	p q : ℕ,	hpq : q < p	⊢ filter.tendsto (λ (x : 𝕜), x ^ (↑p - ↑q)) filter.at_top filter.at_top
𝕜 : Type u_1,	_inst_1 : linear_ordered_field 𝕜,	p q : ℕ,	hpq : q < p	⊢ 0 < ↑p - ↑q
X : Type u_1,	Y : Type u_2,	_inst_1 : normed_group X,	_inst_2 : normed_group Y,	_inst_4 : normed_space ℝ X,	_inst_5 : normed_space ℝ Y,	f : X → Y,	x : X	⊢ conformal_at f x ↔ is_conformal_map (fderiv ℝ f x)
X : Type u_1,	Y : Type u_2,	_inst_1 : normed_group X,	_inst_2 : normed_group Y,	_inst_4 : normed_space ℝ X,	_inst_5 : normed_space ℝ Y,	f : X → Y,	x : X	⊢ conformal_at f x → is_conformal_map (fderiv ℝ f x)
X : Type u_1,	Y : Type u_2,	_inst_1 : normed_group X,	_inst_2 : normed_group Y,	_inst_4 : normed_space ℝ X,	_inst_5 : normed_space ℝ Y,	f : X → Y,	x : X,	c : X →L[ℝ] Y,	hf : has_fderiv_at f c x,	hf' : is_conformal_map c	⊢ is_conformal_map (fderiv ℝ f x)
X : Type u_1,	Y : Type u_2,	_inst_1 : normed_group X,	_inst_2 : normed_group Y,	_inst_4 : normed_space ℝ X,	_inst_5 : normed_space ℝ Y,	f : X → Y,	x : X	⊢ conformal_at f x → is_conformal_map (fderiv ℝ f x)		X : Type u_1,	Y : Type u_2,	_inst_1 : normed_group X,	_inst_2 : normed_group Y,	_inst_4 : normed_space ℝ X,	_inst_5 : normed_space ℝ Y,	f : X → Y,	x : X	⊢ is_conformal_map (fderiv ℝ f x) → conformal_at f x
X : Type u_1,	Y : Type u_2,	_inst_1 : normed_group X,	_inst_2 : normed_group Y,	_inst_4 : normed_space ℝ X,	_inst_5 : normed_space ℝ Y,	f : X → Y,	x : X,	c : X →L[ℝ] Y,	hf : has_fderiv_at f c x,	hf' : is_conformal_map c	⊢ is_conformal_map c
X : Type u_1,	Y : Type u_2,	_inst_1 : normed_group X,	_inst_2 : normed_group Y,	_inst_4 : normed_space ℝ X,	_inst_5 : normed_space ℝ Y,	f : X → Y,	x : X	⊢ is_conformal_map (fderiv ℝ f x) → conformal_at f x
X : Type u_1,	Y : Type u_2,	_inst_1 : normed_group X,	_inst_2 : normed_group Y,	_inst_4 : normed_space ℝ X,	_inst_5 : normed_space ℝ Y,	f : X → Y,	x : X,	H : is_conformal_map (fderiv ℝ f x)	⊢ conformal_at f x
X : Type u_1,	Y : Type u_2,	_inst_1 : normed_group X,	_inst_2 : normed_group Y,	_inst_4 : normed_space ℝ X,	_inst_5 : normed_space ℝ Y,	f : X → Y,	x : X,	H : is_conformal_map (fderiv ℝ f x),	h : differentiable_at ℝ f x	⊢ conformal_at f x		X : Type u_1,	Y : Type u_2,	_inst_1 : normed_group X,	_inst_2 : normed_group Y,	_inst_4 : normed_space ℝ X,	_inst_5 : normed_space ℝ Y,	f : X → Y,	x : X,	H : is_conformal_map (fderiv ℝ f x),	h : ¬differentiable_at ℝ f x	⊢ conformal_at f x
X : Type u_1,	Y : Type u_2,	_inst_1 : normed_group X,	_inst_2 : normed_group Y,	_inst_4 : normed_space ℝ X,	_inst_5 : normed_space ℝ Y,	f : X → Y,	x : X,	H : is_conformal_map (fderiv ℝ f x),	h : differentiable_at ℝ f x	⊢ conformal_at f x
X : Type u_1,	Y : Type u_2,	_inst_1 : normed_group X,	_inst_2 : normed_group Y,	_inst_4 : normed_space ℝ X,	_inst_5 : normed_space ℝ Y,	f : X → Y,	x : X,	H : is_conformal_map (fderiv ℝ f x),	h : ¬differentiable_at ℝ f x	⊢ conformal_at f x
X : Type u_1,	Y : Type u_2,	_inst_1 : normed_group X,	_inst_2 : normed_group Y,	_inst_4 : normed_space ℝ X,	_inst_5 : normed_space ℝ Y,	f : X → Y,	x : X,	H : is_conformal_map (fderiv ℝ f x),	h : ¬differentiable_at ℝ f x,	w : subsingleton X	⊢ conformal_at f x
X : Type u_1,	Y : Type u_2,	_inst_1 : normed_group X,	_inst_2 : normed_group Y,	_inst_4 : normed_space ℝ X,	_inst_5 : normed_space ℝ Y,	f : X → Y,	x : X,	H : is_conformal_map (fderiv ℝ f x),	h : ¬differentiable_at ℝ f x,	w : nontrivial X	⊢ conformal_at f x
X : Type u_1,	Y : Type u_2,	_inst_1 : normed_group X,	_inst_2 : normed_group Y,	_inst_4 : normed_space ℝ X,	_inst_5 : normed_space ℝ Y,	f : X → Y,	x : X,	H : is_conformal_map (fderiv ℝ f x),	h : ¬differentiable_at ℝ f x	⊢ conformal_at f x
X : Type u_1,	Y : Type u_2,	_inst_1 : normed_group X,	_inst_2 : normed_group Y,	_inst_4 : normed_space ℝ X,	_inst_5 : normed_space ℝ Y,	f : X → Y,	x : X,	H : is_conformal_map (fderiv ℝ f x),	h : ¬differentiable_at ℝ f x,	w : subsingleton X	⊢ conformal_at f x
X : Type u_1,	Y : Type u_2,	_inst_1 : normed_group X,	_inst_2 : normed_group Y,	_inst_4 : normed_space ℝ X,	_inst_5 : normed_space ℝ Y,	f : X → Y,	x : X,	H : is_conformal_map (fderiv ℝ f x),	h : ¬differentiable_at ℝ f x,	w : subsingleton X	⊢ conformal_at f x		X : Type u_1,	Y : Type u_2,	_inst_1 : normed_group X,	_inst_2 : normed_group Y,	_inst_4 : normed_space ℝ X,	_inst_5 : normed_space ℝ Y,	f : X → Y,	x : X,	H : is_conformal_map (fderiv ℝ f x),	h : ¬differentiable_at ℝ f x,	w : nontrivial X	⊢ conformal_at f x
X : Type u_1,	Y : Type u_2,	_inst_1 : normed_group X,	_inst_2 : normed_group Y,	_inst_4 : normed_space ℝ X,	_inst_5 : normed_space ℝ Y,	f : X → Y,	x : X,	H : is_conformal_map (fderiv ℝ f x),	h : ¬differentiable_at ℝ f x,	w : nontrivial X	⊢ conformal_at f x
X : Type u_1,	Y : Type u_2,	_inst_1 : normed_group X,	_inst_2 : normed_group Y,	_inst_4 : normed_space ℝ X,	_inst_5 : normed_space ℝ Y,	f : X → Y,	x : X,	H : is_conformal_map (fderiv ℝ f x),	h : ¬differentiable_at ℝ f x,	w : nontrivial X	⊢ false
𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	x : 𝕜,	f : 𝕜 → 𝕜,	f' : 𝕜,	hf : has_strict_deriv_at f f' x,	hx : f x = x,	n : ℕ	⊢ has_strict_deriv_at f^[n] (f' ^ n) x
𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	x : 𝕜,	f : 𝕜 → 𝕜,	f' : 𝕜,	hf : has_strict_deriv_at f f' x,	hx : f x = x,	n : ℕ,	this : has_strict_fderiv_at f^[n] (1.smul_right f' ^ n) x	⊢ has_strict_deriv_at f^[n] (f' ^ n) x
𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	x : 𝕜,	c d : 𝕜 → 𝕜,	c' d' : 𝕜,	hc : has_strict_deriv_at c c' x,	hd : has_strict_deriv_at d d' x,	hx : d x ≠ 0	⊢ has_strict_deriv_at (λ (y : 𝕜), c y / d y) ((c' * d x - c x * d') / d x ^ 2) x
𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	x : 𝕜,	c d : 𝕜 → 𝕜,	c' d' : 𝕜,	hc : has_strict_deriv_at c c' x,	hd : has_strict_deriv_at d d' x,	hx : d x ≠ 0	⊢ (λ (y : 𝕜), c y / d y) = λ (y : 𝕜), c y * (has_inv.inv ∘ d) y		𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	x : 𝕜,	c d : 𝕜 → 𝕜,	c' d' : 𝕜,	hc : has_strict_deriv_at c c' x,	hd : has_strict_deriv_at d d' x,	hx : d x ≠ 0	⊢ (c' * d x - c x * d') / d x ^ 2 = c' * (has_inv.inv ∘ d) x + c x * (-(d x ^ 2)⁻¹ * d')
𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	x : 𝕜,	c d : 𝕜 → 𝕜,	c' d' : 𝕜,	hc : has_strict_deriv_at c c' x,	hd : has_strict_deriv_at d d' x,	hx : d x ≠ 0	⊢ (λ (y : 𝕜), c y / d y) = λ (y : 𝕜), c y * (has_inv.inv ∘ d) y
𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	x : 𝕜,	c d : 𝕜 → 𝕜,	c' d' : 𝕜,	hc : has_strict_deriv_at c c' x,	hd : has_strict_deriv_at d d' x,	hx : d x ≠ 0	⊢ (c' * d x - c x * d') * (d x * d x ^ 2) = (c' * d x ^ 2 + -(c x * d' * d x)) * d x ^ 2
𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	x : 𝕜,	c d : 𝕜 → 𝕜,	c' d' : 𝕜,	hc : has_strict_deriv_at c c' x,	hd : has_strict_deriv_at d d' x,	hx : d x ≠ 0	⊢ (c' * d x - c x * d') / d x ^ 2 = c' * (has_inv.inv ∘ d) x + c x * (-(d x ^ 2)⁻¹ * d')
𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	F : Type v,	_inst_2 : normed_group F,	_inst_3 : normed_space 𝕜 F,	f : 𝕜 → F,	f' : F,	x : 𝕜,	_inst_6 : partial_order 𝕜	⊢ has_deriv_within_at f f' (set.Iio x) x ↔ has_deriv_within_at f f' (set.Iic x) x
𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	F : Type v,	_inst_2 : normed_group F,	_inst_3 : normed_space 𝕜 F,	f f₁ : 𝕜 → F,	f' : F,	x : 𝕜,	L : filter 𝕜,	h : has_deriv_at_filter f f' x L,	hL : f₁ =ᶠ[L] f,	hx : f₁ x = f x	⊢ has_deriv_at_filter f₁ f' x L
𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	F : Type v,	_inst_2 : normed_group F,	_inst_3 : normed_space 𝕜 F,	x : 𝕜,	s : set 𝕜,	c : 𝕜 → 𝕜,	c' : 𝕜,	hc : has_deriv_within_at c c' s x,	f : F	⊢ has_deriv_within_at (λ (y : 𝕜), c y • f) (c' • f) s x
𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	F : Type v,	_inst_2 : normed_group F,	_inst_3 : normed_space 𝕜 F,	x : 𝕜,	s : set 𝕜,	c : 𝕜 → 𝕜,	c' : 𝕜,	hc : has_deriv_within_at c c' s x,	f : F,	this : has_deriv_within_at (λ (y : 𝕜), c y • (λ (x : 𝕜), f) y) (c x • 0 + c' • (λ (x : 𝕜), f) x) s x	⊢ has_deriv_within_at (λ (y : 𝕜), c y • f) (c' • f) s x
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	f : E → F,	x : E,	s : set E,	hxs : unique_diff_within_at 𝕜 s x,	h : ¬differentiable_within_at 𝕜 f s x	⊢ fderiv_within 𝕜 (λ (y : E), -f y) s x = -fderiv_within 𝕜 f s x
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	f : E → F,	x : E,	s : set E,	hxs : unique_diff_within_at 𝕜 s x,	h : ¬differentiable_within_at 𝕜 f s x	⊢ ¬differentiable_within_at 𝕜 (λ (y : E), -f y) s x
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	G : Type u_4,	_inst_6 : normed_group G,	_inst_7 : normed_space 𝕜 G,	iso : E ≃L[𝕜] F,	f : G → E,	x : G	⊢ fderiv 𝕜 (⇑iso ∘ f) x = ↑iso.comp (fderiv 𝕜 f x)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	G : Type u_4,	_inst_6 : normed_group G,	_inst_7 : normed_space 𝕜 G,	iso : E ≃L[𝕜] F,	f : G → E,	x : G	⊢ fderiv_within 𝕜 (⇑iso ∘ f) set.univ x = ↑iso.comp (fderiv_within 𝕜 f set.univ x)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	f : E → F,	f' : E →L[𝕜] F,	x : E,	hf : has_strict_fderiv_at f f' x	⊢ has_fderiv_at f f' x
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	f : E → F,	f' : E →L[𝕜] F,	x : E,	hf : has_strict_fderiv_at f f' x	⊢ ∀ ⦃c : ℝ⦄, 0 < c → (∀ᶠ (x_1 : E) in 𝓝 x, ∥f x_1 - f x - ⇑f' (x_1 - x)∥ ≤ c * ∥x_1 - x∥)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	G : Type u_4,	_inst_6 : normed_group G,	_inst_7 : normed_space 𝕜 G,	f : E → F,	f' : E →L[𝕜] F,	x : E,	L : filter E,	g : F → G,	g' : F →L[𝕜] G,	hg : has_fderiv_at_filter g g' (f x) (filter.map f L),	hf : has_fderiv_at_filter f f' x L	⊢ has_fderiv_at_filter (g ∘ f) (g'.comp f') x L
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	G : Type u_4,	_inst_6 : normed_group G,	_inst_7 : normed_space 𝕜 G,	f : E → F,	f' : E →L[𝕜] F,	x : E,	L : filter E,	g : F → G,	g' : F →L[𝕜] G,	hf : has_fderiv_at_filter f f' x L,	hg : asymptotics.is_o (λ (x' : F), g x' - g (f x) - ⇑g' (x' - f x)) (λ (x' : F), x' - f x) (filter.map f L)	⊢ has_fderiv_at_filter (g ∘ f) (g'.comp f') x L
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	G : Type u_4,	_inst_6 : normed_group G,	_inst_7 : normed_space 𝕜 G,	f : E → F,	f' : E →L[𝕜] F,	x : E,	L : filter E,	g : F → G,	g' : F →L[𝕜] G,	hf : has_fderiv_at_filter f f' x L,	hg : asymptotics.is_o (λ (x' : F), g x' - g (f x) - ⇑g' (x' - f x)) (λ (x' : F), x' - f x) (filter.map f L)	⊢ asymptotics.is_o (λ (x' : E), g (f x') - g (f x) - ⇑g' (f x' - f x)) (λ (x' : E), f x' - f x) L		𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	G : Type u_4,	_inst_6 : normed_group G,	_inst_7 : normed_space 𝕜 G,	f : E → F,	f' : E →L[𝕜] F,	x : E,	L : filter E,	g : F → G,	g' : F →L[𝕜] G,	hf : has_fderiv_at_filter f f' x L,	hg : asymptotics.is_o (λ (x' : F), g x' - g (f x) - ⇑g' (x' - f x)) (λ (x' : F), x' - f x) (filter.map f L),	this : asymptotics.is_o (λ (x' : E), g (f x') - g (f x) - ⇑g' (f x' - f x)) (λ (x' : E), f x' - f x) L	⊢ has_fderiv_at_filter (g ∘ f) (g'.comp f') x L
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	G : Type u_4,	_inst_6 : normed_group G,	_inst_7 : normed_space 𝕜 G,	f : E → F,	f' : E →L[𝕜] F,	x : E,	L : filter E,	g : F → G,	g' : F →L[𝕜] G,	hf : has_fderiv_at_filter f f' x L,	hg : asymptotics.is_o (λ (x' : F), g x' - g (f x) - ⇑g' (x' - f x)) (λ (x' : F), x' - f x) (filter.map f L),	this : asymptotics.is_o (λ (x' : E), g (f x') - g (f x) - ⇑g' (f x' - f x)) (λ (x' : E), f x' - f x) L	⊢ has_fderiv_at_filter (g ∘ f) (g'.comp f') x L
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	G : Type u_4,	_inst_6 : normed_group G,	_inst_7 : normed_space 𝕜 G,	f : E → F,	f' : E →L[𝕜] F,	x : E,	L : filter E,	g : F → G,	g' : F →L[𝕜] G,	hf : has_fderiv_at_filter f f' x L,	hg : asymptotics.is_o (λ (x' : F), g x' - g (f x) - ⇑g' (x' - f x)) (λ (x' : F), x' - f x) (filter.map f L),	this : asymptotics.is_o (λ (x' : E), g (f x') - g (f x) - ⇑g' (f x' - f x)) (λ (x' : E), f x' - f x) L	⊢ asymptotics.is_o (λ (x' : E), g (f x') - g (f x) - ⇑g' (f x' - f x)) (λ (x' : E), x' - x) L		𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	G : Type u_4,	_inst_6 : normed_group G,	_inst_7 : normed_space 𝕜 G,	f : E → F,	f' : E →L[𝕜] F,	x : E,	L : filter E,	g : F → G,	g' : F →L[𝕜] G,	hf : has_fderiv_at_filter f f' x L,	hg : asymptotics.is_o (λ (x' : F), g x' - g (f x) - ⇑g' (x' - f x)) (λ (x' : F), x' - f x) (filter.map f L),	this : asymptotics.is_o (λ (x' : E), g (f x') - g (f x) - ⇑g' (f x' - f x)) (λ (x' : E), f x' - f x) L,	eq₁ : asymptotics.is_o (λ (x' : E), g (f x') - g (f x) - ⇑g' (f x' - f x)) (λ (x' : E), x' - x) L	⊢ has_fderiv_at_filter (g ∘ f) (g'.comp f') x L
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	G : Type u_4,	_inst_6 : normed_group G,	_inst_7 : normed_space 𝕜 G,	f : E → F,	f' : E →L[𝕜] F,	x : E,	L : filter E,	g : F → G,	g' : F →L[𝕜] G,	hf : has_fderiv_at_filter f f' x L,	hg : asymptotics.is_o (λ (x' : F), g x' - g (f x) - ⇑g' (x' - f x)) (λ (x' : F), x' - f x) (filter.map f L),	this : asymptotics.is_o (λ (x' : E), g (f x') - g (f x) - ⇑g' (f x' - f x)) (λ (x' : E), f x' - f x) L,	eq₁ : asymptotics.is_o (λ (x' : E), g (f x') - g (f x) - ⇑g' (f x' - f x)) (λ (x' : E), x' - x) L	⊢ has_fderiv_at_filter (g ∘ f) (g'.comp f') x L
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	G : Type u_4,	_inst_6 : normed_group G,	_inst_7 : normed_space 𝕜 G,	f : E → F,	f' : E →L[𝕜] F,	x : E,	L : filter E,	g : F → G,	g' : F →L[𝕜] G,	hf : has_fderiv_at_filter f f' x L,	hg : asymptotics.is_o (λ (x' : F), g x' - g (f x) - ⇑g' (x' - f x)) (λ (x' : F), x' - f x) (filter.map f L),	this : asymptotics.is_o (λ (x' : E), g (f x') - g (f x) - ⇑g' (f x' - f x)) (λ (x' : E), f x' - f x) L,	eq₁ : asymptotics.is_o (λ (x' : E), g (f x') - g (f x) - ⇑g' (f x' - f x)) (λ (x' : E), x' - x) L	⊢ asymptotics.is_o (λ (x' : E), f x' - f x - ⇑f' (x' - x)) (λ (x' : E), x' - x) L		𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	G : Type u_4,	_inst_6 : normed_group G,	_inst_7 : normed_space 𝕜 G,	f : E → F,	f' : E →L[𝕜] F,	x : E,	L : filter E,	g : F → G,	g' : F →L[𝕜] G,	hf : has_fderiv_at_filter f f' x L,	hg : asymptotics.is_o (λ (x' : F), g x' - g (f x) - ⇑g' (x' - f x)) (λ (x' : F), x' - f x) (filter.map f L),	this : asymptotics.is_o (λ (x' : E), g (f x') - g (f x) - ⇑g' (f x' - f x)) (λ (x' : E), f x' - f x) L,	eq₁ : asymptotics.is_o (λ (x' : E), g (f x') - g (f x) - ⇑g' (f x' - f x)) (λ (x' : E), x' - x) L,	eq₂ : asymptotics.is_o (λ (x' : E), f x' - f x - ⇑f' (x' - x)) (λ (x' : E), x' - x) L	⊢ has_fderiv_at_filter (g ∘ f) (g'.comp f') x L
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	G : Type u_4,	_inst_6 : normed_group G,	_inst_7 : normed_space 𝕜 G,	f : E → F,	f' : E →L[𝕜] F,	x : E,	L : filter E,	g : F → G,	g' : F →L[𝕜] G,	hf : has_fderiv_at_filter f f' x L,	hg : asymptotics.is_o (λ (x' : F), g x' - g (f x) - ⇑g' (x' - f x)) (λ (x' : F), x' - f x) (filter.map f L),	this : asymptotics.is_o (λ (x' : E), g (f x') - g (f x) - ⇑g' (f x' - f x)) (λ (x' : E), f x' - f x) L,	eq₁ : asymptotics.is_o (λ (x' : E), g (f x') - g (f x) - ⇑g' (f x' - f x)) (λ (x' : E), x' - x) L,	eq₂ : asymptotics.is_o (λ (x' : E), f x' - f x - ⇑f' (x' - x)) (λ (x' : E), x' - x) L	⊢ has_fderiv_at_filter (g ∘ f) (g'.comp f') x L
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	G : Type u_4,	_inst_6 : normed_group G,	_inst_7 : normed_space 𝕜 G,	f : E → F,	f' : E →L[𝕜] F,	x : E,	L : filter E,	g : F → G,	g' : F →L[𝕜] G,	hf : has_fderiv_at_filter f f' x L,	hg : asymptotics.is_o (λ (x' : F), g x' - g (f x) - ⇑g' (x' - f x)) (λ (x' : F), x' - f x) (filter.map f L),	this : asymptotics.is_o (λ (x' : E), g (f x') - g (f x) - ⇑g' (f x' - f x)) (λ (x' : E), f x' - f x) L,	eq₁ : asymptotics.is_o (λ (x' : E), g (f x') - g (f x) - ⇑g' (f x' - f x)) (λ (x' : E), x' - x) L,	eq₂ : asymptotics.is_o (λ (x' : E), f x' - f x - ⇑f' (x' - x)) (λ (x' : E), x' - x) L	⊢ asymptotics.is_O (λ (x' : E), ⇑g' (f x' - f x - ⇑f' (x' - x))) (λ (x' : E), f x' - f x - ⇑f' (x' - x)) L		𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	G : Type u_4,	_inst_6 : normed_group G,	_inst_7 : normed_space 𝕜 G,	f : E → F,	f' : E →L[𝕜] F,	x : E,	L : filter E,	g : F → G,	g' : F →L[𝕜] G,	hf : has_fderiv_at_filter f f' x L,	hg : asymptotics.is_o (λ (x' : F), g x' - g (f x) - ⇑g' (x' - f x)) (λ (x' : F), x' - f x) (filter.map f L),	this : asymptotics.is_o (λ (x' : E), g (f x') - g (f x) - ⇑g' (f x' - f x)) (λ (x' : E), f x' - f x) L,	eq₁ : asymptotics.is_o (λ (x' : E), g (f x') - g (f x) - ⇑g' (f x' - f x)) (λ (x' : E), x' - x) L,	eq₂ : asymptotics.is_o (λ (x' : E), f x' - f x - ⇑f' (x' - x)) (λ (x' : E), x' - x) L,	this : asymptotics.is_O (λ (x' : E), ⇑g' (f x' - f x - ⇑f' (x' - x))) (λ (x' : E), f x' - f x - ⇑f' (x' - x)) L	⊢ has_fderiv_at_filter (g ∘ f) (g'.comp f') x L
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	G : Type u_4,	_inst_6 : normed_group G,	_inst_7 : normed_space 𝕜 G,	f : E → F,	f' : E →L[𝕜] F,	x : E,	L : filter E,	g : F → G,	g' : F →L[𝕜] G,	hf : has_fderiv_at_filter f f' x L,	hg : asymptotics.is_o (λ (x' : F), g x' - g (f x) - ⇑g' (x' - f x)) (λ (x' : F), x' - f x) (filter.map f L),	this : asymptotics.is_o (λ (x' : E), g (f x') - g (f x) - ⇑g' (f x' - f x)) (λ (x' : E), f x' - f x) L,	eq₁ : asymptotics.is_o (λ (x' : E), g (f x') - g (f x) - ⇑g' (f x' - f x)) (λ (x' : E), x' - x) L,	eq₂ : asymptotics.is_o (λ (x' : E), f x' - f x - ⇑f' (x' - x)) (λ (x' : E), x' - x) L,	this : asymptotics.is_O (λ (x' : E), ⇑g' (f x' - f x - ⇑f' (x' - x))) (λ (x' : E), f x' - f x - ⇑f' (x' - x)) L	⊢ has_fderiv_at_filter (g ∘ f) (g'.comp f') x L
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	G : Type u_4,	_inst_6 : normed_group G,	_inst_7 : normed_space 𝕜 G,	f : E → F,	f' : E →L[𝕜] F,	x : E,	L : filter E,	g : F → G,	g' : F →L[𝕜] G,	hf : has_fderiv_at_filter f f' x L,	hg : asymptotics.is_o (λ (x' : F), g x' - g (f x) - ⇑g' (x' - f x)) (λ (x' : F), x' - f x) (filter.map f L),	this : asymptotics.is_o (λ (x' : E), g (f x') - g (f x) - ⇑g' (f x' - f x)) (λ (x' : E), f x' - f x) L,	eq₁ : asymptotics.is_o (λ (x' : E), g (f x') - g (f x) - ⇑g' (f x' - f x)) (λ (x' : E), x' - x) L,	eq₂ : asymptotics.is_o (λ (x' : E), f x' - f x - ⇑f' (x' - x)) (λ (x' : E), x' - x) L,	this : asymptotics.is_O (λ (x' : E), ⇑g' (f x' - f x - ⇑f' (x' - x))) (λ (x' : E), f x' - f x - ⇑f' (x' - x)) L	⊢ asymptotics.is_o (λ (x' : E), ⇑g' (f x' - f x - ⇑f' (x' - x))) (λ (x' : E), x' - x) L		𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	G : Type u_4,	_inst_6 : normed_group G,	_inst_7 : normed_space 𝕜 G,	f : E → F,	f' : E →L[𝕜] F,	x : E,	L : filter E,	g : F → G,	g' : F →L[𝕜] G,	hf : has_fderiv_at_filter f f' x L,	hg : asymptotics.is_o (λ (x' : F), g x' - g (f x) - ⇑g' (x' - f x)) (λ (x' : F), x' - f x) (filter.map f L),	this : asymptotics.is_o (λ (x' : E), g (f x') - g (f x) - ⇑g' (f x' - f x)) (λ (x' : E), f x' - f x) L,	eq₁ : asymptotics.is_o (λ (x' : E), g (f x') - g (f x) - ⇑g' (f x' - f x)) (λ (x' : E), x' - x) L,	eq₂ : asymptotics.is_o (λ (x' : E), f x' - f x - ⇑f' (x' - x)) (λ (x' : E), x' - x) L,	this : asymptotics.is_O (λ (x' : E), ⇑g' (f x' - f x - ⇑f' (x' - x))) (λ (x' : E), f x' - f x - ⇑f' (x' - x)) L,	this : asymptotics.is_o (λ (x' : E), ⇑g' (f x' - f x - ⇑f' (x' - x))) (λ (x' : E), x' - x) L	⊢ has_fderiv_at_filter (g ∘ f) (g'.comp f') x L
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	G : Type u_4,	_inst_6 : normed_group G,	_inst_7 : normed_space 𝕜 G,	f : E → F,	f' : E →L[𝕜] F,	x : E,	L : filter E,	g : F → G,	g' : F →L[𝕜] G,	hf : has_fderiv_at_filter f f' x L,	hg : asymptotics.is_o (λ (x' : F), g x' - g (f x) - ⇑g' (x' - f x)) (λ (x' : F), x' - f x) (filter.map f L),	this : asymptotics.is_o (λ (x' : E), g (f x') - g (f x) - ⇑g' (f x' - f x)) (λ (x' : E), f x' - f x) L,	eq₁ : asymptotics.is_o (λ (x' : E), g (f x') - g (f x) - ⇑g' (f x' - f x)) (λ (x' : E), x' - x) L,	eq₂ : asymptotics.is_o (λ (x' : E), f x' - f x - ⇑f' (x' - x)) (λ (x' : E), x' - x) L,	this : asymptotics.is_O (λ (x' : E), ⇑g' (f x' - f x - ⇑f' (x' - x))) (λ (x' : E), f x' - f x - ⇑f' (x' - x)) L,	this : asymptotics.is_o (λ (x' : E), ⇑g' (f x' - f x - ⇑f' (x' - x))) (λ (x' : E), x' - x) L	⊢ has_fderiv_at_filter (g ∘ f) (g'.comp f') x L
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	G : Type u_4,	_inst_6 : normed_group G,	_inst_7 : normed_space 𝕜 G,	f : E → F,	f' : E →L[𝕜] F,	x : E,	L : filter E,	g : F → G,	g' : F →L[𝕜] G,	hf : has_fderiv_at_filter f f' x L,	hg : asymptotics.is_o (λ (x' : F), g x' - g (f x) - ⇑g' (x' - f x)) (λ (x' : F), x' - f x) (filter.map f L),	this : asymptotics.is_o (λ (x' : E), g (f x') - g (f x) - ⇑g' (f x' - f x)) (λ (x' : E), f x' - f x) L,	eq₁ : asymptotics.is_o (λ (x' : E), g (f x') - g (f x) - ⇑g' (f x' - f x)) (λ (x' : E), x' - x) L,	eq₂ : asymptotics.is_o (λ (x' : E), f x' - f x - ⇑f' (x' - x)) (λ (x' : E), x' - x) L,	this : asymptotics.is_O (λ (x' : E), ⇑g' (f x' - f x - ⇑f' (x' - x))) (λ (x' : E), f x' - f x - ⇑f' (x' - x)) L,	this : asymptotics.is_o (λ (x' : E), ⇑g' (f x' - f x - ⇑f' (x' - x))) (λ (x' : E), x' - x) L	⊢ asymptotics.is_o (λ (x' : E), ⇑g' (f x' - f x) - ⇑g' (⇑f' (x' - x))) (λ (x' : E), x' - x) L
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	G : Type u_4,	_inst_6 : normed_group G,	_inst_7 : normed_space 𝕜 G,	f : E → F,	f' : E →L[𝕜] F,	x : E,	L : filter E,	g : F → G,	g' : F →L[𝕜] G,	hf : has_fderiv_at_filter f f' x L,	hg : asymptotics.is_o (λ (x' : F), g x' - g (f x) - ⇑g' (x' - f x)) (λ (x' : F), x' - f x) (filter.map f L),	this : asymptotics.is_o (λ (x' : E), g (f x') - g (f x) - ⇑g' (f x' - f x)) (λ (x' : E), f x' - f x) L,	eq₁ : asymptotics.is_o (λ (x' : E), g (f x') - g (f x) - ⇑g' (f x' - f x)) (λ (x' : E), x' - x) L,	eq₂ : asymptotics.is_o (λ (x' : E), f x' - f x - ⇑f' (x' - x)) (λ (x' : E), x' - x) L,	this : asymptotics.is_O (λ (x' : E), ⇑g' (f x' - f x - ⇑f' (x' - x))) (λ (x' : E), f x' - f x - ⇑f' (x' - x)) L,	this : asymptotics.is_o (λ (x' : E), ⇑g' (f x' - f x - ⇑f' (x' - x))) (λ (x' : E), x' - x) L	⊢ ∀ (x_1 : E), ⇑g' (f x_1 - f x - ⇑f' (x_1 - x)) = ⇑g' (f x_1 - f x) - ⇑g' (⇑f' (x_1 - x))
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	G : Type u_4,	_inst_6 : normed_group G,	_inst_7 : normed_space 𝕜 G,	f : E → F,	f' : E →L[𝕜] F,	x : E,	L : filter E,	g : F → G,	g' : F →L[𝕜] G,	hf : has_fderiv_at_filter f f' x L,	hg : asymptotics.is_o (λ (x' : F), g x' - g (f x) - ⇑g' (x' - f x)) (λ (x' : F), x' - f x) (filter.map f L),	this : asymptotics.is_o (λ (x' : E), g (f x') - g (f x) - ⇑g' (f x' - f x)) (λ (x' : E), f x' - f x) L,	eq₁ : asymptotics.is_o (λ (x' : E), g (f x') - g (f x) - ⇑g' (f x' - f x)) (λ (x' : E), x' - x) L,	eq₂ : asymptotics.is_o (λ (x' : E), f x' - f x - ⇑f' (x' - x)) (λ (x' : E), x' - x) L,	this : asymptotics.is_O (λ (x' : E), ⇑g' (f x' - f x - ⇑f' (x' - x))) (λ (x' : E), f x' - f x - ⇑f' (x' - x)) L,	this : asymptotics.is_o (λ (x' : E), ⇑g' (f x' - f x - ⇑f' (x' - x))) (λ (x' : E), x' - x) L,	eq₃ : asymptotics.is_o (λ (x' : E), ⇑g' (f x' - f x) - ⇑g' (⇑f' (x' - x))) (λ (x' : E), x' - x) L	⊢ has_fderiv_at_filter (g ∘ f) (g'.comp f') x L
E : Type u_1,	F : Type u_2,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	_inst_3 : normed_group F,	_inst_4 : normed_space ℝ F,	x : E,	f : E → F,	f' : E → (E →L[ℝ] F),	f'' : E →L[ℝ] E →L[ℝ] F,	hf : ∀ᶠ (y : E) in 𝓝 x, has_fderiv_at f (f' y) y,	hx : has_fderiv_at f' f'' x,	v w : E	⊢ ⇑(⇑f'' v) w = ⇑(⇑f'' w) v
E : Type u_1,	F : Type u_2,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	_inst_3 : normed_group F,	_inst_4 : normed_space ℝ F,	x : E,	f : E → F,	f' : E → (E →L[ℝ] F),	f'' : E →L[ℝ] E →L[ℝ] F,	hf : ∀ᶠ (y : E) in 𝓝 x, has_fderiv_at f (f' y) y,	hx : has_fderiv_at f' f'' x,	v w : E,	ε : ℝ,	εpos : ε > 0,	hε : metric.ball x ε ⊆ {x : E | (λ (y : E), has_fderiv_at f (f' y) y) x}	⊢ ⇑(⇑f'' v) w = ⇑(⇑f'' w) v
E : Type u_1,	F : Type u_2,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	_inst_3 : normed_group F,	_inst_4 : normed_space ℝ F,	x : E,	f : E → F,	f' : E → (E →L[ℝ] F),	f'' : E →L[ℝ] E →L[ℝ] F,	hf : ∀ᶠ (y : E) in 𝓝 x, has_fderiv_at f (f' y) y,	hx : has_fderiv_at f' f'' x,	v w : E,	ε : ℝ,	εpos : ε > 0,	hε : metric.ball x ε ⊆ {x : E | (λ (y : E), has_fderiv_at f (f' y) y) x}	⊢ (interior (metric.ball x ε)).nonempty
E : Type u_1,	F : Type u_2,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	_inst_3 : normed_group F,	_inst_4 : normed_space ℝ F,	x : E,	f : E → F,	f' : E → (E →L[ℝ] F),	f'' : E →L[ℝ] E →L[ℝ] F,	hf : ∀ᶠ (y : E) in 𝓝 x, has_fderiv_at f (f' y) y,	hx : has_fderiv_at f' f'' x,	v w : E,	ε : ℝ,	εpos : ε > 0,	hε : metric.ball x ε ⊆ {x : E | (λ (y : E), has_fderiv_at f (f' y) y) x},	A : (interior (metric.ball x ε)).nonempty	⊢ ⇑(⇑f'' v) w = ⇑(⇑f'' w) v
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	_inst_4 : complete_space E,	F : Type u_3,	_inst_5 : normed_group F,	_inst_6 : normed_space 𝕜 F,	_inst_7 : complete_space F,	f : E → F,	f' : E →L[𝕜] F,	a : E,	hf : has_strict_fderiv_at f f' a,	hf' : f'.range = ⊤,	hker : f'.ker.closed_complemented	⊢ ⇑(has_strict_fderiv_at.implicit_to_local_homeomorph_of_complemented f f' hf hf' hker) a = (f a, 0)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	_inst_4 : complete_space E,	F : Type u_3,	_inst_5 : normed_group F,	_inst_6 : normed_space 𝕜 F,	_inst_7 : complete_space F,	f : E → F,	f' : E →L[𝕜] F,	a : E,	hf : has_strict_fderiv_at f f' a,	hf' : f'.range = ⊤,	hker : f'.ker.closed_complemented	⊢ has_strict_fderiv_at (has_strict_fderiv_at.implicit_function_of_complemented f f' hf hf' hker (f a)) (continuous_linear_map.subtype_val f'.ker) 0
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	_inst_4 : complete_space E,	F : Type u_3,	_inst_5 : normed_group F,	_inst_6 : normed_space 𝕜 F,	_inst_7 : complete_space F,	f : E → F,	f' : E →L[𝕜] F,	a : E,	hf : has_strict_fderiv_at f f' a,	hf' : f'.range = ⊤,	hker : f'.ker.closed_complemented	⊢ has_strict_fderiv_at (has_strict_fderiv_at.implicit_function_of_complemented f f' hf hf' hker (f a)) (continuous_linear_map.subtype_val f'.ker) 0
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	_inst_4 : complete_space E,	F : Type u_3,	_inst_5 : normed_group F,	_inst_6 : normed_space 𝕜 F,	_inst_7 : complete_space F,	f : E → F,	f' : E →L[𝕜] F,	a : E,	hf : has_strict_fderiv_at f f' a,	hf' : f'.range = ⊤,	hker : f'.ker.closed_complemented	⊢ has_strict_fderiv_at (has_strict_fderiv_at.implicit_function_of_complemented f f' hf hf' hker (f a)) (continuous_linear_map.subtype_val f'.ker) 0
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	_inst_4 : complete_space E,	F : Type u_3,	_inst_5 : normed_group F,	_inst_6 : normed_space 𝕜 F,	_inst_7 : complete_space F,	f : E → F,	f' : E →L[𝕜] F,	a : E,	hf : has_strict_fderiv_at f f' a,	hf' : f'.range = ⊤,	hker : f'.ker.closed_complemented	⊢ (has_strict_fderiv_at.implicit_function_data_of_complemented f f' hf hf' hker).right_deriv.comp (continuous_linear_map.subtype_val f'.ker) = continuous_linear_map.id 𝕜 ↥(f'.ker)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	_inst_4 : complete_space E,	F : Type u_3,	_inst_5 : normed_group F,	_inst_6 : normed_space 𝕜 F,	_inst_7 : complete_space F,	f : E → F,	f' : E →L[𝕜] F,	a : E,	hf : has_strict_fderiv_at f f' a,	hf' : f'.range = ⊤,	hker : f'.ker.closed_complemented	⊢ (has_strict_fderiv_at.implicit_function_data_of_complemented f f' hf hf' hker).left_deriv.comp (continuous_linear_map.subtype_val f'.ker) = 0
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	_inst_4 : complete_space E,	F : Type u_3,	_inst_5 : normed_group F,	_inst_6 : normed_space 𝕜 F,	_inst_7 : complete_space F,	f : E → F,	f' : E →L[𝕜] F,	a : E,	hf : has_strict_fderiv_at f f' a,	hf' : f'.range = ⊤,	hker : f'.ker.closed_complemented	⊢ 0 = (has_strict_fderiv_at.implicit_function_data_of_complemented f f' hf hf' hker).right_fun (has_strict_fderiv_at.implicit_function_data_of_complemented f f' hf hf' hker).pt
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	_inst_4 : complete_space E,	F : Type u_3,	_inst_5 : normed_group F,	_inst_6 : normed_space 𝕜 F,	_inst_7 : complete_space F,	f : E → F,	f' : E →L[𝕜] F,	a : E,	hf : has_strict_fderiv_at f f' a,	hf' : f'.range = ⊤,	hker : f'.ker.closed_complemented,	x : ↥(f'.ker)	⊢ ↑(⇑((has_strict_fderiv_at.implicit_function_data_of_complemented f f' hf hf' hker).right_deriv.comp (continuous_linear_map.subtype_val f'.ker)) x) = ↑(⇑(continuous_linear_map.id 𝕜 ↥(f'.ker)) x)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	_inst_4 : complete_space E,	F : Type u_3,	_inst_5 : normed_group F,	_inst_6 : normed_space 𝕜 F,	_inst_7 : complete_space F,	f : E → F,	f' : E →L[𝕜] F,	a : E,	hf : has_strict_fderiv_at f f' a,	hf' : f'.range = ⊤,	hker : f'.ker.closed_complemented,	x : ↥(f'.ker)	⊢ ⇑((has_strict_fderiv_at.implicit_function_data_of_complemented f f' hf hf' hker).left_deriv.comp (continuous_linear_map.subtype_val f'.ker)) x = ⇑0 x
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	_inst_4 : complete_space E,	F : Type u_3,	_inst_5 : normed_group F,	_inst_6 : normed_space 𝕜 F,	_inst_7 : complete_space F,	f : E → F,	f' : E →L[𝕜] F,	a : E,	hf : has_strict_fderiv_at f f' a,	hf' : f'.range = ⊤,	hker : f'.ker.closed_complemented	⊢ 0 = (has_strict_fderiv_at.implicit_function_data_of_complemented f f' hf hf' hker).right_fun (has_strict_fderiv_at.implicit_function_data_of_complemented f f' hf hf' hker).pt
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	_inst_3 : complete_space E,	φ : E → ℝ,	x₀ : E,	φ' : E →L[ℝ] ℝ,	ι : Type u_2,	_inst_7 : fintype ι,	f : ι → E → ℝ,	f' : ι → (E →L[ℝ] ℝ),	hf' : ∀ (i : ι), has_strict_fderiv_at (f i) (f' i) x₀,	hφ' : has_strict_fderiv_at φ φ' x₀,	_inst : decidable_eq ι := classical.dec_eq ι,	hextr : is_local_extr_on φ {x : E | (λ (i : ι), f i x) = λ (i : ι), f i x₀} x₀,	Λ₀ : ℝ,	Λ : ι → ℝ,	h0 : (⇑((linear_equiv.pi_ring ℝ ℝ ι ℝ).symm) Λ, Λ₀) ≠ 0,	hsum : ∀ (x : E), ⇑(⇑((linear_equiv.pi_ring ℝ ℝ ι ℝ).symm) Λ) (⇑(continuous_linear_map.pi (λ (i : ι), f' i)) x) + Λ₀ • ⇑φ' x = 0	⊢ ∃ (Λ : ι → ℝ) (Λ₀ : ℝ), (Λ, Λ₀) ≠ 0 ∧ ∑ (i : ι), Λ i • f' i + Λ₀ • φ' = 0
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	_inst_3 : complete_space E,	φ : E → ℝ,	x₀ : E,	φ' : E →L[ℝ] ℝ,	ι : Type u_2,	_inst_7 : fintype ι,	f : ι → E → ℝ,	f' : ι → (E →L[ℝ] ℝ),	hf' : ∀ (i : ι), has_strict_fderiv_at (f i) (f' i) x₀,	hφ' : has_strict_fderiv_at φ φ' x₀,	_inst : decidable_eq ι := classical.dec_eq ι,	hextr : is_local_extr_on φ {x : E | (λ (i : ι), f i x) = λ (i : ι), f i x₀} x₀,	Λ₀ : ℝ,	Λ : ι → ℝ,	h0 : (⇑((linear_equiv.pi_ring ℝ ℝ ι ℝ).symm) Λ, Λ₀) ≠ 0,	hsum : ∀ (x : E), ⇑(⇑((linear_equiv.pi_ring ℝ ℝ ι ℝ).symm) Λ) (⇑(continuous_linear_map.pi (λ (i : ι), f' i)) x) + Λ₀ • ⇑φ' x = 0	⊢ (Λ, Λ₀) ≠ 0
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	_inst_3 : complete_space E,	φ : E → ℝ,	x₀ : E,	φ' : E →L[ℝ] ℝ,	ι : Type u_2,	_inst_7 : fintype ι,	f : ι → E → ℝ,	f' : ι → (E →L[ℝ] ℝ),	hf' : ∀ (i : ι), has_strict_fderiv_at (f i) (f' i) x₀,	hφ' : has_strict_fderiv_at φ φ' x₀,	_inst : decidable_eq ι := classical.dec_eq ι,	hextr : is_local_extr_on φ {x : E | (λ (i : ι), f i x) = λ (i : ι), f i x₀} x₀,	Λ₀ : ℝ,	Λ : ι → ℝ,	h0 : (⇑((linear_equiv.pi_ring ℝ ℝ ι ℝ).symm) Λ, Λ₀) ≠ 0,	hsum : ∀ (x : E), ⇑(⇑((linear_equiv.pi_ring ℝ ℝ ι ℝ).symm) Λ) (⇑(continuous_linear_map.pi (λ (i : ι), f' i)) x) + Λ₀ • ⇑φ' x = 0	⊢ (Λ, Λ₀) ≠ 0		E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	_inst_3 : complete_space E,	φ : E → ℝ,	x₀ : E,	φ' : E →L[ℝ] ℝ,	ι : Type u_2,	_inst_7 : fintype ι,	f : ι → E → ℝ,	f' : ι → (E →L[ℝ] ℝ),	hf' : ∀ (i : ι), has_strict_fderiv_at (f i) (f' i) x₀,	hφ' : has_strict_fderiv_at φ φ' x₀,	_inst : decidable_eq ι := classical.dec_eq ι,	hextr : is_local_extr_on φ {x : E | (λ (i : ι), f i x) = λ (i : ι), f i x₀} x₀,	Λ₀ : ℝ,	Λ : ι → ℝ,	h0 : (⇑((linear_equiv.pi_ring ℝ ℝ ι ℝ).symm) Λ, Λ₀) ≠ 0,	hsum : ∀ (x : E), ⇑(⇑((linear_equiv.pi_ring ℝ ℝ ι ℝ).symm) Λ) (⇑(continuous_linear_map.pi (λ (i : ι), f' i)) x) + Λ₀ • ⇑φ' x = 0	⊢ ∑ (i : ι), Λ i • f' i + Λ₀ • φ' = 0
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	_inst_3 : complete_space E,	φ : E → ℝ,	x₀ : E,	φ' : E →L[ℝ] ℝ,	ι : Type u_2,	_inst_7 : fintype ι,	f : ι → E → ℝ,	f' : ι → (E →L[ℝ] ℝ),	hf' : ∀ (i : ι), has_strict_fderiv_at (f i) (f' i) x₀,	hφ' : has_strict_fderiv_at φ φ' x₀,	_inst : decidable_eq ι := classical.dec_eq ι,	hextr : is_local_extr_on φ {x : E | (λ (i : ι), f i x) = λ (i : ι), f i x₀} x₀,	Λ₀ : ℝ,	Λ : ι → ℝ,	h0 : (⇑((linear_equiv.pi_ring ℝ ℝ ι ℝ).symm) Λ, Λ₀) ≠ 0,	hsum : ∀ (x : E), ⇑(⇑((linear_equiv.pi_ring ℝ ℝ ι ℝ).symm) Λ) (⇑(continuous_linear_map.pi (λ (i : ι), f' i)) x) + Λ₀ • ⇑φ' x = 0,	x : E	⊢ ⇑(∑ (i : ι), Λ i • f' i + Λ₀ • φ') x = ⇑0 x
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	_inst_3 : complete_space E,	φ : E → ℝ,	x₀ : E,	φ' : E →L[ℝ] ℝ,	ι : Type u_2,	_inst_7 : fintype ι,	f : ι → E → ℝ,	f' : ι → (E →L[ℝ] ℝ),	hf' : ∀ (i : ι), has_strict_fderiv_at (f i) (f' i) x₀,	hφ' : has_strict_fderiv_at φ φ' x₀,	_inst : decidable_eq ι := classical.dec_eq ι,	hextr : is_local_extr_on φ {x : E | (λ (i : ι), f i x) = λ (i : ι), f i x₀} x₀,	Λ₀ : ℝ,	Λ : ι → ℝ,	h0 : (⇑((linear_equiv.pi_ring ℝ ℝ ι ℝ).symm) Λ, Λ₀) ≠ 0,	hsum : ∀ (x : E), ⇑(⇑((linear_equiv.pi_ring ℝ ℝ ι ℝ).symm) Λ) (⇑(continuous_linear_map.pi (λ (i : ι), f' i)) x) + Λ₀ • ⇑φ' x = 0	⊢ ∑ (i : ι), Λ i • f' i + Λ₀ • φ' = 0
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	_inst_3 : complete_space E,	φ : E → ℝ,	x₀ : E,	φ' : E →L[ℝ] ℝ,	ι : Type u_2,	_inst_7 : fintype ι,	f : ι → E → ℝ,	f' : ι → (E →L[ℝ] ℝ),	hextr : is_local_extr_on φ {x : E | ∀ (i : ι), f i x = f i x₀} x₀,	hf' : ∀ (i : ι), has_strict_fderiv_at (f i) (f' i) x₀,	hφ' : has_strict_fderiv_at φ φ' x₀	⊢ ∃ (Λ : ι → ℝ) (Λ₀ : ℝ), (Λ, Λ₀) ≠ 0 ∧ ∑ (i : ι), Λ i • f' i + Λ₀ • φ' = 0
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	_inst_3 : complete_space E,	φ : E → ℝ,	x₀ : E,	φ' : E →L[ℝ] ℝ,	ι : Type u_2,	_inst_7 : fintype ι,	f : ι → E → ℝ,	f' : ι → (E →L[ℝ] ℝ),	hextr : is_local_extr_on φ {x : E | ∀ (i : ι), f i x = f i x₀} x₀,	hf' : ∀ (i : ι), has_strict_fderiv_at (f i) (f' i) x₀,	hφ' : has_strict_fderiv_at φ φ' x₀,	_inst : decidable_eq ι := classical.dec_eq ι	⊢ ∃ (Λ : ι → ℝ) (Λ₀ : ℝ), (Λ, Λ₀) ≠ 0 ∧ ∑ (i : ι), Λ i • f' i + Λ₀ • φ' = 0
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	_inst_3 : complete_space E,	φ : E → ℝ,	x₀ : E,	φ' : E →L[ℝ] ℝ,	ι : Type u_2,	_inst_7 : fintype ι,	f : ι → E → ℝ,	f' : ι → (E →L[ℝ] ℝ),	hextr : is_local_extr_on φ {x : E | ∀ (i : ι), f i x = f i x₀} x₀,	hf' : ∀ (i : ι), has_strict_fderiv_at (f i) (f' i) x₀,	hφ' : has_strict_fderiv_at φ φ' x₀,	_inst : decidable_eq ι := classical.dec_eq ι	⊢ is_local_extr_on φ {x : E | (λ (i : ι), f i x) = λ (i : ι), f i x₀} x₀
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	_inst_3 : complete_space E,	φ : E → ℝ,	x₀ : E,	φ' : E →L[ℝ] ℝ,	ι : Type u_2,	_inst_7 : fintype ι,	f : ι → E → ℝ,	f' : ι → (E →L[ℝ] ℝ),	hf' : ∀ (i : ι), has_strict_fderiv_at (f i) (f' i) x₀,	hφ' : has_strict_fderiv_at φ φ' x₀,	_inst : decidable_eq ι := classical.dec_eq ι,	hextr : is_local_extr_on φ {x : E | (λ (i : ι), f i x) = λ (i : ι), f i x₀} x₀	⊢ ∃ (Λ : ι → ℝ) (Λ₀ : ℝ), (Λ, Λ₀) ≠ 0 ∧ ∑ (i : ι), Λ i • f' i + Λ₀ • φ' = 0
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	_inst_3 : complete_space E,	φ : E → ℝ,	x₀ : E,	φ' : E →L[ℝ] ℝ,	ι : Type u_2,	_inst_7 : fintype ι,	f : ι → E → ℝ,	f' : ι → (E →L[ℝ] ℝ),	hf' : ∀ (i : ι), has_strict_fderiv_at (f i) (f' i) x₀,	hφ' : has_strict_fderiv_at φ φ' x₀,	_inst : decidable_eq ι := classical.dec_eq ι,	hextr : is_local_extr_on φ {x : E | (λ (i : ι), f i x) = λ (i : ι), f i x₀} x₀,	Λ : module.dual ℝ (ι → ℝ),	Λ₀ : ℝ,	h0 : (Λ, Λ₀) ≠ 0,	hsum : ∀ (x : E), ⇑Λ (⇑(continuous_linear_map.pi (λ (i : ι), f' i)) x) + Λ₀ • ⇑φ' x = 0	⊢ ∃ (Λ : ι → ℝ) (Λ₀ : ℝ), (Λ, Λ₀) ≠ 0 ∧ ∑ (i : ι), Λ i • f' i + Λ₀ • φ' = 0
a b : ℝ,	hab : a < b,	l : filter ℝ,	f f' g g' : ℝ → ℝ,	hff' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at f (f' x) x,	hgg' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at g (g' x) x,	hcf : continuous_on f (set.Ico a b),	hcg : continuous_on g (set.Ico a b),	hg' : ∀ (x : ℝ), x ∈ set.Ioo a b → g' x ≠ 0,	hfa : f a = 0,	hga : g a = 0,	hdiv : filter.tendsto (λ (x : ℝ), f' x / g' x) (𝓝[set.Ioi a] a) l	⊢ filter.tendsto (λ (x : ℝ), f x / g x) (𝓝[set.Ioi a] a) l
a b : ℝ,	hab : a < b,	l : filter ℝ,	f f' g g' : ℝ → ℝ,	hff' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at f (f' x) x,	hgg' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at g (g' x) x,	hcf : continuous_on f (set.Ico a b),	hcg : continuous_on g (set.Ico a b),	hg' : ∀ (x : ℝ), x ∈ set.Ioo a b → g' x ≠ 0,	hfa : f a = 0,	hga : g a = 0,	hdiv : filter.tendsto (λ (x : ℝ), f' x / g' x) (𝓝[set.Ioi a] a) l	⊢ filter.tendsto (λ (x : ℝ), f x) (𝓝[set.Ioi a] a) (𝓝 0)
a b : ℝ,	hab : a < b,	l : filter ℝ,	f f' g g' : ℝ → ℝ,	hff' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at f (f' x) x,	hgg' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at g (g' x) x,	hcf : continuous_on f (set.Ico a b),	hcg : continuous_on g (set.Ico a b),	hg' : ∀ (x : ℝ), x ∈ set.Ioo a b → g' x ≠ 0,	hfa : f a = 0,	hga : g a = 0,	hdiv : filter.tendsto (λ (x : ℝ), f' x / g' x) (𝓝[set.Ioi a] a) l	⊢ filter.tendsto (λ (x : ℝ), f x) (𝓝[set.Ioo a b] a) (𝓝 (f a))
a b : ℝ,	hab : a < b,	l : filter ℝ,	f f' g g' : ℝ → ℝ,	hff' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at f (f' x) x,	hgg' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at g (g' x) x,	hcf : continuous_on f (set.Ico a b),	hcg : continuous_on g (set.Ico a b),	hg' : ∀ (x : ℝ), x ∈ set.Ioo a b → g' x ≠ 0,	hfa : f a = 0,	hga : g a = 0,	hdiv : filter.tendsto (λ (x : ℝ), f' x / g' x) (𝓝[set.Ioi a] a) l	⊢ filter.tendsto (λ (x : ℝ), f x) (𝓝[set.Ioi a] a) (𝓝 0)		a b : ℝ,	hab : a < b,	l : filter ℝ,	f f' g g' : ℝ → ℝ,	hff' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at f (f' x) x,	hgg' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at g (g' x) x,	hcf : continuous_on f (set.Ico a b),	hcg : continuous_on g (set.Ico a b),	hg' : ∀ (x : ℝ), x ∈ set.Ioo a b → g' x ≠ 0,	hfa : f a = 0,	hga : g a = 0,	hdiv : filter.tendsto (λ (x : ℝ), f' x / g' x) (𝓝[set.Ioi a] a) l	⊢ filter.tendsto (λ (x : ℝ), g x) (𝓝[set.Ioi a] a) (𝓝 0)
a b : ℝ,	hab : a < b,	l : filter ℝ,	f f' g g' : ℝ → ℝ,	hff' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at f (f' x) x,	hgg' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at g (g' x) x,	hcf : continuous_on f (set.Ico a b),	hcg : continuous_on g (set.Ico a b),	hg' : ∀ (x : ℝ), x ∈ set.Ioo a b → g' x ≠ 0,	hfa : f a = 0,	hga : g a = 0,	hdiv : filter.tendsto (λ (x : ℝ), f' x / g' x) (𝓝[set.Ioi a] a) l	⊢ filter.tendsto (λ (x : ℝ), g x) (𝓝[set.Ioi a] a) (𝓝 0)
a b : ℝ,	hab : a < b,	l : filter ℝ,	f f' g g' : ℝ → ℝ,	hff' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at f (f' x) x,	hgg' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at g (g' x) x,	hcf : continuous_on f (set.Ico a b),	hcg : continuous_on g (set.Ico a b),	hg' : ∀ (x : ℝ), x ∈ set.Ioo a b → g' x ≠ 0,	hfa : f a = 0,	hga : g a = 0,	hdiv : filter.tendsto (λ (x : ℝ), f' x / g' x) (𝓝[set.Ioi a] a) l	⊢ filter.tendsto (λ (x : ℝ), g x) (𝓝[set.Ioo a b] a) (𝓝 (g a))
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s	⊢ ∃ (z : E) (H : z ∈ segment ℝ x y), f y - f x = ⇑(f' z) (y - x)
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : set.Ioo 0 1 ⊆ set.Icc 0 1	⊢ ∃ (z : E) (H : z ∈ segment ℝ x y), f y - f x = ⇑(f' z) (y - x)
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : set.Ioo 0 1 ⊆ set.Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x)	⊢ ∃ (z : E) (H : z ∈ segment ℝ x y), f y - f x = ⇑(f' z) (y - x)
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : set.Ioo 0 1 ⊆ set.Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x)	⊢ ∀ (t : ℝ), t ∈ set.Icc 0 1 → g t ∈ segment ℝ x y
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : set.Ioo 0 1 ⊆ set.Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x)	⊢ ∀ (t : ℝ), t ∈ set.Icc 0 1 → g t ∈ (λ (θ : ℝ), x + θ • (y - x)) '' set.Icc 0 1
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : set.Ioo 0 1 ⊆ set.Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	t : ℝ,	ht : t ∈ set.Icc 0 1	⊢ ∃ (x_1 : ℝ), x_1 ∈ set.Icc 0 1 ∧ x_1 • (y - x) = t • (y - x)
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : set.Ioo 0 1 ⊆ set.Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x)	⊢ ∀ (t : ℝ), t ∈ set.Icc 0 1 → g t ∈ segment ℝ x y		E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : set.Ioo 0 1 ⊆ set.Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → g t ∈ segment ℝ x y	⊢ ∃ (z : E) (H : z ∈ segment ℝ x y), f y - f x = ⇑(f' z) (y - x)
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : set.Ioo 0 1 ⊆ set.Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x)	⊢ ∀ (t : ℝ), t ∈ set.Icc 0 1 → (∃ (x_1 : ℝ), x_1 ∈ set.Icc 0 1 ∧ x_1 • (y - x) = t • (y - x))
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : set.Ioo 0 1 ⊆ set.Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → g t ∈ segment ℝ x y	⊢ ∃ (z : E) (H : z ∈ segment ℝ x y), f y - f x = ⇑(f' z) (y - x)
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : set.Ioo 0 1 ⊆ set.Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → g t ∈ segment ℝ x y	⊢ g '' set.Icc 0 1 ⊆ s
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : set.Ioo 0 1 ⊆ set.Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → g t ∈ segment ℝ x y	⊢ {b : E | ∃ (a : ℝ), a ∈ set.Icc 0 1 ∧ g a = b} ⊆ s
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : set.Ioo 0 1 ⊆ set.Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → g t ∈ segment ℝ x y	⊢ set.Icc 0 1 ⊆ g ⁻¹' s
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : set.Ioo 0 1 ⊆ set.Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → g t ∈ segment ℝ x y,	z : E,	Hz : z ∈ {b : E | ∃ (a : ℝ), a ∈ set.Icc 0 1 ∧ g a = b}	⊢ z ∈ s
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : set.Ioo 0 1 ⊆ set.Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → g t ∈ segment ℝ x y,	z : E,	Hz : ∃ (a : ℝ), a ∈ set.Icc 0 1 ∧ g a = z	⊢ z ∈ s
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : set.Ioo 0 1 ⊆ set.Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → g t ∈ segment ℝ x y	⊢ ∀ (_x : E), _x ∈ {b : E | ∃ (a : ℝ), a ∈ set.Icc 0 1 ∧ g a = b} → _x ∈ s
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : set.Ioo 0 1 ⊆ set.Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → g t ∈ segment ℝ x y,	z : E,	t : ℝ,	Ht : t ∈ set.Icc 0 1,	hgt : g t = z	⊢ g t ∈ s
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : set.Ioo 0 1 ⊆ set.Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → g t ∈ segment ℝ x y	⊢ set.Icc 0 1 ⊆ g ⁻¹' s		E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : set.Ioo 0 1 ⊆ set.Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : set.Icc 0 1 ⊆ g ⁻¹' s	⊢ ∃ (z : E) (H : z ∈ segment ℝ x y), f y - f x = ⇑(f' z) (y - x)
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : set.Ioo 0 1 ⊆ set.Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → g t ∈ segment ℝ x y,	z : E,	t : ℝ,	Ht : t ∈ set.Icc 0 1,	hgt : g t = z	⊢ z ∈ s
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : set.Ioo 0 1 ⊆ set.Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : set.Icc 0 1 ⊆ g ⁻¹' s	⊢ ∃ (z : E) (H : z ∈ segment ℝ x y), f y - f x = ⇑(f' z) (y - x)
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : set.Ioo 0 1 ⊆ set.Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : set.Icc 0 1 ⊆ g ⁻¹' s	⊢ ∀ (t : ℝ), t ∈ set.Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (set.Icc 0 1) t
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : set.Ioo 0 1 ⊆ set.Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : set.Icc 0 1 ⊆ g ⁻¹' s,	t : ℝ,	Ht : t ∈ set.Icc 0 1	⊢ has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (set.Icc 0 1) t
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : set.Ioo 0 1 ⊆ set.Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : set.Icc 0 1 ⊆ g ⁻¹' s,	t : ℝ,	Ht : t ∈ set.Icc 0 1	⊢ has_deriv_at g (y - x) t
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : set.Ioo 0 1 ⊆ set.Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : set.Icc 0 1 ⊆ g ⁻¹' s,	t : ℝ,	Ht : t ∈ set.Icc 0 1	⊢ has_deriv_at g (y - x) t		E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : set.Ioo 0 1 ⊆ set.Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : set.Icc 0 1 ⊆ g ⁻¹' s,	t : ℝ,	Ht : t ∈ set.Icc 0 1,	hg : has_deriv_at g (y - x) t	⊢ has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (set.Icc 0 1) t
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : set.Ioo 0 1 ⊆ set.Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : set.Icc 0 1 ⊆ g ⁻¹' s,	t : ℝ,	Ht : t ∈ set.Icc 0 1,	this : has_deriv_at (λ (x_1 : ℝ), x + (λ (y_1 : ℝ), id y_1 • (y - x)) x_1) (1 • (y - x)) t	⊢ has_deriv_at g (y - x) t
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : set.Ioo 0 1 ⊆ set.Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : set.Icc 0 1 ⊆ g ⁻¹' s,	t : ℝ,	Ht : t ∈ set.Icc 0 1,	hg : has_deriv_at g (y - x) t	⊢ has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (set.Icc 0 1) t
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : set.Ioo 0 1 ⊆ set.Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : set.Icc 0 1 ⊆ g ⁻¹' s	⊢ ∀ (t : ℝ), t ∈ set.Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (set.Icc 0 1) t		E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : set.Ioo 0 1 ⊆ set.Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : set.Icc 0 1 ⊆ g ⁻¹' s,	hfg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (set.Icc 0 1) t	⊢ ∃ (z : E) (H : z ∈ segment ℝ x y), f y - f x = ⇑(f' z) (y - x)
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : set.Ioo 0 1 ⊆ set.Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : set.Icc 0 1 ⊆ g ⁻¹' s,	hfg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (set.Icc 0 1) t	⊢ ∃ (z : E) (H : z ∈ segment ℝ x y), f y - f x = ⇑(f' z) (y - x)
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : set.Ioo 0 1 ⊆ set.Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : set.Icc 0 1 ⊆ g ⁻¹' s,	hfg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (set.Icc 0 1) t	⊢ 0 < 1
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : set.Ioo 0 1 ⊆ set.Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : set.Icc 0 1 ⊆ g ⁻¹' s,	hfg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (set.Icc 0 1) t	⊢ ∃ (t : ℝ) (H : t ∈ set.Ioo 0 1), ⇑(f' (g t)) (y - x) = (f (g 1) - f (g 0)) / (1 - 0)
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : set.Ioo 0 1 ⊆ set.Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : set.Icc 0 1 ⊆ g ⁻¹' s,	hfg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (set.Icc 0 1) t	⊢ continuous_on (f ∘ g) (set.Icc 0 1)
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : set.Ioo 0 1 ⊆ set.Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : set.Icc 0 1 ⊆ g ⁻¹' s,	hfg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (set.Icc 0 1) t	⊢ continuous_on (f ∘ g) (set.Icc 0 1)		E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : set.Ioo 0 1 ⊆ set.Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : set.Icc 0 1 ⊆ g ⁻¹' s,	hfg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (set.Icc 0 1) t	⊢ ∀ (x_1 : ℝ), x_1 ∈ set.Ioo 0 1 → has_deriv_at (f ∘ g) (⇑(f' (g x_1)) (y - x)) x_1
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : set.Ioo 0 1 ⊆ set.Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : set.Icc 0 1 ⊆ g ⁻¹' s,	hfg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (set.Icc 0 1) t	⊢ ∀ (x : ℝ), x ∈ set.Icc 0 1 → continuous_within_at (f ∘ g) (set.Icc 0 1) x
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : set.Ioo 0 1 ⊆ set.Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : set.Icc 0 1 ⊆ g ⁻¹' s,	hfg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (set.Icc 0 1) t	⊢ ∀ (x_1 : ℝ), x_1 ∈ set.Ioo 0 1 → has_deriv_at (f ∘ g) (⇑(f' (g x_1)) (y - x)) x_1
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : set.Ioo 0 1 ⊆ set.Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : set.Icc 0 1 ⊆ g ⁻¹' s,	hfg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (set.Icc 0 1) t,	t : ℝ,	Ht : t ∈ set.Ioo 0 1	⊢ set.Icc 0 1 ∈ 𝓝 t
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : set.Ioo 0 1 ⊆ set.Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : set.Icc 0 1 ⊆ g ⁻¹' s,	hfg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (set.Icc 0 1) t,	t : ℝ,	Ht : t ∈ set.Ioo 0 1	⊢ ∃ (t_1 : set ℝ) (H : t_1 ⊆ set.Icc 0 1), is_open t_1 ∧ t ∈ t_1
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : set.Ioo 0 1 ⊆ set.Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : set.Icc 0 1 ⊆ g ⁻¹' s,	hfg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (set.Icc 0 1) t,	t : ℝ,	Ht : t ∈ set.Ioo 0 1	⊢ set.Ioo 0 1 ⊆ set.Icc 0 1 ∧ is_open (set.Ioo 0 1) ∧ t ∈ set.Ioo 0 1
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : set.Ioo 0 1 ⊆ set.Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : set.Icc 0 1 ⊆ g ⁻¹' s,	hfg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (set.Icc 0 1) t	⊢ ∃ (t : ℝ) (H : t ∈ set.Ioo 0 1), ⇑(f' (g t)) (y - x) = (f (g 1) - f (g 0)) / (1 - 0)		E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : set.Ioo 0 1 ⊆ set.Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : set.Icc 0 1 ⊆ g ⁻¹' s,	hfg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (set.Icc 0 1) t,	hMVT : ∃ (t : ℝ) (H : t ∈ set.Ioo 0 1), ⇑(f' (g t)) (y - x) = (f (g 1) - f (g 0)) / (1 - 0)	⊢ ∃ (z : E) (H : z ∈ segment ℝ x y), f y - f x = ⇑(f' z) (y - x)
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : set.Ioo 0 1 ⊆ set.Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : set.Icc 0 1 ⊆ g ⁻¹' s,	hfg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (set.Icc 0 1) t,	t : ℝ,	Ht : t ∈ set.Ioo 0 1	⊢ is_open (set.Ioo 0 1)
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : set.Ioo 0 1 ⊆ set.Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : set.Icc 0 1 ⊆ g ⁻¹' s,	hfg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (set.Icc 0 1) t,	hMVT : ∃ (t : ℝ) (H : t ∈ set.Ioo 0 1), ⇑(f' (g t)) (y - x) = (f (g 1) - f (g 0)) / (1 - 0)	⊢ ∃ (z : E) (H : z ∈ segment ℝ x y), f y - f x = ⇑(f' z) (y - x)
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : set.Ioo 0 1 ⊆ set.Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : set.Icc 0 1 ⊆ g ⁻¹' s,	hfg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (set.Icc 0 1) t,	t : ℝ,	Ht : t ∈ set.Ioo 0 1,	hMVT' : ⇑(f' (g t)) (y - x) = (f (g 1) - f (g 0)) / (1 - 0)	⊢ g t ∈ segment ℝ x y ∧ f y - f x = ⇑(f' (g t)) (y - x)
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : set.Ioo 0 1 ⊆ set.Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : set.Icc 0 1 ⊆ g ⁻¹' s,	hfg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (set.Icc 0 1) t,	t : ℝ,	Ht : t ∈ set.Ioo 0 1,	hMVT' : ⇑(f' (g t)) (y - x) = (f (g 1) - f (g 0)) / (1 - 0)	⊢ ∃ (z : E) (H : z ∈ segment ℝ x y), f y - f x = ⇑(f' z) (y - x)
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : set.Ioo 0 1 ⊆ set.Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : set.Icc 0 1 ⊆ g ⁻¹' s,	hfg : ∀ (t : ℝ), t ∈ set.Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (set.Icc 0 1) t,	t : ℝ,	Ht : t ∈ set.Ioo 0 1,	hMVT' : ⇑(f' (g t)) (y - x) = (f (g 1) - f (g 0)) / (1 - 0)	⊢ f y - f x = ⇑(f' (g t)) (y - x)
F : Type u_2,	_inst_3 : normed_group F,	_inst_4 : normed_space ℝ F,	f f' : ℝ → F,	C : ℝ,	s : set ℝ,	x y : ℝ,	hf : ∀ (x : ℝ), x ∈ s → has_deriv_within_at f (f' x) s x,	bound : ∀ (x : ℝ), x ∈ s → ∥f' x∥ ≤ C,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	x : ℝ,	hx : x ∈ s	⊢ ∥1.smul_right (f' x)∥ ≤ ∥f' x∥
f f' : ℝ → ℝ,	a b : ℝ,	hab : a < b,	hfc : continuous_on f (set.Icc a b),	hff' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at f (f' x) x,	g g' : ℝ → ℝ,	hgc : continuous_on g (set.Icc a b),	hgg' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at g (g' x) x	⊢ ∃ (c : ℝ) (H : c ∈ set.Ioo a b), (g b - g a) * f' c = (f b - f a) * g' c
f f' : ℝ → ℝ,	a b : ℝ,	hab : a < b,	hfc : continuous_on f (set.Icc a b),	hff' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at f (f' x) x,	g g' : ℝ → ℝ,	hgc : continuous_on g (set.Icc a b),	hgg' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at g (g' x) x,	h : ℝ → ℝ := λ (x : ℝ), (g b - g a) * f x - (f b - f a) * g x	⊢ ∃ (c : ℝ) (H : c ∈ set.Ioo a b), (g b - g a) * f' c = (f b - f a) * g' c
f f' : ℝ → ℝ,	a b : ℝ,	hab : a < b,	hfc : continuous_on f (set.Icc a b),	hff' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at f (f' x) x,	g g' : ℝ → ℝ,	hgc : continuous_on g (set.Icc a b),	hgg' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at g (g' x) x,	h : ℝ → ℝ := λ (x : ℝ), (g b - g a) * f x - (f b - f a) * g x	⊢ (g b - g a) * f a - (f b - f a) * g a = (g b - g a) * f b - (f b - f a) * g b
f f' : ℝ → ℝ,	a b : ℝ,	hab : a < b,	hfc : continuous_on f (set.Icc a b),	hff' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at f (f' x) x,	g g' : ℝ → ℝ,	hgc : continuous_on g (set.Icc a b),	hgg' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at g (g' x) x,	h : ℝ → ℝ := λ (x : ℝ), (g b - g a) * f x - (f b - f a) * g x	⊢ h a = h b		f f' : ℝ → ℝ,	a b : ℝ,	hab : a < b,	hfc : continuous_on f (set.Icc a b),	hff' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at f (f' x) x,	g g' : ℝ → ℝ,	hgc : continuous_on g (set.Icc a b),	hgg' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at g (g' x) x,	h : ℝ → ℝ := λ (x : ℝ), (g b - g a) * f x - (f b - f a) * g x,	hI : h a = h b	⊢ ∃ (c : ℝ) (H : c ∈ set.Ioo a b), (g b - g a) * f' c = (f b - f a) * g' c
f f' : ℝ → ℝ,	a b : ℝ,	hab : a < b,	hfc : continuous_on f (set.Icc a b),	hff' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at f (f' x) x,	g g' : ℝ → ℝ,	hgc : continuous_on g (set.Icc a b),	hgg' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at g (g' x) x,	h : ℝ → ℝ := λ (x : ℝ), (g b - g a) * f x - (f b - f a) * g x	⊢ h a = h b
f f' : ℝ → ℝ,	a b : ℝ,	hab : a < b,	hfc : continuous_on f (set.Icc a b),	hff' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at f (f' x) x,	g g' : ℝ → ℝ,	hgc : continuous_on g (set.Icc a b),	hgg' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at g (g' x) x,	h : ℝ → ℝ := λ (x : ℝ), (g b - g a) * f x - (f b - f a) * g x,	hI : h a = h b	⊢ ∃ (c : ℝ) (H : c ∈ set.Ioo a b), (g b - g a) * f' c = (f b - f a) * g' c
f f' : ℝ → ℝ,	a b : ℝ,	hab : a < b,	hfc : continuous_on f (set.Icc a b),	hff' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at f (f' x) x,	g g' : ℝ → ℝ,	hgc : continuous_on g (set.Icc a b),	hgg' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at g (g' x) x,	h : ℝ → ℝ := λ (x : ℝ), (g b - g a) * f x - (f b - f a) * g x,	hI : h a = h b,	h' : ℝ → ℝ := λ (x : ℝ), (g b - g a) * f' x - (f b - f a) * g' x	⊢ ∃ (c : ℝ) (H : c ∈ set.Ioo a b), (g b - g a) * f' c = (f b - f a) * g' c
f f' : ℝ → ℝ,	a b : ℝ,	hab : a < b,	hfc : continuous_on f (set.Icc a b),	hff' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at f (f' x) x,	g g' : ℝ → ℝ,	hgc : continuous_on g (set.Icc a b),	hgg' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at g (g' x) x,	h : ℝ → ℝ := λ (x : ℝ), (g b - g a) * f x - (f b - f a) * g x,	hI : h a = h b,	h' : ℝ → ℝ := λ (x : ℝ), (g b - g a) * f' x - (f b - f a) * g' x	⊢ ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at h (h' x) x		f f' : ℝ → ℝ,	a b : ℝ,	hab : a < b,	hfc : continuous_on f (set.Icc a b),	hff' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at f (f' x) x,	g g' : ℝ → ℝ,	hgc : continuous_on g (set.Icc a b),	hgg' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at g (g' x) x,	h : ℝ → ℝ := λ (x : ℝ), (g b - g a) * f x - (f b - f a) * g x,	hI : h a = h b,	h' : ℝ → ℝ := λ (x : ℝ), (g b - g a) * f' x - (f b - f a) * g' x,	hhh' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at h (h' x) x	⊢ ∃ (c : ℝ) (H : c ∈ set.Ioo a b), (g b - g a) * f' c = (f b - f a) * g' c
f f' : ℝ → ℝ,	a b : ℝ,	hab : a < b,	hfc : continuous_on f (set.Icc a b),	hff' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at f (f' x) x,	g g' : ℝ → ℝ,	hgc : continuous_on g (set.Icc a b),	hgg' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at g (g' x) x,	h : ℝ → ℝ := λ (x : ℝ), (g b - g a) * f x - (f b - f a) * g x,	hI : h a = h b,	h' : ℝ → ℝ := λ (x : ℝ), (g b - g a) * f' x - (f b - f a) * g' x,	hhh' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at h (h' x) x	⊢ ∃ (c : ℝ) (H : c ∈ set.Ioo a b), (g b - g a) * f' c = (f b - f a) * g' c
f f' : ℝ → ℝ,	a b : ℝ,	hab : a < b,	hfc : continuous_on f (set.Icc a b),	hff' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at f (f' x) x,	g g' : ℝ → ℝ,	hgc : continuous_on g (set.Icc a b),	hgg' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at g (g' x) x,	h : ℝ → ℝ := λ (x : ℝ), (g b - g a) * f x - (f b - f a) * g x,	hI : h a = h b,	h' : ℝ → ℝ := λ (x : ℝ), (g b - g a) * f' x - (f b - f a) * g' x,	hhh' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at h (h' x) x	⊢ continuous_on h (set.Icc a b)		f f' : ℝ → ℝ,	a b : ℝ,	hab : a < b,	hfc : continuous_on f (set.Icc a b),	hff' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at f (f' x) x,	g g' : ℝ → ℝ,	hgc : continuous_on g (set.Icc a b),	hgg' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at g (g' x) x,	h : ℝ → ℝ := λ (x : ℝ), (g b - g a) * f x - (f b - f a) * g x,	hI : h a = h b,	h' : ℝ → ℝ := λ (x : ℝ), (g b - g a) * f' x - (f b - f a) * g' x,	hhh' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at h (h' x) x,	hhc : continuous_on h (set.Icc a b)	⊢ ∃ (c : ℝ) (H : c ∈ set.Ioo a b), (g b - g a) * f' c = (f b - f a) * g' c
f f' : ℝ → ℝ,	a b : ℝ,	hab : a < b,	hfc : continuous_on f (set.Icc a b),	hff' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at f (f' x) x,	g g' : ℝ → ℝ,	hgc : continuous_on g (set.Icc a b),	hgg' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at g (g' x) x,	h : ℝ → ℝ := λ (x : ℝ), (g b - g a) * f x - (f b - f a) * g x,	hI : h a = h b,	h' : ℝ → ℝ := λ (x : ℝ), (g b - g a) * f' x - (f b - f a) * g' x,	hhh' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at h (h' x) x,	hhc : continuous_on h (set.Icc a b)	⊢ ∃ (c : ℝ) (H : c ∈ set.Ioo a b), (g b - g a) * f' c = (f b - f a) * g' c
f f' : ℝ → ℝ,	a b : ℝ,	hab : a < b,	hfc : continuous_on f (set.Icc a b),	hff' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at f (f' x) x,	g g' : ℝ → ℝ,	hgc : continuous_on g (set.Icc a b),	hgg' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at g (g' x) x,	h : ℝ → ℝ := λ (x : ℝ), (g b - g a) * f x - (f b - f a) * g x,	hI : h a = h b,	h' : ℝ → ℝ := λ (x : ℝ), (g b - g a) * f' x - (f b - f a) * g' x,	hhh' : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_at h (h' x) x,	hhc : continuous_on h (set.Icc a b),	c : ℝ,	cmem : c ∈ set.Ioo a b,	hc : h' c = 0	⊢ ∃ (c : ℝ) (H : c ∈ set.Ioo a b), (g b - g a) * f' c = (f b - f a) * g' c
D : set ℝ,	hD : convex ℝ D,	f : ℝ → ℝ,	hf : continuous_on f D,	hf' : differentiable_on ℝ f (interior D),	hf'_nonpos : ∀ (x : ℝ), x ∈ interior D → deriv f x ≤ 0	⊢ ∀ (x y : ℝ), x ∈ D → y ∈ D → x ≤ y → f y ≤ f x
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space ℝ E,	_inst_4 : complete_space E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : measurable_space E,	_inst_7 : borel_space E,	F : ℝ → α → E,	F' : α → E,	x₀ ε : ℝ,	ε_pos : 0 < ε,	hF_meas : ∀ᶠ (x : ℝ) in 𝓝 x₀, ae_measurable (F x) μ,	hF_int : measure_theory.integrable (F x₀) μ,	hF'_meas : ae_measurable F' μ,	bound : α → ℝ,	h_lipsch : ∀ᵐ (a : α) ∂μ, lipschitz_on_with (⇑real.nnabs (bound a)) (λ (x : ℝ), F x a) (metric.ball x₀ ε),	bound_integrable : measure_theory.integrable bound μ,	h_diff : ∀ᵐ (a : α) ∂μ, has_deriv_at (λ (x : ℝ), F x a) (F' a) x₀	⊢ measure_theory.integrable F' μ ∧ has_deriv_at (λ (x : ℝ), ∫ (a : α), F x a ∂μ) (∫ (a : α), F' a ∂μ) x₀
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space ℝ E,	_inst_4 : complete_space E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : measurable_space E,	_inst_7 : borel_space E,	F : ℝ → α → E,	F' : α → E,	x₀ ε : ℝ,	ε_pos : 0 < ε,	hF_meas : ∀ᶠ (x : ℝ) in 𝓝 x₀, ae_measurable (F x) μ,	hF_int : measure_theory.integrable (F x₀) μ,	hF'_meas : ae_measurable F' μ,	bound : α → ℝ,	h_lipsch : ∀ᵐ (a : α) ∂μ, lipschitz_on_with (⇑real.nnabs (bound a)) (λ (x : ℝ), F x a) (metric.ball x₀ ε),	bound_integrable : measure_theory.integrable bound μ,	h_diff : ∀ᵐ (a : α) ∂μ, has_deriv_at (λ (x : ℝ), F x a) (F' a) x₀,	hm : ae_measurable (⇑(⇑(continuous_linear_map.smul_rightL ℝ ℝ E) 1) ∘ F') μ	⊢ measure_theory.integrable F' μ ∧ has_deriv_at (λ (x : ℝ), ∫ (a : α), F x a ∂μ) (∫ (a : α), F' a ∂μ) x₀
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space ℝ E,	_inst_4 : complete_space E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : measurable_space E,	_inst_7 : borel_space E,	F : ℝ → α → E,	F' : α → E,	x₀ ε : ℝ,	ε_pos : 0 < ε,	hF_meas : ∀ᶠ (x : ℝ) in 𝓝 x₀, ae_measurable (F x) μ,	hF_int : measure_theory.integrable (F x₀) μ,	hF'_meas : ae_measurable F' μ,	bound : α → ℝ,	h_lipsch : ∀ᵐ (a : α) ∂μ, lipschitz_on_with (⇑real.nnabs (bound a)) (λ (x : ℝ), F x a) (metric.ball x₀ ε),	bound_integrable : measure_theory.integrable bound μ,	h_diff : ∀ᵐ (a : α) ∂μ, has_deriv_at (λ (x : ℝ), F x a) (F' a) x₀,	hm : ae_measurable (⇑(⇑(continuous_linear_map.smul_rightL ℝ ℝ E) 1) ∘ F') μ,	hF'_int : measure_theory.integrable (⇑(⇑(continuous_linear_map.smul_rightL ℝ ℝ E) 1) ∘ F') μ,	key : has_fderiv_at (λ (x : ℝ), ∫ (a : α), (λ (x : ℝ), F x) x a ∂μ) (∫ (a : α), (⇑(⇑(continuous_linear_map.smul_rightL ℝ ℝ E) 1) ∘ F') a ∂μ) x₀	⊢ measure_theory.integrable F' μ ∧ has_deriv_at (λ (x : ℝ), ∫ (a : α), F x a ∂μ) (∫ (a : α), F' a ∂μ) x₀
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space ℝ E,	_inst_4 : complete_space E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : measurable_space E,	_inst_7 : borel_space E,	F : ℝ → α → E,	F' : α → E,	x₀ ε : ℝ,	ε_pos : 0 < ε,	hF_meas : ∀ᶠ (x : ℝ) in 𝓝 x₀, ae_measurable (F x) μ,	hF_int : measure_theory.integrable (F x₀) μ,	hF'_meas : ae_measurable F' μ,	bound : α → ℝ,	h_lipsch : ∀ᵐ (a : α) ∂μ, lipschitz_on_with (⇑real.nnabs (bound a)) (λ (x : ℝ), F x a) (metric.ball x₀ ε),	bound_integrable : measure_theory.integrable bound μ,	h_diff : ∀ᵐ (a : α) ∂μ, has_deriv_at (λ (x : ℝ), F x a) (F' a) x₀,	hm : ae_measurable (⇑(⇑(continuous_linear_map.smul_rightL ℝ ℝ E) 1) ∘ F') μ,	hF'_int : measure_theory.integrable (⇑(⇑(continuous_linear_map.smul_rightL ℝ ℝ E) 1) ∘ F') μ,	key : has_fderiv_at (λ (x : ℝ), ∫ (a : α), (λ (x : ℝ), F x) x a ∂μ) (∫ (a : α), (⇑(⇑(continuous_linear_map.smul_rightL ℝ ℝ E) 1) ∘ F') a ∂μ) x₀	⊢ measure_theory.integrable F' μ
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space ℝ E,	_inst_4 : complete_space E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : measurable_space E,	_inst_7 : borel_space E,	F : ℝ → α → E,	F' : α → E,	x₀ ε : ℝ,	ε_pos : 0 < ε,	hF_meas : ∀ᶠ (x : ℝ) in 𝓝 x₀, ae_measurable (F x) μ,	hF_int : measure_theory.integrable (F x₀) μ,	hF'_meas : ae_measurable F' μ,	bound : α → ℝ,	h_lipsch : ∀ᵐ (a : α) ∂μ, lipschitz_on_with (⇑real.nnabs (bound a)) (λ (x : ℝ), F x a) (metric.ball x₀ ε),	bound_integrable : measure_theory.integrable bound μ,	h_diff : ∀ᵐ (a : α) ∂μ, has_deriv_at (λ (x : ℝ), F x a) (F' a) x₀,	hm : ae_measurable (⇑(⇑(continuous_linear_map.smul_rightL ℝ ℝ E) 1) ∘ F') μ,	key : has_fderiv_at (λ (x : ℝ), ∫ (a : α), (λ (x : ℝ), F x) x a ∂μ) (∫ (a : α), (⇑(⇑(continuous_linear_map.smul_rightL ℝ ℝ E) 1) ∘ F') a ∂μ) x₀,	hF'_int : measure_theory.integrable (λ (a : α), ∥(⇑(⇑(continuous_linear_map.smul_rightL ℝ ℝ E) 1) ∘ F') a∥) μ	⊢ measure_theory.integrable F' μ
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space ℝ E,	_inst_4 : complete_space E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : measurable_space E,	_inst_7 : borel_space E,	F : ℝ → α → E,	F' : α → E,	x₀ ε : ℝ,	ε_pos : 0 < ε,	hF_meas : ∀ᶠ (x : ℝ) in 𝓝 x₀, ae_measurable (F x) μ,	hF_int : measure_theory.integrable (F x₀) μ,	hF'_meas : ae_measurable F' μ,	bound : α → ℝ,	h_lipsch : ∀ᵐ (a : α) ∂μ, lipschitz_on_with (⇑real.nnabs (bound a)) (λ (x : ℝ), F x a) (metric.ball x₀ ε),	bound_integrable : measure_theory.integrable bound μ,	h_diff : ∀ᵐ (a : α) ∂μ, has_deriv_at (λ (x : ℝ), F x a) (F' a) x₀,	hm : ae_measurable (⇑(⇑(continuous_linear_map.smul_rightL ℝ ℝ E) 1) ∘ F') μ,	hF'_int : measure_theory.integrable (⇑(⇑(continuous_linear_map.smul_rightL ℝ ℝ E) 1) ∘ F') μ,	key : has_fderiv_at (λ (x : ℝ), ∫ (a : α), (λ (x : ℝ), F x) x a ∂μ) (∫ (a : α), (⇑(⇑(continuous_linear_map.smul_rightL ℝ ℝ E) 1) ∘ F') a ∂μ) x₀	⊢ measure_theory.integrable F' μ		α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space ℝ E,	_inst_4 : complete_space E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : measurable_space E,	_inst_7 : borel_space E,	F : ℝ → α → E,	F' : α → E,	x₀ ε : ℝ,	ε_pos : 0 < ε,	hF_meas : ∀ᶠ (x : ℝ) in 𝓝 x₀, ae_measurable (F x) μ,	hF_int : measure_theory.integrable (F x₀) μ,	hF'_meas : ae_measurable F' μ,	bound : α → ℝ,	h_lipsch : ∀ᵐ (a : α) ∂μ, lipschitz_on_with (⇑real.nnabs (bound a)) (λ (x : ℝ), F x a) (metric.ball x₀ ε),	bound_integrable : measure_theory.integrable bound μ,	h_diff : ∀ᵐ (a : α) ∂μ, has_deriv_at (λ (x : ℝ), F x a) (F' a) x₀,	hm : ae_measurable (⇑(⇑(continuous_linear_map.smul_rightL ℝ ℝ E) 1) ∘ F') μ,	key : has_fderiv_at (λ (x : ℝ), ∫ (a : α), (λ (x : ℝ), F x) x a ∂μ) (∫ (a : α), (⇑(⇑(continuous_linear_map.smul_rightL ℝ ℝ E) 1) ∘ F') a ∂μ) x₀,	hF'_int : measure_theory.integrable F' μ	⊢ measure_theory.integrable F' μ ∧ has_deriv_at (λ (x : ℝ), ∫ (a : α), F x a ∂μ) (∫ (a : α), F' a ∂μ) x₀
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space ℝ E,	_inst_4 : complete_space E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : measurable_space E,	_inst_7 : borel_space E,	F : ℝ → α → E,	F' : α → E,	x₀ ε : ℝ,	ε_pos : 0 < ε,	hF_meas : ∀ᶠ (x : ℝ) in 𝓝 x₀, ae_measurable (F x) μ,	hF_int : measure_theory.integrable (F x₀) μ,	hF'_meas : ae_measurable F' μ,	bound : α → ℝ,	h_lipsch : ∀ᵐ (a : α) ∂μ, lipschitz_on_with (⇑real.nnabs (bound a)) (λ (x : ℝ), F x a) (metric.ball x₀ ε),	bound_integrable : measure_theory.integrable bound μ,	h_diff : ∀ᵐ (a : α) ∂μ, has_deriv_at (λ (x : ℝ), F x a) (F' a) x₀,	hm : ae_measurable (⇑(⇑(continuous_linear_map.smul_rightL ℝ ℝ E) 1) ∘ F') μ,	key : has_fderiv_at (λ (x : ℝ), ∫ (a : α), (λ (x : ℝ), F x) x a ∂μ) (∫ (a : α), (⇑(⇑(continuous_linear_map.smul_rightL ℝ ℝ E) 1) ∘ F') a ∂μ) x₀,	hF'_int : measure_theory.integrable F' μ	⊢ measure_theory.integrable F' μ ∧ has_deriv_at (λ (x : ℝ), ∫ (a : α), F x a ∂μ) (∫ (a : α), F' a ∂μ) x₀
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space ℝ E,	_inst_4 : complete_space E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : measurable_space E,	_inst_7 : borel_space E,	F : ℝ → α → E,	F' : α → E,	x₀ ε : ℝ,	ε_pos : 0 < ε,	hF_meas : ∀ᶠ (x : ℝ) in 𝓝 x₀, ae_measurable (F x) μ,	hF_int : measure_theory.integrable (F x₀) μ,	hF'_meas : ae_measurable F' μ,	bound : α → ℝ,	h_lipsch : ∀ᵐ (a : α) ∂μ, lipschitz_on_with (⇑real.nnabs (bound a)) (λ (x : ℝ), F x a) (metric.ball x₀ ε),	bound_integrable : measure_theory.integrable bound μ,	h_diff : ∀ᵐ (a : α) ∂μ, has_deriv_at (λ (x : ℝ), F x a) (F' a) x₀,	hm : ae_measurable (⇑(⇑(continuous_linear_map.smul_rightL ℝ ℝ E) 1) ∘ F') μ,	key : has_fderiv_at (λ (x : ℝ), ∫ (a : α), (λ (x : ℝ), F x) x a ∂μ) (∫ (a : α), (⇑(⇑(continuous_linear_map.smul_rightL ℝ ℝ E) 1) ∘ F') a ∂μ) x₀,	hF'_int : measure_theory.integrable F' μ	⊢ has_deriv_at (λ (x : ℝ), ∫ (a : α), F x a ∂μ) (∫ (a : α), F' a ∂μ) x₀
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space ℝ E,	_inst_4 : complete_space E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : measurable_space E,	_inst_7 : borel_space E,	F : ℝ → α → E,	F' : α → E,	x₀ ε : ℝ,	ε_pos : 0 < ε,	hF_meas : ∀ᶠ (x : ℝ) in 𝓝 x₀, ae_measurable (F x) μ,	hF_int : measure_theory.integrable (F x₀) μ,	hF'_meas : ae_measurable F' μ,	bound : α → ℝ,	h_lipsch : ∀ᵐ (a : α) ∂μ, lipschitz_on_with (⇑real.nnabs (bound a)) (λ (x : ℝ), F x a) (metric.ball x₀ ε),	bound_integrable : measure_theory.integrable bound μ,	hm : ae_measurable (⇑(⇑(continuous_linear_map.smul_rightL ℝ ℝ E) 1) ∘ F') μ,	key : has_fderiv_at (λ (x : ℝ), ∫ (a : α), (λ (x : ℝ), F x) x a ∂μ) (∫ (a : α), (⇑(⇑(continuous_linear_map.smul_rightL ℝ ℝ E) 1) ∘ F') a ∂μ) x₀,	hF'_int : measure_theory.integrable F' μ,	h_diff : ∀ᵐ (a : α) ∂μ, has_fderiv_at (λ (x : ℝ), F x a) (1.smul_right (F' a)) x₀	⊢ has_fderiv_at (λ (x : ℝ), measure_theory.integral μ (F x)) (1.smul_right (measure_theory.integral μ F')) x₀
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space ℝ E,	_inst_4 : complete_space E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : measurable_space E,	_inst_7 : borel_space E,	F : ℝ → α → E,	F' : α → E,	x₀ ε : ℝ,	ε_pos : 0 < ε,	hF_meas : ∀ᶠ (x : ℝ) in 𝓝 x₀, ae_measurable (F x) μ,	hF_int : measure_theory.integrable (F x₀) μ,	hF'_meas : ae_measurable F' μ,	bound : α → ℝ,	h_lipsch : ∀ᵐ (a : α) ∂μ, lipschitz_on_with (⇑real.nnabs (bound a)) (λ (x : ℝ), F x a) (metric.ball x₀ ε),	bound_integrable : measure_theory.integrable bound μ,	hm : ae_measurable (⇑(⇑(continuous_linear_map.smul_rightL ℝ ℝ E) 1) ∘ F') μ,	key : has_fderiv_at (λ (x : ℝ), ∫ (a : α), (λ (x : ℝ), F x) x a ∂μ) (∫ (a : α), (⇑(⇑(continuous_linear_map.smul_rightL ℝ ℝ E) 1) ∘ F') a ∂μ) x₀,	hF'_int : measure_theory.integrable F' μ,	h_diff : ∀ᵐ (a : α) ∂μ, has_fderiv_at (λ (x : ℝ), F x a) (1.smul_right (F' a)) x₀	⊢ measurable_space ℝ
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space ℝ E,	_inst_4 : complete_space E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : measurable_space E,	_inst_7 : borel_space E,	F : ℝ → α → E,	F' : α → E,	x₀ ε : ℝ,	ε_pos : 0 < ε,	hF_meas : ∀ᶠ (x : ℝ) in 𝓝 x₀, ae_measurable (F x) μ,	hF_int : measure_theory.integrable (F x₀) μ,	hF'_meas : ae_measurable F' μ,	bound : α → ℝ,	h_lipsch : ∀ᵐ (a : α) ∂μ, lipschitz_on_with (⇑real.nnabs (bound a)) (λ (x : ℝ), F x a) (metric.ball x₀ ε),	bound_integrable : measure_theory.integrable bound μ,	hm : ae_measurable (⇑(⇑(continuous_linear_map.smul_rightL ℝ ℝ E) 1) ∘ F') μ,	key : has_fderiv_at (λ (x : ℝ), ∫ (a : α), (λ (x : ℝ), F x) x a ∂μ) (∫ (a : α), (⇑(⇑(continuous_linear_map.smul_rightL ℝ ℝ E) 1) ∘ F') a ∂μ) x₀,	hF'_int : measure_theory.integrable F' μ,	h_diff : ∀ᵐ (a : α) ∂μ, has_fderiv_at (λ (x : ℝ), F x a) (1.smul_right (F' a)) x₀	⊢ opens_measurable_space ℝ
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space ℝ E,	_inst_4 : complete_space E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : measurable_space E,	_inst_7 : borel_space E,	F : ℝ → α → E,	F' : α → E,	x₀ ε : ℝ,	ε_pos : 0 < ε,	hF_meas : ∀ᶠ (x : ℝ) in 𝓝 x₀, ae_measurable (F x) μ,	hF_int : measure_theory.integrable (F x₀) μ,	hF'_meas : ae_measurable F' μ,	bound : α → ℝ,	h_lipsch : ∀ᵐ (a : α) ∂μ, lipschitz_on_with (⇑real.nnabs (bound a)) (λ (x : ℝ), F x a) (metric.ball x₀ ε),	bound_integrable : measure_theory.integrable bound μ,	hm : ae_measurable (⇑(⇑(continuous_linear_map.smul_rightL ℝ ℝ E) 1) ∘ F') μ,	key : has_fderiv_at (λ (x : ℝ), ∫ (a : α), (λ (x : ℝ), F x) x a ∂μ) (∫ (a : α), (⇑(⇑(continuous_linear_map.smul_rightL ℝ ℝ E) 1) ∘ F') a ∂μ) x₀,	hF'_int : measure_theory.integrable F' μ,	h_diff : ∀ᵐ (a : α) ∂μ, has_fderiv_at (λ (x : ℝ), F x a) (1.smul_right (F' a)) x₀	⊢ is_scalar_tower ℝ ℝ E
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space ℝ E,	_inst_4 : complete_space E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : measurable_space E,	_inst_7 : borel_space E,	F : ℝ → α → E,	F' : α → E,	x₀ ε : ℝ,	ε_pos : 0 < ε,	hF_meas : ∀ᶠ (x : ℝ) in 𝓝 x₀, ae_measurable (F x) μ,	hF_int : measure_theory.integrable (F x₀) μ,	hF'_meas : ae_measurable F' μ,	bound : α → ℝ,	h_lipsch : ∀ᵐ (a : α) ∂μ, lipschitz_on_with (⇑real.nnabs (bound a)) (λ (x : ℝ), F x a) (metric.ball x₀ ε),	bound_integrable : measure_theory.integrable bound μ,	hm : ae_measurable (⇑(⇑(continuous_linear_map.smul_rightL ℝ ℝ E) 1) ∘ F') μ,	key : has_fderiv_at (λ (x : ℝ), ∫ (a : α), (λ (x : ℝ), F x) x a ∂μ) (∫ (a : α), (⇑(⇑(continuous_linear_map.smul_rightL ℝ ℝ E) 1) ∘ F') a ∂μ) x₀,	hF'_int : measure_theory.integrable F' μ,	h_diff : ∀ᵐ (a : α) ∂μ, has_fderiv_at (λ (x : ℝ), F x a) (1.smul_right (F' a)) x₀	⊢ is_scalar_tower ℝ ℝ (ℝ →L[ℝ] E)
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space ℝ E,	_inst_4 : complete_space E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : measurable_space E,	_inst_7 : borel_space E,	F : ℝ → α → E,	F' : α → E,	x₀ ε : ℝ,	ε_pos : 0 < ε,	hF_meas : ∀ᶠ (x : ℝ) in 𝓝 x₀, ae_measurable (F x) μ,	hF_int : measure_theory.integrable (F x₀) μ,	hF'_meas : ae_measurable F' μ,	bound : α → ℝ,	h_lipsch : ∀ᵐ (a : α) ∂μ, lipschitz_on_with (⇑real.nnabs (bound a)) (λ (x : ℝ), F x a) (metric.ball x₀ ε),	bound_integrable : measure_theory.integrable bound μ,	hm : ae_measurable (⇑(⇑(continuous_linear_map.smul_rightL ℝ ℝ E) 1) ∘ F') μ,	key : has_fderiv_at (λ (x : ℝ), ∫ (a : α), (λ (x : ℝ), F x) x a ∂μ) (∫ (a : α), (⇑(⇑(continuous_linear_map.smul_rightL ℝ ℝ E) 1) ∘ F') a ∂μ) x₀,	hF'_int : measure_theory.integrable F' μ,	h_diff : ∀ᵐ (a : α) ∂μ, has_fderiv_at (λ (x : ℝ), F x a) (1.smul_right (F' a)) x₀	⊢ measurable_space ℝ		α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space ℝ E,	_inst_4 : complete_space E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : measurable_space E,	_inst_7 : borel_space E,	F : ℝ → α → E,	F' : α → E,	x₀ ε : ℝ,	ε_pos : 0 < ε,	hF_meas : ∀ᶠ (x : ℝ) in 𝓝 x₀, ae_measurable (F x) μ,	hF_int : measure_theory.integrable (F x₀) μ,	hF'_meas : ae_measurable F' μ,	bound : α → ℝ,	h_lipsch : ∀ᵐ (a : α) ∂μ, lipschitz_on_with (⇑real.nnabs (bound a)) (λ (x : ℝ), F x a) (metric.ball x₀ ε),	bound_integrable : measure_theory.integrable bound μ,	hm : ae_measurable (⇑(⇑(continuous_linear_map.smul_rightL ℝ ℝ E) 1) ∘ F') μ,	key : has_fderiv_at (λ (x : ℝ), ∫ (a : α), (λ (x : ℝ), F x) x a ∂μ) (∫ (a : α), (⇑(⇑(continuous_linear_map.smul_rightL ℝ ℝ E) 1) ∘ F') a ∂μ) x₀,	hF'_int : measure_theory.integrable F' μ,	h_diff : ∀ᵐ (a : α) ∂μ, has_fderiv_at (λ (x : ℝ), F x a) (1.smul_right (F' a)) x₀	⊢ opens_measurable_space ℝ		α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space ℝ E,	_inst_4 : complete_space E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : measurable_space E,	_inst_7 : borel_space E,	F : ℝ → α → E,	F' : α → E,	x₀ ε : ℝ,	ε_pos : 0 < ε,	hF_meas : ∀ᶠ (x : ℝ) in 𝓝 x₀, ae_measurable (F x) μ,	hF_int : measure_theory.integrable (F x₀) μ,	hF'_meas : ae_measurable F' μ,	bound : α → ℝ,	h_lipsch : ∀ᵐ (a : α) ∂μ, lipschitz_on_with (⇑real.nnabs (bound a)) (λ (x : ℝ), F x a) (metric.ball x₀ ε),	bound_integrable : measure_theory.integrable bound μ,	hm : ae_measurable (⇑(⇑(continuous_linear_map.smul_rightL ℝ ℝ E) 1) ∘ F') μ,	key : has_fderiv_at (λ (x : ℝ), ∫ (a : α), (λ (x : ℝ), F x) x a ∂μ) (∫ (a : α), (⇑(⇑(continuous_linear_map.smul_rightL ℝ ℝ E) 1) ∘ F') a ∂μ) x₀,	hF'_int : measure_theory.integrable F' μ,	h_diff : ∀ᵐ (a : α) ∂μ, has_fderiv_at (λ (x : ℝ), F x a) (1.smul_right (F' a)) x₀	⊢ is_scalar_tower ℝ ℝ E		α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space ℝ E,	_inst_4 : complete_space E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : measurable_space E,	_inst_7 : borel_space E,	F : ℝ → α → E,	F' : α → E,	x₀ ε : ℝ,	ε_pos : 0 < ε,	hF_meas : ∀ᶠ (x : ℝ) in 𝓝 x₀, ae_measurable (F x) μ,	hF_int : measure_theory.integrable (F x₀) μ,	hF'_meas : ae_measurable F' μ,	bound : α → ℝ,	h_lipsch : ∀ᵐ (a : α) ∂μ, lipschitz_on_with (⇑real.nnabs (bound a)) (λ (x : ℝ), F x a) (metric.ball x₀ ε),	bound_integrable : measure_theory.integrable bound μ,	hm : ae_measurable (⇑(⇑(continuous_linear_map.smul_rightL ℝ ℝ E) 1) ∘ F') μ,	key : has_fderiv_at (λ (x : ℝ), ∫ (a : α), (λ (x : ℝ), F x) x a ∂μ) (∫ (a : α), (⇑(⇑(continuous_linear_map.smul_rightL ℝ ℝ E) 1) ∘ F') a ∂μ) x₀,	hF'_int : measure_theory.integrable F' μ,	h_diff : ∀ᵐ (a : α) ∂μ, has_fderiv_at (λ (x : ℝ), F x a) (1.smul_right (F' a)) x₀	⊢ is_scalar_tower ℝ ℝ (ℝ →L[ℝ] E)
a : ℝ	⊢ (interior (set.Ici a)).nonempty
a b : ℝ,	hab : a < b	⊢ (interior (set.Ico a b)).nonempty
a b : ℝ,	hab : ¬a < b	⊢ unique_diff_on ℝ (set.Ico a b)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	G : Type u_4,	_inst_6 : normed_group G,	_inst_7 : normed_space 𝕜 G,	s : set E,	f : E → F,	n : with_top ℕ,	e : F ≃L[𝕜] G	⊢ times_cont_diff_on 𝕜 n (⇑e ∘ f) s ↔ times_cont_diff_on 𝕜 n f s
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	𝕜' : Type u_6,	_inst_10 : normed_field 𝕜',	_inst_11 : normed_algebra 𝕜 𝕜',	_inst_12 : complete_space 𝕜',	f : E → 𝕜',	n : with_top ℕ,	hf : times_cont_diff 𝕜 n f,	h : ∀ (x : E), f x ≠ 0	⊢ ∀ (x : E), times_cont_diff_at 𝕜 n (λ (x : E), (f x)⁻¹) x
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	𝕜' : Type u_6,	_inst_10 : normed_field 𝕜',	_inst_11 : normed_algebra 𝕜 𝕜',	_inst_12 : complete_space 𝕜',	f : E → 𝕜',	n : with_top ℕ,	hf : times_cont_diff 𝕜 n f,	h : ∀ (x : E), f x ≠ 0	⊢ times_cont_diff 𝕜 n (λ (x : E), (f x)⁻¹)
⊢ 1 < ∥2∥
⊢ 1 < ∥2∥
⊢ 1 < 2
e : ℂ → ℂ,	z : ℝ,	n : with_top ℕ,	h : times_cont_diff_at ℂ n e ↑z	⊢ times_cont_diff_at ℝ n (λ (x : ℝ), (e ↑x).re) z
e : ℂ → ℂ,	z : ℝ,	n : with_top ℕ,	h : times_cont_diff_at ℂ n e ↑z	⊢ times_cont_diff_at ℝ n coe z		e : ℂ → ℂ,	z : ℝ,	n : with_top ℕ,	h : times_cont_diff_at ℂ n e ↑z,	A : times_cont_diff_at ℝ n coe z	⊢ times_cont_diff_at ℝ n (λ (x : ℝ), (e ↑x).re) z
e : ℂ → ℂ,	z : ℝ,	n : with_top ℕ,	h : times_cont_diff_at ℂ n e ↑z,	A : times_cont_diff_at ℝ n coe z	⊢ times_cont_diff_at ℝ n (λ (x : ℝ), (e ↑x).re) z
e : ℂ → ℂ,	z : ℝ,	n : with_top ℕ,	h : times_cont_diff_at ℂ n e ↑z,	A : times_cont_diff_at ℝ n coe z,	B : times_cont_diff_at ℝ n e ↑z	⊢ times_cont_diff_at ℝ n (λ (x : ℝ), (e ↑x).re) z
e : ℂ → ℂ,	z : ℝ,	n : with_top ℕ,	h : times_cont_diff_at ℂ n e ↑z,	A : times_cont_diff_at ℝ n coe z,	B : times_cont_diff_at ℝ n e ↑z	⊢ times_cont_diff_at ℝ n complex.re (e ↑z)		e : ℂ → ℂ,	z : ℝ,	n : with_top ℕ,	h : times_cont_diff_at ℂ n e ↑z,	A : times_cont_diff_at ℝ n coe z,	B : times_cont_diff_at ℝ n e ↑z,	C : times_cont_diff_at ℝ n complex.re (e ↑z)	⊢ times_cont_diff_at ℝ n (λ (x : ℝ), (e ↑x).re) z
e : ℂ → ℂ,	z : ℝ,	n : with_top ℕ,	h : times_cont_diff_at ℂ n e ↑z,	A : times_cont_diff_at ℝ n coe z,	B : times_cont_diff_at ℝ n e ↑z,	C : times_cont_diff_at ℝ n complex.re (e ↑z)	⊢ times_cont_diff_at ℝ n (λ (x : ℝ), (e ↑x).re) z
𝕜 : Type u_1,	E : Type u_2,	F : Type u_3,	_inst_1 : ordered_ring 𝕜,	_inst_2 : add_comm_group E,	_inst_3 : module 𝕜 E,	_inst_4 : add_comm_group F,	_inst_5 : module 𝕜 F,	f : E →ᵃ[𝕜] F,	s : set F,	hs : convex 𝕜 s	⊢ convex 𝕜 (⇑f ⁻¹' s)
𝕜 : Type u_1,	E : Type u_2,	F : Type u_3,	_inst_1 : ordered_ring 𝕜,	_inst_2 : add_comm_group E,	_inst_3 : module 𝕜 E,	_inst_4 : add_comm_group F,	_inst_5 : module 𝕜 F,	f : E →ᵃ[𝕜] F,	s : set F,	hs : convex 𝕜 s,	x y : E,	xs : x ∈ ⇑f ⁻¹' s,	ys : y ∈ ⇑f ⁻¹' s,	a b : 𝕜,	ha : 0 ≤ a,	hb : 0 ≤ b,	hab : a + b = 1	⊢ a • x + b • y ∈ ⇑f ⁻¹' s
𝕜 : Type u_1,	E : Type u_2,	F : Type u_3,	_inst_1 : ordered_ring 𝕜,	_inst_2 : add_comm_group E,	_inst_3 : module 𝕜 E,	_inst_4 : add_comm_group F,	_inst_5 : module 𝕜 F,	f : E →ᵃ[𝕜] F,	s : set F,	hs : convex 𝕜 s,	x y : E,	xs : x ∈ ⇑f ⁻¹' s,	ys : y ∈ ⇑f ⁻¹' s,	a b : 𝕜,	ha : 0 ≤ a,	hb : 0 ≤ b,	hab : a + b = 1	⊢ a • ⇑f x + b • ⇑f y ∈ s
R : Type u_1,	E : Type u_2,	ι : Type u_3,	ι' : Type u_4,	_inst_1 : linear_ordered_field R,	_inst_2 : add_comm_group E,	_inst_3 : module R E,	s : finset ι,	t : finset ι',	ws : ι → R,	zs : ι → E,	wt : ι' → R,	zt : ι' → E,	hws : ∑ (i : ι) in s, ws i = 1,	hwt : ∑ (i : ι') in t, wt i = 1,	a b : R,	hab : a + b = 1	⊢ a • s.center_mass ws zs + b • t.center_mass wt zt = (finset.map function.embedding.inl s ∪ finset.map function.embedding.inr t).center_mass (sum.elim (λ (i : ι), a * ws i) (λ (j : ι'), b * wt j)) (sum.elim zs zt)
R : Type u_1,	E : Type u_2,	ι : Type u_3,	ι' : Type u_4,	_inst_1 : linear_ordered_field R,	_inst_2 : add_comm_group E,	_inst_3 : module R E,	s : finset ι,	t : finset ι',	ws : ι → R,	zs : ι → E,	wt : ι' → R,	zt : ι' → E,	hws : ∑ (i : ι) in s, ws i = 1,	hwt : ∑ (i : ι') in t, wt i = 1,	a b : R,	hab : a + b = 1	⊢ ∑ (x : ι ⊕ ι') in finset.map function.embedding.inl s ∪ finset.map function.embedding.inr t, sum.elim (λ (x : ι), a • (λ (i : ι), ws i) x • zs x) (λ (x : ι'), b • (λ (i : ι'), wt i) x • zt x) x = ∑ (i : ι ⊕ ι') in finset.map function.embedding.inl s ∪ finset.map function.embedding.inr t, sum.elim (λ (i : ι), a * ws i) (λ (j : ι'), b * wt j) i • sum.elim zs zt i
R : Type u_1,	E : Type u_2,	ι : Type u_3,	ι' : Type u_4,	_inst_1 : linear_ordered_field R,	_inst_2 : add_comm_group E,	_inst_3 : module R E,	s : finset ι,	t : finset ι',	ws : ι → R,	zs : ι → E,	wt : ι' → R,	zt : ι' → E,	hws : ∑ (i : ι) in s, ws i = 1,	hwt : ∑ (i : ι') in t, wt i = 1,	a b : R,	hab : a + b = 1,	x : ι	⊢ sum.elim (λ (x : ι), a • (λ (i : ι), ws i) x • zs x) (λ (x : ι'), b • (λ (i : ι'), wt i) x • zt x) (sum.inl x) = sum.elim (λ (i : ι), a * ws i) (λ (j : ι'), b * wt j) (sum.inl x) • sum.elim zs zt (sum.inl x)
R : Type u_1,	E : Type u_2,	ι : Type u_3,	ι' : Type u_4,	_inst_1 : linear_ordered_field R,	_inst_2 : add_comm_group E,	_inst_3 : module R E,	s : finset ι,	t : finset ι',	ws : ι → R,	zs : ι → E,	wt : ι' → R,	zt : ι' → E,	hws : ∑ (i : ι) in s, ws i = 1,	hwt : ∑ (i : ι') in t, wt i = 1,	a b : R,	hab : a + b = 1,	x : ι'	⊢ sum.elim (λ (x : ι), a • (λ (i : ι), ws i) x • zs x) (λ (x : ι'), b • (λ (i : ι'), wt i) x • zt x) (sum.inr x) = sum.elim (λ (i : ι), a * ws i) (λ (j : ι'), b * wt j) (sum.inr x) • sum.elim zs zt (sum.inr x)
R : Type u_1,	E : Type u_2,	ι : Type u_3,	ι' : Type u_4,	_inst_1 : linear_ordered_field R,	_inst_2 : add_comm_group E,	_inst_3 : module R E,	s : finset ι,	t : finset ι',	ws : ι → R,	zs : ι → E,	wt : ι' → R,	zt : ι' → E,	hws : ∑ (i : ι) in s, ws i = 1,	hwt : ∑ (i : ι') in t, wt i = 1,	a b : R,	hab : a + b = 1	⊢ ∑ (x : ι ⊕ ι') in finset.map function.embedding.inl s ∪ finset.map function.embedding.inr t, sum.elim (λ (x : ι), a • (λ (i : ι), ws i) x • zs x) (λ (x : ι'), b • (λ (i : ι'), wt i) x • zt x) x = ∑ (i : ι ⊕ ι') in finset.map function.embedding.inl s ∪ finset.map function.embedding.inr t, sum.elim (λ (i : ι), a * ws i) (λ (j : ι'), b * wt j) i • sum.elim zs zt i
R : Type u_1,	E : Type u_2,	ι : Type u_3,	ι' : Type u_4,	_inst_1 : linear_ordered_field R,	_inst_2 : add_comm_group E,	_inst_3 : module R E,	s : finset ι,	t : finset ι',	ws : ι → R,	zs : ι → E,	wt : ι' → R,	zt : ι' → E,	hws : ∑ (i : ι) in s, ws i = 1,	hwt : ∑ (i : ι') in t, wt i = 1,	a b : R,	hab : a + b = 1	⊢ ∑ (x : ι ⊕ ι') in finset.map function.embedding.inl s ∪ finset.map function.embedding.inr t, sum.elim (λ (x : ι), a • (λ (i : ι), ws i) x • zs x) (λ (x : ι'), b • (λ (i : ι'), wt i) x • zt x) x = ∑ (i : ι ⊕ ι') in finset.map function.embedding.inl s ∪ finset.map function.embedding.inr t, sum.elim (λ (i : ι), a * ws i) (λ (j : ι'), b * wt j) i • sum.elim zs zt i		R : Type u_1,	E : Type u_2,	ι : Type u_3,	ι' : Type u_4,	_inst_1 : linear_ordered_field R,	_inst_2 : add_comm_group E,	_inst_3 : module R E,	s : finset ι,	t : finset ι',	ws : ι → R,	zs : ι → E,	wt : ι' → R,	zt : ι' → E,	hws : ∑ (i : ι) in s, ws i = 1,	hwt : ∑ (i : ι') in t, wt i = 1,	a b : R,	hab : a + b = 1	⊢ ∑ (i : ι ⊕ ι') in finset.map function.embedding.inl s ∪ finset.map function.embedding.inr t, sum.elim (λ (i : ι), a * ws i) (λ (j : ι'), b * wt j) i = 1
R : Type u_1,	E : Type u_2,	ι : Type u_3,	ι' : Type u_4,	_inst_1 : linear_ordered_field R,	_inst_2 : add_comm_group E,	_inst_3 : module R E,	s : finset ι,	t : finset ι',	ws : ι → R,	zs : ι → E,	wt : ι' → R,	zt : ι' → E,	hws : ∑ (i : ι) in s, ws i = 1,	hwt : ∑ (i : ι') in t, wt i = 1,	a b : R,	hab : a + b = 1	⊢ ∑ (i : ι ⊕ ι') in finset.map function.embedding.inl s ∪ finset.map function.embedding.inr t, sum.elim (λ (i : ι), a * ws i) (λ (j : ι'), b * wt j) i = 1
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : ordered_semiring 𝕜,	_inst_2 : add_comm_group E,	_inst_3 : has_scalar 𝕜 E,	A B C : set E,	hAB : is_extreme 𝕜 A B,	hAC : is_extreme 𝕜 A C	⊢ is_extreme 𝕜 A (B ∩ C)
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : ordered_semiring 𝕜,	_inst_2 : add_comm_group E,	_inst_3 : has_scalar 𝕜 E,	A B C : set E,	hAB : is_extreme 𝕜 A B,	hAC : is_extreme 𝕜 A C	⊢ ∀ (x₁ x₂ : E), x₁ ∈ A → x₂ ∈ A → ∀ (x : E), x ∈ B ∩ C → x ∈ open_segment 𝕜 x₁ x₂ → x₁ ∈ B ∩ C ∧ x₂ ∈ B ∩ C
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : ordered_semiring 𝕜,	_inst_2 : add_comm_group E,	_inst_3 : has_scalar 𝕜 E,	A B C : set E,	hAB : is_extreme 𝕜 A B,	hAC : is_extreme 𝕜 A C,	x₁ x₂ : E,	hx₁A : x₁ ∈ A,	hx₂A : x₂ ∈ A,	x : E,	hx : x ∈ open_segment 𝕜 x₁ x₂,	hxB : x ∈ B,	hxC : x ∈ C	⊢ x₁ ∈ B ∩ C ∧ x₂ ∈ B ∩ C
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : ordered_semiring 𝕜,	_inst_2 : add_comm_group E,	_inst_3 : has_scalar 𝕜 E,	A B C : set E,	hAB : is_extreme 𝕜 A B,	hAC : is_extreme 𝕜 A C,	x₁ x₂ : E,	hx₁A : x₁ ∈ A,	hx₂A : x₂ ∈ A,	x : E,	hx : x ∈ open_segment 𝕜 x₁ x₂,	hxB : x ∈ B,	hxC : x ∈ C,	hx₁B : x₁ ∈ B,	hx₂B : x₂ ∈ B	⊢ x₁ ∈ B ∩ C ∧ x₂ ∈ B ∩ C
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : ordered_semiring 𝕜,	_inst_2 : add_comm_group E,	_inst_3 : has_scalar 𝕜 E,	A B C : set E,	hAB : is_extreme 𝕜 A B,	hAC : is_extreme 𝕜 A C,	x₁ x₂ : E,	hx₁A : x₁ ∈ A,	hx₂A : x₂ ∈ A,	x : E,	hx : x ∈ open_segment 𝕜 x₁ x₂,	hxB : x ∈ B,	hxC : x ∈ C,	hx₁B : x₁ ∈ B,	hx₂B : x₂ ∈ B,	hx₁C : x₁ ∈ C,	hx₂C : x₂ ∈ C	⊢ x₁ ∈ B ∩ C ∧ x₂ ∈ B ∩ C
𝕜 : Type u_1,	E : Type u_2,	β : Type u_4,	_inst_1 : ordered_semiring 𝕜,	_inst_2 : add_comm_monoid E,	_inst_4 : ordered_add_comm_monoid β,	_inst_5 : has_scalar 𝕜 E,	_inst_6 : module 𝕜 β,	_inst_7 : ordered_smul 𝕜 β,	s : set E,	f : E → β,	hf : convex_on 𝕜 s f	⊢ convex 𝕜 {p : E × β | p.fst ∈ s ∧ f p.fst ≤ p.snd}
𝕜 : Type u_1,	E : Type u_2,	β : Type u_4,	_inst_1 : ordered_semiring 𝕜,	_inst_2 : add_comm_monoid E,	_inst_4 : ordered_add_comm_monoid β,	_inst_5 : has_scalar 𝕜 E,	_inst_6 : module 𝕜 β,	_inst_7 : ordered_smul 𝕜 β,	s : set E,	f : E → β,	hf : convex_on 𝕜 s f,	a b : 𝕜,	ha : 0 ≤ a,	hb : 0 ≤ b,	hab : a + b = 1,	x : E,	r : β,	y : E,	t : β,	hx : (x, r).fst ∈ s,	hr : f (x, r).fst ≤ (x, r).snd,	hy : (y, t).fst ∈ s,	ht : f (y, t).fst ≤ (y, t).snd	⊢ a • (x, r) + b • (y, t) ∈ {p : E × β | p.fst ∈ s ∧ f p.fst ≤ p.snd}
𝕜 : Type u_1,	E : Type u_2,	β : Type u_4,	_inst_1 : ordered_semiring 𝕜,	_inst_2 : add_comm_monoid E,	_inst_4 : ordered_add_comm_monoid β,	_inst_5 : has_scalar 𝕜 E,	_inst_6 : module 𝕜 β,	_inst_7 : ordered_smul 𝕜 β,	s : set E,	f : E → β,	hf : convex_on 𝕜 s f,	a b : 𝕜,	ha : 0 ≤ a,	hb : 0 ≤ b,	hab : a + b = 1,	x : E,	r : β,	y : E,	t : β,	hx : (x, r).fst ∈ s,	hr : f (x, r).fst ≤ (x, r).snd,	hy : (y, t).fst ∈ s,	ht : f (y, t).fst ≤ (y, t).snd	⊢ f (a • (x, r) + b • (y, t)).fst ≤ (a • (x, r) + b • (y, t)).snd
𝕜 : Type u_1,	E : Type u_2,	β : Type u_4,	_inst_1 : ordered_semiring 𝕜,	_inst_2 : add_comm_monoid E,	_inst_4 : ordered_add_comm_monoid β,	_inst_5 : has_scalar 𝕜 E,	_inst_6 : distrib_mul_action 𝕜 β,	s : set E,	f g : E → β,	hf : convex_on 𝕜 s f,	hg : convex_on 𝕜 s g,	x y : E,	hx : x ∈ s,	hy : y ∈ s,	a b : 𝕜,	ha : 0 ≤ a,	hb : 0 ≤ b,	hab : a + b = 1	⊢ a • f x + b • f y + (a • g x + b • g y) = a • f x + a • g x + b • f y + b • g y
𝕜 : Type u_1,	E : Type u_2,	β : Type u_4,	_inst_1 : ordered_semiring 𝕜,	_inst_2 : add_comm_monoid E,	_inst_4 : ordered_add_comm_monoid β,	_inst_5 : has_scalar 𝕜 E,	_inst_6 : distrib_mul_action 𝕜 β,	s : set E,	f g : E → β,	hf : convex_on 𝕜 s f,	hg : convex_on 𝕜 s g,	x y : E,	hx : x ∈ s,	hy : y ∈ s,	a b : 𝕜,	ha : 0 ≤ a,	hb : 0 ≤ b,	hab : a + b = 1	⊢ a • f x + a • g x + b • f y + b • g y = a • (f x + g x) + b • (f y + g y)
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : ordered_semiring 𝕜,	_inst_2 : add_comm_group E,	_inst_3 : module 𝕜 E,	ι : Type u_3,	_inst_4 : subsingleton ι,	p : ι → E,	s : set ι,	x : ι,	hx : p x ∈ ⇑(convex_hull 𝕜) (p '' s)	⊢ x ∈ s
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : ordered_semiring 𝕜,	_inst_2 : add_comm_group E,	_inst_3 : module 𝕜 E,	ι : Type u_3,	_inst_4 : subsingleton ι,	p : ι → E,	s : set ι,	x : ι,	hx : p x ∈ ⇑(convex_hull 𝕜) (p '' s),	this : (⇑(convex_hull 𝕜) (p '' s)).nonempty	⊢ x ∈ s
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : ordered_semiring 𝕜,	_inst_2 : add_comm_group E,	_inst_3 : module 𝕜 E,	ι : Type u_3,	_inst_4 : subsingleton ι,	p : ι → E,	s : set ι,	x : ι,	hx : p x ∈ ⇑(convex_hull 𝕜) (p '' s),	this : s.nonempty	⊢ x ∈ s
⊢ concave_on ℝ (set.Iio 0) real.log
⊢ set.Iio 0 ⊆ {0}ᶜ
x : ℝ,	hx : x ∈ set.Iio 0,	hx' : x ∈ {0}	⊢ false
x : ℝ,	hx : x ∈ set.Iio 0,	hx' : x = 0	⊢ false
⊢ set.Iio 0 ⊆ {0}ᶜ		h₁ : set.Iio 0 ⊆ {0}ᶜ	⊢ concave_on ℝ (set.Iio 0) real.log
x : ℝ,	hx' : x = 0,	hx : 0 ∈ set.Iio 0	⊢ false
h₁ : set.Iio 0 ⊆ {0}ᶜ	⊢ concave_on ℝ (set.Iio 0) real.log
h₁ : set.Iio 0 ⊆ {0}ᶜ	⊢ differentiable_on ℝ real.log (set.Iio 0)		h₁ : set.Iio 0 ⊆ {0}ᶜ	⊢ differentiable_on ℝ (deriv real.log) (set.Iio 0)		h₁ : set.Iio 0 ⊆ {0}ᶜ	⊢ ∀ (x : ℝ), x ∈ set.Iio 0 → deriv^[2] real.log x ≤ 0
h₁ : set.Iio 0 ⊆ {0}ᶜ	⊢ differentiable_on ℝ real.log (set.Iio 0)
h₁ : set.Iio 0 ⊆ {0}ᶜ	⊢ differentiable_on ℝ (deriv real.log) (set.Iio 0)
h₁ : set.Iio 0 ⊆ {0}ᶜ	⊢ differentiable_on ℝ (deriv real.log) (set.Iio 0)		h₁ : set.Iio 0 ⊆ {0}ᶜ	⊢ ∀ (x : ℝ), x ∈ set.Iio 0 → deriv^[2] real.log x ≤ 0
h₁ : set.Iio 0 ⊆ {0}ᶜ	⊢ is_open {0}ᶜ
h₁ : set.Iio 0 ⊆ {0}ᶜ	⊢ ∀ (x : ℝ), x ∈ set.Iio 0 → deriv^[2] real.log x ≤ 0
h₁ : set.Iio 0 ⊆ {0}ᶜ,	x : ℝ,	hx : x ∈ set.Iio 0	⊢ deriv^[2] real.log x ≤ 0
h₁ : set.Iio 0 ⊆ {0}ᶜ,	x : ℝ,	hx : x ∈ set.Iio 0	⊢ (deriv ∘ deriv) real.log x ≤ 0
h₁ : set.Iio 0 ⊆ {0}ᶜ,	x : ℝ,	hx : x ∈ set.Iio 0	⊢ deriv (deriv real.log) x ≤ 0
h₁ : set.Iio 0 ⊆ {0}ᶜ,	x : ℝ,	hx : x ∈ set.Iio 0	⊢ -(x ^ 2)⁻¹ ≤ 0
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : inner_product_space 𝕜 E,	ι : Type u_4,	x : E,	v : ι → E,	hv : orthonormal 𝕜 v	⊢ summable (λ (i : ι), ∥has_inner.inner (v i) x∥ ^ 2)
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : inner_product_space 𝕜 E,	ι : Type u_4,	x : E,	v : ι → E,	hv : orthonormal 𝕜 v	⊢ has_sum (λ (i : ι), ∥has_inner.inner (v i) x∥ ^ 2) (⨆ (s : finset ι), ∑ (i : ι) in s, ∥has_inner.inner (v i) x∥ ^ 2)
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : inner_product_space 𝕜 E,	ι : Type u_4,	x : E,	v : ι → E,	hv : orthonormal 𝕜 v	⊢ ∀ (b : ι), 0 ≤ ∥has_inner.inner (v b) x∥ ^ 2
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : inner_product_space 𝕜 E,	ι : Type u_4,	x : E,	v : ι → E,	hv : orthonormal 𝕜 v	⊢ ∀ (b : ι), 0 ≤ ∥has_inner.inner (v b) x∥ ^ 2		𝕜 : Type u_1,	E : Type u_2,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : inner_product_space 𝕜 E,	ι : Type u_4,	x : E,	v : ι → E,	hv : orthonormal 𝕜 v	⊢ is_lub (set.range (λ (s : finset ι), ∑ (a : ι) in s, ∥has_inner.inner (v a) x∥ ^ 2)) (⨆ (s : finset ι), ∑ (i : ι) in s, ∥has_inner.inner (v i) x∥ ^ 2)
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : inner_product_space 𝕜 E,	ι : Type u_4,	x : E,	v : ι → E,	hv : orthonormal 𝕜 v,	b : ι	⊢ 0 ≤ ∥has_inner.inner (v b) x∥ ^ 2
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : inner_product_space 𝕜 E,	ι : Type u_4,	x : E,	v : ι → E,	hv : orthonormal 𝕜 v	⊢ is_lub (set.range (λ (s : finset ι), ∑ (a : ι) in s, ∥has_inner.inner (v a) x∥ ^ 2)) (⨆ (s : finset ι), ∑ (i : ι) in s, ∥has_inner.inner (v i) x∥ ^ 2)
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : inner_product_space 𝕜 E,	ι : Type u_4,	x : E,	v : ι → E,	hv : orthonormal 𝕜 v	⊢ bdd_above (set.range (λ (s : finset ι), ∑ (a : ι) in s, ∥has_inner.inner (v a) x∥ ^ 2))
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : inner_product_space 𝕜 E,	ι : Type u_4,	x : E,	v : ι → E,	hv : orthonormal 𝕜 v	⊢ ∥x∥ ^ 2 ∈ upper_bounds (set.range (λ (s : finset ι), ∑ (a : ι) in s, ∥has_inner.inner (v a) x∥ ^ 2))
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : inner_product_space 𝕜 E,	ι : Type u_4,	x : E,	v : ι → E,	hv : orthonormal 𝕜 v,	s : finset ι	⊢ (λ (s : finset ι), ∑ (a : ι) in s, ∥has_inner.inner (v a) x∥ ^ 2) s ≤ ∥x∥ ^ 2
𝕜 : Type u_1,	F : Type u_3,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : add_comm_group F,	_inst_3 : module 𝕜 F,	c : inner_product_space.core 𝕜 F,	x : F	⊢ ⇑is_R_or_C.im (has_inner.inner x x) = 0
𝕜 : Type u_1,	F : Type u_3,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : add_comm_group F,	_inst_3 : module 𝕜 F,	c : inner_product_space.core 𝕜 F,	x : F	⊢ is_R_or_C.I * (⇑is_R_or_C.conj (has_inner.inner x x) - has_inner.inner x x) / 2 = ↑0
𝕜 : Type u_1,	F : Type u_3,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : add_comm_group F,	_inst_3 : module 𝕜 F,	c : inner_product_space.core 𝕜 F,	x : F	⊢ ⇑is_R_or_C.im (has_inner.inner x x) = 0
𝕜 : Type u_1,	F : Type u_3,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : add_comm_group F,	_inst_3 : module 𝕜 F,	c : inner_product_space.core 𝕜 F,	x : F	⊢ x = 0 → has_inner.inner x x = 0
𝕜 : Type u_1,	F : Type u_3,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : add_comm_group F,	_inst_3 : module 𝕜 F,	c : inner_product_space.core 𝕜 F	⊢ has_inner.inner 0 0 = 0
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : inner_product_space 𝕜 E,	ι : Type u_3,	l : ι →₀ 𝕜,	v : ι → E,	x : E	⊢ l.sum (λ (i : ι) (a : 𝕜), ⇑is_R_or_C.conj a • has_inner.inner (v i) x) = ∑ (i : ι) in l.support, has_inner.inner (⇑l i • v i) x
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : inner_product_space 𝕜 E,	ι : Type u_3,	l : ι →₀ 𝕜,	v : ι → E,	x : E	⊢ has_inner.inner (l.sum (λ (i : ι) (a : 𝕜), a • v i)) x = l.sum (λ (i : ι) (a : 𝕜), ⇑is_R_or_C.conj a • has_inner.inner (v i) x)
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : inner_product_space 𝕜 E,	ι : Type u_4,	_inst_4 : fintype ι,	v : ι → E,	hv : orthonormal 𝕜 v,	l : ι → 𝕜,	i : ι	⊢ has_inner.inner (v i) (∑ (i : ι), l i • v i) = l i
F : Type u_1,	_inst_1 : inner_product_space ℝ F,	x y : F	⊢ ⇑(inner_product_space.to_dual' ℝ) (x + y) = ⇑(inner_product_space.to_dual' ℝ) x + ⇑(inner_product_space.to_dual' ℝ) y
F : Type u_1,	_inst_1 : inner_product_space ℝ F,	x y x_1 : F	⊢ ⇑(⇑(inner_product_space.to_dual' ℝ) (x + y)) x_1 = ⇑(⇑(inner_product_space.to_dual' ℝ) x + ⇑(inner_product_space.to_dual' ℝ) y) x_1
F : Type u_1,	_inst_1 : inner_product_space ℝ F,	c : ℝ,	x : F	⊢ ⇑(inner_product_space.to_dual' ℝ) (c • x) = ⇑(ring_hom.id ℝ) c • ⇑(inner_product_space.to_dual' ℝ) x
F : Type u_1,	_inst_1 : inner_product_space ℝ F,	c : ℝ,	x x_1 : F	⊢ ⇑(⇑(inner_product_space.to_dual' ℝ) (c • x)) x_1 = ⇑(⇑(ring_hom.id ℝ) c • ⇑(inner_product_space.to_dual' ℝ) x) x_1
F : Type u_1,	_inst_1 : inner_product_space ℝ F,	x : F	⊢ ∥⇑{to_fun := ⇑(inner_product_space.to_dual' ℝ), map_add' := _, map_smul' := _} x∥ ≤ 1 * ∥x∥
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : inner_product_space 𝕜 E,	x y : E	⊢ ∥⇑{to_fun := λ (y : E), has_inner.inner x y, map_add' := _, map_smul' := _} y∥ ≤ ∥x∥ * ∥y∥
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : inner_product_space 𝕜 E,	x y : E	⊢ is_R_or_C.abs (⇑{to_fun := λ (y : E), has_inner.inner x y, map_add' := _, map_smul' := _} y) ≤ ∥x∥ * ∥y∥
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : inner_product_space 𝕜 E	⊢ {to_fun := λ (y : E), has_inner.inner 0 y, map_add' := _, map_smul' := _}.mk_continuous ∥0∥ _ = 0
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : inner_product_space 𝕜 E,	z : E	⊢ ⇑({to_fun := λ (y : E), has_inner.inner 0 y, map_add' := _, map_smul' := _}.mk_continuous ∥0∥ _) z = ⇑0 z
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : inner_product_space 𝕜 E,	x y : E	⊢ {to_fun := λ (y_1 : E), has_inner.inner (x + y) y_1, map_add' := _, map_smul' := _}.mk_continuous ∥x + y∥ _ = {to_fun := λ (y : E), has_inner.inner x y, map_add' := _, map_smul' := _}.mk_continuous ∥x∥ _ + {to_fun := λ (y_1 : E), has_inner.inner y y_1, map_add' := _, map_smul' := _}.mk_continuous ∥y∥ _
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : inner_product_space 𝕜 E,	x y z : E	⊢ ⇑({to_fun := λ (y_1 : E), has_inner.inner (x + y) y_1, map_add' := _, map_smul' := _}.mk_continuous ∥x + y∥ _) z = ⇑({to_fun := λ (y : E), has_inner.inner x y, map_add' := _, map_smul' := _}.mk_continuous ∥x∥ _ + {to_fun := λ (y_1 : E), has_inner.inner y y_1, map_add' := _, map_smul' := _}.mk_continuous ∥y∥ _) z
x : euclidean_space ℝ (fin 2)	⊢ ⇑(complex.isometry_euclidean.symm) x = ↑(x 0) + ↑(x 1) * is_R_or_C.I
x : euclidean_space ℝ (fin 2)	⊢ ↑(x 0) = (λ (i : fin 2), x i • ⇑complex.basis_one_I i) (fin.mk 0 _)		x : euclidean_space ℝ (fin 2)	⊢ ↑(x 1) * is_R_or_C.I = list.foldr has_add.add 0 (list.map (λ (i : fin 2), x i • ⇑complex.basis_one_I i) (list.pmap fin.mk [1.add 0] _))
x : euclidean_space ℝ (fin 2)	⊢ ↑(x 0) = (λ (i : fin 2), x i • ⇑complex.basis_one_I i) (fin.mk 0 _)
x : euclidean_space ℝ (fin 2)	⊢ ↑(x 1) * is_R_or_C.I = list.foldr has_add.add 0 (list.map (λ (i : fin 2), x i • ⇑complex.basis_one_I i) (list.pmap fin.mk [1.add 0] _))
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : inner_product_space 𝕜 E,	K : submodule 𝕜 E,	_inst_4 : complete_space ↥K,	x y : E	⊢ ⟨orthogonal_projection_fn K (x + y), _⟩ = ⟨orthogonal_projection_fn K x, _⟩ + ⟨orthogonal_projection_fn K y, _⟩
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : inner_product_space 𝕜 E,	K : submodule 𝕜 E,	_inst_4 : complete_space ↥K,	x y : E,	hm : orthogonal_projection_fn K x + orthogonal_projection_fn K y ∈ K	⊢ ⟨orthogonal_projection_fn K (x + y), _⟩ = ⟨orthogonal_projection_fn K x, _⟩ + ⟨orthogonal_projection_fn K y, _⟩
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : inner_product_space 𝕜 E,	K : submodule 𝕜 E,	_inst_4 : complete_space ↥K,	x y : E,	hm : orthogonal_projection_fn K x + orthogonal_projection_fn K y ∈ K	⊢ ∀ (w : E), w ∈ K → has_inner.inner (x + y - (orthogonal_projection_fn K x + orthogonal_projection_fn K y)) w = 0
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : inner_product_space 𝕜 E,	K : submodule 𝕜 E,	_inst_4 : complete_space ↥K,	x y : E,	hm : orthogonal_projection_fn K x + orthogonal_projection_fn K y ∈ K,	w : E,	hw : w ∈ K	⊢ has_inner.inner (x + y - (orthogonal_projection_fn K x + orthogonal_projection_fn K y)) w = 0
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : inner_product_space 𝕜 E,	K : submodule 𝕜 E,	_inst_4 : complete_space ↥K,	x y : E,	hm : orthogonal_projection_fn K x + orthogonal_projection_fn K y ∈ K	⊢ ∀ (w : E), w ∈ K → has_inner.inner (x + y - (orthogonal_projection_fn K x + orthogonal_projection_fn K y)) w = 0		𝕜 : Type u_1,	E : Type u_2,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : inner_product_space 𝕜 E,	K : submodule 𝕜 E,	_inst_4 : complete_space ↥K,	x y : E,	hm : orthogonal_projection_fn K x + orthogonal_projection_fn K y ∈ K,	ho : ∀ (w : E), w ∈ K → has_inner.inner (x + y - (orthogonal_projection_fn K x + orthogonal_projection_fn K y)) w = 0	⊢ ⟨orthogonal_projection_fn K (x + y), _⟩ = ⟨orthogonal_projection_fn K x, _⟩ + ⟨orthogonal_projection_fn K y, _⟩
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : inner_product_space 𝕜 E,	K : submodule 𝕜 E,	_inst_4 : complete_space ↥K,	x y : E,	hm : orthogonal_projection_fn K x + orthogonal_projection_fn K y ∈ K,	ho : ∀ (w : E), w ∈ K → has_inner.inner (x + y - (orthogonal_projection_fn K x + orthogonal_projection_fn K y)) w = 0	⊢ ⟨orthogonal_projection_fn K (x + y), _⟩ = ⟨orthogonal_projection_fn K x, _⟩ + ⟨orthogonal_projection_fn K y, _⟩
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : inner_product_space 𝕜 E,	K : submodule 𝕜 E,	_inst_4 : complete_space ↥K,	x y : E,	hm : orthogonal_projection_fn K x + orthogonal_projection_fn K y ∈ K,	ho : ∀ (w : E), w ∈ K → has_inner.inner (x + y - (orthogonal_projection_fn K x + orthogonal_projection_fn K y)) w = 0	⊢ ↑⟨orthogonal_projection_fn K (x + y), _⟩ = ↑(⟨orthogonal_projection_fn K x, _⟩ + ⟨orthogonal_projection_fn K y, _⟩)
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : inner_product_space 𝕜 E,	K : submodule 𝕜 E,	_inst_4 : complete_space ↥K,	c : 𝕜,	x : E	⊢ ⟨orthogonal_projection_fn K (c • x), _⟩ = ⇑(ring_hom.id 𝕜) c • ⟨orthogonal_projection_fn K x, _⟩
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : inner_product_space 𝕜 E,	K : submodule 𝕜 E,	_inst_4 : complete_space ↥K,	c : 𝕜,	x : E,	hm : c • orthogonal_projection_fn K x ∈ K	⊢ ⟨orthogonal_projection_fn K (c • x), _⟩ = ⇑(ring_hom.id 𝕜) c • ⟨orthogonal_projection_fn K x, _⟩
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : inner_product_space 𝕜 E,	K : submodule 𝕜 E,	_inst_4 : complete_space ↥K,	c : 𝕜,	x : E,	hm : c • orthogonal_projection_fn K x ∈ K	⊢ ∀ (w : E), w ∈ K → has_inner.inner (c • x - c • orthogonal_projection_fn K x) w = 0
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : inner_product_space 𝕜 E,	K : submodule 𝕜 E,	_inst_4 : complete_space ↥K,	c : 𝕜,	x : E,	hm : c • orthogonal_projection_fn K x ∈ K	⊢ ∀ (w : E), w ∈ K → has_inner.inner (c • x - c • orthogonal_projection_fn K x) w = 0		𝕜 : Type u_1,	E : Type u_2,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : inner_product_space 𝕜 E,	K : submodule 𝕜 E,	_inst_4 : complete_space ↥K,	c : 𝕜,	x : E,	hm : c • orthogonal_projection_fn K x ∈ K,	ho : ∀ (w : E), w ∈ K → has_inner.inner (c • x - c • orthogonal_projection_fn K x) w = 0	⊢ ⟨orthogonal_projection_fn K (c • x), _⟩ = ⇑(ring_hom.id 𝕜) c • ⟨orthogonal_projection_fn K x, _⟩
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : inner_product_space 𝕜 E,	K : submodule 𝕜 E,	_inst_4 : complete_space ↥K,	c : 𝕜,	x : E,	hm : c • orthogonal_projection_fn K x ∈ K,	w : E,	hw : w ∈ K	⊢ has_inner.inner (c • x - c • orthogonal_projection_fn K x) w = 0
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : inner_product_space 𝕜 E,	K : submodule 𝕜 E,	_inst_4 : complete_space ↥K,	c : 𝕜,	x : E,	hm : c • orthogonal_projection_fn K x ∈ K,	ho : ∀ (w : E), w ∈ K → has_inner.inner (c • x - c • orthogonal_projection_fn K x) w = 0	⊢ ⟨orthogonal_projection_fn K (c • x), _⟩ = ⇑(ring_hom.id 𝕜) c • ⟨orthogonal_projection_fn K x, _⟩
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : inner_product_space 𝕜 E,	K : submodule 𝕜 E,	_inst_4 : complete_space ↥K,	c : 𝕜,	x : E,	hm : c • orthogonal_projection_fn K x ∈ K,	ho : ∀ (w : E), w ∈ K → has_inner.inner (c • x - c • orthogonal_projection_fn K x) w = 0	⊢ ↑⟨orthogonal_projection_fn K (c • x), _⟩ = ↑(⇑(ring_hom.id 𝕜) c • ⟨orthogonal_projection_fn K x, _⟩)
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : inner_product_space 𝕜 E,	K : submodule 𝕜 E,	_inst_4 : complete_space ↥K,	x : E	⊢ ∥⇑{to_fun := λ (v : E), ⟨orthogonal_projection_fn K v, _⟩, map_add' := _, map_smul' := _} x∥ ≤ 1 * ∥x∥
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : inner_product_space 𝕜 E,	K : submodule 𝕜 E,	_inst_4 : complete_space ↥K,	x : E	⊢ 0 < 2
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : inner_product_space 𝕜 E,	K : submodule 𝕜 E,	_inst_4 : complete_space ↥K,	x : E	⊢ ∥⟨orthogonal_projection_fn K x, _⟩∥ ≤ ∥x∥
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : inner_product_space 𝕜 E,	K : submodule 𝕜 E,	_inst_4 : complete_space ↥K,	x : E	⊢ ∥⟨orthogonal_projection_fn K x, _⟩∥ ^ 2 ≤ ∥x∥ ^ 2
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : inner_product_space 𝕜 E,	K : submodule 𝕜 E,	_inst_4 : complete_space ↥K,	x : E	⊢ ∥orthogonal_projection_fn K x∥ ^ 2 ≤ ∥x∥ ^ 2
ι : Type u,	s : finset ι,	w z : ι → ℝ≥0,	hw' : ∑ (i : ι) in s, w i = 1,	n : ℕ	⊢ (∑ (i : ι) in s, w i * z i) ^ n ≤ ∑ (i : ι) in s, w i * z i ^ n
ι : Type u,	s : finset ι,	w z : ι → ℝ≥0,	hw' : ∑ (i : ι) in s, w i = 1,	n : ℕ	⊢ ∑ (i : ι) in s, ↑(w i) = 1
w₁ w₂ z₁ z₂ : ℝ≥0,	hw' : w₁ + w₂ = 1,	p : ℝ,	hp : 1 ≤ p	⊢ (w₁ * z₁ + w₂ * z₂) ^ p ≤ w₁ * z₁ ^ p + w₂ * z₂ ^ p
w₁ w₂ z₁ z₂ : ℝ≥0,	hw' : w₁ + w₂ = 1,	p : ℝ,	hp : 1 ≤ p,	h : (∑ (i : fin 2), fin.cons w₁ (fin.cons w₂ fin_zero_elim) i * fin.cons z₁ (fin.cons z₂ fin_zero_elim) i) ^ p ≤ ∑ (i : fin 2), fin.cons w₁ (fin.cons w₂ fin_zero_elim) i * fin.cons z₁ (fin.cons z₂ fin_zero_elim) i ^ p	⊢ (w₁ * z₁ + w₂ * z₂) ^ p ≤ w₁ * z₁ ^ p + w₂ * z₂ ^ p
w₁ w₂ z₁ z₂ : ℝ≥0,	hw' : w₁ + w₂ = 1,	p : ℝ,	hp : 1 ≤ p,	h : (∑ (i : fin 2), fin.cons w₁ (fin.cons w₂ fin_zero_elim) i * fin.cons z₁ (fin.cons z₂ fin_zero_elim) i) ^ p ≤ ∑ (i : fin 2), fin.cons w₁ (fin.cons w₂ fin_zero_elim) i * fin.cons z₁ (fin.cons z₂ fin_zero_elim) i ^ p	⊢ (w₁ * z₁ + w₂ * z₂) ^ p ≤ w₁ * z₁ ^ p + w₂ * z₂ ^ p		w₁ w₂ z₁ z₂ : ℝ≥0,	hw' : w₁ + w₂ = 1,	p : ℝ,	hp : 1 ≤ p	⊢ ∑ (i : fin 2), fin.cons w₁ (fin.cons w₂ fin_zero_elim) i = 1
w₁ w₂ z₁ z₂ : ℝ≥0,	hw' : w₁ + w₂ = 1,	p : ℝ,	hp : 1 ≤ p	⊢ ∑ (i : fin 2), fin.cons w₁ (fin.cons w₂ fin_zero_elim) i = 1
ι : Type u,	s : finset ι,	f : ι → ℝ≥0,	p q : ℝ,	hpq : p.is_conjugate_exponent q	⊢ is_greatest ((λ (g : ι → ℝ≥0), ∑ (i : ι) in s, f i * g i) '' {g : ι → ℝ≥0 | ∑ (i : ι) in s, g i ^ q ≤ 1}) ((∑ (i : ι) in s, f i ^ p) ^ (1 / p))
ι : Type u,	s : finset ι,	f : ι → ℝ≥0,	p q : ℝ,	hpq : p.is_conjugate_exponent q	⊢ (∑ (i : ι) in s, f i ^ p) ^ (1 / p) ∈ (λ (g : ι → ℝ≥0), ∑ (i : ι) in s, f i * g i) '' {g : ι → ℝ≥0 | ∑ (i : ι) in s, g i ^ q ≤ 1}
ι : Type u,	s : finset ι,	f : ι → ℝ≥0,	p q : ℝ,	hpq : p.is_conjugate_exponent q	⊢ (λ (i : ι), f i ^ p / f i / (∑ (i : ι) in s, f i ^ p) ^ (1 / q)) ∈ {g : ι → ℝ≥0 | ∑ (i : ι) in s, g i ^ q ≤ 1} ∧ (λ (g : ι → ℝ≥0), ∑ (i : ι) in s, f i * g i) (λ (i : ι), f i ^ p / f i / (∑ (i : ι) in s, f i ^ p) ^ (1 / q)) = (∑ (i : ι) in s, f i ^ p) ^ (1 / p)
ι : Type u,	s : finset ι,	f : ι → ℝ≥0,	p q : ℝ,	hpq : p.is_conjugate_exponent q,	hf : ∑ (i : ι) in s, f i ^ p = 0	⊢ (λ (i : ι), f i ^ p / f i / (∑ (i : ι) in s, f i ^ p) ^ (1 / q)) ∈ {g : ι → ℝ≥0 | ∑ (i : ι) in s, g i ^ q ≤ 1} ∧ (λ (g : ι → ℝ≥0), ∑ (i : ι) in s, f i * g i) (λ (i : ι), f i ^ p / f i / (∑ (i : ι) in s, f i ^ p) ^ (1 / q)) = (∑ (i : ι) in s, f i ^ p) ^ (1 / p)		ι : Type u,	s : finset ι,	f : ι → ℝ≥0,	p q : ℝ,	hpq : p.is_conjugate_exponent q,	hf : ¬∑ (i : ι) in s, f i ^ p = 0	⊢ (λ (i : ι), f i ^ p / f i / (∑ (i : ι) in s, f i ^ p) ^ (1 / q)) ∈ {g : ι → ℝ≥0 | ∑ (i : ι) in s, g i ^ q ≤ 1} ∧ (λ (g : ι → ℝ≥0), ∑ (i : ι) in s, f i * g i) (λ (i : ι), f i ^ p / f i / (∑ (i : ι) in s, f i ^ p) ^ (1 / q)) = (∑ (i : ι) in s, f i ^ p) ^ (1 / p)
ι : Type u,	s : finset ι,	f : ι → ℝ≥0,	p q : ℝ,	hpq : p.is_conjugate_exponent q,	hf : ∑ (i : ι) in s, f i ^ p = 0	⊢ (λ (i : ι), f i ^ p / f i / (∑ (i : ι) in s, f i ^ p) ^ (1 / q)) ∈ {g : ι → ℝ≥0 | ∑ (i : ι) in s, g i ^ q ≤ 1} ∧ (λ (g : ι → ℝ≥0), ∑ (i : ι) in s, f i * g i) (λ (i : ι), f i ^ p / f i / (∑ (i : ι) in s, f i ^ p) ^ (1 / q)) = (∑ (i : ι) in s, f i ^ p) ^ (1 / p)
ι : Type u,	s : finset ι,	f : ι → ℝ≥0,	p q : ℝ,	hpq : p.is_conjugate_exponent q,	hf : ¬∑ (i : ι) in s, f i ^ p = 0	⊢ p + q - q ≠ 0
ι : Type u,	s : finset ι,	f : ι → ℝ≥0,	p q : ℝ,	hpq : p.is_conjugate_exponent q,	hf : ¬∑ (i : ι) in s, f i ^ p = 0	⊢ (λ (i : ι), f i ^ p / f i / (∑ (i : ι) in s, f i ^ p) ^ (1 / q)) ∈ {g : ι → ℝ≥0 | ∑ (i : ι) in s, g i ^ q ≤ 1} ∧ (λ (g : ι → ℝ≥0), ∑ (i : ι) in s, f i * g i) (λ (i : ι), f i ^ p / f i / (∑ (i : ι) in s, f i ^ p) ^ (1 / q)) = (∑ (i : ι) in s, f i ^ p) ^ (1 / p)
ι : Type u,	s : finset ι,	f : ι → ℝ≥0,	p q : ℝ,	hpq : p.is_conjugate_exponent q,	hf : ¬∑ (i : ι) in s, f i ^ p = 0,	A : p + q - q ≠ 0	⊢ (λ (i : ι), f i ^ p / f i / (∑ (i : ι) in s, f i ^ p) ^ (1 / q)) ∈ {g : ι → ℝ≥0 | ∑ (i : ι) in s, g i ^ q ≤ 1} ∧ (λ (g : ι → ℝ≥0), ∑ (i : ι) in s, f i * g i) (λ (i : ι), f i ^ p / f i / (∑ (i : ι) in s, f i ^ p) ^ (1 / q)) = (∑ (i : ι) in s, f i ^ p) ^ (1 / p)
ι : Type u,	s : finset ι,	f : ι → ℝ≥0,	p q : ℝ,	hpq : p.is_conjugate_exponent q,	hf : ¬∑ (i : ι) in s, f i ^ p = 0,	A : p + q - q ≠ 0	⊢ ∀ (y : ℝ≥0), y * y ^ p / y = y ^ p
ι : Type u,	s : finset ι,	f : ι → ℝ≥0,	p q : ℝ,	hpq : p.is_conjugate_exponent q,	hf : ¬∑ (i : ι) in s, f i ^ p = 0,	A : p + q - q ≠ 0	⊢ ∀ (y : ℝ≥0), y * y ^ p / y = y ^ p		ι : Type u,	s : finset ι,	f : ι → ℝ≥0,	p q : ℝ,	hpq : p.is_conjugate_exponent q,	hf : ¬∑ (i : ι) in s, f i ^ p = 0,	A : p + q - q ≠ 0,	B : ∀ (y : ℝ≥0), y * y ^ p / y = y ^ p	⊢ (λ (i : ι), f i ^ p / f i / (∑ (i : ι) in s, f i ^ p) ^ (1 / q)) ∈ {g : ι → ℝ≥0 | ∑ (i : ι) in s, g i ^ q ≤ 1} ∧ (λ (g : ι → ℝ≥0), ∑ (i : ι) in s, f i * g i) (λ (i : ι), f i ^ p / f i / (∑ (i : ι) in s, f i ^ p) ^ (1 / q)) = (∑ (i : ι) in s, f i ^ p) ^ (1 / p)
ι : Type u,	s : finset ι,	f : ι → ℝ≥0,	p q : ℝ,	hpq : p.is_conjugate_exponent q,	hf : ¬∑ (i : ι) in s, f i ^ p = 0,	A : p + q - q ≠ 0,	y : ℝ≥0,	h : y = 0	⊢ y ^ p = 0
ι : Type u,	s : finset ι,	f : ι → ℝ≥0,	p q : ℝ,	hpq : p.is_conjugate_exponent q,	hf : ¬∑ (i : ι) in s, f i ^ p = 0,	A : p + q - q ≠ 0,	B : ∀ (y : ℝ≥0), y * y ^ p / y = y ^ p	⊢ (λ (i : ι), f i ^ p / f i / (∑ (i : ι) in s, f i ^ p) ^ (1 / q)) ∈ {g : ι → ℝ≥0 | ∑ (i : ι) in s, g i ^ q ≤ 1} ∧ (λ (g : ι → ℝ≥0), ∑ (i : ι) in s, f i * g i) (λ (i : ι), f i ^ p / f i / (∑ (i : ι) in s, f i ^ p) ^ (1 / q)) = (∑ (i : ι) in s, f i ^ p) ^ (1 / p)
ι : Type u,	s : finset ι,	f : ι → ℝ≥0,	p q : ℝ,	hpq : p.is_conjugate_exponent q,	hf : ¬∑ (i : ι) in s, f i ^ p = 0,	A : p + q - q ≠ 0,	B : ∀ (y : ℝ≥0), y * y ^ p / y = y ^ p	⊢ (∑ (i : ι) in s, f i ^ p) / (∑ (i : ι) in s, f i ^ p) ^ (1 / q) = (∑ (i : ι) in s, f i ^ p) ^ (1 / p)
ι : Type u,	s : finset ι,	f : ι → ℝ≥0,	p q : ℝ,	hpq : p.is_conjugate_exponent q	⊢ (∑ (i : ι) in s, f i ^ p) ^ (1 / p) ∈ (λ (g : ι → ℝ≥0), ∑ (i : ι) in s, f i * g i) '' {g : ι → ℝ≥0 | ∑ (i : ι) in s, g i ^ q ≤ 1}		ι : Type u,	s : finset ι,	f : ι → ℝ≥0,	p q : ℝ,	hpq : p.is_conjugate_exponent q	⊢ (∑ (i : ι) in s, f i ^ p) ^ (1 / p) ∈ upper_bounds ((λ (g : ι → ℝ≥0), ∑ (i : ι) in s, f i * g i) '' {g : ι → ℝ≥0 | ∑ (i : ι) in s, g i ^ q ≤ 1})
ι : Type u,	s : finset ι,	f : ι → ℝ≥0,	p q : ℝ,	hpq : p.is_conjugate_exponent q,	hf : ¬∑ (i : ι) in s, f i ^ p = 0,	A : p + q - q ≠ 0,	B : ∀ (y : ℝ≥0), y * y ^ p / y = y ^ p	⊢ (∑ (i : ι) in s, f i ^ p) ^ (1 / q) ≠ 0
ι : Type u,	s : finset ι,	f : ι → ℝ≥0,	p q : ℝ,	hpq : p.is_conjugate_exponent q	⊢ (∑ (i : ι) in s, f i ^ p) ^ (1 / p) ∈ upper_bounds ((λ (g : ι → ℝ≥0), ∑ (i : ι) in s, f i * g i) '' {g : ι → ℝ≥0 | ∑ (i : ι) in s, g i ^ q ≤ 1})
ι : Type u,	s : finset ι,	f : ι → ℝ≥0,	p q : ℝ,	hpq : p.is_conjugate_exponent q,	g : ι → ℝ≥0,	hg : g ∈ {g : ι → ℝ≥0 | ∑ (i : ι) in s, g i ^ q ≤ 1}	⊢ (λ (g : ι → ℝ≥0), ∑ (i : ι) in s, f i * g i) g ≤ (∑ (i : ι) in s, f i ^ p) ^ (1 / p)
ι : Type u,	s : finset ι,	f : ι → ℝ≥0,	p q : ℝ,	hpq : p.is_conjugate_exponent q,	g : ι → ℝ≥0,	hg : g ∈ {g : ι → ℝ≥0 | ∑ (i : ι) in s, g i ^ q ≤ 1}	⊢ (∑ (i : ι) in s, f i ^ p) ^ (1 / p) * (∑ (i : ι) in s, g i ^ q) ^ (1 / q) ≤ (∑ (i : ι) in s, f i ^ p) ^ (1 / p)
ι : Type u,	s : finset ι,	f g : ι → ℝ≥0,	p : ℝ,	hp : 1 ≤ p	⊢ (∑ (i : ι) in s, (f i + g i) ^ p) ^ (1 / p) ≤ (∑ (i : ι) in s, f i ^ p) ^ (1 / p) + (∑ (i : ι) in s, g i ^ p) ^ (1 / p)
ι : Type u,	s : finset ι,	f g : ι → ℝ≥0,	hp : 1 ≤ 1	⊢ (∑ (i : ι) in s, (f i + g i) ^ 1) ^ (1 / 1) ≤ (∑ (i : ι) in s, f i ^ 1) ^ (1 / 1) + (∑ (i : ι) in s, g i ^ 1) ^ (1 / 1)
ι : Type u,	s : finset ι,	f g : ι → ℝ≥0,	hp : 1 ≤ 1	⊢ (∑ (i : ι) in s, (f i + g i) ^ 1) ^ (1 / 1) ≤ (∑ (i : ι) in s, f i ^ 1) ^ (1 / 1) + (∑ (i : ι) in s, g i ^ 1) ^ (1 / 1)		ι : Type u,	s : finset ι,	f g : ι → ℝ≥0,	p : ℝ,	hp : 1 ≤ p,	hp : 1 < p	⊢ (∑ (i : ι) in s, (f i + g i) ^ p) ^ (1 / p) ≤ (∑ (i : ι) in s, f i ^ p) ^ (1 / p) + (∑ (i : ι) in s, g i ^ p) ^ (1 / p)
ι : Type u,	s : finset ι,	f g : ι → ℝ≥0,	p : ℝ,	hp : 1 ≤ p,	hp : 1 < p	⊢ (∑ (i : ι) in s, (f i + g i) ^ p) ^ (1 / p) ≤ (∑ (i : ι) in s, f i ^ p) ^ (1 / p) + (∑ (i : ι) in s, g i ^ p) ^ (1 / p)
ι : Type u,	s : finset ι,	f g : ι → ℝ≥0,	p : ℝ,	hp : 1 ≤ p,	hp : 1 < p,	hpq : p.is_conjugate_exponent p.conjugate_exponent	⊢ (∑ (i : ι) in s, (f i + g i) ^ p) ^ (1 / p) ≤ (∑ (i : ι) in s, f i ^ p) ^ (1 / p) + (∑ (i : ι) in s, g i ^ p) ^ (1 / p)
ι : Type u,	s : finset ι,	f g : ι → ℝ≥0,	p : ℝ,	hp : 1 ≤ p,	hp : 1 < p,	hpq : p.is_conjugate_exponent p.conjugate_exponent,	this : is_greatest ((λ (g_1 : ι → ℝ≥0), ∑ (i : ι) in s, (f + g) i * g_1 i) '' {g : ι → ℝ≥0 | ∑ (i : ι) in s, g i ^ p.conjugate_exponent ≤ 1}) ((∑ (i : ι) in s, (f + g) i ^ p) ^ (1 / p))	⊢ (∑ (i : ι) in s, (f i + g i) ^ p) ^ (1 / p) ≤ (∑ (i : ι) in s, f i ^ p) ^ (1 / p) + (∑ (i : ι) in s, g i ^ p) ^ (1 / p)
ι : Type u,	s : finset ι,	f g : ι → ℝ≥0,	p : ℝ,	hp : 1 ≤ p,	hp : 1 < p,	hpq : p.is_conjugate_exponent p.conjugate_exponent,	this : is_greatest ((λ (g_1 : ι → ℝ≥0), ∑ (x : ι) in s, f x * g_1 x + ∑ (x : ι) in s, g x * g_1 x) '' {g : ι → ℝ≥0 | ∑ (i : ι) in s, g i ^ p.conjugate_exponent ≤ 1}) ((∑ (i : ι) in s, (f i + g i) ^ p) ^ (1 / p))	⊢ (∑ (i : ι) in s, (f i + g i) ^ p) ^ (1 / p) ≤ (∑ (i : ι) in s, f i ^ p) ^ (1 / p) + (∑ (i : ι) in s, g i ^ p) ^ (1 / p)
ι : Type u,	s : finset ι,	f g : ι → ℝ≥0,	p : ℝ,	hp : 1 ≤ p,	hp : 1 < p,	hpq : p.is_conjugate_exponent p.conjugate_exponent,	this : is_greatest ((λ (g_1 : ι → ℝ≥0), ∑ (x : ι) in s, f x * g_1 x + ∑ (x : ι) in s, g x * g_1 x) '' {g : ι → ℝ≥0 | ∑ (i : ι) in s, g i ^ p.conjugate_exponent ≤ 1}) ((∑ (i : ι) in s, (f i + g i) ^ p) ^ (1 / p)),	φ : ι → ℝ≥0,	hφ : φ ∈ {g : ι → ℝ≥0 | ∑ (i : ι) in s, g i ^ p.conjugate_exponent ≤ 1},	H : (λ (g_1 : ι → ℝ≥0), ∑ (x : ι) in s, f x * g_1 x + ∑ (x : ι) in s, g x * g_1 x) φ = (∑ (i : ι) in s, (f i + g i) ^ p) ^ (1 / p)	⊢ (∑ (i : ι) in s, (f i + g i) ^ p) ^ (1 / p) ≤ (∑ (i : ι) in s, f i ^ p) ^ (1 / p) + (∑ (i : ι) in s, g i ^ p) ^ (1 / p)
ι : Type u,	s : finset ι,	f g : ι → ℝ≥0,	p : ℝ,	hp : 1 ≤ p,	hp : 1 < p,	hpq : p.is_conjugate_exponent p.conjugate_exponent,	this : is_greatest ((λ (g_1 : ι → ℝ≥0), ∑ (x : ι) in s, f x * g_1 x + ∑ (x : ι) in s, g x * g_1 x) '' {g : ι → ℝ≥0 | ∑ (i : ι) in s, g i ^ p.conjugate_exponent ≤ 1}) ((∑ (i : ι) in s, (f i + g i) ^ p) ^ (1 / p)),	φ : ι → ℝ≥0,	hφ : φ ∈ {g : ι → ℝ≥0 | ∑ (i : ι) in s, g i ^ p.conjugate_exponent ≤ 1},	H : (λ (g_1 : ι → ℝ≥0), ∑ (x : ι) in s, f x * g_1 x + ∑ (x : ι) in s, g x * g_1 x) φ = (∑ (i : ι) in s, (f i + g i) ^ p) ^ (1 / p)	⊢ (λ (g_1 : ι → ℝ≥0), ∑ (x : ι) in s, f x * g_1 x + ∑ (x : ι) in s, g x * g_1 x) φ ≤ (∑ (i : ι) in s, f i ^ p) ^ (1 / p) + (∑ (i : ι) in s, g i ^ p) ^ (1 / p)
⊢ category_theory.limits.has_cokernels SemiNormedGroup
⊢ category_theory.limits.has_cokernels SemiNormedGroup₁
V : Type u_2,	P : Type u_3,	_inst_1 : semi_normed_group V,	_inst_2 : pseudo_metric_space P,	_inst_3 : semi_normed_add_torsor V P,	v v' : V,	p p' : P	⊢ ↑(has_nndist.nndist (v +ᵥ p) (v' +ᵥ p')) ≤ ↑(has_nndist.nndist v v') + ↑(has_nndist.nndist p p')
V : Type u_2,	P : Type u_3,	_inst_1 : semi_normed_group V,	_inst_2 : pseudo_metric_space P,	_inst_3 : semi_normed_add_torsor V P,	v v' : V,	p p' : P	⊢ has_edist.edist (v +ᵥ p) (v' +ᵥ p') ≤ has_edist.edist v v' + has_edist.edist p p'
𝕜 : Type u_1,	V : Type u_2,	V₂ : Type u_4,	_inst_1 : normed_field 𝕜,	_inst_2 : semi_normed_group V,	_inst_4 : semi_normed_group V₂,	_inst_7 : semi_normed_space 𝕜 V,	_inst_9 : semi_normed_space 𝕜 V₂,	e : V ≃ₗᵢ[𝕜] V₂,	x : V	⊢ ⇑(e.to_affine_isometry_equiv.linear_isometry_equiv) x = ⇑e x
𝕜 : Type u_1,	V : Type u_2,	V₂ : Type u_4,	_inst_1 : normed_field 𝕜,	_inst_2 : semi_normed_group V,	_inst_4 : semi_normed_group V₂,	_inst_7 : semi_normed_space 𝕜 V,	_inst_9 : semi_normed_space 𝕜 V₂,	e : V ≃ₗᵢ[𝕜] V₂	⊢ e.to_affine_isometry_equiv.linear_isometry_equiv = e
𝕜 : Type u_1,	V : Type u_2,	P : Type u_8,	_inst_1 : normed_field 𝕜,	_inst_2 : semi_normed_group V,	_inst_7 : semi_normed_space 𝕜 V,	_inst_12 : pseudo_metric_space P,	_inst_17 : semi_normed_add_torsor V P,	x y : P	⊢ has_dist.dist (⇑(affine_isometry_equiv.point_reflection 𝕜 x) y) x = has_dist.dist y x
E : Type u_5,	_inst_2 : normed_group E,	_inst_6 : normed_space ℝ E,	_inst_7 : nontrivial E,	x : E,	r : ℝ	⊢ frontier (metric.closed_ball x r) = metric.sphere x r
𝕜 : Type u_1,	𝕜' : Type u_2,	_inst_1 : normed_field 𝕜,	_inst_2 : semi_normed_ring 𝕜',	_inst_3 : semi_normed_algebra 𝕜 𝕜'	⊢ isometry ⇑(algebra_map 𝕜 𝕜')
𝕜 : Type u_1,	𝕜' : Type u_2,	_inst_1 : normed_field 𝕜,	_inst_2 : semi_normed_ring 𝕜',	_inst_3 : semi_normed_algebra 𝕜 𝕜',	x y : 𝕜	⊢ has_dist.dist (⇑(algebra_map 𝕜 𝕜') x) (⇑(algebra_map 𝕜 𝕜') y) = has_dist.dist x y
𝕜 : Type u_5,	_inst_1 : normed_field 𝕜,	𝕜' : Type u_6,	_inst_2 : semi_normed_ring 𝕜',	_inst_3 : semi_normed_algebra 𝕜 𝕜'	⊢ ∥1∥ = 1
α : Type u_1,	ι : Type u_4,	_inst_1 : semi_normed_group α,	f : ι → α,	g : ι → ℝ,	hg : summable g,	h : ∀ (i : ι), ∥f i∥ ≤ g i,	ε : ℝ,	hε : ε > 0,	_let_match : (∃ (s : finset ι), ∀ (t : finset ι), disjoint t s → ∥∑ (i : ι) in t, g i∥ < ε) → (∃ (s : finset ι), ∀ (t : finset ι), disjoint t s → ∥∑ (i : ι) in t, f i∥ < ε),	s : finset ι,	hs : ∀ (t : finset ι), disjoint t s → ∥∑ (i : ι) in t, g i∥ < ε,	t : finset ι,	ht : disjoint t s,	this : ∥∑ (i : ι) in t, g i∥ < ε,	nn : 0 ≤ ∑ (i : ι) in t, g i	⊢ ∑ (b : ι) in t, g b < ε
α : Type u_1,	_inst_1 : has_norm α,	_inst_2 : add_comm_group α,	_inst_3 : pseudo_metric_space α,	H1 : ∀ (x : α), ∥x∥ = has_dist.dist x 0,	H2 : ∀ (x y z : α), has_dist.dist x y ≤ has_dist.dist (x + z) (y + z),	x y : α	⊢ has_dist.dist x y = has_dist.dist (x - y) 0
α : Type u_1,	_inst_1 : has_norm α,	_inst_2 : add_comm_group α,	_inst_3 : pseudo_metric_space α,	H1 : ∀ (x : α), ∥x∥ = has_dist.dist x 0,	H2 : ∀ (x y z : α), has_dist.dist x y ≤ has_dist.dist (x + z) (y + z),	x y : α	⊢ has_dist.dist x y = ∥x - y∥
α : Type u_1,	_inst_1 : has_norm α,	_inst_2 : add_comm_group α,	_inst_3 : pseudo_metric_space α,	H1 : ∀ (x : α), ∥x∥ = has_dist.dist x 0,	H2 : ∀ (x y z : α), has_dist.dist x y ≤ has_dist.dist (x + z) (y + z),	x y : α	⊢ has_dist.dist x y ≤ has_dist.dist (x + -y) (y + -y)
α : Type u_1,	_inst_1 : has_norm α,	_inst_2 : add_comm_group α,	_inst_3 : pseudo_metric_space α,	H1 : ∀ (x : α), ∥x∥ = has_dist.dist x 0,	H2 : ∀ (x y z : α), has_dist.dist x y ≤ has_dist.dist (x + z) (y + z),	x y : α	⊢ has_dist.dist x y ≤ has_dist.dist (x - y) 0		α : Type u_1,	_inst_1 : has_norm α,	_inst_2 : add_comm_group α,	_inst_3 : pseudo_metric_space α,	H1 : ∀ (x : α), ∥x∥ = has_dist.dist x 0,	H2 : ∀ (x y z : α), has_dist.dist x y ≤ has_dist.dist (x + z) (y + z),	x y : α	⊢ has_dist.dist (x - y) 0 ≤ has_dist.dist x y
α : Type u_1,	_inst_1 : has_norm α,	_inst_2 : add_comm_group α,	_inst_3 : pseudo_metric_space α,	H1 : ∀ (x : α), ∥x∥ = has_dist.dist x 0,	H2 : ∀ (x y z : α), has_dist.dist x y ≤ has_dist.dist (x + z) (y + z),	x y : α	⊢ has_dist.dist x y ≤ has_dist.dist (x - y) 0
α : Type u_1,	_inst_1 : has_norm α,	_inst_2 : add_comm_group α,	_inst_3 : pseudo_metric_space α,	H1 : ∀ (x : α), ∥x∥ = has_dist.dist x 0,	H2 : ∀ (x y z : α), has_dist.dist x y ≤ has_dist.dist (x + z) (y + z),	x y : α,	this : has_dist.dist (x - y) 0 ≤ has_dist.dist (x - y + y) (0 + y)	⊢ has_dist.dist (x - y) 0 ≤ has_dist.dist x y
α : Type u_1,	_inst_1 : has_norm α,	_inst_2 : add_comm_group α,	_inst_3 : pseudo_metric_space α,	H1 : ∀ (x : α), ∥x∥ = has_dist.dist x 0,	H2 : ∀ (x y z : α), has_dist.dist x y ≤ has_dist.dist (x + z) (y + z),	x y : α	⊢ has_dist.dist (x - y) 0 ≤ has_dist.dist x y
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F	⊢ ∀ (x : E), ∥⇑0 x∥ ≤ 0 * ∥x∥
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	_inst_8 : complete_space E,	p q : subspace 𝕜 E,	h : is_compl p q,	hp : is_closed ↑p,	hq : is_closed ↑q,	_inst : complete_space ↥↑p	⊢ (↥p × ↥q) ≃L[𝕜] E
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	_inst_8 : complete_space E,	p q : subspace 𝕜 E,	h : is_compl p q,	hp : is_closed ↑p,	hq : is_closed ↑q	⊢ (↥p × ↥q) ≃L[𝕜] E
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	_inst_8 : complete_space E,	p q : subspace 𝕜 E,	h : is_compl p q,	hp : is_closed ↑p,	hq : is_closed ↑q,	_inst : complete_space ↥↑p,	_inst_4 : complete_space ↥↑q	⊢ (↥p × ↥q) ≃L[𝕜] E
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	_inst_8 : complete_space E,	p q : subspace 𝕜 E,	h : is_compl p q,	hp : is_closed ↑p,	hq : is_closed ↑q,	_inst : complete_space ↥↑p,	_inst_4 : complete_space ↥↑q	⊢ continuous ⇑(submodule.prod_equiv_of_is_compl p q h)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : semi_normed_group E,	_inst_3 : semi_normed_space 𝕜 E,	x : E	⊢ ∥⇑(normed_space.inclusion_in_double_dual 𝕜 E) x∥ ≤ ∥x∥
𝕜 : Type u_1,	V : Type u_2,	_inst_1 : normed_field 𝕜,	_inst_2 : add_comm_group V,	_inst_3 : module 𝕜 V,	e : enorm 𝕜 V	⊢ metric_space ↥(e.finite_subspace)
𝕜 : Type u_1,	V : Type u_2,	_inst_1 : normed_field 𝕜,	_inst_2 : add_comm_group V,	_inst_3 : module 𝕜 V,	e : enorm 𝕜 V,	_inst : emetric_space V := e.emetric_space	⊢ metric_space ↥(e.finite_subspace)
𝕜 : Type u_1,	V : Type u_2,	_inst_1 : normed_field 𝕜,	_inst_2 : add_comm_group V,	_inst_3 : module 𝕜 V,	e : enorm 𝕜 V,	_inst : emetric_space V := e.emetric_space,	x y : ↥(e.finite_subspace)	⊢ has_edist.edist x y ≠ ⊤
𝕜 : Type u_1,	V : Type u_2,	_inst_1 : normed_field 𝕜,	_inst_2 : add_comm_group V,	_inst_3 : module 𝕜 V,	e : enorm 𝕜 V,	_inst : emetric_space V := e.emetric_space,	x y : ↥(e.finite_subspace)	⊢ ⇑e (↑x - ↑y) ≠ ⊤
ι : Type w,	_inst_1 : fintype ι,	𝕜 : Type u,	_inst_2 : normed_field 𝕜,	E : Type v,	_inst_3 : add_comm_group E,	_inst_4 : module 𝕜 E,	_inst_5 : topological_space E,	_inst_6 : topological_add_group E,	_inst_7 : has_continuous_smul 𝕜 E,	f : (ι → 𝕜) →ₗ[𝕜] E	⊢ continuous ⇑f
ι : Type w,	_inst_1 : fintype ι,	𝕜 : Type u,	_inst_2 : normed_field 𝕜,	E : Type v,	_inst_3 : add_comm_group E,	_inst_4 : module 𝕜 E,	_inst_5 : topological_space E,	_inst_6 : topological_add_group E,	_inst_7 : has_continuous_smul 𝕜 E,	f : (ι → 𝕜) →ₗ[𝕜] E	⊢ ⇑f = λ (x : ι → 𝕜), ∑ (i : ι), x i • ⇑f (λ (j : ι), ite (i = j) 1 0)
ι : Type w,	_inst_1 : fintype ι,	𝕜 : Type u,	_inst_2 : normed_field 𝕜,	E : Type v,	_inst_3 : add_comm_group E,	_inst_4 : module 𝕜 E,	_inst_5 : topological_space E,	_inst_6 : topological_add_group E,	_inst_7 : has_continuous_smul 𝕜 E,	f : (ι → 𝕜) →ₗ[𝕜] E,	x : ι → 𝕜	⊢ ⇑f x = ∑ (i : ι), x i • ⇑f (λ (j : ι), ite (i = j) 1 0)
ι : Type w,	_inst_1 : fintype ι,	𝕜 : Type u,	_inst_2 : normed_field 𝕜,	E : Type v,	_inst_3 : add_comm_group E,	_inst_4 : module 𝕜 E,	_inst_5 : topological_space E,	_inst_6 : topological_add_group E,	_inst_7 : has_continuous_smul 𝕜 E,	f : (ι → 𝕜) →ₗ[𝕜] E,	this : ⇑f = λ (x : ι → 𝕜), ∑ (i : ι), x i • ⇑f (λ (j : ι), ite (i = j) 1 0)	⊢ continuous ⇑f
ι : Type w,	_inst_1 : fintype ι,	𝕜 : Type u,	_inst_2 : normed_field 𝕜,	E : Type v,	_inst_3 : add_comm_group E,	_inst_4 : module 𝕜 E,	_inst_5 : topological_space E,	_inst_6 : topological_add_group E,	_inst_7 : has_continuous_smul 𝕜 E,	f : (ι → 𝕜) →ₗ[𝕜] E,	this : ⇑f = λ (x : ι → 𝕜), ∑ (i : ι), x i • ⇑f (λ (j : ι), ite (i = j) 1 0)	⊢ continuous (λ (x : ι → 𝕜), ∑ (i : ι), x i • ⇑f (λ (j : ι), ite (i = j) 1 0))
ι : Type w,	_inst_1 : fintype ι,	𝕜 : Type u,	_inst_2 : normed_field 𝕜,	E : Type v,	_inst_3 : add_comm_group E,	_inst_4 : module 𝕜 E,	_inst_5 : topological_space E,	_inst_6 : topological_add_group E,	_inst_7 : has_continuous_smul 𝕜 E,	f : (ι → 𝕜) →ₗ[𝕜] E,	this : ⇑f = λ (x : ι → 𝕜), ∑ (i : ι), x i • ⇑f (λ (j : ι), ite (i = j) 1 0),	i : ι,	hi : i ∈ finset.univ	⊢ continuous (λ (x : ι → 𝕜), x i • ⇑f (λ (j : ι), ite (i = j) 1 0))
𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type v,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	_inst_11 : complete_space 𝕜,	ι : Type u_1,	_inst_12 : fintype ι,	f : ι → E,	hf : linear_independent 𝕜 f	⊢ ∀ᶠ (g : ι → E) in 𝓝 f, linear_independent 𝕜 g
𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type v,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	_inst_11 : complete_space 𝕜,	ι : Type u_1,	_inst_12 : fintype ι,	f : ι → E,	hf : (⇑(linear_map.lsum 𝕜 (λ (i : ι), 𝕜) ℕ) (λ (i : ι), linear_map.id.smul_right (f i))).ker = ⊥	⊢ ∀ᶠ (g : ι → E) in 𝓝 f, (⇑(linear_map.lsum 𝕜 (λ (i : ι), 𝕜) ℕ) (λ (i : ι), linear_map.id.smul_right (g i))).ker = ⊥
𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type v,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	_inst_11 : complete_space 𝕜,	ι : Type u_1,	_inst_12 : fintype ι,	f : ι → E,	hf : (⇑(linear_map.lsum 𝕜 (λ (i : ι), 𝕜) ℕ) (λ (i : ι), linear_map.id.smul_right (f i))).ker = ⊥,	K : nnreal,	K0 : K > 0,	hK : antilipschitz_with K ⇑(⇑(linear_map.lsum 𝕜 (λ (i : ι), 𝕜) ℕ) (λ (i : ι), linear_map.id.smul_right (f i)))	⊢ ∀ᶠ (g : ι → E) in 𝓝 f, (⇑(linear_map.lsum 𝕜 (λ (i : ι), 𝕜) ℕ) (λ (i : ι), linear_map.id.smul_right (g i))).ker = ⊥
𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type v,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	_inst_11 : complete_space 𝕜,	ι : Type u_1,	_inst_12 : fintype ι,	f : ι → E,	hf : (⇑(linear_map.lsum 𝕜 (λ (i : ι), 𝕜) ℕ) (λ (i : ι), linear_map.id.smul_right (f i))).ker = ⊥,	K : nnreal,	K0 : K > 0,	hK : antilipschitz_with K ⇑(⇑(linear_map.lsum 𝕜 (λ (i : ι), 𝕜) ℕ) (λ (i : ι), linear_map.id.smul_right (f i)))	⊢ filter.tendsto (λ (g : ι → E), ∑ (i : ι), ∥g i - f i∥) (𝓝 f) (𝓝 (∑ (i : ι), ∥f i - f i∥))		𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type v,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	_inst_11 : complete_space 𝕜,	ι : Type u_1,	_inst_12 : fintype ι,	f : ι → E,	hf : (⇑(linear_map.lsum 𝕜 (λ (i : ι), 𝕜) ℕ) (λ (i : ι), linear_map.id.smul_right (f i))).ker = ⊥,	K : nnreal,	K0 : K > 0,	hK : antilipschitz_with K ⇑(⇑(linear_map.lsum 𝕜 (λ (i : ι), 𝕜) ℕ) (λ (i : ι), linear_map.id.smul_right (f i))),	this : filter.tendsto (λ (g : ι → E), ∑ (i : ι), ∥g i - f i∥) (𝓝 f) (𝓝 (∑ (i : ι), ∥f i - f i∥))	⊢ ∀ᶠ (g : ι → E) in 𝓝 f, (⇑(linear_map.lsum 𝕜 (λ (i : ι), 𝕜) ℕ) (λ (i : ι), linear_map.id.smul_right (g i))).ker = ⊥
𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type v,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	_inst_11 : complete_space 𝕜,	ι : Type u_1,	_inst_12 : fintype ι,	f : ι → E,	hf : (⇑(linear_map.lsum 𝕜 (λ (i : ι), 𝕜) ℕ) (λ (i : ι), linear_map.id.smul_right (f i))).ker = ⊥,	K : nnreal,	K0 : K > 0,	hK : antilipschitz_with K ⇑(⇑(linear_map.lsum 𝕜 (λ (i : ι), 𝕜) ℕ) (λ (i : ι), linear_map.id.smul_right (f i))),	this : filter.tendsto (λ (g : ι → E), ∑ (i : ι), ∥g i - f i∥) (𝓝 f) (𝓝 (∑ (i : ι), ∥f i - f i∥))	⊢ ∀ᶠ (g : ι → E) in 𝓝 f, (⇑(linear_map.lsum 𝕜 (λ (i : ι), 𝕜) ℕ) (λ (i : ι), linear_map.id.smul_right (g i))).ker = ⊥
𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type v,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	_inst_11 : complete_space 𝕜,	ι : Type u_1,	_inst_12 : fintype ι,	f : ι → E,	hf : (⇑(linear_map.lsum 𝕜 (λ (i : ι), 𝕜) ℕ) (λ (i : ι), linear_map.id.smul_right (f i))).ker = ⊥,	K : nnreal,	K0 : K > 0,	hK : antilipschitz_with K ⇑(⇑(linear_map.lsum 𝕜 (λ (i : ι), 𝕜) ℕ) (λ (i : ι), linear_map.id.smul_right (f i))),	this : filter.tendsto (λ (g : ι → E), ∑ (i : ι), ∥g i - f i∥) (𝓝 f) (𝓝 0)	⊢ ∀ᶠ (g : ι → E) in 𝓝 f, (⇑(linear_map.lsum 𝕜 (λ (i : ι), 𝕜) ℕ) (λ (i : ι), linear_map.id.smul_right (g i))).ker = ⊥
𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type v,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	_inst_11 : complete_space 𝕜,	ι : Type u_1,	_inst_12 : fintype ι,	f : ι → E,	hf : (⇑(linear_map.lsum 𝕜 (λ (i : ι), 𝕜) ℕ) (λ (i : ι), linear_map.id.smul_right (f i))).ker = ⊥,	K : nnreal,	K0 : K > 0,	hK : antilipschitz_with K ⇑(⇑(linear_map.lsum 𝕜 (λ (i : ι), 𝕜) ℕ) (λ (i : ι), linear_map.id.smul_right (f i))),	this : filter.tendsto (λ (g : ι → E), ∑ (i : ι), ∥g i - f i∥) (𝓝 f) (𝓝 0),	g : ι → E,	hg : ∑ (i : ι), ∥g i - f i∥ < (↑K)⁻¹	⊢ (⇑(linear_map.lsum 𝕜 (λ (i : ι), 𝕜) ℕ) (λ (i : ι), linear_map.id.smul_right (g i))).ker = ⊥
𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type v,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	_inst_11 : complete_space 𝕜,	ι : Type u_1,	_inst_12 : fintype ι,	f : ι → E,	hf : (⇑(linear_map.lsum 𝕜 (λ (i : ι), 𝕜) ℕ) (λ (i : ι), linear_map.id.smul_right (f i))).ker = ⊥,	K : nnreal,	K0 : K > 0,	hK : antilipschitz_with K ⇑(⇑(linear_map.lsum 𝕜 (λ (i : ι), 𝕜) ℕ) (λ (i : ι), linear_map.id.smul_right (f i))),	this : filter.tendsto (λ (g : ι → E), ∑ (i : ι), ∥g i - f i∥) (𝓝 f) (𝓝 0),	g : ι → E,	hg : ∑ (i : ι), ∥g i - f i∥ < (↑K)⁻¹	⊢ ∑ (i : ι), ∥g i - f i∥₊ < K⁻¹
𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type v,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	_inst_11 : complete_space 𝕜,	ι : Type u_1,	_inst_12 : fintype ι,	f : ι → E,	hf : (⇑(linear_map.lsum 𝕜 (λ (i : ι), 𝕜) ℕ) (λ (i : ι), linear_map.id.smul_right (f i))).ker = ⊥,	K : nnreal,	K0 : K > 0,	hK : antilipschitz_with K ⇑(⇑(linear_map.lsum 𝕜 (λ (i : ι), 𝕜) ℕ) (λ (i : ι), linear_map.id.smul_right (f i))),	this : filter.tendsto (λ (g : ι → E), ∑ (i : ι), ∥g i - f i∥) (𝓝 f) (𝓝 0),	g : ι → E,	hg : ∑ (i : ι), ∥g i - f i∥ < (↑K)⁻¹	⊢ ↑∑ (i : ι), ∥g i - f i∥₊ < ↑K⁻¹
𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type v,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	_inst_11 : complete_space 𝕜,	ι : Type u_1,	_inst_12 : fintype ι,	f : ι → E,	hf : (⇑(linear_map.lsum 𝕜 (λ (i : ι), 𝕜) ℕ) (λ (i : ι), linear_map.id.smul_right (f i))).ker = ⊥,	K : nnreal,	K0 : K > 0,	hK : antilipschitz_with K ⇑(⇑(linear_map.lsum 𝕜 (λ (i : ι), 𝕜) ℕ) (λ (i : ι), linear_map.id.smul_right (f i))),	this : filter.tendsto (λ (g : ι → E), ∑ (i : ι), ∥g i - f i∥) (𝓝 f) (𝓝 0),	g : ι → E,	hg : ∑ (i : ι), ∥g i - f i∥ < (↑K)⁻¹	⊢ ∑ (a : ι), ∥g a - f a∥ < (↑K)⁻¹
𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type v,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	_inst_11 : complete_space 𝕜,	ι : Type u_1,	_inst_12 : fintype ι,	f : ι → E,	hf : (⇑(linear_map.lsum 𝕜 (λ (i : ι), 𝕜) ℕ) (λ (i : ι), linear_map.id.smul_right (f i))).ker = ⊥,	K : nnreal,	K0 : K > 0,	hK : antilipschitz_with K ⇑(⇑(linear_map.lsum 𝕜 (λ (i : ι), 𝕜) ℕ) (λ (i : ι), linear_map.id.smul_right (f i))),	this : filter.tendsto (λ (g : ι → E), ∑ (i : ι), ∥g i - f i∥) (𝓝 f) (𝓝 0),	g : ι → E,	hg : ∑ (i : ι), ∥g i - f i∥₊ < K⁻¹	⊢ (⇑(linear_map.lsum 𝕜 (λ (i : ι), 𝕜) ℕ) (λ (i : ι), linear_map.id.smul_right (g i))).ker = ⊥
𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type v,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	_inst_11 : complete_space 𝕜,	ι : Type u_1,	_inst_12 : fintype ι,	f : ι → E,	hf : (⇑(linear_map.lsum 𝕜 (λ (i : ι), 𝕜) ℕ) (λ (i : ι), linear_map.id.smul_right (f i))).ker = ⊥,	K : nnreal,	K0 : K > 0,	hK : antilipschitz_with K ⇑(⇑(linear_map.lsum 𝕜 (λ (i : ι), 𝕜) ℕ) (λ (i : ι), linear_map.id.smul_right (f i))),	this : filter.tendsto (λ (g : ι → E), ∑ (i : ι), ∥g i - f i∥) (𝓝 f) (𝓝 0),	g : ι → E,	hg : ∑ (i : ι), ∥g i - f i∥₊ < K⁻¹	⊢ function.injective ⇑(⇑(linear_map.lsum 𝕜 (λ (i : ι), 𝕜) ℕ) (λ (i : ι), linear_map.id.smul_right (g i)))
𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type v,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	_inst_11 : complete_space 𝕜,	ι : Type u_1,	_inst_12 : fintype ι,	f : ι → E,	hf : (⇑(linear_map.lsum 𝕜 (λ (i : ι), 𝕜) ℕ) (λ (i : ι), linear_map.id.smul_right (f i))).ker = ⊥,	K : nnreal,	K0 : K > 0,	hK : antilipschitz_with K ⇑(⇑(linear_map.lsum 𝕜 (λ (i : ι), 𝕜) ℕ) (λ (i : ι), linear_map.id.smul_right (f i))),	this : filter.tendsto (λ (g : ι → E), ∑ (i : ι), ∥g i - f i∥) (𝓝 f) (𝓝 0),	g : ι → E,	hg : ∑ (i : ι), ∥g i - f i∥₊ < K⁻¹,	v u : Π (i : ι), (λ (i : ι), 𝕜) i	⊢ has_dist.dist ((⇑(⇑(linear_map.lsum 𝕜 (λ (i : ι), 𝕜) ℕ) (λ (i : ι), linear_map.id.smul_right (g i))) - ⇑(⇑(linear_map.lsum 𝕜 (λ (i : ι), 𝕜) ℕ) (λ (i : ι), linear_map.id.smul_right (f i)))) v) ((⇑(⇑(linear_map.lsum 𝕜 (λ (i : ι), 𝕜) ℕ) (λ (i : ι), linear_map.id.smul_right (g i))) - ⇑(⇑(linear_map.lsum 𝕜 (λ (i : ι), 𝕜) ℕ) (λ (i : ι), linear_map.id.smul_right (f i)))) u) ≤ (↑∑ (i : ι), ∥g i - f i∥₊) * has_dist.dist v u
𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type v,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	_inst_11 : complete_space 𝕜,	ι : Type u_1,	_inst_12 : fintype ι,	f : ι → E,	hf : (⇑(linear_map.lsum 𝕜 (λ (i : ι), 𝕜) ℕ) (λ (i : ι), linear_map.id.smul_right (f i))).ker = ⊥,	K : nnreal,	K0 : K > 0,	hK : antilipschitz_with K ⇑(⇑(linear_map.lsum 𝕜 (λ (i : ι), 𝕜) ℕ) (λ (i : ι), linear_map.id.smul_right (f i))),	this : filter.tendsto (λ (g : ι → E), ∑ (i : ι), ∥g i - f i∥) (𝓝 f) (𝓝 0),	g : ι → E,	hg : ∑ (i : ι), ∥g i - f i∥₊ < K⁻¹,	v u : Π (i : ι), (λ (i : ι), 𝕜) i	⊢ ∥∑ (x : ι), (v x - u x) • (g x - f x)∥ ≤ ∑ (x : ι), ∥g x - f x∥ * ∥v - u∥
𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type v,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	_inst_11 : complete_space 𝕜,	ι : Type u_1,	_inst_12 : fintype ι,	f : ι → E,	hf : (⇑(linear_map.lsum 𝕜 (λ (i : ι), 𝕜) ℕ) (λ (i : ι), linear_map.id.smul_right (f i))).ker = ⊥,	K : nnreal,	K0 : K > 0,	hK : antilipschitz_with K ⇑(⇑(linear_map.lsum 𝕜 (λ (i : ι), 𝕜) ℕ) (λ (i : ι), linear_map.id.smul_right (f i))),	this : filter.tendsto (λ (g : ι → E), ∑ (i : ι), ∥g i - f i∥) (𝓝 f) (𝓝 0),	g : ι → E,	hg : ∑ (i : ι), ∥g i - f i∥₊ < K⁻¹,	v u : Π (i : ι), (λ (i : ι), 𝕜) i,	i : ι,	_x : i ∈ finset.univ	⊢ ∥(v i - u i) • (g i - f i)∥ ≤ ∥g i - f i∥ * ∥v - u∥
𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type v,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	_inst_11 : complete_space 𝕜,	ι : Type u_1,	_inst_12 : fintype ι,	f : ι → E,	hf : (⇑(linear_map.lsum 𝕜 (λ (i : ι), 𝕜) ℕ) (λ (i : ι), linear_map.id.smul_right (f i))).ker = ⊥,	K : nnreal,	K0 : K > 0,	hK : antilipschitz_with K ⇑(⇑(linear_map.lsum 𝕜 (λ (i : ι), 𝕜) ℕ) (λ (i : ι), linear_map.id.smul_right (f i))),	this : filter.tendsto (λ (g : ι → E), ∑ (i : ι), ∥g i - f i∥) (𝓝 f) (𝓝 0),	g : ι → E,	hg : ∑ (i : ι), ∥g i - f i∥₊ < K⁻¹,	v u : Π (i : ι), (λ (i : ι), 𝕜) i,	i : ι,	_x : i ∈ finset.univ	⊢ ∥g i - f i∥ * ∥v i - u i∥ ≤ ∥g i - f i∥ * ∥v - u∥
𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type v,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	_inst_11 : complete_space 𝕜,	_inst_13 : finite_dimensional 𝕜 E	⊢ complete_space E
𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type v,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	_inst_11 : complete_space 𝕜,	_inst_13 : finite_dimensional 𝕜 E,	e : E ≃L[𝕜] fin (finite_dimensional.finrank 𝕜 E) → 𝕜 := continuous_linear_equiv.of_finrank_eq _	⊢ complete_space E
𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type v,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	_inst_11 : complete_space 𝕜,	_inst_13 : finite_dimensional 𝕜 E,	e : E ≃L[𝕜] fin (finite_dimensional.finrank 𝕜 E) → 𝕜 := continuous_linear_equiv.of_finrank_eq _,	this : uniform_embedding ⇑(e.to_linear_equiv.to_equiv.symm)	⊢ complete_space E
𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type v,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	_inst_11 : complete_space 𝕜,	_inst_13 : finite_dimensional 𝕜 E,	e : E ≃L[𝕜] fin (finite_dimensional.finrank 𝕜 E) → 𝕜 := continuous_linear_equiv.of_finrank_eq _,	this : uniform_embedding ⇑(e.to_linear_equiv.to_equiv.symm)	⊢ complete_space (fin (finite_dimensional.finrank 𝕜 E) → 𝕜)
R : Type u_1,	E : Type u_2,	F : Type u_3,	_inst_1 : semiring R,	_inst_2 : semi_normed_group E,	_inst_3 : semi_normed_group F,	_inst_6 : module R E,	_inst_7 : module R F,	e : E ≃ₗᵢ[R] F	⊢ set.range ⇑(e.to_isometric) = set.univ
R : Type u_1,	E : Type u_2,	F : Type u_3,	_inst_1 : semiring R,	_inst_2 : semi_normed_group E,	_inst_3 : semi_normed_group F,	_inst_6 : module R E,	_inst_7 : module R F,	e : E ≃ₗᵢ[R] F	⊢ set.range ⇑e = set.univ
𝕜 : Type u,	ι : Type v,	E : ι → Type wE,	G : Type wG,	_inst_1 : decidable_eq ι,	_inst_2 : fintype ι,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_6 : Π (i : ι), normed_group (E i),	_inst_7 : Π (i : ι), normed_space 𝕜 (E i),	_inst_14 : normed_group G,	_inst_15 : normed_space 𝕜 G,	f : continuous_multilinear_map 𝕜 E G	⊢ ∥f∥ = 0 ↔ f = 0
𝕜 : Type u,	ι : Type v,	E : ι → Type wE,	G : Type wG,	_inst_1 : decidable_eq ι,	_inst_2 : fintype ι,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_6 : Π (i : ι), normed_group (E i),	_inst_7 : Π (i : ι), normed_space 𝕜 (E i),	_inst_14 : normed_group G,	_inst_15 : normed_space 𝕜 G,	f : continuous_multilinear_map 𝕜 E G	⊢ ∥f∥ = 0 → f = 0
𝕜 : Type u,	ι : Type v,	E : ι → Type wE,	G : Type wG,	_inst_1 : decidable_eq ι,	_inst_2 : fintype ι,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_6 : Π (i : ι), normed_group (E i),	_inst_7 : Π (i : ι), normed_space 𝕜 (E i),	_inst_14 : normed_group G,	_inst_15 : normed_space 𝕜 G,	f : continuous_multilinear_map 𝕜 E G,	h : ∥f∥ = 0	⊢ f = 0
𝕜 : Type u,	ι : Type v,	E : ι → Type wE,	G : Type wG,	_inst_1 : decidable_eq ι,	_inst_2 : fintype ι,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_6 : Π (i : ι), normed_group (E i),	_inst_7 : Π (i : ι), normed_space 𝕜 (E i),	_inst_14 : normed_group G,	_inst_15 : normed_space 𝕜 G,	f : continuous_multilinear_map 𝕜 E G	⊢ ∥f∥ = 0 → f = 0		𝕜 : Type u,	ι : Type v,	E : ι → Type wE,	G : Type wG,	_inst_1 : decidable_eq ι,	_inst_2 : fintype ι,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_6 : Π (i : ι), normed_group (E i),	_inst_7 : Π (i : ι), normed_space 𝕜 (E i),	_inst_14 : normed_group G,	_inst_15 : normed_space 𝕜 G,	f : continuous_multilinear_map 𝕜 E G	⊢ f = 0 → ∥f∥ = 0
𝕜 : Type u,	ι : Type v,	E : ι → Type wE,	G : Type wG,	_inst_1 : decidable_eq ι,	_inst_2 : fintype ι,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_6 : Π (i : ι), normed_group (E i),	_inst_7 : Π (i : ι), normed_space 𝕜 (E i),	_inst_14 : normed_group G,	_inst_15 : normed_space 𝕜 G,	f : continuous_multilinear_map 𝕜 E G,	h : ∥f∥ = 0,	m : Π (i : ι), E i	⊢ ⇑f m = ⇑0 m
𝕜 : Type u,	ι : Type v,	E : ι → Type wE,	G : Type wG,	_inst_1 : decidable_eq ι,	_inst_2 : fintype ι,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_6 : Π (i : ι), normed_group (E i),	_inst_7 : Π (i : ι), normed_space 𝕜 (E i),	_inst_14 : normed_group G,	_inst_15 : normed_space 𝕜 G,	f : continuous_multilinear_map 𝕜 E G	⊢ f = 0 → ∥f∥ = 0
𝕜 : Type u,	ι : Type v,	E : ι → Type wE,	G : Type wG,	_inst_1 : decidable_eq ι,	_inst_2 : fintype ι,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_6 : Π (i : ι), normed_group (E i),	_inst_7 : Π (i : ι), normed_space 𝕜 (E i),	_inst_14 : normed_group G,	_inst_15 : normed_space 𝕜 G	⊢ ∥0∥ = 0
𝕜 : Type u,	ι : Type v,	E : ι → Type wE,	G : Type wG,	_inst_1 : decidable_eq ι,	_inst_2 : fintype ι,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_6 : Π (i : ι), normed_group (E i),	_inst_7 : Π (i : ι), normed_space 𝕜 (E i),	_inst_14 : normed_group G,	_inst_15 : normed_space 𝕜 G,	m : Π (i : ι), E i	⊢ ∥⇑0 m∥ ≤ 0 * ∏ (i : ι), ∥m i∥
𝕜 : Type u,	ι : Type v,	E : ι → Type wE,	G : Type wG,	G' : Type wG',	_inst_1 : decidable_eq ι,	_inst_2 : fintype ι,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_6 : Π (i : ι), normed_group (E i),	_inst_7 : Π (i : ι), normed_space 𝕜 (E i),	_inst_14 : normed_group G,	_inst_15 : normed_space 𝕜 G,	_inst_16 : normed_group G',	_inst_17 : normed_space 𝕜 G',	f : continuous_multilinear_map 𝕜 E G × continuous_multilinear_map 𝕜 E G'	⊢ (λ (f : continuous_multilinear_map 𝕜 E (G × G')), ((continuous_linear_map.fst 𝕜 G G').comp_continuous_multilinear_map f, (continuous_linear_map.snd 𝕜 G G').comp_continuous_multilinear_map f)) ((λ (f : continuous_multilinear_map 𝕜 E G × continuous_multilinear_map 𝕜 E G'), f.fst.prod f.snd) f) = f
𝕜 : Type u,	ι : Type v,	E : ι → Type wE,	G : Type wG,	G' : Type wG',	_inst_1 : decidable_eq ι,	_inst_2 : fintype ι,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_6 : Π (i : ι), normed_group (E i),	_inst_7 : Π (i : ι), normed_space 𝕜 (E i),	_inst_14 : normed_group G,	_inst_15 : normed_space 𝕜 G,	_inst_16 : normed_group G',	_inst_17 : normed_space 𝕜 G',	f : continuous_multilinear_map 𝕜 E G × continuous_multilinear_map 𝕜 E G'	⊢ (λ (f : continuous_multilinear_map 𝕜 E (G × G')), ((continuous_linear_map.fst 𝕜 G G').comp_continuous_multilinear_map f, (continuous_linear_map.snd 𝕜 G G').comp_continuous_multilinear_map f)) ((λ (f : continuous_multilinear_map 𝕜 E G × continuous_multilinear_map 𝕜 E G'), f.fst.prod f.snd) f) = f
𝕜 : Type u,	ι : Type v,	E : ι → Type wE,	G : Type wG,	G' : Type wG',	_inst_1 : decidable_eq ι,	_inst_2 : fintype ι,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_6 : Π (i : ι), normed_group (E i),	_inst_7 : Π (i : ι), normed_space 𝕜 (E i),	_inst_14 : normed_group G,	_inst_15 : normed_space 𝕜 G,	_inst_16 : normed_group G',	_inst_17 : normed_space 𝕜 G',	f : continuous_multilinear_map 𝕜 E G × continuous_multilinear_map 𝕜 E G',	x : Π (i : ι), E i	⊢ ⇑(((λ (f : continuous_multilinear_map 𝕜 E (G × G')), ((continuous_linear_map.fst 𝕜 G G').comp_continuous_multilinear_map f, (continuous_linear_map.snd 𝕜 G G').comp_continuous_multilinear_map f)) ((λ (f : continuous_multilinear_map 𝕜 E G × continuous_multilinear_map 𝕜 E G'), f.fst.prod f.snd) f)).fst) x = ⇑(f.fst) x
𝕜 : Type u,	ι : Type v,	E : ι → Type wE,	G : Type wG,	G' : Type wG',	_inst_1 : decidable_eq ι,	_inst_2 : fintype ι,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_6 : Π (i : ι), normed_group (E i),	_inst_7 : Π (i : ι), normed_space 𝕜 (E i),	_inst_14 : normed_group G,	_inst_15 : normed_space 𝕜 G,	_inst_16 : normed_group G',	_inst_17 : normed_space 𝕜 G',	f : continuous_multilinear_map 𝕜 E G × continuous_multilinear_map 𝕜 E G',	x : Π (i : ι), E i	⊢ ⇑(((λ (f : continuous_multilinear_map 𝕜 E (G × G')), ((continuous_linear_map.fst 𝕜 G G').comp_continuous_multilinear_map f, (continuous_linear_map.snd 𝕜 G G').comp_continuous_multilinear_map f)) ((λ (f : continuous_multilinear_map 𝕜 E G × continuous_multilinear_map 𝕜 E G'), f.fst.prod f.snd) f)).snd) x = ⇑(f.snd) x
𝕜 : Type u,	ι : Type v,	E : ι → Type wE,	G : Type wG,	G' : Type wG',	_inst_1 : decidable_eq ι,	_inst_2 : fintype ι,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_6 : Π (i : ι), normed_group (E i),	_inst_7 : Π (i : ι), normed_space 𝕜 (E i),	_inst_14 : normed_group G,	_inst_15 : normed_space 𝕜 G,	_inst_16 : normed_group G',	_inst_17 : normed_space 𝕜 G',	f : continuous_multilinear_map 𝕜 E (G × G')	⊢ (λ (f : continuous_multilinear_map 𝕜 E G × continuous_multilinear_map 𝕜 E G'), f.fst.prod f.snd) ((λ (f : continuous_multilinear_map 𝕜 E (G × G')), ((continuous_linear_map.fst 𝕜 G G').comp_continuous_multilinear_map f, (continuous_linear_map.snd 𝕜 G G').comp_continuous_multilinear_map f)) f) = f
𝕜 : Type u,	ι : Type v,	E : ι → Type wE,	G : Type wG,	G' : Type wG',	_inst_1 : decidable_eq ι,	_inst_2 : fintype ι,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_6 : Π (i : ι), normed_group (E i),	_inst_7 : Π (i : ι), normed_space 𝕜 (E i),	_inst_14 : normed_group G,	_inst_15 : normed_space 𝕜 G,	_inst_16 : normed_group G',	_inst_17 : normed_space 𝕜 G',	f : continuous_multilinear_map 𝕜 E (G × G')	⊢ (λ (f : continuous_multilinear_map 𝕜 E G × continuous_multilinear_map 𝕜 E G'), f.fst.prod f.snd) ((λ (f : continuous_multilinear_map 𝕜 E (G × G')), ((continuous_linear_map.fst 𝕜 G G').comp_continuous_multilinear_map f, (continuous_linear_map.snd 𝕜 G G').comp_continuous_multilinear_map f)) f) = f
𝕜 : Type u,	ι : Type v,	E : ι → Type wE,	G : Type wG,	G' : Type wG',	_inst_1 : decidable_eq ι,	_inst_2 : fintype ι,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_6 : Π (i : ι), normed_group (E i),	_inst_7 : Π (i : ι), normed_space 𝕜 (E i),	_inst_14 : normed_group G,	_inst_15 : normed_space 𝕜 G,	_inst_16 : normed_group G',	_inst_17 : normed_space 𝕜 G',	f : continuous_multilinear_map 𝕜 E (G × G'),	x : Π (i : ι), E i	⊢ (⇑((λ (f : continuous_multilinear_map 𝕜 E G × continuous_multilinear_map 𝕜 E G'), f.fst.prod f.snd) ((λ (f : continuous_multilinear_map 𝕜 E (G × G')), ((continuous_linear_map.fst 𝕜 G G').comp_continuous_multilinear_map f, (continuous_linear_map.snd 𝕜 G G').comp_continuous_multilinear_map f)) f)) x).fst = (⇑f x).fst
𝕜 : Type u,	ι : Type v,	E : ι → Type wE,	G : Type wG,	G' : Type wG',	_inst_1 : decidable_eq ι,	_inst_2 : fintype ι,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_6 : Π (i : ι), normed_group (E i),	_inst_7 : Π (i : ι), normed_space 𝕜 (E i),	_inst_14 : normed_group G,	_inst_15 : normed_space 𝕜 G,	_inst_16 : normed_group G',	_inst_17 : normed_space 𝕜 G',	f : continuous_multilinear_map 𝕜 E (G × G'),	x : Π (i : ι), E i	⊢ (⇑((λ (f : continuous_multilinear_map 𝕜 E G × continuous_multilinear_map 𝕜 E G'), f.fst.prod f.snd) ((λ (f : continuous_multilinear_map 𝕜 E (G × G')), ((continuous_linear_map.fst 𝕜 G G').comp_continuous_multilinear_map f, (continuous_linear_map.snd 𝕜 G G').comp_continuous_multilinear_map f)) f)) x).snd = (⇑f x).snd
𝕜 : Type u,	ι : Type v,	E : ι → Type wE,	G : Type wG,	_inst_1 : decidable_eq ι,	_inst_2 : fintype ι,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_6 : Π (i : ι), normed_group (E i),	_inst_7 : Π (i : ι), normed_space 𝕜 (E i),	_inst_14 : normed_group G,	_inst_15 : normed_space 𝕜 G,	α : Type u_1,	p : α → continuous_multilinear_map 𝕜 E G,	q : continuous_multilinear_map 𝕜 E G,	h : has_sum p q,	m : Π (i : ι), E i	⊢ has_sum (λ (a : α), ⇑(p a) m) (⇑q m)
𝕜 : Type u,	ι : Type v,	E : ι → Type wE,	G : Type wG,	_inst_1 : decidable_eq ι,	_inst_2 : fintype ι,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_6 : Π (i : ι), normed_group (E i),	_inst_7 : Π (i : ι), normed_space 𝕜 (E i),	_inst_14 : normed_group G,	_inst_15 : normed_space 𝕜 G,	α : Type u_1,	p : α → continuous_multilinear_map 𝕜 E G,	q : continuous_multilinear_map 𝕜 E G,	m : Π (i : ι), E i,	h : filter.tendsto (λ (s : finset α), s.sum p) filter.at_top (nhds q)	⊢ filter.tendsto (λ (s : finset α), ∑ (b : α) in s, ⇑(p b) m) filter.at_top (nhds (⇑q m))
𝕜 : Type u,	ι : Type v,	E : ι → Type wE,	G : Type wG,	_inst_1 : decidable_eq ι,	_inst_2 : fintype ι,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_6 : Π (i : ι), normed_group (E i),	_inst_7 : Π (i : ι), normed_space 𝕜 (E i),	_inst_14 : normed_group G,	_inst_15 : normed_space 𝕜 G,	α : Type u_1,	p : α → continuous_multilinear_map 𝕜 E G,	q : continuous_multilinear_map 𝕜 E G,	m : Π (i : ι), E i,	h : filter.tendsto (λ (s : finset α), s.sum p) filter.at_top (nhds q)	⊢ (λ (s : finset α), ∑ (b : α) in s, ⇑(p b) m) = (λ (p : continuous_multilinear_map 𝕜 E G), ⇑p m) ∘ λ (s : finset α), s.sum p
𝕜 : Type u,	ι : Type v,	E : ι → Type wE,	G : Type wG,	_inst_1 : decidable_eq ι,	_inst_2 : fintype ι,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_6 : Π (i : ι), normed_group (E i),	_inst_7 : Π (i : ι), normed_space 𝕜 (E i),	_inst_14 : normed_group G,	_inst_15 : normed_space 𝕜 G,	α : Type u_1,	p : α → continuous_multilinear_map 𝕜 E G,	q : continuous_multilinear_map 𝕜 E G,	m : Π (i : ι), E i,	h : filter.tendsto (λ (s : finset α), s.sum p) filter.at_top (nhds q),	s : finset α	⊢ ∑ (b : α) in s, ⇑(p b) m = ((λ (p : continuous_multilinear_map 𝕜 E G), ⇑p m) ∘ λ (s : finset α), s.sum p) s
V : Type u_1,	_inst_1 : semi_normed_group V,	s : add_subgroup V,	v : ↥s	⊢ ∥↑v∥ ≤ 1 * ∥v∥
V : Type u_1,	_inst_1 : semi_normed_group V,	s : add_subgroup V,	v : ↥s	⊢ ∥↑v∥ ≤ ∥v∥
V₁ : Type u_3,	V₂ : Type u_4,	_inst_3 : semi_normed_group V₁,	_inst_4 : semi_normed_group V₂,	v : V₁	⊢ ∥⇑0 v∥ ≤ ∥v∥
M : Type u_1,	_inst_1 : semi_normed_group M,	S : add_subgroup M	⊢ ∀ (t : set (quotient_add_group.quotient S)), t ∈ 𝓝 0 ↔ ∃ (i : ℝ) (hi : 0 < i), {x : quotient_add_group.quotient S | ∥x∥ < i} ⊆ t
M : Type u_1,	_inst_1 : semi_normed_group M,	S : add_subgroup M,	U : set (quotient_add_group.quotient S)	⊢ U ∈ 𝓝 0 ↔ ∃ (i : ℝ) (hi : 0 < i), {x : quotient_add_group.quotient S | ∥x∥ < i} ⊆ U
M : Type u_1,	_inst_1 : semi_normed_group M,	S : add_subgroup M,	U : set (quotient_add_group.quotient S)	⊢ U ∈ 𝓝 0 → (∃ (i : ℝ) (hi : 0 < i), {x : quotient_add_group.quotient S | ∥x∥ < i} ⊆ U)
M : Type u_1,	_inst_1 : semi_normed_group M,	S : add_subgroup M,	U : set (quotient_add_group.quotient S),	U_in : U ∈ 𝓝 0	⊢ ∃ (i : ℝ) (hi : 0 < i), {x : quotient_add_group.quotient S | ∥x∥ < i} ⊆ U
M : Type u_1,	_inst_1 : semi_normed_group M,	S : add_subgroup M,	U : set (quotient_add_group.quotient S),	U_in : U ∈ 𝓝 (⇑(quotient_add_group.mk' S) 0)	⊢ ∃ (i : ℝ) (hi : 0 < i), {x : quotient_add_group.quotient S | ∥x∥ < i} ⊆ U
M : Type u_1,	_inst_1 : semi_normed_group M,	S : add_subgroup M,	U : set (quotient_add_group.quotient S),	U_in : U ∈ 𝓝 (⇑(quotient_add_group.mk' S) 0),	this : ⇑(quotient_add_group.mk' S) ⁻¹' U ∈ 𝓝 0	⊢ ∃ (i : ℝ) (hi : 0 < i), {x : quotient_add_group.quotient S | ∥x∥ < i} ⊆ U
M : Type u_1,	_inst_1 : semi_normed_group M,	S : add_subgroup M,	U : set (quotient_add_group.quotient S),	U_in : U ∈ 𝓝 (⇑(quotient_add_group.mk' S) 0),	this : ⇑(quotient_add_group.mk' S) ⁻¹' U ∈ 𝓝 0,	ε : ℝ,	ε_pos : ε > 0,	H : metric.ball 0 ε ⊆ ⇑(quotient_add_group.mk' S) ⁻¹' U	⊢ ∃ (i : ℝ) (hi : 0 < i), {x : quotient_add_group.quotient S | ∥x∥ < i} ⊆ U
M : Type u_1,	_inst_1 : semi_normed_group M,	S : add_subgroup M,	U : set (quotient_add_group.quotient S),	U_in : U ∈ 𝓝 (⇑(quotient_add_group.mk' S) 0),	this : ⇑(quotient_add_group.mk' S) ⁻¹' U ∈ 𝓝 0,	ε : ℝ,	ε_pos : ε > 0,	H : metric.ball 0 ε ⊆ ⇑(quotient_add_group.mk' S) ⁻¹' U	⊢ {x : quotient_add_group.quotient S | ∥x∥ < ε / 2} ⊆ U
M : Type u_1,	_inst_1 : semi_normed_group M,	S : add_subgroup M,	U : set (quotient_add_group.quotient S),	U_in : U ∈ 𝓝 (⇑(quotient_add_group.mk' S) 0),	this : ⇑(quotient_add_group.mk' S) ⁻¹' U ∈ 𝓝 0,	ε : ℝ,	ε_pos : ε > 0,	H : metric.ball 0 ε ⊆ ⇑(quotient_add_group.mk' S) ⁻¹' U,	x : quotient_add_group.quotient S,	x_in : x ∈ {x : quotient_add_group.quotient S | ∥x∥ < ε / 2}	⊢ x ∈ U
M : Type u_1,	_inst_1 : semi_normed_group M,	S : add_subgroup M,	U : set (quotient_add_group.quotient S),	U_in : U ∈ 𝓝 (⇑(quotient_add_group.mk' S) 0),	this : ⇑(quotient_add_group.mk' S) ⁻¹' U ∈ 𝓝 0,	ε : ℝ,	ε_pos : ε > 0,	H : metric.ball 0 ε ⊆ ⇑(quotient_add_group.mk' S) ⁻¹' U,	x : quotient_add_group.quotient S,	x_in : ∥x∥ < ε / 2	⊢ x ∈ U
M : Type u_1,	_inst_1 : semi_normed_group M,	S : add_subgroup M,	U : set (quotient_add_group.quotient S),	U_in : U ∈ 𝓝 (⇑(quotient_add_group.mk' S) 0),	this : ⇑(quotient_add_group.mk' S) ⁻¹' U ∈ 𝓝 0,	ε : ℝ,	ε_pos : ε > 0,	H : metric.ball 0 ε ⊆ ⇑(quotient_add_group.mk' S) ⁻¹' U,	y : M,	x_in : ∥⇑(quotient_add_group.mk' S) y∥ < ε / 2,	ry : ∥y∥ < ∥⇑(quotient_add_group.mk' S) y∥ + ε / 2	⊢ ⇑(quotient_add_group.mk' S) y ∈ U
M : Type u_1,	_inst_1 : semi_normed_group M,	S : add_subgroup M,	U : set (quotient_add_group.quotient S),	U_in : U ∈ 𝓝 (⇑(quotient_add_group.mk' S) 0),	this : ⇑(quotient_add_group.mk' S) ⁻¹' U ∈ 𝓝 0,	ε : ℝ,	ε_pos : ε > 0,	H : metric.ball 0 ε ⊆ ⇑(quotient_add_group.mk' S) ⁻¹' U,	y : M,	x_in : ∥⇑(quotient_add_group.mk' S) y∥ < ε / 2,	ry : ∥y∥ < ∥⇑(quotient_add_group.mk' S) y∥ + ε / 2	⊢ y ∈ metric.ball 0 ε
M : Type u_1,	_inst_1 : semi_normed_group M,	S : add_subgroup M,	U : set (quotient_add_group.quotient S),	U_in : U ∈ 𝓝 (⇑(quotient_add_group.mk' S) 0),	this : ⇑(quotient_add_group.mk' S) ⁻¹' U ∈ 𝓝 0,	ε : ℝ,	ε_pos : ε > 0,	H : metric.ball 0 ε ⊆ ⇑(quotient_add_group.mk' S) ⁻¹' U,	y : M,	x_in : ∥⇑(quotient_add_group.mk' S) y∥ < ε / 2,	ry : ∥y∥ < ∥⇑(quotient_add_group.mk' S) y∥ + ε / 2	⊢ y ∈ {x : M | ∥x∥ < ε}
M : Type u_1,	_inst_1 : semi_normed_group M,	S : add_subgroup M,	U : set (quotient_add_group.quotient S)	⊢ U ∈ 𝓝 0 → (∃ (i : ℝ) (hi : 0 < i), {x : quotient_add_group.quotient S | ∥x∥ < i} ⊆ U)		M : Type u_1,	_inst_1 : semi_normed_group M,	S : add_subgroup M,	U : set (quotient_add_group.quotient S)	⊢ (∃ (i : ℝ) (hi : 0 < i), {x : quotient_add_group.quotient S | ∥x∥ < i} ⊆ U) → U ∈ 𝓝 0
M : Type u_1,	_inst_1 : semi_normed_group M,	S : add_subgroup M,	U : set (quotient_add_group.quotient S),	U_in : U ∈ 𝓝 (⇑(quotient_add_group.mk' S) 0),	this : ⇑(quotient_add_group.mk' S) ⁻¹' U ∈ 𝓝 0,	ε : ℝ,	ε_pos : ε > 0,	H : metric.ball 0 ε ⊆ ⇑(quotient_add_group.mk' S) ⁻¹' U,	y : M,	x_in : ∥⇑(quotient_add_group.mk' S) y∥ < ε / 2,	ry : ∥y∥ < ∥⇑(quotient_add_group.mk' S) y∥ + ε / 2	⊢ ∥y∥ < ε
M : Type u_1,	_inst_1 : semi_normed_group M,	S : add_subgroup M,	U : set (quotient_add_group.quotient S)	⊢ (∃ (i : ℝ) (hi : 0 < i), {x : quotient_add_group.quotient S | ∥x∥ < i} ⊆ U) → U ∈ 𝓝 0
M : Type u_1,	_inst_1 : semi_normed_group M,	S : add_subgroup M,	U : set (quotient_add_group.quotient S),	ε : ℝ,	ε_pos : 0 < ε,	h : {x : quotient_add_group.quotient S | ∥x∥ < ε} ⊆ U	⊢ U ∈ 𝓝 0
M : Type u_1,	_inst_1 : semi_normed_group M,	S : add_subgroup M,	U : set (quotient_add_group.quotient S),	ε : ℝ,	ε_pos : 0 < ε,	h : {x : quotient_add_group.quotient S | ∥x∥ < ε} ⊆ U	⊢ ⇑(quotient_add_group.mk' S) '' metric.ball 0 ε ⊆ {x : quotient_add_group.quotient S | ∥x∥ < ε}
M : Type u_1,	_inst_1 : semi_normed_group M,	S : add_subgroup M,	U : set (quotient_add_group.quotient S),	ε : ℝ,	ε_pos : 0 < ε,	h : {x : quotient_add_group.quotient S | ∥x∥ < ε} ⊆ U,	x : M,	x_in : x ∈ metric.ball 0 ε	⊢ ⇑(quotient_add_group.mk' S) x ∈ {x : quotient_add_group.quotient S | ∥x∥ < ε}
M : Type u_1,	_inst_1 : semi_normed_group M,	S : add_subgroup M,	U : set (quotient_add_group.quotient S),	ε : ℝ,	ε_pos : 0 < ε,	h : {x : quotient_add_group.quotient S | ∥x∥ < ε} ⊆ U	⊢ ⇑(quotient_add_group.mk' S) '' metric.ball 0 ε ⊆ {x : quotient_add_group.quotient S | ∥x∥ < ε}		M : Type u_1,	_inst_1 : semi_normed_group M,	S : add_subgroup M,	U : set (quotient_add_group.quotient S),	ε : ℝ,	ε_pos : 0 < ε,	h : {x : quotient_add_group.quotient S | ∥x∥ < ε} ⊆ U,	this : ⇑(quotient_add_group.mk' S) '' metric.ball 0 ε ⊆ {x : quotient_add_group.quotient S | ∥x∥ < ε}	⊢ U ∈ 𝓝 0
M : Type u_1,	_inst_1 : semi_normed_group M,	S : add_subgroup M,	U : set (quotient_add_group.quotient S),	ε : ℝ,	ε_pos : 0 < ε,	h : {x : quotient_add_group.quotient S | ∥x∥ < ε} ⊆ U,	x : M,	x_in : ∥x∥ < ε	⊢ ⇑(quotient_add_group.mk' S) x ∈ {x : quotient_add_group.quotient S | ∥x∥ < ε}
M : Type u_1,	_inst_1 : semi_normed_group M,	S : add_subgroup M,	U : set (quotient_add_group.quotient S),	ε : ℝ,	ε_pos : 0 < ε,	h : {x : quotient_add_group.quotient S | ∥x∥ < ε} ⊆ U,	this : ⇑(quotient_add_group.mk' S) '' metric.ball 0 ε ⊆ {x : quotient_add_group.quotient S | ∥x∥ < ε}	⊢ U ∈ 𝓝 0
M : Type u_1,	_inst_1 : semi_normed_group M,	S : add_subgroup M,	U : set (quotient_add_group.quotient S),	ε : ℝ,	ε_pos : 0 < ε,	h : {x : quotient_add_group.quotient S | ∥x∥ < ε} ⊆ U,	this : ⇑(quotient_add_group.mk' S) '' metric.ball 0 ε ⊆ {x : quotient_add_group.quotient S | ∥x∥ < ε}	⊢ ⇑(quotient_add_group.mk' S) '' metric.ball 0 ε ∈ 𝓝 0
M : Type u_1,	_inst_1 : semi_normed_group M,	S : add_subgroup M,	ε : ℝ,	ε_pos : 0 < ε	⊢ ⇑(quotient_add_group.mk' S) '' metric.ball 0 ε ∈ 𝓝 0
M : Type u_1,	_inst_1 : semi_normed_group M,	S : add_subgroup M,	ε : ℝ,	ε_pos : 0 < ε	⊢ is_open (⇑(quotient_add_group.mk' S) '' metric.ball 0 ε)
M : Type u_1,	_inst_1 : semi_normed_group M,	S : add_subgroup M,	ε : ℝ,	ε_pos : 0 < ε	⊢ is_open (⇑(quotient_add_group.mk' S) ⁻¹' (⇑(quotient_add_group.mk' S) '' metric.ball 0 ε))
M : Type u_1,	_inst_1 : semi_normed_group M,	S : add_subgroup M,	ε : ℝ,	ε_pos : 0 < ε	⊢ is_open (⋃ (x : ↥S), (λ (y : M), y + ↑x) ⁻¹' metric.ball 0 ε)
M : Type u_1,	_inst_1 : semi_normed_group M,	S : add_subgroup M,	ε : ℝ,	ε_pos : 0 < ε	⊢ ∀ (i : ↥S), is_open ((λ (y : M), y + ↑i) ⁻¹' metric.ball 0 ε)
M : Type u_1,	_inst_1 : semi_normed_group M,	S : add_subgroup M,	ε : ℝ,	ε_pos : 0 < ε	⊢ is_open (⇑(quotient_add_group.mk' S) '' metric.ball 0 ε)		M : Type u_1,	_inst_1 : semi_normed_group M,	S : add_subgroup M,	ε : ℝ,	ε_pos : 0 < ε	⊢ 0 ∈ ⇑(quotient_add_group.mk' S) '' metric.ball 0 ε
M : Type u_1,	_inst_1 : semi_normed_group M,	S : add_subgroup M,	ε : ℝ,	ε_pos : 0 < ε,	s : M,	s_in : s ∈ S	⊢ is_open ((λ (y : M), y + ↑⟨s, s_in⟩) ⁻¹' metric.ball 0 ε)
M : Type u_1,	_inst_1 : semi_normed_group M,	S : add_subgroup M,	ε : ℝ,	ε_pos : 0 < ε	⊢ 0 ∈ ⇑(quotient_add_group.mk' S) '' metric.ball 0 ε
𝕜 : Type u_1,	E : Type u_2,	F : Type u_3,	G : Type u_4,	_inst_1 : semi_normed_group E,	_inst_2 : semi_normed_group F,	_inst_3 : semi_normed_group G,	_inst_4 : nondiscrete_normed_field 𝕜,	_inst_5 : semi_normed_space 𝕜 E,	_inst_6 : semi_normed_space 𝕜 F,	_inst_7 : semi_normed_space 𝕜 G,	f : E →L[𝕜] F,	g : E →L[𝕜] G,	x : E	⊢ ∥⇑(f.prod g) x∥ ≤ ∥(f, g)∥ * ∥x∥
ι : Type u_1,	p : ℝ,	hp : 1 ≤ p,	β : ι → Type u_3,	_inst_2 : Π (i : ι), pseudo_emetric_space (β i),	_inst_3 : fintype ι,	pos : 0 < p,	f : pi_Lp p hp β	⊢ has_edist.edist f f = 0
ι : Type u_1,	p : ℝ,	hp : 1 ≤ p,	β : ι → Type u_3,	_inst_2 : Π (i : ι), pseudo_emetric_space (β i),	_inst_3 : fintype ι,	pos : 0 < p,	f g : pi_Lp p hp β	⊢ has_edist.edist f g = has_edist.edist g f
ι : Type u_1,	p : ℝ,	hp : 1 ≤ p,	β : ι → Type u_3,	_inst_2 : Π (i : ι), pseudo_emetric_space (β i),	_inst_3 : fintype ι,	pos : 0 < p,	f g h : pi_Lp p hp β	⊢ (∑ (i : ι), has_edist.edist (f i) (h i) ^ p) ^ (1 / p) ≤ (∑ (i : ι), (has_edist.edist (f i) (g i) + has_edist.edist (g i) (h i)) ^ p) ^ (1 / p)
ι : Type u_1,	p : ℝ,	hp : 1 ≤ p,	β : ι → Type u_3,	_inst_2 : Π (i : ι), pseudo_emetric_space (β i),	_inst_3 : fintype ι,	pos : 0 < p,	f g h : pi_Lp p hp β	⊢ ∑ (i : ι), has_edist.edist (f i) (h i) ^ p ≤ ∑ (i : ι), (has_edist.edist (f i) (g i) + has_edist.edist (g i) (h i)) ^ p
ι : Type u_1,	p : ℝ,	hp : 1 ≤ p,	β : ι → Type u_3,	_inst_2 : Π (i : ι), pseudo_emetric_space (β i),	_inst_3 : fintype ι,	pos : 0 < p,	f g h : pi_Lp p hp β,	i : ι,	hi : i ∈ finset.univ	⊢ has_edist.edist (f i) (h i) ^ p ≤ (has_edist.edist (f i) (g i) + has_edist.edist (g i) (h i)) ^ p
ι : Type u_1,	p : ℝ,	hp : 1 ≤ p,	β : ι → Type u_3,	_inst_2 : Π (i : ι), pseudo_emetric_space (β i),	_inst_3 : fintype ι	⊢ antilipschitz_with (↑(fintype.card ι) ^ (1 / p)) ⇑(pi_Lp.equiv p hp β)
ι : Type u_1,	p : ℝ,	hp : 1 ≤ p,	β : ι → Type u_3,	_inst_2 : Π (i : ι), pseudo_emetric_space (β i),	_inst_3 : fintype ι,	pos : 0 < p	⊢ antilipschitz_with (↑(fintype.card ι) ^ (1 / p)) ⇑(pi_Lp.equiv p hp β)
ι : Type u_1,	p : ℝ,	hp : 1 ≤ p,	β : ι → Type u_3,	_inst_2 : Π (i : ι), pseudo_emetric_space (β i),	_inst_3 : fintype ι,	pos : 0 < p,	nonneg : 0 ≤ 1 / p	⊢ antilipschitz_with (↑(fintype.card ι) ^ (1 / p)) ⇑(pi_Lp.equiv p hp β)
ι : Type u_1,	p : ℝ,	hp : 1 ≤ p,	β : ι → Type u_3,	_inst_2 : Π (i : ι), pseudo_emetric_space (β i),	_inst_3 : fintype ι,	pos : 0 < p,	nonneg : 0 ≤ 1 / p,	cancel : p * (1 / p) = 1	⊢ antilipschitz_with (↑(fintype.card ι) ^ (1 / p)) ⇑(pi_Lp.equiv p hp β)
ι : Type u_1,	p : ℝ,	hp : 1 ≤ p,	β : ι → Type u_3,	_inst_2 : Π (i : ι), pseudo_emetric_space (β i),	_inst_3 : fintype ι,	pos : 0 < p,	nonneg : 0 ≤ 1 / p,	cancel : p * (1 / p) = 1,	x y : pi_Lp p hp β	⊢ has_edist.edist x y ≤ ↑(↑(fintype.card ι) ^ (1 / p)) * has_edist.edist (⇑(pi_Lp.equiv p hp β) x) (⇑(pi_Lp.equiv p hp β) y)
ι : Type u_1,	p : ℝ,	hp : 1 ≤ p,	β : ι → Type u_3,	_inst_2 : Π (i : ι), pseudo_emetric_space (β i),	_inst_3 : fintype ι,	pos : 0 < p,	nonneg : 0 ≤ 1 / p,	cancel : p * (1 / p) = 1,	x y : pi_Lp p hp β	⊢ (∑ (i : ι), has_edist.edist (x i) (y i) ^ p) ^ (1 / p) ≤ ↑(↑(fintype.card ι) ^ (1 / p)) * finset.univ.sup (λ (b : ι), has_edist.edist (⇑(pi_Lp.equiv p hp β) x b) (⇑(pi_Lp.equiv p hp β) y b))
ι : Type u_1,	p : ℝ,	hp : 1 ≤ p,	β : ι → Type u_3,	_inst_2 : Π (i : ι), pseudo_emetric_space (β i),	_inst_3 : fintype ι,	pos : 0 < p,	nonneg : 0 ≤ 1 / p,	cancel : p * (1 / p) = 1,	x y : pi_Lp p hp β	⊢ (∑ (i : ι), has_edist.edist (x i) (y i) ^ p) ^ (1 / p) ≤ (∑ (i : ι), has_edist.edist (⇑(pi_Lp.equiv p hp β) x) (⇑(pi_Lp.equiv p hp β) y) ^ p) ^ (1 / p)
ι : Type u_1,	p : ℝ,	hp : 1 ≤ p,	β : ι → Type u_3,	_inst_2 : Π (i : ι), pseudo_emetric_space (β i),	_inst_3 : fintype ι,	pos : 0 < p,	nonneg : 0 ≤ 1 / p,	cancel : p * (1 / p) = 1,	x y : pi_Lp p hp β	⊢ ∑ (i : ι), has_edist.edist (x i) (y i) ^ p ≤ ∑ (i : ι), has_edist.edist (⇑(pi_Lp.equiv p hp β) x) (⇑(pi_Lp.equiv p hp β) y) ^ p
ι : Type u_1,	p : ℝ,	hp : 1 ≤ p,	β : ι → Type u_3,	_inst_2 : Π (i : ι), pseudo_emetric_space (β i),	_inst_3 : fintype ι,	pos : 0 < p,	nonneg : 0 ≤ 1 / p,	cancel : p * (1 / p) = 1,	x y : pi_Lp p hp β,	i : ι,	hi : i ∈ finset.univ	⊢ has_edist.edist (x i) (y i) ^ p ≤ has_edist.edist (⇑(pi_Lp.equiv p hp β) x) (⇑(pi_Lp.equiv p hp β) y) ^ p
ι : Type u_1,	p : ℝ,	hp : 1 ≤ p,	β : ι → Type u_3,	_inst_2 : Π (i : ι), pseudo_emetric_space (β i),	_inst_3 : fintype ι,	pos : 0 < p,	nonneg : 0 ≤ 1 / p,	cancel : p * (1 / p) = 1,	x y : pi_Lp p hp β,	i : ι,	hi : i ∈ finset.univ	⊢ has_edist.edist (x i) (y i) ≤ has_edist.edist (⇑(pi_Lp.equiv p hp β) x) (⇑(pi_Lp.equiv p hp β) y)
ι : Type u_1,	p : ℝ,	hp : 1 ≤ p,	β : ι → Type u_3,	_inst_2 : Π (i : ι), pseudo_emetric_space (β i),	_inst_3 : fintype ι,	pos : 0 < p,	nonneg : 0 ≤ 1 / p,	cancel : p * (1 / p) = 1,	x y : pi_Lp p hp β	⊢ (∑ (i : ι), has_edist.edist (⇑(pi_Lp.equiv p hp β) x) (⇑(pi_Lp.equiv p hp β) y) ^ p) ^ (1 / p) = ↑(↑(fintype.card ι) ^ (1 / p)) * has_edist.edist (⇑(pi_Lp.equiv p hp β) x) (⇑(pi_Lp.equiv p hp β) y)
ι : Type u_1,	p : ℝ,	hp : 1 ≤ p,	β : ι → Type u_3,	_inst_2 : Π (i : ι), pseudo_emetric_space (β i),	_inst_3 : fintype ι,	pos : 0 < p,	nonneg : 0 ≤ 1 / p,	cancel : p * (1 / p) = 1,	x y : pi_Lp p hp β	⊢ ↑(fintype.card ι) ^ (1 / p) * has_edist.edist (⇑(pi_Lp.equiv p hp β) x) (⇑(pi_Lp.equiv p hp β) y) = ↑(↑(fintype.card ι) ^ (1 / p)) * has_edist.edist (⇑(pi_Lp.equiv p hp β) x) (⇑(pi_Lp.equiv p hp β) y)
ι : Type u_1,	p : ℝ,	hp : 1 ≤ p,	β : ι → Type u_3,	_inst_2 : Π (i : ι), pseudo_emetric_space (β i),	_inst_3 : fintype ι,	pos : 0 < p,	nonneg : 0 ≤ 1 / p,	cancel : p * (1 / p) = 1,	x y : pi_Lp p hp β,	this : ↑(fintype.card ι) = ↑↑(fintype.card ι)	⊢ ↑(fintype.card ι) ^ (1 / p) * has_edist.edist (⇑(pi_Lp.equiv p hp β) x) (⇑(pi_Lp.equiv p hp β) y) = ↑(↑(fintype.card ι) ^ (1 / p)) * has_edist.edist (⇑(pi_Lp.equiv p hp β) x) (⇑(pi_Lp.equiv p hp β) y)
𝕜 : Type u_1,	_inst_1 : normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	c : 𝕜,	hc : 1 < ∥c∥,	R : ℝ,	hR : ∥c∥ < R,	F : subspace 𝕜 E,	hFc : is_closed ↑F,	hF : ∃ (x : E), x ∉ F	⊢ ∃ (x₀ : E), ∥x₀∥ ≤ R ∧ ∀ (y : E), y ∈ F → 1 ≤ ∥x₀ - y∥
𝕜 : Type u_1,	_inst_1 : normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	c : 𝕜,	hc : 1 < ∥c∥,	R : ℝ,	hR : ∥c∥ < R,	F : subspace 𝕜 E,	hFc : is_closed ↑F,	hF : ∃ (x : E), x ∉ F,	Rpos : 0 < R	⊢ ∥c∥ / R < 1
𝕜 : Type u_1,	_inst_1 : normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	c : 𝕜,	hc : 1 < ∥c∥,	R : ℝ,	hR : ∥c∥ < R,	F : subspace 𝕜 E,	hFc : is_closed ↑F,	hF : ∃ (x : E), x ∉ F,	Rpos : 0 < R	⊢ ∃ (x₀ : E), ∥x₀∥ ≤ R ∧ ∀ (y : E), y ∈ F → 1 ≤ ∥x₀ - y∥
𝕜 : Type u_1,	_inst_1 : normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	c : 𝕜,	hc : 1 < ∥c∥,	R : ℝ,	hR : ∥c∥ < R,	F : subspace 𝕜 E,	hFc : is_closed ↑F,	hF : ∃ (x : E), x ∉ F,	Rpos : 0 < R	⊢ ∥c∥ < 1 * R
𝕜 : Type u_1,	_inst_1 : normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	c : 𝕜,	hc : 1 < ∥c∥,	R : ℝ,	hR : ∥c∥ < R,	F : subspace 𝕜 E,	hFc : is_closed ↑F,	hF : ∃ (x : E), x ∉ F,	Rpos : 0 < R,	this : ∥c∥ / R < 1	⊢ ∃ (x₀ : E), ∥x₀∥ ≤ R ∧ ∀ (y : E), y ∈ F → 1 ≤ ∥x₀ - y∥
𝕜 : Type u_1,	_inst_1 : normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	c : 𝕜,	hc : 1 < ∥c∥,	R : ℝ,	hR : ∥c∥ < R,	F : subspace 𝕜 E,	hFc : is_closed ↑F,	hF : ∃ (x : E), x ∉ F,	Rpos : 0 < R,	this : ∥c∥ / R < 1,	x : E,	xF : x ∉ F,	hx : ∀ (y : E), y ∈ F → ∥c∥ / R * ∥x∥ ≤ ∥x - y∥,	H : x = 0	⊢ false
𝕜 : Type u_1,	_inst_1 : normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	c : 𝕜,	hc : 1 < ∥c∥,	R : ℝ,	hR : ∥c∥ < R,	F : subspace 𝕜 E,	hFc : is_closed ↑F,	hF : ∃ (x : E), x ∉ F,	Rpos : 0 < R,	this : ∥c∥ / R < 1,	x : E,	xF : x ∉ F,	hx : ∀ (y : E), y ∈ F → ∥c∥ / R * ∥x∥ ≤ ∥x - y∥	⊢ ∃ (x₀ : E), ∥x₀∥ ≤ R ∧ ∀ (y : E), y ∈ F → 1 ≤ ∥x₀ - y∥
𝕜 : Type u_1,	_inst_1 : normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	c : 𝕜,	hc : 1 < ∥c∥,	R : ℝ,	hR : ∥c∥ < R,	F : subspace 𝕜 E,	hFc : is_closed ↑F,	hF : ∃ (x : E), x ∉ F,	Rpos : 0 < R,	this : ∥c∥ / R < 1,	x : E,	xF : x ∉ F,	hx : ∀ (y : E), y ∈ F → ∥c∥ / R * ∥x∥ ≤ ∥x - y∥,	x0 : x ≠ 0	⊢ ∃ (x₀ : E), ∥x₀∥ ≤ R ∧ ∀ (y : E), y ∈ F → 1 ≤ ∥x₀ - y∥
𝕜 : Type u_1,	_inst_1 : normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	c : 𝕜,	hc : 1 < ∥c∥,	R : ℝ,	hR : ∥c∥ < R,	F : subspace 𝕜 E,	hFc : is_closed ↑F,	hF : ∃ (x : E), x ∉ F,	Rpos : 0 < R,	this : ∥c∥ / R < 1,	x : E,	xF : x ∉ F,	hx : ∀ (y : E), y ∈ F → ∥c∥ / R * ∥x∥ ≤ ∥x - y∥,	x0 : x ≠ 0,	d : 𝕜,	d0 : d ≠ 0,	dxlt : ∥d • x∥ < R,	ledx : R / ∥c∥ ≤ ∥d • x∥	⊢ ∃ (x₀ : E), ∥x₀∥ ≤ R ∧ ∀ (y : E), y ∈ F → 1 ≤ ∥x₀ - y∥
𝕜 : Type u_1,	_inst_1 : normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	c : 𝕜,	hc : 1 < ∥c∥,	R : ℝ,	hR : ∥c∥ < R,	F : subspace 𝕜 E,	hFc : is_closed ↑F,	hF : ∃ (x : E), x ∉ F,	Rpos : 0 < R,	this : ∥c∥ / R < 1,	x : E,	xF : x ∉ F,	hx : ∀ (y : E), y ∈ F → ∥c∥ / R * ∥x∥ ≤ ∥x - y∥,	x0 : x ≠ 0,	d : 𝕜,	d0 : d ≠ 0,	dxlt : ∥d • x∥ < R,	ledx : R / ∥c∥ ≤ ∥d • x∥,	y : E,	hy : y ∈ F	⊢ 1 ≤ ∥d • x - y∥
𝕜 : Type u_1,	_inst_1 : normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	c : 𝕜,	hc : 1 < ∥c∥,	R : ℝ,	hR : ∥c∥ < R,	F : subspace 𝕜 E,	hFc : is_closed ↑F,	hF : ∃ (x : E), x ∉ F,	Rpos : 0 < R,	this : ∥c∥ / R < 1,	x : E,	xF : x ∉ F,	hx : ∀ (y : E), y ∈ F → ∥c∥ / R * ∥x∥ ≤ ∥x - y∥,	x0 : x ≠ 0,	d : 𝕜,	d0 : d ≠ 0,	dxlt : ∥d • x∥ < R,	ledx : R / ∥c∥ ≤ ∥d • x∥,	y : E,	hy : y ∈ F,	y' : E := d⁻¹ • y,	hy' : y' = d⁻¹ • y	⊢ y' ∈ F
𝕜 : Type u_1,	_inst_1 : normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	c : 𝕜,	hc : 1 < ∥c∥,	R : ℝ,	hR : ∥c∥ < R,	F : subspace 𝕜 E,	hFc : is_closed ↑F,	hF : ∃ (x : E), x ∉ F,	Rpos : 0 < R,	this : ∥c∥ / R < 1,	x : E,	xF : x ∉ F,	hx : ∀ (y : E), y ∈ F → ∥c∥ / R * ∥x∥ ≤ ∥x - y∥,	x0 : x ≠ 0,	d : 𝕜,	d0 : d ≠ 0,	dxlt : ∥d • x∥ < R,	ledx : R / ∥c∥ ≤ ∥d • x∥,	y : E,	hy : y ∈ F,	y' : E := d⁻¹ • y,	hy' : y' = d⁻¹ • y	⊢ 1 ≤ ∥d • x - y∥
𝕜 : Type u_1,	_inst_1 : normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	c : 𝕜,	hc : 1 < ∥c∥,	R : ℝ,	hR : ∥c∥ < R,	F : subspace 𝕜 E,	hFc : is_closed ↑F,	hF : ∃ (x : E), x ∉ F,	Rpos : 0 < R,	this : ∥c∥ / R < 1,	x : E,	xF : x ∉ F,	hx : ∀ (y : E), y ∈ F → ∥c∥ / R * ∥x∥ ≤ ∥x - y∥,	x0 : x ≠ 0,	d : 𝕜,	d0 : d ≠ 0,	dxlt : ∥d • x∥ < R,	ledx : R / ∥c∥ ≤ ∥d • x∥,	y : E,	hy : y ∈ F,	y' : E := d⁻¹ • y,	hy' : y' = d⁻¹ • y,	y'F : y' ∈ F	⊢ y = d • y'
𝕜 : Type u_1,	_inst_1 : normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	c : 𝕜,	hc : 1 < ∥c∥,	R : ℝ,	hR : ∥c∥ < R,	F : subspace 𝕜 E,	hFc : is_closed ↑F,	hF : ∃ (x : E), x ∉ F,	Rpos : 0 < R,	this : ∥c∥ / R < 1,	x : E,	xF : x ∉ F,	hx : ∀ (y : E), y ∈ F → ∥c∥ / R * ∥x∥ ≤ ∥x - y∥,	x0 : x ≠ 0,	d : 𝕜,	d0 : d ≠ 0,	dxlt : ∥d • x∥ < R,	ledx : R / ∥c∥ ≤ ∥d • x∥,	y : E,	hy : y ∈ F,	y' : E := d⁻¹ • y,	hy' : y' = d⁻¹ • y,	y'F : y' ∈ F	⊢ 1 ≤ ∥d • x - y∥
𝕜 : Type u_1,	_inst_1 : normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	c : 𝕜,	hc : 1 < ∥c∥,	R : ℝ,	hR : ∥c∥ < R,	F : subspace 𝕜 E,	hFc : is_closed ↑F,	hF : ∃ (x : E), x ∉ F,	Rpos : 0 < R,	this : ∥c∥ / R < 1,	x : E,	xF : x ∉ F,	hx : ∀ (y : E), y ∈ F → ∥c∥ / R * ∥x∥ ≤ ∥x - y∥,	x0 : x ≠ 0,	d : 𝕜,	d0 : d ≠ 0,	dxlt : ∥d • x∥ < R,	ledx : R / ∥c∥ ≤ ∥d • x∥,	y : E,	hy : y ∈ F,	y' : E := d⁻¹ • y,	hy' : y' = d⁻¹ • y,	y'F : y' ∈ F,	yy' : y = d • y'	⊢ 1 = ∥c∥ / R * (R / ∥c∥)
𝕜 : Type u_1,	_inst_1 : normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	c : 𝕜,	hc : 1 < ∥c∥,	R : ℝ,	hR : ∥c∥ < R,	F : subspace 𝕜 E,	hFc : is_closed ↑F,	hF : ∃ (x : E), x ∉ F,	Rpos : 0 < R,	this : ∥c∥ / R < 1,	x : E,	xF : x ∉ F,	hx : ∀ (y : E), y ∈ F → ∥c∥ / R * ∥x∥ ≤ ∥x - y∥,	x0 : x ≠ 0,	d : 𝕜,	d0 : d ≠ 0,	dxlt : ∥d • x∥ < R,	ledx : R / ∥c∥ ≤ ∥d • x∥,	y : E,	hy : y ∈ F,	y' : E := d⁻¹ • y,	hy' : y' = d⁻¹ • y,	y'F : y' ∈ F,	yy' : y = d • y'	⊢ 1 ≤ ∥d • x - y∥
𝕜 : Type u_1,	_inst_1 : normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	c : 𝕜,	hc : 1 < ∥c∥,	R : ℝ,	hR : ∥c∥ < R,	F : subspace 𝕜 E,	hFc : is_closed ↑F,	hF : ∃ (x : E), x ∉ F,	Rpos : 0 < R,	this : ∥c∥ / R < 1,	x : E,	xF : x ∉ F,	hx : ∀ (y : E), y ∈ F → ∥c∥ / R * ∥x∥ ≤ ∥x - y∥,	x0 : x ≠ 0,	d : 𝕜,	d0 : d ≠ 0,	dxlt : ∥d • x∥ < R,	ledx : R / ∥c∥ ≤ ∥d • x∥,	y : E,	hy : y ∈ F,	y' : E := d⁻¹ • y,	hy' : y' = d⁻¹ • y,	y'F : y' ∈ F,	yy' : y = d • y'	⊢ ∥c∥ / R * ∥d • x∥ = ∥d∥ * (∥c∥ / R * ∥x∥)
𝕜 : Type u_1,	_inst_1 : normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	c : 𝕜,	hc : 1 < ∥c∥,	R : ℝ,	hR : ∥c∥ < R,	F : subspace 𝕜 E,	hFc : is_closed ↑F,	hF : ∃ (x : E), x ∉ F,	Rpos : 0 < R,	this : ∥c∥ / R < 1,	x : E,	xF : x ∉ F,	hx : ∀ (y : E), y ∈ F → ∥c∥ / R * ∥x∥ ≤ ∥x - y∥,	x0 : x ≠ 0,	d : 𝕜,	d0 : d ≠ 0,	dxlt : ∥d • x∥ < R,	ledx : R / ∥c∥ ≤ ∥d • x∥,	y : E,	hy : y ∈ F,	y' : E := d⁻¹ • y,	hy' : y' = d⁻¹ • y,	y'F : y' ∈ F,	yy' : y = d • y'	⊢ ∥c∥ / R * (∥d∥ * ∥x∥) = ∥d∥ * (∥c∥ / R * ∥x∥)
𝕜 : Type u_1,	_inst_1 : normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	c : 𝕜,	hc : 1 < ∥c∥,	R : ℝ,	hR : ∥c∥ < R,	F : subspace 𝕜 E,	hFc : is_closed ↑F,	hF : ∃ (x : E), x ∉ F,	Rpos : 0 < R,	this : ∥c∥ / R < 1,	x : E,	xF : x ∉ F,	hx : ∀ (y : E), y ∈ F → ∥c∥ / R * ∥x∥ ≤ ∥x - y∥,	x0 : x ≠ 0,	d : 𝕜,	d0 : d ≠ 0,	dxlt : ∥d • x∥ < R,	ledx : R / ∥c∥ ≤ ∥d • x∥,	y : E,	hy : y ∈ F,	y' : E := d⁻¹ • y,	hy' : y' = d⁻¹ • y,	y'F : y' ∈ F,	yy' : y = d • y'	⊢ y' ∈ F
𝕜 : Type u_1,	_inst_1 : normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	c : 𝕜,	hc : 1 < ∥c∥,	R : ℝ,	hR : ∥c∥ < R,	F : subspace 𝕜 E,	hFc : is_closed ↑F,	hF : ∃ (x : E), x ∉ F,	Rpos : 0 < R,	this : ∥c∥ / R < 1,	x : E,	xF : x ∉ F,	hx : ∀ (y : E), y ∈ F → ∥c∥ / R * ∥x∥ ≤ ∥x - y∥,	x0 : x ≠ 0,	d : 𝕜,	d0 : d ≠ 0,	dxlt : ∥d • x∥ < R,	ledx : R / ∥c∥ ≤ ∥d • x∥,	y : E,	hy : y ∈ F,	y' : E := d⁻¹ • y,	hy' : y' = d⁻¹ • y,	y'F : y' ∈ F,	yy' : y = d • y'	⊢ ∥d∥ * ∥x - y'∥ = ∥d • x - y∥
R : Type u_1,	_inst_1 : normed_ring R,	_inst_2 : complete_space R,	x : units R	⊢ continuous_at ring.inverse ↑x
R : Type u_1,	_inst_1 : normed_ring R,	_inst_2 : complete_space R,	x : units R	⊢ asymptotics.is_o (λ (t : R), ∥ring.inverse (↑x + t) - ↑x⁻¹∥) (λ (t : R), 1) (𝓝 0)
R : Type u_1,	_inst_1 : normed_ring R,	_inst_2 : complete_space R,	x : units R	⊢ asymptotics.is_o (λ (t : R), ∥ring.inverse (↑x + t) - ↑x⁻¹∥) (λ (t : R), 1) (𝓝 0)		R : Type u_1,	_inst_1 : normed_ring R,	_inst_2 : complete_space R,	x : units R,	h_is_o : asymptotics.is_o (λ (t : R), ∥ring.inverse (↑x + t) - ↑x⁻¹∥) (λ (t : R), 1) (𝓝 0)	⊢ continuous_at ring.inverse ↑x
R : Type u_1,	_inst_1 : normed_ring R,	_inst_2 : complete_space R,	x : units R	⊢ asymptotics.is_o (λ (t : R), ∥t∥) (λ (t : R), 1) (𝓝 0)
R : Type u_1,	_inst_1 : normed_ring R,	_inst_2 : complete_space R,	x : units R,	h_is_o : asymptotics.is_o (λ (t : R), ∥ring.inverse (↑x + t) - ↑x⁻¹∥) (λ (t : R), 1) (𝓝 0)	⊢ continuous_at ring.inverse ↑x
R : Type u_1,	_inst_1 : normed_ring R,	_inst_2 : complete_space R,	x : units R,	h_is_o : asymptotics.is_o (λ (t : R), ∥ring.inverse (↑x + t) - ↑x⁻¹∥) (λ (t : R), 1) (𝓝 0)	⊢ filter.tendsto (λ (y : R), y - ↑x) (𝓝 ↑x) (𝓝 0)
R : Type u_1,	_inst_1 : normed_ring R,	_inst_2 : complete_space R,	x : units R,	h_is_o : asymptotics.is_o (λ (t : R), ∥ring.inverse (↑x + t) - ↑x⁻¹∥) (λ (t : R), 1) (𝓝 0)	⊢ filter.tendsto (λ (y : R), y - ↑x) (𝓝 ↑x) (𝓝 0)		R : Type u_1,	_inst_1 : normed_ring R,	_inst_2 : complete_space R,	x : units R,	h_is_o : asymptotics.is_o (λ (t : R), ∥ring.inverse (↑x + t) - ↑x⁻¹∥) (λ (t : R), 1) (𝓝 0),	h_lim : filter.tendsto (λ (y : R), y - ↑x) (𝓝 ↑x) (𝓝 0)	⊢ continuous_at ring.inverse ↑x
R : Type u_1,	_inst_1 : normed_ring R,	_inst_2 : complete_space R,	x : units R,	h_is_o : asymptotics.is_o (λ (t : R), ∥ring.inverse (↑x + t) - ↑x⁻¹∥) (λ (t : R), 1) (𝓝 0)	⊢ filter.tendsto (λ (e : R), ∥e - ↑x∥) (𝓝 ↑x) (𝓝 0)
R : Type u_1,	_inst_1 : normed_ring R,	_inst_2 : complete_space R,	x : units R,	h_is_o : asymptotics.is_o (λ (t : R), ∥ring.inverse (↑x + t) - ↑x⁻¹∥) (λ (t : R), 1) (𝓝 0),	h_lim : filter.tendsto (λ (y : R), y - ↑x) (𝓝 ↑x) (𝓝 0)	⊢ continuous_at ring.inverse ↑x
R : Type u_1,	_inst_1 : normed_ring R,	_inst_2 : complete_space R,	x : units R,	h_is_o : asymptotics.is_o (λ (t : R), ∥ring.inverse (↑x + t) - ↑x⁻¹∥) (λ (t : R), 1) (𝓝 0),	h_lim : filter.tendsto (λ (y : R), y - ↑x) (𝓝 ↑x) (𝓝 0)	⊢ filter.tendsto ring.inverse (𝓝 ↑x) (𝓝 (ring.inverse ↑x))
R : Type u_1,	_inst_1 : normed_ring R,	_inst_2 : complete_space R,	x : units R,	h_is_o : asymptotics.is_o (λ (t : R), ∥ring.inverse (↑x + t) - ↑x⁻¹∥) (λ (t : R), 1) (𝓝 0),	h_lim : filter.tendsto (λ (y : R), y - ↑x) (𝓝 ↑x) (𝓝 0)	⊢ filter.tendsto (λ (e : R), ∥ring.inverse e - ↑x⁻¹∥) (𝓝 ↑x) (𝓝 0)
R : Type u_1,	_inst_1 : normed_ring R,	_inst_2 : complete_space R,	x : units R,	h_is_o : asymptotics.is_o (λ (t : R), ∥ring.inverse (↑x + t) - ↑x⁻¹∥) (λ (t : R), 1) (𝓝 0),	h_lim : filter.tendsto (λ (y : R), y - ↑x) (𝓝 ↑x) (𝓝 0)	⊢ (λ (e : R), ∥ring.inverse e - ↑x⁻¹∥) = (λ (x_1 : R), ∥ring.inverse (↑x + x_1) - ↑x⁻¹∥ / 1) ∘ λ (y : R), y - ↑x
R : Type u_1,	_inst_1 : normed_ring R,	_inst_2 : complete_space R,	x : units R,	h_is_o : asymptotics.is_o (λ (t : R), ∥ring.inverse (↑x + t) - ↑x⁻¹∥) (λ (t : R), 1) (𝓝 0),	h_lim : filter.tendsto (λ (y : R), y - ↑x) (𝓝 ↑x) (𝓝 0),	x_1 : R	⊢ ∥ring.inverse x_1 - ↑x⁻¹∥ = ((λ (x_1 : R), ∥ring.inverse (↑x + x_1) - ↑x⁻¹∥ / 1) ∘ λ (y : R), y - ↑x) x_1
M : Type u_1,	_inst_1 : ordered_add_comm_monoid M,	f : ℕ → M,	hf : ∀ ⦃m n : ℕ⦄, 1 < m → m ≤ n → f n ≤ f m,	n : ℕ	⊢ ∑ (k : ℕ) in finset.range (n + 1), 2 ^ k • f (2 ^ k) ≤ f 1 + 2 • ∑ (k : ℕ) in finset.Ico 2 (2 ^ n + 1), f k
M : Type u_1,	_inst_1 : ordered_add_comm_monoid M,	f : ℕ → M,	hf : ∀ ⦃m n : ℕ⦄, 1 < m → m ≤ n → f n ≤ f m,	n : ℕ	⊢ ∑ (k : ℕ) in finset.range (n + 1), 2 ^ k • f (2 ^ k) = f 1 + 2 • ∑ (k : ℕ) in finset.range n, 2 ^ k • f (2 ^ (k + 1))
x : ℝ,	hx : 0 ≤ x	⊢ ↑x.arg = 0
x y : ℝ,	hx : 0 < x,	hy : 0 < y	⊢ real.log x < real.log y ↔ x < y
x : ℝ,	hx : 0 < x	⊢ real.log 1 < real.log x ↔ 1 < x
x : ℝ,	hx : 0 < x	⊢ 0 < real.log x ↔ 1 < x
a b : ℝ	⊢ ∫ (x : ℝ) in a..b, real.exp x = real.exp b - real.exp a
a b : ℝ	⊢ deriv (λ {b : ℝ}, real.exp b) = λ (y : ℝ), real.exp y
a b : ℝ	⊢ ∀ (x : ℝ), x ∈ set.interval a b → differentiable_at ℝ (λ {b : ℝ}, real.exp b) x
a b : ℝ	⊢ continuous_on (λ (y : ℝ), real.exp y) (set.interval a b)
a b : ℝ	⊢ ∫ (x : ℝ) in a..b, real.exp x = real.exp b - real.exp a
n : ℕ,	H : ∀ (x : ℝ), x ∈ set.Icc 0 π → real.sin x ^ (n + 1) ≤ real.sin x ^ n := λ (x : ℝ) (h : x ∈ set.Icc 0 π), pow_le_pow_of_le_one (real.sin_nonneg_of_mem_Icc h) x.sin_le_one (n.le_add_right 1)	⊢ ∫ (x : ℝ) in 0..π, real.sin x ^ (n + 1) ≤ ∫ (x : ℝ) in 0..π, real.sin x ^ n
n : ℕ,	H : ∀ (x : ℝ), x ∈ set.Icc 0 π → real.sin x ^ (n + 1) ≤ real.sin x ^ n := λ (x : ℝ) (h : x ∈ set.Icc 0 π), pow_le_pow_of_le_one (real.sin_nonneg_of_mem_Icc h) x.sin_le_one (n.le_add_right 1)	⊢ interval_integrable (λ (x : ℝ), real.sin x ^ (n + 1)) measure_theory.measure_space.volume 0 π
n : ℕ,	H : ∀ (x : ℝ), x ∈ set.Icc 0 π → real.sin x ^ (n + 1) ≤ real.sin x ^ n := λ (x : ℝ) (h : x ∈ set.Icc 0 π), pow_le_pow_of_le_one (real.sin_nonneg_of_mem_Icc h) x.sin_le_one (n.le_add_right 1)	⊢ interval_integrable (λ (x : ℝ), real.sin x ^ n) measure_theory.measure_space.volume 0 π
n : ℕ,	H : ∀ (x : ℝ), x ∈ set.Icc 0 π → real.sin x ^ (n + 1) ≤ real.sin x ^ n := λ (x : ℝ) (h : x ∈ set.Icc 0 π), pow_le_pow_of_le_one (real.sin_nonneg_of_mem_Icc h) x.sin_le_one (n.le_add_right 1)	⊢ ∫ (x : ℝ) in 0..π, real.sin x ^ (n + 1) ≤ ∫ (x : ℝ) in 0..π, real.sin x ^ n
a b : ℝ	⊢ ∫ (x : ℝ) in a..b, real.sin x ^ 2 * real.cos x ^ 2 = (b - a) / 8 - (real.sin (4 * b) - real.sin (4 * a)) / 32
a b : ℝ	⊢ (b - a) / 8 - (real.sin (4 * b) - real.sin (4 * a)) / 32 = ∫ (x : ℝ) in a..b, ((1 - real.cos (2 * x)) / 2) ^ 1 * ((1 + real.cos (2 * x)) / 2) ^ 1
a b c : ℝ	⊢ (1 - c) / 2 * ((1 + c) / 2) = (1 - c ^ 2) / 4
a b : ℝ,	h1 : ∀ (c : ℝ), (1 - c) / 2 * ((1 + c) / 2) = (1 - c ^ 2) / 4	⊢ (b - a) / 8 - (real.sin (4 * b) - real.sin (4 * a)) / 32 = ∫ (x : ℝ) in a..b, ((1 - real.cos (2 * x)) / 2) ^ 1 * ((1 + real.cos (2 * x)) / 2) ^ 1
a b : ℝ,	h1 : ∀ (c : ℝ), (1 - c) / 2 * ((1 + c) / 2) = (1 - c ^ 2) / 4	⊢ continuous (λ (x : ℝ), real.cos (2 * x) ^ 2)
a b : ℝ,	h1 : ∀ (c : ℝ), (1 - c) / 2 * ((1 + c) / 2) = (1 - c ^ 2) / 4,	h2 : continuous (λ (x : ℝ), real.cos (2 * x) ^ 2)	⊢ (b - a) / 8 - (real.sin (4 * b) - real.sin (4 * a)) / 32 = ∫ (x : ℝ) in a..b, ((1 - real.cos (2 * x)) / 2) ^ 1 * ((1 + real.cos (2 * x)) / 2) ^ 1
a b : ℝ,	h1 : ∀ (c : ℝ), (1 - c) / 2 * ((1 + c) / 2) = (1 - c ^ 2) / 4,	h2 : continuous (λ (x : ℝ), real.cos (2 * x) ^ 2)	⊢ ∀ (x : ℝ), real.cos x * real.sin x = real.sin (2 * x) / 2
a b : ℝ,	h1 : ∀ (c : ℝ), (1 - c) / 2 * ((1 + c) / 2) = (1 - c ^ 2) / 4,	h2 : continuous (λ (x : ℝ), real.cos (2 * x) ^ 2),	x : ℝ	⊢ real.cos x * real.sin x = real.sin (2 * x) / 2
a b : ℝ,	h1 : ∀ (c : ℝ), (1 - c) / 2 * ((1 + c) / 2) = (1 - c ^ 2) / 4,	h2 : continuous (λ (x : ℝ), real.cos (2 * x) ^ 2),	x : ℝ	⊢ real.cos x * real.sin x = 2 * real.sin x * real.cos x / 2
a b : ℝ,	h1 : ∀ (c : ℝ), (1 - c) / 2 * ((1 + c) / 2) = (1 - c ^ 2) / 4,	h2 : continuous (λ (x : ℝ), real.cos (2 * x) ^ 2)	⊢ ∀ (x : ℝ), real.cos x * real.sin x = real.sin (2 * x) / 2		a b : ℝ,	h1 : ∀ (c : ℝ), (1 - c) / 2 * ((1 + c) / 2) = (1 - c ^ 2) / 4,	h2 : continuous (λ (x : ℝ), real.cos (2 * x) ^ 2),	h3 : ∀ (x : ℝ), real.cos x * real.sin x = real.sin (2 * x) / 2	⊢ (b - a) / 8 - (real.sin (4 * b) - real.sin (4 * a)) / 32 = ∫ (x : ℝ) in a..b, ((1 - real.cos (2 * x)) / 2) ^ 1 * ((1 + real.cos (2 * x)) / 2) ^ 1
a b : ℝ,	h1 : ∀ (c : ℝ), (1 - c) / 2 * ((1 + c) / 2) = (1 - c ^ 2) / 4,	h2 : continuous (λ (x : ℝ), real.cos (2 * x) ^ 2),	h3 : ∀ (x : ℝ), real.cos x * real.sin x = real.sin (2 * x) / 2	⊢ (b - a) / 8 - (real.sin (4 * b) - real.sin (4 * a)) / 32 = ∫ (x : ℝ) in a..b, ((1 - real.cos (2 * x)) / 2) ^ 1 * ((1 + real.cos (2 * x)) / 2) ^ 1
a b : ℝ,	h1 : ∀ (c : ℝ), (1 - c) / 2 * ((1 + c) / 2) = (1 - c ^ 2) / 4,	h2 : continuous (λ (x : ℝ), real.cos (2 * x) ^ 2),	h3 : ∀ (x : ℝ), real.cos x * real.sin x = real.sin (2 * x) / 2,	d : ℝ	⊢ 2 * (2 * d) = 4 * d
a b : ℝ,	h1 : ∀ (c : ℝ), (1 - c) / 2 * ((1 + c) / 2) = (1 - c ^ 2) / 4,	h2 : continuous (λ (x : ℝ), real.cos (2 * x) ^ 2),	h3 : ∀ (x : ℝ), real.cos x * real.sin x = real.sin (2 * x) / 2,	h4 : ∀ (d : ℝ), 2 * (2 * d) = 4 * d	⊢ (b - a) / 8 - (real.sin (4 * b) - real.sin (4 * a)) / 32 = ∫ (x : ℝ) in a..b, ((1 - real.cos (2 * x)) / 2) ^ 1 * ((1 + real.cos (2 * x)) / 2) ^ 1
a b : ℝ,	h1 : ∀ (c : ℝ), (1 - c) / 2 * ((1 + c) / 2) = (1 - c ^ 2) / 4,	h2 : continuous (λ (x : ℝ), real.cos (2 * x) ^ 2),	h3 : ∀ (x : ℝ), real.cos x * real.sin x = real.sin (2 * x) / 2,	h4 : ∀ (d : ℝ), 2 * (2 * d) = 4 * d	⊢ (b - a) / 8 - (real.sin (4 * b) - real.sin (4 * a)) / 32 = (b - a - 2⁻¹ * ((real.sin (4 * b) / 2 - real.sin (4 * a) / 2 + 2 * b - 2 * a) / 2)) / 4
x : ℝ≥0,	n : ℕ	⊢ ↑(x ^ ↑n) = ↑(x ^ n)
x : ℝ≥0∞	⊢ x ^ -1 = x⁻¹
x y : ℝ≥0∞,	z : ℝ,	hz : 0 ≤ z	⊢ (x / y) ^ z = x ^ z / y ^ z
x : ℝ≥0∞,	z : ℝ	⊢ x.to_nnreal ^ z = (x ^ z).to_nnreal
z : ℝ,	H : z < 0	⊢ ennreal.to_nnreal option.none ^ z = (option.none ^ z).to_nnreal
z : ℝ,	H : z < 0	⊢ ennreal.to_nnreal option.none ^ z = (option.none ^ z).to_nnreal		case option.some	z : ℝ,	H : z < 0,	x : ℝ≥0	⊢ ennreal.to_nnreal (option.some x) ^ z = (option.some x ^ z).to_nnreal
x : ℝ≥0∞,	z : ℝ,	H : z < 0	⊢ x.to_nnreal ^ z = (x ^ z).to_nnreal
z : ℝ,	H : z < 0,	x : ℝ≥0	⊢ ennreal.to_nnreal (option.some x) ^ z = (option.some x ^ z).to_nnreal
z : ℝ,	H : z < 0,	x : ℝ≥0,	hx : x = 0	⊢ ennreal.to_nnreal (option.some x) ^ z = (option.some x ^ z).to_nnreal		z : ℝ,	H : z < 0,	x : ℝ≥0,	hx : ¬x = 0	⊢ ennreal.to_nnreal (option.some x) ^ z = (option.some x ^ z).to_nnreal
z : ℝ,	H : z < 0,	x : ℝ≥0,	hx : x = 0	⊢ ennreal.to_nnreal (option.some x) ^ z = (option.some x ^ z).to_nnreal
x : ℝ≥0∞,	z : ℝ,	H : z < 0	⊢ x.to_nnreal ^ z = (x ^ z).to_nnreal		x : ℝ≥0∞,	z : ℝ,	H : z = 0	⊢ x.to_nnreal ^ z = (x ^ z).to_nnreal		x : ℝ≥0∞,	z : ℝ,	H : 0 < z	⊢ x.to_nnreal ^ z = (x ^ z).to_nnreal
z : ℝ,	H : z < 0,	x : ℝ≥0,	hx : ¬x = 0	⊢ ennreal.to_nnreal (option.some x) ^ z = (option.some x ^ z).to_nnreal
x : ℝ≥0∞,	z : ℝ,	H : z = 0	⊢ x.to_nnreal ^ z = (x ^ z).to_nnreal		x : ℝ≥0∞,	z : ℝ,	H : 0 < z	⊢ x.to_nnreal ^ z = (x ^ z).to_nnreal
x : ℝ≥0∞,	z : ℝ,	H : z = 0	⊢ x.to_nnreal ^ z = (x ^ z).to_nnreal
z : ℝ,	H : 0 < z	⊢ ennreal.to_nnreal option.none ^ z = (option.none ^ z).to_nnreal
z : ℝ,	H : 0 < z	⊢ ennreal.to_nnreal option.none ^ z = (option.none ^ z).to_nnreal		case option.some	z : ℝ,	H : 0 < z,	x : ℝ≥0	⊢ ennreal.to_nnreal (option.some x) ^ z = (option.some x ^ z).to_nnreal
x : ℝ≥0∞,	z : ℝ,	H : 0 < z	⊢ x.to_nnreal ^ z = (x ^ z).to_nnreal
z : ℝ,	H : 0 < z,	x : ℝ≥0	⊢ ennreal.to_nnreal (option.some x) ^ z = (option.some x ^ z).to_nnreal
x : ℝ,	hx : 0 ≤ x,	y : ℝ	⊢ x ^ y = ite (x = 0) (ite (y = 0) 1 0) (real.exp (real.log x * y))
x : ℝ,	hx : 0 ≤ x,	y : ℝ	⊢ x ^ y = ite (x = 0) (ite (y = 0) 1 0) (real.exp (real.log x * y))
x : ℝ,	hx : 0 ≤ x,	y : ℝ	⊢ x ^ y = ite (x = 0) (ite (y = 0) 1 0) (real.exp (real.log x * y))
x : ℝ,	hx : 0 ≤ x,	y : ℝ	⊢ (ite (↑x = 0) (ite (↑y = 0) 1 0) (complex.exp (complex.log ↑x * ↑y))).re = ite (x = 0) (ite (y = 0) 1 0) (real.exp (real.log x * y))
x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ↑x = 0,	h_1 : ↑y = 0,	h_2 : x = 0,	h_3 : y = 0	⊢ 1.re = 1
x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ↑x = 0,	h_1 : ↑y = 0,	h_2 : x = 0,	h_3 : ¬y = 0	⊢ 1.re = 0
x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ↑x = 0,	h_1 : ↑y = 0,	h_2 : ¬x = 0	⊢ 1.re = real.exp (real.log x * y)
x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ↑x = 0,	h_1 : ¬↑y = 0,	h_2 : x = 0,	h_3 : y = 0	⊢ 0.re = 1
x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ↑x = 0,	h_1 : ¬↑y = 0,	h_2 : x = 0,	h_3 : ¬y = 0	⊢ 0.re = 0
x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ↑x = 0,	h_1 : ¬↑y = 0,	h_2 : ¬x = 0	⊢ 0.re = real.exp (real.log x * y)
x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ¬↑x = 0,	h_1 : x = 0,	h_2 : y = 0	⊢ (complex.exp (complex.log ↑x * ↑y)).re = 1
x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ¬↑x = 0,	h_1 : x = 0,	h_2 : ¬y = 0	⊢ (complex.exp (complex.log ↑x * ↑y)).re = 0
x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ¬↑x = 0,	h_1 : ¬x = 0	⊢ (complex.exp (complex.log ↑x * ↑y)).re = real.exp (real.log x * y)
x : ℝ,	hx : 0 ≤ x,	y z : ℝ	⊢ x ^ (y * z) = (x ^ y) ^ z
x : ℝ,	hx : 0 ≤ x,	y z : ℝ	⊢ x ^ (y * z) = (x ^ y) ^ z
x : ℝ,	hx : 0 ≤ x,	y z : ℝ	⊢ -π < (complex.log ↑x * ↑y).im
x : ℝ,	hx : 0 ≤ x,	y z : ℝ	⊢ (complex.log ↑x * ↑y).im ≤ π
x y z : ℝ,	hx : 1 ≤ x,	hyz : y ≤ z	⊢ x ^ y ≤ x ^ z
x y z : ℝ,	hx : 1 ≤ x,	hyz : y ≤ z	⊢ real.exp (real.log x * y) ≤ x ^ z
x y z : ℝ,	hx : 1 ≤ x,	hyz : y ≤ z	⊢ real.exp (real.log x * y) ≤ real.exp (real.log x * z)
x y z : ℝ,	hx : 1 ≤ x,	hyz : y ≤ z	⊢ x ^ y ≤ x ^ z
x y z : ℝ,	hx : 1 ≤ x,	hyz : y ≤ z	⊢ real.log x * y ≤ real.log x * z
x y z : ℝ,	hx : 1 ≤ x,	hyz : y ≤ z	⊢ real.exp (real.log x * y) ≤ real.exp (real.log x * z)
x : ℂ,	cpow_int_cast : ∀ (n : ℤ), x ^ ↑n = x ^ n,	n : ℕ	⊢ x ^ ↑↑n = x ^ ↑n
x : ℂ,	cpow_int_cast : ∀ (n : ℤ), x ^ ↑n = x ^ n,	n : ℕ	⊢ x ^ ↑↑n = x ^ ↑n
x : ℂ,	cpow_int_cast : ∀ (n : ℤ), x ^ ↑n = x ^ n,	n : ℕ	⊢ x ^ ↑-[1+ n] = x ^ -[1+ n]
x : ℂ,	cpow_int_cast : ∀ (n : ℤ), x ^ ↑n = x ^ n,	n : ℕ	⊢ x ^ ↑-[1+ n] = x ^ -[1+ n]
x : ℂ,	cpow_int_cast : ∀ (n : ℤ), x ^ ↑n = x ^ n,	n : ℕ	⊢ x ^ ↑-[1+ n] = (x ^ n.succ)⁻¹
n : with_top ℕ,	x : ℝ,	h : real.cos x ≠ 0	⊢ complex.cos ↑x ≠ 0
n : ℕ	⊢ real.cos (↑n * (2 * π) - π) = -1
⊢ real.sin (π / 32) = real.sin (π / 2 ^ 5)		⊢ real.sin (π / 2 ^ 5) = real.sqrt (2 - real.sqrt (2 + real.sqrt (2 + real.sqrt 2))) / 2
⊢ 32 = 2 ^ 5		⊢ real.sin (π / 2 ^ 5) = real.sqrt (2 - real.sqrt (2 + real.sqrt (2 + real.sqrt 2))) / 2
⊢ real.sin (π / 2 ^ 5) = real.sqrt (2 - real.sqrt (2 + real.sqrt (2 + real.sqrt 2))) / 2
⊢ real.sin (π / 32) = real.sqrt (2 - real.sqrt (2 + real.sqrt (2 + real.sqrt 2))) / 2
θ ψ : ℝ,	Hcos : real.cos θ = real.cos ψ,	Hsin : real.sin θ = real.sin ψ	⊢ ↑θ = ↑ψ
θ ψ : ℝ,	Hcos : real.cos θ = real.cos ψ,	Hsin : real.sin θ = real.sin ψ,	hc : ↑θ = ↑ψ	⊢ ↑θ = ↑ψ
θ ψ : ℝ,	Hcos : real.cos θ = real.cos ψ,	Hsin : real.sin θ = real.sin ψ,	hc : ↑θ = ↑ψ	⊢ ↑θ = ↑ψ		case or.inr	θ ψ : ℝ,	Hcos : real.cos θ = real.cos ψ,	Hsin : real.sin θ = real.sin ψ,	hc : ↑θ = -↑ψ	⊢ ↑θ = ↑ψ
θ ψ : ℝ,	Hcos : real.cos θ = real.cos ψ,	Hsin : real.sin θ = real.sin ψ,	hc : ↑θ = -↑ψ	⊢ ↑θ = ↑ψ
θ ψ : ℝ,	Hcos : real.cos θ = real.cos ψ,	Hsin : real.sin θ = real.sin ψ,	hc : ↑θ = -↑ψ,	hs : ↑θ = ↑ψ	⊢ ↑θ = ↑ψ
θ ψ : ℝ,	Hcos : real.cos θ = real.cos ψ,	Hsin : real.sin θ = real.sin ψ,	hc : ↑θ = -↑ψ,	hs : ↑θ = ↑ψ	⊢ ↑θ = ↑ψ		case or.inr, or.inr	θ ψ : ℝ,	Hcos : real.cos θ = real.cos ψ,	Hsin : real.sin θ = real.sin ψ,	hc : ↑θ = -↑ψ,	hs : ↑θ + ↑ψ = ↑π	⊢ ↑θ = ↑ψ
θ ψ : ℝ,	Hcos : real.cos θ = real.cos ψ,	Hsin : real.sin θ = real.sin ψ,	hc : ↑θ = -↑ψ,	hs : ↑θ + ↑ψ = ↑π	⊢ ↑θ = ↑ψ
θ ψ : ℝ,	Hcos : real.cos θ = real.cos ψ,	Hsin : real.sin θ = real.sin ψ,	hs : ↑θ + ↑ψ = ↑π,	hc : ↑π = 0,	n : ℤ,	hn : (λ (_x : ℤ), _x • (2 * π)) n = -π + 0	⊢ ↑θ = ↑ψ
θ ψ : ℝ,	Hcos : real.cos θ = real.cos ψ,	Hsin : real.sin θ = real.sin ψ,	hs : ↑θ + ↑ψ = ↑π,	hc : ↑π = 0	⊢ ↑θ = ↑ψ
θ ψ : ℝ,	Hcos : real.cos θ = real.cos ψ,	Hsin : real.sin θ = real.sin ψ,	hs : ↑θ + ↑ψ = ↑π,	hc : ↑π = 0,	n : ℤ,	hn : n • (2 * π) = -π + 0	⊢ ↑θ = ↑ψ
θ ψ : ℝ,	Hcos : real.cos θ = real.cos ψ,	Hsin : real.sin θ = real.sin ψ,	hs : ↑θ + ↑ψ = ↑π,	hc : ↑π = 0,	n : ℤ,	hn : n * 2 + 1 = 0	⊢ ↑θ = ↑ψ
θ ψ : ℝ,	Hcos : real.cos θ = real.cos ψ,	Hsin : real.sin θ = real.sin ψ,	hs : ↑θ + ↑ψ = ↑π,	hc : ↑π = 0,	n : ℤ,	hn : n * 2 + 1 = 0,	this : (n * 2 + 1) % 2 = 0 % 2	⊢ ↑θ = ↑ψ
θ ψ : ℝ,	Hcos : real.cos θ = real.cos ψ,	Hsin : real.sin θ = real.sin ψ,	hs : ↑θ + ↑ψ = ↑π,	hc : ↑π = 0,	n : ℤ,	hn : n * 2 + 1 = 0,	this : 1 % 2 = 0 % 2	⊢ ↑θ = ↑ψ
x : ℂ	⊢ complex.cos (x + ↑π / 2) = -complex.sin x
⊢ real.cos (π / 2) = 0
⊢ real.cos (π / 2) = 0
⊢ real.cos (classical.some real.exists_cos_eq_zero) = 0
x : ℝ	⊢ x < real.sin (π / 2) ↔ x < 1
x : ℝ	⊢ real.arccos x = π / 2 ↔ x = 0
α : Type u_1,	_inst_1 : pseudo_emetric_space α,	r C : ℝ≥0∞,	hr : r < 1,	hC : C ≠ ⊤,	f : ℕ → α,	hu : ∀ (n : ℕ), has_edist.edist (f n) (f (n + 1)) ≤ C * r ^ n	⊢ cauchy_seq f
α : Type u_1,	_inst_1 : pseudo_emetric_space α,	r C : ℝ≥0∞,	hr : r < 1,	hC : C ≠ ⊤,	f : ℕ → α,	hu : ∀ (n : ℕ), has_edist.edist (f n) (f (n + 1)) ≤ C * r ^ n	⊢ ∑' (n : ℕ), C * r ^ n ≠ ⊤
α : Type u_1,	_inst_1 : pseudo_emetric_space α,	r C : ℝ≥0∞,	hr : r < 1,	hC : C ≠ ⊤,	f : ℕ → α,	hu : ∀ (n : ℕ), has_edist.edist (f n) (f (n + 1)) ≤ C * r ^ n	⊢ C * (1 - r)⁻¹ ≠ ⊤
α : Type u_1,	_inst_1 : pseudo_emetric_space α,	r C : ℝ≥0∞,	hr : r < 1,	hC : C ≠ ⊤,	f : ℕ → α,	hu : ∀ (n : ℕ), has_edist.edist (f n) (f (n + 1)) ≤ C * r ^ n	⊢ 1 - r ≠ 0
α : Type u_1,	_inst_1 : pseudo_metric_space α,	C : ℝ,	f : ℕ → α,	hu₂ : ∀ (n : ℕ), has_dist.dist (f n) (f (n + 1)) ≤ C / 2 / 2 ^ n,	a : α,	ha : filter.tendsto f filter.at_top (𝓝 a),	n : ℕ	⊢ has_dist.dist (f n) a ≤ C / 2 ^ n
α : Type u_1,	_inst_1 : pseudo_metric_space α,	C : ℝ,	f : ℕ → α,	hu₂ : ∀ (n : ℕ), has_dist.dist (f n) (f (n + 1)) ≤ C / 2 / 2 ^ n,	a : α,	ha : filter.tendsto f filter.at_top (𝓝 a),	n : ℕ	⊢ C / 2 ^ n = ∑' (m : ℕ), C / 2 / 2 ^ (n + m)
α : Type u_1,	_inst_1 : pseudo_metric_space α,	C : ℝ,	f : ℕ → α,	hu₂ : ∀ (n : ℕ), has_dist.dist (f n) (f (n + 1)) ≤ C / 2 / 2 ^ n,	a : α,	ha : filter.tendsto f filter.at_top (𝓝 a),	n : ℕ	⊢ C / 2 ^ n = ∑' (m : ℕ), C / 2 / 2 ^ m / 2 ^ n
α : Type u_1,	_inst_1 : pseudo_metric_space α,	C : ℝ,	f : ℕ → α,	hu₂ : ∀ (n : ℕ), has_dist.dist (f n) (f (n + 1)) ≤ C / 2 / 2 ^ n,	a : α,	ha : filter.tendsto f filter.at_top (𝓝 a),	n : ℕ	⊢ ∑' (m : ℕ), C / 2 / 2 ^ m / 2 ^ n = C / 2 ^ n
n : ℕ	⊢ 0 ≤ ↑n!
n : ℕ	⊢ 0 ≤ ↑n
⊢ ∀ᶠ (b : ℕ) in filter.at_top, ↑b! / ↑b ^ b ≤ 1 / ↑b
n : ℕ,	hn : 0 < n	⊢ ↑n! / ↑n ^ n ≤ 1 / ↑n
k : ℕ,	hn : 0 < k.succ	⊢ ↑(k.succ)! / ↑(k.succ) ^ k.succ ≤ 1 / ↑(k.succ)
k : ℕ,	hn : 0 < k.succ	⊢ (∏ (k_1 : ℕ) in finset.range k, ↑(k_1 + 1 + 1) * (↑k + 1)⁻¹) * (↑(0 + 1) * (↑k + 1)⁻¹) ≤ (↑k + 1)⁻¹
k : ℕ,	hn : 0 < k.succ	⊢ 0 ≤ ↑k + 1
k : ℕ,	hn : 0 < k.succ	⊢ (∏ (k_1 : ℕ) in finset.range k, (↑k_1 + 1 + 1) * (↑k + 1)⁻¹) * (↑k + 1)⁻¹ ≤ (↑k + 1)⁻¹
k : ℕ,	hn : 0 < k.succ	⊢ (∏ (k_1 : ℕ) in finset.range k, (↑k_1 + 1 + 1) * (↑k + 1)⁻¹) * (↑k + 1)⁻¹ ≤ (↑k + 1)⁻¹
k : ℕ,	hn : 0 < k.succ	⊢ (∏ (k_1 : ℕ) in finset.range k, (↑k_1 + 1 + 1) * (↑k + 1)⁻¹) * (↑k + 1)⁻¹ ≤ (↑k + 1)⁻¹
k : ℕ,	hn : 0 < k.succ,	x : ℕ,	hx : x ∈ finset.range k	⊢ 0 ≤ (↑x + 1 + 1) * (↑k + 1)⁻¹
k : ℕ,	hn : 0 < k.succ,	x : ℕ,	hx : x ∈ finset.range k	⊢ (↑x + 1 + 1) * (↑k + 1)⁻¹ ≤ 1
k : ℕ,	hn : 0 < k.succ	⊢ ∀ (i : ℕ), i ∈ finset.range k → 0 ≤ (↑i + 1 + 1) * (↑k + 1)⁻¹
k : ℕ,	hn : 0 < k.succ	⊢ ∀ (i : ℕ), i ∈ finset.range k → (↑i + 1 + 1) * (↑k + 1)⁻¹ ≤ 1
k : ℕ,	hn : 0 < k.succ,	x : ℕ,	hx : x < k	⊢ 0 ≤ (↑x + 1 + 1) * (↑k + 1)⁻¹
k : ℕ,	hn : 0 < k.succ,	x : ℕ,	hx : x < k	⊢ 0 ≤ (↑x + 1 + 1) * (↑k + 1)⁻¹
k : ℕ,	hn : 0 < k.succ,	x : ℕ,	hx : x < k	⊢ 0 ≤ ↑x + 1 + 1
k : ℕ,	hn : 0 < k.succ,	x : ℕ,	hx : x < k	⊢ 0 ≤ ↑k + 1
k : ℕ,	hn : 0 < k.succ,	x : ℕ,	hx : x < k	⊢ 0 ≤ x + 1 + 1
k : ℕ,	hn : 0 < k.succ,	x : ℕ,	hx : x < k	⊢ 0 ≤ k + 1
k : ℕ,	hn : 0 < k.succ,	x : ℕ,	hx : x < k	⊢ 0 ≤ (↑x + 1 + 1) * (↑k + 1)⁻¹		k : ℕ,	hn : 0 < k.succ,	x : ℕ,	hx : x < k	⊢ (↑x + 1 + 1) * (↑k + 1)⁻¹ ≤ 1
k : ℕ,	hn : 0 < k.succ,	x : ℕ,	hx : x < k	⊢ 0 ≤ (↑x + 1 + 1) * (↑k + 1)⁻¹
k : ℕ,	hn : 0 < k.succ,	x : ℕ,	hx : x < k	⊢ 0 < ↑k + 1
k : ℕ,	hn : 0 < k.succ,	x : ℕ,	hx : x < k	⊢ ↑x + 1 + 1 ≤ ↑k + 1
k : ℕ,	hn : 0 < k.succ,	x : ℕ,	hx : x < k	⊢ x + 1 + 1 ≤ k + 1
k : ℕ,	hn : 0 < k.succ,	x : ℕ,	hx : x < k	⊢ (↑x + 1 + 1) * (↑k + 1)⁻¹ ≤ 1
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.abelian C	⊢ category_theory.limits.has_images C
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.abelian C	⊢ category_theory.limits.has_image_maps C
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.abelian C,	_inst_3 : category_theory.limits.has_pullbacks C,	X Y Z : C,	f : X ⟶ Z,	g : Y ⟶ Z,	_inst_4 : category_theory.epi g,	s : category_theory.limits.pullback_cone f g,	hs : category_theory.limits.is_limit s	⊢ category_theory.epi s.fst
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.abelian C,	_inst_3 : category_theory.limits.has_pullbacks C,	X Y Z : C,	f : X ⟶ Z,	g : Y ⟶ Z,	_inst_4 : category_theory.epi g,	s : category_theory.limits.pullback_cone f g,	hs : category_theory.limits.is_limit s	⊢ X = (category_theory.limits.cospan f g).obj category_theory.limits.walking_cospan.left		C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.abelian C,	_inst_3 : category_theory.limits.has_pullbacks C,	X Y Z : C,	f : X ⟶ Z,	g : Y ⟶ Z,	_inst_4 : category_theory.epi g,	s : category_theory.limits.pullback_cone f g,	hs : category_theory.limits.is_limit s	⊢ category_theory.epi ((category_theory.limits.limit.cone (category_theory.limits.cospan f g)).π.app category_theory.limits.walking_cospan.left)
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.abelian C,	_inst_3 : category_theory.limits.has_pullbacks C,	X Y Z : C,	f : X ⟶ Z,	g : Y ⟶ Z,	_inst_4 : category_theory.epi g,	s : category_theory.limits.pullback_cone f g,	hs : category_theory.limits.is_limit s	⊢ X = (category_theory.limits.cospan f g).obj category_theory.limits.walking_cospan.left
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.abelian C,	_inst_3 : category_theory.limits.has_pullbacks C,	X Y Z : C,	f : X ⟶ Z,	g : Y ⟶ Z,	_inst_4 : category_theory.epi g,	s : category_theory.limits.pullback_cone f g,	hs : category_theory.limits.is_limit s	⊢ category_theory.epi ((category_theory.limits.limit.cone (category_theory.limits.cospan f g)).π.app category_theory.limits.walking_cospan.left)
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.abelian C,	X Y Z : C,	f : X ⟶ Y,	g : Y ⟶ Z	⊢ category_theory.exact f g ↔ category_theory.limits.image_subobject f = category_theory.limits.kernel_subobject g
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.abelian C,	X Y Z : C,	f : X ⟶ Y,	g : Y ⟶ Z	⊢ category_theory.exact f g → category_theory.limits.image_subobject f = category_theory.limits.kernel_subobject g
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.abelian C,	X Y Z : C,	f : X ⟶ Y,	g : Y ⟶ Z,	h : category_theory.exact f g	⊢ category_theory.limits.image_subobject f = category_theory.limits.kernel_subobject g
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.abelian C,	X Y Z : C,	f : X ⟶ Y,	g : Y ⟶ Z,	h : category_theory.exact f g	⊢ ↑(category_theory.limits.image_subobject f) ≅ ↑(category_theory.limits.kernel_subobject g)
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.abelian C,	X Y Z : C,	f : X ⟶ Y,	g : Y ⟶ Z,	h : category_theory.exact f g,	this : category_theory.is_iso (image_to_kernel f g category_theory.exact.w)	⊢ ↑(category_theory.limits.image_subobject f) ≅ ↑(category_theory.limits.kernel_subobject g)		C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.abelian C,	X Y Z : C,	f : X ⟶ Y,	g : Y ⟶ Z,	h : category_theory.exact f g	⊢ category_theory.is_iso (image_to_kernel f g category_theory.exact.w)
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.abelian C,	X Y Z : C,	f : X ⟶ Y,	g : Y ⟶ Z,	h : category_theory.exact f g,	this : category_theory.is_iso (image_to_kernel f g category_theory.exact.w)	⊢ ↑(category_theory.limits.image_subobject f) ≅ ↑(category_theory.limits.kernel_subobject g)
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.abelian C,	X Y Z : C,	f : X ⟶ Y,	g : Y ⟶ Z,	h : category_theory.exact f g	⊢ ↑(category_theory.limits.image_subobject f) ≅ ↑(category_theory.limits.kernel_subobject g)		C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.abelian C,	X Y Z : C,	f : X ⟶ Y,	g : Y ⟶ Z,	h : category_theory.exact f g	⊢ ?m_1.hom ≫ (category_theory.limits.kernel_subobject g).arrow = (category_theory.limits.image_subobject f).arrow
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.abelian C,	X Y Z : C,	f : X ⟶ Y,	g : Y ⟶ Z,	h : category_theory.exact f g	⊢ category_theory.is_iso (image_to_kernel f g category_theory.exact.w)
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.abelian C,	X Y Z : C,	f : X ⟶ Y,	g : Y ⟶ Z	⊢ category_theory.exact f g → category_theory.limits.image_subobject f = category_theory.limits.kernel_subobject g		C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.abelian C,	X Y Z : C,	f : X ⟶ Y,	g : Y ⟶ Z	⊢ category_theory.limits.image_subobject f = category_theory.limits.kernel_subobject g → category_theory.exact f g
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.abelian C,	X Y Z : C,	f : X ⟶ Y,	g : Y ⟶ Z,	h : category_theory.exact f g	⊢ (category_theory.as_iso (image_to_kernel f g category_theory.exact.w)).hom ≫ (category_theory.limits.kernel_subobject g).arrow = (category_theory.limits.image_subobject f).arrow
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.abelian C,	X Y Z : C,	f : X ⟶ Y,	g : Y ⟶ Z	⊢ category_theory.limits.image_subobject f = category_theory.limits.kernel_subobject g → category_theory.exact f g
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.non_preadditive_abelian C,	X Y : C,	a b c d : X ⟶ Y	⊢ a - c - (b - d) = a - b - (c - d)
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.non_preadditive_abelian C,	X Y : C,	a b c d : X ⟶ Y	⊢ category_theory.limits.prod.lift (category_theory.limits.prod.lift a b ≫ category_theory.non_preadditive_abelian.σ) (category_theory.limits.prod.lift c d ≫ category_theory.non_preadditive_abelian.σ) ≫ category_theory.non_preadditive_abelian.σ = a - b - (c - d)
A : Type u₁,	B : Type u₂,	C : Type u₃,	_inst_1 : category_theory.category A,	_inst_2 : category_theory.category B,	_inst_3 : category_theory.category C,	U : B ⥤ C,	F : C ⥤ B,	R : A ⥤ B,	F' : C ⥤ A,	adj₁ : F ⊣ U,	adj₂ : F' ⊣ R ⋙ U,	_inst_4 : category_theory.limits.has_reflexive_coequalizers A,	_inst_5 : Π (X : B), category_theory.regular_epi (adj₁.counit.app X),	Y : A,	X : B	⊢ {f // F'.map (U.map (adj₁.counit.app X)) ≫ f = category_theory.lift_adjoint.other_map R F' adj₁ adj₂ X ≫ f} ≃ {g // U.map (F.map g ≫ adj₁.counit.app (R.obj Y)) = U.map (adj₁.counit.app X) ≫ g}
A : Type u₁,	B : Type u₂,	C : Type u₃,	_inst_1 : category_theory.category A,	_inst_2 : category_theory.category B,	_inst_3 : category_theory.category C,	U : B ⥤ C,	F : C ⥤ B,	R : A ⥤ B,	F' : C ⥤ A,	adj₁ : F ⊣ U,	adj₂ : F' ⊣ R ⋙ U,	_inst_4 : category_theory.limits.has_reflexive_coequalizers A,	_inst_5 : Π (X : B), category_theory.regular_epi (adj₁.counit.app X),	Y : A,	X : B	⊢ ∀ (a : F'.obj (U.obj X) ⟶ Y), F'.map (U.map (adj₁.counit.app X)) ≫ a = category_theory.lift_adjoint.other_map R F' adj₁ adj₂ X ≫ a ↔ U.map (F.map (⇑(adj₂.hom_equiv (U.obj X) Y) a) ≫ adj₁.counit.app (R.obj Y)) = U.map (adj₁.counit.app X) ≫ ⇑(adj₂.hom_equiv (U.obj X) Y) a
A : Type u₁,	B : Type u₂,	C : Type u₃,	_inst_1 : category_theory.category A,	_inst_2 : category_theory.category B,	_inst_3 : category_theory.category C,	U : B ⥤ C,	F : C ⥤ B,	R : A ⥤ B,	F' : C ⥤ A,	adj₁ : F ⊣ U,	adj₂ : F' ⊣ R ⋙ U,	_inst_4 : category_theory.limits.has_reflexive_coequalizers A,	_inst_5 : Π (X : B), category_theory.regular_epi (adj₁.counit.app X),	Y : A,	X : B,	f : F'.obj (U.obj X) ⟶ Y	⊢ F'.map (U.map (adj₁.counit.app X)) ≫ f = category_theory.lift_adjoint.other_map R F' adj₁ adj₂ X ≫ f ↔ U.map (F.map (⇑(adj₂.hom_equiv (U.obj X) Y) f) ≫ adj₁.counit.app (R.obj Y)) = U.map (adj₁.counit.app X) ≫ ⇑(adj₂.hom_equiv (U.obj X) Y) f
A : Type u₁,	B : Type u₂,	C : Type u₃,	_inst_1 : category_theory.category A,	_inst_2 : category_theory.category B,	_inst_3 : category_theory.category C,	U : B ⥤ C,	F : C ⥤ B,	R : A ⥤ B,	F' : C ⥤ A,	adj₁ : F ⊣ U,	adj₂ : F' ⊣ R ⋙ U,	_inst_4 : category_theory.limits.has_reflexive_coequalizers A,	_inst_5 : Π (X : B), category_theory.regular_epi (adj₁.counit.app X),	Y : A,	X : B,	f : F'.obj (U.obj X) ⟶ Y	⊢ U.map (F.map (adj₂.unit.app (U.obj X)) ≫ F.map (U.map (R.map f)) ≫ adj₁.counit.app (R.obj Y)) = U.map (adj₁.counit.app X) ≫ adj₂.unit.app (U.obj ((𝟭 B).obj X)) ≫ (R ⋙ U).map f ↔ U.map (F.map (adj₂.unit.app (U.obj X)) ≫ F.map ((R ⋙ U).map f) ≫ adj₁.counit.app (R.obj Y)) = U.map (adj₁.counit.app X) ≫ adj₂.unit.app (U.obj X) ≫ (R ⋙ U).map f
A : Type u₁,	B : Type u₂,	C : Type u₃,	_inst_1 : category_theory.category A,	_inst_2 : category_theory.category B,	_inst_3 : category_theory.category C,	U : B ⥤ C,	F : C ⥤ B,	R : A ⥤ B,	F' : C ⥤ A,	adj₁ : F ⊣ U,	adj₂ : F' ⊣ R ⋙ U,	_inst_4 : category_theory.limits.has_reflexive_coequalizers A,	_inst_5 : Π (X : B), category_theory.regular_epi (adj₁.counit.app X),	Y : A,	X : B	⊢ {g // U.map (F.map g ≫ adj₁.counit.app (R.obj Y)) = U.map (adj₁.counit.app X) ≫ g} ≃ {z // F.map (U.map (adj₁.counit.app X)) ≫ z = adj₁.counit.app (F.obj (U.obj X)) ≫ z}
A : Type u₁,	B : Type u₂,	C : Type u₃,	_inst_1 : category_theory.category A,	_inst_2 : category_theory.category B,	_inst_3 : category_theory.category C,	U : B ⥤ C,	F : C ⥤ B,	R : A ⥤ B,	F' : C ⥤ A,	adj₁ : F ⊣ U,	adj₂ : F' ⊣ R ⋙ U,	_inst_4 : category_theory.limits.has_reflexive_coequalizers A,	_inst_5 : Π (X : B), category_theory.regular_epi (adj₁.counit.app X),	Y : A,	X : B	⊢ ∀ (a : U.obj X ⟶ U.obj (R.obj Y)), U.map (F.map a ≫ adj₁.counit.app (R.obj Y)) = U.map (adj₁.counit.app X) ≫ a ↔ F.map (U.map (adj₁.counit.app X)) ≫ ⇑((adj₁.hom_equiv (U.obj X) (R.obj Y)).symm) a = adj₁.counit.app (F.obj (U.obj X)) ≫ ⇑((adj₁.hom_equiv (U.obj X) (R.obj Y)).symm) a
A : Type u₁,	B : Type u₂,	C : Type u₃,	_inst_1 : category_theory.category A,	_inst_2 : category_theory.category B,	_inst_3 : category_theory.category C,	U : B ⥤ C,	F : C ⥤ B,	R : A ⥤ B,	F' : C ⥤ A,	adj₁ : F ⊣ U,	adj₂ : F' ⊣ R ⋙ U,	_inst_4 : category_theory.limits.has_reflexive_coequalizers A,	_inst_5 : Π (X : B), category_theory.regular_epi (adj₁.counit.app X),	Y : A,	X : B,	g : U.obj X ⟶ U.obj (R.obj Y)	⊢ U.map (F.map g ≫ adj₁.counit.app (R.obj Y)) = U.map (adj₁.counit.app X) ≫ g ↔ F.map (U.map (adj₁.counit.app X)) ≫ ⇑((adj₁.hom_equiv (U.obj X) (R.obj Y)).symm) g = adj₁.counit.app (F.obj (U.obj X)) ≫ ⇑((adj₁.hom_equiv (U.obj X) (R.obj Y)).symm) g
A : Type u₁,	B : Type u₂,	C : Type u₃,	_inst_1 : category_theory.category A,	_inst_2 : category_theory.category B,	_inst_3 : category_theory.category C,	U : B ⥤ C,	F : C ⥤ B,	R : A ⥤ B,	F' : C ⥤ A,	adj₁ : F ⊣ U,	adj₂ : F' ⊣ R ⋙ U,	_inst_4 : category_theory.limits.has_reflexive_coequalizers A,	_inst_5 : Π (X : B), category_theory.regular_epi (adj₁.counit.app X),	Y : A,	X : B,	g : U.obj X ⟶ U.obj (R.obj Y)	⊢ adj₁.counit.app (F.obj (U.obj X)) ≫ F.map g ≫ adj₁.counit.app (R.obj Y) = F.map (U.map (adj₁.counit.app X)) ≫ F.map g ≫ adj₁.counit.app ((𝟭 B).obj (R.obj Y)) ↔ F.map (U.map (adj₁.counit.app X)) ≫ F.map g ≫ adj₁.counit.app (R.obj Y) = adj₁.counit.app (F.obj (U.obj X)) ≫ F.map g ≫ adj₁.counit.app (R.obj Y)
A : Type u₁,	B : Type u₂,	C : Type u₃,	_inst_1 : category_theory.category A,	_inst_2 : category_theory.category B,	_inst_3 : category_theory.category C,	U : B ⥤ C,	F : C ⥤ B,	R : A ⥤ B,	F' : C ⥤ A,	adj₁ : F ⊣ U,	adj₂ : F' ⊣ R ⋙ U,	_inst_4 : category_theory.limits.has_reflexive_coequalizers A,	_inst_5 : Π (X : B), category_theory.regular_epi (adj₁.counit.app X)	⊢ B ⥤ A
A : Type u₁,	B : Type u₂,	C : Type u₃,	_inst_1 : category_theory.category A,	_inst_2 : category_theory.category B,	_inst_3 : category_theory.category C,	U : B ⥤ C,	F : C ⥤ B,	R : A ⥤ B,	F' : C ⥤ A,	adj₁ : F ⊣ U,	adj₂ : F' ⊣ R ⋙ U,	_inst_4 : category_theory.limits.has_reflexive_coequalizers A,	_inst_5 : Π (X : B), category_theory.regular_epi (adj₁.counit.app X)	⊢ ∀ (X : B) (Y Y' : A) (g : Y ⟶ Y') (h : category_theory.lift_adjoint.construct_left_adjoint_obj R F' adj₁ adj₂ X ⟶ Y), ⇑(category_theory.lift_adjoint.construct_left_adjoint_equiv R F' adj₁ adj₂ Y' X) (h ≫ g) = ⇑(category_theory.lift_adjoint.construct_left_adjoint_equiv R F' adj₁ adj₂ Y X) h ≫ R.map g
A : Type u₁,	B : Type u₂,	C : Type u₃,	_inst_1 : category_theory.category A,	_inst_2 : category_theory.category B,	_inst_3 : category_theory.category C,	U : B ⥤ C,	F : C ⥤ B,	R : A ⥤ B,	F' : C ⥤ A,	adj₁ : F ⊣ U,	adj₂ : F' ⊣ R ⋙ U,	_inst_4 : category_theory.limits.has_reflexive_coequalizers A,	_inst_5 : Π (X : B), category_theory.regular_epi (adj₁.counit.app X),	X : B,	Y Y' : A,	g : Y ⟶ Y',	h : category_theory.lift_adjoint.construct_left_adjoint_obj R F' adj₁ adj₂ X ⟶ Y	⊢ ⇑(category_theory.lift_adjoint.construct_left_adjoint_equiv R F' adj₁ adj₂ Y' X) (h ≫ g) = ⇑(category_theory.lift_adjoint.construct_left_adjoint_equiv R F' adj₁ adj₂ Y X) h ≫ R.map g
C : Type u₁,	D : Type u₂,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.category D,	L₁ : C ⥤ D,	R₁ : D ⥤ C,	adj₁ : L₁ ⊣ R₁	⊢ 𝟙 R₁ = ⇑(category_theory.transfer_nat_trans_self adj₁ adj₁) (𝟙 L₁)
C : Type u₁,	D : Type u₂,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.category D,	L₁ : C ⥤ D,	R₁ : D ⥤ C,	adj₁ : L₁ ⊣ R₁	⊢ ⇑((category_theory.transfer_nat_trans_self adj₁ adj₁).symm) (𝟙 R₁) = 𝟙 L₁
C : Type u₁,	D : Type u₂,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.category D,	i : D ⥤ C,	_inst_4 : category_theory.reflective i,	A B : C,	hB : B ∈ i.ess_image,	f : i.obj ((category_theory.left_adjoint i).obj A) ⟶ B	⊢ ⇑((category_theory.unit_comp_partial_bijective A hB).symm) f = (category_theory.adjunction.of_right_adjoint i).unit.app A ≫ f
D : Type u,	_inst_2 : category_theory.small_category D	⊢ category_theory.large_category (ulift D)
C : Type u₁,	_inst_1 : category_theory.category C	⊢ ∀ {X Y : C} (f : X ⟶ Y), (𝟭 C).map f ≫ (category_theory.eq_to_iso rfl).hom = (category_theory.eq_to_iso rfl).hom ≫ (category_theory.as_small.up ⋙ category_theory.as_small.down).map f
C : Type u₁,	_inst_1 : category_theory.category C,	X : category_theory.as_small C	⊢ (category_theory.as_small.down ⋙ category_theory.as_small.up).obj X = (𝟭 (category_theory.as_small C)).obj X
C : Type u₁,	_inst_1 : category_theory.category C,	X : category_theory.as_small C	⊢ ((category_theory.as_small.down ⋙ category_theory.as_small.up).obj X).down = ((𝟭 (category_theory.as_small C)).obj X).down
C : Type u₁,	_inst_1 : category_theory.category C	⊢ ∀ {X Y : category_theory.as_small C} (f : X ⟶ Y), (category_theory.as_small.down ⋙ category_theory.as_small.up).map f ≫ (category_theory.eq_to_iso _).hom = (category_theory.eq_to_iso _).hom ≫ (𝟭 (category_theory.as_small C)).map f
C : Type u₁,	_inst_1 : category_theory.category C,	X Y : ulift C,	f : X ⟶ Y	⊢ (category_theory.ulift.down ⋙ category_theory.ulift.up).map f ≫ 𝟙 ((category_theory.ulift.down ⋙ category_theory.ulift.up).obj Y).down = 𝟙 ((category_theory.ulift.down ⋙ category_theory.ulift.up).obj X).down ≫ (𝟭 (ulift C)).map f
C : Type u₁,	_inst_1 : category_theory.category C,	X Y : ulift C,	f : X ⟶ Y	⊢ f ≫ 𝟙 Y = 𝟙 X ≫ f
C : Type u₁,	_inst_1 : category_theory.category C,	X Y : ulift C,	f : X ⟶ Y	⊢ (𝟭 (ulift C)).map f ≫ 𝟙 ((𝟭 (ulift C)).obj Y).down = 𝟙 ((𝟭 (ulift C)).obj X).down ≫ (category_theory.ulift.down ⋙ category_theory.ulift.up).map f
C : Type u₁,	_inst_1 : category_theory.category C	⊢ {app := λ (X : ulift C), 𝟙 ((category_theory.ulift.down ⋙ category_theory.ulift.up).obj X).down, naturality' := _} ≫ {app := λ (X : ulift C), 𝟙 ((𝟭 (ulift C)).obj X).down, naturality' := _} = 𝟙 (category_theory.ulift.down ⋙ category_theory.ulift.up)
C : Type u₁,	_inst_1 : category_theory.category C,	x : ulift C	⊢ ({app := λ (X : ulift C), 𝟙 ((category_theory.ulift.down ⋙ category_theory.ulift.up).obj X).down, naturality' := _} ≫ {app := λ (X : ulift C), 𝟙 ((𝟭 (ulift C)).obj X).down, naturality' := _}).app x = (𝟙 (category_theory.ulift.down ⋙ category_theory.ulift.up)).app x
C : Type u₁,	_inst_1 : category_theory.category C,	x : ulift C	⊢ 𝟙 ((category_theory.ulift.down ⋙ category_theory.ulift.up).obj x).down ≫ 𝟙 ((category_theory.ulift.down ⋙ category_theory.ulift.up).obj x).down = 𝟙 ((category_theory.ulift.down ⋙ category_theory.ulift.up).obj x).down
C : Type u₁,	_inst_1 : category_theory.category C	⊢ {app := λ (X : ulift C), 𝟙 ((𝟭 (ulift C)).obj X).down, naturality' := _} ≫ {app := λ (X : ulift C), 𝟙 ((category_theory.ulift.down ⋙ category_theory.ulift.up).obj X).down, naturality' := _} = 𝟙 (𝟭 (ulift C))
C : Type u₁,	_inst_1 : category_theory.category C,	x : ulift C	⊢ ({app := λ (X : ulift C), 𝟙 ((𝟭 (ulift C)).obj X).down, naturality' := _} ≫ {app := λ (X : ulift C), 𝟙 ((category_theory.ulift.down ⋙ category_theory.ulift.up).obj X).down, naturality' := _}).app x = (𝟙 (𝟭 (ulift C))).app x
C : Type u₁,	_inst_1 : category_theory.category C,	x : ulift C	⊢ 𝟙 ((𝟭 (ulift C)).obj x).down ≫ 𝟙 ((𝟭 (ulift C)).obj x).down = 𝟙 ((𝟭 (ulift C)).obj x).down
C : Type u₁,	_inst_1 : category_theory.category C,	X : C	⊢ category_theory.ulift.up.map ({hom := 𝟙 (𝟭 C), inv := 𝟙 (category_theory.ulift.up ⋙ category_theory.ulift.down), hom_inv_id' := _, inv_hom_id' := _}.hom.app X) ≫ {hom := {app := λ (X : ulift C), 𝟙 ((category_theory.ulift.down ⋙ category_theory.ulift.up).obj X).down, naturality' := _}, inv := {app := λ (X : ulift C), 𝟙 ((𝟭 (ulift C)).obj X).down, naturality' := _}, hom_inv_id' := _, inv_hom_id' := _}.hom.app (category_theory.ulift.up.obj X) = 𝟙 (category_theory.ulift.up.obj X)
C : Type u₁,	_inst_1 : category_theory.category C,	X : C	⊢ 𝟙 X ≫ 𝟙 X = 𝟙 X
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.limits.has_finite_products C,	I B : C,	t : category_theory.limits.is_initial I,	_inst_4 : category_theory.cartesian_closed C,	B : C,	g h : B ⟶ I,	_x : g ≫ t.to B = h ≫ t.to B	⊢ g = h
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.limits.has_finite_products C,	I B : C,	t : category_theory.limits.is_initial I,	_inst_4 : category_theory.cartesian_closed C,	B : C,	g h : B ⟶ I,	_x : g ≫ t.to B = h ≫ t.to B,	_inst : category_theory.is_iso g	⊢ g = h
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.limits.has_finite_products C,	I B : C,	t : category_theory.limits.is_initial I,	_inst_4 : category_theory.cartesian_closed C,	B : C,	g h : B ⟶ I,	_x : g ≫ t.to B = h ≫ t.to B,	_inst : category_theory.is_iso g,	_inst_3 : category_theory.is_iso h	⊢ g = h
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	X _x : C	⊢ function.left_inverse (λ (a : X ⟶ (𝟭 C).obj _x), (λ_ X).hom ≫ a) (λ (a : (category_theory.monoidal_category.tensor_left (𝟙_ C)).obj X ⟶ _x), (λ_ X).inv ≫ a)
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	X _x : C	⊢ function.right_inverse (λ (a : X ⟶ (𝟭 C).obj _x), (λ_ X).hom ≫ a) (λ (a : (category_theory.monoidal_category.tensor_left (𝟙_ C)).obj X ⟶ _x), (λ_ X).inv ≫ a)
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	X' X Y : C,	f : X' ⟶ X,	g : X ⟶ (𝟭 C).obj Y	⊢ ⇑({to_fun := λ (a : (category_theory.monoidal_category.tensor_left (𝟙_ C)).obj X' ⟶ Y), (λ_ X').inv ≫ a, inv_fun := λ (a : X' ⟶ (𝟭 C).obj Y), (λ_ X').hom ≫ a, left_inv := _, right_inv := _}.symm) (f ≫ g) = (category_theory.monoidal_category.tensor_left (𝟙_ C)).map f ≫ ⇑({to_fun := λ (a : (category_theory.monoidal_category.tensor_left (𝟙_ C)).obj X ⟶ Y), (λ_ X).inv ≫ a, inv_fun := λ (a : X ⟶ (𝟭 C).obj Y), (λ_ X).hom ≫ a, left_inv := _, right_inv := _}.symm) g
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	X' X Y : C,	f : X' ⟶ X,	g : X ⟶ (𝟭 C).obj Y	⊢ (λ_ X').hom ≫ f ≫ g = (𝟙 (𝟙_ C) ⊗ f) ≫ (λ_ X).hom ≫ g
C : Type v₁,	_inst_2 : category_theory.small_category C,	F : C ⥤ Type v₁	⊢ category_theory.is_left_adjoint (category_theory.monoidal_category.tensor_left F)
C : Type v₁,	_inst_2 : category_theory.small_category C,	F : C ⥤ Type v₁,	_inst : category_theory.limits.preserves_colimits (category_theory.limits.prod.functor.obj F) := category_theory.functor_category.prod_preserves_colimits F	⊢ category_theory.is_left_adjoint (category_theory.monoidal_category.tensor_left F)
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.limits.has_zero_morphisms C,	_inst_3 : category_theory.has_shift C,	X Y : category_theory.differential_object C,	f : X ≅ Y	⊢ auto_param (f.hom.f ≫ f.inv.f = 𝟙 X.X) (name.mk_string "obviously" name.anonymous)
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.limits.has_zero_morphisms C,	_inst_3 : category_theory.has_shift C,	X Y : category_theory.differential_object C,	f : X ≅ Y	⊢ f.hom.f ≫ f.inv.f = 𝟙 X.X
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.limits.has_zero_morphisms C,	_inst_3 : category_theory.has_shift C,	X Y : category_theory.differential_object C,	f : X ≅ Y	⊢ f.inv.f ≫ f.hom.f = 𝟙 Y.X
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.limits.has_zero_morphisms C,	_inst_3 : category_theory.has_shift C,	X Y : category_theory.differential_object C,	f : X ≅ Y	⊢ auto_param (f.inv.f ≫ f.hom.f = 𝟙 Y.X) (name.mk_string "obviously" name.anonymous)
α : Type u₁,	_inst_1 : subsingleton α	⊢ subsingleton α
α : Type u₁,	_inst_1 : subsingleton α	⊢ subsingleton (category_theory.discrete α)
C : Type u₁,	_inst_1 : category_theory.category C,	X Y : C,	f : X ⟶ Y,	_inst_2 : category_theory.split_epi f,	_inst_3 : category_theory.epi (category_theory.section_ f)	⊢ category_theory.section_ f ≫ f ≫ category_theory.section_ f = category_theory.section_ f
C : Type u₁,	_inst_1 : category_theory.category C,	X Y : C,	f : X ⟶ Y,	_inst_2 : category_theory.split_epi f,	_inst_3 : category_theory.epi (category_theory.section_ f)	⊢ category_theory.section_ f ≫ f = 𝟙 Y
C : Type u₁,	_inst_1 : category_theory.category C,	D : Type u₂,	_inst_2 : category_theory.category D,	e : C ≌ D,	X Y : D,	f f' : X ⟶ e.functor.obj (e.inverse.obj Y)	⊢ f ≫ e.counit.app Y = f' ≫ e.counit.app Y ↔ f = f'
α : Type u,	_inst_2 : semilattice_sup_bot α	⊢ category_theory.is_filtered α
α : Type u,	_inst_2 : semilattice_sup_top α	⊢ category_theory.is_filtered α
α : Type u,	_inst_2 : semilattice_inf_bot α	⊢ category_theory.is_cofiltered α
α : Type u,	_inst_2 : semilattice_inf_top α	⊢ category_theory.is_cofiltered α
C : Type u₁,	_inst_1 : category_theory.category C,	D : Type u₂,	_inst_2 : category_theory.category D,	F : C ⥤ D	⊢ F ⋙ 𝟭 D = F
C : Type u₁,	_inst_1 : category_theory.category C,	D : Type u₂,	_inst_2 : category_theory.category D,	F : C ⥤ D	⊢ F ⋙ 𝟭 D = F
C : Type u₁,	_inst_1 : category_theory.category C,	D : Type u₂,	_inst_2 : category_theory.category D,	F_obj : C → D,	F_map : Π {X Y : C}, (X ⟶ Y) → (F_obj X ⟶ F_obj Y),	F_map_id' : auto_param (∀ (X : C), F_map (𝟙 X) = 𝟙 (F_obj X)) (name.mk_string "obviously" name.anonymous),	F_map_comp' : auto_param (∀ {X Y Z : C} (f : X ⟶ Y) (g : Y ⟶ Z), F_map (f ≫ g) = F_map f ≫ F_map g) (name.mk_string "obviously" name.anonymous)	⊢ {obj := F_obj, map := F_map, map_id' := F_map_id', map_comp' := F_map_comp'} ⋙ 𝟭 D = {obj := F_obj, map := F_map, map_id' := F_map_id', map_comp' := F_map_comp'}
C : Type u,	_inst_1 : category_theory.category C,	X Y : C,	α β : X ≅ Y,	w : α.hom = β.hom,	this : α.inv = β.inv	⊢ α = β
C : Type u,	_inst_1 : category_theory.category C,	X Y : C,	α β : X ≅ Y,	w : α.hom = β.hom,	this : α.inv = β.inv	⊢ α = β
C : Type u,	_inst_1 : category_theory.category C,	X Y : C,	α β : X ≅ Y,	w : α.hom = β.hom,	this : α.inv = β.inv	⊢ α = β
C : Type u,	_inst_1 : category_theory.category C,	X Y : C,	β : X ≅ Y,	α_hom : X ⟶ Y,	α_inv : Y ⟶ X,	α_hom_inv_id' : auto_param (α_hom ≫ α_inv = 𝟙 X) (name.mk_string "obviously" name.anonymous),	α_inv_hom_id' : auto_param (α_inv ≫ α_hom = 𝟙 Y) (name.mk_string "obviously" name.anonymous),	w : {hom := α_hom, inv := α_inv, hom_inv_id' := α_hom_inv_id', inv_hom_id' := α_inv_hom_id'}.hom = β.hom,	this : {hom := α_hom, inv := α_inv, hom_inv_id' := α_hom_inv_id', inv_hom_id' := α_inv_hom_id'}.inv = β.inv	⊢ {hom := α_hom, inv := α_inv, hom_inv_id' := α_hom_inv_id', inv_hom_id' := α_inv_hom_id'} = β
C : Type u,	_inst_1 : category_theory.category C,	X Y : C,	α_hom : X ⟶ Y,	α_inv : Y ⟶ X,	α_hom_inv_id' : auto_param (α_hom ≫ α_inv = 𝟙 X) (name.mk_string "obviously" name.anonymous),	α_inv_hom_id' : auto_param (α_inv ≫ α_hom = 𝟙 Y) (name.mk_string "obviously" name.anonymous),	β_hom : X ⟶ Y,	β_inv : Y ⟶ X,	β_hom_inv_id' : auto_param (β_hom ≫ β_inv = 𝟙 X) (name.mk_string "obviously" name.anonymous),	β_inv_hom_id' : auto_param (β_inv ≫ β_hom = 𝟙 Y) (name.mk_string "obviously" name.anonymous),	w : {hom := α_hom, inv := α_inv, hom_inv_id' := α_hom_inv_id', inv_hom_id' := α_inv_hom_id'}.hom = {hom := β_hom, inv := β_inv, hom_inv_id' := β_hom_inv_id', inv_hom_id' := β_inv_hom_id'}.hom,	this : {hom := α_hom, inv := α_inv, hom_inv_id' := α_hom_inv_id', inv_hom_id' := α_inv_hom_id'}.inv = {hom := β_hom, inv := β_inv, hom_inv_id' := β_hom_inv_id', inv_hom_id' := β_inv_hom_id'}.inv	⊢ {hom := α_hom, inv := α_inv, hom_inv_id' := α_hom_inv_id', inv_hom_id' := α_inv_hom_id'} = {hom := β_hom, inv := β_inv, hom_inv_id' := β_hom_inv_id', inv_hom_id' := β_inv_hom_id'}
C : Type u,	_inst_1 : category_theory.category C,	X Y : C,	α β : X ≅ Y,	w : α.hom = β.hom	⊢ α.inv = α.inv ≫ β.hom ≫ β.inv
C : Type u,	_inst_1 : category_theory.category C,	X Y : C,	α β : X ≅ Y,	w : α.hom = β.hom	⊢ α.inv ≫ β.hom ≫ β.inv = (α.inv ≫ α.hom) ≫ β.inv
C : Type u,	_inst_1 : category_theory.category C,	X Y : C,	α β : X ≅ Y,	w : α.hom = β.hom	⊢ (α.inv ≫ α.hom) ≫ β.inv = β.inv
J : Type v,	_inst_1 : category_theory.small_category J,	A : Type u₁,	_inst_2 : category_theory.category A,	B : Type u₂,	_inst_3 : category_theory.category B,	T : Type u₃,	_inst_4 : category_theory.category T,	L : A ⥤ T,	R : B ⥤ T,	F : J ⥤ category_theory.comma L R,	_inst_5 : category_theory.limits.preserves_limit (F ⋙ category_theory.comma.snd L R) R,	c₁ : category_theory.limits.cone (F ⋙ category_theory.comma.fst L R),	t₁ : category_theory.limits.is_limit c₁,	c₂ : category_theory.limits.cone (F ⋙ category_theory.comma.snd L R),	t₂ : category_theory.limits.is_limit c₂,	s : category_theory.limits.cone F,	j : J	⊢ (L.map (t₁.lift ((category_theory.comma.fst L R).map_cone s)) ≫ (category_theory.comma.cone_of_preserves F c₁ t₂).X.hom) ≫ (R.map_cone c₂).π.app j = (s.X.hom ≫ R.map (t₂.lift ((category_theory.comma.snd L R).map_cone s))) ≫ (R.map_cone c₂).π.app j
J : Type v,	_inst_1 : category_theory.small_category J,	A : Type u₁,	_inst_2 : category_theory.category A,	B : Type u₂,	_inst_3 : category_theory.category B,	T : Type u₃,	_inst_4 : category_theory.category T,	L : A ⥤ T,	R : B ⥤ T,	F : J ⥤ category_theory.comma L R,	_inst_5 : category_theory.limits.preserves_limit (F ⋙ category_theory.comma.snd L R) R,	c₁ : category_theory.limits.cone (F ⋙ category_theory.comma.fst L R),	t₁ : category_theory.limits.is_limit c₁,	c₂ : category_theory.limits.cone (F ⋙ category_theory.comma.snd L R),	t₂ : category_theory.limits.is_limit c₂,	s : category_theory.limits.cone F,	j : J	⊢ L.map (((category_theory.comma.fst L R).map_cone s).π.app j) ≫ (F.obj j).hom = s.X.hom ≫ R.map (((category_theory.comma.snd L R).map_cone s).π.app j)
J : Type v,	_inst_1 : category_theory.small_category J,	A : Type u₁,	_inst_2 : category_theory.category A,	B : Type u₂,	_inst_3 : category_theory.category B,	T : Type u₃,	_inst_4 : category_theory.category T,	L : A ⥤ T,	R : B ⥤ T,	F : J ⥤ category_theory.comma L R,	_inst_5 : category_theory.limits.preserves_limit (F ⋙ category_theory.comma.snd L R) R,	c₁ : category_theory.limits.cone (F ⋙ category_theory.comma.fst L R),	t₁ : category_theory.limits.is_limit c₁,	c₂ : category_theory.limits.cone (F ⋙ category_theory.comma.snd L R),	t₂ : category_theory.limits.is_limit c₂,	s : category_theory.limits.cone F,	m : s.X ⟶ (category_theory.comma.cone_of_preserves F c₁ t₂).X,	w : ∀ (j : J), m ≫ (category_theory.comma.cone_of_preserves F c₁ t₂).π.app j = s.π.app j,	j : J	⊢ ?m_1 ≫ c₁.π.app j = ((category_theory.comma.fst L R).map_cone s).π.app j
J : Type v,	_inst_1 : category_theory.small_category J,	A : Type u₁,	_inst_2 : category_theory.category A,	B : Type u₂,	_inst_3 : category_theory.category B,	T : Type u₃,	_inst_4 : category_theory.category T,	L : A ⥤ T,	R : B ⥤ T,	F : J ⥤ category_theory.comma L R,	_inst_5 : category_theory.limits.preserves_limit (F ⋙ category_theory.comma.snd L R) R,	c₁ : category_theory.limits.cone (F ⋙ category_theory.comma.fst L R),	t₁ : category_theory.limits.is_limit c₁,	c₂ : category_theory.limits.cone (F ⋙ category_theory.comma.snd L R),	t₂ : category_theory.limits.is_limit c₂,	s : category_theory.limits.cone F,	m : s.X ⟶ (category_theory.comma.cone_of_preserves F c₁ t₂).X,	w : ∀ (j : J), m ≫ (category_theory.comma.cone_of_preserves F c₁ t₂).π.app j = s.π.app j,	j : J	⊢ ?m_1 ≫ c₂.π.app j = ((category_theory.comma.snd L R).map_cone s).π.app j
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.concrete_category C,	J : Type v,	_inst_3 : category_theory.small_category J,	F : J ⥤ C,	_inst_4 : category_theory.limits.preserves_colimit F (category_theory.forget C),	D : category_theory.limits.cocone F,	hD : category_theory.limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : category_theory.limits.cocone (F ⋙ category_theory.forget C) := (category_theory.forget C).map_cocone D,	hE : category_theory.limits.is_colimit E := category_theory.limits.is_colimit_of_preserves (category_theory.forget C) hD,	G : category_theory.limits.cocone (F ⋙ category_theory.forget C) := category_theory.limits.types.colimit_cocone (F ⋙ category_theory.forget C)	⊢ function.surjective ff
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.concrete_category C,	J : Type v,	_inst_3 : category_theory.small_category J,	F : J ⥤ C,	_inst_4 : category_theory.limits.preserves_colimit F (category_theory.forget C),	D : category_theory.limits.cocone F,	hD : category_theory.limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : category_theory.limits.cocone (F ⋙ category_theory.forget C) := (category_theory.forget C).map_cocone D,	hE : category_theory.limits.is_colimit E := category_theory.limits.is_colimit_of_preserves (category_theory.forget C) hD,	G : category_theory.limits.cocone (F ⋙ category_theory.forget C) := category_theory.limits.types.colimit_cocone (F ⋙ category_theory.forget C),	hG : category_theory.limits.is_colimit (category_theory.limits.types.colimit_cocone (F ⋙ category_theory.forget C)) := category_theory.limits.types.colimit_cocone_is_colimit (F ⋙ category_theory.forget C)	⊢ function.surjective ff
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.concrete_category C,	J : Type v,	_inst_3 : category_theory.small_category J,	F : J ⥤ C,	_inst_4 : category_theory.limits.preserves_colimit F (category_theory.forget C),	D : category_theory.limits.cocone F,	hD : category_theory.limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : category_theory.limits.cocone (F ⋙ category_theory.forget C) := (category_theory.forget C).map_cocone D,	hE : category_theory.limits.is_colimit E := category_theory.limits.is_colimit_of_preserves (category_theory.forget C) hD,	G : category_theory.limits.cocone (F ⋙ category_theory.forget C) := category_theory.limits.types.colimit_cocone (F ⋙ category_theory.forget C),	hG : category_theory.limits.is_colimit (category_theory.limits.types.colimit_cocone (F ⋙ category_theory.forget C)) := category_theory.limits.types.colimit_cocone_is_colimit (F ⋙ category_theory.forget C),	T : E ≅ G := hE.unique_up_to_iso hG	⊢ function.surjective ff
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.concrete_category C,	J : Type v,	_inst_3 : category_theory.small_category J,	F : J ⥤ C,	_inst_4 : category_theory.limits.preserves_colimit F (category_theory.forget C),	D : category_theory.limits.cocone F,	hD : category_theory.limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : category_theory.limits.cocone (F ⋙ category_theory.forget C) := (category_theory.forget C).map_cocone D,	hE : category_theory.limits.is_colimit E := category_theory.limits.is_colimit_of_preserves (category_theory.forget C) hD,	G : category_theory.limits.cocone (F ⋙ category_theory.forget C) := category_theory.limits.types.colimit_cocone (F ⋙ category_theory.forget C),	hG : category_theory.limits.is_colimit (category_theory.limits.types.colimit_cocone (F ⋙ category_theory.forget C)) := category_theory.limits.types.colimit_cocone_is_colimit (F ⋙ category_theory.forget C),	T : E ≅ G := hE.unique_up_to_iso hG,	TX : E.X ≅ G.X := (category_theory.limits.cocones.forget (F ⋙ category_theory.forget C)).map_iso T	⊢ function.surjective ff
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.concrete_category C,	J : Type v,	_inst_3 : category_theory.small_category J,	F : J ⥤ C,	_inst_4 : category_theory.limits.preserves_colimit F (category_theory.forget C),	D : category_theory.limits.cocone F,	hD : category_theory.limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : category_theory.limits.cocone (F ⋙ category_theory.forget C) := (category_theory.forget C).map_cocone D,	hE : category_theory.limits.is_colimit E := category_theory.limits.is_colimit_of_preserves (category_theory.forget C) hD,	G : category_theory.limits.cocone (F ⋙ category_theory.forget C) := category_theory.limits.types.colimit_cocone (F ⋙ category_theory.forget C),	hG : category_theory.limits.is_colimit (category_theory.limits.types.colimit_cocone (F ⋙ category_theory.forget C)) := category_theory.limits.types.colimit_cocone_is_colimit (F ⋙ category_theory.forget C),	T : E ≅ G := hE.unique_up_to_iso hG,	TX : E.X ≅ G.X := (category_theory.limits.cocones.forget (F ⋙ category_theory.forget C)).map_iso T,	this : function.surjective (TX.hom ∘ ff)	⊢ function.surjective ff
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.concrete_category C,	J : Type v,	_inst_3 : category_theory.small_category J,	F : J ⥤ C,	_inst_4 : category_theory.limits.preserves_colimit F (category_theory.forget C),	D : category_theory.limits.cocone F,	hD : category_theory.limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : category_theory.limits.cocone (F ⋙ category_theory.forget C) := (category_theory.forget C).map_cocone D,	hE : category_theory.limits.is_colimit E := category_theory.limits.is_colimit_of_preserves (category_theory.forget C) hD,	G : category_theory.limits.cocone (F ⋙ category_theory.forget C) := category_theory.limits.types.colimit_cocone (F ⋙ category_theory.forget C),	hG : category_theory.limits.is_colimit (category_theory.limits.types.colimit_cocone (F ⋙ category_theory.forget C)) := category_theory.limits.types.colimit_cocone_is_colimit (F ⋙ category_theory.forget C),	T : E ≅ G := hE.unique_up_to_iso hG,	TX : E.X ≅ G.X := (category_theory.limits.cocones.forget (F ⋙ category_theory.forget C)).map_iso T,	this : function.surjective (TX.hom ∘ ff),	a : ↥(D.X)	⊢ ∃ (a_1 : Σ (j : J), ↥(F.obj j)), ff a_1 = a
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.concrete_category C,	J : Type v,	_inst_3 : category_theory.small_category J,	F : J ⥤ C,	_inst_4 : category_theory.limits.preserves_colimit F (category_theory.forget C),	D : category_theory.limits.cocone F,	hD : category_theory.limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : category_theory.limits.cocone (F ⋙ category_theory.forget C) := (category_theory.forget C).map_cocone D,	hE : category_theory.limits.is_colimit E := category_theory.limits.is_colimit_of_preserves (category_theory.forget C) hD,	G : category_theory.limits.cocone (F ⋙ category_theory.forget C) := category_theory.limits.types.colimit_cocone (F ⋙ category_theory.forget C),	hG : category_theory.limits.is_colimit (category_theory.limits.types.colimit_cocone (F ⋙ category_theory.forget C)) := category_theory.limits.types.colimit_cocone_is_colimit (F ⋙ category_theory.forget C),	T : E ≅ G := hE.unique_up_to_iso hG,	TX : E.X ≅ G.X := (category_theory.limits.cocones.forget (F ⋙ category_theory.forget C)).map_iso T,	this : function.surjective (TX.hom ∘ ff),	a : ↥(D.X),	b : Σ (j : J), ↥(F.obj j),	hb : (TX.hom ∘ ff) b = TX.hom a	⊢ ∃ (a_1 : Σ (j : J), ↥(F.obj j)), ff a_1 = a
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.concrete_category C,	J : Type v,	_inst_3 : category_theory.small_category J,	F : J ⥤ C,	_inst_4 : category_theory.limits.preserves_colimit F (category_theory.forget C),	D : category_theory.limits.cocone F,	hD : category_theory.limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : category_theory.limits.cocone (F ⋙ category_theory.forget C) := (category_theory.forget C).map_cocone D,	hE : category_theory.limits.is_colimit E := category_theory.limits.is_colimit_of_preserves (category_theory.forget C) hD,	G : category_theory.limits.cocone (F ⋙ category_theory.forget C) := category_theory.limits.types.colimit_cocone (F ⋙ category_theory.forget C),	hG : category_theory.limits.is_colimit (category_theory.limits.types.colimit_cocone (F ⋙ category_theory.forget C)) := category_theory.limits.types.colimit_cocone_is_colimit (F ⋙ category_theory.forget C),	T : E ≅ G := hE.unique_up_to_iso hG,	TX : E.X ≅ G.X := (category_theory.limits.cocones.forget (F ⋙ category_theory.forget C)).map_iso T,	this : function.surjective (TX.hom ∘ ff),	a : ↥(D.X),	b : Σ (j : J), ↥(F.obj j),	hb : (TX.hom ∘ ff) b = TX.hom a	⊢ ff b = a
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.concrete_category C,	J : Type v,	_inst_3 : category_theory.small_category J,	F : J ⥤ C,	_inst_4 : category_theory.limits.preserves_colimit F (category_theory.forget C),	D : category_theory.limits.cocone F,	hD : category_theory.limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : category_theory.limits.cocone (F ⋙ category_theory.forget C) := (category_theory.forget C).map_cocone D,	hE : category_theory.limits.is_colimit E := category_theory.limits.is_colimit_of_preserves (category_theory.forget C) hD,	G : category_theory.limits.cocone (F ⋙ category_theory.forget C) := category_theory.limits.types.colimit_cocone (F ⋙ category_theory.forget C),	hG : category_theory.limits.is_colimit (category_theory.limits.types.colimit_cocone (F ⋙ category_theory.forget C)) := category_theory.limits.types.colimit_cocone_is_colimit (F ⋙ category_theory.forget C),	T : E ≅ G := hE.unique_up_to_iso hG,	TX : E.X ≅ G.X := (category_theory.limits.cocones.forget (F ⋙ category_theory.forget C)).map_iso T,	this : function.surjective (TX.hom ∘ ff),	a : ↥(D.X),	b : Σ (j : J), ↥(F.obj j),	hb : TX.inv ((TX.hom ∘ ff) b) = TX.inv (TX.hom a)	⊢ ff b = a
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.concrete_category C,	J : Type v,	_inst_3 : category_theory.small_category J,	F : J ⥤ C,	_inst_4 : category_theory.limits.preserves_colimit F (category_theory.forget C),	D : category_theory.limits.cocone F,	hD : category_theory.limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : category_theory.limits.cocone (F ⋙ category_theory.forget C) := (category_theory.forget C).map_cocone D,	hE : category_theory.limits.is_colimit E := category_theory.limits.is_colimit_of_preserves (category_theory.forget C) hD,	G : category_theory.limits.cocone (F ⋙ category_theory.forget C) := category_theory.limits.types.colimit_cocone (F ⋙ category_theory.forget C),	hG : category_theory.limits.is_colimit (category_theory.limits.types.colimit_cocone (F ⋙ category_theory.forget C)) := category_theory.limits.types.colimit_cocone_is_colimit (F ⋙ category_theory.forget C),	T : E ≅ G := hE.unique_up_to_iso hG,	TX : E.X ≅ G.X := (category_theory.limits.cocones.forget (F ⋙ category_theory.forget C)).map_iso T,	this : function.surjective (TX.hom ∘ ff)	⊢ function.surjective ff		C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.concrete_category C,	J : Type v,	_inst_3 : category_theory.small_category J,	F : J ⥤ C,	_inst_4 : category_theory.limits.preserves_colimit F (category_theory.forget C),	D : category_theory.limits.cocone F,	hD : category_theory.limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : category_theory.limits.cocone (F ⋙ category_theory.forget C) := (category_theory.forget C).map_cocone D,	hE : category_theory.limits.is_colimit E := category_theory.limits.is_colimit_of_preserves (category_theory.forget C) hD,	G : category_theory.limits.cocone (F ⋙ category_theory.forget C) := category_theory.limits.types.colimit_cocone (F ⋙ category_theory.forget C),	hG : category_theory.limits.is_colimit (category_theory.limits.types.colimit_cocone (F ⋙ category_theory.forget C)) := category_theory.limits.types.colimit_cocone_is_colimit (F ⋙ category_theory.forget C),	T : E ≅ G := hE.unique_up_to_iso hG,	TX : E.X ≅ G.X := (category_theory.limits.cocones.forget (F ⋙ category_theory.forget C)).map_iso T	⊢ function.surjective (TX.hom ∘ ff)
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.concrete_category C,	J : Type v,	_inst_3 : category_theory.small_category J,	F : J ⥤ C,	_inst_4 : category_theory.limits.preserves_colimit F (category_theory.forget C),	D : category_theory.limits.cocone F,	hD : category_theory.limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : category_theory.limits.cocone (F ⋙ category_theory.forget C) := (category_theory.forget C).map_cocone D,	hE : category_theory.limits.is_colimit E := category_theory.limits.is_colimit_of_preserves (category_theory.forget C) hD,	G : category_theory.limits.cocone (F ⋙ category_theory.forget C) := category_theory.limits.types.colimit_cocone (F ⋙ category_theory.forget C),	hG : category_theory.limits.is_colimit (category_theory.limits.types.colimit_cocone (F ⋙ category_theory.forget C)) := category_theory.limits.types.colimit_cocone_is_colimit (F ⋙ category_theory.forget C),	T : E ≅ G := hE.unique_up_to_iso hG,	TX : E.X ≅ G.X := (category_theory.limits.cocones.forget (F ⋙ category_theory.forget C)).map_iso T,	this : function.surjective (TX.hom ∘ ff),	a : ↥(D.X),	b : Σ (j : J), ↥(F.obj j),	hb : (TX.hom ≫ TX.inv) (ff b) = (TX.hom ≫ TX.inv) a	⊢ ff b = a
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.concrete_category C,	J : Type v,	_inst_3 : category_theory.small_category J,	F : J ⥤ C,	_inst_4 : category_theory.limits.preserves_colimit F (category_theory.forget C),	D : category_theory.limits.cocone F,	hD : category_theory.limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : category_theory.limits.cocone (F ⋙ category_theory.forget C) := (category_theory.forget C).map_cocone D,	hE : category_theory.limits.is_colimit E := category_theory.limits.is_colimit_of_preserves (category_theory.forget C) hD,	G : category_theory.limits.cocone (F ⋙ category_theory.forget C) := category_theory.limits.types.colimit_cocone (F ⋙ category_theory.forget C),	hG : category_theory.limits.is_colimit (category_theory.limits.types.colimit_cocone (F ⋙ category_theory.forget C)) := category_theory.limits.types.colimit_cocone_is_colimit (F ⋙ category_theory.forget C),	T : E ≅ G := hE.unique_up_to_iso hG,	TX : E.X ≅ G.X := (category_theory.limits.cocones.forget (F ⋙ category_theory.forget C)).map_iso T	⊢ function.surjective (TX.hom ∘ ff)
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.concrete_category C,	J : Type v,	_inst_3 : category_theory.small_category J,	F : J ⥤ C,	_inst_4 : category_theory.limits.preserves_colimit F (category_theory.forget C),	D : category_theory.limits.cocone F,	hD : category_theory.limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : category_theory.limits.cocone (F ⋙ category_theory.forget C) := (category_theory.forget C).map_cocone D,	hE : category_theory.limits.is_colimit E := category_theory.limits.is_colimit_of_preserves (category_theory.forget C) hD,	G : category_theory.limits.cocone (F ⋙ category_theory.forget C) := category_theory.limits.types.colimit_cocone (F ⋙ category_theory.forget C),	hG : category_theory.limits.is_colimit (category_theory.limits.types.colimit_cocone (F ⋙ category_theory.forget C)) := category_theory.limits.types.colimit_cocone_is_colimit (F ⋙ category_theory.forget C),	T : E ≅ G := hE.unique_up_to_iso hG,	TX : E.X ≅ G.X := (category_theory.limits.cocones.forget (F ⋙ category_theory.forget C)).map_iso T	⊢ TX.hom ∘ ff = λ (a : Σ (j : J), ↥(F.obj j)), G.ι.app a.fst a.snd
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.concrete_category C,	J : Type v,	_inst_3 : category_theory.small_category J,	F : J ⥤ C,	_inst_4 : category_theory.limits.preserves_colimit F (category_theory.forget C),	D : category_theory.limits.cocone F,	hD : category_theory.limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : category_theory.limits.cocone (F ⋙ category_theory.forget C) := (category_theory.forget C).map_cocone D,	hE : category_theory.limits.is_colimit E := category_theory.limits.is_colimit_of_preserves (category_theory.forget C) hD,	G : category_theory.limits.cocone (F ⋙ category_theory.forget C) := category_theory.limits.types.colimit_cocone (F ⋙ category_theory.forget C),	hG : category_theory.limits.is_colimit (category_theory.limits.types.colimit_cocone (F ⋙ category_theory.forget C)) := category_theory.limits.types.colimit_cocone_is_colimit (F ⋙ category_theory.forget C),	T : E ≅ G := hE.unique_up_to_iso hG,	TX : E.X ≅ G.X := (category_theory.limits.cocones.forget (F ⋙ category_theory.forget C)).map_iso T,	a : Σ (j : J), ↥(F.obj j)	⊢ (TX.hom ∘ ff) a = G.ι.app a.fst a.snd
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.concrete_category C,	J : Type v,	_inst_3 : category_theory.small_category J,	F : J ⥤ C,	_inst_4 : category_theory.limits.preserves_colimit F (category_theory.forget C),	D : category_theory.limits.cocone F,	hD : category_theory.limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : category_theory.limits.cocone (F ⋙ category_theory.forget C) := (category_theory.forget C).map_cocone D,	hE : category_theory.limits.is_colimit E := category_theory.limits.is_colimit_of_preserves (category_theory.forget C) hD,	G : category_theory.limits.cocone (F ⋙ category_theory.forget C) := category_theory.limits.types.colimit_cocone (F ⋙ category_theory.forget C),	hG : category_theory.limits.is_colimit (category_theory.limits.types.colimit_cocone (F ⋙ category_theory.forget C)) := category_theory.limits.types.colimit_cocone_is_colimit (F ⋙ category_theory.forget C),	T : E ≅ G := hE.unique_up_to_iso hG,	TX : E.X ≅ G.X := (category_theory.limits.cocones.forget (F ⋙ category_theory.forget C)).map_iso T	⊢ TX.hom ∘ ff = λ (a : Σ (j : J), ↥(F.obj j)), G.ι.app a.fst a.snd		C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.concrete_category C,	J : Type v,	_inst_3 : category_theory.small_category J,	F : J ⥤ C,	_inst_4 : category_theory.limits.preserves_colimit F (category_theory.forget C),	D : category_theory.limits.cocone F,	hD : category_theory.limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : category_theory.limits.cocone (F ⋙ category_theory.forget C) := (category_theory.forget C).map_cocone D,	hE : category_theory.limits.is_colimit E := category_theory.limits.is_colimit_of_preserves (category_theory.forget C) hD,	G : category_theory.limits.cocone (F ⋙ category_theory.forget C) := category_theory.limits.types.colimit_cocone (F ⋙ category_theory.forget C),	hG : category_theory.limits.is_colimit (category_theory.limits.types.colimit_cocone (F ⋙ category_theory.forget C)) := category_theory.limits.types.colimit_cocone_is_colimit (F ⋙ category_theory.forget C),	T : E ≅ G := hE.unique_up_to_iso hG,	TX : E.X ≅ G.X := (category_theory.limits.cocones.forget (F ⋙ category_theory.forget C)).map_iso T,	this : TX.hom ∘ ff = λ (a : Σ (j : J), ↥(F.obj j)), G.ι.app a.fst a.snd	⊢ function.surjective (TX.hom ∘ ff)
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.concrete_category C,	J : Type v,	_inst_3 : category_theory.small_category J,	F : J ⥤ C,	_inst_4 : category_theory.limits.preserves_colimit F (category_theory.forget C),	D : category_theory.limits.cocone F,	hD : category_theory.limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : category_theory.limits.cocone (F ⋙ category_theory.forget C) := (category_theory.forget C).map_cocone D,	hE : category_theory.limits.is_colimit E := category_theory.limits.is_colimit_of_preserves (category_theory.forget C) hD,	G : category_theory.limits.cocone (F ⋙ category_theory.forget C) := category_theory.limits.types.colimit_cocone (F ⋙ category_theory.forget C),	hG : category_theory.limits.is_colimit (category_theory.limits.types.colimit_cocone (F ⋙ category_theory.forget C)) := category_theory.limits.types.colimit_cocone_is_colimit (F ⋙ category_theory.forget C),	T : E ≅ G := hE.unique_up_to_iso hG,	TX : E.X ≅ G.X := (category_theory.limits.cocones.forget (F ⋙ category_theory.forget C)).map_iso T,	a : Σ (j : J), ↥(F.obj j)	⊢ (E.ι.app a.fst ≫ hE.desc G) a.snd = G.ι.app a.fst a.snd
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.concrete_category C,	J : Type v,	_inst_3 : category_theory.small_category J,	F : J ⥤ C,	_inst_4 : category_theory.limits.preserves_colimit F (category_theory.forget C),	D : category_theory.limits.cocone F,	hD : category_theory.limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : category_theory.limits.cocone (F ⋙ category_theory.forget C) := (category_theory.forget C).map_cocone D,	hE : category_theory.limits.is_colimit E := category_theory.limits.is_colimit_of_preserves (category_theory.forget C) hD,	G : category_theory.limits.cocone (F ⋙ category_theory.forget C) := category_theory.limits.types.colimit_cocone (F ⋙ category_theory.forget C),	hG : category_theory.limits.is_colimit (category_theory.limits.types.colimit_cocone (F ⋙ category_theory.forget C)) := category_theory.limits.types.colimit_cocone_is_colimit (F ⋙ category_theory.forget C),	T : E ≅ G := hE.unique_up_to_iso hG,	TX : E.X ≅ G.X := (category_theory.limits.cocones.forget (F ⋙ category_theory.forget C)).map_iso T,	this : TX.hom ∘ ff = λ (a : Σ (j : J), ↥(F.obj j)), G.ι.app a.fst a.snd	⊢ function.surjective (TX.hom ∘ ff)
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.concrete_category C,	J : Type v,	_inst_3 : category_theory.small_category J,	F : J ⥤ C,	_inst_4 : category_theory.limits.preserves_colimit F (category_theory.forget C),	D : category_theory.limits.cocone F,	hD : category_theory.limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : category_theory.limits.cocone (F ⋙ category_theory.forget C) := (category_theory.forget C).map_cocone D,	hE : category_theory.limits.is_colimit E := category_theory.limits.is_colimit_of_preserves (category_theory.forget C) hD,	G : category_theory.limits.cocone (F ⋙ category_theory.forget C) := category_theory.limits.types.colimit_cocone (F ⋙ category_theory.forget C),	hG : category_theory.limits.is_colimit (category_theory.limits.types.colimit_cocone (F ⋙ category_theory.forget C)) := category_theory.limits.types.colimit_cocone_is_colimit (F ⋙ category_theory.forget C),	T : E ≅ G := hE.unique_up_to_iso hG,	TX : E.X ≅ G.X := (category_theory.limits.cocones.forget (F ⋙ category_theory.forget C)).map_iso T,	this : TX.hom ∘ ff = λ (a : Σ (j : J), ↥(F.obj j)), G.ι.app a.fst a.snd	⊢ function.surjective (λ (a : Σ (j : J), ↥(F.obj j)), G.ι.app a.fst a.snd)
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.concrete_category C,	J : Type v,	_inst_3 : category_theory.small_category J,	F : J ⥤ C,	_inst_4 : category_theory.limits.preserves_colimit F (category_theory.forget C),	D : category_theory.limits.cocone F,	hD : category_theory.limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : category_theory.limits.cocone (F ⋙ category_theory.forget C) := (category_theory.forget C).map_cocone D,	hE : category_theory.limits.is_colimit E := category_theory.limits.is_colimit_of_preserves (category_theory.forget C) hD,	G : category_theory.limits.cocone (F ⋙ category_theory.forget C) := category_theory.limits.types.colimit_cocone (F ⋙ category_theory.forget C),	hG : category_theory.limits.is_colimit (category_theory.limits.types.colimit_cocone (F ⋙ category_theory.forget C)) := category_theory.limits.types.colimit_cocone_is_colimit (F ⋙ category_theory.forget C),	T : E ≅ G := hE.unique_up_to_iso hG,	TX : E.X ≅ G.X := (category_theory.limits.cocones.forget (F ⋙ category_theory.forget C)).map_iso T,	this : TX.hom ∘ ff = λ (a : Σ (j : J), ↥(F.obj j)), G.ι.app a.fst a.snd,	j : J,	a : (F ⋙ category_theory.forget C).obj j	⊢ ∃ (a_1 : Σ (j : J), ↥(F.obj j)), (λ (a : Σ (j : J), ↥(F.obj j)), G.ι.app a.fst a.snd) a_1 = quot.mk (category_theory.limits.types.quot.rel (F ⋙ category_theory.forget C)) ⟨j, a⟩
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.concrete_category C,	J : Type v,	_inst_3 : category_theory.small_category J,	F : J ⥤ C,	_inst_4 : category_theory.limits.preserves_colimit F (category_theory.forget C),	D : category_theory.limits.cocone F,	hD : category_theory.limits.is_colimit D	⊢ let ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd in function.surjective ff
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.concrete_category C,	J : Type v,	_inst_3 : category_theory.small_category J,	F : J ⥤ C,	_inst_4 : category_theory.limits.preserves_colimit F (category_theory.forget C),	D : category_theory.limits.cocone F,	hD : category_theory.limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd	⊢ function.surjective ff
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.concrete_category C,	J : Type v,	_inst_3 : category_theory.small_category J,	F : J ⥤ C,	_inst_4 : category_theory.limits.preserves_colimit F (category_theory.forget C),	D : category_theory.limits.cocone F,	hD : category_theory.limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : category_theory.limits.cocone (F ⋙ category_theory.forget C) := (category_theory.forget C).map_cocone D	⊢ function.surjective ff
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.concrete_category C,	J : Type v,	_inst_3 : category_theory.small_category J,	F : J ⥤ C,	_inst_4 : category_theory.limits.preserves_colimit F (category_theory.forget C),	D : category_theory.limits.cocone F,	hD : category_theory.limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : category_theory.limits.cocone (F ⋙ category_theory.forget C) := (category_theory.forget C).map_cocone D,	hE : category_theory.limits.is_colimit E := category_theory.limits.is_colimit_of_preserves (category_theory.forget C) hD	⊢ function.surjective ff
J : Type v,	_inst_1 : category_theory.small_category J,	C : Type u₁,	_inst_3 : category_theory.category C,	D : Type u₂,	_inst_4 : category_theory.category D,	F G : J ⥤ C,	H : C ⥤ D,	α : F ⟶ G,	c : category_theory.limits.cocone G	⊢ ∀ (j : J), (H.map_cocone ((category_theory.limits.cocones.precompose α).obj c)).ι.app j ≫ (category_theory.iso.refl (H.map_cocone ((category_theory.limits.cocones.precompose α).obj c)).X).hom = ((category_theory.limits.cocones.precompose (category_theory.whisker_right α H)).obj (H.map_cocone c)).ι.app j
C : Type u,	_inst_1 : category_theory.category C,	_inst_4 : category_theory.limits.has_coproducts C,	_inst_5 : category_theory.limits.has_coequalizers C,	J : Type v,	𝒥 : category_theory.small_category J,	F : J ⥤ C	⊢ category_theory.limits.has_colimit F
C : Type u,	_inst_2 : category_theory.category C,	B : C,	_inst_3 : category_theory.limits.has_pullbacks C	⊢ category_theory.limits.has_pullbacks (category_theory.over B)
C : Type u,	_inst_2 : category_theory.category C,	B : C,	_inst_3 : category_theory.limits.has_equalizers C	⊢ category_theory.limits.has_equalizers (category_theory.over B)
C : Type u,	_inst_1 : category_theory.category C,	K : Type v,	_inst_3 : category_theory.category K,	_inst_4 : category_theory.limits.has_limits C,	k : K,	J : Type v,	𝒥 : category_theory.small_category J	⊢ category_theory.limits.preserves_limits_of_shape J ((category_theory.evaluation K C).obj k)
C : Type u,	_inst_1 : category_theory.category C,	K : Type v,	_inst_3 : category_theory.category K,	_inst_4 : category_theory.limits.has_limits C,	k : K,	J : Type v,	𝒥 : category_theory.small_category J	⊢ category_theory.limits.preserves_limits_of_shape J ((category_theory.evaluation K C).obj k)
C : Type u,	_inst_1 : category_theory.category C,	K : Type v,	_inst_3 : category_theory.category K,	_inst_4 : category_theory.limits.has_limits C,	k : K,	J : Type v,	𝒥 : category_theory.small_category J	⊢ category_theory.limits.preserves_limits_of_shape J ((category_theory.evaluation K C).obj k)
C : Type u,	_inst_1 : category_theory.category C,	J K : Type v,	_inst_2 : category_theory.small_category J,	_inst_3 : category_theory.category K,	F : J ⥤ K ⥤ C,	c : category_theory.limits.cone F,	t : Π (k : K), category_theory.limits.is_limit (((category_theory.evaluation K C).obj k).map_cone c),	s : category_theory.limits.cone F,	X Y : K,	f : X ⟶ Y,	j : J	⊢ (s.X.map f ≫ (t Y).lift {X := s.X.obj Y, π := category_theory.whisker_right s.π ((category_theory.evaluation K C).obj Y)}) ≫ (((category_theory.evaluation K C).obj Y).map_cone c).π.app j = ((t X).lift {X := s.X.obj X, π := category_theory.whisker_right s.π ((category_theory.evaluation K C).obj X)} ≫ c.X.map f) ≫ (((category_theory.evaluation K C).obj Y).map_cone c).π.app j
C : Type u,	_inst_1 : category_theory.category C,	J K : Type v,	_inst_2 : category_theory.small_category J,	_inst_3 : category_theory.category K,	F : J ⥤ K ⥤ C,	c : category_theory.limits.cone F,	t : Π (k : K), category_theory.limits.is_limit (((category_theory.evaluation K C).obj k).map_cone c),	s : category_theory.limits.cone F,	X Y : K,	f : X ⟶ Y,	j : J	⊢ s.X.map f ≫ {X := s.X.obj Y, π := category_theory.whisker_right s.π ((category_theory.evaluation K C).obj Y)}.π.app j = ((t X).lift {X := s.X.obj X, π := category_theory.whisker_right s.π ((category_theory.evaluation K C).obj X)} ≫ c.X.map f) ≫ (((category_theory.evaluation K C).obj Y).map_cone c).π.app j
C : Type u,	_inst_1 : category_theory.category C,	J K : Type v,	_inst_2 : category_theory.small_category J,	_inst_3 : category_theory.category K,	F : J ⥤ K ⥤ C,	c : Π (k : K), category_theory.limits.limit_cone (F.flip.obj k),	k : K	⊢ ∀ (j : J), (((category_theory.evaluation K C).obj k).map_cone (category_theory.limits.combine_cones F c)).π.app j = (category_theory.iso.refl (((category_theory.evaluation K C).obj k).map_cone (category_theory.limits.combine_cones F c)).X).hom ≫ (c k).cone.π.app j
J : Type v,	_inst_1 : category_theory.small_category J,	C : Type u,	_inst_3 : category_theory.category C,	F : J ⥤ C,	D : Type u',	_inst_4 : category_theory.category D,	_inst_5 : category_theory.limits.has_limit F,	G : C ⥤ D,	_inst_6 : category_theory.limits.has_limit (F ⋙ G),	c : category_theory.limits.cone F,	j : J	⊢ (G.map (category_theory.limits.limit.lift F c) ≫ category_theory.limits.limit.post F G) ≫ category_theory.limits.limit.π (F ⋙ G) j = category_theory.limits.limit.lift (F ⋙ G) (G.map_cone c) ≫ category_theory.limits.limit.π (F ⋙ G) j
J : Type v,	_inst_1 : category_theory.small_category J,	C : Type u,	_inst_3 : category_theory.category C,	F : J ⥤ C,	D : Type u',	_inst_4 : category_theory.category D,	_inst_5 : category_theory.limits.has_limit F,	G : C ⥤ D,	_inst_6 : category_theory.limits.has_limit (F ⋙ G),	c : category_theory.limits.cone F	⊢ G.map (category_theory.limits.limit.lift F c) ≫ category_theory.limits.limit.post F G = category_theory.limits.limit.lift (F ⋙ G) (G.map_cone c)
J : Type v,	_inst_1 : category_theory.small_category J,	C : Type u,	_inst_3 : category_theory.category C,	F : J ⥤ C,	D : Type u',	_inst_4 : category_theory.category D,	_inst_5 : category_theory.limits.has_limit F,	G : C ⥤ D,	_inst_6 : category_theory.limits.has_limit (F ⋙ G),	c : category_theory.limits.cone F,	j : J	⊢ G.map (c.π.app j) = (G.map_cone c).π.app j
J K : Type v,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.small_category K,	C : Type u,	_inst_3 : category_theory.category C,	_inst_4 : category_theory.limits.has_limits_of_shape J C,	_inst_5 : category_theory.limits.has_limits_of_shape K C,	F : J ⥤ C,	E₁ E₂ : K ⥤ J,	α : E₁ ⟶ E₂,	j : K	⊢ category_theory.limits.limit.pre F E₂ ≫ category_theory.limits.limit.π (E₂ ⋙ F) j = (category_theory.limits.limit.pre F E₁ ≫ category_theory.limits.lim.map (category_theory.whisker_right α F)) ≫ category_theory.limits.limit.π (E₂ ⋙ F) j
J K : Type v,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.small_category K,	C : Type u,	_inst_3 : category_theory.category C,	_inst_4 : category_theory.limits.has_limits_of_shape J C,	_inst_5 : category_theory.limits.has_limits_of_shape K C,	F : J ⥤ C,	E₁ E₂ : K ⥤ J,	α : E₁ ⟶ E₂	⊢ category_theory.limits.limit.pre F E₂ = category_theory.limits.limit.pre F E₁ ≫ category_theory.limits.lim.map (category_theory.whisker_right α F)
J K : Type v,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.small_category K,	C : Type u,	_inst_3 : category_theory.category C,	_inst_4 : category_theory.limits.has_limits_of_shape J C,	_inst_5 : category_theory.limits.has_limits_of_shape K C,	F : J ⥤ C,	E₁ E₂ : K ⥤ J,	α : E₁ ⟶ E₂	⊢ category_theory.limits.limit.pre F E₂ = category_theory.limits.limit.pre F E₁ ≫ category_theory.limits.lim.map (category_theory.whisker_right α F)
J K : Type v,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.small_category K,	C : Type u,	_inst_3 : category_theory.category C,	F : J ⥤ C,	D : Type u',	_inst_4 : category_theory.category D,	G : K ⥤ D,	h : category_theory.limits.cone G ≌ category_theory.limits.cone F,	c : category_theory.limits.cone G	⊢ function.left_inverse (category_theory.limits.is_limit.of_right_adjoint h.functor) (λ (P : category_theory.limits.is_limit (h.functor.obj c)), (category_theory.limits.is_limit.of_right_adjoint h.inverse P).of_iso_limit (h.unit_iso.symm.app c))
J K : Type v,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.small_category K,	C : Type u,	_inst_3 : category_theory.category C,	F : J ⥤ C,	D : Type u',	_inst_4 : category_theory.category D,	G : K ⥤ D,	h : category_theory.limits.cone G ≌ category_theory.limits.cone F,	c : category_theory.limits.cone G	⊢ function.right_inverse (category_theory.limits.is_limit.of_right_adjoint h.functor) (λ (P : category_theory.limits.is_limit (h.functor.obj c)), (category_theory.limits.is_limit.of_right_adjoint h.inverse P).of_iso_limit (h.unit_iso.symm.app c))
S : Type v,	L : Type u₂,	D : Type u₃,	_inst_1 : category_theory.category S,	_inst_2 : category_theory.category L,	_inst_3 : category_theory.category D,	ι : S ⥤ L,	_inst_4 : category_theory.full ι,	_inst_5 : category_theory.faithful ι,	_inst_6 : ∀ (X : L), category_theory.limits.has_limits_of_shape (category_theory.structured_arrow X ι) D	⊢ category_theory.is_iso (category_theory.Ran.adjunction D ι).counit
S : Type v,	L : Type u₂,	D : Type u₃,	_inst_1 : category_theory.category S,	_inst_2 : category_theory.category L,	_inst_3 : category_theory.category D,	ι : S ⥤ L,	_inst_4 : category_theory.full ι,	_inst_5 : category_theory.faithful ι,	_inst_6 : ∀ (X : L), category_theory.limits.has_limits_of_shape (category_theory.structured_arrow X ι) D	⊢ ∀ (X : S ⥤ D), category_theory.is_iso ((category_theory.Ran.adjunction D ι).counit.app X)
S : Type v,	L : Type u₂,	D : Type u₃,	_inst_1 : category_theory.category S,	_inst_2 : category_theory.category L,	_inst_3 : category_theory.category D,	ι : S ⥤ L,	_inst_4 : category_theory.full ι,	_inst_5 : category_theory.faithful ι,	_inst_6 : ∀ (X : L), category_theory.limits.has_limits_of_shape (category_theory.structured_arrow X ι) D,	F : S ⥤ D	⊢ category_theory.is_iso ((category_theory.Ran.adjunction D ι).counit.app F)
S : Type v,	L : Type u₂,	D : Type u₃,	_inst_1 : category_theory.category S,	_inst_2 : category_theory.category L,	_inst_3 : category_theory.category D,	ι : S ⥤ L,	_inst_4 : category_theory.full ι,	_inst_5 : category_theory.faithful ι,	_inst_6 : ∀ (X : L), category_theory.limits.has_limits_of_shape (category_theory.structured_arrow X ι) D,	F : S ⥤ D	⊢ ∀ (X : S), category_theory.is_iso (((category_theory.Ran.adjunction D ι).counit.app F).app X)
S : Type v,	L : Type u₂,	D : Type u₃,	_inst_1 : category_theory.category S,	_inst_2 : category_theory.category L,	_inst_3 : category_theory.category D,	ι : S ⥤ L,	_inst_4 : category_theory.full ι,	_inst_5 : category_theory.faithful ι,	_inst_6 : ∀ (X : L), category_theory.limits.has_limits_of_shape (category_theory.structured_arrow X ι) D,	F : S ⥤ D,	X : S	⊢ category_theory.is_iso (((category_theory.Ran.adjunction D ι).counit.app F).app X)
S : Type v,	L : Type u₂,	D : Type u₃,	_inst_1 : category_theory.category S,	_inst_2 : category_theory.category L,	_inst_3 : category_theory.category D,	ι : S ⥤ L,	_inst_4 : category_theory.full ι,	_inst_5 : category_theory.faithful ι,	_inst_6 : ∀ (X : L), category_theory.limits.has_limits_of_shape (category_theory.structured_arrow X ι) D,	F : S ⥤ D,	X : S	⊢ category_theory.is_iso (𝟙 (category_theory.limits.limit (category_theory.Ran.diagram ι F (ι.obj X))) ≫ category_theory.limits.limit.π (category_theory.Ran.diagram ι F (ι.obj X)) (category_theory.structured_arrow.mk (𝟙 (ι.obj X))))
S : Type v,	L : Type u₂,	D : Type u₃,	_inst_1 : category_theory.category S,	_inst_2 : category_theory.category L,	_inst_3 : category_theory.category D,	ι : S ⥤ L,	_inst_4 : category_theory.full ι,	_inst_5 : category_theory.faithful ι,	_inst_6 : ∀ (X : L), category_theory.limits.has_limits_of_shape (category_theory.structured_arrow X ι) D,	F : S ⥤ D,	X : S	⊢ category_theory.is_iso (category_theory.limits.limit.π (category_theory.Ran.diagram ι F (ι.obj X)) (category_theory.structured_arrow.mk (𝟙 (ι.obj X))))
S : Type v,	L : Type u₂,	D : Type u₃,	_inst_1 : category_theory.category S,	_inst_2 : category_theory.category L,	_inst_3 : category_theory.category D,	ι : S ⥤ L,	F : S ⥤ D,	_inst_4 : ∀ (x : L), category_theory.limits.has_limit (category_theory.Ran.diagram ι F x)	⊢ ∀ (X : L), category_theory.limits.limit.pre (category_theory.Ran.diagram ι F X) (category_theory.structured_arrow.map (𝟙 X)) = 𝟙 (category_theory.limits.limit (category_theory.Ran.diagram ι F X))
S : Type v,	L : Type u₂,	D : Type u₃,	_inst_1 : category_theory.category S,	_inst_2 : category_theory.category L,	_inst_3 : category_theory.category D,	ι : S ⥤ L,	F : S ⥤ D,	_inst_4 : ∀ (x : L), category_theory.limits.has_limit (category_theory.Ran.diagram ι F x),	l : L	⊢ category_theory.limits.limit.pre (category_theory.Ran.diagram ι F l) (category_theory.structured_arrow.map (𝟙 l)) = 𝟙 (category_theory.limits.limit (category_theory.Ran.diagram ι F l))
S : Type v,	L : Type u₂,	D : Type u₃,	_inst_1 : category_theory.category S,	_inst_2 : category_theory.category L,	_inst_3 : category_theory.category D,	ι : S ⥤ L,	F : S ⥤ D,	_inst_4 : ∀ (x : L), category_theory.limits.has_limit (category_theory.Ran.diagram ι F x),	l : L,	j : category_theory.structured_arrow l ι	⊢ category_theory.limits.limit.pre (category_theory.Ran.diagram ι F l) (category_theory.structured_arrow.map (𝟙 l)) ≫ category_theory.limits.limit.π (category_theory.structured_arrow.map (𝟙 l) ⋙ category_theory.Ran.diagram ι F l) j = 𝟙 (category_theory.limits.limit (category_theory.Ran.diagram ι F l)) ≫ category_theory.limits.limit.π (category_theory.structured_arrow.map (𝟙 l) ⋙ category_theory.Ran.diagram ι F l) j
S : Type v,	L : Type u₂,	D : Type u₃,	_inst_1 : category_theory.category S,	_inst_2 : category_theory.category L,	_inst_3 : category_theory.category D,	ι : S ⥤ L,	F : S ⥤ D,	_inst_4 : ∀ (x : L), category_theory.limits.has_limit (category_theory.Ran.diagram ι F x),	l : L,	j : category_theory.structured_arrow l ι	⊢ category_theory.limits.limit.π (category_theory.Ran.diagram ι F l) ((category_theory.structured_arrow.map (𝟙 l)).obj j) = category_theory.limits.limit.π (category_theory.structured_arrow.map (𝟙 l) ⋙ category_theory.Ran.diagram ι F l) j
S : Type v,	L : Type u₂,	D : Type u₃,	_inst_1 : category_theory.category S,	_inst_2 : category_theory.category L,	_inst_3 : category_theory.category D,	ι : S ⥤ L,	F : S ⥤ D,	_inst_4 : ∀ (x : L), category_theory.limits.has_limit (category_theory.Ran.diagram ι F x),	l : L,	j : category_theory.structured_arrow l ι	⊢ (category_theory.structured_arrow.map (𝟙 l)).obj j = j
S : Type v,	L : Type u₂,	D : Type u₃,	_inst_1 : category_theory.category S,	_inst_2 : category_theory.category L,	_inst_3 : category_theory.category D,	ι : S ⥤ L,	F : S ⥤ D,	_inst_4 : ∀ (x : L), category_theory.limits.has_limit (category_theory.Ran.diagram ι F x)	⊢ ∀ {X Y Z : L} (f : X ⟶ Y) (g : Y ⟶ Z), category_theory.limits.limit.pre (category_theory.Ran.diagram ι F X) (category_theory.structured_arrow.map (f ≫ g)) = category_theory.limits.limit.pre (category_theory.Ran.diagram ι F X) (category_theory.structured_arrow.map f) ≫ category_theory.limits.limit.pre (category_theory.Ran.diagram ι F Y) (category_theory.structured_arrow.map g)
S : Type v,	L : Type u₂,	D : Type u₃,	_inst_1 : category_theory.category S,	_inst_2 : category_theory.category L,	_inst_3 : category_theory.category D,	ι : S ⥤ L,	F : S ⥤ D,	_inst_4 : ∀ (x : L), category_theory.limits.has_limit (category_theory.Ran.diagram ι F x),	x y z : L,	f : x ⟶ y,	g : y ⟶ z	⊢ category_theory.limits.limit.pre (category_theory.Ran.diagram ι F x) (category_theory.structured_arrow.map (f ≫ g)) = category_theory.limits.limit.pre (category_theory.Ran.diagram ι F x) (category_theory.structured_arrow.map f) ≫ category_theory.limits.limit.pre (category_theory.Ran.diagram ι F y) (category_theory.structured_arrow.map g)
S : Type v,	L : Type u₂,	D : Type u₃,	_inst_1 : category_theory.category S,	_inst_2 : category_theory.category L,	_inst_3 : category_theory.category D,	ι : S ⥤ L,	F : S ⥤ D,	_inst_4 : ∀ (x : L), category_theory.limits.has_limit (category_theory.Ran.diagram ι F x),	x y z : L,	f : x ⟶ y,	g : y ⟶ z,	j : category_theory.structured_arrow z ι	⊢ category_theory.limits.limit.pre (category_theory.Ran.diagram ι F x) (category_theory.structured_arrow.map (f ≫ g)) ≫ category_theory.limits.limit.π (category_theory.structured_arrow.map (f ≫ g) ⋙ category_theory.Ran.diagram ι F x) j = (category_theory.limits.limit.pre (category_theory.Ran.diagram ι F x) (category_theory.structured_arrow.map f) ≫ category_theory.limits.limit.pre (category_theory.Ran.diagram ι F y) (category_theory.structured_arrow.map g)) ≫ category_theory.limits.limit.π (category_theory.structured_arrow.map (f ≫ g) ⋙ category_theory.Ran.diagram ι F x) j
S : Type v,	L : Type u₂,	D : Type u₃,	_inst_1 : category_theory.category S,	_inst_2 : category_theory.category L,	_inst_3 : category_theory.category D,	ι : S ⥤ L,	F : S ⥤ D,	_inst_4 : ∀ (x : L), category_theory.limits.has_limit (category_theory.Ran.diagram ι F x),	x y z : L,	f : x ⟶ y,	g : y ⟶ z,	j : category_theory.structured_arrow z ι	⊢ category_theory.limits.limit.π (category_theory.Ran.diagram ι F x) ((category_theory.structured_arrow.map (f ≫ g)).obj j) = category_theory.limits.limit.π (category_theory.Ran.diagram ι F x) ((category_theory.structured_arrow.map g ⋙ category_theory.structured_arrow.map f).obj j)
S : Type v,	L : Type u₂,	D : Type u₃,	_inst_1 : category_theory.category S,	_inst_2 : category_theory.category L,	_inst_3 : category_theory.category D,	ι : S ⥤ L,	F : S ⥤ D,	_inst_4 : ∀ (x : L), category_theory.limits.has_limit (category_theory.Ran.diagram ι F x),	x y z : L,	f : x ⟶ y,	g : y ⟶ z,	j : category_theory.structured_arrow z ι	⊢ (category_theory.structured_arrow.map (f ≫ g)).obj j = (category_theory.structured_arrow.map g ⋙ category_theory.structured_arrow.map f).obj j
α : Type u,	_inst_2 : complete_lattice α,	J : Type u,	𝒥 : category_theory.small_category J	⊢ category_theory.limits.has_colimits_of_shape J α
C : Type u,	_inst_1 : category_theory.category C,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Cᵒᵖ,	_inst_3 : category_theory.limits.has_colimit F.left_op,	s : category_theory.limits.cone F,	j : J	⊢ (category_theory.limits.colimit.desc F.left_op (category_theory.limits.cocone_left_op_of_cone s)).op ≫ (category_theory.limits.cone_of_cocone_left_op (category_theory.limits.colimit.cocone F.left_op)).π.app j = s.π.app j
C : Type u,	_inst_1 : category_theory.category C,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Cᵒᵖ,	_inst_3 : category_theory.limits.has_colimit F.left_op,	s : category_theory.limits.cone F,	j : J	⊢ s.π.app (opposite.unop (opposite.op j)) = s.π.app j
C : Type u,	_inst_1 : category_theory.category C,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Cᵒᵖ,	_inst_3 : category_theory.limits.has_colimit F.left_op,	s : category_theory.limits.cone F,	m : s.X ⟶ (category_theory.limits.cone_of_cocone_left_op (category_theory.limits.colimit.cocone F.left_op)).X,	w : ∀ (j : J), m ≫ (category_theory.limits.cone_of_cocone_left_op (category_theory.limits.colimit.cocone F.left_op)).π.app j = s.π.app j	⊢ m = (category_theory.limits.colimit.desc F.left_op (category_theory.limits.cocone_left_op_of_cone s)).op
C : Type u,	_inst_1 : category_theory.category C,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Cᵒᵖ,	_inst_3 : category_theory.limits.has_colimit F.left_op,	s : category_theory.limits.cone F,	m : s.X ⟶ (category_theory.limits.cone_of_cocone_left_op (category_theory.limits.colimit.cocone F.left_op)).X,	w : ∀ (j : J), m ≫ (category_theory.limits.cone_of_cocone_left_op (category_theory.limits.colimit.cocone F.left_op)).π.app j = s.π.app j,	u : (∀ (j : Jᵒᵖ), (category_theory.limits.colimit.cocone F.left_op).ι.app j ≫ m.unop = (category_theory.limits.cocone_left_op_of_cone s).ι.app j) → m.unop = (category_theory.limits.colimit.is_colimit F.left_op).desc (category_theory.limits.cocone_left_op_of_cone s)	⊢ ∀ (j : Jᵒᵖ), (category_theory.limits.colimit.cocone F.left_op).ι.app j ≫ m.unop = (category_theory.limits.cocone_left_op_of_cone s).ι.app j
C : Type u,	_inst_1 : category_theory.category C,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Cᵒᵖ,	_inst_3 : category_theory.limits.has_colimit F.left_op,	s : category_theory.limits.cone F,	m : s.X ⟶ (category_theory.limits.cone_of_cocone_left_op (category_theory.limits.colimit.cocone F.left_op)).X,	w : ∀ (j : J), m ≫ (category_theory.limits.cone_of_cocone_left_op (category_theory.limits.colimit.cocone F.left_op)).π.app j = s.π.app j,	u : (∀ (j : Jᵒᵖ), (category_theory.limits.colimit.cocone F.left_op).ι.app j ≫ m.unop = (category_theory.limits.cocone_left_op_of_cone s).ι.app j) → m.unop = (category_theory.limits.colimit.is_colimit F.left_op).desc (category_theory.limits.cocone_left_op_of_cone s)	⊢ m = (category_theory.limits.colimit.desc F.left_op (category_theory.limits.cocone_left_op_of_cone s)).op
C : Type u,	_inst_1 : category_theory.category C,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Cᵒᵖ,	_inst_3 : category_theory.limits.has_colimit F.left_op,	s : category_theory.limits.cone F,	m : s.X ⟶ (category_theory.limits.cone_of_cocone_left_op (category_theory.limits.colimit.cocone F.left_op)).X,	w : ∀ (j : J), m ≫ (category_theory.limits.cone_of_cocone_left_op (category_theory.limits.colimit.cocone F.left_op)).π.app j = s.π.app j	⊢ ∀ (j : Jᵒᵖ), (category_theory.limits.colimit.cocone F.left_op).ι.app j ≫ m.unop = (category_theory.limits.cocone_left_op_of_cone s).ι.app j
C : Type u,	_inst_1 : category_theory.category C,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Cᵒᵖ,	_inst_3 : category_theory.limits.has_colimit F.left_op,	s : category_theory.limits.cone F,	m : s.X ⟶ (category_theory.limits.cone_of_cocone_left_op (category_theory.limits.colimit.cocone F.left_op)).X,	w : ∀ (j : J), m ≫ (category_theory.limits.cone_of_cocone_left_op (category_theory.limits.colimit.cocone F.left_op)).π.app j = s.π.app j,	j : Jᵒᵖ	⊢ (category_theory.limits.colimit.cocone F.left_op).ι.app j ≫ m.unop = (category_theory.limits.cocone_left_op_of_cone s).ι.app j
C : Type u,	_inst_1 : category_theory.category C,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Cᵒᵖ,	_inst_3 : category_theory.limits.has_colimit F.left_op,	s : category_theory.limits.cone F,	m : s.X ⟶ (category_theory.limits.cone_of_cocone_left_op (category_theory.limits.colimit.cocone F.left_op)).X,	w : ∀ (j : J), m ≫ (category_theory.limits.cone_of_cocone_left_op (category_theory.limits.colimit.cocone F.left_op)).π.app j = s.π.app j,	j : Jᵒᵖ	⊢ category_theory.limits.colimit.ι F.left_op j = ((category_theory.limits.cone_of_cocone_left_op (category_theory.limits.colimit.cocone F.left_op)).π.app (opposite.unop j)).unop
C : Type u,	_inst_1 : category_theory.category C,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Cᵒᵖ,	_inst_3 : category_theory.limits.has_colimit F.left_op,	s : category_theory.limits.cone F,	m : s.X ⟶ (category_theory.limits.cone_of_cocone_left_op (category_theory.limits.colimit.cocone F.left_op)).X,	w : ∀ (j : J), m ≫ (category_theory.limits.cone_of_cocone_left_op (category_theory.limits.colimit.cocone F.left_op)).π.app j = s.π.app j,	j : Jᵒᵖ	⊢ category_theory.limits.colimit.ι F.left_op j ≫ m.unop = (s.π.app (opposite.unop j)).unop
C : Type u,	_inst_1 : category_theory.category C,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Cᵒᵖ,	_inst_3 : category_theory.limits.has_colimit F.left_op,	s : category_theory.limits.cone F,	m : s.X ⟶ (category_theory.limits.cone_of_cocone_left_op (category_theory.limits.colimit.cocone F.left_op)).X,	j : Jᵒᵖ	⊢ category_theory.limits.colimit.ι F.left_op j = ((category_theory.limits.cone_of_cocone_left_op (category_theory.limits.colimit.cocone F.left_op)).π.app (opposite.unop j)).unop
C : Type u,	_inst_1 : category_theory.category C,	J : Type v,	_inst_2 : category_theory.small_category J,	F : J ⥤ Cᵒᵖ,	_inst_3 : category_theory.limits.has_colimit F.left_op,	s : category_theory.limits.cone F,	m : s.X ⟶ (category_theory.limits.cone_of_cocone_left_op (category_theory.limits.colimit.cocone F.left_op)).X,	j : Jᵒᵖ	⊢ category_theory.limits.colimit.ι F.left_op j = category_theory.limits.colimit.ι F.left_op (opposite.op (opposite.unop j))
C : Type u₁,	_inst_1 : category_theory.category C,	D : Type u₂,	_inst_2 : category_theory.category D,	J : Type v,	_inst_4 : category_theory.small_category J,	F : C ⥤ D	⊢ ∀ (a b : category_theory.limits.preserves_colimits_of_shape J F), a = b
C : Type u₁,	_inst_1 : category_theory.category C,	D : Type u₂,	_inst_2 : category_theory.category D,	J : Type v,	_inst_4 : category_theory.small_category J,	F : C ⥤ D,	a b : category_theory.limits.preserves_colimits_of_shape J F	⊢ a = b
C : Type u₁,	_inst_1 : category_theory.category C,	D : Type u₂,	_inst_2 : category_theory.category D,	J : Type v,	_inst_4 : category_theory.small_category J,	F : C ⥤ D,	b : category_theory.limits.preserves_colimits_of_shape J F,	a : auto_param (Π {K : J ⥤ C}, category_theory.limits.preserves_colimit K F) (name.mk_string "apply_instance" (name.mk_string "tactic" name.anonymous))	⊢ {preserves_colimit := a} = b
C : Type u₁,	_inst_1 : category_theory.category C,	D : Type u₂,	_inst_2 : category_theory.category D,	J : Type v,	_inst_4 : category_theory.small_category J,	F : C ⥤ D,	a b : auto_param (Π {K : J ⥤ C}, category_theory.limits.preserves_colimit K F) (name.mk_string "apply_instance" (name.mk_string "tactic" name.anonymous))	⊢ {preserves_colimit := a} = {preserves_colimit := b}
C : Type u₁,	_inst_1 : category_theory.category C,	D : Type u₂,	_inst_2 : category_theory.category D,	J : Type v,	_inst_4 : category_theory.small_category J,	F : C ⥤ D	⊢ subsingleton (category_theory.limits.preserves_colimits_of_shape J F)
C : Type u₁,	_inst_1 : category_theory.category C,	D : Type u₂,	_inst_2 : category_theory.category D,	J : Type v,	_inst_3 : category_theory.small_category J,	J' : Type v,	_inst_4 : category_theory.small_category J',	e : J ≌ J',	F : C ⥤ D,	_inst_5 : category_theory.limits.preserves_limits_of_shape J F,	K : J' ⥤ C,	c : category_theory.limits.cone K,	t : category_theory.limits.is_limit c	⊢ category_theory.limits.is_limit (F.map_cone c)
C : Type u₁,	_inst_1 : category_theory.category C,	D : Type u₂,	_inst_2 : category_theory.category D,	J : Type v,	_inst_3 : category_theory.small_category J,	J' : Type v,	_inst_4 : category_theory.small_category J',	e : J ≌ J',	F : C ⥤ D,	_inst_5 : category_theory.limits.preserves_limits_of_shape J F,	K : J' ⥤ C,	c : category_theory.limits.cone K,	t : category_theory.limits.is_limit c,	equ : e.inverse ⋙ e.functor ⋙ K ⋙ F ≅ K ⋙ F := e.inv_fun_id_assoc (K ⋙ F)	⊢ category_theory.limits.is_limit (F.map_cone c)
C : Type u₁,	_inst_1 : category_theory.category C,	D : Type u₂,	_inst_2 : category_theory.category D,	J : Type v,	_inst_3 : category_theory.small_category J,	J' : Type v,	_inst_4 : category_theory.small_category J',	e : J ≌ J',	F : C ⥤ D,	_inst_5 : category_theory.limits.preserves_limits_of_shape J F,	K : J' ⥤ C,	c : category_theory.limits.cone K,	t : category_theory.limits.is_limit c,	equ : e.inverse ⋙ e.functor ⋙ K ⋙ F ≅ K ⋙ F := e.inv_fun_id_assoc (K ⋙ F),	this : category_theory.limits.is_limit (category_theory.limits.cone.whisker e.symm.functor (F.map_cone (category_theory.limits.cone.whisker e.functor c)))	⊢ category_theory.limits.is_limit (F.map_cone c)
C : Type u₁,	_inst_1 : category_theory.category C,	D : Type u₂,	_inst_2 : category_theory.category D,	J : Type v,	_inst_3 : category_theory.small_category J,	J' : Type v,	_inst_4 : category_theory.small_category J',	e : J ≌ J',	F : C ⥤ D,	_inst_5 : category_theory.limits.preserves_limits_of_shape J F,	K : J' ⥤ C,	c : category_theory.limits.cone K,	t : category_theory.limits.is_limit c,	equ : e.inverse ⋙ e.functor ⋙ K ⋙ F ≅ K ⋙ F := e.inv_fun_id_assoc (K ⋙ F),	this : category_theory.limits.is_limit (category_theory.limits.cone.whisker e.symm.functor (F.map_cone (category_theory.limits.cone.whisker e.functor c)))	⊢ (category_theory.limits.cones.postcompose equ.hom).obj (category_theory.limits.cone.whisker e.symm.functor (F.map_cone (category_theory.limits.cone.whisker e.functor c))) ≅ F.map_cone c
C : Type u₁,	_inst_1 : category_theory.category C,	D : Type u₂,	_inst_2 : category_theory.category D,	J : Type v,	_inst_3 : category_theory.small_category J,	J' : Type v,	_inst_4 : category_theory.small_category J',	e : J ≌ J',	F : C ⥤ D,	_inst_5 : category_theory.limits.preserves_limits_of_shape J F,	K : J' ⥤ C,	c : category_theory.limits.cone K,	t : category_theory.limits.is_limit c,	equ : e.inverse ⋙ e.functor ⋙ K ⋙ F ≅ K ⋙ F := e.inv_fun_id_assoc (K ⋙ F),	this : category_theory.limits.is_limit (category_theory.limits.cone.whisker e.symm.functor (F.map_cone (category_theory.limits.cone.whisker e.functor c))),	j : J'	⊢ F.map (c.π.app (e.functor.obj (e.inverse.obj j))) ≫ equ.hom.app j = 𝟙 (F.obj c.X) ≫ F.map (c.π.app j)
C : Type u₁,	_inst_1 : category_theory.category C,	D : Type u₂,	_inst_2 : category_theory.category D,	J : Type v,	_inst_3 : category_theory.small_category J,	J' : Type v,	_inst_4 : category_theory.small_category J',	e : J ≌ J',	F : C ⥤ D,	_inst_5 : category_theory.limits.preserves_limits_of_shape J F,	K : J' ⥤ C,	c : category_theory.limits.cone K,	t : category_theory.limits.is_limit c,	equ : e.inverse ⋙ e.functor ⋙ K ⋙ F ≅ K ⋙ F := e.inv_fun_id_assoc (K ⋙ F),	this : category_theory.limits.is_limit (category_theory.limits.cone.whisker e.symm.functor (F.map_cone (category_theory.limits.cone.whisker e.functor c))),	j : J'	⊢ ((category_theory.limits.cones.postcompose equ.hom).obj (category_theory.limits.cone.whisker e.symm.functor (F.map_cone (category_theory.limits.cone.whisker e.functor c)))).π.app j = (category_theory.iso.refl ((category_theory.limits.cones.postcompose equ.hom).obj (category_theory.limits.cone.whisker e.symm.functor (F.map_cone (category_theory.limits.cone.whisker e.functor c)))).X).hom ≫ (F.map_cone c).π.app j
C : Type u₁,	_inst_1 : category_theory.category C,	D : Type u₂,	_inst_2 : category_theory.category D,	F G : C ⥤ D,	h : F ≅ G,	_inst_4 : category_theory.limits.preserves_colimits F,	J : Type v,	𝒥₁ : category_theory.small_category J	⊢ category_theory.limits.preserves_colimits_of_shape J G
C : Type u₁,	_inst_1 : category_theory.category C,	D : Type u₂,	_inst_2 : category_theory.category D,	F : C ⥤ D	⊢ ∀ (a b : category_theory.limits.reflects_limits F), a = b
C : Type u₁,	_inst_1 : category_theory.category C,	D : Type u₂,	_inst_2 : category_theory.category D,	F : C ⥤ D,	a b : category_theory.limits.reflects_limits F	⊢ a = b
C : Type u₁,	_inst_1 : category_theory.category C,	D : Type u₂,	_inst_2 : category_theory.category D,	F : C ⥤ D,	b : category_theory.limits.reflects_limits F,	a : auto_param (Π {J : Type v} [_inst_4 : category_theory.small_category J], category_theory.limits.reflects_limits_of_shape J F) (name.mk_string "apply_instance" (name.mk_string "tactic" name.anonymous))	⊢ {reflects_limits_of_shape := a} = b
C : Type u₁,	_inst_1 : category_theory.category C,	D : Type u₂,	_inst_2 : category_theory.category D,	F : C ⥤ D,	a b : auto_param (Π {J : Type v} [_inst_4 : category_theory.small_category J], category_theory.limits.reflects_limits_of_shape J F) (name.mk_string "apply_instance" (name.mk_string "tactic" name.anonymous))	⊢ {reflects_limits_of_shape := a} = {reflects_limits_of_shape := b}
C : Type u₁,	_inst_1 : category_theory.category C,	D : Type u₂,	_inst_2 : category_theory.category D,	F : C ⥤ D	⊢ subsingleton (category_theory.limits.reflects_limits F)
C : Type u₁,	_inst_1 : category_theory.category C,	D : Type u₂,	_inst_2 : category_theory.category D,	G : C ⥤ D,	J : Type v,	f : J → C,	_inst_3 : category_theory.limits.has_coproduct f,	_inst_4 : category_theory.limits.has_coproduct (λ (j : J), G.obj (f j)),	_inst_5 : category_theory.limits.preserves_colimit (category_theory.discrete.functor f) G	⊢ category_theory.is_iso (category_theory.limits.sigma_comparison G f)
C : Type u₁,	_inst_1 : category_theory.category C,	D : Type u₂,	_inst_2 : category_theory.category D,	G : C ⥤ D,	J : Type v,	f : J → C,	_inst_3 : category_theory.limits.has_coproduct f,	_inst_4 : category_theory.limits.has_coproduct (λ (j : J), G.obj (f j)),	_inst_5 : category_theory.limits.preserves_colimit (category_theory.discrete.functor f) G	⊢ category_theory.is_iso (category_theory.limits.preserves_coproduct.iso G f).inv
C : Type u₁,	_inst_1 : category_theory.small_category C,	P₁ P₂ : Cᵒᵖ ⥤ Type u₁,	α : P₁ ⟶ P₂,	j : (P₁.elements)ᵒᵖ	⊢ (category_theory.cocone_of_representable P₁).ι.app j ≫ α = (category_theory.cocone_of_representable P₂).ι.app ((category_theory.category_of_elements.map α).op.obj j)
C : Type u₁,	_inst_1 : category_theory.small_category C,	P₁ P₂ : Cᵒᵖ ⥤ Type u₁,	α : P₁ ⟶ P₂,	j : (P₁.elements)ᵒᵖ,	T : Cᵒᵖ,	f : ((category_theory.functor_to_representables P₁).obj j).obj T	⊢ ((category_theory.cocone_of_representable P₁).ι.app j ≫ α).app T f = ((category_theory.cocone_of_representable P₂).ι.app ((category_theory.category_of_elements.map α).op.obj j)).app T f
C : Type u,	_inst_1 : category_theory.category C,	X Y : C,	_inst_2 : category_theory.limits.has_binary_product Y Y,	f : X ⟶ Y	⊢ f ≫ category_theory.limits.diag Y = category_theory.limits.prod.lift f f
C : Type u,	_inst_1 : category_theory.category C,	X Y : C,	_inst_2 : category_theory.limits.has_binary_coproduct X Y	⊢ category_theory.limits.coprod.inl ≫ category_theory.limits.coprod.map (𝟙 X) (𝟙 Y) = category_theory.limits.coprod.inl ≫ 𝟙 (X ⨿ Y)
C : Type u,	_inst_1 : category_theory.category C,	X Y : C,	_inst_2 : category_theory.limits.has_binary_coproduct X Y	⊢ category_theory.limits.coprod.inr ≫ category_theory.limits.coprod.map (𝟙 X) (𝟙 Y) = category_theory.limits.coprod.inr ≫ 𝟙 (X ⨿ Y)
C : Type u,	_inst_1 : category_theory.category C,	X Y : C,	_inst_2 : category_theory.limits.has_binary_coproduct X Y	⊢ category_theory.limits.coprod.map (𝟙 X) (𝟙 Y) = 𝟙 (X ⨿ Y)
C : Type u,	_inst_1 : category_theory.category C,	X Y : C,	_inst_2 : category_theory.limits.has_binary_coproduct X Y	⊢ category_theory.limits.coprod.map (𝟙 X) (𝟙 Y) = 𝟙 (X ⨿ Y)
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.preadditive C,	X Y : C,	_inst_5 : category_theory.limits.has_binary_biproduct X Y	⊢ category_theory.limits.biprod.fst ≫ category_theory.limits.biprod.inl + category_theory.limits.biprod.snd ≫ category_theory.limits.biprod.inr = 𝟙 (X ⊞ Y)
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.preadditive C,	X Y : C,	_inst_5 : category_theory.limits.has_binary_biproduct X Y	⊢ category_theory.limits.biprod.fst ≫ category_theory.limits.biprod.inl + category_theory.limits.biprod.snd ≫ category_theory.limits.biprod.inr = 𝟙 (X ⊞ Y)
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.preadditive C,	X Y : C,	_inst_5 : category_theory.limits.has_binary_biproduct X Y	⊢ (category_theory.limits.biprod.inl ≫ (category_theory.limits.biprod.fst ≫ category_theory.limits.biprod.inl + category_theory.limits.biprod.snd ≫ category_theory.limits.biprod.inr)) ≫ category_theory.limits.biprod.fst = (category_theory.limits.biprod.inl ≫ 𝟙 (X ⊞ Y)) ≫ category_theory.limits.biprod.fst
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.preadditive C,	X Y : C,	_inst_5 : category_theory.limits.has_binary_biproduct X Y	⊢ (category_theory.limits.biprod.inl ≫ (category_theory.limits.biprod.fst ≫ category_theory.limits.biprod.inl + category_theory.limits.biprod.snd ≫ category_theory.limits.biprod.inr)) ≫ category_theory.limits.biprod.snd = (category_theory.limits.biprod.inl ≫ 𝟙 (X ⊞ Y)) ≫ category_theory.limits.biprod.snd
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.preadditive C,	X Y : C,	_inst_5 : category_theory.limits.has_binary_biproduct X Y	⊢ (category_theory.limits.biprod.inr ≫ (category_theory.limits.biprod.fst ≫ category_theory.limits.biprod.inl + category_theory.limits.biprod.snd ≫ category_theory.limits.biprod.inr)) ≫ category_theory.limits.biprod.fst = (category_theory.limits.biprod.inr ≫ 𝟙 (X ⊞ Y)) ≫ category_theory.limits.biprod.fst
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.preadditive C,	X Y : C,	_inst_5 : category_theory.limits.has_binary_biproduct X Y	⊢ (category_theory.limits.biprod.inr ≫ (category_theory.limits.biprod.fst ≫ category_theory.limits.biprod.inl + category_theory.limits.biprod.snd ≫ category_theory.limits.biprod.inr)) ≫ category_theory.limits.biprod.snd = (category_theory.limits.biprod.inr ≫ 𝟙 (X ⊞ Y)) ≫ category_theory.limits.biprod.snd
C : Type u,	_inst_2 : category_theory.category C,	_inst_3 : category_theory.limits.has_zero_morphisms C,	_inst_4 : category_theory.limits.has_binary_biproducts C,	W X Y Z : C,	f : W ⟶ Y,	g : X ⟶ Z	⊢ (category_theory.limits.biprod.braiding X W).hom ≫ category_theory.limits.biprod.map f g ≫ (category_theory.limits.biprod.braiding Y Z).hom = category_theory.limits.biprod.map g f
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.preadditive C,	_inst_5 : category_theory.limits.has_finite_coproducts C,	J : Type v,	_x : decidable_eq J,	_x : fintype J,	F : J → C	⊢ category_theory.limits.has_biproduct F
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.preadditive C,	J : Type v,	_inst_3 : decidable_eq J,	_inst_4 : fintype J,	f : J → C,	_inst_5 : category_theory.limits.has_biproduct f,	T U : C,	g : Π (j : J), T ⟶ f j,	h : Π (j : J), f j ⟶ U	⊢ category_theory.limits.biproduct.lift g ≫ category_theory.limits.biproduct.desc h = ∑ (j : J), g j ≫ h j
C : Type u,	_inst_1 : category_theory.category C,	X Y : C,	f g : X ⟶ Y,	s : category_theory.limits.fork f g	⊢ s.π.app category_theory.limits.walking_parallel_pair.zero ≫ g = s.π.app category_theory.limits.walking_parallel_pair.one
C : Type u,	_inst_1 : category_theory.category C,	X Y : C,	f g : X ⟶ Y,	h : f = g,	s : category_theory.limits.cofork f g,	m : (category_theory.limits.id_cofork h).X ⟶ s.X,	h : ∀ (j : category_theory.limits.walking_parallel_pair), (category_theory.limits.id_cofork h).ι.app j ≫ m = s.ι.app j	⊢ m = s.π
C : Type u,	_inst_1 : category_theory.category C,	X Y : C,	f g : X ⟶ Y,	h : f = g,	s : category_theory.limits.cofork f g,	m : (category_theory.limits.id_cofork h).X ⟶ s.X,	h : ∀ (j : category_theory.limits.walking_parallel_pair), (category_theory.limits.id_cofork h).ι.app j ≫ m = s.ι.app j	⊢ m = (category_theory.limits.id_cofork h).ι.app category_theory.limits.walking_parallel_pair.one ≫ m
J : Type v,	_inst_2 : decidable_eq J,	j j' : category_theory.limits.wide_pullback_shape J	⊢ finset (j ⟶ j')
J : Type v,	_inst_2 : decidable_eq J,	j : category_theory.limits.wide_pullback_shape J	⊢ finset (j ⟶ option.none)
J : Type v,	_inst_2 : decidable_eq J	⊢ finset (option.none ⟶ option.none)		case option.none, option.some	J : Type v,	_inst_2 : decidable_eq J,	j : J	⊢ finset (option.some j ⟶ option.none)
J : Type v,	_inst_2 : decidable_eq J	⊢ finset (option.none ⟶ option.none)
J : Type v,	_inst_2 : decidable_eq J,	j : category_theory.limits.wide_pullback_shape J	⊢ finset (j ⟶ option.none)		case option.some	J : Type v,	_inst_2 : decidable_eq J,	j : category_theory.limits.wide_pullback_shape J,	j' : J	⊢ finset (j ⟶ option.some j')
J : Type v,	_inst_2 : decidable_eq J,	j : J	⊢ finset (option.some j ⟶ option.none)
J : Type v,	_inst_2 : decidable_eq J,	j : category_theory.limits.wide_pullback_shape J,	j' : J	⊢ finset (j ⟶ option.some j')
J : Type v,	_inst_2 : decidable_eq J,	j : category_theory.limits.wide_pullback_shape J,	j' : J,	h : option.some j' = j	⊢ finset (j ⟶ option.some j')
J : Type v,	_inst_2 : decidable_eq J,	j : category_theory.limits.wide_pullback_shape J,	j' : J,	h : option.some j' = j	⊢ finset (j ⟶ option.some j')		J : Type v,	_inst_2 : decidable_eq J,	j : category_theory.limits.wide_pullback_shape J,	j' : J,	h : ¬option.some j' = j	⊢ finset (j ⟶ option.some j')
J : Type v,	_inst_2 : decidable_eq J,	j : category_theory.limits.wide_pullback_shape J,	j' : J,	h : option.some j' = j	⊢ finset (j ⟶ j)
J : Type v,	_inst_2 : decidable_eq J,	j : category_theory.limits.wide_pullback_shape J,	j' : J,	h : ¬option.some j' = j	⊢ finset (j ⟶ option.some j')
J : Type v,	_inst_2 : decidable_eq J,	j j' : category_theory.limits.wide_pullback_shape J	⊢ ∀ (x : j ⟶ j'), x ∈ option.cases_on j' (option.cases_on j {category_theory.limits.wide_pullback_shape.hom.id option.none} (λ (j : J), {category_theory.limits.wide_pullback_shape.hom.term j})) (λ (j' : J), dite (option.some j' = j) (λ (h : option.some j' = j), _.mpr {category_theory.limits.wide_pullback_shape.hom.id j}) (λ (h : ¬option.some j' = j), ∅))
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.limits.has_finite_wide_pullbacks C	⊢ category_theory.limits.has_pullbacks C
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.limits.has_finite_wide_pushouts C	⊢ category_theory.limits.has_pushouts C
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.limits.has_finite_limits C	⊢ category_theory.limits.has_equalizers C
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.limits.has_finite_colimits C	⊢ category_theory.limits.has_coequalizers C
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.limits.has_finite_limits C,	J : Type v,	𝒥₁ : decidable_eq J,	𝒥₂ : fintype J	⊢ category_theory.limits.has_limits_of_shape (category_theory.discrete J) C
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.limits.has_finite_limits C,	J : Type v,	𝒥₁ : decidable_eq J,	𝒥₂ : fintype J	⊢ category_theory.limits.has_limits_of_shape (category_theory.discrete J) C
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.limits.has_coproducts C	⊢ ∀ (J : Type v) [_inst_2 : decidable_eq J] [_inst_3 : fintype J], category_theory.limits.has_colimits_of_shape (category_theory.discrete J) C
C : Type u,	_inst_1 : category_theory.category C,	X Y : C,	f : X ⟶ Y,	_inst_2 : category_theory.limits.has_image f,	F' : category_theory.limits.mono_factorisation f,	l : category_theory.limits.image f ⟶ F'.I,	w : l ≫ F'.m = category_theory.limits.image.ι f	⊢ l ≫ F'.m = category_theory.limits.image.lift F' ≫ F'.m
C : Type u,	_inst_1 : category_theory.category C,	X Y : C,	f : X ⟶ Y,	_inst_2 : category_theory.limits.has_image f,	_inst_3 : category_theory.mono f	⊢ (category_theory.limits.image_mono_iso_source f).hom ≫ f = category_theory.limits.image.ι f = ?m_1
C : Type u,	_inst_1 : category_theory.category C,	X Y : C,	f : X ⟶ Y,	_inst_2 : category_theory.limits.has_image f,	_inst_3 : category_theory.mono f	⊢ (category_theory.limits.image_mono_iso_source f).hom ≫ f = ?m_1
C : Type u,	_inst_1 : category_theory.category C,	X Y : C,	f : X ⟶ Y,	_inst_2 : category_theory.limits.has_image f,	_inst_3 : category_theory.mono f	⊢ (category_theory.limits.image_mono_iso_source f).hom = ?m_1		C : Type u,	_inst_1 : category_theory.category C,	X Y : C,	f : X ⟶ Y,	_inst_2 : category_theory.limits.has_image f,	_inst_3 : category_theory.mono f	⊢ f = ?m_1
C : Type u,	_inst_1 : category_theory.category C,	X Y : C,	f : X ⟶ Y,	_inst_2 : category_theory.limits.has_image f,	_inst_3 : category_theory.mono f	⊢ f = ?m_1
C : Type u,	_inst_1 : category_theory.category C,	X Y : C,	f : X ⟶ Y,	_inst_2 : category_theory.limits.has_image f,	_inst_3 : category_theory.mono f	⊢ (category_theory.limits.image_mono_iso_source f).hom ≫ f = category_theory.limits.image.ι f
C : Type u,	_inst_1 : category_theory.category C,	X Y : C,	f : X ⟶ Y,	_inst_2 : category_theory.limits.has_image f,	_inst_3 : category_theory.mono f	⊢ (category_theory.limits.image_mono_iso_source f).hom ≫ (category_theory.limits.image_mono_iso_source f).inv ≫ category_theory.limits.image.ι f = category_theory.limits.image.ι f
C : Type u,	_inst_1 : category_theory.category C,	X Y : C,	f : X ⟶ Y,	_inst_2 : category_theory.limits.has_image f	⊢ category_theory.limits.has_image f
C : Type u,	_inst_1 : category_theory.category C,	R X Y Z : C,	a b : R ⟶ X,	f₁ : X ⟶ Y,	f₂ : Y ⟶ Z,	_inst_2 : category_theory.mono f₂,	small_k : category_theory.is_kernel_pair f₁ a b	⊢ a ≫ f₁ ≫ f₂ = b ≫ f₁ ≫ f₂
C : Type u,	_inst_1 : category_theory.category C,	R X Y Z : C,	a b : R ⟶ X,	f₁ : X ⟶ Y,	f₂ : Y ⟶ Z,	_inst_2 : category_theory.mono f₂,	small_k : category_theory.is_kernel_pair f₁ a b,	s : category_theory.limits.pullback_cone (f₁ ≫ f₂) (f₁ ≫ f₂)	⊢ {l // l ≫ (category_theory.limits.pullback_cone.mk a b _).fst = s.fst ∧ l ≫ (category_theory.limits.pullback_cone.mk a b _).snd = s.snd ∧ ∀ {m : s.X ⟶ (category_theory.limits.pullback_cone.mk a b _).X}, m ≫ (category_theory.limits.pullback_cone.mk a b _).fst = s.fst → m ≫ (category_theory.limits.pullback_cone.mk a b _).snd = s.snd → m = l}
C : Type u,	_inst_1 : category_theory.category C,	R X Y Z : C,	a b : R ⟶ X,	f₁ : X ⟶ Y,	f₂ : Y ⟶ Z,	_inst_2 : category_theory.mono f₂,	small_k : category_theory.is_kernel_pair f₁ a b,	s : category_theory.limits.pullback_cone (f₁ ≫ f₂) (f₁ ≫ f₂)	⊢ s.X ⟶ (category_theory.limits.pullback_cone.mk a b _).X		C : Type u,	_inst_1 : category_theory.category C,	R X Y Z : C,	a b : R ⟶ X,	f₁ : X ⟶ Y,	f₂ : Y ⟶ Z,	_inst_2 : category_theory.mono f₂,	small_k : category_theory.is_kernel_pair f₁ a b,	s : category_theory.limits.pullback_cone (f₁ ≫ f₂) (f₁ ≫ f₂)	⊢ ?m_1 ≫ (category_theory.limits.pullback_cone.mk a b _).fst = s.fst		C : Type u,	_inst_1 : category_theory.category C,	R X Y Z : C,	a b : R ⟶ X,	f₁ : X ⟶ Y,	f₂ : Y ⟶ Z,	_inst_2 : category_theory.mono f₂,	small_k : category_theory.is_kernel_pair f₁ a b,	s : category_theory.limits.pullback_cone (f₁ ≫ f₂) (f₁ ≫ f₂)	⊢ ?m_1 ≫ (category_theory.limits.pullback_cone.mk a b _).snd = s.snd		C : Type u,	_inst_1 : category_theory.category C,	R X Y Z : C,	a b : R ⟶ X,	f₁ : X ⟶ Y,	f₂ : Y ⟶ Z,	_inst_2 : category_theory.mono f₂,	small_k : category_theory.is_kernel_pair f₁ a b,	s : category_theory.limits.pullback_cone (f₁ ≫ f₂) (f₁ ≫ f₂)	⊢ ∀ {m : s.X ⟶ (category_theory.limits.pullback_cone.mk a b _).X}, m ≫ (category_theory.limits.pullback_cone.mk a b _).fst = s.fst → m ≫ (category_theory.limits.pullback_cone.mk a b _).snd = s.snd → m = ?m_1
C : Type u,	_inst_1 : category_theory.category C,	R X Y Z : C,	a b : R ⟶ X,	f₁ : X ⟶ Y,	f₂ : Y ⟶ Z,	_inst_2 : category_theory.mono f₂,	small_k : category_theory.is_kernel_pair f₁ a b,	s : category_theory.limits.pullback_cone (f₁ ≫ f₂) (f₁ ≫ f₂)	⊢ s.fst ≫ f₁ = s.snd ≫ f₁		C : Type u,	_inst_1 : category_theory.category C,	R X Y Z : C,	a b : R ⟶ X,	f₁ : X ⟶ Y,	f₂ : Y ⟶ Z,	_inst_2 : category_theory.mono f₂,	small_k : category_theory.is_kernel_pair f₁ a b,	s : category_theory.limits.pullback_cone (f₁ ≫ f₂) (f₁ ≫ f₂)	⊢ (category_theory.limits.pullback_cone.is_limit.lift' small_k.is_limit s.fst s.snd ?m_1).val ≫ (category_theory.limits.pullback_cone.mk a b _).fst = s.fst		C : Type u,	_inst_1 : category_theory.category C,	R X Y Z : C,	a b : R ⟶ X,	f₁ : X ⟶ Y,	f₂ : Y ⟶ Z,	_inst_2 : category_theory.mono f₂,	small_k : category_theory.is_kernel_pair f₁ a b,	s : category_theory.limits.pullback_cone (f₁ ≫ f₂) (f₁ ≫ f₂)	⊢ (category_theory.limits.pullback_cone.is_limit.lift' small_k.is_limit s.fst s.snd ?m_1).val ≫ (category_theory.limits.pullback_cone.mk a b _).snd = s.snd		C : Type u,	_inst_1 : category_theory.category C,	R X Y Z : C,	a b : R ⟶ X,	f₁ : X ⟶ Y,	f₂ : Y ⟶ Z,	_inst_2 : category_theory.mono f₂,	small_k : category_theory.is_kernel_pair f₁ a b,	s : category_theory.limits.pullback_cone (f₁ ≫ f₂) (f₁ ≫ f₂)	⊢ ∀ {m : s.X ⟶ (category_theory.limits.pullback_cone.mk a b _).X}, m ≫ (category_theory.limits.pullback_cone.mk a b _).fst = s.fst → m ≫ (category_theory.limits.pullback_cone.mk a b _).snd = s.snd → m = (category_theory.limits.pullback_cone.is_limit.lift' small_k.is_limit s.fst s.snd ?m_1).val
C : Type u,	_inst_1 : category_theory.category C,	R X Y Z : C,	a b : R ⟶ X,	f₁ : X ⟶ Y,	f₂ : Y ⟶ Z,	_inst_2 : category_theory.mono f₂,	small_k : category_theory.is_kernel_pair f₁ a b,	s : category_theory.limits.pullback_cone (f₁ ≫ f₂) (f₁ ≫ f₂)	⊢ (category_theory.limits.pullback_cone.is_limit.lift' small_k.is_limit s.fst s.snd _).val ≫ (category_theory.limits.pullback_cone.mk a b _).fst = s.fst		C : Type u,	_inst_1 : category_theory.category C,	R X Y Z : C,	a b : R ⟶ X,	f₁ : X ⟶ Y,	f₂ : Y ⟶ Z,	_inst_2 : category_theory.mono f₂,	small_k : category_theory.is_kernel_pair f₁ a b,	s : category_theory.limits.pullback_cone (f₁ ≫ f₂) (f₁ ≫ f₂)	⊢ (category_theory.limits.pullback_cone.is_limit.lift' small_k.is_limit s.fst s.snd _).val ≫ (category_theory.limits.pullback_cone.mk a b _).snd = s.snd		C : Type u,	_inst_1 : category_theory.category C,	R X Y Z : C,	a b : R ⟶ X,	f₁ : X ⟶ Y,	f₂ : Y ⟶ Z,	_inst_2 : category_theory.mono f₂,	small_k : category_theory.is_kernel_pair f₁ a b,	s : category_theory.limits.pullback_cone (f₁ ≫ f₂) (f₁ ≫ f₂)	⊢ ∀ {m : s.X ⟶ (category_theory.limits.pullback_cone.mk a b _).X}, m ≫ (category_theory.limits.pullback_cone.mk a b _).fst = s.fst → m ≫ (category_theory.limits.pullback_cone.mk a b _).snd = s.snd → m = (category_theory.limits.pullback_cone.is_limit.lift' small_k.is_limit s.fst s.snd _).val
C : Type u,	_inst_1 : category_theory.category C,	R X Y Z : C,	a b : R ⟶ X,	f₁ : X ⟶ Y,	f₂ : Y ⟶ Z,	_inst_2 : category_theory.mono f₂,	small_k : category_theory.is_kernel_pair f₁ a b,	s : category_theory.limits.pullback_cone (f₁ ≫ f₂) (f₁ ≫ f₂)	⊢ (category_theory.limits.pullback_cone.is_limit.lift' small_k.is_limit s.fst s.snd _).val ≫ (category_theory.limits.pullback_cone.mk a b _).snd = s.snd		C : Type u,	_inst_1 : category_theory.category C,	R X Y Z : C,	a b : R ⟶ X,	f₁ : X ⟶ Y,	f₂ : Y ⟶ Z,	_inst_2 : category_theory.mono f₂,	small_k : category_theory.is_kernel_pair f₁ a b,	s : category_theory.limits.pullback_cone (f₁ ≫ f₂) (f₁ ≫ f₂)	⊢ ∀ {m : s.X ⟶ (category_theory.limits.pullback_cone.mk a b _).X}, m ≫ (category_theory.limits.pullback_cone.mk a b _).fst = s.fst → m ≫ (category_theory.limits.pullback_cone.mk a b _).snd = s.snd → m = (category_theory.limits.pullback_cone.is_limit.lift' small_k.is_limit s.fst s.snd _).val
C : Type u,	_inst_1 : category_theory.category C,	R X Y Z : C,	a b : R ⟶ X,	f₁ : X ⟶ Y,	f₂ : Y ⟶ Z,	_inst_2 : category_theory.mono f₂,	small_k : category_theory.is_kernel_pair f₁ a b,	s : category_theory.limits.pullback_cone (f₁ ≫ f₂) (f₁ ≫ f₂)	⊢ ∀ {m : s.X ⟶ (category_theory.limits.pullback_cone.mk a b _).X}, m ≫ (category_theory.limits.pullback_cone.mk a b _).fst = s.fst → m ≫ (category_theory.limits.pullback_cone.mk a b _).snd = s.snd → m = (category_theory.limits.pullback_cone.is_limit.lift' small_k.is_limit s.fst s.snd _).val
C : Type u,	_inst_1 : category_theory.category C,	R X Y Z : C,	a b : R ⟶ X,	f₁ : X ⟶ Y,	f₂ : Y ⟶ Z,	_inst_2 : category_theory.mono f₂,	small_k : category_theory.is_kernel_pair f₁ a b,	s : category_theory.limits.pullback_cone (f₁ ≫ f₂) (f₁ ≫ f₂),	m : s.X ⟶ (category_theory.limits.pullback_cone.mk a b _).X,	m₁ : m ≫ (category_theory.limits.pullback_cone.mk a b _).fst = s.fst,	m₂ : m ≫ (category_theory.limits.pullback_cone.mk a b _).snd = s.snd	⊢ m = (category_theory.limits.pullback_cone.is_limit.lift' small_k.is_limit s.fst s.snd _).val
C : Type u,	_inst_1 : category_theory.category C,	R X Y Z : C,	a b : R ⟶ X,	f₁ : X ⟶ Y,	f₂ : Y ⟶ Z,	_inst_2 : category_theory.mono f₂,	small_k : category_theory.is_kernel_pair f₁ a b,	s : category_theory.limits.pullback_cone (f₁ ≫ f₂) (f₁ ≫ f₂),	m : s.X ⟶ (category_theory.limits.pullback_cone.mk a b _).X,	m₁ : m ≫ (category_theory.limits.pullback_cone.mk a b _).fst = s.fst,	m₂ : m ≫ (category_theory.limits.pullback_cone.mk a b _).snd = s.snd	⊢ ∀ (j : category_theory.limits.walking_cospan), m ≫ (category_theory.limits.pullback_cone.mk a b _).π.app j = (category_theory.limits.pullback_cone.is_limit.lift' small_k.is_limit s.fst s.snd _).val ≫ (category_theory.limits.pullback_cone.mk a b _).π.app j
C : Type u,	_inst_1 : category_theory.category C,	R X Y Z : C,	a b : R ⟶ X,	f₁ : X ⟶ Y,	f₂ : Y ⟶ Z,	_inst_2 : category_theory.mono f₂,	small_k : category_theory.is_kernel_pair f₁ a b,	s : category_theory.limits.pullback_cone (f₁ ≫ f₂) (f₁ ≫ f₂),	m : s.X ⟶ (category_theory.limits.pullback_cone.mk a b _).X,	m₁ : m ≫ (category_theory.limits.pullback_cone.mk a b _).fst = s.fst,	m₂ : m ≫ (category_theory.limits.pullback_cone.mk a b _).snd = s.snd	⊢ m ≫ (category_theory.limits.pullback_cone.mk a b _).fst = (category_theory.limits.pullback_cone.is_limit.lift' small_k.is_limit s.fst s.snd _).val ≫ (category_theory.limits.pullback_cone.mk a b _).fst		C : Type u,	_inst_1 : category_theory.category C,	R X Y Z : C,	a b : R ⟶ X,	f₁ : X ⟶ Y,	f₂ : Y ⟶ Z,	_inst_2 : category_theory.mono f₂,	small_k : category_theory.is_kernel_pair f₁ a b,	s : category_theory.limits.pullback_cone (f₁ ≫ f₂) (f₁ ≫ f₂),	m : s.X ⟶ (category_theory.limits.pullback_cone.mk a b _).X,	m₁ : m ≫ (category_theory.limits.pullback_cone.mk a b _).fst = s.fst,	m₂ : m ≫ (category_theory.limits.pullback_cone.mk a b _).snd = s.snd	⊢ m ≫ (category_theory.limits.pullback_cone.mk a b _).snd = (category_theory.limits.pullback_cone.is_limit.lift' small_k.is_limit s.fst s.snd _).val ≫ (category_theory.limits.pullback_cone.mk a b _).snd
C : Type u,	_inst_1 : category_theory.category C,	R X Y Z : C,	a b : R ⟶ X,	f₁ : X ⟶ Y,	f₂ : Y ⟶ Z,	_inst_2 : category_theory.mono f₂,	small_k : category_theory.is_kernel_pair f₁ a b,	s : category_theory.limits.pullback_cone (f₁ ≫ f₂) (f₁ ≫ f₂),	m : s.X ⟶ (category_theory.limits.pullback_cone.mk a b _).X,	m₁ : m ≫ (category_theory.limits.pullback_cone.mk a b _).fst = s.fst,	m₂ : m ≫ (category_theory.limits.pullback_cone.mk a b _).snd = s.snd	⊢ m ≫ (category_theory.limits.pullback_cone.mk a b _).snd = (category_theory.limits.pullback_cone.is_limit.lift' small_k.is_limit s.fst s.snd _).val ≫ (category_theory.limits.pullback_cone.mk a b _).snd
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.limits.has_zero_morphisms C,	X Y : C,	f : X ⟶ Y,	t : category_theory.limits.kernel_fork f,	lift : Π (s : category_theory.limits.kernel_fork f), s.X ⟶ t.X,	fac : ∀ (s : category_theory.limits.kernel_fork f), lift s ≫ category_theory.limits.fork.ι t = category_theory.limits.fork.ι s,	uniq : ∀ (s : category_theory.limits.kernel_fork f) (m : s.X ⟶ t.X), m ≫ category_theory.limits.fork.ι t = category_theory.limits.fork.ι s → m = lift s,	s : category_theory.limits.cone (category_theory.limits.parallel_pair f 0),	j : category_theory.limits.walking_parallel_pair	⊢ lift s ≫ t.π.app j = s.π.app j
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.limits.has_zero_morphisms C,	X Y : C,	f : X ⟶ Y,	t : category_theory.limits.kernel_fork f,	lift : Π (s : category_theory.limits.kernel_fork f), s.X ⟶ t.X,	fac : ∀ (s : category_theory.limits.kernel_fork f), lift s ≫ category_theory.limits.fork.ι t = category_theory.limits.fork.ι s,	uniq : ∀ (s : category_theory.limits.kernel_fork f) (m : s.X ⟶ t.X), m ≫ category_theory.limits.fork.ι t = category_theory.limits.fork.ι s → m = lift s,	s : category_theory.limits.cone (category_theory.limits.parallel_pair f 0)	⊢ lift s ≫ t.π.app category_theory.limits.walking_parallel_pair.zero = s.π.app category_theory.limits.walking_parallel_pair.zero
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.limits.has_zero_morphisms C,	X Y : C,	f : X ⟶ Y,	t : category_theory.limits.kernel_fork f,	lift : Π (s : category_theory.limits.kernel_fork f), s.X ⟶ t.X,	fac : ∀ (s : category_theory.limits.kernel_fork f), lift s ≫ category_theory.limits.fork.ι t = category_theory.limits.fork.ι s,	uniq : ∀ (s : category_theory.limits.kernel_fork f) (m : s.X ⟶ t.X), m ≫ category_theory.limits.fork.ι t = category_theory.limits.fork.ι s → m = lift s,	s : category_theory.limits.cone (category_theory.limits.parallel_pair f 0)	⊢ lift s ≫ t.π.app category_theory.limits.walking_parallel_pair.zero = s.π.app category_theory.limits.walking_parallel_pair.zero		case category_theory.limits.walking_parallel_pair.one	C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.limits.has_zero_morphisms C,	X Y : C,	f : X ⟶ Y,	t : category_theory.limits.kernel_fork f,	lift : Π (s : category_theory.limits.kernel_fork f), s.X ⟶ t.X,	fac : ∀ (s : category_theory.limits.kernel_fork f), lift s ≫ category_theory.limits.fork.ι t = category_theory.limits.fork.ι s,	uniq : ∀ (s : category_theory.limits.kernel_fork f) (m : s.X ⟶ t.X), m ≫ category_theory.limits.fork.ι t = category_theory.limits.fork.ι s → m = lift s,	s : category_theory.limits.cone (category_theory.limits.parallel_pair f 0)	⊢ lift s ≫ t.π.app category_theory.limits.walking_parallel_pair.one = s.π.app category_theory.limits.walking_parallel_pair.one
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.limits.has_zero_morphisms C,	X Y : C,	f : X ⟶ Y,	t : category_theory.limits.kernel_fork f,	lift : Π (s : category_theory.limits.kernel_fork f), s.X ⟶ t.X,	fac : ∀ (s : category_theory.limits.kernel_fork f), lift s ≫ category_theory.limits.fork.ι t = category_theory.limits.fork.ι s,	uniq : ∀ (s : category_theory.limits.kernel_fork f) (m : s.X ⟶ t.X), m ≫ category_theory.limits.fork.ι t = category_theory.limits.fork.ι s → m = lift s,	s : category_theory.limits.cone (category_theory.limits.parallel_pair f 0)	⊢ lift s ≫ t.π.app category_theory.limits.walking_parallel_pair.one = s.π.app category_theory.limits.walking_parallel_pair.one
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.limits.has_zero_morphisms C,	X Y : C,	f : X ⟶ Y,	s : category_theory.limits.cokernel_cofork f	⊢ f ≫ category_theory.limits.cofork.π s = 0
C : Type u,	_inst_1 : category_theory.category C,	P Q : C,	f : P ⟶ Q,	_inst_2 : category_theory.is_iso f	⊢ category_theory.epi f
C : Type u,	_inst_1 : category_theory.category C,	P Q : C,	f : P ⟶ Q,	_inst_2 : category_theory.is_iso f,	X Y : C,	u : P ⟶ X,	v : Q ⟶ Y,	z : X ⟶ Y,	_x : category_theory.mono z,	h : u ≫ z = f ≫ v	⊢ auto_param ((category_theory.arrow.mk f).hom ≫ category_theory.inv f ≫ u = (category_theory.arrow.hom_mk' h).left) (name.mk_string "obviously" name.anonymous)
C : Type u,	_inst_1 : category_theory.category C,	P Q : C,	f : P ⟶ Q,	_inst_2 : category_theory.is_iso f,	X Y : C,	u : P ⟶ X,	v : Q ⟶ Y,	z : X ⟶ Y,	_x : category_theory.mono z,	h : u ≫ z = f ≫ v	⊢ auto_param ((category_theory.inv f ≫ u) ≫ (category_theory.arrow.mk z).hom = (category_theory.arrow.hom_mk' h).right) (name.mk_string "obviously" name.anonymous)
C : Type u,	_inst_1 : category_theory.category C,	J : Type v,	_inst_2 : category_theory.small_category J,	X : J,	tX : category_theory.limits.is_terminal X,	F : J ⥤ C,	j j' : J,	k : j ⟶ j'	⊢ F.map k ≫ F.map (tX.from j') = F.map (tX.from j) ≫ ((category_theory.functor.const J).obj (F.obj X)).map k
C : Type u,	_inst_1 : category_theory.category C,	J : Type v,	_inst_2 : category_theory.small_category J,	X : J,	tX : category_theory.limits.is_terminal X,	F : J ⥤ C,	j j' : J,	k : j ⟶ j'	⊢ F.map k ≫ F.map (tX.from j') = F.map (tX.from j) ≫ 𝟙 (F.obj X)
X Y Z : Type u,	f : X ⟶ Y,	g h : Y ⟶ Z,	w : f ≫ g = f ≫ h,	t : ∀ (y : Y), g y = h y → (∃! (x : X), f x = y),	s : category_theory.limits.fork g h	⊢ {l // l ≫ (category_theory.limits.fork.of_ι f w).ι = s.ι ∧ ∀ {m : ((category_theory.functor.const category_theory.limits.walking_parallel_pair).obj s.X).obj category_theory.limits.walking_parallel_pair.zero ⟶ ((category_theory.functor.const category_theory.limits.walking_parallel_pair).obj (category_theory.limits.fork.of_ι f w).X).obj category_theory.limits.walking_parallel_pair.zero}, m ≫ (category_theory.limits.fork.of_ι f w).ι = s.ι → m = l}
X Y Z : Type u,	f : X ⟶ Y,	g h : Y ⟶ Z,	w : f ≫ g = f ≫ h,	t : ∀ (y : Y), g y = h y → (∃! (x : X), f x = y),	s : category_theory.limits.fork g h,	i : ((category_theory.functor.const category_theory.limits.walking_parallel_pair).obj s.X).obj category_theory.limits.walking_parallel_pair.zero	⊢ ((category_theory.functor.const category_theory.limits.walking_parallel_pair).obj (category_theory.limits.fork.of_ι f w).X).obj category_theory.limits.walking_parallel_pair.zero
X Y Z : Type u,	f : X ⟶ Y,	g h : Y ⟶ Z,	w : f ≫ g = f ≫ h,	t : ∀ (y : Y), g y = h y → (∃! (x : X), f x = y),	s : category_theory.limits.fork g h,	i : ((category_theory.functor.const category_theory.limits.walking_parallel_pair).obj s.X).obj category_theory.limits.walking_parallel_pair.zero	⊢ ((category_theory.functor.const category_theory.limits.walking_parallel_pair).obj (category_theory.limits.fork.of_ι f w).X).obj category_theory.limits.walking_parallel_pair.zero		X Y Z : Type u,	f : X ⟶ Y,	g h : Y ⟶ Z,	w : f ≫ g = f ≫ h,	t : ∀ (y : Y), g y = h y → (∃! (x : X), f x = y),	s : category_theory.limits.fork g h	⊢ (λ (i : ((category_theory.functor.const category_theory.limits.walking_parallel_pair).obj s.X).obj category_theory.limits.walking_parallel_pair.zero), ?m_1[i]) ≫ (category_theory.limits.fork.of_ι f w).ι = s.ι		X Y Z : Type u,	f : X ⟶ Y,	g h : Y ⟶ Z,	w : f ≫ g = f ≫ h,	t : ∀ (y : Y), g y = h y → (∃! (x : X), f x = y),	s : category_theory.limits.fork g h	⊢ ∀ {m : ((category_theory.functor.const category_theory.limits.walking_parallel_pair).obj s.X).obj category_theory.limits.walking_parallel_pair.zero ⟶ ((category_theory.functor.const category_theory.limits.walking_parallel_pair).obj (category_theory.limits.fork.of_ι f w).X).obj category_theory.limits.walking_parallel_pair.zero}, m ≫ (category_theory.limits.fork.of_ι f w).ι = s.ι → (m = λ (i : ((category_theory.functor.const category_theory.limits.walking_parallel_pair).obj s.X).obj category_theory.limits.walking_parallel_pair.zero), ?m_1[i])
X Y Z : Type u,	f : X ⟶ Y,	g h : Y ⟶ Z,	w : f ≫ g = f ≫ h,	t : ∀ (y : Y), g y = h y → (∃! (x : X), f x = y),	s : category_theory.limits.fork g h,	i : ((category_theory.functor.const category_theory.limits.walking_parallel_pair).obj s.X).obj category_theory.limits.walking_parallel_pair.zero	⊢ g (s.ι i) = h (s.ι i)
X Y Z : Type u,	f : X ⟶ Y,	g h : Y ⟶ Z,	w : f ≫ g = f ≫ h,	t : ∀ (y : Y), g y = h y → (∃! (x : X), f x = y),	s : category_theory.limits.fork g h	⊢ (λ (i : ((category_theory.functor.const category_theory.limits.walking_parallel_pair).obj s.X).obj category_theory.limits.walking_parallel_pair.zero), classical.some _) ≫ (category_theory.limits.fork.of_ι f w).ι = s.ι
X Y Z : Type u,	f : X ⟶ Y,	g h : Y ⟶ Z,	w : f ≫ g = f ≫ h,	t : ∀ (y : Y), g y = h y → (∃! (x : X), f x = y),	s : category_theory.limits.fork g h	⊢ (λ (i : ((category_theory.functor.const category_theory.limits.walking_parallel_pair).obj s.X).obj category_theory.limits.walking_parallel_pair.zero), classical.some _) ≫ (category_theory.limits.fork.of_ι f w).ι = s.ι		X Y Z : Type u,	f : X ⟶ Y,	g h : Y ⟶ Z,	w : f ≫ g = f ≫ h,	t : ∀ (y : Y), g y = h y → (∃! (x : X), f x = y),	s : category_theory.limits.fork g h	⊢ ∀ {m : ((category_theory.functor.const category_theory.limits.walking_parallel_pair).obj s.X).obj category_theory.limits.walking_parallel_pair.zero ⟶ ((category_theory.functor.const category_theory.limits.walking_parallel_pair).obj (category_theory.limits.fork.of_ι f w).X).obj category_theory.limits.walking_parallel_pair.zero}, m ≫ (category_theory.limits.fork.of_ι f w).ι = s.ι → (m = λ (i : ((category_theory.functor.const category_theory.limits.walking_parallel_pair).obj s.X).obj category_theory.limits.walking_parallel_pair.zero), classical.some _)
X Y Z : Type u,	f : X ⟶ Y,	g h : Y ⟶ Z,	w : f ≫ g = f ≫ h,	t : ∀ (y : Y), g y = h y → (∃! (x : X), f x = y),	s : category_theory.limits.fork g h,	i : ((category_theory.functor.const category_theory.limits.walking_parallel_pair).obj s.X).obj category_theory.limits.walking_parallel_pair.zero	⊢ ((λ (i : ((category_theory.functor.const category_theory.limits.walking_parallel_pair).obj s.X).obj category_theory.limits.walking_parallel_pair.zero), classical.some _) ≫ (category_theory.limits.fork.of_ι f w).ι) i = s.ι i
X Y Z : Type u,	f : X ⟶ Y,	g h : Y ⟶ Z,	w : f ≫ g = f ≫ h,	t : ∀ (y : Y), g y = h y → (∃! (x : X), f x = y),	s : category_theory.limits.fork g h	⊢ ∀ {m : ((category_theory.functor.const category_theory.limits.walking_parallel_pair).obj s.X).obj category_theory.limits.walking_parallel_pair.zero ⟶ ((category_theory.functor.const category_theory.limits.walking_parallel_pair).obj (category_theory.limits.fork.of_ι f w).X).obj category_theory.limits.walking_parallel_pair.zero}, m ≫ (category_theory.limits.fork.of_ι f w).ι = s.ι → (m = λ (i : ((category_theory.functor.const category_theory.limits.walking_parallel_pair).obj s.X).obj category_theory.limits.walking_parallel_pair.zero), classical.some _)
X Y Z : Type u,	f : X ⟶ Y,	g h : Y ⟶ Z,	w : f ≫ g = f ≫ h,	t : ∀ (y : Y), g y = h y → (∃! (x : X), f x = y),	s : category_theory.limits.fork g h,	m : ((category_theory.functor.const category_theory.limits.walking_parallel_pair).obj s.X).obj category_theory.limits.walking_parallel_pair.zero ⟶ ((category_theory.functor.const category_theory.limits.walking_parallel_pair).obj (category_theory.limits.fork.of_ι f w).X).obj category_theory.limits.walking_parallel_pair.zero,	hm : m ≫ (category_theory.limits.fork.of_ι f w).ι = s.ι	⊢ m = λ (i : ((category_theory.functor.const category_theory.limits.walking_parallel_pair).obj s.X).obj category_theory.limits.walking_parallel_pair.zero), classical.some _
X Y Z : Type u,	f : X ⟶ Y,	g h : Y ⟶ Z,	w : f ≫ g = f ≫ h,	t : ∀ (y : Y), g y = h y → (∃! (x : X), f x = y),	s : category_theory.limits.fork g h,	m : ((category_theory.functor.const category_theory.limits.walking_parallel_pair).obj s.X).obj category_theory.limits.walking_parallel_pair.zero ⟶ ((category_theory.functor.const category_theory.limits.walking_parallel_pair).obj (category_theory.limits.fork.of_ι f w).X).obj category_theory.limits.walking_parallel_pair.zero,	hm : m ≫ (category_theory.limits.fork.of_ι f w).ι = s.ι,	i : ((category_theory.functor.const category_theory.limits.walking_parallel_pair).obj s.X).obj category_theory.limits.walking_parallel_pair.zero	⊢ m i = classical.some _
X Y Z : Type u,	f : X ⟶ Y,	g h : Y ⟶ Z,	w : f ≫ g = f ≫ h,	t : ∀ (y : Y), g y = h y → (∃! (x : X), f x = y),	s : category_theory.limits.fork g h,	m : ((category_theory.functor.const category_theory.limits.walking_parallel_pair).obj s.X).obj category_theory.limits.walking_parallel_pair.zero ⟶ ((category_theory.functor.const category_theory.limits.walking_parallel_pair).obj (category_theory.limits.fork.of_ι f w).X).obj category_theory.limits.walking_parallel_pair.zero,	hm : m ≫ (category_theory.limits.fork.of_ι f w).ι = s.ι,	i : ((category_theory.functor.const category_theory.limits.walking_parallel_pair).obj s.X).obj category_theory.limits.walking_parallel_pair.zero	⊢ f (m i) = s.ι i
J : Type v,	C : Type u,	_inst_1 : category_theory.category C,	F : category_theory.limits.walking_parallel_family J ⥤ C,	t : category_theory.limits.trident (λ (j : J), F.map (category_theory.limits.walking_parallel_family.hom.line j)),	X : category_theory.limits.walking_parallel_family J	⊢ (category_theory.limits.parallel_family (λ (j : J), F.map (category_theory.limits.walking_parallel_family.hom.line j))).obj X = F.obj X
J : Type v,	C : Type u,	_inst_1 : category_theory.category C,	F : category_theory.limits.walking_parallel_family J ⥤ C,	t : category_theory.limits.trident (λ (j : J), F.map (category_theory.limits.walking_parallel_family.hom.line j)),	j j' : category_theory.limits.walking_parallel_family J,	g : j ⟶ j'	⊢ ((category_theory.functor.const (category_theory.limits.walking_parallel_family J)).obj t.X).map g ≫ t.π.app j' ≫ category_theory.eq_to_hom _ = (t.π.app j ≫ category_theory.eq_to_hom _) ≫ F.map g
J : Type v,	C : Type u,	_inst_1 : category_theory.category C,	F : category_theory.limits.walking_parallel_family J ⥤ C,	t : category_theory.limits.trident (λ (j : J), F.map (category_theory.limits.walking_parallel_family.hom.line j)),	j j' : category_theory.limits.walking_parallel_family J,	g : j ⟶ j'	⊢ ((category_theory.functor.const (category_theory.limits.walking_parallel_family J)).obj t.X).map g ≫ t.π.app j' ≫ category_theory.eq_to_hom _ = (t.π.app j ≫ category_theory.eq_to_hom _) ≫ F.map g
J : Type v,	C : Type u,	_inst_1 : category_theory.category C,	F : category_theory.limits.walking_parallel_family J ⥤ C,	t : category_theory.limits.trident (λ (j : J), F.map (category_theory.limits.walking_parallel_family.hom.line j)),	g_1 : J	⊢ ((category_theory.functor.const (category_theory.limits.walking_parallel_family J)).obj t.X).map (category_theory.limits.walking_parallel_family.hom.line g_1) ≫ t.π.app category_theory.limits.walking_parallel_family.one ≫ category_theory.eq_to_hom _ = (t.π.app category_theory.limits.walking_parallel_family.zero ≫ category_theory.eq_to_hom _) ≫ F.map (category_theory.limits.walking_parallel_family.hom.line g_1)
J : Type v,	C : Type u,	_inst_1 : category_theory.category C,	F : category_theory.limits.walking_parallel_family J ⥤ C,	t : category_theory.limits.trident (λ (j : J), F.map (category_theory.limits.walking_parallel_family.hom.line j)),	g_1 : J	⊢ 𝟙 t.X ≫ t.π.app category_theory.limits.walking_parallel_family.one ≫ 𝟙 (F.obj category_theory.limits.walking_parallel_family.one) = (t.π.app category_theory.limits.walking_parallel_family.zero ≫ 𝟙 (F.obj category_theory.limits.walking_parallel_family.zero)) ≫ F.map (category_theory.limits.walking_parallel_family.hom.line g_1)
J : Type v,	C : Type u,	_inst_1 : category_theory.category C,	B : C,	objs : J → C,	arrows : Π (j : J), objs j ⟶ B,	X Y : category_theory.limits.wide_pullback_shape J,	f : X ⟶ Y	⊢ option.cases_on X B objs ⟶ option.cases_on Y B objs
J : Type v,	C : Type u,	_inst_1 : category_theory.category C,	B : C,	objs : J → C,	arrows : Π (j : J), objs j ⟶ B,	X : category_theory.limits.wide_pullback_shape J	⊢ option.cases_on X B objs ⟶ option.cases_on X B objs		case category_theory.limits.wide_pullback_shape.hom.term	J : Type v,	C : Type u,	_inst_1 : category_theory.category C,	B : C,	objs : J → C,	arrows : Π (j : J), objs j ⟶ B,	j : J	⊢ (option.some j).cases_on B objs ⟶ option.none.cases_on B objs
J : Type v,	C : Type u,	_inst_1 : category_theory.category C,	B : C,	objs : J → C,	arrows : Π (j : J), objs j ⟶ B,	X : category_theory.limits.wide_pullback_shape J	⊢ option.cases_on X B objs ⟶ option.cases_on X B objs
J : Type v,	C : Type u,	_inst_1 : category_theory.category C,	B : C,	objs : J → C,	arrows : Π (j : J), objs j ⟶ B,	j : J	⊢ (option.some j).cases_on B objs ⟶ option.none.cases_on B objs
⊢ Π (X Y : category_theory.discrete punit), has_zero (X ⟶ Y)
J : Type u,	_inst_1 : category_theory.small_category J,	F : J ⥤ Type u,	x y : category_theory.limits.limit F,	w : ∀ (j : J), category_theory.limits.limit.π F j x = category_theory.limits.limit.π F j y	⊢ x = y
J : Type u,	_inst_1 : category_theory.small_category J,	F : J ⥤ Type u,	x y : category_theory.limits.limit F,	w : ∀ (j : J), category_theory.limits.limit.π F j x = category_theory.limits.limit.π F j y	⊢ ⇑(category_theory.limits.types.limit_equiv_sections F) x = ⇑(category_theory.limits.types.limit_equiv_sections F) y
J : Type u,	_inst_1 : category_theory.small_category J,	F : J ⥤ Type u,	x y : category_theory.limits.limit F,	w : ∀ (j : J), category_theory.limits.limit.π F j x = category_theory.limits.limit.π F j y,	j : J	⊢ ↑(⇑(category_theory.limits.types.limit_equiv_sections F) x) j = ↑(⇑(category_theory.limits.types.limit_equiv_sections F) y) j
J : Type u,	_inst_1 : category_theory.small_category J,	F : J ⥤ Type u,	_inst_2 : category_theory.is_filtered_or_empty J,	i j : J,	xi : F.obj i,	xj : F.obj j	⊢ (category_theory.limits.types.colimit_cocone F).ι.app i xi = (category_theory.limits.types.colimit_cocone F).ι.app j xj ↔ category_theory.limits.types.filtered_colimit.rel F ⟨i, xi⟩ ⟨j, xj⟩
J : Type u,	_inst_1 : category_theory.small_category J,	F : J ⥤ Type u,	_inst_2 : category_theory.is_filtered_or_empty J,	i j : J,	xi : F.obj i,	xj : F.obj j	⊢ quot.mk (category_theory.limits.types.quot.rel F) ⟨i, xi⟩ = quot.mk (category_theory.limits.types.quot.rel F) ⟨j, xj⟩ ↔ category_theory.limits.types.filtered_colimit.rel F ⟨i, xi⟩ ⟨j, xj⟩
C : Type u₁,	D : Type u₂,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.category D,	G : D ⥤ C,	_inst_3 : category_theory.is_right_adjoint G,	_inst_4 : category_theory.reflects_isomorphisms G,	_inst_5 : ∀ ⦃A B : D⦄ (f g : A ⟶ B) [_inst_6 : G.is_split_pair f g], category_theory.limits.has_coequalizer f g,	_inst_7 : Π ⦃A B : D⦄ (f g : A ⟶ B) [_inst_8 : G.is_split_pair f g], category_theory.limits.preserves_colimit (category_theory.limits.parallel_pair f g) G	⊢ category_theory.monadic_right_adjoint G
C : Type u₁,	D : Type u₂,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.category D,	G : D ⥤ C,	_inst_3 : category_theory.is_right_adjoint G,	_inst_4 : category_theory.reflects_isomorphisms G,	_inst_5 : ∀ ⦃A B : D⦄ (f g : A ⟶ B) [_inst_6 : G.is_split_pair f g], category_theory.limits.has_coequalizer f g,	_inst_7 : Π ⦃A B : D⦄ (f g : A ⟶ B) [_inst_8 : G.is_split_pair f g], category_theory.limits.preserves_colimit (category_theory.limits.parallel_pair f g) G	⊢ category_theory.is_right_adjoint G		C : Type u₁,	D : Type u₂,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.category D,	G : D ⥤ C,	_inst_3 : category_theory.is_right_adjoint G,	_inst_4 : category_theory.reflects_isomorphisms G,	_inst_5 : ∀ ⦃A B : D⦄ (f g : A ⟶ B) [_inst_6 : G.is_split_pair f g], category_theory.limits.has_coequalizer f g,	_inst_7 : Π ⦃A B : D⦄ (f g : A ⟶ B) [_inst_8 : G.is_split_pair f g], category_theory.limits.preserves_colimit (category_theory.limits.parallel_pair f g) G	⊢ ∀ ⦃A B : D⦄ (f g : A ⟶ B) [_inst_5 : G.is_split_pair f g], category_theory.limits.has_coequalizer f g		C : Type u₁,	D : Type u₂,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.category D,	G : D ⥤ C,	_inst_3 : category_theory.is_right_adjoint G,	_inst_4 : category_theory.reflects_isomorphisms G,	_inst_5 : ∀ ⦃A B : D⦄ (f g : A ⟶ B) [_inst_6 : G.is_split_pair f g], category_theory.limits.has_coequalizer f g,	_inst_7 : Π ⦃A B : D⦄ (f g : A ⟶ B) [_inst_8 : G.is_split_pair f g], category_theory.limits.preserves_colimit (category_theory.limits.parallel_pair f g) G	⊢ Π ⦃A B : D⦄ (f g : A ⟶ B) [_inst_7 : G.is_split_pair f g], category_theory.limits.preserves_colimit (category_theory.limits.parallel_pair f g) G		C : Type u₁,	D : Type u₂,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.category D,	G : D ⥤ C,	_inst_3 : category_theory.is_right_adjoint G,	_inst_4 : category_theory.reflects_isomorphisms G,	_inst_5 : ∀ ⦃A B : D⦄ (f g : A ⟶ B) [_inst_6 : G.is_split_pair f g], category_theory.limits.has_coequalizer f g,	_inst_7 : Π ⦃A B : D⦄ (f g : A ⟶ B) [_inst_8 : G.is_split_pair f g], category_theory.limits.preserves_colimit (category_theory.limits.parallel_pair f g) G	⊢ Π ⦃A B : D⦄ (f g : A ⟶ B) [_inst_9 : G.is_split_pair f g], category_theory.limits.reflects_colimit (category_theory.limits.parallel_pair f g) G
C : Type u₁,	D : Type u₂,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.category D,	G : D ⥤ C,	_inst_3 : category_theory.is_right_adjoint G,	_inst_4 : category_theory.reflects_isomorphisms G,	_inst_5 : ∀ ⦃A B : D⦄ (f g : A ⟶ B) [_inst_6 : G.is_split_pair f g], category_theory.limits.has_coequalizer f g,	_inst_7 : Π ⦃A B : D⦄ (f g : A ⟶ B) [_inst_8 : G.is_split_pair f g], category_theory.limits.preserves_colimit (category_theory.limits.parallel_pair f g) G	⊢ category_theory.is_right_adjoint G
C : Type u₁,	D : Type u₂,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.category D,	G : D ⥤ C,	_inst_3 : category_theory.is_right_adjoint G,	_inst_4 : category_theory.reflects_isomorphisms G,	_inst_5 : ∀ ⦃A B : D⦄ (f g : A ⟶ B) [_inst_6 : G.is_split_pair f g], category_theory.limits.has_coequalizer f g,	_inst_7 : Π ⦃A B : D⦄ (f g : A ⟶ B) [_inst_8 : G.is_split_pair f g], category_theory.limits.preserves_colimit (category_theory.limits.parallel_pair f g) G	⊢ ∀ ⦃A B : D⦄ (f g : A ⟶ B) [_inst_5 : G.is_split_pair f g], category_theory.limits.has_coequalizer f g		C : Type u₁,	D : Type u₂,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.category D,	G : D ⥤ C,	_inst_3 : category_theory.is_right_adjoint G,	_inst_4 : category_theory.reflects_isomorphisms G,	_inst_5 : ∀ ⦃A B : D⦄ (f g : A ⟶ B) [_inst_6 : G.is_split_pair f g], category_theory.limits.has_coequalizer f g,	_inst_7 : Π ⦃A B : D⦄ (f g : A ⟶ B) [_inst_8 : G.is_split_pair f g], category_theory.limits.preserves_colimit (category_theory.limits.parallel_pair f g) G	⊢ Π ⦃A B : D⦄ (f g : A ⟶ B) [_inst_7 : G.is_split_pair f g], category_theory.limits.preserves_colimit (category_theory.limits.parallel_pair f g) G		C : Type u₁,	D : Type u₂,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.category D,	G : D ⥤ C,	_inst_3 : category_theory.is_right_adjoint G,	_inst_4 : category_theory.reflects_isomorphisms G,	_inst_5 : ∀ ⦃A B : D⦄ (f g : A ⟶ B) [_inst_6 : G.is_split_pair f g], category_theory.limits.has_coequalizer f g,	_inst_7 : Π ⦃A B : D⦄ (f g : A ⟶ B) [_inst_8 : G.is_split_pair f g], category_theory.limits.preserves_colimit (category_theory.limits.parallel_pair f g) G	⊢ Π ⦃A B : D⦄ (f g : A ⟶ B) [_inst_9 : G.is_split_pair f g], category_theory.limits.reflects_colimit (category_theory.limits.parallel_pair f g) G
C : Type u₁,	D : Type u₂,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.category D,	G : D ⥤ C,	_inst_3 : category_theory.is_right_adjoint G,	_inst_4 : category_theory.reflects_isomorphisms G,	_inst_5 : ∀ ⦃A B : D⦄ (f g : A ⟶ B) [_inst_6 : G.is_split_pair f g], category_theory.limits.has_coequalizer f g,	_inst_7 : Π ⦃A B : D⦄ (f g : A ⟶ B) [_inst_8 : G.is_split_pair f g], category_theory.limits.preserves_colimit (category_theory.limits.parallel_pair f g) G	⊢ ∀ ⦃A B : D⦄ (f g : A ⟶ B) [_inst_5 : G.is_split_pair f g], category_theory.limits.has_coequalizer f g
C : Type u₁,	D : Type u₂,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.category D,	G : D ⥤ C,	_inst_3 : category_theory.is_right_adjoint G,	_inst_4 : category_theory.reflects_isomorphisms G,	_inst_5 : ∀ ⦃A B : D⦄ (f g : A ⟶ B) [_inst_6 : G.is_split_pair f g], category_theory.limits.has_coequalizer f g,	_inst_7 : Π ⦃A B : D⦄ (f g : A ⟶ B) [_inst_8 : G.is_split_pair f g], category_theory.limits.preserves_colimit (category_theory.limits.parallel_pair f g) G	⊢ Π ⦃A B : D⦄ (f g : A ⟶ B) [_inst_7 : G.is_split_pair f g], category_theory.limits.preserves_colimit (category_theory.limits.parallel_pair f g) G		C : Type u₁,	D : Type u₂,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.category D,	G : D ⥤ C,	_inst_3 : category_theory.is_right_adjoint G,	_inst_4 : category_theory.reflects_isomorphisms G,	_inst_5 : ∀ ⦃A B : D⦄ (f g : A ⟶ B) [_inst_6 : G.is_split_pair f g], category_theory.limits.has_coequalizer f g,	_inst_7 : Π ⦃A B : D⦄ (f g : A ⟶ B) [_inst_8 : G.is_split_pair f g], category_theory.limits.preserves_colimit (category_theory.limits.parallel_pair f g) G	⊢ Π ⦃A B : D⦄ (f g : A ⟶ B) [_inst_9 : G.is_split_pair f g], category_theory.limits.reflects_colimit (category_theory.limits.parallel_pair f g) G
C : Type u₁,	D : Type u₂,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.category D,	G : D ⥤ C,	_inst_3 : category_theory.is_right_adjoint G,	_inst_4 : category_theory.reflects_isomorphisms G,	_inst_5 : ∀ ⦃A B : D⦄ (f g : A ⟶ B) [_inst_6 : G.is_split_pair f g], category_theory.limits.has_coequalizer f g,	_inst_7 : Π ⦃A B : D⦄ (f g : A ⟶ B) [_inst_8 : G.is_split_pair f g], category_theory.limits.preserves_colimit (category_theory.limits.parallel_pair f g) G	⊢ Π ⦃A B : D⦄ (f g : A ⟶ B) [_inst_7 : G.is_split_pair f g], category_theory.limits.preserves_colimit (category_theory.limits.parallel_pair f g) G
C : Type u₁,	D : Type u₂,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.category D,	G : D ⥤ C,	_inst_3 : category_theory.is_right_adjoint G,	_inst_4 : category_theory.reflects_isomorphisms G,	_inst_5 : ∀ ⦃A B : D⦄ (f g : A ⟶ B) [_inst_6 : G.is_split_pair f g], category_theory.limits.has_coequalizer f g,	_inst_7 : Π ⦃A B : D⦄ (f g : A ⟶ B) [_inst_8 : G.is_split_pair f g], category_theory.limits.preserves_colimit (category_theory.limits.parallel_pair f g) G	⊢ Π ⦃A B : D⦄ (f g : A ⟶ B) [_inst_9 : G.is_split_pair f g], category_theory.limits.reflects_colimit (category_theory.limits.parallel_pair f g) G
C : Type u₁,	D : Type u₂,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.category D,	G : D ⥤ C,	_inst_3 : category_theory.is_right_adjoint G,	_inst_4 : category_theory.reflects_isomorphisms G,	_inst_5 : ∀ ⦃A B : D⦄ (f g : A ⟶ B) [_inst_6 : G.is_split_pair f g], category_theory.limits.has_coequalizer f g,	_inst_7 : Π ⦃A B : D⦄ (f g : A ⟶ B) [_inst_8 : G.is_split_pair f g], category_theory.limits.preserves_colimit (category_theory.limits.parallel_pair f g) G,	A B : D,	f g : A ⟶ B,	i : G.is_split_pair f g	⊢ category_theory.limits.reflects_colimit (category_theory.limits.parallel_pair f g) G
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C	⊢ (ρ_ (𝟙_ C)).hom ≫ (λ_ (𝟙_ C)).inv = 𝟙 (𝟙_ C ⊗ 𝟙_ C)
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C	⊢ (λ_ (𝟙_ C)).inv = (ρ_ (𝟙_ C)).inv
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	V W X Y Z : C,	f : V ≅ W,	g : X ⟶ Y,	h : Y ⟶ Z	⊢ (g ⊗ f.hom) ≫ (h ⊗ f.inv) = g ≫ h ⊗ 𝟙 V
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	_inst_4 : category_theory.monoidal_category D,	F : category_theory.monoidal_functor C D,	G : D ⥤ C,	h : F.to_lax_monoidal_functor.to_functor ⊣ G,	X Y X' Y' : D,	f : X ⟶ Y,	g : X' ⟶ Y'	⊢ (G.map f ⊗ G.map g) ≫ ⇑(h.hom_equiv (G.obj Y ⊗ G.obj Y') (Y ⊗ Y')) (category_theory.inv (F.to_lax_monoidal_functor.μ (G.obj Y) (G.obj Y')) ≫ (h.counit.app Y ⊗ h.counit.app Y')) = ⇑(h.hom_equiv (G.obj X ⊗ G.obj X') (X ⊗ X')) (category_theory.inv (F.to_lax_monoidal_functor.μ (G.obj X) (G.obj X')) ≫ (h.counit.app X ⊗ h.counit.app X')) ≫ G.map (f ⊗ g)
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	_inst_4 : category_theory.monoidal_category D,	F : category_theory.monoidal_functor C D,	G : D ⥤ C,	h : F.to_lax_monoidal_functor.to_functor ⊣ G,	X Y Z : D	⊢ (⇑(h.hom_equiv (G.obj X ⊗ G.obj Y) (X ⊗ Y)) (category_theory.inv (F.to_lax_monoidal_functor.μ (G.obj X) (G.obj Y)) ≫ (h.counit.app X ⊗ h.counit.app Y)) ⊗ 𝟙 (G.obj Z)) ≫ ⇑(h.hom_equiv (G.obj (X ⊗ Y) ⊗ G.obj Z) ((X ⊗ Y) ⊗ Z)) (category_theory.inv (F.to_lax_monoidal_functor.μ (G.obj (X ⊗ Y)) (G.obj Z)) ≫ (h.counit.app (X ⊗ Y) ⊗ h.counit.app Z)) ≫ G.map (α_ X Y Z).hom = (α_ (G.obj X) (G.obj Y) (G.obj Z)).hom ≫ (𝟙 (G.obj X) ⊗ ⇑(h.hom_equiv (G.obj Y ⊗ G.obj Z) (Y ⊗ Z)) (category_theory.inv (F.to_lax_monoidal_functor.μ (G.obj Y) (G.obj Z)) ≫ (h.counit.app Y ⊗ h.counit.app Z))) ≫ ⇑(h.hom_equiv (G.obj X ⊗ G.obj (Y ⊗ Z)) (X ⊗ Y ⊗ Z)) (category_theory.inv (F.to_lax_monoidal_functor.μ (G.obj X) (G.obj (Y ⊗ Z))) ≫ (h.counit.app X ⊗ h.counit.app (Y ⊗ Z)))
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	_inst_4 : category_theory.monoidal_category D,	F : category_theory.monoidal_functor C D,	G : D ⥤ C,	h : F.to_lax_monoidal_functor.to_functor ⊣ G,	X Y Z : D	⊢ ((h.counit.app X ⊗ h.counit.app Y) ⊗ h.counit.app Z) ≫ (α_ X Y Z).hom = (α_ (F.to_lax_monoidal_functor.to_functor.obj (G.obj X)) (F.to_lax_monoidal_functor.to_functor.obj (G.obj Y)) (F.to_lax_monoidal_functor.to_functor.obj (G.obj Z))).hom ≫ (h.counit.app X ⊗ h.counit.app Y ⊗ h.counit.app Z)
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	_inst_4 : category_theory.monoidal_category D,	F : category_theory.monoidal_functor C D,	G : D ⥤ C,	h : F.to_lax_monoidal_functor.to_functor ⊣ G,	X : D	⊢ (λ_ (G.obj X)).hom = (⇑(h.hom_equiv (𝟙_ C) (𝟙_ D)) (category_theory.inv F.to_lax_monoidal_functor.ε) ⊗ 𝟙 (G.obj X)) ≫ ⇑(h.hom_equiv (G.obj (𝟙_ D) ⊗ G.obj X) (𝟙_ D ⊗ X)) (category_theory.inv (F.to_lax_monoidal_functor.μ (G.obj (𝟙_ D)) (G.obj X)) ≫ (h.counit.app (𝟙_ D) ⊗ h.counit.app X)) ≫ G.map (λ_ X).hom
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	_inst_4 : category_theory.monoidal_category D,	F : category_theory.monoidal_functor C D,	G : D ⥤ C,	h : F.to_lax_monoidal_functor.to_functor ⊣ G,	X : D	⊢ (ρ_ (G.obj X)).hom = (𝟙 (G.obj X) ⊗ ⇑(h.hom_equiv (𝟙_ C) (𝟙_ D)) (category_theory.inv F.to_lax_monoidal_functor.ε)) ≫ ⇑(h.hom_equiv (G.obj X ⊗ G.obj (𝟙_ D)) (X ⊗ 𝟙_ D)) (category_theory.inv (F.to_lax_monoidal_functor.μ (G.obj X) (G.obj (𝟙_ D))) ≫ (h.counit.app X ⊗ h.counit.app (𝟙_ D))) ≫ G.map (ρ_ X).hom
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	X Y₁ Y₂ : C,	_x : category_theory.exact_pairing X Y₁,	_x : category_theory.exact_pairing X Y₂	⊢ (𝟙 X)ᘁ ≫ (𝟙 X)ᘁ = 𝟙 Y₁
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	X Y₁ Y₂ : C,	_x : category_theory.exact_pairing X Y₁,	_x : category_theory.exact_pairing X Y₂	⊢ (𝟙 X)ᘁ ≫ (𝟙 X)ᘁ = 𝟙 Y₂
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	e : C ≌ D,	X Y X' Y' : C,	f : X ⟶ Y,	g : X' ⟶ Y'	⊢ ({obj := e.functor.obj, map := e.functor.map, map_id' := _, map_comp' := _}.map f ⊗ {obj := e.functor.obj, map := e.functor.map, map_id' := _, map_comp' := _}.map g) ≫ e.functor.map (e.unit_inv.app Y ⊗ e.unit_inv.app Y') = e.functor.map (e.unit_inv.app X ⊗ e.unit_inv.app X') ≫ {obj := e.functor.obj, map := e.functor.map, map_id' := _, map_comp' := _}.map (f ⊗ g)
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	e : C ≌ D,	X Y X' Y' : C,	f : X ⟶ Y,	g : X' ⟶ Y'	⊢ e.functor.map (e.inverse.map (e.functor.map f) ⊗ e.inverse.map (e.functor.map g)) ≫ e.functor.map (e.unit_inv.app Y ⊗ e.unit_inv.app Y') = e.functor.map (e.unit_inv.app X ⊗ e.unit_inv.app X') ≫ e.functor.map (f ⊗ g)
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	e : C ≌ D,	X Y X' Y' : C,	f : X ⟶ Y,	g : X' ⟶ Y'	⊢ e.functor.map (e.unit_inv.app X ⊗ e.unit_inv.app X') ≫ e.functor.map (f ⊗ g) ≫ e.functor.map (e.unit.app Y ⊗ e.unit.app Y') ≫ e.functor.map (e.unit_inv.app Y ⊗ e.unit_inv.app Y') = e.functor.map (e.unit_inv.app X ⊗ e.unit_inv.app X') ≫ e.functor.map (f ⊗ g)
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	e : C ≌ D,	X Y X' Y' : C,	f : X ⟶ Y,	g : X' ⟶ Y'	⊢ e.functor.map ((e.unit_inv.app X ⊗ e.unit_inv.app X') ≫ (f ⊗ g) ≫ (e.unit.app Y ⊗ e.unit.app Y') ≫ (e.unit_inv.app Y ⊗ e.unit_inv.app Y')) = e.functor.map ((e.unit_inv.app X ⊗ e.unit_inv.app X') ≫ (f ⊗ g))
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	e : C ≌ D,	X Y X' Y' : C,	f : X ⟶ Y,	g : X' ⟶ Y'	⊢ (e.unit_inv.app X ⊗ e.unit_inv.app X') ≫ (f ⊗ g) ≫ (e.unit.app Y ⊗ e.unit.app Y') ≫ (e.unit_inv.app Y ⊗ e.unit_inv.app Y') = (e.unit_inv.app X ⊗ e.unit_inv.app X') ≫ (f ⊗ g)
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	e : C ≌ D,	X Y X' Y' : C,	f : X ⟶ Y,	g : X' ⟶ Y'	⊢ (e.unit_inv.app X ⊗ e.unit_inv.app X') ≫ (f ≫ 𝟙 ((𝟭 C).obj Y) ⊗ g ≫ 𝟙 ((𝟭 C).obj Y')) = (e.unit_inv.app X ⊗ e.unit_inv.app X') ≫ (f ⊗ g)
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	e : C ≌ D,	X Y X' Y' : C,	f : X ⟶ Y,	g : X' ⟶ Y'	⊢ (e.unit_inv.app X ⊗ e.unit_inv.app X') ≫ (f ≫ 𝟙 Y ⊗ g ≫ 𝟙 Y') = (e.unit_inv.app X ⊗ e.unit_inv.app X') ≫ (f ⊗ g)
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	e : C ≌ D,	X Y Z : C	⊢ (e.functor.map (e.unit_inv.app X ⊗ e.unit_inv.app Y) ⊗ 𝟙 ({obj := e.functor.obj, map := e.functor.map, map_id' := _, map_comp' := _}.obj Z)) ≫ e.functor.map (e.unit_inv.app (X ⊗ Y) ⊗ e.unit_inv.app Z) ≫ {obj := e.functor.obj, map := e.functor.map, map_id' := _, map_comp' := _}.map (α_ X Y Z).hom = (α_ ({obj := e.functor.obj, map := e.functor.map, map_id' := _, map_comp' := _}.obj X) ({obj := e.functor.obj, map := e.functor.map, map_id' := _, map_comp' := _}.obj Y) ({obj := e.functor.obj, map := e.functor.map, map_id' := _, map_comp' := _}.obj Z)).hom ≫ (𝟙 ({obj := e.functor.obj, map := e.functor.map, map_id' := _, map_comp' := _}.obj X) ⊗ e.functor.map (e.unit_inv.app Y ⊗ e.unit_inv.app Z)) ≫ e.functor.map (e.unit_inv.app X ⊗ e.unit_inv.app (Y ⊗ Z))
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	e : C ≌ D,	X Y Z : C	⊢ e.functor.map (e.inverse.map (e.functor.map (e.unit_inv.app X ⊗ e.unit_inv.app Y)) ⊗ e.inverse.map (𝟙 (e.functor.obj Z))) ≫ e.functor.map (e.unit_inv.app (X ⊗ Y) ⊗ e.unit_inv.app Z) ≫ e.functor.map (α_ X Y Z).hom = e.functor.map ((e.unit_iso.inv.app (e.inverse.obj (e.functor.obj X) ⊗ e.inverse.obj (e.functor.obj Y)) ⊗ 𝟙 (e.inverse.obj (e.functor.obj Z))) ≫ (α_ (e.inverse.obj (e.functor.obj X)) (e.inverse.obj (e.functor.obj Y)) (e.inverse.obj (e.functor.obj Z))).hom ≫ (𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ e.unit_iso.hom.app (e.inverse.obj (e.functor.obj Y) ⊗ e.inverse.obj (e.functor.obj Z)))) ≫ e.functor.map (e.inverse.map (𝟙 (e.functor.obj X)) ⊗ e.inverse.map (e.functor.map (e.unit_inv.app Y ⊗ e.unit_inv.app Z))) ≫ e.functor.map (e.unit_inv.app X ⊗ e.unit_inv.app (Y ⊗ Z))
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	e : C ≌ D,	X Y Z : C	⊢ e.functor.map (e.unit_inv.app (e.inverse.obj (e.functor.obj X) ⊗ e.inverse.obj (e.functor.obj Y)) ⊗ 𝟙 (e.inverse.obj (e.functor.obj Z))) ≫ e.functor.map ((e.unit_inv.app X ⊗ e.unit_inv.app Y) ⊗ 𝟙 (e.inverse.obj (e.functor.obj Z))) ≫ e.functor.map (e.unit.app (X ⊗ Y) ⊗ 𝟙 (e.inverse.obj (e.functor.obj Z))) ≫ e.functor.map (e.unit_inv.app (X ⊗ Y) ⊗ e.unit_inv.app Z) ≫ e.functor.map (α_ X Y Z).hom = e.functor.map (e.unit_iso.inv.app (e.inverse.obj (e.functor.obj X) ⊗ e.inverse.obj (e.functor.obj Y)) ⊗ 𝟙 (e.inverse.obj (e.functor.obj Z))) ≫ e.functor.map (α_ (e.inverse.obj (e.functor.obj X)) (e.inverse.obj (e.functor.obj Y)) (e.inverse.obj (e.functor.obj Z))).hom ≫ e.functor.map (𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ e.unit_iso.hom.app (e.inverse.obj (e.functor.obj Y) ⊗ e.inverse.obj (e.functor.obj Z))) ≫ e.functor.map (𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ e.unit_inv.app (e.inverse.obj (e.functor.obj Y) ⊗ e.inverse.obj (e.functor.obj Z))) ≫ e.functor.map (𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ e.unit_inv.app Y ⊗ e.unit_inv.app Z) ≫ e.functor.map (𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ e.unit.app (Y ⊗ Z)) ≫ e.functor.map (e.unit_inv.app X ⊗ e.unit_inv.app (Y ⊗ Z))
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	e : C ≌ D,	X Y Z : C	⊢ e.functor.map ((e.unit_inv.app (e.inverse.obj (e.functor.obj X) ⊗ e.inverse.obj (e.functor.obj Y)) ⊗ 𝟙 (e.inverse.obj (e.functor.obj Z))) ≫ ((e.unit_inv.app X ⊗ e.unit_inv.app Y) ⊗ 𝟙 (e.inverse.obj (e.functor.obj Z))) ≫ (e.unit.app (X ⊗ Y) ⊗ 𝟙 (e.inverse.obj (e.functor.obj Z))) ≫ (e.unit_inv.app (X ⊗ Y) ⊗ e.unit_inv.app Z) ≫ (α_ X Y Z).hom) = e.functor.map ((e.unit_iso.inv.app (e.inverse.obj (e.functor.obj X) ⊗ e.inverse.obj (e.functor.obj Y)) ⊗ 𝟙 (e.inverse.obj (e.functor.obj Z))) ≫ (α_ (e.inverse.obj (e.functor.obj X)) (e.inverse.obj (e.functor.obj Y)) (e.inverse.obj (e.functor.obj Z))).hom ≫ (𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ e.unit_iso.hom.app (e.inverse.obj (e.functor.obj Y) ⊗ e.inverse.obj (e.functor.obj Z))) ≫ (𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ e.unit_inv.app (e.inverse.obj (e.functor.obj Y) ⊗ e.inverse.obj (e.functor.obj Z))) ≫ (𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ e.unit_inv.app Y ⊗ e.unit_inv.app Z) ≫ (𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ e.unit.app (Y ⊗ Z)) ≫ (e.unit_inv.app X ⊗ e.unit_inv.app (Y ⊗ Z)))
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	e : C ≌ D,	X Y Z : C	⊢ e.unit_inv.app (X ⊗ Y) ⊗ e.unit_inv.app Z = ?m_1
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	e : C ≌ D,	X Y Z : C	⊢ ((e.unit_inv.app X ⊗ e.unit_inv.app Y) ⊗ 𝟙 (e.inverse.obj (e.functor.obj Z))) ≫ (e.unit.app (X ⊗ Y) ⊗ 𝟙 (e.inverse.obj (e.functor.obj Z))) ≫ (e.unit_inv.app (X ⊗ Y) ⊗ e.unit_inv.app Z) ≫ (α_ X Y Z).hom = (α_ (e.inverse.obj (e.functor.obj X)) (e.inverse.obj (e.functor.obj Y)) (e.inverse.obj (e.functor.obj Z))).hom ≫ (𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ e.unit_iso.hom.app (e.inverse.obj (e.functor.obj Y) ⊗ e.inverse.obj (e.functor.obj Z))) ≫ (𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ e.unit_inv.app (e.inverse.obj (e.functor.obj Y) ⊗ e.inverse.obj (e.functor.obj Z))) ≫ (𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ e.unit_inv.app Y ⊗ e.unit_inv.app Z) ≫ (𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ e.unit.app (Y ⊗ Z)) ≫ (e.unit_inv.app X ⊗ e.unit_inv.app (Y ⊗ Z))
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	e : C ≌ D,	X Y Z : C	⊢ (e.unit.app (X ⊗ Y) ⊗ 𝟙 (e.inverse.obj (e.functor.obj Z))) ≫ (e.unit_inv.app (X ⊗ Y) ⊗ 𝟙 (e.inverse.obj (e.functor.obj Z))) = ?m_1
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	e : C ≌ D,	X Y Z : C	⊢ ((e.unit_inv.app X ⊗ e.unit_inv.app Y) ⊗ 𝟙 (e.inverse.obj (e.functor.obj Z))) ≫ (e.unit.app (X ⊗ Y) ⊗ 𝟙 (e.inverse.obj (e.functor.obj Z))) ≫ ((e.unit_inv.app (X ⊗ Y) ⊗ 𝟙 (e.inverse.obj (e.functor.obj Z))) ≫ (𝟙 (X ⊗ Y) ⊗ e.unit_inv.app Z)) ≫ (α_ X Y Z).hom = (α_ (e.inverse.obj (e.functor.obj X)) (e.inverse.obj (e.functor.obj Y)) (e.inverse.obj (e.functor.obj Z))).hom ≫ (𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ e.unit_iso.hom.app (e.inverse.obj (e.functor.obj Y) ⊗ e.inverse.obj (e.functor.obj Z))) ≫ (𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ e.unit_inv.app (e.inverse.obj (e.functor.obj Y) ⊗ e.inverse.obj (e.functor.obj Z))) ≫ (𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ e.unit_inv.app Y ⊗ e.unit_inv.app Z) ≫ (𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ e.unit.app (Y ⊗ Z)) ≫ (e.unit_inv.app X ⊗ e.unit_inv.app (Y ⊗ Z))
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	e : C ≌ D,	X Y Z : C	⊢ 𝟙 ((𝟭 C).obj (X ⊗ Y)) ⊗ 𝟙 (e.inverse.obj (e.functor.obj Z)) = ?m_1
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	e : C ≌ D,	X Y Z : C	⊢ 𝟙 (X ⊗ Y) ⊗ 𝟙 (e.inverse.obj (e.functor.obj Z)) = ?m_1
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	e : C ≌ D,	X Y Z : C	⊢ ((e.unit_inv.app X ⊗ e.unit_inv.app Y) ⊗ 𝟙 (e.inverse.obj (e.functor.obj Z))) ≫ (𝟙 ((X ⊗ Y) ⊗ e.inverse.obj (e.functor.obj Z)) ≫ (𝟙 (X ⊗ Y) ⊗ e.unit_inv.app Z)) ≫ (α_ X Y Z).hom = (α_ (e.inverse.obj (e.functor.obj X)) (e.inverse.obj (e.functor.obj Y)) (e.inverse.obj (e.functor.obj Z))).hom ≫ (𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ e.unit_iso.hom.app (e.inverse.obj (e.functor.obj Y) ⊗ e.inverse.obj (e.functor.obj Z))) ≫ (𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ e.unit_inv.app (e.inverse.obj (e.functor.obj Y) ⊗ e.inverse.obj (e.functor.obj Z))) ≫ (𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ e.unit_inv.app Y ⊗ e.unit_inv.app Z) ≫ (𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ e.unit.app (Y ⊗ Z)) ≫ (e.unit_inv.app X ⊗ e.unit_inv.app (Y ⊗ Z))
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	e : C ≌ D,	X Y Z : C	⊢ (𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ e.unit_iso.hom.app (e.inverse.obj (e.functor.obj Y) ⊗ e.inverse.obj (e.functor.obj Z))) ≫ (𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ e.unit_inv.app (e.inverse.obj (e.functor.obj Y) ⊗ e.inverse.obj (e.functor.obj Z))) = ?m_1
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	e : C ≌ D,	X Y Z : C	⊢ ((e.unit_inv.app X ⊗ e.unit_inv.app Y) ⊗ 𝟙 (e.inverse.obj (e.functor.obj Z))) ≫ (𝟙 (X ⊗ Y) ⊗ e.unit_inv.app Z) ≫ (α_ X Y Z).hom = (α_ (e.inverse.obj (e.functor.obj X)) (e.inverse.obj (e.functor.obj Y)) (e.inverse.obj (e.functor.obj Z))).hom ≫ (𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ e.unit_iso.hom.app (e.inverse.obj (e.functor.obj Y) ⊗ e.inverse.obj (e.functor.obj Z))) ≫ (𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ e.unit_inv.app (e.inverse.obj (e.functor.obj Y) ⊗ e.inverse.obj (e.functor.obj Z))) ≫ (𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ e.unit_inv.app Y ⊗ e.unit_inv.app Z) ≫ (𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ e.unit.app (Y ⊗ Z)) ≫ (e.unit_inv.app X ⊗ e.unit_inv.app (Y ⊗ Z))
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	e : C ≌ D,	X Y Z : C	⊢ 𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ 𝟙 ((𝟭 C).obj (e.inverse.obj (e.functor.obj Y) ⊗ e.inverse.obj (e.functor.obj Z))) = ?m_1
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	e : C ≌ D,	X Y Z : C	⊢ 𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ 𝟙 (e.inverse.obj (e.functor.obj Y) ⊗ e.inverse.obj (e.functor.obj Z)) = ?m_1
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	e : C ≌ D,	X Y Z : C	⊢ ((e.unit_inv.app X ⊗ e.unit_inv.app Y) ⊗ 𝟙 (e.inverse.obj (e.functor.obj Z))) ≫ (𝟙 (X ⊗ Y) ⊗ e.unit_inv.app Z) ≫ (α_ X Y Z).hom = (α_ (e.inverse.obj (e.functor.obj X)) (e.inverse.obj (e.functor.obj Y)) (e.inverse.obj (e.functor.obj Z))).hom ≫ ((𝟙 (e.inverse.obj (e.functor.obj X) ⊗ e.inverse.obj (e.functor.obj Y) ⊗ e.inverse.obj (e.functor.obj Z)) ≫ (𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ e.unit_inv.app Y ⊗ e.unit_inv.app Z)) ≫ (𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ e.unit.app (Y ⊗ Z))) ≫ (e.unit_inv.app X ⊗ e.unit_inv.app (Y ⊗ Z))
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	e : C ≌ D,	X Y Z : C	⊢ (α_ (e.inverse.obj (e.functor.obj X)) (e.inverse.obj (e.functor.obj Y)) (e.inverse.obj (e.functor.obj Z))).hom ≫ ((𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ e.unit_inv.app Y ⊗ e.unit_inv.app Z) ≫ (𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ e.unit.app (Y ⊗ Z))) ≫ (e.unit_inv.app X ⊗ e.unit_inv.app (Y ⊗ Z)) = ?m_1
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	e : C ≌ D,	X Y Z : C	⊢ ((e.unit_inv.app X ⊗ e.unit_inv.app Y) ⊗ 𝟙 (e.inverse.obj (e.functor.obj Z))) ≫ (𝟙 (X ⊗ Y) ⊗ e.unit_inv.app Z) ≫ (α_ X Y Z).hom = (α_ (e.inverse.obj (e.functor.obj X)) (e.inverse.obj (e.functor.obj Y)) (e.inverse.obj (e.functor.obj Z))).hom ≫ ((𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ e.unit_inv.app Y ⊗ e.unit_inv.app Z) ≫ (𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ e.unit.app (Y ⊗ Z))) ≫ (e.unit_inv.app X ⊗ e.unit_inv.app (Y ⊗ Z))
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	e : C ≌ D,	X Y Z : C	⊢ ((e.unit_inv.app X ⊗ e.unit_inv.app Y) ⊗ 𝟙 (e.inverse.obj (e.functor.obj Z))) ≫ (𝟙 (X ⊗ Y) ⊗ e.unit_inv.app Z) ≫ (α_ X Y Z).hom = (α_ (e.inverse.obj (e.functor.obj X)) (e.inverse.obj (e.functor.obj Y)) (e.inverse.obj (e.functor.obj Z))).hom ≫ ((𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ e.unit_inv.app Y ⊗ e.unit_inv.app Z) ≫ (𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ e.unit.app (Y ⊗ Z))) ≫ (𝟙 ((e.functor ⋙ e.inverse).obj X) ⊗ e.unit_inv.app (Y ⊗ Z)) ≫ (e.unit_inv.app X ⊗ 𝟙 (Y ⊗ Z))
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	e : C ≌ D,	X Y Z : C	⊢ (𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ e.unit.app (Y ⊗ Z)) ≫ (𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ e.unit_inv.app (Y ⊗ Z)) = ?m_1
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	e : C ≌ D,	X Y Z : C	⊢ ((e.unit_inv.app X ⊗ e.unit_inv.app Y) ⊗ 𝟙 (e.inverse.obj (e.functor.obj Z))) ≫ (𝟙 (X ⊗ Y) ⊗ e.unit_inv.app Z) ≫ (α_ X Y Z).hom = (α_ (e.inverse.obj (e.functor.obj X)) (e.inverse.obj (e.functor.obj Y)) (e.inverse.obj (e.functor.obj Z))).hom ≫ ((𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ e.unit_inv.app Y ⊗ e.unit_inv.app Z) ≫ (𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ e.unit.app (Y ⊗ Z))) ≫ (𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ e.unit_inv.app (Y ⊗ Z)) ≫ (e.unit_inv.app X ⊗ 𝟙 (Y ⊗ Z))
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	e : C ≌ D,	X Y Z : C	⊢ 𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ 𝟙 ((𝟭 C).obj (Y ⊗ Z)) = ?m_1
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	e : C ≌ D,	X Y Z : C	⊢ 𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ 𝟙 (Y ⊗ Z) = ?m_1
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	e : C ≌ D,	X Y Z : C	⊢ ((e.unit_inv.app X ⊗ e.unit_inv.app Y) ⊗ 𝟙 (e.inverse.obj (e.functor.obj Z))) ≫ (𝟙 (X ⊗ Y) ⊗ e.unit_inv.app Z) ≫ (α_ X Y Z).hom = (α_ (e.inverse.obj (e.functor.obj X)) (e.inverse.obj (e.functor.obj Y)) (e.inverse.obj (e.functor.obj Z))).hom ≫ (𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ e.unit_inv.app Y ⊗ e.unit_inv.app Z) ≫ 𝟙 (e.inverse.obj (e.functor.obj X) ⊗ Y ⊗ Z) ≫ (e.unit_inv.app X ⊗ 𝟙 (Y ⊗ Z))
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	e : C ≌ D,	X Y Z : C	⊢ ((e.unit_inv.app X ⊗ e.unit_inv.app Y) ⊗ 𝟙 (e.inverse.obj (e.functor.obj Z))) ≫ (𝟙 (X ⊗ Y) ⊗ e.unit_inv.app Z) ≫ (α_ X Y Z).hom = (α_ (e.inverse.obj (e.functor.obj X)) (e.inverse.obj (e.functor.obj Y)) (e.inverse.obj (e.functor.obj Z))).hom ≫ (𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ e.unit_inv.app Y ⊗ e.unit_inv.app Z) ≫ (e.unit_inv.app X ⊗ 𝟙 (Y ⊗ Z))
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	e : C ≌ D,	X : C	⊢ (λ_ ({obj := e.functor.obj, map := e.functor.map, map_id' := _, map_comp' := _}.obj X)).hom = (𝟙 (e.functor.obj (𝟙_ C)) ⊗ 𝟙 ({obj := e.functor.obj, map := e.functor.map, map_id' := _, map_comp' := _}.obj X)) ≫ e.functor.map (e.unit_inv.app (𝟙_ C) ⊗ e.unit_inv.app X) ≫ {obj := e.functor.obj, map := e.functor.map, map_id' := _, map_comp' := _}.map (λ_ X).hom
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	e : C ≌ D,	X : C	⊢ e.functor.map ((e.unit_iso.inv.app (𝟙_ C) ⊗ 𝟙 (e.inverse.obj (e.functor.obj X))) ≫ (λ_ (e.inverse.obj (e.functor.obj X))).hom) ≫ e.counit_iso.hom.app (e.functor.obj X) = e.functor.map (e.inverse.map (𝟙 (e.functor.obj (𝟙_ C))) ⊗ e.inverse.map (𝟙 (e.functor.obj X))) ≫ e.functor.map (e.unit_inv.app (𝟙_ C) ⊗ e.unit_inv.app X) ≫ e.functor.map (λ_ X).hom
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	e : C ≌ D,	X : C	⊢ e.functor.map (e.unit_iso.inv.app (𝟙_ C) ⊗ 𝟙 (e.inverse.obj (e.functor.obj X))) ≫ e.functor.map (λ_ (e.inverse.obj (e.functor.obj X))).hom ≫ e.counit_iso.hom.app (e.functor.obj X) = e.functor.map (𝟙 (e.inverse.obj (e.functor.obj (𝟙_ C)) ⊗ e.inverse.obj (e.functor.obj X))) ≫ e.functor.map (e.unit_inv.app (𝟙_ C) ⊗ e.unit_inv.app X) ≫ e.functor.map (λ_ X).hom
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	e : C ≌ D,	X : C	⊢ e.functor.map (e.unit_iso.inv.app (𝟙_ C) ⊗ 𝟙 (e.inverse.obj (e.functor.obj X))) ≫ e.functor.map (λ_ (e.inverse.obj (e.functor.obj X))).hom ≫ e.functor.map (e.unit_inv.app X) = e.functor.map (𝟙 (e.inverse.obj (e.functor.obj (𝟙_ C)) ⊗ e.inverse.obj (e.functor.obj X))) ≫ e.functor.map (e.unit_inv.app (𝟙_ C) ⊗ e.unit_inv.app X) ≫ e.functor.map (λ_ X).hom
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	e : C ≌ D,	X : C	⊢ e.functor.map ((e.unit_iso.inv.app (𝟙_ C) ⊗ 𝟙 (e.inverse.obj (e.functor.obj X))) ≫ (λ_ (e.inverse.obj (e.functor.obj X))).hom ≫ e.unit_inv.app X) = e.functor.map (𝟙 (e.inverse.obj (e.functor.obj (𝟙_ C)) ⊗ e.inverse.obj (e.functor.obj X)) ≫ (e.unit_inv.app (𝟙_ C) ⊗ e.unit_inv.app X) ≫ (λ_ X).hom)
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	e : C ≌ D,	X : C	⊢ (e.unit_iso.inv.app (𝟙_ C) ⊗ 𝟙 (e.inverse.obj (e.functor.obj X))) ≫ (λ_ (e.inverse.obj (e.functor.obj X))).hom ≫ e.unit_inv.app X = 𝟙 (e.inverse.obj (e.functor.obj (𝟙_ C)) ⊗ e.inverse.obj (e.functor.obj X)) ≫ (e.unit_inv.app (𝟙_ C) ⊗ e.unit_inv.app X) ≫ (λ_ X).hom
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	e : C ≌ D,	X : C	⊢ (e.unit_iso.inv.app (𝟙_ C) ⊗ 𝟙 (e.inverse.obj (e.functor.obj X))) ≫ (𝟙 (𝟙_ C) ⊗ e.unit_inv.app X) ≫ (λ_ X).hom = 𝟙 (e.inverse.obj (e.functor.obj (𝟙_ C)) ⊗ e.inverse.obj (e.functor.obj X)) ≫ (e.unit_inv.app (𝟙_ C) ⊗ e.unit_inv.app X) ≫ (λ_ X).hom
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	e : C ≌ D,	X : C	⊢ (ρ_ ({obj := e.functor.obj, map := e.functor.map, map_id' := _, map_comp' := _}.obj X)).hom = (𝟙 ({obj := e.functor.obj, map := e.functor.map, map_id' := _, map_comp' := _}.obj X) ⊗ 𝟙 (e.functor.obj (𝟙_ C))) ≫ e.functor.map (e.unit_inv.app X ⊗ e.unit_inv.app (𝟙_ C)) ≫ {obj := e.functor.obj, map := e.functor.map, map_id' := _, map_comp' := _}.map (ρ_ X).hom
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	e : C ≌ D,	X : C	⊢ e.functor.map ((𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ e.unit_iso.inv.app (𝟙_ C)) ≫ (ρ_ (e.inverse.obj (e.functor.obj X))).hom) ≫ e.counit_iso.hom.app (e.functor.obj X) = e.functor.map (e.inverse.map (𝟙 (e.functor.obj X)) ⊗ e.inverse.map (𝟙 (e.functor.obj (𝟙_ C)))) ≫ e.functor.map (e.unit_inv.app X ⊗ e.unit_inv.app (𝟙_ C)) ≫ e.functor.map (ρ_ X).hom
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	e : C ≌ D,	X : C	⊢ e.functor.map (𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ e.unit_iso.inv.app (𝟙_ C)) ≫ e.functor.map (ρ_ (e.inverse.obj (e.functor.obj X))).hom ≫ e.counit_iso.hom.app (e.functor.obj X) = e.functor.map (𝟙 (e.inverse.obj (e.functor.obj X) ⊗ e.inverse.obj (e.functor.obj (𝟙_ C)))) ≫ e.functor.map (e.unit_inv.app X ⊗ e.unit_inv.app (𝟙_ C)) ≫ e.functor.map (ρ_ X).hom
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	e : C ≌ D,	X : C	⊢ e.functor.map (𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ e.unit_iso.inv.app (𝟙_ C)) ≫ e.functor.map (ρ_ (e.inverse.obj (e.functor.obj X))).hom ≫ e.functor.map (e.unit_inv.app X) = e.functor.map (𝟙 (e.inverse.obj (e.functor.obj X) ⊗ e.inverse.obj (e.functor.obj (𝟙_ C)))) ≫ e.functor.map (e.unit_inv.app X ⊗ e.unit_inv.app (𝟙_ C)) ≫ e.functor.map (ρ_ X).hom
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	e : C ≌ D,	X : C	⊢ e.functor.map ((𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ e.unit_iso.inv.app (𝟙_ C)) ≫ (ρ_ (e.inverse.obj (e.functor.obj X))).hom ≫ e.unit_inv.app X) = e.functor.map (𝟙 (e.inverse.obj (e.functor.obj X) ⊗ e.inverse.obj (e.functor.obj (𝟙_ C))) ≫ (e.unit_inv.app X ⊗ e.unit_inv.app (𝟙_ C)) ≫ (ρ_ X).hom)
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	e : C ≌ D,	X : C	⊢ (𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ e.unit_iso.inv.app (𝟙_ C)) ≫ (ρ_ (e.inverse.obj (e.functor.obj X))).hom ≫ e.unit_inv.app X = 𝟙 (e.inverse.obj (e.functor.obj X) ⊗ e.inverse.obj (e.functor.obj (𝟙_ C))) ≫ (e.unit_inv.app X ⊗ e.unit_inv.app (𝟙_ C)) ≫ (ρ_ X).hom
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.monoidal_category C,	D : Type u₂,	_inst_3 : category_theory.category D,	e : C ≌ D,	X : C	⊢ (𝟙 (e.inverse.obj (e.functor.obj X)) ⊗ e.unit_iso.inv.app (𝟙_ C)) ≫ (e.unit_inv.app X ⊗ 𝟙 (𝟙_ C)) ≫ (ρ_ X).hom = 𝟙 (e.inverse.obj (e.functor.obj X) ⊗ e.inverse.obj (e.functor.obj (𝟙_ C))) ≫ (e.unit_inv.app X ⊗ e.unit_inv.app (𝟙_ C)) ≫ (ρ_ X).hom
C : Type u₁,	_inst_1 : category_theory.category C,	D : Type u₂,	_inst_2 : category_theory.category D,	F G : C ⥤ D,	app : Π (X : C), F.obj X ≅ G.obj X,	naturality : ∀ {X Y : C} (f : X ⟶ Y), F.map f ≫ (app Y).hom = (app X).hom ≫ G.map f,	X Y : C,	f : X ⟶ Y	⊢ G.map f ≫ (app Y).inv = (app X).inv ≫ F.map f
C : Type u₁,	_inst_1 : category_theory.category C,	D : Type u₂,	_inst_2 : category_theory.category D,	F G : C ⥤ D,	app : Π (X : C), F.obj X ≅ G.obj X,	naturality : ∀ {X Y : C} (f : X ⟶ Y), F.map f ≫ (app Y).hom = (app X).hom ≫ G.map f,	X Y : C,	f : X ⟶ Y,	h : (λ (f : F.obj X ⟶ G.obj Y), (app X).inv ≫ f ≫ (app Y).inv) ((app X).hom ≫ G.map f) = (λ (f : F.obj X ⟶ G.obj Y), (app X).inv ≫ f ≫ (app Y).inv) (F.map f ≫ (app Y).hom)	⊢ G.map f ≫ (app Y).inv = (app X).inv ≫ F.map f
C : Type u₁,	_inst_1 : category_theory.category C,	D : Type u₂,	_inst_2 : category_theory.category D,	F G : C ⥤ D,	app : Π (X : C), F.obj X ≅ G.obj X,	naturality : ∀ {X Y : C} (f : X ⟶ Y), F.map f ≫ (app Y).hom = (app X).hom ≫ G.map f,	X Y : C,	f : X ⟶ Y,	h : G.map f ≫ (app Y).inv = (app X).inv ≫ F.map f	⊢ G.map f ≫ (app Y).inv = (app X).inv ≫ F.map f
C : Type u₁,	_inst_1 : category_theory.category C,	D : Type u₂,	_inst_2 : category_theory.category D,	F G : C ⥤ D,	α : F ⟶ G,	_inst_4 : ∀ (X : C), category_theory.is_iso (α.app X)	⊢ ∀ {X Y : C} (f : X ⟶ Y), F.map f ≫ (category_theory.as_iso (α.app Y)).hom = (category_theory.as_iso (α.app X)).hom ≫ G.map f
C : Type u₁,	_inst_1 : category_theory.category C,	D : Type u₂,	_inst_2 : category_theory.category D,	F G : C ⥤ D,	α : category_theory.nat_trans F G,	X Y U V : C,	f : X ⟶ Y,	g : Y ⟶ U,	h : U ⟶ V	⊢ α.app X ≫ G.map f ≫ G.map g ≫ G.map h = F.map f ≫ F.map g ≫ F.map h ≫ α.app V
C : Type u₁,	_inst_1 : category_theory.category C,	X Y : C,	f : X ⟶ Y,	_inst_2 : category_theory.is_iso f.op	⊢ (f ≫ (category_theory.inv f.op).unop).op = (𝟙 X).op
C : Type u₁,	_inst_1 : category_theory.category C,	X Y : C,	f : X ⟶ Y,	_inst_2 : category_theory.is_iso f.op	⊢ ((category_theory.inv f.op).unop ≫ f).op = (𝟙 Y).op
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.preadditive C,	X : C	⊢ (λ (_x _x : {ι := punit, F := punit.fintype, D := λ (a b : punit), punit.decidable_eq a b, X := λ (_x : punit), X}.ι), 𝟙 X) = 𝟙 {ι := punit, F := punit.fintype, D := λ (a b : punit), punit.decidable_eq a b, X := λ (_x : punit), X}
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.preadditive C,	X : C	⊢ 𝟙 X = 𝟙 {ι := punit, F := punit.fintype, D := λ (a b : punit), punit.decidable_eq a b, X := λ (_x : punit), X} punit.star punit.star
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.preadditive C,	X Y Z : C,	f : X ⟶ Y,	g : Y ⟶ Z	⊢ (λ (_x : {ι := punit, F := punit.fintype, D := λ (a b : punit), punit.decidable_eq a b, X := λ (_x : punit), X}.ι) (_x : {ι := punit, F := punit.fintype, D := λ (a b : punit), punit.decidable_eq a b, X := λ (_x : punit), Z}.ι), f ≫ g) = (λ (_x : {ι := punit, F := punit.fintype, D := λ (a b : punit), punit.decidable_eq a b, X := λ (_x : punit), X}.ι) (_x : {ι := punit, F := punit.fintype, D := λ (a b : punit), punit.decidable_eq a b, X := λ (_x : punit), Y}.ι), f) ≫ λ (_x : {ι := punit, F := punit.fintype, D := λ (a b : punit), punit.decidable_eq a b, X := λ (_x : punit), Y}.ι) (_x : {ι := punit, F := punit.fintype, D := λ (a b : punit), punit.decidable_eq a b, X := λ (_x : punit), Z}.ι), g
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.preadditive C,	X Y Z : C,	f : X ⟶ Y,	g : Y ⟶ Z	⊢ f ≫ g = ((λ (_x : {ι := punit, F := punit.fintype, D := λ (a b : punit), punit.decidable_eq a b, X := λ (_x : punit), X}.ι) (_x : {ι := punit, F := punit.fintype, D := λ (a b : punit), punit.decidable_eq a b, X := λ (_x : punit), Y}.ι), f) ≫ λ (_x : {ι := punit, F := punit.fintype, D := λ (a b : punit), punit.decidable_eq a b, X := λ (_x : punit), Y}.ι) (_x : {ι := punit, F := punit.fintype, D := λ (a b : punit), punit.decidable_eq a b, X := λ (_x : punit), Z}.ι), g) punit.star punit.star
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.preadditive C,	D : Type u₁,	_inst_3 : category_theory.category D,	_inst_4 : category_theory.preadditive D,	_inst_5 : category_theory.limits.has_finite_biproducts D,	F : category_theory.Mat_ C ⥤ D,	_inst_6 : F.additive,	M N : category_theory.Mat_ C,	f : M ⟶ N	⊢ F.map f ≫ (category_theory.Mat_.additive_obj_iso_biproduct F N).hom = (category_theory.Mat_.additive_obj_iso_biproduct F M).hom ≫ category_theory.limits.biproduct.matrix (λ (i : M.ι) (j : N.ι), F.map ((category_theory.Mat_.embedding C).map (f i j)))
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.preadditive C,	D : Type u₁,	_inst_3 : category_theory.category D,	_inst_4 : category_theory.preadditive D,	_inst_5 : category_theory.limits.has_finite_biproducts D,	F : category_theory.Mat_ C ⥤ D,	_inst_6 : F.additive,	M N : category_theory.Mat_ C,	f : M ⟶ N,	j : N.ι	⊢ (F.map f ≫ (category_theory.Mat_.additive_obj_iso_biproduct F N).hom) ≫ category_theory.limits.biproduct.π (λ (i : N.ι), F.obj ((category_theory.Mat_.embedding C).obj (N.X i))) j = ((category_theory.Mat_.additive_obj_iso_biproduct F M).hom ≫ category_theory.limits.biproduct.matrix (λ (i : M.ι) (j : N.ι), F.map ((category_theory.Mat_.embedding C).map (f i j)))) ≫ category_theory.limits.biproduct.π (λ (i : N.ι), F.obj ((category_theory.Mat_.embedding C).obj (N.X i))) j
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.preadditive C,	D : Type u₁,	_inst_3 : category_theory.category D,	_inst_4 : category_theory.preadditive D,	_inst_5 : category_theory.limits.has_finite_biproducts D,	F : category_theory.Mat_ C ⥤ D,	_inst_6 : F.additive,	M N : category_theory.Mat_ C,	f : M ⟶ N,	j : N.ι	⊢ (F.map f ≫ F.map (category_theory.limits.biproduct.lift (λ (i j : N.ι) (k : punit), dite (j = i) (λ (h : j = i), category_theory.eq_to_hom _) (λ (h : ¬j = i), 0))) ≫ category_theory.limits.biproduct.lift (λ (j : N.ι), F.map (category_theory.limits.biproduct.π (λ (i : N.ι), {ι := punit, F := punit.fintype, D := punit.decidable_eq, X := λ (_x : punit), N.X i}) j))) ≫ category_theory.limits.biproduct.π (λ (i : N.ι), F.obj {ι := punit, F := punit.fintype, D := punit.decidable_eq, X := λ (_x : punit), N.X i}) j = ((F.map (category_theory.limits.biproduct.lift (λ (i j : M.ι) (k : punit), dite (j = i) (λ (h : j = i), category_theory.eq_to_hom _) (λ (h : ¬j = i), 0))) ≫ category_theory.limits.biproduct.lift (λ (j : M.ι), F.map (category_theory.limits.biproduct.π (λ (i : M.ι), {ι := punit, F := punit.fintype, D := punit.decidable_eq, X := λ (_x : punit), M.X i}) j))) ≫ category_theory.limits.biproduct.matrix (λ (i : M.ι) (j : N.ι), F.map (λ (_x _x : punit), f i j))) ≫ category_theory.limits.biproduct.π (λ (i : N.ι), F.obj {ι := punit, F := punit.fintype, D := punit.decidable_eq, X := λ (_x : punit), N.X i}) j
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.preadditive C,	D : Type u₁,	_inst_3 : category_theory.category D,	_inst_4 : category_theory.preadditive D,	_inst_5 : category_theory.limits.has_finite_biproducts D,	F : category_theory.Mat_ C ⥤ D,	_inst_6 : F.additive,	M N : category_theory.Mat_ C,	f : M ⟶ N,	j : N.ι	⊢ F.map (f ≫ λ (j_1 : N.ι) (k : punit), dite (j_1 = j) (λ (h : j_1 = j), category_theory.eq_to_hom _) (λ (h : ¬j_1 = j), 0)) = F.map (category_theory.limits.biproduct.lift (λ (i j : M.ι) (k : punit), dite (j = i) (λ (h : j = i), category_theory.eq_to_hom _) (λ (h : ¬j = i), 0))) ≫ category_theory.limits.biproduct.lift (λ (j : M.ι), F.map (category_theory.limits.biproduct.π (λ (i : M.ι), {ι := punit, F := punit.fintype, D := punit.decidable_eq, X := λ (_x : punit), M.X i}) j)) ≫ category_theory.limits.biproduct.desc (λ (j_1 : M.ι), F.map (λ (_x _x : punit), f j_1 j))
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.preadditive C,	D : Type u₁,	_inst_3 : category_theory.category D,	_inst_4 : category_theory.preadditive D,	_inst_5 : category_theory.limits.has_finite_biproducts D,	F : category_theory.Mat_ C ⥤ D,	_inst_6 : F.additive,	M N : category_theory.Mat_ C,	f : M ⟶ N,	j : N.ι	⊢ F.map (f ≫ λ (j_1 : N.ι) (k : punit), dite (j_1 = j) (λ (h : j_1 = j), category_theory.eq_to_hom _) (λ (h : ¬j_1 = j), 0)) = F.map (∑ (j_1 : M.ι), (λ (j : M.ι) (k : punit), dite (j = j_1) (λ (h : j = j_1), category_theory.eq_to_hom _) (λ (h : ¬j = j_1), 0)) ≫ λ (_x _x : punit), f j_1 j)
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.preadditive C,	D : Type u₁,	_inst_3 : category_theory.category D,	_inst_4 : category_theory.preadditive D,	_inst_5 : category_theory.limits.has_finite_biproducts D,	F : category_theory.Mat_ C ⥤ D,	_inst_6 : F.additive,	M N : category_theory.Mat_ C,	f : M ⟶ N,	j : N.ι	⊢ F.map (λ (i : M.ι) (k : {ι := punit, F := punit.fintype, D := punit.decidable_eq, X := λ (_x : punit), N.X j}.ι), f i j ≫ category_theory.eq_to_hom _) = F.map (∑ (j_1 : M.ι), λ (i : M.ι) (k : {ι := punit, F := punit.fintype, D := punit.decidable_eq, X := λ (_x : punit), N.X j}.ι), ∑ (j_2 : {ι := punit, F := punit.fintype, D := punit.decidable_eq, X := λ (_x : punit), M.X j_1}.ι), dite (i = j_1) (λ (h : i = j_1), category_theory.eq_to_hom _) (λ (h : ¬i = j_1), 0) ≫ f j_1 j)
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.preadditive C,	D : Type u₁,	_inst_3 : category_theory.category D,	_inst_4 : category_theory.preadditive D,	_inst_5 : category_theory.limits.has_finite_biproducts D,	F : category_theory.Mat_ C ⥤ D,	_inst_6 : F.additive,	M N : category_theory.Mat_ C,	f : M ⟶ N,	j : N.ι	⊢ F.map (λ (i : M.ι) (k : punit), f i j ≫ 𝟙 (N.X j)) = F.map (∑ (j_1 : M.ι), λ (i : M.ι) (k : punit), ∑ (j_2 : punit) in {punit.star}, dite (i = j_1) (λ (h : i = j_1), category_theory.eq_to_hom _) (λ (h : ¬i = j_1), 0) ≫ f j_1 j)
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.preadditive C,	D : Type u₁,	_inst_3 : category_theory.category D,	_inst_4 : category_theory.preadditive D,	_inst_5 : category_theory.limits.has_finite_biproducts D,	F : category_theory.Mat_ C ⥤ D,	_inst_6 : F.additive,	M N : category_theory.Mat_ C,	f : M ⟶ N,	j : N.ι	⊢ F.map (λ (i : M.ι) (k : punit), f i j ≫ 𝟙 (N.X j)) = F.map (∑ (j_1 : M.ι), λ (i : M.ι) (k : punit), dite (i = j_1) (λ (h : i = j_1), category_theory.eq_to_hom _ ≫ f j_1 j) (λ (h : ¬i = j_1), 0))
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.preadditive C,	D : Type u₁,	_inst_3 : category_theory.category D,	_inst_4 : category_theory.preadditive D,	_inst_5 : category_theory.limits.has_finite_biproducts D,	F : category_theory.Mat_ C ⥤ D,	_inst_6 : F.additive,	M N : category_theory.Mat_ C,	f : M ⟶ N,	j : N.ι	⊢ (λ (i : M.ι) (k : punit), f i j ≫ 𝟙 (N.X j)) = ∑ (j_1 : M.ι), λ (i : M.ι) (k : punit), dite (i = j_1) (λ (h : i = j_1), category_theory.eq_to_hom _ ≫ f j_1 j) (λ (h : ¬i = j_1), 0)
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.preadditive C,	D : Type u₁,	_inst_3 : category_theory.category D,	_inst_4 : category_theory.preadditive D,	_inst_5 : category_theory.limits.has_finite_biproducts D,	F : category_theory.Mat_ C ⥤ D,	_inst_6 : F.additive,	M N : category_theory.Mat_ C,	f : M ⟶ N,	j : N.ι	⊢ (∑ (j_1 : M.ι), λ (i : M.ι) (k : punit), dite (i = j_1) (λ (h : i = j_1), category_theory.eq_to_hom _ ≫ f j_1 j) (λ (h : ¬i = j_1), 0)) = λ (i : M.ι) (k : punit), f i j ≫ 𝟙 (N.X j)
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.preadditive C,	D : Type u₁,	_inst_3 : category_theory.category D,	_inst_4 : category_theory.preadditive D,	_inst_5 : category_theory.limits.has_finite_biproducts D,	F : category_theory.Mat_ C ⥤ D,	_inst_6 : F.additive,	M N : category_theory.Mat_ C,	f : M ⟶ N,	j : N.ι	⊢ (λ (i : M.ι) (k : punit), f i j ≫ 𝟙 (N.X j)) = λ (a : M.ι), ∑ (c : M.ι), λ (k : punit), dite (a = c) (λ (h : a = c), category_theory.eq_to_hom _ ≫ f c j) (λ (h : ¬a = c), 0)
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.preadditive C,	D : Type u₁,	_inst_3 : category_theory.category D,	_inst_4 : category_theory.preadditive D,	_inst_5 : category_theory.limits.has_finite_biproducts D,	F : category_theory.Mat_ C ⥤ D,	_inst_6 : F.additive,	M N : category_theory.Mat_ C,	f : M ⟶ N,	j : N.ι	⊢ (λ (i : M.ι) (k : punit), f i j ≫ 𝟙 (N.X j)) = λ (a : M.ι) (a_1 : punit), ite (a ∈ finset.univ) (category_theory.eq_to_hom _ ≫ f a j) 0
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.preadditive C,	D : Type u₁,	_inst_3 : category_theory.category D,	_inst_4 : category_theory.preadditive D,	_inst_5 : category_theory.limits.has_finite_biproducts D,	F : category_theory.Mat_ C ⥤ D,	_inst_6 : F.additive,	M N : category_theory.Mat_ C,	f : M ⟶ N,	j : N.ι,	x : M.ι,	x_1 : punit	⊢ f x j ≫ 𝟙 (N.X j) = ite (x ∈ finset.univ) (category_theory.eq_to_hom _ ≫ f x j) 0
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.limits.has_zero_object C,	_inst_3 : category_theory.preadditive C,	_inst_4 : category_theory.limits.has_equalizers C,	_inst_5 : category_theory.limits.has_images C,	Y Z : C,	P : category_theory.ProjectiveResolution Y,	Q : category_theory.ProjectiveResolution Z,	f : P.complex ⟶ Q.complex,	comm : f ≫ Q.π = 0	⊢ homotopy f 0
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.limits.has_zero_object C,	_inst_3 : category_theory.preadditive C,	_inst_4 : category_theory.limits.has_equalizers C,	_inst_5 : category_theory.limits.has_images C,	Y Z : C,	P : category_theory.ProjectiveResolution Y,	Q : category_theory.ProjectiveResolution Z,	f : P.complex ⟶ Q.complex,	comm : f ≫ Q.π = 0	⊢ P.complex.X 0 ⟶ Q.complex.X 1		C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.limits.has_zero_object C,	_inst_3 : category_theory.preadditive C,	_inst_4 : category_theory.limits.has_equalizers C,	_inst_5 : category_theory.limits.has_images C,	Y Z : C,	P : category_theory.ProjectiveResolution Y,	Q : category_theory.ProjectiveResolution Z,	f : P.complex ⟶ Q.complex,	comm : f ≫ Q.π = 0	⊢ f.f 0 = ?m_1 ≫ Q.complex.d 1 0		C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.limits.has_zero_object C,	_inst_3 : category_theory.preadditive C,	_inst_4 : category_theory.limits.has_equalizers C,	_inst_5 : category_theory.limits.has_images C,	Y Z : C,	P : category_theory.ProjectiveResolution Y,	Q : category_theory.ProjectiveResolution Z,	f : P.complex ⟶ Q.complex,	comm : f ≫ Q.π = 0	⊢ P.complex.X 1 ⟶ Q.complex.X 2		C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.limits.has_zero_object C,	_inst_3 : category_theory.preadditive C,	_inst_4 : category_theory.limits.has_equalizers C,	_inst_5 : category_theory.limits.has_images C,	Y Z : C,	P : category_theory.ProjectiveResolution Y,	Q : category_theory.ProjectiveResolution Z,	f : P.complex ⟶ Q.complex,	comm : f ≫ Q.π = 0	⊢ f.f 1 = P.complex.d 1 0 ≫ ?m_1 + ?m_2 ≫ Q.complex.d 2 1		C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.limits.has_zero_object C,	_inst_3 : category_theory.preadditive C,	_inst_4 : category_theory.limits.has_equalizers C,	_inst_5 : category_theory.limits.has_images C,	Y Z : C,	P : category_theory.ProjectiveResolution Y,	Q : category_theory.ProjectiveResolution Z,	f : P.complex ⟶ Q.complex,	comm : f ≫ Q.π = 0	⊢ Π (n : ℕ) (p : Σ' (f_1 : P.complex.X n ⟶ Q.complex.X (n + 1)) (f' : P.complex.X (n + 1) ⟶ Q.complex.X (n + 2)), f.f (n + 1) = P.complex.d (n + 1) n ≫ f_1 + f' ≫ Q.complex.d (n + 2) (n + 1)), Σ' (f'' : P.complex.X (n + 2) ⟶ Q.complex.X (n + 3)), f.f (n + 2) = P.complex.d (n + 2) (n + 1) ≫ p.snd.fst + f'' ≫ Q.complex.d (n + 3) (n + 2)
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.limits.has_zero_object C,	_inst_3 : category_theory.preadditive C,	_inst_4 : category_theory.limits.has_equalizers C,	_inst_5 : category_theory.limits.has_images C,	Y Z : C,	P : category_theory.ProjectiveResolution Y,	Q : category_theory.ProjectiveResolution Z,	f : P.complex ⟶ Q.complex,	comm : f ≫ Q.π = 0	⊢ P.complex.X 0 ⟶ Q.complex.X 1
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.limits.has_zero_object C,	_inst_3 : category_theory.preadditive C,	_inst_4 : category_theory.limits.has_equalizers C,	_inst_5 : category_theory.limits.has_images C,	Y Z : C,	P : category_theory.ProjectiveResolution Y,	Q : category_theory.ProjectiveResolution Z,	f : P.complex ⟶ Q.complex,	comm : f ≫ Q.π = 0	⊢ f.f 0 = category_theory.ProjectiveResolution.lift_homotopy_zero_zero f comm ≫ Q.complex.d 1 0		C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.limits.has_zero_object C,	_inst_3 : category_theory.preadditive C,	_inst_4 : category_theory.limits.has_equalizers C,	_inst_5 : category_theory.limits.has_images C,	Y Z : C,	P : category_theory.ProjectiveResolution Y,	Q : category_theory.ProjectiveResolution Z,	f : P.complex ⟶ Q.complex,	comm : f ≫ Q.π = 0	⊢ P.complex.X 1 ⟶ Q.complex.X 2		C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.limits.has_zero_object C,	_inst_3 : category_theory.preadditive C,	_inst_4 : category_theory.limits.has_equalizers C,	_inst_5 : category_theory.limits.has_images C,	Y Z : C,	P : category_theory.ProjectiveResolution Y,	Q : category_theory.ProjectiveResolution Z,	f : P.complex ⟶ Q.complex,	comm : f ≫ Q.π = 0	⊢ f.f 1 = P.complex.d 1 0 ≫ category_theory.ProjectiveResolution.lift_homotopy_zero_zero f comm + ?m_1 ≫ Q.complex.d 2 1		C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.limits.has_zero_object C,	_inst_3 : category_theory.preadditive C,	_inst_4 : category_theory.limits.has_equalizers C,	_inst_5 : category_theory.limits.has_images C,	Y Z : C,	P : category_theory.ProjectiveResolution Y,	Q : category_theory.ProjectiveResolution Z,	f : P.complex ⟶ Q.complex,	comm : f ≫ Q.π = 0	⊢ Π (n : ℕ) (p : Σ' (f_1 : P.complex.X n ⟶ Q.complex.X (n + 1)) (f' : P.complex.X (n + 1) ⟶ Q.complex.X (n + 2)), f.f (n + 1) = P.complex.d (n + 1) n ≫ f_1 + f' ≫ Q.complex.d (n + 2) (n + 1)), Σ' (f'' : P.complex.X (n + 2) ⟶ Q.complex.X (n + 3)), f.f (n + 2) = P.complex.d (n + 2) (n + 1) ≫ p.snd.fst + f'' ≫ Q.complex.d (n + 3) (n + 2)
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.limits.has_zero_object C,	_inst_3 : category_theory.preadditive C,	_inst_4 : category_theory.limits.has_equalizers C,	_inst_5 : category_theory.limits.has_images C,	Y Z : C,	P : category_theory.ProjectiveResolution Y,	Q : category_theory.ProjectiveResolution Z,	f : P.complex ⟶ Q.complex,	comm : f ≫ Q.π = 0	⊢ f.f 0 = category_theory.ProjectiveResolution.lift_homotopy_zero_zero f comm ≫ Q.complex.d 1 0
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.limits.has_zero_object C,	_inst_3 : category_theory.preadditive C,	_inst_4 : category_theory.limits.has_equalizers C,	_inst_5 : category_theory.limits.has_images C,	Y Z : C,	P : category_theory.ProjectiveResolution Y,	Q : category_theory.ProjectiveResolution Z,	f : P.complex ⟶ Q.complex,	comm : f ≫ Q.π = 0	⊢ P.complex.X 1 ⟶ Q.complex.X 2		C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.limits.has_zero_object C,	_inst_3 : category_theory.preadditive C,	_inst_4 : category_theory.limits.has_equalizers C,	_inst_5 : category_theory.limits.has_images C,	Y Z : C,	P : category_theory.ProjectiveResolution Y,	Q : category_theory.ProjectiveResolution Z,	f : P.complex ⟶ Q.complex,	comm : f ≫ Q.π = 0	⊢ f.f 1 = P.complex.d 1 0 ≫ category_theory.ProjectiveResolution.lift_homotopy_zero_zero f comm + ?m_1 ≫ Q.complex.d 2 1		C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.limits.has_zero_object C,	_inst_3 : category_theory.preadditive C,	_inst_4 : category_theory.limits.has_equalizers C,	_inst_5 : category_theory.limits.has_images C,	Y Z : C,	P : category_theory.ProjectiveResolution Y,	Q : category_theory.ProjectiveResolution Z,	f : P.complex ⟶ Q.complex,	comm : f ≫ Q.π = 0	⊢ Π (n : ℕ) (p : Σ' (f_1 : P.complex.X n ⟶ Q.complex.X (n + 1)) (f' : P.complex.X (n + 1) ⟶ Q.complex.X (n + 2)), f.f (n + 1) = P.complex.d (n + 1) n ≫ f_1 + f' ≫ Q.complex.d (n + 2) (n + 1)), Σ' (f'' : P.complex.X (n + 2) ⟶ Q.complex.X (n + 3)), f.f (n + 2) = P.complex.d (n + 2) (n + 1) ≫ p.snd.fst + f'' ≫ Q.complex.d (n + 3) (n + 2)
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.limits.has_zero_object C,	_inst_3 : category_theory.preadditive C,	_inst_4 : category_theory.limits.has_equalizers C,	_inst_5 : category_theory.limits.has_images C,	Y Z : C,	P : category_theory.ProjectiveResolution Y,	Q : category_theory.ProjectiveResolution Z,	f : P.complex ⟶ Q.complex,	comm : f ≫ Q.π = 0	⊢ P.complex.X 1 ⟶ Q.complex.X 2
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.limits.has_zero_object C,	_inst_3 : category_theory.preadditive C,	_inst_4 : category_theory.limits.has_equalizers C,	_inst_5 : category_theory.limits.has_images C,	Y Z : C,	P : category_theory.ProjectiveResolution Y,	Q : category_theory.ProjectiveResolution Z,	f : P.complex ⟶ Q.complex,	comm : f ≫ Q.π = 0	⊢ f.f 1 = P.complex.d 1 0 ≫ category_theory.ProjectiveResolution.lift_homotopy_zero_zero f comm + category_theory.ProjectiveResolution.lift_homotopy_zero_one f comm ≫ Q.complex.d 2 1		C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.limits.has_zero_object C,	_inst_3 : category_theory.preadditive C,	_inst_4 : category_theory.limits.has_equalizers C,	_inst_5 : category_theory.limits.has_images C,	Y Z : C,	P : category_theory.ProjectiveResolution Y,	Q : category_theory.ProjectiveResolution Z,	f : P.complex ⟶ Q.complex,	comm : f ≫ Q.π = 0	⊢ Π (n : ℕ) (p : Σ' (f_1 : P.complex.X n ⟶ Q.complex.X (n + 1)) (f' : P.complex.X (n + 1) ⟶ Q.complex.X (n + 2)), f.f (n + 1) = P.complex.d (n + 1) n ≫ f_1 + f' ≫ Q.complex.d (n + 2) (n + 1)), Σ' (f'' : P.complex.X (n + 2) ⟶ Q.complex.X (n + 3)), f.f (n + 2) = P.complex.d (n + 2) (n + 1) ≫ p.snd.fst + f'' ≫ Q.complex.d (n + 3) (n + 2)
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.limits.has_zero_object C,	_inst_3 : category_theory.preadditive C,	_inst_4 : category_theory.limits.has_equalizers C,	_inst_5 : category_theory.limits.has_images C,	Y Z : C,	P : category_theory.ProjectiveResolution Y,	Q : category_theory.ProjectiveResolution Z,	f : P.complex ⟶ Q.complex,	comm : f ≫ Q.π = 0	⊢ f.f 1 = P.complex.d 1 0 ≫ category_theory.ProjectiveResolution.lift_homotopy_zero_zero f comm + category_theory.ProjectiveResolution.lift_homotopy_zero_one f comm ≫ Q.complex.d 2 1
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.limits.has_zero_object C,	_inst_3 : category_theory.preadditive C,	_inst_4 : category_theory.limits.has_equalizers C,	_inst_5 : category_theory.limits.has_images C,	Y Z : C,	P : category_theory.ProjectiveResolution Y,	Q : category_theory.ProjectiveResolution Z,	f : P.complex ⟶ Q.complex,	comm : f ≫ Q.π = 0	⊢ Π (n : ℕ) (p : Σ' (f_1 : P.complex.X n ⟶ Q.complex.X (n + 1)) (f' : P.complex.X (n + 1) ⟶ Q.complex.X (n + 2)), f.f (n + 1) = P.complex.d (n + 1) n ≫ f_1 + f' ≫ Q.complex.d (n + 2) (n + 1)), Σ' (f'' : P.complex.X (n + 2) ⟶ Q.complex.X (n + 3)), f.f (n + 2) = P.complex.d (n + 2) (n + 1) ≫ p.snd.fst + f'' ≫ Q.complex.d (n + 3) (n + 2)
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.limits.has_zero_object C,	_inst_3 : category_theory.preadditive C,	_inst_4 : category_theory.limits.has_equalizers C,	_inst_5 : category_theory.limits.has_images C,	Y Z : C,	P : category_theory.ProjectiveResolution Y,	Q : category_theory.ProjectiveResolution Z,	f : P.complex ⟶ Q.complex,	comm : f ≫ Q.π = 0,	n : ℕ,	g : P.complex.X n ⟶ Q.complex.X (n + 1),	g' : P.complex.X (n + 1) ⟶ Q.complex.X (n + 2),	w : f.f (n + 1) = P.complex.d (n + 1) n ≫ g + g' ≫ Q.complex.d (n + 2) (n + 1)	⊢ Σ' (f'' : P.complex.X (n + 2) ⟶ Q.complex.X (n + 3)), f.f (n + 2) = P.complex.d (n + 2) (n + 1) ≫ ⟨g, ⟨g', w⟩⟩.snd.fst + f'' ≫ Q.complex.d (n + 3) (n + 2)
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.limits.has_zero_object C,	_inst_3 : category_theory.preadditive C,	_inst_4 : category_theory.limits.has_equalizers C,	_inst_5 : category_theory.limits.has_images C,	Y Z : C,	P : category_theory.ProjectiveResolution Y,	Q : category_theory.ProjectiveResolution Z,	f : P.complex ⟶ Q.complex,	comm : f ≫ Q.π = 0,	n : ℕ,	g : P.complex.X n ⟶ Q.complex.X (n + 1),	g' : P.complex.X (n + 1) ⟶ Q.complex.X (n + 2),	w : f.f (n + 1) = P.complex.d (n + 1) n ≫ g + g' ≫ Q.complex.d (n + 2) (n + 1)	⊢ P.complex.X (n + 2) ⟶ Q.complex.X (n + 3)		C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.limits.has_zero_object C,	_inst_3 : category_theory.preadditive C,	_inst_4 : category_theory.limits.has_equalizers C,	_inst_5 : category_theory.limits.has_images C,	Y Z : C,	P : category_theory.ProjectiveResolution Y,	Q : category_theory.ProjectiveResolution Z,	f : P.complex ⟶ Q.complex,	comm : f ≫ Q.π = 0,	n : ℕ,	g : P.complex.X n ⟶ Q.complex.X (n + 1),	g' : P.complex.X (n + 1) ⟶ Q.complex.X (n + 2),	w : f.f (n + 1) = P.complex.d (n + 1) n ≫ g + g' ≫ Q.complex.d (n + 2) (n + 1)	⊢ f.f (n + 2) = P.complex.d (n + 2) (n + 1) ≫ ⟨g, ⟨g', w⟩⟩.snd.fst + ?m_1 ≫ Q.complex.d (n + 3) (n + 2)
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.limits.has_zero_object C,	_inst_3 : category_theory.preadditive C,	_inst_4 : category_theory.limits.has_equalizers C,	_inst_5 : category_theory.limits.has_images C,	Y Z : C,	P : category_theory.ProjectiveResolution Y,	Q : category_theory.ProjectiveResolution Z,	f : P.complex ⟶ Q.complex,	comm : f ≫ Q.π = 0,	n : ℕ,	g : P.complex.X n ⟶ Q.complex.X (n + 1),	g' : P.complex.X (n + 1) ⟶ Q.complex.X (n + 2),	w : f.f (n + 1) = P.complex.d (n + 1) n ≫ g + g' ≫ Q.complex.d (n + 2) (n + 1)	⊢ P.complex.X (n + 2) ⟶ Q.complex.X (n + 3)
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.limits.has_zero_object C,	_inst_3 : category_theory.preadditive C,	_inst_4 : category_theory.limits.has_equalizers C,	_inst_5 : category_theory.limits.has_images C,	Y Z : C,	P : category_theory.ProjectiveResolution Y,	Q : category_theory.ProjectiveResolution Z,	f : P.complex ⟶ Q.complex,	comm : f ≫ Q.π = 0,	n : ℕ,	g : P.complex.X n ⟶ Q.complex.X (n + 1),	g' : P.complex.X (n + 1) ⟶ Q.complex.X (n + 2),	w : f.f (n + 1) = P.complex.d (n + 1) n ≫ g + g' ≫ Q.complex.d (n + 2) (n + 1)	⊢ f.f (n + 2) = P.complex.d (n + 2) (n + 1) ≫ ⟨g, ⟨g', w⟩⟩.snd.fst + category_theory.ProjectiveResolution.lift_homotopy_zero_succ f n g g' w ≫ Q.complex.d (n + 3) (n + 2)
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.preadditive C,	𝕜 : Type u_1,	_inst_3 : field 𝕜,	_inst_4 : category_theory.limits.has_kernels C,	_inst_5 : category_theory.linear 𝕜 C,	X Y : C,	_inst_6 : category_theory.simple X,	_inst_7 : category_theory.simple Y,	h : (X ≅ Y) → false	⊢ finite_dimensional.finrank 𝕜 (X ⟶ Y) = 0
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.preadditive C,	𝕜 : Type u_1,	_inst_3 : field 𝕜,	_inst_4 : category_theory.limits.has_kernels C,	_inst_5 : category_theory.linear 𝕜 C,	X Y : C,	_inst_6 : category_theory.simple X,	_inst_7 : category_theory.simple Y,	h : (X ≅ Y) → false,	f : X ⟶ Y	⊢ f = 0
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.preadditive C,	𝕜 : Type u_1,	_inst_3 : field 𝕜,	_inst_4 : category_theory.limits.has_kernels C,	_inst_5 : category_theory.linear 𝕜 C,	X Y : C,	_inst_6 : category_theory.simple X,	_inst_7 : category_theory.simple Y,	h : (X ≅ Y) → false,	f : X ⟶ Y,	p : ¬category_theory.is_iso f ↔ ¬f ≠ 0	⊢ f = 0
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.preadditive C,	𝕜 : Type u_1,	_inst_3 : field 𝕜,	_inst_4 : category_theory.limits.has_kernels C,	_inst_5 : category_theory.linear 𝕜 C,	X Y : C,	_inst_6 : category_theory.simple X,	_inst_7 : category_theory.simple Y,	h : (X ≅ Y) → false,	f : X ⟶ Y,	p : ¬category_theory.is_iso f ↔ f = 0,	_x : category_theory.is_iso f	⊢ false
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.preadditive C,	𝕜 : Type u_1,	_inst_3 : field 𝕜,	_inst_4 : category_theory.limits.has_kernels C,	_inst_5 : category_theory.linear 𝕜 C,	X Y : C,	_inst_6 : category_theory.simple X,	_inst_7 : category_theory.simple Y,	h : (X ≅ Y) → false,	f : X ⟶ Y,	p : ¬category_theory.is_iso f ↔ f = 0	⊢ f = 0
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.preadditive C,	𝕜 : Type u_1,	_inst_3 : field 𝕜,	_inst_4 : category_theory.limits.has_kernels C,	_inst_5 : category_theory.linear 𝕜 C,	X Y : C,	_inst_6 : category_theory.simple X,	_inst_7 : category_theory.simple Y,	h : (X ≅ Y) → false,	_inst : subsingleton (X ⟶ Y)	⊢ finite_dimensional.finrank 𝕜 (X ⟶ Y) = 0
C : Type u_1,	_inst_1 : category_theory.category C,	r : hom_rel C,	a b c : C,	f : a ⟶ b,	comp_left : ∀ (g₁ g₂ : b ⟶ c), category_theory.quotient.comp_closure r g₁ g₂ → category_theory.quotient.comp_closure r (f ≫ g₁) (f ≫ g₂),	__mlocal__fresh_1306_144 __mlocal__fresh_1306_145 : C,	x : b ⟶ __mlocal__fresh_1306_144,	m₁ m₂ : __mlocal__fresh_1306_144 ⟶ __mlocal__fresh_1306_145,	y : __mlocal__fresh_1306_145 ⟶ c,	h : r m₁ m₂	⊢ category_theory.quotient.comp_closure r (f ≫ x ≫ m₁ ≫ y) (f ≫ x ≫ m₂ ≫ y)
α : Type u,	β : Type v,	_inst_1 : monoid α,	_inst_2 : monoid β,	f : category_theory.single_obj α ⥤ category_theory.single_obj β	⊢ (λ (f : α →* β), {obj := id (category_theory.single_obj α), map := λ (_x _x : category_theory.single_obj α), ⇑f, map_id' := _, map_comp' := _}) ((λ (f : category_theory.single_obj α ⥤ category_theory.single_obj β), {to_fun := f.map (category_theory.single_obj.star α), map_one' := _, map_mul' := _}) f) = f
α : Type u,	β : Type v,	_inst_1 : monoid α,	_inst_2 : monoid β,	f : category_theory.single_obj α ⥤ category_theory.single_obj β	⊢ (λ (f : α →* β), {obj := id (category_theory.single_obj α), map := λ (_x _x : category_theory.single_obj α), ⇑f, map_id' := _, map_comp' := _}) ((λ (f : category_theory.single_obj α ⥤ category_theory.single_obj β), {to_fun := f.map (category_theory.single_obj.star α), map_one' := _, map_mul' := _}) f) = f
α : Type u,	β : Type v,	_inst_1 : monoid α,	_inst_2 : monoid β,	f_obj : category_theory.single_obj α → category_theory.single_obj β,	f_map : Π {X Y : category_theory.single_obj α}, (X ⟶ Y) → (f_obj X ⟶ f_obj Y),	f_map_id' : auto_param (∀ (X : category_theory.single_obj α), f_map (𝟙 X) = 𝟙 (f_obj X)) (name.mk_string "obviously" name.anonymous),	f_map_comp' : auto_param (∀ {X Y Z : category_theory.single_obj α} (f : X ⟶ Y) (g : Y ⟶ Z), f_map (f ≫ g) = f_map f ≫ f_map g) (name.mk_string "obviously" name.anonymous)	⊢ (λ (f : α →* β), {obj := id (category_theory.single_obj α), map := λ (_x _x : category_theory.single_obj α), ⇑f, map_id' := _, map_comp' := _}) ((λ (f : category_theory.single_obj α ⥤ category_theory.single_obj β), {to_fun := f.map (category_theory.single_obj.star α), map_one' := _, map_mul' := _}) {obj := f_obj, map := f_map, map_id' := f_map_id', map_comp' := f_map_comp'}) = {obj := f_obj, map := f_map, map_id' := f_map_id', map_comp' := f_map_comp'}
C : Type u,	_inst_1 : category_theory.category C,	X : C,	J : category_theory.grothendieck_topology C,	S : category_theory.sieve X	⊢ S ∈ ⇑J X ↔ J.covers S (𝟙 X)
C : Type u,	_inst_1 : category_theory.category C,	J₂ : category_theory.grothendieck_topology C,	J₁_sieves : Π (X : C), set (category_theory.sieve X),	J₁_top_mem' : ∀ (X : C), ⊤ ∈ J₁_sieves X,	J₁_pullback_stable' : ∀ ⦃X Y : C⦄ ⦃S : category_theory.sieve X⦄ (f : Y ⟶ X), S ∈ J₁_sieves X → category_theory.sieve.pullback f S ∈ J₁_sieves Y,	J₁_transitive' : ∀ ⦃X : C⦄ ⦃S : category_theory.sieve X⦄, S ∈ J₁_sieves X → ∀ (R : category_theory.sieve X), (∀ ⦃Y : C⦄ ⦃f : Y ⟶ X⦄, ⇑S f → category_theory.sieve.pullback f R ∈ J₁_sieves Y) → R ∈ J₁_sieves X,	h : ⇑{sieves := J₁_sieves, top_mem' := J₁_top_mem', pullback_stable' := J₁_pullback_stable', transitive' := J₁_transitive'} = ⇑J₂	⊢ {sieves := J₁_sieves, top_mem' := J₁_top_mem', pullback_stable' := J₁_pullback_stable', transitive' := J₁_transitive'} = J₂
C : Type u,	_inst_1 : category_theory.category C,	J₁_sieves : Π (X : C), set (category_theory.sieve X),	J₁_top_mem' : ∀ (X : C), ⊤ ∈ J₁_sieves X,	J₁_pullback_stable' : ∀ ⦃X Y : C⦄ ⦃S : category_theory.sieve X⦄ (f : Y ⟶ X), S ∈ J₁_sieves X → category_theory.sieve.pullback f S ∈ J₁_sieves Y,	J₁_transitive' : ∀ ⦃X : C⦄ ⦃S : category_theory.sieve X⦄, S ∈ J₁_sieves X → ∀ (R : category_theory.sieve X), (∀ ⦃Y : C⦄ ⦃f : Y ⟶ X⦄, ⇑S f → category_theory.sieve.pullback f R ∈ J₁_sieves Y) → R ∈ J₁_sieves X,	J₂_sieves : Π (X : C), set (category_theory.sieve X),	J₂_top_mem' : ∀ (X : C), ⊤ ∈ J₂_sieves X,	J₂_pullback_stable' : ∀ ⦃X Y : C⦄ ⦃S : category_theory.sieve X⦄ (f : Y ⟶ X), S ∈ J₂_sieves X → category_theory.sieve.pullback f S ∈ J₂_sieves Y,	J₂_transitive' : ∀ ⦃X : C⦄ ⦃S : category_theory.sieve X⦄, S ∈ J₂_sieves X → ∀ (R : category_theory.sieve X), (∀ ⦃Y : C⦄ ⦃f : Y ⟶ X⦄, ⇑S f → category_theory.sieve.pullback f R ∈ J₂_sieves Y) → R ∈ J₂_sieves X,	h : ⇑{sieves := J₁_sieves, top_mem' := J₁_top_mem', pullback_stable' := J₁_pullback_stable', transitive' := J₁_transitive'} = ⇑{sieves := J₂_sieves, top_mem' := J₂_top_mem', pullback_stable' := J₂_pullback_stable', transitive' := J₂_transitive'}	⊢ {sieves := J₁_sieves, top_mem' := J₁_top_mem', pullback_stable' := J₁_pullback_stable', transitive' := J₁_transitive'} = {sieves := J₂_sieves, top_mem' := J₂_top_mem', pullback_stable' := J₂_pullback_stable', transitive' := J₂_transitive'}
C : Type u,	_inst_1 : category_theory.category C,	J₁_sieves : Π (X : C), set (category_theory.sieve X),	J₁_top_mem' : ∀ (X : C), ⊤ ∈ J₁_sieves X,	J₁_pullback_stable' : ∀ ⦃X Y : C⦄ ⦃S : category_theory.sieve X⦄ (f : Y ⟶ X), S ∈ J₁_sieves X → category_theory.sieve.pullback f S ∈ J₁_sieves Y,	J₁_transitive' : ∀ ⦃X : C⦄ ⦃S : category_theory.sieve X⦄, S ∈ J₁_sieves X → ∀ (R : category_theory.sieve X), (∀ ⦃Y : C⦄ ⦃f : Y ⟶ X⦄, ⇑S f → category_theory.sieve.pullback f R ∈ J₁_sieves Y) → R ∈ J₁_sieves X,	J₂_sieves : Π (X : C), set (category_theory.sieve X),	J₂_top_mem' : ∀ (X : C), ⊤ ∈ J₂_sieves X,	J₂_pullback_stable' : ∀ ⦃X Y : C⦄ ⦃S : category_theory.sieve X⦄ (f : Y ⟶ X), S ∈ J₂_sieves X → category_theory.sieve.pullback f S ∈ J₂_sieves Y,	J₂_transitive' : ∀ ⦃X : C⦄ ⦃S : category_theory.sieve X⦄, S ∈ J₂_sieves X → ∀ (R : category_theory.sieve X), (∀ ⦃Y : C⦄ ⦃f : Y ⟶ X⦄, ⇑S f → category_theory.sieve.pullback f R ∈ J₂_sieves Y) → R ∈ J₂_sieves X,	h : ⇑{sieves := J₁_sieves, top_mem' := J₁_top_mem', pullback_stable' := J₁_pullback_stable', transitive' := J₁_transitive'} = ⇑{sieves := J₂_sieves, top_mem' := J₂_top_mem', pullback_stable' := J₂_pullback_stable', transitive' := J₂_transitive'}	⊢ J₁_sieves = J₂_sieves
C : Type u,	_inst_1 : category_theory.category C,	J₁ J₂ : category_theory.grothendieck_topology C,	h : ⇑J₁ = ⇑J₂	⊢ J₁ = J₂
C : Type u,	_inst_1 : category_theory.category C,	X : C,	P : Cᵒᵖ ⥤ Type v,	S : category_theory.sieve X,	R : category_theory.presieve X,	h : ⇑S ≤ R,	trans : ∀ ⦃Y : C⦄ (f : Y ⟶ X), category_theory.presieve.is_sheaf_for P ⇑(category_theory.sieve.pullback f S)	⊢ category_theory.presieve.is_sheaf_for P ⇑S
C : Type u,	_inst_1 : category_theory.category C,	X Y : C,	f : Y ⟶ X,	_inst_2 : category_theory.limits.has_pullbacks C,	ι : Type u_1,	Z : ι → C,	g : Π (i : ι), Z i ⟶ X	⊢ category_theory.presieve.of_arrows (λ (i : ι), category_theory.limits.pullback (g i) f) (λ (i : ι), category_theory.limits.pullback.snd) = category_theory.presieve.pullback_arrows f (category_theory.presieve.of_arrows Z g)
C : Type u,	_inst_1 : category_theory.category C,	X Y : C,	f : Y ⟶ X,	_inst_2 : category_theory.limits.has_pullbacks C,	ι : Type u_1,	Z : ι → C,	g : Π (i : ι), Z i ⟶ X,	T : C,	h : T ⟶ Y	⊢ h ∈ category_theory.presieve.of_arrows (λ (i : ι), category_theory.limits.pullback (g i) f) (λ (i : ι), category_theory.limits.pullback.snd) ↔ h ∈ category_theory.presieve.pullback_arrows f (category_theory.presieve.of_arrows Z g)
C : Type u,	_inst_1 : category_theory.category C,	X Y : C,	f : Y ⟶ X,	_inst_2 : category_theory.limits.has_pullbacks C,	ι : Type u_1,	Z : ι → C,	g : Π (i : ι), Z i ⟶ X,	T : C,	h : T ⟶ Y	⊢ h ∈ category_theory.presieve.of_arrows (λ (i : ι), category_theory.limits.pullback (g i) f) (λ (i : ι), category_theory.limits.pullback.snd) → h ∈ category_theory.presieve.pullback_arrows f (category_theory.presieve.of_arrows Z g)
C : Type u,	_inst_1 : category_theory.category C,	X Y : C,	f : Y ⟶ X,	_inst_2 : category_theory.limits.has_pullbacks C,	ι : Type u_1,	Z : ι → C,	g : Π (i : ι), Z i ⟶ X,	hk : ι,	ᾰ : (category_theory.limits.limit.cone (category_theory.limits.cospan (g hk) f)).π.app category_theory.limits.walking_cospan.right ∈ category_theory.presieve.of_arrows (λ (i : ι), category_theory.limits.pullback (g i) f) (λ (i : ι), category_theory.limits.pullback.snd)	⊢ (category_theory.limits.limit.cone (category_theory.limits.cospan (g hk) f)).π.app category_theory.limits.walking_cospan.right ∈ category_theory.presieve.pullback_arrows f (category_theory.presieve.of_arrows Z g)
C : Type u,	_inst_1 : category_theory.category C,	X Y : C,	f : Y ⟶ X,	_inst_2 : category_theory.limits.has_pullbacks C,	ι : Type u_1,	Z : ι → C,	g : Π (i : ι), Z i ⟶ X,	T : C,	h : T ⟶ Y	⊢ h ∈ category_theory.presieve.of_arrows (λ (i : ι), category_theory.limits.pullback (g i) f) (λ (i : ι), category_theory.limits.pullback.snd) → h ∈ category_theory.presieve.pullback_arrows f (category_theory.presieve.of_arrows Z g)		C : Type u,	_inst_1 : category_theory.category C,	X Y : C,	f : Y ⟶ X,	_inst_2 : category_theory.limits.has_pullbacks C,	ι : Type u_1,	Z : ι → C,	g : Π (i : ι), Z i ⟶ X,	T : C,	h : T ⟶ Y	⊢ h ∈ category_theory.presieve.pullback_arrows f (category_theory.presieve.of_arrows Z g) → h ∈ category_theory.presieve.of_arrows (λ (i : ι), category_theory.limits.pullback (g i) f) (λ (i : ι), category_theory.limits.pullback.snd)
C : Type u,	_inst_1 : category_theory.category C,	X Y : C,	f : Y ⟶ X,	_inst_2 : category_theory.limits.has_pullbacks C,	ι : Type u_1,	Z : ι → C,	g : Π (i : ι), Z i ⟶ X,	T : C,	h : T ⟶ Y	⊢ h ∈ category_theory.presieve.pullback_arrows f (category_theory.presieve.of_arrows Z g) → h ∈ category_theory.presieve.of_arrows (λ (i : ι), category_theory.limits.pullback (g i) f) (λ (i : ι), category_theory.limits.pullback.snd)
C : Type u,	_inst_1 : category_theory.category C,	X Y : C,	f : Y ⟶ X,	_inst_2 : category_theory.limits.has_pullbacks C,	ι : Type u_1,	Z : ι → C,	g : Π (i : ι), Z i ⟶ X,	W : C,	k : W ⟶ X,	hk₁ : category_theory.presieve.of_arrows Z g k,	ᾰ : (category_theory.limits.limit.cone (category_theory.limits.cospan k f)).π.app category_theory.limits.walking_cospan.right ∈ category_theory.presieve.pullback_arrows f (category_theory.presieve.of_arrows Z g)	⊢ (category_theory.limits.limit.cone (category_theory.limits.cospan k f)).π.app category_theory.limits.walking_cospan.right ∈ category_theory.presieve.of_arrows (λ (i : ι), category_theory.limits.pullback (g i) f) (λ (i : ι), category_theory.limits.pullback.snd)
C : Type u,	_inst_1 : category_theory.category C,	X Y : C,	f : Y ⟶ X,	_inst_2 : category_theory.limits.has_pullbacks C,	ι : Type u_1,	Z : ι → C,	g : Π (i : ι), Z i ⟶ X,	i : ι,	hk₁ : category_theory.presieve.of_arrows Z g (g i),	ᾰ : (category_theory.limits.limit.cone (category_theory.limits.cospan (g i) f)).π.app category_theory.limits.walking_cospan.right ∈ category_theory.presieve.pullback_arrows f (category_theory.presieve.of_arrows Z g)	⊢ (category_theory.limits.limit.cone (category_theory.limits.cospan (g i) f)).π.app category_theory.limits.walking_cospan.right ∈ category_theory.presieve.of_arrows (λ (i : ι), category_theory.limits.pullback (g i) f) (λ (i : ι), category_theory.limits.pullback.snd)
C : Type u,	_inst_1 : category_theory.category C,	X : C,	S R : category_theory.sieve X	⊢ ∀ {Y Z : C} {f : Y ⟶ X}, ⇑S f ∧ ⇑R f → ∀ (g : Z ⟶ Y), ⇑S (g ≫ f) ∧ ⇑R (g ≫ f)
C : Type u,	_inst_1 : category_theory.category C,	X : C,	S R : category_theory.sieve X,	Y Z : C,	f : Y ⟶ X,	g : Z ⟶ Y,	h₁ : ⇑S f,	h₂ : ⇑R f	⊢ ⇑S (g ≫ f) ∧ ⇑R (g ≫ f)
C : Type u,	_inst_1 : category_theory.category C,	X Y : C,	S : category_theory.sieve X,	f : Y ⟶ X	⊢ ⇑S f ↔ category_theory.sieve.pullback f S = ⊤
C : Type u₁,	_inst_1 : category_theory.category C,	D : Type u₂,	_inst_2 : category_theory.category D,	S : D,	T : C ⥤ D,	f_left : auto_param (category_theory.discrete punit) (name.mk_string "obviously" name.anonymous),	f_right : auto_param C (name.mk_string "obviously" name.anonymous),	f_hom : (category_theory.functor.from_punit S).obj f_left ⟶ T.obj f_right	⊢ {left := f_left, right := f_right, hom := f_hom} = category_theory.structured_arrow.mk {left := f_left, right := f_right, hom := f_hom}.hom
C : Type u₁,	_inst_1 : category_theory.category C,	D : Type u₂,	_inst_2 : category_theory.category D,	S : D,	T : C ⥤ D,	f_left : auto_param (category_theory.discrete punit) (name.mk_string "obviously" name.anonymous),	f_right : auto_param C (name.mk_string "obviously" name.anonymous),	f_hom : (category_theory.functor.from_punit S).obj f_left ⟶ T.obj f_right	⊢ f_left = punit.star
C : Type u₁,	_inst_1 : category_theory.category C,	D : Type u₂,	_inst_2 : category_theory.category D,	S : D,	T : C ⥤ D,	f : category_theory.structured_arrow S T	⊢ f = category_theory.structured_arrow.mk f.hom
C : Type u₁,	_inst_1 : category_theory.category C,	D : Type u₂,	_inst_2 : category_theory.category D,	S : D,	T : C ⥤ D,	f f' : category_theory.structured_arrow S T,	g : f.right ≅ f'.right,	w : f.hom ≫ T.map g.hom = f'.hom	⊢ f.left = f'.left
C : Type u₁,	_inst_1 : category_theory.category C,	D : Type u₂,	_inst_2 : category_theory.category D,	S : D,	T : C ⥤ D,	f f' : category_theory.structured_arrow S T,	g : f.right ≅ f'.right,	w : f.hom ≫ T.map g.hom = f'.hom	⊢ (category_theory.functor.from_punit S).map (category_theory.eq_to_iso punit.ext).hom ≫ f'.hom = f.hom ≫ T.map g.hom
C : Type u₁,	_inst_1 : category_theory.category C,	B A₁ A₂ : C,	X : category_theory.subobject B,	f : A₁ ⟶ B,	_inst_3 : category_theory.mono f,	g : A₂ ⟶ B,	_inst_4 : category_theory.mono g,	h₁ : X ≤ category_theory.subobject.mk f,	h₂ : category_theory.subobject.mk f ≤ category_theory.subobject.mk g	⊢ X.of_le_mk f h₁ ≫ category_theory.subobject.of_mk_le_mk f g h₂ = X.of_le_mk g _
C : Type u₁,	_inst_1 : category_theory.category C,	X : C	⊢ ∀ (a : category_theory.subobject X), a ≤ ⊤
C : Type u₁,	_inst_1 : category_theory.category C,	X : C,	f : category_theory.mono_over X	⊢ quotient.mk' f ≤ ⊤
C : Type u₁,	_inst_1 : category_theory.category C,	_inst_3 : category_theory.limits.has_zero_object C,	_inst_4 : category_theory.limits.has_zero_morphisms C,	B : C	⊢ (category_theory.limits.initial_is_initial.unique_up_to_iso category_theory.limits.has_zero_object.zero_is_initial).hom ≫ 0 = category_theory.limits.initial.to B
C : Type u,	_inst_1 : category_theory.category C,	X Y : C,	f : X ⟶ Y,	_inst_2 : category_theory.limits.has_image f,	W : C,	k : W ⟶ X	⊢ (k ≫ category_theory.limits.factor_thru_image f) ≫ (category_theory.mono_over.mk' (category_theory.limits.image.ι f)).arrow = k ≫ f
C : Type u,	_inst_1 : category_theory.category C,	X Y : C,	f g : X ⟶ Y,	_inst_2 : category_theory.limits.has_equalizer f g,	W : C,	h : W ⟶ X,	w : h ≫ f = h ≫ g	⊢ category_theory.limits.equalizer.lift h w ≫ (category_theory.mono_over.mk' (category_theory.limits.equalizer.ι f g)).arrow = h
C : Type u₁,	_inst_1 : category_theory.category C,	A : C,	_inst_2 : category_theory.limits.has_binary_product A A,	_inst_3 : category_theory.is_iso (category_theory.limits.diag A),	Z : C,	f g : Z ⟶ A	⊢ f = g
C : Type u₁,	_inst_1 : category_theory.category C,	A : C,	_inst_2 : category_theory.limits.has_binary_product A A,	_inst_3 : category_theory.is_iso (category_theory.limits.diag A),	Z : C,	f g : Z ⟶ A	⊢ category_theory.limits.prod.fst = category_theory.limits.prod.snd		C : Type u₁,	_inst_1 : category_theory.category C,	A : C,	_inst_2 : category_theory.limits.has_binary_product A A,	_inst_3 : category_theory.is_iso (category_theory.limits.diag A),	Z : C,	f g : Z ⟶ A,	this : category_theory.limits.prod.fst = category_theory.limits.prod.snd	⊢ f = g
C : Type u₁,	_inst_1 : category_theory.category C,	A : C,	_inst_2 : category_theory.limits.has_binary_product A A,	_inst_3 : category_theory.is_iso (category_theory.limits.diag A),	Z : C,	f g : Z ⟶ A	⊢ category_theory.limits.prod.fst = category_theory.limits.prod.snd
C : Type u₁,	_inst_1 : category_theory.category C,	A : C,	_inst_2 : category_theory.limits.has_binary_product A A,	_inst_3 : category_theory.is_iso (category_theory.limits.diag A),	Z : C,	f g : Z ⟶ A,	this : category_theory.limits.prod.fst = category_theory.limits.prod.snd	⊢ f = g
C : Type u₁,	_inst_1 : category_theory.category C,	D : Type u₁,	_inst_2 : category_theory.category D	⊢ category_theory.is_equivalence (category_theory.sum.swap.equivalence C D).functor
α β : Type u,	f : α → β,	_inst_1 : category_theory.is_iso (↾f)	⊢ category_theory.mono (↾f)
α β : Type u,	f : α → β,	_inst_1 : category_theory.is_iso (↾f)	⊢ ↾f ≫ category_theory.inv (↾f) = 𝟙 α
n : ℕ,	i : fin (composition.ones n).length	⊢ (composition.ones n).blocks_fun i = 1
α : Type u_1,	_inst_1 : decidable_eq α	⊢ ↥(derangements (option α)) ≃ Σ (a : α), ↥{f : equiv.perm α | function.fixed_points ⇑f ⊆ {a}}
α : Type u_1,	_inst_1 : decidable_eq α	⊢ ↥∅ → false
α : Type u_1,	_inst_1 : decidable_eq α	⊢ ↥(derangements.equiv.remove_none.fiber option.none) → false		α : Type u_1,	_inst_1 : decidable_eq α,	fiber_none_is_false : ↥(derangements.equiv.remove_none.fiber option.none) → false	⊢ ↥(derangements (option α)) ≃ Σ (a : α), ↥{f : equiv.perm α | function.fixed_points ⇑f ⊆ {a}}
α : Type u_1,	_inst_1 : decidable_eq α	⊢ ↥(derangements.equiv.remove_none.fiber option.none) → false
α : Type u_1,	_inst_1 : decidable_eq α,	fiber_none_is_false : ↥(derangements.equiv.remove_none.fiber option.none) → false	⊢ ↥(derangements (option α)) ≃ Σ (a : α), ↥{f : equiv.perm α | function.fixed_points ⇑f ⊆ {a}}
α : Type u_1,	_inst_1 : decidable_eq α,	fiber_none_is_false : ↥(derangements.equiv.remove_none.fiber option.none) → false	⊢ (Σ (a : α), ↥(derangements.equiv.remove_none.fiber (option.some a))) ≃ Σ (a : α), ↥{f : equiv.perm α | function.fixed_points ⇑f ⊆ {a}}
⊢ ↑(num_derangements 0) = ∑ (k : ℕ) in finset.range (0 + 1), (-1) ^ k * ↑(k.asc_factorial (0 - k))
⊢ ↑(num_derangements 0) = ∑ (k : ℕ) in finset.range (0 + 1), (-1) ^ k * ↑(k.asc_factorial (0 - k))		case nat.succ	n : ℕ,	hn : ↑(num_derangements n) = ∑ (k : ℕ) in finset.range (n + 1), (-1) ^ k * ↑(k.asc_factorial (n - k))	⊢ ↑(num_derangements n.succ) = ∑ (k : ℕ) in finset.range (n.succ + 1), (-1) ^ k * ↑(k.asc_factorial (n.succ - k))
n : ℕ	⊢ ↑(num_derangements n) = ∑ (k : ℕ) in finset.range (n + 1), (-1) ^ k * ↑(k.asc_factorial (n - k))
n : ℕ,	hn : ↑(num_derangements n) = ∑ (k : ℕ) in finset.range (n + 1), (-1) ^ k * ↑(k.asc_factorial (n - k))	⊢ ↑(num_derangements n.succ) = ∑ (k : ℕ) in finset.range (n.succ + 1), (-1) ^ k * ↑(k.asc_factorial (n.succ - k))
n : ℕ,	hn : ↑(num_derangements n) = ∑ (k : ℕ) in finset.range (n + 1), (-1) ^ k * ↑(k.asc_factorial (n - k))	⊢ ∀ (x : ℕ), x ∈ finset.range (n + 1) → (↑n + 1) * ((-1) ^ x * ↑(x.asc_factorial (n - x))) = (-1) ^ x * ↑(x.asc_factorial (n.succ - x))
n : ℕ,	hn : ↑(num_derangements n) = ∑ (k : ℕ) in finset.range (n + 1), (-1) ^ k * ↑(k.asc_factorial (n - k)),	x : ℕ,	hx : x ∈ finset.range (n + 1)	⊢ (↑n + 1) * ((-1) ^ x * ↑(x.asc_factorial (n - x))) = (-1) ^ x * ↑(x.asc_factorial (n.succ - x))
n : ℕ,	hn : ↑(num_derangements n) = ∑ (k : ℕ) in finset.range (n + 1), (-1) ^ k * ↑(k.asc_factorial (n - k)),	x : ℕ,	hx : x ∈ finset.range (n + 1),	h_le : x ≤ n	⊢ (↑n + 1) * ((-1) ^ x * ↑(x.asc_factorial (n - x))) = (-1) ^ x * ↑(x.asc_factorial (n.succ - x))
ι : Type u,	α : Type v,	_inst_1 : fintype ι,	t : ι → finset α,	_inst_2 : decidable_eq α,	n : ℕ,	hn : fintype.card ι = n + 1,	ht : ∀ (s : finset ι), s.card ≤ (s.bUnion t).card,	ι' : Type u,	_inst_3 : fintype ι',	t' : ι' → finset α	⊢ Sort ?
ι : Type u,	α : Type v,	_inst_1 : fintype ι,	t : ι → finset α,	_inst_2 : decidable_eq α,	n : ℕ,	hn : fintype.card ι = n + 1,	ht : ∀ (s : finset ι), s.card ≤ (s.bUnion t).card,	ih : ∀ {ι' : Type u} [_inst_3 : fintype ι'] (t' : ι' → finset α), fintype.card ι' ≤ n → (∀ (s' : finset ι'), s'.card ≤ (s'.bUnion t').card) → (∃ (f : ι' → α), function.injective f ∧ ∀ (x : ι'), f x ∈ t' x)	⊢ ∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x
ι : Type u,	α : Type v,	_inst_1 : fintype ι,	t : ι → finset α,	_inst_2 : decidable_eq α,	n : ℕ,	hn : fintype.card ι = n + 1,	ht : ∀ (s : finset ι), s.card ≤ (s.bUnion t).card,	ih : ∀ {ι' : Type u} [_inst_3 : fintype ι'] (t' : ι' → finset α), fintype.card ι' ≤ n → (∀ (s' : finset ι'), s'.card ≤ (s'.bUnion t').card) → (∃ (f : ι' → α), function.injective f ∧ ∀ (x : ι'), f x ∈ t' x),	h : ∀ (s : finset ι), s.nonempty → s ≠ finset.univ → s.card < (s.bUnion t).card	⊢ ∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x		ι : Type u,	α : Type v,	_inst_1 : fintype ι,	t : ι → finset α,	_inst_2 : decidable_eq α,	n : ℕ,	hn : fintype.card ι = n + 1,	ht : ∀ (s : finset ι), s.card ≤ (s.bUnion t).card,	ih : ∀ {ι' : Type u} [_inst_3 : fintype ι'] (t' : ι' → finset α), fintype.card ι' ≤ n → (∀ (s' : finset ι'), s'.card ≤ (s'.bUnion t').card) → (∃ (f : ι' → α), function.injective f ∧ ∀ (x : ι'), f x ∈ t' x),	h : ¬∀ (s : finset ι), s.nonempty → s ≠ finset.univ → s.card < (s.bUnion t).card	⊢ ∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x
ι : Type u,	α : Type v,	_inst_1 : fintype ι,	t : ι → finset α,	_inst_2 : decidable_eq α,	n : ℕ,	hn : fintype.card ι = n + 1,	ht : ∀ (s : finset ι), s.card ≤ (s.bUnion t).card,	ih : ∀ {ι' : Type u} [_inst_3 : fintype ι'] (t' : ι' → finset α), fintype.card ι' ≤ n → (∀ (s' : finset ι'), s'.card ≤ (s'.bUnion t').card) → (∃ (f : ι' → α), function.injective f ∧ ∀ (x : ι'), f x ∈ t' x),	h : ∀ (s : finset ι), s.nonempty → s ≠ finset.univ → s.card < (s.bUnion t).card	⊢ ∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x
ι : Type u,	α : Type v,	_inst_1 : fintype ι,	t : ι → finset α,	_inst_2 : decidable_eq α,	n : ℕ,	hn : fintype.card ι = n + 1,	ht : ∀ (s : finset ι), s.card ≤ (s.bUnion t).card,	ih : ∀ {ι' : Type u} [_inst_3 : fintype ι'] (t' : ι' → finset α), fintype.card ι' ≤ n → (∀ (s' : finset ι'), s'.card ≤ (s'.bUnion t').card) → (∃ (f : ι' → α), function.injective f ∧ ∀ (x : ι'), f x ∈ t' x),	h : ¬∀ (s : finset ι), s.nonempty → s ≠ finset.univ → s.card < (s.bUnion t).card	⊢ ∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x
ι : Type u,	α : Type v,	_inst_1 : fintype ι,	t : ι → finset α,	_inst_2 : decidable_eq α,	n : ℕ,	hn : fintype.card ι = n + 1,	ht : ∀ (s : finset ι), s.card ≤ (s.bUnion t).card,	ih : ∀ {ι' : Type u} [_inst_3 : fintype ι'] (t' : ι' → finset α), fintype.card ι' ≤ n → (∀ (s' : finset ι'), s'.card ≤ (s'.bUnion t').card) → (∃ (f : ι' → α), function.injective f ∧ ∀ (x : ι'), f x ∈ t' x),	h : ∃ (s : finset ι), s.nonempty ∧ s ≠ finset.univ ∧ (s.bUnion t).card ≤ s.card	⊢ ∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x
ι : Type u,	α : Type v,	_inst_1 : fintype ι,	t : ι → finset α,	_inst_2 : decidable_eq α,	n : ℕ,	hn : fintype.card ι = n + 1,	ht : ∀ (s : finset ι), s.card ≤ (s.bUnion t).card,	ih : ∀ {ι' : Type u} [_inst_3 : fintype ι'] (t' : ι' → finset α), fintype.card ι' ≤ n → (∀ (s' : finset ι'), s'.card ≤ (s'.bUnion t').card) → (∃ (f : ι' → α), function.injective f ∧ ∀ (x : ι'), f x ∈ t' x),	s : finset ι,	sne : s.nonempty,	snu : s ≠ finset.univ,	sle : (s.bUnion t).card ≤ s.card	⊢ ∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x
ι : Type u,	α : Type v,	_inst_1 : fintype ι,	t : ι → finset α,	_inst_2 : decidable_eq α,	n : ℕ,	hn : fintype.card ι = n + 1,	ht : ∀ (s : finset ι), s.card ≤ (s.bUnion t).card,	ih : ∀ {ι' : Type u} [_inst_3 : fintype ι'] (t' : ι' → finset α), fintype.card ι' ≤ n → (∀ (s' : finset ι'), s'.card ≤ (s'.bUnion t').card) → (∃ (f : ι' → α), function.injective f ∧ ∀ (x : ι'), f x ∈ t' x),	s : finset ι,	sne : s.nonempty,	snu : s ≠ finset.univ,	sle : (s.bUnion t).card ≤ s.card,	seq : s.card = (s.bUnion t).card	⊢ ∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x
ι : Type u,	α : Type v,	_inst_1 : fintype ι,	t : ι → finset α,	_inst_2 : decidable_eq α,	n : ℕ,	hn : fintype.card ι = n,	ht : ∀ (s : finset ι), s.card ≤ (s.bUnion t).card	⊢ ∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x
ι : Type u,	α : Type v,	_inst_1 : fintype ι,	t : ι → finset α,	_inst_2 : decidable_eq α,	n : ℕ,	hn : fintype.card ι = n,	ht : ∀ (s : finset ι), s.card ≤ (s.bUnion t).card	⊢ ∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x
α : Type v,	_inst_2 : decidable_eq α,	n : ℕ	⊢ ∀ {ι : Type u} [_inst_1 : fintype ι] {t : ι → finset α}, fintype.card ι = n → (∀ (s : finset ι), s.card ≤ (s.bUnion t).card) → (∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x)
α : Type v,	_inst_2 : decidable_eq α,	n n' : ℕ,	ih : ∀ (m : ℕ), m < n' → ∀ {ι : Type u} [_inst_1 : fintype ι] {t : ι → finset α}, fintype.card ι = m → (∀ (s : finset ι), s.card ≤ (s.bUnion t).card) → (∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x)	⊢ ∀ {ι : Type u} [_inst_1 : fintype ι] {t : ι → finset α}, fintype.card ι = n' → (∀ (s : finset ι), s.card ≤ (s.bUnion t).card) → (∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x)
α : Type v,	_inst_2 : decidable_eq α,	n n' : ℕ,	ih : ∀ (m : ℕ), m < n' → ∀ {ι : Type u} [_inst_1 : fintype ι] {t : ι → finset α}, fintype.card ι = m → (∀ (s : finset ι), s.card ≤ (s.bUnion t).card) → (∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x),	ι : Type u,	_inst_1 : fintype ι,	t : ι → finset α,	hn : fintype.card ι = n',	ht : ∀ (s : finset ι), s.card ≤ (s.bUnion t).card	⊢ ∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x
α : Type v,	_inst_2 : decidable_eq α,	n : ℕ,	ι : Type u,	_inst_1 : fintype ι,	t : ι → finset α,	ht : ∀ (s : finset ι), s.card ≤ (s.bUnion t).card,	ih : ∀ (m : ℕ), m < 0 → ∀ {ι : Type u} [_inst_1 : fintype ι] {t : ι → finset α}, fintype.card ι = m → (∀ (s : finset ι), s.card ≤ (s.bUnion t).card) → (∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x),	hn : fintype.card ι = 0	⊢ ∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x		α : Type v,	_inst_2 : decidable_eq α,	n : ℕ,	ι : Type u,	_inst_1 : fintype ι,	t : ι → finset α,	ht : ∀ (s : finset ι), s.card ≤ (s.bUnion t).card,	n' : ℕ,	ih : ∀ (m : ℕ), m < n'.succ → ∀ {ι : Type u} [_inst_1 : fintype ι] {t : ι → finset α}, fintype.card ι = m → (∀ (s : finset ι), s.card ≤ (s.bUnion t).card) → (∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x),	hn : fintype.card ι = n'.succ	⊢ ∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x
α : Type v,	_inst_2 : decidable_eq α,	n : ℕ,	ι : Type u,	_inst_1 : fintype ι,	t : ι → finset α,	ht : ∀ (s : finset ι), s.card ≤ (s.bUnion t).card,	ih : ∀ (m : ℕ), m < 0 → ∀ {ι : Type u} [_inst_1 : fintype ι] {t : ι → finset α}, fintype.card ι = m → (∀ (s : finset ι), s.card ≤ (s.bUnion t).card) → (∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x),	hn : fintype.card ι = 0	⊢ ∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x
α : Type v,	_inst_2 : decidable_eq α,	n : ℕ,	ι : Type u,	_inst_1 : fintype ι,	t : ι → finset α,	ht : ∀ (s : finset ι), s.card ≤ (s.bUnion t).card,	n' : ℕ,	ih : ∀ (m : ℕ), m < n'.succ → ∀ {ι : Type u} [_inst_1 : fintype ι] {t : ι → finset α}, fintype.card ι = m → (∀ (s : finset ι), s.card ≤ (s.bUnion t).card) → (∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x),	hn : fintype.card ι = n'.succ	⊢ ∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x
α : Type v,	_inst_2 : decidable_eq α,	n : ℕ,	ι : Type u,	_inst_1 : fintype ι,	t : ι → finset α,	ht : ∀ (s : finset ι), s.card ≤ (s.bUnion t).card,	n' : ℕ,	ih : ∀ (m : ℕ), m < n'.succ → ∀ {ι : Type u} [_inst_1 : fintype ι] {t : ι → finset α}, fintype.card ι = m → (∀ (s : finset ι), s.card ≤ (s.bUnion t).card) → (∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x),	hn : fintype.card ι = n'.succ	⊢ ∀ {ι' : Type u} [_inst_3 : fintype ι'] (t' : ι' → finset α), fintype.card ι' ≤ n' → (∀ (s' : finset ι'), s'.card ≤ (s'.bUnion t').card) → (∃ (f : ι' → α), function.injective f ∧ ∀ (x : ι'), f x ∈ t' x)
α : Type v,	_inst_2 : decidable_eq α,	n : ℕ,	ι : Type u,	_inst_1 : fintype ι,	t : ι → finset α,	ht : ∀ (s : finset ι), s.card ≤ (s.bUnion t).card,	n' : ℕ,	ih : ∀ (m : ℕ), m < n'.succ → ∀ {ι : Type u} [_inst_1 : fintype ι] {t : ι → finset α}, fintype.card ι = m → (∀ (s : finset ι), s.card ≤ (s.bUnion t).card) → (∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x),	hn : fintype.card ι = n'.succ,	ι' : Type u,	_inst_3 : fintype ι',	t' : ι' → finset α,	hι' : fintype.card ι' ≤ n'	⊢ (∀ (s' : finset ι'), s'.card ≤ (s'.bUnion t').card) → (∃ (f : ι' → α), function.injective f ∧ ∀ (x : ι'), f x ∈ t' x)
n : ℕ,	c : composition n	⊢ ↑(c.blocks).sum = n
V : Type u,	G : simple_graph V,	a : V,	hab : G.adj a a	⊢ false
V : Type u,	G : simple_graph V,	a b : V,	hab : G.adj a b	⊢ a ≠ b
V : Type u,	G : simple_graph V,	v : V	⊢ disjoint (G.neighbor_set v) (Gᶜ.neighbor_set v)
V : Type u,	G : simple_graph V,	v : V	⊢ G.neighbor_set v ∩ Gᶜ.neighbor_set v ⊆ ∅
V : Type u,	G : simple_graph V,	v w : V,	h : w ∈ G.neighbor_set v,	h' : w ∈ Gᶜ.neighbor_set v	⊢ w ∈ ∅
V : Type u,	G : simple_graph V,	v w : V,	h : w ∈ G.neighbor_set v,	h' : v ≠ w ∧ ¬G.adj v w	⊢ w ∈ ∅
V : Type u,	G : simple_graph V,	v w : V	⊢ G.neighbor_set w ∩ G.neighbor_set v = G.common_neighbors w v
V : Type u,	G : simple_graph V,	v w : V	⊢ G.common_neighbors v w = G.common_neighbors w v
V : Type u,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	v : V	⊢ ⊤.degree v = fintype.card V - 1
V : Type u,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	v : V	⊢ ⊤.degree v = finset.univ.card.pred		V : Type u,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	v : V	⊢ fintype V
V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_rel G.adj,	_inst_3 : nonempty V	⊢ ∃ (v : V), G.min_degree = G.degree v
V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_rel G.adj,	_inst_3 : nonempty V,	t : ℕ,	ht : (finset.image (λ (v : V), G.degree v) finset.univ).min = option.some t	⊢ ∃ (v : V), G.min_degree = G.degree v
V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_rel G.adj,	_inst_3 : nonempty V,	v : V,	h_w : v ∈ finset.univ,	ht : (finset.image (λ (v : V), G.degree v) finset.univ).min = option.some (G.degree v)	⊢ G.min_degree = G.degree v
V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_rel G.adj,	_inst_3 : nonempty V,	v : V,	h_w : v ∈ finset.univ,	ht : (finset.image (λ (v : V), G.degree v) finset.univ).min = option.some (G.degree v)	⊢ ∃ (v : V), G.min_degree = G.degree v
V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_rel G.adj,	_inst_3 : decidable_eq V,	d d' : G.dart	⊢ d' ∈ finset.filter (λ (d' : G.dart), d'.edge = d.edge) finset.univ ↔ d' ∈ {d, d.rev}
V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v)	⊢ odd (finset.filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) finset.univ).card
V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (finset.filter (λ (v : V), odd (G.degree v)) finset.univ).card = 2 * k	⊢ odd (finset.filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) finset.univ).card
V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (finset.filter (λ (v : V), odd (G.degree v)) finset.univ).card = 2 * k	⊢ 0 < k
V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (finset.filter (λ (v : V), odd (G.degree v)) finset.univ).card = 2 * k	⊢ (finset.filter (λ (v : V), odd (G.degree v)) finset.univ).nonempty
V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (finset.filter (λ (v : V), odd (G.degree v)) finset.univ).card = 2 * k	⊢ v ∈ finset.filter (λ (v : V), odd (G.degree v)) finset.univ
V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (finset.filter (λ (v : V), odd (G.degree v)) finset.univ).card = 2 * k	⊢ (finset.filter (λ (v : V), odd (G.degree v)) finset.univ).nonempty		V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (finset.filter (λ (v : V), odd (G.degree v)) finset.univ).card = 2 * k,	hh : (finset.filter (λ (v : V), odd (G.degree v)) finset.univ).nonempty	⊢ 0 < k
V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (finset.filter (λ (v : V), odd (G.degree v)) finset.univ).card = 2 * k	⊢ odd (G.degree v)
V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (finset.filter (λ (v : V), odd (G.degree v)) finset.univ).card = 2 * k,	hh : (finset.filter (λ (v : V), odd (G.degree v)) finset.univ).nonempty	⊢ 0 < k
V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (finset.filter (λ (v : V), odd (G.degree v)) finset.univ).card = 2 * k	⊢ 0 < k		V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (finset.filter (λ (v : V), odd (G.degree v)) finset.univ).card = 2 * k,	hk : 0 < k	⊢ odd (finset.filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) finset.univ).card
V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (finset.filter (λ (v : V), odd (G.degree v)) finset.univ).card = 2 * k,	hh : 0 < 2 * k	⊢ 0 < 2
V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (finset.filter (λ (v : V), odd (G.degree v)) finset.univ).card = 2 * k,	hk : 0 < k	⊢ odd (finset.filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) finset.univ).card
V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (finset.filter (λ (v : V), odd (G.degree v)) finset.univ).card = 2 * k,	hk : 0 < k	⊢ (λ (w : V), w ≠ v ∧ odd (G.degree w)) = λ (w : V), odd (G.degree w) ∧ w ≠ v
V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (finset.filter (λ (v : V), odd (G.degree v)) finset.univ).card = 2 * k,	hk : 0 < k	⊢ (λ (w : V), w ≠ v ∧ odd (G.degree w)) = λ (w : V), odd (G.degree w) ∧ w ≠ v		V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (finset.filter (λ (v : V), odd (G.degree v)) finset.univ).card = 2 * k,	hk : 0 < k,	hc : (λ (w : V), w ≠ v ∧ odd (G.degree w)) = λ (w : V), odd (G.degree w) ∧ w ≠ v	⊢ odd (finset.filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) finset.univ).card
V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (finset.filter (λ (v : V), odd (G.degree v)) finset.univ).card = 2 * k,	hk : 0 < k,	w : V	⊢ w ≠ v ∧ odd (G.degree w) ↔ odd (G.degree w) ∧ w ≠ v
V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (finset.filter (λ (v : V), odd (G.degree v)) finset.univ).card = 2 * k,	hk : 0 < k,	hc : (λ (w : V), w ≠ v ∧ odd (G.degree w)) = λ (w : V), odd (G.degree w) ∧ w ≠ v	⊢ odd (finset.filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) finset.univ).card
V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (finset.filter (λ (v : V), odd (G.degree v)) finset.univ).card = 2 * k,	hk : 0 < k,	hc : (λ (w : V), w ≠ v ∧ odd (G.degree w)) = λ (w : V), odd (G.degree w) ∧ w ≠ v	⊢ odd (finset.filter (λ (w : V), odd (G.degree w) ∧ w ≠ v) finset.univ).card
V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (finset.filter (λ (v : V), odd (G.degree v)) finset.univ).card = 2 * k,	hk : 0 < k,	hc : (λ (w : V), w ≠ v ∧ odd (G.degree w)) = λ (w : V), odd (G.degree w) ∧ w ≠ v	⊢ odd (finset.filter (λ (a : V), odd (G.degree a)) finset.univ).card.pred
V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (finset.filter (λ (v : V), odd (G.degree v)) finset.univ).card = 2 * k,	hk : 0 < k,	hc : (λ (w : V), w ≠ v ∧ odd (G.degree w)) = λ (w : V), odd (G.degree w) ∧ w ≠ v	⊢ (finset.filter (λ (a : V), odd (G.degree a)) finset.univ).card.pred = 2 * (k - 1) + 1
V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (finset.filter (λ (v : V), odd (G.degree v)) finset.univ).card = 2 * k,	hk : 0 < k,	hc : (λ (w : V), w ≠ v ∧ odd (G.degree w)) = λ (w : V), odd (G.degree w) ∧ w ≠ v	⊢ 2 * k + 2 = 2 * k + 2 * 1		V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (finset.filter (λ (v : V), odd (G.degree v)) finset.univ).card = 2 * k,	hk : 0 < k,	hc : (λ (w : V), w ≠ v ∧ odd (G.degree w)) = λ (w : V), odd (G.degree w) ∧ w ≠ v	⊢ 2 * 1 ≤ 2 * k + 2		V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (finset.filter (λ (v : V), odd (G.degree v)) finset.univ).card = 2 * k,	hk : 0 < k,	hc : (λ (w : V), w ≠ v ∧ odd (G.degree w)) = λ (w : V), odd (G.degree w) ∧ w ≠ v	⊢ 2 * 1 ≤ 2 * k
V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (finset.filter (λ (v : V), odd (G.degree v)) finset.univ).card = 2 * k,	hk : 0 < k,	hc : (λ (w : V), w ≠ v ∧ odd (G.degree w)) = λ (w : V), odd (G.degree w) ∧ w ≠ v	⊢ 2 * k + 2 = 2 * k + 2 * 1
V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (finset.filter (λ (v : V), odd (G.degree v)) finset.univ).card = 2 * k,	hk : 0 < k,	hc : (λ (w : V), w ≠ v ∧ odd (G.degree w)) = λ (w : V), odd (G.degree w) ∧ w ≠ v	⊢ 2 * 1 ≤ 2 * k + 2		V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (finset.filter (λ (v : V), odd (G.degree v)) finset.univ).card = 2 * k,	hk : 0 < k,	hc : (λ (w : V), w ≠ v ∧ odd (G.degree w)) = λ (w : V), odd (G.degree w) ∧ w ≠ v	⊢ 2 * 1 ≤ 2 * k
V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (finset.filter (λ (v : V), odd (G.degree v)) finset.univ).card = 2 * k,	hk : 0 < k,	hc : (λ (w : V), w ≠ v ∧ odd (G.degree w)) = λ (w : V), odd (G.degree w) ∧ w ≠ v	⊢ 2 * 1 ≤ 2 * k + 2
V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (finset.filter (λ (v : V), odd (G.degree v)) finset.univ).card = 2 * k,	hk : 0 < k,	hc : (λ (w : V), w ≠ v ∧ odd (G.degree w)) = λ (w : V), odd (G.degree w) ∧ w ≠ v	⊢ odd (finset.filter (λ (a : V), odd (G.degree a)) finset.univ).card.pred		V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (finset.filter (λ (v : V), odd (G.degree v)) finset.univ).card = 2 * k,	hk : 0 < k,	hc : (λ (w : V), w ≠ v ∧ odd (G.degree w)) = λ (w : V), odd (G.degree w) ∧ w ≠ v	⊢ v ∈ finset.filter (λ (a : V), odd (G.degree a)) finset.univ
V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (finset.filter (λ (v : V), odd (G.degree v)) finset.univ).card = 2 * k,	hk : 0 < k,	hc : (λ (w : V), w ≠ v ∧ odd (G.degree w)) = λ (w : V), odd (G.degree w) ∧ w ≠ v	⊢ 2 * 1 ≤ 2 * k
V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (finset.filter (λ (v : V), odd (G.degree v)) finset.univ).card = 2 * k,	hk : 0 < k,	hc : (λ (w : V), w ≠ v ∧ odd (G.degree w)) = λ (w : V), odd (G.degree w) ∧ w ≠ v	⊢ v ∈ finset.filter (λ (a : V), odd (G.degree a)) finset.univ
V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_rel G.adj,	v : V,	h : odd (G.degree v)	⊢ decidable_eq V
V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_rel G.adj,	v : V,	h : odd (G.degree v)	⊢ ∃ (w : V), w ≠ v ∧ odd (G.degree w)
V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	_inst : Π (a : Prop), decidable a	⊢ decidable_eq V
V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_rel G.adj,	v : V,	h : odd (G.degree v)	⊢ decidable_eq V		V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	_inst : decidable_eq V	⊢ ∃ (w : V), w ≠ v ∧ odd (G.degree w)
V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	_inst : decidable_eq V	⊢ ∃ (w : V), w ≠ v ∧ odd (G.degree w)
V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	_inst : decidable_eq V,	k : ℕ,	hg : (finset.filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) finset.univ).card = 2 * k + 1	⊢ ∃ (w : V), w ≠ v ∧ odd (G.degree w)
V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	_inst : decidable_eq V,	k : ℕ,	hg : (finset.filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) finset.univ).card = 2 * k + 1	⊢ (finset.filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) finset.univ).card > 0
V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	_inst : decidable_eq V,	k : ℕ,	hg : (finset.filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) finset.univ).card = 2 * k + 1	⊢ (finset.filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) finset.univ).card > 0		V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	_inst : decidable_eq V,	k : ℕ,	hg : (finset.filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) finset.univ).card = 2 * k + 1,	hg' : (finset.filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) finset.univ).card > 0	⊢ ∃ (w : V), w ≠ v ∧ odd (G.degree w)
V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	_inst : decidable_eq V,	k : ℕ,	hg : (finset.filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) finset.univ).card = 2 * k + 1	⊢ 2 * k + 1 > 0
V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	_inst : decidable_eq V,	k : ℕ,	hg : (finset.filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) finset.univ).card = 2 * k + 1,	hg' : (finset.filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) finset.univ).card > 0	⊢ ∃ (w : V), w ≠ v ∧ odd (G.degree w)
V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	_inst : decidable_eq V,	k : ℕ,	hg : (finset.filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) finset.univ).card = 2 * k + 1,	hg' : (finset.filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) finset.univ).card > 0,	w : V,	hw : w ∈ finset.filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) finset.univ	⊢ ∃ (w : V), w ≠ v ∧ odd (G.degree w)
V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	_inst : decidable_eq V,	k : ℕ,	hg : (finset.filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) finset.univ).card = 2 * k + 1,	hg' : (finset.filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) finset.univ).card > 0,	w : V,	hw : ¬w = v ∧ odd (G.degree w)	⊢ ∃ (w : V), w ≠ v ∧ odd (G.degree w)
α : Type u,	σ : Type v,	M : DFA α σ,	x y : list α,	s : σ,	hx : M.eval_from s x = s,	hy : y ∈ {x}.star	⊢ M.eval_from s y = s
α : Type u,	σ : Type v,	M : DFA α σ,	x y : list α,	s : σ,	hx : M.eval_from s x = s,	hy : ∃ (S : list (list α)), y = S.join ∧ ∀ (y : list α), y ∈ S → y ∈ {x}	⊢ M.eval_from s y = s
α : Type u,	σ : Type v,	M : DFA α σ,	x : list α,	s : σ,	hx : M.eval_from s x = s,	S : list (list α),	hS : ∀ (y : list α), y ∈ S → y ∈ {x}	⊢ M.eval_from s S.join = s
α : Type u,	σ : Type v,	M : DFA α σ,	x : list α,	s : σ,	hx : M.eval_from s x = s,	hS : ∀ (y : list α), y ∈ list.nil → y ∈ {x}	⊢ M.eval_from s list.nil.join = s		case list.cons	α : Type u,	σ : Type v,	M : DFA α σ,	x : list α,	s : σ,	hx : M.eval_from s x = s,	a : list α,	S : list (list α),	ih : (∀ (y : list α), y ∈ S → y ∈ {x}) → M.eval_from s S.join = s,	hS : ∀ (y : list α), y ∈ a :: S → y ∈ {x}	⊢ M.eval_from s (a :: S).join = s
α : Type u,	σ : Type v,	M : DFA α σ,	x : list α,	s : σ,	hx : M.eval_from s x = s,	hS : ∀ (y : list α), y ∈ list.nil → y ∈ {x}	⊢ M.eval_from s list.nil.join = s
α : Type u,	σ : Type v,	M : DFA α σ,	x : list α,	s : σ,	hx : M.eval_from s x = s,	a : list α,	S : list (list α),	ih : (∀ (y : list α), y ∈ S → y ∈ {x}) → M.eval_from s S.join = s,	hS : ∀ (y : list α), y ∈ a :: S → y ∈ {x}	⊢ M.eval_from s (a :: S).join = s
α : Type u,	σ : Type v,	M : DFA α σ,	x : list α,	s : σ,	hx : M.eval_from s x = s,	a : list α,	S : list (list α),	ih : (∀ (y : list α), y ∈ S → y ∈ {x}) → M.eval_from s S.join = s,	hS : ∀ (y : list α), y ∈ a :: S → y ∈ {x},	ha : a ∈ {x}	⊢ M.eval_from s (a :: S).join = s
α : Type u,	σ : Type v,	M : DFA α σ,	x : list α,	s : σ,	hx : M.eval_from s x = s,	a : list α,	S : list (list α),	ih : (∀ (y : list α), y ∈ S → y ∈ {x}) → M.eval_from s S.join = s,	hS : ∀ (y : list α), y ∈ a :: S → y ∈ {x},	ha : a = x	⊢ M.eval_from s (a :: S).join = s
α : Type u,	σ : Type v,	M : DFA α σ,	x : list α,	s : σ,	hx : M.eval_from s x = s,	a : list α,	S : list (list α),	ih : (∀ (y : list α), y ∈ S → y ∈ {x}) → M.eval_from s S.join = s,	hS : ∀ (y : list α), y ∈ a :: S → y ∈ {x},	ha : a = x	⊢ M.eval_from s S.join = s
α : Type u,	σ : Type v,	M : DFA α σ,	x : list α,	s : σ,	hx : M.eval_from s x = s,	a : list α,	S : list (list α),	ih : (∀ (y : list α), y ∈ S → y ∈ {x}) → M.eval_from s S.join = s,	hS : ∀ (y : list α), y ∈ a :: S → y ∈ {x},	ha : a = x	⊢ ∀ (y : list α), y ∈ S → y ∈ {x}
α : Type u,	σ : Type v,	M : DFA α σ,	x : list α,	s : σ,	hx : M.eval_from s x = s,	a : list α,	S : list (list α),	ih : (∀ (y : list α), y ∈ S → y ∈ {x}) → M.eval_from s S.join = s,	hS : ∀ (y : list α), y ∈ a :: S → y ∈ {x},	ha : a = x,	z : list α,	hz : z ∈ S	⊢ z ∈ {x}
α : Type u_1,	σ : Type u_4,	_inst_1 : primcodable α,	_inst_4 : primcodable σ,	vector_m_of_fn : ∀ {n : ℕ} {f : fin n → α →. σ}, (∀ (i : fin n), partrec (f i)) → partrec (λ (a : α), vector.m_of_fn (λ (i : fin n), f i a)),	n : ℕ,	f : fin (n + 1) → α →. σ,	hf : ∀ (i : fin (n + 1)), partrec (f i)	⊢ partrec (λ (a : α), vector.m_of_fn (λ (i : fin (n + 1)), f i a))
α : Type u_1,	σ : Type u_4,	_inst_1 : primcodable α,	_inst_4 : primcodable σ,	vector_m_of_fn : ∀ {n : ℕ} {f : fin n → α →. σ}, (∀ (i : fin n), partrec (f i)) → partrec (λ (a : α), vector.m_of_fn (λ (i : fin n), f i a)),	n : ℕ,	f : fin (n + 1) → α →. σ,	hf : ∀ (i : fin (n + 1)), partrec (f i)	⊢ partrec (λ (a : α), vector.m_of_fn (λ (i : fin (n + 1)), f i a))
α : Type u_1,	σ : Type u_4,	_inst_1 : primcodable α,	_inst_4 : primcodable σ,	vector_m_of_fn : ∀ {n : ℕ} {f : fin n → α →. σ}, (∀ (i : fin n), partrec (f i)) → partrec (λ (a : α), vector.m_of_fn (λ (i : fin n), f i a)),	n : ℕ,	f : fin (n + 1) → α →. σ,	hf : ∀ (i : fin (n + 1)), partrec (f i)	⊢ partrec (λ (a : α), (f 0 a).bind (λ (a_1 : σ), (vector.m_of_fn (λ (i : fin n), f i.succ a)).bind (λ (v : vector σ n), part.some (a_1::ᵥ v))))
α : Type u_1,	β : Type u_2,	σ : Type u_4,	_inst_1 : primcodable α,	_inst_2 : primcodable β,	_inst_4 : primcodable σ,	f : α → option β,	g : α → β → option σ,	hf : computable f,	hg : computable₂ g,	a : α	⊢ (f a).cases_on option.none (g a) = (f a).bind (g a)
α : Type u_1,	β : Type u_2,	σ : Type u_4,	_inst_1 : primcodable α,	_inst_2 : primcodable β,	_inst_4 : primcodable σ,	f : α → option β,	g : α → β → option σ,	hf : computable f,	hg : computable₂ g,	a : α	⊢ option.none.cases_on option.none (g a) = option.none.bind (g a)
α : Type u_1,	β : Type u_2,	σ : Type u_4,	_inst_1 : primcodable α,	_inst_2 : primcodable β,	_inst_4 : primcodable σ,	f : α → option β,	g : α → β → option σ,	hf : computable f,	hg : computable₂ g,	a : α,	val : β	⊢ (option.some val).cases_on option.none (g a) = (option.some val).bind (g a)
α : Type u_1,	β : Type u_2,	σ : Type u_4,	_inst_1 : primcodable α,	_inst_2 : primcodable β,	_inst_4 : primcodable σ,	f : α → option β,	g : α → β → option σ,	hf : computable f,	hg : computable₂ g,	a : α	⊢ (f a).cases_on option.none (g a) = (f a).bind (g a)
cf cg : nat.partrec.code	⊢ encodable.encode cf < encodable.encode (cf.pair cg) ∧ encodable.encode cg < encodable.encode (cf.pair cg)
cf cg : nat.partrec.code	⊢ cf.encode_code < bit0 (bit0 (nat.mkpair cf.encode_code cg.encode_code)) + 4 ∧ cg.encode_code < bit0 (bit0 (nat.mkpair cf.encode_code cg.encode_code)) + 4
cf cg : nat.partrec.code,	this : 1 * ?m_1 ≤ 2 * 2 * ?m_1	⊢ cf.encode_code < bit0 (bit0 (nat.mkpair cf.encode_code cg.encode_code)) + 4 ∧ cg.encode_code < bit0 (bit0 (nat.mkpair cf.encode_code cg.encode_code)) + 4		cf cg : nat.partrec.code	⊢ ℕ
cf cg : nat.partrec.code,	this : ?m_1 ≤ bit0 (bit0 ?m_1)	⊢ cf.encode_code < bit0 (bit0 (nat.mkpair cf.encode_code cg.encode_code)) + 4 ∧ cg.encode_code < bit0 (bit0 (nat.mkpair cf.encode_code cg.encode_code)) + 4		cf cg : nat.partrec.code	⊢ ℕ
cf cg : nat.partrec.code,	this : ?m_1 ≤ bit0 (bit0 ?m_1),	this : ?m_1 < bit0 (bit0 ?m_1) + 4	⊢ cf.encode_code < bit0 (bit0 (nat.mkpair cf.encode_code cg.encode_code)) + 4 ∧ cg.encode_code < bit0 (bit0 (nat.mkpair cf.encode_code cg.encode_code)) + 4		cf cg : nat.partrec.code	⊢ ℕ		cf cg : nat.partrec.code	⊢ ℕ
cf : nat.partrec.code	⊢ encodable.encode cf < encodable.encode cf.rfind'
cf : nat.partrec.code	⊢ cf.encode_code < bit1 (bit1 cf.encode_code) + 4
cf : nat.partrec.code,	this : 1 * ?m_1 ≤ 2 * 2 * ?m_1	⊢ cf.encode_code < bit1 (bit1 cf.encode_code) + 4		cf : nat.partrec.code	⊢ ℕ
cf : nat.partrec.code,	this : ?m_1 ≤ bit0 (bit0 ?m_1)	⊢ cf.encode_code < bit1 (bit1 cf.encode_code) + 4		cf : nat.partrec.code	⊢ ℕ
cf : nat.partrec.code,	this : cf.encode_code ≤ bit0 (bit0 cf.encode_code)	⊢ bit0 (bit0 cf.encode_code) ≤ bit1 (bit1 cf.encode_code)
p : ℕ	⊢ nat.unpaired (λ (z n : ℕ), nat.elim 1 (λ (y IH : ℕ), nat.unpaired has_mul.mul (nat.mkpair (nat.unpair (nat.unpair (nat.mkpair z (nat.mkpair y IH))).snd).snd (nat.unpair (nat.mkpair z (nat.mkpair y IH))).fst)) n) p = nat.unpaired has_pow.pow p
p : ℕ	⊢ nat.unpaired (λ (z n : ℕ), nat.elim 1 (λ (y IH : ℕ), nat.unpaired has_mul.mul (nat.mkpair (nat.unpair (nat.unpair (nat.mkpair z (nat.mkpair y IH))).snd).snd (nat.unpair (nat.mkpair z (nat.mkpair y IH))).fst)) n) p = nat.unpaired has_pow.pow p
p : ℕ	⊢ nat.elim 1 (λ (y IH : ℕ), IH * (nat.unpair p).fst) (nat.unpair p).snd = (nat.unpair p).fst ^ (nat.unpair p).snd
p : ℕ	⊢ nat.elim 1 (λ (y IH : ℕ), IH * (nat.unpair p).fst) 0 = (nat.unpair p).fst ^ 0
p n : ℕ,	ih : nat.elim 1 (λ (y IH : ℕ), IH * (nat.unpair p).fst) n = (nat.unpair p).fst ^ n	⊢ nat.elim 1 (λ (y IH : ℕ), IH * (nat.unpair p).fst) n.succ = (nat.unpair p).fst ^ n.succ
p : ℕ	⊢ nat.unpaired (λ (z n : ℕ), nat.elim 1 (λ (y IH : ℕ), nat.unpaired has_mul.mul (nat.mkpair (nat.unpair (nat.unpair (nat.mkpair z (nat.mkpair y IH))).snd).snd (nat.unpair (nat.mkpair z (nat.mkpair y IH))).fst)) n) p = nat.unpaired has_pow.pow p
α : Type u_1,	σ : Type u_4,	_inst_1 : primcodable α,	_inst_4 : primcodable σ,	n : ℕ,	f : fin n → α → σ,	h : ∀ (i : fin n), primrec (f i),	a : fin n × α	⊢ (vector.of_fn (λ (i : fin n), f i a.snd)).nth a.fst = f a.fst a.snd
n : ℕ,	f : vector ℕ n → ℕ,	pf : nat.primrec' f	⊢ primrec f
n : ℕ,	f : vector ℕ n → ℕ	⊢ primrec (λ (_x : vector ℕ 0), 0)
n : ℕ,	f : vector ℕ n → ℕ	⊢ primrec (λ (_x : vector ℕ 0), 0)		case nat.primrec'.succ	n : ℕ,	f : vector ℕ n → ℕ	⊢ primrec (λ (v : vector ℕ 1), v.head.succ)		case nat.primrec'.nth	n : ℕ,	f : vector ℕ n → ℕ,	pf_n : ℕ,	pf_i : fin pf_n	⊢ primrec (λ (v : vector ℕ pf_n), v.nth pf_i)		case nat.primrec'.comp	n : ℕ,	f : vector ℕ n → ℕ,	pf_m pf_n : ℕ,	pf_f : vector ℕ pf_n → ℕ,	pf_g : fin pf_n → vector ℕ pf_m → ℕ,	pf_ᾰ : nat.primrec' pf_f,	pf_ᾰ_1 : ∀ (i : fin pf_n), nat.primrec' (pf_g i),	pf_ih_ᾰ : primrec pf_f,	pf_ih_ᾰ_1 : ∀ (i : fin pf_n), (λ {n : ℕ} {f : vector ℕ n → ℕ} (pf : nat.primrec' f), primrec f) _	⊢ primrec (λ (a : vector ℕ pf_m), pf_f (vector.of_fn (λ (i : fin pf_n), pf_g i a)))		case nat.primrec'.prec	n : ℕ,	f : vector ℕ n → ℕ,	pf_n : ℕ,	pf_f : vector ℕ pf_n → ℕ,	pf_g : vector ℕ (pf_n + 2) → ℕ,	pf_ᾰ : nat.primrec' pf_f,	pf_ᾰ_1 : nat.primrec' pf_g,	pf_ih_ᾰ : primrec pf_f,	pf_ih_ᾰ_1 : primrec pf_g	⊢ primrec (λ (v : vector ℕ (pf_n + 1)), nat.elim (pf_f v.tail) (λ (y IH : ℕ), pf_g (y::ᵥ IH::ᵥ v.tail)) v.head)
n : ℕ,	f : vector ℕ n → ℕ	⊢ primrec (λ (v : vector ℕ 1), v.head.succ)
n : ℕ,	f : vector ℕ n → ℕ	⊢ primrec (λ (v : vector ℕ 1), v.head.succ)		case nat.primrec'.nth	n : ℕ,	f : vector ℕ n → ℕ,	pf_n : ℕ,	pf_i : fin pf_n	⊢ primrec (λ (v : vector ℕ pf_n), v.nth pf_i)		case nat.primrec'.comp	n : ℕ,	f : vector ℕ n → ℕ,	pf_m pf_n : ℕ,	pf_f : vector ℕ pf_n → ℕ,	pf_g : fin pf_n → vector ℕ pf_m → ℕ,	pf_ᾰ : nat.primrec' pf_f,	pf_ᾰ_1 : ∀ (i : fin pf_n), nat.primrec' (pf_g i),	pf_ih_ᾰ : primrec pf_f,	pf_ih_ᾰ_1 : ∀ (i : fin pf_n), (λ {n : ℕ} {f : vector ℕ n → ℕ} (pf : nat.primrec' f), primrec f) _	⊢ primrec (λ (a : vector ℕ pf_m), pf_f (vector.of_fn (λ (i : fin pf_n), pf_g i a)))		case nat.primrec'.prec	n : ℕ,	f : vector ℕ n → ℕ,	pf_n : ℕ,	pf_f : vector ℕ pf_n → ℕ,	pf_g : vector ℕ (pf_n + 2) → ℕ,	pf_ᾰ : nat.primrec' pf_f,	pf_ᾰ_1 : nat.primrec' pf_g,	pf_ih_ᾰ : primrec pf_f,	pf_ih_ᾰ_1 : primrec pf_g	⊢ primrec (λ (v : vector ℕ (pf_n + 1)), nat.elim (pf_f v.tail) (λ (y IH : ℕ), pf_g (y::ᵥ IH::ᵥ v.tail)) v.head)
n : ℕ,	f : vector ℕ n → ℕ,	pf_n : ℕ,	pf_i : fin pf_n	⊢ primrec (λ (v : vector ℕ pf_n), v.nth pf_i)		case nat.primrec'.comp	n : ℕ,	f : vector ℕ n → ℕ,	pf_m pf_n : ℕ,	pf_f : vector ℕ pf_n → ℕ,	pf_g : fin pf_n → vector ℕ pf_m → ℕ,	pf_ᾰ : nat.primrec' pf_f,	pf_ᾰ_1 : ∀ (i : fin pf_n), nat.primrec' (pf_g i),	pf_ih_ᾰ : primrec pf_f,	pf_ih_ᾰ_1 : ∀ (i : fin pf_n), (λ {n : ℕ} {f : vector ℕ n → ℕ} (pf : nat.primrec' f), primrec f) _	⊢ primrec (λ (a : vector ℕ pf_m), pf_f (vector.of_fn (λ (i : fin pf_n), pf_g i a)))		case nat.primrec'.prec	n : ℕ,	f : vector ℕ n → ℕ,	pf_n : ℕ,	pf_f : vector ℕ pf_n → ℕ,	pf_g : vector ℕ (pf_n + 2) → ℕ,	pf_ᾰ : nat.primrec' pf_f,	pf_ᾰ_1 : nat.primrec' pf_g,	pf_ih_ᾰ : primrec pf_f,	pf_ih_ᾰ_1 : primrec pf_g	⊢ primrec (λ (v : vector ℕ (pf_n + 1)), nat.elim (pf_f v.tail) (λ (y IH : ℕ), pf_g (y::ᵥ IH::ᵥ v.tail)) v.head)
n : ℕ,	f : vector ℕ n → ℕ,	n : ℕ,	i : fin n	⊢ primrec (λ (v : vector ℕ n), v.nth i)
n : ℕ,	f : vector ℕ n → ℕ,	pf_m pf_n : ℕ,	pf_f : vector ℕ pf_n → ℕ,	pf_g : fin pf_n → vector ℕ pf_m → ℕ,	pf_ᾰ : nat.primrec' pf_f,	pf_ᾰ_1 : ∀ (i : fin pf_n), nat.primrec' (pf_g i),	pf_ih_ᾰ : primrec pf_f,	pf_ih_ᾰ_1 : ∀ (i : fin pf_n), (λ {n : ℕ} {f : vector ℕ n → ℕ} (pf : nat.primrec' f), primrec f) _	⊢ primrec (λ (a : vector ℕ pf_m), pf_f (vector.of_fn (λ (i : fin pf_n), pf_g i a)))		case nat.primrec'.prec	n : ℕ,	f : vector ℕ n → ℕ,	pf_n : ℕ,	pf_f : vector ℕ pf_n → ℕ,	pf_g : vector ℕ (pf_n + 2) → ℕ,	pf_ᾰ : nat.primrec' pf_f,	pf_ᾰ_1 : nat.primrec' pf_g,	pf_ih_ᾰ : primrec pf_f,	pf_ih_ᾰ_1 : primrec pf_g	⊢ primrec (λ (v : vector ℕ (pf_n + 1)), nat.elim (pf_f v.tail) (λ (y IH : ℕ), pf_g (y::ᵥ IH::ᵥ v.tail)) v.head)
n : ℕ,	f : vector ℕ n → ℕ,	m n : ℕ,	f : vector ℕ n → ℕ,	g : fin n → vector ℕ m → ℕ,	pf_ᾰ : nat.primrec' f,	pf_ᾰ_1 : ∀ (i : fin n), nat.primrec' (g i),	hf : primrec f,	hg : ∀ (i : fin n), (λ {n : ℕ} {f : vector ℕ n → ℕ} (pf : nat.primrec' f), primrec f) _	⊢ primrec (λ (a : vector ℕ m), f (vector.of_fn (λ (i : fin n), g i a)))
n : ℕ,	f : vector ℕ n → ℕ,	pf_n : ℕ,	pf_f : vector ℕ pf_n → ℕ,	pf_g : vector ℕ (pf_n + 2) → ℕ,	pf_ᾰ : nat.primrec' pf_f,	pf_ᾰ_1 : nat.primrec' pf_g,	pf_ih_ᾰ : primrec pf_f,	pf_ih_ᾰ_1 : primrec pf_g	⊢ primrec (λ (v : vector ℕ (pf_n + 1)), nat.elim (pf_f v.tail) (λ (y IH : ℕ), pf_g (y::ᵥ IH::ᵥ v.tail)) v.head)
n : ℕ,	f : vector ℕ n → ℕ,	n : ℕ,	f : vector ℕ n → ℕ,	g : vector ℕ (n + 2) → ℕ,	pf_ᾰ : nat.primrec' f,	pf_ᾰ_1 : nat.primrec' g,	hf : primrec f,	hg : primrec g	⊢ primrec (λ (v : vector ℕ (n + 1)), nat.elim (f v.tail) (λ (y IH : ℕ), g (y::ᵥ IH::ᵥ v.tail)) v.head)
encode : ∀ {n : ℕ}, nat.primrec' encodable.encode,	v : vector ℕ 0	⊢ 0 = encodable.encode v
encode : ∀ {n : ℕ}, nat.primrec' encodable.encode,	v : vector ℕ 0	⊢ 0 = encodable.encode v
encode : ∀ {n : ℕ}, nat.primrec' encodable.encode,	v : vector ℕ 0	⊢ 0 = encodable.encode vector.nil
α : Type u_1,	_inst_1 : primcodable α	⊢ ∀ (n : ℕ), encodable.encode (encodable.decode α n) = encodable.encode (option.map id (encodable.decode α n))
α : Type u_1,	β : Type u_2,	_inst_3 : primcodable α,	_inst_4 : primcodable β,	n : ℕ	⊢ nat.unpaired (λ (z n : ℕ), nat.cases 0 (λ (y : ℕ), nat.unpaired (λ (z n : ℕ), nat.cases 0 (λ (y : ℕ), (nat.unpair (nat.mkpair z y)).snd.succ) n) (nat.mkpair (nat.unpair (nat.mkpair z y)).snd (encodable.encode (encodable.decode β (nat.unpair (nat.mkpair z y)).fst)))) n) (nat.mkpair (nat.unpair n).snd (encodable.encode (encodable.decode α (nat.unpair n).fst))) = encodable.encode (option.map prod.snd (encodable.decode (α × β) n))
α : Type u_1,	β : Type u_2,	_inst_3 : primcodable α,	_inst_4 : primcodable β,	n : ℕ	⊢ nat.cases 0 (λ (y : ℕ), nat.cases 0 nat.succ (encodable.encode (encodable.decode β (nat.unpair n).snd))) (encodable.encode (encodable.decode α (nat.unpair n).fst)) = encodable.encode (option.map prod.snd ((encodable.decode α (nat.unpair n).fst).bind (λ (a : α), option.map (prod.mk a) (encodable.decode β (nat.unpair n).snd))))
α : Type u_1,	β : Type u_2,	_inst_3 : primcodable α,	_inst_4 : primcodable β,	n : ℕ	⊢ nat.cases 0 (λ (y : ℕ), nat.cases 0 nat.succ (encodable.encode (encodable.decode β (nat.unpair n).snd))) (encodable.encode option.none) = encodable.encode (option.map prod.snd (option.none.bind (λ (a : α), option.map (prod.mk a) (encodable.decode β (nat.unpair n).snd))))
α : Type u_1,	β : Type u_2,	_inst_3 : primcodable α,	_inst_4 : primcodable β,	n : ℕ,	val : α	⊢ nat.cases 0 (λ (y : ℕ), nat.cases 0 nat.succ (encodable.encode (encodable.decode β (nat.unpair n).snd))) (encodable.encode (option.some val)) = encodable.encode (option.map prod.snd ((option.some val).bind (λ (a : α), option.map (prod.mk a) (encodable.decode β (nat.unpair n).snd))))
α : Type u_1,	β : Type u_2,	_inst_3 : primcodable α,	_inst_4 : primcodable β,	n : ℕ	⊢ nat.cases 0 (λ (y : ℕ), nat.cases 0 nat.succ (encodable.encode (encodable.decode β (nat.unpair n).snd))) (encodable.encode (encodable.decode α (nat.unpair n).fst)) = encodable.encode (option.map prod.snd ((encodable.decode α (nat.unpair n).fst).bind (λ (a : α), option.map (prod.mk a) (encodable.decode β (nat.unpair n).snd))))
α : Type u_1,	β : Type u_2,	_inst_3 : primcodable α,	_inst_4 : primcodable β,	n : ℕ,	val : α	⊢ nat.cases 0 nat.succ (encodable.encode (encodable.decode β (nat.unpair n).snd)) = encodable.encode (option.map (prod.snd ∘ prod.mk val) (encodable.decode β (nat.unpair n).snd))
α : Type u_1,	β : Type u_2,	_inst_3 : primcodable α,	_inst_4 : primcodable β,	n : ℕ,	val : α	⊢ nat.cases 0 nat.succ (encodable.encode option.none) = encodable.encode (option.map (prod.snd ∘ prod.mk val) option.none)
α : Type u_1,	β : Type u_2,	_inst_3 : primcodable α,	_inst_4 : primcodable β,	n : ℕ,	val : α,	val_1 : β	⊢ nat.cases 0 nat.succ (encodable.encode (option.some val_1)) = encodable.encode (option.map (prod.snd ∘ prod.mk val) (option.some val_1))
α : Type u_1,	β : Type u_2,	_inst_3 : primcodable α,	_inst_4 : primcodable β,	n : ℕ,	val : α	⊢ nat.cases 0 nat.succ (encodable.encode (encodable.decode β (nat.unpair n).snd)) = encodable.encode (option.map (prod.snd ∘ prod.mk val) (encodable.decode β (nat.unpair n).snd))
α : Type u_1,	β : Type u_2,	σ : Type u_5,	_inst_1 : primcodable α,	_inst_2 : primcodable β,	_inst_5 : primcodable σ,	f : α → β → option σ,	h : primrec₂ (λ (a : α) (n : ℕ), (encodable.decode β n).bind (f a))	⊢ primrec₂ f
α : Type u_1,	σ : Type u_5,	_inst_1 : primcodable α,	_inst_5 : primcodable σ,	c : α → Prop,	_inst_6 : decidable_pred c,	f g : α → σ,	hc : primrec_pred c,	hf : primrec f,	hg : primrec g	⊢ primrec (λ (a : α), ite (c a) (f a) (g a))
α : Type u_1,	_inst_1 : primcodable α,	_x : option α × option α,	_fun_match : ∀ (_a : option α × option α), _a.fst.cases_on _a.snd (λ (b : α), (_a, b).fst.fst) = (_a.fst <|> _a.snd),	o₁ o₂ : option α	⊢ (o₁, o₂).fst.cases_on (o₁, o₂).snd (λ (b : α), ((o₁, o₂), b).fst.fst) = ((o₁, o₂).fst <|> (o₁, o₂).snd)
α : Type u_1,	_inst_1 : primcodable α,	_x : option α × option α,	_fun_match : ∀ (_a : option α × option α), _a.fst.cases_on _a.snd (λ (b : α), (_a, b).fst.fst) = (_a.fst <|> _a.snd),	o₁ o₂ : option α	⊢ (o₁, o₂).fst.cases_on (o₁, o₂).snd (λ (b : α), ((o₁, o₂), b).fst.fst) = ((o₁, o₂).fst <|> (o₁, o₂).snd)
α : Type u_1,	_inst_1 : primcodable α,	_x : option α × option α,	_fun_match : ∀ (_a : option α × option α), _a.fst.cases_on _a.snd (λ (b : α), (_a, b).fst.fst) = (_a.fst <|> _a.snd),	o₁ o₂ : option α	⊢ (o₁, o₂).fst.cases_on (o₁, o₂).snd (λ (b : α), ((o₁, o₂), b).fst.fst) = ((o₁, o₂).fst <|> (o₁, o₂).snd)
α : Type u_1,	_inst_1 : primcodable α,	_x : option α × option α,	_fun_match : ∀ (_a : option α × option α), _a.fst.cases_on _a.snd (λ (b : α), (_a, b).fst.fst) = (_a.fst <|> _a.snd),	o₂ : option α	⊢ (option.none α, o₂).fst.cases_on (option.none α, o₂).snd (λ (b : α), ((option.none α, o₂), b).fst.fst) = ((option.none α, o₂).fst <|> (option.none α, o₂).snd)
α : Type u_1,	_inst_1 : primcodable α,	_x : option α × option α,	_fun_match : ∀ (_a : option α × option α), _a.fst.cases_on _a.snd (λ (b : α), (_a, b).fst.fst) = (_a.fst <|> _a.snd),	o₂ : option α,	o₁ : α	⊢ (option.some o₁, o₂).fst.cases_on (option.some o₁, o₂).snd (λ (b : α), ((option.some o₁, o₂), b).fst.fst) = ((option.some o₁, o₂).fst <|> (option.some o₁, o₂).snd)
α : Type u_1,	_inst_1 : primcodable α,	_x : option α × option α,	_fun_match : ∀ (_a : option α × option α), _a.fst.cases_on _a.snd (λ (b : α), (_a, b).fst.fst) = (_a.fst <|> _a.snd)	⊢ (option.none α, option.none α).fst.cases_on (option.none α, option.none α).snd (λ (b : α), ((option.none α, option.none α), b).fst.fst) = ((option.none α, option.none α).fst <|> (option.none α, option.none α).snd)
α : Type u_1,	_inst_1 : primcodable α,	_x : option α × option α,	_fun_match : ∀ (_a : option α × option α), _a.fst.cases_on _a.snd (λ (b : α), (_a, b).fst.fst) = (_a.fst <|> _a.snd),	o₂ : α	⊢ (option.none α, option.some o₂).fst.cases_on (option.none α, option.some o₂).snd (λ (b : α), ((option.none α, option.some o₂), b).fst.fst) = ((option.none α, option.some o₂).fst <|> (option.none α, option.some o₂).snd)
α : Type u_1,	_inst_1 : primcodable α,	_x : option α × option α,	_fun_match : ∀ (_a : option α × option α), _a.fst.cases_on _a.snd (λ (b : α), (_a, b).fst.fst) = (_a.fst <|> _a.snd),	o₁ : α	⊢ (option.some o₁, option.none α).fst.cases_on (option.some o₁, option.none α).snd (λ (b : α), ((option.some o₁, option.none α), b).fst.fst) = ((option.some o₁, option.none α).fst <|> (option.some o₁, option.none α).snd)
α : Type u_1,	_inst_1 : primcodable α,	_x : option α × option α,	_fun_match : ∀ (_a : option α × option α), _a.fst.cases_on _a.snd (λ (b : α), (_a, b).fst.fst) = (_a.fst <|> _a.snd),	o₁ o₂ : α	⊢ (option.some o₁, option.some o₂).fst.cases_on (option.some o₁, option.some o₂).snd (λ (b : α), ((option.some o₁, option.some o₂), b).fst.fst) = ((option.some o₁, option.some o₂).fst <|> (option.some o₁, option.some o₂).snd)
α : Type u_1,	_inst_1 : primcodable α	⊢ nat.primrec (λ (n : ℕ), encodable.encode (encodable.decode (list α) n))
α : Type u_1,	_inst_1 : primcodable α,	H : nat.primrec (λ (n : ℕ), encodable.encode (encodable.decode (list ℕ) n)) := primcodable.prim (list ℕ)	⊢ nat.primrec (λ (n : ℕ), encodable.encode (encodable.decode (list α) n))
α : Type u_1,	_inst_1 : primcodable α	⊢ nat.primrec (λ (n : ℕ), encodable.encode (encodable.decode (list α) n))
α : Type u_1,	_inst_1 : primcodable α,	H : nat.primrec (λ (n : ℕ), encodable.encode (encodable.decode (list ℕ) n)) := primcodable.prim (list ℕ),	this : primrec₂ (λ (a : α) (o : option (list ℕ)), option.map (list.cons (encodable.encode a)) o),	this : primrec (λ (n : ℕ), list.foldl (λ (o : option (list ℕ)) (m : ℕ), (encodable.decode α m).bind (λ (a : α), option.map (list.cons (encodable.encode a)) o)) (option.some list.nil) (denumerable.of_nat (list ℕ) n).reverse),	n : ℕ	⊢ encodable.encode (list.foldl (λ (o : option (list ℕ)) (m : ℕ), (encodable.decode α m).bind (λ (a : α), option.map (list.cons (encodable.encode a)) o)) (option.some list.nil) (denumerable.of_nat (list ℕ) n).reverse) = encodable.encode (encodable.decode (list α) n)
α : Type u_1,	_inst_1 : primcodable α,	H : nat.primrec (λ (n : ℕ), encodable.encode (encodable.decode (list ℕ) n)) := primcodable.prim (list ℕ),	this : primrec₂ (λ (a : α) (o : option (list ℕ)), option.map (list.cons (encodable.encode a)) o),	this : primrec (λ (n : ℕ), list.foldl (λ (o : option (list ℕ)) (m : ℕ), (encodable.decode α m).bind (λ (a : α), option.map (list.cons (encodable.encode a)) o)) (option.some list.nil) (denumerable.of_nat (list ℕ) n).reverse),	n : ℕ	⊢ encodable.encode (list.foldr (λ (x : ℕ) (y : option (list ℕ)), (encodable.decode α x).bind (λ (a : α), option.map (list.cons (encodable.encode a)) y)) (option.some list.nil) (denumerable.of_nat (list ℕ) n)) = encodable.encode (encodable.decode (list α) n)
α : Type u_1,	_inst_1 : primcodable α,	H : nat.primrec (λ (n : ℕ), encodable.encode (encodable.decode (list ℕ) n)) := primcodable.prim (list ℕ),	this : primrec₂ (λ (a : α) (o : option (list ℕ)), option.map (list.cons (encodable.encode a)) o),	this : primrec (λ (n : ℕ), list.foldl (λ (o : option (list ℕ)) (m : ℕ), (encodable.decode α m).bind (λ (a : α), option.map (list.cons (encodable.encode a)) o)) (option.some list.nil) (denumerable.of_nat (list ℕ) n).reverse),	n : ℕ	⊢ encodable.encode (list.foldr (λ (x : ℕ) (y : option (list ℕ)), (encodable.decode α x).bind (λ (a : α), option.map (list.cons (encodable.encode a)) y)) (option.some list.nil) (denumerable.of_nat (list ℕ) 0)) = encodable.encode (encodable.decode (list α) 0)
α : Type u_1,	_inst_1 : primcodable α,	H : nat.primrec (λ (n : ℕ), encodable.encode (encodable.decode (list ℕ) n)) := primcodable.prim (list ℕ),	this : primrec₂ (λ (a : α) (o : option (list ℕ)), option.map (list.cons (encodable.encode a)) o),	this : primrec (λ (n : ℕ), list.foldl (λ (o : option (list ℕ)) (m : ℕ), (encodable.decode α m).bind (λ (a : α), option.map (list.cons (encodable.encode a)) o)) (option.some list.nil) (denumerable.of_nat (list ℕ) n).reverse),	n : ℕ	⊢ encodable.encode (list.foldr (λ (x : ℕ) (y : option (list ℕ)), (encodable.decode α x).bind (λ (a : α), option.map (list.cons (encodable.encode a)) y)) (option.some list.nil) (denumerable.of_nat (list ℕ) 0)) = encodable.encode (encodable.decode (list α) 0)		α : Type u_1,	_inst_1 : primcodable α,	H : nat.primrec (λ (n : ℕ), encodable.encode (encodable.decode (list ℕ) n)) := primcodable.prim (list ℕ),	this : primrec₂ (λ (a : α) (o : option (list ℕ)), option.map (list.cons (encodable.encode a)) o),	this : primrec (λ (n : ℕ), list.foldl (λ (o : option (list ℕ)) (m : ℕ), (encodable.decode α m).bind (λ (a : α), option.map (list.cons (encodable.encode a)) o)) (option.some list.nil) (denumerable.of_nat (list ℕ) n).reverse),	n : ℕ	⊢ ∀ (n : ℕ), (∀ (m : ℕ), m ≤ n → encodable.encode (list.foldr (λ (x : ℕ) (y : option (list ℕ)), (encodable.decode α x).bind (λ (a : α), option.map (list.cons (encodable.encode a)) y)) (option.some list.nil) (denumerable.of_nat (list ℕ) m)) = encodable.encode (encodable.decode (list α) m)) → encodable.encode (list.foldr (λ (x : ℕ) (y : option (list ℕ)), (encodable.decode α x).bind (λ (a : α), option.map (list.cons (encodable.encode a)) y)) (option.some list.nil) (denumerable.of_nat (list ℕ) n.succ)) = encodable.encode (encodable.decode (list α) n.succ)
α : Type u_1,	_inst_1 : primcodable α,	H : nat.primrec (λ (n : ℕ), encodable.encode (encodable.decode (list ℕ) n)) := primcodable.prim (list ℕ),	this : primrec₂ (λ (a : α) (o : option (list ℕ)), option.map (list.cons (encodable.encode a)) o),	this : primrec (λ (n : ℕ), list.foldl (λ (o : option (list ℕ)) (m : ℕ), (encodable.decode α m).bind (λ (a : α), option.map (list.cons (encodable.encode a)) o)) (option.some list.nil) (denumerable.of_nat (list ℕ) n).reverse),	n n : ℕ,	IH : ∀ (m : ℕ), m ≤ n → encodable.encode (list.foldr (λ (x : ℕ) (y : option (list ℕ)), (encodable.decode α x).bind (λ (a : α), option.map (list.cons (encodable.encode a)) y)) (option.some list.nil) (denumerable.of_nat (list ℕ) m)) = encodable.encode (encodable.decode (list α) m)	⊢ encodable.encode (list.foldr (λ (x : ℕ) (y : option (list ℕ)), (encodable.decode α x).bind (λ (a : α), option.map (list.cons (encodable.encode a)) y)) (option.some list.nil) (denumerable.of_nat (list ℕ) n.succ)) = encodable.encode (encodable.decode (list α) n.succ)
α : Type u_1,	_inst_1 : primcodable α,	H : nat.primrec (λ (n : ℕ), encodable.encode (encodable.decode (list ℕ) n)) := primcodable.prim (list ℕ),	this : primrec₂ (λ (a : α) (o : option (list ℕ)), option.map (list.cons (encodable.encode a)) o),	this : primrec (λ (n : ℕ), list.foldl (λ (o : option (list ℕ)) (m : ℕ), (encodable.decode α m).bind (λ (a : α), option.map (list.cons (encodable.encode a)) o)) (option.some list.nil) (denumerable.of_nat (list ℕ) n).reverse),	n : ℕ	⊢ ∀ (n : ℕ), (∀ (m : ℕ), m ≤ n → encodable.encode (list.foldr (λ (x : ℕ) (y : option (list ℕ)), (encodable.decode α x).bind (λ (a : α), option.map (list.cons (encodable.encode a)) y)) (option.some list.nil) (denumerable.of_nat (list ℕ) m)) = encodable.encode (encodable.decode (list α) m)) → encodable.encode (list.foldr (λ (x : ℕ) (y : option (list ℕ)), (encodable.decode α x).bind (λ (a : α), option.map (list.cons (encodable.encode a)) y)) (option.some list.nil) (denumerable.of_nat (list ℕ) n.succ)) = encodable.encode (encodable.decode (list α) n.succ)
α : Type u_1,	_inst_1 : primcodable α,	H : nat.primrec (λ (n : ℕ), encodable.encode (encodable.decode (list ℕ) n)) := primcodable.prim (list ℕ),	this : primrec₂ (λ (a : α) (o : option (list ℕ)), option.map (list.cons (encodable.encode a)) o),	this : primrec (λ (n : ℕ), list.foldl (λ (o : option (list ℕ)) (m : ℕ), (encodable.decode α m).bind (λ (a : α), option.map (list.cons (encodable.encode a)) o)) (option.some list.nil) (denumerable.of_nat (list ℕ) n).reverse),	n n : ℕ,	IH : ∀ (m : ℕ), m ≤ n → encodable.encode (list.foldr (λ (x : ℕ) (y : option (list ℕ)), (encodable.decode α x).bind (λ (a : α), option.map (list.cons (encodable.encode a)) y)) (option.some list.nil) (denumerable.of_nat (list ℕ) m)) = encodable.encode (encodable.decode (list α) m)	⊢ encodable.encode (option.none.bind (λ (a : α), option.map (list.cons (encodable.encode a)) (list.foldr (λ (x : ℕ) (y : option (list ℕ)), (encodable.decode α x).bind (λ (a : α), option.map (list.cons (encodable.encode a)) y)) (option.some list.nil) (denumerable.of_nat (list ℕ) (nat.unpair n).snd)))) = encodable.encode (option.map list.cons option.none <*> encodable.decode (list α) (nat.unpair n).snd)
α : Type u_1,	_inst_1 : primcodable α,	H : nat.primrec (λ (n : ℕ), encodable.encode (encodable.decode (list ℕ) n)) := primcodable.prim (list ℕ),	this : primrec₂ (λ (a : α) (o : option (list ℕ)), option.map (list.cons (encodable.encode a)) o),	this : primrec (λ (n : ℕ), list.foldl (λ (o : option (list ℕ)) (m : ℕ), (encodable.decode α m).bind (λ (a : α), option.map (list.cons (encodable.encode a)) o)) (option.some list.nil) (denumerable.of_nat (list ℕ) n).reverse),	n n : ℕ,	IH : ∀ (m : ℕ), m ≤ n → encodable.encode (list.foldr (λ (x : ℕ) (y : option (list ℕ)), (encodable.decode α x).bind (λ (a : α), option.map (list.cons (encodable.encode a)) y)) (option.some list.nil) (denumerable.of_nat (list ℕ) m)) = encodable.encode (encodable.decode (list α) m)	⊢ encodable.encode ((encodable.decode α (nat.unpair n).fst).bind (λ (a : α), option.map (list.cons (encodable.encode a)) (list.foldr (λ (x : ℕ) (y : option (list ℕ)), (encodable.decode α x).bind (λ (a : α), option.map (list.cons (encodable.encode a)) y)) (option.some list.nil) (denumerable.of_nat (list ℕ) (nat.unpair n).snd)))) = encodable.encode (option.map list.cons (encodable.decode α (nat.unpair n).fst) <*> encodable.decode (list α) (nat.unpair n).snd)
α : Type u_1,	_inst_1 : primcodable α,	H : nat.primrec (λ (n : ℕ), encodable.encode (encodable.decode (list ℕ) n)) := primcodable.prim (list ℕ),	this : primrec₂ (λ (a : α) (o : option (list ℕ)), option.map (list.cons (encodable.encode a)) o),	this : primrec (λ (n : ℕ), list.foldl (λ (o : option (list ℕ)) (m : ℕ), (encodable.decode α m).bind (λ (a : α), option.map (list.cons (encodable.encode a)) o)) (option.some list.nil) (denumerable.of_nat (list ℕ) n).reverse),	n n : ℕ,	IH : ∀ (m : ℕ), m ≤ n → encodable.encode (list.foldr (λ (x : ℕ) (y : option (list ℕ)), (encodable.decode α x).bind (λ (a : α), option.map (list.cons (encodable.encode a)) y)) (option.some list.nil) (denumerable.of_nat (list ℕ) m)) = encodable.encode (encodable.decode (list α) m)	⊢ encodable.encode (option.none.bind (λ (a : α), option.map (list.cons (encodable.encode a)) (list.foldr (λ (x : ℕ) (y : option (list ℕ)), (encodable.decode α x).bind (λ (a : α), option.map (list.cons (encodable.encode a)) y)) (option.some list.nil) (denumerable.of_nat (list ℕ) (nat.unpair n).snd)))) = encodable.encode (option.map list.cons option.none <*> encodable.decode (list α) (nat.unpair n).snd)		case option.some	α : Type u_1,	_inst_1 : primcodable α,	H : nat.primrec (λ (n : ℕ), encodable.encode (encodable.decode (list ℕ) n)) := primcodable.prim (list ℕ),	this : primrec₂ (λ (a : α) (o : option (list ℕ)), option.map (list.cons (encodable.encode a)) o),	this : primrec (λ (n : ℕ), list.foldl (λ (o : option (list ℕ)) (m : ℕ), (encodable.decode α m).bind (λ (a : α), option.map (list.cons (encodable.encode a)) o)) (option.some list.nil) (denumerable.of_nat (list ℕ) n).reverse),	n n : ℕ,	IH : ∀ (m : ℕ), m ≤ n → encodable.encode (list.foldr (λ (x : ℕ) (y : option (list ℕ)), (encodable.decode α x).bind (λ (a : α), option.map (list.cons (encodable.encode a)) y)) (option.some list.nil) (denumerable.of_nat (list ℕ) m)) = encodable.encode (encodable.decode (list α) m),	a : α	⊢ encodable.encode ((option.some a).bind (λ (a : α), option.map (list.cons (encodable.encode a)) (list.foldr (λ (x : ℕ) (y : option (list ℕ)), (encodable.decode α x).bind (λ (a : α), option.map (list.cons (encodable.encode a)) y)) (option.some list.nil) (denumerable.of_nat (list ℕ) (nat.unpair n).snd)))) = encodable.encode (option.map list.cons (option.some a) <*> encodable.decode (list α) (nat.unpair n).snd)
α : Type u_1,	_inst_1 : primcodable α,	H : nat.primrec (λ (n : ℕ), encodable.encode (encodable.decode (list ℕ) n)) := primcodable.prim (list ℕ),	this : primrec₂ (λ (a : α) (o : option (list ℕ)), option.map (list.cons (encodable.encode a)) o),	this : primrec (λ (n : ℕ), list.foldl (λ (o : option (list ℕ)) (m : ℕ), (encodable.decode α m).bind (λ (a : α), option.map (list.cons (encodable.encode a)) o)) (option.some list.nil) (denumerable.of_nat (list ℕ) n).reverse),	n n : ℕ,	IH : ∀ (m : ℕ), m ≤ n → encodable.encode (list.foldr (λ (x : ℕ) (y : option (list ℕ)), (encodable.decode α x).bind (λ (a : α), option.map (list.cons (encodable.encode a)) y)) (option.some list.nil) (denumerable.of_nat (list ℕ) m)) = encodable.encode (encodable.decode (list α) m),	a : α	⊢ encodable.encode ((option.some a).bind (λ (a : α), option.map (list.cons (encodable.encode a)) (list.foldr (λ (x : ℕ) (y : option (list ℕ)), (encodable.decode α x).bind (λ (a : α), option.map (list.cons (encodable.encode a)) y)) (option.some list.nil) (denumerable.of_nat (list ℕ) (nat.unpair n).snd)))) = encodable.encode (option.map list.cons (option.some a) <*> encodable.decode (list α) (nat.unpair n).snd)
α : Type u_1,	_inst_1 : primcodable α,	H : nat.primrec (λ (n : ℕ), encodable.encode (encodable.decode (list ℕ) n)) := primcodable.prim (list ℕ),	this : primrec₂ (λ (a : α) (o : option (list ℕ)), option.map (list.cons (encodable.encode a)) o),	this : primrec (λ (n : ℕ), list.foldl (λ (o : option (list ℕ)) (m : ℕ), (encodable.decode α m).bind (λ (a : α), option.map (list.cons (encodable.encode a)) o)) (option.some list.nil) (denumerable.of_nat (list ℕ) n).reverse),	n n : ℕ,	IH : ∀ (m : ℕ), m ≤ n → encodable.encode (list.foldr (λ (x : ℕ) (y : option (list ℕ)), (encodable.decode α x).bind (λ (a : α), option.map (list.cons (encodable.encode a)) y)) (option.some list.nil) (denumerable.of_nat (list ℕ) m)) = encodable.encode (encodable.decode (list α) m),	a : α	⊢ encodable.encode (option.map (list.cons (encodable.encode a)) (list.foldr (λ (x : ℕ) (y : option (list ℕ)), (encodable.decode α x).bind (λ (a : α), option.map (list.cons (encodable.encode a)) y)) (option.some list.nil) (denumerable.of_nat (list ℕ) (nat.unpair n).snd))) = encodable.encode (option.some (list.cons a) <*> encodable.decode (list α) (nat.unpair n).snd)
α : Type u_1,	_inst_1 : primcodable α,	H : nat.primrec (λ (n : ℕ), encodable.encode (encodable.decode (list ℕ) n)) := primcodable.prim (list ℕ),	this : primrec₂ (λ (a : α) (o : option (list ℕ)), option.map (list.cons (encodable.encode a)) o),	this : primrec (λ (n : ℕ), list.foldl (λ (o : option (list ℕ)) (m : ℕ), (encodable.decode α m).bind (λ (a : α), option.map (list.cons (encodable.encode a)) o)) (option.some list.nil) (denumerable.of_nat (list ℕ) n).reverse),	n n : ℕ,	IH : ∀ (m : ℕ), m ≤ n → encodable.encode (list.foldr (λ (x : ℕ) (y : option (list ℕ)), (encodable.decode α x).bind (λ (a : α), option.map (list.cons (encodable.encode a)) y)) (option.some list.nil) (denumerable.of_nat (list ℕ) m)) = encodable.encode (encodable.decode (list α) m),	a : α,	this : ∀ (o : option (list ℕ)) (p : option (list α)), encodable.encode o = encodable.encode p → encodable.encode (option.map (list.cons (encodable.encode a)) o) = encodable.encode (option.map (list.cons a) p)	⊢ encodable.encode (option.map (list.cons (encodable.encode a)) (list.foldr (λ (x : ℕ) (y : option (list ℕ)), (encodable.decode α x).bind (λ (a : α), option.map (list.cons (encodable.encode a)) y)) (option.some list.nil) (denumerable.of_nat (list ℕ) (nat.unpair n).snd))) = encodable.encode (option.some (list.cons a) <*> encodable.decode (list α) (nat.unpair n).snd)		α : Type u_1,	_inst_1 : primcodable α,	H : nat.primrec (λ (n : ℕ), encodable.encode (encodable.decode (list ℕ) n)) := primcodable.prim (list ℕ),	this : primrec₂ (λ (a : α) (o : option (list ℕ)), option.map (list.cons (encodable.encode a)) o),	this : primrec (λ (n : ℕ), list.foldl (λ (o : option (list ℕ)) (m : ℕ), (encodable.decode α m).bind (λ (a : α), option.map (list.cons (encodable.encode a)) o)) (option.some list.nil) (denumerable.of_nat (list ℕ) n).reverse),	n n : ℕ,	IH : ∀ (m : ℕ), m ≤ n → encodable.encode (list.foldr (λ (x : ℕ) (y : option (list ℕ)), (encodable.decode α x).bind (λ (a : α), option.map (list.cons (encodable.encode a)) y)) (option.some list.nil) (denumerable.of_nat (list ℕ) m)) = encodable.encode (encodable.decode (list α) m),	a : α	⊢ ∀ (o : option (list ℕ)) (p : option (list α)), encodable.encode o = encodable.encode p → encodable.encode (option.map (list.cons (encodable.encode a)) o) = encodable.encode (option.map (list.cons a) p)
α : Type u_1,	_inst_1 : primcodable α,	H : nat.primrec (λ (n : ℕ), encodable.encode (encodable.decode (list ℕ) n)) := primcodable.prim (list ℕ),	this : primrec₂ (λ (a : α) (o : option (list ℕ)), option.map (list.cons (encodable.encode a)) o),	this : primrec (λ (n : ℕ), list.foldl (λ (o : option (list ℕ)) (m : ℕ), (encodable.decode α m).bind (λ (a : α), option.map (list.cons (encodable.encode a)) o)) (option.some list.nil) (denumerable.of_nat (list ℕ) n).reverse),	n n : ℕ,	IH : ∀ (m : ℕ), m ≤ n → encodable.encode (list.foldr (λ (x : ℕ) (y : option (list ℕ)), (encodable.decode α x).bind (λ (a : α), option.map (list.cons (encodable.encode a)) y)) (option.some list.nil) (denumerable.of_nat (list ℕ) m)) = encodable.encode (encodable.decode (list α) m),	a : α	⊢ ∀ (o : option (list ℕ)) (p : option (list α)), encodable.encode o = encodable.encode p → encodable.encode (option.map (list.cons (encodable.encode a)) o) = encodable.encode (option.map (list.cons a) p)
α : Type u_1,	_inst_1 : primcodable α,	H : nat.primrec (λ (n : ℕ), encodable.encode (encodable.decode (list ℕ) n)) := primcodable.prim (list ℕ),	this : primrec₂ (λ (a : α) (o : option (list ℕ)), option.map (list.cons (encodable.encode a)) o),	this : primrec (λ (n : ℕ), list.foldl (λ (o : option (list ℕ)) (m : ℕ), (encodable.decode α m).bind (λ (a : α), option.map (list.cons (encodable.encode a)) o)) (option.some list.nil) (denumerable.of_nat (list ℕ) n).reverse),	n n : ℕ,	IH : ∀ (m : ℕ), m ≤ n → encodable.encode (list.foldr (λ (x : ℕ) (y : option (list ℕ)), (encodable.decode α x).bind (λ (a : α), option.map (list.cons (encodable.encode a)) y)) (option.some list.nil) (denumerable.of_nat (list ℕ) m)) = encodable.encode (encodable.decode (list α) m),	a : α,	o : option (list ℕ),	p : option (list α),	IH : encodable.encode o = encodable.encode p	⊢ encodable.encode (option.map (list.cons (encodable.encode a)) o) = encodable.encode (option.map (list.cons a) p)
α : Type u_1,	_inst_1 : primcodable α,	H : nat.primrec (λ (n : ℕ), encodable.encode (encodable.decode (list ℕ) n)) := primcodable.prim (list ℕ),	this : primrec₂ (λ (a : α) (o : option (list ℕ)), option.map (list.cons (encodable.encode a)) o),	this : primrec (λ (n : ℕ), list.foldl (λ (o : option (list ℕ)) (m : ℕ), (encodable.decode α m).bind (λ (a : α), option.map (list.cons (encodable.encode a)) o)) (option.some list.nil) (denumerable.of_nat (list ℕ) n).reverse),	n n : ℕ,	IH : ∀ (m : ℕ), m ≤ n → encodable.encode (list.foldr (λ (x : ℕ) (y : option (list ℕ)), (encodable.decode α x).bind (λ (a : α), option.map (list.cons (encodable.encode a)) y)) (option.some list.nil) (denumerable.of_nat (list ℕ) m)) = encodable.encode (encodable.decode (list α) m),	a : α,	o : option (list ℕ),	p : option (list α),	IH : encodable.encode o = encodable.encode p	⊢ encodable.encode (option.map (list.cons (encodable.encode a)) o) = encodable.encode (option.map (list.cons a) p)
α : Type u_1,	_inst_1 : primcodable α,	H : nat.primrec (λ (n : ℕ), encodable.encode (encodable.decode (list ℕ) n)) := primcodable.prim (list ℕ),	this : primrec₂ (λ (a : α) (o : option (list ℕ)), option.map (list.cons (encodable.encode a)) o),	this : primrec (λ (n : ℕ), list.foldl (λ (o : option (list ℕ)) (m : ℕ), (encodable.decode α m).bind (λ (a : α), option.map (list.cons (encodable.encode a)) o)) (option.some list.nil) (denumerable.of_nat (list ℕ) n).reverse),	n n : ℕ,	IH : ∀ (m : ℕ), m ≤ n → encodable.encode (list.foldr (λ (x : ℕ) (y : option (list ℕ)), (encodable.decode α x).bind (λ (a : α), option.map (list.cons (encodable.encode a)) y)) (option.some list.nil) (denumerable.of_nat (list ℕ) m)) = encodable.encode (encodable.decode (list α) m),	a : α,	p : option (list α),	IH : encodable.encode option.none = encodable.encode p	⊢ encodable.encode (option.map (list.cons (encodable.encode a)) option.none) = encodable.encode (option.map (list.cons a) p)
α : Type u_1,	_inst_1 : primcodable α,	H : nat.primrec (λ (n : ℕ), encodable.encode (encodable.decode (list ℕ) n)) := primcodable.prim (list ℕ),	this : primrec₂ (λ (a : α) (o : option (list ℕ)), option.map (list.cons (encodable.encode a)) o),	this : primrec (λ (n : ℕ), list.foldl (λ (o : option (list ℕ)) (m : ℕ), (encodable.decode α m).bind (λ (a : α), option.map (list.cons (encodable.encode a)) o)) (option.some list.nil) (denumerable.of_nat (list ℕ) n).reverse),	n n : ℕ,	IH : ∀ (m : ℕ), m ≤ n → encodable.encode (list.foldr (λ (x : ℕ) (y : option (list ℕ)), (encodable.decode α x).bind (λ (a : α), option.map (list.cons (encodable.encode a)) y)) (option.some list.nil) (denumerable.of_nat (list ℕ) m)) = encodable.encode (encodable.decode (list α) m),	a : α,	p : option (list α),	o : list ℕ,	IH : encodable.encode (option.some o) = encodable.encode p	⊢ encodable.encode (option.map (list.cons (encodable.encode a)) (option.some o)) = encodable.encode (option.map (list.cons a) p)
α : Type u_1,	_inst_1 : primcodable α,	H : nat.primrec (λ (n : ℕ), encodable.encode (encodable.decode (list ℕ) n)) := primcodable.prim (list ℕ),	this : primrec₂ (λ (a : α) (o : option (list ℕ)), option.map (list.cons (encodable.encode a)) o),	this : primrec (λ (n : ℕ), list.foldl (λ (o : option (list ℕ)) (m : ℕ), (encodable.decode α m).bind (λ (a : α), option.map (list.cons (encodable.encode a)) o)) (option.some list.nil) (denumerable.of_nat (list ℕ) n).reverse),	n n : ℕ,	IH : ∀ (m : ℕ), m ≤ n → encodable.encode (list.foldr (λ (x : ℕ) (y : option (list ℕ)), (encodable.decode α x).bind (λ (a : α), option.map (list.cons (encodable.encode a)) y)) (option.some list.nil) (denumerable.of_nat (list ℕ) m)) = encodable.encode (encodable.decode (list α) m),	a : α,	IH : encodable.encode option.none = encodable.encode option.none	⊢ encodable.encode (option.map (list.cons (encodable.encode a)) option.none) = encodable.encode (option.map (list.cons a) option.none)
α : Type u_1,	_inst_1 : primcodable α,	H : nat.primrec (λ (n : ℕ), encodable.encode (encodable.decode (list ℕ) n)) := primcodable.prim (list ℕ),	this : primrec₂ (λ (a : α) (o : option (list ℕ)), option.map (list.cons (encodable.encode a)) o),	this : primrec (λ (n : ℕ), list.foldl (λ (o : option (list ℕ)) (m : ℕ), (encodable.decode α m).bind (λ (a : α), option.map (list.cons (encodable.encode a)) o)) (option.some list.nil) (denumerable.of_nat (list ℕ) n).reverse),	n n : ℕ,	IH : ∀ (m : ℕ), m ≤ n → encodable.encode (list.foldr (λ (x : ℕ) (y : option (list ℕ)), (encodable.decode α x).bind (λ (a : α), option.map (list.cons (encodable.encode a)) y)) (option.some list.nil) (denumerable.of_nat (list ℕ) m)) = encodable.encode (encodable.decode (list α) m),	a : α,	p : list α,	IH : encodable.encode option.none = encodable.encode (option.some p)	⊢ encodable.encode (option.map (list.cons (encodable.encode a)) option.none) = encodable.encode (option.map (list.cons a) (option.some p))
α : Type u_1,	_inst_1 : primcodable α,	H : nat.primrec (λ (n : ℕ), encodable.encode (encodable.decode (list ℕ) n)) := primcodable.prim (list ℕ),	this : primrec₂ (λ (a : α) (o : option (list ℕ)), option.map (list.cons (encodable.encode a)) o),	this : primrec (λ (n : ℕ), list.foldl (λ (o : option (list ℕ)) (m : ℕ), (encodable.decode α m).bind (λ (a : α), option.map (list.cons (encodable.encode a)) o)) (option.some list.nil) (denumerable.of_nat (list ℕ) n).reverse),	n n : ℕ,	IH : ∀ (m : ℕ), m ≤ n → encodable.encode (list.foldr (λ (x : ℕ) (y : option (list ℕ)), (encodable.decode α x).bind (λ (a : α), option.map (list.cons (encodable.encode a)) y)) (option.some list.nil) (denumerable.of_nat (list ℕ) m)) = encodable.encode (encodable.decode (list α) m),	a : α,	o : list ℕ,	IH : encodable.encode (option.some o) = encodable.encode option.none	⊢ encodable.encode (option.map (list.cons (encodable.encode a)) (option.some o)) = encodable.encode (option.map (list.cons a) option.none)
α : Type u_1,	_inst_1 : primcodable α,	H : nat.primrec (λ (n : ℕ), encodable.encode (encodable.decode (list ℕ) n)) := primcodable.prim (list ℕ),	this : primrec₂ (λ (a : α) (o : option (list ℕ)), option.map (list.cons (encodable.encode a)) o),	this : primrec (λ (n : ℕ), list.foldl (λ (o : option (list ℕ)) (m : ℕ), (encodable.decode α m).bind (λ (a : α), option.map (list.cons (encodable.encode a)) o)) (option.some list.nil) (denumerable.of_nat (list ℕ) n).reverse),	n n : ℕ,	IH : ∀ (m : ℕ), m ≤ n → encodable.encode (list.foldr (λ (x : ℕ) (y : option (list ℕ)), (encodable.decode α x).bind (λ (a : α), option.map (list.cons (encodable.encode a)) y)) (option.some list.nil) (denumerable.of_nat (list ℕ) m)) = encodable.encode (encodable.decode (list α) m),	a : α,	o : list ℕ,	p : list α,	IH : encodable.encode (option.some o) = encodable.encode (option.some p)	⊢ encodable.encode (option.map (list.cons (encodable.encode a)) (option.some o)) = encodable.encode (option.map (list.cons a) (option.some p))
α : Type u_1,	_inst_1 : primcodable α,	H : nat.primrec (λ (n : ℕ), encodable.encode (encodable.decode (list ℕ) n)) := primcodable.prim (list ℕ),	this : primrec₂ (λ (a : α) (o : option (list ℕ)), option.map (list.cons (encodable.encode a)) o),	this : primrec (λ (n : ℕ), list.foldl (λ (o : option (list ℕ)) (m : ℕ), (encodable.decode α m).bind (λ (a : α), option.map (list.cons (encodable.encode a)) o)) (option.some list.nil) (denumerable.of_nat (list ℕ) n).reverse),	n n : ℕ,	IH : ∀ (m : ℕ), m ≤ n → encodable.encode (list.foldr (λ (x : ℕ) (y : option (list ℕ)), (encodable.decode α x).bind (λ (a : α), option.map (list.cons (encodable.encode a)) y)) (option.some list.nil) (denumerable.of_nat (list ℕ) m)) = encodable.encode (encodable.decode (list α) m),	a : α,	o : option (list ℕ),	p : option (list α),	IH : encodable.encode o = encodable.encode p	⊢ encodable.encode (option.map (list.cons (encodable.encode a)) o) = encodable.encode (option.map (list.cons a) p)
α : Type u_1,	_inst_1 : primcodable α,	H : nat.primrec (λ (n : ℕ), encodable.encode (encodable.decode (list ℕ) n)) := primcodable.prim (list ℕ),	this : primrec₂ (λ (a : α) (o : option (list ℕ)), option.map (list.cons (encodable.encode a)) o),	this : primrec (λ (n : ℕ), list.foldl (λ (o : option (list ℕ)) (m : ℕ), (encodable.decode α m).bind (λ (a : α), option.map (list.cons (encodable.encode a)) o)) (option.some list.nil) (denumerable.of_nat (list ℕ) n).reverse),	n n : ℕ,	IH : ∀ (m : ℕ), m ≤ n → encodable.encode (list.foldr (λ (x : ℕ) (y : option (list ℕ)), (encodable.decode α x).bind (λ (a : α), option.map (list.cons (encodable.encode a)) y)) (option.some list.nil) (denumerable.of_nat (list ℕ) m)) = encodable.encode (encodable.decode (list α) m),	a : α,	o : list ℕ,	p : list α,	IH : encodable.encode (option.some o) = encodable.encode (option.some p),	h : encodable.encode o = encodable.encode p	⊢ encodable.encode (option.map (list.cons (encodable.encode a)) (option.some o)) = encodable.encode (option.map (list.cons a) (option.some p))
d₁ d₂ : many_one_degree	⊢ ?m_1 + d₂ ≤ d₁ + d₂
v : list ℕ	⊢ turing.to_partrec.code.head.eval v = has_pure.pure [v.head]
K : Type u_1,	_inst_1 : decidable_eq K,	Γ : K → Type u_2,	Λ : Type u_3,	_inst_2 : inhabited Λ,	σ : Type u_4,	_inst_3 : inhabited σ,	S : finset Λ,	k : K,	s : turing.TM2to1.st_act k,	q : turing.TM2.stmt Γ Λ σ	⊢ turing.TM2.supports_stmt S (turing.TM2to1.st_run s q) ↔ turing.TM2.supports_stmt S q
K : Type u_1,	_inst_1 : decidable_eq K,	Γ : K → Type u_2,	Λ : Type u_3,	_inst_2 : inhabited Λ,	σ : Type u_4,	_inst_3 : inhabited σ,	S : finset Λ,	k : K,	q : turing.TM2.stmt Γ Λ σ,	s : σ → Γ k	⊢ turing.TM2.supports_stmt S (turing.TM2to1.st_run (turing.TM2to1.st_act.push s) q) ↔ turing.TM2.supports_stmt S q
K : Type u_1,	_inst_1 : decidable_eq K,	Γ : K → Type u_2,	Λ : Type u_3,	_inst_2 : inhabited Λ,	σ : Type u_4,	_inst_3 : inhabited σ,	S : finset Λ,	k : K,	q : turing.TM2.stmt Γ Λ σ,	s : σ → option (Γ k) → σ	⊢ turing.TM2.supports_stmt S (turing.TM2to1.st_run (turing.TM2to1.st_act.peek s) q) ↔ turing.TM2.supports_stmt S q
K : Type u_1,	_inst_1 : decidable_eq K,	Γ : K → Type u_2,	Λ : Type u_3,	_inst_2 : inhabited Λ,	σ : Type u_4,	_inst_3 : inhabited σ,	S : finset Λ,	k : K,	q : turing.TM2.stmt Γ Λ σ,	s : σ → option (Γ k) → σ	⊢ turing.TM2.supports_stmt S (turing.TM2to1.st_run (turing.TM2to1.st_act.pop s) q) ↔ turing.TM2.supports_stmt S q
K : Type u_1,	_inst_1 : decidable_eq K,	Γ : K → Type u_2,	Λ : Type u_3,	_inst_2 : inhabited Λ,	σ : Type u_4,	_inst_3 : inhabited σ,	S : finset Λ,	k : K,	s : turing.TM2to1.st_act k,	q : turing.TM2.stmt Γ Λ σ	⊢ turing.TM2.supports_stmt S (turing.TM2to1.st_run s q) ↔ turing.TM2.supports_stmt S q
K : Type u_1,	_inst_1 : decidable_eq K,	Γ : K → Type u_2,	Λ : Type u_3,	_inst_2 : inhabited Λ,	σ : Type u_4,	_inst_3 : inhabited σ,	M : Λ → turing.TM2.stmt Γ Λ σ,	k : K,	L : list (Γ k)	⊢ turing.TM2to1.tr_cfg (turing.TM2.init k L) (turing.TM1.init (turing.TM2to1.tr_init k L))
K : Type u_1,	_inst_1 : decidable_eq K,	Γ : K → Type u_2,	Λ : Type u_3,	_inst_2 : inhabited Λ,	σ : Type u_4,	_inst_3 : inhabited σ,	M : Λ → turing.TM2.stmt Γ Λ σ,	k : K,	L : list (Γ k)	⊢ turing.TM2to1.tr_cfg (turing.TM2.init k L) ?m_1
K : Type u_1,	_inst_1 : decidable_eq K,	Γ : K → Type u_2,	Λ : Type u_3,	_inst_2 : inhabited Λ,	σ : Type u_4,	_inst_3 : inhabited σ,	M : Λ → turing.TM2.stmt Γ Λ σ,	k : K,	L : list (Γ k),	k' : K	⊢ turing.list_blank.map (turing.proj k') (turing.list_blank.mk (list.map (λ (a : Γ k), function.update (inhabited.default (Π (a : K), option (Γ a))) k (option.some a)) L.reverse)) = turing.list_blank.mk (list.map option.some (function.update (λ (_x : K), list.nil) k L k')).reverse
K : Type u_1,	_inst_1 : decidable_eq K,	Γ : K → Type u_2,	Λ : Type u_3,	_inst_2 : inhabited Λ,	σ : Type u_4,	_inst_3 : inhabited σ,	M : Λ → turing.TM2.stmt Γ Λ σ,	k : K,	L : list (Γ k),	k' : K,	i : ℕ	⊢ (turing.list_blank.map (turing.proj k') (turing.list_blank.mk (list.map (λ (a : Γ k), function.update (inhabited.default (Π (a : K), option (Γ a))) k (option.some a)) L.reverse))).nth i = (turing.list_blank.mk (list.map option.some (function.update (λ (_x : K), list.nil) k L k')).reverse).nth i
K : Type u_1,	_inst_1 : decidable_eq K,	Γ : K → Type u_2,	Λ : Type u_3,	_inst_2 : inhabited Λ,	σ : Type u_4,	_inst_3 : inhabited σ,	M : Λ → turing.TM2.stmt Γ Λ σ,	k : K,	L : list (Γ k),	k' : K,	i : ℕ	⊢ (option.map (λ (x : Γ k), function.update (inhabited.default (Π (a : K), option (Γ a))) k (option.some x) k') (L.reverse.nth i)).iget = (turing.list_blank.mk (list.map option.some (function.update (λ (_x : K), list.nil) k L k')).reverse).nth i
K : Type u_1,	_inst_1 : decidable_eq K,	Γ : K → Type u_2,	Λ : Type u_3,	_inst_2 : inhabited Λ,	σ : Type u_4,	_inst_3 : inhabited σ,	M : Λ → turing.TM2.stmt Γ Λ σ,	k : K,	L : list (Γ k),	i : ℕ	⊢ (option.map (λ (x : Γ k), function.update (inhabited.default (Π (a : K), option (Γ a))) k (option.some x) k) (L.reverse.nth i)).iget = (turing.list_blank.mk (list.map option.some (function.update (λ (_x : K), list.nil) k L k)).reverse).nth i
K : Type u_1,	_inst_1 : decidable_eq K,	Γ : K → Type u_2,	Λ : Type u_3,	_inst_2 : inhabited Λ,	σ : Type u_4,	_inst_3 : inhabited σ,	M : Λ → turing.TM2.stmt Γ Λ σ,	k : K,	L : list (Γ k),	k' : K,	i : ℕ,	h : k' = k	⊢ (option.map (λ (x : Γ k), function.update (inhabited.default (Π (a : K), option (Γ a))) k (option.some x) k') (L.reverse.nth i)).iget = (turing.list_blank.mk (list.map option.some (function.update (λ (_x : K), list.nil) k L k')).reverse).nth i
K : Type u_1,	_inst_1 : decidable_eq K,	Γ : K → Type u_2,	Λ : Type u_3,	_inst_2 : inhabited Λ,	σ : Type u_4,	_inst_3 : inhabited σ,	M : Λ → turing.TM2.stmt Γ Λ σ,	k : K,	L : list (Γ k),	k' : K,	i : ℕ,	h : k' = k	⊢ (option.map (λ (x : Γ k), function.update (inhabited.default (Π (a : K), option (Γ a))) k (option.some x) k') (L.reverse.nth i)).iget = (turing.list_blank.mk (list.map option.some (function.update (λ (_x : K), list.nil) k L k')).reverse).nth i		K : Type u_1,	_inst_1 : decidable_eq K,	Γ : K → Type u_2,	Λ : Type u_3,	_inst_2 : inhabited Λ,	σ : Type u_4,	_inst_3 : inhabited σ,	M : Λ → turing.TM2.stmt Γ Λ σ,	k : K,	L : list (Γ k),	k' : K,	i : ℕ,	h : ¬k' = k	⊢ (option.map (λ (x : Γ k), function.update (inhabited.default (Π (a : K), option (Γ a))) k (option.some x) k') (L.reverse.nth i)).iget = (turing.list_blank.mk (list.map option.some (function.update (λ (_x : K), list.nil) k L k')).reverse).nth i
K : Type u_1,	_inst_1 : decidable_eq K,	Γ : K → Type u_2,	Λ : Type u_3,	_inst_2 : inhabited Λ,	σ : Type u_4,	_inst_3 : inhabited σ,	M : Λ → turing.TM2.stmt Γ Λ σ,	k : K,	L : list (Γ k),	i : ℕ	⊢ (option.map option.some (L.reverse.nth i)).iget = (turing.list_blank.mk (list.map option.some L).reverse).nth i
K : Type u_1,	_inst_1 : decidable_eq K,	Γ : K → Type u_2,	Λ : Type u_3,	_inst_2 : inhabited Λ,	σ : Type u_4,	_inst_3 : inhabited σ,	M : Λ → turing.TM2.stmt Γ Λ σ,	k : K,	L : list (Γ k),	k' : K,	i : ℕ,	h : ¬k' = k	⊢ (option.map (λ (x : Γ k), function.update (inhabited.default (Π (a : K), option (Γ a))) k (option.some x) k') (L.reverse.nth i)).iget = (turing.list_blank.mk (list.map option.some (function.update (λ (_x : K), list.nil) k L k')).reverse).nth i
K : Type u_1,	_inst_1 : decidable_eq K,	Γ : K → Type u_2,	Λ : Type u_3,	_inst_2 : inhabited Λ,	σ : Type u_4,	_inst_3 : inhabited σ,	M : Λ → turing.TM2.stmt Γ Λ σ,	k : K,	L : list (Γ k),	k' : K,	i : ℕ,	h : ¬k' = k	⊢ (option.map (λ (x : Γ k), inhabited.default (Π (a : K), option (Γ a)) k') (L.reverse.nth i)).iget = (turing.list_blank.mk (list.map option.some list.nil).reverse).nth i
K : Type u_1,	_inst_1 : decidable_eq K,	Γ : K → Type u_2,	Λ : Type u_3,	_inst_2 : inhabited Λ,	σ : Type u_4,	_inst_3 : inhabited σ,	M : Λ → turing.TM2.stmt Γ Λ σ,	k : K,	L : list (Γ k),	k' : K,	i : ℕ,	h : ¬k' = k	⊢ (option.map (λ (x : Γ k), inhabited.default (Π (a : K), option (Γ a)) k') (L.reverse.nth i)).iget = option.none.iget
K : Type u_1,	_inst_1 : decidable_eq K,	Γ : K → Type u_2,	Λ : Type u_3,	_inst_2 : inhabited Λ,	σ : Type u_4,	_inst_3 : inhabited σ,	M : Λ → turing.TM2.stmt Γ Λ σ,	k : K,	L : list (Γ k),	k' : K,	i : ℕ,	h : ¬k' = k	⊢ (option.map (λ (x : Γ k), inhabited.default (Π (a : K), option (Γ a)) k') option.none).iget = option.none.iget
K : Type u_1,	_inst_1 : decidable_eq K,	Γ : K → Type u_2,	Λ : Type u_3,	_inst_2 : inhabited Λ,	σ : Type u_4,	_inst_3 : inhabited σ,	M : Λ → turing.TM2.stmt Γ Λ σ,	k : K,	L : list (Γ k),	k' : K,	i : ℕ,	h : ¬k' = k,	val : Γ k	⊢ (option.map (λ (x : Γ k), inhabited.default (Π (a : K), option (Γ a)) k') (option.some val)).iget = option.none.iget
K : Type u_1,	_inst_1 : decidable_eq K,	Γ : K → Type u_2,	Λ : Type u_3,	_inst_2 : inhabited Λ,	σ : Type u_4,	_inst_3 : inhabited σ,	M : Λ → turing.TM2.stmt Γ Λ σ,	k : K,	L : list (Γ k)	⊢ turing.TM2to1.tr_cfg (turing.TM2.init k L) ?m_1		K : Type u_1,	_inst_1 : decidable_eq K,	Γ : K → Type u_2,	Λ : Type u_3,	_inst_2 : inhabited Λ,	σ : Type u_4,	_inst_3 : inhabited σ,	M : Λ → turing.TM2.stmt Γ Λ σ,	k : K,	L : list (Γ k)	⊢ turing.TM1.init (turing.TM2to1.tr_init k L) = ?m_1
K : Type u_1,	_inst_1 : decidable_eq K,	Γ : K → Type u_2,	Λ : Type u_3,	_inst_2 : inhabited Λ,	σ : Type u_4,	_inst_3 : inhabited σ,	M : Λ → turing.TM2.stmt Γ Λ σ,	k : K,	L : list (Γ k),	k' : K,	i : ℕ,	h : ¬k' = k	⊢ (option.map (λ (x : Γ k), inhabited.default (Π (a : K), option (Γ a)) k') (L.reverse.nth i)).iget = option.none.iget
K : Type u_1,	_inst_1 : decidable_eq K,	Γ : K → Type u_2,	Λ : Type u_3,	_inst_2 : inhabited Λ,	σ : Type u_4,	_inst_3 : inhabited σ,	M : Λ → turing.TM2.stmt Γ Λ σ,	k : K,	L : list (Γ k)	⊢ ⟨option.some (inhabited.default turing.TM2to1.Λ'), inhabited.default σ _inst_3, turing.tape.mk₁ (let L' : list turing.TM2to1.Γ' := list.map (λ (a : Γ k), (bool.ff, function.update (λ (_x : K), option.none) k ↑a)) L.reverse in (bool.tt, L'.head.snd) :: L'.tail)⟩ = ⟨option.map turing.TM2to1.Λ'.normal (option.some (inhabited.default Λ)), inhabited.default σ _inst_3, turing.tape.mk' ∅ (turing.TM2to1.add_bottom (turing.list_blank.mk (list.map (λ (a : Γ k), function.update (inhabited.default (Π (a : K), option (Γ a))) k (option.some a)) L.reverse)))⟩
K : Type u_1,	_inst_1 : decidable_eq K,	Γ : K → Type u_2,	Λ : Type u_3,	_inst_2 : inhabited Λ,	σ : Type u_4,	_inst_3 : inhabited σ,	M : Λ → turing.TM2.stmt Γ Λ σ,	k : K,	L : list (Γ k)	⊢ ⟨option.some (inhabited.default turing.TM2to1.Λ'), inhabited.default σ _inst_3, turing.tape.mk₁ ((bool.tt, (list.map (λ (a : Γ k), (bool.ff, function.update (λ (_x : K), option.none) k ↑a)) L.reverse).head.snd) :: (list.map (λ (a : Γ k), (bool.ff, function.update (λ (_x : K), option.none) k ↑a)) L.reverse).tail)⟩ = ⟨option.map turing.TM2to1.Λ'.normal (option.some (inhabited.default Λ)), inhabited.default σ _inst_3, turing.tape.mk' ∅ (turing.TM2to1.add_bottom (turing.list_blank.mk (list.map (λ (a : Γ k), function.update (inhabited.default (Π (a : K), option (Γ a))) k (option.some a)) L.reverse)))⟩
K : Type u_1,	_inst_1 : decidable_eq K,	Γ : K → Type u_2,	Λ : Type u_3,	_inst_2 : inhabited Λ,	σ : Type u_4,	_inst_3 : inhabited σ,	M : Λ → turing.TM2.stmt Γ Λ σ,	k : K,	L : list (Γ k)	⊢ ⟨option.some (inhabited.default turing.TM2to1.Λ'), inhabited.default σ _inst_3, turing.tape.mk₁ ((bool.tt, (list.map (λ (a : Γ k), (bool.ff, function.update (λ (_x : K), option.none) k ↑a)) L.reverse).head.snd) :: (list.map (λ (a : Γ k), (bool.ff, function.update (λ (_x : K), option.none) k ↑a)) L.reverse).tail)⟩ = ⟨option.map turing.TM2to1.Λ'.normal (option.some (inhabited.default Λ)), inhabited.default σ _inst_3, turing.tape.mk' ∅ (turing.TM2to1.add_bottom (turing.list_blank.mk (list.map (λ (a : Γ k), function.update (inhabited.default (Π (a : K), option (Γ a))) k (option.some a)) L.reverse)))⟩
K : Type u_1,	_inst_1 : decidable_eq K,	Γ : K → Type u_2,	Λ : Type u_3,	_inst_2 : inhabited Λ,	σ : Type u_4,	_inst_3 : inhabited σ,	M : Λ → turing.TM2.stmt Γ Λ σ,	k : K,	L : list (Γ k)	⊢ ⟨option.some (inhabited.default turing.TM2to1.Λ'), inhabited.default σ _inst_3, turing.tape.mk₁ ((bool.tt, (list.map (λ (a : Γ k), (bool.ff, function.update (λ (_x : K), option.none) k ↑a)) L.reverse).head.snd) :: (list.map (λ (a : Γ k), (bool.ff, function.update (λ (_x : K), option.none) k ↑a)) L.reverse).tail)⟩ = ⟨option.map turing.TM2to1.Λ'.normal (option.some (inhabited.default Λ)), inhabited.default σ _inst_3, turing.tape.mk' ∅ (turing.TM2to1.add_bottom (turing.list_blank.mk (list.map (λ (a : Γ k), function.update (inhabited.default (Π (a : K), option (Γ a))) k (option.some a)) L.reverse)))⟩
K : Type u_1,	_inst_1 : decidable_eq K,	Γ : K → Type u_2,	Λ : Type u_3,	_inst_2 : inhabited Λ,	σ : Type u_4,	_inst_3 : inhabited σ,	M : Λ → turing.TM2.stmt Γ Λ σ,	k : K,	L : list (Γ k)	⊢ (list.map (λ (a : Γ k), (bool.ff, function.update (λ (_x : K), option.none) k ↑a)) L.reverse).head.snd = (turing.list_blank.mk (list.map (λ (a : Γ k), function.update (inhabited.default (Π (a : K), option (Γ a))) k (option.some a)) L.reverse)).head
K : Type u_1,	_inst_1 : decidable_eq K,	Γ : K → Type u_2,	Λ : Type u_3,	_inst_2 : inhabited Λ,	σ : Type u_4,	_inst_3 : inhabited σ,	M : Λ → turing.TM2.stmt Γ Λ σ,	k : K,	L : list (Γ k)	⊢ (list.map (λ (a : Γ k), (bool.ff, function.update (λ (_x : K), option.none) k ↑a)) L.reverse).tail = list.map ⇑{f := prod.mk bool.ff, map_pt' := _} (list.map (λ (a : Γ k), function.update (inhabited.default (Π (a : K), option (Γ a))) k (option.some a)) L.reverse).tail
K : Type u_1,	_inst_1 : decidable_eq K,	Γ : K → Type u_2,	Λ : Type u_3,	_inst_2 : inhabited Λ,	σ : Type u_4,	_inst_3 : inhabited σ,	M : Λ → turing.TM2.stmt Γ Λ σ,	k : K,	L : list (Γ k)	⊢ turing.TM1.init (turing.TM2to1.tr_init k L) = ⟨option.map turing.TM2to1.Λ'.normal (option.some (inhabited.default Λ)), inhabited.default σ _inst_3, turing.tape.mk' ∅ (turing.TM2to1.add_bottom (turing.list_blank.mk (list.map (λ (a : Γ k), function.update (inhabited.default (Π (a : K), option (Γ a))) k (option.some a)) L.reverse)))⟩
K : Type u_1,	_inst_1 : decidable_eq K,	Γ : K → Type u_2,	Λ : Type u_3,	_inst_2 : inhabited Λ,	σ : Type u_4,	_inst_3 : inhabited σ,	M : Λ → turing.TM2.stmt Γ Λ σ,	k : K,	L : list (Γ k)	⊢ (list.map (λ (a : Γ k), (bool.ff, function.update (λ (_x : K), option.none) k ↑a)) list.nil).head.snd = (turing.list_blank.mk (list.map (λ (a : Γ k), function.update (inhabited.default (Π (a : K), option (Γ a))) k (option.some a)) list.nil)).head
K : Type u_1,	_inst_1 : decidable_eq K,	Γ : K → Type u_2,	Λ : Type u_3,	_inst_2 : inhabited Λ,	σ : Type u_4,	_inst_3 : inhabited σ,	M : Λ → turing.TM2.stmt Γ Λ σ,	k : K,	L : list (Γ k),	hd : Γ k,	tl : list (Γ k)	⊢ (list.map (λ (a : Γ k), (bool.ff, function.update (λ (_x : K), option.none) k ↑a)) (hd :: tl)).head.snd = (turing.list_blank.mk (list.map (λ (a : Γ k), function.update (inhabited.default (Π (a : K), option (Γ a))) k (option.some a)) (hd :: tl))).head
K : Type u_1,	_inst_1 : decidable_eq K,	Γ : K → Type u_2,	Λ : Type u_3,	_inst_2 : inhabited Λ,	σ : Type u_4,	_inst_3 : inhabited σ,	M : Λ → turing.TM2.stmt Γ Λ σ,	k : K,	L : list (Γ k)	⊢ (list.map (λ (a : Γ k), (bool.ff, function.update (λ (_x : K), option.none) k ↑a)) list.nil).tail = list.map ⇑{f := prod.mk bool.ff, map_pt' := _} (list.map (λ (a : Γ k), function.update (inhabited.default (Π (a : K), option (Γ a))) k (option.some a)) list.nil).tail
K : Type u_1,	_inst_1 : decidable_eq K,	Γ : K → Type u_2,	Λ : Type u_3,	_inst_2 : inhabited Λ,	σ : Type u_4,	_inst_3 : inhabited σ,	M : Λ → turing.TM2.stmt Γ Λ σ,	k : K,	L : list (Γ k),	hd : Γ k,	tl : list (Γ k)	⊢ (list.map (λ (a : Γ k), (bool.ff, function.update (λ (_x : K), option.none) k ↑a)) (hd :: tl)).tail = list.map ⇑{f := prod.mk bool.ff, map_pt' := _} (list.map (λ (a : Γ k), function.update (inhabited.default (Π (a : K), option (Γ a))) k (option.some a)) (hd :: tl)).tail
K : Type u_1,	_inst_1 : decidable_eq K,	Γ : K → Type u_2,	Λ : Type u_3,	_inst_2 : inhabited Λ,	σ : Type u_4,	_inst_3 : inhabited σ,	M : Λ → turing.TM2.stmt Γ Λ σ,	k : K,	L : list (Γ k),	hd : Γ k,	tl : list (Γ k)	⊢ (list.map (λ (a : Γ k), (bool.ff, function.update (λ (_x : K), option.none) k ↑a)) (hd :: tl)).tail = list.map ⇑{f := prod.mk bool.ff, map_pt' := _} (list.map (λ (a : Γ k), function.update (inhabited.default (Π (a : K), option (Γ a))) k (option.some a)) (hd :: tl)).tail
K : Type u_1,	_inst_1 : decidable_eq K,	Γ : K → Type u_2,	Λ : Type u_3,	_inst_2 : inhabited Λ,	σ : Type u_4,	_inst_3 : inhabited σ,	M : Λ → turing.TM2.stmt Γ Λ σ,	k : K,	L : list (Γ k),	hd : Γ k,	tl : list (Γ k)	⊢ list.map (λ (a : Γ k), (bool.ff, function.update (λ (_x : K), option.none) k ↑a)) tl = list.map (⇑{f := prod.mk bool.ff, map_pt' := _} ∘ λ (a : Γ k), function.update (inhabited.default (Π (a : K), option (Γ a))) k (option.some a)) tl
K : Type u_1,	_inst_1 : decidable_eq K,	Γ : K → Type u_2,	Λ : Type u_3,	_inst_2 : inhabited Λ,	σ : Type u_4,	_inst_3 : inhabited σ,	M : Λ → turing.TM2.stmt Γ Λ σ,	k : K,	L : list (Γ k),	hd : Γ k,	tl : list (Γ k)	⊢ (list.map (λ (a : Γ k), (bool.ff, function.update (λ (_x : K), option.none) k ↑a)) (hd :: tl)).tail = list.map ⇑{f := prod.mk bool.ff, map_pt' := _} (list.map (λ (a : Γ k), function.update (inhabited.default (Π (a : K), option (Γ a))) k (option.some a)) (hd :: tl)).tail
Γ : Type u_1,	_inst_1 : inhabited Γ,	l : turing.list_blank Γ	⊢ l.nth 0 = ?m_1
Γ : Type u_1,	_inst_1 : inhabited Γ,	l : turing.list_blank Γ	⊢ l.nth 0 = l.head
Γ : Type u_1,	_inst_1 : inhabited Γ,	l : turing.list_blank Γ	⊢ l.nth 0 = l.head = ?m_1
Γ : Type u_1,	_inst_1 : inhabited Γ,	l : turing.list_blank Γ	⊢ (turing.list_blank.cons l.head l.tail).nth 0 = l.head
Γ : Type u_1,	_inst_1 : inhabited Γ,	l₁ l₂ : list Γ	⊢ turing.list_blank.append l₁ (turing.list_blank.mk l₂) = turing.list_blank.mk (l₁ ++ l₂)
Γ : Type u_1,	_inst_1 : inhabited Γ,	l₂ : list Γ	⊢ turing.list_blank.append list.nil (turing.list_blank.mk l₂) = turing.list_blank.mk (list.nil ++ l₂)
Γ : Type u_1,	_inst_1 : inhabited Γ,	l₂ : list Γ,	l₁_hd : Γ,	l₁_tl : list Γ,	l₁_ih : turing.list_blank.append l₁_tl (turing.list_blank.mk l₂) = turing.list_blank.mk (l₁_tl ++ l₂)	⊢ turing.list_blank.append (l₁_hd :: l₁_tl) (turing.list_blank.mk l₂) = turing.list_blank.mk (l₁_hd :: l₁_tl ++ l₂)
Γ : Type u_1,	_inst_1 : inhabited Γ,	l₁ l₂ : list Γ	⊢ turing.list_blank.append l₁ (turing.list_blank.mk l₂) = turing.list_blank.mk (l₁ ++ l₂)
Γ : Type u_1,	_inst_1 : inhabited Γ,	l₁ l₂ : list Γ,	l₃ : turing.list_blank Γ	⊢ ∀ (a : list Γ), turing.list_blank.append (l₁ ++ l₂) (turing.list_blank.mk a) = turing.list_blank.append l₁ (turing.list_blank.append l₂ (turing.list_blank.mk a))
Γ : Type u_1,	_inst_1 : inhabited Γ,	l₁ l₂ : list Γ,	l₃ : turing.list_blank Γ	⊢ ∀ (a : list Γ), turing.list_blank.append (l₁ ++ l₂) (turing.list_blank.mk a) = turing.list_blank.append l₁ (turing.list_blank.append l₂ (turing.list_blank.mk a))
Γ : Type u_1,	_inst_1 : inhabited Γ,	l₁ l₂ : list Γ,	l₃ : turing.list_blank Γ,	a : list Γ	⊢ turing.list_blank.append (l₁ ++ l₂) (turing.list_blank.mk a) = turing.list_blank.append l₁ (turing.list_blank.append l₂ (turing.list_blank.mk a))
F : Type u → Type w,	G : Type v → Type u,	_inst_1 : applicative F,	_inst_2 : applicative G,	_inst_3 : is_lawful_applicative F,	_inst_4 : is_lawful_applicative G,	α β : Type v,	f : α → β,	x : functor.comp F G α	⊢ functor.comp.run (has_pure.pure f <*> x) = (f <$> x).run
⊢ is_lawful_bifunctor prod
⊢ is_lawful_bifunctor prod
⊢ is_lawful_bifunctor prod
⊢ ∀ {α : Type ?} {β : Type ?} (x : α × β), bifunctor.bimap id id x = x
⊢ ∀ {α₀ α₁ α₂ : Type ?} {β₀ β₁ β₂ : Type ?} (f : α₀ → α₁) (f' : α₁ → α₂) (g : β₀ → β₁) (g' : β₁ → β₂) (x : α₀ × β₀), bifunctor.bimap f' g' (bifunctor.bimap f g x) = bifunctor.bimap (f' ∘ f) (g' ∘ g) x
α : Type ?,	β : Type ?,	x : α × β	⊢ bifunctor.bimap id id x = x
α₀ α₁ α₂ : Type ?,	β₀ β₁ β₂ : Type ?,	f : α₀ → α₁,	f' : α₁ → α₂,	g : β₀ → β₁,	g' : β₁ → β₂,	x : α₀ × β₀	⊢ bifunctor.bimap f' g' (bifunctor.bimap f g x) = bifunctor.bimap (f' ∘ f) (g' ∘ g) x
α : Type ?,	β : Type ?,	x_fst : α,	x_snd : β	⊢ bifunctor.bimap id id (x_fst, x_snd) = (x_fst, x_snd)
α₀ α₁ α₂ : Type ?,	β₀ β₁ β₂ : Type ?,	f : α₀ → α₁,	f' : α₁ → α₂,	g : β₀ → β₁,	g' : β₁ → β₂,	x_fst : α₀,	x_snd : β₀	⊢ bifunctor.bimap f' g' (bifunctor.bimap f g (x_fst, x_snd)) = bifunctor.bimap (f' ∘ f) (g' ∘ g) (x_fst, x_snd)
⊢ is_lawful_bifunctor prod
α : Type u_1,	β : α → Type u_2,	f : (Π (a : α), part (β a)) → Π (a : α), part (β a),	x : α,	h' : ∃ (i : ℕ), (part.fix.approx f i x).dom	⊢ part.fix f x = part.fix.approx f (nat.find h').succ x
α : Type u_1,	β : α → Type u_2,	f : (Π (a : α), part (β a)) → Π (a : α), part (β a),	x : α,	h' : ∃ (i : ℕ), (part.fix.approx f i x).dom,	p : ℕ → Prop := λ (i : ℕ), (part.fix.approx f i x).dom	⊢ part.fix f x = part.fix.approx f (nat.find h').succ x
α : Type u_1,	β : α → Type u_2,	f : (Π (a : α), part (β a)) → Π (a : α), part (β a),	x : α,	h' : ∃ (i : ℕ), (part.fix.approx f i x).dom,	p : ℕ → Prop := λ (i : ℕ), (part.fix.approx f i x).dom,	this : p (nat.find h')	⊢ part.fix f x = part.fix.approx f (nat.find h').succ x
α : Type u_1,	β : α → Type u_2,	f : (Π (a : α), part (β a)) → Π (a : α), part (β a),	x : α,	h' : ∃ (i : ℕ), (part.fix.approx f i x).dom,	p : ℕ → Prop := λ (i : ℕ), (part.fix.approx f i x).dom,	this : p (nat.find h'),	k : ℕ,	hk : nat.find h' = k	⊢ part.fix f x = part.fix.approx f k.succ x
α : Type u_1,	β : α → Type u_2,	f : (Π (a : α), part (β a)) → Π (a : α), part (β a),	x : α,	h' : ∃ (i : ℕ), (part.fix.approx f i x).dom,	p : ℕ → Prop := λ (i : ℕ), (part.fix.approx f i x).dom,	this : p (nat.find h'),	k : ℕ,	hk : nat.find h' = k + nat.upto.zero.val	⊢ part.fix f x = part.fix.approx f k.succ x
α : Type u_1,	β : α → Type u_2,	f : (Π (a : α), part (β a)) → Π (a : α), part (β a),	x : α,	h' : ∃ (i : ℕ), (part.fix.approx f i x).dom,	p : ℕ → Prop := λ (i : ℕ), (part.fix.approx f i x).dom,	k : ℕ,	hk : nat.find h' = k + nat.upto.zero.val,	this : p (k + nat.upto.zero.val)	⊢ part.fix f x = part.fix.approx f k.succ x
α : Type u_1,	β : α → Type u_2,	f : (Π (a : α), part (β a)) → Π (a : α), part (β a),	x : α,	h' : ∃ (i : ℕ), (part.fix.approx f i x).dom,	p : ℕ → Prop := λ (i : ℕ), (part.fix.approx f i x).dom,	k : ℕ,	this : p (k + nat.upto.zero.val)	⊢ nat.find h' = k + ↑nat.upto.zero → part.assert (∃ (i : ℕ), (part.fix.approx f i x).dom) (λ (h : ∃ (i : ℕ), (part.fix.approx f i x).dom), _.fix (part.fix_aux f) nat.upto.zero x) = part.fix.approx f k.succ x
α : Type u_1,	β : α → Type u_2,	f : (Π (a : α), part (β a)) → Π (a : α), part (β a),	x : α,	h' : ∃ (i : ℕ), (part.fix.approx f i x).dom,	p : ℕ → Prop := λ (i : ℕ), (part.fix.approx f i x).dom,	k : ℕ,	this : p (k + nat.upto.zero.val)	⊢ nat.find h' = k + ↑nat.upto.zero → _.fix (part.fix_aux f) nat.upto.zero x = part.fix.approx f k.succ x
α : Type u_1,	β : α → Type u_2,	f : (Π (a : α), part (β a)) → Π (a : α), part (β a),	x : α,	h' : ∃ (i : ℕ), (part.fix.approx f i x).dom,	p : ℕ → Prop := λ (i : ℕ), (part.fix.approx f i x).dom,	k : ℕ,	this : p (k + nat.upto.zero.val)	⊢ nat.find h' = k + nat.upto.zero.val → part.fix f x = part.fix.approx f k.succ x
α : Type u_1,	β : α → Type u_2,	f : (Π (a : α), part (β a)) → Π (a : α), part (β a),	x : α,	h' : ∃ (i : ℕ), (part.fix.approx f i x).dom,	p : ℕ → Prop := λ (i : ℕ), (part.fix.approx f i x).dom,	k : ℕ,	z : nat.upto p	⊢ p (k + z.val) → nat.find h' = k + ↑z → _.fix (part.fix_aux f) z x = part.fix.approx f k.succ x
α : Type u_1,	β : α → Type u_2,	f : (Π (a : α), part (β a)) → Π (a : α), part (β a),	x : α,	h' : ∃ (i : ℕ), (part.fix.approx f i x).dom,	p : ℕ → Prop := λ (i : ℕ), (part.fix.approx f i x).dom,	k : ℕ	⊢ p (k + nat.upto.zero.val) → nat.find h' = k + ↑nat.upto.zero → _.fix (part.fix_aux f) nat.upto.zero x = part.fix.approx f k.succ x
α : Type u_1,	β : α → Type u_2,	f : (Π (a : α), part (β a)) → Π (a : α), part (β a),	x : α,	h' : ∃ (i : ℕ), (part.fix.approx f i x).dom,	p : ℕ → Prop := λ (i : ℕ), (part.fix.approx f i x).dom,	k : ℕ,	z : nat.upto p,	this : p (k + z.val),	hk : nat.find h' = k + ↑z	⊢ _.fix (part.fix_aux f) z x = part.fix.approx f k.succ x
α : Type u_1,	β : α → Type u_2,	f : (Π (a : α), part (β a)) → Π (a : α), part (β a),	x : α,	h' : ∃ (i : ℕ), (part.fix.approx f i x).dom,	p : ℕ → Prop := λ (i : ℕ), (part.fix.approx f i x).dom,	k : ℕ,	z : nat.upto p,	this : p (k + z.val),	hk : nat.find h' = k + ↑z,	this : ∀ (x' : α), _.fix (part.fix_aux f) z x' = part.fix.approx f k.succ x'	⊢ _.fix (part.fix_aux f) z x = part.fix.approx f k.succ x		α : Type u_1,	β : α → Type u_2,	f : (Π (a : α), part (β a)) → Π (a : α), part (β a),	x : α,	h' : ∃ (i : ℕ), (part.fix.approx f i x).dom,	p : ℕ → Prop := λ (i : ℕ), (part.fix.approx f i x).dom,	k : ℕ,	z : nat.upto p,	this : p (k + z.val),	hk : nat.find h' = k + ↑z	⊢ ∀ (x' : α), _.fix (part.fix_aux f) z x' = part.fix.approx f k.succ x'
α : Type u_1,	β : α → Type u_2,	f : (Π (a : α), part (β a)) → Π (a : α), part (β a),	x : α,	h' : ∃ (i : ℕ), (part.fix.approx f i x).dom,	p : ℕ → Prop := λ (i : ℕ), (part.fix.approx f i x).dom,	k : ℕ,	z : nat.upto p,	this : p (k + z.val),	hk : nat.find h' = k + ↑z	⊢ ∀ (x' : α), _.fix (part.fix_aux f) z x' = part.fix.approx f k.succ x'
α : Type u_1,	β : α → Type u_2,	f : (Π (a : α), part (β a)) → Π (a : α), part (β a),	x : α,	h' : ∃ (i : ℕ), (part.fix.approx f i x).dom,	p : ℕ → Prop := λ (i : ℕ), (part.fix.approx f i x).dom,	z : nat.upto p,	this : p (0 + z.val),	hk : nat.find h' = 0 + ↑z	⊢ ∀ (x' : α), _.fix (part.fix_aux f) z x' = part.fix.approx f 1 x'
α : Type u_1,	β : α → Type u_2,	f : (Π (a : α), part (β a)) → Π (a : α), part (β a),	x : α,	h' : ∃ (i : ℕ), (part.fix.approx f i x).dom,	p : ℕ → Prop := λ (i : ℕ), (part.fix.approx f i x).dom,	k_n : ℕ,	k_ih : ∀ (z : nat.upto p), p (k_n + z.val) → nat.find h' = k_n + ↑z → ∀ (x' : α), _.fix (part.fix_aux f) z x' = part.fix.approx f k_n.succ x',	z : nat.upto p,	this : p (k_n.succ + z.val),	hk : nat.find h' = k_n.succ + ↑z	⊢ ∀ (x' : α), _.fix (part.fix_aux f) z x' = part.fix.approx f k_n.succ.succ x'
α : Type u_1,	β : α → Type u_2,	f : (Π (a : α), part (β a)) → Π (a : α), part (β a),	x : α,	h' : ∃ (i : ℕ), (part.fix.approx f i x).dom,	p : ℕ → Prop := λ (i : ℕ), (part.fix.approx f i x).dom,	k : ℕ,	z : nat.upto p,	this : p (k + z.val),	hk : nat.find h' = k + ↑z	⊢ ∀ (x' : α), _.fix (part.fix_aux f) z x' = part.fix.approx f k.succ x'
α : Type u_1,	β : α → Type u_2,	f : (Π (a : α), part (β a)) → Π (a : α), part (β a),	x : α,	h' : ∃ (i : ℕ), (part.fix.approx f i x).dom,	p : ℕ → Prop := λ (i : ℕ), (part.fix.approx f i x).dom,	z : nat.upto p,	this : p (0 + z.val),	hk : nat.find h' = 0 + ↑z,	x' : α	⊢ _.fix (part.fix_aux f) z x' = part.fix.approx f 1 x'
α : Type u_1,	β : α → Type u_2,	f : (Π (a : α), part (β a)) → Π (a : α), part (β a),	x : α,	h' : ∃ (i : ℕ), (part.fix.approx f i x).dom,	p : ℕ → Prop := λ (i : ℕ), (part.fix.approx f i x).dom,	z : nat.upto p,	this : p (0 + z.val),	hk : nat.find h' = 0 + ↑z,	x' : α	⊢ (λ (x_1 : α), part.assert (¬(part.fix.approx f z.val x).dom) (λ (h : ¬(part.fix.approx f z.val x).dom), _.fix (part.fix_aux f) (z.succ h) x_1)) = part.fix.approx f 0
α : Type u_1,	β : α → Type u_2,	f : (Π (a : α), part (β a)) → Π (a : α), part (β a),	x : α,	h' : ∃ (i : ℕ), (part.fix.approx f i x).dom,	p : ℕ → Prop := λ (i : ℕ), (part.fix.approx f i x).dom,	z : nat.upto p,	this : p (0 + z.val),	hk : nat.find h' = 0 + ↑z,	x' x_1 : α	⊢ part.assert (¬(part.fix.approx f z.val x).dom) (λ (h : ¬(part.fix.approx f z.val x).dom), _.fix (part.fix_aux f) (z.succ h) x_1) = part.fix.approx f 0 x_1
α : Type u_1,	β : α → Type u_2,	f : (Π (a : α), part (β a)) → Π (a : α), part (β a),	x : α,	h' : ∃ (i : ℕ), (part.fix.approx f i x).dom,	p : ℕ → Prop := λ (i : ℕ), (part.fix.approx f i x).dom,	z : nat.upto p,	this : p (0 + z.val),	hk : nat.find h' = 0 + ↑z,	x' x_1 : α	⊢ part.none = part.fix.approx f 0 x_1		α : Type u_1,	β : α → Type u_2,	f : (Π (a : α), part (β a)) → Π (a : α), part (β a),	x : α,	h' : ∃ (i : ℕ), (part.fix.approx f i x).dom,	p : ℕ → Prop := λ (i : ℕ), (part.fix.approx f i x).dom,	z : nat.upto p,	this : p (0 + z.val),	hk : nat.find h' = 0 + ↑z,	x' x_1 : α	⊢ ¬¬(part.fix.approx f z.val x).dom
α : Type u_1,	β : α → Type u_2,	f : (Π (a : α), part (β a)) → Π (a : α), part (β a),	x : α,	h' : ∃ (i : ℕ), (part.fix.approx f i x).dom,	p : ℕ → Prop := λ (i : ℕ), (part.fix.approx f i x).dom,	z : nat.upto p,	this : p (0 + z.val),	hk : nat.find h' = 0 + ↑z,	x' : α	⊢ f (λ (x_1 : α), part.assert (¬(part.fix.approx f z.val x).dom) (λ (h : ¬(part.fix.approx f z.val x).dom), _.fix (part.fix_aux f) (z.succ h) x_1)) x' = f (part.fix.approx f 0) x'
α : Type u_1,	β : α → Type u_2,	f : (Π (a : α), part (β a)) → Π (a : α), part (β a),	x : α,	h' : ∃ (i : ℕ), (part.fix.approx f i x).dom,	p : ℕ → Prop := λ (i : ℕ), (part.fix.approx f i x).dom,	z : nat.upto p,	this : p (0 + z.val),	hk : nat.find h' = 0 + ↑z,	x' x_1 : α	⊢ ¬¬(part.fix.approx f z.val x).dom
α : Type u_1,	β : α → Type u_2,	f : (Π (a : α), part (β a)) → Π (a : α), part (β a),	x : α,	h' : ∃ (i : ℕ), (part.fix.approx f i x).dom,	p : ℕ → Prop := λ (i : ℕ), (part.fix.approx f i x).dom,	z : nat.upto p,	this : p (0 + z.val),	hk : nat.find h' = 0 + ↑z,	x' : α	⊢ _.fix (part.fix_aux f) z x' = part.fix.approx f 1 x'		case nat.succ	α : Type u_1,	β : α → Type u_2,	f : (Π (a : α), part (β a)) → Π (a : α), part (β a),	x : α,	h' : ∃ (i : ℕ), (part.fix.approx f i x).dom,	p : ℕ → Prop := λ (i : ℕ), (part.fix.approx f i x).dom,	k_n : ℕ,	k_ih : ∀ (z : nat.upto p), p (k_n + z.val) → nat.find h' = k_n + ↑z → ∀ (x' : α), _.fix (part.fix_aux f) z x' = part.fix.approx f k_n.succ x',	z : nat.upto p,	this : p (k_n.succ + z.val),	hk : nat.find h' = k_n.succ + ↑z,	x' : α	⊢ _.fix (part.fix_aux f) z x' = part.fix.approx f k_n.succ.succ x'
α : Type u_1,	β : α → Type u_2,	f : (Π (a : α), part (β a)) → Π (a : α), part (β a),	x : α,	h' : ∃ (i : ℕ), (part.fix.approx f i x).dom,	p : ℕ → Prop := λ (i : ℕ), (part.fix.approx f i x).dom,	z : nat.upto p,	hk : nat.find h' = 0 + ↑z,	x' x_1 : α,	this : p z.val	⊢ ¬¬(part.fix.approx f z.val x).dom
α : Type u_1,	β : α → Type u_2,	f : (Π (a : α), part (β a)) → Π (a : α), part (β a),	x : α,	h' : ∃ (i : ℕ), (part.fix.approx f i x).dom,	p : ℕ → Prop := λ (i : ℕ), (part.fix.approx f i x).dom,	k_n : ℕ,	k_ih : ∀ (z : nat.upto p), p (k_n + z.val) → nat.find h' = k_n + ↑z → ∀ (x' : α), _.fix (part.fix_aux f) z x' = part.fix.approx f k_n.succ x',	z : nat.upto p,	this : p (k_n.succ + z.val),	hk : nat.find h' = k_n.succ + ↑z,	x' : α	⊢ _.fix (part.fix_aux f) z x' = part.fix.approx f k_n.succ.succ x'
α : Type u_1,	β : α → Type u_2,	f : (Π (a : α), part (β a)) → Π (a : α), part (β a),	x : α,	h' : ∃ (i : ℕ), (part.fix.approx f i x).dom,	p : ℕ → Prop := λ (i : ℕ), (part.fix.approx f i x).dom,	k_n : ℕ,	k_ih : ∀ (z : nat.upto p), p (k_n + z.val) → nat.find h' = k_n + ↑z → ∀ (x' : α), _.fix (part.fix_aux f) z x' = part.fix.approx f k_n.succ x',	z : nat.upto p,	this : p (k_n.succ + z.val),	hk : nat.find h' = k_n.succ + ↑z,	x' : α	⊢ (λ (x_1 : α), part.assert (¬(part.fix.approx f z.val x).dom) (λ (h : ¬(part.fix.approx f z.val x).dom), _.fix (part.fix_aux f) (z.succ h) x_1)) = part.fix.approx f k_n.succ
α : Type u_1,	β : α → Type u_2,	f : (Π (a : α), part (β a)) → Π (a : α), part (β a),	x : α,	h' : ∃ (i : ℕ), (part.fix.approx f i x).dom,	p : ℕ → Prop := λ (i : ℕ), (part.fix.approx f i x).dom,	k_n : ℕ,	k_ih : ∀ (z : nat.upto p), p (k_n + z.val) → nat.find h' = k_n + ↑z → ∀ (x' : α), _.fix (part.fix_aux f) z x' = part.fix.approx f k_n.succ x',	z : nat.upto p,	this : p (k_n.succ + z.val),	hk : nat.find h' = k_n.succ + ↑z,	x' : α	⊢ f (λ (x_1 : α), part.assert (¬(part.fix.approx f z.val x).dom) (λ (h : ¬(part.fix.approx f z.val x).dom), _.fix (part.fix_aux f) (z.succ h) x_1)) x' = f (part.fix.approx f k_n.succ) x'
α : Type u_1,	β : α → Type u_2,	f : (Π (a : α), part (β a)) → Π (a : α), part (β a),	x : α,	h' : ∃ (i : ℕ), (part.fix.approx f i x).dom,	p : ℕ → Prop := λ (i : ℕ), (part.fix.approx f i x).dom,	k_n : ℕ,	k_ih : ∀ (z : nat.upto p), p (k_n + z.val) → nat.find h' = k_n + ↑z → ∀ (x' : α), _.fix (part.fix_aux f) z x' = part.fix.approx f k_n.succ x',	z : nat.upto p,	this : p (k_n.succ + z.val),	hk : nat.find h' = k_n.succ + ↑z,	x' x_1 : α	⊢ part.assert (¬(part.fix.approx f z.val x).dom) (λ (h : ¬(part.fix.approx f z.val x).dom), _.fix (part.fix_aux f) (z.succ h) x_1) = part.fix.approx f k_n.succ x_1
α : Type u_1,	β : α → Type u_2,	f : (Π (a : α), part (β a)) → Π (a : α), part (β a),	x : α,	h' : ∃ (i : ℕ), (part.fix.approx f i x).dom,	p : ℕ → Prop := λ (i : ℕ), (part.fix.approx f i x).dom,	k_n : ℕ,	k_ih : ∀ (z : nat.upto p), p (k_n + z.val) → nat.find h' = k_n + ↑z → ∀ (x' : α), _.fix (part.fix_aux f) z x' = part.fix.approx f k_n.succ x',	z : nat.upto p,	this : p (k_n.succ + z.val),	hk : nat.find h' = k_n.succ + ↑z,	x' x_1 : α	⊢ ¬(part.fix.approx f z.val x).dom
α : Type u_1,	β : α → Type u_2,	f : (Π (a : α), part (β a)) → Π (a : α), part (β a),	x : α,	h' : ∃ (i : ℕ), (part.fix.approx f i x).dom,	p : ℕ → Prop := λ (i : ℕ), (part.fix.approx f i x).dom,	k_n : ℕ,	k_ih : ∀ (z : nat.upto p), p (k_n + z.val) → nat.find h' = k_n + ↑z → ∀ (x' : α), _.fix (part.fix_aux f) z x' = part.fix.approx f k_n.succ x',	z : nat.upto p,	this : p (k_n.succ + z.val),	hk : nat.find h' = k_n.succ + ↑z,	x' x_1 : α	⊢ z.val < nat.find h'
α : Type u_1,	β : α → Type u_2,	f : (Π (a : α), part (β a)) → Π (a : α), part (β a),	x : α,	h' : ∃ (i : ℕ), (part.fix.approx f i x).dom,	p : ℕ → Prop := λ (i : ℕ), (part.fix.approx f i x).dom,	k_n : ℕ,	k_ih : ∀ (z : nat.upto p), p (k_n + z.val) → nat.find h' = k_n + ↑z → ∀ (x' : α), _.fix (part.fix_aux f) z x' = part.fix.approx f k_n.succ x',	z : nat.upto p,	this : p (k_n.succ + z.val),	hk : nat.find h' = k_n.succ + ↑z,	x' x_1 : α	⊢ z.val < k_n + ↑z.succ
α : Type u_1,	β : α → Type u_2,	f : (Π (a : α), part (β a)) → Π (a : α), part (β a),	x : α,	h' : ∃ (i : ℕ), (part.fix.approx f i x).dom,	p : ℕ → Prop := λ (i : ℕ), (part.fix.approx f i x).dom,	k_n : ℕ,	k_ih : ∀ (z : nat.upto p), p (k_n + z.val) → nat.find h' = k_n + ↑z → ∀ (x' : α), _.fix (part.fix_aux f) z x' = part.fix.approx f k_n.succ x',	z : nat.upto p,	this : p (k_n.succ + z.val),	hk : nat.find h' = k_n.succ + ↑z,	x' x_1 : α	⊢ ¬(part.fix.approx f z.val x).dom		α : Type u_1,	β : α → Type u_2,	f : (Π (a : α), part (β a)) → Π (a : α), part (β a),	x : α,	h' : ∃ (i : ℕ), (part.fix.approx f i x).dom,	p : ℕ → Prop := λ (i : ℕ), (part.fix.approx f i x).dom,	k_n : ℕ,	k_ih : ∀ (z : nat.upto p), p (k_n + z.val) → nat.find h' = k_n + ↑z → ∀ (x' : α), _.fix (part.fix_aux f) z x' = part.fix.approx f k_n.succ x',	z : nat.upto p,	this : p (k_n.succ + z.val),	hk : nat.find h' = k_n.succ + ↑z,	x' x_1 : α,	hh : ¬(part.fix.approx f z.val x).dom	⊢ part.assert (¬(part.fix.approx f z.val x).dom) (λ (h : ¬(part.fix.approx f z.val x).dom), _.fix (part.fix_aux f) (z.succ h) x_1) = part.fix.approx f k_n.succ x_1
α : Type u_1,	β : α → Type u_2,	f : (Π (a : α), part (β a)) → Π (a : α), part (β a),	x : α,	h' : ∃ (i : ℕ), (part.fix.approx f i x).dom,	p : ℕ → Prop := λ (i : ℕ), (part.fix.approx f i x).dom,	k_n : ℕ,	k_ih : ∀ (z : nat.upto p), p (k_n + z.val) → nat.find h' = k_n + ↑z → ∀ (x' : α), _.fix (part.fix_aux f) z x' = part.fix.approx f k_n.succ x',	z : nat.upto p,	this : p (k_n.succ + z.val),	hk : nat.find h' = k_n.succ + ↑z,	x' x_1 : α	⊢ z.val.succ ≤ k_n + ↑z.succ
α : Type u_1,	β : α → Type u_2,	f : (Π (a : α), part (β a)) → Π (a : α), part (β a),	x : α,	h' : ∃ (i : ℕ), (part.fix.approx f i x).dom,	p : ℕ → Prop := λ (i : ℕ), (part.fix.approx f i x).dom,	k_n : ℕ,	k_ih : ∀ (z : nat.upto p), p (k_n + z.val) → nat.find h' = k_n + ↑z → ∀ (x' : α), _.fix (part.fix_aux f) z x' = part.fix.approx f k_n.succ x',	z : nat.upto p,	this : p (k_n.succ + z.val),	hk : nat.find h' = k_n.succ + ↑z,	x' x_1 : α,	hh : ¬(part.fix.approx f z.val x).dom	⊢ part.assert (¬(part.fix.approx f z.val x).dom) (λ (h : ¬(part.fix.approx f z.val x).dom), _.fix (part.fix_aux f) (z.succ h) x_1) = part.fix.approx f k_n.succ x_1
α : Type u_1,	β : α → Type u_2,	f : (Π (a : α), part (β a)) → Π (a : α), part (β a),	x : α,	h' : ∃ (i : ℕ), (part.fix.approx f i x).dom,	p : ℕ → Prop := λ (i : ℕ), (part.fix.approx f i x).dom,	k_n : ℕ,	k_ih : ∀ (z : nat.upto p), p (k_n + z.val) → nat.find h' = k_n + ↑z → ∀ (x' : α), _.fix (part.fix_aux f) z x' = part.fix.approx f k_n.succ x',	z : nat.upto p,	x' x_1 : α,	hh : ¬(part.fix.approx f z.val x).dom,	hk : nat.find h' = k_n + ↑z.succ,	this : p (k_n + z.val.succ)	⊢ part.assert (¬(part.fix.approx f z.val x).dom) (λ (h : ¬(part.fix.approx f z.val x).dom), _.fix (part.fix_aux f) (z.succ h) x_1) = part.fix.approx f k_n.succ x_1
α β : Type u,	m : Type u → Type u,	_inst_1 : monad m,	_inst_2 : is_lawful_monad m,	f : α → β → m β	⊢ ∀ (x y : free_monoid α), monoid.mfoldr.of_free_monoid f (x * y) = monoid.mfoldr.of_free_monoid f x * monoid.mfoldr.of_free_monoid f y
α β : Type u,	m : Type u → Type u,	_inst_1 : monad m,	_inst_2 : is_lawful_monad m,	f : α → β → m β	⊢ ∀ (x y : free_monoid α), monoid.mfoldr.of_free_monoid f (x * y) = monoid.mfoldr.of_free_monoid f x * monoid.mfoldr.of_free_monoid f y
α β : Type u,	m : Type u → Type u,	_inst_1 : monad m,	_inst_2 : is_lawful_monad m,	f : α → β → m β	⊢ ∀ (x y : free_monoid α), monoid.mfoldr.of_free_monoid f (x * y) = monoid.mfoldr.of_free_monoid f x * monoid.mfoldr.of_free_monoid f y
α β : Type u,	m : Type u → Type u,	_inst_1 : monad m,	_inst_2 : is_lawful_monad m,	f : α → β → m β,	x y : free_monoid α	⊢ monoid.mfoldr.of_free_monoid f (x * y) = monoid.mfoldr.of_free_monoid f x * monoid.mfoldr.of_free_monoid f y
α β : Type u,	m : Type u → Type u,	_inst_1 : monad m,	_inst_2 : is_lawful_monad m,	f : α → β → m β,	x y : free_monoid α,	x_1 : category_theory.Kleisli.mk (λ {β : Type u}, m β) β	⊢ monoid.mfoldr.of_free_monoid f (x * y) x_1 = (monoid.mfoldr.of_free_monoid f x * monoid.mfoldr.of_free_monoid f y) x_1
α : Type u,	t : Type u → Type u,	_inst_1 : traversable t,	_inst_2 : is_lawful_traversable t,	xs : t α	⊢ traversable.fold_map traversable.free.mk xs = (list.reverse (traversable.fold_map traversable.free.mk xs)).reverse
α : Type u,	t : Type u → Type u,	_inst_1 : traversable t,	_inst_2 : is_lawful_traversable t,	xs : t α	⊢ (list.reverse (traversable.fold_map traversable.free.mk xs)).reverse = (list.foldr list.cons list.nil (list.reverse (traversable.fold_map traversable.free.mk xs))).reverse
α : Type u,	t : Type u → Type u,	_inst_1 : traversable t,	_inst_2 : is_lawful_traversable t,	xs : t α	⊢ (list.foldr list.cons list.nil (list.reverse (traversable.fold_map traversable.free.mk xs))).reverse = (opposite.unop (monoid.foldl.of_free_monoid (flip list.cons) (traversable.fold_map traversable.free.mk xs)) list.nil).reverse
α : Type u,	t : Type u → Type u,	_inst_1 : traversable t,	_inst_2 : is_lawful_traversable t,	xs : t α	⊢ (opposite.unop (monoid.foldl.of_free_monoid (flip list.cons) (traversable.fold_map traversable.free.mk xs)) list.nil).reverse = traversable.to_list xs
α : Type u,	t : Type u → Type u,	_inst_1 : traversable t,	_inst_2 : is_lawful_traversable t,	xs : t α	⊢ is_monoid_hom (monoid.foldl.of_free_monoid (flip list.cons))
α : Type u,	t : Type u → Type u,	_inst_1 : traversable t,	_inst_2 : is_lawful_traversable t,	xs : t α	⊢ is_monoid_hom (monoid.foldl.of_free_monoid (flip list.cons))		α : Type u,	t : Type u → Type u,	_inst_1 : traversable t,	_inst_2 : is_lawful_traversable t,	xs : t α,	this : is_monoid_hom (monoid.foldl.of_free_monoid (flip list.cons))	⊢ (opposite.unop (monoid.foldl.of_free_monoid (flip list.cons) (traversable.fold_map traversable.free.mk xs)) list.nil).reverse = traversable.to_list xs
α : Type u,	t : Type u → Type u,	_inst_1 : traversable t,	_inst_2 : is_lawful_traversable t,	xs : t α,	this : is_monoid_hom (monoid.foldl.of_free_monoid (flip list.cons))	⊢ (opposite.unop (monoid.foldl.of_free_monoid (flip list.cons) (traversable.fold_map traversable.free.mk xs)) list.nil).reverse = traversable.to_list xs
α : Type u,	t : Type u → Type u,	_inst_1 : traversable t,	_inst_2 : is_lawful_traversable t,	xs : t α,	this : is_monoid_hom (monoid.foldl.of_free_monoid (flip list.cons))	⊢ (opposite.unop (traversable.fold_map (monoid.foldl.of_free_monoid (flip list.cons) ∘ traversable.free.mk) xs) list.nil).reverse = traversable.to_list xs		α : Type u,	t : Type u → Type u,	_inst_1 : traversable t,	_inst_2 : is_lawful_traversable t,	xs : t α,	this : is_monoid_hom (monoid.foldl.of_free_monoid (flip list.cons))	⊢ is_lawful_traversable (λ (α : Type u), t α)
α : Type u,	t : Type u → Type u,	_inst_1 : traversable t,	_inst_2 : is_lawful_traversable t,	xs : t α,	this : is_monoid_hom (monoid.foldl.of_free_monoid (flip list.cons))	⊢ is_lawful_traversable (λ (α : Type u), t α)
α : Type u,	t : Type u → Type u,	_inst_1 : traversable t,	_inst_2 : is_lawful_traversable t,	xs : t α,	this : is_monoid_hom (monoid.foldl.of_free_monoid (flip list.cons))	⊢ is_lawful_traversable (λ (α : Type u), t α)
F : Type u → Type v,	_inst_1 : applicative F,	_inst_2 : is_lawful_applicative F,	G : Type u → Type w,	_inst_3 : applicative G,	_inst_4 : is_lawful_applicative G,	η η' : applicative_transformation F G,	h : ∀ (α : Type u) (x : F α), ⇑η x = ⇑η' x	⊢ ⇑η = ⇑η'
F : Type u → Type v,	_inst_1 : applicative F,	_inst_2 : is_lawful_applicative F,	G : Type u → Type w,	_inst_3 : applicative G,	_inst_4 : is_lawful_applicative G,	η η' : applicative_transformation F G,	h : ∀ (α : Type u) (x : F α), ⇑η x = ⇑η' x,	α : Type u	⊢ ⇑η = ⇑η'
F : Type u → Type v,	_inst_1 : applicative F,	_inst_2 : is_lawful_applicative F,	G : Type u → Type w,	_inst_3 : applicative G,	_inst_4 : is_lawful_applicative G,	η η' : applicative_transformation F G,	h : ∀ (α : Type u) (x : F α), ⇑η x = ⇑η' x	⊢ η = η'
F : Type u → Type u,	_inst_1 : applicative F,	α' β' : Type u,	f : α' → F β',	_inst_3 : is_lawful_applicative F,	traverse_append : ∀ (as bs : list α'), traversable.traverse f (as ++ bs) = has_append.append <$> traversable.traverse f as <*> traversable.traverse f bs,	bs : list α'	⊢ has_append.append list.nil = id
F : Type u → Type u,	_inst_1 : applicative F,	α' β' : Type u,	f : α' → F β',	_inst_3 : is_lawful_applicative F,	traverse_append : ∀ (as bs : list α'), traversable.traverse f (as ++ bs) = has_append.append <$> traversable.traverse f as <*> traversable.traverse f bs,	bs : list α'	⊢ has_append.append list.nil = id
F : Type u → Type u,	_inst_1 : applicative F,	α' β' : Type u,	f : α' → F β',	_inst_3 : is_lawful_applicative F,	traverse_append : ∀ (as bs : list α'), traversable.traverse f (as ++ bs) = has_append.append <$> traversable.traverse f as <*> traversable.traverse f bs,	bs : list α',	x : list β'	⊢ list.nil ++ x = id x
F : Type u → Type u,	_inst_1 : applicative F,	α' β' : Type u,	f : α' → F β',	_inst_3 : is_lawful_applicative F,	traverse_append : ∀ (as bs : list α'), traversable.traverse f (as ++ bs) = has_append.append <$> traversable.traverse f as <*> traversable.traverse f bs,	bs : list α',	this : has_append.append list.nil = id	⊢ traversable.traverse f (list.nil ++ bs) = has_append.append <$> traversable.traverse f list.nil <*> traversable.traverse f bs
F : Type u → Type u,	_inst_1 : applicative F,	α' β' : Type u,	f : α' → F β',	_inst_3 : is_lawful_applicative F,	traverse_append : ∀ (as bs : list α'), traversable.traverse f (as ++ bs) = has_append.append <$> traversable.traverse f as <*> traversable.traverse f bs,	a : α',	as bs : list α'	⊢ traversable.traverse f (a :: as ++ bs) = has_append.append <$> traversable.traverse f (a :: as) <*> traversable.traverse f bs
F : Type u → Type u,	_inst_1 : applicative F,	α' β' : Type u,	f : α' → F β',	_inst_3 : is_lawful_applicative F,	traverse_append : ∀ (as bs : list α'), traversable.traverse f (as ++ bs) = has_append.append <$> traversable.traverse f as <*> traversable.traverse f bs,	a : α',	as bs : list α'	⊢ traversable.traverse f (a :: as ++ bs) = has_append.append <$> traversable.traverse f (a :: as) <*> traversable.traverse f bs
F : Type u → Type u,	_inst_1 : applicative F,	α' β' : Type u,	f : α' → F β',	_inst_3 : is_lawful_applicative F,	traverse_append : ∀ (as bs : list α'), traversable.traverse f (as ++ bs) = has_append.append <$> traversable.traverse f as <*> traversable.traverse f bs,	a : α',	as bs : list α'	⊢ ((λ (m : (list β' → list β') → list β' → list β'), m ∘ has_append.append) ∘ function.comp ∘ list.cons) <$> f a <*> traversable.traverse f as <*> traversable.traverse f bs = (function.comp has_append.append ∘ list.cons) <$> f a <*> traversable.traverse f as <*> traversable.traverse f bs
n : ℕ,	α : Type u,	a : array n α,	i : fin n,	v : α	⊢ (a.write i v).to_list.length = (a.to_list.update_nth ↑i v).length
n : ℕ,	α : Type u,	a : array n α,	i : fin n,	v : α,	j : ℕ,	h₁ : j < (a.write i v).to_list.length,	h₂ : j < (a.to_list.update_nth ↑i v).length	⊢ j < n
n : ℕ,	α : Type u,	a : array n α,	i : fin n,	v : α,	j : ℕ,	h₁ : j < (a.write i v).to_list.length,	h₂ : j < (a.to_list.update_nth ↑i v).length	⊢ j < n		n : ℕ,	α : Type u,	a : array n α,	i : fin n,	v : α,	j : ℕ,	h₁ : j < (a.write i v).to_list.length,	h₂ : j < (a.to_list.update_nth ↑i v).length,	h₃ : j < n	⊢ (a.write i v).to_list.nth_le j h₁ = (a.to_list.update_nth ↑i v).nth_le j h₂
n : ℕ,	α : Type u,	a : array n α,	i : fin n,	v : α,	j : ℕ,	h₁ : j < (a.write i v).to_list.length,	h₂ : j < (a.to_list.update_nth ↑i v).length	⊢ (a.write i v).to_list.nth_le j h₁ = (a.to_list.update_nth ↑i v).nth_le j h₂
n : ℕ,	α : Type u,	a : array n α,	i : fin n,	v : α,	j : ℕ,	h₁ : j < (a.write i v).to_list.length,	h₂ : j < (a.to_list.update_nth ↑i v).length,	h₃ : j < n	⊢ (a.write i v).to_list.nth_le j h₁ = (a.to_list.update_nth ↑i v).nth_le j h₂
n : ℕ,	α : Type u,	a : array n α,	i : fin n,	v : α,	j : ℕ,	h₁ : j < (a.write i v).to_list.length,	h₂ : j < (a.to_list.update_nth ↑i v).length,	h₃ : j < n	⊢ (a.write i v).read ⟨j, h₃⟩ = (a.to_list.update_nth ↑i v).nth_le j h₂
n : ℕ,	α : Type u,	a : array n α,	i : fin n,	v : α,	j : ℕ,	h₁ : j < (a.write i v).to_list.length,	h₂ : j < (a.to_list.update_nth ↑i v).length,	h₃ : j < n	⊢ (a.to_list.update_nth ↑i v).nth j = option.some ((a.write i v).read ⟨j, h₃⟩)
n : ℕ,	α : Type u,	a : array n α,	i : fin n,	v : α,	h₁ : ↑i < (a.write i v).to_list.length,	h₂ : ↑i < (a.to_list.update_nth ↑i v).length,	h₃ : ↑i < n	⊢ (a.to_list.update_nth ↑i v).nth ↑i = option.some ((a.write i v).read ⟨↑i, h₃⟩)
n : ℕ,	α : Type u,	a : array n α,	i : fin n,	v : α,	j : ℕ,	h₁ : j < (a.write i v).to_list.length,	h₂ : j < (a.to_list.update_nth ↑i v).length,	h₃ : j < n,	ij : ↑i = j	⊢ (a.to_list.update_nth ↑i v).nth j = option.some ((a.write i v).read ⟨j, h₃⟩)
n : ℕ,	α : Type u,	a : array n α,	i : fin n,	v : α,	j : ℕ,	h₁ : j < (a.write i v).to_list.length,	h₂ : j < (a.to_list.update_nth ↑i v).length,	h₃ : j < n,	ij : ↑i = j	⊢ (a.to_list.update_nth ↑i v).nth j = option.some ((a.write i v).read ⟨j, h₃⟩)		n : ℕ,	α : Type u,	a : array n α,	i : fin n,	v : α,	j : ℕ,	h₁ : j < (a.write i v).to_list.length,	h₂ : j < (a.to_list.update_nth ↑i v).length,	h₃ : j < n,	ij : ¬↑i = j	⊢ (a.to_list.update_nth ↑i v).nth j = option.some ((a.write i v).read ⟨j, h₃⟩)
n : ℕ,	α : Type u,	a : array n α,	i : fin n,	v : α,	h₁ : ↑i < (a.write i v).to_list.length,	h₂ : ↑i < (a.to_list.update_nth ↑i v).length,	h₃ : ↑i < n	⊢ ↑i < a.to_list.length
n : ℕ,	α : Type u,	a : array n α,	i : fin n,	v : α,	j : ℕ,	h₁ : j < (a.write i v).to_list.length,	h₂ : j < (a.to_list.update_nth ↑i v).length,	h₃ : j < n,	ij : ¬↑i = j	⊢ (a.to_list.update_nth ↑i v).nth j = option.some ((a.write i v).read ⟨j, h₃⟩)
n : ℕ,	α : Type u,	a : array n α,	i : fin n,	v : α,	j : ℕ,	h₁ : j < (a.write i v).to_list.length,	h₂ : j < (a.to_list.update_nth ↑i v).length,	h₃ : j < n,	ij : ¬↑i = j	⊢ i ≠ ⟨j, h₃⟩
n : ℕ,	α : Type u,	v : α,	a : array n α	⊢ v ∈ a.to_list ↔ v ∈ a
n : ℕ,	α : Type u,	v : α,	a : array n α	⊢ v ∈ a.rev_list.reverse ↔ v ∈ a
n : ℕ,	α : Type u,	v : α,	a : array n α	⊢ v ∈ a.to_list ↔ v ∈ a
a b : bool,	H : ↥a	⊢ ↥(a || b)
α : Type u_1,	p : Prop,	_inst_1 : decidable p,	t e : α	⊢ cond (decidable.to_bool p) t e = ite p t e
α : Type u_1,	p : Prop,	_inst_1 : decidable p,	t e : α,	h : p	⊢ cond (decidable.to_bool p) t e = ite p t e
α : Type u_1,	p : Prop,	_inst_1 : decidable p,	t e : α,	h : ¬p	⊢ cond (decidable.to_bool p) t e = ite p t e
α : Type u_1,	p : Prop,	_inst_1 : decidable p,	t e : α	⊢ cond (decidable.to_bool p) t e = ite p t e
α : Type,	msgs : thunk (list string),	p : parser α	⊢ (parser.decorate_errors msgs p).bounded ↔ p.bounded
α : Type,	msgs : thunk (list string),	p : parser α	⊢ (parser.decorate_errors msgs p).bounded → p.bounded
α : Type,	msgs : thunk (list string),	p : parser α,	ᾰ : (parser.decorate_errors msgs p).bounded	⊢ p.bounded
α : Type,	msgs : thunk (list string),	p : parser α,	ᾰ : (parser.decorate_errors msgs p).bounded	⊢ ∀ {cb : char_buffer} {n : ℕ}, buffer.size cb ≤ n → (∃ (n' : ℕ) (err : dlist string), p cb n = parse_result.fail n' err)
α : Type,	msgs : thunk (list string),	p : parser α,	ᾰ : (parser.decorate_errors msgs p).bounded,	cb : char_buffer,	n : ℕ,	hn : buffer.size cb ≤ n	⊢ ∃ (n' : ℕ) (err : dlist string), p cb n = parse_result.fail n' err
α : Type,	msgs : thunk (list string),	p : parser α,	ᾰ : (parser.decorate_errors msgs p).bounded,	cb : char_buffer,	n : ℕ,	hn : buffer.size cb ≤ n,	w : ℕ,	h_w : dlist string,	h : parser.decorate_errors msgs p cb n = parse_result.fail w h_w	⊢ ∃ (n' : ℕ) (err : dlist string), p cb n = parse_result.fail n' err
α : Type,	msgs : thunk (list string),	p : parser α	⊢ (parser.decorate_errors msgs p).bounded → p.bounded		α : Type,	msgs : thunk (list string),	p : parser α	⊢ p.bounded → (parser.decorate_errors msgs p).bounded
α : Type,	msgs : thunk (list string),	p : parser α,	ᾰ : (parser.decorate_errors msgs p).bounded,	cb : char_buffer,	n : ℕ,	hn : buffer.size cb ≤ n,	w : ℕ,	h_w : dlist string,	h : n = w ∧ h_w = dlist.of_list (msgs ()) ∧ ∃ (np : ℕ) (err' : dlist string), p cb n = parse_result.fail np err'	⊢ ∃ (n' : ℕ) (err : dlist string), p cb n = parse_result.fail n' err
α : Type,	msgs : thunk (list string),	p : parser α	⊢ p.bounded → (parser.decorate_errors msgs p).bounded
α : Type,	msgs : thunk (list string),	p : parser α,	ᾰ : p.bounded	⊢ (parser.decorate_errors msgs p).bounded
α : Type,	msgs : thunk (list string),	p : parser α,	ᾰ : p.bounded	⊢ ∀ {cb : char_buffer} {n : ℕ}, buffer.size cb ≤ n → (∃ (n' : ℕ) (err : dlist string), parser.decorate_errors msgs p cb n = parse_result.fail n' err)
α : Type,	msgs : thunk (list string),	p : parser α,	ᾰ : p.bounded,	cb : char_buffer,	n : ℕ,	hn : buffer.size cb ≤ n	⊢ ∃ (n' : ℕ) (err : dlist string), parser.decorate_errors msgs p cb n = parse_result.fail n' err
α : Type,	msgs : thunk (list string),	p : parser α,	ᾰ : p.bounded,	cb : char_buffer,	n : ℕ,	hn : buffer.size cb ≤ n,	w : ℕ,	h_w : dlist string,	h : p cb n = parse_result.fail w h_w	⊢ ∃ (n' : ℕ) (err : dlist string), parser.decorate_errors msgs p cb n = parse_result.fail n' err
⊢ ¬parser.remaining.step
⊢ ∃ (cb : char_buffer) (n n' a : ℕ), parser.remaining cb n = parse_result.done n' a
α : Type,	cb : char_buffer,	n n' : ℕ,	err : dlist string	⊢ failure cb n = parse_result.fail n' err ↔ n = n' ∧ err = dlist.empty
α : Type,	cb : char_buffer,	n n' : ℕ,	p : parser α,	err : dlist string	⊢ p.many cb n = parse_result.fail n' err ↔ n ≠ n' ∧ (p cb n = parse_result.fail n' err ∨ ∃ (np : ℕ) (a : α), p cb n = parse_result.done np a ∧ parser.foldr_core list.cons p list.nil (buffer.size cb - n) cb np = parse_result.fail n' err)
α : Type,	cb : char_buffer,	n n' : ℕ,	a : α,	p : parser α,	l : list α	⊢ p.many1 cb n = parse_result.done n' (a :: l) ↔ ∃ (np : ℕ), p cb n = parse_result.done np a ∧ p.many cb np = parse_result.done n' l
⊢ ring ℂ
z : ℂ	⊢ (⇑complex.conj (bit0 z)).re = (bit0 (⇑complex.conj z)).re ∧ (⇑complex.conj (bit0 z)).im = (bit0 (⇑complex.conj z)).im
z : ℂ	⊢ ⇑complex.norm_sq (-z) = ⇑complex.norm_sq z
n : ℤ	⊢ complex.I ^ bit1 n = (-1) ^ n * complex.I
z w : ℂ,	hz : 0 < z,	hw : 0 < w	⊢ 0 < z * w
f : cau_seq ℂ complex.abs,	ε : ℝ,	ε0 : ε > 0,	i : ℕ,	H : ∀ (j : ℕ), j ≥ i → abs' (⇑(⟨λ (n : ℕ), (⇑f n).re, _⟩ - cau_seq.const abs' (cau_seq.lim ⟨λ (n : ℕ), (⇑f n).re, _⟩)) j) < ε / 2 ∧ abs' (⇑(⟨λ (n : ℕ), (⇑f n).im, _⟩ - cau_seq.const abs' (cau_seq.lim ⟨λ (n : ℕ), (⇑f n).im, _⟩)) j) < ε / 2,	j : ℕ,	ij : j ≥ i	⊢ complex.abs (⇑(f - cau_seq.const complex.abs (complex.lim_aux f)) j) < ε
f : cau_seq ℂ complex.abs,	ε : ℝ,	ε0 : ε > 0,	i : ℕ,	H : ∀ (j : ℕ), j ≥ i → abs' (⇑(⟨λ (n : ℕ), (⇑f n).re, _⟩ - cau_seq.const abs' (cau_seq.lim ⟨λ (n : ℕ), (⇑f n).re, _⟩)) j) < ε / 2 ∧ abs' (⇑(⟨λ (n : ℕ), (⇑f n).im, _⟩ - cau_seq.const abs' (cau_seq.lim ⟨λ (n : ℕ), (⇑f n).im, _⟩)) j) < ε / 2,	j : ℕ,	ij : j ≥ i,	H₁ : abs' (⇑(⟨λ (n : ℕ), (⇑f n).re, _⟩ - cau_seq.const abs' (cau_seq.lim ⟨λ (n : ℕ), (⇑f n).re, _⟩)) j) < ε / 2,	H₂ : abs' (⇑(⟨λ (n : ℕ), (⇑f n).im, _⟩ - cau_seq.const abs' (cau_seq.lim ⟨λ (n : ℕ), (⇑f n).im, _⟩)) j) < ε / 2	⊢ complex.abs (⇑(f - cau_seq.const complex.abs (complex.lim_aux f)) j) < ε
f : cau_seq ℂ complex.abs,	ε : ℝ,	ε0 : ε > 0,	i : ℕ,	H : ∀ (j : ℕ), j ≥ i → abs' (⇑(⟨λ (n : ℕ), (⇑f n).re, _⟩ - cau_seq.const abs' (cau_seq.lim ⟨λ (n : ℕ), (⇑f n).re, _⟩)) j) < ε / 2 ∧ abs' (⇑(⟨λ (n : ℕ), (⇑f n).im, _⟩ - cau_seq.const abs' (cau_seq.lim ⟨λ (n : ℕ), (⇑f n).im, _⟩)) j) < ε / 2,	j : ℕ,	ij : j ≥ i,	H₁ : abs' (⇑(⟨λ (n : ℕ), (⇑f n).re, _⟩ - cau_seq.const abs' (cau_seq.lim ⟨λ (n : ℕ), (⇑f n).re, _⟩)) j) < ε / 2,	H₂ : abs' (⇑(⟨λ (n : ℕ), (⇑f n).im, _⟩ - cau_seq.const abs' (cau_seq.lim ⟨λ (n : ℕ), (⇑f n).im, _⟩)) j) < ε / 2	⊢ abs' (⇑(f - cau_seq.const complex.abs (complex.lim_aux f)) j).re + abs' (⇑(f - cau_seq.const complex.abs (complex.lim_aux f)) j).im < ε
f : cau_seq ℂ complex.abs,	ε : ℝ,	ε0 : ε > 0,	i : ℕ,	H : ∀ (j : ℕ), j ≥ i → abs' ((⇑f j).re - cau_seq.lim ⟨λ (n : ℕ), (⇑f n).re, _⟩) < ε / 2 ∧ abs' ((⇑f j).im - cau_seq.lim ⟨λ (n : ℕ), (⇑f n).im, _⟩) < ε / 2,	j : ℕ,	ij : j ≥ i,	H₁ : abs' ((⇑f j).re - cau_seq.lim ⟨λ (n : ℕ), (⇑f n).re, _⟩) < ε / 2,	H₂ : abs' ((⇑f j).im - cau_seq.lim ⟨λ (n : ℕ), (⇑f n).im, _⟩) < ε / 2	⊢ abs' ((⇑f j).re - (complex.cau_seq_re f).lim) + abs' ((⇑f j).im - (complex.cau_seq_im f).lim) < ε
f : cau_seq ℂ complex.abs,	ε : ℝ,	ε0 : ε > 0,	i : ℕ,	H : ∀ (j : ℕ), j ≥ i → abs' ((⇑f j).re - cau_seq.lim ⟨λ (n : ℕ), (⇑f n).re, _⟩) < ε / 2 ∧ abs' ((⇑f j).im - cau_seq.lim ⟨λ (n : ℕ), (⇑f n).im, _⟩) < ε / 2,	j : ℕ,	ij : j ≥ i,	H₁ : abs' ((⇑f j).re - cau_seq.lim ⟨λ (n : ℕ), (⇑f n).re, _⟩) < ε / 2,	H₂ : abs' ((⇑f j).im - cau_seq.lim ⟨λ (n : ℕ), (⇑f n).im, _⟩) < ε / 2,	this : abs' ((⇑f j).re - cau_seq.lim ⟨λ (n : ℕ), (⇑f n).re, _⟩) + abs' ((⇑f j).im - cau_seq.lim ⟨λ (n : ℕ), (⇑f n).im, _⟩) < ε / 2 + ε / 2	⊢ abs' ((⇑f j).re - (complex.cau_seq_re f).lim) + abs' ((⇑f j).im - (complex.cau_seq_im f).lim) < ε
f : cau_seq ℂ complex.abs	⊢ (complex.cau_seq_conj f).lim.re = (⇑complex.conj f.lim).re
f : cau_seq ℂ complex.abs	⊢ (complex.cau_seq_conj f).lim.im = (⇑complex.conj f.lim).im
f : cau_seq ℂ complex.abs	⊢ cau_seq.lim ⟨λ (n : ℕ), -(⇑f n).im, _⟩ = (-⟨λ (n : ℕ), (⇑f n).im, _⟩).lim
f : cau_seq ℂ complex.abs	⊢ (complex.cau_seq_conj f).lim.im = (⇑complex.conj f.lim).im
x : ℝ	⊢ real.sin x * real.sin x ≤ 1
x : ℂ,	hx : complex.abs x ≤ 1	⊢ complex.abs (complex.exp x - 1) = complex.abs (complex.exp x - ∑ (m : ℕ) in finset.range 1, x ^ m / ↑m!)
x : ℂ,	hx : complex.abs x ≤ 1	⊢ complex.abs x ^ 1 * (↑(1.succ) * (↑1! * ↑1)⁻¹) = 2 * complex.abs x
n : ℕ,	x a₁ b₁ : ℝ,	m : ℕ,	e₁ : n + 1 = m,	a₂ b₂ : ℝ,	e : abs' (1 + x / ↑m * a₂ - a₁) ≤ b₁ - abs' x / ↑m * b₂,	h : abs' (real.exp x - real.exp_near m x a₂) ≤ abs' x ^ m / ↑m! * b₂	⊢ abs' (real.exp x - real.exp_near n x a₁) ≤ abs' x ^ n / ↑n! * b₁
n : ℕ,	x a₁ b₁ a₂ b₂ : ℝ,	e : abs' (1 + x / ↑(n + 1) * a₂ - a₁) ≤ b₁ - abs' x / ↑(n + 1) * b₂,	h : abs' (real.exp x - real.exp_near (n + 1) x a₂) ≤ abs' x ^ (n + 1) / ↑(n + 1)! * b₂	⊢ abs' x ^ (n + 1) / ↑(n + 1)! * b₂ + abs' (real.exp_near (n + 1) x a₂ - real.exp_near n x a₁) ≤ abs' x ^ n / ↑n! * b₁
n : ℕ,	x a₁ b₁ : ℝ,	m : ℕ,	e₁ : n + 1 = m,	a₂ b₂ : ℝ,	e : abs' (1 + x / ↑m * a₂ - a₁) ≤ b₁ - abs' x / ↑m * b₂,	h : abs' (real.exp x - real.exp_near m x a₂) ≤ abs' x ^ m / ↑m! * b₂	⊢ abs' x ^ m / ↑m! * b₂ + abs' (real.exp_near m x a₂ - real.exp_near n x a₁) ≤ abs' x ^ n / ↑n! * b₁
n : ℕ,	x a₁ b₁ a₂ b₂ : ℝ,	e : abs' (1 + x / ↑(n + 1) * a₂ - a₁) ≤ b₁ - abs' x / ↑(n + 1) * b₂,	h : abs' (real.exp x - real.exp_near (n + 1) x a₂) ≤ abs' x ^ (n + 1) / ↑(n + 1)! * b₂	⊢ abs' x ^ (n + 1) / ↑(n + 1)! * b₂ + abs' (x ^ n / ↑n!) * abs' (1 + x / (↑n + 1) * a₂ - a₁) ≤ abs' x ^ n / ↑n! * b₁
n : ℕ,	x a₁ b₁ a₂ b₂ : ℝ,	e : abs' (1 + x / ↑(n + 1) * a₂ - a₁) ≤ b₁ - abs' x / ↑(n + 1) * b₂,	h : abs' (real.exp x - real.exp_near (n + 1) x a₂) ≤ abs' x ^ (n + 1) / ↑(n + 1)! * b₂	⊢ abs' x ^ (n + 1) / ↑(n + 1)! * b₂ + abs' (x ^ n / ↑n!) * abs' (1 + x / (↑n + 1) * a₂ - a₁) = abs' x ^ n / ↑n! * (abs' x / ↑(n + 1) * b₂ + abs' (1 + x / ↑(n + 1) * a₂ - a₁))
n : ℕ,	x a₁ b₁ a₂ b₂ : ℝ,	e : abs' (1 + x / ↑(n + 1) * a₂ - a₁) ≤ b₁ - abs' x / ↑(n + 1) * b₂,	h : abs' (real.exp x - real.exp_near (n + 1) x a₂) ≤ abs' x ^ (n + 1) / ↑(n + 1)! * b₂	⊢ abs' x ^ (n + 1) / ↑(n + 1)! * b₂ + abs' (x ^ n / ↑n!) * abs' (1 + x / (↑n + 1) * a₂ - a₁) = abs' x ^ n / ↑n! * (abs' x / ↑(n + 1) * b₂ + abs' (1 + x / ↑(n + 1) * a₂ - a₁))		n : ℕ,	x a₁ b₁ a₂ b₂ : ℝ,	e : abs' (1 + x / ↑(n + 1) * a₂ - a₁) ≤ b₁ - abs' x / ↑(n + 1) * b₂,	h : abs' (real.exp x - real.exp_near (n + 1) x a₂) ≤ abs' x ^ (n + 1) / ↑(n + 1)! * b₂	⊢ 0 ≤ abs' x ^ n / ↑n!
n : ℕ,	x a₁ b₁ a₂ b₂ : ℝ,	e : abs' (1 + x / ↑(n + 1) * a₂ - a₁) ≤ b₁ - abs' x / ↑(n + 1) * b₂,	h : abs' (real.exp x - real.exp_near (n + 1) x a₂) ≤ abs' x ^ (n + 1) / ↑(n + 1)! * b₂	⊢ abs' x ^ n * abs' x * ((↑n + 1)⁻¹ * (↑n!)⁻¹) * b₂ = abs' x ^ n * (↑n!)⁻¹ * (abs' x * (↑n + 1)⁻¹ * b₂)
n : ℕ,	x a₁ b₁ a₂ b₂ : ℝ,	e : abs' (1 + x / ↑(n + 1) * a₂ - a₁) ≤ b₁ - abs' x / ↑(n + 1) * b₂,	h : abs' (real.exp x - real.exp_near (n + 1) x a₂) ≤ abs' x ^ (n + 1) / ↑(n + 1)! * b₂	⊢ 0 ≤ abs' x ^ n / ↑n!
ε : ℝ,	ε0 : ε > 0,	j : ℕ,	hj : j ≥ 1	⊢ complex.abs (⇑(complex.exp' 0 - cau_seq.const complex.abs 1) j) < ε
ε : ℝ,	ε0 : ε > 0,	j : ℕ,	hj : j ≥ 1	⊢ complex.abs (⇑(complex.exp' 0 - cau_seq.const complex.abs 1) j) = 0
ε : ℝ,	ε0 : ε > 0,	hj : 0 ≥ 1	⊢ complex.abs (⇑(complex.exp' 0 - cau_seq.const complex.abs 1) 0) = 0		case nat.succ	ε : ℝ,	ε0 : ε > 0,	j : ℕ,	hj : j.succ ≥ 1	⊢ complex.abs (⇑(complex.exp' 0 - cau_seq.const complex.abs 1) j.succ) = 0
ε : ℝ,	ε0 : ε > 0,	hj : 0 ≥ 1	⊢ complex.abs (⇑(complex.exp' 0 - cau_seq.const complex.abs 1) 0) = 0
ε : ℝ,	ε0 : ε > 0,	j : ℕ,	hj : j.succ ≥ 1	⊢ complex.abs (⇑(complex.exp' 0 - cau_seq.const complex.abs 1) j.succ) = 0
ε : ℝ,	ε0 : ε > 0,	j : ℕ,	hj : j.succ ≥ 1	⊢ complex.abs (∑ (m : ℕ) in finset.range j.succ, 0 ^ m / ↑m! - 1) = 0
ε : ℝ,	ε0 : ε > 0,	hj : 1 ≥ 1	⊢ complex.abs (∑ (m : ℕ) in finset.range 1, 0 ^ m / ↑m! - 1) = 0
ε : ℝ,	ε0 : ε > 0,	hj : 1 ≥ 1	⊢ complex.abs (∑ (m : ℕ) in {0}, 0 ^ m / ↑m! - 1) = 0
ε : ℝ,	ε0 : ε > 0,	hj : 1 ≥ 1	⊢ complex.abs (∑ (m : ℕ) in finset.range 1, 0 ^ m / ↑m! - 1) = 0		case nat.succ	ε : ℝ,	ε0 : ε > 0,	j : ℕ,	ih : j.succ ≥ 1 → complex.abs (∑ (m : ℕ) in finset.range j.succ, 0 ^ m / ↑m! - 1) = 0,	hj : j.succ.succ ≥ 1	⊢ complex.abs (∑ (m : ℕ) in finset.range j.succ.succ, 0 ^ m / ↑m! - 1) = 0
ε : ℝ,	ε0 : ε > 0,	hj : 1 ≥ 1	⊢ complex.abs (∑ (m : ℕ) in finset.range 1, 0 ^ m / ↑m! - 1) = 0
ε : ℝ,	ε0 : ε > 0,	j : ℕ,	ih : j.succ ≥ 1 → complex.abs (∑ (m : ℕ) in finset.range j.succ, 0 ^ m / ↑m! - 1) = 0,	hj : j.succ.succ ≥ 1	⊢ complex.abs (∑ (m : ℕ) in finset.range j.succ.succ, 0 ^ m / ↑m! - 1) = 0
ε : ℝ,	ε0 : ε > 0,	j : ℕ,	ih : j.succ ≥ 1 → complex.abs (∑ (m : ℕ) in finset.range j.succ, 0 ^ m / ↑m! - 1) = 0,	hj : j.succ.succ ≥ 1	⊢ complex.abs (∑ (m : ℕ) in finset.range j.succ.succ, 0 ^ m / ↑m! - 1) = complex.abs (∑ (m : ℕ) in finset.range j.succ, 0 ^ m / ↑m! - 1)
ε : ℝ,	ε0 : ε > 0,	j : ℕ,	ih : j.succ ≥ 1 → complex.abs (∑ (m : ℕ) in finset.range j.succ, 0 ^ m / ↑m! - 1) = 0,	hj : j.succ.succ ≥ 1	⊢ complex.abs (∑ (x : ℕ) in finset.range j, 0 ^ x / ↑x! + 0 ^ j / ↑j! + 0 * 0 ^ j / ↑(j.succ)! - 1) = complex.abs (∑ (x : ℕ) in finset.range j, 0 ^ x / ↑x! + 0 ^ j / ↑j! - 1)
x : ℂ,	exp_nat_mul : ∀ (n : ℕ), complex.exp (↑n * x) = complex.exp x ^ n	⊢ complex.exp (↑0 * x) = complex.exp x ^ 0
x : ℂ,	exp_nat_mul : ∀ (n : ℕ), complex.exp (↑n * x) = complex.exp x ^ n,	n : ℕ	⊢ complex.exp (↑(n.succ) * x) = complex.exp x ^ n.succ
K : Type u_1,	_inst_1 : is_R_or_C K,	r : ℝ	⊢ ∥↑r∥ ^ 2 = r * r
K : Type u_1,	_inst_1 : is_R_or_C K,	z w : K	⊢ ⇑is_R_or_C.re (z / w) = ⇑is_R_or_C.re z * ⇑is_R_or_C.re w / ⇑is_R_or_C.norm_sq w + ⇑is_R_or_C.im z * ⇑is_R_or_C.im w / ⇑is_R_or_C.norm_sq w
K : Type u_1,	_inst_1 : is_R_or_C K,	this : is_R_or_C.I = 0 ∨ is_R_or_C.I * is_R_or_C.I = -1	⊢ is_R_or_C.I ≠ 0 → is_R_or_C.I * is_R_or_C.I = -1		K : Type u_1,	_inst_1 : is_R_or_C K	⊢ Type ?		K : Type u_1,	_inst_1 : is_R_or_C K	⊢ is_R_or_C ?m_1
K : Type u_1,	_inst_1 : is_R_or_C K	⊢ is_R_or_C.I ≠ 0 → is_R_or_C.I * is_R_or_C.I = -1
K : Type u_1,	_inst_1 : is_R_or_C K,	z w : K	⊢ is_R_or_C.abs (z + w) * is_R_or_C.abs (z + w) ≤ (is_R_or_C.abs z + is_R_or_C.abs w) * (is_R_or_C.abs z + is_R_or_C.abs w)
K : Type u_1,	_inst_1 : is_R_or_C K,	z w : K	⊢ ⇑is_R_or_C.re (z * ⇑is_R_or_C.conj w) ≤ is_R_or_C.abs z * is_R_or_C.abs w
⊢ ⇑(add_monoid_hom.id ℝ) 0 = 0
z : ℝ	⊢ ⇑(algebra_map ℝ ℝ) (⇑(add_monoid_hom.id ℝ) z) + ⇑(algebra_map ℝ ℝ) (⇑0 z) * 0 = z
z : ℝ	⊢ ⇑(algebra_map ℝ ℝ) (⇑(add_monoid_hom.id ℝ) z) + ⇑(algebra_map ℝ ℝ) (⇑0 z) * 0 = z
z : ℝ	⊢ (algebra_map ℝ ℝ).to_fun ((add_monoid_hom.id ℝ).to_fun z) + (algebra_map ℝ ℝ).to_fun (0.to_fun z) * 0 = z
r : ℝ	⊢ ⇑(add_monoid_hom.id ℝ) (⇑(algebra_map ℝ ℝ) r) = r
r : ℝ	⊢ ⇑0 (⇑(algebra_map ℝ ℝ) r) = 0
z w : ℝ	⊢ ⇑(add_monoid_hom.id ℝ) (z * w) = ⇑(add_monoid_hom.id ℝ) z * ⇑(add_monoid_hom.id ℝ) w - ⇑0 z * ⇑0 w
z w : ℝ	⊢ ⇑0 (z * w) = ⇑(add_monoid_hom.id ℝ) z * ⇑0 w + ⇑0 z * ⇑(add_monoid_hom.id ℝ) w
z : ℝ	⊢ ⇑(add_monoid_hom.id ℝ) (⇑(ring_hom.id ℝ) z) = ⇑(add_monoid_hom.id ℝ) z
z : ℝ	⊢ ⇑0 (⇑(ring_hom.id ℝ) z) = -⇑0 z
⊢ ⇑(ring_hom.id ℝ) 0 = -0
z : ℝ	⊢ ∥z∥ ^ 2 = ⇑(add_monoid_hom.id ℝ) z * ⇑(add_monoid_hom.id ℝ) z + ⇑0 z * ⇑0 z
z : ℝ	⊢ ⇑0 z * ⇑0 0 = ⇑0 z
z : ℝ	⊢ z⁻¹ = ⇑(ring_hom.id ℝ) z * ⇑(algebra_map ℝ ℝ) (∥z∥ ^ 2)⁻¹
z : ℝ	⊢ z / 0 = -(z * 0)
K : Type u_1,	_inst_1 : is_R_or_C K,	z : K	⊢ ∥⇑(is_R_or_C.conj_ae.to_linear_equiv) z∥ = ∥z∥
A : Type u_1,	_inst_1 : ring A,	_inst_2 : algebra ℝ A,	I' : A,	hf : I' * I' = -1	⊢ ⇑(algebra_map ℝ A) 1 + 0 • I' = 1
A : Type u_1,	_inst_1 : ring A,	_inst_2 : algebra ℝ A,	I' : A,	hf : I' * I' = -1,	_x : ℂ,	_fun_match : ∀ (_a y : ℂ), ⇑((algebra.of_id ℝ A).to_linear_map.comp complex.re_lm + (linear_map.to_span_singleton ℝ A I').comp complex.im_lm) (_a * y) = ⇑((algebra.of_id ℝ A).to_linear_map.comp complex.re_lm + (linear_map.to_span_singleton ℝ A I').comp complex.im_lm) _a * ⇑((algebra.of_id ℝ A).to_linear_map.comp complex.re_lm + (linear_map.to_span_singleton ℝ A I').comp complex.im_lm) y,	x₁ y₁ : ℝ,	_x : ℂ,	_fun_match : ∀ (_a : ℂ), ⇑((algebra.of_id ℝ A).to_linear_map.comp complex.re_lm + (linear_map.to_span_singleton ℝ A I').comp complex.im_lm) ({re := x₁, im := y₁} * _a) = ⇑((algebra.of_id ℝ A).to_linear_map.comp complex.re_lm + (linear_map.to_span_singleton ℝ A I').comp complex.im_lm) {re := x₁, im := y₁} * ⇑((algebra.of_id ℝ A).to_linear_map.comp complex.re_lm + (linear_map.to_span_singleton ℝ A I').comp complex.im_lm) _a,	x₂ y₂ : ℝ	⊢ ⇑(algebra_map ℝ A) (x₁ * x₂ - y₁ * y₂) + (x₁ * y₂ + y₁ * x₂) • I' = (⇑(algebra_map ℝ A) x₁ + y₁ • I') * (⇑(algebra_map ℝ A) x₂ + y₂ • I')
A : Type u_1,	_inst_1 : ring A,	_inst_2 : algebra ℝ A,	I' : A,	hf : I' * I' = -1,	_x : ℂ,	_fun_match : ∀ (_a y : ℂ), ⇑((algebra.of_id ℝ A).to_linear_map.comp complex.re_lm + (linear_map.to_span_singleton ℝ A I').comp complex.im_lm) (_a * y) = ⇑((algebra.of_id ℝ A).to_linear_map.comp complex.re_lm + (linear_map.to_span_singleton ℝ A I').comp complex.im_lm) _a * ⇑((algebra.of_id ℝ A).to_linear_map.comp complex.re_lm + (linear_map.to_span_singleton ℝ A I').comp complex.im_lm) y,	x₁ y₁ : ℝ,	_x : ℂ,	_fun_match : ∀ (_a : ℂ), ⇑((algebra.of_id ℝ A).to_linear_map.comp complex.re_lm + (linear_map.to_span_singleton ℝ A I').comp complex.im_lm) ({re := x₁, im := y₁} * _a) = ⇑((algebra.of_id ℝ A).to_linear_map.comp complex.re_lm + (linear_map.to_span_singleton ℝ A I').comp complex.im_lm) {re := x₁, im := y₁} * ⇑((algebra.of_id ℝ A).to_linear_map.comp complex.re_lm + (linear_map.to_span_singleton ℝ A I').comp complex.im_lm) _a,	x₂ y₂ : ℝ	⊢ ⇑(algebra_map ℝ A) (x₁ * x₂ - y₁ * y₂) + (x₁ * y₂ + y₁ * x₂) • I' = ⇑(algebra_map ℝ A) x₁ * ⇑(algebra_map ℝ A) x₂ + y₁ • I' * y₂ • I' + (⇑(algebra_map ℝ A) x₁ * y₂ • I' + y₁ • I' * ⇑(algebra_map ℝ A) x₂)
A : Type u_1,	_inst_1 : ring A,	_inst_2 : algebra ℝ A,	I' : A,	hf : I' * I' = -1,	_x : ℂ,	_fun_match : ∀ (_a y : ℂ), ⇑((algebra.of_id ℝ A).to_linear_map.comp complex.re_lm + (linear_map.to_span_singleton ℝ A I').comp complex.im_lm) (_a * y) = ⇑((algebra.of_id ℝ A).to_linear_map.comp complex.re_lm + (linear_map.to_span_singleton ℝ A I').comp complex.im_lm) _a * ⇑((algebra.of_id ℝ A).to_linear_map.comp complex.re_lm + (linear_map.to_span_singleton ℝ A I').comp complex.im_lm) y,	x₁ y₁ : ℝ,	_x : ℂ,	_fun_match : ∀ (_a : ℂ), ⇑((algebra.of_id ℝ A).to_linear_map.comp complex.re_lm + (linear_map.to_span_singleton ℝ A I').comp complex.im_lm) ({re := x₁, im := y₁} * _a) = ⇑((algebra.of_id ℝ A).to_linear_map.comp complex.re_lm + (linear_map.to_span_singleton ℝ A I').comp complex.im_lm) {re := x₁, im := y₁} * ⇑((algebra.of_id ℝ A).to_linear_map.comp complex.re_lm + (linear_map.to_span_singleton ℝ A I').comp complex.im_lm) _a,	x₂ y₂ : ℝ	⊢ ⇑(algebra_map ℝ A) (x₁ * x₂ - y₁ * y₂) = ⇑(algebra_map ℝ A) x₁ * ⇑(algebra_map ℝ A) x₂ + y₁ • I' * y₂ • I'
A : Type u_1,	_inst_1 : ring A,	_inst_2 : algebra ℝ A,	I' : A,	hf : I' * I' = -1,	_x : ℂ,	_fun_match : ∀ (_a y : ℂ), ⇑((algebra.of_id ℝ A).to_linear_map.comp complex.re_lm + (linear_map.to_span_singleton ℝ A I').comp complex.im_lm) (_a * y) = ⇑((algebra.of_id ℝ A).to_linear_map.comp complex.re_lm + (linear_map.to_span_singleton ℝ A I').comp complex.im_lm) _a * ⇑((algebra.of_id ℝ A).to_linear_map.comp complex.re_lm + (linear_map.to_span_singleton ℝ A I').comp complex.im_lm) y,	x₁ y₁ : ℝ,	_x : ℂ,	_fun_match : ∀ (_a : ℂ), ⇑((algebra.of_id ℝ A).to_linear_map.comp complex.re_lm + (linear_map.to_span_singleton ℝ A I').comp complex.im_lm) ({re := x₁, im := y₁} * _a) = ⇑((algebra.of_id ℝ A).to_linear_map.comp complex.re_lm + (linear_map.to_span_singleton ℝ A I').comp complex.im_lm) {re := x₁, im := y₁} * ⇑((algebra.of_id ℝ A).to_linear_map.comp complex.re_lm + (linear_map.to_span_singleton ℝ A I').comp complex.im_lm) _a,	x₂ y₂ : ℝ	⊢ ⇑(algebra_map ℝ A) (x₁ * x₂ - y₁ * y₂) = ⇑(algebra_map ℝ A) x₁ * ⇑(algebra_map ℝ A) x₂ + y₁ • I' * y₂ • I'		A : Type u_1,	_inst_1 : ring A,	_inst_2 : algebra ℝ A,	I' : A,	hf : I' * I' = -1,	_x : ℂ,	_fun_match : ∀ (_a y : ℂ), ⇑((algebra.of_id ℝ A).to_linear_map.comp complex.re_lm + (linear_map.to_span_singleton ℝ A I').comp complex.im_lm) (_a * y) = ⇑((algebra.of_id ℝ A).to_linear_map.comp complex.re_lm + (linear_map.to_span_singleton ℝ A I').comp complex.im_lm) _a * ⇑((algebra.of_id ℝ A).to_linear_map.comp complex.re_lm + (linear_map.to_span_singleton ℝ A I').comp complex.im_lm) y,	x₁ y₁ : ℝ,	_x : ℂ,	_fun_match : ∀ (_a : ℂ), ⇑((algebra.of_id ℝ A).to_linear_map.comp complex.re_lm + (linear_map.to_span_singleton ℝ A I').comp complex.im_lm) ({re := x₁, im := y₁} * _a) = ⇑((algebra.of_id ℝ A).to_linear_map.comp complex.re_lm + (linear_map.to_span_singleton ℝ A I').comp complex.im_lm) {re := x₁, im := y₁} * ⇑((algebra.of_id ℝ A).to_linear_map.comp complex.re_lm + (linear_map.to_span_singleton ℝ A I').comp complex.im_lm) _a,	x₂ y₂ : ℝ	⊢ (x₁ * y₂ + y₁ * x₂) • I' = ⇑(algebra_map ℝ A) x₁ * y₂ • I' + y₁ • I' * ⇑(algebra_map ℝ A) x₂
A : Type u_1,	_inst_1 : ring A,	_inst_2 : algebra ℝ A,	I' : A,	hf : I' * I' = -1,	_x : ℂ,	_fun_match : ∀ (_a y : ℂ), ⇑((algebra.of_id ℝ A).to_linear_map.comp complex.re_lm + (linear_map.to_span_singleton ℝ A I').comp complex.im_lm) (_a * y) = ⇑((algebra.of_id ℝ A).to_linear_map.comp complex.re_lm + (linear_map.to_span_singleton ℝ A I').comp complex.im_lm) _a * ⇑((algebra.of_id ℝ A).to_linear_map.comp complex.re_lm + (linear_map.to_span_singleton ℝ A I').comp complex.im_lm) y,	x₁ y₁ : ℝ,	_x : ℂ,	_fun_match : ∀ (_a : ℂ), ⇑((algebra.of_id ℝ A).to_linear_map.comp complex.re_lm + (linear_map.to_span_singleton ℝ A I').comp complex.im_lm) ({re := x₁, im := y₁} * _a) = ⇑((algebra.of_id ℝ A).to_linear_map.comp complex.re_lm + (linear_map.to_span_singleton ℝ A I').comp complex.im_lm) {re := x₁, im := y₁} * ⇑((algebra.of_id ℝ A).to_linear_map.comp complex.re_lm + (linear_map.to_span_singleton ℝ A I').comp complex.im_lm) _a,	x₂ y₂ : ℝ	⊢ (x₁ * y₂ + y₁ * x₂) • I' = ⇑(algebra_map ℝ A) x₁ * y₂ • I' + y₁ • I' * ⇑(algebra_map ℝ A) x₂
R : Type u_1,	S : Type u_2,	_inst_1 : has_scalar R ℝ,	_inst_2 : has_scalar S ℝ,	_inst_3 : smul_comm_class R S ℝ,	r : R,	s : S,	x : ℂ	⊢ r • s • x = s • r • x
R : Type u_1,	S : Type u_2,	_inst_1 : has_scalar R ℝ,	_inst_2 : has_scalar S ℝ,	_inst_3 : smul_comm_class R S ℝ,	r : R,	s : S,	x : ℂ	⊢ r • s • x = s • r • x
R : Type u_1,	S : Type u_2,	_inst_1 : has_scalar R ℝ,	_inst_2 : has_scalar S ℝ,	_inst_3 : smul_comm_class R S ℝ,	r : R,	s : S,	x : ℂ	⊢ (r • s • x).re = (s • r • x).re
R : Type u_1,	S : Type u_2,	_inst_1 : has_scalar R ℝ,	_inst_2 : has_scalar S ℝ,	_inst_3 : smul_comm_class R S ℝ,	r : R,	s : S,	x : ℂ	⊢ (r • s • x).im = (s • r • x).im
R : Type u_1,	S : Type u_2,	_inst_1 : has_scalar R S,	_inst_2 : has_scalar R ℝ,	_inst_3 : has_scalar S ℝ,	_inst_4 : is_scalar_tower R S ℝ,	r : R,	s : S,	x : ℂ	⊢ (r • s) • x = r • s • x
R : Type u_1,	S : Type u_2,	_inst_1 : has_scalar R S,	_inst_2 : has_scalar R ℝ,	_inst_3 : has_scalar S ℝ,	_inst_4 : is_scalar_tower R S ℝ,	r : R,	s : S,	x : ℂ	⊢ (r • s) • x = r • s • x
R : Type u_1,	S : Type u_2,	_inst_1 : has_scalar R S,	_inst_2 : has_scalar R ℝ,	_inst_3 : has_scalar S ℝ,	_inst_4 : is_scalar_tower R S ℝ,	r : R,	s : S,	x : ℂ	⊢ ((r • s) • x).re = (r • s • x).re
R : Type u_1,	S : Type u_2,	_inst_1 : has_scalar R S,	_inst_2 : has_scalar R ℝ,	_inst_3 : has_scalar S ℝ,	_inst_4 : is_scalar_tower R S ℝ,	r : R,	s : S,	x : ℂ	⊢ ((r • s) • x).im = (r • s • x).im
ι : Type u,	γ : Type w,	β : ι → Type v,	_inst_1 : semiring γ,	_inst_2 : Π (i : ι), add_comm_monoid (β i),	_inst_3 : Π (i : ι), module γ (β i),	c : Π₀ (i : ι), β i,	i : ι	⊢ ⇑(0 • c) i = ⇑0 i
ι : Type u,	γ : Type w,	β : ι → Type v,	_inst_1 : semiring γ,	_inst_2 : Π (i : ι), add_comm_monoid (β i),	_inst_3 : Π (i : ι), module γ (β i),	c x : γ,	y : Π₀ (i : ι), β i,	i : ι	⊢ ⇑((c + x) • y) i = ⇑(c • y + x • y) i
ι : Type u,	β : ι → Type v,	_inst_1 : Π (i : ι), add_zero_class (β i),	p : ι → Prop,	_inst_2 : decidable_pred p,	v v' : Π₀ (i : ι), β i,	i : subtype p	⊢ ⇑(dfinsupp.subtype_domain p (v + v')) i = ⇑(dfinsupp.subtype_domain p v + dfinsupp.subtype_domain p v') i
ι : Type u,	β : ι → Type v,	dec : decidable_eq ι,	_inst_1 : Π (i : ι), has_zero (β i),	p : ι → Prop,	_inst_2 : decidable_pred p,	i : ι,	x : β i	⊢ dfinsupp.filter p (dfinsupp.single i x) = ite (p i) (dfinsupp.single i x) 0
ι : Type u,	β : ι → Type v,	dec : decidable_eq ι,	_inst_1 : Π (i : ι), has_zero (β i),	p : ι → Prop,	_inst_2 : decidable_pred p,	i : ι,	x : β i,	j : ι	⊢ ⇑(dfinsupp.filter p (dfinsupp.single i x)) j = ⇑(ite (p i) (dfinsupp.single i x) 0) j
ι : Type u,	β : ι → Type v,	dec : decidable_eq ι,	_inst_1 : Π (i : ι), has_zero (β i),	p : ι → Prop,	_inst_2 : decidable_pred p,	i : ι,	x : β i,	j : ι,	this : (λ (x : Π₀ (i : ι), β i), ⇑x j) (ite (p i) (dfinsupp.single i x) 0) = ite (p i) ((λ (x : Π₀ (i : ι), β i), ⇑x j) (dfinsupp.single i x)) ((λ (x : Π₀ (i : ι), β i), ⇑x j) 0)	⊢ ⇑(dfinsupp.filter p (dfinsupp.single i x)) j = ⇑(ite (p i) (dfinsupp.single i x) 0) j
ι : Type u,	β : ι → Type v,	dec : decidable_eq ι,	_inst_1 : Π (i : ι), has_zero (β i),	p : ι → Prop,	_inst_2 : decidable_pred p,	i : ι,	x : β i,	j : ι,	this : ⇑(ite (p i) (dfinsupp.single i x) 0) j = ite (p i) (⇑(dfinsupp.single i x) j) 0	⊢ ⇑(dfinsupp.filter p (dfinsupp.single i x)) j = ⇑(ite (p i) (dfinsupp.single i x) 0) j
ι : Type u,	β : ι → Type v,	dec : decidable_eq ι,	_inst_1 : Π (i : ι), has_zero (β i),	p : ι → Prop,	_inst_2 : decidable_pred p,	i : ι,	x : β i,	j : ι,	this : ⇑(ite (p i) (dfinsupp.single i x) 0) j = ite (p i) (⇑(dfinsupp.single i x) j) 0	⊢ ite (p j) (⇑(dfinsupp.single i x) j) 0 = ite (p i) (⇑(dfinsupp.single i x) j) 0
ι : Type u,	β : ι → Type v,	dec : decidable_eq ι,	_inst_1 : Π (i : ι), has_zero (β i),	p : ι → Prop,	_inst_2 : decidable_pred p,	i : ι,	x : β i,	this : ⇑(ite (p i) (dfinsupp.single i x) 0) i = ite (p i) (⇑(dfinsupp.single i x) i) 0	⊢ ite (p i) (⇑(dfinsupp.single i x) i) 0 = ite (p i) (⇑(dfinsupp.single i x) i) 0		ι : Type u,	β : ι → Type v,	dec : decidable_eq ι,	_inst_1 : Π (i : ι), has_zero (β i),	p : ι → Prop,	_inst_2 : decidable_pred p,	i : ι,	x : β i,	j : ι,	this : ⇑(ite (p i) (dfinsupp.single i x) 0) j = ite (p i) (⇑(dfinsupp.single i x) j) 0,	hij : i ≠ j	⊢ ite (p j) (⇑(dfinsupp.single i x) j) 0 = ite (p i) (⇑(dfinsupp.single i x) j) 0
ι : Type u,	β : ι → Type v,	dec : decidable_eq ι,	_inst_1 : Π (i : ι), has_zero (β i),	p : ι → Prop,	_inst_2 : decidable_pred p,	i : ι,	x : β i,	this : ⇑(ite (p i) (dfinsupp.single i x) 0) i = ite (p i) (⇑(dfinsupp.single i x) i) 0	⊢ ite (p i) (⇑(dfinsupp.single i x) i) 0 = ite (p i) (⇑(dfinsupp.single i x) i) 0
ι : Type u,	β : ι → Type v,	dec : decidable_eq ι,	_inst_1 : Π (i : ι), has_zero (β i),	p : ι → Prop,	_inst_2 : decidable_pred p,	i : ι,	x : β i,	j : ι,	this : ⇑(ite (p i) (dfinsupp.single i x) 0) j = ite (p i) (⇑(dfinsupp.single i x) j) 0,	hij : i ≠ j	⊢ ite (p j) (⇑(dfinsupp.single i x) j) 0 = ite (p i) (⇑(dfinsupp.single i x) j) 0
α : Type u,	p : α → Prop,	q : subtype p → Prop,	_x : {a // ∃ (h : p a), q ⟨a, h⟩},	_fun_match : {a // ∃ (h : p a), q ⟨a, h⟩} → subtype q,	a : α,	ha : ∃ (h : p a), q ⟨a, h⟩	⊢ q ⟨a, _⟩
α : Type u,	p : α → Prop,	q : subtype p → Prop,	_x : {a // ∃ (h : p a), q ⟨a, h⟩},	_fun_match : {a // ∃ (h : p a), q ⟨a, h⟩} → subtype q,	a : α,	ha_w : p a,	ha_h : q ⟨a, ha_w⟩	⊢ q ⟨a, _⟩
α : Type u_1,	s t : set α,	h : s ⊆ t,	_inst_1 : decidable_pred (λ (_x : α), _x ∈ s),	x : ↥t,	hx : x.val ∉ s	⊢ ⇑((equiv.set.sum_diff_subset h).symm) x = sum.inr ⟨↑x, _⟩
α : Type u_1,	s t : set α,	h : s ⊆ t,	_inst_1 : decidable_pred (λ (_x : α), _x ∈ s),	x : ↥t,	hx : x.val ∉ s	⊢ ⇑(equiv.set.sum_diff_subset h) (⇑((equiv.set.sum_diff_subset h).symm) x) = ⇑(equiv.set.sum_diff_subset h) (sum.inr ⟨↑x, _⟩)
α : Type u_1,	s t : set α,	h : s ⊆ t,	_inst_1 : decidable_pred (λ (_x : α), _x ∈ s),	x : ↥t,	hx : x.val ∉ s	⊢ x = set.inclusion _ ⟨↑x, _⟩
α : Sort u,	_inst_1 : decidable_eq α,	a b x : α	⊢ x ≠ a → x ≠ b → ⇑(equiv.swap a b) x = x
α : Sort u,	_inst_1 : decidable_eq α,	a b x : α	⊢ ⇑(equiv.swap a b) x ≠ x ↔ a ≠ b ∧ (x = a ∨ x = b)
α : Sort u,	_inst_1 : decidable_eq α,	a b x : α,	hab : a = b	⊢ ⇑(equiv.swap a b) x ≠ x ↔ a ≠ b ∧ (x = a ∨ x = b)		α : Sort u,	_inst_1 : decidable_eq α,	a b x : α,	hab : ¬a = b	⊢ ⇑(equiv.swap a b) x ≠ x ↔ a ≠ b ∧ (x = a ∨ x = b)
α : Sort u,	_inst_1 : decidable_eq α,	a b x : α,	hab : a = b	⊢ ⇑(equiv.swap a b) x ≠ x ↔ a ≠ b ∧ (x = a ∨ x = b)
α : Sort u,	_inst_1 : decidable_eq α,	a b x : α,	hab : ¬a = b	⊢ ⇑(equiv.swap a b) x ≠ x ↔ a ≠ b ∧ (x = a ∨ x = b)
α : Sort u,	_inst_1 : decidable_eq α,	a b x : α,	hab : ¬a = b,	hax : x = a	⊢ ⇑(equiv.swap a b) x ≠ x ↔ a ≠ b ∧ (x = a ∨ x = b)		α : Sort u,	_inst_1 : decidable_eq α,	a b x : α,	hab : ¬a = b,	hax : ¬x = a	⊢ ⇑(equiv.swap a b) x ≠ x ↔ a ≠ b ∧ (x = a ∨ x = b)
α : Sort u,	_inst_1 : decidable_eq α,	a b x : α,	hab : ¬a = b,	hax : x = a	⊢ ⇑(equiv.swap a b) x ≠ x ↔ a ≠ b ∧ (x = a ∨ x = b)
α : Sort u,	_inst_1 : decidable_eq α,	a b x : α,	hab : ¬a = b,	hax : ¬x = a	⊢ ⇑(equiv.swap a b) x ≠ x ↔ a ≠ b ∧ (x = a ∨ x = b)
α : Sort u,	_inst_1 : decidable_eq α,	a b x : α,	hab : ¬a = b,	hax : ¬x = a,	hbx : x = b	⊢ ⇑(equiv.swap a b) x ≠ x ↔ a ≠ b ∧ (x = a ∨ x = b)		α : Sort u,	_inst_1 : decidable_eq α,	a b x : α,	hab : ¬a = b,	hax : ¬x = a,	hbx : ¬x = b	⊢ ⇑(equiv.swap a b) x ≠ x ↔ a ≠ b ∧ (x = a ∨ x = b)
α : Sort u,	_inst_1 : decidable_eq α,	a b x : α,	hab : ¬a = b,	hax : ¬x = a,	hbx : x = b	⊢ ⇑(equiv.swap a b) x ≠ x ↔ a ≠ b ∧ (x = a ∨ x = b)
α : Sort u,	_inst_1 : decidable_eq α,	a b x : α,	hab : ¬a = b,	hax : ¬x = a,	hbx : ¬x = b	⊢ ⇑(equiv.swap a b) x ≠ x ↔ a ≠ b ∧ (x = a ∨ x = b)
α : Type u_1,	β : Type u_2,	_inst_2 : decidable_eq α,	_inst_3 : decidable_eq β,	i j : α	⊢ (equiv.swap i j).sum_congr (equiv.refl β) = equiv.swap (sum.inl i) (sum.inl j)
α : Type u_1,	β : Type u_2,	_inst_2 : decidable_eq α,	_inst_3 : decidable_eq β,	i j : α,	x : α ⊕ β	⊢ ⇑((equiv.swap i j).sum_congr (equiv.refl β)) x = ⇑(equiv.swap (sum.inl i) (sum.inl j)) x
α : Type u_1,	β : Type u_2,	_inst_2 : decidable_eq α,	_inst_3 : decidable_eq β,	i j x : α	⊢ ⇑((equiv.swap i j).sum_congr (equiv.refl β)) (sum.inl x) = ⇑(equiv.swap (sum.inl i) (sum.inl j)) (sum.inl x)
α : Type u_1,	β : Type u_2,	_inst_2 : decidable_eq α,	_inst_3 : decidable_eq β,	i j x : α	⊢ sum.inl (ite (x = i) j (ite (x = j) i x)) = ite (x = i) (sum.inl j) (ite (x = j) (sum.inl i) (sum.inl x))
α : Type u_1,	β : Type u_2,	_inst_2 : decidable_eq α,	_inst_3 : decidable_eq β,	i j x : α,	h : x = i	⊢ j = j
α : Type u_1,	β : Type u_2,	_inst_2 : decidable_eq α,	_inst_3 : decidable_eq β,	i j x : α,	h : ¬x = i,	h_1 : x = j	⊢ i = i
α : Type u_1,	β : Type u_2,	_inst_2 : decidable_eq α,	_inst_3 : decidable_eq β,	i j x : α,	h : ¬x = i,	h_1 : ¬x = j	⊢ x = x
α : Type u_1,	β : Type u_2,	_inst_2 : decidable_eq α,	_inst_3 : decidable_eq β,	i j x : α	⊢ ⇑((equiv.swap i j).sum_congr (equiv.refl β)) (sum.inl x) = ⇑(equiv.swap (sum.inl i) (sum.inl j)) (sum.inl x)		case sum.inr	α : Type u_1,	β : Type u_2,	_inst_2 : decidable_eq α,	_inst_3 : decidable_eq β,	i j : α,	x : β	⊢ ⇑((equiv.swap i j).sum_congr (equiv.refl β)) (sum.inr x) = ⇑(equiv.swap (sum.inl i) (sum.inl j)) (sum.inr x)
α : Type u_1,	β : Type u_2,	_inst_2 : decidable_eq α,	_inst_3 : decidable_eq β,	i j x : α	⊢ sum.inl (ite (x = i) j (ite (x = j) i x)) = ite (x = i) (sum.inl j) (ite (x = j) (sum.inl i) (sum.inl x))
α : Type u_1,	β : Type u_2,	_inst_2 : decidable_eq α,	_inst_3 : decidable_eq β,	i j : α,	x : β	⊢ ⇑((equiv.swap i j).sum_congr (equiv.refl β)) (sum.inr x) = ⇑(equiv.swap (sum.inl i) (sum.inl j)) (sum.inr x)
α₁ : Type u_1,	β₁ : Type u_2,	e : α₁ ≃ β₁,	f : α₁ → α₁,	x : α₁	⊢ ⇑e (f x) = ⇑(e.conj) f (⇑e x)
α : Type u_1,	β : Type u_2,	γ : Type u_3,	s : set α,	t : set β,	u : set γ,	x : (α × β) × γ	⊢ x ∈ ⇑(equiv.prod_assoc α β γ) ⁻¹' s.prod (t.prod u) ↔ x ∈ (s.prod t).prod u
α : Type u_1,	β : Type u_2,	γ : Type u_3,	s : set α,	t : set β,	u : set γ	⊢ ⇑(equiv.prod_assoc α β γ) ⁻¹' s.prod (t.prod u) = (s.prod t).prod u
α : Type u_1,	β : Type u_2,	_inst_1 : encodable α,	_inst_2 : encodable β,	s : α ⊕ β	⊢ encodable.decode_sum (encodable.encode_sum s) = option.some s
α : Type u_1,	β : Type u_2,	_inst_1 : encodable α,	_inst_2 : encodable β,	s : α ⊕ β	⊢ encodable.decode_sum (encodable.encode_sum s) = option.some s
α : Type u_1,	β : Type u_2,	_inst_1 : encodable α,	_inst_2 : encodable β,	s : α	⊢ encodable.decode_sum (encodable.encode_sum (sum.inl s)) = option.some (sum.inl s)
α : Type u_1,	β : Type u_2,	_inst_1 : encodable α,	_inst_2 : encodable β,	s : β	⊢ encodable.decode_sum (encodable.encode_sum (sum.inr s)) = option.some (sum.inr s)
α : Type u_1,	β : Type u_2,	_inst_1 : encodable α,	_inst_2 : encodable β,	s : α ⊕ β	⊢ encodable.decode_sum (encodable.encode_sum s) = option.some s
_x : punit	⊢ 0.cases_on (option.some punit.star) (λ (_x : ℕ), option.none) = option.some _x
n : ℕ	⊢ ⇑(fin_succ_equiv n) 0 = option.none
⊢ ⇑(fin_succ_equiv 0) 0 = option.none
n : ℕ	⊢ ⇑(fin_succ_equiv n.succ) 0 = option.none
n : ℕ	⊢ ⇑(fin_succ_equiv n) 0 = option.none
n m : ℕ,	h : n = m,	k : ℕ,	w : k < n	⊢ k < m
n k : ℕ,	w : k < n	⊢ k < n
lower_raise' : ∀ (l : list ℕ) (n : ℕ), denumerable.lower' (denumerable.raise' l n) n = l,	m : ℕ,	l : list ℕ,	n : ℕ	⊢ denumerable.lower' (denumerable.raise' (m :: l) n) n = m :: l
α : Type u_1,	β : Type u_2,	γ : Type u_3,	e : local_equiv α β,	e' : local_equiv β γ	⊢ (e.trans e').source = e.source ∩ ⇑e ⁻¹' (e.target ∩ e'.source)
M : Type u_3,	N : Type u_4,	_inst_1 : has_mul M,	_inst_2 : has_mul N,	f : mul_hom M N,	g : N → M,	h₁ : function.left_inverse g ⇑f,	h₂ : function.right_inverse g ⇑f,	x y : N	⊢ g (x * y) = g (⇑f (g x) * ⇑f (g y))
M : Type u_3,	N : Type u_4,	_inst_1 : has_mul M,	_inst_2 : has_mul N,	f : mul_hom M N,	g : N → M,	h₁ : function.left_inverse g ⇑f,	h₂ : function.right_inverse g ⇑f,	x y : N	⊢ g (⇑f (g x) * ⇑f (g y)) = g (⇑f (g x * g y))
A : Type u_1,	B : Type u_2,	_inst_5 : ring A,	_inst_6 : ring B,	hB : is_integral_domain B,	e : A ≃+* B,	x y : A	⊢ ⇑(e.symm) (⇑e x * ⇑e y) = ⇑(e.symm) (⇑e y * ⇑e x)
A : Type u_1,	B : Type u_2,	_inst_5 : ring A,	_inst_6 : ring B,	hB : is_integral_domain B,	e : A ≃+* B,	x y : A,	this : ⇑(e.symm) (⇑e x * ⇑e y) = ⇑(e.symm) (⇑e y * ⇑e x)	⊢ x * y = y * x
A : Type u_1,	B : Type u_2,	_inst_5 : ring A,	_inst_6 : ring B,	hB : is_integral_domain B,	e : A ≃+* B,	x y : A,	hxy : x * y = 0	⊢ ⇑e x * ⇑e y = 0
A : Type u_1,	B : Type u_2,	_inst_5 : ring A,	_inst_6 : ring B,	hB : is_integral_domain B,	e : A ≃+* B,	x y : A,	hxy : x * y = 0,	this : ⇑e x * ⇑e y = 0,	hx : ⇑e x = 0	⊢ x = 0
A : Type u_1,	B : Type u_2,	_inst_5 : ring A,	_inst_6 : ring B,	hB : is_integral_domain B,	e : A ≃+* B,	x y : A,	hxy : x * y = 0,	this : ⇑e x * ⇑e y = 0,	hy : ⇑e y = 0	⊢ y = 0
A : Type u_1,	B : Type u_2,	_inst_5 : ring A,	_inst_6 : ring B,	hB : is_integral_domain B,	e : A ≃+* B	⊢ ⇑(e.symm) 0 ≠ ⇑(e.symm) 1
A : Type u_1,	B : Type u_2,	_inst_5 : ring A,	_inst_6 : ring B,	hB : is_integral_domain B,	e : A ≃+* B,	_inst : nontrivial B	⊢ ⇑(e.symm) 0 ≠ ⇑(e.symm) 1
R : Type u_1,	_inst_1 : has_mul R,	_inst_2 : has_add R	⊢ ring_aut R →* add_aut R
R : Type u_1,	_inst_1 : has_mul R,	_inst_2 : has_add R	⊢ ring_aut R →* add_aut R
R : Type u_1,	_inst_1 : has_mul R,	_inst_2 : has_add R	⊢ ring_aut R →* add_aut R
R : Type u_1,	_inst_1 : has_mul R,	_inst_2 : has_add R	⊢ 1.to_add_equiv = 1
R : Type u_1,	_inst_1 : has_mul R,	_inst_2 : has_add R	⊢ ∀ (x y : R ≃+* R), (x * y).to_add_equiv = x.to_add_equiv * y.to_add_equiv
R : Type u_1,	_inst_1 : has_mul R,	_inst_2 : has_add R	⊢ 1.to_add_equiv = 1
R : Type u_1,	_inst_1 : has_mul R,	_inst_2 : has_add R,	x y : R ≃+* R	⊢ (x * y).to_add_equiv = x.to_add_equiv * y.to_add_equiv
α : Type u,	β : Type v,	e : α ≃ β,	_inst_1 : has_add β,	_inst_2 : has_mul β,	_inst : has_add α := e.has_add	⊢ Sort ?
α : Type u,	β : Type v,	e : α ≃ β,	_inst_1 : has_add β,	_inst_2 : has_mul β,	_inst : has_add α := e.has_add,	_inst_3 : has_mul α := e.has_mul	⊢ Sort ?
α : Type u,	β : Type v,	e : α ≃ β,	_inst_1 : has_add β,	_inst_2 : has_mul β	⊢ Sort ?
α : Type u,	β : Type v,	e : α ≃ β,	_inst_1 : has_add β,	_inst_2 : has_mul β	⊢ let _inst : has_add α := e.has_add, _inst_3 : has_mul α := e.has_mul in α ≃+* β
α : Type u,	β : Type v,	e : α ≃ β,	_inst_1 : has_add β,	_inst_2 : has_mul β,	_inst : has_add α := e.has_add,	_inst_3 : has_mul α := e.has_mul	⊢ α ≃+* β
α : Type u,	β : Type v,	e : α ≃ β,	_inst_1 : has_add β,	_inst_2 : has_mul β,	_inst : has_add α := e.has_add,	_inst_3 : has_mul α := e.has_mul,	x y : α	⊢ e.to_fun (x + y) = e.to_fun x + e.to_fun y
α : Type u,	β : Type v,	e : α ≃ β,	_inst_1 : has_add β,	_inst_2 : has_mul β,	_inst : has_add α := e.has_add,	_inst_3 : has_mul α := e.has_mul,	x y : α	⊢ ⇑(e.symm) (e.to_fun (x + y)) = ⇑(e.symm) (e.to_fun x + e.to_fun y)
α : Type u,	β : Type v,	e : α ≃ β,	_inst_1 : has_add β,	_inst_2 : has_mul β,	_inst : has_add α := e.has_add,	_inst_3 : has_mul α := e.has_mul,	x y : α	⊢ x + y = ⇑(e.symm) (⇑e x + ⇑e y)
α : Type u,	β : Type v,	e : α ≃ β,	_inst_1 : has_add β,	_inst_2 : has_mul β,	_inst : has_add α := e.has_add,	_inst_3 : has_mul α := e.has_mul,	x y : α	⊢ e.to_fun (x * y) = e.to_fun x * e.to_fun y
α : Type u,	β : Type v,	e : α ≃ β,	_inst_1 : has_add β,	_inst_2 : has_mul β,	_inst : has_add α := e.has_add,	_inst_3 : has_mul α := e.has_mul,	x y : α	⊢ ⇑(e.symm) (e.to_fun (x * y)) = ⇑(e.symm) (e.to_fun x * e.to_fun y)
α : Type u,	β : Type v,	e : α ≃ β,	_inst_1 : has_add β,	_inst_2 : has_mul β,	_inst : has_add α := e.has_add,	_inst_3 : has_mul α := e.has_mul,	x y : α	⊢ x * y = ⇑(e.symm) (⇑e x * ⇑e y)
α : Type u,	β : Type v,	e : α ≃ β,	_inst_1 : mul_zero_class β,	zero : has_zero α := e.has_zero,	mul : has_mul α := e.has_mul	⊢ mul_zero_class α
α : Type u,	β : Type v,	e : α ≃ β,	_inst_1 : mul_zero_class β,	zero : has_zero α := e.has_zero,	mul : has_mul α := e.has_mul	⊢ mul_zero_class α
α : Type u,	β : Type v,	e : α ≃ β,	_inst_1 : mul_zero_class β,	zero : has_zero α := e.has_zero,	mul : has_mul α := e.has_mul	⊢ mul_zero_class α
α : Type u,	β : Type v,	e : α ≃ β,	_inst_1 : mul_zero_class β,	zero : has_zero α := e.has_zero,	mul : has_mul α := e.has_mul	⊢ mul_zero_class α
α : Type u,	β : Type v,	e : α ≃ β,	_inst_1 : mul_zero_class β,	zero : has_zero α := e.has_zero,	mul : has_mul α := e.has_mul	⊢ ⇑e 0 = 0
α : Type u,	β : Type v,	e : α ≃ β,	_inst_1 : mul_zero_class β,	zero : has_zero α := e.has_zero,	mul : has_mul α := e.has_mul	⊢ ∀ (a b : α), ⇑e (a * b) = ⇑e a * ⇑e b
α : Type u,	β : Type v,	e : α ≃ β,	_inst_1 : mul_zero_class β,	zero : has_zero α := e.has_zero,	mul : has_mul α := e.has_mul	⊢ mul_zero_class α
α : Type u,	β : Type v,	e : α ≃ β,	_inst_1 : mul_zero_class β,	zero : has_zero α := e.has_zero,	mul : has_mul α := e.has_mul	⊢ ⇑e 0 = 0
α : Type u,	β : Type v,	e : α ≃ β,	_inst_1 : mul_zero_class β,	zero : has_zero α := e.has_zero,	mul : has_mul α := e.has_mul,	a b : α	⊢ ⇑e (a * b) = ⇑e a * ⇑e b
α : Sort u_1,	a : α	⊢ ?m_1		α : Sort u_1,	a : α,	h : ?m_2 := ?m_1	⊢ (erased.mk a).out = a
α : Sort u_1,	a : α	⊢ (erased.mk a).out = a
α : Sort u_1,	a : α,	h : ∃ (x : α), (λ (b : α), x = b) = λ (b : α), a = b := erased.mk._proof_1 a	⊢ classical.some h = a
α : Sort u_1,	a : α,	h : ∃ (x : α), (λ (b : α), x = b) = λ (b : α), a = b := erased.mk._proof_1 a,	this : (λ (b : α), classical.some h = b) = λ (b : α), a = b	⊢ classical.some h = a
m n : ℕ,	C : fin (m + n) → Sort u_1,	hleft : Π (i : fin m), C (⇑(fin.cast_add n) i),	hright : Π (i : fin n), C (⇑(fin.nat_add m) i),	i : fin n	⊢ ¬↑(⇑(fin.nat_add m) i) < m		m n : ℕ,	C : fin (m + n) → Sort u_1,	hleft : Π (i : fin m), C (⇑(fin.cast_add n) i),	hright : Π (i : fin n), C (⇑(fin.nat_add m) i),	i : fin n,	this : ¬↑(⇑(fin.nat_add m) i) < m	⊢ fin.add_cases hleft hright (⇑(fin.nat_add m) i) = hright i
m n : ℕ,	C : fin (m + n) → Sort u_1,	hleft : Π (i : fin m), C (⇑(fin.cast_add n) i),	hright : Π (i : fin n), C (⇑(fin.nat_add m) i),	i : fin n	⊢ fin.add_cases hleft hright (⇑(fin.nat_add m) i) = hright i
m n : ℕ,	C : fin (m + n) → Sort u_1,	hleft : Π (i : fin m), C (⇑(fin.cast_add n) i),	hright : Π (i : fin n), C (⇑(fin.nat_add m) i),	i : fin n,	this : ¬↑(⇑(fin.nat_add m) i) < m	⊢ fin.add_cases hleft hright (⇑(fin.nat_add m) i) = hright i
m n : ℕ,	C : fin (m + n) → Sort u_1,	hleft : Π (i : fin m), C (⇑(fin.cast_add n) i),	hright : Π (i : fin n), C (⇑(fin.nat_add m) i),	i : fin n,	this : ¬↑(⇑(fin.nat_add m) i) < m	⊢ _.rec_on (hright (fin.sub_nat m (⇑(fin.cast _) (⇑(fin.nat_add m) i)) _)) = hright i
m n : ℕ,	C : fin (m + n) → Sort u_1,	hleft : Π (i : fin m), C (⇑(fin.cast_add n) i),	hright : Π (i : fin n), C (⇑(fin.nat_add m) i),	i : fin n,	this : ¬↑(⇑(fin.nat_add m) i) < m	⊢ hright (fin.sub_nat m (⇑(fin.cast _) (⇑(fin.nat_add m) i)) _) == hright i
m n : ℕ,	C : fin (m + n) → Sort u_1,	hleft : Π (i : fin m), C (⇑(fin.cast_add n) i),	hright : Π (i : fin n), C (⇑(fin.nat_add m) i),	i : fin n,	this : ¬↑(⇑(fin.nat_add m) i) < m	⊢ fin.sub_nat m (⇑(fin.cast _) (⇑(fin.nat_add m) i)) _ = i
n : ℕ,	p : fin n,	i : fin (n + 1),	h : i ≠ ⇑fin.cast_succ p	⊢ ⇑((⇑fin.cast_succ p).succ_above) (p.pred_above i) = i
n : ℕ,	p : fin n,	i : fin (n + 1),	h : i ≠ ⇑fin.cast_succ p	⊢ ite (⇑fin.cast_succ (dite (⇑fin.cast_succ p < i) (λ (h : ⇑fin.cast_succ p < i), i.pred _) (λ (h : ¬⇑fin.cast_succ p < i), i.cast_lt _)) < ⇑fin.cast_succ p) (⇑fin.cast_succ (dite (⇑fin.cast_succ p < i) (λ (h : ⇑fin.cast_succ p < i), i.pred _) (λ (h : ¬⇑fin.cast_succ p < i), i.cast_lt _))) (dite (⇑fin.cast_succ p < i) (λ (h : ⇑fin.cast_succ p < i), i.pred _) (λ (h : ¬⇑fin.cast_succ p < i), i.cast_lt _)).succ = i
n : ℕ,	i : fin (n + 1),	p : ℕ,	p_property : p < n,	h : i ≠ ⇑fin.cast_succ ⟨p, p_property⟩	⊢ ite (⇑fin.cast_succ (dite (⇑fin.cast_succ ⟨p, p_property⟩ < i) (λ (h : ⇑fin.cast_succ ⟨p, p_property⟩ < i), i.pred _) (λ (h : ¬⇑fin.cast_succ ⟨p, p_property⟩ < i), i.cast_lt _)) < ⇑fin.cast_succ ⟨p, p_property⟩) (⇑fin.cast_succ (dite (⇑fin.cast_succ ⟨p, p_property⟩ < i) (λ (h : ⇑fin.cast_succ ⟨p, p_property⟩ < i), i.pred _) (λ (h : ¬⇑fin.cast_succ ⟨p, p_property⟩ < i), i.cast_lt _))) (dite (⇑fin.cast_succ ⟨p, p_property⟩ < i) (λ (h : ⇑fin.cast_succ ⟨p, p_property⟩ < i), i.pred _) (λ (h : ¬⇑fin.cast_succ ⟨p, p_property⟩ < i), i.cast_lt _)).succ = i
n p : ℕ,	p_property : p < n,	i : ℕ,	i_property : i < n + 1,	h : ⟨i, i_property⟩ ≠ ⇑fin.cast_succ ⟨p, p_property⟩	⊢ ite (⇑fin.cast_succ (dite (⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩) (λ (h : ⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩), fin.pred ⟨i, i_property⟩ _) (λ (h : ¬⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩), fin.cast_lt ⟨i, i_property⟩ _)) < ⇑fin.cast_succ ⟨p, p_property⟩) (⇑fin.cast_succ (dite (⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩) (λ (h : ⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩), fin.pred ⟨i, i_property⟩ _) (λ (h : ¬⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩), fin.cast_lt ⟨i, i_property⟩ _))) (dite (⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩) (λ (h : ⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩), fin.pred ⟨i, i_property⟩ _) (λ (h : ¬⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩), fin.cast_lt ⟨i, i_property⟩ _)).succ = ⟨i, i_property⟩
n p : ℕ,	p_property : p < n,	i : ℕ,	i_property : i < n + 1,	h : ⟨i, i_property⟩ ≠ ⇑fin.cast_succ ⟨p, p_property⟩,	H : i < p	⊢ ite (⇑fin.cast_succ (fin.cast_lt ⟨i, i_property⟩ _) < ⇑fin.cast_succ ⟨p, p_property⟩) (⇑fin.cast_succ (fin.cast_lt ⟨i, i_property⟩ _)) (fin.cast_lt ⟨i, i_property⟩ _).succ = ⟨i, i_property⟩		n p : ℕ,	p_property : p < n,	i : ℕ,	i_property : i < n + 1,	h : ⟨i, i_property⟩ ≠ ⇑fin.cast_succ ⟨p, p_property⟩,	H : i < p	⊢ ¬⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩
n p : ℕ,	p_property : p < n,	i : ℕ,	i_property : i < n + 1,	h : ⟨i, i_property⟩ ≠ ⇑fin.cast_succ ⟨p, p_property⟩,	H : i < p	⊢ ⇑fin.cast_succ (fin.cast_lt ⟨i, i_property⟩ _) = ⟨i, i_property⟩		n p : ℕ,	p_property : p < n,	i : ℕ,	i_property : i < n + 1,	h : ⟨i, i_property⟩ ≠ ⇑fin.cast_succ ⟨p, p_property⟩,	H : i < p	⊢ ⇑fin.cast_succ (fin.cast_lt ⟨i, i_property⟩ _) < ⇑fin.cast_succ ⟨p, p_property⟩		n p : ℕ,	p_property : p < n,	i : ℕ,	i_property : i < n + 1,	h : ⟨i, i_property⟩ ≠ ⇑fin.cast_succ ⟨p, p_property⟩,	H : i < p	⊢ ¬⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩
n p : ℕ,	p_property : p < n,	i : ℕ,	i_property : i < n + 1,	h : ⟨i, i_property⟩ ≠ ⇑fin.cast_succ ⟨p, p_property⟩,	H : i < p	⊢ ⇑fin.cast_succ (fin.cast_lt ⟨i, i_property⟩ _) < ⇑fin.cast_succ ⟨p, p_property⟩		n p : ℕ,	p_property : p < n,	i : ℕ,	i_property : i < n + 1,	h : ⟨i, i_property⟩ ≠ ⇑fin.cast_succ ⟨p, p_property⟩,	H : i < p	⊢ ¬⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩
n p : ℕ,	p_property : p < n,	i : ℕ,	i_property : i < n + 1,	h : ⟨i, i_property⟩ ≠ ⇑fin.cast_succ ⟨p, p_property⟩,	H : i < p	⊢ ¬⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩
n p : ℕ,	p_property : p < n,	i : ℕ,	i_property : i < n + 1,	h : ⟨i, i_property⟩ ≠ ⇑fin.cast_succ ⟨p, p_property⟩,	H : i < p	⊢ i ≤ p
n p : ℕ,	p_property : p < n,	i : ℕ,	i_property : i < n + 1,	h : ⟨i, i_property⟩ ≠ ⇑fin.cast_succ ⟨p, p_property⟩,	H : i < p	⊢ ite (⇑fin.cast_succ (dite (⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩) (λ (h : ⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩), fin.pred ⟨i, i_property⟩ _) (λ (h : ¬⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩), fin.cast_lt ⟨i, i_property⟩ _)) < ⇑fin.cast_succ ⟨p, p_property⟩) (⇑fin.cast_succ (dite (⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩) (λ (h : ⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩), fin.pred ⟨i, i_property⟩ _) (λ (h : ¬⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩), fin.cast_lt ⟨i, i_property⟩ _))) (dite (⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩) (λ (h : ⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩), fin.pred ⟨i, i_property⟩ _) (λ (h : ¬⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩), fin.cast_lt ⟨i, i_property⟩ _)).succ = ⟨i, i_property⟩
n p : ℕ,	p_property : p < n,	i : ℕ,	i_property : i < n + 1,	h : ⟨i, i_property⟩ ≠ ⇑fin.cast_succ ⟨p, p_property⟩,	H : i < p	⊢ ite (⇑fin.cast_succ (dite (⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩) (λ (h : ⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩), fin.pred ⟨i, i_property⟩ _) (λ (h : ¬⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩), fin.cast_lt ⟨i, i_property⟩ _)) < ⇑fin.cast_succ ⟨p, p_property⟩) (⇑fin.cast_succ (dite (⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩) (λ (h : ⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩), fin.pred ⟨i, i_property⟩ _) (λ (h : ¬⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩), fin.cast_lt ⟨i, i_property⟩ _))) (dite (⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩) (λ (h : ⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩), fin.pred ⟨i, i_property⟩ _) (λ (h : ¬⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩), fin.cast_lt ⟨i, i_property⟩ _)).succ = ⟨i, i_property⟩		case or.inr	n p : ℕ,	p_property : p < n,	i : ℕ,	i_property : i < n + 1,	h : ⟨i, i_property⟩ ≠ ⇑fin.cast_succ ⟨p, p_property⟩,	H : p ≤ i	⊢ ite (⇑fin.cast_succ (dite (⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩) (λ (h : ⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩), fin.pred ⟨i, i_property⟩ _) (λ (h : ¬⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩), fin.cast_lt ⟨i, i_property⟩ _)) < ⇑fin.cast_succ ⟨p, p_property⟩) (⇑fin.cast_succ (dite (⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩) (λ (h : ⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩), fin.pred ⟨i, i_property⟩ _) (λ (h : ¬⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩), fin.cast_lt ⟨i, i_property⟩ _))) (dite (⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩) (λ (h : ⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩), fin.pred ⟨i, i_property⟩ _) (λ (h : ¬⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩), fin.cast_lt ⟨i, i_property⟩ _)).succ = ⟨i, i_property⟩
n p : ℕ,	p_property : p < n,	i : ℕ,	i_property : i < n + 1,	h : ⟨i, i_property⟩ ≠ ⇑fin.cast_succ ⟨p, p_property⟩,	H : p ≤ i	⊢ ite (⇑fin.cast_succ (fin.pred ⟨i, i_property⟩ _) < ⇑fin.cast_succ ⟨p, p_property⟩) (⇑fin.cast_succ (fin.pred ⟨i, i_property⟩ _)) (fin.pred ⟨i, i_property⟩ _).succ = ⟨i, i_property⟩		n p : ℕ,	p_property : p < n,	i : ℕ,	i_property : i < n + 1,	h : ⟨i, i_property⟩ ≠ ⇑fin.cast_succ ⟨p, p_property⟩,	H : p ≤ i	⊢ ⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩
n p : ℕ,	p_property : p < n,	i : ℕ,	i_property : i < n + 1,	h : ⟨i, i_property⟩ ≠ ⇑fin.cast_succ ⟨p, p_property⟩,	H : p ≤ i	⊢ ite (⇑fin.cast_succ (dite (⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩) (λ (h : ⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩), fin.pred ⟨i, i_property⟩ _) (λ (h : ¬⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩), fin.cast_lt ⟨i, i_property⟩ _)) < ⇑fin.cast_succ ⟨p, p_property⟩) (⇑fin.cast_succ (dite (⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩) (λ (h : ⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩), fin.pred ⟨i, i_property⟩ _) (λ (h : ¬⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩), fin.cast_lt ⟨i, i_property⟩ _))) (dite (⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩) (λ (h : ⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩), fin.pred ⟨i, i_property⟩ _) (λ (h : ¬⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩), fin.cast_lt ⟨i, i_property⟩ _)).succ = ⟨i, i_property⟩
n p : ℕ,	p_property : p < n,	i : ℕ,	i_property : i < n + 1,	h : ⟨i, i_property⟩ ≠ ⇑fin.cast_succ ⟨p, p_property⟩,	H : p ≤ i	⊢ (fin.pred ⟨i, i_property⟩ _).succ = ⟨i, i_property⟩		n p : ℕ,	p_property : p < n,	i : ℕ,	i_property : i < n + 1,	h : ⟨i, i_property⟩ ≠ ⇑fin.cast_succ ⟨p, p_property⟩,	H : p ≤ i	⊢ ¬⇑fin.cast_succ (fin.pred ⟨i, i_property⟩ _) < ⇑fin.cast_succ ⟨p, p_property⟩		n p : ℕ,	p_property : p < n,	i : ℕ,	i_property : i < n + 1,	h : ⟨i, i_property⟩ ≠ ⇑fin.cast_succ ⟨p, p_property⟩,	H : p ≤ i	⊢ ⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩
n p : ℕ,	p_property : p < n,	i : ℕ,	i_property : i < n + 1,	h : ⟨i, i_property⟩ ≠ ⇑fin.cast_succ ⟨p, p_property⟩,	H : p ≤ i	⊢ ⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩		case or.inr	n p : ℕ,	p_property : p < n,	i : ℕ,	i_property : i < n + 1,	h : ⟨i, i_property⟩ ≠ ⇑fin.cast_succ ⟨p, p_property⟩,	H : p ≤ i	⊢ (fin.pred ⟨i, i_property⟩ _).succ = ⟨i, i_property⟩		n p : ℕ,	p_property : p < n,	i : ℕ,	i_property : i < n + 1,	h : ⟨i, i_property⟩ ≠ ⇑fin.cast_succ ⟨p, p_property⟩,	H : p ≤ i	⊢ ¬⇑fin.cast_succ (fin.pred ⟨i, i_property⟩ _) < ⇑fin.cast_succ ⟨p, p_property⟩
n p : ℕ,	p_property : p < n,	i : ℕ,	i_property : i < n + 1,	h : ⟨i, i_property⟩ ≠ ⇑fin.cast_succ ⟨p, p_property⟩,	H : p ≤ i	⊢ ⇑fin.cast_succ ⟨p, p_property⟩ < ⟨i, i_property⟩
n p : ℕ,	p_property : p < n,	i : ℕ,	i_property : i < n + 1,	h : ⟨i, i_property⟩ ≠ ⇑fin.cast_succ ⟨p, p_property⟩,	H : p ≤ i	⊢ (fin.pred ⟨i, i_property⟩ _).succ = ⟨i, i_property⟩		n p : ℕ,	p_property : p < n,	i : ℕ,	i_property : i < n + 1,	h : ⟨i, i_property⟩ ≠ ⇑fin.cast_succ ⟨p, p_property⟩,	H : p ≤ i	⊢ ¬⇑fin.cast_succ (fin.pred ⟨i, i_property⟩ _) < ⇑fin.cast_succ ⟨p, p_property⟩
n p : ℕ,	p_property : p < n,	i : ℕ,	i_property : i < n + 1,	h : ⟨i, i_property⟩ ≠ ⇑fin.cast_succ ⟨p, p_property⟩,	H : p ≤ i	⊢ (fin.pred ⟨i, i_property⟩ _).succ = ⟨i, i_property⟩
n p : ℕ,	p_property : p < n,	i : ℕ,	i_property : i < n + 1,	h : ⟨i, i_property⟩ ≠ ⇑fin.cast_succ ⟨p, p_property⟩,	H : p ≤ i	⊢ ¬⇑fin.cast_succ (fin.pred ⟨i, i_property⟩ _) < ⇑fin.cast_succ ⟨p, p_property⟩
n p : ℕ,	p_property : p < n,	i : ℕ,	i_property : i < n + 1,	h : ⟨i, i_property⟩ ≠ ⇑fin.cast_succ ⟨p, p_property⟩,	H : p ≤ i,	h : ¬i = p	⊢ ¬⇑fin.cast_succ (fin.pred ⟨i, i_property⟩ _) < ⇑fin.cast_succ ⟨p, p_property⟩
n p : ℕ,	p_property : p < n,	i : ℕ,	i_property : i < n + 1,	h : ⟨i, i_property⟩ ≠ ⇑fin.cast_succ ⟨p, p_property⟩,	H : p ≤ i,	h : ¬i = p	⊢ ⇑fin.cast_succ ⟨p, p_property⟩ ≤ ⇑fin.cast_succ ⟨i.pred, _⟩
α : fin 0 → Sort u	⊢ unique (Π (i : fin 0), α i)
n : ℕ,	α : Type u_1,	β : Type u_2,	g : α → β,	y : α,	q : fin n → α	⊢ g ∘ fin.cons y q = fin.cons (g y) (g ∘ q)
n : ℕ,	α : Type u_1,	β : Type u_2,	g : α → β,	y : α,	q : fin n → α,	j : fin (n + 1)	⊢ (g ∘ fin.cons y q) j = fin.cons (g y) (g ∘ q) j
n : ℕ,	α : Type u_1,	β : Type u_2,	g : α → β,	y : α,	q : fin n → α,	j : fin (n + 1),	h : j = 0	⊢ (g ∘ fin.cons y q) 0 = fin.cons (g y) (g ∘ q) 0
n : ℕ,	α : Type u_1,	β : Type u_2,	g : α → β,	y : α,	q : fin n → α,	j : fin (n + 1),	h : j = 0	⊢ (g ∘ fin.cons y q) j = fin.cons (g y) (g ∘ q) j		n : ℕ,	α : Type u_1,	β : Type u_2,	g : α → β,	y : α,	q : fin n → α,	j : fin (n + 1),	h : ¬j = 0	⊢ (g ∘ fin.cons y q) j = fin.cons (g y) (g ∘ q) j
n : ℕ,	α : Type u_1,	β : Type u_2,	g : α → β,	y : α,	q : fin n → α,	j : fin (n + 1),	h : j = 0	⊢ (g ∘ fin.cons y q) j = fin.cons (g y) (g ∘ q) j
n : ℕ,	α : Type u_1,	β : Type u_2,	g : α → β,	y : α,	q : fin n → α,	j : fin (n + 1),	h : ¬j = 0	⊢ (g ∘ fin.cons y q) j = fin.cons (g y) (g ∘ q) j
n : ℕ,	α : Type u_1,	β : Type u_2,	g : α → β,	y : α,	q : fin n → α,	j : fin (n + 1),	h : ¬j = 0,	j' : fin n := j.pred h	⊢ (g ∘ fin.cons y q) j = fin.cons (g y) (g ∘ q) j
n : ℕ,	α : Type u_1,	β : Type u_2,	g : α → β,	y : α,	q : fin n → α,	j : fin (n + 1),	h : ¬j = 0,	j' : fin n := j.pred h,	this : j'.succ = j	⊢ (g ∘ fin.cons y q) j = fin.cons (g y) (g ∘ q) j
n : ℕ,	β : Type v,	x : β,	p : fin n → β	⊢ 0.insert_nth x p = fin.cons x p
n : ℕ,	a : fin (n + 1)	⊢ ↑(a.val) = a
n : ℕ,	a : fin (n + 1)	⊢ ↑(a.val).val = a.val
n : ℕ	⊢ ⟨n % n.succ, _⟩ = ⟨n, _⟩
n : ℕ	⊢ ↑n = fin.last n
n : ℕ,	a : fin n	⊢ ↑a = ⇑fin.cast_succ a
n : ℕ,	a : fin n	⊢ ↑↑a = ↑(⇑fin.cast_succ a)
n : ℕ,	i : fin (n + 2),	h : ↑i < n + 1	⊢ (i + 1).pred _ = i.cast_lt h
n : ℕ,	i : fin (n + 2),	h : ↑i < n + 1	⊢ ↑i + 1 < n + 2
α : Type u_1,	_inst_1 : decidable_eq α,	s t : finset α	⊢ s ∩ t ∪ s \ t = s
α : Type u_1,	_inst_1 : decidable_eq α,	s t : finset α	⊢ s \ t ∪ s ∩ t = s
α : Type u_1,	δ : α → Sort u_4,	s : finset α,	f g : Π (i : α), δ i,	_inst_1 : Π (j : α), decidable (j ∈ s),	i : α,	p : δ i → Prop,	hf : p (f i),	hg : p (g i)	⊢ p (s.piecewise f g i)
α : Type u_1,	δ : α → Sort u_4,	s : finset α,	f g : Π (i : α), δ i,	_inst_1 : Π (j : α), decidable (j ∈ s),	i : α,	p : δ i → Prop,	hf : p (f i),	hg : p (g i),	hi : i ∈ s	⊢ p (s.piecewise f g i)
α : Type u_1,	δ : α → Sort u_4,	s : finset α,	f g : Π (i : α), δ i,	_inst_1 : Π (j : α), decidable (j ∈ s),	i : α,	p : δ i → Prop,	hf : p (f i),	hg : p (g i),	hi : i ∉ s	⊢ p (s.piecewise f g i)
α : Type u_1,	δ : α → Sort u_4,	s : finset α,	f g : Π (i : α), δ i,	_inst_1 : Π (j : α), decidable (j ∈ s),	i : α,	p : δ i → Prop,	hf : p (f i),	hg : p (g i)	⊢ p (s.piecewise f g i)
α : Type u_1,	p q : α → Prop,	_inst_1 : decidable_pred p,	_inst_2 : decidable_pred q,	_inst_3 : decidable_eq α,	_inst_4 : decidable_pred (λ (a : α), p a ∨ q a),	s : finset α,	_x : α	⊢ _x ∈ finset.filter (λ (a : α), p a ∨ q a) s ↔ _x ∈ finset.filter p s ∪ finset.filter q s
α : Type u_1,	p : α → Prop,	_inst_1 : decidable_pred p,	_inst_3 : decidable_eq α,	_inst_4 : decidable_pred (λ (a : α), ¬p a),	s : finset α	⊢ ∀ (a : α), a ∈ finset.filter (λ (a : α), ¬p a) s ↔ a ∈ s \ finset.filter p s
α : Type u_1,	p : α → Prop,	_inst_1 : decidable_pred p,	_inst_3 : decidable_eq α,	_inst_4 : decidable_pred (λ (a : α), ¬p a),	s : finset α	⊢ finset.filter p s ∩ finset.filter (λ (a : α), ¬p a) s = ∅
α : Type u_1,	s : finset α	⊢ s.card ≤ 1 ↔ ∀ (a : α), a ∈ s → ∀ (b : α), b ∈ s → a = b
α : Type u_1	⊢ ∅.card ≤ 1 ↔ ∀ (a : α), a ∈ ∅ → ∀ (b : α), b ∈ ∅ → a = b
α : Type u_1	⊢ ∅.card ≤ 1 ↔ ∀ (a : α), a ∈ ∅ → ∀ (b : α), b ∈ ∅ → a = b		α : Type u_1,	s : finset α,	x : α,	hx : x ∈ s	⊢ s.card ≤ 1 ↔ ∀ (a : α), a ∈ s → ∀ (b : α), b ∈ s → a = b
α : Type u_1,	s : finset α,	x : α,	hx : x ∈ s	⊢ s.card ≤ 1 ↔ ∀ (a : α), a ∈ s → ∀ (b : α), b ∈ s → a = b
α : Type u_1,	x y : α,	hx : x ∈ {y}	⊢ ∀ (a : α), a ∈ {y} → ∀ (b : α), b ∈ {y} → a = b
α : Type u_1,	s : finset α,	x : α,	hx : x ∈ s	⊢ (∃ (a : α), s = {a}) → ∀ (a : α), a ∈ s → ∀ (b : α), b ∈ s → a = b		α : Type u_1,	s : finset α,	x : α,	hx : x ∈ s	⊢ (∀ (a : α), a ∈ s → ∀ (b : α), b ∈ s → a = b) → (∃ (a : α), s = {a})
α : Type u_1,	s : finset α,	x : α,	hx : x ∈ s	⊢ (∃ (a : α), s = {a}) → ∀ (a : α), a ∈ s → ∀ (b : α), b ∈ s → a = b
α : Type u_1,	s : finset α,	x : α,	hx : x ∈ s	⊢ (∀ (a : α), a ∈ s → ∀ (b : α), b ∈ s → a = b) → (∃ (a : α), s = {a})
α : Type u_1,	_inst_1 : decidable_eq α,	s t : finset α,	h : disjoint s t	⊢ (s ∪ t).card = s.card + t.card
α : Type u_1,	_inst_1 : decidable_eq α,	s t : finset α,	h : disjoint s t	⊢ (s ∩ t).card = 0
α : Type u_1,	_inst_1 : decidable_eq α,	s t : finset α,	h : disjoint s t	⊢ (s ∪ t).card = (s ∪ t).card + (s ∩ t).card
α : Type u_1,	_inst_1 : decidable_eq α,	s t : finset α,	h : disjoint s t	⊢ s ∩ t = ∅
α : Type u_1,	β : Type u_2,	γ : Type u_3,	_inst_1 : decidable_eq β,	_inst_2 : decidable_eq γ,	f : α → β,	s : finset α,	t : β → finset γ	⊢ (finset.image f s).bUnion t = s.bUnion (λ (a : α), t (f a))
α : Type u_1,	β : Type u_2,	γ : Type u_3,	_inst_1 : decidable_eq β,	_inst_2 : decidable_eq γ,	f : α → β,	s : finset α,	t : β → finset γ,	_inst : decidable_eq α	⊢ (finset.image f s).bUnion t = s.bUnion (λ (a : α), t (f a))
α : Type u_1,	β : Type u_2,	γ : Type u_3,	_inst_1 : decidable_eq β,	_inst_2 : decidable_eq γ,	f : α → β,	s : finset α,	t : β → finset γ	⊢ (finset.image f s).bUnion t = s.bUnion (λ (a : α), t (f a))
α : Type u_1,	β : Type u_2,	γ : Type u_3,	_inst_1 : decidable_eq β,	_inst_2 : decidable_eq γ,	f : α → β,	s : finset α,	t : β → finset γ,	_inst : decidable_eq α,	a : α,	s : finset α,	has : a ∉ s,	ih : (finset.image f s).bUnion t = s.bUnion (λ (a : α), t (f a))	⊢ (finset.image f (has_insert.insert a s)).bUnion t = (has_insert.insert a s).bUnion (λ (a : α), t (f a))
α : Type u_1,	β : Type u_2,	_inst_1 : decidable_eq β,	s : finset α,	f : α → β,	x : β	⊢ x ∈ s.bUnion (λ (a : α), {f a}) ↔ x ∈ finset.image f s
α : Type u_1,	_inst_1 : decidable_eq α,	a : α,	s t : finset α	⊢ disjoint (has_insert.insert a s) t ↔ a ∉ t ∧ disjoint s t
α : Type u_1,	a b : finset α,	_inst_2 : decidable_eq α	⊢ (∀ {a_1 : α}, a_1 ∈ a → a_1 ∉ b) ↔ ∀ {a_1 : α}, a_1 ∈ ↑a → a_1 ∉ ↑b
α : Type u_1,	a b : finset α,	_inst_2 : decidable_eq α	⊢ disjoint a b ↔ disjoint ↑a ↑b
α : Type u_1,	_inst_1 : decidable_eq α,	P : finset α → finset α → Prop,	symm : ∀ {a b : finset α}, P a b → P b a,	empty_right : ∀ {a : finset α}, P a ∅,	singletons : ∀ {a b : α}, P {a} {b},	union_of : ∀ {a b c : finset α}, P a c → P b c → P (a ∪ b) c	⊢ ∀ (a b : finset α), P a b
α : Type u_1,	_inst_1 : decidable_eq α,	P : finset α → finset α → Prop,	symm : ∀ {a b : finset α}, P a b → P b a,	empty_right : ∀ {a : finset α}, P a ∅,	singletons : ∀ {a b : α}, P {a} {b},	union_of : ∀ {a b c : finset α}, P a c → P b c → P (a ∪ b) c,	a b : finset α	⊢ P a b
α : Type u_1,	_inst_1 : decidable_eq α,	P : finset α → finset α → Prop,	symm : ∀ {a b : finset α}, P a b → P b a,	empty_right : ∀ {a : finset α}, P a ∅,	singletons : ∀ {a b : α}, P {a} {b},	union_of : ∀ {a b c : finset α}, P a c → P b c → P (a ∪ b) c,	a b : finset α,	x : α,	s : finset α,	xs : x ∉ s,	hi : P a s	⊢ P (has_insert.insert x s) a
α : Type u_1,	_inst_1 : decidable_eq α,	P : finset α → finset α → Prop,	symm : ∀ {a b : finset α}, P a b → P b a,	empty_right : ∀ {a : finset α}, P a ∅,	singletons : ∀ {a b : α}, P {a} {b},	union_of : ∀ {a b c : finset α}, P a c → P b c → P (a ∪ b) c,	a b : finset α,	x : α,	s : finset α,	xs : x ∉ s,	hi : P a s	⊢ P ({x} ∪ s) a
α : Type u_1,	_inst_1 : decidable_eq α,	P : finset α → finset α → Prop,	symm : ∀ {a b : finset α}, P a b → P b a,	empty_right : ∀ {a : finset α}, P a ∅,	singletons : ∀ {a b : α}, P {a} {b},	union_of : ∀ {a b c : finset α}, P a c → P b c → P (a ∪ b) c,	a b : finset α,	x : α,	s : finset α,	xs : x ∉ s,	hi : P a s	⊢ P {x} a
α : Type u_1,	_inst_1 : decidable_eq α,	P : finset α → finset α → Prop,	symm : ∀ {a b : finset α}, P a b → P b a,	empty_right : ∀ {a : finset α}, P a ∅,	singletons : ∀ {a b : α}, P {a} {b},	union_of : ∀ {a b c : finset α}, P a c → P b c → P (a ∪ b) c,	a b : finset α,	x : α,	s : finset α,	xs : x ∉ s,	hi : P a s,	a : α,	t : finset α,	ta : a ∉ t,	hi : P {x} t	⊢ P (has_insert.insert a t) {x}
α : Type u_1,	_inst_1 : decidable_eq α,	P : finset α → finset α → Prop,	symm : ∀ {a b : finset α}, P a b → P b a,	empty_right : ∀ {a : finset α}, P a ∅,	singletons : ∀ {a b : α}, P {a} {b},	union_of : ∀ {a b c : finset α}, P a c → P b c → P (a ∪ b) c,	a b : finset α,	x : α,	s : finset α,	xs : x ∉ s,	hi : P a s,	a : α,	t : finset α,	ta : a ∉ t,	hi : P {x} t	⊢ P ({a} ∪ t) {x}
α : Type u_1,	_inst_1 : decidable_eq α,	a : α,	s : finset α,	H : a ∈ s	⊢ {a} ∩ s = {a}
n m l k : ℕ	⊢ finset.Ico n m ∩ finset.Ico l k = finset.Ico (linear_order.max n l) (linear_order.min m k)
l u : ℤ	⊢ (finset.Ico_ℤ l u).card = (u - l).to_nat
α : Type u_1,	_inst_1 : linear_order α,	s : finset α,	h₂ : 1 < s.card	⊢ s.min' _ < s.max' _
α : Type u_1,	_inst_1 : linear_order α,	s : finset α,	h₂ : 1 < s.card,	a : α,	ha : a ∈ s,	b : α,	hb : b ∈ s,	hab : a ≠ b	⊢ s.min' _ < s.max' _
α : Type u_1	⊢ 0.antidiagonal = {(0, 0)}
α : Type u_1	⊢ 0.antidiagonal = {(0, 0)}
α : Type u_1	⊢ (multiset.map (prod.map ⇑multiset.to_finsupp ⇑multiset.to_finsupp) (⇑finsupp.to_multiset 0).antidiagonal).to_finset = {(0, 0)}
α : Type u_1,	n : α →₀ ℕ	⊢ {m : α →₀ ℕ | m ≤ n}.finite
α : Type u_1,	β : Type u_2,	M : Type u_5,	_inst_1 : add_comm_monoid M,	f : α → β,	hf : function.injective f,	v₁ v₂ : α →₀ M,	eq : finsupp.map_domain f v₁ = finsupp.map_domain f v₂	⊢ v₁ = v₂
α : Type u_1,	β : Type u_2,	M : Type u_5,	_inst_1 : add_comm_monoid M,	f : α → β,	hf : function.injective f	⊢ function.injective (finsupp.map_domain f)
α : Type u_1,	β : Type u_2,	M : Type u_5,	_inst_1 : add_comm_monoid M,	f : α → β,	hf : function.injective f,	v₁ v₂ : α →₀ M,	eq : finsupp.map_domain f v₁ = finsupp.map_domain f v₂,	a : α	⊢ ⇑v₁ a = ⇑v₂ a
α : Type u_1,	β : Type u_2,	M : Type u_5,	_inst_1 : add_comm_monoid M,	f : α → β,	hf : function.injective f,	v₁ v₂ : α →₀ M,	eq : finsupp.map_domain f v₁ = finsupp.map_domain f v₂,	a : α	⊢ ⇑(finsupp.map_domain f v₁) (f a) = ⇑(finsupp.map_domain f v₂) (f a)
α : Type u_1,	β : Type u_2,	M : Type u_5,	_inst_1 : add_comm_monoid M,	f : α → β,	hf : function.injective f,	v₁ v₂ : α →₀ M,	eq : finsupp.map_domain f v₁ = finsupp.map_domain f v₂,	a : α	⊢ ⇑(finsupp.map_domain f v₁) (f a) = ⇑(finsupp.map_domain f v₂) (f a)		α : Type u_1,	β : Type u_2,	M : Type u_5,	_inst_1 : add_comm_monoid M,	f : α → β,	hf : function.injective f,	v₁ v₂ : α →₀ M,	eq : finsupp.map_domain f v₁ = finsupp.map_domain f v₂,	a : α,	this : ⇑(finsupp.map_domain f v₁) (f a) = ⇑(finsupp.map_domain f v₂) (f a)	⊢ ⇑v₁ a = ⇑v₂ a
α : Type u_1,	β : Type u_2,	M : Type u_5,	_inst_1 : add_comm_monoid M,	f : α → β,	hf : function.injective f,	v₁ v₂ : α →₀ M,	eq : finsupp.map_domain f v₁ = finsupp.map_domain f v₂,	a : α,	this : ⇑(finsupp.map_domain f v₁) (f a) = ⇑(finsupp.map_domain f v₂) (f a)	⊢ ⇑v₁ a = ⇑v₂ a
α : Type u_1,	M : Type u_5,	_inst_1 : has_zero M,	f : option α →₀ M,	_x : α	⊢ _x ∈ option.some ⁻¹' ↑(f.support) → ∀ ⦃x₂ : α⦄, x₂ ∈ option.some ⁻¹' ↑(f.support) → option.some _x = option.some x₂ → _x = x₂
α : Type u_1,	M : Type u_5,	_inst_1 : has_zero M,	_inst_2 : fintype α,	f : α → M	⊢ ∀ (a : α), a ∈ finset.filter (λ (a : α), f a ≠ 0) finset.univ ↔ f a ≠ 0
α : Type u_1,	M : Type u_5,	_inst_1 : has_zero M,	_inst_2 : fintype α,	f : α →₀ M	⊢ (λ (f : α → M), {support := finset.filter (λ (a : α), f a ≠ 0) finset.univ, to_fun := f, mem_support_to_fun := _}) ((λ (f : α →₀ M) (a : α), ⇑f a) f) = f
α : Type u_1,	M : Type u_5,	_inst_1 : has_zero M,	_inst_2 : fintype α,	f : α →₀ M,	a : α	⊢ ⇑((λ (f : α → M), {support := finset.filter (λ (a : α), f a ≠ 0) finset.univ, to_fun := f, mem_support_to_fun := _}) ((λ (f : α →₀ M) (a : α), ⇑f a) f)) a = ⇑f a
α : Type u_1,	M : Type u_5,	_inst_1 : has_zero M,	_inst_2 : fintype α	⊢ function.left_inverse (λ (f : α → M), {support := finset.filter (λ (a : α), f a ≠ 0) finset.univ, to_fun := f, mem_support_to_fun := _}) (λ (f : α →₀ M) (a : α), ⇑f a)
α : Type u_1,	M : Type u_5,	_inst_1 : has_zero M,	_inst_2 : fintype α,	f : α → M	⊢ (λ (f : α →₀ M) (a : α), ⇑f a) ((λ (f : α → M), {support := finset.filter (λ (a : α), f a ≠ 0) finset.univ, to_fun := f, mem_support_to_fun := _}) f) = f
α : Type u_1,	M : Type u_5,	_inst_1 : has_zero M,	_inst_2 : fintype α,	f : α → M,	a : α	⊢ (λ (f : α →₀ M) (a : α), ⇑f a) ((λ (f : α → M), {support := finset.filter (λ (a : α), f a ≠ 0) finset.univ, to_fun := f, mem_support_to_fun := _}) f) a = f a
α : Type u_1,	M : Type u_5,	_inst_1 : has_zero M,	_inst_2 : fintype α	⊢ function.right_inverse (λ (f : α → M), {support := finset.filter (λ (a : α), f a ≠ 0) finset.univ, to_fun := f, mem_support_to_fun := _}) (λ (f : α →₀ M) (a : α), ⇑f a)
α : Type u_1,	D : decidable_eq α,	s : multiset α	⊢ (⇑multiset.to_finsupp s).support = s.to_finset
α : Type u_1,	D : decidable_eq α,	s : multiset α	⊢ (⇑multiset.to_finsupp s).support = s.to_finset
α : Type u_1,	D : decidable_eq α,	s : multiset α	⊢ (⇑multiset.to_finsupp s).support = s.to_finset
α : Type u_1,	M : Type u_5,	_inst_1 : has_zero M,	s : finset α,	f : α → M,	hf : ∀ (a : α), f a ≠ 0 → a ∈ s,	a : α	⊢ a ∈ (finsupp.on_finset s f hf).support ↔ f a ≠ 0
α : Type u_1,	M : Type u_5,	N : Type u_7,	_inst_1 : has_zero M,	_inst_3 : comm_monoid N,	_inst_4 : decidable_eq α,	f : α →₀ M,	a : α,	b : α → M → N	⊢ ∏ (a_1 : α) in f.support, ite (a_1 = a) (b a_1 (⇑f a_1)) 1 = ite (a ∈ f.support) (b a (⇑f a)) 1
α : Type u_1,	M : Type u_5,	N : Type u_7,	_inst_1 : has_zero M,	_inst_3 : comm_monoid N,	_inst_4 : decidable_eq α,	f : α →₀ M,	a : α,	b : α → M → N	⊢ f.prod (λ (x : α) (v : M), ite (x = a) (b x v) 1) = ite (a ∈ f.support) (b a (⇑f a)) 1
α : Type u_1,	M : Type u_5,	_inst_1 : add_zero_class M,	a : α,	f : α →₀ M,	a' : α,	h : a = a'	⊢ ⇑(finsupp.erase a f + finsupp.single a (⇑f a)) a' = ⇑f a'
α : Type u_1,	M : Type u_5,	_inst_1 : add_zero_class M,	a : α,	f : α →₀ M,	a' : α,	h : a = a'	⊢ ⇑(finsupp.erase a f + finsupp.single a (⇑f a)) a' = ⇑f a'
α : Type u_1,	M : Type u_5,	_inst_1 : add_zero_class M,	a : α,	f : α →₀ M	⊢ ⇑(finsupp.erase a f + finsupp.single a (⇑f a)) a = ⇑f a
α : Type u_1,	M : Type u_5,	_inst_1 : add_zero_class M,	a : α,	f : α →₀ M,	a' : α,	h : ¬a = a'	⊢ ⇑(finsupp.erase a f + finsupp.single a (⇑f a)) a' = ⇑f a'
ι : Type u_1,	η : ι → Type u_4,	N : Type u_5,	_inst_2 : has_zero N,	f : (Σ (i : ι), η i) →₀ N,	i : ι	⊢ i ∈ f.split_support.val ∨ f.split i = 0
ι : Type u_1,	η : ι → Type u_4,	N : Type u_5,	_inst_2 : has_zero N,	f : (Σ (i : ι), η i) →₀ N,	i : ι	⊢ f.split i ≠ 0 ∨ f.split i = 0
ι : Type u_1,	η : ι → Type u_4,	N : Type u_5,	_inst_2 : has_zero N,	f : Π₀ (i : ι), η i →₀ N	⊢ (Σ (i : ι), η i) →₀ N
ι : Type u_1,	η : ι → Type u_4,	N : Type u_5,	_inst_2 : has_zero N,	f : Π₀ (i : ι), η i →₀ N,	g : Σ (i : ι), η i,	hg : ⇑(⇑f g.fst) g.snd ≠ 0	⊢ g.fst ∈ f.support
ι : Type u_1,	η : ι → Type u_4,	N : Type u_5,	_inst_2 : has_zero N,	f : Π₀ (i : ι), η i →₀ N,	g : Σ (i : ι), η i,	hg : ⇑(⇑f g.fst) g.snd ≠ 0	⊢ ¬⇑f g.fst = 0
ι : Type u_1,	η : ι → Type u_4,	N : Type u_5,	_inst_2 : has_zero N,	f : Π₀ (i : ι), η i →₀ N,	g : Σ (i : ι), η i,	hg : ⇑(⇑f g.fst) g.snd ≠ 0,	h : ⇑f g.fst = 0	⊢ false
ι : Type u_1,	η : ι → Type u_4,	N : Type u_5,	_inst_2 : has_zero N,	f : Π₀ (i : ι), η i →₀ N,	g : Σ (i : ι), η i,	h : ⇑f g.fst = 0,	hg : ⇑0 g.snd ≠ 0	⊢ false
ι : Type u_1,	η : ι → Type u_4,	N : Type u_5,	_inst_2 : has_zero N,	f : (Σ (i : ι), η i) →₀ N	⊢ (λ (f : Π₀ (i : ι), η i →₀ N), finsupp.on_finset (f.support.sigma (λ (j : ι), (⇑f j).support)) (λ (ji : Σ (i : ι), η i), ⇑(⇑f ji.fst) ji.snd) _) ((λ (f : (Σ (i : ι), η i) →₀ N), ⟦{to_fun := f.split, pre_support := f.split_support.val, zero := _}⟧) f) = f
ι : Type u_1,	η : ι → Type u_4,	N : Type u_5,	_inst_2 : has_zero N,	f : (Σ (i : ι), η i) →₀ N,	a : Σ (i : ι), η i	⊢ ⇑((λ (f : Π₀ (i : ι), η i →₀ N), finsupp.on_finset (f.support.sigma (λ (j : ι), (⇑f j).support)) (λ (ji : Σ (i : ι), η i), ⇑(⇑f ji.fst) ji.snd) _) ((λ (f : (Σ (i : ι), η i) →₀ N), ⟦{to_fun := f.split, pre_support := f.split_support.val, zero := _}⟧) f)) a = ⇑f a
ι : Type u_1,	η : ι → Type u_4,	N : Type u_5,	_inst_2 : has_zero N,	f : Π₀ (i : ι), η i →₀ N	⊢ (λ (f : (Σ (i : ι), η i) →₀ N), ⟦{to_fun := f.split, pre_support := f.split_support.val, zero := _}⟧) ((λ (f : Π₀ (i : ι), η i →₀ N), finsupp.on_finset (f.support.sigma (λ (j : ι), (⇑f j).support)) (λ (ji : Σ (i : ι), η i), ⇑(⇑f ji.fst) ji.snd) _) f) = f
ι : Type u_1,	η : ι → Type u_4,	N : Type u_5,	_inst_2 : has_zero N,	f : Π₀ (i : ι), η i →₀ N,	i : ι,	a : η i	⊢ ⇑(⇑((λ (f : (Σ (i : ι), η i) →₀ N), ⟦{to_fun := f.split, pre_support := f.split_support.val, zero := _}⟧) ((λ (f : Π₀ (i : ι), η i →₀ N), finsupp.on_finset (f.support.sigma (λ (j : ι), (⇑f j).support)) (λ (ji : Σ (i : ι), η i), ⇑(⇑f ji.fst) ji.snd) _) f)) i) a = ⇑(⇑f i) a
α : Type u_1,	β : α → Type u_2,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	_inst_3 : Π (a : α), fintype (β a),	a : Π (a : α), a ∈ finset.univ → (λ (a : α), β a) a	⊢ a ∈ finset.univ.pi (λ (a : α), finset.univ) ↔ a ∈ finset.univ
α : Type u_1,	β : α → Type u_2,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	_inst_3 : Π (a : α), fintype (β a)	⊢ finset.univ.pi (λ (a : α), finset.univ) = finset.univ
α : Type u_1,	β : Type u_2,	_inst_2 : fintype α,	_inst_3 : fintype β,	e : α ≃ β,	b : β	⊢ ⇑(e.to_embedding) (⇑(e.symm) b) = b
α : Type u_1,	β : Type u_2,	_inst_1 : decidable_eq β,	_inst_2 : fintype β,	f : α → β,	g : β → α	⊢ decidable (∀ (x : β), f (g x) = x)
α : Type u_1,	β : Type u_2,	_inst_1 : fintype α,	_inst_2 : decidable_eq β,	f : α → β,	hf : function.injective f,	b : ↥(set.range f)	⊢ ∀ (x : α), f x = b.val ↔ x ∈ finset.univ ∧ f x = ↑b
α : Type u_1,	β : Type u_2,	F : fintype α,	G : fintype β,	h : fintype.card α = fintype.card β	⊢ nonempty (α ≃ β)
α : Type u_1,	β : Type u_2,	F : fintype α,	G : fintype β,	h : fintype.card α = fintype.card β,	_inst : Π (a : Prop), decidable a	⊢ nonempty (α ≃ β)
x : units ℤ	⊢ x ∈ {1, -1}
x : units ℤ	⊢ x ∈ {1, -1}
x : units ℤ,	h : x = 1	⊢ x ∈ {1, -1}
x : units ℤ,	h : x = -1	⊢ x ∈ {1, -1}
α : Type ?,	β : Type ?,	_inst_1 : decidable_eq α,	_inst_2 : fintype (α × β),	_inst_3 : nonempty β,	a : α,	_let_match : nonempty β → a ∈ finset.image prod.fst (fintype.elems (α × β)),	b : β	⊢ a ∈ finset.image prod.fst (fintype.elems (α × β))
α : Type ?,	β : Type ?,	_inst_1 : decidable_eq α,	_inst_2 : fintype (α × β),	_inst_3 : nonempty β,	a : α,	_let_match : nonempty β → a ∈ finset.image prod.fst (fintype.elems (α × β)),	b : β	⊢ a ∈ finset.image prod.fst (fintype.elems (α × β))
α : Type ?,	β : Type ?,	_inst_1 : decidable_eq α,	_inst_2 : fintype (α × β),	_inst_3 : nonempty β,	a : α,	_let_match : nonempty β → a ∈ finset.image prod.fst (fintype.elems (α × β)),	b : β	⊢ ∃ (x : β), (a, x) ∈ fintype.elems (α × β)
α : Type u,	β : Type v,	_inst_1 : fintype α,	_inst_2 : fintype β,	b : bool	⊢ fintype ((λ (b : bool), cond b (ulift α) (ulift β)) b)
α : Type u,	β : Type v,	_inst_1 : fintype α,	_inst_2 : fintype β,	b : bool	⊢ fintype ((λ (b : bool), cond b (ulift α) (ulift β)) b)
α : Type u,	β : Type v,	_inst_1 : fintype α,	_inst_2 : fintype β	⊢ fintype ((λ (b : bool), cond b (ulift α) (ulift β)) bool.ff)
α : Type u,	β : Type v,	_inst_1 : fintype α,	_inst_2 : fintype β	⊢ fintype ((λ (b : bool), cond b (ulift α) (ulift β)) bool.tt)
α : Type u_1,	_inst_1 : fintype α	⊢ fintype.card α = 1 ↔ ∃ (x : α), ∀ (y : α), y = x
α : Type u_1,	_inst_1 : fintype α	⊢ nonempty (α ≃ unit) ↔ ∃ (x : α), ∀ (y : α), y = x
α : Type u_1,	_inst_1 : fintype α	⊢ fintype.card α = 1 ↔ ∃ (x : α), ∀ (y : α), y = x
α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	δ : α → Type u_2,	t : Π (a : α), finset (δ a)	⊢ (fintype.pi_finset t).card = ∏ (a : α), (t a).card
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a'	⊢ ⟨a', b'⟩ ∈ ({hash_fn := hash_fn, size := size, nbuckets := n, buckets := bkts, is_valid := v}.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ {hash_fn := hash_fn, size := size, nbuckets := n, buckets := bkts, is_valid := v}.entries)
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a	⊢ ⟨a', b'⟩ ∈ ({hash_fn := hash_fn, size := size, nbuckets := n, buckets := bkts, is_valid := v}.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ {hash_fn := hash_fn, size := size, nbuckets := n, buckets := bkts, is_valid := v}.entries)
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup	⊢ ⟨a', b'⟩ ∈ ({hash_fn := hash_fn, size := size, nbuckets := n, buckets := bkts, is_valid := v}.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ {hash_fn := hash_fn, size := size, nbuckets := n, buckets := bkts, is_valid := v}.entries)
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup	⊢ ∀ (bkts' : bucket_array α β n) (v1 u w : list (Σ (a : α), β a)), bkts.as_list = u ++ v1 ++ w → bkts'.as_list = u ++ [⟨a, b⟩] ++ w → (v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩]) → (⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list))
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	bkts' : bucket_array α β n,	v1 u w : list (Σ (a : α), β a),	hl : bkts.as_list = u ++ v1 ++ w,	hfl : bkts'.as_list = u ++ [⟨a, b⟩] ++ w,	veq : v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩]	⊢ ⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list)
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	bkts' : bucket_array α β n,	v1 u w : list (Σ (a : α), β a),	hl : bkts.as_list = u ++ v1 ++ w,	hfl : bkts'.as_list = u ++ [⟨a, b⟩] ++ w,	veq : v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩]	⊢ ⟨a', b'⟩ ∈ u ++ [⟨a, b⟩] ++ w ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ u ++ v1 ++ w)
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	bkts' : bucket_array α β n,	v1 u w : list (Σ (a : α), β a),	hl : bkts.as_list = u ++ v1 ++ w,	hfl : bkts'.as_list = u ++ [⟨a, b⟩] ++ w,	veq : v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩],	h : a = a'	⊢ ⟨a', b'⟩ ∈ u ++ [⟨a, b⟩] ++ w ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ u ++ v1 ++ w)
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	bkts' : bucket_array α β n,	v1 u w : list (Σ (a : α), β a),	hl : bkts.as_list = u ++ v1 ++ w,	hfl : bkts'.as_list = u ++ [⟨a, b⟩] ++ w,	veq : v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩],	b' : β a	⊢ ⟨a, b'⟩ ∈ u ++ [⟨a, b⟩] ++ w ↔ ite (a = a) (b == b') (⟨a, b'⟩ ∈ u ++ v1 ++ w)
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	bkts' : bucket_array α β n,	v1 u w : list (Σ (a : α), β a),	hl : bkts.as_list = u ++ v1 ++ w,	hfl : bkts'.as_list = u ++ [⟨a, b⟩] ++ w,	veq : v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩],	b' : β a,	this : b = b' ∨ ⟨a, b'⟩ ∈ u ∨ ⟨a, b'⟩ ∈ w ↔ b = b'	⊢ ⟨a, b'⟩ ∈ u ++ [⟨a, b⟩] ++ w ↔ ite (a = a) (b == b') (⟨a, b'⟩ ∈ u ++ v1 ++ w)		α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	bkts' : bucket_array α β n,	v1 u w : list (Σ (a : α), β a),	hl : bkts.as_list = u ++ v1 ++ w,	hfl : bkts'.as_list = u ++ [⟨a, b⟩] ++ w,	veq : v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩],	b' : β a	⊢ b = b' ∨ ⟨a, b'⟩ ∈ u ∨ ⟨a, b'⟩ ∈ w ↔ b = b'
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	bkts' : bucket_array α β n,	v1 u w : list (Σ (a : α), β a),	hl : bkts.as_list = u ++ v1 ++ w,	hfl : bkts'.as_list = u ++ [⟨a, b⟩] ++ w,	veq : v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩],	b' : β a,	this : b = b' ∨ ⟨a, b'⟩ ∈ u ∨ ⟨a, b'⟩ ∈ w ↔ b = b'	⊢ ⟨a, b'⟩ ∈ u ++ [⟨a, b⟩] ++ w ↔ ite (a = a) (b == b') (⟨a, b'⟩ ∈ u ++ v1 ++ w)
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	bkts' : bucket_array α β n,	v1 u w : list (Σ (a : α), β a),	hl : bkts.as_list = u ++ v1 ++ w,	hfl : bkts'.as_list = u ++ [⟨a, b⟩] ++ w,	veq : v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩],	b' : β a	⊢ b = b' ∨ ⟨a, b'⟩ ∈ u ∨ ⟨a, b'⟩ ∈ w ↔ b = b'
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	bkts' : bucket_array α β n,	v1 u w : list (Σ (a : α), β a),	hl : bkts.as_list = u ++ v1 ++ w,	hfl : bkts'.as_list = u ++ [⟨a, b⟩] ++ w,	veq : v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩],	b' : β a	⊢ ⟨a, b'⟩ ∉ u ∧ ⟨a, b'⟩ ∉ w
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	bkts' : bucket_array α β n,	u w : list (Σ (a : α), β a),	hfl : bkts'.as_list = u ++ [⟨a, b⟩] ++ w,	b' : β a,	Hnc : ¬↥(hash_map.contains_aux a bkt),	hl : bkts.as_list = u ++ list.nil ++ w	⊢ ⟨a, b'⟩ ∉ u ∧ ⟨a, b'⟩ ∉ w
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	bkts' : bucket_array α β n,	u w : list (Σ (a : α), β a),	hfl : bkts'.as_list = u ++ [⟨a, b⟩] ++ w,	b' : β a,	Hnc : ¬↥(hash_map.contains_aux a bkt),	hl : bkts.as_list = u ++ list.nil ++ w,	na : (∀ (x : β a), ⟨a, x⟩ ∉ u) ∧ ∀ (x : β a), ⟨a, x⟩ ∉ w	⊢ ⟨a, b'⟩ ∉ u ∧ ⟨a, b'⟩ ∉ w
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	bkts' : bucket_array α β n,	u w : list (Σ (a : α), β a),	hfl : bkts'.as_list = u ++ [⟨a, b⟩] ++ w,	b' : β a,	Hnc : ¬↥(hash_map.contains_aux a bkt),	hl : bkts.as_list = u ++ list.nil ++ w	⊢ ⟨a, b'⟩ ∉ u ∧ ⟨a, b'⟩ ∉ w		α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	bkts' : bucket_array α β n,	u w : list (Σ (a : α), β a),	hfl : bkts'.as_list = u ++ [⟨a, b⟩] ++ w,	b' b'' : β a,	hl : bkts.as_list = u ++ [⟨a, b''⟩] ++ w	⊢ ⟨a, b'⟩ ∉ u ∧ ⟨a, b'⟩ ∉ w
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	bkts' : bucket_array α β n,	u w : list (Σ (a : α), β a),	hfl : bkts'.as_list = u ++ [⟨a, b⟩] ++ w,	b' : β a,	Hnc : ¬↥(hash_map.contains_aux a bkt),	hl : bkts.as_list = u ++ list.nil ++ w,	na : a ∉ list.map sigma.fst bkts.as_list	⊢ ⟨a, b'⟩ ∉ u ∧ ⟨a, b'⟩ ∉ w
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	bkts' : bucket_array α β n,	u w : list (Σ (a : α), β a),	hfl : bkts'.as_list = u ++ [⟨a, b⟩] ++ w,	b' b'' : β a,	hl : bkts.as_list = u ++ [⟨a, b''⟩] ++ w	⊢ ⟨a, b'⟩ ∉ u ∧ ⟨a, b'⟩ ∉ w
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	bkts' : bucket_array α β n,	u w : list (Σ (a : α), β a),	hfl : bkts'.as_list = u ++ [⟨a, b⟩] ++ w,	b' b'' : β a,	hl : bkts.as_list = u ++ [⟨a, b''⟩] ++ w,	nd' : (list.map sigma.fst u).nodup ∧ ((∀ (x : β a), ⟨a, x⟩ ∉ w) ∧ (list.map sigma.fst w).nodup) ∧ (∀ (x : β a), ⟨a, x⟩ ∉ u) ∧ (list.map sigma.fst u).disjoint (list.map sigma.fst w)	⊢ ⟨a, b'⟩ ∉ u ∧ ⟨a, b'⟩ ∉ w
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	bkts' : bucket_array α β n,	v1 u w : list (Σ (a : α), β a),	hl : bkts.as_list = u ++ v1 ++ w,	hfl : bkts'.as_list = u ++ [⟨a, b⟩] ++ w,	veq : v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩],	h : a = a'	⊢ ⟨a', b'⟩ ∈ u ++ [⟨a, b⟩] ++ w ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ u ++ v1 ++ w)		α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	bkts' : bucket_array α β n,	v1 u w : list (Σ (a : α), β a),	hl : bkts.as_list = u ++ v1 ++ w,	hfl : bkts'.as_list = u ++ [⟨a, b⟩] ++ w,	veq : v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩],	h : ¬a = a'	⊢ ⟨a', b'⟩ ∈ u ++ [⟨a, b⟩] ++ w ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ u ++ v1 ++ w)
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	bkts' : bucket_array α β n,	u w : list (Σ (a : α), β a),	hfl : bkts'.as_list = u ++ [⟨a, b⟩] ++ w,	b' b'' : β a,	hl : bkts.as_list = u ++ [⟨a, b''⟩] ++ w,	nd' : (list.map sigma.fst bkts.as_list).nodup	⊢ ⟨a, b'⟩ ∉ u ∧ ⟨a, b'⟩ ∉ w
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	bkts' : bucket_array α β n,	v1 u w : list (Σ (a : α), β a),	hl : bkts.as_list = u ++ v1 ++ w,	hfl : bkts'.as_list = u ++ [⟨a, b⟩] ++ w,	veq : v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩],	h : ¬a = a',	this : ⟨a', b'⟩ ∉ v1	⊢ ⟨a', b'⟩ ∈ u ++ [⟨a, b⟩] ++ w ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ u ++ v1 ++ w)
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	bkts' : bucket_array α β n,	v1 u w : list (Σ (a : α), β a),	hl : bkts.as_list = u ++ v1 ++ w,	hfl : bkts'.as_list = u ++ [⟨a, b⟩] ++ w,	veq : v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩],	h : ¬a = a',	this : ⟨a', b'⟩ ∉ v1	⊢ ⟨a', b'⟩ ∈ u ++ [⟨a, b⟩] ++ w ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ u ++ v1 ++ w)		α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	bkts' : bucket_array α β n,	v1 u w : list (Σ (a : α), β a),	hl : bkts.as_list = u ++ v1 ++ w,	hfl : bkts'.as_list = u ++ [⟨a, b⟩] ++ w,	veq : v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩],	h : ¬a = a'	⊢ ⟨a', b'⟩ ∉ v1
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	bkts' : bucket_array α β n,	v1 u w : list (Σ (a : α), β a),	hl : bkts.as_list = u ++ v1 ++ w,	hfl : bkts'.as_list = u ++ [⟨a, b⟩] ++ w,	veq : v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩],	h : ¬a = a'	⊢ ⟨a', b'⟩ ∈ u ++ [⟨a, b⟩] ++ w ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ u ++ v1 ++ w)
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	bkts' : bucket_array α β n,	v1 u w : list (Σ (a : α), β a),	hl : bkts.as_list = u ++ v1 ++ w,	hfl : bkts'.as_list = u ++ [⟨a, b⟩] ++ w,	veq : v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩],	h : ¬a = a'	⊢ ⟨a', b'⟩ ∉ v1
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	bkts' : bucket_array α β n,	u w : list (Σ (a : α), β a),	hfl : bkts'.as_list = u ++ [⟨a, b⟩] ++ w,	h : ¬a = a',	Hnc : ¬↥(hash_map.contains_aux a bkt),	hl : bkts.as_list = u ++ list.nil ++ w	⊢ ⟨a', b'⟩ ∉ list.nil
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	bkts' : bucket_array α β n,	u w : list (Σ (a : α), β a),	hfl : bkts'.as_list = u ++ [⟨a, b⟩] ++ w,	h : ¬a = a',	b'' : β a,	hl : bkts.as_list = u ++ [⟨a, b''⟩] ++ w	⊢ ⟨a', b'⟩ ∉ [⟨a, b''⟩]
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup	⊢ ∀ (bkts' : bucket_array α β n) (v1 u w : list (Σ (a : α), β a)), bkts.as_list = u ++ v1 ++ w → bkts'.as_list = u ++ [⟨a, b⟩] ++ w → (v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩]) → (⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list))		α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	lem : ∀ (bkts' : bucket_array α β n) (v1 u w : list (Σ (a : α), β a)), bkts.as_list = u ++ v1 ++ w → bkts'.as_list = u ++ [⟨a, b⟩] ++ w → (v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩]) → (⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list))	⊢ ⟨a', b'⟩ ∈ ({hash_fn := hash_fn, size := size, nbuckets := n, buckets := bkts, is_valid := v}.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ {hash_fn := hash_fn, size := size, nbuckets := n, buckets := bkts, is_valid := v}.entries)
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	bkts' : bucket_array α β n,	v1 u w : list (Σ (a : α), β a),	hl : bkts.as_list = u ++ v1 ++ w,	hfl : bkts'.as_list = u ++ [⟨a, b⟩] ++ w,	veq : v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩],	h : ¬a = a'	⊢ ⟨a', b'⟩ ∉ v1
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	lem : ∀ (bkts' : bucket_array α β n) (v1 u w : list (Σ (a : α), β a)), bkts.as_list = u ++ v1 ++ w → bkts'.as_list = u ++ [⟨a, b⟩] ++ w → (v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩]) → (⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list))	⊢ ⟨a', b'⟩ ∈ ({hash_fn := hash_fn, size := size, nbuckets := n, buckets := bkts, is_valid := v}.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ {hash_fn := hash_fn, size := size, nbuckets := n, buckets := bkts, is_valid := v}.entries)
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	lem : ∀ (bkts' : bucket_array α β n) (v1 u w : list (Σ (a : α), β a)), bkts.as_list = u ++ v1 ++ w → bkts'.as_list = u ++ [⟨a, b⟩] ++ w → (v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩]) → (⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list)),	Hc : ↥(hash_map.contains_aux a bkt)	⊢ ⟨a', b'⟩ ∈ ({hash_fn := hash_fn, size := size, nbuckets := n, buckets := bkts, is_valid := v}.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ {hash_fn := hash_fn, size := size, nbuckets := n, buckets := bkts, is_valid := v}.entries)
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	lem : ∀ (bkts' : bucket_array α β n) (v1 u w : list (Σ (a : α), β a)), bkts.as_list = u ++ v1 ++ w → bkts'.as_list = u ++ [⟨a, b⟩] ++ w → (v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩]) → (⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list)),	Hc : ↥(hash_map.contains_aux a bkt),	u' w' : list (Σ (a : α), (λ (a : α), β a) a),	b'' : β a,	hl' : array.read bkts (hash_map.mk_idx n (hash_fn a)) = u' ++ [⟨a, b''⟩] ++ w',	hfl' : hash_map.replace_aux a b (array.read bkts (hash_map.mk_idx n (hash_fn a))) = u' ++ [⟨a, b⟩] ++ w'	⊢ ⟨a', b'⟩ ∈ ({hash_fn := hash_fn, size := size, nbuckets := n, buckets := bkts, is_valid := v}.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ {hash_fn := hash_fn, size := size, nbuckets := n, buckets := bkts, is_valid := v}.entries)
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	lem : ∀ (bkts' : bucket_array α β n) (v1 u w : list (Σ (a : α), β a)), bkts.as_list = u ++ v1 ++ w → bkts'.as_list = u ++ [⟨a, b⟩] ++ w → (v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩]) → (⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list)),	Hc : ↥(hash_map.contains_aux a bkt),	u' w' : list (Σ (a : α), (λ (a : α), β a) a),	b'' : β a,	hl' : array.read bkts (hash_map.mk_idx n (hash_fn a)) = u' ++ [⟨a, b''⟩] ++ w',	hfl' : hash_map.replace_aux a b (array.read bkts (hash_map.mk_idx n (hash_fn a))) = u' ++ [⟨a, b⟩] ++ w',	u w : list (Σ (a : α), (λ (a : α), (λ (a : α), β a) a) a),	hl : bkts.as_list = u ++ [⟨a, b''⟩] ++ w,	hfl : bkts'.as_list = u ++ [⟨a, b⟩] ++ w	⊢ ⟨a', b'⟩ ∈ ({hash_fn := hash_fn, size := size, nbuckets := n, buckets := bkts, is_valid := v}.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ {hash_fn := hash_fn, size := size, nbuckets := n, buckets := bkts, is_valid := v}.entries)
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	lem : ∀ (bkts' : bucket_array α β n) (v1 u w : list (Σ (a : α), β a)), bkts.as_list = u ++ v1 ++ w → bkts'.as_list = u ++ [⟨a, b⟩] ++ w → (v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩]) → (⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list)),	Hc : ↥(hash_map.contains_aux a bkt)	⊢ ⟨a', b'⟩ ∈ ({hash_fn := hash_fn, size := size, nbuckets := n, buckets := bkts, is_valid := v}.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ {hash_fn := hash_fn, size := size, nbuckets := n, buckets := bkts, is_valid := v}.entries)		α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	lem : ∀ (bkts' : bucket_array α β n) (v1 u w : list (Σ (a : α), β a)), bkts.as_list = u ++ v1 ++ w → bkts'.as_list = u ++ [⟨a, b⟩] ++ w → (v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩]) → (⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list)),	Hc : ¬↥(hash_map.contains_aux a bkt)	⊢ ⟨a', b'⟩ ∈ ({hash_fn := hash_fn, size := size, nbuckets := n, buckets := bkts, is_valid := v}.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ {hash_fn := hash_fn, size := size, nbuckets := n, buckets := bkts, is_valid := v}.entries)
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	lem : ∀ (bkts' : bucket_array α β n) (v1 u w : list (Σ (a : α), β a)), bkts.as_list = u ++ v1 ++ w → bkts'.as_list = u ++ [⟨a, b⟩] ++ w → (v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩]) → (⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list)),	Hc : ¬↥(hash_map.contains_aux a bkt)	⊢ ⟨a', b'⟩ ∈ ({hash_fn := hash_fn, size := size, nbuckets := n, buckets := bkts, is_valid := v}.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ {hash_fn := hash_fn, size := size, nbuckets := n, buckets := bkts, is_valid := v}.entries)
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	lem : ∀ (bkts' : bucket_array α β n) (v1 u w : list (Σ (a : α), β a)), bkts.as_list = u ++ v1 ++ w → bkts'.as_list = u ++ [⟨a, b⟩] ++ w → (v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩]) → (⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list)),	Hc : ¬↥(hash_map.contains_aux a bkt),	size' : ℕ := size + 1	⊢ ⟨a', b'⟩ ∈ ({hash_fn := hash_fn, size := size, nbuckets := n, buckets := bkts, is_valid := v}.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ {hash_fn := hash_fn, size := size, nbuckets := n, buckets := bkts, is_valid := v}.entries)
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	lem : ∀ (bkts' : bucket_array α β n) (v1 u w : list (Σ (a : α), β a)), bkts.as_list = u ++ v1 ++ w → bkts'.as_list = u ++ [⟨a, b⟩] ++ w → (v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩]) → (⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list)),	Hc : ¬↥(hash_map.contains_aux a bkt),	size' : ℕ := size + 1,	bkts' : bucket_array α β n := bucket_array.modify hash_fn bkts a (λ (l : list (Σ (a : α), β a)), ⟨a, b⟩ :: l)	⊢ ⟨a', b'⟩ ∈ ({hash_fn := hash_fn, size := size, nbuckets := n, buckets := bkts, is_valid := v}.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ {hash_fn := hash_fn, size := size, nbuckets := n, buckets := bkts, is_valid := v}.entries)
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	lem : ∀ (bkts' : bucket_array α β n) (v1 u w : list (Σ (a : α), β a)), bkts.as_list = u ++ v1 ++ w → bkts'.as_list = u ++ [⟨a, b⟩] ++ w → (v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩]) → (⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list)),	Hc : ¬↥(hash_map.contains_aux a bkt),	size' : ℕ := size + 1,	bkts' : bucket_array α β n := bucket_array.modify hash_fn bkts a (λ (l : list (Σ (a : α), β a)), ⟨a, b⟩ :: l),	mi : ⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list)	⊢ ⟨a', b'⟩ ∈ ({hash_fn := hash_fn, size := size, nbuckets := n, buckets := bkts, is_valid := v}.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ {hash_fn := hash_fn, size := size, nbuckets := n, buckets := bkts, is_valid := v}.entries)
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	lem : ∀ (bkts' : bucket_array α β n) (v1 u w : list (Σ (a : α), β a)), bkts.as_list = u ++ v1 ++ w → bkts'.as_list = u ++ [⟨a, b⟩] ++ w → (v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩]) → (⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list)),	Hc : ¬↥(hash_map.contains_aux a bkt),	size' : ℕ := size + 1,	bkts' : bucket_array α β n := bucket_array.modify hash_fn bkts a (λ (l : list (Σ (a : α), β a)), ⟨a, b⟩ :: l),	mi : ⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list)	⊢ ⟨a', b'⟩ ∈ (ite (size + 1 ≤ ↑n) {hash_fn := hash_fn, size := size + 1, nbuckets := n, buckets := bucket_array.modify hash_fn bkts a (list.cons ⟨a, b⟩), is_valid := _} {hash_fn := hash_fn, size := size + 1, nbuckets := ⟨↑n * 2, _⟩, buckets := (bucket_array.modify hash_fn bkts a (list.cons ⟨a, b⟩)).foldl (mk_array ↑⟨↑n * 2, _⟩ list.nil) (hash_map.reinsert_aux hash_fn), is_valid := _}).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ {hash_fn := hash_fn, size := size, nbuckets := n, buckets := bkts, is_valid := v}.entries)
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	lem : ∀ (bkts' : bucket_array α β n) (v1 u w : list (Σ (a : α), β a)), bkts.as_list = u ++ v1 ++ w → bkts'.as_list = u ++ [⟨a, b⟩] ++ w → (v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩]) → (⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list)),	Hc : ¬↥(hash_map.contains_aux a bkt),	size' : ℕ := size + 1,	bkts' : bucket_array α β n := bucket_array.modify hash_fn bkts a (λ (l : list (Σ (a : α), β a)), ⟨a, b⟩ :: l),	mi : ⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list),	h : size' ≤ ↑n	⊢ ⟨a', b'⟩ ∈ (ite (size + 1 ≤ ↑n) {hash_fn := hash_fn, size := size + 1, nbuckets := n, buckets := bucket_array.modify hash_fn bkts a (list.cons ⟨a, b⟩), is_valid := _} {hash_fn := hash_fn, size := size + 1, nbuckets := ⟨↑n * 2, _⟩, buckets := (bucket_array.modify hash_fn bkts a (list.cons ⟨a, b⟩)).foldl (mk_array ↑⟨↑n * 2, _⟩ list.nil) (hash_map.reinsert_aux hash_fn), is_valid := _}).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ {hash_fn := hash_fn, size := size, nbuckets := n, buckets := bkts, is_valid := v}.entries)		α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	lem : ∀ (bkts' : bucket_array α β n) (v1 u w : list (Σ (a : α), β a)), bkts.as_list = u ++ v1 ++ w → bkts'.as_list = u ++ [⟨a, b⟩] ++ w → (v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩]) → (⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list)),	Hc : ¬↥(hash_map.contains_aux a bkt),	size' : ℕ := size + 1,	bkts' : bucket_array α β n := bucket_array.modify hash_fn bkts a (λ (l : list (Σ (a : α), β a)), ⟨a, b⟩ :: l),	mi : ⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list),	h : ¬size' ≤ ↑n	⊢ ⟨a', b'⟩ ∈ (ite (size + 1 ≤ ↑n) {hash_fn := hash_fn, size := size + 1, nbuckets := n, buckets := bucket_array.modify hash_fn bkts a (list.cons ⟨a, b⟩), is_valid := _} {hash_fn := hash_fn, size := size + 1, nbuckets := ⟨↑n * 2, _⟩, buckets := (bucket_array.modify hash_fn bkts a (list.cons ⟨a, b⟩)).foldl (mk_array ↑⟨↑n * 2, _⟩ list.nil) (hash_map.reinsert_aux hash_fn), is_valid := _}).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ {hash_fn := hash_fn, size := size, nbuckets := n, buckets := bkts, is_valid := v}.entries)
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	lem : ∀ (bkts' : bucket_array α β n) (v1 u w : list (Σ (a : α), β a)), bkts.as_list = u ++ v1 ++ w → bkts'.as_list = u ++ [⟨a, b⟩] ++ w → (v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩]) → (⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list)),	Hc : ¬↥(hash_map.contains_aux a bkt),	size' : ℕ := size + 1,	bkts' : bucket_array α β n := bucket_array.modify hash_fn bkts a (λ (l : list (Σ (a : α), β a)), ⟨a, b⟩ :: l),	mi : ⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list),	h : size' ≤ ↑n	⊢ ⟨a', b'⟩ ∈ (ite (size + 1 ≤ ↑n) {hash_fn := hash_fn, size := size + 1, nbuckets := n, buckets := bucket_array.modify hash_fn bkts a (list.cons ⟨a, b⟩), is_valid := _} {hash_fn := hash_fn, size := size + 1, nbuckets := ⟨↑n * 2, _⟩, buckets := (bucket_array.modify hash_fn bkts a (list.cons ⟨a, b⟩)).foldl (mk_array ↑⟨↑n * 2, _⟩ list.nil) (hash_map.reinsert_aux hash_fn), is_valid := _}).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ {hash_fn := hash_fn, size := size, nbuckets := n, buckets := bkts, is_valid := v}.entries)
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	lem : ∀ (bkts' : bucket_array α β n) (v1 u w : list (Σ (a : α), β a)), bkts.as_list = u ++ v1 ++ w → bkts'.as_list = u ++ [⟨a, b⟩] ++ w → (v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩]) → (⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list)),	Hc : ¬↥(hash_map.contains_aux a bkt),	size' : ℕ := size + 1,	bkts' : bucket_array α β n := bucket_array.modify hash_fn bkts a (λ (l : list (Σ (a : α), β a)), ⟨a, b⟩ :: l),	mi : ⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list),	h : ¬size' ≤ ↑n	⊢ ⟨a', b'⟩ ∈ (ite (size + 1 ≤ ↑n) {hash_fn := hash_fn, size := size + 1, nbuckets := n, buckets := bucket_array.modify hash_fn bkts a (list.cons ⟨a, b⟩), is_valid := _} {hash_fn := hash_fn, size := size + 1, nbuckets := ⟨↑n * 2, _⟩, buckets := (bucket_array.modify hash_fn bkts a (list.cons ⟨a, b⟩)).foldl (mk_array ↑⟨↑n * 2, _⟩ list.nil) (hash_map.reinsert_aux hash_fn), is_valid := _}).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ {hash_fn := hash_fn, size := size, nbuckets := n, buckets := bkts, is_valid := v}.entries)
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	lem : ∀ (bkts' : bucket_array α β n) (v1 u w : list (Σ (a : α), β a)), bkts.as_list = u ++ v1 ++ w → bkts'.as_list = u ++ [⟨a, b⟩] ++ w → (v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩]) → (⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list)),	Hc : ¬↥(hash_map.contains_aux a bkt),	size' : ℕ := size + 1,	bkts' : bucket_array α β n := bucket_array.modify hash_fn bkts a (λ (l : list (Σ (a : α), β a)), ⟨a, b⟩ :: l),	mi : ⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list),	h : ¬size' ≤ ↑n,	n' : ℕ+ := ⟨↑n * 2, _⟩	⊢ ⟨a', b'⟩ ∈ (ite (size + 1 ≤ ↑n) {hash_fn := hash_fn, size := size + 1, nbuckets := n, buckets := bucket_array.modify hash_fn bkts a (list.cons ⟨a, b⟩), is_valid := _} {hash_fn := hash_fn, size := size + 1, nbuckets := ⟨↑n * 2, _⟩, buckets := (bucket_array.modify hash_fn bkts a (list.cons ⟨a, b⟩)).foldl (mk_array ↑⟨↑n * 2, _⟩ list.nil) (hash_map.reinsert_aux hash_fn), is_valid := _}).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ {hash_fn := hash_fn, size := size, nbuckets := n, buckets := bkts, is_valid := v}.entries)
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	lem : ∀ (bkts' : bucket_array α β n) (v1 u w : list (Σ (a : α), β a)), bkts.as_list = u ++ v1 ++ w → bkts'.as_list = u ++ [⟨a, b⟩] ++ w → (v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩]) → (⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list)),	Hc : ¬↥(hash_map.contains_aux a bkt),	size' : ℕ := size + 1,	bkts' : bucket_array α β n := bucket_array.modify hash_fn bkts a (λ (l : list (Σ (a : α), β a)), ⟨a, b⟩ :: l),	mi : ⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list),	h : ¬size' ≤ ↑n,	n' : ℕ+ := ⟨↑n * 2, _⟩,	bkts'' : bucket_array α β n' := bkts'.foldl (mk_array ↑n' list.nil) (hash_map.reinsert_aux hash_fn)	⊢ ⟨a', b'⟩ ∈ (ite (size + 1 ≤ ↑n) {hash_fn := hash_fn, size := size + 1, nbuckets := n, buckets := bucket_array.modify hash_fn bkts a (list.cons ⟨a, b⟩), is_valid := _} {hash_fn := hash_fn, size := size + 1, nbuckets := ⟨↑n * 2, _⟩, buckets := (bucket_array.modify hash_fn bkts a (list.cons ⟨a, b⟩)).foldl (mk_array ↑⟨↑n * 2, _⟩ list.nil) (hash_map.reinsert_aux hash_fn), is_valid := _}).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ {hash_fn := hash_fn, size := size, nbuckets := n, buckets := bkts, is_valid := v}.entries)
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	lem : ∀ (bkts' : bucket_array α β n) (v1 u w : list (Σ (a : α), β a)), bkts.as_list = u ++ v1 ++ w → bkts'.as_list = u ++ [⟨a, b⟩] ++ w → (v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩]) → (⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list)),	Hc : ¬↥(hash_map.contains_aux a bkt),	size' : ℕ := size + 1,	bkts' : bucket_array α β n := bucket_array.modify hash_fn bkts a (λ (l : list (Σ (a : α), β a)), ⟨a, b⟩ :: l),	mi : ⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list),	h : ¬size' ≤ ↑n,	n' : ℕ+ := ⟨↑n * 2, _⟩,	bkts'' : bucket_array α β n' := bkts'.foldl (mk_array ↑n' list.nil) (hash_map.reinsert_aux hash_fn),	this : ⟨a', b'⟩ ∈ bkts''.as_list ↔ ⟨a', b'⟩ ∈ bkts'.as_list.reverse	⊢ ⟨a', b'⟩ ∈ (ite (size + 1 ≤ ↑n) {hash_fn := hash_fn, size := size + 1, nbuckets := n, buckets := bucket_array.modify hash_fn bkts a (list.cons ⟨a, b⟩), is_valid := _} {hash_fn := hash_fn, size := size + 1, nbuckets := ⟨↑n * 2, _⟩, buckets := (bucket_array.modify hash_fn bkts a (list.cons ⟨a, b⟩)).foldl (mk_array ↑⟨↑n * 2, _⟩ list.nil) (hash_map.reinsert_aux hash_fn), is_valid := _}).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ {hash_fn := hash_fn, size := size, nbuckets := n, buckets := bkts, is_valid := v}.entries)		α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	lem : ∀ (bkts' : bucket_array α β n) (v1 u w : list (Σ (a : α), β a)), bkts.as_list = u ++ v1 ++ w → bkts'.as_list = u ++ [⟨a, b⟩] ++ w → (v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩]) → (⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list)),	Hc : ¬↥(hash_map.contains_aux a bkt),	size' : ℕ := size + 1,	bkts' : bucket_array α β n := bucket_array.modify hash_fn bkts a (λ (l : list (Σ (a : α), β a)), ⟨a, b⟩ :: l),	mi : ⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list),	h : ¬size' ≤ ↑n,	n' : ℕ+ := ⟨↑n * 2, _⟩,	bkts'' : bucket_array α β n' := bkts'.foldl (mk_array ↑n' list.nil) (hash_map.reinsert_aux hash_fn)	⊢ ⟨a', b'⟩ ∈ bkts''.as_list ↔ ⟨a', b'⟩ ∈ bkts'.as_list.reverse
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	lem : ∀ (bkts' : bucket_array α β n) (v1 u w : list (Σ (a : α), β a)), bkts.as_list = u ++ v1 ++ w → bkts'.as_list = u ++ [⟨a, b⟩] ++ w → (v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩]) → (⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list)),	Hc : ¬↥(hash_map.contains_aux a bkt),	size' : ℕ := size + 1,	bkts' : bucket_array α β n := bucket_array.modify hash_fn bkts a (λ (l : list (Σ (a : α), β a)), ⟨a, b⟩ :: l),	mi : ⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list),	h : ¬size' ≤ ↑n,	n' : ℕ+ := ⟨↑n * 2, _⟩,	bkts'' : bucket_array α β n' := bkts'.foldl (mk_array ↑n' list.nil) (hash_map.reinsert_aux hash_fn),	this : ⟨a', b'⟩ ∈ bkts''.as_list ↔ ⟨a', b'⟩ ∈ bkts'.as_list.reverse	⊢ ⟨a', b'⟩ ∈ (ite (size + 1 ≤ ↑n) {hash_fn := hash_fn, size := size + 1, nbuckets := n, buckets := bucket_array.modify hash_fn bkts a (list.cons ⟨a, b⟩), is_valid := _} {hash_fn := hash_fn, size := size + 1, nbuckets := ⟨↑n * 2, _⟩, buckets := (bucket_array.modify hash_fn bkts a (list.cons ⟨a, b⟩)).foldl (mk_array ↑⟨↑n * 2, _⟩ list.nil) (hash_map.reinsert_aux hash_fn), is_valid := _}).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ {hash_fn := hash_fn, size := size, nbuckets := n, buckets := bkts, is_valid := v}.entries)
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	lem : ∀ (bkts' : bucket_array α β n) (v1 u w : list (Σ (a : α), β a)), bkts.as_list = u ++ v1 ++ w → bkts'.as_list = u ++ [⟨a, b⟩] ++ w → (v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩]) → (⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list)),	Hc : ¬↥(hash_map.contains_aux a bkt),	size' : ℕ := size + 1,	bkts' : bucket_array α β n := bucket_array.modify hash_fn bkts a (λ (l : list (Σ (a : α), β a)), ⟨a, b⟩ :: l),	mi : ⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list),	h : ¬size' ≤ ↑n,	n' : ℕ+ := ⟨↑n * 2, _⟩,	bkts'' : bucket_array α β n' := bkts'.foldl (mk_array ↑n' list.nil) (hash_map.reinsert_aux hash_fn)	⊢ ⟨a', b'⟩ ∈ bkts''.as_list ↔ ⟨a', b'⟩ ∈ bkts'.as_list.reverse
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	lem : ∀ (bkts' : bucket_array α β n) (v1 u w : list (Σ (a : α), β a)), bkts.as_list = u ++ v1 ++ w → bkts'.as_list = u ++ [⟨a, b⟩] ++ w → (v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩]) → (⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list)),	Hc : ¬↥(hash_map.contains_aux a bkt),	size' : ℕ := size + 1,	bkts' : bucket_array α β n := bucket_array.modify hash_fn bkts a (λ (l : list (Σ (a : α), β a)), ⟨a, b⟩ :: l),	mi : ⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list),	h : ¬size' ≤ ↑n,	n' : ℕ+ := ⟨↑n * 2, _⟩,	bkts'' : bucket_array α β n' := bkts'.foldl (mk_array ↑n' list.nil) (hash_map.reinsert_aux hash_fn)	⊢ ⟨a', b'⟩ ∈ (list.foldr (λ (y : Σ (a : α), β a) (x : bucket_array α β n'), hash_map.reinsert_aux hash_fn x y.fst y.snd) (mk_array ↑n' list.nil) bkts'.as_list.reverse).as_list ↔ ⟨a', b'⟩ ∈ bkts'.as_list.reverse
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	lem : ∀ (bkts' : bucket_array α β n) (v1 u w : list (Σ (a : α), β a)), bkts.as_list = u ++ v1 ++ w → bkts'.as_list = u ++ [⟨a, b⟩] ++ w → (v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩]) → (⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list)),	Hc : ¬↥(hash_map.contains_aux a bkt),	size' : ℕ := size + 1,	bkts' : bucket_array α β n := bucket_array.modify hash_fn bkts a (λ (l : list (Σ (a : α), β a)), ⟨a, b⟩ :: l),	mi : ⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list),	h : ¬size' ≤ ↑n,	n' : ℕ+ := ⟨↑n * 2, _⟩,	bkts'' : bucket_array α β n' := bkts'.foldl (mk_array ↑n' list.nil) (hash_map.reinsert_aux hash_fn)	⊢ ⟨a', b'⟩ ∈ (list.foldr (λ (y : Σ (a : α), β a) (x : bucket_array α β n'), hash_map.reinsert_aux hash_fn x y.fst y.snd) (mk_array ↑n' list.nil) list.nil).as_list ↔ ⟨a', b'⟩ ∈ list.nil		case list.cons	α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	lem : ∀ (bkts' : bucket_array α β n) (v1 u w : list (Σ (a : α), β a)), bkts.as_list = u ++ v1 ++ w → bkts'.as_list = u ++ [⟨a, b⟩] ++ w → (v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩]) → (⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list)),	Hc : ¬↥(hash_map.contains_aux a bkt),	size' : ℕ := size + 1,	bkts' : bucket_array α β n := bucket_array.modify hash_fn bkts a (λ (l : list (Σ (a : α), β a)), ⟨a, b⟩ :: l),	mi : ⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list),	h : ¬size' ≤ ↑n,	n' : ℕ+ := ⟨↑n * 2, _⟩,	bkts'' : bucket_array α β n' := bkts'.foldl (mk_array ↑n' list.nil) (hash_map.reinsert_aux hash_fn),	a : Σ (a : α), β a,	l : list (Σ (a : α), β a),	IH : ⟨a', b'⟩ ∈ (list.foldr (λ (y : Σ (a : α), β a) (x : bucket_array α β n'), hash_map.reinsert_aux hash_fn x y.fst y.snd) (mk_array ↑n' list.nil) l).as_list ↔ ⟨a', b'⟩ ∈ l	⊢ ⟨a', b'⟩ ∈ (list.foldr (λ (y : Σ (a : α), β a) (x : bucket_array α β n'), hash_map.reinsert_aux hash_fn x y.fst y.snd) (mk_array ↑n' list.nil) (a :: l)).as_list ↔ ⟨a', b'⟩ ∈ a :: l
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	lem : ∀ (bkts' : bucket_array α β n) (v1 u w : list (Σ (a : α), β a)), bkts.as_list = u ++ v1 ++ w → bkts'.as_list = u ++ [⟨a, b⟩] ++ w → (v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩]) → (⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list)),	Hc : ¬↥(hash_map.contains_aux a bkt),	size' : ℕ := size + 1,	bkts' : bucket_array α β n := bucket_array.modify hash_fn bkts a (λ (l : list (Σ (a : α), β a)), ⟨a, b⟩ :: l),	mi : ⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list),	h : ¬size' ≤ ↑n,	n' : ℕ+ := ⟨↑n * 2, _⟩,	bkts'' : bucket_array α β n' := bkts'.foldl (mk_array ↑n' list.nil) (hash_map.reinsert_aux hash_fn)	⊢ ⟨a', b'⟩ ∈ (list.foldr (λ (y : Σ (a : α), β a) (x : bucket_array α β n'), hash_map.reinsert_aux hash_fn x y.fst y.snd) (mk_array ↑n' list.nil) list.nil).as_list ↔ ⟨a', b'⟩ ∈ list.nil
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	lem : ∀ (bkts' : bucket_array α β n) (v1 u w : list (Σ (a : α), β a)), bkts.as_list = u ++ v1 ++ w → bkts'.as_list = u ++ [⟨a, b⟩] ++ w → (v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩]) → (⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list)),	Hc : ¬↥(hash_map.contains_aux a bkt),	size' : ℕ := size + 1,	bkts' : bucket_array α β n := bucket_array.modify hash_fn bkts a (λ (l : list (Σ (a : α), β a)), ⟨a, b⟩ :: l),	mi : ⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list),	h : ¬size' ≤ ↑n,	n' : ℕ+ := ⟨↑n * 2, _⟩,	bkts'' : bucket_array α β n' := bkts'.foldl (mk_array ↑n' list.nil) (hash_map.reinsert_aux hash_fn),	a : Σ (a : α), β a,	l : list (Σ (a : α), β a),	IH : ⟨a', b'⟩ ∈ (list.foldr (λ (y : Σ (a : α), β a) (x : bucket_array α β n'), hash_map.reinsert_aux hash_fn x y.fst y.snd) (mk_array ↑n' list.nil) l).as_list ↔ ⟨a', b'⟩ ∈ l	⊢ ⟨a', b'⟩ ∈ (list.foldr (λ (y : Σ (a : α), β a) (x : bucket_array α β n'), hash_map.reinsert_aux hash_fn x y.fst y.snd) (mk_array ↑n' list.nil) (a :: l)).as_list ↔ ⟨a', b'⟩ ∈ a :: l
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	lem : ∀ (bkts' : bucket_array α β n) (v1 u w : list (Σ (a : α), β a)), bkts.as_list = u ++ v1 ++ w → bkts'.as_list = u ++ [⟨a, b⟩] ++ w → (v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩]) → (⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list)),	Hc : ¬↥(hash_map.contains_aux a bkt),	size' : ℕ := size + 1,	bkts' : bucket_array α β n := bucket_array.modify hash_fn bkts a (λ (l : list (Σ (a : α), β a)), ⟨a, b⟩ :: l),	mi : ⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list),	h : ¬size' ≤ ↑n,	n' : ℕ+ := ⟨↑n * 2, _⟩,	bkts'' : bucket_array α β n' := bkts'.foldl (mk_array ↑n' list.nil) (hash_map.reinsert_aux hash_fn),	l : list (Σ (a : α), β a),	IH : ⟨a', b'⟩ ∈ (list.foldr (λ (y : Σ (a : α), β a) (x : bucket_array α β n'), hash_map.reinsert_aux hash_fn x y.fst y.snd) (mk_array ↑n' list.nil) l).as_list ↔ ⟨a', b'⟩ ∈ l,	a'' : α,	b'' : β a''	⊢ ⟨a', b'⟩ ∈ (list.foldr (λ (y : Σ (a : α), β a) (x : bucket_array α β n'), hash_map.reinsert_aux hash_fn x y.fst y.snd) (mk_array ↑n' list.nil) (⟨a'', b''⟩ :: l)).as_list ↔ ⟨a', b'⟩ ∈ ⟨a'', b''⟩ :: l
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	lem : ∀ (bkts' : bucket_array α β n) (v1 u w : list (Σ (a : α), β a)), bkts.as_list = u ++ v1 ++ w → bkts'.as_list = u ++ [⟨a, b⟩] ++ w → (v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩]) → (⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list)),	Hc : ¬↥(hash_map.contains_aux a bkt),	size' : ℕ := size + 1,	bkts' : bucket_array α β n := bucket_array.modify hash_fn bkts a (λ (l : list (Σ (a : α), β a)), ⟨a, b⟩ :: l),	mi : ⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list),	h : ¬size' ≤ ↑n,	n' : ℕ+ := ⟨↑n * 2, _⟩,	bkts'' : bucket_array α β n' := bkts'.foldl (mk_array ↑n' list.nil) (hash_map.reinsert_aux hash_fn),	l : list (Σ (a : α), β a),	IH : ⟨a', b'⟩ ∈ (list.foldr (λ (y : Σ (a : α), β a) (x : bucket_array α β n'), hash_map.reinsert_aux hash_fn x y.fst y.snd) (mk_array ↑n' list.nil) l).as_list ↔ ⟨a', b'⟩ ∈ l,	a'' : α,	b'' : β a'',	B : bucket_array α β n' := list.foldr (λ (y : sigma β) (x : bucket_array α β n'), hash_map.reinsert_aux hash_fn x y.fst y.snd) (mk_array ↑n' list.nil) l	⊢ ⟨a', b'⟩ ∈ (list.foldr (λ (y : Σ (a : α), β a) (x : bucket_array α β n'), hash_map.reinsert_aux hash_fn x y.fst y.snd) (mk_array ↑n' list.nil) (⟨a'', b''⟩ :: l)).as_list ↔ ⟨a', b'⟩ ∈ ⟨a'', b''⟩ :: l
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	lem : ∀ (bkts' : bucket_array α β n) (v1 u w : list (Σ (a : α), β a)), bkts.as_list = u ++ v1 ++ w → bkts'.as_list = u ++ [⟨a, b⟩] ++ w → (v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩]) → (⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list)),	Hc : ¬↥(hash_map.contains_aux a bkt),	size' : ℕ := size + 1,	bkts' : bucket_array α β n := bucket_array.modify hash_fn bkts a (λ (l : list (Σ (a : α), β a)), ⟨a, b⟩ :: l),	mi : ⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list),	h : ¬size' ≤ ↑n,	n' : ℕ+ := ⟨↑n * 2, _⟩,	bkts'' : bucket_array α β n' := bkts'.foldl (mk_array ↑n' list.nil) (hash_map.reinsert_aux hash_fn),	l : list (Σ (a : α), β a),	IH : ⟨a', b'⟩ ∈ (list.foldr (λ (y : Σ (a : α), β a) (x : bucket_array α β n'), hash_map.reinsert_aux hash_fn x y.fst y.snd) (mk_array ↑n' list.nil) l).as_list ↔ ⟨a', b'⟩ ∈ l,	a'' : α,	b'' : β a'',	B : bucket_array α β n' := list.foldr (λ (y : sigma β) (x : bucket_array α β n'), hash_map.reinsert_aux hash_fn x y.fst y.snd) (mk_array ↑n' list.nil) l,	u w : list (Σ (a : α), (λ (a'' : α), β a'') a),	hl : ?m_2.as_list = u ++ list.nil ++ w,	hfl : _private.2525329411.bkts'.as_list = u ++ [⟨a'', b''⟩] ++ w	⊢ ⟨a', b'⟩ ∈ (list.foldr (λ (y : Σ (a : α), β a) (x : bucket_array α β n'), hash_map.reinsert_aux hash_fn x y.fst y.snd) (mk_array ↑n' list.nil) (⟨a'', b''⟩ :: l)).as_list ↔ ⟨a', b'⟩ ∈ ⟨a'', b''⟩ :: l		α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	lem : ∀ (bkts' : bucket_array α β n) (v1 u w : list (Σ (a : α), β a)), bkts.as_list = u ++ v1 ++ w → bkts'.as_list = u ++ [⟨a, b⟩] ++ w → (v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩]) → (⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list)),	Hc : ¬↥(hash_map.contains_aux a bkt),	size' : ℕ := size + 1,	bkts' : bucket_array α β n := bucket_array.modify hash_fn bkts a (λ (l : list (Σ (a : α), β a)), ⟨a, b⟩ :: l),	mi : ⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list),	h : ¬size' ≤ ↑n,	n' : ℕ+ := ⟨↑n * 2, _⟩,	bkts'' : bucket_array α β n' := bkts'.foldl (mk_array ↑n' list.nil) (hash_map.reinsert_aux hash_fn),	l : list (Σ (a : α), β a),	IH : ⟨a', b'⟩ ∈ (list.foldr (λ (y : Σ (a : α), β a) (x : bucket_array α β n'), hash_map.reinsert_aux hash_fn x y.fst y.snd) (mk_array ↑n' list.nil) l).as_list ↔ ⟨a', b'⟩ ∈ l,	a'' : α,	b'' : β a'',	B : bucket_array α β n' := list.foldr (λ (y : sigma β) (x : bucket_array α β n'), hash_map.reinsert_aux hash_fn x y.fst y.snd) (mk_array ↑n' list.nil) l	⊢ ℕ+		α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	lem : ∀ (bkts' : bucket_array α β n) (v1 u w : list (Σ (a : α), β a)), bkts.as_list = u ++ v1 ++ w → bkts'.as_list = u ++ [⟨a, b⟩] ++ w → (v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩]) → (⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list)),	Hc : ¬↥(hash_map.contains_aux a bkt),	size' : ℕ := size + 1,	bkts' : bucket_array α β n := bucket_array.modify hash_fn bkts a (λ (l : list (Σ (a : α), β a)), ⟨a, b⟩ :: l),	mi : ⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list),	h : ¬size' ≤ ↑n,	n' : ℕ+ := ⟨↑n * 2, _⟩,	bkts'' : bucket_array α β n' := bkts'.foldl (mk_array ↑n' list.nil) (hash_map.reinsert_aux hash_fn),	l : list (Σ (a : α), β a),	IH : ⟨a', b'⟩ ∈ (list.foldr (λ (y : Σ (a : α), β a) (x : bucket_array α β n'), hash_map.reinsert_aux hash_fn x y.fst y.snd) (mk_array ↑n' list.nil) l).as_list ↔ ⟨a', b'⟩ ∈ l,	a'' : α,	b'' : β a'',	B : bucket_array α β n' := list.foldr (λ (y : sigma β) (x : bucket_array α β n'), hash_map.reinsert_aux hash_fn x y.fst y.snd) (mk_array ↑n' list.nil) l	⊢ bucket_array α (λ (a'' : α), β a'') ?m_1		α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	mem_insert : ∀ (m : hash_map α β) (a : α) (b : β a) (a' : α) (b' : β a'), ⟨a', b'⟩ ∈ (m.insert a b).entries ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ m.entries),	hash_fn : α → ℕ,	size : ℕ,	n : ℕ+,	bkts : bucket_array α β n,	v : hash_map.valid hash_fn bkts size,	a : α,	b : β a,	a' : α,	b' : β a',	bkt : list (Σ (a : α), β a) := bucket_array.read hash_fn bkts a,	nd : (list.map sigma.fst bkt).nodup,	lem : ∀ (bkts' : bucket_array α β n) (v1 u w : list (Σ (a : α), β a)), bkts.as_list = u ++ v1 ++ w → bkts'.as_list = u ++ [⟨a, b⟩] ++ w → (v1 = list.nil ∧ ¬↥(hash_map.contains_aux a bkt) ∨ ∃ (b'' : β a), v1 = [⟨a, b''⟩]) → (⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list)),	Hc : ¬↥(hash_map.contains_aux a bkt),	size' : ℕ := size + 1,	bkts' : bucket_array α β n := bucket_array.modify hash_fn bkts a (λ (l : list (Σ (a : α), β a)), ⟨a, b⟩ :: l),	mi : ⟨a', b'⟩ ∈ bkts'.as_list ↔ ite (a = a') (b == b') (⟨a', b'⟩ ∈ bkts.as_list),	h : ¬size' ≤ ↑n,	n' : ℕ+ := ⟨↑n * 2, _⟩,	bkts'' : bucket_array α β n' := bkts'.foldl (mk_array ↑n' list.nil) (hash_map.reinsert_aux hash_fn),	l : list (Σ (a : α), β a),	IH : ⟨a', b'⟩ ∈ (list.foldr (λ (y : Σ (a : α), β a) (x : bucket_array α β n'), hash_map.reinsert_aux hash_fn x y.fst y.snd) (mk_array ↑n' list.nil) l).as_list ↔ ⟨a', b'⟩ ∈ l,	a'' : α,	b'' : β a'',	B : bucket_array α β n' := list.foldr (λ (y : sigma β) (x : bucket_array α β n'), hash_map.reinsert_aux hash_fn x y.fst y.snd) (mk_array ↑n' list.nil) l	⊢ fin ↑?m_1
α : Type,	d : ℕ,	ds : list ℕ,	x y : holor α (d :: ds),	h : x.slice = y.slice,	t : holor_index (d :: ds),	i : ℕ,	is : list ℕ,	hiis : t.val = i :: is	⊢ list.forall₂ has_lt.lt (i :: is) (d :: ds)
α : Type,	d : ℕ,	ds : list ℕ,	x y : holor α (d :: ds),	h : x.slice = y.slice,	t : holor_index (d :: ds),	i : ℕ,	is : list ℕ,	hiis : t.val = i :: is	⊢ list.forall₂ has_lt.lt t.val (d :: ds)
α : Type,	d : ℕ,	ds : list ℕ,	x y : holor α (d :: ds),	h : x.slice = y.slice,	t : holor_index (d :: ds),	i : ℕ,	is : list ℕ,	hiis : t.val = i :: is,	hiisdds : list.forall₂ has_lt.lt (i :: is) (d :: ds),	hid : i < d,	hisds : list.forall₂ has_lt.lt is ds	⊢ x.slice i hid ⟨is, hisds⟩ = y.slice i hid ⟨is, hisds⟩
a : bool,	m : ℤ,	b : bool,	n : ℤ	⊢ (int.bit a m).ldiff (int.bit b n) = int.bit (a && !b) (m.ldiff n)
div_zero : ∀ (a : ℤ), a / 0 = 0	⊢ int.of_nat (0 / 0) = 0
div_zero : ∀ (a : ℤ), a / 0 = 0,	n : ℕ	⊢ int.of_nat ((n + 1) / 0) = 0
⊢ monoid ℤ
m n : ℕ,	_x : ↑m ∣ ↑n,	_fun_match : ↑m ∣ ↑n → m ∣ n,	a : ℤ,	ae : ↑n = ↑m * a,	m0 : m = 0	⊢ m ∣ n
m n : ℕ,	_x : ↑m ∣ ↑n,	_fun_match : ↑m ∣ ↑n → m ∣ n,	a : ℤ,	ae : ↑n = ↑m * a,	m0 : m = 0	⊢ m ∣ n
m n : ℕ,	_x : ↑m ∣ ↑n,	_fun_match : ↑m ∣ ↑n → m ∣ n,	a : ℤ,	m0 : m = 0,	ae : n = 0	⊢ m ∣ n
m n : ℕ,	_x : ↑m ∣ ↑n,	_fun_match : ↑m ∣ ↑n → m ∣ n,	a : ℤ,	ae : ↑n = ↑m * a,	m0l : 0 < m	⊢ m ∣ n
m n : ℕ,	_x : ↑m ∣ ↑n,	_fun_match : ↑m ∣ ↑n → m ∣ n,	a : ℤ,	ae : ↑n = ↑m * a,	m0l : 0 < m	⊢ 0 ≤ ↑m * a
m n : ℕ,	_x : ↑m ∣ ↑n,	_fun_match : ↑m ∣ ↑n → m ∣ n,	a : ℤ,	ae : ↑n = ↑m * a,	m0l : 0 < m	⊢ 0 < ↑m
m n : ℕ,	_x : ↑m ∣ ↑n,	_fun_match : ↑m ∣ ↑n → m ∣ n,	m0l : 0 < m,	k : ℕ,	ae : ↑n = ↑m * ↑k	⊢ m ∣ n
m n : ℕ,	_x : ↑m ∣ ↑n,	_fun_match : ↑m ∣ ↑n → m ∣ n,	a : ℤ,	ae : ↑n = ↑m * a,	m0l : 0 < m,	k : ℕ,	e : a = ↑k	⊢ m ∣ n
m n : ℕ,	_x : m ∣ n,	_fun_match : m ∣ n → ↑m ∣ ↑n,	k : ℕ,	e : n = m * k	⊢ ↑m * ↑k = ↑n
a b c : ℤ,	hcb : c ∣ b	⊢ (a - b) / c = a / c - b / c
a b c : ℤ,	hcb : c ∣ b	⊢ a / c + -b / c = a / c + -(b / c)
a b c : ℤ,	hcb : c ∣ b	⊢ -b / c = -(b / c)
a b : ℤ,	H1 : 0 < a,	H2 : 0 ≤ b,	H3 : b ∣ a	⊢ 0 * b < a
n : ℕ	⊢ ↑(bit1 n) = bit1 ↑n
n : ℕ	⊢ ↑(bit0 n + 1) = bit0 ↑n + 1
n : ℕ	⊢ ↑(n + n + 1) = ↑n + ↑n + 1
i j k : ℤ	⊢ (i.nat_abs * j.nat_abs).gcd (k.nat_abs * j.nat_abs) = i.nat_abs.gcd k.nat_abs * j.nat_abs
i j k : ℤ	⊢ (i * j).gcd (k * j) = i.gcd k * j.nat_abs
i j : ℤ	⊢ i.nat_abs.lcm j.nat_abs = j.nat_abs.lcm i.nat_abs
i j : ℤ	⊢ i.lcm j = j.lcm i
x y : ℕ	⊢ x.xgcd y = (x.gcd_a y, x.gcd_b y)
x y : ℕ	⊢ x.xgcd y = (x.gcd_a y, x.gcd_b y)
x y : ℕ	⊢ x.xgcd y = ((x.xgcd y).fst, (x.xgcd y).snd)
x y : ℕ,	fst snd : ℤ	⊢ (fst, snd) = ((fst, snd).fst, (fst, snd).snd)
x y : ℕ	⊢ x.xgcd y = (x.gcd_a y, x.gcd_b y)
s : set ℤ,	h : ¬bdd_below s	⊢ ¬(s.nonempty ∧ bdd_below s)
m n : ℤ	⊢ odd (m + n) ↔ (odd m ↔ even n)
n : ℤ	⊢ even (n * (n + 1))
n : ℤ	⊢ even n ∨ even (n + 1)
n : ℤ	⊢ even (n + 1) = odd n
m n : ℤ,	h : even m	⊢ ¬even (n + 3) ↔ even (m ^ 2 + m + n)
⊢ ¬even 25394535
n : ℤ,	_x : odd n,	_fun_match : odd n → n % 2 = 1,	m : ℤ,	hm : n = 2 * m + 1	⊢ n % 2 = 1
n : ℤ,	_x : odd n,	_fun_match : odd n → n % 2 = 1,	m : ℤ,	hm : n = 2 * m + 1	⊢ (2 * m % 2 + 1 % 2) % 2 = 1
n : ℤ,	h : n % 2 = 1	⊢ n % 2 + 2 * (n / 2) = 2 * (n / 2) + 1
n : ℤ,	h : n % 2 = 1	⊢ 1 + 2 * (n / 2) = 2 * (n / 2) + 1
n : ℤ	⊢ ∃ (k : ℤ), n = 2 * k ∨ n = 2 * k + 1
α : Type u,	f g : list α → list α,	m n : ℕ,	l : list α,	h : n ≤ m	⊢ list.modify_nth_tail g m (list.modify_nth_tail f n l) = list.modify_nth_tail (λ (l : list α), list.modify_nth_tail g (m - n) (f l)) n l
α : Type u,	f g : list α → list α,	n : ℕ,	l : list α,	m : ℕ,	h : n ≤ n + m	⊢ list.modify_nth_tail g (n + m) (list.modify_nth_tail f n l) = list.modify_nth_tail (λ (l : list α), list.modify_nth_tail g (n + m - n) (f l)) n l
α : Type u,	a b : α,	update_nth_comm : ∀ {n m : ℕ} (l : list α), n ≠ m → (l.update_nth n a).update_nth m b = (l.update_nth m b).update_nth n a,	_x _x : ℕ,	_x : _x ≠ _x	⊢ (list.nil.update_nth _x a).update_nth _x b = (list.nil.update_nth _x b).update_nth _x a
α : Type u,	a b : α,	update_nth_comm : ∀ {n m : ℕ} (l : list α), n ≠ m → (l.update_nth n a).update_nth m b = (l.update_nth m b).update_nth n a,	n : ℕ,	x : α,	t : list α,	h : n + 1 ≠ 0	⊢ ((x :: t).update_nth (n + 1) a).update_nth 0 b = ((x :: t).update_nth 0 b).update_nth (n + 1) a
α : Type u,	a b : α,	update_nth_comm : ∀ {n m : ℕ} (l : list α), n ≠ m → (l.update_nth n a).update_nth m b = (l.update_nth m b).update_nth n a,	m : ℕ,	x : α,	t : list α,	h : 0 ≠ m + 1	⊢ ((x :: t).update_nth 0 a).update_nth (m + 1) b = ((x :: t).update_nth (m + 1) b).update_nth 0 a
α : Type u,	a b : α,	update_nth_comm : ∀ {n m : ℕ} (l : list α), n ≠ m → (l.update_nth n a).update_nth m b = (l.update_nth m b).update_nth n a,	n m : ℕ,	x : α,	t : list α,	h : n + 1 ≠ m + 1	⊢ ((x :: t).update_nth (n + 1) a).update_nth (m + 1) b = ((x :: t).update_nth (m + 1) b).update_nth (n + 1) a
α : Type u,	a b : α,	update_nth_comm : ∀ {n m : ℕ} (l : list α), n ≠ m → (l.update_nth n a).update_nth m b = (l.update_nth m b).update_nth n a,	n m : ℕ,	x : α,	t : list α,	h : n + 1 ≠ m + 1	⊢ (t.update_nth n a).update_nth m b = (t.update_nth m b).update_nth n a
α : Type u,	a b : α,	mem_insert_nth : ∀ {n : ℕ} {l : list α}, n ≤ l.length → (a ∈ list.insert_nth n b l ↔ a = b ∨ a ∈ l),	n : ℕ,	a' : α,	as : list α,	h : n + 1 ≤ (a' :: as).length	⊢ a ∈ list.insert_nth (n + 1) b (a' :: as) ↔ a = b ∨ a ∈ a' :: as
α : Type u,	a b : α,	mem_insert_nth : ∀ {n : ℕ} {l : list α}, n ≤ l.length → (a ∈ list.insert_nth n b l ↔ a = b ∨ a ∈ l),	n : ℕ,	a' : α,	as : list α,	h : n + 1 ≤ (a' :: as).length	⊢ a ∈ a' :: list.modify_nth_tail (list.cons b) n as ↔ a = b ∨ a ∈ a' :: as
α : Type u,	l : list α,	x : α,	n : ℕ	⊢ l.length ≤ (list.insert_nth n x l).length
α : Type u,	l : list α,	x : α,	n : ℕ,	hn : n ≤ l.length	⊢ l.length ≤ (list.insert_nth n x l).length
α : Type u,	l : list α,	x : α,	n : ℕ,	hn : n ≤ l.length	⊢ l.length ≤ (list.insert_nth n x l).length		case or.inr	α : Type u,	l : list α,	x : α,	n : ℕ,	hn : l.length < n	⊢ l.length ≤ (list.insert_nth n x l).length
α : Type u,	l : list α,	x : α,	n : ℕ,	hn : n ≤ l.length	⊢ l.length ≤ l.length + 1
α : Type u,	l : list α,	x : α,	n : ℕ,	hn : l.length < n	⊢ l.length ≤ (list.insert_nth n x l).length
α : Type u_1,	β : Type u_2,	f : α → β,	map_take : ∀ (L : list α) (i : ℕ), list.map f (list.take i L) = list.take i (list.map f L),	i : ℕ	⊢ list.map f (list.take i list.nil) = list.take i (list.map f list.nil)
α : Type u_1,	β : Type u_2,	f : α → β,	map_take : ∀ (L : list α) (i : ℕ), list.map f (list.take i L) = list.take i (list.map f L),	L : list α	⊢ list.map f (list.take 0 L) = list.take 0 (list.map f L)
α : Type u_1,	β : Type u_2,	f : α → β,	map_take : ∀ (L : list α) (i : ℕ), list.map f (list.take i L) = list.take i (list.map f L),	h : α,	t : list α,	n : ℕ	⊢ list.map f (list.take (n + 1) (h :: t)) = list.take (n + 1) (list.map f (h :: t))
α : Type u_1,	β : Type u_2,	f : α → β,	map_take : ∀ (L : list α) (i : ℕ), list.map f (list.take i L) = list.take i (list.map f L),	h : α,	t : list α,	n : ℕ	⊢ f h :: list.map f (list.take n t) = f h :: list.take n (list.map f t)
α : Type u,	L₁ L₂ : list (list α)	⊢ (L₁ ++ L₂).join = L₁.join ++ L₂.join
α : Type u,	L₂ : list (list α)	⊢ (list.nil ++ L₂).join = list.nil.join ++ L₂.join
α : Type u,	L₂ : list (list α),	L₁_hd : list α,	L₁_tl : list (list α),	L₁_ih : (L₁_tl ++ L₂).join = L₁_tl.join ++ L₂.join	⊢ (L₁_hd :: L₁_tl ++ L₂).join = (L₁_hd :: L₁_tl).join ++ L₂.join
α : Type u,	L₁ L₂ : list (list α)	⊢ (L₁ ++ L₂).join = L₁.join ++ L₂.join
α : Type u,	p : α → Prop,	_inst_1 : decidable_pred p,	a : α,	H : list.find p list.nil = option.some a	⊢ a ∈ list.nil
α : Type u,	p : α → Prop,	_inst_1 : decidable_pred p,	l : list α,	a : α,	H : list.find p l = option.some a	⊢ a ∈ l
α : Type u,	p : α → Prop,	_inst_1 : decidable_pred p,	a : α,	H : list.find p list.nil = option.some a	⊢ a ∈ list.nil		case list.cons	α : Type u,	p : α → Prop,	_inst_1 : decidable_pred p,	a b : α,	l : list α,	IH : list.find p l = option.some a → a ∈ l,	H : list.find p (b :: l) = option.some a	⊢ a ∈ b :: l
α : Type u,	p : α → Prop,	_inst_1 : decidable_pred p,	a b : α,	l : list α,	IH : list.find p l = option.some a → a ∈ l,	H : list.find p (b :: l) = option.some a	⊢ a ∈ b :: l
α : Type u,	p : α → Prop,	_inst_1 : decidable_pred p,	a b : α,	l : list α,	IH : list.find p l = option.some a → a ∈ l,	h : p b,	H : option.some b = option.some a	⊢ a ∈ b :: l
α : Type u,	p : α → Prop,	_inst_1 : decidable_pred p,	a : α,	l : list α,	IH : list.find p l = option.some a → a ∈ l,	h : p a,	H : option.some a = option.some a	⊢ a ∈ a :: l
α : Type u,	p : α → Prop,	_inst_1 : decidable_pred p,	a b : α,	l : list α,	IH : list.find p l = option.some a → a ∈ l,	H : list.find p (b :: l) = option.some a,	h : p b	⊢ a ∈ b :: l
α : Type u,	p : α → Prop,	_inst_1 : decidable_pred p,	a b : α,	l : list α,	IH : list.find p l = option.some a → a ∈ l,	H : list.find p (b :: l) = option.some a,	h : p b	⊢ a ∈ b :: l		α : Type u,	p : α → Prop,	_inst_1 : decidable_pred p,	a b : α,	l : list α,	IH : list.find p l = option.some a → a ∈ l,	H : list.find p (b :: l) = option.some a,	h : ¬p b	⊢ a ∈ b :: l
α : Type u,	p : α → Prop,	_inst_1 : decidable_pred p,	a b : α,	l : list α,	IH : list.find p l = option.some a → a ∈ l,	h : ¬p b,	H : list.find p l = option.some a	⊢ a ∈ b :: l
α : Type u,	p : α → Prop,	_inst_1 : decidable_pred p,	a b : α,	l : list α,	IH : list.find p l = option.some a → a ∈ l,	H : list.find p (b :: l) = option.some a,	h : ¬p b	⊢ a ∈ b :: l
α : Type u,	β : Type v,	f : α → option β,	a : α,	l : list α,	h : f a = option.none	⊢ list.filter_map f (a :: l) = list.filter_map f l
α : Type u,	β : Type v,	f : α → option β,	l : list α,	b : β	⊢ b ∈ list.filter_map f l ↔ ∃ (a : α), a ∈ l ∧ f a = option.some b
α : Type u,	β : Type v,	f : α → option β,	b : β	⊢ b ∈ list.filter_map f list.nil → (∃ (a : α), a ∈ list.nil ∧ f a = option.some b)
α : Type u,	β : Type v,	f : α → option β,	b : β,	H : b ∈ list.filter_map f list.nil	⊢ ∃ (a : α), a ∈ list.nil ∧ f a = option.some b
α : Type u,	β : Type v,	f : α → option β,	b : β	⊢ b ∈ list.filter_map f list.nil → (∃ (a : α), a ∈ list.nil ∧ f a = option.some b)		α : Type u,	β : Type v,	f : α → option β,	b : β	⊢ (∃ (a : α), a ∈ list.nil ∧ f a = option.some b) → b ∈ list.filter_map f list.nil
α : Type u,	β : Type v,	f : α → option β,	b : β	⊢ (∃ (a : α), a ∈ list.nil ∧ f a = option.some b) → b ∈ list.filter_map f list.nil
α : Type u,	β : Type v,	f : α → option β,	b : β,	ᾰ_w : α,	H : ᾰ_w ∈ list.nil,	ᾰ_h_right : f ᾰ_w = option.some b	⊢ b ∈ list.filter_map f list.nil
α : Type u,	β : Type v,	f : α → option β,	b : β	⊢ b ∈ list.filter_map f list.nil ↔ ∃ (a : α), a ∈ list.nil ∧ f a = option.some b
α : Type u,	β : Type v,	f : α → option β,	b : β	⊢ b ∈ list.filter_map f list.nil ↔ ∃ (a : α), a ∈ list.nil ∧ f a = option.some b		case list.cons	α : Type u,	β : Type v,	f : α → option β,	b : β,	a : α,	l : list α,	IH : b ∈ list.filter_map f l ↔ ∃ (a : α), a ∈ l ∧ f a = option.some b	⊢ b ∈ list.filter_map f (a :: l) ↔ ∃ (a_1 : α), a_1 ∈ a :: l ∧ f a_1 = option.some b
α : Type u,	β : Type v,	f : α → option β,	b : β,	a : α,	l : list α,	IH : b ∈ list.filter_map f l ↔ ∃ (a : α), a ∈ l ∧ f a = option.some b	⊢ b ∈ list.filter_map f (a :: l) ↔ ∃ (a_1 : α), a_1 ∈ a :: l ∧ f a_1 = option.some b
α : Type u,	β : Type v,	f : α → option β,	b : β,	a : α,	l : list α,	IH : b ∈ list.filter_map f l ↔ ∃ (a : α), a ∈ l ∧ f a = option.some b,	h : f a = option.none	⊢ f a ≠ option.some b
α : Type u,	β : Type v,	f : α → option β,	b : β,	a : α,	l : list α,	IH : b ∈ list.filter_map f l ↔ ∃ (a : α), a ∈ l ∧ f a = option.some b,	h : f a = option.none	⊢ option.none ≠ option.some b
α : Type u,	β : Type v,	f : α → option β,	b : β,	a : α,	l : list α,	IH : b ∈ list.filter_map f l ↔ ∃ (a : α), a ∈ l ∧ f a = option.some b,	h : f a = option.none,	ᾰ : option.none = option.some b	⊢ false
α : Type u,	β : Type v,	f : α → option β,	b : β,	a : α,	l : list α,	IH : b ∈ list.filter_map f l ↔ ∃ (a : α), a ∈ l ∧ f a = option.some b,	h : f a = option.none	⊢ f a ≠ option.some b		α : Type u,	β : Type v,	f : α → option β,	b : β,	a : α,	l : list α,	IH : b ∈ list.filter_map f l ↔ ∃ (a : α), a ∈ l ∧ f a = option.some b,	h : f a = option.none,	this : f a ≠ option.some b	⊢ b ∈ list.filter_map f (a :: l) ↔ ∃ (a_1 : α), a_1 ∈ a :: l ∧ f a_1 = option.some b
α : Type u,	β : Type v,	f : α → option β,	b : β,	a : α,	l : list α,	IH : b ∈ list.filter_map f l ↔ ∃ (a : α), a ∈ l ∧ f a = option.some b,	h : f a = option.none	⊢ b ∈ list.filter_map f (a :: l) ↔ ∃ (a_1 : α), a_1 ∈ a :: l ∧ f a_1 = option.some b
α : Type u,	β : Type v,	f : α → option β,	b : β,	a : α,	l : list α,	IH : b ∈ list.filter_map f l ↔ ∃ (a : α), a ∈ l ∧ f a = option.some b,	h : f a = option.none,	this : f a ≠ option.some b	⊢ b ∈ list.filter_map f (a :: l) ↔ ∃ (a_1 : α), a_1 ∈ a :: l ∧ f a_1 = option.some b
α : Type u,	β : Type v,	f : α → option β,	b : β,	a : α,	l : list α,	IH : b ∈ list.filter_map f l ↔ ∃ (a : α), a ∈ l ∧ f a = option.some b,	h : f a = option.none	⊢ b ∈ list.filter_map f (a :: l) ↔ ∃ (a_1 : α), a_1 ∈ a :: l ∧ f a_1 = option.some b		case list.cons, option.some	α : Type u,	β : Type v,	f : α → option β,	b : β,	a : α,	l : list α,	IH : b ∈ list.filter_map f l ↔ ∃ (a : α), a ∈ l ∧ f a = option.some b,	b' : β,	h : f a = option.some b'	⊢ b ∈ list.filter_map f (a :: l) ↔ ∃ (a_1 : α), a_1 ∈ a :: l ∧ f a_1 = option.some b
α : Type u,	β : Type v,	f : α → option β,	b : β,	a : α,	l : list α,	IH : b ∈ list.filter_map f l ↔ ∃ (a : α), a ∈ l ∧ f a = option.some b,	b' : β,	h : f a = option.some b'	⊢ b ∈ list.filter_map f (a :: l) ↔ ∃ (a_1 : α), a_1 ∈ a :: l ∧ f a_1 = option.some b
α : Type u,	β : Type v,	f : α → option β,	b : β,	a : α,	l : list α,	IH : b ∈ list.filter_map f l ↔ ∃ (a : α), a ∈ l ∧ f a = option.some b,	b' : β,	h : f a = option.some b'	⊢ f a = option.some b ↔ b = b'
α : Type u,	β : Type v,	f : α → option β,	b : β,	a : α,	l : list α,	IH : b ∈ list.filter_map f l ↔ ∃ (a : α), a ∈ l ∧ f a = option.some b,	b' : β,	h : f a = option.some b'	⊢ f a = option.some b → b = b'
α : Type u,	β : Type v,	f : α → option β,	b : β,	a : α,	l : list α,	IH : b ∈ list.filter_map f l ↔ ∃ (a : α), a ∈ l ∧ f a = option.some b,	b' : β,	h : f a = option.some b'	⊢ b = b' → f a = option.some b
α : Type u,	β : Type v,	f : α → option β,	b : β,	a : α,	l : list α,	IH : b ∈ list.filter_map f l ↔ ∃ (a : α), a ∈ l ∧ f a = option.some b,	b' : β,	h : f a = option.some b',	t : f a = option.some b	⊢ b = b'
α : Type u,	β : Type v,	f : α → option β,	b : β,	a : α,	l : list α,	IH : b ∈ list.filter_map f l ↔ ∃ (a : α), a ∈ l ∧ f a = option.some b,	b' : β,	h : f a = option.some b',	t : f a = option.some b	⊢ b = b'
α : Type u,	β : Type v,	f : α → option β,	b : β,	a : α,	l : list α,	IH : b ∈ list.filter_map f l ↔ ∃ (a : α), a ∈ l ∧ f a = option.some b,	b' : β,	t : f a = option.some b,	h : option.some b = option.some b'	⊢ b = b'
α : Type u,	β : Type v,	f : α → option β,	b : β,	a : α,	l : list α,	IH : b ∈ list.filter_map f l ↔ ∃ (a : α), a ∈ l ∧ f a = option.some b,	b' : β,	h : f a = option.some b',	t : f a = option.some b	⊢ b = b'		α : Type u,	β : Type v,	f : α → option β,	b : β,	a : α,	l : list α,	IH : b ∈ list.filter_map f l ↔ ∃ (a : α), a ∈ l ∧ f a = option.some b,	b' : β,	h : f a = option.some b',	t : b = b'	⊢ f a = option.some b
α : Type u,	β : Type v,	f : α → option β,	b : β,	a : α,	l : list α,	IH : b ∈ list.filter_map f l ↔ ∃ (a : α), a ∈ l ∧ f a = option.some b,	b' : β,	h : f a = option.some b',	t : b = b'	⊢ f a = option.some b
α : Type u,	β : Type v,	f : α → option β,	b : β,	a : α,	l : list α,	IH : b ∈ list.filter_map f l ↔ ∃ (a : α), a ∈ l ∧ f a = option.some b,	b' : β,	h : f a = option.some b'	⊢ f a = option.some b ↔ b = b'		α : Type u,	β : Type v,	f : α → option β,	b : β,	a : α,	l : list α,	IH : b ∈ list.filter_map f l ↔ ∃ (a : α), a ∈ l ∧ f a = option.some b,	b' : β,	h : f a = option.some b',	this : f a = option.some b ↔ b = b'	⊢ b ∈ list.filter_map f (a :: l) ↔ ∃ (a_1 : α), a_1 ∈ a :: l ∧ f a_1 = option.some b
α : Type u,	β : Type v,	f : α → option β,	b : β,	a : α,	l : list α,	IH : b ∈ list.filter_map f l ↔ ∃ (a : α), a ∈ l ∧ f a = option.some b,	b' : β,	h : f a = option.some b'	⊢ f a = option.some b ↔ b = b'
α : Type u,	β : Type v,	f : α → option β,	b : β,	a : α,	l : list α,	IH : b ∈ list.filter_map f l ↔ ∃ (a : α), a ∈ l ∧ f a = option.some b,	b' : β,	h : f a = option.some b',	this : f a = option.some b ↔ b = b'	⊢ b ∈ list.filter_map f (a :: l) ↔ ∃ (a_1 : α), a_1 ∈ a :: l ∧ f a_1 = option.some b
α : Type u,	l : list (option α),	x : α	⊢ (∃ (i : ℕ), l.nth i = option.some (option.some x)) ↔ ∃ (i : ℕ), l.reduce_option.nth i = option.some x
α : Type u,	a : α,	l : list α	⊢ (a :: l).inits = list.nil :: list.map (λ (t : list α), a :: t) l.inits
α : Type u,	tails_eq_inits : ∀ (l : list α), l.tails = (list.map list.reverse l.reverse.inits).reverse	⊢ list.nil.tails = (list.map list.reverse list.nil.reverse.inits).reverse
α : Type u,	tails_eq_inits : ∀ (l : list α), l.tails = (list.map list.reverse l.reverse.inits).reverse,	a : α,	l : list α	⊢ (a :: l).tails = (list.map list.reverse (a :: l).reverse.inits).reverse
α : Type u_1,	β : Type u_2,	α' : Type u_3,	β' : Type u_4,	g : α → α',	g' : β → β',	t : α,	ts ys : list α,	r : list β,	f : list α → β,	f' : list α' → β',	H : ∀ (a : list α), g' (f a) = f' (list.map g a)	⊢ list.map g' (list.permutations_aux2 t ts r ys f).snd = (list.permutations_aux2 (g t) (list.map g ts) (list.map g' r) (list.map g ys) f').snd
α : Type u_1,	β : Type u_2,	α' : Type u_3,	β' : Type u_4,	g : α → α',	g' : β → β',	t : α,	ts : list α,	r : list β,	f : list α → β,	f' : list α' → β',	H : ∀ (a : list α), g' (f a) = f' (list.map g a)	⊢ list.map g' (list.permutations_aux2 t ts r list.nil f).snd = (list.permutations_aux2 (g t) (list.map g ts) (list.map g' r) (list.map g list.nil) f').snd
α : Type u_1,	β : Type u_2,	α' : Type u_3,	β' : Type u_4,	g : α → α',	g' : β → β',	t : α,	ts : list α,	r : list β,	ys_hd : α,	ys_tl : list α,	ys_ih : ∀ (f : list α → β) (f' : list α' → β'), (∀ (a : list α), g' (f a) = f' (list.map g a)) → list.map g' (list.permutations_aux2 t ts r ys_tl f).snd = (list.permutations_aux2 (g t) (list.map g ts) (list.map g' r) (list.map g ys_tl) f').snd,	f : list α → β,	f' : list α' → β',	H : ∀ (a : list α), g' (f a) = f' (list.map g a)	⊢ list.map g' (list.permutations_aux2 t ts r (ys_hd :: ys_tl) f).snd = (list.permutations_aux2 (g t) (list.map g ts) (list.map g' r) (list.map g (ys_hd :: ys_tl)) f').snd
α : Type u_1,	β : Type u_2,	α' : Type u_3,	β' : Type u_4,	g : α → α',	g' : β → β',	t : α,	ts ys : list α,	r : list β,	f : list α → β,	f' : list α' → β',	H : ∀ (a : list α), g' (f a) = f' (list.map g a)	⊢ list.map g' (list.permutations_aux2 t ts r ys f).snd = (list.permutations_aux2 (g t) (list.map g ts) (list.map g' r) (list.map g ys) f').snd
α : Type u_1,	β : Type u_2,	α' : Type u_3,	β' : Type u_4,	g : α → α',	g' : β → β',	t : α,	ts : list α,	r : list β,	ys_hd : α,	ys_tl : list α,	ys_ih : ∀ (f : list α → β) (f' : list α' → β'), (∀ (a : list α), g' (f a) = f' (list.map g a)) → list.map g' (list.permutations_aux2 t ts r ys_tl f).snd = (list.permutations_aux2 (g t) (list.map g ts) (list.map g' r) (list.map g ys_tl) f').snd,	f : list α → β,	f' : list α' → β',	H : ∀ (a : list α), g' (f a) = f' (list.map g a)	⊢ ∀ (a : list α), g' (f (ys_hd :: a)) = f' (g ys_hd :: list.map g a)
α : Type u_1,	β : Type u_2,	α' : Type u_3,	β' : Type u_4,	g : α → α',	g' : β → β',	t : α,	ts : list α,	r : list β,	ys_hd : α,	ys_tl : list α,	ys_ih : ∀ (f : list α → β) (f' : list α' → β'), (∀ (a : list α), g' (f a) = f' (list.map g a)) → list.map g' (list.permutations_aux2 t ts r ys_tl f).snd = (list.permutations_aux2 (g t) (list.map g ts) (list.map g' r) (list.map g ys_tl) f').snd,	f : list α → β,	f' : list α' → β',	H : ∀ (a : list α), g' (f a) = f' (list.map g a)	⊢ list.map g' (list.permutations_aux2 t ts r ys_tl (λ (x : list α), f (ys_hd :: x))).snd = (list.permutations_aux2 (g t) (list.map g ts) (list.map g' r) (list.map g ys_tl) (λ (x : list α'), f' (g ys_hd :: x))).snd
α : Type u,	t : α,	ts ys l l' : list α	⊢ l' ∈ (list.permutations_aux2 t ts list.nil ys (has_append.append l)).snd ↔ ∃ (l₁ l₂ : list α), l₂ ≠ list.nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts
α : Type u,	t : α,	ts l' l : list α	⊢ l' ∈ (list.permutations_aux2 t ts list.nil list.nil (has_append.append l)).snd ↔ ∃ (l₁ l₂ : list α), l₂ ≠ list.nil ∧ list.nil = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts		case list.cons	α : Type u,	t : α,	ts l' : list α,	y : α,	ys : list α,	ih : ∀ {l : list α}, l' ∈ (list.permutations_aux2 t ts list.nil ys (has_append.append l)).snd ↔ ∃ (l₁ l₂ : list α), l₂ ≠ list.nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts,	l : list α	⊢ l' ∈ (list.permutations_aux2 t ts list.nil (y :: ys) (has_append.append l)).snd ↔ ∃ (l₁ l₂ : list α), l₂ ≠ list.nil ∧ y :: ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts
α : Type u,	t : α,	ts l' l : list α	⊢ l' ∈ (list.permutations_aux2 t ts list.nil list.nil (has_append.append l)).snd ↔ ∃ (l₁ l₂ : list α), l₂ ≠ list.nil ∧ list.nil = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts
α : Type u,	t : α,	ts l' : list α,	y : α,	ys : list α,	ih : ∀ {l : list α}, l' ∈ (list.permutations_aux2 t ts list.nil ys (has_append.append l)).snd ↔ ∃ (l₁ l₂ : list α), l₂ ≠ list.nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts,	l : list α	⊢ l' ∈ (list.permutations_aux2 t ts list.nil (y :: ys) (has_append.append l)).snd ↔ ∃ (l₁ l₂ : list α), l₂ ≠ list.nil ∧ y :: ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts
α : Type u,	t : α,	ts l' : list α,	y : α,	ys : list α,	ih : ∀ {l : list α}, l' ∈ (list.permutations_aux2 t ts list.nil ys (has_append.append l)).snd ↔ ∃ (l₁ l₂ : list α), l₂ ≠ list.nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts,	l : list α	⊢ (λ (x : list α), l ++ y :: x) = has_append.append (l ++ [y])
α : Type u,	t : α,	ts l' : list α,	y : α,	ys : list α,	ih : ∀ {l : list α}, l' ∈ (list.permutations_aux2 t ts list.nil ys (has_append.append l)).snd ↔ ∃ (l₁ l₂ : list α), l₂ ≠ list.nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts,	l : list α	⊢ (λ (x : list α), l ++ y :: x) = has_append.append (l ++ [y])
α : Type u,	t : α,	ts l' : list α,	y : α,	ys : list α,	ih : ∀ {l : list α}, l' ∈ (list.permutations_aux2 t ts list.nil ys (has_append.append l)).snd ↔ ∃ (l₁ l₂ : list α), l₂ ≠ list.nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts,	l x : list α	⊢ l ++ y :: x = l ++ [y] ++ x
α : Type u,	t : α,	ts l' : list α,	y : α,	ys : list α,	ih : ∀ {l : list α}, l' ∈ (list.permutations_aux2 t ts list.nil ys (has_append.append l)).snd ↔ ∃ (l₁ l₂ : list α), l₂ ≠ list.nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts,	l : list α	⊢ (l' = l ++ (t :: y :: ys ++ ts) ∨ ∃ (l₁ l₂ : list α), l₂ ≠ list.nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ [y] ++ l₁ ++ t :: l₂ ++ ts) ↔ ∃ (l₁ l₂ : list α), l₂ ≠ list.nil ∧ y :: ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts
α : Type u,	t : α,	ts l' : list α,	y : α,	ys : list α,	ih : ∀ {l : list α}, l' ∈ (list.permutations_aux2 t ts list.nil ys (has_append.append l)).snd ↔ ∃ (l₁ l₂ : list α), l₂ ≠ list.nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts,	l : list α	⊢ (l' = l ++ (t :: y :: ys ++ ts) ∨ ∃ (l₁ l₂ : list α), l₂ ≠ list.nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ [y] ++ l₁ ++ t :: l₂ ++ ts) ↔ ∃ (l₁ l₂ : list α), l₂ ≠ list.nil ∧ y :: ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts
α : Type u,	t : α,	ts l' : list α,	y : α,	ys : list α,	ih : ∀ {l : list α}, l' ∈ (list.permutations_aux2 t ts list.nil ys (has_append.append l)).snd ↔ ∃ (l₁ l₂ : list α), l₂ ≠ list.nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts,	l : list α	⊢ (l' = l ++ (t :: y :: ys ++ ts) ∨ ∃ (l₁ l₂ : list α), l₂ ≠ list.nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ [y] ++ l₁ ++ t :: l₂ ++ ts) → (∃ (l₁ l₂ : list α), l₂ ≠ list.nil ∧ y :: ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts)
α : Type u,	t : α,	ts l' : list α,	y : α,	ys : list α,	ih : ∀ {l : list α}, l' ∈ (list.permutations_aux2 t ts list.nil ys (has_append.append l)).snd ↔ ∃ (l₁ l₂ : list α), l₂ ≠ list.nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts,	l : list α	⊢ (∃ (l₁ l₂ : list α), l₂ ≠ list.nil ∧ y :: ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts) → (l' = l ++ (t :: y :: ys ++ ts) ∨ ∃ (l₁ l₂ : list α), l₂ ≠ list.nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ [y] ++ l₁ ++ t :: l₂ ++ ts)
α : Type u,	t : α,	ts l' : list α,	y : α,	ys : list α,	ih : ∀ {l : list α}, l' ∈ (list.permutations_aux2 t ts list.nil ys (has_append.append l)).snd ↔ ∃ (l₁ l₂ : list α), l₂ ≠ list.nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts,	l : list α,	h : l' = l ++ (t :: y :: ys ++ ts) ∨ ∃ (l₁ l₂ : list α), l₂ ≠ list.nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ [y] ++ l₁ ++ t :: l₂ ++ ts	⊢ ∃ (l₁ l₂ : list α), l₂ ≠ list.nil ∧ y :: ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts
α : Type u,	t : α,	ts : list α,	y : α,	ys l : list α,	ih : ∀ {l_1 : list α}, l ++ (t :: y :: ys ++ ts) ∈ (list.permutations_aux2 t ts list.nil ys (has_append.append l_1)).snd ↔ ∃ (l₁ l₂ : list α), l₂ ≠ list.nil ∧ ys = l₁ ++ l₂ ∧ l ++ (t :: y :: ys ++ ts) = l_1 ++ l₁ ++ t :: l₂ ++ ts	⊢ ∃ (l₁ l₂ : list α), l₂ ≠ list.nil ∧ y :: ys = l₁ ++ l₂ ∧ l ++ (t :: y :: ys ++ ts) = l ++ l₁ ++ t :: l₂ ++ ts
α : Type u,	t : α,	ts : list α,	y : α,	ys l : list α,	ih : ∀ {l_1 : list α}, l ++ (t :: y :: ys ++ ts) ∈ (list.permutations_aux2 t ts list.nil ys (has_append.append l_1)).snd ↔ ∃ (l₁ l₂ : list α), l₂ ≠ list.nil ∧ ys = l₁ ++ l₂ ∧ l ++ (t :: y :: ys ++ ts) = l_1 ++ l₁ ++ t :: l₂ ++ ts	⊢ y :: ys ≠ list.nil ∧ y :: ys = list.nil ++ y :: ys ∧ l ++ (t :: y :: ys ++ ts) = l ++ list.nil ++ t :: y :: ys ++ ts
α : Type u,	t : α,	ts l' : list α,	y : α,	ys : list α,	ih : ∀ {l : list α}, l' ∈ (list.permutations_aux2 t ts list.nil ys (has_append.append l)).snd ↔ ∃ (l₁ l₂ : list α), l₂ ≠ list.nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts,	l : list α,	e : l' = l ++ (t :: y :: ys ++ ts)	⊢ ∃ (l₁ l₂ : list α), l₂ ≠ list.nil ∧ y :: ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts		α : Type u,	t : α,	ts l' : list α,	y : α,	ys : list α,	ih : ∀ {l : list α}, l' ∈ (list.permutations_aux2 t ts list.nil ys (has_append.append l)).snd ↔ ∃ (l₁ l₂ : list α), l₂ ≠ list.nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts,	l l₁ l₂ : list α,	l0 : l₂ ≠ list.nil,	ye : ys = l₁ ++ l₂,	h_h_h_right_right : l' = l ++ [y] ++ l₁ ++ t :: l₂ ++ ts	⊢ ∃ (l₁ l₂ : list α), l₂ ≠ list.nil ∧ y :: ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts
α : Type u,	t : α,	ts l' : list α,	y : α,	ys : list α,	ih : ∀ {l : list α}, l' ∈ (list.permutations_aux2 t ts list.nil ys (has_append.append l)).snd ↔ ∃ (l₁ l₂ : list α), l₂ ≠ list.nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts,	l : list α,	e : l' = l ++ (t :: y :: ys ++ ts)	⊢ ∃ (l₁ l₂ : list α), l₂ ≠ list.nil ∧ y :: ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts
α : Type u,	t : α,	ts : list α,	y : α,	l l₁ l₂ : list α,	l0 : l₂ ≠ list.nil,	ih : ∀ {l_1 : list α}, l ++ [y] ++ l₁ ++ t :: l₂ ++ ts ∈ (list.permutations_aux2 t ts list.nil (l₁ ++ l₂) (has_append.append l_1)).snd ↔ ∃ (l₁_1 l₂_1 : list α), l₂_1 ≠ list.nil ∧ l₁ ++ l₂ = l₁_1 ++ l₂_1 ∧ l ++ [y] ++ l₁ ++ t :: l₂ ++ ts = l_1 ++ l₁_1 ++ t :: l₂_1 ++ ts	⊢ ∃ (l₁_1 l₂_1 : list α), l₂_1 ≠ list.nil ∧ y :: (l₁ ++ l₂) = l₁_1 ++ l₂_1 ∧ l ++ [y] ++ l₁ ++ t :: l₂ ++ ts = l ++ l₁_1 ++ t :: l₂_1 ++ ts
α : Type u,	t : α,	ts : list α,	y : α,	l l₁ l₂ : list α,	l0 : l₂ ≠ list.nil,	ih : ∀ {l_1 : list α}, l ++ [y] ++ l₁ ++ t :: l₂ ++ ts ∈ (list.permutations_aux2 t ts list.nil (l₁ ++ l₂) (has_append.append l_1)).snd ↔ ∃ (l₁_1 l₂_1 : list α), l₂_1 ≠ list.nil ∧ l₁ ++ l₂ = l₁_1 ++ l₂_1 ∧ l ++ [y] ++ l₁ ++ t :: l₂ ++ ts = l_1 ++ l₁_1 ++ t :: l₂_1 ++ ts	⊢ y :: (l₁ ++ l₂) = y :: l₁ ++ l₂ ∧ l ++ [y] ++ l₁ ++ t :: l₂ ++ ts = l ++ y :: l₁ ++ t :: l₂ ++ ts
α : Type u,	t : α,	ts l' : list α,	y : α,	ys : list α,	ih : ∀ {l : list α}, l' ∈ (list.permutations_aux2 t ts list.nil ys (has_append.append l)).snd ↔ ∃ (l₁ l₂ : list α), l₂ ≠ list.nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts,	l : list α,	h : l' = l ++ (t :: y :: ys ++ ts) ∨ ∃ (l₁ l₂ : list α), l₂ ≠ list.nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ [y] ++ l₁ ++ t :: l₂ ++ ts	⊢ ∃ (l₁ l₂ : list α), l₂ ≠ list.nil ∧ y :: ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts		α : Type u,	t : α,	ts l' : list α,	y : α,	ys : list α,	ih : ∀ {l : list α}, l' ∈ (list.permutations_aux2 t ts list.nil ys (has_append.append l)).snd ↔ ∃ (l₁ l₂ : list α), l₂ ≠ list.nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts,	l : list α,	h : ∃ (l₁ l₂ : list α), l₂ ≠ list.nil ∧ y :: ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts	⊢ l' = l ++ (t :: y :: ys ++ ts) ∨ ∃ (l₁ l₂ : list α), l₂ ≠ list.nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ [y] ++ l₁ ++ t :: l₂ ++ ts
α : Type u,	t : α,	ts l' : list α,	y : α,	ys : list α,	ih : ∀ {l : list α}, l' ∈ (list.permutations_aux2 t ts list.nil ys (has_append.append l)).snd ↔ ∃ (l₁ l₂ : list α), l₂ ≠ list.nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts,	l l₁ l₂ : list α,	l0 : l₂ ≠ list.nil,	ye : ys = l₁ ++ l₂,	h_h_h_right_right : l' = l ++ [y] ++ l₁ ++ t :: l₂ ++ ts	⊢ ∃ (l₁ l₂ : list α), l₂ ≠ list.nil ∧ y :: ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts
α : Type u,	t : α,	ts l' : list α,	y : α,	ys : list α,	ih : ∀ {l : list α}, l' ∈ (list.permutations_aux2 t ts list.nil ys (has_append.append l)).snd ↔ ∃ (l₁ l₂ : list α), l₂ ≠ list.nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts,	l : list α,	h : ∃ (l₁ l₂ : list α), l₂ ≠ list.nil ∧ y :: ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts	⊢ l' = l ++ (t :: y :: ys ++ ts) ∨ ∃ (l₁ l₂ : list α), l₂ ≠ list.nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ [y] ++ l₁ ++ t :: l₂ ++ ts
α : Type u,	t : α,	ts : list α,	y : α,	ys l l₂ : list α,	l0 : l₂ ≠ list.nil,	ye : y :: ys = list.nil ++ l₂,	ih : ∀ {l_1 : list α}, l ++ list.nil ++ t :: l₂ ++ ts ∈ (list.permutations_aux2 t ts list.nil ys (has_append.append l_1)).snd ↔ ∃ (l₁ l₂_1 : list α), l₂_1 ≠ list.nil ∧ ys = l₁ ++ l₂_1 ∧ l ++ list.nil ++ t :: l₂ ++ ts = l_1 ++ l₁ ++ t :: l₂_1 ++ ts	⊢ l ++ list.nil ++ t :: l₂ ++ ts = l ++ (t :: y :: ys ++ ts) ∨ ∃ (l₁ l₂_1 : list α), l₂_1 ≠ list.nil ∧ ys = l₁ ++ l₂_1 ∧ l ++ list.nil ++ t :: l₂ ++ ts = l ++ [y] ++ l₁ ++ t :: l₂_1 ++ ts		α : Type u,	t : α,	ts : list α,	y : α,	ys l : list α,	y' : α,	l₁ l₂ : list α,	l0 : l₂ ≠ list.nil,	ye : y :: ys = y' :: l₁ ++ l₂,	ih : ∀ {l_1 : list α}, l ++ y' :: l₁ ++ t :: l₂ ++ ts ∈ (list.permutations_aux2 t ts list.nil ys (has_append.append l_1)).snd ↔ ∃ (l₁_1 l₂_1 : list α), l₂_1 ≠ list.nil ∧ ys = l₁_1 ++ l₂_1 ∧ l ++ y' :: l₁ ++ t :: l₂ ++ ts = l_1 ++ l₁_1 ++ t :: l₂_1 ++ ts	⊢ l ++ y' :: l₁ ++ t :: l₂ ++ ts = l ++ (t :: y :: ys ++ ts) ∨ ∃ (l₁_1 l₂_1 : list α), l₂_1 ≠ list.nil ∧ ys = l₁_1 ++ l₂_1 ∧ l ++ y' :: l₁ ++ t :: l₂ ++ ts = l ++ [y] ++ l₁_1 ++ t :: l₂_1 ++ ts
α : Type u,	t : α,	ts : list α,	y : α,	ys l l₂ : list α,	l0 : l₂ ≠ list.nil,	ye : y :: ys = list.nil ++ l₂,	ih : ∀ {l_1 : list α}, l ++ list.nil ++ t :: l₂ ++ ts ∈ (list.permutations_aux2 t ts list.nil ys (has_append.append l_1)).snd ↔ ∃ (l₁ l₂_1 : list α), l₂_1 ≠ list.nil ∧ ys = l₁ ++ l₂_1 ∧ l ++ list.nil ++ t :: l₂ ++ ts = l_1 ++ l₁ ++ t :: l₂_1 ++ ts	⊢ l ++ list.nil ++ t :: l₂ ++ ts = l ++ (t :: y :: ys ++ ts) ∨ ∃ (l₁ l₂_1 : list α), l₂_1 ≠ list.nil ∧ ys = l₁ ++ l₂_1 ∧ l ++ list.nil ++ t :: l₂ ++ ts = l ++ [y] ++ l₁ ++ t :: l₂_1 ++ ts
α : Type u,	t : α,	ts : list α,	y : α,	ys l : list α,	y' : α,	l₁ l₂ : list α,	l0 : l₂ ≠ list.nil,	ih : ∀ {l_1 : list α}, l ++ y' :: l₁ ++ t :: l₂ ++ ts ∈ (list.permutations_aux2 t ts list.nil ys (has_append.append l_1)).snd ↔ ∃ (l₁_1 l₂_1 : list α), l₂_1 ≠ list.nil ∧ ys = l₁_1 ++ l₂_1 ∧ l ++ y' :: l₁ ++ t :: l₂ ++ ts = l_1 ++ l₁_1 ++ t :: l₂_1 ++ ts,	ye : y = y' ∧ ys = l₁ ++ l₂	⊢ l ++ y' :: l₁ ++ t :: l₂ ++ ts = l ++ (t :: y :: ys ++ ts) ∨ ∃ (l₁_1 l₂_1 : list α), l₂_1 ≠ list.nil ∧ ys = l₁_1 ++ l₂_1 ∧ l ++ y' :: l₁ ++ t :: l₂ ++ ts = l ++ [y] ++ l₁_1 ++ t :: l₂_1 ++ ts
α : Type u,	t : α,	ts : list α,	y : α,	ys l : list α,	y' : α,	l₁ l₂ : list α,	l0 : l₂ ≠ list.nil,	ye : y :: ys = y' :: l₁ ++ l₂,	ih : ∀ {l_1 : list α}, l ++ y' :: l₁ ++ t :: l₂ ++ ts ∈ (list.permutations_aux2 t ts list.nil ys (has_append.append l_1)).snd ↔ ∃ (l₁_1 l₂_1 : list α), l₂_1 ≠ list.nil ∧ ys = l₁_1 ++ l₂_1 ∧ l ++ y' :: l₁ ++ t :: l₂ ++ ts = l_1 ++ l₁_1 ++ t :: l₂_1 ++ ts	⊢ l ++ y' :: l₁ ++ t :: l₂ ++ ts = l ++ (t :: y :: ys ++ ts) ∨ ∃ (l₁_1 l₂_1 : list α), l₂_1 ≠ list.nil ∧ ys = l₁_1 ++ l₂_1 ∧ l ++ y' :: l₁ ++ t :: l₂ ++ ts = l ++ [y] ++ l₁_1 ++ t :: l₂_1 ++ ts
α : Type u,	t : α,	ts : list α,	y : α,	l l₁ l₂ : list α,	l0 : l₂ ≠ list.nil,	ih : ∀ {l_1 : list α}, l ++ y :: l₁ ++ t :: l₂ ++ ts ∈ (list.permutations_aux2 t ts list.nil (l₁ ++ l₂) (has_append.append l_1)).snd ↔ ∃ (l₁_1 l₂_1 : list α), l₂_1 ≠ list.nil ∧ l₁ ++ l₂ = l₁_1 ++ l₂_1 ∧ l ++ y :: l₁ ++ t :: l₂ ++ ts = l_1 ++ l₁_1 ++ t :: l₂_1 ++ ts	⊢ l₁ ++ l₂ = l₁ ++ l₂ ∧ l ++ y :: l₁ ++ t :: l₂ ++ ts = l ++ [y] ++ l₁ ++ t :: l₂ ++ ts
α : Type u,	t : α,	ts : list α,	y : α,	l l₁ l₂ : list α,	l0 : l₂ ≠ list.nil,	ih : ∀ {l_1 : list α}, l ++ y :: l₁ ++ t :: l₂ ++ ts ∈ (list.permutations_aux2 t ts list.nil (l₁ ++ l₂) (has_append.append l_1)).snd ↔ ∃ (l₁_1 l₂_1 : list α), l₂_1 ≠ list.nil ∧ l₁ ++ l₂ = l₁_1 ++ l₂_1 ∧ l ++ y :: l₁ ++ t :: l₂ ++ ts = l_1 ++ l₁_1 ++ t :: l₂_1 ++ ts	⊢ l ++ y :: l₁ ++ t :: l₂ ++ ts = l ++ (t :: y :: (l₁ ++ l₂) ++ ts) ∨ ∃ (l₁_1 l₂_1 : list α), l₂_1 ≠ list.nil ∧ l₁ ++ l₂ = l₁_1 ++ l₂_1 ∧ l ++ y :: l₁ ++ t :: l₂ ++ ts = l ++ [y] ++ l₁_1 ++ t :: l₂_1 ++ ts
α : Type u,	_inst_1 : decidable_eq α,	a : α,	l : list α,	h : a ∉ l	⊢ has_insert.insert a l = a :: l
α : Type u,	_inst_1 : decidable_eq α,	a : α,	l : list α,	h : a ∉ l	⊢ has_insert.insert a l = a :: l
α : Type u,	_inst_1 : decidable_eq α,	a : α,	l : list α,	h : a ∉ l	⊢ a = a ∧ l = l
α : Type u,	_inst_1 : decidable_eq α,	a : α,	l : list α,	h : a ∉ l	⊢ a = a
α : Type u,	_inst_1 : decidable_eq α,	a : α,	l : list α,	h : a ∉ l	⊢ l = l
α : Type u,	_inst_1 : decidable_eq α,	a : α,	l : list α,	h : a ∉ l	⊢ has_insert.insert a l = a :: l
α : Type u,	_inst_1 : decidable_eq α,	a : α,	l : list α	⊢ l <:+ has_insert.insert a l
α : Type u,	_inst_1 : decidable_eq α,	a : α,	l : list α,	h : a ∈ l	⊢ l <:+ has_insert.insert a l
α : Type u,	_inst_1 : decidable_eq α,	a : α,	l : list α	⊢ l <:+ has_insert.insert a l
α : Type u,	_inst_1 : decidable_eq α,	a : α,	l : list α,	h : a ∉ l	⊢ l <:+ has_insert.insert a l
α : Type u,	_inst_1 : decidable_eq α,	l : list α	⊢ list.nil.diff l = list.nil
α : Type u,	_inst_1 : decidable_eq α	⊢ list.nil.diff list.nil = list.nil
α : Type u,	_inst_1 : decidable_eq α,	l_hd : α,	l_tl : list α,	l_ih : list.nil.diff l_tl = list.nil	⊢ list.nil.diff (l_hd :: l_tl) = list.nil
α : Type u,	_inst_1 : decidable_eq α,	l : list α	⊢ list.nil.diff l = list.nil
α : Type u,	β : Type v,	γ : Type w,	f : option α → β → γ,	bs : list β	⊢ list.map₂_right' f list.nil bs = (list.map (f option.none) bs, list.nil α)
α : Type u,	β : Type v,	γ : Type w,	f : option α → β → γ	⊢ list.map₂_right' f list.nil list.nil = (list.map (f option.none) list.nil, list.nil α)
α : Type u,	β : Type v,	γ : Type w,	f : option α → β → γ,	bs_hd : β,	bs_tl : list β	⊢ list.map₂_right' f list.nil (bs_hd :: bs_tl) = (list.map (f option.none) (bs_hd :: bs_tl), list.nil α)
α : Type u,	β : Type v,	γ : Type w,	f : option α → β → γ,	bs : list β	⊢ list.map₂_right' f list.nil bs = (list.map (f option.none) bs, list.nil α)
α : Type u,	a : α,	l : list α	⊢ l.concat a = l ++ [a]
α : Type u,	a : α,	l : list α	⊢ l.concat a = l ++ [a]
α : Type u,	a : α,	l : list α	⊢ l.concat a = l ++ [a]
α : Type u,	a : α	⊢ list.nil.concat a = list.nil ++ [a]
α : Type u,	a l_hd : α,	l_tl : list α,	l_ih : l_tl.concat a = l_tl ++ [a]	⊢ (l_hd :: l_tl).concat a = l_hd :: l_tl ++ [a]
α : Type u,	a : α	⊢ [a] = list.nil ++ [a]
α : Type u,	a l_hd : α,	l_tl : list α,	l_ih : l_tl.concat a = l_tl ++ [a]	⊢ l_hd :: (l_tl ++ [a]) = l_hd :: l_tl ++ [a]
α : Type u,	a : α,	l : list α	⊢ l.concat a = l ++ [a]
α : Type u,	a : α,	l₁ l₂ : list α	⊢ l₁.concat a ++ l₂ = l₁ ++ a :: l₂
α : Type u,	a : α,	l : list α,	h : l ++ [a] ≠ list.nil	⊢ (l ++ [a]).last h = a
α : Type u,	a : α,	l : list α,	h : l ++ [a] ≠ list.nil	⊢ (l ++ [a]).last h = a
α : Type u,	a l_hd : α,	l_tl : list α,	l_ih : ∀ (h : l_tl ++ [a] ≠ list.nil), (l_tl ++ [a]).last h = a,	h : l_hd :: l_tl ++ [a] ≠ list.nil	⊢ (l_hd :: l_tl ++ [a]).last h = a
α : Type u,	a : α,	h : list.nil ++ [a] ≠ list.nil	⊢ (list.nil ++ [a]).last h = a
α : Type u,	a : α,	l : list α,	h : a ∈ l	⊢ l ≠ list.nil
α : Type u,	a : α,	l : list α,	h : a ∈ l	⊢ l ≠ list.nil
α : Type u,	a : α,	l : list α,	h : a ∈ l,	e : l = list.nil	⊢ false
α : Type u,	a : α,	l : list α,	e : l = list.nil,	h : a ∈ list.nil	⊢ false
α : Type u,	a : α,	l : list α,	h : a ∈ l	⊢ l ≠ list.nil
α : Type u,	R : α → α → Prop,	tr : transitive R,	a : α,	l : list α,	b : α	⊢ list.pairwise R [b]
α : Type u,	R : α → α → Prop,	tr : transitive R,	a : α,	l : list α,	c : list.chain R a l	⊢ list.pairwise R (a :: l)
α : Type u,	R : α → α → Prop,	tr : transitive R,	a : α,	l : list α,	b : α	⊢ list.pairwise R [b]		case list.chain.cons	α : Type u,	R : α → α → Prop,	tr : transitive R,	a : α,	l : list α,	b c : α,	l : list α,	r : R b c,	p : list.chain R c l,	IH : list.pairwise R (c :: l)	⊢ list.pairwise R (b :: c :: l)
α : Type u,	R : α → α → Prop,	tr : transitive R,	a : α,	l : list α,	b c : α,	l : list α,	r : R b c,	p : list.chain R c l,	IH : list.pairwise R (c :: l)	⊢ ∀ (a' : α), a' ∈ c :: l → R b a'
α : Type u,	R : α → α → Prop,	tr : transitive R,	a : α,	l : list α,	b c : α,	l : list α,	r : R b c,	p : list.chain R c l,	IH : list.pairwise R (c :: l)	⊢ list.pairwise R (b :: c :: l)
α : Type u,	R : α → α → Prop,	tr : transitive R,	a : α,	l : list α,	b c : α,	l : list α,	r : R b c,	p : list.chain R c l,	IH : list.pairwise R (c :: l)	⊢ ∀ (x : α), x ∈ l → R b x
α : Type u,	R : α → α → Prop,	tr : transitive R,	a : α,	l : list α,	b c : α,	l : list α,	r : R b c,	p : list.chain R c l,	IH : list.pairwise R (c :: l)	⊢ ∀ (a : α), a ∈ l → R b a
α : Type u,	R : α → α → Prop,	chain'.append_overlap : ∀ {l₁ l₂ l₃ : list α}, list.chain' R (l₁ ++ l₂) → list.chain' R (l₂ ++ l₃) → l₂ ≠ list.nil → list.chain' R (l₁ ++ l₂ ++ l₃),	a b : α,	l₂ l₃ : list α,	h₁ : list.chain' R ([a] ++ b :: l₂),	h₂ : list.chain' R (b :: l₂ ++ l₃),	hn : b :: l₂ ≠ list.nil	⊢ list.chain' R ([a] ++ b :: l₂ ++ l₃)
α : Type u,	R : α → α → Prop,	a b : α,	l₂ l₃ : list α,	chain'.append_overlap : ∀ {l₁ l₂ l₃ : list α}, list.chain' R (l₁ ++ l₂) → list.chain' R (l₂ ++ l₃) → ¬l₂ = list.nil → list.chain' R (l₁ ++ (l₂ ++ l₃)),	h₁ : R a b ∧ list.chain' R (b :: l₂),	h₂ : list.chain' R (b :: (l₂ ++ l₃)),	hn : true	⊢ R a b ∧ list.chain' R (b :: (l₂ ++ l₃))
α : Type u,	R : α → α → Prop,	chain'.append_overlap : ∀ {l₁ l₂ l₃ : list α}, list.chain' R (l₁ ++ l₂) → list.chain' R (l₂ ++ l₃) → l₂ ≠ list.nil → list.chain' R (l₁ ++ l₂ ++ l₃),	a b : α,	l₁ : list α,	c : α,	l₂ l₃ : list α,	h₁ : list.chain' R (a :: b :: l₁ ++ c :: l₂),	h₂ : list.chain' R (c :: l₂ ++ l₃),	hn : c :: l₂ ≠ list.nil	⊢ list.chain' R (a :: b :: l₁ ++ c :: l₂ ++ l₃)
α : Type u,	R : α → α → Prop,	chain'.append_overlap : ∀ {l₁ l₂ l₃ : list α}, list.chain' R (l₁ ++ l₂) → list.chain' R (l₂ ++ l₃) → l₂ ≠ list.nil → list.chain' R (l₁ ++ l₂ ++ l₃),	a b : α,	l₁ : list α,	c : α,	l₂ l₃ : list α,	hn : c :: l₂ ≠ list.nil,	h₂ : list.chain' R (c :: (l₂ ++ l₃)),	h₁ : R a b ∧ list.chain' R (b :: (l₁ ++ c :: l₂))	⊢ R a b ∧ list.chain' R (b :: (l₁ ++ c :: l₂ ++ l₃))
α : Type u,	R : α → α → Prop,	chain'.append_overlap : ∀ {l₁ l₂ l₃ : list α}, list.chain' R (l₁ ++ l₂) → list.chain' R (l₂ ++ l₃) → l₂ ≠ list.nil → list.chain' R (l₁ ++ l₂ ++ l₃),	a b : α,	l₁ : list α,	c : α,	l₂ l₃ : list α,	hn : c :: l₂ ≠ list.nil,	h₂ : list.chain' R (c :: l₂ ++ l₃),	h₁ : R a b ∧ list.chain' R (b :: l₁ ++ c :: l₂)	⊢ R a b ∧ list.chain' R (b :: l₁ ++ c :: l₂ ++ l₃)
α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	l : {l // l.nodup}	⊢ ↑(l.val).nodup
α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	_x : {s // s.nodup},	_fun_match : ∀ (_a : {s // s.nodup}), ∃ (a : {l // l.nodup}), (λ (l : {l // l.nodup}), ⟨↑(l.val), _⟩) a = _a,	s : cycle α,	hs : s.nodup	⊢ ∃ (a : {l // l.nodup}), (λ (l : {l // l.nodup}), ⟨↑(l.val), _⟩) a = ⟨s, hs⟩
α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	_x : {s // s.nodup},	_fun_match : ∀ (_a : {s // s.nodup}), ∃ (a : {l // l.nodup}), (λ (l : {l // l.nodup}), ⟨↑(l.val), _⟩) a = _a,	s : list α,	hs : cycle.nodup (quotient.mk' s)	⊢ (λ (l : {l // l.nodup}), ⟨↑(l.val), _⟩) ⟨s, hs⟩ = ⟨quotient.mk' s, hs⟩
α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	_x : {s // s.nodup},	_fun_match : ∀ (_a : {s // s.nodup}), ∃ (a : {l // l.nodup}), (λ (l : {l // l.nodup}), ⟨↑(l.val), _⟩) a = _a,	s : list α,	hs : cycle.nodup (quotient.mk' s)	⊢ ∃ (a : {l // l.nodup}), (λ (l : {l // l.nodup}), ⟨↑(l.val), _⟩) a = ⟨quotient.mk' s, hs⟩
α : Type u_1,	C : list α → list α → Sort v,	H0 : Π (is : list α), C list.nil is,	H1 : Π (t : α) (ts is : list α), C ts (t :: is) → C is list.nil → C (t :: ts) is,	permutations_aux.rec : Π (l₁ l₂ : list α), C l₁ l₂,	t : α,	ts is : list α	⊢ prod.lex has_lt.lt has_lt.lt ((ts.length + is.length).succ, ts.length) (ts.length.succ + is.length, (t :: ts).length)
α : Type u_1,	C : list α → list α → Sort v,	H0 : Π (is : list α), C list.nil is,	H1 : Π (t : α) (ts is : list α), C ts (t :: is) → C is list.nil → C (t :: ts) is,	permutations_aux.rec : Π (l₁ l₂ : list α), C l₁ l₂,	t : α,	ts is : list α	⊢ prod.lex has_lt.lt has_lt.lt ((ts.length + is.length).succ, ts.length) ((ts.length + is.length).succ, (t :: ts).length)
α : Type u_1,	C : list α → list α → Sort v,	H0 : Π (is : list α), C list.nil is,	H1 : Π (t : α) (ts is : list α), C ts (t :: is) → C is list.nil → C (t :: ts) is,	permutations_aux.rec : Π (l₁ l₂ : list α), C l₁ l₂,	t : α,	ts is : list α	⊢ prod.lex has_lt.lt has_lt.lt ((ts.length + is.length).succ, ts.length) (ts.length.succ + is.length, (t :: ts).length)
α : Type u_1,	l : list α,	x y : α,	h : x ∈+ y :: l,	hx : x ≠ y	⊢ x ∈+ l
α : Type u_1,	β : Type u_2,	R : α → β → Prop,	l : list α,	l₁ l₂ : list β,	h : list.forall₂ R l (l₁ ++ l₂),	h' : list.forall₂ R (list.take l₁.length l) (list.take l₁.length (l₁ ++ l₂))	⊢ list.forall₂ R (list.take l₁.length l) l₁
α : Type u_1,	β : Type u_2,	R S : α → β → Prop,	H : ∀ (a : α) (b : β), R a b → S a b,	l₁ : list α,	l₂ : list β,	h : list.forall₂ R l₁ l₂	⊢ list.forall₂ S l₁ l₂
α : Type u_1,	β : Type u_2,	R S : α → β → Prop,	H : ∀ (a : α) (b : β), R a b → S a b,	l₁ : list α,	l₂ : list β,	h : list.forall₂ R l₁ l₂	⊢ list.forall₂ S l₁ l₂
α : Type u_1,	β : Type u_2,	R S : α → β → Prop,	H : ∀ (a : α) (b : β), R a b → S a b,	l₁ : list α,	l₂ : list β	⊢ list.forall₂ S list.nil list.nil
α : Type u_1,	β : Type u_2,	R S : α → β → Prop,	H : ∀ (a : α) (b : β), R a b → S a b,	l₁ : list α,	l₂ : list β,	h_a : α,	h_b : β,	h_l₁ : list α,	h_l₂ : list β,	h_ᾰ : R h_a h_b,	h_ᾰ_1 : list.forall₂ R h_l₁ h_l₂,	h_ih : list.forall₂ S h_l₁ h_l₂	⊢ list.forall₂ S (h_a :: h_l₁) (h_b :: h_l₂)
α : Type u_1,	β : Type u_2,	R S : α → β → Prop,	H : ∀ (a : α) (b : β), R a b → S a b,	l₁ : list α,	l₂ : list β,	h_a : α,	h_b : β,	h_l₁ : list α,	h_l₂ : list β,	h_ᾰ : R h_a h_b,	h_ᾰ_1 : list.forall₂ R h_l₁ h_l₂,	h_ih : list.forall₂ S h_l₁ h_l₂	⊢ S h_a h_b
α : Type u_1,	β : Type u_2,	R S : α → β → Prop,	H : ∀ (a : α) (b : β), R a b → S a b,	l₁ : list α,	l₂ : list β,	h_a : α,	h_b : β,	h_l₁ : list α,	h_l₂ : list β,	h_ᾰ : R h_a h_b,	h_ᾰ_1 : list.forall₂ R h_l₁ h_l₂,	h_ih : list.forall₂ S h_l₁ h_l₂	⊢ list.forall₂ S h_l₁ h_l₂
α : Type u_1,	β : Type u_2,	R S : α → β → Prop,	H : ∀ (a : α) (b : β), R a b → S a b,	l₁ : list α,	l₂ : list β,	h : list.forall₂ R l₁ l₂	⊢ list.forall₂ S l₁ l₂
α : Type u_1,	β : Type u_2,	γ : Type u_3,	r : α → β → Prop,	f : γ → α,	forall₂_map_left_iff : ∀ {l : list γ} {u : list β}, list.forall₂ r (list.map f l) u ↔ list.forall₂ (λ (c : γ) (b : β), r (f c) b) l u,	_x : list β	⊢ list.forall₂ r (list.map f list.nil) _x ↔ list.forall₂ (λ (c : γ) (b : β), r (f c) b) list.nil _x
α : Type u_1,	β : Type u_2,	γ : Type u_3,	r : α → β → Prop,	f : γ → α,	forall₂_map_left_iff : ∀ {l : list γ} {u : list β}, list.forall₂ r (list.map f l) u ↔ list.forall₂ (λ (c : γ) (b : β), r (f c) b) l u,	a : γ,	l : list γ,	_x : list β	⊢ list.forall₂ r (list.map f (a :: l)) _x ↔ list.forall₂ (λ (c : γ) (b : β), r (f c) b) (a :: l) _x
α : Type u,	_inst_1 : inhabited α,	k : ℕ	⊢ list.func.get k list.nil = inhabited.default α
α : Type u,	_inst_1 : inhabited α	⊢ list.func.get 0 list.nil = inhabited.default α
α : Type u,	_inst_1 : inhabited α,	k : ℕ	⊢ list.func.get k.succ list.nil = inhabited.default α
α : Type u,	_inst_1 : inhabited α,	k : ℕ	⊢ list.func.get k list.nil = inhabited.default α
α : Type u,	r : α → α → Prop,	_inst_1 : is_trichotomous α r,	l₁ : list α,	_match : ∀ (_a b : list α), list.lex r _a b ∨ _a = b ∨ list.lex r b _a,	a : α,	l₁ : list α,	b : α,	l₂ : list α	⊢ list.lex r (a :: l₁) (b :: l₂) ∨ a :: l₁ = b :: l₂ ∨ list.lex r (b :: l₂) (a :: l₁)
α : Type u,	r : α → α → Prop,	_inst_1 : is_trichotomous α r,	l₁ : list α,	_match : ∀ (_a b : list α), list.lex r _a b ∨ _a = b ∨ list.lex r b _a,	a : α,	l₁ : list α,	b : α,	l₂ : list α,	ab : r a b	⊢ list.lex r (a :: l₁) (b :: l₂) ∨ a :: l₁ = b :: l₂ ∨ list.lex r (b :: l₂) (a :: l₁)		α : Type u,	r : α → α → Prop,	_inst_1 : is_trichotomous α r,	l₁ : list α,	_match : ∀ (_a b : list α), list.lex r _a b ∨ _a = b ∨ list.lex r b _a,	a : α,	l₁ l₂ : list α	⊢ list.lex r (a :: l₁) (a :: l₂) ∨ a :: l₁ = a :: l₂ ∨ list.lex r (a :: l₂) (a :: l₁)		α : Type u,	r : α → α → Prop,	_inst_1 : is_trichotomous α r,	l₁ : list α,	_match : ∀ (_a b : list α), list.lex r _a b ∨ _a = b ∨ list.lex r b _a,	a : α,	l₁ : list α,	b : α,	l₂ : list α,	ab : r b a	⊢ list.lex r (a :: l₁) (b :: l₂) ∨ a :: l₁ = b :: l₂ ∨ list.lex r (b :: l₂) (a :: l₁)
α : Type u,	r : α → α → Prop,	_inst_1 : is_trichotomous α r,	l₁ : list α,	_match : ∀ (_a b : list α), list.lex r _a b ∨ _a = b ∨ list.lex r b _a,	a : α,	l₁ : list α,	b : α,	l₂ : list α,	ab : r a b	⊢ list.lex r (a :: l₁) (b :: l₂) ∨ a :: l₁ = b :: l₂ ∨ list.lex r (b :: l₂) (a :: l₁)
α : Type u,	r : α → α → Prop,	_inst_1 : is_trichotomous α r,	l₁ : list α,	_match : ∀ (_a b : list α), list.lex r _a b ∨ _a = b ∨ list.lex r b _a,	a : α,	l₁ l₂ : list α	⊢ list.lex r (a :: l₁) (a :: l₂) ∨ a :: l₁ = a :: l₂ ∨ list.lex r (a :: l₂) (a :: l₁)
α : Type u,	r : α → α → Prop,	_inst_1 : is_trichotomous α r,	l₁ : list α,	_match : ∀ (_a b : list α), list.lex r _a b ∨ _a = b ∨ list.lex r b _a,	a : α,	l₁ l₂ : list α	⊢ list.lex r (a :: l₁) (a :: l₂) ∨ a :: l₁ = a :: l₂ ∨ list.lex r (a :: l₂) (a :: l₁)		α : Type u,	r : α → α → Prop,	_inst_1 : is_trichotomous α r,	l₁ : list α,	_match : ∀ (_a b : list α), list.lex r _a b ∨ _a = b ∨ list.lex r b _a,	a : α,	l₁ : list α,	b : α,	l₂ : list α,	ab : r b a	⊢ list.lex r (a :: l₁) (b :: l₂) ∨ a :: l₁ = b :: l₂ ∨ list.lex r (b :: l₂) (a :: l₁)
α : Type u,	r : α → α → Prop,	_inst_1 : is_trichotomous α r,	l₁ : list α,	_match : ∀ (_a b : list α), list.lex r _a b ∨ _a = b ∨ list.lex r b _a,	a : α,	l₁ : list α,	b : α,	l₂ : list α,	ab : r b a	⊢ list.lex r (a :: l₁) (b :: l₂) ∨ a :: l₁ = b :: l₂ ∨ list.lex r (b :: l₂) (a :: l₁)
α : Type u_1,	_inst_1 : decidable_eq α,	l : list α,	H : l.nodup,	i : fin l.length	⊢ (λ (x : {x // x ∈ l}), ⟨list.index_of ↑x l, _⟩) ((λ (i : fin l.length), ⟨l.nth_le ↑i _, _⟩) i) = i
α : Type u_1,	_inst_1 : decidable_eq α,	l : list α,	H : l.nodup,	x : {x // x ∈ l}	⊢ (λ (i : fin l.length), ⟨l.nth_le ↑i _, _⟩) ((λ (x : {x // x ∈ l}), ⟨list.index_of ↑x l, _⟩) x) = x
α : Type u,	n : ℕ,	c : α	⊢ list.of_fn (λ (i : fin 0), c) = list.repeat c 0
α : Type u,	n : ℕ,	c : α,	n : ℕ,	ihn : list.of_fn (λ (i : fin n), c) = list.repeat c n	⊢ list.of_fn (λ (i : fin n.succ), c) = list.repeat c n.succ
α : Type u_1,	R : α → α → Prop,	s : symmetric R,	a : α,	l₁ l₂ : list α	⊢ list.pairwise R (l₁ ++ ([a] ++ l₂)) ↔ list.pairwise R ([a] ++ l₁ ++ l₂)
α : Type u_1,	R : α → α → Prop,	s : symmetric R,	a : α,	l₁ l₂ : list α	⊢ list.pairwise R (l₁ ++ ([a] ++ l₂)) ↔ list.pairwise R ([a] ++ l₁ ++ l₂)
α : Type u_1,	R : α → α → Prop,	s : symmetric R,	a : α,	l₁ l₂ : list α	⊢ (list.pairwise R ([a] ++ l₁) ∧ list.pairwise R l₂ ∧ ∀ (x : α), x ∈ l₁ ++ [a] → ∀ (y : α), y ∈ l₂ → R x y) ↔ list.pairwise R ([a] ++ l₁) ∧ list.pairwise R l₂ ∧ ∀ (x : α), x ∈ [a] ++ l₁ → ∀ (y : α), y ∈ l₂ → R x y
α : Type u_1,	R : α → α → Prop,	_inst_1 : decidable_rel R,	pw_filter_sublist : ∀ (l : list α), list.pw_filter R l <+ l,	x : α,	l : list α	⊢ list.pw_filter R (x :: l) <+ x :: l
α : Type u_1,	R : α → α → Prop,	_inst_1 : decidable_rel R,	pw_filter_sublist : ∀ (l : list α), list.pw_filter R l <+ l,	x : α,	l : list α,	h : ∀ (y : α), y ∈ list.pw_filter R l → R x y	⊢ list.pw_filter R (x :: l) <+ x :: l
α : Type u_1,	R : α → α → Prop,	_inst_1 : decidable_rel R,	pw_filter_sublist : ∀ (l : list α), list.pw_filter R l <+ l,	x : α,	l : list α,	h : ∀ (y : α), y ∈ list.pw_filter R l → R x y	⊢ list.pw_filter R (x :: l) <+ x :: l		α : Type u_1,	R : α → α → Prop,	_inst_1 : decidable_rel R,	pw_filter_sublist : ∀ (l : list α), list.pw_filter R l <+ l,	x : α,	l : list α,	h : ¬∀ (y : α), y ∈ list.pw_filter R l → R x y	⊢ list.pw_filter R (x :: l) <+ x :: l
α : Type u_1,	R : α → α → Prop,	_inst_1 : decidable_rel R,	pw_filter_sublist : ∀ (l : list α), list.pw_filter R l <+ l,	x : α,	l : list α,	h : ∀ (y : α), y ∈ list.pw_filter R l → R x y	⊢ x :: list.pw_filter R l <+ x :: l
α : Type u_1,	R : α → α → Prop,	_inst_1 : decidable_rel R,	pw_filter_sublist : ∀ (l : list α), list.pw_filter R l <+ l,	x : α,	l : list α,	h : ¬∀ (y : α), y ∈ list.pw_filter R l → R x y	⊢ list.pw_filter R (x :: l) <+ x :: l
α : Type u_1,	R : α → α → Prop,	_inst_1 : decidable_rel R,	pw_filter_sublist : ∀ (l : list α), list.pw_filter R l <+ l,	x : α,	l : list α,	h : ¬∀ (y : α), y ∈ list.pw_filter R l → R x y	⊢ list.pw_filter R l <+ x :: l
α : Type u_1,	R S : α → α → Prop,	l : list α,	hR : list.pairwise R l,	hS : list.pairwise S l	⊢ list.pairwise (λ (a b : α), R a b ∧ S a b) l
α : Type u_1,	R S : α → α → Prop,	l : list α,	_x : list.pairwise R l ∧ list.pairwise S l,	_fun_match : list.pairwise R l ∧ list.pairwise S l → list.pairwise (λ (a b : α), R a b ∧ S a b) l,	hR : list.pairwise R l,	hS : list.pairwise S l	⊢ list.pairwise (λ (a b : α), R a b ∧ S a b) l
α : Type u_1,	R S : α → α → Prop,	l : list α,	hR : list.pairwise R l,	hS : list.pairwise S l	⊢ list.pairwise (λ (a b : α), R a b ∧ S a b) l
α : Type u_1,	R S : α → α → Prop,	l : list α,	hS : list.pairwise S list.nil	⊢ list.pairwise (λ (a b : α), R a b ∧ S a b) list.nil
α : Type u_1,	R S : α → α → Prop,	l : list α,	a : α,	l : list α,	R1 : ∀ (a' : α), a' ∈ l → R a a',	R2 : list.pairwise R l,	IH : list.pairwise S l → list.pairwise (λ (a b : α), R a b ∧ S a b) l,	hS : list.pairwise S (a :: l)	⊢ list.pairwise (λ (a b : α), R a b ∧ S a b) (a :: l)
α : Type u_1,	R S : α → α → Prop,	l : list α,	a : α,	l : list α,	R1 : ∀ (a' : α), a' ∈ l → R a a',	R2 : list.pairwise R l,	IH : list.pairwise S l → list.pairwise (λ (a b : α), R a b ∧ S a b) l,	hS : (∀ (a' : α), a' ∈ l → S a a') ∧ list.pairwise S l	⊢ (∀ (a' : α), a' ∈ l → R a a' ∧ S a a') ∧ list.pairwise (λ (a b : α), R a b ∧ S a b) l
α : Type uu,	_inst_1 : decidable_eq α,	l : list α,	x : α	⊢ list.count (x :: l) (list.permutations'_aux x l) = (list.take_while (eq x) l).length + 1
α : Type uu,	_inst_1 : decidable_eq α,	x : α	⊢ list.count [x] (list.permutations'_aux x list.nil) = (list.take_while (eq x) list.nil).length + 1		case list.cons	α : Type uu,	_inst_1 : decidable_eq α,	y : α,	l : list α,	IH : ∀ (x : α), list.count (x :: l) (list.permutations'_aux x l) = (list.take_while (eq x) l).length + 1,	x : α	⊢ list.count (x :: y :: l) (list.permutations'_aux x (y :: l)) = (list.take_while (eq x) (y :: l)).length + 1
α : Type uu,	_inst_1 : decidable_eq α,	x : α	⊢ list.count [x] (list.permutations'_aux x list.nil) = (list.take_while (eq x) list.nil).length + 1
α : Type uu,	_inst_1 : decidable_eq α,	y : α,	l : list α,	IH : ∀ (x : α), list.count (x :: l) (list.permutations'_aux x l) = (list.take_while (eq x) l).length + 1,	x : α	⊢ list.count (x :: y :: l) (list.permutations'_aux x (y :: l)) = (list.take_while (eq x) (y :: l)).length + 1
α : Type uu,	_inst_1 : decidable_eq α,	y : α,	l : list α,	IH : ∀ (x : α), list.count (x :: l) (list.permutations'_aux x l) = (list.take_while (eq x) l).length + 1,	x : α	⊢ (list.count (x :: y :: l) (list.map (list.cons y) (list.permutations'_aux x l))).succ = (list.take_while (eq x) (y :: l)).length + 1
α : Type uu,	_inst_1 : decidable_eq α,	y : α,	l : list α,	IH : ∀ (x : α), list.count (x :: l) (list.permutations'_aux x l) = (list.take_while (eq x) l).length + 1,	x : α,	hx : x = y	⊢ (list.count (x :: y :: l) (list.map (list.cons y) (list.permutations'_aux x l))).succ = (list.take_while (eq x) (y :: l)).length + 1
α : Type uu,	_inst_1 : decidable_eq α,	y : α,	l : list α,	IH : ∀ (x : α), list.count (x :: l) (list.permutations'_aux x l) = (list.take_while (eq x) l).length + 1,	x : α,	hx : x = y	⊢ (list.count (x :: y :: l) (list.map (list.cons y) (list.permutations'_aux x l))).succ = (list.take_while (eq x) (y :: l)).length + 1		α : Type uu,	_inst_1 : decidable_eq α,	y : α,	l : list α,	IH : ∀ (x : α), list.count (x :: l) (list.permutations'_aux x l) = (list.take_while (eq x) l).length + 1,	x : α,	hx : ¬x = y	⊢ (list.count (x :: y :: l) (list.map (list.cons y) (list.permutations'_aux x l))).succ = (list.take_while (eq x) (y :: l)).length + 1
α : Type uu,	_inst_1 : decidable_eq α,	l : list α,	IH : ∀ (x : α), list.count (x :: l) (list.permutations'_aux x l) = (list.take_while (eq x) l).length + 1,	x : α	⊢ (list.count (x :: x :: l) (list.map (list.cons x) (list.permutations'_aux x l))).succ = (list.take_while (eq x) (x :: l)).length + 1
α : Type uu,	_inst_1 : decidable_eq α,	y : α,	l : list α,	IH : ∀ (x : α), list.count (x :: l) (list.permutations'_aux x l) = (list.take_while (eq x) l).length + 1,	x : α,	hx : ¬x = y	⊢ (list.count (x :: y :: l) (list.map (list.cons y) (list.permutations'_aux x l))).succ = (list.take_while (eq x) (y :: l)).length + 1
α : Type uu,	_inst_1 : decidable_eq α,	y : α,	l : list α,	IH : ∀ (x : α), list.count (x :: l) (list.permutations'_aux x l) = (list.take_while (eq x) l).length + 1,	x : α,	hx : ¬x = y	⊢ (list.count (x :: y :: l) (list.map (list.cons y) (list.permutations'_aux x l))).succ = (ite (x = y) (y :: list.take_while (eq x) l) list.nil).length + 1
α : Type uu,	_inst_1 : decidable_eq α,	y : α,	l : list α,	IH : ∀ (x : α), list.count (x :: l) (list.permutations'_aux x l) = (list.take_while (eq x) l).length + 1,	x : α,	hx : ¬x = y	⊢ (list.count (x :: y :: l) (list.map (list.cons y) (list.permutations'_aux x l))).succ = list.nil.length + 1
α : Type uu,	_inst_1 : decidable_eq α,	y : α,	l : list α,	IH : ∀ (x : α), list.count (x :: l) (list.permutations'_aux x l) = (list.take_while (eq x) l).length + 1,	x : α,	hx : ¬x = y	⊢ (list.count (x :: y :: l) (list.map (list.cons y) list.nil)).succ = list.nil.length + 1		case list.cons	α : Type uu,	_inst_1 : decidable_eq α,	y : α,	l : list α,	IH : ∀ (x : α), list.count (x :: l) (list.permutations'_aux x l) = (list.take_while (eq x) l).length + 1,	x : α,	hx : ¬x = y,	a : list α,	as : list (list α)	⊢ (list.count (x :: y :: l) (list.map (list.cons y) (a :: as))).succ = list.nil.length + 1
α : Type uu,	_inst_1 : decidable_eq α,	y : α,	l : list α,	IH : ∀ (x : α), list.count (x :: l) (list.permutations'_aux x l) = (list.take_while (eq x) l).length + 1,	x : α,	hx : ¬x = y	⊢ (list.count (x :: y :: l) (list.map (list.cons y) list.nil)).succ = list.nil.length + 1
α : Type uu,	_inst_1 : decidable_eq α,	y : α,	l : list α,	IH : ∀ (x : α), list.count (x :: l) (list.permutations'_aux x l) = (list.take_while (eq x) l).length + 1,	x : α,	hx : ¬x = y,	a : list α,	as : list (list α)	⊢ (list.count (x :: y :: l) (list.map (list.cons y) (a :: as))).succ = list.nil.length + 1
α : Type uu,	_inst_1 : decidable_eq α,	y : α,	l : list α,	IH : ∀ (x : α), list.count (x :: l) (list.permutations'_aux x l) = (list.take_while (eq x) l).length + 1,	x : α,	hx : ¬x = y,	a : list α,	as : list (list α)	⊢ x :: y :: l ∉ list.map (list.cons y) (a :: as)
α : Type uu,	sublists_perm_sublists' : ∀ (l : list α), l.sublists ~ l.sublists',	a : α,	l : list α,	IH : l.sublists ~ l.sublists' := sublists_perm_sublists' l	⊢ (a :: l).sublists ~ (a :: l).sublists'
α : Type uu,	sublists_perm_sublists' : ∀ (l : list α), l.sublists ~ l.sublists',	a : α,	l : list α,	IH : l.sublists ~ l.sublists' := sublists_perm_sublists' l	⊢ (a :: l).sublists ~ l.sublists' ++ list.map (list.cons a) l.sublists'
α : Type uu,	sublists_perm_sublists' : ∀ (l : list α), l.sublists ~ l.sublists',	a : α,	l : list α,	IH : l.sublists ~ l.sublists' := sublists_perm_sublists' l	⊢ (a :: l).sublists ~ (a :: l).sublists'
pairwise_lt_range' : ∀ (s n : ℕ), list.pairwise has_lt.lt (list.range' s n),	s n : ℕ	⊢ transitive has_lt.lt
α : Type u,	l : list α,	n m : ℕ	⊢ (l.rotate n).rotate m = l.rotate (n + m)
α : Type u_1,	β : Type u_2,	γ : Type u_3,	f : α → β → γ,	l : list α,	l' : list β,	n : ℕ,	h : l.length = l'.length	⊢ (list.zip_with f l l').rotate n = list.zip_with f (l.rotate n) (l'.rotate n)
α : Type u_1,	β : Type u_2,	γ : Type u_3,	f : α → β → γ,	l : list α,	l' : list β,	n : ℕ,	h : l.length = l'.length	⊢ (list.drop (n % l'.length) l).length = (list.drop (n % l'.length) l').length
α : Type u,	l : list α,	hl : l.nodup,	n : ℕ	⊢ l.rotate n = l ↔ n % l.length = 0 ∨ l = list.nil
α : Type u,	l : list α,	hl : l.nodup,	n : ℕ	⊢ l.rotate n = l → n % l.length = 0 ∨ l = list.nil
α : Type u,	l : list α,	hl : l.nodup,	n : ℕ,	h : l.rotate n = l	⊢ n % l.length = 0 ∨ l = list.nil
α : Type u,	l : list α,	hl : l.nodup,	n : ℕ,	h : l.rotate n = l,	hl' : 0 = l.length	⊢ n % l.length = 0 ∨ l = list.nil		case or.inr	α : Type u,	l : list α,	hl : l.nodup,	n : ℕ,	h : l.rotate n = l,	hl' : 0 < l.length	⊢ n % l.length = 0 ∨ l = list.nil
α : Type u,	l : list α,	hl : l.nodup,	n : ℕ,	h : l.rotate n = l,	hl' : 0 = l.length	⊢ n % l.length = 0 ∨ l = list.nil
α : Type u,	l : list α,	hl : l.nodup,	n : ℕ,	h : l.rotate n = l,	hl' : 0 < l.length	⊢ n % l.length = 0 ∨ l = list.nil
α : Type u,	l : list α,	hl : l.nodup,	n : ℕ,	h : l.rotate n = l,	hl' : 0 < l.length	⊢ n % l.length = 0
α : Type u,	l : list α,	n : ℕ,	h : l.rotate n = l,	hl' : 0 < l.length,	hl : ∀ (i j : ℕ) (h₁ : i < l.length) (h₂ : j < l.length), l.nth_le i h₁ = l.nth_le j h₂ → i = j	⊢ n % l.length = 0
α : Type u,	l : list α,	n : ℕ,	h : l.rotate n = l,	hl' : 0 < l.length,	hl : ∀ (i j : ℕ) (h₁ : i < l.length) (h₂ : j < l.length), l.nth_le i h₁ = l.nth_le j h₂ → i = j	⊢ l.nth_le (n % l.length) _ = l.nth_le 0 hl'
α : Type u,	l : list α,	n : ℕ,	h : l.rotate n = l,	hl' : 0 < l.length,	hl : ∀ (i j : ℕ) (h₁ : i < l.length) (h₂ : j < l.length), l.nth_le i h₁ = l.nth_le j h₂ → i = j	⊢ (l.rotate n).nth_le ((l.length - n % l.length + n % l.length) % l.length) _ = l.nth_le 0 hl'
α : Type u,	l : list α,	hl : l.nodup,	n : ℕ	⊢ l.rotate n = l → n % l.length = 0 ∨ l = list.nil		α : Type u,	l : list α,	hl : l.nodup,	n : ℕ	⊢ n % l.length = 0 ∨ l = list.nil → l.rotate n = l
α : Type u,	l : list α,	hl : l.nodup,	n : ℕ	⊢ n % l.length = 0 ∨ l = list.nil → l.rotate n = l
α : Type u,	l : list α,	hl : l.nodup,	n : ℕ,	h : n % l.length = 0	⊢ l.rotate n = l
α : Type u,	l : list α,	hl : l.nodup,	n : ℕ,	h : n % l.length = 0	⊢ l.rotate n = l		α : Type u,	l : list α,	hl : l.nodup,	n : ℕ,	h : l = list.nil	⊢ l.rotate n = l
α : Type u,	l : list α,	hl : l.nodup,	n : ℕ,	h : n % l.length = 0	⊢ l.rotate 0 = l
α : Type u,	l : list α,	hl : l.nodup,	n : ℕ,	h : l = list.nil	⊢ l.rotate n = l
α : Type u,	l : list α,	n : ℕ,	hn : n < l.cyclic_permutations.length	⊢ l.cyclic_permutations.nth_le n hn = l.rotate n
α : Type u,	n : ℕ,	hn : n < list.nil.cyclic_permutations.length	⊢ list.nil.cyclic_permutations.nth_le n hn = list.nil.rotate n		α : Type u,	l : list α,	n : ℕ,	hn : n < l.cyclic_permutations.length,	h : l ≠ list.nil	⊢ l.cyclic_permutations.nth_le n hn = l.rotate n
α : Type u,	n : ℕ,	hn : n < list.nil.cyclic_permutations.length	⊢ list.nil.cyclic_permutations.nth_le n hn = list.nil.rotate n
α : Type u,	l : list α,	n : ℕ,	hn : n < l.cyclic_permutations.length,	h : l ≠ list.nil	⊢ l.cyclic_permutations.nth_le n hn = l.rotate n
α : Type u,	l : list α,	n : ℕ,	hn : n < l.cyclic_permutations.length,	h : l ≠ list.nil,	hn : n < l.length	⊢ l.cyclic_permutations.nth_le n hn = l.rotate n
α : Type u,	l : list α	⊢ l.rotate' l.length = l
α : Type u,	l : list α	⊢ list.drop l.length l ++ list.take l.length l = l
α : Type u,	l : list α	⊢ l.rotate' l.length = l
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	a : α,	b : β a	⊢ ∀ (a_1 b_1 : sigma β), b_1 ∈ dite (a = a_1.fst) (λ (h : a = a_1.fst), option.some ⟨a, b⟩) (λ (h : ¬a = a_1.fst), option.none) → a_1.fst = b_1.fst
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	a : α,	b : β a	⊢ ∀ (a_1 b_1 : sigma β), b_1 ∈ dite (a = a_1.fst) (λ (h : a = a_1.fst), option.some ⟨a, b⟩) (λ (h : ¬a = a_1.fst), option.none) → a_1.fst = b_1.fst
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	a : α,	b : β a	⊢ ∀ (a_1 b_1 : sigma β), b_1 ∈ dite (a = a_1.fst) (λ (h : a = a_1.fst), option.some ⟨a, b⟩) (λ (h : ¬a = a_1.fst), option.none) → a_1.fst = b_1.fst
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	a : α,	b : β a	⊢ ∀ (a_1 b_1 : sigma β), b_1 ∈ dite (a = a_1.fst) (λ (h : a = a_1.fst), option.some ⟨a, b⟩) (λ (h : ¬a = a_1.fst), option.none) → a_1.fst = b_1.fst
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	a : α,	b : β a,	a₁ : α,	b₂ : β a₁,	a₂ : α,	b₂ : β a₂	⊢ ⟨a₂, b₂⟩ ∈ ite (a = a₁) (option.some ⟨a, b⟩) option.none → a₁ = a₂
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	a : α,	b : β a,	a₁ : α,	b₂ : β a₁,	a₂ : α,	b₂ : β a₂,	h : a = a₁	⊢ ⟨a₂, b₂⟩ ∈ option.some ⟨a, b⟩ → a₁ = a₂
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	a : α,	b : β a,	a₁ : α,	b₂ : β a₁,	a₂ : α,	b₂ : β a₂,	h : ¬a = a₁	⊢ ⟨a₂, b₂⟩ ∈ option.none → a₁ = a₂
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	a : α,	b : β a,	a₁ : α,	b₂ : β a₁,	a₂ : α,	b₂ : β a₂	⊢ ⟨a₂, b₂⟩ ∈ dite (a = ⟨a₁, b₂⟩.fst) (λ (h : a = ⟨a₁, b₂⟩.fst), option.some ⟨a, b⟩) (λ (h : ¬a = ⟨a₁, b₂⟩.fst), option.none) → ⟨a₁, b₂⟩.fst = ⟨a₂, b₂⟩.fst
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	a : α,	l : list (sigma β)	⊢ (list.kerase a l).keys = l.keys.erase a
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	l₁ l₂ : list (sigma β),	p : l₁ ~ l₂,	l : list (sigma β)	⊢ l₁.kunion l ~ l₂.kunion l
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	l₁ l₂ l : list (sigma β)	⊢ list.nil.kunion l ~ list.nil.kunion l
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	l₁ l₂ l : list (sigma β)	⊢ list.nil.kunion l ~ list.nil.kunion l		case list.perm.cons	α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	l₁ l₂ : list (sigma β),	p_x : sigma β,	p_l₁ p_l₂ : list (sigma β),	p_ᾰ : p_l₁ ~ p_l₂,	p_ih : ∀ (l : list (sigma β)), p_l₁.kunion l ~ p_l₂.kunion l,	l : list (sigma β)	⊢ (p_x :: p_l₁).kunion l ~ (p_x :: p_l₂).kunion l		case list.perm.swap	α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	l₁ l₂ : list (sigma β),	p_x p_y : sigma β,	p_l l : list (sigma β)	⊢ (p_y :: p_x :: p_l).kunion l ~ (p_x :: p_y :: p_l).kunion l		case list.perm.trans	α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	l₁ l₂ p_l₁ p_l₂ p_l₃ : list (sigma β),	p_ᾰ : p_l₁ ~ p_l₂,	p_ᾰ_1 : p_l₂ ~ p_l₃,	p_ih_ᾰ : ∀ (l : list (sigma β)), p_l₁.kunion l ~ p_l₂.kunion l,	p_ih_ᾰ_1 : ∀ (l : list (sigma β)), p_l₂.kunion l ~ p_l₃.kunion l,	l : list (sigma β)	⊢ p_l₁.kunion l ~ p_l₃.kunion l
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	l₁ l₂ : list (sigma β),	p_x : sigma β,	p_l₁ p_l₂ : list (sigma β),	p_ᾰ : p_l₁ ~ p_l₂,	p_ih : ∀ (l : list (sigma β)), p_l₁.kunion l ~ p_l₂.kunion l,	l : list (sigma β)	⊢ (p_x :: p_l₁).kunion l ~ (p_x :: p_l₂).kunion l		case list.perm.swap	α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	l₁ l₂ : list (sigma β),	p_x p_y : sigma β,	p_l l : list (sigma β)	⊢ (p_y :: p_x :: p_l).kunion l ~ (p_x :: p_y :: p_l).kunion l		case list.perm.trans	α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	l₁ l₂ p_l₁ p_l₂ p_l₃ : list (sigma β),	p_ᾰ : p_l₁ ~ p_l₂,	p_ᾰ_1 : p_l₂ ~ p_l₃,	p_ih_ᾰ : ∀ (l : list (sigma β)), p_l₁.kunion l ~ p_l₂.kunion l,	p_ih_ᾰ_1 : ∀ (l : list (sigma β)), p_l₂.kunion l ~ p_l₃.kunion l,	l : list (sigma β)	⊢ p_l₁.kunion l ~ p_l₃.kunion l
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	l₁ l₂ : list (sigma β),	hd : sigma β,	tl₁ tl₂ : list (sigma β),	p : tl₁ ~ tl₂,	ih : ∀ (l : list (sigma β)), tl₁.kunion l ~ tl₂.kunion l,	l : list (sigma β)	⊢ (hd :: tl₁).kunion l ~ (hd :: tl₂).kunion l
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	l₁ l₂ : list (sigma β),	p_x p_y : sigma β,	p_l l : list (sigma β)	⊢ (p_y :: p_x :: p_l).kunion l ~ (p_x :: p_y :: p_l).kunion l		case list.perm.trans	α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	l₁ l₂ p_l₁ p_l₂ p_l₃ : list (sigma β),	p_ᾰ : p_l₁ ~ p_l₂,	p_ᾰ_1 : p_l₂ ~ p_l₃,	p_ih_ᾰ : ∀ (l : list (sigma β)), p_l₁.kunion l ~ p_l₂.kunion l,	p_ih_ᾰ_1 : ∀ (l : list (sigma β)), p_l₂.kunion l ~ p_l₃.kunion l,	l : list (sigma β)	⊢ p_l₁.kunion l ~ p_l₃.kunion l
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	l₁ l₂ : list (sigma β),	s₁ s₂ : sigma β,	l l : list (sigma β)	⊢ (s₂ :: s₁ :: l).kunion l ~ (s₁ :: s₂ :: l).kunion l
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	l₁ l₂ p_l₁ p_l₂ p_l₃ : list (sigma β),	p_ᾰ : p_l₁ ~ p_l₂,	p_ᾰ_1 : p_l₂ ~ p_l₃,	p_ih_ᾰ : ∀ (l : list (sigma β)), p_l₁.kunion l ~ p_l₂.kunion l,	p_ih_ᾰ_1 : ∀ (l : list (sigma β)), p_l₂.kunion l ~ p_l₃.kunion l,	l : list (sigma β)	⊢ p_l₁.kunion l ~ p_l₃.kunion l
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	l₁ l₂ l₁ l₂ l₃ : list (sigma β),	p₁₂ : l₁ ~ l₂,	p₂₃ : l₂ ~ l₃,	ih₁₂ : ∀ (l : list (sigma β)), l₁.kunion l ~ l₂.kunion l,	ih₂₃ : ∀ (l : list (sigma β)), l₂.kunion l ~ l₃.kunion l,	l : list (sigma β)	⊢ l₁.kunion l ~ l₃.kunion l
α : Type uu,	r : α → α → Prop,	_inst_1 : decidable_rel r,	perm_insertion_sort : ∀ (l : list α), list.insertion_sort r l ~ l,	b : α,	l : list α	⊢ list.insertion_sort r (b :: l) ~ b :: l
α : Type u,	β : Type u_1,	a : α,	b : β,	mem_zip : ∀ {l₁ : list α} {l₂ : list β}, (a, b) ∈ l₁.zip l₂ → a ∈ l₁ ∧ b ∈ l₂,	a' : α,	l₁ : list α,	b' : β,	l₂ : list β,	h : list.mem (a, b) (list.zip_with prod.mk l₁ l₂)	⊢ a ∈ a' :: l₁ ∧ b ∈ b' :: l₂
α : Type u,	β : Type u_1,	a : α,	b : β,	mem_zip : ∀ {l₁ : list α} {l₂ : list β}, (a, b) ∈ l₁.zip l₂ → a ∈ l₁ ∧ b ∈ l₂,	a' : α,	l₁ : list α,	b' : β,	l₂ : list β,	h : list.mem (a, b) (list.zip_with prod.mk l₁ l₂)	⊢ a ∈ a' :: l₁ ∧ b ∈ b' :: l₂
α : Type u,	β : Type u_1,	a : α,	b : β,	mem_zip : ∀ {l₁ : list α} {l₂ : list β}, (a, b) ∈ l₁.zip l₂ → a ∈ l₁ ∧ b ∈ l₂,	a' : α,	l₁ : list α,	b' : β,	l₂ : list β,	h : list.mem (a, b) (list.zip_with prod.mk l₁ l₂)	⊢ a ∈ a' :: l₁
α : Type u,	β : Type u_1,	a : α,	b : β,	mem_zip : ∀ {l₁ : list α} {l₂ : list β}, (a, b) ∈ l₁.zip l₂ → a ∈ l₁ ∧ b ∈ l₂,	a' : α,	l₁ : list α,	b' : β,	l₂ : list β,	h : list.mem (a, b) (list.zip_with prod.mk l₁ l₂)	⊢ b ∈ b' :: l₂
α : Type u,	β : Type u_1,	γ : Type u_2,	f : α → β → γ,	l : list α,	l' : list β	⊢ list.zip_with f l l' = list.nil ↔ l = list.nil ∨ l' = list.nil
α : Type u,	β : Type u_1,	γ : Type u_2,	f : α → β → γ,	l : list α,	l' : list β	⊢ list.zip_with f l l' = list.nil ↔ l = list.nil ∨ l' = list.nil
α : Type u,	β : Type u_1,	γ : Type u_2,	f : α → β → γ,	l' : list β	⊢ list.zip_with f list.nil l' = list.nil ↔ list.nil = list.nil ∨ l' = list.nil
α : Type u,	β : Type u_1,	γ : Type u_2,	f : α → β → γ,	l' : list β,	l_hd : α,	l_tl : list α	⊢ list.zip_with f (l_hd :: l_tl) l' = list.nil ↔ l_hd :: l_tl = list.nil ∨ l' = list.nil
α : Type u,	β : Type u_1,	γ : Type u_2,	f : α → β → γ	⊢ list.zip_with f list.nil list.nil = list.nil ↔ list.nil = list.nil ∨ list.nil = list.nil
α : Type u,	β : Type u_1,	γ : Type u_2,	f : α → β → γ,	l'_hd : β,	l'_tl : list β	⊢ list.zip_with f list.nil (l'_hd :: l'_tl) = list.nil ↔ list.nil = list.nil ∨ l'_hd :: l'_tl = list.nil
α : Type u,	β : Type u_1,	γ : Type u_2,	f : α → β → γ,	l_hd : α,	l_tl : list α	⊢ list.zip_with f (l_hd :: l_tl) list.nil = list.nil ↔ l_hd :: l_tl = list.nil ∨ list.nil = list.nil
α : Type u,	β : Type u_1,	γ : Type u_2,	f : α → β → γ,	l_hd : α,	l_tl : list α,	l'_hd : β,	l'_tl : list β	⊢ list.zip_with f (l_hd :: l_tl) (l'_hd :: l'_tl) = list.nil ↔ l_hd :: l_tl = list.nil ∨ l'_hd :: l'_tl = list.nil
α : Type u,	β : Type u_1,	γ : Type u_2,	f : α → β → γ,	l : list α,	l' : list β	⊢ list.zip_with f l l' = list.nil ↔ l = list.nil ∨ l' = list.nil
α : Type u,	β : Type u_1,	γ : Type u_2,	f : α → γ,	l₁ : list α,	l₂ : list β	⊢ (list.map f l₁).zip l₂ = list.map (prod.map f id) (l₁.zip l₂)
m : Type u_2,	n : Type u_3,	α : Type v,	_inst_1 : ring α,	_inst_2 : star_ring α,	M N : matrix m n α	⊢ (M - N)ᴴ = Mᴴ - Nᴴ
m : Type u_2,	n : Type u_3,	α : Type v,	_inst_1 : ring α,	_inst_2 : star_ring α,	M N : matrix m n α	⊢ (M - N)ᴴ = Mᴴ - Nᴴ
m : Type u_2,	n : Type u_3,	α : Type v,	_inst_1 : ring α,	_inst_2 : star_ring α,	M N : matrix m n α,	i : n,	j : m	⊢ (M - N)ᴴ i j = (Mᴴ - Nᴴ) i j
n : Type u_3,	α : Type v,	β : Type w,	_inst_1 : decidable_eq n,	_inst_2 : has_zero α,	_inst_3 : has_zero β,	f : α → β,	h : f 0 = 0,	d : n → α,	i j : n	⊢ (matrix.diagonal d).map f i j = matrix.diagonal (λ (m : n), f (d m)) i j
n : Type u_3,	α : Type v,	β : Type w,	_inst_1 : decidable_eq n,	_inst_2 : has_zero α,	_inst_3 : has_zero β,	f : α → β,	h : f 0 = 0,	d : n → α,	i j : n	⊢ f (ite (i = j) (d i) 0) = ite (i = j) (f (d i)) 0
n : Type u_3,	α : Type v,	β : Type w,	_inst_1 : decidable_eq n,	_inst_2 : has_zero α,	_inst_3 : has_zero β,	f : α → β,	h : f 0 = 0,	d : n → α,	i j : n	⊢ f (ite (i = j) (d i) 0) = ite (i = j) (f (d i)) 0
n : Type u_3,	α : Type v,	β : Type w,	_inst_1 : decidable_eq n,	_inst_2 : has_zero α,	_inst_3 : has_zero β,	f : α → β,	h : f 0 = 0,	d : n → α,	i j : n,	h_1 : i = j	⊢ f (d i) = f (d i)
n : Type u_3,	α : Type v,	β : Type w,	_inst_1 : decidable_eq n,	_inst_2 : has_zero α,	_inst_3 : has_zero β,	f : α → β,	h : f 0 = 0,	d : n → α,	i j : n,	h_1 : ¬i = j	⊢ f 0 = 0
n : Type u_3,	α : Type v,	β : Type w,	_inst_1 : decidable_eq n,	_inst_2 : has_zero α,	_inst_3 : has_zero β,	f : α → β,	h : f 0 = 0,	d : n → α	⊢ (matrix.diagonal d).map f = matrix.diagonal (λ (m : n), f (d m))
l : Type u_1,	m : Type u_2,	n : Type u_3,	o : Type u_4,	α : Type v,	_inst_1 : non_unital_semiring α,	_inst_2 : fintype m,	_inst_3 : fintype n,	L : matrix l m α,	M : matrix m n α,	N : matrix n o α,	i : l,	j : o	⊢ (L ⬝ M ⬝ N) i j = (L ⬝ (M ⬝ N)) i j
l : Type u_1,	m : Type u_2,	n : Type u_3,	o : Type u_4,	α : Type v,	_inst_1 : non_unital_semiring α,	_inst_2 : fintype m,	_inst_3 : fintype n,	L : matrix l m α,	M : matrix m n α,	N : matrix n o α	⊢ L ⬝ M ⬝ N = L ⬝ (M ⬝ N)
n : Type u_3,	α : Type v,	_inst_1 : semiring α,	_inst_2 : decidable_eq n,	_inst_3 : fintype n,	a : α,	i : n	⊢ ⇑(matrix.scalar n) a i i = a
n : Type u_3,	α : Type v,	_inst_1 : comm_semiring α,	_inst_2 : fintype n,	_inst_3 : decidable_eq n,	r : α,	M : matrix n n α	⊢ commute (⇑(matrix.scalar n) r) M
m : Type u_2,	n : Type u_3,	α : Type u_5,	_inst_2 : decidable_eq m,	_inst_3 : decidable_eq n,	_inst_4 : semiring α,	i : m,	j : n,	a b : α	⊢ (b • λ (i' : m) (j' : n), ite (i = i' ∧ j = j') a 0) = λ (i' : m) (j' : n), ite (i = i' ∧ j = j') (b • a) 0
m : Type u_2,	n : Type u_3,	α : Type u_5,	_inst_2 : decidable_eq m,	_inst_3 : decidable_eq n,	_inst_4 : semiring α,	i : m,	j : n,	a b : α,	x : m,	x_1 : n	⊢ (b • λ (i' : m) (j' : n), ite (i = i' ∧ j = j') a 0) x x_1 = ite (i = x ∧ j = x_1) (b • a) 0
m : Type u_2,	n : Type u_3,	α : Type u_5,	_inst_2 : decidable_eq m,	_inst_3 : decidable_eq n,	_inst_4 : semiring α,	i : m,	j : n,	a b : α	⊢ b • matrix.std_basis_matrix i j a = matrix.std_basis_matrix i j (b • a)
m : Type u_2,	n : Type u_3,	_inst_2 : fintype m,	_inst_3 : fintype n,	α : m → n → Type v,	_inst_5 : Π (i : m) (j : n), add_group (α i j),	β : m → n → Type w,	_inst_6 : Π (i : m) (j : n), add_group (β i j),	f : Π ⦃i : m⦄ ⦃j : n⦄, α i j →+ β i j,	M N : dmatrix m n α,	i : m,	j : n	⊢ (M - N).map (λ (i : m) (j : n), ⇑f) i j = (M.map (λ (i : m) (j : n), ⇑f) - N.map (λ (i : m) (j : n), ⇑f)) i j
m : Type u_2,	n : Type u_3,	_inst_2 : fintype m,	_inst_3 : fintype n,	α : m → n → Type v,	_inst_5 : Π (i : m) (j : n), add_group (α i j),	β : m → n → Type w,	_inst_6 : Π (i : m) (j : n), add_group (β i j),	f : Π ⦃i : m⦄ ⦃j : n⦄, α i j →+ β i j,	M N : dmatrix m n α	⊢ (M - N).map (λ (i : m) (j : n), ⇑f) = M.map (λ (i : m) (j : n), ⇑f) - N.map (λ (i : m) (j : n), ⇑f)
m : Type u_2,	n : Type u_3,	_inst_2 : fintype m,	_inst_3 : fintype n,	α : m → n → Type v,	_inst_5 : is_empty m,	M N : dmatrix m n α	⊢ M = N
m : Type u_2,	n : Type u_3,	_inst_2 : fintype m,	_inst_3 : fintype n,	α : m → n → Type v,	_inst_5 : is_empty m,	M N : dmatrix m n α,	i : m,	j : n	⊢ M i j = N i j
n : ℕ,	m' : Type u_1,	α : Type u_2,	_inst_2 : comm_semiring α,	A : m' → fin n.succ → α,	x : α,	v : fin n → α,	i : m'	⊢ matrix.mul_vec A (matrix.vec_cons x v) i = (x • matrix.vec_head ∘ A + matrix.mul_vec (matrix.vec_tail ∘ A) v) i
n : ℕ,	m' : Type u_1,	α : Type u_2,	_inst_2 : comm_semiring α,	A : m' → fin n.succ → α,	x : α,	v : fin n → α	⊢ matrix.mul_vec A (matrix.vec_cons x v) = x • matrix.vec_head ∘ A + matrix.mul_vec (matrix.vec_tail ∘ A) v
α : Type u,	n : ℕ,	_inst_1 : has_add α,	x : α,	v : fin n → α,	w : fin n.succ → α,	i : fin n.succ	⊢ (matrix.vec_cons x v + w) i = matrix.vec_cons (x + matrix.vec_head w) (v + matrix.vec_tail w) i
α : Type u,	n : ℕ,	_inst_1 : has_add α,	x : α,	v : fin n → α,	w : fin n.succ → α,	i : fin n.succ	⊢ (matrix.vec_cons x v + w) i = matrix.vec_cons (x + matrix.vec_head w) (v + matrix.vec_tail w) i
α : Type u,	n : ℕ,	_inst_1 : has_add α,	x : α,	v : fin n → α,	w : fin n.succ → α,	i : fin n.succ	⊢ (matrix.vec_cons x v + w) 0 = matrix.vec_cons (x + matrix.vec_head w) (v + matrix.vec_tail w) 0
α : Type u,	n : ℕ,	_inst_1 : has_add α,	x : α,	v : fin n → α,	w : fin n.succ → α,	i : fin n.succ	⊢ ∀ (i : fin n), (matrix.vec_cons x v + w) i.succ = matrix.vec_cons (x + matrix.vec_head w) (v + matrix.vec_tail w) i.succ
α : Type u,	n : ℕ,	_inst_1 : has_add α,	x : α,	v : fin n → α,	w : fin n.succ → α	⊢ matrix.vec_cons x v + w = matrix.vec_cons (x + matrix.vec_head w) (v + matrix.vec_tail w)
α : Type u_1,	_inst_1 : ordered_comm_monoid α,	m : multiset α	⊢ (∀ (x : α), x ∈ m → 1 ≤ x) → m.prod = 1 → ∀ (x : α), x ∈ m → x = 1
α : Type u_1,	_inst_1 : ordered_comm_monoid α,	m : multiset α	⊢ ∀ (a : list α), (∀ (x : α), x ∈ ⟦a⟧ → 1 ≤ x) → multiset.prod ⟦a⟧ = 1 → ∀ (x : α), x ∈ ⟦a⟧ → x = 1
α : Type u_1,	_inst_1 : ordered_comm_monoid α,	m : multiset α	⊢ ∀ (a : list α), (∀ (x : α), x ∈ a → 1 ≤ x) → a.prod = 1 → ∀ (x : α), x ∈ a → x = 1
α : Type u_1,	_inst_1 : ordered_comm_monoid α,	m : multiset α,	l : list α,	hl₁ : ∀ (x : α), x ∈ l → 1 ≤ x,	hl₂ : l.prod = 1,	x : α,	hx : x ∈ l	⊢ x = 1
α : Type u_1,	σ : α → Type u_4,	s : multiset α,	t : Π (a : α), multiset (σ a)	⊢ ⇑multiset.card (s.sigma t) = (multiset.map (λ (a : α), ⇑multiset.card (t a)) s).sum
α : Type u_1,	m : multiset α,	β : α → Type ?,	h : Π (a : α), decidable_eq (β a),	f g : Π (a : α), a ∈ m → β a	⊢ (∀ (a : α) (h : a ∈ m), f a h = g a h) ↔ f = g
α : Type u_1,	p : α → Prop,	_inst_1 : decidable_pred p,	_inst_2 : decidable_eq α,	s t : multiset α,	h : t ≤ s	⊢ multiset.countp p (s - t) = multiset.countp p s - multiset.countp p t
α : Type u_1,	_inst_1 : decidable_eq α,	a : α,	s t : multiset α	⊢ multiset.count a (s ∪ t) = linear_order.max (multiset.count a s) (multiset.count a t)
α : Type u_1,	s t : multiset α	⊢ multiset.rel eq s t ↔ s = t
α : Type u_1,	s t : multiset α,	h : multiset.rel eq s t	⊢ s = t
α : Type u_1,	s t : multiset α,	h : multiset.rel eq s t	⊢ s = t
α : Type u_1,	s t : multiset α	⊢ 0 = 0
α : Type u_1,	s t : multiset α,	h_a h_b : α,	h_as h_bs : multiset α,	h_ᾰ : h_a = h_b,	h_ᾰ_1 : multiset.rel eq h_as h_bs,	h_ih : h_as = h_bs	⊢ h_a ::ₘ h_as = h_b ::ₘ h_bs
α : Type u_1,	s t : multiset α	⊢ multiset.rel eq s t → s = t		α : Type u_1,	s t : multiset α	⊢ s = t → multiset.rel eq s t
α : Type u_1,	s t : multiset α	⊢ multiset.rel eq s t → s = t
α : Type u_1,	s t : multiset α,	h : s = t	⊢ multiset.rel eq s t
α : Type u_1,	s : multiset α	⊢ multiset.rel eq s s
α : Type u_1,	s t : multiset α	⊢ s = t → multiset.rel eq s t
α : Type u_1,	a : α,	s t : multiset α	⊢ s.disjoint (a ::ₘ t) ↔ a ∉ s ∧ s.disjoint t
α : Type u_1,	a : α,	s t : multiset α	⊢ a ∉ s ∧ t.disjoint s ↔ a ∉ s ∧ s.disjoint t
α : Type u_1,	a : α,	s t : multiset α	⊢ s.disjoint (a ::ₘ t) ↔ a ∉ s ∧ s.disjoint t
α : Type u_1,	s t : multiset α	⊢ s ≤ s + t
α : Type u_1,	s : multiset α,	e : s = 0	⊢ ⇑multiset.card s = 0
α : Type u_1,	s t : multiset α,	n : ℕ,	h : s.nodup,	hn : n ≠ 0	⊢ s ≤ n • t ↔ s ≤ t
α : Type u_1,	s t : multiset α,	n : ℕ,	h : s.nodup,	hn : n ≠ 0,	_inst : Π (a : Prop), decidable a	⊢ s ≤ n • t ↔ s ≤ t
α : Type u_1,	s t : multiset α,	n : ℕ,	h : s.nodup,	hn : n ≠ 0,	_inst : Π (a : Prop), decidable a	⊢ s ≤ t.erase_dup ↔ s ≤ (n • t).erase_dup
α : Type u_1,	_inst_1 : decidable_eq α,	s t u : multiset α	⊢ s ≤ t.ndinter u ↔ s ≤ t ∧ s ⊆ u
n : ℕ	⊢ multiset.nat.antidiagonal (n + 1) = (0, n + 1) ::ₘ multiset.map (prod.map nat.succ id) (multiset.nat.antidiagonal n)
α : Type u_1,	s : multiset α,	l : list α,	h : multiset.nodup ⟦l⟧	⊢ (multiset.powerset ⟦l⟧).nodup
α : Type u_1,	s : multiset α,	l : list α,	h : multiset.nodup ⟦l⟧	⊢ (multiset.powerset ⟦l⟧).nodup
α : Type u_1,	s : multiset α,	l : list α,	h : multiset.nodup ⟦l⟧	⊢ (list.map coe l.sublists').nodup
α : Type u_1,	s : multiset α,	l : list α,	h : multiset.nodup ⟦l⟧	⊢ ∀ (x : list α), x ∈ l.sublists' → ∀ (y : list α), y ∈ l.sublists' → ↑x = ↑y → x = y
α : Type u_1,	s : multiset α,	l : list α,	h : multiset.nodup ⟦l⟧	⊢ (multiset.powerset ⟦l⟧).nodup
α : Type u_1,	n : ℕ,	l : list α,	s : multiset α	⊢ ∀ (a : list α), ⟦a⟧ ∈ multiset.powerset_len_aux n l ↔ ⟦a⟧ ≤ ↑l ∧ ⇑multiset.card ⟦a⟧ = n
α : Type u_1,	n : ℕ,	l : list α,	s : multiset α	⊢ ∀ (a : list α), (∃ (a_1 : list α), (a_1 <+ l ∧ a_1.length = n) ∧ a_1 ~ a) ↔ (∃ (l_1 : list α), l_1 ~ a ∧ l_1 <+ l) ∧ a.length = n
α : Type u_1,	n : ℕ,	l : list α,	s : multiset α	⊢ ∀ (a : list α), ⟦a⟧ ∈ multiset.powerset_len_aux n l ↔ ⟦a⟧ ≤ ↑l ∧ ⇑multiset.card ⟦a⟧ = n
α : Type u_1,	l : list α	⊢ multiset.powerset_len_aux 0 l = [0]
α : Type u_1,	s : multiset (multiset α)	⊢ ∀ {a : multiset α}, a ∈ 0.sections ↔ multiset.rel (λ (s : multiset α) (a : α), a ∈ s) 0 a
α : Type u_1,	s : multiset (multiset α),	a : multiset α,	s : multiset (multiset α),	ih : ∀ {a : multiset α}, a ∈ s.sections ↔ multiset.rel (λ (s : multiset α) (a : α), a ∈ s) s a,	a' : multiset α	⊢ a' ∈ (a ::ₘ s).sections ↔ multiset.rel (λ (s : multiset α) (a : α), a ∈ s) (a ::ₘ s) a'
R : Type u,	σ : Type u_1,	_inst_1 : comm_semiring R,	A : Type u_2,	_inst_3 : add_comm_monoid A,	p : mv_polynomial σ R,	b : (σ →₀ ℕ) → R → A	⊢ finsupp.sum p b = ∑ (m : σ →₀ ℕ) in p.support, b m (mv_polynomial.coeff m p)
R : Type u,	S₁ : Type v,	S₂ : Type w,	σ : Type u_1,	_inst_1 : comm_semiring R,	_inst_2 : comm_semiring S₁,	f : R →+* S₁,	_inst_3 : comm_semiring S₂,	g : S₁ →+* S₂,	p : mv_polynomial σ R	⊢ mv_polynomial.eval₂ ((mv_polynomial.map g).comp (mv_polynomial.C.comp f)) (⇑(mv_polynomial.map g) ∘ mv_polynomial.X) p = ⇑(mv_polynomial.map (g.comp f)) p
R : Type u,	S₁ : Type v,	S₂ : Type w,	σ : Type u_1,	_inst_1 : comm_semiring R,	_inst_2 : comm_semiring S₁,	f : R →+* S₁,	_inst_3 : comm_semiring S₂,	g : S₁ →+* S₂,	p : mv_polynomial σ R,	a : R	⊢ ⇑((mv_polynomial.map g).comp (mv_polynomial.C.comp f)) a = ⇑(mv_polynomial.C.comp (g.comp f)) a
R : Type u,	S₁ : Type v,	S₂ : Type w,	σ : Type u_1,	_inst_1 : comm_semiring R,	_inst_2 : comm_semiring S₁,	f : R →+* S₁,	_inst_3 : comm_semiring S₂,	g : S₁ →+* S₂,	p : mv_polynomial σ R	⊢ (mv_polynomial.map g).comp (mv_polynomial.C.comp f) = mv_polynomial.C.comp (g.comp f)
R : Type u,	S₁ : Type v,	S₂ : Type w,	σ : Type u_1,	_inst_1 : comm_semiring R,	_inst_2 : comm_semiring S₁,	f : R →+* S₁,	_inst_3 : comm_semiring S₂,	g : S₁ →+* S₂,	p : mv_polynomial σ R	⊢ (mv_polynomial.map g).comp (mv_polynomial.C.comp f) = mv_polynomial.C.comp (g.comp f)		R : Type u,	S₁ : Type v,	S₂ : Type w,	σ : Type u_1,	_inst_1 : comm_semiring R,	_inst_2 : comm_semiring S₁,	f : R →+* S₁,	_inst_3 : comm_semiring S₂,	g : S₁ →+* S₂,	p : mv_polynomial σ R	⊢ ⇑(mv_polynomial.map g) ∘ mv_polynomial.X = λ (n : σ), mv_polynomial.X n
R : Type u,	S₁ : Type v,	S₂ : Type w,	σ : Type u_1,	_inst_1 : comm_semiring R,	_inst_2 : comm_semiring S₁,	f : R →+* S₁,	_inst_3 : comm_semiring S₂,	g : S₁ →+* S₂,	p : mv_polynomial σ R,	n : σ	⊢ (⇑(mv_polynomial.map g) ∘ mv_polynomial.X) n = mv_polynomial.X n
R : Type u,	S₁ : Type v,	S₂ : Type w,	σ : Type u_1,	_inst_1 : comm_semiring R,	_inst_2 : comm_semiring S₁,	f : R →+* S₁,	_inst_3 : comm_semiring S₂,	g : S₁ →+* S₂,	p : mv_polynomial σ R	⊢ ⇑(mv_polynomial.map g) ∘ mv_polynomial.X = λ (n : σ), mv_polynomial.X n
R : Type u,	S₁ : Type v,	σ : Type u_1,	_inst_1 : comm_semiring R,	_inst_2 : comm_semiring S₁,	f : R →+* S₁,	x : R	⊢ ⇑((mv_polynomial.constant_coeff.comp (mv_polynomial.map f)).comp mv_polynomial.C) x = ⇑((f.comp mv_polynomial.constant_coeff).comp mv_polynomial.C) x
R : Type u,	S₁ : Type v,	σ : Type u_1,	_inst_1 : comm_semiring R,	_inst_2 : comm_semiring S₁,	f : R →+* S₁	⊢ ∀ (i : σ), ⇑(mv_polynomial.constant_coeff.comp (mv_polynomial.map f)) (mv_polynomial.X i) = ⇑(f.comp mv_polynomial.constant_coeff) (mv_polynomial.X i)
R : Type u,	S₁ : Type v,	σ : Type u_1,	_inst_1 : comm_semiring R,	_inst_2 : comm_semiring S₁,	f : R →+* S₁	⊢ mv_polynomial.constant_coeff.comp (mv_polynomial.map f) = f.comp mv_polynomial.constant_coeff
R : Type u,	S₁ : Type v,	σ : Type u_1,	_inst_1 : comm_semiring R,	_inst_2 : comm_semiring S₁,	f : R →+* S₁	⊢ mv_polynomial.constant_coeff.comp (mv_polynomial.map f) = f.comp mv_polynomial.constant_coeff
R : Type u,	S₂ : Type w,	σ : Type u_1,	_inst_1 : comm_semiring R,	_inst_4 : comm_semiring S₂,	f : R →+* S₂,	g : σ → S₂,	φ : mv_polynomial σ R,	h : ∀ (d : σ →₀ ℕ), mv_polynomial.coeff d φ ≠ 0 → (∃ (i : σ) (H : i ∈ d.support), g i = 0)	⊢ ⇑(mv_polynomial.eval₂_hom f g) φ = 0
R : Type u,	S₂ : Type w,	σ : Type u_1,	_inst_1 : comm_semiring R,	_inst_4 : comm_semiring S₂,	f : R →+* S₂,	g : σ → S₂,	φ : mv_polynomial σ R,	h : ∀ (d : σ →₀ ℕ), mv_polynomial.coeff d φ ≠ 0 → (∃ (i : σ) (H : i ∈ d.support), g i = 0)	⊢ ∀ (x : σ →₀ ℕ), x ∈ φ.support → ⇑(mv_polynomial.eval₂_hom f g) (mv_polynomial.monomial x (mv_polynomial.coeff x φ)) = 0
R : Type u,	S₂ : Type w,	σ : Type u_1,	_inst_1 : comm_semiring R,	_inst_4 : comm_semiring S₂,	f : R →+* S₂,	g : σ → S₂,	φ : mv_polynomial σ R,	h : ∀ (d : σ →₀ ℕ), mv_polynomial.coeff d φ ≠ 0 → (∃ (i : σ) (H : i ∈ d.support), g i = 0),	d : σ →₀ ℕ,	hd : d ∈ φ.support	⊢ ⇑(mv_polynomial.eval₂_hom f g) (mv_polynomial.monomial d (mv_polynomial.coeff d φ)) = 0
R : Type u,	S₂ : Type w,	σ : Type u_1,	_inst_1 : comm_semiring R,	_inst_4 : comm_semiring S₂,	f : R →+* S₂,	g : σ → S₂,	φ : mv_polynomial σ R,	h : ∀ (d : σ →₀ ℕ), mv_polynomial.coeff d φ ≠ 0 → (∃ (i : σ) (H : i ∈ d.support), g i = 0),	d : σ →₀ ℕ,	hd : d ∈ φ.support,	i : σ,	hi : i ∈ d.support,	hgi : g i = 0	⊢ ⇑(mv_polynomial.eval₂_hom f g) (mv_polynomial.monomial d (mv_polynomial.coeff d φ)) = 0
R : Type u,	S₂ : Type w,	σ : Type u_1,	_inst_1 : comm_semiring R,	_inst_4 : comm_semiring S₂,	f : R →+* S₂,	g : σ → S₂,	φ : mv_polynomial σ R,	h : ∀ (d : σ →₀ ℕ), mv_polynomial.coeff d φ ≠ 0 → (∃ (i : σ) (H : i ∈ d.support), g i = 0),	d : σ →₀ ℕ,	hd : d ∈ φ.support,	i : σ,	hi : i ∈ d.support,	hgi : g i = 0	⊢ g i ^ ⇑d i = 0
R : Type u,	S₂ : Type w,	σ : Type u_1,	_inst_1 : comm_semiring R,	_inst_4 : comm_semiring S₂,	f : R →+* S₂,	g : σ → S₂,	φ : mv_polynomial σ R,	h : ∀ (d : σ →₀ ℕ), mv_polynomial.coeff d φ ≠ 0 → (∃ (i : σ) (H : i ∈ d.support), g i = 0),	d : σ →₀ ℕ,	hd : d ∈ φ.support,	i : σ,	hi : i ∈ d.support,	hgi : g i = 0	⊢ 0 < ⇑d i
R : Type u,	σ : Type u_1,	_inst_1 : comm_ring R,	p : mv_polynomial σ R	⊢ (-p).degrees = p.degrees
R : Type u,	σ : Type u_1,	_inst_1 : comm_ring R,	p : mv_polynomial σ R	⊢ p.support.sup (λ (s : σ →₀ ℕ), ⇑finsupp.to_multiset s) = p.degrees
R : Type u,	σ : Type u_1,	_inst_1 : comm_ring R,	p : mv_polynomial σ R	⊢ (-p).degrees = p.degrees
R : Type u,	σ : Type u_1,	_inst_1 : comm_semiring R,	i : σ,	n : ℕ	⊢ ⇑(mv_polynomial.pderiv i) ↑n = 0
R : Type u,	σ : Type u_1,	_inst_1 : comm_semiring R,	i : σ	⊢ ⇑(mv_polynomial.pderiv i) ↑0 = 0		case nat.succ	R : Type u,	σ : Type u_1,	_inst_1 : comm_semiring R,	i : σ,	n : ℕ,	ih : ⇑(mv_polynomial.pderiv i) ↑n = 0	⊢ ⇑(mv_polynomial.pderiv i) ↑(n.succ) = 0
R : Type u,	σ : Type u_1,	_inst_1 : comm_semiring R,	i : σ	⊢ ⇑(mv_polynomial.pderiv i) ↑0 = 0
R : Type u,	σ : Type u_1,	_inst_1 : comm_semiring R,	i : σ,	n : ℕ,	ih : ⇑(mv_polynomial.pderiv i) ↑n = 0	⊢ ⇑(mv_polynomial.pderiv i) ↑(n.succ) = 0
R : Type u,	σ : Type u_1,	a : R,	_inst_1 : comm_semiring R,	i : σ,	this : ⇑(mv_polynomial.pderiv i) (mv_polynomial.monomial 0 a) = 0	⊢ ⇑(mv_polynomial.pderiv i) (⇑mv_polynomial.C a) = 0
R : Type u,	σ : Type u_1,	a : R,	_inst_1 : comm_semiring R,	i : σ	⊢ ⇑(mv_polynomial.pderiv i) (mv_polynomial.monomial 0 a) = 0
σ : Type u_1,	τ : Type u_2,	R : Type u_4,	S : Type u_5,	_inst_1 : comm_semiring R,	_inst_2 : comm_semiring S,	f : R →+* S,	g : σ → τ,	p : mv_polynomial σ R,	a : R	⊢ ⇑(mv_polynomial.map f) (⇑(mv_polynomial.rename g) (⇑mv_polynomial.C a)) = ⇑(mv_polynomial.rename g) (⇑(mv_polynomial.map f) (⇑mv_polynomial.C a))
σ : Type u_1,	τ : Type u_2,	R : Type u_4,	S : Type u_5,	_inst_1 : comm_semiring R,	_inst_2 : comm_semiring S,	f : R →+* S,	g : σ → τ,	p p q : mv_polynomial σ R,	hp : ⇑(mv_polynomial.map f) (⇑(mv_polynomial.rename g) p) = ⇑(mv_polynomial.rename g) (⇑(mv_polynomial.map f) p),	hq : ⇑(mv_polynomial.map f) (⇑(mv_polynomial.rename g) q) = ⇑(mv_polynomial.rename g) (⇑(mv_polynomial.map f) q)	⊢ ⇑(mv_polynomial.map f) (⇑(mv_polynomial.rename g) (p + q)) = ⇑(mv_polynomial.rename g) (⇑(mv_polynomial.map f) (p + q))
σ : Type u_1,	τ : Type u_2,	R : Type u_4,	S : Type u_5,	_inst_1 : comm_semiring R,	_inst_2 : comm_semiring S,	f : R →+* S,	g : σ → τ,	p p : mv_polynomial σ R,	n : σ,	hp : ⇑(mv_polynomial.map f) (⇑(mv_polynomial.rename g) p) = ⇑(mv_polynomial.rename g) (⇑(mv_polynomial.map f) p)	⊢ ⇑(mv_polynomial.map f) (⇑(mv_polynomial.rename g) (p * mv_polynomial.X n)) = ⇑(mv_polynomial.rename g) (⇑(mv_polynomial.map f) (p * mv_polynomial.X n))
σ : Type u_1,	τ : Type u_2,	α : Type u_3,	R : Type u_4,	_inst_1 : comm_semiring R,	f : σ → τ,	g : τ → α,	p : mv_polynomial σ R	⊢ ⇑(mv_polynomial.rename g) (mv_polynomial.eval₂ mv_polynomial.C (mv_polynomial.X ∘ f) p) = ⇑(mv_polynomial.rename (g ∘ f)) p
σ : Type u_1,	τ : Type u_2,	α : Type u_3,	R : Type u_4,	_inst_1 : comm_semiring R,	f : σ → τ,	g : τ → α,	p : mv_polynomial σ R	⊢ ⇑(mv_polynomial.eval₂_hom (algebra_map R (mv_polynomial α R)) (mv_polynomial.X ∘ g)) (mv_polynomial.eval₂ mv_polynomial.C (mv_polynomial.X ∘ f) p) = ⇑(mv_polynomial.eval₂_hom (algebra_map R (mv_polynomial α R)) (mv_polynomial.X ∘ g ∘ f)) p
σ : Type u_1,	τ : Type u_2,	α : Type u_3,	R : Type u_4,	_inst_1 : comm_semiring R,	f : σ → τ,	g : τ → α,	p : mv_polynomial σ R	⊢ mv_polynomial.eval₂ ((mv_polynomial.eval₂_hom (algebra_map R (mv_polynomial α R)) (λ (x : τ), mv_polynomial.X (g x))).comp mv_polynomial.C) (λ (x : σ), mv_polynomial.X (g (f x))) p = mv_polynomial.eval₂ (algebra_map R (mv_polynomial α R)) (λ (x : σ), mv_polynomial.X (g (f x))) p
σ : Type u_1,	τ : Type u_2,	α : Type u_3,	R : Type u_4,	_inst_1 : comm_semiring R,	f : σ → τ,	g : τ → α,	p : mv_polynomial σ R	⊢ (mv_polynomial.eval₂_hom (algebra_map R (mv_polynomial α R)) (λ (x : τ), mv_polynomial.X (g x))).comp mv_polynomial.C = algebra_map R (mv_polynomial α R)
σ : Type u_1,	τ : Type u_2,	α : Type u_3,	R : Type u_4,	_inst_1 : comm_semiring R,	f : σ → τ,	g : τ → α,	p : mv_polynomial σ R,	x : R	⊢ ⇑((mv_polynomial.eval₂_hom (algebra_map R (mv_polynomial α R)) (λ (x : τ), mv_polynomial.X (g x))).comp mv_polynomial.C) x = ⇑(algebra_map R (mv_polynomial α R)) x
R : Type u,	σ : Type u_1,	_inst_1 : comm_semiring R,	p : mv_polynomial σ R	⊢ p.total_degree ≤ ⇑multiset.card p.degrees
R : Type u,	σ : Type u_1,	_inst_1 : comm_semiring R,	p : mv_polynomial σ R	⊢ p.support.sup (λ (m : σ →₀ ℕ), ⇑multiset.card (⇑finsupp.to_multiset m)) ≤ ⇑multiset.card p.degrees
n : ℕ	⊢ ¬2 = 1
n : ℕ	⊢ ¬2 ∣ bit1 n
a b : ℕ,	h1 : 0 < b,	h2 : b < a	⊢ ¬a ∣ b
a c : ℕ,	h1 : 0 < a * c,	h2 : a * c < a	⊢ false
a : ℕ,	h1 : 0 < a * 0,	h2 : a * 0 < a	⊢ false		a c : ℕ,	h1 : 0 < a * c,	h2 : a * c < a,	hc : 0 < c	⊢ false
a : ℕ,	h1 : 0 < a * 0,	h2 : a * 0 < a	⊢ false
a c : ℕ,	h1 : 0 < a * c,	h2 : a * c < a,	hc : 0 < c	⊢ false
n : ℕ	⊢ n.bodd_div2 = (n.bodd, n.div2)
n : ℕ	⊢ n.bodd_div2 = (n.bodd, n.div2)
n : ℕ	⊢ n.bodd_div2 = (n.bodd_div2.fst, n.bodd_div2.snd)
n : ℕ,	fst : bool,	snd : ℕ	⊢ (fst, snd) = ((fst, snd).fst, (fst, snd).snd)
n : ℕ	⊢ n.bodd_div2 = (n.bodd, n.div2)
P : ℕ → Prop,	h : decidable_pred P,	decidable_exists_lt : decidable_pred (λ (n : ℕ), ∃ (m : ℕ), m < n ∧ P m)	⊢ ¬(λ (n : ℕ), ∃ (m : ℕ), m < n ∧ P m) 0
P : ℕ → Prop,	h : decidable_pred P,	decidable_exists_lt : decidable_pred (λ (n : ℕ), ∃ (m : ℕ), m < n ∧ P m),	n : ℕ	⊢ (λ (n : ℕ), ∃ (m : ℕ), m < n ∧ P m) n ∨ P n ↔ (λ (n : ℕ), ∃ (m : ℕ), m < n ∧ P m) (n + 1)
a b c d : ℕ,	h : c + d = a + b - 1	⊢ a ≤ c ∨ b ≤ d
a b c d : ℕ,	h : c + d = a + b - 1,	h' : a ≤ c	⊢ a ≤ c ∨ b ≤ d
a b c d : ℕ,	h : c + d = a + b - 1	⊢ a ≤ c ∨ b ≤ d
a b c d : ℕ,	h : c + d = a + b - 1,	h' : c < a	⊢ a ≤ c ∨ b ≤ d
a b c d : ℕ,	h : c + d = a + b - 1,	h' : a ≤ c	⊢ a ≤ c		a b c d : ℕ,	h : c + d = a + b - 1,	h' : c < a	⊢ b ≤ d
a b c d : ℕ,	h : c + d = a + b - 1,	h' : a ≤ c	⊢ a ≤ c
a b c d : ℕ,	h : c + d = a + b - 1,	h' : c + d < a + d	⊢ b ≤ d
a b c d : ℕ,	h : c + d = a + b - 1,	h' : c < a	⊢ b ≤ d
a b c d : ℕ,	h : c + d = a + b - 1,	h' : a + b - 1 < a + d,	hb : b = 0	⊢ b ≤ d
a b c d : ℕ,	h : c + d = a + b - 1,	h' : a + b - 1 < a + d,	hb : b = 0	⊢ 0 ≤ d
a b c d : ℕ,	h : c + d = a + b - 1,	h' : a + b - 1 < a + d	⊢ b ≤ d
a b c d : ℕ,	h : c + d = a + b - 1,	h' : a + b - 1 < a + d,	hb : b = 0	⊢ b ≤ d		case or.inr	a b c d : ℕ,	h : c + d = a + b - 1,	h' : a + b - 1 < a + d,	hb : 0 < b	⊢ b ≤ d
a b c d : ℕ,	h : c + d = a + b - 1,	h' : a + b - 1 < a + d,	hb : 0 < b	⊢ b ≤ d
a b c d : ℕ,	h : c + d = a + b - 1,	hb : 0 < b,	h' : b - 1 < d	⊢ b ≤ d
⊢ comm_semigroup ℕ
a b c : ℕ,	hc0 : c = 0	⊢ a * (b / c) ≤ a * b / c
a b c : ℕ,	hc0 : ¬c = 0	⊢ a * (b / c) * c ≤ a * b
a b c : ℕ,	hc0 : ¬c = 0	⊢ a * (b / c * c) ≤ a * b
a b c : ℕ,	hc0 : ¬c = 0	⊢ a * (b / c) * c ≤ a * b
n : ℕ	⊢ n.land 0 = 0
K : Type u_1,	_inst_1 : division_ring K,	_inst_2 : char_zero K,	a b : ℕ	⊢ ↑(a.choose b) = polynomial.eval ↑(a - (b - 1)) (pochhammer K b) / ↑b!
L : list ℕ	⊢ nat.of_digits 1 L = L.sum
⊢ nat.of_digits 1 list.nil = list.nil.sum		case list.cons	d : ℕ,	L : list ℕ,	ih : nat.of_digits 1 L = L.sum	⊢ nat.of_digits 1 (d :: L) = (d :: L).sum
⊢ nat.of_digits 1 list.nil = list.nil.sum
d : ℕ,	L : list ℕ,	ih : nat.of_digits 1 L = L.sum	⊢ nat.of_digits 1 (d :: L) = (d :: L).sum
b b' : ℕ,	h : b' % b = 1,	n : ℕ	⊢ n ≡ (b'.digits n).sum [MOD b]
b b' : ℕ,	h : b' % b = 1,	n : ℕ	⊢ n ≡ nat.of_digits 1 (b'.digits n) [MOD b] = ?m_1
b b' : ℕ,	h : b' % b = 1,	n : ℕ	⊢ b = ?m_1		b b' : ℕ,	h : b' % b = 1,	n : ℕ	⊢ n = ?m_1		b b' : ℕ,	h : b' % b = 1,	n : ℕ	⊢ nat.of_digits 1 (b'.digits n) = ?m_1
b b' : ℕ,	h : b' % b = 1,	n : ℕ	⊢ n = ?m_1		b b' : ℕ,	h : b' % b = 1,	n : ℕ	⊢ nat.of_digits 1 (b'.digits n) = ?m_1
b b' : ℕ,	h : b' % b = 1,	n : ℕ	⊢ n ≡ nat.of_digits 1 (b'.digits n) [MOD b]
b b' : ℕ,	h : b' % b = 1,	n : ℕ	⊢ nat.of_digits b' (b'.digits n) ≡ nat.of_digits 1 (b'.digits n) [MOD b]
b b' : ℕ,	h : b' % b = 1,	n : ℕ	⊢ 1 = b' % b
digits : ℕ → ℕ → list ℕ,	b : ℕ	⊢ 2 ≤ b + 2
b n : ℕ	⊢ 0 < n + 1
b n : ℕ	⊢ (b + 2).digits (n + 1) = (n + 1) % (b + 2) :: (b + 2).digits ((n + 1) / (b + 2))
k n m : ℕ	⊢ (k * n).dist (k * m) = k * n.dist m
P : enat → Prop	⊢ ∀ (a : enat), P ⊤ → (∀ (n : ℕ), P (enat.some n)) → P a
P : enat → Prop	⊢ ∀ (a : enat), P ⊤ → (∀ (n : ℕ), P ↑n) → P a
x : ℕ,	h : ↑x.dom	⊢ ↑x.get h = x
x : enat	⊢ 0 < ⊤ ↔ 1 ≤ ⊤
x : enat,	n : ℕ	⊢ 0 < ↑n ↔ 1 ≤ ↑n
x : enat,	n : ℕ	⊢ 0 < n ↔ 1 ≤ n
x y : enat,	hx : x ≠ ⊤	⊢ x < y + 1 → x ≤ y		x y : enat,	hx : x ≠ ⊤	⊢ x ≤ y → x < y + 1
x y : enat,	hx : x ≠ ⊤	⊢ x < y + 1 ↔ x ≤ y
x y : enat,	hx : x ≠ ⊤,	h : x ≤ y	⊢ x < y + 1
x y : enat,	hx : x ≠ ⊤	⊢ x ≤ y → x < y + 1
y : enat,	m : ℕ,	hx : ↑m ≠ ⊤,	h : ↑m ≤ y	⊢ ↑m < y + 1
m : ℕ,	hx : ↑m ≠ ⊤,	h : ↑m ≤ ⊤	⊢ ↑m < ⊤ + 1
m : ℕ,	hx : ↑m ≠ ⊤,	h : ↑m ≤ ⊤	⊢ ↑m < ⊤
m : ℕ,	hx : ↑m ≠ ⊤,	h : ↑m ≤ ⊤	⊢ ↑m < ⊤ + 1		case ᾰ	m : ℕ,	hx : ↑m ≠ ⊤,	n : ℕ,	h : ↑m ≤ ↑n	⊢ ↑m < ↑n + 1
m : ℕ,	hx : ↑m ≠ ⊤,	n : ℕ,	h : ↑m ≤ ↑n,	this : ∀ {a b : ℕ}, a ≤ b → a < b.succ	⊢ m ≤ n
m : ℕ,	hx : ↑m ≠ ⊤,	n : ℕ,	h : ↑m ≤ ↑n	⊢ ↑m < ↑n + 1
n : ℕ	⊢ fib_aux_stream (n + 1) = fib_aux_step (fib_aux_stream n)
n : ℕ	⊢ stream.nth (n + 1) (stream.iterate fib_aux_step (0, 1)) = fib_aux_step (stream.nth n (stream.iterate fib_aux_step (0, 1)))
b : ℕ,	hb : b ≤ 1,	n : ℕ	⊢ nat.clog b n = 0
n : ℕ,	this : n ≡ 1 [MOD 2 * 2] → n ≡ 1 [MOD 2]	⊢ 2 * 2 = 4
n : ℕ	⊢ n % 4 = 1 → n % 2 = 1
α : Type u_1,	_inst_1 : nonempty α,	l : list α,	h : l.rotate 1 = l,	n n : ℕ,	hn : l.rotate n = l	⊢ l.rotate n.succ = l
m n b : ℕ,	hm : m ≠ 1,	hn : 0 < n,	hb : nat.log m n < b	⊢ multiplicity m n = ↑((finset.Ico 1 ((multiplicity m n).get _ + 1)).card)
m n b : ℕ,	hm : m ≠ 1,	hn : 0 < n,	hb : nat.log m n < b,	i : ℕ	⊢ i ∈ finset.Ico 1 ((multiplicity m n).get _ + 1) ↔ i ∈ finset.filter (λ (i : ℕ), m ^ i ∣ n) (finset.Ico 1 b)
m n b : ℕ,	hm : m ≠ 1,	hn : 0 < n,	hb : nat.log m n < b,	i : ℕ	⊢ 1 ≤ i ∧ m ^ i ∣ n ↔ (1 ≤ i ∧ m ^ i ∣ n) ∧ i < b
m n b : ℕ,	hm : m ≠ 1,	hn : 0 < n,	hb : nat.log m n < b,	i : ℕ,	h : 1 ≤ i ∧ m ^ i ∣ n	⊢ i < b
n b : ℕ,	hn : 0 < n,	i : ℕ,	hm : 0 ≠ 1,	hb : nat.log 0 n < b,	h : 1 ≤ i ∧ 0 ^ i ∣ n	⊢ i < b
n b : ℕ,	hn : 0 < n,	i : ℕ,	hm : 0 ≠ 1,	hb : nat.log 0 n < b,	h : 1 ≤ i ∧ n = 0	⊢ i < b		n b : ℕ,	hn : 0 < n,	i : ℕ,	hm : 0 ≠ 1,	hb : nat.log 0 n < b,	h : 1 ≤ i ∧ 0 ^ i ∣ n	⊢ 0 < i
n b : ℕ,	hn : 0 < n,	i : ℕ,	hm : 0 ≠ 1,	hb : nat.log 0 n < b,	h : 1 ≤ i ∧ 0 ^ i ∣ n	⊢ 0 < i
n b : ℕ,	hn : 0 < n,	i : ℕ,	hm : 0 ≠ 1,	hb : nat.log 0 n < b,	h : 1 ≤ i ∧ 0 ^ i ∣ n	⊢ i < b		case nat.succ	n b : ℕ,	hn : 0 < n,	i m : ℕ,	hm : m.succ ≠ 1,	hb : nat.log m.succ n < b,	h : 1 ≤ i ∧ m.succ ^ i ∣ n	⊢ i < b
n b : ℕ,	hn : 0 < n,	i m : ℕ,	hm : m.succ ≠ 1,	hb : nat.log m.succ n < b,	h : 1 ≤ i ∧ m.succ ^ i ∣ n	⊢ i < b
m n : ℕ,	h : even m	⊢ ¬even (n + 3) ↔ even (m ^ 2 + m + n)
m : ℕ,	shiftl_eq_mul_pow : ∀ (n : ℕ), m.shiftl n = m * 2 ^ n,	k : ℕ	⊢ bit0 (m.shiftl k) = m * (2 * 2 ^ k)
a b : ℕ,	a1 : 1 < a,	b1 : 1 < b,	h : nat.prime (a * b)	⊢ a * 1 = a * b
m n : ℕ,	h : n = 1 ∨ m ≤ n.min_fac,	p : ℕ,	pp : 1 < p,	d : p ∣ n	⊢ n = 1 → m ≤ p
m p : ℕ,	pp : 1 < p,	h : 1 = 1 ∨ m ≤ 1.min_fac,	d : p ∣ 1	⊢ m ≤ p
m n : ℕ,	h : n = 1 ∨ m ≤ n.min_fac,	p : ℕ,	pp : 1 < p,	d : p ∣ n	⊢ n = 1 → m ≤ p
p : ℕ,	hp : nat.prime p,	n : ℕ	⊢ (p ^ n).factors = list.repeat p n
p : ℕ,	hp : nat.prime p,	n : ℕ	⊢ list.repeat p n = (p ^ n).factors
p : ℕ,	hp : nat.prime p,	n : ℕ	⊢ list.repeat p n ~ (p ^ n).factors
p : ℕ,	hp : nat.prime p,	n : ℕ	⊢ ∀ (p_1 : ℕ), p_1 ∈ list.repeat p n → nat.prime p_1
p : ℕ,	hp : nat.prime p,	n q : ℕ,	hq : q ∈ list.repeat p n	⊢ nat.prime q
n q : ℕ	⊢ q = nat.sqrt n ↔ q ^ 2 ≤ n ∧ n < (q + 1) ^ 2
decidable_le : decidable_rel has_le.le,	a b : num	⊢ decidable (a ≤ b)
decidable_le : decidable_rel has_le.le,	a b : num	⊢ decidable (a ≤ b)
decidable_le : decidable_rel has_le.le,	a b : num	⊢ decidable (¬b < a)
div_to_nat : ∀ (n d : num), ↑(n / d) = ↑n / ↑d	⊢ ↑(0 / 0) = ↑0 / ↑0
n : znum	⊢ n.div 0 = 0
n : znum	⊢ n.div 0 = 0
⊢ znum.zero.div 0 = 0
n : pos_num	⊢ (znum.pos n).div 0 = 0
n : pos_num	⊢ (znum.neg n).div 0 = 0
div_to_int : ∀ (n d : znum), ↑(n / d) = ↑n / ↑d	⊢ ↑(0 / 0) = ↑0 / ↑0
div_to_int : ∀ (n d : znum), ↑(n / d) = ↑n / ↑d,	n d : pos_num	⊢ ↑(n.div' d) = ↑(znum.pos n) / ↑(znum.pos d)
div_to_int : ∀ (n d : znum), ↑(n / d) = ↑n / ↑d,	n d : pos_num	⊢ ↑↑(n.div' d) = ↑(znum.pos n) / ↑(znum.pos d)
div_to_int : ∀ (n d : znum), ↑(n / d) = ↑n / ↑d,	n d : pos_num	⊢ ↑(n.div' d) = ↑(znum.pos n) / ↑(znum.pos d)
div_to_int : ∀ (n d : znum), ↑(n / d) = ↑n / ↑d,	n d : pos_num	⊢ -↑(n.div' d) = ↑(znum.pos n) / ↑(znum.neg d)
div_to_int : ∀ (n d : znum), ↑(n / d) = ↑n / ↑d,	n d : pos_num	⊢ -↑↑(n.div' d) = ↑(znum.pos n) / ↑(znum.neg d)
div_to_int : ∀ (n d : znum), ↑(n / d) = ↑n / ↑d,	n d : pos_num	⊢ -↑(n.div' d) = ↑(znum.pos n) / ↑(znum.neg d)
div_to_int : ∀ (n d : znum), ↑(n / d) = ↑n / ↑d,	n d : pos_num	⊢ -↑((n.pred' / num.pos d).succ') = -↑n / ↑d
div_to_int : ∀ (n d : znum), ↑(n / d) = ↑n / ↑d,	n d : pos_num	⊢ -↑(↑(n.pred') / ↑(num.pos d) + 1) = -(↑↑(n.pred') + 1) / (↑↑(d.pred') + 1)
div_to_int : ∀ (n d : znum), ↑(n / d) = ↑n / ↑d,	n d : pos_num	⊢ -[1+ ↑(n.pred') / ↑d] = -[1+ ↑(n.pred') / (↑(d.pred') + 1)]
div_to_int : ∀ (n d : znum), ↑(n / d) = ↑n / ↑d,	n d : pos_num	⊢ ↑((n.pred' / num.pos d).succ') = -↑n / -↑d
div_to_int : ∀ (n d : znum), ↑(n / d) = ↑n / ↑d,	n d : pos_num	⊢ ↑(↑(n.pred') / ↑(num.pos d) + 1) = -(↑↑(n.pred') + 1) / -(↑↑(d.pred') + 1)
div_to_int : ∀ (n d : znum), ↑(n / d) = ↑n / ↑d,	n d : pos_num	⊢ ↑((↑(n.pred') / ↑d).succ) = ↑((↑(n.pred') / (↑(d.pred') + 1)).succ)
cmp_to_nat : ∀ (m n : num), (m.cmp n).cases_on (↑m < ↑n) (m = n) (↑n < ↑m),	a b : pos_num	⊢ ((num.pos a).cmp (num.pos b)).cases_on (↑(num.pos a) < ↑(num.pos b)) (num.pos a = num.pos b) (↑(num.pos b) < ↑(num.pos a))
cmp_to_nat : ∀ (m n : num), (m.cmp n).cases_on (↑m < ↑n) (m = n) (↑n < ↑m),	a b : pos_num	⊢ ((num.pos a).cmp (num.pos b)).cases_on (↑(num.pos a) < ↑(num.pos b)) (num.pos a = num.pos b) (↑(num.pos b) < ↑(num.pos a))
cmp_to_nat : ∀ (m n : num), (m.cmp n).cases_on (↑m < ↑n) (m = n) (↑n < ↑m),	a b : pos_num	⊢ ((num.pos a).cmp (num.pos b)).cases_on (↑(num.pos a) < ↑(num.pos b)) (num.pos a = num.pos b) (↑(num.pos b) < ↑(num.pos a))
cmp_to_nat : ∀ (m n : num), (m.cmp n).cases_on (↑m < ↑n) (m = n) (↑n < ↑m),	a b : pos_num,	this : (a.cmp b).cases_on (↑a < ↑b) (a = b) (↑b < ↑a)	⊢ ((num.pos a).cmp (num.pos b)).cases_on (↑(num.pos a) < ↑(num.pos b)) (num.pos a = num.pos b) (↑(num.pos b) < ↑(num.pos a))
cmp_to_nat : ∀ (m n : num), (m.cmp n).cases_on (↑m < ↑n) (m = n) (↑n < ↑m),	a b : pos_num	⊢ (a.cmp b).cases_on (↑a < ↑b) (a = b) (↑b < ↑a) → ((num.pos a).cmp (num.pos b)).cases_on (↑(num.pos a) < ↑(num.pos b)) (num.pos a = num.pos b) (↑(num.pos b) < ↑(num.pos a))
cmp_to_nat : ∀ (m n : num), (m.cmp n).cases_on (↑m < ↑n) (m = n) (↑n < ↑m),	a b : pos_num	⊢ ((num.pos a).cmp (num.pos b)).cases_on (↑(num.pos a) < ↑(num.pos b)) (num.pos a = num.pos b) (↑(num.pos b) < ↑(num.pos a))
cmp_to_nat : ∀ (m n : num), (m.cmp n).cases_on (↑m < ↑n) (m = n) (↑n < ↑m),	a b : pos_num	⊢ ordering.rec (↑a < ↑b) (a = b) (↑b < ↑a) ordering.lt → ordering.rec (↑a < ↑b) (num.pos a = num.pos b) (↑b < ↑a) ordering.lt		case ordering.eq	cmp_to_nat : ∀ (m n : num), (m.cmp n).cases_on (↑m < ↑n) (m = n) (↑n < ↑m),	a b : pos_num	⊢ ordering.rec (↑a < ↑b) (a = b) (↑b < ↑a) ordering.eq → ordering.rec (↑a < ↑b) (num.pos a = num.pos b) (↑b < ↑a) ordering.eq		case ordering.gt	cmp_to_nat : ∀ (m n : num), (m.cmp n).cases_on (↑m < ↑n) (m = n) (↑n < ↑m),	a b : pos_num	⊢ ordering.rec (↑a < ↑b) (a = b) (↑b < ↑a) ordering.gt → ordering.rec (↑a < ↑b) (num.pos a = num.pos b) (↑b < ↑a) ordering.gt
cmp_to_nat : ∀ (m n : num), (m.cmp n).cases_on (↑m < ↑n) (m = n) (↑n < ↑m),	a b : pos_num	⊢ ordering.rec (↑a < ↑b) (a = b) (↑b < ↑a) (a.cmp b) → ordering.rec (↑a < ↑b) (num.pos a = num.pos b) (↑b < ↑a) (a.cmp b)
⊢ comm_semiring num
⊢ comm_semiring num
⊢ comm_semiring num
⊢ comm_semiring num
a b : num	⊢ a * b = b * a
⊢ ∀ (a b c : num), a + b + c = a + (b + c)
⊢ ∀ (x : num), nsmul_rec 0 x = 0
⊢ ∀ (n : ℕ) (x : num), nsmul_rec n.succ x = x + nsmul_rec n x
⊢ ∀ (a b : num), a + b = b + a
⊢ ∀ (a b c : num), a * (b + c) = a * b + a * c
⊢ ∀ (a b c : num), (a + b) * c = a * c + b * c
⊢ ∀ (a : num), 0 * a = 0
⊢ ∀ (a : num), a * 0 = 0
⊢ ∀ (a b c : num), a * b * c = a * (b * c)
⊢ ∀ (a : num), 1 * a = a
⊢ ∀ (a : num), a * 1 = a
⊢ ∀ (x : num), npow_rec 0 x = 1
⊢ ∀ (n : ℕ) (x : num), npow_rec n.succ x = x * npow_rec n x
⊢ ∀ (a b : num), a * b = b * a
⊢ ∀ (a b c : num), a + b + c = a + (b + c)
⊢ ∀ (a b : num), a + b = b + a
⊢ ∀ (a b c : num), a * (b + c) = a * b + a * c
⊢ ∀ (a b c : num), (a + b) * c = a * c + b * c
⊢ ∀ (a : num), 0 * a = 0
⊢ ∀ (a : num), a * 0 = 0
⊢ ∀ (a b c : num), a * b * c = a * (b * c)
⊢ ∀ (a : num), 1 * a = a
⊢ ∀ (a : num), a * 1 = a
⊢ ∀ (a b : num), a * b = b * a
⊢ ∀ (a b : num), a * b = b * a
a b : num	⊢ ↑a + ↑b = ↑b + ↑a
a b c : num	⊢ ↑a * (↑b + ↑c) = ↑a * ↑b + ↑a * ↑c
a b c : num	⊢ (↑a + ↑b) * ↑c = ↑a * ↑c + ↑b * ↑c
a b c : num	⊢ ↑a * ↑b * ↑c = ↑a * (↑b * ↑c)
a b : num	⊢ ↑a * ↑b = ↑b * ↑a
⊢ ∀ (a b : num), a * b = b * a
n : pos_num	⊢ 1 + n = n.succ
n : pos_num	⊢ 1 + n = n.succ
⊢ 1 + pos_num.one = pos_num.one.succ
n : pos_num	⊢ 1 + n.bit1 = n.bit1.succ
n : pos_num	⊢ 1 + n.bit0 = n.bit0.succ
n : num	⊢ -n.to_znum_neg = n.to_znum
n : num	⊢ -n.to_znum_neg = n.to_znum
⊢ -num.zero.to_znum_neg = num.zero.to_znum
n : pos_num	⊢ -(num.pos n).to_znum_neg = (num.pos n).to_znum
n : znum	⊢ -n.succ = (-n).pred
n : znum	⊢ -n.succ = (-n).pred
n : znum	⊢ -n.succ = (-n).pred
⊢ -znum.zero.succ = (-znum.zero).pred
n : pos_num	⊢ -(znum.pos n).succ = (-znum.pos n).pred
n : pos_num	⊢ -(znum.neg n).succ = (-znum.neg n).pred
n : pos_num	⊢ -(znum.neg n).succ = (-znum.neg n).pred
n : pos_num	⊢ -(znum.neg n).succ = (-znum.neg n).pred
n : znum	⊢ -n.succ = (-n).pred
n : pos_num	⊢ n.pred'.to_znum = (-znum.neg n).pred
α : Type u_1,	_inst_1 : add_group α,	_inst_2 : has_one α,	cast_bit1 : ∀ (n : znum), ↑(n.bit1) = bit1 ↑n	⊢ ↑(0.bit1) = bit1 ↑0
α : Type u_1,	_inst_1 : add_group α,	_inst_2 : has_one α,	cast_bit1 : ∀ (n : znum), ↑(n.bit1) = bit1 ↑n,	p : pos_num	⊢ ↑((znum.pos p).bit1) = bit1 ↑(znum.pos p)
α : Type u_1,	_inst_1 : add_group α,	_inst_2 : has_one α,	cast_bit1 : ∀ (n : znum), ↑(n.bit1) = bit1 ↑n,	p : pos_num	⊢ ↑((znum.pos p).bit1) = bit1 ↑(znum.pos p)
α : Type u_1,	_inst_1 : add_group α,	_inst_2 : has_one α,	cast_bit1 : ∀ (n : znum), ↑(n.bit1) = bit1 ↑n,	p : pos_num	⊢ ↑(p.bit1) = bit1 ↑p
α : Type u_1,	_inst_1 : add_group α,	_inst_2 : has_one α,	cast_bit1 : ∀ (n : znum), ↑(n.bit1) = bit1 ↑n,	p : pos_num	⊢ ↑((znum.neg p).bit1) = bit1 ↑(znum.neg p)
α : Type u_1,	_inst_1 : add_group α,	_inst_2 : has_one α,	cast_bit1 : ∀ (n : znum), ↑(n.bit1) = bit1 ↑n,	p : pos_num	⊢ -↑(p.pred'.cases_on 1 pos_num.bit1) = bit1 (-↑p)
α : Type u_1,	_inst_1 : add_group α,	_inst_2 : has_one α,	cast_bit1 : ∀ (n : znum), ↑(n.bit1) = bit1 ↑n,	p : pos_num	⊢ -↑(p.pred'.cases_on 1 pos_num.bit1) = bit1 (-↑p)
α : Type u_1,	_inst_1 : add_group α,	_inst_2 : has_one α,	cast_bit1 : ∀ (n : znum), ↑(n.bit1) = bit1 ↑n,	p : pos_num,	e : p.pred' = num.zero	⊢ -↑(num.zero.cases_on 1 pos_num.bit1) = bit1 (-↑p)
α : Type u_1,	_inst_1 : add_group α,	_inst_2 : has_one α,	cast_bit1 : ∀ (n : znum), ↑(n.bit1) = bit1 ↑n,	p a : pos_num,	e : p.pred' = num.pos a	⊢ -↑((num.pos a).cases_on 1 pos_num.bit1) = bit1 (-↑p)
α : Type u_1,	_inst_1 : add_group α,	_inst_2 : has_one α,	cast_bit1 : ∀ (n : znum), ↑(n.bit1) = bit1 ↑n,	p : pos_num,	e : p.pred' = num.zero,	this : p = 1	⊢ -↑(num.zero.cases_on 1 pos_num.bit1) = bit1 (-↑p)
α : Type u_1,	_inst_1 : add_group α,	_inst_2 : has_one α,	cast_bit1 : ∀ (n : znum), ↑(n.bit1) = bit1 ↑n,	p : pos_num,	e : p.pred' = num.zero,	this : p = num.zero.succ'	⊢ -↑(num.zero.cases_on 1 pos_num.bit1) = bit1 (-↑p)
α : Type u_1,	_inst_1 : add_group α,	_inst_2 : has_one α,	cast_bit1 : ∀ (n : znum), ↑(n.bit1) = bit1 ↑n,	p : pos_num,	e : p.pred' = num.zero,	this : p = num.zero.succ'	⊢ -↑(num.zero.cases_on 1 pos_num.bit1) = bit1 (-↑p)		α : Type u_1,	_inst_1 : add_group α,	_inst_2 : has_one α,	cast_bit1 : ∀ (n : znum), ↑(n.bit1) = bit1 ↑n,	p a : pos_num,	e : p.pred' = num.pos a,	this : p = (num.pos a).succ'	⊢ -↑((num.pos a).cases_on 1 pos_num.bit1) = bit1 (-↑p)
α : Type u_1,	_inst_1 : add_group α,	_inst_2 : has_one α,	cast_bit1 : ∀ (n : znum), ↑(n.bit1) = bit1 ↑n,	e : 1.pred' = num.zero	⊢ -↑(num.zero.cases_on 1 pos_num.bit1) = bit1 (-↑1)
α : Type u_1,	_inst_1 : add_group α,	_inst_2 : has_one α,	cast_bit1 : ∀ (n : znum), ↑(n.bit1) = bit1 ↑n,	p a : pos_num,	e : p.pred' = num.pos a,	this : p = a.succ	⊢ -↑((num.pos a).cases_on 1 pos_num.bit1) = bit1 (-↑p)
α : Type u_1,	_inst_1 : add_group α,	_inst_2 : has_one α,	cast_bit1 : ∀ (n : znum), ↑(n.bit1) = bit1 ↑n,	p a : pos_num,	e : p.pred' = num.pos a,	this : p = (num.pos a).succ'	⊢ -↑((num.pos a).cases_on 1 pos_num.bit1) = bit1 (-↑p)
α : Type u_1,	_inst_1 : add_group α,	_inst_2 : has_one α,	cast_bit1 : ∀ (n : znum), ↑(n.bit1) = bit1 ↑n,	a : pos_num,	e : a.succ.pred' = num.pos a	⊢ ↑-↑a = -1 + ↑(-↑a + 1)
α : Type u_1,	_inst_1 : add_group α,	_inst_2 : has_one α,	cast_bit1 : ∀ (n : znum), ↑(n.bit1) = bit1 ↑n,	a : pos_num,	e : a.succ.pred' = num.pos a	⊢ ↑-↑a = -1 + ↑(-↑a + 1)		α : Type u_1,	_inst_1 : add_group α,	_inst_2 : has_one α,	cast_bit1 : ∀ (n : znum), ↑(n.bit1) = bit1 ↑n,	a : pos_num,	e : a.succ.pred' = num.pos a,	this : ↑-↑a = -1 + ↑(-↑a + 1)	⊢ -↑((num.pos a).cases_on 1 pos_num.bit1) = bit1 (-↑(a.succ))
α : Type u_1,	_inst_1 : add_group α,	_inst_2 : has_one α,	cast_bit1 : ∀ (n : znum), ↑(n.bit1) = bit1 ↑n,	a : pos_num,	e : a.succ.pred' = num.pos a	⊢ -↑((num.pos a).cases_on 1 pos_num.bit1) = bit1 (-↑(a.succ))
α : Type u_1,	_inst_1 : add_group α,	_inst_2 : has_one α,	cast_bit1 : ∀ (n : znum), ↑(n.bit1) = bit1 ↑n,	a : pos_num,	e : a.succ.pred' = num.pos a,	this : ↑-↑a = -1 + ↑(-↑a + 1)	⊢ -↑((num.pos a).cases_on 1 pos_num.bit1) = bit1 (-↑(a.succ))
n : ℕ	⊢ ↑n.to_znum_neg = -↑n
α : Type u_1,	_inst_1 : add_group α,	_inst_2 : has_one α,	n : znum	⊢ ↑(n.succ) = ↑n + 1
m n : pos_num	⊢ ↑m < ↑n → ↑m + ↑m + 1 + 1 ≤ ↑n + ↑n
m n : pos_num	⊢ ↑m < ↑n → ↑m + ↑m + 1 + 1 ≤ ↑n + ↑n
m n : pos_num,	h : ↑m < ↑n	⊢ ↑m + ↑m + 1 + 1 ≤ ↑n + ↑n
m n : pos_num	⊢ ↑m < ↑n → ↑m + ↑m + 1 + 1 ≤ ↑n + ↑n
m n : pos_num,	h : ↑m < ↑n	⊢ ↑m + 1 + (↑m + 1) ≤ ↑n + ↑n
α : Type u_1,	β : Type u_2,	γ : Type u_3,	x : option α,	f : α → option β,	g : β → option γ	⊢ (x.bind f).bind g = x.bind (λ (y : α), (f y).bind g)
α : Type u_1,	β : Type u_2,	γ : Type u_3,	x : option α,	f : α → option β,	g : β → option γ	⊢ (x.bind f).bind g = x.bind (λ (y : α), (f y).bind g)
α : Type u_1,	β : Type u_2,	γ : Type u_3,	f : α → option β,	g : β → option γ	⊢ (option.none.bind f).bind g = option.none.bind (λ (y : α), (f y).bind g)
α : Type u_1,	β : Type u_2,	γ : Type u_3,	f : α → option β,	g : β → option γ,	x : α	⊢ ((option.some x).bind f).bind g = (option.some x).bind (λ (y : α), (f y).bind g)
α β : Type u_1,	x : option α,	f : α → β,	b : β	⊢ f <$> x = option.some b ↔ ∃ (a : α), x = option.some a ∧ f a = b
α β : Type u_1,	f : α → β,	b : β	⊢ f <$> option.none = option.some b ↔ ∃ (a : α), option.none = option.some a ∧ f a = b
α β : Type u_1,	f : α → β,	b : β,	x : α	⊢ f <$> option.some x = option.some b ↔ ∃ (a : α), option.some x = option.some a ∧ f a = b
α β : Type u_1,	x : option α,	f : α → β,	b : β	⊢ f <$> x = option.some b ↔ ∃ (a : α), x = option.some a ∧ f a = b
α : Type u_1,	x : option α	⊢ ↥(x.is_some) ↔ ∃ (a : α), x = option.some a
α : Type u_1,	x : option α	⊢ ↥(x.is_some) ↔ ∃ (a : α), x = option.some a
α : Type u_1	⊢ ↥(option.none.is_some) ↔ ∃ (a : α), option.none = option.some a
α : Type u_1,	x : α	⊢ ↥((option.some x).is_some) ↔ ∃ (a : α), option.some x = option.some a
α : Type u_1,	x : option α	⊢ ↥(x.is_some) ↔ ∃ (a : α), x = option.some a
α : Type u_1,	dual_dual : ∀ (t : ordnode α), t.dual.dual = t,	s : ℕ,	l : ordnode α,	x : α,	r : ordnode α	⊢ (ordnode.node s l x r).dual.dual = ordnode.node s l x r
α : Type u_1,	l : ordnode α,	x : α,	m : ordnode α,	y : α,	r : ordnode α	⊢ (l.node3_r x m y r).dual = r.dual.node3_l y m.dual x l.dual
α : Type u_1,	P : α → Prop,	l : ordnode α,	x : α,	r : ordnode α,	hl : l.balanced,	hr : r.balanced,	sl : l.sized,	sr : r.sized,	H : (∃ (l' : ℕ), ordnode.raised l.size l' ∧ ordnode.balanced_sz l' r.size) ∨ ∃ (r' : ℕ), ordnode.raised r' r.size ∧ ordnode.balanced_sz l.size r'	⊢ ordnode.all P (l.balance_r x r) ↔ ordnode.all P l ∧ P x ∧ ordnode.all P r
α : Type u_1,	_inst_1 : preorder α,	valid'.dual : ∀ {t : ordnode α} {o₁ : with_bot α} {o₂ : with_top α}, ordnode.valid' o₁ t o₂ → ordnode.valid' o₂ t.dual o₁,	l : ordnode α,	x : α,	r : ordnode α,	o₁ : with_bot α,	o₂ : with_top α,	ol : l.bounded o₁ ↑x,	or : r.bounded ↑x o₂,	sl : l.sized,	sr : r.sized,	b : ordnode.balanced_sz l.size r.size,	bl : l.balanced,	br : r.balanced,	_let_match : ordnode.valid' ↑x l.dual o₁ → ordnode.valid' o₂ (ordnode.node (l.size + r.size + 1) l x r).dual o₁,	ol' : l.dual.bounded ↑x o₁,	sl' : l.dual.sized,	bl' : l.dual.balanced,	_let_match : ordnode.valid' o₂ r.dual ↑x → ordnode.valid' o₂ (ordnode.node (l.size + r.size + 1) l x r).dual o₁,	or' : r.dual.bounded o₂ ↑x,	sr' : r.dual.sized,	br' : r.dual.balanced	⊢ l.size + r.size + 1 = r.dual.size + l.dual.size + 1
α : Type u_1,	_inst_1 : preorder α,	valid'.dual : ∀ {t : ordnode α} {o₁ : with_bot α} {o₂ : with_top α}, ordnode.valid' o₁ t o₂ → ordnode.valid' o₂ t.dual o₁,	l : ordnode α,	x : α,	r : ordnode α,	o₁ : with_bot α,	o₂ : with_top α,	ol : l.bounded o₁ ↑x,	or : r.bounded ↑x o₂,	sl : l.sized,	sr : r.sized,	b : ordnode.balanced_sz l.size r.size,	bl : l.balanced,	br : r.balanced,	_let_match : ordnode.valid' ↑x l.dual o₁ → ordnode.valid' o₂ (ordnode.node (l.size + r.size + 1) l x r).dual o₁,	ol' : l.dual.bounded ↑x o₁,	sl' : l.dual.sized,	bl' : l.dual.balanced,	_let_match : ordnode.valid' o₂ r.dual ↑x → ordnode.valid' o₂ (ordnode.node (l.size + r.size + 1) l x r).dual o₁,	or' : r.dual.bounded o₂ ↑x,	sr' : r.dual.sized,	br' : r.dual.balanced	⊢ ordnode.balanced_sz r.dual.size l.dual.size
α : Type u_1,	_inst_1 : preorder α,	valid'.dual : ∀ {t : ordnode α} {o₁ : with_bot α} {o₂ : with_top α}, ordnode.valid' o₁ t o₂ → ordnode.valid' o₂ t.dual o₁,	l : ordnode α,	x : α,	r : ordnode α,	o₁ : with_bot α,	o₂ : with_top α,	ol : l.bounded o₁ ↑x,	or : r.bounded ↑x o₂,	sl : l.sized,	sr : r.sized,	b : ordnode.balanced_sz l.size r.size,	bl : l.balanced,	br : r.balanced,	_let_match : ordnode.valid' ↑x l.dual o₁ → ordnode.valid' o₂ (ordnode.node (l.size + r.size + 1) l x r).dual o₁,	ol' : l.dual.bounded ↑x o₁,	sl' : l.dual.sized,	bl' : l.dual.balanced,	_let_match : ordnode.valid' o₂ r.dual ↑x → ordnode.valid' o₂ (ordnode.node (l.size + r.size + 1) l x r).dual o₁,	or' : r.dual.bounded o₂ ↑x,	sr' : r.dual.sized,	br' : r.dual.balanced	⊢ ordnode.balanced_sz r.size l.size
α : Type u_1,	_inst_1 : preorder α,	valid'.dual : ∀ {t : ordnode α} {o₁ : with_bot α} {o₂ : with_top α}, ordnode.valid' o₁ t o₂ → ordnode.valid' o₂ t.dual o₁,	l : ordnode α,	x : α,	r : ordnode α,	o₁ : with_bot α,	o₂ : with_top α,	ol : l.bounded o₁ ↑x,	or : r.bounded ↑x o₂,	sl : l.sized,	sr : r.sized,	b : ordnode.balanced_sz l.size r.size,	bl : l.balanced,	br : r.balanced,	_let_match : ordnode.valid' ↑x l.dual o₁ → ordnode.valid' o₂ (ordnode.node (l.size + r.size + 1) l x r).dual o₁,	ol' : l.dual.bounded ↑x o₁,	sl' : l.dual.sized,	bl' : l.dual.balanced,	_let_match : ordnode.valid' o₂ r.dual ↑x → ordnode.valid' o₂ (ordnode.node (l.size + r.size + 1) l x r).dual o₁,	or' : r.dual.bounded o₂ ↑x,	sr' : r.dual.sized,	br' : r.dual.balanced	⊢ ordnode.balanced_sz r.dual.size l.dual.size
α : Type u,	β : Type v,	f g : α ≃. β,	fg : f ≤ g,	gf : g ≤ f	⊢ ∀ (x : α), ⇑f x = ⇑g x
α : Type u,	β : Type v,	f g : α ≃. β,	fg : f ≤ g,	gf : g ≤ f,	a : α	⊢ ⇑f a = ⇑g a
α : Type u,	β : Type v,	f g : α ≃. β,	fg : f ≤ g,	gf : g ≤ f,	a : α,	h : ⇑g a = option.none	⊢ ⇑f a = option.none
α : Type u,	β : Type v,	f g : α ≃. β,	fg : f ≤ g,	gf : g ≤ f,	a : α,	h : ⇑g a = option.none	⊢ ⇑f a = option.none		case option.some	α : Type u,	β : Type v,	f g : α ≃. β,	fg : f ≤ g,	gf : g ≤ f,	a : α,	b : β,	h : ⇑g a = option.some b	⊢ ⇑f a = option.some b
α : Type u,	β : Type v,	f g : α ≃. β,	fg : f ≤ g,	gf : g ≤ f,	a : α,	b : β,	h : ⇑g a = option.some b	⊢ ⇑f a = option.some b
α : Type u_1,	β : Type u_2,	f : α →. β,	s : set α,	h : s ⊆ f.dom,	a : α,	b : β	⊢ b ∈ f.restrict h a ↔ a ∈ s ∧ b ∈ f a
α : Type u_1,	β : Type u_2,	f : α →. β,	x : α	⊢ x ∈ f.dom ↔ ∃ (y : β), y ∈ f x
P : pfunctor,	α : Type u,	g : α → P.obj α,	x : α	⊢ (pfunctor.M.corec g x).dest = pfunctor.M.corec g <$> g x
u : prime_multiset	⊢ (0 • u).prod = u.prod ^ 0		case nat.succ	u : prime_multiset,	d : ℕ,	ih : (d • u).prod = u.prod ^ d	⊢ (d.succ • u).prod = u.prod ^ d.succ
d : ℕ,	u : prime_multiset	⊢ (d • u).prod = u.prod ^ d
u : prime_multiset,	d : ℕ,	ih : (d • u).prod = u.prod ^ d	⊢ (d.succ • u).prod = u.prod ^ d.succ
m n : ℕ+	⊢ (m.gcd n).factor_multiset = m.factor_multiset ⊓ n.factor_multiset
m n : ℕ+	⊢ (m.gcd n).factor_multiset ≤ m.factor_multiset ⊓ n.factor_multiset
m n : ℕ+	⊢ (m.gcd n).factor_multiset ≤ m.factor_multiset ⊓ n.factor_multiset
m n : ℕ+	⊢ (m.gcd n).factor_multiset ≤ m.factor_multiset ∧ (m.gcd n).factor_multiset ≤ n.factor_multiset
m n : ℕ+	⊢ (m.gcd n).factor_multiset ≤ m.factor_multiset
m n : ℕ+	⊢ (m.gcd n).factor_multiset ≤ n.factor_multiset
m n : ℕ+	⊢ (m.gcd n).factor_multiset ≤ m.factor_multiset ⊓ n.factor_multiset
m n : ℕ+	⊢ m.gcd n ∣ n
m n : ℕ+	⊢ (m.gcd n).factor_multiset ≤ m.factor_multiset ⊓ n.factor_multiset		m n : ℕ+	⊢ m.factor_multiset ⊓ n.factor_multiset ≤ (m.gcd n).factor_multiset
m n : ℕ+	⊢ m.gcd n ∣ m		m n : ℕ+	⊢ m.gcd n ∣ n
m n : ℕ+	⊢ m.factor_multiset ⊓ n.factor_multiset ≤ (m.gcd n).factor_multiset
m n : ℕ+	⊢ (m.factor_multiset ⊓ n.factor_multiset).prod ∣ m.gcd n
m n : ℕ+	⊢ (m.factor_multiset ⊓ n.factor_multiset).prod ∣ m
m n : ℕ+	⊢ (m.factor_multiset ⊓ n.factor_multiset).prod ∣ n
m n : ℕ+	⊢ (m.factor_multiset ⊓ n.factor_multiset).prod ∣ m.gcd n
m n : ℕ+	⊢ m.factor_multiset ⊓ n.factor_multiset ≤ n.factor_multiset
m n : ℕ+	⊢ m.factor_multiset ⊓ n.factor_multiset ≤ m.factor_multiset		m n : ℕ+	⊢ m.factor_multiset ⊓ n.factor_multiset ≤ n.factor_multiset
l u : ℕ+,	n m : {x // x ∈ finset.Ico ↑l ↑u},	h : (λ (n : {x // x ∈ finset.Ico ↑l ↑u}), ⟨↑n, _⟩) n = (λ (n : {x // x ∈ finset.Ico ↑l ↑u}), ⟨↑n, _⟩) m	⊢ n.val = m.val
l u : ℕ+,	n m : {x // x ∈ finset.Ico ↑l ↑u},	h : ((λ (n : {x // x ∈ finset.Ico ↑l ↑u}), ⟨↑n, _⟩) n).val = ((λ (n : {x // x ∈ finset.Ico ↑l ↑u}), ⟨↑n, _⟩) m).val	⊢ n.val = m.val
m n k : ℕ+	⊢ k.coprime n → (k * m).gcd n = m.gcd n
m n k : ℕ+	⊢ k.coprime n → (m * k).gcd n = m.gcd n
R : Type u,	_inst_1 : semiring R,	p : polynomial R,	n : ℕ	⊢ ⇑(polynomial.monomial n) (p.coeff n) + polynomial.erase n p = p
R : Type u,	_inst_1 : semiring R,	n : ℕ,	p : add_monoid_algebra R ℕ	⊢ ⇑(polynomial.monomial n) ({to_finsupp := p}.coeff n) + polynomial.erase n {to_finsupp := p} = {to_finsupp := p}
R : Type u,	_inst_1 : semiring R,	n : ℕ,	p : add_monoid_algebra R ℕ	⊢ finsupp.single n (⇑p n) + finsupp.erase n p = p
R : Type u,	_inst_1 : ring R,	n : ℕ,	p : add_monoid_algebra R ℕ	⊢ (-{to_finsupp := p}).coeff n = -{to_finsupp := p}.coeff n
R : Type u,	_inst_1 : ring R,	p : polynomial R,	n : ℕ	⊢ (-p).coeff n = -p.coeff n
R : Type u,	S : Type v,	_inst_1 : semiring R,	p : polynomial R,	_inst_2 : semiring S,	q : polynomial S,	h : p.degree = q.degree	⊢ p.nat_degree = q.nat_degree
R : Type u,	S : Type v,	_inst_1 : semiring R,	p : polynomial R,	_inst_2 : semiring S,	q : polynomial S,	h : p.degree = q.degree	⊢ option.get_or_else p.degree 0 = option.get_or_else q.degree 0
R : Type u,	S : Type v,	_inst_1 : semiring R,	p : polynomial R,	_inst_2 : semiring S,	q : polynomial S,	h : p.degree = q.degree	⊢ p.nat_degree = q.nat_degree
R : Type u_1,	_inst_2 : semiring R,	_inst_3 : nontrivial R,	hp : 0.monic	⊢ false
R : Type u_1,	_inst_2 : semiring R,	_inst_3 : nontrivial R,	p : polynomial R,	hp : p.monic	⊢ p ≠ 0
R : Type u,	_inst_1 : semiring R,	p : polynomial R,	hp : p ≠ 0,	_let_match : (∃ (x : ℕ), ¬x ∉ p.degree) → p.degree = ↑(p.nat_degree),	n : ℕ,	hn : ¬n ∉ p.degree,	hn : p.degree = option.some n	⊢ p.degree = ↑(p.nat_degree)
R : Type u,	_inst_1 : semiring R,	p : polynomial R,	hp : p ≠ 0,	_let_match : (∃ (x : ℕ), ¬x ∉ p.degree) → p.degree = ↑(p.nat_degree),	n : ℕ,	hn : ¬n ∉ p.degree,	hn : p.degree = option.some n	⊢ option.some n = ↑((option.some n).get_or_else 0)
R : Type u,	_inst_1 : semiring R,	p : polynomial R,	hp : p ≠ 0,	_let_match : (∃ (x : ℕ), ¬x ∉ p.degree) → p.degree = ↑(p.nat_degree),	n : ℕ,	hn : ¬n ∉ p.degree,	hn : p.degree = option.some n	⊢ p.degree = ↑(p.nat_degree)
R : Type u,	a : R,	_inst_1 : semiring R,	p : polynomial R,	ai : R,	au : ai * a = 1	⊢ p.nat_degree = (1 * p).nat_degree
R : Type u,	a : R,	_inst_1 : semiring R,	p : polynomial R,	ai : R,	au : ai * a = 1	⊢ (1 * p).nat_degree = (⇑polynomial.C ai * (⇑polynomial.C a * p)).nat_degree
R : Type u,	_inst_1 : semiring R,	n : ℕ	⊢ ↑n.nat_trailing_degree = 0
R : Type u_1,	K : Type u_2,	_inst_1 : semiring R,	_inst_2 : comm_semiring K,	i : R →+* K,	a b : R,	N : ℕ,	f g : polynomial R,	_x : denoms_clearable a b N f i,	_fun_match : denoms_clearable a b N f i → denoms_clearable a b N g i → denoms_clearable a b N (f + g) i,	Df : R,	bf : K,	bfu : bf * ⇑i b = 1,	Hf : ⇑i Df = ⇑i b ^ N * polynomial.eval (⇑i a * bf) (polynomial.map i f),	_x : denoms_clearable a b N g i,	_fun_match : denoms_clearable a b N g i → denoms_clearable a b N (f + g) i,	Dg : R,	bg : K,	bgu : bg * ⇑i b = 1,	Hg : ⇑i Dg = ⇑i b ^ N * polynomial.eval (⇑i a * bg) (polynomial.map i g)	⊢ ⇑i (Df + Dg) = ⇑i b ^ N * polynomial.eval (⇑i a * bf) (polynomial.map i (f + g))
R : Type u_1,	K : Type u_2,	_inst_1 : semiring R,	_inst_2 : comm_semiring K,	i : R →+* K,	a b : R,	N : ℕ,	f g : polynomial R,	_x : denoms_clearable a b N f i,	_fun_match : denoms_clearable a b N f i → denoms_clearable a b N g i → denoms_clearable a b N (f + g) i,	Df : R,	bf : K,	bfu : bf * ⇑i b = 1,	Hf : ⇑i Df = ⇑i b ^ N * polynomial.eval (⇑i a * bf) (polynomial.map i f),	_x : denoms_clearable a b N g i,	_fun_match : denoms_clearable a b N g i → denoms_clearable a b N (f + g) i,	Dg : R,	bg : K,	bgu : bg * ⇑i b = 1,	Hg : ⇑i Dg = ⇑i b ^ N * polynomial.eval (⇑i a * bg) (polynomial.map i g)	⊢ ⇑i b ^ N * polynomial.eval (⇑i a * bf) (polynomial.map i f) + ⇑i b ^ N * polynomial.eval (⇑i a * bg) (polynomial.map i g) = ⇑i b ^ N * polynomial.eval (⇑i a * bf) (polynomial.map i f) + ⇑i b ^ N * polynomial.eval (⇑i a * bf) (polynomial.map i g)
R : Type u_1,	K : Type u_2,	_inst_1 : semiring R,	_inst_2 : comm_semiring K,	i : R →+* K,	a b : R,	N : ℕ,	f g : polynomial R,	_x : denoms_clearable a b N f i,	_fun_match : denoms_clearable a b N f i → denoms_clearable a b N g i → denoms_clearable a b N (f + g) i,	Df : R,	bf : K,	bfu : bf * ⇑i b = 1,	Hf : ⇑i Df = ⇑i b ^ N * polynomial.eval (⇑i a * bf) (polynomial.map i f),	_x : denoms_clearable a b N g i,	_fun_match : denoms_clearable a b N g i → denoms_clearable a b N (f + g) i,	Dg : R,	bg : K,	bgu : bg * ⇑i b = 1,	Hg : ⇑i Dg = ⇑i b ^ N * polynomial.eval (⇑i a * bg) (polynomial.map i g)	⊢ bg = bf
R : Type u_1,	K : Type u_2,	_inst_1 : semiring R,	_inst_2 : comm_semiring K,	i : R →+* K,	a b : R,	N : ℕ,	f g : polynomial R,	_x : denoms_clearable a b N f i,	_fun_match : denoms_clearable a b N f i → denoms_clearable a b N g i → denoms_clearable a b N (f + g) i,	Df : R,	bf : K,	bfu : bf * ⇑i b = 1,	Hf : ⇑i Df = ⇑i b ^ N * polynomial.eval (⇑i a * bf) (polynomial.map i f),	_x : denoms_clearable a b N g i,	_fun_match : denoms_clearable a b N g i → denoms_clearable a b N (f + g) i,	Dg : R,	bg : K,	bgu : bg * ⇑i b = 1,	Hg : ⇑i Dg = ⇑i b ^ N * polynomial.eval (⇑i a * bg) (polynomial.map i g)	⊢ bg = bf
R : Type u_1,	K : Type u_2,	_inst_1 : semiring R,	_inst_2 : comm_semiring K,	i : R →+* K,	a b : R,	N : ℕ,	f g : polynomial R,	_x : denoms_clearable a b N f i,	_fun_match : denoms_clearable a b N f i → denoms_clearable a b N g i → denoms_clearable a b N (f + g) i,	Df : R,	bf : K,	bfu : bf * ⇑i b = 1,	Hf : ⇑i Df = ⇑i b ^ N * polynomial.eval (⇑i a * bf) (polynomial.map i f),	_x : denoms_clearable a b N g i,	_fun_match : denoms_clearable a b N g i → denoms_clearable a b N (f + g) i,	Dg : R,	bg : K,	bgu : bg * ⇑i b = 1,	Hg : ⇑i Dg = ⇑i b ^ N * polynomial.eval (⇑i a * bg) (polynomial.map i g)	⊢ ⇑i b * bg = 1
R : Type u_1,	K : Type u_2,	_inst_1 : semiring R,	_inst_2 : comm_semiring K,	i : R →+* K,	a b : R,	N : ℕ,	f g : polynomial R,	_x : denoms_clearable a b N f i,	_fun_match : denoms_clearable a b N f i → denoms_clearable a b N g i → denoms_clearable a b N (f + g) i,	Df : R,	bf : K,	bfu : bf * ⇑i b = 1,	Hf : ⇑i Df = ⇑i b ^ N * polynomial.eval (⇑i a * bf) (polynomial.map i f),	_x : denoms_clearable a b N g i,	_fun_match : denoms_clearable a b N g i → denoms_clearable a b N (f + g) i,	Dg : R,	bg : K,	bgu : bg * ⇑i b = 1,	Hg : ⇑i Dg = ⇑i b ^ N * polynomial.eval (⇑i a * bg) (polynomial.map i g)	⊢ ⇑i b * bf = 1
R : Type u,	S : Type v,	_inst_1 : comm_semiring R,	_inst_2 : comm_semiring S,	p : polynomial R,	f : R →+* S,	r : R	⊢ ⇑polynomial.derivative (polynomial.map f (⇑polynomial.C r)) = polynomial.map f (⇑polynomial.derivative (⇑polynomial.C r))
R : Type u,	S : Type v,	_inst_1 : comm_semiring R,	_inst_2 : comm_semiring S,	p : polynomial R,	f : R →+* S,	p q : polynomial R,	ihp : ⇑polynomial.derivative (polynomial.map f p) = polynomial.map f (⇑polynomial.derivative p),	ihq : ⇑polynomial.derivative (polynomial.map f q) = polynomial.map f (⇑polynomial.derivative q)	⊢ ⇑polynomial.derivative (polynomial.map f (p + q)) = polynomial.map f (⇑polynomial.derivative (p + q))
R : Type u,	S : Type v,	_inst_1 : comm_semiring R,	_inst_2 : comm_semiring S,	p : polynomial R,	f : R →+* S,	n : ℕ,	r : R,	ih : ⇑polynomial.derivative (polynomial.map f (⇑polynomial.C r * polynomial.X ^ n)) = polynomial.map f (⇑polynomial.derivative (⇑polynomial.C r * polynomial.X ^ n))	⊢ ⇑polynomial.derivative (polynomial.map f (⇑polynomial.C r * polynomial.X ^ (n + 1))) = polynomial.map f (⇑polynomial.derivative (⇑polynomial.C r * polynomial.X ^ (n + 1)))
R : Type u,	_inst_1 : comm_semiring R,	p : polynomial R,	H : p = 0	⊢ (⇑polynomial.derivative p).degree = p.degree
R : Type u,	_inst_2 : comm_ring R,	f g : polynomial R,	hg : g.monic	⊢ (f /ₘ g).nat_degree = f.nat_degree - g.nat_degree
R : Type u,	_inst_2 : comm_ring R,	f g : polynomial R,	hg : g.monic,	h01 : 0 = 1	⊢ (f /ₘ g).nat_degree = f.nat_degree - g.nat_degree
R : Type u,	_inst_2 : comm_ring R,	f g : polynomial R,	hg : g.monic,	h01 : 0 = 1,	_inst : subsingleton R	⊢ (f /ₘ g).nat_degree = f.nat_degree - g.nat_degree
R : Type u,	_inst_2 : comm_ring R,	f g : polynomial R,	hg : g.monic,	h01 : 0 = 1	⊢ (f /ₘ g).nat_degree = f.nat_degree - g.nat_degree		R : Type u,	_inst_2 : comm_ring R,	f g : polynomial R,	hg : g.monic,	h01 : ¬0 = 1	⊢ (f /ₘ g).nat_degree = f.nat_degree - g.nat_degree
R : Type u,	_inst_2 : comm_ring R,	f g : polynomial R,	hg : g.monic,	h01 : ¬0 = 1	⊢ (f /ₘ g).nat_degree = f.nat_degree - g.nat_degree
R : Type u,	_inst_2 : comm_ring R,	f g : polynomial R,	hg : g.monic,	h01 : ¬0 = 1,	_inst : nontrivial R	⊢ (f /ₘ g).nat_degree = f.nat_degree - g.nat_degree
R : Type u,	_inst_2 : comm_ring R,	f g : polynomial R,	hg : g.monic,	h01 : ¬0 = 1,	_inst : nontrivial R,	hfg : f /ₘ g = 0	⊢ 0 = f.nat_degree - g.nat_degree
R : Type u,	_inst_2 : comm_ring R,	f g : polynomial R,	hg : g.monic,	h01 : ¬0 = 1,	_inst : nontrivial R,	hfg : f /ₘ g = 0	⊢ (f /ₘ g).nat_degree = f.nat_degree - g.nat_degree
R : Type u,	_inst_2 : comm_ring R,	f g : polynomial R,	hg : g.monic,	h01 : ¬0 = 1,	_inst : nontrivial R,	hfg : f.degree < g.degree	⊢ 0 = f.nat_degree - g.nat_degree
R : Type u,	_inst_2 : comm_ring R,	f g : polynomial R,	hg : g.monic,	h01 : ¬0 = 1,	_inst : nontrivial R,	hfg : f /ₘ g = 0	⊢ (f /ₘ g).nat_degree = f.nat_degree - g.nat_degree		R : Type u,	_inst_2 : comm_ring R,	f g : polynomial R,	hg : g.monic,	h01 : ¬0 = 1,	_inst : nontrivial R,	hfg : ¬f /ₘ g = 0	⊢ (f /ₘ g).nat_degree = f.nat_degree - g.nat_degree
R : Type u,	_inst_2 : comm_ring R,	f g : polynomial R,	hg : g.monic,	h01 : ¬0 = 1,	_inst : nontrivial R,	hfg hgf : ¬f /ₘ g = 0	⊢ (f /ₘ g).nat_degree = f.nat_degree - g.nat_degree
R : Type u,	_inst_2 : comm_ring R,	f g : polynomial R,	hg : g.monic,	h01 : ¬0 = 1,	_inst : nontrivial R,	hfg : ¬f /ₘ g = 0	⊢ (f /ₘ g).nat_degree = f.nat_degree - g.nat_degree
R : Type u,	_inst_2 : comm_ring R,	f g : polynomial R,	hg : g.monic,	h01 : ¬0 = 1,	_inst : nontrivial R,	hfg : ¬f /ₘ g = 0,	hgf : ¬f.degree < g.degree	⊢ (f /ₘ g).nat_degree = f.nat_degree - g.nat_degree
R : Type u,	_inst_2 : comm_ring R,	f g : polynomial R,	hg : g.monic,	h01 : ¬0 = 1,	_inst : nontrivial R,	hfg : ¬f /ₘ g = 0,	hgf : g.degree ≤ f.degree	⊢ (f /ₘ g).nat_degree = f.nat_degree - g.nat_degree
R : Type u,	_inst_2 : comm_ring R,	f g : polynomial R,	hg : g.monic,	h01 : ¬0 = 1,	_inst : nontrivial R,	hfg : ¬f /ₘ g = 0,	hgf : g.degree ≤ f.degree,	this : g.degree + (f /ₘ g).degree = f.degree	⊢ f ≠ 0
R : Type u,	_inst_2 : comm_ring R,	f g : polynomial R,	hg : g.monic,	h01 : ¬0 = 1,	_inst : nontrivial R,	hfg : ¬f /ₘ g = 0,	hgf : g.degree ≤ f.degree,	this : g.degree + (f /ₘ g).degree = f.degree,	hf : f = 0	⊢ false
R : Type u,	_inst_2 : comm_ring R,	f g : polynomial R,	hg : g.monic,	h01 : ¬0 = 1,	_inst : nontrivial R,	hfg : ¬f /ₘ g = 0,	hgf : g.degree ≤ f.degree,	this : g.degree + (f /ₘ g).degree = f.degree	⊢ (f /ₘ g).nat_degree = f.nat_degree - g.nat_degree
R : Type u,	_inst_2 : comm_ring R,	f g : polynomial R,	hg : g.monic,	h01 : ¬0 = 1,	_inst : nontrivial R,	hfg : ¬f /ₘ g = 0,	hgf : g.degree ≤ f.degree,	this : g.degree + (f /ₘ g).degree = f.degree,	hf : f = 0	⊢ f /ₘ g = 0
R : Type u,	_inst_2 : comm_ring R,	f g : polynomial R,	hg : g.monic,	h01 : ¬0 = 1,	_inst : nontrivial R,	hfg : ¬f /ₘ g = 0,	hgf : g.degree ≤ f.degree,	this : g.degree + (f /ₘ g).degree = f.degree	⊢ f ≠ 0		R : Type u,	_inst_2 : comm_ring R,	f g : polynomial R,	hg : g.monic,	h01 : ¬0 = 1,	_inst : nontrivial R,	hfg : ¬f /ₘ g = 0,	hgf : g.degree ≤ f.degree,	this : g.degree + (f /ₘ g).degree = f.degree,	hf : f ≠ 0	⊢ (f /ₘ g).nat_degree = f.nat_degree - g.nat_degree
R : Type u,	_inst_2 : comm_ring R,	f g : polynomial R,	hg : g.monic,	h01 : ¬0 = 1,	_inst : nontrivial R,	hfg : ¬f /ₘ g = 0,	hgf : g.degree ≤ f.degree,	this : g.degree + (f /ₘ g).degree = f.degree,	hf : f ≠ 0	⊢ (f /ₘ g).nat_degree = f.nat_degree - g.nat_degree
R : Type u,	_inst_2 : comm_ring R,	f g : polynomial R,	hg : g.monic,	h01 : ¬0 = 1,	_inst : nontrivial R,	hfg : ¬f /ₘ g = 0,	hgf : g.degree ≤ f.degree,	hf : f ≠ 0,	this : g.nat_degree + (f /ₘ g).nat_degree = f.nat_degree	⊢ (f /ₘ g).nat_degree = f.nat_degree - g.nat_degree
R : Type u,	S : Type v,	_inst_1 : comm_ring R,	_inst_2 : comm_ring S,	f : R →+* S,	hf : function.injective ⇑f,	x y : polynomial R,	hx : x.monic	⊢ polynomial.map f x ∣ polynomial.map f y ↔ x ∣ y
R : Type u,	S : Type v,	_inst_1 : comm_ring R,	_inst_2 : comm_ring S,	f : R →+* S,	hf : function.injective ⇑f,	x y : polynomial R,	hx : x.monic,	H : polynomial.map f (y %ₘ x) = 0	⊢ polynomial.map f (y %ₘ x) = polynomial.map f 0
R : Type u,	S : Type v,	_inst_1 : comm_ring R,	_inst_2 : comm_ring S,	f : R →+* S,	hf : function.injective ⇑f,	x y : polynomial R,	hx : x.monic	⊢ polynomial.map f (y %ₘ x) = 0 ↔ y %ₘ x = 0
R : Type u,	S : Type v,	_inst_1 : comm_ring R,	_inst_2 : comm_ring S,	f : R →+* S,	hf : function.injective ⇑f,	x y : polynomial R,	hx : x.monic,	H : y %ₘ x = 0	⊢ polynomial.map f (y %ₘ x) = 0
R : Type u,	_inst_1 : semiring R,	p : polynomial R,	x : R	⊢ polynomial.eval x (p * polynomial.X) = polynomial.eval x p * x
R : Type u,	_inst_1 : semiring R,	p : polynomial R,	x : R	⊢ ∀ (p q : polynomial R), polynomial.eval x (p * polynomial.X) = polynomial.eval x p * x → polynomial.eval x (q * polynomial.X) = polynomial.eval x q * x → polynomial.eval x ((p + q) * polynomial.X) = polynomial.eval x (p + q) * x
R : Type u,	_inst_1 : semiring R,	p : polynomial R,	x : R	⊢ ∀ (p q : polynomial R), polynomial.eval x (p * polynomial.X) = polynomial.eval x p * x → polynomial.eval x (q * polynomial.X) = polynomial.eval x q * x → polynomial.eval x ((p + q) * polynomial.X) = polynomial.eval x (p + q) * x		R : Type u,	_inst_1 : semiring R,	p : polynomial R,	x : R	⊢ ∀ (n : ℕ) (a : R), polynomial.eval x (⇑(polynomial.monomial n) a * polynomial.X) = polynomial.eval x (⇑(polynomial.monomial n) a) * x
R : Type u,	_inst_1 : semiring R,	p : polynomial R,	x : R,	p q : polynomial R,	ph : polynomial.eval x (p * polynomial.X) = polynomial.eval x p * x,	qh : polynomial.eval x (q * polynomial.X) = polynomial.eval x q * x	⊢ polynomial.eval x ((p + q) * polynomial.X) = polynomial.eval x (p + q) * x
R : Type u,	_inst_1 : semiring R,	p : polynomial R,	x : R	⊢ ∀ (n : ℕ) (a : R), polynomial.eval x (⇑(polynomial.monomial n) a * polynomial.X) = polynomial.eval x (⇑(polynomial.monomial n) a) * x
R : Type u,	_inst_1 : semiring R,	p : polynomial R,	x : R,	n : ℕ,	a : R	⊢ polynomial.eval x (⇑(polynomial.monomial n) a * polynomial.X) = polynomial.eval x (⇑(polynomial.monomial n) a) * x
R : Type u,	S : Type v,	_inst_1 : semiring R,	p : polynomial R,	_inst_2 : semiring S,	f : R →+* S,	hf : ⇑f p.leading_coeff ≠ 0	⊢ (polynomial.map f p).leading_coeff = ⇑f p.leading_coeff
R : Type u,	S : Type v,	_inst_1 : semiring R,	p : polynomial R,	_inst_2 : semiring S,	f : R →+* S,	hf : ⇑f p.leading_coeff ≠ 0	⊢ (polynomial.map f p).coeff (polynomial.map f p).nat_degree = ⇑f (p.coeff p.nat_degree)
R : Type u,	_inst_1 : ring R,	p q : polynomial R,	S : Type u_1,	_inst_2 : ring S,	f : R →+* S,	x : S	⊢ polynomial.eval₂ f x (p - q) = polynomial.eval₂ f x p - polynomial.eval₂ f x q
R : Type u_1,	S : Type u_2,	_inst_2 : field R,	_inst_3 : field S,	_inst_4 : algebra R S,	n : ℕ,	hn : n ≠ 0,	a : R,	ha : a ≠ 0	⊢ (⇑polynomial.C a * polynomial.X ^ n).root_set S = {0}
R : Type u_1,	S : Type u_2,	_inst_2 : field R,	_inst_3 : field S,	_inst_4 : algebra R S,	n : ℕ,	hn : n ≠ 0,	a : R,	ha : a ≠ 0,	x : S	⊢ x ∈ (⇑polynomial.C a * polynomial.X ^ n).root_set S ↔ x ∈ {0}
R : Type u_1,	S : Type u_2,	_inst_2 : field R,	_inst_3 : field S,	_inst_4 : algebra R S,	n : ℕ,	hn : n ≠ 0,	a : R,	ha : a ≠ 0,	x : S	⊢ ⇑(algebra_map R S) a = 0 ∨ x ^ n = 0 ↔ x = 0
R : Type u_1,	S : Type u_2,	_inst_2 : field R,	_inst_3 : field S,	_inst_4 : algebra R S,	n : ℕ,	hn : n ≠ 0,	a : R,	ha : a ≠ 0,	x : S	⊢ ⇑(algebra_map R S) a = 0 ∨ x ^ n = 0 ↔ x = 0		R : Type u_1,	S : Type u_2,	_inst_2 : field R,	_inst_3 : field S,	_inst_4 : algebra R S,	n : ℕ,	hn : n ≠ 0,	a : R,	ha : a ≠ 0,	x : S	⊢ ⇑polynomial.C a * polynomial.X ^ n ≠ 0
R : Type u_1,	S : Type u_2,	_inst_2 : field R,	_inst_3 : field S,	_inst_4 : algebra R S,	n : ℕ,	hn : n ≠ 0,	a : R,	ha : a ≠ 0,	x : S	⊢ a = 0 → x = 0
R : Type u_1,	S : Type u_2,	_inst_2 : field R,	_inst_3 : field S,	_inst_4 : algebra R S,	n : ℕ,	hn : n ≠ 0,	a : R,	ha : a ≠ 0,	x : S	⊢ ⇑polynomial.C a * polynomial.X ^ n ≠ 0
R : Type u,	_inst_1 : field R,	u : units (polynomial R),	n : ℕ	⊢ (↑u.coeff n)⁻¹ = ↑u⁻¹.coeff n
R : Type u,	_inst_1 : field R,	u : units (polynomial R),	n : ℕ	⊢ 1 / ite (n = 0) (↑u.coeff 0) 0 = ite (n = 0) (↑u⁻¹.coeff 0) 0
R : Type u,	_inst_1 : field R,	u : units (polynomial R),	n : ℕ,	h : n = 0	⊢ 1 / ↑u.coeff 0 = ↑u⁻¹.coeff 0
R : Type u,	_inst_1 : field R,	u : units (polynomial R),	n : ℕ,	h : n = 0	⊢ 1 / ↑u.coeff 0 = ↑u⁻¹.coeff 0
R : Type u,	_inst_1 : field R,	u : units (polynomial R),	n : ℕ,	h : n = 0	⊢ 1 / ↑u.coeff 0 = ↑u⁻¹.coeff 0		R : Type u,	_inst_1 : field R,	u : units (polynomial R),	n : ℕ,	h : ¬n = 0	⊢ 1 / 0 = 0
R : Type u,	_inst_1 : field R,	u : units (polynomial R),	n : ℕ,	h : n = 0	⊢ polynomial.eval 0 ↑1 = 1
R : Type u,	_inst_1 : field R,	u : units (polynomial R),	n : ℕ,	h : ¬n = 0	⊢ 1 / 0 = 0
R : Type u_1,	_inst_1 : semiring R,	f : polynomial R	⊢ ⇑(polynomial.hasse_deriv 1) f = ⇑polynomial.derivative f
R : Type u,	_inst_1 : semiring R,	f : polynomial R,	i : ℕ,	this : f.coeff i = 0 → f.degree ≠ ↑i	⊢ f.integral_normalization.coeff i = ite (f.degree = ↑i) 1 (f.coeff i * f.leading_coeff ^ (f.nat_degree - 1 - i))
R : Type u,	_inst_1 : semiring R,	S : Type v,	_inst_2 : semiring S,	f : R →+* S,	_inst_3 : nontrivial S,	p : polynomial S,	hlifts : p ∈ polynomial.lifts f,	hmonic : p.monic	⊢ ∃ (q : polynomial R), polynomial.map f q = p ∧ q.degree = p.degree ∧ q.monic
R : Type u,	_inst_1 : semiring R,	S : Type v,	_inst_2 : semiring S,	f : R →+* S,	_inst_3 : nontrivial S,	p : polynomial S,	hlifts : p ∈ polynomial.lifts f,	hmonic : p.monic,	Rtrivial : nontrivial R	⊢ ∃ (q : polynomial R), polynomial.map f q = p ∧ q.degree = p.degree ∧ q.monic		R : Type u,	_inst_1 : semiring R,	S : Type v,	_inst_2 : semiring S,	f : R →+* S,	_inst_3 : nontrivial S,	p : polynomial S,	hlifts : p ∈ polynomial.lifts f,	hmonic : p.monic,	Rtrivial : ¬nontrivial R	⊢ ∃ (q : polynomial R), polynomial.map f q = p ∧ q.degree = p.degree ∧ q.monic
R : Type u,	_inst_1 : semiring R,	S : Type v,	_inst_2 : semiring S,	f : R →+* S,	_inst_3 : nontrivial S,	p : polynomial S,	hlifts : p ∈ polynomial.lifts f,	hmonic : p.monic,	Rtrivial : ¬nontrivial R	⊢ ∃ (q : polynomial R), polynomial.map f q = p ∧ q.degree = p.degree ∧ q.monic
R : Type u,	_inst_1 : semiring R,	S : Type v,	_inst_2 : semiring S,	f : R →+* S,	_inst_3 : nontrivial S,	p : polynomial S,	hlifts : p ∈ polynomial.lifts f,	hmonic : p.monic,	Rtrivial : subsingleton R	⊢ ∃ (q : polynomial R), polynomial.map f q = p ∧ q.degree = p.degree ∧ q.monic
R : Type u,	_inst_1 : semiring R,	S : Type v,	_inst_2 : semiring S,	f : R →+* S,	_inst_3 : nontrivial S,	p : polynomial S,	hlifts : p ∈ polynomial.lifts f,	hmonic : p.monic,	Rtrivial : subsingleton R,	q : polynomial R,	hq : polynomial.map f q = p ∧ q.degree = p.degree	⊢ ∃ (q : polynomial R), polynomial.map f q = p ∧ q.degree = p.degree ∧ q.monic
R : Type u,	_inst_1 : semiring R,	S : Type v,	_inst_2 : semiring S,	f : R →+* S,	_inst_3 : nontrivial S,	p : polynomial S,	hlifts : p ∈ polynomial.lifts f,	hmonic : p.monic,	Rtrivial : subsingleton R,	q : polynomial R,	hq : polynomial.map f q = p ∧ q.degree = p.degree	⊢ polynomial.map f q = p ∧ q.degree = p.degree ∧ q.monic
R : Type u,	_inst_1 : semiring R,	S : Type v,	_inst_2 : semiring S,	f : R →+* S,	_inst_3 : nontrivial S,	p : polynomial S,	hlifts : p ∈ polynomial.lifts f,	hmonic : p.monic,	Rtrivial : ¬nontrivial R	⊢ ∃ (q : polynomial R), polynomial.map f q = p ∧ q.degree = p.degree ∧ q.monic		R : Type u,	_inst_1 : semiring R,	S : Type v,	_inst_2 : semiring S,	f : R →+* S,	_inst_3 : nontrivial S,	p : polynomial S,	hlifts : p ∈ polynomial.lifts f,	hmonic : p.monic,	Rtrivial : nontrivial R	⊢ ∃ (q : polynomial R), polynomial.map f q = p ∧ q.degree = p.degree ∧ q.monic
R : Type u,	_inst_1 : semiring R,	S : Type v,	_inst_2 : semiring S,	f : R →+* S,	_inst_3 : nontrivial S,	p : polynomial S,	hlifts : p ∈ polynomial.lifts f,	hmonic : p.monic,	Rtrivial : nontrivial R	⊢ ∃ (q : polynomial R), polynomial.map f q = p ∧ q.degree = p.degree ∧ q.monic
R : Type u,	_inst_1 : semiring R,	S : Type v,	_inst_2 : semiring S,	f : R →+* S,	_inst_3 : nontrivial S,	p : polynomial S,	hlifts : p ∈ polynomial.lifts f,	hmonic : p.monic,	Rtrivial : nontrivial R,	er_zero : p.erase_lead = 0	⊢ ∃ (q : polynomial R), polynomial.map f q = p ∧ q.degree = p.degree ∧ q.monic
R : Type u,	_inst_1 : semiring R,	S : Type v,	_inst_2 : semiring S,	f : R →+* S,	_inst_3 : nontrivial S,	p : polynomial S,	hlifts : p ∈ polynomial.lifts f,	hmonic : p.monic,	Rtrivial : nontrivial R,	er_zero : p.erase_lead = 0	⊢ ∃ (q : polynomial R), polynomial.map f q = polynomial.X ^ p.nat_degree ∧ q.degree = (polynomial.X ^ p.nat_degree).degree ∧ q.monic
R : Type u,	_inst_1 : semiring R,	S : Type v,	_inst_2 : semiring S,	f : R →+* S,	_inst_3 : nontrivial S,	p : polynomial S,	hlifts : p ∈ polynomial.lifts f,	hmonic : p.monic,	Rtrivial : nontrivial R,	er_zero : p.erase_lead = 0	⊢ polynomial.map f (polynomial.X ^ p.nat_degree) = polynomial.X ^ p.nat_degree ∧ (polynomial.X ^ p.nat_degree).degree = (polynomial.X ^ p.nat_degree).degree ∧ (polynomial.X ^ p.nat_degree).monic
R : Type u,	_inst_1 : semiring R,	S : Type v,	_inst_2 : semiring S,	f : R →+* S,	_inst_3 : nontrivial S,	p : polynomial S,	hlifts : p ∈ polynomial.lifts f,	hmonic : p.monic,	Rtrivial : nontrivial R,	er_zero : p.erase_lead = 0	⊢ (polynomial.X ^ p.nat_degree).degree = (polynomial.X ^ p.nat_degree).degree ∧ (polynomial.X ^ p.nat_degree).monic
R : Type u,	_inst_1 : semiring R,	S : Type v,	_inst_2 : semiring S,	f : R →+* S,	_inst_3 : nontrivial S,	p : polynomial S,	hlifts : p ∈ polynomial.lifts f,	hmonic : p.monic,	Rtrivial : nontrivial R,	er_zero : p.erase_lead = 0	⊢ (polynomial.X ^ p.nat_degree).monic
R : Type u,	_inst_1 : semiring R,	S : Type v,	_inst_2 : semiring S,	f : R →+* S,	_inst_3 : nontrivial S,	p : polynomial S,	hlifts : p ∈ polynomial.lifts f,	hmonic : p.monic,	Rtrivial : nontrivial R,	er_zero : p.erase_lead = 0	⊢ polynomial.map f (polynomial.X ^ p.nat_degree) = polynomial.X ^ p.nat_degree ∧ (polynomial.X ^ p.nat_degree).degree = (polynomial.X ^ p.nat_degree).degree ∧ (polynomial.X ^ p.nat_degree).monic
R : Type u,	_inst_1 : semiring R,	S : Type v,	_inst_2 : semiring S,	f : R →+* S,	_inst_3 : nontrivial S,	p : polynomial S,	hlifts : p ∈ polynomial.lifts f,	hmonic : p.monic,	Rtrivial : nontrivial R,	er_zero : p.erase_lead = 0	⊢ polynomial.map f (polynomial.X ^ p.nat_degree) = polynomial.X ^ p.nat_degree		R : Type u,	_inst_1 : semiring R,	S : Type v,	_inst_2 : semiring S,	f : R →+* S,	_inst_3 : nontrivial S,	p : polynomial S,	hlifts : p ∈ polynomial.lifts f,	hmonic : p.monic,	Rtrivial : nontrivial R,	er_zero : p.erase_lead = 0	⊢ (polynomial.X ^ p.nat_degree).degree = (polynomial.X ^ p.nat_degree).degree		R : Type u,	_inst_1 : semiring R,	S : Type v,	_inst_2 : semiring S,	f : R →+* S,	_inst_3 : nontrivial S,	p : polynomial S,	hlifts : p ∈ polynomial.lifts f,	hmonic : p.monic,	Rtrivial : nontrivial R,	er_zero : p.erase_lead = 0	⊢ (polynomial.X ^ p.nat_degree).monic
R : Type u,	_inst_1 : semiring R,	S : Type v,	_inst_2 : semiring S,	f : R →+* S,	_inst_3 : nontrivial S,	p : polynomial S,	hlifts : p ∈ polynomial.lifts f,	hmonic : p.monic,	Rtrivial : nontrivial R,	er_zero : p.erase_lead = 0	⊢ polynomial.map f (polynomial.X ^ p.nat_degree) = polynomial.X ^ p.nat_degree
R : Type u,	_inst_1 : semiring R,	S : Type v,	_inst_2 : semiring S,	f : R →+* S,	_inst_3 : nontrivial S,	p : polynomial S,	hlifts : p ∈ polynomial.lifts f,	hmonic : p.monic,	Rtrivial : nontrivial R,	er_zero : p.erase_lead = 0	⊢ (polynomial.X ^ p.nat_degree).degree = (polynomial.X ^ p.nat_degree).degree		R : Type u,	_inst_1 : semiring R,	S : Type v,	_inst_2 : semiring S,	f : R →+* S,	_inst_3 : nontrivial S,	p : polynomial S,	hlifts : p ∈ polynomial.lifts f,	hmonic : p.monic,	Rtrivial : nontrivial R,	er_zero : p.erase_lead = 0	⊢ (polynomial.X ^ p.nat_degree).monic
R : Type u,	_inst_1 : semiring R,	S : Type v,	_inst_2 : semiring S,	f : R →+* S,	_inst_3 : nontrivial S,	p : polynomial S,	hlifts : p ∈ polynomial.lifts f,	hmonic : p.monic,	Rtrivial : nontrivial R,	er_zero : p.erase_lead = 0	⊢ (polynomial.X ^ p.nat_degree).degree = (polynomial.X ^ p.nat_degree).degree
R : Type u,	_inst_1 : semiring R,	S : Type v,	_inst_2 : semiring S,	f : R →+* S,	_inst_3 : nontrivial S,	p : polynomial S,	hlifts : p ∈ polynomial.lifts f,	hmonic : p.monic,	Rtrivial : nontrivial R,	er_zero : p.erase_lead = 0	⊢ ∃ (q : polynomial R), polynomial.map f q = p ∧ q.degree = p.degree ∧ q.monic		R : Type u,	_inst_1 : semiring R,	S : Type v,	_inst_2 : semiring S,	f : R →+* S,	_inst_3 : nontrivial S,	p : polynomial S,	hlifts : p ∈ polynomial.lifts f,	hmonic : p.monic,	Rtrivial : nontrivial R,	er_zero : ¬p.erase_lead = 0	⊢ ∃ (q : polynomial R), polynomial.map f q = p ∧ q.degree = p.degree ∧ q.monic
R : Type u,	_inst_1 : semiring R,	S : Type v,	_inst_2 : semiring S,	f : R →+* S,	_inst_3 : nontrivial S,	p : polynomial S,	hlifts : p ∈ polynomial.lifts f,	hmonic : p.monic,	Rtrivial : nontrivial R,	er_zero : p.erase_lead = 0	⊢ (polynomial.X ^ p.nat_degree).monic
R : Type u,	_inst_1 : semiring R,	S : Type v,	_inst_2 : semiring S,	f : R →+* S,	_inst_3 : nontrivial S,	p : polynomial S,	hlifts : p ∈ polynomial.lifts f,	hmonic : p.monic,	Rtrivial : nontrivial R,	er_zero : ¬p.erase_lead = 0	⊢ ∃ (q : polynomial R), polynomial.map f q = p ∧ q.degree = p.degree ∧ q.monic
R : Type u,	_inst_1 : semiring R,	S : Type v,	_inst_2 : semiring S,	f : R →+* S,	_inst_3 : nontrivial S,	p : polynomial S,	hlifts : p ∈ polynomial.lifts f,	hmonic : p.monic,	Rtrivial : nontrivial R,	er_zero : ¬p.erase_lead = 0,	q : polynomial R,	hq : polynomial.map f q = polynomial.erase p.nat_degree p ∧ q.degree = (polynomial.erase p.nat_degree p).degree	⊢ ∃ (q : polynomial R), polynomial.map f q = p ∧ q.degree = p.degree ∧ q.monic
R : Type u,	_inst_1 : semiring R,	S : Type v,	_inst_2 : semiring S,	f : R →+* S,	_inst_3 : nontrivial S,	p : polynomial S,	hlifts : p ∈ polynomial.lifts f,	hmonic : p.monic,	Rtrivial : nontrivial R,	er_zero : ¬p.erase_lead = 0,	q : polynomial R,	hq : polynomial.map f q = polynomial.erase p.nat_degree p ∧ q.degree = (polynomial.erase p.nat_degree p).degree,	deg_er : p.erase_lead.nat_degree < p.nat_degree	⊢ ∃ (q : polynomial R), polynomial.map f q = p ∧ q.degree = p.degree ∧ q.monic
R : Type u,	_inst_1 : semiring R,	S : Type v,	_inst_2 : semiring S,	f : R →+* S,	_inst_3 : nontrivial S,	p : polynomial S,	hlifts : p ∈ polynomial.lifts f,	hmonic : p.monic,	Rtrivial : nontrivial R,	er_zero : ¬p.erase_lead = 0,	q : polynomial R,	hq : polynomial.map f q = polynomial.erase p.nat_degree p ∧ q.degree = (polynomial.erase p.nat_degree p).degree,	deg_er : ↑(p.erase_lead.nat_degree) < ↑(p.nat_degree)	⊢ ∃ (q : polynomial R), polynomial.map f q = p ∧ q.degree = p.degree ∧ q.monic
R : Type u,	_inst_1 : semiring R,	S : Type v,	_inst_2 : semiring S,	f : R →+* S,	_inst_3 : nontrivial S,	p : polynomial S,	hlifts : p ∈ polynomial.lifts f,	hmonic : p.monic,	Rtrivial : nontrivial R,	er_zero : ¬p.erase_lead = 0,	q : polynomial R,	hq : polynomial.map f q = polynomial.erase p.nat_degree p ∧ q.degree = (polynomial.erase p.nat_degree p).degree,	deg_er : q.degree < (polynomial.X ^ p.nat_degree).degree	⊢ ∃ (q : polynomial R), polynomial.map f q = p ∧ q.degree = p.degree ∧ q.monic
R : Type u,	_inst_1 : semiring R,	S : Type v,	_inst_2 : semiring S,	f : R →+* S,	_inst_3 : nontrivial S,	p : polynomial S,	hlifts : p ∈ polynomial.lifts f,	hmonic : p.monic,	Rtrivial : nontrivial R,	er_zero : ¬p.erase_lead = 0,	q : polynomial R,	hq : polynomial.map f q = polynomial.erase p.nat_degree p ∧ q.degree = (polynomial.erase p.nat_degree p).degree,	deg_er : q.degree < (polynomial.X ^ p.nat_degree).degree	⊢ polynomial.map f (q + polynomial.X ^ p.nat_degree) = p ∧ (q + polynomial.X ^ p.nat_degree).degree = p.degree ∧ (q + polynomial.X ^ p.nat_degree).monic
R : Type u,	_inst_1 : semiring R,	S : Type v,	_inst_2 : semiring S,	f : R →+* S,	_inst_3 : nontrivial S,	p : polynomial S,	hlifts : p ∈ polynomial.lifts f,	hmonic : p.monic,	Rtrivial : nontrivial R,	er_zero : ¬p.erase_lead = 0,	q : polynomial R,	hq : polynomial.map f q = polynomial.erase p.nat_degree p ∧ q.degree = (polynomial.erase p.nat_degree p).degree,	deg_er : q.degree < (polynomial.X ^ p.nat_degree).degree	⊢ (q + polynomial.X ^ p.nat_degree).degree = p.degree ∧ (q + polynomial.X ^ p.nat_degree).monic
R : Type u,	_inst_1 : semiring R,	S : Type v,	_inst_2 : semiring S,	f : R →+* S,	_inst_3 : nontrivial S,	p : polynomial S,	hlifts : p ∈ polynomial.lifts f,	hmonic : p.monic,	Rtrivial : nontrivial R,	er_zero : ¬p.erase_lead = 0,	q : polynomial R,	hq : polynomial.map f q = polynomial.erase p.nat_degree p ∧ q.degree = (polynomial.erase p.nat_degree p).degree,	deg_er : q.degree < (polynomial.X ^ p.nat_degree).degree	⊢ (q + polynomial.X ^ p.nat_degree).monic
R : Type u,	_inst_1 : semiring R,	S : Type v,	_inst_2 : semiring S,	f : R →+* S,	_inst_3 : nontrivial S,	p : polynomial S,	hlifts : p ∈ polynomial.lifts f,	hmonic : p.monic,	Rtrivial : nontrivial R,	er_zero : ¬p.erase_lead = 0,	q : polynomial R,	hq : polynomial.map f q = polynomial.erase p.nat_degree p ∧ q.degree = (polynomial.erase p.nat_degree p).degree,	deg_er : q.degree < (polynomial.X ^ p.nat_degree).degree	⊢ polynomial.map f (q + polynomial.X ^ p.nat_degree) = p ∧ (q + polynomial.X ^ p.nat_degree).degree = p.degree ∧ (q + polynomial.X ^ p.nat_degree).monic
R : Type u,	_inst_1 : semiring R,	S : Type v,	_inst_2 : semiring S,	f : R →+* S,	_inst_3 : nontrivial S,	p : polynomial S,	hlifts : p ∈ polynomial.lifts f,	hmonic : p.monic,	Rtrivial : nontrivial R,	er_zero : ¬p.erase_lead = 0,	q : polynomial R,	hq : polynomial.map f q = polynomial.erase p.nat_degree p ∧ q.degree = (polynomial.erase p.nat_degree p).degree,	deg_er : q.degree < (polynomial.X ^ p.nat_degree).degree	⊢ polynomial.map f (q + polynomial.X ^ p.nat_degree) = p
R : Type u,	_inst_1 : semiring R,	S : Type v,	_inst_2 : semiring S,	f : R →+* S,	_inst_3 : nontrivial S,	p : polynomial S,	hlifts : p ∈ polynomial.lifts f,	hmonic : p.monic,	Rtrivial : nontrivial R,	er_zero : ¬p.erase_lead = 0,	q : polynomial R,	hq : polynomial.map f q = polynomial.erase p.nat_degree p ∧ q.degree = (polynomial.erase p.nat_degree p).degree,	deg_er : q.degree < (polynomial.X ^ p.nat_degree).degree	⊢ polynomial.erase p.nat_degree p + polynomial.X ^ p.nat_degree = p
R : Type u,	_inst_1 : semiring R,	S : Type v,	_inst_2 : semiring S,	f : R →+* S,	_inst_3 : nontrivial S,	p : polynomial S,	hlifts : p ∈ polynomial.lifts f,	hmonic : p.monic,	Rtrivial : nontrivial R,	er_zero : ¬p.erase_lead = 0,	q : polynomial R,	hq : polynomial.map f q = polynomial.erase p.nat_degree p ∧ q.degree = (polynomial.erase p.nat_degree p).degree,	deg_er : q.degree < (polynomial.X ^ p.nat_degree).degree	⊢ polynomial.erase p.nat_degree p + polynomial.X ^ p.nat_degree = p.erase_lead + ⇑polynomial.C p.leading_coeff * polynomial.X ^ p.nat_degree
R : Type u,	_inst_1 : semiring R,	S : Type v,	_inst_2 : semiring S,	f : R →+* S,	_inst_3 : nontrivial S,	p : polynomial S,	hlifts : p ∈ polynomial.lifts f,	hmonic : p.monic,	Rtrivial : nontrivial R,	er_zero : ¬p.erase_lead = 0,	q : polynomial R,	hq : polynomial.map f q = polynomial.erase p.nat_degree p ∧ q.degree = (polynomial.erase p.nat_degree p).degree,	deg_er : q.degree < (polynomial.X ^ p.nat_degree).degree	⊢ polynomial.map f (q + polynomial.X ^ p.nat_degree) = p		R : Type u,	_inst_1 : semiring R,	S : Type v,	_inst_2 : semiring S,	f : R →+* S,	_inst_3 : nontrivial S,	p : polynomial S,	hlifts : p ∈ polynomial.lifts f,	hmonic : p.monic,	Rtrivial : nontrivial R,	er_zero : ¬p.erase_lead = 0,	q : polynomial R,	hq : polynomial.map f q = polynomial.erase p.nat_degree p ∧ q.degree = (polynomial.erase p.nat_degree p).degree,	deg_er : q.degree < (polynomial.X ^ p.nat_degree).degree	⊢ (q + polynomial.X ^ p.nat_degree).degree = p.degree		R : Type u,	_inst_1 : semiring R,	S : Type v,	_inst_2 : semiring S,	f : R →+* S,	_inst_3 : nontrivial S,	p : polynomial S,	hlifts : p ∈ polynomial.lifts f,	hmonic : p.monic,	Rtrivial : nontrivial R,	er_zero : ¬p.erase_lead = 0,	q : polynomial R,	hq : polynomial.map f q = polynomial.erase p.nat_degree p ∧ q.degree = (polynomial.erase p.nat_degree p).degree,	deg_er : q.degree < (polynomial.X ^ p.nat_degree).degree	⊢ (q + polynomial.X ^ p.nat_degree).monic
R : Type u,	_inst_1 : semiring R,	S : Type v,	_inst_2 : semiring S,	f : R →+* S,	_inst_3 : nontrivial S,	p : polynomial S,	hlifts : p ∈ polynomial.lifts f,	hmonic : p.monic,	Rtrivial : nontrivial R,	er_zero : ¬p.erase_lead = 0,	q : polynomial R,	hq : polynomial.map f q = polynomial.erase p.nat_degree p ∧ q.degree = (polynomial.erase p.nat_degree p).degree,	deg_er : q.degree < (polynomial.X ^ p.nat_degree).degree	⊢ (q + polynomial.X ^ p.nat_degree).degree = p.degree
R : Type u,	_inst_1 : semiring R,	S : Type v,	_inst_2 : semiring S,	f : R →+* S,	_inst_3 : nontrivial S,	p : polynomial S,	hlifts : p ∈ polynomial.lifts f,	hmonic : p.monic,	Rtrivial : nontrivial R,	er_zero : ¬p.erase_lead = 0,	q : polynomial R,	hq : polynomial.map f q = polynomial.erase p.nat_degree p ∧ q.degree = (polynomial.erase p.nat_degree p).degree,	deg_er : q.degree < (polynomial.X ^ p.nat_degree).degree	⊢ (q + polynomial.X ^ p.nat_degree).degree = p.degree		R : Type u,	_inst_1 : semiring R,	S : Type v,	_inst_2 : semiring S,	f : R →+* S,	_inst_3 : nontrivial S,	p : polynomial S,	hlifts : p ∈ polynomial.lifts f,	hmonic : p.monic,	Rtrivial : nontrivial R,	er_zero : ¬p.erase_lead = 0,	q : polynomial R,	hq : polynomial.map f q = polynomial.erase p.nat_degree p ∧ q.degree = (polynomial.erase p.nat_degree p).degree,	deg_er : q.degree < (polynomial.X ^ p.nat_degree).degree	⊢ (q + polynomial.X ^ p.nat_degree).monic
R : Type u,	_inst_1 : semiring R,	S : Type v,	_inst_2 : semiring S,	f : R →+* S,	_inst_3 : nontrivial S,	p : polynomial S,	hlifts : p ∈ polynomial.lifts f,	hmonic : p.monic,	Rtrivial : nontrivial R,	er_zero : ¬p.erase_lead = 0,	q : polynomial R,	hq : polynomial.map f q = polynomial.erase p.nat_degree p ∧ q.degree = (polynomial.erase p.nat_degree p).degree,	deg_er : q.degree < (polynomial.X ^ p.nat_degree).degree	⊢ (q + polynomial.X ^ p.nat_degree).monic
R : Type u,	_inst_1 : semiring R,	S : Type v,	_inst_2 : semiring S,	f : R →+* S,	_inst_3 : nontrivial S,	p : polynomial S,	hlifts : p ∈ polynomial.lifts f,	hmonic : p.monic,	Rtrivial : nontrivial R,	er_zero : ¬p.erase_lead = 0,	q : polynomial R,	hq : polynomial.map f q = polynomial.erase p.nat_degree p ∧ q.degree = (polynomial.erase p.nat_degree p).degree,	deg_er : q.degree < (polynomial.X ^ p.nat_degree).degree	⊢ (polynomial.X ^ p.nat_degree).leading_coeff = 1
R : Type u,	_inst_1 : semiring R,	S : Type v,	_inst_2 : semiring S,	f : R →+* S,	p : polynomial S	⊢ p ∈ polynomial.lifts f ↔ p ∈ (polynomial.map_ring_hom f).srange
R : Type u,	_inst_1 : semiring R,	p : polynomial R,	hp : p.monic	⊢ p = ?m_1
R : Type u,	_inst_1 : semiring R,	p : polynomial R,	hp : p.monic	⊢ p = polynomial.X ^ p.nat_degree + ∑ (i : ℕ) in finset.range p.nat_degree, ⇑polynomial.C (p.coeff i) * polynomial.X ^ i
R : Type u,	_inst_1 : semiring R,	p : polynomial R,	hp : p.monic	⊢ ⇑polynomial.C (p.coeff p.nat_degree) * polynomial.X ^ p.nat_degree + ∑ (x : ℕ) in finset.range p.nat_degree, ⇑polynomial.C (p.coeff x) * polynomial.X ^ x = polynomial.X ^ p.nat_degree + ∑ (i : ℕ) in finset.range p.nat_degree, ⇑polynomial.C (p.coeff i) * polynomial.X ^ i
R : Type u,	_inst_1 : semiring R,	p : polynomial R,	hp : p.monic,	this : ⇑polynomial.C (p.coeff p.nat_degree) = 1	⊢ ⇑polynomial.C (p.coeff p.nat_degree) * polynomial.X ^ p.nat_degree + ∑ (x : ℕ) in finset.range p.nat_degree, ⇑polynomial.C (p.coeff x) * polynomial.X ^ x = polynomial.X ^ p.nat_degree + ∑ (i : ℕ) in finset.range p.nat_degree, ⇑polynomial.C (p.coeff i) * polynomial.X ^ i		R : Type u,	_inst_1 : semiring R,	p : polynomial R,	hp : p.monic	⊢ ⇑polynomial.C (p.coeff p.nat_degree) = 1
R : Type u,	_inst_1 : semiring R,	p : polynomial R,	hp : p.monic,	this : ⇑polynomial.C (p.coeff p.nat_degree) = 1	⊢ ⇑polynomial.C (p.coeff p.nat_degree) * polynomial.X ^ p.nat_degree + ∑ (x : ℕ) in finset.range p.nat_degree, ⇑polynomial.C (p.coeff x) * polynomial.X ^ x = polynomial.X ^ p.nat_degree + ∑ (i : ℕ) in finset.range p.nat_degree, ⇑polynomial.C (p.coeff i) * polynomial.X ^ i
R : Type u,	_inst_1 : semiring R,	p : polynomial R,	hp : p.monic	⊢ ⇑polynomial.C (p.coeff p.nat_degree) = 1
R : Type u_1,	_inst_1 : semiring R,	N n : ℕ,	c : R	⊢ polynomial.reflect N (⇑polynomial.C c * polynomial.X ^ n) = ⇑polynomial.C c * polynomial.X ^ ⇑(polynomial.rev_at N) n
R : Type u_1,	_inst_1 : semiring R,	N n : ℕ,	c : R,	n_1 : ℕ	⊢ (polynomial.reflect N (⇑polynomial.C c * polynomial.X ^ n)).coeff n_1 = (⇑polynomial.C c * polynomial.X ^ ⇑(polynomial.rev_at N) n).coeff n_1
R : Type u_1,	_inst_1 : semiring R,	N n : ℕ,	c : R,	n_1 : ℕ	⊢ c * (polynomial.X ^ n).coeff (⇑(polynomial.rev_at N) n_1) = c * ite (n_1 = ⇑(polynomial.rev_at N) n) 1 0
R : Type u_1,	_inst_1 : semiring R,	N n : ℕ,	c : R,	n_1 : ℕ,	h : n_1 = ⇑(polynomial.rev_at N) n	⊢ c * (polynomial.X ^ n).coeff (⇑(polynomial.rev_at N) n_1) = c * 1		R : Type u_1,	_inst_1 : semiring R,	N n : ℕ,	c : R,	n_1 : ℕ,	h : ¬n_1 = ⇑(polynomial.rev_at N) n	⊢ c * (polynomial.X ^ n).coeff (⇑(polynomial.rev_at N) n_1) = c * 0
R : Type u_1,	_inst_1 : semiring R,	N n : ℕ,	c : R,	n_1 : ℕ,	h : n_1 = ⇑(polynomial.rev_at N) n	⊢ c * (polynomial.X ^ n).coeff (⇑(polynomial.rev_at N) n_1) = c * 1
R : Type u_1,	_inst_1 : semiring R,	N n : ℕ,	c : R,	n_1 : ℕ,	h : ¬n_1 = ⇑(polynomial.rev_at N) n	⊢ c * (polynomial.X ^ n).coeff (⇑(polynomial.rev_at N) n_1) = c * 0
R : Type u_1,	_inst_1 : semiring R,	N n : ℕ,	c : R,	n_1 : ℕ,	h : ¬n_1 = ⇑(polynomial.rev_at N) n	⊢ ⇑(polynomial.rev_at N) n_1 ∉ (polynomial.X ^ n).support
R : Type u_1,	_inst_1 : semiring R,	N n : ℕ,	c : R,	n_1 : ℕ,	h : ¬n_1 = ⇑(polynomial.rev_at N) n,	a : ⇑(polynomial.rev_at N) n_1 ∈ (polynomial.X ^ n).support	⊢ false
R : Type u_1,	_inst_1 : semiring R,	N n : ℕ,	c : R,	n_1 : ℕ,	h : ¬n_1 = ⇑(polynomial.rev_at N) n,	a : ⇑(polynomial.rev_at N) n_1 ∈ (⇑polynomial.C 1 * polynomial.X ^ n).support	⊢ false
R : Type u_1,	_inst_1 : semiring R,	N n : ℕ,	c : R,	n_1 : ℕ,	h : ¬n_1 = ⇑(polynomial.rev_at N) n,	a : ⇑(polynomial.rev_at N) n_1 ∈ (⇑polynomial.C 1 * polynomial.X ^ n).support	⊢ n_1 = ⇑(polynomial.rev_at N) n
R : Type u,	_inst_1 : integral_domain R,	p : polynomial R,	hp1 : p.degree = 1,	hm : p.monic	⊢ p = polynomial.X - ⇑polynomial.C (-p.coeff 0)
n : ℕ,	F : typevec (n + 1) → Type u,	_inst_1 : mvfunctor F,	q : mvqpf F,	α : typevec n,	p : mvqpf.fix F α → Prop,	h : ∀ (x : F (α ::: mvqpf.fix F α)), mvfunctor.liftp (α.pred_last p) x → p (mvqpf.fix.mk x)	⊢ ∀ (x : mvqpf.fix F α), p x
n : ℕ,	F : typevec (n + 1) → Type u,	_inst_1 : mvfunctor F,	q : mvqpf F,	α : typevec n,	p : mvqpf.fix F α → Prop,	h : ∀ (x : F (α ::: mvqpf.fix F α)), mvfunctor.liftp (α.pred_last p) x → p (mvqpf.fix.mk x)	⊢ ∀ (a : (mvqpf.P F).W α), p (quot.mk setoid.r a)
n : ℕ,	F : typevec (n + 1) → Type u,	_inst_1 : mvfunctor F,	q : mvqpf F,	α : typevec n,	p : mvqpf.fix F α → Prop,	h : ∀ (x : F (α ::: mvqpf.fix F α)), mvfunctor.liftp (α.pred_last p) x → p (mvqpf.fix.mk x),	x : (mvqpf.P F).W α	⊢ ∀ (a : (mvqpf.P F).A) (f' : (mvqpf.P F).drop.B a ⟹ α) (f : (mvqpf.P F).last.B a → (mvqpf.P F).W α), (∀ (i : (mvqpf.P F).last.B a), p (quot.mk setoid.r (f i))) → p (quot.mk setoid.r ((mvqpf.P F).W_mk a f' f))
n : ℕ,	F : typevec (n + 1) → Type u,	_inst_1 : mvfunctor F,	q : mvqpf F,	α : typevec n,	p : mvqpf.fix F α → Prop,	h : ∀ (x : F (α ::: mvqpf.fix F α)), mvfunctor.liftp (α.pred_last p) x → p (mvqpf.fix.mk x),	x : (mvqpf.P F).W α	⊢ p (quot.mk setoid.r x)
n : ℕ,	F : typevec (n + 1) → Type u,	_inst_1 : mvfunctor F,	q : mvqpf F,	α : typevec n,	p : mvqpf.fix F α → Prop,	h : ∀ (x : F (α ::: mvqpf.fix F α)), mvfunctor.liftp (α.pred_last p) x → p (mvqpf.fix.mk x),	x : (mvqpf.P F).W α,	a : (mvqpf.P F).A,	f' : (mvqpf.P F).drop.B a ⟹ α,	f : (mvqpf.P F).last.B a → (mvqpf.P F).W α,	ih : ∀ (i : (mvqpf.P F).last.B a), p (quot.mk setoid.r (f i))	⊢ p (quot.mk setoid.r ((mvqpf.P F).W_mk a f' f))
n : ℕ,	F : typevec (n + 1) → Type u,	_inst_1 : mvfunctor F,	q : mvqpf F,	α : typevec n,	p : mvqpf.fix F α → Prop,	h : ∀ (x : F (α ::: mvqpf.fix F α)), mvfunctor.liftp (α.pred_last p) x → p (mvqpf.fix.mk x),	x : (mvqpf.P F).W α,	a : (mvqpf.P F).A,	f' : (mvqpf.P F).drop.B a ⟹ α,	f : (mvqpf.P F).last.B a → (mvqpf.P F).W α,	ih : ∀ (i : (mvqpf.P F).last.B a), p (quot.mk setoid.r (f i))	⊢ p ⟦(mvqpf.P F).W_mk a f' f⟧
n : ℕ,	F : typevec (n + 1) → Type u,	_inst_1 : mvfunctor F,	q : mvqpf F,	α : typevec n,	p : mvqpf.fix F α → Prop,	h : ∀ (x : F (α ::: mvqpf.fix F α)), mvfunctor.liftp (α.pred_last p) x → p (mvqpf.fix.mk x),	x : (mvqpf.P F).W α,	a : (mvqpf.P F).A,	f' : (mvqpf.P F).drop.B a ⟹ α,	f : (mvqpf.P F).last.B a → (mvqpf.P F).W α,	ih : ∀ (i : (mvqpf.P F).last.B a), p (quot.mk setoid.r (f i))	⊢ p (mvqpf.fix.mk (mvqpf.abs ⟨a, (mvqpf.P F).append_contents f' (λ (x : (mvqpf.P F).last.B a), ⟦f x⟧)⟩))
n : ℕ,	F : typevec (n + 1) → Type u,	_inst_1 : mvfunctor F,	q : mvqpf F,	α : typevec n,	p : mvqpf.fix F α → Prop,	h : ∀ (x : F (α ::: mvqpf.fix F α)), mvfunctor.liftp (α.pred_last p) x → p (mvqpf.fix.mk x),	x : (mvqpf.P F).W α,	a : (mvqpf.P F).A,	f' : (mvqpf.P F).drop.B a ⟹ α,	f : (mvqpf.P F).last.B a → (mvqpf.P F).W α,	ih : ∀ (i : (mvqpf.P F).last.B a), p (quot.mk setoid.r (f i))	⊢ mvfunctor.liftp (α.pred_last p) (mvqpf.abs ⟨a, (mvqpf.P F).append_contents f' (λ (x : (mvqpf.P F).last.B a), ⟦f x⟧)⟩)
n : ℕ,	F : typevec (n + 1) → Type u,	_inst_1 : mvfunctor F,	q : mvqpf F,	α : typevec n,	p : mvqpf.fix F α → Prop,	h : ∀ (x : F (α ::: mvqpf.fix F α)), mvfunctor.liftp (α.pred_last p) x → p (mvqpf.fix.mk x),	x : (mvqpf.P F).W α,	a : (mvqpf.P F).A,	f' : (mvqpf.P F).drop.B a ⟹ α,	f : (mvqpf.P F).last.B a → (mvqpf.P F).W α,	ih : ∀ (i : (mvqpf.P F).last.B a), p (quot.mk setoid.r (f i))	⊢ ∃ (a_1 : (mvqpf.P F).A) (f_1 : (mvqpf.P F).B a_1 ⟹ λ (i : fin2 (n + 1)), (α ::: mvqpf.fix F α) i), mvqpf.abs ⟨a, (mvqpf.P F).append_contents f' (λ (x : (mvqpf.P F).last.B a), ⟦f x⟧)⟩ = mvqpf.abs ⟨a_1, f_1⟩ ∧ ∀ (i : fin2 (n + 1)) (j : (mvqpf.P F).B a_1 i), α.pred_last p (f_1 i j)
n : ℕ,	F : typevec (n + 1) → Type u,	_inst_1 : mvfunctor F,	q : mvqpf F,	α : typevec n,	p : mvqpf.fix F α → Prop,	h : ∀ (x : F (α ::: mvqpf.fix F α)), mvfunctor.liftp (α.pred_last p) x → p (mvqpf.fix.mk x),	x : (mvqpf.P F).W α,	a : (mvqpf.P F).A,	f' : (mvqpf.P F).drop.B a ⟹ α,	f : (mvqpf.P F).last.B a → (mvqpf.P F).W α,	ih : ∀ (i : (mvqpf.P F).last.B a), p (quot.mk setoid.r (f i))	⊢ ∀ (i : fin2 (n + 1)) (j : (mvqpf.P F).B a i), α.pred_last p ((mvqpf.P F).append_contents f' (λ (x : (mvqpf.P F).last.B a), ⟦f x⟧) i j)
n : ℕ,	F : typevec (n + 1) → Type u,	_inst_1 : mvfunctor F,	q : mvqpf F,	α : typevec n,	p : mvqpf.fix F α → Prop,	h : ∀ (x : F (α ::: mvqpf.fix F α)), mvfunctor.liftp (α.pred_last p) x → p (mvqpf.fix.mk x),	x : (mvqpf.P F).W α,	a : (mvqpf.P F).A,	f' : (mvqpf.P F).drop.B a ⟹ α,	f : (mvqpf.P F).last.B a → (mvqpf.P F).W α,	ih : ∀ (i : (mvqpf.P F).last.B a), p (quot.mk setoid.r (f i)),	i : fin2 (n + 1),	j : (mvqpf.P F).B a i	⊢ α.pred_last p ((mvqpf.P F).append_contents f' (λ (x : (mvqpf.P F).last.B a), ⟦f x⟧) i j)
n : ℕ,	F : typevec (n + 1) → Type u,	_inst_1 : mvfunctor F,	q : mvqpf F,	α : typevec n,	p : mvqpf.fix F α → Prop,	h : ∀ (x : F (α ::: mvqpf.fix F α)), mvfunctor.liftp (α.pred_last p) x → p (mvqpf.fix.mk x),	x : (mvqpf.P F).W α,	a : (mvqpf.P F).A,	f' : (mvqpf.P F).drop.B a ⟹ α,	f : (mvqpf.P F).last.B a → (mvqpf.P F).W α,	ih : ∀ (i : (mvqpf.P F).last.B a), p (quot.mk setoid.r (f i)),	j : (mvqpf.P F).B a fin2.fz	⊢ α.pred_last p ((mvqpf.P F).append_contents f' (λ (x : (mvqpf.P F).last.B a), ⟦f x⟧) fin2.fz j)		case fin2.fs	n : ℕ,	F : typevec (n + 1) → Type u,	_inst_1 : mvfunctor F,	q : mvqpf F,	α : typevec n,	p : mvqpf.fix F α → Prop,	h : ∀ (x : F (α ::: mvqpf.fix F α)), mvfunctor.liftp (α.pred_last p) x → p (mvqpf.fix.mk x),	x : (mvqpf.P F).W α,	a : (mvqpf.P F).A,	f' : (mvqpf.P F).drop.B a ⟹ α,	f : (mvqpf.P F).last.B a → (mvqpf.P F).W α,	ih : ∀ (i : (mvqpf.P F).last.B a), p (quot.mk setoid.r (f i)),	i_ᾰ : fin2 n,	j : (mvqpf.P F).B a i_ᾰ.fs	⊢ α.pred_last p ((mvqpf.P F).append_contents f' (λ (x : (mvqpf.P F).last.B a), ⟦f x⟧) i_ᾰ.fs j)
n : ℕ,	F : typevec (n + 1) → Type u,	_inst_1 : mvfunctor F,	q : mvqpf F,	α : typevec n,	p : mvqpf.fix F α → Prop,	h : ∀ (x : F (α ::: mvqpf.fix F α)), mvfunctor.liftp (α.pred_last p) x → p (mvqpf.fix.mk x),	x : (mvqpf.P F).W α,	a : (mvqpf.P F).A,	f' : (mvqpf.P F).drop.B a ⟹ α,	f : (mvqpf.P F).last.B a → (mvqpf.P F).W α,	ih : ∀ (i : (mvqpf.P F).last.B a), p (quot.mk setoid.r (f i)),	j : (mvqpf.P F).B a fin2.fz	⊢ α.pred_last p ((mvqpf.P F).append_contents f' (λ (x : (mvqpf.P F).last.B a), ⟦f x⟧) fin2.fz j)
n : ℕ,	F : typevec (n + 1) → Type u,	_inst_1 : mvfunctor F,	q : mvqpf F,	α : typevec n,	p : mvqpf.fix F α → Prop,	h : ∀ (x : F (α ::: mvqpf.fix F α)), mvfunctor.liftp (α.pred_last p) x → p (mvqpf.fix.mk x),	x : (mvqpf.P F).W α,	a : (mvqpf.P F).A,	f' : (mvqpf.P F).drop.B a ⟹ α,	f : (mvqpf.P F).last.B a → (mvqpf.P F).W α,	ih : ∀ (i : (mvqpf.P F).last.B a), p (quot.mk setoid.r (f i)),	i_ᾰ : fin2 n,	j : (mvqpf.P F).B a i_ᾰ.fs	⊢ α.pred_last p ((mvqpf.P F).append_contents f' (λ (x : (mvqpf.P F).last.B a), ⟦f x⟧) i_ᾰ.fs j)
F : Type u → Type u,	_inst_1 : functor F,	q : qpf F,	y : (qpf.P F).W,	a : (qpf.P F).A,	f : (qpf.P F).B a → W_type (qpf.P F).B	⊢ qpf.Wequiv (W_type.mk a f) y → qpf.Wequiv y (W_type.mk a f)
F : Type u → Type u,	_inst_1 : functor F,	q : qpf F,	x y : (qpf.P F).W	⊢ qpf.Wequiv x y → qpf.Wequiv y x
F : Type u → Type u,	_inst_1 : functor F,	q : qpf F,	a : (qpf.P F).A,	f : (qpf.P F).B a → W_type (qpf.P F).B,	b : (qpf.P F).A,	g : (qpf.P F).B b → W_type (qpf.P F).B,	h : qpf.Wequiv (W_type.mk a f) (W_type.mk b g)	⊢ qpf.Wequiv (W_type.mk b g) (W_type.mk a f)
F : Type u → Type u,	_inst_1 : functor F,	q : qpf F,	a : (qpf.P F).A,	f : (qpf.P F).B a → W_type (qpf.P F).B,	b : (qpf.P F).A,	g : (qpf.P F).B b → W_type (qpf.P F).B	⊢ qpf.Wequiv (W_type.mk a f) (W_type.mk b g) → qpf.Wequiv (W_type.mk b g) (W_type.mk a f)
F : Type u → Type u,	_inst_1 : functor F,	q : qpf F,	h_a : (qpf.P F).A,	h_f h_f' : (qpf.P F).B h_a → (qpf.P F).W,	h_ᾰ : ∀ (x : (qpf.P F).B h_a), qpf.Wequiv (h_f x) (h_f' x),	h_ih : ∀ (x : (qpf.P F).B h_a), (λ (_x _x_1 : W_type (qpf.P F).B) (h : qpf.Wequiv _x _x_1), qpf.Wequiv _x_1 _x) (h_f x) (h_f' x) _	⊢ qpf.Wequiv (W_type.mk h_a h_f') (W_type.mk h_a h_f)		case qpf.Wequiv.abs	F : Type u → Type u,	_inst_1 : functor F,	q : qpf F,	h_a : (qpf.P F).A,	h_f : (qpf.P F).B h_a → (qpf.P F).W,	h_a' : (qpf.P F).A,	h_f' : (qpf.P F).B h_a' → (qpf.P F).W,	h_ᾰ : qpf.abs ⟨h_a, h_f⟩ = qpf.abs ⟨h_a', h_f'⟩	⊢ qpf.Wequiv (W_type.mk h_a' h_f') (W_type.mk h_a h_f)		case qpf.Wequiv.trans	F : Type u → Type u,	_inst_1 : functor F,	q : qpf F,	h_u h_v h_w : (qpf.P F).W,	h_ᾰ : qpf.Wequiv h_u h_v,	h_ᾰ_1 : qpf.Wequiv h_v h_w,	h_ih_ᾰ : qpf.Wequiv h_v h_u,	h_ih_ᾰ_1 : qpf.Wequiv h_w h_v	⊢ qpf.Wequiv h_w h_u
F : Type u → Type u,	_inst_1 : functor F,	q : qpf F,	a : (qpf.P F).A,	f f' : (qpf.P F).B a → (qpf.P F).W,	h : ∀ (x : (qpf.P F).B a), qpf.Wequiv (f x) (f' x),	ih : ∀ (x : (qpf.P F).B a), (λ (_x _x_1 : W_type (qpf.P F).B) (h : qpf.Wequiv _x _x_1), qpf.Wequiv _x_1 _x) (f x) (f' x) _	⊢ qpf.Wequiv (W_type.mk a f') (W_type.mk a f)
F : Type u → Type u,	_inst_1 : functor F,	q : qpf F,	h_a : (qpf.P F).A,	h_f : (qpf.P F).B h_a → (qpf.P F).W,	h_a' : (qpf.P F).A,	h_f' : (qpf.P F).B h_a' → (qpf.P F).W,	h_ᾰ : qpf.abs ⟨h_a, h_f⟩ = qpf.abs ⟨h_a', h_f'⟩	⊢ qpf.Wequiv (W_type.mk h_a' h_f') (W_type.mk h_a h_f)		case qpf.Wequiv.trans	F : Type u → Type u,	_inst_1 : functor F,	q : qpf F,	h_u h_v h_w : (qpf.P F).W,	h_ᾰ : qpf.Wequiv h_u h_v,	h_ᾰ_1 : qpf.Wequiv h_v h_w,	h_ih_ᾰ : qpf.Wequiv h_v h_u,	h_ih_ᾰ_1 : qpf.Wequiv h_w h_v	⊢ qpf.Wequiv h_w h_u
F : Type u → Type u,	_inst_1 : functor F,	q : qpf F,	a : (qpf.P F).A,	f : (qpf.P F).B a → (qpf.P F).W,	a' : (qpf.P F).A,	f' : (qpf.P F).B a' → (qpf.P F).W,	h : qpf.abs ⟨a, f⟩ = qpf.abs ⟨a', f'⟩	⊢ qpf.Wequiv (W_type.mk a' f') (W_type.mk a f)
F : Type u → Type u,	_inst_1 : functor F,	q : qpf F,	h_u h_v h_w : (qpf.P F).W,	h_ᾰ : qpf.Wequiv h_u h_v,	h_ᾰ_1 : qpf.Wequiv h_v h_w,	h_ih_ᾰ : qpf.Wequiv h_v h_u,	h_ih_ᾰ_1 : qpf.Wequiv h_w h_v	⊢ qpf.Wequiv h_w h_u
F : Type u → Type u,	_inst_1 : functor F,	q : qpf F,	x y z : (qpf.P F).W,	e₁ : qpf.Wequiv x y,	e₂ : qpf.Wequiv y z,	ih₁ : qpf.Wequiv y x,	ih₂ : qpf.Wequiv z y	⊢ qpf.Wequiv z x
α : Type u_1,	_inst_1 : linear_ordered_field α,	a b : ℚ	⊢ ↑(linear_order.min a b) = linear_order.min ↑a ↑b
α : Type u_1,	_inst_1 : linear_ordered_field α,	a b : ℚ,	h : a ≤ b	⊢ ↑(linear_order.min a b) = linear_order.min ↑a ↑b
α : Type u_1,	_inst_1 : linear_ordered_field α,	a b : ℚ,	h : ¬a ≤ b	⊢ ↑(linear_order.min a b) = linear_order.min ↑a ↑b
α : Type u_1,	_inst_1 : linear_ordered_field α,	a b : ℚ	⊢ ↑(linear_order.min a b) = linear_order.min ↑a ↑b
⊢ comm_semigroup ℝ
a b : ℝ,	a b : cau_seq ℚ abs	⊢ real.mk a < real.mk b ↔ real.mk a ≤ real.mk b ∧ ¬real.mk b ≤ real.mk a
a : ℝ	⊢ ∀ (y : cau_seq ℚ abs), real.mk y ≤ real.mk y
a : ℝ	⊢ ∀ (y : cau_seq ℚ abs), real.mk y ≤ real.mk y
a : ℝ,	a : cau_seq ℚ abs	⊢ real.mk a ≤ real.mk a
a b c : ℝ,	a b c : cau_seq ℚ abs	⊢ real.mk a ≤ real.mk b → real.mk b ≤ real.mk c → real.mk a ≤ real.mk c
a b : ℝ,	a b : cau_seq ℚ abs	⊢ real.mk a ≤ real.mk b → real.mk b ≤ real.mk a → real.mk a = real.mk b
⊢ semilattice_inf ℝ
c : ℝ,	f g : ℕ → bool,	h1 : 0 ≤ c,	h2 : c < 1,	h3 : ∀ (n : ℕ), ↥(f n) → ↥(g n)	⊢ cardinal.cantor_function c f ≤ cardinal.cantor_function c g
c : ℝ,	f g : ℕ → bool,	h1 : 0 ≤ c,	h2 : c < 1,	h3 : ∀ (n : ℕ), ↥(f n) → ↥(g n),	n : ℕ	⊢ cardinal.cantor_function_aux c f n ≤ cardinal.cantor_function_aux c g n
c : ℝ,	f g : ℕ → bool,	h1 : 0 ≤ c,	h2 : c < 1,	h3 : ∀ (n : ℕ), ↥(f n) → ↥(g n),	n : ℕ,	h : f n = bool.ff	⊢ cardinal.cantor_function_aux c f n ≤ cardinal.cantor_function_aux c g n		case bool.tt	c : ℝ,	f g : ℕ → bool,	h1 : 0 ≤ c,	h2 : c < 1,	h3 : ∀ (n : ℕ), ↥(f n) → ↥(g n),	n : ℕ,	h : f n = bool.tt	⊢ cardinal.cantor_function_aux c f n ≤ cardinal.cantor_function_aux c g n
c : ℝ,	f g : ℕ → bool,	h1 : 0 ≤ c,	h2 : c < 1,	h3 : ∀ (n : ℕ), ↥(f n) → ↥(g n)	⊢ ∀ (b : ℕ), cardinal.cantor_function_aux c f b ≤ cardinal.cantor_function_aux c g b
c : ℝ,	f g : ℕ → bool,	h1 : 0 ≤ c,	h2 : c < 1,	n : ℕ,	h : f n = bool.tt,	h3 : g n = bool.tt	⊢ cardinal.cantor_function_aux c f n ≤ cardinal.cantor_function_aux c g n
c : ℝ,	f g : ℕ → bool,	h1 : 0 ≤ c,	h2 : c < 1,	h3 : ∀ (n : ℕ), ↥(f n) → ↥(g n),	n : ℕ,	h : f n = bool.tt	⊢ cardinal.cantor_function_aux c f n ≤ cardinal.cantor_function_aux c g n
α : Type u_1,	_inst_1 : linear_ordered_field α,	β : Type u_2,	_inst_2 : field β,	abv : β → α,	_inst_3 : is_absolute_value abv,	x : β,	hx : x ≠ 0	⊢ ¬(cau_seq.const abv x).lim_zero
α : Type u_1,	_inst_1 : linear_ordered_field α,	β : Type u_2,	_inst_2 : field β,	abv : β → α,	_inst_3 : is_absolute_value abv,	x : β,	hx : x ≠ 0,	n : ℕ	⊢ ⇑(cau_seq.const abv x⁻¹) n = ⇑((cau_seq.const abv x).inv _) n
α : Type u_1,	_inst_1 : linear_ordered_field α,	f g : cau_seq α abs,	pos_add_lim_zero : f.pos → g.lim_zero → (f + g).pos,	F : α,	F0 : F > 0,	hF : ∃ (i : ℕ), ∀ (j : ℕ), j ≥ i → F ≤ ⇑f j,	H : g.lim_zero,	_let_match : (∃ (i : ℕ), ∀ (j : ℕ), j ≥ i → (λ (j : ℕ), F ≤ ⇑f j) j ∧ (λ (j : ℕ), abs (⇑g j) < F / 2) j) → (f + g).pos,	i : ℕ,	h : ∀ (j : ℕ), j ≥ i → (λ (j : ℕ), F ≤ ⇑f j) j ∧ (λ (j : ℕ), abs (⇑g j) < F / 2) j,	j : ℕ,	ij : j ≥ i	⊢ F / 2 ≤ ⇑(f + g) j
α : Type u_1,	_inst_1 : linear_ordered_field α,	f g : cau_seq α abs,	pos_add_lim_zero : f.pos → g.lim_zero → (f + g).pos,	F : α,	F0 : F > 0,	hF : ∃ (i : ℕ), ∀ (j : ℕ), j ≥ i → F ≤ ⇑f j,	H : g.lim_zero,	_let_match : (∃ (i : ℕ), ∀ (j : ℕ), j ≥ i → (λ (j : ℕ), F ≤ ⇑f j) j ∧ (λ (j : ℕ), abs (⇑g j) < F / 2) j) → (f + g).pos,	i : ℕ,	h : ∀ (j : ℕ), j ≥ i → (λ (j : ℕ), F ≤ ⇑f j) j ∧ (λ (j : ℕ), abs (⇑g j) < F / 2) j,	j : ℕ,	ij : j ≥ i,	h₁ : F ≤ ⇑f j,	h₂ : abs (⇑g j) < F / 2	⊢ F / 2 ≤ ⇑(f + g) j
α : Type u_1,	_inst_1 : linear_ordered_field α,	f g : cau_seq α abs,	pos_add_lim_zero : f.pos → g.lim_zero → (f + g).pos,	F : α,	F0 : F > 0,	hF : ∃ (i : ℕ), ∀ (j : ℕ), j ≥ i → F ≤ ⇑f j,	H : g.lim_zero,	_let_match : (∃ (i : ℕ), ∀ (j : ℕ), j ≥ i → (λ (j : ℕ), F ≤ ⇑f j) j ∧ (λ (j : ℕ), abs (⇑g j) < F / 2) j) → (f + g).pos,	i : ℕ,	h : ∀ (j : ℕ), j ≥ i → (λ (j : ℕ), F ≤ ⇑f j) j ∧ (λ (j : ℕ), abs (⇑g j) < F / 2) j,	j : ℕ,	ij : j ≥ i,	h₁ : F ≤ ⇑f j,	h₂ : abs (⇑g j) < F / 2,	this : F + -(F / 2) ≤ ⇑f j + ⇑g j	⊢ F / 2 ≤ ⇑(f + g) j
α : Type u_1,	_inst_1 : linear_ordered_field α,	f g : cau_seq α abs,	h : (g - f).lim_zero ∨ (-(g - f)).pos,	h : (-(g - f)).pos	⊢ g < f
a b : ℝ≥0∞,	h0 : a ≠ 0,	hI : a ≠ ⊤	⊢ a * (b / a) = b
a b : ℝ≥0∞,	ha : a ≠ ⊤,	hb : b ≠ ⊤	⊢ (a + b).to_real = a.to_real + b.to_real
b : ℝ≥0∞,	hb : b ≠ ⊤,	a : ℝ≥0	⊢ (↑a + b).to_real = ↑a.to_real + b.to_real
a b : ℝ≥0	⊢ (↑a + ↑b).to_real = ↑a.to_real + ↑b.to_real
⊢ ↑1 < ↑2
⊢ algebra ℝ≥0 ℝ≥0∞
⊢ distrib_mul_action (units ℝ≥0) ℝ≥0∞
R : Type u_1,	_inst_1 : monoid R,	r : R,	s : ℝ≥0,	_inst_2 : mul_action R ℝ≥0,	_inst_3 : has_scalar R ℝ≥0∞,	_inst_4 : is_scalar_tower R ℝ≥0 ℝ≥0,	_inst_5 : is_scalar_tower R ℝ≥0 ℝ≥0∞	⊢ ↑(r • s) = r • ↑s
R : Type u_1,	_inst_1 : monoid R,	r : R,	s : ℝ≥0,	_inst_2 : mul_action R ℝ≥0,	_inst_3 : has_scalar R ℝ≥0∞,	_inst_4 : is_scalar_tower R ℝ≥0 ℝ≥0,	_inst_5 : is_scalar_tower R ℝ≥0 ℝ≥0∞	⊢ ↑(r • s) = (r • 1) • ↑s
R : Type u_1,	_inst_1 : monoid R,	r : R,	s : ℝ≥0,	_inst_2 : mul_action R ℝ≥0,	_inst_3 : has_scalar R ℝ≥0∞,	_inst_4 : is_scalar_tower R ℝ≥0 ℝ≥0,	_inst_5 : is_scalar_tower R ℝ≥0 ℝ≥0∞	⊢ ↑(r • s) = ↑(r • 1) * ↑s
a b : ℝ≥0∞	⊢ a + b ≠ ⊤ ↔ a ≠ ⊤ ∧ b ≠ ⊤
coe_ennreal_eq_coe_ennreal_iff : ∀ {x y : ℝ≥0∞}, ↑x = ↑y ↔ x = y	⊢ ↑⊤ = ↑⊤ ↔ ⊤ = ⊤
coe_ennreal_eq_coe_ennreal_iff : ∀ {x y : ℝ≥0∞}, ↑x = ↑y ↔ x = y,	x : ℝ≥0	⊢ ↑(option.some x) = ↑⊤ ↔ option.some x = ⊤
coe_ennreal_eq_coe_ennreal_iff : ∀ {x y : ℝ≥0∞}, ↑x = ↑y ↔ x = y,	y : ℝ≥0	⊢ ↑⊤ = ↑(option.some y) ↔ ⊤ = option.some y
coe_ennreal_eq_coe_ennreal_iff : ∀ {x y : ℝ≥0∞}, ↑x = ↑y ↔ x = y,	x y : ℝ≥0	⊢ ↑(option.some x) = ↑(option.some y) ↔ option.some x = option.some y
x y : ℝ	⊢ x.to_ereal < y.to_ereal ↔ x < y
x y : ℝ	⊢ ↑x < ↑y ↔ x < y
⊢ 0 < 1 + real.sqrt 5
⊢ 0 < 1 + real.sqrt 5
⊢ 0 < 1
⊢ 0 < real.sqrt 5
x : ℝ*,	hx : x.st ≠ 0	⊢ x.is_st (dite (∃ (r : ℝ), x.is_st r) (λ (h : ∃ (r : ℝ), x.is_st r), classical.some h) (λ (h : ¬∃ (r : ℝ), x.is_st r), 0))
x : ℝ*,	hx : x.st ≠ 0	⊢ x.is_st x.st
x : ℝ*,	hx : x.st ≠ 0,	h : ∃ (r : ℝ), x.is_st r	⊢ x.is_st (classical.some h)		x : ℝ*,	hx : x.st ≠ 0,	h : ¬∃ (r : ℝ), x.is_st r	⊢ x.is_st 0
x : ℝ*,	hx : x.st ≠ 0,	h : ∃ (r : ℝ), x.is_st r	⊢ x.is_st (classical.some h)
x : ℝ*,	hx : x.st ≠ 0,	h : ¬∃ (r : ℝ), x.is_st r	⊢ x.st = 0
x : ℝ*,	hx : x.st ≠ 0,	h : ¬∃ (r : ℝ), x.is_st r	⊢ x.st = 0
x : ℝ*,	hx : x.st ≠ 0,	h : ¬∃ (r : ℝ), x.is_st r	⊢ x.st = 0
x : ℝ*,	hx : x.st ≠ 0,	h : ¬∃ (r : ℝ), x.is_st r	⊢ dite (∃ (r : ℝ), x.is_st r) (λ (h : ∃ (r : ℝ), x.is_st r), classical.some h) (λ (h : ¬∃ (r : ℝ), x.is_st r), 0) = 0
x : ℝ*,	hx : x.st ≠ 0,	h : ¬∃ (r : ℝ), x.is_st r	⊢ 0 = 0
x : ℝ*,	hx : x.st ≠ 0,	h : ¬∃ (r : ℝ), x.is_st r	⊢ x.is_st 0
this : ∀ᶠ (i : ℕ) in ↑(filter.hyperfilter ℕ), 0 < (↑i)⁻¹	⊢ 0 < ε
x y : ℝ*,	hx : ¬x.infinitesimal,	hp : 0 < x,	hy : y.infinite_neg	⊢ (x * y).infinite_neg
x y : ℝ*,	hx : ¬x.infinitesimal,	hp : 0 < x,	hy : y.infinite_neg	⊢ (x * y).infinite_neg
x y : ℝ*,	hx : ¬x.infinitesimal,	hp : 0 < x,	hy : y.infinite_neg	⊢ (y * x).infinite_neg
⊢ {n : ℕ | ¬0 < n} = {0}
⊢ {n : ℕ | ¬0 < n} = {0}
⊢ {n : ℕ | ¬0 < n} = {0}
⊢ {n : ℕ | n ≤ 0} = {n : ℕ | n = 0}
x : ℕ	⊢ x ∈ {n : ℕ | n ≤ 0} ↔ x ∈ {n : ℕ | n = 0}
h0' : {n : ℕ | ¬0 < n} = {0}	⊢ ∀ᶠ (i : ℕ) in ↑(filter.hyperfilter ℕ), 0 < (↑i)⁻¹
h0' : {n : ℕ | ¬0 < n} = {0}	⊢ filter.eventually (has_lt.lt 0) ↑(filter.hyperfilter ℕ)
h0' : {n : ℕ | ¬0 < n} = {0}	⊢ {x : ℕ | 0 < x}ᶜ.finite
q : ℚ,	x : ℝ,	h : irrational x	⊢ irrational (↑q - x)
⊢ algebra ℝ≥0 ℝ
⊢ distrib_mul_action (units ℝ≥0) ℝ
r p : ℝ	⊢ r.to_nnreal < p.to_nnreal ↔ r < p ∧ 0 < p
a b r : ℝ≥0,	hr : r ≠ 0	⊢ a ≤ b / r ↔ a * r ≤ b
r : ℝ,	hr : r ≠ 0	⊢ 0 < r.sign * r
r : ℝ,	hr : r ≠ 0,	h : 0 = r.sign * r	⊢ r = 0
r : ℝ,	hr : r ≠ 0,	h : 0 = r.sign * r,	hs0 : r.sign = 0	⊢ r = 0
⊢ real.sqrt 1 = 1
α : Type u_1,	β : Type u_2,	r : rel α β	⊢ r.inv.dom = r.codom
α : Type u_1,	β : Type u_2,	r : rel α β,	x : β	⊢ x ∈ r.inv.dom ↔ x ∈ r.codom
α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	r : rel α β,	s : rel β γ,	t : rel γ δ	⊢ (λ (x : α) (z : δ), ∃ (y : γ), (∃ (y_1 : β), r x y_1 ∧ s y_1 y) ∧ t y z) = λ (x : α) (z : δ), ∃ (y : β), r x y ∧ ∃ (y_1 : γ), s y y_1 ∧ t y_1 z
α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	r : rel α β,	s : rel β γ,	t : rel γ δ,	x : α,	w : δ	⊢ (∃ (y : γ), (∃ (y_1 : β), r x y_1 ∧ s y_1 y) ∧ t y w) ↔ ∃ (y : β), r x y ∧ ∃ (y_1 : γ), s y y_1 ∧ t y_1 w
α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	r : rel α β,	s : rel β γ,	t : rel γ δ	⊢ (r ∘ s) ∘ t = r ∘ s ∘ t
α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	r : rel α β,	s : rel β γ,	t : rel γ δ,	x : α,	w : δ,	z : γ,	tzw : t z w,	y : β,	rxy : r x y,	syz : s y z	⊢ ∃ (y : β), r x y ∧ ∃ (y_1 : γ), s y y_1 ∧ t y_1 w
α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	r : rel α β,	s : rel β γ,	t : rel γ δ,	x : α,	w : δ	⊢ (∃ (y : γ), (∃ (y_1 : β), r x y_1 ∧ s y_1 y) ∧ t y w) → (∃ (y : β), r x y ∧ ∃ (y_1 : γ), s y y_1 ∧ t y_1 w)
α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	r : rel α β,	s : rel β γ,	t : rel γ δ,	x : α,	w : δ	⊢ (∃ (y : γ), (∃ (y_1 : β), r x y_1 ∧ s y_1 y) ∧ t y w) → (∃ (y : β), r x y ∧ ∃ (y_1 : γ), s y y_1 ∧ t y_1 w)		α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	r : rel α β,	s : rel β γ,	t : rel γ δ,	x : α,	w : δ	⊢ (∃ (y : β), r x y ∧ ∃ (y_1 : γ), s y y_1 ∧ t y_1 w) → (∃ (y : γ), (∃ (y_1 : β), r x y_1 ∧ s y_1 y) ∧ t y w)
α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	r : rel α β,	s : rel β γ,	t : rel γ δ,	x : α,	w : δ,	y : β,	rxy : r x y,	z : γ,	syz : s y z,	tzw : t z w	⊢ ∃ (y : γ), (∃ (y_1 : β), r x y_1 ∧ s y_1 y) ∧ t y w
α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	r : rel α β,	s : rel β γ,	t : rel γ δ,	x : α,	w : δ	⊢ (∃ (y : β), r x y ∧ ∃ (y_1 : γ), s y y_1 ∧ t y_1 w) → (∃ (y : γ), (∃ (y_1 : β), r x y_1 ∧ s y_1 y) ∧ t y w)
α : Type u_1,	q : semiquot α,	p : q.is_pure,	_let_match : (∃ (a : α), a ∈ q) → q.get p ∈ q,	a : α,	h : a ∈ q	⊢ q.get p ∈ q
α : Type u_1,	q : semiquot α,	p : q.is_pure,	_let_match : (∃ (a : α), a ∈ q) → q.get p ∈ q,	a : α,	h : a ∈ q	⊢ q.get p ∈ q
α : Type u_1,	q : semiquot α,	p : q.is_pure,	_let_match : (∃ (a : α), a ∈ q) → q.get p ∈ q,	a : α,	h : a ∈ q	⊢ q.lift_on id p ∈ q
α : Type u_1,	q : semiquot α,	p : q.is_pure,	_let_match : (∃ (a : α), a ∈ q) → q.get p ∈ q,	a : α,	h : a ∈ q	⊢ id a ∈ q
α : Type u_1,	q : semiquot α,	p : q.is_pure,	_let_match : (∃ (a : α), a ∈ q) → q.get p ∈ q,	a : α,	h : a ∈ q	⊢ q.get p ∈ q
α : Type u,	s : computation α,	H : ¬s.terminates	⊢ s.val = (computation.empty α).val
α : Type u,	s : computation α,	H : ¬s.terminates	⊢ s = computation.empty α
α : Type u,	s : computation α,	H : ¬s.terminates,	n : ℕ,	h : s.val n = option.none	⊢ option.none = (computation.empty α).val n
α : Type u,	s : computation α,	H : ¬s.terminates,	n : ℕ,	h : s.val n = option.none	⊢ option.none = (computation.empty α).val n		case option.some	α : Type u,	s : computation α,	H : ¬s.terminates,	n : ℕ,	val : α,	h : s.val n = option.some val	⊢ option.some val = (computation.empty α).val n
α : Type u,	s : computation α,	H : ¬s.terminates,	n : ℕ	⊢ s.val n = (computation.empty α).val n
α : Type u,	s : computation α,	H : ¬s.terminates,	n : ℕ,	val : α,	h : s.val n = option.some val	⊢ s.terminates
α : Type u,	s : computation α,	H : ¬s.terminates,	n : ℕ,	val : α,	h : s.val n = option.some val	⊢ option.some val = (computation.empty α).val n
α : Type u,	S T : wseq (computation α),	a : α,	h1 : ∀ (s : computation α), s ∈ S → s ~> a,	H : wseq.lift_rel computation.equiv S T,	h2 : ∀ (t : computation α), t ∈ T → t ~> a := (computation.parallel_congr_lem H).mp h1,	a' : α,	h : a' ∈ computation.parallel S	⊢ a' ∈ computation.parallel T
α : Type u,	S T : wseq (computation α),	a : α,	h1 : ∀ (s : computation α), s ∈ S → s ~> a,	H : wseq.lift_rel computation.equiv S T,	h2 : ∀ (t : computation α), t ∈ T → t ~> a := (computation.parallel_congr_lem H).mp h1,	a' : α,	h : a' ∈ computation.parallel S	⊢ a' ∈ computation.parallel T
α : Type u,	S T : wseq (computation α),	a : α,	h1 : ∀ (s : computation α), s ∈ S → s ~> a,	H : wseq.lift_rel computation.equiv S T,	h2 : ∀ (t : computation α), t ∈ T → t ~> a := (computation.parallel_congr_lem H).mp h1,	a' : α,	h : a' ∈ computation.parallel S	⊢ a' ∈ computation.parallel T
α : Type u,	S T : wseq (computation α),	a : α,	h1 : ∀ (s : computation α), s ∈ S → s ~> a,	H : wseq.lift_rel computation.equiv S T,	h2 : ∀ (t : computation α), t ∈ T → t ~> a := (computation.parallel_congr_lem H).mp h1,	a' : α,	h : a' ∈ computation.parallel S	⊢ a' ∈ computation.parallel T
α : Type u,	S T : wseq (computation α),	a : α,	h1 : ∀ (s : computation α), s ∈ S → s ~> a,	H : wseq.lift_rel computation.equiv S T,	h2 : ∀ (t : computation α), t ∈ T → t ~> a := (computation.parallel_congr_lem H).mp h1,	a' : α,	h : a' ∈ computation.parallel S,	aa : a = a'	⊢ a' ∈ computation.parallel T
α : Type u,	S T : wseq (computation α),	a : α,	h1 : ∀ (s : computation α), s ∈ S → s ~> a,	H : wseq.lift_rel computation.equiv S T,	h2 : ∀ (t : computation α), t ∈ T → t ~> a := (computation.parallel_congr_lem H).mp h1,	a' : α,	h : a' ∈ computation.parallel S,	aa : a = a'	⊢ a ∈ computation.parallel T
α : Type u,	S T : wseq (computation α),	a : α,	h1 : ∀ (s : computation α), s ∈ S → s ~> a,	H : wseq.lift_rel computation.equiv S T,	h2 : ∀ (t : computation α), t ∈ T → t ~> a := (computation.parallel_congr_lem H).mp h1,	a' : α,	aa : a = a',	h : a ∈ computation.parallel S	⊢ a ∈ computation.parallel T
α : Type u,	S T : wseq (computation α),	a : α,	h1 : ∀ (s : computation α), s ∈ S → s ~> a,	H : wseq.lift_rel computation.equiv S T,	h2 : ∀ (t : computation α), t ∈ T → t ~> a := (computation.parallel_congr_lem H).mp h1,	a' : α,	h : a' ∈ computation.parallel T	⊢ a' ∈ computation.parallel S
α : Type u,	S T : wseq (computation α),	a : α,	h1 : ∀ (s : computation α), s ∈ S → s ~> a,	H : wseq.lift_rel computation.equiv S T,	h2 : ∀ (t : computation α), t ∈ T → t ~> a := (computation.parallel_congr_lem H).mp h1,	a' : α,	h : a' ∈ computation.parallel T	⊢ a' ∈ computation.parallel S
α : Type u,	S T : wseq (computation α),	a : α,	h1 : ∀ (s : computation α), s ∈ S → s ~> a,	H : wseq.lift_rel computation.equiv S T,	h2 : ∀ (t : computation α), t ∈ T → t ~> a := (computation.parallel_congr_lem H).mp h1,	a' : α,	h : a' ∈ computation.parallel T	⊢ a' ∈ computation.parallel S
α : Type u,	S T : wseq (computation α),	a : α,	h1 : ∀ (s : computation α), s ∈ S → s ~> a,	H : wseq.lift_rel computation.equiv S T,	h2 : ∀ (t : computation α), t ∈ T → t ~> a := (computation.parallel_congr_lem H).mp h1,	a' : α,	h : a' ∈ computation.parallel T,	aa : a = a'	⊢ a' ∈ computation.parallel S
α : Type u,	S T : wseq (computation α),	a : α,	h1 : ∀ (s : computation α), s ∈ S → s ~> a,	H : wseq.lift_rel computation.equiv S T,	h2 : ∀ (t : computation α), t ∈ T → t ~> a := (computation.parallel_congr_lem H).mp h1,	a' : α,	h : a' ∈ computation.parallel T,	aa : a = a'	⊢ a ∈ computation.parallel S
α : Type u,	S T : wseq (computation α),	a : α,	h1 : ∀ (s : computation α), s ∈ S → s ~> a,	H : wseq.lift_rel computation.equiv S T,	h2 : ∀ (t : computation α), t ∈ T → t ~> a := (computation.parallel_congr_lem H).mp h1,	a' : α,	aa : a = a',	h : a ∈ computation.parallel T	⊢ a ∈ computation.parallel S
α : Type u,	S T : wseq (computation α),	a : α,	h1 : ∀ (s : computation α), s ∈ S → s ~> a,	H : wseq.lift_rel computation.equiv S T,	h2 : ∀ (t : computation α), t ∈ T → t ~> a := (computation.parallel_congr_lem H).mp h1,	a' : α,	h : a' ∈ computation.parallel T	⊢ a' ∈ computation.parallel S
α : Type u,	a : α,	s : stream α	⊢ seq.of_stream (a::s) = seq.cons a (seq.of_stream s)
α : Type u,	a : α,	s : stream α	⊢ seq.of_stream (a::s) = seq.cons a (seq.of_stream s)
α : Type u,	a : α,	s : stream α	⊢ (seq.of_stream (a::s)).val = (seq.cons a (seq.of_stream s)).val
α : Type u,	a : α,	s : stream α	⊢ stream.map option.some (a::s) = option.some a::stream.map option.some s
α : Type u,	a : α,	s : stream α	⊢ seq.of_stream (a::s) = seq.cons a (seq.of_stream s)
α : Type u,	s : wseq α,	b a : α	⊢ option.some (b, s) ∈ (wseq.cons b s).destruct
α : Type u,	β : Type v,	R : α → β → Prop	⊢ wseq.lift_rel R wseq.nil wseq.nil
α : Type u,	β : Type v,	R : α → β → Prop	⊢ computation.lift_rel (wseq.lift_rel_o R (wseq.lift_rel R)) wseq.nil.destruct wseq.nil.destruct
α : Type u,	β : Type v,	R : α → β → Prop	⊢ wseq.lift_rel R wseq.nil wseq.nil
α : Type u,	β : Type v,	R : α → β → Prop,	s : wseq α,	t : wseq β	⊢ wseq.lift_rel R s.think t ↔ wseq.lift_rel R s t
α : Type u,	β : Type v,	R : α → β → Prop,	s : wseq α,	t : wseq β	⊢ wseq.lift_rel R s.think t ↔ wseq.lift_rel R s t
α : Type u,	β : Type v,	R : α → β → Prop,	s : wseq α,	t : wseq β	⊢ computation.lift_rel (wseq.lift_rel_o R (wseq.lift_rel R)) s.think.destruct t.destruct ↔ computation.lift_rel (wseq.lift_rel_o R (wseq.lift_rel R)) s.destruct t.destruct
α : Type u,	c : computation (wseq α),	s : wseq α,	h : s ∈ c	⊢ wseq.flatten (return s) ~ s
α : Type u,	c : computation (wseq α),	s : wseq α,	h : s ∈ c	⊢ wseq.flatten c ~ s
α : Type u,	c : computation (wseq α),	s : wseq α,	h : s ∈ c	⊢ wseq.flatten (return s) ~ s		α : Type u,	c : computation (wseq α),	s : wseq α,	h : s ∈ c	⊢ ∀ (s_1 : computation (wseq α)), wseq.flatten s_1 ~ s → wseq.flatten s_1.think ~ s
α : Type u,	c : computation (wseq α),	s : wseq α,	h : s ∈ c,	s' : computation (wseq α)	⊢ wseq.flatten s' ~ s → wseq.flatten s'.think ~ s
α : Type u,	c : computation (wseq α),	s : wseq α,	h : s ∈ c,	s' : computation (wseq α)	⊢ wseq.flatten s'.think ~ wseq.flatten s'
α : Type u,	c : computation (wseq α),	s : wseq α,	h : s ∈ c	⊢ ∀ (s_1 : computation (wseq α)), wseq.flatten s_1 ~ s → wseq.flatten s_1.think ~ s
α : Type u,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n	⊢ computation.lift_rel (wseq.lift_rel_o eq (λ (s t : wseq α), ∀ (n : ℕ), s.nth n ~ t.nth n)) s.destruct t.destruct
α : Type u,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n	⊢ s.destruct.terminates ↔ t.destruct.terminates
α : Type u,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n	⊢ s.destruct.terminates ↔ t.destruct.terminates		α : Type u,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n	⊢ ∀ {a b : option (α × wseq α)}, a ∈ s.destruct → b ∈ t.destruct → wseq.lift_rel_o eq (λ (s t : wseq α), ∀ (n : ℕ), s.nth n ~ t.nth n) a b
α : Type u,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n	⊢ s.head.terminates ↔ t.head.terminates
α : Type u,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n	⊢ ∀ {a b : option (α × wseq α)}, a ∈ s.destruct → b ∈ t.destruct → wseq.lift_rel_o eq (λ (s t : wseq α), ∀ (n : ℕ), s.nth n ~ t.nth n) a b
α : Type u,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	a b : option (α × wseq α),	ma : a ∈ s.destruct,	mb : b ∈ t.destruct	⊢ wseq.lift_rel_o eq (λ (s t : wseq α), ∀ (n : ℕ), s.nth n ~ t.nth n) a b
α : Type u,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	b : option (α × wseq α),	mb : b ∈ t.destruct,	ma : option.none ∈ s.destruct	⊢ wseq.lift_rel_o eq (λ (s t : wseq α), ∀ (n : ℕ), s.nth n ~ t.nth n) option.none b
α : Type u,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	b : option (α × wseq α),	mb : b ∈ t.destruct,	a : α × wseq α,	ma : option.some a ∈ s.destruct	⊢ wseq.lift_rel_o eq (λ (s t : wseq α), ∀ (n : ℕ), s.nth n ~ t.nth n) (option.some a) b
α : Type u,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	a b : option (α × wseq α),	ma : a ∈ s.destruct,	mb : b ∈ t.destruct	⊢ wseq.lift_rel_o eq (λ (s t : wseq α), ∀ (n : ℕ), s.nth n ~ t.nth n) a b
α : Type u,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	ma : option.none ∈ s.destruct,	mb : option.none ∈ t.destruct	⊢ wseq.lift_rel_o eq (λ (s t : wseq α), ∀ (n : ℕ), s.nth n ~ t.nth n) option.none option.none		case option.none, option.some	α : Type u,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	ma : option.none ∈ s.destruct,	b : α × wseq α,	mb : option.some b ∈ t.destruct	⊢ wseq.lift_rel_o eq (λ (s t : wseq α), ∀ (n : ℕ), s.nth n ~ t.nth n) option.none (option.some b)		case option.some, option.none	α : Type u,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	a : α × wseq α,	ma : option.some a ∈ s.destruct,	mb : option.none ∈ t.destruct	⊢ wseq.lift_rel_o eq (λ (s t : wseq α), ∀ (n : ℕ), s.nth n ~ t.nth n) (option.some a) option.none		case option.some, option.some	α : Type u,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	a : α × wseq α,	ma : option.some a ∈ s.destruct,	b : α × wseq α,	mb : option.some b ∈ t.destruct	⊢ wseq.lift_rel_o eq (λ (s t : wseq α), ∀ (n : ℕ), s.nth n ~ t.nth n) (option.some a) (option.some b)
α : Type u,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	ma : option.none ∈ s.destruct,	mb : option.none ∈ t.destruct	⊢ wseq.lift_rel_o eq (λ (s t : wseq α), ∀ (n : ℕ), s.nth n ~ t.nth n) option.none option.none
α : Type u,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	ma : option.none ∈ s.destruct,	b : α × wseq α,	mb : option.some b ∈ t.destruct	⊢ wseq.lift_rel_o eq (λ (s t : wseq α), ∀ (n : ℕ), s.nth n ~ t.nth n) option.none (option.some b)		case option.some, option.none	α : Type u,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	a : α × wseq α,	ma : option.some a ∈ s.destruct,	mb : option.none ∈ t.destruct	⊢ wseq.lift_rel_o eq (λ (s t : wseq α), ∀ (n : ℕ), s.nth n ~ t.nth n) (option.some a) option.none		case option.some, option.some	α : Type u,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	a : α × wseq α,	ma : option.some a ∈ s.destruct,	b : α × wseq α,	mb : option.some b ∈ t.destruct	⊢ wseq.lift_rel_o eq (λ (s t : wseq α), ∀ (n : ℕ), s.nth n ~ t.nth n) (option.some a) (option.some b)
α : Type u,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	ma : option.none ∈ s.destruct,	b : α × wseq α,	mb : option.some b ∈ t.destruct	⊢ wseq.lift_rel_o eq (λ (s t : wseq α), ∀ (n : ℕ), s.nth n ~ t.nth n) option.none (option.some b)
α : Type u,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	a : α × wseq α,	ma : option.some a ∈ s.destruct,	mb : option.none ∈ t.destruct	⊢ wseq.lift_rel_o eq (λ (s t : wseq α), ∀ (n : ℕ), s.nth n ~ t.nth n) (option.some a) option.none		case option.some, option.some	α : Type u,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	a : α × wseq α,	ma : option.some a ∈ s.destruct,	b : α × wseq α,	mb : option.some b ∈ t.destruct	⊢ wseq.lift_rel_o eq (λ (s t : wseq α), ∀ (n : ℕ), s.nth n ~ t.nth n) (option.some a) (option.some b)
α : Type u,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	a : α × wseq α,	ma : option.some a ∈ s.destruct,	mb : option.none ∈ t.destruct	⊢ wseq.lift_rel_o eq (λ (s t : wseq α), ∀ (n : ℕ), s.nth n ~ t.nth n) (option.some a) option.none
α : Type u,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	b : α × wseq α,	mb : option.some b ∈ t.destruct,	a : α,	s' : wseq α,	ma : option.some (a, s') ∈ s.destruct	⊢ wseq.lift_rel_o eq (λ (s t : wseq α), ∀ (n : ℕ), s.nth n ~ t.nth n) (option.some (a, s')) (option.some b)
α : Type u,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	a : α × wseq α,	ma : option.some a ∈ s.destruct,	b : α × wseq α,	mb : option.some b ∈ t.destruct	⊢ wseq.lift_rel_o eq (λ (s t : wseq α), ∀ (n : ℕ), s.nth n ~ t.nth n) (option.some a) (option.some b)
α : Type u,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	a : α,	s' : wseq α,	ma : option.some (a, s') ∈ s.destruct,	b : α,	t' : wseq α,	mb : option.some (b, t') ∈ t.destruct	⊢ wseq.lift_rel_o eq (λ (s t : wseq α), ∀ (n : ℕ), s.nth n ~ t.nth n) (option.some (a, s')) (option.some (b, t'))
α : Type u,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	a : α,	s' : wseq α,	ma : option.some (a, s') ∈ s.destruct,	b : α,	t' : wseq α,	mb : option.some (b, t') ∈ t.destruct,	ab : (a, s').fst = (b, t').fst	⊢ wseq.lift_rel_o eq (λ (s t : wseq α), ∀ (n : ℕ), s.nth n ~ t.nth n) (option.some (a, s')) (option.some (b, t'))
α : Type u,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	a : α,	s' : wseq α,	ma : option.some (a, s') ∈ s.destruct,	b : α,	t' : wseq α,	mb : option.some (b, t') ∈ t.destruct,	ab : (a, s').fst = (b, t').fst,	n : ℕ	⊢ s'.nth n ~ t'.nth n
α : Type u,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	a : α,	s' : wseq α,	ma : option.some (a, s') ∈ s.destruct,	b : α,	t' : wseq α,	mb : option.some (b, t') ∈ t.destruct,	ab : (a, s').fst = (b, t').fst,	n : ℕ	⊢ s.nth (n + 1) ~ t.nth (n + 1)
α : Type u,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	s t : wseq α,	h : ∀ (n : ℕ), s.nth n ~ t.nth n,	a : α,	s' : wseq α,	ma : option.some (a, s') ∈ s.destruct,	b : α,	t' : wseq α,	mb : option.some (b, t') ∈ t.destruct,	ab : (a, s').fst = (b, t').fst,	n : ℕ	⊢ s.tail.nth n ~ t.tail.nth n
α : Type u,	β : Type v,	f : α → β,	s t : set α,	x : β	⊢ x ∈ f '' (s ∪ t) → x ∈ f '' s ∪ f '' t
α : Type u,	β : Type v,	f : α → β,	s t : set α,	x : β	⊢ x ∈ f '' (s ∪ t) → x ∈ f '' s ∪ f '' t
α : Type u,	β : Type v,	f : α → β,	s t : set α,	x : β	⊢ x ∈ f '' (s ∪ t) → x ∈ f '' s ∪ f '' t
α : Type u,	β : Type v,	f : α → β,	s t : set α,	a : α,	h : a ∈ s	⊢ f a ∈ f '' s ∪ f '' t
α : Type u,	β : Type v,	f : α → β,	s t : set α,	a : α,	h : a ∈ t	⊢ f a ∈ f '' s ∪ f '' t
α : Type u,	β : Type v,	f : α → β,	s t : set α,	a : α,	h : a ∈ s	⊢ f a ∈ f '' s
α : Type u,	β : Type v,	f : α → β,	s t : set α,	a : α,	h : a ∈ t	⊢ f a ∈ f '' t
α : Type u,	β : Type v,	f : α → β,	s t : set α,	x : β	⊢ x ∈ f '' s ∪ f '' t → x ∈ f '' (s ∪ t)
α : Type u,	β : Type v,	f : α → β,	s t : set α,	x : β	⊢ x ∈ f '' s ∪ f '' t → x ∈ f '' (s ∪ t)
α : Type u,	β : Type v,	f : α → β,	s t : set α,	x : β	⊢ x ∈ f '' s ∪ f '' t → x ∈ f '' (s ∪ t)
α : Type u,	β : Type v,	f : α → β,	s t : set α,	a : α,	h : a ∈ s	⊢ f a ∈ f '' (s ∪ t)
α : Type u,	β : Type v,	f : α → β,	s t : set α,	a : α,	h : a ∈ t	⊢ f a ∈ f '' (s ∪ t)
α : Type u,	β : Type v,	f : α → β,	s t : set α,	a : α,	h : a ∈ s	⊢ a ∈ s ∪ t
α : Type u,	β : Type v,	f : α → β,	s t : set α,	a : α,	h : a ∈ t	⊢ a ∈ s ∪ t
α : Type u,	β : Type v,	f : α → β,	s t : set α,	x : β	⊢ x ∈ f '' s ∪ f '' t → x ∈ f '' (s ∪ t)
α : Type u,	β : Type v,	f : α → β,	s t : set α,	a : α,	h : a ∈ s	⊢ a ∈ s
α : Type u,	β : Type v,	f : α → β,	s t : set α,	a : α,	h : a ∈ t	⊢ a ∈ t
α : Type u_1,	x y : α	⊢ (x, y) ∈ set.diagonal α ↔ (x, y) ∈ set.range (λ (x : α), (x, x))
α : Type u_1	⊢ set.diagonal α = set.range (λ (x : α), (x, x))
α : Type u,	β : Type v,	f : α → β,	x : ↥(set.range f)	⊢ set.range_factorization f (set.range_splitting f x) = x
α : Type u,	β : Type v,	f : α → β,	x : ↥(set.range f)	⊢ ↑(set.range_factorization f (set.range_splitting f x)) = ↑x
α : Type u,	β : Type v,	f : α → β,	x : ↥(set.range f)	⊢ f (set.range_splitting f x) = ↑x
ι : Type u_1,	α : ι → Type u_2,	p : ι → Prop,	h : decidable_pred p,	s : set ι,	t₁ t₂ : Π (i : ι), set (α i)	⊢ s.pi (λ (i : ι), ite (p i) (t₁ i) (t₂ i)) = {i ∈ s | p i}.pi t₁ ∩ {i ∈ s | ¬p i}.pi t₂
ι : Type u_1,	α : ι → Type u_2,	p : ι → Prop,	h : decidable_pred p,	s : set ι,	t₁ t₂ : Π (i : ι), set (α i),	f : Π (i : ι), (λ (i : ι), α i) i	⊢ f ∈ s.pi (λ (i : ι), ite (p i) (t₁ i) (t₂ i)) ↔ f ∈ {i ∈ s | p i}.pi t₁ ∩ {i ∈ s | ¬p i}.pi t₂
ι : Type u_1,	α : ι → Type u_2,	p : ι → Prop,	h : decidable_pred p,	s : set ι,	t₁ t₂ : Π (i : ι), set (α i),	f : Π (i : ι), (λ (i : ι), α i) i,	h : f ∈ s.pi (λ (i : ι), ite (p i) (t₁ i) (t₂ i))	⊢ f ∈ {i ∈ s | p i}.pi t₁ ∩ {i ∈ s | ¬p i}.pi t₂
ι : Type u_1,	α : ι → Type u_2,	p : ι → Prop,	h : decidable_pred p,	s : set ι,	t₁ t₂ : Π (i : ι), set (α i),	f : Π (i : ι), (λ (i : ι), α i) i,	h : f ∈ s.pi (λ (i : ι), ite (p i) (t₁ i) (t₂ i))	⊢ f ∈ {i ∈ s | p i}.pi t₁ ∩ {i ∈ s | ¬p i}.pi t₂
ι : Type u_1,	α : ι → Type u_2,	p : ι → Prop,	h : decidable_pred p,	s : set ι,	t₁ t₂ : Π (i : ι), set (α i),	f : Π (i : ι), (λ (i : ι), α i) i,	h : f ∈ s.pi (λ (i : ι), ite (p i) (t₁ i) (t₂ i))	⊢ f ∈ {i ∈ s | ¬p i}.pi t₂
ι : Type u_1,	α : ι → Type u_2,	p : ι → Prop,	h : decidable_pred p,	s : set ι,	t₁ t₂ : Π (i : ι), set (α i),	f : Π (i : ι), (λ (i : ι), α i) i,	h : f ∈ s.pi (λ (i : ι), ite (p i) (t₁ i) (t₂ i)),	i : ι,	his : i ∈ s,	hpi : ¬p i	⊢ f i ∈ t₂ i
ι : Type u_1,	α : ι → Type u_2,	p : ι → Prop,	h : decidable_pred p,	s : set ι,	t₁ t₂ : Π (i : ι), set (α i),	f : Π (i : ι), (λ (i : ι), α i) i	⊢ f ∈ s.pi (λ (i : ι), ite (p i) (t₁ i) (t₂ i)) → f ∈ {i ∈ s | p i}.pi t₁ ∩ {i ∈ s | ¬p i}.pi t₂
ι : Type u_1,	α : ι → Type u_2,	p : ι → Prop,	h : decidable_pred p,	s : set ι,	t₁ t₂ : Π (i : ι), set (α i),	f : Π (i : ι), (λ (i : ι), α i) i	⊢ f ∈ s.pi (λ (i : ι), ite (p i) (t₁ i) (t₂ i)) → f ∈ {i ∈ s | p i}.pi t₁ ∩ {i ∈ s | ¬p i}.pi t₂		ι : Type u_1,	α : ι → Type u_2,	p : ι → Prop,	h : decidable_pred p,	s : set ι,	t₁ t₂ : Π (i : ι), set (α i),	f : Π (i : ι), (λ (i : ι), α i) i	⊢ f ∈ {i ∈ s | p i}.pi t₁ ∩ {i ∈ s | ¬p i}.pi t₂ → f ∈ s.pi (λ (i : ι), ite (p i) (t₁ i) (t₂ i))
ι : Type u_1,	α : ι → Type u_2,	p : ι → Prop,	h : decidable_pred p,	s : set ι,	t₁ t₂ : Π (i : ι), set (α i),	f : Π (i : ι), (λ (i : ι), α i) i	⊢ f ∈ {i ∈ s | p i}.pi t₁ ∩ {i ∈ s | ¬p i}.pi t₂ → f ∈ s.pi (λ (i : ι), ite (p i) (t₁ i) (t₂ i))
ι : Type u_1,	α : ι → Type u_2,	p : ι → Prop,	h : decidable_pred p,	s : set ι,	t₁ t₂ : Π (i : ι), set (α i),	f : Π (i : ι), (λ (i : ι), α i) i,	i : ι,	his : i ∈ s,	ht₁ : f ∈ {i ∈ s | p i}.pi t₁,	ht₂ : f ∈ {i ∈ s | ¬p i}.pi t₂	⊢ f i ∈ (λ (i : ι), ite (p i) (t₁ i) (t₂ i)) i
ι : Type u_1,	α : ι → Type u_2,	p : ι → Prop,	h : decidable_pred p,	s : set ι,	t₁ t₂ : Π (i : ι), set (α i),	f : Π (i : ι), (λ (i : ι), α i) i,	i : ι,	his : i ∈ s,	ht₁ : f ∈ {i ∈ s | p i}.pi t₁,	ht₂ : f ∈ {i ∈ s | ¬p i}.pi t₂,	h : p i	⊢ f i ∈ (λ (i : ι), ite (p i) (t₁ i) (t₂ i)) i
ι : Type u_1,	α : ι → Type u_2,	p : ι → Prop,	h : decidable_pred p,	s : set ι,	t₁ t₂ : Π (i : ι), set (α i),	f : Π (i : ι), (λ (i : ι), α i) i,	i : ι,	his : i ∈ s,	ht₁ : f ∈ {i ∈ s | p i}.pi t₁,	ht₂ : f ∈ {i ∈ s | ¬p i}.pi t₂,	h : ¬p i	⊢ f i ∈ (λ (i : ι), ite (p i) (t₁ i) (t₂ i)) i
ι : Type u_1,	α : ι → Type u_2,	p : ι → Prop,	h : decidable_pred p,	s : set ι,	t₁ t₂ : Π (i : ι), set (α i),	f : Π (i : ι), (λ (i : ι), α i) i,	i : ι,	his : i ∈ s,	ht₁ : f ∈ {i ∈ s | p i}.pi t₁,	ht₂ : f ∈ {i ∈ s | ¬p i}.pi t₂	⊢ f i ∈ (λ (i : ι), ite (p i) (t₁ i) (t₂ i)) i
ι : Type u_1,	α : ι → Type u_2,	s : set ι,	_inst_1 : decidable_eq ι,	β : ι → Type u_3,	i : ι,	hi : i ∉ s,	f : Π (j : ι), α j,	a : α i,	t : Π (j : ι), α j → set (β j),	j : ι,	hj : j ∈ s	⊢ t j (function.update f i a j) = t j (f j)
ι : Type u_1,	α : ι → Type u_2,	s : set ι,	_inst_1 : decidable_eq ι,	β : ι → Type u_3,	i : ι,	hi : i ∉ s,	f : Π (j : ι), α j,	a : α i,	t : Π (j : ι), α j → set (β j),	j : ι,	hj : j ∈ s	⊢ j ≠ i
ι : Type u_1,	α : ι → Type u_2,	s : set ι,	_inst_1 : decidable_eq ι,	β : ι → Type u_3,	i : ι,	hi : i ∈ s,	f : Π (j : ι), α j,	a : α i,	t : Π (j : ι), α j → set (β j)	⊢ s.pi (λ (j : ι), t j (function.update f i a j)) = ({i} ∪ s \ {i}).pi (λ (j : ι), t j (function.update f i a j))
ι : Type u_1,	α : ι → Type u_2,	s : set ι,	_inst_1 : decidable_eq ι,	β : ι → Type u_3,	i : ι,	hi : i ∈ s,	f : Π (j : ι), α j,	a : α i,	t : Π (j : ι), α j → set (β j)	⊢ i ∉ s \ {i}
ι : Type u_1,	α : ι → Type u_2,	s : set ι,	_inst_1 : decidable_eq ι,	β : ι → Type u_3,	i : ι,	hi : i ∈ s,	f : Π (j : ι), α j,	a : α i,	t : Π (j : ι), α j → set (β j)	⊢ ({i} ∪ s \ {i}).pi (λ (j : ι), t j (function.update f i a j)) = {x : Π (i : ι), β i | x i ∈ t i a} ∩ (s \ {i}).pi (λ (j : ι), t j (f j))
ι : Type u_1,	α : ι → Type u_2,	s : set ι,	t : Π (i : ι), set (α i),	i : ι,	f : Π (i : ι), α i,	hi : i ∈ s,	hf : ∀ (j : ι), j ∈ s → j ≠ i → f j ∈ t j,	x : α i	⊢ x ∈ function.update f i ⁻¹' s.pi t ↔ x ∈ t i
ι : Type u_1,	α : ι → Type u_2,	s : set ι,	t : Π (i : ι), set (α i),	i : ι,	f : Π (i : ι), α i,	hi : i ∈ s,	hf : ∀ (j : ι), j ∈ s → j ≠ i → f j ∈ t j	⊢ function.update f i ⁻¹' s.pi t = t i
ι : Type u_1,	α : ι → Type u_2,	s : set ι,	t : Π (i : ι), set (α i),	i : ι,	f : Π (i : ι), α i,	hi : i ∈ s,	hf : ∀ (j : ι), j ∈ s → j ≠ i → f j ∈ t j,	x : α i,	h : x ∈ function.update f i ⁻¹' s.pi t	⊢ x ∈ t i
ι : Type u_1,	α : ι → Type u_2,	s : set ι,	t : Π (i : ι), set (α i),	i : ι,	f : Π (i : ι), α i,	hi : i ∈ s,	hf : ∀ (j : ι), j ∈ s → j ≠ i → f j ∈ t j,	x : α i,	h : x ∈ function.update f i ⁻¹' s.pi t	⊢ x = function.update f i x i
ι : Type u_1,	α : ι → Type u_2,	s : set ι,	t : Π (i : ι), set (α i),	i : ι,	f : Π (i : ι), α i,	hi : i ∈ s,	hf : ∀ (j : ι), j ∈ s → j ≠ i → f j ∈ t j,	x : α i	⊢ x ∈ function.update f i ⁻¹' s.pi t → x ∈ t i		ι : Type u_1,	α : ι → Type u_2,	s : set ι,	t : Π (i : ι), set (α i),	i : ι,	f : Π (i : ι), α i,	hi : i ∈ s,	hf : ∀ (j : ι), j ∈ s → j ≠ i → f j ∈ t j,	x : α i	⊢ x ∈ t i → x ∈ function.update f i ⁻¹' s.pi t
ι : Type u_1,	α : ι → Type u_2,	s : set ι,	t : Π (i : ι), set (α i),	i : ι,	f : Π (i : ι), α i,	hi : i ∈ s,	hf : ∀ (j : ι), j ∈ s → j ≠ i → f j ∈ t j,	x : α i	⊢ x ∈ function.update f i ⁻¹' s.pi t → x ∈ t i
ι : Type u_1,	α : ι → Type u_2,	s : set ι,	t : Π (i : ι), set (α i),	i : ι,	f : Π (i : ι), α i,	hi : i ∈ s,	hf : ∀ (j : ι), j ∈ s → j ≠ i → f j ∈ t j,	x : α i,	hx : x ∈ t i,	j : ι,	hj : j ∈ s	⊢ function.update f i x j ∈ t j
ι : Type u_1,	α : ι → Type u_2,	s : set ι,	t : Π (i : ι), set (α i),	i : ι,	f : Π (i : ι), α i,	hi : i ∈ s,	hf : ∀ (j : ι), j ∈ s → j ≠ i → f j ∈ t j,	x : α i	⊢ x ∈ t i → x ∈ function.update f i ⁻¹' s.pi t
ι : Type u_1,	α : ι → Type u_2,	s : set ι,	t : Π (i : ι), set (α i),	i : ι,	f : Π (i : ι), α i,	hi : i ∈ s,	hf : ∀ (j : ι), j ∈ s → j ≠ i → f j ∈ t j,	x : α i,	hx : x ∈ t i,	hj : i ∈ s,	h : i = i	⊢ function.update f i x i ∈ t i
ι : Type u_1,	α : ι → Type u_2,	s : set ι,	t : Π (i : ι), set (α i),	i : ι,	f : Π (i : ι), α i,	hi : i ∈ s,	hf : ∀ (j : ι), j ∈ s → j ≠ i → f j ∈ t j,	x : α i,	hx : x ∈ t i,	j : ι,	hj : j ∈ s,	h : j = i	⊢ function.update f i x j ∈ t j		ι : Type u_1,	α : ι → Type u_2,	s : set ι,	t : Π (i : ι), set (α i),	i : ι,	f : Π (i : ι), α i,	hi : i ∈ s,	hf : ∀ (j : ι), j ∈ s → j ≠ i → f j ∈ t j,	x : α i,	hx : x ∈ t i,	j : ι,	hj : j ∈ s,	h : ¬j = i	⊢ function.update f i x j ∈ t j
ι : Type u_1,	α : ι → Type u_2,	s : set ι,	t : Π (i : ι), set (α i),	i : ι,	f : Π (i : ι), α i,	hi : i ∈ s,	hf : ∀ (j : ι), j ∈ s → j ≠ i → f j ∈ t j,	x : α i,	hx : x ∈ t i,	j : ι,	hj : j ∈ s,	h : j = i	⊢ function.update f i x j ∈ t j
ι : Type u_1,	α : ι → Type u_2,	s : set ι,	t : Π (i : ι), set (α i),	i : ι,	f : Π (i : ι), α i,	hi : i ∈ s,	hf : ∀ (j : ι), j ∈ s → j ≠ i → f j ∈ t j,	x : α i,	hx : x ∈ t i,	j : ι,	hj : j ∈ s,	h : ¬j = i	⊢ f j ∈ t j
ι : Type u_1,	α : ι → Type u_2,	s : set ι,	t : Π (i : ι), set (α i),	i : ι,	f : Π (i : ι), α i,	hi : i ∈ s,	hf : ∀ (j : ι), j ∈ s → j ≠ i → f j ∈ t j,	x : α i,	hx : x ∈ t i,	j : ι,	hj : j ∈ s,	h : ¬j = i	⊢ function.update f i x j ∈ t j
α : Type u,	β : Type v,	f : α → β	⊢ function.injective (set.preimage f) ↔ function.surjective f
α : Type u,	β : Type v,	f : α → β,	h : function.injective (set.preimage f),	y : β	⊢ ∃ (a : α), f a = y
α : Type u,	β : Type v,	f : α → β,	h : function.injective (set.preimage f),	y : β	⊢ {y}.nonempty
α : Type u,	β : Type v,	f : α → β,	h : function.injective (set.preimage f),	y : β	⊢ (f ⁻¹' {y}).nonempty
α : Type u,	β : Type v,	f : α → β,	h : function.injective (set.preimage f),	y : β	⊢ (f ⁻¹' {y}).nonempty		α : Type u,	β : Type v,	f : α → β,	h : function.injective (set.preimage f),	y : β,	x : α,	hx : x ∈ f ⁻¹' {y}	⊢ ∃ (a : α), f a = y
α : Type u,	β : Type v,	f : α → β,	h : function.injective (set.preimage f),	y : β,	x : α,	hx : x ∈ f ⁻¹' {y}	⊢ ∃ (a : α), f a = y
α : Type u_1,	β : Type u_2,	γ : Type u_3,	s : set α,	t : set β,	f : α → β → γ,	ᾰ_w : α × β,	ᾰ_h_left : ᾰ_w ∈ s.prod t	⊢ (λ (x : α × β), f x.fst x.snd) ᾰ_w ∈ set.image2 f s t
α : Type u_1,	β : Type u_2,	γ : Type u_3,	s : set α,	t : set β,	f : α → β → γ,	a : γ	⊢ a ∈ (λ (x : α × β), f x.fst x.snd) '' s.prod t → a ∈ set.image2 f s t
α : Type u_1,	β : Type u_2,	γ : Type u_3,	s : set α,	t : set β,	f : α → β → γ,	ᾰ_w : α,	ᾰ_h_w : β,	ᾰ_h_h_left : ᾰ_w ∈ s,	ᾰ_h_h_right_left : ᾰ_h_w ∈ t	⊢ f ᾰ_w ᾰ_h_w ∈ (λ (x : α × β), f x.fst x.snd) '' s.prod t
α : Type u_1,	β : Type u_2,	γ : Type u_3,	s : set α,	t : set β,	f : α → β → γ,	a : γ	⊢ a ∈ set.image2 f s t → a ∈ (λ (x : α × β), f x.fst x.snd) '' s.prod t
α : Type u,	s : set α,	x : α	⊢ s ⊂ {x} ↔ s = ∅
α : Type u,	s : set α,	x : α	⊢ s = ∅ → s ≠ {x}
α : Type u,	x : α	⊢ ∅ ≠ {x}
α : Type u,	a : α,	s : set α,	_inst_1 : fintype ↥s,	h : a ∉ s	⊢ fintype.card ↥(has_insert.insert a s) = fintype.card ↥s + 1
α : Type u,	a : α,	s : set α,	_inst_1 : fintype ↥s,	h : a ∉ s	⊢ fintype.card ↥(has_insert.insert a s) = fintype.card ↥s + 1
α : Type u,	a : α,	s : set α,	_inst_1 : fintype ↥s,	h : a ∉ s	⊢ fintype.card ↥(has_insert.insert a s) = fintype.card ↥s + 1
α : Type u,	a : α,	s : set α,	_inst_1 : fintype ↥s,	h : a ∉ s	⊢ ⇑multiset.card finset.univ.val = fintype.card ↥s
α : Type u,	a : α,	s : set α,	_inst_1 : fintype ↥s,	h : a ∉ s	⊢ {val := a ::ₘ s.to_finset.val, nodup := _}.card = fintype.card ↥s + 1
α : Type u,	ι : Sort w,	_inst_1 : decidable_eq α,	f : ι → α,	_inst_2 : fintype (plift ι)	⊢ ∀ (x : α), x ∈ finset.image (f ∘ plift.down) finset.univ ↔ x ∈ set.range f
α : Type u,	ι : Sort w,	f : ι → α,	_inst_1 : fintype (plift ι)	⊢ (set.range f).finite
α : Type u,	ι : Sort w,	f : ι → α,	_inst_1 : fintype (plift ι),	_inst : decidable_eq α	⊢ (set.range f).finite
α : Type u,	ι : Sort w,	f : ι → α,	_inst_1 : fintype (plift ι),	_inst : decidable_eq α	⊢ fintype ↥(set.range f)
α : Type u,	ι : Sort w,	f : ι → α,	_inst_1 : fintype (plift ι)	⊢ (set.range f).finite
α : Type u,	s : set α,	h : s.finite	⊢ ↥(h.to_finset) = ↥s
α : Type u,	P : α → ℕ → Prop,	_inst_1 : Π (x : α), decidable_pred (P x),	b : ℕ	⊢ ∀ (y : α), nat.find_greatest (P y) b ∈ ↑(finset.range (b + 1))
α : Type u,	P : α → ℕ → Prop,	_inst_1 : Π (x : α), decidable_pred (P x),	b : ℕ,	x : α	⊢ nat.find_greatest (P x) b ∈ ↑(finset.range (b + 1))
α : Type u,	P : α → ℕ → Prop,	_inst_1 : Π (x : α), decidable_pred (P x),	b : ℕ	⊢ set.range (λ (x : α), nat.find_greatest (P x) b) ⊆ ↑(finset.range (b + 1))
α : Type u,	_inst_1 : linear_order α,	a b c : α	⊢ set.Ioc a c ∪ set.Ioc b c = set.Ioc (linear_order.min a b) c
α : Type u,	_inst_1 : linear_order α,	a b c : α	⊢ linear_order.min a c ≤ linear_order.max b c
α : Type u,	_inst_1 : linear_order α,	a b c : α	⊢ linear_order.min b c ≤ linear_order.max a c
α : Type u,	_inst_1 : linear_order α,	a b c : α	⊢ set.Ioc a c ∪ set.Ioc b c = set.Ioc (linear_order.min a b) c
α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : set.Ioo a b ⊆ s,	hc : s ⊆ set.Icc a b	⊢ s ∈ {set.Icc a b, set.Ico a b, set.Ioc a b, set.Ioo a b}
α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : set.Ioo a b ⊆ s,	hc : s ⊆ set.Icc a b,	_inst : Π (a : Prop), decidable a	⊢ s ∈ {set.Icc a b, set.Ico a b, set.Ioc a b, set.Ioo a b}
α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : set.Ioo a b ⊆ s,	hc : s ⊆ set.Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∈ s	⊢ s ∈ {set.Icc a b, set.Ico a b, set.Ioc a b, set.Ioo a b}
α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : set.Ioo a b ⊆ s,	hc : s ⊆ set.Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∉ s	⊢ s ∈ {set.Icc a b, set.Ico a b, set.Ioc a b, set.Ioo a b}
α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : set.Ioo a b ⊆ s,	hc : s ⊆ set.Icc a b,	_inst : Π (a : Prop), decidable a	⊢ s ∈ {set.Icc a b, set.Ico a b, set.Ioc a b, set.Ioo a b}
α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : set.Ioo a b ⊆ s,	hc : s ⊆ set.Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∈ s,	hb : b ∈ s	⊢ s ∈ {set.Icc a b, set.Ico a b, set.Ioc a b, set.Ioo a b}
α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : set.Ioo a b ⊆ s,	hc : s ⊆ set.Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∈ s,	hb : b ∈ s	⊢ set.Icc a b ⊆ s
α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : set.Ioo a b ⊆ s,	hc : s ⊆ set.Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∈ s,	hb : b ∈ s	⊢ s ∈ {set.Icc a b, set.Ico a b, set.Ioc a b, set.Ioo a b}		α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : set.Ioo a b ⊆ s,	hc : s ⊆ set.Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∈ s,	hb : b ∉ s	⊢ s ∈ {set.Icc a b, set.Ico a b, set.Ioc a b, set.Ioo a b}		α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : set.Ioo a b ⊆ s,	hc : s ⊆ set.Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∉ s,	hb : b ∈ s	⊢ s ∈ {set.Icc a b, set.Ico a b, set.Ioc a b, set.Ioo a b}		α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : set.Ioo a b ⊆ s,	hc : s ⊆ set.Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∉ s,	hb : b ∉ s	⊢ s ∈ {set.Icc a b, set.Ico a b, set.Ioc a b, set.Ioo a b}
α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : set.Ioo a b ⊆ s,	hc : s ⊆ set.Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∈ s,	hb : b ∉ s	⊢ s ∈ {set.Icc a b, set.Ico a b, set.Ioc a b, set.Ioo a b}
α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : set.Ioo a b ⊆ s,	hc : s ⊆ set.Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∈ s,	hb : b ∉ s	⊢ s ⊆ set.Ico a b
α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : set.Ioo a b ⊆ s,	hc : s ⊆ set.Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∈ s,	hb : b ∉ s	⊢ s ⊆ set.Ico a b		α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : set.Ioo a b ⊆ s,	hc : s ⊆ set.Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∈ s,	hb : b ∉ s	⊢ set.Ico a b ⊆ s
α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : set.Ioo a b ⊆ s,	hc : s ⊆ set.Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∈ s,	hb : b ∉ s	⊢ s ⊆ set.Icc a b \ {b}
α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : set.Ioo a b ⊆ s,	hc : s ⊆ set.Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∈ s,	hb : b ∉ s	⊢ set.Ico a b ⊆ s
α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : set.Ioo a b ⊆ s,	hc : s ⊆ set.Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∈ s,	hb : b ∉ s	⊢ s ∈ {set.Icc a b, set.Ico a b, set.Ioc a b, set.Ioo a b}		α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : set.Ioo a b ⊆ s,	hc : s ⊆ set.Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∉ s,	hb : b ∈ s	⊢ s ∈ {set.Icc a b, set.Ico a b, set.Ioc a b, set.Ioo a b}		α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : set.Ioo a b ⊆ s,	hc : s ⊆ set.Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∉ s,	hb : b ∉ s	⊢ s ∈ {set.Icc a b, set.Ico a b, set.Ioc a b, set.Ioo a b}
α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : set.Ioo a b ⊆ s,	hc : s ⊆ set.Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∉ s,	hb : b ∈ s	⊢ s ∈ {set.Icc a b, set.Ico a b, set.Ioc a b, set.Ioo a b}
α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : set.Ioo a b ⊆ s,	hc : s ⊆ set.Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∉ s,	hb : b ∈ s	⊢ s ⊆ set.Ioc a b
α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : set.Ioo a b ⊆ s,	hc : s ⊆ set.Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∉ s,	hb : b ∈ s	⊢ s ⊆ set.Ioc a b		α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : set.Ioo a b ⊆ s,	hc : s ⊆ set.Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∉ s,	hb : b ∈ s	⊢ set.Ioc a b ⊆ s
α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : set.Ioo a b ⊆ s,	hc : s ⊆ set.Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∉ s,	hb : b ∈ s	⊢ s ⊆ set.Icc a b \ {a}
α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : set.Ioo a b ⊆ s,	hc : s ⊆ set.Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∉ s,	hb : b ∈ s	⊢ set.Ioc a b ⊆ s
α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : set.Ioo a b ⊆ s,	hc : s ⊆ set.Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∉ s,	hb : b ∈ s	⊢ s ∈ {set.Icc a b, set.Ico a b, set.Ioc a b, set.Ioo a b}		α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : set.Ioo a b ⊆ s,	hc : s ⊆ set.Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∉ s,	hb : b ∉ s	⊢ s ∈ {set.Icc a b, set.Ico a b, set.Ioc a b, set.Ioo a b}
α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : set.Ioo a b ⊆ s,	hc : s ⊆ set.Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∉ s,	hb : b ∉ s	⊢ s ∈ {set.Icc a b, set.Ico a b, set.Ioc a b, set.Ioo a b}
α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : set.Ioo a b ⊆ s,	hc : s ⊆ set.Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∉ s,	hb : b ∉ s	⊢ s ⊆ set.Ioo a b
α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : set.Ioo a b ⊆ s,	hc : s ⊆ set.Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∉ s,	hb : b ∉ s	⊢ s ⊆ set.Icc a b \ {b} \ {a}
α : Type u,	_inst_1 : partial_order α,	a b x : α,	hmem : x ∈ set.Ioc a b	⊢ x = b ∨ x ∈ set.Ioo a b
α : Type u,	_inst_1 : partial_order α,	a b x : α,	hmem : x ∈ set.Ioc a b,	this : x ∈ set.Ico b a → x = b ∨ x ∈ set.Ioo b a	⊢ x = b ∨ x ∈ set.Ioo a b
α : Type u,	_inst_1 : partial_order α,	a b x : α,	hmem : x ∈ set.Ioc a b,	this : x ∈ set.Ioc a b → x = b ∨ x ∈ set.Ioo a b	⊢ x = b ∨ x ∈ set.Ioo a b
α : Type u,	_inst_1 : linear_order α,	x₁ x₂ y₁ y₂ : α,	h : disjoint (set.Ico x₁ x₂) (set.Ico y₁ y₂),	hx : x₁ < x₂,	h2 : x₂ ∈ set.Ico y₁ y₂	⊢ y₁ = x₂
α : Type u,	_inst_1 : linear_order α,	x₁ x₂ y₁ y₂ : α,	hx : x₁ < x₂,	h2 : x₂ ∈ set.Ico y₁ y₂,	h : x₂ ≤ x₁ ∨ x₂ ≤ y₁	⊢ y₁ = x₂
α : Type u,	_inst_1 : linear_order α,	x₁ x₂ y₁ y₂ : α,	hx : x₁ < x₂,	h2 : x₂ ∈ set.Ico y₁ y₂,	h : x₂ ≤ x₁ ∨ x₂ ≤ y₁	⊢ x₂ ≤ y₁
G : Type u,	_inst_1 : ordered_add_comm_group G,	a b : G	⊢ -set.Ico a b = set.Ioc (-b) (-a)
G : Type u,	_inst_1 : ordered_add_comm_group G,	a b : G	⊢ -set.Ioc a b = set.Ico (-b) (-a)
G : Type u,	_inst_1 : ordered_add_comm_group G,	a b c : G	⊢ (λ (x : G), a - x) ⁻¹' set.Ico b c = set.Ioc (a - c) (a - b)
G : Type u,	_inst_1 : ordered_add_comm_group G,	a b c : G	⊢ (λ (x : G), a + x) '' set.Icc b c = set.Icc (a + b) (a + c)
G : Type u,	_inst_1 : ordered_add_comm_group G,	a : G	⊢ has_neg.neg '' set.Iio a = set.Ioi (-a)
k : Type u,	_inst_1 : linear_ordered_field k,	a b c : k,	ha : 0 ≤ a,	hbc : b ≤ c	⊢ has_mul.mul a '' set.Icc b c = set.Icc (a * b) (a * c)
k : Type u,	_inst_1 : linear_ordered_field k,	a b c : k,	ha : 0 ≤ a,	hbc : b ≤ c	⊢ has_mul.mul a '' set.Icc b c = (λ (x : k), x * a) '' set.Icc b c
k : Type u,	_inst_1 : linear_ordered_field k,	a b c : k,	ha : 0 ≤ a,	hbc : b ≤ c	⊢ set.Icc (a * b) (a * c) = set.Icc (b * a) (c * a)
k : Type u,	_inst_1 : linear_ordered_field k,	a b c : k,	ha : 0 ≤ a,	hbc : b ≤ c	⊢ has_mul.mul a '' set.Icc b c = set.Icc (a * b) (a * c)
α : Type u_1,	_inst_1 : preorder α,	s : set α,	h : s.ord_connected	⊢ s.ord_connected
α : Type u_1,	β : Type u_2,	f : α → β,	t : set α	⊢ ∀ (x : β), x ∈ {f}.seq t ↔ x ∈ f '' t
α : Type u_1,	β : Type u_2,	s : set α,	t : set β	⊢ s.prod t = (prod.mk '' s).seq t
α : Type u_1,	β : Type u_2,	s : set α,	t : set β,	a : α,	b : β	⊢ (a, b) ∈ s.prod t ↔ (a, b) ∈ (prod.mk '' s).seq t
α : Type u_1,	β : Type u_2,	s : set α,	t : set β,	a : α,	b : β,	ha : (a, b).fst ∈ s,	hb : (a, b).snd ∈ t	⊢ (a, b) ∈ (prod.mk '' s).seq t
α : Type u_1,	β : Type u_2,	s : set α,	t : set β,	a : α,	b : β	⊢ (a, b) ∈ s.prod t → (a, b) ∈ (prod.mk '' s).seq t
α : Type u_1,	β : Type u_2,	s : set α,	t : set β,	a : α,	b : β	⊢ (a, b) ∈ s.prod t → (a, b) ∈ (prod.mk '' s).seq t		α : Type u_1,	β : Type u_2,	s : set α,	t : set β,	a : α,	b : β	⊢ (a, b) ∈ (prod.mk '' s).seq t → (a, b) ∈ s.prod t
α : Type u_1,	β : Type u_2,	s : set α,	t : set β,	a : α,	b : β,	x : α,	hx : x ∈ s,	y : β,	hy : y ∈ t,	eq : (x, y) = (a, b)	⊢ (a, b) ∈ s.prod t
α : Type u_1,	β : Type u_2,	s : set α,	t : set β,	a : α,	b : β,	x : α,	hx : x ∈ s,	y : β,	hy : y ∈ t,	eq : (x, y) = (a, b)	⊢ (x, y) ∈ s.prod t
α : Type u_1,	β : Type u_2,	s : set α,	t : set β,	a : α,	b : β	⊢ (a, b) ∈ (prod.mk '' s).seq t → (a, b) ∈ s.prod t
α : Type u_1,	s : set (set α),	f : ↥s → set α,	hf : ∀ (x : ↥s), f x ⊆ x.val,	ht : s.pairwise_disjoint,	x y : ↥s,	hxy : f x ≠ f y	⊢ disjoint (f x) (f y)
α : Type u_1,	s : set (set α),	f : ↥s → set α,	hf : ∀ (x : ↥s), f x ⊆ x.val,	ht : s.pairwise_disjoint	⊢ (set.range f).pairwise_disjoint
α : Type u_1,	s : set (set α),	f : ↥s → set α,	hf : ∀ (x : ↥s), f x ⊆ x.val,	ht : s.pairwise_disjoint,	x y : ↥s,	hxy : f x ≠ f y,	h : x.val = y.val	⊢ false
α : Type u_1,	s : set (set α),	f : ↥s → set α,	hf : ∀ (x : ↥s), f x ⊆ x.val,	ht : s.pairwise_disjoint,	x y : ↥s,	hxy : f x ≠ f y,	h : x.val = y.val	⊢ f x = f y
α : Type u_1,	s : set (set α),	f : ↥s → set α,	hf : ∀ (x : ↥s), f x ⊆ x.val,	ht : s.pairwise_disjoint,	x y : ↥s,	hxy : f x ≠ f y	⊢ x.val ≠ y.val
α : Type u_1,	s : set (set α),	f : ↥s → set α,	hf : ∀ (x : ↥s), f x ⊆ x.val,	ht : s.pairwise_disjoint,	x y : ↥s,	hxy : f x ≠ f y,	h : x.val = y.val	⊢ x = y
α : Type u_1,	β : Type u_2,	s : set α,	t : α → set β	⊢ (⋃ (i : α) (H : i ∈ s), t i)ᶜ = ⋂ (i : α) (H : i ∈ s), (t i)ᶜ
α : Type u_1,	S : set (set α)	⊢ (⋃₀ S).nonempty ↔ ∃ (s : set α) (H : s ∈ S), s.nonempty
α : Type u_1,	ι : Type u_2,	s : ι → set α,	u : set ι,	t : set α	⊢ (⋂ (i : ι) (H : i ∈ u), s i) ∪ t = ⋂ (i : ι) (H : i ∈ u), s i ∪ t
α : Type u_1,	r s : setoid α	⊢ r ⊔ s = eqv_gen.setoid (λ (x y : α), r.rel x y ∨ s.rel x y)
α : Type u_1,	r s : setoid α	⊢ r ⊔ s = has_Inf.Inf {s_1 : setoid α | ∀ ⦃x y : α⦄, r.rel x y ∨ s.rel x y → s_1.rel x y}
α : Type u_1,	r s : setoid α	⊢ {x : setoid α | r ≤ x ∧ s ≤ x} = {s_1 : setoid α | ∀ ⦃x y : α⦄, r.rel x y ∨ s.rel x y → s_1.rel x y}
α : Type u_1,	x y : subtype setoid.is_partition,	hx : x ≤ y,	hy : y ≤ x,	h : setoid.mk_classes x.val _ = setoid.mk_classes y.val _ := le_antisymm hx hy	⊢ x = y
l data : list char,	hl : l.as_string = {data := data}	⊢ string.to_list {data := data} = l
l : list char	⊢ l.as_string.to_list = l
α : Type u_1,	a₁ b₁ a₂ b₂ : α	⊢ [a₁, b₁] ~ [a₂, b₂] → a₁ = a₂ ∧ b₁ = b₂ ∨ a₁ = b₂ ∧ b₁ = a₂
α : Type u_1,	a₁ b₁ a₂ b₂ : α	⊢ [a₁, b₁] ~ [a₂, b₂] → a₁ = a₂ ∧ b₁ = b₂ ∨ a₁ = b₂ ∧ b₁ = a₂
α : Type u_1,	a₁ b₁ a₂ b₂ : α	⊢ a₁ = a₂ ∧ b₁ = b₂ ∨ ¬a₁ = a₂ ∧ b₁ = a₂ ∧ b₂ = a₁ → a₁ = a₂ ∧ b₁ = b₂ ∨ a₁ = b₂ ∧ b₁ = a₂
α : Type u_1,	a₁ b₁ a₂ b₂ : α	⊢ a₁ = a₂ ∧ b₁ = b₂ ∨ a₁ = b₂ ∧ b₁ = a₂ → [a₁, b₁] ~ [a₂, b₂]
α : Type u_1,	a₁ b₁ a₂ b₂ : α,	h : a₁ = a₂ ∧ b₁ = b₂ ∨ a₁ = b₂ ∧ b₁ = a₂	⊢ [a₁, b₁] ~ [a₂, b₂]
α : Type u_1,	a₁ b₁ a₂ b₂ : α,	h : a₁ = a₂ ∧ b₁ = b₂ ∨ a₁ = b₂ ∧ b₁ = a₂	⊢ [a₁, b₁] ~ [a₂, b₂]
α : Type u_1,	a₁ b₁ a₂ b₂ : α,	h : a₁ = a₂ ∧ b₁ = b₂	⊢ [a₁, b₁] ~ [a₂, b₂]
α : Type u_1,	a₁ b₁ a₂ b₂ : α,	h : a₁ = b₂ ∧ b₁ = a₂	⊢ [a₁, b₁] ~ [a₂, b₂]
α : Type u_1,	a₁ b₁ a₂ b₂ : α,	h : a₁ = b₂ ∧ b₁ = a₂	⊢ [b₂, a₂] ~ [a₂, b₂]
α : Type u_1,	a₁ b₁ a₂ b₂ : α,	h : a₁ = b₂ ∧ b₁ = a₂	⊢ list.nil ~ list.nil
α : Type u	⊢ equivalence (sym2.rel α)
α : Type u	⊢ equivalence (sym2.rel α)
α : Type u	⊢ equivalence (sym2.rel α)
α : Type u,	z_fst z_snd y_fst y_snd : α,	ᾰ_1 : sym2.rel α (y_fst, y_snd) (z_fst, z_snd),	x_fst x_snd : α,	ᾰ : sym2.rel α (x_fst, x_snd) (y_fst, y_snd)	⊢ sym2.rel α (x_fst, x_snd) (z_fst, z_snd)
α : Type u,	z_fst z_snd y_fst y_snd : α,	ᾰ_1 : sym2.rel α (y_fst, y_snd) (z_fst, z_snd),	x_fst x_snd : α,	ᾰ : sym2.rel α (x_fst, x_snd) (y_fst, y_snd)	⊢ sym2.rel α (x_fst, x_snd) ?m_1
α : Type u,	z_fst z_snd y_fst y_snd : α,	ᾰ_1 : sym2.rel α (y_fst, y_snd) (z_fst, z_snd),	x_fst x_snd : α,	ᾰ : sym2.rel α (x_fst, x_snd) (y_fst, y_snd)	⊢ sym2.rel α (y_fst, y_snd) (z_fst, z_snd)
ι : Type u_1,	α : ι → Type u_2,	_inst_1 : decidable_eq ι,	ext : ∀ {l : list ι}, l.nodup → ∀ {v w : list.tprod α l}, (∀ (i : ι) (hi : i ∈ l), v.elim hi = w.elim hi) → v = w,	i : ι,	is : list ι,	hl : (i :: is).nodup,	v w : list.tprod α (i :: is),	hvw : ∀ (i_1 : ι) (hi : i_1 ∈ i :: is), v.elim hi = w.elim hi,	j : ι,	hj : j ∈ is	⊢ list.tprod.elim v.snd hj = list.tprod.elim w.snd hj
ι : Type u_1,	α : ι → Type u_2,	_inst_1 : decidable_eq ι,	ext : ∀ {l : list ι}, l.nodup → ∀ {v w : list.tprod α l}, (∀ (i : ι) (hi : i ∈ l), v.elim hi = w.elim hi) → v = w,	i : ι,	is : list ι,	hl : (i :: is).nodup,	v w : list.tprod α (i :: is),	hvw : ∀ (i_1 : ι) (hi : i_1 ∈ i :: is), v.elim hi = w.elim hi	⊢ v.fst = w.fst		ι : Type u_1,	α : ι → Type u_2,	_inst_1 : decidable_eq ι,	ext : ∀ {l : list ι}, l.nodup → ∀ {v w : list.tprod α l}, (∀ (i : ι) (hi : i ∈ l), v.elim hi = w.elim hi) → v = w,	i : ι,	is : list ι,	hl : (i :: is).nodup,	v w : list.tprod α (i :: is),	hvw : ∀ (i_1 : ι) (hi : i_1 ∈ i :: is), v.elim hi = w.elim hi	⊢ v.snd = w.snd
ι : Type u_1,	α : ι → Type u_2,	_inst_1 : decidable_eq ι,	ext : ∀ {l : list ι}, l.nodup → ∀ {v w : list.tprod α l}, (∀ (i : ι) (hi : i ∈ l), v.elim hi = w.elim hi) → v = w,	i : ι,	is : list ι,	hl : (i :: is).nodup,	v w : list.tprod α (i :: is),	hvw : ∀ (i_1 : ι) (hi : i_1 ∈ i :: is), v.elim hi = w.elim hi	⊢ v = w
ι : Type u_1,	α : ι → Type u_2,	_inst_1 : decidable_eq ι,	ext : ∀ {l : list ι}, l.nodup → ∀ {v w : list.tprod α l}, (∀ (i : ι) (hi : i ∈ l), v.elim hi = w.elim hi) → v = w,	i : ι,	is : list ι,	hl : (i :: is).nodup,	v w : list.tprod α (i :: is),	hvw : ∀ (i_1 : ι) (hi : i_1 ∈ i :: is), v.elim hi = w.elim hi	⊢ v.snd = w.snd
n : ℕ,	α : typevec n,	β : typevec n,	p : α ⟹ typevec.repeat n Prop,	f : β ⟹ typevec.subtype_ p	⊢ typevec.to_subtype p ⊚ typevec.of_subtype (λ (i : fin2 n) (x : α i), p i x) ⊚ f = f
n : ℕ,	α : typevec n,	β : typevec n,	p : α ⟹ typevec.repeat n Prop,	f : β ⟹ typevec.subtype_ p	⊢ typevec.id ⊚ f = f
n : ℕ,	α : typevec n,	β : typevec n,	p : α ⟹ typevec.repeat n Prop,	f : β ⟹ typevec.subtype_ p	⊢ typevec.to_subtype p ⊚ typevec.of_subtype (λ (i : fin2 n) (x : α i), p i x) ⊚ f = f
n : ℕ,	α : Type u_1,	v_val : list α,	v_property : v_val.length = n	⊢ (vector.reverse ⟨v_val, v_property⟩).reverse = ⟨v_val, v_property⟩
n : ℕ,	α : Type u_1,	v : vector α n	⊢ v.reverse.reverse = v
n : ℕ,	α : Type u_1,	β : Type u_2,	γ : Type u_3,	C : Π {n : ℕ}, vector α n → vector β n → vector γ n → Sort ?,	u : vector α n,	v : vector β n,	w : vector γ n,	h_nil : C vector.nil vector.nil vector.nil,	h_cons : Π {n : ℕ} {a : α} {b : β} {c : γ} {x : vector α n} {y : vector β n} {z : vector γ n}, C x y z → C (a::ᵥ x) (b::ᵥ y) (c::ᵥ z)	⊢ C u v w
α : Type u_1,	β : Type u_2,	γ : Type u_3,	C : Π {n : ℕ}, vector α n → vector β n → vector γ n → Sort ?,	h_nil : C vector.nil vector.nil vector.nil,	h_cons : Π {n : ℕ} {a : α} {b : β} {c : γ} {x : vector α n} {y : vector β n} {z : vector γ n}, C x y z → C (a::ᵥ x) (b::ᵥ y) (c::ᵥ z),	v : vector β 0,	w : vector γ 0,	u_property : list.nil.length = 0	⊢ C ⟨list.nil α, u_property⟩ v w
α : Type u_1,	β : Type u_2,	γ : Type u_3,	C : Π {n : ℕ}, vector α n → vector β n → vector γ n → Sort ?,	h_nil : C vector.nil vector.nil vector.nil,	h_cons : Π {n : ℕ} {a : α} {b : β} {c : γ} {x : vector α n} {y : vector β n} {z : vector γ n}, C x y z → C (a::ᵥ x) (b::ᵥ y) (c::ᵥ z),	u : vector α 0,	v : vector β 0,	w : vector γ 0	⊢ C u v w
α : Type u_1,	β : Type u_2,	γ : Type u_3,	C : Π {n : ℕ}, vector α n → vector β n → vector γ n → Sort ?,	h_nil : C vector.nil vector.nil vector.nil,	h_cons : Π {n : ℕ} {a : α} {b : β} {c : γ} {x : vector α n} {y : vector β n} {z : vector γ n}, C x y z → C (a::ᵥ x) (b::ᵥ y) (c::ᵥ z),	w : vector γ 0,	u_property : list.nil.length = 0,	v_property : list.nil.length = 0	⊢ C ⟨list.nil α, u_property⟩ ⟨list.nil β, v_property⟩ w
α : Type u_1,	β : Type u_2,	γ : Type u_3,	C : Π {n : ℕ}, vector α n → vector β n → vector γ n → Sort ?,	h_nil : C vector.nil vector.nil vector.nil,	h_cons : Π {n : ℕ} {a : α} {b : β} {c : γ} {x : vector α n} {y : vector β n} {z : vector γ n}, C x y z → C (a::ᵥ x) (b::ᵥ y) (c::ᵥ z),	u : vector α 0,	v : vector β 0,	w : vector γ 0	⊢ C u v w		case nat.succ	α : Type u_1,	β : Type u_2,	γ : Type u_3,	C : Π {n : ℕ}, vector α n → vector β n → vector γ n → Sort ?,	h_nil : C vector.nil vector.nil vector.nil,	h_cons : Π {n : ℕ} {a : α} {b : β} {c : γ} {x : vector α n} {y : vector β n} {z : vector γ n}, C x y z → C (a::ᵥ x) (b::ᵥ y) (c::ᵥ z),	n : ℕ,	ih : Π (u : vector α n) (v : vector β n) (w : vector γ n), C u v w,	u : vector α n.succ,	v : vector β n.succ,	w : vector γ n.succ	⊢ C u v w
α : Type u_1,	β : Type u_2,	γ : Type u_3,	C : Π {n : ℕ}, vector α n → vector β n → vector γ n → Sort ?,	h_nil : C vector.nil vector.nil vector.nil,	h_cons : Π {n : ℕ} {a : α} {b : β} {c : γ} {x : vector α n} {y : vector β n} {z : vector γ n}, C x y z → C (a::ᵥ x) (b::ᵥ y) (c::ᵥ z),	u_property : list.nil.length = 0,	v_property : list.nil.length = 0,	w_property : list.nil.length = 0	⊢ C ⟨list.nil α, u_property⟩ ⟨list.nil β, v_property⟩ ⟨list.nil γ, w_property⟩
α : Type u_1,	β : Type u_2,	γ : Type u_3,	C : Π {n : ℕ}, vector α n → vector β n → vector γ n → Sort ?,	h_nil : C vector.nil vector.nil vector.nil,	h_cons : Π {n : ℕ} {a : α} {b : β} {c : γ} {x : vector α n} {y : vector β n} {z : vector γ n}, C x y z → C (a::ᵥ x) (b::ᵥ y) (c::ᵥ z),	n : ℕ,	ih : Π (u : vector α n) (v : vector β n) (w : vector γ n), C u v w,	u : vector α n.succ,	v : vector β n.succ,	w : vector γ n.succ	⊢ C u v w
α : Type u_1,	β : Type u_2,	γ : Type u_3,	C : Π {n : ℕ}, vector α n → vector β n → vector γ n → Sort ?,	h_nil : C vector.nil vector.nil vector.nil,	h_cons : Π {n : ℕ} {a : α} {b : β} {c : γ} {x : vector α n} {y : vector β n} {z : vector γ n}, C x y z → C (a::ᵥ x) (b::ᵥ y) (c::ᵥ z),	n : ℕ,	ih : Π (u : vector α n) (v : vector β n) (w : vector γ n), C u v w,	v : vector β n.succ,	w : vector γ n.succ,	u_property : list.nil.length = n.succ	⊢ C ⟨list.nil α, u_property⟩ v w		α : Type u_1,	β : Type u_2,	γ : Type u_3,	C : Π {n : ℕ}, vector α n → vector β n → vector γ n → Sort ?,	h_nil : C vector.nil vector.nil vector.nil,	h_cons : Π {n : ℕ} {a : α} {b : β} {c : γ} {x : vector α n} {y : vector β n} {z : vector γ n}, C x y z → C (a::ᵥ x) (b::ᵥ y) (c::ᵥ z),	n : ℕ,	ih : Π (u : vector α n) (v : vector β n) (w : vector γ n), C u v w,	v : vector β n.succ,	w : vector γ n.succ,	a : α,	u : list α,	u_property : (a :: u).length = n.succ	⊢ C ⟨a :: u, u_property⟩ v w
α : Type u_1,	β : Type u_2,	γ : Type u_3,	C : Π {n : ℕ}, vector α n → vector β n → vector γ n → Sort ?,	h_nil : C vector.nil vector.nil vector.nil,	h_cons : Π {n : ℕ} {a : α} {b : β} {c : γ} {x : vector α n} {y : vector β n} {z : vector γ n}, C x y z → C (a::ᵥ x) (b::ᵥ y) (c::ᵥ z),	n : ℕ,	ih : Π (u : vector α n) (v : vector β n) (w : vector γ n), C u v w,	v : vector β n.succ,	w : vector γ n.succ,	a : α,	u : list α,	u_property : (a :: u).length = n.succ	⊢ C ⟨a :: u, u_property⟩ v w
α : Type u_1,	β : Type u_2,	γ : Type u_3,	C : Π {n : ℕ}, vector α n → vector β n → vector γ n → Sort ?,	h_nil : C vector.nil vector.nil vector.nil,	h_cons : Π {n : ℕ} {a : α} {b : β} {c : γ} {x : vector α n} {y : vector β n} {z : vector γ n}, C x y z → C (a::ᵥ x) (b::ᵥ y) (c::ᵥ z),	n : ℕ,	ih : Π (u : vector α n) (v : vector β n) (w : vector γ n), C u v w,	w : vector γ n.succ,	a : α,	u : list α,	u_property : (a :: u).length = n.succ,	v_property : list.nil.length = n.succ	⊢ C ⟨a :: u, u_property⟩ ⟨list.nil β, v_property⟩ w		α : Type u_1,	β : Type u_2,	γ : Type u_3,	C : Π {n : ℕ}, vector α n → vector β n → vector γ n → Sort ?,	h_nil : C vector.nil vector.nil vector.nil,	h_cons : Π {n : ℕ} {a : α} {b : β} {c : γ} {x : vector α n} {y : vector β n} {z : vector γ n}, C x y z → C (a::ᵥ x) (b::ᵥ y) (c::ᵥ z),	n : ℕ,	ih : Π (u : vector α n) (v : vector β n) (w : vector γ n), C u v w,	w : vector γ n.succ,	a : α,	u : list α,	u_property : (a :: u).length = n.succ,	b : β,	v : list β,	v_property : (b :: v).length = n.succ	⊢ C ⟨a :: u, u_property⟩ ⟨b :: v, v_property⟩ w
α : Type u_1,	β : Type u_2,	γ : Type u_3,	C : Π {n : ℕ}, vector α n → vector β n → vector γ n → Sort ?,	h_nil : C vector.nil vector.nil vector.nil,	h_cons : Π {n : ℕ} {a : α} {b : β} {c : γ} {x : vector α n} {y : vector β n} {z : vector γ n}, C x y z → C (a::ᵥ x) (b::ᵥ y) (c::ᵥ z),	n : ℕ,	ih : Π (u : vector α n) (v : vector β n) (w : vector γ n), C u v w,	w : vector γ n.succ,	a : α,	u : list α,	u_property : (a :: u).length = n.succ,	b : β,	v : list β,	v_property : (b :: v).length = n.succ	⊢ C ⟨a :: u, u_property⟩ ⟨b :: v, v_property⟩ w
α : Type u_1,	β : Type u_2,	γ : Type u_3,	C : Π {n : ℕ}, vector α n → vector β n → vector γ n → Sort ?,	h_nil : C vector.nil vector.nil vector.nil,	h_cons : Π {n : ℕ} {a : α} {b : β} {c : γ} {x : vector α n} {y : vector β n} {z : vector γ n}, C x y z → C (a::ᵥ x) (b::ᵥ y) (c::ᵥ z),	n : ℕ,	ih : Π (u : vector α n) (v : vector β n) (w : vector γ n), C u v w,	a : α,	u : list α,	u_property : (a :: u).length = n.succ,	b : β,	v : list β,	v_property : (b :: v).length = n.succ,	w_property : list.nil.length = n.succ	⊢ C ⟨a :: u, u_property⟩ ⟨b :: v, v_property⟩ ⟨list.nil γ, w_property⟩		α : Type u_1,	β : Type u_2,	γ : Type u_3,	C : Π {n : ℕ}, vector α n → vector β n → vector γ n → Sort ?,	h_nil : C vector.nil vector.nil vector.nil,	h_cons : Π {n : ℕ} {a : α} {b : β} {c : γ} {x : vector α n} {y : vector β n} {z : vector γ n}, C x y z → C (a::ᵥ x) (b::ᵥ y) (c::ᵥ z),	n : ℕ,	ih : Π (u : vector α n) (v : vector β n) (w : vector γ n), C u v w,	a : α,	u : list α,	u_property : (a :: u).length = n.succ,	b : β,	v : list β,	v_property : (b :: v).length = n.succ,	c : γ,	w : list γ,	w_property : (c :: w).length = n.succ	⊢ C ⟨a :: u, u_property⟩ ⟨b :: v, v_property⟩ ⟨c :: w, w_property⟩
α : Type u_1,	β : Type u_2,	γ : Type u_3,	C : Π {n : ℕ}, vector α n → vector β n → vector γ n → Sort ?,	h_nil : C vector.nil vector.nil vector.nil,	h_cons : Π {n : ℕ} {a : α} {b : β} {c : γ} {x : vector α n} {y : vector β n} {z : vector γ n}, C x y z → C (a::ᵥ x) (b::ᵥ y) (c::ᵥ z),	n : ℕ,	ih : Π (u : vector α n) (v : vector β n) (w : vector γ n), C u v w,	a : α,	u : list α,	u_property : (a :: u).length = n.succ,	b : β,	v : list β,	v_property : (b :: v).length = n.succ,	c : γ,	w : list γ,	w_property : (c :: w).length = n.succ	⊢ C ⟨a :: u, u_property⟩ ⟨b :: v, v_property⟩ ⟨c :: w, w_property⟩
α : Type u_1,	β : Type u_2,	γ : Type u_3,	C : Π {n : ℕ}, vector α n → vector β n → vector γ n → Sort ?,	h_nil : C vector.nil vector.nil vector.nil,	h_cons : Π {n : ℕ} {a : α} {b : β} {c : γ} {x : vector α n} {y : vector β n} {z : vector γ n}, C x y z → C (a::ᵥ x) (b::ᵥ y) (c::ᵥ z),	n : ℕ,	ih : Π (u : vector α n) (v : vector β n) (w : vector γ n), C u v w,	a : α,	u : list α,	u_property : (a :: u).length = n.succ,	b : β,	v : list β,	v_property : (b :: v).length = n.succ,	c : γ,	w : list γ,	w_property : (c :: w).length = n.succ	⊢ C ⟨u, _⟩ ⟨v, _⟩ ⟨w, _⟩
n : ℕ,	_inst_1 : fact (0 < n),	a : zmod n	⊢ a.val < n
_inst_1 : fact (0 < 0),	a : zmod 0	⊢ false
_inst_1 : fact (0 < 0),	a : zmod 0	⊢ a.val < 0		n : ℕ,	_inst_1 : fact (0 < n.succ),	a : zmod n.succ	⊢ a.val < n.succ
_inst_1 : fact (0 < 0),	a : zmod 0	⊢ a.val < 0
n : ℕ,	_inst_1 : fact (0 < n.succ),	a : zmod n.succ	⊢ a.val < n.succ
n : ℕ,	hn : fact (n % 2 = 1),	a : zmod n,	ha : a ≠ 0,	h : a = -a,	this : a.val ≤ n / 2 ↔ n / 2 < (-a).val	⊢ false
n : ℕ,	_inst_1 : fact (0 < n),	x : zmod n	⊢ x.val_min_abs = ite (x.val ≤ n / 2) ↑(x.val) (↑(x.val) - ↑n)
_inst_1 : fact (0 < 0),	x : zmod 0	⊢ false
_inst_1 : fact (0 < 0),	x : zmod 0	⊢ x.val_min_abs = ite (x.val ≤ 0 / 2) ↑(x.val) (↑(x.val) - ↑0)		n : ℕ,	_inst_1 : fact (0 < n.succ),	x : zmod n.succ	⊢ x.val_min_abs = ite (x.val ≤ n.succ / 2) ↑(x.val) (↑(x.val) - ↑(n.succ))
_inst_1 : fact (0 < 0),	x : zmod 0	⊢ x.val_min_abs = ite (x.val ≤ 0 / 2) ↑(x.val) (↑(x.val) - ↑0)
n : ℕ,	_inst_1 : fact (0 < n.succ),	x : zmod n.succ	⊢ x.val_min_abs = ite (x.val ≤ n.succ / 2) ↑(x.val) (↑(x.val) - ↑(n.succ))
F : Type u_1,	_inst_1 : field F,	S : set F	⊢ ∀ {a b : F}, a ∈ field.closure S → b ∈ field.closure S → a * b ∈ field.closure S
F : Type u_1,	_inst_1 : field F,	S : set F	⊢ ∀ {a b : F}, a ∈ field.closure S → b ∈ field.closure S → a * b ∈ field.closure S
F : Type u_1,	_inst_1 : field F,	S : set F,	p : F,	hp : p ∈ ring.closure S,	q : F,	hq : q ∈ ring.closure S,	ᾰ_h_h_h_h : p / q = field.div p q,	r : F,	hr : r ∈ ring.closure S,	s : F,	hs : s ∈ ring.closure S,	ᾰ_1_h_h_h_h : r / s = field.div r s	⊢ field.div p q * field.div r s ∈ field.closure S
f : circle_deg1_lift,	coe_pow : ∀ (n : ℕ), ⇑(f ^ n) = (⇑f^[n]),	n : ℕ	⊢ ⇑(f ^ (n + 1)) = (⇑f^[n + 1])
f : circle_deg1_lift,	coe_pow : ∀ (n : ℕ), ⇑(f ^ n) = (⇑f^[n]),	n : ℕ,	x : ℝ	⊢ ⇑(f ^ (n + 1)) x = ⇑f^[n + 1] x
f g : circle_deg1_lift	⊢ has_dist.dist (⇑f 0 + ⇑g 0) (⇑f (⇑g 0)) < 1
f g : circle_deg1_lift	⊢ ⇑f 0 + ⇑g 0 - 1 < ⇑f (⇑g 0) ∧ ⇑f (⇑g 0) < ⇑f 0 + ⇑g 0 + 1
f : circle_deg1_lift,	n : ℕ	⊢ has_dist.dist (f.transnum_aux_seq n) (f.transnum_aux_seq (n + 1)) < 1 / 2 / 2 ^ n
f : circle_deg1_lift,	n : ℕ,	this : 0 < 2 ^ (n + 1)	⊢ has_dist.dist (f.transnum_aux_seq n) (f.transnum_aux_seq (n + 1)) < 1 / 2 / 2 ^ n
f : circle_deg1_lift,	n : ℕ,	this : 0 < 2 ^ (n + 1)	⊢ has_dist.dist (f.transnum_aux_seq n) (f.transnum_aux_seq (n + 1)) < 1 / abs (2 ^ (n + 1))
f : circle_deg1_lift,	n : ℕ,	this : 0 < abs (2 ^ (n + 1))	⊢ has_dist.dist (f.transnum_aux_seq n) (f.transnum_aux_seq (n + 1)) < 1 / abs (2 ^ (n + 1))
f : circle_deg1_lift,	n : ℕ,	this : 0 < abs (2 ^ (n + 1))	⊢ has_dist.dist (f.transnum_aux_seq n) (f.transnum_aux_seq (n + 1)) = has_dist.dist (⇑(f ^ 2 ^ n) 0 + ⇑(f ^ 2 ^ n) 0) (⇑(f ^ 2 ^ n) (⇑(f ^ 2 ^ n) 0)) / abs (2 ^ (n + 1))
f : circle_deg1_lift,	n : ℕ,	this : 0 < abs (2 ^ (n + 1))	⊢ abs (⇑(f ^ 2 ^ n) 0 / 2 ^ n - ⇑(f ^ 2 ^ (n + 1)) 0 / 2 ^ (n + 1)) = abs (⇑(f ^ 2 ^ n) 0 + ⇑(f ^ 2 ^ n) 0 - ⇑(f ^ 2 ^ n) (⇑(f ^ 2 ^ n) 0)) / abs (2 ^ (n + 1))
f : circle_deg1_lift	⊢ filter.tendsto (λ (n : ℕ), ⇑(f ^ (n + 1)) 0 / (↑n + 1)) filter.at_top (𝓝 f.translation_number)
f : circle_deg1_lift,	n : ℕ	⊢ has_dist.dist (⇑(f ^ (n + 1)) 0 / (↑n + 1)) f.translation_number ≤ ((λ (n : ℕ), 1 / ↑n) ∘ λ (a : ℕ), a + 1) n
f : circle_deg1_lift,	n : ℕ	⊢ has_dist.dist (⇑(f ^ (n + 1)) 0 / (↑n + 1)) f.translation_number ≤ 1 / (↑n + 1)
f : circle_deg1_lift,	n : ℕ,	this : 0 < ↑n + 1	⊢ has_dist.dist (⇑(f ^ (n + 1)) 0 / (↑n + 1)) f.translation_number ≤ 1 / (↑n + 1)
f : circle_deg1_lift,	n : ℕ,	this : 0 < ↑n + 1	⊢ has_dist.dist (⇑(f ^ (n + 1)) 0) (↑(n + 1) * f.translation_number) ≤ 1
α : Type u_2,	_inst_1 : measurable_space α,	f : α → α,	s : set α,	μ : measure_theory.measure α,	hf : measure_theory.conservative f μ,	hs : measurable_set s	⊢ ∀ᵐ (x : α) ∂μ, x ∈ s → (∃ᶠ (n : ℕ) in filter.at_top, f^[n] x ∈ s)
α : Type u_2,	_inst_1 : measurable_space α,	f : α → α,	s : set α,	μ : measure_theory.measure α,	hf : measure_theory.conservative f μ,	hs : measurable_set s	⊢ ∀ (i : ℕ), ∀ᵐ (a : α) ∂μ, a ∈ s → (∃ (b : ℕ) (H : b ≥ i), f^[b] a ∈ s)
α : Type u_2,	_inst_1 : measurable_space α,	f : α → α,	s : set α,	μ : measure_theory.measure α,	hf : measure_theory.conservative f μ,	hs : measurable_set s,	n : ℕ	⊢ ∀ᵐ (a : α) ∂μ, a ∈ s → (∃ (b : ℕ) (H : b ≥ n), f^[b] a ∈ s)
α : Type u_2,	_inst_1 : measurable_space α,	f : α → α,	s : set α,	μ : measure_theory.measure α,	hf : measure_theory.conservative f μ,	hs : measurable_set s,	n : ℕ	⊢ ∀ (a : α), a ∉ {x ∈ s | ∀ (m : ℕ), m ≥ n → f^[m] x ∉ s} → a ∈ s → (∃ (b : ℕ) (H : b ≥ n), f^[b] a ∈ s)
α : Type u_1,	β : Type u_2,	γ : Type u_3,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	_inst_3 : measurable_space γ,	μa : measure_theory.measure α,	μb : measure_theory.measure β,	μc : measure_theory.measure γ,	g : β → γ,	f : α → β,	hg : measure_theory.measure_preserving g μb μc,	hf : measure_theory.measure_preserving f μa μb	⊢ ⇑(measure_theory.measure.map (g ∘ f)) μa = μc
τ : Type u_1,	_inst_1 : topological_space τ,	_inst_2 : add_comm_group τ,	_inst_3 : topological_add_group τ,	α : Type u_2,	_inst_4 : topological_space α,	f : filter τ,	ϕ : flow τ α,	s : set α,	hf : ∀ (t : τ), filter.tendsto (λ (_x : τ), _x + t) f f,	t : τ	⊢ ω f ⇑ϕ s = ω f ⇑ϕ (⇑ϕ (-t) '' (⇑ϕ t '' s))
α : Type u_1,	f : α → α,	x : α,	p k : ℕ,	hp : fact (nat.prime p),	hk : ¬function.is_periodic_pt f (p ^ k) x,	hk1 : function.is_periodic_pt f (p ^ (k + 1)) x	⊢ function.minimal_period f x = p ^ (k + 1)
α : Type u_1,	f : α → α,	x : α,	p k : ℕ,	hp : fact (nat.prime p),	hk : ¬function.is_periodic_pt f (p ^ k) x,	hk1 : function.is_periodic_pt f (p ^ (k + 1)) x	⊢ function.minimal_period f x = p ^ (k + 1)
α : Type u_1,	f : α → α,	x : α,	p k : ℕ,	hp : fact (nat.prime p),	hk : ¬function.is_periodic_pt f (p ^ k) x,	hk1 : function.is_periodic_pt f (p ^ (k + 1)) x	⊢ ¬function.minimal_period f x ∣ p ^ k
α : Type u_1,	f : α → α,	x : α,	p k : ℕ,	hp : fact (nat.prime p),	hk : ¬function.is_periodic_pt f (p ^ k) x,	hk1 : function.is_periodic_pt f (p ^ (k + 1)) x	⊢ function.minimal_period f x ∣ p ^ (k + 1)
F : Type u_1,	_inst_1 : field F,	x : F	⊢ is_solvable (⇑polynomial.C x).gal
F : Type u_1,	_inst_1 : field F,	E : Type u_2,	_inst_2 : field E,	_inst_3 : algebra F E,	S : set E	⊢ set.range ⇑(algebra_map F E) ⊆ ↑(intermediate_field.adjoin F S)
F : Type u_1,	_inst_1 : field F,	E : Type u_2,	_inst_2 : field E,	_inst_3 : algebra F E,	S : set E,	x : E,	hx : x ∈ set.range ⇑(algebra_map F E)	⊢ x ∈ ↑(intermediate_field.adjoin F S)
F : Type u_1,	_inst_1 : field F,	E : Type u_2,	_inst_2 : field E,	_inst_3 : algebra F E,	S : set E,	x : E,	f : F,	hf : ⇑(algebra_map F E) f = x	⊢ x ∈ ↑(intermediate_field.adjoin F S)
F : Type u_1,	_inst_1 : field F,	E : Type u_2,	_inst_2 : field E,	_inst_3 : algebra F E,	S : set E,	x : E,	f : F,	hf : ⇑(algebra_map F E) f = x	⊢ ⇑(algebra_map F E) f ∈ ↑(intermediate_field.adjoin F S)
p : ℕ,	_inst_4 : fact (nat.prime p),	x : zmod p,	h : x ^ fintype.card (zmod p) = x	⊢ x ^ p = x
p : ℕ,	_inst_4 : fact (nat.prime p),	x : zmod p	⊢ x ^ p = x
p : ℕ,	_inst_4 : fact (nat.prime p),	f : polynomial (zmod p),	h : ⇑(polynomial.expand (zmod p) (fintype.card (zmod p))) f = f ^ fintype.card (zmod p)	⊢ ⇑(polynomial.expand (zmod p) p) f = f ^ p
p : ℕ,	_inst_4 : fact (nat.prime p),	f : polynomial (zmod p)	⊢ ⇑(polynomial.expand (zmod p) p) f = f ^ p
σ K : Type u,	_inst_1 : fintype σ,	_inst_2 : field K,	_inst_3 : fintype K	⊢ module.rank K (mv_polynomial.R σ K) < ω
G : Type u,	_inst_2 : group G,	F : Type v,	_inst_3 : field F,	_inst_5 : mul_semiring_action G F,	_inst_6 : fintype G,	x : F	⊢ (prod_X_sub_smul G F x).monic
G : Type u,	_inst_2 : group G,	F : Type v,	_inst_3 : field F,	_inst_5 : mul_semiring_action G F,	_inst_6 : fintype G,	x : F	⊢ (fixed_points.minpoly G F x).monic
M : Type u,	_inst_1 : monoid M,	F : Type v,	_inst_3 : field F,	_inst_4 : mul_semiring_action M F,	g : M,	x : F,	hx : x ∈ fixed_points.subfield M F,	g' : M	⊢ g' • g • x = g • x
F : Type u_1,	_inst_1 : field F,	E : Type u_2,	_inst_2 : field E,	_inst_3 : algebra F E,	K : intermediate_field F E,	_x : ↥(K.fixing_subgroup)	⊢ (λ (ϕ : E ≃ₐ[↥K] E), ⟨alg_equiv.of_bijective {to_fun := ⇑ϕ, map_one' := _, map_mul' := _, map_zero' := _, map_add' := _, commutes' := _} _, _⟩) ((λ (ϕ : ↥(K.fixing_subgroup)), alg_equiv.of_bijective {to_fun := ⇑ϕ, map_one' := _, map_mul' := _, map_zero' := _, map_add' := _, commutes' := _} _) _x) = _x
F : Type u_1,	_inst_1 : field F,	E : Type u_2,	_inst_2 : field E,	_inst_3 : algebra F E,	K : intermediate_field F E,	_x : ↥(K.fixing_subgroup),	a : E	⊢ ⇑↑((λ (ϕ : E ≃ₐ[↥K] E), ⟨alg_equiv.of_bijective {to_fun := ⇑ϕ, map_one' := _, map_mul' := _, map_zero' := _, map_add' := _, commutes' := _} _, _⟩) ((λ (ϕ : ↥(K.fixing_subgroup)), alg_equiv.of_bijective {to_fun := ⇑ϕ, map_one' := _, map_mul' := _, map_zero' := _, map_add' := _, commutes' := _} _) _x)) a = ⇑↑_x a
F : Type u_1,	_inst_1 : field F,	E : Type u_2,	_inst_2 : field E,	_inst_3 : algebra F E,	K : intermediate_field F E,	_x : E ≃ₐ[↥K] E	⊢ (λ (ϕ : ↥(K.fixing_subgroup)), alg_equiv.of_bijective {to_fun := ⇑ϕ, map_one' := _, map_mul' := _, map_zero' := _, map_add' := _, commutes' := _} _) ((λ (ϕ : E ≃ₐ[↥K] E), ⟨alg_equiv.of_bijective {to_fun := ⇑ϕ, map_one' := _, map_mul' := _, map_zero' := _, map_add' := _, commutes' := _} _, _⟩) _x) = _x
F : Type u_1,	_inst_1 : field F,	E : Type u_2,	_inst_2 : field E,	_inst_3 : algebra F E,	K : intermediate_field F E,	_x : E ≃ₐ[↥K] E,	a : E	⊢ ⇑((λ (ϕ : ↥(K.fixing_subgroup)), alg_equiv.of_bijective {to_fun := ⇑ϕ, map_one' := _, map_mul' := _, map_zero' := _, map_add' := _, commutes' := _} _) ((λ (ϕ : E ≃ₐ[↥K] E), ⟨alg_equiv.of_bijective {to_fun := ⇑ϕ, map_one' := _, map_mul' := _, map_zero' := _, map_add' := _, commutes' := _} _, _⟩) _x)) a = ⇑_x a
F : Type u_1,	_inst_1 : field F,	E : Type u_2,	_inst_2 : field E,	_inst_3 : algebra F E,	K : intermediate_field F E,	_x _x : ↥(K.fixing_subgroup)	⊢ alg_equiv.of_bijective {to_fun := ⇑(_x * _x), map_one' := _, map_mul' := _, map_zero' := _, map_add' := _, commutes' := _} _ = alg_equiv.of_bijective {to_fun := ⇑_x, map_one' := _, map_mul' := _, map_zero' := _, map_add' := _, commutes' := _} _ * alg_equiv.of_bijective {to_fun := ⇑_x, map_one' := _, map_mul' := _, map_zero' := _, map_add' := _, commutes' := _} _
F : Type u_1,	_inst_1 : field F,	E : Type u_2,	_inst_2 : field E,	_inst_3 : algebra F E,	K : intermediate_field F E,	_x _x : ↥(K.fixing_subgroup),	a : E	⊢ ⇑(alg_equiv.of_bijective {to_fun := ⇑(_x * _x), map_one' := _, map_mul' := _, map_zero' := _, map_add' := _, commutes' := _} _) a = ⇑(alg_equiv.of_bijective {to_fun := ⇑_x, map_one' := _, map_mul' := _, map_zero' := _, map_add' := _, commutes' := _} _ * alg_equiv.of_bijective {to_fun := ⇑_x, map_one' := _, map_mul' := _, map_zero' := _, map_add' := _, commutes' := _} _) a
F : Type u_1,	_inst_1 : field F,	E : Type u_2,	_inst_2 : field E,	_inst_3 : algebra F E,	_inst_4 : finite_dimensional F E,	_inst_5 : is_galois F E	⊢ ∃ (p : polynomial F), p.separable ∧ polynomial.is_splitting_field F E p
F : Type u_1,	_inst_1 : field F,	E : Type u_2,	_inst_2 : field E,	_inst_3 : algebra F E,	_inst_4 : finite_dimensional F E,	_inst_5 : is_galois F E,	α : E,	h1 : F⟮α⟯ = ⊤	⊢ ∃ (p : polynomial F), p.separable ∧ polynomial.is_splitting_field F E p
F : Type u_1,	_inst_1 : field F,	E : Type u_2,	_inst_2 : field E,	_inst_3 : algebra F E,	_inst_4 : finite_dimensional F E,	_inst_5 : is_galois F E,	α : E,	h1 : F⟮α⟯ = ⊤	⊢ algebra.adjoin F ↑((polynomial.map (algebra_map F E) (minpoly F α)).roots.to_finset) = ⊤
F : Type u_1,	_inst_1 : field F,	E : Type u_2,	_inst_2 : field E,	_inst_3 : algebra F E,	_inst_4 : finite_dimensional F E,	_inst_5 : is_galois F E,	α : E,	h1 : F⟮α⟯ = ⊤	⊢ F⟮α⟯.to_subalgebra ≤ algebra.adjoin F ↑((polynomial.map (algebra_map F E) (minpoly F α)).roots.to_finset)
F : Type u_1,	_inst_1 : field F,	E : Type u_2,	_inst_2 : field E,	_inst_3 : algebra F E,	_inst_4 : finite_dimensional F E,	_inst_5 : is_galois F E,	α : E,	h1 : F⟮α⟯ = ⊤	⊢ algebra.adjoin F {α} ≤ algebra.adjoin F ↑((polynomial.map (algebra_map F E) (minpoly F α)).roots.to_finset)
F : Type u_1,	_inst_1 : field F,	E : Type u_2,	_inst_2 : field E,	_inst_3 : algebra F E,	_inst_4 : finite_dimensional F E,	_inst_5 : is_galois F E,	α : E,	h1 : F⟮α⟯ = ⊤	⊢ {α} ⊆ ↑((polynomial.map (algebra_map F E) (minpoly F α)).roots.to_finset)
F : Type u_1,	_inst_1 : field F,	E : Type u_2,	_inst_2 : field E,	_inst_3 : algebra F E,	_inst_4 : finite_dimensional F E,	_inst_5 : is_galois F E,	α : E,	h1 : F⟮α⟯ = ⊤	⊢ (polynomial.map (algebra_map F E) (minpoly F α)).is_root α
F : Type u_1,	_inst_1 : field F,	E : Type u_2,	_inst_2 : field E,	_inst_3 : algebra F E,	_inst_4 : finite_dimensional F E,	_inst_5 : is_galois F E,	α : E,	h1 : F⟮α⟯ = ⊤	⊢ polynomial.eval α (polynomial.map (algebra_map F E) (minpoly F α)) = 0
F : Type u_1,	_inst_1 : field F,	E : Type u_2,	_inst_2 : field E,	_inst_3 : algebra F E,	_inst_4 : finite_dimensional F E,	_inst_5 : is_galois F E,	α : E,	h1 : F⟮α⟯ = ⊤	⊢ (polynomial.map (algebra_map F E) (minpoly F α)).is_root α		F : Type u_1,	_inst_1 : field F,	E : Type u_2,	_inst_2 : field E,	_inst_3 : algebra F E,	_inst_4 : finite_dimensional F E,	_inst_5 : is_galois F E,	α : E,	h1 : F⟮α⟯ = ⊤	⊢ polynomial.map (algebra_map F E) (minpoly F α) ≠ 0
F : Type u_1,	_inst_1 : field F,	E : Type u_2,	_inst_2 : field E,	_inst_3 : algebra F E,	_inst_4 : finite_dimensional F E,	_inst_5 : is_galois F E,	α : E,	h1 : F⟮α⟯ = ⊤	⊢ ⇑(polynomial.aeval α) (minpoly F α) = 0
F : Type u_1,	_inst_1 : field F,	E : Type u_2,	_inst_2 : field E,	_inst_3 : algebra F E,	_inst_4 : finite_dimensional F E,	_inst_5 : is_galois F E,	α : E,	h1 : F⟮α⟯ = ⊤	⊢ polynomial.map (algebra_map F E) (minpoly F α) ≠ 0
K : Type u_1,	L : Type u_2,	_inst_1 : field K,	_inst_2 : field L,	_inst_3 : algebra K L,	S : intermediate_field K L,	n : ℤ	⊢ ↑n ∈ S
A : Type u_1,	K : Type u_2,	R : Type u_3,	_inst_4 : comm_ring A,	_inst_5 : field K,	_inst_6 : comm_ring R,	_inst_7 : algebra A K,	_inst_8 : algebra A R,	_inst_9 : algebra K R,	_inst_10 : is_scalar_tower A K R,	x : R	⊢ ⇑(polynomial.aeval x) (polynomial.map (algebra_map A K) (minpoly A x)) = 0
A : Type u_1,	K : Type u_2,	R : Type u_3,	_inst_4 : comm_ring A,	_inst_5 : field K,	_inst_6 : comm_ring R,	_inst_7 : algebra A K,	_inst_8 : algebra A R,	_inst_9 : algebra K R,	_inst_10 : is_scalar_tower A K R,	x : R	⊢ minpoly K x ∣ polynomial.map (algebra_map A K) (minpoly A x)
A : Type u_1,	B : Type u_2,	_inst_1 : field A,	_inst_2 : domain B,	_inst_3 : algebra A B,	x : B,	hx : is_integral A x	⊢ (minpoly A x).coeff 0 = 0 ↔ x = 0
A : Type u_1,	B : Type u_2,	_inst_1 : field A,	_inst_2 : domain B,	_inst_3 : algebra A B,	x : B,	hx : is_integral A x	⊢ (minpoly A x).coeff 0 = 0 → x = 0
A : Type u_1,	B : Type u_2,	_inst_1 : field A,	_inst_2 : domain B,	_inst_3 : algebra A B,	x : B,	hx : is_integral A x,	h : (minpoly A x).coeff 0 = 0	⊢ x = 0
A : Type u_1,	B : Type u_2,	_inst_1 : field A,	_inst_2 : domain B,	_inst_3 : algebra A B,	x : B,	hx : is_integral A x,	h : (minpoly A x).coeff 0 = 0,	zero_root : (minpoly A x).is_root 0	⊢ x = 0
A : Type u_1,	B : Type u_2,	_inst_1 : field A,	_inst_2 : domain B,	_inst_3 : algebra A B,	x : B,	hx : is_integral A x	⊢ (minpoly A x).coeff 0 = 0 → x = 0		A : Type u_1,	B : Type u_2,	_inst_1 : field A,	_inst_2 : domain B,	_inst_3 : algebra A B,	x : B,	hx : is_integral A x	⊢ x = 0 → (minpoly A x).coeff 0 = 0
A : Type u_1,	B : Type u_2,	_inst_1 : field A,	_inst_2 : domain B,	_inst_3 : algebra A B,	x : B,	hx : is_integral A x,	h : (minpoly A x).coeff 0 = 0,	zero_root : (minpoly A x).is_root 0	⊢ ⇑(algebra_map A B) 0 = 0
A : Type u_1,	B : Type u_2,	_inst_1 : field A,	_inst_2 : domain B,	_inst_3 : algebra A B,	hx : is_integral A 0	⊢ (minpoly A 0).coeff 0 = 0
A : Type u_1,	B : Type u_2,	_inst_1 : field A,	_inst_2 : domain B,	_inst_3 : algebra A B,	x : B,	hx : is_integral A x	⊢ x = 0 → (minpoly A x).coeff 0 = 0
F : Type u,	_inst_1 : field F,	f : polynomial F,	hf : irreducible f,	h : ⇑polynomial.derivative f ≠ 0,	g : polynomial F,	hg1 : g ∈ nonunits (polynomial F),	hg2 : g ≠ 0,	_x : g ∣ f,	_fun_match : g ∣ f → ¬g ∣ ⇑polynomial.derivative f,	p : polynomial F,	hg3 : f = g * p,	hg4 : g ∣ ⇑polynomial.derivative f,	_let_match : is_unit p → false,	u : units (polynomial F),	hu : ↑u = p	⊢ f ∣ ⇑polynomial.derivative f
F : Type u,	_inst_1 : field F,	f : polynomial F,	hf : irreducible f,	h : ⇑polynomial.derivative f ≠ 0,	g : polynomial F,	hg1 : g ∈ nonunits (polynomial F),	hg2 : g ≠ 0,	_x : g ∣ f,	_fun_match : g ∣ f → ¬g ∣ ⇑polynomial.derivative f,	p : polynomial F,	hg3 : f = g * p,	hg4 : g ∣ ⇑polynomial.derivative f,	_let_match : is_unit p → false,	u : units (polynomial F),	hu : ↑u = p	⊢ f = ?m_1
F : Type u,	_inst_1 : field F,	f : polynomial F,	hf : irreducible f,	h : ⇑polynomial.derivative f ≠ 0,	g : polynomial F,	hg1 : g ∈ nonunits (polynomial F),	hg2 : g ≠ 0,	_x : g ∣ f,	_fun_match : g ∣ f → ¬g ∣ ⇑polynomial.derivative f,	p : polynomial F,	hg3 : f = g * p,	hg4 : g ∣ ⇑polynomial.derivative f,	_let_match : is_unit p → false,	u : units (polynomial F),	hu : ↑u = p	⊢ g * ↑u ∣ ⇑polynomial.derivative f
F : Type u,	_inst_1 : field F,	p : ℕ,	hp : fact (nat.prime p),	HF : char_p F p,	f : polynomial F,	hf : irreducible f,	H : ⇑polynomial.derivative f = 0	⊢ ¬f.separable
F : Type u,	_inst_1 : field F,	p : ℕ,	hp : fact (nat.prime p),	HF : char_p F p,	f : polynomial F,	hf : irreducible f,	H : ⇑polynomial.derivative f = 0	⊢ irreducible (polynomial.contract p f)
F : Type u,	_inst_1 : field F,	p : ℕ,	hp : fact (nat.prime p),	HF : char_p F p,	f : polynomial F,	hf : irreducible f,	H : ⇑polynomial.derivative f = 0,	_inst : is_local_ring_hom ↑(polynomial.expand F p)	⊢ irreducible (polynomial.contract p f)
F : Type u,	_inst_1 : field F,	p : ℕ,	hp : fact (nat.prime p),	HF : char_p F p,	f : polynomial F,	hf : irreducible f,	H : ⇑polynomial.derivative f = 0	⊢ irreducible (polynomial.contract p f)
F : Type u,	_inst_1 : field F,	p : ℕ,	hp : fact (nat.prime p),	HF : char_p F p,	f : polynomial F,	hf : irreducible f,	H : ⇑polynomial.derivative f = 0,	_inst : is_local_ring_hom ↑(polynomial.expand F p)	⊢ irreducible (⇑↑(polynomial.expand F p) (polynomial.contract p f))
F : Type u,	_inst_1 : field F,	p q : polynomial F,	hq : ¬is_unit q,	hsep : p.separable	⊢ multiplicity q p ≤ 1
F : Type u,	_inst_1 : field F,	p q : polynomial F,	hsep : p.separable,	hq : 1 < multiplicity q p	⊢ is_unit q
F : Type u,	_inst_1 : field F,	p q : polynomial F,	hsep : p.separable,	hq : 1 < multiplicity q p	⊢ q * q ∣ p
F : Type u,	_inst_1 : field F,	p q : polynomial F,	hsep : p.separable,	hq : 1 < multiplicity q p	⊢ q ^ 2 ∣ p
F : Type u,	_inst_1 : field F,	p q : polynomial F,	hsep : p.separable,	hq : 1 < multiplicity q p	⊢ ↑2 ≤ multiplicity q p
F : Type u,	_inst_1 : field F,	p : polynomial F,	hp : p ≠ 0,	hsep : p.separable,	x : F	⊢ polynomial.root_multiplicity x p ≤ 1
F : Type u,	_inst_1 : field F,	p : polynomial F,	hp : p ≠ 0,	hsep : p.separable,	x : F	⊢ multiplicity (polynomial.X - ⇑polynomial.C x) p ≤ 1
F : Type u,	_inst_1 : field F,	K : Type v,	_inst_2 : field K,	i : F →+* K,	x : F,	h : polynomial F,	h_ne_zero : h ≠ 0,	h_sep : h.separable,	h_root : polynomial.eval x h = 0,	h_splits : polynomial.splits i h,	h_roots : ∀ (y : K), y ∈ (polynomial.map i h).roots → y = ⇑i x	⊢ h = ⇑polynomial.C h.leading_coeff * (polynomial.X - ⇑polynomial.C x)
F : Type u,	_inst_1 : field F,	K : Type v,	_inst_2 : field K,	i : F →+* K,	x : F,	h : polynomial F,	h_ne_zero : h ≠ 0,	h_sep : h.separable,	h_root : polynomial.eval x h = 0,	h_splits : polynomial.splits i h,	h_roots : ∀ (y : K), y ∈ (polynomial.map i h).roots → y = ⇑i x	⊢ (polynomial.map i h).roots = {⇑i x}
F : Type u,	_inst_1 : field F,	K : Type v,	_inst_2 : field K,	i : F →+* K,	x : F,	h : polynomial F,	h_ne_zero : h ≠ 0,	h_sep : h.separable,	h_root : polynomial.eval x h = 0,	h_splits : polynomial.splits i h,	h_roots : ∀ (y : K), y ∈ (polynomial.map i h).roots → y = ⇑i x	⊢ {val := (polynomial.map i h).roots, nodup := ?m_1} = {val := {⇑i x}, nodup := ?m_2}
F : Type u,	_inst_1 : field F,	K : Type v,	_inst_2 : field K,	i : F →+* K,	x : F,	h : polynomial F,	h_ne_zero : h ≠ 0,	h_sep : h.separable,	h_root : polynomial.eval x h = 0,	h_splits : polynomial.splits i h,	h_roots : ∀ (y : K), y ∈ (polynomial.map i h).roots → y = ⇑i x	⊢ {val := (polynomial.map i h).roots, nodup := ?m_1} = {⇑i x}
F : Type u,	_inst_1 : field F,	K : Type v,	_inst_2 : field K,	i : F →+* K,	x : F,	h : polynomial F,	h_ne_zero : h ≠ 0,	h_sep : h.separable,	h_root : polynomial.eval x h = 0,	h_splits : polynomial.splits i h,	h_roots : ∀ (y : K), y ∈ (polynomial.map i h).roots → y = ⇑i x	⊢ ⇑i x ∈ {val := (polynomial.map i h).roots, nodup := ?m_1} ∧ ∀ (x_1 : K), x_1 ∈ {val := (polynomial.map i h).roots, nodup := ?m_1} → x_1 = ⇑i x
F : Type u,	_inst_1 : field F,	K : Type v,	_inst_2 : field K,	i : F →+* K,	x : F,	h : polynomial F,	h_ne_zero : h ≠ 0,	h_sep : h.separable,	h_root : polynomial.eval x h = 0,	h_splits : polynomial.splits i h,	h_roots : ∀ (y : K), y ∈ (polynomial.map i h).roots → y = ⇑i x	⊢ ⇑i x ∈ {val := (polynomial.map i h).roots, nodup := ?m_1}
F : Type u,	_inst_1 : field F,	K : Type v,	_inst_2 : field K,	i : F →+* K,	x : F,	h : polynomial F,	h_ne_zero : h ≠ 0,	h_sep : h.separable,	h_root : polynomial.eval x h = 0,	h_splits : polynomial.splits i h,	h_roots : ∀ (y : K), y ∈ (polynomial.map i h).roots → y = ⇑i x	⊢ polynomial.map i h ≠ 0
F : Type u,	_inst_1 : field F,	K : Type v,	_inst_2 : field K,	i : F →+* K,	x : F,	h : polynomial F,	h_ne_zero : h ≠ 0,	h_sep : h.separable,	h_root : polynomial.eval x h = 0,	h_splits : polynomial.splits i h,	h_roots : ∀ (y : K), y ∈ (polynomial.map i h).roots → y = ⇑i x	⊢ ⇑i x ∈ (polynomial.map i h).roots
F : Type u,	_inst_1 : field F,	K : Type v,	_inst_2 : field K,	i : F →+* K,	x : F,	h : polynomial F,	h_ne_zero : h ≠ 0,	h_sep : h.separable,	h_root : polynomial.eval x h = 0,	h_splits : polynomial.splits i h,	h_roots : ∀ (y : K), y ∈ (polynomial.map i h).roots → y = ⇑i x	⊢ (polynomial.map i h).is_root (⇑i x)
F : Type u,	_inst_1 : field F,	K : Type v,	_inst_2 : field K,	i : F →+* K,	x : F,	h : polynomial F,	h_ne_zero : h ≠ 0,	h_sep : h.separable,	h_root : polynomial.eval x h = 0,	h_splits : polynomial.splits i h,	h_roots : ∀ (y : K), y ∈ (polynomial.map i h).roots → y = ⇑i x	⊢ ⇑i x ∈ {val := (polynomial.map i h).roots, nodup := ?m_1}		F : Type u,	_inst_1 : field F,	K : Type v,	_inst_2 : field K,	i : F →+* K,	x : F,	h : polynomial F,	h_ne_zero : h ≠ 0,	h_sep : h.separable,	h_root : polynomial.eval x h = 0,	h_splits : polynomial.splits i h,	h_roots : ∀ (y : K), y ∈ (polynomial.map i h).roots → y = ⇑i x	⊢ ∀ (x_1 : K), x_1 ∈ {val := (polynomial.map i h).roots, nodup := ?m_1} → x_1 = ⇑i x
F : Type u,	_inst_1 : field F,	K : Type v,	_inst_2 : field K,	i : F →+* K,	x : F,	h : polynomial F,	h_ne_zero : h ≠ 0,	h_sep : h.separable,	h_root : polynomial.eval x h = 0,	h_splits : polynomial.splits i h,	h_roots : ∀ (y : K), y ∈ (polynomial.map i h).roots → y = ⇑i x	⊢ ⇑i 0 = 0
F : Type u,	_inst_1 : field F,	K : Type v,	_inst_2 : field K,	i : F →+* K,	x : F,	h : polynomial F,	h_ne_zero : h ≠ 0,	h_sep : h.separable,	h_root : polynomial.eval x h = 0,	h_splits : polynomial.splits i h,	h_roots : ∀ (y : K), y ∈ (polynomial.map i h).roots → y = ⇑i x	⊢ {val := (polynomial.map i h).roots, nodup := ?m_1} = {val := {⇑i x}, nodup := ?m_2}		F : Type u,	_inst_1 : field F,	K : Type v,	_inst_2 : field K,	i : F →+* K,	x : F,	h : polynomial F,	h_ne_zero : h ≠ 0,	h_sep : h.separable,	h_root : polynomial.eval x h = 0,	h_splits : polynomial.splits i h,	h_roots : ∀ (y : K), y ∈ (polynomial.map i h).roots → y = ⇑i x	⊢ (polynomial.map i h).roots.nodup		F : Type u,	_inst_1 : field F,	K : Type v,	_inst_2 : field K,	i : F →+* K,	x : F,	h : polynomial F,	h_ne_zero : h ≠ 0,	h_sep : h.separable,	h_root : polynomial.eval x h = 0,	h_splits : polynomial.splits i h,	h_roots : ∀ (y : K), y ∈ (polynomial.map i h).roots → y = ⇑i x	⊢ {⇑i x}.nodup
F : Type u,	_inst_1 : field F,	K : Type v,	_inst_2 : field K,	i : F →+* K,	x : F,	h : polynomial F,	h_ne_zero : h ≠ 0,	h_sep : h.separable,	h_root : polynomial.eval x h = 0,	h_splits : polynomial.splits i h,	h_roots : ∀ (y : K), y ∈ (polynomial.map i h).roots → y = ⇑i x	⊢ ∀ (x_1 : K), x_1 ∈ {val := (polynomial.map i h).roots, nodup := ?m_1} → x_1 = ⇑i x
F : Type u,	_inst_1 : field F,	K : Type v,	_inst_2 : field K,	i : F →+* K,	x : F,	h : polynomial F,	h_ne_zero : h ≠ 0,	h_sep : h.separable,	h_root : polynomial.eval x h = 0,	h_splits : polynomial.splits i h,	h_roots : ∀ (y : K), y ∈ (polynomial.map i h).roots → y = ⇑i x	⊢ (polynomial.map i h).roots.nodup
F : Type u_1,	E : Type u_3,	_inst_1 : field F,	_inst_3 : field E,	_inst_5 : algebra F E,	E' : Type u_2,	_inst_8 : field E',	_inst_9 : algebra F E',	f : E →ₐ[F] E',	_inst_10 : is_separable F E'	⊢ is_separable F E
F : Type u_1,	E : Type u_3,	_inst_1 : field F,	_inst_3 : field E,	_inst_5 : algebra F E,	E' : Type u_2,	_inst_8 : field E',	_inst_9 : algebra F E',	f : E →ₐ[F] E',	_inst_10 : is_separable F E',	_inst : algebra E E' := f.to_ring_hom.to_algebra	⊢ is_separable F E
F : Type u_1,	E : Type u_3,	_inst_1 : field F,	_inst_3 : field E,	_inst_5 : algebra F E,	E' : Type u_2,	_inst_8 : field E',	_inst_9 : algebra F E',	f : E →ₐ[F] E',	_inst_10 : is_separable F E',	_inst : algebra E E' := f.to_ring_hom.to_algebra,	_inst_2 : is_scalar_tower F E E'	⊢ is_separable F E
V : Type u_1,	_inst_1 : inner_product_space ℝ V,	x y : V,	hx : x ≠ 0,	hy : y ≠ 0	⊢ has_inner.inner x y = -(∥x∥ * ∥y∥) ↔ inner_product_geometry.angle x y = π
V : Type u_1,	_inst_1 : inner_product_space ℝ V,	x y : V,	hx : x ≠ 0,	hy : y ≠ 0,	h : has_inner.inner x y = -(∥x∥ * ∥y∥)	⊢ inner_product_geometry.angle x y = π
V : Type u_1,	_inst_1 : inner_product_space ℝ V,	x y : V,	hx : x ≠ 0,	hy : y ≠ 0,	h : has_inner.inner x y = -(∥x∥ * ∥y∥),	h₁ : ∥x∥ * ∥y∥ ≠ 0	⊢ inner_product_geometry.angle x y = π
V : Type u_1,	_inst_1 : inner_product_space ℝ V,	x y : V	⊢ ∥x + y∥ = ∥x - y∥ ↔ inner_product_geometry.angle x y = π / 2
V : Type u_1,	_inst_1 : inner_product_space ℝ V,	x y : V	⊢ ∥x∥ ^ 2 + 2 * has_inner.inner x y + ∥y∥ ^ 2 = ∥x∥ ^ 2 - 2 * has_inner.inner x y + ∥y∥ ^ 2 → has_inner.inner x y = 0
V : Type u_1,	_inst_1 : inner_product_space ℝ V,	x y : V	⊢ has_inner.inner x y = 0 → ∥x∥ ^ 2 + 2 * has_inner.inner x y + ∥y∥ ^ 2 = ∥x∥ ^ 2 - 2 * has_inner.inner x y + ∥y∥ ^ 2
V : Type u_1,	_inst_1 : inner_product_space ℝ V,	x y : V,	h : ∥x∥ ^ 2 + 2 * has_inner.inner x y + ∥y∥ ^ 2 = ∥x∥ ^ 2 - 2 * has_inner.inner x y + ∥y∥ ^ 2	⊢ has_inner.inner x y = 0
V : Type u_1,	_inst_1 : inner_product_space ℝ V,	x y : V,	h : has_inner.inner x y = 0	⊢ ∥x∥ ^ 2 + 2 * has_inner.inner x y + ∥y∥ ^ 2 = ∥x∥ ^ 2 - 2 * has_inner.inner x y + ∥y∥ ^ 2
V : Type u_1,	_inst_1 : inner_product_space ℝ V,	x y : V	⊢ ∥x∥ ^ 2 + 2 * has_inner.inner x y + ∥y∥ ^ 2 = ∥x∥ ^ 2 - 2 * has_inner.inner x y + ∥y∥ ^ 2 ↔ has_inner.inner x y = 0
V : Type u_1,	_inst_1 : inner_product_space ℝ V,	x y : V	⊢ ∥x∥ ^ 2 + 2 * has_inner.inner x y + ∥y∥ ^ 2 = ∥x∥ ^ 2 - 2 * has_inner.inner x y + ∥y∥ ^ 2 ↔ has_inner.inner x y = 0
V : Type u_1,	_inst_1 : inner_product_space ℝ V,	x y : V	⊢ ∥x∥ ^ 2 + 2 * has_inner.inner x y + ∥y∥ ^ 2 = ∥x∥ ^ 2 - 2 * has_inner.inner x y + ∥y∥ ^ 2 ↔ has_inner.inner x y = 0
V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	r : ℝ,	v : V,	p₁ p₂ : P	⊢ has_dist.dist (r • v +ᵥ p₁) p₂ * has_dist.dist (r • v +ᵥ p₁) p₂ = has_inner.inner v v * r * r + 2 * has_inner.inner v (p₁ -ᵥ p₂) * r + has_inner.inner (p₁ -ᵥ p₂) (p₁ -ᵥ p₂)
V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	r : ℝ,	v : V,	p₁ p₂ : P	⊢ r * (r * has_inner.inner v v) + 2 * (r * has_inner.inner v (p₁ -ᵥ p₂)) + has_inner.inner (p₁ -ᵥ p₂) (p₁ -ᵥ p₂) = has_inner.inner v v * r * r + 2 * has_inner.inner v (p₁ -ᵥ p₂) * r + has_inner.inner (p₁ -ᵥ p₂) (p₁ -ᵥ p₂)
V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	n : ℕ,	s : affine.simplex ℝ P n	⊢ ∀ (i : fin (n + 1)), has_dist.dist s.circumcenter (s.points i) = s.circumradius
V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	n : ℕ,	s : affine.simplex ℝ P n,	i : fin (n + 1)	⊢ has_dist.dist s.circumcenter (s.points i) = s.circumradius
V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	n : ℕ,	s : affine.simplex ℝ P n,	i : fin (n + 1)	⊢ has_dist.dist (s.points i) s.circumcenter = s.circumradius
V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	n : ℕ,	s : affine.simplex ℝ P n,	p : P,	hp : p ∈ affine_span ℝ (set.range s.points),	r : ℝ,	hr : ∀ (i : fin (n + 1)), has_dist.dist (s.points i) p = r	⊢ r = s.circumradius
V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	n : ℕ,	s : affine.simplex ℝ P n,	p : P,	hp : p ∈ affine_span ℝ (set.range s.points),	r : ℝ,	hr : ∀ (i : fin (n + 1)), has_dist.dist (s.points i) p = r,	h : ((p, r).fst ∈ affine_span ℝ (set.range s.points) ∧ ∀ (i : fin (n + 1)), has_dist.dist (s.points i) (p, r).fst = (p, r).snd) → (p, r) = s.circumcenter_circumradius	⊢ r = s.circumradius
V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	n : ℕ,	s : affine.simplex ℝ P n,	p : P,	hp : p ∈ affine_span ℝ (set.range s.points),	r : ℝ,	hr : ∀ (i : fin (n + 1)), has_dist.dist (s.points i) p = r,	h : p = s.circumcenter_circumradius.fst ∧ r = s.circumcenter_circumradius.snd	⊢ r = s.circumradius
n : ℕ	⊢ ∑ (i : affine.simplex.points_with_circumcenter_index n), affine.simplex.circumcenter_weights_with_circumcenter n i = 1
n : ℕ	⊢ (λ (i : affine.simplex.points_with_circumcenter_index n), affine.simplex.circumcenter_weights_with_circumcenter n i) = λ (x : affine.simplex.points_with_circumcenter_index n), ite (x = affine.simplex.points_with_circumcenter_index.circumcenter_index) (function.const (affine.simplex.points_with_circumcenter_index n) 1 x) 0
n : ℕ,	j : fin (n + 1)	⊢ affine.simplex.circumcenter_weights_with_circumcenter n (affine.simplex.points_with_circumcenter_index.point_index j) = ite (affine.simplex.points_with_circumcenter_index.point_index j = affine.simplex.points_with_circumcenter_index.circumcenter_index) (function.const (affine.simplex.points_with_circumcenter_index n) 1 (affine.simplex.points_with_circumcenter_index.point_index j)) 0
n : ℕ	⊢ affine.simplex.circumcenter_weights_with_circumcenter n affine.simplex.points_with_circumcenter_index.circumcenter_index = ite (affine.simplex.points_with_circumcenter_index.circumcenter_index = affine.simplex.points_with_circumcenter_index.circumcenter_index) (function.const (affine.simplex.points_with_circumcenter_index n) 1 affine.simplex.points_with_circumcenter_index.circumcenter_index) 0
n : ℕ	⊢ (λ (i : affine.simplex.points_with_circumcenter_index n), affine.simplex.circumcenter_weights_with_circumcenter n i) = λ (x : affine.simplex.points_with_circumcenter_index n), ite (x = affine.simplex.points_with_circumcenter_index.circumcenter_index) (function.const (affine.simplex.points_with_circumcenter_index n) 1 x) 0
n : ℕ	⊢ (λ (i : affine.simplex.points_with_circumcenter_index n), affine.simplex.circumcenter_weights_with_circumcenter n i) = λ (x : affine.simplex.points_with_circumcenter_index n), ite (x = affine.simplex.points_with_circumcenter_index.circumcenter_index) (function.const (affine.simplex.points_with_circumcenter_index n) 1 x) 0		n : ℕ	⊢ 1 = ite (affine.simplex.points_with_circumcenter_index.circumcenter_index ∈ finset.univ) (function.const (affine.simplex.points_with_circumcenter_index n) 1 affine.simplex.points_with_circumcenter_index.circumcenter_index) 0		n : ℕ	⊢ decidable_eq (affine.simplex.points_with_circumcenter_index n)
n : ℕ	⊢ 1 = ite (affine.simplex.points_with_circumcenter_index.circumcenter_index ∈ finset.univ) (function.const (affine.simplex.points_with_circumcenter_index n) 1 affine.simplex.points_with_circumcenter_index.circumcenter_index) 0		n : ℕ	⊢ decidable_eq (affine.simplex.points_with_circumcenter_index n)
n : ℕ	⊢ 1 = ite (affine.simplex.points_with_circumcenter_index.circumcenter_index ∈ finset.univ) (function.const (affine.simplex.points_with_circumcenter_index n) 1 affine.simplex.points_with_circumcenter_index.circumcenter_index) 0
V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	n : ℕ,	s : affine.simplex ℝ P n	⊢ s.circumcenter = ⇑(finset.univ.affine_combination s.points_with_circumcenter) (affine.simplex.circumcenter_weights_with_circumcenter n)
V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	n : ℕ,	s : affine.simplex ℝ P n	⊢ s.points_with_circumcenter affine.simplex.points_with_circumcenter_index.circumcenter_index = ⇑(finset.univ.affine_combination s.points_with_circumcenter) (affine.simplex.circumcenter_weights_with_circumcenter n)
V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	n : ℕ,	s : affine.simplex ℝ P n	⊢ ⇑(finset.univ.affine_combination s.points_with_circumcenter) (affine.simplex.circumcenter_weights_with_circumcenter n) = s.points_with_circumcenter affine.simplex.points_with_circumcenter_index.circumcenter_index
V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	n : ℕ,	s : affine.simplex ℝ P n	⊢ ∀ (i2 : affine.simplex.points_with_circumcenter_index n), i2 ∈ finset.univ → i2 ≠ affine.simplex.points_with_circumcenter_index.circumcenter_index → affine.simplex.circumcenter_weights_with_circumcenter n i2 = 0
V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	n : ℕ,	s : affine.simplex ℝ P n,	i : fin (n + 1),	hi : affine.simplex.points_with_circumcenter_index.point_index i ∈ finset.univ,	hn : affine.simplex.points_with_circumcenter_index.point_index i ≠ affine.simplex.points_with_circumcenter_index.circumcenter_index	⊢ affine.simplex.circumcenter_weights_with_circumcenter n (affine.simplex.points_with_circumcenter_index.point_index i) = 0
V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	n : ℕ,	s : affine.simplex ℝ P n,	hi : affine.simplex.points_with_circumcenter_index.circumcenter_index ∈ finset.univ,	hn : affine.simplex.points_with_circumcenter_index.circumcenter_index ≠ affine.simplex.points_with_circumcenter_index.circumcenter_index	⊢ affine.simplex.circumcenter_weights_with_circumcenter n affine.simplex.points_with_circumcenter_index.circumcenter_index = 0
V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	n : ℕ,	s : affine.simplex ℝ P n	⊢ ∀ (i2 : affine.simplex.points_with_circumcenter_index n), i2 ∈ finset.univ → i2 ≠ affine.simplex.points_with_circumcenter_index.circumcenter_index → affine.simplex.circumcenter_weights_with_circumcenter n i2 = 0
n : ℕ	⊢ ∑ (i : affine.simplex.points_with_circumcenter_index (n + 2)), affine.simplex.monge_point_weights_with_circumcenter n i = 1
n : ℕ	⊢ ↑(n + 2 + 1) * (↑(n + 1))⁻¹ + (-2) / ↑(n + 1) = 1
n : ℕ	⊢ ↑n + 1 ≠ 0		n : ℕ,	hn1 : ↑n + 1 ≠ 0	⊢ ↑(n + 2 + 1) * (↑(n + 1))⁻¹ + (-2) / ↑(n + 1) = 1
n : ℕ	⊢ ↑n + 1 ≠ 0
n : ℕ,	hn1 : ↑n + 1 ≠ 0	⊢ ↑(n + 2 + 1) * (↑(n + 1))⁻¹ + (-2) / ↑(n + 1) = 1
n : ℕ,	hn1 : ↑n + 1 ≠ 0	⊢ ↑n + 2 + 1 + -2 = ↑n + 1
V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t : affine.triangle ℝ P,	i₁ i₂ : fin 3,	h : i₁ ≠ i₂	⊢ has_dist.dist t.orthocenter (⇑(euclidean_geometry.reflection (affine_span ℝ (t.points '' {i₁, i₂}))) (affine.simplex.circumcenter t)) = affine.simplex.circumradius t
V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t : affine.triangle ℝ P,	i₁ i₂ : fin 3,	h : i₁ ≠ i₂	⊢ (-∑ (i₁_1 i₂_1 : affine.simplex.points_with_circumcenter_index 2), ((λ (i : affine.simplex.points_with_circumcenter_index 2), affine.simplex.monge_point_weights_with_circumcenter 0 i) - λ (i : affine.simplex.points_with_circumcenter_index 2), affine.simplex.reflection_circumcenter_weights_with_circumcenter i₁ i₂ i) i₁_1 * ((λ (i : affine.simplex.points_with_circumcenter_index 2), affine.simplex.monge_point_weights_with_circumcenter 0 i) - λ (i : affine.simplex.points_with_circumcenter_index 2), affine.simplex.reflection_circumcenter_weights_with_circumcenter i₁ i₂ i) i₂_1 * (has_dist.dist (affine.simplex.points_with_circumcenter t i₁_1) (affine.simplex.points_with_circumcenter t i₂_1) * has_dist.dist (affine.simplex.points_with_circumcenter t i₁_1) (affine.simplex.points_with_circumcenter t i₂_1))) / 2 = affine.simplex.circumradius t * affine.simplex.circumradius t
V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t : affine.triangle ℝ P,	i₁ i₂ : fin 3,	h : i₁ ≠ i₂	⊢ -(∑ (i : fin (0 + 2 + 1)), (∑ (i_1 : fin (0 + 2 + 1)), ((↑(0 + 1))⁻¹ - ite (i = i₁ ∨ i = i₂) 1 0) * ((↑(0 + 1))⁻¹ - ite (i_1 = i₁ ∨ i_1 = i₂) 1 0) * (has_dist.dist (affine.simplex.points_with_circumcenter t (affine.simplex.points_with_circumcenter_index.point_index i)) (affine.simplex.points_with_circumcenter t (affine.simplex.points_with_circumcenter_index.point_index i_1)) * has_dist.dist (affine.simplex.points_with_circumcenter t (affine.simplex.points_with_circumcenter_index.point_index i)) (affine.simplex.points_with_circumcenter t (affine.simplex.points_with_circumcenter_index.point_index i_1))) + ((↑(0 + 1))⁻¹ - ite (i = i₁ ∨ i = i₂) 1 0) * ((-2) / ↑(0 + 1) - -1) * (has_dist.dist (affine.simplex.points_with_circumcenter t (affine.simplex.points_with_circumcenter_index.point_index i)) (affine.simplex.points_with_circumcenter t affine.simplex.points_with_circumcenter_index.circumcenter_index) * has_dist.dist (affine.simplex.points_with_circumcenter t (affine.simplex.points_with_circumcenter_index.point_index i)) (affine.simplex.points_with_circumcenter t affine.simplex.points_with_circumcenter_index.circumcenter_index))) + (∑ (i : fin (0 + 2 + 1)), ((-2) / ↑(0 + 1) - -1) * ((↑(0 + 1))⁻¹ - ite (i = i₁ ∨ i = i₂) 1 0) * (has_dist.dist (affine.simplex.points_with_circumcenter t affine.simplex.points_with_circumcenter_index.circumcenter_index) (affine.simplex.points_with_circumcenter t (affine.simplex.points_with_circumcenter_index.point_index i)) * has_dist.dist (affine.simplex.points_with_circumcenter t affine.simplex.points_with_circumcenter_index.circumcenter_index) (affine.simplex.points_with_circumcenter t (affine.simplex.points_with_circumcenter_index.point_index i))) + ((-2) / ↑(0 + 1) - -1) * ((-2) / ↑(0 + 1) - -1) * (has_dist.dist (affine.simplex.points_with_circumcenter t affine.simplex.points_with_circumcenter_index.circumcenter_index) (affine.simplex.points_with_circumcenter t affine.simplex.points_with_circumcenter_index.circumcenter_index) * has_dist.dist (affine.simplex.points_with_circumcenter t affine.simplex.points_with_circumcenter_index.circumcenter_index) (affine.simplex.points_with_circumcenter t affine.simplex.points_with_circumcenter_index.circumcenter_index)))) / 2 = affine.simplex.circumradius t * affine.simplex.circumradius t
V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t : affine.triangle ℝ P,	i₁ i₂ : fin 3,	h : i₁ ≠ i₂,	hu : {i₁, i₂} ⊆ finset.univ	⊢ -(∑ (i : fin (0 + 2 + 1)), (∑ (i_1 : fin (0 + 2 + 1)), ((↑(0 + 1))⁻¹ - ite (i = i₁ ∨ i = i₂) 1 0) * ((↑(0 + 1))⁻¹ - ite (i_1 = i₁ ∨ i_1 = i₂) 1 0) * (has_dist.dist (affine.simplex.points_with_circumcenter t (affine.simplex.points_with_circumcenter_index.point_index i)) (affine.simplex.points_with_circumcenter t (affine.simplex.points_with_circumcenter_index.point_index i_1)) * has_dist.dist (affine.simplex.points_with_circumcenter t (affine.simplex.points_with_circumcenter_index.point_index i)) (affine.simplex.points_with_circumcenter t (affine.simplex.points_with_circumcenter_index.point_index i_1))) + ((↑(0 + 1))⁻¹ - ite (i = i₁ ∨ i = i₂) 1 0) * ((-2) / ↑(0 + 1) - -1) * (has_dist.dist (affine.simplex.points_with_circumcenter t (affine.simplex.points_with_circumcenter_index.point_index i)) (affine.simplex.points_with_circumcenter t affine.simplex.points_with_circumcenter_index.circumcenter_index) * has_dist.dist (affine.simplex.points_with_circumcenter t (affine.simplex.points_with_circumcenter_index.point_index i)) (affine.simplex.points_with_circumcenter t affine.simplex.points_with_circumcenter_index.circumcenter_index))) + (∑ (i : fin (0 + 2 + 1)), ((-2) / ↑(0 + 1) - -1) * ((↑(0 + 1))⁻¹ - ite (i = i₁ ∨ i = i₂) 1 0) * (has_dist.dist (affine.simplex.points_with_circumcenter t affine.simplex.points_with_circumcenter_index.circumcenter_index) (affine.simplex.points_with_circumcenter t (affine.simplex.points_with_circumcenter_index.point_index i)) * has_dist.dist (affine.simplex.points_with_circumcenter t affine.simplex.points_with_circumcenter_index.circumcenter_index) (affine.simplex.points_with_circumcenter t (affine.simplex.points_with_circumcenter_index.point_index i))) + ((-2) / ↑(0 + 1) - -1) * ((-2) / ↑(0 + 1) - -1) * (has_dist.dist (affine.simplex.points_with_circumcenter t affine.simplex.points_with_circumcenter_index.circumcenter_index) (affine.simplex.points_with_circumcenter t affine.simplex.points_with_circumcenter_index.circumcenter_index) * has_dist.dist (affine.simplex.points_with_circumcenter t affine.simplex.points_with_circumcenter_index.circumcenter_index) (affine.simplex.points_with_circumcenter t affine.simplex.points_with_circumcenter_index.circumcenter_index)))) / 2 = affine.simplex.circumradius t * affine.simplex.circumradius t
V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t : affine.triangle ℝ P,	i₁ i₂ : fin 3,	h : i₁ ≠ i₂,	hu : {i₁, i₂} ⊆ finset.univ	⊢ ∃ (i₃ : fin 3), finset.univ \ {i₁, i₂} = {i₃} ∧ i₃ ≠ i₁ ∧ i₃ ≠ i₂
V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t : affine.triangle ℝ P,	i₁ i₂ : fin 3,	h : i₁ ≠ i₂,	hu : {i₁, i₂} ⊆ finset.univ,	i₃ : fin 3,	hi₃ : finset.univ \ {i₁, i₂} = {i₃},	hi₃₁ : i₃ ≠ i₁,	hi₃₂ : i₃ ≠ i₂	⊢ -(∑ (i : fin (0 + 2 + 1)), (∑ (i_1 : fin (0 + 2 + 1)), ((↑(0 + 1))⁻¹ - ite (i = i₁ ∨ i = i₂) 1 0) * ((↑(0 + 1))⁻¹ - ite (i_1 = i₁ ∨ i_1 = i₂) 1 0) * (has_dist.dist (affine.simplex.points_with_circumcenter t (affine.simplex.points_with_circumcenter_index.point_index i)) (affine.simplex.points_with_circumcenter t (affine.simplex.points_with_circumcenter_index.point_index i_1)) * has_dist.dist (affine.simplex.points_with_circumcenter t (affine.simplex.points_with_circumcenter_index.point_index i)) (affine.simplex.points_with_circumcenter t (affine.simplex.points_with_circumcenter_index.point_index i_1))) + ((↑(0 + 1))⁻¹ - ite (i = i₁ ∨ i = i₂) 1 0) * ((-2) / ↑(0 + 1) - -1) * (has_dist.dist (affine.simplex.points_with_circumcenter t (affine.simplex.points_with_circumcenter_index.point_index i)) (affine.simplex.points_with_circumcenter t affine.simplex.points_with_circumcenter_index.circumcenter_index) * has_dist.dist (affine.simplex.points_with_circumcenter t (affine.simplex.points_with_circumcenter_index.point_index i)) (affine.simplex.points_with_circumcenter t affine.simplex.points_with_circumcenter_index.circumcenter_index))) + (∑ (i : fin (0 + 2 + 1)), ((-2) / ↑(0 + 1) - -1) * ((↑(0 + 1))⁻¹ - ite (i = i₁ ∨ i = i₂) 1 0) * (has_dist.dist (affine.simplex.points_with_circumcenter t affine.simplex.points_with_circumcenter_index.circumcenter_index) (affine.simplex.points_with_circumcenter t (affine.simplex.points_with_circumcenter_index.point_index i)) * has_dist.dist (affine.simplex.points_with_circumcenter t affine.simplex.points_with_circumcenter_index.circumcenter_index) (affine.simplex.points_with_circumcenter t (affine.simplex.points_with_circumcenter_index.point_index i))) + ((-2) / ↑(0 + 1) - -1) * ((-2) / ↑(0 + 1) - -1) * (has_dist.dist (affine.simplex.points_with_circumcenter t affine.simplex.points_with_circumcenter_index.circumcenter_index) (affine.simplex.points_with_circumcenter t affine.simplex.points_with_circumcenter_index.circumcenter_index) * has_dist.dist (affine.simplex.points_with_circumcenter t affine.simplex.points_with_circumcenter_index.circumcenter_index) (affine.simplex.points_with_circumcenter t affine.simplex.points_with_circumcenter_index.circumcenter_index)))) / 2 = affine.simplex.circumradius t * affine.simplex.circumradius t
V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t : affine.triangle ℝ P,	i₁ i₂ : fin 3,	h : i₁ ≠ i₂,	hu : {i₁, i₂} ⊆ finset.univ,	i₃ : fin 3,	hi₃ : finset.univ \ {i₁, i₂} = {i₃},	hi₃₁ : i₃ ≠ i₁,	hi₃₂ : i₃ ≠ i₂	⊢ -(∑ (x : fin 3) in {i₃}, (∑ (x_1 : fin 3) in {i₃}, ((↑(0 + 1))⁻¹ - ite (x = i₁ ∨ x = i₂) 1 0) * ((↑(0 + 1))⁻¹ - ite (x_1 = i₁ ∨ x_1 = i₂) 1 0) * (has_dist.dist (affine.simplex.points_with_circumcenter t (affine.simplex.points_with_circumcenter_index.point_index x)) (affine.simplex.points_with_circumcenter t (affine.simplex.points_with_circumcenter_index.point_index x_1)) * has_dist.dist (affine.simplex.points_with_circumcenter t (affine.simplex.points_with_circumcenter_index.point_index x)) (affine.simplex.points_with_circumcenter t (affine.simplex.points_with_circumcenter_index.point_index x_1))) + ∑ (x_1 : fin 3) in {i₁, i₂}, ((↑(0 + 1))⁻¹ - ite (x = i₁ ∨ x = i₂) 1 0) * ((↑(0 + 1))⁻¹ - ite (x_1 = i₁ ∨ x_1 = i₂) 1 0) * (has_dist.dist (affine.simplex.points_with_circumcenter t (affine.simplex.points_with_circumcenter_index.point_index x)) (affine.simplex.points_with_circumcenter t (affine.simplex.points_with_circumcenter_index.point_index x_1)) * has_dist.dist (affine.simplex.points_with_circumcenter t (affine.simplex.points_with_circumcenter_index.point_index x)) (affine.simplex.points_with_circumcenter t (affine.simplex.points_with_circumcenter_index.point_index x_1))) + ((↑(0 + 1))⁻¹ - ite (x = i₁ ∨ x = i₂) 1 0) * ((-2) / ↑(0 + 1) - -1) * (has_dist.dist (affine.simplex.points_with_circumcenter t (affine.simplex.points_with_circumcenter_index.point_index x)) (affine.simplex.points_with_circumcenter t affine.simplex.points_with_circumcenter_index.circumcenter_index) * has_dist.dist (affine.simplex.points_with_circumcenter t (affine.simplex.points_with_circumcenter_index.point_index x)) (affine.simplex.points_with_circumcenter t affine.simplex.points_with_circumcenter_index.circumcenter_index))) + ∑ (x : fin 3) in {i₁, i₂}, (∑ (x_1 : fin 3) in {i₃}, ((↑(0 + 1))⁻¹ - ite (x = i₁ ∨ x = i₂) 1 0) * ((↑(0 + 1))⁻¹ - ite (x_1 = i₁ ∨ x_1 = i₂) 1 0) * (has_dist.dist (affine.simplex.points_with_circumcenter t (affine.simplex.points_with_circumcenter_index.point_index x)) (affine.simplex.points_with_circumcenter t (affine.simplex.points_with_circumcenter_index.point_index x_1)) * has_dist.dist (affine.simplex.points_with_circumcenter t (affine.simplex.points_with_circumcenter_index.point_index x)) (affine.simplex.points_with_circumcenter t (affine.simplex.points_with_circumcenter_index.point_index x_1))) + ∑ (x_1 : fin 3) in {i₁, i₂}, ((↑(0 + 1))⁻¹ - ite (x = i₁ ∨ x = i₂) 1 0) * ((↑(0 + 1))⁻¹ - ite (x_1 = i₁ ∨ x_1 = i₂) 1 0) * (has_dist.dist (affine.simplex.points_with_circumcenter t (affine.simplex.points_with_circumcenter_index.point_index x)) (affine.simplex.points_with_circumcenter t (affine.simplex.points_with_circumcenter_index.point_index x_1)) * has_dist.dist (affine.simplex.points_with_circumcenter t (affine.simplex.points_with_circumcenter_index.point_index x)) (affine.simplex.points_with_circumcenter t (affine.simplex.points_with_circumcenter_index.point_index x_1))) + ((↑(0 + 1))⁻¹ - ite (x = i₁ ∨ x = i₂) 1 0) * ((-2) / ↑(0 + 1) - -1) * (has_dist.dist (affine.simplex.points_with_circumcenter t (affine.simplex.points_with_circumcenter_index.point_index x)) (affine.simplex.points_with_circumcenter t affine.simplex.points_with_circumcenter_index.circumcenter_index) * has_dist.dist (affine.simplex.points_with_circumcenter t (affine.simplex.points_with_circumcenter_index.point_index x)) (affine.simplex.points_with_circumcenter t affine.simplex.points_with_circumcenter_index.circumcenter_index))) + (∑ (x : fin 3) in {i₃}, ((-2) / ↑(0 + 1) - -1) * ((↑(0 + 1))⁻¹ - ite (x = i₁ ∨ x = i₂) 1 0) * (has_dist.dist (affine.simplex.points_with_circumcenter t affine.simplex.points_with_circumcenter_index.circumcenter_index) (affine.simplex.points_with_circumcenter t (affine.simplex.points_with_circumcenter_index.point_index x)) * has_dist.dist (affine.simplex.points_with_circumcenter t affine.simplex.points_with_circumcenter_index.circumcenter_index) (affine.simplex.points_with_circumcenter t (affine.simplex.points_with_circumcenter_index.point_index x))) + ∑ (x : fin 3) in {i₁, i₂}, ((-2) / ↑(0 + 1) - -1) * ((↑(0 + 1))⁻¹ - ite (x = i₁ ∨ x = i₂) 1 0) * (has_dist.dist (affine.simplex.points_with_circumcenter t affine.simplex.points_with_circumcenter_index.circumcenter_index) (affine.simplex.points_with_circumcenter t (affine.simplex.points_with_circumcenter_index.point_index x)) * has_dist.dist (affine.simplex.points_with_circumcenter t affine.simplex.points_with_circumcenter_index.circumcenter_index) (affine.simplex.points_with_circumcenter t (affine.simplex.points_with_circumcenter_index.point_index x))) + ((-2) / ↑(0 + 1) - -1) * ((-2) / ↑(0 + 1) - -1) * (has_dist.dist (affine.simplex.points_with_circumcenter t affine.simplex.points_with_circumcenter_index.circumcenter_index) (affine.simplex.points_with_circumcenter t affine.simplex.points_with_circumcenter_index.circumcenter_index) * has_dist.dist (affine.simplex.points_with_circumcenter t affine.simplex.points_with_circumcenter_index.circumcenter_index) (affine.simplex.points_with_circumcenter t affine.simplex.points_with_circumcenter_index.circumcenter_index)))) / 2 = affine.simplex.circumradius t * affine.simplex.circumradius t
V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t : affine.triangle ℝ P,	i₁ i₂ : fin 3,	h : i₁ ≠ i₂,	hu : {i₁, i₂} ⊆ finset.univ,	i₃ : fin 3,	hi₃ : finset.univ \ {i₁, i₂} = {i₃},	hi₃₁ : i₃ ≠ i₁,	hi₃₂ : i₃ ≠ i₂	⊢ -((1 - 2) * (affine.simplex.circumradius t * affine.simplex.circumradius t)) = affine.simplex.circumradius t * affine.simplex.circumradius t
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	H : Type u_2,	_inst_2 : topological_space H,	E : Type u_3,	_inst_3 : normed_group E,	_inst_4 : normed_space 𝕜 E,	I : model_with_corners 𝕜 E H,	G : Type u_5,	_inst_7 : topological_space G,	_inst_8 : charted_space H G,	_inst_9 : group G,	_inst_10 : lie_group I G,	E' : Type u_6,	_inst_11 : normed_group E',	_inst_12 : normed_space 𝕜 E',	H' : Type u_7,	_inst_13 : topological_space H',	I' : model_with_corners 𝕜 E' H',	M : Type u_8,	_inst_14 : topological_space M,	_inst_15 : charted_space H' M,	f g : M → G,	hf : smooth I' I f,	hg : smooth I' I g	⊢ smooth I' I (f * g⁻¹)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	H : Type u_2,	_inst_2 : topological_space H,	E : Type u_3,	_inst_3 : normed_group E,	_inst_4 : normed_space 𝕜 E,	I : model_with_corners 𝕜 E H,	G : Type u_5,	_inst_7 : topological_space G,	_inst_8 : charted_space H G,	_inst_9 : group G,	_inst_10 : lie_group I G,	E' : Type u_6,	_inst_11 : normed_group E',	_inst_12 : normed_space 𝕜 E',	H' : Type u_7,	_inst_13 : topological_space H',	I' : model_with_corners 𝕜 E' H',	M : Type u_8,	_inst_14 : topological_space M,	_inst_15 : charted_space H' M,	f g : M → G,	hf : smooth I' I f,	hg : smooth I' I g	⊢ smooth I' I (f / g)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	p : tangent_bundle I H	⊢ (charted_space.chart_at (model_prod H E) p).symm.to_local_equiv.to_fun = (equiv.sigma_equiv_prod H E).symm.to_fun
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	p : tangent_bundle I H	⊢ ⇑((charted_space.chart_at (model_prod H E) p).symm) = ⇑((equiv.sigma_equiv_prod H E).symm)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	E' : Type u_3,	_inst_4 : normed_group E',	_inst_5 : normed_space 𝕜 E',	F : Type u_4,	_inst_6 : normed_group F,	_inst_7 : normed_space 𝕜 F,	H : Type u_5,	_inst_8 : topological_space H,	H' : Type u_6,	_inst_9 : topological_space H',	G : Type u_7,	_inst_10 : topological_space G,	I : model_with_corners 𝕜 E H,	I' : model_with_corners 𝕜 E' H',	J : model_with_corners 𝕜 F G,	M : Type u_8,	_inst_11 : topological_space M,	_inst_12 : charted_space H M,	M' : Type u_9,	_inst_13 : topological_space M',	_inst_14 : charted_space H' M',	N : Type u_10,	_inst_15 : topological_space N,	_inst_16 : charted_space G N,	n m : with_top ℕ,	h : M ≃ₘ^n⟮I,J⟯ N,	f : N → M',	s : set M,	x : M,	hm : m ≤ n	⊢ times_cont_mdiff_within_at I I' m (f ∘ ⇑h) s x ↔ times_cont_mdiff_within_at J I' m f (⇑(h.symm) ⁻¹' s) (⇑h x)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	E' : Type u_3,	_inst_4 : normed_group E',	_inst_5 : normed_space 𝕜 E',	F : Type u_4,	_inst_6 : normed_group F,	_inst_7 : normed_space 𝕜 F,	H : Type u_5,	_inst_8 : topological_space H,	H' : Type u_6,	_inst_9 : topological_space H',	G : Type u_7,	_inst_10 : topological_space G,	I : model_with_corners 𝕜 E H,	I' : model_with_corners 𝕜 E' H',	J : model_with_corners 𝕜 F G,	M : Type u_8,	_inst_11 : topological_space M,	_inst_12 : charted_space H M,	M' : Type u_9,	_inst_13 : topological_space M',	_inst_14 : charted_space H' M',	N : Type u_10,	_inst_15 : topological_space N,	_inst_16 : charted_space G N,	n m : with_top ℕ,	h : M ≃ₘ^n⟮I,J⟯ N,	f : N → M',	s : set M,	x : M,	hm : m ≤ n	⊢ times_cont_mdiff_within_at I I' m (f ∘ ⇑h) s x → times_cont_mdiff_within_at J I' m f (⇑(h.symm) ⁻¹' s) (⇑h x)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	E' : Type u_3,	_inst_4 : normed_group E',	_inst_5 : normed_space 𝕜 E',	F : Type u_4,	_inst_6 : normed_group F,	_inst_7 : normed_space 𝕜 F,	H : Type u_5,	_inst_8 : topological_space H,	H' : Type u_6,	_inst_9 : topological_space H',	G : Type u_7,	_inst_10 : topological_space G,	I : model_with_corners 𝕜 E H,	I' : model_with_corners 𝕜 E' H',	J : model_with_corners 𝕜 F G,	M : Type u_8,	_inst_11 : topological_space M,	_inst_12 : charted_space H M,	M' : Type u_9,	_inst_13 : topological_space M',	_inst_14 : charted_space H' M',	N : Type u_10,	_inst_15 : topological_space N,	_inst_16 : charted_space G N,	n m : with_top ℕ,	h : M ≃ₘ^n⟮I,J⟯ N,	f : N → M',	s : set M,	x : M,	hm : m ≤ n,	Hfh : times_cont_mdiff_within_at I I' m (f ∘ ⇑h) s x	⊢ times_cont_mdiff_within_at J I' m f (⇑(h.symm) ⁻¹' s) (⇑h x)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	E' : Type u_3,	_inst_4 : normed_group E',	_inst_5 : normed_space 𝕜 E',	F : Type u_4,	_inst_6 : normed_group F,	_inst_7 : normed_space 𝕜 F,	H : Type u_5,	_inst_8 : topological_space H,	H' : Type u_6,	_inst_9 : topological_space H',	G : Type u_7,	_inst_10 : topological_space G,	I : model_with_corners 𝕜 E H,	I' : model_with_corners 𝕜 E' H',	J : model_with_corners 𝕜 F G,	M : Type u_8,	_inst_11 : topological_space M,	_inst_12 : charted_space H M,	M' : Type u_9,	_inst_13 : topological_space M',	_inst_14 : charted_space H' M',	N : Type u_10,	_inst_15 : topological_space N,	_inst_16 : charted_space G N,	n m : with_top ℕ,	h : M ≃ₘ^n⟮I,J⟯ N,	f : N → M',	s : set M,	x : M,	hm : m ≤ n,	Hfh : times_cont_mdiff_within_at I I' m (f ∘ ⇑h) s (⇑(h.symm) (⇑h x))	⊢ times_cont_mdiff_within_at J I' m f (⇑(h.symm) ⁻¹' s) (⇑h x)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	E' : Type u_3,	_inst_4 : normed_group E',	_inst_5 : normed_space 𝕜 E',	F : Type u_4,	_inst_6 : normed_group F,	_inst_7 : normed_space 𝕜 F,	H : Type u_5,	_inst_8 : topological_space H,	H' : Type u_6,	_inst_9 : topological_space H',	G : Type u_7,	_inst_10 : topological_space G,	I : model_with_corners 𝕜 E H,	I' : model_with_corners 𝕜 E' H',	J : model_with_corners 𝕜 F G,	M : Type u_8,	_inst_11 : topological_space M,	_inst_12 : charted_space H M,	M' : Type u_9,	_inst_13 : topological_space M',	_inst_14 : charted_space H' M',	N : Type u_10,	_inst_15 : topological_space N,	_inst_16 : charted_space G N,	n m : with_top ℕ,	h : M ≃ₘ^n⟮I,J⟯ N,	f : N → M',	s : set M,	x : M,	hm : m ≤ n	⊢ times_cont_mdiff_within_at I I' m (f ∘ ⇑h) s x → times_cont_mdiff_within_at J I' m f (⇑(h.symm) ⁻¹' s) (⇑h x)		𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	E' : Type u_3,	_inst_4 : normed_group E',	_inst_5 : normed_space 𝕜 E',	F : Type u_4,	_inst_6 : normed_group F,	_inst_7 : normed_space 𝕜 F,	H : Type u_5,	_inst_8 : topological_space H,	H' : Type u_6,	_inst_9 : topological_space H',	G : Type u_7,	_inst_10 : topological_space G,	I : model_with_corners 𝕜 E H,	I' : model_with_corners 𝕜 E' H',	J : model_with_corners 𝕜 F G,	M : Type u_8,	_inst_11 : topological_space M,	_inst_12 : charted_space H M,	M' : Type u_9,	_inst_13 : topological_space M',	_inst_14 : charted_space H' M',	N : Type u_10,	_inst_15 : topological_space N,	_inst_16 : charted_space G N,	n m : with_top ℕ,	h : M ≃ₘ^n⟮I,J⟯ N,	f : N → M',	s : set M,	x : M,	hm : m ≤ n	⊢ times_cont_mdiff_within_at J I' m f (⇑(h.symm) ⁻¹' s) (⇑h x) → times_cont_mdiff_within_at I I' m (f ∘ ⇑h) s x
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	E' : Type u_3,	_inst_4 : normed_group E',	_inst_5 : normed_space 𝕜 E',	F : Type u_4,	_inst_6 : normed_group F,	_inst_7 : normed_space 𝕜 F,	H : Type u_5,	_inst_8 : topological_space H,	H' : Type u_6,	_inst_9 : topological_space H',	G : Type u_7,	_inst_10 : topological_space G,	I : model_with_corners 𝕜 E H,	I' : model_with_corners 𝕜 E' H',	J : model_with_corners 𝕜 F G,	M : Type u_8,	_inst_11 : topological_space M,	_inst_12 : charted_space H M,	M' : Type u_9,	_inst_13 : topological_space M',	_inst_14 : charted_space H' M',	N : Type u_10,	_inst_15 : topological_space N,	_inst_16 : charted_space G N,	n m : with_top ℕ,	h : M ≃ₘ^n⟮I,J⟯ N,	f : N → M',	s : set M,	x : M,	hm : m ≤ n	⊢ times_cont_mdiff_within_at J I' m f (⇑(h.symm) ⁻¹' s) (⇑h x) → times_cont_mdiff_within_at I I' m (f ∘ ⇑h) s x
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	E' : Type u_3,	_inst_4 : normed_group E',	_inst_5 : normed_space 𝕜 E',	F : Type u_4,	_inst_6 : normed_group F,	_inst_7 : normed_space 𝕜 F,	H : Type u_5,	_inst_8 : topological_space H,	H' : Type u_6,	_inst_9 : topological_space H',	G : Type u_7,	_inst_10 : topological_space G,	I : model_with_corners 𝕜 E H,	I' : model_with_corners 𝕜 E' H',	J : model_with_corners 𝕜 F G,	M : Type u_8,	_inst_11 : topological_space M,	_inst_12 : charted_space H M,	M' : Type u_9,	_inst_13 : topological_space M',	_inst_14 : charted_space H' M',	N : Type u_10,	_inst_15 : topological_space N,	_inst_16 : charted_space G N,	n m : with_top ℕ,	h : M ≃ₘ^n⟮I,J⟯ N,	f : N → M',	s : set M,	x : M,	hm : m ≤ n	⊢ times_cont_mdiff_within_at J I' m f (⇑h '' s) (⇑h x) → times_cont_mdiff_within_at I I' m (f ∘ ⇑h) s x
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	E' : Type u_3,	_inst_4 : normed_group E',	_inst_5 : normed_space 𝕜 E',	H : Type u_5,	_inst_8 : topological_space H,	I : model_with_corners 𝕜 E H,	e : E ≃ₘ⟮𝓘(𝕜, E),𝓘(𝕜, E')⟯ E'	⊢ (I.to_local_equiv ≫ e.to_equiv.to_local_equiv).source = set.univ
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	E' : Type u_3,	_inst_4 : normed_group E',	_inst_5 : normed_space 𝕜 E',	H : Type u_5,	_inst_8 : topological_space H,	I : model_with_corners 𝕜 E H,	e : E ≃ₘ⟮𝓘(𝕜, E),𝓘(𝕜, E')⟯ E'	⊢ unique_diff_on 𝕜 (I.to_local_equiv ≫ e.to_equiv.to_local_equiv).target
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v	⊢ stereo_inv_fun hv (stereo_to_fun v ↑x) = x
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v	⊢ ↑(stereo_inv_fun hv (stereo_to_fun v ↑x)) = ↑x
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v	⊢ (∥(2 / (1 - ⇑(inner_right v) ↑x)) • ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x∥ ^ 2 + 4)⁻¹ • 4 • ↑((2 / (1 - ⇑(inner_right v) ↑x)) • ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x) + (∥(2 / (1 - ⇑(inner_right v) ↑x)) • ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x∥ ^ 2 + 4)⁻¹ • (∥(2 / (1 - ⇑(inner_right v) ↑x)) • ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x∥ ^ 2 - 4) • v = ↑x
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x	⊢ (∥(2 / (1 - a)) • ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x∥ ^ 2 + 4)⁻¹ • 4 • ↑((2 / (1 - a)) • ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x) + (∥(2 / (1 - a)) • ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x∥ ^ 2 + 4)⁻¹ • (∥(2 / (1 - a)) • ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x∥ ^ 2 - 4) • v = ↑x
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x	⊢ (∥(2 / (1 - a)) • y∥ ^ 2 + 4)⁻¹ • 4 • ↑((2 / (1 - a)) • y) + (∥(2 / (1 - a)) • y∥ ^ 2 + 4)⁻¹ • (∥(2 / (1 - a)) • y∥ ^ 2 - 4) • v = ↑x
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x	⊢ ↑x = a • v + ↑y
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x	⊢ a • v = ↑(⇑(orthogonal_projection (submodule.span ℝ {v})) ↑x)
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x	⊢ ↑x = a • v + ↑y		E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y	⊢ (∥(2 / (1 - a)) • y∥ ^ 2 + 4)⁻¹ • 4 • ↑((2 / (1 - a)) • y) + (∥(2 / (1 - a)) • y∥ ^ 2 + 4)⁻¹ • (∥(2 / (1 - a)) • y∥ ^ 2 - 4) • v = ↑x
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y	⊢ (∥(2 / (1 - a)) • y∥ ^ 2 + 4)⁻¹ • 4 • ↑((2 / (1 - a)) • y) + (∥(2 / (1 - a)) • y∥ ^ 2 + 4)⁻¹ • (∥(2 / (1 - a)) • y∥ ^ 2 - 4) • v = ↑x
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y,	hvy : has_inner.inner v ↑y = 0	⊢ (∥(2 / (1 - a)) • y∥ ^ 2 + 4)⁻¹ • 4 • ↑((2 / (1 - a)) • y) + (∥(2 / (1 - a)) • y∥ ^ 2 + 4)⁻¹ • (∥(2 / (1 - a)) • y∥ ^ 2 - 4) • v = ↑x
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y,	hvy : has_inner.inner v ↑y = 0	⊢ has_inner.inner (a • v) ↑y = 0
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y,	hvy : has_inner.inner v ↑y = 0	⊢ 1 = a ^ 2 + ∥y∥ ^ 2
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y,	hvy : has_inner.inner v ↑y = 0,	hvy' : has_inner.inner (a • v) ↑y = 0	⊢ 1 = a ^ 2 + ∥y∥ ^ 2
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y,	hvy : has_inner.inner v ↑y = 0,	hvy' : has_inner.inner (a • v) ↑y = 0	⊢ 1 = ∥a • v + ↑y∥ * ∥a • v + ↑y∥		E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y,	hvy : has_inner.inner v ↑y = 0,	hvy' : has_inner.inner (a • v) ↑y = 0	⊢ a ^ 2 = ∥a • v∥ * ∥a • v∥		E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y,	hvy : has_inner.inner v ↑y = 0,	hvy' : has_inner.inner (a • v) ↑y = 0	⊢ ∥y∥ ^ 2 = ∥↑y∥ * ∥↑y∥
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y,	hvy : has_inner.inner v ↑y = 0,	hvy' : has_inner.inner (a • v) ↑y = 0	⊢ 1 = ∥a • v + ↑y∥ * ∥a • v + ↑y∥
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y,	hvy : has_inner.inner v ↑y = 0,	hvy' : has_inner.inner (a • v) ↑y = 0	⊢ a ^ 2 = ∥a • v∥ * ∥a • v∥		E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y,	hvy : has_inner.inner v ↑y = 0,	hvy' : has_inner.inner (a • v) ↑y = 0	⊢ ∥y∥ ^ 2 = ∥↑y∥ * ∥↑y∥
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y,	hvy : has_inner.inner v ↑y = 0,	hvy' : has_inner.inner (a • v) ↑y = 0	⊢ a ^ 2 = ∥a • v∥ * ∥a • v∥
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y,	hvy : has_inner.inner v ↑y = 0	⊢ 1 = a ^ 2 + ∥y∥ ^ 2		E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y,	hvy : has_inner.inner v ↑y = 0,	pythag : 1 = a ^ 2 + ∥y∥ ^ 2	⊢ (∥(2 / (1 - a)) • y∥ ^ 2 + 4)⁻¹ • 4 • ↑((2 / (1 - a)) • y) + (∥(2 / (1 - a)) • y∥ ^ 2 + 4)⁻¹ • (∥(2 / (1 - a)) • y∥ ^ 2 - 4) • v = ↑x
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y,	hvy : has_inner.inner v ↑y = 0,	hvy' : has_inner.inner (a • v) ↑y = 0	⊢ ∥y∥ ^ 2 = ∥↑y∥ * ∥↑y∥
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y,	hvy : has_inner.inner v ↑y = 0,	pythag : 1 = a ^ 2 + ∥y∥ ^ 2	⊢ (∥(2 / (1 - a)) • y∥ ^ 2 + 4)⁻¹ • 4 • ↑((2 / (1 - a)) • y) + (∥(2 / (1 - a)) • y∥ ^ 2 + 4)⁻¹ • (∥(2 / (1 - a)) • y∥ ^ 2 - 4) • v = ↑x
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y,	hvy : has_inner.inner v ↑y = 0,	pythag : 1 = a ^ 2 + ∥y∥ ^ 2	⊢ 1 - a ≠ 0
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y,	hvy : has_inner.inner v ↑y = 0,	pythag : 1 = a ^ 2 + ∥y∥ ^ 2	⊢ ∥↑x∥ = 1
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y,	hvy : has_inner.inner v ↑y = 0,	pythag : 1 = a ^ 2 + ∥y∥ ^ 2	⊢ 1 - a ≠ 0		E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y,	hvy : has_inner.inner v ↑y = 0,	pythag : 1 = a ^ 2 + ∥y∥ ^ 2,	ha : 1 - a ≠ 0	⊢ (∥(2 / (1 - a)) • y∥ ^ 2 + 4)⁻¹ • 4 • ↑((2 / (1 - a)) • y) + (∥(2 / (1 - a)) • y∥ ^ 2 + 4)⁻¹ • (∥(2 / (1 - a)) • y∥ ^ 2 - 4) • v = ↑x
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y,	hvy : has_inner.inner v ↑y = 0,	pythag : 1 = a ^ 2 + ∥y∥ ^ 2,	this : a < 1	⊢ 1 - a ≠ 0
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y,	hvy : has_inner.inner v ↑y = 0,	pythag : 1 = a ^ 2 + ∥y∥ ^ 2,	ha : 1 - a ≠ 0	⊢ (∥(2 / (1 - a)) • y∥ ^ 2 + 4)⁻¹ • 4 • ↑((2 / (1 - a)) • y) + (∥(2 / (1 - a)) • y∥ ^ 2 + 4)⁻¹ • (∥(2 / (1 - a)) • y∥ ^ 2 - 4) • v = ↑x
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y,	hvy : has_inner.inner v ↑y = 0,	pythag : 1 = a ^ 2 + ∥y∥ ^ 2,	ha : 1 - a ≠ 0	⊢ 2 ^ 2 * ∥y∥ ^ 2 + 4 * (1 - a) ^ 2 ≠ 0
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y,	hvy : has_inner.inner v ↑y = 0,	pythag : 1 = a ^ 2 + ∥y∥ ^ 2,	ha : 1 - a ≠ 0	⊢ 0 < 2 ^ 2 * ∥y∥ ^ 2 + 4 * (1 - a) ^ 2
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y,	hvy : has_inner.inner v ↑y = 0,	pythag : 1 = a ^ 2 + ∥y∥ ^ 2,	ha : 1 - a ≠ 0,	this : 0 ≤ ∥↑y∥	⊢ 0 < 2 ^ 2 * ∥y∥ ^ 2 + 4 * (1 - a) ^ 2
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y,	hvy : has_inner.inner v ↑y = 0,	pythag : 1 = a ^ 2 + ∥y∥ ^ 2,	ha : 1 - a ≠ 0	⊢ 2 ^ 2 * ∥y∥ ^ 2 + 4 * (1 - a) ^ 2 ≠ 0		E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y,	hvy : has_inner.inner v ↑y = 0,	pythag : 1 = a ^ 2 + ∥y∥ ^ 2,	ha : 1 - a ≠ 0,	this : 2 ^ 2 * ∥y∥ ^ 2 + 4 * (1 - a) ^ 2 ≠ 0	⊢ (∥(2 / (1 - a)) • y∥ ^ 2 + 4)⁻¹ • 4 • ↑((2 / (1 - a)) • y) + (∥(2 / (1 - a)) • y∥ ^ 2 + 4)⁻¹ • (∥(2 / (1 - a)) • y∥ ^ 2 - 4) • v = ↑x
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y,	hvy : has_inner.inner v ↑y = 0,	pythag : 1 = a ^ 2 + ∥y∥ ^ 2,	ha : 1 - a ≠ 0,	this : 0 ≤ ∥↑y∥,	this : 0 < (1 - a) ^ 2	⊢ 0 < 2 ^ 2 * ∥y∥ ^ 2 + 4 * (1 - a) ^ 2
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y,	hvy : has_inner.inner v ↑y = 0,	pythag : 1 = a ^ 2 + ∥y∥ ^ 2,	ha : 1 - a ≠ 0,	this : 2 ^ 2 * ∥y∥ ^ 2 + 4 * (1 - a) ^ 2 ≠ 0	⊢ (∥(2 / (1 - a)) • y∥ ^ 2 + 4)⁻¹ • 4 • ↑((2 / (1 - a)) • y) + (∥(2 / (1 - a)) • y∥ ^ 2 + 4)⁻¹ • (∥(2 / (1 - a)) • y∥ ^ 2 - 4) • v = ↑x
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y,	hvy : has_inner.inner v ↑y = 0,	pythag : 1 = a ^ 2 + ∥y∥ ^ 2,	ha : 1 - a ≠ 0,	this : 2 ^ 2 * ∥y∥ ^ 2 + 4 * (1 - a) ^ 2 ≠ 0	⊢ (2 ^ 2 / (1 - a) ^ 2 * ∥y∥ ^ 2 + 4)⁻¹ * 4 * (2 / (1 - a)) = 1
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y,	hvy : has_inner.inner v ↑y = 0,	pythag : 1 = a ^ 2 + ∥y∥ ^ 2,	ha : 1 - a ≠ 0,	this : 2 ^ 2 * ∥y∥ ^ 2 + 4 * (1 - a) ^ 2 ≠ 0	⊢ (2 ^ 2 / (1 - a) ^ 2 * ∥y∥ ^ 2 + 4)⁻¹ * 4 * (2 / (1 - a)) = 1		E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y,	hvy : has_inner.inner v ↑y = 0,	pythag : 1 = a ^ 2 + ∥y∥ ^ 2,	ha : 1 - a ≠ 0,	this : 2 ^ 2 * ∥y∥ ^ 2 + 4 * (1 - a) ^ 2 ≠ 0,	h₁ : (2 ^ 2 / (1 - a) ^ 2 * ∥y∥ ^ 2 + 4)⁻¹ * 4 * (2 / (1 - a)) = 1	⊢ (∥(2 / (1 - a)) • y∥ ^ 2 + 4)⁻¹ • 4 • ↑((2 / (1 - a)) • y) + (∥(2 / (1 - a)) • y∥ ^ 2 + 4)⁻¹ • (∥(2 / (1 - a)) • y∥ ^ 2 - 4) • v = ↑x
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y,	hvy : has_inner.inner v ↑y = 0,	pythag : 1 = a ^ 2 + ∥y∥ ^ 2,	ha : 1 - a ≠ 0,	this : 2 ^ 2 * ∥y∥ ^ 2 + 4 * (1 - a) ^ 2 ≠ 0	⊢ (1 - a) ^ 2 * 4 * 2 = (2 ^ 2 * ∥y∥ ^ 2 + 4 * (1 - a) ^ 2) * (1 - a)
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y,	hvy : has_inner.inner v ↑y = 0,	pythag : 1 = a ^ 2 + ∥y∥ ^ 2,	ha : 1 - a ≠ 0,	this : 2 ^ 2 * ∥y∥ ^ 2 + 4 * (1 - a) ^ 2 ≠ 0,	h₁ : (2 ^ 2 / (1 - a) ^ 2 * ∥y∥ ^ 2 + 4)⁻¹ * 4 * (2 / (1 - a)) = 1	⊢ (∥(2 / (1 - a)) • y∥ ^ 2 + 4)⁻¹ • 4 • ↑((2 / (1 - a)) • y) + (∥(2 / (1 - a)) • y∥ ^ 2 + 4)⁻¹ • (∥(2 / (1 - a)) • y∥ ^ 2 - 4) • v = ↑x
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y,	hvy : has_inner.inner v ↑y = 0,	pythag : 1 = a ^ 2 + ∥y∥ ^ 2,	ha : 1 - a ≠ 0,	this : 2 ^ 2 * ∥y∥ ^ 2 + 4 * (1 - a) ^ 2 ≠ 0,	h₁ : (2 ^ 2 / (1 - a) ^ 2 * ∥y∥ ^ 2 + 4)⁻¹ * 4 * (2 / (1 - a)) = 1	⊢ (2 ^ 2 / (1 - a) ^ 2 * ∥y∥ ^ 2 + 4)⁻¹ * (2 ^ 2 / (1 - a) ^ 2 * ∥y∥ ^ 2 - 4) = a
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y,	hvy : has_inner.inner v ↑y = 0,	pythag : 1 = a ^ 2 + ∥y∥ ^ 2,	ha : 1 - a ≠ 0,	this : 2 ^ 2 * ∥y∥ ^ 2 + 4 * (1 - a) ^ 2 ≠ 0,	h₁ : (2 ^ 2 / (1 - a) ^ 2 * ∥y∥ ^ 2 + 4)⁻¹ * 4 * (2 / (1 - a)) = 1	⊢ (1 - a) ^ 2 * (2 ^ 2 * ∥y∥ ^ 2 - (1 - a) ^ 2 * 4) = a * ((2 ^ 2 * ∥y∥ ^ 2 + 4 * (1 - a) ^ 2) * (1 - a) ^ 2)
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y,	hvy : has_inner.inner v ↑y = 0,	pythag : 1 = a ^ 2 + ∥y∥ ^ 2,	ha : 1 - a ≠ 0,	this : 2 ^ 2 * ∥y∥ ^ 2 + 4 * (1 - a) ^ 2 ≠ 0,	h₁ : (2 ^ 2 / (1 - a) ^ 2 * ∥y∥ ^ 2 + 4)⁻¹ * 4 * (2 / (1 - a)) = 1	⊢ (1 - a) ^ 2 * (2 ^ 2 * ∥y∥ ^ 2 - (1 - a) ^ 2 * 4) = (1 - a) ^ 2 * (a * (2 ^ 2 * ∥y∥ ^ 2 + 4 * (1 - a) ^ 2))
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y,	hvy : has_inner.inner v ↑y = 0,	pythag : 1 = a ^ 2 + ∥y∥ ^ 2,	ha : 1 - a ≠ 0,	this : 2 ^ 2 * ∥y∥ ^ 2 + 4 * (1 - a) ^ 2 ≠ 0,	h₁ : (2 ^ 2 / (1 - a) ^ 2 * ∥y∥ ^ 2 + 4)⁻¹ * 4 * (2 / (1 - a)) = 1	⊢ (1 - a) ^ 2 * (2 ^ 2 * ∥y∥ ^ 2 - (1 - a) ^ 2 * 4) = (1 - a) ^ 2 * (a * (2 ^ 2 * ∥y∥ ^ 2 + 4 * (1 - a) ^ 2))		E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y,	hvy : has_inner.inner v ↑y = 0,	pythag : 1 = a ^ 2 + ∥y∥ ^ 2,	ha : 1 - a ≠ 0,	this : 2 ^ 2 * ∥y∥ ^ 2 + 4 * (1 - a) ^ 2 ≠ 0,	h₁ : (2 ^ 2 / (1 - a) ^ 2 * ∥y∥ ^ 2 + 4)⁻¹ * 4 * (2 / (1 - a)) = 1	⊢ (1 - a) ^ 2 * (a * (2 ^ 2 * ∥y∥ ^ 2 + 4 * (1 - a) ^ 2)) = a * ((2 ^ 2 * ∥y∥ ^ 2 + 4 * (1 - a) ^ 2) * (1 - a) ^ 2)
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y,	hvy : has_inner.inner v ↑y = 0,	pythag : 1 = a ^ 2 + ∥y∥ ^ 2,	ha : 1 - a ≠ 0,	this : 2 ^ 2 * ∥y∥ ^ 2 + 4 * (1 - a) ^ 2 ≠ 0,	h₁ : (2 ^ 2 / (1 - a) ^ 2 * ∥y∥ ^ 2 + 4)⁻¹ * 4 * (2 / (1 - a)) = 1	⊢ 2 ^ 2 * ∥y∥ ^ 2 - (1 - a) ^ 2 * 4 = a * (2 ^ 2 * ∥y∥ ^ 2 + 4 * (1 - a) ^ 2)
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y,	hvy : has_inner.inner v ↑y = 0,	pythag : 1 = a ^ 2 + ∥y∥ ^ 2,	ha : 1 - a ≠ 0,	this : 2 ^ 2 * ∥y∥ ^ 2 + 4 * (1 - a) ^ 2 ≠ 0,	h₁ : (2 ^ 2 / (1 - a) ^ 2 * ∥y∥ ^ 2 + 4)⁻¹ * 4 * (2 / (1 - a)) = 1	⊢ (1 - a) ^ 2 * (a * (2 ^ 2 * ∥y∥ ^ 2 + 4 * (1 - a) ^ 2)) = a * ((2 ^ 2 * ∥y∥ ^ 2 + 4 * (1 - a) ^ 2) * (1 - a) ^ 2)
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y,	hvy : has_inner.inner v ↑y = 0,	pythag : 1 = a ^ 2 + ∥y∥ ^ 2,	ha : 1 - a ≠ 0,	this : 2 ^ 2 * ∥y∥ ^ 2 + 4 * (1 - a) ^ 2 ≠ 0,	h₁ : (2 ^ 2 / (1 - a) ^ 2 * ∥y∥ ^ 2 + 4)⁻¹ * 4 * (2 / (1 - a)) = 1	⊢ (2 ^ 2 / (1 - a) ^ 2 * ∥y∥ ^ 2 + 4)⁻¹ * (2 ^ 2 / (1 - a) ^ 2 * ∥y∥ ^ 2 - 4) = a		E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y,	hvy : has_inner.inner v ↑y = 0,	pythag : 1 = a ^ 2 + ∥y∥ ^ 2,	ha : 1 - a ≠ 0,	this : 2 ^ 2 * ∥y∥ ^ 2 + 4 * (1 - a) ^ 2 ≠ 0,	h₁ : (2 ^ 2 / (1 - a) ^ 2 * ∥y∥ ^ 2 + 4)⁻¹ * 4 * (2 / (1 - a)) = 1,	h₂ : (2 ^ 2 / (1 - a) ^ 2 * ∥y∥ ^ 2 + 4)⁻¹ * (2 ^ 2 / (1 - a) ^ 2 * ∥y∥ ^ 2 - 4) = a	⊢ (∥(2 / (1 - a)) • y∥ ^ 2 + 4)⁻¹ • 4 • ↑((2 / (1 - a)) • y) + (∥(2 / (1 - a)) • y∥ ^ 2 + 4)⁻¹ • (∥(2 / (1 - a)) • y∥ ^ 2 - 4) • v = ↑x
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y,	hvy : has_inner.inner v ↑y = 0,	pythag : 1 = a ^ 2 + ∥y∥ ^ 2,	ha : 1 - a ≠ 0,	this : 2 ^ 2 * ∥y∥ ^ 2 + 4 * (1 - a) ^ 2 ≠ 0,	h₁ : (2 ^ 2 / (1 - a) ^ 2 * ∥y∥ ^ 2 + 4)⁻¹ * 4 * (2 / (1 - a)) = 1	⊢ (1 - a) ^ 2 * (a * (2 ^ 2 * ∥y∥ ^ 2 + 4 * (1 - a) ^ 2)) = a * ((2 ^ 2 * ∥y∥ ^ 2 + 4 * (1 - a) ^ 2) * (1 - a) ^ 2)
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y,	hvy : has_inner.inner v ↑y = 0,	pythag : 1 = a ^ 2 + ∥y∥ ^ 2,	ha : 1 - a ≠ 0,	this : 2 ^ 2 * ∥y∥ ^ 2 + 4 * (1 - a) ^ 2 ≠ 0,	h₁ : (2 ^ 2 / (1 - a) ^ 2 * ∥y∥ ^ 2 + 4)⁻¹ * 4 * (2 / (1 - a)) = 1,	h₂ : (2 ^ 2 / (1 - a) ^ 2 * ∥y∥ ^ 2 + 4)⁻¹ * (2 ^ 2 / (1 - a) ^ 2 * ∥y∥ ^ 2 - 4) = a	⊢ (∥(2 / (1 - a)) • y∥ ^ 2 + 4)⁻¹ • 4 • ↑((2 / (1 - a)) • y) + (∥(2 / (1 - a)) • y∥ ^ 2 + 4)⁻¹ • (∥(2 / (1 - a)) • y∥ ^ 2 - 4) • v = ↑x
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y,	hvy : has_inner.inner v ↑y = 0,	pythag : 1 = a ^ 2 + ∥y∥ ^ 2,	ha : 1 - a ≠ 0,	this : 2 ^ 2 * ∥y∥ ^ 2 + 4 * (1 - a) ^ 2 ≠ 0,	h₁ : (2 ^ 2 / (1 - a) ^ 2 * ∥y∥ ^ 2 + 4)⁻¹ * 4 * (2 / (1 - a)) = 1,	h₂ : (2 ^ 2 / (1 - a) ^ 2 * ∥y∥ ^ 2 + 4)⁻¹ * (2 ^ 2 / (1 - a) ^ 2 * ∥y∥ ^ 2 - 4) = a	⊢ (∥(2 / (1 - a)) • y∥ ^ 2 + 4)⁻¹ • 4 • ↑((2 / (1 - a)) • y) + (∥(2 / (1 - a)) • y∥ ^ 2 + 4)⁻¹ • (∥(2 / (1 - a)) • y∥ ^ 2 - 4) • v = ((2 ^ 2 / (1 - a) ^ 2 * ∥y∥ ^ 2 + 4)⁻¹ * 4 * (2 / (1 - a))) • ↑y + ((2 ^ 2 / (1 - a) ^ 2 * ∥y∥ ^ 2 + 4)⁻¹ * (2 ^ 2 / (1 - a) ^ 2 * ∥y∥ ^ 2 - 4)) • v
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y,	hvy : has_inner.inner v ↑y = 0,	pythag : 1 = a ^ 2 + ∥y∥ ^ 2,	ha : 1 - a ≠ 0,	this : 2 ^ 2 * ∥y∥ ^ 2 + 4 * (1 - a) ^ 2 ≠ 0,	h₁ : (2 ^ 2 / (1 - a) ^ 2 * ∥y∥ ^ 2 + 4)⁻¹ * 4 * (2 / (1 - a)) = 1,	h₂ : (2 ^ 2 / (1 - a) ^ 2 * ∥y∥ ^ 2 + 4)⁻¹ * (2 ^ 2 / (1 - a) ^ 2 * ∥y∥ ^ 2 - 4) = a	⊢ (∥(2 / (1 - a)) • y∥ ^ 2 + 4)⁻¹ • 4 • ↑((2 / (1 - a)) • y) + (∥(2 / (1 - a)) • y∥ ^ 2 + 4)⁻¹ • (∥(2 / (1 - a)) • y∥ ^ 2 - 4) • v = ((2 ^ 2 / (1 - a) ^ 2 * ∥y∥ ^ 2 + 4)⁻¹ * 4 * (2 / (1 - a))) • ↑y + ((2 ^ 2 / (1 - a) ^ 2 * ∥y∥ ^ 2 + 4)⁻¹ * (2 ^ 2 / (1 - a) ^ 2 * ∥y∥ ^ 2 - 4)) • v		E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y,	hvy : has_inner.inner v ↑y = 0,	pythag : 1 = a ^ 2 + ∥y∥ ^ 2,	ha : 1 - a ≠ 0,	this : 2 ^ 2 * ∥y∥ ^ 2 + 4 * (1 - a) ^ 2 ≠ 0,	h₁ : (2 ^ 2 / (1 - a) ^ 2 * ∥y∥ ^ 2 + 4)⁻¹ * 4 * (2 / (1 - a)) = 1,	h₂ : (2 ^ 2 / (1 - a) ^ 2 * ∥y∥ ^ 2 + 4)⁻¹ * (2 ^ 2 / (1 - a) ^ 2 * ∥y∥ ^ 2 - 4) = a	⊢ ↑x = 1 • ↑y + a • v
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	v : E,	_inst_2 : complete_space E,	hv : ∥v∥ = 1,	x : ↥(metric.sphere 0 1),	hx : ↑x ≠ v,	a : ℝ := ⇑(inner_right v) ↑x,	y : ↥(submodule.span ℝ {v})ᗮ := ⇑(orthogonal_projection (submodule.span ℝ {v})ᗮ) ↑x,	split : ↑x = a • v + ↑y,	hvy : has_inner.inner v ↑y = 0,	pythag : 1 = a ^ 2 + ∥y∥ ^ 2,	ha : 1 - a ≠ 0,	this : 2 ^ 2 * ∥y∥ ^ 2 + 4 * (1 - a) ^ 2 ≠ 0,	h₁ : (2 ^ 2 / (1 - a) ^ 2 * ∥y∥ ^ 2 + 4)⁻¹ * 4 * (2 / (1 - a)) = 1,	h₂ : (2 ^ 2 / (1 - a) ^ 2 * ∥y∥ ^ 2 + 4)⁻¹ * (2 ^ 2 / (1 - a) ^ 2 * ∥y∥ ^ 2 - 4) = a	⊢ ↑x = 1 • ↑y + a • v
H : Type u_1,	M : Type u_2,	_inst_1 : topological_space H,	_inst_2 : topological_space M,	_inst_3 : charted_space H M,	G : structure_groupoid H,	x : M,	Q : (H → H) → set H → H → Prop,	_inst_7 : has_groupoid M G,	hG : G.local_invariant_prop G Q,	hQ : ∀ (y : H), Q id set.univ y	⊢ ⇑(charted_space.chart_at H x) x ∈ (charted_space.chart_at H x).to_local_equiv.target
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	M : Type u_4,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	x : M,	s : set M,	xs : x ∈ s,	hs : is_open s	⊢ unique_mdiff_within_at I s x
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	M : Type u_4,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	x : M,	s : set M,	xs : x ∈ s,	hs : is_open s,	this : unique_mdiff_within_at I (set.univ ∩ s) x	⊢ unique_mdiff_within_at I s x
𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	ι : Type v,	_inst_2 : fintype ι,	E : ι → Type w,	_inst_3 : Π (i : ι), normed_group (E i),	_inst_4 : Π (i : ι), normed_space 𝕜 (E i),	H : ι → Type u',	_inst_5 : Π (i : ι), topological_space (H i),	I : Π (i : ι), model_with_corners 𝕜 (E i) (H i)	⊢ (local_equiv.pi (λ (i : ι), (I i).to_local_equiv)).source = set.univ
𝕜 : Type ?,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type ?,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E	⊢ set.range ⇑𝓘(𝕜, E) = set.univ
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H	⊢ times_cont_diff_groupoid 0 I = continuous_groupoid H
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H	⊢ ⊤ ≤ times_cont_diff_groupoid 0 I
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	u : local_homeomorph H H,	hu : u ∈ ⊤.members	⊢ u ∈ (times_cont_diff_groupoid 0 I).members
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	u : local_homeomorph H H,	hu : u ∈ ⊤.members	⊢ u ∈ times_cont_diff_groupoid 0 I
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	u : local_homeomorph H H,	hu : u ∈ ⊤.members	⊢ {property := λ (f : H → H) (s : set H), times_cont_diff_on 𝕜 0 (⇑I ∘ f ∘ ⇑(I.symm)) (⇑(I.symm) ⁻¹' s ∩ set.range ⇑I), comp := _, id_mem := _, locality := _, congr := _}.property ⇑u u.to_local_equiv.source ∧ {property := λ (f : H → H) (s : set H), times_cont_diff_on 𝕜 0 (⇑I ∘ f ∘ ⇑(I.symm)) (⇑(I.symm) ⁻¹' s ∩ set.range ⇑I), comp := _, id_mem := _, locality := _, congr := _}.property ⇑(u.symm) u.to_local_equiv.target
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	u : local_homeomorph H H,	hu : u ∈ ⊤.members	⊢ continuous_on (⇑I ∘ ⇑u ∘ ⇑(I.symm)) (⇑(I.symm) ⁻¹' u.to_local_equiv.source ∩ set.range ⇑I) ∧ continuous_on (⇑I ∘ ⇑(u.symm) ∘ ⇑(I.symm)) (⇑(I.symm) ⁻¹' u.to_local_equiv.target ∩ set.range ⇑I)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	u : local_homeomorph H H,	hu : u ∈ ⊤.members	⊢ continuous_on (⇑I ∘ ⇑u ∘ ⇑(I.symm)) (⇑(I.symm) ⁻¹' u.to_local_equiv.source ∩ set.range ⇑I)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	u : local_homeomorph H H,	hu : u ∈ ⊤.members	⊢ continuous_on (⇑u ∘ ⇑(I.symm)) (⇑(I.symm) ⁻¹' u.to_local_equiv.source ∩ set.range ⇑I)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	u : local_homeomorph H H,	hu : u ∈ ⊤.members	⊢ continuous_on (⇑I ∘ ⇑u ∘ ⇑(I.symm)) (⇑(I.symm) ⁻¹' u.to_local_equiv.source ∩ set.range ⇑I)		𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	u : local_homeomorph H H,	hu : u ∈ ⊤.members	⊢ continuous_on (⇑I ∘ ⇑(u.symm) ∘ ⇑(I.symm)) (⇑(I.symm) ⁻¹' u.to_local_equiv.target ∩ set.range ⇑I)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	u : local_homeomorph H H,	hu : u ∈ ⊤.members	⊢ continuous_on (⇑I ∘ ⇑(u.symm) ∘ ⇑(I.symm)) (⇑(I.symm) ⁻¹' u.to_local_equiv.target ∩ set.range ⇑I)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	u : local_homeomorph H H,	hu : u ∈ ⊤.members	⊢ continuous_on (⇑(u.symm) ∘ ⇑(I.symm)) (⇑(I.symm) ⁻¹' u.to_local_equiv.target ∩ set.range ⇑I)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	M : Type u_4,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	Is : smooth_manifold_with_corners I M,	x : M,	n : with_top ℕ,	x' : M,	h : x' ∈ (charted_space.chart_at H x).to_local_equiv.source	⊢ times_cont_mdiff_at I 𝓘(𝕜, E) n ⇑(ext_chart_at I x) x'
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	M : Type u_4,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	Is : smooth_manifold_with_corners I M,	x : M,	n : with_top ℕ,	x' : M,	h : x' ∈ (charted_space.chart_at H x).to_local_equiv.source	⊢ continuous_within_at ⇑(ext_chart_at I x) set.univ x' ∧ times_cont_diff_within_at 𝕜 n (⇑(ext_chart_at 𝓘(𝕜, E) (⇑(ext_chart_at I x) x')) ∘ ⇑(ext_chart_at I x) ∘ ⇑((ext_chart_at I x).symm)) ((ext_chart_at I x).target ∩ ⇑((ext_chart_at I x).symm) ⁻¹' (set.univ ∩ ⇑(ext_chart_at I x) ⁻¹' (ext_chart_at 𝓘(𝕜, E) (⇑(ext_chart_at I x) x')).source)) (⇑(ext_chart_at I x) x')
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	M : Type u_4,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	Is : smooth_manifold_with_corners I M,	x : M,	n : with_top ℕ,	x' : M,	h : x' ∈ (charted_space.chart_at H x).to_local_equiv.source	⊢ x' ∈ (ext_chart_at I x).source		𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	M : Type u_4,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	Is : smooth_manifold_with_corners I M,	x : M,	n : with_top ℕ,	x' : M,	h : x' ∈ (charted_space.chart_at H x).to_local_equiv.source	⊢ times_cont_diff_within_at 𝕜 n (⇑(ext_chart_at 𝓘(𝕜, E) (⇑(ext_chart_at I x) x')) ∘ ⇑(ext_chart_at I x) ∘ ⇑((ext_chart_at I x).symm)) ((ext_chart_at I x).target ∩ ⇑((ext_chart_at I x).symm) ⁻¹' (set.univ ∩ ⇑(ext_chart_at I x) ⁻¹' (ext_chart_at 𝓘(𝕜, E) (⇑(ext_chart_at I x) x')).source)) (⇑(ext_chart_at I x) x')
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	M : Type u_4,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	Is : smooth_manifold_with_corners I M,	x : M,	n : with_top ℕ,	x' : M,	h : x' ∈ (charted_space.chart_at H x).to_local_equiv.source	⊢ x' ∈ (ext_chart_at I x).source
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	M : Type u_4,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	Is : smooth_manifold_with_corners I M,	x : M,	n : with_top ℕ,	x' : M,	h : x' ∈ (charted_space.chart_at H x).to_local_equiv.source	⊢ times_cont_diff_within_at 𝕜 n (⇑(ext_chart_at 𝓘(𝕜, E) (⇑(ext_chart_at I x) x')) ∘ ⇑(ext_chart_at I x) ∘ ⇑((ext_chart_at I x).symm)) ((ext_chart_at I x).target ∩ ⇑((ext_chart_at I x).symm) ⁻¹' (set.univ ∩ ⇑(ext_chart_at I x) ⁻¹' (ext_chart_at 𝓘(𝕜, E) (⇑(ext_chart_at I x) x')).source)) (⇑(ext_chart_at I x) x')
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	M : Type u_4,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	Is : smooth_manifold_with_corners I M,	x : M,	n : with_top ℕ,	x' : M,	h : x' ∈ (charted_space.chart_at H x).to_local_equiv.source	⊢ times_cont_diff_within_at 𝕜 n (⇑(ext_chart_at 𝓘(𝕜, E) (⇑(ext_chart_at I x) x')) ∘ ⇑(ext_chart_at I x) ∘ ⇑((ext_chart_at I x).symm)) ((ext_chart_at I x).target ∩ ⇑((ext_chart_at I x).symm) ⁻¹' (set.univ ∩ ⇑(ext_chart_at I x) ⁻¹' (ext_chart_at 𝓘(𝕜, E) (⇑(ext_chart_at I x) x')).source)) (⇑(ext_chart_at I x) x')
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	M : Type u_4,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	Is : smooth_manifold_with_corners I M,	x : M,	n : with_top ℕ,	x' : M,	h : x' ∈ (charted_space.chart_at H x).to_local_equiv.source	⊢ ∀ (y : E), y ∈ (ext_chart_at I x).target ∩ ⇑((ext_chart_at I x).symm) ⁻¹' (set.univ ∩ ⇑(ext_chart_at I x) ⁻¹' (ext_chart_at 𝓘(𝕜, E) (⇑(ext_chart_at I x) x')).source) → (⇑(ext_chart_at 𝓘(𝕜, E) (⇑(ext_chart_at I x) x')) ∘ ⇑(ext_chart_at I x) ∘ ⇑((ext_chart_at I x).symm)) y = id y
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	M : Type u_4,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	Is : smooth_manifold_with_corners I M,	x : M,	n : with_top ℕ,	x' : M,	h : x' ∈ (charted_space.chart_at H x).to_local_equiv.source	⊢ ⇑(ext_chart_at I x) x' ∈ (ext_chart_at I x).target ∩ ⇑((ext_chart_at I x).symm) ⁻¹' (set.univ ∩ ⇑(ext_chart_at I x) ⁻¹' (ext_chart_at 𝓘(𝕜, E) (⇑(ext_chart_at I x) x')).source)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	M : Type u_4,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	Is : smooth_manifold_with_corners I M,	E' : Type u_5,	_inst_7 : normed_group E',	_inst_8 : normed_space 𝕜 E',	H' : Type u_6,	_inst_9 : topological_space H',	I' : model_with_corners 𝕜 E' H',	M' : Type u_7,	_inst_10 : topological_space M',	_inst_11 : charted_space H' M',	I's : smooth_manifold_with_corners I' M',	f : M → M',	x : M,	n : ℕ	⊢ times_cont_mdiff_at I I' ↑n f x ↔ ∃ (u : set M) (H_1 : u ∈ 𝓝 x), times_cont_mdiff_on I I' ↑n f u
α : Type u_1,	_inst_1 : group α,	s : set α,	x a : α,	_x : x ∈ s *r a,	_fun_match : x ∈ s *r a → x * a⁻¹ ∈ s,	b : α,	hb : b ∈ s,	eq : (λ (x : α), x * a) b = x	⊢ x * a⁻¹ ∈ s
α : Type u_1,	_inst_1 : group α,	s : set α,	x a : α,	h : x * a⁻¹ ∈ s	⊢ (λ (x : α), x * a) (x * a⁻¹) = x
α : Type u_1,	_inst_1 : group α,	s : subgroup α	⊢ equivalence (λ (x y : α), x⁻¹ * y ∈ s)
α : Type u_1,	_inst_1 : group α,	s : subgroup α	⊢ equivalence (λ (x y : α), x *l ↑s = y *l ↑s)
α : Type u_1,	_inst_1 : group α,	_inst_2 : fintype α,	s : subgroup α,	_inst_3 : fintype ↥s,	_inst_4 : decidable_pred (λ (a : α), a ∈ s)	⊢ fintype.card α = fintype.card (quotient_group.quotient s) * fintype.card ↥s
α : Type u_1,	_inst_1 : group α,	_inst_2 : fintype α,	s : subgroup α,	_inst_3 : fintype ↥s,	_inst_4 : decidable_pred (λ (a : α), a ∈ s)	⊢ fintype.card α = fintype.card (quotient_group.quotient s) * fintype.card ↥s
α : Type u_1,	_inst_1 : group α,	_inst_2 : fintype α,	s : subgroup α,	_inst_3 : fintype ↥s,	_inst_4 : decidable_pred (λ (a : α), a ∈ s)	⊢ fintype.card α = fintype.card (quotient_group.quotient s × ↥s)
α : Type u,	L : list (α × bool),	x : α,	b : bool,	h : free_group.red ((x, b) :: L) list.nil,	h₁ : free_group.red ((x, !b) :: (x, b) :: L) [(x, !b)],	h₂ : free_group.red ((x, !b) :: (x, b) :: L) L,	_let_match : relation.join free_group.red [(x, !b)] L → free_group.red L [(x, !b)],	L' : list (α × bool),	h₁ : free_group.red [(x, !b)] L',	h₂ : free_group.red L L'	⊢ free_group.red L [(x, !b)]
α : Type u,	L : list (α × bool),	x : α,	b : bool,	h : free_group.red ((x, b) :: L) list.nil,	h₁ : free_group.red ((x, !b) :: (x, b) :: L) [(x, !b)],	h₂ : free_group.red ((x, !b) :: (x, b) :: L) L,	_let_match : relation.join free_group.red [(x, !b)] L → free_group.red L [(x, !b)],	L' : list (α × bool),	h₁ : free_group.red [(x, !b)] L',	h₂ : free_group.red L L'	⊢ free_group.red L [(x, !b)]
α : Type u,	L : list (α × bool),	x : α,	b : bool,	h : free_group.red ((x, b) :: L) list.nil,	h₁ : free_group.red ((x, !b) :: (x, b) :: L) [(x, !b)],	h₂ : free_group.red ((x, !b) :: (x, b) :: L) L,	_let_match : relation.join free_group.red [(x, !b)] L → free_group.red L [(x, !b)],	L' : list (α × bool),	h₂ : free_group.red L L',	h₁ : L' = [(x, !b)]	⊢ free_group.red L [(x, !b)]
α : Type u,	L : list (α × bool),	x : α,	b : bool,	h : free_group.red ((x, b) :: L) list.nil,	h₁ : free_group.red ((x, !b) :: (x, b) :: L) [(x, !b)],	h₂ : free_group.red ((x, !b) :: (x, b) :: L) L,	_let_match : relation.join free_group.red [(x, !b)] L → free_group.red L [(x, !b)],	h₂ : free_group.red L [(x, !b)]	⊢ free_group.red L [(x, !b)]
α : Type u,	L : list (α × bool),	x : α,	b : bool,	h : free_group.red ((x, b) :: L) list.nil,	h₁ : free_group.red ((x, !b) :: (x, b) :: L) [(x, !b)],	h₂ : free_group.red ((x, !b) :: (x, b) :: L) L,	_let_match : relation.join free_group.red [(x, !b)] L → free_group.red L [(x, !b)],	L' : list (α × bool),	h₁ : free_group.red [(x, !b)] L',	h₂ : free_group.red L L'	⊢ free_group.red L [(x, !b)]
α : Type ?,	β : Type ?,	e : α ≃ β,	x : free_group α	⊢ ⇑(free_group.map ⇑(e.symm)) (⇑(free_group.map ⇑e) x) = x
α : Type ?,	β : Type ?,	e : α ≃ β,	x : free_group β	⊢ ⇑(free_group.map ⇑e) (⇑(free_group.map ⇑(e.symm)) x) = x
ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι	⊢ function.injective free_product.word.rcons
ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : free_product.word M,	h : w.fst_idx ≠ option.some i,	m' : M i,	w' : free_product.word M,	h' : w'.fst_idx ≠ option.some i,	he : free_product.word.rcons {head := m, tail := w, fst_idx_ne := h} = free_product.word.rcons {head := m', tail := w', fst_idx_ne := h'}	⊢ {head := m, tail := w, fst_idx_ne := h} = {head := m', tail := w', fst_idx_ne := h'}
ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : free_product.word M,	h : w.fst_idx ≠ option.some i,	m' : M i,	w' : free_product.word M,	h' : w'.fst_idx ≠ option.some i,	he : free_product.word.rcons {head := m, tail := w, fst_idx_ne := h} = free_product.word.rcons {head := m', tail := w', fst_idx_ne := h'}	⊢ {head := m, tail := w, fst_idx_ne := h} = {head := m', tail := w', fst_idx_ne := h'}
ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : free_product.word M,	h : w.fst_idx ≠ option.some i,	m' : M i,	w' : free_product.word M,	h' : w'.fst_idx ≠ option.some i,	he : free_product.word.rcons {head := m, tail := w, fst_idx_ne := h} = free_product.word.rcons {head := m', tail := w', fst_idx_ne := h'},	hm : m = 1	⊢ {head := m, tail := w, fst_idx_ne := h} = {head := m', tail := w', fst_idx_ne := h'}
ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : free_product.word M,	h : w.fst_idx ≠ option.some i,	m' : M i,	w' : free_product.word M,	h' : w'.fst_idx ≠ option.some i,	he : free_product.word.rcons {head := m, tail := w, fst_idx_ne := h} = free_product.word.rcons {head := m', tail := w', fst_idx_ne := h'},	hm : ¬m = 1	⊢ {head := m, tail := w, fst_idx_ne := h} = {head := m', tail := w', fst_idx_ne := h'}
ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : free_product.word M,	h : w.fst_idx ≠ option.some i,	m' : M i,	w' : free_product.word M,	h' : w'.fst_idx ≠ option.some i,	hm : m = 1,	hm' : m' = 1,	he : w = w'	⊢ {head := m, tail := w, fst_idx_ne := h} = {head := m', tail := w', fst_idx_ne := h'}
ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : free_product.word M,	h : w.fst_idx ≠ option.some i,	m' : M i,	w' : free_product.word M,	h' : w'.fst_idx ≠ option.some i,	he : free_product.word.rcons {head := m, tail := w, fst_idx_ne := h} = free_product.word.rcons {head := m', tail := w', fst_idx_ne := h'},	hm : m = 1,	hm' : m' = 1	⊢ {head := m, tail := w, fst_idx_ne := h} = {head := m', tail := w', fst_idx_ne := h'}		ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : free_product.word M,	h : w.fst_idx ≠ option.some i,	m' : M i,	w' : free_product.word M,	h' : w'.fst_idx ≠ option.some i,	he : free_product.word.rcons {head := m, tail := w, fst_idx_ne := h} = free_product.word.rcons {head := m', tail := w', fst_idx_ne := h'},	hm : m = 1,	hm' : ¬m' = 1	⊢ {head := m, tail := w, fst_idx_ne := h} = {head := m', tail := w', fst_idx_ne := h'}		ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : free_product.word M,	h : w.fst_idx ≠ option.some i,	m' : M i,	w' : free_product.word M,	h' : w'.fst_idx ≠ option.some i,	he : free_product.word.rcons {head := m, tail := w, fst_idx_ne := h} = free_product.word.rcons {head := m', tail := w', fst_idx_ne := h'},	hm : ¬m = 1,	hm' : m' = 1	⊢ {head := m, tail := w, fst_idx_ne := h} = {head := m', tail := w', fst_idx_ne := h'}		ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : free_product.word M,	h : w.fst_idx ≠ option.some i,	m' : M i,	w' : free_product.word M,	h' : w'.fst_idx ≠ option.some i,	he : free_product.word.rcons {head := m, tail := w, fst_idx_ne := h} = free_product.word.rcons {head := m', tail := w', fst_idx_ne := h'},	hm : ¬m = 1,	hm' : ¬m' = 1	⊢ {head := m, tail := w, fst_idx_ne := h} = {head := m', tail := w', fst_idx_ne := h'}
ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : free_product.word M,	h : w.fst_idx ≠ option.some i,	m' : M i,	w' : free_product.word M,	h' : w'.fst_idx ≠ option.some i,	he : free_product.word.rcons {head := m, tail := w, fst_idx_ne := h} = free_product.word.rcons {head := m', tail := w', fst_idx_ne := h'},	hm : m = 1,	hm' : m' = 1	⊢ {head := m, tail := w, fst_idx_ne := h} = {head := m', tail := w', fst_idx_ne := h'}
ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : free_product.word M,	h : w.fst_idx ≠ option.some i,	m' : M i,	w' : free_product.word M,	h' : w'.fst_idx ≠ option.some i,	he : free_product.word.rcons {head := m, tail := w, fst_idx_ne := h} = free_product.word.rcons {head := m', tail := w', fst_idx_ne := h'},	hm : m = 1,	hm' : ¬m' = 1	⊢ false
ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : free_product.word M,	h : w.fst_idx ≠ option.some i,	m' : M i,	w' : free_product.word M,	h' : w'.fst_idx ≠ option.some i,	he : free_product.word.rcons {head := m, tail := w, fst_idx_ne := h} = free_product.word.rcons {head := m', tail := w', fst_idx_ne := h'},	hm : m = 1,	hm' : ¬m' = 1	⊢ {head := m, tail := w, fst_idx_ne := h} = {head := m', tail := w', fst_idx_ne := h'}
ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : free_product.word M,	h : w.fst_idx ≠ option.some i,	m' : M i,	w' : free_product.word M,	h' : w'.fst_idx ≠ option.some i,	hm : m = 1,	hm' : ¬m' = 1,	he : w = {to_list := ⟨i, m'⟩ :: w'.to_list, ne_one := _, chain_ne := _}	⊢ false
ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : free_product.word M,	m' : M i,	w' : free_product.word M,	h' : w'.fst_idx ≠ option.some i,	hm : m = 1,	hm' : ¬m' = 1,	he : w = {to_list := ⟨i, m'⟩ :: w'.to_list, ne_one := _, chain_ne := _},	h : {to_list := ⟨i, m'⟩ :: w'.to_list, ne_one := _, chain_ne := _}.fst_idx ≠ option.some i	⊢ false
ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : free_product.word M,	h : w.fst_idx ≠ option.some i,	m' : M i,	w' : free_product.word M,	h' : w'.fst_idx ≠ option.some i,	he : free_product.word.rcons {head := m, tail := w, fst_idx_ne := h} = free_product.word.rcons {head := m', tail := w', fst_idx_ne := h'},	hm : m = 1,	hm' : ¬m' = 1	⊢ {head := m, tail := w, fst_idx_ne := h} = {head := m', tail := w', fst_idx_ne := h'}		ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : free_product.word M,	h : w.fst_idx ≠ option.some i,	m' : M i,	w' : free_product.word M,	h' : w'.fst_idx ≠ option.some i,	he : free_product.word.rcons {head := m, tail := w, fst_idx_ne := h} = free_product.word.rcons {head := m', tail := w', fst_idx_ne := h'},	hm : ¬m = 1,	hm' : m' = 1	⊢ {head := m, tail := w, fst_idx_ne := h} = {head := m', tail := w', fst_idx_ne := h'}		ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : free_product.word M,	h : w.fst_idx ≠ option.some i,	m' : M i,	w' : free_product.word M,	h' : w'.fst_idx ≠ option.some i,	he : free_product.word.rcons {head := m, tail := w, fst_idx_ne := h} = free_product.word.rcons {head := m', tail := w', fst_idx_ne := h'},	hm : ¬m = 1,	hm' : ¬m' = 1	⊢ {head := m, tail := w, fst_idx_ne := h} = {head := m', tail := w', fst_idx_ne := h'}
ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : free_product.word M,	h : w.fst_idx ≠ option.some i,	m' : M i,	w' : free_product.word M,	h' : w'.fst_idx ≠ option.some i,	he : free_product.word.rcons {head := m, tail := w, fst_idx_ne := h} = free_product.word.rcons {head := m', tail := w', fst_idx_ne := h'},	hm : ¬m = 1,	hm' : m' = 1	⊢ false
ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : free_product.word M,	h : w.fst_idx ≠ option.some i,	m' : M i,	w' : free_product.word M,	h' : w'.fst_idx ≠ option.some i,	he : free_product.word.rcons {head := m, tail := w, fst_idx_ne := h} = free_product.word.rcons {head := m', tail := w', fst_idx_ne := h'},	hm : ¬m = 1,	hm' : m' = 1	⊢ {head := m, tail := w, fst_idx_ne := h} = {head := m', tail := w', fst_idx_ne := h'}
ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : free_product.word M,	h : w.fst_idx ≠ option.some i,	m' : M i,	w' : free_product.word M,	h' : w'.fst_idx ≠ option.some i,	hm : ¬m = 1,	hm' : m' = 1,	he : {to_list := ⟨i, m⟩ :: w.to_list, ne_one := _, chain_ne := _} = w'	⊢ false
ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : free_product.word M,	h : w.fst_idx ≠ option.some i,	m' : M i,	w' : free_product.word M,	hm : ¬m = 1,	hm' : m' = 1,	he : {to_list := ⟨i, m⟩ :: w.to_list, ne_one := _, chain_ne := _} = w',	h' : {to_list := ⟨i, m⟩ :: w.to_list, ne_one := _, chain_ne := _}.fst_idx ≠ option.some i	⊢ false
ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : free_product.word M,	h : w.fst_idx ≠ option.some i,	m' : M i,	w' : free_product.word M,	h' : w'.fst_idx ≠ option.some i,	he : free_product.word.rcons {head := m, tail := w, fst_idx_ne := h} = free_product.word.rcons {head := m', tail := w', fst_idx_ne := h'},	hm : ¬m = 1,	hm' : m' = 1	⊢ {head := m, tail := w, fst_idx_ne := h} = {head := m', tail := w', fst_idx_ne := h'}		ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : free_product.word M,	h : w.fst_idx ≠ option.some i,	m' : M i,	w' : free_product.word M,	h' : w'.fst_idx ≠ option.some i,	he : free_product.word.rcons {head := m, tail := w, fst_idx_ne := h} = free_product.word.rcons {head := m', tail := w', fst_idx_ne := h'},	hm : ¬m = 1,	hm' : ¬m' = 1	⊢ {head := m, tail := w, fst_idx_ne := h} = {head := m', tail := w', fst_idx_ne := h'}
ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : free_product.word M,	h : w.fst_idx ≠ option.some i,	m' : M i,	w' : free_product.word M,	h' : w'.fst_idx ≠ option.some i,	he : free_product.word.rcons {head := m, tail := w, fst_idx_ne := h} = free_product.word.rcons {head := m', tail := w', fst_idx_ne := h'},	hm : ¬m = 1,	hm' : ¬m' = 1	⊢ {head := m, tail := w, fst_idx_ne := h} = {head := m', tail := w', fst_idx_ne := h'}
ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : free_product.word M,	h : w.fst_idx ≠ option.some i,	m' : M i,	w' : free_product.word M,	h' : w'.fst_idx ≠ option.some i,	he : free_product.word.rcons {head := m, tail := w, fst_idx_ne := h} = free_product.word.rcons {head := m', tail := w', fst_idx_ne := h'},	hm : ¬m = 1,	hm' : ¬m' = 1	⊢ m = m' ∧ w.to_list = w'.to_list
ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : free_product.word M,	h : w.fst_idx ≠ option.some i,	m' : M i,	w' : free_product.word M,	h' : w'.fst_idx ≠ option.some i,	he : free_product.word.rcons {head := m, tail := w, fst_idx_ne := h} = free_product.word.rcons {head := m', tail := w', fst_idx_ne := h'},	hm : ¬m = 1,	hm' : ¬m' = 1	⊢ m = m' ∧ w.to_list = w'.to_list		ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : free_product.word M,	h : w.fst_idx ≠ option.some i,	m' : M i,	w' : free_product.word M,	h' : w'.fst_idx ≠ option.some i,	he : free_product.word.rcons {head := m, tail := w, fst_idx_ne := h} = free_product.word.rcons {head := m', tail := w', fst_idx_ne := h'},	hm : ¬m = 1,	hm' : ¬m' = 1,	this : m = m' ∧ w.to_list = w'.to_list	⊢ {head := m, tail := w, fst_idx_ne := h} = {head := m', tail := w', fst_idx_ne := h'}
ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : free_product.word M,	h : w.fst_idx ≠ option.some i,	m' : M i,	w' : free_product.word M,	h' : w'.fst_idx ≠ option.some i,	he : free_product.word.rcons {head := m, tail := w, fst_idx_ne := h} = free_product.word.rcons {head := m', tail := w', fst_idx_ne := h'},	hm : ¬m = 1,	hm' : ¬m' = 1,	this : m = m' ∧ w.to_list = w'.to_list	⊢ {head := m, tail := w, fst_idx_ne := h} = {head := m', tail := w', fst_idx_ne := h'}
ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : free_product.word M,	h : w.fst_idx ≠ option.some i,	w' : free_product.word M,	h' : w'.fst_idx ≠ option.some i,	hm : ¬m = 1,	h : w.to_list = w'.to_list,	he : free_product.word.rcons {head := m, tail := w, fst_idx_ne := h} = free_product.word.rcons {head := m, tail := w', fst_idx_ne := h'},	hm' : ¬m = 1	⊢ w = w'
ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : free_product.word M,	h : w.fst_idx ≠ option.some i,	w' : free_product.word M,	h' : w'.fst_idx ≠ option.some i,	hm : ¬m = 1,	h : w.to_list = w'.to_list,	he : free_product.word.rcons {head := m, tail := w, fst_idx_ne := h} = free_product.word.rcons {head := m, tail := w', fst_idx_ne := h'},	hm' : ¬m = 1	⊢ {head := m, tail := w, fst_idx_ne := h} = {head := m, tail := w', fst_idx_ne := h'}
α : Type u,	β : Type v,	_inst_1 : group α,	_inst_2 : mul_action α β,	a b : β,	_x : a ∈ mul_action.orbit α b,	_fun_match : a ∈ mul_action.orbit α b → mul_action.orbit α a = mul_action.orbit α b,	x : α,	hx : x • b = a,	c : β,	_x : c ∈ mul_action.orbit α a,	_fun_match : c ∈ mul_action.orbit α a → c ∈ mul_action.orbit α b,	y : α,	hy : y • a = c	⊢ (y * x) • b = c
α : Type u,	β : Type v,	_inst_1 : group α,	_inst_2 : mul_action α β,	a b : β,	_x : a ∈ mul_action.orbit α b,	_fun_match : a ∈ mul_action.orbit α b → mul_action.orbit α a = mul_action.orbit α b,	x : α,	hx : x • b = a,	c : β,	_x : c ∈ mul_action.orbit α b,	_fun_match : c ∈ mul_action.orbit α b → c ∈ mul_action.orbit α a,	y : α,	hy : y • b = c	⊢ (y * x⁻¹) • a = c = ?m_1
α : Type u,	β : Type v,	_inst_1 : group α,	_inst_2 : mul_action α β,	a b : β,	_x : a ∈ mul_action.orbit α b,	_fun_match : a ∈ mul_action.orbit α b → mul_action.orbit α a = mul_action.orbit α b,	x : α,	hx : x • b = a,	c : β,	_x : c ∈ mul_action.orbit α b,	_fun_match : c ∈ mul_action.orbit α b → c ∈ mul_action.orbit α a,	y : α,	hy : y • b = c	⊢ c = ?m_1
α : Type u,	β : Type v,	_inst_1 : group α,	_inst_2 : mul_action α β,	a b : β,	_x : a ∈ mul_action.orbit α b,	_fun_match : a ∈ mul_action.orbit α b → mul_action.orbit α a = mul_action.orbit α b,	x : α,	hx : x • b = a,	c : β,	_x : c ∈ mul_action.orbit α b,	_fun_match : c ∈ mul_action.orbit α b → c ∈ mul_action.orbit α a,	y : α,	hy : y • b = c	⊢ (y * x⁻¹) • a = c
α : Type u,	β : Type v,	_inst_1 : monoid α,	_inst_2 : mul_action α β,	x : β,	hx : x ∈ ⋂ (g : α), mul_action.fixed_by α β g,	g : α	⊢ g • x = x
M : Type u_1,	N : Type u_2,	α : Type u_6,	β : Type u_7,	_inst_1 : has_scalar M α,	_inst_2 : has_scalar M β,	_inst_3 : has_scalar α β,	_inst_4 : is_scalar_tower M α β,	g : N → M	⊢ Sort ?
M : Type u_1,	N : Type u_2,	α : Type u_6,	β : Type u_7,	_inst_1 : has_scalar M α,	_inst_2 : has_scalar M β,	_inst_3 : has_scalar α β,	_inst_4 : is_scalar_tower M α β,	g : N → M	⊢ Sort ?
M : Type u_1,	N : Type u_2,	α : Type u_6,	β : Type u_7,	_inst_1 : has_scalar M α,	_inst_2 : has_scalar M β,	_inst_3 : has_scalar α β,	_inst_4 : is_scalar_tower M α β,	g : N → M,	_inst : has_scalar N α	⊢ Sort ?
M : Type u_1,	N : Type u_2,	α : Type u_6,	β : Type u_7,	_inst_1 : has_scalar M α,	_inst_2 : has_scalar M β,	_inst_3 : has_scalar α β,	_inst_4 : is_scalar_tower M α β,	g : N → M,	_inst : has_scalar N α,	_inst_5 : has_scalar N β	⊢ Sort ?
M : Type u_1,	N : Type u_2,	α : Type u_6,	β : Type u_7,	_inst_1 : has_scalar M α,	_inst_2 : has_scalar M β,	_inst_3 : has_scalar α β,	_inst_4 : is_scalar_tower M α β,	g : N → M	⊢ Sort ?
M : Type u_1,	N : Type u_2,	α : Type u_6,	β : Type u_7,	_inst_1 : has_scalar M α,	_inst_2 : has_scalar M β,	_inst_3 : has_scalar α β,	_inst_4 : is_scalar_tower M α β,	g : N → M	⊢ is_scalar_tower N α β
M : Type u_1,	α : Type u_6,	_inst_1 : has_scalar M α,	p : Prop,	_inst_2 : decidable p,	a : M,	b₁ b₂ : α	⊢ a • ite p b₁ b₂ = ite p (a • b₁) (a • b₂)
M : Type u_1,	α : Type u_6,	_inst_1 : has_scalar M α,	p : Prop,	_inst_2 : decidable p,	a : M,	b₁ b₂ : α,	h : p	⊢ a • b₁ = a • b₁
M : Type u_1,	α : Type u_6,	_inst_1 : has_scalar M α,	p : Prop,	_inst_2 : decidable p,	a : M,	b₁ b₂ : α,	h : ¬p	⊢ a • b₂ = a • b₂
M : Type u_1,	α : Type u_6,	_inst_1 : has_scalar M α,	p : Prop,	_inst_2 : decidable p,	a : M,	b₁ b₂ : α	⊢ a • ite p b₁ b₂ = ite p (a • b₁) (a • b₂)
M : Type u_1,	A : Type u_4,	_inst_1 : monoid M,	_inst_2 : add_group A,	_inst_3 : distrib_mul_action M A,	r : M,	x : A	⊢ r • -x + r • x = 0
R : Type u,	M : Type v,	_inst_1 : has_scalar R M,	p : sub_mul_action R M	⊢ ↥p →[R] M
R : Type u,	M : Type v,	_inst_1 : has_scalar R M,	p : sub_mul_action R M	⊢ ∀ (m : R) (x : ↥p), ↑(m • x) = m • ↑x
R : Type u,	M : Type v,	_inst_1 : has_scalar R M,	p : sub_mul_action R M	⊢ ↥p →[R] M
G : Type u,	_inst_1 : group G,	_inst_4 : is_free_group G	⊢ (⇑free_group.lift is_free_group.of).comp (⇑is_free_group.lift' free_group.of) = monoid_hom.id G
G : Type u,	_inst_1 : group G,	_inst_4 : is_free_group G,	a : is_free_group.generators G	⊢ ⇑((⇑free_group.lift is_free_group.of).comp (⇑is_free_group.lift' free_group.of)) (is_free_group.of a) = ⇑(monoid_hom.id G) (is_free_group.of a)
G : Type u,	_inst_1 : group G,	_inst_4 : is_free_group G	⊢ (⇑is_free_group.lift' free_group.of).comp (⇑free_group.lift is_free_group.of) = monoid_hom.id (free_group (is_free_group.generators G))
G : Type u,	_inst_1 : group G,	_inst_4 : is_free_group G,	a : is_free_group.generators (free_group (is_free_group.generators G))	⊢ ⇑((⇑is_free_group.lift' free_group.of).comp (⇑free_group.lift is_free_group.of)) (is_free_group.of a) = ⇑(monoid_hom.id (free_group (is_free_group.generators G))) (is_free_group.of a)
M : Type u_1,	_inst_1 : comm_monoid M,	S : submonoid M,	N : Type u_2,	_inst_2 : comm_monoid N,	f g : S.localization_map N,	h : ∀ (x : M), ⇑(f.to_map) x = ⇑(g.to_map) x	⊢ f = g
M : Type u_1,	_inst_1 : comm_monoid M,	S : submonoid M,	N : Type u_2,	_inst_2 : comm_monoid N,	f g : S.localization_map N,	h : ∀ (x : M), ⇑(f.to_map) x = ⇑(g.to_map) x	⊢ f = g
M : Type u_1,	_inst_1 : comm_monoid M,	S : submonoid M,	N : Type u_2,	_inst_2 : comm_monoid N,	f g : S.localization_map N,	h : ∀ (x : M), ⇑(f.to_map) x = ⇑(g.to_map) x	⊢ f = g
M : Type u_1,	_inst_1 : comm_monoid M,	S : submonoid M,	N : Type u_2,	_inst_2 : comm_monoid N,	g : S.localization_map N,	f_to_fun : M → N,	f_map_one' : f_to_fun 1 = 1,	f_map_mul' : ∀ (x y : M), f_to_fun (x * y) = f_to_fun x * f_to_fun y,	f_map_units' : ∀ (y : ↥S), is_unit (f_to_fun ↑y),	f_surj' : ∀ (z : N), ∃ (x : M × ↥S), z * f_to_fun ↑(x.snd) = f_to_fun x.fst,	f_eq_iff_exists' : ∀ (x y : M), f_to_fun x = f_to_fun y ↔ ∃ (c : ↥S), x * ↑c = y * ↑c,	h : ∀ (x : M), ⇑({to_fun := f_to_fun, map_one' := f_map_one', map_mul' := f_map_mul', map_units' := f_map_units', surj' := f_surj', eq_iff_exists' := f_eq_iff_exists'}.to_map) x = ⇑(g.to_map) x	⊢ {to_fun := f_to_fun, map_one' := f_map_one', map_mul' := f_map_mul', map_units' := f_map_units', surj' := f_surj', eq_iff_exists' := f_eq_iff_exists'} = g
M : Type u_1,	_inst_1 : comm_monoid M,	S : submonoid M,	N : Type u_2,	_inst_2 : comm_monoid N,	f_to_fun : M → N,	f_map_one' : f_to_fun 1 = 1,	f_map_mul' : ∀ (x y : M), f_to_fun (x * y) = f_to_fun x * f_to_fun y,	f_map_units' : ∀ (y : ↥S), is_unit (f_to_fun ↑y),	f_surj' : ∀ (z : N), ∃ (x : M × ↥S), z * f_to_fun ↑(x.snd) = f_to_fun x.fst,	f_eq_iff_exists' : ∀ (x y : M), f_to_fun x = f_to_fun y ↔ ∃ (c : ↥S), x * ↑c = y * ↑c,	g_to_fun : M → N,	g_map_one' : g_to_fun 1 = 1,	g_map_mul' : ∀ (x y : M), g_to_fun (x * y) = g_to_fun x * g_to_fun y,	g_map_units' : ∀ (y : ↥S), is_unit (g_to_fun ↑y),	g_surj' : ∀ (z : N), ∃ (x : M × ↥S), z * g_to_fun ↑(x.snd) = g_to_fun x.fst,	g_eq_iff_exists' : ∀ (x y : M), g_to_fun x = g_to_fun y ↔ ∃ (c : ↥S), x * ↑c = y * ↑c,	h : ∀ (x : M), ⇑({to_fun := f_to_fun, map_one' := f_map_one', map_mul' := f_map_mul', map_units' := f_map_units', surj' := f_surj', eq_iff_exists' := f_eq_iff_exists'}.to_map) x = ⇑({to_fun := g_to_fun, map_one' := g_map_one', map_mul' := g_map_mul', map_units' := g_map_units', surj' := g_surj', eq_iff_exists' := g_eq_iff_exists'}.to_map) x	⊢ {to_fun := f_to_fun, map_one' := f_map_one', map_mul' := f_map_mul', map_units' := f_map_units', surj' := f_surj', eq_iff_exists' := f_eq_iff_exists'} = {to_fun := g_to_fun, map_one' := g_map_one', map_mul' := g_map_mul', map_units' := g_map_units', surj' := g_surj', eq_iff_exists' := g_eq_iff_exists'}
M : Type u_1,	_inst_1 : comm_monoid M,	S : submonoid M,	N : Type u_2,	_inst_2 : comm_monoid N,	f_to_fun : M → N,	f_map_one' : f_to_fun 1 = 1,	f_map_mul' : ∀ (x y : M), f_to_fun (x * y) = f_to_fun x * f_to_fun y,	f_map_units' : ∀ (y : ↥S), is_unit (f_to_fun ↑y),	f_surj' : ∀ (z : N), ∃ (x : M × ↥S), z * f_to_fun ↑(x.snd) = f_to_fun x.fst,	f_eq_iff_exists' : ∀ (x y : M), f_to_fun x = f_to_fun y ↔ ∃ (c : ↥S), x * ↑c = y * ↑c,	g_to_fun : M → N,	g_map_one' : g_to_fun 1 = 1,	g_map_mul' : ∀ (x y : M), g_to_fun (x * y) = g_to_fun x * g_to_fun y,	g_map_units' : ∀ (y : ↥S), is_unit (g_to_fun ↑y),	g_surj' : ∀ (z : N), ∃ (x : M × ↥S), z * g_to_fun ↑(x.snd) = g_to_fun x.fst,	g_eq_iff_exists' : ∀ (x y : M), g_to_fun x = g_to_fun y ↔ ∃ (c : ↥S), x * ↑c = y * ↑c,	h : ∀ (x : M), ⇑({to_fun := f_to_fun, map_one' := f_map_one', map_mul' := f_map_mul', map_units' := f_map_units', surj' := f_surj', eq_iff_exists' := f_eq_iff_exists'}.to_map) x = ⇑({to_fun := g_to_fun, map_one' := g_map_one', map_mul' := g_map_mul', map_units' := g_map_units', surj' := g_surj', eq_iff_exists' := g_eq_iff_exists'}.to_map) x	⊢ f_to_fun = g_to_fun
M : Type u_1,	_inst_1 : comm_monoid M,	S : submonoid M,	N : Type u_2,	_inst_2 : comm_monoid N,	f g : S.localization_map N,	h : ∀ (x : M), ⇑(f.to_map) x = ⇑(g.to_map) x	⊢ f = g
M : Type u_1,	_inst_1 : comm_monoid M,	S : submonoid M,	N : Type u_2,	_inst_2 : comm_monoid N,	f : S.localization_map N,	x : M,	y : ↥S	⊢ ⇑(f.to_map) x * ↑(⇑(is_unit.lift_right (f.to_map.mrestrict S) _) y)⁻¹ * ⇑(f.to_map) ↑y = ⇑(f.to_map) x
G : Type u,	_inst_1 : category_theory.groupoid G,	_inst_2 : is_free_groupoid G,	T : wide_subquiver (quiver.symmetrify (is_free_groupoid.generators G)),	_inst_3 : quiver.arborescence ↥T,	a : G,	p : quiver.path (quiver.root ↥T) a	⊢ is_free_groupoid.spanning_tree.tree_hom T a = is_free_groupoid.spanning_tree.hom_of_path T p
G : Type u_1,	_inst_1 : group G,	H : ℕ → subgroup G,	hH : is_descending_central_series H,	descending_central_series_ge_lower : ∀ (n : ℕ), lower_central_series G n ≤ H n,	n : ℕ	⊢ lower_central_series G (n + 1) ≤ H (n + 1)
G : Type u_1,	_inst_1 : group G,	H : ℕ → subgroup G,	hH : is_descending_central_series H,	n : ℕ,	descending_central_series_ge_lower : lower_central_series G n ≤ H n	⊢ lower_central_series G (n + 1) ≤ H (n + 1)
G : Type u_1,	_inst_1 : group G,	H : ℕ → subgroup G,	hH : is_descending_central_series H,	n : ℕ,	descending_central_series_ge_lower : lower_central_series G n ≤ H n	⊢ ∀ (p : G), p ∈ lower_central_series G (n.add 0) → ∀ (q : G), q ∈ ⊤ → p * q * p⁻¹ * q⁻¹ ∈ H (n + 1)
G : Type u_1,	_inst_1 : group G,	H : ℕ → subgroup G,	hH : is_descending_central_series H,	n : ℕ,	descending_central_series_ge_lower : lower_central_series G n ≤ H n,	x : G,	hx : x ∈ lower_central_series G (n.add 0),	q : G,	H_1 : q ∈ ⊤	⊢ x * q * x⁻¹ * q⁻¹ ∈ H (n + 1)
G : Type u_1,	_inst_1 : group G,	H : Type u_2,	_inst_3 : group H,	f : G →* H,	n : ℕ	⊢ subgroup.map f (lower_central_series G n) ≤ lower_central_series H n
G : Type u_1,	_inst_1 : group G,	H : Type u_2,	_inst_3 : group H,	f : G →* H	⊢ subgroup.map f (lower_central_series G 0) ≤ lower_central_series H 0		case nat.succ	G : Type u_1,	_inst_1 : group G,	H : Type u_2,	_inst_3 : group H,	f : G →* H,	d : ℕ,	hd : subgroup.map f (lower_central_series G d) ≤ lower_central_series H d	⊢ subgroup.map f (lower_central_series G d.succ) ≤ lower_central_series H d.succ
G : Type u_1,	_inst_1 : group G,	H : Type u_2,	_inst_3 : group H,	f : G →* H	⊢ subgroup.map f (lower_central_series G 0) ≤ lower_central_series H 0
G : Type u_1,	_inst_1 : group G,	H : Type u_2,	_inst_3 : group H,	f : G →* H,	d : ℕ,	hd : subgroup.map f (lower_central_series G d) ≤ lower_central_series H d	⊢ subgroup.map f (lower_central_series G d.succ) ≤ lower_central_series H d.succ
G : Type u_1,	_inst_1 : group G,	H : Type u_2,	_inst_3 : group H,	f : G →* H,	d : ℕ,	hd : subgroup.map f (lower_central_series G d) ≤ lower_central_series H d,	x : G,	hx : x ∈ lower_central_series G d.succ	⊢ ⇑f 1 ∈ lower_central_series H d.succ
G : Type u_1,	_inst_1 : group G,	H : Type u_2,	_inst_3 : group H,	f : G →* H,	d : ℕ,	hd : subgroup.map f (lower_central_series G d) ≤ lower_central_series H d,	x : G,	hx : x ∈ lower_central_series G d.succ	⊢ ⇑f x ∈ lower_central_series H d.succ
G : Type u_1,	_inst_1 : group G,	H : Type u_2,	_inst_3 : group H,	f : G →* H,	d : ℕ,	hd : subgroup.map f (lower_central_series G d) ≤ lower_central_series H d,	x : G,	hx : x ∈ lower_central_series G d.succ,	y z : G,	hy : ⇑f y ∈ lower_central_series H d.succ,	hz : ⇑f z ∈ lower_central_series H d.succ	⊢ ⇑f (y * z) ∈ lower_central_series H d.succ
G : Type u_1,	_inst_1 : group G,	H : Type u_2,	_inst_3 : group H,	f : G →* H,	d : ℕ,	hd : subgroup.map f (lower_central_series G d) ≤ lower_central_series H d,	x : G,	hx : x ∈ lower_central_series G d.succ,	y : G,	hy : ⇑f y ∈ lower_central_series H d.succ	⊢ ⇑f y⁻¹ ∈ lower_central_series H d.succ
G : Type u_1,	_inst_1 : group G,	H : Type u_2,	_inst_3 : group H,	f : G →* H,	d : ℕ,	hd : subgroup.map f (lower_central_series G d) ≤ lower_central_series H d,	x : G,	hx : x ∈ lower_central_series G d.succ	⊢ ∀ (x : G), x ∈ {x : G | ∃ (p : G) (H : p ∈ lower_central_series G d) (q : G) (H : q ∈ ⊤), p * q * p⁻¹ * q⁻¹ = x} → ⇑f x ∈ lower_central_series H d.succ
G : Type u_1,	_inst_1 : group G,	H : Type u_2,	_inst_3 : group H,	f : G →* H,	d : ℕ,	hd : subgroup.map f (lower_central_series G d) ≤ lower_central_series H d,	x : G,	hx : x ∈ lower_central_series G d.succ,	y : G,	hy : y ∈ lower_central_series G d,	z : G	⊢ ⇑f (y * z * y⁻¹ * z⁻¹) ∈ lower_central_series H d.succ
G : Type u_1,	_inst_1 : group G,	H : Type u_2,	_inst_3 : group H,	f : G →* H,	d : ℕ,	hd : subgroup.map f (lower_central_series G d) ≤ lower_central_series H d,	x : G,	hx : x ∈ lower_central_series G d.succ,	y : G,	hy : y ∈ lower_central_series G d,	z : G,	K : subgroup H,	hK : {x : H | ∃ (p : H) (H_1 : p ∈ lower_central_series H d) (q : H) (H_1 : q ∈ ⊤), p * q * p⁻¹ * q⁻¹ = x} ⊆ ↑K	⊢ ∃ (q : H) (H_1 : q ∈ ⊤), ⇑f y * q * (⇑f y)⁻¹ * q⁻¹ = ⇑f (y * z * y⁻¹ * z⁻¹)
G : Type u_1,	_inst_1 : group G,	H : Type u_2,	_inst_3 : group H,	f : G →* H,	d : ℕ,	hd : subgroup.map f (lower_central_series G d) ≤ lower_central_series H d,	x : G,	hx : x ∈ lower_central_series G d.succ,	y : G,	hy : y ∈ lower_central_series G d,	z : G	⊢ ∀ (K : subgroup H), {x : H | ∃ (p : H) (H_1 : p ∈ lower_central_series H d) (q : H) (H_1 : q ∈ ⊤), p * q * p⁻¹ * q⁻¹ = x} ⊆ ↑K → ⇑f (y * z * y⁻¹ * z⁻¹) ∈ K
G : Type u,	_inst_1 : monoid G,	x : G	⊢ x ^ order_of x = 1
G : Type u,	_inst_1 : monoid G,	x : G	⊢ x ^ order_of x = has_mul.mul x^[function.minimal_period (has_mul.mul x) 1] 1
⊢ order_of (-1) = 2
_inst : fact (nat.prime 2)	⊢ order_of (-1) = 2
A : Type v,	a : A,	_inst_2 : fintype A,	_inst_4 : add_group A,	_inst_5 : decidable_eq A,	x : A	⊢ x ∈ finset.image (λ (i : ℕ), i • a) (finset.range (add_order_of a)) ↔ x ∈ ↑(add_subgroup.gmultiples a).to_finset
A : Type v,	a : A,	_inst_2 : fintype A,	_inst_4 : add_group A,	_inst_5 : decidable_eq A	⊢ finset.image (λ (i : ℕ), i • a) (finset.range (add_order_of a)) = ↑(add_subgroup.gmultiples a).to_finset
α : Type u_1,	_inst_1 : fintype α,	_inst_2 : decidable_eq α,	σ σ : equiv.perm α,	hσ : σ.is_cycle	⊢ σ⁻¹.cycle_type = σ.cycle_type
α : Type u_1,	_inst_1 : fintype α,	_inst_2 : decidable_eq α,	σ σ τ : equiv.perm α,	hστ : σ.disjoint τ,	hc : σ.is_cycle,	hσ : σ⁻¹.cycle_type = σ.cycle_type,	hτ : τ⁻¹.cycle_type = τ.cycle_type	⊢ (σ * τ)⁻¹.cycle_type = (σ * τ).cycle_type
α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	σ τ : equiv.perm α	⊢ (σ * τ * σ⁻¹).support = finset.map (equiv.to_embedding σ) τ.support
α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	σ τ : equiv.perm α,	a : α	⊢ a ∈ (σ * τ * σ⁻¹).support ↔ a ∈ finset.map (equiv.to_embedding σ) τ.support
α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	σ τ : equiv.perm α,	a : α	⊢ ¬⇑σ (⇑τ (⇑σ⁻¹ a)) = a ↔ ¬⇑σ (⇑τ (⇑(equiv.symm σ) a)) = a
β : Type u_2,	f : equiv.perm β,	x y : β,	n : ℕ	⊢ f.same_cycle (⇑(f ^ n) x) y ↔ f.same_cycle x y
β : Type u_2,	f : equiv.perm β,	x y : β,	n : ℕ	⊢ f.same_cycle (⇑(f ^ n) x) y → f.same_cycle x y
β : Type u_2,	f : equiv.perm β,	x : β,	n : ℕ,	k : ℤ	⊢ f.same_cycle x (⇑(f ^ k) (⇑(f ^ n) x))
β : Type u_2,	f : equiv.perm β,	x y : β,	n : ℕ	⊢ f.same_cycle (⇑(f ^ n) x) y → f.same_cycle x y		β : Type u_2,	f : equiv.perm β,	x y : β,	n : ℕ	⊢ f.same_cycle x y → f.same_cycle (⇑(f ^ n) x) y
β : Type u_2,	f : equiv.perm β,	x : β,	n : ℕ,	k : ℤ	⊢ ⇑(f ^ (k + ↑n)) x = ⇑(f ^ k) (⇑(f ^ n) x)
β : Type u_2,	f : equiv.perm β,	x y : β,	n : ℕ	⊢ f.same_cycle x y → f.same_cycle (⇑(f ^ n) x) y
β : Type u_2,	f : equiv.perm β,	x : β,	n : ℕ,	k : ℤ	⊢ f.same_cycle (⇑(f ^ n) x) (⇑(f ^ k) x)
β : Type u_2,	f : equiv.perm β,	x : β,	n : ℕ,	k : ℤ	⊢ ⇑(f ^ (k - ↑n)) (⇑(f ^ n) x) = ⇑(f ^ k) x
α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : equiv.perm α,	x : α	⊢ (f.cycle_of x).support ≤ f.support
α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : equiv.perm α,	x y : α,	hy : y ∈ (f.cycle_of x).support	⊢ y ∈ f.support
α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : equiv.perm α,	x y : α,	hy : ite (f.same_cycle x y) (⇑f y) y ≠ y	⊢ y ∈ f.support
α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : equiv.perm α,	x y : α,	h : f.same_cycle x y,	hy : ⇑f y ≠ y	⊢ y ∈ f.support		α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : equiv.perm α,	x y : α,	h : ¬f.same_cycle x y,	hy : y ≠ y	⊢ y ∈ f.support
α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : equiv.perm α,	x y : α,	h : f.same_cycle x y,	hy : ⇑f y ≠ y	⊢ y ∈ f.support
α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : equiv.perm α,	x y : α,	h : ¬f.same_cycle x y,	hy : y ≠ y	⊢ y ∈ f.support
β : Type u_2,	f : equiv.perm β,	hf : f.is_cycle,	_let_match : f.is_cycle → f⁻¹.is_cycle,	x : β,	hx : ⇑f x ≠ x ∧ ∀ (y : β), ⇑f y ≠ y → (∃ (i : ℤ), ⇑(f ^ i) x = y)	⊢ ⇑f⁻¹ x ≠ x
β : Type u_2,	f : equiv.perm β,	hf : f.is_cycle,	x : β,	hx : ¬⇑f x = x ∧ ∀ (y : β), ¬⇑f y = y → (∃ (i : ℤ), ⇑(f ^ i) x = y),	_let_match : f⁻¹.is_cycle	⊢ ¬x = ⇑f x
β : Type u_2,	f : equiv.perm β,	hf : f.is_cycle,	_let_match : f.is_cycle → f⁻¹.is_cycle,	x : β,	hx : ⇑f x ≠ x ∧ ∀ (y : β), ⇑f y ≠ y → (∃ (i : ℤ), ⇑(f ^ i) x = y),	y : β,	hy : ⇑f⁻¹ y ≠ y	⊢ ⇑f y ≠ y
β : Type u_2,	f : equiv.perm β,	hf : f.is_cycle,	x y : β,	hy : ¬y = ⇑f y,	hx : ¬⇑f x = x ∧ ∀ (y : β), ¬⇑f y = y → (∃ (i : ℤ), ⇑(f ^ i) x = y),	_let_match : f⁻¹.is_cycle	⊢ ¬⇑f y = y
β : Type u_2,	f : equiv.perm β,	hf : f.is_cycle,	_let_match : f.is_cycle → f⁻¹.is_cycle,	x : β,	hx : ⇑f x ≠ x ∧ ∀ (y : β), ⇑f y ≠ y → (∃ (i : ℤ), ⇑(f ^ i) x = y),	y : β,	hy : ⇑f⁻¹ y ≠ y,	_let_match : (∃ (i : ℤ), ⇑(f ^ i) x = y) → (∃ (i : ℤ), ⇑(f⁻¹ ^ i) x = y),	i : ℤ,	hi : ⇑(f ^ i) x = y	⊢ ⇑(f⁻¹ ^ -i) x = y
α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : equiv.perm α	⊢ f.cycle_factors_finset = {f} ↔ f.is_cycle
n : ℕ,	i j : fin n.succ,	h : j ≤ i	⊢ ⇑(i.cycle_range) j = ite (j = i) 0 (j + 1)
i j : fin 1,	h : j ≤ i	⊢ ⇑(i.cycle_range) j = ite (j = i) 0 (j + 1)		case nat.succ	n : ℕ,	i j : fin n.succ.succ,	h : j ≤ i	⊢ ⇑(i.cycle_range) j = ite (j = i) 0 (j + 1)
i j : fin 1,	h : j ≤ i	⊢ ⇑(i.cycle_range) j = ite (j = i) 0 (j + 1)
n : ℕ,	i j : fin n.succ.succ,	h : j ≤ i	⊢ ⇑(i.cycle_range) j = ite (j = i) 0 (j + 1)
n : ℕ,	i j : fin n.succ.succ,	h : j ≤ i	⊢ j = ⇑((fin.cast_le _).to_embedding) ⟨↑j, _⟩		n : ℕ,	i j : fin n.succ.succ,	h : j ≤ i,	this : j = ⇑((fin.cast_le _).to_embedding) ⟨↑j, _⟩	⊢ ⇑(i.cycle_range) j = ite (j = i) 0 (j + 1)
n : ℕ,	i j : fin n.succ.succ,	h : j ≤ i	⊢ j = ⇑((fin.cast_le _).to_embedding) ⟨↑j, _⟩
n : ℕ,	i j : fin n.succ.succ,	h : j ≤ i,	this : j = ⇑((fin.cast_le _).to_embedding) ⟨↑j, _⟩	⊢ ⇑(i.cycle_range) j = ite (j = i) 0 (j + 1)
n : ℕ,	i j : fin n.succ.succ,	h : j ≤ i,	this : j = ⇑((fin.cast_le _).to_embedding) ⟨↑j, _⟩	⊢ ↑(⇑(i.cycle_range) j) = ↑(ite (j = i) 0 (j + 1))
n : ℕ,	i j : fin n.succ.succ,	h : j ≤ i,	this : j = ⇑((fin.cast_le _).to_embedding) ⟨↑j, _⟩	⊢ ite (⟨↑j, _⟩ = fin.last ↑i) 0 (↑⟨↑j, _⟩ + 1) = ↑(ite (⇑(fin.cast_le _) ⟨↑j, _⟩ = i) 0 (⇑(fin.cast_le _) ⟨↑j, _⟩ + 1))
n : ℕ,	i j : fin n.succ.succ,	h : j ≤ i,	this : j = ⇑((fin.cast_le _).to_embedding) ⟨↑j, _⟩	⊢ ite (↑j = ↑i) 0 (↑j + 1) = ite (↑j = ↑i) 0 ↑(j + 1)
n : ℕ,	i j : fin n.succ.succ,	h : j ≤ i,	this : j = ⇑((fin.cast_le _).to_embedding) ⟨↑j, _⟩,	heq : ↑j = ↑i	⊢ 0 = 0		n : ℕ,	i j : fin n.succ.succ,	h : j ≤ i,	this : j = ⇑((fin.cast_le _).to_embedding) ⟨↑j, _⟩,	heq : ¬↑j = ↑i	⊢ ↑j + 1 = ↑(j + 1)
n : ℕ,	i j : fin n.succ.succ,	h : j ≤ i,	this : j = ⇑((fin.cast_le _).to_embedding) ⟨↑j, _⟩,	heq : ↑j = ↑i	⊢ 0 = 0
n : ℕ,	i j : fin n.succ.succ,	h : j ≤ i,	this : j = ⇑((fin.cast_le _).to_embedding) ⟨↑j, _⟩,	heq : ¬↑j = ↑i	⊢ ↑j + 1 = ↑(j + 1)
n : ℕ,	i j : fin n.succ.succ,	h : j ≤ i,	this : j = ⇑((fin.cast_le _).to_embedding) ⟨↑j, _⟩,	heq : ¬↑j = ↑i	⊢ j < fin.last n.succ
n : ℕ	⊢ 2.cycle_range.is_three_cycle
n : ℕ	⊢ 2.cycle_range.is_three_cycle
n : ℕ	⊢ {↑2 + 1} = {3}
n : ℕ	⊢ 2 ≠ 0
n : ℕ,	p : fin (n + 1),	e : equiv.perm (fin n)	⊢ ⇑(⇑(equiv.perm.decompose_fin.symm) (p, e)) 0 = p
n : ℕ,	f : equiv.perm (fin n),	_x : Σ (a : fin n), fin n,	_fun_match : ∀ (_a b : Σ (a : fin n), fin n), _a ∈ equiv.perm.fin_pairs_lt n → b ∈ equiv.perm.fin_pairs_lt n → f.sign_bij_aux _a = f.sign_bij_aux b → _a = b,	a₁ a₂ : fin n,	_x : Σ (a : fin n), fin n,	_fun_match : ∀ (_a : Σ (a : fin n), fin n), ⟨a₁, a₂⟩ ∈ equiv.perm.fin_pairs_lt n → _a ∈ equiv.perm.fin_pairs_lt n → f.sign_bij_aux ⟨a₁, a₂⟩ = f.sign_bij_aux _a → ⟨a₁, a₂⟩ = _a,	b₁ b₂ : fin n,	ha : ⟨a₁, a₂⟩ ∈ equiv.perm.fin_pairs_lt n,	hb : ⟨b₁, b₂⟩ ∈ equiv.perm.fin_pairs_lt n,	h : f.sign_bij_aux ⟨a₁, a₂⟩ = f.sign_bij_aux ⟨b₁, b₂⟩	⊢ ⟨a₁, a₂⟩ = ⟨b₁, b₂⟩
n : ℕ,	f : equiv.perm (fin n),	_x : Σ (a : fin n), fin n,	_fun_match : ∀ (_a b : Σ (a : fin n), fin n), _a ∈ equiv.perm.fin_pairs_lt n → b ∈ equiv.perm.fin_pairs_lt n → f.sign_bij_aux _a = f.sign_bij_aux b → _a = b,	a₁ a₂ : fin n,	_x : Σ (a : fin n), fin n,	_fun_match : ∀ (_a : Σ (a : fin n), fin n), ⟨a₁, a₂⟩ ∈ equiv.perm.fin_pairs_lt n → _a ∈ equiv.perm.fin_pairs_lt n → f.sign_bij_aux ⟨a₁, a₂⟩ = f.sign_bij_aux _a → ⟨a₁, a₂⟩ = _a,	b₁ b₂ : fin n,	ha : ⟨a₁, a₂⟩ ∈ equiv.perm.fin_pairs_lt n,	hb : ⟨b₁, b₂⟩ ∈ equiv.perm.fin_pairs_lt n,	h : dite (⇑f ⟨a₁, a₂⟩.snd < ⇑f ⟨a₁, a₂⟩.fst) (λ (hxa : ⇑f ⟨a₁, a₂⟩.snd < ⇑f ⟨a₁, a₂⟩.fst), ⟨⇑f ⟨a₁, a₂⟩.fst, ⇑f ⟨a₁, a₂⟩.snd⟩) (λ (hxa : ¬⇑f ⟨a₁, a₂⟩.snd < ⇑f ⟨a₁, a₂⟩.fst), ⟨⇑f ⟨a₁, a₂⟩.snd, ⇑f ⟨a₁, a₂⟩.fst⟩) = dite (⇑f ⟨b₁, b₂⟩.snd < ⇑f ⟨b₁, b₂⟩.fst) (λ (hxa : ⇑f ⟨b₁, b₂⟩.snd < ⇑f ⟨b₁, b₂⟩.fst), ⟨⇑f ⟨b₁, b₂⟩.fst, ⇑f ⟨b₁, b₂⟩.snd⟩) (λ (hxa : ¬⇑f ⟨b₁, b₂⟩.snd < ⇑f ⟨b₁, b₂⟩.fst), ⟨⇑f ⟨b₁, b₂⟩.snd, ⇑f ⟨b₁, b₂⟩.fst⟩)	⊢ ⟨a₁, a₂⟩ = ⟨b₁, b₂⟩
n : ℕ,	f : equiv.perm (fin n),	_x : Σ (a : fin n), fin n,	_fun_match : ∀ (_a b : Σ (a : fin n), fin n), _a ∈ equiv.perm.fin_pairs_lt n → b ∈ equiv.perm.fin_pairs_lt n → f.sign_bij_aux _a = f.sign_bij_aux b → _a = b,	a₁ a₂ : fin n,	_x : Σ (a : fin n), fin n,	b₁ b₂ : fin n,	h : dite (⇑f ⟨a₁, a₂⟩.snd < ⇑f ⟨a₁, a₂⟩.fst) (λ (hxa : ⇑f ⟨a₁, a₂⟩.snd < ⇑f ⟨a₁, a₂⟩.fst), ⟨⇑f ⟨a₁, a₂⟩.fst, ⇑f ⟨a₁, a₂⟩.snd⟩) (λ (hxa : ¬⇑f ⟨a₁, a₂⟩.snd < ⇑f ⟨a₁, a₂⟩.fst), ⟨⇑f ⟨a₁, a₂⟩.snd, ⇑f ⟨a₁, a₂⟩.fst⟩) = dite (⇑f ⟨b₁, b₂⟩.snd < ⇑f ⟨b₁, b₂⟩.fst) (λ (hxa : ⇑f ⟨b₁, b₂⟩.snd < ⇑f ⟨b₁, b₂⟩.fst), ⟨⇑f ⟨b₁, b₂⟩.fst, ⇑f ⟨b₁, b₂⟩.snd⟩) (λ (hxa : ¬⇑f ⟨b₁, b₂⟩.snd < ⇑f ⟨b₁, b₂⟩.fst), ⟨⇑f ⟨b₁, b₂⟩.snd, ⇑f ⟨b₁, b₂⟩.fst⟩),	_fun_match : ∀ (_a : Σ (a : fin n), fin n), ⟨a₁, a₂⟩.snd < ⟨a₁, a₂⟩.fst → _a ∈ equiv.perm.fin_pairs_lt n → f.sign_bij_aux ⟨a₁, a₂⟩ = f.sign_bij_aux _a → ⟨a₁, a₂⟩ = _a,	ha : ⟨a₁, a₂⟩.snd < ⟨a₁, a₂⟩.fst,	hb : ⟨b₁, b₂⟩.snd < ⟨b₁, b₂⟩.fst	⊢ ⟨a₁, a₂⟩ = ⟨b₁, b₂⟩
n : ℕ,	f : equiv.perm (fin n),	_x : Σ (a : fin n), fin n,	_fun_match : ∀ (_a b : Σ (a : fin n), fin n), _a ∈ equiv.perm.fin_pairs_lt n → b ∈ equiv.perm.fin_pairs_lt n → f.sign_bij_aux _a = f.sign_bij_aux b → _a = b,	a₁ a₂ : fin n,	_x : Σ (a : fin n), fin n,	b₁ b₂ : fin n,	h : dite (⇑f ⟨a₁, a₂⟩.snd < ⇑f ⟨a₁, a₂⟩.fst) (λ (hxa : ⇑f ⟨a₁, a₂⟩.snd < ⇑f ⟨a₁, a₂⟩.fst), ⟨⇑f ⟨a₁, a₂⟩.fst, ⇑f ⟨a₁, a₂⟩.snd⟩) (λ (hxa : ¬⇑f ⟨a₁, a₂⟩.snd < ⇑f ⟨a₁, a₂⟩.fst), ⟨⇑f ⟨a₁, a₂⟩.snd, ⇑f ⟨a₁, a₂⟩.fst⟩) = dite (⇑f ⟨b₁, b₂⟩.snd < ⇑f ⟨b₁, b₂⟩.fst) (λ (hxa : ⇑f ⟨b₁, b₂⟩.snd < ⇑f ⟨b₁, b₂⟩.fst), ⟨⇑f ⟨b₁, b₂⟩.fst, ⇑f ⟨b₁, b₂⟩.snd⟩) (λ (hxa : ¬⇑f ⟨b₁, b₂⟩.snd < ⇑f ⟨b₁, b₂⟩.fst), ⟨⇑f ⟨b₁, b₂⟩.snd, ⇑f ⟨b₁, b₂⟩.fst⟩),	_fun_match : ∀ (_a : Σ (a : fin n), fin n), ⟨a₁, a₂⟩.snd < ⟨a₁, a₂⟩.fst → _a ∈ equiv.perm.fin_pairs_lt n → f.sign_bij_aux ⟨a₁, a₂⟩ = f.sign_bij_aux _a → ⟨a₁, a₂⟩ = _a,	ha : ⟨a₁, a₂⟩.snd < ⟨a₁, a₂⟩.fst,	hb : ⟨b₁, b₂⟩.snd < ⟨b₁, b₂⟩.fst,	this : ¬b₁ < b₂	⊢ ⟨a₁, a₂⟩ = ⟨b₁, b₂⟩
n : ℕ,	f : equiv.perm (fin n),	_x : Σ (a : fin n), fin n,	_fun_match : ∀ (_a b : Σ (a : fin n), fin n), _a ∈ equiv.perm.fin_pairs_lt n → b ∈ equiv.perm.fin_pairs_lt n → f.sign_bij_aux _a = f.sign_bij_aux b → _a = b,	a₁ a₂ : fin n,	_x : Σ (a : fin n), fin n,	b₁ b₂ : fin n,	h : dite (⇑f ⟨a₁, a₂⟩.snd < ⇑f ⟨a₁, a₂⟩.fst) (λ (hxa : ⇑f ⟨a₁, a₂⟩.snd < ⇑f ⟨a₁, a₂⟩.fst), ⟨⇑f ⟨a₁, a₂⟩.fst, ⇑f ⟨a₁, a₂⟩.snd⟩) (λ (hxa : ¬⇑f ⟨a₁, a₂⟩.snd < ⇑f ⟨a₁, a₂⟩.fst), ⟨⇑f ⟨a₁, a₂⟩.snd, ⇑f ⟨a₁, a₂⟩.fst⟩) = dite (⇑f ⟨b₁, b₂⟩.snd < ⇑f ⟨b₁, b₂⟩.fst) (λ (hxa : ⇑f ⟨b₁, b₂⟩.snd < ⇑f ⟨b₁, b₂⟩.fst), ⟨⇑f ⟨b₁, b₂⟩.fst, ⇑f ⟨b₁, b₂⟩.snd⟩) (λ (hxa : ¬⇑f ⟨b₁, b₂⟩.snd < ⇑f ⟨b₁, b₂⟩.fst), ⟨⇑f ⟨b₁, b₂⟩.snd, ⇑f ⟨b₁, b₂⟩.fst⟩),	_fun_match : ∀ (_a : Σ (a : fin n), fin n), ⟨a₁, a₂⟩.snd < ⟨a₁, a₂⟩.fst → _a ∈ equiv.perm.fin_pairs_lt n → f.sign_bij_aux ⟨a₁, a₂⟩ = f.sign_bij_aux _a → ⟨a₁, a₂⟩ = _a,	ha : ⟨a₁, a₂⟩.snd < ⟨a₁, a₂⟩.fst,	hb : ⟨b₁, b₂⟩.snd < ⟨b₁, b₂⟩.fst,	this : ¬b₁ < b₂	⊢ ⟨a₁, a₂⟩ = ⟨b₁, b₂⟩
n : ℕ,	f : equiv.perm (fin n),	_x : Σ (a : fin n), fin n,	_fun_match : ∀ (_a b : Σ (a : fin n), fin n), _a ∈ equiv.perm.fin_pairs_lt n → b ∈ equiv.perm.fin_pairs_lt n → f.sign_bij_aux _a = f.sign_bij_aux b → _a = b,	a₁ a₂ : fin n,	_x : Σ (a : fin n), fin n,	b₁ b₂ : fin n,	_fun_match : ∀ (_a : Σ (a : fin n), fin n), ⟨a₁, a₂⟩.snd < ⟨a₁, a₂⟩.fst → _a ∈ equiv.perm.fin_pairs_lt n → f.sign_bij_aux ⟨a₁, a₂⟩ = f.sign_bij_aux _a → ⟨a₁, a₂⟩ = _a,	ha : ⟨a₁, a₂⟩.snd < ⟨a₁, a₂⟩.fst,	hb : ⟨b₁, b₂⟩.snd < ⟨b₁, b₂⟩.fst,	this : ¬b₁ < b₂,	h_1 : ⇑f ⟨a₁, a₂⟩.snd < ⇑f ⟨a₁, a₂⟩.fst,	h_2 : ⇑f ⟨b₁, b₂⟩.snd < ⇑f ⟨b₁, b₂⟩.fst,	h : ⇑f a₁ = ⇑f b₁ ∧ ⇑f a₂ == ⇑f b₂	⊢ ⟨a₁, a₂⟩ = ⟨b₁, b₂⟩
n : ℕ,	f : equiv.perm (fin n),	_x : Σ (a : fin n), fin n,	_fun_match : ∀ (_a b : Σ (a : fin n), fin n), _a ∈ equiv.perm.fin_pairs_lt n → b ∈ equiv.perm.fin_pairs_lt n → f.sign_bij_aux _a = f.sign_bij_aux b → _a = b,	a₁ a₂ : fin n,	_x : Σ (a : fin n), fin n,	b₁ b₂ : fin n,	_fun_match : ∀ (_a : Σ (a : fin n), fin n), ⟨a₁, a₂⟩.snd < ⟨a₁, a₂⟩.fst → _a ∈ equiv.perm.fin_pairs_lt n → f.sign_bij_aux ⟨a₁, a₂⟩ = f.sign_bij_aux _a → ⟨a₁, a₂⟩ = _a,	ha : ⟨a₁, a₂⟩.snd < ⟨a₁, a₂⟩.fst,	hb : ⟨b₁, b₂⟩.snd < ⟨b₁, b₂⟩.fst,	this : ¬b₁ < b₂,	h_1 : ⇑f ⟨a₁, a₂⟩.snd < ⇑f ⟨a₁, a₂⟩.fst,	h_2 : ¬⇑f ⟨b₁, b₂⟩.snd < ⇑f ⟨b₁, b₂⟩.fst,	h : ⇑f a₁ = ⇑f b₂ ∧ ⇑f a₂ == ⇑f b₁	⊢ ⟨a₁, a₂⟩ = ⟨b₁, b₂⟩
n : ℕ,	f : equiv.perm (fin n),	_x : Σ (a : fin n), fin n,	_fun_match : ∀ (_a b : Σ (a : fin n), fin n), _a ∈ equiv.perm.fin_pairs_lt n → b ∈ equiv.perm.fin_pairs_lt n → f.sign_bij_aux _a = f.sign_bij_aux b → _a = b,	a₁ a₂ : fin n,	_x : Σ (a : fin n), fin n,	b₁ b₂ : fin n,	_fun_match : ∀ (_a : Σ (a : fin n), fin n), ⟨a₁, a₂⟩.snd < ⟨a₁, a₂⟩.fst → _a ∈ equiv.perm.fin_pairs_lt n → f.sign_bij_aux ⟨a₁, a₂⟩ = f.sign_bij_aux _a → ⟨a₁, a₂⟩ = _a,	ha : ⟨a₁, a₂⟩.snd < ⟨a₁, a₂⟩.fst,	hb : ⟨b₁, b₂⟩.snd < ⟨b₁, b₂⟩.fst,	this : ¬b₁ < b₂,	h_1 : ¬⇑f ⟨a₁, a₂⟩.snd < ⇑f ⟨a₁, a₂⟩.fst,	h_2 : ⇑f ⟨b₁, b₂⟩.snd < ⇑f ⟨b₁, b₂⟩.fst,	h : ⇑f a₂ = ⇑f b₁ ∧ ⇑f a₁ == ⇑f b₂	⊢ ⟨a₁, a₂⟩ = ⟨b₁, b₂⟩
n : ℕ,	f : equiv.perm (fin n),	_x : Σ (a : fin n), fin n,	_fun_match : ∀ (_a b : Σ (a : fin n), fin n), _a ∈ equiv.perm.fin_pairs_lt n → b ∈ equiv.perm.fin_pairs_lt n → f.sign_bij_aux _a = f.sign_bij_aux b → _a = b,	a₁ a₂ : fin n,	_x : Σ (a : fin n), fin n,	b₁ b₂ : fin n,	_fun_match : ∀ (_a : Σ (a : fin n), fin n), ⟨a₁, a₂⟩.snd < ⟨a₁, a₂⟩.fst → _a ∈ equiv.perm.fin_pairs_lt n → f.sign_bij_aux ⟨a₁, a₂⟩ = f.sign_bij_aux _a → ⟨a₁, a₂⟩ = _a,	ha : ⟨a₁, a₂⟩.snd < ⟨a₁, a₂⟩.fst,	hb : ⟨b₁, b₂⟩.snd < ⟨b₁, b₂⟩.fst,	this : ¬b₁ < b₂,	h_1 : ¬⇑f ⟨a₁, a₂⟩.snd < ⇑f ⟨a₁, a₂⟩.fst,	h_2 : ¬⇑f ⟨b₁, b₂⟩.snd < ⇑f ⟨b₁, b₂⟩.fst,	h : ⇑f a₂ = ⇑f b₂ ∧ ⇑f a₁ == ⇑f b₁	⊢ ⟨a₁, a₂⟩ = ⟨b₁, b₂⟩
α : Type u,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	p : α → Prop,	_inst_5 : decidable_pred p,	ep : equiv.perm {a // p a},	en : equiv.perm {a // ¬p a}	⊢ ⇑equiv.perm.sign (ep.subtype_congr en) = ⇑equiv.perm.sign ep * ⇑equiv.perm.sign en
α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : equiv.perm α,	n : ℕ,	x : α	⊢ ⇑(f ^ n) x ∈ f.support ↔ x ∈ f.support
α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : equiv.perm α,	x : α	⊢ ⇑(f ^ 0) x ∈ f.support ↔ x ∈ f.support		case nat.succ	α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : equiv.perm α,	x : α,	n : ℕ,	ih : ⇑(f ^ n) x ∈ f.support ↔ x ∈ f.support	⊢ ⇑(f ^ n.succ) x ∈ f.support ↔ x ∈ f.support
α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : equiv.perm α,	x : α	⊢ ⇑(f ^ 0) x ∈ f.support ↔ x ∈ f.support
α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : equiv.perm α,	x : α,	n : ℕ,	ih : ⇑(f ^ n) x ∈ f.support ↔ x ∈ f.support	⊢ ⇑(f ^ n.succ) x ∈ f.support ↔ x ∈ f.support
α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : equiv.perm α,	x y : α,	hy : y ∈ (equiv.swap x (⇑f x) * f).support	⊢ y ∈ f.support ∧ y ≠ x
α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : equiv.perm α,	x y : α,	hy : ite (⇑f y = x) (⇑f x) (ite (y = x) x (⇑f y)) ≠ y	⊢ ⇑f y ≠ y ∧ y ≠ x
α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : equiv.perm α,	x y : α,	hy : ite (⇑f y = x) (⇑f x) (ite (y = x) x (⇑f y)) ≠ y,	h : ⇑f y = x	⊢ ⇑f y ≠ y ∧ y ≠ x
α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : equiv.perm α,	x y : α,	hy : ite (⇑f y = x) (⇑f x) (ite (y = x) x (⇑f y)) ≠ y,	h : ⇑f y = x	⊢ ⇑f y ≠ y ∧ y ≠ x
α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : equiv.perm α,	x y : α,	hy : ite (⇑f y = x) (⇑f x) (ite (y = x) x (⇑f y)) ≠ y,	h : ⇑f y = x	⊢ ⇑f y ≠ y
α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : equiv.perm α,	x y : α,	hy : ite (⇑f y = x) (⇑f x) (ite (y = x) x (⇑f y)) ≠ y,	h : ⇑f y = x	⊢ y ≠ x
α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : equiv.perm α,	x y : α,	hy : ite (⇑f y = x) (⇑f x) (ite (y = x) x (⇑f y)) ≠ y,	h : ⇑f y = x,	ᾰ : ⇑f y = y	⊢ false
α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : equiv.perm α,	x y : α,	hy : ite (⇑f y = x) (⇑f x) (ite (y = x) x (⇑f y)) ≠ y,	h : ⇑f y = x,	ᾰ : y = x	⊢ false
α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : equiv.perm α,	x y : α,	hy : ite (⇑f y = x) (⇑f x) (ite (y = x) x (⇑f y)) ≠ y,	h : ⇑f y = x	⊢ ⇑f y ≠ y ∧ y ≠ x
α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : equiv.perm α,	x y : α,	hy : ite (⇑f y = x) (⇑f x) (ite (y = x) x (⇑f y)) ≠ y,	h : ⇑f y = x	⊢ ⇑f y ≠ y ∧ y ≠ x		α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : equiv.perm α,	x y : α,	hy : ite (⇑f y = x) (⇑f x) (ite (y = x) x (⇑f y)) ≠ y,	h : ¬⇑f y = x	⊢ ⇑f y ≠ y ∧ y ≠ x
α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : equiv.perm α,	x y : α,	hy : ite (⇑f y = x) (⇑f x) (ite (y = x) x (⇑f y)) ≠ y,	h : ¬⇑f y = x	⊢ ⇑f y ≠ y ∧ y ≠ x
α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : equiv.perm α,	x y : α,	h : ¬⇑f y = x,	h_1 : y = x,	hy : x ≠ y	⊢ ⇑f y ≠ y ∧ y ≠ x
α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : equiv.perm α,	x y : α,	h : ¬⇑f y = x,	h_1 : ¬y = x,	hy : ⇑f y ≠ y	⊢ ⇑f y ≠ y ∧ y ≠ x
α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : equiv.perm α,	x y : α,	hy : ite (⇑f y = x) (⇑f x) (ite (y = x) x (⇑f y)) ≠ y,	h : ¬⇑f y = x	⊢ ⇑f y ≠ y ∧ y ≠ x
α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : equiv.perm α	⊢ f.support.card ≠ 1
α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : equiv.perm α,	h : f = 1	⊢ f.support.card ≠ 1
α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : equiv.perm α,	h : f = 1	⊢ f.support.card ≠ 1		α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : equiv.perm α,	h : ¬f = 1	⊢ f.support.card ≠ 1
α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : equiv.perm α,	h : ¬f = 1	⊢ f.support.card ≠ 1
N : Type u_1,	G : Type u_2,	_inst_1 : group N,	_inst_2 : group G,	φ : G →* mul_aut N,	N₁ : Type u_4,	G₁ : Type u_5,	_inst_4 : group N₁,	_inst_5 : group G₁,	φ₁ : G₁ →* mul_aut N₁,	f₁ : N →* N₁,	f₂ : G →* G₁,	h : ∀ (g : G), f₁.comp (mul_equiv.to_monoid_hom (⇑φ g)) = (mul_equiv.to_monoid_hom (⇑φ₁ (⇑f₂ g))).comp f₁	⊢ (semidirect_product.map f₁ f₂ h).comp semidirect_product.inl = semidirect_product.inl.comp f₁
N : Type u_1,	G : Type u_2,	_inst_1 : group N,	_inst_2 : group G,	φ : G →* mul_aut N,	N₁ : Type u_4,	G₁ : Type u_5,	_inst_4 : group N₁,	_inst_5 : group G₁,	φ₁ : G₁ →* mul_aut N₁,	f₁ : N →* N₁,	f₂ : G →* G₁,	h : ∀ (g : G), f₁.comp (mul_equiv.to_monoid_hom (⇑φ g)) = (mul_equiv.to_monoid_hom (⇑φ₁ (⇑f₂ g))).comp f₁	⊢ (semidirect_product.map f₁ f₂ h).comp semidirect_product.inl = semidirect_product.inl.comp f₁
N : Type u_1,	G : Type u_2,	_inst_1 : group N,	_inst_2 : group G,	φ : G →* mul_aut N,	N₁ : Type u_4,	G₁ : Type u_5,	_inst_4 : group N₁,	_inst_5 : group G₁,	φ₁ : G₁ →* mul_aut N₁,	f₁ : N →* N₁,	f₂ : G →* G₁,	h : ∀ (g : G), f₁.comp (mul_equiv.to_monoid_hom (⇑φ g)) = (mul_equiv.to_monoid_hom (⇑φ₁ (⇑f₂ g))).comp f₁,	x : N	⊢ (⇑((semidirect_product.map f₁ f₂ h).comp semidirect_product.inl) x).left = (⇑(semidirect_product.inl.comp f₁) x).left
N : Type u_1,	G : Type u_2,	_inst_1 : group N,	_inst_2 : group G,	φ : G →* mul_aut N,	N₁ : Type u_4,	G₁ : Type u_5,	_inst_4 : group N₁,	_inst_5 : group G₁,	φ₁ : G₁ →* mul_aut N₁,	f₁ : N →* N₁,	f₂ : G →* G₁,	h : ∀ (g : G), f₁.comp (mul_equiv.to_monoid_hom (⇑φ g)) = (mul_equiv.to_monoid_hom (⇑φ₁ (⇑f₂ g))).comp f₁,	x : N	⊢ (⇑((semidirect_product.map f₁ f₂ h).comp semidirect_product.inl) x).right = (⇑(semidirect_product.inl.comp f₁) x).right
G : Type u_1,	_inst_1 : group G,	H : subgroup G,	_inst_3 : H.normal,	h : is_solvable G	⊢ function.surjective ⇑(quotient_group.mk' H)
⊢ ¬is_solvable (equiv.perm (fin 5))
x : equiv.perm (fin 5) := {to_fun := ![1, 2, 0, 3, 4], inv_fun := ![2, 0, 1, 3, 4], left_inv := _, right_inv := _}	⊢ ¬is_solvable (equiv.perm (fin 5))
x : equiv.perm (fin 5) := {to_fun := ![1, 2, 0, 3, 4], inv_fun := ![2, 0, 1, 3, 4], left_inv := _, right_inv := _},	y : equiv.perm (fin 5) := {to_fun := ![3, 4, 2, 0, 1], inv_fun := ![3, 4, 2, 0, 1], left_inv := _, right_inv := _}	⊢ ¬is_solvable (equiv.perm (fin 5))
x : equiv.perm (fin 5) := {to_fun := ![1, 2, 0, 3, 4], inv_fun := ![2, 0, 1, 3, 4], left_inv := _, right_inv := _},	y : equiv.perm (fin 5) := {to_fun := ![3, 4, 2, 0, 1], inv_fun := ![3, 4, 2, 0, 1], left_inv := _, right_inv := _},	z : equiv.perm (fin 5) := {to_fun := ![0, 3, 2, 1, 4], inv_fun := ![0, 3, 2, 1, 4], left_inv := _, right_inv := _}	⊢ x ≠ 1
x : equiv.perm (fin 5) := {to_fun := ![1, 2, 0, 3, 4], inv_fun := ![2, 0, 1, 3, 4], left_inv := _, right_inv := _},	y : equiv.perm (fin 5) := {to_fun := ![3, 4, 2, 0, 1], inv_fun := ![3, 4, 2, 0, 1], left_inv := _, right_inv := _},	z : equiv.perm (fin 5) := {to_fun := ![0, 3, 2, 1, 4], inv_fun := ![0, 3, 2, 1, 4], left_inv := _, right_inv := _}	⊢ ¬is_solvable (equiv.perm (fin 5))
x : equiv.perm (fin 5) := {to_fun := ![1, 2, 0, 3, 4], inv_fun := ![2, 0, 1, 3, 4], left_inv := _, right_inv := _},	y : equiv.perm (fin 5) := {to_fun := ![3, 4, 2, 0, 1], inv_fun := ![3, 4, 2, 0, 1], left_inv := _, right_inv := _},	z : equiv.perm (fin 5) := {to_fun := ![0, 3, 2, 1, 4], inv_fun := ![0, 3, 2, 1, 4], left_inv := _, right_inv := _}	⊢ ¬∀ (x_1 : fin 5), ⇑x x_1 = ⇑1 x_1
x : equiv.perm (fin 5) := {to_fun := ![1, 2, 0, 3, 4], inv_fun := ![2, 0, 1, 3, 4], left_inv := _, right_inv := _},	y : equiv.perm (fin 5) := {to_fun := ![3, 4, 2, 0, 1], inv_fun := ![3, 4, 2, 0, 1], left_inv := _, right_inv := _},	z : equiv.perm (fin 5) := {to_fun := ![0, 3, 2, 1, 4], inv_fun := ![0, 3, 2, 1, 4], left_inv := _, right_inv := _}	⊢ x ≠ 1		x : equiv.perm (fin 5) := {to_fun := ![1, 2, 0, 3, 4], inv_fun := ![2, 0, 1, 3, 4], left_inv := _, right_inv := _},	y : equiv.perm (fin 5) := {to_fun := ![3, 4, 2, 0, 1], inv_fun := ![3, 4, 2, 0, 1], left_inv := _, right_inv := _},	z : equiv.perm (fin 5) := {to_fun := ![0, 3, 2, 1, 4], inv_fun := ![0, 3, 2, 1, 4], left_inv := _, right_inv := _},	x_ne_one : x ≠ 1	⊢ ¬is_solvable (equiv.perm (fin 5))
x : equiv.perm (fin 5) := {to_fun := ![1, 2, 0, 3, 4], inv_fun := ![2, 0, 1, 3, 4], left_inv := _, right_inv := _},	y : equiv.perm (fin 5) := {to_fun := ![3, 4, 2, 0, 1], inv_fun := ![3, 4, 2, 0, 1], left_inv := _, right_inv := _},	z : equiv.perm (fin 5) := {to_fun := ![0, 3, 2, 1, 4], inv_fun := ![0, 3, 2, 1, 4], left_inv := _, right_inv := _},	x_ne_one : x ≠ 1	⊢ ¬is_solvable (equiv.perm (fin 5))
x : equiv.perm (fin 5) := {to_fun := ![1, 2, 0, 3, 4], inv_fun := ![2, 0, 1, 3, 4], left_inv := _, right_inv := _},	y : equiv.perm (fin 5) := {to_fun := ![3, 4, 2, 0, 1], inv_fun := ![3, 4, 2, 0, 1], left_inv := _, right_inv := _},	z : equiv.perm (fin 5) := {to_fun := ![0, 3, 2, 1, 4], inv_fun := ![0, 3, 2, 1, 4], left_inv := _, right_inv := _},	x_ne_one : x ≠ 1,	a : fin 5	⊢ ↑(⇑x a) = ↑(⇑(z * (x * (y * x * y⁻¹) * x⁻¹ * (y * x * y⁻¹)⁻¹) * z⁻¹) a)
x : equiv.perm (fin 5) := {to_fun := ![1, 2, 0, 3, 4], inv_fun := ![2, 0, 1, 3, 4], left_inv := _, right_inv := _},	y : equiv.perm (fin 5) := {to_fun := ![3, 4, 2, 0, 1], inv_fun := ![3, 4, 2, 0, 1], left_inv := _, right_inv := _},	z : equiv.perm (fin 5) := {to_fun := ![0, 3, 2, 1, 4], inv_fun := ![0, 3, 2, 1, 4], left_inv := _, right_inv := _},	x_ne_one : x ≠ 1	⊢ x = z * (x * (y * x * y⁻¹) * x⁻¹ * (y * x * y⁻¹)⁻¹) * z⁻¹		x : equiv.perm (fin 5) := {to_fun := ![1, 2, 0, 3, 4], inv_fun := ![2, 0, 1, 3, 4], left_inv := _, right_inv := _},	y : equiv.perm (fin 5) := {to_fun := ![3, 4, 2, 0, 1], inv_fun := ![3, 4, 2, 0, 1], left_inv := _, right_inv := _},	z : equiv.perm (fin 5) := {to_fun := ![0, 3, 2, 1, 4], inv_fun := ![0, 3, 2, 1, 4], left_inv := _, right_inv := _},	x_ne_one : x ≠ 1,	key : x = z * (x * (y * x * y⁻¹) * x⁻¹ * (y * x * y⁻¹)⁻¹) * z⁻¹	⊢ ¬is_solvable (equiv.perm (fin 5))
x : equiv.perm (fin 5) := {to_fun := ![1, 2, 0, 3, 4], inv_fun := ![2, 0, 1, 3, 4], left_inv := _, right_inv := _},	y : equiv.perm (fin 5) := {to_fun := ![3, 4, 2, 0, 1], inv_fun := ![3, 4, 2, 0, 1], left_inv := _, right_inv := _},	z : equiv.perm (fin 5) := {to_fun := ![0, 3, 2, 1, 4], inv_fun := ![0, 3, 2, 1, 4], left_inv := _, right_inv := _},	x_ne_one : x ≠ 1	⊢ x = z * (x * (y * x * y⁻¹) * x⁻¹ * (y * x * y⁻¹)⁻¹) * z⁻¹
x : equiv.perm (fin 5) := {to_fun := ![1, 2, 0, 3, 4], inv_fun := ![2, 0, 1, 3, 4], left_inv := _, right_inv := _},	y : equiv.perm (fin 5) := {to_fun := ![3, 4, 2, 0, 1], inv_fun := ![3, 4, 2, 0, 1], left_inv := _, right_inv := _},	z : equiv.perm (fin 5) := {to_fun := ![0, 3, 2, 1, 4], inv_fun := ![0, 3, 2, 1, 4], left_inv := _, right_inv := _},	x_ne_one : x ≠ 1,	key : x = z * (x * (y * x * y⁻¹) * x⁻¹ * (y * x * y⁻¹)⁻¹) * z⁻¹	⊢ ¬is_solvable (equiv.perm (fin 5))
x : equiv.perm (fin 5) := {to_fun := ![1, 2, 0, 3, 4], inv_fun := ![2, 0, 1, 3, 4], left_inv := _, right_inv := _},	y : equiv.perm (fin 5) := {to_fun := ![3, 4, 2, 0, 1], inv_fun := ![3, 4, 2, 0, 1], left_inv := _, right_inv := _},	z : equiv.perm (fin 5) := {to_fun := ![0, 3, 2, 1, 4], inv_fun := ![0, 3, 2, 1, 4], left_inv := _, right_inv := _},	x_ne_one : x ≠ 1,	key : x = z * (x * (y * x * y⁻¹) * x⁻¹ * (y * x * y⁻¹)⁻¹) * z⁻¹,	n : ℕ	⊢ x ∈ derived_series (equiv.perm (fin 5)) n
x : equiv.perm (fin 5) := {to_fun := ![1, 2, 0, 3, 4], inv_fun := ![2, 0, 1, 3, 4], left_inv := _, right_inv := _},	y : equiv.perm (fin 5) := {to_fun := ![3, 4, 2, 0, 1], inv_fun := ![3, 4, 2, 0, 1], left_inv := _, right_inv := _},	z : equiv.perm (fin 5) := {to_fun := ![0, 3, 2, 1, 4], inv_fun := ![0, 3, 2, 1, 4], left_inv := _, right_inv := _},	x_ne_one : x ≠ 1,	key : x = z * (x * (y * x * y⁻¹) * x⁻¹ * (y * x * y⁻¹)⁻¹) * z⁻¹	⊢ x ∈ derived_series (equiv.perm (fin 5)) 0		case nat.succ	x : equiv.perm (fin 5) := {to_fun := ![1, 2, 0, 3, 4], inv_fun := ![2, 0, 1, 3, 4], left_inv := _, right_inv := _},	y : equiv.perm (fin 5) := {to_fun := ![3, 4, 2, 0, 1], inv_fun := ![3, 4, 2, 0, 1], left_inv := _, right_inv := _},	z : equiv.perm (fin 5) := {to_fun := ![0, 3, 2, 1, 4], inv_fun := ![0, 3, 2, 1, 4], left_inv := _, right_inv := _},	x_ne_one : x ≠ 1,	key : x = z * (x * (y * x * y⁻¹) * x⁻¹ * (y * x * y⁻¹)⁻¹) * z⁻¹,	n : ℕ,	ih : x ∈ derived_series (equiv.perm (fin 5)) n	⊢ x ∈ derived_series (equiv.perm (fin 5)) n.succ
x : equiv.perm (fin 5) := {to_fun := ![1, 2, 0, 3, 4], inv_fun := ![2, 0, 1, 3, 4], left_inv := _, right_inv := _},	y : equiv.perm (fin 5) := {to_fun := ![3, 4, 2, 0, 1], inv_fun := ![3, 4, 2, 0, 1], left_inv := _, right_inv := _},	z : equiv.perm (fin 5) := {to_fun := ![0, 3, 2, 1, 4], inv_fun := ![0, 3, 2, 1, 4], left_inv := _, right_inv := _},	x_ne_one : x ≠ 1,	key : x = z * (x * (y * x * y⁻¹) * x⁻¹ * (y * x * y⁻¹)⁻¹) * z⁻¹	⊢ x ∈ derived_series (equiv.perm (fin 5)) 0
x : equiv.perm (fin 5) := {to_fun := ![1, 2, 0, 3, 4], inv_fun := ![2, 0, 1, 3, 4], left_inv := _, right_inv := _},	y : equiv.perm (fin 5) := {to_fun := ![3, 4, 2, 0, 1], inv_fun := ![3, 4, 2, 0, 1], left_inv := _, right_inv := _},	z : equiv.perm (fin 5) := {to_fun := ![0, 3, 2, 1, 4], inv_fun := ![0, 3, 2, 1, 4], left_inv := _, right_inv := _},	x_ne_one : x ≠ 1,	key : x = z * (x * (y * x * y⁻¹) * x⁻¹ * (y * x * y⁻¹)⁻¹) * z⁻¹,	n : ℕ,	ih : x ∈ derived_series (equiv.perm (fin 5)) n	⊢ x ∈ derived_series (equiv.perm (fin 5)) n.succ
x : equiv.perm (fin 5) := {to_fun := ![1, 2, 0, 3, 4], inv_fun := ![2, 0, 1, 3, 4], left_inv := _, right_inv := _},	y : equiv.perm (fin 5) := {to_fun := ![3, 4, 2, 0, 1], inv_fun := ![3, 4, 2, 0, 1], left_inv := _, right_inv := _},	z : equiv.perm (fin 5) := {to_fun := ![0, 3, 2, 1, 4], inv_fun := ![0, 3, 2, 1, 4], left_inv := _, right_inv := _},	x_ne_one : x ≠ 1,	key : x = z * (x * (y * x * y⁻¹) * x⁻¹ * (y * x * y⁻¹)⁻¹) * z⁻¹,	n : ℕ,	ih : x ∈ derived_series (equiv.perm (fin 5)) n	⊢ z * (x * (y * x * y⁻¹) * x⁻¹ * (y * x * y⁻¹)⁻¹) * z⁻¹ ∈ derived_series (equiv.perm (fin 5)) n.succ
n : ℕ,	_inst_1 : fact (0 < n)	⊢ fintype.card (dihedral_group n) = 2 * n
A : Type u_2,	_inst_2 : add_group A,	H : add_subgroup A,	x : A,	hx : x ∈ H,	gsmul_mem : ∀ (n : ℤ), n • x ∈ H,	n : ℕ	⊢ ↑n • x ∈ H
A : Type u_2,	_inst_2 : add_group A,	H : add_subgroup A,	x : A,	hx : x ∈ H,	gsmul_mem : ∀ (n : ℤ), n • x ∈ H,	n : ℕ	⊢ n • x ∈ H
A : Type u_2,	_inst_2 : add_group A,	H : add_subgroup A,	x : A,	hx : x ∈ H,	gsmul_mem : ∀ (n : ℤ), n • x ∈ H,	n : ℕ	⊢ -[1+ n] • x ∈ H
A : Type u_2,	_inst_2 : add_group A,	H : add_subgroup A,	x : A,	hx : x ∈ H,	gsmul_mem : ∀ (n : ℤ), n • x ∈ H,	n : ℕ	⊢ -(n.succ • x) ∈ H
A : Type u_2,	_inst_2 : add_group A,	H : add_subgroup A,	x : A,	hx : x ∈ H,	gsmul_mem : ∀ (n : ℤ), n • x ∈ H,	n : ℕ	⊢ n.succ • x ∈ H.carrier
G : Type u_1,	_inst_1 : group G,	H : Type u_2,	_inst_4 : group H,	_inst_5 : is_simple_group G,	_inst_6 : nontrivial H,	f : G →* H,	hf : function.surjective ⇑f,	H : subgroup H,	iH : H.normal	⊢ H = ⊥ ∨ H = ⊤
G : Type u_1,	_inst_1 : group G,	H : Type u_2,	_inst_4 : group H,	_inst_5 : is_simple_group G,	_inst_6 : nontrivial H,	f : G →* H,	hf : function.surjective ⇑f,	H : subgroup H,	iH : H.normal,	h : subgroup.comap f H = ⊥	⊢ H = ⊥
G : Type u_1,	_inst_1 : group G,	H : Type u_2,	_inst_4 : group H,	_inst_5 : is_simple_group G,	_inst_6 : nontrivial H,	f : G →* H,	hf : function.surjective ⇑f,	H : subgroup H,	iH : H.normal,	h : subgroup.comap f H = ⊥	⊢ H = ⊥		G : Type u_1,	_inst_1 : group G,	H : Type u_2,	_inst_4 : group H,	_inst_5 : is_simple_group G,	_inst_6 : nontrivial H,	f : G →* H,	hf : function.surjective ⇑f,	H : subgroup H,	iH : H.normal,	h : subgroup.comap f H = ⊤	⊢ H = ⊤
G : Type u_1,	_inst_1 : group G,	H : Type u_2,	_inst_4 : group H,	_inst_5 : is_simple_group G,	_inst_6 : nontrivial H,	f : G →* H,	hf : function.surjective ⇑f,	H : subgroup H,	iH : H.normal,	h : subgroup.comap f H = subgroup.comap f ⊤	⊢ H = ⊤
G : Type u_1,	_inst_1 : group G,	H : Type u_2,	_inst_4 : group H,	_inst_5 : is_simple_group G,	_inst_6 : nontrivial H,	f : G →* H,	hf : function.surjective ⇑f,	H : subgroup H,	iH : H.normal,	h : subgroup.comap f H = ⊤	⊢ H = ⊤
G : Type u_1,	_inst_1 : group G,	H N : subgroup G,	hN : N.normal	⊢ 1 * 1 = 1
G : Type u_1,	_inst_1 : group G,	H N : subgroup G,	hN : N.normal,	a b : G,	_x : a ∈ ↑H * ↑N,	_fun_match : a ∈ ↑H * ↑N → b ∈ ↑H * ↑N → a * b ∈ ↑H * ↑N,	h n : G,	hh : h ∈ ↑H,	hn : n ∈ ↑N,	ha : h * n = a,	_x : b ∈ ↑H * ↑N,	_fun_match : b ∈ ↑H * ↑N → a * b ∈ ↑H * ↑N,	h' n' : G,	hh' : h' ∈ ↑H,	hn' : n' ∈ ↑N,	hb : h' * n' = b	⊢ h'⁻¹ * n * h' ∈ N
G : Type u_1,	_inst_1 : group G,	H N : subgroup G,	hN : N.normal,	a b : G,	_x : a ∈ ↑H * ↑N,	_fun_match : a ∈ ↑H * ↑N → b ∈ ↑H * ↑N → a * b ∈ ↑H * ↑N,	h n : G,	hh : h ∈ ↑H,	hn : n ∈ ↑N,	ha : h * n = a,	_x : b ∈ ↑H * ↑N,	_fun_match : b ∈ ↑H * ↑N → a * b ∈ ↑H * ↑N,	h' n' : G,	hh' : h' ∈ ↑H,	hn' : n' ∈ ↑N,	hb : h' * n' = b	⊢ h * h' * (h'⁻¹ * n * h' * n') = a * b
G : Type u_1,	_inst_1 : group G,	H N : subgroup G,	hN : N.normal,	x : G,	_x : x ∈ ↑H * ↑N,	_fun_match : x ∈ ↑H * ↑N → x⁻¹ ∈ ↑H * ↑N,	h n : G,	hh : h ∈ ↑H,	hn : n ∈ ↑N,	hx : h * n = x	⊢ h⁻¹ * (h * n⁻¹ * h⁻¹) = x⁻¹
M : Type u_1,	N : Type u_2,	_inst_1 : mul_one_class M,	_inst_3 : mul_one_class N,	f g : M →* N	⊢ 1 ∈ {x : M | ⇑f x = ⇑g x}
M : Type u_1,	N : Type u_2,	_inst_1 : mul_one_class M,	_inst_3 : mul_one_class N,	f g : M →* N,	x y : M,	hx : ⇑f x = ⇑g x,	hy : ⇑f y = ⇑g y	⊢ x * y ∈ {x : M | ⇑f x = ⇑g x}
M' : Type u_4,	_inst_4 : monoid M',	S : submonoid M'	⊢ is_scalar_tower ↥S M' M'
R : Type u_1,	_inst_1 : comm_ring R,	I : ideal R,	M : Type u_2,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	x : Hausdorffification I M,	x : M,	hx : ∀ (n : ℕ), quotient.mk' x ≡ 0 [SMOD I ^ n • ⊤],	n : ℕ	⊢ x ∈ I ^ n • ⊤
R : Type u_1,	_inst_1 : comm_ring R,	I : ideal R,	M : Type u_2,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	x : Hausdorffification I M,	x : M,	hx : ∀ (n : ℕ), quotient.mk' x ≡ 0 [SMOD I ^ n • ⊤],	n : ℕ,	this : submodule.comap (⨅ (n : ℕ), I ^ n • ⊤).mkq (submodule.map (⨅ (n : ℕ), I ^ n • ⊤).mkq (I ^ n • ⊤)) = (⨅ (n : ℕ), I ^ n • ⊤) ⊔ I ^ n • ⊤	⊢ x ∈ I ^ n • ⊤
R : Type u_1,	_inst_1 : comm_ring R,	I : ideal R,	M : Type u_2,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	x : Hausdorffification I M,	x : M,	hx : ∀ (n : ℕ), quotient.mk' x ≡ 0 [SMOD I ^ n • ⊤],	n : ℕ,	this : submodule.comap (⨅ (n : ℕ), I ^ n • ⊤).mkq (submodule.map (⨅ (n : ℕ), I ^ n • ⊤).mkq (I ^ n • ⊤)) = I ^ n • ⊤	⊢ x ∈ I ^ n • ⊤
R : Type u_1,	_inst_1 : comm_ring R,	I : ideal R,	M : Type u_2,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	x : Hausdorffification I M,	x : M,	hx : ∀ (n : ℕ), quotient.mk' x ≡ 0 [SMOD I ^ n • ⊤],	n : ℕ,	this : submodule.comap (⨅ (n : ℕ), I ^ n • ⊤).mkq (submodule.map (⨅ (n : ℕ), I ^ n • ⊤).mkq (I ^ n • ⊤)) = I ^ n • ⊤	⊢ ⇑((⨅ (n : ℕ), I ^ n • ⊤).mkq) x ≡ 0 [SMOD I ^ n • ⊤]
R : Type u_1,	_inst_1 : comm_ring R,	I : ideal R,	M : Type u_2,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	f : Π (n : ℕ), (I ^ n • ⊤).quotient,	m n : ℕ,	h : m ≤ n	⊢ I ^ n • ⊤ ≤ (I ^ m • ⊤).mkq.ker
R : Type u_1,	_inst_1 : comm_ring R,	I : ideal R,	M : Type u_2,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	f : Π (n : ℕ), (I ^ n • ⊤).quotient,	m n : ℕ,	h : m ≤ n	⊢ I ^ n • ⊤ ≤ I ^ m • ⊤
R : Type u_1,	_inst_1 : comm_ring R,	I : ideal R,	M : Type u_2,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	m n : ℕ,	hmn : m ≤ n	⊢ ⇑((I ^ n • ⊤).liftq (I ^ m • ⊤).mkq _) (0 n) = 0 m
R : Type u_1,	_inst_1 : comm_ring R,	I : ideal R,	M : Type u_2,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	f g : Π (n : ℕ), (I ^ n • ⊤).quotient,	hf : f ∈ {f : Π (n : ℕ), (I ^ n • ⊤).quotient | ∀ {m n : ℕ} (h : m ≤ n), ⇑((I ^ n • ⊤).liftq (I ^ m • ⊤).mkq _) (f n) = f m},	hg : g ∈ {f : Π (n : ℕ), (I ^ n • ⊤).quotient | ∀ {m n : ℕ} (h : m ≤ n), ⇑((I ^ n • ⊤).liftq (I ^ m • ⊤).mkq _) (f n) = f m},	m n : ℕ,	hmn : m ≤ n	⊢ ⇑((I ^ n • ⊤).liftq (I ^ m • ⊤).mkq _) ((f + g) n) = (f + g) m
R : Type u_1,	_inst_1 : comm_ring R,	I : ideal R,	M : Type u_2,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	c : R,	f : Π (n : ℕ), (I ^ n • ⊤).quotient,	hf : f ∈ {f : Π (n : ℕ), (I ^ n • ⊤).quotient | ∀ {m n : ℕ} (h : m ≤ n), ⇑((I ^ n • ⊤).liftq (I ^ m • ⊤).mkq _) (f n) = f m},	m n : ℕ,	hmn : m ≤ n	⊢ ⇑((I ^ n • ⊤).liftq (I ^ m • ⊤).mkq _) ((c • f) n) = (c • f) m
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	p : P,	ps : set P,	h : p ∈ affine_span k ps	⊢ affine_span k (has_insert.insert p ps) = affine_span k ps
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	p : P,	ps : set P,	h : p ∈ ↑(affine_span k ps)	⊢ affine_span k (has_insert.insert p ps) = affine_span k ps
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	s : set P,	p1 p2 : P,	hp1 : p1 ∈ span_points k s,	hp2 : p2 ∈ span_points k s	⊢ p1 -ᵥ p2 ∈ vector_span k s
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	s : set P,	p1 p2 : P,	hp2 : p2 ∈ span_points k s,	p1a : P,	hp1a : p1a ∈ s,	v1 : V,	hv1 : v1 ∈ vector_span k s,	hv1p : p1 = v1 +ᵥ p1a	⊢ p1 -ᵥ p2 ∈ vector_span k s
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	s : set P,	p1 p2 p1a : P,	hp1a : p1a ∈ s,	v1 : V,	hv1 : v1 ∈ vector_span k s,	hv1p : p1 = v1 +ᵥ p1a,	p2a : P,	hp2a : p2a ∈ s,	v2 : V,	hv2 : v2 ∈ vector_span k s,	hv2p : p2 = v2 +ᵥ p2a	⊢ p1 -ᵥ p2 ∈ vector_span k s
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	s : set P,	p1 p2 p1a : P,	hp1a : p1a ∈ s,	v1 : V,	hv1 : v1 ∈ vector_span k s,	hv1p : p1 = v1 +ᵥ p1a,	p2a : P,	hp2a : p2a ∈ s,	v2 : V,	hv2 : v2 ∈ vector_span k s,	hv2p : p2 = v2 +ᵥ p2a	⊢ p1a -ᵥ p2a + (v1 - v2) ∈ vector_span k s
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	s : set P,	p1 p2 p1a : P,	hp1a : p1a ∈ s,	v1 : V,	hv1 : v1 ∈ vector_span k s,	hv1p : p1 = v1 +ᵥ p1a,	p2a : P,	hp2a : p2a ∈ s,	v2 : V,	hv2 : v2 ∈ vector_span k s,	hv2p : p2 = v2 +ᵥ p2a	⊢ v1 - v2 ∈ vector_span k s
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	s : set P,	p1 p2 p1a : P,	hp1a : p1a ∈ s,	v1 : V,	hv1 : v1 ∈ vector_span k s,	hv1p : p1 = v1 +ᵥ p1a,	p2a : P,	hp2a : p2a ∈ s,	v2 : V,	hv2 : v2 ∈ vector_span k s,	hv2p : p2 = v2 +ᵥ p2a	⊢ v1 + -v2 ∈ vector_span k s
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	s : set P,	p1 p2 p1a : P,	hp1a : p1a ∈ s,	v1 : V,	hv1 : v1 ∈ vector_span k s,	hv1p : p1 = v1 +ᵥ p1a,	p2a : P,	hp2a : p2a ∈ s,	v2 : V,	hv2 : v2 ∈ vector_span k s,	hv2p : p2 = v2 +ᵥ p2a	⊢ -v2 ∈ vector_span k s
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	s : set P,	p1 p2 p1a : P,	hp1a : p1a ∈ s,	v1 : V,	hv1 : v1 ∈ vector_span k s,	hv1p : p1 = v1 +ᵥ p1a,	p2a : P,	hp2a : p2a ∈ s,	v2 : V,	hv2 : v2 ∈ vector_span k s,	hv2p : p2 = v2 +ᵥ p2a	⊢ v1 - v2 ∈ vector_span k s		k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	s : set P,	p1 p2 p1a : P,	hp1a : p1a ∈ s,	v1 : V,	hv1 : v1 ∈ vector_span k s,	hv1p : p1 = v1 +ᵥ p1a,	p2a : P,	hp2a : p2a ∈ s,	v2 : V,	hv2 : v2 ∈ vector_span k s,	hv2p : p2 = v2 +ᵥ p2a,	hv1v2 : v1 - v2 ∈ vector_span k s	⊢ p1a -ᵥ p2a + (v1 - v2) ∈ vector_span k s
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	s : set P,	p1 p2 p1a : P,	hp1a : p1a ∈ s,	v1 : V,	hv1 : v1 ∈ vector_span k s,	hv1p : p1 = v1 +ᵥ p1a,	p2a : P,	hp2a : p2a ∈ s,	v2 : V,	hv2 : v2 ∈ vector_span k s,	hv2p : p2 = v2 +ᵥ p2a	⊢ (-1) • v2 ∈ vector_span k s
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	s : set P,	p1 p2 p1a : P,	hp1a : p1a ∈ s,	v1 : V,	hv1 : v1 ∈ vector_span k s,	hv1p : p1 = v1 +ᵥ p1a,	p2a : P,	hp2a : p2a ∈ s,	v2 : V,	hv2 : v2 ∈ vector_span k s,	hv2p : p2 = v2 +ᵥ p2a,	hv1v2 : v1 - v2 ∈ vector_span k s	⊢ p1a -ᵥ p2a + (v1 - v2) ∈ vector_span k s
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	s : set P,	p1 p2 p1a : P,	hp1a : p1a ∈ s,	v1 : V,	hv1 : v1 ∈ vector_span k s,	hv1p : p1 = v1 +ᵥ p1a,	p2a : P,	hp2a : p2a ∈ s,	v2 : V,	hv2 : v2 ∈ vector_span k s,	hv2p : p2 = v2 +ᵥ p2a,	hv1v2 : v1 - v2 ∈ vector_span k s	⊢ p1a -ᵥ p2a ∈ vector_span k s
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	p : P,	direction : submodule k V,	c : k,	p1 p2 p3 : P,	hp1 : p1 ∈ {q : P | ∃ (v : V) (H : v ∈ direction), q = v +ᵥ p},	hp2 : p2 ∈ {q : P | ∃ (v : V) (H : v ∈ direction), q = v +ᵥ p},	hp3 : p3 ∈ {q : P | ∃ (v : V) (H : v ∈ direction), q = v +ᵥ p}	⊢ c • (p1 -ᵥ p2) +ᵥ p3 ∈ {q : P | ∃ (v : V) (H : v ∈ direction), q = v +ᵥ p}
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	p : P,	direction : submodule k V,	c : k,	p1 p2 p3 : P,	hp2 : p2 ∈ {q : P | ∃ (v : V) (H : v ∈ direction), q = v +ᵥ p},	hp3 : p3 ∈ {q : P | ∃ (v : V) (H : v ∈ direction), q = v +ᵥ p},	v1 : V,	hv1 : v1 ∈ direction,	hp1 : p1 = v1 +ᵥ p	⊢ c • (p1 -ᵥ p2) +ᵥ p3 ∈ {q : P | ∃ (v : V) (H : v ∈ direction), q = v +ᵥ p}
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	p : P,	direction : submodule k V,	c : k,	p1 p2 p3 : P,	hp3 : p3 ∈ {q : P | ∃ (v : V) (H : v ∈ direction), q = v +ᵥ p},	v1 : V,	hv1 : v1 ∈ direction,	hp1 : p1 = v1 +ᵥ p,	v2 : V,	hv2 : v2 ∈ direction,	hp2 : p2 = v2 +ᵥ p	⊢ c • (p1 -ᵥ p2) +ᵥ p3 ∈ {q : P | ∃ (v : V) (H : v ∈ direction), q = v +ᵥ p}
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	p : P,	direction : submodule k V,	c : k,	p1 p2 p3 : P,	v1 : V,	hv1 : v1 ∈ direction,	hp1 : p1 = v1 +ᵥ p,	v2 : V,	hv2 : v2 ∈ direction,	hp2 : p2 = v2 +ᵥ p,	v3 : V,	hv3 : v3 ∈ direction,	hp3 : p3 = v3 +ᵥ p	⊢ c • (p1 -ᵥ p2) +ᵥ p3 ∈ {q : P | ∃ (v : V) (H : v ∈ direction), q = v +ᵥ p}
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	p : P,	direction : submodule k V,	c : k,	p1 p2 p3 : P,	v1 : V,	hv1 : v1 ∈ direction,	hp1 : p1 = v1 +ᵥ p,	v2 : V,	hv2 : v2 ∈ direction,	hp2 : p2 = v2 +ᵥ p,	v3 : V,	hv3 : v3 ∈ direction,	hp3 : p3 = v3 +ᵥ p	⊢ c • (p1 -ᵥ p2) +ᵥ p3 = c • (v1 - v2) + v3 +ᵥ p
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	p : P,	direction : submodule k V	⊢ (affine_subspace.mk' p direction).direction = direction
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	p : P,	direction : submodule k V,	v : V	⊢ v ∈ (affine_subspace.mk' p direction).direction ↔ v ∈ direction
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	p : P,	direction : submodule k V,	v : V	⊢ (∃ (p1 : P) (H : p1 ∈ affine_subspace.mk' p direction) (p2 : P) (H : p2 ∈ affine_subspace.mk' p direction), v = p1 -ᵥ p2) ↔ v ∈ direction
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	p : P,	direction : submodule k V,	v : V	⊢ (∃ (p1 : P) (H : p1 ∈ affine_subspace.mk' p direction) (p2 : P) (H : p2 ∈ affine_subspace.mk' p direction), v = p1 -ᵥ p2) → v ∈ direction
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	p : P,	direction : submodule k V,	v : V,	p1 : P,	v1 : V,	hv1 : v1 ∈ direction,	hp1 : p1 = v1 +ᵥ p,	p2 : P,	hv : v = p1 -ᵥ p2,	v2 : V,	hv2 : v2 ∈ direction,	hp2 : p2 = v2 +ᵥ p	⊢ v ∈ direction
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	p : P,	direction : submodule k V,	v : V	⊢ (∃ (p1 : P) (H : p1 ∈ affine_subspace.mk' p direction) (p2 : P) (H : p2 ∈ affine_subspace.mk' p direction), v = p1 -ᵥ p2) → v ∈ direction		k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	p : P,	direction : submodule k V,	v : V	⊢ v ∈ direction → (∃ (p1 : P) (H : p1 ∈ affine_subspace.mk' p direction) (p2 : P) (H : p2 ∈ affine_subspace.mk' p direction), v = p1 -ᵥ p2)
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	p : P,	direction : submodule k V,	v : V,	p1 : P,	v1 : V,	hv1 : v1 ∈ direction,	hp1 : p1 = v1 +ᵥ p,	p2 : P,	hv : v = p1 -ᵥ p2,	v2 : V,	hv2 : v2 ∈ direction,	hp2 : p2 = v2 +ᵥ p	⊢ v1 - v2 ∈ direction
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	p : P,	direction : submodule k V,	v : V	⊢ v ∈ direction → (∃ (p1 : P) (H : p1 ∈ affine_subspace.mk' p direction) (p2 : P) (H : p2 ∈ affine_subspace.mk' p direction), v = p1 -ᵥ p2)
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	S : affine_space V P	⊢ ⊤.direction = ⊤
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	S : affine_space V P,	p : P	⊢ ⊤.direction = ⊤
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	S : affine_space V P,	p : P,	v : V	⊢ v ∈ ⊤.direction ↔ v ∈ ⊤
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	S : affine_space V P,	p : P,	v : V,	hv : v ∈ ⊤	⊢ v ∈ ⊤.direction
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	S : affine_space V P,	p : P,	v : V,	hv : v ∈ ⊤,	hpv : v +ᵥ p -ᵥ p ∈ ⊤.direction	⊢ v ∈ ⊤.direction
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	s : set P,	p : P,	hp : p ∈ s	⊢ vector_span k s = submodule.span k (has_vsub.vsub p '' s)
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	s : set P,	p : P,	hp : p ∈ s	⊢ submodule.span k (s -ᵥ s) = submodule.span k (has_vsub.vsub p '' s)
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	s : set P,	p : P,	hp : p ∈ s	⊢ submodule.span k (s -ᵥ s) ≤ submodule.span k (has_vsub.vsub p '' s)
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	s : set P,	p : P,	hp : p ∈ s	⊢ s -ᵥ s ⊆ ↑(submodule.span k (has_vsub.vsub p '' s))
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	s : set P,	p : P,	hp : p ∈ s,	v : V,	p1 p2 : P,	hp1 : p1 ∈ s,	hp2 : p2 ∈ s,	hv : p1 -ᵥ p2 = v	⊢ v ∈ ↑(submodule.span k (has_vsub.vsub p '' s))
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	s : set P,	p : P,	hp : p ∈ s,	v : V,	p1 p2 : P,	hp1 : p1 ∈ s,	hp2 : p2 ∈ s,	hv : p -ᵥ p2 - (p -ᵥ p1) = v	⊢ v ∈ ↑(submodule.span k (has_vsub.vsub p '' s))
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	s : set P,	p : P,	hp : p ∈ s,	v : V,	p1 p2 : P,	hp1 : p1 ∈ s,	hp2 : p2 ∈ s,	hv : p -ᵥ p2 - (p -ᵥ p1) = v	⊢ ∀ (p_1 : submodule k V), has_vsub.vsub p '' s ⊆ ↑p_1 → p -ᵥ p2 - (p -ᵥ p1) ∈ p_1
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	s : set P,	p : P,	hp : p ∈ s	⊢ submodule.span k (s -ᵥ s) ≤ submodule.span k (has_vsub.vsub p '' s)		k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	s : set P,	p : P,	hp : p ∈ s	⊢ has_vsub.vsub p '' s ⊆ s -ᵥ s
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	s : set P,	p : P,	hp : p ∈ s	⊢ has_vsub.vsub p '' s ⊆ s -ᵥ s
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	s : set P,	p : P,	hp : p ∈ s,	v : V,	p2 : P,	hp2 : p2 ∈ s,	hv : p -ᵥ p2 = v	⊢ v ∈ s -ᵥ s
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	p : ι → P,	s : set ι,	i : ι,	hi : i ∈ s	⊢ vector_span k (p '' s) = ?m_1
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	p : ι → P,	s : set ι,	i : ι,	hi : i ∈ s	⊢ vector_span k (p '' s) = submodule.span k (has_vsub.vsub (p i) '' (p '' (s \ {i})))
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	p : ι → P,	s : set ι,	i : ι,	hi : i ∈ s	⊢ submodule.span k (has_insert.insert (p i -ᵥ p i) (has_vsub.vsub (p i) '' (p '' (s \ {i})))) = submodule.span k (has_vsub.vsub (p i) '' (p '' (s \ {i})))
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	S : affine_space V P,	ι : Type u_4,	s : finset ι,	w : ι → k,	p : ι → P,	h : ∑ (i : ι) in s, w i = 1,	b₁ b₂ : P,	x : ι	⊢ w x • (p x -ᵥ b₁) - w x • (p x -ᵥ b₂) = ?m_1 x
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	S : affine_space V P,	ι : Type u_4,	s : finset ι,	w : ι → k,	p : ι → P,	h : ∑ (i : ι) in s, w i = 1,	b₁ b₂ : P	⊢ b₁ -ᵥ b₂ + ∑ (x : ι) in s, w x • (b₂ -ᵥ b₁) = 0
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	v : V,	p : ι → P	⊢ v ∈ vector_span k (set.range p) ↔ ∃ (s : finset ι) (w : ι → k) (h : ∑ (i : ι) in s, w i = 0), v = ⇑(s.weighted_vsub p) w
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	v : V,	p : ι → P,	hι : is_empty ι	⊢ v ∈ vector_span k (set.range p) → (∃ (s : finset ι) (w : ι → k) (h : ∑ (i : ι) in s, w i = 0), v = ⇑(s.weighted_vsub p) w)		k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	v : V,	p : ι → P,	i0 : ι	⊢ v ∈ vector_span k (set.range p) → (∃ (s : finset ι) (w : ι → k) (h : ∑ (i : ι) in s, w i = 0), v = ⇑(s.weighted_vsub p) w)
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	v : V,	p : ι → P	⊢ v ∈ vector_span k (set.range p) → (∃ (s : finset ι) (w : ι → k) (h : ∑ (i : ι) in s, w i = 0), v = ⇑(s.weighted_vsub p) w)
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	v : V,	p : ι → P,	i0 : ι	⊢ v ∈ vector_span k (set.range p) → (∃ (s : finset ι) (w : ι → k) (h : ∑ (i : ι) in s, w i = 0), v = ⇑(s.weighted_vsub p) w)
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	v : V,	p : ι → P,	i0 : ι	⊢ (∃ (l : ι →₀ k) (H : l ∈ finsupp.supported k k set.univ), ⇑(finsupp.total ι V k (λ (i : ι), p i -ᵥ p i0)) l = v) → (∃ (s : finset ι) (w : ι → k) (h : ∑ (i : ι) in s, w i = 0), v = ⇑(s.weighted_vsub p) w)
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	v : V,	p : ι → P,	i0 : ι,	l : ι →₀ k,	hl : l ∈ finsupp.supported k k set.univ,	hv : ⇑(finsupp.total ι V k (λ (i : ι), p i -ᵥ p i0)) l = v	⊢ ∃ (s : finset ι) (w : ι → k) (h : ∑ (i : ι) in s, w i = 0), v = ⇑(s.weighted_vsub p) w
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	v : V,	p : ι → P,	i0 : ι,	l : ι →₀ k,	hl : l ∈ finsupp.supported k k set.univ,	hv : ⇑(finsupp.total ι V k (λ (i : ι), p i -ᵥ p i0)) l = v	⊢ ∃ (w : ι → k) (h : ∑ (i : ι) in has_insert.insert i0 l.support, w i = 0), v = ⇑((has_insert.insert i0 l.support).weighted_vsub p) w
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	v : V,	p : ι → P,	i0 : ι,	l : ι →₀ k,	hl : l ∈ finsupp.supported k k set.univ,	hv : ⇑(finsupp.total ι V k (λ (i : ι), p i -ᵥ p i0)) l = v,	w : has_coe_to_fun.F l := ⇑l - function.update (function.const ι 0) i0 (∑ (i : ι) in l.support, ⇑l i),	hwdef : w = ⇑l - function.update (function.const ι 0) i0 (∑ (i : ι) in l.support, ⇑l i)	⊢ ∃ (w : ι → k) (h : ∑ (i : ι) in has_insert.insert i0 l.support, w i = 0), v = ⇑((has_insert.insert i0 l.support).weighted_vsub p) w
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	v : V,	p : ι → P,	i0 : ι,	l : ι →₀ k,	hl : l ∈ finsupp.supported k k set.univ,	hv : ⇑(finsupp.total ι V k (λ (i : ι), p i -ᵥ p i0)) l = v,	w : has_coe_to_fun.F l := ⇑l - function.update (function.const ι 0) i0 (∑ (i : ι) in l.support, ⇑l i),	hwdef : w = ⇑l - function.update (function.const ι 0) i0 (∑ (i : ι) in l.support, ⇑l i)	⊢ ∑ (i : ι) in has_insert.insert i0 l.support, w i = 0 ∧ v = ⇑((has_insert.insert i0 l.support).weighted_vsub p) w
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	v : V,	p : ι → P,	i0 : ι,	l : ι →₀ k,	hl : l ∈ finsupp.supported k k set.univ,	hv : ⇑(finsupp.total ι V k (λ (i : ι), p i -ᵥ p i0)) l = v,	w : has_coe_to_fun.F l := ⇑l - function.update (function.const ι 0) i0 (∑ (i : ι) in l.support, ⇑l i),	hwdef : w = ⇑l - function.update (function.const ι 0) i0 (∑ (i : ι) in l.support, ⇑l i)	⊢ ∑ (i : ι) in has_insert.insert i0 l.support, w i = 0
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	v : V,	p : ι → P,	i0 : ι,	l : ι →₀ k,	hl : l ∈ finsupp.supported k k set.univ,	hv : ⇑(finsupp.total ι V k (λ (i : ι), p i -ᵥ p i0)) l = v,	w : has_coe_to_fun.F l := ⇑l - function.update (function.const ι 0) i0 (∑ (i : ι) in l.support, ⇑l i),	hwdef : w = ⇑l - function.update (function.const ι 0) i0 (∑ (i : ι) in l.support, ⇑l i)	⊢ ∑ (i : ι) in has_insert.insert i0 l.support, (⇑l - function.update (function.const ι 0) i0 (∑ (i : ι) in l.support, ⇑l i)) i = 0
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	v : V,	p : ι → P,	i0 : ι,	l : ι →₀ k,	hl : l ∈ finsupp.supported k k set.univ,	hv : ⇑(finsupp.total ι V k (λ (i : ι), p i -ᵥ p i0)) l = v,	w : has_coe_to_fun.F l := ⇑l - function.update (function.const ι 0) i0 (∑ (i : ι) in l.support, ⇑l i),	hwdef : w = ⇑l - function.update (function.const ι 0) i0 (∑ (i : ι) in l.support, ⇑l i)	⊢ ∑ (i : ι) in has_insert.insert i0 l.support, w i = 0		k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	v : V,	p : ι → P,	i0 : ι,	l : ι →₀ k,	hl : l ∈ finsupp.supported k k set.univ,	hv : ⇑(finsupp.total ι V k (λ (i : ι), p i -ᵥ p i0)) l = v,	w : has_coe_to_fun.F l := ⇑l - function.update (function.const ι 0) i0 (∑ (i : ι) in l.support, ⇑l i),	hwdef : w = ⇑l - function.update (function.const ι 0) i0 (∑ (i : ι) in l.support, ⇑l i),	hw : ∑ (i : ι) in has_insert.insert i0 l.support, w i = 0	⊢ ∑ (i : ι) in has_insert.insert i0 l.support, w i = 0 ∧ v = ⇑((has_insert.insert i0 l.support).weighted_vsub p) w
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	v : V,	p : ι → P,	i0 : ι,	l : ι →₀ k,	hl : l ∈ finsupp.supported k k set.univ,	hv : ⇑(finsupp.total ι V k (λ (i : ι), p i -ᵥ p i0)) l = v,	w : has_coe_to_fun.F l := ⇑l - function.update (function.const ι 0) i0 (∑ (i : ι) in l.support, ⇑l i),	hwdef : w = ⇑l - function.update (function.const ι 0) i0 (∑ (i : ι) in l.support, ⇑l i),	hw : ∑ (i : ι) in has_insert.insert i0 l.support, w i = 0	⊢ ∑ (i : ι) in has_insert.insert i0 l.support, w i = 0 ∧ v = ⇑((has_insert.insert i0 l.support).weighted_vsub p) w
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	v : V,	p : ι → P,	i0 : ι,	l : ι →₀ k,	hl : l ∈ finsupp.supported k k set.univ,	hv : ⇑(finsupp.total ι V k (λ (i : ι), p i -ᵥ p i0)) l = v,	w : has_coe_to_fun.F l := ⇑l - function.update (function.const ι 0) i0 (∑ (i : ι) in l.support, ⇑l i),	hwdef : w = ⇑l - function.update (function.const ι 0) i0 (∑ (i : ι) in l.support, ⇑l i),	hw : ∑ (i : ι) in has_insert.insert i0 l.support, w i = 0	⊢ v = ⇑((has_insert.insert i0 l.support).weighted_vsub p) w
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	v : V,	p : ι → P,	i0 : ι,	l : ι →₀ k,	hl : l ∈ finsupp.supported k k set.univ,	hv : ⇑(finsupp.total ι V k (λ (i : ι), p i -ᵥ p i0)) l = v,	w : has_coe_to_fun.F l := ⇑l - function.update (function.const ι 0) i0 (∑ (i : ι) in l.support, ⇑l i),	hwdef : w = ⇑l - function.update (function.const ι 0) i0 (∑ (i : ι) in l.support, ⇑l i),	hw : ∑ (i : ι) in has_insert.insert i0 l.support, w i = 0,	hz : w i0 • (p i0 -ᵥ p i0) = 0	⊢ v = ⇑((has_insert.insert i0 l.support).weighted_vsub p) w
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	v : V,	p : ι → P,	i0 : ι,	l : ι →₀ k,	hl : l ∈ finsupp.supported k k set.univ,	hv : ⇑(finsupp.total ι V k (λ (i : ι), p i -ᵥ p i0)) l = v,	w : has_coe_to_fun.F l := ⇑l - function.update (function.const ι 0) i0 (∑ (i : ι) in l.support, ⇑l i),	hwdef : w = ⇑l - function.update (function.const ι 0) i0 (∑ (i : ι) in l.support, ⇑l i),	hw : ∑ (i : ι) in has_insert.insert i0 l.support, w i = 0,	hz : (λ (i : ι), w i • (p i -ᵥ p i0)) i0 = 0	⊢ v = ⇑((has_insert.insert i0 l.support).weighted_vsub p) w
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	v : V,	p : ι → P,	i0 : ι,	l : ι →₀ k,	hl : l ∈ finsupp.supported k k set.univ,	hv : ⇑(finsupp.total ι V k (λ (i : ι), p i -ᵥ p i0)) l = v,	w : has_coe_to_fun.F l := ⇑l - function.update (function.const ι 0) i0 (∑ (i : ι) in l.support, ⇑l i),	hwdef : w = ⇑l - function.update (function.const ι 0) i0 (∑ (i : ι) in l.support, ⇑l i),	hw : ∑ (i : ι) in has_insert.insert i0 l.support, w i = 0,	hz : (λ (i : ι), w i • (p i -ᵥ p i0)) i0 = 0	⊢ l.sum (λ (i : ι) (a : k), a • (p i -ᵥ p i0)) = ∑ (x : ι) in l.support, (λ (i : ι), w i • (p i -ᵥ p i0)) x
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	v : V,	p : ι → P,	i0 : ι,	l : ι →₀ k,	hl : l ∈ finsupp.supported k k set.univ,	hv : ⇑(finsupp.total ι V k (λ (i : ι), p i -ᵥ p i0)) l = v,	w : has_coe_to_fun.F l := ⇑l - function.update (function.const ι 0) i0 (∑ (i : ι) in l.support, ⇑l i),	hwdef : w = ⇑l - function.update (function.const ι 0) i0 (∑ (i : ι) in l.support, ⇑l i),	hw : ∑ (i : ι) in has_insert.insert i0 l.support, w i = 0,	hz : (λ (i : ι), w i • (p i -ᵥ p i0)) i0 = 0	⊢ ∑ (i : ι) in l.support, ⇑l i • (p i -ᵥ p i0) = ∑ (x : ι) in l.support, (λ (i : ι), w i • (p i -ᵥ p i0)) x
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	v : V,	p : ι → P,	i0 : ι,	l : ι →₀ k,	hl : l ∈ finsupp.supported k k set.univ,	hv : ⇑(finsupp.total ι V k (λ (i : ι), p i -ᵥ p i0)) l = v,	w : has_coe_to_fun.F l := ⇑l - function.update (function.const ι 0) i0 (∑ (i : ι) in l.support, ⇑l i),	hwdef : w = ⇑l - function.update (function.const ι 0) i0 (∑ (i : ι) in l.support, ⇑l i),	hw : ∑ (i : ι) in has_insert.insert i0 l.support, w i = 0,	hz : (λ (i : ι), w i • (p i -ᵥ p i0)) i0 = 0,	i : ι	⊢ ⇑l i • (p i -ᵥ p i0) = (λ (i : ι), w i • (p i -ᵥ p i0)) i
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	v : V,	p : ι → P,	i0 : ι,	l : ι →₀ k,	hl : l ∈ finsupp.supported k k set.univ,	hv : ⇑(finsupp.total ι V k (λ (i : ι), p i -ᵥ p i0)) l = v,	w : has_coe_to_fun.F l := ⇑l - function.update (function.const ι 0) i0 (∑ (i : ι) in l.support, ⇑l i),	hwdef : w = ⇑l - function.update (function.const ι 0) i0 (∑ (i : ι) in l.support, ⇑l i),	hw : ∑ (i : ι) in has_insert.insert i0 l.support, w i = 0,	hz : (λ (i : ι), w i • (p i -ᵥ p i0)) i0 = 0,	i : ι,	h : i = i0	⊢ ⇑l i • (p i -ᵥ p i0) = (λ (i : ι), w i • (p i -ᵥ p i0)) i		k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	v : V,	p : ι → P,	i0 : ι,	l : ι →₀ k,	hl : l ∈ finsupp.supported k k set.univ,	hv : ⇑(finsupp.total ι V k (λ (i : ι), p i -ᵥ p i0)) l = v,	w : has_coe_to_fun.F l := ⇑l - function.update (function.const ι 0) i0 (∑ (i : ι) in l.support, ⇑l i),	hwdef : w = ⇑l - function.update (function.const ι 0) i0 (∑ (i : ι) in l.support, ⇑l i),	hw : ∑ (i : ι) in has_insert.insert i0 l.support, w i = 0,	hz : (λ (i : ι), w i • (p i -ᵥ p i0)) i0 = 0,	i : ι,	h : ¬i = i0	⊢ ⇑l i • (p i -ᵥ p i0) = (λ (i : ι), w i • (p i -ᵥ p i0)) i
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	v : V,	p : ι → P,	i0 : ι,	l : ι →₀ k,	hl : l ∈ finsupp.supported k k set.univ,	hv : ⇑(finsupp.total ι V k (λ (i : ι), p i -ᵥ p i0)) l = v,	w : has_coe_to_fun.F l := ⇑l - function.update (function.const ι 0) i0 (∑ (i : ι) in l.support, ⇑l i),	hwdef : w = ⇑l - function.update (function.const ι 0) i0 (∑ (i : ι) in l.support, ⇑l i),	hw : ∑ (i : ι) in has_insert.insert i0 l.support, w i = 0,	hz : (λ (i : ι), w i • (p i -ᵥ p i0)) i0 = 0,	i : ι,	h : i = i0	⊢ ⇑l i • (p i -ᵥ p i0) = (λ (i : ι), w i • (p i -ᵥ p i0)) i
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	v : V,	p : ι → P,	i0 : ι	⊢ v ∈ vector_span k (set.range p) → (∃ (s : finset ι) (w : ι → k) (h : ∑ (i : ι) in s, w i = 0), v = ⇑(s.weighted_vsub p) w)		k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	v : V,	p : ι → P,	hι : is_empty ι	⊢ v ∈ vector_span k (set.range p) → (∃ (s : finset ι) (w : ι → k) (h : ∑ (i : ι) in s, w i = 0), v = ⇑(s.weighted_vsub p) w)
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	v : V,	p : ι → P,	i0 : ι,	l : ι →₀ k,	hl : l ∈ finsupp.supported k k set.univ,	hv : ⇑(finsupp.total ι V k (λ (i : ι), p i -ᵥ p i0)) l = v,	w : has_coe_to_fun.F l := ⇑l - function.update (function.const ι 0) i0 (∑ (i : ι) in l.support, ⇑l i),	hwdef : w = ⇑l - function.update (function.const ι 0) i0 (∑ (i : ι) in l.support, ⇑l i),	hw : ∑ (i : ι) in has_insert.insert i0 l.support, w i = 0,	hz : (λ (i : ι), w i • (p i -ᵥ p i0)) i0 = 0,	i : ι,	h : ¬i = i0	⊢ ⇑l i • (p i -ᵥ p i0) = (λ (i : ι), w i • (p i -ᵥ p i0)) i
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	v : V,	p : ι → P,	hι : is_empty ι	⊢ v ∈ vector_span k (set.range p) → (∃ (s : finset ι) (w : ι → k) (h : ∑ (i : ι) in s, w i = 0), v = ⇑(s.weighted_vsub p) w)
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	v : V,	p : ι → P,	hι : is_empty ι	⊢ v ∈ vector_span k (set.range p) → (∃ (s : finset ι) (w : ι → k) (h : ∑ (i : ι) in s, w i = 0), v = ⇑(s.weighted_vsub p) w)
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	v : V,	p : ι → P,	hι : is_empty ι	⊢ v = 0 → (∃ (s : finset ι) (w : ι → k) (h : ∑ (i : ι) in s, w i = 0), v = ⇑(s.weighted_vsub p) w)
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	p : ι → P,	hι : is_empty ι	⊢ ∃ (s : finset ι) (w : ι → k) (h : ∑ (i : ι) in s, w i = 0), 0 = ⇑(s.weighted_vsub p) w
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	v : V,	p : ι → P	⊢ v ∈ vector_span k (set.range p) → (∃ (s : finset ι) (w : ι → k) (h : ∑ (i : ι) in s, w i = 0), v = ⇑(s.weighted_vsub p) w)		k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	v : V,	p : ι → P	⊢ (∃ (s : finset ι) (w : ι → k) (h : ∑ (i : ι) in s, w i = 0), v = ⇑(s.weighted_vsub p) w) → v ∈ vector_span k (set.range p)
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	p : ι → P,	hι : is_empty ι	⊢ ∃ (w : ι → k) (h : ∑ (i : ι) in ∅, w i = 0), 0 = ⇑(∅.weighted_vsub p) w
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	v : V,	p : ι → P	⊢ (∃ (s : finset ι) (w : ι → k) (h : ∑ (i : ι) in s, w i = 0), v = ⇑(s.weighted_vsub p) w) → v ∈ vector_span k (set.range p)
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	p : ι → P,	s : finset ι,	w : ι → k,	hw : ∑ (i : ι) in s, w i = 0	⊢ ⇑(s.weighted_vsub p) w ∈ vector_span k (set.range p)
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	S : affine_space V P,	ι : Type u_4,	s : finset ι,	w : ι → k,	p : ι → P,	h : ∑ (i : ι) in s, w i = 1,	b₁ b₂ : P	⊢ ⇑(s.weighted_vsub_of_point p b₁) w +ᵥ b₁ = ⇑(s.weighted_vsub_of_point p b₂) w +ᵥ b₂
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	S : affine_space V P,	ι : Type u_4,	s : finset ι,	w : ι → k,	p : ι → P,	h : ∑ (i : ι) in s, w i = 1,	b₁ b₂ : P	⊢ b₁ -ᵥ b₂ + ∑ (x : ι) in s, (w x • (p x -ᵥ b₁) - w x • (p x -ᵥ b₂)) = 0
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	S : affine_space V P,	ι : Type u_4,	s : finset ι,	w : ι → k,	p : ι → P,	h : ∑ (i : ι) in s, w i = 1,	b₁ b₂ : P	⊢ b₁ -ᵥ b₂ + ∑ (x : ι) in s, (w x • (p x -ᵥ b₁) - w x • (p x -ᵥ b₂)) = ?m_1
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	S : affine_space V P,	ι : Type u_4,	s : finset ι,	w : ι → k,	p : ι → P,	h : ∑ (i : ι) in s, w i = 1,	b₁ b₂ : P	⊢ b₁ -ᵥ b₂ = ?m_1		k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	S : affine_space V P,	ι : Type u_4,	s : finset ι,	w : ι → k,	p : ι → P,	h : ∑ (i : ι) in s, w i = 1,	b₁ b₂ : P	⊢ ∑ (x : ι) in s, (w x • (p x -ᵥ b₁) - w x • (p x -ᵥ b₂)) = ?m_1
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	S : affine_space V P,	ι : Type u_4,	s : finset ι,	w : ι → k,	p : ι → P,	h : ∑ (i : ι) in s, w i = 1,	b₁ b₂ : P	⊢ ∑ (x : ι) in s, (w x • (p x -ᵥ b₁) - w x • (p x -ᵥ b₂)) = ?m_1
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	S : affine_space V P,	ι : Type u_4,	s : finset ι,	w : ι → k,	p : ι → P,	h : ∑ (i : ι) in s, w i = 1,	b₁ b₂ : P	⊢ s = ?m_1		k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	S : affine_space V P,	ι : Type u_4,	s : finset ι,	w : ι → k,	p : ι → P,	h : ∑ (i : ι) in s, w i = 1,	b₁ b₂ : P	⊢ (λ (x : ι), w x • (p x -ᵥ b₁) - w x • (p x -ᵥ b₂)) = ?m_1
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	S : affine_space V P,	ι : Type u_4,	s : finset ι,	w : ι → k,	p : ι → P,	h : ∑ (i : ι) in s, w i = 1,	b₁ b₂ : P	⊢ (λ (x : ι), w x • (p x -ᵥ b₁) - w x • (p x -ᵥ b₂)) = ?m_1
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : field k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	p : fin 3 → P	⊢ affine_independent k p ↔ ¬collinear k (set.range p)
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	ι2 : Type u_5,	f : ι2 ↪ ι,	p : ι → P,	ha : affine_independent k p	⊢ affine_independent k (p ∘ ⇑f)
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	ι2 : Type u_5,	f : ι2 ↪ ι,	p : ι → P,	ha : affine_independent k p,	fs : finset ι2,	w : ι2 → k,	hw : ∑ (i : ι2) in fs, w i = 0,	hs : ⇑(fs.weighted_vsub (p ∘ ⇑f)) w = 0,	i0 : ι2,	hi0 : i0 ∈ fs	⊢ w i0 = 0
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	ι2 : Type u_5,	f : ι2 ↪ ι,	p : ι → P,	ha : affine_independent k p,	fs : finset ι2,	w : ι2 → k,	hw : ∑ (i : ι2) in fs, w i = 0,	hs : ⇑(fs.weighted_vsub (p ∘ ⇑f)) w = 0,	i0 : ι2,	hi0 : i0 ∈ fs,	fs' : finset ι := finset.map f fs	⊢ w i0 = 0
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	ι2 : Type u_5,	f : ι2 ↪ ι,	p : ι → P,	ha : affine_independent k p,	fs : finset ι2,	w : ι2 → k,	hw : ∑ (i : ι2) in fs, w i = 0,	hs : ⇑(fs.weighted_vsub (p ∘ ⇑f)) w = 0,	i0 : ι2,	hi0 : i0 ∈ fs,	fs' : finset ι := finset.map f fs,	w' : ι → k := λ (i : ι), dite (∃ (i2 : ι2), ⇑f i2 = i) (λ (h : ∃ (i2 : ι2), ⇑f i2 = i), w h.some) (λ (h : ¬∃ (i2 : ι2), ⇑f i2 = i), 0)	⊢ w i0 = 0
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	ι2 : Type u_5,	f : ι2 ↪ ι,	p : ι → P,	ha : affine_independent k p,	fs : finset ι2,	w : ι2 → k,	hw : ∑ (i : ι2) in fs, w i = 0,	hs : ⇑(fs.weighted_vsub (p ∘ ⇑f)) w = 0,	i0 : ι2,	hi0 : i0 ∈ fs,	fs' : finset ι := finset.map f fs,	w' : ι → k := λ (i : ι), dite (∃ (i2 : ι2), ⇑f i2 = i) (λ (h : ∃ (i2 : ι2), ⇑f i2 = i), w h.some) (λ (h : ¬∃ (i2 : ι2), ⇑f i2 = i), 0)	⊢ ∀ (i2 : ι2), w' (⇑f i2) = w i2
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	ι2 : Type u_5,	f : ι2 ↪ ι,	p : ι → P,	ha : affine_independent k p,	fs : finset ι2,	w : ι2 → k,	hw : ∑ (i : ι2) in fs, w i = 0,	hs : ⇑(fs.weighted_vsub (p ∘ ⇑f)) w = 0,	i0 : ι2,	hi0 : i0 ∈ fs,	fs' : finset ι := finset.map f fs,	w' : ι → k := λ (i : ι), dite (∃ (i2 : ι2), ⇑f i2 = i) (λ (h : ∃ (i2 : ι2), ⇑f i2 = i), w h.some) (λ (h : ¬∃ (i2 : ι2), ⇑f i2 = i), 0),	i2 : ι2	⊢ w' (⇑f i2) = w i2
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	ι2 : Type u_5,	f : ι2 ↪ ι,	p : ι → P,	ha : affine_independent k p,	fs : finset ι2,	w : ι2 → k,	hw : ∑ (i : ι2) in fs, w i = 0,	hs : ⇑(fs.weighted_vsub (p ∘ ⇑f)) w = 0,	i0 : ι2,	hi0 : i0 ∈ fs,	fs' : finset ι := finset.map f fs,	w' : ι → k := λ (i : ι), dite (∃ (i2 : ι2), ⇑f i2 = i) (λ (h : ∃ (i2 : ι2), ⇑f i2 = i), w h.some) (λ (h : ¬∃ (i2 : ι2), ⇑f i2 = i), 0),	i2 : ι2,	h : ∃ (i : ι2), ⇑f i = ⇑f i2	⊢ w' (⇑f i2) = w i2
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	ι2 : Type u_5,	f : ι2 ↪ ι,	p : ι → P,	ha : affine_independent k p,	fs : finset ι2,	w : ι2 → k,	hw : ∑ (i : ι2) in fs, w i = 0,	hs : ⇑(fs.weighted_vsub (p ∘ ⇑f)) w = 0,	i0 : ι2,	hi0 : i0 ∈ fs,	fs' : finset ι := finset.map f fs,	w' : ι → k := λ (i : ι), dite (∃ (i2 : ι2), ⇑f i2 = i) (λ (h : ∃ (i2 : ι2), ⇑f i2 = i), w h.some) (λ (h : ¬∃ (i2 : ι2), ⇑f i2 = i), 0)	⊢ ∀ (i2 : ι2), w' (⇑f i2) = w i2		k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	ι2 : Type u_5,	f : ι2 ↪ ι,	p : ι → P,	ha : affine_independent k p,	fs : finset ι2,	w : ι2 → k,	hw : ∑ (i : ι2) in fs, w i = 0,	hs : ⇑(fs.weighted_vsub (p ∘ ⇑f)) w = 0,	i0 : ι2,	hi0 : i0 ∈ fs,	fs' : finset ι := finset.map f fs,	w' : ι → k := λ (i : ι), dite (∃ (i2 : ι2), ⇑f i2 = i) (λ (h : ∃ (i2 : ι2), ⇑f i2 = i), w h.some) (λ (h : ¬∃ (i2 : ι2), ⇑f i2 = i), 0),	hw' : ∀ (i2 : ι2), w' (⇑f i2) = w i2	⊢ w i0 = 0
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	ι2 : Type u_5,	f : ι2 ↪ ι,	p : ι → P,	ha : affine_independent k p,	fs : finset ι2,	w : ι2 → k,	hw : ∑ (i : ι2) in fs, w i = 0,	hs : ⇑(fs.weighted_vsub (p ∘ ⇑f)) w = 0,	i0 : ι2,	hi0 : i0 ∈ fs,	fs' : finset ι := finset.map f fs,	w' : ι → k := λ (i : ι), dite (∃ (i2 : ι2), ⇑f i2 = i) (λ (h : ∃ (i2 : ι2), ⇑f i2 = i), w h.some) (λ (h : ¬∃ (i2 : ι2), ⇑f i2 = i), 0),	i2 : ι2,	h : ∃ (i : ι2), ⇑f i = ⇑f i2,	hs : h.some = i2	⊢ w' (⇑f i2) = w i2
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	ι2 : Type u_5,	f : ι2 ↪ ι,	p : ι → P,	ha : affine_independent k p,	fs : finset ι2,	w : ι2 → k,	hw : ∑ (i : ι2) in fs, w i = 0,	hs : ⇑(fs.weighted_vsub (p ∘ ⇑f)) w = 0,	i0 : ι2,	hi0 : i0 ∈ fs,	fs' : finset ι := finset.map f fs,	w' : ι → k := λ (i : ι), dite (∃ (i2 : ι2), ⇑f i2 = i) (λ (h : ∃ (i2 : ι2), ⇑f i2 = i), w h.some) (λ (h : ¬∃ (i2 : ι2), ⇑f i2 = i), 0),	hw' : ∀ (i2 : ι2), w' (⇑f i2) = w i2	⊢ w i0 = 0
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	ι2 : Type u_5,	f : ι2 ↪ ι,	p : ι → P,	ha : affine_independent k p,	fs : finset ι2,	w : ι2 → k,	hw : ∑ (i : ι2) in fs, w i = 0,	hs : ⇑(fs.weighted_vsub (p ∘ ⇑f)) w = 0,	i0 : ι2,	hi0 : i0 ∈ fs,	fs' : finset ι := finset.map f fs,	w' : ι → k := λ (i : ι), dite (∃ (i2 : ι2), ⇑f i2 = i) (λ (h : ∃ (i2 : ι2), ⇑f i2 = i), w h.some) (λ (h : ¬∃ (i2 : ι2), ⇑f i2 = i), 0),	hw' : ∀ (i2 : ι2), w' (⇑f i2) = w i2	⊢ ∑ (i : ι) in fs', w' i = 0
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	ι2 : Type u_5,	f : ι2 ↪ ι,	p : ι → P,	ha : affine_independent k p,	fs : finset ι2,	w : ι2 → k,	hw : ∑ (i : ι2) in fs, w i = 0,	hs : ⇑(fs.weighted_vsub (p ∘ ⇑f)) w = 0,	i0 : ι2,	hi0 : i0 ∈ fs,	fs' : finset ι := finset.map f fs,	w' : ι → k := λ (i : ι), dite (∃ (i2 : ι2), ⇑f i2 = i) (λ (h : ∃ (i2 : ι2), ⇑f i2 = i), w h.some) (λ (h : ¬∃ (i2 : ι2), ⇑f i2 = i), 0),	hw' : ∀ (i2 : ι2), w' (⇑f i2) = w i2	⊢ ∑ (i : ι) in fs', w' i = 0		k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	ι2 : Type u_5,	f : ι2 ↪ ι,	p : ι → P,	ha : affine_independent k p,	fs : finset ι2,	w : ι2 → k,	hw : ∑ (i : ι2) in fs, w i = 0,	hs : ⇑(fs.weighted_vsub (p ∘ ⇑f)) w = 0,	i0 : ι2,	hi0 : i0 ∈ fs,	fs' : finset ι := finset.map f fs,	w' : ι → k := λ (i : ι), dite (∃ (i2 : ι2), ⇑f i2 = i) (λ (h : ∃ (i2 : ι2), ⇑f i2 = i), w h.some) (λ (h : ¬∃ (i2 : ι2), ⇑f i2 = i), 0),	hw' : ∀ (i2 : ι2), w' (⇑f i2) = w i2,	hw's : ∑ (i : ι) in fs', w' i = 0	⊢ w i0 = 0
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	ι2 : Type u_5,	f : ι2 ↪ ι,	p : ι → P,	ha : affine_independent k p,	fs : finset ι2,	w : ι2 → k,	hw : ∑ (i : ι2) in fs, w i = 0,	hs : ⇑(fs.weighted_vsub (p ∘ ⇑f)) w = 0,	i0 : ι2,	hi0 : i0 ∈ fs,	fs' : finset ι := finset.map f fs,	w' : ι → k := λ (i : ι), dite (∃ (i2 : ι2), ⇑f i2 = i) (λ (h : ∃ (i2 : ι2), ⇑f i2 = i), w h.some) (λ (h : ¬∃ (i2 : ι2), ⇑f i2 = i), 0),	hw' : ∀ (i2 : ι2), w' (⇑f i2) = w i2	⊢ ∑ (x : ι2) in fs, w' (⇑f x) = ∑ (i : ι2) in fs, w i
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	ι2 : Type u_5,	f : ι2 ↪ ι,	p : ι → P,	ha : affine_independent k p,	fs : finset ι2,	w : ι2 → k,	hw : ∑ (i : ι2) in fs, w i = 0,	hs : ⇑(fs.weighted_vsub (p ∘ ⇑f)) w = 0,	i0 : ι2,	hi0 : i0 ∈ fs,	fs' : finset ι := finset.map f fs,	w' : ι → k := λ (i : ι), dite (∃ (i2 : ι2), ⇑f i2 = i) (λ (h : ∃ (i2 : ι2), ⇑f i2 = i), w h.some) (λ (h : ¬∃ (i2 : ι2), ⇑f i2 = i), 0),	hw' : ∀ (i2 : ι2), w' (⇑f i2) = w i2,	hw's : ∑ (i : ι) in fs', w' i = 0	⊢ w i0 = 0
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	ι2 : Type u_5,	f : ι2 ↪ ι,	p : ι → P,	ha : affine_independent k p,	fs : finset ι2,	w : ι2 → k,	hw : ∑ (i : ι2) in fs, w i = 0,	hs : ⇑(fs.weighted_vsub (p ∘ ⇑f)) w = 0,	i0 : ι2,	hi0 : i0 ∈ fs,	fs' : finset ι := finset.map f fs,	w' : ι → k := λ (i : ι), dite (∃ (i2 : ι2), ⇑f i2 = i) (λ (h : ∃ (i2 : ι2), ⇑f i2 = i), w h.some) (λ (h : ¬∃ (i2 : ι2), ⇑f i2 = i), 0),	hw' : ∀ (i2 : ι2), w' (⇑f i2) = w i2,	hw's : ∑ (i : ι) in fs', w' i = 0	⊢ ⇑(fs'.weighted_vsub p) w' = 0
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	ι2 : Type u_5,	f : ι2 ↪ ι,	p : ι → P,	ha : affine_independent k p,	fs : finset ι2,	w : ι2 → k,	hw : ∑ (i : ι2) in fs, w i = 0,	hs : ⇑(fs.weighted_vsub (p ∘ ⇑f)) w = 0,	i0 : ι2,	hi0 : i0 ∈ fs,	fs' : finset ι := finset.map f fs,	w' : ι → k := λ (i : ι), dite (∃ (i2 : ι2), ⇑f i2 = i) (λ (h : ∃ (i2 : ι2), ⇑f i2 = i), w h.some) (λ (h : ¬∃ (i2 : ι2), ⇑f i2 = i), 0),	hw' : ∀ (i2 : ι2), w' (⇑f i2) = w i2,	hw's : ∑ (i : ι) in fs', w' i = 0	⊢ ⇑(fs.weighted_vsub (p ∘ ⇑f)) (w' ∘ ⇑f) = ⇑(fs.weighted_vsub (p ∘ ⇑f)) w
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	ι2 : Type u_5,	f : ι2 ↪ ι,	p : ι → P,	ha : affine_independent k p,	fs : finset ι2,	w : ι2 → k,	hw : ∑ (i : ι2) in fs, w i = 0,	hs : ⇑(fs.weighted_vsub (p ∘ ⇑f)) w = 0,	i0 : ι2,	hi0 : i0 ∈ fs,	fs' : finset ι := finset.map f fs,	w' : ι → k := λ (i : ι), dite (∃ (i2 : ι2), ⇑f i2 = i) (λ (h : ∃ (i2 : ι2), ⇑f i2 = i), w h.some) (λ (h : ¬∃ (i2 : ι2), ⇑f i2 = i), 0),	hw' : ∀ (i2 : ι2), w' (⇑f i2) = w i2,	hw's : ∑ (i : ι) in fs', w' i = 0	⊢ ⇑(fs'.weighted_vsub p) w' = 0		k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	ι2 : Type u_5,	f : ι2 ↪ ι,	p : ι → P,	ha : affine_independent k p,	fs : finset ι2,	w : ι2 → k,	hw : ∑ (i : ι2) in fs, w i = 0,	hs : ⇑(fs.weighted_vsub (p ∘ ⇑f)) w = 0,	i0 : ι2,	hi0 : i0 ∈ fs,	fs' : finset ι := finset.map f fs,	w' : ι → k := λ (i : ι), dite (∃ (i2 : ι2), ⇑f i2 = i) (λ (h : ∃ (i2 : ι2), ⇑f i2 = i), w h.some) (λ (h : ¬∃ (i2 : ι2), ⇑f i2 = i), 0),	hw' : ∀ (i2 : ι2), w' (⇑f i2) = w i2,	hw's : ∑ (i : ι) in fs', w' i = 0,	hs' : ⇑(fs'.weighted_vsub p) w' = 0	⊢ w i0 = 0
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	ι2 : Type u_5,	f : ι2 ↪ ι,	p : ι → P,	ha : affine_independent k p,	fs : finset ι2,	w : ι2 → k,	hw : ∑ (i : ι2) in fs, w i = 0,	hs : ⇑(fs.weighted_vsub (p ∘ ⇑f)) w = 0,	i0 : ι2,	hi0 : i0 ∈ fs,	fs' : finset ι := finset.map f fs,	w' : ι → k := λ (i : ι), dite (∃ (i2 : ι2), ⇑f i2 = i) (λ (h : ∃ (i2 : ι2), ⇑f i2 = i), w h.some) (λ (h : ¬∃ (i2 : ι2), ⇑f i2 = i), 0),	hw' : ∀ (i2 : ι2), w' (⇑f i2) = w i2,	hw's : ∑ (i : ι) in fs', w' i = 0,	i : ι2	⊢ (w' ∘ ⇑f) i = w i
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : affine_space V P,	ι : Type u_4,	ι2 : Type u_5,	f : ι2 ↪ ι,	p : ι → P,	ha : affine_independent k p,	fs : finset ι2,	w : ι2 → k,	hw : ∑ (i : ι2) in fs, w i = 0,	hs : ⇑(fs.weighted_vsub (p ∘ ⇑f)) w = 0,	i0 : ι2,	hi0 : i0 ∈ fs,	fs' : finset ι := finset.map f fs,	w' : ι → k := λ (i : ι), dite (∃ (i2 : ι2), ⇑f i2 = i) (λ (h : ∃ (i2 : ι2), ⇑f i2 = i), w h.some) (λ (h : ¬∃ (i2 : ι2), ⇑f i2 = i), 0),	hw' : ∀ (i2 : ι2), w' (⇑f i2) = w i2,	hw's : ∑ (i : ι) in fs', w' i = 0,	hs' : ⇑(fs'.weighted_vsub p) w' = 0	⊢ w i0 = 0
k : Type u_1,	E : Type u_2,	PE : Type u_3,	_inst_1 : field k,	_inst_2 : add_comm_group E,	_inst_3 : module k E,	_inst_4 : add_torsor E PE,	f : k → PE,	a b : k	⊢ slope f a b = slope f b a
R : Type u_1,	_inst_1 : semiring R,	M : Type u_2,	_inst_2 : add_comm_monoid M,	_inst_3 : module R M,	N' : Type u_5,	_inst_8 : add_comm_group N',	_inst_9 : module R N',	ι : Type u_6,	_inst_10 : decidable_eq ι,	f : alternating_map R M N' ι,	v : ι → M,	i j : ι,	h : v i = v j,	hij : i ≠ j	⊢ (-↑f).to_fun v = 0
α : Type u_1,	β : Type u_2,	_inst_22 : decidable_eq (α ⊕ β),	i j : α ⊕ β,	σ : equiv.perm.mod_sum_congr α β	⊢ equiv.swap i j • equiv.swap i j • σ = σ
α : Type u_1,	β : Type u_2,	_inst_22 : decidable_eq (α ⊕ β),	i j : α ⊕ β,	σ : equiv.perm.mod_sum_congr α β,	σ : equiv.perm (α ⊕ β)	⊢ equiv.swap i j • equiv.swap i j • quotient.mk' σ = quotient.mk' σ
ιa : Type u_7,	ιb : Type u_8,	_inst_11 : decidable_eq ιa,	_inst_12 : decidable_eq ιb,	_inst_13 : fintype ιa,	_inst_14 : fintype ιb,	R' : Type u_9,	Mᵢ : Type u_10,	N₁ : Type u_11,	N₂ : Type u_12,	_inst_15 : comm_semiring R',	_inst_16 : add_comm_group N₁,	_inst_17 : module R' N₁,	_inst_18 : add_comm_group N₂,	_inst_19 : module R' N₂,	_inst_20 : add_comm_monoid Mᵢ,	_inst_21 : module R' Mᵢ,	a : alternating_map R' Mᵢ N₁ ιa,	b : alternating_map R' Mᵢ N₂ ιb,	v : ιa ⊕ ιb → Mᵢ,	i j : ιa ⊕ ιb,	hv : v i = v j,	hij : i ≠ j	⊢ (⇑∑ (σ : equiv.perm.mod_sum_congr ιa ιb), alternating_map.dom_coprod.summand a b σ) v = 0
ιa : Type u_7,	ιb : Type u_8,	_inst_11 : decidable_eq ιa,	_inst_12 : decidable_eq ιb,	_inst_13 : fintype ιa,	_inst_14 : fintype ιb,	R' : Type u_9,	Mᵢ : Type u_10,	N₁ : Type u_11,	N₂ : Type u_12,	_inst_15 : comm_semiring R',	_inst_16 : add_comm_group N₁,	_inst_17 : module R' N₁,	_inst_18 : add_comm_group N₂,	_inst_19 : module R' N₂,	_inst_20 : add_comm_monoid Mᵢ,	_inst_21 : module R' Mᵢ,	a : alternating_map R' Mᵢ N₁ ιa,	b : alternating_map R' Mᵢ N₂ ιb,	v : ιa ⊕ ιb → Mᵢ,	i j : ιa ⊕ ιb,	hv : v i = v j,	hij : i ≠ j	⊢ ⇑(finset.univ.sum (alternating_map.dom_coprod.summand a b)) v = 0
ιa : Type u_7,	ιb : Type u_8,	_inst_11 : decidable_eq ιa,	_inst_12 : decidable_eq ιb,	_inst_13 : fintype ιa,	_inst_14 : fintype ιb,	R' : Type u_9,	Mᵢ : Type u_10,	N₁ : Type u_11,	N₂ : Type u_12,	_inst_15 : comm_semiring R',	_inst_16 : add_comm_group N₁,	_inst_17 : module R' N₁,	_inst_18 : add_comm_group N₂,	_inst_19 : module R' N₂,	_inst_20 : add_comm_monoid Mᵢ,	_inst_21 : module R' Mᵢ,	a : alternating_map R' Mᵢ N₁ ιa,	b : alternating_map R' Mᵢ N₂ ιb,	v : ιa ⊕ ιb → Mᵢ,	i j : ιa ⊕ ιb,	hv : v i = v j,	hij : i ≠ j	⊢ ∑ (a_1 : equiv.perm.mod_sum_congr ιa ιb), ⇑(alternating_map.dom_coprod.summand a b a_1) v = 0
R : Type u_1,	M : Type u_8,	_inst_1 : semiring R,	_inst_4 : add_comm_monoid M,	_inst_8 : module R M,	p p' : submodule R M,	x : M	⊢ x ∈ ↑(p ⊔ p') ↔ x ∈ ↑p + ↑p'
R : Type u_1,	M : Type u_8,	_inst_1 : semiring R,	_inst_4 : add_comm_monoid M,	_inst_8 : module R M,	p p' : submodule R M,	x : M	⊢ (∃ (y : M) (H : y ∈ p) (z : M) (H : z ∈ p'), y + z = x) ↔ ∃ (x_1 y : M), x_1 ∈ ↑p ∧ y ∈ ↑p' ∧ x_1 + y = x
R : Type u_1,	M : Type u_8,	_inst_1 : semiring R,	_inst_4 : add_comm_monoid M,	_inst_8 : module R M,	p p' : submodule R M	⊢ ↑(p ⊔ p') = ↑p + ↑p'
R : Type u_1,	R₂ : Type u_3,	R₃ : Type u_4,	M : Type u_8,	M₂ : Type u_11,	M₃ : Type u_12,	_inst_1 : semiring R,	_inst_2 : semiring R₂,	_inst_3 : semiring R₃,	_inst_4 : add_comm_monoid M,	_inst_5 : add_comm_monoid M₂,	_inst_6 : add_comm_monoid M₃,	_inst_7 : module R M,	_inst_8 : module R₂ M₂,	_inst_9 : module R₃ M₃,	τ₁₂ : R →+* R₂,	τ₂₃ : R₂ →+* R₃,	τ₁₃ : R →+* R₃,	_inst_10 : ring_hom_comp_triple τ₁₂ τ₂₃ τ₁₃,	f : M →ₛₗ[τ₁₂] M₂,	g : M₂ →ₛₗ[τ₂₃] M₃,	hg : g.ker = ⊥	⊢ (g.comp f).ker = f.ker
R : Type u_1,	R₂ : Type u_3,	M : Type u_8,	M₂ : Type u_11,	_inst_1 : comm_ring R,	_inst_2 : comm_ring R₂,	_inst_3 : add_comm_group M,	_inst_4 : add_comm_group M₂,	_inst_5 : module R M,	_inst_6 : module R₂ M₂,	τ₁₂ : R →+* R₂,	τ₂₁ : R₂ →+* R,	_inst_11 : ring_hom_inv_pair τ₁₂ τ₂₁,	_inst_12 : ring_hom_inv_pair τ₂₁ τ₁₂,	e : M ≃ₛₗ[τ₁₂] M₂,	K : submodule R M,	_x : M₂	⊢ _x ∈ submodule.map ↑e K ↔ _x ∈ submodule.comap ↑(e.symm) K
R : Type u_1,	M : Type u_8,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : module R M,	m : Type u_19,	n : Type u_20,	f : m → n,	hf : function.injective f	⊢ function.surjective ⇑(linear_map.fun_left R M f)
R : Type u_1,	M : Type u_8,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : module R M,	m : Type u_19,	n : Type u_20,	f : m → n,	hf : function.injective f,	_inst : Π (a : Prop), decidable a	⊢ function.surjective ⇑(linear_map.fun_left R M f)
R : Type u_1,	M : Type u_8,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : module R M,	m : Type u_19,	n : Type u_20,	f : m → n,	hf : function.injective f,	_inst : Π (a : Prop), decidable a,	g : m → M	⊢ ∃ (a : n → M), ⇑(linear_map.fun_left R M f) a = g
R : Type u_1,	M : Type u_8,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : module R M,	m : Type u_19,	n : Type u_20,	f : m → n,	hf : function.injective f,	_inst : Π (a : Prop), decidable a,	g : m → M	⊢ ⇑(linear_map.fun_left R M f) (λ (x : n), dite (∃ (y : m), f y = x) (λ (h : ∃ (y : m), f y = x), g h.some) (λ (h : ¬∃ (y : m), f y = x), 0)) = g
R : Type u_1,	M : Type u_8,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : module R M,	m : Type u_19,	n : Type u_20,	f : m → n,	hf : function.injective f,	_inst : Π (a : Prop), decidable a,	g : m → M,	x : m	⊢ ⇑(linear_map.fun_left R M f) (λ (x : n), dite (∃ (y : m), f y = x) (λ (h : ∃ (y : m), f y = x), g h.some) (λ (h : ¬∃ (y : m), f y = x), 0)) x = g x
R : Type u_1,	M : Type u_8,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : module R M,	m : Type u_19,	n : Type u_20,	f : m → n,	hf : function.injective f,	_inst : Π (a : Prop), decidable a,	g : m → M,	x : m	⊢ dite (∃ (y : m), f y = f x) (λ (h : ∃ (y : m), f y = f x), g h.some) (λ (h : ¬∃ (y : m), f y = f x), 0) = g x
R : Type u_1,	M : Type u_8,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : module R M,	m : Type u_19,	n : Type u_20,	f : m → n,	hf : function.injective f,	_inst : Π (a : Prop), decidable a,	g : m → M,	x : m,	w : ∃ (y : m), f y = f x	⊢ g w.some = g x
R : Type u_1,	M : Type u_8,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : module R M,	m : Type u_19,	n : Type u_20,	f : m → n,	hf : function.injective f,	_inst : Π (a : Prop), decidable a,	g : m → M,	x : m,	w : ∃ (y : m), f y = f x	⊢ g w.some = g x		R : Type u_1,	M : Type u_8,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : module R M,	m : Type u_19,	n : Type u_20,	f : m → n,	hf : function.injective f,	_inst : Π (a : Prop), decidable a,	g : m → M,	x : m,	w : ¬∃ (y : m), f y = f x	⊢ 0 = g x
R : Type u_1,	M : Type u_8,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : module R M,	m : Type u_19,	n : Type u_20,	f : m → n,	hf : function.injective f,	_inst : Π (a : Prop), decidable a,	g : m → M,	x : m,	w : ∃ (y : m), f y = f x	⊢ w.some = x
R : Type u_1,	M : Type u_8,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : module R M,	m : Type u_19,	n : Type u_20,	f : m → n,	hf : function.injective f,	_inst : Π (a : Prop), decidable a,	g : m → M,	x : m,	w : ¬∃ (y : m), f y = f x	⊢ 0 = g x
R : Type u_1,	M : Type u_8,	_inst_1 : semiring R,	_inst_5 : add_comm_monoid M,	_inst_10 : module R M,	_inst_19 : nontrivial M	⊢ nontrivial (module.End R M)
R : Type u_1,	M : Type u_8,	_inst_1 : semiring R,	_inst_5 : add_comm_monoid M,	_inst_10 : module R M,	_inst_19 : nontrivial M,	m : M,	ne : m ≠ 0	⊢ nontrivial (module.End R M)
R : Type u_1,	R₃ : Type u_4,	M : Type u_8,	M₃ : Type u_12,	_inst_1 : semiring R,	_inst_3 : semiring R₃,	_inst_5 : add_comm_monoid M,	_inst_7 : add_comm_group M₃,	_inst_9 : module R M,	_inst_11 : module R₃ M₃,	σ₁₃ : R →+* R₃,	f g : M →ₛₗ[σ₁₃] M₃,	x y : M	⊢ (⇑f - ⇑g) (x + y) = (⇑f - ⇑g) x + (⇑f - ⇑g) y
R : Type u_1,	R₃ : Type u_4,	M : Type u_8,	M₃ : Type u_12,	_inst_1 : semiring R,	_inst_3 : semiring R₃,	_inst_5 : add_comm_monoid M,	_inst_7 : add_comm_group M₃,	_inst_9 : module R M,	_inst_11 : module R₃ M₃,	σ₁₃ : R →+* R₃,	f g : M →ₛₗ[σ₁₃] M₃,	r : R,	x : M	⊢ (⇑f - ⇑g) (r • x) = ⇑σ₁₃ r • (⇑f - ⇑g) x
R : Type u_1,	R₂ : Type u_3,	M : Type u_8,	M₂ : Type u_11,	_inst_1 : semiring R,	_inst_2 : semiring R₂,	_inst_4 : add_comm_monoid M,	_inst_5 : add_comm_monoid M₂,	_inst_8 : module R M,	_inst_10 : module R₂ M₂,	σ₁₂ : R →+* R₂,	σ₂₁ : R₂ →+* R,	_inst_12 : ring_hom_inv_pair σ₁₂ σ₂₁,	_inst_13 : ring_hom_inv_pair σ₂₁ σ₁₂,	f : M →ₛₗ[σ₁₂] M₂,	i : function.injective ⇑f,	p : submodule R M	⊢ ∀ (x y : ↥p), (equiv.set.image ⇑f ↑p i).to_fun (x + y) = (equiv.set.image ⇑f ↑p i).to_fun x + (equiv.set.image ⇑f ↑p i).to_fun y
R : Type u_1,	R₂ : Type u_3,	M : Type u_8,	M₂ : Type u_11,	_inst_1 : semiring R,	_inst_2 : semiring R₂,	_inst_4 : add_comm_monoid M,	_inst_5 : add_comm_monoid M₂,	_inst_8 : module R M,	_inst_10 : module R₂ M₂,	σ₁₂ : R →+* R₂,	σ₂₁ : R₂ →+* R,	_inst_12 : ring_hom_inv_pair σ₁₂ σ₂₁,	_inst_13 : ring_hom_inv_pair σ₂₁ σ₁₂,	f : M →ₛₗ[σ₁₂] M₂,	i : function.injective ⇑f,	p : submodule R M,	x y : ↥p	⊢ (equiv.set.image ⇑f ↑p i).to_fun (x + y) = (equiv.set.image ⇑f ↑p i).to_fun x + (equiv.set.image ⇑f ↑p i).to_fun y
R : Type u_1,	R₂ : Type u_3,	M : Type u_8,	M₂ : Type u_11,	_inst_1 : semiring R,	_inst_2 : semiring R₂,	_inst_4 : add_comm_monoid M,	_inst_5 : add_comm_monoid M₂,	_inst_8 : module R M,	_inst_10 : module R₂ M₂,	σ₁₂ : R →+* R₂,	σ₂₁ : R₂ →+* R,	_inst_12 : ring_hom_inv_pair σ₁₂ σ₂₁,	_inst_13 : ring_hom_inv_pair σ₂₁ σ₁₂,	f : M →ₛₗ[σ₁₂] M₂,	i : function.injective ⇑f,	p : submodule R M,	x y : ↥p	⊢ ⟨⇑f ↑x + ⇑f ↑y, _⟩ = ⟨⇑f ↑x, _⟩ + ⟨⇑f ↑y, _⟩
R : Type u_1,	R₂ : Type u_3,	M : Type u_8,	M₂ : Type u_11,	_inst_1 : semiring R,	_inst_2 : semiring R₂,	_inst_4 : add_comm_monoid M,	_inst_5 : add_comm_monoid M₂,	_inst_8 : module R M,	_inst_10 : module R₂ M₂,	σ₁₂ : R →+* R₂,	σ₂₁ : R₂ →+* R,	_inst_12 : ring_hom_inv_pair σ₁₂ σ₂₁,	_inst_13 : ring_hom_inv_pair σ₂₁ σ₁₂,	f : M →ₛₗ[σ₁₂] M₂,	i : function.injective ⇑f,	p : submodule R M	⊢ ∀ (r : R) (x : ↥p), (equiv.set.image ⇑f ↑p i).to_fun (r • x) = ⇑σ₁₂ r • (equiv.set.image ⇑f ↑p i).to_fun x
R : Type u_1,	R₂ : Type u_3,	M : Type u_8,	M₂ : Type u_11,	_inst_1 : semiring R,	_inst_2 : semiring R₂,	_inst_4 : add_comm_monoid M,	_inst_5 : add_comm_monoid M₂,	_inst_8 : module R M,	_inst_10 : module R₂ M₂,	σ₁₂ : R →+* R₂,	σ₂₁ : R₂ →+* R,	_inst_12 : ring_hom_inv_pair σ₁₂ σ₂₁,	_inst_13 : ring_hom_inv_pair σ₂₁ σ₁₂,	f : M →ₛₗ[σ₁₂] M₂,	i : function.injective ⇑f,	p : submodule R M,	r : R,	x : ↥p	⊢ (equiv.set.image ⇑f ↑p i).to_fun (r • x) = ⇑σ₁₂ r • (equiv.set.image ⇑f ↑p i).to_fun x
R : Type u_1,	R₂ : Type u_3,	M : Type u_8,	M₂ : Type u_11,	_inst_1 : semiring R,	_inst_2 : semiring R₂,	_inst_4 : add_comm_monoid M,	_inst_5 : add_comm_monoid M₂,	_inst_8 : module R M,	_inst_10 : module R₂ M₂,	σ₁₂ : R →+* R₂,	σ₂₁ : R₂ →+* R,	_inst_12 : ring_hom_inv_pair σ₁₂ σ₂₁,	_inst_13 : ring_hom_inv_pair σ₂₁ σ₁₂,	f : M →ₛₗ[σ₁₂] M₂,	i : function.injective ⇑f,	p : submodule R M,	r : R,	x : ↥p	⊢ ⟨⇑σ₁₂ r • ⇑f ↑x, _⟩ = ⇑σ₁₂ r • ⟨⇑f ↑x, _⟩
K : Type u_4,	V : Type u,	V' : Type u_8,	_inst_1 : field K,	_inst_2 : add_comm_group V,	_inst_3 : add_comm_group V',	_inst_4 : module K V,	_inst_5 : module K V',	p : submodule K V,	f : ↥p →ₗ[K] V',	_let_match : (∃ (g : V →ₗ[K] ↥p), g.comp p.subtype = linear_map.id) → (∃ (g : V →ₗ[K] V'), g.comp p.subtype = f),	g : V →ₗ[K] ↥p,	hg : g.comp p.subtype = linear_map.id	⊢ (f.comp g).comp p.subtype = f
ι : Type u_1,	R : Type u_3,	M : Type u_5,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : module R M,	b : basis ι R M,	i : ι,	h : opt_param (⇑b i ∈ set.range (λ (i : ι), ⇑b i)) _	⊢ ⇑(b.reindex_range) ⟨⇑b i, h⟩ = ⇑b i
ι : Type u_1,	R : Type u_3,	M : Type u_5,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : module R M,	b : basis ι R M,	i : ι,	h : opt_param (⇑b i ∈ set.range (λ (i : ι), ⇑b i)) _,	htr : nontrivial R	⊢ ⇑(b.reindex_range) ⟨⇑b i, h⟩ = ⇑b i
ι : Type u_1,	R : Type u_3,	M : Type u_5,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : module R M,	b : basis ι R M,	i : ι,	h : opt_param (⇑b i ∈ set.range (λ (i : ι), ⇑b i)) _,	htr : nontrivial R,	_inst : nontrivial R := htr	⊢ ⇑(b.reindex_range) ⟨⇑b i, h⟩ = ⇑b i
ι : Type u_1,	R : Type u_3,	M : Type u_5,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : module R M,	b : basis ι R M,	i : ι,	h : opt_param (⇑b i ∈ set.range (λ (i : ι), ⇑b i)) _,	htr : nontrivial R	⊢ ⇑(b.reindex_range) ⟨⇑b i, h⟩ = ⇑b i		ι : Type u_1,	R : Type u_3,	M : Type u_5,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : module R M,	b : basis ι R M,	i : ι,	h : opt_param (⇑b i ∈ set.range (λ (i : ι), ⇑b i)) _,	htr : ¬nontrivial R	⊢ ⇑(b.reindex_range) ⟨⇑b i, h⟩ = ⇑b i
ι : Type u_1,	R : Type u_3,	M : Type u_5,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : module R M,	b : basis ι R M,	i : ι,	h : opt_param (⇑b i ∈ set.range (λ (i : ι), ⇑b i)) _,	htr : ¬nontrivial R	⊢ ⇑(b.reindex_range) ⟨⇑b i, h⟩ = ⇑b i
ι : Type u_1,	R : Type u_3,	M : Type u_5,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : module R M,	b : basis ι R M,	i : ι,	h : opt_param (⇑b i ∈ set.range (λ (i : ι), ⇑b i)) _,	htr : ¬nontrivial R,	_inst : subsingleton R := not_nontrivial_iff_subsingleton.mp htr	⊢ ⇑(b.reindex_range) ⟨⇑b i, h⟩ = ⇑b i
ι : Type u_1,	R : Type u_3,	M : Type u_5,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : module R M,	b : basis ι R M,	i : ι,	h : opt_param (⇑b i ∈ set.range (λ (i : ι), ⇑b i)) _,	htr : ¬nontrivial R,	_inst : subsingleton R := not_nontrivial_iff_subsingleton.mp htr,	_inst_4 : subsingleton M := module.subsingleton R M	⊢ ⇑(b.reindex_range) ⟨⇑b i, h⟩ = ⇑b i
ι : Type u_1,	ι' : Type u_2,	R : Type u_3,	M : Type u_5,	M' : Type u_6,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : module R M,	_inst_4 : add_comm_monoid M',	_inst_5 : module R M',	b : basis ι R M,	b' : basis ι' R M',	i : ι'	⊢ ⇑(b.repr) (⇑(b.prod b') (sum.inr i)).fst = ⇑(b.repr) 0
ι : Type u_1,	ι' : Type u_2,	R : Type u_3,	M : Type u_5,	M' : Type u_6,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : module R M,	_inst_4 : add_comm_monoid M',	_inst_5 : module R M',	b : basis ι R M,	b' : basis ι' R M',	i : ι',	i : ι	⊢ ⇑(⇑(b.repr) (⇑(b.prod b') (sum.inr i)).fst) i = ⇑(⇑(b.repr) 0) i
ι : Type u_1,	ι' : Type u_2,	R : Type u_3,	M : Type u_5,	M' : Type u_6,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : module R M,	_inst_4 : add_comm_monoid M',	_inst_5 : module R M',	b : basis ι R M,	b' : basis ι' R M',	i : ι',	i : ι	⊢ ⇑(finsupp.single (sum.inr i) 1) (sum.inl i) = 0
R : Type u_1,	M : Type u_2,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : module R M,	M' : Type w,	_inst_16 : add_comm_monoid M',	_inst_17 : module R M',	B : bilin_form R M',	l r : M →ₗ[R] M',	x y z : M	⊢ ⇑B (⇑l (x + y)) (⇑r z) = ⇑B (⇑l x) (⇑r z) + ⇑B (⇑l y) (⇑r z)
R : Type u_1,	M : Type u_2,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : module R M,	M' : Type w,	_inst_16 : add_comm_monoid M',	_inst_17 : module R M',	B : bilin_form R M',	l r : M →ₗ[R] M',	x : R,	y z : M	⊢ ⇑B (⇑l (x • y)) (⇑r z) = x * ⇑B (⇑l y) (⇑r z)
R : Type u_1,	M : Type u_2,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : module R M,	M' : Type w,	_inst_16 : add_comm_monoid M',	_inst_17 : module R M',	B : bilin_form R M',	l r : M →ₗ[R] M',	x y z : M	⊢ ⇑B (⇑l x) (⇑r (y + z)) = ⇑B (⇑l x) (⇑r y) + ⇑B (⇑l x) (⇑r z)
R : Type u_1,	M : Type u_2,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : module R M,	M' : Type w,	_inst_16 : add_comm_monoid M',	_inst_17 : module R M',	B : bilin_form R M',	l r : M →ₗ[R] M',	x : R,	y z : M	⊢ ⇑B (⇑l y) (⇑r (x • z)) = x * ⇑B (⇑l y) (⇑r z)
V : Type u_9,	K : Type u_10,	_inst_13 : field K,	_inst_14 : add_comm_group V,	_inst_15 : module K V,	n : Type w,	B : bilin_form K V,	v : n → V,	hv₁ : B.is_Ortho v,	hv₂ : ∀ (i : n), ¬B.is_ortho (v i) (v i)	⊢ linear_independent K v
V : Type u_9,	K : Type u_10,	_inst_13 : field K,	_inst_14 : add_comm_group V,	_inst_15 : module K V,	n : Type w,	B : bilin_form K V,	v : n → V,	hv₁ : B.is_Ortho v,	hv₂ : ∀ (i : n), ¬B.is_ortho (v i) (v i),	_inst : Π (a : Prop), decidable a	⊢ linear_independent K v
V : Type u_9,	K : Type u_10,	_inst_13 : field K,	_inst_14 : add_comm_group V,	_inst_15 : module K V,	n : Type w,	B : bilin_form K V,	v : n → V,	hv₁ : B.is_Ortho v,	hv₂ : ∀ (i : n), ¬B.is_ortho (v i) (v i),	_inst : Π (a : Prop), decidable a	⊢ ∀ (s : finset n) (g : n → K), ∑ (i : n) in s, g i • v i = 0 → ∀ (i : n), i ∈ s → g i = 0
V : Type u_9,	K : Type u_10,	_inst_13 : field K,	_inst_14 : add_comm_group V,	_inst_15 : module K V,	n : Type w,	B : bilin_form K V,	v : n → V,	hv₁ : B.is_Ortho v,	hv₂ : ∀ (i : n), ¬B.is_ortho (v i) (v i),	_inst : Π (a : Prop), decidable a,	s : finset n,	w : n → K,	hs : ∑ (i : n) in s, w i • v i = 0,	i : n,	hi : i ∈ s	⊢ w i = 0
V : Type u_9,	K : Type u_10,	_inst_13 : field K,	_inst_14 : add_comm_group V,	_inst_15 : module K V,	n : Type w,	B : bilin_form K V,	v : n → V,	hv₁ : B.is_Ortho v,	hv₂ : ∀ (i : n), ¬B.is_ortho (v i) (v i),	_inst : Π (a : Prop), decidable a,	s : finset n,	w : n → K,	hs : ∑ (i : n) in s, w i • v i = 0,	i : n,	hi : i ∈ s	⊢ ⇑B (∑ (i : n) in s, w i • v i) (v i) = 0		V : Type u_9,	K : Type u_10,	_inst_13 : field K,	_inst_14 : add_comm_group V,	_inst_15 : module K V,	n : Type w,	B : bilin_form K V,	v : n → V,	hv₁ : B.is_Ortho v,	hv₂ : ∀ (i : n), ¬B.is_ortho (v i) (v i),	_inst : Π (a : Prop), decidable a,	s : finset n,	w : n → K,	hs : ∑ (i : n) in s, w i • v i = 0,	i : n,	hi : i ∈ s,	this : ⇑B (∑ (i : n) in s, w i • v i) (v i) = 0	⊢ w i = 0
V : Type u_9,	K : Type u_10,	_inst_13 : field K,	_inst_14 : add_comm_group V,	_inst_15 : module K V,	n : Type w,	B : bilin_form K V,	v : n → V,	hv₁ : B.is_Ortho v,	hv₂ : ∀ (i : n), ¬B.is_ortho (v i) (v i),	_inst : Π (a : Prop), decidable a,	s : finset n,	w : n → K,	hs : ∑ (i : n) in s, w i • v i = 0,	i : n,	hi : i ∈ s	⊢ ⇑B (∑ (i : n) in s, w i • v i) (v i) = 0
V : Type u_9,	K : Type u_10,	_inst_13 : field K,	_inst_14 : add_comm_group V,	_inst_15 : module K V,	n : Type w,	B : bilin_form K V,	v : n → V,	hv₁ : B.is_Ortho v,	hv₂ : ∀ (i : n), ¬B.is_ortho (v i) (v i),	_inst : Π (a : Prop), decidable a,	s : finset n,	w : n → K,	hs : ∑ (i : n) in s, w i • v i = 0,	i : n,	hi : i ∈ s,	this : ⇑B (∑ (i : n) in s, w i • v i) (v i) = 0	⊢ w i = 0
V : Type u_9,	K : Type u_10,	_inst_13 : field K,	_inst_14 : add_comm_group V,	_inst_15 : module K V,	n : Type w,	B : bilin_form K V,	v : n → V,	hv₁ : B.is_Ortho v,	hv₂ : ∀ (i : n), ¬B.is_ortho (v i) (v i),	_inst : Π (a : Prop), decidable a,	s : finset n,	w : n → K,	hs : ∑ (i : n) in s, w i • v i = 0,	i : n,	hi : i ∈ s,	this : ⇑B (∑ (i : n) in s, w i • v i) (v i) = 0	⊢ ∑ (j : n) in s, w j * ⇑B (v j) (v i) = ∑ (j : n) in s, ite (i = j) (w j * ⇑B (v j) (v i)) 0
V : Type u_9,	K : Type u_10,	_inst_13 : field K,	_inst_14 : add_comm_group V,	_inst_15 : module K V,	n : Type w,	B : bilin_form K V,	v : n → V,	hv₁ : B.is_Ortho v,	hv₂ : ∀ (i : n), ¬B.is_ortho (v i) (v i),	_inst : Π (a : Prop), decidable a,	s : finset n,	w : n → K,	hs : ∑ (i : n) in s, w i • v i = 0,	i : n,	hi : i ∈ s,	this : ⇑B (∑ (i : n) in s, w i • v i) (v i) = 0,	j : n,	hj : j ∈ s	⊢ w j * ⇑B (v j) (v i) = ite (i = j) (w j * ⇑B (v j) (v i)) 0
V : Type u_9,	K : Type u_10,	_inst_13 : field K,	_inst_14 : add_comm_group V,	_inst_15 : module K V,	n : Type w,	B : bilin_form K V,	v : n → V,	hv₁ : B.is_Ortho v,	hv₂ : ∀ (i : n), ¬B.is_ortho (v i) (v i),	_inst : Π (a : Prop), decidable a,	s : finset n,	w : n → K,	hs : ∑ (i : n) in s, w i • v i = 0,	i : n,	hi : i ∈ s,	this : ⇑B (∑ (i : n) in s, w i • v i) (v i) = 0,	j : n,	hj : j ∈ s,	h : i = j	⊢ w j * ⇑B (v j) (v i) = ite (i = j) (w j * ⇑B (v j) (v i)) 0		V : Type u_9,	K : Type u_10,	_inst_13 : field K,	_inst_14 : add_comm_group V,	_inst_15 : module K V,	n : Type w,	B : bilin_form K V,	v : n → V,	hv₁ : B.is_Ortho v,	hv₂ : ∀ (i : n), ¬B.is_ortho (v i) (v i),	_inst : Π (a : Prop), decidable a,	s : finset n,	w : n → K,	hs : ∑ (i : n) in s, w i • v i = 0,	i : n,	hi : i ∈ s,	this : ⇑B (∑ (i : n) in s, w i • v i) (v i) = 0,	j : n,	hj : j ∈ s,	h : ¬i = j	⊢ w j * ⇑B (v j) (v i) = ite (i = j) (w j * ⇑B (v j) (v i)) 0
V : Type u_9,	K : Type u_10,	_inst_13 : field K,	_inst_14 : add_comm_group V,	_inst_15 : module K V,	n : Type w,	B : bilin_form K V,	v : n → V,	hv₁ : B.is_Ortho v,	hv₂ : ∀ (i : n), ¬B.is_ortho (v i) (v i),	_inst : Π (a : Prop), decidable a,	s : finset n,	w : n → K,	hs : ∑ (i : n) in s, w i • v i = 0,	i : n,	hi : i ∈ s,	this : ⇑B (∑ (i : n) in s, w i • v i) (v i) = 0,	j : n,	hj : j ∈ s,	h : i = j	⊢ w j * ⇑B (v j) (v i) = ite (i = j) (w j * ⇑B (v j) (v i)) 0
V : Type u_9,	K : Type u_10,	_inst_13 : field K,	_inst_14 : add_comm_group V,	_inst_15 : module K V,	n : Type w,	B : bilin_form K V,	v : n → V,	hv₁ : B.is_Ortho v,	hv₂ : ∀ (i : n), ¬B.is_ortho (v i) (v i),	_inst : Π (a : Prop), decidable a,	s : finset n,	w : n → K,	hs : ∑ (i : n) in s, w i • v i = 0,	i : n,	hi : i ∈ s,	this : ⇑B (∑ (i : n) in s, w i • v i) (v i) = 0	⊢ ∑ (j : n) in s, w j * ⇑B (v j) (v i) = ∑ (j : n) in s, ite (i = j) (w j * ⇑B (v j) (v i)) 0		V : Type u_9,	K : Type u_10,	_inst_13 : field K,	_inst_14 : add_comm_group V,	_inst_15 : module K V,	n : Type w,	B : bilin_form K V,	v : n → V,	hv₁ : B.is_Ortho v,	hv₂ : ∀ (i : n), ¬B.is_ortho (v i) (v i),	_inst : Π (a : Prop), decidable a,	s : finset n,	w : n → K,	hs : ∑ (i : n) in s, w i • v i = 0,	i : n,	hi : i ∈ s,	this : ⇑B (∑ (i : n) in s, w i • v i) (v i) = 0,	hsum : ∑ (j : n) in s, w j * ⇑B (v j) (v i) = ∑ (j : n) in s, ite (i = j) (w j * ⇑B (v j) (v i)) 0	⊢ w i = 0
V : Type u_9,	K : Type u_10,	_inst_13 : field K,	_inst_14 : add_comm_group V,	_inst_15 : module K V,	n : Type w,	B : bilin_form K V,	v : n → V,	hv₁ : B.is_Ortho v,	hv₂ : ∀ (i : n), ¬B.is_ortho (v i) (v i),	_inst : Π (a : Prop), decidable a,	s : finset n,	w : n → K,	hs : ∑ (i : n) in s, w i • v i = 0,	i : n,	hi : i ∈ s,	this : ⇑B (∑ (i : n) in s, w i • v i) (v i) = 0,	j : n,	hj : j ∈ s,	h : ¬i = j	⊢ w j * ⇑B (v j) (v i) = ite (i = j) (w j * ⇑B (v j) (v i)) 0
V : Type u_9,	K : Type u_10,	_inst_13 : field K,	_inst_14 : add_comm_group V,	_inst_15 : module K V,	n : Type w,	B : bilin_form K V,	v : n → V,	hv₁ : B.is_Ortho v,	hv₂ : ∀ (i : n), ¬B.is_ortho (v i) (v i),	_inst : Π (a : Prop), decidable a,	s : finset n,	w : n → K,	hs : ∑ (i : n) in s, w i • v i = 0,	i : n,	hi : i ∈ s,	this : ⇑B (∑ (i : n) in s, w i • v i) (v i) = 0,	hsum : ∑ (j : n) in s, w j * ⇑B (v j) (v i) = ∑ (j : n) in s, ite (i = j) (w j * ⇑B (v j) (v i)) 0	⊢ w i = 0
V : Type u_9,	K : Type u_10,	_inst_13 : field K,	_inst_14 : add_comm_group V,	_inst_15 : module K V,	n : Type w,	B : bilin_form K V,	v : n → V,	hv₁ : B.is_Ortho v,	hv₂ : ∀ (i : n), ¬B.is_ortho (v i) (v i),	_inst : Π (a : Prop), decidable a,	s : finset n,	w : n → K,	hs : ∑ (i : n) in s, w i • v i = 0,	i : n,	hi : i ∈ s,	hsum : ∑ (j : n) in s, w j * ⇑B (v j) (v i) = ∑ (j : n) in s, ite (i = j) (w j * ⇑B (v j) (v i)) 0,	this : ite (i ∈ s) (w i * ⇑B (v i) (v i)) 0 = 0	⊢ w i = 0
V : Type u_9,	K : Type u_10,	_inst_13 : field K,	_inst_14 : add_comm_group V,	_inst_15 : module K V,	n : Type w,	B : bilin_form K V,	v : n → V,	hv₁ : B.is_Ortho v,	hv₂ : ∀ (i : n), ¬B.is_ortho (v i) (v i),	_inst : Π (a : Prop), decidable a,	s : finset n,	w : n → K,	hs : ∑ (i : n) in s, w i • v i = 0,	i : n,	hi : i ∈ s,	hsum : ∑ (j : n) in s, w j * ⇑B (v j) (v i) = ∑ (j : n) in s, ite (i = j) (w j * ⇑B (v j) (v i)) 0,	this : w i = 0 ∨ ⇑B (v i) (v i) = 0	⊢ w i = 0		V : Type u_9,	K : Type u_10,	_inst_13 : field K,	_inst_14 : add_comm_group V,	_inst_15 : module K V,	n : Type w,	B : bilin_form K V,	v : n → V,	hv₁ : B.is_Ortho v,	hv₂ : ∀ (i : n), ¬B.is_ortho (v i) (v i),	_inst : Π (a : Prop), decidable a,	s : finset n,	w : n → K,	hs : ∑ (i : n) in s, w i • v i = 0,	i : n,	hi : i ∈ s,	hsum : ∑ (j : n) in s, w j * ⇑B (v j) (v i) = ∑ (j : n) in s, ite (i = j) (w j * ⇑B (v j) (v i)) 0,	this : ite (i ∈ s) (w i * ⇑B (v i) (v i)) 0 = 0	⊢ i ∈ s
V : Type u_9,	K : Type u_10,	_inst_13 : field K,	_inst_14 : add_comm_group V,	_inst_15 : module K V,	n : Type w,	B : bilin_form K V,	v : n → V,	hv₁ : B.is_Ortho v,	hv₂ : ∀ (i : n), ¬B.is_ortho (v i) (v i),	_inst : Π (a : Prop), decidable a,	s : finset n,	w : n → K,	hs : ∑ (i : n) in s, w i • v i = 0,	i : n,	hi : i ∈ s,	hsum : ∑ (j : n) in s, w j * ⇑B (v j) (v i) = ∑ (j : n) in s, ite (i = j) (w j * ⇑B (v j) (v i)) 0,	this : w i = 0	⊢ w i = 0		case or.inr	V : Type u_9,	K : Type u_10,	_inst_13 : field K,	_inst_14 : add_comm_group V,	_inst_15 : module K V,	n : Type w,	B : bilin_form K V,	v : n → V,	hv₁ : B.is_Ortho v,	hv₂ : ∀ (i : n), ¬B.is_ortho (v i) (v i),	_inst : Π (a : Prop), decidable a,	s : finset n,	w : n → K,	hs : ∑ (i : n) in s, w i • v i = 0,	i : n,	hi : i ∈ s,	hsum : ∑ (j : n) in s, w j * ⇑B (v j) (v i) = ∑ (j : n) in s, ite (i = j) (w j * ⇑B (v j) (v i)) 0,	this : ⇑B (v i) (v i) = 0	⊢ w i = 0		V : Type u_9,	K : Type u_10,	_inst_13 : field K,	_inst_14 : add_comm_group V,	_inst_15 : module K V,	n : Type w,	B : bilin_form K V,	v : n → V,	hv₁ : B.is_Ortho v,	hv₂ : ∀ (i : n), ¬B.is_ortho (v i) (v i),	_inst : Π (a : Prop), decidable a,	s : finset n,	w : n → K,	hs : ∑ (i : n) in s, w i • v i = 0,	i : n,	hi : i ∈ s,	hsum : ∑ (j : n) in s, w j * ⇑B (v j) (v i) = ∑ (j : n) in s, ite (i = j) (w j * ⇑B (v j) (v i)) 0,	this : ite (i ∈ s) (w i * ⇑B (v i) (v i)) 0 = 0	⊢ i ∈ s
V : Type u_9,	K : Type u_10,	_inst_13 : field K,	_inst_14 : add_comm_group V,	_inst_15 : module K V,	n : Type w,	B : bilin_form K V,	v : n → V,	hv₁ : B.is_Ortho v,	hv₂ : ∀ (i : n), ¬B.is_ortho (v i) (v i),	_inst : Π (a : Prop), decidable a,	s : finset n,	w : n → K,	hs : ∑ (i : n) in s, w i • v i = 0,	i : n,	hi : i ∈ s,	hsum : ∑ (j : n) in s, w j * ⇑B (v j) (v i) = ∑ (j : n) in s, ite (i = j) (w j * ⇑B (v j) (v i)) 0,	this : w i = 0	⊢ w i = 0
V : Type u_9,	K : Type u_10,	_inst_13 : field K,	_inst_14 : add_comm_group V,	_inst_15 : module K V,	n : Type w,	B : bilin_form K V,	v : n → V,	hv₁ : B.is_Ortho v,	hv₂ : ∀ (i : n), ¬B.is_ortho (v i) (v i),	_inst : Π (a : Prop), decidable a,	s : finset n,	w : n → K,	hs : ∑ (i : n) in s, w i • v i = 0,	i : n,	hi : i ∈ s,	hsum : ∑ (j : n) in s, w j * ⇑B (v j) (v i) = ∑ (j : n) in s, ite (i = j) (w j * ⇑B (v j) (v i)) 0,	this : ⇑B (v i) (v i) = 0	⊢ w i = 0		V : Type u_9,	K : Type u_10,	_inst_13 : field K,	_inst_14 : add_comm_group V,	_inst_15 : module K V,	n : Type w,	B : bilin_form K V,	v : n → V,	hv₁ : B.is_Ortho v,	hv₂ : ∀ (i : n), ¬B.is_ortho (v i) (v i),	_inst : Π (a : Prop), decidable a,	s : finset n,	w : n → K,	hs : ∑ (i : n) in s, w i • v i = 0,	i : n,	hi : i ∈ s,	hsum : ∑ (j : n) in s, w j * ⇑B (v j) (v i) = ∑ (j : n) in s, ite (i = j) (w j * ⇑B (v j) (v i)) 0,	this : ite (i ∈ s) (w i * ⇑B (v i) (v i)) 0 = 0	⊢ i ∈ s
V : Type u_9,	K : Type u_10,	_inst_13 : field K,	_inst_14 : add_comm_group V,	_inst_15 : module K V,	n : Type w,	B : bilin_form K V,	v : n → V,	hv₁ : B.is_Ortho v,	hv₂ : ∀ (i : n), ¬B.is_ortho (v i) (v i),	_inst : Π (a : Prop), decidable a,	s : finset n,	w : n → K,	hs : ∑ (i : n) in s, w i • v i = 0,	i : n,	hi : i ∈ s,	hsum : ∑ (j : n) in s, w j * ⇑B (v j) (v i) = ∑ (j : n) in s, ite (i = j) (w j * ⇑B (v j) (v i)) 0,	this : ⇑B (v i) (v i) = 0	⊢ w i = 0
V : Type u_9,	K : Type u_10,	_inst_13 : field K,	_inst_14 : add_comm_group V,	_inst_15 : module K V,	n : Type w,	B : bilin_form K V,	v : n → V,	hv₁ : B.is_Ortho v,	hv₂ : ∀ (i : n), ¬B.is_ortho (v i) (v i),	_inst : Π (a : Prop), decidable a,	s : finset n,	w : n → K,	hs : ∑ (i : n) in s, w i • v i = 0,	i : n,	hi : i ∈ s,	hsum : ∑ (j : n) in s, w j * ⇑B (v j) (v i) = ∑ (j : n) in s, ite (i = j) (w j * ⇑B (v j) (v i)) 0,	this : ite (i ∈ s) (w i * ⇑B (v i) (v i)) 0 = 0	⊢ i ∈ s
R : Type u_1,	_inst_1 : comm_ring R,	M : Type u_2,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	Q : quadratic_form R M,	A : Type u_3,	_inst_4 : semiring A,	_inst_5 : algebra R A,	f : {f // ∀ (m : M), ⇑f m * ⇑f m = ⇑(algebra_map R A) (⇑Q m)},	x y : tensor_algebra R M,	h : clifford_algebra.rel Q x y	⊢ ⇑(⇑(tensor_algebra.lift R) ↑f) x = ⇑(⇑(tensor_algebra.lift R) ↑f) y
R : Type u_1,	_inst_1 : comm_ring R,	M : Type u_2,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	Q : quadratic_form R M,	A : Type u_3,	_inst_4 : semiring A,	_inst_5 : algebra R A,	f : {f // ∀ (m : M), ⇑f m * ⇑f m = ⇑(algebra_map R A) (⇑Q m)},	x y : tensor_algebra R M,	h : M	⊢ ⇑(⇑(tensor_algebra.lift R) ↑f) (⇑(tensor_algebra.ι R) h * ⇑(tensor_algebra.ι R) h) = ⇑(⇑(tensor_algebra.lift R) ↑f) (⇑(algebra_map R (tensor_algebra R M)) (⇑Q h))
R : Type u_1,	_inst_1 : comm_ring R,	M : Type u_2,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	Q : quadratic_form R M,	A : Type u_3,	_inst_4 : semiring A,	_inst_5 : algebra R A,	F : clifford_algebra Q →ₐ[R] A,	m : M	⊢ ⇑(F.to_linear_map.comp (clifford_algebra.ι Q)) m * ⇑(F.to_linear_map.comp (clifford_algebra.ι Q)) m = ⇑(algebra_map R A) (⇑Q m)
R : Type u_1,	_inst_1 : comm_ring R,	M : Type u_2,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	Q : quadratic_form R M,	A : Type u_3,	_inst_4 : semiring A,	_inst_5 : algebra R A,	f : {f // ∀ (m : M), ⇑f m * ⇑f m = ⇑(algebra_map R A) (⇑Q m)}	⊢ (λ (F : clifford_algebra Q →ₐ[R] A), ⟨F.to_linear_map.comp (clifford_algebra.ι Q), _⟩) ((λ (f : {f // ∀ (m : M), ⇑f m * ⇑f m = ⇑(algebra_map R A) (⇑Q m)}), ⇑(ring_quot.lift_alg_hom R) ⟨⇑(tensor_algebra.lift R) ↑f, _⟩) f) = f
R : Type u_1,	_inst_1 : comm_ring R,	M : Type u_2,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	Q : quadratic_form R M,	A : Type u_3,	_inst_4 : semiring A,	_inst_5 : algebra R A,	f : {f // ∀ (m : M), ⇑f m * ⇑f m = ⇑(algebra_map R A) (⇑Q m)},	x : M	⊢ ⇑↑((λ (F : clifford_algebra Q →ₐ[R] A), ⟨F.to_linear_map.comp (clifford_algebra.ι Q), _⟩) ((λ (f : {f // ∀ (m : M), ⇑f m * ⇑f m = ⇑(algebra_map R A) (⇑Q m)}), ⇑(ring_quot.lift_alg_hom R) ⟨⇑(tensor_algebra.lift R) ↑f, _⟩) f)) x = ⇑↑f x
R : Type u_1,	_inst_1 : comm_ring R,	M : Type u_2,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	Q : quadratic_form R M,	A : Type u_3,	_inst_4 : semiring A,	_inst_5 : algebra R A,	F : clifford_algebra Q →ₐ[R] A	⊢ (λ (f : {f // ∀ (m : M), ⇑f m * ⇑f m = ⇑(algebra_map R A) (⇑Q m)}), ⇑(ring_quot.lift_alg_hom R) ⟨⇑(tensor_algebra.lift R) ↑f, _⟩) ((λ (F : clifford_algebra Q →ₐ[R] A), ⟨F.to_linear_map.comp (clifford_algebra.ι Q), _⟩) F) = F
R : Type u_1,	_inst_1 : comm_ring R,	M : Type u_2,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	Q : quadratic_form R M,	A : Type u_3,	_inst_4 : semiring A,	_inst_5 : algebra R A,	F : clifford_algebra Q →ₐ[R] A,	x : M	⊢ ⇑((((λ (f : {f // ∀ (m : M), ⇑f m * ⇑f m = ⇑(algebra_map R A) (⇑Q m)}), ⇑(ring_quot.lift_alg_hom R) ⟨⇑(tensor_algebra.lift R) ↑f, _⟩) ((λ (F : clifford_algebra Q →ₐ[R] A), ⟨F.to_linear_map.comp (clifford_algebra.ι Q), _⟩) F)).comp (ring_quot.mk_alg_hom R (λ (x y : tensor_algebra R M), clifford_algebra.rel Q x y))).to_linear_map.comp (tensor_algebra.ι R)) x = ⇑((F.comp (ring_quot.mk_alg_hom R (λ (x y : tensor_algebra R M), clifford_algebra.rel Q x y))).to_linear_map.comp (tensor_algebra.ι R)) x
R : Type u_1,	_inst_1 : comm_ring R,	M₁ : Type u_4,	M₂ : Type u_5,	M₃ : Type u_6,	_inst_6 : add_comm_group M₁,	_inst_7 : add_comm_group M₂,	_inst_8 : add_comm_group M₃,	_inst_9 : module R M₁,	_inst_10 : module R M₂,	_inst_11 : module R M₃,	Q₁ : quadratic_form R M₁,	Q₂ : quadratic_form R M₂,	Q₃ : quadratic_form R M₃,	e₁₂ : Q₁.isometry Q₂,	e₂₃ : Q₂.isometry Q₃,	x : clifford_algebra Q₁	⊢ ⇑((clifford_algebra.equiv_of_isometry e₁₂).trans (clifford_algebra.equiv_of_isometry e₂₃)) x = ⇑(clifford_algebra.equiv_of_isometry (e₁₂.trans e₂₃)) x
R : Type u_1,	_inst_1 : comm_ring R,	M₁ : Type u_4,	M₂ : Type u_5,	M₃ : Type u_6,	_inst_6 : add_comm_group M₁,	_inst_7 : add_comm_group M₂,	_inst_8 : add_comm_group M₃,	_inst_9 : module R M₁,	_inst_10 : module R M₂,	_inst_11 : module R M₃,	Q₁ : quadratic_form R M₁,	Q₂ : quadratic_form R M₂,	Q₃ : quadratic_form R M₃,	e₁₂ : Q₁.isometry Q₂,	e₂₃ : Q₂.isometry Q₃	⊢ (clifford_algebra.equiv_of_isometry e₁₂).trans (clifford_algebra.equiv_of_isometry e₂₃) = clifford_algebra.equiv_of_isometry (e₁₂.trans e₂₃)
R : Type u_1,	_inst_1 : comm_ring R,	M : Type u_2,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	Q : quadratic_form R M,	m : M	⊢ opposite.unop (⇑((opposite.op_linear_equiv R).to_linear_map.comp (clifford_algebra.ι Q)) m * ⇑((opposite.op_linear_equiv R).to_linear_map.comp (clifford_algebra.ι Q)) m) = opposite.unop (⇑(algebra_map R (clifford_algebra Q)ᵒᵖ) (⇑Q m))
R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R	⊢ clifford_algebra_quaternion.to_quaternion.comp clifford_algebra_quaternion.of_quaternion = alg_hom.id R ℍ[R,c₁,c₂]
R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R	⊢ ⇑(quaternion_algebra.lift.symm) (clifford_algebra_quaternion.to_quaternion.comp clifford_algebra_quaternion.of_quaternion) = ⇑(quaternion_algebra.lift.symm) (alg_hom.id R ℍ[R,c₁,c₂])
R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R	⊢ ⇑clifford_algebra_quaternion.to_quaternion (⇑(algebra_map R (clifford_algebra (clifford_algebra_quaternion.Q c₁ c₂))) 0 + 1 • ⇑(clifford_algebra.ι (clifford_algebra_quaternion.Q c₁ c₂)) (1, 0) + 0 • ⇑(clifford_algebra.ι (clifford_algebra_quaternion.Q c₁ c₂)) (0, 1) + 0 • (⇑(clifford_algebra.ι (clifford_algebra_quaternion.Q c₁ c₂)) (1, 0) * ⇑(clifford_algebra.ι (clifford_algebra_quaternion.Q c₁ c₂)) (0, 1))) = {re := 0, im_i := 1, im_j := 0, im_k := 0}
R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R	⊢ ⇑clifford_algebra_quaternion.to_quaternion (⇑(algebra_map R (clifford_algebra (clifford_algebra_quaternion.Q c₁ c₂))) 0 + 0 • ⇑(clifford_algebra.ι (clifford_algebra_quaternion.Q c₁ c₂)) (1, 0) + 1 • ⇑(clifford_algebra.ι (clifford_algebra_quaternion.Q c₁ c₂)) (0, 1) + 0 • (⇑(clifford_algebra.ι (clifford_algebra_quaternion.Q c₁ c₂)) (1, 0) * ⇑(clifford_algebra.ι (clifford_algebra_quaternion.Q c₁ c₂)) (0, 1))) = {re := 0, im_i := 0, im_j := 1, im_k := 0}
R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R	⊢ ⇑(quaternion_algebra.lift.symm) (clifford_algebra_quaternion.to_quaternion.comp clifford_algebra_quaternion.of_quaternion) = ⇑(quaternion_algebra.lift.symm) (alg_hom.id R ℍ[R,c₁,c₂])
R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R	⊢ ⇑(quaternion_algebra.lift.symm) (clifford_algebra_quaternion.to_quaternion.comp clifford_algebra_quaternion.of_quaternion) = ⇑(quaternion_algebra.lift.symm) (alg_hom.id R ℍ[R,c₁,c₂])
R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R	⊢ (⇑(quaternion_algebra.lift.symm) (clifford_algebra_quaternion.to_quaternion.comp clifford_algebra_quaternion.of_quaternion)).i = (⇑(quaternion_algebra.lift.symm) (alg_hom.id R ℍ[R,c₁,c₂])).i
R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R	⊢ (⇑(quaternion_algebra.lift.symm) (clifford_algebra_quaternion.to_quaternion.comp clifford_algebra_quaternion.of_quaternion)).j = (⇑(quaternion_algebra.lift.symm) (alg_hom.id R ℍ[R,c₁,c₂])).j
R : Type u_1,	_inst_1 : comm_ring R,	x : unit	⊢ ⇑(clifford_algebra.involute.to_linear_map.comp (clifford_algebra.ι 0)) x = ⇑((alg_hom.id R (clifford_algebra 0)).to_linear_map.comp (clifford_algebra.ι 0)) x
R : Type u_1,	_inst_1 : comm_ring R	⊢ clifford_algebra.involute = alg_hom.id R (clifford_algebra 0)
M : Type u_2,	_inst_2 : add_comm_group M,	A : Type u_5,	_inst_8 : integral_domain A,	_inst_9 : module A M,	_inst_11 : decidable_eq M,	s : finset M,	b : basis ↥s A M,	f : M →ₗ[A] M,	this : ∃ (s : finset M), nonempty (basis ↥s A M)	⊢ ⇑linear_map.det f = (⇑(linear_map.to_matrix b b) f).det
M : Type u_2,	_inst_2 : add_comm_group M,	A : Type u_5,	_inst_8 : integral_domain A,	_inst_9 : module A M,	_inst_11 : decidable_eq M,	s : finset M,	b : basis ↥s A M,	f : M →ₗ[A] M,	this : ∃ (s : finset M), nonempty (basis ↥s A M)	⊢ ⇑linear_map.det f = (⇑(linear_map.to_matrix b b) f).det
M : Type u_2,	_inst_2 : add_comm_group M,	A : Type u_5,	_inst_8 : integral_domain A,	_inst_9 : module A M,	_inst_11 : decidable_eq M,	s : finset M,	b : basis ↥s A M,	f : M →ₗ[A] M,	this : ∃ (s : finset M), nonempty (basis ↥s A M)	⊢ ∃ (s : finset M), nonempty (basis ↥s A M)
𝕜 : Type u_1,	_inst_11 : field 𝕜,	M : Type u_2,	_inst_12 : add_comm_group M,	_inst_13 : module 𝕜 M	⊢ ⇑linear_map.det 0 = 0 ^ finite_dimensional.finrank 𝕜 M
ι : Type u_1,	R : Type u_2,	S : Type u_3,	M : ι → Type u_4,	N : Type u_5,	dec_ι : decidable_eq ι,	_inst_1 : semiring R,	_inst_2 : Π (i : ι), add_comm_monoid (M i),	_inst_3 : Π (i : ι), module R (M i),	_inst_4 : add_comm_monoid N,	_inst_5 : module R N,	_inst_6 : semiring S,	_inst_7 : module S N,	_inst_8 : smul_comm_class R S N,	F : Π (i : ι), M i →ₗ[R] N,	c : R,	f : Π₀ (i : ι), M i	⊢ ⇑(dfinsupp.sum_add_hom (λ (i : ι), (F i).to_add_monoid_hom)) (c • f) = ⇑(ring_hom.id R) c • ⇑(dfinsupp.sum_add_hom (λ (i : ι), (F i).to_add_monoid_hom)) f
ι : Type u_1,	R : Type u_2,	S : Type u_3,	M : ι → Type u_4,	N : Type u_5,	dec_ι : decidable_eq ι,	_inst_1 : semiring R,	_inst_2 : Π (i : ι), add_comm_monoid (M i),	_inst_3 : Π (i : ι), module R (M i),	_inst_4 : add_comm_monoid N,	_inst_5 : module R N,	_inst_6 : semiring S,	_inst_7 : module S N,	_inst_8 : smul_comm_class R S N,	F : Π (i : ι), M i →ₗ[R] N,	c : R,	f : Π₀ (i : ι), M i	⊢ ⇑(dfinsupp.sum_add_hom (λ (i : ι), (F i).to_add_monoid_hom)) (c • f) = c • ⇑(dfinsupp.sum_add_hom (λ (i : ι), (F i).to_add_monoid_hom)) f
ι : Type u_1,	R : Type u_2,	S : Type u_3,	M : ι → Type u_4,	N : Type u_5,	dec_ι : decidable_eq ι,	_inst_1 : semiring R,	_inst_2 : Π (i : ι), add_comm_monoid (M i),	_inst_3 : Π (i : ι), module R (M i),	_inst_4 : add_comm_monoid N,	_inst_5 : module R N,	_inst_6 : semiring S,	_inst_7 : module S N,	_inst_8 : smul_comm_class R S N,	F : Π (i : ι), M i →ₗ[R] N,	c : R,	f : Π₀ (i : ι), M i	⊢ ⇑(dfinsupp.sum_add_hom (λ (i : ι), (F i).to_add_monoid_hom)) (c • 0) = c • ⇑(dfinsupp.sum_add_hom (λ (i : ι), (F i).to_add_monoid_hom)) 0		ι : Type u_1,	R : Type u_2,	S : Type u_3,	M : ι → Type u_4,	N : Type u_5,	dec_ι : decidable_eq ι,	_inst_1 : semiring R,	_inst_2 : Π (i : ι), add_comm_monoid (M i),	_inst_3 : Π (i : ι), module R (M i),	_inst_4 : add_comm_monoid N,	_inst_5 : module R N,	_inst_6 : semiring S,	_inst_7 : module S N,	_inst_8 : smul_comm_class R S N,	F : Π (i : ι), M i →ₗ[R] N,	c : R,	f : Π₀ (i : ι), M i	⊢ ∀ (i : ι) (b : (λ (i : ι), M i) i) (f : Π₀ (i : ι), (λ (i : ι), M i) i), ⇑f i = 0 → b ≠ 0 → ⇑(dfinsupp.sum_add_hom (λ (i : ι), (F i).to_add_monoid_hom)) (c • f) = c • ⇑(dfinsupp.sum_add_hom (λ (i : ι), (F i).to_add_monoid_hom)) f → ⇑(dfinsupp.sum_add_hom (λ (i : ι), (F i).to_add_monoid_hom)) (c • (dfinsupp.single i b + f)) = c • ⇑(dfinsupp.sum_add_hom (λ (i : ι), (F i).to_add_monoid_hom)) (dfinsupp.single i b + f)
ι : Type u_1,	R : Type u_2,	S : Type u_3,	M : ι → Type u_4,	N : Type u_5,	dec_ι : decidable_eq ι,	_inst_1 : semiring R,	_inst_2 : Π (i : ι), add_comm_monoid (M i),	_inst_3 : Π (i : ι), module R (M i),	_inst_4 : add_comm_monoid N,	_inst_5 : module R N,	_inst_6 : semiring S,	_inst_7 : module S N,	_inst_8 : smul_comm_class R S N,	F : Π (i : ι), M i →ₗ[R] N,	c : R,	f : Π₀ (i : ι), M i	⊢ ⇑(dfinsupp.sum_add_hom (λ (i : ι), (F i).to_add_monoid_hom)) (c • 0) = c • ⇑(dfinsupp.sum_add_hom (λ (i : ι), (F i).to_add_monoid_hom)) 0
ι : Type u_1,	R : Type u_2,	S : Type u_3,	M : ι → Type u_4,	N : Type u_5,	dec_ι : decidable_eq ι,	_inst_1 : semiring R,	_inst_2 : Π (i : ι), add_comm_monoid (M i),	_inst_3 : Π (i : ι), module R (M i),	_inst_4 : add_comm_monoid N,	_inst_5 : module R N,	_inst_6 : semiring S,	_inst_7 : module S N,	_inst_8 : smul_comm_class R S N,	F : Π (i : ι), M i →ₗ[R] N,	c : R,	f : Π₀ (i : ι), M i	⊢ ∀ (i : ι) (b : (λ (i : ι), M i) i) (f : Π₀ (i : ι), (λ (i : ι), M i) i), ⇑f i = 0 → b ≠ 0 → ⇑(dfinsupp.sum_add_hom (λ (i : ι), (F i).to_add_monoid_hom)) (c • f) = c • ⇑(dfinsupp.sum_add_hom (λ (i : ι), (F i).to_add_monoid_hom)) f → ⇑(dfinsupp.sum_add_hom (λ (i : ι), (F i).to_add_monoid_hom)) (c • (dfinsupp.single i b + f)) = c • ⇑(dfinsupp.sum_add_hom (λ (i : ι), (F i).to_add_monoid_hom)) (dfinsupp.single i b + f)
ι : Type u_1,	R : Type u_2,	S : Type u_3,	M : ι → Type u_4,	N : Type u_5,	dec_ι : decidable_eq ι,	_inst_1 : semiring R,	_inst_2 : Π (i : ι), add_comm_monoid (M i),	_inst_3 : Π (i : ι), module R (M i),	_inst_4 : add_comm_monoid N,	_inst_5 : module R N,	_inst_6 : semiring S,	_inst_7 : module S N,	_inst_8 : smul_comm_class R S N,	F : Π (i : ι), M i →ₗ[R] N,	c : R,	f : Π₀ (i : ι), M i,	a : ι,	b : M a,	f : Π₀ (i : ι), (λ (i : ι), M i) i,	ha : ⇑f a = 0,	hb : b ≠ 0,	hf : ⇑(dfinsupp.sum_add_hom (λ (i : ι), (F i).to_add_monoid_hom)) (c • f) = c • ⇑(dfinsupp.sum_add_hom (λ (i : ι), (F i).to_add_monoid_hom)) f	⊢ ⇑(dfinsupp.sum_add_hom (λ (i : ι), (F i).to_add_monoid_hom)) (c • (dfinsupp.single a b + f)) = c • ⇑(dfinsupp.sum_add_hom (λ (i : ι), (F i).to_add_monoid_hom)) (dfinsupp.single a b + f)
ι : Type u_1,	R : Type u_2,	S : Type u_3,	M : ι → Type u_4,	N : Type u_5,	dec_ι : decidable_eq ι,	_inst_1 : semiring R,	_inst_2 : Π (i : ι), add_comm_monoid (M i),	_inst_3 : Π (i : ι), module R (M i),	_inst_4 : add_comm_monoid N,	_inst_5 : module R N,	_inst_6 : semiring S,	_inst_7 : module S N,	_inst_8 : smul_comm_class R S N,	F : Π (i : ι), M i →ₗ[R] N	⊢ (λ (F : (Π₀ (i : ι), M i) →ₗ[R] N) (i : ι), F.comp (dfinsupp.lsingle i)) ((λ (F : Π (i : ι), M i →ₗ[R] N), {to_fun := ⇑(dfinsupp.sum_add_hom (λ (i : ι), (F i).to_add_monoid_hom)), map_add' := _, map_smul' := _}) F) = F
ι : Type u_1,	R : Type u_2,	S : Type u_3,	M : ι → Type u_4,	N : Type u_5,	dec_ι : decidable_eq ι,	_inst_1 : semiring R,	_inst_2 : Π (i : ι), add_comm_monoid (M i),	_inst_3 : Π (i : ι), module R (M i),	_inst_4 : add_comm_monoid N,	_inst_5 : module R N,	_inst_6 : semiring S,	_inst_7 : module S N,	_inst_8 : smul_comm_class R S N,	F : Π (i : ι), M i →ₗ[R] N,	x : ι,	y : M x	⊢ ⇑((λ (F : (Π₀ (i : ι), M i) →ₗ[R] N) (i : ι), F.comp (dfinsupp.lsingle i)) ((λ (F : Π (i : ι), M i →ₗ[R] N), {to_fun := ⇑(dfinsupp.sum_add_hom (λ (i : ι), (F i).to_add_monoid_hom)), map_add' := _, map_smul' := _}) F) x) y = ⇑(F x) y
ι : Type u_1,	R : Type u_2,	S : Type u_3,	M : ι → Type u_4,	N : Type u_5,	dec_ι : decidable_eq ι,	_inst_1 : semiring R,	_inst_2 : Π (i : ι), add_comm_monoid (M i),	_inst_3 : Π (i : ι), module R (M i),	_inst_4 : add_comm_monoid N,	_inst_5 : module R N,	_inst_6 : semiring S,	_inst_7 : module S N,	_inst_8 : smul_comm_class R S N,	F : (Π₀ (i : ι), M i) →ₗ[R] N	⊢ (λ (F : Π (i : ι), M i →ₗ[R] N), {to_fun := ⇑(dfinsupp.sum_add_hom (λ (i : ι), (F i).to_add_monoid_hom)), map_add' := _, map_smul' := _}) ((λ (F : (Π₀ (i : ι), M i) →ₗ[R] N) (i : ι), F.comp (dfinsupp.lsingle i)) F) = F
ι : Type u_1,	R : Type u_2,	S : Type u_3,	M : ι → Type u_4,	N : Type u_5,	dec_ι : decidable_eq ι,	_inst_1 : semiring R,	_inst_2 : Π (i : ι), add_comm_monoid (M i),	_inst_3 : Π (i : ι), module R (M i),	_inst_4 : add_comm_monoid N,	_inst_5 : module R N,	_inst_6 : semiring S,	_inst_7 : module S N,	_inst_8 : smul_comm_class R S N,	F : (Π₀ (i : ι), M i) →ₗ[R] N,	x : ι,	y : M x	⊢ ⇑(((λ (F : Π (i : ι), M i →ₗ[R] N), {to_fun := ⇑(dfinsupp.sum_add_hom (λ (i : ι), (F i).to_add_monoid_hom)), map_add' := _, map_smul' := _}) ((λ (F : (Π₀ (i : ι), M i) →ₗ[R] N) (i : ι), F.comp (dfinsupp.lsingle i)) F)).comp (dfinsupp.lsingle x)) y = ⇑(F.comp (dfinsupp.lsingle x)) y
ι : Type u_1,	R : Type u_2,	S : Type u_3,	M : ι → Type u_4,	N : Type u_5,	dec_ι : decidable_eq ι,	_inst_1 : semiring R,	_inst_2 : Π (i : ι), add_comm_monoid (M i),	_inst_3 : Π (i : ι), module R (M i),	_inst_4 : add_comm_monoid N,	_inst_5 : module R N,	_inst_6 : semiring S,	_inst_7 : module S N,	_inst_8 : smul_comm_class R S N,	F G : Π (i : ι), M i →ₗ[R] N	⊢ {to_fun := ⇑(dfinsupp.sum_add_hom (λ (i : ι), ((F + G) i).to_add_monoid_hom)), map_add' := _, map_smul' := _} = {to_fun := ⇑(dfinsupp.sum_add_hom (λ (i : ι), (F i).to_add_monoid_hom)), map_add' := _, map_smul' := _} + {to_fun := ⇑(dfinsupp.sum_add_hom (λ (i : ι), (G i).to_add_monoid_hom)), map_add' := _, map_smul' := _}
ι : Type u_1,	R : Type u_2,	S : Type u_3,	M : ι → Type u_4,	N : Type u_5,	dec_ι : decidable_eq ι,	_inst_1 : semiring R,	_inst_2 : Π (i : ι), add_comm_monoid (M i),	_inst_3 : Π (i : ι), module R (M i),	_inst_4 : add_comm_monoid N,	_inst_5 : module R N,	_inst_6 : semiring S,	_inst_7 : module S N,	_inst_8 : smul_comm_class R S N,	F G : Π (i : ι), M i →ₗ[R] N,	x : ι,	y : M x	⊢ ⇑({to_fun := ⇑(dfinsupp.sum_add_hom (λ (i : ι), ((F + G) i).to_add_monoid_hom)), map_add' := _, map_smul' := _}.comp (dfinsupp.lsingle x)) y = ⇑(({to_fun := ⇑(dfinsupp.sum_add_hom (λ (i : ι), (F i).to_add_monoid_hom)), map_add' := _, map_smul' := _} + {to_fun := ⇑(dfinsupp.sum_add_hom (λ (i : ι), (G i).to_add_monoid_hom)), map_add' := _, map_smul' := _}).comp (dfinsupp.lsingle x)) y
ι : Type u_1,	R : Type u_2,	S : Type u_3,	M : ι → Type u_4,	N : Type u_5,	dec_ι : decidable_eq ι,	_inst_1 : semiring R,	_inst_2 : Π (i : ι), add_comm_monoid (M i),	_inst_3 : Π (i : ι), module R (M i),	_inst_4 : add_comm_monoid N,	_inst_5 : module R N,	_inst_6 : semiring S,	_inst_7 : module S N,	_inst_8 : smul_comm_class R S N,	c : S,	F : Π (i : ι), M i →ₗ[R] N	⊢ {to_fun := ⇑(dfinsupp.sum_add_hom (λ (i : ι), ((c • F) i).to_add_monoid_hom)), map_add' := _, map_smul' := _} = ⇑(ring_hom.id S) c • {to_fun := ⇑(dfinsupp.sum_add_hom (λ (i : ι), (F i).to_add_monoid_hom)), map_add' := _, map_smul' := _}
ι : Type u_1,	R : Type u_2,	S : Type u_3,	M : ι → Type u_4,	N : Type u_5,	dec_ι : decidable_eq ι,	_inst_1 : semiring R,	_inst_2 : Π (i : ι), add_comm_monoid (M i),	_inst_3 : Π (i : ι), module R (M i),	_inst_4 : add_comm_monoid N,	_inst_5 : module R N,	_inst_6 : semiring S,	_inst_7 : module S N,	_inst_8 : smul_comm_class R S N,	c : S,	F : Π (i : ι), M i →ₗ[R] N,	i : ι,	x : M i	⊢ ⇑({to_fun := ⇑(dfinsupp.sum_add_hom (λ (i : ι), ((c • F) i).to_add_monoid_hom)), map_add' := _, map_smul' := _}.comp (dfinsupp.lsingle i)) x = ⇑((⇑(ring_hom.id S) c • {to_fun := ⇑(dfinsupp.sum_add_hom (λ (i : ι), (F i).to_add_monoid_hom)), map_add' := _, map_smul' := _}).comp (dfinsupp.lsingle i)) x
K : Type u,	V : Type v,	V' : Type v',	_inst_1 : field K,	_inst_2 : add_comm_group V,	_inst_3 : module K V,	_inst_6 : add_comm_group V',	_inst_7 : module K V',	f g : V →ₗ[K] V'	⊢ rank (f + g) ≤ module.rank K ↥(f.range ⊔ g.range)
K : Type u,	V : Type v,	V' : Type v',	_inst_1 : field K,	_inst_2 : add_comm_group V,	_inst_3 : module K V,	_inst_6 : add_comm_group V',	_inst_7 : module K V',	f g : V →ₗ[K] V'	⊢ (f + g).range ≤ f.range ⊔ g.range
R : Type u,	_inst_1 : ring R,	M : Type v,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	M' : Type v',	_inst_4 : add_comm_group M',	_inst_5 : module R M',	f : M ≃ₗ[R] M'	⊢ (module.rank R M).lift = (module.rank R M').lift
R : Type u,	_inst_1 : ring R,	M : Type v,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	M' : Type v',	_inst_4 : add_comm_group M',	_inst_5 : module R M',	f : M ≃ₗ[R] M'	⊢ (module.rank R M).lift ≤ (module.rank R M').lift
R : Type u,	_inst_1 : ring R,	M : Type v,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	M' : Type v',	_inst_4 : add_comm_group M',	_inst_5 : module R M',	f : M ≃ₗ[R] M'	⊢ (module.rank R M).lift ≤ (module.rank R M').lift		R : Type u,	_inst_1 : ring R,	M : Type v,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	M' : Type v',	_inst_4 : add_comm_group M',	_inst_5 : module R M',	f : M ≃ₗ[R] M'	⊢ (module.rank R M').lift ≤ (module.rank R M).lift
R : Type u,	_inst_1 : ring R,	M : Type v,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	M' : Type v',	_inst_4 : add_comm_group M',	_inst_5 : module R M',	f : M ≃ₗ[R] M'	⊢ (module.rank R M').lift ≤ (module.rank R M).lift
R : Type u_1,	M : Type u_2,	ι : Type u_5,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_4 : decidable_eq ι,	b : basis ι R M,	_inst_5 : fintype ι,	i : ι,	x : M	⊢ ⇑(⇑(b.dual_basis) i) x = ⇑(b.coord i) x
R : Type u_1,	M : Type u_2,	ι : Type u_5,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_4 : decidable_eq ι,	b : basis ι R M,	_inst_5 : fintype ι	⊢ ⇑(b.dual_basis) = b.coord
R : Type u_1,	M : Type u_2,	ι : Type u_3,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	e : ι → M,	ε : ι → module.dual R M,	_inst_4 : decidable_eq ι,	h : dual_pair e ε,	l : ι →₀ R,	i : ι	⊢ ⇑(h.coeffs (dual_pair.lc e l)) i = ⇑l i
R : Type u_1,	M : Type u_2,	ι : Type u_3,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	e : ι → M,	ε : ι → module.dual R M,	_inst_4 : decidable_eq ι,	h : dual_pair e ε,	l : ι →₀ R	⊢ h.coeffs (dual_pair.lc e l) = l
K : Type u,	V : Type v,	_inst_1 : field K,	_inst_2 : add_comm_group V,	_inst_3 : module K V,	_inst_6 : finite_dimensional K V,	W : subspace K V	⊢ submodule.quotient W ≃ₗ[K] ↥(submodule.dual_annihilator W)
K : Type u,	V : Type v,	_inst_1 : field K,	_inst_2 : add_comm_group V,	_inst_3 : module K V,	_inst_6 : finite_dimensional K V,	W : subspace K V	⊢ submodule.quotient W ≃ₗ[K] W.dual_lift.range.quotient
K : Type u,	V : Type v,	_inst_1 : field K,	_inst_2 : add_comm_group V,	_inst_3 : module K V,	_inst_6 : finite_dimensional K V,	W : subspace K V	⊢ ↥W ≃ₗ[K] ↥(W.dual_lift.range)
K : Type v,	V : Type w,	_inst_4 : field K,	_inst_5 : add_comm_group V,	_inst_6 : module K V,	_inst_7 : is_alg_closed K,	_inst_8 : finite_dimensional K V,	_inst_9 : nontrivial V,	f : module.End K V	⊢ ∃ (c : K), f.has_eigenvalue c
K : Type v,	V : Type w,	_inst_4 : field K,	_inst_5 : add_comm_group V,	_inst_6 : module K V,	_inst_7 : is_alg_closed K,	_inst_8 : finite_dimensional K V,	_inst_9 : nontrivial V,	f : module.End K V,	c : K,	nu : ¬is_unit (f - ⇑(algebra_map K (module.End K V)) c)	⊢ ∃ (c : K), f.has_eigenvalue c
K : Type v,	V : Type w,	_inst_4 : field K,	_inst_5 : add_comm_group V,	_inst_6 : module K V,	_inst_7 : is_alg_closed K,	_inst_8 : finite_dimensional K V,	_inst_9 : nontrivial V,	f : module.End K V,	c : K,	nu : ¬is_unit (f - ⇑(algebra_map K (module.End K V)) c)	⊢ f.has_eigenvalue c
K : Type v,	V : Type w,	_inst_4 : field K,	_inst_5 : add_comm_group V,	_inst_6 : module K V,	_inst_7 : is_alg_closed K,	_inst_8 : finite_dimensional K V,	_inst_9 : nontrivial V,	f : module.End K V,	c : K,	nu : ¬linear_map.ker (f - ⇑(algebra_map K (module.End K V)) c) = ⊥	⊢ f.has_eigenvalue c
R : Type v,	M : Type w,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	f : module.End R M,	p : submodule R M,	k : ℕ,	μ : R,	hfp : ∀ (x : M), x ∈ p → ⇑f x ∈ p	⊢ ⇑(module.End.generalized_eigenspace (linear_map.restrict f hfp) μ) k = submodule.comap p.subtype (⇑(f.generalized_eigenspace μ) k)
R : Type v,	M : Type w,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	f : module.End R M,	p : submodule R M,	k : ℕ,	μ : R,	hfp : ∀ (x : M), x ∈ p → ⇑f x ∈ p	⊢ linear_map.ker ((linear_map.restrict f hfp - ⇑(algebra_map R (module.End R ↥p)) μ) ^ k) = submodule.comap p.subtype (linear_map.ker ((f - ⇑(algebra_map R (module.End R M)) μ) ^ k))
R : Type v,	M : Type w,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	f : module.End R M,	p : submodule R M,	μ : R,	hfp : ∀ (x : M), x ∈ p → ⇑f x ∈ p	⊢ linear_map.ker ((linear_map.restrict f hfp - ⇑(algebra_map R (module.End R ↥p)) μ) ^ 0) = submodule.comap p.subtype (linear_map.ker ((f - ⇑(algebra_map R (module.End R M)) μ) ^ 0))
R : Type v,	M : Type w,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	f : module.End R M,	p : submodule R M,	μ : R,	hfp : ∀ (x : M), x ∈ p → ⇑f x ∈ p	⊢ linear_map.ker ((linear_map.restrict f hfp - ⇑(algebra_map R (module.End R ↥p)) μ) ^ 0) = submodule.comap p.subtype (linear_map.ker ((f - ⇑(algebra_map R (module.End R M)) μ) ^ 0))		case nat.succ	R : Type v,	M : Type w,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	f : module.End R M,	p : submodule R M,	μ : R,	hfp : ∀ (x : M), x ∈ p → ⇑f x ∈ p,	k : ℕ,	ih : linear_map.ker ((linear_map.restrict f hfp - ⇑(algebra_map R (module.End R ↥p)) μ) ^ k) = submodule.comap p.subtype (linear_map.ker ((f - ⇑(algebra_map R (module.End R M)) μ) ^ k))	⊢ linear_map.ker ((linear_map.restrict f hfp - ⇑(algebra_map R (module.End R ↥p)) μ) ^ k.succ) = submodule.comap p.subtype (linear_map.ker ((f - ⇑(algebra_map R (module.End R M)) μ) ^ k.succ))
R : Type v,	M : Type w,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	f : module.End R M,	p : submodule R M,	μ : R,	hfp : ∀ (x : M), x ∈ p → ⇑f x ∈ p	⊢ linear_map.id.ker = submodule.comap p.subtype (linear_map.ker 1)
R : Type v,	M : Type w,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	f : module.End R M,	p : submodule R M,	μ : R,	hfp : ∀ (x : M), x ∈ p → ⇑f x ∈ p,	k : ℕ,	ih : linear_map.ker ((linear_map.restrict f hfp - ⇑(algebra_map R (module.End R ↥p)) μ) ^ k) = submodule.comap p.subtype (linear_map.ker ((f - ⇑(algebra_map R (module.End R M)) μ) ^ k))	⊢ linear_map.ker ((linear_map.restrict f hfp - ⇑(algebra_map R (module.End R ↥p)) μ) ^ k.succ) = submodule.comap p.subtype (linear_map.ker ((f - ⇑(algebra_map R (module.End R M)) μ) ^ k.succ))
K : Type u,	V : Type v,	_inst_1 : field K,	_inst_2 : add_comm_group V,	_inst_3 : module K V,	v : V,	n : v ≠ 0,	h : ∀ (w : V), ∃ (c : K), c • v = w	⊢ finite_dimensional.finrank K V = 1
K : Type u,	V : Type v,	_inst_1 : field K,	_inst_2 : add_comm_group V,	_inst_3 : module K V,	v : V,	n : v ≠ 0,	h : ∀ (w : V), ∃ (c : K), c • v = w,	b : basis punit K V	⊢ finite_dimensional.finrank K V = 1
K : Type u,	V : Type v,	_inst_1 : division_ring K,	_inst_2 : add_comm_group V,	_inst_3 : module K V,	ι : Type ?,	_inst_6 : unique ι,	h : finite_dimensional.finrank K V = 1	⊢ basis ι K V
K : Type u,	V : Type v,	_inst_1 : division_ring K,	_inst_2 : add_comm_group V,	_inst_3 : module K V,	ι : Type ?,	_inst_6 : unique ι,	h : finite_dimensional.finrank K V = 1,	_inst : finite_dimensional K V	⊢ basis ι K V
K : Type u,	V : Type v,	_inst_1 : division_ring K,	_inst_2 : add_comm_group V,	_inst_3 : module K V,	_inst_6 : finite_dimensional K V,	ι : Type w,	b : ι → V,	h : linear_independent K b	⊢ # ι ≤ ↑(finite_dimensional.finrank K V)
K : Type u,	V : Type v,	_inst_1 : division_ring K,	_inst_2 : add_comm_group V,	_inst_3 : module K V,	_inst_6 : finite_dimensional K V,	ι : Type w,	b : ι → V,	h : linear_independent K b	⊢ (# ι).lift ≤ ↑(finite_dimensional.finrank K V).lift
K : Type u,	V : Type v,	_inst_1 : division_ring K,	_inst_2 : add_comm_group V,	_inst_3 : module K V,	V₂ : Type v',	_inst_4 : add_comm_group V₂,	_inst_5 : module K V₂,	f : V →ₗ[K] V₂,	p : submodule K V,	h : finite_dimensional K ↥p	⊢ finite_dimensional K ↥(submodule.map f p)
K : Type u,	V : Type v,	_inst_1 : division_ring K,	_inst_2 : add_comm_group V,	_inst_3 : module K V,	V₂ : Type v',	_inst_4 : add_comm_group V₂,	_inst_5 : module K V₂,	f : V →ₗ[K] V₂,	p : submodule K V,	h : finite_dimensional K ↥p	⊢ finite_dimensional K ↥(submodule.map f p)
K : Type u,	V : Type v,	_inst_1 : division_ring K,	_inst_2 : add_comm_group V,	_inst_3 : module K V,	V₂ : Type v',	_inst_4 : add_comm_group V₂,	_inst_5 : module K V₂,	f : V →ₗ[K] V₂,	p : submodule K V,	h : module.rank K ↥p < ω	⊢ module.rank K ↥(submodule.map f p) < ω
K : Type u,	V : Type v,	_inst_1 : division_ring K,	_inst_2 : add_comm_group V,	_inst_3 : module K V,	V₂ : Type v',	_inst_4 : add_comm_group V₂,	_inst_5 : module K V₂,	f : V →ₗ[K] V₂,	p : submodule K V,	h : module.rank K ↥p < ω	⊢ (module.rank K ↥(submodule.map f p)).lift < ω.lift
K : Type u,	V : Type v,	_inst_1 : division_ring K,	_inst_2 : add_comm_group V,	_inst_3 : module K V,	V₂ : Type v',	_inst_4 : add_comm_group V₂,	_inst_5 : module K V₂,	f : V →ₗ[K] V₂,	p : submodule K V,	h : (module.rank K ↥p).lift < ω.lift	⊢ (module.rank K ↥(submodule.map f p)).lift < ω.lift
K : Type u,	V : Type v,	_inst_1 : division_ring K,	_inst_2 : add_comm_group V,	_inst_3 : module K V,	V₂ : Type v',	_inst_4 : add_comm_group V₂,	_inst_5 : module K V₂,	f : V →ₗ[K] V₂,	p : submodule K V,	h : (module.rank K ↥p).lift < ω	⊢ (module.rank K ↥(submodule.map f p)).lift < ω
α : Type u_1,	M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	s : set α,	p : α →₀ M	⊢ p ∈ finsupp.supported M R s ↔ ∀ (x : α), x ∉ s → ⇑p x = 0
α : Type u_1,	M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	s : set α,	p : α →₀ M	⊢ p ∈ finsupp.supported M R s ↔ ∀ (x : α), x ∉ s → ⇑p x = 0
α : Type u_1,	M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	s : set α,	p : α →₀ M,	_inst : decidable_pred (λ (x : α), x ∈ s)	⊢ p ∈ finsupp.supported M R s ↔ ∀ (x : α), x ∉ s → ⇑p x = 0
α : Type u_1,	M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	_inst_9 : nontrivial M,	s t : set α	⊢ disjoint (finsupp.supported M R s) (finsupp.supported M R t) ↔ disjoint s t
α : Type u_1,	M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	_inst_9 : nontrivial M,	s t : set α,	h : disjoint (finsupp.supported M R s) (finsupp.supported M R t),	x : α,	hx : x ∈ s ⊓ t	⊢ x ∈ ⊥
α : Type u_1,	M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	_inst_9 : nontrivial M,	s t : set α,	h : disjoint (finsupp.supported M R s) (finsupp.supported M R t),	x : α,	hx : x ∈ s ⊓ t,	y : M,	hy : y ≠ 0	⊢ x ∈ ⊥
α : Type u_1,	M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	_inst_9 : nontrivial M,	s t : set α,	h : disjoint (finsupp.supported M R s) (finsupp.supported M R t),	x : α,	hx : x ∈ s ⊓ t,	y : M,	hy : y ≠ 0,	this : finsupp.single x y ∈ ⊥	⊢ x ∈ ⊥
α : Type u_1,	M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	_inst_9 : nontrivial M,	s t : set α,	h : disjoint (finsupp.supported M R s) (finsupp.supported M R t),	x : α,	hx : x ∈ s ⊓ t,	y : M,	hy : y ≠ 0,	this : y = 0	⊢ x ∈ ⊥
α : Type u_1,	M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	v : α → M	⊢ (finsupp.total α M R v).range = submodule.span R (set.range v)
α : Type u_1,	M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	v : α → M,	x : M	⊢ x ∈ (finsupp.total α M R v).range ↔ x ∈ submodule.span R (set.range v)
α : Type u_1,	M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	v : α → M,	x : M	⊢ x ∈ (finsupp.total α M R v).range → x ∈ submodule.span R (set.range v)
α : Type u_1,	M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	v : α → M,	x : M,	hx : x ∈ (finsupp.total α M R v).range	⊢ x ∈ submodule.span R (set.range v)
α : Type u_1,	M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	v : α → M,	x : M,	hx : ∃ (y : α →₀ R), ⇑(finsupp.total α M R v) y = x	⊢ x ∈ submodule.span R (set.range v)
α : Type u_1,	M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	v : α → M,	x : M,	l : α →₀ R,	hl : ⇑(finsupp.total α M R v) l = x	⊢ x ∈ submodule.span R (set.range v)
α : Type u_1,	M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	v : α → M,	x : M,	l : α →₀ R,	hl : ⇑(finsupp.total α M R v) l = x	⊢ ⇑(finsupp.total α M R v) l ∈ submodule.span R (set.range v)
α : Type u_1,	M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	v : α → M,	x : M,	l : α →₀ R,	hl : ⇑(finsupp.total α M R v) l = x	⊢ l.sum (λ (i : α) (a : R), a • v i) ∈ submodule.span R (set.range v)
α : Type u_1,	M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	v : α → M,	x : M,	l : α →₀ R,	hl : ⇑(finsupp.total α M R v) l = x	⊢ ∑ (a : α) in l.support, ⇑l a • v a ∈ submodule.span R (set.range v)
α : Type u_1,	M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	v : α → M,	x : M,	l : α →₀ R,	hl : ⇑(finsupp.total α M R v) l = x	⊢ ∀ (c : α), c ∈ l.support → ⇑l c • v c ∈ submodule.span R (set.range v)
α : Type u_1,	M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	v : α → M,	x : M	⊢ x ∈ (finsupp.total α M R v).range → x ∈ submodule.span R (set.range v)		α : Type u_1,	M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	v : α → M,	x : M	⊢ x ∈ submodule.span R (set.range v) → x ∈ (finsupp.total α M R v).range
α : Type u_1,	M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	v : α → M,	x : M	⊢ x ∈ submodule.span R (set.range v) → x ∈ (finsupp.total α M R v).range
α : Type u_1,	M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	v : α → M,	x : M	⊢ set.range v ⊆ ↑((finsupp.total α M R v).range)
α : Type u_1,	M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	v : α → M,	x x : M,	hx : x ∈ set.range v	⊢ x ∈ ↑((finsupp.total α M R v).range)
α : Type u_1,	M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	v : α → M,	x x : M,	i : α,	hi : v i = x	⊢ x ∈ ↑((finsupp.total α M R v).range)
α : Type u_1,	M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	v : α → M,	x x : M,	i : α,	hi : v i = x	⊢ ∃ (y : α →₀ R), ⇑(finsupp.total α M R v) y = x
α : Type u_1,	M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	v : α → M,	x x : M,	i : α,	hi : v i = x	⊢ ⇑(finsupp.total α M R v) (finsupp.single i 1) = x
α : Type u_1,	M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	α' : Type u_7,	v : α → M,	f : α' → α,	a : α'	⊢ ⇑((finsupp.total α' M R (v ∘ f)).comp (finsupp.lsingle a)) 1 = ⇑(((finsupp.total α M R v).comp (finsupp.lmap_domain R R f)).comp (finsupp.lsingle a)) 1
α : Type u_1,	M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	α' : Type u_7,	v : α → M,	f : α' → α	⊢ finsupp.total α' M R (v ∘ f) = (finsupp.total α M R v).comp (finsupp.lmap_domain R R f)
M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	α : Type ?,	β : Type ?	⊢ ∀ (r : R) (x : α ⊕ β →₀ M), finsupp.sum_finsupp_add_equiv_prod_finsupp.to_fun (r • x) = ⇑(ring_hom.id R) r • finsupp.sum_finsupp_add_equiv_prod_finsupp.to_fun x
M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	α : Type ?,	β : Type ?,	r : R,	x : α ⊕ β →₀ M	⊢ finsupp.sum_finsupp_add_equiv_prod_finsupp.to_fun (r • x) = ⇑(ring_hom.id R) r • finsupp.sum_finsupp_add_equiv_prod_finsupp.to_fun x
M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	α : Type ?,	β : Type ?,	r : R,	x : α ⊕ β →₀ M	⊢ finsupp.sum_finsupp_add_equiv_prod_finsupp.to_fun (r • x) = ⇑(ring_hom.id R) r • finsupp.sum_finsupp_add_equiv_prod_finsupp.to_fun x
M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	α : Type ?,	β : Type ?,	r : R,	x : α ⊕ β →₀ M,	a : α	⊢ ⇑((finsupp.sum_finsupp_add_equiv_prod_finsupp.to_fun (r • x)).fst) a = ⇑((⇑(ring_hom.id R) r • finsupp.sum_finsupp_add_equiv_prod_finsupp.to_fun x).fst) a
M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	α : Type ?,	β : Type ?,	r : R,	x : α ⊕ β →₀ M,	a : β	⊢ ⇑((finsupp.sum_finsupp_add_equiv_prod_finsupp.to_fun (r • x)).snd) a = ⇑((⇑(ring_hom.id R) r • finsupp.sum_finsupp_add_equiv_prod_finsupp.to_fun x).snd) a
R : Type u,	_inst_1 : comm_ring R,	_inst_2 : nontrivial R,	n m : ℕ,	e : (fin n → R) ≃ₗ[R] fin m → R,	_let_match : (∃ (M : ideal R), M.is_maximal) → n = m,	I : ideal R,	hI : I.is_maximal	⊢ n = m
R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_5 : module R M,	p p' : submodule R M	⊢ submodule.comap p.subtype (p ⊓ p') ≤ ((submodule.comap (p ⊔ p').subtype p').mkq.comp (submodule.of_le le_sup_left)).ker
R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_5 : module R M,	p p' : submodule R M	⊢ submodule.comap p.subtype (p ⊓ p') ≤ submodule.comap p.subtype ((p ⊔ p') ⊓ p')
K : Type u_4,	V : Type u,	_inst_1 : division_ring K,	_inst_2 : add_comm_group V,	_inst_4 : module K V,	ι : Type u_1,	s : set ι,	a : ι,	f : ι → V,	has : a ∉ s	⊢ linear_independent K (λ (x : ↥(has_insert.insert a s)), f ↑x) ↔ linear_independent K (λ (x : ↥s), f ↑x) ∧ f a ∉ submodule.span K (f '' s)
K : Type u_4,	V : Type u,	_inst_1 : division_ring K,	_inst_2 : add_comm_group V,	_inst_4 : module K V,	ι : Type u_1,	s : set ι,	a : ι,	f : ι → V,	has : a ∉ s	⊢ linear_independent K (((λ (x : ↥(has_insert.insert a s)), f ↑x) ∘ ⇑((equiv.option_equiv_sum_punit ↥s).trans (equiv.set.insert has).symm)) ∘ coe) ∧ ((λ (x : ↥(has_insert.insert a s)), f ↑x) ∘ ⇑((equiv.option_equiv_sum_punit ↥s).trans (equiv.set.insert has).symm)) option.none ∉ submodule.span K (set.range (((λ (x : ↥(has_insert.insert a s)), f ↑x) ∘ ⇑((equiv.option_equiv_sum_punit ↥s).trans (equiv.set.insert has).symm)) ∘ coe)) ↔ linear_independent K (λ (x : ↥s), f ↑x) ∧ f a ∉ submodule.span K (f '' s)
ι : Type u_1,	R : Type u_3,	M : Type u_5,	v : ι → M,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_5 : module R M,	hv : linear_independent R v,	_inst_8 : nontrivial R,	x : ↥(submodule.span R (set.range v))	⊢ span.repr R (set.range v) x = finsupp.equiv_map_domain (equiv.of_injective v _) (⇑(hv.repr) x)
ι : Type u_1,	R : Type u_3,	M : Type u_5,	v : ι → M,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_5 : module R M,	hv : linear_independent R v,	_inst_8 : nontrivial R,	x : ↥(submodule.span R (set.range v))	⊢ finsupp.equiv_map_domain (equiv.of_injective v _).symm (span.repr R (set.range v) x) = ⇑(hv.repr) x
ι : Type u_1,	R : Type u_3,	M : Type u_5,	v : ι → M,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_5 : module R M,	hv : linear_independent R v,	_inst_8 : nontrivial R,	x : ↥(submodule.span R (set.range v))	⊢ ⇑(hv.total_equiv) (finsupp.equiv_map_domain (equiv.of_injective v _).symm (span.repr R (set.range v) x)) = ⇑(hv.total_equiv) (⇑(hv.repr) x)
ι : Type u_1,	R : Type u_3,	M : Type u_5,	v : ι → M,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_5 : module R M,	hv : linear_independent R v,	_inst_8 : nontrivial R,	x : ↥(submodule.span R (set.range v))	⊢ finsupp.equiv_map_domain (equiv.of_injective v _).symm (span.repr R (set.range v) x) = ⇑(hv.repr) x		ι : Type u_1,	R : Type u_3,	M : Type u_5,	v : ι → M,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_5 : module R M,	hv : linear_independent R v,	_inst_8 : nontrivial R,	x : ↥(submodule.span R (set.range v)),	p : finsupp.equiv_map_domain (equiv.of_injective v _).symm (span.repr R (set.range v) x) = ⇑(hv.repr) x	⊢ span.repr R (set.range v) x = finsupp.equiv_map_domain (equiv.of_injective v _) (⇑(hv.repr) x)
ι : Type u_1,	R : Type u_3,	M : Type u_5,	v : ι → M,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_5 : module R M,	hv : linear_independent R v,	_inst_8 : nontrivial R,	x : ↥(submodule.span R (set.range v))	⊢ ↑(⇑(hv.total_equiv) (finsupp.equiv_map_domain (equiv.of_injective v _).symm (span.repr R (set.range v) x))) = ↑(⇑(hv.total_equiv) (⇑(hv.repr) x))
ι : Type u_1,	R : Type u_3,	M : Type u_5,	v : ι → M,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_5 : module R M,	hv : linear_independent R v,	_inst_8 : nontrivial R,	x : ↥(submodule.span R (set.range v)),	p : finsupp.equiv_map_domain (equiv.of_injective v _).symm (span.repr R (set.range v) x) = ⇑(hv.repr) x	⊢ span.repr R (set.range v) x = finsupp.equiv_map_domain (equiv.of_injective v _) (⇑(hv.repr) x)
ι : Type u_1,	R : Type u_3,	M : Type u_5,	v : ι → M,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_5 : module R M,	hv : linear_independent R v,	_inst_8 : nontrivial R,	x : ↥(submodule.span R (set.range v)),	p : finsupp.equiv_map_domain (equiv.of_injective v _).symm (span.repr R (set.range v) x) = ⇑(hv.repr) x,	i : ι	⊢ ⇑(span.repr R (set.range v) x) ⟨v i, _⟩ = ⇑(finsupp.equiv_map_domain (equiv.of_injective v _) (⇑(hv.repr) x)) ⟨v i, _⟩
ι : Type u_1,	R : Type u_5,	M : Type u_6,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_4 : fintype ι,	e : basis ι R M,	c : R,	v : ι → M	⊢ e.to_matrix (c • v) = ⇑(ring_hom.id R) c • e.to_matrix v
ι : Type u_1,	R : Type u_5,	M : Type u_6,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_4 : fintype ι,	e : basis ι R M,	c : R,	v : ι → M,	i j : ι	⊢ e.to_matrix (c • v) i j = (⇑(ring_hom.id R) c • e.to_matrix v) i j
ι : Type u_1,	R : Type u_5,	M : Type u_6,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_4 : fintype ι,	e : basis ι R M,	c : R,	v : ι → M,	i j : ι	⊢ ⇑(c • ⇑(e.repr) (v j)) i = (⇑(ring_hom.id R) c • e.to_matrix v) i j
ι : Type u_1,	R : Type u_5,	M : Type u_6,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_4 : fintype ι,	e : basis ι R M	⊢ function.left_inverse (λ (m : matrix ι ι R) (j : ι), ∑ (i : ι), m i j • ⇑e i) e.to_matrix
ι : Type u_1,	R : Type u_5,	M : Type u_6,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_4 : fintype ι,	e : basis ι R M,	v : ι → M	⊢ (λ (m : matrix ι ι R) (j : ι), ∑ (i : ι), m i j • ⇑e i) (e.to_matrix v) = v
ι : Type u_1,	R : Type u_5,	M : Type u_6,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_4 : fintype ι,	e : basis ι R M,	v : ι → M,	j : ι	⊢ (λ (m : matrix ι ι R) (j : ι), ∑ (i : ι), m i j • ⇑e i) (e.to_matrix v) j = v j
ι : Type u_1,	R : Type u_5,	M : Type u_6,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_4 : fintype ι,	e : basis ι R M	⊢ function.right_inverse (λ (m : matrix ι ι R) (j : ι), ∑ (i : ι), m i j • ⇑e i) e.to_matrix
ι : Type u_1,	R : Type u_5,	M : Type u_6,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_4 : fintype ι,	e : basis ι R M,	m : matrix ι ι R	⊢ e.to_matrix ((λ (m : matrix ι ι R) (j : ι), ∑ (i : ι), m i j • ⇑e i) m) = m
ι : Type u_1,	R : Type u_5,	M : Type u_6,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_4 : fintype ι,	e : basis ι R M,	m : matrix ι ι R,	k l : ι	⊢ e.to_matrix ((λ (m : matrix ι ι R) (j : ι), ∑ (i : ι), m i j • ⇑e i) m) k l = m k l
ι : Type u_1,	ι' : Type u_2,	R : Type u_5,	M : Type u_6,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	e : basis ι R M,	v : ι' → M,	j : ι',	_inst_4 : fintype ι	⊢ ∑ (i : ι), e.to_matrix v i j • ⇑e i = v j
ι : Type u_1,	R : Type u_5,	M : Type u_6,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_4 : fintype ι,	e : basis ι R M,	v w : ι → M	⊢ e.to_matrix (v + w) = e.to_matrix v + e.to_matrix w
ι : Type u_1,	R : Type u_5,	M : Type u_6,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_4 : fintype ι,	e : basis ι R M,	v w : ι → M,	i j : ι	⊢ e.to_matrix (v + w) i j = (e.to_matrix v + e.to_matrix w) i j
ι : Type u_1,	R : Type u_5,	M : Type u_6,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_4 : fintype ι,	e : basis ι R M,	v w : ι → M,	i j : ι	⊢ e.to_matrix (v + w) i j = e.to_matrix v i j + e.to_matrix w i j
ι : Type u_1,	R : Type u_5,	M : Type u_6,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_4 : fintype ι,	e : basis ι R M,	v w : ι → M,	i j : ι	⊢ ⇑(⇑(e.repr) (v j) + ⇑(e.repr) (w j)) i = e.to_matrix v i j + e.to_matrix w i j
ι : Type u_1,	R : Type u_5,	M : Type u_6,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_4 : fintype ι,	e : basis ι R M	⊢ ∀ (r : R) (x : ι → M), e.to_matrix (r • x) = ⇑(ring_hom.id R) r • e.to_matrix x
α : Type u_1,	n : Type u_4,	_inst_1 : has_star α,	_inst_2 : add_group n,	v : n → α	⊢ (matrix.circulant v)ᴴ = matrix.circulant (star (λ (i : n), v (-i)))
α : Type u_1,	n : Type u_4,	_inst_1 : has_star α,	_inst_2 : add_group n,	v : n → α	⊢ (matrix.circulant v)ᴴ = matrix.circulant (star (λ (i : n), v (-i)))
α : Type u_1,	n : Type u_4,	_inst_1 : has_star α,	_inst_2 : add_group n,	v : n → α,	i j : n	⊢ (matrix.circulant v)ᴴ i j = matrix.circulant (star (λ (i : n), v (-i))) i j
n' : Type u_1,	_inst_1 : decidable_eq n',	_inst_2 : fintype n',	R : Type u_2,	_inst_3 : comm_ring R,	A : matrix n' n' R	⊢ A ^ -1 = A⁻¹
n' : Type u_1,	_inst_1 : decidable_eq n',	_inst_2 : fintype n',	R : Type u_2,	_inst_3 : comm_ring R,	A : matrix n' n' R	⊢ A = div_inv_monoid.gpow ↑1 A
n' : Type u_1,	_inst_1 : decidable_eq n',	_inst_2 : fintype n',	R : Type u_2,	_inst_3 : comm_ring R,	A : matrix n' n' R,	h : is_unit A.det,	fpow_add_one : ∀ (n : ℤ), A ^ (n + 1) = A ^ n * A,	n : ℕ	⊢ A ^ (↑n + 1) = A ^ ↑n * A
n' : Type u_1,	_inst_1 : decidable_eq n',	_inst_2 : fintype n',	R : Type u_2,	_inst_3 : comm_ring R,	A : matrix n' n' R,	h : is_unit A.det,	fpow_add_one : ∀ (n : ℤ), A ^ (n + 1) = A ^ n * A,	n : ℕ	⊢ A ^ (-(↑n + 1) + 1) = (A ^ n)⁻¹
n' : Type u_1,	_inst_1 : decidable_eq n',	_inst_2 : fintype n',	R : Type u_2,	_inst_3 : comm_ring R,	A : matrix n' n' R,	h : is_unit A.det,	fpow_add_one : ∀ (n : ℤ), A ^ (n + 1) = A ^ n * A,	n : ℕ	⊢ (A ^ n)⁻¹ = (A ⬝ A ^ n)⁻¹ ⬝ A
n' : Type u_1,	_inst_1 : decidable_eq n',	_inst_2 : fintype n',	R : Type u_2,	_inst_3 : comm_ring R,	A : matrix n' n' R,	h : is_unit A.det,	fpow_add_one : ∀ (n : ℤ), A ^ (n + 1) = A ^ n * A,	n : ℕ	⊢ (A ⬝ A ^ n)⁻¹ ⬝ A = A ^ -(↑n + 1) * A
n' : Type u_1,	_inst_1 : decidable_eq n',	_inst_2 : fintype n',	R : Type u_2,	_inst_3 : comm_ring R,	u : units (matrix n' n' R)	⊢ ↑u⁻¹ = (↑u)⁻¹
n' : Type u_1,	_inst_1 : decidable_eq n',	_inst_2 : fintype n',	R : Type u_2,	_inst_3 : comm_ring R,	u : units (matrix n' n' R)	⊢ ↑u⁻¹ ⬝ ↑u = 1
n : Type u,	_inst_1 : decidable_eq n,	_inst_2 : fintype n,	α : Type v,	_inst_3 : comm_ring α,	A : matrix n n α,	h : fintype.card n = 1	⊢ A.adjugate = 1
n : Type u,	_inst_1 : decidable_eq n,	_inst_2 : fintype n,	α : Type v,	_inst_3 : comm_ring α,	A : matrix n n α,	h : fintype.card n = 1,	_inst : subsingleton n	⊢ A.adjugate = 1
n : Type u,	_inst_1 : decidable_eq n,	_inst_2 : fintype n,	α : Type v,	_inst_3 : comm_ring α,	A B : matrix n n α,	h : B ⬝ A = 1	⊢ A⁻¹ = B
n : Type u,	_inst_1 : decidable_eq n,	_inst_2 : fintype n,	α : Type v,	_inst_3 : comm_ring α,	A B : matrix n n α,	h : B ⬝ A = 1,	h1 : is_unit A.det	⊢ A⁻¹ = B
n : Type u,	_inst_1 : decidable_eq n,	_inst_2 : fintype n,	α : Type v,	_inst_3 : comm_ring α,	A B : matrix n n α,	h : B ⬝ A = 1,	h1 : is_unit A.det,	h2 : invertible A	⊢ A⁻¹ = B
n : Type u,	_inst_1 : decidable_eq n,	_inst_2 : fintype n,	α : Type v,	_inst_3 : comm_ring α,	A B : matrix n n α,	h : B ⬝ A = 1,	h1 : is_unit A.det,	h2 : invertible A,	this : ⅟ A = B	⊢ A⁻¹ = B
R : Type u_1,	_inst_1 : comm_ring R,	n : Type u_4,	_inst_2 : fintype n,	_inst_3 : decidable_eq n,	M : matrix n n R	⊢ (⇑matrix.to_lin' M).ker = ⊥ ↔ ∀ (v : n → R), M.mul_vec v = 0 → v = 0
R : Type u_1,	_inst_1 : comm_ring R,	m : Type u_3,	n : Type u_4,	_inst_2 : fintype n,	_inst_3 : fintype m,	_inst_4 : decidable_eq n,	M₁ : Type u_5,	M₂ : Type u_6,	_inst_5 : add_comm_group M₁,	_inst_6 : add_comm_group M₂,	_inst_7 : module R M₁,	_inst_8 : module R M₂,	v₁ : basis n R M₁,	v₂ : basis m R M₂,	_inst_11 : decidable_eq m,	M : matrix m n R,	M' : matrix n m R,	hMM' : M ⬝ M' = 1,	hM'M : M' ⬝ M = 1,	x : M₁	⊢ ⇑(⇑(matrix.to_lin v₂ v₁) M') (⇑(⇑(matrix.to_lin v₁ v₂) M) x) = x
R : Type u_1,	_inst_1 : comm_ring R,	m : Type u_3,	n : Type u_4,	_inst_2 : fintype n,	_inst_3 : fintype m,	_inst_4 : decidable_eq n,	M₁ : Type u_5,	M₂ : Type u_6,	_inst_5 : add_comm_group M₁,	_inst_6 : add_comm_group M₂,	_inst_7 : module R M₁,	_inst_8 : module R M₂,	v₁ : basis n R M₁,	v₂ : basis m R M₂,	_inst_11 : decidable_eq m,	M : matrix m n R,	M' : matrix n m R,	hMM' : M ⬝ M' = 1,	hM'M : M' ⬝ M = 1,	x : M₂	⊢ ⇑(⇑(matrix.to_lin v₁ v₂) M) (⇑(⇑(matrix.to_lin v₂ v₁) M') x) = x
R : Type u_1,	_inst_1 : comm_ring R,	m : Type u_3,	n : Type u_4,	_inst_2 : fintype n,	_inst_3 : decidable_eq n,	M : matrix m n R	⊢ (λ (f : (n → R) →ₗ[R] m → R) (i : m) (j : n), ⇑f (⇑(linear_map.std_basis R (λ (_x : n), R) j) 1) i) M.mul_vec_lin = M
R : Type u_1,	_inst_1 : comm_ring R,	m : Type u_3,	n : Type u_4,	_inst_2 : fintype n,	_inst_3 : decidable_eq n,	M : matrix m n R,	i : m,	j : n	⊢ (λ (f : (n → R) →ₗ[R] m → R) (i : m) (j : n), ⇑f (⇑(linear_map.std_basis R (λ (_x : n), R) j) 1) i) M.mul_vec_lin i j = M i j
R : Type u_1,	_inst_1 : comm_ring R,	m : Type u_3,	n : Type u_4,	_inst_2 : fintype n,	_inst_3 : decidable_eq n,	f : (n → R) →ₗ[R] m → R	⊢ matrix.mul_vec_lin ((λ (f : (n → R) →ₗ[R] m → R) (i : m) (j : n), ⇑f (⇑(linear_map.std_basis R (λ (_x : n), R) j) 1) i) f) = f
R : Type u_1,	_inst_1 : comm_ring R,	m : Type u_3,	n : Type u_4,	_inst_2 : fintype n,	_inst_3 : decidable_eq n,	f : (n → R) →ₗ[R] m → R,	j : n	⊢ ⇑(matrix.mul_vec_lin ((λ (f : (n → R) →ₗ[R] m → R) (i : m) (j : n), ⇑f (⇑(linear_map.std_basis R (λ (_x : n), R) j) 1) i) f)) (⇑(pi.basis_fun R n) j) = ⇑f (⇑(pi.basis_fun R n) j)
R : Type u_1,	_inst_1 : comm_ring R,	m : Type u_3,	n : Type u_4,	_inst_2 : fintype n,	_inst_3 : decidable_eq n,	f : (n → R) →ₗ[R] m → R	⊢ ∀ (i : n), ⇑(matrix.mul_vec_lin ((λ (f : (n → R) →ₗ[R] m → R) (i : m) (j : n), ⇑f (⇑(linear_map.std_basis R (λ (_x : n), R) j) 1) i) f)) (⇑(pi.basis_fun R n) i) = ⇑f (⇑(pi.basis_fun R n) i)
R : Type u_1,	_inst_1 : comm_ring R,	m : Type u_3,	n : Type u_4,	_inst_2 : fintype n,	_inst_3 : decidable_eq n,	f : (n → R) →ₗ[R] m → R,	j : n,	i : m	⊢ ⇑(matrix.mul_vec_lin ((λ (f : (n → R) →ₗ[R] m → R) (i : m) (j : n), ⇑f (⇑(linear_map.std_basis R (λ (_x : n), R) j) 1) i) f)) (⇑(pi.basis_fun R n) j) i = ⇑f (⇑(pi.basis_fun R n) j) i
R : Type u_1,	_inst_1 : comm_ring R,	m : Type u_3,	n : Type u_4,	_inst_2 : fintype n,	_inst_3 : decidable_eq n,	f g : (n → R) →ₗ[R] m → R	⊢ (λ (i : m) (j : n), ⇑(f + g) (⇑(linear_map.std_basis R (λ (_x : n), R) j) 1) i) = (λ (i : m) (j : n), ⇑f (⇑(linear_map.std_basis R (λ (_x : n), R) j) 1) i) + λ (i : m) (j : n), ⇑g (⇑(linear_map.std_basis R (λ (_x : n), R) j) 1) i
R : Type u_1,	_inst_1 : comm_ring R,	m : Type u_3,	n : Type u_4,	_inst_2 : fintype n,	_inst_3 : decidable_eq n,	f g : (n → R) →ₗ[R] m → R,	i : m,	j : n	⊢ ⇑(f + g) (⇑(linear_map.std_basis R (λ (_x : n), R) j) 1) i = ((λ (i : m) (j : n), ⇑f (⇑(linear_map.std_basis R (λ (_x : n), R) j) 1) i) + λ (i : m) (j : n), ⇑g (⇑(linear_map.std_basis R (λ (_x : n), R) j) 1) i) i j
R : Type u_1,	_inst_1 : comm_ring R,	m : Type u_3,	n : Type u_4,	_inst_2 : fintype n,	_inst_3 : decidable_eq n,	c : R,	f : (n → R) →ₗ[R] m → R	⊢ (λ (i : m) (j : n), ⇑(c • f) (⇑(linear_map.std_basis R (λ (_x : n), R) j) 1) i) = ⇑(ring_hom.id R) c • λ (i : m) (j : n), ⇑f (⇑(linear_map.std_basis R (λ (_x : n), R) j) 1) i
R : Type u_1,	_inst_1 : comm_ring R,	m : Type u_3,	n : Type u_4,	_inst_2 : fintype n,	_inst_3 : decidable_eq n,	c : R,	f : (n → R) →ₗ[R] m → R,	i : m,	j : n	⊢ ⇑(c • f) (⇑(linear_map.std_basis R (λ (_x : n), R) j) 1) i = (⇑(ring_hom.id R) c • λ (i : m) (j : n), ⇑f (⇑(linear_map.std_basis R (λ (_x : n), R) j) 1) i) i j
R : Type u,	n : ℕ,	_inst_2 : comm_semiring R,	A : Type u_1,	_inst_9 : semiring A,	_inst_10 : algebra R A,	a : A	⊢ ⇑(multilinear_map.mk_pi_algebra_fin R n A) (λ (_x : fin n), a) = a ^ n
R : Type u,	ι : Type u',	M₁ : ι → Type v₁,	M₂ : Type v₂,	_inst_1 : decidable_eq ι,	_inst_2 : semiring R,	_inst_3 : Π (i : ι), add_comm_monoid (M₁ i),	_inst_4 : add_comm_group M₂,	_inst_5 : Π (i : ι), module R (M₁ i),	_inst_6 : module R M₂,	f : multilinear_map R M₁ M₂,	m : Π (i : ι), M₁ i,	i : ι,	x y : M₁ i	⊢ -⇑f (function.update m i (x + y)) = -⇑f (function.update m i x) + -⇑f (function.update m i y)
R : Type u,	ι : Type u',	M₁ : ι → Type v₁,	M₂ : Type v₂,	_inst_1 : decidable_eq ι,	_inst_2 : semiring R,	_inst_3 : Π (i : ι), add_comm_monoid (M₁ i),	_inst_4 : add_comm_group M₂,	_inst_5 : Π (i : ι), module R (M₁ i),	_inst_6 : module R M₂,	f : multilinear_map R M₁ M₂,	m : Π (i : ι), M₁ i,	i : ι,	c : R,	x : M₁ i	⊢ -⇑f (function.update m i (c • x)) = c • -⇑f (function.update m i x)
R : Type u,	n : ℕ,	M : fin n.succ → Type v,	M₂ : Type v₂,	_inst_2 : comm_semiring R,	_inst_3 : Π (i : fin n.succ), add_comm_monoid (M i),	_inst_5 : add_comm_monoid M₂,	_inst_6 : Π (i : fin n.succ), module R (M i),	_inst_8 : module R M₂,	f : multilinear_map R M M₂,	m : Π (i : fin n), M (⇑fin.cast_succ i),	x y : M (fin.last n)	⊢ ⇑f (fin.snoc m (x + y)) = ⇑f (fin.snoc m x) + ⇑f (fin.snoc m y)
R : Type u,	n : ℕ,	M : fin n.succ → Type v,	M₂ : Type v₂,	_inst_2 : comm_semiring R,	_inst_3 : Π (i : fin n.succ), add_comm_monoid (M i),	_inst_5 : add_comm_monoid M₂,	_inst_6 : Π (i : fin n.succ), module R (M i),	_inst_8 : module R M₂,	f : multilinear_map R M M₂,	m : Π (i : fin n), M (⇑fin.cast_succ i),	c : R,	x : M (fin.last n)	⊢ ⇑f (fin.snoc m (c • x)) = ⇑(ring_hom.id R) c • ⇑f (fin.snoc m x)
R : Type u,	n : ℕ,	M : fin n.succ → Type v,	M₂ : Type v₂,	_inst_2 : comm_semiring R,	_inst_3 : Π (i : fin n.succ), add_comm_monoid (M i),	_inst_5 : add_comm_monoid M₂,	_inst_6 : Π (i : fin n.succ), module R (M i),	_inst_8 : module R M₂,	f : multilinear_map R M M₂,	m : Π (i : fin n), M (⇑fin.cast_succ i),	i : fin n,	x y : M (⇑fin.cast_succ i)	⊢ {to_fun := λ (x_1 : M (fin.last n)), ⇑f (fin.snoc (function.update m i (x + y)) x_1), map_add' := _, map_smul' := _} = {to_fun := λ (x_1 : M (fin.last n)), ⇑f (fin.snoc (function.update m i x) x_1), map_add' := _, map_smul' := _} + {to_fun := λ (x : M (fin.last n)), ⇑f (fin.snoc (function.update m i y) x), map_add' := _, map_smul' := _}
R : Type u,	n : ℕ,	M : fin n.succ → Type v,	M₂ : Type v₂,	_inst_2 : comm_semiring R,	_inst_3 : Π (i : fin n.succ), add_comm_monoid (M i),	_inst_5 : add_comm_monoid M₂,	_inst_6 : Π (i : fin n.succ), module R (M i),	_inst_8 : module R M₂,	f : multilinear_map R M M₂,	m : Π (i : fin n), M (⇑fin.cast_succ i),	i : fin n,	x y : M (⇑fin.cast_succ i),	z : M (fin.last n)	⊢ ⇑{to_fun := λ (x_1 : M (fin.last n)), ⇑f (fin.snoc (function.update m i (x + y)) x_1), map_add' := _, map_smul' := _} z = ⇑({to_fun := λ (x_1 : M (fin.last n)), ⇑f (fin.snoc (function.update m i x) x_1), map_add' := _, map_smul' := _} + {to_fun := λ (x : M (fin.last n)), ⇑f (fin.snoc (function.update m i y) x), map_add' := _, map_smul' := _}) z
R : Type u,	n : ℕ,	M : fin n.succ → Type v,	M₂ : Type v₂,	_inst_2 : comm_semiring R,	_inst_3 : Π (i : fin n.succ), add_comm_monoid (M i),	_inst_5 : add_comm_monoid M₂,	_inst_6 : Π (i : fin n.succ), module R (M i),	_inst_8 : module R M₂,	f : multilinear_map R M M₂,	m : Π (i : fin n), M (⇑fin.cast_succ i),	i : fin n,	x y : M (⇑fin.cast_succ i),	z : M (fin.last n)	⊢ ⇑f (fin.snoc (function.update m i (x + y)) z) = ⇑f (fin.snoc (function.update m i x) z) + ⇑f (fin.snoc (function.update m i y) z)
R : Type u,	n : ℕ,	M : fin n.succ → Type v,	M₂ : Type v₂,	_inst_2 : comm_semiring R,	_inst_3 : Π (i : fin n.succ), add_comm_monoid (M i),	_inst_5 : add_comm_monoid M₂,	_inst_6 : Π (i : fin n.succ), module R (M i),	_inst_8 : module R M₂,	f : multilinear_map R M M₂,	m : Π (i : fin n), M (⇑fin.cast_succ i),	i : fin n,	c : R,	x : M (⇑fin.cast_succ i)	⊢ {to_fun := λ (x_1 : M (fin.last n)), ⇑f (fin.snoc (function.update m i (c • x)) x_1), map_add' := _, map_smul' := _} = c • {to_fun := λ (x_1 : M (fin.last n)), ⇑f (fin.snoc (function.update m i x) x_1), map_add' := _, map_smul' := _}
R : Type u,	n : ℕ,	M : fin n.succ → Type v,	M₂ : Type v₂,	_inst_2 : comm_semiring R,	_inst_3 : Π (i : fin n.succ), add_comm_monoid (M i),	_inst_5 : add_comm_monoid M₂,	_inst_6 : Π (i : fin n.succ), module R (M i),	_inst_8 : module R M₂,	f : multilinear_map R M M₂,	m : Π (i : fin n), M (⇑fin.cast_succ i),	i : fin n,	c : R,	x : M (⇑fin.cast_succ i),	z : M (fin.last n)	⊢ ⇑{to_fun := λ (x_1 : M (fin.last n)), ⇑f (fin.snoc (function.update m i (c • x)) x_1), map_add' := _, map_smul' := _} z = ⇑(c • {to_fun := λ (x_1 : M (fin.last n)), ⇑f (fin.snoc (function.update m i x) x_1), map_add' := _, map_smul' := _}) z
R : Type u,	n : ℕ,	M : fin n.succ → Type v,	M₂ : Type v₂,	_inst_2 : comm_semiring R,	_inst_3 : Π (i : fin n.succ), add_comm_monoid (M i),	_inst_5 : add_comm_monoid M₂,	_inst_6 : Π (i : fin n.succ), module R (M i),	_inst_8 : module R M₂,	f : multilinear_map R M M₂,	m : Π (i : fin n), M (⇑fin.cast_succ i),	i : fin n,	c : R,	x : M (⇑fin.cast_succ i),	z : M (fin.last n)	⊢ ⇑f (fin.snoc (function.update m i (c • x)) z) = c • ⇑f (fin.snoc (function.update m i x) z)
α : Type ?,	β : Type ?,	R : Type ?,	M : Type ?,	_inst_15 : semiring R,	_inst_16 : add_comm_monoid M,	_inst_17 : module R M	⊢ ∀ (x y : α ⊕ β → M), (equiv.sum_arrow_equiv_prod_arrow α β M).to_fun (x + y) = (equiv.sum_arrow_equiv_prod_arrow α β M).to_fun x + (equiv.sum_arrow_equiv_prod_arrow α β M).to_fun y
α : Type ?,	β : Type ?,	R : Type ?,	M : Type ?,	_inst_15 : semiring R,	_inst_16 : add_comm_monoid M,	_inst_17 : module R M,	f g : α ⊕ β → M	⊢ (equiv.sum_arrow_equiv_prod_arrow α β M).to_fun (f + g) = (equiv.sum_arrow_equiv_prod_arrow α β M).to_fun f + (equiv.sum_arrow_equiv_prod_arrow α β M).to_fun g
α : Type ?,	β : Type ?,	R : Type ?,	M : Type ?,	_inst_15 : semiring R,	_inst_16 : add_comm_monoid M,	_inst_17 : module R M,	f g : α ⊕ β → M	⊢ (equiv.sum_arrow_equiv_prod_arrow α β M).to_fun (f + g) = (equiv.sum_arrow_equiv_prod_arrow α β M).to_fun f + (equiv.sum_arrow_equiv_prod_arrow α β M).to_fun g
α : Type ?,	β : Type ?,	R : Type ?,	M : Type ?,	_inst_15 : semiring R,	_inst_16 : add_comm_monoid M,	_inst_17 : module R M,	f g : α ⊕ β → M,	x : α	⊢ ((equiv.sum_arrow_equiv_prod_arrow α β M).to_fun (f + g)).fst x = ((equiv.sum_arrow_equiv_prod_arrow α β M).to_fun f + (equiv.sum_arrow_equiv_prod_arrow α β M).to_fun g).fst x
α : Type ?,	β : Type ?,	R : Type ?,	M : Type ?,	_inst_15 : semiring R,	_inst_16 : add_comm_monoid M,	_inst_17 : module R M,	f g : α ⊕ β → M,	x : β	⊢ ((equiv.sum_arrow_equiv_prod_arrow α β M).to_fun (f + g)).snd x = ((equiv.sum_arrow_equiv_prod_arrow α β M).to_fun f + (equiv.sum_arrow_equiv_prod_arrow α β M).to_fun g).snd x
α : Type ?,	β : Type ?,	R : Type ?,	M : Type ?,	_inst_15 : semiring R,	_inst_16 : add_comm_monoid M,	_inst_17 : module R M	⊢ ∀ (r : R) (x : α ⊕ β → M), (equiv.sum_arrow_equiv_prod_arrow α β M).to_fun (r • x) = ⇑(ring_hom.id R) r • (equiv.sum_arrow_equiv_prod_arrow α β M).to_fun x
α : Type ?,	β : Type ?,	R : Type ?,	M : Type ?,	_inst_15 : semiring R,	_inst_16 : add_comm_monoid M,	_inst_17 : module R M,	r : R,	f : α ⊕ β → M	⊢ (equiv.sum_arrow_equiv_prod_arrow α β M).to_fun (r • f) = ⇑(ring_hom.id R) r • (equiv.sum_arrow_equiv_prod_arrow α β M).to_fun f
α : Type ?,	β : Type ?,	R : Type ?,	M : Type ?,	_inst_15 : semiring R,	_inst_16 : add_comm_monoid M,	_inst_17 : module R M,	r : R,	f : α ⊕ β → M	⊢ (equiv.sum_arrow_equiv_prod_arrow α β M).to_fun (r • f) = ⇑(ring_hom.id R) r • (equiv.sum_arrow_equiv_prod_arrow α β M).to_fun f
α : Type ?,	β : Type ?,	R : Type ?,	M : Type ?,	_inst_15 : semiring R,	_inst_16 : add_comm_monoid M,	_inst_17 : module R M,	r : R,	f : α ⊕ β → M,	x : α	⊢ ((equiv.sum_arrow_equiv_prod_arrow α β M).to_fun (r • f)).fst x = (⇑(ring_hom.id R) r • (equiv.sum_arrow_equiv_prod_arrow α β M).to_fun f).fst x
α : Type ?,	β : Type ?,	R : Type ?,	M : Type ?,	_inst_15 : semiring R,	_inst_16 : add_comm_monoid M,	_inst_17 : module R M,	r : R,	f : α ⊕ β → M,	x : β	⊢ ((equiv.sum_arrow_equiv_prod_arrow α β M).to_fun (r • f)).snd x = (⇑(ring_hom.id R) r • (equiv.sum_arrow_equiv_prod_arrow α β M).to_fun f).snd x
R : Type u,	M : Type v,	M₂ : Type w,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : add_comm_monoid M₂,	_inst_4 : module R M,	_inst_5 : module R M₂,	p : submodule R M	⊢ submodule.comap (linear_map.fst R M M₂) p = p.prod ⊤
R : Type u,	M : Type v,	M₂ : Type w,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : add_comm_monoid M₂,	_inst_4 : module R M,	_inst_5 : module R M₂,	p : submodule R M,	x : M,	y : M₂	⊢ (x, y) ∈ submodule.comap (linear_map.fst R M M₂) p ↔ (x, y) ∈ p.prod ⊤
R : Type u,	M : Type v,	M₂ : Type w,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : add_comm_monoid M₂,	_inst_4 : module R M,	_inst_5 : module R M₂,	p : submodule R M	⊢ submodule.comap (linear_map.fst R M M₂) p = p.prod ⊤
R : Type u,	M : Type v,	M₂ : Type w,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : add_comm_monoid M₂,	_inst_4 : module R M,	_inst_5 : module R M₂,	x : M,	ᾰ : x = 0	⊢ M₂
R : Type u,	M : Type v,	M₂ : Type w,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : add_comm_monoid M₂,	_inst_4 : module R M,	_inst_5 : module R M₂	⊢ submodule.map (linear_map.fst R M M₂) (submodule.snd R M M₂) = ⊥
R : Type u_2,	M : Type u_3,	_inst_1 : add_comm_group M,	_inst_2 : ring R,	_inst_4 : module R M,	Q' : quadratic_form R M,	Q_to_fun : M → R,	Q_to_fun_smul : ∀ (a : R) (x : M), Q_to_fun (a • x) = a * a * Q_to_fun x,	Q_polar_add_left' : ∀ (x x' y : M), quadratic_form.polar Q_to_fun (x + x') y = quadratic_form.polar Q_to_fun x y + quadratic_form.polar Q_to_fun x' y,	Q_polar_smul_left' : ∀ (a : R) (x y : M), quadratic_form.polar Q_to_fun (a • x) y = a • quadratic_form.polar Q_to_fun x y,	Q_polar_add_right' : ∀ (x y y' : M), quadratic_form.polar Q_to_fun x (y + y') = quadratic_form.polar Q_to_fun x y + quadratic_form.polar Q_to_fun x y',	Q_polar_smul_right' : ∀ (a : R) (x y : M), quadratic_form.polar Q_to_fun x (a • y) = a • quadratic_form.polar Q_to_fun x y,	H : ∀ (x : M), ⇑{to_fun := Q_to_fun, to_fun_smul := Q_to_fun_smul, polar_add_left' := Q_polar_add_left', polar_smul_left' := Q_polar_smul_left', polar_add_right' := Q_polar_add_right', polar_smul_right' := Q_polar_smul_right'} x = ⇑Q' x	⊢ {to_fun := Q_to_fun, to_fun_smul := Q_to_fun_smul, polar_add_left' := Q_polar_add_left', polar_smul_left' := Q_polar_smul_left', polar_add_right' := Q_polar_add_right', polar_smul_right' := Q_polar_smul_right'} = Q'
R : Type u_2,	M : Type u_3,	_inst_1 : add_comm_group M,	_inst_2 : ring R,	_inst_4 : module R M,	Q_to_fun : M → R,	Q_to_fun_smul : ∀ (a : R) (x : M), Q_to_fun (a • x) = a * a * Q_to_fun x,	Q_polar_add_left' : ∀ (x x' y : M), quadratic_form.polar Q_to_fun (x + x') y = quadratic_form.polar Q_to_fun x y + quadratic_form.polar Q_to_fun x' y,	Q_polar_smul_left' : ∀ (a : R) (x y : M), quadratic_form.polar Q_to_fun (a • x) y = a • quadratic_form.polar Q_to_fun x y,	Q_polar_add_right' : ∀ (x y y' : M), quadratic_form.polar Q_to_fun x (y + y') = quadratic_form.polar Q_to_fun x y + quadratic_form.polar Q_to_fun x y',	Q_polar_smul_right' : ∀ (a : R) (x y : M), quadratic_form.polar Q_to_fun x (a • y) = a • quadratic_form.polar Q_to_fun x y,	Q'_to_fun : M → R,	Q'_to_fun_smul : ∀ (a : R) (x : M), Q'_to_fun (a • x) = a * a * Q'_to_fun x,	Q'_polar_add_left' : ∀ (x x' y : M), quadratic_form.polar Q'_to_fun (x + x') y = quadratic_form.polar Q'_to_fun x y + quadratic_form.polar Q'_to_fun x' y,	Q'_polar_smul_left' : ∀ (a : R) (x y : M), quadratic_form.polar Q'_to_fun (a • x) y = a • quadratic_form.polar Q'_to_fun x y,	Q'_polar_add_right' : ∀ (x y y' : M), quadratic_form.polar Q'_to_fun x (y + y') = quadratic_form.polar Q'_to_fun x y + quadratic_form.polar Q'_to_fun x y',	Q'_polar_smul_right' : ∀ (a : R) (x y : M), quadratic_form.polar Q'_to_fun x (a • y) = a • quadratic_form.polar Q'_to_fun x y,	H : ∀ (x : M), ⇑{to_fun := Q_to_fun, to_fun_smul := Q_to_fun_smul, polar_add_left' := Q_polar_add_left', polar_smul_left' := Q_polar_smul_left', polar_add_right' := Q_polar_add_right', polar_smul_right' := Q_polar_smul_right'} x = ⇑{to_fun := Q'_to_fun, to_fun_smul := Q'_to_fun_smul, polar_add_left' := Q'_polar_add_left', polar_smul_left' := Q'_polar_smul_left', polar_add_right' := Q'_polar_add_right', polar_smul_right' := Q'_polar_smul_right'} x	⊢ {to_fun := Q_to_fun, to_fun_smul := Q_to_fun_smul, polar_add_left' := Q_polar_add_left', polar_smul_left' := Q_polar_smul_left', polar_add_right' := Q_polar_add_right', polar_smul_right' := Q_polar_smul_right'} = {to_fun := Q'_to_fun, to_fun_smul := Q'_to_fun_smul, polar_add_left' := Q'_polar_add_left', polar_smul_left' := Q'_polar_smul_left', polar_add_right' := Q'_polar_add_right', polar_smul_right' := Q'_polar_smul_right'}
R : Type u_2,	M : Type u_3,	_inst_1 : add_comm_group M,	_inst_2 : ring R,	_inst_4 : module R M,	Q_to_fun : M → R,	Q_to_fun_smul : ∀ (a : R) (x : M), Q_to_fun (a • x) = a * a * Q_to_fun x,	Q_polar_add_left' : ∀ (x x' y : M), quadratic_form.polar Q_to_fun (x + x') y = quadratic_form.polar Q_to_fun x y + quadratic_form.polar Q_to_fun x' y,	Q_polar_smul_left' : ∀ (a : R) (x y : M), quadratic_form.polar Q_to_fun (a • x) y = a • quadratic_form.polar Q_to_fun x y,	Q_polar_add_right' : ∀ (x y y' : M), quadratic_form.polar Q_to_fun x (y + y') = quadratic_form.polar Q_to_fun x y + quadratic_form.polar Q_to_fun x y',	Q_polar_smul_right' : ∀ (a : R) (x y : M), quadratic_form.polar Q_to_fun x (a • y) = a • quadratic_form.polar Q_to_fun x y,	Q'_to_fun : M → R,	Q'_to_fun_smul : ∀ (a : R) (x : M), Q'_to_fun (a • x) = a * a * Q'_to_fun x,	Q'_polar_add_left' : ∀ (x x' y : M), quadratic_form.polar Q'_to_fun (x + x') y = quadratic_form.polar Q'_to_fun x y + quadratic_form.polar Q'_to_fun x' y,	Q'_polar_smul_left' : ∀ (a : R) (x y : M), quadratic_form.polar Q'_to_fun (a • x) y = a • quadratic_form.polar Q'_to_fun x y,	Q'_polar_add_right' : ∀ (x y y' : M), quadratic_form.polar Q'_to_fun x (y + y') = quadratic_form.polar Q'_to_fun x y + quadratic_form.polar Q'_to_fun x y',	Q'_polar_smul_right' : ∀ (a : R) (x y : M), quadratic_form.polar Q'_to_fun x (a • y) = a • quadratic_form.polar Q'_to_fun x y,	H : ∀ (x : M), ⇑{to_fun := Q_to_fun, to_fun_smul := Q_to_fun_smul, polar_add_left' := Q_polar_add_left', polar_smul_left' := Q_polar_smul_left', polar_add_right' := Q_polar_add_right', polar_smul_right' := Q_polar_smul_right'} x = ⇑{to_fun := Q'_to_fun, to_fun_smul := Q'_to_fun_smul, polar_add_left' := Q'_polar_add_left', polar_smul_left' := Q'_polar_smul_left', polar_add_right' := Q'_polar_add_right', polar_smul_right' := Q'_polar_smul_right'} x	⊢ Q_to_fun = Q'_to_fun
R : Type u_2,	M : Type u_3,	_inst_1 : add_comm_group M,	_inst_2 : ring R,	_inst_4 : module R M,	Q_to_fun : M → R,	Q_to_fun_smul : ∀ (a : R) (x : M), Q_to_fun (a • x) = a * a * Q_to_fun x,	Q_polar_add_left' : ∀ (x x' y : M), quadratic_form.polar Q_to_fun (x + x') y = quadratic_form.polar Q_to_fun x y + quadratic_form.polar Q_to_fun x' y,	Q_polar_smul_left' : ∀ (a : R) (x y : M), quadratic_form.polar Q_to_fun (a • x) y = a • quadratic_form.polar Q_to_fun x y,	Q_polar_add_right' : ∀ (x y y' : M), quadratic_form.polar Q_to_fun x (y + y') = quadratic_form.polar Q_to_fun x y + quadratic_form.polar Q_to_fun x y',	Q_polar_smul_right' : ∀ (a : R) (x y : M), quadratic_form.polar Q_to_fun x (a • y) = a • quadratic_form.polar Q_to_fun x y,	Q'_to_fun : M → R,	Q'_to_fun_smul : ∀ (a : R) (x : M), Q'_to_fun (a • x) = a * a * Q'_to_fun x,	Q'_polar_add_left' : ∀ (x x' y : M), quadratic_form.polar Q'_to_fun (x + x') y = quadratic_form.polar Q'_to_fun x y + quadratic_form.polar Q'_to_fun x' y,	Q'_polar_smul_left' : ∀ (a : R) (x y : M), quadratic_form.polar Q'_to_fun (a • x) y = a • quadratic_form.polar Q'_to_fun x y,	Q'_polar_add_right' : ∀ (x y y' : M), quadratic_form.polar Q'_to_fun x (y + y') = quadratic_form.polar Q'_to_fun x y + quadratic_form.polar Q'_to_fun x y',	Q'_polar_smul_right' : ∀ (a : R) (x y : M), quadratic_form.polar Q'_to_fun x (a • y) = a • quadratic_form.polar Q'_to_fun x y,	H : ∀ (x : M), ⇑{to_fun := Q_to_fun, to_fun_smul := Q_to_fun_smul, polar_add_left' := Q_polar_add_left', polar_smul_left' := Q_polar_smul_left', polar_add_right' := Q_polar_add_right', polar_smul_right' := Q_polar_smul_right'} x = ⇑{to_fun := Q'_to_fun, to_fun_smul := Q'_to_fun_smul, polar_add_left' := Q'_polar_add_left', polar_smul_left' := Q'_polar_smul_left', polar_add_right' := Q'_polar_add_right', polar_smul_right' := Q'_polar_smul_right'} x,	x : M	⊢ Q_to_fun x = Q'_to_fun x
R : Type u_2,	M : Type u_3,	_inst_1 : add_comm_group M,	_inst_2 : ring R,	_inst_4 : module R M,	Q Q' : quadratic_form R M,	H : ∀ (x : M), ⇑Q x = ⇑Q' x	⊢ Q = Q'
S : Type u_1,	R : Type u_2,	M : Type u_3,	_inst_1 : add_comm_group M,	_inst_2 : ring R,	_inst_4 : module R M,	_inst_6 : comm_semiring S,	_inst_7 : algebra S R,	_inst_8 : invertible 2,	Q : quadratic_form R M,	x : M	⊢ ⇑((⇑(quadratic_form.associated_hom S) Q).to_quadratic_form) x = ⅟ 2 * (⇑Q x + ⇑Q x)
S : Type u_1,	R : Type u_2,	M : Type u_3,	_inst_1 : add_comm_group M,	_inst_2 : ring R,	_inst_4 : module R M,	_inst_6 : comm_semiring S,	_inst_7 : algebra S R,	_inst_8 : invertible 2,	Q : quadratic_form R M,	x : M	⊢ ⅟ 2 * (⇑Q x + ⇑Q x) = ⇑Q x
R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	p : submodule R M,	R₂ : Type u_3,	M₂ : Type u_4,	_inst_4 : ring R₂,	_inst_5 : add_comm_group M₂,	_inst_6 : module R₂ M₂,	τ₁₂ : R →+* R₂,	f : M →ₛₗ[τ₁₂] M₂,	h : p ≤ f.ker,	h' : f.ker ≤ p	⊢ (p.liftq f h).ker = ⊥
R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	R₂ : Type u_3,	M₂ : Type u_4,	_inst_4 : ring R₂,	_inst_5 : add_comm_group M₂,	_inst_6 : module R₂ M₂,	τ₁₂ : R →+* R₂,	_inst_7 : ring_hom_surjective τ₁₂,	f : M →ₛₗ[τ₁₂] M₂,	s : set M₂,	h₀ : s.nonempty,	h₁ : s ⊆ ↑(f.range)	⊢ submodule.span R (⇑f ⁻¹' s) = submodule.comap f (submodule.span R₂ s)
R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	R₂ : Type u_3,	M₂ : Type u_4,	_inst_4 : ring R₂,	_inst_5 : add_comm_group M₂,	_inst_6 : module R₂ M₂,	τ₁₂ : R →+* R₂,	_inst_7 : ring_hom_surjective τ₁₂,	f : M →ₛₗ[τ₁₂] M₂,	s : set M₂,	h₀ : s.nonempty,	h₁ : s ⊆ ↑(f.range),	this : submodule.comap f (submodule.span R₂ s) ≤ submodule.span R (⇑f ⁻¹' s)	⊢ submodule.span R (⇑f ⁻¹' s) = submodule.comap f (submodule.span R₂ s)		R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	R₂ : Type u_3,	M₂ : Type u_4,	_inst_4 : ring R₂,	_inst_5 : add_comm_group M₂,	_inst_6 : module R₂ M₂,	τ₁₂ : R →+* R₂,	_inst_7 : ring_hom_surjective τ₁₂,	f : M →ₛₗ[τ₁₂] M₂,	s : set M₂,	h₀ : s.nonempty,	h₁ : s ⊆ ↑(f.range)	⊢ submodule.comap f (submodule.span R₂ s) ≤ submodule.span R (⇑f ⁻¹' s)
R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	R₂ : Type u_3,	M₂ : Type u_4,	_inst_4 : ring R₂,	_inst_5 : add_comm_group M₂,	_inst_6 : module R₂ M₂,	τ₁₂ : R →+* R₂,	_inst_7 : ring_hom_surjective τ₁₂,	f : M →ₛₗ[τ₁₂] M₂,	s : set M₂,	h₀ : s.nonempty,	h₁ : s ⊆ ↑(f.range),	this : submodule.comap f (submodule.span R₂ s) ≤ submodule.span R (⇑f ⁻¹' s)	⊢ submodule.span R (⇑f ⁻¹' s) = submodule.comap f (submodule.span R₂ s)
R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	R₂ : Type u_3,	M₂ : Type u_4,	_inst_4 : ring R₂,	_inst_5 : add_comm_group M₂,	_inst_6 : module R₂ M₂,	τ₁₂ : R →+* R₂,	_inst_7 : ring_hom_surjective τ₁₂,	f : M →ₛₗ[τ₁₂] M₂,	s : set M₂,	h₀ : s.nonempty,	h₁ : s ⊆ ↑(f.range)	⊢ submodule.comap f (submodule.span R₂ s) ≤ submodule.span R (⇑f ⁻¹' s)
R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	R₂ : Type u_3,	M₂ : Type u_4,	_inst_4 : ring R₂,	_inst_5 : add_comm_group M₂,	_inst_6 : module R₂ M₂,	τ₁₂ : R →+* R₂,	_inst_7 : ring_hom_surjective τ₁₂,	f : M →ₛₗ[τ₁₂] M₂,	s : set M₂,	h₀ : s.nonempty,	h₁ : s ⊆ ↑(f.range),	y : M₂ := classical.some h₀	⊢ f.ker ≤ submodule.span R (⇑f ⁻¹' s)
R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	R₂ : Type u_3,	M₂ : Type u_4,	_inst_4 : ring R₂,	_inst_5 : add_comm_group M₂,	_inst_6 : module R₂ M₂,	τ₁₂ : R →+* R₂,	_inst_7 : ring_hom_surjective τ₁₂,	f : M →ₛₗ[τ₁₂] M₂,	s : set M₂,	h₀ : s.nonempty,	h₁ : s ⊆ ↑(f.range),	y : M₂ := classical.some h₀	⊢ y ∈ s
R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	R₂ : Type u_3,	M₂ : Type u_4,	_inst_4 : ring R₂,	_inst_5 : add_comm_group M₂,	_inst_6 : module R₂ M₂,	τ₁₂ : R →+* R₂,	_inst_7 : ring_hom_surjective τ₁₂,	f : M →ₛₗ[τ₁₂] M₂,	s : set M₂,	h₀ : s.nonempty,	h₁ : s ⊆ ↑(f.range)	⊢ f.ker ≤ submodule.span R (⇑f ⁻¹' s)
R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	R₂ : Type u_3,	M₂ : Type u_4,	_inst_4 : ring R₂,	_inst_5 : add_comm_group M₂,	_inst_6 : module R₂ M₂,	τ₁₂ : R →+* R₂,	_inst_7 : ring_hom_surjective τ₁₂,	f : M →ₛₗ[τ₁₂] M₂,	s : set M₂,	h₀ : s.nonempty,	h₁ : s ⊆ ↑(f.range),	y : M₂ := classical.some h₀	⊢ y ∈ s		R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	R₂ : Type u_3,	M₂ : Type u_4,	_inst_4 : ring R₂,	_inst_5 : add_comm_group M₂,	_inst_6 : module R₂ M₂,	τ₁₂ : R →+* R₂,	_inst_7 : ring_hom_surjective τ₁₂,	f : M →ₛₗ[τ₁₂] M₂,	s : set M₂,	h₀ : s.nonempty,	h₁ : s ⊆ ↑(f.range),	y : M₂ := classical.some h₀,	hy : y ∈ s	⊢ f.ker ≤ submodule.span R (⇑f ⁻¹' s)
R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	R₂ : Type u_3,	M₂ : Type u_4,	_inst_4 : ring R₂,	_inst_5 : add_comm_group M₂,	_inst_6 : module R₂ M₂,	τ₁₂ : R →+* R₂,	_inst_7 : ring_hom_surjective τ₁₂,	f : M →ₛₗ[τ₁₂] M₂,	s : set M₂,	h₀ : s.nonempty,	h₁ : s ⊆ ↑(f.range),	y : M₂ := classical.some h₀,	hy : y ∈ s	⊢ ∃ (y : M₂) (H : y ∈ f.range), ⇑f ⁻¹' {y} ⊆ ↑(submodule.span R (⇑f ⁻¹' s))
R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	R₂ : Type u_3,	M₂ : Type u_4,	_inst_4 : ring R₂,	_inst_5 : add_comm_group M₂,	_inst_6 : module R₂ M₂,	τ₁₂ : R →+* R₂,	_inst_7 : ring_hom_surjective τ₁₂,	f : M →ₛₗ[τ₁₂] M₂,	s : set M₂,	h₀ : s.nonempty,	h₁ : s ⊆ ↑(f.range),	y : M₂ := classical.some h₀,	hy : y ∈ s	⊢ ⇑f ⁻¹' {y} ⊆ ↑(submodule.span R (⇑f ⁻¹' s))
R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	R₂ : Type u_3,	M₂ : Type u_4,	_inst_4 : ring R₂,	_inst_5 : add_comm_group M₂,	_inst_6 : module R₂ M₂,	τ₁₂ : R →+* R₂,	_inst_7 : ring_hom_surjective τ₁₂,	f : M →ₛₗ[τ₁₂] M₂,	s : set M₂,	h₀ : s.nonempty,	h₁ : s ⊆ ↑(f.range),	y : M₂ := classical.some h₀,	hy : y ∈ s	⊢ f.ker ≤ submodule.span R (⇑f ⁻¹' s)
R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	R₂ : Type u_3,	M₂ : Type u_4,	_inst_4 : ring R₂,	_inst_5 : add_comm_group M₂,	_inst_6 : module R₂ M₂,	τ₁₂ : R →+* R₂,	_inst_7 : ring_hom_surjective τ₁₂,	f : M →ₛₗ[τ₁₂] M₂,	s : set M₂,	h₀ : s.nonempty,	h₁ : s ⊆ ↑(f.range),	y : M₂ := classical.some h₀,	hy : {y} ⊆ s	⊢ ⇑f ⁻¹' {y} ⊆ ↑(submodule.span R (⇑f ⁻¹' s))
R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	R₂ : Type u_3,	M₂ : Type u_4,	_inst_4 : ring R₂,	_inst_5 : add_comm_group M₂,	_inst_6 : module R₂ M₂,	τ₁₂ : R →+* R₂,	_inst_7 : ring_hom_surjective τ₁₂,	f : M →ₛₗ[τ₁₂] M₂,	s : set M₂,	h₀ : s.nonempty,	h₁ : s ⊆ ↑(f.range)	⊢ f.ker ≤ submodule.span R (⇑f ⁻¹' s)		R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	R₂ : Type u_3,	M₂ : Type u_4,	_inst_4 : ring R₂,	_inst_5 : add_comm_group M₂,	_inst_6 : module R₂ M₂,	τ₁₂ : R →+* R₂,	_inst_7 : ring_hom_surjective τ₁₂,	f : M →ₛₗ[τ₁₂] M₂,	s : set M₂,	h₀ : s.nonempty,	h₁ : s ⊆ ↑(f.range),	hk : f.ker ≤ submodule.span R (⇑f ⁻¹' s)	⊢ submodule.comap f (submodule.span R₂ s) ≤ submodule.span R (⇑f ⁻¹' s)
R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	R₂ : Type u_3,	M₂ : Type u_4,	_inst_4 : ring R₂,	_inst_5 : add_comm_group M₂,	_inst_6 : module R₂ M₂,	τ₁₂ : R →+* R₂,	_inst_7 : ring_hom_surjective τ₁₂,	f : M →ₛₗ[τ₁₂] M₂,	s : set M₂,	h₀ : s.nonempty,	h₁ : s ⊆ ↑(f.range),	hk : submodule.span R (⇑f ⁻¹' s) = submodule.span R (⇑f ⁻¹' s) ⊔ f.ker	⊢ submodule.comap f (submodule.span R₂ s) ≤ submodule.span R (⇑f ⁻¹' s)
R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	R₂ : Type u_3,	M₂ : Type u_4,	_inst_4 : ring R₂,	_inst_5 : add_comm_group M₂,	_inst_6 : module R₂ M₂,	τ₁₂ : R →+* R₂,	_inst_7 : ring_hom_surjective τ₁₂,	f : M →ₛₗ[τ₁₂] M₂,	s : set M₂,	h₀ : s.nonempty,	h₁ : s ⊆ ↑(f.range),	hk : f.ker ≤ submodule.span R (⇑f ⁻¹' s)	⊢ submodule.comap f (submodule.span R₂ s) ≤ submodule.span R (⇑f ⁻¹' s)
R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	R₂ : Type u_3,	M₂ : Type u_4,	_inst_4 : ring R₂,	_inst_5 : add_comm_group M₂,	_inst_6 : module R₂ M₂,	τ₁₂ : R →+* R₂,	_inst_7 : ring_hom_surjective τ₁₂,	f : M →ₛₗ[τ₁₂] M₂,	s : set M₂,	h₀ : s.nonempty,	hk : submodule.span R (⇑f ⁻¹' s) = submodule.span R (⇑f ⁻¹' s) ⊔ f.ker,	h₁ : s ⊆ set.range ⇑f	⊢ submodule.comap f (submodule.span R₂ s) ≤ submodule.span R (⇑f ⁻¹' s)
R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	R₂ : Type u_3,	M₂ : Type u_4,	_inst_4 : ring R₂,	_inst_5 : add_comm_group M₂,	_inst_6 : module R₂ M₂,	τ₁₂ : R →+* R₂,	_inst_7 : ring_hom_surjective τ₁₂,	f : M →ₛₗ[τ₁₂] M₂,	s : set M₂,	h₀ : s.nonempty,	hk : submodule.span R (⇑f ⁻¹' s) = submodule.span R (⇑f ⁻¹' s) ⊔ f.ker,	h₁ : s ⊆ set.range ⇑f	⊢ f.range ⊓ submodule.span R₂ s ≤ submodule.span R₂ s
R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	p : submodule R M,	a : p.quotient,	a b : M,	h : setoid.r a b	⊢ -a - -b ∈ p
R : Type u_1,	_inst_1 : comm_semiring R,	M : Type u_2,	_inst_2 : add_comm_monoid M,	_inst_3 : module R M,	x : R	⊢ ⇑tensor_algebra.algebra_map_inv (⇑(algebra_map R (tensor_algebra R M)) x) = x
R : Type u_1,	_inst_1 : comm_semiring R,	M : Type u_4,	N : Type u_5,	P : Type u_6,	Q : Type u_7,	_inst_4 : add_comm_monoid M,	_inst_5 : add_comm_monoid N,	_inst_6 : add_comm_monoid P,	_inst_7 : add_comm_monoid Q,	_inst_9 : module R M,	_inst_10 : module R N,	_inst_11 : module R P,	_inst_12 : module R Q,	f : M →ₗ[R] P,	g : N →ₗ[R] Q	⊢ (tensor_product.map f g).range = submodule.span R {t : P ⊗[R] Q | ∃ (m : M) (n : N), ⇑f m ⊗ₜ[R] ⇑g n = t}
R : Type u_1,	_inst_1 : comm_semiring R,	M : Type u_4,	N : Type u_5,	P : Type u_6,	Q : Type u_7,	_inst_4 : add_comm_monoid M,	_inst_5 : add_comm_monoid N,	_inst_6 : add_comm_monoid P,	_inst_7 : add_comm_monoid Q,	_inst_9 : module R M,	_inst_10 : module R N,	_inst_11 : module R P,	_inst_12 : module R Q,	f : M →ₗ[R] P,	g : N →ₗ[R] Q	⊢ ⇑(tensor_product.map f g) '' {t : M ⊗[R] N | ∃ (m : M) (n : N), m ⊗ₜ[R] n = t} = {t : P ⊗[R] Q | ∃ (m : M) (n : N), ⇑f m ⊗ₜ[R] ⇑g n = t}
R : Type u_1,	_inst_1 : comm_semiring R,	M : Type u_4,	N : Type u_5,	P : Type u_6,	Q : Type u_7,	_inst_4 : add_comm_monoid M,	_inst_5 : add_comm_monoid N,	_inst_6 : add_comm_monoid P,	_inst_7 : add_comm_monoid Q,	_inst_9 : module R M,	_inst_10 : module R N,	_inst_11 : module R P,	_inst_12 : module R Q,	f : M →ₗ[R] P,	g : N →ₗ[R] Q	⊢ submodule.span R (⇑(tensor_product.map f g) '' {t : M ⊗[R] N | ∃ (m : M) (n : N), m ⊗ₜ[R] n = t}) = submodule.span R {t : P ⊗[R] Q | ∃ (m : M) (n : N), ⇑f m ⊗ₜ[R] ⇑g n = t}
R : Type u_1,	_inst_1 : comm_semiring R,	M : Type u_4,	N : Type u_5,	P : Type u_6,	Q : Type u_7,	_inst_4 : add_comm_monoid M,	_inst_5 : add_comm_monoid N,	_inst_6 : add_comm_monoid P,	_inst_7 : add_comm_monoid Q,	_inst_9 : module R M,	_inst_10 : module R N,	_inst_11 : module R P,	_inst_12 : module R Q,	f : M →ₗ[R] P,	g : N →ₗ[R] Q,	t : P ⊗[R] Q	⊢ t ∈ ⇑(tensor_product.map f g) '' {t : M ⊗[R] N | ∃ (m : M) (n : N), m ⊗ₜ[R] n = t} ↔ t ∈ {t : P ⊗[R] Q | ∃ (m : M) (n : N), ⇑f m ⊗ₜ[R] ⇑g n = t}
R : Type u_1,	_inst_1 : comm_semiring R,	M : Type u_4,	N : Type u_5,	P : Type u_6,	Q : Type u_7,	_inst_4 : add_comm_monoid M,	_inst_5 : add_comm_monoid N,	_inst_6 : add_comm_monoid P,	_inst_7 : add_comm_monoid Q,	_inst_9 : module R M,	_inst_10 : module R N,	_inst_11 : module R P,	_inst_12 : module R Q,	f : M →ₗ[R] P,	g : N →ₗ[R] Q,	m : M,	n : N	⊢ ⇑(tensor_product.map f g) (m ⊗ₜ[R] n) ∈ {t : P ⊗[R] Q | ∃ (m : M) (n : N), ⇑f m ⊗ₜ[R] ⇑g n = t}
R : Type u_1,	_inst_1 : comm_semiring R,	M : Type u_4,	N : Type u_5,	P : Type u_6,	Q : Type u_7,	_inst_4 : add_comm_monoid M,	_inst_5 : add_comm_monoid N,	_inst_6 : add_comm_monoid P,	_inst_7 : add_comm_monoid Q,	_inst_9 : module R M,	_inst_10 : module R N,	_inst_11 : module R P,	_inst_12 : module R Q,	f : M →ₗ[R] P,	g : N →ₗ[R] Q,	m : M,	n : N	⊢ ⇑f m ⊗ₜ[R] ⇑g n = ⇑(tensor_product.map f g) (m ⊗ₜ[R] n)
R : Type u_1,	_inst_1 : comm_semiring R,	M : Type u_4,	N : Type u_5,	P : Type u_6,	Q : Type u_7,	_inst_4 : add_comm_monoid M,	_inst_5 : add_comm_monoid N,	_inst_6 : add_comm_monoid P,	_inst_7 : add_comm_monoid Q,	_inst_9 : module R M,	_inst_10 : module R N,	_inst_11 : module R P,	_inst_12 : module R Q,	f : M →ₗ[R] P,	g : N →ₗ[R] Q,	t : P ⊗[R] Q	⊢ t ∈ ⇑(tensor_product.map f g) '' {t : M ⊗[R] N | ∃ (m : M) (n : N), m ⊗ₜ[R] n = t} → t ∈ {t : P ⊗[R] Q | ∃ (m : M) (n : N), ⇑f m ⊗ₜ[R] ⇑g n = t}
R : Type u_1,	_inst_1 : comm_semiring R,	M : Type u_4,	N : Type u_5,	P : Type u_6,	Q : Type u_7,	_inst_4 : add_comm_monoid M,	_inst_5 : add_comm_monoid N,	_inst_6 : add_comm_monoid P,	_inst_7 : add_comm_monoid Q,	_inst_9 : module R M,	_inst_10 : module R N,	_inst_11 : module R P,	_inst_12 : module R Q,	f : M →ₗ[R] P,	g : N →ₗ[R] Q,	t : P ⊗[R] Q	⊢ t ∈ ⇑(tensor_product.map f g) '' {t : M ⊗[R] N | ∃ (m : M) (n : N), m ⊗ₜ[R] n = t} → t ∈ {t : P ⊗[R] Q | ∃ (m : M) (n : N), ⇑f m ⊗ₜ[R] ⇑g n = t}		R : Type u_1,	_inst_1 : comm_semiring R,	M : Type u_4,	N : Type u_5,	P : Type u_6,	Q : Type u_7,	_inst_4 : add_comm_monoid M,	_inst_5 : add_comm_monoid N,	_inst_6 : add_comm_monoid P,	_inst_7 : add_comm_monoid Q,	_inst_9 : module R M,	_inst_10 : module R N,	_inst_11 : module R P,	_inst_12 : module R Q,	f : M →ₗ[R] P,	g : N →ₗ[R] Q,	t : P ⊗[R] Q	⊢ t ∈ {t : P ⊗[R] Q | ∃ (m : M) (n : N), ⇑f m ⊗ₜ[R] ⇑g n = t} → t ∈ ⇑(tensor_product.map f g) '' {t : M ⊗[R] N | ∃ (m : M) (n : N), m ⊗ₜ[R] n = t}
R : Type u_1,	_inst_1 : comm_semiring R,	M : Type u_4,	N : Type u_5,	P : Type u_6,	Q : Type u_7,	_inst_4 : add_comm_monoid M,	_inst_5 : add_comm_monoid N,	_inst_6 : add_comm_monoid P,	_inst_7 : add_comm_monoid Q,	_inst_9 : module R M,	_inst_10 : module R N,	_inst_11 : module R P,	_inst_12 : module R Q,	f : M →ₗ[R] P,	g : N →ₗ[R] Q,	m : M,	n : N	⊢ ⇑f m ⊗ₜ[R] ⇑g n ∈ ⇑(tensor_product.map f g) '' {t : M ⊗[R] N | ∃ (m : M) (n : N), m ⊗ₜ[R] n = t}
R : Type u_1,	_inst_1 : comm_semiring R,	M : Type u_4,	N : Type u_5,	P : Type u_6,	Q : Type u_7,	_inst_4 : add_comm_monoid M,	_inst_5 : add_comm_monoid N,	_inst_6 : add_comm_monoid P,	_inst_7 : add_comm_monoid Q,	_inst_9 : module R M,	_inst_10 : module R N,	_inst_11 : module R P,	_inst_12 : module R Q,	f : M →ₗ[R] P,	g : N →ₗ[R] Q,	m : M,	n : N	⊢ ⇑(tensor_product.map f g) (m ⊗ₜ[R] n) = ⇑f m ⊗ₜ[R] ⇑g n
R : Type u_1,	_inst_1 : comm_semiring R,	M : Type u_4,	N : Type u_5,	P : Type u_6,	Q : Type u_7,	_inst_4 : add_comm_monoid M,	_inst_5 : add_comm_monoid N,	_inst_6 : add_comm_monoid P,	_inst_7 : add_comm_monoid Q,	_inst_9 : module R M,	_inst_10 : module R N,	_inst_11 : module R P,	_inst_12 : module R Q,	f : M →ₗ[R] P,	g : N →ₗ[R] Q,	t : P ⊗[R] Q	⊢ t ∈ {t : P ⊗[R] Q | ∃ (m : M) (n : N), ⇑f m ⊗ₜ[R] ⇑g n = t} → t ∈ ⇑(tensor_product.map f g) '' {t : M ⊗[R] N | ∃ (m : M) (n : N), m ⊗ₜ[R] n = t}
α : Sort u_1,	p : Prop,	_inst_1 : decidable p,	a b c : α	⊢ ite p a b = c ↔ p ∧ a = c ∨ ¬p ∧ b = c
α : Sort u_1,	p : Prop,	_inst_1 : decidable p,	a b c : α,	h : p	⊢ ite p a b = c ↔ p ∧ a = c ∨ ¬p ∧ b = c
α : Sort u_1,	p : Prop,	_inst_1 : decidable p,	a b c : α,	h : ¬p	⊢ ite p a b = c ↔ p ∧ a = c ∨ ¬p ∧ b = c
α : Sort u_1,	p : Prop,	_inst_1 : decidable p,	a b c : α	⊢ ite p a b = c ↔ p ∧ a = c ∨ ¬p ∧ b = c
α : Sort u_1,	p : Prop,	_inst_1 : decidable p,	a b : α	⊢ ite p a b = b ↔ p → a = b
α : Sort u_1,	p : Prop,	_inst_1 : decidable p,	a b : α,	h : p	⊢ ite p a b = b ↔ p → a = b
α : Sort u_1,	p : Prop,	_inst_1 : decidable p,	a b : α,	h : ¬p	⊢ ite p a b = b ↔ p → a = b
α : Sort u_1,	p : Prop,	_inst_1 : decidable p,	a b : α	⊢ ite p a b = b ↔ p → a = b
P : pempty → Prop,	h : ∃ (x : pempty), P x	⊢ false
P : pempty → Prop,	w : pempty,	h_h : P w	⊢ false
α : Sort u_1,	p : α → Prop,	a' : α	⊢ (∃ (a : α), p a ∧ a' = a) ↔ p a'
α : Sort u_1,	β : Sort u_2,	f g : α ↪ β,	h : f = g,	_x : α	⊢ ⇑f _x = ⇑g _x
α : Sort u_1,	β : Sort u_2,	h : nonempty α,	_inst_1 : is_empty β	⊢ is_empty (α → β)
α : Type u_1,	β : Type u_2,	_inst_1 : nontrivial β,	f : α → β,	hf : function.surjective f	⊢ nontrivial α
α : Type u_1,	β : Type u_2,	_inst_1 : nontrivial β,	f : α → β,	hf : function.surjective f,	x y : β,	h : x ≠ y	⊢ nontrivial α
α : Type u_1,	β : Type u_2,	_inst_1 : nontrivial β,	f : α → β,	hf : function.surjective f,	x y : β,	h : x ≠ y,	x' : α,	hx' : f x' = x	⊢ nontrivial α
α : Type u_1,	β : Type u_2,	_inst_1 : nontrivial β,	f : α → β,	hf : function.surjective f,	x y : β,	h : x ≠ y,	x' : α,	hx' : f x' = x,	y' : α,	hy' : f y' = y	⊢ x' ≠ y'
α : Type u_1,	β : Type u_2,	_inst_1 : nontrivial β,	f : α → β,	hf : function.surjective f,	x y : β,	x' : α,	hx' : f x' = x,	y' : α,	hy' : f y' = y,	h : x' = y'	⊢ x = y
α : Type u_1,	β : Type u_2,	_inst_1 : nontrivial β,	f : α → β,	hf : function.surjective f,	x y : β,	h : x ≠ y,	x' : α,	hx' : f x' = x,	y' : α,	hy' : f y' = y	⊢ nontrivial α
α : Type u_1,	β : Type u_2,	_inst_1 : nontrivial β,	f : α → β,	hf : function.surjective f,	x y : β,	h : x ≠ y,	x' : α,	hx' : f x' = x,	y' : α,	hy' : f y' = y,	this : x' ≠ y'	⊢ nontrivial α
α : Type u_1,	_inst_1 : nontrivial α,	x : α	⊢ ∃ (y : α), y ≠ x
α : Type u_1,	_inst_1 : nontrivial α,	x : α,	_inst : Π (a : Prop), decidable a	⊢ ∃ (y : α), y ≠ x
α : Type u_1,	_inst_1 : nontrivial α,	x : α	⊢ ∃ (y : α), y ≠ x
α : Type u_1,	r : α → α → Prop,	a b c : α,	hab : relation.refl_trans_gen r a b,	hbc : r b c	⊢ relation.trans_gen r a c
α : Type u_1,	r : α → α → Prop,	a b c : α,	hac : r a c	⊢ relation.trans_gen r a c
α : Type u_1,	r : α → α → Prop,	a b c : α,	hbc : r a c	⊢ relation.trans_gen r a c		case relation.refl_trans_gen.tail	α : Type u_1,	r : α → α → Prop,	a b hab_b hab_c : α,	hab_ᾰ : relation.refl_trans_gen r a hab_b,	hab_ᾰ_1 : r hab_b hab_c,	hab_ih : ∀ {c : α}, r hab_b c → relation.trans_gen r a c,	c : α,	hbc : r hab_c c	⊢ relation.trans_gen r a c
α : Type u_1,	r : α → α → Prop,	a b hab_b hab_c : α,	hab_ᾰ : relation.refl_trans_gen r a hab_b,	hab_ᾰ_1 : r hab_b hab_c,	hab_ih : ∀ {c : α}, r hab_b c → relation.trans_gen r a c,	c : α,	hbc : r hab_c c	⊢ relation.trans_gen r a c
α : Type u_1,	r : α → α → Prop,	a b d b : α,	hab : relation.refl_trans_gen r a d,	hdb : r d b,	IH : ∀ {c : α}, r d c → relation.trans_gen r a c,	c : α,	hbc : r b c	⊢ relation.trans_gen r a c
α : Type u_1,	β : Type u_2,	r : α → α → Prop,	p : β → β → Prop,	a b : α,	f : α → β,	h : ∀ (a b : α), r a b → relation.refl_trans_gen p (f a) (f b),	hab : relation.refl_trans_gen r a b	⊢ relation.refl_trans_gen p (f a) (f b)
α : Sort u,	subsingleton_unique' : ∀ (h₁ h₂ : unique α), h₁ = h₂,	x : α,	h : ∀ (a : α), a = inhabited.default α,	y : α,	_x : ∀ (a : α), a = inhabited.default α	⊢ {to_inhabited := {default := x}, uniq := h} = {to_inhabited := {default := y}, uniq := _x}
α : Sort u,	subsingleton_unique' : ∀ (h₁ h₂ : unique α), h₁ = h₂,	x : α,	h : ∀ (a : α), a = inhabited.default α,	y : α,	_x : ∀ (a : α), a = inhabited.default α	⊢ {to_inhabited := {default := x}, uniq := h} = {to_inhabited := {default := y}, uniq := _x}
α : Sort u,	subsingleton_unique' : ∀ (h₁ h₂ : unique α), h₁ = h₂,	x : α,	h : ∀ (a : α), a = inhabited.default α,	y : α,	_x : ∀ (a : α), a = inhabited.default α	⊢ x = y
α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : topological_space.second_countable_topology α,	_inst_3 : linear_order α,	_inst_4 : order_topology α	⊢ topological_space.second_countable_topology α
β : Type u_4,	E : Type u_5,	_inst_3 : normed_group E,	_inst_4 : normed_space ℝ E,	_inst_5 : measurable_space E,	_inst_6 : topological_space.second_countable_topology E,	_inst_7 : borel_space E,	_inst_8 : complete_space E,	ι : Type u_1,	_inst_9 : unique ι,	_inst_10 : measure_theory.measure_space β,	f : (ι → β) → E,	s : set (ι → β)	⊢ ∫ (y : ι → β) in s, f y = ∫ (x : β) in function.const ι ⁻¹' s, f (λ (_x : ι), x)
α : Type u_1,	β : Type u_3,	_inst_1 : measurable_space α,	_inst_3 : measurable_space β,	μ : measure_theory.measure α,	ν : measure_theory.measure β,	_inst_8 : measure_theory.sigma_finite ν	⊢ ⇑(measure_theory.measure.map prod.fst) (μ.prod ν) ≪ μ
α : Type u_1,	β : Type u_3,	_inst_1 : measurable_space α,	_inst_3 : measurable_space β,	μ : measure_theory.measure α,	ν : measure_theory.measure β,	_inst_8 : measure_theory.sigma_finite ν,	s : set α,	hs : measurable_set s,	h2s : ⇑μ s = 0	⊢ ⇑(⇑(measure_theory.measure.map prod.fst) (μ.prod ν)) s = 0
α : Type u_1,	β : Type u_3,	_inst_1 : measurable_space α,	_inst_3 : measurable_space β,	μ : measure_theory.measure α,	ν : measure_theory.measure β,	_inst_8 : measure_theory.sigma_finite ν,	s : set α,	hs : measurable_set s,	h2s : ⇑μ s = 0	⊢ ⇑μ s * ⇑ν set.univ = 0
α : Type u_1,	_inst_1 : measurable_space α,	j : measure_theory.jordan_decomposition α,	r : ℝ≥0	⊢ dite (0 ≤ ↑r) (λ (hr : 0 ≤ ↑r), ↑r.to_nnreal • j) (λ (hr : ¬0 ≤ ↑r), -((-↑r).to_nnreal • j)) = r • j
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x)	⊢ ∃ (s : set α), measurable_set s ∧ (∀ (t : set α), measurable_set t → t ⊆ s → ⇑ν t ≤ ⇑μ t) ∧ ∀ (t : set α), measurable_set t → t ⊆ sᶜ → ⇑μ t ≤ ⇑ν t
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n)	⊢ ∃ (s : set α), measurable_set s ∧ (∀ (t : set α), measurable_set t → t ⊆ s → ⇑ν t ≤ ⇑μ t) ∧ ∀ (t : set α), measurable_set t → t ⊆ sᶜ → ⇑μ t ≤ ⇑ν t
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n)	⊢ ∃ (s : set α), measurable_set s ∧ (∀ (t : set α), measurable_set t → t ⊆ s → ⇑ν t ≤ ⇑μ t) ∧ ∀ (t : set α), measurable_set t → t ⊆ sᶜ → ⇑μ t ≤ ⇑ν t
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e	⊢ ∃ (s : set α), measurable_set s ∧ (∀ (t : set α), measurable_set t → t ⊆ s → ⇑ν t ≤ ⇑μ t) ∧ ∀ (t : set α), measurable_set t → t ⊆ sᶜ → ⇑μ t ≤ ⇑ν t
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e	⊢ ∀ (n m : ℕ), measurable_set (f n m)
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	n m : ℕ	⊢ measurable_set (f n m)
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	n m : ℕ	⊢ measurable_set (⨅ (a : ℕ) (H : a ∈ finset.Ico n (m + 1)), e a)
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e	⊢ ∀ (n m : ℕ), measurable_set (f n m)		α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m)	⊢ ∃ (s : set α), measurable_set s ∧ (∀ (t : set α), measurable_set t → t ⊆ s → ⇑ν t ≤ ⇑μ t) ∧ ∀ (t : set α), measurable_set t → t ⊆ sᶜ → ⇑μ t ≤ ⇑ν t
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m)	⊢ ∃ (s : set α), measurable_set s ∧ (∀ (t : set α), measurable_set t → t ⊆ s → ⇑ν t ≤ ⇑μ t) ∧ ∀ (t : set α), measurable_set t → t ⊆ sᶜ → ⇑μ t ≤ ⇑ν t
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m)	⊢ ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	a b c d : ℕ,	hab : a ≤ b,	hcd : c ≤ d	⊢ f a d ⊆ f b c
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	a b c d : ℕ,	hab : a ≤ b,	hcd : c ≤ d	⊢ (finset.Ico a (d + 1)).inf e ⊆ (finset.Ico b (c + 1)).inf e
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	a b c d : ℕ,	hab : a ≤ b,	hcd : c ≤ d	⊢ (⨅ (a_1 : ℕ) (H : a_1 ∈ finset.Ico a (d + 1)), e a_1) ⊆ ⨅ (a : ℕ) (H : a ∈ finset.Ico b (c + 1)), e a
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	a b c d : ℕ,	hab : a ≤ b,	hcd : c ≤ d	⊢ (λ (a : ℕ), a ∈ (finset.Ico b (c + 1)).val) ⊆ λ (a_1 : ℕ), a_1 ∈ (finset.Ico a (d + 1)).val
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	a b c d : ℕ,	hab : a ≤ b,	hcd : c ≤ d	⊢ (λ (a : ℕ), b ≤ a ∧ a < c + 1) ⊆ λ (a_1 : ℕ), a ≤ a_1 ∧ a_1 < d + 1
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	a b c d : ℕ,	hab : a ≤ b,	hcd : c ≤ d,	j : ℕ,	hbj : b ≤ j,	hjc : j < c + 1	⊢ j ∈ λ (a_1 : ℕ), a ≤ a_1 ∧ a_1 < d + 1
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m)	⊢ ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c		α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c	⊢ ∃ (s : set α), measurable_set s ∧ (∀ (t : set α), measurable_set t → t ⊆ s → ⇑ν t ≤ ⇑μ t) ∧ ∀ (t : set α), measurable_set t → t ⊆ sᶜ → ⇑μ t ≤ ⇑ν t
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c	⊢ ∃ (s : set α), measurable_set s ∧ (∀ (t : set α), measurable_set t → t ⊆ s → ⇑ν t ≤ ⇑μ t) ∧ ∀ (t : set α), measurable_set t → t ⊆ sᶜ → ⇑μ t ≤ ⇑ν t
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c	⊢ ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1)
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	n m : ℕ,	hnm : n ≤ m	⊢ f n (m + 1) = f n m ∩ e (m + 1)
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	n m : ℕ,	hnm : n ≤ m,	this : n ≤ m + 1	⊢ f n (m + 1) = f n m ∩ e (m + 1)
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	n m : ℕ,	hnm : n ≤ m,	this : n ≤ m + 1	⊢ (finset.Ico n (m + 1 + 1)).inf e = (finset.Ico n (m + 1)).inf e ∩ e (m + 1)
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c	⊢ ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1)		α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1)	⊢ ∃ (s : set α), measurable_set s ∧ (∀ (t : set α), measurable_set t → t ⊆ s → ⇑ν t ≤ ⇑μ t) ∧ ∀ (t : set α), measurable_set t → t ⊆ sᶜ → ⇑μ t ≤ ⇑ν t
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	n m : ℕ,	hnm : n ≤ m,	this : n ≤ m + 1	⊢ e (m + 1) ⊓ (finset.Ico n (m + 1)).inf e = e (m + 1) ∩ (finset.Ico n (m + 1)).inf e
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1)	⊢ ∃ (s : set α), measurable_set s ∧ (∀ (t : set α), measurable_set t → t ⊆ s → ⇑ν t ≤ ⇑μ t) ∧ ∀ (t : set α), measurable_set t → t ⊆ sᶜ → ⇑μ t ≤ ⇑ν t
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1)	⊢ ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n)
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	n m : ℕ,	h : m ≤ n	⊢ γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n)
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	n m : ℕ,	h : m ≤ n	⊢ γ - 2 * (1 / 2) ^ m + (1 / 2) ^ m ≤ d (f m m)
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	n m : ℕ,	h : m ≤ n,	this : γ - (1 / 2) ^ m < d (e m)	⊢ γ - 2 * (1 / 2) ^ m + (1 / 2) ^ m ≤ d (f m m)
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	n m : ℕ,	h : m ≤ n,	this : γ - (1 / 2) ^ m < d (e m)	⊢ γ - 2 * (1 / 2) ^ m + (1 / 2) ^ m ≤ d ((finset.Ico m (m + 1)).inf e)
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	n m : ℕ,	h : m ≤ n	⊢ γ - 2 * (1 / 2) ^ m + (1 / 2) ^ m ≤ d (f m m)		α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	n m : ℕ,	h : m ≤ n	⊢ ∀ (n : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n) → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ (n + 1) ≤ d (f m (n + 1))
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	n m : ℕ,	h : m ≤ n,	this : γ - (1 / 2) ^ m < d (e m)	⊢ γ - 2 * (1 / 2) ^ m + (1 / 2) ^ m ≤ d (e m)
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	n m : ℕ,	h : m ≤ n	⊢ ∀ (n : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n) → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ (n + 1) ≤ d (f m (n + 1))
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	n m : ℕ,	h : m ≤ n,	n : ℕ,	hmn : m ≤ n,	ih : γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n)	⊢ γ - 2 * (1 / 2) ^ m + (1 / 2) ^ (n + 1) ≤ d (f m (n + 1))
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	n m : ℕ,	h : m ≤ n,	n : ℕ,	hmn : m ≤ n,	ih : γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n)	⊢ γ + (γ - 2 * (1 / 2) ^ m + (1 / 2) ^ (n + 1)) ≤ γ + d (f m (n + 1))
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	n m : ℕ,	h : m ≤ n,	n : ℕ,	hmn : m ≤ n,	ih : γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n)	⊢ γ + (γ - 2 * (1 / 2) ^ m + (1 / 2) ^ (n + 1)) ≤ γ + (γ - 2 * (1 / 2) ^ m + ((1 / 2) ^ n - (1 / 2) ^ (n + 1)))
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	n m : ℕ,	h : m ≤ n,	n : ℕ,	hmn : m ≤ n,	ih : γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n)	⊢ (1 / 2) ^ (n + 1) ≤ (1 / 2) ^ n - (1 / 2) ^ (n + 1)
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	n m : ℕ,	h : m ≤ n,	n : ℕ,	hmn : m ≤ n,	ih : γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n)	⊢ (1 / 2) ^ n * (1 / 2) + (1 / 2) ^ n * (1 / 2) ≤ (1 / 2) ^ n
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	n m : ℕ,	h : m ≤ n,	n : ℕ,	hmn : m ≤ n,	ih : γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n)	⊢ γ + (γ - 2 * (1 / 2) ^ m + ((1 / 2) ^ n - (1 / 2) ^ (n + 1))) = γ - (1 / 2) ^ (n + 1) + (γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n)
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	n m : ℕ,	h : m ≤ n,	n : ℕ,	hmn : m ≤ n,	ih : γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n)	⊢ γ + (γ - 2 * (1 / 2) ^ m + ((1 / 2) ^ n - (1 / 2) ^ (n + 1))) = γ - (1 / 2) ^ (n + 1) + (γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n)
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	n m : ℕ,	h : m ≤ n,	n : ℕ,	hmn : m ≤ n,	ih : γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n)	⊢ γ + (γ + -(2 * (1 / 2) ^ m) + ((1 / 2) ^ n + -(1 / 2) ^ (n + 1))) = γ + -(1 / 2) ^ (n + 1) + (γ + -(2 * (1 / 2) ^ m) + (1 / 2) ^ n)
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	n m : ℕ,	h : m ≤ n,	n : ℕ,	hmn : m ≤ n,	ih : γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n)	⊢ d (e (n + 1)) + d (f m n) ≤ d (e (n + 1)) + d (f m n \ e (n + 1)) + d (f m (n + 1))
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	n m : ℕ,	h : m ≤ n,	n : ℕ,	hmn : m ≤ n,	ih : γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n)	⊢ d (e (n + 1)) + d (f m n \ e (n + 1)) + d (f m (n + 1)) = d (e (n + 1) ∪ f m n) + d (f m (n + 1))
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	n m : ℕ,	h : m ≤ n,	n : ℕ,	hmn : m ≤ n,	ih : γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n)	⊢ d (e (n + 1)) + d (f m n \ e (n + 1)) + d (f m (n + 1)) = d (f m n \ e (n + 1)) + d (e (n + 1)) + d (f m (n + 1))		α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	n m : ℕ,	h : m ≤ n,	n : ℕ,	hmn : m ≤ n,	ih : γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n)	⊢ measurable_set (e (n + 1) ∪ f m n)		α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	n m : ℕ,	h : m ≤ n,	n : ℕ,	hmn : m ≤ n,	ih : γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n)	⊢ measurable_set (e (n + 1))
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	n m : ℕ,	h : m ≤ n,	n : ℕ,	hmn : m ≤ n,	ih : γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n)	⊢ measurable_set (e (n + 1) ∪ f m n)		α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	n m : ℕ,	h : m ≤ n,	n : ℕ,	hmn : m ≤ n,	ih : γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n)	⊢ measurable_set (e (n + 1))
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	n m : ℕ,	h : m ≤ n,	n : ℕ,	hmn : m ≤ n,	ih : γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n)	⊢ measurable_set (e (n + 1))
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	n m : ℕ,	h : m ≤ n,	n : ℕ,	hmn : m ≤ n,	ih : γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n)	⊢ γ + (γ - 2 * (1 / 2) ^ m + (1 / 2) ^ (n + 1)) ≤ γ + d (f m (n + 1))		α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	n m : ℕ,	h : m ≤ n,	n : ℕ,	hmn : m ≤ n,	ih : γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	this : γ + (γ - 2 * (1 / 2) ^ m + (1 / 2) ^ (n + 1)) ≤ γ + d (f m (n + 1))	⊢ γ - 2 * (1 / 2) ^ m + (1 / 2) ^ (n + 1) ≤ d (f m (n + 1))
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1)	⊢ ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n)		α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n)	⊢ ∃ (s : set α), measurable_set s ∧ (∀ (t : set α), measurable_set t → t ⊆ s → ⇑ν t ≤ ⇑μ t) ∧ ∀ (t : set α), measurable_set t → t ⊆ sᶜ → ⇑μ t ≤ ⇑ν t
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	n m : ℕ,	h : m ≤ n,	n : ℕ,	hmn : m ≤ n,	ih : γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	this : γ + (γ - 2 * (1 / 2) ^ m + (1 / 2) ^ (n + 1)) ≤ γ + d (f m (n + 1))	⊢ γ - 2 * (1 / 2) ^ m + (1 / 2) ^ (n + 1) ≤ d (f m (n + 1))
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n)	⊢ ∃ (s : set α), measurable_set s ∧ (∀ (t : set α), measurable_set t → t ⊆ s → ⇑ν t ≤ ⇑μ t) ∧ ∀ (t : set α), measurable_set t → t ⊆ sᶜ → ⇑μ t ≤ ⇑ν t
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n	⊢ ∃ (s : set α), measurable_set s ∧ (∀ (t : set α), measurable_set t → t ⊆ s → ⇑ν t ≤ ⇑μ t) ∧ ∀ (t : set α), measurable_set t → t ⊆ sᶜ → ⇑μ t ≤ ⇑ν t
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n	⊢ γ ≤ d s
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	this : filter.tendsto (λ (m : ℕ), γ - 2 * (1 / 2) ^ m) filter.at_top (𝓝 (γ - 2 * 0))	⊢ filter.tendsto (λ (m : ℕ), γ - 2 * (1 / 2) ^ m) filter.at_top (𝓝 γ)
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n	⊢ filter.tendsto (λ (m : ℕ), γ - 2 * (1 / 2) ^ m) filter.at_top (𝓝 γ)
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	this : filter.tendsto (λ (m : ℕ), γ - 2 * (1 / 2) ^ m) filter.at_top (𝓝 (γ - 2 * 0))	⊢ filter.tendsto (λ (m : ℕ), γ - 2 * (1 / 2) ^ m) filter.at_top (𝓝 γ)		α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n	⊢ filter.tendsto (λ (m : ℕ), γ - 2 * (1 / 2) ^ m) filter.at_top (𝓝 (γ - 2 * 0))
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n	⊢ filter.tendsto (λ (m : ℕ), γ - 2 * (1 / 2) ^ m) filter.at_top (𝓝 (γ - 2 * 0))
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n	⊢ filter.tendsto (λ (m : ℕ), γ - 2 * (1 / 2) ^ m) filter.at_top (𝓝 γ)		α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	hγ : filter.tendsto (λ (m : ℕ), γ - 2 * (1 / 2) ^ m) filter.at_top (𝓝 γ)	⊢ γ ≤ d s
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	hγ : filter.tendsto (λ (m : ℕ), γ - 2 * (1 / 2) ^ m) filter.at_top (𝓝 γ)	⊢ γ ≤ d s
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	hγ : filter.tendsto (λ (m : ℕ), γ - 2 * (1 / 2) ^ m) filter.at_top (𝓝 γ)	⊢ filter.tendsto (λ (m : ℕ), d (⋂ (n : ℕ), f m n)) filter.at_top (𝓝 (d (⋃ (m : ℕ), ⋂ (n : ℕ), f m n)))
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	hγ : filter.tendsto (λ (m : ℕ), γ - 2 * (1 / 2) ^ m) filter.at_top (𝓝 γ),	n : ℕ	⊢ measurable_set (⋂ (n_1 : ℕ), f n n_1)
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	hγ : filter.tendsto (λ (m : ℕ), γ - 2 * (1 / 2) ^ m) filter.at_top (𝓝 γ)	⊢ ∀ (n : ℕ), measurable_set (⋂ (n_1 : ℕ), f n n_1)		α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	hγ : filter.tendsto (λ (m : ℕ), γ - 2 * (1 / 2) ^ m) filter.at_top (𝓝 γ)	⊢ monotone (λ (n : ℕ), ⋂ (n_1 : ℕ), f n n_1)
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	hγ : filter.tendsto (λ (m : ℕ), γ - 2 * (1 / 2) ^ m) filter.at_top (𝓝 γ)	⊢ ∀ (n : ℕ), measurable_set (⋂ (n_1 : ℕ), f n n_1)
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	hγ : filter.tendsto (λ (m : ℕ), γ - 2 * (1 / 2) ^ m) filter.at_top (𝓝 γ)	⊢ monotone (λ (n : ℕ), ⋂ (n_1 : ℕ), f n n_1)
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	hγ : filter.tendsto (λ (m : ℕ), γ - 2 * (1 / 2) ^ m) filter.at_top (𝓝 γ)	⊢ filter.tendsto (λ (m : ℕ), d (⋂ (n : ℕ), f m n)) filter.at_top (𝓝 (d (⋃ (m : ℕ), ⋂ (n : ℕ), f m n)))		α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	hγ : filter.tendsto (λ (m : ℕ), γ - 2 * (1 / 2) ^ m) filter.at_top (𝓝 γ),	hd : filter.tendsto (λ (m : ℕ), d (⋂ (n : ℕ), f m n)) filter.at_top (𝓝 (d (⋃ (m : ℕ), ⋂ (n : ℕ), f m n)))	⊢ γ ≤ d s
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	hγ : filter.tendsto (λ (m : ℕ), γ - 2 * (1 / 2) ^ m) filter.at_top (𝓝 γ),	hd : filter.tendsto (λ (m : ℕ), d (⋂ (n : ℕ), f m n)) filter.at_top (𝓝 (d (⋃ (m : ℕ), ⋂ (n : ℕ), f m n)))	⊢ γ ≤ d s
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	hγ : filter.tendsto (λ (m : ℕ), γ - 2 * (1 / 2) ^ m) filter.at_top (𝓝 γ),	hd : filter.tendsto (λ (m : ℕ), d (⋂ (n : ℕ), f m n)) filter.at_top (𝓝 (d (⋃ (m : ℕ), ⋂ (n : ℕ), f m n))),	m : ℕ	⊢ γ - 2 * (1 / 2) ^ m ≤ d (⋂ (n : ℕ), f m n)
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	hγ : filter.tendsto (λ (m : ℕ), γ - 2 * (1 / 2) ^ m) filter.at_top (𝓝 γ),	hd : filter.tendsto (λ (m : ℕ), d (⋂ (n : ℕ), f m n)) filter.at_top (𝓝 (d (⋃ (m : ℕ), ⋂ (n : ℕ), f m n))),	m : ℕ	⊢ filter.tendsto (λ (n : ℕ), d (f m n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), f m n)))
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	hγ : filter.tendsto (λ (m : ℕ), γ - 2 * (1 / 2) ^ m) filter.at_top (𝓝 γ),	hd : filter.tendsto (λ (m : ℕ), d (⋂ (n : ℕ), f m n)) filter.at_top (𝓝 (d (⋃ (m : ℕ), ⋂ (n : ℕ), f m n))),	m n : ℕ	⊢ measurable_set (f m n)
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	hγ : filter.tendsto (λ (m : ℕ), γ - 2 * (1 / 2) ^ m) filter.at_top (𝓝 γ),	hd : filter.tendsto (λ (m : ℕ), d (⋂ (n : ℕ), f m n)) filter.at_top (𝓝 (d (⋃ (m : ℕ), ⋂ (n : ℕ), f m n))),	m : ℕ	⊢ ∀ (n : ℕ), measurable_set (f m n)		α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	hγ : filter.tendsto (λ (m : ℕ), γ - 2 * (1 / 2) ^ m) filter.at_top (𝓝 γ),	hd : filter.tendsto (λ (m : ℕ), d (⋂ (n : ℕ), f m n)) filter.at_top (𝓝 (d (⋃ (m : ℕ), ⋂ (n : ℕ), f m n))),	m : ℕ	⊢ ∀ (n m_1 : ℕ), n ≤ m_1 → f m m_1 ⊆ f m n
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	hγ : filter.tendsto (λ (m : ℕ), γ - 2 * (1 / 2) ^ m) filter.at_top (𝓝 γ),	hd : filter.tendsto (λ (m : ℕ), d (⋂ (n : ℕ), f m n)) filter.at_top (𝓝 (d (⋃ (m : ℕ), ⋂ (n : ℕ), f m n))),	m : ℕ	⊢ ∀ (n : ℕ), measurable_set (f m n)
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	hγ : filter.tendsto (λ (m : ℕ), γ - 2 * (1 / 2) ^ m) filter.at_top (𝓝 γ),	hd : filter.tendsto (λ (m : ℕ), d (⋂ (n : ℕ), f m n)) filter.at_top (𝓝 (d (⋃ (m : ℕ), ⋂ (n : ℕ), f m n))),	m n m : ℕ,	hnm : n ≤ m	⊢ f m m ⊆ f m n
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	hγ : filter.tendsto (λ (m : ℕ), γ - 2 * (1 / 2) ^ m) filter.at_top (𝓝 γ),	hd : filter.tendsto (λ (m : ℕ), d (⋂ (n : ℕ), f m n)) filter.at_top (𝓝 (d (⋃ (m : ℕ), ⋂ (n : ℕ), f m n))),	m : ℕ	⊢ filter.tendsto (λ (n : ℕ), d (f m n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), f m n)))		α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	hγ : filter.tendsto (λ (m : ℕ), γ - 2 * (1 / 2) ^ m) filter.at_top (𝓝 γ),	hd : filter.tendsto (λ (m : ℕ), d (⋂ (n : ℕ), f m n)) filter.at_top (𝓝 (d (⋃ (m : ℕ), ⋂ (n : ℕ), f m n))),	m : ℕ,	this : filter.tendsto (λ (n : ℕ), d (f m n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), f m n)))	⊢ γ - 2 * (1 / 2) ^ m ≤ d (⋂ (n : ℕ), f m n)
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	hγ : filter.tendsto (λ (m : ℕ), γ - 2 * (1 / 2) ^ m) filter.at_top (𝓝 γ),	hd : filter.tendsto (λ (m : ℕ), d (⋂ (n : ℕ), f m n)) filter.at_top (𝓝 (d (⋃ (m : ℕ), ⋂ (n : ℕ), f m n))),	m : ℕ	⊢ ∀ (n m_1 : ℕ), n ≤ m_1 → f m m_1 ⊆ f m n
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	hγ : filter.tendsto (λ (m : ℕ), γ - 2 * (1 / 2) ^ m) filter.at_top (𝓝 γ),	hd : filter.tendsto (λ (m : ℕ), d (⋂ (n : ℕ), f m n)) filter.at_top (𝓝 (d (⋃ (m : ℕ), ⋂ (n : ℕ), f m n))),	m : ℕ,	this : filter.tendsto (λ (n : ℕ), d (f m n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), f m n)))	⊢ γ - 2 * (1 / 2) ^ m ≤ d (⋂ (n : ℕ), f m n)
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	hγ : filter.tendsto (λ (m : ℕ), γ - 2 * (1 / 2) ^ m) filter.at_top (𝓝 γ),	hd : filter.tendsto (λ (m : ℕ), d (⋂ (n : ℕ), f m n)) filter.at_top (𝓝 (d (⋃ (m : ℕ), ⋂ (n : ℕ), f m n))),	m : ℕ,	this : filter.tendsto (λ (n : ℕ), d (f m n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), f m n))),	n : ℕ,	hmn : n ≥ m	⊢ γ - 2 * (1 / 2) ^ m ≤ d (f m n)
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	hγ : filter.tendsto (λ (m : ℕ), γ - 2 * (1 / 2) ^ m) filter.at_top (𝓝 γ),	hd : filter.tendsto (λ (m : ℕ), d (⋂ (n : ℕ), f m n)) filter.at_top (𝓝 (d (⋃ (m : ℕ), ⋂ (n : ℕ), f m n))),	m : ℕ,	this : filter.tendsto (λ (n : ℕ), d (f m n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), f m n))),	n : ℕ,	hmn : n ≥ m	⊢ γ - 2 * (1 / 2) ^ m ≤ d (f m n)
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	hγ : filter.tendsto (λ (m : ℕ), γ - 2 * (1 / 2) ^ m) filter.at_top (𝓝 γ),	hd : filter.tendsto (λ (m : ℕ), d (⋂ (n : ℕ), f m n)) filter.at_top (𝓝 (d (⋃ (m : ℕ), ⋂ (n : ℕ), f m n))),	m : ℕ,	this : filter.tendsto (λ (n : ℕ), d (f m n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), f m n))),	n : ℕ,	hmn : n ≥ m	⊢ γ - 2 * (1 / 2) ^ m ≤ γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n	⊢ γ ≤ d s		α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	γ_le_d_s : γ ≤ d s	⊢ ∃ (s : set α), measurable_set s ∧ (∀ (t : set α), measurable_set t → t ⊆ s → ⇑ν t ≤ ⇑μ t) ∧ ∀ (t : set α), measurable_set t → t ⊆ sᶜ → ⇑μ t ≤ ⇑ν t
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	γ_le_d_s : γ ≤ d s	⊢ ∃ (s : set α), measurable_set s ∧ (∀ (t : set α), measurable_set t → t ⊆ s → ⇑ν t ≤ ⇑μ t) ∧ ∀ (t : set α), measurable_set t → t ⊆ sᶜ → ⇑μ t ≤ ⇑ν t
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	γ_le_d_s : γ ≤ d s,	hs : measurable_set s	⊢ ∃ (s : set α), measurable_set s ∧ (∀ (t : set α), measurable_set t → t ⊆ s → ⇑ν t ≤ ⇑μ t) ∧ ∀ (t : set α), measurable_set t → t ⊆ sᶜ → ⇑μ t ≤ ⇑ν t
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	γ_le_d_s : γ ≤ d s,	hs : measurable_set s	⊢ ∀ (t : set α), measurable_set t → t ⊆ s → ⇑ν t ≤ ⇑μ t
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	γ_le_d_s : γ ≤ d s,	hs : measurable_set s,	t : set α,	ht : measurable_set t,	hts : t ⊆ s	⊢ ⇑ν t ≤ ⇑μ t
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	γ_le_d_s : γ ≤ d s,	hs : measurable_set s,	t : set α,	ht : measurable_set t,	hts : t ⊆ s	⊢ γ + 0 ≤ d s
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	γ_le_d_s : γ ≤ d s,	hs : measurable_set s,	t : set α,	ht : measurable_set t,	hts : t ⊆ s	⊢ γ + 0 ≤ d s
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	γ_le_d_s : γ ≤ d s,	hs : measurable_set s,	t : set α,	ht : measurable_set t,	hts : t ⊆ s	⊢ γ ≤ d s
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	γ_le_d_s : γ ≤ d s,	hs : measurable_set s,	t : set α,	ht : measurable_set t,	hts : t ⊆ s	⊢ d s = d (s \ t) + d t
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	γ_le_d_s : γ ≤ d s,	hs : measurable_set s,	t : set α,	ht : measurable_set t,	hts : t ⊆ s,	this : 0 ≤ d t	⊢ ⇑ν t ≤ ⇑μ t
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	γ_le_d_s : γ ≤ d s,	hs : measurable_set s,	t : set α,	ht : measurable_set t,	hts : t ⊆ s,	this : 0 ≤ d t	⊢ ↑((⇑ν t).to_nnreal) ≤ ↑((⇑μ t).to_nnreal)
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	γ_le_d_s : γ ≤ d s,	hs : measurable_set s	⊢ ∀ (t : set α), measurable_set t → t ⊆ s → ⇑ν t ≤ ⇑μ t		α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	γ_le_d_s : γ ≤ d s,	hs : measurable_set s	⊢ ∀ (t : set α), measurable_set t → t ⊆ sᶜ → ⇑μ t ≤ ⇑ν t
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	γ_le_d_s : γ ≤ d s,	hs : measurable_set s	⊢ ∀ (t : set α), measurable_set t → t ⊆ sᶜ → ⇑μ t ≤ ⇑ν t
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	γ_le_d_s : γ ≤ d s,	hs : measurable_set s,	t : set α,	ht : measurable_set t,	hts : t ⊆ sᶜ	⊢ ⇑μ t ≤ ⇑ν t
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	γ_le_d_s : γ ≤ d s,	hs : measurable_set s,	t : set α,	ht : measurable_set t,	hts : t ⊆ sᶜ	⊢ d t ≤ 0		α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	γ_le_d_s : γ ≤ d s,	hs : measurable_set s,	t : set α,	ht : measurable_set t,	hts : t ⊆ sᶜ,	this : d t ≤ 0	⊢ ⇑μ t ≤ ⇑ν t
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	γ_le_d_s : γ ≤ d s,	hs : measurable_set s,	t : set α,	ht : measurable_set t,	hts : t ⊆ sᶜ	⊢ d s + d t = d (s ∪ t)
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	γ_le_d_s : γ ≤ d s,	hs : measurable_set s,	t : set α,	ht : measurable_set t,	hts : t ⊆ sᶜ	⊢ t ∩ s ⊆ ∅
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	γ_le_d_s : γ ≤ d s,	hs : measurable_set s,	t : set α,	ht : measurable_set t,	hts : t ⊆ sᶜ	⊢ d (s ∪ t) ≤ γ + 0
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	γ_le_d_s : γ ≤ d s,	hs : measurable_set s,	t : set α,	ht : measurable_set t,	hts : t ⊆ sᶜ	⊢ d (s ∪ t) ≤ γ + 0
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	γ_le_d_s : γ ≤ d s,	hs : measurable_set s,	t : set α,	ht : measurable_set t,	hts : t ⊆ sᶜ	⊢ d (s ∪ t) ≤ γ
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	γ_le_d_s : γ ≤ d s,	hs : measurable_set s,	t : set α,	ht : measurable_set t,	hts : t ⊆ sᶜ,	this : d t ≤ 0	⊢ ⇑μ t ≤ ⇑ν t
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : ℕ → set α,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x),	he₁ : ∀ (n : ℕ), measurable_set (e n),	he₂ : ∀ (n : ℕ), γ - (1 / 2) ^ n < d (e n),	f : ℕ → ℕ → set α := λ (n m : ℕ), (finset.Ico n (m + 1)).inf e,	hf : ∀ (n m : ℕ), measurable_set (f n m),	f_subset_f : ∀ {a b c d : ℕ}, a ≤ b → c ≤ d → f a d ⊆ f b c,	f_succ : ∀ (n m : ℕ), n ≤ m → f n (m + 1) = f n m ∩ e (m + 1),	le_d_f : ∀ (n m : ℕ), m ≤ n → γ - 2 * (1 / 2) ^ m + (1 / 2) ^ n ≤ d (f m n),	s : set α := ⋃ (m : ℕ), ⋂ (n : ℕ), f m n,	γ_le_d_s : γ ≤ d s,	hs : measurable_set s,	t : set α,	ht : measurable_set t,	hts : t ⊆ sᶜ,	this : d t ≤ 0	⊢ ↑((⇑μ t).to_nnreal) ≤ ↑((⇑ν t).to_nnreal)
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν	⊢ ∃ (s : set α), measurable_set s ∧ (∀ (t : set α), measurable_set t → t ⊆ s → ⇑ν t ≤ ⇑μ t) ∧ ∀ (t : set α), measurable_set t → t ⊆ sᶜ → ⇑μ t ≤ ⇑ν t
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal)	⊢ ∃ (s : set α), measurable_set s ∧ (∀ (t : set α), measurable_set t → t ⊆ s → ⇑ν t ≤ ⇑μ t) ∧ ∀ (t : set α), measurable_set t → t ⊆ sᶜ → ⇑μ t ≤ ⇑ν t
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s}	⊢ ∃ (s : set α), measurable_set s ∧ (∀ (t : set α), measurable_set t → t ⊆ s → ⇑ν t ≤ ⇑μ t) ∧ ∀ (t : set α), measurable_set t → t ⊆ sᶜ → ⇑μ t ≤ ⇑ν t
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c	⊢ ∃ (s : set α), measurable_set s ∧ (∀ (t : set α), measurable_set t → t ⊆ s → ⇑ν t ≤ ⇑μ t) ∧ ∀ (t : set α), measurable_set t → t ⊆ sᶜ → ⇑μ t ≤ ⇑ν t
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤	⊢ ∃ (s : set α), measurable_set s ∧ (∀ (t : set α), measurable_set t → t ⊆ s → ⇑ν t ≤ ⇑μ t) ∧ ∀ (t : set α), measurable_set t → t ⊆ sᶜ → ⇑μ t ≤ ⇑ν t
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤	⊢ ∃ (s : set α), measurable_set s ∧ (∀ (t : set α), measurable_set t → t ⊆ s → ⇑ν t ≤ ⇑μ t) ∧ ∀ (t : set α), measurable_set t → t ⊆ sᶜ → ⇑μ t ≤ ⇑ν t
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s	⊢ ∃ (s : set α), measurable_set s ∧ (∀ (t : set α), measurable_set t → t ⊆ s → ⇑ν t ≤ ⇑μ t) ∧ ∀ (t : set α), measurable_set t → t ⊆ sᶜ → ⇑μ t ≤ ⇑ν t
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s	⊢ d ∅ = 0
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s	⊢ ↑((⇑μ ∅).to_nnreal) - ↑((⇑ν ∅).to_nnreal) = 0
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s	⊢ ∃ (s : set α), measurable_set s ∧ (∀ (t : set α), measurable_set t → t ⊆ s → ⇑ν t ≤ ⇑μ t) ∧ ∀ (t : set α), measurable_set t → t ⊆ sᶜ → ⇑μ t ≤ ⇑ν t
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s	⊢ ↑(0.to_nnreal) - ↑(0.to_nnreal) = 0
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s	⊢ d ∅ = 0		α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0	⊢ ∃ (s : set α), measurable_set s ∧ (∀ (t : set α), measurable_set t → t ⊆ s → ⇑ν t ≤ ⇑μ t) ∧ ∀ (t : set α), measurable_set t → t ⊆ sᶜ → ⇑μ t ≤ ⇑ν t
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0	⊢ ∃ (s : set α), measurable_set s ∧ (∀ (t : set α), measurable_set t → t ⊆ s → ⇑ν t ≤ ⇑μ t) ∧ ∀ (t : set α), measurable_set t → t ⊆ sᶜ → ⇑μ t ≤ ⇑ν t
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0	⊢ ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t)
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	s t : set α,	hs : measurable_set s,	ht : measurable_set t	⊢ d s = d (s \ t) + d (s ∩ t)
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	s t : set α,	hs : measurable_set s,	ht : measurable_set t	⊢ ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal) = ↑((⇑μ (s \ t)).to_nnreal) - ↑((⇑ν (s \ t)).to_nnreal) + (↑((⇑μ (s ∩ t)).to_nnreal) - ↑((⇑ν (s ∩ t)).to_nnreal))
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	s t : set α,	hs : measurable_set s,	ht : measurable_set t	⊢ ↑((⇑μ (s ∩ t)).to_nnreal) + ↑((⇑μ (s \ t)).to_nnreal) - (↑((⇑ν (s ∩ t)).to_nnreal) + ↑((⇑ν (s \ t)).to_nnreal)) = ↑((⇑μ (s \ t)).to_nnreal) - ↑((⇑ν (s \ t)).to_nnreal) + (↑((⇑μ (s ∩ t)).to_nnreal) - ↑((⇑ν (s ∩ t)).to_nnreal))
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0	⊢ ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t)		α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t)	⊢ ∃ (s : set α), measurable_set s ∧ (∀ (t : set α), measurable_set t → t ⊆ s → ⇑ν t ≤ ⇑μ t) ∧ ∀ (t : set α), measurable_set t → t ⊆ sᶜ → ⇑μ t ≤ ⇑ν t
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	s t : set α,	hs : measurable_set s,	ht : measurable_set t	⊢ ↑((⇑μ (s ∩ t)).to_nnreal) + ↑((⇑μ (s \ t)).to_nnreal) + (-↑((⇑ν (s ∩ t)).to_nnreal) + -↑((⇑ν (s \ t)).to_nnreal)) = ↑((⇑μ (s \ t)).to_nnreal) + -↑((⇑ν (s \ t)).to_nnreal) + (↑((⇑μ (s ∩ t)).to_nnreal) + -↑((⇑ν (s ∩ t)).to_nnreal))
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t)	⊢ ∃ (s : set α), measurable_set s ∧ (∀ (t : set α), measurable_set t → t ⊆ s → ⇑ν t ≤ ⇑μ t) ∧ ∀ (t : set α), measurable_set t → t ⊆ sᶜ → ⇑μ t ≤ ⇑ν t
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t)	⊢ ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n)))
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	s : ℕ → set α,	hs : ∀ (n : ℕ), measurable_set (s n),	hm : monotone s	⊢ filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n)))
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	s : ℕ → set α,	hs : ∀ (n : ℕ), measurable_set (s n),	hm : monotone s	⊢ filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n)))
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	s : ℕ → set α,	hs : ∀ (n : ℕ), measurable_set (s n),	hm : monotone s	⊢ filter.tendsto (λ (n : ℕ), ↑((⇑μ (s n)).to_nnreal)) filter.at_top (𝓝 ↑((⇑μ (⋃ (n : ℕ), s n)).to_nnreal))
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	s : ℕ → set α,	hs : ∀ (n : ℕ), measurable_set (s n),	hm : monotone s	⊢ filter.tendsto (λ (n : ℕ), ↑((⇑ν (s n)).to_nnreal)) filter.at_top (𝓝 ↑((⇑ν (⋃ (n : ℕ), s n)).to_nnreal))
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	s : ℕ → set α,	hs : ∀ (n : ℕ), measurable_set (s n),	hm : monotone s	⊢ ⇑μ (⋃ (n : ℕ), s n) ≠ ⊤		α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	s : ℕ → set α,	hs : ∀ (n : ℕ), measurable_set (s n),	hm : monotone s	⊢ ⇑ν (⋃ (n : ℕ), s n) ≠ ⊤
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t)	⊢ ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n)))		α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n)))	⊢ ∃ (s : set α), measurable_set s ∧ (∀ (t : set α), measurable_set t → t ⊆ s → ⇑ν t ≤ ⇑μ t) ∧ ∀ (t : set α), measurable_set t → t ⊆ sᶜ → ⇑μ t ≤ ⇑ν t
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	s : ℕ → set α,	hs : ∀ (n : ℕ), measurable_set (s n),	hm : monotone s	⊢ ⇑ν (⋃ (n : ℕ), s n) ≠ ⊤
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n)))	⊢ ∃ (s : set α), measurable_set s ∧ (∀ (t : set α), measurable_set t → t ⊆ s → ⇑ν t ≤ ⇑μ t) ∧ ∀ (t : set α), measurable_set t → t ⊆ sᶜ → ⇑μ t ≤ ⇑ν t
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n)))	⊢ ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n)))
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	s : ℕ → set α,	hs : ∀ (n : ℕ), measurable_set (s n),	hm : ∀ (n m : ℕ), n ≤ m → s m ⊆ s n	⊢ filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n)))
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	s : ℕ → set α,	hs : ∀ (n : ℕ), measurable_set (s n),	hm : ∀ (n m : ℕ), n ≤ m → s m ⊆ s n	⊢ filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n)))
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	s : ℕ → set α,	hs : ∀ (n : ℕ), measurable_set (s n),	hm : ∀ (n m : ℕ), n ≤ m → s m ⊆ s n	⊢ filter.tendsto (λ (n : ℕ), ↑((⇑μ (s n)).to_nnreal)) filter.at_top (𝓝 ↑((⇑μ (⋂ (n : ℕ), s n)).to_nnreal))
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	s : ℕ → set α,	hs : ∀ (n : ℕ), measurable_set (s n),	hm : ∀ (n m : ℕ), n ≤ m → s m ⊆ s n	⊢ filter.tendsto (λ (n : ℕ), ↑((⇑ν (s n)).to_nnreal)) filter.at_top (𝓝 ↑((⇑ν (⋂ (n : ℕ), s n)).to_nnreal))
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n)))	⊢ ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n)))		α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n)))	⊢ ∃ (s : set α), measurable_set s ∧ (∀ (t : set α), measurable_set t → t ⊆ s → ⇑ν t ≤ ⇑μ t) ∧ ∀ (t : set α), measurable_set t → t ⊆ sᶜ → ⇑μ t ≤ ⇑ν t
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	s : ℕ → set α,	hs : ∀ (n : ℕ), measurable_set (s n),	hm : ∀ (n m : ℕ), n ≤ m → s m ⊆ s n	⊢ ⇑μ (⋂ (n : ℕ), s n) ≠ ⊤		α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	s : ℕ → set α,	hs : ∀ (n : ℕ), measurable_set (s n),	hm : ∀ (n m : ℕ), n ≤ m → s m ⊆ s n	⊢ ∃ (i : ℕ), ⇑μ (s i) ≠ ⊤		α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	s : ℕ → set α,	hs : ∀ (n : ℕ), measurable_set (s n),	hm : ∀ (n m : ℕ), n ≤ m → s m ⊆ s n	⊢ ⇑ν (⋂ (n : ℕ), s n) ≠ ⊤		α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	s : ℕ → set α,	hs : ∀ (n : ℕ), measurable_set (s n),	hm : ∀ (n m : ℕ), n ≤ m → s m ⊆ s n	⊢ ∃ (i : ℕ), ⇑ν (s i) ≠ ⊤
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n)))	⊢ ∃ (s : set α), measurable_set s ∧ (∀ (t : set α), measurable_set t → t ⊆ s → ⇑ν t ≤ ⇑μ t) ∧ ∀ (t : set α), measurable_set t → t ⊆ sᶜ → ⇑μ t ≤ ⇑ν t
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n)))	⊢ bdd_above c
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n)))	⊢ ↑((⇑μ set.univ).to_nnreal) ∈ upper_bounds c
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	s : set α,	hs : s ∈ {s : set α | measurable_set s}	⊢ d s ≤ ↑((⇑μ set.univ).to_nnreal)
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	s : set α,	hs : s ∈ {s : set α | measurable_set s}	⊢ ↑((⇑μ s).to_nnreal) ≤ ↑((⇑μ set.univ).to_nnreal)
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n)))	⊢ bdd_above c		α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c	⊢ ∃ (s : set α), measurable_set s ∧ (∀ (t : set α), measurable_set t → t ⊆ s → ⇑ν t ≤ ⇑μ t) ∧ ∀ (t : set α), measurable_set t → t ⊆ sᶜ → ⇑μ t ≤ ⇑ν t
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	s : set α,	hs : s ∈ {s : set α | measurable_set s}	⊢ ⇑μ s ≤ ⇑μ set.univ
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c	⊢ ∃ (s : set α), measurable_set s ∧ (∀ (t : set α), measurable_set t → t ⊆ s → ⇑ν t ≤ ⇑μ t) ∧ ∀ (t : set α), measurable_set t → t ⊆ sᶜ → ⇑μ t ≤ ⇑ν t
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty	⊢ ∃ (s : set α), measurable_set s ∧ (∀ (t : set α), measurable_set t → t ⊆ s → ⇑ν t ≤ ⇑μ t) ∧ ∀ (t : set α), measurable_set t → t ⊆ sᶜ → ⇑μ t ≤ ⇑ν t
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ	⊢ ∃ (s : set α), measurable_set s ∧ (∀ (t : set α), measurable_set t → t ⊆ s → ⇑ν t ≤ ⇑μ t) ∧ ∀ (t : set α), measurable_set t → t ⊆ sᶜ → ⇑μ t ≤ ⇑ν t
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ	⊢ ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	n : ℕ	⊢ ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	n : ℕ,	this : γ - (1 / 2) ^ n < γ	⊢ ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ	⊢ ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s		α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s	⊢ ∃ (s : set α), measurable_set s ∧ (∀ (t : set α), measurable_set t → t ⊆ s → ⇑ν t ≤ ⇑μ t) ∧ ∀ (t : set α), measurable_set t → t ⊆ sᶜ → ⇑μ t ≤ ⇑ν t
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	n : ℕ,	this : γ - (1 / 2) ^ n < γ,	s : set α,	hs : s ∈ {s : set α | measurable_set s},	hlt : γ - (1 / 2) ^ n < d s	⊢ ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s	⊢ ∃ (s : set α), measurable_set s ∧ (∀ (t : set α), measurable_set t → t ⊆ s → ⇑ν t ≤ ⇑μ t) ∧ ∀ (t : set α), measurable_set t → t ⊆ sᶜ → ⇑μ t ≤ ⇑ν t
α : Type u_1,	_inst_1 : measurable_space α,	μ ν : measure_theory.measure α,	_inst_2 : measure_theory.is_finite_measure μ,	_inst_3 : measure_theory.is_finite_measure ν,	d : set α → ℝ := λ (s : set α), ↑((⇑μ s).to_nnreal) - ↑((⇑ν s).to_nnreal),	c : set ℝ := d '' {s : set α | measurable_set s},	γ : ℝ := has_Sup.Sup c,	hμ : ∀ (s : set α), ⇑μ s ≠ ⊤,	hν : ∀ (s : set α), ⇑ν s ≠ ⊤,	to_nnreal_μ : ∀ (s : set α), ↑((⇑μ s).to_nnreal) = ⇑μ s,	to_nnreal_ν : ∀ (s : set α), ↑((⇑ν s).to_nnreal) = ⇑ν s,	d_empty : d ∅ = 0,	d_split : ∀ (s t : set α), measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t),	d_Union : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → monotone s → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋃ (n : ℕ), s n))),	d_Inter : ∀ (s : ℕ → set α), (∀ (n : ℕ), measurable_set (s n)) → (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) → filter.tendsto (λ (n : ℕ), d (s n)) filter.at_top (𝓝 (d (⋂ (n : ℕ), s n))),	bdd_c : bdd_above c,	c_nonempty : c.nonempty,	d_le_γ : ∀ (s : set α), measurable_set s → d s ≤ γ,	this : ∀ (n : ℕ), ∃ (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s,	e : Π (x : ℕ), (λ (n : ℕ), set α) x,	he : ∀ (x : ℕ), (λ (n : ℕ) (s : set α), measurable_set s ∧ γ - (1 / 2) ^ n < d s) x (e x)	⊢ ∃ (s : set α), measurable_set s ∧ (∀ (t : set α), measurable_set t → t ⊆ s → ⇑ν t ≤ ⇑μ t) ∧ ∀ (t : set α), measurable_set t → t ⊆ sᶜ → ⇑μ t ≤ ⇑ν t
α : Type u_1,	β : Type u_2,	ι : Type u_4,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	f : ι → α → β,	μ : measure_theory.measure α,	p : α → (ι → β) → Prop,	_inst_3 : encodable ι,	hf : ∀ (i : ι), ae_measurable (f i) μ,	hp : ∀ᵐ (x : α) ∂μ, p x (λ (n : ι), f n x)	⊢ ⇑μ (ae_seq_set hf p)ᶜ = 0
α : Type u_1,	β : Type u_2,	ι : Type u_4,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	f : ι → α → β,	μ : measure_theory.measure α,	p : α → (ι → β) → Prop,	_inst_3 : encodable ι,	hf : ∀ (i : ι), ae_measurable (f i) μ,	hp : ∀ᵐ (x : α) ∂μ, p x (λ (n : ι), f n x)	⊢ ⇑μ {x : α | (∀ (i : ι), f i x = ae_measurable.mk (f i) _ x) ∧ p x (λ (n : ι), f n x)}ᶜ = 0
α : Type u_1,	β : Type u_2,	ι : Type u_4,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	f : ι → α → β,	μ : measure_theory.measure α,	p : α → (ι → β) → Prop,	_inst_3 : encodable ι,	hf : ∀ (i : ι), ae_measurable (f i) μ,	hp : ∀ᵐ (x : α) ∂μ, p x (λ (n : ι), f n x),	hf_eq : ∀ (i : ι), f i =ᵐ[μ] ae_measurable.mk (f i) _	⊢ ⇑μ {x : α | (∀ (i : ι), f i x = ae_measurable.mk (f i) _ x) ∧ p x (λ (n : ι), f n x)}ᶜ = 0
α : Type u_1,	β : Type u_2,	ι : Type u_4,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	f : ι → α → β,	μ : measure_theory.measure α,	p : α → (ι → β) → Prop,	_inst_3 : encodable ι,	hf : ∀ (i : ι), ae_measurable (f i) μ,	hp : ∀ᵐ (x : α) ∂μ, p x (λ (n : ι), f n x),	hf_eq : ∀ᵐ (a : α) ∂μ, ∀ (i : ι), f i a = ae_measurable.mk (f i) _ a	⊢ ⇑μ {x : α | (∀ (i : ι), f i x = ae_measurable.mk (f i) _ x) ∧ p x (λ (n : ι), f n x)}ᶜ = 0
α : Type u_1,	β : Type u_2,	ι : Type u_4,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	f : ι → α → β,	μ : measure_theory.measure α,	p : α → (ι → β) → Prop,	hf : ∀ (i : ι), ae_measurable (f i) μ,	x : α,	hx : x ∈ ae_seq_set hf p	⊢ p x (λ (n : ι), ae_seq hf p n x)
α : Type u_1,	β : Type u_2,	ι : Type u_4,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	f : ι → α → β,	μ : measure_theory.measure α,	p : α → (ι → β) → Prop,	hf : ∀ (i : ι), ae_measurable (f i) μ,	x : α,	hx : x ∈ ae_seq_set hf p	⊢ p x (λ (n : ι), ae_measurable.mk (f n) _ x)
α : Type u_1,	β : Type u_2,	ι : Type u_4,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	f : ι → α → β,	μ : measure_theory.measure α,	p : α → (ι → β) → Prop,	hf : ∀ (i : ι), ae_measurable (f i) μ,	x : α,	hx : x ∈ ae_seq_set hf p	⊢ p x (λ (n : ι), f n x)
α : Type u_1,	β : Type u_2,	ι : Type u_4,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	f : ι → α → β,	μ : measure_theory.measure α,	p : α → (ι → β) → Prop,	hf : ∀ (i : ι), ae_measurable (f i) μ,	x : α,	hx : x ∈ ae_seq_set hf p	⊢ ae_seq_set hf p ⊆ {x : α | p x (λ (n : ι), f n x)}
α : Type u_1,	β : Type u_2,	ι : Type u_4,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	f : ι → α → β,	μ : measure_theory.measure α,	p : α → (ι → β) → Prop,	hf : ∀ (i : ι), ae_measurable (f i) μ,	x : α,	hx : x ∈ ae_seq_set hf p	⊢ {x : α | p x (λ (n : ι), f n x)}ᶜ ⊆ measure_theory.to_measurable μ {x : α | (∀ (i : ι), f i x = ae_measurable.mk (f i) _ x) ∧ p x (λ (n : ι), f n x)}ᶜ
α : Type u_1,	β : Type u_2,	ι : Type u_4,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	f : ι → α → β,	μ : measure_theory.measure α,	p : α → (ι → β) → Prop,	hf : ∀ (i : ι), ae_measurable (f i) μ,	x : α,	hx : x ∈ ae_seq_set hf p	⊢ ae_seq_set hf p ⊆ {x : α | p x (λ (n : ι), f n x)}		α : Type u_1,	β : Type u_2,	ι : Type u_4,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	f : ι → α → β,	μ : measure_theory.measure α,	p : α → (ι → β) → Prop,	hf : ∀ (i : ι), ae_measurable (f i) μ,	x : α,	hx : x ∈ ae_seq_set hf p,	h_ss : ae_seq_set hf p ⊆ {x : α | p x (λ (n : ι), f n x)}	⊢ p x (λ (n : ι), f n x)
α : Type u_1,	β : Type u_2,	ι : Type u_4,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	f : ι → α → β,	μ : measure_theory.measure α,	p : α → (ι → β) → Prop,	hf : ∀ (i : ι), ae_measurable (f i) μ,	x : α,	hx : x ∈ ae_seq_set hf p	⊢ {x : α | (∀ (i : ι), f i x = ae_measurable.mk (f i) _ x) ∧ p x (λ (n : ι), f n x)} ⊆ {x : α | p x (λ (n : ι), f n x)}
α : Type u_1,	β : Type u_2,	ι : Type u_4,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	f : ι → α → β,	μ : measure_theory.measure α,	p : α → (ι → β) → Prop,	hf : ∀ (i : ι), ae_measurable (f i) μ,	x : α,	hx : x ∈ ae_seq_set hf p,	h_ss : ae_seq_set hf p ⊆ {x : α | p x (λ (n : ι), f n x)}	⊢ p x (λ (n : ι), f n x)
α : Type u_1,	β : Type u_2,	ι : Type u_4,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	f : ι → α → β,	μ : measure_theory.measure α,	p : α → (ι → β) → Prop,	hf : ∀ (i : ι), ae_measurable (f i) μ,	x : α,	hx : x ∈ ae_seq_set hf p,	h_ss : ae_seq_set hf p ⊆ {x : α | p x (λ (n : ι), f n x)},	hx' : x ∈ {x : α | p x (λ (n : ι), f n x)}	⊢ p x (λ (n : ι), f n x)
α : Type u_1,	β : Type u_2,	m m0 : measurable_space α,	μ : measure_theory.measure α,	_inst_1 : measurable_space β,	f g : α → β,	_inst_3 : has_add β,	_inst_4 : has_measurable_add₂ β,	hf : measure_theory.ae_measurable' m f μ,	hg : measure_theory.ae_measurable' m g μ	⊢ measure_theory.ae_measurable' m (f + g) μ
α : Type u_1,	β : Type u_2,	m m0 : measurable_space α,	μ : measure_theory.measure α,	_inst_1 : measurable_space β,	f g : α → β,	_inst_3 : has_add β,	_inst_4 : has_measurable_add₂ β,	hg : measure_theory.ae_measurable' m g μ,	f' : α → β,	h_f'_meas : measurable f',	hff' : f =ᵐ[μ] f'	⊢ measure_theory.ae_measurable' m (f + g) μ
α : Type u_1,	β : Type u_2,	m m0 : measurable_space α,	μ : measure_theory.measure α,	_inst_1 : measurable_space β,	f g : α → β,	_inst_3 : has_add β,	_inst_4 : has_measurable_add₂ β,	f' : α → β,	h_f'_meas : measurable f',	hff' : f =ᵐ[μ] f',	g' : α → β,	h_g'_meas : measurable g',	hgg' : g =ᵐ[μ] g'	⊢ measure_theory.ae_measurable' m (f + g) μ
α : Type u_1,	F' : Type u_7,	_inst_19 : normed_group F',	_inst_21 : measurable_space F',	_inst_22 : borel_space F',	_inst_23 : topological_space.second_countable_topology F',	_inst_24 : normed_space ℝ F',	_inst_25 : complete_space F',	m m0 : measurable_space α,	μ : measure_theory.measure α,	hm : m ≤ m0,	_inst_40 : measure_theory.sigma_finite (μ.trim hm),	f : ↥(measure_theory.Lp_meas F' ℝ m 1 μ)	⊢ ⇑(measure_theory.condexp_L1_clm hm μ) ↑f = ↑f
α : Type u_1,	F' : Type u_7,	_inst_19 : normed_group F',	_inst_21 : measurable_space F',	_inst_22 : borel_space F',	_inst_23 : topological_space.second_countable_topology F',	_inst_24 : normed_space ℝ F',	_inst_25 : complete_space F',	m m0 : measurable_space α,	μ : measure_theory.measure α,	hm : m ≤ m0,	_inst_40 : measure_theory.sigma_finite (μ.trim hm),	f : ↥(measure_theory.Lp_meas F' ℝ m 1 μ),	g : ↥(measure_theory.Lp F' 1 (μ.trim hm)) := ⇑(measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm) f	⊢ ⇑(measure_theory.condexp_L1_clm hm μ) ↑f = ↑f
α : Type u_1,	F' : Type u_7,	_inst_19 : normed_group F',	_inst_21 : measurable_space F',	_inst_22 : borel_space F',	_inst_23 : topological_space.second_countable_topology F',	_inst_24 : normed_space ℝ F',	_inst_25 : complete_space F',	m m0 : measurable_space α,	μ : measure_theory.measure α,	hm : m ≤ m0,	_inst_40 : measure_theory.sigma_finite (μ.trim hm),	f : ↥(measure_theory.Lp_meas F' ℝ m 1 μ),	g : ↥(measure_theory.Lp F' 1 (μ.trim hm)) := ⇑(measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm) f	⊢ f = ⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g
α : Type u_1,	F' : Type u_7,	_inst_19 : normed_group F',	_inst_21 : measurable_space F',	_inst_22 : borel_space F',	_inst_23 : topological_space.second_countable_topology F',	_inst_24 : normed_space ℝ F',	_inst_25 : complete_space F',	m m0 : measurable_space α,	μ : measure_theory.measure α,	hm : m ≤ m0,	_inst_40 : measure_theory.sigma_finite (μ.trim hm),	f : ↥(measure_theory.Lp_meas F' ℝ m 1 μ),	g : ↥(measure_theory.Lp F' 1 (μ.trim hm)) := ⇑(measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm) f,	hfg : f = ⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g	⊢ ⇑(measure_theory.condexp_L1_clm hm μ) ↑f = ↑f
α : Type u_1,	F' : Type u_7,	_inst_19 : normed_group F',	_inst_21 : measurable_space F',	_inst_22 : borel_space F',	_inst_23 : topological_space.second_countable_topology F',	_inst_24 : normed_space ℝ F',	_inst_25 : complete_space F',	m m0 : measurable_space α,	μ : measure_theory.measure α,	hm : m ≤ m0,	_inst_40 : measure_theory.sigma_finite (μ.trim hm),	f : ↥(measure_theory.Lp_meas F' ℝ m 1 μ),	g : ↥(measure_theory.Lp F' 1 (μ.trim hm)) := ⇑(measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm) f,	hfg : f = ⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g	⊢ ⇑(measure_theory.condexp_L1_clm hm μ) ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g) = ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g)
α : Type u_1,	F' : Type u_7,	_inst_19 : normed_group F',	_inst_21 : measurable_space F',	_inst_22 : borel_space F',	_inst_23 : topological_space.second_countable_topology F',	_inst_24 : normed_space ℝ F',	_inst_25 : complete_space F',	m m0 : measurable_space α,	μ : measure_theory.measure α,	hm : m ≤ m0,	_inst_40 : measure_theory.sigma_finite (μ.trim hm),	f : ↥(measure_theory.Lp_meas F' ℝ m 1 μ),	g : ↥(measure_theory.Lp F' 1 (μ.trim hm)) := ⇑(measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm) f,	hfg : f = ⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g	⊢ ∀ (c : F') {s : set α} (hs : measurable_set s) (hμs : ⇑(μ.trim hm) s < ⊤), (λ (g : ↥(measure_theory.Lp F' 1 (μ.trim hm))), ⇑(measure_theory.condexp_L1_clm hm μ) ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g) = ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g)) ↑(measure_theory.Lp.simple_func.indicator_const 1 hs _ c)
α : Type u_1,	F' : Type u_7,	_inst_19 : normed_group F',	_inst_21 : measurable_space F',	_inst_22 : borel_space F',	_inst_23 : topological_space.second_countable_topology F',	_inst_24 : normed_space ℝ F',	_inst_25 : complete_space F',	m m0 : measurable_space α,	μ : measure_theory.measure α,	hm : m ≤ m0,	_inst_40 : measure_theory.sigma_finite (μ.trim hm),	f : ↥(measure_theory.Lp_meas F' ℝ m 1 μ),	g : ↥(measure_theory.Lp F' 1 (μ.trim hm)) := ⇑(measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm) f,	hfg : f = ⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g,	c : F',	s : set α,	hs : measurable_set s,	hμs : ⇑(μ.trim hm) s < ⊤	⊢ ⇑(measure_theory.condexp_L1_clm hm μ) ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) ↑(measure_theory.Lp.simple_func.indicator_const 1 hs _ c)) = ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) ↑(measure_theory.Lp.simple_func.indicator_const 1 hs _ c))
α : Type u_1,	F' : Type u_7,	_inst_19 : normed_group F',	_inst_21 : measurable_space F',	_inst_22 : borel_space F',	_inst_23 : topological_space.second_countable_topology F',	_inst_24 : normed_space ℝ F',	_inst_25 : complete_space F',	m m0 : measurable_space α,	μ : measure_theory.measure α,	hm : m ≤ m0,	_inst_40 : measure_theory.sigma_finite (μ.trim hm),	f : ↥(measure_theory.Lp_meas F' ℝ m 1 μ),	g : ↥(measure_theory.Lp F' 1 (μ.trim hm)) := ⇑(measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm) f,	hfg : f = ⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g,	c : F',	s : set α,	hs : measurable_set s,	hμs : ⇑(μ.trim hm) s < ⊤	⊢ ⇑(measure_theory.condexp_ind hm μ s) c = measure_theory.indicator_const_Lp 1 _ _ c
α : Type u_1,	F' : Type u_7,	_inst_19 : normed_group F',	_inst_21 : measurable_space F',	_inst_22 : borel_space F',	_inst_23 : topological_space.second_countable_topology F',	_inst_24 : normed_space ℝ F',	_inst_25 : complete_space F',	m m0 : measurable_space α,	μ : measure_theory.measure α,	hm : m ≤ m0,	_inst_40 : measure_theory.sigma_finite (μ.trim hm),	f : ↥(measure_theory.Lp_meas F' ℝ m 1 μ),	g : ↥(measure_theory.Lp F' 1 (μ.trim hm)) := ⇑(measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm) f,	hfg : f = ⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g	⊢ ∀ (c : F') {s : set α} (hs : measurable_set s) (hμs : ⇑(μ.trim hm) s < ⊤), (λ (g : ↥(measure_theory.Lp F' 1 (μ.trim hm))), ⇑(measure_theory.condexp_L1_clm hm μ) ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g) = ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g)) ↑(measure_theory.Lp.simple_func.indicator_const 1 hs _ c)		α : Type u_1,	F' : Type u_7,	_inst_19 : normed_group F',	_inst_21 : measurable_space F',	_inst_22 : borel_space F',	_inst_23 : topological_space.second_countable_topology F',	_inst_24 : normed_space ℝ F',	_inst_25 : complete_space F',	m m0 : measurable_space α,	μ : measure_theory.measure α,	hm : m ≤ m0,	_inst_40 : measure_theory.sigma_finite (μ.trim hm),	f : ↥(measure_theory.Lp_meas F' ℝ m 1 μ),	g : ↥(measure_theory.Lp F' 1 (μ.trim hm)) := ⇑(measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm) f,	hfg : f = ⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g	⊢ ∀ ⦃f g : α → F'⦄ (hf : measure_theory.mem_ℒp f 1 (μ.trim hm)) (hg : measure_theory.mem_ℒp g 1 (μ.trim hm)), disjoint (function.support f) (function.support g) → (λ (g : ↥(measure_theory.Lp F' 1 (μ.trim hm))), ⇑(measure_theory.condexp_L1_clm hm μ) ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g) = ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g)) (measure_theory.mem_ℒp.to_Lp f hf) → (λ (g : ↥(measure_theory.Lp F' 1 (μ.trim hm))), ⇑(measure_theory.condexp_L1_clm hm μ) ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g) = ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g)) (measure_theory.mem_ℒp.to_Lp g hg) → (λ (g : ↥(measure_theory.Lp F' 1 (μ.trim hm))), ⇑(measure_theory.condexp_L1_clm hm μ) ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g) = ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g)) (measure_theory.mem_ℒp.to_Lp f hf + measure_theory.mem_ℒp.to_Lp g hg)		α : Type u_1,	F' : Type u_7,	_inst_19 : normed_group F',	_inst_21 : measurable_space F',	_inst_22 : borel_space F',	_inst_23 : topological_space.second_countable_topology F',	_inst_24 : normed_space ℝ F',	_inst_25 : complete_space F',	m m0 : measurable_space α,	μ : measure_theory.measure α,	hm : m ≤ m0,	_inst_40 : measure_theory.sigma_finite (μ.trim hm),	f : ↥(measure_theory.Lp_meas F' ℝ m 1 μ),	g : ↥(measure_theory.Lp F' 1 (μ.trim hm)) := ⇑(measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm) f,	hfg : f = ⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g	⊢ is_closed {f : ↥(measure_theory.Lp F' 1 (μ.trim hm)) | (λ (g : ↥(measure_theory.Lp F' 1 (μ.trim hm))), ⇑(measure_theory.condexp_L1_clm hm μ) ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g) = ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g)) f}
α : Type u_1,	F' : Type u_7,	_inst_19 : normed_group F',	_inst_21 : measurable_space F',	_inst_22 : borel_space F',	_inst_23 : topological_space.second_countable_topology F',	_inst_24 : normed_space ℝ F',	_inst_25 : complete_space F',	m m0 : measurable_space α,	μ : measure_theory.measure α,	hm : m ≤ m0,	_inst_40 : measure_theory.sigma_finite (μ.trim hm),	f : ↥(measure_theory.Lp_meas F' ℝ m 1 μ),	g : ↥(measure_theory.Lp F' 1 (μ.trim hm)) := ⇑(measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm) f,	hfg : f = ⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g	⊢ ∀ ⦃f g : α → F'⦄ (hf : measure_theory.mem_ℒp f 1 (μ.trim hm)) (hg : measure_theory.mem_ℒp g 1 (μ.trim hm)), disjoint (function.support f) (function.support g) → (λ (g : ↥(measure_theory.Lp F' 1 (μ.trim hm))), ⇑(measure_theory.condexp_L1_clm hm μ) ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g) = ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g)) (measure_theory.mem_ℒp.to_Lp f hf) → (λ (g : ↥(measure_theory.Lp F' 1 (μ.trim hm))), ⇑(measure_theory.condexp_L1_clm hm μ) ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g) = ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g)) (measure_theory.mem_ℒp.to_Lp g hg) → (λ (g : ↥(measure_theory.Lp F' 1 (μ.trim hm))), ⇑(measure_theory.condexp_L1_clm hm μ) ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g) = ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g)) (measure_theory.mem_ℒp.to_Lp f hf + measure_theory.mem_ℒp.to_Lp g hg)
α : Type u_1,	F' : Type u_7,	_inst_19 : normed_group F',	_inst_21 : measurable_space F',	_inst_22 : borel_space F',	_inst_23 : topological_space.second_countable_topology F',	_inst_24 : normed_space ℝ F',	_inst_25 : complete_space F',	m m0 : measurable_space α,	μ : measure_theory.measure α,	hm : m ≤ m0,	_inst_40 : measure_theory.sigma_finite (μ.trim hm),	f : ↥(measure_theory.Lp_meas F' ℝ m 1 μ),	g : ↥(measure_theory.Lp F' 1 (μ.trim hm)) := ⇑(measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm) f,	hfg : f = ⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g,	f g : α → F',	hf : measure_theory.mem_ℒp f 1 (μ.trim hm),	hg : measure_theory.mem_ℒp g 1 (μ.trim hm),	hfg_disj : disjoint (function.support f) (function.support g),	hf_eq : ⇑(measure_theory.condexp_L1_clm hm μ) ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) (measure_theory.mem_ℒp.to_Lp f hf)) = ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) (measure_theory.mem_ℒp.to_Lp f hf)),	hg_eq : ⇑(measure_theory.condexp_L1_clm hm μ) ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) (measure_theory.mem_ℒp.to_Lp g hg)) = ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) (measure_theory.mem_ℒp.to_Lp g hg))	⊢ ⇑(measure_theory.condexp_L1_clm hm μ) ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) (measure_theory.mem_ℒp.to_Lp f hf + measure_theory.mem_ℒp.to_Lp g hg)) = ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) (measure_theory.mem_ℒp.to_Lp f hf + measure_theory.mem_ℒp.to_Lp g hg))
α : Type u_1,	F' : Type u_7,	_inst_19 : normed_group F',	_inst_21 : measurable_space F',	_inst_22 : borel_space F',	_inst_23 : topological_space.second_countable_topology F',	_inst_24 : normed_space ℝ F',	_inst_25 : complete_space F',	m m0 : measurable_space α,	μ : measure_theory.measure α,	hm : m ≤ m0,	_inst_40 : measure_theory.sigma_finite (μ.trim hm),	f : ↥(measure_theory.Lp_meas F' ℝ m 1 μ),	g : ↥(measure_theory.Lp F' 1 (μ.trim hm)) := ⇑(measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm) f,	hfg : f = ⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g,	f g : α → F',	hf : measure_theory.mem_ℒp f 1 (μ.trim hm),	hg : measure_theory.mem_ℒp g 1 (μ.trim hm),	hfg_disj : disjoint (function.support f) (function.support g),	hf_eq : ⇑(measure_theory.condexp_L1_clm hm μ) ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) (measure_theory.mem_ℒp.to_Lp f hf)) = ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) (measure_theory.mem_ℒp.to_Lp f hf)),	hg_eq : ⇑(measure_theory.condexp_L1_clm hm μ) ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) (measure_theory.mem_ℒp.to_Lp g hg)) = ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) (measure_theory.mem_ℒp.to_Lp g hg))	⊢ ⇑(measure_theory.condexp_L1_clm hm μ) ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) (measure_theory.mem_ℒp.to_Lp f hf) + ⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) (measure_theory.mem_ℒp.to_Lp g hg)) = ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) (measure_theory.mem_ℒp.to_Lp f hf) + ⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) (measure_theory.mem_ℒp.to_Lp g hg))
α : Type u_1,	F' : Type u_7,	_inst_19 : normed_group F',	_inst_21 : measurable_space F',	_inst_22 : borel_space F',	_inst_23 : topological_space.second_countable_topology F',	_inst_24 : normed_space ℝ F',	_inst_25 : complete_space F',	m m0 : measurable_space α,	μ : measure_theory.measure α,	hm : m ≤ m0,	_inst_40 : measure_theory.sigma_finite (μ.trim hm),	f : ↥(measure_theory.Lp_meas F' ℝ m 1 μ),	g : ↥(measure_theory.Lp F' 1 (μ.trim hm)) := ⇑(measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm) f,	hfg : f = ⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g	⊢ ∀ ⦃f g : α → F'⦄ (hf : measure_theory.mem_ℒp f 1 (μ.trim hm)) (hg : measure_theory.mem_ℒp g 1 (μ.trim hm)), disjoint (function.support f) (function.support g) → (λ (g : ↥(measure_theory.Lp F' 1 (μ.trim hm))), ⇑(measure_theory.condexp_L1_clm hm μ) ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g) = ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g)) (measure_theory.mem_ℒp.to_Lp f hf) → (λ (g : ↥(measure_theory.Lp F' 1 (μ.trim hm))), ⇑(measure_theory.condexp_L1_clm hm μ) ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g) = ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g)) (measure_theory.mem_ℒp.to_Lp g hg) → (λ (g : ↥(measure_theory.Lp F' 1 (μ.trim hm))), ⇑(measure_theory.condexp_L1_clm hm μ) ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g) = ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g)) (measure_theory.mem_ℒp.to_Lp f hf + measure_theory.mem_ℒp.to_Lp g hg)		α : Type u_1,	F' : Type u_7,	_inst_19 : normed_group F',	_inst_21 : measurable_space F',	_inst_22 : borel_space F',	_inst_23 : topological_space.second_countable_topology F',	_inst_24 : normed_space ℝ F',	_inst_25 : complete_space F',	m m0 : measurable_space α,	μ : measure_theory.measure α,	hm : m ≤ m0,	_inst_40 : measure_theory.sigma_finite (μ.trim hm),	f : ↥(measure_theory.Lp_meas F' ℝ m 1 μ),	g : ↥(measure_theory.Lp F' 1 (μ.trim hm)) := ⇑(measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm) f,	hfg : f = ⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g	⊢ is_closed {f : ↥(measure_theory.Lp F' 1 (μ.trim hm)) | (λ (g : ↥(measure_theory.Lp F' 1 (μ.trim hm))), ⇑(measure_theory.condexp_L1_clm hm μ) ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g) = ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g)) f}
α : Type u_1,	F' : Type u_7,	_inst_19 : normed_group F',	_inst_21 : measurable_space F',	_inst_22 : borel_space F',	_inst_23 : topological_space.second_countable_topology F',	_inst_24 : normed_space ℝ F',	_inst_25 : complete_space F',	m m0 : measurable_space α,	μ : measure_theory.measure α,	hm : m ≤ m0,	_inst_40 : measure_theory.sigma_finite (μ.trim hm),	f : ↥(measure_theory.Lp_meas F' ℝ m 1 μ),	g : ↥(measure_theory.Lp F' 1 (μ.trim hm)) := ⇑(measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm) f,	hfg : f = ⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g,	f g : α → F',	hf : measure_theory.mem_ℒp f 1 (μ.trim hm),	hg : measure_theory.mem_ℒp g 1 (μ.trim hm),	hfg_disj : disjoint (function.support f) (function.support g),	hf_eq : ⇑(measure_theory.condexp_L1_clm hm μ) ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) (measure_theory.mem_ℒp.to_Lp f hf)) = ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) (measure_theory.mem_ℒp.to_Lp f hf)),	hg_eq : ⇑(measure_theory.condexp_L1_clm hm μ) ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) (measure_theory.mem_ℒp.to_Lp g hg)) = ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) (measure_theory.mem_ℒp.to_Lp g hg))	⊢ ⇑(measure_theory.condexp_L1_clm hm μ) (↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) (measure_theory.mem_ℒp.to_Lp f hf)) + ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) (measure_theory.mem_ℒp.to_Lp g hg))) = ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) (measure_theory.mem_ℒp.to_Lp f hf)) + ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) (measure_theory.mem_ℒp.to_Lp g hg))
α : Type u_1,	F' : Type u_7,	_inst_19 : normed_group F',	_inst_21 : measurable_space F',	_inst_22 : borel_space F',	_inst_23 : topological_space.second_countable_topology F',	_inst_24 : normed_space ℝ F',	_inst_25 : complete_space F',	m m0 : measurable_space α,	μ : measure_theory.measure α,	hm : m ≤ m0,	_inst_40 : measure_theory.sigma_finite (μ.trim hm),	f : ↥(measure_theory.Lp_meas F' ℝ m 1 μ),	g : ↥(measure_theory.Lp F' 1 (μ.trim hm)) := ⇑(measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm) f,	hfg : f = ⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g	⊢ is_closed {f : ↥(measure_theory.Lp F' 1 (μ.trim hm)) | (λ (g : ↥(measure_theory.Lp F' 1 (μ.trim hm))), ⇑(measure_theory.condexp_L1_clm hm μ) ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g) = ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g)) f}
α : Type u_1,	F' : Type u_7,	_inst_19 : normed_group F',	_inst_21 : measurable_space F',	_inst_22 : borel_space F',	_inst_23 : topological_space.second_countable_topology F',	_inst_24 : normed_space ℝ F',	_inst_25 : complete_space F',	m m0 : measurable_space α,	μ : measure_theory.measure α,	hm : m ≤ m0,	_inst_40 : measure_theory.sigma_finite (μ.trim hm),	f : ↥(measure_theory.Lp_meas F' ℝ m 1 μ),	g : ↥(measure_theory.Lp F' 1 (μ.trim hm)) := ⇑(measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm) f,	hfg : f = ⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g	⊢ continuous (λ (f : ↥(measure_theory.Lp F' 1 (μ.trim hm))), ⇑(measure_theory.condexp_L1_clm hm μ) ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) f))
α : Type u_1,	F' : Type u_7,	_inst_19 : normed_group F',	_inst_21 : measurable_space F',	_inst_22 : borel_space F',	_inst_23 : topological_space.second_countable_topology F',	_inst_24 : normed_space ℝ F',	_inst_25 : complete_space F',	m m0 : measurable_space α,	μ : measure_theory.measure α,	hm : m ≤ m0,	_inst_40 : measure_theory.sigma_finite (μ.trim hm),	f : ↥(measure_theory.Lp_meas F' ℝ m 1 μ),	g : ↥(measure_theory.Lp F' 1 (μ.trim hm)) := ⇑(measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm) f,	hfg : f = ⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g	⊢ continuous (λ (f : ↥(measure_theory.Lp F' 1 (μ.trim hm))), ⇑(measure_theory.condexp_L1_clm hm μ) ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) f))		α : Type u_1,	F' : Type u_7,	_inst_19 : normed_group F',	_inst_21 : measurable_space F',	_inst_22 : borel_space F',	_inst_23 : topological_space.second_countable_topology F',	_inst_24 : normed_space ℝ F',	_inst_25 : complete_space F',	m m0 : measurable_space α,	μ : measure_theory.measure α,	hm : m ≤ m0,	_inst_40 : measure_theory.sigma_finite (μ.trim hm),	f : ↥(measure_theory.Lp_meas F' ℝ m 1 μ),	g : ↥(measure_theory.Lp F' 1 (μ.trim hm)) := ⇑(measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm) f,	hfg : f = ⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g	⊢ continuous (λ (f : ↥(measure_theory.Lp F' 1 (μ.trim hm))), ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) f))
α : Type u_1,	F' : Type u_7,	_inst_19 : normed_group F',	_inst_21 : measurable_space F',	_inst_22 : borel_space F',	_inst_23 : topological_space.second_countable_topology F',	_inst_24 : normed_space ℝ F',	_inst_25 : complete_space F',	m m0 : measurable_space α,	μ : measure_theory.measure α,	hm : m ≤ m0,	_inst_40 : measure_theory.sigma_finite (μ.trim hm),	f : ↥(measure_theory.Lp_meas F' ℝ m 1 μ),	g : ↥(measure_theory.Lp F' 1 (μ.trim hm)) := ⇑(measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm) f,	hfg : f = ⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g	⊢ continuous (λ (f : ↥(measure_theory.Lp F' 1 (μ.trim hm))), ⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) f)
α : Type u_1,	F' : Type u_7,	_inst_19 : normed_group F',	_inst_21 : measurable_space F',	_inst_22 : borel_space F',	_inst_23 : topological_space.second_countable_topology F',	_inst_24 : normed_space ℝ F',	_inst_25 : complete_space F',	m m0 : measurable_space α,	μ : measure_theory.measure α,	hm : m ≤ m0,	_inst_40 : measure_theory.sigma_finite (μ.trim hm),	f : ↥(measure_theory.Lp_meas F' ℝ m 1 μ),	g : ↥(measure_theory.Lp F' 1 (μ.trim hm)) := ⇑(measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm) f,	hfg : f = ⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) g	⊢ continuous (λ (f : ↥(measure_theory.Lp F' 1 (μ.trim hm))), ↑(⇑((measure_theory.Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm) f))
α : Type u_1,	β : Type u_2,	m m0 m0' : measurable_space α,	_inst_1 : measurable_space β,	hm0 : m0 ≤ m0',	μ : measure_theory.measure α,	f g : α → β,	hg_meas : measurable g,	hfg : f =ᵐ[μ.trim hm0] g	⊢ measure_theory.ae_measurable' m f μ
α : Type u_1,	β : Type u_2,	m m0 m0' : measurable_space α,	_inst_1 : measurable_space β,	hm0 : m0 ≤ m0',	μ : measure_theory.measure α,	f : α → β,	hf : measure_theory.ae_measurable' m f (μ.trim hm0)	⊢ measure_theory.ae_measurable' m f μ
α : Type u_1,	F' : Type u_7,	_inst_19 : normed_group F',	_inst_21 : measurable_space F',	_inst_22 : borel_space F',	_inst_23 : topological_space.second_countable_topology F',	_inst_24 : normed_space ℝ F',	_inst_25 : complete_space F',	m m0 : measurable_space α,	μ : measure_theory.measure α,	hm : m ≤ m0,	_inst_40 : measure_theory.sigma_finite (μ.trim hm),	f : α → F',	hf : measure_theory.integrable f μ	⊢ ∫ (x : α), μ[f|hm] x ∂μ = ∫ (x : α), f x ∂μ
α : Type u_1,	F' : Type u_7,	_inst_19 : normed_group F',	_inst_21 : measurable_space F',	_inst_22 : borel_space F',	_inst_23 : topological_space.second_countable_topology F',	_inst_24 : normed_space ℝ F',	_inst_25 : complete_space F',	m m0 : measurable_space α,	μ : measure_theory.measure α,	hm : m ≤ m0,	_inst_40 : measure_theory.sigma_finite (μ.trim hm),	f : α → F',	hf : measure_theory.integrable f μ,	this : ∫ (x : α) in set.univ, μ[f|hm] x ∂μ = ∫ (x : α) in set.univ, f x ∂μ	⊢ ∫ (x : α), μ[f|hm] x ∂μ = ∫ (x : α), f x ∂μ
α : Type u_1,	F' : Type u_7,	_inst_19 : normed_group F',	_inst_21 : measurable_space F',	_inst_22 : borel_space F',	_inst_23 : topological_space.second_countable_topology F',	_inst_24 : normed_space ℝ F',	_inst_25 : complete_space F',	m m0 : measurable_space α,	μ : measure_theory.measure α,	hm : m ≤ m0,	_inst_40 : measure_theory.sigma_finite (μ.trim hm),	f : α → F',	hf : measure_theory.integrable f μ,	this : measure_theory.integral μ μ[f|hm] = measure_theory.integral μ f	⊢ ∫ (x : α), μ[f|hm] x ∂μ = ∫ (x : α), f x ∂μ
α : Type u_1,	F' : Type u_7,	_inst_19 : normed_group F',	_inst_21 : measurable_space F',	_inst_22 : borel_space F',	_inst_23 : topological_space.second_countable_topology F',	_inst_24 : normed_space ℝ F',	_inst_25 : complete_space F',	m m0 : measurable_space α,	μ : measure_theory.measure α,	hm : m ≤ m0,	_inst_40 : measure_theory.sigma_finite (μ.trim hm),	f : α → F',	hf : measure_theory.integrable f μ	⊢ ∫ (x : α) in set.univ, μ[f|hm] x ∂μ = ∫ (x : α) in set.univ, f x ∂μ
α : Type u_1,	F' : Type u_7,	𝕜 : Type u_11,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : measurable_space 𝕜,	_inst_19 : normed_group F',	_inst_20 : normed_space 𝕜 F',	_inst_21 : measurable_space F',	_inst_22 : borel_space F',	_inst_23 : topological_space.second_countable_topology F',	_inst_24 : normed_space ℝ F',	_inst_25 : complete_space F',	m m0 : measurable_space α,	μ : measure_theory.measure α,	_inst_38 : borel_space 𝕜,	_inst_39 : is_scalar_tower ℝ 𝕜 F',	hm : m ≤ m0,	_inst_40 : measure_theory.sigma_finite (μ.trim hm),	c : 𝕜,	f : α → F'	⊢ μ[c • f|hm] =ᵐ[μ] c • μ[f|hm]
α : Type u_1,	F' : Type u_7,	𝕜 : Type u_11,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : measurable_space 𝕜,	_inst_19 : normed_group F',	_inst_20 : normed_space 𝕜 F',	_inst_21 : measurable_space F',	_inst_22 : borel_space F',	_inst_23 : topological_space.second_countable_topology F',	_inst_24 : normed_space ℝ F',	_inst_25 : complete_space F',	m m0 : measurable_space α,	μ : measure_theory.measure α,	_inst_38 : borel_space 𝕜,	_inst_39 : is_scalar_tower ℝ 𝕜 F',	hm : m ≤ m0,	_inst_40 : measure_theory.sigma_finite (μ.trim hm),	c : 𝕜,	f : α → F',	hf : measure_theory.integrable f μ	⊢ μ[c • f|hm] =ᵐ[μ] c • μ[f|hm]
α : Type u_1,	F' : Type u_7,	𝕜 : Type u_11,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : measurable_space 𝕜,	_inst_19 : normed_group F',	_inst_20 : normed_space 𝕜 F',	_inst_21 : measurable_space F',	_inst_22 : borel_space F',	_inst_23 : topological_space.second_countable_topology F',	_inst_24 : normed_space ℝ F',	_inst_25 : complete_space F',	m m0 : measurable_space α,	μ : measure_theory.measure α,	_inst_38 : borel_space 𝕜,	_inst_39 : is_scalar_tower ℝ 𝕜 F',	hm : m ≤ m0,	_inst_40 : measure_theory.sigma_finite (μ.trim hm),	c : 𝕜,	f : α → F',	hf : measure_theory.integrable f μ	⊢ ⇑(measure_theory.condexp_L1 hm μ (c • f)) =ᵐ[μ] c • μ[f|hm]
α : Type u_1,	F' : Type u_7,	𝕜 : Type u_11,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : measurable_space 𝕜,	_inst_19 : normed_group F',	_inst_20 : normed_space 𝕜 F',	_inst_21 : measurable_space F',	_inst_22 : borel_space F',	_inst_23 : topological_space.second_countable_topology F',	_inst_24 : normed_space ℝ F',	_inst_25 : complete_space F',	m m0 : measurable_space α,	μ : measure_theory.measure α,	_inst_38 : borel_space 𝕜,	_inst_39 : is_scalar_tower ℝ 𝕜 F',	hm : m ≤ m0,	_inst_40 : measure_theory.sigma_finite (μ.trim hm),	c : 𝕜,	f : α → F',	hf : measure_theory.integrable f μ	⊢ ⇑(c • measure_theory.condexp_L1 hm μ f) =ᵐ[μ] c • μ[f|hm]
α : Type u_1,	F' : Type u_7,	𝕜 : Type u_11,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : measurable_space 𝕜,	_inst_19 : normed_group F',	_inst_20 : normed_space 𝕜 F',	_inst_21 : measurable_space F',	_inst_22 : borel_space F',	_inst_23 : topological_space.second_countable_topology F',	_inst_24 : normed_space ℝ F',	_inst_25 : complete_space F',	m m0 : measurable_space α,	μ : measure_theory.measure α,	_inst_38 : borel_space 𝕜,	_inst_39 : is_scalar_tower ℝ 𝕜 F',	hm : m ≤ m0,	_inst_40 : measure_theory.sigma_finite (μ.trim hm),	c : 𝕜,	f : α → F',	hf : measure_theory.integrable f μ	⊢ ∀ᵐ (x : α) ∂μ, μ[f|hm] x = ⇑(measure_theory.condexp_L1 hm μ f) x → ⇑(c • measure_theory.condexp_L1 hm μ f) x = (c • μ[f|hm]) x
α : Type u_1,	F' : Type u_7,	𝕜 : Type u_11,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : measurable_space 𝕜,	_inst_19 : normed_group F',	_inst_20 : normed_space 𝕜 F',	_inst_21 : measurable_space F',	_inst_22 : borel_space F',	_inst_23 : topological_space.second_countable_topology F',	_inst_24 : normed_space ℝ F',	_inst_25 : complete_space F',	m m0 : measurable_space α,	μ : measure_theory.measure α,	_inst_38 : borel_space 𝕜,	_inst_39 : is_scalar_tower ℝ 𝕜 F',	hm : m ≤ m0,	_inst_40 : measure_theory.sigma_finite (μ.trim hm),	c : 𝕜,	f : α → F',	hf : measure_theory.integrable f μ	⊢ μ[c • f|hm] =ᵐ[μ] c • μ[f|hm]		α : Type u_1,	F' : Type u_7,	𝕜 : Type u_11,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : measurable_space 𝕜,	_inst_19 : normed_group F',	_inst_20 : normed_space 𝕜 F',	_inst_21 : measurable_space F',	_inst_22 : borel_space F',	_inst_23 : topological_space.second_countable_topology F',	_inst_24 : normed_space ℝ F',	_inst_25 : complete_space F',	m m0 : measurable_space α,	μ : measure_theory.measure α,	_inst_38 : borel_space 𝕜,	_inst_39 : is_scalar_tower ℝ 𝕜 F',	hm : m ≤ m0,	_inst_40 : measure_theory.sigma_finite (μ.trim hm),	c : 𝕜,	f : α → F',	hf : ¬measure_theory.integrable f μ	⊢ μ[c • f|hm] =ᵐ[μ] c • μ[f|hm]
α : Type u_1,	F' : Type u_7,	𝕜 : Type u_11,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : measurable_space 𝕜,	_inst_19 : normed_group F',	_inst_20 : normed_space 𝕜 F',	_inst_21 : measurable_space F',	_inst_22 : borel_space F',	_inst_23 : topological_space.second_countable_topology F',	_inst_24 : normed_space ℝ F',	_inst_25 : complete_space F',	m m0 : measurable_space α,	μ : measure_theory.measure α,	_inst_38 : borel_space 𝕜,	_inst_39 : is_scalar_tower ℝ 𝕜 F',	hm : m ≤ m0,	_inst_40 : measure_theory.sigma_finite (μ.trim hm),	c : 𝕜,	f : α → F',	hf : measure_theory.integrable f μ,	x : α,	hx1 : ⇑(c • measure_theory.condexp_L1 hm μ f) x = (c • ⇑(measure_theory.condexp_L1 hm μ f)) x,	hx2 : μ[f|hm] x = ⇑(measure_theory.condexp_L1 hm μ f) x	⊢ ⇑(c • measure_theory.condexp_L1 hm μ f) x = (c • μ[f|hm]) x
α : Type u_1,	F' : Type u_7,	𝕜 : Type u_11,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : measurable_space 𝕜,	_inst_19 : normed_group F',	_inst_20 : normed_space 𝕜 F',	_inst_21 : measurable_space F',	_inst_22 : borel_space F',	_inst_23 : topological_space.second_countable_topology F',	_inst_24 : normed_space ℝ F',	_inst_25 : complete_space F',	m m0 : measurable_space α,	μ : measure_theory.measure α,	_inst_38 : borel_space 𝕜,	_inst_39 : is_scalar_tower ℝ 𝕜 F',	hm : m ≤ m0,	_inst_40 : measure_theory.sigma_finite (μ.trim hm),	c : 𝕜,	f : α → F',	hf : ¬measure_theory.integrable f μ	⊢ μ[c • f|hm] =ᵐ[μ] c • μ[f|hm]
α : Type u_1,	F' : Type u_7,	𝕜 : Type u_11,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : measurable_space 𝕜,	_inst_19 : normed_group F',	_inst_20 : normed_space 𝕜 F',	_inst_21 : measurable_space F',	_inst_22 : borel_space F',	_inst_23 : topological_space.second_countable_topology F',	_inst_24 : normed_space ℝ F',	_inst_25 : complete_space F',	m m0 : measurable_space α,	μ : measure_theory.measure α,	_inst_38 : borel_space 𝕜,	_inst_39 : is_scalar_tower ℝ 𝕜 F',	hm : m ≤ m0,	_inst_40 : measure_theory.sigma_finite (μ.trim hm),	c : 𝕜,	f : α → F',	hf : ¬measure_theory.integrable f μ,	hc : c = 0	⊢ μ[c • f|hm] =ᵐ[μ] c • μ[f|hm]		α : Type u_1,	F' : Type u_7,	𝕜 : Type u_11,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : measurable_space 𝕜,	_inst_19 : normed_group F',	_inst_20 : normed_space 𝕜 F',	_inst_21 : measurable_space F',	_inst_22 : borel_space F',	_inst_23 : topological_space.second_countable_topology F',	_inst_24 : normed_space ℝ F',	_inst_25 : complete_space F',	m m0 : measurable_space α,	μ : measure_theory.measure α,	_inst_38 : borel_space 𝕜,	_inst_39 : is_scalar_tower ℝ 𝕜 F',	hm : m ≤ m0,	_inst_40 : measure_theory.sigma_finite (μ.trim hm),	c : 𝕜,	f : α → F',	hf : ¬measure_theory.integrable f μ,	hc : ¬c = 0	⊢ μ[c • f|hm] =ᵐ[μ] c • μ[f|hm]
α : Type u_1,	F' : Type u_7,	𝕜 : Type u_11,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : measurable_space 𝕜,	_inst_19 : normed_group F',	_inst_20 : normed_space 𝕜 F',	_inst_21 : measurable_space F',	_inst_22 : borel_space F',	_inst_23 : topological_space.second_countable_topology F',	_inst_24 : normed_space ℝ F',	_inst_25 : complete_space F',	m m0 : measurable_space α,	μ : measure_theory.measure α,	_inst_38 : borel_space 𝕜,	_inst_39 : is_scalar_tower ℝ 𝕜 F',	hm : m ≤ m0,	_inst_40 : measure_theory.sigma_finite (μ.trim hm),	c : 𝕜,	f : α → F',	hf : ¬measure_theory.integrable f μ,	hc : c = 0	⊢ μ[c • f|hm] =ᵐ[μ] c • μ[f|hm]
α : Type u_1,	F' : Type u_7,	𝕜 : Type u_11,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : measurable_space 𝕜,	_inst_19 : normed_group F',	_inst_20 : normed_space 𝕜 F',	_inst_21 : measurable_space F',	_inst_22 : borel_space F',	_inst_23 : topological_space.second_countable_topology F',	_inst_24 : normed_space ℝ F',	_inst_25 : complete_space F',	m m0 : measurable_space α,	μ : measure_theory.measure α,	_inst_38 : borel_space 𝕜,	_inst_39 : is_scalar_tower ℝ 𝕜 F',	hm : m ≤ m0,	_inst_40 : measure_theory.sigma_finite (μ.trim hm),	c : 𝕜,	f : α → F',	hf : ¬measure_theory.integrable f μ,	hc : ¬c = 0	⊢ μ[c • f|hm] =ᵐ[μ] c • μ[f|hm]
α : Type u_1,	F' : Type u_7,	𝕜 : Type u_11,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : measurable_space 𝕜,	_inst_19 : normed_group F',	_inst_20 : normed_space 𝕜 F',	_inst_21 : measurable_space F',	_inst_22 : borel_space F',	_inst_23 : topological_space.second_countable_topology F',	_inst_24 : normed_space ℝ F',	_inst_25 : complete_space F',	m m0 : measurable_space α,	μ : measure_theory.measure α,	_inst_38 : borel_space 𝕜,	_inst_39 : is_scalar_tower ℝ 𝕜 F',	hm : m ≤ m0,	_inst_40 : measure_theory.sigma_finite (μ.trim hm),	c : 𝕜,	f : α → F',	hf : ¬measure_theory.integrable f μ,	hc : ¬c = 0	⊢ 0 =ᵐ[μ] c • μ[f|hm]
α : Type u_1,	F' : Type u_7,	𝕜 : Type u_11,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : measurable_space 𝕜,	_inst_19 : normed_group F',	_inst_20 : normed_space 𝕜 F',	_inst_21 : measurable_space F',	_inst_22 : borel_space F',	_inst_23 : topological_space.second_countable_topology F',	_inst_24 : normed_space ℝ F',	_inst_25 : complete_space F',	m m0 : measurable_space α,	μ : measure_theory.measure α,	_inst_38 : borel_space 𝕜,	_inst_39 : is_scalar_tower ℝ 𝕜 F',	hm : m ≤ m0,	_inst_40 : measure_theory.sigma_finite (μ.trim hm),	c : 𝕜,	f : α → F',	hf : ¬measure_theory.integrable f μ,	hc : ¬c = 0,	x : α,	hx : μ[f|hm] x = 0 x	⊢ 0 x = (c • μ[f|hm]) x
α : Type u_1,	F : Type u_6,	p : ℝ≥0∞,	_inst_14 : normed_group F,	_inst_16 : measurable_space F,	_inst_17 : borel_space F,	_inst_18 : topological_space.second_countable_topology F,	m m0 : measurable_space α,	μ : measure_theory.measure α,	hm : m ≤ m0	⊢ function.right_inverse (measure_theory.Lp_trim_to_Lp_meas_subgroup F p μ hm) (measure_theory.Lp_meas_subgroup_to_Lp_trim F p μ hm)
α : Type u_1,	F : Type u_6,	p : ℝ≥0∞,	_inst_14 : normed_group F,	_inst_16 : measurable_space F,	_inst_17 : borel_space F,	_inst_18 : topological_space.second_countable_topology F,	m m0 : measurable_space α,	μ : measure_theory.measure α,	hm : m ≤ m0,	f : ↥(measure_theory.Lp F p (μ.trim hm))	⊢ measure_theory.Lp_meas_subgroup_to_Lp_trim F p μ hm (measure_theory.Lp_trim_to_Lp_meas_subgroup F p μ hm f) = f
α : Type u_1,	F : Type u_6,	p : ℝ≥0∞,	_inst_14 : normed_group F,	_inst_16 : measurable_space F,	_inst_17 : borel_space F,	_inst_18 : topological_space.second_countable_topology F,	m m0 : measurable_space α,	μ : measure_theory.measure α,	hm : m ≤ m0,	f : ↥(measure_theory.Lp F p (μ.trim hm))	⊢ ⇑(measure_theory.Lp_meas_subgroup_to_Lp_trim F p μ hm (measure_theory.Lp_trim_to_Lp_meas_subgroup F p μ hm f)) =ᵐ[μ.trim hm] ⇑f
α : Type u_1,	F : Type u_6,	p : ℝ≥0∞,	_inst_14 : normed_group F,	_inst_16 : measurable_space F,	_inst_17 : borel_space F,	_inst_18 : topological_space.second_countable_topology F,	m m0 : measurable_space α,	μ : measure_theory.measure α,	hm : m ≤ m0,	f : ↥(measure_theory.Lp F p (μ.trim hm))	⊢ ⇑(measure_theory.Lp_meas_subgroup_to_Lp_trim F p μ hm (measure_theory.Lp_trim_to_Lp_meas_subgroup F p μ hm f)) =ᵐ[μ] ⇑f
α : Type u_1,	F : Type u_6,	p : ℝ≥0∞,	_inst_14 : normed_group F,	_inst_16 : measurable_space F,	_inst_17 : borel_space F,	_inst_18 : topological_space.second_countable_topology F,	m m0 : measurable_space α,	μ : measure_theory.measure α,	hp : fact (1 ≤ p),	hm : m ≤ m0,	f : ↥(measure_theory.Lp_meas_subgroup F m p μ)	⊢ ∥measure_theory.Lp_meas_subgroup_to_Lp_trim F p μ hm f∥ = ∥f∥
α : Type u_1,	F : Type u_6,	p : ℝ≥0∞,	_inst_14 : normed_group F,	_inst_16 : measurable_space F,	_inst_17 : borel_space F,	_inst_18 : topological_space.second_countable_topology F,	m m0 : measurable_space α,	μ : measure_theory.measure α,	hp : fact (1 ≤ p),	hm : m ≤ m0,	f : ↥(measure_theory.Lp_meas_subgroup F m p μ)	⊢ opens_measurable_space F
α : Type u_1,	F : Type u_6,	p : ℝ≥0∞,	_inst_14 : normed_group F,	_inst_16 : measurable_space F,	_inst_17 : borel_space F,	_inst_18 : topological_space.second_countable_topology F,	m m0 : measurable_space α,	μ : measure_theory.measure α,	hp : fact (1 ≤ p),	hm : m ≤ m0,	f : ↥(measure_theory.Lp_meas_subgroup F m p μ)	⊢ opens_measurable_space F		α : Type u_1,	F : Type u_6,	p : ℝ≥0∞,	_inst_14 : normed_group F,	_inst_16 : measurable_space F,	_inst_17 : borel_space F,	_inst_18 : topological_space.second_countable_topology F,	m m0 : measurable_space α,	μ : measure_theory.measure α,	hp : fact (1 ≤ p),	hm : m ≤ m0,	f : ↥(measure_theory.Lp_meas_subgroup F m p μ)	⊢ (measure_theory.snorm ⇑(measure_theory.Lp_meas_subgroup_to_Lp_trim F p μ hm f) p μ).to_real = ∥f∥
α : Type u_1,	F : Type u_6,	p : ℝ≥0∞,	_inst_14 : normed_group F,	_inst_16 : measurable_space F,	_inst_17 : borel_space F,	_inst_18 : topological_space.second_countable_topology F,	m m0 : measurable_space α,	μ : measure_theory.measure α,	hp : fact (1 ≤ p),	hm : m ≤ m0,	f : ↥(measure_theory.Lp_meas_subgroup F m p μ)	⊢ (measure_theory.snorm ⇑(measure_theory.Lp_meas_subgroup_to_Lp_trim F p μ hm f) p μ).to_real = ∥f∥		α : Type u_1,	F : Type u_6,	p : ℝ≥0∞,	_inst_14 : normed_group F,	_inst_16 : measurable_space F,	_inst_17 : borel_space F,	_inst_18 : topological_space.second_countable_topology F,	m m0 : measurable_space α,	μ : measure_theory.measure α,	hp : fact (1 ≤ p),	hm : m ≤ m0,	f : ↥(measure_theory.Lp_meas_subgroup F m p μ)	⊢ opens_measurable_space F
α : Type u_1,	F : Type u_6,	p : ℝ≥0∞,	_inst_14 : normed_group F,	_inst_16 : measurable_space F,	_inst_17 : borel_space F,	_inst_18 : topological_space.second_countable_topology F,	m m0 : measurable_space α,	μ : measure_theory.measure α,	hp : fact (1 ≤ p),	hm : m ≤ m0,	f : ↥(measure_theory.Lp_meas_subgroup F m p μ)	⊢ (measure_theory.snorm ⇑(measure_theory.Lp_meas_subgroup_to_Lp_trim F p μ hm f) p μ).to_real = ∥f∥
α : Type u_1,	F : Type u_6,	p : ℝ≥0∞,	_inst_14 : normed_group F,	_inst_16 : measurable_space F,	_inst_17 : borel_space F,	_inst_18 : topological_space.second_countable_topology F,	m m0 : measurable_space α,	μ : measure_theory.measure α,	hp : fact (1 ≤ p),	hm : m ≤ m0,	f : ↥(measure_theory.Lp_meas_subgroup F m p μ)	⊢ ∥↑f∥ = ∥f∥
α : Type u_1,	E' : Type u_5,	𝕜 : Type u_11,	p : ℝ≥0∞,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : measurable_space 𝕜,	_inst_8 : inner_product_space 𝕜 E',	_inst_9 : measurable_space E',	_inst_10 : borel_space E',	_inst_11 : topological_space.second_countable_topology E',	_inst_12 : complete_space E',	_inst_13 : normed_space ℝ E',	m m0 : measurable_space α,	μ : measure_theory.measure α,	_inst_38 : borel_space 𝕜,	hm : m ≤ m0,	f : ↥(measure_theory.Lp E' p μ),	hp_ne_zero : p ≠ 0,	hp_ne_top : p ≠ ⊤,	hf_int_finite : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → measure_theory.integrable_on ⇑f s μ,	hf_zero : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → ∫ (x : α) in s, ⇑f x ∂μ = 0,	hf_meas : measure_theory.ae_measurable' m ⇑f μ	⊢ ⇑f =ᵐ[μ] 0
α : Type u_1,	E' : Type u_5,	𝕜 : Type u_11,	p : ℝ≥0∞,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : measurable_space 𝕜,	_inst_8 : inner_product_space 𝕜 E',	_inst_9 : measurable_space E',	_inst_10 : borel_space E',	_inst_11 : topological_space.second_countable_topology E',	_inst_12 : complete_space E',	_inst_13 : normed_space ℝ E',	m m0 : measurable_space α,	μ : measure_theory.measure α,	_inst_38 : borel_space 𝕜,	hm : m ≤ m0,	f : ↥(measure_theory.Lp E' p μ),	hp_ne_zero : p ≠ 0,	hp_ne_top : p ≠ ⊤,	hf_int_finite : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → measure_theory.integrable_on ⇑f s μ,	hf_zero : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → ∫ (x : α) in s, ⇑f x ∂μ = 0,	hf_meas : measure_theory.ae_measurable' m ⇑f μ,	f_meas : ↥(measure_theory.Lp_meas E' 𝕜 m p μ) := ⟨f, hf_meas⟩	⊢ ⇑f =ᵐ[μ] ⇑f_meas
α : Type u_1,	E' : Type u_5,	𝕜 : Type u_11,	p : ℝ≥0∞,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : measurable_space 𝕜,	_inst_8 : inner_product_space 𝕜 E',	_inst_9 : measurable_space E',	_inst_10 : borel_space E',	_inst_11 : topological_space.second_countable_topology E',	_inst_12 : complete_space E',	_inst_13 : normed_space ℝ E',	m m0 : measurable_space α,	μ : measure_theory.measure α,	_inst_38 : borel_space 𝕜,	hm : m ≤ m0,	f : ↥(measure_theory.Lp E' p μ),	hp_ne_zero : p ≠ 0,	hp_ne_top : p ≠ ⊤,	hf_int_finite : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → measure_theory.integrable_on ⇑f s μ,	hf_zero : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → ∫ (x : α) in s, ⇑f x ∂μ = 0,	hf_meas : measure_theory.ae_measurable' m ⇑f μ,	f_meas : ↥(measure_theory.Lp_meas E' 𝕜 m p μ) := ⟨f, hf_meas⟩	⊢ ⇑f =ᵐ[μ] 0
α : Type u_1,	E' : Type u_5,	𝕜 : Type u_11,	p : ℝ≥0∞,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : measurable_space 𝕜,	_inst_8 : inner_product_space 𝕜 E',	_inst_9 : measurable_space E',	_inst_10 : borel_space E',	_inst_11 : topological_space.second_countable_topology E',	_inst_12 : complete_space E',	_inst_13 : normed_space ℝ E',	m m0 : measurable_space α,	μ : measure_theory.measure α,	_inst_38 : borel_space 𝕜,	hm : m ≤ m0,	f : ↥(measure_theory.Lp E' p μ),	hp_ne_zero : p ≠ 0,	hp_ne_top : p ≠ ⊤,	hf_int_finite : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → measure_theory.integrable_on ⇑f s μ,	hf_zero : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → ∫ (x : α) in s, ⇑f x ∂μ = 0,	hf_meas : measure_theory.ae_measurable' m ⇑f μ,	f_meas : ↥(measure_theory.Lp_meas E' 𝕜 m p μ) := ⟨f, hf_meas⟩,	hf_f_meas : ⇑f =ᵐ[μ] ⇑f_meas	⊢ ⇑f =ᵐ[μ] 0
α : Type u_1,	E' : Type u_5,	𝕜 : Type u_11,	p : ℝ≥0∞,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : measurable_space 𝕜,	_inst_8 : inner_product_space 𝕜 E',	_inst_9 : measurable_space E',	_inst_10 : borel_space E',	_inst_11 : topological_space.second_countable_topology E',	_inst_12 : complete_space E',	_inst_13 : normed_space ℝ E',	m m0 : measurable_space α,	μ : measure_theory.measure α,	_inst_38 : borel_space 𝕜,	hm : m ≤ m0,	f : ↥(measure_theory.Lp E' p μ),	hp_ne_zero : p ≠ 0,	hp_ne_top : p ≠ ⊤,	hf_int_finite : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → measure_theory.integrable_on ⇑f s μ,	hf_zero : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → ∫ (x : α) in s, ⇑f x ∂μ = 0,	hf_meas : measure_theory.ae_measurable' m ⇑f μ,	f_meas : ↥(measure_theory.Lp_meas E' 𝕜 m p μ) := ⟨f, hf_meas⟩,	hf_f_meas : ⇑f =ᵐ[μ] ⇑f_meas	⊢ ⇑f_meas =ᵐ[μ] 0
α : Type u_1,	E' : Type u_5,	𝕜 : Type u_11,	p : ℝ≥0∞,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : measurable_space 𝕜,	_inst_8 : inner_product_space 𝕜 E',	_inst_9 : measurable_space E',	_inst_10 : borel_space E',	_inst_11 : topological_space.second_countable_topology E',	_inst_12 : complete_space E',	_inst_13 : normed_space ℝ E',	m m0 : measurable_space α,	μ : measure_theory.measure α,	_inst_38 : borel_space 𝕜,	hm : m ≤ m0,	f : ↥(measure_theory.Lp E' p μ),	hp_ne_zero : p ≠ 0,	hp_ne_top : p ≠ ⊤,	hf_int_finite : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → measure_theory.integrable_on ⇑f s μ,	hf_zero : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → ∫ (x : α) in s, ⇑f x ∂μ = 0,	hf_meas : measure_theory.ae_measurable' m ⇑f μ,	f_meas : ↥(measure_theory.Lp_meas E' 𝕜 m p μ) := ⟨f, hf_meas⟩,	hf_f_meas : ⇑f =ᵐ[μ] ⇑f_meas	⊢ ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → measure_theory.integrable_on ⇑f_meas s μ
α : Type u_1,	E' : Type u_5,	𝕜 : Type u_11,	p : ℝ≥0∞,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : measurable_space 𝕜,	_inst_8 : inner_product_space 𝕜 E',	_inst_9 : measurable_space E',	_inst_10 : borel_space E',	_inst_11 : topological_space.second_countable_topology E',	_inst_12 : complete_space E',	_inst_13 : normed_space ℝ E',	m m0 : measurable_space α,	μ : measure_theory.measure α,	_inst_38 : borel_space 𝕜,	hm : m ≤ m0,	f : ↥(measure_theory.Lp E' p μ),	hp_ne_zero : p ≠ 0,	hp_ne_top : p ≠ ⊤,	hf_int_finite : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → measure_theory.integrable_on ⇑f s μ,	hf_zero : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → ∫ (x : α) in s, ⇑f x ∂μ = 0,	hf_meas : measure_theory.ae_measurable' m ⇑f μ,	f_meas : ↥(measure_theory.Lp_meas E' 𝕜 m p μ) := ⟨f, hf_meas⟩,	hf_f_meas : ⇑f =ᵐ[μ] ⇑f_meas,	s : set α,	hs : measurable_set s,	hμs : ⇑μ s < ⊤	⊢ ⇑f =ᵐ[μ.restrict s] ⇑f_meas		α : Type u_1,	E' : Type u_5,	𝕜 : Type u_11,	p : ℝ≥0∞,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : measurable_space 𝕜,	_inst_8 : inner_product_space 𝕜 E',	_inst_9 : measurable_space E',	_inst_10 : borel_space E',	_inst_11 : topological_space.second_countable_topology E',	_inst_12 : complete_space E',	_inst_13 : normed_space ℝ E',	m m0 : measurable_space α,	μ : measure_theory.measure α,	_inst_38 : borel_space 𝕜,	hm : m ≤ m0,	f : ↥(measure_theory.Lp E' p μ),	hp_ne_zero : p ≠ 0,	hp_ne_top : p ≠ ⊤,	hf_int_finite : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → measure_theory.integrable_on ⇑f s μ,	hf_zero : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → ∫ (x : α) in s, ⇑f x ∂μ = 0,	hf_meas : measure_theory.ae_measurable' m ⇑f μ,	f_meas : ↥(measure_theory.Lp_meas E' 𝕜 m p μ) := ⟨f, hf_meas⟩,	hf_f_meas : ⇑f =ᵐ[μ] ⇑f_meas,	s : set α,	hs : measurable_set s,	hμs : ⇑μ s < ⊤,	hfg_restrict : ⇑f =ᵐ[μ.restrict s] ⇑f_meas	⊢ measure_theory.integrable_on ⇑f_meas s μ
α : Type u_1,	E' : Type u_5,	𝕜 : Type u_11,	p : ℝ≥0∞,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : measurable_space 𝕜,	_inst_8 : inner_product_space 𝕜 E',	_inst_9 : measurable_space E',	_inst_10 : borel_space E',	_inst_11 : topological_space.second_countable_topology E',	_inst_12 : complete_space E',	_inst_13 : normed_space ℝ E',	m m0 : measurable_space α,	μ : measure_theory.measure α,	_inst_38 : borel_space 𝕜,	hm : m ≤ m0,	f : ↥(measure_theory.Lp E' p μ),	hp_ne_zero : p ≠ 0,	hp_ne_top : p ≠ ⊤,	hf_int_finite : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → measure_theory.integrable_on ⇑f s μ,	hf_zero : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → ∫ (x : α) in s, ⇑f x ∂μ = 0,	hf_meas : measure_theory.ae_measurable' m ⇑f μ,	f_meas : ↥(measure_theory.Lp_meas E' 𝕜 m p μ) := ⟨f, hf_meas⟩,	hf_f_meas : ⇑f =ᵐ[μ] ⇑f_meas,	s : set α,	hs : measurable_set s,	hμs : ⇑μ s < ⊤	⊢ measure_theory.integrable_on ⇑f_meas s μ
α : Type u_1,	E' : Type u_5,	𝕜 : Type u_11,	p : ℝ≥0∞,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : measurable_space 𝕜,	_inst_8 : inner_product_space 𝕜 E',	_inst_9 : measurable_space E',	_inst_10 : borel_space E',	_inst_11 : topological_space.second_countable_topology E',	_inst_12 : complete_space E',	_inst_13 : normed_space ℝ E',	m m0 : measurable_space α,	μ : measure_theory.measure α,	_inst_38 : borel_space 𝕜,	hm : m ≤ m0,	f : ↥(measure_theory.Lp E' p μ),	hp_ne_zero : p ≠ 0,	hp_ne_top : p ≠ ⊤,	hf_int_finite : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → measure_theory.integrable_on ⇑f s μ,	hf_zero : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → ∫ (x : α) in s, ⇑f x ∂μ = 0,	hf_meas : measure_theory.ae_measurable' m ⇑f μ,	f_meas : ↥(measure_theory.Lp_meas E' 𝕜 m p μ) := ⟨f, hf_meas⟩,	hf_f_meas : ⇑f =ᵐ[μ] ⇑f_meas,	s : set α,	hs : measurable_set s,	hμs : ⇑μ s < ⊤,	hfg_restrict : ⇑f =ᵐ[μ.restrict s] ⇑f_meas	⊢ measure_theory.integrable_on ⇑f_meas s μ
α : Type u_1,	E' : Type u_5,	𝕜 : Type u_11,	p : ℝ≥0∞,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : measurable_space 𝕜,	_inst_8 : inner_product_space 𝕜 E',	_inst_9 : measurable_space E',	_inst_10 : borel_space E',	_inst_11 : topological_space.second_countable_topology E',	_inst_12 : complete_space E',	_inst_13 : normed_space ℝ E',	m m0 : measurable_space α,	μ : measure_theory.measure α,	_inst_38 : borel_space 𝕜,	hm : m ≤ m0,	f : ↥(measure_theory.Lp E' p μ),	hp_ne_zero : p ≠ 0,	hp_ne_top : p ≠ ⊤,	hf_int_finite : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → measure_theory.integrable_on ⇑f s μ,	hf_zero : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → ∫ (x : α) in s, ⇑f x ∂μ = 0,	hf_meas : measure_theory.ae_measurable' m ⇑f μ,	f_meas : ↥(measure_theory.Lp_meas E' 𝕜 m p μ) := ⟨f, hf_meas⟩,	hf_f_meas : ⇑f =ᵐ[μ] ⇑f_meas	⊢ ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → measure_theory.integrable_on ⇑f_meas s μ		α : Type u_1,	E' : Type u_5,	𝕜 : Type u_11,	p : ℝ≥0∞,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : measurable_space 𝕜,	_inst_8 : inner_product_space 𝕜 E',	_inst_9 : measurable_space E',	_inst_10 : borel_space E',	_inst_11 : topological_space.second_countable_topology E',	_inst_12 : complete_space E',	_inst_13 : normed_space ℝ E',	m m0 : measurable_space α,	μ : measure_theory.measure α,	_inst_38 : borel_space 𝕜,	hm : m ≤ m0,	f : ↥(measure_theory.Lp E' p μ),	hp_ne_zero : p ≠ 0,	hp_ne_top : p ≠ ⊤,	hf_int_finite : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → measure_theory.integrable_on ⇑f s μ,	hf_zero : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → ∫ (x : α) in s, ⇑f x ∂μ = 0,	hf_meas : measure_theory.ae_measurable' m ⇑f μ,	f_meas : ↥(measure_theory.Lp_meas E' 𝕜 m p μ) := ⟨f, hf_meas⟩,	hf_f_meas : ⇑f =ᵐ[μ] ⇑f_meas	⊢ ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → ∫ (x : α) in s, ⇑f_meas x ∂μ = 0
α : Type u_1,	E' : Type u_5,	𝕜 : Type u_11,	p : ℝ≥0∞,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : measurable_space 𝕜,	_inst_8 : inner_product_space 𝕜 E',	_inst_9 : measurable_space E',	_inst_10 : borel_space E',	_inst_11 : topological_space.second_countable_topology E',	_inst_12 : complete_space E',	_inst_13 : normed_space ℝ E',	m m0 : measurable_space α,	μ : measure_theory.measure α,	_inst_38 : borel_space 𝕜,	hm : m ≤ m0,	f : ↥(measure_theory.Lp E' p μ),	hp_ne_zero : p ≠ 0,	hp_ne_top : p ≠ ⊤,	hf_int_finite : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → measure_theory.integrable_on ⇑f s μ,	hf_zero : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → ∫ (x : α) in s, ⇑f x ∂μ = 0,	hf_meas : measure_theory.ae_measurable' m ⇑f μ,	f_meas : ↥(measure_theory.Lp_meas E' 𝕜 m p μ) := ⟨f, hf_meas⟩,	hf_f_meas : ⇑f =ᵐ[μ] ⇑f_meas,	s : set α,	hs : measurable_set s,	hμs : ⇑μ s < ⊤,	hfg_restrict : ⇑f =ᵐ[μ.restrict s] ⇑f_meas	⊢ measure_theory.integrable ⇑f (μ.restrict s)
α : Type u_1,	E' : Type u_5,	𝕜 : Type u_11,	p : ℝ≥0∞,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : measurable_space 𝕜,	_inst_8 : inner_product_space 𝕜 E',	_inst_9 : measurable_space E',	_inst_10 : borel_space E',	_inst_11 : topological_space.second_countable_topology E',	_inst_12 : complete_space E',	_inst_13 : normed_space ℝ E',	m m0 : measurable_space α,	μ : measure_theory.measure α,	_inst_38 : borel_space 𝕜,	hm : m ≤ m0,	f : ↥(measure_theory.Lp E' p μ),	hp_ne_zero : p ≠ 0,	hp_ne_top : p ≠ ⊤,	hf_int_finite : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → measure_theory.integrable_on ⇑f s μ,	hf_zero : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → ∫ (x : α) in s, ⇑f x ∂μ = 0,	hf_meas : measure_theory.ae_measurable' m ⇑f μ,	f_meas : ↥(measure_theory.Lp_meas E' 𝕜 m p μ) := ⟨f, hf_meas⟩,	hf_f_meas : ⇑f =ᵐ[μ] ⇑f_meas	⊢ ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → ∫ (x : α) in s, ⇑f_meas x ∂μ = 0
α : Type u_1,	E' : Type u_5,	𝕜 : Type u_11,	p : ℝ≥0∞,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : measurable_space 𝕜,	_inst_8 : inner_product_space 𝕜 E',	_inst_9 : measurable_space E',	_inst_10 : borel_space E',	_inst_11 : topological_space.second_countable_topology E',	_inst_12 : complete_space E',	_inst_13 : normed_space ℝ E',	m m0 : measurable_space α,	μ : measure_theory.measure α,	_inst_38 : borel_space 𝕜,	hm : m ≤ m0,	f : ↥(measure_theory.Lp E' p μ),	hp_ne_zero : p ≠ 0,	hp_ne_top : p ≠ ⊤,	hf_int_finite : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → measure_theory.integrable_on ⇑f s μ,	hf_zero : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → ∫ (x : α) in s, ⇑f x ∂μ = 0,	hf_meas : measure_theory.ae_measurable' m ⇑f μ,	f_meas : ↥(measure_theory.Lp_meas E' 𝕜 m p μ) := ⟨f, hf_meas⟩,	hf_f_meas : ⇑f =ᵐ[μ] ⇑f_meas,	s : set α,	hs : measurable_set s,	hμs : ⇑μ s < ⊤	⊢ ⇑f =ᵐ[μ.restrict s] ⇑f_meas		α : Type u_1,	E' : Type u_5,	𝕜 : Type u_11,	p : ℝ≥0∞,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : measurable_space 𝕜,	_inst_8 : inner_product_space 𝕜 E',	_inst_9 : measurable_space E',	_inst_10 : borel_space E',	_inst_11 : topological_space.second_countable_topology E',	_inst_12 : complete_space E',	_inst_13 : normed_space ℝ E',	m m0 : measurable_space α,	μ : measure_theory.measure α,	_inst_38 : borel_space 𝕜,	hm : m ≤ m0,	f : ↥(measure_theory.Lp E' p μ),	hp_ne_zero : p ≠ 0,	hp_ne_top : p ≠ ⊤,	hf_int_finite : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → measure_theory.integrable_on ⇑f s μ,	hf_zero : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → ∫ (x : α) in s, ⇑f x ∂μ = 0,	hf_meas : measure_theory.ae_measurable' m ⇑f μ,	f_meas : ↥(measure_theory.Lp_meas E' 𝕜 m p μ) := ⟨f, hf_meas⟩,	hf_f_meas : ⇑f =ᵐ[μ] ⇑f_meas,	s : set α,	hs : measurable_set s,	hμs : ⇑μ s < ⊤,	hfg_restrict : ⇑f =ᵐ[μ.restrict s] ⇑f_meas	⊢ ∫ (x : α) in s, ⇑f_meas x ∂μ = 0
α : Type u_1,	E' : Type u_5,	𝕜 : Type u_11,	p : ℝ≥0∞,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : measurable_space 𝕜,	_inst_8 : inner_product_space 𝕜 E',	_inst_9 : measurable_space E',	_inst_10 : borel_space E',	_inst_11 : topological_space.second_countable_topology E',	_inst_12 : complete_space E',	_inst_13 : normed_space ℝ E',	m m0 : measurable_space α,	μ : measure_theory.measure α,	_inst_38 : borel_space 𝕜,	hm : m ≤ m0,	f : ↥(measure_theory.Lp E' p μ),	hp_ne_zero : p ≠ 0,	hp_ne_top : p ≠ ⊤,	hf_int_finite : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → measure_theory.integrable_on ⇑f s μ,	hf_zero : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → ∫ (x : α) in s, ⇑f x ∂μ = 0,	hf_meas : measure_theory.ae_measurable' m ⇑f μ,	f_meas : ↥(measure_theory.Lp_meas E' 𝕜 m p μ) := ⟨f, hf_meas⟩,	hf_f_meas : ⇑f =ᵐ[μ] ⇑f_meas,	s : set α,	hs : measurable_set s,	hμs : ⇑μ s < ⊤	⊢ ∫ (x : α) in s, ⇑f_meas x ∂μ = 0
α : Type u_1,	E' : Type u_5,	𝕜 : Type u_11,	p : ℝ≥0∞,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : measurable_space 𝕜,	_inst_8 : inner_product_space 𝕜 E',	_inst_9 : measurable_space E',	_inst_10 : borel_space E',	_inst_11 : topological_space.second_countable_topology E',	_inst_12 : complete_space E',	_inst_13 : normed_space ℝ E',	m m0 : measurable_space α,	μ : measure_theory.measure α,	_inst_38 : borel_space 𝕜,	hm : m ≤ m0,	f : ↥(measure_theory.Lp E' p μ),	hp_ne_zero : p ≠ 0,	hp_ne_top : p ≠ ⊤,	hf_int_finite : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → measure_theory.integrable_on ⇑f s μ,	hf_zero : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → ∫ (x : α) in s, ⇑f x ∂μ = 0,	hf_meas : measure_theory.ae_measurable' m ⇑f μ,	f_meas : ↥(measure_theory.Lp_meas E' 𝕜 m p μ) := ⟨f, hf_meas⟩,	hf_f_meas : ⇑f =ᵐ[μ] ⇑f_meas,	s : set α,	hs : measurable_set s,	hμs : ⇑μ s < ⊤,	hfg_restrict : ⇑f =ᵐ[μ.restrict s] ⇑f_meas	⊢ ∫ (x : α) in s, ⇑f_meas x ∂μ = 0
α : Type u_1,	E' : Type u_5,	𝕜 : Type u_11,	p : ℝ≥0∞,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : measurable_space 𝕜,	_inst_8 : inner_product_space 𝕜 E',	_inst_9 : measurable_space E',	_inst_10 : borel_space E',	_inst_11 : topological_space.second_countable_topology E',	_inst_12 : complete_space E',	_inst_13 : normed_space ℝ E',	m m0 : measurable_space α,	μ : measure_theory.measure α,	_inst_38 : borel_space 𝕜,	hm : m ≤ m0,	f : ↥(measure_theory.Lp E' p μ),	hp_ne_zero : p ≠ 0,	hp_ne_top : p ≠ ⊤,	hf_int_finite : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → measure_theory.integrable_on ⇑f s μ,	hf_zero : ∀ (s : set α), measurable_set s → ⇑μ s < ⊤ → ∫ (x : α) in s, ⇑f x ∂μ = 0,	hf_meas : measure_theory.ae_measurable' m ⇑f μ,	f_meas : ↥(measure_theory.Lp_meas E' 𝕜 m p μ) := ⟨f, hf_meas⟩,	hf_f_meas : ⇑f =ᵐ[μ] ⇑f_meas,	s : set α,	hs : measurable_set s,	hμs : ⇑μ s < ⊤,	hfg_restrict : ⇑f =ᵐ[μ.restrict s] ⇑f_meas	⊢ ∫ (a : α) in s, ⇑f a ∂μ = 0
α : Type u_1,	β : Type u_2,	m m0 : measurable_space α,	μ : measure_theory.measure α,	_inst_1 : measurable_space β,	f g : α → β,	hfg : f =ᵐ[μ] g,	f' : α → β,	hf'_meas : measurable f',	hff' : f =ᵐ[μ] f'	⊢ measure_theory.ae_measurable' m g μ
α : Type u_1,	β : Type u_2,	m m0 : measurable_space α,	μ : measure_theory.measure α,	_inst_1 : measurable_space β,	f g : α → β,	hf : measure_theory.ae_measurable' m f μ,	hfg : f =ᵐ[μ] g	⊢ measure_theory.ae_measurable' m g μ
α : Type u_1,	β : Type u_2,	γ : Type u_3,	m : measurable_space α,	μ : measure_theory.measure α,	_inst_1 : normed_group β,	_inst_2 : normed_group γ,	f : α → β,	g : α → γ,	hg : measure_theory.has_finite_integral g μ,	h : ∀ᵐ (a : α) ∂μ, ∥f a∥ ≤ ∥g a∥	⊢ measure_theory.has_finite_integral f μ
α : Type u_1,	β : Type u_2,	γ : Type u_3,	m : measurable_space α,	μ : measure_theory.measure α,	_inst_1 : normed_group β,	_inst_2 : normed_group γ,	f : α → β,	g : α → γ,	h : ∀ᵐ (a : α) ∂μ, ∥f a∥ ≤ ∥g a∥,	hg : ∫⁻ (a : α), ennreal.of_real ∥g a∥ ∂μ < ⊤	⊢ ∫⁻ (a : α), ennreal.of_real ∥f a∥ ∂μ < ⊤
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measure_theory.has_finite_integral f μ,	x : α	⊢ ∥linear_order.max (f x) 0∥ ≤ ∥f x∥
α : Type u_1,	β : Type u_2,	m : measurable_space α,	μ : measure_theory.measure α,	_inst_1 : normed_group β,	_inst_3 : measurable_space β,	f : α → β	⊢ measure_theory.mem_ℒp f 1 μ ↔ measure_theory.integrable f μ
α : Type u_1,	β : Type u_2,	m : measurable_space α,	μ : measure_theory.measure α,	_inst_1 : normed_group β,	_inst_3 : measurable_space β,	_inst_6 : borel_space β,	_inst_7 : topological_space.second_countable_topology β,	f g : α →ₘ[μ] β	⊢ f.integrable → g.integrable → (f + g).integrable
α : Type u_1,	β : Type u_2,	m : measurable_space α,	μ : measure_theory.measure α,	_inst_1 : normed_group β,	_inst_3 : measurable_space β,	_inst_6 : borel_space β,	_inst_7 : topological_space.second_countable_topology β,	f g : α →ₘ[μ] β,	f : α → β,	hf : ae_measurable f μ,	g : α → β,	hg : ae_measurable g μ,	hfi : (measure_theory.ae_eq_fun.mk f hf).integrable,	hgi : (measure_theory.ae_eq_fun.mk g hg).integrable	⊢ (measure_theory.ae_eq_fun.mk f hf + measure_theory.ae_eq_fun.mk g hg).integrable
α : Type u_1,	β : Type u_2,	m : measurable_space α,	μ : measure_theory.measure α,	_inst_1 : normed_group β,	_inst_3 : measurable_space β,	_inst_6 : borel_space β,	_inst_7 : topological_space.second_countable_topology β,	f g : α →ₘ[μ] β,	f : α → β,	hf : ae_measurable f μ,	g : α → β,	hg : ae_measurable g μ,	hgi : measure_theory.integrable g μ,	hfi : measure_theory.integrable f μ	⊢ measure_theory.integrable (f + g) μ
α : Type u_1,	β : Type u_2,	m : measurable_space α,	μ : measure_theory.measure α,	_inst_1 : normed_group β,	_inst_3 : measurable_space β,	_inst_6 : topological_space.second_countable_topology β,	_inst_7 : borel_space β,	f : ↥(measure_theory.Lp β 1 μ)	⊢ ∫⁻ (a : α), ↑∥⇑f a∥₊ ∂μ ≠ ⊤
α : Type u_1,	β : Type u_2,	m : measurable_space α,	μ : measure_theory.measure α,	_inst_1 : normed_group β,	_inst_3 : measurable_space β,	_inst_6 : topological_space.second_countable_topology β,	_inst_7 : borel_space β,	f : ↥(measure_theory.Lp β 1 μ)	⊢ ennreal.of_real ∥f∥ = ∫⁻ (x : α), ↑∥⇑f x∥₊ ∂μ
α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ℝ≥0∞,	μ : measure_theory.measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : topological_space.second_countable_topology E	⊢ ∥0∥ = 0
α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ℝ≥0∞,	μ : measure_theory.measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : topological_space.second_countable_topology E	⊢ (measure_theory.snorm ⇑0 p μ).to_real = 0
α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ℝ≥0∞,	μ : measure_theory.measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : topological_space.second_countable_topology E,	_inst_7 : measure_theory.is_finite_measure μ,	f : ↥(measure_theory.Lp E p μ),	C : ℝ,	hC : 0 ≤ C,	hfC : ∀ᵐ (x : α) ∂μ, ∥⇑f x∥ ≤ C	⊢ ∥f∥ ≤ ↑(measure_theory.measure_univ_nnreal μ) ^ (p.to_real)⁻¹ * C
α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ℝ≥0∞,	μ : measure_theory.measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : topological_space.second_countable_topology E,	_inst_7 : measure_theory.is_finite_measure μ,	f : ↥(measure_theory.Lp E p μ),	C : ℝ,	hC : 0 ≤ C,	hfC : ∀ᵐ (x : α) ∂μ, ∥⇑f x∥ ≤ C,	hμ : μ = 0	⊢ ∥f∥ ≤ ↑(measure_theory.measure_univ_nnreal μ) ^ (p.to_real)⁻¹ * C
α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ℝ≥0∞,	μ : measure_theory.measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : topological_space.second_countable_topology E,	_inst_7 : measure_theory.is_finite_measure μ,	f : ↥(measure_theory.Lp E p μ),	C : ℝ,	hC : 0 ≤ C,	hfC : ∀ᵐ (x : α) ∂μ, ∥⇑f x∥ ≤ C,	hμ : μ = 0,	hp : (p.to_real)⁻¹ = 0	⊢ ∥f∥ ≤ ↑(measure_theory.measure_univ_nnreal μ) ^ (p.to_real)⁻¹ * C		α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ℝ≥0∞,	μ : measure_theory.measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : topological_space.second_countable_topology E,	_inst_7 : measure_theory.is_finite_measure μ,	f : ↥(measure_theory.Lp E p μ),	C : ℝ,	hC : 0 ≤ C,	hfC : ∀ᵐ (x : α) ∂μ, ∥⇑f x∥ ≤ C,	hμ : μ = 0,	hp : ¬(p.to_real)⁻¹ = 0	⊢ ∥f∥ ≤ ↑(measure_theory.measure_univ_nnreal μ) ^ (p.to_real)⁻¹ * C
α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ℝ≥0∞,	μ : measure_theory.measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : topological_space.second_countable_topology E,	_inst_7 : measure_theory.is_finite_measure μ,	f : ↥(measure_theory.Lp E p μ),	C : ℝ,	hC : 0 ≤ C,	hfC : ∀ᵐ (x : α) ∂μ, ∥⇑f x∥ ≤ C,	hμ : μ = 0,	hp : (p.to_real)⁻¹ = 0	⊢ ∥f∥ ≤ ↑(measure_theory.measure_univ_nnreal μ) ^ (p.to_real)⁻¹ * C
α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ℝ≥0∞,	μ : measure_theory.measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : topological_space.second_countable_topology E,	_inst_7 : measure_theory.is_finite_measure μ,	f : ↥(measure_theory.Lp E p μ),	C : ℝ,	hC : 0 ≤ C,	hfC : ∀ᵐ (x : α) ∂μ, ∥⇑f x∥ ≤ C,	hμ : μ = 0	⊢ ∥f∥ ≤ ↑(measure_theory.measure_univ_nnreal μ) ^ (p.to_real)⁻¹ * C		α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ℝ≥0∞,	μ : measure_theory.measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : topological_space.second_countable_topology E,	_inst_7 : measure_theory.is_finite_measure μ,	f : ↥(measure_theory.Lp E p μ),	C : ℝ,	hC : 0 ≤ C,	hfC : ∀ᵐ (x : α) ∂μ, ∥⇑f x∥ ≤ C,	hμ : ¬μ = 0	⊢ ∥f∥ ≤ ↑(measure_theory.measure_univ_nnreal μ) ^ (p.to_real)⁻¹ * C
α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ℝ≥0∞,	μ : measure_theory.measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : topological_space.second_countable_topology E,	_inst_7 : measure_theory.is_finite_measure μ,	f : ↥(measure_theory.Lp E p μ),	C : ℝ,	hC : 0 ≤ C,	hfC : ∀ᵐ (x : α) ∂μ, ∥⇑f x∥ ≤ C,	hμ : μ = 0,	hp : ¬(p.to_real)⁻¹ = 0	⊢ ∥f∥ ≤ ↑(measure_theory.measure_univ_nnreal μ) ^ (p.to_real)⁻¹ * C
α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ℝ≥0∞,	μ : measure_theory.measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : topological_space.second_countable_topology E,	_inst_7 : measure_theory.is_finite_measure μ,	f : ↥(measure_theory.Lp E p μ),	C : ℝ,	hC : 0 ≤ C,	hfC : ∀ᵐ (x : α) ∂μ, ∥⇑f x∥ ≤ C,	hμ : ¬μ = 0	⊢ ∥f∥ ≤ ↑(measure_theory.measure_univ_nnreal μ) ^ (p.to_real)⁻¹ * C
α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ℝ≥0∞,	μ : measure_theory.measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : topological_space.second_countable_topology E,	_inst_7 : measure_theory.is_finite_measure μ,	f : ↥(measure_theory.Lp E p μ),	C : ℝ,	hC : 0 ≤ C,	hfC : ∀ᵐ (x : α) ∂μ, ∥⇑f x∥ ≤ C,	hμ : ¬μ = 0,	A : ℝ≥0 := measure_theory.measure_univ_nnreal μ ^ (p.to_real)⁻¹ * ⟨C, hC⟩	⊢ ∥f∥ ≤ ↑(measure_theory.measure_univ_nnreal μ) ^ (p.to_real)⁻¹ * C
α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ℝ≥0∞,	μ : measure_theory.measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : topological_space.second_countable_topology E,	_inst_7 : measure_theory.is_finite_measure μ,	f : ↥(measure_theory.Lp E p μ),	C : ℝ,	hC : 0 ≤ C,	hfC : ∀ᵐ (x : α) ∂μ, ∥⇑f x∥ ≤ C,	hμ : ¬μ = 0,	A : ℝ≥0 := measure_theory.measure_univ_nnreal μ ^ (p.to_real)⁻¹ * ⟨C, hC⟩,	this : measure_theory.snorm ⇑f p μ ≤ ↑A	⊢ ∥f∥ ≤ ↑(measure_theory.measure_univ_nnreal μ) ^ (p.to_real)⁻¹ * C		α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ℝ≥0∞,	μ : measure_theory.measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : topological_space.second_countable_topology E,	_inst_7 : measure_theory.is_finite_measure μ,	f : ↥(measure_theory.Lp E p μ),	C : ℝ,	hC : 0 ≤ C,	hfC : ∀ᵐ (x : α) ∂μ, ∥⇑f x∥ ≤ C,	hμ : ¬μ = 0,	A : ℝ≥0 := measure_theory.measure_univ_nnreal μ ^ (p.to_real)⁻¹ * ⟨C, hC⟩	⊢ measure_theory.snorm ⇑f p μ ≤ ↑A
α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ℝ≥0∞,	μ : measure_theory.measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : topological_space.second_countable_topology E,	_inst_7 : measure_theory.is_finite_measure μ,	f : ↥(measure_theory.Lp E p μ),	C : ℝ,	hC : 0 ≤ C,	hfC : ∀ᵐ (x : α) ∂μ, ∥⇑f x∥ ≤ C,	hμ : ¬μ = 0,	A : ℝ≥0 := measure_theory.measure_univ_nnreal μ ^ (p.to_real)⁻¹ * ⟨C, hC⟩,	this : measure_theory.snorm ⇑f p μ ≤ ↑A	⊢ ∥f∥ ≤ ↑(measure_theory.measure_univ_nnreal μ) ^ (p.to_real)⁻¹ * C
α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ℝ≥0∞,	μ : measure_theory.measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : topological_space.second_countable_topology E,	_inst_7 : measure_theory.is_finite_measure μ,	f : ↥(measure_theory.Lp E p μ),	C : ℝ,	hC : 0 ≤ C,	hfC : ∀ᵐ (x : α) ∂μ, ∥⇑f x∥ ≤ C,	hμ : ¬μ = 0,	A : ℝ≥0 := measure_theory.measure_univ_nnreal μ ^ (p.to_real)⁻¹ * ⟨C, hC⟩	⊢ measure_theory.snorm ⇑f p μ ≤ ↑A
α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ℝ≥0∞,	μ : measure_theory.measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : topological_space.second_countable_topology E,	_inst_7 : measure_theory.is_finite_measure μ,	f : ↥(measure_theory.Lp E p μ),	C : ℝ,	hC : 0 ≤ C,	hfC : ∀ᵐ (x : α) ∂μ, ∥⇑f x∥ ≤ C,	hμ : ¬μ = 0,	A : ℝ≥0 := measure_theory.measure_univ_nnreal μ ^ (p.to_real)⁻¹ * ⟨C, hC⟩	⊢ ↑A = ⇑μ set.univ ^ (p.to_real)⁻¹ * ennreal.of_real C
α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ℝ≥0∞,	μ : measure_theory.measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : topological_space.second_countable_topology E,	_inst_7 : measure_theory.is_finite_measure μ,	f : ↥(measure_theory.Lp E p μ),	C : ℝ,	hC : 0 ≤ C,	hfC : ∀ᵐ (x : α) ∂μ, ∥⇑f x∥ ≤ C,	hμ : ¬μ = 0,	A : ℝ≥0 := measure_theory.measure_univ_nnreal μ ^ (p.to_real)⁻¹ * ⟨C, hC⟩	⊢ ↑(measure_theory.measure_univ_nnreal μ ^ (p.to_real)⁻¹) * ↑⟨C, hC⟩ = ↑(measure_theory.measure_univ_nnreal μ ^ (p.to_real)⁻¹) * ennreal.of_real C
α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ℝ≥0∞,	μ : measure_theory.measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : topological_space.second_countable_topology E,	_inst_7 : measure_theory.is_finite_measure μ,	f : ↥(measure_theory.Lp E p μ),	C : ℝ,	hC : 0 ≤ C,	hfC : ∀ᵐ (x : α) ∂μ, ∥⇑f x∥ ≤ C,	hμ : ¬μ = 0,	A : ℝ≥0 := measure_theory.measure_univ_nnreal μ ^ (p.to_real)⁻¹ * ⟨C, hC⟩	⊢ C = linear_order.max C 0
α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	μ : measure_theory.measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : topological_space.second_countable_topology E	⊢ normed_group ↥(measure_theory.Lp E 1 μ)
α : Type u_1,	G : Type u_4,	m0 : measurable_space α,	p : ℝ≥0∞,	μ : measure_theory.measure α,	_inst_4 : normed_group G,	s : set α,	c : G,	hs : measurable_set s,	hμs : ⇑μ s ≠ 0,	hp : p ≠ 0	⊢ measure_theory.snorm (s.indicator (λ (_x : α), c)) p μ = ↑∥c∥₊ * ⇑μ s ^ (1 / p.to_real)
α : Type u_1,	G : Type u_4,	m0 : measurable_space α,	p : ℝ≥0∞,	μ : measure_theory.measure α,	_inst_4 : normed_group G,	s : set α,	c : G,	hs : measurable_set s,	hμs : ⇑μ s ≠ 0,	hp : p ≠ 0,	hp_top : p = ⊤	⊢ measure_theory.snorm (s.indicator (λ (_x : α), c)) p μ = ↑∥c∥₊ * ⇑μ s ^ (1 / p.to_real)
α : Type u_1,	G : Type u_4,	m0 : measurable_space α,	p : ℝ≥0∞,	μ : measure_theory.measure α,	_inst_4 : normed_group G,	s : set α,	c : G,	hs : measurable_set s,	hμs : ⇑μ s ≠ 0,	hp : p ≠ 0,	hp_top : p = ⊤	⊢ measure_theory.snorm (s.indicator (λ (_x : α), c)) p μ = ↑∥c∥₊ * ⇑μ s ^ (1 / p.to_real)		α : Type u_1,	G : Type u_4,	m0 : measurable_space α,	p : ℝ≥0∞,	μ : measure_theory.measure α,	_inst_4 : normed_group G,	s : set α,	c : G,	hs : measurable_set s,	hμs : ⇑μ s ≠ 0,	hp : p ≠ 0,	hp_top : ¬p = ⊤	⊢ measure_theory.snorm (s.indicator (λ (_x : α), c)) p μ = ↑∥c∥₊ * ⇑μ s ^ (1 / p.to_real)
α : Type u_1,	G : Type u_4,	m0 : measurable_space α,	p : ℝ≥0∞,	μ : measure_theory.measure α,	_inst_4 : normed_group G,	s : set α,	c : G,	hs : measurable_set s,	hμs : ⇑μ s ≠ 0,	hp : p ≠ 0,	hp_top : ¬p = ⊤	⊢ measure_theory.snorm (s.indicator (λ (_x : α), c)) p μ = ↑∥c∥₊ * ⇑μ s ^ (1 / p.to_real)
α : Type u_1,	m0 : measurable_space α,	μ : measure_theory.measure α,	E : Type u_2,	_inst_7 : measurable_space E,	_inst_8 : normed_group E,	_inst_9 : borel_space E,	f : ℕ → α → E,	p : ℝ,	hp_pos : 0 < p,	hf : ∀ (n : ℕ), ae_measurable (f n) μ,	f_lim : α → E,	h_lim : ∀ᵐ (x : α) ∂μ, filter.tendsto (λ (n : ℕ), f n x) filter.at_top (𝓝 (f_lim x))	⊢ measure_theory.snorm' f_lim p μ ≤ filter.at_top.liminf (λ (n : ℕ), measure_theory.snorm' (f n) p μ)
α : Type u_1,	m0 : measurable_space α,	μ : measure_theory.measure α,	E : Type u_2,	_inst_7 : measurable_space E,	_inst_8 : normed_group E,	_inst_9 : borel_space E,	f : ℕ → α → E,	p : ℝ,	hp_pos : 0 < p,	hf : ∀ (n : ℕ), ae_measurable (f n) μ,	f_lim : α → E,	h_lim : ∀ᵐ (x : α) ∂μ, filter.tendsto (λ (n : ℕ), f n x) filter.at_top (𝓝 (f_lim x))	⊢ (∫⁻ (a : α), filter.at_top.liminf (λ (m : ℕ), ↑∥(λ (n : ℕ) (x : α), f n x) m a∥₊ ^ p) ∂μ) ^ (1 / p) ≤ filter.at_top.liminf (λ (n : ℕ), measure_theory.snorm' (f n) p μ)
α : Type u_1,	m0 : measurable_space α,	μ : measure_theory.measure α,	E : Type u_2,	_inst_7 : measurable_space E,	_inst_8 : normed_group E,	_inst_9 : borel_space E,	f : ℕ → α → E,	p : ℝ,	hp_pos : 0 < p,	hf : ∀ (n : ℕ), ae_measurable (f n) μ,	f_lim : α → E,	h_lim : ∀ᵐ (x : α) ∂μ, filter.tendsto (λ (n : ℕ), f n x) filter.at_top (𝓝 (f_lim x))	⊢ 0 < 1 / p
α : Type u_1,	m0 : measurable_space α,	μ : measure_theory.measure α,	E : Type u_2,	_inst_7 : measurable_space E,	_inst_8 : normed_group E,	_inst_9 : borel_space E,	f : ℕ → α → E,	p : ℝ,	hp_pos : 0 < p,	hf : ∀ (n : ℕ), ae_measurable (f n) μ,	f_lim : α → E,	h_lim : ∀ᵐ (x : α) ∂μ, filter.tendsto (λ (n : ℕ), f n x) filter.at_top (𝓝 (f_lim x))	⊢ ∫⁻ (a : α), filter.at_top.liminf (λ (m : ℕ), ↑∥(λ (n : ℕ) (x : α), f n x) m a∥₊ ^ p) ∂μ ≤ filter.at_top.liminf (λ (n : ℕ), measure_theory.snorm' (f n) p μ) ^ p
α : Type u_1,	m0 : measurable_space α,	μ : measure_theory.measure α,	E : Type u_2,	_inst_7 : measurable_space E,	_inst_8 : normed_group E,	_inst_9 : borel_space E,	f : ℕ → α → E,	p : ℝ,	hp_pos : 0 < p,	hf : ∀ (n : ℕ), ae_measurable (f n) μ,	f_lim : α → E,	h_lim : ∀ᵐ (x : α) ∂μ, filter.tendsto (λ (n : ℕ), f n x) filter.at_top (𝓝 (f_lim x))	⊢ filter.at_top.liminf (λ (n : ℕ), ∫⁻ (a : α), ↑∥f n a∥₊ ^ p ∂μ) = filter.at_top.liminf (λ (n : ℕ), measure_theory.snorm' (f n) p μ) ^ p
α : Type u_1,	m0 : measurable_space α,	μ : measure_theory.measure α,	E : Type u_2,	_inst_7 : measurable_space E,	_inst_8 : normed_group E,	_inst_9 : borel_space E,	f : ℕ → α → E,	p : ℝ,	hp_pos : 0 < p,	hf : ∀ (n : ℕ), ae_measurable (f n) μ,	f_lim : α → E,	h_lim : ∀ᵐ (x : α) ∂μ, filter.tendsto (λ (n : ℕ), f n x) filter.at_top (𝓝 (f_lim x))	⊢ filter.at_top.liminf (λ (n : ℕ), measure_theory.snorm' (f n) p μ) ^ p = filter.at_top.liminf (λ (n : ℕ), measure_theory.snorm' (f n) p μ ^ p)
α : Type u_1,	m0 : measurable_space α,	μ : measure_theory.measure α,	E : Type u_2,	_inst_7 : measurable_space E,	_inst_8 : normed_group E,	_inst_9 : borel_space E,	f : ℕ → α → E,	p : ℝ,	hp_pos : 0 < p,	hf : ∀ (n : ℕ), ae_measurable (f n) μ,	f_lim : α → E,	h_lim : ∀ᵐ (x : α) ∂μ, filter.tendsto (λ (n : ℕ), f n x) filter.at_top (𝓝 (f_lim x)),	h_rpow_mono : strict_mono (λ (y : ℝ≥0∞), y ^ p)	⊢ filter.at_top.liminf (λ (n : ℕ), measure_theory.snorm' (f n) p μ) ^ p = filter.at_top.liminf (λ (n : ℕ), measure_theory.snorm' (f n) p μ ^ p)
α : Type u_1,	m0 : measurable_space α,	μ : measure_theory.measure α,	E : Type u_2,	_inst_7 : measurable_space E,	_inst_8 : normed_group E,	_inst_9 : borel_space E,	f : ℕ → α → E,	p : ℝ,	hp_pos : 0 < p,	hf : ∀ (n : ℕ), ae_measurable (f n) μ,	f_lim : α → E,	h_lim : ∀ᵐ (x : α) ∂μ, filter.tendsto (λ (n : ℕ), f n x) filter.at_top (𝓝 (f_lim x)),	h_rpow_mono : strict_mono (λ (y : ℝ≥0∞), y ^ p),	h_rpow_surj : function.surjective (λ (y : ℝ≥0∞), y ^ p)	⊢ filter.at_top.liminf (λ (n : ℕ), measure_theory.snorm' (f n) p μ) ^ p = filter.at_top.liminf (λ (n : ℕ), measure_theory.snorm' (f n) p μ ^ p)
α : Type u_1,	m0 : measurable_space α,	μ : measure_theory.measure α,	E : Type u_2,	_inst_7 : measurable_space E,	_inst_8 : normed_group E,	_inst_9 : borel_space E,	f : ℕ → α → E,	p : ℝ,	hp_pos : 0 < p,	hf : ∀ (n : ℕ), ae_measurable (f n) μ,	f_lim : α → E,	h_lim : ∀ᵐ (x : α) ∂μ, filter.tendsto (λ (n : ℕ), f n x) filter.at_top (𝓝 (f_lim x)),	h_rpow_mono : strict_mono (λ (y : ℝ≥0∞), y ^ p),	h_rpow_surj : function.surjective (λ (y : ℝ≥0∞), y ^ p)	⊢ auto_param (filter.is_bounded_under ge filter.at_top (λ (n : ℕ), measure_theory.snorm' (f n) p μ)) (name.mk_string "is_bounded_default" (name.mk_string "filter" name.anonymous))
α : Type u_1,	m0 : measurable_space α,	μ : measure_theory.measure α,	E : Type u_2,	_inst_7 : measurable_space E,	_inst_8 : normed_group E,	_inst_9 : borel_space E,	f : ℕ → α → E,	p : ℝ,	hp_pos : 0 < p,	hf : ∀ (n : ℕ), ae_measurable (f n) μ,	f_lim : α → E,	h_lim : ∀ᵐ (x : α) ∂μ, filter.tendsto (λ (n : ℕ), f n x) filter.at_top (𝓝 (f_lim x)),	h_rpow_mono : strict_mono (λ (y : ℝ≥0∞), y ^ p),	h_rpow_surj : function.surjective (λ (y : ℝ≥0∞), y ^ p)	⊢ auto_param (filter.is_cobounded_under ge filter.at_top (λ (n : ℕ), measure_theory.snorm' (f n) p μ)) (name.mk_string "is_bounded_default" (name.mk_string "filter" name.anonymous))
α : Type u_1,	m0 : measurable_space α,	μ : measure_theory.measure α,	E : Type u_2,	_inst_7 : measurable_space E,	_inst_8 : normed_group E,	_inst_9 : borel_space E,	f : ℕ → α → E,	p : ℝ,	hp_pos : 0 < p,	hf : ∀ (n : ℕ), ae_measurable (f n) μ,	f_lim : α → E,	h_lim : ∀ᵐ (x : α) ∂μ, filter.tendsto (λ (n : ℕ), f n x) filter.at_top (𝓝 (f_lim x)),	h_rpow_mono : strict_mono (λ (y : ℝ≥0∞), y ^ p),	h_rpow_surj : function.surjective (λ (y : ℝ≥0∞), y ^ p)	⊢ auto_param (filter.is_bounded_under ge filter.at_top (λ (x : ℕ), ⇑(strict_mono.order_iso_of_surjective (λ (y : ℝ≥0∞), y ^ p) h_rpow_mono h_rpow_surj) (measure_theory.snorm' (f x) p μ))) (name.mk_string "is_bounded_default" (name.mk_string "filter" name.anonymous))
α : Type u_1,	m0 : measurable_space α,	μ : measure_theory.measure α,	E : Type u_2,	_inst_7 : measurable_space E,	_inst_8 : normed_group E,	_inst_9 : borel_space E,	f : ℕ → α → E,	p : ℝ,	hp_pos : 0 < p,	hf : ∀ (n : ℕ), ae_measurable (f n) μ,	f_lim : α → E,	h_lim : ∀ᵐ (x : α) ∂μ, filter.tendsto (λ (n : ℕ), f n x) filter.at_top (𝓝 (f_lim x)),	h_rpow_mono : strict_mono (λ (y : ℝ≥0∞), y ^ p),	h_rpow_surj : function.surjective (λ (y : ℝ≥0∞), y ^ p)	⊢ auto_param (filter.is_cobounded_under ge filter.at_top (λ (x : ℕ), ⇑(strict_mono.order_iso_of_surjective (λ (y : ℝ≥0∞), y ^ p) h_rpow_mono h_rpow_surj) (measure_theory.snorm' (f x) p μ))) (name.mk_string "is_bounded_default" (name.mk_string "filter" name.anonymous))
α : Type u_1,	m0 : measurable_space α,	μ : measure_theory.measure α,	E : Type u_2,	_inst_7 : measurable_space E,	_inst_8 : normed_group E,	_inst_9 : borel_space E,	f : ℕ → α → E,	p : ℝ,	hp_pos : 0 < p,	hf : ∀ (n : ℕ), ae_measurable (f n) μ,	f_lim : α → E,	h_lim : ∀ᵐ (x : α) ∂μ, filter.tendsto (λ (n : ℕ), f n x) filter.at_top (𝓝 (f_lim x))	⊢ filter.at_top.liminf (λ (n : ℕ), measure_theory.snorm' (f n) p μ) ^ p = filter.at_top.liminf (λ (n : ℕ), measure_theory.snorm' (f n) p μ ^ p)		α : Type u_1,	m0 : measurable_space α,	μ : measure_theory.measure α,	E : Type u_2,	_inst_7 : measurable_space E,	_inst_8 : normed_group E,	_inst_9 : borel_space E,	f : ℕ → α → E,	p : ℝ,	hp_pos : 0 < p,	hf : ∀ (n : ℕ), ae_measurable (f n) μ,	f_lim : α → E,	h_lim : ∀ᵐ (x : α) ∂μ, filter.tendsto (λ (n : ℕ), f n x) filter.at_top (𝓝 (f_lim x)),	h_pow_liminf : filter.at_top.liminf (λ (n : ℕ), measure_theory.snorm' (f n) p μ) ^ p = filter.at_top.liminf (λ (n : ℕ), measure_theory.snorm' (f n) p μ ^ p)	⊢ filter.at_top.liminf (λ (n : ℕ), ∫⁻ (a : α), ↑∥f n a∥₊ ^ p ∂μ) = filter.at_top.liminf (λ (n : ℕ), measure_theory.snorm' (f n) p μ) ^ p
α : Type u_1,	m0 : measurable_space α,	μ : measure_theory.measure α,	E : Type u_2,	_inst_7 : measurable_space E,	_inst_8 : normed_group E,	_inst_9 : borel_space E,	f : ℕ → α → E,	p : ℝ,	hp_pos : 0 < p,	hf : ∀ (n : ℕ), ae_measurable (f n) μ,	f_lim : α → E,	h_lim : ∀ᵐ (x : α) ∂μ, filter.tendsto (λ (n : ℕ), f n x) filter.at_top (𝓝 (f_lim x)),	h_rpow_mono : strict_mono (λ (y : ℝ≥0∞), y ^ p),	h_rpow_surj : function.surjective (λ (y : ℝ≥0∞), y ^ p)	⊢ auto_param (filter.is_bounded_under ge filter.at_top (λ (n : ℕ), measure_theory.snorm' (f n) p μ)) (name.mk_string "is_bounded_default" (name.mk_string "filter" name.anonymous))		α : Type u_1,	m0 : measurable_space α,	μ : measure_theory.measure α,	E : Type u_2,	_inst_7 : measurable_space E,	_inst_8 : normed_group E,	_inst_9 : borel_space E,	f : ℕ → α → E,	p : ℝ,	hp_pos : 0 < p,	hf : ∀ (n : ℕ), ae_measurable (f n) μ,	f_lim : α → E,	h_lim : ∀ᵐ (x : α) ∂μ, filter.tendsto (λ (n : ℕ), f n x) filter.at_top (𝓝 (f_lim x)),	h_rpow_mono : strict_mono (λ (y : ℝ≥0∞), y ^ p),	h_rpow_surj : function.surjective (λ (y : ℝ≥0∞), y ^ p)	⊢ auto_param (filter.is_cobounded_under ge filter.at_top (λ (n : ℕ), measure_theory.snorm' (f n) p μ)) (name.mk_string "is_bounded_default" (name.mk_string "filter" name.anonymous))		α : Type u_1,	m0 : measurable_space α,	μ : measure_theory.measure α,	E : Type u_2,	_inst_7 : measurable_space E,	_inst_8 : normed_group E,	_inst_9 : borel_space E,	f : ℕ → α → E,	p : ℝ,	hp_pos : 0 < p,	hf : ∀ (n : ℕ), ae_measurable (f n) μ,	f_lim : α → E,	h_lim : ∀ᵐ (x : α) ∂μ, filter.tendsto (λ (n : ℕ), f n x) filter.at_top (𝓝 (f_lim x)),	h_rpow_mono : strict_mono (λ (y : ℝ≥0∞), y ^ p),	h_rpow_surj : function.surjective (λ (y : ℝ≥0∞), y ^ p)	⊢ auto_param (filter.is_bounded_under ge filter.at_top (λ (x : ℕ), ⇑(strict_mono.order_iso_of_surjective (λ (y : ℝ≥0∞), y ^ p) h_rpow_mono h_rpow_surj) (measure_theory.snorm' (f x) p μ))) (name.mk_string "is_bounded_default" (name.mk_string "filter" name.anonymous))		α : Type u_1,	m0 : measurable_space α,	μ : measure_theory.measure α,	E : Type u_2,	_inst_7 : measurable_space E,	_inst_8 : normed_group E,	_inst_9 : borel_space E,	f : ℕ → α → E,	p : ℝ,	hp_pos : 0 < p,	hf : ∀ (n : ℕ), ae_measurable (f n) μ,	f_lim : α → E,	h_lim : ∀ᵐ (x : α) ∂μ, filter.tendsto (λ (n : ℕ), f n x) filter.at_top (𝓝 (f_lim x)),	h_rpow_mono : strict_mono (λ (y : ℝ≥0∞), y ^ p),	h_rpow_surj : function.surjective (λ (y : ℝ≥0∞), y ^ p)	⊢ auto_param (filter.is_cobounded_under ge filter.at_top (λ (x : ℕ), ⇑(strict_mono.order_iso_of_surjective (λ (y : ℝ≥0∞), y ^ p) h_rpow_mono h_rpow_surj) (measure_theory.snorm' (f x) p μ))) (name.mk_string "is_bounded_default" (name.mk_string "filter" name.anonymous))
α : Type u_1,	m0 : measurable_space α,	μ : measure_theory.measure α,	E : Type u_2,	_inst_7 : measurable_space E,	_inst_8 : normed_group E,	_inst_9 : borel_space E,	f : ℕ → α → E,	p : ℝ,	hp_pos : 0 < p,	hf : ∀ (n : ℕ), ae_measurable (f n) μ,	f_lim : α → E,	h_lim : ∀ᵐ (x : α) ∂μ, filter.tendsto (λ (n : ℕ), f n x) filter.at_top (𝓝 (f_lim x)),	h_pow_liminf : filter.at_top.liminf (λ (n : ℕ), measure_theory.snorm' (f n) p μ) ^ p = filter.at_top.liminf (λ (n : ℕ), measure_theory.snorm' (f n) p μ ^ p)	⊢ filter.at_top.liminf (λ (n : ℕ), ∫⁻ (a : α), ↑∥f n a∥₊ ^ p ∂μ) = filter.at_top.liminf (λ (n : ℕ), measure_theory.snorm' (f n) p μ) ^ p
α : Type u_1,	m0 : measurable_space α,	μ : measure_theory.measure α,	E : Type u_2,	_inst_7 : measurable_space E,	_inst_8 : normed_group E,	_inst_9 : borel_space E,	f : ℕ → α → E,	p : ℝ,	hp_pos : 0 < p,	hf : ∀ (n : ℕ), ae_measurable (f n) μ,	f_lim : α → E,	h_lim : ∀ᵐ (x : α) ∂μ, filter.tendsto (λ (n : ℕ), f n x) filter.at_top (𝓝 (f_lim x)),	h_pow_liminf : filter.at_top.liminf (λ (n : ℕ), measure_theory.snorm' (f n) p μ) ^ p = filter.at_top.liminf (λ (n : ℕ), measure_theory.snorm' (f n) p μ ^ p)	⊢ filter.at_top.liminf (λ (n : ℕ), ∫⁻ (a : α), ↑∥f n a∥₊ ^ p ∂μ) = filter.at_top.liminf (λ (n : ℕ), measure_theory.snorm' (f n) p μ ^ p)
α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ℝ≥0∞,	μ : measure_theory.measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : topological_space.second_countable_topology E,	hp : 1 ≤ p,	f : ℕ → α → E,	hf : ∀ (n : ℕ), measure_theory.mem_ℒp (f n) p μ,	f_lim : α → E,	h_lim_meas : ae_measurable f_lim μ,	h_tendsto : filter.tendsto (λ (n : ℕ), measure_theory.snorm (f n - f_lim) p μ) filter.at_top (𝓝 0)	⊢ measure_theory.mem_ℒp f_lim p μ
α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ℝ≥0∞,	μ : measure_theory.measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : topological_space.second_countable_topology E,	hp : 1 ≤ p,	f : ℕ → α → E,	hf : ∀ (n : ℕ), measure_theory.mem_ℒp (f n) p μ,	f_lim : α → E,	h_lim_meas : ae_measurable f_lim μ,	h_tendsto : filter.tendsto (λ (n : ℕ), measure_theory.snorm (f n - f_lim) p μ) filter.at_top (𝓝 0)	⊢ measure_theory.snorm f_lim p μ < ⊤
α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ℝ≥0∞,	μ : measure_theory.measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : topological_space.second_countable_topology E,	hp : 1 ≤ p,	f : ℕ → α → E,	hf : ∀ (n : ℕ), measure_theory.mem_ℒp (f n) p μ,	f_lim : α → E,	h_lim_meas : ae_measurable f_lim μ,	h_tendsto : ∀ (ε : ℝ≥0∞), ε > 0 → (∃ (N : ℕ), ∀ (n : ℕ), n ≥ N → measure_theory.snorm (f n - f_lim) p μ ≤ ε)	⊢ measure_theory.snorm f_lim p μ < ⊤
α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ℝ≥0∞,	μ : measure_theory.measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : topological_space.second_countable_topology E,	hp : 1 ≤ p,	f : ℕ → α → E,	hf : ∀ (n : ℕ), measure_theory.mem_ℒp (f n) p μ,	f_lim : α → E,	h_lim_meas : ae_measurable f_lim μ,	h_tendsto : ∀ (ε : ℝ≥0∞), ε > 0 → (∃ (N : ℕ), ∀ (n : ℕ), n ≥ N → measure_theory.snorm (f n - f_lim) p μ ≤ ε),	N : ℕ,	h_tendsto_1 : ∀ (n : ℕ), n ≥ N → measure_theory.snorm (f n - f_lim) p μ ≤ 1	⊢ measure_theory.snorm f_lim p μ < ⊤
α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ℝ≥0∞,	μ : measure_theory.measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : topological_space.second_countable_topology E,	hp : 1 ≤ p,	f : ℕ → α → E,	hf : ∀ (n : ℕ), measure_theory.mem_ℒp (f n) p μ,	f_lim : α → E,	h_lim_meas : ae_measurable f_lim μ,	h_tendsto : ∀ (ε : ℝ≥0∞), ε > 0 → (∃ (N : ℕ), ∀ (n : ℕ), n ≥ N → measure_theory.snorm (f n - f_lim) p μ ≤ ε),	N : ℕ,	h_tendsto_1 : measure_theory.snorm (f N - f_lim) p μ ≤ 1	⊢ measure_theory.snorm f_lim p μ < ⊤
α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ℝ≥0∞,	μ : measure_theory.measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : topological_space.second_countable_topology E,	hp : 1 ≤ p,	f : ℕ → α → E,	hf : ∀ (n : ℕ), measure_theory.mem_ℒp (f n) p μ,	f_lim : α → E,	h_lim_meas : ae_measurable f_lim μ,	h_tendsto : ∀ (ε : ℝ≥0∞), ε > 0 → (∃ (N : ℕ), ∀ (n : ℕ), n ≥ N → measure_theory.snorm (f n - f_lim) p μ ≤ ε),	N : ℕ,	h_tendsto_1 : measure_theory.snorm (f N - f_lim) p μ ≤ 1	⊢ f_lim = f_lim - f N + f N
α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ℝ≥0∞,	μ : measure_theory.measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : topological_space.second_countable_topology E,	hp : 1 ≤ p,	f : ℕ → α → E,	hf : ∀ (n : ℕ), measure_theory.mem_ℒp (f n) p μ,	f_lim : α → E,	h_lim_meas : ae_measurable f_lim μ,	h_tendsto : ∀ (ε : ℝ≥0∞), ε > 0 → (∃ (N : ℕ), ∀ (n : ℕ), n ≥ N → measure_theory.snorm (f n - f_lim) p μ ≤ ε),	N : ℕ,	h_tendsto_1 : measure_theory.snorm (f N - f_lim) p μ ≤ 1,	h_add : f_lim = f_lim - f N + f N	⊢ measure_theory.snorm f_lim p μ < ⊤
α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ℝ≥0∞,	μ : measure_theory.measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : topological_space.second_countable_topology E,	hp : 1 ≤ p,	f : ℕ → α → E,	hf : ∀ (n : ℕ), measure_theory.mem_ℒp (f n) p μ,	f_lim : α → E,	h_lim_meas : ae_measurable f_lim μ,	h_tendsto : ∀ (ε : ℝ≥0∞), ε > 0 → (∃ (N : ℕ), ∀ (n : ℕ), n ≥ N → measure_theory.snorm (f n - f_lim) p μ ≤ ε),	N : ℕ,	h_tendsto_1 : measure_theory.snorm (f N - f_lim) p μ ≤ 1,	h_add : f_lim = f_lim - f N + f N	⊢ measure_theory.snorm (f_lim - f N + f N) p μ < ⊤
α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ℝ≥0∞,	μ : measure_theory.measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : topological_space.second_countable_topology E,	hp : 1 ≤ p,	f : ℕ → α → E,	hf : ∀ (n : ℕ), measure_theory.mem_ℒp (f n) p μ,	f_lim : α → E,	h_lim_meas : ae_measurable f_lim μ,	h_tendsto : ∀ (ε : ℝ≥0∞), ε > 0 → (∃ (N : ℕ), ∀ (n : ℕ), n ≥ N → measure_theory.snorm (f n - f_lim) p μ ≤ ε),	N : ℕ,	h_tendsto_1 : measure_theory.snorm (f N - f_lim) p μ ≤ 1,	h_add : f_lim = f_lim - f N + f N	⊢ measure_theory.snorm (f_lim - f N) p μ + measure_theory.snorm (f N) p μ < ⊤
α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ℝ≥0∞,	μ : measure_theory.measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : topological_space.second_countable_topology E,	hp : 1 ≤ p,	f : ℕ → α → E,	hf : ∀ (n : ℕ), measure_theory.mem_ℒp (f n) p μ,	f_lim : α → E,	h_lim_meas : ae_measurable f_lim μ,	h_tendsto : ∀ (ε : ℝ≥0∞), ε > 0 → (∃ (N : ℕ), ∀ (n : ℕ), n ≥ N → measure_theory.snorm (f n - f_lim) p μ ≤ ε),	N : ℕ,	h_tendsto_1 : measure_theory.snorm (f N - f_lim) p μ ≤ 1,	h_add : f_lim = f_lim - f N + f N	⊢ measure_theory.snorm (f_lim - f N) p μ < ⊤ ∧ measure_theory.snorm (f N) p μ < ⊤
α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ℝ≥0∞,	μ : measure_theory.measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : topological_space.second_countable_topology E,	hp : 1 ≤ p,	f : ℕ → α → E,	hf : ∀ (n : ℕ), measure_theory.mem_ℒp (f n) p μ,	f_lim : α → E,	h_lim_meas : ae_measurable f_lim μ,	h_tendsto : ∀ (ε : ℝ≥0∞), ε > 0 → (∃ (N : ℕ), ∀ (n : ℕ), n ≥ N → measure_theory.snorm (f n - f_lim) p μ ≤ ε),	N : ℕ,	h_tendsto_1 : measure_theory.snorm (f N - f_lim) p μ ≤ 1,	h_add : f_lim = f_lim - f N + f N	⊢ measure_theory.snorm (f_lim - f N) p μ < ⊤
α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ℝ≥0∞,	μ : measure_theory.measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : topological_space.second_countable_topology E,	hp : 1 ≤ p,	f : ℕ → α → E,	hf : ∀ (n : ℕ), measure_theory.mem_ℒp (f n) p μ,	f_lim : α → E,	h_lim_meas : ae_measurable f_lim μ,	h_tendsto : ∀ (ε : ℝ≥0∞), ε > 0 → (∃ (N : ℕ), ∀ (n : ℕ), n ≥ N → measure_theory.snorm (f n - f_lim) p μ ≤ ε),	N : ℕ,	h_tendsto_1 : measure_theory.snorm (f N - f_lim) p μ ≤ 1,	h_add : f_lim = f_lim - f N + f N	⊢ f_lim - f N = -(f N - f_lim)
α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ℝ≥0∞,	μ : measure_theory.measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : topological_space.second_countable_topology E,	hp : 1 ≤ p,	f : ℕ → α → E,	hf : ∀ (n : ℕ), measure_theory.mem_ℒp (f n) p μ,	f_lim : α → E,	h_lim_meas : ae_measurable f_lim μ,	h_tendsto : ∀ (ε : ℝ≥0∞), ε > 0 → (∃ (N : ℕ), ∀ (n : ℕ), n ≥ N → measure_theory.snorm (f n - f_lim) p μ ≤ ε),	N : ℕ,	h_tendsto_1 : measure_theory.snorm (f N - f_lim) p μ ≤ 1,	h_add : f_lim = f_lim - f N + f N	⊢ measure_theory.snorm (f_lim - f N) p μ ≤ 1
α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ℝ≥0∞,	μ : measure_theory.measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : topological_space.second_countable_topology E,	hp : 1 ≤ p,	f : ℕ → α → E,	hf : ∀ (n : ℕ), measure_theory.mem_ℒp (f n) p μ,	f_lim : α → E,	h_lim_meas : ae_measurable f_lim μ,	h_tendsto : ∀ (ε : ℝ≥0∞), ε > 0 → (∃ (N : ℕ), ∀ (n : ℕ), n ≥ N → measure_theory.snorm (f n - f_lim) p μ ≤ ε),	N : ℕ,	h_tendsto_1 : measure_theory.snorm (f N - f_lim) p μ ≤ 1,	h_add : f_lim = f_lim - f N + f N	⊢ measure_theory.snorm (f_lim - f N) p μ < ⊤		α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ℝ≥0∞,	μ : measure_theory.measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : topological_space.second_countable_topology E,	hp : 1 ≤ p,	f : ℕ → α → E,	hf : ∀ (n : ℕ), measure_theory.mem_ℒp (f n) p μ,	f_lim : α → E,	h_lim_meas : ae_measurable f_lim μ,	h_tendsto : ∀ (ε : ℝ≥0∞), ε > 0 → (∃ (N : ℕ), ∀ (n : ℕ), n ≥ N → measure_theory.snorm (f n - f_lim) p μ ≤ ε),	N : ℕ,	h_tendsto_1 : measure_theory.snorm (f N - f_lim) p μ ≤ 1,	h_add : f_lim = f_lim - f N + f N	⊢ measure_theory.snorm (f N) p μ < ⊤
α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ℝ≥0∞,	μ : measure_theory.measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : topological_space.second_countable_topology E,	hp : 1 ≤ p,	f : ℕ → α → E,	hf : ∀ (n : ℕ), measure_theory.mem_ℒp (f n) p μ,	f_lim : α → E,	h_lim_meas : ae_measurable f_lim μ,	h_tendsto : ∀ (ε : ℝ≥0∞), ε > 0 → (∃ (N : ℕ), ∀ (n : ℕ), n ≥ N → measure_theory.snorm (f n - f_lim) p μ ≤ ε),	N : ℕ,	h_tendsto_1 : measure_theory.snorm (f N - f_lim) p μ ≤ 1,	h_add : f_lim = f_lim - f N + f N,	h_neg : f_lim - f N = -(f N - f_lim)	⊢ measure_theory.snorm (f_lim - f N) p μ ≤ 1
α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ℝ≥0∞,	μ : measure_theory.measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : topological_space.second_countable_topology E,	hp : 1 ≤ p,	f : ℕ → α → E,	hf : ∀ (n : ℕ), measure_theory.mem_ℒp (f n) p μ,	f_lim : α → E,	h_lim_meas : ae_measurable f_lim μ,	h_tendsto : ∀ (ε : ℝ≥0∞), ε > 0 → (∃ (N : ℕ), ∀ (n : ℕ), n ≥ N → measure_theory.snorm (f n - f_lim) p μ ≤ ε),	N : ℕ,	h_tendsto_1 : measure_theory.snorm (f N - f_lim) p μ ≤ 1,	h_add : f_lim = f_lim - f N + f N	⊢ measure_theory.snorm (f N) p μ < ⊤
α : Type u_1,	F : Type u_3,	m0 : measurable_space α,	q : ℝ,	μ : measure_theory.measure α,	_inst_3 : normed_group F,	c : F,	hq_pos : 0 < q,	_inst_5 : measure_theory.is_probability_measure μ	⊢ measure_theory.snorm' (λ (x : α), c) q μ = ↑∥c∥₊
α : Type u_1,	F : Type u_3,	m0 : measurable_space α,	q : ℝ,	μ : measure_theory.measure α,	_inst_3 : normed_group F,	f : α → F	⊢ measure_theory.snorm' (λ (a : α), ∥f a∥) q μ = measure_theory.snorm' f q μ
α : Type u_1,	F : Type u_3,	m0 : measurable_space α,	q : ℝ,	μ : measure_theory.measure α,	_inst_3 : normed_group F,	hq_pos : 0 < q,	f : α → F	⊢ measure_theory.snorm' f q μ ≤ measure_theory.snorm_ess_sup f μ * ⇑μ set.univ ^ (1 / q)
α : Type u_1,	F : Type u_3,	m0 : measurable_space α,	q : ℝ,	μ : measure_theory.measure α,	_inst_3 : normed_group F,	hq_pos : 0 < q,	f : α → F	⊢ ∫⁻ (a : α), ↑∥f a∥₊ ^ q ∂μ ≤ ∫⁻ (a : α), measure_theory.snorm_ess_sup f μ ^ q ∂μ
α : Type u_1,	F : Type u_3,	m0 : measurable_space α,	q : ℝ,	μ : measure_theory.measure α,	_inst_3 : normed_group F,	hq_pos : 0 < q,	f : α → F	⊢ ∀ᵐ (a : α) ∂μ, ↑∥f a∥₊ ^ q ≤ measure_theory.snorm_ess_sup f μ ^ q
α : Type u_1,	F : Type u_3,	m0 : measurable_space α,	q : ℝ,	μ : measure_theory.measure α,	_inst_3 : normed_group F,	hq_pos : 0 < q,	f : α → F,	h_nnnorm_le_snorm_ess_sup : ∀ᵐ (x : α) ∂μ, ↑∥f x∥₊ ≤ measure_theory.snorm_ess_sup f μ	⊢ ∀ᵐ (a : α) ∂μ, ↑∥f a∥₊ ^ q ≤ measure_theory.snorm_ess_sup f μ ^ q
α : Type u_1,	F : Type u_3,	m0 : measurable_space α,	q : ℝ,	μ : measure_theory.measure α,	_inst_3 : normed_group F,	hq_pos : 0 < q,	f : α → F	⊢ ∫⁻ (a : α), ↑∥f a∥₊ ^ q ∂μ ≤ ∫⁻ (a : α), measure_theory.snorm_ess_sup f μ ^ q ∂μ		α : Type u_1,	F : Type u_3,	m0 : measurable_space α,	q : ℝ,	μ : measure_theory.measure α,	_inst_3 : normed_group F,	hq_pos : 0 < q,	f : α → F,	h_le : ∫⁻ (a : α), ↑∥f a∥₊ ^ q ∂μ ≤ ∫⁻ (a : α), measure_theory.snorm_ess_sup f μ ^ q ∂μ	⊢ measure_theory.snorm' f q μ ≤ measure_theory.snorm_ess_sup f μ * ⇑μ set.univ ^ (1 / q)
α : Type u_1,	F : Type u_3,	m0 : measurable_space α,	q : ℝ,	μ : measure_theory.measure α,	_inst_3 : normed_group F,	hq_pos : 0 < q,	f : α → F,	h_le : ∫⁻ (a : α), ↑∥f a∥₊ ^ q ∂μ ≤ ∫⁻ (a : α), measure_theory.snorm_ess_sup f μ ^ q ∂μ	⊢ measure_theory.snorm' f q μ ≤ measure_theory.snorm_ess_sup f μ * ⇑μ set.univ ^ (1 / q)
α : Type u_1,	F : Type u_3,	m0 : measurable_space α,	q : ℝ,	μ : measure_theory.measure α,	_inst_3 : normed_group F,	hq_pos : 0 < q,	f : α → F,	h_le : ∫⁻ (a : α), ↑∥f a∥₊ ^ q ∂μ ≤ ∫⁻ (a : α), measure_theory.snorm_ess_sup f μ ^ q ∂μ	⊢ (∫⁻ (a : α), ↑∥f a∥₊ ^ q ∂μ) ^ (1 / q) ≤ measure_theory.snorm_ess_sup f μ ^ 1 * ⇑μ set.univ ^ (1 / q)
α : Type u_1,	F : Type u_3,	m0 : measurable_space α,	q : ℝ,	μ : measure_theory.measure α,	_inst_3 : normed_group F,	hq_pos : 0 < q,	f : α → F,	h_le : ∫⁻ (a : α), ↑∥f a∥₊ ^ q ∂μ ≤ ∫⁻ (a : α), measure_theory.snorm_ess_sup f μ ^ q ∂μ	⊢ (∫⁻ (a : α), ↑∥f a∥₊ ^ q ∂μ) ^ (1 / q) ≤ measure_theory.snorm_ess_sup f μ ^ (q * q⁻¹) * ⇑μ set.univ ^ (1 / q)
α : Type u_1,	F : Type u_3,	m0 : measurable_space α,	q : ℝ,	μ : measure_theory.measure α,	_inst_3 : normed_group F,	hq_pos : 0 < q,	f : α → F,	h_le : ∫⁻ (a : α), ↑∥f a∥₊ ^ q ∂μ ≤ ∫⁻ (a : α), measure_theory.snorm_ess_sup f μ ^ q ∂μ	⊢ 0 ≤ q⁻¹
α : Type u_1,	F : Type u_3,	m0 : measurable_space α,	q : ℝ,	μ : measure_theory.measure α,	_inst_3 : normed_group F,	hq_pos : 0 < q,	f : α → F,	h_le : ∫⁻ (a : α), ↑∥f a∥₊ ^ q ∂μ ≤ ∫⁻ (a : α), measure_theory.snorm_ess_sup f μ ^ q ∂μ	⊢ (∫⁻ (a : α), ↑∥f a∥₊ ^ q ∂μ) ^ q⁻¹ ≤ (measure_theory.snorm_ess_sup f μ ^ q * ⇑μ set.univ) ^ q⁻¹
α : Type u_1,	F : Type u_3,	m0 : measurable_space α,	q : ℝ,	μ : measure_theory.measure α,	_inst_3 : normed_group F,	hq_pos : 0 < q,	f : α → F,	h_le : ∫⁻ (a : α), ↑∥f a∥₊ ^ q ∂μ ≤ ∫⁻ (a : α), measure_theory.snorm_ess_sup f μ ^ q ∂μ	⊢ ∫⁻ (a : α), ↑∥f a∥₊ ^ q ∂μ ≤ measure_theory.snorm_ess_sup f μ ^ q * ⇑μ set.univ
α : Type u_1,	E : Type u_2,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	m : measurable_space α,	p q : ℝ,	hp0_lt : 0 < p,	hpq : p ≤ q,	μ : measure_theory.measure α,	_inst_6 : measure_theory.is_probability_measure μ,	f : α → E,	hf : ae_measurable f μ	⊢ measure_theory.snorm' f p μ ≤ measure_theory.snorm' f q μ
α : Type u_1,	E : Type u_2,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	m : measurable_space α,	p q : ℝ,	hp0_lt : 0 < p,	hpq : p ≤ q,	μ : measure_theory.measure α,	_inst_6 : measure_theory.is_probability_measure μ,	f : α → E,	hf : ae_measurable f μ,	h_le_μ : measure_theory.snorm' f p μ ≤ measure_theory.snorm' f q μ * ⇑μ set.univ ^ (1 / p - 1 / q)	⊢ measure_theory.snorm' f p μ ≤ measure_theory.snorm' f q μ
α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	μ : measure_theory.measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	p q : ℝ≥0∞,	hpq : p ≤ q,	_inst_6 : measure_theory.is_probability_measure μ,	f : α → E,	hf : ae_measurable f μ	⊢ measure_theory.snorm f q μ * ⇑μ set.univ ^ (1 / p.to_real - 1 / q.to_real) = measure_theory.snorm f q μ
α : Type u_1,	E : Type u_4,	F : Type u_5,	_inst_1 : measurable_space α,	_inst_2 : normed_group E,	_inst_3 : measurable_space E,	_inst_4 : normed_group F,	μ : measure_theory.measure α,	_inst_5 : measurable_space F,	f : α →ₛ E,	g : α →ₛ F	⊢ measure_theory.integrable ⇑f μ → measure_theory.integrable ⇑g μ → measure_theory.integrable ⇑(f.pair g) μ
α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	f : α → β,	_inst_3 : emetric_space β,	_inst_4 : opens_measurable_space β,	_inst_5 : topological_space.second_countable_topology β,	hf : measurable f	⊢ measure_theory.strongly_measurable f
α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	f : α → β,	_inst_3 : emetric_space β,	_inst_4 : opens_measurable_space β,	_inst_5 : topological_space.second_countable_topology β,	hf : measurable f,	h : is_empty β	⊢ measure_theory.strongly_measurable f
α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	f : α → β,	_inst_3 : emetric_space β,	_inst_4 : opens_measurable_space β,	_inst_5 : topological_space.second_countable_topology β,	hf : measurable f,	h : nonempty β	⊢ measure_theory.strongly_measurable f
α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	f : α → β,	_inst_3 : emetric_space β,	_inst_4 : opens_measurable_space β,	_inst_5 : topological_space.second_countable_topology β,	hf : measurable f	⊢ measure_theory.strongly_measurable f
α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	f : α → β,	_inst_3 : emetric_space β,	_inst_4 : opens_measurable_space β,	_inst_5 : topological_space.second_countable_topology β,	hf : measurable f,	h : is_empty β	⊢ measure_theory.strongly_measurable f		α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	f : α → β,	_inst_3 : emetric_space β,	_inst_4 : opens_measurable_space β,	_inst_5 : topological_space.second_countable_topology β,	hf : measurable f,	h : nonempty β	⊢ measure_theory.strongly_measurable f
α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	f : α → β,	_inst_3 : emetric_space β,	_inst_4 : opens_measurable_space β,	_inst_5 : topological_space.second_countable_topology β,	hf : measurable f,	h : is_empty β	⊢ measure_theory.strongly_measurable f
α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	f : α → β,	_inst_3 : emetric_space β,	_inst_4 : opens_measurable_space β,	_inst_5 : topological_space.second_countable_topology β,	hf : measurable f,	h : nonempty β	⊢ measure_theory.strongly_measurable f
α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	f : α → β,	_inst_3 : emetric_space β,	_inst_4 : opens_measurable_space β,	_inst_5 : topological_space.second_countable_topology β,	hf : measurable f,	h : nonempty β,	inst : inhabited β	⊢ measure_theory.strongly_measurable f
α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	f : α → β,	_inst_3 : emetric_space β,	_inst_4 : opens_measurable_space β,	_inst_5 : topological_space.second_countable_topology β,	hf : measurable f,	h : nonempty β,	inst : inhabited β,	x : α	⊢ f x ∈ closure set.univ
G : Type u_1,	_inst_1 : measurable_space G,	_inst_2 : group G,	_inst_3 : topological_space G,	_inst_4 : topological_group G,	_inst_5 : borel_space G,	μ : measure_theory.measure G,	s : set G,	hs : measurable_set s	⊢ ⇑(μ.inv.inv) s = ⇑μ s
G : Type u_1,	_inst_1 : measurable_space G,	_inst_2 : group G,	_inst_3 : topological_space G,	_inst_4 : topological_group G,	_inst_5 : borel_space G,	μ : measure_theory.measure G	⊢ μ.inv.inv = μ
G : Type u_1,	_inst_1 : measurable_space G,	_inst_2 : group G,	_inst_3 : topological_space G,	_inst_4 : topological_group G,	_inst_5 : borel_space G,	μ : measure_theory.measure G,	s : set G,	hs : measurable_set s	⊢ measurable_set s⁻¹
E : Type ?,	_inst_5 : normed_group E,	_inst_6 : normed_space ℝ E,	_inst_7 : nontrivial E,	_inst_8 : finite_dimensional ℝ E,	_inst_9 : measurable_space E,	_inst_10 : borel_space E,	μ : measure_theory.measure E,	_inst_11 : μ.is_add_haar_measure	⊢ measure_theory.has_no_atoms μ
G : Type u_1,	_inst_1 : topological_space G,	_inst_2 : measurable_space G,	_inst_3 : topological_space.second_countable_topology G,	_inst_4 : borel_space G,	_inst_5 : group G,	_inst_6 : topological_group G,	μ ν : measure_theory.measure G,	_inst_7 : measure_theory.sigma_finite ν,	_inst_8 : measure_theory.sigma_finite μ,	hμ : measure_theory.is_mul_left_invariant ⇑μ,	hν : measure_theory.is_mul_left_invariant ⇑ν,	S : G × G ≃ᵐ G × G := (homeomorph.shear_mul_right G).to_measurable_equiv	⊢ ⇑(measure_theory.measure.map (λ (z : G × G), (z.snd * z.fst, (z.fst)⁻¹))) (μ.prod ν) = μ.prod ν
G : Type u_1,	_inst_1 : topological_space G,	_inst_2 : measurable_space G,	_inst_3 : topological_space.second_countable_topology G,	_inst_4 : borel_space G,	_inst_5 : group G,	_inst_6 : topological_group G,	μ ν : measure_theory.measure G,	_inst_7 : measure_theory.sigma_finite ν,	_inst_8 : measure_theory.sigma_finite μ,	hμ : measure_theory.is_mul_left_invariant ⇑μ,	hν : measure_theory.is_mul_left_invariant ⇑ν,	S : G × G ≃ᵐ G × G := (homeomorph.shear_mul_right G).to_measurable_equiv,	this : ⇑(measure_theory.measure.map ((λ (z : G × G), (z.snd, (z.snd)⁻¹ * z.fst)) ∘ λ (z : G × G), (z.snd, z.snd * z.fst))) (μ.prod ν) = μ.prod ν	⊢ (λ (z : G × G), (z.snd * z.fst, (z.fst)⁻¹)) = (λ (z : G × G), (z.snd, (z.snd)⁻¹ * z.fst)) ∘ λ (z : G × G), (z.snd, z.snd * z.fst)
G : Type u_1,	_inst_1 : topological_space G,	_inst_2 : measurable_space G,	_inst_3 : topological_space.second_countable_topology G,	_inst_4 : borel_space G,	_inst_5 : group G,	_inst_6 : topological_group G,	μ ν : measure_theory.measure G,	_inst_7 : measure_theory.sigma_finite ν,	_inst_8 : measure_theory.sigma_finite μ,	hμ : measure_theory.is_mul_left_invariant ⇑μ,	hν : measure_theory.is_mul_left_invariant ⇑ν,	S : G × G ≃ᵐ G × G := (homeomorph.shear_mul_right G).to_measurable_equiv,	this : ⇑(measure_theory.measure.map ((λ (z : G × G), (z.snd, (z.snd)⁻¹ * z.fst)) ∘ λ (z : G × G), (z.snd, z.snd * z.fst))) (μ.prod ν) = μ.prod ν,	x y : G	⊢ ((x, y).snd * (x, y).fst, ((x, y).fst)⁻¹) = ((λ (z : G × G), (z.snd, (z.snd)⁻¹ * z.fst)) ∘ λ (z : G × G), (z.snd, z.snd * z.fst)) (x, y)
G : Type u_1,	_inst_1 : topological_space G,	_inst_2 : measurable_space G,	_inst_3 : topological_space.second_countable_topology G,	_inst_4 : borel_space G,	_inst_5 : group G,	_inst_6 : topological_group G,	μ ν : measure_theory.measure G,	_inst_7 : measure_theory.sigma_finite ν,	_inst_8 : measure_theory.sigma_finite μ,	hμ : measure_theory.is_mul_left_invariant ⇑μ,	hν : measure_theory.is_mul_left_invariant ⇑ν,	S : G × G ≃ᵐ G × G := (homeomorph.shear_mul_right G).to_measurable_equiv,	this : ⇑(measure_theory.measure.map ((λ (z : G × G), (z.snd, (z.snd)⁻¹ * z.fst)) ∘ λ (z : G × G), (z.snd, z.snd * z.fst))) (μ.prod ν) = μ.prod ν	⊢ ⇑(measure_theory.measure.map (λ (z : G × G), (z.snd * z.fst, (z.fst)⁻¹))) (μ.prod ν) = μ.prod ν		G : Type u_1,	_inst_1 : topological_space G,	_inst_2 : measurable_space G,	_inst_3 : topological_space.second_countable_topology G,	_inst_4 : borel_space G,	_inst_5 : group G,	_inst_6 : topological_group G,	μ ν : measure_theory.measure G,	_inst_7 : measure_theory.sigma_finite ν,	_inst_8 : measure_theory.sigma_finite μ,	hμ : measure_theory.is_mul_left_invariant ⇑μ,	hν : measure_theory.is_mul_left_invariant ⇑ν,	S : G × G ≃ᵐ G × G := (homeomorph.shear_mul_right G).to_measurable_equiv	⊢ ⇑(measure_theory.measure.map ((λ (z : G × G), (z.snd, (z.snd)⁻¹ * z.fst)) ∘ λ (z : G × G), (z.snd, z.snd * z.fst))) (μ.prod ν) = μ.prod ν
G : Type u_1,	_inst_1 : topological_space G,	_inst_2 : measurable_space G,	_inst_3 : topological_space.second_countable_topology G,	_inst_4 : borel_space G,	_inst_5 : group G,	_inst_6 : topological_group G,	μ ν : measure_theory.measure G,	_inst_7 : measure_theory.sigma_finite ν,	_inst_8 : measure_theory.sigma_finite μ,	hμ : measure_theory.is_mul_left_invariant ⇑μ,	hν : measure_theory.is_mul_left_invariant ⇑ν,	S : G × G ≃ᵐ G × G := (homeomorph.shear_mul_right G).to_measurable_equiv,	this : ⇑(measure_theory.measure.map ((λ (z : G × G), (z.snd, (z.snd)⁻¹ * z.fst)) ∘ λ (z : G × G), (z.snd, z.snd * z.fst))) (μ.prod ν) = μ.prod ν	⊢ ⇑(measure_theory.measure.map (λ (z : G × G), (z.snd * z.fst, (z.fst)⁻¹))) (μ.prod ν) = μ.prod ν
G : Type u_1,	_inst_1 : topological_space G,	_inst_2 : measurable_space G,	_inst_3 : topological_space.second_countable_topology G,	_inst_4 : borel_space G,	_inst_5 : group G,	_inst_6 : topological_group G,	μ ν : measure_theory.measure G,	_inst_7 : measure_theory.sigma_finite ν,	_inst_8 : measure_theory.sigma_finite μ,	hμ : measure_theory.is_mul_left_invariant ⇑μ,	hν : measure_theory.is_mul_left_invariant ⇑ν,	S : G × G ≃ᵐ G × G := (homeomorph.shear_mul_right G).to_measurable_equiv	⊢ ⇑(measure_theory.measure.map ((λ (z : G × G), (z.snd, (z.snd)⁻¹ * z.fst)) ∘ λ (z : G × G), (z.snd, z.snd * z.fst))) (μ.prod ν) = μ.prod ν
G : Type u_1,	_inst_1 : topological_space G,	_inst_2 : measurable_space G,	_inst_3 : topological_space.second_countable_topology G,	_inst_4 : borel_space G,	_inst_5 : group G,	_inst_6 : topological_group G,	μ ν : measure_theory.measure G,	_inst_7 : measure_theory.sigma_finite ν,	_inst_8 : measure_theory.sigma_finite μ,	hμ : measure_theory.is_mul_left_invariant ⇑μ,	hν : measure_theory.is_mul_left_invariant ⇑ν	⊢ ⇑(measure_theory.measure.map (λ (z : G × G), (z.snd * z.fst, (z.fst)⁻¹))) (μ.prod ν) = μ.prod ν
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ≥0∞,	hfm : ae_measurable f μ,	hf : ∀ᵐ (x : α) ∂μ, f x < ⊤	⊢ ∫ (a : α), (f a).to_real ∂μ = (∫⁻ (a : α), f a ∂μ).to_real
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ≥0∞,	hfm : ae_measurable f μ,	hf : ∀ᵐ (x : α) ∂μ, f x < ⊤	⊢ (λ (a : α), ennreal.of_real ((λ (x : α), (f x).to_real) a)) =ᵐ[μ] λ (a : α), f a
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ≥0∞,	hfm : ae_measurable f μ,	hf : ∀ᵐ (x : α) ∂μ, f x < ⊤	⊢ (∫⁻ (a : α), ennreal.of_real ((λ (x : α), (f x).to_real) a) ∂μ).to_real = (∫⁻ (a : α), f a ∂μ).to_real
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ≥0∞,	hfm : ae_measurable f μ,	hf : ∀ᵐ (x : α) ∂μ, f x < ⊤,	x : α,	hx : f x < ⊤	⊢ (λ (a : α), ennreal.of_real ((λ (x : α), (f x).to_real) a)) x = f x
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ≥0∞,	hfm : ae_measurable f μ,	hf : ∀ᵐ (x : α) ∂μ, f x < ⊤,	x : α,	hx : f x ≠ ⊤	⊢ (λ (a : α), ennreal.of_real ((λ (x : α), (f x).to_real) a)) x = f x
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ≥0∞,	hfm : ae_measurable f μ,	hf : ∀ᵐ (x : α) ∂μ, f x < ⊤	⊢ (∫⁻ (a : α), ennreal.of_real ((λ (x : α), (f x).to_real) a) ∂μ).to_real = (∫⁻ (a : α), f a ∂μ).to_real		α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ≥0∞,	hfm : ae_measurable f μ,	hf : ∀ᵐ (x : α) ∂μ, f x < ⊤	⊢ 0 ≤ᵐ[μ] λ (x : α), (f x).to_real
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ≥0∞,	hfm : ae_measurable f μ,	hf : ∀ᵐ (x : α) ∂μ, f x < ⊤	⊢ ∀ (x : α), f x < ⊤ → (λ (a : α), ennreal.of_real ((λ (x : α), (f x).to_real) a)) x = f x
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ≥0∞,	hfm : ae_measurable f μ,	hf : ∀ᵐ (x : α) ∂μ, f x < ⊤	⊢ 0 ≤ᵐ[μ] λ (x : α), (f x).to_real
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measure_theory.integrable f μ,	f₁ : ↥(measure_theory.Lp ℝ 1 μ) := measure_theory.integrable.to_L1 f hf	⊢ (∫⁻ (a : α), ennreal.of_real (f a) ∂μ).to_real = ∥measure_theory.Lp.pos_part f₁∥
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measure_theory.integrable f μ,	f₁ : ↥(measure_theory.Lp ℝ 1 μ) := measure_theory.integrable.to_L1 f hf	⊢ (∫⁻ (a : α), ennreal.of_real (f a) ∂μ).to_real = (∫⁻ (a : α), ↑∥⇑(measure_theory.Lp.pos_part f₁) a∥₊ ∂μ).to_real
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measure_theory.integrable f μ,	f₁ : ↥(measure_theory.Lp ℝ 1 μ) := measure_theory.integrable.to_L1 f hf	⊢ ∫⁻ (a : α), ennreal.of_real (f a) ∂μ = ∫⁻ (a : α), ↑∥⇑(measure_theory.Lp.pos_part f₁) a∥₊ ∂μ
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measure_theory.integrable f μ,	f₁ : ↥(measure_theory.Lp ℝ 1 μ) := measure_theory.integrable.to_L1 f hf	⊢ (λ (a : α), ennreal.of_real (f a)) =ᵐ[μ] λ (a : α), ↑∥⇑(measure_theory.Lp.pos_part f₁) a∥₊
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measure_theory.integrable f μ,	f₁ : ↥(measure_theory.Lp ℝ 1 μ) := measure_theory.integrable.to_L1 f hf	⊢ ∀ (a : α), ⇑(measure_theory.Lp.pos_part f₁) a = linear_order.max (⇑f₁ a) 0 → ⇑(measure_theory.integrable.to_L1 f hf) a = f a → ennreal.of_real (f a) = ↑∥⇑(measure_theory.Lp.pos_part f₁) a∥₊
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measure_theory.integrable f μ,	f₁ : ↥(measure_theory.Lp ℝ 1 μ) := measure_theory.integrable.to_L1 f hf,	a : α,	h₁ : ⇑(measure_theory.Lp.pos_part f₁) a = linear_order.max (⇑f₁ a) 0,	h₂ : ⇑(measure_theory.integrable.to_L1 f hf) a = f a	⊢ ennreal.of_real (f a) = ↑∥⇑(measure_theory.Lp.pos_part f₁) a∥₊
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measure_theory.integrable f μ,	f₁ : ↥(measure_theory.Lp ℝ 1 μ) := measure_theory.integrable.to_L1 f hf,	a : α,	h₁ : ⇑(measure_theory.Lp.pos_part f₁) a = linear_order.max (⇑f₁ a) 0,	h₂ : ⇑(measure_theory.integrable.to_L1 f hf) a = f a	⊢ ↑((f a).to_nnreal) = ↑∥linear_order.max (f a) 0∥₊
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measure_theory.integrable f μ,	f₁ : ↥(measure_theory.Lp ℝ 1 μ) := measure_theory.integrable.to_L1 f hf,	a : α,	h₁ : ⇑(measure_theory.Lp.pos_part f₁) a = linear_order.max (⇑f₁ a) 0,	h₂ : ⇑(measure_theory.integrable.to_L1 f hf) a = f a	⊢ (f a).to_nnreal = ∥linear_order.max (f a) 0∥₊
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measure_theory.integrable f μ,	f₁ : ↥(measure_theory.Lp ℝ 1 μ) := measure_theory.integrable.to_L1 f hf,	a : α,	h₁ : ⇑(measure_theory.Lp.pos_part f₁) a = linear_order.max (⇑f₁ a) 0,	h₂ : ⇑(measure_theory.integrable.to_L1 f hf) a = f a	⊢ ↑((f a).to_nnreal) = ↑∥linear_order.max (f a) 0∥₊
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measure_theory.integrable f μ,	f₁ : ↥(measure_theory.Lp ℝ 1 μ) := measure_theory.integrable.to_L1 f hf,	eq₁ : (∫⁻ (a : α), ennreal.of_real (f a) ∂μ).to_real = ∥measure_theory.Lp.pos_part f₁∥	⊢ (∫⁻ (a : α), ennreal.of_real (-f a) ∂μ).to_real = ∥measure_theory.Lp.neg_part f₁∥
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measure_theory.integrable f μ,	f₁ : ↥(measure_theory.Lp ℝ 1 μ) := measure_theory.integrable.to_L1 f hf,	eq₁ : (∫⁻ (a : α), ennreal.of_real (f a) ∂μ).to_real = ∥measure_theory.Lp.pos_part f₁∥	⊢ (∫⁻ (a : α), ennreal.of_real (-f a) ∂μ).to_real = (∫⁻ (a : α), ↑∥⇑(measure_theory.Lp.neg_part f₁) a∥₊ ∂μ).to_real
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measure_theory.integrable f μ,	f₁ : ↥(measure_theory.Lp ℝ 1 μ) := measure_theory.integrable.to_L1 f hf,	eq₁ : (∫⁻ (a : α), ennreal.of_real (f a) ∂μ).to_real = ∥measure_theory.Lp.pos_part f₁∥	⊢ ∫⁻ (a : α), ennreal.of_real (-f a) ∂μ = ∫⁻ (a : α), ↑∥⇑(measure_theory.Lp.neg_part f₁) a∥₊ ∂μ
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measure_theory.integrable f μ,	f₁ : ↥(measure_theory.Lp ℝ 1 μ) := measure_theory.integrable.to_L1 f hf,	eq₁ : (∫⁻ (a : α), ennreal.of_real (f a) ∂μ).to_real = ∥measure_theory.Lp.pos_part f₁∥	⊢ (λ (a : α), ennreal.of_real (-f a)) =ᵐ[μ] λ (a : α), ↑∥⇑(measure_theory.Lp.neg_part f₁) a∥₊
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measure_theory.integrable f μ,	f₁ : ↥(measure_theory.Lp ℝ 1 μ) := measure_theory.integrable.to_L1 f hf,	eq₁ : (∫⁻ (a : α), ennreal.of_real (f a) ∂μ).to_real = ∥measure_theory.Lp.pos_part f₁∥	⊢ ∀ (a : α), ⇑(measure_theory.Lp.neg_part f₁) a = -linear_order.min (⇑f₁ a) 0 → ⇑(measure_theory.integrable.to_L1 f hf) a = f a → ennreal.of_real (-f a) = ↑∥⇑(measure_theory.Lp.neg_part f₁) a∥₊
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measure_theory.integrable f μ,	f₁ : ↥(measure_theory.Lp ℝ 1 μ) := measure_theory.integrable.to_L1 f hf,	eq₁ : (∫⁻ (a : α), ennreal.of_real (f a) ∂μ).to_real = ∥measure_theory.Lp.pos_part f₁∥,	a : α,	h₁ : ⇑(measure_theory.Lp.neg_part f₁) a = -linear_order.min (⇑f₁ a) 0,	h₂ : ⇑(measure_theory.integrable.to_L1 f hf) a = f a	⊢ ennreal.of_real (-f a) = ↑∥⇑(measure_theory.Lp.neg_part f₁) a∥₊
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measure_theory.integrable f μ,	f₁ : ↥(measure_theory.Lp ℝ 1 μ) := measure_theory.integrable.to_L1 f hf,	eq₁ : (∫⁻ (a : α), ennreal.of_real (f a) ∂μ).to_real = ∥measure_theory.Lp.pos_part f₁∥,	a : α,	h₁ : ⇑(measure_theory.Lp.neg_part f₁) a = -linear_order.min (⇑f₁ a) 0,	h₂ : ⇑(measure_theory.integrable.to_L1 f hf) a = f a	⊢ ↑((-f a).to_nnreal) = ↑∥-linear_order.min (f a) 0∥₊
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measure_theory.integrable f μ,	f₁ : ↥(measure_theory.Lp ℝ 1 μ) := measure_theory.integrable.to_L1 f hf,	eq₁ : (∫⁻ (a : α), ennreal.of_real (f a) ∂μ).to_real = ∥measure_theory.Lp.pos_part f₁∥,	a : α,	h₁ : ⇑(measure_theory.Lp.neg_part f₁) a = -linear_order.min (⇑f₁ a) 0,	h₂ : ⇑(measure_theory.integrable.to_L1 f hf) a = f a	⊢ (-f a).to_nnreal = ∥-linear_order.min (f a) 0∥₊
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measure_theory.integrable f μ,	f₁ : ↥(measure_theory.Lp ℝ 1 μ) := measure_theory.integrable.to_L1 f hf,	eq₁ : (∫⁻ (a : α), ennreal.of_real (f a) ∂μ).to_real = ∥measure_theory.Lp.pos_part f₁∥,	a : α,	h₁ : ⇑(measure_theory.Lp.neg_part f₁) a = -linear_order.min (⇑f₁ a) 0,	h₂ : ⇑(measure_theory.integrable.to_L1 f hf) a = f a	⊢ ↑((-f a).to_nnreal) = ↑∥-linear_order.min (f a) 0∥₊
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measure_theory.integrable f μ,	f₁ : ↥(measure_theory.Lp ℝ 1 μ) := measure_theory.integrable.to_L1 f hf,	eq₁ : (∫⁻ (a : α), ennreal.of_real (f a) ∂μ).to_real = ∥measure_theory.Lp.pos_part f₁∥,	a : α,	h₁ : ⇑(measure_theory.Lp.neg_part f₁) a = -linear_order.min (⇑f₁ a) 0,	h₂ : ⇑(measure_theory.integrable.to_L1 f hf) a = f a	⊢ linear_order.max (-f a) 0 = ↑∥-linear_order.min (f a) 0∥₊
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measure_theory.integrable f μ,	f₁ : ↥(measure_theory.Lp ℝ 1 μ) := measure_theory.integrable.to_L1 f hf,	eq₁ : (∫⁻ (a : α), ennreal.of_real (f a) ∂μ).to_real = ∥measure_theory.Lp.pos_part f₁∥,	eq₂ : (∫⁻ (a : α), ennreal.of_real (-f a) ∂μ).to_real = ∥measure_theory.Lp.neg_part f₁∥	⊢ ∫ (a : α), f a ∂μ = (∫⁻ (a : α), ennreal.of_real (f a) ∂μ).to_real - (∫⁻ (a : α), ennreal.of_real (-f a) ∂μ).to_real
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measure_theory.integrable f μ,	f₁ : ↥(measure_theory.Lp ℝ 1 μ) := measure_theory.integrable.to_L1 f hf,	eq₁ : (∫⁻ (a : α), ennreal.of_real (f a) ∂μ).to_real = ∥measure_theory.Lp.pos_part f₁∥,	eq₂ : (∫⁻ (a : α), ennreal.of_real (-f a) ∂μ).to_real = ∥measure_theory.Lp.neg_part f₁∥	⊢ measure_theory.L1.integral (measure_theory.integrable.to_L1 (λ (a : α), f a) ?m_1) = ∥measure_theory.Lp.pos_part f₁∥ - ∥measure_theory.Lp.neg_part f₁∥		α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measure_theory.integrable f μ,	f₁ : ↥(measure_theory.Lp ℝ 1 μ) := measure_theory.integrable.to_L1 f hf,	eq₁ : (∫⁻ (a : α), ennreal.of_real (f a) ∂μ).to_real = ∥measure_theory.Lp.pos_part f₁∥,	eq₂ : (∫⁻ (a : α), ennreal.of_real (-f a) ∂μ).to_real = ∥measure_theory.Lp.neg_part f₁∥	⊢ measure_theory.integrable (λ (a : α), f a) μ
α : Type u_1,	_inst_1 : measurable_space α,	_inst_4 : topological_space α,	_inst_5 : opens_measurable_space α,	μ : measure_theory.measure α,	s t : set α,	f g : α → ℝ,	hf : measure_theory.integrable_on f s μ,	hg : continuous_on g t,	hs : measurable_set s,	ht : is_compact t,	hst : s ⊆ t	⊢ measure_theory.integrable_on (λ (x : α), f x * g x) s μ
α : Type u_1,	_inst_1 : measurable_space α,	_inst_4 : topological_space α,	_inst_5 : opens_measurable_space α,	μ : measure_theory.measure α,	s t : set α,	f g : α → ℝ,	hf : measure_theory.integrable_on f s μ,	hg : continuous_on g t,	hs : measurable_set s,	ht : is_compact t,	hst : s ⊆ t,	C : ℝ,	hC : ∀ (x : α), x ∈ t → ∥g x∥ ≤ C	⊢ measure_theory.integrable_on (λ (x : α), f x * g x) s μ
α : Type u_1,	_inst_1 : measurable_space α,	_inst_4 : topological_space α,	_inst_5 : opens_measurable_space α,	μ : measure_theory.measure α,	s t : set α,	f g : α → ℝ,	hg : continuous_on g t,	hs : measurable_set s,	ht : is_compact t,	hst : s ⊆ t,	C : ℝ,	hC : ∀ (x : α), x ∈ t → ∥g x∥ ≤ C,	hf : measure_theory.mem_ℒp f 1 (μ.restrict s)	⊢ measure_theory.mem_ℒp (λ (x : α), f x * g x) 1 (μ.restrict s)
α : Type u_1,	_inst_1 : measurable_space α,	_inst_4 : topological_space α,	_inst_5 : opens_measurable_space α,	μ : measure_theory.measure α,	s t : set α,	f g : α → ℝ,	hg : continuous_on g t,	hs : measurable_set s,	ht : is_compact t,	hst : s ⊆ t,	C : ℝ,	hC : ∀ (x : α), x ∈ t → ∥g x∥ ≤ C,	hf : measure_theory.mem_ℒp f 1 (μ.restrict s)	⊢ ∀ᵐ (x : α) ∂μ.restrict s, ∥f x * g x∥ ≤ C * ∥f x∥
α : Type u_1,	_inst_1 : measurable_space α,	_inst_4 : topological_space α,	_inst_5 : opens_measurable_space α,	μ : measure_theory.measure α,	s t : set α,	f g : α → ℝ,	hg : continuous_on g t,	hs : measurable_set s,	ht : is_compact t,	hst : s ⊆ t,	C : ℝ,	hC : ∀ (x : α), x ∈ t → ∥g x∥ ≤ C,	hf : measure_theory.mem_ℒp f 1 (μ.restrict s)	⊢ ∀ (a : α), a ∈ s → ∥f a * g a∥ ≤ C * ∥f a∥
α : Type u_1,	_inst_1 : measurable_space α,	_inst_4 : topological_space α,	_inst_5 : opens_measurable_space α,	μ : measure_theory.measure α,	s t : set α,	f g : α → ℝ,	hg : continuous_on g t,	hs : measurable_set s,	ht : is_compact t,	hst : s ⊆ t,	C : ℝ,	hC : ∀ (x : α), x ∈ t → ∥g x∥ ≤ C,	hf : measure_theory.mem_ℒp f 1 (μ.restrict s),	x : α,	hx : x ∈ s	⊢ ∥f x * g x∥ ≤ C * ∥f x∥
α : Type u_1,	_inst_1 : measurable_space α,	_inst_4 : topological_space α,	_inst_5 : opens_measurable_space α,	μ : measure_theory.measure α,	s t : set α,	f g : α → ℝ,	hg : continuous_on g t,	hs : measurable_set s,	ht : is_compact t,	hst : s ⊆ t,	C : ℝ,	hC : ∀ (x : α), x ∈ t → ∥g x∥ ≤ C,	hf : measure_theory.mem_ℒp f 1 (μ.restrict s),	x : α,	hx : x ∈ s	⊢ abs (g x) * abs (f x) ≤ C * abs (f x)
α : Type u_1,	_inst_1 : measurable_space α,	_inst_4 : topological_space α,	_inst_5 : opens_measurable_space α,	μ : measure_theory.measure α,	s t : set α,	f g : α → ℝ,	hg : continuous_on g t,	hs : measurable_set s,	ht : is_compact t,	hst : s ⊆ t,	C : ℝ,	hC : ∀ (x : α), x ∈ t → ∥g x∥ ≤ C,	hf : measure_theory.mem_ℒp f 1 (μ.restrict s)	⊢ ∀ᵐ (x : α) ∂μ.restrict s, ∥f x * g x∥ ≤ C * ∥f x∥		α : Type u_1,	_inst_1 : measurable_space α,	_inst_4 : topological_space α,	_inst_5 : opens_measurable_space α,	μ : measure_theory.measure α,	s t : set α,	f g : α → ℝ,	hg : continuous_on g t,	hs : measurable_set s,	ht : is_compact t,	hst : s ⊆ t,	C : ℝ,	hC : ∀ (x : α), x ∈ t → ∥g x∥ ≤ C,	hf : measure_theory.mem_ℒp f 1 (μ.restrict s),	this : ∀ᵐ (x : α) ∂μ.restrict s, ∥f x * g x∥ ≤ C * ∥f x∥	⊢ measure_theory.mem_ℒp (λ (x : α), f x * g x) 1 (μ.restrict s)
α : Type u_1,	_inst_1 : measurable_space α,	_inst_4 : topological_space α,	_inst_5 : opens_measurable_space α,	μ : measure_theory.measure α,	s t : set α,	f g : α → ℝ,	hg : continuous_on g t,	hs : measurable_set s,	ht : is_compact t,	hst : s ⊆ t,	C : ℝ,	hC : ∀ (x : α), x ∈ t → ∥g x∥ ≤ C,	hf : measure_theory.mem_ℒp f 1 (μ.restrict s),	this : ∀ᵐ (x : α) ∂μ.restrict s, ∥f x * g x∥ ≤ C * ∥f x∥	⊢ measure_theory.mem_ℒp (λ (x : α), f x * g x) 1 (μ.restrict s)
α : Type u_1,	ι : Type u_2,	E : Type u_3,	_inst_1 : topological_space α,	_inst_2 : linear_order α,	_inst_3 : order_closed_topology α,	_inst_4 : measurable_space α,	_inst_5 : opens_measurable_space α,	μ : measure_theory.measure α,	l : filter ι,	_inst_6 : l.ne_bot,	hcg : l.is_countably_generated,	_inst_7 : measurable_space E,	_inst_8 : normed_group E,	_inst_9 : borel_space E,	a : ι → α,	f : α → E,	hfm : ae_measurable f μ,	_inst_10 : no_bot_order α,	I : ℝ,	b : α,	hfi : ∀ (i : ι), measure_theory.integrable_on f (set.Ioc (a i) b) μ,	ha : filter.tendsto a l filter.at_bot,	h : filter.tendsto (λ (i : ι), ∫ (x : α) in a i..b, ∥f x∥ ∂μ) l (𝓝 I)	⊢ measure_theory.integrable_on f (set.Iic b) μ
α : Type u_1,	ι : Type u_2,	E : Type u_3,	_inst_1 : topological_space α,	_inst_2 : linear_order α,	_inst_3 : order_closed_topology α,	_inst_4 : measurable_space α,	_inst_5 : opens_measurable_space α,	μ : measure_theory.measure α,	l : filter ι,	_inst_6 : l.ne_bot,	hcg : l.is_countably_generated,	_inst_7 : measurable_space E,	_inst_8 : normed_group E,	_inst_9 : borel_space E,	a : ι → α,	f : α → E,	hfm : ae_measurable f μ,	_inst_10 : no_bot_order α,	I : ℝ,	b : α,	hfi : ∀ (i : ι), measure_theory.integrable_on f (set.Ioc (a i) b) μ,	ha : filter.tendsto a l filter.at_bot,	h : filter.tendsto (λ (i : ι), ∫ (x : α) in a i..b, ∥f x∥ ∂μ) l (𝓝 I),	φ : ι → set α := λ (i : ι), set.Ioi (a i)	⊢ measure_theory.integrable_on f (set.Iic b) μ
α : Type u_1,	ι : Type u_2,	E : Type u_3,	_inst_1 : topological_space α,	_inst_2 : linear_order α,	_inst_3 : order_closed_topology α,	_inst_4 : measurable_space α,	_inst_5 : opens_measurable_space α,	μ : measure_theory.measure α,	l : filter ι,	_inst_6 : l.ne_bot,	hcg : l.is_countably_generated,	_inst_7 : measurable_space E,	_inst_8 : normed_group E,	_inst_9 : borel_space E,	a : ι → α,	f : α → E,	hfm : ae_measurable f μ,	_inst_10 : no_bot_order α,	I : ℝ,	b : α,	hfi : ∀ (i : ι), measure_theory.integrable_on f (set.Ioc (a i) b) μ,	ha : filter.tendsto a l filter.at_bot,	h : filter.tendsto (λ (i : ι), ∫ (x : α) in a i..b, ∥f x∥ ∂μ) l (𝓝 I),	φ : ι → set α := λ (i : ι), set.Ioi (a i),	hφ : measure_theory.ae_cover (μ.restrict (set.Iic b)) l φ	⊢ measure_theory.integrable_on f (set.Iic b) μ
α : Type u_1,	ι : Type u_2,	E : Type u_3,	_inst_1 : topological_space α,	_inst_2 : linear_order α,	_inst_3 : order_closed_topology α,	_inst_4 : measurable_space α,	_inst_5 : opens_measurable_space α,	μ : measure_theory.measure α,	l : filter ι,	_inst_6 : l.ne_bot,	hcg : l.is_countably_generated,	_inst_7 : measurable_space E,	_inst_8 : normed_group E,	_inst_9 : borel_space E,	a : ι → α,	f : α → E,	hfm : ae_measurable f μ,	_inst_10 : no_bot_order α,	I : ℝ,	b : α,	hfi : ∀ (i : ι), measure_theory.integrable_on f (set.Ioc (a i) b) μ,	ha : filter.tendsto a l filter.at_bot,	h : filter.tendsto (λ (i : ι), ∫ (x : α) in a i..b, ∥f x∥ ∂μ) l (𝓝 I),	φ : ι → set α := λ (i : ι), set.Ioi (a i),	hφ : measure_theory.ae_cover (μ.restrict (set.Iic b)) l φ	⊢ ∀ (i : ι), measure_theory.integrable_on f (φ i) (μ.restrict (set.Iic b))
α : Type u_1,	ι : Type u_2,	E : Type u_3,	_inst_1 : topological_space α,	_inst_2 : linear_order α,	_inst_3 : order_closed_topology α,	_inst_4 : measurable_space α,	_inst_5 : opens_measurable_space α,	μ : measure_theory.measure α,	l : filter ι,	_inst_6 : l.ne_bot,	hcg : l.is_countably_generated,	_inst_7 : measurable_space E,	_inst_8 : normed_group E,	_inst_9 : borel_space E,	a : ι → α,	f : α → E,	hfm : ae_measurable f μ,	_inst_10 : no_bot_order α,	I : ℝ,	b : α,	hfi : ∀ (i : ι), measure_theory.integrable_on f (set.Ioc (a i) b) μ,	ha : filter.tendsto a l filter.at_bot,	h : filter.tendsto (λ (i : ι), ∫ (x : α) in a i..b, ∥f x∥ ∂μ) l (𝓝 I),	φ : ι → set α := λ (i : ι), set.Ioi (a i),	hφ : measure_theory.ae_cover (μ.restrict (set.Iic b)) l φ,	i : ι	⊢ measure_theory.integrable_on f (φ i) (μ.restrict (set.Iic b))
α : Type u_1,	ι : Type u_2,	E : Type u_3,	_inst_1 : topological_space α,	_inst_2 : linear_order α,	_inst_3 : order_closed_topology α,	_inst_4 : measurable_space α,	_inst_5 : opens_measurable_space α,	μ : measure_theory.measure α,	l : filter ι,	_inst_6 : l.ne_bot,	hcg : l.is_countably_generated,	_inst_7 : measurable_space E,	_inst_8 : normed_group E,	_inst_9 : borel_space E,	a : ι → α,	f : α → E,	hfm : ae_measurable f μ,	_inst_10 : no_bot_order α,	I : ℝ,	b : α,	hfi : ∀ (i : ι), measure_theory.integrable_on f (set.Ioc (a i) b) μ,	ha : filter.tendsto a l filter.at_bot,	h : filter.tendsto (λ (i : ι), ∫ (x : α) in a i..b, ∥f x∥ ∂μ) l (𝓝 I),	φ : ι → set α := λ (i : ι), set.Ioi (a i),	hφ : measure_theory.ae_cover (μ.restrict (set.Iic b)) l φ	⊢ ∀ (i : ι), measure_theory.integrable_on f (φ i) (μ.restrict (set.Iic b))		α : Type u_1,	ι : Type u_2,	E : Type u_3,	_inst_1 : topological_space α,	_inst_2 : linear_order α,	_inst_3 : order_closed_topology α,	_inst_4 : measurable_space α,	_inst_5 : opens_measurable_space α,	μ : measure_theory.measure α,	l : filter ι,	_inst_6 : l.ne_bot,	hcg : l.is_countably_generated,	_inst_7 : measurable_space E,	_inst_8 : normed_group E,	_inst_9 : borel_space E,	a : ι → α,	f : α → E,	hfm : ae_measurable f μ,	_inst_10 : no_bot_order α,	I : ℝ,	b : α,	hfi : ∀ (i : ι), measure_theory.integrable_on f (set.Ioc (a i) b) μ,	ha : filter.tendsto a l filter.at_bot,	h : filter.tendsto (λ (i : ι), ∫ (x : α) in a i..b, ∥f x∥ ∂μ) l (𝓝 I),	φ : ι → set α := λ (i : ι), set.Ioi (a i),	hφ : measure_theory.ae_cover (μ.restrict (set.Iic b)) l φ,	hfi : ∀ (i : ι), measure_theory.integrable_on f (φ i) (μ.restrict (set.Iic b))	⊢ measure_theory.integrable_on f (set.Iic b) μ
α : Type u_1,	ι : Type u_2,	E : Type u_3,	_inst_1 : topological_space α,	_inst_2 : linear_order α,	_inst_3 : order_closed_topology α,	_inst_4 : measurable_space α,	_inst_5 : opens_measurable_space α,	μ : measure_theory.measure α,	l : filter ι,	_inst_6 : l.ne_bot,	hcg : l.is_countably_generated,	_inst_7 : measurable_space E,	_inst_8 : normed_group E,	_inst_9 : borel_space E,	a : ι → α,	f : α → E,	hfm : ae_measurable f μ,	_inst_10 : no_bot_order α,	I : ℝ,	b : α,	hfi : ∀ (i : ι), measure_theory.integrable_on f (set.Ioc (a i) b) μ,	ha : filter.tendsto a l filter.at_bot,	h : filter.tendsto (λ (i : ι), ∫ (x : α) in a i..b, ∥f x∥ ∂μ) l (𝓝 I),	φ : ι → set α := λ (i : ι), set.Ioi (a i),	hφ : measure_theory.ae_cover (μ.restrict (set.Iic b)) l φ,	i : ι	⊢ measure_theory.integrable f (μ.restrict (φ i ∩ set.Iic b))
α : Type u_1,	ι : Type u_2,	E : Type u_3,	_inst_1 : topological_space α,	_inst_2 : linear_order α,	_inst_3 : order_closed_topology α,	_inst_4 : measurable_space α,	_inst_5 : opens_measurable_space α,	μ : measure_theory.measure α,	l : filter ι,	_inst_6 : l.ne_bot,	hcg : l.is_countably_generated,	_inst_7 : measurable_space E,	_inst_8 : normed_group E,	_inst_9 : borel_space E,	a : ι → α,	f : α → E,	hfm : ae_measurable f μ,	_inst_10 : no_bot_order α,	I : ℝ,	b : α,	hfi : ∀ (i : ι), measure_theory.integrable_on f (set.Ioc (a i) b) μ,	ha : filter.tendsto a l filter.at_bot,	h : filter.tendsto (λ (i : ι), ∫ (x : α) in a i..b, ∥f x∥ ∂μ) l (𝓝 I),	φ : ι → set α := λ (i : ι), set.Ioi (a i),	hφ : measure_theory.ae_cover (μ.restrict (set.Iic b)) l φ,	hfi : ∀ (i : ι), measure_theory.integrable_on f (φ i) (μ.restrict (set.Iic b))	⊢ measure_theory.integrable_on f (set.Iic b) μ
α : Type u_1,	ι : Type u_2,	E : Type u_3,	_inst_1 : topological_space α,	_inst_2 : linear_order α,	_inst_3 : order_closed_topology α,	_inst_4 : measurable_space α,	_inst_5 : opens_measurable_space α,	μ : measure_theory.measure α,	l : filter ι,	_inst_6 : l.ne_bot,	hcg : l.is_countably_generated,	_inst_7 : measurable_space E,	_inst_8 : normed_group E,	_inst_9 : borel_space E,	a : ι → α,	f : α → E,	hfm : ae_measurable f μ,	_inst_10 : no_bot_order α,	I : ℝ,	b : α,	hfi : ∀ (i : ι), measure_theory.integrable_on f (set.Ioc (a i) b) μ,	ha : filter.tendsto a l filter.at_bot,	h : filter.tendsto (λ (i : ι), ∫ (x : α) in a i..b, ∥f x∥ ∂μ) l (𝓝 I),	φ : ι → set α := λ (i : ι), set.Ioi (a i),	hφ : measure_theory.ae_cover (μ.restrict (set.Iic b)) l φ,	hfi : ∀ (i : ι), measure_theory.integrable_on f (φ i) (μ.restrict (set.Iic b))	⊢ (λ (i : ι), ∫ (x : α) in a i..b, ∥f x∥ ∂μ) =ᶠ[l] λ (i : ι), ∫ (x : α) in φ i, ∥f x∥ ∂μ.restrict (set.Iic b)
α : Type u_1,	ι : Type u_2,	E : Type u_3,	_inst_1 : topological_space α,	_inst_2 : linear_order α,	_inst_3 : order_closed_topology α,	_inst_4 : measurable_space α,	_inst_5 : opens_measurable_space α,	μ : measure_theory.measure α,	l : filter ι,	_inst_6 : l.ne_bot,	hcg : l.is_countably_generated,	_inst_7 : measurable_space E,	_inst_8 : normed_group E,	_inst_9 : borel_space E,	a : ι → α,	f : α → E,	hfm : ae_measurable f μ,	_inst_10 : no_bot_order α,	I : ℝ,	b : α,	hfi : ∀ (i : ι), measure_theory.integrable_on f (set.Ioc (a i) b) μ,	ha : filter.tendsto a l filter.at_bot,	h : filter.tendsto (λ (i : ι), ∫ (x : α) in a i..b, ∥f x∥ ∂μ) l (𝓝 I),	φ : ι → set α := λ (i : ι), set.Ioi (a i),	hφ : measure_theory.ae_cover (μ.restrict (set.Iic b)) l φ,	hfi : ∀ (i : ι), measure_theory.integrable_on f (φ i) (μ.restrict (set.Iic b))	⊢ ∀ (a_1 : ι), a a_1 ≤ b → ∫ (x : α) in a a_1..b, ∥f x∥ ∂μ = ∫ (x : α) in φ a_1, ∥f x∥ ∂μ.restrict (set.Iic b)
α : Type u_1,	ι : Type u_2,	E : Type u_3,	_inst_1 : topological_space α,	_inst_2 : linear_order α,	_inst_3 : order_closed_topology α,	_inst_4 : measurable_space α,	_inst_5 : opens_measurable_space α,	μ : measure_theory.measure α,	l : filter ι,	_inst_6 : l.ne_bot,	hcg : l.is_countably_generated,	_inst_7 : measurable_space E,	_inst_8 : normed_group E,	_inst_9 : borel_space E,	a : ι → α,	f : α → E,	hfm : ae_measurable f μ,	_inst_10 : no_bot_order α,	I : ℝ,	b : α,	hfi : ∀ (i : ι), measure_theory.integrable_on f (set.Ioc (a i) b) μ,	ha : filter.tendsto a l filter.at_bot,	h : filter.tendsto (λ (i : ι), ∫ (x : α) in a i..b, ∥f x∥ ∂μ) l (𝓝 I),	φ : ι → set α := λ (i : ι), set.Ioi (a i),	hφ : measure_theory.ae_cover (μ.restrict (set.Iic b)) l φ,	hfi : ∀ (i : ι), measure_theory.integrable_on f (φ i) (μ.restrict (set.Iic b)),	i : ι,	hai : a i ≤ b	⊢ ∫ (x : α) in a i..b, ∥f x∥ ∂μ = ∫ (x : α) in φ i, ∥f x∥ ∂μ.restrict (set.Iic b)
α : Type u_1,	ι : Type u_2,	E : Type u_3,	_inst_1 : topological_space α,	_inst_2 : linear_order α,	_inst_3 : order_closed_topology α,	_inst_4 : measurable_space α,	_inst_5 : opens_measurable_space α,	μ : measure_theory.measure α,	l : filter ι,	_inst_6 : l.ne_bot,	hcg : l.is_countably_generated,	_inst_7 : measurable_space E,	_inst_8 : normed_group E,	_inst_9 : borel_space E,	a : ι → α,	f : α → E,	hfm : ae_measurable f μ,	_inst_10 : no_bot_order α,	I : ℝ,	b : α,	hfi : ∀ (i : ι), measure_theory.integrable_on f (set.Ioc (a i) b) μ,	ha : filter.tendsto a l filter.at_bot,	h : filter.tendsto (λ (i : ι), ∫ (x : α) in a i..b, ∥f x∥ ∂μ) l (𝓝 I),	φ : ι → set α := λ (i : ι), set.Ioi (a i),	hφ : measure_theory.ae_cover (μ.restrict (set.Iic b)) l φ,	hfi : ∀ (i : ι), measure_theory.integrable_on f (φ i) (μ.restrict (set.Iic b)),	i : ι,	hai : a i ≤ b	⊢ ∫ (x : α) in set.Ioc (a i) b, ∥f x∥ ∂μ = ∫ (x : α) in φ i ∩ set.Iic b, ∥f x∥ ∂μ
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ	⊢ ae_measurable (λ (x : α), {x : α | x ≤ b₀}.indicator f x) (μ.restrict (Ι b₁ b₂))		α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ	⊢ ∀ᶠ (x : α) in 𝓝[set.Icc b₁ b₂] b₀, ∀ᵐ (t : α) ∂μ.restrict (Ι b₁ b₂), ∥{x_1 : α | x_1 ≤ x}.indicator f t∥ ≤ ∥f t∥		α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ	⊢ ∀ᵐ (t : α) ∂μ.restrict (Ι b₁ b₂), continuous_within_at (λ (x : α), {x_1 : α | x_1 ≤ x}.indicator f t) (set.Icc b₁ b₂) b₀
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ	⊢ measurable_set {x : α | x ≤ b₀}
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ	⊢ ∀ᶠ (x : α) in 𝓝[set.Icc b₁ b₂] b₀, ∀ᵐ (t : α) ∂μ.restrict (Ι b₁ b₂), ∥{x_1 : α | x_1 ≤ x}.indicator f t∥ ≤ ∥f t∥
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	x t : α	⊢ ∥{x_1 : α | x_1 ≤ x}.indicator f t∥ ≤ ∥f t∥
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	x t : α	⊢ ∥ite (t ≤ x) (f t) 0∥ ≤ ∥f t∥
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	x t : α,	h : t ≤ x	⊢ ∥f t∥ ≤ ∥f t∥
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	x t : α,	h : ¬t ≤ x	⊢ ∥0∥ ≤ ∥f t∥
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ	⊢ ∀ᶠ (x : α) in 𝓝[set.Icc b₁ b₂] b₀, ∀ᵐ (t : α) ∂μ.restrict (Ι b₁ b₂), ∥{x_1 : α | x_1 ≤ x}.indicator f t∥ ≤ ∥f t∥		α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ	⊢ ∀ᵐ (t : α) ∂μ.restrict (Ι b₁ b₂), continuous_within_at (λ (x : α), {x_1 : α | x_1 ≤ x}.indicator f t) (set.Icc b₁ b₂) b₀
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	x t : α	⊢ ∥ite (t ≤ x) (f t) 0∥ ≤ ∥f t∥
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ	⊢ ∀ᵐ (t : α) ∂μ.restrict (Ι b₁ b₂), continuous_within_at (λ (x : α), {x_1 : α | x_1 ≤ x}.indicator f t) (set.Icc b₁ b₂) b₀
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ	⊢ ∀ᵐ (t : α) ∂μ.restrict (Ι b₁ b₂), t < b₀ ∨ b₀ < t
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ	⊢ ∀ᵐ (x : α) ∂μ, x < b₀ ∨ b₀ < x
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ	⊢ ∀ (x : α), (λ (x : α), x ∉ {b₀}) x → x < b₀ ∨ b₀ < x
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ	⊢ ∀ᵐ (t : α) ∂μ.restrict (Ι b₁ b₂), t < b₀ ∨ b₀ < t		α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	this : ∀ᵐ (t : α) ∂μ.restrict (Ι b₁ b₂), t < b₀ ∨ b₀ < t	⊢ ∀ᵐ (t : α) ∂μ.restrict (Ι b₁ b₂), continuous_within_at (λ (x : α), {x_1 : α | x_1 ≤ x}.indicator f t) (set.Icc b₁ b₂) b₀
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	x : α,	hx : x ∉ {b₀}	⊢ x < b₀ ∨ b₀ < x
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	this : ∀ᵐ (t : α) ∂μ.restrict (Ι b₁ b₂), t < b₀ ∨ b₀ < t	⊢ ∀ᵐ (t : α) ∂μ.restrict (Ι b₁ b₂), continuous_within_at (λ (x : α), {x_1 : α | x_1 ≤ x}.indicator f t) (set.Icc b₁ b₂) b₀
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	this : ∀ᵐ (t : α) ∂μ.restrict (Ι b₁ b₂), t < b₀ ∨ b₀ < t	⊢ ∀ (x : α), (λ (t : α), t < b₀ ∨ b₀ < t) x → continuous_within_at (λ (x_1 : α), {x : α | x ≤ x_1}.indicator f x) (set.Icc b₁ b₂) b₀
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	this : ∀ᵐ (t : α) ∂μ.restrict (Ι b₁ b₂), t < b₀ ∨ b₀ < t,	x₀ : α,	hx₀ : x₀ < b₀	⊢ continuous_within_at (λ (x : α), {x_1 : α | x_1 ≤ x}.indicator f x₀) (set.Icc b₁ b₂) b₀
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	this : ∀ᵐ (t : α) ∂μ.restrict (Ι b₁ b₂), t < b₀ ∨ b₀ < t,	x₀ : α,	hx₀ : x₀ < b₀	⊢ ∀ᶠ (x : α) in 𝓝[set.Icc b₁ b₂] b₀, {t : α | t ≤ x}.indicator f x₀ = f x₀
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	this : ∀ᵐ (t : α) ∂μ.restrict (Ι b₁ b₂), t < b₀ ∨ b₀ < t,	x₀ : α,	hx₀ : x₀ < b₀	⊢ {x : α | (λ (x : α), {t : α | t ≤ x}.indicator f x₀ = f x₀) x} ∈ 𝓝 b₀
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	this : ∀ᵐ (t : α) ∂μ.restrict (Ι b₁ b₂), t < b₀ ∨ b₀ < t,	x₀ : α,	hx₀ : x₀ < b₀	⊢ ∀ (x : α), (λ (x : α), x₀ < x) x → {t : α | t ≤ x}.indicator f x₀ = f x₀
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	this : ∀ᵐ (t : α) ∂μ.restrict (Ι b₁ b₂), t < b₀ ∨ b₀ < t,	x₀ : α,	hx₀ : x₀ < b₀,	x : α,	hx : x₀ < x	⊢ {t : α | t ≤ x}.indicator f x₀ = f x₀
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	this : ∀ᵐ (t : α) ∂μ.restrict (Ι b₁ b₂), t < b₀ ∨ b₀ < t,	x₀ : α,	hx₀ : x₀ < b₀	⊢ ∀ᶠ (x : α) in 𝓝[set.Icc b₁ b₂] b₀, {t : α | t ≤ x}.indicator f x₀ = f x₀		α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	this : ∀ᵐ (t : α) ∂μ.restrict (Ι b₁ b₂), t < b₀ ∨ b₀ < t,	x₀ : α,	hx₀ : x₀ < b₀,	this : ∀ᶠ (x : α) in 𝓝[set.Icc b₁ b₂] b₀, {t : α | t ≤ x}.indicator f x₀ = f x₀	⊢ continuous_within_at (λ (x : α), {x_1 : α | x_1 ≤ x}.indicator f x₀) (set.Icc b₁ b₂) b₀
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	this : ∀ᵐ (t : α) ∂μ.restrict (Ι b₁ b₂), t < b₀ ∨ b₀ < t,	x₀ : α,	hx₀ : x₀ < b₀,	this : ∀ᶠ (x : α) in 𝓝[set.Icc b₁ b₂] b₀, {t : α | t ≤ x}.indicator f x₀ = f x₀	⊢ continuous_within_at (λ (x : α), {x_1 : α | x_1 ≤ x}.indicator f x₀) (set.Icc b₁ b₂) b₀
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	this : ∀ᵐ (t : α) ∂μ.restrict (Ι b₁ b₂), t < b₀ ∨ b₀ < t,	x₀ : α,	hx₀ : x₀ < b₀	⊢ continuous_within_at (λ (x : α), {x_1 : α | x_1 ≤ x}.indicator f x₀) (set.Icc b₁ b₂) b₀		α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	this : ∀ᵐ (t : α) ∂μ.restrict (Ι b₁ b₂), t < b₀ ∨ b₀ < t,	x₀ : α,	hx₀ : b₀ < x₀	⊢ continuous_within_at (λ (x : α), {x_1 : α | x_1 ≤ x}.indicator f x₀) (set.Icc b₁ b₂) b₀
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	this : ∀ᵐ (t : α) ∂μ.restrict (Ι b₁ b₂), t < b₀ ∨ b₀ < t,	x₀ : α,	hx₀ : x₀ < b₀,	this : ∀ᶠ (x : α) in 𝓝[set.Icc b₁ b₂] b₀, {t : α | t ≤ x}.indicator f x₀ = f x₀	⊢ (λ (x : α), {t : α | t ≤ x}.indicator f x₀) b₀ = (λ (_x : α), f x₀) b₀
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	this : ∀ᵐ (t : α) ∂μ.restrict (Ι b₁ b₂), t < b₀ ∨ b₀ < t,	x₀ : α,	hx₀ : b₀ < x₀	⊢ continuous_within_at (λ (x : α), {x_1 : α | x_1 ≤ x}.indicator f x₀) (set.Icc b₁ b₂) b₀
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	this : ∀ᵐ (t : α) ∂μ.restrict (Ι b₁ b₂), t < b₀ ∨ b₀ < t,	x₀ : α,	hx₀ : b₀ < x₀	⊢ ∀ᶠ (x : α) in 𝓝[set.Icc b₁ b₂] b₀, {t : α | t ≤ x}.indicator f x₀ = 0
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	this : ∀ᵐ (t : α) ∂μ.restrict (Ι b₁ b₂), t < b₀ ∨ b₀ < t,	x₀ : α,	hx₀ : b₀ < x₀	⊢ {x : α | (λ (x : α), {t : α | t ≤ x}.indicator f x₀ = 0) x} ∈ 𝓝 b₀
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	this : ∀ᵐ (t : α) ∂μ.restrict (Ι b₁ b₂), t < b₀ ∨ b₀ < t,	x₀ : α,	hx₀ : b₀ < x₀	⊢ ∀ (x : α), (λ (x : α), x < x₀) x → {t : α | t ≤ x}.indicator f x₀ = 0
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	this : ∀ᵐ (t : α) ∂μ.restrict (Ι b₁ b₂), t < b₀ ∨ b₀ < t,	x₀ : α,	hx₀ : b₀ < x₀,	x : α,	hx : x < x₀	⊢ {t : α | t ≤ x}.indicator f x₀ = 0
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	this : ∀ᵐ (t : α) ∂μ.restrict (Ι b₁ b₂), t < b₀ ∨ b₀ < t,	x₀ : α,	hx₀ : b₀ < x₀	⊢ ∀ᶠ (x : α) in 𝓝[set.Icc b₁ b₂] b₀, {t : α | t ≤ x}.indicator f x₀ = 0		α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	this : ∀ᵐ (t : α) ∂μ.restrict (Ι b₁ b₂), t < b₀ ∨ b₀ < t,	x₀ : α,	hx₀ : b₀ < x₀,	this : ∀ᶠ (x : α) in 𝓝[set.Icc b₁ b₂] b₀, {t : α | t ≤ x}.indicator f x₀ = 0	⊢ continuous_within_at (λ (x : α), {x_1 : α | x_1 ≤ x}.indicator f x₀) (set.Icc b₁ b₂) b₀
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	this : ∀ᵐ (t : α) ∂μ.restrict (Ι b₁ b₂), t < b₀ ∨ b₀ < t,	x₀ : α,	hx₀ : b₀ < x₀,	this : ∀ᶠ (x : α) in 𝓝[set.Icc b₁ b₂] b₀, {t : α | t ≤ x}.indicator f x₀ = 0	⊢ continuous_within_at (λ (x : α), {x_1 : α | x_1 ≤ x}.indicator f x₀) (set.Icc b₁ b₂) b₀
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂	⊢ continuous_within_at (λ (b : α), ∫ (x : α) in a..b, f x ∂μ) (set.Icc b₁ b₂) b₀		α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∉ set.Icc b₁ b₂	⊢ continuous_within_at (λ (b : α), ∫ (x : α) in a..b, f x ∂μ) (set.Icc b₁ b₂) b₀
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	this : ∀ᵐ (t : α) ∂μ.restrict (Ι b₁ b₂), t < b₀ ∨ b₀ < t,	x₀ : α,	hx₀ : b₀ < x₀,	this : ∀ᶠ (x : α) in 𝓝[set.Icc b₁ b₂] b₀, {t : α | t ≤ x}.indicator f x₀ = 0	⊢ (λ (x : α), {t : α | t ≤ x}.indicator f x₀) b₀ = (λ (_x : α), 0) b₀
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∉ set.Icc b₁ b₂	⊢ continuous_within_at (λ (b : α), ∫ (x : α) in a..b, f x ∂μ) (set.Icc b₁ b₂) b₀
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∉ set.Icc b₁ b₂	⊢ b₀ ∉ closure (set.Icc b₁ b₂)
β : Type u_2,	_inst_9 : linear_order β,	_inst_10 : measurable_space β,	_inst_11 : topological_space β,	_inst_12 : opens_measurable_space β,	_inst_13 : order_topology β,	x a b : β,	h : fact (x ∈ [a, b]),	_inst : fact (x ∈ set.Icc (linear_order.min a b) (linear_order.max a b))	⊢ interval_integral.FTC_filter x (𝓝[[a, b]] x) (𝓝[[a, b]] x)
β : Type u_2,	_inst_9 : linear_order β,	_inst_10 : measurable_space β,	_inst_11 : topological_space β,	_inst_12 : opens_measurable_space β,	_inst_13 : order_topology β,	x a b : β,	h : fact (x ∈ [a, b])	⊢ interval_integral.FTC_filter x (𝓝[[a, b]] x) (𝓝[[a, b]] x)
E : Type u_4,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	f : ℝ → E,	a b : ℝ,	f' : ℝ → E,	hab : a ≤ b,	hcont : continuous_on f (set.Icc a b),	hderiv : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_within_at f (f' x) (set.Ioi x) x,	f'int : interval_integrable f' measure_theory.measure_space.volume a b	⊢ ∫ (y : ℝ) in a..b, f' y = f b - f a
E : Type u_4,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	f : ℝ → E,	a b : ℝ,	f' : ℝ → E,	hab : a ≤ b,	hcont : continuous_on f (set.Icc a b),	hderiv : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_within_at f (f' x) (set.Ioi x) x,	f'int : interval_integrable f' measure_theory.measure_space.volume a b,	g : normed_space.dual ℝ E	⊢ ⇑g (∫ (y : ℝ) in a..b, f' y) = ⇑g (f b - f a)
E : Type u_4,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	f : ℝ → E,	a b : ℝ,	f' : ℝ → E,	hab : a ≤ b,	hcont : continuous_on f (set.Icc a b),	hderiv : ∀ (x : ℝ), x ∈ set.Ioo a b → has_deriv_within_at f (f' x) (set.Ioi x) x,	f'int : interval_integrable f' measure_theory.measure_space.volume a b,	g : normed_space.dual ℝ E	⊢ ∫ (x : ℝ) in a..b, ⇑g (f' x) = ⇑g (f b) - ⇑g (f a)
E : Type u_4,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	a b c : ℝ,	f : ℝ → E,	hc : c ≠ 0	⊢ ∫ (x : ℝ) in a..b, f (c * x) = c⁻¹ • ∫ (x : ℝ) in c * a..c * b, f x
E : Type u_4,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	a b : ℝ,	f : ℝ → E,	d : ℝ	⊢ ∫ (x : ℝ) in a..b, f (d - x) = ∫ (x : ℝ) in d - b..d - a, f x
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂)	⊢ continuous_within_at (λ (b : α), ∫ (x : α) in a..b, f x ∂μ) (set.Icc b₁ b₂) b₀
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂	⊢ continuous_within_at (λ (b : α), ∫ (x : α) in a..b, f x ∂μ) (set.Icc b₁ b₂) b₀
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂	⊢ continuous_within_at (λ (b : α), ∫ (x : α) in a..b, f x ∂μ) (set.Icc b₁ b₂) b₀
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁	⊢ continuous_within_at (λ (b : α), ∫ (x : α) in a..b, f x ∂μ) (set.Icc b₁ b₂) b₀
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁	⊢ ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	x : α,	h₁ : b₁ ≤ x,	h₂ : x ≤ b₂	⊢ interval_integrable f μ b₁ x
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	x : α,	h₁ : b₁ ≤ x,	h₂ : x ≤ b₂	⊢ [b₁, x] ⊆ [linear_order.min a b₁, linear_order.max a b₂]
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	x : α,	h₁ : b₁ ≤ x,	h₂ : x ≤ b₂	⊢ b₁ ∈ [linear_order.min a b₁, linear_order.max a b₂]
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	x : α,	h₁ : b₁ ≤ x,	h₂ : x ≤ b₂	⊢ b₁ ∈ [linear_order.min a b₁, linear_order.max a b₂]		α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	x : α,	h₁ : b₁ ≤ x,	h₂ : x ≤ b₂	⊢ x ∈ [linear_order.min a b₁, linear_order.max a b₂]
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	x : α,	h₁ : b₁ ≤ x,	h₂ : x ≤ b₂	⊢ x ∈ [linear_order.min a b₁, linear_order.max a b₂]
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁	⊢ ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x		α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x	⊢ continuous_within_at (λ (b : α), ∫ (x : α) in a..b, f x ∂μ) (set.Icc b₁ b₂) b₀
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x	⊢ continuous_within_at (λ (b : α), ∫ (x : α) in a..b, f x ∂μ) (set.Icc b₁ b₂) b₀
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x	⊢ ∀ (b : α), b ∈ set.Icc b₁ b₂ → ∫ (x : α) in a..b, f x ∂μ = ∫ (x : α) in a..b₁, f x ∂μ + ∫ (x : α) in b₁..b, f x ∂μ
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	b : α,	h₁ : b₁ ≤ b,	h₂ : b ≤ b₂	⊢ ∫ (x : α) in a..b, f x ∂μ = ∫ (x : α) in a..b₁, f x ∂μ + ∫ (x : α) in b₁..b, f x ∂μ
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	b : α,	h₁ : b₁ ≤ b,	h₂ : b ≤ b₂	⊢ interval_integrable f μ a b₁
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	b : α,	h₁ : b₁ ≤ b,	h₂ : b ≤ b₂	⊢ [a, b₁] ⊆ [linear_order.min a b₁, linear_order.max a b₂]
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	b : α,	h₁ : b₁ ≤ b,	h₂ : b ≤ b₂	⊢ a ∈ [linear_order.min a b₁, linear_order.max a b₂]		α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	b : α,	h₁ : b₁ ≤ b,	h₂ : b ≤ b₂	⊢ b₁ ∈ [linear_order.min a b₁, linear_order.max a b₂]
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	b : α,	h₁ : b₁ ≤ b,	h₂ : b ≤ b₂	⊢ a ∈ [linear_order.min a b₁, linear_order.max a b₂]
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	b : α,	h₁ : b₁ ≤ b,	h₂ : b ≤ b₂	⊢ b₁ ∈ [linear_order.min a b₁, linear_order.max a b₂]
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x	⊢ ∀ (b : α), b ∈ set.Icc b₁ b₂ → ∫ (x : α) in a..b, f x ∂μ = ∫ (x : α) in a..b₁, f x ∂μ + ∫ (x : α) in b₁..b, f x ∂μ		α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : ∀ (b : α), b ∈ set.Icc b₁ b₂ → ∫ (x : α) in a..b, f x ∂μ = ∫ (x : α) in a..b₁, f x ∂μ + ∫ (x : α) in b₁..b, f x ∂μ	⊢ continuous_within_at (λ (b : α), ∫ (x : α) in a..b, f x ∂μ) (set.Icc b₁ b₂) b₀
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : ∀ (b : α), b ∈ set.Icc b₁ b₂ → ∫ (x : α) in a..b, f x ∂μ = ∫ (x : α) in a..b₁, f x ∂μ + ∫ (x : α) in b₁..b, f x ∂μ	⊢ continuous_within_at (λ (b : α), ∫ (x : α) in a..b₁, f x ∂μ + ∫ (x : α) in b₁..b, f x ∂μ) (set.Icc b₁ b₂) b₀
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : ∀ (b : α), b ∈ set.Icc b₁ b₂ → ∫ (x : α) in a..b, f x ∂μ = ∫ (x : α) in a..b₁, f x ∂μ + ∫ (x : α) in b₁..b, f x ∂μ	⊢ continuous_within_at (λ (b : α), ∫ (x : α) in a..b, f x ∂μ) (set.Icc b₁ b₂) b₀
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x	⊢ continuous_within_at (λ (b : α), ∫ (x : α) in a..b₁, f x ∂μ + ∫ (x : α) in b₁..b, f x ∂μ) (set.Icc b₁ b₂) b₀
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x	⊢ continuous_within_at (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) (set.Icc b₁ b₂) b₀
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x	⊢ (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x	⊢ (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ		α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ	⊢ continuous_within_at (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) (set.Icc b₁ b₂) b₀
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x	⊢ set.eq_on (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) (λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ) (set.Icc b₁ b₂)
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ	⊢ continuous_within_at (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) (set.Icc b₁ b₂) b₀
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ	⊢ continuous_within_at (λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ) (set.Icc b₁ b₂) b₀
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ	⊢ interval_integrable (λ (x : α), ∥f x∥) μ b₁ b₂		α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	this : interval_integrable (λ (x : α), ∥f x∥) μ b₁ b₂	⊢ continuous_within_at (λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ) (set.Icc b₁ b₂) b₀
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	this : interval_integrable (λ (x : α), ∥f x∥) μ b₁ b₂	⊢ continuous_within_at (λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ) (set.Icc b₁ b₂) b₀
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	this : interval_integrable (λ (x : α), ∥f x∥) μ b₁ b₂	⊢ continuous_within_at (λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ) (set.Icc b₁ b₂) b₀
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	this : interval_integrable (λ (x : α), ∥f x∥) μ b₁ b₂	⊢ ∀ᶠ (x : α) in 𝓝[set.Icc b₁ b₂] b₀, ae_measurable (λ (x_1 : α), {x_1 : α | x_1 ≤ x}.indicator f x_1) (μ.restrict (Ι b₁ b₂))
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	this : interval_integrable (λ (x : α), ∥f x∥) μ b₁ b₂	⊢ ae_measurable (λ (x : α), {x : α | x ≤ b₀}.indicator f x) (μ.restrict (Ι b₁ b₂))
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	this : interval_integrable (λ (x : α), ∥f x∥) μ b₁ b₂	⊢ ∀ᶠ (x : α) in 𝓝[set.Icc b₁ b₂] b₀, ∀ᵐ (t : α) ∂μ.restrict (Ι b₁ b₂), ∥{x_1 : α | x_1 ≤ x}.indicator f t∥ ≤ ∥f t∥
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	this : interval_integrable (λ (x : α), ∥f x∥) μ b₁ b₂	⊢ ∀ᵐ (t : α) ∂μ.restrict (Ι b₁ b₂), continuous_within_at (λ (x : α), {x_1 : α | x_1 ≤ x}.indicator f t) (set.Icc b₁ b₂) b₀
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ	⊢ ∀ᶠ (x : α) in 𝓝[set.Icc b₁ b₂] b₀, ae_measurable (λ (x_1 : α), {x_1 : α | x_1 ≤ x}.indicator f x_1) (μ.restrict (Ι b₁ b₂))
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ	⊢ ∀ (x : α), b₁ ≤ x ∧ x ≤ b₂ → ae_measurable (λ (x_1 : α), {x_1 : α | x_1 ≤ x}.indicator f x_1) (μ.restrict (Ι b₁ b₂))
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	x : α,	hx : b₁ ≤ x ∧ x ≤ b₂	⊢ ae_measurable (λ (x_1 : α), {x_1 : α | x_1 ≤ x}.indicator f x_1) (μ.restrict (Ι b₁ b₂))
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	x : α,	hx : b₁ ≤ x ∧ x ≤ b₂	⊢ ae_measurable (λ (x : α), f x) (μ.restrict (set.Ioc (linear_order.min b₁ b₂) x))
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	x : α,	hx : b₁ ≤ x ∧ x ≤ b₂	⊢ ae_measurable (λ (x : α), f x) (μ.restrict (set.Ioc (linear_order.min b₁ b₂) x))		α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	x : α,	hx : b₁ ≤ x ∧ x ≤ b₂	⊢ x ≤ linear_order.max b₁ b₂		α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	x : α,	hx : b₁ ≤ x ∧ x ≤ b₂	⊢ measurable_set {x_1 : α | x_1 ≤ x}		α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	x : α,	hx : b₁ ≤ x ∧ x ≤ b₂	⊢ measurable_set {x_1 : α | x_1 ≤ x}
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	x : α,	hx : b₁ ≤ x ∧ x ≤ b₂	⊢ ae_measurable (λ (x : α), f x) (μ.restrict (set.Ioc b₁ x))
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	x : α,	hx : b₁ ≤ x ∧ x ≤ b₂	⊢ x ≤ linear_order.max b₁ b₂		α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	x : α,	hx : b₁ ≤ x ∧ x ≤ b₂	⊢ measurable_set {x_1 : α | x_1 ≤ x}		α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	x : α,	hx : b₁ ≤ x ∧ x ≤ b₂	⊢ measurable_set {x_1 : α | x_1 ≤ x}
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	x : α,	hx : b₁ ≤ x ∧ x ≤ b₂	⊢ x ≤ linear_order.max b₁ b₂
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ	⊢ ∀ᶠ (x : α) in 𝓝[set.Icc b₁ b₂] b₀, ae_measurable (λ (x_1 : α), {x_1 : α | x_1 ≤ x}.indicator f x_1) (μ.restrict (Ι b₁ b₂))		α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ	⊢ ae_measurable (λ (x : α), {x : α | x ≤ b₀}.indicator f x) (μ.restrict (Ι b₁ b₂))		α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ	⊢ ∀ᶠ (x : α) in 𝓝[set.Icc b₁ b₂] b₀, ∀ᵐ (t : α) ∂μ.restrict (Ι b₁ b₂), ∥{x_1 : α | x_1 ≤ x}.indicator f t∥ ≤ ∥f t∥		α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ	⊢ ∀ᵐ (t : α) ∂μ.restrict (Ι b₁ b₂), continuous_within_at (λ (x : α), {x_1 : α | x_1 ≤ x}.indicator f t) (set.Icc b₁ b₂) b₀
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	x : α,	hx : b₁ ≤ x ∧ x ≤ b₂	⊢ measurable_set {x_1 : α | x_1 ≤ x}		α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ,	x : α,	hx : b₁ ≤ x ∧ x ≤ b₂	⊢ measurable_set {x_1 : α | x_1 ≤ x}
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ	⊢ ae_measurable (λ (x : α), {x : α | x ≤ b₀}.indicator f x) (μ.restrict (Ι b₁ b₂))
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ	⊢ ae_measurable (λ (x : α), f x) (μ.restrict (set.Ioc (linear_order.min b₁ b₂) b₀))
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ	⊢ ae_measurable (λ (x : α), f x) (μ.restrict (set.Ioc (linear_order.min b₁ b₂) b₀))		α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ	⊢ b₀ ≤ linear_order.max b₁ b₂		α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ	⊢ measurable_set {x : α | x ≤ b₀}		α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ	⊢ measurable_set {x : α | x ≤ b₀}
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ	⊢ ae_measurable (λ (x : α), f x) (μ.restrict (set.Ioc b₁ b₀))
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ	⊢ b₀ ≤ linear_order.max b₁ b₂		α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ	⊢ measurable_set {x : α | x ≤ b₀}		α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ	⊢ measurable_set {x : α | x ≤ b₀}
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ	⊢ b₀ ≤ linear_order.max b₁ b₂
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ	⊢ measurable_set {x : α | x ≤ b₀}		α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : topological_space.second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : topological_space.first_countable_topology α,	μ : measure_theory.measure α,	f : α → E,	a b₀ b₁ b₂ : α,	hb₀ : ⇑μ {b₀} = 0,	h_int : interval_integrable f μ (linear_order.min a b₁) (linear_order.max a b₂),	h₀ : b₀ ∈ set.Icc b₁ b₂,	h₁₂ : b₁ ≤ b₂,	min₁₂ : linear_order.min b₁ b₂ = b₁,	h_int' : ∀ {x : α}, x ∈ set.Icc b₁ b₂ → interval_integrable f μ b₁ x,	this : (λ (b : α), ∫ (x : α) in b₁..b, f x ∂μ) =ᶠ[𝓝[set.Icc b₁ b₂] b₀] λ (b : α), ∫ (x : α) in b₁..b₂, {x : α | x ≤ b}.indicator f x ∂μ	⊢ measurable_set {x : α | x ≤ b₀}
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	s : set α,	c : ℝ≥0∞	⊢ ∫⁻ (a : α) in s, c ∂μ = c * ⇑μ s
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f	⊢ ∫⁻ (a : α), (⨆ (n : ℕ), f n a) ∂μ = ⨆ (n : ℕ), ∫⁻ (a : α), f n a ∂μ
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe	⊢ ∫⁻ (a : α), (⨆ (n : ℕ), f n a) ∂μ = ⨆ (n : ℕ), ∫⁻ (a : α), f n a ∂μ
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a	⊢ measure_theory.lintegral μ F = ⨆ (n : ℕ), ∫⁻ (a : α), f n a ∂μ
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F	⊢ measure_theory.lintegral μ F = ⨆ (n : ℕ), ∫⁻ (a : α), f n a ∂μ
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F	⊢ measure_theory.lintegral μ F ≤ ⨆ (n : ℕ), ∫⁻ (a : α), f n a ∂μ
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F	⊢ (⨆ (φ : α →ₛ ℝ≥0) (hf : ∀ (x : α), ↑(⇑φ x) ≤ ⨆ (n : ℕ), f n x), (measure_theory.simple_func.map coe φ).lintegral μ) ≤ ⨆ (n : ℕ), ∫⁻ (a : α), f n a ∂μ
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x	⊢ (measure_theory.simple_func.map coe s).lintegral μ ≤ ⨆ (n : ℕ), ∫⁻ (a : α), f n a ∂μ
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	a : ℝ≥0∞,	ha : a < 1	⊢ a * (measure_theory.simple_func.map coe s).lintegral μ ≤ ⨆ (n : ℕ), ∫⁻ (a : α), f n a ∂μ
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1	⊢ ↑r * (measure_theory.simple_func.map coe s).lintegral μ ≤ ⨆ (n : ℕ), ∫⁻ (a : α), f n a ∂μ
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1	⊢ ↑r * (measure_theory.simple_func.map coe s).lintegral μ ≤ ⨆ (n : ℕ), ∫⁻ (a : α), f n a ∂μ
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s	⊢ ↑r * (measure_theory.simple_func.map coe s).lintegral μ ≤ ⨆ (n : ℕ), ∫⁻ (a : α), f n a ∂μ
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	a : α	⊢ ⇑(measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s) a = ⇑(measure_theory.simple_func.map c rs) a
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s	⊢ measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs		α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs	⊢ ↑r * (measure_theory.simple_func.map coe s).lintegral μ ≤ ⨆ (n : ℕ), ∫⁻ (a : α), f n a ∂μ
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s	⊢ measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs	⊢ ↑r * (measure_theory.simple_func.map coe s).lintegral μ ≤ ⨆ (n : ℕ), ∫⁻ (a : α), f n a ∂μ
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs	⊢ ∀ (p : ℝ≥0∞), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} = ⋃ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} ∩ {a : α | p ≤ f n a}
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	p : ℝ≥0∞	⊢ ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} = ⋃ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} ∩ {a : α | p ≤ f n a}
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	p : ℝ≥0∞	⊢ ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} ∩ set.univ = ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} ∩ ⋃ (i : ℕ), {a : α | p ≤ f i a}
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	p : ℝ≥0∞,	x : α,	hx : x ∈ ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p},	p_eq : p = 0	⊢ x ∈ ⋃ (i : ℕ), {a : α | p ≤ f i a}
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	p : ℝ≥0∞,	x : α,	hx : x ∈ ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p},	p_eq : p = 0	⊢ x ∈ ⋃ (i : ℕ), {a : α | p ≤ f i a}		α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	p : ℝ≥0∞,	x : α,	hx : x ∈ ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p},	p_eq : ¬p = 0	⊢ x ∈ ⋃ (i : ℕ), {a : α | p ≤ f i a}
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	p : ℝ≥0∞,	x : α,	hx : x ∈ ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p}	⊢ x ∈ ⋃ (i : ℕ), {a : α | p ≤ f i a}
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	p : ℝ≥0∞,	x : α,	p_eq : ¬p = 0,	hx : c (r * ⇑s x) = p	⊢ x ∈ ⋃ (i : ℕ), {a : α | p ≤ f i a}
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	p : ℝ≥0∞,	x : α,	hx : x ∈ ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p},	p_eq : ¬p = 0	⊢ x ∈ ⋃ (i : ℕ), {a : α | p ≤ f i a}
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	x : α,	p_eq : ¬c (r * ⇑s x) = 0	⊢ r * ⇑s x ≠ 0
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	x : α,	p_eq : ¬c (r * ⇑s x) = 0	⊢ x ∈ ⋃ (i : ℕ), {a : α | c (r * ⇑s x) ≤ f i a}
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	x : α,	p_eq : ¬c (r * ⇑s x) = 0	⊢ r * ⇑s x ≠ 0		α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	x : α,	p_eq : ¬c (r * ⇑s x) = 0,	this : r * ⇑s x ≠ 0	⊢ x ∈ ⋃ (i : ℕ), {a : α | c (r * ⇑s x) ≤ f i a}
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	x : α,	p_eq : ¬c (r * ⇑s x) = 0,	this : r * ⇑s x ≠ 0	⊢ ⇑s x ≠ 0
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	x : α,	p_eq : ¬c (r * ⇑s x) = 0,	this : r * ⇑s x ≠ 0	⊢ ⇑s x = 0 → r * ⇑s x = 0
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	x : α,	p_eq : ¬c (r * ⇑s x) = 0,	this : r * ⇑s x ≠ 0,	h : ⇑s x = 0	⊢ r * ⇑s x = 0
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	x : α,	p_eq : ¬c (r * ⇑s x) = 0,	this : r * ⇑s x ≠ 0	⊢ x ∈ ⋃ (i : ℕ), {a : α | c (r * ⇑s x) ≤ f i a}
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	x : α,	p_eq : ¬c (r * ⇑s x) = 0,	this : r * ⇑s x ≠ 0	⊢ ⇑s x ≠ 0		α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	x : α,	p_eq : ¬c (r * ⇑s x) = 0,	this : r * ⇑s x ≠ 0,	this : ⇑s x ≠ 0	⊢ x ∈ ⋃ (i : ℕ), {a : α | c (r * ⇑s x) ≤ f i a}
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	x : α,	p_eq : ¬c (r * ⇑s x) = 0,	this : r * ⇑s x ≠ 0,	this : ⇑s x ≠ 0	⊢ x ∈ ⋃ (i : ℕ), {a : α | c (r * ⇑s x) ≤ f i a}
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	x : α,	p_eq : ¬c (r * ⇑s x) = 0,	this : r * ⇑s x ≠ 0,	this : ⇑s x ≠ 0	⊢ ⇑(measure_theory.simple_func.map c rs) x < ⨆ (n : ℕ), f n x
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	x : α,	p_eq : ¬c (r * ⇑s x) = 0,	this : r * ⇑s x ≠ 0,	this : ⇑s x ≠ 0,	this : r * ⇑s x < 1 * ⇑s x	⊢ ⇑rs x < ⇑s x		α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	x : α,	p_eq : ¬c (r * ⇑s x) = 0,	this : r * ⇑s x ≠ 0,	this : ⇑s x ≠ 0	⊢ r * ⇑s x < 1 * ⇑s x
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	x : α,	p_eq : ¬c (r * ⇑s x) = 0,	this : r * ⇑s x ≠ 0,	this : ⇑s x ≠ 0	⊢ ⇑rs x < ⇑s x
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	x : α,	p_eq : ¬c (r * ⇑s x) = 0,	this : r * ⇑s x ≠ 0,	this : ⇑s x ≠ 0	⊢ ⇑(measure_theory.simple_func.map c rs) x < ⨆ (n : ℕ), f n x		α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	x : α,	p_eq : ¬c (r * ⇑s x) = 0,	this : r * ⇑s x ≠ 0,	this : ⇑s x ≠ 0,	this : ⇑(measure_theory.simple_func.map c rs) x < ⨆ (n : ℕ), f n x	⊢ x ∈ ⋃ (i : ℕ), {a : α | c (r * ⇑s x) ≤ f i a}
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	x : α,	p_eq : ¬c (r * ⇑s x) = 0,	this : r * ⇑s x ≠ 0,	this : ⇑s x ≠ 0	⊢ r * ⇑s x < 1 * ⇑s x
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	x : α,	p_eq : ¬c (r * ⇑s x) = 0,	this : r * ⇑s x ≠ 0,	this : ⇑s x ≠ 0,	this : ⇑(measure_theory.simple_func.map c rs) x < ⨆ (n : ℕ), f n x	⊢ x ∈ ⋃ (i : ℕ), {a : α | c (r * ⇑s x) ≤ f i a}
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs	⊢ ∀ (p : ℝ≥0∞), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} = ⋃ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} ∩ {a : α | p ≤ f n a}		α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	eq : ∀ (p : ℝ≥0∞), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} = ⋃ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} ∩ {a : α | p ≤ f n a}	⊢ ↑r * (measure_theory.simple_func.map coe s).lintegral μ ≤ ⨆ (n : ℕ), ∫⁻ (a : α), f n a ∂μ
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	x : α,	p_eq : ¬c (r * ⇑s x) = 0,	this : r * ⇑s x ≠ 0,	this : ⇑s x ≠ 0,	this : ⇑(measure_theory.simple_func.map c rs) x < ⨆ (n : ℕ), f n x,	i : ℕ,	hi : ⇑(measure_theory.simple_func.map c rs) x < f i x	⊢ x ∈ ⋃ (i : ℕ), {a : α | c (r * ⇑s x) ≤ f i a}
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	eq : ∀ (p : ℝ≥0∞), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} = ⋃ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} ∩ {a : α | p ≤ f n a}	⊢ ↑r * (measure_theory.simple_func.map coe s).lintegral μ ≤ ⨆ (n : ℕ), ∫⁻ (a : α), f n a ∂μ
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	eq : ∀ (p : ℝ≥0∞), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} = ⋃ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} ∩ {a : α | p ≤ f n a}	⊢ ∀ (r : ℝ≥0∞), monotone (λ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {r} ∩ {a : α | r ≤ f n a})
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	eq : ∀ (p : ℝ≥0∞), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} = ⋃ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} ∩ {a : α | p ≤ f n a},	r : ℝ≥0∞,	i j : ℕ,	h : i ≤ j	⊢ (λ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {r} ∩ {a : α | r ≤ f n a}) i ≤ (λ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {r} ∩ {a : α | r ≤ f n a}) j
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	eq : ∀ (p : ℝ≥0∞), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} = ⋃ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} ∩ {a : α | p ≤ f n a},	r : ℝ≥0∞,	i j : ℕ,	h : i ≤ j,	x : α,	hx : x ∈ {a : α | r ≤ f i a}	⊢ x ∈ {a : α | r ≤ f j a}
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	eq : ∀ (p : ℝ≥0∞), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} = ⋃ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} ∩ {a : α | p ≤ f n a}	⊢ ∀ (r : ℝ≥0∞), monotone (λ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {r} ∩ {a : α | r ≤ f n a})		α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	eq : ∀ (p : ℝ≥0∞), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} = ⋃ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} ∩ {a : α | p ≤ f n a},	mono : ∀ (r : ℝ≥0∞), monotone (λ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {r} ∩ {a : α | r ≤ f n a})	⊢ ↑r * (measure_theory.simple_func.map coe s).lintegral μ ≤ ⨆ (n : ℕ), ∫⁻ (a : α), f n a ∂μ
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	eq : ∀ (p : ℝ≥0∞), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} = ⋃ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} ∩ {a : α | p ≤ f n a},	r : ℝ≥0∞,	i j : ℕ,	h : i ≤ j	⊢ {a : α | r ≤ f i a} ⊆ {a : α | r ≤ f j a}
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	eq : ∀ (p : ℝ≥0∞), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} = ⋃ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} ∩ {a : α | p ≤ f n a},	mono : ∀ (r : ℝ≥0∞), monotone (λ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {r} ∩ {a : α | r ≤ f n a})	⊢ ↑r * (measure_theory.simple_func.map coe s).lintegral μ ≤ ⨆ (n : ℕ), ∫⁻ (a : α), f n a ∂μ
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	eq : ∀ (p : ℝ≥0∞), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} = ⋃ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} ∩ {a : α | p ≤ f n a},	mono : ∀ (r : ℝ≥0∞), monotone (λ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {r} ∩ {a : α | r ≤ f n a}),	h_meas : ∀ (n : ℕ), measurable_set {a : α | ⇑(measure_theory.simple_func.map c rs) a ≤ f n a}	⊢ ↑r * (measure_theory.simple_func.map coe s).lintegral μ ≤ ⨆ (n : ℕ), ∫⁻ (a : α), f n a ∂μ
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	eq : ∀ (p : ℝ≥0∞), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} = ⋃ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} ∩ {a : α | p ≤ f n a},	mono : ∀ (r : ℝ≥0∞), monotone (λ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {r} ∩ {a : α | r ≤ f n a}),	h_meas : ∀ (n : ℕ), measurable_set {a : α | ⇑(measure_theory.simple_func.map c rs) a ≤ f n a}	⊢ ↑r * (measure_theory.simple_func.map c s).lintegral μ = ∑ (r : ℝ≥0∞) in (measure_theory.simple_func.map c rs).range, r * ⇑μ (⇑(measure_theory.simple_func.map c rs) ⁻¹' {r})
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	eq : ∀ (p : ℝ≥0∞), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} = ⋃ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} ∩ {a : α | p ≤ f n a},	mono : ∀ (r : ℝ≥0∞), monotone (λ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {r} ∩ {a : α | r ≤ f n a}),	h_meas : ∀ (n : ℕ), measurable_set {a : α | ⇑(measure_theory.simple_func.map c rs) a ≤ f n a},	x : ℝ≥0∞,	hx : x ∈ (measure_theory.simple_func.map c rs).range	⊢ x * ⇑μ (⇑(measure_theory.simple_func.map c rs) ⁻¹' {x}) = x * ⇑μ (⋃ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {x} ∩ {a : α | x ≤ f n a})
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	eq : ∀ (p : ℝ≥0∞), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} = ⋃ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} ∩ {a : α | p ≤ f n a},	mono : ∀ (r : ℝ≥0∞), monotone (λ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {r} ∩ {a : α | r ≤ f n a}),	h_meas : ∀ (n : ℕ), measurable_set {a : α | ⇑(measure_theory.simple_func.map c rs) a ≤ f n a},	x : ℝ≥0∞,	hx : x ∈ (measure_theory.simple_func.map c rs).range	⊢ x * ⇑μ (⋃ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {x} ∩ {a : α | x ≤ f n a}) = ⨆ (n : ℕ), x * ⇑μ (⇑(measure_theory.simple_func.map c rs) ⁻¹' {x} ∩ {a : α | x ≤ f n a})
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	eq : ∀ (p : ℝ≥0∞), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} = ⋃ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} ∩ {a : α | p ≤ f n a},	mono : ∀ (r : ℝ≥0∞), monotone (λ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {r} ∩ {a : α | r ≤ f n a}),	h_meas : ∀ (n : ℕ), measurable_set {a : α | ⇑(measure_theory.simple_func.map c rs) a ≤ f n a},	x : ℝ≥0∞,	hx : x ∈ (measure_theory.simple_func.map c rs).range	⊢ ∀ (i : ℕ), measurable_set ((λ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {x} ∩ {a : α | x ≤ f n a}) i)
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	eq : ∀ (p : ℝ≥0∞), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} = ⋃ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} ∩ {a : α | p ≤ f n a},	mono : ∀ (r : ℝ≥0∞), monotone (λ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {r} ∩ {a : α | r ≤ f n a}),	h_meas : ∀ (n : ℕ), measurable_set {a : α | ⇑(measure_theory.simple_func.map c rs) a ≤ f n a},	x : ℝ≥0∞,	hx : x ∈ (measure_theory.simple_func.map c rs).range,	i : ℕ	⊢ measurable_set ((λ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {x} ∩ {a : α | x ≤ f n a}) i)
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	eq : ∀ (p : ℝ≥0∞), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} = ⋃ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} ∩ {a : α | p ≤ f n a},	mono : ∀ (r : ℝ≥0∞), monotone (λ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {r} ∩ {a : α | r ≤ f n a}),	h_meas : ∀ (n : ℕ), measurable_set {a : α | ⇑(measure_theory.simple_func.map c rs) a ≤ f n a},	x : ℝ≥0∞,	hx : x ∈ (measure_theory.simple_func.map c rs).range,	i : ℕ	⊢ measurable_set {a : α | x ≤ f i a}
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	eq : ∀ (p : ℝ≥0∞), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} = ⋃ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} ∩ {a : α | p ≤ f n a},	mono : ∀ (r : ℝ≥0∞), monotone (λ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {r} ∩ {a : α | r ≤ f n a}),	h_meas : ∀ (n : ℕ), measurable_set {a : α | ⇑(measure_theory.simple_func.map c rs) a ≤ f n a}	⊢ (∑ (r : ℝ≥0∞) in (measure_theory.simple_func.map c rs).range, ⨆ (n : ℕ), r * ⇑μ (⇑(measure_theory.simple_func.map c rs) ⁻¹' {r} ∩ {a : α | r ≤ f n a})) ≤ ⨆ (n : ℕ), ∑ (r : ℝ≥0∞) in (measure_theory.simple_func.map c rs).range, r * ⇑μ (⇑(measure_theory.simple_func.map c rs) ⁻¹' {r} ∩ {a : α | r ≤ f n a})
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	eq : ∀ (p : ℝ≥0∞), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} = ⋃ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} ∩ {a : α | p ≤ f n a},	mono : ∀ (r : ℝ≥0∞), monotone (λ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {r} ∩ {a : α | r ≤ f n a}),	h_meas : ∀ (n : ℕ), measurable_set {a : α | ⇑(measure_theory.simple_func.map c rs) a ≤ f n a}	⊢ (∑ (r : ℝ≥0∞) in (measure_theory.simple_func.map c rs).range, ⨆ (n : ℕ), r * ⇑μ (⇑(measure_theory.simple_func.map c rs) ⁻¹' {r} ∩ {a : α | r ≤ f n a})) = ⨆ (n : ℕ), ∑ (r : ℝ≥0∞) in (measure_theory.simple_func.map c rs).range, r * ⇑μ (⇑(measure_theory.simple_func.map c rs) ⁻¹' {r} ∩ {a : α | r ≤ f n a})
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	eq : ∀ (p : ℝ≥0∞), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} = ⋃ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} ∩ {a : α | p ≤ f n a},	mono : ∀ (r : ℝ≥0∞), monotone (λ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {r} ∩ {a : α | r ≤ f n a}),	h_meas : ∀ (n : ℕ), measurable_set {a : α | ⇑(measure_theory.simple_func.map c rs) a ≤ f n a}	⊢ ∀ (a : ℝ≥0∞), monotone (λ (n : ℕ), a * ⇑μ (⇑(measure_theory.simple_func.map c rs) ⁻¹' {a} ∩ {a_1 : α | a ≤ f n a_1}))
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	eq : ∀ (p : ℝ≥0∞), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} = ⋃ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} ∩ {a : α | p ≤ f n a},	mono : ∀ (r : ℝ≥0∞), monotone (λ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {r} ∩ {a : α | r ≤ f n a}),	h_meas : ∀ (n : ℕ), measurable_set {a : α | ⇑(measure_theory.simple_func.map c rs) a ≤ f n a},	p : ℝ≥0∞,	i j : ℕ,	h : i ≤ j	⊢ (λ (n : ℕ), p * ⇑μ (⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} ∩ {a : α | p ≤ f n a})) i ≤ (λ (n : ℕ), p * ⇑μ (⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} ∩ {a : α | p ≤ f n a})) j
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	eq : ∀ (p : ℝ≥0∞), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} = ⋃ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} ∩ {a : α | p ≤ f n a},	mono : ∀ (r : ℝ≥0∞), monotone (λ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {r} ∩ {a : α | r ≤ f n a}),	h_meas : ∀ (n : ℕ), measurable_set {a : α | ⇑(measure_theory.simple_func.map c rs) a ≤ f n a}	⊢ (⨆ (n : ℕ), ∑ (r : ℝ≥0∞) in (measure_theory.simple_func.map c rs).range, r * ⇑μ (⇑(measure_theory.simple_func.map c rs) ⁻¹' {r} ∩ {a : α | r ≤ f n a})) ≤ ⨆ (n : ℕ), ((measure_theory.simple_func.map c rs).restrict {a : α | ⇑(measure_theory.simple_func.map c rs) a ≤ f n a}).lintegral μ
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	eq : ∀ (p : ℝ≥0∞), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} = ⋃ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} ∩ {a : α | p ≤ f n a},	mono : ∀ (r : ℝ≥0∞), monotone (λ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {r} ∩ {a : α | r ≤ f n a}),	h_meas : ∀ (n : ℕ), measurable_set {a : α | ⇑(measure_theory.simple_func.map c rs) a ≤ f n a},	n : ℕ	⊢ ∑ (r : ℝ≥0∞) in (measure_theory.simple_func.map c rs).range, r * ⇑μ (⇑(measure_theory.simple_func.map c rs) ⁻¹' {r} ∩ {a : α | r ≤ f n a}) ≤ ((measure_theory.simple_func.map c rs).restrict {a : α | ⇑(measure_theory.simple_func.map c rs) a ≤ f n a}).lintegral μ
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	eq : ∀ (p : ℝ≥0∞), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} = ⋃ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} ∩ {a : α | p ≤ f n a},	mono : ∀ (r : ℝ≥0∞), monotone (λ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {r} ∩ {a : α | r ≤ f n a}),	h_meas : ∀ (n : ℕ), measurable_set {a : α | ⇑(measure_theory.simple_func.map c rs) a ≤ f n a},	n : ℕ	⊢ ∑ (r : ℝ≥0∞) in (measure_theory.simple_func.map c rs).range, r * ⇑μ (⇑(measure_theory.simple_func.map c rs) ⁻¹' {r} ∩ {a : α | r ≤ f n a}) ≤ ∑ (r : ℝ≥0∞) in (measure_theory.simple_func.map c rs).range, r * ⇑μ (⇑(measure_theory.simple_func.map c rs) ⁻¹' {r} ∩ {a : α | ⇑(measure_theory.simple_func.map c rs) a ≤ f n a})
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	eq : ∀ (p : ℝ≥0∞), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} = ⋃ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} ∩ {a : α | p ≤ f n a},	mono : ∀ (r : ℝ≥0∞), monotone (λ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {r} ∩ {a : α | r ≤ f n a}),	h_meas : ∀ (n : ℕ), measurable_set {a : α | ⇑(measure_theory.simple_func.map c rs) a ≤ f n a},	n : ℕ,	r : ℝ≥0∞,	hr : r ∈ (measure_theory.simple_func.map c rs).range	⊢ r * ⇑μ (⇑(measure_theory.simple_func.map c rs) ⁻¹' {r} ∩ {a : α | r ≤ f n a}) = r * ⇑μ (⇑(measure_theory.simple_func.map c rs) ⁻¹' {r} ∩ {a : α | ⇑(measure_theory.simple_func.map c rs) a ≤ f n a})
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	eq : ∀ (p : ℝ≥0∞), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} = ⋃ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} ∩ {a : α | p ≤ f n a},	mono : ∀ (r : ℝ≥0∞), monotone (λ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {r} ∩ {a : α | r ≤ f n a}),	h_meas : ∀ (n : ℕ), measurable_set {a : α | ⇑(measure_theory.simple_func.map c rs) a ≤ f n a},	n : ℕ,	r : ℝ≥0∞,	hr : r ∈ (measure_theory.simple_func.map c rs).range,	a : α	⊢ a ∈ ⇑(measure_theory.simple_func.map c rs) ⁻¹' {r} ∩ {a : α | r ≤ f n a} ↔ a ∈ ⇑(measure_theory.simple_func.map c rs) ⁻¹' {r} ∩ {a : α | ⇑(measure_theory.simple_func.map c rs) a ≤ f n a}
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	eq : ∀ (p : ℝ≥0∞), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} = ⋃ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} ∩ {a : α | p ≤ f n a},	mono : ∀ (r : ℝ≥0∞), monotone (λ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {r} ∩ {a : α | r ≤ f n a}),	h_meas : ∀ (n : ℕ), measurable_set {a : α | ⇑(measure_theory.simple_func.map c rs) a ≤ f n a},	n : ℕ,	r : ℝ≥0∞,	hr : r ∈ (measure_theory.simple_func.map c rs).range,	a : α	⊢ a ∈ ⇑(measure_theory.simple_func.map c rs) ⁻¹' {r} → (a ∈ {a : α | r ≤ f n a} ↔ a ∈ {a : α | ⇑(measure_theory.simple_func.map c rs) a ≤ f n a})
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	eq : ∀ (p : ℝ≥0∞), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} = ⋃ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} ∩ {a : α | p ≤ f n a},	mono : ∀ (r : ℝ≥0∞), monotone (λ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {r} ∩ {a : α | r ≤ f n a}),	h_meas : ∀ (n : ℕ), measurable_set {a : α | ⇑(measure_theory.simple_func.map c rs) a ≤ f n a}	⊢ (⨆ (n : ℕ), ((measure_theory.simple_func.map c rs).restrict {a : α | ⇑(measure_theory.simple_func.map c rs) a ≤ f n a}).lintegral μ) ≤ ⨆ (n : ℕ), ∫⁻ (a : α), f n a ∂μ
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	eq : ∀ (p : ℝ≥0∞), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} = ⋃ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} ∩ {a : α | p ≤ f n a},	mono : ∀ (r : ℝ≥0∞), monotone (λ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {r} ∩ {a : α | r ≤ f n a}),	h_meas : ∀ (n : ℕ), measurable_set {a : α | ⇑(measure_theory.simple_func.map c rs) a ≤ f n a},	n : ℕ	⊢ ((measure_theory.simple_func.map c rs).restrict {a : α | ⇑(measure_theory.simple_func.map c rs) a ≤ f n a}).lintegral μ ≤ ∫⁻ (a : α), f n a ∂μ
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	eq : ∀ (p : ℝ≥0∞), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} = ⋃ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} ∩ {a : α | p ≤ f n a},	mono : ∀ (r : ℝ≥0∞), monotone (λ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {r} ∩ {a : α | r ≤ f n a}),	h_meas : ∀ (n : ℕ), measurable_set {a : α | ⇑(measure_theory.simple_func.map c rs) a ≤ f n a},	n : ℕ	⊢ ∫⁻ (a : α), ⇑((measure_theory.simple_func.map c rs).restrict {a : α | ⇑(measure_theory.simple_func.map c rs) a ≤ f n a}) a ∂μ ≤ ∫⁻ (a : α), f n a ∂μ
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	eq : ∀ (p : ℝ≥0∞), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} = ⋃ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} ∩ {a : α | p ≤ f n a},	mono : ∀ (r : ℝ≥0∞), monotone (λ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {r} ∩ {a : α | r ≤ f n a}),	h_meas : ∀ (n : ℕ), measurable_set {a : α | ⇑(measure_theory.simple_func.map c rs) a ≤ f n a},	n : ℕ,	a : α	⊢ (λ (a : α), ⇑((measure_theory.simple_func.map c rs).restrict {a : α | ⇑(measure_theory.simple_func.map c rs) a ≤ f n a}) a) a ≤ (λ (a : α), f n a) a
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	eq : ∀ (p : ℝ≥0∞), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} = ⋃ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} ∩ {a : α | p ≤ f n a},	mono : ∀ (r : ℝ≥0∞), monotone (λ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {r} ∩ {a : α | r ≤ f n a}),	n : ℕ,	a : α,	h_meas : ∀ (n : ℕ), measurable_set {a : α | c (r * ⇑s a) ≤ f n a}	⊢ (λ (a : α), ⇑((measure_theory.simple_func.map c rs).restrict {a : α | ⇑(measure_theory.simple_func.map c rs) a ≤ f n a}) a) a ≤ (λ (a : α), f n a) a
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : ℕ → α → ℝ≥0∞,	hf : ∀ (n : ℕ), measurable (f n),	h_mono : monotone f,	c : ℝ≥0 → ℝ≥0∞ := coe,	F : α → ℝ≥0∞ := λ (a : α), ⨆ (n : ℕ), f n a,	hF : measurable F,	s : α →ₛ ℝ≥0,	hsf : ∀ (x : α), ↑(⇑s x) ≤ ⨆ (n : ℕ), f n x,	r : ℝ≥0,	ha ha : ↑r < 1,	ha : r < 1,	rs : α →ₛ ℝ≥0 := measure_theory.simple_func.map (λ (a : ℝ≥0), r * a) s,	eq_rs : measure_theory.simple_func.const α ↑r * measure_theory.simple_func.map c s = measure_theory.simple_func.map c rs,	eq : ∀ (p : ℝ≥0∞), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} = ⋃ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {p} ∩ {a : α | p ≤ f n a},	mono : ∀ (r : ℝ≥0∞), monotone (λ (n : ℕ), ⇑(measure_theory.simple_func.map c rs) ⁻¹' {r} ∩ {a : α | r ≤ f n a}),	n : ℕ,	a : α,	h_meas : ∀ (n : ℕ), measurable_set {a : α | c (r * ⇑s a) ≤ f n a}	⊢ {a : α | c (r * ⇑s a) ≤ f n a}.indicator (λ (x : α), c (r * ⇑s x)) a ≤ f n a
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f g : α → ℝ≥0∞,	hf : measurable f,	hg : measurable g	⊢ ∫⁻ (a : α), f a + g a ∂μ = ∫⁻ (a : α), ((⨆ (n : ℕ), ⇑(measure_theory.simple_func.eapprox f n) a) + ⨆ (n : ℕ), ⇑(measure_theory.simple_func.eapprox g n) a) ∂μ
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f g : α → ℝ≥0∞,	hf : measurable f,	hg : measurable g	⊢ (λ (a : α), (⨆ (n : ℕ), ⇑(measure_theory.simple_func.eapprox f n) a) + ⨆ (n : ℕ), ⇑(measure_theory.simple_func.eapprox g n) a) = λ (a : α), ⨆ (n : ℕ), (⇑(measure_theory.simple_func.eapprox f n) + ⇑(measure_theory.simple_func.eapprox g n)) a
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f g : α → ℝ≥0∞,	hf : measurable f,	hg : measurable g	⊢ ∫⁻ (a : α), ((⨆ (n : ℕ), ⇑(measure_theory.simple_func.eapprox f n) a) + ⨆ (n : ℕ), ⇑(measure_theory.simple_func.eapprox g n) a) ∂μ = ∫⁻ (a : α), (⨆ (n : ℕ), (⇑(measure_theory.simple_func.eapprox f n) + ⇑(measure_theory.simple_func.eapprox g n)) a) ∂μ
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f g : α → ℝ≥0∞,	hf : measurable f,	hg : measurable g,	a : α	⊢ (⨆ (a_1 : ℕ), ⇑(measure_theory.simple_func.eapprox f a_1) a + ⇑(measure_theory.simple_func.eapprox g a_1) a) = ⨆ (n : ℕ), (⇑(measure_theory.simple_func.eapprox f n) + ⇑(measure_theory.simple_func.eapprox g n)) a
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f g : α → ℝ≥0∞,	hf : measurable f,	hg : measurable g,	a : α	⊢ (⨆ (a_1 : ℕ), ⇑(measure_theory.simple_func.eapprox f a_1) a + ⇑(measure_theory.simple_func.eapprox g a_1) a) = ⨆ (n : ℕ), (⇑(measure_theory.simple_func.eapprox f n) + ⇑(measure_theory.simple_func.eapprox g n)) a		α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f g : α → ℝ≥0∞,	hf : measurable f,	hg : measurable g,	a : α	⊢ monotone (λ (n : ℕ), ⇑(measure_theory.simple_func.eapprox f n) a)		α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f g : α → ℝ≥0∞,	hf : measurable f,	hg : measurable g,	a : α	⊢ monotone (λ (n : ℕ), ⇑(measure_theory.simple_func.eapprox g n) a)
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f g : α → ℝ≥0∞,	hf : measurable f,	hg : measurable g,	a : α	⊢ ((⨆ (n : ℕ), ⇑(measure_theory.simple_func.eapprox f n) a) + ⨆ (n : ℕ), ⇑(measure_theory.simple_func.eapprox g n) a) = ⨆ (n : ℕ), (⇑(measure_theory.simple_func.eapprox f n) + ⇑(measure_theory.simple_func.eapprox g n)) a
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f g : α → ℝ≥0∞,	hf : measurable f,	hg : measurable g,	a : α,	i j : ℕ,	h : i ≤ j	⊢ (λ (n : ℕ), ⇑(measure_theory.simple_func.eapprox f n) a) i ≤ (λ (n : ℕ), ⇑(measure_theory.simple_func.eapprox f n) a) j
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f g : α → ℝ≥0∞,	hf : measurable f,	hg : measurable g,	a : α	⊢ monotone (λ (n : ℕ), ⇑(measure_theory.simple_func.eapprox f n) a)		α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f g : α → ℝ≥0∞,	hf : measurable f,	hg : measurable g,	a : α	⊢ monotone (λ (n : ℕ), ⇑(measure_theory.simple_func.eapprox g n) a)
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f g : α → ℝ≥0∞,	hf : measurable f,	hg : measurable g,	a : α	⊢ monotone (λ (n : ℕ), ⇑(measure_theory.simple_func.eapprox f n) a)
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f g : α → ℝ≥0∞,	hf : measurable f,	hg : measurable g,	a : α,	i j : ℕ,	h : i ≤ j	⊢ (λ (n : ℕ), ⇑(measure_theory.simple_func.eapprox g n) a) i ≤ (λ (n : ℕ), ⇑(measure_theory.simple_func.eapprox g n) a) j
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f g : α → ℝ≥0∞,	hf : measurable f,	hg : measurable g,	a : α	⊢ monotone (λ (n : ℕ), ⇑(measure_theory.simple_func.eapprox g n) a)
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f g : α → ℝ≥0∞,	hf : measurable f,	hg : measurable g	⊢ ∫⁻ (a : α), (⨆ (n : ℕ), (⇑(measure_theory.simple_func.eapprox f n) + ⇑(measure_theory.simple_func.eapprox g n)) a) ∂μ = ⨆ (n : ℕ), (measure_theory.simple_func.eapprox f n).lintegral μ + (measure_theory.simple_func.eapprox g n).lintegral μ
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f g : α → ℝ≥0∞,	hf : measurable f,	hg : measurable g	⊢ (⨆ (n : ℕ), ∫⁻ (a : α), (⇑(measure_theory.simple_func.eapprox f n) + ⇑(measure_theory.simple_func.eapprox g n)) a ∂μ) = ⨆ (n : ℕ), (measure_theory.simple_func.eapprox f n).lintegral μ + (measure_theory.simple_func.eapprox g n).lintegral μ
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f g : α → ℝ≥0∞,	hf : measurable f,	hg : measurable g,	n : ℕ	⊢ ∫⁻ (a : α), (⇑(measure_theory.simple_func.eapprox f n) + ⇑(measure_theory.simple_func.eapprox g n)) a ∂μ = (measure_theory.simple_func.eapprox f n).lintegral μ + (measure_theory.simple_func.eapprox g n).lintegral μ
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f g : α → ℝ≥0∞,	hf : measurable f,	hg : measurable g	⊢ (λ (n : ℕ), ∫⁻ (a : α), (⇑(measure_theory.simple_func.eapprox f n) + ⇑(measure_theory.simple_func.eapprox g n)) a ∂μ) = λ (n : ℕ), (measure_theory.simple_func.eapprox f n).lintegral μ + (measure_theory.simple_func.eapprox g n).lintegral μ
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f g : α → ℝ≥0∞,	hf : measurable f,	hg : measurable g	⊢ (⨆ (n : ℕ), ∫⁻ (a : α), (⇑(measure_theory.simple_func.eapprox f n) + ⇑(measure_theory.simple_func.eapprox g n)) a ∂μ) = ⨆ (n : ℕ), (measure_theory.simple_func.eapprox f n).lintegral μ + (measure_theory.simple_func.eapprox g n).lintegral μ		α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f g : α → ℝ≥0∞,	hf : measurable f,	hg : measurable g	⊢ ∀ (n : ℕ), measurable (λ (a : α), (⇑(measure_theory.simple_func.eapprox f n) + ⇑(measure_theory.simple_func.eapprox g n)) a)		α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f g : α → ℝ≥0∞,	hf : measurable f,	hg : measurable g	⊢ monotone (λ (n : ℕ) (a : α), (⇑(measure_theory.simple_func.eapprox f n) + ⇑(measure_theory.simple_func.eapprox g n)) a)
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f g : α → ℝ≥0∞,	hf : measurable f,	hg : measurable g,	n : ℕ	⊢ ∫⁻ (a : α), (⇑(measure_theory.simple_func.eapprox f n) + ⇑(measure_theory.simple_func.eapprox g n)) a ∂μ = ∫⁻ (a : α), ⇑(measure_theory.simple_func.eapprox f n + measure_theory.simple_func.eapprox g n) a ∂μ
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f g : α → ℝ≥0∞,	hf : measurable f,	hg : measurable g	⊢ ∀ (n : ℕ), measurable (λ (a : α), (⇑(measure_theory.simple_func.eapprox f n) + ⇑(measure_theory.simple_func.eapprox g n)) a)		α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f g : α → ℝ≥0∞,	hf : measurable f,	hg : measurable g	⊢ monotone (λ (n : ℕ) (a : α), (⇑(measure_theory.simple_func.eapprox f n) + ⇑(measure_theory.simple_func.eapprox g n)) a)
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f g : α → ℝ≥0∞,	hf : measurable f,	hg : measurable g	⊢ ∀ (n : ℕ), measurable (λ (a : α), (⇑(measure_theory.simple_func.eapprox f n) + ⇑(measure_theory.simple_func.eapprox g n)) a)
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f g : α → ℝ≥0∞,	hf : measurable f,	hg : measurable g,	i j : ℕ,	h : i ≤ j,	a : α	⊢ (λ (n : ℕ) (a : α), (⇑(measure_theory.simple_func.eapprox f n) + ⇑(measure_theory.simple_func.eapprox g n)) a) i a ≤ (λ (n : ℕ) (a : α), (⇑(measure_theory.simple_func.eapprox f n) + ⇑(measure_theory.simple_func.eapprox g n)) a) j a
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f g : α → ℝ≥0∞,	hf : measurable f,	hg : measurable g	⊢ monotone (λ (n : ℕ) (a : α), (⇑(measure_theory.simple_func.eapprox f n) + ⇑(measure_theory.simple_func.eapprox g n)) a)
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f g : α → ℝ≥0∞,	hf : measurable f,	hg : measurable g	⊢ (⨆ (n : ℕ), (measure_theory.simple_func.eapprox f n).lintegral μ + (measure_theory.simple_func.eapprox g n).lintegral μ) = (⨆ (n : ℕ), (measure_theory.simple_func.eapprox f n).lintegral μ) + ⨆ (n : ℕ), (measure_theory.simple_func.eapprox g n).lintegral μ
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f g : α → ℝ≥0∞,	hf : measurable f,	hg : measurable g	⊢ (⨆ (n : ℕ), (measure_theory.simple_func.eapprox f n).lintegral μ + (measure_theory.simple_func.eapprox g n).lintegral μ) = (⨆ (n : ℕ), (measure_theory.simple_func.eapprox f n).lintegral μ) + ⨆ (n : ℕ), (measure_theory.simple_func.eapprox g n).lintegral μ
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f g : α → ℝ≥0∞,	hf : measurable f,	hg : measurable g,	i j : ℕ,	h : i ≤ j	⊢ (λ (n : ℕ), (measure_theory.simple_func.eapprox g n).lintegral μ) i ≤ (λ (n : ℕ), (measure_theory.simple_func.eapprox g n).lintegral μ) j
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f g : α → ℝ≥0∞,	hf : measurable f,	hg : measurable g	⊢ monotone (λ (n : ℕ), (measure_theory.simple_func.eapprox g n).lintegral μ)
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f g : α → ℝ≥0∞,	hf : measurable f,	hg : measurable g	⊢ ((⨆ (n : ℕ), (measure_theory.simple_func.eapprox f n).lintegral μ) + ⨆ (n : ℕ), (measure_theory.simple_func.eapprox g n).lintegral μ) = ∫⁻ (a : α), f a ∂μ + ∫⁻ (a : α), g a ∂μ
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ≥0∞,	hf : ∫⁻ (a : α), f a ∂μ ≠ ⊤	⊢ ⇑(μ.with_density f) set.univ < ⊤
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measurable f	⊢ μ.with_density (λ (x : α), ennreal.of_real (f x)) ⊥ₘ μ.with_density (λ (x : α), ennreal.of_real (-f x))
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measurable f,	S : set α := {x : α | f x < 0},	hSdef : S = {x : α | f x < 0}	⊢ μ.with_density (λ (x : α), ennreal.of_real (f x)) ⊥ₘ μ.with_density (λ (x : α), ennreal.of_real (-f x))
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measurable f,	S : set α := {x : α | f x < 0},	hSdef : S = {x : α | f x < 0},	hS : measurable_set S	⊢ μ.with_density (λ (x : α), ennreal.of_real (f x)) ⊥ₘ μ.with_density (λ (x : α), ennreal.of_real (-f x))
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measurable f,	S : set α := {x : α | f x < 0},	hSdef : S = {x : α | f x < 0},	hS : measurable_set S	⊢ ⇑(μ.with_density (λ (x : α), ennreal.of_real (f x))) S = 0
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measurable f,	S : set α := {x : α | f x < 0},	hSdef : S = {x : α | f x < 0},	hS : measurable_set S	⊢ ∫⁻ (a : α) in {x : α | f x < 0}, ennreal.of_real (f a) ∂μ = 0
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measurable f,	S : set α := {x : α | f x < 0},	hSdef : S = {x : α | f x < 0},	hS : measurable_set S	⊢ ∀ᵐ (x : α) ∂μ, x ∈ S → ennreal.of_real (f x) = 0
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measurable f,	S : set α := {x : α | f x < 0},	hSdef : S = {x : α | f x < 0},	hS : measurable_set S	⊢ ∀ᵐ (x : α) ∂μ, x ∈ S → ennreal.of_real (f x) = 0		α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measurable f,	S : set α := {x : α | f x < 0},	hSdef : S = {x : α | f x < 0},	hS : measurable_set S,	hf0 : ∀ᵐ (x : α) ∂μ, x ∈ S → ennreal.of_real (f x) = 0	⊢ ∫⁻ (a : α) in {x : α | f x < 0}, ennreal.of_real (f a) ∂μ = 0
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measurable f,	S : set α := {x : α | f x < 0},	hSdef : S = {x : α | f x < 0},	hS : measurable_set S,	_x : α,	hx : _x ∈ S	⊢ ennreal.of_real (f _x) = 0
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measurable f,	S : set α := {x : α | f x < 0},	hSdef : S = {x : α | f x < 0},	hS : measurable_set S,	hf0 : ∀ᵐ (x : α) ∂μ, x ∈ S → ennreal.of_real (f x) = 0	⊢ ∫⁻ (a : α) in {x : α | f x < 0}, ennreal.of_real (f a) ∂μ = 0
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measurable f,	S : set α := {x : α | f x < 0},	hSdef : S = {x : α | f x < 0},	hS : measurable_set S	⊢ ⇑(μ.with_density (λ (x : α), ennreal.of_real (f x))) S = 0		α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measurable f,	S : set α := {x : α | f x < 0},	hSdef : S = {x : α | f x < 0},	hS : measurable_set S	⊢ ⇑(μ.with_density (λ (x : α), ennreal.of_real (-f x))) Sᶜ = 0
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measurable f,	S : set α := {x : α | f x < 0},	hSdef : S = {x : α | f x < 0},	hS : measurable_set S,	hf0 : ∀ᵐ (x : α) ∂μ, x ∈ S → ennreal.of_real (f x) = 0	⊢ ∫⁻ (x : α) in S, (λ (x : α), 0) x ∂μ = 0
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measurable f,	S : set α := {x : α | f x < 0},	hSdef : S = {x : α | f x < 0},	hS : measurable_set S	⊢ ⇑(μ.with_density (λ (x : α), ennreal.of_real (-f x))) Sᶜ = 0
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measurable f,	S : set α := {x : α | f x < 0},	hSdef : S = {x : α | f x < 0},	hS : measurable_set S	⊢ ∫⁻ (a : α) in {x : α | f x < 0}ᶜ, ennreal.of_real (-f a) ∂μ = 0
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measurable f,	S : set α := {x : α | f x < 0},	hSdef : S = {x : α | f x < 0},	hS : measurable_set S	⊢ ∀ᵐ (x : α) ∂μ, x ∈ Sᶜ → ennreal.of_real (-f x) = 0
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measurable f,	S : set α := {x : α | f x < 0},	hSdef : S = {x : α | f x < 0},	hS : measurable_set S,	x : α,	hx : x ∈ Sᶜ	⊢ ennreal.of_real (-f x) = 0
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measurable f,	S : set α := {x : α | f x < 0},	hSdef : S = {x : α | f x < 0},	hS : measurable_set S	⊢ ∀ᵐ (x : α) ∂μ, x ∈ Sᶜ → ennreal.of_real (-f x) = 0		α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measurable f,	S : set α := {x : α | f x < 0},	hSdef : S = {x : α | f x < 0},	hS : measurable_set S,	hf0 : ∀ᵐ (x : α) ∂μ, x ∈ Sᶜ → ennreal.of_real (-f x) = 0	⊢ ∫⁻ (a : α) in {x : α | f x < 0}ᶜ, ennreal.of_real (-f a) ∂μ = 0
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measurable f,	S : set α := {x : α | f x < 0},	hSdef : S = {x : α | f x < 0},	hS : measurable_set S,	x : α,	hx : x ∈ Sᶜ	⊢ -f x ≤ 0
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measurable f,	S : set α := {x : α | f x < 0},	hSdef : S = {x : α | f x < 0},	hS : measurable_set S,	hf0 : ∀ᵐ (x : α) ∂μ, x ∈ Sᶜ → ennreal.of_real (-f x) = 0	⊢ ∫⁻ (a : α) in {x : α | f x < 0}ᶜ, ennreal.of_real (-f a) ∂μ = 0
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measurable f,	S : set α := {x : α | f x < 0},	hSdef : S = {x : α | f x < 0},	hS : measurable_set S,	hf0 : ∀ᵐ (x : α) ∂μ, x ∈ Sᶜ → ennreal.of_real (-f x) = 0	⊢ ∫⁻ (x : α) in Sᶜ, (λ (x : α), 0) x ∂μ = 0
α : Type u_1,	β : Type u_2,	γ : Type u_3,	_inst_1 : measurable_space α,	f : α →ₛ β,	g : β → γ,	s : set γ	⊢ ⇑(measure_theory.simple_func.map g f) ⁻¹' s = ⇑f ⁻¹' ↑(finset.filter (λ (b : β), g b ∈ s) f.range)
α : Type u_1,	β : Type u_2,	γ : Type u_3,	_inst_1 : measurable_space α,	f : α →ₛ β,	g : β → γ,	s : set γ	⊢ g ∘ ⇑f ⁻¹' s = ⇑f ⁻¹' (g ⁻¹' s)
α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : has_zero β,	_inst_3 : preorder β,	s : set α,	f g : α →ₛ β,	H : f ≤ g,	hs : measurable_set s,	x : α	⊢ ⇑(f.restrict s) x ≤ ⇑(g.restrict s) x
α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : has_zero β,	_inst_3 : preorder β,	s : set α,	f g : α →ₛ β,	H : f ≤ g,	hs : ¬measurable_set s	⊢ f.restrict s ≤ g.restrict s
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	p : ℝ,	hp0_lt : 0 < p,	f g : α → ℝ≥0∞,	hf : ae_measurable f μ,	hf_zero : ∫⁻ (a : α), f a ^ p ∂μ = 0	⊢ ∫⁻ (a : α), (f * g) a ∂μ = 0
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	p : ℝ,	hp0_lt : 0 < p,	f g : α → ℝ≥0∞,	hf : ae_measurable f μ,	hf_zero : ∫⁻ (a : α), f a ^ p ∂μ = 0	⊢ ∫⁻ (a : α), (f * g) a ∂μ = ∫⁻ (a : α), 0 a ∂μ
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	p : ℝ,	hp0_lt : 0 < p,	f g : α → ℝ≥0∞,	hf : ae_measurable f μ,	hf_zero : ∫⁻ (a : α), f a ^ p ∂μ = 0	⊢ (λ (a : α), (f * g) a) =ᵐ[μ] λ (a : α), 0 a
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	p : ℝ,	hp0_lt : 0 < p,	f g : α → ℝ≥0∞,	hf : ae_measurable f μ,	hf_zero : ∫⁻ (a : α), f a ^ p ∂μ = 0,	h_mul_zero : f * g =ᵐ[μ] 0 * g	⊢ (λ (a : α), (f * g) a) =ᵐ[μ] λ (a : α), 0 a
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	p : ℝ,	hp0_lt : 0 < p,	f g : α → ℝ≥0∞,	hf : ae_measurable f μ,	hf_zero : ∫⁻ (a : α), f a ^ p ∂μ = 0	⊢ f =ᵐ[μ] 0		α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	p : ℝ,	hp0_lt : 0 < p,	f g : α → ℝ≥0∞,	hf : ae_measurable f μ,	hf_zero : ∫⁻ (a : α), f a ^ p ∂μ = 0,	hf_eq_zero : f =ᵐ[μ] 0	⊢ f * g =ᵐ[μ] 0 * g
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	p : ℝ,	hp0_lt : 0 < p,	f g : α → ℝ≥0∞,	hf : ae_measurable f μ,	hf_zero : ∫⁻ (a : α), f a ^ p ∂μ = 0	⊢ f * g =ᵐ[μ] 0 * g
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	p : ℝ,	hp0_lt : 0 < p,	f g : α → ℝ≥0∞,	hf : ae_measurable f μ,	hf_zero : ∫⁻ (a : α), f a ^ p ∂μ = 0,	hf_eq_zero : f =ᵐ[μ] 0	⊢ f * g =ᵐ[μ] 0 * g
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measurable f,	hfi : measure_theory.integrable f μ,	h_meas : measurable_set {x : α | 0 ≤ f x}	⊢ ∫ (x : α), ∥f x∥ ∂μ = ∫ (x : α) in {x : α | 0 ≤ f x}, ∥f x∥ ∂μ + ∫ (x : α) in {x : α | 0 ≤ f x}ᶜ, ∥f x∥ ∂μ
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measurable f,	hfi : measure_theory.integrable f μ,	h_meas : measurable_set {x : α | 0 ≤ f x}	⊢ ∫ (x : α) in {x : α | 0 ≤ f x}, ∥f x∥ ∂μ + ∫ (x : α) in {x : α | 0 ≤ f x}ᶜ, ∥f x∥ ∂μ = ∫ (x : α) in {x : α | 0 ≤ f x}, f x ∂μ + ∫ (x : α) in {x : α | 0 ≤ f x}ᶜ, ∥f x∥ ∂μ
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measurable f,	hfi : measure_theory.integrable f μ,	h_meas : measurable_set {x : α | 0 ≤ f x}	⊢ ∫ (x : α) in {x : α | 0 ≤ f x}, ∥f x∥ ∂μ = ∫ (x : α) in {x : α | 0 ≤ f x}, f x ∂μ
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measurable f,	hfi : measure_theory.integrable f μ,	h_meas : measurable_set {x : α | 0 ≤ f x},	x : α,	hx : x ∈ {x : α | 0 ≤ f x}	⊢ (λ (x : α), ∥f x∥) x = (λ (x : α), f x) x
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measurable f,	hfi : measure_theory.integrable f μ,	h_meas : measurable_set {x : α | 0 ≤ f x},	x : α,	hx : x ∈ {x : α | 0 ≤ f x}	⊢ ∥f x∥ = f x
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measurable f,	hfi : measure_theory.integrable f μ,	h_meas : measurable_set {x : α | 0 ≤ f x},	x : α,	hx : x ∈ {x : α | 0 ≤ f x}	⊢ 0 ≤ f x
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measurable f,	hfi : measure_theory.integrable f μ,	h_meas : measurable_set {x : α | 0 ≤ f x}	⊢ ∫ (x : α) in {x : α | 0 ≤ f x}, f x ∂μ + ∫ (x : α) in {x : α | 0 ≤ f x}ᶜ, ∥f x∥ ∂μ = ∫ (x : α) in {x : α | 0 ≤ f x}, f x ∂μ - ∫ (x : α) in {x : α | 0 ≤ f x}ᶜ, f x ∂μ
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measurable f,	hfi : measure_theory.integrable f μ,	h_meas : measurable_set {x : α | 0 ≤ f x}	⊢ ∫ (x : α) in {x : α | 0 ≤ f x}ᶜ, ∥f x∥ ∂μ = -∫ (x : α) in {x : α | 0 ≤ f x}ᶜ, f x ∂μ
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measurable f,	hfi : measure_theory.integrable f μ,	h_meas : measurable_set {x : α | 0 ≤ f x}	⊢ ∫ (x : α) in {x : α | 0 ≤ f x}ᶜ, ∥f x∥ ∂μ = ∫ (a : α) in {x : α | 0 ≤ f x}ᶜ, -f a ∂μ
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measurable f,	hfi : measure_theory.integrable f μ,	h_meas : measurable_set {x : α | 0 ≤ f x},	x : α,	hx : x ∈ {x : α | 0 ≤ f x}ᶜ	⊢ (λ (x : α), ∥f x∥) x = (λ (a : α), -f a) x
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measurable f,	hfi : measure_theory.integrable f μ,	h_meas : measurable_set {x : α | 0 ≤ f x},	x : α,	hx : x ∈ {x : α | 0 ≤ f x}ᶜ	⊢ ∥f x∥ = -f x
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measurable f,	hfi : measure_theory.integrable f μ,	h_meas : measurable_set {x : α | 0 ≤ f x},	x : α,	hx : x ∈ {x : α | 0 ≤ f x}ᶜ	⊢ f x ≤ 0
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measurable f,	hfi : measure_theory.integrable f μ,	h_meas : measurable_set {x : α | 0 ≤ f x},	x : α,	hx : ¬0 ≤ f x	⊢ f x ≤ 0
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measurable f,	hfi : measure_theory.integrable f μ,	h_meas : measurable_set {x : α | 0 ≤ f x}	⊢ ∫ (x : α) in {x : α | 0 ≤ f x}, f x ∂μ - ∫ (x : α) in {x : α | 0 ≤ f x}ᶜ, f x ∂μ = ∫ (x : α) in {x : α | 0 ≤ f x}, f x ∂μ - ∫ (x : α) in {x : α | f x < 0}, f x ∂μ
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measurable f,	hfi : measure_theory.integrable f μ,	h_meas : measurable_set {x : α | 0 ≤ f x}	⊢ {x : α | 0 ≤ f x}ᶜ = {x : α | f x < 0}
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measurable f,	hfi : measure_theory.integrable f μ,	h_meas : measurable_set {x : α | 0 ≤ f x}	⊢ ∫ (x : α) in {x : α | 0 ≤ f x}, f x ∂μ - ∫ (x : α) in {x : α | 0 ≤ f x}ᶜ, f x ∂μ = ∫ (x : α) in {x : α | 0 ≤ f x}, f x ∂μ - ∫ (x : α) in {x : α | f x ≤ 0}, f x ∂μ
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	f : α → ℝ,	hf : measurable f,	hfi : measure_theory.integrable f μ,	h_meas : measurable_set {x : α | 0 ≤ f x},	x : α	⊢ x ∈ {x : α | 0 ≤ f x}ᶜ ↔ x ∈ {x : α | f x < 0}
α : Type u_1,	F : Type u_4,	_inst_1 : measurable_space α,	𝕜 : Type u_5,	_inst_6 : is_R_or_C 𝕜,	_inst_7 : measurable_space 𝕜,	_inst_8 : normed_group F,	_inst_9 : measurable_space F,	_inst_10 : topological_space.second_countable_topology F,	_inst_11 : borel_space F,	_inst_12 : normed_space 𝕜 F,	_inst_13 : borel_space 𝕜,	μ : measure_theory.measure α,	p : ℝ≥0∞,	hp : fact (1 ≤ p),	s : set α	⊢ ∀ (x : ↥(measure_theory.Lp F p μ)), ∥⇑{to_fun := λ (f : ↥(measure_theory.Lp F p μ)), measure_theory.mem_ℒp.to_Lp ⇑f _, map_add' := _, map_smul' := _} x∥ ≤ 1 * ∥x∥
α : Type u_1,	F : Type u_4,	_inst_1 : measurable_space α,	𝕜 : Type u_5,	_inst_6 : is_R_or_C 𝕜,	_inst_7 : measurable_space 𝕜,	_inst_8 : normed_group F,	_inst_9 : measurable_space F,	_inst_10 : topological_space.second_countable_topology F,	_inst_11 : borel_space F,	_inst_12 : normed_space 𝕜 F,	_inst_13 : borel_space 𝕜,	μ : measure_theory.measure α,	p : ℝ≥0∞,	hp : fact (1 ≤ p),	s : set α,	f : ↥(measure_theory.Lp F p μ)	⊢ ∥⇑{to_fun := λ (f : ↥(measure_theory.Lp F p μ)), measure_theory.mem_ℒp.to_Lp ⇑f _, map_add' := _, map_smul' := _} f∥ ≤ 1 * ∥f∥
α : Type u_1,	F : Type u_4,	_inst_1 : measurable_space α,	𝕜 : Type u_5,	_inst_6 : is_R_or_C 𝕜,	_inst_7 : measurable_space 𝕜,	_inst_8 : normed_group F,	_inst_9 : measurable_space F,	_inst_10 : topological_space.second_countable_topology F,	_inst_11 : borel_space F,	_inst_12 : normed_space 𝕜 F,	_inst_13 : borel_space 𝕜,	μ : measure_theory.measure α,	p : ℝ≥0∞,	hp : fact (1 ≤ p),	s : set α,	f : ↥(measure_theory.Lp F p μ)	⊢ ∥⇑{to_fun := λ (f : ↥(measure_theory.Lp F p μ)), measure_theory.mem_ℒp.to_Lp ⇑f _, map_add' := _, map_smul' := _} f∥ ≤ ∥f∥
α : Type u_1,	E : Type u_2,	F : Type u_3,	_inst_1 : normed_group E,	_inst_2 : measurable_space E,	_inst_3 : normed_space ℝ E,	_inst_4 : normed_group F,	_inst_5 : normed_space ℝ F,	m : measurable_space α,	μ : measure_theory.measure α,	_inst_10 : topological_space.second_countable_topology E,	_inst_11 : borel_space E,	T : set α → (E →L[ℝ] F),	C : ℝ,	hT_norm : ∀ (s : set α), ∥T s∥ ≤ C * (⇑μ s).to_real,	f : ↥(measure_theory.Lp.simple_func E 1 μ)	⊢ ∥measure_theory.L1.simple_func.set_to_L1s T f∥ ≤ C * ∥f∥
α : Type u_1,	E : Type u_2,	F : Type u_3,	_inst_1 : normed_group E,	_inst_2 : measurable_space E,	_inst_3 : normed_space ℝ E,	_inst_4 : normed_group F,	_inst_5 : normed_space ℝ F,	m : measurable_space α,	μ : measure_theory.measure α,	_inst_10 : topological_space.second_countable_topology E,	_inst_11 : borel_space E,	T : set α → (E →L[ℝ] F),	C : ℝ,	hT_norm : ∀ (s : set α), ∥T s∥ ≤ C * (⇑μ s).to_real,	f : ↥(measure_theory.Lp.simple_func E 1 μ)	⊢ ∥measure_theory.simple_func.set_to_simple_func T (measure_theory.Lp.simple_func.to_simple_func f)∥ ≤ C * ∑ (x : E) in (measure_theory.Lp.simple_func.to_simple_func f).range, (⇑μ (⇑(measure_theory.Lp.simple_func.to_simple_func f) ⁻¹' {x})).to_real * ∥x∥
α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	μ : measure_theory.measure α,	_inst_4 : μ.weakly_regular,	c : ℝ≥0,	s : set α,	hs : measurable_set s,	ε : ℝ≥0∞,	ε0 : ε ≠ 0,	f : α →ₛ ℝ≥0 := measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0),	h : ∫⁻ (x : α), ↑(⇑f x) ∂μ = ⊤,	x : α	⊢ ⇑(measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0)) x ≤ c
α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	μ : measure_theory.measure α,	_inst_4 : μ.weakly_regular,	c : ℝ≥0,	s : set α,	hs : measurable_set s,	ε : ℝ≥0∞,	ε0 : ε ≠ 0,	f : α →ₛ ℝ≥0 := measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0),	h : ∫⁻ (x : α), ↑(⇑f x) ∂μ = ⊤	⊢ ∃ (g : α → ℝ≥0), (∀ (x : α), ⇑(measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0)) x ≤ g x) ∧ lower_semicontinuous g ∧ ∫⁻ (x : α), ↑(g x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑(measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0)) x) ∂μ + ε		α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	μ : measure_theory.measure α,	_inst_4 : μ.weakly_regular,	c : ℝ≥0,	s : set α,	hs : measurable_set s,	ε : ℝ≥0∞,	ε0 : ε ≠ 0,	f : α →ₛ ℝ≥0 := measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0),	h : ¬∫⁻ (x : α), ↑(⇑f x) ∂μ = ⊤	⊢ ∃ (g : α → ℝ≥0), (∀ (x : α), ⇑(measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0)) x ≤ g x) ∧ lower_semicontinuous g ∧ ∫⁻ (x : α), ↑(g x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑(measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0)) x) ∂μ + ε
α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	μ : measure_theory.measure α,	_inst_4 : μ.weakly_regular,	c : ℝ≥0,	s : set α,	hs : measurable_set s,	ε : ℝ≥0∞,	ε0 : ε ≠ 0,	f : α →ₛ ℝ≥0 := measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0),	h : ∫⁻ (x : α), ↑(⇑f x) ∂μ = ⊤,	x : α	⊢ s.indicator (function.const α c) x ≤ c
α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	μ : measure_theory.measure α,	_inst_4 : μ.weakly_regular,	c : ℝ≥0,	s : set α,	hs : measurable_set s,	ε : ℝ≥0∞,	ε0 : ε ≠ 0,	f : α →ₛ ℝ≥0 := measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0),	h : ¬∫⁻ (x : α), ↑(⇑f x) ∂μ = ⊤	⊢ ∃ (g : α → ℝ≥0), (∀ (x : α), ⇑(measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0)) x ≤ g x) ∧ lower_semicontinuous g ∧ ∫⁻ (x : α), ↑(g x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑(measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0)) x) ∂μ + ε
α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	μ : measure_theory.measure α,	_inst_4 : μ.weakly_regular,	c : ℝ≥0,	s : set α,	hs : measurable_set s,	ε : ℝ≥0∞,	ε0 : ε ≠ 0,	f : α →ₛ ℝ≥0 := measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0),	h : ¬∫⁻ (x : α), ↑(⇑f x) ∂μ = ⊤,	hc : c = 0	⊢ ∃ (g : α → ℝ≥0), (∀ (x : α), ⇑(measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0)) x ≤ g x) ∧ lower_semicontinuous g ∧ ∫⁻ (x : α), ↑(g x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑(measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0)) x) ∂μ + ε
α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	μ : measure_theory.measure α,	_inst_4 : μ.weakly_regular,	c : ℝ≥0,	s : set α,	hs : measurable_set s,	ε : ℝ≥0∞,	ε0 : ε ≠ 0,	f : α →ₛ ℝ≥0 := measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0),	h : ¬∫⁻ (x : α), ↑(⇑f x) ∂μ = ⊤,	hc : c = 0	⊢ ∀ (x : α), ⇑(measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0)) x ≤ 0
α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	μ : measure_theory.measure α,	_inst_4 : μ.weakly_regular,	c : ℝ≥0,	s : set α,	hs : measurable_set s,	ε : ℝ≥0∞,	ε0 : ε ≠ 0,	f : α →ₛ ℝ≥0 := measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0),	h : ¬∫⁻ (x : α), ↑(⇑f x) ∂μ = ⊤,	hc : c = 0	⊢ ∀ (x : α), ⇑(measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0)) x ≤ 0		α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	μ : measure_theory.measure α,	_inst_4 : μ.weakly_regular,	c : ℝ≥0,	s : set α,	hs : measurable_set s,	ε : ℝ≥0∞,	ε0 : ε ≠ 0,	f : α →ₛ ℝ≥0 := measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0),	h : ¬∫⁻ (x : α), ↑(⇑f x) ∂μ = ⊤,	hc : c = 0	⊢ ∫⁻ (x : α), ↑0 ∂μ ≤ ∫⁻ (x : α), ↑(⇑(measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0)) x) ∂μ + ε
α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	μ : measure_theory.measure α,	_inst_4 : μ.weakly_regular,	c : ℝ≥0,	s : set α,	hs : measurable_set s,	ε : ℝ≥0∞,	ε0 : ε ≠ 0,	f : α →ₛ ℝ≥0 := measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0),	h : ¬∫⁻ (x : α), ↑(⇑f x) ∂μ = ⊤,	hc : c = 0	⊢ ∃ (g : α → ℝ≥0), (∀ (x : α), ⇑(measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0)) x ≤ g x) ∧ lower_semicontinuous g ∧ ∫⁻ (x : α), ↑(g x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑(measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0)) x) ∂μ + ε		α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	μ : measure_theory.measure α,	_inst_4 : μ.weakly_regular,	c : ℝ≥0,	s : set α,	hs : measurable_set s,	ε : ℝ≥0∞,	ε0 : ε ≠ 0,	f : α →ₛ ℝ≥0 := measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0),	h : ¬∫⁻ (x : α), ↑(⇑f x) ∂μ = ⊤,	hc : ¬c = 0	⊢ ∃ (g : α → ℝ≥0), (∀ (x : α), ⇑(measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0)) x ≤ g x) ∧ lower_semicontinuous g ∧ ∫⁻ (x : α), ↑(g x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑(measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0)) x) ∂μ + ε
α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	μ : measure_theory.measure α,	_inst_4 : μ.weakly_regular,	c : ℝ≥0,	s : set α,	hs : measurable_set s,	ε : ℝ≥0∞,	ε0 : ε ≠ 0,	f : α →ₛ ℝ≥0 := measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0),	h : ¬∫⁻ (x : α), ↑(⇑f x) ∂μ = ⊤,	hc : c = 0	⊢ ∫⁻ (x : α), ↑0 ∂μ ≤ ∫⁻ (x : α), ↑(⇑(measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0)) x) ∂μ + ε
α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	μ : measure_theory.measure α,	_inst_4 : μ.weakly_regular,	c : ℝ≥0,	s : set α,	hs : measurable_set s,	ε : ℝ≥0∞,	ε0 : ε ≠ 0,	f : α →ₛ ℝ≥0 := measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0),	h : ¬∫⁻ (x : α), ↑(⇑f x) ∂μ = ⊤,	hc : ¬c = 0	⊢ ∃ (g : α → ℝ≥0), (∀ (x : α), ⇑(measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0)) x ≤ g x) ∧ lower_semicontinuous g ∧ ∫⁻ (x : α), ↑(g x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑(measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0)) x) ∂μ + ε
α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	μ : measure_theory.measure α,	_inst_4 : μ.weakly_regular,	c : ℝ≥0,	s : set α,	hs : measurable_set s,	ε : ℝ≥0∞,	ε0 : ε ≠ 0,	f : α →ₛ ℝ≥0 := measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0),	h : ¬∫⁻ (x : α), ↑(⇑f x) ∂μ = ⊤,	hc : ¬c = 0	⊢ ⇑μ s < ⇑μ s + ε / ↑c
α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	μ : measure_theory.measure α,	_inst_4 : μ.weakly_regular,	c : ℝ≥0,	s : set α,	hs : measurable_set s,	ε : ℝ≥0∞,	ε0 : ε ≠ 0,	f : α →ₛ ℝ≥0 := measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0),	h : ¬∫⁻ (x : α), ↑(⇑f x) ∂μ = ⊤,	hc : ¬c = 0,	this : 0 < ε / ↑c	⊢ ⇑μ s < ⇑μ s + ε / ↑c
α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	μ : measure_theory.measure α,	_inst_4 : μ.weakly_regular,	c : ℝ≥0,	s : set α,	hs : measurable_set s,	ε : ℝ≥0∞,	ε0 : ε ≠ 0,	f : α →ₛ ℝ≥0 := measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0),	h : ¬∫⁻ (x : α), ↑(⇑f x) ∂μ = ⊤,	hc : ¬c = 0,	this : 0 < ε / ↑c	⊢ ⇑μ s ≠ ⊤
α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	μ : measure_theory.measure α,	_inst_4 : μ.weakly_regular,	c : ℝ≥0,	s : set α,	hs : measurable_set s,	ε : ℝ≥0∞,	ε0 : ε ≠ 0,	f : α →ₛ ℝ≥0 := measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0),	h : ¬∫⁻ (x : α), ↑(⇑f x) ∂μ = ⊤,	hc : ¬c = 0	⊢ ⇑μ s < ⇑μ s + ε / ↑c		α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	μ : measure_theory.measure α,	_inst_4 : μ.weakly_regular,	c : ℝ≥0,	s : set α,	hs : measurable_set s,	ε : ℝ≥0∞,	ε0 : ε ≠ 0,	f : α →ₛ ℝ≥0 := measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0),	h : ¬∫⁻ (x : α), ↑(⇑f x) ∂μ = ⊤,	hc : ¬c = 0,	this : ⇑μ s < ⇑μ s + ε / ↑c	⊢ ∃ (g : α → ℝ≥0), (∀ (x : α), ⇑(measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0)) x ≤ g x) ∧ lower_semicontinuous g ∧ ∫⁻ (x : α), ↑(g x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑(measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0)) x) ∂μ + ε
α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	μ : measure_theory.measure α,	_inst_4 : μ.weakly_regular,	c : ℝ≥0,	s : set α,	hs : measurable_set s,	ε : ℝ≥0∞,	ε0 : ε ≠ 0,	f : α →ₛ ℝ≥0 := measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0),	h : ¬∫⁻ (x : α), ↑(⇑f x) ∂μ = ⊤,	hc : ¬c = 0,	this : ⇑μ s < ⇑μ s + ε / ↑c	⊢ ∃ (g : α → ℝ≥0), (∀ (x : α), ⇑(measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0)) x ≤ g x) ∧ lower_semicontinuous g ∧ ∫⁻ (x : α), ↑(g x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑(measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0)) x) ∂μ + ε
α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	μ : measure_theory.measure α,	_inst_4 : μ.weakly_regular,	c : ℝ≥0,	s : set α,	hs : measurable_set s,	ε : ℝ≥0∞,	ε0 : ε ≠ 0,	f : α →ₛ ℝ≥0 := measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0),	h : ¬∫⁻ (x : α), ↑(⇑f x) ∂μ = ⊤,	hc : ¬c = 0,	this : ⇑μ s < ⇑μ s + ε / ↑c,	u : set α,	su : u ⊇ s,	u_open : is_open u,	μu : ⇑μ u < ⇑μ s + ε / ↑c	⊢ ∃ (g : α → ℝ≥0), (∀ (x : α), ⇑(measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0)) x ≤ g x) ∧ lower_semicontinuous g ∧ ∫⁻ (x : α), ↑(g x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑(measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0)) x) ∂μ + ε
α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	μ : measure_theory.measure α,	_inst_4 : μ.weakly_regular,	c : ℝ≥0,	s : set α,	hs : measurable_set s,	ε : ℝ≥0∞,	ε0 : ε ≠ 0,	f : α →ₛ ℝ≥0 := measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0),	h : ¬∫⁻ (x : α), ↑(⇑f x) ∂μ = ⊤,	hc : ¬c = 0,	this : ⇑μ s < ⇑μ s + ε / ↑c,	u : set α,	su : u ⊇ s,	u_open : is_open u,	μu : ⇑μ u < ⇑μ s + ε / ↑c,	x : α	⊢ ⇑(measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0)) x ≤ u.indicator (λ (x : α), c) x
α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	μ : measure_theory.measure α,	_inst_4 : μ.weakly_regular,	c : ℝ≥0,	s : set α,	hs : measurable_set s,	ε : ℝ≥0∞,	ε0 : ε ≠ 0,	f : α →ₛ ℝ≥0 := measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0),	h : ¬∫⁻ (x : α), ↑(⇑f x) ∂μ = ⊤,	hc : ¬c = 0,	this : ⇑μ s < ⇑μ s + ε / ↑c,	u : set α,	su : u ⊇ s,	u_open : is_open u,	μu : ⇑μ u < ⇑μ s + ε / ↑c,	x : α	⊢ ⇑(measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0)) x ≤ u.indicator (λ (x : α), c) x		α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	μ : measure_theory.measure α,	_inst_4 : μ.weakly_regular,	c : ℝ≥0,	s : set α,	hs : measurable_set s,	ε : ℝ≥0∞,	ε0 : ε ≠ 0,	f : α →ₛ ℝ≥0 := measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0),	h : ¬∫⁻ (x : α), ↑(⇑f x) ∂μ = ⊤,	hc : ¬c = 0,	this : ⇑μ s < ⇑μ s + ε / ↑c,	u : set α,	su : u ⊇ s,	u_open : is_open u,	μu : ⇑μ u < ⇑μ s + ε / ↑c	⊢ ∫⁻ (x : α), ↑(u.indicator (λ (x : α), c) x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑(measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0)) x) ∂μ + ε
α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	μ : measure_theory.measure α,	_inst_4 : μ.weakly_regular,	c : ℝ≥0,	s : set α,	hs : measurable_set s,	ε : ℝ≥0∞,	ε0 : ε ≠ 0,	f : α →ₛ ℝ≥0 := measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0),	h : ¬∫⁻ (x : α), ↑(⇑f x) ∂μ = ⊤,	hc : ¬c = 0,	this : ⇑μ s < ⇑μ s + ε / ↑c,	u : set α,	su : u ⊇ s,	u_open : is_open u,	μu : ⇑μ u < ⇑μ s + ε / ↑c,	x : α	⊢ s.indicator (function.const α c) x ≤ u.indicator (λ (x : α), c) x
α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	μ : measure_theory.measure α,	_inst_4 : μ.weakly_regular,	c : ℝ≥0,	s : set α,	hs : measurable_set s,	ε : ℝ≥0∞,	ε0 : ε ≠ 0,	f : α →ₛ ℝ≥0 := measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0),	h : ¬∫⁻ (x : α), ↑(⇑f x) ∂μ = ⊤,	hc : ¬c = 0,	this : ⇑μ s < ⇑μ s + ε / ↑c,	u : set α,	su : u ⊇ s,	u_open : is_open u,	μu : ⇑μ u < ⇑μ s + ε / ↑c	⊢ ∫⁻ (x : α), ↑(u.indicator (λ (x : α), c) x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑(measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0)) x) ∂μ + ε
α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	μ : measure_theory.measure α,	_inst_4 : μ.weakly_regular,	c : ℝ≥0,	s : set α,	hs : measurable_set s,	ε : ℝ≥0∞,	ε0 : ε ≠ 0,	f : α →ₛ ℝ≥0 := measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0),	h : ¬∫⁻ (x : α), ↑(⇑f x) ∂μ = ⊤,	hc : ¬c = 0,	this : ⇑μ s < ⇑μ s + ε / ↑c,	u : set α,	su : u ⊇ s,	u_open : is_open u,	μu : ⇑μ u < ⇑μ s + ε / ↑c,	this : ↑c * ⇑μ u ≤ ↑c * ⇑μ s + ε	⊢ ∫⁻ (x : α), ↑(u.indicator (λ (x : α), c) x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑(measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0)) x) ∂μ + ε
α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	μ : measure_theory.measure α,	_inst_4 : μ.weakly_regular,	c : ℝ≥0,	s : set α,	hs : measurable_set s,	ε : ℝ≥0∞,	ε0 : ε ≠ 0,	f : α →ₛ ℝ≥0 := measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0),	h : ¬∫⁻ (x : α), ↑(⇑f x) ∂μ = ⊤,	hc : ¬c = 0,	this : ⇑μ s < ⇑μ s + ε / ↑c,	u : set α,	su : u ⊇ s,	u_open : is_open u,	μu : ⇑μ u < ⇑μ s + ε / ↑c	⊢ ↑c * ⇑μ u ≤ ↑c * ⇑μ s + ε
α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	μ : measure_theory.measure α,	_inst_4 : μ.weakly_regular,	c : ℝ≥0,	s : set α,	hs : measurable_set s,	ε : ℝ≥0∞,	ε0 : ε ≠ 0,	f : α →ₛ ℝ≥0 := measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0),	h : ¬∫⁻ (x : α), ↑(⇑f x) ∂μ = ⊤,	hc : ¬c = 0,	this : ⇑μ s < ⇑μ s + ε / ↑c,	u : set α,	su : u ⊇ s,	u_open : is_open u,	μu : ⇑μ u < ⇑μ s + ε / ↑c	⊢ ↑c * (⇑μ s + ε / ↑c) = ↑c * ⇑μ s + ε
α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	μ : measure_theory.measure α,	_inst_4 : μ.weakly_regular,	c : ℝ≥0,	s : set α,	hs : measurable_set s,	ε : ℝ≥0∞,	ε0 : ε ≠ 0,	f : α →ₛ ℝ≥0 := measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0),	h : ¬∫⁻ (x : α), ↑(⇑f x) ∂μ = ⊤,	hc : ¬c = 0,	this : ⇑μ s < ⇑μ s + ε / ↑c,	u : set α,	su : u ⊇ s,	u_open : is_open u,	μu : ⇑μ u < ⇑μ s + ε / ↑c	⊢ ↑c * ⇑μ s + ↑c * (ε / ↑c) = ↑c * ⇑μ s + ε
α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	μ : measure_theory.measure α,	_inst_4 : μ.weakly_regular,	c : ℝ≥0,	s : set α,	hs : measurable_set s,	ε : ℝ≥0∞,	ε0 : ε ≠ 0,	f : α →ₛ ℝ≥0 := measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0),	h : ¬∫⁻ (x : α), ↑(⇑f x) ∂μ = ⊤,	hc : ¬c = 0,	this : ⇑μ s < ⇑μ s + ε / ↑c,	u : set α,	su : u ⊇ s,	u_open : is_open u,	μu : ⇑μ u < ⇑μ s + ε / ↑c	⊢ ↑c ≠ 0
α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	μ : measure_theory.measure α,	_inst_4 : μ.weakly_regular,	c : ℝ≥0,	s : set α,	hs : measurable_set s,	ε : ℝ≥0∞,	ε0 : ε ≠ 0	⊢ ∃ (g : α → ℝ≥0), (∀ (x : α), ⇑(measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0)) x ≤ g x) ∧ lower_semicontinuous g ∧ ∫⁻ (x : α), ↑(g x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑(measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0)) x) ∂μ + ε		case h_add	α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	μ : measure_theory.measure α,	_inst_4 : μ.weakly_regular,	f₁ f₂ : α →ₛ ℝ≥0,	H : disjoint (function.support ⇑f₁) (function.support ⇑f₂),	h₁ : ∀ {ε : ℝ≥0∞}, ε ≠ 0 → (∃ (g : α → ℝ≥0), (∀ (x : α), ⇑f₁ x ≤ g x) ∧ lower_semicontinuous g ∧ ∫⁻ (x : α), ↑(g x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑f₁ x) ∂μ + ε),	h₂ : ∀ {ε : ℝ≥0∞}, ε ≠ 0 → (∃ (g : α → ℝ≥0), (∀ (x : α), ⇑f₂ x ≤ g x) ∧ lower_semicontinuous g ∧ ∫⁻ (x : α), ↑(g x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑f₂ x) ∂μ + ε),	ε : ℝ≥0∞,	ε0 : ε ≠ 0	⊢ ∃ (g : α → ℝ≥0), (∀ (x : α), ⇑(f₁ + f₂) x ≤ g x) ∧ lower_semicontinuous g ∧ ∫⁻ (x : α), ↑(g x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑(f₁ + f₂) x) ∂μ + ε
α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	μ : measure_theory.measure α,	_inst_4 : μ.weakly_regular,	f₁ f₂ : α →ₛ ℝ≥0,	H : disjoint (function.support ⇑f₁) (function.support ⇑f₂),	h₁ : ∀ {ε : ℝ≥0∞}, ε ≠ 0 → (∃ (g : α → ℝ≥0), (∀ (x : α), ⇑f₁ x ≤ g x) ∧ lower_semicontinuous g ∧ ∫⁻ (x : α), ↑(g x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑f₁ x) ∂μ + ε),	h₂ : ∀ {ε : ℝ≥0∞}, ε ≠ 0 → (∃ (g : α → ℝ≥0), (∀ (x : α), ⇑f₂ x ≤ g x) ∧ lower_semicontinuous g ∧ ∫⁻ (x : α), ↑(g x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑f₂ x) ∂μ + ε),	ε : ℝ≥0∞,	ε0 : ε ≠ 0	⊢ ∃ (g : α → ℝ≥0), (∀ (x : α), ⇑(f₁ + f₂) x ≤ g x) ∧ lower_semicontinuous g ∧ ∫⁻ (x : α), ↑(g x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑(f₁ + f₂) x) ∂μ + ε
α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	μ : measure_theory.measure α,	_inst_4 : μ.weakly_regular,	f₁ f₂ : α →ₛ ℝ≥0,	H : disjoint (function.support ⇑f₁) (function.support ⇑f₂),	h₁ : ∀ {ε : ℝ≥0∞}, ε ≠ 0 → (∃ (g : α → ℝ≥0), (∀ (x : α), ⇑f₁ x ≤ g x) ∧ lower_semicontinuous g ∧ ∫⁻ (x : α), ↑(g x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑f₁ x) ∂μ + ε),	h₂ : ∀ {ε : ℝ≥0∞}, ε ≠ 0 → (∃ (g : α → ℝ≥0), (∀ (x : α), ⇑f₂ x ≤ g x) ∧ lower_semicontinuous g ∧ ∫⁻ (x : α), ↑(g x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑f₂ x) ∂μ + ε),	ε : ℝ≥0∞,	ε0 : ε ≠ 0,	g₁ : α → ℝ≥0,	f₁_le_g₁ : ∀ (x : α), ⇑f₁ x ≤ g₁ x,	g₁cont : lower_semicontinuous g₁,	g₁int : ∫⁻ (x : α), ↑(g₁ x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑f₁ x) ∂μ + ε / 2	⊢ ∃ (g : α → ℝ≥0), (∀ (x : α), ⇑(f₁ + f₂) x ≤ g x) ∧ lower_semicontinuous g ∧ ∫⁻ (x : α), ↑(g x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑(f₁ + f₂) x) ∂μ + ε
α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	μ : measure_theory.measure α,	_inst_4 : μ.weakly_regular,	f₁ f₂ : α →ₛ ℝ≥0,	H : disjoint (function.support ⇑f₁) (function.support ⇑f₂),	h₁ : ∀ {ε : ℝ≥0∞}, ε ≠ 0 → (∃ (g : α → ℝ≥0), (∀ (x : α), ⇑f₁ x ≤ g x) ∧ lower_semicontinuous g ∧ ∫⁻ (x : α), ↑(g x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑f₁ x) ∂μ + ε),	h₂ : ∀ {ε : ℝ≥0∞}, ε ≠ 0 → (∃ (g : α → ℝ≥0), (∀ (x : α), ⇑f₂ x ≤ g x) ∧ lower_semicontinuous g ∧ ∫⁻ (x : α), ↑(g x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑f₂ x) ∂μ + ε),	ε : ℝ≥0∞,	ε0 : ε ≠ 0,	g₁ : α → ℝ≥0,	f₁_le_g₁ : ∀ (x : α), ⇑f₁ x ≤ g₁ x,	g₁cont : lower_semicontinuous g₁,	g₁int : ∫⁻ (x : α), ↑(g₁ x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑f₁ x) ∂μ + ε / 2,	g₂ : α → ℝ≥0,	f₂_le_g₂ : ∀ (x : α), ⇑f₂ x ≤ g₂ x,	g₂cont : lower_semicontinuous g₂,	g₂int : ∫⁻ (x : α), ↑(g₂ x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑f₂ x) ∂μ + ε / 2	⊢ ∃ (g : α → ℝ≥0), (∀ (x : α), ⇑(f₁ + f₂) x ≤ g x) ∧ lower_semicontinuous g ∧ ∫⁻ (x : α), ↑(g x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑(f₁ + f₂) x) ∂μ + ε
α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	μ : measure_theory.measure α,	_inst_4 : μ.weakly_regular,	f₁ f₂ : α →ₛ ℝ≥0,	H : disjoint (function.support ⇑f₁) (function.support ⇑f₂),	h₁ : ∀ {ε : ℝ≥0∞}, ε ≠ 0 → (∃ (g : α → ℝ≥0), (∀ (x : α), ⇑f₁ x ≤ g x) ∧ lower_semicontinuous g ∧ ∫⁻ (x : α), ↑(g x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑f₁ x) ∂μ + ε),	h₂ : ∀ {ε : ℝ≥0∞}, ε ≠ 0 → (∃ (g : α → ℝ≥0), (∀ (x : α), ⇑f₂ x ≤ g x) ∧ lower_semicontinuous g ∧ ∫⁻ (x : α), ↑(g x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑f₂ x) ∂μ + ε),	ε : ℝ≥0∞,	ε0 : ε ≠ 0,	g₁ : α → ℝ≥0,	f₁_le_g₁ : ∀ (x : α), ⇑f₁ x ≤ g₁ x,	g₁cont : lower_semicontinuous g₁,	g₁int : ∫⁻ (x : α), ↑(g₁ x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑f₁ x) ∂μ + ε / 2,	g₂ : α → ℝ≥0,	f₂_le_g₂ : ∀ (x : α), ⇑f₂ x ≤ g₂ x,	g₂cont : lower_semicontinuous g₂,	g₂int : ∫⁻ (x : α), ↑(g₂ x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑f₂ x) ∂μ + ε / 2	⊢ ∫⁻ (x : α), ↑(g₁ x + g₂ x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑(f₁ + f₂) x) ∂μ + ε
α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	μ : measure_theory.measure α,	_inst_4 : μ.weakly_regular,	f₁ f₂ : α →ₛ ℝ≥0,	H : disjoint (function.support ⇑f₁) (function.support ⇑f₂),	h₁ : ∀ {ε : ℝ≥0∞}, ε ≠ 0 → (∃ (g : α → ℝ≥0), (∀ (x : α), ⇑f₁ x ≤ g x) ∧ lower_semicontinuous g ∧ ∫⁻ (x : α), ↑(g x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑f₁ x) ∂μ + ε),	h₂ : ∀ {ε : ℝ≥0∞}, ε ≠ 0 → (∃ (g : α → ℝ≥0), (∀ (x : α), ⇑f₂ x ≤ g x) ∧ lower_semicontinuous g ∧ ∫⁻ (x : α), ↑(g x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑f₂ x) ∂μ + ε),	ε : ℝ≥0∞,	ε0 : ε ≠ 0,	g₁ : α → ℝ≥0,	f₁_le_g₁ : ∀ (x : α), ⇑f₁ x ≤ g₁ x,	g₁cont : lower_semicontinuous g₁,	g₁int : ∫⁻ (x : α), ↑(g₁ x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑f₁ x) ∂μ + ε / 2,	g₂ : α → ℝ≥0,	f₂_le_g₂ : ∀ (x : α), ⇑f₂ x ≤ g₂ x,	g₂cont : lower_semicontinuous g₂,	g₂int : ∫⁻ (x : α), ↑(g₂ x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑f₂ x) ∂μ + ε / 2	⊢ ∫⁻ (x : α), ↑(g₁ x) + ↑(g₂ x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑f₁ x) + ↑(⇑f₂ x) ∂μ + ε
α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	μ : measure_theory.measure α,	_inst_4 : μ.weakly_regular,	f₁ f₂ : α →ₛ ℝ≥0,	H : disjoint (function.support ⇑f₁) (function.support ⇑f₂),	h₁ : ∀ {ε : ℝ≥0∞}, ε ≠ 0 → (∃ (g : α → ℝ≥0), (∀ (x : α), ⇑f₁ x ≤ g x) ∧ lower_semicontinuous g ∧ ∫⁻ (x : α), ↑(g x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑f₁ x) ∂μ + ε),	h₂ : ∀ {ε : ℝ≥0∞}, ε ≠ 0 → (∃ (g : α → ℝ≥0), (∀ (x : α), ⇑f₂ x ≤ g x) ∧ lower_semicontinuous g ∧ ∫⁻ (x : α), ↑(g x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑f₂ x) ∂μ + ε),	ε : ℝ≥0∞,	ε0 : ε ≠ 0,	g₁ : α → ℝ≥0,	f₁_le_g₁ : ∀ (x : α), ⇑f₁ x ≤ g₁ x,	g₁cont : lower_semicontinuous g₁,	g₁int : ∫⁻ (x : α), ↑(g₁ x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑f₁ x) ∂μ + ε / 2,	g₂ : α → ℝ≥0,	f₂_le_g₂ : ∀ (x : α), ⇑f₂ x ≤ g₂ x,	g₂cont : lower_semicontinuous g₂,	g₂int : ∫⁻ (x : α), ↑(g₂ x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑f₂ x) ∂μ + ε / 2	⊢ ∫⁻ (a : α), (λ (x : α), ↑(g₁ x)) a ∂μ + ∫⁻ (a : α), (λ (x : α), ↑(g₂ x)) a ∂μ ≤ ∫⁻ (a : α), (λ (x : α), ↑(⇑f₁ x)) a ∂μ + ∫⁻ (a : α), (λ (x : α), ↑(⇑f₂ x)) a ∂μ + ε
α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	μ : measure_theory.measure α,	_inst_4 : μ.weakly_regular,	f₁ f₂ : α →ₛ ℝ≥0,	H : disjoint (function.support ⇑f₁) (function.support ⇑f₂),	h₁ : ∀ {ε : ℝ≥0∞}, ε ≠ 0 → (∃ (g : α → ℝ≥0), (∀ (x : α), ⇑f₁ x ≤ g x) ∧ lower_semicontinuous g ∧ ∫⁻ (x : α), ↑(g x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑f₁ x) ∂μ + ε),	h₂ : ∀ {ε : ℝ≥0∞}, ε ≠ 0 → (∃ (g : α → ℝ≥0), (∀ (x : α), ⇑f₂ x ≤ g x) ∧ lower_semicontinuous g ∧ ∫⁻ (x : α), ↑(g x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑f₂ x) ∂μ + ε),	ε : ℝ≥0∞,	ε0 : ε ≠ 0,	g₁ : α → ℝ≥0,	f₁_le_g₁ : ∀ (x : α), ⇑f₁ x ≤ g₁ x,	g₁cont : lower_semicontinuous g₁,	g₁int : ∫⁻ (x : α), ↑(g₁ x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑f₁ x) ∂μ + ε / 2,	g₂ : α → ℝ≥0,	f₂_le_g₂ : ∀ (x : α), ⇑f₂ x ≤ g₂ x,	g₂cont : lower_semicontinuous g₂,	g₂int : ∫⁻ (x : α), ↑(g₂ x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑f₂ x) ∂μ + ε / 2	⊢ ∫⁻ (a : α), (λ (x : α), ↑(⇑f₁ x)) a ∂μ + ∫⁻ (a : α), (λ (x : α), ↑(⇑f₂ x)) a ∂μ + ε = ?m_1
α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	μ : measure_theory.measure α,	_inst_4 : μ.weakly_regular,	f₁ f₂ : α →ₛ ℝ≥0,	H : disjoint (function.support ⇑f₁) (function.support ⇑f₂),	h₁ : ∀ {ε : ℝ≥0∞}, ε ≠ 0 → (∃ (g : α → ℝ≥0), (∀ (x : α), ⇑f₁ x ≤ g x) ∧ lower_semicontinuous g ∧ ∫⁻ (x : α), ↑(g x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑f₁ x) ∂μ + ε),	h₂ : ∀ {ε : ℝ≥0∞}, ε ≠ 0 → (∃ (g : α → ℝ≥0), (∀ (x : α), ⇑f₂ x ≤ g x) ∧ lower_semicontinuous g ∧ ∫⁻ (x : α), ↑(g x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑f₂ x) ∂μ + ε),	ε : ℝ≥0∞,	ε0 : ε ≠ 0,	g₁ : α → ℝ≥0,	f₁_le_g₁ : ∀ (x : α), ⇑f₁ x ≤ g₁ x,	g₁cont : lower_semicontinuous g₁,	g₁int : ∫⁻ (x : α), ↑(g₁ x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑f₁ x) ∂μ + ε / 2,	g₂ : α → ℝ≥0,	f₂_le_g₂ : ∀ (x : α), ⇑f₂ x ≤ g₂ x,	g₂cont : lower_semicontinuous g₂,	g₂int : ∫⁻ (x : α), ↑(g₂ x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑f₂ x) ∂μ + ε / 2	⊢ ∫⁻ (a : α), (λ (x : α), ↑(⇑f₁ x)) a ∂μ + ∫⁻ (a : α), (λ (x : α), ↑(⇑f₂ x)) a ∂μ + ε = ∫⁻ (x : α), ↑(⇑f₁ x) ∂μ + ε / 2 + (∫⁻ (x : α), ↑(⇑f₂ x) ∂μ + ε / 2)
α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	μ : measure_theory.measure α,	_inst_4 : μ.weakly_regular,	f₁ f₂ : α →ₛ ℝ≥0,	H : disjoint (function.support ⇑f₁) (function.support ⇑f₂),	h₁ : ∀ {ε : ℝ≥0∞}, ε ≠ 0 → (∃ (g : α → ℝ≥0), (∀ (x : α), ⇑f₁ x ≤ g x) ∧ lower_semicontinuous g ∧ ∫⁻ (x : α), ↑(g x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑f₁ x) ∂μ + ε),	h₂ : ∀ {ε : ℝ≥0∞}, ε ≠ 0 → (∃ (g : α → ℝ≥0), (∀ (x : α), ⇑f₂ x ≤ g x) ∧ lower_semicontinuous g ∧ ∫⁻ (x : α), ↑(g x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑f₂ x) ∂μ + ε),	ε : ℝ≥0∞,	ε0 : ε ≠ 0,	g₁ : α → ℝ≥0,	f₁_le_g₁ : ∀ (x : α), ⇑f₁ x ≤ g₁ x,	g₁cont : lower_semicontinuous g₁,	g₁int : ∫⁻ (x : α), ↑(g₁ x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑f₁ x) ∂μ + ε / 2,	g₂ : α → ℝ≥0,	f₂_le_g₂ : ∀ (x : α), ⇑f₂ x ≤ g₂ x,	g₂cont : lower_semicontinuous g₂,	g₂int : ∫⁻ (x : α), ↑(g₂ x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑f₂ x) ∂μ + ε / 2	⊢ ∫⁻ (a : α), (λ (x : α), ↑(⇑f₁ x)) a ∂μ + ∫⁻ (a : α), (λ (x : α), ↑(⇑f₂ x)) a ∂μ + (ε / 2 + ε / 2) = ∫⁻ (x : α), ↑(⇑f₁ x) ∂μ + ε / 2 + (∫⁻ (x : α), ↑(⇑f₂ x) ∂μ + ε / 2)
α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	μ : measure_theory.measure α,	_inst_4 : μ.weakly_regular,	f : α →ₛ ℝ≥0,	ε : ℝ≥0∞,	ε0 : ε ≠ 0	⊢ ∃ (g : α → ℝ≥0), (∀ (x : α), ⇑f x ≤ g x) ∧ lower_semicontinuous g ∧ ∫⁻ (x : α), ↑(g x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑f x) ∂μ + ε
α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	μ : measure_theory.measure α,	_inst_4 : μ.weakly_regular,	c : ℝ≥0,	s : set α,	hs : measurable_set s,	ε : ℝ≥0∞,	ε0 : ε ≠ 0	⊢ ∃ (g : α → ℝ≥0), (∀ (x : α), ⇑(measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0)) x ≤ g x) ∧ lower_semicontinuous g ∧ ∫⁻ (x : α), ↑(g x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑(measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0)) x) ∂μ + ε
α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	μ : measure_theory.measure α,	_inst_4 : μ.weakly_regular,	c : ℝ≥0,	s : set α,	hs : measurable_set s,	ε : ℝ≥0∞,	ε0 : ε ≠ 0,	f : α →ₛ ℝ≥0 := measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0)	⊢ ∃ (g : α → ℝ≥0), (∀ (x : α), ⇑(measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0)) x ≤ g x) ∧ lower_semicontinuous g ∧ ∫⁻ (x : α), ↑(g x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑(measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0)) x) ∂μ + ε
α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	μ : measure_theory.measure α,	_inst_4 : μ.weakly_regular,	c : ℝ≥0,	s : set α,	hs : measurable_set s,	ε : ℝ≥0∞,	ε0 : ε ≠ 0,	f : α →ₛ ℝ≥0 := measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0),	h : ∫⁻ (x : α), ↑(⇑f x) ∂μ = ⊤	⊢ ∃ (g : α → ℝ≥0), (∀ (x : α), ⇑(measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0)) x ≤ g x) ∧ lower_semicontinuous g ∧ ∫⁻ (x : α), ↑(g x) ∂μ ≤ ∫⁻ (x : α), ↑(⇑(measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0)) x) ∂μ + ε
α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	μ : measure_theory.measure α,	_inst_4 : μ.weakly_regular,	c : ℝ≥0,	s : set α,	hs : measurable_set s,	ε : ℝ≥0∞,	ε0 : ε ≠ 0,	f : α →ₛ ℝ≥0 := measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0),	h : ∫⁻ (x : α), ↑(⇑f x) ∂μ = ⊤	⊢ ∫⁻ (x : α), ↑c ∂μ ≤ ∫⁻ (x : α), ↑(⇑(measure_theory.simple_func.piecewise s hs (measure_theory.simple_func.const α c) (measure_theory.simple_func.const α 0)) x) ∂μ + ε
α : Type u_1,	_inst_1 : measurable_space α	⊢ measurable_set set.univ
α : Type u_1,	_inst_1 : measurable_space α,	s : set α,	hs : measurable_set s	⊢ measurable (λ (b : measure_theory.measure (measure_theory.measure α)), ⇑(b.join) s)
α : Type u_1,	_inst_1 : measurable_space α,	s : set α,	hs : measurable_set s	⊢ measurable (λ (b : measure_theory.measure (measure_theory.measure α)), ∫⁻ (μ : measure_theory.measure α), ⇑μ s ∂b)
α : Type u_1,	_inst_1 : measurable_space α,	s : set α,	hs : measurable_set s	⊢ measurable (λ (b : measure_theory.measure (measure_theory.measure α)), ⇑(b.join) s)
G : Type u_1,	_inst_1 : group G,	_inst_2 : topological_space G,	_inst_3 : t2_space G,	_inst_4 : topological_group G,	_inst_5 : measurable_space G,	_inst_6 : borel_space G,	K₀ : topological_space.positive_compacts G	⊢ ⇑(measure_theory.measure.haar_measure K₀) K₀.val = 1
G : Type u_1,	_inst_1 : group G,	_inst_2 : topological_space G,	_inst_3 : t2_space G,	_inst_4 : topological_group G,	_inst_5 : measurable_space G,	_inst_6 : borel_space G,	K₀ : topological_space.positive_compacts G,	_inst : locally_compact_space G	⊢ ⇑(measure_theory.measure.haar_measure K₀) K₀.val = 1
G : Type u_1,	_inst_1 : group G,	_inst_2 : topological_space G,	_inst_3 : t2_space G,	_inst_4 : topological_group G,	_inst_5 : measurable_space G,	_inst_6 : borel_space G,	K₀ : topological_space.positive_compacts G,	_inst : locally_compact_space G	⊢ 0 < ⇑((measure_theory.measure.haar.haar_content K₀).outer_measure) K₀.val
G : Type u_1,	_inst_1 : group G,	_inst_2 : topological_space G,	_inst_3 : t2_space G,	_inst_4 : topological_group G,	_inst_5 : measurable_space G,	_inst_6 : borel_space G,	K₀ : topological_space.positive_compacts G,	_inst : locally_compact_space G	⊢ ⇑((measure_theory.measure.haar.haar_content K₀).outer_measure) K₀.val ≠ 0
G : Type u_1,	_inst_1 : group G,	_inst_2 : topological_space G,	_inst_3 : t2_space G,	_inst_4 : topological_group G,	_inst_5 : measurable_space G,	_inst_6 : borel_space G,	K₀ : topological_space.positive_compacts G,	_inst : locally_compact_space G	⊢ ⇑((measure_theory.measure.haar.haar_content K₀).outer_measure) K₀.val ≠ 0		G : Type u_1,	_inst_1 : group G,	_inst_2 : topological_space G,	_inst_3 : t2_space G,	_inst_4 : topological_group G,	_inst_5 : measurable_space G,	_inst_6 : borel_space G,	K₀ : topological_space.positive_compacts G,	_inst : locally_compact_space G	⊢ ⇑((measure_theory.measure.haar.haar_content K₀).outer_measure) K₀.val ≠ ⊤
G : Type u_1,	_inst_1 : group G,	_inst_2 : topological_space G,	_inst_3 : t2_space G,	_inst_4 : topological_group G,	_inst_5 : measurable_space G,	_inst_6 : borel_space G,	K₀ : topological_space.positive_compacts G,	_inst : locally_compact_space G	⊢ ⇑((measure_theory.measure.haar.haar_content K₀).outer_measure) K₀.val ≠ ⊤
ι : Type ?,	_inst_1 : fintype ι	⊢ (interior (set.univ.pi (λ (i : ι), set.Icc 0 1))).nonempty
ι : Type ?,	_inst_1 : fintype ι	⊢ (set.univ.pi (λ (i : ι), interior (set.Icc 0 1))).nonempty
ι : Type u_1,	X : Type u_2,	_inst_1 : emetric_space X,	μ : measure_theory.outer_measure X,	hm : μ.is_metric,	I : finset ι,	s : ι → set X,	hI : ∀ (i : ι), i ∈ I → ∀ (j : ι), j ∈ I → i ≠ j → is_metric_separated (s i) (s j)	⊢ ⇑μ (⋃ (i : ι) (H : i ∈ I), s i) = ∑ (i : ι) in I, ⇑μ (s i)
ι : Type u_1,	X : Type u_2,	_inst_1 : emetric_space X,	μ : measure_theory.outer_measure X,	hm : μ.is_metric,	I : finset ι,	s : ι → set X,	hI : ∀ (i : ι), i ∈ I → ∀ (j : ι), j ∈ I → i ≠ j → is_metric_separated (s i) (s j),	_inst : Π (a : Prop), decidable a	⊢ ⇑μ (⋃ (i : ι) (H : i ∈ I), s i) = ∑ (i : ι) in I, ⇑μ (s i)
ι : Type u_1,	X : Type u_2,	_inst_1 : emetric_space X,	μ : measure_theory.outer_measure X,	hm : μ.is_metric,	s : ι → set X,	_inst : Π (a : Prop), decidable a,	hI : ∀ (i : ι), i ∈ ∅ → ∀ (j : ι), j ∈ ∅ → i ≠ j → is_metric_separated (s i) (s j)	⊢ ⇑μ (⋃ (i : ι) (H : i ∈ ∅), s i) = ∑ (i : ι) in ∅, ⇑μ (s i)
ι : Type u_1,	X : Type u_2,	_inst_1 : emetric_space X,	μ : measure_theory.outer_measure X,	hm : μ.is_metric,	s : ι → set X,	_inst : Π (a : Prop), decidable a,	hI : ∀ (i : ι), i ∈ ∅ → ∀ (j : ι), j ∈ ∅ → i ≠ j → is_metric_separated (s i) (s j)	⊢ ⇑μ (⋃ (i : ι) (H : i ∈ ∅), s i) = ∑ (i : ι) in ∅, ⇑μ (s i)		case h₂	ι : Type u_1,	X : Type u_2,	_inst_1 : emetric_space X,	μ : measure_theory.outer_measure X,	hm : μ.is_metric,	s : ι → set X,	_inst : Π (a : Prop), decidable a,	i : ι,	I : finset ι,	hiI : i ∉ I,	ihI : (∀ (i : ι), i ∈ I → ∀ (j : ι), j ∈ I → i ≠ j → is_metric_separated (s i) (s j)) → ⇑μ (⋃ (i : ι) (H : i ∈ I), s i) = ∑ (i : ι) in I, ⇑μ (s i),	hI : ∀ (i_1 : ι), i_1 ∈ has_insert.insert i I → ∀ (j : ι), j ∈ has_insert.insert i I → i_1 ≠ j → is_metric_separated (s i_1) (s j)	⊢ ⇑μ (⋃ (i_1 : ι) (H : i_1 ∈ has_insert.insert i I), s i_1) = ∑ (i : ι) in has_insert.insert i I, ⇑μ (s i)
ι : Type u_1,	X : Type u_2,	_inst_1 : emetric_space X,	μ : measure_theory.outer_measure X,	hm : μ.is_metric,	s : ι → set X,	_inst : Π (a : Prop), decidable a,	i : ι,	I : finset ι,	hiI : i ∉ I,	ihI : (∀ (i : ι), i ∈ I → ∀ (j : ι), j ∈ I → i ≠ j → is_metric_separated (s i) (s j)) → ⇑μ (⋃ (i : ι) (H : i ∈ I), s i) = ∑ (i : ι) in I, ⇑μ (s i),	hI : ∀ (i_1 : ι), i_1 ∈ has_insert.insert i I → ∀ (j : ι), j ∈ has_insert.insert i I → i_1 ≠ j → is_metric_separated (s i_1) (s j)	⊢ ⇑μ (⋃ (i_1 : ι) (H : i_1 ∈ has_insert.insert i I), s i_1) = ∑ (i : ι) in has_insert.insert i I, ⇑μ (s i)
ι : Type u_1,	X : Type u_2,	_inst_1 : emetric_space X,	μ : measure_theory.outer_measure X,	hm : μ.is_metric,	s : ι → set X,	_inst : Π (a : Prop), decidable a,	i : ι,	I : finset ι,	hiI : i ∉ I,	ihI : (∀ (i : ι), i ∈ I → ∀ (j : ι), j ∈ I → i ≠ j → is_metric_separated (s i) (s j)) → ⇑μ (⋃ (i : ι) (H : i ∈ I), s i) = ∑ (i : ι) in I, ⇑μ (s i),	hI : ∀ (i_1 : ι), i_1 = i ∨ i_1 ∈ I → ∀ (j : ι), j = i ∨ j ∈ I → i_1 ≠ j → is_metric_separated (s i_1) (s j)	⊢ ⇑μ (⋃ (i_1 : ι) (H : i_1 ∈ has_insert.insert i I), s i_1) = ∑ (i : ι) in has_insert.insert i I, ⇑μ (s i)
ι : Type u_1,	X : Type u_2,	_inst_1 : emetric_space X,	μ : measure_theory.outer_measure X,	hm : μ.is_metric,	s : ι → set X,	_inst : Π (a : Prop), decidable a,	i : ι,	I : finset ι,	hiI : i ∉ I,	ihI : (∀ (i : ι), i ∈ I → ∀ (j : ι), j ∈ I → i ≠ j → is_metric_separated (s i) (s j)) → ⇑μ (⋃ (i : ι) (H : i ∈ I), s i) = ∑ (i : ι) in I, ⇑μ (s i),	hI : ∀ (i_1 : ι), i_1 = i ∨ i_1 ∈ I → ∀ (j : ι), j = i ∨ j ∈ I → i_1 ≠ j → is_metric_separated (s i_1) (s j)	⊢ ∀ (i : ι), i ∈ I → ∀ (j : ι), j ∈ I → i ≠ j → is_metric_separated (s i) (s j)		ι : Type u_1,	X : Type u_2,	_inst_1 : emetric_space X,	μ : measure_theory.outer_measure X,	hm : μ.is_metric,	s : ι → set X,	_inst : Π (a : Prop), decidable a,	i : ι,	I : finset ι,	hiI : i ∉ I,	ihI : (∀ (i : ι), i ∈ I → ∀ (j : ι), j ∈ I → i ≠ j → is_metric_separated (s i) (s j)) → ⇑μ (⋃ (i : ι) (H : i ∈ I), s i) = ∑ (i : ι) in I, ⇑μ (s i),	hI : ∀ (i_1 : ι), i_1 = i ∨ i_1 ∈ I → ∀ (j : ι), j = i ∨ j ∈ I → i_1 ≠ j → is_metric_separated (s i_1) (s j)	⊢ is_metric_separated (s i) (⋃ (x : ι) (H : x ∈ I), s x)
X : Type u_2,	_inst_1 : emetric_space X,	m : set X → ℝ≥0∞,	s : set X	⊢ filter.tendsto (λ (r : ℝ≥0∞), ⇑(measure_theory.outer_measure.mk_metric'.pre m r) s) (𝓝[set.Ioi 0] 0) (𝓝 (⇑(measure_theory.outer_measure.mk_metric' m) s))
X : Type u_2,	_inst_1 : emetric_space X,	m : set X → ℝ≥0∞,	s : set X	⊢ filter.tendsto ((λ (r : ℝ≥0∞), ⇑(measure_theory.outer_measure.mk_metric'.pre m r) s) ∘ coe) filter.at_bot (𝓝 (⇑(measure_theory.outer_measure.mk_metric' m) s))
X : Type u_2,	_inst_1 : emetric_space X,	m : set X → ℝ≥0∞,	s : set X	⊢ filter.tendsto ((λ (r : ℝ≥0∞), ⇑(measure_theory.outer_measure.mk_metric'.pre m r) s) ∘ coe) filter.at_bot (𝓝 (⨆ (i : {i // i > 0}), ⇑(measure_theory.outer_measure.mk_metric'.pre m ↑i) s))
X : Type u_2,	_inst_1 : emetric_space X,	_inst_3 : measurable_space X,	_inst_4 : borel_space X,	d₁ d₂ : ℝ,	h : d₁ < d₂,	s : set X,	H : ¬(⇑μH[d₂] s = 0 ∨ ⇑μH[d₁] s = ⊤)	⊢ false
X : Type u_2,	_inst_1 : emetric_space X,	_inst_3 : measurable_space X,	_inst_4 : borel_space X,	d₁ d₂ : ℝ,	h : d₁ < d₂,	s : set X	⊢ ⇑μH[d₂] s = 0 ∨ ⇑μH[d₁] s = ⊤
X : Type u_2,	_inst_1 : emetric_space X,	_inst_3 : measurable_space X,	_inst_4 : borel_space X,	d₁ d₂ : ℝ,	h : d₁ < d₂,	s : set X,	H : ⇑μH[d₂] s ≠ 0 ∧ ⇑μH[d₁] s ≠ ⊤	⊢ false
X : Type u_2,	_inst_1 : emetric_space X,	_inst_3 : measurable_space X,	_inst_4 : borel_space X,	d₁ d₂ : ℝ,	h : d₁ < d₂,	s : set X,	H : ⇑μH[d₂] s ≠ 0 ∧ ⇑μH[d₁] s ≠ ⊤,	this : ∀ (c : ℝ≥0), c ≠ 0 → ⇑μH[d₂] s ≤ ↑c * ⇑μH[d₁] s	⊢ false
X : Type u_2,	_inst_1 : emetric_space X,	_inst_3 : measurable_space X,	_inst_4 : borel_space X,	d₁ d₂ : ℝ,	h : d₁ < d₂,	s : set X,	H : ⇑μH[d₂] s ≠ 0 ∧ ⇑μH[d₁] s ≠ ⊤,	this : ∀ (c : ℝ≥0), c ≠ 0 → ⇑μH[d₂] s ≤ ↑c * ⇑μH[d₁] s	⊢ false		X : Type u_2,	_inst_1 : emetric_space X,	_inst_3 : measurable_space X,	_inst_4 : borel_space X,	d₁ d₂ : ℝ,	h : d₁ < d₂,	s : set X,	H : ⇑μH[d₂] s ≠ 0 ∧ ⇑μH[d₁] s ≠ ⊤	⊢ ∀ (c : ℝ≥0), c ≠ 0 → ⇑μH[d₂] s ≤ ↑c * ⇑μH[d₁] s
X : Type u_2,	_inst_1 : emetric_space X,	_inst_3 : measurable_space X,	_inst_4 : borel_space X,	d₁ d₂ : ℝ,	h : d₁ < d₂,	s : set X,	H : ⇑μH[d₂] s ≠ 0 ∧ ⇑μH[d₁] s ≠ ⊤,	this : ∀ (c : ℝ≥0), c ≠ 0 → ⇑μH[d₂] s ≤ ↑c * ⇑μH[d₁] s,	c : ℝ≥0,	hc0 : c > 0,	hc : ↑c * ⇑μH[d₁] s < ⇑μH[d₂] s	⊢ false
X : Type u_2,	_inst_1 : emetric_space X,	_inst_3 : measurable_space X,	_inst_4 : borel_space X,	d₁ d₂ : ℝ,	h : d₁ < d₂,	s : set X,	H : ⇑μH[d₂] s ≠ 0 ∧ ⇑μH[d₁] s ≠ ⊤	⊢ ∀ (c : ℝ≥0), c ≠ 0 → ⇑μH[d₂] s ≤ ↑c * ⇑μH[d₁] s
X : Type u_2,	_inst_1 : emetric_space X,	_inst_3 : measurable_space X,	_inst_4 : borel_space X,	d₁ d₂ : ℝ,	h : d₁ < d₂,	s : set X,	H : ⇑μH[d₂] s ≠ 0 ∧ ⇑μH[d₁] s ≠ ⊤,	c : ℝ≥0,	hc : c ≠ 0	⊢ ⇑μH[d₂] s ≤ ↑c * ⇑μH[d₁] s
X : Type u_2,	_inst_1 : emetric_space X,	_inst_3 : measurable_space X,	_inst_4 : borel_space X,	d₁ d₂ : ℝ,	h : d₁ < d₂,	s : set X,	H : ⇑μH[d₂] s ≠ 0 ∧ ⇑μH[d₁] s ≠ ⊤,	c : ℝ≥0,	hc : c ≠ 0	⊢ ↑c ≠ 0
X : Type u_2,	_inst_1 : emetric_space X,	_inst_3 : measurable_space X,	_inst_4 : borel_space X,	d₁ d₂ : ℝ,	h : d₁ < d₂,	s : set X,	H : ⇑μH[d₂] s ≠ 0 ∧ ⇑μH[d₁] s ≠ ⊤,	c : ℝ≥0,	hc : c ≠ 0	⊢ (λ (r : ℝ≥0∞), r ^ d₂) ≤ᶠ[𝓝[set.Ioi 0] 0] ↑c • λ (r : ℝ≥0∞), r ^ d₁
X : Type u_2,	_inst_1 : emetric_space X,	_inst_3 : measurable_space X,	_inst_4 : borel_space X,	d₁ d₂ : ℝ,	h : d₁ < d₂,	s : set X,	H : ⇑μH[d₂] s ≠ 0 ∧ ⇑μH[d₁] s ≠ ⊤,	c : ℝ≥0,	hc : c ≠ 0	⊢ 0 < ↑c ^ (d₂ - d₁)⁻¹
X : Type u_2,	_inst_1 : emetric_space X,	_inst_3 : measurable_space X,	_inst_4 : borel_space X,	d₁ d₂ : ℝ,	h : d₁ < d₂,	s : set X,	H : ⇑μH[d₂] s ≠ 0 ∧ ⇑μH[d₁] s ≠ ⊤,	c : ℝ≥0,	hc : c ≠ 0	⊢ 0 < ↑c ^ (d₂ - d₁)⁻¹		X : Type u_2,	_inst_1 : emetric_space X,	_inst_3 : measurable_space X,	_inst_4 : borel_space X,	d₁ d₂ : ℝ,	h : d₁ < d₂,	s : set X,	H : ⇑μH[d₂] s ≠ 0 ∧ ⇑μH[d₁] s ≠ ⊤,	c : ℝ≥0,	hc : c ≠ 0,	this : 0 < ↑c ^ (d₂ - d₁)⁻¹	⊢ (λ (r : ℝ≥0∞), r ^ d₂) ≤ᶠ[𝓝[set.Ioi 0] 0] ↑c • λ (r : ℝ≥0∞), r ^ d₁
X : Type u_2,	_inst_1 : emetric_space X,	_inst_3 : measurable_space X,	_inst_4 : borel_space X,	d₁ d₂ : ℝ,	h : d₁ < d₂,	s : set X,	H : ⇑μH[d₂] s ≠ 0 ∧ ⇑μH[d₁] s ≠ ⊤,	c : ℝ≥0,	hc : c ≠ 0	⊢ ¬(c = 0 ∧ (d₂ - d₁)⁻¹ ≠ 0)
X : Type u_2,	_inst_1 : emetric_space X,	_inst_3 : measurable_space X,	_inst_4 : borel_space X,	d₁ d₂ : ℝ,	h : d₁ < d₂,	s : set X,	H : ⇑μH[d₂] s ≠ 0 ∧ ⇑μH[d₁] s ≠ ⊤,	c : ℝ≥0,	hc : c ≠ 0,	this : 0 < ↑c ^ (d₂ - d₁)⁻¹	⊢ (λ (r : ℝ≥0∞), r ^ d₂) ≤ᶠ[𝓝[set.Ioi 0] 0] ↑c • λ (r : ℝ≥0∞), r ^ d₁
X : Type u_2,	_inst_1 : emetric_space X,	_inst_3 : measurable_space X,	_inst_4 : borel_space X,	d₁ d₂ : ℝ,	h : d₁ < d₂,	s : set X,	H : ⇑μH[d₂] s ≠ 0 ∧ ⇑μH[d₁] s ≠ ⊤,	c : ℝ≥0,	hc : c ≠ 0,	this : 0 < ↑c ^ (d₂ - d₁)⁻¹	⊢ ∀ (a : ℝ≥0∞), a ∈ set.Ioo 0 (↑c ^ (d₂ - d₁)⁻¹) → a ^ d₂ ≤ (↑c • λ (r : ℝ≥0∞), r ^ d₁) a
X : Type u_2,	_inst_1 : emetric_space X,	_inst_3 : measurable_space X,	_inst_4 : borel_space X,	d₁ d₂ : ℝ,	h : d₁ < d₂,	s : set X,	H : ⇑μH[d₂] s ≠ 0 ∧ ⇑μH[d₁] s ≠ ⊤,	c : ℝ≥0,	hc : c ≠ 0,	this : 0 < ↑c ^ (d₂ - d₁)⁻¹,	r : ℝ≥0∞,	hr₀ : 0 < r,	hrc : r < ↑c ^ (d₂ - d₁)⁻¹	⊢ r ^ d₂ ≤ (↑c • λ (r : ℝ≥0∞), r ^ d₁) r
X : Type u_2,	_inst_1 : emetric_space X,	_inst_3 : measurable_space X,	_inst_4 : borel_space X,	d₁ d₂ : ℝ,	h : d₁ < d₂,	s : set X,	H : ⇑μH[d₂] s ≠ 0 ∧ ⇑μH[d₁] s ≠ ⊤,	c : ℝ≥0,	hc : c ≠ 0,	this : 0 < ↑c ^ (d₂ - d₁)⁻¹,	r : ℝ≥0,	hr₀ : 0 < ↑r,	hrc : ↑r < ↑c ^ (d₂ - d₁)⁻¹	⊢ ↑r ^ d₂ ≤ (↑c • λ (r : ℝ≥0∞), r ^ d₁) ↑r
X : Type u_2,	_inst_1 : emetric_space X,	_inst_3 : measurable_space X,	_inst_4 : borel_space X,	d₁ d₂ : ℝ,	h : d₁ < d₂,	s : set X,	H : ⇑μH[d₂] s ≠ 0 ∧ ⇑μH[d₁] s ≠ ⊤,	c : ℝ≥0,	hc : c ≠ 0,	this : 0 < ↑c ^ (d₂ - d₁)⁻¹,	r : ℝ≥0,	hr₀ : 0 < ↑r,	hrc : ↑r < ↑c ^ (d₂ - d₁)⁻¹	⊢ ↑r ^ (d₂ - d₁) ≤ ↑c
X : Type u_2,	_inst_1 : emetric_space X,	_inst_3 : measurable_space X,	_inst_4 : borel_space X,	d₁ d₂ : ℝ,	h : d₁ < d₂,	s : set X,	H : ⇑μH[d₂] s ≠ 0 ∧ ⇑μH[d₁] s ≠ ⊤,	c : ℝ≥0,	hc : c ≠ 0,	this : 0 < ↑c ^ (d₂ - d₁)⁻¹,	r : ℝ≥0,	hr₀ : 0 < ↑r,	hrc : ↑r < ↑c ^ (d₂ - d₁)⁻¹	⊢ (↑c ^ (d₂ - d₁)⁻¹) ^ (d₂ - d₁) ≤ ↑c
X : Type u_2,	_inst_1 : emetric_space X,	_inst_3 : measurable_space X,	_inst_4 : borel_space X,	d₁ d₂ : ℝ,	h : d₁ < d₂,	s : set X,	H : ⇑μH[d₂] s ≠ 0 ∧ ⇑μH[d₁] s ≠ ⊤,	c : ℝ≥0,	hc : c ≠ 0,	this : 0 < ↑c ^ (d₂ - d₁)⁻¹,	r : ℝ≥0,	hr₀ : 0 < ↑r,	hrc : ↑r < ↑c ^ (d₂ - d₁)⁻¹	⊢ ↑c ≤ ↑c
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι	⊢ μH[↑(fintype.card ι)] = measure_theory.measure_space.volume
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a	⊢ μH[↑(fintype.card ι)] = measure_theory.measure_space.volume
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a	⊢ ∀ (s : ι → set ℝ), (∀ (i : ι), s i ∈ ⋃ (a b : ℚ) (h : a < b), {set.Ioo ↑a ↑b}) → ⇑μH[↑(fintype.card ι)] (set.univ.pi s) = ∏ (i : ι), ⇑measure_theory.measure_space.volume (s i)
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a	⊢ ∀ (s : ι → set ℝ), (∀ (i : ι), ∃ (i_1 i_2 : ℚ) (i_3 : i_1 < i_2), s i = set.Ioo ↑i_1 ↑i_2) → ⇑μH[↑(fintype.card ι)] (set.univ.pi s) = ∏ (i : ι), ⇑measure_theory.measure_space.volume (s i)
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	s : ι → set ℝ,	hs : ∀ (i : ι), ∃ (i_1 i_2 : ℚ) (i_3 : i_1 < i_2), s i = set.Ioo ↑i_1 ↑i_2	⊢ ⇑μH[↑(fintype.card ι)] (set.univ.pi s) = ∏ (i : ι), ⇑measure_theory.measure_space.volume (s i)
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	s : ι → set ℝ,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i ∧ s i = set.Ioo ↑(a i) ↑(b i)	⊢ ⇑μH[↑(fintype.card ι)] (set.univ.pi s) = ∏ (i : ι), ⇑measure_theory.measure_space.volume (s i)
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	s : ι → set ℝ,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i ∧ s i = set.Ioo ↑(a i) ↑(b i)	⊢ s = λ (i : ι), set.Ioo ↑(a i) ↑(b i)		ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i ∧ (λ (i : ι), set.Ioo ↑(a i) ↑(b i)) i = set.Ioo ↑(a i) ↑(b i)	⊢ ⇑μH[↑(fintype.card ι)] (set.univ.pi (λ (i : ι), set.Ioo ↑(a i) ↑(b i))) = ∏ (i : ι), ⇑measure_theory.measure_space.volume ((λ (i : ι), set.Ioo ↑(a i) ↑(b i)) i)
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i ∧ (λ (i : ι), set.Ioo ↑(a i) ↑(b i)) i = set.Ioo ↑(a i) ↑(b i)	⊢ ⇑μH[↑(fintype.card ι)] (set.univ.pi (λ (i : ι), set.Ioo ↑(a i) ↑(b i))) = ∏ (i : ι), ⇑measure_theory.measure_space.volume ((λ (i : ι), set.Ioo ↑(a i) ↑(b i)) i)
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i	⊢ ⇑μH[↑(fintype.card ι)] (set.univ.pi (λ (i : ι), set.Ioo ↑(a i) ↑(b i))) = ∏ (i : ι), ⇑measure_theory.measure_space.volume ((λ (i : ι), set.Ioo ↑(a i) ↑(b i)) i)
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i	⊢ ∏ (i : ι), ⇑measure_theory.measure_space.volume ((λ (i : ι), set.Ioo ↑(a i) ↑(b i)) i) ≤ ⇑μH[↑(fintype.card ι)] (set.univ.pi (λ (i : ι), set.Ioo ↑(a i) ↑(b i)))
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i	⊢ measure_theory.measure_space.volume ≤ μH[↑(fintype.card ι)]
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	s : set (ι → ℝ),	h₁ : emetric.diam s ≤ ⊤,	h₂ : ¬set.subsingleton s	⊢ ⇑measure_theory.measure_space.volume s ≤ emetric.diam s ^ ↑(fintype.card ι)
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i	⊢ measure_theory.measure_space.volume ≤ μH[↑(fintype.card ι)]		ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	Hle : measure_theory.measure_space.volume ≤ μH[↑(fintype.card ι)]	⊢ ∏ (i : ι), ⇑measure_theory.measure_space.volume ((λ (i : ι), set.Ioo ↑(a i) ↑(b i)) i) ≤ ⇑μH[↑(fintype.card ι)] (set.univ.pi (λ (i : ι), set.Ioo ↑(a i) ↑(b i)))
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	s : set (ι → ℝ),	h₁ : emetric.diam s ≤ ⊤,	h₂ : ¬set.subsingleton s	⊢ ⇑measure_theory.measure_space.volume s ≤ emetric.diam s ^ fintype.card ι
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	Hle : measure_theory.measure_space.volume ≤ μH[↑(fintype.card ι)]	⊢ ∏ (i : ι), ⇑measure_theory.measure_space.volume ((λ (i : ι), set.Ioo ↑(a i) ↑(b i)) i) ≤ ⇑μH[↑(fintype.card ι)] (set.univ.pi (λ (i : ι), set.Ioo ↑(a i) ↑(b i)))
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i	⊢ ∏ (i : ι), ⇑measure_theory.measure_space.volume ((λ (i : ι), set.Ioo ↑(a i) ↑(b i)) i) ≤ ⇑μH[↑(fintype.card ι)] (set.univ.pi (λ (i : ι), set.Ioo ↑(a i) ↑(b i)))		ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i	⊢ partial_order ℝ≥0∞		ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i	⊢ ⇑μH[↑(fintype.card ι)] (set.univ.pi (λ (i : ι), set.Ioo ↑(a i) ↑(b i))) ≤ ∏ (i : ι), ⇑measure_theory.measure_space.volume ((λ (i : ι), set.Ioo ↑(a i) ↑(b i)) i)
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	Hle : measure_theory.measure_space.volume ≤ μH[↑(fintype.card ι)]	⊢ ⇑measure_theory.measure_space.volume (set.univ.pi (λ (i : ι), set.Ioo ↑(a i) ↑(b i))) ≤ ⇑μH[↑(fintype.card ι)] (set.univ.pi (λ (i : ι), set.Ioo ↑(a i) ↑(b i)))
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i	⊢ ⇑μH[↑(fintype.card ι)] (set.univ.pi (λ (i : ι), set.Ioo ↑(a i) ↑(b i))) ≤ ∏ (i : ι), ⇑measure_theory.measure_space.volume ((λ (i : ι), set.Ioo ↑(a i) ↑(b i)) i)
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	i : ι	⊢ 0 ≤ ↑(b i) - ↑(a i)
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i)	⊢ ⇑μH[↑(fintype.card ι)] (set.univ.pi (λ (i : ι), set.Ioo ↑(a i) ↑(b i))) ≤ ∏ (i : ι), ⇑measure_theory.measure_space.volume ((λ (i : ι), set.Ioo ↑(a i) ↑(b i)) i)
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊	⊢ ⇑μH[↑(fintype.card ι)] (set.univ.pi (λ (i : ι), set.Ioo ↑(a i) ↑(b i))) ≤ ∏ (i : ι), ⇑measure_theory.measure_space.volume ((λ (i : ι), set.Ioo ↑(a i) ↑(b i)) i)
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n))	⊢ ⇑μH[↑(fintype.card ι)] (set.univ.pi (λ (i : ι), set.Ioo ↑(a i) ↑(b i))) ≤ ∏ (i : ι), ⇑measure_theory.measure_space.volume ((λ (i : ι), set.Ioo ↑(a i) ↑(b i)) i)
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n))	⊢ filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0)
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0)	⊢ ⇑μH[↑(fintype.card ι)] (set.univ.pi (λ (i : ι), set.Ioo ↑(a i) ↑(b i))) ≤ ∏ (i : ι), ⇑measure_theory.measure_space.volume ((λ (i : ι), set.Ioo ↑(a i) ↑(b i)) i)
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0)	⊢ ∀ᶠ (n : ℕ) in filter.at_top, ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0),	n : ℕ,	hn : n ≥ 1	⊢ ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0),	n : ℕ,	hn : n ≥ 1,	f : γ n	⊢ emetric.diam (t n f) ≤ 1 / ↑n
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0),	n : ℕ,	hn : n ≥ 1,	f : γ n,	b : ι	⊢ emetric.diam (set.Icc (↑(a b) + ↑(f b) / ↑n) (↑(a b) + (↑(f b) + 1) / ↑n)) ≤ 1 / ↑n
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0)	⊢ ∀ᶠ (n : ℕ) in filter.at_top, ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n		ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0),	B : ∀ᶠ (n : ℕ) in filter.at_top, ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n	⊢ ⇑μH[↑(fintype.card ι)] (set.univ.pi (λ (i : ι), set.Ioo ↑(a i) ↑(b i))) ≤ ∏ (i : ι), ⇑measure_theory.measure_space.volume ((λ (i : ι), set.Ioo ↑(a i) ↑(b i)) i)
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0),	B : ∀ᶠ (n : ℕ) in filter.at_top, ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n	⊢ ⇑μH[↑(fintype.card ι)] (set.univ.pi (λ (i : ι), set.Ioo ↑(a i) ↑(b i))) ≤ ∏ (i : ι), ⇑measure_theory.measure_space.volume ((λ (i : ι), set.Ioo ↑(a i) ↑(b i)) i)
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0),	B : ∀ᶠ (n : ℕ) in filter.at_top, ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n	⊢ ∀ᶠ (n : ℕ) in filter.at_top, set.univ.pi (λ (i : ι), set.Ioo ↑(a i) ↑(b i)) ⊆ ⋃ (i : γ n), t n i
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0),	B : ∀ᶠ (n : ℕ) in filter.at_top, ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n,	n : ℕ,	hn : n ≥ 1	⊢ set.univ.pi (λ (i : ι), set.Ioo ↑(a i) ↑(b i)) ⊆ ⋃ (i : γ n), t n i
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0),	B : ∀ᶠ (n : ℕ) in filter.at_top, ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n,	n : ℕ,	hn : n ≥ 1,	npos : 0 < ↑n	⊢ set.univ.pi (λ (i : ι), set.Ioo ↑(a i) ↑(b i)) ⊆ ⋃ (i : γ n), t n i
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0),	B : ∀ᶠ (n : ℕ) in filter.at_top, ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n,	n : ℕ,	hn : n ≥ 1,	npos : 0 < ↑n,	x : ι → ℝ,	hx : x ∈ set.univ.pi (λ (i : ι), set.Ioo ↑(a i) ↑(b i))	⊢ x ∈ ⋃ (i : γ n), t n i
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0),	B : ∀ᶠ (n : ℕ) in filter.at_top, ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n,	n : ℕ,	hn : n ≥ 1,	npos : 0 < ↑n,	x : ι → ℝ,	hx : ∀ (i : ι), ↑(a i) < x i ∧ x i < ↑(b i)	⊢ x ∈ ⋃ (i : γ n), t n i
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0),	B : ∀ᶠ (n : ℕ) in filter.at_top, ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n,	n : ℕ,	hn : n ≥ 1,	npos : 0 < ↑n,	x : ι → ℝ,	hx : ∀ (i : ι), ↑(a i) < x i ∧ x i < ↑(b i)	⊢ ∃ (i : γ n), ∀ (i_1 : ι), x i_1 ∈ set.Icc (↑(a i_1) + ↑↑(i i_1) / ↑n) (↑(a i_1) + (↑↑(i i_1) + 1) / ↑n)
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0),	B : ∀ᶠ (n : ℕ) in filter.at_top, ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n,	n : ℕ,	hn : n ≥ 1,	npos : 0 < ↑n,	x : ι → ℝ,	hx : ∀ (i : ι), ↑(a i) < x i ∧ x i < ↑(b i),	i : ι	⊢ ⌊(x i - ↑(a i)) * ↑n⌋₊ < ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0),	B : ∀ᶠ (n : ℕ) in filter.at_top, ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n,	n : ℕ,	hn : n ≥ 1,	npos : 0 < ↑n,	x : ι → ℝ,	hx : ∀ (i : ι), ↑(a i) < x i ∧ x i < ↑(b i),	i : ι	⊢ (x i - ↑(a i)) * ↑n < (↑(b i) - ↑(a i)) * ↑n
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0),	B : ∀ᶠ (n : ℕ) in filter.at_top, ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n,	n : ℕ,	hn : n ≥ 1,	npos : 0 < ↑n,	x : ι → ℝ,	hx : ∀ (i : ι), ↑(a i) < x i ∧ x i < ↑(b i),	i : ι	⊢ (x i - ↑(a i)) * ↑n < (↑(b i) - ↑(a i)) * ↑n		ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0),	B : ∀ᶠ (n : ℕ) in filter.at_top, ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n,	n : ℕ,	hn : n ≥ 1,	npos : 0 < ↑n,	x : ι → ℝ,	hx : ∀ (i : ι), ↑(a i) < x i ∧ x i < ↑(b i),	i : ι	⊢ 0 < (↑(b i) - ↑(a i)) * ↑n
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0),	B : ∀ᶠ (n : ℕ) in filter.at_top, ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n,	n : ℕ,	hn : n ≥ 1,	npos : 0 < ↑n,	x : ι → ℝ,	hx : ∀ (i : ι), ↑(a i) < x i ∧ x i < ↑(b i),	i : ι	⊢ x i - ↑(a i) < ↑(b i) - ↑(a i)
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0),	B : ∀ᶠ (n : ℕ) in filter.at_top, ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n,	n : ℕ,	hn : n ≥ 1,	npos : 0 < ↑n,	x : ι → ℝ,	hx : ∀ (i : ι), ↑(a i) < x i ∧ x i < ↑(b i),	i : ι	⊢ 0 < (↑(b i) - ↑(a i)) * ↑n
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0),	B : ∀ᶠ (n : ℕ) in filter.at_top, ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n,	n : ℕ,	hn : n ≥ 1,	npos : 0 < ↑n,	x : ι → ℝ,	hx : ∀ (i : ι), ↑(a i) < x i ∧ x i < ↑(b i),	i : ι	⊢ 0 < ↑(b i) - ↑(a i)
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0),	B : ∀ᶠ (n : ℕ) in filter.at_top, ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n,	n : ℕ,	hn : n ≥ 1,	npos : 0 < ↑n,	x : ι → ℝ,	hx : ∀ (i : ι), ↑(a i) < x i ∧ x i < ↑(b i),	f : γ n := λ (i : ι), ⟨⌊(x i - ↑(a i)) * ↑n⌋₊, _⟩	⊢ ∃ (i : γ n), ∀ (i_1 : ι), x i_1 ∈ set.Icc (↑(a i_1) + ↑↑(i i_1) / ↑n) (↑(a i_1) + (↑↑(i i_1) + 1) / ↑n)
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0),	B : ∀ᶠ (n : ℕ) in filter.at_top, ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n,	n : ℕ,	hn : n ≥ 1,	npos : 0 < ↑n,	x : ι → ℝ,	hx : ∀ (i : ι), ↑(a i) < x i ∧ x i < ↑(b i),	f : γ n := λ (i : ι), ⟨⌊(x i - ↑(a i)) * ↑n⌋₊, _⟩,	i : ι	⊢ ↑(a i) + ↑↑(f i) / ↑n ≤ x i
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0),	B : ∀ᶠ (n : ℕ) in filter.at_top, ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n,	n : ℕ,	hn : n ≥ 1,	npos : 0 < ↑n,	x : ι → ℝ,	hx : ∀ (i : ι), ↑(a i) < x i ∧ x i < ↑(b i),	f : γ n := λ (i : ι), ⟨⌊(x i - ↑(a i)) * ↑n⌋₊, _⟩,	i : ι	⊢ ↑(a i) + ↑⌊(x i - ↑(a i)) * ↑n⌋₊ / ↑n ≤ ↑(a i) + (x i - ↑(a i)) * ↑n / ↑n
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0),	B : ∀ᶠ (n : ℕ) in filter.at_top, ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n,	n : ℕ,	hn : n ≥ 1,	npos : 0 < ↑n,	x : ι → ℝ,	hx : ∀ (i : ι), ↑(a i) < x i ∧ x i < ↑(b i),	f : γ n := λ (i : ι), ⟨⌊(x i - ↑(a i)) * ↑n⌋₊, _⟩,	i : ι	⊢ ↑⌊(x i - ↑(a i)) * ↑n⌋₊ ≤ (x i - ↑(a i)) * ↑n
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0),	B : ∀ᶠ (n : ℕ) in filter.at_top, ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n,	n : ℕ,	hn : n ≥ 1,	npos : 0 < ↑n,	x : ι → ℝ,	hx : ∀ (i : ι), ↑(a i) < x i ∧ x i < ↑(b i),	f : γ n := λ (i : ι), ⟨⌊(x i - ↑(a i)) * ↑n⌋₊, _⟩,	i : ι	⊢ ↑(a i) + (x i - ↑(a i)) * ↑n / ↑n = x i
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0),	B : ∀ᶠ (n : ℕ) in filter.at_top, ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n,	n : ℕ,	hn : n ≥ 1,	npos : 0 < ↑n,	x : ι → ℝ,	hx : ∀ (i : ι), ↑(a i) < x i ∧ x i < ↑(b i),	f : γ n := λ (i : ι), ⟨⌊(x i - ↑(a i)) * ↑n⌋₊, _⟩,	i : ι	⊢ ↑(a i) + ↑↑(f i) / ↑n ≤ x i		ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0),	B : ∀ᶠ (n : ℕ) in filter.at_top, ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n,	n : ℕ,	hn : n ≥ 1,	npos : 0 < ↑n,	x : ι → ℝ,	hx : ∀ (i : ι), ↑(a i) < x i ∧ x i < ↑(b i),	f : γ n := λ (i : ι), ⟨⌊(x i - ↑(a i)) * ↑n⌋₊, _⟩,	i : ι	⊢ x i ≤ ↑(a i) + (↑↑(f i) + 1) / ↑n
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0),	B : ∀ᶠ (n : ℕ) in filter.at_top, ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n,	n : ℕ,	hn : n ≥ 1,	npos : 0 < ↑n,	x : ι → ℝ,	hx : ∀ (i : ι), ↑(a i) < x i ∧ x i < ↑(b i),	f : γ n := λ (i : ι), ⟨⌊(x i - ↑(a i)) * ↑n⌋₊, _⟩,	i : ι	⊢ x i ≤ ↑(a i) + (↑↑(f i) + 1) / ↑n
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0),	B : ∀ᶠ (n : ℕ) in filter.at_top, ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n,	n : ℕ,	hn : n ≥ 1,	npos : 0 < ↑n,	x : ι → ℝ,	hx : ∀ (i : ι), ↑(a i) < x i ∧ x i < ↑(b i),	f : γ n := λ (i : ι), ⟨⌊(x i - ↑(a i)) * ↑n⌋₊, _⟩,	i : ι	⊢ x i = ↑(a i) + (x i - ↑(a i)) * ↑n / ↑n
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0),	B : ∀ᶠ (n : ℕ) in filter.at_top, ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n	⊢ ∀ᶠ (n : ℕ) in filter.at_top, set.univ.pi (λ (i : ι), set.Ioo ↑(a i) ↑(b i)) ⊆ ⋃ (i : γ n), t n i		ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0),	B : ∀ᶠ (n : ℕ) in filter.at_top, ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n,	C : ∀ᶠ (n : ℕ) in filter.at_top, set.univ.pi (λ (i : ι), set.Ioo ↑(a i) ↑(b i)) ⊆ ⋃ (i : γ n), t n i	⊢ ⇑μH[↑(fintype.card ι)] (set.univ.pi (λ (i : ι), set.Ioo ↑(a i) ↑(b i))) ≤ ∏ (i : ι), ⇑measure_theory.measure_space.volume ((λ (i : ι), set.Ioo ↑(a i) ↑(b i)) i)
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0),	B : ∀ᶠ (n : ℕ) in filter.at_top, ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n,	C : ∀ᶠ (n : ℕ) in filter.at_top, set.univ.pi (λ (i : ι), set.Ioo ↑(a i) ↑(b i)) ⊆ ⋃ (i : γ n), t n i	⊢ ⇑μH[↑(fintype.card ι)] (set.univ.pi (λ (i : ι), set.Ioo ↑(a i) ↑(b i))) ≤ ∏ (i : ι), ⇑measure_theory.measure_space.volume ((λ (i : ι), set.Ioo ↑(a i) ↑(b i)) i)
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0),	B : ∀ᶠ (n : ℕ) in filter.at_top, ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n,	C : ∀ᶠ (n : ℕ) in filter.at_top, set.univ.pi (λ (i : ι), set.Ioo ↑(a i) ↑(b i)) ⊆ ⋃ (i : γ n), t n i	⊢ auto_param (filter.is_bounded_under ge filter.at_top (λ (n : ℕ), ∑ (i : γ n), emetric.diam (t n i) ^ ↑(fintype.card ι))) (name.mk_string "is_bounded_default" (name.mk_string "filter" name.anonymous))
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0),	B : ∀ᶠ (n : ℕ) in filter.at_top, ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n,	C : ∀ᶠ (n : ℕ) in filter.at_top, set.univ.pi (λ (i : ι), set.Ioo ↑(a i) ↑(b i)) ⊆ ⋃ (i : γ n), t n i	⊢ filter.at_top.liminf (λ (n : ℕ), ∑ (i : γ n), emetric.diam (t n i) ^ ↑(fintype.card ι)) ≤ filter.at_top.liminf (λ (n : ℕ), ∑ (i : γ n), (1 / ↑n) ^ fintype.card ι)
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0),	B : ∀ᶠ (n : ℕ) in filter.at_top, ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n,	C : ∀ᶠ (n : ℕ) in filter.at_top, set.univ.pi (λ (i : ι), set.Ioo ↑(a i) ↑(b i)) ⊆ ⋃ (i : γ n), t n i	⊢ ∀ᶠ (a_1 : ℕ) in filter.at_top, ∑ (i : γ a_1), emetric.diam (t a_1 i) ^ ↑(fintype.card ι) ≤ ∑ (i : γ a_1), (1 / ↑a_1) ^ fintype.card ι
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0),	B : ∀ᶠ (n : ℕ) in filter.at_top, ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n,	C : ∀ᶠ (n : ℕ) in filter.at_top, set.univ.pi (λ (i : ι), set.Ioo ↑(a i) ↑(b i)) ⊆ ⋃ (i : γ n), t n i	⊢ ∀ (a_1 : ℕ), (∀ (i : γ a_1), emetric.diam (t a_1 i) ≤ 1 / ↑a_1) → ∑ (i : γ a_1), emetric.diam (t a_1 i) ^ ↑(fintype.card ι) ≤ ∑ (i : γ a_1), (1 / ↑a_1) ^ fintype.card ι
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0),	B : ∀ᶠ (n : ℕ) in filter.at_top, ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n,	C : ∀ᶠ (n : ℕ) in filter.at_top, set.univ.pi (λ (i : ι), set.Ioo ↑(a i) ↑(b i)) ⊆ ⋃ (i : γ n), t n i,	n : ℕ,	hn : ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n	⊢ ∑ (i : γ n), emetric.diam (t n i) ^ ↑(fintype.card ι) ≤ ∑ (i : γ n), (1 / ↑n) ^ fintype.card ι
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0),	B : ∀ᶠ (n : ℕ) in filter.at_top, ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n,	C : ∀ᶠ (n : ℕ) in filter.at_top, set.univ.pi (λ (i : ι), set.Ioo ↑(a i) ↑(b i)) ⊆ ⋃ (i : γ n), t n i,	n : ℕ,	hn : ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n,	i : γ n,	_x : i ∈ finset.univ	⊢ emetric.diam (t n i) ^ ↑(fintype.card ι) ≤ (1 / ↑n) ^ fintype.card ι
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0),	B : ∀ᶠ (n : ℕ) in filter.at_top, ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n,	C : ∀ᶠ (n : ℕ) in filter.at_top, set.univ.pi (λ (i : ι), set.Ioo ↑(a i) ↑(b i)) ⊆ ⋃ (i : γ n), t n i,	n : ℕ,	hn : ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n,	i : γ n,	_x : i ∈ finset.univ	⊢ emetric.diam (t n i) ^ fintype.card ι ≤ (1 / ↑n) ^ fintype.card ι
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0),	B : ∀ᶠ (n : ℕ) in filter.at_top, ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n,	C : ∀ᶠ (n : ℕ) in filter.at_top, set.univ.pi (λ (i : ι), set.Ioo ↑(a i) ↑(b i)) ⊆ ⋃ (i : γ n), t n i	⊢ filter.at_top.liminf (λ (n : ℕ), ∑ (i : γ n), (1 / ↑n) ^ fintype.card ι) = filter.at_top.liminf (λ (n : ℕ), ∏ (i : ι), ↑⌈(↑(b i) - ↑(a i)) * ↑n⌉₊ / ↑n)
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0),	B : ∀ᶠ (n : ℕ) in filter.at_top, ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n,	C : ∀ᶠ (n : ℕ) in filter.at_top, set.univ.pi (λ (i : ι), set.Ioo ↑(a i) ↑(b i)) ⊆ ⋃ (i : γ n), t n i	⊢ filter.at_top.liminf (λ (n : ℕ), ∏ (i : ι), ↑⌈(↑(b i) - ↑(a i)) * ↑n⌉₊ / ↑n) = ∏ (i : ι), ⇑measure_theory.measure_space.volume (set.Ioo ↑(a i) ↑(b i))
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0),	B : ∀ᶠ (n : ℕ) in filter.at_top, ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n,	C : ∀ᶠ (n : ℕ) in filter.at_top, set.univ.pi (λ (i : ι), set.Ioo ↑(a i) ↑(b i)) ⊆ ⋃ (i : γ n), t n i	⊢ filter.at_top.liminf (λ (n : ℕ), ∏ (i : ι), ↑⌈(↑(b i) - ↑(a i)) * ↑n⌉₊ / ↑n) = ∏ (i : ι), ennreal.of_real (↑(b i) - ↑(a i))
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0),	B : ∀ᶠ (n : ℕ) in filter.at_top, ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n,	C : ∀ᶠ (n : ℕ) in filter.at_top, set.univ.pi (λ (i : ι), set.Ioo ↑(a i) ↑(b i)) ⊆ ⋃ (i : γ n), t n i	⊢ filter.tendsto (λ (n : ℕ), ∏ (i : ι), ↑⌈(↑(b i) - ↑(a i)) * ↑n⌉₊ / ↑n) filter.at_top (𝓝 (∏ (i : ι), ennreal.of_real (↑(b i) - ↑(a i))))
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0),	B : ∀ᶠ (n : ℕ) in filter.at_top, ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n,	C : ∀ᶠ (n : ℕ) in filter.at_top, set.univ.pi (λ (i : ι), set.Ioo ↑(a i) ↑(b i)) ⊆ ⋃ (i : γ n), t n i,	i : ι,	hi : i ∈ finset.univ	⊢ filter.tendsto (λ (n : ℕ), ↑⌈(↑(b i) - ↑(a i)) * ↑n⌉₊ / ↑n) filter.at_top (𝓝 (ennreal.of_real (↑(b i) - ↑(a i))))
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0),	B : ∀ᶠ (n : ℕ) in filter.at_top, ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n,	C : ∀ᶠ (n : ℕ) in filter.at_top, set.univ.pi (λ (i : ι), set.Ioo ↑(a i) ↑(b i)) ⊆ ⋃ (i : γ n), t n i,	i : ι,	hi : i ∈ finset.univ	⊢ ennreal.of_real ∘ (λ (x : ℝ), ↑⌈(↑(b i) - ↑(a i)) * x⌉₊ / x) ∘ coe =ᶠ[filter.at_top] λ (n : ℕ), ↑⌈(↑(b i) - ↑(a i)) * ↑n⌉₊ / ↑n
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0),	B : ∀ᶠ (n : ℕ) in filter.at_top, ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n,	C : ∀ᶠ (n : ℕ) in filter.at_top, set.univ.pi (λ (i : ι), set.Ioo ↑(a i) ↑(b i)) ⊆ ⋃ (i : γ n), t n i,	i : ι,	hi : i ∈ finset.univ,	n : ℕ,	hn : n ≥ 1	⊢ (ennreal.of_real ∘ (λ (x : ℝ), ↑⌈(↑(b i) - ↑(a i)) * x⌉₊ / x) ∘ coe) n = ↑⌈(↑(b i) - ↑(a i)) * ↑n⌉₊ / ↑n
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0),	B : ∀ᶠ (n : ℕ) in filter.at_top, ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n,	C : ∀ᶠ (n : ℕ) in filter.at_top, set.univ.pi (λ (i : ι), set.Ioo ↑(a i) ↑(b i)) ⊆ ⋃ (i : γ n), t n i,	i : ι,	hi : i ∈ finset.univ	⊢ filter.tendsto (λ (n : ℕ), ↑⌈(↑(b i) - ↑(a i)) * ↑n⌉₊ / ↑n) filter.at_top (𝓝 (ennreal.of_real (↑(b i) - ↑(a i))))		ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0),	B : ∀ᶠ (n : ℕ) in filter.at_top, ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n,	C : ∀ᶠ (n : ℕ) in filter.at_top, set.univ.pi (λ (i : ι), set.Ioo ↑(a i) ↑(b i)) ⊆ ⋃ (i : γ n), t n i,	i : ι,	hi : i ∈ finset.univ	⊢ ennreal.of_real (↑(b i) - ↑(a i)) ≠ ⊤
ι : Type u_1,	_inst_3 : fintype ι,	_inst_4 : nonempty ι,	_inst : Π (a : Prop), decidable a,	a b : ι → ℚ,	H : ∀ (i : ι), a i < b i,	I : ∀ (i : ι), 0 ≤ ↑(b i) - ↑(a i),	γ : ℕ → Type u_1 := λ (n : ℕ), Π (i : ι), fin ⌈(↑(b i) - ↑(a i)) * ↑n⌉₊,	t : Π (n : ℕ), γ n → set (ι → ℝ) := λ (n : ℕ) (f : γ n), set.univ.pi (λ (i : ι), set.Icc (↑(a i) + ↑(f i) / ↑n) (↑(a i) + (↑(f i) + 1) / ↑n)),	A : filter.tendsto (λ (n : ℕ), 1 / ↑n) filter.at_top (𝓝 0),	B : ∀ᶠ (n : ℕ) in filter.at_top, ∀ (i : γ n), emetric.diam (t n i) ≤ 1 / ↑n,	C : ∀ᶠ (n : ℕ) in filter.at_top, set.univ.pi (λ (i : ι), set.Ioo ↑(a i) ↑(b i)) ⊆ ⋃ (i : γ n), t n i,	i : ι,	hi : i ∈ finset.univ	⊢ ennreal.of_real (↑(b i) - ↑(a i)) ≠ ⊤
a : ℝ	⊢ ⇑measure_theory.measure_space.volume (set.Ici a) = ⊤
ι : Type u_1,	_inst_1 : fintype ι,	a : ι → ℝ,	r : ℝ,	hr : 0 < r	⊢ ⇑measure_theory.measure_space.volume (metric.ball a r) = ennreal.of_real ((2 * r) ^ fintype.card ι)
ι : Type u_1,	_inst_1 : fintype ι,	a : ι → ℝ,	r : ℝ,	hr : 0 < r	⊢ ennreal.of_real (2 * r) ^ finset.univ.card = ennreal.of_real ((2 * r) ^ fintype.card ι)
s : set ℝ	⊢ ⇑measure_theory.measure_space.volume s ≤ emetric.diam s
s : set ℝ,	hs : metric.bounded s	⊢ ⇑measure_theory.measure_space.volume s ≤ emetric.diam s
s : set ℝ,	hs : metric.bounded s	⊢ ⇑measure_theory.measure_space.volume s ≤ ⇑measure_theory.measure_space.volume (set.Icc (has_Inf.Inf s) (has_Sup.Sup s))
s : set ℝ,	hs : metric.bounded s	⊢ ⇑measure_theory.measure_space.volume s ≤ emetric.diam s		s : set ℝ,	hs : ¬metric.bounded s	⊢ ⇑measure_theory.measure_space.volume s ≤ emetric.diam s
s : set ℝ,	hs : ¬metric.bounded s	⊢ ⇑measure_theory.measure_space.volume s ≤ ⊤
s : set ℝ,	hs : ¬metric.bounded s	⊢ ⇑measure_theory.measure_space.volume s ≤ emetric.diam s
α : Type u_1,	m : measurable_space α,	s : set α,	h : s.countable,	μ : measure_theory.measure α,	_inst_4 : measure_theory.has_no_atoms μ	⊢ ⇑μ s = 0
α : Type u_1,	m : measurable_space α,	s : set α,	h : s.countable,	μ : measure_theory.measure α,	_inst_4 : measure_theory.has_no_atoms μ	⊢ ⇑μ (⋃ (x : α) (H : x ∈ s), {x}) ≤ 0
α : Type u_1,	m : measurable_space α,	s : set α,	h : s.countable,	μ : measure_theory.measure α,	_inst_4 : measure_theory.has_no_atoms μ	⊢ ∑' (p : ↥s), ⇑μ {↑p} ≤ 0
α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	μ : measure_theory.measure α,	f : α ≃ᵐ β,	s : set β	⊢ ⇑(⇑(measure_theory.measure.map ⇑f) μ) s = ⇑μ (⇑f ⁻¹' s)
α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	μ : measure_theory.measure α,	f : α ≃ᵐ β,	s : set β	⊢ ⇑(⇑(measure_theory.measure.map ⇑f) μ) s ≤ ⇑μ (⇑f ⁻¹' s)
α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	μ : measure_theory.measure α,	f : α ≃ᵐ β,	s : set β	⊢ ∀ (i : {t // ⇑f ⁻¹' s ⊆ t ∧ measurable_set t}), ⇑(⇑(measure_theory.measure.map ⇑f) μ) s ≤ ⇑μ ↑i
α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	μ : measure_theory.measure α,	f : α ≃ᵐ β,	s : set β	⊢ ⇑(⇑(measure_theory.measure.map ⇑f) μ) s ≤ ⨅ (t : {t // ⇑f ⁻¹' s ⊆ t ∧ measurable_set t}), ⇑μ ↑t
α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	μ : measure_theory.measure α,	f : α ≃ᵐ β,	s : set β,	t : set α,	hst : ⇑f ⁻¹' s ⊆ t,	ht : measurable_set t	⊢ ⇑(⇑(measure_theory.measure.map ⇑f) μ) s ≤ ⇑μ ↑⟨t, _⟩
α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	μ : measure_theory.measure α,	f : α ≃ᵐ β,	s : set β,	t : set α,	hst : ⇑f ⁻¹' s ⊆ t,	ht : measurable_set t	⊢ ⇑(⇑(measure_theory.measure.map ⇑f) μ) s ≤ ⇑μ t
α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	μ : measure_theory.measure α,	f : α ≃ᵐ β,	s : set β,	t : set α,	hst : ⇑f ⁻¹' s ⊆ t,	ht : measurable_set t,	this : ⇑(f.symm) '' s = ⇑f ⁻¹' s	⊢ ⇑(⇑(measure_theory.measure.map ⇑f) μ) s ≤ ⇑μ t
α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	μ : measure_theory.measure α,	f : α ≃ᵐ β,	s : set β,	t : set α,	ht : measurable_set t,	this : ⇑(f.symm) '' s = ⇑f ⁻¹' s,	hst : s ⊆ ⇑(f.symm) ⁻¹' t	⊢ ⇑(⇑(measure_theory.measure.map ⇑f) μ) s ≤ ⇑μ t
α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	μ : measure_theory.measure α,	f : α ≃ᵐ β,	s : set β,	t : set α,	ht : measurable_set t,	this : ⇑(f.symm) '' s = ⇑f ⁻¹' s,	hst : s ⊆ ⇑(f.symm) ⁻¹' t	⊢ ⇑μ t = ⇑(⇑(measure_theory.measure.map ⇑f) μ) (⇑(f.symm) ⁻¹' t)
α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	μ : measure_theory.measure α,	f : α ≃ᵐ β,	s : set β,	t : set α,	ht : measurable_set t,	this : ⇑(f.symm) '' s = ⇑f ⁻¹' s,	hst : s ⊆ ⇑(f.symm) ⁻¹' t	⊢ (λ (x : α), ⇑(f.symm) (⇑f x)) ⁻¹' t = t
α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	μ : measure_theory.measure α,	f : α ≃ᵐ β,	s : set β,	t : set α,	ht : measurable_set t,	this : ⇑(f.symm) '' s = ⇑f ⁻¹' s,	hst : s ⊆ ⇑(f.symm) ⁻¹' t	⊢ (λ (x : α), ⇑(f.symm) (⇑f x)) = id
α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	μ : measure_theory.measure α,	f : α ≃ᵐ β,	s : set β,	t : set α,	ht : measurable_set t,	this : ⇑(f.symm) '' s = ⇑f ⁻¹' s,	hst : s ⊆ ⇑(f.symm) ⁻¹' t	⊢ ⇑μ t = ⇑μ ((λ (x : α), ⇑(f.symm) (⇑f x)) ⁻¹' t)
α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	μ : measure_theory.measure α,	f : α ≃ᵐ β,	s : set β,	t : set α,	ht : measurable_set t,	this : ⇑(f.symm) '' s = ⇑f ⁻¹' s,	hst : s ⊆ ⇑(f.symm) ⁻¹' t	⊢ ⇑μ t = ⇑μ ((λ (x : α), ⇑(f.symm) (⇑f x)) ⁻¹' t)		α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	μ : measure_theory.measure α,	f : α ≃ᵐ β,	s : set β,	t : set α,	ht : measurable_set t,	this : ⇑(f.symm) '' s = ⇑f ⁻¹' s,	hst : s ⊆ ⇑(f.symm) ⁻¹' t	⊢ measurable ⇑f		α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	μ : measure_theory.measure α,	f : α ≃ᵐ β,	s : set β,	t : set α,	ht : measurable_set t,	this : ⇑(f.symm) '' s = ⇑f ⁻¹' s,	hst : s ⊆ ⇑(f.symm) ⁻¹' t	⊢ measurable_set (⇑(f.symm) ⁻¹' t)
α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	μ : measure_theory.measure α,	f : α ≃ᵐ β,	s : set β,	t : set α,	ht : measurable_set t,	this : ⇑(f.symm) '' s = ⇑f ⁻¹' s,	hst : s ⊆ ⇑(f.symm) ⁻¹' t	⊢ measurable ⇑f		α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	μ : measure_theory.measure α,	f : α ≃ᵐ β,	s : set β,	t : set α,	ht : measurable_set t,	this : ⇑(f.symm) '' s = ⇑f ⁻¹' s,	hst : s ⊆ ⇑(f.symm) ⁻¹' t	⊢ measurable_set (⇑(f.symm) ⁻¹' t)
α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	μ : measure_theory.measure α,	ν : measure_theory.measure β,	e : α ≃ᵐ β	⊢ ⇑(measure_theory.measure.map ⇑e) μ = ν ↔ ⇑(measure_theory.measure.map ⇑(e.symm)) ν = μ
α : Type u_1,	ι : Type u_5,	m : measurable_space α,	μ : measure_theory.measure α,	s : ι → set α,	hs : ∀ (i : ι), measurable_set (s i),	H : ⇑μ set.univ < ∑' (i : ι), ⇑μ (s i)	⊢ ∃ (i j : ι) (h : i ≠ j), (s i ∩ s j).nonempty
α : Type u_1,	ι : Type u_5,	m : measurable_space α,	μ : measure_theory.measure α,	s : ι → set α,	hs : ∀ (i : ι), measurable_set (s i),	H : ∀ (i j : ι), i ≠ j → ¬(s i ∩ s j).nonempty	⊢ ∑' (i : ι), ⇑μ (s i) ≤ ⇑μ set.univ
α : Type u_1,	ι : Type u_5,	m : measurable_space α,	μ : measure_theory.measure α,	s : ι → set α,	hs : ∀ (i : ι), measurable_set (s i),	H : ∀ (i j : ι), i ≠ j → ¬(s i ∩ s j).nonempty	⊢ pairwise (disjoint on λ (i : ι), s i)
α : Type u_1,	m0 : measurable_space α,	μ ν : measure_theory.measure α	⊢ ¬ν ≤ μ ↔ ∃ (s : set α), measurable_set s ∧ ⇑μ s < ⇑ν s
α : Type u_1,	s : set α,	m0 : measurable_space α,	hs : measurable_set s,	μ : measure_theory.measure α,	t : set α,	ht : measurable_set t	⊢ ⇑(⇑((measure_theory.measure.map coe).comp (measure_theory.measure.comap coe)) μ) t = ⇑(⇑(measure_theory.measure.restrictₗ s) μ) t
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	s : set α	⊢ ∃ (t : set α), s ⊆ t ∧ measurable_set t ∧ ⇑μ t = ⇑μ s
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	s t : set α	⊢ ⇑μ (s ∪ t) < ⊤ ↔ ⇑μ s < ⊤ ∧ ⇑μ t < ⊤
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	s t : set α,	h : ⇑μ (s ∪ t) < ⊤	⊢ ⇑μ s < ⊤
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	s t : set α,	h : ⇑μ (s ∪ t) < ⊤	⊢ ⇑μ s < ⊤		α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	s t : set α,	h : ⇑μ (s ∪ t) < ⊤	⊢ ⇑μ t < ⊤
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure_theory.measure α,	s t : set α,	h : ⇑μ (s ∪ t) < ⊤	⊢ ⇑μ t < ⊤
α : Type u_1,	ι : Sort u_2,	f : ι → measure_theory.outer_measure α,	s : set α	⊢ (⇑⨆ (i : ι), f i) s = ⨆ (i : ι), ⇑(f i) s
α : Type u_1,	m : measure_theory.outer_measure α,	s : set α	⊢ ⇑(⇑(measure_theory.outer_measure.restrict ∅) m) s = ⇑0 s
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	p q q' : set α → Prop,	H : μ.inner_regular p q,	H' : μ.inner_regular q q'	⊢ μ.inner_regular p q'
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	p q q' : set α → Prop,	H : μ.inner_regular p q,	H' : μ.inner_regular q q',	U : set α,	hU : q' U,	r : ℝ≥0∞,	hr : r < ⇑μ U	⊢ ∃ (K : set α) (H : K ⊆ U), p K ∧ r < ⇑μ K
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	p q q' : set α → Prop,	H : μ.inner_regular p q,	H' : μ.inner_regular q q',	U : set α,	hU : q' U,	r : ℝ≥0∞,	hr : r < ⇑μ U,	F : set α,	hFU : F ⊆ U,	hqF : q F,	hF : r < ⇑μ F	⊢ ∃ (K : set α) (H : K ⊆ U), p K ∧ r < ⇑μ K
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	p q q' : set α → Prop,	H : μ.inner_regular p q,	H' : μ.inner_regular q q',	U : set α,	hU : q' U,	r : ℝ≥0∞,	hr : r < ⇑μ U,	F : set α,	hFU : F ⊆ U,	hqF : q F,	hF : r < ⇑μ F,	K : set α,	hKF : K ⊆ F,	hpK : p K,	hrK : r < ⇑μ K	⊢ ∃ (K : set α) (H : K ⊆ U), p K ∧ r < ⇑μ K
X : Type u_1,	_inst_3 : topological_space X,	_inst_4 : t2_space X,	_inst_5 : sigma_compact_space X,	_inst_6 : measurable_space X,	_inst_7 : opens_measurable_space X,	μ : measure_theory.measure X	⊢ μ.inner_regular is_compact is_closed
X : Type u_1,	_inst_3 : topological_space X,	_inst_4 : t2_space X,	_inst_5 : sigma_compact_space X,	_inst_6 : measurable_space X,	_inst_7 : opens_measurable_space X,	μ : measure_theory.measure X,	F : set X,	hF : is_closed F,	r : ℝ≥0∞,	hr : r < ⇑μ F	⊢ ∃ (K : set X) (H : K ⊆ F), is_compact K ∧ r < ⇑μ K
X : Type u_1,	_inst_3 : topological_space X,	_inst_4 : t2_space X,	_inst_5 : sigma_compact_space X,	_inst_6 : measurable_space X,	_inst_7 : opens_measurable_space X,	μ : measure_theory.measure X,	F : set X,	hF : is_closed F,	r : ℝ≥0∞,	hr : r < ⇑μ F,	B : ℕ → set X := compact_covering X	⊢ ∃ (K : set X) (H : K ⊆ F), is_compact K ∧ r < ⇑μ K
X : Type u_1,	_inst_3 : topological_space X,	_inst_4 : t2_space X,	_inst_5 : sigma_compact_space X,	_inst_6 : measurable_space X,	_inst_7 : opens_measurable_space X,	μ : measure_theory.measure X,	F : set X,	hF : is_closed F,	r : ℝ≥0∞,	hr : r < ⇑μ F,	B : ℕ → set X := compact_covering X	⊢ ∀ (n : ℕ), is_compact (F ∩ B n)		X : Type u_1,	_inst_3 : topological_space X,	_inst_4 : t2_space X,	_inst_5 : sigma_compact_space X,	_inst_6 : measurable_space X,	_inst_7 : opens_measurable_space X,	μ : measure_theory.measure X,	F : set X,	hF : is_closed F,	r : ℝ≥0∞,	hr : r < ⇑μ F,	B : ℕ → set X := compact_covering X,	hBc : ∀ (n : ℕ), is_compact (F ∩ B n)	⊢ ∃ (K : set X) (H : K ⊆ F), is_compact K ∧ r < ⇑μ K
X : Type u_1,	_inst_3 : topological_space X,	_inst_4 : t2_space X,	_inst_5 : sigma_compact_space X,	_inst_6 : measurable_space X,	_inst_7 : opens_measurable_space X,	μ : measure_theory.measure X,	F : set X,	hF : is_closed F,	r : ℝ≥0∞,	hr : r < ⇑μ F,	B : ℕ → set X := compact_covering X,	hBc : ∀ (n : ℕ), is_compact (F ∩ B n)	⊢ (⋃ (n : ℕ), F ∩ B n) = F
X : Type u_1,	_inst_3 : topological_space X,	_inst_4 : t2_space X,	_inst_5 : sigma_compact_space X,	_inst_6 : measurable_space X,	_inst_7 : opens_measurable_space X,	μ : measure_theory.measure X,	F : set X,	hF : is_closed F,	r : ℝ≥0∞,	hr : r < ⇑μ F,	B : ℕ → set X := compact_covering X,	hBc : ∀ (n : ℕ), is_compact (F ∩ B n)	⊢ ∃ (K : set X) (H : K ⊆ F), is_compact K ∧ r < ⇑μ K
X : Type u_1,	_inst_3 : topological_space X,	_inst_4 : t2_space X,	_inst_5 : sigma_compact_space X,	_inst_6 : measurable_space X,	_inst_7 : opens_measurable_space X,	μ : measure_theory.measure X,	F : set X,	hF : is_closed F,	r : ℝ≥0∞,	hr : r < ⇑μ F,	B : ℕ → set X := compact_covering X,	hBc : ∀ (n : ℕ), is_compact (F ∩ B n),	hBU : (⋃ (n : ℕ), F ∩ B n) = F	⊢ ∃ (K : set X) (H : K ⊆ F), is_compact K ∧ r < ⇑μ K
X : Type u_1,	_inst_3 : topological_space X,	_inst_4 : t2_space X,	_inst_5 : sigma_compact_space X,	_inst_6 : measurable_space X,	_inst_7 : opens_measurable_space X,	μ : measure_theory.measure X,	F : set X,	hF : is_closed F,	r : ℝ≥0∞,	hr : r < ⇑μ F,	B : ℕ → set X := compact_covering X,	hBc : ∀ (n : ℕ), is_compact (F ∩ B n),	hBU : (⋃ (n : ℕ), F ∩ B n) = F	⊢ ⇑μ F = ⨆ (n : ℕ), ⇑μ (F ∩ B n)
X : Type u_1,	_inst_3 : topological_space X,	_inst_4 : t2_space X,	_inst_5 : sigma_compact_space X,	_inst_6 : measurable_space X,	_inst_7 : opens_measurable_space X,	μ : measure_theory.measure X,	F : set X,	hF : is_closed F,	r : ℝ≥0∞,	hr : r < ⇑μ F,	B : ℕ → set X := compact_covering X,	hBc : ∀ (n : ℕ), is_compact (F ∩ B n),	hBU : (⋃ (n : ℕ), F ∩ B n) = F	⊢ ∀ (i : ℕ), measurable_set (F ∩ B i)		X : Type u_1,	_inst_3 : topological_space X,	_inst_4 : t2_space X,	_inst_5 : sigma_compact_space X,	_inst_6 : measurable_space X,	_inst_7 : opens_measurable_space X,	μ : measure_theory.measure X,	F : set X,	hF : is_closed F,	r : ℝ≥0∞,	hr : r < ⇑μ F,	B : ℕ → set X := compact_covering X,	hBc : ∀ (n : ℕ), is_compact (F ∩ B n),	hBU : (⋃ (n : ℕ), F ∩ B n) = F	⊢ directed has_subset.subset (λ (i : ℕ), F ∩ B i)
X : Type u_1,	_inst_3 : topological_space X,	_inst_4 : t2_space X,	_inst_5 : sigma_compact_space X,	_inst_6 : measurable_space X,	_inst_7 : opens_measurable_space X,	μ : measure_theory.measure X,	F : set X,	hF : is_closed F,	r : ℝ≥0∞,	hr : r < ⇑μ F,	B : ℕ → set X := compact_covering X,	hBc : ∀ (n : ℕ), is_compact (F ∩ B n),	hBU : (⋃ (n : ℕ), F ∩ B n) = F	⊢ ⇑μ F = ⨆ (n : ℕ), ⇑μ (F ∩ B n)		X : Type u_1,	_inst_3 : topological_space X,	_inst_4 : t2_space X,	_inst_5 : sigma_compact_space X,	_inst_6 : measurable_space X,	_inst_7 : opens_measurable_space X,	μ : measure_theory.measure X,	F : set X,	hF : is_closed F,	r : ℝ≥0∞,	hr : r < ⇑μ F,	B : ℕ → set X := compact_covering X,	hBc : ∀ (n : ℕ), is_compact (F ∩ B n),	hBU : (⋃ (n : ℕ), F ∩ B n) = F,	this : ⇑μ F = ⨆ (n : ℕ), ⇑μ (F ∩ B n)	⊢ ∃ (K : set X) (H : K ⊆ F), is_compact K ∧ r < ⇑μ K
X : Type u_1,	_inst_3 : topological_space X,	_inst_4 : t2_space X,	_inst_5 : sigma_compact_space X,	_inst_6 : measurable_space X,	_inst_7 : opens_measurable_space X,	μ : measure_theory.measure X,	F : set X,	hF : is_closed F,	r : ℝ≥0∞,	B : ℕ → set X := compact_covering X,	hBc : ∀ (n : ℕ), is_compact (F ∩ B n),	hBU : (⋃ (n : ℕ), F ∩ B n) = F,	this : ⇑μ F = ⨆ (n : ℕ), ⇑μ (F ∩ B n),	hr : r < ⨆ (n : ℕ), ⇑μ (F ∩ B n)	⊢ ∃ (K : set X) (H : K ⊆ F), is_compact K ∧ r < ⇑μ K
X : Type u_1,	_inst_3 : topological_space X,	_inst_4 : t2_space X,	_inst_5 : sigma_compact_space X,	_inst_6 : measurable_space X,	_inst_7 : opens_measurable_space X,	μ : measure_theory.measure X,	F : set X,	hF : is_closed F,	r : ℝ≥0∞,	hr : r < ⇑μ F,	B : ℕ → set X := compact_covering X,	hBc : ∀ (n : ℕ), is_compact (F ∩ B n),	hBU : (⋃ (n : ℕ), F ∩ B n) = F,	this : ⇑μ F = ⨆ (n : ℕ), ⇑μ (F ∩ B n)	⊢ ∃ (K : set X) (H : K ⊆ F), is_compact K ∧ r < ⇑μ K
X : Type u_1,	_inst_3 : topological_space X,	_inst_4 : t2_space X,	_inst_5 : sigma_compact_space X,	_inst_6 : measurable_space X,	_inst_7 : opens_measurable_space X,	μ : measure_theory.measure X,	F : set X,	hF : is_closed F,	r : ℝ≥0∞,	B : ℕ → set X := compact_covering X,	hBc : ∀ (n : ℕ), is_compact (F ∩ B n),	hBU : (⋃ (n : ℕ), F ∩ B n) = F,	this : ⇑μ F = ⨆ (n : ℕ), ⇑μ (F ∩ B n),	hr : r < ⨆ (n : ℕ), ⇑μ (F ∩ B n),	n : ℕ,	hn : r < ⇑μ (F ∩ B n)	⊢ ∃ (K : set X) (H : K ⊆ F), is_compact K ∧ r < ⇑μ K
f : stieltjes_function,	a b : ℝ	⊢ ⇑{to_outer_measure := f.outer, m_Union := _, trimmed := _} (set.Ioc a b) = ennreal.of_real (⇑f b - ⇑f a)
f : stieltjes_function,	a b : ℝ	⊢ ⇑(f.measure) (set.Ioc a b) = ennreal.of_real (⇑f b - ⇑f a)
α : Type u_1,	m : measurable_space α,	M : Type u_4,	N : Type u_5,	_inst_3 : add_comm_monoid M,	_inst_4 : topological_space M,	_inst_5 : add_comm_monoid N,	_inst_6 : topological_space N,	v : measure_theory.vector_measure α M,	w : measure_theory.vector_measure α N,	R : Type u_2,	_inst_7 : semiring R,	_inst_8 : distrib_mul_action R N,	_inst_9 : topological_space R,	_inst_10 : has_continuous_smul R N,	r : R,	h : v ⊥ᵥ w,	_let_match : v ⊥ᵥ w → v ⊥ᵥ r • w,	s : set α,	hmeas : measurable_set s,	hs₁ : ∀ (t : set α), t ⊆ s → ⇑v t = 0,	hs₂ : ∀ (t : set α), t ⊆ sᶜ → ⇑w t = 0,	t : set α,	ht : t ⊆ sᶜ	⊢ ⇑(r • w) t = 0
α : Type u_1,	m : measurable_space α,	s : measure_theory.signed_measure α,	hs : 0.restrict set.univ ≤ measure_theory.vector_measure.restrict s set.univ	⊢ (s.to_measure_of_zero_le set.univ measurable_set.univ hs).to_signed_measure = s
α : Type u_1,	m : measurable_space α,	s : measure_theory.signed_measure α,	hs : 0.restrict set.univ ≤ measure_theory.vector_measure.restrict s set.univ,	i : set α,	hi : measurable_set i	⊢ ⇑((s.to_measure_of_zero_le set.univ measurable_set.univ hs).to_signed_measure) i = ⇑s i
α : Type u_1,	m : measurable_space α,	s : measure_theory.signed_measure α,	hs : measure_theory.vector_measure.restrict s set.univ ≤ 0.restrict set.univ	⊢ (s.to_measure_of_le_zero set.univ measurable_set.univ hs).to_signed_measure = -s
α : Type u_1,	m : measurable_space α,	s : measure_theory.signed_measure α,	hs : measure_theory.vector_measure.restrict s set.univ ≤ 0.restrict set.univ,	i : set α,	hi : measurable_set i	⊢ ⇑((s.to_measure_of_le_zero set.univ measurable_set.univ hs).to_signed_measure) i = (⇑-s) i
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	E : Type u_3,	_inst_1 : normed_group E,	_inst_2 : measurable_space E,	_inst_3 : topological_space.second_countable_topology E,	_inst_4 : normed_space ℝ E,	_inst_5 : complete_space E,	_inst_6 : borel_space E,	f g : α → E,	hf : measure_theory.integrable f μ,	hg : measure_theory.integrable g μ,	hfg : μ.with_densityᵥ f = μ.with_densityᵥ g	⊢ f =ᵐ[μ] g
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	E : Type u_3,	_inst_1 : normed_group E,	_inst_2 : measurable_space E,	_inst_3 : topological_space.second_countable_topology E,	_inst_4 : normed_space ℝ E,	_inst_5 : complete_space E,	_inst_6 : borel_space E,	f g : α → E,	hf : measure_theory.integrable f μ,	hg : measure_theory.integrable g μ,	hfg : μ.with_densityᵥ f = μ.with_densityᵥ g,	i : set α,	hi : measurable_set i,	_x : ⇑μ i < ⊤	⊢ ∫ (x : α) in i, f x ∂μ = ∫ (x : α) in i, g x ∂μ
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	E : Type u_3,	_inst_1 : normed_group E,	_inst_2 : measurable_space E,	_inst_3 : topological_space.second_countable_topology E,	_inst_4 : normed_space ℝ E,	_inst_5 : complete_space E,	_inst_6 : borel_space E,	f : α → E	⊢ μ.with_densityᵥ (-f) = -μ.with_densityᵥ f
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	E : Type u_3,	_inst_1 : normed_group E,	_inst_2 : measurable_space E,	_inst_3 : topological_space.second_countable_topology E,	_inst_4 : normed_space ℝ E,	_inst_5 : complete_space E,	_inst_6 : borel_space E,	f : α → E,	hf : measure_theory.integrable f μ	⊢ μ.with_densityᵥ (-f) = -μ.with_densityᵥ f
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	E : Type u_3,	_inst_1 : normed_group E,	_inst_2 : measurable_space E,	_inst_3 : topological_space.second_countable_topology E,	_inst_4 : normed_space ℝ E,	_inst_5 : complete_space E,	_inst_6 : borel_space E,	f : α → E,	hf : measure_theory.integrable f μ,	i : set α,	hi : measurable_set i	⊢ ⇑(μ.with_densityᵥ (-f)) i = (⇑-μ.with_densityᵥ f) i
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	E : Type u_3,	_inst_1 : normed_group E,	_inst_2 : measurable_space E,	_inst_3 : topological_space.second_countable_topology E,	_inst_4 : normed_space ℝ E,	_inst_5 : complete_space E,	_inst_6 : borel_space E,	f : α → E,	hf : measure_theory.integrable f μ	⊢ μ.with_densityᵥ (-f) = -μ.with_densityᵥ f		α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	E : Type u_3,	_inst_1 : normed_group E,	_inst_2 : measurable_space E,	_inst_3 : topological_space.second_countable_topology E,	_inst_4 : normed_space ℝ E,	_inst_5 : complete_space E,	_inst_6 : borel_space E,	f : α → E,	hf : ¬measure_theory.integrable f μ	⊢ μ.with_densityᵥ (-f) = -μ.with_densityᵥ f
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	E : Type u_3,	_inst_1 : normed_group E,	_inst_2 : measurable_space E,	_inst_3 : topological_space.second_countable_topology E,	_inst_4 : normed_space ℝ E,	_inst_5 : complete_space E,	_inst_6 : borel_space E,	f : α → E,	hf : measure_theory.integrable f μ,	i : set α,	hi : measurable_set i	⊢ ∫ (x : α) in i, (-f) x ∂μ = ∫ (a : α) in i, -f a ∂μ
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	E : Type u_3,	_inst_1 : normed_group E,	_inst_2 : measurable_space E,	_inst_3 : topological_space.second_countable_topology E,	_inst_4 : normed_space ℝ E,	_inst_5 : complete_space E,	_inst_6 : borel_space E,	f : α → E,	hf : ¬measure_theory.integrable f μ	⊢ μ.with_densityᵥ (-f) = -μ.with_densityᵥ f
α : Type u_1,	m : measurable_space α,	μ : measure_theory.measure α,	E : Type u_3,	_inst_1 : normed_group E,	_inst_2 : measurable_space E,	_inst_3 : topological_space.second_countable_topology E,	_inst_4 : normed_space ℝ E,	_inst_5 : complete_space E,	_inst_6 : borel_space E,	f : α → E,	hf : ¬measure_theory.integrable f μ	⊢ ¬measure_theory.integrable (-f) μ
α : Type u_1,	S T : set (set α),	hST : S ⊆ T	⊢ generate_pi_system S ⊆ generate_pi_system T
α : Type u_1,	S T : set (set α),	hST : S ⊆ T,	t : set α,	ht : t ∈ generate_pi_system S	⊢ t ∈ generate_pi_system T
α : Type u_1,	S T : set (set α),	hST : S ⊆ T,	t s : set α,	h_s : s ∈ S	⊢ s ∈ generate_pi_system T
α : Type u_1,	S T : set (set α),	hST : S ⊆ T,	t s : set α,	h_s : s ∈ S	⊢ s ∈ generate_pi_system T		case generate_pi_system.inter	α : Type u_1,	S T : set (set α),	hST : S ⊆ T,	t s u : set α,	h_gen_s : generate_pi_system S s,	h_gen_u : generate_pi_system S u,	h_nonempty : (s ∩ u).nonempty,	h_s : s ∈ generate_pi_system T,	h_u : u ∈ generate_pi_system T	⊢ s ∩ u ∈ generate_pi_system T
α : Type u_1,	S T : set (set α),	hST : S ⊆ T,	t s u : set α,	h_gen_s : generate_pi_system S s,	h_gen_u : generate_pi_system S u,	h_nonempty : (s ∩ u).nonempty,	h_s : s ∈ generate_pi_system T,	h_u : u ∈ generate_pi_system T	⊢ s ∩ u ∈ generate_pi_system T
α : Type u_1,	p : pmf α,	a a' : α	⊢ ⇑p a * ite (a' = a) 1 0 = ite (a = a') (⇑p a') 0
α : Type u_1,	p : pmf α,	a a' : α	⊢ ⇑p a * ite (a' = a) 1 0 = ite (a = a') (⇑p a') 0
α : Type u_1,	p : pmf α,	a a' : α	⊢ ⇑p a * ite (a' = a) 1 0 = ite (a = a') (⇑p a') 0
α : Type u_1,	p : pmf α,	a a' : α	⊢ ⇑p a * ite (a' = a) 1 0 = ite (a = a') (⇑p a') 0
α : Type u_1,	p : pmf α,	a a' : α,	h : a' = a,	h_1 : a = a'	⊢ ⇑p a * 1 = ⇑p a'
α : Type u_1,	p : pmf α,	a a' : α,	h : a' = a,	h_1 : ¬a = a'	⊢ ⇑p a * 1 = 0
α : Type u_1,	p : pmf α,	a a' : α,	h : ¬a' = a,	h_1 : a = a'	⊢ ⇑p a * 0 = ⇑p a'
α : Type u_1,	p : pmf α,	a a' : α,	h : ¬a' = a,	h_1 : ¬a = a'	⊢ ⇑p a * 0 = 0
α : Type u_1,	p : pmf α,	a a' : α,	h : ¬a' = a,	h_1 : ¬a = a'	⊢ ⇑p a * 0 = 0
α : Type u_1,	p : pmf α,	a' : α,	h_1 : a' = a'	⊢ ⇑p a' * 1 = ⇑p a'
α : Type u_1,	p : pmf α,	a' : α,	h_1 : ¬a' = a'	⊢ ⇑p a' * 1 = 0
α : Type u_1,	p : pmf α,	a' : α,	h : ¬a' = a'	⊢ ⇑p a' * 0 = ⇑p a'
α : Type u_1,	p : pmf α,	a a' : α,	h : ¬a' = a,	h_1 : ¬a = a'	⊢ ⇑p a * 0 = 0
α : Type u_1,	p : pmf α,	a a' : α,	h : ¬a' = a,	h_1 : ¬a = a'	⊢ ⇑p a * 0 = 0
α : Type u_1,	p : pmf α,	a' : α,	h_1 : a' = a'	⊢ ⇑p a' * 1 = ⇑p a'
α : Type u_1,	p : pmf α,	a' : α,	h_1 : ¬a' = a'	⊢ ⇑p a' * 1 = 0
α : Type u_1,	p : pmf α,	a' : α,	h : ¬a' = a'	⊢ ⇑p a' * 0 = ⇑p a'
α : Type u_1,	p : pmf α,	a a' : α,	h : ¬a' = a,	h_1 : ¬a = a'	⊢ ⇑p a * 0 = 0
α : Type u_1,	p : pmf α,	this : ∀ (a a' : α), ⇑p a * ite (a' = a) 1 0 = ite (a = a') (⇑p a') 0,	b : α	⊢ ↑(⇑(p.bind pmf.pure) b) = ↑(⇑p b)
α : Type u_1,	p : pmf α,	this : ∀ (a a' : α), ⇑p a * ite (a' = a) 1 0 = ite (a = a') (⇑p a') 0	⊢ p.bind pmf.pure = p
α : Type u_1,	p : pmf α,	this : ∀ (a a' : α), ⇑p a * ite (a' = a) 1 0 = ite (a = a') (⇑p a') 0	⊢ p.bind pmf.pure = p
L : first_order.language,	M : Type u_3,	N : Type u_4,	_inst_1 : L.Structure M,	_inst_2 : L.Structure N,	_inst_5 : L.is_algebraic,	f : L.hom M N,	hf : function.injective ⇑f,	x : M	⊢ ⇑((first_order.language.embedding.of_injective hf).to_hom) x = ⇑f x
L : first_order.language,	M : Type u_3,	N : Type u_4,	_inst_1 : L.Structure M,	_inst_2 : L.Structure N,	_inst_5 : L.is_algebraic,	f : L.hom M N,	hf : function.injective ⇑f	⊢ (first_order.language.embedding.of_injective hf).to_hom = f
R : Type u_1,	_inst_1 : add_group R,	f : nat.arithmetic_function R	⊢ -⇑f 0 = 0
k : ℕ	⊢ ζ * nat.arithmetic_function.pow k = σ k
k x : ℕ	⊢ ⇑(ζ * nat.arithmetic_function.pow k) x = ⇑(σ k) x
k x : ℕ	⊢ ∑ (i : ℕ) in x.divisors, ⇑(nat.arithmetic_function.pow k) i = ⇑{to_fun := λ (n : ℕ), ∑ (d : ℕ) in n.divisors, d ^ k, map_zero' := _} x
k x : ℕ	⊢ ∀ (x_1 : ℕ), x_1 ∈ x.divisors → ⇑(nat.arithmetic_function.pow k) x_1 = x_1 ^ k
k x x : ℕ,	hx : x ∈ x.divisors	⊢ ⇑(nat.arithmetic_function.pow k) x = x ^ k
k x x : ℕ,	hx : x ∈ x.divisors	⊢ ¬x = 0
k x x : ℕ,	hx : x = 0	⊢ x ∉ x.divisors
⊢ ∑ (k : ℕ) in finset.range 0, ↑(0.choose k) * bernoulli' k = ↑0
⊢ ∑ (k : ℕ) in finset.range 0, ↑(0.choose k) * bernoulli' k = ↑0		case nat.succ	n : ℕ	⊢ ∑ (k : ℕ) in finset.range n.succ, ↑(n.succ.choose k) * bernoulli' k = ↑(n.succ)
n : ℕ	⊢ ∑ (k : ℕ) in finset.range n, ↑(n.choose k) * bernoulli' k = ↑n
n : ℕ	⊢ ∑ (k : ℕ) in finset.range n.succ, ↑(n.succ.choose k) * bernoulli' k = ↑(n.succ)
n : ℕ,	this : (↑n + 1) * ∑ (k : ℕ) in finset.range n, ↑(n.choose k) / (↑n - ↑k + 1) * bernoulli' k = ∑ (x : ℕ) in finset.range n, ↑(n.succ.choose x) * bernoulli' x	⊢ ∑ (k : ℕ) in finset.range n.succ, ↑(n.succ.choose k) * bernoulli' k = ↑(n.succ)
n : ℕ,	this : (↑n + 1) * ∑ (k : ℕ) in finset.range n, ↑(n.choose k) / (↑n - ↑k + 1) * bernoulli' k = ∑ (x : ℕ) in finset.range n, ↑(n.succ.choose x) * bernoulli' x	⊢ ↑(n + 1) * ∑ (k : ℕ) in finset.range n, ↑(n.choose k) / (↑n - ↑k + 1) * bernoulli' k + ↑(n + 1) * (1 - ∑ (k : ℕ) in finset.range n, ↑(n.choose k) / (↑n - ↑k + 1) * bernoulli' k) = ↑(n.succ)
n : ℕ,	this : (↑n + 1) * ∑ (k : ℕ) in finset.range n, ↑(n.choose k) / (↑n - ↑k + 1) * bernoulli' k = ∑ (x : ℕ) in finset.range n, ↑(n.succ.choose x) * bernoulli' x	⊢ ∑ (k : ℕ) in finset.range n.succ, ↑(n.succ.choose k) * bernoulli' k = ↑(n.succ)		n : ℕ	⊢ (↑n + 1) * ∑ (k : ℕ) in finset.range n, ↑(n.choose k) / (↑n - ↑k + 1) * bernoulli' k = ∑ (x : ℕ) in finset.range n, ↑(n.succ.choose x) * bernoulli' x
n : ℕ	⊢ (↑n + 1) * ∑ (k : ℕ) in finset.range n, ↑(n.choose k) / (↑n - ↑k + 1) * bernoulli' k = ∑ (x : ℕ) in finset.range n, ↑(n.succ.choose x) * bernoulli' x
n : ℕ	⊢ ∑ (x : ℕ) in finset.range n, (↑n + 1) * (↑(n.choose x) / (↑n - ↑x + 1)) * bernoulli' x = ∑ (x : ℕ) in finset.range n, ↑(n.succ.choose x) * bernoulli' x
n k : ℕ,	hk : k ∈ finset.range n	⊢ (↑n + 1) * (↑(n.choose k) / (↑n - ↑k + 1)) * bernoulli' k = ↑(n.succ.choose k) * bernoulli' k
n k : ℕ,	hk : k ∈ finset.range n	⊢ (↑n + 1) * (↑(n.choose k) / (↑n - ↑k + 1)) = ↑(n.succ.choose k)
n k : ℕ,	hk : k ∈ finset.range n	⊢ ↑(n - k) + 1 ≠ 0
n k : ℕ,	hk : k ∈ finset.range n,	this : ↑(n - k) + 1 ≠ 0	⊢ (↑n + 1) * (↑(n.choose k) / (↑n - ↑k + 1)) = ↑(n.succ.choose k)
n k : ℕ,	hk : k ∈ finset.range n,	this : ↑(n - k) + 1 ≠ 0	⊢ ↑(n.choose k) * (↑n + 1) = ↑(n.succ.choose k) * (↑(n - k) + 1)
⊢ bernoulli 1 = (-1) / 2
n : ℕ	⊢ 1 - ∑ (k : fin n), ↑(n.choose ↑k) / (↑n - ↑k + 1) * bernoulli' ↑k = 1 - ∑ (i : fin n), ↑(n.choose ↑i) / (↑n - ↑↑i + 1) * bernoulli' ↑i
n : ℕ	⊢ bernoulli' n = 1 - ∑ (k : ℕ) in finset.range n, ↑(n.choose k) / (↑n - ↑k + 1) * bernoulli' k
⊢ 1 - ∑ (k : ℕ) in finset.range 0, ↑(0.choose k) / (↑0 - ↑k + 1) * bernoulli' k = 1
⊢ bernoulli' 0 = 1
R : Type u_1,	S : Type u_2,	_inst_1 : euclidean_domain R,	_inst_2 : integral_domain S,	_inst_11 : algebra R S,	abv : absolute_value R ℤ,	ι : Type u_5,	_inst_13 : decidable_eq ι,	_inst_14 : fintype ι,	bS : basis ι R S,	T : Type u_3,	_inst_15 : linear_ordered_comm_ring T,	a : S,	y : T,	hy : ∀ (k : ι), ↑(⇑abv (⇑(⇑(bS.repr) a) k)) < y,	i : ι,	him : (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).nonempty	⊢ ↑(⇑abv (⇑(algebra.norm R) a)) < ↑(class_group.norm_bound abv bS) * y ^ fintype.card ι
R : Type u_1,	S : Type u_2,	_inst_1 : euclidean_domain R,	_inst_2 : integral_domain S,	_inst_11 : algebra R S,	abv : absolute_value R ℤ,	ι : Type u_5,	_inst_13 : decidable_eq ι,	_inst_14 : fintype ι,	bS : basis ι R S,	T : Type u_3,	_inst_15 : linear_ordered_comm_ring T,	a : S,	y : T,	hy : ∀ (k : ι), ↑(⇑abv (⇑(⇑(bS.repr) a) k)) < y,	i : ι,	him : (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).nonempty,	y' : ℤ := (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	y'_def : y' = (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him	⊢ ↑(⇑abv (⇑(algebra.norm R) a)) < ↑(class_group.norm_bound abv bS) * y ^ fintype.card ι
R : Type u_1,	S : Type u_2,	_inst_1 : euclidean_domain R,	_inst_2 : integral_domain S,	_inst_11 : algebra R S,	abv : absolute_value R ℤ,	ι : Type u_5,	_inst_13 : decidable_eq ι,	_inst_14 : fintype ι,	bS : basis ι R S,	T : Type u_3,	_inst_15 : linear_ordered_comm_ring T,	a : S,	y : T,	hy : ∀ (k : ι), ↑(⇑abv (⇑(⇑(bS.repr) a) k)) < y,	i : ι,	him : (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).nonempty,	y' : ℤ := (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	y'_def : y' = (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him	⊢ ∀ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k) ≤ y'
R : Type u_1,	S : Type u_2,	_inst_1 : euclidean_domain R,	_inst_2 : integral_domain S,	_inst_11 : algebra R S,	abv : absolute_value R ℤ,	ι : Type u_5,	_inst_13 : decidable_eq ι,	_inst_14 : fintype ι,	bS : basis ι R S,	T : Type u_3,	_inst_15 : linear_ordered_comm_ring T,	a : S,	y : T,	hy : ∀ (k : ι), ↑(⇑abv (⇑(⇑(bS.repr) a) k)) < y,	i : ι,	him : (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).nonempty,	y' : ℤ := (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	y'_def : y' = (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	k : ι	⊢ ⇑abv (⇑(⇑(bS.repr) a) k) ≤ y'
R : Type u_1,	S : Type u_2,	_inst_1 : euclidean_domain R,	_inst_2 : integral_domain S,	_inst_11 : algebra R S,	abv : absolute_value R ℤ,	ι : Type u_5,	_inst_13 : decidable_eq ι,	_inst_14 : fintype ι,	bS : basis ι R S,	T : Type u_3,	_inst_15 : linear_ordered_comm_ring T,	a : S,	y : T,	hy : ∀ (k : ι), ↑(⇑abv (⇑(⇑(bS.repr) a) k)) < y,	i : ι,	him : (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).nonempty,	y' : ℤ := (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	y'_def : y' = (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him	⊢ ∀ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k) ≤ y'		R : Type u_1,	S : Type u_2,	_inst_1 : euclidean_domain R,	_inst_2 : integral_domain S,	_inst_11 : algebra R S,	abv : absolute_value R ℤ,	ι : Type u_5,	_inst_13 : decidable_eq ι,	_inst_14 : fintype ι,	bS : basis ι R S,	T : Type u_3,	_inst_15 : linear_ordered_comm_ring T,	a : S,	y : T,	hy : ∀ (k : ι), ↑(⇑abv (⇑(⇑(bS.repr) a) k)) < y,	i : ι,	him : (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).nonempty,	y' : ℤ := (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	y'_def : y' = (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	hy' : ∀ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k) ≤ y'	⊢ ↑(⇑abv (⇑(algebra.norm R) a)) < ↑(class_group.norm_bound abv bS) * y ^ fintype.card ι
R : Type u_1,	S : Type u_2,	_inst_1 : euclidean_domain R,	_inst_2 : integral_domain S,	_inst_11 : algebra R S,	abv : absolute_value R ℤ,	ι : Type u_5,	_inst_13 : decidable_eq ι,	_inst_14 : fintype ι,	bS : basis ι R S,	T : Type u_3,	_inst_15 : linear_ordered_comm_ring T,	a : S,	y : T,	hy : ∀ (k : ι), ↑(⇑abv (⇑(⇑(bS.repr) a) k)) < y,	i : ι,	him : (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).nonempty,	y' : ℤ := (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	y'_def : y' = (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	hy' : ∀ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k) ≤ y'	⊢ ↑(⇑abv (⇑(algebra.norm R) a)) < ↑(class_group.norm_bound abv bS) * y ^ fintype.card ι
R : Type u_1,	S : Type u_2,	_inst_1 : euclidean_domain R,	_inst_2 : integral_domain S,	_inst_11 : algebra R S,	abv : absolute_value R ℤ,	ι : Type u_5,	_inst_13 : decidable_eq ι,	_inst_14 : fintype ι,	bS : basis ι R S,	T : Type u_3,	_inst_15 : linear_ordered_comm_ring T,	a : S,	y : T,	hy : ∀ (k : ι), ↑(⇑abv (⇑(⇑(bS.repr) a) k)) < y,	i : ι,	him : (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).nonempty,	y' : ℤ := (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	y'_def : y' = (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	hy' : ∀ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k) ≤ y'	⊢ ↑y' < y
R : Type u_1,	S : Type u_2,	_inst_1 : euclidean_domain R,	_inst_2 : integral_domain S,	_inst_11 : algebra R S,	abv : absolute_value R ℤ,	ι : Type u_5,	_inst_13 : decidable_eq ι,	_inst_14 : fintype ι,	bS : basis ι R S,	T : Type u_3,	_inst_15 : linear_ordered_comm_ring T,	a : S,	y : T,	hy : ∀ (k : ι), ↑(⇑abv (⇑(⇑(bS.repr) a) k)) < y,	i : ι,	him : (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).nonempty,	y' : ℤ := (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	y'_def : y' = (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	hy' : ∀ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k) ≤ y'	⊢ (finset.image coe (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ)).max' ?m_1 < y		R : Type u_1,	S : Type u_2,	_inst_1 : euclidean_domain R,	_inst_2 : integral_domain S,	_inst_11 : algebra R S,	abv : absolute_value R ℤ,	ι : Type u_5,	_inst_13 : decidable_eq ι,	_inst_14 : fintype ι,	bS : basis ι R S,	T : Type u_3,	_inst_15 : linear_ordered_comm_ring T,	a : S,	y : T,	hy : ∀ (k : ι), ↑(⇑abv (⇑(⇑(bS.repr) a) k)) < y,	i : ι,	him : (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).nonempty,	y' : ℤ := (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	y'_def : y' = (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	hy' : ∀ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k) ≤ y'	⊢ (finset.image coe (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ)).nonempty
R : Type u_1,	S : Type u_2,	_inst_1 : euclidean_domain R,	_inst_2 : integral_domain S,	_inst_11 : algebra R S,	abv : absolute_value R ℤ,	ι : Type u_5,	_inst_13 : decidable_eq ι,	_inst_14 : fintype ι,	bS : basis ι R S,	T : Type u_3,	_inst_15 : linear_ordered_comm_ring T,	a : S,	y : T,	hy : ∀ (k : ι), ↑(⇑abv (⇑(⇑(bS.repr) a) k)) < y,	i : ι,	him : (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).nonempty,	y' : ℤ := (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	y'_def : y' = (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	hy' : ∀ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k) ≤ y'	⊢ ∀ (y_1 : T), y_1 ∈ finset.image coe (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ) → y_1 < y
R : Type u_1,	S : Type u_2,	_inst_1 : euclidean_domain R,	_inst_2 : integral_domain S,	_inst_11 : algebra R S,	abv : absolute_value R ℤ,	ι : Type u_5,	_inst_13 : decidable_eq ι,	_inst_14 : fintype ι,	bS : basis ι R S,	T : Type u_3,	_inst_15 : linear_ordered_comm_ring T,	a : S,	y : T,	hy : ∀ (k : ι), ↑(⇑abv (⇑(⇑(bS.repr) a) k)) < y,	i : ι,	him : (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).nonempty,	y' : ℤ := (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	y'_def : y' = (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	hy' : ∀ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k) ≤ y'	⊢ ∀ (y_1 : T), (∃ (a_1 : ℤ), (∃ (a_2 : ι), a_2 ∈ finset.univ ∧ ⇑abv (⇑(⇑(bS.repr) a) a_2) = a_1) ∧ ↑a_1 = y_1) → y_1 < y
R : Type u_1,	S : Type u_2,	_inst_1 : euclidean_domain R,	_inst_2 : integral_domain S,	_inst_11 : algebra R S,	abv : absolute_value R ℤ,	ι : Type u_5,	_inst_13 : decidable_eq ι,	_inst_14 : fintype ι,	bS : basis ι R S,	T : Type u_3,	_inst_15 : linear_ordered_comm_ring T,	a : S,	y : T,	hy : ∀ (k : ι), ↑(⇑abv (⇑(⇑(bS.repr) a) k)) < y,	i : ι,	him : (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).nonempty,	y' : ℤ := (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	y'_def : y' = (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	hy' : ∀ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k) ≤ y'	⊢ ↑y' < y		R : Type u_1,	S : Type u_2,	_inst_1 : euclidean_domain R,	_inst_2 : integral_domain S,	_inst_11 : algebra R S,	abv : absolute_value R ℤ,	ι : Type u_5,	_inst_13 : decidable_eq ι,	_inst_14 : fintype ι,	bS : basis ι R S,	T : Type u_3,	_inst_15 : linear_ordered_comm_ring T,	a : S,	y : T,	hy : ∀ (k : ι), ↑(⇑abv (⇑(⇑(bS.repr) a) k)) < y,	i : ι,	him : (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).nonempty,	y' : ℤ := (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	y'_def : y' = (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	hy' : ∀ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k) ≤ y',	this : ↑y' < y	⊢ ↑(⇑abv (⇑(algebra.norm R) a)) < ↑(class_group.norm_bound abv bS) * y ^ fintype.card ι
R : Type u_1,	S : Type u_2,	_inst_1 : euclidean_domain R,	_inst_2 : integral_domain S,	_inst_11 : algebra R S,	abv : absolute_value R ℤ,	ι : Type u_5,	_inst_13 : decidable_eq ι,	_inst_14 : fintype ι,	bS : basis ι R S,	T : Type u_3,	_inst_15 : linear_ordered_comm_ring T,	a : S,	y : T,	hy : ∀ (k : ι), ↑(⇑abv (⇑(⇑(bS.repr) a) k)) < y,	i : ι,	him : (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).nonempty,	y' : ℤ := (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	y'_def : y' = (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	hy' : ∀ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k) ≤ y',	k : ι	⊢ ↑(⇑abv (⇑(⇑(bS.repr) a) k)) < y
R : Type u_1,	S : Type u_2,	_inst_1 : euclidean_domain R,	_inst_2 : integral_domain S,	_inst_11 : algebra R S,	abv : absolute_value R ℤ,	ι : Type u_5,	_inst_13 : decidable_eq ι,	_inst_14 : fintype ι,	bS : basis ι R S,	T : Type u_3,	_inst_15 : linear_ordered_comm_ring T,	a : S,	y : T,	hy : ∀ (k : ι), ↑(⇑abv (⇑(⇑(bS.repr) a) k)) < y,	i : ι,	him : (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).nonempty,	y' : ℤ := (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	y'_def : y' = (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	hy' : ∀ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k) ≤ y',	this : ↑y' < y	⊢ ↑(⇑abv (⇑(algebra.norm R) a)) < ↑(class_group.norm_bound abv bS) * y ^ fintype.card ι
R : Type u_1,	S : Type u_2,	_inst_1 : euclidean_domain R,	_inst_2 : integral_domain S,	_inst_11 : algebra R S,	abv : absolute_value R ℤ,	ι : Type u_5,	_inst_13 : decidable_eq ι,	_inst_14 : fintype ι,	bS : basis ι R S,	T : Type u_3,	_inst_15 : linear_ordered_comm_ring T,	a : S,	y : T,	hy : ∀ (k : ι), ↑(⇑abv (⇑(⇑(bS.repr) a) k)) < y,	i : ι,	him : (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).nonempty,	y' : ℤ := (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	y'_def : y' = (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	hy' : ∀ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k) ≤ y',	this : ↑y' < y,	y'_nonneg : 0 ≤ y'	⊢ ↑(⇑abv (⇑(algebra.norm R) a)) < ↑(class_group.norm_bound abv bS) * y ^ fintype.card ι
R : Type u_1,	S : Type u_2,	_inst_1 : euclidean_domain R,	_inst_2 : integral_domain S,	_inst_11 : algebra R S,	abv : absolute_value R ℤ,	ι : Type u_5,	_inst_13 : decidable_eq ι,	_inst_14 : fintype ι,	bS : basis ι R S,	T : Type u_3,	_inst_15 : linear_ordered_comm_ring T,	a : S,	y : T,	hy : ∀ (k : ι), ↑(⇑abv (⇑(⇑(bS.repr) a) k)) < y,	i : ι,	him : (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).nonempty,	y' : ℤ := (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	y'_def : y' = (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	hy' : ∀ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k) ≤ y',	this : ↑y' < y,	y'_nonneg : 0 ≤ y'	⊢ ↑(class_group.norm_bound abv bS * y' ^ fintype.card ι) < ↑(class_group.norm_bound abv bS) * y ^ fintype.card ι		R : Type u_1,	S : Type u_2,	_inst_1 : euclidean_domain R,	_inst_2 : integral_domain S,	_inst_11 : algebra R S,	abv : absolute_value R ℤ,	ι : Type u_5,	_inst_13 : decidable_eq ι,	_inst_14 : fintype ι,	bS : basis ι R S,	T : Type u_3,	_inst_15 : linear_ordered_comm_ring T,	a : S,	y : T,	hy : ∀ (k : ι), ↑(⇑abv (⇑(⇑(bS.repr) a) k)) < y,	i : ι,	him : (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).nonempty,	y' : ℤ := (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	y'_def : y' = (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	hy' : ∀ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k) ≤ y',	this : ↑y' < y,	y'_nonneg : 0 ≤ y'	⊢ nontrivial T
R : Type u_1,	S : Type u_2,	_inst_1 : euclidean_domain R,	_inst_2 : integral_domain S,	_inst_11 : algebra R S,	abv : absolute_value R ℤ,	ι : Type u_5,	_inst_13 : decidable_eq ι,	_inst_14 : fintype ι,	bS : basis ι R S,	T : Type u_3,	_inst_15 : linear_ordered_comm_ring T,	a : S,	y : T,	hy : ∀ (k : ι), ↑(⇑abv (⇑(⇑(bS.repr) a) k)) < y,	i : ι,	him : (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).nonempty,	y' : ℤ := (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	y'_def : y' = (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	hy' : ∀ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k) ≤ y',	this : ↑y' < y,	y'_nonneg : 0 ≤ y'	⊢ ↑(class_group.norm_bound abv bS) * ↑y' ^ fintype.card ι < ↑(class_group.norm_bound abv bS) * y ^ fintype.card ι		R : Type u_1,	S : Type u_2,	_inst_1 : euclidean_domain R,	_inst_2 : integral_domain S,	_inst_11 : algebra R S,	abv : absolute_value R ℤ,	ι : Type u_5,	_inst_13 : decidable_eq ι,	_inst_14 : fintype ι,	bS : basis ι R S,	T : Type u_3,	_inst_15 : linear_ordered_comm_ring T,	a : S,	y : T,	hy : ∀ (k : ι), ↑(⇑abv (⇑(⇑(bS.repr) a) k)) < y,	i : ι,	him : (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).nonempty,	y' : ℤ := (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	y'_def : y' = (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	hy' : ∀ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k) ≤ y',	this : ↑y' < y,	y'_nonneg : 0 ≤ y'	⊢ nontrivial T
R : Type u_1,	S : Type u_2,	_inst_1 : euclidean_domain R,	_inst_2 : integral_domain S,	_inst_11 : algebra R S,	abv : absolute_value R ℤ,	ι : Type u_5,	_inst_13 : decidable_eq ι,	_inst_14 : fintype ι,	bS : basis ι R S,	T : Type u_3,	_inst_15 : linear_ordered_comm_ring T,	a : S,	y : T,	hy : ∀ (k : ι), ↑(⇑abv (⇑(⇑(bS.repr) a) k)) < y,	i : ι,	him : (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).nonempty,	y' : ℤ := (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	y'_def : y' = (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	hy' : ∀ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k) ≤ y',	this : ↑y' < y,	y'_nonneg : 0 ≤ y'	⊢ ↑y' ^ fintype.card ι < y ^ fintype.card ι
R : Type u_1,	S : Type u_2,	_inst_1 : euclidean_domain R,	_inst_2 : integral_domain S,	_inst_11 : algebra R S,	abv : absolute_value R ℤ,	ι : Type u_5,	_inst_13 : decidable_eq ι,	_inst_14 : fintype ι,	bS : basis ι R S,	T : Type u_3,	_inst_15 : linear_ordered_comm_ring T,	a : S,	y : T,	hy : ∀ (k : ι), ↑(⇑abv (⇑(⇑(bS.repr) a) k)) < y,	i : ι,	him : (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).nonempty,	y' : ℤ := (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	y'_def : y' = (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	hy' : ∀ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k) ≤ y',	this : ↑y' < y,	y'_nonneg : 0 ≤ y'	⊢ ↑y' ^ fintype.card ι < y ^ fintype.card ι		R : Type u_1,	S : Type u_2,	_inst_1 : euclidean_domain R,	_inst_2 : integral_domain S,	_inst_11 : algebra R S,	abv : absolute_value R ℤ,	ι : Type u_5,	_inst_13 : decidable_eq ι,	_inst_14 : fintype ι,	bS : basis ι R S,	T : Type u_3,	_inst_15 : linear_ordered_comm_ring T,	a : S,	y : T,	hy : ∀ (k : ι), ↑(⇑abv (⇑(⇑(bS.repr) a) k)) < y,	i : ι,	him : (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).nonempty,	y' : ℤ := (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	y'_def : y' = (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	hy' : ∀ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k) ≤ y',	this : ↑y' < y,	y'_nonneg : 0 ≤ y'	⊢ 0 ≤ ↑y' ^ fintype.card ι		R : Type u_1,	S : Type u_2,	_inst_1 : euclidean_domain R,	_inst_2 : integral_domain S,	_inst_11 : algebra R S,	abv : absolute_value R ℤ,	ι : Type u_5,	_inst_13 : decidable_eq ι,	_inst_14 : fintype ι,	bS : basis ι R S,	T : Type u_3,	_inst_15 : linear_ordered_comm_ring T,	a : S,	y : T,	hy : ∀ (k : ι), ↑(⇑abv (⇑(⇑(bS.repr) a) k)) < y,	i : ι,	him : (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).nonempty,	y' : ℤ := (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	y'_def : y' = (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	hy' : ∀ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k) ≤ y',	this : ↑y' < y,	y'_nonneg : 0 ≤ y'	⊢ 0 < ↑(class_group.norm_bound abv bS)		R : Type u_1,	S : Type u_2,	_inst_1 : euclidean_domain R,	_inst_2 : integral_domain S,	_inst_11 : algebra R S,	abv : absolute_value R ℤ,	ι : Type u_5,	_inst_13 : decidable_eq ι,	_inst_14 : fintype ι,	bS : basis ι R S,	T : Type u_3,	_inst_15 : linear_ordered_comm_ring T,	a : S,	y : T,	hy : ∀ (k : ι), ↑(⇑abv (⇑(⇑(bS.repr) a) k)) < y,	i : ι,	him : (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).nonempty,	y' : ℤ := (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	y'_def : y' = (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	hy' : ∀ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k) ≤ y',	this : ↑y' < y,	y'_nonneg : 0 ≤ y'	⊢ nontrivial T
R : Type u_1,	S : Type u_2,	_inst_1 : euclidean_domain R,	_inst_2 : integral_domain S,	_inst_11 : algebra R S,	abv : absolute_value R ℤ,	ι : Type u_5,	_inst_13 : decidable_eq ι,	_inst_14 : fintype ι,	bS : basis ι R S,	T : Type u_3,	_inst_15 : linear_ordered_comm_ring T,	a : S,	y : T,	hy : ∀ (k : ι), ↑(⇑abv (⇑(⇑(bS.repr) a) k)) < y,	i : ι,	him : (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).nonempty,	y' : ℤ := (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	y'_def : y' = (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	hy' : ∀ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k) ≤ y',	this : ↑y' < y,	y'_nonneg : 0 ≤ y'	⊢ 0 ≤ ↑y' ^ fintype.card ι		R : Type u_1,	S : Type u_2,	_inst_1 : euclidean_domain R,	_inst_2 : integral_domain S,	_inst_11 : algebra R S,	abv : absolute_value R ℤ,	ι : Type u_5,	_inst_13 : decidable_eq ι,	_inst_14 : fintype ι,	bS : basis ι R S,	T : Type u_3,	_inst_15 : linear_ordered_comm_ring T,	a : S,	y : T,	hy : ∀ (k : ι), ↑(⇑abv (⇑(⇑(bS.repr) a) k)) < y,	i : ι,	him : (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).nonempty,	y' : ℤ := (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	y'_def : y' = (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	hy' : ∀ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k) ≤ y',	this : ↑y' < y,	y'_nonneg : 0 ≤ y'	⊢ 0 < ↑(class_group.norm_bound abv bS)		R : Type u_1,	S : Type u_2,	_inst_1 : euclidean_domain R,	_inst_2 : integral_domain S,	_inst_11 : algebra R S,	abv : absolute_value R ℤ,	ι : Type u_5,	_inst_13 : decidable_eq ι,	_inst_14 : fintype ι,	bS : basis ι R S,	T : Type u_3,	_inst_15 : linear_ordered_comm_ring T,	a : S,	y : T,	hy : ∀ (k : ι), ↑(⇑abv (⇑(⇑(bS.repr) a) k)) < y,	i : ι,	him : (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).nonempty,	y' : ℤ := (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	y'_def : y' = (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	hy' : ∀ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k) ≤ y',	this : ↑y' < y,	y'_nonneg : 0 ≤ y'	⊢ nontrivial T
R : Type u_1,	S : Type u_2,	_inst_1 : euclidean_domain R,	_inst_2 : integral_domain S,	_inst_11 : algebra R S,	abv : absolute_value R ℤ,	ι : Type u_5,	_inst_13 : decidable_eq ι,	_inst_14 : fintype ι,	bS : basis ι R S,	T : Type u_3,	_inst_15 : linear_ordered_comm_ring T,	a : S,	y : T,	hy : ∀ (k : ι), ↑(⇑abv (⇑(⇑(bS.repr) a) k)) < y,	i : ι,	him : (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).nonempty,	y' : ℤ := (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	y'_def : y' = (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	hy' : ∀ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k) ≤ y',	this : ↑y' < y,	y'_nonneg : 0 ≤ y'	⊢ 0 ≤ ↑y' ^ fintype.card ι
R : Type u_1,	S : Type u_2,	_inst_1 : euclidean_domain R,	_inst_2 : integral_domain S,	_inst_11 : algebra R S,	abv : absolute_value R ℤ,	ι : Type u_5,	_inst_13 : decidable_eq ι,	_inst_14 : fintype ι,	bS : basis ι R S,	T : Type u_3,	_inst_15 : linear_ordered_comm_ring T,	a : S,	y : T,	hy : ∀ (k : ι), ↑(⇑abv (⇑(⇑(bS.repr) a) k)) < y,	i : ι,	him : (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).nonempty,	y' : ℤ := (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	y'_def : y' = (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	hy' : ∀ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k) ≤ y',	this : ↑y' < y,	y'_nonneg : 0 ≤ y'	⊢ 0 < ↑(class_group.norm_bound abv bS)		R : Type u_1,	S : Type u_2,	_inst_1 : euclidean_domain R,	_inst_2 : integral_domain S,	_inst_11 : algebra R S,	abv : absolute_value R ℤ,	ι : Type u_5,	_inst_13 : decidable_eq ι,	_inst_14 : fintype ι,	bS : basis ι R S,	T : Type u_3,	_inst_15 : linear_ordered_comm_ring T,	a : S,	y : T,	hy : ∀ (k : ι), ↑(⇑abv (⇑(⇑(bS.repr) a) k)) < y,	i : ι,	him : (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).nonempty,	y' : ℤ := (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	y'_def : y' = (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	hy' : ∀ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k) ≤ y',	this : ↑y' < y,	y'_nonneg : 0 ≤ y'	⊢ nontrivial T
R : Type u_1,	S : Type u_2,	_inst_1 : euclidean_domain R,	_inst_2 : integral_domain S,	_inst_11 : algebra R S,	abv : absolute_value R ℤ,	ι : Type u_5,	_inst_13 : decidable_eq ι,	_inst_14 : fintype ι,	bS : basis ι R S,	T : Type u_3,	_inst_15 : linear_ordered_comm_ring T,	a : S,	y : T,	hy : ∀ (k : ι), ↑(⇑abv (⇑(⇑(bS.repr) a) k)) < y,	i : ι,	him : (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).nonempty,	y' : ℤ := (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	y'_def : y' = (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	hy' : ∀ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k) ≤ y',	this : ↑y' < y,	y'_nonneg : 0 ≤ y'	⊢ 0 < ↑(class_group.norm_bound abv bS)
R : Type u_1,	S : Type u_2,	_inst_1 : euclidean_domain R,	_inst_2 : integral_domain S,	_inst_11 : algebra R S,	abv : absolute_value R ℤ,	ι : Type u_5,	_inst_13 : decidable_eq ι,	_inst_14 : fintype ι,	bS : basis ι R S,	T : Type u_3,	_inst_15 : linear_ordered_comm_ring T,	a : S,	y : T,	hy : ∀ (k : ι), ↑(⇑abv (⇑(⇑(bS.repr) a) k)) < y,	i : ι,	him : (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).nonempty,	y' : ℤ := (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	y'_def : y' = (finset.image (λ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k)) finset.univ).max' him,	hy' : ∀ (k : ι), ⇑abv (⇑(⇑(bS.repr) a) k) ≤ y',	this : ↑y' < y,	y'_nonneg : 0 ≤ y'	⊢ nontrivial T
R : Type u_1,	S : Type u_2,	_inst_1 : euclidean_domain R,	_inst_2 : integral_domain S,	_inst_11 : algebra R S,	abv : absolute_value R ℤ,	ι : Type u_5,	_inst_13 : decidable_eq ι,	_inst_14 : fintype ι,	bS : basis ι R S,	T : Type u_3,	_inst_15 : linear_ordered_comm_ring T,	a : S,	y : T,	hy : ∀ (k : ι), ↑(⇑abv (⇑(⇑(bS.repr) a) k)) < y	⊢ ↑(⇑abv (⇑(algebra.norm R) a)) < ↑(class_group.norm_bound abv bS) * y ^ fintype.card ι
R : Type u_1,	S : Type u_2,	_inst_1 : euclidean_domain R,	_inst_2 : integral_domain S,	_inst_11 : algebra R S,	abv : absolute_value R ℤ,	ι : Type u_5,	_inst_13 : decidable_eq ι,	_inst_14 : fintype ι,	bS : basis ι R S,	T : Type u_3,	_inst_15 : linear_ordered_comm_ring T,	a : S,	y : T,	hy : ∀ (k : ι), ↑(⇑abv (⇑(⇑(bS.repr) a) k)) < y,	i : ι	⊢ ↑(⇑abv (⇑(algebra.norm R) a)) < ↑(class_group.norm_bound abv bS) * y ^ fintype.card ι
α : Type u_1,	β : Sort u_2,	v : option α → β,	o : option α	⊢ (v option.none::v ∘ option.some) o = v o
α : Type u_1,	β : Sort u_2,	v : option α → β,	o : option α	⊢ (v option.none::v ∘ option.some) o = v o
α : Type u_1,	β : Sort u_2,	v : option α → β	⊢ (v option.none::v ∘ option.some) option.none = v option.none
α : Type u_1,	β : Sort u_2,	v : option α → β,	o : α	⊢ (v option.none::v ∘ option.some) (option.some o) = v (option.some o)
α : Type,	f g : (α → ℕ) → ℕ,	df : dioph.dioph_fn f,	dg : dioph.dioph_fn g	⊢ vector_allp dioph.dioph_fn [f, g]
n m : ℕ,	hzero : n ≠ 0,	h : m ∣ n,	hdiff : m ≠ n	⊢ m.divisors ⊆ n.proper_divisors
n m : ℕ,	hzero : n ≠ 0,	h : m ∣ n,	hdiff : m ≠ n	⊢ ∀ ⦃x : ℕ⦄, x ∈ m.divisors → x ∈ n.proper_divisors
n m : ℕ,	hzero : n ≠ 0,	h : m ∣ n,	hdiff : m ≠ n,	x : ℕ,	hx : x ∈ m.divisors	⊢ x ∈ n.proper_divisors
⊢ 0.divisors_antidiagonal = ∅
a : ℕ × ℕ	⊢ a ∈ 0.divisors_antidiagonal ↔ a ∈ ∅
⊢ 1 < 5
⊢ 1 < 7
⊢ lucas_lehmer.lucas_lehmer_test 7
p : ℕ,	hp_prime : fact (nat.prime p),	x : ℤ_[p]	⊢ 0 ≤ x.valuation
p : ℕ,	hp_prime : fact (nat.prime p),	x : ℤ_[p],	hx : x = 0	⊢ 0 ≤ x.valuation		p : ℕ,	hp_prime : fact (nat.prime p),	x : ℤ_[p],	hx : ¬x = 0	⊢ 0 ≤ x.valuation
p : ℕ,	hp_prime : fact (nat.prime p),	x : ℤ_[p],	hx : x = 0	⊢ 0 ≤ x.valuation
p : ℕ,	hp_prime : fact (nat.prime p),	x : ℤ_[p],	hx : ¬x = 0	⊢ 1 < ↑p
p : ℕ,	hp_prime : fact (nat.prime p),	x : ℤ_[p],	hx : ¬x = 0	⊢ 0 ≤ x.valuation
p : ℕ,	hp_prime : fact (nat.prime p),	x : ℤ_[p],	hx : ¬x = 0,	h : 1 < ↑p	⊢ 0 ≤ x.valuation
p : ℕ,	hp_prime : fact (nat.prime p),	x : ℤ_[p],	hx : ¬x = 0,	h : 1 < ↑p	⊢ (λ (n : ℤ), ↑p ^ n) (-x.valuation) ≤ (λ (n : ℤ), ↑p ^ n) 0
p : ℕ,	hp_prime : fact (nat.prime p),	x : ℤ_[p],	hx : ¬x = 0,	h : 1 < ↑p	⊢ ↑p ^ -x.valuation ≤ ↑p ^ 0
p : ℕ,	hp_prime : fact (nat.prime p),	x : ℤ_[p],	hx : ¬x = 0,	h : 1 < ↑p	⊢ ∥x∥ ≤ ↑p ^ 0
p : ℕ,	hp_prime : fact (nat.prime p),	mul_inv : ∀ {z : ℤ_[p]}, ∥z∥ = 1 → z * z.inv = 1,	k : ℚ_[p],	_x : ∥k∥ ≤ 1,	h : ∥⟨k, _x⟩∥ = 1	⊢ k ≠ 0		p : ℕ,	hp_prime : fact (nat.prime p),	mul_inv : ∀ {z : ℤ_[p]}, ∥z∥ = 1 → z * z.inv = 1,	k : ℚ_[p],	_x : ∥k∥ ≤ 1,	h : ∥⟨k, _x⟩∥ = 1,	hk : k ≠ 0	⊢ ⟨k, _x⟩ * padic_int.inv ⟨k, _x⟩ = 1
p : ℕ,	hp_prime : fact (nat.prime p),	mul_inv : ∀ {z : ℤ_[p]}, ∥z∥ = 1 → z * z.inv = 1,	k : ℚ_[p],	_x : ∥k∥ ≤ 1,	h : ∥⟨k, _x⟩∥ = 1	⊢ ⟨k, _x⟩ * padic_int.inv ⟨k, _x⟩ = 1
p : ℕ,	hp_prime : fact (nat.prime p),	mul_inv : ∀ {z : ℤ_[p]}, ∥z∥ = 1 → z * z.inv = 1,	k : ℚ_[p],	_x : ∥k∥ ≤ 1,	h : ∥⟨k, _x⟩∥ = 1,	h' : k = 0	⊢ 0 = 1
p : ℕ,	hp_prime : fact (nat.prime p),	mul_inv : ∀ {z : ℤ_[p]}, ∥z∥ = 1 → z * z.inv = 1,	k : ℚ_[p],	_x : ∥k∥ ≤ 1,	h : ∥⟨k, _x⟩∥ = 1,	hk : k ≠ 0	⊢ ⟨k, _x⟩ * dite (∥k∥ = 1) (λ (h : ∥k∥ = 1), ⟨1 / k, _⟩) (λ (h : ¬∥k∥ = 1), 0) = 1
p : ℕ,	hp_prime : fact (nat.prime p),	mul_inv : ∀ {z : ℤ_[p]}, ∥z∥ = 1 → z * z.inv = 1,	k : ℚ_[p],	_x : ∥k∥ ≤ 1,	h : ∥⟨k, _x⟩∥ = 1,	hk : k ≠ 0	⊢ ⟨k, _x⟩ * padic_int.inv ⟨k, _x⟩ = 1
p : ℕ,	hp_prime : fact (nat.prime p),	mul_inv : ∀ {z : ℤ_[p]}, ∥z∥ = 1 → z * z.inv = 1,	k : ℚ_[p],	_x : ∥k∥ ≤ 1,	h : ∥⟨k, _x⟩∥ = 1,	hk : k ≠ 0,	h_1 : ∥k∥ = 1	⊢ ⟨k, _x⟩ * ⟨1 / k, _⟩ = 1
p : ℕ,	hp_prime : fact (nat.prime p),	mul_inv : ∀ {z : ℤ_[p]}, ∥z∥ = 1 → z * z.inv = 1,	k : ℚ_[p],	_x : ∥k∥ ≤ 1,	h : ∥⟨k, _x⟩∥ = 1,	hk : k ≠ 0,	h_1 : ∥k∥ = 1	⊢ ⟨1, _⟩ = 1
p : ℕ,	hp_prime : fact (nat.prime p),	mul_inv : ∀ {z : ℤ_[p]}, ∥z∥ = 1 → z * z.inv = 1,	k : ℚ_[p],	_x : ∥k∥ ≤ 1,	h : ∥⟨k, _x⟩∥ = 1,	hk : k ≠ 0,	h_1 : ∥k∥ = 1	⊢ ⟨k, _x⟩ * ⟨1 / k, _⟩ = 1		p : ℕ,	hp_prime : fact (nat.prime p),	mul_inv : ∀ {z : ℤ_[p]}, ∥z∥ = 1 → z * z.inv = 1,	k : ℚ_[p],	_x : ∥k∥ ≤ 1,	h : ∥⟨k, _x⟩∥ = 1,	hk : k ≠ 0,	h_1 : ¬∥k∥ = 1	⊢ ⟨k, _x⟩ * ⟨1 / k, _⟩ = 1
p : ℕ,	hp_prime : fact (nat.prime p),	mul_inv : ∀ {z : ℤ_[p]}, ∥z∥ = 1 → z * z.inv = 1,	k : ℚ_[p],	_x : ∥k∥ ≤ 1,	h : ∥⟨k, _x⟩∥ = 1,	hk : k ≠ 0,	h_1 : ∥k∥ = 1	⊢ ⟨k * (1 / k), _⟩ = 1
p : ℕ,	hp_prime : fact (nat.prime p),	mul_inv : ∀ {z : ℤ_[p]}, ∥z∥ = 1 → z * z.inv = 1,	k : ℚ_[p],	_x : ∥k∥ ≤ 1,	h : ∥⟨k, _x⟩∥ = 1,	hk : k ≠ 0,	h_1 : ¬∥k∥ = 1	⊢ (⟨k, _x⟩ * ⟨1 / k, _⟩).val = 1.val
p : ℕ,	hp_prime : fact (nat.prime p),	mul_inv : ∀ {z : ℤ_[p]}, ∥z∥ = 1 → z * z.inv = 1,	k : ℚ_[p],	_x : ∥k∥ ≤ 1,	h : ∥⟨k, _x⟩∥ = 1,	hk : k ≠ 0,	h_1 : ¬∥k∥ = 1	⊢ ⟨k, _x⟩ * ⟨1 / k, _⟩ = 1
p : ℕ,	q : ℚ,	hq : q = 0	⊢ 0 ≤ padic_norm p q
p : ℕ,	q : ℚ,	hq : ¬q = 0	⊢ 0 ≤ padic_norm p q
p : ℕ,	q : ℚ,	hq : ¬q = 0	⊢ 0 ≤ ite (q = 0) 0 (↑p ^ -padic_val_rat p q)
p : ℕ,	q : ℚ,	hq : ¬q = 0	⊢ 0 ≤ padic_norm p q
p : ℕ,	q : ℚ,	hq : ¬q = 0	⊢ 0 ≤ ↑p ^ -padic_val_rat p q
p : ℕ,	q : ℚ,	hq : ¬q = 0	⊢ 0 ≤ ↑p
p : ℕ	⊢ padic_norm p 1 = 1
p : ℕ,	q : ℚ,	hq : q ≠ 0	⊢ padic_norm p q = ↑p ^ -padic_val_rat p q
p : ℕ,	_inst_1 : fact (nat.prime p),	f : padic_seq p,	hf : f ≈ 0	⊢ 0 ≤ f.norm
p : ℕ,	_inst_1 : fact (nat.prime p),	f : padic_seq p,	hf : ¬f ≈ 0	⊢ 0 ≤ f.norm
p : ℕ,	hp : fact (nat.prime p),	f g : padic_seq p,	hfg : f + g ≈ 0,	this : 0 ≤ linear_order.max f.norm g.norm	⊢ (f + g).norm ≤ linear_order.max f.norm g.norm
p : ℕ,	hp : fact (nat.prime p),	f g : padic_seq p,	hfg : ¬f + g ≈ 0,	hf : f ≈ 0	⊢ f + g ≈ g
p : ℕ,	hp : fact (nat.prime p),	f g : padic_seq p,	hfg : ¬f + g ≈ 0,	hf : (f - 0).lim_zero	⊢ (f + g - g).lim_zero
p : ℕ,	hp : fact (nat.prime p),	f g : padic_seq p,	hfg : ¬f + g ≈ 0,	hf : (f - 0).lim_zero	⊢ f + g ≈ g
p : ℕ,	hp : fact (nat.prime p),	f g : padic_seq p,	hfg : ¬f + g ≈ 0,	hf : f ≈ 0,	hfg' : f + g ≈ g,	hcfg : (f + g).norm = g.norm,	hcl : f.norm = 0	⊢ linear_order.max f.norm g.norm = g.norm
p : ℕ,	hp : fact (nat.prime p),	f g : padic_seq p,	hfg : ¬f + g ≈ 0,	hf : f ≈ 0,	hfg' : f + g ≈ g,	hcfg : (f + g).norm = g.norm,	hcl : f.norm = 0	⊢ linear_order.max 0 g.norm = g.norm
p : ℕ,	hp : fact (nat.prime p),	f g : padic_seq p,	hfg : ¬f + g ≈ 0,	hf : f ≈ 0,	hfg' : f + g ≈ g,	hcfg : (f + g).norm = g.norm,	hcl : f.norm = 0	⊢ linear_order.max f.norm g.norm = g.norm
p : ℕ,	hp : fact (nat.prime p),	f g : padic_seq p,	hfg : ¬f + g ≈ 0,	hf : f ≈ 0,	hfg' : f + g ≈ g,	hcfg : (f + g).norm = g.norm,	hcl : f.norm = 0,	this : linear_order.max f.norm g.norm = g.norm	⊢ (f + g).norm ≤ linear_order.max f.norm g.norm
p : ℕ,	hp : fact (nat.prime p),	f g : padic_seq p,	hfg : ¬f + g ≈ 0,	hf : ¬f ≈ 0,	hg : g ≈ 0	⊢ f + g ≈ f
p : ℕ,	hp : fact (nat.prime p),	f g : padic_seq p,	hfg : ¬f + g ≈ 0,	hf : ¬f ≈ 0,	hg : (g - 0).lim_zero	⊢ (f + g - f).lim_zero
p : ℕ,	hp : fact (nat.prime p),	f g : padic_seq p,	hfg : ¬f + g ≈ 0,	hf : ¬f ≈ 0,	hg : (g - 0).lim_zero	⊢ f + g ≈ f
p : ℕ,	hp : fact (nat.prime p),	f g : padic_seq p,	hfg : ¬f + g ≈ 0,	hf : ¬f ≈ 0,	hg : g ≈ 0,	hfg' : f + g ≈ f,	hcfg : (f + g).norm = f.norm,	hcl : g.norm = 0	⊢ linear_order.max f.norm g.norm = f.norm
p : ℕ,	hp : fact (nat.prime p),	f g : padic_seq p,	hfg : ¬f + g ≈ 0,	hf : ¬f ≈ 0,	hg : g ≈ 0,	hfg' : f + g ≈ f,	hcfg : (f + g).norm = f.norm,	hcl : g.norm = 0	⊢ linear_order.max f.norm 0 = f.norm
p : ℕ,	hp : fact (nat.prime p),	f g : padic_seq p,	hfg : ¬f + g ≈ 0,	hf : ¬f ≈ 0,	hg : g ≈ 0,	hfg' : f + g ≈ f,	hcfg : (f + g).norm = f.norm,	hcl : g.norm = 0	⊢ linear_order.max f.norm g.norm = f.norm
p : ℕ,	hp : fact (nat.prime p),	f g : padic_seq p,	hfg : ¬f + g ≈ 0,	hf : ¬f ≈ 0,	hg : g ≈ 0,	hfg' : f + g ≈ f,	hcfg : (f + g).norm = f.norm,	hcl : g.norm = 0,	this : linear_order.max f.norm g.norm = f.norm	⊢ (f + g).norm ≤ linear_order.max f.norm g.norm
p : ℕ,	hp : fact (nat.prime p),	f g : padic_seq p,	hfgne : f.norm ≠ g.norm,	hfg : ¬f + g ≈ 0,	hf : f ≈ 0,	this : (f - 0).lim_zero	⊢ (f + g - g).lim_zero
p : ℕ,	hp : fact (nat.prime p),	f g : padic_seq p,	hfgne : f.norm ≠ g.norm,	hfg : ¬f + g ≈ 0,	hf : f ≈ 0,	this : (f - 0).lim_zero,	this : f + g ≈ g,	h1 : (f + g).norm = g.norm,	h2 : f.norm = 0	⊢ (f + g).norm = linear_order.max f.norm g.norm
p : ℕ,	hp : fact (nat.prime p),	f g : padic_seq p,	hfgne : f.norm ≠ g.norm,	hfg : ¬f + g ≈ 0,	hf : f ≈ 0,	this : (f - 0).lim_zero,	this : f + g ≈ g,	h1 : (f + g).norm = g.norm,	h2 : f.norm = 0	⊢ g.norm = linear_order.max 0 g.norm
p : ℕ,	hp : fact (nat.prime p),	f g : padic_seq p,	hfgne : f.norm ≠ g.norm,	hfg : ¬f + g ≈ 0,	hf : f ≈ 0,	this : (f - 0).lim_zero,	this : f + g ≈ g,	h1 : (f + g).norm = g.norm,	h2 : f.norm = 0	⊢ (f + g).norm = linear_order.max f.norm g.norm
p : ℕ,	hp : fact (nat.prime p),	f g : padic_seq p,	hfgne : f.norm ≠ g.norm,	hfg : ¬f + g ≈ 0,	hf : ¬f ≈ 0,	hg : g ≈ 0,	this : (g - 0).lim_zero	⊢ (f + g - f).lim_zero
p : ℕ,	hp : fact (nat.prime p),	f g : padic_seq p,	hfgne : f.norm ≠ g.norm,	hfg : ¬f + g ≈ 0,	hf : ¬f ≈ 0,	hg : g ≈ 0,	this : (g - 0).lim_zero	⊢ (f + g - f).lim_zero
p : ℕ,	hp : fact (nat.prime p),	f g : padic_seq p,	hfgne : f.norm ≠ g.norm,	hfg : ¬f + g ≈ 0,	hf : ¬f ≈ 0,	hg : g ≈ 0,	this : (g - 0).lim_zero	⊢ cau_seq.lim_zero g
p : ℕ,	hp : fact (nat.prime p),	f g : padic_seq p,	hfgne : f.norm ≠ g.norm,	hfg : ¬f + g ≈ 0,	hf : ¬f ≈ 0,	hg : g ≈ 0,	this : (g - 0).lim_zero,	this : f + g ≈ f,	h1 : (f + g).norm = f.norm,	h2 : g.norm = 0	⊢ (f + g).norm = linear_order.max f.norm g.norm
p : ℕ,	hp : fact (nat.prime p),	f g : padic_seq p,	hfgne : f.norm ≠ g.norm,	hfg : ¬f + g ≈ 0,	hf : ¬f ≈ 0,	hg : g ≈ 0,	this : (g - 0).lim_zero,	this : f + g ≈ f,	h1 : (f + g).norm = f.norm,	h2 : g.norm = 0	⊢ f.norm = linear_order.max f.norm 0
p : ℕ,	hp : fact (nat.prime p),	f g : padic_seq p,	hfgne : f.norm ≠ g.norm,	hfg : ¬f + g ≈ 0,	hf : ¬f ≈ 0,	hg : g ≈ 0,	this : (g - 0).lim_zero,	this : f + g ≈ f,	h1 : (f + g).norm = f.norm,	h2 : g.norm = 0	⊢ (f + g).norm = linear_order.max f.norm g.norm
p : ℕ,	hp : fact (nat.prime p),	f g : padic_seq p,	hfg : ¬f + g ≈ 0,	hf : ¬f ≈ 0,	hg : ¬g ≈ 0,	hfgne : dite (f ≈ 0) (λ (hf : f ≈ 0), 0) (λ (hf : ¬f ≈ 0), padic_norm p (⇑f (padic_seq.stationary_point hf))) ≠ dite (g ≈ 0) (λ (hf : g ≈ 0), 0) (λ (hf : ¬g ≈ 0), padic_norm p (⇑g (padic_seq.stationary_point hf)))	⊢ dite (f + g ≈ 0) (λ (hf : f + g ≈ 0), 0) (λ (hf : ¬f + g ≈ 0), padic_norm p (⇑(f + g) (padic_seq.stationary_point hf))) = linear_order.max (dite (f ≈ 0) (λ (hf : f ≈ 0), 0) (λ (hf : ¬f ≈ 0), padic_norm p (⇑f (padic_seq.stationary_point hf)))) (dite (g ≈ 0) (λ (hf : g ≈ 0), 0) (λ (hf : ¬g ≈ 0), padic_norm p (⇑g (padic_seq.stationary_point hf))))
p : ℕ,	hp : fact (nat.prime p),	f g : padic_seq p,	hfgne : f.norm ≠ g.norm,	hfg : ¬f + g ≈ 0,	hf : ¬f ≈ 0,	hg : ¬g ≈ 0	⊢ (f + g).norm = linear_order.max f.norm g.norm
p : ℕ,	hp : fact (nat.prime p),	f g : padic_seq p,	hfg : ¬f + g ≈ 0,	hf : ¬f ≈ 0,	hg : ¬g ≈ 0,	hfgne : padic_norm p (⇑f (padic_seq.stationary_point hf)) ≠ padic_norm p (⇑g (padic_seq.stationary_point hg))	⊢ padic_norm p (⇑(f + g) (padic_seq.stationary_point hfg)) = linear_order.max (padic_norm p (⇑f (padic_seq.stationary_point hf))) (padic_norm p (⇑g (padic_seq.stationary_point hg)))
p : ℕ,	hp : fact (nat.prime p),	f g : padic_seq p,	hfg : ¬f + g ≈ 0,	hf : ¬f ≈ 0,	hg : ¬g ≈ 0,	hfgne : padic_norm p (⇑f (linear_order.max (padic_seq.stationary_point hfg) (linear_order.max (padic_seq.stationary_point hf) (padic_seq.stationary_point hg)))) ≠ padic_norm p (⇑g (linear_order.max (padic_seq.stationary_point hfg) (linear_order.max (padic_seq.stationary_point hf) (padic_seq.stationary_point hg))))	⊢ padic_norm p (⇑(f + g) (linear_order.max (padic_seq.stationary_point hfg) (linear_order.max (padic_seq.stationary_point hf) (padic_seq.stationary_point hg)))) = linear_order.max (padic_norm p (⇑f (linear_order.max (padic_seq.stationary_point hfg) (linear_order.max (padic_seq.stationary_point hf) (padic_seq.stationary_point hg))))) (padic_norm p (⇑g (linear_order.max (padic_seq.stationary_point hfg) (linear_order.max (padic_seq.stationary_point hf) (padic_seq.stationary_point hg)))))
p : ℕ,	hp : fact (nat.prime p),	q r : ℚ_[p]	⊢ ∥q + r∥ ≤ linear_order.max ∥q∥ ∥r∥
p : ℕ,	hp : fact (nat.prime p),	q r : ℚ_[p]	⊢ ↑(padic_norm_e (q + r)) ≤ linear_order.max ↑(padic_norm_e q) ↑(padic_norm_e r)
p : ℕ,	hp_prime : fact (nat.prime p),	x : ℤ_[p]	⊢ monotone x.appr
p : ℕ,	hp_prime : fact (nat.prime p),	x : ℤ_[p]	⊢ ∀ (n : ℕ), x.appr n ≤ x.appr (n + 1)
p : ℕ,	hp_prime : fact (nat.prime p),	x : ℤ_[p],	n : ℕ	⊢ x.appr n ≤ x.appr (n + 1)
p : ℕ,	hp_prime : fact (nat.prime p),	x : ℤ_[p],	n : ℕ,	h : x - ↑(x.appr n) = 0	⊢ x.appr n ≤ x.appr n
p : ℕ,	hp_prime : fact (nat.prime p),	x : ℤ_[p],	n : ℕ,	h : x - ↑(x.appr n) = 0	⊢ x.appr n ≤ x.appr n		p : ℕ,	hp_prime : fact (nat.prime p),	x : ℤ_[p],	n : ℕ,	h : ¬x - ↑(x.appr n) = 0	⊢ x.appr n ≤ x.appr n + p ^ n * (⇑padic_int.to_zmod (↑(padic_int.unit_coeff h) * ↑p ^ ((x - ↑(x.appr n)).valuation - ↑n).nat_abs)).val
p : ℕ,	hp_prime : fact (nat.prime p),	x : ℤ_[p],	n : ℕ	⊢ x.appr n ≤ dite (x - ↑(x.appr n) = 0) (λ (hy : x - ↑(x.appr n) = 0), x.appr n) (λ (hy : ¬x - ↑(x.appr n) = 0), x.appr n + p ^ n * (⇑padic_int.to_zmod (↑(padic_int.unit_coeff hy) * ↑p ^ ((x - ↑(x.appr n)).valuation - ↑n).nat_abs)).val)
p : ℕ,	hp_prime : fact (nat.prime p),	x : ℤ_[p],	n : ℕ,	h : ¬x - ↑(x.appr n) = 0	⊢ x.appr n ≤ x.appr n + p ^ n * (⇑padic_int.to_zmod (↑(padic_int.unit_coeff h) * ↑p ^ ((x - ↑(x.appr n)).valuation - ↑n).nat_abs)).val
p : ℕ,	hp_prime : fact (nat.prime p),	n : ℕ,	x : ℤ_[p]	⊢ x - ↑(x.appr n) ∈ ideal.span {↑(p ^ n)}
p : ℕ,	hp_prime : fact (nat.prime p),	n : ℕ,	x : ℤ_[p]	⊢ ideal.span {↑(p ^ n)} = ideal.span {↑p ^ n}
p : ℕ,	hp_prime : fact (nat.prime p),	n : ℕ	⊢ ∀ (x : ℤ_[p]), x - ↑(x.appr n) ∈ ideal.span {↑(p ^ n)}
p : ℕ,	hp_prime : fact (nat.prime p),	n : ℕ	⊢ ∀ (x : ℤ_[p]) (a b : ℕ), x - ↑a ∈ ideal.span {↑(p ^ n)} → x - ↑b ∈ ideal.span {↑(p ^ n)} → ↑a = ↑b
p : ℕ,	hp_prime : fact (nat.prime p),	n : ℕ,	x : ℤ_[p],	a b : ℕ,	ha : x - ↑a ∈ ideal.span {↑(p ^ n)},	hb : x - ↑b ∈ ideal.span {↑(p ^ n)}	⊢ ↑a = ↑b
p : ℕ,	hp_prime : fact (nat.prime p),	n : ℕ,	x : ℤ_[p],	a b : ℕ,	ha : x - ↑a ∈ ideal.span {↑(p ^ n)},	hb : x - ↑b ∈ ideal.span {↑(p ^ n)}	⊢ x - ↑a ∈ ideal.span {↑p ^ n}
p : ℕ,	hp_prime : fact (nat.prime p),	n : ℕ,	x : ℤ_[p],	a b : ℕ,	ha : x - ↑a ∈ ideal.span {↑(p ^ n)},	hb : x - ↑b ∈ ideal.span {↑(p ^ n)}	⊢ x - ↑a ∈ ideal.span {↑p ^ n}		p : ℕ,	hp_prime : fact (nat.prime p),	n : ℕ,	x : ℤ_[p],	a b : ℕ,	ha : x - ↑a ∈ ideal.span {↑(p ^ n)},	hb : x - ↑b ∈ ideal.span {↑(p ^ n)}	⊢ x - ↑b ∈ ideal.span {↑p ^ n}
p : ℕ,	hp_prime : fact (nat.prime p),	n : ℕ,	x : ℤ_[p],	a b : ℕ,	ha : x - ↑a ∈ ideal.span {↑(p ^ n)},	hb : x - ↑b ∈ ideal.span {↑(p ^ n)}	⊢ x - ↑b ∈ ideal.span {↑p ^ n}
a : ℕ,	a1 : 1 < a,	is_pell_norm : ∀ {b : ℤ√↑d}, pell.is_pell b ↔ b * b.conj = 1,	x y : ℤ	⊢ pell.is_pell {re := x, im := y} ↔ {re := x, im := y} * {re := x, im := y}.conj = 1
a : ℕ,	a1 : 1 < a,	is_pell_norm : ∀ {b : ℤ√↑d}, pell.is_pell b ↔ b * b.conj = 1,	x y : ℤ	⊢ pell.is_pell {re := x, im := y} ↔ {re := x, im := y} * {re := x, im := y}.conj = 1
a : ℕ,	a1 : 1 < a,	is_pell_norm : ∀ {b : ℤ√↑d}, pell.is_pell b ↔ b * b.conj = 1,	x y : ℤ	⊢ x * x - y * (y * ↑d) = 1 ↔ x * x + -(y * (y * ↑d)) = 1
a : ℕ,	a1 : 1 < a,	n : ℕ	⊢ pell.pell_zd (n + 1) = pell.pell_zd n * {re := ↑a, im := 1}
a : ℕ,	a1 : 1 < a,	x y : ℕ,	hp : x * x - d * y * y = 1,	_match : ∀ (_a : ℕ), _a * _a - d * y * y = 1 → 1 ≤ {re := ↑_a, im := ↑y},	hp : 0 - d * y * y = 1	⊢ 1 ≤ {re := ↑0, im := ↑y}
a : ℕ,	a1 : 1 < a,	x y : ℕ,	hp : x * x - d * y * y = 1,	_match : ∀ (_a : ℕ), _a * _a - d * y * y = 1 → 1 ≤ {re := ↑_a, im := ↑y},	hp : 0 - d * y * y = 1	⊢ 1 ≤ {re := ↑0, im := ↑y}
a : ℕ,	a1 : 1 < a,	x y : ℕ,	hp : x * x - d * y * y = 1,	_match : ∀ (_a : ℕ), _a * _a - d * y * y = 1 → 1 ≤ {re := ↑_a, im := ↑y},	hp : 0 = 1	⊢ 1 ≤ {re := ↑0, im := ↑y}
a : ℕ,	a1 : 1 < a,	n : ℕ	⊢ pell.yn n * pell.yn n ∣ pell.yn n ^ 3
a : ℕ,	a1 : 1 < a,	n : ℕ	⊢ pell.yn n * pell.yn n ∣ pell.yn n * pell.xn n ^ (pell.yn n - 1) * pell.yn n
s : finset ℕ,	a : ℕ,	s : finset ℕ,	a_not_in_s : a ∉ s,	induct : ∀ (n : ℕ), (∀ (a : ℕ), a ∈ s → nat.prime a) → (∀ (a : ℕ), a ∈ s → a ∣ n) → ∏ (p : ℕ) in s, p ∣ n,	primes : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → nat.prime a_1,	k : ℕ,	divs : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → a_1 ∣ a * k,	b : ℕ,	b_in_s : b ∈ s,	b_div_n : b ∣ a * k,	a_prime : nat.prime a,	b_prime : nat.prime b,	b_div_k : b ∣ k	⊢ b ∣ k
s : finset ℕ,	a : ℕ,	s : finset ℕ,	a_not_in_s : a ∉ s,	induct : ∀ (n : ℕ), (∀ (a : ℕ), a ∈ s → nat.prime a) → (∀ (a : ℕ), a ∈ s → a ∣ n) → ∏ (p : ℕ) in s, p ∣ n,	primes : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → nat.prime a_1,	k : ℕ,	divs : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → a_1 ∣ a * k	⊢ ∏ (p : ℕ) in s, p ∣ k		s : finset ℕ,	a : ℕ,	s : finset ℕ,	a_not_in_s : a ∉ s,	induct : ∀ (n : ℕ), (∀ (a : ℕ), a ∈ s → nat.prime a) → (∀ (a : ℕ), a ∈ s → a ∣ n) → ∏ (p : ℕ) in s, p ∣ n,	primes : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → nat.prime a_1,	k : ℕ,	divs : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → a_1 ∣ a * k,	step : ∏ (p : ℕ) in s, p ∣ k	⊢ a * ∏ (x : ℕ) in s, x ∣ a * k
s : finset ℕ,	a : ℕ,	s : finset ℕ,	a_not_in_s : a ∉ s,	induct : ∀ (n : ℕ), (∀ (a : ℕ), a ∈ s → nat.prime a) → (∀ (a : ℕ), a ∈ s → a ∣ n) → ∏ (p : ℕ) in s, p ∣ n,	primes : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → nat.prime a_1,	k : ℕ,	divs : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → a_1 ∣ a * k,	step : ∏ (p : ℕ) in s, p ∣ k	⊢ a * ∏ (x : ℕ) in s, x ∣ a * k
s : finset ℕ	⊢ ∀ (n : ℕ), (∀ (a : ℕ), a ∈ s → nat.prime a) → (∀ (a : ℕ), a ∈ s → a ∣ n) → ∏ (p : ℕ) in s, p ∣ n
s : finset ℕ	⊢ ∀ (n : ℕ), (∀ (a : ℕ), a ∈ ∅ → nat.prime a) → (∀ (a : ℕ), a ∈ ∅ → a ∣ n) → ∏ (p : ℕ) in ∅, p ∣ n		s : finset ℕ	⊢ ∀ ⦃a : ℕ⦄ {s : finset ℕ}, a ∉ s → (∀ (n : ℕ), (∀ (a : ℕ), a ∈ s → nat.prime a) → (∀ (a : ℕ), a ∈ s → a ∣ n) → ∏ (p : ℕ) in s, p ∣ n) → ∀ (n : ℕ), (∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → nat.prime a_1) → (∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → a_1 ∣ n) → ∏ (p : ℕ) in has_insert.insert a s, p ∣ n
s : finset ℕ	⊢ ∀ (n : ℕ), (∀ (a : ℕ), a ∈ ∅ → nat.prime a) → (∀ (a : ℕ), a ∈ ∅ → a ∣ n) → ∏ (p : ℕ) in ∅, p ∣ n
s : finset ℕ	⊢ ∀ ⦃a : ℕ⦄ {s : finset ℕ}, a ∉ s → (∀ (n : ℕ), (∀ (a : ℕ), a ∈ s → nat.prime a) → (∀ (a : ℕ), a ∈ s → a ∣ n) → ∏ (p : ℕ) in s, p ∣ n) → ∀ (n : ℕ), (∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → nat.prime a_1) → (∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → a_1 ∣ n) → ∏ (p : ℕ) in has_insert.insert a s, p ∣ n
s : finset ℕ,	a : ℕ,	s : finset ℕ,	a_not_in_s : a ∉ s,	induct : ∀ (n : ℕ), (∀ (a : ℕ), a ∈ s → nat.prime a) → (∀ (a : ℕ), a ∈ s → a ∣ n) → ∏ (p : ℕ) in s, p ∣ n,	n : ℕ,	primes : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → nat.prime a_1,	divs : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → a_1 ∣ n	⊢ ∏ (p : ℕ) in has_insert.insert a s, p ∣ n
s : finset ℕ,	a : ℕ,	s : finset ℕ,	a_not_in_s : a ∉ s,	induct : ∀ (n : ℕ), (∀ (a : ℕ), a ∈ s → nat.prime a) → (∀ (a : ℕ), a ∈ s → a ∣ n) → ∏ (p : ℕ) in s, p ∣ n,	n : ℕ,	primes : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → nat.prime a_1,	divs : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → a_1 ∣ n	⊢ a ∣ n
s : finset ℕ,	a : ℕ,	s : finset ℕ,	a_not_in_s : a ∉ s,	induct : ∀ (n : ℕ), (∀ (a : ℕ), a ∈ s → nat.prime a) → (∀ (a : ℕ), a ∈ s → a ∣ n) → ∏ (p : ℕ) in s, p ∣ n,	n : ℕ,	primes : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → nat.prime a_1,	divs : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → a_1 ∣ n	⊢ a * ∏ (x : ℕ) in s, x ∣ n
s : finset ℕ,	a : ℕ,	s : finset ℕ,	a_not_in_s : a ∉ s,	induct : ∀ (n : ℕ), (∀ (a : ℕ), a ∈ s → nat.prime a) → (∀ (a : ℕ), a ∈ s → a ∣ n) → ∏ (p : ℕ) in s, p ∣ n,	primes : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → nat.prime a_1,	k : ℕ,	divs : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → a_1 ∣ a * k	⊢ a * ∏ (x : ℕ) in s, x ∣ a * k
s : finset ℕ,	a : ℕ,	s : finset ℕ,	a_not_in_s : a ∉ s,	induct : ∀ (n : ℕ), (∀ (a : ℕ), a ∈ s → nat.prime a) → (∀ (a : ℕ), a ∈ s → a ∣ n) → ∏ (p : ℕ) in s, p ∣ n,	primes : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → nat.prime a_1,	k : ℕ,	divs : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → a_1 ∣ a * k	⊢ ∏ (p : ℕ) in s, p ∣ k
s : finset ℕ,	a : ℕ,	s : finset ℕ,	a_not_in_s : a ∉ s,	induct : ∀ (n : ℕ), (∀ (a : ℕ), a ∈ s → nat.prime a) → (∀ (a : ℕ), a ∈ s → a ∣ n) → ∏ (p : ℕ) in s, p ∣ n,	primes : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → nat.prime a_1,	k : ℕ,	divs : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → a_1 ∣ a * k	⊢ ∀ (a : ℕ), a ∈ s → nat.prime a
s : finset ℕ,	a : ℕ,	s : finset ℕ,	a_not_in_s : a ∉ s,	induct : ∀ (n : ℕ), (∀ (a : ℕ), a ∈ s → nat.prime a) → (∀ (a : ℕ), a ∈ s → a ∣ n) → ∏ (p : ℕ) in s, p ∣ n,	primes : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → nat.prime a_1,	k : ℕ,	divs : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → a_1 ∣ a * k	⊢ ∀ (a : ℕ), a ∈ s → nat.prime a		s : finset ℕ,	a : ℕ,	s : finset ℕ,	a_not_in_s : a ∉ s,	induct : ∀ (n : ℕ), (∀ (a : ℕ), a ∈ s → nat.prime a) → (∀ (a : ℕ), a ∈ s → a ∣ n) → ∏ (p : ℕ) in s, p ∣ n,	primes : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → nat.prime a_1,	k : ℕ,	divs : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → a_1 ∣ a * k	⊢ ∀ (a : ℕ), a ∈ s → a ∣ k
s : finset ℕ,	a : ℕ,	s : finset ℕ,	a_not_in_s : a ∉ s,	induct : ∀ (n : ℕ), (∀ (a : ℕ), a ∈ s → nat.prime a) → (∀ (a : ℕ), a ∈ s → a ∣ n) → ∏ (p : ℕ) in s, p ∣ n,	primes : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → nat.prime a_1,	k : ℕ,	divs : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → a_1 ∣ a * k,	b : ℕ,	b_in_s : b ∈ s	⊢ nat.prime b
s : finset ℕ,	a : ℕ,	s : finset ℕ,	a_not_in_s : a ∉ s,	induct : ∀ (n : ℕ), (∀ (a : ℕ), a ∈ s → nat.prime a) → (∀ (a : ℕ), a ∈ s → a ∣ n) → ∏ (p : ℕ) in s, p ∣ n,	primes : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → nat.prime a_1,	k : ℕ,	divs : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → a_1 ∣ a * k	⊢ ∀ (a : ℕ), a ∈ s → a ∣ k
s : finset ℕ,	a : ℕ,	s : finset ℕ,	a_not_in_s : a ∉ s,	induct : ∀ (n : ℕ), (∀ (a : ℕ), a ∈ s → nat.prime a) → (∀ (a : ℕ), a ∈ s → a ∣ n) → ∏ (p : ℕ) in s, p ∣ n,	primes : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → nat.prime a_1,	k : ℕ,	divs : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → a_1 ∣ a * k,	b : ℕ,	b_in_s : b ∈ s	⊢ ?m_1
s : finset ℕ,	a : ℕ,	s : finset ℕ,	a_not_in_s : a ∉ s,	induct : ∀ (n : ℕ), (∀ (a : ℕ), a ∈ s → nat.prime a) → (∀ (a : ℕ), a ∈ s → a ∣ n) → ∏ (p : ℕ) in s, p ∣ n,	primes : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → nat.prime a_1,	k : ℕ,	divs : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → a_1 ∣ a * k,	b : ℕ,	b_in_s : b ∈ s	⊢ b ∣ k
s : finset ℕ,	a : ℕ,	s : finset ℕ,	a_not_in_s : a ∉ s,	induct : ∀ (n : ℕ), (∀ (a : ℕ), a ∈ s → nat.prime a) → (∀ (a : ℕ), a ∈ s → a ∣ n) → ∏ (p : ℕ) in s, p ∣ n,	primes : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → nat.prime a_1,	k : ℕ,	divs : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → a_1 ∣ a * k,	b : ℕ,	b_in_s : b ∈ s,	b_div_n : b ∣ a * k	⊢ nat.prime a
s : finset ℕ,	a : ℕ,	s : finset ℕ,	a_not_in_s : a ∉ s,	induct : ∀ (n : ℕ), (∀ (a : ℕ), a ∈ s → nat.prime a) → (∀ (a : ℕ), a ∈ s → a ∣ n) → ∏ (p : ℕ) in s, p ∣ n,	primes : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → nat.prime a_1,	k : ℕ,	divs : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → a_1 ∣ a * k,	b : ℕ,	b_in_s : b ∈ s,	b_div_n : b ∣ a * k	⊢ nat.prime a		s : finset ℕ,	a : ℕ,	s : finset ℕ,	a_not_in_s : a ∉ s,	induct : ∀ (n : ℕ), (∀ (a : ℕ), a ∈ s → nat.prime a) → (∀ (a : ℕ), a ∈ s → a ∣ n) → ∏ (p : ℕ) in s, p ∣ n,	primes : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → nat.prime a_1,	k : ℕ,	divs : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → a_1 ∣ a * k,	b : ℕ,	b_in_s : b ∈ s,	b_div_n : b ∣ a * k,	a_prime : nat.prime a	⊢ b ∣ k
s : finset ℕ,	a : ℕ,	s : finset ℕ,	a_not_in_s : a ∉ s,	induct : ∀ (n : ℕ), (∀ (a : ℕ), a ∈ s → nat.prime a) → (∀ (a : ℕ), a ∈ s → a ∣ n) → ∏ (p : ℕ) in s, p ∣ n,	primes : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → nat.prime a_1,	k : ℕ,	divs : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → a_1 ∣ a * k,	b : ℕ,	b_in_s : b ∈ s,	b_div_n : b ∣ a * k	⊢ b ∣ k
s : finset ℕ,	a : ℕ,	s : finset ℕ,	a_not_in_s : a ∉ s,	induct : ∀ (n : ℕ), (∀ (a : ℕ), a ∈ s → nat.prime a) → (∀ (a : ℕ), a ∈ s → a ∣ n) → ∏ (p : ℕ) in s, p ∣ n,	primes : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → nat.prime a_1,	k : ℕ,	divs : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → a_1 ∣ a * k,	b : ℕ,	b_in_s : b ∈ s,	b_div_n : b ∣ a * k,	a_prime : nat.prime a	⊢ nat.prime b
s : finset ℕ,	a : ℕ,	s : finset ℕ,	a_not_in_s : a ∉ s,	induct : ∀ (n : ℕ), (∀ (a : ℕ), a ∈ s → nat.prime a) → (∀ (a : ℕ), a ∈ s → a ∣ n) → ∏ (p : ℕ) in s, p ∣ n,	primes : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → nat.prime a_1,	k : ℕ,	divs : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → a_1 ∣ a * k,	b : ℕ,	b_in_s : b ∈ s,	b_div_n : b ∣ a * k,	a_prime : nat.prime a	⊢ nat.prime b		s : finset ℕ,	a : ℕ,	s : finset ℕ,	a_not_in_s : a ∉ s,	induct : ∀ (n : ℕ), (∀ (a : ℕ), a ∈ s → nat.prime a) → (∀ (a : ℕ), a ∈ s → a ∣ n) → ∏ (p : ℕ) in s, p ∣ n,	primes : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → nat.prime a_1,	k : ℕ,	divs : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → a_1 ∣ a * k,	b : ℕ,	b_in_s : b ∈ s,	b_div_n : b ∣ a * k,	a_prime : nat.prime a,	b_prime : nat.prime b	⊢ b ∣ k
s : finset ℕ,	a : ℕ,	s : finset ℕ,	a_not_in_s : a ∉ s,	induct : ∀ (n : ℕ), (∀ (a : ℕ), a ∈ s → nat.prime a) → (∀ (a : ℕ), a ∈ s → a ∣ n) → ∏ (p : ℕ) in s, p ∣ n,	primes : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → nat.prime a_1,	k : ℕ,	divs : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → a_1 ∣ a * k,	b : ℕ,	b_in_s : b ∈ s,	b_div_n : b ∣ a * k,	a_prime : nat.prime a	⊢ b ∣ k
s : finset ℕ,	a : ℕ,	s : finset ℕ,	a_not_in_s : a ∉ s,	induct : ∀ (n : ℕ), (∀ (a : ℕ), a ∈ s → nat.prime a) → (∀ (a : ℕ), a ∈ s → a ∣ n) → ∏ (p : ℕ) in s, p ∣ n,	primes : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → nat.prime a_1,	k : ℕ,	divs : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → a_1 ∣ a * k,	b : ℕ,	b_in_s : b ∈ s,	b_div_n : b ∣ a * k,	a_prime : nat.prime a,	b_prime : nat.prime b	⊢ b ∣ a ∨ b ∣ k		s : finset ℕ,	a : ℕ,	s : finset ℕ,	a_not_in_s : a ∉ s,	induct : ∀ (n : ℕ), (∀ (a : ℕ), a ∈ s → nat.prime a) → (∀ (a : ℕ), a ∈ s → a ∣ n) → ∏ (p : ℕ) in s, p ∣ n,	primes : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → nat.prime a_1,	k : ℕ,	divs : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → a_1 ∣ a * k,	b : ℕ,	b_in_s : b ∈ s,	b_div_n : b ∣ a * k,	a_prime : nat.prime a,	b_prime : nat.prime b,	b_div_a : b ∣ a	⊢ b ∣ k		s : finset ℕ,	a : ℕ,	s : finset ℕ,	a_not_in_s : a ∉ s,	induct : ∀ (n : ℕ), (∀ (a : ℕ), a ∈ s → nat.prime a) → (∀ (a : ℕ), a ∈ s → a ∣ n) → ∏ (p : ℕ) in s, p ∣ n,	primes : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → nat.prime a_1,	k : ℕ,	divs : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → a_1 ∣ a * k,	b : ℕ,	b_in_s : b ∈ s,	b_div_n : b ∣ a * k,	a_prime : nat.prime a,	b_prime : nat.prime b,	b_div_k : b ∣ k	⊢ b ∣ k
s : finset ℕ,	a : ℕ,	s : finset ℕ,	a_not_in_s : a ∉ s,	induct : ∀ (n : ℕ), (∀ (a : ℕ), a ∈ s → nat.prime a) → (∀ (a : ℕ), a ∈ s → a ∣ n) → ∏ (p : ℕ) in s, p ∣ n,	primes : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → nat.prime a_1,	k : ℕ,	divs : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → a_1 ∣ a * k,	b : ℕ,	b_in_s : b ∈ s,	b_div_n : b ∣ a * k,	a_prime : nat.prime a,	b_prime : nat.prime b	⊢ b ∣ k
s : finset ℕ,	a : ℕ,	s : finset ℕ,	a_not_in_s : a ∉ s,	induct : ∀ (n : ℕ), (∀ (a : ℕ), a ∈ s → nat.prime a) → (∀ (a : ℕ), a ∈ s → a ∣ n) → ∏ (p : ℕ) in s, p ∣ n,	primes : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → nat.prime a_1,	k : ℕ,	divs : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → a_1 ∣ a * k,	b : ℕ,	b_in_s : b ∈ s,	b_div_n : b ∣ a * k,	a_prime : nat.prime a,	b_prime : nat.prime b,	b_div_a : b ∣ a	⊢ b ∣ k
s : finset ℕ,	a : ℕ,	s : finset ℕ,	a_not_in_s : a ∉ s,	induct : ∀ (n : ℕ), (∀ (a : ℕ), a ∈ s → nat.prime a) → (∀ (a : ℕ), a ∈ s → a ∣ n) → ∏ (p : ℕ) in s, p ∣ n,	primes : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → nat.prime a_1,	k : ℕ,	divs : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → a_1 ∣ a * k,	b : ℕ,	b_in_s : b ∈ s,	b_div_n : b ∣ a * k,	a_prime : nat.prime a,	b_prime : nat.prime b,	b_div_a : b ∣ a	⊢ false
s : finset ℕ,	a : ℕ,	s : finset ℕ,	a_not_in_s : a ∉ s,	induct : ∀ (n : ℕ), (∀ (a : ℕ), a ∈ s → nat.prime a) → (∀ (a : ℕ), a ∈ s → a ∣ n) → ∏ (p : ℕ) in s, p ∣ n,	primes : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → nat.prime a_1,	k : ℕ,	divs : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → a_1 ∣ a * k,	b : ℕ,	b_in_s : b ∈ s,	b_div_n : b ∣ a * k,	a_prime : nat.prime a,	b_prime : nat.prime b,	b_div_a : b ∣ a	⊢ b = a
s : finset ℕ,	a : ℕ,	s : finset ℕ,	a_not_in_s : a ∉ s,	induct : ∀ (n : ℕ), (∀ (a : ℕ), a ∈ s → nat.prime a) → (∀ (a : ℕ), a ∈ s → a ∣ n) → ∏ (p : ℕ) in s, p ∣ n,	primes : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → nat.prime a_1,	k : ℕ,	divs : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → a_1 ∣ a * k,	b : ℕ,	b_in_s : b ∈ s,	b_div_n : b ∣ a * k,	a_prime : nat.prime a,	b_prime : nat.prime b,	b_div_a : b ∣ a,	b_eq_1 : b = 1	⊢ b = a
s : finset ℕ,	a : ℕ,	s : finset ℕ,	a_not_in_s : a ∉ s,	induct : ∀ (n : ℕ), (∀ (a : ℕ), a ∈ s → nat.prime a) → (∀ (a : ℕ), a ∈ s → a ∣ n) → ∏ (p : ℕ) in s, p ∣ n,	primes : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → nat.prime a_1,	k : ℕ,	divs : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → a_1 ∣ a * k,	a_prime : nat.prime a,	b_in_s : 1 ∈ s,	b_div_n : 1 ∣ a * k,	b_prime : nat.prime 1,	b_div_a : 1 ∣ a	⊢ 1 = a
s : finset ℕ,	a : ℕ,	s : finset ℕ,	a_not_in_s : a ∉ s,	induct : ∀ (n : ℕ), (∀ (a : ℕ), a ∈ s → nat.prime a) → (∀ (a : ℕ), a ∈ s → a ∣ n) → ∏ (p : ℕ) in s, p ∣ n,	primes : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → nat.prime a_1,	k : ℕ,	divs : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → a_1 ∣ a * k,	a_prime : nat.prime a,	b_in_s : 1 ∈ s,	b_div_n : 1 ∣ a * k,	b_prime : nat.prime 1,	b_div_a : 1 ∣ a	⊢ false
s : finset ℕ,	a : ℕ,	s : finset ℕ,	a_not_in_s : a ∉ s,	induct : ∀ (n : ℕ), (∀ (a : ℕ), a ∈ s → nat.prime a) → (∀ (a : ℕ), a ∈ s → a ∣ n) → ∏ (p : ℕ) in s, p ∣ n,	primes : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → nat.prime a_1,	k : ℕ,	divs : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → a_1 ∣ a * k,	b : ℕ,	b_in_s : b ∈ s,	b_div_n : b ∣ a * k,	a_prime : nat.prime a,	b_prime : nat.prime b,	b_div_a : b ∣ a,	b_eq_1 : b = 1	⊢ b = a		case or.inr	s : finset ℕ,	a : ℕ,	s : finset ℕ,	a_not_in_s : a ∉ s,	induct : ∀ (n : ℕ), (∀ (a : ℕ), a ∈ s → nat.prime a) → (∀ (a : ℕ), a ∈ s → a ∣ n) → ∏ (p : ℕ) in s, p ∣ n,	primes : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → nat.prime a_1,	k : ℕ,	divs : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → a_1 ∣ a * k,	b : ℕ,	b_in_s : b ∈ s,	b_div_n : b ∣ a * k,	a_prime : nat.prime a,	b_prime : nat.prime b,	b_div_a : b ∣ a,	b_eq_a : b = a	⊢ b = a
s : finset ℕ,	a : ℕ,	s : finset ℕ,	a_not_in_s : a ∉ s,	induct : ∀ (n : ℕ), (∀ (a : ℕ), a ∈ s → nat.prime a) → (∀ (a : ℕ), a ∈ s → a ∣ n) → ∏ (p : ℕ) in s, p ∣ n,	primes : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → nat.prime a_1,	k : ℕ,	divs : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → a_1 ∣ a * k,	b : ℕ,	b_in_s : b ∈ s,	b_div_n : b ∣ a * k,	a_prime : nat.prime a,	b_prime : nat.prime b,	b_div_a : b ∣ a,	b_eq_a : b = a	⊢ b = a
s : finset ℕ,	a : ℕ,	s : finset ℕ,	a_not_in_s : a ∉ s,	induct : ∀ (n : ℕ), (∀ (a : ℕ), a ∈ s → nat.prime a) → (∀ (a : ℕ), a ∈ s → a ∣ n) → ∏ (p : ℕ) in s, p ∣ n,	primes : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → nat.prime a_1,	k : ℕ,	divs : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → a_1 ∣ a * k,	b : ℕ,	b_in_s : b ∈ s,	b_div_n : b ∣ a * k,	a_prime : nat.prime a,	b_prime : nat.prime b,	b_div_a : b ∣ a	⊢ b = a		s : finset ℕ,	a : ℕ,	s : finset ℕ,	a_not_in_s : a ∉ s,	induct : ∀ (n : ℕ), (∀ (a : ℕ), a ∈ s → nat.prime a) → (∀ (a : ℕ), a ∈ s → a ∣ n) → ∏ (p : ℕ) in s, p ∣ n,	primes : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → nat.prime a_1,	k : ℕ,	divs : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → a_1 ∣ a * k,	b : ℕ,	b_in_s : b ∈ s,	b_div_n : b ∣ a * k,	a_prime : nat.prime a,	b_prime : nat.prime b,	b_div_a : b ∣ a,	b_eq_a : b = a	⊢ false
s : finset ℕ,	a : ℕ,	s : finset ℕ,	a_not_in_s : a ∉ s,	induct : ∀ (n : ℕ), (∀ (a : ℕ), a ∈ s → nat.prime a) → (∀ (a : ℕ), a ∈ s → a ∣ n) → ∏ (p : ℕ) in s, p ∣ n,	primes : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → nat.prime a_1,	k : ℕ,	divs : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → a_1 ∣ a * k,	b : ℕ,	b_in_s : b ∈ s,	b_div_n : b ∣ a * k,	a_prime : nat.prime a,	b_prime : nat.prime b,	b_div_a : b ∣ a,	b_eq_a : b = a	⊢ false
s s : finset ℕ,	induct : ∀ (n : ℕ), (∀ (a : ℕ), a ∈ s → nat.prime a) → (∀ (a : ℕ), a ∈ s → a ∣ n) → ∏ (p : ℕ) in s, p ∣ n,	k b : ℕ,	b_in_s : b ∈ s,	b_prime : nat.prime b,	a_not_in_s : b ∉ s,	primes : ∀ (a : ℕ), a ∈ has_insert.insert b s → nat.prime a,	divs : ∀ (a : ℕ), a ∈ has_insert.insert b s → a ∣ b * k,	b_div_n : b ∣ b * k,	a_prime : nat.prime b,	b_div_a : b ∣ b	⊢ false
s : finset ℕ,	a : ℕ,	s : finset ℕ,	a_not_in_s : a ∉ s,	induct : ∀ (n : ℕ), (∀ (a : ℕ), a ∈ s → nat.prime a) → (∀ (a : ℕ), a ∈ s → a ∣ n) → ∏ (p : ℕ) in s, p ∣ n,	primes : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → nat.prime a_1,	k : ℕ,	divs : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → a_1 ∣ a * k,	b : ℕ,	b_in_s : b ∈ s,	b_div_n : b ∣ a * k,	a_prime : nat.prime a,	b_prime : nat.prime b,	b_div_a : b ∣ a	⊢ b ∣ k		s : finset ℕ,	a : ℕ,	s : finset ℕ,	a_not_in_s : a ∉ s,	induct : ∀ (n : ℕ), (∀ (a : ℕ), a ∈ s → nat.prime a) → (∀ (a : ℕ), a ∈ s → a ∣ n) → ∏ (p : ℕ) in s, p ∣ n,	primes : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → nat.prime a_1,	k : ℕ,	divs : ∀ (a_1 : ℕ), a_1 ∈ has_insert.insert a s → a_1 ∣ a * k,	b : ℕ,	b_in_s : b ∈ s,	b_div_n : b ∣ a * k,	a_prime : nat.prime a,	b_prime : nat.prime b,	b_div_k : b ∣ k	⊢ b ∣ k
x y z : ℤ,	h : pythagorean_triple x y z,	hc : _.is_primitive_classified	⊢ h.is_classified
x y z : ℤ,	h : pythagorean_triple x y z,	hc : _.is_primitive_classified	⊢ h.is_classified
x y z : ℤ,	h : pythagorean_triple x y z,	hc : _.is_primitive_classified	⊢ x = ↑(x.gcd y) * (x / ↑(x.gcd y))
x y z : ℤ,	h : pythagorean_triple x y z,	hc : _.is_primitive_classified	⊢ y = ↑(x.gcd y) * (y / ↑(x.gcd y))
x y z : ℤ,	h : pythagorean_triple x y z,	hc : _.is_primitive_classified	⊢ z = ↑(x.gcd y) * (z / ↑(x.gcd y))
x y z : ℤ,	h : pythagorean_triple x y z,	hc : _.is_primitive_classified	⊢ ↑(x.gcd y) ∣ x		x y z : ℤ,	h : pythagorean_triple x y z,	hc : _.is_primitive_classified	⊢ ↑(x.gcd y) ∣ y		x y z : ℤ,	h : pythagorean_triple x y z,	hc : _.is_primitive_classified	⊢ ↑(x.gcd y) ∣ z
x y z : ℤ,	h : pythagorean_triple x y z,	hc : _.is_primitive_classified	⊢ ↑(x.gcd y) ∣ x
x y z : ℤ,	h : pythagorean_triple x y z,	hc : _.is_primitive_classified	⊢ ↑(x.gcd y) ∣ y		x y z : ℤ,	h : pythagorean_triple x y z,	hc : _.is_primitive_classified	⊢ ↑(x.gcd y) ∣ z
x y z : ℤ,	h : pythagorean_triple x y z,	hc : _.is_primitive_classified	⊢ ↑(x.gcd y) ∣ y
x y z : ℤ,	h : pythagorean_triple x y z,	hc : _.is_primitive_classified	⊢ ↑(x.gcd y) ∣ z
x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1,	this : 0 < z * z	⊢ z ≠ 0
x y : ℤ,	hc : x.gcd y = 1,	h : pythagorean_triple x y 0,	this : 0 < 0 * 0	⊢ false
x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1	⊢ z ≠ 0
x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1,	this : 0 < z * z	⊢ z ≠ 0		x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1	⊢ 0 < z * z
x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1	⊢ 0 < z * z
x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1	⊢ x.gcd y ≠ 0
x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1	⊢ 0 < x ^ 2 + y ^ 2
x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1	⊢ 1 ≠ 0
x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1	⊢ x.gcd y ≠ 0		x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1,	hc' : x.gcd y ≠ 0	⊢ 0 < x ^ 2 + y ^ 2
x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1,	hc' : x.gcd y ≠ 0	⊢ 0 < x ^ 2 + y ^ 2
x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1,	hc' : x.gcd y ≠ 0,	hxz : x ≠ 0	⊢ 0 < x ^ 2 + y ^ 2
x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1,	hc' : x.gcd y ≠ 0,	hxz : x ≠ 0	⊢ 0 < x ^ 2 + y ^ 2		case or.inr	x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1,	hc' : x.gcd y ≠ 0,	hyz : y ≠ 0	⊢ 0 < x ^ 2 + y ^ 2
x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1,	hc' : x.gcd y ≠ 0,	hyz : y ≠ 0	⊢ 0 < x ^ 2 + y ^ 2
x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1	⊢ y.gcd z = 1
x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1,	H : ¬y.gcd z = 1	⊢ false
x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1,	H : ¬y.gcd z = 1,	p : ℕ,	hp : nat.prime p,	hpy : p ∣ y.nat_abs,	hpz : p ∣ z.nat_abs	⊢ false
x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1,	H : ¬y.gcd z = 1,	p : ℕ,	hp : nat.prime p,	hpy : p ∣ y.nat_abs,	hpz : p ∣ z.nat_abs	⊢ p ∣ 1
x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1,	H : ¬y.gcd z = 1,	p : ℕ,	hp : nat.prime p,	hpy : p ∣ y.nat_abs,	hpz : p ∣ z.nat_abs	⊢ p ∣ x.gcd y
x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1,	H : ¬y.gcd z = 1,	p : ℕ,	hp : nat.prime p,	hpy : p ∣ y.nat_abs,	hpz : p ∣ z.nat_abs	⊢ ↑p ∣ x ^ 2
x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1,	H : ¬y.gcd z = 1,	p : ℕ,	hp : nat.prime p,	hpy : p ∣ y.nat_abs,	hpz : p ∣ z.nat_abs	⊢ ↑p ∣ z * z - y * y
x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1,	H : ¬y.gcd z = 1,	p : ℕ,	hp : nat.prime p,	hpz : ↑p ∣ z,	hpy : ↑p ∣ y	⊢ ↑p ∣ z * z - y * y
x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1,	hzpos : 0 < z	⊢ h.is_primitive_classified
x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1,	hzpos : 0 < z,	h1 : x % 2 = 0 ∧ y % 2 = 1	⊢ h.is_primitive_classified
x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1,	hzpos : 0 < z,	h1 : x % 2 = 0 ∧ y % 2 = 1	⊢ h.is_primitive_classified		case or.inr	x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1,	hzpos : 0 < z,	h2 : x % 2 = 1 ∧ y % 2 = 0	⊢ h.is_primitive_classified
x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1,	hzpos : 0 < z,	h2 : x % 2 = 1 ∧ y % 2 = 0	⊢ h.is_primitive_classified
x y z : ℤ,	h : pythagorean_triple x y z,	hzpos : 0 < z,	h2 : x % 2 = 1 ∧ y % 2 = 0,	hc : y.gcd x = 1	⊢ h.is_primitive_classified
x y z : ℤ,	h : pythagorean_triple x y z,	hzpos : 0 < z,	h2 : x % 2 = 1 ∧ y % 2 = 0,	hc : y.gcd x = 1,	m n : ℤ,	H : (y = m ^ 2 - n ^ 2 ∧ x = 2 * m * n ∨ y = 2 * m * n ∧ x = m ^ 2 - n ^ 2) ∧ m.gcd n = 1 ∧ (m % 2 = 0 ∧ n % 2 = 1 ∨ m % 2 = 1 ∧ n % 2 = 0)	⊢ (x = m ^ 2 - n ^ 2 ∧ y = 2 * m * n ∨ x = 2 * m * n ∧ y = m ^ 2 - n ^ 2) ∧ m.gcd n = 1 ∧ (m % 2 = 0 ∧ n % 2 = 1 ∨ m % 2 = 1 ∧ n % 2 = 0)
x y z : ℤ,	h : pythagorean_triple x y z,	hzpos : 0 < z,	h2 : x % 2 = 1 ∧ y % 2 = 0,	hc : y.gcd x = 1,	m n : ℤ,	H : (y = m ^ 2 - n ^ 2 ∧ x = 2 * m * n ∨ y = 2 * m * n ∧ x = m ^ 2 - n ^ 2) ∧ m.gcd n = 1 ∧ (m % 2 = 0 ∧ n % 2 = 1 ∨ m % 2 = 1 ∧ n % 2 = 0)	⊢ h.is_primitive_classified
p : ℕ,	_inst_1 : fact (nat.prime p)	⊢ finset.Ico 1 p = ?m_1
p : ℕ,	_inst_1 : fact (nat.prime p)	⊢ ∏ (x : ℕ) in finset.Ico 1 p, ↑x = -1
p : ℕ,	_inst_1 : fact (nat.prime p)	⊢ ∏ (x : ℕ) in finset.Ico 1 (p - 1).succ, ↑x = -1
d : ℤ,	n : ℕ	⊢ ↑n = {re := ↑n, im := 0}
d x y : ℤ	⊢ {re := x, im := y} * {re := x, im := y}.conj = ↑x * ↑x - ↑d * ↑y * ↑y
x : ℤ[i]	⊢ ↑x = {re := ↑(x.re), im := ↑(x.im)}
x : ℤ[i]	⊢ ↑x.re = {re := ↑(x.re), im := ↑(x.im)}.re
x : ℤ[i]	⊢ ↑x.im = {re := ↑(x.re), im := ↑(x.im)}.im
x : ℤ[i]	⊢ ↑x = {re := ↑(x.re), im := ↑(x.im)}
α : Type u,	x y z : α,	_inst_1 : generalized_boolean_algebra α,	hz : z ≤ y,	hx : x ≤ y,	H : disjoint z (y \ x)	⊢ z ⊔ y \ x ≤ x ⊔ y \ x
α : Type u,	x y z : α,	_inst_1 : generalized_boolean_algebra α,	hz : z ≤ y,	hx : x ≤ y,	H : disjoint z (y \ x)	⊢ z ⊔ y \ x ≤ y
α : Type u,	x y z : α,	_inst_1 : generalized_boolean_algebra α,	hz : z ≤ y,	hx : x ≤ y,	H : disjoint z (y \ x)	⊢ z ⊔ y ≤ y
α : Type u,	x y : α,	_inst_1 : boolean_algebra α	⊢ x \ yᶜ = x ⊓ y
α : Type u,	_inst_1 : distrib_lattice_bot α,	a b c : α	⊢ disjoint a (b ⊔ c) ↔ disjoint a b ∧ disjoint a c
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : order_top β,	f : α → β,	H : strict_mono f,	a : α,	h_top : f a = ⊤,	x : α,	p : β	⊢ p ≤ f a
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : order_top β,	f : α → β,	H : strict_mono f,	a : α,	h_top : f a = ⊤,	x : α,	p : β	⊢ p ≤ ⊤
α : Type u,	_inst_1 : partial_order α,	lt_iff_exists_coe : ∀ {a b : with_top α}, a < b ↔ ∃ (p : α), a = ↑p ∧ ↑p < b,	a : α,	b : with_top α	⊢ option.some a < b ↔ ∃ (p : α), option.some a = ↑p ∧ ↑p < b
α : Type u,	_inst_1 : partial_order α,	lt_iff_exists_coe : ∀ {a b : with_top α}, a < b ↔ ∃ (p : α), a = ↑p ∧ ↑p < b,	b : with_top α	⊢ option.none < b ↔ ∃ (p : α), option.none = ↑p ∧ ↑p < b
α : Type u,	_inst_1 : preorder α,	_inst_3 : no_top_order α	⊢ ¬bdd_above set.univ
α : Type u_1,	_inst_1 : complete_lattice α,	_inst_2 : is_modular_lattice α,	_inst_3 : is_compactly_generated α,	_inst_4 : is_complemented α,	b : α	⊢ b = ⊥ ∨ ∃ (a : α), is_atom a ∧ a ≤ b
α : Type u_1,	_inst_1 : complete_lattice α,	_inst_2 : is_modular_lattice α,	_inst_3 : is_compactly_generated α,	_inst_4 : is_complemented α,	b : α,	h : {c : α | complete_lattice.is_compact_element c ∧ c ≤ b} ⊆ {⊥}	⊢ b = ⊥ ∨ ∃ (a : α), is_atom a ∧ a ≤ b
α : Type u_1,	_inst_1 : complete_lattice α,	_inst_2 : is_modular_lattice α,	_inst_3 : is_compactly_generated α,	_inst_4 : is_complemented α,	b : α,	h : {c : α | complete_lattice.is_compact_element c ∧ c ≤ b} ⊆ {⊥}	⊢ b = ⊥
α : Type u_1,	_inst_1 : complete_lattice α,	_inst_2 : is_modular_lattice α,	_inst_3 : is_compactly_generated α,	_inst_4 : is_complemented α,	b : α,	h : {c : α | complete_lattice.is_compact_element c ∧ c ≤ b} ⊆ {⊥}	⊢ b = ⊥ ∨ ∃ (a : α), is_atom a ∧ a ≤ b		α : Type u_1,	_inst_1 : complete_lattice α,	_inst_2 : is_modular_lattice α,	_inst_3 : is_compactly_generated α,	_inst_4 : is_complemented α,	b : α,	h : ¬{c : α | complete_lattice.is_compact_element c ∧ c ≤ b} ⊆ {⊥}	⊢ b = ⊥ ∨ ∃ (a : α), is_atom a ∧ a ≤ b
α : Type u_1,	_inst_1 : complete_lattice α,	_inst_2 : is_modular_lattice α,	_inst_3 : is_compactly_generated α,	_inst_4 : is_complemented α,	b : α,	h : {c : α | complete_lattice.is_compact_element c ∧ c ≤ b} ⊆ {⊥}	⊢ ∀ (a : α), a ∈ {c : α | complete_lattice.is_compact_element c ∧ c ≤ b} → a = ⊥
α : Type u_1,	_inst_1 : complete_lattice α,	_inst_2 : is_modular_lattice α,	_inst_3 : is_compactly_generated α,	_inst_4 : is_complemented α,	b : α,	h : ¬{c : α | complete_lattice.is_compact_element c ∧ c ≤ b} ⊆ {⊥}	⊢ b = ⊥ ∨ ∃ (a : α), is_atom a ∧ a ≤ b
α : Type u_1,	_inst_1 : complete_lattice α,	_inst_2 : is_modular_lattice α,	_inst_3 : is_compactly_generated α,	_inst_4 : is_complemented α,	b : α,	h : ¬{c : α | complete_lattice.is_compact_element c ∧ c ≤ b} ⊆ {⊥},	c : α,	hcbot : c ∉ {⊥},	hc : complete_lattice.is_compact_element c,	hcb : c ≤ b	⊢ b = ⊥ ∨ ∃ (a : α), is_atom a ∧ a ≤ b
α : Type u_1,	_inst_1 : complete_lattice α,	_inst_2 : is_modular_lattice α,	_inst_3 : is_compactly_generated α,	_inst_4 : is_complemented α,	b : α,	h : ¬{c : α | complete_lattice.is_compact_element c ∧ c ≤ b} ⊆ {⊥},	c : α,	hcbot : c ∉ {⊥},	hc : complete_lattice.is_compact_element c,	hcb : c ≤ b	⊢ ∃ (a : α), is_atom a ∧ a ≤ b
α : Type u_1,	_inst_1 : complete_lattice α,	_inst_2 : is_modular_lattice α,	_inst_3 : is_compactly_generated α,	_inst_4 : is_complemented α,	b : α,	h : ¬{c : α | complete_lattice.is_compact_element c ∧ c ≤ b} ⊆ {⊥},	c : α,	hcbot : c ∉ {⊥},	hc : complete_lattice.is_compact_element c,	hcb : c ≤ b,	hc' : is_coatomic ↥(set.Iic c)	⊢ ∃ (a : α), is_atom a ∧ a ≤ b
α : Type u_1,	_inst_1 : complete_lattice α,	_inst_2 : is_modular_lattice α,	_inst_3 : is_compactly_generated α,	_inst_4 : is_complemented α,	b : α,	h : ¬{c : α | complete_lattice.is_compact_element c ∧ c ≤ b} ⊆ {⊥},	c : α,	hcbot : c ∉ {⊥},	hc : complete_lattice.is_compact_element c,	hcb : c ≤ b,	hc' : is_atomic ↥(set.Iic c)	⊢ ∃ (a : α), is_atom a ∧ a ≤ b
α : Type u_1,	_inst_1 : complete_lattice α,	_inst_2 : is_modular_lattice α,	_inst_3 : is_compactly_generated α,	_inst_4 : is_complemented α,	b : α,	h : ¬{c : α | complete_lattice.is_compact_element c ∧ c ≤ b} ⊆ {⊥},	c : α,	hcbot : c ∉ {⊥},	hc : complete_lattice.is_compact_element c,	hcb : c ≤ b,	hc' _inst : is_atomic ↥(set.Iic c)	⊢ ∃ (a : α), is_atom a ∧ a ≤ b
α : Type u_1,	_inst_1 : complete_lattice α,	_inst_2 : is_modular_lattice α,	_inst_3 : is_compactly_generated α,	_inst_4 : is_complemented α,	b : α,	h : ¬{c : α | complete_lattice.is_compact_element c ∧ c ≤ b} ⊆ {⊥},	c : α,	hcbot : c ∉ {⊥},	hc : complete_lattice.is_compact_element c,	hcb : c ≤ b,	hc' _inst : is_atomic ↥(set.Iic c),	con : ⟨c, _⟩ = ⊥	⊢ ∃ (a : α), is_atom a ∧ a ≤ b
α : Type u_1,	_inst_1 : complete_lattice α,	_inst_2 : is_modular_lattice α,	_inst_3 : is_compactly_generated α,	_inst_4 : is_complemented α,	b : α,	h : ¬{c : α | complete_lattice.is_compact_element c ∧ c ≤ b} ⊆ {⊥},	c : α,	hcbot : c ∉ {⊥},	hc : complete_lattice.is_compact_element c,	hcb : c ≤ b,	hc' _inst : is_atomic ↥(set.Iic c),	con : ⟨c, _⟩ = ⊥	⊢ false
α : Type u_1,	_inst_1 : complete_lattice α,	_inst_2 : is_modular_lattice α,	_inst_3 : is_compactly_generated α,	_inst_4 : is_complemented α,	b : α,	h : ¬{c : α | complete_lattice.is_compact_element c ∧ c ≤ b} ⊆ {⊥},	c : α,	hcbot : c ∉ {⊥},	hc : complete_lattice.is_compact_element c,	hcb : c ≤ b,	hc' _inst : is_atomic ↥(set.Iic c),	con : ⟨c, _⟩ = ⊥	⊢ c ∈ {⊥}
α : Type u_1,	_inst_1 : complete_lattice α,	_inst_2 : is_modular_lattice α,	_inst_3 : is_compactly_generated α,	_inst_4 : is_complemented α,	b : α,	h : ¬{c : α | complete_lattice.is_compact_element c ∧ c ≤ b} ⊆ {⊥},	c : α,	hcbot : c ∉ {⊥},	hc : complete_lattice.is_compact_element c,	hcb : c ≤ b,	hc' _inst : is_atomic ↥(set.Iic c),	con : ⟨c, _⟩ = ⊥	⊢ ∃ (a : α), is_atom a ∧ a ≤ b		α : Type u_1,	_inst_1 : complete_lattice α,	_inst_2 : is_modular_lattice α,	_inst_3 : is_compactly_generated α,	_inst_4 : is_complemented α,	b : α,	h : ¬{c : α | complete_lattice.is_compact_element c ∧ c ≤ b} ⊆ {⊥},	c : α,	hcbot : c ∉ {⊥},	hc : complete_lattice.is_compact_element c,	hcb : c ≤ b,	hc' _inst : is_atomic ↥(set.Iic c),	a : {x // x ∈ set.Iic c},	ha : is_atom a,	hac : a ≤ ⟨c, _⟩	⊢ ∃ (a : α), is_atom a ∧ a ≤ b
α : Type u_1,	_inst_1 : complete_lattice α,	_inst_2 : is_modular_lattice α,	_inst_3 : is_compactly_generated α,	_inst_4 : is_complemented α,	b : α,	h : ¬{c : α | complete_lattice.is_compact_element c ∧ c ≤ b} ⊆ {⊥},	c : α,	hcbot : c ∉ {⊥},	hc : complete_lattice.is_compact_element c,	hcb : c ≤ b,	hc' _inst : is_atomic ↥(set.Iic c),	con : c = ⊥	⊢ c ∈ {⊥}
α : Type u_1,	_inst_1 : complete_lattice α,	_inst_2 : is_modular_lattice α,	_inst_3 : is_compactly_generated α,	_inst_4 : is_complemented α,	b : α,	h : ¬{c : α | complete_lattice.is_compact_element c ∧ c ≤ b} ⊆ {⊥},	c : α,	hcbot : c ∉ {⊥},	hc : complete_lattice.is_compact_element c,	hcb : c ≤ b,	hc' _inst : is_atomic ↥(set.Iic c),	a : {x // x ∈ set.Iic c},	ha : is_atom a,	hac : a ≤ ⟨c, _⟩	⊢ ∃ (a : α), is_atom a ∧ a ≤ b
α : Type u_1,	_inst_1 : complete_lattice α,	_inst_2 : is_modular_lattice α,	_inst_3 : is_compactly_generated α,	_inst_4 : is_complemented α,	b : α,	h : ¬{c : α | complete_lattice.is_compact_element c ∧ c ≤ b} ⊆ {⊥},	c : α,	hcbot : c ∉ {⊥},	hc : complete_lattice.is_compact_element c,	hcb : c ≤ b,	hc' _inst : is_atomic ↥(set.Iic c),	a : {x // x ∈ set.Iic c},	ha : is_atom a,	hac : ↑a ≤ c	⊢ ∃ (a : α), is_atom a ∧ a ≤ b
α : Type u_1,	_inst_1 : complete_lattice α,	s : set (set α)	⊢ has_Sup.Sup (⋃₀ s) = ⨆ (t : set α) (H : t ∈ s), has_Sup.Sup t
α : Type u_1,	_inst_1 : complete_lattice α,	s : set (set α)	⊢ has_Sup.Sup (⋃₀ s) ≤ ⨆ (t : set α) (H : t ∈ s), has_Sup.Sup t
α : Type u_1,	_inst_1 : complete_lattice α,	s : set (set α),	b : α,	hb : b ∈ ⋃₀ s	⊢ b ≤ ⨆ (t : set α) (H : t ∈ s), has_Sup.Sup t
α : Type u_1,	_inst_1 : complete_lattice α,	s : set (set α),	b : α,	t : set α,	ts : t ∈ s,	bt : b ∈ t	⊢ b ≤ ⨆ (t : set α) (H : t ∈ s), has_Sup.Sup t
α : Type u_1,	_inst_1 : complete_lattice α,	s : set (set α)	⊢ has_Sup.Sup (⋃₀ s) ≤ ⨆ (t : set α) (H : t ∈ s), has_Sup.Sup t		α : Type u_1,	_inst_1 : complete_lattice α,	s : set (set α)	⊢ (⨆ (t : set α) (H : t ∈ s), has_Sup.Sup t) ≤ has_Sup.Sup (⋃₀ s)
α : Type u_1,	_inst_1 : complete_lattice α,	s : set (set α),	b : α,	t : set α,	ts : t ∈ s,	bt : b ∈ t	⊢ b ≤ ⨆ (H : t ∈ s), has_Sup.Sup t
α : Type u_1,	_inst_1 : complete_lattice α,	s : set (set α)	⊢ (⨆ (t : set α) (H : t ∈ s), has_Sup.Sup t) ≤ has_Sup.Sup (⋃₀ s)
α : Type u_1,	_inst_1 : complete_lattice α,	s : set (set α),	t : set α	⊢ (⨆ (H : t ∈ s), has_Sup.Sup t) ≤ has_Sup.Sup (⋃₀ s)
α : Type u_1,	_inst_2 : has_Sup α,	p q : Prop,	f₁ : p → α,	f₂ : q → α,	pq : p ↔ q,	f : ∀ (x : q), f₁ _ = f₂ x,	this : p = q	⊢ supr f₁ = supr f₂
α : Type u_1,	_inst_2 : has_Sup α,	p q : Prop,	f₁ : p → α,	f₂ : q → α,	pq : p ↔ q,	f : ∀ (x : q), f₁ _ = f₂ x	⊢ supr f₁ = supr f₂
α : Type u_1,	_inst_2 : has_Sup α,	p : Prop,	f₁ f₂ : p → α,	pq : p ↔ p,	f : ∀ (x : p), f₁ _ = f₂ x	⊢ supr f₁ = supr f₂
α : Type u_1,	_inst_2 : has_Sup α,	p : Prop,	f₁ f₂ : p → α,	pq : p ↔ p,	f : ∀ (x : p), f₁ _ = f₂ x,	x : p	⊢ f₁ x = f₂ x
α : Type u_1,	ι : Sort u_4,	_inst_1 : complete_lattice α,	_inst_2 : nonempty ι,	a : α	⊢ (⨅ (b : ι), a) = a
α : Type u,	c : distrib_lattice α,	le : α → α → Prop,	eq_le : le = distrib_lattice.le,	sup : α → α → α,	eq_sup : sup = distrib_lattice.sup,	inf : α → α → α,	eq_inf : inf = distrib_lattice.inf	⊢ distrib_lattice α
α : Type u,	c : distrib_lattice α,	le : α → α → Prop,	eq_le : le = distrib_lattice.le,	sup : α → α → α,	eq_sup : sup = distrib_lattice.sup,	inf : α → α → α,	eq_inf : inf = distrib_lattice.inf	⊢ ∀ (a : α), a ≤ a
α : Type u,	c : distrib_lattice α,	le : α → α → Prop,	eq_le : le = distrib_lattice.le,	sup : α → α → α,	eq_sup : sup = distrib_lattice.sup,	inf : α → α → α,	eq_inf : inf = distrib_lattice.inf	⊢ ∀ (a b c : α), a ≤ b → b ≤ c → a ≤ c
α : Type u,	c : distrib_lattice α,	le : α → α → Prop,	eq_le : le = distrib_lattice.le,	sup : α → α → α,	eq_sup : sup = distrib_lattice.sup,	inf : α → α → α,	eq_inf : inf = distrib_lattice.inf	⊢ ∀ (a b : α), a ≤ b → b ≤ a → a = b
α : Type u,	c : distrib_lattice α,	le : α → α → Prop,	eq_le : le = distrib_lattice.le,	sup : α → α → α,	eq_sup : sup = distrib_lattice.sup,	inf : α → α → α,	eq_inf : inf = distrib_lattice.inf	⊢ ∀ (a b : α), a ≤ a ⊔ b
α : Type u,	c : distrib_lattice α,	le : α → α → Prop,	eq_le : le = distrib_lattice.le,	sup : α → α → α,	eq_sup : sup = distrib_lattice.sup,	inf : α → α → α,	eq_inf : inf = distrib_lattice.inf	⊢ ∀ (a b : α), b ≤ a ⊔ b
α : Type u,	c : distrib_lattice α,	le : α → α → Prop,	eq_le : le = distrib_lattice.le,	sup : α → α → α,	eq_sup : sup = distrib_lattice.sup,	inf : α → α → α,	eq_inf : inf = distrib_lattice.inf	⊢ ∀ (a b c_1 : α), a ≤ c_1 → b ≤ c_1 → a ⊔ b ≤ c_1
α : Type u,	c : distrib_lattice α,	le : α → α → Prop,	eq_le : le = distrib_lattice.le,	sup : α → α → α,	eq_sup : sup = distrib_lattice.sup,	inf : α → α → α,	eq_inf : inf = distrib_lattice.inf	⊢ ∀ (a b : α), a ⊓ b ≤ a
α : Type u,	c : distrib_lattice α,	le : α → α → Prop,	eq_le : le = distrib_lattice.le,	sup : α → α → α,	eq_sup : sup = distrib_lattice.sup,	inf : α → α → α,	eq_inf : inf = distrib_lattice.inf	⊢ ∀ (a b : α), a ⊓ b ≤ b
α : Type u,	c : distrib_lattice α,	le : α → α → Prop,	eq_le : le = distrib_lattice.le,	sup : α → α → α,	eq_sup : sup = distrib_lattice.sup,	inf : α → α → α,	eq_inf : inf = distrib_lattice.inf	⊢ ∀ (a b c_1 : α), a ≤ b → a ≤ c_1 → a ≤ b ⊓ c_1
α : Type u,	c : distrib_lattice α,	le : α → α → Prop,	eq_le : le = distrib_lattice.le,	sup : α → α → α,	eq_sup : sup = distrib_lattice.sup,	inf : α → α → α,	eq_inf : inf = distrib_lattice.inf	⊢ ∀ (x y z : α), (x ⊔ y) ⊓ (x ⊔ z) ≤ x ⊔ y ⊓ z
α : Type u,	c : distrib_lattice α,	le : α → α → Prop,	eq_le : le = distrib_lattice.le,	sup : α → α → α,	eq_sup : sup = distrib_lattice.sup,	inf : α → α → α,	eq_inf : inf = distrib_lattice.inf	⊢ ∀ (x y z : α), (x ⊔ y) ⊓ (x ⊔ z) ≤ x ⊔ y ⊓ z
α : Type u,	c : distrib_lattice α	⊢ ∀ (x y z : α), (x ⊔ y) ⊓ (x ⊔ z) ≤ x ⊔ y ⊓ z
α : Type u,	c : distrib_lattice α,	le : α → α → Prop,	eq_le : le = distrib_lattice.le,	sup : α → α → α,	eq_sup : sup = distrib_lattice.sup,	inf : α → α → α,	eq_inf : inf = distrib_lattice.inf	⊢ ∀ (a : α), a ≤ a		α : Type u,	c : distrib_lattice α,	le : α → α → Prop,	eq_le : le = distrib_lattice.le,	sup : α → α → α,	eq_sup : sup = distrib_lattice.sup,	inf : α → α → α,	eq_inf : inf = distrib_lattice.inf	⊢ ∀ (a b c : α), a ≤ b → b ≤ c → a ≤ c		α : Type u,	c : distrib_lattice α,	le : α → α → Prop,	eq_le : le = distrib_lattice.le,	sup : α → α → α,	eq_sup : sup = distrib_lattice.sup,	inf : α → α → α,	eq_inf : inf = distrib_lattice.inf	⊢ ∀ (a b : α), a ≤ b → b ≤ a → a = b		α : Type u,	c : distrib_lattice α,	le : α → α → Prop,	eq_le : le = distrib_lattice.le,	sup : α → α → α,	eq_sup : sup = distrib_lattice.sup,	inf : α → α → α,	eq_inf : inf = distrib_lattice.inf	⊢ ∀ (a b : α), a ≤ a ⊔ b		α : Type u,	c : distrib_lattice α,	le : α → α → Prop,	eq_le : le = distrib_lattice.le,	sup : α → α → α,	eq_sup : sup = distrib_lattice.sup,	inf : α → α → α,	eq_inf : inf = distrib_lattice.inf	⊢ ∀ (a b : α), b ≤ a ⊔ b		α : Type u,	c : distrib_lattice α,	le : α → α → Prop,	eq_le : le = distrib_lattice.le,	sup : α → α → α,	eq_sup : sup = distrib_lattice.sup,	inf : α → α → α,	eq_inf : inf = distrib_lattice.inf	⊢ ∀ (a b c : α), a ≤ c → b ≤ c → a ⊔ b ≤ c		α : Type u,	c : distrib_lattice α,	le : α → α → Prop,	eq_le : le = distrib_lattice.le,	sup : α → α → α,	eq_sup : sup = distrib_lattice.sup,	inf : α → α → α,	eq_inf : inf = distrib_lattice.inf	⊢ ∀ (a b : α), a ⊓ b ≤ a		α : Type u,	c : distrib_lattice α,	le : α → α → Prop,	eq_le : le = distrib_lattice.le,	sup : α → α → α,	eq_sup : sup = distrib_lattice.sup,	inf : α → α → α,	eq_inf : inf = distrib_lattice.inf	⊢ ∀ (a b : α), a ⊓ b ≤ b		α : Type u,	c : distrib_lattice α,	le : α → α → Prop,	eq_le : le = distrib_lattice.le,	sup : α → α → α,	eq_sup : sup = distrib_lattice.sup,	inf : α → α → α,	eq_inf : inf = distrib_lattice.inf	⊢ ∀ (a b c : α), a ≤ b → a ≤ c → a ≤ b ⊓ c		α : Type u,	c : distrib_lattice α,	le : α → α → Prop,	eq_le : le = distrib_lattice.le,	sup : α → α → α,	eq_sup : sup = distrib_lattice.sup,	inf : α → α → α,	eq_inf : inf = distrib_lattice.inf	⊢ ∀ (x y z : α), (x ⊔ y) ⊓ (x ⊔ z) ≤ x ⊔ y ⊓ z
α : Type u,	c_sup : α → α → α,	c_le c_lt : α → α → Prop,	c_le_refl : ∀ (a : α), a ≤ a,	c_le_trans : ∀ (a b c : α), a ≤ b → b ≤ c → a ≤ c,	c_lt_iff_le_not_le : auto_param (∀ (a b : α), a < b ↔ a ≤ b ∧ ¬b ≤ a) (name.mk_string "order_laws_tac" name.anonymous),	c_le_antisymm : ∀ (a b : α), a ≤ b → b ≤ a → a = b,	c_le_sup_left : ∀ (a b : α), a ≤ a ⊔ b,	c_le_sup_right : ∀ (a b : α), b ≤ a ⊔ b,	c_sup_le : ∀ (a b c : α), a ≤ c → b ≤ c → a ⊔ b ≤ c,	c_inf : α → α → α,	c_inf_le_left : ∀ (a b : α), a ⊓ b ≤ a,	c_inf_le_right : ∀ (a b : α), a ⊓ b ≤ b,	c_le_inf : ∀ (a b c : α), a ≤ b → a ≤ c → a ≤ b ⊓ c,	c_le_sup_inf : ∀ (x y z : α), (x ⊔ y) ⊓ (x ⊔ z) ≤ x ⊔ y ⊓ z	⊢ ∀ (x y z : α), (x ⊔ y) ⊓ (x ⊔ z) ≤ x ⊔ y ⊓ z
α : Type u,	c : complete_lattice α,	le : α → α → Prop,	eq_le : le = complete_lattice.le,	top : α,	eq_top : top = complete_lattice.top,	bot : α,	eq_bot : bot = complete_lattice.bot,	sup : α → α → α,	eq_sup : sup = complete_lattice.sup,	inf : α → α → α,	eq_inf : inf = complete_lattice.inf,	Sup : set α → α,	eq_Sup : Sup = complete_lattice.Sup,	Inf : set α → α,	eq_Inf : Inf = complete_lattice.Inf	⊢ complete_lattice α
α : Type u,	c : complete_lattice α,	le : α → α → Prop,	eq_le : le = complete_lattice.le,	top : α,	eq_top : top = complete_lattice.top,	bot : α,	eq_bot : bot = complete_lattice.bot,	sup : α → α → α,	eq_sup : sup = complete_lattice.sup,	inf : α → α → α,	eq_inf : inf = complete_lattice.inf,	Sup : set α → α,	eq_Sup : Sup = complete_lattice.Sup,	Inf : set α → α,	eq_Inf : Inf = complete_lattice.Inf	⊢ ∀ (s : set α) (a : α), a ∈ s → a ≤ Sup s
α : Type u,	c : complete_lattice α,	le : α → α → Prop,	eq_le : le = complete_lattice.le,	top : α,	eq_top : top = complete_lattice.top,	bot : α,	eq_bot : bot = complete_lattice.bot,	sup : α → α → α,	eq_sup : sup = complete_lattice.sup,	inf : α → α → α,	eq_inf : inf = complete_lattice.inf,	Sup : set α → α,	eq_Sup : Sup = complete_lattice.Sup,	Inf : set α → α,	eq_Inf : Inf = complete_lattice.Inf	⊢ ∀ (s : set α) (a : α), (∀ (b : α), b ∈ s → b ≤ a) → Sup s ≤ a
α : Type u,	c : complete_lattice α,	le : α → α → Prop,	eq_le : le = complete_lattice.le,	top : α,	eq_top : top = complete_lattice.top,	bot : α,	eq_bot : bot = complete_lattice.bot,	sup : α → α → α,	eq_sup : sup = complete_lattice.sup,	inf : α → α → α,	eq_inf : inf = complete_lattice.inf,	Sup : set α → α,	eq_Sup : Sup = complete_lattice.Sup,	Inf : set α → α,	eq_Inf : Inf = complete_lattice.Inf	⊢ ∀ (s : set α) (a : α), a ∈ s → Inf s ≤ a
α : Type u,	c : complete_lattice α,	le : α → α → Prop,	eq_le : le = complete_lattice.le,	top : α,	eq_top : top = complete_lattice.top,	bot : α,	eq_bot : bot = complete_lattice.bot,	sup : α → α → α,	eq_sup : sup = complete_lattice.sup,	inf : α → α → α,	eq_inf : inf = complete_lattice.inf,	Sup : set α → α,	eq_Sup : Sup = complete_lattice.Sup,	Inf : set α → α,	eq_Inf : Inf = complete_lattice.Inf	⊢ ∀ (s : set α) (a : α), (∀ (b : α), b ∈ s → a ≤ b) → a ≤ Inf s
α : Type u,	c : complete_lattice α,	le : α → α → Prop,	eq_le : le = complete_lattice.le,	top : α,	eq_top : top = complete_lattice.top,	bot : α,	eq_bot : bot = complete_lattice.bot,	sup : α → α → α,	eq_sup : sup = complete_lattice.sup,	inf : α → α → α,	eq_inf : inf = complete_lattice.inf,	Sup : set α → α,	eq_Sup : Sup = complete_lattice.Sup,	Inf : set α → α,	eq_Inf : Inf = complete_lattice.Inf	⊢ ∀ (s : set α) (a : α), (∀ (b : α), b ∈ s → a ≤ b) → a ≤ Inf s
α : Type u,	c : complete_lattice α	⊢ ∀ (s : set α) (a : α), (∀ (b : α), b ∈ s → a ≤ b) → a ≤ complete_lattice.Inf s
α : Type u,	c : complete_lattice α,	le : α → α → Prop,	eq_le : le = complete_lattice.le,	top : α,	eq_top : top = complete_lattice.top,	bot : α,	eq_bot : bot = complete_lattice.bot,	sup : α → α → α,	eq_sup : sup = complete_lattice.sup,	inf : α → α → α,	eq_inf : inf = complete_lattice.inf,	Sup : set α → α,	eq_Sup : Sup = complete_lattice.Sup,	Inf : set α → α,	eq_Inf : Inf = complete_lattice.Inf	⊢ ∀ (s : set α) (a : α), a ∈ s → a ≤ Sup s		α : Type u,	c : complete_lattice α,	le : α → α → Prop,	eq_le : le = complete_lattice.le,	top : α,	eq_top : top = complete_lattice.top,	bot : α,	eq_bot : bot = complete_lattice.bot,	sup : α → α → α,	eq_sup : sup = complete_lattice.sup,	inf : α → α → α,	eq_inf : inf = complete_lattice.inf,	Sup : set α → α,	eq_Sup : Sup = complete_lattice.Sup,	Inf : set α → α,	eq_Inf : Inf = complete_lattice.Inf	⊢ ∀ (s : set α) (a : α), (∀ (b : α), b ∈ s → b ≤ a) → Sup s ≤ a		α : Type u,	c : complete_lattice α,	le : α → α → Prop,	eq_le : le = complete_lattice.le,	top : α,	eq_top : top = complete_lattice.top,	bot : α,	eq_bot : bot = complete_lattice.bot,	sup : α → α → α,	eq_sup : sup = complete_lattice.sup,	inf : α → α → α,	eq_inf : inf = complete_lattice.inf,	Sup : set α → α,	eq_Sup : Sup = complete_lattice.Sup,	Inf : set α → α,	eq_Inf : Inf = complete_lattice.Inf	⊢ ∀ (s : set α) (a : α), a ∈ s → Inf s ≤ a		α : Type u,	c : complete_lattice α,	le : α → α → Prop,	eq_le : le = complete_lattice.le,	top : α,	eq_top : top = complete_lattice.top,	bot : α,	eq_bot : bot = complete_lattice.bot,	sup : α → α → α,	eq_sup : sup = complete_lattice.sup,	inf : α → α → α,	eq_inf : inf = complete_lattice.inf,	Sup : set α → α,	eq_Sup : Sup = complete_lattice.Sup,	Inf : set α → α,	eq_Inf : Inf = complete_lattice.Inf	⊢ ∀ (s : set α) (a : α), (∀ (b : α), b ∈ s → a ≤ b) → a ≤ Inf s
α : Type u,	c_sup : α → α → α,	c_le c_lt : α → α → Prop,	c_le_refl : ∀ (a : α), a ≤ a,	c_le_trans : ∀ (a b c : α), a ≤ b → b ≤ c → a ≤ c,	c_lt_iff_le_not_le : auto_param (∀ (a b : α), a < b ↔ a ≤ b ∧ ¬b ≤ a) (name.mk_string "order_laws_tac" name.anonymous),	c_le_antisymm : ∀ (a b : α), a ≤ b → b ≤ a → a = b,	c_le_sup_left : ∀ (a b : α), a ≤ a ⊔ b,	c_le_sup_right : ∀ (a b : α), b ≤ a ⊔ b,	c_sup_le : ∀ (a b c : α), a ≤ c → b ≤ c → a ⊔ b ≤ c,	c_inf : α → α → α,	c_inf_le_left : ∀ (a b : α), a ⊓ b ≤ a,	c_inf_le_right : ∀ (a b : α), a ⊓ b ≤ b,	c_le_inf : ∀ (a b c : α), a ≤ b → a ≤ c → a ≤ b ⊓ c,	c_top : α,	c_le_top : ∀ (a : α), a ≤ ⊤,	c_bot : α,	c_bot_le : ∀ (a : α), ⊥ ≤ a,	c_Sup : set α → α,	c_le_Sup : ∀ (s : set α) (a : α), a ∈ s → a ≤ c_Sup s,	c_Sup_le : ∀ (s : set α) (a : α), (∀ (b : α), b ∈ s → b ≤ a) → c_Sup s ≤ a,	c_Inf : set α → α,	c_Inf_le : ∀ (s : set α) (a : α), a ∈ s → c_Inf s ≤ a,	c_le_Inf : ∀ (s : set α) (a : α), (∀ (b : α), b ∈ s → a ≤ b) → a ≤ c_Inf s	⊢ ∀ (s : set α) (a : α), (∀ (b : α), b ∈ s → a ≤ b) → a ≤ complete_lattice.Inf s
α : Type u_1,	β : Type u_2,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	f : finset (α × β),	hf : ∀ (p q : α × β), p ∈ f → q ∈ f → cmp p.fst q.fst = cmp p.snd q.snd,	p q : β × α,	hq : q ∈ finset.image ⇑(equiv.prod_comm α β) f,	hp : p ∈ ⇑((equiv.prod_comm α β).symm) ⁻¹' ↑f	⊢ ⇑((equiv.prod_comm α β).symm) p ∈ f
α : Type u_1,	β : Type u_2,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	f : finset (α × β),	hf : ∀ (p q : α × β), p ∈ f → q ∈ f → cmp p.fst q.fst = cmp p.snd q.snd,	p q : β × α,	hp : p ∈ finset.image ⇑(equiv.prod_comm α β) f,	hq : q ∈ finset.image ⇑(equiv.prod_comm α β) f	⊢ ⇑((equiv.prod_comm α β).symm) p ∈ f
α : Type u_1,	β : Type u_2,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	f : finset (α × β),	hf : ∀ (p q : α × β), p ∈ f → q ∈ f → cmp p.fst q.fst = cmp p.snd q.snd,	p q : β × α,	hp : p ∈ finset.image ⇑(equiv.prod_comm α β) f,	hq : q ∈ ⇑((equiv.prod_comm α β).symm) ⁻¹' ↑f	⊢ ⇑((equiv.prod_comm α β).symm) q ∈ f
α : Type u_1,	β : Type u_2,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	f : finset (α × β),	hf : ∀ (p q : α × β), p ∈ f → q ∈ f → cmp p.fst q.fst = cmp p.snd q.snd,	p q : β × α,	hp : p ∈ finset.image ⇑(equiv.prod_comm α β) f,	hq : q ∈ finset.image ⇑(equiv.prod_comm α β) f	⊢ ⇑((equiv.prod_comm α β).symm) q ∈ f
α : Type u_1,	_inst_1 : generalized_boolean_algebra α,	f : ℕ → α,	p : α → Sort ?,	hdiff : Π ⦃t : α⦄ ⦃i : ℕ⦄, p t → p (t \ f i),	disjointed_rec : Π ⦃n : ℕ⦄, p (f n) → p (disjointed f n),	n : ℕ,	h : p (f (n + 1))	⊢ p (disjointed f (n + 1))
α : Type u_1,	_inst_1 : generalized_boolean_algebra α,	f : ℕ → α,	p : α → Sort ?,	hdiff : Π ⦃t : α⦄ ⦃i : ℕ⦄, p t → p (t \ f i),	disjointed_rec : Π ⦃n : ℕ⦄, p (f n) → p (disjointed f n),	n : ℕ,	h : p (f (n + 1)),	H : Π (k : ℕ), p (f (n + 1) \ ⇑(partial_sups f) k)	⊢ p (disjointed f (n + 1))		α : Type u_1,	_inst_1 : generalized_boolean_algebra α,	f : ℕ → α,	p : α → Sort ?,	hdiff : Π ⦃t : α⦄ ⦃i : ℕ⦄, p t → p (t \ f i),	disjointed_rec : Π ⦃n : ℕ⦄, p (f n) → p (disjointed f n),	n : ℕ,	h : p (f (n + 1))	⊢ Π (k : ℕ), p (f (n + 1) \ ⇑(partial_sups f) k)
α : Type u_1,	_inst_1 : generalized_boolean_algebra α,	f : ℕ → α,	p : α → Sort ?,	hdiff : Π ⦃t : α⦄ ⦃i : ℕ⦄, p t → p (t \ f i),	disjointed_rec : Π ⦃n : ℕ⦄, p (f n) → p (disjointed f n),	n : ℕ,	h : p (f (n + 1)),	H : Π (k : ℕ), p (f (n + 1) \ ⇑(partial_sups f) k)	⊢ p (disjointed f (n + 1))
α : Type u_1,	_inst_1 : generalized_boolean_algebra α,	f : ℕ → α,	p : α → Sort ?,	hdiff : Π ⦃t : α⦄ ⦃i : ℕ⦄, p t → p (t \ f i),	disjointed_rec : Π ⦃n : ℕ⦄, p (f n) → p (disjointed f n),	n : ℕ,	h : p (f (n + 1))	⊢ Π (k : ℕ), p (f (n + 1) \ ⇑(partial_sups f) k)
α : Type u_1,	_inst_1 : generalized_boolean_algebra α,	f : ℕ → α,	p : α → Sort ?,	hdiff : Π ⦃t : α⦄ ⦃i : ℕ⦄, p t → p (t \ f i),	disjointed_rec : Π ⦃n : ℕ⦄, p (f n) → p (disjointed f n),	n : ℕ,	h : p (f (n + 1)),	k : ℕ	⊢ p (f (n + 1) \ ⇑(partial_sups f) k)
α : Type u_1,	_inst_1 : generalized_boolean_algebra α,	f : ℕ → α,	p : α → Sort ?,	hdiff : Π ⦃t : α⦄ ⦃i : ℕ⦄, p t → p (t \ f i),	disjointed_rec : Π ⦃n : ℕ⦄, p (f n) → p (disjointed f n),	n : ℕ,	h : p (f (n + 1))	⊢ p (f (n + 1) \ ⇑(partial_sups f) 0)		case nat.succ	α : Type u_1,	_inst_1 : generalized_boolean_algebra α,	f : ℕ → α,	p : α → Sort ?,	hdiff : Π ⦃t : α⦄ ⦃i : ℕ⦄, p t → p (t \ f i),	disjointed_rec : Π ⦃n : ℕ⦄, p (f n) → p (disjointed f n),	n : ℕ,	h : p (f (n + 1)),	k : ℕ,	ih : p (f (n + 1) \ ⇑(partial_sups f) k)	⊢ p (f (n + 1) \ ⇑(partial_sups f) k.succ)
α : Type u_1,	_inst_1 : generalized_boolean_algebra α,	f : ℕ → α,	p : α → Sort ?,	hdiff : Π ⦃t : α⦄ ⦃i : ℕ⦄, p t → p (t \ f i),	disjointed_rec : Π ⦃n : ℕ⦄, p (f n) → p (disjointed f n),	n : ℕ,	h : p (f (n + 1))	⊢ p (f (n + 1) \ ⇑(partial_sups f) 0)
α : Type u_1,	_inst_1 : generalized_boolean_algebra α,	f : ℕ → α,	p : α → Sort ?,	hdiff : Π ⦃t : α⦄ ⦃i : ℕ⦄, p t → p (t \ f i),	disjointed_rec : Π ⦃n : ℕ⦄, p (f n) → p (disjointed f n),	n : ℕ,	h : p (f (n + 1)),	k : ℕ,	ih : p (f (n + 1) \ ⇑(partial_sups f) k)	⊢ p (f (n + 1) \ ⇑(partial_sups f) k.succ)
α : Type u_1,	_inst_1 : generalized_boolean_algebra α,	f : ℕ → α,	p : α → Sort ?,	hdiff : Π ⦃t : α⦄ ⦃i : ℕ⦄, p t → p (t \ f i),	disjointed_rec : Π ⦃n : ℕ⦄, p (f n) → p (disjointed f n),	n : ℕ,	h : p (f (n + 1)),	k : ℕ,	ih : p (f (n + 1) \ ⇑(partial_sups f) k)	⊢ p (f (n + 1) \ ⇑(partial_sups f) k \ f (k + 1))
α : Type u_3,	β : Type u_4,	_inst_1 : preorder β,	m : α → β,	f : filter α	⊢ filter.tendsto m f filter.at_top ↔ ∀ (b : β), ∀ᶠ (a : α) in f, b ≤ m a
P : ℕ → Prop,	h : ∃ᶠ (n : ℕ) in filter.at_top, P n	⊢ ∃ (φ : ℕ → ℕ), strict_mono φ ∧ ∀ (n : ℕ), P (φ n)
P : ℕ → Prop,	h : ∀ (a : ℕ), ∃ (b : ℕ) (H : b > a), P b	⊢ ∃ (φ : ℕ → ℕ), strict_mono φ ∧ ∀ (n : ℕ), P (φ n)
α : Type u_3,	β : Type u_4,	_inst_1 : ordered_ring α,	l : filter β,	f g : β → α,	hf : filter.tendsto f l filter.at_bot,	hg : filter.tendsto g l filter.at_bot,	this : filter.tendsto (λ (x : β), -f x * -g x) l filter.at_top	⊢ filter.tendsto (λ (x : β), f x * g x) l filter.at_top
β : Type u_4,	γ : Type u_5,	i : β → γ,	j : γ → β,	h : function.left_inverse j i,	a : β	⊢ a ∈ finset.image j {i a}
n m : ℕ	⊢ ∃ (z : set ℕ) (H : z ∈ set.range set.Ici), z ⊆ set.Ici n ∩ set.Ici m
n m : ℕ	⊢ set.Ici (linear_order.max n m) ⊆ set.Ici n ∩ set.Ici m
n m p : ℕ,	p_in : p ∈ set.Ici (linear_order.max n m)	⊢ p ∈ set.Ici n ∩ set.Ici m
n m p : ℕ,	p_in : p ∈ set.Ici (linear_order.max n m)	⊢ p ∈ set.Ici n
n m p : ℕ,	p_in : p ∈ set.Ici (linear_order.max n m)	⊢ p ∈ set.Ici m
n m p : ℕ,	p_in : p ∈ set.Ici (linear_order.max n m)	⊢ p ∈ set.Ici n ∩ set.Ici m
n m p : ℕ,	p_in : linear_order.max n m ≤ p	⊢ n ≤ p		n m p : ℕ,	p_in : linear_order.max n m ≤ p	⊢ m ≤ p
n m p : ℕ,	p_in : linear_order.max n m ≤ p	⊢ m ≤ p
α : Type u_1,	ι : Sort u_4,	p : ι → Prop,	s : ι → set α,	h : filter.is_basis p s,	t : set α	⊢ t ∈ h.filter ↔ ∃ (i : ι) (hi : p i), s i ⊆ t
α : Type u_1,	β : Type u_2,	ι : Sort u_4,	la : filter α,	pa : ι → Prop,	sa : ι → set α,	lb : filter β,	f : α → β,	hla : la.has_basis pa sa	⊢ (∀ (t : set β), t ∈ lb → (∃ (i : ι) (hi : pa i), sa i ⊆ f ⁻¹' t)) ↔ ∀ (t : set β), t ∈ lb → (∃ (i : ι) (hi : pa i), set.maps_to f (sa i) t)
α : Type u_1,	β : Type u_2,	ι : Sort u_4,	la : filter α,	pa : ι → Prop,	sa : ι → set α,	lb : filter β,	f : α → β,	hla : la.has_basis pa sa	⊢ filter.tendsto f la lb ↔ ∀ (t : set β), t ∈ lb → (∃ (i : ι) (hi : pa i), set.maps_to f (sa i) t)
⊢ ∀ {x y : set ℕ}, x ∈ set.range set.Ici → y ∈ set.range set.Ici → (∃ (z : set ℕ) (H : z ∈ set.range set.Ici), z ⊆ x ∩ y)
α : Type u,	β : Type v,	f : filter α,	m : α → β	⊢ m '' set.univ ∈ filter.map m f
α : Type u,	β : Type v,	f : filter α,	m : α → β	⊢ set.range m ∈ filter.map m f
α : Type u,	β : Type v,	f : filter α,	m : α → β,	h : function.injective m,	s : set α,	hs : s ∈ f	⊢ m ⁻¹' (m '' s) ⊆ s
α : Type u,	β : Type v,	f₁ f₂ : filter α,	g : filter β	⊢ f₁ ⊔ f₂ ×ᶠ g = (f₁ ×ᶠ g) ⊔ (f₂ ×ᶠ g)
α : Type u,	β : Type v,	a : α,	f : filter β	⊢ has_pure.pure a ×ᶠ f = filter.map (prod.mk a) f
α : Type u_2,	l₁ l₂ : filter α,	_inst_2 : countable_Inter_filter l₁,	_inst_3 : countable_Inter_filter l₂	⊢ countable_Inter_filter (l₁ ⊓ l₂)
α : Type u_2,	l₁ l₂ : filter α,	_inst_2 : countable_Inter_filter l₁,	_inst_3 : countable_Inter_filter l₂,	S : set (set α),	hSc : set.countable S,	hS : ∀ (s : set α), s ∈ S → s ∈ l₁ ⊓ l₂	⊢ ⋂₀ S ∈ l₁ ⊓ l₂
α : Type u_2,	l₁ l₂ : filter α,	_inst_2 : countable_Inter_filter l₁,	_inst_3 : countable_Inter_filter l₂,	S : set (set α),	hSc : set.countable S,	s : Π (s : set α), s ∈ S → set α,	hs : ∀ (s_1 : set α) (H : s_1 ∈ S), s s_1 H ∈ l₁,	t : Π (s : set α), s ∈ S → set α,	ht : ∀ (s : set α) (H : s ∈ S), t s H ∈ l₂,	hst : ∀ (s_1 : set α) (H : s_1 ∈ S), s_1 = s s_1 H ∩ t s_1 H	⊢ ⋂₀ S ∈ l₁ ⊓ l₂
α : Type u_2,	l₁ l₂ : filter α,	_inst_2 : countable_Inter_filter l₁,	_inst_3 : countable_Inter_filter l₂,	S : set (set α),	hSc : set.countable S,	s t : Π (s : set α), s ∈ S → set α,	ht : ∀ (s : set α) (H : s ∈ S), t s H ∈ l₂,	hst : ∀ (s_1 : set α) (H : s_1 ∈ S), s_1 = s s_1 H ∩ t s_1 H,	hs : (⋂ (i : set α) (H : i ∈ S), s i H) ∈ l₁	⊢ ⋂₀ S ∈ l₁ ⊓ l₂
α : Type u_2,	l₁ l₂ : filter α,	_inst_2 : countable_Inter_filter l₁,	_inst_3 : countable_Inter_filter l₂,	S : set (set α),	hSc : set.countable S,	s t : Π (s : set α), s ∈ S → set α,	hst : ∀ (s_1 : set α) (H : s_1 ∈ S), s_1 = s s_1 H ∩ t s_1 H,	hs : (⋂ (i : set α) (H : i ∈ S), s i H) ∈ l₁,	ht : (⋂ (i : set α) (H : i ∈ S), t i H) ∈ l₂	⊢ ⋂₀ S ∈ l₁ ⊓ l₂
α : Type u_2,	l₁ l₂ : filter α,	_inst_2 : countable_Inter_filter l₁,	_inst_3 : countable_Inter_filter l₂,	S : set (set α),	hSc : set.countable S,	s t : Π (s : set α), s ∈ S → set α,	hst : ∀ (s_1 : set α) (H : s_1 ∈ S), s_1 = s s_1 H ∩ t s_1 H,	hs : (⋂ (i : set α) (H : i ∈ S), s i H) ∈ l₁,	ht : (⋂ (i : set α) (H : i ∈ S), t i H) ∈ l₂,	i : set α,	hi : i ∈ S	⊢ ((⋂ (i : set α) (H : i ∈ S), s i H) ∩ ⋂ (i : set α) (H : i ∈ S), t i H) ⊆ i
α : Type u_2,	l₁ l₂ : filter α,	_inst_2 : countable_Inter_filter l₁,	_inst_3 : countable_Inter_filter l₂,	S : set (set α),	hSc : set.countable S,	s t : Π (s : set α), s ∈ S → set α,	hst : ∀ (s_1 : set α) (H : s_1 ∈ S), s_1 = s s_1 H ∩ t s_1 H,	hs : (⋂ (i : set α) (H : i ∈ S), s i H) ∈ l₁,	ht : (⋂ (i : set α) (H : i ∈ S), t i H) ∈ l₂,	i : set α,	hi : i ∈ S	⊢ ((⋂ (i : set α) (H : i ∈ S), s i H) ∩ ⋂ (i : set α) (H : i ∈ S), t i H) ⊆ s i hi ∩ t i hi
α : Type u_2,	l₁ l₂ : filter α,	_inst_2 : countable_Inter_filter l₁,	_inst_3 : countable_Inter_filter l₂,	S : set (set α),	hSc : set.countable S,	s t : Π (s : set α), s ∈ S → set α,	hst : ∀ (s_1 : set α) (H : s_1 ∈ S), s_1 = s s_1 H ∩ t s_1 H,	hs : (⋂ (i : set α) (H : i ∈ S), s i H) ∈ l₁,	ht : (⋂ (i : set α) (H : i ∈ S), t i H) ∈ l₂,	i : set α,	hi : i ∈ S	⊢ (⋂ (i : set α) (H : i ∈ S), s i H) ⊆ s i hi
α : Type u_2,	l₁ l₂ : filter α,	_inst_2 : countable_Inter_filter l₁,	_inst_3 : countable_Inter_filter l₂,	S : set (set α),	hSc : set.countable S,	s t : Π (s : set α), s ∈ S → set α,	hst : ∀ (s_1 : set α) (H : s_1 ∈ S), s_1 = s s_1 H ∩ t s_1 H,	hs : (⋂ (i : set α) (H : i ∈ S), s i H) ∈ l₁,	ht : (⋂ (i : set α) (H : i ∈ S), t i H) ∈ l₂,	i : set α,	hi : i ∈ S	⊢ (⋂ (i : set α) (H : i ∈ S), t i H) ⊆ t i hi
α : Type u_2,	l₁ l₂ : filter α,	_inst_2 : countable_Inter_filter l₁,	_inst_3 : countable_Inter_filter l₂,	S : set (set α),	hSc : set.countable S,	s t : Π (s : set α), s ∈ S → set α,	hst : ∀ (s_1 : set α) (H : s_1 ∈ S), s_1 = s s_1 H ∩ t s_1 H,	hs : (⋂ (i : set α) (H : i ∈ S), s i H) ∈ l₁,	ht : (⋂ (i : set α) (H : i ∈ S), t i H) ∈ l₂,	i : set α,	hi : i ∈ S	⊢ ((⋂ (i : set α) (H : i ∈ S), s i H) ∩ ⋂ (i : set α) (H : i ∈ S), t i H) ⊆ s i hi ∩ t i hi
ι : Type u_1,	α : Type u_2,	l : filter α,	_inst_1 : countable_Inter_filter l,	S : set ι,	hS : S.countable,	p : α → Π (i : ι), i ∈ S → Prop	⊢ (∀ᶠ (x : α) in l, ∀ (i : ι) (H : i ∈ S), p x i H) ↔ ∀ (i : ι) (H : i ∈ S), ∀ᶠ (x : α) in l, p x i H
α : Type u_1,	β : Type u_2,	g : set α → filter β	⊢ ⊤.lift g = g set.univ
α : Type u,	β : Type v,	_inst_1 : monoid α,	_inst_2 : monoid β,	m : mul_hom α β,	f₁ f₂ : filter β	⊢ filter.comap ⇑m f₁ * filter.comap ⇑m f₂ ≤ filter.comap ⇑m (f₁ * f₂)
α : Type u,	β : Type v,	_inst_1 : monoid α,	_inst_2 : monoid β,	m : mul_hom α β,	f₁ f₂ : filter β,	s : set α,	t : set β,	mt : ⇑m ⁻¹' t ⊆ s,	t₁ t₂ : set β,	ht₁ : t₁ ∈ f₁,	ht₂ : t₂ ∈ f₂,	t₁t₂ : t₁ * t₂ ⊆ t	⊢ s ∈ filter.comap ⇑m f₁ * filter.comap ⇑m f₂
α : Type u,	β : Type v,	_inst_1 : monoid α,	_inst_2 : monoid β,	m : mul_hom α β,	f₁ f₂ : filter β,	s : set α,	t : set β,	mt : ⇑m ⁻¹' t ⊆ s,	t₁ t₂ : set β,	ht₁ : t₁ ∈ f₁,	ht₂ : t₂ ∈ f₂,	t₁t₂ : t₁ * t₂ ⊆ t	⊢ ⇑m ⁻¹' t₁ * ⇑m ⁻¹' t₂ ⊆ s
α : Type u,	β : Type v,	_inst_1 : monoid α,	_inst_2 : monoid β,	m : mul_hom α β,	f₁ f₂ : filter β,	s : set α,	t : set β,	mt : ⇑m ⁻¹' t ⊆ s,	t₁ t₂ : set β,	ht₁ : t₁ ∈ f₁,	ht₂ : t₂ ∈ f₂,	t₁t₂ : t₁ * t₂ ⊆ t,	this : ⇑m ⁻¹' (t₁ * t₂) ⊆ s	⊢ ⇑m ⁻¹' t₁ * ⇑m ⁻¹' t₂ ⊆ s
α : Type u,	β : Type v,	l : α → β,	u : β → α,	_inst_1 : partial_order β,	_inst_2 : semilattice_inf α,	gi : galois_insertion l u	⊢ ∀ (a b : β), a ⊓ b ≤ a
α : Type u,	β : Type v,	l : α → β,	u : β → α,	_inst_1 : partial_order β,	_inst_2 : semilattice_inf α,	gi : galois_insertion l u	⊢ ∀ (a b : β), a ⊓ b ≤ a
α : Type u,	β : Type v,	l : α → β,	u : β → α,	_inst_1 : partial_order β,	_inst_2 : semilattice_inf α,	gi : galois_insertion l u	⊢ ∀ (a b : β), l (u a ⊓ u b) ≤ a
α : Type u,	β : Type v,	l : α → β,	u : β → α,	_inst_1 : partial_order β,	_inst_2 : semilattice_inf α,	gi : galois_insertion l u	⊢ ∀ (a b : β), a ⊓ b ≤ b
α : Type u,	β : Type v,	l : α → β,	u : β → α,	_inst_1 : partial_order β,	_inst_2 : semilattice_inf α,	gi : galois_insertion l u	⊢ ∀ (a b : β), a ⊓ b ≤ b
α : Type u,	β : Type v,	l : α → β,	u : β → α,	_inst_1 : partial_order β,	_inst_2 : semilattice_inf α,	gi : galois_insertion l u	⊢ ∀ (a b : β), l (u a ⊓ u b) ≤ b
α : Type u,	β : Type v,	l : α → β,	u : β → α,	_inst_1 : partial_order β,	_inst_2 : semilattice_inf α,	gi : galois_insertion l u	⊢ ∀ (a b c : β), a ≤ b → a ≤ c → a ≤ b ⊓ c
α : Type u,	β : Type v,	l : α → β,	u : β → α,	_inst_1 : partial_order β,	_inst_2 : semilattice_inf α,	gi : galois_insertion l u	⊢ ∀ (a b c : β), a ≤ b → a ≤ c → a ≤ b ⊓ c
α : Type u,	β : Type v,	l : α → β,	u : β → α,	_inst_1 : partial_order β,	_inst_2 : semilattice_inf α,	gi : galois_insertion l u	⊢ ∀ (a b c : β), a ≤ b → a ≤ c → a ≤ l (u b ⊓ u c)
α : Type u,	_inst_1 : semilattice_sup α,	a b : α	⊢ a ⊔ (a ⊔ b) = a ⊔ b
α : Type u,	_inst_1 : semilattice_sup α,	a b c : α	⊢ a ⊔ (b ⊔ c) = b ⊔ (a ⊔ c)
α : Type u,	_inst_1 : semilattice_sup α,	a : α,	this : (∃ (b : α), ¬b ≤ a) → (∃ (b : α), a < b)	⊢ (∀ (b : α), b ≤ a) ∨ ∃ (b : α), a < b
α : Type u,	_inst_1 : semilattice_inf α,	a b : α	⊢ a ⊓ b ≤ b ∧ b ≤ a ⊓ b ↔ b ≤ a
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β	⊢ (a₁, b₁) ≤ (a₂, b₂) ∨ (a₂, b₂) ≤ (a₁, b₁)
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β	⊢ (a₁, b₁) ≤ (a₂, b₂) ∨ (a₂, b₂) ≤ (a₁, b₁)
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	ha : a₁ ≤ a₂	⊢ (a₁, b₁) ≤ (a₂, b₂) ∨ (a₂, b₂) ≤ (a₁, b₁)
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	ha : a₂ ≤ a₁	⊢ (a₁, b₁) ≤ (a₂, b₂) ∨ (a₂, b₂) ≤ (a₁, b₁)
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	ha : a₁ ≤ a₂,	a_lt : a₁ < a₂	⊢ (a₁, b₁) ≤ (a₂, b₂)
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	ha : a₁ ≤ a₂,	a_lt : a₁ < a₂	⊢ a₁ < a₂
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	ha : a₁ ≤ a₂,	a_lt : a₁ < a₂	⊢ (a₁, b₁) ≤ (a₂, b₂) ∨ (a₂, b₂) ≤ (a₁, b₁)		case or.inr	α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	ha : a₁ ≤ a₂,	a_eq : a₁ = a₂	⊢ (a₁, b₁) ≤ (a₂, b₂) ∨ (a₂, b₂) ≤ (a₁, b₁)		case or.inl	α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	ha : a₂ ≤ a₁,	a_lt : a₂ < a₁	⊢ (a₁, b₁) ≤ (a₂, b₂) ∨ (a₂, b₂) ≤ (a₁, b₁)		case or.inr	α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	ha : a₂ ≤ a₁,	a_eq : a₂ = a₁	⊢ (a₁, b₁) ≤ (a₂, b₂) ∨ (a₂, b₂) ≤ (a₁, b₁)
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	ha : a₁ ≤ a₂,	a_lt : a₁ < a₂	⊢ (a₁, b₁) ≤ (a₂, b₂) ∨ (a₂, b₂) ≤ (a₁, b₁)
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	ha : a₁ ≤ a₂,	a_eq : a₁ = a₂	⊢ (a₁, b₁) ≤ (a₂, b₂) ∨ (a₂, b₂) ≤ (a₁, b₁)		case or.inl	α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	ha : a₂ ≤ a₁,	a_lt : a₂ < a₁	⊢ (a₁, b₁) ≤ (a₂, b₂) ∨ (a₂, b₂) ≤ (a₁, b₁)		case or.inr	α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	ha : a₂ ≤ a₁,	a_eq : a₂ = a₁	⊢ (a₁, b₁) ≤ (a₂, b₂) ∨ (a₂, b₂) ≤ (a₁, b₁)
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	ha : a₂ ≤ a₁,	a_lt : a₂ < a₁	⊢ (a₂, b₂) ≤ (a₁, b₁)
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	ha : a₂ ≤ a₁,	a_lt : a₂ < a₁	⊢ a₂ < a₁
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	ha : a₂ ≤ a₁,	a_lt : a₂ < a₁	⊢ (a₁, b₁) ≤ (a₂, b₂) ∨ (a₂, b₂) ≤ (a₁, b₁)		case or.inr	α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	ha : a₁ ≤ a₂,	a_eq : a₁ = a₂	⊢ (a₁, b₁) ≤ (a₂, b₂) ∨ (a₂, b₂) ≤ (a₁, b₁)		case or.inr	α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	ha : a₂ ≤ a₁,	a_eq : a₂ = a₁	⊢ (a₁, b₁) ≤ (a₂, b₂) ∨ (a₂, b₂) ≤ (a₁, b₁)
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	ha : a₂ ≤ a₁,	a_lt : a₂ < a₁	⊢ (a₁, b₁) ≤ (a₂, b₂) ∨ (a₂, b₂) ≤ (a₁, b₁)
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	ha : a₁ ≤ a₂,	a_eq : a₁ = a₂	⊢ (a₁, b₁) ≤ (a₂, b₂) ∨ (a₂, b₂) ≤ (a₁, b₁)
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	ha : a₂ ≤ a₁,	a_eq : a₂ = a₁	⊢ (a₁, b₁) ≤ (a₂, b₂) ∨ (a₂, b₂) ≤ (a₁, b₁)
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ b₂ : β,	ha : a₁ ≤ a₁	⊢ (a₁, b₁) ≤ (a₁, b₂) ∨ (a₁, b₂) ≤ (a₁, b₁)
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	b₁ : β,	a₂ : α,	b₂ : β,	ha : a₂ ≤ a₂	⊢ (a₂, b₁) ≤ (a₂, b₂) ∨ (a₂, b₂) ≤ (a₂, b₁)
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	ha : a₁ ≤ a₂,	a_eq : a₁ = a₂	⊢ (a₁, b₁) ≤ (a₂, b₂) ∨ (a₂, b₂) ≤ (a₁, b₁)		case or.inr	α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	ha : a₂ ≤ a₁,	a_eq : a₂ = a₁	⊢ (a₁, b₁) ≤ (a₂, b₂) ∨ (a₂, b₂) ≤ (a₁, b₁)
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ b₂ : β,	ha : a₁ ≤ a₁,	hb : b₁ ≤ b₂	⊢ (a₁, b₁) ≤ (a₁, b₂)
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ b₂ : β,	ha : a₁ ≤ a₁,	hb : b₁ ≤ b₂	⊢ b₁ ≤ b₂
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ b₂ : β,	ha : a₁ ≤ a₁,	hb : b₁ ≤ b₂	⊢ (a₁, b₁) ≤ (a₁, b₂) ∨ (a₁, b₂) ≤ (a₁, b₁)		α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ b₂ : β,	ha : a₁ ≤ a₁,	hb : b₂ ≤ b₁	⊢ (a₁, b₁) ≤ (a₁, b₂) ∨ (a₁, b₂) ≤ (a₁, b₁)		α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	b₁ : β,	a₂ : α,	b₂ : β,	ha : a₂ ≤ a₂,	hb : b₁ ≤ b₂	⊢ (a₂, b₁) ≤ (a₂, b₂) ∨ (a₂, b₂) ≤ (a₂, b₁)		α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	b₁ : β,	a₂ : α,	b₂ : β,	ha : a₂ ≤ a₂,	hb : b₂ ≤ b₁	⊢ (a₂, b₁) ≤ (a₂, b₂) ∨ (a₂, b₂) ≤ (a₂, b₁)
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ b₂ : β,	ha : a₁ ≤ a₁,	hb : b₁ ≤ b₂	⊢ (a₁, b₁) ≤ (a₁, b₂) ∨ (a₁, b₂) ≤ (a₁, b₁)
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ b₂ : β,	ha : a₁ ≤ a₁,	hb : b₂ ≤ b₁	⊢ (a₁, b₂) ≤ (a₁, b₁)
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ b₂ : β,	ha : a₁ ≤ a₁,	hb : b₂ ≤ b₁	⊢ b₂ ≤ b₁
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ b₂ : β,	ha : a₁ ≤ a₁,	hb : b₂ ≤ b₁	⊢ (a₁, b₁) ≤ (a₁, b₂) ∨ (a₁, b₂) ≤ (a₁, b₁)		α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	b₁ : β,	a₂ : α,	b₂ : β,	ha : a₂ ≤ a₂,	hb : b₁ ≤ b₂	⊢ (a₂, b₁) ≤ (a₂, b₂) ∨ (a₂, b₂) ≤ (a₂, b₁)		α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	b₁ : β,	a₂ : α,	b₂ : β,	ha : a₂ ≤ a₂,	hb : b₂ ≤ b₁	⊢ (a₂, b₁) ≤ (a₂, b₂) ∨ (a₂, b₂) ≤ (a₂, b₁)
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ b₂ : β,	ha : a₁ ≤ a₁,	hb : b₂ ≤ b₁	⊢ (a₁, b₁) ≤ (a₁, b₂) ∨ (a₁, b₂) ≤ (a₁, b₁)
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	b₁ : β,	a₂ : α,	b₂ : β,	ha : a₂ ≤ a₂,	hb : b₁ ≤ b₂	⊢ (a₂, b₁) ≤ (a₂, b₂)
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	b₁ : β,	a₂ : α,	b₂ : β,	ha : a₂ ≤ a₂,	hb : b₁ ≤ b₂	⊢ b₁ ≤ b₂
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	b₁ : β,	a₂ : α,	b₂ : β,	ha : a₂ ≤ a₂,	hb : b₁ ≤ b₂	⊢ (a₂, b₁) ≤ (a₂, b₂) ∨ (a₂, b₂) ≤ (a₂, b₁)		α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	b₁ : β,	a₂ : α,	b₂ : β,	ha : a₂ ≤ a₂,	hb : b₂ ≤ b₁	⊢ (a₂, b₁) ≤ (a₂, b₂) ∨ (a₂, b₂) ≤ (a₂, b₁)
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	b₁ : β,	a₂ : α,	b₂ : β,	ha : a₂ ≤ a₂,	hb : b₁ ≤ b₂	⊢ (a₂, b₁) ≤ (a₂, b₂) ∨ (a₂, b₂) ≤ (a₂, b₁)
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	b₁ : β,	a₂ : α,	b₂ : β,	ha : a₂ ≤ a₂,	hb : b₂ ≤ b₁	⊢ (a₂, b₂) ≤ (a₂, b₁)
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	b₁ : β,	a₂ : α,	b₂ : β,	ha : a₂ ≤ a₂,	hb : b₂ ≤ b₁	⊢ b₂ ≤ b₁
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	b₁ : β,	a₂ : α,	b₂ : β,	ha : a₂ ≤ a₂,	hb : b₂ ≤ b₁	⊢ (a₂, b₁) ≤ (a₂, b₂) ∨ (a₂, b₂) ≤ (a₂, b₁)
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β	⊢ decidable_rel has_le.le
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β	⊢ decidable ((a₁, b₁) ≤ (a₂, b₂))
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	a_lt : ¬a₁ ≤ a₂	⊢ ¬(a₁, b₁) ≤ (a₂, b₂)
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	a_lt : a₂ < a₁	⊢ ¬(a₁, b₁) ≤ (a₂, b₂)
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	a_lt : ¬a₁ ≤ a₂	⊢ decidable ((a₁, b₁) ≤ (a₂, b₂))
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	a_lt : a₂ < a₁,	ᾰ_h : a₁ < a₂	⊢ a₂ < a₂
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	a_lt : a₂ < a₁,	ᾰ_h : a₁ < a₂	⊢ a₂ < ?m_1		α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	a_lt : a₂ < a₁,	ᾰ_h : a₁ < a₂	⊢ ?m_1 < a₂		α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	a_lt : a₂ < a₁,	ᾰ_h : a₁ < a₂	⊢ α
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	a_lt : a₂ < a₁,	ᾰ_h : a₁ < a₂	⊢ a₂ < ?m_1
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	a_lt : a₂ < a₁,	ᾰ_h : a₁ < a₂	⊢ a₁ < a₂

α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	a_lt : a₂ < a₁,	ᾰ_h : a₁ < a₂	⊢ false		α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ b₂ : β,	a_lt : a₁ < a₁,	ᾰ : (a₁, b₁) ≤ (a₁, b₂),	ᾰ_h : b₁ ≤ b₂	⊢ false
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	a_lt : a₂ < a₁,	ᾰ_h : a₁ < a₂	⊢ false
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ b₂ : β,	a_lt : a₁ < a₁,	ᾰ : (a₁, b₁) ≤ (a₁, b₂),	ᾰ_h : b₁ ≤ b₂	⊢ a₁ < a₁
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	a_lt : ¬a₁ ≤ a₂	⊢ decidable ((a₁, b₁) ≤ (a₂, b₂))		α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	a_le : a₁ ≤ a₂	⊢ decidable ((a₁, b₁) ≤ (a₂, b₂))
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ b₂ : β,	a_lt : a₁ < a₁,	ᾰ : (a₁, b₁) ≤ (a₁, b₂),	ᾰ_h : b₁ ≤ b₂	⊢ false
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	a_le : a₁ ≤ a₂	⊢ decidable ((a₁, b₁) ≤ (a₂, b₂))
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	a_le : a₁ ≤ a₂,	h : a₁ = a₂	⊢ decidable ((a₁, b₁) ≤ (a₂, b₂))
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	a_le : a₁ ≤ a₂,	h : a₁ = a₂	⊢ decidable ((a₂, b₁) ≤ (a₂, b₂))
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	a_le : a₁ ≤ a₂,	h : a₁ = a₂,	b_lt : ¬b₁ ≤ b₂	⊢ decidable ((a₂, b₁) ≤ (a₂, b₂))
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	a_le : a₁ ≤ a₂,	h : a₁ = a₂,	b_lt : ¬b₁ ≤ b₂	⊢ ¬(a₂, b₁) ≤ (a₂, b₂)
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	a_le : a₁ ≤ a₂,	h : a₁ = a₂,	b_lt : b₂ < b₁	⊢ ¬(a₂, b₁) ≤ (a₂, b₂)
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	a_le : a₁ ≤ a₂,	h : a₁ = a₂,	b_lt : b₂ < b₁,	ᾰ_h : a₂ < a₂	⊢ false
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	a_le : a₁ ≤ a₂,	h : a₁ = a₂,	b_lt : b₂ < b₁,	ᾰ_h : a₂ < a₂	⊢ a₂ < a₂
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	a_le : a₁ ≤ a₂,	h : a₁ = a₂,	b_lt : b₂ < b₁,	ᾰ_h : a₂ < a₂	⊢ false		α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	a_le : a₁ ≤ a₂,	h : a₁ = a₂,	b_lt : b₂ < b₁,	ᾰ_h : b₁ ≤ b₂	⊢ false
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	a_le : a₁ ≤ a₂,	h : a₁ = a₂,	b_lt : b₂ < b₁,	ᾰ_h : b₁ ≤ b₂	⊢ false
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	a_le : a₁ ≤ a₂,	h : a₁ = a₂,	b_lt : b₂ < b₁,	ᾰ_h : b₁ ≤ b₂	⊢ b₂ < b₂
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	a_le : a₁ ≤ a₂,	h : a₁ = a₂,	b_lt : b₂ < b₁,	ᾰ_h : b₁ ≤ b₂	⊢ b₂ < ?m_1		α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	a_le : a₁ ≤ a₂,	h : a₁ = a₂,	b_lt : b₂ < b₁,	ᾰ_h : b₁ ≤ b₂	⊢ ?m_1 ≤ b₂		α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	a_le : a₁ ≤ a₂,	h : a₁ = a₂,	b_lt : b₂ < b₁,	ᾰ_h : b₁ ≤ b₂	⊢ β
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	a_le : a₁ ≤ a₂,	h : a₁ = a₂,	b_lt : b₂ < b₁,	ᾰ_h : b₁ ≤ b₂	⊢ b₂ < ?m_1
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	a_le : a₁ ≤ a₂,	h : a₁ = a₂,	b_lt : b₂ < b₁,	ᾰ_h : b₁ ≤ b₂	⊢ b₁ ≤ b₂
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	a_le : a₁ ≤ a₂,	h : a₁ = a₂,	b_lt : ¬b₁ ≤ b₂	⊢ decidable ((a₂, b₁) ≤ (a₂, b₂))		α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	a_le : a₁ ≤ a₂,	h : a₁ = a₂,	b_le : b₁ ≤ b₂	⊢ decidable ((a₂, b₁) ≤ (a₂, b₂))
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	a_le : a₁ ≤ a₂,	h : a₁ = a₂,	b_le : b₁ ≤ b₂	⊢ decidable ((a₂, b₁) ≤ (a₂, b₂))
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	a_le : a₁ ≤ a₂,	h : a₁ = a₂,	b_le : b₁ ≤ b₂	⊢ (a₂, b₁) ≤ (a₂, b₂)
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	a_le : a₁ ≤ a₂,	h : a₁ = a₂,	b_le : b₁ ≤ b₂	⊢ b₁ ≤ b₂
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	a_le : a₁ ≤ a₂,	h : a₁ = a₂	⊢ decidable ((a₁, b₁) ≤ (a₂, b₂))		α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	a_le : a₁ ≤ a₂,	h : ¬a₁ = a₂	⊢ decidable ((a₁, b₁) ≤ (a₂, b₂))
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	a_le : a₁ ≤ a₂,	h : ¬a₁ = a₂	⊢ (a₁, b₁) ≤ (a₂, b₂)
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	a_le : a₁ ≤ a₂,	h : ¬a₁ = a₂	⊢ a₁ < a₂
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	a_le : a₁ ≤ a₂,	h : ¬a₁ = a₂	⊢ a₁ ≤ a₂		α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	a_le : a₁ ≤ a₂,	h : ¬a₁ = a₂	⊢ a₁ ≠ a₂
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	a_le : a₁ ≤ a₂,	h : ¬a₁ = a₂	⊢ a₁ ≤ a₂
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	a_le : a₁ ≤ a₂,	h : ¬a₁ = a₂	⊢ a₁ ≠ a₂
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β,	a₁ : α,	b₁ : β,	a₂ : α,	b₂ : β,	a_le : a₁ ≤ a₂,	h : ¬a₁ = a₂	⊢ decidable ((a₁, b₁) ≤ (a₂, b₂))
α : Type u,	β : Type v,	_inst_1 : linear_order α,	_inst_2 : linear_order β	⊢ ∀ (a b : lex α β), a ≤ b ∨ b ≤ a
α : Type u_1,	_inst_1 : complete_lattice α,	f : ℕ → α,	k : ℕ	⊢ (⨆ (n : ℕ), ⨅ (i : ℕ) (H : i ≥ n), f (i + k)) = ⨆ (n : ℕ), ⨅ (i : ℕ) (H : i ≥ n), f i
α : Type u_1,	_inst_1 : complete_lattice α,	f : ℕ → α,	k : ℕ	⊢ filter.at_top.liminf (λ (i : ℕ), f (i + k)) = filter.at_top.liminf f
α : Type u,	β : Type v,	_inst_1 : omega_complete_partial_order α,	_inst_2 : partial_order β,	f : β →ₘ α,	ωSup₀ : omega_complete_partial_order.chain β → β,	h : ∀ (x y : β), ⇑f x ≤ ⇑f y → x ≤ y,	h' : ∀ (c : omega_complete_partial_order.chain β), ⇑f (ωSup₀ c) = omega_complete_partial_order.ωSup (c.map f),	c : omega_complete_partial_order.chain β,	x : β,	hx : ∀ (i : ℕ), ⇑c i ≤ x	⊢ ⇑f (ωSup₀ c) ≤ ⇑f x
α : Type u,	β : Type v,	_inst_1 : omega_complete_partial_order α,	_inst_2 : partial_order β,	f : β →ₘ α,	ωSup₀ : omega_complete_partial_order.chain β → β,	h : ∀ (x y : β), ⇑f x ≤ ⇑f y → x ≤ y,	h' : ∀ (c : omega_complete_partial_order.chain β), ⇑f (ωSup₀ c) = omega_complete_partial_order.ωSup (c.map f),	c : omega_complete_partial_order.chain β,	x : β,	hx : ∀ (i : ℕ), ⇑c i ≤ x	⊢ ⇑f (ωSup₀ c) ≤ ⇑f x
α : Type u,	β : Type v,	_inst_1 : omega_complete_partial_order α,	_inst_2 : partial_order β,	f : β →ₘ α,	ωSup₀ : omega_complete_partial_order.chain β → β,	h : ∀ (x y : β), ⇑f x ≤ ⇑f y → x ≤ y,	h' : ∀ (c : omega_complete_partial_order.chain β), ⇑f (ωSup₀ c) = omega_complete_partial_order.ωSup (c.map f),	c : omega_complete_partial_order.chain β,	x : β,	hx : ∀ (i : ℕ), ⇑c i ≤ x	⊢ ⇑f (ωSup₀ c) ≤ ⇑f x
α : Type u,	β : Type v,	_inst_1 : omega_complete_partial_order α,	_inst_2 : partial_order β,	f : β →ₘ α,	ωSup₀ : omega_complete_partial_order.chain β → β,	h : ∀ (x y : β), ⇑f x ≤ ⇑f y → x ≤ y,	h' : ∀ (c : omega_complete_partial_order.chain β), ⇑f (ωSup₀ c) = omega_complete_partial_order.ωSup (c.map f),	c : omega_complete_partial_order.chain β,	x : β,	hx : ∀ (i : ℕ), ⇑c i ≤ x	⊢ ⇑f (ωSup₀ c) ≤ ⇑f x
α : Type u,	β : Type v,	_inst_1 : omega_complete_partial_order α,	_inst_2 : partial_order β,	f : β →ₘ α,	ωSup₀ : omega_complete_partial_order.chain β → β,	h : ∀ (x y : β), ⇑f x ≤ ⇑f y → x ≤ y,	h' : ∀ (c : omega_complete_partial_order.chain β), ⇑f (ωSup₀ c) = omega_complete_partial_order.ωSup (c.map f),	c : omega_complete_partial_order.chain β,	x : β,	hx : ∀ (i : ℕ), ⇑c i ≤ x	⊢ omega_complete_partial_order.ωSup (c.map f) ≤ ⇑f x
α : Type u,	β : Type v,	_inst_1 : omega_complete_partial_order α,	_inst_2 : partial_order β,	f : β →ₘ α,	ωSup₀ : omega_complete_partial_order.chain β → β,	h : ∀ (x y : β), ⇑f x ≤ ⇑f y → x ≤ y,	h' : ∀ (c : omega_complete_partial_order.chain β), ⇑f (ωSup₀ c) = omega_complete_partial_order.ωSup (c.map f),	c : omega_complete_partial_order.chain β,	x : β,	hx : ∀ (i : ℕ), ⇑c i ≤ x	⊢ ∀ (i : ℕ), ⇑(c.map f) i ≤ ⇑f x
α : Type u,	β : Type v,	_inst_1 : omega_complete_partial_order α,	_inst_2 : partial_order β,	f : β →ₘ α,	ωSup₀ : omega_complete_partial_order.chain β → β,	h : ∀ (x y : β), ⇑f x ≤ ⇑f y → x ≤ y,	h' : ∀ (c : omega_complete_partial_order.chain β), ⇑f (ωSup₀ c) = omega_complete_partial_order.ωSup (c.map f),	c : omega_complete_partial_order.chain β,	x : β,	hx : ∀ (i : ℕ), ⇑c i ≤ x,	i : ℕ	⊢ ⇑(c.map f) i ≤ ⇑f x
α : Type u,	β : Type v,	_inst_1 : omega_complete_partial_order α,	_inst_2 : partial_order β,	f : β →ₘ α,	ωSup₀ : omega_complete_partial_order.chain β → β,	h : ∀ (x y : β), ⇑f x ≤ ⇑f y → x ≤ y,	h' : ∀ (c : omega_complete_partial_order.chain β), ⇑f (ωSup₀ c) = omega_complete_partial_order.ωSup (c.map f),	c : omega_complete_partial_order.chain β,	i : ℕ	⊢ ⇑f (⇑c i) ≤ ⇑f (ωSup₀ c)
α : Type u,	β : Type v,	_inst_1 : omega_complete_partial_order α,	_inst_2 : partial_order β,	f : β →ₘ α,	ωSup₀ : omega_complete_partial_order.chain β → β,	h : ∀ (x y : β), ⇑f x ≤ ⇑f y → x ≤ y,	h' : ∀ (c : omega_complete_partial_order.chain β), ⇑f (ωSup₀ c) = omega_complete_partial_order.ωSup (c.map f),	c : omega_complete_partial_order.chain β,	i : ℕ	⊢ ⇑f (⇑c i) ≤ ⇑f (ωSup₀ c)
α : Type u,	β : Type v,	_inst_1 : omega_complete_partial_order α,	_inst_2 : partial_order β,	f : β →ₘ α,	ωSup₀ : omega_complete_partial_order.chain β → β,	h : ∀ (x y : β), ⇑f x ≤ ⇑f y → x ≤ y,	h' : ∀ (c : omega_complete_partial_order.chain β), ⇑f (ωSup₀ c) = omega_complete_partial_order.ωSup (c.map f),	c : omega_complete_partial_order.chain β,	i : ℕ	⊢ ⇑f (⇑c i) ≤ omega_complete_partial_order.ωSup (c.map f)
α : Type u,	_inst_1 : omega_complete_partial_order α,	c : omega_complete_partial_order.chain α,	x : α	⊢ omega_complete_partial_order.ωSup c ≤ x → ∀ (i : ℕ), ⇑c i ≤ x
α : Type u,	_inst_1 : omega_complete_partial_order α,	c : omega_complete_partial_order.chain α,	x : α	⊢ (∀ (i : ℕ), ⇑c i ≤ x) → omega_complete_partial_order.ωSup c ≤ x
α : Type u,	_inst_1 : omega_complete_partial_order α,	c : omega_complete_partial_order.chain α,	x : α	⊢ omega_complete_partial_order.ωSup c ≤ x ↔ ∀ (i : ℕ), ⇑c i ≤ x
α : Type u,	_inst_1 : omega_complete_partial_order α,	c : omega_complete_partial_order.chain α,	x : α	⊢ omega_complete_partial_order.ωSup c ≤ x ↔ ∀ (i : ℕ), ⇑c i ≤ x
α : Type u,	_inst_1 : omega_complete_partial_order α,	c : omega_complete_partial_order.chain α,	x : α,	ᾰ : omega_complete_partial_order.ωSup c ≤ x,	i : ℕ	⊢ ⇑c i ≤ x
α : Type u,	_inst_1 : omega_complete_partial_order α,	c : omega_complete_partial_order.chain α,	x : α,	ᾰ : omega_complete_partial_order.ωSup c ≤ x,	i : ℕ	⊢ omega_complete_partial_order.ωSup c ≤ x
α : Type u,	_inst_1 : omega_complete_partial_order α,	c : omega_complete_partial_order.chain α,	x : α,	ᾰ : omega_complete_partial_order.ωSup c ≤ x,	i : ℕ	⊢ ⇑c i ≤ x		α : Type u,	_inst_1 : omega_complete_partial_order α,	c : omega_complete_partial_order.chain α,	x : α,	ᾰ : ∀ (i : ℕ), ⇑c i ≤ x	⊢ omega_complete_partial_order.ωSup c ≤ x
α : Type u,	_inst_1 : omega_complete_partial_order α,	c : omega_complete_partial_order.chain α,	x : α,	ᾰ : omega_complete_partial_order.ωSup c ≤ x,	i : ℕ	⊢ ⇑c i ≤ omega_complete_partial_order.ωSup c		α : Type u,	_inst_1 : omega_complete_partial_order α,	c : omega_complete_partial_order.chain α,	x : α,	ᾰ : omega_complete_partial_order.ωSup c ≤ x,	i : ℕ	⊢ omega_complete_partial_order.ωSup c ≤ x
α : Type u,	_inst_1 : omega_complete_partial_order α,	c : omega_complete_partial_order.chain α,	x : α,	ᾰ : ∀ (i : ℕ), ⇑c i ≤ x	⊢ omega_complete_partial_order.ωSup c ≤ x
α : Type u,	_inst_1 : complete_lattice α,	_x : omega_complete_partial_order.chain α,	_fun_match : ∀ (_a : omega_complete_partial_order.chain α) (x : α), (∀ (i : ℕ), ⇑_a i ≤ x) → (⨆ (i : ℕ), ⇑_a i) ≤ x,	c : ℕ → α,	_x : monotone c,	s : α,	hs : ∀ (i : ℕ), ⇑{to_fun := c, monotone' := _x} i ≤ s	⊢ (⨆ (i : ℕ), ⇑{to_fun := c, monotone' := _x} i) ≤ s
α : Type u,	_inst_1 : complete_lattice α,	_x : omega_complete_partial_order.chain α,	_fun_match : ∀ (_a : omega_complete_partial_order.chain α) (x : α), (∀ (i : ℕ), ⇑_a i ≤ x) → (⨆ (i : ℕ), ⇑_a i) ≤ x,	c : ℕ → α,	_x : monotone c,	s : α,	hs : ∀ (i : ℕ), ⇑{to_fun := c, monotone' := _x} i ≤ s	⊢ (⨆ (i : ℕ), ⇑{to_fun := c, monotone' := _x} i) ≤ s
α : Type u,	_inst_1 : complete_lattice α,	_x : omega_complete_partial_order.chain α,	_fun_match : ∀ (_a : omega_complete_partial_order.chain α) (x : α), (∀ (i : ℕ), ⇑_a i ≤ x) → (⨆ (i : ℕ), ⇑_a i) ≤ x,	c : ℕ → α,	_x : monotone c,	s : α,	hs : ∀ (i : ℕ), ⇑{to_fun := c, monotone' := _x} i ≤ s	⊢ (⨆ (i : ℕ), ⇑{to_fun := c, monotone' := _x} i) ≤ s
α : Type u,	_inst_1 : complete_lattice α,	_x : omega_complete_partial_order.chain α,	_fun_match : ∀ (_a : omega_complete_partial_order.chain α) (x : α), (∀ (i : ℕ), ⇑_a i ≤ x) → (⨆ (i : ℕ), ⇑_a i) ≤ x,	c : ℕ → α,	_x : monotone c,	s : α,	hs : ∀ (i : ℕ), c i ≤ s,	i : ℕ	⊢ c i ≤ s
α : Type u,	_inst_1 : complete_lattice α,	_x : omega_complete_partial_order.chain α,	_fun_match : ∀ (_a : omega_complete_partial_order.chain α) (x : α), (∀ (i : ℕ), ⇑_a i ≤ x) → (⨆ (i : ℕ), ⇑_a i) ≤ x,	c : ℕ → α,	_x : monotone c,	s : α,	hs : ∀ (i : ℕ), c i ≤ s	⊢ ∀ (i : ℕ), c i ≤ s
α : Type u,	_inst_1 : complete_lattice α,	_x : omega_complete_partial_order.chain α,	_fun_match : ∀ (_a : omega_complete_partial_order.chain α) (i : ℕ), ⇑_a i ≤ ⨆ (i : ℕ), ⇑_a i,	c : ℕ → α,	_x : monotone c,	i : ℕ	⊢ ⇑{to_fun := c, monotone' := _x} i ≤ ⨆ (i : ℕ), ⇑{to_fun := c, monotone' := _x} i
α : Type u,	_inst_1 : complete_lattice α,	_x : omega_complete_partial_order.chain α,	_fun_match : ∀ (_a : omega_complete_partial_order.chain α) (i : ℕ), ⇑_a i ≤ ⨆ (i : ℕ), ⇑_a i,	c : ℕ → α,	_x : monotone c,	i : ℕ	⊢ ⇑{to_fun := c, monotone' := _x} i ≤ ⨆ (i : ℕ), ⇑{to_fun := c, monotone' := _x} i
α : Type u,	_inst_1 : complete_lattice α,	_x : omega_complete_partial_order.chain α,	_fun_match : ∀ (_a : omega_complete_partial_order.chain α) (i : ℕ), ⇑_a i ≤ ⨆ (i : ℕ), ⇑_a i,	c : ℕ → α,	_x : monotone c,	i : ℕ	⊢ ⇑{to_fun := c, monotone' := _x} i ≤ ⨆ (i : ℕ), ⇑{to_fun := c, monotone' := _x} i
α : Type u,	_inst_1 : complete_lattice α,	_x : omega_complete_partial_order.chain α,	_fun_match : ∀ (_a : omega_complete_partial_order.chain α) (i : ℕ), ⇑_a i ≤ ⨆ (i : ℕ), ⇑_a i,	c : ℕ → α,	_x : monotone c,	i : ℕ	⊢ c i ≤ supr c
α : Type u,	_inst_1 : complete_lattice α,	_x : omega_complete_partial_order.chain α,	_fun_match : ∀ (_a : omega_complete_partial_order.chain α) (i : ℕ), ⇑_a i ≤ ⨆ (i : ℕ), ⇑_a i,	c : ℕ → α,	_x : monotone c,	i : ℕ	⊢ c i ≤ c i
α : Type u,	β : Type v,	_inst_1 : omega_complete_partial_order α,	_inst_2 : complete_lattice β,	f g : α →ₘ β,	hf : omega_complete_partial_order.continuous f,	hg : omega_complete_partial_order.continuous g	⊢ omega_complete_partial_order.continuous (has_Sup.Sup {f, g})
α : Type u,	β : Type v,	_inst_1 : omega_complete_partial_order α,	_inst_2 : complete_lattice β,	f g : α →ₘ β,	hf : omega_complete_partial_order.continuous f,	hg : omega_complete_partial_order.continuous g	⊢ omega_complete_partial_order.continuous (f ⊔ g)
α : Type u,	β : Type v,	_inst_1 : omega_complete_partial_order α,	_inst_2 : complete_lattice β,	f g : α →ₘ β,	hf : omega_complete_partial_order.continuous f,	hg : omega_complete_partial_order.continuous g	⊢ ∀ (f_1 : α →ₘ β), f_1 ∈ {f, g} → omega_complete_partial_order.continuous f_1
α : Type u,	β : Type v,	_inst_1 : omega_complete_partial_order α,	_inst_2 : complete_lattice β,	g : α →ₘ β,	hg : omega_complete_partial_order.continuous g,	f : α →ₘ β,	hf : omega_complete_partial_order.continuous f	⊢ omega_complete_partial_order.continuous f
α : Type u,	β : Type v,	_inst_1 : omega_complete_partial_order α,	_inst_2 : complete_lattice β,	f g : α →ₘ β,	hf : omega_complete_partial_order.continuous f,	hg : omega_complete_partial_order.continuous g,	H : g ∈ {g}	⊢ omega_complete_partial_order.continuous g
α : Type u,	β : Type v,	_inst_1 : omega_complete_partial_order α,	_inst_2 : complete_lattice β,	f g : α →ₘ β,	hf : omega_complete_partial_order.continuous f,	hg : omega_complete_partial_order.continuous g	⊢ ∀ (f_1 : α →ₘ β), f_1 ∈ {f, g} → omega_complete_partial_order.continuous f_1
α : Type u,	β : Type v,	_inst_1 : omega_complete_partial_order α,	_inst_2 : complete_lattice β,	c : omega_complete_partial_order.chain α	⊢ ⇑⊤ (omega_complete_partial_order.ωSup c) = omega_complete_partial_order.ωSup (c.map ⊤)
α : Type u,	β : Type v,	_inst_1 : omega_complete_partial_order α,	_inst_2 : complete_lattice β,	c : omega_complete_partial_order.chain α	⊢ ∀ (c_1 : β), ⇑⊤ (omega_complete_partial_order.ωSup c) ≤ c_1 ↔ omega_complete_partial_order.ωSup (c.map ⊤) ≤ c_1
α : Type u,	β : Type v,	_inst_1 : omega_complete_partial_order α,	_inst_2 : complete_lattice β	⊢ omega_complete_partial_order.continuous ⊤
α : Type u,	β : Type v,	_inst_1 : omega_complete_partial_order α,	_inst_2 : complete_lattice β,	c : omega_complete_partial_order.chain α,	z : β	⊢ ⇑⊤ (omega_complete_partial_order.ωSup c) ≤ z ↔ omega_complete_partial_order.ωSup (c.map ⊤) ≤ z
α : Type u,	β : Type v,	_inst_1 : omega_complete_partial_order α,	_inst_2 : omega_complete_partial_order β,	p : Prop,	hp : decidable p,	f g : α → β,	hf : omega_complete_partial_order.continuous' f,	hg : omega_complete_partial_order.continuous' g	⊢ omega_complete_partial_order.continuous' (λ (x : α), ite p (f x) (g x))
α : Type u,	β : Type v,	_inst_1 : omega_complete_partial_order α,	_inst_2 : omega_complete_partial_order β,	p : Prop,	hp : decidable p,	f g : α → β,	hf : omega_complete_partial_order.continuous' f,	hg : omega_complete_partial_order.continuous' g,	h : p	⊢ omega_complete_partial_order.continuous' f
α : Type u,	β : Type v,	_inst_1 : omega_complete_partial_order α,	_inst_2 : omega_complete_partial_order β,	p : Prop,	hp : decidable p,	f g : α → β,	hf : omega_complete_partial_order.continuous' f,	hg : omega_complete_partial_order.continuous' g,	h : ¬p	⊢ omega_complete_partial_order.continuous' g
α : Type u,	β : Type v,	_inst_1 : omega_complete_partial_order α,	_inst_2 : omega_complete_partial_order β,	p : Prop,	hp : decidable p,	f g : α → β,	hf : omega_complete_partial_order.continuous' f,	hg : omega_complete_partial_order.continuous' g	⊢ omega_complete_partial_order.continuous' (λ (x : α), ite p (f x) (g x))
α : Type u,	β : Type v,	_inst_1 : complete_lattice α,	_inst_2 : complete_lattice β,	f : α → β,	hf : left_ord_continuous f,	s : set α	⊢ f (has_Sup.Sup s) = ⨆ (x : α) (H : x ∈ s), f x
α : Type ?,	r : α → α → Prop,	_inst_1 : is_well_order α r	⊢ is_asymm α r
α : Type u_1,	β : Type u_2,	_inst_1 : semilattice_sup α,	_inst_2 : linear_order β,	a : gt →r gt,	m n : β	⊢ ⇑a m ⊔ ⇑a n = ⇑a (m ⊔ n)
α : Type u_1,	β : Type u_2,	_inst_1 : semilattice_sup α,	_inst_2 : linear_order β,	a : gt →r gt,	m n : β	⊢ ⇑a (m ⊔ n) = ⇑a m ⊔ ⇑a n
α : Type u_1,	β : Type u_2,	_inst_1 : semilattice_sup α,	_inst_2 : linear_order β,	a : gt →r gt,	m n : β,	h : m ≤ n	⊢ ⇑a m ≤ ⇑a n
α : Type u_1,	β : Type u_2,	_inst_1 : semilattice_sup α,	_inst_2 : linear_order β,	a : gt →r gt,	m n : β,	h : m ≤ n	⊢ ⇑a m ⊔ ⇑a n = ⇑a (m ⊔ n)
α : Type u_1,	β : Type u_2,	_inst_1 : semilattice_sup α,	_inst_2 : linear_order β,	a : gt →r gt,	m n : β,	h : m ≤ n	⊢ ⇑a m ⊔ ⇑a n = ⇑a (m ⊔ n)		case or.inr	α : Type u_1,	β : Type u_2,	_inst_1 : semilattice_sup α,	_inst_2 : linear_order β,	a : gt →r gt,	m n : β,	h : n < m	⊢ ⇑a m ⊔ ⇑a n = ⇑a (m ⊔ n)
α : Type u_1,	β : Type u_2,	_inst_1 : semilattice_sup α,	_inst_2 : linear_order β,	a : gt →r gt,	m n : β,	h : n < m	⊢ ⇑a n ≤ ⇑a m
α : Type u_1,	β : Type u_2,	_inst_1 : semilattice_sup α,	_inst_2 : linear_order β,	a : gt →r gt,	m n : β,	h : n < m	⊢ ⇑a m ⊔ ⇑a n = ⇑a (m ⊔ n)
α : Type u_1,	β : Type u_2,	r : α → α → Prop,	s : β → β → Prop,	f : r ≃r s,	a b : β	⊢ r (⇑(f.to_equiv.symm) a) (⇑(f.to_equiv.symm) b) ↔ s a b
α : Type u_1,	_inst_1 : generalized_boolean_algebra α,	a b : α	⊢ a Δ b = a ↔ a Δ b = a Δ ⊥
α : Type u_1,	_inst_1 : generalized_boolean_algebra α,	a b : α	⊢ a Δ b = a Δ ⊥ ↔ b = ⊥
α : Type u_1,	_inst_1 : generalized_boolean_algebra α,	a b : α	⊢ a Δ b \ b = a \ b
α : Type u_1,	s : set α,	r : α → α → Prop,	_inst_1 : is_refl α r,	_inst_2 : is_trans α r	⊢ s.partially_well_ordered_on r ↔ ∀ (f : ℕ → α), set.range f ⊆ s → (∃ (g : ℕ ↪o ℕ), ∀ (m n : ℕ), m ≤ n → r (f (⇑g m)) (f (⇑g n)))
α : Type u_1,	s : set α,	r : α → α → Prop,	_inst_1 : is_refl α r,	_inst_2 : is_trans α r,	_inst : Π (a : Prop), decidable a	⊢ s.partially_well_ordered_on r → ∀ (f : ℕ → α), set.range f ⊆ s → (∃ (g : ℕ ↪o ℕ), ∀ (m n : ℕ), m ≤ n → r (f (⇑g m)) (f (⇑g n)))
α : Type u_1,	s : set α,	r : α → α → Prop,	_inst_1 : is_refl α r,	_inst_2 : is_trans α r,	_inst : Π (a : Prop), decidable a	⊢ (∀ (f : ℕ → α), set.range f ⊆ s → (∃ (g : ℕ ↪o ℕ), ∀ (m n : ℕ), m ≤ n → r (f (⇑g m)) (f (⇑g n)))) → s.partially_well_ordered_on r
α : Type u_1,	s : set α,	r : α → α → Prop,	_inst_1 : is_refl α r,	_inst_2 : is_trans α r,	_inst : Π (a : Prop), decidable a	⊢ s.partially_well_ordered_on r ↔ ∀ (f : ℕ → α), set.range f ⊆ s → (∃ (g : ℕ ↪o ℕ), ∀ (m n : ℕ), m ≤ n → r (f (⇑g m)) (f (⇑g n)))
α : Type u_1,	s : set α,	r : α → α → Prop,	_inst_1 : is_refl α r,	_inst_2 : is_trans α r,	_inst : Π (a : Prop), decidable a	⊢ s.partially_well_ordered_on r ↔ ∀ (f : ℕ → α), set.range f ⊆ s → (∃ (g : ℕ ↪o ℕ), ∀ (m n : ℕ), m ≤ n → r (f (⇑g m)) (f (⇑g n)))
α : Type u_1,	s : set α,	r : α → α → Prop,	_inst_1 : is_refl α r,	_inst_2 : is_trans α r,	_inst : Π (a : Prop), decidable a,	h : s.partially_well_ordered_on r,	f : ℕ → α,	hf : set.range f ⊆ s	⊢ ∃ (g : ℕ ↪o ℕ), ∀ (m n : ℕ), m ≤ n → r (f (⇑g m)) (f (⇑g n))		α : Type u_1,	s : set α,	r : α → α → Prop,	_inst_1 : is_refl α r,	_inst_2 : is_trans α r,	_inst : Π (a : Prop), decidable a,	h : ∀ (f : ℕ → α), set.range f ⊆ s → (∃ (g : ℕ ↪o ℕ), ∀ (m n : ℕ), m ≤ n → r (f (⇑g m)) (f (⇑g n))),	f : ℕ → α,	hf : set.range f ⊆ s	⊢ ∃ (m n : ℕ), m < n ∧ r (f m) (f n)
α : Type u_1,	s : set α,	r : α → α → Prop,	_inst_1 : is_refl α r,	_inst_2 : is_trans α r,	_inst : Π (a : Prop), decidable a,	h : s.partially_well_ordered_on r,	f : ℕ → α,	hf : set.range f ⊆ s	⊢ ∃ (g : ℕ ↪o ℕ), ∀ (m n : ℕ), m ≤ n → r (f (⇑g m)) (f (⇑g n))
α : Type u_1,	s : set α,	r : α → α → Prop,	_inst_1 : is_refl α r,	_inst_2 : is_trans α r,	_inst : Π (a : Prop), decidable a,	h : ∀ (f : ℕ → α), set.range f ⊆ s → (∃ (g : ℕ ↪o ℕ), ∀ (m n : ℕ), m ≤ n → r (f (⇑g m)) (f (⇑g n))),	f : ℕ → α,	hf : set.range f ⊆ s	⊢ ∃ (m n : ℕ), m < n ∧ r (f m) (f n)
α : Type u_1,	s : set α,	r : α → α → Prop,	_inst_1 : is_refl α r,	_inst_2 : is_trans α r,	_inst : Π (a : Prop), decidable a,	h : ∀ (f : ℕ → α), set.range f ⊆ s → (∃ (g : ℕ ↪o ℕ), ∀ (m n : ℕ), m ≤ n → r (f (⇑g m)) (f (⇑g n))),	f : ℕ → α,	hf : set.range f ⊆ s,	g : ℕ ↪o ℕ,	gmon : ∀ (m n : ℕ), m ≤ n → r (f (⇑g m)) (f (⇑g n))	⊢ ∃ (m n : ℕ), m < n ∧ r (f m) (f n)
α : Type u_1,	_inst_1 : partial_order α,	s : set α,	a : α,	hs : s.is_pwo	⊢ (s ∪ {a}).is_pwo
α : Type u_1,	_inst_1 : partial_order α,	s : set α,	a : α,	hs : s.is_pwo	⊢ (has_insert.insert a s).is_pwo
α : Type u_1,	_inst_1 : measurable_space α,	s t : set α,	μ : measure_theory.measure α,	h : ⇑μ (s ∩ t) = ⇑μ s * ⇑μ t,	s1 t1 : set α,	hs1 : s1 ∈ {s},	ht1 : t1 ∈ {t}	⊢ ⇑μ (s1 ∩ t1) = ⇑μ s1 * ⇑μ t1
k : Type u,	_inst_1 : comm_ring k,	G : Type u,	_inst_2 : group G,	V : Type u,	_inst_3 : add_comm_group V,	_inst_4 : module k V,	_inst_5 : module (monoid_algebra k G) V,	_inst_6 : is_scalar_tower k (monoid_algebra k G) V,	W : Type u,	_inst_7 : add_comm_group W,	_inst_8 : module k W,	_inst_9 : module (monoid_algebra k G) W,	_inst_10 : is_scalar_tower k (monoid_algebra k G) W,	π : W →ₗ[k] V,	i : V →ₗ[monoid_algebra k G] W,	h : ∀ (v : V), ⇑π (⇑i v) = v,	g : G,	v : V	⊢ ⇑(π.conjugate g) (⇑i v) = v
k : Type u,	_inst_1 : comm_ring k,	G : Type u,	_inst_2 : group G,	V : Type u,	_inst_3 : add_comm_group V,	_inst_4 : module k V,	_inst_5 : module (monoid_algebra k G) V,	_inst_6 : is_scalar_tower k (monoid_algebra k G) V,	W : Type u,	_inst_7 : add_comm_group W,	_inst_8 : module k W,	_inst_9 : module (monoid_algebra k G) W,	_inst_10 : is_scalar_tower k (monoid_algebra k G) W,	π : W →ₗ[k] V,	i : V →ₗ[monoid_algebra k G] W,	h : ∀ (v : V), ⇑π (⇑i v) = v,	g : G,	v : V	⊢ finsupp.single g⁻¹ 1 • ⇑π (finsupp.single g 1 • ⇑i v) = v
k : Type u,	_inst_1 : comm_ring k,	G : Type u,	_inst_2 : group G,	V : Type u,	_inst_3 : add_comm_group V,	_inst_4 : module k V,	_inst_5 : module (monoid_algebra k G) V,	_inst_6 : is_scalar_tower k (monoid_algebra k G) V,	W : Type u,	_inst_7 : add_comm_group W,	_inst_8 : module k W,	_inst_9 : module (monoid_algebra k G) W,	_inst_10 : is_scalar_tower k (monoid_algebra k G) W,	π : W →ₗ[k] V,	i : V →ₗ[monoid_algebra k G] W,	h : ∀ (v : V), ⇑π (⇑i v) = v,	g : G,	v : V	⊢ finsupp.single 1 1 • v = v
k : Type u,	_inst_1 : comm_ring k,	G : Type u,	_inst_2 : group G,	V : Type u,	_inst_3 : add_comm_group V,	_inst_4 : module k V,	_inst_5 : module (monoid_algebra k G) V,	_inst_6 : is_scalar_tower k (monoid_algebra k G) V,	W : Type u,	_inst_7 : add_comm_group W,	_inst_8 : module k W,	_inst_9 : module (monoid_algebra k G) W,	_inst_10 : is_scalar_tower k (monoid_algebra k G) W,	π : W →ₗ[k] V,	i : V →ₗ[monoid_algebra k G] W,	h : ∀ (v : V), ⇑π (⇑i v) = v,	g : G,	v : V	⊢ 1 • v = v
K : Type w,	_inst_1 : field K,	f : polynomial K,	hf : f ≠ 0	⊢ minpoly K (adjoin_root.root f) = f * ⇑polynomial.C (f.leading_coeff)⁻¹
K : Type w,	_inst_1 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑polynomial.C (f.leading_coeff)⁻¹).monic	⊢ minpoly K (adjoin_root.root f) = f * ⇑polynomial.C (f.leading_coeff)⁻¹
K : Type w,	_inst_1 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑polynomial.C (f.leading_coeff)⁻¹).monic	⊢ ⇑(polynomial.aeval (adjoin_root.root f)) (f * ⇑polynomial.C (f.leading_coeff)⁻¹) = 0		K : Type w,	_inst_1 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑polynomial.C (f.leading_coeff)⁻¹).monic	⊢ ∀ (q : polynomial K), q.monic → ⇑(polynomial.aeval (adjoin_root.root f)) q = 0 → (f * ⇑polynomial.C (f.leading_coeff)⁻¹).degree ≤ q.degree
K : Type w,	_inst_1 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑polynomial.C (f.leading_coeff)⁻¹).monic	⊢ ⇑(polynomial.aeval (adjoin_root.root f)) (f * ⇑polynomial.C (f.leading_coeff)⁻¹) = 0
K : Type w,	_inst_1 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑polynomial.C (f.leading_coeff)⁻¹).monic	⊢ ∀ (q : polynomial K), q.monic → ⇑(polynomial.aeval (adjoin_root.root f)) q = 0 → (f * ⇑polynomial.C (f.leading_coeff)⁻¹).degree ≤ q.degree
K : Type w,	_inst_1 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑polynomial.C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(polynomial.aeval (adjoin_root.root f)) q = 0	⊢ (f * ⇑polynomial.C (f.leading_coeff)⁻¹).degree ≤ q.degree
K : Type w,	_inst_1 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑polynomial.C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(polynomial.aeval (adjoin_root.root f)) q = 0	⊢ (adjoin_root.lift (algebra_map K (adjoin_root f)) (adjoin_root.root f) q_aeval).comp (adjoin_root.mk q) = adjoin_root.mk f
K : Type w,	_inst_1 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑polynomial.C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(polynomial.aeval (adjoin_root.root f)) q = 0,	x : K	⊢ ⇑(algebra_map K (adjoin_root f)) x = ↑x
K : Type w,	_inst_1 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑polynomial.C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(polynomial.aeval (adjoin_root.root f)) q = 0,	x : K	⊢ ⇑(((adjoin_root.lift (algebra_map K (adjoin_root f)) (adjoin_root.root f) q_aeval).comp (adjoin_root.mk q)).comp polynomial.C) x = ⇑((adjoin_root.mk f).comp polynomial.C) x		K : Type w,	_inst_1 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑polynomial.C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(polynomial.aeval (adjoin_root.root f)) q = 0	⊢ ⇑((adjoin_root.lift (algebra_map K (adjoin_root f)) (adjoin_root.root f) q_aeval).comp (adjoin_root.mk q)) polynomial.X = ⇑(adjoin_root.mk f) polynomial.X
K : Type w,	_inst_1 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑polynomial.C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(polynomial.aeval (adjoin_root.root f)) q = 0,	x : K	⊢ ⇑(((adjoin_root.lift (algebra_map K (adjoin_root f)) (adjoin_root.root f) q_aeval).comp (adjoin_root.mk q)).comp polynomial.C) x = ⇑((adjoin_root.mk f).comp polynomial.C) x
K : Type w,	_inst_1 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑polynomial.C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(polynomial.aeval (adjoin_root.root f)) q = 0	⊢ (adjoin_root.lift (algebra_map K (adjoin_root f)) (adjoin_root.root f) q_aeval).comp (adjoin_root.mk q) = adjoin_root.mk f		K : Type w,	_inst_1 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑polynomial.C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(polynomial.aeval (adjoin_root.root f)) q = 0,	commutes : (adjoin_root.lift (algebra_map K (adjoin_root f)) (adjoin_root.root f) q_aeval).comp (adjoin_root.mk q) = adjoin_root.mk f	⊢ (f * ⇑polynomial.C (f.leading_coeff)⁻¹).degree ≤ q.degree
K : Type w,	_inst_1 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑polynomial.C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(polynomial.aeval (adjoin_root.root f)) q = 0	⊢ ⇑((adjoin_root.lift (algebra_map K (adjoin_root f)) (adjoin_root.root f) q_aeval).comp (adjoin_root.mk q)) polynomial.X = ⇑(adjoin_root.mk f) polynomial.X
K : Type w,	_inst_1 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑polynomial.C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(polynomial.aeval (adjoin_root.root f)) q = 0,	commutes : (adjoin_root.lift (algebra_map K (adjoin_root f)) (adjoin_root.root f) q_aeval).comp (adjoin_root.mk q) = adjoin_root.mk f	⊢ (f * ⇑polynomial.C (f.leading_coeff)⁻¹).degree ≤ q.degree
K : Type w,	_inst_1 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑polynomial.C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(polynomial.aeval (adjoin_root.root f)) q = 0,	commutes : (adjoin_root.lift (algebra_map K (adjoin_root f)) (adjoin_root.root f) q_aeval).comp (adjoin_root.mk q) = adjoin_root.mk f	⊢ f.nat_degree ≤ q.nat_degree		K : Type w,	_inst_1 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑polynomial.C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(polynomial.aeval (adjoin_root.root f)) q = 0,	commutes : (adjoin_root.lift (algebra_map K (adjoin_root f)) (adjoin_root.root f) q_aeval).comp (adjoin_root.mk q) = adjoin_root.mk f	⊢ ⇑polynomial.C (f.leading_coeff)⁻¹ ≠ 0
K : Type w,	_inst_1 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑polynomial.C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(polynomial.aeval (adjoin_root.root f)) q = 0,	commutes : (adjoin_root.lift (algebra_map K (adjoin_root f)) (adjoin_root.root f) q_aeval).comp (adjoin_root.mk q) = adjoin_root.mk f	⊢ ⇑(adjoin_root.mk f) q = 0
K : Type w,	_inst_1 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑polynomial.C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(polynomial.aeval (adjoin_root.root f)) q = 0,	commutes : (adjoin_root.lift (algebra_map K (adjoin_root f)) (adjoin_root.root f) q_aeval).comp (adjoin_root.mk q) = adjoin_root.mk f	⊢ f ∣ q
K : Type w,	_inst_1 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑polynomial.C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(polynomial.aeval (adjoin_root.root f)) q = 0,	commutes : (adjoin_root.lift (algebra_map K (adjoin_root f)) (adjoin_root.root f) q_aeval).comp (adjoin_root.mk q) = adjoin_root.mk f,	this : ⇑(adjoin_root.mk f) q = 0	⊢ f ∣ q
K : Type w,	_inst_1 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑polynomial.C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(polynomial.aeval (adjoin_root.root f)) q = 0,	commutes : (adjoin_root.lift (algebra_map K (adjoin_root f)) (adjoin_root.root f) q_aeval).comp (adjoin_root.mk q) = adjoin_root.mk f	⊢ f ∣ q		K : Type w,	_inst_1 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑polynomial.C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(polynomial.aeval (adjoin_root.root f)) q = 0,	commutes : (adjoin_root.lift (algebra_map K (adjoin_root f)) (adjoin_root.root f) q_aeval).comp (adjoin_root.mk q) = adjoin_root.mk f	⊢ q ≠ 0		K : Type w,	_inst_1 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑polynomial.C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(polynomial.aeval (adjoin_root.root f)) q = 0,	commutes : (adjoin_root.lift (algebra_map K (adjoin_root f)) (adjoin_root.root f) q_aeval).comp (adjoin_root.mk q) = adjoin_root.mk f	⊢ ⇑polynomial.C (f.leading_coeff)⁻¹ ≠ 0
K : Type w,	_inst_1 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑polynomial.C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(polynomial.aeval (adjoin_root.root f)) q = 0,	commutes : (adjoin_root.lift (algebra_map K (adjoin_root f)) (adjoin_root.root f) q_aeval).comp (adjoin_root.mk q) = adjoin_root.mk f	⊢ q ≠ 0		K : Type w,	_inst_1 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑polynomial.C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(polynomial.aeval (adjoin_root.root f)) q = 0,	commutes : (adjoin_root.lift (algebra_map K (adjoin_root f)) (adjoin_root.root f) q_aeval).comp (adjoin_root.mk q) = adjoin_root.mk f	⊢ ⇑polynomial.C (f.leading_coeff)⁻¹ ≠ 0
K : Type w,	_inst_1 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑polynomial.C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(polynomial.aeval (adjoin_root.root f)) q = 0,	commutes : (adjoin_root.lift (algebra_map K (adjoin_root f)) (adjoin_root.root f) q_aeval).comp (adjoin_root.mk q) = adjoin_root.mk f	⊢ q ≠ 0
K : Type w,	_inst_1 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑polynomial.C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(polynomial.aeval (adjoin_root.root f)) q = 0,	commutes : (adjoin_root.lift (algebra_map K (adjoin_root f)) (adjoin_root.root f) q_aeval).comp (adjoin_root.mk q) = adjoin_root.mk f	⊢ ⇑polynomial.C (f.leading_coeff)⁻¹ ≠ 0
R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_artinian_ring R	⊢ is_nilpotent ⊥.jacobson
R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_artinian_ring R,	Jac : ideal R := ⊥.jacobson	⊢ is_nilpotent ⊥.jacobson
R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_artinian_ring R,	Jac : ideal R := ⊥.jacobson,	f : ℕ →ₘ order_dual (ideal R) := {to_fun := λ (n : ℕ), Jac ^ n, monotone' := _}	⊢ is_nilpotent ⊥.jacobson
R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_artinian_ring R,	Jac : ideal R := ⊥.jacobson,	f : ℕ →ₘ order_dual (ideal R) := {to_fun := λ (n : ℕ), Jac ^ n, monotone' := _},	n : ℕ,	hn : ∀ (m : ℕ), n ≤ m → Jac ^ n = Jac ^ m	⊢ is_nilpotent ⊥.jacobson
R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_artinian_ring R,	Jac : ideal R := ⊥.jacobson,	f : ℕ →ₘ order_dual (ideal R) := {to_fun := λ (n : ℕ), Jac ^ n, monotone' := _},	n : ℕ,	hn : ∀ (m : ℕ), n ≤ m → Jac ^ n = Jac ^ m	⊢ ⊥.jacobson ^ n = 0
R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_artinian_ring R,	Jac : ideal R := ⊥.jacobson,	f : ℕ →ₘ order_dual (ideal R) := {to_fun := λ (n : ℕ), Jac ^ n, monotone' := _},	n : ℕ,	hn : ∀ (m : ℕ), n ≤ m → Jac ^ n = Jac ^ m,	J : ideal R := (Jac ^ n).annihilator	⊢ ⊥.jacobson ^ n = 0
R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_artinian_ring R,	Jac : ideal R := ⊥.jacobson,	f : ℕ →ₘ order_dual (ideal R) := {to_fun := λ (n : ℕ), Jac ^ n, monotone' := _},	n : ℕ,	hn : ∀ (m : ℕ), n ≤ m → Jac ^ n = Jac ^ m,	J : ideal R := (Jac ^ n).annihilator,	this : J = ⊤	⊢ ⊥.jacobson ^ n = 0
R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_artinian_ring R,	Jac : ideal R := ⊥.jacobson,	f : ℕ →ₘ order_dual (ideal R) := {to_fun := λ (n : ℕ), Jac ^ n, monotone' := _},	n : ℕ,	hn : ∀ (m : ℕ), n ≤ m → Jac ^ n = Jac ^ m,	J : ideal R := (Jac ^ n).annihilator,	this : J = ⊤,	hJ : J • Jac ^ n = ⊥	⊢ ⊥.jacobson ^ n = 0
R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_artinian_ring R,	Jac : ideal R := ⊥.jacobson,	f : ℕ →ₘ order_dual (ideal R) := {to_fun := λ (n : ℕ), Jac ^ n, monotone' := _},	n : ℕ,	hn : ∀ (m : ℕ), n ≤ m → Jac ^ n = Jac ^ m,	J : ideal R := (Jac ^ n).annihilator,	this : J = ⊤	⊢ ⊥.jacobson ^ n = 0		R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_artinian_ring R,	Jac : ideal R := ⊥.jacobson,	f : ℕ →ₘ order_dual (ideal R) := {to_fun := λ (n : ℕ), Jac ^ n, monotone' := _},	n : ℕ,	hn : ∀ (m : ℕ), n ≤ m → Jac ^ n = Jac ^ m,	J : ideal R := (Jac ^ n).annihilator	⊢ J = ⊤
R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_artinian_ring R,	Jac : ideal R := ⊥.jacobson,	f : ℕ →ₘ order_dual (ideal R) := {to_fun := λ (n : ℕ), Jac ^ n, monotone' := _},	n : ℕ,	hn : ∀ (m : ℕ), n ≤ m → Jac ^ n = Jac ^ m,	J : ideal R := (Jac ^ n).annihilator,	hJ : ¬J = ⊤	⊢ false
R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_artinian_ring R,	Jac : ideal R := ⊥.jacobson,	f : ℕ →ₘ order_dual (ideal R) := {to_fun := λ (n : ℕ), Jac ^ n, monotone' := _},	n : ℕ,	hn : ∀ (m : ℕ), n ≤ m → Jac ^ n = Jac ^ m,	J : ideal R := (Jac ^ n).annihilator	⊢ J = ⊤
R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_artinian_ring R,	Jac : ideal R := ⊥.jacobson,	f : ℕ →ₘ order_dual (ideal R) := {to_fun := λ (n : ℕ), Jac ^ n, monotone' := _},	n : ℕ,	hn : ∀ (m : ℕ), n ≤ m → Jac ^ n = Jac ^ m,	J : ideal R := (Jac ^ n).annihilator,	hJ : J ≠ ⊤	⊢ false
R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_artinian_ring R,	Jac : ideal R := ⊥.jacobson,	f : ℕ →ₘ order_dual (ideal R) := {to_fun := λ (n : ℕ), Jac ^ n, monotone' := _},	n : ℕ,	hn : ∀ (m : ℕ), n ≤ m → Jac ^ n = Jac ^ m,	J : ideal R := (Jac ^ n).annihilator,	hJ : J ≠ ⊤,	J' : submodule R R,	hJJ' : J < J',	hJ' : ∀ (I : ideal R), J < I → I ≤ J' → I = J'	⊢ false
R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_artinian_ring R,	Jac : ideal R := ⊥.jacobson,	f : ℕ →ₘ order_dual (ideal R) := {to_fun := λ (n : ℕ), Jac ^ n, monotone' := _},	n : ℕ,	hn : ∀ (m : ℕ), n ≤ m → Jac ^ n = Jac ^ m,	J : ideal R := (Jac ^ n).annihilator,	hJ : J ≠ ⊤,	J' : submodule R R,	hJJ' : J < J',	hJ' : ∀ (I : ideal R), J < I → I ≤ J' → I = J',	x : R,	hxJ' : x ∈ J',	hxJ : x ∉ J	⊢ false
R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_artinian_ring R,	Jac : ideal R := ⊥.jacobson,	f : ℕ →ₘ order_dual (ideal R) := {to_fun := λ (n : ℕ), Jac ^ n, monotone' := _},	n : ℕ,	hn : ∀ (m : ℕ), n ≤ m → Jac ^ n = Jac ^ m,	J : ideal R := (Jac ^ n).annihilator,	hJ : J ≠ ⊤,	J' : submodule R R,	hJJ' : J < J',	hJ' : ∀ (I : ideal R), J < I → I ≤ J' → I = J',	x : R,	hxJ' : x ∈ J',	hxJ : x ∉ J	⊢ J ⊔ ideal.span {x} = J'
R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_artinian_ring R,	Jac : ideal R := ⊥.jacobson,	f : ℕ →ₘ order_dual (ideal R) := {to_fun := λ (n : ℕ), Jac ^ n, monotone' := _},	n : ℕ,	hn : ∀ (m : ℕ), n ≤ m → Jac ^ n = Jac ^ m,	J : ideal R := (Jac ^ n).annihilator,	hJ : J ≠ ⊤,	J' : submodule R R,	hJJ' : J < J',	hJ' : ∀ (I : ideal R), J < I → I ≤ J' → I = J',	x : R,	hxJ' : x ∈ J',	hxJ : x ∉ J	⊢ J < J ⊔ ideal.span {x}
R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_artinian_ring R,	Jac : ideal R := ⊥.jacobson,	f : ℕ →ₘ order_dual (ideal R) := {to_fun := λ (n : ℕ), Jac ^ n, monotone' := _},	n : ℕ,	hn : ∀ (m : ℕ), n ≤ m → Jac ^ n = Jac ^ m,	J : ideal R := (Jac ^ n).annihilator,	hJ : J ≠ ⊤,	J' : submodule R R,	hJJ' : J < J',	hJ' : ∀ (I : ideal R), J < I → I ≤ J' → I = J',	x : R,	hxJ' : x ∈ J',	hxJ : x ∉ J	⊢ J ≤ J ⊔ ideal.span {x} ∧ ∃ (x_1 : R) (H : x_1 ∈ J ⊔ ideal.span {x}), x_1 ∉ J
R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_artinian_ring R,	Jac : ideal R := ⊥.jacobson,	f : ℕ →ₘ order_dual (ideal R) := {to_fun := λ (n : ℕ), Jac ^ n, monotone' := _},	n : ℕ,	hn : ∀ (m : ℕ), n ≤ m → Jac ^ n = Jac ^ m,	J : ideal R := (Jac ^ n).annihilator,	hJ : J ≠ ⊤,	J' : submodule R R,	hJJ' : J < J',	hJ' : ∀ (I : ideal R), J < I → I ≤ J' → I = J',	x : R,	hxJ' : x ∈ J',	hxJ : x ∉ J	⊢ J < J ⊔ ideal.span {x}		R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_artinian_ring R,	Jac : ideal R := ⊥.jacobson,	f : ℕ →ₘ order_dual (ideal R) := {to_fun := λ (n : ℕ), Jac ^ n, monotone' := _},	n : ℕ,	hn : ∀ (m : ℕ), n ≤ m → Jac ^ n = Jac ^ m,	J : ideal R := (Jac ^ n).annihilator,	hJ : J ≠ ⊤,	J' : submodule R R,	hJJ' : J < J',	hJ' : ∀ (I : ideal R), J < I → I ≤ J' → I = J',	x : R,	hxJ' : x ∈ J',	hxJ : x ∉ J	⊢ J ⊔ ideal.span {x} ≤ J'
R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_artinian_ring R,	Jac : ideal R := ⊥.jacobson,	f : ℕ →ₘ order_dual (ideal R) := {to_fun := λ (n : ℕ), Jac ^ n, monotone' := _},	n : ℕ,	hn : ∀ (m : ℕ), n ≤ m → Jac ^ n = Jac ^ m,	J : ideal R := (Jac ^ n).annihilator,	hJ : J ≠ ⊤,	J' : submodule R R,	hJJ' : J < J',	hJ' : ∀ (I : ideal R), J < I → I ≤ J' → I = J',	x : R,	hxJ' : x ∈ J',	hxJ : x ∉ J	⊢ J ⊔ ideal.span {x} = J'		R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_artinian_ring R,	Jac : ideal R := ⊥.jacobson,	f : ℕ →ₘ order_dual (ideal R) := {to_fun := λ (n : ℕ), Jac ^ n, monotone' := _},	n : ℕ,	hn : ∀ (m : ℕ), n ≤ m → Jac ^ n = Jac ^ m,	J : ideal R := (Jac ^ n).annihilator,	hJ : J ≠ ⊤,	x : R,	hxJ : x ∉ J,	hJJ' : J < J ⊔ ideal.span {x},	hJ' : ∀ (I : ideal R), J < I → I ≤ J ⊔ ideal.span {x} → I = J ⊔ ideal.span {x},	hxJ' : x ∈ J ⊔ ideal.span {x}	⊢ false
R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_artinian_ring R,	Jac : ideal R := ⊥.jacobson,	f : ℕ →ₘ order_dual (ideal R) := {to_fun := λ (n : ℕ), Jac ^ n, monotone' := _},	n : ℕ,	hn : ∀ (m : ℕ), n ≤ m → Jac ^ n = Jac ^ m,	J : ideal R := (Jac ^ n).annihilator,	hJ : J ≠ ⊤,	J' : submodule R R,	hJJ' : J < J',	hJ' : ∀ (I : ideal R), J < I → I ≤ J' → I = J',	x : R,	hxJ' : x ∈ J',	hxJ : x ∉ J	⊢ J ⊔ ideal.span {x} ≤ J'
R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_artinian_ring R,	Jac : ideal R := ⊥.jacobson,	f : ℕ →ₘ order_dual (ideal R) := {to_fun := λ (n : ℕ), Jac ^ n, monotone' := _},	n : ℕ,	hn : ∀ (m : ℕ), n ≤ m → Jac ^ n = Jac ^ m,	J : ideal R := (Jac ^ n).annihilator,	hJ : J ≠ ⊤,	x : R,	hxJ : x ∉ J,	hJJ' : J < J ⊔ ideal.span {x},	hJ' : ∀ (I : ideal R), J < I → I ≤ J ⊔ ideal.span {x} → I = J ⊔ ideal.span {x},	hxJ' : x ∈ J ⊔ ideal.span {x}	⊢ false
R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_artinian_ring R,	Jac : ideal R := ⊥.jacobson,	f : ℕ →ₘ order_dual (ideal R) := {to_fun := λ (n : ℕ), Jac ^ n, monotone' := _},	n : ℕ,	hn : ∀ (m : ℕ), n ≤ m → Jac ^ n = Jac ^ m,	J : ideal R := (Jac ^ n).annihilator,	hJ : J ≠ ⊤,	x : R,	hxJ : x ∉ J,	hJJ' : J < J ⊔ ideal.span {x},	hJ' : ∀ (I : ideal R), J < I → I ≤ J ⊔ ideal.span {x} → I = J ⊔ ideal.span {x},	hxJ' : x ∈ J ⊔ ideal.span {x}	⊢ J ⊔ Jac • ideal.span {x} ≤ J ⊔ ideal.span {x}		R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_artinian_ring R,	Jac : ideal R := ⊥.jacobson,	f : ℕ →ₘ order_dual (ideal R) := {to_fun := λ (n : ℕ), Jac ^ n, monotone' := _},	n : ℕ,	hn : ∀ (m : ℕ), n ≤ m → Jac ^ n = Jac ^ m,	J : ideal R := (Jac ^ n).annihilator,	hJ : J ≠ ⊤,	x : R,	hxJ : x ∉ J,	hJJ' : J < J ⊔ ideal.span {x},	hJ' : ∀ (I : ideal R), J < I → I ≤ J ⊔ ideal.span {x} → I = J ⊔ ideal.span {x},	hxJ' : x ∈ J ⊔ ideal.span {x},	this : J ⊔ Jac • ideal.span {x} ≤ J ⊔ ideal.span {x}	⊢ false
R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_artinian_ring R,	Jac : ideal R := ⊥.jacobson,	f : ℕ →ₘ order_dual (ideal R) := {to_fun := λ (n : ℕ), Jac ^ n, monotone' := _},	n : ℕ,	hn : ∀ (m : ℕ), n ≤ m → Jac ^ n = Jac ^ m,	J : ideal R := (Jac ^ n).annihilator,	hJ : J ≠ ⊤,	x : R,	hxJ : x ∉ J,	hJJ' : J < J ⊔ ideal.span {x},	hJ' : ∀ (I : ideal R), J < I → I ≤ J ⊔ ideal.span {x} → I = J ⊔ ideal.span {x},	hxJ' : x ∈ J ⊔ ideal.span {x},	this : J ⊔ Jac • ideal.span {x} ≤ J ⊔ ideal.span {x}	⊢ false
R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_artinian_ring R,	Jac : ideal R := ⊥.jacobson,	f : ℕ →ₘ order_dual (ideal R) := {to_fun := λ (n : ℕ), Jac ^ n, monotone' := _},	n : ℕ,	hn : ∀ (m : ℕ), n ≤ m → Jac ^ n = Jac ^ m,	J : ideal R := (Jac ^ n).annihilator,	hJ : J ≠ ⊤,	x : R,	hxJ : x ∉ J,	hJJ' : J < J ⊔ ideal.span {x},	hJ' : ∀ (I : ideal R), J < I → I ≤ J ⊔ ideal.span {x} → I = J ⊔ ideal.span {x},	hxJ' : x ∈ J ⊔ ideal.span {x},	this : J ⊔ Jac • ideal.span {x} ≤ J ⊔ ideal.span {x},	_inst : Π (a : Prop), decidable a	⊢ Jac * ideal.span {x} ≤ J
R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_artinian_ring R,	Jac : ideal R := ⊥.jacobson,	f : ℕ →ₘ order_dual (ideal R) := {to_fun := λ (n : ℕ), Jac ^ n, monotone' := _},	n : ℕ,	hn : ∀ (m : ℕ), n ≤ m → Jac ^ n = Jac ^ m,	J : ideal R := (Jac ^ n).annihilator,	hJ : J ≠ ⊤,	x : R,	hxJ : x ∉ J,	hJJ' : J < J ⊔ ideal.span {x},	hJ' : ∀ (I : ideal R), J < I → I ≤ J ⊔ ideal.span {x} → I = J ⊔ ideal.span {x},	hxJ' : x ∈ J ⊔ ideal.span {x},	this : J ⊔ Jac • ideal.span {x} ≤ J ⊔ ideal.span {x}	⊢ Jac * ideal.span {x} ≤ J
R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_artinian_ring R,	Jac : ideal R := ⊥.jacobson,	f : ℕ →ₘ order_dual (ideal R) := {to_fun := λ (n : ℕ), Jac ^ n, monotone' := _},	n : ℕ,	hn : ∀ (m : ℕ), n ≤ m → Jac ^ n = Jac ^ m,	J : ideal R := (Jac ^ n).annihilator,	hJ : J ≠ ⊤,	x : R,	hxJ : x ∉ J,	hJJ' : J < J ⊔ ideal.span {x},	hJ' : ∀ (I : ideal R), J < I → I ≤ J ⊔ ideal.span {x} → I = J ⊔ ideal.span {x},	hxJ' : x ∈ J ⊔ ideal.span {x},	this : J ⊔ Jac • ideal.span {x} ≤ J ⊔ ideal.span {x},	_inst : Π (a : Prop), decidable a,	H : ¬Jac * ideal.span {x} ≤ J	⊢ false
R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_artinian_ring R,	Jac : ideal R := ⊥.jacobson,	f : ℕ →ₘ order_dual (ideal R) := {to_fun := λ (n : ℕ), Jac ^ n, monotone' := _},	n : ℕ,	hn : ∀ (m : ℕ), n ≤ m → Jac ^ n = Jac ^ m,	J : ideal R := (Jac ^ n).annihilator,	hJ : J ≠ ⊤,	x : R,	hxJ : x ∉ J,	hJJ' : J < J ⊔ ideal.span {x},	hJ' : ∀ (I : ideal R), J < I → I ≤ J ⊔ ideal.span {x} → I = J ⊔ ideal.span {x},	hxJ' : x ∈ J ⊔ ideal.span {x},	this : J ⊔ Jac • ideal.span {x} ≤ J ⊔ ideal.span {x},	_inst : Π (a : Prop), decidable a,	H : ¬Jac * ideal.span {x} ≤ J	⊢ J < J ⊔ Jac • ideal.span {x}
R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_artinian_ring R,	Jac : ideal R := ⊥.jacobson,	f : ℕ →ₘ order_dual (ideal R) := {to_fun := λ (n : ℕ), Jac ^ n, monotone' := _},	n : ℕ,	hn : ∀ (m : ℕ), n ≤ m → Jac ^ n = Jac ^ m,	J : ideal R := (Jac ^ n).annihilator,	hJ : J ≠ ⊤,	x : R,	hxJ : x ∉ J,	hJJ' : J < J ⊔ ideal.span {x},	hJ' : ∀ (I : ideal R), J < I → I ≤ J ⊔ ideal.span {x} → I = J ⊔ ideal.span {x},	hxJ' : x ∈ J ⊔ ideal.span {x},	this : J ⊔ Jac • ideal.span {x} ≤ J ⊔ ideal.span {x}	⊢ Jac * ideal.span {x} ≤ J		R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_artinian_ring R,	Jac : ideal R := ⊥.jacobson,	f : ℕ →ₘ order_dual (ideal R) := {to_fun := λ (n : ℕ), Jac ^ n, monotone' := _},	n : ℕ,	hn : ∀ (m : ℕ), n ≤ m → Jac ^ n = Jac ^ m,	J : ideal R := (Jac ^ n).annihilator,	hJ : J ≠ ⊤,	x : R,	hxJ : x ∉ J,	hJJ' : J < J ⊔ ideal.span {x},	hJ' : ∀ (I : ideal R), J < I → I ≤ J ⊔ ideal.span {x} → I = J ⊔ ideal.span {x},	hxJ' : x ∈ J ⊔ ideal.span {x},	this : J ⊔ Jac • ideal.span {x} ≤ J ⊔ ideal.span {x},	this : Jac * ideal.span {x} ≤ J	⊢ false
R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_artinian_ring R,	Jac : ideal R := ⊥.jacobson,	f : ℕ →ₘ order_dual (ideal R) := {to_fun := λ (n : ℕ), Jac ^ n, monotone' := _},	n : ℕ,	hn : ∀ (m : ℕ), n ≤ m → Jac ^ n = Jac ^ m,	J : ideal R := (Jac ^ n).annihilator,	hJ : J ≠ ⊤,	x : R,	hxJ : x ∉ J,	hJJ' : J < J ⊔ ideal.span {x},	hJ' : ∀ (I : ideal R), J < I → I ≤ J ⊔ ideal.span {x} → I = J ⊔ ideal.span {x},	hxJ' : x ∈ J ⊔ ideal.span {x},	this : J ⊔ Jac • ideal.span {x} ≤ J ⊔ ideal.span {x},	this : Jac * ideal.span {x} ≤ J	⊢ false
R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_artinian_ring R,	Jac : ideal R := ⊥.jacobson,	f : ℕ →ₘ order_dual (ideal R) := {to_fun := λ (n : ℕ), Jac ^ n, monotone' := _},	n : ℕ,	hn : ∀ (m : ℕ), n ≤ m → Jac ^ n = Jac ^ m,	J : ideal R := (Jac ^ n).annihilator,	hJ : J ≠ ⊤,	x : R,	hxJ : x ∉ J,	hJJ' : J < J ⊔ ideal.span {x},	hJ' : ∀ (I : ideal R), J < I → I ≤ J ⊔ ideal.span {x} → I = J ⊔ ideal.span {x},	hxJ' : x ∈ J ⊔ ideal.span {x},	this : J ⊔ Jac • ideal.span {x} ≤ J ⊔ ideal.span {x},	this : Jac * ideal.span {x} ≤ J	⊢ ideal.span {x} * Jac ^ (n + 1) ≤ ⊥		R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_artinian_ring R,	Jac : ideal R := ⊥.jacobson,	f : ℕ →ₘ order_dual (ideal R) := {to_fun := λ (n : ℕ), Jac ^ n, monotone' := _},	n : ℕ,	hn : ∀ (m : ℕ), n ≤ m → Jac ^ n = Jac ^ m,	J : ideal R := (Jac ^ n).annihilator,	hJ : J ≠ ⊤,	x : R,	hxJ : x ∉ J,	hJJ' : J < J ⊔ ideal.span {x},	hJ' : ∀ (I : ideal R), J < I → I ≤ J ⊔ ideal.span {x} → I = J ⊔ ideal.span {x},	hxJ' : x ∈ J ⊔ ideal.span {x},	this : J ⊔ Jac • ideal.span {x} ≤ J ⊔ ideal.span {x},	this : Jac * ideal.span {x} ≤ J,	this : ideal.span {x} * Jac ^ (n + 1) ≤ ⊥	⊢ false
R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_artinian_ring R,	Jac : ideal R := ⊥.jacobson,	f : ℕ →ₘ order_dual (ideal R) := {to_fun := λ (n : ℕ), Jac ^ n, monotone' := _},	n : ℕ,	hn : ∀ (m : ℕ), n ≤ m → Jac ^ n = Jac ^ m,	J : ideal R := (Jac ^ n).annihilator,	hJ : J ≠ ⊤,	x : R,	hxJ : x ∉ J,	hJJ' : J < J ⊔ ideal.span {x},	hJ' : ∀ (I : ideal R), J < I → I ≤ J ⊔ ideal.span {x} → I = J ⊔ ideal.span {x},	hxJ' : x ∈ J ⊔ ideal.span {x},	this : J ⊔ Jac • ideal.span {x} ≤ J ⊔ ideal.span {x},	this : Jac * ideal.span {x} ≤ J	⊢ ideal.span {x} * Jac ^ (n + 1) = ideal.span {x} * Jac * Jac ^ n
R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_artinian_ring R,	Jac : ideal R := ⊥.jacobson,	f : ℕ →ₘ order_dual (ideal R) := {to_fun := λ (n : ℕ), Jac ^ n, monotone' := _},	n : ℕ,	hn : ∀ (m : ℕ), n ≤ m → Jac ^ n = Jac ^ m,	J : ideal R := (Jac ^ n).annihilator,	hJ : J ≠ ⊤,	x : R,	hxJ : x ∉ J,	hJJ' : J < J ⊔ ideal.span {x},	hJ' : ∀ (I : ideal R), J < I → I ≤ J ⊔ ideal.span {x} → I = J ⊔ ideal.span {x},	hxJ' : x ∈ J ⊔ ideal.span {x},	this : J ⊔ Jac • ideal.span {x} ≤ J ⊔ ideal.span {x},	this : Jac * ideal.span {x} ≤ J	⊢ ideal.span {x} * Jac ≤ J
R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_artinian_ring R,	Jac : ideal R := ⊥.jacobson,	f : ℕ →ₘ order_dual (ideal R) := {to_fun := λ (n : ℕ), Jac ^ n, monotone' := _},	n : ℕ,	hn : ∀ (m : ℕ), n ≤ m → Jac ^ n = Jac ^ m,	J : ideal R := (Jac ^ n).annihilator,	hJ : J ≠ ⊤,	x : R,	hxJ : x ∉ J,	hJJ' : J < J ⊔ ideal.span {x},	hJ' : ∀ (I : ideal R), J < I → I ≤ J ⊔ ideal.span {x} → I = J ⊔ ideal.span {x},	hxJ' : x ∈ J ⊔ ideal.span {x},	this : J ⊔ Jac • ideal.span {x} ≤ J ⊔ ideal.span {x},	this : Jac * ideal.span {x} ≤ J	⊢ J * Jac ^ n = ⊥
R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_artinian_ring R,	Jac : ideal R := ⊥.jacobson,	f : ℕ →ₘ order_dual (ideal R) := {to_fun := λ (n : ℕ), Jac ^ n, monotone' := _},	n : ℕ,	hn : ∀ (m : ℕ), n ≤ m → Jac ^ n = Jac ^ m,	J : ideal R := (Jac ^ n).annihilator,	hJ : J ≠ ⊤,	x : R,	hxJ : x ∉ J,	hJJ' : J < J ⊔ ideal.span {x},	hJ' : ∀ (I : ideal R), J < I → I ≤ J ⊔ ideal.span {x} → I = J ⊔ ideal.span {x},	hxJ' : x ∈ J ⊔ ideal.span {x},	this : J ⊔ Jac • ideal.span {x} ≤ J ⊔ ideal.span {x},	this : Jac * ideal.span {x} ≤ J,	this : ideal.span {x} * Jac ^ (n + 1) ≤ ⊥	⊢ false
R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_artinian_ring R,	Jac : ideal R := ⊥.jacobson,	f : ℕ →ₘ order_dual (ideal R) := {to_fun := λ (n : ℕ), Jac ^ n, monotone' := _},	n : ℕ,	hn : ∀ (m : ℕ), n ≤ m → Jac ^ n = Jac ^ m,	J : ideal R := (Jac ^ n).annihilator,	hJ : J ≠ ⊤,	x : R,	hxJ : x ∉ J,	hJJ' : J < J ⊔ ideal.span {x},	hJ' : ∀ (I : ideal R), J < I → I ≤ J ⊔ ideal.span {x} → I = J ⊔ ideal.span {x},	hxJ' : x ∈ J ⊔ ideal.span {x},	this : J ⊔ Jac • ideal.span {x} ≤ J ⊔ ideal.span {x},	this : Jac * ideal.span {x} ≤ J,	this : ideal.span {x} * Jac ^ (n + 1) ≤ ⊥,	y : R,	hy : y ∈ Jac ^ n	⊢ x • y ∈ ⊥
R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_artinian_ring R,	Jac : ideal R := ⊥.jacobson,	f : ℕ →ₘ order_dual (ideal R) := {to_fun := λ (n : ℕ), Jac ^ n, monotone' := _},	n : ℕ,	hn : ∀ (m : ℕ), n ≤ m → Jac ^ n = Jac ^ m,	J : ideal R := (Jac ^ n).annihilator,	hJ : J ≠ ⊤,	x : R,	hxJ : x ∉ J,	hJJ' : J < J ⊔ ideal.span {x},	hJ' : ∀ (I : ideal R), J < I → I ≤ J ⊔ ideal.span {x} → I = J ⊔ ideal.span {x},	hxJ' : x ∈ J ⊔ ideal.span {x},	this : J ⊔ Jac • ideal.span {x} ≤ J ⊔ ideal.span {x},	this : Jac * ideal.span {x} ≤ J,	this : ideal.span {x} * Jac ^ (n + 1) ≤ ⊥,	y : R,	hy : y ∈ Jac ^ n	⊢ y ∈ Jac ^ (n + 1)
R : Type u_1,	K : Type u_2,	_inst_1 : integral_domain R,	_inst_2 : field K,	_inst_5 : algebra R K,	_inst_6 : is_fraction_ring R K,	_inst_11 : is_dedekind_domain R,	I J : ↥(ideal R)⁰	⊢ ⇑(class_group.mk0 K) I = ⇑(class_group.mk0 K) J ↔ ∃ (x : K) (H : x ≠ 0), fractional_ideal.span_singleton R⁰ x * ↑I = ↑J
R : Type u_1,	K : Type u_2,	_inst_1 : integral_domain R,	_inst_2 : field K,	_inst_5 : algebra R K,	_inst_6 : is_fraction_ring R K,	_inst_11 : is_dedekind_domain R,	I J : ↥(ideal R)⁰	⊢ (∃ (z : units (fractional_ideal R⁰ K)) (H : z ∈ (to_principal_ideal R K).range), ⇑(fractional_ideal.mk0 K) I * z = ⇑(fractional_ideal.mk0 K) J) ↔ ∃ (x : K) (H : x ≠ 0), fractional_ideal.span_singleton R⁰ x * ↑I = ↑J
R : Type u_1,	K : Type u_2,	_inst_1 : integral_domain R,	_inst_2 : field K,	_inst_5 : algebra R K,	_inst_6 : is_fraction_ring R K,	_inst_11 : is_dedekind_domain R,	I J : ↥(ideal R)⁰	⊢ (∃ (z : units (fractional_ideal R⁰ K)) (H : z ∈ (to_principal_ideal R K).range), ⇑(fractional_ideal.mk0 K) I * z = ⇑(fractional_ideal.mk0 K) J) → (∃ (x : K) (H : x ≠ 0), fractional_ideal.span_singleton R⁰ x * ↑I = ↑J)
R : Type u_1,	K : Type u_2,	_inst_1 : integral_domain R,	_inst_2 : field K,	_inst_5 : algebra R K,	_inst_6 : is_fraction_ring R K,	_inst_11 : is_dedekind_domain R,	I J : ↥(ideal R)⁰,	x : units K,	hx : ⇑(fractional_ideal.mk0 K) I * ⇑(to_principal_ideal R K) x = ⇑(fractional_ideal.mk0 K) J	⊢ ∃ (x : K) (H : x ≠ 0), fractional_ideal.span_singleton R⁰ x * ↑I = ↑J
R : Type u_1,	K : Type u_2,	_inst_1 : integral_domain R,	_inst_2 : field K,	_inst_5 : algebra R K,	_inst_6 : is_fraction_ring R K,	_inst_11 : is_dedekind_domain R,	I J : ↥(ideal R)⁰,	x : units K,	hx : ⇑(fractional_ideal.mk0 K) I * ⇑(to_principal_ideal R K) x = ⇑(fractional_ideal.mk0 K) J	⊢ fractional_ideal.span_singleton R⁰ ↑x * ↑I = ↑J
R : Type u_1,	K : Type u_2,	_inst_1 : integral_domain R,	_inst_2 : field K,	_inst_5 : algebra R K,	_inst_6 : is_fraction_ring R K,	_inst_11 : is_dedekind_domain R,	I J : ↥(ideal R)⁰	⊢ (∃ (z : units (fractional_ideal R⁰ K)) (H : z ∈ (to_principal_ideal R K).range), ⇑(fractional_ideal.mk0 K) I * z = ⇑(fractional_ideal.mk0 K) J) → (∃ (x : K) (H : x ≠ 0), fractional_ideal.span_singleton R⁰ x * ↑I = ↑J)		R : Type u_1,	K : Type u_2,	_inst_1 : integral_domain R,	_inst_2 : field K,	_inst_5 : algebra R K,	_inst_6 : is_fraction_ring R K,	_inst_11 : is_dedekind_domain R,	I J : ↥(ideal R)⁰	⊢ (∃ (x : K) (H : x ≠ 0), fractional_ideal.span_singleton R⁰ x * ↑I = ↑J) → (∃ (z : units (fractional_ideal R⁰ K)) (H : z ∈ (to_principal_ideal R K).range), ⇑(fractional_ideal.mk0 K) I * z = ⇑(fractional_ideal.mk0 K) J)
R : Type u_1,	K : Type u_2,	_inst_1 : integral_domain R,	_inst_2 : field K,	_inst_5 : algebra R K,	_inst_6 : is_fraction_ring R K,	_inst_11 : is_dedekind_domain R,	I J : ↥(ideal R)⁰	⊢ (∃ (x : K) (H : x ≠ 0), fractional_ideal.span_singleton R⁰ x * ↑I = ↑J) → (∃ (z : units (fractional_ideal R⁰ K)) (H : z ∈ (to_principal_ideal R K).range), ⇑(fractional_ideal.mk0 K) I * z = ⇑(fractional_ideal.mk0 K) J)
R : Type u_1,	K : Type u_2,	_inst_1 : integral_domain R,	_inst_2 : field K,	_inst_5 : algebra R K,	_inst_6 : is_fraction_ring R K,	_inst_11 : is_dedekind_domain R,	I J : ↥(ideal R)⁰,	x : K,	hx : x ≠ 0,	eq_J : fractional_ideal.span_singleton R⁰ x * ↑I = ↑J	⊢ ∃ (z : units (fractional_ideal R⁰ K)) (H : z ∈ (to_principal_ideal R K).range), ⇑(fractional_ideal.mk0 K) I * z = ⇑(fractional_ideal.mk0 K) J
R : Type u_1,	K : Type u_2,	_inst_1 : integral_domain R,	_inst_2 : field K,	_inst_5 : algebra R K,	_inst_6 : is_fraction_ring R K,	_inst_11 : is_dedekind_domain R,	I J : ↥(ideal R)⁰,	x : K,	hx : x ≠ 0,	eq_J : fractional_ideal.span_singleton R⁰ x * ↑I = ↑J	⊢ ↑(⇑(fractional_ideal.mk0 K) I * ⇑(to_principal_ideal R K) (units.mk0 x hx)) = ↑(⇑(fractional_ideal.mk0 K) J)
R : Type u_1,	K : Type u_2,	_inst_1 : integral_domain R,	_inst_2 : field K,	_inst_5 : algebra R K,	_inst_6 : is_fraction_ring R K,	_inst_11 : is_principal_ideal_ring R	⊢ ∀ (x : class_group R K), x ∈ {1}
R : Type u_1,	K : Type u_2,	_inst_1 : integral_domain R,	_inst_2 : field K,	_inst_5 : algebra R K,	_inst_6 : is_fraction_ring R K,	_inst_11 : is_principal_ideal_ring R,	I : units (fractional_ideal R⁰ K)	⊢ quot.mk setoid.r I ∈ {1}
R : Type u_1,	K : Type u_2,	_inst_1 : integral_domain R,	_inst_2 : field K,	_inst_5 : algebra R K,	_inst_6 : is_fraction_ring R K,	_inst_11 : is_principal_ideal_ring R,	I : units (fractional_ideal R⁰ K)	⊢ quot.mk setoid.r I = 1
R : Type u,	_inst_1 : comm_semiring R,	x : R,	I : Type v,	s : I → R,	t : finset I,	b : I,	t : finset I,	hbt : b ∉ t,	ih : is_coprime (∏ (i : I) in t, s i) x ↔ ∀ (i : I), i ∈ t → is_coprime (s i) x	⊢ is_coprime (∏ (i : I) in has_insert.insert b t, s i) x ↔ ∀ (i : I), i ∈ has_insert.insert b t → is_coprime (s i) x
A : Type u_2,	_inst_2 : integral_domain A,	h : is_dedekind_domain_inv A	⊢ is_integrally_closed A
A : Type u_2,	_inst_2 : integral_domain A,	h : is_dedekind_domain_inv A,	x : fraction_ring A,	hx : is_integral A x	⊢ ∃ (y : A), ⇑(algebra_map A (fraction_ring A)) y = x
A : Type u_2,	_inst_2 : integral_domain A,	h : is_dedekind_domain_inv A,	x : fraction_ring A,	hx : is_integral A x	⊢ x ∈ ↑(fractional_ideal.adjoin_integral A⁰ x hx)		A : Type u_2,	_inst_2 : integral_domain A,	h : is_dedekind_domain_inv A,	x : fraction_ring A,	hx : is_integral A x	⊢ fractional_ideal.adjoin_integral A⁰ x hx ≠ 0
A : Type u_2,	_inst_2 : integral_domain A,	h : is_dedekind_domain_inv A,	x : fraction_ring A,	hx : is_integral A x	⊢ x ∈ ↑(fractional_ideal.adjoin_integral A⁰ x hx)
A : Type u_2,	_inst_2 : integral_domain A,	h : is_dedekind_domain_inv A,	x : fraction_ring A,	hx : is_integral A x	⊢ fractional_ideal.adjoin_integral A⁰ x hx ≠ 0
A : Type u_2,	K : Type u_3,	_inst_2 : integral_domain A,	_inst_3 : field K,	_inst_10 : algebra A K,	_inst_11 : is_fraction_ring A K,	I : ideal A,	hI : I ≠ ⊥	⊢ 1 ∈ (↑I)⁻¹
A : Type u_2,	K : Type u_3,	_inst_2 : integral_domain A,	_inst_3 : field K,	_inst_10 : algebra A K,	_inst_11 : is_fraction_ring A K,	I : ideal A,	hI : I ≠ ⊥	⊢ ∀ (y : K), y ∈ ↑I → 1 * y ∈ 1		A : Type u_2,	K : Type u_3,	_inst_2 : integral_domain A,	_inst_3 : field K,	_inst_10 : algebra A K,	_inst_11 : is_fraction_ring A K,	I : ideal A,	hI : I ≠ ⊥	⊢ is_fraction_ring A K
A : Type u_2,	K : Type u_3,	_inst_2 : integral_domain A,	_inst_3 : field K,	_inst_10 : algebra A K,	_inst_11 : is_fraction_ring A K,	I : ideal A,	hI : I ≠ ⊥,	y : K,	hy : y ∈ ↑I	⊢ 1 * y ∈ 1		A : Type u_2,	K : Type u_3,	_inst_2 : integral_domain A,	_inst_3 : field K,	_inst_10 : algebra A K,	_inst_11 : is_fraction_ring A K,	I : ideal A,	hI : I ≠ ⊥	⊢ is_fraction_ring A K
A : Type u_2,	K : Type u_3,	_inst_2 : integral_domain A,	_inst_3 : field K,	_inst_10 : algebra A K,	_inst_11 : is_fraction_ring A K,	I : ideal A,	hI : I ≠ ⊥,	y : K,	hy : y ∈ ↑I	⊢ y ∈ 1		A : Type u_2,	K : Type u_3,	_inst_2 : integral_domain A,	_inst_3 : field K,	_inst_10 : algebra A K,	_inst_11 : is_fraction_ring A K,	I : ideal A,	hI : I ≠ ⊥	⊢ is_fraction_ring A K
A : Type u_2,	K : Type u_3,	_inst_2 : integral_domain A,	_inst_3 : field K,	_inst_10 : algebra A K,	_inst_11 : is_fraction_ring A K,	I : ideal A,	hI : I ≠ ⊥	⊢ is_fraction_ring A K
R : Type u_1,	A : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_ring A,	_inst_3 : algebra R A	⊢ algebra.finite_type R A ↔ ∃ (n : ℕ) (f : mv_polynomial (fin n) R →ₐ[R] A), function.surjective ⇑f
R : Type u_1,	A : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_ring A,	_inst_3 : algebra R A	⊢ algebra.finite_type R A → (∃ (n : ℕ) (f : mv_polynomial (fin n) R →ₐ[R] A), function.surjective ⇑f)
R : Type u_1,	A : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_ring A,	_inst_3 : algebra R A	⊢ (∃ (ι : Type u_2) (_x : fintype ι) (f : mv_polynomial ι R →ₐ[R] A), function.surjective ⇑f) → (∃ (n : ℕ) (f : mv_polynomial (fin n) R →ₐ[R] A), function.surjective ⇑f)
R : Type u_1,	A : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_ring A,	_inst_3 : algebra R A,	ι : Type u_2,	hfintype : fintype ι,	f : mv_polynomial ι R →ₐ[R] A,	hsur : function.surjective ⇑f	⊢ ∃ (n : ℕ) (f : mv_polynomial (fin n) R →ₐ[R] A), function.surjective ⇑f
R : Type u_1,	A : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_ring A,	_inst_3 : algebra R A,	ι : Type u_2,	hfintype : fintype ι,	f : mv_polynomial ι R →ₐ[R] A,	hsur : function.surjective ⇑f,	_inst : fintype ι := hfintype	⊢ ∃ (n : ℕ) (f : mv_polynomial (fin n) R →ₐ[R] A), function.surjective ⇑f
R : Type u_1,	A : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_ring A,	_inst_3 : algebra R A,	ι : Type u_2,	hfintype : fintype ι,	f : mv_polynomial ι R →ₐ[R] A,	hsur : function.surjective ⇑f,	_inst : fintype ι := hfintype,	equiv : ι ≃ fin (fintype.card ι)	⊢ ∃ (n : ℕ) (f : mv_polynomial (fin n) R →ₐ[R] A), function.surjective ⇑f
R : Type u_1,	A : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_ring A,	_inst_3 : algebra R A,	ι : Type u_2,	hfintype : fintype ι,	f : mv_polynomial ι R →ₐ[R] A,	hsur : function.surjective ⇑f,	_inst : fintype ι := hfintype,	equiv : mv_polynomial ι R ≃ₐ[R] mv_polynomial (fin (fintype.card ι)) R	⊢ ∃ (n : ℕ) (f : mv_polynomial (fin n) R →ₐ[R] A), function.surjective ⇑f
R : Type u_1,	A : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_ring A,	_inst_3 : algebra R A	⊢ algebra.finite_type R A → (∃ (n : ℕ) (f : mv_polynomial (fin n) R →ₐ[R] A), function.surjective ⇑f)		R : Type u_1,	A : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_ring A,	_inst_3 : algebra R A	⊢ (∃ (n : ℕ) (f : mv_polynomial (fin n) R →ₐ[R] A), function.surjective ⇑f) → algebra.finite_type R A
R : Type u_1,	A : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_ring A,	_inst_3 : algebra R A	⊢ (∃ (n : ℕ) (f : mv_polynomial (fin n) R →ₐ[R] A), function.surjective ⇑f) → algebra.finite_type R A
R : Type u_1,	A : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_ring A,	_inst_3 : algebra R A,	n : ℕ,	f : mv_polynomial (fin n) R →ₐ[R] A,	hsur : function.surjective ⇑f	⊢ algebra.finite_type R A
A : Type u_1,	B : Type u_2,	C : Type u_3,	_inst_1 : comm_ring A,	_inst_2 : comm_ring B,	_inst_3 : comm_ring C,	f : A →+* B,	g : B →+* C,	h : (g.comp f).finite	⊢ g.finite
A : Type u_1,	B : Type u_2,	C : Type u_3,	_inst_1 : comm_ring A,	_inst_2 : comm_ring B,	_inst_3 : comm_ring C,	f : A →+* B,	g : B →+* C,	h : (g.comp f).finite,	_inst : algebra A B := f.to_algebra	⊢ g.finite
A : Type u_1,	B : Type u_2,	C : Type u_3,	_inst_1 : comm_ring A,	_inst_2 : comm_ring B,	_inst_3 : comm_ring C,	f : A →+* B,	g : B →+* C,	h : (g.comp f).finite,	_inst : algebra A B := f.to_algebra,	_inst_4 : algebra B C := g.to_algebra	⊢ g.finite
A : Type u_1,	B : Type u_2,	C : Type u_3,	_inst_1 : comm_ring A,	_inst_2 : comm_ring B,	_inst_3 : comm_ring C,	f : A →+* B,	g : B →+* C,	h : (g.comp f).finite,	_inst : algebra A B := f.to_algebra,	_inst_4 : algebra B C := g.to_algebra,	_inst_5 : algebra A C := (g.comp f).to_algebra	⊢ g.finite
A : Type u_1,	B : Type u_2,	C : Type u_3,	_inst_1 : comm_ring A,	_inst_2 : comm_ring B,	_inst_3 : comm_ring C,	f : A →+* B,	g : B →+* C,	h : (g.comp f).finite,	_inst : algebra A B := f.to_algebra,	_inst_4 : algebra B C := g.to_algebra,	_inst_5 : algebra A C := (g.comp f).to_algebra,	_inst_6 : is_scalar_tower A B C := restrict_scalars.is_scalar_tower A B C	⊢ g.finite
A : Type u_1,	B : Type u_2,	C : Type u_3,	_inst_1 : comm_ring A,	_inst_2 : comm_ring B,	_inst_3 : comm_ring C,	f : A →+* B,	g : B →+* C,	h : (g.comp f).finite,	_inst : algebra A B := f.to_algebra,	_inst_4 : algebra B C := g.to_algebra,	_inst_5 : algebra A C := (g.comp f).to_algebra,	_inst_6 : is_scalar_tower A B C := restrict_scalars.is_scalar_tower A B C,	_inst_7 : module.finite A C := h	⊢ g.finite
R : Type u_1,	M : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_monoid M,	_inst_3 : nontrivial R,	m : M,	S : set M	⊢ ⇑(monoid_algebra.of R M) m ∈ submodule.span R (⇑(monoid_algebra.of R M) '' S) ↔ m ∈ S
R : Type u_1,	M : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_monoid M,	_inst_3 : nontrivial R,	m : M,	S : set M,	h : ⇑(monoid_algebra.of R M) m ∈ submodule.span R (⇑(monoid_algebra.of R M) '' S)	⊢ m ∈ S
R : Type u_1,	M : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_monoid M,	_inst_3 : nontrivial R,	m : M,	S : set M,	h : ↑((finsupp.single m 1).support) ⊆ S	⊢ nontrivial R
R : Type u_1,	M : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_monoid M,	_inst_3 : nontrivial R,	m : M,	S : set M,	h : ↑{m} ⊆ S	⊢ m ∈ S
R : Type u_1,	_inst_1 : comm_ring R,	S : submonoid R,	P : Type u_2,	_inst_2 : comm_ring P,	_inst_3 : algebra R P,	loc : is_localization S P	⊢ fractional_ideal.span_singleton S 1 = 1
R : Type u_1,	_inst_1 : comm_ring R,	S : submonoid R,	P : Type u_2,	_inst_2 : comm_ring P,	_inst_3 : algebra R P,	loc : is_localization S P,	x : P	⊢ x ∈ fractional_ideal.span_singleton S 1 ↔ x ∈ 1
R : Type u_1,	_inst_1 : comm_ring R,	S : submonoid R,	P : Type u_2,	_inst_2 : comm_ring P,	_inst_3 : algebra R P,	loc : is_localization S P,	x : P	⊢ ∀ (a : R), a • 1 = x ↔ ⇑(algebra_map R P) a = x
R : Type u_1,	_inst_1 : comm_ring R,	S : submonoid R,	P : Type u_2,	_inst_2 : comm_ring P,	_inst_3 : algebra R P,	loc : is_localization S P,	x : P,	x' : R	⊢ x' • 1 = x ↔ ⇑(algebra_map R P) x' = x
R : Type u_1,	_inst_1 : comm_ring R,	S : submonoid R,	P : Type u_2,	_inst_2 : comm_ring P,	_inst_3 : algebra R P,	I : submodule R P,	J : fractional_ideal S P,	hIJ : I ≤ ↑J	⊢ is_fractional S I
R : Type u_1,	_inst_1 : comm_ring R,	S : submonoid R,	P : Type u_2,	_inst_2 : comm_ring P,	_inst_3 : algebra R P,	I : submodule R P,	J : fractional_ideal S P,	hIJ : I ≤ ↑J,	a : R,	a_mem : a ∈ S,	ha : ∀ (b : P), b ∈ ↑J → is_localization.is_integer R (a • b)	⊢ is_fractional S I
R : Type u_1,	_inst_1 : comm_ring R,	S : submonoid R,	P : Type u_2,	_inst_2 : comm_ring P,	_inst_3 : algebra R P,	I : submodule R P,	J : fractional_ideal S P,	hIJ : I ≤ ↑J,	a : R,	a_mem : a ∈ S,	ha : ∀ (b : P), b ∈ ↑J → is_localization.is_integer R (a • b)	⊢ ∀ (b : P), b ∈ I → is_localization.is_integer R (a • b)
R : Type u_1,	_inst_1 : comm_ring R,	S : submonoid R,	P : Type u_2,	_inst_2 : comm_ring P,	_inst_3 : algebra R P,	I : submodule R P,	J : fractional_ideal S P,	hIJ : I ≤ ↑J,	a : R,	a_mem : a ∈ S,	ha : ∀ (b : P), b ∈ ↑J → is_localization.is_integer R (a • b),	b : P,	b_mem : b ∈ I	⊢ is_localization.is_integer R (a • b)
R : Type u_1,	_inst_1 : comm_ring R,	S : submonoid R,	P : Type u_2,	_inst_2 : comm_ring P,	_inst_3 : algebra R P,	x : P,	_x : x ∈ 0,	_fun_match : x ∈ 0 → x = 0,	x' : R,	x'_mem_zero : x' ∈ ↑0,	x'_eq_x : ⇑(algebra.linear_map R P) x' = x,	x'_eq_zero : x' = 0	⊢ x = 0
R : Type u_1,	_inst_1 : comm_ring R,	S : submonoid R,	P : Type u_2,	_inst_2 : comm_ring P,	_inst_3 : algebra R P,	x : P,	hx : x = 0	⊢ ⇑(algebra.linear_map R P) 0 = x
R : Type u_1,	_inst_1 : comm_ring R,	K : Type u_3,	_inst_4 : field K,	_inst_6 : algebra R K,	_inst_7 : is_fraction_ring R K,	I : fractional_ideal R⁰ K,	_inst_10 : nontrivial R,	hI : I ≠ 0	⊢ ∃ (x : R) (H : x ≠ 0), ⇑(algebra_map R K) x ∈ I
R : Type u_1,	_inst_1 : comm_ring R,	K : Type u_3,	_inst_4 : field K,	_inst_6 : algebra R K,	_inst_7 : is_fraction_ring R K,	I : fractional_ideal R⁰ K,	_inst_10 : nontrivial R,	hI : I ≠ 0,	y : K,	y_mem : y ∈ I,	y_not_mem : y ∉ ⊥	⊢ y ≠ 0
R : Type u_1,	_inst_1 : comm_ring R,	K : Type u_3,	_inst_4 : field K,	_inst_6 : algebra R K,	_inst_7 : is_fraction_ring R K,	I : fractional_ideal R⁰ K,	_inst_10 : nontrivial R,	hI : I ≠ 0,	y : K,	y_mem : y ∈ I,	y_not_mem : y ∉ ⊥	⊢ ∃ (x : R) (H : x ≠ 0), ⇑(algebra_map R K) x ∈ I
R : Type u_1,	_inst_1 : comm_ring R,	K : Type u_3,	_inst_4 : field K,	_inst_6 : algebra R K,	_inst_7 : is_fraction_ring R K,	I : fractional_ideal R⁰ K,	_inst_10 : nontrivial R,	hI : I ≠ 0,	y : K,	y_mem : y ∈ I,	y_not_mem : y ∉ ⊥,	y_ne_zero : y ≠ 0	⊢ ∃ (x : R) (H : x ≠ 0), ⇑(algebra_map R K) x ∈ I
R : Type u_1,	_inst_1 : comm_ring R,	K : Type u_3,	_inst_4 : field K,	_inst_6 : algebra R K,	_inst_7 : is_fraction_ring R K,	I : fractional_ideal R⁰ K,	_inst_10 : nontrivial R,	hI : I ≠ 0,	y : K,	y_mem : y ∈ I,	y_not_mem : y ∉ ⊥,	y_ne_zero : y ≠ 0,	z : ↥R⁰,	x : R,	hx : ⇑(algebra_map R K) x = ↑z • y	⊢ ∃ (x : R) (H : x ≠ 0), ⇑(algebra_map R K) x ∈ I
R : Type u_1,	_inst_1 : comm_ring R,	K : Type u_3,	_inst_4 : field K,	_inst_6 : algebra R K,	_inst_7 : is_fraction_ring R K,	I : fractional_ideal R⁰ K,	_inst_10 : nontrivial R,	hI : I ≠ 0,	y : K,	y_mem : y ∈ I,	y_not_mem : y ∉ ⊥,	y_ne_zero : y ≠ 0,	z : ↥R⁰,	x : R,	hx : ⇑(algebra_map R K) x = ↑z • y	⊢ x ≠ 0
R : Type u_1,	_inst_1 : comm_ring R,	K : Type u_3,	_inst_4 : field K,	_inst_6 : algebra R K,	_inst_7 : is_fraction_ring R K,	I : fractional_ideal R⁰ K,	_inst_10 : nontrivial R,	hI : I ≠ 0,	y : K,	y_mem : y ∈ I,	y_not_mem : y ∉ ⊥,	y_ne_zero : y ≠ 0,	z : ↥R⁰,	x : R,	hx : ⇑(algebra_map R K) x = ↑z • y	⊢ ¬⇑(algebra_map R K) ↑z * y = 0
R : Type u_1,	_inst_1 : comm_ring R,	K : Type u_3,	_inst_4 : field K,	_inst_6 : algebra R K,	_inst_7 : is_fraction_ring R K,	I : fractional_ideal R⁰ K,	_inst_10 : nontrivial R,	hI : I ≠ 0,	y : K,	y_mem : y ∈ I,	y_not_mem : y ∉ ⊥,	y_ne_zero : y ≠ 0,	z : ↥R⁰,	x : R,	hx : ⇑(algebra_map R K) x = ↑z • y	⊢ x ≠ 0		R : Type u_1,	_inst_1 : comm_ring R,	K : Type u_3,	_inst_4 : field K,	_inst_6 : algebra R K,	_inst_7 : is_fraction_ring R K,	I : fractional_ideal R⁰ K,	_inst_10 : nontrivial R,	hI : I ≠ 0,	y : K,	y_mem : y ∈ I,	y_not_mem : y ∉ ⊥,	y_ne_zero : y ≠ 0,	z : ↥R⁰,	x : R,	hx : ⇑(algebra_map R K) x = ↑z • y	⊢ ⇑(algebra_map R K) x ∈ I
R : Type u_1,	_inst_1 : comm_ring R,	K : Type u_3,	_inst_4 : field K,	_inst_6 : algebra R K,	_inst_7 : is_fraction_ring R K,	I : fractional_ideal R⁰ K,	_inst_10 : nontrivial R,	hI : I ≠ 0,	y : K,	y_mem : y ∈ I,	y_not_mem : y ∉ ⊥,	y_ne_zero : y ≠ 0,	z : ↥R⁰,	x : R,	hx : ⇑(algebra_map R K) x = ↑z • y	⊢ ⇑(algebra_map R K) x ∈ I
R : Type u_1,	_inst_1 : comm_ring R,	K : Type u_3,	_inst_4 : field K,	_inst_6 : algebra R K,	_inst_7 : is_fraction_ring R K,	I : fractional_ideal R⁰ K,	_inst_10 : nontrivial R,	hI : I ≠ 0,	y : K,	y_mem : y ∈ I,	y_not_mem : y ∉ ⊥,	y_ne_zero : y ≠ 0,	z : ↥R⁰,	x : R,	hx : ⇑(algebra_map R K) x = ↑z • y	⊢ ↑z • y ∈ I
R₁ : Type u_3,	_inst_4 : integral_domain R₁,	K : Type u_4,	_inst_5 : field K,	_inst_6 : algebra R₁ K,	h : 0 = 1	⊢ 1 ∈ 0
R₁ : Type u_3,	_inst_4 : integral_domain R₁,	K : Type u_4,	_inst_5 : field K,	_inst_6 : algebra R₁ K,	h : 0 = 1	⊢ ⇑(algebra_map R₁ K) 1 ∈ 0
Γ : Type u_1,	R : Type u_2,	_inst_1 : ordered_cancel_add_comm_monoid Γ,	_inst_2 : non_unital_non_assoc_semiring R,	x y z : hahn_series Γ R	⊢ x * (y + z) = x * y + x * z
Γ : Type u_1,	R : Type u_2,	_inst_1 : ordered_cancel_add_comm_monoid Γ,	_inst_2 : non_unital_non_assoc_semiring R,	x y z : hahn_series Γ R,	a : Γ	⊢ (x * (y + z)).coeff a = (x * y + x * z).coeff a
Γ : Type u_1,	R : Type u_2,	_inst_1 : ordered_cancel_add_comm_monoid Γ,	_inst_2 : non_unital_non_assoc_semiring R,	x y z : hahn_series Γ R,	a : Γ,	hwf : (y.support ∪ z.support).is_pwo	⊢ (x * (y + z)).coeff a = (x * y + x * z).coeff a
Γ : Type u_1,	R : Type u_2,	_inst_1 : ordered_cancel_add_comm_monoid Γ,	_inst_2 : non_unital_non_assoc_semiring R,	x y z : hahn_series Γ R,	a : Γ,	hwf : (y.support ∪ z.support).is_pwo	⊢ ∑ (ij : Γ × Γ) in finset.add_antidiagonal _ hwf a, x.coeff ij.fst * (y + z).coeff ij.snd = ∑ (ij : Γ × Γ) in finset.add_antidiagonal _ hwf a, x.coeff ij.fst * y.coeff ij.snd + ∑ (ij : Γ × Γ) in finset.add_antidiagonal _ hwf a, x.coeff ij.fst * z.coeff ij.snd		Γ : Type u_1,	R : Type u_2,	_inst_1 : ordered_cancel_add_comm_monoid Γ,	_inst_2 : non_unital_non_assoc_semiring R,	x y z : hahn_series Γ R,	a : Γ,	hwf : (y.support ∪ z.support).is_pwo	⊢ (y + z).support ⊆ y.support ∪ z.support
Γ : Type u_1,	R : Type u_2,	_inst_1 : ordered_cancel_add_comm_monoid Γ,	_inst_2 : non_unital_non_assoc_semiring R,	x y z : hahn_series Γ R,	a : Γ,	hwf : (y.support ∪ z.support).is_pwo	⊢ ∑ (ij : Γ × Γ) in finset.add_antidiagonal _ hwf a, x.coeff ij.fst * (y + z).coeff ij.snd = ∑ (ij : Γ × Γ) in finset.add_antidiagonal _ hwf a, x.coeff ij.fst * y.coeff ij.snd + ∑ (ij : Γ × Γ) in finset.add_antidiagonal _ hwf a, x.coeff ij.fst * z.coeff ij.snd
Γ : Type u_1,	R : Type u_2,	_inst_1 : ordered_cancel_add_comm_monoid Γ,	_inst_2 : non_unital_non_assoc_semiring R,	x y z : hahn_series Γ R,	a : Γ,	hwf : (y.support ∪ z.support).is_pwo	⊢ (y + z).support ⊆ y.support ∪ z.support
Γ : Type u_1,	R : Type u_2,	_inst_1 : ordered_cancel_add_comm_monoid Γ,	_inst_2 : non_unital_non_assoc_semiring R,	x y z : hahn_series Γ R,	a : Γ,	hwf : (y.support ∪ z.support).is_pwo,	b : Γ	⊢ b ∈ (y + z).support → b ∈ y.support ∪ z.support
Γ : Type u_1,	R : Type u_2,	_inst_1 : ordered_cancel_add_comm_monoid Γ,	_inst_2 : non_unital_non_assoc_semiring R,	x y z : hahn_series Γ R,	a : Γ,	hwf : (y.support ∪ z.support).is_pwo,	b : Γ	⊢ ¬y.coeff b + z.coeff b = 0 → ¬y.coeff b = 0 ∨ ¬z.coeff b = 0
Γ : Type u_1,	R : Type u_2,	_inst_1 : ordered_cancel_add_comm_monoid Γ,	_inst_2 : non_unital_non_assoc_semiring R,	x y z : hahn_series Γ R,	a : Γ,	hwf : (y.support ∪ z.support).is_pwo,	b : Γ	⊢ y.coeff b = 0 ∧ z.coeff b = 0 → y.coeff b + z.coeff b = 0
Γ : Type u_1,	R : Type u_2,	_inst_1 : ordered_cancel_add_comm_monoid Γ,	_inst_2 : non_unital_non_assoc_semiring R,	x y z : hahn_series Γ R,	a : Γ,	hwf : (y.support ∪ z.support).is_pwo,	b : Γ,	h : y.coeff b = 0 ∧ z.coeff b = 0	⊢ y.coeff b + z.coeff b = 0
Γ : Type u_1,	R : Type u_2,	_inst_1 : ordered_cancel_add_comm_monoid Γ,	_inst_2 : non_unital_non_assoc_semiring R,	x y z : hahn_series Γ R	⊢ (x + y) * z = x * z + y * z
Γ : Type u_1,	R : Type u_2,	_inst_1 : ordered_cancel_add_comm_monoid Γ,	_inst_2 : non_unital_non_assoc_semiring R,	x y z : hahn_series Γ R,	a : Γ	⊢ ((x + y) * z).coeff a = (x * z + y * z).coeff a
Γ : Type u_1,	R : Type u_2,	_inst_1 : ordered_cancel_add_comm_monoid Γ,	_inst_2 : non_unital_non_assoc_semiring R,	x y z : hahn_series Γ R,	a : Γ,	hwf : (x.support ∪ y.support).is_pwo	⊢ ((x + y) * z).coeff a = (x * z + y * z).coeff a
Γ : Type u_1,	R : Type u_2,	_inst_1 : ordered_cancel_add_comm_monoid Γ,	_inst_2 : non_unital_non_assoc_semiring R,	x y z : hahn_series Γ R,	a : Γ,	hwf : (x.support ∪ y.support).is_pwo	⊢ ∑ (ij : Γ × Γ) in finset.add_antidiagonal hwf _ a, (x + y).coeff ij.fst * z.coeff ij.snd = ∑ (ij : Γ × Γ) in finset.add_antidiagonal hwf _ a, x.coeff ij.fst * z.coeff ij.snd + ∑ (ij : Γ × Γ) in finset.add_antidiagonal hwf _ a, y.coeff ij.fst * z.coeff ij.snd		Γ : Type u_1,	R : Type u_2,	_inst_1 : ordered_cancel_add_comm_monoid Γ,	_inst_2 : non_unital_non_assoc_semiring R,	x y z : hahn_series Γ R,	a : Γ,	hwf : (x.support ∪ y.support).is_pwo	⊢ (x + y).support ⊆ x.support ∪ y.support
Γ : Type u_1,	R : Type u_2,	_inst_1 : ordered_cancel_add_comm_monoid Γ,	_inst_2 : non_unital_non_assoc_semiring R,	x y z : hahn_series Γ R,	a : Γ,	hwf : (x.support ∪ y.support).is_pwo	⊢ ∑ (ij : Γ × Γ) in finset.add_antidiagonal hwf _ a, (x + y).coeff ij.fst * z.coeff ij.snd = ∑ (ij : Γ × Γ) in finset.add_antidiagonal hwf _ a, x.coeff ij.fst * z.coeff ij.snd + ∑ (ij : Γ × Γ) in finset.add_antidiagonal hwf _ a, y.coeff ij.fst * z.coeff ij.snd
Γ : Type u_1,	R : Type u_2,	_inst_1 : ordered_cancel_add_comm_monoid Γ,	_inst_2 : non_unital_non_assoc_semiring R,	x y z : hahn_series Γ R,	a : Γ,	hwf : (x.support ∪ y.support).is_pwo	⊢ (x + y).support ⊆ x.support ∪ y.support
Γ : Type u_1,	R : Type u_2,	_inst_1 : ordered_cancel_add_comm_monoid Γ,	_inst_2 : non_unital_non_assoc_semiring R,	x y z : hahn_series Γ R,	a : Γ,	hwf : (x.support ∪ y.support).is_pwo,	b : Γ	⊢ b ∈ (x + y).support → b ∈ x.support ∪ y.support
Γ : Type u_1,	R : Type u_2,	_inst_1 : ordered_cancel_add_comm_monoid Γ,	_inst_2 : non_unital_non_assoc_semiring R,	x y z : hahn_series Γ R,	a : Γ,	hwf : (x.support ∪ y.support).is_pwo,	b : Γ	⊢ ¬x.coeff b + y.coeff b = 0 → ¬x.coeff b = 0 ∨ ¬y.coeff b = 0
Γ : Type u_1,	R : Type u_2,	_inst_1 : ordered_cancel_add_comm_monoid Γ,	_inst_2 : non_unital_non_assoc_semiring R,	x y z : hahn_series Γ R,	a : Γ,	hwf : (x.support ∪ y.support).is_pwo,	b : Γ	⊢ x.coeff b = 0 ∧ y.coeff b = 0 → x.coeff b + y.coeff b = 0
Γ : Type u_1,	R : Type u_2,	_inst_1 : ordered_cancel_add_comm_monoid Γ,	_inst_2 : non_unital_non_assoc_semiring R,	x y z : hahn_series Γ R,	a : Γ,	hwf : (x.support ∪ y.support).is_pwo,	b : Γ,	h : x.coeff b = 0 ∧ y.coeff b = 0	⊢ x.coeff b + y.coeff b = 0
R : Type u,	S : Type v,	_inst_1 : ring R,	_inst_2 : ring S,	I : ideal R,	f : R ≃+* S	⊢ ideal.comap ↑f (ideal.comap ↑(f.symm) I) = I
R : Type u,	M : Type v,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	S : set R,	T : set M,	r : R,	hrS : r ∈ ideal.span S,	n : M,	hnT : n ∈ submodule.span R T,	r : R,	hrS : r ∈ S,	c : R,	m : M	⊢ r • m ∈ submodule.span R (⋃ (s : R) (H : s ∈ S) (t : M) (H : t ∈ T), {s • t}) → r • c • m ∈ submodule.span R (⋃ (s : R) (H : s ∈ S) (t : M) (H : t ∈ T), {s • t})
R : Type u,	M : Type v,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	S : set R,	T : set M,	r : R,	hrS : r ∈ ideal.span S,	n : M,	hnT : n ∈ submodule.span R T,	r : R,	hrS : r ∈ S,	c : R,	m : M	⊢ r • m ∈ submodule.span R (⋃ (s : R) (H : s ∈ S) (t : M) (H : t ∈ T), {s • t}) → r • c • m ∈ submodule.span R (⋃ (s : R) (H : s ∈ S) (t : M) (H : t ∈ T), {s • t})
R : Type u,	M : Type v,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	S : set R,	T : set M,	r : R,	hrS : r ∈ ideal.span S,	n : M,	hnT : n ∈ submodule.span R T,	r : R,	hrS : r ∈ S,	c : R,	m : M	⊢ r • m ∈ submodule.span R (⋃ (s : R) (H : s ∈ S) (t : M) (H : t ∈ T), {s • t}) → c • r • m ∈ submodule.span R (⋃ (s : R) (H : s ∈ S) (t : M) (H : t ∈ T), {s • t})
R : Type u,	M : Type v,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	S : set R,	T : set M,	r : R,	hrS : r ∈ ideal.span S,	n : M,	hnT : n ∈ submodule.span R T,	c r : R	⊢ r • n ∈ submodule.span R (⋃ (s : R) (H : s ∈ S) (t : M) (H : t ∈ T), {s • t}) → (c • r) • n ∈ submodule.span R (⋃ (s : R) (H : s ∈ S) (t : M) (H : t ∈ T), {s • t})
R : Type u,	M : Type v,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	S : set R,	T : set M,	r : R,	hrS : r ∈ ideal.span S,	n : M,	hnT : n ∈ submodule.span R T,	c r : R	⊢ r • n ∈ submodule.span R (⋃ (s : R) (H : s ∈ S) (t : M) (H : t ∈ T), {s • t}) → (c • r) • n ∈ submodule.span R (⋃ (s : R) (H : s ∈ S) (t : M) (H : t ∈ T), {s • t})
R : Type u,	M : Type v,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	S : set R,	T : set M,	r : R,	hrS : r ∈ ideal.span S,	n : M,	hnT : n ∈ submodule.span R T,	c r : R	⊢ r • n ∈ submodule.span R (⋃ (s : R) (H : s ∈ S) (t : M) (H : t ∈ T), {s • t}) → c • r • n ∈ submodule.span R (⋃ (s : R) (H : s ∈ S) (t : M) (H : t ∈ T), {s • t})
R : Type u,	_inst_1 : comm_ring R,	ι : Type v,	_inst_2 : fintype ι,	f : ι → ideal R,	hf : ∀ (i j : ι), i ≠ j → f i ⊔ f j = ⊤,	g : ι → R	⊢ ∃ (r : R), ∀ (i : ι), r - g i ∈ f i
R : Type u,	_inst_1 : comm_ring R,	ι : Type v,	_inst_2 : fintype ι,	f : ι → ideal R,	hf : ∀ (i j : ι), i ≠ j → f i ⊔ f j = ⊤,	g : ι → R	⊢ ∃ (φ : ι → R), (∀ (i : ι), φ i - 1 ∈ f i) ∧ ∀ (i j : ι), i ≠ j → φ i ∈ f j
R : Type u,	_inst_1 : comm_ring R,	ι : Type v,	_inst_2 : fintype ι,	f : ι → ideal R,	hf : ∀ (i j : ι), i ≠ j → f i ⊔ f j = ⊤,	g : ι → R,	this : ∀ (i : ι), i ∈ finset.univ → (∃ (r : R), r - 1 ∈ (λ (i : ι), f i) i ∧ ∀ (j : ι), j ∈ finset.univ → j ≠ i → r ∈ (λ (i : ι), f i) j)	⊢ ∃ (φ : ι → R), (∀ (i : ι), φ i - 1 ∈ f i) ∧ ∀ (i j : ι), i ≠ j → φ i ∈ f j
R : Type u,	_inst_1 : comm_ring R,	ι : Type v,	_inst_2 : fintype ι,	f : ι → ideal R,	hf : ∀ (i j : ι), i ≠ j → f i ⊔ f j = ⊤,	g : ι → R,	φ : Π (i : ι), i ∈ finset.univ → R,	hφ : ∀ (i : ι) (his : i ∈ finset.univ), φ i his - 1 ∈ (λ (i : ι), f i) i ∧ ∀ (j : ι), j ∈ finset.univ → j ≠ i → φ i his ∈ (λ (i : ι), f i) j	⊢ ∃ (φ : ι → R), (∀ (i : ι), φ i - 1 ∈ f i) ∧ ∀ (i j : ι), i ≠ j → φ i ∈ f j
R : Type u,	_inst_1 : comm_ring R,	ι : Type v,	_inst_2 : fintype ι,	f : ι → ideal R,	hf : ∀ (i j : ι), i ≠ j → f i ⊔ f j = ⊤,	g : ι → R,	φ : Π (i : ι), i ∈ finset.univ → R,	hφ : ∀ (i : ι) (his : i ∈ finset.univ), φ i his - 1 ∈ (λ (i : ι), f i) i ∧ ∀ (j : ι), j ∈ finset.univ → j ≠ i → φ i his ∈ (λ (i : ι), f i) j	⊢ (∀ (i : ι), (λ (i : ι), φ i _) i - 1 ∈ f i) ∧ ∀ (i j : ι), i ≠ j → (λ (i : ι), φ i _) i ∈ f j
R : Type u,	_inst_1 : comm_ring R,	ι : Type v,	_inst_2 : fintype ι,	f : ι → ideal R,	hf : ∀ (i j : ι), i ≠ j → f i ⊔ f j = ⊤,	g : ι → R	⊢ ∃ (φ : ι → R), (∀ (i : ι), φ i - 1 ∈ f i) ∧ ∀ (i j : ι), i ≠ j → φ i ∈ f j		R : Type u,	_inst_1 : comm_ring R,	ι : Type v,	_inst_2 : fintype ι,	f : ι → ideal R,	hf : ∀ (i j : ι), i ≠ j → f i ⊔ f j = ⊤,	g : ι → R,	this : ∃ (φ : ι → R), (∀ (i : ι), φ i - 1 ∈ f i) ∧ ∀ (i j : ι), i ≠ j → φ i ∈ f j	⊢ ∃ (r : R), ∀ (i : ι), r - g i ∈ f i
R : Type u,	_inst_1 : comm_ring R,	ι : Type v,	_inst_2 : fintype ι,	f : ι → ideal R,	hf : ∀ (i j : ι), i ≠ j → f i ⊔ f j = ⊤,	g : ι → R,	this : ∃ (φ : ι → R), (∀ (i : ι), φ i - 1 ∈ f i) ∧ ∀ (i j : ι), i ≠ j → φ i ∈ f j	⊢ ∃ (r : R), ∀ (i : ι), r - g i ∈ f i
R : Type u,	_inst_1 : comm_ring R,	ι : Type v,	_inst_2 : fintype ι,	f : ι → ideal R,	hf : ∀ (i j : ι), i ≠ j → f i ⊔ f j = ⊤,	g φ : ι → R,	hφ1 : ∀ (i : ι), φ i - 1 ∈ f i,	hφ2 : ∀ (i j : ι), i ≠ j → φ i ∈ f j	⊢ ∃ (r : R), ∀ (i : ι), r - g i ∈ f i
R : Type u,	_inst_1 : comm_ring R,	ι : Type v,	_inst_2 : fintype ι,	f : ι → ideal R,	hf : ∀ (i j : ι), i ≠ j → f i ⊔ f j = ⊤,	g φ : ι → R,	hφ1 : ∀ (i : ι), φ i - 1 ∈ f i,	hφ2 : ∀ (i j : ι), i ≠ j → φ i ∈ f j	⊢ ∀ (i : ι), ∑ (i : ι), g i * φ i - g i ∈ f i
R : Type u,	_inst_1 : comm_ring R,	ι : Type v,	_inst_2 : fintype ι,	f : ι → ideal R,	hf : ∀ (i j : ι), i ≠ j → f i ⊔ f j = ⊤,	g φ : ι → R,	hφ1 : ∀ (i : ι), φ i - 1 ∈ f i,	hφ2 : ∀ (i j : ι), i ≠ j → φ i ∈ f j,	i : ι	⊢ ∑ (i : ι), g i * φ i - g i ∈ f i
R : Type u,	_inst_1 : comm_ring R,	ι : Type v,	_inst_2 : fintype ι,	f : ι → ideal R,	hf : ∀ (i j : ι), i ≠ j → f i ⊔ f j = ⊤,	g φ : ι → R,	hφ1 : ∀ (i : ι), φ i - 1 ∈ f i,	hφ2 : ∀ (i j : ι), i ≠ j → φ i ∈ f j,	i : ι	⊢ ∑ (x : ι), ⇑(ideal.quotient.mk (f i)) (g x * φ x) = ⇑(ideal.quotient.mk (f i)) (g i)
R : Type u,	_inst_1 : comm_ring R,	ι : Type v,	_inst_2 : fintype ι,	f : ι → ideal R,	hf : ∀ (i j : ι), i ≠ j → f i ⊔ f j = ⊤,	g φ : ι → R,	hφ1 : ∀ (i : ι), φ i - 1 ∈ f i,	hφ2 : ∀ (i j : ι), i ≠ j → φ i ∈ f j,	i j : ι,	H : j ∈ finset.univ,	hji : j ≠ i	⊢ ⇑(ideal.quotient.mk (f i)) (g j * φ j) = 0
R : Type u,	_inst_1 : comm_ring R,	ι : Type v,	_inst_2 : fintype ι,	f : ι → ideal R,	hf : ∀ (i j : ι), i ≠ j → f i ⊔ f j = ⊤,	g φ : ι → R,	hφ1 : ∀ (i : ι), φ i - 1 ∈ f i,	hφ2 : ∀ (i j : ι), i ≠ j → φ i ∈ f j,	i j : ι,	H : j ∈ finset.univ,	hji : j ≠ i	⊢ g j * φ j ∈ f i
R : Type u,	_inst_1 : comm_ring R,	ι : Type v,	_inst_2 : fintype ι,	f : ι → ideal R,	hf : ∀ (i j : ι), i ≠ j → f i ⊔ f j = ⊤,	g φ : ι → R,	hφ1 : ∀ (i : ι), φ i - 1 ∈ f i,	hφ2 : ∀ (i j : ι), i ≠ j → φ i ∈ f j,	i : ι	⊢ ∀ (b : ι), b ∈ finset.univ → b ≠ i → ⇑(ideal.quotient.mk (f i)) (g b * φ b) = 0
R : Type u,	_inst_1 : comm_ring R,	ι : Type v,	_inst_2 : fintype ι,	f : ι → ideal R,	hf : ∀ (i j : ι), i ≠ j → f i ⊔ f j = ⊤,	g φ : ι → R,	hφ1 : ∀ (i : ι), φ i - 1 ∈ f i,	hφ2 : ∀ (i j : ι), i ≠ j → φ i ∈ f j,	i : ι	⊢ ∀ (b : ι), b ∈ finset.univ → b ≠ i → ⇑(ideal.quotient.mk (f i)) (g b * φ b) = 0		R : Type u,	_inst_1 : comm_ring R,	ι : Type v,	_inst_2 : fintype ι,	f : ι → ideal R,	hf : ∀ (i j : ι), i ≠ j → f i ⊔ f j = ⊤,	g φ : ι → R,	hφ1 : ∀ (i : ι), φ i - 1 ∈ f i,	hφ2 : ∀ (i j : ι), i ≠ j → φ i ∈ f j,	i : ι	⊢ i ∉ finset.univ → ⇑(ideal.quotient.mk (f i)) (g i * φ i) = 0		R : Type u,	_inst_1 : comm_ring R,	ι : Type v,	_inst_2 : fintype ι,	f : ι → ideal R,	hf : ∀ (i j : ι), i ≠ j → f i ⊔ f j = ⊤,	g φ : ι → R,	hφ1 : ∀ (i : ι), φ i - 1 ∈ f i,	hφ2 : ∀ (i j : ι), i ≠ j → φ i ∈ f j,	i : ι	⊢ ⇑(ideal.quotient.mk (f i)) (g i * φ i) = ⇑(ideal.quotient.mk (f i)) (g i)
R : Type u,	_inst_1 : comm_ring R,	ι : Type v,	_inst_2 : fintype ι,	f : ι → ideal R,	hf : ∀ (i j : ι), i ≠ j → f i ⊔ f j = ⊤,	g φ : ι → R,	hφ1 : ∀ (i : ι), φ i - 1 ∈ f i,	hφ2 : ∀ (i j : ι), i ≠ j → φ i ∈ f j,	i : ι,	hi : i ∉ finset.univ	⊢ ⇑(ideal.quotient.mk (f i)) (g i * φ i) = 0
R : Type u,	_inst_1 : comm_ring R,	ι : Type v,	_inst_2 : fintype ι,	f : ι → ideal R,	hf : ∀ (i j : ι), i ≠ j → f i ⊔ f j = ⊤,	g φ : ι → R,	hφ1 : ∀ (i : ι), φ i - 1 ∈ f i,	hφ2 : ∀ (i j : ι), i ≠ j → φ i ∈ f j,	i : ι	⊢ i ∉ finset.univ → ⇑(ideal.quotient.mk (f i)) (g i * φ i) = 0		R : Type u,	_inst_1 : comm_ring R,	ι : Type v,	_inst_2 : fintype ι,	f : ι → ideal R,	hf : ∀ (i j : ι), i ≠ j → f i ⊔ f j = ⊤,	g φ : ι → R,	hφ1 : ∀ (i : ι), φ i - 1 ∈ f i,	hφ2 : ∀ (i j : ι), i ≠ j → φ i ∈ f j,	i : ι	⊢ ⇑(ideal.quotient.mk (f i)) (g i * φ i) = ⇑(ideal.quotient.mk (f i)) (g i)
R : Type u,	_inst_1 : comm_ring R,	ι : Type v,	_inst_2 : fintype ι,	f : ι → ideal R,	hf : ∀ (i j : ι), i ≠ j → f i ⊔ f j = ⊤,	g φ : ι → R,	hφ1 : ∀ (i : ι), φ i - 1 ∈ f i,	hφ2 : ∀ (i j : ι), i ≠ j → φ i ∈ f j,	i : ι	⊢ i ∉ finset.univ → ⇑(ideal.quotient.mk (f i)) (g i * φ i) = 0
R : Type u,	_inst_1 : comm_ring R,	ι : Type v,	_inst_2 : fintype ι,	f : ι → ideal R,	hf : ∀ (i j : ι), i ≠ j → f i ⊔ f j = ⊤,	g φ : ι → R,	hφ2 : ∀ (i j : ι), i ≠ j → φ i ∈ f j,	i : ι,	hφ1 : φ i - 1 ∈ f i	⊢ ⇑(ideal.quotient.mk (f i)) (g i * φ i) = ⇑(ideal.quotient.mk (f i)) (g i)
R : Type u,	_inst_1 : comm_ring R,	ι : Type v,	_inst_2 : fintype ι,	f : ι → ideal R,	hf : ∀ (i j : ι), i ≠ j → f i ⊔ f j = ⊤,	g φ : ι → R,	hφ1 : ∀ (i : ι), φ i - 1 ∈ f i,	hφ2 : ∀ (i j : ι), i ≠ j → φ i ∈ f j,	i : ι	⊢ ⇑(ideal.quotient.mk (f i)) (g i * φ i) = ⇑(ideal.quotient.mk (f i)) (g i)
R : Type u,	_inst_1 : comm_ring R,	ι : Type v,	_inst_2 : fintype ι,	f : ι → ideal R,	hf : ∀ (i j : ι), i ≠ j → f i ⊔ f j = ⊤,	g φ : ι → R,	hφ2 : ∀ (i j : ι), i ≠ j → φ i ∈ f j,	i : ι,	hφ1 : ⇑(ideal.quotient.mk (f i)) (φ i) = 1	⊢ ⇑(ideal.quotient.mk (f i)) (g i * φ i) = ⇑(ideal.quotient.mk (f i)) (g i)
R : Type u_1,	_inst_1 : comm_ring R,	S : Type u_2,	_inst_2 : integral_domain S,	I J : ideal S,	_inst_3 : algebra R S,	hI : I.is_prime,	hIJ : I ≤ J,	x : S,	mem : x ∈ ↑J \ ↑I,	integral : is_integral R x	⊢ ideal.comap (algebra_map R S) I < ideal.comap (algebra_map R S) J
R : Type u_1,	_inst_1 : comm_ring R,	S : Type u_2,	_inst_2 : integral_domain S,	I J : ideal S,	_inst_3 : algebra R S,	hI : I.is_prime,	hIJ : I ≤ J,	x : S,	mem : x ∈ ↑J \ ↑I,	p : polynomial R,	p_monic : p.monic,	hpx : polynomial.eval₂ (algebra_map R S) x p = 0	⊢ ideal.comap (algebra_map R S) I < ideal.comap (algebra_map R S) J
R : Type u_1,	_inst_1 : comm_ring R,	S : Type u_2,	_inst_2 : integral_domain S,	I J : ideal S,	_inst_3 : algebra R S,	hI : I.is_prime,	hIJ : I ≤ J,	x : S,	mem : x ∈ ↑J \ ↑I,	p : polynomial R,	p_monic : p.monic,	hpx : polynomial.eval₂ (algebra_map R S) x p = 0	⊢ polynomial R		R : Type u_1,	_inst_1 : comm_ring R,	S : Type u_2,	_inst_2 : integral_domain S,	I J : ideal S,	_inst_3 : algebra R S,	hI : I.is_prime,	hIJ : I ≤ J,	x : S,	mem : x ∈ ↑J \ ↑I,	p : polynomial R,	p_monic : p.monic,	hpx : polynomial.eval₂ (algebra_map R S) x p = 0	⊢ polynomial.map (ideal.quotient.mk (ideal.comap (algebra_map R S) I)) ?m_1 ≠ 0		R : Type u_1,	_inst_1 : comm_ring R,	S : Type u_2,	_inst_2 : integral_domain S,	I J : ideal S,	_inst_3 : algebra R S,	hI : I.is_prime,	hIJ : I ≤ J,	x : S,	mem : x ∈ ↑J \ ↑I,	p : polynomial R,	p_monic : p.monic,	hpx : polynomial.eval₂ (algebra_map R S) x p = 0	⊢ polynomial.eval₂ (algebra_map R S) x ?m_1 ∈ I
R : Type u_1,	_inst_1 : comm_ring R,	S : Type u_2,	_inst_2 : integral_domain S,	I J : ideal S,	_inst_3 : algebra R S,	hI : I.is_prime,	hIJ : I ≤ J,	x : S,	mem : x ∈ ↑J \ ↑I,	p : polynomial R,	p_monic : p.monic,	hpx : polynomial.eval₂ (algebra_map R S) x p = 0	⊢ polynomial.map (ideal.quotient.mk (ideal.comap (algebra_map R S) I)) ?m_1 ≠ 0
R : Type u_1,	_inst_1 : comm_ring R,	S : Type u_2,	_inst_2 : integral_domain S,	I J : ideal S,	_inst_3 : algebra R S,	hI : I.is_prime,	hIJ : I ≤ J,	x : S,	mem : x ∈ ↑J \ ↑I,	p : polynomial R,	p_monic : p.monic,	hpx : polynomial.eval₂ (algebra_map R S) x p = 0	⊢ nontrivial (ideal.comap (algebra_map R S) I).quotient
R : Type u_1,	_inst_1 : comm_ring R,	S : Type u_2,	_inst_2 : integral_domain S,	I J : ideal S,	_inst_3 : algebra R S,	hI : I.is_prime,	hIJ : I ≤ J,	x : S,	mem : x ∈ ↑J \ ↑I,	p : polynomial R,	p_monic : p.monic,	hpx : polynomial.eval₂ (algebra_map R S) x p = 0	⊢ ideal.comap (algebra_map R S) I ≠ ⊤
R : Type u_1,	_inst_1 : comm_ring R,	S : Type u_2,	_inst_2 : integral_domain S,	I J : ideal S,	_inst_3 : algebra R S,	hI : I.is_prime,	hIJ : I ≤ J,	x : S,	mem : x ∈ ↑J \ ↑I,	p : polynomial R,	p_monic : p.monic,	hpx : polynomial.eval₂ (algebra_map R S) x p = 0	⊢ polynomial.map (ideal.quotient.mk (ideal.comap (algebra_map R S) I)) ?m_1 ≠ 0		R : Type u_1,	_inst_1 : comm_ring R,	S : Type u_2,	_inst_2 : integral_domain S,	I J : ideal S,	_inst_3 : algebra R S,	hI : I.is_prime,	hIJ : I ≤ J,	x : S,	mem : x ∈ ↑J \ ↑I,	p : polynomial R,	p_monic : p.monic,	hpx : polynomial.eval₂ (algebra_map R S) x p = 0	⊢ polynomial R		R : Type u_1,	_inst_1 : comm_ring R,	S : Type u_2,	_inst_2 : integral_domain S,	I J : ideal S,	_inst_3 : algebra R S,	hI : I.is_prime,	hIJ : I ≤ J,	x : S,	mem : x ∈ ↑J \ ↑I,	p : polynomial R,	p_monic : p.monic,	hpx : polynomial.eval₂ (algebra_map R S) x p = 0	⊢ polynomial.eval₂ (algebra_map R S) x ?m_1 ∈ I
R : Type u_1,	_inst_1 : comm_ring R,	S : Type u_2,	_inst_2 : integral_domain S,	I J : ideal S,	_inst_3 : algebra R S,	hI : I.is_prime,	hIJ : I ≤ J,	x : S,	mem : x ∈ ↑J \ ↑I,	p : polynomial R,	p_monic : p.monic,	hpx : polynomial.eval₂ (algebra_map R S) x p = 0	⊢ ¬I = ⊤
R : Type u_1,	_inst_1 : comm_ring R,	S : Type u_2,	_inst_2 : integral_domain S,	I J : ideal S,	_inst_3 : algebra R S,	hI : I.is_prime,	hIJ : I ≤ J,	x : S,	mem : x ∈ ↑J \ ↑I,	p : polynomial R,	p_monic : p.monic,	hpx : polynomial.eval₂ (algebra_map R S) x p = 0	⊢ polynomial.eval₂ (algebra_map R S) x p ∈ I
R : Type u,	S : Type v,	_inst_1 : ring R,	_inst_2 : ring S,	I : ideal R,	J : ideal S	⊢ (I.prod J).is_prime → I = ⊤ ∨ J = ⊤
R : Type u,	S : Type v,	_inst_1 : ring R,	_inst_2 : ring S,	I : ideal R,	J : ideal S	⊢ I ≠ ⊤ ∧ J ≠ ⊤ → ¬(I.prod J).is_prime
R : Type u,	S : Type v,	_inst_1 : ring R,	_inst_2 : ring S,	I : ideal R,	J : ideal S	⊢ 1 ∉ I ∧ 1 ∉ J → 1 ∉ I.prod J → (∃ (x x_1 : R × S) (x_2 : x * x_1 ∈ I.prod J), x ∉ I.prod J ∧ x_1 ∉ I.prod J)
R : Type u,	S : Type v,	_inst_1 : ring R,	_inst_2 : ring S,	I : ideal R,	J : ideal S,	_x : 1 ∉ I ∧ 1 ∉ J,	_fun_match : 1 ∉ I ∧ 1 ∉ J → 1 ∉ I.prod J → (∃ (x x_1 : R × S) (x_2 : x * x_1 ∈ I.prod J), x ∉ I.prod J ∧ x_1 ∉ I.prod J),	hI : 1 ∉ I,	hJ : 1 ∉ J,	hIJ : 1 ∉ I.prod J	⊢ (0, 1) * (1, 0) ∈ I.prod J
R : Type u,	S : Type v,	_inst_1 : ring R,	_inst_2 : ring S,	I : ideal R,	J : ideal S,	_x : 1 ∉ I ∧ 1 ∉ J,	_fun_match : 1 ∉ I ∧ 1 ∉ J → 1 ∉ I.prod J → (∃ (x x_1 : R × S) (x_2 : x * x_1 ∈ I.prod J), x ∉ I.prod J ∧ x_1 ∉ I.prod J),	hI : 1 ∉ I,	hJ : 1 ∉ J,	hIJ : 1 ∉ I.prod J	⊢ (0, 1) ∉ I.prod J
R : Type u,	S : Type v,	_inst_1 : ring R,	_inst_2 : ring S,	I : ideal R,	J : ideal S,	_x : 1 ∉ I ∧ 1 ∉ J,	_fun_match : 1 ∉ I ∧ 1 ∉ J → 1 ∉ I.prod J → (∃ (x x_1 : R × S) (x_2 : x * x_1 ∈ I.prod J), x ∉ I.prod J ∧ x_1 ∉ I.prod J),	hI : 1 ∉ I,	hJ : 1 ∉ J,	hIJ : 1 ∉ I.prod J	⊢ (1, 0) ∉ I.prod J
R : Type u,	S : Type v,	_inst_1 : ring R,	_inst_2 : ring S,	I : ideal R,	h : I.is_prime	⊢ (I.prod ⊤).is_prime
R : Type u_1,	_inst_1 : integral_domain R,	S : subgroup (units R),	_inst_4 : fintype ↥S	⊢ is_cyclic ↥S
R : Type u_1,	_inst_1 : integral_domain R,	S : subgroup (units R),	_inst_4 : fintype ↥S	⊢ ↑1 = 1		R : Type u_1,	_inst_1 : integral_domain R,	S : subgroup (units R),	_inst_4 : fintype ↥S	⊢ ∀ (x y : ↥S), ↑(x * y) = ↑x * ↑y
R : Type u_1,	_inst_1 : integral_domain R,	S : subgroup (units R),	_inst_4 : fintype ↥S	⊢ ↑1 = 1
R : Type u_1,	_inst_1 : integral_domain R,	S : subgroup (units R),	_inst_4 : fintype ↥S,	x y : ↥S	⊢ ↑(x * y) = ↑x * ↑y
R : Type u_1,	_inst_1 : integral_domain R,	S : subgroup (units R),	_inst_4 : fintype ↥S	⊢ ∀ (x y : ↥S), ↑(x * y) = ↑x * ↑y
R : Type u_1,	_inst_1 : semiring R,	x : laurent_series R	⊢ ⇑(hahn_series.single (hahn_series.order x)) 1 * ↑(x.power_series_part) = x
R : Type u_1,	_inst_1 : semiring R,	x : laurent_series R,	n : ℤ	⊢ (⇑(hahn_series.single (hahn_series.order x)) 1 * ↑(x.power_series_part)).coeff n = x.coeff n
R : Type u_1,	_inst_1 : semiring R,	x : laurent_series R,	n : ℤ	⊢ ↑(x.power_series_part).coeff (n - hahn_series.order x) = x.coeff n
R : Type u_1,	_inst_1 : semiring R,	x : laurent_series R,	n : ℤ,	h : hahn_series.order x ≤ n	⊢ ↑(x.power_series_part).coeff (n - hahn_series.order x) = x.coeff n
R : Type u_1,	_inst_1 : semiring R,	x : laurent_series R,	n : ℤ,	h : hahn_series.order x ≤ n	⊢ ↑(x.power_series_part).coeff (n - hahn_series.order x) = x.coeff n		R : Type u_1,	_inst_1 : semiring R,	x : laurent_series R,	n : ℤ,	h : ¬hahn_series.order x ≤ n	⊢ ↑(x.power_series_part).coeff (n - hahn_series.order x) = x.coeff n
R : Type u_1,	_inst_1 : semiring R,	x : laurent_series R,	n : ℤ,	h : ¬hahn_series.order x ≤ n	⊢ ↑(x.power_series_part).coeff (n - hahn_series.order x) = x.coeff n
R : Type u_1,	_inst_1 : semiring R,	x : laurent_series R,	n : ℤ,	h : ¬hahn_series.order x ≤ n	⊢ 0 = x.coeff n
R : Type u_1,	_inst_1 : semiring R,	x : laurent_series R,	n : ℤ,	h : ¬hahn_series.order x ≤ n	⊢ 0 = x.coeff n		R : Type u_1,	_inst_1 : semiring R,	x : laurent_series R,	n : ℤ,	h : ¬hahn_series.order x ≤ n	⊢ n - hahn_series.order x ∉ set.range ⇑{to_embedding := {to_fun := coe coe_to_lift, inj' := _}, map_rel_iff' := _}
R : Type u_1,	_inst_1 : semiring R,	x : laurent_series R,	n : ℤ,	h : 0 ≠ x.coeff n	⊢ hahn_series.order x ≤ n
R : Type u_1,	_inst_1 : semiring R,	x : laurent_series R,	n : ℤ,	h : ¬hahn_series.order x ≤ n	⊢ n - hahn_series.order x ∉ set.range ⇑{to_embedding := {to_fun := coe coe_to_lift, inj' := _}, map_rel_iff' := _}
R : Type u_1,	_inst_1 : semiring R,	x : laurent_series R,	n : ℤ,	h : n - hahn_series.order x ∈ set.range ⇑{to_embedding := {to_fun := coe coe_to_lift, inj' := _}, map_rel_iff' := _}	⊢ hahn_series.order x ≤ n
R : Type u_1,	_inst_1 : semiring R,	x : laurent_series R,	n : ℤ,	h : ∃ (y : ℕ), ↑y = n - hahn_series.order x	⊢ hahn_series.order x ≤ n
R : Type u_1,	_inst_1 : semiring R,	x : laurent_series R,	n : ℤ,	m : ℕ,	hm : ↑m = n - hahn_series.order x	⊢ hahn_series.order x ≤ n
R : Type u_1,	_inst_1 : semiring R,	x : laurent_series R,	n : ℤ,	m : ℕ,	hm : ↑m = n - hahn_series.order x	⊢ 0 ≤ ↑m
R : Type u_1,	_inst_1 : comm_ring R,	M : submonoid R,	S : Type u_2,	_inst_2 : comm_ring S,	_inst_3 : algebra R S,	_inst_5 : is_localization M S,	H : ∀ (x : ↥M), is_unit ↑x	⊢ R ≃ₐ[R] S
R : Type u_1,	_inst_1 : comm_ring R,	M : submonoid R,	S : Type u_2,	_inst_2 : comm_ring S,	_inst_3 : algebra R S,	_inst_5 : is_localization M S,	H : ∀ (x : ↥M), is_unit ↑x	⊢ function.injective ⇑(algebra.of_id R S)
R : Type u_1,	_inst_1 : comm_ring R,	M : submonoid R,	S : Type u_2,	_inst_2 : comm_ring S,	_inst_3 : algebra R S,	_inst_5 : is_localization M S,	H : ∀ (x : ↥M), is_unit ↑x,	x y : R,	hxy : ⇑(algebra.of_id R S) x = ⇑(algebra.of_id R S) y	⊢ x = y
R : Type u_1,	_inst_1 : comm_ring R,	M : submonoid R,	S : Type u_2,	_inst_2 : comm_ring S,	_inst_3 : algebra R S,	_inst_5 : is_localization M S,	H : ∀ (x : ↥M), is_unit ↑x,	x y : R,	hxy : ⇑(algebra.of_id R S) x = ⇑(algebra.of_id R S) y,	c : ↥M,	eq : x * ↑c = y * ↑c	⊢ x = y
R : Type u_1,	_inst_1 : comm_ring R,	M : submonoid R,	S : Type u_2,	_inst_2 : comm_ring S,	_inst_3 : algebra R S,	_inst_5 : is_localization M S,	H : ∀ (x : ↥M), is_unit ↑x	⊢ function.injective ⇑(algebra.of_id R S)		R : Type u_1,	_inst_1 : comm_ring R,	M : submonoid R,	S : Type u_2,	_inst_2 : comm_ring S,	_inst_3 : algebra R S,	_inst_5 : is_localization M S,	H : ∀ (x : ↥M), is_unit ↑x	⊢ function.surjective ⇑(algebra.of_id R S)
R : Type u_1,	_inst_1 : comm_ring R,	M : submonoid R,	S : Type u_2,	_inst_2 : comm_ring S,	_inst_3 : algebra R S,	_inst_5 : is_localization M S,	H : ∀ (x : ↥M), is_unit ↑x,	x y : R,	hxy : ⇑(algebra.of_id R S) x = ⇑(algebra.of_id R S) y,	c : ↥M,	eq : x * ↑c = y * ↑c,	u : units R,	hu : ↑u = ↑c	⊢ x = y
R : Type u_1,	_inst_1 : comm_ring R,	M : submonoid R,	S : Type u_2,	_inst_2 : comm_ring S,	_inst_3 : algebra R S,	_inst_5 : is_localization M S,	H : ∀ (x : ↥M), is_unit ↑x	⊢ function.surjective ⇑(algebra.of_id R S)
R : Type u_1,	_inst_1 : comm_ring R,	M : submonoid R,	S : Type u_2,	_inst_2 : comm_ring S,	_inst_3 : algebra R S,	_inst_5 : is_localization M S,	H : ∀ (x : ↥M), is_unit ↑x,	y : S	⊢ ∃ (a : R), ⇑(algebra.of_id R S) a = y
R : Type u_1,	_inst_1 : comm_ring R,	M : submonoid R,	S : Type u_2,	_inst_2 : comm_ring S,	_inst_3 : algebra R S,	_inst_5 : is_localization M S,	H : ∀ (x : ↥M), is_unit ↑x,	y : S,	x : R,	s : ↥M,	eq : y * ⇑(algebra_map R S) ↑((x, s).snd) = ⇑(algebra_map R S) (x, s).fst	⊢ ∃ (a : R), ⇑(algebra.of_id R S) a = y
R : Type u_1,	_inst_1 : comm_ring R,	M : submonoid R,	S : Type u_2,	_inst_2 : comm_ring S,	_inst_3 : algebra R S,	_inst_5 : is_localization M S,	H : ∀ (x : ↥M), is_unit ↑x,	y : S,	x : R,	s : ↥M,	eq : y * ⇑(algebra_map R S) ↑((x, s).snd) = ⇑(algebra_map R S) (x, s).fst,	u : units R,	hu : ↑u = ↑s	⊢ ∃ (a : R), ⇑(algebra.of_id R S) a = y
R : Type u_1,	_inst_1 : comm_ring R,	M : submonoid R,	S : Type u_2,	_inst_2 : comm_ring S,	_inst_3 : algebra R S,	_inst_5 : is_localization M S,	H : ∀ (x : ↥M), is_unit ↑x,	y : S,	x : R,	s : ↥M,	eq : y * ⇑(algebra_map R S) ↑((x, s).snd) = ⇑(algebra_map R S) (x, s).fst,	u : units R,	hu : ↑u = ↑s	⊢ ⇑(algebra.of_id R S) (x * u.inv) = y
R : Type u_1,	_inst_1 : comm_ring R,	M : submonoid R,	S : Type u_2,	_inst_2 : comm_ring S,	_inst_3 : algebra R S,	_inst_5 : is_localization M S,	H : ∀ (x : ↥M), is_unit ↑x,	y : S,	x : R,	s : ↥M,	eq : y * ⇑(algebra_map R S) ↑((x, s).snd) = ⇑(algebra_map R S) (x, s).fst,	u : units R,	hu : ↑u = ↑s	⊢ ⇑(algebra_map R S) (x * u.inv) = y
R : Type u_1,	_inst_1 : comm_ring R,	M : submonoid R,	S : Type u_2,	_inst_2 : comm_ring S,	_inst_3 : algebra R S,	_inst_5 : is_localization M S,	H : ∀ (x : ↥M), is_unit ↑x,	y : S,	x : R,	s : ↥M,	eq : y * ⇑(algebra_map R S) ↑((x, s).snd) = ⇑(algebra_map R S) (x, s).fst,	u : units R,	hu : ↑u = ↑s	⊢ y * ⇑(algebra_map R S) (↑u * u.inv) = y
R : Type u_1,	_inst_1 : comm_ring R,	S : Type u_2,	_inst_2 : comm_ring S,	_inst_3 : algebra R S	⊢ is_localization.coe_submodule S ⊤ = 1
R : Type u_1,	_inst_1 : comm_ring R,	M : submonoid R,	S : Type u_2,	_inst_2 : comm_ring S,	_inst_3 : algebra R S,	_inst_5 : is_localization M S,	x₁ x₂ : R,	y₁ y₂ : ↥M	⊢ (is_localization.mk' S x₁ y₁ + is_localization.mk' S x₂ y₂) * ⇑(algebra_map R S) ↑(y₁ * y₂) = ⇑(algebra_map R S) (x₁ * ↑y₂ + x₂ * ↑y₁)
R : Type u_1,	_inst_1 : comm_ring R,	M : submonoid R,	S : Type u_2,	_inst_2 : comm_ring S,	_inst_3 : algebra R S,	_inst_5 : is_localization M S,	x₁ x₂ : R,	y₁ y₂ : ↥M	⊢ ⇑(algebra_map R S) (↑y₁ * ↑(y₁ * y₂) * x₂) = (⇑(algebra_map R S) ↑y₁ * ⇑(algebra_map R S) (x₁ * ↑y₂ + x₂ * ↑y₁) - ⇑(algebra_map R S) (↑(y₁ * y₂) * x₁)) * ⇑(algebra_map R S) ↑y₂
R : Type u_1,	_inst_1 : comm_ring R,	M : submonoid R,	S : Type u_2,	_inst_2 : comm_ring S,	_inst_3 : algebra R S,	_inst_5 : is_localization M S,	x₁ x₂ : R,	y₁ y₂ : ↥M	⊢ ⇑(algebra_map R S) ↑y₁ * (⇑(algebra_map R S) ↑y₁ * ⇑(algebra_map R S) ↑y₂) * ⇑(algebra_map R S) x₂ = (⇑(algebra_map R S) ↑y₁ * (⇑(algebra_map R S) x₁ * ⇑(algebra_map R S) ↑y₂ + ⇑(algebra_map R S) x₂ * ⇑(algebra_map R S) ↑y₁) - ⇑(algebra_map R S) ↑y₁ * ⇑(algebra_map R S) ↑y₂ * ⇑(algebra_map R S) x₁) * ⇑(algebra_map R S) ↑y₂
R : Type u_1,	_inst_1 : comm_ring R,	M : submonoid R,	S : Type u_2,	_inst_2 : comm_ring S,	_inst_3 : algebra R S,	_inst_5 : is_localization M S,	I : ideal R	⊢ 0 * ⇑(algebra_map R S) ↑((0, 1).snd) = ⇑(algebra_map R S) ↑((0, 1).fst)
R : Type u_1,	_inst_1 : comm_ring R,	M : submonoid R,	S : Type u_2,	_inst_2 : comm_ring S,	_inst_3 : algebra R S,	_inst_5 : is_localization M S,	I : ideal R	⊢ ∀ {a b : S}, a ∈ {z : S | ∃ (x : ↥I × ↥M), z * ⇑(algebra_map R S) ↑(x.snd) = ⇑(algebra_map R S) ↑(x.fst)} → b ∈ {z : S | ∃ (x : ↥I × ↥M), z * ⇑(algebra_map R S) ↑(x.snd) = ⇑(algebra_map R S) ↑(x.fst)} → a + b ∈ {z : S | ∃ (x : ↥I × ↥M), z * ⇑(algebra_map R S) ↑(x.snd) = ⇑(algebra_map R S) ↑(x.fst)}
R : Type u_1,	_inst_1 : comm_ring R,	M : submonoid R,	S : Type u_2,	_inst_2 : comm_ring S,	_inst_3 : algebra R S,	_inst_5 : is_localization M S,	I : ideal R,	a b : S,	a' : ↥I × ↥M,	ha : a * ⇑(algebra_map R S) ↑(a'.snd) = ⇑(algebra_map R S) ↑(a'.fst),	b' : ↥I × ↥M,	hb : b * ⇑(algebra_map R S) ↑(b'.snd) = ⇑(algebra_map R S) ↑(b'.fst)	⊢ a + b ∈ {z : S | ∃ (x : ↥I × ↥M), z * ⇑(algebra_map R S) ↑(x.snd) = ⇑(algebra_map R S) ↑(x.fst)}
R : Type u_1,	_inst_1 : comm_ring R,	M : submonoid R,	S : Type u_2,	_inst_2 : comm_ring S,	_inst_3 : algebra R S,	_inst_5 : is_localization M S,	I : ideal R,	a b : S,	a' : ↥I × ↥M,	ha : a * ⇑(algebra_map R S) ↑(a'.snd) = ⇑(algebra_map R S) ↑(a'.fst),	b' : ↥I × ↥M,	hb : b * ⇑(algebra_map R S) ↑(b'.snd) = ⇑(algebra_map R S) ↑(b'.fst)	⊢ ↥M		R : Type u_1,	_inst_1 : comm_ring R,	M : submonoid R,	S : Type u_2,	_inst_2 : comm_ring S,	_inst_3 : algebra R S,	_inst_5 : is_localization M S,	I : ideal R,	a b : S,	a' : ↥I × ↥M,	ha : a * ⇑(algebra_map R S) ↑(a'.snd) = ⇑(algebra_map R S) ↑(a'.fst),	b' : ↥I × ↥M,	hb : b * ⇑(algebra_map R S) ↑(b'.snd) = ⇑(algebra_map R S) ↑(b'.fst)	⊢ (a + b) * ⇑(algebra_map R S) ↑((⟨↑(a'.snd) * ↑(b'.fst) + ↑(b'.snd) * ↑(a'.fst), _⟩, ?m_1).snd) = ⇑(algebra_map R S) ↑((⟨↑(a'.snd) * ↑(b'.fst) + ↑(b'.snd) * ↑(a'.fst), _⟩, ?m_1).fst)
R : Type u_1,	_inst_1 : comm_ring R,	M : submonoid R,	S : Type u_2,	_inst_2 : comm_ring S,	_inst_3 : algebra R S,	_inst_5 : is_localization M S,	I : ideal R,	a b : S,	a' : ↥I × ↥M,	ha : a * ⇑(algebra_map R S) ↑(a'.snd) = ⇑(algebra_map R S) ↑(a'.fst),	b' : ↥I × ↥M,	hb : b * ⇑(algebra_map R S) ↑(b'.snd) = ⇑(algebra_map R S) ↑(b'.fst)	⊢ (a + b) * ⇑(algebra_map R S) ↑((⟨↑(a'.snd) * ↑(b'.fst) + ↑(b'.snd) * ↑(a'.fst), _⟩, a'.snd * b'.snd).snd) = ⇑(algebra_map R S) ↑((⟨↑(a'.snd) * ↑(b'.fst) + ↑(b'.snd) * ↑(a'.fst), _⟩, a'.snd * b'.snd).fst)
R : Type u_1,	_inst_1 : comm_ring R,	M : submonoid R,	S : Type u_2,	_inst_2 : comm_ring S,	_inst_3 : algebra R S,	_inst_5 : is_localization M S,	I : ideal R,	a b : S,	a' : ↥I × ↥M,	ha : a * ⇑(algebra_map R S) ↑(a'.snd) = ⇑(algebra_map R S) ↑(a'.fst),	b' : ↥I × ↥M,	hb : b * ⇑(algebra_map R S) ↑(b'.snd) = ⇑(algebra_map R S) ↑(b'.fst)	⊢ (a + b) * (⇑(algebra_map R S) ↑(a'.snd) * ⇑(algebra_map R S) ↑(b'.snd)) = ⇑(algebra_map R S) ↑(a'.snd) * ⇑(algebra_map R S) ↑(b'.fst) + ⇑(algebra_map R S) ↑(b'.snd) * ⇑(algebra_map R S) ↑(a'.fst)
R : Type u_1,	_inst_1 : comm_ring R,	M : submonoid R,	S : Type u_2,	_inst_2 : comm_ring S,	_inst_3 : algebra R S,	_inst_5 : is_localization M S,	I : ideal R,	a b : S,	a' : ↥I × ↥M,	ha : a * ⇑(algebra_map R S) ↑(a'.snd) = ⇑(algebra_map R S) ↑(a'.fst),	b' : ↥I × ↥M,	hb : b * ⇑(algebra_map R S) ↑(b'.snd) = ⇑(algebra_map R S) ↑(b'.fst)	⊢ ⇑(algebra_map R S) ↑(a'.fst) * ⇑(algebra_map R S) ↑(b'.snd) + ⇑(algebra_map R S) ↑(b'.fst) * ⇑(algebra_map R S) ↑(a'.snd) = ⇑(algebra_map R S) ↑(a'.snd) * ⇑(algebra_map R S) ↑(b'.fst) + ⇑(algebra_map R S) ↑(b'.snd) * ⇑(algebra_map R S) ↑(a'.fst)
R : Type u_1,	_inst_1 : comm_ring R,	M : submonoid R,	S : Type u_2,	_inst_2 : comm_ring S,	_inst_3 : algebra R S,	_inst_5 : is_localization M S,	I : ideal R	⊢ ∀ (c : S) {x : S}, x ∈ {z : S | ∃ (x : ↥I × ↥M), z * ⇑(algebra_map R S) ↑(x.snd) = ⇑(algebra_map R S) ↑(x.fst)} → c • x ∈ {z : S | ∃ (x : ↥I × ↥M), z * ⇑(algebra_map R S) ↑(x.snd) = ⇑(algebra_map R S) ↑(x.fst)}
R : Type u_1,	_inst_1 : comm_ring R,	M : submonoid R,	S : Type u_2,	_inst_2 : comm_ring S,	_inst_3 : algebra R S,	_inst_5 : is_localization M S,	I : ideal R,	c x : S,	x' : ↥I × ↥M,	hx : x * ⇑(algebra_map R S) ↑(x'.snd) = ⇑(algebra_map R S) ↑(x'.fst)	⊢ c • x ∈ {z : S | ∃ (x : ↥I × ↥M), z * ⇑(algebra_map R S) ↑(x.snd) = ⇑(algebra_map R S) ↑(x.fst)}
R : Type u_1,	_inst_1 : comm_ring R,	M : submonoid R,	S : Type u_2,	_inst_2 : comm_ring S,	_inst_3 : algebra R S,	_inst_5 : is_localization M S,	I : ideal R,	c x : S,	x' : ↥I × ↥M,	hx : x * ⇑(algebra_map R S) ↑(x'.snd) = ⇑(algebra_map R S) ↑(x'.fst),	c' : R × ↥M,	hc : c * ⇑(algebra_map R S) ↑(c'.snd) = ⇑(algebra_map R S) c'.fst	⊢ c • x ∈ {z : S | ∃ (x : ↥I × ↥M), z * ⇑(algebra_map R S) ↑(x.snd) = ⇑(algebra_map R S) ↑(x.fst)}
R : Type u_1,	_inst_1 : comm_ring R,	M : submonoid R,	S : Type u_2,	_inst_2 : comm_ring S,	_inst_3 : algebra R S,	_inst_5 : is_localization M S,	I : ideal R,	c x : S,	x' : ↥I × ↥M,	hx : x * ⇑(algebra_map R S) ↑(x'.snd) = ⇑(algebra_map R S) ↑(x'.fst),	c' : R × ↥M,	hc : c * ⇑(algebra_map R S) ↑(c'.snd) = ⇑(algebra_map R S) c'.fst	⊢ ↥M		R : Type u_1,	_inst_1 : comm_ring R,	M : submonoid R,	S : Type u_2,	_inst_2 : comm_ring S,	_inst_3 : algebra R S,	_inst_5 : is_localization M S,	I : ideal R,	c x : S,	x' : ↥I × ↥M,	hx : x * ⇑(algebra_map R S) ↑(x'.snd) = ⇑(algebra_map R S) ↑(x'.fst),	c' : R × ↥M,	hc : c * ⇑(algebra_map R S) ↑(c'.snd) = ⇑(algebra_map R S) c'.fst	⊢ c • x * ⇑(algebra_map R S) ↑((⟨c'.fst * ↑(x'.fst), _⟩, ?m_1).snd) = ⇑(algebra_map R S) ↑((⟨c'.fst * ↑(x'.fst), _⟩, ?m_1).fst)
R : Type u_1,	_inst_1 : comm_ring R,	M : submonoid R,	S : Type u_2,	_inst_2 : comm_ring S,	_inst_3 : algebra R S,	_inst_5 : is_localization M S,	I : ideal R,	c x : S,	x' : ↥I × ↥M,	hx : x * ⇑(algebra_map R S) ↑(x'.snd) = ⇑(algebra_map R S) ↑(x'.fst),	c' : R × ↥M,	hc : c * ⇑(algebra_map R S) ↑(c'.snd) = ⇑(algebra_map R S) c'.fst	⊢ c • x * ⇑(algebra_map R S) ↑((⟨c'.fst * ↑(x'.fst), _⟩, c'.snd * x'.snd).snd) = ⇑(algebra_map R S) ↑((⟨c'.fst * ↑(x'.fst), _⟩, c'.snd * x'.snd).fst)
R : Type u_1,	_inst_1 : comm_ring R,	M : submonoid R,	S : Type u_2,	_inst_2 : comm_ring S,	_inst_3 : algebra R S,	_inst_5 : is_localization M S,	I : ideal R,	c x : S,	x' : ↥I × ↥M,	hx : x * ⇑(algebra_map R S) ↑(x'.snd) = ⇑(algebra_map R S) ↑(x'.fst),	c' : R × ↥M,	hc : c * ⇑(algebra_map R S) ↑(c'.snd) = ⇑(algebra_map R S) c'.fst	⊢ c * x * (⇑(algebra_map R S) ↑(c'.snd) * ⇑(algebra_map R S) ↑(x'.snd)) = c * ⇑(algebra_map R S) ↑(c'.snd) * (x * ⇑(algebra_map R S) ↑(x'.snd))
R : Type u,	_inst_1 : comm_semiring R,	A : Type v,	_inst_2 : semiring A,	_inst_3 : algebra R A,	n : Type w,	_inst_4 : fintype n,	_inst_5 : decidable_eq n,	a : A,	M : matrix n n R	⊢ ⇑((matrix_equiv_tensor R A n).symm) (a ⊗ₜ[R] M) = λ (i j : n), a * ⇑(algebra_map R A) (M i j)
R : Type u,	_inst_1 : comm_semiring R,	A : Type v,	_inst_2 : semiring A,	_inst_3 : algebra R A,	n : Type w,	_inst_4 : fintype n,	_inst_5 : decidable_eq n,	a : A,	M : matrix n n R	⊢ ⇑(⇑(matrix_equiv_tensor.to_fun_bilinear R A n) a) M = λ (i j : n), a * ⇑(algebra_map R A) (M i j)
α : Type u_1,	_inst_1 : comm_monoid α,	a b c : α,	_x : multiplicity.finite a (b * c),	_fun_match : multiplicity.finite a (b * c) → multiplicity.finite a c,	n : ℕ,	hn : ¬a ^ (n + 1) ∣ b * c,	h : a ^ (n + 1) ∣ c	⊢ c ∣ b * c
α : Type u_1,	_inst_1 : comm_monoid α,	_inst_2 : decidable_rel has_dvd.dvd,	a b : α,	k : ℕ,	hk : a ^ k ∣ b,	hsucc : ¬a ^ (k + 1) ∣ b,	this : multiplicity.finite a b	⊢ ∃ (h : (multiplicity a b).dom), (multiplicity a b).get h ≤ k
α : Type u_1,	_inst_1 : comm_monoid α,	_inst_2 : decidable_rel has_dvd.dvd,	a b : α,	k : ℕ,	hk : a ^ k ∣ b,	hsucc : ¬a ^ (k + 1) ∣ b,	this : multiplicity.finite a b	⊢ multiplicity a b ≤ ↑k
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	hs1 : (submodule.map f s).fg,	hs2 : (s ⊓ f.ker).fg,	_inst : decidable_eq R	⊢ s.fg
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	hs1 : (submodule.map f s).fg,	hs2 : (s ⊓ f.ker).fg	⊢ s.fg
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	hs1 : (submodule.map f s).fg,	hs2 : (s ⊓ f.ker).fg,	_inst : decidable_eq R,	_inst_1 : decidable_eq M	⊢ s.fg
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	hs2 : (s ⊓ f.ker).fg,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s	⊢ s.fg
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	hs1 : (submodule.map f s).fg,	hs2 : (s ⊓ f.ker).fg,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P	⊢ s.fg
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker	⊢ s.fg
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker	⊢ ∀ (y : P), y ∈ t1 → (∃ (x : M) (H : x ∈ s), ⇑f x = y)
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	y : P,	hy : y ∈ t1	⊢ y ∈ submodule.map f s
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	y : P,	hy : y ∈ t1	⊢ y ∈ submodule.span R ↑t1
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	y : P,	hy : y ∈ t1	⊢ y ∈ submodule.map f s		R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	y : P,	hy : y ∈ t1,	this : y ∈ submodule.map f s	⊢ ∃ (x : M) (H : x ∈ s), ⇑f x = y
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	y : P,	hy : y ∈ t1	⊢ ∃ (x : M) (H : x ∈ s), ⇑f x = y
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	y : P,	hy : y ∈ t1,	this : y ∈ submodule.map f s	⊢ ∃ (x : M) (H : x ∈ s), ⇑f x = y
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker	⊢ ∀ (y : P), y ∈ t1 → (∃ (x : M) (H : x ∈ s), ⇑f x = y)		R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	this : ∀ (y : P), y ∈ t1 → (∃ (x : M) (H : x ∈ s), ⇑f x = y)	⊢ s.fg
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	y : P,	hy : y ∈ t1,	this : y ∈ submodule.map f s,	x : M,	hx1 : x ∈ s,	hx2 : ⇑f x = y	⊢ ∃ (x : M) (H : x ∈ s), ⇑f x = y
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	this : ∀ (y : P), y ∈ t1 → (∃ (x : M) (H : x ∈ s), ⇑f x = y)	⊢ s.fg
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	this : ∀ (y : P), y ∈ t1 → (∃ (x : M) (H : x ∈ s), ⇑f x = y)	⊢ ∃ (g : P → M), ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : Π (y : P), y ∈ t1 → M,	hg1 : ∀ (y : P) (H : y ∈ t1), g y H ∈ s,	hg2 : ∀ (y : P) (H : y ∈ t1), ⇑f (g y H) = y	⊢ ∃ (g : P → M), ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : Π (y : P), y ∈ t1 → M,	hg1 : ∀ (y : P) (H : y ∈ t1), g y H ∈ s,	hg2 : ∀ (y : P) (H : y ∈ t1), ⇑f (g y H) = y,	y : P,	H : y ∈ t1	⊢ (λ (y : P), dite (y ∈ t1) (λ (H : y ∈ t1), g y H) (λ (H : y ∉ t1), 0)) y ∈ s ∧ ⇑f ((λ (y : P), dite (y ∈ t1) (λ (H : y ∈ t1), g y H) (λ (H : y ∉ t1), 0)) y) = y
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : Π (y : P), y ∈ t1 → M,	hg1 : ∀ (y : P) (H : y ∈ t1), g y H ∈ s,	hg2 : ∀ (y : P) (H : y ∈ t1), ⇑f (g y H) = y	⊢ ∀ (y : P), y ∈ t1 → (λ (y : P), dite (y ∈ t1) (λ (H : y ∈ t1), g y H) (λ (H : y ∉ t1), 0)) y ∈ s ∧ ⇑f ((λ (y : P), dite (y ∈ t1) (λ (H : y ∈ t1), g y H) (λ (H : y ∉ t1), 0)) y) = y
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : Π (y : P), y ∈ t1 → M,	hg1 : ∀ (y : P) (H : y ∈ t1), g y H ∈ s,	hg2 : ∀ (y : P) (H : y ∈ t1), ⇑f (g y H) = y,	y : P,	H : y ∈ t1	⊢ g y H ∈ s
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : Π (y : P), y ∈ t1 → M,	hg1 : ∀ (y : P) (H : y ∈ t1), g y H ∈ s,	hg2 : ∀ (y : P) (H : y ∈ t1), ⇑f (g y H) = y,	y : P,	H : y ∈ t1	⊢ (λ (y : P), dite (y ∈ t1) (λ (H : y ∈ t1), g y H) (λ (H : y ∉ t1), 0)) y ∈ s		R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : Π (y : P), y ∈ t1 → M,	hg1 : ∀ (y : P) (H : y ∈ t1), g y H ∈ s,	hg2 : ∀ (y : P) (H : y ∈ t1), ⇑f (g y H) = y,	y : P,	H : y ∈ t1	⊢ ⇑f ((λ (y : P), dite (y ∈ t1) (λ (H : y ∈ t1), g y H) (λ (H : y ∉ t1), 0)) y) = y
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : Π (y : P), y ∈ t1 → M,	hg1 : ∀ (y : P) (H : y ∈ t1), g y H ∈ s,	hg2 : ∀ (y : P) (H : y ∈ t1), ⇑f (g y H) = y,	y : P,	H : y ∈ t1	⊢ (λ (y : P), dite (y ∈ t1) (λ (H : y ∈ t1), g y H) (λ (H : y ∉ t1), 0)) y ∈ s
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : Π (y : P), y ∈ t1 → M,	hg1 : ∀ (y : P) (H : y ∈ t1), g y H ∈ s,	hg2 : ∀ (y : P) (H : y ∈ t1), ⇑f (g y H) = y,	y : P,	H : y ∈ t1	⊢ ⇑f (g y H) = y
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	this : ∀ (y : P), y ∈ t1 → (∃ (x : M) (H : x ∈ s), ⇑f x = y)	⊢ ∃ (g : P → M), ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y		R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	this : ∀ (y : P), y ∈ t1 → (∃ (x : M) (H : x ∈ s), ⇑f x = y),	this : ∃ (g : P → M), ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y	⊢ s.fg
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : Π (y : P), y ∈ t1 → M,	hg1 : ∀ (y : P) (H : y ∈ t1), g y H ∈ s,	hg2 : ∀ (y : P) (H : y ∈ t1), ⇑f (g y H) = y,	y : P,	H : y ∈ t1	⊢ ⇑f ((λ (y : P), dite (y ∈ t1) (λ (H : y ∈ t1), g y H) (λ (H : y ∉ t1), 0)) y) = y
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	this : ∀ (y : P), y ∈ t1 → (∃ (x : M) (H : x ∈ s), ⇑f x = y),	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y	⊢ s.fg
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	this : ∀ (y : P), y ∈ t1 → (∃ (x : M) (H : x ∈ s), ⇑f x = y),	this : ∃ (g : P → M), ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y	⊢ s.fg
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y	⊢ s.fg
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y	⊢ submodule.span R ↑(finset.image g t1 ∪ t2) = s
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y	⊢ submodule.span R (g '' ↑t1) ⊔ submodule.span R ↑t2 = s
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y	⊢ submodule.span R (g '' ↑t1) ⊔ submodule.span R ↑t2 ≤ s
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	y : P,	hy : y ∈ ↑t1	⊢ y ∈ g ⁻¹' ↑s
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y	⊢ ↑t1 ⊆ g ⁻¹' ↑s		R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y	⊢ ↑t2 ⊆ ↑s
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y	⊢ ↑t1 ⊆ g ⁻¹' ↑s
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ ↑t2	⊢ x ∈ ↑s
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y	⊢ ↑t2 ⊆ ↑s
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ ↑t2,	this : x ∈ ↑(submodule.span ?m_1 ↑t2)	⊢ x ∈ ↑s		R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ ↑t2	⊢ Type ?		R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ ↑t2	⊢ semiring ?m_1		R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ ↑t2	⊢ module ?m_1 M
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y	⊢ submodule.span R (g '' ↑t1) ⊔ submodule.span R ↑t2 ≤ s		R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y	⊢ s ≤ submodule.span R (g '' ↑t1) ⊔ submodule.span R ↑t2
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ ↑t2,	this : x ∈ ↑(s ⊓ f.ker)	⊢ x ∈ ↑s
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y	⊢ s ≤ submodule.span R (g '' ↑t1) ⊔ submodule.span R ↑t2
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s	⊢ ⇑f x ∈ submodule.map f s
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s	⊢ ∃ (y : M), y ∈ s ∧ ⇑f y = ⇑f x
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s	⊢ x ∈ submodule.span R (g '' ↑t1) ⊔ submodule.span R ↑t2
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s	⊢ ⇑f x ∈ submodule.map f s		R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s,	this : ⇑f x ∈ submodule.map f s	⊢ x ∈ submodule.span R (g '' ↑t1) ⊔ submodule.span R ↑t2
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s,	this : ⇑f x ∈ submodule.map f s	⊢ x ∈ submodule.span R (g '' ↑t1) ⊔ submodule.span R ↑t2
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s,	this : ∃ (l : P →₀ R) (H : l ∈ finsupp.supported R R ↑t1), ⇑(finsupp.total P P R id) l = ⇑f x	⊢ x ∈ submodule.span R (g '' ↑t1) ⊔ submodule.span R ↑t2
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s,	l : P →₀ R,	hl1 : l ∈ finsupp.supported R R ↑t1,	hl2 : ⇑(finsupp.total P P R id) l = ⇑f x	⊢ x ∈ submodule.span R (g '' ↑t1) ⊔ submodule.span R ↑t2
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s,	l : P →₀ R,	hl1 : l ∈ finsupp.supported R R ↑t1,	hl2 : ⇑(finsupp.total P P R id) l = ⇑f x	⊢ (finsupp.total M M R id).to_fun (⇑(finsupp.lmap_domain R R g) l) ∈ submodule.span R (g '' ↑t1)
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s,	l : P →₀ R,	hl1 : l ∈ finsupp.supported R R ↑t1,	hl2 : ⇑(finsupp.total P P R id) l = ⇑f x	⊢ ∃ (l_1 : M →₀ R) (H : l_1 ∈ finsupp.supported R R (g '' ↑t1)), ⇑(finsupp.total M M R id) l_1 = (finsupp.total M M R id).to_fun (⇑(finsupp.lmap_domain R R g) l)
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s,	l : P →₀ R,	hl1 : l ∈ finsupp.supported R R ↑t1,	hl2 : ⇑(finsupp.total P P R id) l = ⇑f x	⊢ ⇑(finsupp.lmap_domain R R g) l ∈ finsupp.supported R R (g '' ↑t1)
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s,	l : P →₀ R,	hl1 : l ∈ finsupp.supported R R ↑t1,	hl2 : ⇑(finsupp.total P P R id) l = ⇑f x,	_inst_3 : inhabited P	⊢ ⇑(finsupp.lmap_domain R R g) l ∈ finsupp.supported R R (g '' ↑t1)
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s,	l : P →₀ R,	hl1 : l ∈ finsupp.supported R R ↑t1,	hl2 : ⇑(finsupp.total P P R id) l = ⇑f x,	_inst_3 : inhabited P	⊢ ∃ (y : P →₀ R), y ∈ finsupp.supported R R ↑t1 ∧ ⇑(finsupp.lmap_domain R R g) y = ⇑(finsupp.lmap_domain R R g) l
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s,	l : P →₀ R,	hl1 : l ∈ finsupp.supported R R ↑t1,	hl2 : ⇑(finsupp.total P P R id) l = ⇑f x	⊢ (finsupp.total M M R id).to_fun (⇑(finsupp.lmap_domain R R g) l) ∈ submodule.span R (g '' ↑t1)		R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s,	l : P →₀ R,	hl1 : l ∈ finsupp.supported R R ↑t1,	hl2 : ⇑(finsupp.total P P R id) l = ⇑f x	⊢ x - ⇑(finsupp.total M M R id) (⇑(finsupp.lmap_domain R R g) l) ∈ submodule.span R ↑t2
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s,	l : P →₀ R,	hl1 : l ∈ finsupp.supported R R ↑t1,	hl2 : ⇑(finsupp.total P P R id) l = ⇑f x,	_inst_3 : inhabited P	⊢ ⇑(finsupp.lmap_domain R R g) l = ⇑(finsupp.lmap_domain R R g) l
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s,	l : P →₀ R,	hl1 : l ∈ finsupp.supported R R ↑t1,	hl2 : ⇑(finsupp.total P P R id) l = ⇑f x	⊢ x - ⇑(finsupp.total M M R id) (⇑(finsupp.lmap_domain R R g) l) ∈ s ∧ x - ⇑(finsupp.total M M R id) (⇑(finsupp.lmap_domain R R g) l) ∈ f.ker
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s,	l : P →₀ R,	hl1 : l ∈ finsupp.supported R R ↑t1,	hl2 : ⇑(finsupp.total P P R id) l = ⇑f x	⊢ x - ⇑(finsupp.total M M R id) (⇑(finsupp.lmap_domain R R g) l) ∈ submodule.span R ↑t2
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s,	l : P →₀ R,	hl1 : l ∈ finsupp.supported R R ↑t1,	hl2 : ⇑(finsupp.total P P R id) l = ⇑f x	⊢ x - ⇑(finsupp.total M M R id) (⇑(finsupp.lmap_domain R R g) l) ∈ s
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s,	l : P →₀ R,	hl1 : l ∈ finsupp.supported R R ↑t1,	hl2 : ⇑(finsupp.total P P R id) l = ⇑f x	⊢ ⇑(finsupp.total M M R id) (⇑(finsupp.lmap_domain R R g) l) ∈ s
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s,	l : P →₀ R,	hl1 : l ∈ finsupp.supported R R ↑t1,	hl2 : ⇑(finsupp.total P P R id) l = ⇑f x	⊢ l.sum (λ (a : P) (m : R), m • id (g a)) ∈ s		R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s,	l : P →₀ R,	hl1 : l ∈ finsupp.supported R R ↑t1,	hl2 : ⇑(finsupp.total P P R id) l = ⇑f x	⊢ ∀ (b : M), 0 • id b = 0		R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s,	l : P →₀ R,	hl1 : l ∈ finsupp.supported R R ↑t1,	hl2 : ⇑(finsupp.total P P R id) l = ⇑f x	⊢ ∀ (b : M) (m₁ m₂ : R), (m₁ + m₂) • id b = m₁ • id b + m₂ • id b
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s,	l : P →₀ R,	hl1 : l ∈ finsupp.supported R R ↑t1,	hl2 : ⇑(finsupp.total P P R id) l = ⇑f x,	y : P,	hy : y ∈ l.support	⊢ (λ (a : P) (m : R), m • id (g a)) y (⇑l y) ∈ s
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s,	l : P →₀ R,	hl1 : l ∈ finsupp.supported R R ↑t1,	hl2 : ⇑(finsupp.total P P R id) l = ⇑f x	⊢ ∀ (c : P), c ∈ l.support → (λ (a : P) (m : R), m • id (g a)) c (⇑l c) ∈ s		R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s,	l : P →₀ R,	hl1 : l ∈ finsupp.supported R R ↑t1,	hl2 : ⇑(finsupp.total P P R id) l = ⇑f x	⊢ ∀ (b : M), 0 • id b = 0		R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s,	l : P →₀ R,	hl1 : l ∈ finsupp.supported R R ↑t1,	hl2 : ⇑(finsupp.total P P R id) l = ⇑f x	⊢ ∀ (b : M) (m₁ m₂ : R), (m₁ + m₂) • id b = m₁ • id b + m₂ • id b
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s,	l : P →₀ R,	hl1 : l ∈ finsupp.supported R R ↑t1,	hl2 : ⇑(finsupp.total P P R id) l = ⇑f x	⊢ ∀ (c : P), c ∈ l.support → (λ (a : P) (m : R), m • id (g a)) c (⇑l c) ∈ s
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s,	l : P →₀ R,	hl1 : l ∈ finsupp.supported R R ↑t1,	hl2 : ⇑(finsupp.total P P R id) l = ⇑f x	⊢ ∀ (b : M), 0 • id b = 0		R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s,	l : P →₀ R,	hl1 : l ∈ finsupp.supported R R ↑t1,	hl2 : ⇑(finsupp.total P P R id) l = ⇑f x	⊢ ∀ (b : M) (m₁ m₂ : R), (m₁ + m₂) • id b = m₁ • id b + m₂ • id b
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s,	l : P →₀ R,	hl1 : l ∈ finsupp.supported R R ↑t1,	hl2 : ⇑(finsupp.total P P R id) l = ⇑f x	⊢ ∀ (b : M) (m₁ m₂ : R), (m₁ + m₂) • id b = m₁ • id b + m₂ • id b
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s,	l : P →₀ R,	hl1 : l ∈ finsupp.supported R R ↑t1,	hl2 : ⇑(finsupp.total P P R id) l = ⇑f x	⊢ x - ⇑(finsupp.total M M R id) (⇑(finsupp.lmap_domain R R g) l) ∈ s		R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s,	l : P →₀ R,	hl1 : l ∈ finsupp.supported R R ↑t1,	hl2 : ⇑(finsupp.total P P R id) l = ⇑f x	⊢ x - ⇑(finsupp.total M M R id) (⇑(finsupp.lmap_domain R R g) l) ∈ f.ker
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s,	l : P →₀ R,	hl1 : l ∈ finsupp.supported R R ↑t1,	hl2 : ⇑(finsupp.total P P R id) l = ⇑f x	⊢ ∀ (b : M), 0 • id b = 0
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s,	l : P →₀ R,	hl1 : l ∈ finsupp.supported R R ↑t1,	hl2 : ⇑(finsupp.total P P R id) l = ⇑f x	⊢ x - ⇑(finsupp.total M M R id) (⇑(finsupp.lmap_domain R R g) l) ∈ f.ker
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s,	l : P →₀ R,	hl1 : l ∈ finsupp.supported R R ↑t1,	hl2 : ⇑(finsupp.total P P R id) l = ⇑f x	⊢ ⇑(finsupp.total P P R id) l - ⇑f (⇑(finsupp.total M M R id) (⇑(finsupp.lmap_domain R R g) l)) = 0
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s,	l : P →₀ R,	hl1 : l ∈ finsupp.supported R R ↑t1,	hl2 : ⇑(finsupp.total P P R id) l = ⇑f x	⊢ l.sum (λ (i : P) (a : R), a • id i) - ⇑f ((finsupp.map_domain g l).sum (λ (i : M) (a : R), a • id i)) = 0
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s,	l : P →₀ R,	hl1 : l ∈ finsupp.supported R R ↑t1,	hl2 : ⇑(finsupp.total P P R id) l = ⇑f x	⊢ ∑ (a : P) in l.support, ⇑l a • id a - ∑ (i : P) in l.support, ⇑f (⇑l i • id (g i)) = 0		R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s,	l : P →₀ R,	hl1 : l ∈ finsupp.supported R R ↑t1,	hl2 : ⇑(finsupp.total P P R id) l = ⇑f x	⊢ ∀ (b : M), 0 • id b = 0		R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s,	l : P →₀ R,	hl1 : l ∈ finsupp.supported R R ↑t1,	hl2 : ⇑(finsupp.total P P R id) l = ⇑f x	⊢ ∀ (b : M) (m₁ m₂ : R), (m₁ + m₂) • id b = m₁ • id b + m₂ • id b
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s,	l : P →₀ R,	hl1 : l ∈ finsupp.supported R R ↑t1,	hl2 : ⇑(finsupp.total P P R id) l = ⇑f x	⊢ ∑ (a : P) in l.support, ⇑l a • id a = ∑ (i : P) in l.support, ⇑f (⇑l i • id (g i))		R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s,	l : P →₀ R,	hl1 : l ∈ finsupp.supported R R ↑t1,	hl2 : ⇑(finsupp.total P P R id) l = ⇑f x	⊢ ∀ (b : M), 0 • id b = 0		R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s,	l : P →₀ R,	hl1 : l ∈ finsupp.supported R R ↑t1,	hl2 : ⇑(finsupp.total P P R id) l = ⇑f x	⊢ ∀ (b : M) (m₁ m₂ : R), (m₁ + m₂) • id b = m₁ • id b + m₂ • id b
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s,	l : P →₀ R,	hl1 : l ∈ finsupp.supported R R ↑t1,	hl2 : ⇑(finsupp.total P P R id) l = ⇑f x,	y : P,	hy : y ∈ l.support	⊢ ⇑l y • id y = ⇑f (⇑l y • id (g y))		R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s,	l : P →₀ R,	hl1 : l ∈ finsupp.supported R R ↑t1,	hl2 : ⇑(finsupp.total P P R id) l = ⇑f x	⊢ ∀ (b : M), 0 • id b = 0		R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s,	l : P →₀ R,	hl1 : l ∈ finsupp.supported R R ↑t1,	hl2 : ⇑(finsupp.total P P R id) l = ⇑f x	⊢ ∀ (b : M) (m₁ m₂ : R), (m₁ + m₂) • id b = m₁ • id b + m₂ • id b
R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s,	l : P →₀ R,	hl1 : l ∈ finsupp.supported R R ↑t1,	hl2 : ⇑(finsupp.total P P R id) l = ⇑f x,	y : P,	hy : y ∈ l.support	⊢ ⇑l y • y = ⇑f (⇑l y • g y)		R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s,	l : P →₀ R,	hl1 : l ∈ finsupp.supported R R ↑t1,	hl2 : ⇑(finsupp.total P P R id) l = ⇑f x	⊢ ∀ (b : M), 0 • id b = 0		R : Type u_1,	M : Type u_2,	P : Type u_3,	_inst_6 : ring R,	_inst_7 : add_comm_group M,	_inst_8 : module R M,	_inst_9 : add_comm_group P,	_inst_10 : module R P,	f : M →ₗ[R] P,	s : submodule R M,	_inst : decidable_eq R,	_inst_1 : decidable_eq M,	_inst_2 : decidable_eq P,	t1 : finset P,	ht1 : submodule.span R ↑t1 = submodule.map f s,	t2 : finset M,	ht2 : submodule.span R ↑t2 = s ⊓ f.ker,	g : P → M,	hg : ∀ (y : P), y ∈ t1 → g y ∈ s ∧ ⇑f (g y) = y,	x : M,	hx : x ∈ s,	l : P →₀ R,	hl1 : l ∈ finsupp.supported R R ↑t1,	hl2 : ⇑(finsupp.total P P R id) l = ⇑f x	⊢ ∀ (b : M) (m₁ m₂ : R), (m₁ + m₂) • id b = m₁ • id b + m₂ • id b
R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe	⊢ s.finite
R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite	⊢ ℕ ↪ ↥s		R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s	⊢ gt ↪r gt
R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite	⊢ gt ↪r gt
R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s	⊢ gt ↪r gt
R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s,	n : ℕ,	x : M,	y : ℕ,	hy₁ : y ∈ {m : ℕ | m ≤ n},	hy₂ : (coe ∘ ⇑f) y = x	⊢ x ∈ s
R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s,	n y : ℕ,	hy₁ : y ∈ {m : ℕ | m ≤ n}	⊢ (coe ∘ ⇑f) y ∈ s
R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s	⊢ ∀ (n : ℕ), coe ∘ ⇑f '' {m : ℕ | m ≤ n} ⊆ s		R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s,	this : ∀ (n : ℕ), coe ∘ ⇑f '' {m : ℕ | m ≤ n} ⊆ s	⊢ gt ↪r gt
R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s	⊢ ∀ (n : ℕ), coe ∘ ⇑f '' {m : ℕ | m ≤ n} ⊆ s
R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s,	this : ∀ (n : ℕ), coe ∘ ⇑f '' {m : ℕ | m ≤ n} ⊆ s	⊢ gt ↪r gt
R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s,	this : ∀ (n : ℕ), coe ∘ ⇑f '' {m : ℕ | m ≤ n} ⊆ s	⊢ ∀ (a b : ℕ), a ≤ b ↔ submodule.span R (coe ∘ ⇑f '' {m : ℕ | m ≤ a}) ≤ submodule.span R (coe ∘ ⇑f '' {m : ℕ | m ≤ b})
R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s,	this : ∀ (n : ℕ), coe ∘ ⇑f '' {m : ℕ | m ≤ n} ⊆ s,	a b : ℕ	⊢ a ≤ b ↔ submodule.span R (coe ∘ ⇑f '' {m : ℕ | m ≤ a}) ≤ submodule.span R (coe ∘ ⇑f '' {m : ℕ | m ≤ b})
R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s,	this : ∀ (n : ℕ), coe ∘ ⇑f '' {m : ℕ | m ≤ n} ⊆ s,	a b : ℕ	⊢ a ≤ b ↔ ∀ (x : ℕ), x ∈ {m : ℕ | m ≤ a} → x ∈ {m : ℕ | m ≤ b}
R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s,	this : ∀ (n : ℕ), coe ∘ ⇑f '' {m : ℕ | m ≤ n} ⊆ s	⊢ ∀ (a b : ℕ), a ≤ b ↔ submodule.span R (coe ∘ ⇑f '' {m : ℕ | m ≤ a}) ≤ submodule.span R (coe ∘ ⇑f '' {m : ℕ | m ≤ b})		R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s,	this : ∀ (n : ℕ), coe ∘ ⇑f '' {m : ℕ | m ≤ n} ⊆ s,	this : ∀ (a b : ℕ), a ≤ b ↔ submodule.span R (coe ∘ ⇑f '' {m : ℕ | m ≤ a}) ≤ submodule.span R (coe ∘ ⇑f '' {m : ℕ | m ≤ b})	⊢ gt ↪r gt		R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s,	this : ∀ (n : ℕ), coe ∘ ⇑f '' {m : ℕ | m ≤ n} ⊆ s,	a b : ℕ	⊢ Type ?		R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s,	this : ∀ (n : ℕ), coe ∘ ⇑f '' {m : ℕ | m ≤ n} ⊆ s,	a b : ℕ	⊢ add_comm_monoid ?m_1		R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s,	this : ∀ (n : ℕ), coe ∘ ⇑f '' {m : ℕ | m ≤ n} ⊆ s,	a b : ℕ	⊢ module R ?m_1		R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s,	this : ∀ (n : ℕ), coe ∘ ⇑f '' {m : ℕ | m ≤ n} ⊆ s,	a b : ℕ	⊢ has_le (submodule R ?m_1)		R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s,	this : ∀ (n : ℕ), coe ∘ ⇑f '' {m : ℕ | m ≤ n} ⊆ s,	a b : ℕ	⊢ has_lift_t ↥s ?m_1		R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s,	this : ∀ (n : ℕ), coe ∘ ⇑f '' {m : ℕ | m ≤ n} ⊆ s,	a b : ℕ	⊢ has_lift_t ↥s ?m_1
R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s,	this : ∀ (n : ℕ), coe ∘ ⇑f '' {m : ℕ | m ≤ n} ⊆ s,	this : ∀ (a b : ℕ), a ≤ b ↔ submodule.span R (coe ∘ ⇑f '' {m : ℕ | m ≤ a}) ≤ submodule.span R (coe ∘ ⇑f '' {m : ℕ | m ≤ b})	⊢ gt ↪r gt
R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s,	this : ∀ (n : ℕ), coe ∘ ⇑f '' {m : ℕ | m ≤ n} ⊆ s,	this : ∀ (a b : ℕ), a ≤ b ↔ submodule.span R (coe ∘ ⇑f '' {m : ℕ | m ≤ a}) ≤ submodule.span R (coe ∘ ⇑f '' {m : ℕ | m ≤ b}),	x y : ℕ	⊢ (λ (n : ℕ), submodule.span R (coe ∘ ⇑f '' {m : ℕ | m ≤ n})) x = (λ (n : ℕ), submodule.span R (coe ∘ ⇑f '' {m : ℕ | m ≤ n})) y → x = y
R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s,	this : ∀ (n : ℕ), coe ∘ ⇑f '' {m : ℕ | m ≤ n} ⊆ s,	this : ∀ (a b : ℕ), a ≤ b ↔ submodule.span R (coe ∘ ⇑f '' {m : ℕ | m ≤ a}) ≤ submodule.span R (coe ∘ ⇑f '' {m : ℕ | m ≤ b})	⊢ ∀ {a b : ℕ}, ⇑{to_fun := λ (n : ℕ), submodule.span R (coe ∘ ⇑f '' {m : ℕ | m ≤ n}), inj' := _} a > ⇑{to_fun := λ (n : ℕ), submodule.span R (coe ∘ ⇑f '' {m : ℕ | m ≤ n}), inj' := _} b ↔ a > b
R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s,	this : ∀ (n : ℕ), coe ∘ ⇑f '' {m : ℕ | m ≤ n} ⊆ s,	this : ∀ (a b : ℕ), a ≤ b ↔ submodule.span R (coe ∘ ⇑f '' {m : ℕ | m ≤ a}) ≤ submodule.span R (coe ∘ ⇑f '' {m : ℕ | m ≤ b})	⊢ ∀ {a b : ℕ}, ⇑{to_fun := λ (n : ℕ), submodule.span R (coe ∘ ⇑f '' {m : ℕ | m ≤ n}), inj' := _} a > ⇑{to_fun := λ (n : ℕ), submodule.span R (coe ∘ ⇑f '' {m : ℕ | m ≤ n}), inj' := _} b ↔ a > b
R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s,	this : ∀ (n : ℕ), coe ∘ ⇑f '' {m : ℕ | m ≤ n} ⊆ s,	this : ∀ (a b : ℕ), a ≤ b ↔ submodule.span R (coe ∘ ⇑f '' {m : ℕ | m ≤ a}) ≤ submodule.span R (coe ∘ ⇑f '' {m : ℕ | m ≤ b})	⊢ ∀ {a b : ℕ}, submodule.span R (coe ∘ ⇑f '' {m : ℕ | m ≤ b}) < submodule.span R (coe ∘ ⇑f '' {m : ℕ | m ≤ a}) ↔ b < a
R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s,	this : ∀ (n : ℕ), coe ∘ ⇑f '' {m : ℕ | m ≤ n} ⊆ s,	this : ∀ (a b : ℕ), a ≤ b ↔ submodule.span R (coe ∘ ⇑f '' {m : ℕ | m ≤ a}) ≤ submodule.span R (coe ∘ ⇑f '' {m : ℕ | m ≤ b})	⊢ ∀ {a b : ℕ}, b ≤ a ∧ ¬a ≤ b ↔ b ≤ a ∧ ¬a ≤ b
R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s,	this : ∀ (n : ℕ), coe ∘ ⇑f '' {m : ℕ | m ≤ n} ⊆ s,	this : ∀ (a b : ℕ), a ≤ b ↔ submodule.span R (coe ∘ ⇑f '' {m : ℕ | m ≤ a}) ≤ submodule.span R (coe ∘ ⇑f '' {m : ℕ | m ≤ b})	⊢ ∀ {a b : ℕ}, ⇑{to_fun := λ (n : ℕ), submodule.span R (coe ∘ ⇑f '' {m : ℕ | m ≤ n}), inj' := _} a > ⇑{to_fun := λ (n : ℕ), submodule.span R (coe ∘ ⇑f '' {m : ℕ | m ≤ n}), inj' := _} b ↔ a > b
k : Type u_1,	_inst_1 : field k,	σ : Type u_2,	I : ideal (mv_polynomial σ k)	⊢ I.radical ≤ mv_polynomial.vanishing_ideal (mv_polynomial.zero_locus I)
k : Type u_1,	_inst_1 : field k,	σ : Type u_2,	I : ideal (mv_polynomial σ k),	p : mv_polynomial σ k,	hp : p ∈ I.radical,	x : σ → k,	hx : x ∈ mv_polynomial.zero_locus I	⊢ ⇑(mv_polynomial.eval x) p = 0
k : Type u_1,	_inst_1 : field k,	σ : Type u_2,	I : ideal (mv_polynomial σ k),	p : mv_polynomial σ k,	hp : p ∈ I.radical,	x : σ → k,	hx : x ∈ mv_polynomial.zero_locus I	⊢ p ∈ mv_polynomial.vanishing_ideal {x}
k : Type u_1,	_inst_1 : field k,	σ : Type u_2,	I : ideal (mv_polynomial σ k),	p : mv_polynomial σ k,	x : σ → k,	hx : x ∈ mv_polynomial.zero_locus I,	hp : p ∈ has_Inf.Inf {J : ideal (mv_polynomial σ k) | I ≤ J ∧ J.is_prime}	⊢ p ∈ mv_polynomial.vanishing_ideal {x}
p : ℕ,	_inst_1 : fact (nat.prime p),	R : Type u₁,	_inst_2 : comm_semiring R,	_inst_3 : char_p R p,	S : Type u₂,	_inst_7 : comm_semiring S,	_inst_8 : char_p S p,	φ : R →+* S,	f : ring.perfection R p	⊢ ⇑(perfection.coeff S p 0) (⇑(perfection_map.map p _ _ φ) f) = ⇑(perfection.coeff S p 0) (⇑(perfection.map p φ) f)
R : Type u,	_inst_1 : comm_ring R,	p : polynomial R	⊢ p.restriction.support = p.support
R : Type u,	_inst_1 : comm_ring R,	p : polynomial R,	i : ℕ	⊢ i ∈ p.restriction.support ↔ i ∈ p.support
R : Type u,	_inst_1 : comm_ring R,	p : polynomial R,	i : ℕ	⊢ p.coeff i = 0 = ?m_1
R : Type u,	_inst_1 : comm_ring R,	p : polynomial R,	i : ℕ	⊢ p.restriction.coeff i = 0 ↔ p.coeff i = 0
R : Type u,	_inst_1 : comm_ring R,	p : polynomial R,	i : ℕ,	H : p.restriction.coeff i = 0	⊢ ↑(p.restriction.coeff i) = 0
R : Type u,	_inst_1 : comm_ring R,	p : polynomial R,	i : ℕ,	H : p.restriction.coeff i = 0	⊢ ↑0 = 0
R : Type u,	_inst_1 : comm_ring R,	p : polynomial R,	i : ℕ	⊢ p.restriction.coeff i = 0 ↔ ↑(p.restriction.coeff i) = 0
R : Type u,	_inst_1 : comm_ring R	⊢ 0.restriction = 0
R : Type u,	_inst_1 : comm_ring R,	I : ideal R,	f g : polynomial I.quotient	⊢ ⇑(polynomial.eval₂_ring_hom (ideal.quotient.lift I ((ideal.quotient.mk (ideal.map polynomial.C I)).comp polynomial.C) ideal.quotient_map_C_eq_zero) (⇑(ideal.quotient.mk (ideal.map polynomial.C I)) polynomial.X)) (f * g) = ⇑(polynomial.eval₂_ring_hom (ideal.quotient.lift I ((ideal.quotient.mk (ideal.map polynomial.C I)).comp polynomial.C) ideal.quotient_map_C_eq_zero) (⇑(ideal.quotient.mk (ideal.map polynomial.C I)) polynomial.X)) f * ⇑(polynomial.eval₂_ring_hom (ideal.quotient.lift I ((ideal.quotient.mk (ideal.map polynomial.C I)).comp polynomial.C) ideal.quotient_map_C_eq_zero) (⇑(ideal.quotient.mk (ideal.map polynomial.C I)) polynomial.X)) g
R : Type u,	_inst_1 : comm_ring R,	I : ideal R,	f g : polynomial I.quotient	⊢ ⇑(polynomial.eval₂_ring_hom (ideal.quotient.lift I ((ideal.quotient.mk (ideal.map polynomial.C I)).comp polynomial.C) ideal.quotient_map_C_eq_zero) (⇑(ideal.quotient.mk (ideal.map polynomial.C I)) polynomial.X)) (f + g) = ⇑(polynomial.eval₂_ring_hom (ideal.quotient.lift I ((ideal.quotient.mk (ideal.map polynomial.C I)).comp polynomial.C) ideal.quotient_map_C_eq_zero) (⇑(ideal.quotient.mk (ideal.map polynomial.C I)) polynomial.X)) f + ⇑(polynomial.eval₂_ring_hom (ideal.quotient.lift I ((ideal.quotient.mk (ideal.map polynomial.C I)).comp polynomial.C) ideal.quotient_map_C_eq_zero) (⇑(ideal.quotient.mk (ideal.map polynomial.C I)) polynomial.X)) g
R : Type u,	_inst_1 : comm_ring R,	I : ideal R	⊢ function.left_inverse ⇑(ideal.quotient.lift (ideal.map polynomial.C I) (polynomial.eval₂_ring_hom (polynomial.C.comp (ideal.quotient.mk I)) polynomial.X) ideal.eval₂_C_mk_eq_zero) ⇑(polynomial.eval₂_ring_hom (ideal.quotient.lift I ((ideal.quotient.mk (ideal.map polynomial.C I)).comp polynomial.C) ideal.quotient_map_C_eq_zero) (⇑(ideal.quotient.mk (ideal.map polynomial.C I)) polynomial.X))
R : Type u,	_inst_1 : comm_ring R,	I : ideal R,	f : polynomial I.quotient	⊢ ⇑(ideal.quotient.lift (ideal.map polynomial.C I) (polynomial.eval₂_ring_hom (polynomial.C.comp (ideal.quotient.mk I)) polynomial.X) ideal.eval₂_C_mk_eq_zero) (⇑(polynomial.eval₂_ring_hom (ideal.quotient.lift I ((ideal.quotient.mk (ideal.map polynomial.C I)).comp polynomial.C) ideal.quotient_map_C_eq_zero) (⇑(ideal.quotient.mk (ideal.map polynomial.C I)) polynomial.X)) f) = f
R : Type u,	_inst_1 : comm_ring R,	I : ideal R,	f : polynomial I.quotient	⊢ ∀ (p q : polynomial I.quotient), ⇑(ideal.quotient.lift (ideal.map polynomial.C I) (polynomial.eval₂_ring_hom (polynomial.C.comp (ideal.quotient.mk I)) polynomial.X) ideal.eval₂_C_mk_eq_zero) (⇑(polynomial.eval₂_ring_hom (ideal.quotient.lift I ((ideal.quotient.mk (ideal.map polynomial.C I)).comp polynomial.C) ideal.quotient_map_C_eq_zero) (⇑(ideal.quotient.mk (ideal.map polynomial.C I)) polynomial.X)) p) = p → ⇑(ideal.quotient.lift (ideal.map polynomial.C I) (polynomial.eval₂_ring_hom (polynomial.C.comp (ideal.quotient.mk I)) polynomial.X) ideal.eval₂_C_mk_eq_zero) (⇑(polynomial.eval₂_ring_hom (ideal.quotient.lift I ((ideal.quotient.mk (ideal.map polynomial.C I)).comp polynomial.C) ideal.quotient_map_C_eq_zero) (⇑(ideal.quotient.mk (ideal.map polynomial.C I)) polynomial.X)) q) = q → ⇑(ideal.quotient.lift (ideal.map polynomial.C I) (polynomial.eval₂_ring_hom (polynomial.C.comp (ideal.quotient.mk I)) polynomial.X) ideal.eval₂_C_mk_eq_zero) (⇑(polynomial.eval₂_ring_hom (ideal.quotient.lift I ((ideal.quotient.mk (ideal.map polynomial.C I)).comp polynomial.C) ideal.quotient_map_C_eq_zero) (⇑(ideal.quotient.mk (ideal.map polynomial.C I)) polynomial.X)) (p + q)) = p + q
R : Type u,	_inst_1 : comm_ring R,	I : ideal R,	f p q : polynomial I.quotient,	hp : ⇑(ideal.quotient.lift (ideal.map polynomial.C I) (polynomial.eval₂_ring_hom (polynomial.C.comp (ideal.quotient.mk I)) polynomial.X) ideal.eval₂_C_mk_eq_zero) (⇑(polynomial.eval₂_ring_hom (ideal.quotient.lift I ((ideal.quotient.mk (ideal.map polynomial.C I)).comp polynomial.C) ideal.quotient_map_C_eq_zero) (⇑(ideal.quotient.mk (ideal.map polynomial.C I)) polynomial.X)) p) = p,	hq : ⇑(ideal.quotient.lift (ideal.map polynomial.C I) (polynomial.eval₂_ring_hom (polynomial.C.comp (ideal.quotient.mk I)) polynomial.X) ideal.eval₂_C_mk_eq_zero) (⇑(polynomial.eval₂_ring_hom (ideal.quotient.lift I ((ideal.quotient.mk (ideal.map polynomial.C I)).comp polynomial.C) ideal.quotient_map_C_eq_zero) (⇑(ideal.quotient.mk (ideal.map polynomial.C I)) polynomial.X)) q) = q	⊢ ⇑(ideal.quotient.lift (ideal.map polynomial.C I) (polynomial.eval₂_ring_hom (polynomial.C.comp (ideal.quotient.mk I)) polynomial.X) ideal.eval₂_C_mk_eq_zero) (⇑(polynomial.eval₂_ring_hom (ideal.quotient.lift I ((ideal.quotient.mk (ideal.map polynomial.C I)).comp polynomial.C) ideal.quotient_map_C_eq_zero) (⇑(ideal.quotient.mk (ideal.map polynomial.C I)) polynomial.X)) (p + q)) = p + q
R : Type u,	_inst_1 : comm_ring R,	I : ideal R,	f p q : polynomial I.quotient,	hq : ⇑(ideal.quotient.lift (ideal.map polynomial.C I) (polynomial.eval₂_ring_hom (polynomial.C.comp (ideal.quotient.mk I)) polynomial.X) ideal.eval₂_C_mk_eq_zero) (⇑(polynomial.eval₂_ring_hom (ideal.quotient.lift I ((ideal.quotient.mk (ideal.map polynomial.C I)).comp polynomial.C) ideal.quotient_map_C_eq_zero) (⇑(ideal.quotient.mk (ideal.map polynomial.C I)) polynomial.X)) q) = q,	hp : ⇑(ideal.quotient.lift (ideal.map polynomial.C I) (polynomial.eval₂_ring_hom (polynomial.C.comp (ideal.quotient.mk I)) polynomial.X) ideal.eval₂_C_mk_eq_zero) (polynomial.eval₂ (ideal.quotient.lift I ((ideal.quotient.mk (ideal.map polynomial.C I)).comp polynomial.C) ideal.quotient_map_C_eq_zero) (⇑(ideal.quotient.mk (ideal.map polynomial.C I)) polynomial.X) p) = p	⊢ ⇑(ideal.quotient.lift (ideal.map polynomial.C I) (polynomial.eval₂_ring_hom (polynomial.C.comp (ideal.quotient.mk I)) polynomial.X) ideal.eval₂_C_mk_eq_zero) (⇑(polynomial.eval₂_ring_hom (ideal.quotient.lift I ((ideal.quotient.mk (ideal.map polynomial.C I)).comp polynomial.C) ideal.quotient_map_C_eq_zero) (⇑(ideal.quotient.mk (ideal.map polynomial.C I)) polynomial.X)) (p + q)) = p + q
R : Type u,	_inst_1 : comm_ring R,	I : ideal R,	f : polynomial I.quotient	⊢ ∀ (p q : polynomial I.quotient), ⇑(ideal.quotient.lift (ideal.map polynomial.C I) (polynomial.eval₂_ring_hom (polynomial.C.comp (ideal.quotient.mk I)) polynomial.X) ideal.eval₂_C_mk_eq_zero) (⇑(polynomial.eval₂_ring_hom (ideal.quotient.lift I ((ideal.quotient.mk (ideal.map polynomial.C I)).comp polynomial.C) ideal.quotient_map_C_eq_zero) (⇑(ideal.quotient.mk (ideal.map polynomial.C I)) polynomial.X)) p) = p → ⇑(ideal.quotient.lift (ideal.map polynomial.C I) (polynomial.eval₂_ring_hom (polynomial.C.comp (ideal.quotient.mk I)) polynomial.X) ideal.eval₂_C_mk_eq_zero) (⇑(polynomial.eval₂_ring_hom (ideal.quotient.lift I ((ideal.quotient.mk (ideal.map polynomial.C I)).comp polynomial.C) ideal.quotient_map_C_eq_zero) (⇑(ideal.quotient.mk (ideal.map polynomial.C I)) polynomial.X)) q) = q → ⇑(ideal.quotient.lift (ideal.map polynomial.C I) (polynomial.eval₂_ring_hom (polynomial.C.comp (ideal.quotient.mk I)) polynomial.X) ideal.eval₂_C_mk_eq_zero) (⇑(polynomial.eval₂_ring_hom (ideal.quotient.lift I ((ideal.quotient.mk (ideal.map polynomial.C I)).comp polynomial.C) ideal.quotient_map_C_eq_zero) (⇑(ideal.quotient.mk (ideal.map polynomial.C I)) polynomial.X)) (p + q)) = p + q		R : Type u,	_inst_1 : comm_ring R,	I : ideal R,	f : polynomial I.quotient	⊢ ∀ (n : ℕ) (a : I.quotient), ⇑(ideal.quotient.lift (ideal.map polynomial.C I) (polynomial.eval₂_ring_hom (polynomial.C.comp (ideal.quotient.mk I)) polynomial.X) ideal.eval₂_C_mk_eq_zero) (⇑(polynomial.eval₂_ring_hom (ideal.quotient.lift I ((ideal.quotient.mk (ideal.map polynomial.C I)).comp polynomial.C) ideal.quotient_map_C_eq_zero) (⇑(ideal.quotient.mk (ideal.map polynomial.C I)) polynomial.X)) (⇑(polynomial.monomial n) a)) = ⇑(polynomial.monomial n) a
R : Type u,	_inst_1 : comm_ring R,	I : ideal R,	f p q : polynomial I.quotient,	hp : ⇑(ideal.quotient.lift (ideal.map polynomial.C I) (polynomial.eval₂_ring_hom (polynomial.C.comp (ideal.quotient.mk I)) polynomial.X) ideal.eval₂_C_mk_eq_zero) (polynomial.eval₂ (ideal.quotient.lift I ((ideal.quotient.mk (ideal.map polynomial.C I)).comp polynomial.C) ideal.quotient_map_C_eq_zero) (⇑(ideal.quotient.mk (ideal.map polynomial.C I)) polynomial.X) p) = p,	hq : ⇑(ideal.quotient.lift (ideal.map polynomial.C I) (polynomial.eval₂_ring_hom (polynomial.C.comp (ideal.quotient.mk I)) polynomial.X) ideal.eval₂_C_mk_eq_zero) (polynomial.eval₂ (ideal.quotient.lift I ((ideal.quotient.mk (ideal.map polynomial.C I)).comp polynomial.C) ideal.quotient_map_C_eq_zero) (⇑(ideal.quotient.mk (ideal.map polynomial.C I)) polynomial.X) q) = q	⊢ ⇑(ideal.quotient.lift (ideal.map polynomial.C I) (polynomial.eval₂_ring_hom (polynomial.C.comp (ideal.quotient.mk I)) polynomial.X) ideal.eval₂_C_mk_eq_zero) (⇑(polynomial.eval₂_ring_hom (ideal.quotient.lift I ((ideal.quotient.mk (ideal.map polynomial.C I)).comp polynomial.C) ideal.quotient_map_C_eq_zero) (⇑(ideal.quotient.mk (ideal.map polynomial.C I)) polynomial.X)) (p + q)) = p + q
R : Type u,	_inst_1 : comm_ring R,	I : ideal R,	f : polynomial I.quotient	⊢ ∀ (n : ℕ) (a : I.quotient), ⇑(ideal.quotient.lift (ideal.map polynomial.C I) (polynomial.eval₂_ring_hom (polynomial.C.comp (ideal.quotient.mk I)) polynomial.X) ideal.eval₂_C_mk_eq_zero) (⇑(polynomial.eval₂_ring_hom (ideal.quotient.lift I ((ideal.quotient.mk (ideal.map polynomial.C I)).comp polynomial.C) ideal.quotient_map_C_eq_zero) (⇑(ideal.quotient.mk (ideal.map polynomial.C I)) polynomial.X)) (⇑(polynomial.monomial n) a)) = ⇑(polynomial.monomial n) a
R : Type u,	_inst_1 : comm_ring R,	I : ideal R,	f : polynomial I.quotient,	n : ℕ,	x : R	⊢ ⇑(ideal.quotient.lift (ideal.map polynomial.C I) (polynomial.eval₂_ring_hom (polynomial.C.comp (ideal.quotient.mk I)) polynomial.X) ideal.eval₂_C_mk_eq_zero) (⇑(polynomial.eval₂_ring_hom (ideal.quotient.lift I ((ideal.quotient.mk (ideal.map polynomial.C I)).comp polynomial.C) ideal.quotient_map_C_eq_zero) (⇑(ideal.quotient.mk (ideal.map polynomial.C I)) polynomial.X)) (⇑(polynomial.monomial n) (quot.mk setoid.r x))) = ⇑(polynomial.monomial n) (quot.mk setoid.r x)
R : Type u,	_inst_1 : comm_ring R,	I : ideal R	⊢ function.right_inverse ⇑(ideal.quotient.lift (ideal.map polynomial.C I) (polynomial.eval₂_ring_hom (polynomial.C.comp (ideal.quotient.mk I)) polynomial.X) ideal.eval₂_C_mk_eq_zero) ⇑(polynomial.eval₂_ring_hom (ideal.quotient.lift I ((ideal.quotient.mk (ideal.map polynomial.C I)).comp polynomial.C) ideal.quotient_map_C_eq_zero) (⇑(ideal.quotient.mk (ideal.map polynomial.C I)) polynomial.X))
R : Type u,	_inst_1 : comm_ring R,	I : ideal R,	f : polynomial R	⊢ ⇑(polynomial.eval₂_ring_hom (ideal.quotient.lift I ((ideal.quotient.mk (ideal.map polynomial.C I)).comp polynomial.C) ideal.quotient_map_C_eq_zero) (⇑(ideal.quotient.mk (ideal.map polynomial.C I)) polynomial.X)) (⇑(ideal.quotient.lift (ideal.map polynomial.C I) (polynomial.eval₂_ring_hom (polynomial.C.comp (ideal.quotient.mk I)) polynomial.X) ideal.eval₂_C_mk_eq_zero) (quot.mk setoid.r f)) = quot.mk setoid.r f
R : Type u,	_inst_1 : comm_ring R,	I : ideal R,	f : polynomial R	⊢ ∀ (p q : polynomial R), ⇑(polynomial.eval₂_ring_hom (ideal.quotient.lift I ((ideal.quotient.mk (ideal.map polynomial.C I)).comp polynomial.C) ideal.quotient_map_C_eq_zero) (⇑(ideal.quotient.mk (ideal.map polynomial.C I)) polynomial.X)) (⇑(ideal.quotient.lift (ideal.map polynomial.C I) (polynomial.eval₂_ring_hom (polynomial.C.comp (ideal.quotient.mk I)) polynomial.X) ideal.eval₂_C_mk_eq_zero) (quot.mk setoid.r p)) = quot.mk setoid.r p → ⇑(polynomial.eval₂_ring_hom (ideal.quotient.lift I ((ideal.quotient.mk (ideal.map polynomial.C I)).comp polynomial.C) ideal.quotient_map_C_eq_zero) (⇑(ideal.quotient.mk (ideal.map polynomial.C I)) polynomial.X)) (⇑(ideal.quotient.lift (ideal.map polynomial.C I) (polynomial.eval₂_ring_hom (polynomial.C.comp (ideal.quotient.mk I)) polynomial.X) ideal.eval₂_C_mk_eq_zero) (quot.mk setoid.r q)) = quot.mk setoid.r q → ⇑(polynomial.eval₂_ring_hom (ideal.quotient.lift I ((ideal.quotient.mk (ideal.map polynomial.C I)).comp polynomial.C) ideal.quotient_map_C_eq_zero) (⇑(ideal.quotient.mk (ideal.map polynomial.C I)) polynomial.X)) (⇑(ideal.quotient.lift (ideal.map polynomial.C I) (polynomial.eval₂_ring_hom (polynomial.C.comp (ideal.quotient.mk I)) polynomial.X) ideal.eval₂_C_mk_eq_zero) (quot.mk setoid.r (p + q))) = quot.mk setoid.r (p + q)
R : Type u,	_inst_1 : comm_ring R,	I : ideal R,	f : polynomial R	⊢ ∀ (p q : polynomial R), ⇑(polynomial.eval₂_ring_hom (ideal.quotient.lift I ((ideal.quotient.mk (ideal.map polynomial.C I)).comp polynomial.C) ideal.quotient_map_C_eq_zero) (⇑(ideal.quotient.mk (ideal.map polynomial.C I)) polynomial.X)) (⇑(ideal.quotient.lift (ideal.map polynomial.C I) (polynomial.eval₂_ring_hom (polynomial.C.comp (ideal.quotient.mk I)) polynomial.X) ideal.eval₂_C_mk_eq_zero) (quot.mk setoid.r p)) = quot.mk setoid.r p → ⇑(polynomial.eval₂_ring_hom (ideal.quotient.lift I ((ideal.quotient.mk (ideal.map polynomial.C I)).comp polynomial.C) ideal.quotient_map_C_eq_zero) (⇑(ideal.quotient.mk (ideal.map polynomial.C I)) polynomial.X)) (⇑(ideal.quotient.lift (ideal.map polynomial.C I) (polynomial.eval₂_ring_hom (polynomial.C.comp (ideal.quotient.mk I)) polynomial.X) ideal.eval₂_C_mk_eq_zero) (quot.mk setoid.r q)) = quot.mk setoid.r q → ⇑(polynomial.eval₂_ring_hom (ideal.quotient.lift I ((ideal.quotient.mk (ideal.map polynomial.C I)).comp polynomial.C) ideal.quotient_map_C_eq_zero) (⇑(ideal.quotient.mk (ideal.map polynomial.C I)) polynomial.X)) (⇑(ideal.quotient.lift (ideal.map polynomial.C I) (polynomial.eval₂_ring_hom (polynomial.C.comp (ideal.quotient.mk I)) polynomial.X) ideal.eval₂_C_mk_eq_zero) (quot.mk setoid.r (p + q))) = quot.mk setoid.r (p + q)		R : Type u,	_inst_1 : comm_ring R,	I : ideal R,	f : polynomial R	⊢ ∀ (n : ℕ) (a : R), ⇑(polynomial.eval₂_ring_hom (ideal.quotient.lift I ((ideal.quotient.mk (ideal.map polynomial.C I)).comp polynomial.C) ideal.quotient_map_C_eq_zero) (⇑(ideal.quotient.mk (ideal.map polynomial.C I)) polynomial.X)) (⇑(ideal.quotient.lift (ideal.map polynomial.C I) (polynomial.eval₂_ring_hom (polynomial.C.comp (ideal.quotient.mk I)) polynomial.X) ideal.eval₂_C_mk_eq_zero) (quot.mk setoid.r (⇑(polynomial.monomial n) a))) = quot.mk setoid.r (⇑(polynomial.monomial n) a)
R : Type u,	_inst_1 : comm_ring R,	I : ideal R,	f p q : polynomial R,	hp : polynomial.eval₂ (ideal.quotient.lift I ((ideal.quotient.mk (ideal.map polynomial.C I)).comp polynomial.C) ideal.quotient_map_C_eq_zero) (⇑(ideal.quotient.mk (ideal.map polynomial.C I)) polynomial.X) (polynomial.eval₂ (polynomial.C.comp (ideal.quotient.mk I)) polynomial.X p) = ⇑(ideal.quotient.mk (ideal.map polynomial.C I)) p,	hq : polynomial.eval₂ (ideal.quotient.lift I ((ideal.quotient.mk (ideal.map polynomial.C I)).comp polynomial.C) ideal.quotient_map_C_eq_zero) (⇑(ideal.quotient.mk (ideal.map polynomial.C I)) polynomial.X) (polynomial.eval₂ (polynomial.C.comp (ideal.quotient.mk I)) polynomial.X q) = ⇑(ideal.quotient.mk (ideal.map polynomial.C I)) q	⊢ polynomial.eval₂ (ideal.quotient.lift I ((ideal.quotient.mk (ideal.map polynomial.C I)).comp polynomial.C) ideal.quotient_map_C_eq_zero) (⇑(ideal.quotient.mk (ideal.map polynomial.C I)) polynomial.X) (polynomial.eval₂ (polynomial.C.comp (ideal.quotient.mk I)) polynomial.X p) + polynomial.eval₂ (ideal.quotient.lift I ((ideal.quotient.mk (ideal.map polynomial.C I)).comp polynomial.C) ideal.quotient_map_C_eq_zero) (⇑(ideal.quotient.mk (ideal.map polynomial.C I)) polynomial.X) (polynomial.eval₂ (polynomial.C.comp (ideal.quotient.mk I)) polynomial.X q) = ⇑(ideal.quotient.mk (ideal.map polynomial.C I)) p + ⇑(ideal.quotient.mk (ideal.map polynomial.C I)) q
R : Type u,	_inst_1 : comm_ring R,	I : ideal R,	f : polynomial R	⊢ ∀ (n : ℕ) (a : R), ⇑(polynomial.eval₂_ring_hom (ideal.quotient.lift I ((ideal.quotient.mk (ideal.map polynomial.C I)).comp polynomial.C) ideal.quotient_map_C_eq_zero) (⇑(ideal.quotient.mk (ideal.map polynomial.C I)) polynomial.X)) (⇑(ideal.quotient.lift (ideal.map polynomial.C I) (polynomial.eval₂_ring_hom (polynomial.C.comp (ideal.quotient.mk I)) polynomial.X) ideal.eval₂_C_mk_eq_zero) (quot.mk setoid.r (⇑(polynomial.monomial n) a))) = quot.mk setoid.r (⇑(polynomial.monomial n) a)
R : Type u,	_inst_1 : comm_ring R,	I : ideal R,	f : polynomial R,	n : ℕ,	a : R	⊢ ⇑(polynomial.eval₂_ring_hom (ideal.quotient.lift I ((ideal.quotient.mk (ideal.map polynomial.C I)).comp polynomial.C) ideal.quotient_map_C_eq_zero) (⇑(ideal.quotient.mk (ideal.map polynomial.C I)) polynomial.X)) (⇑(ideal.quotient.lift (ideal.map polynomial.C I) (polynomial.eval₂_ring_hom (polynomial.C.comp (ideal.quotient.mk I)) polynomial.X) ideal.eval₂_C_mk_eq_zero) (quot.mk setoid.r (⇑(polynomial.monomial n) a))) = quot.mk setoid.r (⇑(polynomial.monomial n) a)
R : Type u,	σ : Type v,	_inst_4 : integral_domain R,	H : 0 = 1	⊢ false
R : Type u,	σ : Type v,	_inst_4 : integral_domain R,	H : 0 = 1	⊢ 0 = 1
R : Type u,	σ : Type v,	_inst_4 : integral_domain R,	H : 0 = 1	⊢ mv_polynomial.eval₂ (ring_hom.id R) (λ (s : σ), 0) 0 = mv_polynomial.eval₂ (ring_hom.id R) (λ (s : σ), 0) 1		R : Type u,	σ : Type v,	_inst_4 : integral_domain R,	H : 0 = 1,	this : mv_polynomial.eval₂ (ring_hom.id R) (λ (s : σ), 0) 0 = mv_polynomial.eval₂ (ring_hom.id R) (λ (s : σ), 0) 1	⊢ false
R : Type u,	σ : Type v,	_inst_4 : integral_domain R,	H : 0 = 1	⊢ mv_polynomial.eval₂ (ring_hom.id R) (λ (s : σ), 0) 0 = mv_polynomial.eval₂ (ring_hom.id R) (λ (s : σ), 0) 1
R : Type u,	σ : Type v,	_inst_4 : integral_domain R,	H : 0 = 1,	this : mv_polynomial.eval₂ (ring_hom.id R) (λ (s : σ), 0) 0 = mv_polynomial.eval₂ (ring_hom.id R) (λ (s : σ), 0) 1	⊢ false
R : Type u,	σ : Type v,	_inst_4 : integral_domain R	⊢ comm_ring (mv_polynomial σ R)
R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ ⇑polynomial.derivative (bernstein_polynomial R (n + 1) (ν + 1)) = (↑n + 1) * (bernstein_polynomial R n ν - bernstein_polynomial R n (ν + 1))
R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ ⇑polynomial.derivative (↑((n + 1).choose (ν + 1)) * polynomial.X ^ (ν + 1) * (1 - polynomial.X) ^ (n + 1 - (ν + 1))) = (↑n + 1) * (↑(n.choose ν) * polynomial.X ^ ν * (1 - polynomial.X) ^ (n - ν) - ↑(n.choose (ν + 1)) * polynomial.X ^ (ν + 1) * (1 - polynomial.X) ^ (n - (ν + 1)))
R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ,	this : ↑((n + 1).choose (ν + 1)) * ((↑ν + 1) * polynomial.X ^ ν) * (1 - polynomial.X) ^ (n - ν) - ↑((n + 1).choose (ν + 1)) * polynomial.X ^ (ν + 1) * (↑(n - ν) * (1 - polynomial.X) ^ (n - ν - 1)) = (↑n + 1) * (↑(n.choose ν) * polynomial.X ^ ν * (1 - polynomial.X) ^ (n - ν) - ↑(n.choose (ν + 1)) * polynomial.X ^ (ν + 1) * (1 - polynomial.X) ^ (n - (ν + 1)))	⊢ ⇑polynomial.derivative (↑((n + 1).choose (ν + 1)) * polynomial.X ^ (ν + 1) * (1 - polynomial.X) ^ (n + 1 - (ν + 1))) = (↑n + 1) * (↑(n.choose ν) * polynomial.X ^ ν * (1 - polynomial.X) ^ (n - ν) - ↑(n.choose (ν + 1)) * polynomial.X ^ (ν + 1) * (1 - polynomial.X) ^ (n - (ν + 1)))		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ ↑((n + 1).choose (ν + 1)) * ((↑ν + 1) * polynomial.X ^ ν) * (1 - polynomial.X) ^ (n - ν) - ↑((n + 1).choose (ν + 1)) * polynomial.X ^ (ν + 1) * (↑(n - ν) * (1 - polynomial.X) ^ (n - ν - 1)) = (↑n + 1) * (↑(n.choose ν) * polynomial.X ^ ν * (1 - polynomial.X) ^ (n - ν) - ↑(n.choose (ν + 1)) * polynomial.X ^ (ν + 1) * (1 - polynomial.X) ^ (n - (ν + 1)))		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ Type ?		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ semiring ?m_1		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_sub (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_mul (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_mul (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_lift_t ℕ (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_mul (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_add (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_lift_t ℕ (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_one (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_pow (polynomial ?m_1) ℕ		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_pow (polynomial ?m_1) ℕ		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_sub (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_one (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_mul (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_mul (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_lift_t ℕ (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_pow (polynomial ?m_1) ℕ		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_mul (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_lift_t ℕ (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_pow (polynomial ?m_1) ℕ		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_sub (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_one (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_mul (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_add (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_lift_t ℕ (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_one (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_sub (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_mul (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_mul (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_lift_t ℕ (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_pow (polynomial ?m_1) ℕ		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_pow (polynomial ?m_1) ℕ		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_sub (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_one (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_mul (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_mul (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_lift_t ℕ (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_pow (polynomial ?m_1) ℕ		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_pow (polynomial ?m_1) ℕ		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_sub (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_one (polynomial ?m_1)
R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ,	this : ↑((n + 1).choose (ν + 1)) * ((↑ν + 1) * polynomial.X ^ ν) * (1 - polynomial.X) ^ (n - ν) - ↑((n + 1).choose (ν + 1)) * polynomial.X ^ (ν + 1) * (↑(n - ν) * (1 - polynomial.X) ^ (n - ν - 1)) = (↑n + 1) * (↑(n.choose ν) * polynomial.X ^ ν * (1 - polynomial.X) ^ (n - ν) - ↑(n.choose (ν + 1)) * polynomial.X ^ (ν + 1) * (1 - polynomial.X) ^ (n - (ν + 1)))	⊢ ⇑polynomial.derivative (↑((n + 1).choose (ν + 1)) * polynomial.X ^ (ν + 1) * (1 - polynomial.X) ^ (n + 1 - (ν + 1))) = (↑n + 1) * (↑(n.choose ν) * polynomial.X ^ ν * (1 - polynomial.X) ^ (n - ν) - ↑(n.choose (ν + 1)) * polynomial.X ^ (ν + 1) * (1 - polynomial.X) ^ (n - (ν + 1)))
R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ (↑n + 1) * (↑(n.choose ν) * polynomial.X ^ ν * (1 - polynomial.X) ^ (n - ν) - ↑(n.choose (ν + 1)) * polynomial.X ^ (ν + 1) * (1 - polynomial.X) ^ (n - (ν + 1))) = ?m_1
R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ ↑((n + 1).choose (ν + 1)) * ((↑ν + 1) * polynomial.X ^ ν) * (1 - polynomial.X) ^ (n - ν) - ↑((n + 1).choose (ν + 1)) * polynomial.X ^ (ν + 1) * (↑(n - ν) * (1 - polynomial.X) ^ (n - ν - 1)) = (↑n + 1) * (↑(n.choose ν) * polynomial.X ^ ν * (1 - polynomial.X) ^ (n - ν) - ↑(n.choose (ν + 1)) * polynomial.X ^ (ν + 1) * (1 - polynomial.X) ^ (n - (ν + 1)))
R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ ↑((n + 1).choose (ν + 1)) * ((↑ν + 1) * polynomial.X ^ ν) * (1 - polynomial.X) ^ (n - ν) - ↑((n + 1).choose (ν + 1)) * polynomial.X ^ (ν + 1) * (↑(n - ν) * (1 - polynomial.X) ^ (n - ν - 1)) = (↑n + 1) * (↑(n.choose ν) * polynomial.X ^ ν * (1 - polynomial.X) ^ (n - ν)) - (↑n + 1) * (↑(n.choose (ν + 1)) * polynomial.X ^ (ν + 1) * (1 - polynomial.X) ^ (n - (ν + 1)))
R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ ↑((n + 1).choose (ν + 1)) * ((↑ν + 1) * polynomial.X ^ ν) * (1 - polynomial.X) ^ (n - ν) = (↑n + 1) * (↑(n.choose ν) * polynomial.X ^ ν * (1 - polynomial.X) ^ (n - ν))
R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ ↑((n + 1).choose (ν + 1)) * (↑ν + 1) * polynomial.X ^ ν * (1 - polynomial.X) ^ (n - ν) = (↑n + 1) * ↑(n.choose ν) * polynomial.X ^ ν * (1 - polynomial.X) ^ (n - ν)
R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ ↑((n + 1).choose (ν + 1)) * (↑ν + 1) = (↑n + 1) * ↑(n.choose ν)
R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ ↑((n + 1).choose (ν + 1)) * ((↑ν + 1) * polynomial.X ^ ν) * (1 - polynomial.X) ^ (n - ν) = (↑n + 1) * (↑(n.choose ν) * polynomial.X ^ ν * (1 - polynomial.X) ^ (n - ν))		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ ↑((n + 1).choose (ν + 1)) * polynomial.X ^ (ν + 1) * (↑(n - ν) * (1 - polynomial.X) ^ (n - ν - 1)) = (↑n + 1) * (↑(n.choose (ν + 1)) * polynomial.X ^ (ν + 1) * (1 - polynomial.X) ^ (n - (ν + 1)))
R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ ↑((n + 1).choose (ν + 1)) * polynomial.X ^ (ν + 1) * (↑(n - ν) * (1 - polynomial.X) ^ (n - (ν + 1))) = (↑n + 1) * (↑(n.choose (ν + 1)) * polynomial.X ^ (ν + 1) * (1 - polynomial.X) ^ (n - (ν + 1)))
R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ ↑((n + 1).choose (ν + 1)) * polynomial.X ^ (ν + 1) * ↑(n - ν) * (1 - polynomial.X) ^ (n - (ν + 1)) = (↑n + 1) * (↑(n.choose (ν + 1)) * polynomial.X ^ (ν + 1)) * (1 - polynomial.X) ^ (n - (ν + 1))
R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ ↑((n + 1).choose (ν + 1)) * polynomial.X ^ (ν + 1) * (↑(n - ν) * (1 - polynomial.X) ^ (n - ν - 1)) = (↑n + 1) * (↑(n.choose (ν + 1)) * polynomial.X ^ (ν + 1) * (1 - polynomial.X) ^ (n - (ν + 1)))
R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ ↑(n - ν) * (↑((n + 1).choose (ν + 1)) * polynomial.X ^ (ν + 1)) = (↑n + 1) * (↑(n.choose (ν + 1)) * polynomial.X ^ (ν + 1))
R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ ↑(n - ν) * ↑((n + 1).choose (ν + 1)) * polynomial.X ^ (ν + 1) = (↑n + 1) * ↑(n.choose (ν + 1)) * polynomial.X ^ (ν + 1)
R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ ↑((n + 1).choose (ν + 1)) * polynomial.X ^ (ν + 1) * ↑(n - ν) = (↑n + 1) * (↑(n.choose (ν + 1)) * polynomial.X ^ (ν + 1))
R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ ↑(n - ν) * ↑((n + 1).choose (ν + 1)) = (↑n + 1) * ↑(n.choose (ν + 1))
R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ ↑((n - ν) * (n + 1).choose (ν + 1)) = ↑((n + 1) * n.choose (ν + 1))
R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ (n - ν) * (n + 1).choose (ν + 1) = (n + 1) * n.choose (ν + 1)
R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ (n - ν) * (n + 1).choose (ν + 1) = (n + 1).choose (ν + 1) * (n + 1 - (ν + 1))
R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ (n - ν) * (n + 1).choose (ν + 1) = (n + 1).choose (ν + 1) * (n + 1 - (ν + 1))		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ (n + 1) * n.choose (ν + 1) = n.choose (ν + 1) * (n + 1)
R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ n + 1 - (ν + 1) = n - ν
R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ (n + 1) * n.choose (ν + 1) = n.choose (ν + 1) * (n + 1)
R : Type u_1,	_inst_1 : comm_ring R,	n : ℕ	⊢ (finset.range (n + 1)).sum (λ (ν : ℕ), (ν * (ν - 1)) • bernstein_polynomial R n ν) = (n * (n - 1)) • polynomial.X ^ 2
R : Type u_1,	_inst_1 : comm_ring R,	n : ℕ,	x : mv_polynomial bool R := mv_polynomial.X bool.tt	⊢ (finset.range (n + 1)).sum (λ (ν : ℕ), (ν * (ν - 1)) • bernstein_polynomial R n ν) = (n * (n - 1)) • polynomial.X ^ 2
R : Type u_1,	_inst_1 : comm_ring R,	n : ℕ,	x : mv_polynomial bool R := mv_polynomial.X bool.tt,	y : mv_polynomial bool R := mv_polynomial.X bool.ff	⊢ (finset.range (n + 1)).sum (λ (ν : ℕ), (ν * (ν - 1)) • bernstein_polynomial R n ν) = (n * (n - 1)) • polynomial.X ^ 2
R : Type u_1,	_inst_1 : comm_ring R,	n : ℕ,	x : mv_polynomial bool R := mv_polynomial.X bool.tt,	y : mv_polynomial bool R := mv_polynomial.X bool.ff	⊢ ⇑(mv_polynomial.pderiv bool.tt) x = 1
R : Type u_1,	_inst_1 : comm_ring R,	n : ℕ,	x : mv_polynomial bool R := mv_polynomial.X bool.tt,	y : mv_polynomial bool R := mv_polynomial.X bool.ff	⊢ ⇑(mv_polynomial.pderiv bool.tt) x = 1		R : Type u_1,	_inst_1 : comm_ring R,	n : ℕ,	x : mv_polynomial bool R := mv_polynomial.X bool.tt,	y : mv_polynomial bool R := mv_polynomial.X bool.ff,	pderiv_tt_x : ⇑(mv_polynomial.pderiv bool.tt) x = 1	⊢ (finset.range (n + 1)).sum (λ (ν : ℕ), (ν * (ν - 1)) • bernstein_polynomial R n ν) = (n * (n - 1)) • polynomial.X ^ 2
R : Type u_1,	_inst_1 : comm_ring R,	n : ℕ,	x : mv_polynomial bool R := mv_polynomial.X bool.tt,	y : mv_polynomial bool R := mv_polynomial.X bool.ff,	pderiv_tt_x : ⇑(mv_polynomial.pderiv bool.tt) x = 1	⊢ (finset.range (n + 1)).sum (λ (ν : ℕ), (ν * (ν - 1)) • bernstein_polynomial R n ν) = (n * (n - 1)) • polynomial.X ^ 2
R : Type u_1,	_inst_1 : comm_ring R,	n : ℕ,	x : mv_polynomial bool R := mv_polynomial.X bool.tt,	y : mv_polynomial bool R := mv_polynomial.X bool.ff,	pderiv_tt_x : ⇑(mv_polynomial.pderiv bool.tt) x = 1	⊢ ⇑(mv_polynomial.pderiv bool.tt) y = 0
R : Type u_1,	_inst_1 : comm_ring R,	n : ℕ,	x : mv_polynomial bool R := mv_polynomial.X bool.tt,	y : mv_polynomial bool R := mv_polynomial.X bool.ff,	pderiv_tt_x : ⇑(mv_polynomial.pderiv bool.tt) x = 1	⊢ ⇑(mv_polynomial.pderiv bool.tt) y = 0		R : Type u_1,	_inst_1 : comm_ring R,	n : ℕ,	x : mv_polynomial bool R := mv_polynomial.X bool.tt,	y : mv_polynomial bool R := mv_polynomial.X bool.ff,	pderiv_tt_x : ⇑(mv_polynomial.pderiv bool.tt) x = 1,	pderiv_tt_y : ⇑(mv_polynomial.pderiv bool.tt) y = 0	⊢ (finset.range (n + 1)).sum (λ (ν : ℕ), (ν * (ν - 1)) • bernstein_polynomial R n ν) = (n * (n - 1)) • polynomial.X ^ 2
R : Type u_1,	_inst_1 : comm_ring R,	n : ℕ,	x : mv_polynomial bool R := mv_polynomial.X bool.tt,	y : mv_polynomial bool R := mv_polynomial.X bool.ff,	pderiv_tt_x : ⇑(mv_polynomial.pderiv bool.tt) x = 1,	pderiv_tt_y : ⇑(mv_polynomial.pderiv bool.tt) y = 0	⊢ (finset.range (n + 1)).sum (λ (ν : ℕ), (ν * (ν - 1)) • bernstein_polynomial R n ν) = (n * (n - 1)) • polynomial.X ^ 2
R : Type u_1,	_inst_1 : comm_ring R,	n : ℕ,	x : mv_polynomial bool R := mv_polynomial.X bool.tt,	y : mv_polynomial bool R := mv_polynomial.X bool.ff,	pderiv_tt_x : ⇑(mv_polynomial.pderiv bool.tt) x = 1,	pderiv_tt_y : ⇑(mv_polynomial.pderiv bool.tt) y = 0,	e : bool → polynomial R := λ (i : bool), cond i polynomial.X (1 - polynomial.X)	⊢ (finset.range (n + 1)).sum (λ (ν : ℕ), (ν * (ν - 1)) • bernstein_polynomial R n ν) = (n * (n - 1)) • polynomial.X ^ 2
R : Type u_1,	_inst_1 : comm_ring R,	n : ℕ,	x : mv_polynomial bool R := mv_polynomial.X bool.tt,	y : mv_polynomial bool R := mv_polynomial.X bool.ff,	pderiv_tt_x : ⇑(mv_polynomial.pderiv bool.tt) x = 1,	pderiv_tt_y : ⇑(mv_polynomial.pderiv bool.tt) y = 0,	e : bool → polynomial R := λ (i : bool), cond i polynomial.X (1 - polynomial.X),	h : (x + y) ^ n = (x + y) ^ n	⊢ (finset.range (n + 1)).sum (λ (ν : ℕ), (ν * (ν - 1)) • bernstein_polynomial R n ν) = (n * (n - 1)) • polynomial.X ^ 2
R : Type u_1,	_inst_1 : comm_ring R,	n : ℕ,	x : mv_polynomial bool R := mv_polynomial.X bool.tt,	y : mv_polynomial bool R := mv_polynomial.X bool.ff,	pderiv_tt_x : ⇑(mv_polynomial.pderiv bool.tt) x = 1,	pderiv_tt_y : ⇑(mv_polynomial.pderiv bool.tt) y = 0,	e : bool → polynomial R := λ (i : bool), cond i polynomial.X (1 - polynomial.X),	h : ⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n) = ⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n)	⊢ (finset.range (n + 1)).sum (λ (ν : ℕ), (ν * (ν - 1)) • bernstein_polynomial R n ν) = (n * (n - 1)) • polynomial.X ^ 2
R : Type u_1,	_inst_1 : comm_ring R,	n : ℕ,	x : mv_polynomial bool R := mv_polynomial.X bool.tt,	y : mv_polynomial bool R := mv_polynomial.X bool.ff,	pderiv_tt_x : ⇑(mv_polynomial.pderiv bool.tt) x = 1,	pderiv_tt_y : ⇑(mv_polynomial.pderiv bool.tt) y = 0,	e : bool → polynomial R := λ (i : bool), cond i polynomial.X (1 - polynomial.X),	h : ⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n)) = ⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))	⊢ (finset.range (n + 1)).sum (λ (ν : ℕ), (ν * (ν - 1)) • bernstein_polynomial R n ν) = (n * (n - 1)) • polynomial.X ^ 2
R : Type u_1,	_inst_1 : comm_ring R,	n : ℕ,	x : mv_polynomial bool R := mv_polynomial.X bool.tt,	y : mv_polynomial bool R := mv_polynomial.X bool.ff,	pderiv_tt_x : ⇑(mv_polynomial.pderiv bool.tt) x = 1,	pderiv_tt_y : ⇑(mv_polynomial.pderiv bool.tt) y = 0,	e : bool → polynomial R := λ (i : bool), cond i polynomial.X (1 - polynomial.X),	h : ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) = ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n)))	⊢ (finset.range (n + 1)).sum (λ (ν : ℕ), (ν * (ν - 1)) • bernstein_polynomial R n ν) = (n * (n - 1)) • polynomial.X ^ 2
R : Type u_1,	_inst_1 : comm_ring R,	n : ℕ,	x : mv_polynomial bool R := mv_polynomial.X bool.tt,	y : mv_polynomial bool R := mv_polynomial.X bool.ff,	pderiv_tt_x : ⇑(mv_polynomial.pderiv bool.tt) x = 1,	pderiv_tt_y : ⇑(mv_polynomial.pderiv bool.tt) y = 0,	e : bool → polynomial R := λ (i : bool), cond i polynomial.X (1 - polynomial.X),	h : ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2 = ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2	⊢ (finset.range (n + 1)).sum (λ (ν : ℕ), (ν * (ν - 1)) • bernstein_polynomial R n ν) = (n * (n - 1)) • polynomial.X ^ 2
R : Type u_1,	_inst_1 : comm_ring R,	n : ℕ,	x : mv_polynomial bool R := mv_polynomial.X bool.tt,	y : mv_polynomial bool R := mv_polynomial.X bool.ff,	pderiv_tt_x : ⇑(mv_polynomial.pderiv bool.tt) x = 1,	pderiv_tt_y : ⇑(mv_polynomial.pderiv bool.tt) y = 0,	e : bool → polynomial R := λ (i : bool), cond i polynomial.X (1 - polynomial.X),	h : ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2 = ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2	⊢ ∀ (k : ℕ), ↑k * (↑(k - 1) * polynomial.X ^ (k - 1 - 1)) * (1 - polynomial.X) ^ (n - k) * ↑(n.choose k) * polynomial.X ^ 2 = (k * (k - 1)) • bernstein_polynomial R n k
R : Type u_1,	_inst_1 : comm_ring R,	n : ℕ,	x : mv_polynomial bool R := mv_polynomial.X bool.tt,	y : mv_polynomial bool R := mv_polynomial.X bool.ff,	pderiv_tt_x : ⇑(mv_polynomial.pderiv bool.tt) x = 1,	pderiv_tt_y : ⇑(mv_polynomial.pderiv bool.tt) y = 0,	e : bool → polynomial R := λ (i : bool), cond i polynomial.X (1 - polynomial.X),	h : ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2 = ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2	⊢ ↑0 * (↑(0 - 1) * polynomial.X ^ (0 - 1 - 1)) * (1 - polynomial.X) ^ (n - 0) * ↑(n.choose 0) * polynomial.X ^ 2 = (0 * (0 - 1)) • bernstein_polynomial R n 0		R : Type u_1,	_inst_1 : comm_ring R,	n : ℕ,	x : mv_polynomial bool R := mv_polynomial.X bool.tt,	y : mv_polynomial bool R := mv_polynomial.X bool.ff,	pderiv_tt_x : ⇑(mv_polynomial.pderiv bool.tt) x = 1,	pderiv_tt_y : ⇑(mv_polynomial.pderiv bool.tt) y = 0,	e : bool → polynomial R := λ (i : bool), cond i polynomial.X (1 - polynomial.X),	h : ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2 = ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2,	k : ℕ	⊢ ↑(k.succ) * (↑(k.succ - 1) * polynomial.X ^ (k.succ - 1 - 1)) * (1 - polynomial.X) ^ (n - k.succ) * ↑(n.choose k.succ) * polynomial.X ^ 2 = (k.succ * (k.succ - 1)) • bernstein_polynomial R n k.succ
R : Type u_1,	_inst_1 : comm_ring R,	n : ℕ,	x : mv_polynomial bool R := mv_polynomial.X bool.tt,	y : mv_polynomial bool R := mv_polynomial.X bool.ff,	pderiv_tt_x : ⇑(mv_polynomial.pderiv bool.tt) x = 1,	pderiv_tt_y : ⇑(mv_polynomial.pderiv bool.tt) y = 0,	e : bool → polynomial R := λ (i : bool), cond i polynomial.X (1 - polynomial.X),	h : ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2 = ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2	⊢ ↑0 * (↑(0 - 1) * polynomial.X ^ (0 - 1 - 1)) * (1 - polynomial.X) ^ (n - 0) * ↑(n.choose 0) * polynomial.X ^ 2 = (0 * (0 - 1)) • bernstein_polynomial R n 0
R : Type u_1,	_inst_1 : comm_ring R,	n : ℕ,	x : mv_polynomial bool R := mv_polynomial.X bool.tt,	y : mv_polynomial bool R := mv_polynomial.X bool.ff,	pderiv_tt_x : ⇑(mv_polynomial.pderiv bool.tt) x = 1,	pderiv_tt_y : ⇑(mv_polynomial.pderiv bool.tt) y = 0,	e : bool → polynomial R := λ (i : bool), cond i polynomial.X (1 - polynomial.X),	h : ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2 = ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2,	k : ℕ	⊢ ↑(k.succ) * (↑(k.succ - 1) * polynomial.X ^ (k.succ - 1 - 1)) * (1 - polynomial.X) ^ (n - k.succ) * ↑(n.choose k.succ) * polynomial.X ^ 2 = (k.succ * (k.succ - 1)) • bernstein_polynomial R n k.succ
R : Type u_1,	_inst_1 : comm_ring R,	n : ℕ,	x : mv_polynomial bool R := mv_polynomial.X bool.tt,	y : mv_polynomial bool R := mv_polynomial.X bool.ff,	pderiv_tt_x : ⇑(mv_polynomial.pderiv bool.tt) x = 1,	pderiv_tt_y : ⇑(mv_polynomial.pderiv bool.tt) y = 0,	e : bool → polynomial R := λ (i : bool), cond i polynomial.X (1 - polynomial.X),	h : ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2 = ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2	⊢ ↑1 * (↑(1 - 1) * polynomial.X ^ (1 - 1 - 1)) * (1 - polynomial.X) ^ (n - 1) * ↑(n.choose 1) * polynomial.X ^ 2 = (1 * (1 - 1)) • bernstein_polynomial R n 1		R : Type u_1,	_inst_1 : comm_ring R,	n : ℕ,	x : mv_polynomial bool R := mv_polynomial.X bool.tt,	y : mv_polynomial bool R := mv_polynomial.X bool.ff,	pderiv_tt_x : ⇑(mv_polynomial.pderiv bool.tt) x = 1,	pderiv_tt_y : ⇑(mv_polynomial.pderiv bool.tt) y = 0,	e : bool → polynomial R := λ (i : bool), cond i polynomial.X (1 - polynomial.X),	h : ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2 = ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2,	k : ℕ	⊢ ↑(k.succ.succ) * (↑(k.succ.succ - 1) * polynomial.X ^ (k.succ.succ - 1 - 1)) * (1 - polynomial.X) ^ (n - k.succ.succ) * ↑(n.choose k.succ.succ) * polynomial.X ^ 2 = (k.succ.succ * (k.succ.succ - 1)) • bernstein_polynomial R n k.succ.succ
R : Type u_1,	_inst_1 : comm_ring R,	n : ℕ,	x : mv_polynomial bool R := mv_polynomial.X bool.tt,	y : mv_polynomial bool R := mv_polynomial.X bool.ff,	pderiv_tt_x : ⇑(mv_polynomial.pderiv bool.tt) x = 1,	pderiv_tt_y : ⇑(mv_polynomial.pderiv bool.tt) y = 0,	e : bool → polynomial R := λ (i : bool), cond i polynomial.X (1 - polynomial.X),	h : ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2 = ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2	⊢ ↑1 * (↑(1 - 1) * polynomial.X ^ (1 - 1 - 1)) * (1 - polynomial.X) ^ (n - 1) * ↑(n.choose 1) * polynomial.X ^ 2 = (1 * (1 - 1)) • bernstein_polynomial R n 1
R : Type u_1,	_inst_1 : comm_ring R,	n : ℕ,	x : mv_polynomial bool R := mv_polynomial.X bool.tt,	y : mv_polynomial bool R := mv_polynomial.X bool.ff,	pderiv_tt_x : ⇑(mv_polynomial.pderiv bool.tt) x = 1,	pderiv_tt_y : ⇑(mv_polynomial.pderiv bool.tt) y = 0,	e : bool → polynomial R := λ (i : bool), cond i polynomial.X (1 - polynomial.X),	h : ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2 = ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2,	k : ℕ	⊢ ↑(k.succ.succ) * (↑(k.succ.succ - 1) * polynomial.X ^ (k.succ.succ - 1 - 1)) * (1 - polynomial.X) ^ (n - k.succ.succ) * ↑(n.choose k.succ.succ) * polynomial.X ^ 2 = (k.succ.succ * (k.succ.succ - 1)) • bernstein_polynomial R n k.succ.succ
R : Type u_1,	_inst_1 : comm_ring R,	n : ℕ,	x : mv_polynomial bool R := mv_polynomial.X bool.tt,	y : mv_polynomial bool R := mv_polynomial.X bool.ff,	pderiv_tt_x : ⇑(mv_polynomial.pderiv bool.tt) x = 1,	pderiv_tt_y : ⇑(mv_polynomial.pderiv bool.tt) y = 0,	e : bool → polynomial R := λ (i : bool), cond i polynomial.X (1 - polynomial.X),	h : ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2 = ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2,	k : ℕ	⊢ (↑k + 1 + 1) * (↑(k.succ.succ - 1) * polynomial.X ^ (k.succ.succ - 1 - 1)) * (1 - polynomial.X) ^ (n - k.succ.succ) * ↑(n.choose k.succ.succ) * polynomial.X ^ 2 = (k.succ.succ * (k.succ.succ - 1)) • (↑(n.choose k.succ.succ) * polynomial.X ^ k.succ.succ * (1 - polynomial.X) ^ (n - k.succ.succ))
R : Type u_1,	_inst_1 : comm_ring R,	n : ℕ,	x : mv_polynomial bool R := mv_polynomial.X bool.tt,	y : mv_polynomial bool R := mv_polynomial.X bool.ff,	pderiv_tt_x : ⇑(mv_polynomial.pderiv bool.tt) x = 1,	pderiv_tt_y : ⇑(mv_polynomial.pderiv bool.tt) y = 0,	e : bool → polynomial R := λ (i : bool), cond i polynomial.X (1 - polynomial.X),	h : ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2 = ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2,	k : ℕ	⊢ (↑k + 1 + 1) * (↑(k + 1) * polynomial.X ^ k) * (1 - polynomial.X) ^ (n - (k + 1 + 1)) * ↑(n.choose (k + 1 + 1)) * (polynomial.X * (polynomial.X * polynomial.X ^ 0)) = ↑((k + 1 + 1) * (k + 1)) * (↑(n.choose (k + 1 + 1)) * (polynomial.X * (polynomial.X * polynomial.X ^ k)) * (1 - polynomial.X) ^ (n - (k + 1 + 1)))
R : Type u_1,	_inst_1 : comm_ring R,	n : ℕ,	x : mv_polynomial bool R := mv_polynomial.X bool.tt,	y : mv_polynomial bool R := mv_polynomial.X bool.ff,	pderiv_tt_x : ⇑(mv_polynomial.pderiv bool.tt) x = 1,	pderiv_tt_y : ⇑(mv_polynomial.pderiv bool.tt) y = 0,	e : bool → polynomial R := λ (i : bool), cond i polynomial.X (1 - polynomial.X),	h : ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2 = ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2	⊢ ∀ (k : ℕ), ↑k * (↑(k - 1) * polynomial.X ^ (k - 1 - 1)) * (1 - polynomial.X) ^ (n - k) * ↑(n.choose k) * polynomial.X ^ 2 = (k * (k - 1)) • bernstein_polynomial R n k		R : Type u_1,	_inst_1 : comm_ring R,	n : ℕ,	x : mv_polynomial bool R := mv_polynomial.X bool.tt,	y : mv_polynomial bool R := mv_polynomial.X bool.ff,	pderiv_tt_x : ⇑(mv_polynomial.pderiv bool.tt) x = 1,	pderiv_tt_y : ⇑(mv_polynomial.pderiv bool.tt) y = 0,	e : bool → polynomial R := λ (i : bool), cond i polynomial.X (1 - polynomial.X),	h : ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2 = ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2,	w : ∀ (k : ℕ), ↑k * (↑(k - 1) * polynomial.X ^ (k - 1 - 1)) * (1 - polynomial.X) ^ (n - k) * ↑(n.choose k) * polynomial.X ^ 2 = (k * (k - 1)) • bernstein_polynomial R n k	⊢ (finset.range (n + 1)).sum (λ (ν : ℕ), (ν * (ν - 1)) • bernstein_polynomial R n ν) = (n * (n - 1)) • polynomial.X ^ 2
R : Type u_1,	_inst_1 : comm_ring R,	n : ℕ,	x : mv_polynomial bool R := mv_polynomial.X bool.tt,	y : mv_polynomial bool R := mv_polynomial.X bool.ff,	pderiv_tt_x : ⇑(mv_polynomial.pderiv bool.tt) x = 1,	pderiv_tt_y : ⇑(mv_polynomial.pderiv bool.tt) y = 0,	e : bool → polynomial R := λ (i : bool), cond i polynomial.X (1 - polynomial.X),	h : ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2 = ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2,	k : ℕ	⊢ (↑k + 1 + 1) * ((↑k + 1) * polynomial.X ^ k) * (1 - polynomial.X) ^ (n - (k + 1 + 1)) * ↑(n.choose (k + 1 + 1)) * (polynomial.X * (polynomial.X * polynomial.X ^ 0)) = (↑k + 1 + 1) * (↑k + 1) * (↑(n.choose (k + 1 + 1)) * (polynomial.X * (polynomial.X * polynomial.X ^ k)) * (1 - polynomial.X) ^ (n - (k + 1 + 1)))
R : Type u_1,	_inst_1 : comm_ring R,	n : ℕ,	x : mv_polynomial bool R := mv_polynomial.X bool.tt,	y : mv_polynomial bool R := mv_polynomial.X bool.ff,	pderiv_tt_x : ⇑(mv_polynomial.pderiv bool.tt) x = 1,	pderiv_tt_y : ⇑(mv_polynomial.pderiv bool.tt) y = 0,	e : bool → polynomial R := λ (i : bool), cond i polynomial.X (1 - polynomial.X),	h : ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2 = ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2,	w : ∀ (k : ℕ), ↑k * (↑(k - 1) * polynomial.X ^ (k - 1 - 1)) * (1 - polynomial.X) ^ (n - k) * ↑(n.choose k) * polynomial.X ^ 2 = (k * (k - 1)) • bernstein_polynomial R n k	⊢ (finset.range (n + 1)).sum (λ (ν : ℕ), (ν * (ν - 1)) • bernstein_polynomial R n ν) = (n * (n - 1)) • polynomial.X ^ 2
R : Type u_1,	_inst_1 : comm_ring R,	n : ℕ,	x : mv_polynomial bool R := mv_polynomial.X bool.tt,	y : mv_polynomial bool R := mv_polynomial.X bool.ff,	pderiv_tt_x : ⇑(mv_polynomial.pderiv bool.tt) x = 1,	pderiv_tt_y : ⇑(mv_polynomial.pderiv bool.tt) y = 0,	e : bool → polynomial R := λ (i : bool), cond i polynomial.X (1 - polynomial.X),	h : ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2 = ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2,	w : ∀ (k : ℕ), ↑k * (↑(k - 1) * polynomial.X ^ (k - 1 - 1)) * (1 - polynomial.X) ^ (n - k) * ↑(n.choose k) * polynomial.X ^ 2 = (k * (k - 1)) • bernstein_polynomial R n k	⊢ ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2 = ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2 = ?m_1
R : Type u_1,	_inst_1 : comm_ring R,	n : ℕ,	x : mv_polynomial bool R := mv_polynomial.X bool.tt,	y : mv_polynomial bool R := mv_polynomial.X bool.ff,	pderiv_tt_x : ⇑(mv_polynomial.pderiv bool.tt) x = 1,	pderiv_tt_y : ⇑(mv_polynomial.pderiv bool.tt) y = 0,	e : bool → polynomial R := λ (i : bool), cond i polynomial.X (1 - polynomial.X),	h : ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2 = ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2,	w : ∀ (k : ℕ), ↑k * (↑(k - 1) * polynomial.X ^ (k - 1 - 1)) * (1 - polynomial.X) ^ (n - k) * ↑(n.choose k) * polynomial.X ^ 2 = (k * (k - 1)) • bernstein_polynomial R n k	⊢ ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2 = ?m_1
R : Type u_1,	_inst_1 : comm_ring R,	n : ℕ,	x : mv_polynomial bool R := mv_polynomial.X bool.tt,	y : mv_polynomial bool R := mv_polynomial.X bool.ff,	pderiv_tt_x : ⇑(mv_polynomial.pderiv bool.tt) x = 1,	pderiv_tt_y : ⇑(mv_polynomial.pderiv bool.tt) y = 0,	e : bool → polynomial R := λ (i : bool), cond i polynomial.X (1 - polynomial.X),	h : ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2 = ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2,	w : ∀ (k : ℕ), ↑k * (↑(k - 1) * polynomial.X ^ (k - 1 - 1)) * (1 - polynomial.X) ^ (n - k) * ↑(n.choose k) * polynomial.X ^ 2 = (k * (k - 1)) • bernstein_polynomial R n k	⊢ finset.range (n + 1) = ?m_1		R : Type u_1,	_inst_1 : comm_ring R,	n : ℕ,	x : mv_polynomial bool R := mv_polynomial.X bool.tt,	y : mv_polynomial bool R := mv_polynomial.X bool.ff,	pderiv_tt_x : ⇑(mv_polynomial.pderiv bool.tt) x = 1,	pderiv_tt_y : ⇑(mv_polynomial.pderiv bool.tt) y = 0,	e : bool → polynomial R := λ (i : bool), cond i polynomial.X (1 - polynomial.X),	h : ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2 = ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2,	w : ∀ (k : ℕ), ↑k * (↑(k - 1) * polynomial.X ^ (k - 1 - 1)) * (1 - polynomial.X) ^ (n - k) * ↑(n.choose k) * polynomial.X ^ 2 = (k * (k - 1)) • bernstein_polynomial R n k,	x_1 : ℕ,	H : x_1 ∈ ?m_1	⊢ ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) (x ^ x_1 * y ^ (n - x_1) * ↑(n.choose x_1)))) * polynomial.X ^ 2 = ?m_2 x_1
R : Type u_1,	_inst_1 : comm_ring R,	n : ℕ,	x : mv_polynomial bool R := mv_polynomial.X bool.tt,	y : mv_polynomial bool R := mv_polynomial.X bool.ff,	pderiv_tt_x : ⇑(mv_polynomial.pderiv bool.tt) x = 1,	pderiv_tt_y : ⇑(mv_polynomial.pderiv bool.tt) y = 0,	e : bool → polynomial R := λ (i : bool), cond i polynomial.X (1 - polynomial.X),	h : ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2 = ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2,	w : ∀ (k : ℕ), ↑k * (↑(k - 1) * polynomial.X ^ (k - 1 - 1)) * (1 - polynomial.X) ^ (n - k) * ↑(n.choose k) * polynomial.X ^ 2 = (k * (k - 1)) • bernstein_polynomial R n k	⊢ (finset.range (n + 1)).sum (λ (x_1 : ℕ), ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) (x ^ x_1 * y ^ (n - x_1) * ↑(n.choose x_1)))) * polynomial.X ^ 2) = ?m_1
R : Type u_1,	_inst_1 : comm_ring R,	n : ℕ,	x : mv_polynomial bool R := mv_polynomial.X bool.tt,	y : mv_polynomial bool R := mv_polynomial.X bool.ff,	pderiv_tt_x : ⇑(mv_polynomial.pderiv bool.tt) x = 1,	pderiv_tt_y : ⇑(mv_polynomial.pderiv bool.tt) y = 0,	e : bool → polynomial R := λ (i : bool), cond i polynomial.X (1 - polynomial.X),	h : ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2 = ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2,	w : ∀ (k : ℕ), ↑k * (↑(k - 1) * polynomial.X ^ (k - 1 - 1)) * (1 - polynomial.X) ^ (n - k) * ↑(n.choose k) * polynomial.X ^ 2 = (k * (k - 1)) • bernstein_polynomial R n k,	x_1 : ℕ,	H : x_1 ∈ finset.range (n + 1)	⊢ ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) (x ^ x_1 * y ^ (n - x_1) * ↑(n.choose x_1)))) * polynomial.X ^ 2 = ?m_1 x_1
R : Type u_1,	_inst_1 : comm_ring R,	n : ℕ,	x : mv_polynomial bool R := mv_polynomial.X bool.tt,	y : mv_polynomial bool R := mv_polynomial.X bool.ff,	pderiv_tt_x : ⇑(mv_polynomial.pderiv bool.tt) x = 1,	pderiv_tt_y : ⇑(mv_polynomial.pderiv bool.tt) y = 0,	e : bool → polynomial R := λ (i : bool), cond i polynomial.X (1 - polynomial.X),	w : ∀ (k : ℕ), ↑k * (↑(k - 1) * polynomial.X ^ (k - 1 - 1)) * (1 - polynomial.X) ^ (n - k) * ↑(n.choose k) * polynomial.X ^ 2 = (k * (k - 1)) • bernstein_polynomial R n k,	h : (finset.range (n + 1)).sum (λ (x_1 : ℕ), ↑x_1 * ↑(x_1 - 1) * bernstein_polynomial R n x_1) = ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2	⊢ (finset.range (n + 1)).sum (λ (ν : ℕ), (ν * (ν - 1)) • bernstein_polynomial R n ν) = (n * (n - 1)) • polynomial.X ^ 2
R : Type u_1,	_inst_1 : comm_ring R,	n : ℕ,	x : mv_polynomial bool R := mv_polynomial.X bool.tt,	y : mv_polynomial bool R := mv_polynomial.X bool.ff,	pderiv_tt_x : ⇑(mv_polynomial.pderiv bool.tt) x = 1,	pderiv_tt_y : ⇑(mv_polynomial.pderiv bool.tt) y = 0,	e : bool → polynomial R := λ (i : bool), cond i polynomial.X (1 - polynomial.X),	w : ∀ (k : ℕ), ↑k * (↑(k - 1) * polynomial.X ^ (k - 1 - 1)) * (1 - polynomial.X) ^ (n - k) * ↑(n.choose k) * polynomial.X ^ 2 = (k * (k - 1)) • bernstein_polynomial R n k,	h : (finset.range (n + 1)).sum (λ (x_1 : ℕ), ↑x_1 * ↑(x_1 - 1) * bernstein_polynomial R n x_1) = ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2	⊢ (finset.range (n + 1)).sum (λ (x_1 : ℕ), ↑x_1 * ↑(x_1 - 1) * bernstein_polynomial R n x_1) = ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2 = ?m_1
R : Type u_1,	_inst_1 : comm_ring R,	n : ℕ,	x : mv_polynomial bool R := mv_polynomial.X bool.tt,	y : mv_polynomial bool R := mv_polynomial.X bool.ff,	pderiv_tt_x : ⇑(mv_polynomial.pderiv bool.tt) x = 1,	pderiv_tt_y : ⇑(mv_polynomial.pderiv bool.tt) y = 0,	e : bool → polynomial R := λ (i : bool), cond i polynomial.X (1 - polynomial.X),	w : ∀ (k : ℕ), ↑k * (↑(k - 1) * polynomial.X ^ (k - 1 - 1)) * (1 - polynomial.X) ^ (n - k) * ↑(n.choose k) * polynomial.X ^ 2 = (k * (k - 1)) • bernstein_polynomial R n k,	h : (finset.range (n + 1)).sum (λ (x_1 : ℕ), ↑x_1 * ↑(x_1 - 1) * bernstein_polynomial R n x_1) = ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2	⊢ ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2 = ?m_1
R : Type u_1,	_inst_1 : comm_ring R,	n : ℕ,	x : mv_polynomial bool R := mv_polynomial.X bool.tt,	y : mv_polynomial bool R := mv_polynomial.X bool.ff,	pderiv_tt_x : ⇑(mv_polynomial.pderiv bool.tt) x = 1,	pderiv_tt_y : ⇑(mv_polynomial.pderiv bool.tt) y = 0,	e : bool → polynomial R := λ (i : bool), cond i polynomial.X (1 - polynomial.X),	w : ∀ (k : ℕ), ↑k * (↑(k - 1) * polynomial.X ^ (k - 1 - 1)) * (1 - polynomial.X) ^ (n - k) * ↑(n.choose k) * polynomial.X ^ 2 = (k * (k - 1)) • bernstein_polynomial R n k,	h : (finset.range (n + 1)).sum (λ (x_1 : ℕ), ↑x_1 * ↑(x_1 - 1) * bernstein_polynomial R n x_1) = ⇑(mv_polynomial.aeval e) (⇑(mv_polynomial.pderiv bool.tt) (⇑(mv_polynomial.pderiv bool.tt) ((x + y) ^ n))) * polynomial.X ^ 2	⊢ ⇑(mv_polynomial.aeval e) ((0 * (1 + 0) + ↑n * (0 + ⇑(mv_polynomial.pderiv bool.tt) 0)) * (x + y) ^ (n - 1) + ↑n * (1 + 0) * (↑(n - 1) * (1 + 0) * (x + y) ^ (n - 1 - 1))) * polynomial.X ^ 2 = ?m_1
R : Type u_1,	_inst_1 : comm_ring R,	n : ℕ,	x : mv_polynomial bool R := mv_polynomial.X bool.tt,	y : mv_polynomial bool R := mv_polynomial.X bool.ff,	pderiv_tt_x : ⇑(mv_polynomial.pderiv bool.tt) x = 1,	pderiv_tt_y : ⇑(mv_polynomial.pderiv bool.tt) y = 0,	e : bool → polynomial R := λ (i : bool), cond i polynomial.X (1 - polynomial.X),	w : ∀ (k : ℕ), ↑k * (↑(k - 1) * polynomial.X ^ (k - 1 - 1)) * (1 - polynomial.X) ^ (n - k) * ↑(n.choose k) * polynomial.X ^ 2 = (k * (k - 1)) • bernstein_polynomial R n k,	h : (finset.range (n + 1)).sum (λ (x_1 : ℕ), ↑x_1 * ↑(x_1 - 1) * bernstein_polynomial R n x_1) = ↑n * ↑(n - 1) * polynomial.X ^ 2	⊢ (finset.range (n + 1)).sum (λ (ν : ℕ), (ν * (ν - 1)) • bernstein_polynomial R n ν) = (n * (n - 1)) • polynomial.X ^ 2
⊢ bernstein_polynomial ℤ 3 2 = 3 * polynomial.X ^ 2 - 3 * polynomial.X ^ 3
⊢ 3 * polynomial.X ^ 2 * (1 - polynomial.X) = 3 * polynomial.X ^ 2 - 3 * polynomial.X ^ 3
R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ,	h : ν ≤ n	⊢ (bernstein_polynomial R n ν).comp (1 - polynomial.X) = bernstein_polynomial R n (n - ν)
R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ,	h : ν ≤ n	⊢ (↑(n.choose ν) * polynomial.X ^ ν * (1 - polynomial.X) ^ (n - ν)).comp (1 - polynomial.X) = ↑(n.choose (n - ν)) * polynomial.X ^ (n - ν) * (1 - polynomial.X) ^ (n - (n - ν))
R : Type u_1,	_inst_1 : integral_domain R,	_inst_2 : gcd_monoid R,	a : R,	p q : polynomial R,	h : ⇑polynomial.C a ∣ p - q	⊢ gcd_monoid.gcd a p.content = gcd_monoid.gcd a q.content
R : Type u_1,	_inst_1 : integral_domain R,	_inst_2 : gcd_monoid R,	a : R,	p q : polynomial R,	h : ⇑polynomial.C a ∣ p - q	⊢ gcd_monoid.gcd a ((finset.range (linear_order.max p.nat_degree q.nat_degree).succ).gcd p.coeff) = gcd_monoid.gcd a q.content
R : Type u_1,	_inst_1 : integral_domain R,	_inst_2 : gcd_monoid R,	a : R,	p q : polynomial R,	h : ⇑polynomial.C a ∣ p - q	⊢ gcd_monoid.gcd a ((finset.range (linear_order.max p.nat_degree q.nat_degree).succ).gcd p.coeff) = gcd_monoid.gcd a ((finset.range (linear_order.max p.nat_degree q.nat_degree).succ).gcd q.coeff)
R : Type u_1,	_inst_1 : integral_domain R,	_inst_2 : gcd_monoid R,	a : R,	p q : polynomial R,	h : ⇑polynomial.C a ∣ p - q	⊢ ∀ (x : ℕ), x ∈ finset.range (linear_order.max p.nat_degree q.nat_degree).succ → a ∣ p.coeff x - q.coeff x
R : Type u_1,	_inst_1 : integral_domain R,	_inst_2 : gcd_monoid R,	a : R,	p q : polynomial R,	h : ⇑polynomial.C a ∣ p - q,	x : ℕ,	hx : x ∈ finset.range (linear_order.max p.nat_degree q.nat_degree).succ	⊢ a ∣ p.coeff x - q.coeff x
R : Type u_1,	_inst_1 : integral_domain R,	_inst_2 : gcd_monoid R,	a : R,	p q : polynomial R,	x : ℕ,	hx : x ∈ finset.range (linear_order.max p.nat_degree q.nat_degree).succ,	w : polynomial R,	hw : p - q = ⇑polynomial.C a * w	⊢ a ∣ p.coeff x - q.coeff x
R : Type u_1,	_inst_1 : integral_domain R,	_inst_2 : gcd_monoid R,	a : R,	p q : polynomial R,	x : ℕ,	hx : x ∈ finset.range (linear_order.max p.nat_degree q.nat_degree).succ,	w : polynomial R,	hw : p - q = ⇑polynomial.C a * w	⊢ p.coeff x - q.coeff x = a * w.coeff x
σ : Type u_1,	R : Type u_3,	_inst_1 : comm_semiring R,	i : σ	⊢ (mv_polynomial.X i).is_homogeneous 1
σ : Type u_1,	R : Type u_3,	_inst_1 : comm_semiring R,	i : σ	⊢ ∑ (i_1 : σ) in (finsupp.single i 1).support, ⇑(finsupp.single i 1) i_1 = 1
σ : Type u_1,	R : Type u_3,	_inst_1 : comm_semiring R,	i : σ	⊢ has_coe_to_fun.coe (finsupp.single i 1) i = 1
R : Type u_3,	_inst_3 : comm_ring R,	p : polynomial R,	s : R	⊢ (scale_roots p s).monic ↔ p.monic
R : Type u_1,	_inst_1 : comm_semiring R,	φ ψ : power_series R	⊢ φ.order + ψ.order ≤ (φ * ψ).order
R : Type u_1,	_inst_1 : comm_semiring R,	φ ψ : power_series R,	n : ℕ,	hn : ↑n < φ.order + ψ.order	⊢ ⇑(power_series.coeff R n) (φ * ψ) = 0
R : Type u_1,	_inst_1 : comm_semiring R,	φ ψ : power_series R	⊢ ∀ (i : ℕ), ↑i < φ.order + ψ.order → ⇑(power_series.coeff R i) (φ * ψ) = 0
R : Type u_1,	_inst_1 : comm_semiring R,	φ ψ : power_series R,	n : ℕ,	hn : ↑n < φ.order + ψ.order	⊢ ∀ (x : ℕ × ℕ), x ∈ finset.nat.antidiagonal n → ⇑(power_series.coeff R x.fst) φ * ⇑(power_series.coeff R x.snd) ψ = 0
R : Type u_1,	_inst_1 : comm_semiring R,	φ ψ : power_series R,	n : ℕ,	hn : ↑n < φ.order + ψ.order,	i j : ℕ,	hij : (i, j) ∈ finset.nat.antidiagonal n	⊢ ⇑(power_series.coeff R (i, j).fst) φ * ⇑(power_series.coeff R (i, j).snd) ψ = 0
R : Type u_1,	_inst_1 : comm_semiring R,	φ ψ : power_series R,	n : ℕ,	hn : ↑n < φ.order + ψ.order,	i j : ℕ,	hij : (i, j) ∈ finset.nat.antidiagonal n,	hi : ↑i < φ.order	⊢ ⇑(power_series.coeff R (i, j).fst) φ * ⇑(power_series.coeff R (i, j).snd) ψ = 0		R : Type u_1,	_inst_1 : comm_semiring R,	φ ψ : power_series R,	n : ℕ,	hn : ↑n < φ.order + ψ.order,	i j : ℕ,	hij : (i, j) ∈ finset.nat.antidiagonal n,	hi : ¬↑i < φ.order	⊢ ⇑(power_series.coeff R (i, j).fst) φ * ⇑(power_series.coeff R (i, j).snd) ψ = 0
R : Type u_1,	_inst_1 : comm_semiring R,	φ ψ : power_series R,	n : ℕ,	hn : ↑n < φ.order + ψ.order,	i j : ℕ,	hij : (i, j) ∈ finset.nat.antidiagonal n,	hi : ↑i < φ.order	⊢ ⇑(power_series.coeff R (i, j).fst) φ * ⇑(power_series.coeff R (i, j).snd) ψ = 0
R : Type u_1,	_inst_1 : comm_semiring R,	φ ψ : power_series R,	n : ℕ,	hn : ↑n < φ.order + ψ.order,	i j : ℕ,	hij : (i, j) ∈ finset.nat.antidiagonal n,	hi : ¬↑i < φ.order	⊢ ⇑(power_series.coeff R (i, j).fst) φ * ⇑(power_series.coeff R (i, j).snd) ψ = 0
R : Type u_1,	_inst_1 : comm_semiring R,	φ ψ : power_series R,	n : ℕ,	hn : ↑n < φ.order + ψ.order,	i j : ℕ,	hij : (i, j) ∈ finset.nat.antidiagonal n,	hi : ¬↑i < φ.order,	hj : ↑j < ψ.order	⊢ ⇑(power_series.coeff R (i, j).fst) φ * ⇑(power_series.coeff R (i, j).snd) ψ = 0		R : Type u_1,	_inst_1 : comm_semiring R,	φ ψ : power_series R,	n : ℕ,	hn : ↑n < φ.order + ψ.order,	i j : ℕ,	hij : (i, j) ∈ finset.nat.antidiagonal n,	hi : ¬↑i < φ.order,	hj : ¬↑j < ψ.order	⊢ ⇑(power_series.coeff R (i, j).fst) φ * ⇑(power_series.coeff R (i, j).snd) ψ = 0
R : Type u_1,	_inst_1 : comm_semiring R,	φ ψ : power_series R,	n : ℕ,	hn : ↑n < φ.order + ψ.order,	i j : ℕ,	hij : (i, j) ∈ finset.nat.antidiagonal n,	hi : ¬↑i < φ.order,	hj : ↑j < ψ.order	⊢ ⇑(power_series.coeff R (i, j).fst) φ * ⇑(power_series.coeff R (i, j).snd) ψ = 0
R : Type u_1,	_inst_1 : comm_semiring R,	φ ψ : power_series R,	n : ℕ,	hn : ↑n < φ.order + ψ.order,	i j : ℕ,	hij : (i, j) ∈ finset.nat.antidiagonal n,	hj : ψ.order ≤ ↑j,	hi : φ.order ≤ ↑i	⊢ ⇑(power_series.coeff R (i, j).fst) φ * ⇑(power_series.coeff R (i, j).snd) ψ = 0
R : Type u_1,	_inst_1 : comm_semiring R,	φ ψ : power_series R,	n : ℕ,	hn : ↑n < φ.order + ψ.order,	i j : ℕ,	hij : (i, j) ∈ finset.nat.antidiagonal n,	hi : ¬↑i < φ.order,	hj : ¬↑j < ψ.order	⊢ ⇑(power_series.coeff R (i, j).fst) φ * ⇑(power_series.coeff R (i, j).snd) ψ = 0
R : Type u_1,	_inst_1 : comm_semiring R,	φ ψ : power_series R,	n : ℕ,	hn : ↑n < φ.order + ψ.order,	i j : ℕ,	hj : ψ.order ≤ ↑j,	hi : φ.order ≤ ↑i,	hij : (i, j).fst + (i, j).snd = n	⊢ ⇑(power_series.coeff R (i, j).fst) φ * ⇑(power_series.coeff R (i, j).snd) ψ = 0
R : Type u_1,	_inst_1 : comm_semiring R,	φ ψ : power_series R,	n : ℕ,	hn : ↑n < φ.order + ψ.order,	i j : ℕ,	hj : ψ.order ≤ ↑j,	hi : φ.order ≤ ↑i,	hij : (i, j).fst + (i, j).snd = n	⊢ false
R : Type u_1,	_inst_1 : comm_semiring R,	φ ψ : power_series R,	n : ℕ,	hn : ↑n < φ.order + ψ.order,	i j : ℕ,	hj : ψ.order ≤ ↑j,	hi : φ.order ≤ ↑i,	hij : (i, j).fst + (i, j).snd = n	⊢ ↑n = ↑i + ↑j
R : Type u_1,	_inst_1 : comm_semiring R,	n : ℕ,	a : R,	h : a ≠ 0	⊢ (⇑(power_series.monomial R n) a).order = ↑n
R : Type u_2,	_inst_1 : comm_semiring R	⊢ ↑1 = 1
R : Type u_2,	_inst_1 : comm_semiring R,	this : ↑(⇑(polynomial.monomial 0) 1) = ⇑(power_series.monomial R 0) 1	⊢ ↑1 = 1
σ : Type u_1,	R : Type u_2,	_inst_1 : semiring R,	n : σ →₀ ℕ,	φ : mv_power_series σ R,	a : R	⊢ ⇑(mv_power_series.coeff R n) (⇑(mv_power_series.C σ R) a * φ) = a * ⇑(mv_power_series.coeff R n) φ
M : Type u_1,	_inst_1 : comm_monoid M,	k : ℕ,	ζ : M,	hk : 0 < k,	h1 : ζ ^ k = 1,	h : ∀ (l : ℕ), 0 < l → l < k → ζ ^ l ≠ 1	⊢ is_primitive_root ζ k
M : Type u_1,	_inst_1 : comm_monoid M,	k : ℕ,	ζ : M,	hk : 0 < k,	h1 : ζ ^ k = 1,	h : ∀ (l : ℕ), 0 < l → l < k → ζ ^ l ≠ 1	⊢ ∀ (l : ℕ), ζ ^ l = 1 → k ∣ l
M : Type u_1,	_inst_1 : comm_monoid M,	k : ℕ,	ζ : M,	hk : 0 < k,	h1 : ζ ^ k = 1,	h : ∀ (l : ℕ), 0 < l → l < k → ζ ^ l ≠ 1,	l : ℕ,	hl : ζ ^ l = 1	⊢ k ∣ l
M : Type u_1,	_inst_1 : comm_monoid M,	k : ℕ,	ζ : M,	hk : 0 < k,	h1 : ζ ^ k = 1,	h : ∀ (l : ℕ), 0 < l → l < k → ζ ^ l ≠ 1,	l : ℕ,	hl : ζ ^ l = 1,	this : k.gcd l = k	⊢ k ∣ k.gcd l
M : Type u_1,	_inst_1 : comm_monoid M,	k : ℕ,	ζ : M,	hk : 0 < k,	h1 : ζ ^ k = 1,	h : ∀ (l : ℕ), 0 < l → l < k → ζ ^ l ≠ 1,	l : ℕ,	hl : ζ ^ l = 1,	this : k.gcd l = k	⊢ k ∣ k.gcd l		M : Type u_1,	_inst_1 : comm_monoid M,	k : ℕ,	ζ : M,	hk : 0 < k,	h1 : ζ ^ k = 1,	h : ∀ (l : ℕ), 0 < l → l < k → ζ ^ l ≠ 1,	l : ℕ,	hl : ζ ^ l = 1	⊢ k.gcd l = k
M : Type u_1,	_inst_1 : comm_monoid M,	k : ℕ,	ζ : M,	hk : 0 < k,	h1 : ζ ^ k = 1,	h : ∀ (l : ℕ), 0 < l → l < k → ζ ^ l ≠ 1,	l : ℕ,	hl : ζ ^ l = 1	⊢ k ∣ k.gcd l
M : Type u_1,	_inst_1 : comm_monoid M,	k : ℕ,	ζ : M,	hk : 0 < k,	h1 : ζ ^ k = 1,	h : ∀ (l : ℕ), 0 < l → l < k → ζ ^ l ≠ 1,	l : ℕ,	hl : ζ ^ l = 1	⊢ k.gcd l = k
M : Type u_1,	_inst_1 : comm_monoid M,	k : ℕ,	ζ : M,	hk : 0 < k,	h1 : ζ ^ k = 1,	h : ∀ (l : ℕ), 0 < l → l < k → ζ ^ l ≠ 1,	l : ℕ,	hl : ζ ^ l = 1	⊢ k.gcd l ≤ k ∧ ¬k.gcd l < k
M : Type u_1,	_inst_1 : comm_monoid M,	k : ℕ,	ζ : M,	hk : 0 < k,	h1 : ζ ^ k = 1,	h : ∀ (l : ℕ), 0 < l → l < k → ζ ^ l ≠ 1,	l : ℕ,	hl : ζ ^ l = 1,	h' : k.gcd l < k	⊢ false
M : Type u_1,	_inst_1 : comm_monoid M,	k : ℕ,	ζ : M,	hk : 0 < k,	h1 : ζ ^ k = 1,	h : ∀ (l : ℕ), 0 < l → l < k → ζ ^ l ≠ 1,	l : ℕ,	hl : ζ ^ l = 1	⊢ ¬k.gcd l < k
M : Type u_1,	_inst_1 : comm_monoid M,	k : ℕ,	ζ : M,	hk : 0 < k,	h1 : ζ ^ k = 1,	h : ∀ (l : ℕ), 0 < l → l < k → ζ ^ l ≠ 1,	l : ℕ,	hl : ζ ^ l = 1,	h' : k.gcd l < k	⊢ ζ ^ k.gcd l = 1
G : Type u_3,	_inst_3 : comm_group G,	k : ℕ,	ζ : G,	h : is_primitive_root ζ k,	i : ℤ,	hi : i.gcd ↑k = 1	⊢ is_primitive_root (ζ ^ i) k
G : Type u_3,	_inst_3 : comm_group G,	k : ℕ,	ζ : G,	h : is_primitive_root ζ k,	i : ℤ,	hi : i.gcd ↑k = 1,	h0 : 0 ≤ i	⊢ is_primitive_root (ζ ^ i) k
G : Type u_3,	_inst_3 : comm_group G,	k : ℕ,	ζ : G,	h : is_primitive_root ζ k,	i : ℕ,	hi : ↑i.gcd ↑k = 1	⊢ is_primitive_root (ζ ^ ↑i) k
G : Type u_3,	_inst_3 : comm_group G,	k : ℕ,	ζ : G,	h : is_primitive_root ζ k,	i : ℤ,	hi : i.gcd ↑k = 1,	h0 : 0 ≤ i	⊢ is_primitive_root (ζ ^ i) k		G : Type u_3,	_inst_3 : comm_group G,	k : ℕ,	ζ : G,	h : is_primitive_root ζ k,	i : ℤ,	hi : i.gcd ↑k = 1,	h0 : ¬0 ≤ i	⊢ is_primitive_root (ζ ^ i) k
G : Type u_3,	_inst_3 : comm_group G,	k : ℕ,	ζ : G,	h : is_primitive_root ζ k,	i : ℕ,	hi : ↑i.gcd ↑k = 1	⊢ is_primitive_root (ζ ^ i) k
G : Type u_3,	_inst_3 : comm_group G,	k : ℕ,	ζ : G,	h : is_primitive_root ζ k,	i : ℤ,	hi : i.gcd ↑k = 1,	h0 : ¬0 ≤ i	⊢ 0 ≤ -i
G : Type u_3,	_inst_3 : comm_group G,	k : ℕ,	ζ : G,	h : is_primitive_root ζ k,	i : ℤ,	hi : i.gcd ↑k = 1,	h0 : ¬0 ≤ i	⊢ is_primitive_root (ζ ^ i) k
G : Type u_3,	_inst_3 : comm_group G,	k : ℕ,	ζ : G,	h : is_primitive_root ζ k,	i : ℤ,	hi : i.gcd ↑k = 1,	h0 : i < 0	⊢ i ≤ 0
G : Type u_3,	_inst_3 : comm_group G,	k : ℕ,	ζ : G,	h : is_primitive_root ζ k,	i : ℤ,	hi : i.gcd ↑k = 1,	h0 : ¬0 ≤ i	⊢ 0 ≤ -i		G : Type u_3,	_inst_3 : comm_group G,	k : ℕ,	ζ : G,	h : is_primitive_root ζ k,	i : ℤ,	hi : i.gcd ↑k = 1,	h0 : ¬0 ≤ i,	this : 0 ≤ -i	⊢ is_primitive_root (ζ ^ i) k
G : Type u_3,	_inst_3 : comm_group G,	k : ℕ,	ζ : G,	h : is_primitive_root ζ k,	i : ℤ,	hi : i.gcd ↑k = 1,	h0 : ¬0 ≤ i,	this : 0 ≤ -i	⊢ is_primitive_root (ζ ^ i) k
G : Type u_3,	_inst_3 : comm_group G,	k : ℕ,	ζ : G,	h : is_primitive_root ζ k,	i : ℤ,	hi : i.gcd ↑k = 1,	h0 : ¬0 ≤ i,	i' : ℕ,	hi' : ↑i' = -i	⊢ is_primitive_root (ζ ^ i) k
G : Type u_3,	_inst_3 : comm_group G,	k : ℕ,	ζ : G,	h : is_primitive_root ζ k,	i : ℤ,	hi : i.gcd ↑k = 1,	h0 : ¬0 ≤ i,	i' : ℕ,	hi' : ↑i' = -i	⊢ is_primitive_root (ζ ^ i') k
G : Type u_3,	_inst_3 : comm_group G,	k : ℕ,	ζ : G,	h : is_primitive_root ζ k,	i : ℤ,	hi : i.gcd ↑k = 1,	h0 : ¬0 ≤ i,	i' : ℕ,	hi' : ↑i' = -i	⊢ i'.coprime k
G : Type u_3,	_inst_3 : comm_group G,	k : ℕ,	ζ : G,	h : is_primitive_root ζ k,	i : ℤ,	h0 : ¬0 ≤ i,	i' : ℕ,	hi' : ↑i' = -i,	hi : ↑i'.nat_abs.gcd ↑k.nat_abs = 1	⊢ i'.coprime k
R : Type u_5,	_inst_5 : integral_domain R,	ζ : R,	h : is_primitive_root ζ 2	⊢ ζ = -1
R : Type u_5,	_inst_5 : integral_domain R,	ζ : R,	h : is_primitive_root ζ 2	⊢ ¬ζ ^ 1 = 1
R : Type u_5,	_inst_5 : integral_domain R,	ζ : R,	h : is_primitive_root ζ 2	⊢ ¬ζ ^ 1 = 1
R : Type u_5,	_inst_5 : integral_domain R,	ζ : R,	h : is_primitive_root ζ 2	⊢ 0 < 1
R : Type u_5,	_inst_5 : integral_domain R,	ζ : R,	h : is_primitive_root ζ 2	⊢ 1 < 2
R : Type u_5,	_inst_5 : integral_domain R,	ζ : R,	h : is_primitive_root ζ 2	⊢ ¬ζ = 1
R : Type u_5,	_inst_5 : integral_domain R,	ζ : R,	h : is_primitive_root ζ 2	⊢ ¬ζ = 1		R : Type u_5,	_inst_5 : integral_domain R,	ζ : R,	h : is_primitive_root ζ 2	⊢ ζ ^ 2 = 1 ^ 2
R : Type u_5,	_inst_5 : integral_domain R,	ζ : R,	h : is_primitive_root ζ 2	⊢ ζ ^ 2 = 1 ^ 2
R : Type u_5,	_inst_5 : integral_domain R,	k : ℕ+,	ζ ξ : units R,	h : is_primitive_root ζ ↑k,	hξ : ξ ∈ roots_of_unity k R	⊢ ∃ (i : ℕ) (hi : i < ↑k), ζ ^ i = ξ
R : Type u_5,	_inst_5 : integral_domain R,	k : ℕ+,	ζ ξ : units R,	h : is_primitive_root ζ ↑k,	hξ : ξ ∈ roots_of_unity k R	⊢ ∃ (n : ℤ), ζ ^ n = ξ
R : Type u_5,	_inst_5 : integral_domain R,	k : ℕ+,	ζ : units R,	h : is_primitive_root ζ ↑k,	n : ℤ,	hξ : ζ ^ n ∈ roots_of_unity k R	⊢ 0 < ↑k
R : Type u_5,	_inst_5 : integral_domain R,	k : ℕ+,	ζ : units R,	h : is_primitive_root ζ ↑k,	n : ℤ,	hξ : ζ ^ n ∈ roots_of_unity k R	⊢ ∃ (i : ℕ) (hi : i < ↑k), ζ ^ i = ζ ^ n
R : Type u_5,	_inst_5 : integral_domain R,	k : ℕ+,	ζ : units R,	h : is_primitive_root ζ ↑k,	n : ℤ,	hξ : ζ ^ n ∈ roots_of_unity k R,	hk0 : 0 < ↑k	⊢ ∃ (i : ℕ) (hi : i < ↑k), ζ ^ i = ζ ^ n
R : Type u_5,	_inst_5 : integral_domain R,	k : ℕ+,	ζ : units R,	h : is_primitive_root ζ ↑k,	n : ℤ,	hξ : ζ ^ n ∈ roots_of_unity k R,	hk0 : 0 < ↑k,	i : ℤ := n % ↑k	⊢ ∃ (i : ℕ) (hi : i < ↑k), ζ ^ i = ζ ^ n
R : Type u_5,	_inst_5 : integral_domain R,	k : ℕ+,	ζ : units R,	h : is_primitive_root ζ ↑k,	n : ℤ,	hξ : ζ ^ n ∈ roots_of_unity k R,	hk0 : 0 < ↑k,	i : ℤ := n % ↑k,	hi0 : 0 ≤ i	⊢ ∃ (i : ℕ) (hi : i < ↑k), ζ ^ i = ζ ^ n
R : Type u_5,	_inst_5 : integral_domain R,	k : ℕ+,	ζ : units R,	h : is_primitive_root ζ ↑k,	n : ℤ,	hξ : ζ ^ n ∈ roots_of_unity k R,	hk0 : 0 < ↑k,	i : ℤ := n % ↑k,	i₀ : ℕ,	hi₀ : ↑i₀ = i	⊢ ∃ (i : ℕ) (hi : i < ↑k), ζ ^ i = ζ ^ n
R : Type u_5,	_inst_5 : integral_domain R,	k : ℕ+,	ζ : units R,	h : is_primitive_root ζ ↑k,	n : ℤ,	hξ : ζ ^ n ∈ roots_of_unity k R,	hk0 : 0 < ↑k,	i : ℤ := n % ↑k,	i₀ : ℕ,	hi₀ : ↑i₀ = i	⊢ ↑i₀ < ↑↑k
R : Type u_5,	_inst_5 : integral_domain R,	k : ℕ+,	ζ : units R,	h : is_primitive_root ζ ↑k,	n : ℤ,	hξ : ζ ^ n ∈ roots_of_unity k R,	hk0 : 0 < ↑k,	i : ℤ := n % ↑k,	i₀ : ℕ,	hi₀ : ↑i₀ = i	⊢ i < ↑↑k
R : Type u_5,	_inst_5 : integral_domain R,	k : ℕ+,	ζ : units R,	h : is_primitive_root ζ ↑k,	n : ℤ,	hξ : ζ ^ n ∈ roots_of_unity k R,	hk0 : 0 < ↑k,	i : ℤ := n % ↑k,	i₀ : ℕ,	hi₀ : ↑i₀ = i	⊢ i₀ < ↑k		R : Type u_5,	_inst_5 : integral_domain R,	k : ℕ+,	ζ : units R,	h : is_primitive_root ζ ↑k,	n : ℤ,	hξ : ζ ^ n ∈ roots_of_unity k R,	hk0 : 0 < ↑k,	i : ℤ := n % ↑k,	i₀ : ℕ,	hi₀ : ↑i₀ = i	⊢ ζ ^ i₀ = ζ ^ n
R : Type u_5,	_inst_5 : integral_domain R,	k : ℕ+,	ζ : units R,	h : is_primitive_root ζ ↑k,	n : ℤ,	hξ : ζ ^ n ∈ roots_of_unity k R,	hk0 : 0 < ↑k,	i : ℤ := n % ↑k,	i₀ : ℕ,	hi₀ : ↑i₀ = i	⊢ i₀ < ↑k
R : Type u_5,	_inst_5 : integral_domain R,	k : ℕ+,	ζ : units R,	h : is_primitive_root ζ ↑k,	n : ℤ,	hξ : ζ ^ n ∈ roots_of_unity k R,	hk0 : 0 < ↑k,	i : ℤ := n % ↑k,	i₀ : ℕ,	hi₀ : ↑i₀ = i,	aux : ζ ^ ↑↑k = 1	⊢ ζ ^ i₀ = ζ ^ n
R : Type u_5,	_inst_5 : integral_domain R,	k : ℕ+,	ζ : units R,	h : is_primitive_root ζ ↑k,	n : ℤ,	hξ : ζ ^ n ∈ roots_of_unity k R,	hk0 : 0 < ↑k,	i : ℤ := n % ↑k,	i₀ : ℕ,	hi₀ : ↑i₀ = i	⊢ ζ ^ i₀ = ζ ^ n
R : Type u_5,	_inst_5 : integral_domain R,	k : ℕ+,	ζ : units R,	h : is_primitive_root ζ ↑k,	n : ℤ,	hξ : ζ ^ n ∈ roots_of_unity k R,	hk0 : 0 < ↑k,	i : ℤ := n % ↑k,	i₀ : ℕ,	hi₀ : ↑i₀ = i,	aux : ζ ^ ↑k = 1	⊢ ζ ^ i₀ = ζ ^ n
M : Type u_1,	_inst_1 : comm_monoid M,	k l : ℕ+,	h : k ∣ l	⊢ roots_of_unity k M ≤ roots_of_unity l M
M : Type u_1,	_inst_1 : comm_monoid M,	k d : ℕ+	⊢ roots_of_unity k M ≤ roots_of_unity (k * d) M
M : Type u_1,	_inst_1 : comm_monoid M,	k d : ℕ+,	ζ : units M,	h : ζ ∈ roots_of_unity k M	⊢ ζ ∈ roots_of_unity (k * d) M
R : Type u_1,	_inst_1 : ring R,	M : Type u_2,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	N : Type u_3,	_inst_4 : add_comm_group N,	_inst_5 : module R N,	_inst_6 : is_simple_module R M,	f : M →ₗ[R] N	⊢ f.ker = ⊥ ∨ f.ker = ⊤
R : Type u_1,	_inst_1 : ring R,	M : Type u_2,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_4 : is_simple_module R M	⊢ ∃ (y : M), 0 ≠ y
R : Type u_1,	_inst_1 : ring R,	M : Type u_2,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_4 : is_simple_module R M,	h : ⊥ ≠ ⊤	⊢ ∃ (y : M), 0 ≠ y
R : Type u_1,	_inst_1 : ring R,	M : Type u_2,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_4 : is_simple_module R M,	h : ∀ (y : M), 0 = y	⊢ ⊥ = ⊤
R : Type u_1,	_inst_1 : ring R,	M : Type u_2,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_4 : is_simple_module R M,	h : ∀ (y : M), 0 = y,	x : M	⊢ x ∈ ⊥ ↔ x ∈ ⊤
R : Type u_1,	_inst_1 : ring R,	M : Type u_2,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	N : Type u_3,	_inst_4 : add_comm_group N,	_inst_5 : module R N,	_inst_6 : is_simple_module R M,	f : M →ₗ[R] N	⊢ function.injective ⇑f ∨ f = 0
R : Type u,	S : Type v,	_inst_1 : ring R,	_inst_2 : ring S,	f : R →+* S	⊢ ↑(f.range) = ↑⊤ ↔ set.range ⇑f = set.univ
R : Type u,	_inst_1 : comm_ring R,	A : Type v₁,	_inst_2 : comm_ring A,	_inst_3 : algebra R A,	B : Type v₂,	_inst_4 : comm_ring B,	_inst_5 : algebra R B,	x y : A ⊗ B	⊢ x * y = y * x
R : Type u,	_inst_1 : comm_ring R,	A : Type v₁,	_inst_2 : comm_ring A,	_inst_3 : algebra R A,	B : Type v₂,	_inst_4 : comm_ring B,	_inst_5 : algebra R B,	x y : A ⊗ B	⊢ 0 * y = y * 0		R : Type u,	_inst_1 : comm_ring R,	A : Type v₁,	_inst_2 : comm_ring A,	_inst_3 : algebra R A,	B : Type v₂,	_inst_4 : comm_ring B,	_inst_5 : algebra R B,	x y : A ⊗ B	⊢ ∀ {x : A} {y_1 : B}, x ⊗ₜ[R] y_1 * y = y * x ⊗ₜ[R] y_1		R : Type u,	_inst_1 : comm_ring R,	A : Type v₁,	_inst_2 : comm_ring A,	_inst_3 : algebra R A,	B : Type v₂,	_inst_4 : comm_ring B,	_inst_5 : algebra R B,	x y : A ⊗ B	⊢ ∀ {x y_1 : A ⊗ B}, x * y = y * x → y_1 * y = y * y_1 → (x + y_1) * y = y * (x + y_1)
R : Type u,	_inst_1 : comm_ring R,	A : Type v₁,	_inst_2 : comm_ring A,	_inst_3 : algebra R A,	B : Type v₂,	_inst_4 : comm_ring B,	_inst_5 : algebra R B,	x y : A ⊗ B	⊢ 0 * y = y * 0
R : Type u,	_inst_1 : comm_ring R,	A : Type v₁,	_inst_2 : comm_ring A,	_inst_3 : algebra R A,	B : Type v₂,	_inst_4 : comm_ring B,	_inst_5 : algebra R B,	x y : A ⊗ B	⊢ ∀ {x : A} {y_1 : B}, x ⊗ₜ[R] y_1 * y = y * x ⊗ₜ[R] y_1
R : Type u,	_inst_1 : comm_ring R,	A : Type v₁,	_inst_2 : comm_ring A,	_inst_3 : algebra R A,	B : Type v₂,	_inst_4 : comm_ring B,	_inst_5 : algebra R B,	x y : A ⊗ B,	a₁ : A,	b₁ : B	⊢ a₁ ⊗ₜ[R] b₁ * y = y * a₁ ⊗ₜ[R] b₁
R : Type u,	_inst_1 : comm_ring R,	A : Type v₁,	_inst_2 : comm_ring A,	_inst_3 : algebra R A,	B : Type v₂,	_inst_4 : comm_ring B,	_inst_5 : algebra R B,	x y : A ⊗ B,	a₁ : A,	b₁ : B	⊢ a₁ ⊗ₜ[R] b₁ * 0 = 0 * a₁ ⊗ₜ[R] b₁		R : Type u,	_inst_1 : comm_ring R,	A : Type v₁,	_inst_2 : comm_ring A,	_inst_3 : algebra R A,	B : Type v₂,	_inst_4 : comm_ring B,	_inst_5 : algebra R B,	x y : A ⊗ B,	a₁ : A,	b₁ : B	⊢ ∀ {x : A} {y : B}, a₁ ⊗ₜ[R] b₁ * x ⊗ₜ[R] y = x ⊗ₜ[R] y * a₁ ⊗ₜ[R] b₁		R : Type u,	_inst_1 : comm_ring R,	A : Type v₁,	_inst_2 : comm_ring A,	_inst_3 : algebra R A,	B : Type v₂,	_inst_4 : comm_ring B,	_inst_5 : algebra R B,	x y : A ⊗ B,	a₁ : A,	b₁ : B	⊢ ∀ {x y : A ⊗ B}, a₁ ⊗ₜ[R] b₁ * x = x * a₁ ⊗ₜ[R] b₁ → a₁ ⊗ₜ[R] b₁ * y = y * a₁ ⊗ₜ[R] b₁ → a₁ ⊗ₜ[R] b₁ * (x + y) = (x + y) * a₁ ⊗ₜ[R] b₁
R : Type u,	_inst_1 : comm_ring R,	A : Type v₁,	_inst_2 : comm_ring A,	_inst_3 : algebra R A,	B : Type v₂,	_inst_4 : comm_ring B,	_inst_5 : algebra R B,	x y : A ⊗ B,	a₁ : A,	b₁ : B	⊢ a₁ ⊗ₜ[R] b₁ * 0 = 0 * a₁ ⊗ₜ[R] b₁
R : Type u,	_inst_1 : comm_ring R,	A : Type v₁,	_inst_2 : comm_ring A,	_inst_3 : algebra R A,	B : Type v₂,	_inst_4 : comm_ring B,	_inst_5 : algebra R B,	x y : A ⊗ B,	a₁ : A,	b₁ : B	⊢ ∀ {x : A} {y : B}, a₁ ⊗ₜ[R] b₁ * x ⊗ₜ[R] y = x ⊗ₜ[R] y * a₁ ⊗ₜ[R] b₁
R : Type u,	_inst_1 : comm_ring R,	A : Type v₁,	_inst_2 : comm_ring A,	_inst_3 : algebra R A,	B : Type v₂,	_inst_4 : comm_ring B,	_inst_5 : algebra R B,	x y : A ⊗ B,	a₁ : A,	b₁ : B	⊢ ∀ {x : A} {y : B}, a₁ ⊗ₜ[R] b₁ * x ⊗ₜ[R] y = x ⊗ₜ[R] y * a₁ ⊗ₜ[R] b₁		R : Type u,	_inst_1 : comm_ring R,	A : Type v₁,	_inst_2 : comm_ring A,	_inst_3 : algebra R A,	B : Type v₂,	_inst_4 : comm_ring B,	_inst_5 : algebra R B,	x y : A ⊗ B,	a₁ : A,	b₁ : B	⊢ ∀ {x y : A ⊗ B}, a₁ ⊗ₜ[R] b₁ * x = x * a₁ ⊗ₜ[R] b₁ → a₁ ⊗ₜ[R] b₁ * y = y * a₁ ⊗ₜ[R] b₁ → a₁ ⊗ₜ[R] b₁ * (x + y) = (x + y) * a₁ ⊗ₜ[R] b₁
R : Type u,	_inst_1 : comm_ring R,	A : Type v₁,	_inst_2 : comm_ring A,	_inst_3 : algebra R A,	B : Type v₂,	_inst_4 : comm_ring B,	_inst_5 : algebra R B,	x y : A ⊗ B,	a₁ : A,	b₁ : B,	a₂ : A,	b₂ : B	⊢ a₁ ⊗ₜ[R] b₁ * a₂ ⊗ₜ[R] b₂ = a₂ ⊗ₜ[R] b₂ * a₁ ⊗ₜ[R] b₁
R : Type u,	_inst_1 : comm_ring R,	A : Type v₁,	_inst_2 : comm_ring A,	_inst_3 : algebra R A,	B : Type v₂,	_inst_4 : comm_ring B,	_inst_5 : algebra R B,	x y : A ⊗ B,	a₁ : A,	b₁ : B	⊢ ∀ {x y : A ⊗ B}, a₁ ⊗ₜ[R] b₁ * x = x * a₁ ⊗ₜ[R] b₁ → a₁ ⊗ₜ[R] b₁ * y = y * a₁ ⊗ₜ[R] b₁ → a₁ ⊗ₜ[R] b₁ * (x + y) = (x + y) * a₁ ⊗ₜ[R] b₁
R : Type u,	_inst_1 : comm_ring R,	A : Type v₁,	_inst_2 : comm_ring A,	_inst_3 : algebra R A,	B : Type v₂,	_inst_4 : comm_ring B,	_inst_5 : algebra R B,	x y : A ⊗ B	⊢ ∀ {x : A} {y_1 : B}, x ⊗ₜ[R] y_1 * y = y * x ⊗ₜ[R] y_1		R : Type u,	_inst_1 : comm_ring R,	A : Type v₁,	_inst_2 : comm_ring A,	_inst_3 : algebra R A,	B : Type v₂,	_inst_4 : comm_ring B,	_inst_5 : algebra R B,	x y : A ⊗ B	⊢ ∀ {x y_1 : A ⊗ B}, x * y = y * x → y_1 * y = y * y_1 → (x + y_1) * y = y * (x + y_1)
R : Type u,	_inst_1 : comm_ring R,	A : Type v₁,	_inst_2 : comm_ring A,	_inst_3 : algebra R A,	B : Type v₂,	_inst_4 : comm_ring B,	_inst_5 : algebra R B,	x y : A ⊗ B,	a₁ : A,	b₁ : B,	a₂ b₂ : A ⊗ B,	ha : a₁ ⊗ₜ[R] b₁ * a₂ = a₂ * a₁ ⊗ₜ[R] b₁,	hb : a₁ ⊗ₜ[R] b₁ * b₂ = b₂ * a₁ ⊗ₜ[R] b₁	⊢ a₁ ⊗ₜ[R] b₁ * (a₂ + b₂) = (a₂ + b₂) * a₁ ⊗ₜ[R] b₁
R : Type u,	_inst_1 : comm_ring R,	A : Type v₁,	_inst_2 : comm_ring A,	_inst_3 : algebra R A,	B : Type v₂,	_inst_4 : comm_ring B,	_inst_5 : algebra R B,	x y : A ⊗ B	⊢ ∀ {x y_1 : A ⊗ B}, x * y = y * x → y_1 * y = y * y_1 → (x + y_1) * y = y * (x + y_1)
R : Type u,	_inst_1 : comm_ring R,	A : Type v₁,	_inst_2 : comm_ring A,	_inst_3 : algebra R A,	B : Type v₂,	_inst_4 : comm_ring B,	_inst_5 : algebra R B,	x y x₁ x₂ : A ⊗ B,	h₁ : x₁ * y = y * x₁,	h₂ : x₂ * y = y * x₂	⊢ (x₁ + x₂) * y = y * (x₁ + x₂)
R : Type u,	_inst_1 : comm_ring R,	A : Type v₁,	_inst_2 : comm_ring A,	_inst_3 : algebra R A,	B : Type v₂,	_inst_4 : comm_ring B,	_inst_5 : algebra R B	⊢ ring (A ⊗ B)
A : Type v₁,	_inst_1 : ring A,	B : Type v₂,	_inst_2 : ring B	⊢ ring (A ⊗ B)
A : Type v₁,	_inst_1 : comm_ring A,	B : Type v₂,	_inst_2 : comm_ring B	⊢ comm_ring (A ⊗ B)
K : Type u_4,	L : Type u_5,	_inst_6 : field K,	_inst_7 : field L,	_inst_8 : algebra K L,	x : K	⊢ ⇑(algebra.trace K L) (⇑(algebra_map K L) x) = finite_dimensional.finrank K L • x
K : Type u_4,	L : Type u_5,	_inst_6 : field K,	_inst_7 : field L,	_inst_8 : algebra K L,	x : K,	H : ∃ (s : finset L), nonempty (basis ↥s K L)	⊢ ⇑(algebra.trace K L) (⇑(algebra_map K L) x) = finite_dimensional.finrank K L • x
K : Type u_4,	L : Type u_5,	_inst_6 : field K,	_inst_7 : field L,	_inst_8 : algebra K L,	x : K,	H : ∃ (s : finset L), nonempty (basis ↥s K L)	⊢ ⇑(algebra.trace K L) (⇑(algebra_map K L) x) = finite_dimensional.finrank K L • x		K : Type u_4,	L : Type u_5,	_inst_6 : field K,	_inst_7 : field L,	_inst_8 : algebra K L,	x : K,	H : ¬∃ (s : finset L), nonempty (basis ↥s K L)	⊢ ⇑(algebra.trace K L) (⇑(algebra_map K L) x) = finite_dimensional.finrank K L • x
K : Type u_4,	L : Type u_5,	_inst_6 : field K,	_inst_7 : field L,	_inst_8 : algebra K L,	x : K,	H : ¬∃ (s : finset L), nonempty (basis ↥s K L)	⊢ ⇑(algebra.trace K L) (⇑(algebra_map K L) x) = finite_dimensional.finrank K L • x
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	dec_irr : Π (p : associates α), decidable (irreducible p),	_inst_2 : unique_factorization_monoid α,	_inst_3 : nontrivial α,	_inst_4 : normalization_monoid α,	dec : decidable_eq α,	dec' : decidable_eq (associates α),	a b : α,	ha0 : a ≠ 0,	hb0 : b ≠ 0	⊢ associates.mk a ⊓ associates.mk b = 1 ↔ ∀ {d : α}, d ∣ a → d ∣ b → ¬prime d
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	dec_irr : Π (p : associates α), decidable (irreducible p),	_inst_2 : unique_factorization_monoid α,	_inst_3 : nontrivial α,	_inst_4 : normalization_monoid α,	dec : decidable_eq α,	dec' : decidable_eq (associates α),	a b : α,	ha0 : a ≠ 0,	hb0 : b ≠ 0	⊢ associates.mk a ⊓ associates.mk b = 1 → ∀ {d : α}, d ∣ a → d ∣ b → ¬prime d
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	dec_irr : Π (p : associates α), decidable (irreducible p),	_inst_2 : unique_factorization_monoid α,	_inst_3 : nontrivial α,	_inst_4 : normalization_monoid α,	dec : decidable_eq α,	dec' : decidable_eq (associates α),	a b : α,	ha0 : a ≠ 0,	hb0 : b ≠ 0,	hg : associates.mk a ⊓ associates.mk b = 1,	p : α,	ha : p ∣ a,	hb : p ∣ b,	hp : prime p	⊢ false
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	dec_irr : Π (p : associates α), decidable (irreducible p),	_inst_2 : unique_factorization_monoid α,	_inst_3 : nontrivial α,	_inst_4 : normalization_monoid α,	dec : decidable_eq α,	dec' : decidable_eq (associates α),	a b : α,	ha0 : a ≠ 0,	hb0 : b ≠ 0,	hg : associates.mk a ⊓ associates.mk b = 1,	p : α,	ha : p ∣ a,	hb : p ∣ b,	hp : prime p	⊢ associates.mk p ∣ 1
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	dec_irr : Π (p : associates α), decidable (irreducible p),	_inst_2 : unique_factorization_monoid α,	_inst_3 : nontrivial α,	_inst_4 : normalization_monoid α,	dec : decidable_eq α,	dec' : decidable_eq (associates α),	a b : α,	ha0 : a ≠ 0,	hb0 : b ≠ 0,	hg : associates.mk a ⊓ associates.mk b = 1,	p : α,	ha : p ∣ a,	hb : p ∣ b,	hp : prime p	⊢ associates.mk p ∣ associates.mk a ⊓ associates.mk b
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	dec_irr : Π (p : associates α), decidable (irreducible p),	_inst_2 : unique_factorization_monoid α,	_inst_3 : nontrivial α,	_inst_4 : normalization_monoid α,	dec : decidable_eq α,	dec' : decidable_eq (associates α),	a b : α,	ha0 : a ≠ 0,	hb0 : b ≠ 0	⊢ associates.mk a ⊓ associates.mk b = 1 → ∀ {d : α}, d ∣ a → d ∣ b → ¬prime d		α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	dec_irr : Π (p : associates α), decidable (irreducible p),	_inst_2 : unique_factorization_monoid α,	_inst_3 : nontrivial α,	_inst_4 : normalization_monoid α,	dec : decidable_eq α,	dec' : decidable_eq (associates α),	a b : α,	ha0 : a ≠ 0,	hb0 : b ≠ 0	⊢ (∀ {d : α}, d ∣ a → d ∣ b → ¬prime d) → associates.mk a ⊓ associates.mk b = 1
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	dec_irr : Π (p : associates α), decidable (irreducible p),	_inst_2 : unique_factorization_monoid α,	_inst_3 : nontrivial α,	_inst_4 : normalization_monoid α,	dec : decidable_eq α,	dec' : decidable_eq (associates α),	a b : α,	ha0 : a ≠ 0,	hb0 : b ≠ 0	⊢ (∀ {d : α}, d ∣ a → d ∣ b → ¬prime d) → associates.mk a ⊓ associates.mk b = 1
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	dec_irr : Π (p : associates α), decidable (irreducible p),	_inst_2 : unique_factorization_monoid α,	_inst_3 : nontrivial α,	_inst_4 : normalization_monoid α,	dec : decidable_eq α,	dec' : decidable_eq (associates α),	a b : α,	ha0 : a ≠ 0,	hb0 : b ≠ 0	⊢ ¬associates.mk a ⊓ associates.mk b = 1 → (¬∀ {d : α}, d ∣ a → d ∣ b → ¬prime d)
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	dec_irr : Π (p : associates α), decidable (irreducible p),	_inst_2 : unique_factorization_monoid α,	_inst_3 : nontrivial α,	_inst_4 : normalization_monoid α,	dec : decidable_eq α,	dec' : decidable_eq (associates α),	a b : α,	ha0 : a ≠ 0,	hb0 : b ≠ 0,	hg : ¬associates.mk a ⊓ associates.mk b = 1,	hc : ∀ {d : α}, d ∣ a → d ∣ b → ¬prime d	⊢ false
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	dec_irr : Π (p : associates α), decidable (irreducible p),	_inst_2 : unique_factorization_monoid α,	_inst_3 : nontrivial α,	_inst_4 : normalization_monoid α,	dec : decidable_eq α,	dec' : decidable_eq (associates α),	a b : α,	ha0 : a ≠ 0,	hb0 : b ≠ 0,	hg : ¬associates.mk a ⊓ associates.mk b = 1,	hc : ∀ {d : α}, d ∣ a → d ∣ b → ¬prime d,	p : α,	hp : prime p,	hpa : p ∣ a,	hpb : p ∣ b	⊢ false
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : decidable_eq α,	_inst_3 : nontrivial α,	_inst_4 : normalization_monoid α,	_inst_5 : unique_factorization_monoid α,	a : α,	ha : irreducible a	⊢ unique_factorization_monoid.factors a = {⇑normalize a}
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : decidable_eq α,	_inst_3 : nontrivial α,	_inst_4 : normalization_monoid α,	_inst_5 : unique_factorization_monoid α,	a : α,	ha : irreducible a,	p : α,	a_assoc : a ~ᵤ p,	hp : unique_factorization_monoid.factors a = {p}	⊢ unique_factorization_monoid.factors a = {⇑normalize a}
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : decidable_eq α,	_inst_3 : nontrivial α,	_inst_4 : normalization_monoid α,	_inst_5 : unique_factorization_monoid α,	a : α,	ha : irreducible a,	p : α,	a_assoc : a ~ᵤ p,	hp : unique_factorization_monoid.factors a = {p}	⊢ p ∈ {p}
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : decidable_eq α,	_inst_3 : nontrivial α,	_inst_4 : normalization_monoid α,	_inst_5 : unique_factorization_monoid α,	a : α,	ha : irreducible a,	p : α,	a_assoc : a ~ᵤ p,	hp : unique_factorization_monoid.factors a = {p}	⊢ p ∈ unique_factorization_monoid.factors a		α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : decidable_eq α,	_inst_3 : nontrivial α,	_inst_4 : normalization_monoid α,	_inst_5 : unique_factorization_monoid α,	a : α,	ha : irreducible a,	p : α,	a_assoc : a ~ᵤ p,	hp : unique_factorization_monoid.factors a = {p},	p_mem : p ∈ unique_factorization_monoid.factors a	⊢ unique_factorization_monoid.factors a = {⇑normalize a}
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : decidable_eq α,	_inst_3 : nontrivial α,	_inst_4 : normalization_monoid α,	_inst_5 : unique_factorization_monoid α,	a : α,	ha : irreducible a,	p : α,	a_assoc : a ~ᵤ p,	hp : unique_factorization_monoid.factors a = {p}	⊢ p ∈ unique_factorization_monoid.factors a
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : decidable_eq α,	_inst_3 : nontrivial α,	_inst_4 : normalization_monoid α,	_inst_5 : unique_factorization_monoid α,	a : α,	ha : irreducible a,	p : α,	a_assoc : a ~ᵤ p,	hp : unique_factorization_monoid.factors a = {p},	p_mem : p ∈ unique_factorization_monoid.factors a	⊢ unique_factorization_monoid.factors a = {⇑normalize a}
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : decidable_eq α,	_inst_3 : nontrivial α,	_inst_4 : normalization_monoid α,	_inst_5 : unique_factorization_monoid α,	a : α,	ha : irreducible a,	p : α,	a_assoc : a ~ᵤ p,	hp : unique_factorization_monoid.factors a = {p},	p_mem : p ∈ unique_factorization_monoid.factors a	⊢ ⇑normalize a = p
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : decidable_eq α,	_inst_3 : nontrivial α,	_inst_4 : normalization_monoid α,	_inst_5 : unique_factorization_monoid α,	x y : α,	hx : x ≠ 0,	hy : y ≠ 0	⊢ x ∣ y ↔ unique_factorization_monoid.factors x ≤ unique_factorization_monoid.factors y
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : decidable_eq α,	_inst_3 : nontrivial α,	_inst_4 : normalization_monoid α,	_inst_5 : unique_factorization_monoid α,	x y : α,	hx : x ≠ 0,	hy : y ≠ 0	⊢ x ∣ y → unique_factorization_monoid.factors x ≤ unique_factorization_monoid.factors y
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : decidable_eq α,	_inst_3 : nontrivial α,	_inst_4 : normalization_monoid α,	_inst_5 : unique_factorization_monoid α,	x y : α,	hx : x ≠ 0,	hy : y ≠ 0	⊢ x ∣ y → unique_factorization_monoid.factors x ≤ unique_factorization_monoid.factors y		α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : decidable_eq α,	_inst_3 : nontrivial α,	_inst_4 : normalization_monoid α,	_inst_5 : unique_factorization_monoid α,	x y : α,	hx : x ≠ 0,	hy : y ≠ 0	⊢ unique_factorization_monoid.factors x ≤ unique_factorization_monoid.factors y → x ∣ y
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : decidable_eq α,	_inst_3 : nontrivial α,	_inst_4 : normalization_monoid α,	_inst_5 : unique_factorization_monoid α,	x : α,	hx : x ≠ 0,	c : α,	hy : x * c ≠ 0	⊢ unique_factorization_monoid.factors x ≤ unique_factorization_monoid.factors (x * c)
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : decidable_eq α,	_inst_3 : nontrivial α,	_inst_4 : normalization_monoid α,	_inst_5 : unique_factorization_monoid α,	x y : α,	hx : x ≠ 0,	hy : y ≠ 0	⊢ unique_factorization_monoid.factors x ≤ unique_factorization_monoid.factors y → x ∣ y
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : decidable_eq α,	_inst_3 : nontrivial α,	_inst_4 : normalization_monoid α,	_inst_5 : unique_factorization_monoid α,	x y : α,	hx : x ≠ 0,	hy : y ≠ 0	⊢ unique_factorization_monoid.factors x ≤ unique_factorization_monoid.factors y → (unique_factorization_monoid.factors x).prod ∣ (unique_factorization_monoid.factors y).prod
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : unique_factorization_monoid α	⊢ ite (1 = 0) 0 (multiset.map (classical.some _) (unique_factorization_monoid.factors 1)).prod = 1
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : unique_factorization_monoid α,	x y : associates α,	hx : x = 0	⊢ ite (x * y = 0) 0 (multiset.map (classical.some _) (unique_factorization_monoid.factors (x * y))).prod = ite (x = 0) 0 (multiset.map (classical.some _) (unique_factorization_monoid.factors x)).prod * ite (y = 0) 0 (multiset.map (classical.some _) (unique_factorization_monoid.factors y)).prod
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : unique_factorization_monoid α,	x y : associates α,	hx : x = 0	⊢ ite (x * y = 0) 0 (multiset.map (classical.some _) (unique_factorization_monoid.factors (x * y))).prod = ite (x = 0) 0 (multiset.map (classical.some _) (unique_factorization_monoid.factors x)).prod * ite (y = 0) 0 (multiset.map (classical.some _) (unique_factorization_monoid.factors y)).prod		α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : unique_factorization_monoid α,	x y : associates α,	hx : ¬x = 0	⊢ ite (x * y = 0) 0 (multiset.map (classical.some _) (unique_factorization_monoid.factors (x * y))).prod = ite (x = 0) 0 (multiset.map (classical.some _) (unique_factorization_monoid.factors x)).prod * ite (y = 0) 0 (multiset.map (classical.some _) (unique_factorization_monoid.factors y)).prod
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : unique_factorization_monoid α,	x y : associates α	⊢ ite (x * y = 0) 0 (multiset.map (classical.some _) (unique_factorization_monoid.factors (x * y))).prod = ite (x = 0) 0 (multiset.map (classical.some _) (unique_factorization_monoid.factors x)).prod * ite (y = 0) 0 (multiset.map (classical.some _) (unique_factorization_monoid.factors y)).prod
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : unique_factorization_monoid α,	x y : associates α,	hx : ¬x = 0,	hy : y = 0	⊢ ite (x * y = 0) 0 (multiset.map (classical.some _) (unique_factorization_monoid.factors (x * y))).prod = ite (x = 0) 0 (multiset.map (classical.some _) (unique_factorization_monoid.factors x)).prod * ite (y = 0) 0 (multiset.map (classical.some _) (unique_factorization_monoid.factors y)).prod
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : unique_factorization_monoid α,	x y : associates α,	hx : ¬x = 0,	hy : y = 0	⊢ ite (x * y = 0) 0 (multiset.map (classical.some _) (unique_factorization_monoid.factors (x * y))).prod = ite (x = 0) 0 (multiset.map (classical.some _) (unique_factorization_monoid.factors x)).prod * ite (y = 0) 0 (multiset.map (classical.some _) (unique_factorization_monoid.factors y)).prod		α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : unique_factorization_monoid α,	x y : associates α,	hx : ¬x = 0,	hy : ¬y = 0	⊢ ite (x * y = 0) 0 (multiset.map (classical.some _) (unique_factorization_monoid.factors (x * y))).prod = ite (x = 0) 0 (multiset.map (classical.some _) (unique_factorization_monoid.factors x)).prod * ite (y = 0) 0 (multiset.map (classical.some _) (unique_factorization_monoid.factors y)).prod
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : unique_factorization_monoid α,	x y : associates α,	hx : ¬x = 0	⊢ ite (x * y = 0) 0 (multiset.map (classical.some _) (unique_factorization_monoid.factors (x * y))).prod = ite (x = 0) 0 (multiset.map (classical.some _) (unique_factorization_monoid.factors x)).prod * ite (y = 0) 0 (multiset.map (classical.some _) (unique_factorization_monoid.factors y)).prod
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : unique_factorization_monoid α,	x y : associates α,	hx : ¬x = 0,	hy : ¬y = 0	⊢ ite (x * y = 0) 0 (multiset.map (classical.some _) (unique_factorization_monoid.factors (x * y))).prod = ite (x = 0) 0 (multiset.map (classical.some _) (unique_factorization_monoid.factors x)).prod * ite (y = 0) 0 (multiset.map (classical.some _) (unique_factorization_monoid.factors y)).prod
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : unique_factorization_monoid α	⊢ function.right_inverse ⇑{to_fun := λ (a : associates α), ite (a = 0) 0 (multiset.map (classical.some _) (unique_factorization_monoid.factors a)).prod, map_one' := _, map_mul' := _} associates.mk
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : unique_factorization_monoid α,	x : associates α	⊢ associates.mk (⇑{to_fun := λ (a : associates α), ite (a = 0) 0 (multiset.map (classical.some _) (unique_factorization_monoid.factors a)).prod, map_one' := _, map_mul' := _} x) = x
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : unique_factorization_monoid α,	x : associates α,	hx : x = 0	⊢ associates.mk (ite (x = 0) 0 (multiset.map (classical.some _) (unique_factorization_monoid.factors x)).prod) = x
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : unique_factorization_monoid α,	x : associates α,	hx : x = 0	⊢ associates.mk (ite (x = 0) 0 (multiset.map (classical.some _) (unique_factorization_monoid.factors x)).prod) = x		α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : unique_factorization_monoid α,	x : associates α,	hx : ¬x = 0	⊢ associates.mk (ite (x = 0) 0 (multiset.map (classical.some _) (unique_factorization_monoid.factors x)).prod) = x
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : unique_factorization_monoid α,	x : associates α	⊢ associates.mk (ite (x = 0) 0 (multiset.map (classical.some _) (unique_factorization_monoid.factors x)).prod) = x
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : unique_factorization_monoid α,	x : associates α,	hx : ¬x = 0	⊢ associates.mk (ite (x = 0) 0 (multiset.map (classical.some _) (unique_factorization_monoid.factors x)).prod) = x
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : unique_factorization_monoid α,	x : associates α,	hx : ¬x = 0	⊢ ⇑associates.mk_monoid_hom ∘ classical.some _ = id
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : unique_factorization_monoid α,	x : associates α,	hx : ¬x = 0,	x : associates α	⊢ (⇑associates.mk_monoid_hom ∘ classical.some _) x = id x
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : unique_factorization_monoid α,	x : associates α,	hx : ¬x = 0	⊢ ⇑associates.mk_monoid_hom ∘ classical.some _ = id		α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : unique_factorization_monoid α,	x : associates α,	hx : ¬x = 0,	h : ⇑associates.mk_monoid_hom ∘ classical.some _ = id	⊢ associates.mk (ite (x = 0) 0 (multiset.map (classical.some _) (unique_factorization_monoid.factors x)).prod) = x
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : unique_factorization_monoid α,	x : associates α,	hx : ¬x = 0,	x : associates α	⊢ x = id x
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : unique_factorization_monoid α,	x : associates α,	hx : ¬x = 0,	h : ⇑associates.mk_monoid_hom ∘ classical.some _ = id	⊢ associates.mk (ite (x = 0) 0 (multiset.map (classical.some _) (unique_factorization_monoid.factors x)).prod) = x
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	_inst_2 : nontrivial α,	_inst_3 : unique_factorization_monoid α,	x : associates α,	hx : ¬x = 0,	h : ⇑associates.mk_monoid_hom ∘ classical.some _ = id	⊢ (unique_factorization_monoid.factors x).prod ~ᵤ x
R : Type u_2,	_inst_1 : comm_cancel_monoid_with_zero R,	_inst_2 : unique_factorization_monoid R,	_inst_3 : nontrivial R,	_inst_4 : normalization_monoid R,	_inst_5 : decidable_eq R,	_inst_6 : decidable_rel has_dvd.dvd,	a b : R,	n : ℕ,	ha : irreducible a,	hb : b ≠ 0	⊢ ↑n ≤ multiplicity a b ↔ multiset.repeat (⇑normalize a) n ≤ unique_factorization_monoid.factors b
R : Type u_2,	_inst_1 : comm_cancel_monoid_with_zero R,	_inst_2 : unique_factorization_monoid R,	_inst_3 : nontrivial R,	_inst_4 : normalization_monoid R,	_inst_5 : decidable_eq R,	_inst_6 : decidable_rel has_dvd.dvd,	a b : R,	n : ℕ,	ha : irreducible a,	hb : b ≠ 0	⊢ a ^ n ∣ b ↔ multiset.repeat (⇑normalize a) n ≤ unique_factorization_monoid.factors b
R : Type u_2,	_inst_1 : comm_cancel_monoid_with_zero R,	_inst_2 : unique_factorization_monoid R,	_inst_3 : nontrivial R,	_inst_4 : normalization_monoid R,	_inst_5 : decidable_eq R,	_inst_6 : decidable_rel has_dvd.dvd,	a : R,	ha : irreducible a	⊢ ∀ {b : R}, b ≠ 0 → (a ^ 0 ∣ b ↔ multiset.repeat (⇑normalize a) 0 ≤ unique_factorization_monoid.factors b)
R : Type u_2,	_inst_1 : comm_cancel_monoid_with_zero R,	_inst_2 : unique_factorization_monoid R,	_inst_3 : nontrivial R,	_inst_4 : normalization_monoid R,	_inst_5 : decidable_eq R,	_inst_6 : decidable_rel has_dvd.dvd,	a : R,	ha : irreducible a	⊢ ∀ {b : R}, b ≠ 0 → (a ^ 0 ∣ b ↔ multiset.repeat (⇑normalize a) 0 ≤ unique_factorization_monoid.factors b)		case nat.succ	R : Type u_2,	_inst_1 : comm_cancel_monoid_with_zero R,	_inst_2 : unique_factorization_monoid R,	_inst_3 : nontrivial R,	_inst_4 : normalization_monoid R,	_inst_5 : decidable_eq R,	_inst_6 : decidable_rel has_dvd.dvd,	a : R,	ha : irreducible a,	n : ℕ,	ih : ∀ {b : R}, b ≠ 0 → (a ^ n ∣ b ↔ multiset.repeat (⇑normalize a) n ≤ unique_factorization_monoid.factors b)	⊢ ∀ {b : R}, b ≠ 0 → (a ^ n.succ ∣ b ↔ multiset.repeat (⇑normalize a) n.succ ≤ unique_factorization_monoid.factors b)
R : Type u_2,	_inst_1 : comm_cancel_monoid_with_zero R,	_inst_2 : unique_factorization_monoid R,	_inst_3 : nontrivial R,	_inst_4 : normalization_monoid R,	_inst_5 : decidable_eq R,	_inst_6 : decidable_rel has_dvd.dvd,	a : R,	n : ℕ,	ha : irreducible a	⊢ ∀ {b : R}, b ≠ 0 → (a ^ n ∣ b ↔ multiset.repeat (⇑normalize a) n ≤ unique_factorization_monoid.factors b)
R : Type u_2,	_inst_1 : comm_cancel_monoid_with_zero R,	_inst_2 : unique_factorization_monoid R,	_inst_3 : nontrivial R,	_inst_4 : normalization_monoid R,	_inst_5 : decidable_eq R,	_inst_6 : decidable_rel has_dvd.dvd,	a : R,	ha : irreducible a,	n : ℕ,	ih : ∀ {b : R}, b ≠ 0 → (a ^ n ∣ b ↔ multiset.repeat (⇑normalize a) n ≤ unique_factorization_monoid.factors b)	⊢ ∀ {b : R}, b ≠ 0 → (a ^ n.succ ∣ b ↔ multiset.repeat (⇑normalize a) n.succ ≤ unique_factorization_monoid.factors b)
R : Type u_2,	_inst_1 : comm_cancel_monoid_with_zero R,	_inst_2 : unique_factorization_monoid R,	_inst_3 : nontrivial R,	_inst_4 : normalization_monoid R,	_inst_5 : decidable_eq R,	_inst_6 : decidable_rel has_dvd.dvd,	a : R,	ha : irreducible a,	n : ℕ,	ih : ∀ {b : R}, b ≠ 0 → (a ^ n ∣ b ↔ multiset.repeat (⇑normalize a) n ≤ unique_factorization_monoid.factors b),	b : R,	hb : b ≠ 0	⊢ a ^ n.succ ∣ b ↔ multiset.repeat (⇑normalize a) n.succ ≤ unique_factorization_monoid.factors b
R : Type u_2,	_inst_1 : comm_cancel_monoid_with_zero R,	_inst_2 : unique_factorization_monoid R,	_inst_3 : nontrivial R,	_inst_4 : normalization_monoid R,	_inst_5 : decidable_eq R,	_inst_6 : decidable_rel has_dvd.dvd,	a : R,	ha : irreducible a,	n : ℕ,	ih : ∀ {b : R}, b ≠ 0 → (a ^ n ∣ b ↔ multiset.repeat (⇑normalize a) n ≤ unique_factorization_monoid.factors b),	b : R,	hb : b ≠ 0	⊢ a ^ n.succ ∣ b → multiset.repeat (⇑normalize a) n.succ ≤ unique_factorization_monoid.factors b
R : Type u_2,	_inst_1 : comm_cancel_monoid_with_zero R,	_inst_2 : unique_factorization_monoid R,	_inst_3 : nontrivial R,	_inst_4 : normalization_monoid R,	_inst_5 : decidable_eq R,	_inst_6 : decidable_rel has_dvd.dvd,	a : R,	ha : irreducible a,	n : ℕ,	ih : ∀ {b : R}, b ≠ 0 → (a ^ n ∣ b ↔ multiset.repeat (⇑normalize a) n ≤ unique_factorization_monoid.factors b),	c : R,	hb : a ^ n.succ * c ≠ 0	⊢ multiset.repeat (⇑normalize a) n.succ ≤ unique_factorization_monoid.factors (a ^ n.succ * c)
R : Type u_2,	_inst_1 : comm_cancel_monoid_with_zero R,	_inst_2 : unique_factorization_monoid R,	_inst_3 : nontrivial R,	_inst_4 : normalization_monoid R,	_inst_5 : decidable_eq R,	_inst_6 : decidable_rel has_dvd.dvd,	a : R,	ha : irreducible a,	n : ℕ,	ih : ∀ {b : R}, b ≠ 0 → (a ^ n ∣ b ↔ multiset.repeat (⇑normalize a) n ≤ unique_factorization_monoid.factors b),	c : R,	hb : ¬a = 0 ∧ ¬a ^ n * c = 0	⊢ multiset.repeat (⇑normalize a) n.succ ≤ unique_factorization_monoid.factors (a ^ n.succ * c)
R : Type u_2,	_inst_1 : comm_cancel_monoid_with_zero R,	_inst_2 : unique_factorization_monoid R,	_inst_3 : nontrivial R,	_inst_4 : normalization_monoid R,	_inst_5 : decidable_eq R,	_inst_6 : decidable_rel has_dvd.dvd,	a : R,	ha : irreducible a,	n : ℕ,	ih : ∀ {b : R}, b ≠ 0 → (a ^ n ∣ b ↔ multiset.repeat (⇑normalize a) n ≤ unique_factorization_monoid.factors b),	b : R,	hb : b ≠ 0	⊢ a ^ n.succ ∣ b → multiset.repeat (⇑normalize a) n.succ ≤ unique_factorization_monoid.factors b		R : Type u_2,	_inst_1 : comm_cancel_monoid_with_zero R,	_inst_2 : unique_factorization_monoid R,	_inst_3 : nontrivial R,	_inst_4 : normalization_monoid R,	_inst_5 : decidable_eq R,	_inst_6 : decidable_rel has_dvd.dvd,	a : R,	ha : irreducible a,	n : ℕ,	ih : ∀ {b : R}, b ≠ 0 → (a ^ n ∣ b ↔ multiset.repeat (⇑normalize a) n ≤ unique_factorization_monoid.factors b),	b : R,	hb : b ≠ 0	⊢ multiset.repeat (⇑normalize a) n.succ ≤ unique_factorization_monoid.factors b → a ^ n.succ ∣ b
R : Type u_2,	_inst_1 : comm_cancel_monoid_with_zero R,	_inst_2 : unique_factorization_monoid R,	_inst_3 : nontrivial R,	_inst_4 : normalization_monoid R,	_inst_5 : decidable_eq R,	_inst_6 : decidable_rel has_dvd.dvd,	a : R,	ha : irreducible a,	n : ℕ,	ih : ∀ {b : R}, b ≠ 0 → (a ^ n ∣ b ↔ multiset.repeat (⇑normalize a) n ≤ unique_factorization_monoid.factors b),	c : R,	hb : ¬a = 0 ∧ ¬a ^ n * c = 0	⊢ a ^ n ∣ a ^ n * c
R : Type u_2,	_inst_1 : comm_cancel_monoid_with_zero R,	_inst_2 : unique_factorization_monoid R,	_inst_3 : nontrivial R,	_inst_4 : normalization_monoid R,	_inst_5 : decidable_eq R,	_inst_6 : decidable_rel has_dvd.dvd,	a : R,	ha : irreducible a,	n : ℕ,	ih : ∀ {b : R}, b ≠ 0 → (a ^ n ∣ b ↔ multiset.repeat (⇑normalize a) n ≤ unique_factorization_monoid.factors b),	b : R,	hb : b ≠ 0	⊢ multiset.repeat (⇑normalize a) n.succ ≤ unique_factorization_monoid.factors b → a ^ n.succ ∣ b
R : Type u_2,	_inst_1 : comm_cancel_monoid_with_zero R,	_inst_2 : unique_factorization_monoid R,	_inst_3 : nontrivial R,	_inst_4 : normalization_monoid R,	_inst_5 : decidable_eq R,	_inst_6 : decidable_rel has_dvd.dvd,	a : R,	ha : irreducible a,	n : ℕ,	ih : ∀ {b : R}, b ≠ 0 → (a ^ n ∣ b ↔ multiset.repeat (⇑normalize a) n ≤ unique_factorization_monoid.factors b),	b : R,	hb : b ≠ 0	⊢ (∃ (u : multiset R), unique_factorization_monoid.factors b = multiset.repeat (⇑normalize a) n.succ + u) → a ^ n.succ ∣ b
R : Type u_2,	_inst_1 : comm_cancel_monoid_with_zero R,	_inst_2 : unique_factorization_monoid R,	_inst_3 : nontrivial R,	_inst_4 : normalization_monoid R,	_inst_5 : decidable_eq R,	_inst_6 : decidable_rel has_dvd.dvd,	a : R,	ha : irreducible a,	n : ℕ,	ih : ∀ {b : R}, b ≠ 0 → (a ^ n ∣ b ↔ multiset.repeat (⇑normalize a) n ≤ unique_factorization_monoid.factors b),	b : R,	hb : b ≠ 0,	u : multiset R,	hu : unique_factorization_monoid.factors b = multiset.repeat (⇑normalize a) n.succ + u	⊢ a ^ n.succ ∣ b
R : Type u_2,	_inst_1 : comm_cancel_monoid_with_zero R,	_inst_2 : unique_factorization_monoid R,	_inst_3 : nontrivial R,	_inst_4 : normalization_monoid R,	_inst_5 : decidable_eq R,	_inst_6 : decidable_rel has_dvd.dvd,	a : R,	ha : irreducible a,	n : ℕ,	ih : ∀ {b : R}, b ≠ 0 → (a ^ n ∣ b ↔ multiset.repeat (⇑normalize a) n ≤ unique_factorization_monoid.factors b),	b : R,	hb : b ≠ 0,	u : multiset R,	hu : unique_factorization_monoid.factors b = multiset.repeat (⇑normalize a) n.succ + u	⊢ a ^ n.succ ∣ ⇑normalize a ^ n.succ * u.prod
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	prod_add : ∀ (a b : associates.factor_set α), (a + b).prod = a.prod * b.prod,	b : associates.factor_set α	⊢ (⊤ + b).prod = ⊤.prod * b.prod
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	prod_add : ∀ (a b : associates.factor_set α), (a + b).prod = a.prod * b.prod,	a : associates.factor_set α	⊢ (a + ⊤).prod = a.prod * ⊤.prod
α : Type u_1,	_inst_1 : comm_cancel_monoid_with_zero α,	prod_add : ∀ (a b : associates.factor_set α), (a + b).prod = a.prod * b.prod,	a b : multiset {a // irreducible a}	⊢ (↑a + ↑b).prod = ↑a.prod * ↑b.prod
R : Type u,	Γ₀ : Type v,	_inst_1 : comm_ring R,	_inst_2 : linear_ordered_comm_group_with_zero Γ₀,	v : valuation R Γ₀,	O : Type w,	_inst_3 : comm_ring O,	_inst_4 : algebra O R,	hv : v.integers O,	x : R,	hx : is_integral O x,	_let_match : is_integral O x → x ∈ v.integer,	p : polynomial O,	hpm : p.monic,	hpx : polynomial.eval₂ (algebra_map O R) x p = 0,	hvx : 1 < ⇑v x	⊢ false
R : Type u,	Γ₀ : Type v,	_inst_1 : comm_ring R,	_inst_2 : linear_ordered_comm_group_with_zero Γ₀,	v : valuation R Γ₀,	O : Type w,	_inst_3 : comm_ring O,	_inst_4 : algebra O R,	hv : v.integers O,	x : R,	hx : is_integral O x,	_let_match : is_integral O x → x ∈ v.integer,	p : polynomial O,	hpm : p.monic,	hvx : 1 < ⇑v x,	hpx : ⇑v (x ^ p.nat_degree) = ⇑v (-∑ (i : ℕ) in finset.range p.nat_degree, polynomial.eval₂ (algebra_map O R) x (⇑polynomial.C (p.coeff i) * polynomial.X ^ i))	⊢ false
R : Type u,	Γ₀ : Type v,	_inst_1 : comm_ring R,	_inst_2 : linear_ordered_comm_group_with_zero Γ₀,	v : valuation R Γ₀,	O : Type w,	_inst_3 : comm_ring O,	_inst_4 : algebra O R,	hv : v.integers O,	x : R,	hx : is_integral O x,	_let_match : is_integral O x → x ∈ v.integer,	p : polynomial O,	hpm : p.monic,	hvx : 1 < ⇑v x,	hpx : x ^ p.nat_degree = -∑ (i : ℕ) in finset.range p.nat_degree, polynomial.eval₂ (algebra_map O R) x (⇑polynomial.C (p.coeff i) * polynomial.X ^ i)	⊢ false
R : Type u,	Γ₀ : Type v,	_inst_1 : comm_ring R,	_inst_2 : linear_ordered_comm_group_with_zero Γ₀,	v : valuation R Γ₀,	O : Type w,	_inst_3 : comm_ring O,	_inst_4 : algebra O R,	hv : v.integers O,	x : R,	hx : is_integral O x,	_let_match : is_integral O x → x ∈ v.integer,	p : polynomial O,	hpm : p.monic,	hvx : 1 < ⇑v x,	hpx : ⇑v (x ^ p.nat_degree) = ⇑v (-∑ (i : ℕ) in finset.range p.nat_degree, polynomial.eval₂ (algebra_map O R) x (⇑polynomial.C (p.coeff i) * polynomial.X ^ i))	⊢ ⇑v (-∑ (i : ℕ) in finset.range p.nat_degree, polynomial.eval₂ (algebra_map O R) x (⇑polynomial.C (p.coeff i) * polynomial.X ^ i)) < ⇑v (x ^ p.nat_degree)
R : Type u,	Γ₀ : Type v,	_inst_1 : comm_ring R,	_inst_2 : linear_ordered_comm_group_with_zero Γ₀,	v : valuation R Γ₀,	O : Type w,	_inst_3 : comm_ring O,	_inst_4 : algebra O R,	hv : v.integers O,	x : R,	hx : is_integral O x,	_let_match : is_integral O x → x ∈ v.integer,	p : polynomial O,	hpm : p.monic,	hvx : 1 < ⇑v x,	hpx : ⇑v (x ^ p.nat_degree) = ⇑v (-∑ (i : ℕ) in finset.range p.nat_degree, polynomial.eval₂ (algebra_map O R) x (⇑polynomial.C (p.coeff i) * polynomial.X ^ i))	⊢ ⇑v (∑ (i : ℕ) in finset.range p.nat_degree, polynomial.eval₂ (algebra_map O R) x (⇑polynomial.C (p.coeff i) * polynomial.X ^ i)) < ⇑v x ^ p.nat_degree
R : Type u,	Γ₀ : Type v,	_inst_1 : comm_ring R,	_inst_2 : linear_ordered_comm_group_with_zero Γ₀,	v : valuation R Γ₀,	O : Type w,	_inst_3 : comm_ring O,	_inst_4 : algebra O R,	hv : v.integers O,	x : R,	hx : is_integral O x,	_let_match : is_integral O x → x ∈ v.integer,	p : polynomial O,	hpm : p.monic,	hvx : 1 < ⇑v x,	hpx : ⇑v (x ^ p.nat_degree) = ⇑v (-∑ (i : ℕ) in finset.range p.nat_degree, polynomial.eval₂ (algebra_map O R) x (⇑polynomial.C (p.coeff i) * polynomial.X ^ i)),	i : ℕ,	hi : i ∈ finset.range p.nat_degree	⊢ ⇑v (polynomial.eval₂ (algebra_map O R) x (⇑polynomial.C (p.coeff i) * polynomial.X ^ i)) < ⇑v x ^ p.nat_degree
R : Type u,	Γ₀ : Type v,	_inst_1 : comm_ring R,	_inst_2 : linear_ordered_comm_group_with_zero Γ₀,	v : valuation R Γ₀,	O : Type w,	_inst_3 : comm_ring O,	_inst_4 : algebra O R,	hv : v.integers O,	x : R,	hx : is_integral O x,	_let_match : is_integral O x → x ∈ v.integer,	p : polynomial O,	hpm : p.monic,	hvx : 1 < ⇑v x,	hpx : ⇑v (x ^ p.nat_degree) = ⇑v (-∑ (i : ℕ) in finset.range p.nat_degree, polynomial.eval₂ (algebra_map O R) x (⇑polynomial.C (p.coeff i) * polynomial.X ^ i)),	i : ℕ,	hi : i ∈ finset.range p.nat_degree	⊢ ⇑v (⇑(algebra_map O R) (p.coeff i)) * ⇑v x ^ i < 1 * ⇑v x ^ p.nat_degree
R : Type u,	Γ₀ : Type v,	_inst_1 : comm_ring R,	_inst_2 : linear_ordered_comm_group_with_zero Γ₀,	v : valuation R Γ₀,	O : Type w,	_inst_3 : comm_ring O,	_inst_4 : algebra O R,	hv : v.integers O,	x : R,	hx : is_integral O x,	_let_match : is_integral O x → x ∈ v.integer,	p : polynomial O,	hpm : p.monic,	hvx : 1 < ⇑v x,	hpx : ⇑v (x ^ p.nat_degree) = ⇑v (-∑ (i : ℕ) in finset.range p.nat_degree, polynomial.eval₂ (algebra_map O R) x (⇑polynomial.C (p.coeff i) * polynomial.X ^ i)),	i : ℕ,	hi : i ∈ finset.range p.nat_degree,	hvpi : ⇑v (⇑(algebra_map O R) (p.coeff i)) < 1	⊢ ⇑v (⇑(algebra_map O R) (p.coeff i)) * ⇑v x ^ i < 1 * ⇑v x ^ p.nat_degree
R : Type u,	Γ₀ : Type v,	_inst_1 : comm_ring R,	_inst_2 : linear_ordered_comm_group_with_zero Γ₀,	v : valuation R Γ₀,	O : Type w,	_inst_3 : comm_ring O,	_inst_4 : algebra O R,	hv : v.integers O,	x : R,	hx : is_integral O x,	_let_match : is_integral O x → x ∈ v.integer,	p : polynomial O,	hpm : p.monic,	hvx : 1 < ⇑v x,	hpx : ⇑v (x ^ p.nat_degree) = ⇑v (-∑ (i : ℕ) in finset.range p.nat_degree, polynomial.eval₂ (algebra_map O R) x (⇑polynomial.C (p.coeff i) * polynomial.X ^ i)),	i : ℕ,	hi : i ∈ finset.range p.nat_degree,	hvpi : ⇑v (⇑(algebra_map O R) (p.coeff i)) < 1	⊢ ⇑v (⇑(algebra_map O R) (p.coeff i)) * ⇑v x ^ i < 1 * ⇑v x ^ p.nat_degree		case or.inr	R : Type u,	Γ₀ : Type v,	_inst_1 : comm_ring R,	_inst_2 : linear_ordered_comm_group_with_zero Γ₀,	v : valuation R Γ₀,	O : Type w,	_inst_3 : comm_ring O,	_inst_4 : algebra O R,	hv : v.integers O,	x : R,	hx : is_integral O x,	_let_match : is_integral O x → x ∈ v.integer,	p : polynomial O,	hpm : p.monic,	hvx : 1 < ⇑v x,	hpx : ⇑v (x ^ p.nat_degree) = ⇑v (-∑ (i : ℕ) in finset.range p.nat_degree, polynomial.eval₂ (algebra_map O R) x (⇑polynomial.C (p.coeff i) * polynomial.X ^ i)),	i : ℕ,	hi : i ∈ finset.range p.nat_degree,	hvpi : ⇑v (⇑(algebra_map O R) (p.coeff i)) = 1	⊢ ⇑v (⇑(algebra_map O R) (p.coeff i)) * ⇑v x ^ i < 1 * ⇑v x ^ p.nat_degree
R : Type u,	Γ₀ : Type v,	_inst_1 : comm_ring R,	_inst_2 : linear_ordered_comm_group_with_zero Γ₀,	v : valuation R Γ₀,	O : Type w,	_inst_3 : comm_ring O,	_inst_4 : algebra O R,	hv : v.integers O,	x : R,	hx : is_integral O x,	_let_match : is_integral O x → x ∈ v.integer,	p : polynomial O,	hpm : p.monic,	hvx : 1 < ⇑v x,	hpx : ⇑v (x ^ p.nat_degree) = ⇑v (-∑ (i : ℕ) in finset.range p.nat_degree, polynomial.eval₂ (algebra_map O R) x (⇑polynomial.C (p.coeff i) * polynomial.X ^ i)),	i : ℕ,	hi : i ∈ finset.range p.nat_degree,	hvpi : ⇑v (⇑(algebra_map O R) (p.coeff i)) = 1	⊢ 1 * ⇑v x ^ i < 1 * ⇑v x ^ p.nat_degree
R : Type u,	Γ₀ : Type v,	_inst_1 : comm_ring R,	_inst_2 : linear_ordered_comm_group_with_zero Γ₀,	v : valuation R Γ₀,	O : Type w,	_inst_3 : comm_ring O,	_inst_4 : algebra O R,	hv : v.integers O,	x : R,	hx : is_integral O x,	_let_match : is_integral O x → x ∈ v.integer,	p : polynomial O,	hpm : p.monic,	hvx : 1 < ⇑v x,	hpx : ⇑v (x ^ p.nat_degree) = ⇑v (-∑ (i : ℕ) in finset.range p.nat_degree, polynomial.eval₂ (algebra_map O R) x (⇑polynomial.C (p.coeff i) * polynomial.X ^ i)),	i : ℕ,	hi : i ∈ finset.range p.nat_degree,	hvpi : ⇑v (⇑(algebra_map O R) (p.coeff i)) = 1	⊢ ⇑v x ^ i < ⇑v x ^ p.nat_degree
R : Type u,	Γ₀ : Type v,	_inst_1 : comm_ring R,	_inst_2 : linear_ordered_comm_group_with_zero Γ₀,	v : valuation R Γ₀,	O : Type w,	_inst_3 : comm_ring O,	_inst_4 : algebra O R,	hv : v.integers O,	x : R,	hx : is_integral O x,	_let_match : is_integral O x → x ∈ v.integer,	p : polynomial O,	hpm : p.monic,	hvx : 1 < ⇑v x,	hpx : ⇑v (x ^ p.nat_degree) = ⇑v (-∑ (i : ℕ) in finset.range p.nat_degree, polynomial.eval₂ (algebra_map O R) x (⇑polynomial.C (p.coeff i) * polynomial.X ^ i)),	i : ℕ,	hi : i ∈ finset.range p.nat_degree,	hvpi : ⇑v (⇑(algebra_map O R) (p.coeff i)) = 1	⊢ ⇑v (⇑(algebra_map O R) (p.coeff i)) * ⇑v x ^ i < 1 * ⇑v x ^ p.nat_degree
p : ℕ,	hp : fact (nat.prime p),	x : witt_vector p (zmod p)	⊢ ⇑((witt_vector.from_padic_int p).comp (witt_vector.to_padic_int p)) x = ⇑(ring_hom.id (witt_vector p (zmod p))) x
p : ℕ,	R : Type u_1,	hp : fact (nat.prime p),	_inst_1 : comm_ring R,	x y : witt_vector p R,	n : ℕ	⊢ (x - y).coeff n = witt_vector.peval (witt_vector.witt_sub p n) ![x.coeff, y.coeff]
p : ℕ,	hp : fact (nat.prime p),	n k : ℕ	⊢ ⇑(mv_polynomial.bind₁ (witt_vector.witt_mul_n p n)) (witt_polynomial p ℤ k) = ↑n * witt_polynomial p ℤ k
p : ℕ,	hp : fact (nat.prime p),	k : ℕ	⊢ ⇑(mv_polynomial.bind₁ (witt_vector.witt_mul_n p 0)) (witt_polynomial p ℤ k) = ↑0 * witt_polynomial p ℤ k
p : ℕ,	hp : fact (nat.prime p),	k : ℕ	⊢ ⇑(mv_polynomial.bind₁ (witt_vector.witt_mul_n p 0)) (witt_polynomial p ℤ k) = ↑0 * witt_polynomial p ℤ k		case nat.succ	p : ℕ,	hp : fact (nat.prime p),	k n : ℕ,	ih : ⇑(mv_polynomial.bind₁ (witt_vector.witt_mul_n p n)) (witt_polynomial p ℤ k) = ↑n * witt_polynomial p ℤ k	⊢ ⇑(mv_polynomial.bind₁ (witt_vector.witt_mul_n p n.succ)) (witt_polynomial p ℤ k) = ↑(n.succ) * witt_polynomial p ℤ k
p : ℕ,	hp : fact (nat.prime p),	k n : ℕ,	ih : ⇑(mv_polynomial.bind₁ (witt_vector.witt_mul_n p n)) (witt_polynomial p ℤ k) = ↑n * witt_polynomial p ℤ k	⊢ ⇑(mv_polynomial.bind₁ (witt_vector.witt_mul_n p n.succ)) (witt_polynomial p ℤ k) = ↑(n.succ) * witt_polynomial p ℤ k
p : ℕ,	hp : fact (nat.prime p),	k n : ℕ,	ih : ⇑(mv_polynomial.bind₁ (witt_vector.witt_mul_n p n)) (witt_polynomial p ℤ k) = ↑n * witt_polynomial p ℤ k	⊢ ⇑(mv_polynomial.bind₁ (function.uncurry ![witt_vector.witt_mul_n p n, mv_polynomial.X])) (⇑(mv_polynomial.bind₁ (λ (i : fin 2), ⇑(mv_polynomial.rename (prod.mk i)) (witt_polynomial p ℤ k))) (mv_polynomial.X 0 + mv_polynomial.X 1)) = ↑(n.succ) * witt_polynomial p ℤ k
p : ℕ,	hp : fact (nat.prime p),	k n : ℕ,	ih : ⇑(mv_polynomial.bind₁ (witt_vector.witt_mul_n p n)) (witt_polynomial p ℤ k) = ↑n * witt_polynomial p ℤ k	⊢ ⇑(mv_polynomial.bind₁ (function.uncurry ![witt_vector.witt_mul_n p n, mv_polynomial.X])) (⇑(mv_polynomial.rename (prod.mk 0)) (witt_polynomial p ℤ k)) + ⇑(mv_polynomial.bind₁ (function.uncurry ![witt_vector.witt_mul_n p n, mv_polynomial.X])) (⇑(mv_polynomial.rename (prod.mk 1)) (witt_polynomial p ℤ k)) = (↑n + 1) * witt_polynomial p ℤ k
p : ℕ,	hp : fact (nat.prime p),	k n : ℕ,	ih : ⇑(mv_polynomial.bind₁ (witt_vector.witt_mul_n p n)) (witt_polynomial p ℤ k) = ↑n * witt_polynomial p ℤ k	⊢ ⇑(mv_polynomial.bind₁ (function.uncurry ![witt_vector.witt_mul_n p n, mv_polynomial.X] ∘ prod.mk 0)) (witt_polynomial p ℤ k) + ⇑(mv_polynomial.bind₁ (function.uncurry ![witt_vector.witt_mul_n p n, mv_polynomial.X] ∘ prod.mk 1)) (witt_polynomial p ℤ k) = ↑n * witt_polynomial p ℤ k + witt_polynomial p ℤ k
p : ℕ,	idx : Type u_2,	hp : fact (nat.prime p),	Φ : mv_polynomial idx ℚ	⊢ ∃! (φ : ℕ → mv_polynomial (idx × ℕ) ℚ), ∀ (n : ℕ), ⇑(mv_polynomial.bind₁ φ) (witt_polynomial p ℚ n) = ⇑(mv_polynomial.bind₁ (λ (i : idx), ⇑(mv_polynomial.rename (prod.mk i)) (witt_polynomial p ℚ n))) Φ
p : ℕ,	idx : Type u_2,	hp : fact (nat.prime p),	Φ : mv_polynomial idx ℚ,	n : ℕ	⊢ ⇑(mv_polynomial.bind₁ (witt_structure_rat p Φ)) (witt_polynomial p ℚ n) = ⇑(mv_polynomial.bind₁ (λ (i : idx), ⇑(mv_polynomial.rename (prod.mk i)) (witt_polynomial p ℚ n))) Φ
p : ℕ,	idx : Type u_2,	hp : fact (nat.prime p),	Φ : mv_polynomial idx ℚ	⊢ (λ (φ : ℕ → mv_polynomial (idx × ℕ) ℚ), ∀ (n : ℕ), ⇑(mv_polynomial.bind₁ φ) (witt_polynomial p ℚ n) = ⇑(mv_polynomial.bind₁ (λ (i : idx), ⇑(mv_polynomial.rename (prod.mk i)) (witt_polynomial p ℚ n))) Φ) (witt_structure_rat p Φ)		p : ℕ,	idx : Type u_2,	hp : fact (nat.prime p),	Φ : mv_polynomial idx ℚ	⊢ ∀ (y : ℕ → mv_polynomial (idx × ℕ) ℚ), (λ (φ : ℕ → mv_polynomial (idx × ℕ) ℚ), ∀ (n : ℕ), ⇑(mv_polynomial.bind₁ φ) (witt_polynomial p ℚ n) = ⇑(mv_polynomial.bind₁ (λ (i : idx), ⇑(mv_polynomial.rename (prod.mk i)) (witt_polynomial p ℚ n))) Φ) y → y = witt_structure_rat p Φ
p : ℕ,	idx : Type u_2,	hp : fact (nat.prime p),	Φ : mv_polynomial idx ℚ	⊢ (λ (φ : ℕ → mv_polynomial (idx × ℕ) ℚ), ∀ (n : ℕ), ⇑(mv_polynomial.bind₁ φ) (witt_polynomial p ℚ n) = ⇑(mv_polynomial.bind₁ (λ (i : idx), ⇑(mv_polynomial.rename (prod.mk i)) (witt_polynomial p ℚ n))) Φ) (witt_structure_rat p Φ)
p : ℕ,	idx : Type u_2,	hp : fact (nat.prime p),	Φ : mv_polynomial idx ℚ	⊢ ∀ (y : ℕ → mv_polynomial (idx × ℕ) ℚ), (λ (φ : ℕ → mv_polynomial (idx × ℕ) ℚ), ∀ (n : ℕ), ⇑(mv_polynomial.bind₁ φ) (witt_polynomial p ℚ n) = ⇑(mv_polynomial.bind₁ (λ (i : idx), ⇑(mv_polynomial.rename (prod.mk i)) (witt_polynomial p ℚ n))) Φ) y → y = witt_structure_rat p Φ
p : ℕ,	idx : Type u_2,	hp : fact (nat.prime p),	Φ : mv_polynomial idx ℚ,	φ : ℕ → mv_polynomial (idx × ℕ) ℚ,	H : ∀ (n : ℕ), ⇑(mv_polynomial.bind₁ φ) (witt_polynomial p ℚ n) = ⇑(mv_polynomial.bind₁ (λ (i : idx), ⇑(mv_polynomial.rename (prod.mk i)) (witt_polynomial p ℚ n))) Φ	⊢ φ = witt_structure_rat p Φ
p : ℕ,	idx : Type u_2,	hp : fact (nat.prime p),	Φ : mv_polynomial idx ℚ,	φ : ℕ → mv_polynomial (idx × ℕ) ℚ,	H : ∀ (n : ℕ), ⇑(mv_polynomial.bind₁ φ) (witt_polynomial p ℚ n) = ⇑(mv_polynomial.bind₁ (λ (i : idx), ⇑(mv_polynomial.rename (prod.mk i)) (witt_polynomial p ℚ n))) Φ,	n : ℕ	⊢ φ n = witt_structure_rat p Φ n
p : ℕ,	idx : Type u_2,	hp : fact (nat.prime p),	Φ : mv_polynomial idx ℚ,	φ : ℕ → mv_polynomial (idx × ℕ) ℚ,	H : ∀ (n : ℕ), ⇑(mv_polynomial.bind₁ φ) (witt_polynomial p ℚ n) = ⇑(mv_polynomial.bind₁ (λ (i : idx), ⇑(mv_polynomial.rename (prod.mk i)) (witt_polynomial p ℚ n))) Φ,	n : ℕ	⊢ φ n = ⇑(mv_polynomial.bind₁ φ) (⇑(mv_polynomial.bind₁ (witt_polynomial p ℚ)) (X_in_terms_of_W p ℚ n))
p : ℕ,	idx : Type u_2,	hp : fact (nat.prime p),	Φ : mv_polynomial idx ℚ,	φ : ℕ → mv_polynomial (idx × ℕ) ℚ,	H : ∀ (n : ℕ), ⇑(mv_polynomial.bind₁ φ) (witt_polynomial p ℚ n) = ⇑(mv_polynomial.bind₁ (λ (i : idx), ⇑(mv_polynomial.rename (prod.mk i)) (witt_polynomial p ℚ n))) Φ,	n : ℕ	⊢ ⇑(mv_polynomial.bind₁ φ) (⇑(mv_polynomial.bind₁ (witt_polynomial p ℚ)) (X_in_terms_of_W p ℚ n)) = witt_structure_rat p Φ n
p : ℕ,	idx : Type u_2,	hp : fact (nat.prime p),	Φ : mv_polynomial idx ℚ,	φ : ℕ → mv_polynomial (idx × ℕ) ℚ,	H : ∀ (n : ℕ), ⇑(mv_polynomial.bind₁ φ) (witt_polynomial p ℚ n) = ⇑(mv_polynomial.bind₁ (λ (i : idx), ⇑(mv_polynomial.rename (prod.mk i)) (witt_polynomial p ℚ n))) Φ,	n : ℕ	⊢ ⇑(mv_polynomial.bind₁ (λ (i : ℕ), ⇑(mv_polynomial.bind₁ φ) (witt_polynomial p ℚ i))) (X_in_terms_of_W p ℚ n) = witt_structure_rat p Φ n
p : ℕ,	hp : fact (nat.prime p),	R : Type u_1,	_inst_1 : comm_ring R	⊢ (⨅ (i : ℕ), (witt_vector.truncate i).ker) = ⊥
p : ℕ,	hp : fact (nat.prime p),	R : Type u_1,	_inst_1 : comm_ring R	⊢ ∀ (x : witt_vector p R), (x ∈ ⨅ (i : ℕ), (witt_vector.truncate i).ker) → x = 0
p : ℕ,	hp : fact (nat.prime p),	R : Type u_1,	_inst_1 : comm_ring R,	x : witt_vector p R,	hx : x ∈ ⨅ (i : ℕ), (witt_vector.truncate i).ker	⊢ x = 0
p : ℕ,	hp : fact (nat.prime p),	R : Type u_1,	_inst_1 : comm_ring R,	x : witt_vector p R,	hx : x ∈ ⨅ (i : ℕ), (witt_vector.truncate i).ker,	n : ℕ	⊢ x.coeff n = 0.coeff n
p : ℕ,	hp : fact (nat.prime p),	R : Type u_1,	_inst_1 : comm_ring R,	x : witt_vector p R,	n : ℕ,	hx : ∀ (i i_1 : ℕ), i_1 < i → x.coeff i_1 = 0	⊢ x.coeff n = 0
p : ℕ,	hp : fact (nat.prime p),	R : Type u_1,	_inst_1 : comm_ring R,	S : Type u_2,	_inst_2 : semiring S,	f : Π (k : ℕ), S →+* truncated_witt_vector p k R,	f_compat : ∀ (k₁ k₂ : ℕ) (hk : k₁ ≤ k₂), (truncated_witt_vector.truncate hk).comp (f k₂) = f k₁,	g : S →+* witt_vector p R,	g_compat : ∀ (k : ℕ), (witt_vector.truncate k).comp g = f k	⊢ witt_vector.lift (λ (k₂ : ℕ), f k₂) f_compat = g
p : ℕ,	hp : fact (nat.prime p),	R : Type u_1,	_inst_1 : comm_ring R,	S : Type u_2,	_inst_2 : semiring S,	f : Π (k : ℕ), S →+* truncated_witt_vector p k R,	f_compat : ∀ (k₁ k₂ : ℕ) (hk : k₁ ≤ k₂), (truncated_witt_vector.truncate hk).comp (f k₂) = f k₁,	g : S →+* witt_vector p R,	g_compat : ∀ (k : ℕ), (witt_vector.truncate k).comp g = f k,	x : S	⊢ ⇑(witt_vector.lift (λ (k₂ : ℕ), f k₂) f_compat) x = ⇑g x
p : ℕ,	hp : fact (nat.prime p),	R : Type u_1,	_inst_1 : comm_ring R,	S : Type u_2,	_inst_2 : semiring S,	f : Π (k : ℕ), S →+* truncated_witt_vector p k R,	f_compat : ∀ (k₁ k₂ : ℕ) (hk : k₁ ≤ k₂), (truncated_witt_vector.truncate hk).comp (f k₂) = f k₁,	g : S →+* witt_vector p R,	g_compat : ∀ (k : ℕ), (witt_vector.truncate k).comp g = f k,	x : S	⊢ ∀ (i : ℕ), ⇑(witt_vector.lift (λ (k₂ : ℕ), f k₂) f_compat) x - ⇑g x ∈ (witt_vector.truncate i).ker
p : ℕ,	hp : fact (nat.prime p),	R : Type u_1,	_inst_1 : comm_ring R,	S : Type u_2,	_inst_2 : semiring S,	f : Π (k : ℕ), S →+* truncated_witt_vector p k R,	f_compat : ∀ (k₁ k₂ : ℕ) (hk : k₁ ≤ k₂), (truncated_witt_vector.truncate hk).comp (f k₂) = f k₁,	g : S →+* witt_vector p R,	g_compat : ∀ (k : ℕ), (witt_vector.truncate k).comp g = f k,	x : S,	i : ℕ	⊢ ⇑(witt_vector.lift (λ (k₂ : ℕ), f k₂) f_compat) x - ⇑g x ∈ (witt_vector.truncate i).ker
p : ℕ,	R : Type u_1,	_inst_1 : comm_ring R	⊢ witt_polynomial p R 1 = ⇑mv_polynomial.C ↑p * mv_polynomial.X 1 + mv_polynomial.X 0 ^ p
α : Type u,	s : finset α	⊢ ↑(s.card) = # ↥s
α β : Type u,	f : α → β,	s : set α,	t : set β,	h : t ⊆ set.range (λ (x : ↥s), f ↑x)	⊢ # ↥t ≤ # ↥{x ∈ s | f x ∈ t}
α β : Type u,	f : α → β,	s : set α,	t : set β,	h : t ⊆ f '' s	⊢ # ↥t ≤ # ↥{x ∈ s | f x ∈ t}
α β : Type u,	f : α → β,	s : set α,	t : set β,	h : t ⊆ set.range (λ (x : ↥s), f ↑x)	⊢ # ↥{x : ↥s | f x.val ∈ t} = # ↥((λ (x : ↥s), f ↑x) ⁻¹' t)
α β : Type u,	f : α → β,	s : set α,	t : set β,	h : t ⊆ set.range (λ (x : ↥s), f ↑x)	⊢ # ↥{x ∈ s | f x ∈ t} = # ↥((λ (x : ↥s), f ↑x) ⁻¹' t)
ι : Type u_1,	f g : ι → cardinal,	H : ∀ (i : ι), f i ≤ g i,	i : ι	⊢ nonempty (quotient.out (f i) ↪ quotient.out (g (⇑(function.embedding.refl ι) i)))
ι : Type u_1,	f g : ι → cardinal,	H : ∀ (i : ι), f i ≤ g i,	i : ι,	this : f i ≤ g i	⊢ nonempty (quotient.out (f i) ↪ quotient.out (g (⇑(function.embedding.refl ι) i)))
ι : Type u_1,	f g : ι → cardinal,	H : ∀ (i : ι), f i ≤ g i,	i : ι	⊢ nonempty (quotient.out (f i) ↪ quotient.out (g (⇑(function.embedding.refl ι) i)))
⊢ ⇑cardinal.to_nat 0 = 0
a : cardinal	⊢ ¬bit0 a = 0 ↔ ¬a = 0
a b : cardinal	⊢ a.aleph_idx ≤ b.aleph_idx ↔ a ≤ b
⊢ 0.cof ≤ 0
α : Type u_1,	r : α → α → Prop,	_inst_1 : is_well_order α r,	h : (ordinal.type r).is_limit,	_let_match : (∃ (S : set α), (∀ (a : α), ∃ (b : α) (H : b ∈ S), ¬r b a) ∧ # ↥S = (ordinal.type r).cof) → (∃ (S : set α), (∀ (a : α), ∃ (b : α) (H : b ∈ S), r a b) ∧ # ↥S = (ordinal.type r).cof),	S : set α,	H : ∀ (a : α), ∃ (b : α) (H : b ∈ S), ¬r b a,	e : # ↥S = (ordinal.type r).cof,	a : α,	a' : α := ordinal.enum r (ordinal.typein r a).succ _,	_let_match : (∃ (b : α) (H : b ∈ S), ¬r b a') → (∃ (b : α) (H : b ∈ S), r a b),	b : α,	h : b ∈ S,	ab : ¬r b a'	⊢ ordinal.typein r a < ordinal.typein r (ordinal.enum r (ordinal.typein r a).succ _)
α : Type u_1,	r : α → α → Prop,	_inst_1 : is_well_order α r,	h : (ordinal.type r).is_limit,	_let_match : (∃ (S : set α), (∀ (a : α), ∃ (b : α) (H : b ∈ S), ¬r b a) ∧ # ↥S = (ordinal.type r).cof) → (∃ (S : set α), (∀ (a : α), ∃ (b : α) (H : b ∈ S), r a b) ∧ # ↥S = (ordinal.type r).cof),	S : set α,	H : ∀ (a : α), ∃ (b : α) (H : b ∈ S), ¬r b a,	e : # ↥S = (ordinal.type r).cof,	a : α,	a' : α := ordinal.enum r (ordinal.typein r a).succ _,	_let_match : (∃ (b : α) (H : b ∈ S), ¬r b a') → (∃ (b : α) (H : b ∈ S), r a b),	b : α,	h : b ∈ S,	ab : ¬r b a'	⊢ ordinal.typein r a < (ordinal.typein r a).succ
α : Type u_1,	r : α → α → Prop,	_inst_1 : is_well_order α r,	h : (ordinal.type r).is_limit,	_let_match : (∃ (S : set α), (∀ (a : α), ∃ (b : α) (H : b ∈ S), ¬r b a) ∧ # ↥S = (ordinal.type r).cof) → (∃ (S : set α), (∀ (a : α), ∃ (b : α) (H : b ∈ S), r a b) ∧ # ↥S = (ordinal.type r).cof),	S : set α,	H : ∀ (a : α), ∃ (b : α) (H : b ∈ S), ¬r b a,	e : # ↥S = (ordinal.type r).cof,	a : α,	a' : α := ordinal.enum r (ordinal.typein r a).succ _,	_let_match : (∃ (b : α) (H : b ∈ S), ¬r b a') → (∃ (b : α) (H : b ∈ S), r a b),	b : α,	h : b ∈ S,	ab : ¬r b a'	⊢ ordinal.typein r a < ordinal.typein r (ordinal.enum r (ordinal.typein r a).succ _)
β α : Type u,	f : β → α,	w : # α < # β,	w' : ω ≤ # α	⊢ ∃ (a : α), # α < # ↥(f ⁻¹' {a})
β α : Type u,	f : β → α,	w : # α < # β,	w' : ω ≤ # α	⊢ ∃ (a : α), (# α).succ ≤ # ↥(f ⁻¹' {a})
β α : Type u_1,	f : β → α,	w : # α < # β,	w' : infinite α	⊢ ∃ (a : α), infinite ↥(f ⁻¹' {a})
β α : Type u_1,	f : β → α,	w : # α < # β,	w' : ω ≤ # α	⊢ ∃ (a : α), ω ≤ # ↥(f ⁻¹' {a})
β α : Type u_1,	f : β → α,	w : # α < # β,	w' : ω ≤ # α,	a : α,	ha : # α < # ↥(f ⁻¹' {a})	⊢ ∃ (a : α), ω ≤ # ↥(f ⁻¹' {a})
⊢ ∀ (x : game), 0 + x = x
x : pgame	⊢ 0 + quot.mk setoid.r x = quot.mk setoid.r x
x : pgame	⊢ setoid.r (0 + x) x
y : pgame,	x_α x_β : Type ?,	x_ᾰ : x_α → pgame,	x_ᾰ_1 : x_β → pgame	⊢ (pgame.mk x_α x_β x_ᾰ x_ᾰ_1 * y).left_moves ≃ (pgame.mk x_α x_β x_ᾰ x_ᾰ_1).left_moves × y.left_moves ⊕ (pgame.mk x_α x_β x_ᾰ x_ᾰ_1).right_moves × y.right_moves
x_α x_β : Type ?,	x_ᾰ : x_α → pgame,	x_ᾰ_1 : x_β → pgame,	y_α y_β : Type ?,	y_ᾰ : y_α → pgame,	y_ᾰ_1 : y_β → pgame	⊢ (pgame.mk x_α x_β x_ᾰ x_ᾰ_1 * pgame.mk y_α y_β y_ᾰ y_ᾰ_1).left_moves ≃ (pgame.mk x_α x_β x_ᾰ x_ᾰ_1).left_moves × (pgame.mk y_α y_β y_ᾰ y_ᾰ_1).left_moves ⊕ (pgame.mk x_α x_β x_ᾰ x_ᾰ_1).right_moves × (pgame.mk y_α y_β y_ᾰ y_ᾰ_1).right_moves
x y : pgame	⊢ (x * y).left_moves ≃ x.left_moves × y.left_moves ⊕ x.right_moves × y.right_moves
b : pgame.domineering.board,	m : ℤ × ℤ,	h : m ∈ pgame.domineering.left b	⊢ 2 ≤ finset.card b
b : pgame.domineering.board,	m : ℤ × ℤ,	h : m ∈ b ∩ finset.map pgame.domineering.shift_up b	⊢ 2 ≤ finset.card b
b : pgame.domineering.board,	m : ℤ × ℤ,	h : m ∈ b ∩ finset.map pgame.domineering.shift_up b	⊢ m ∈ b
b : pgame.domineering.board,	m : ℤ × ℤ,	h : m ∈ b ∩ finset.map pgame.domineering.shift_up b	⊢ m ∈ b		b : pgame.domineering.board,	m : ℤ × ℤ,	h : m ∈ b ∩ finset.map pgame.domineering.shift_up b,	w₁ : m ∈ b	⊢ 2 ≤ finset.card b
b : pgame.domineering.board,	m : ℤ × ℤ,	h : m ∈ b ∧ m ∈ finset.map pgame.domineering.shift_up b	⊢ m ∈ b
b : pgame.domineering.board,	m : ℤ × ℤ,	h : m ∈ b ∩ finset.map pgame.domineering.shift_up b,	w₁ : m ∈ b	⊢ 2 ≤ finset.card b
b : pgame.domineering.board,	m : ℤ × ℤ,	h : m ∈ b ∩ finset.map pgame.domineering.shift_up b,	w₁ : m ∈ b	⊢ (m.fst, m.snd - 1) ∈ finset.erase b m
b : pgame.domineering.board,	m : ℤ × ℤ,	h : m ∈ b ∩ finset.map pgame.domineering.shift_up b,	w₁ : m ∈ b	⊢ (m.fst, m.snd - 1) ≠ m ∧ (m.fst, m.snd - 1) ∈ b
b : pgame.domineering.board,	m : ℤ × ℤ,	h : m ∈ b ∩ finset.map pgame.domineering.shift_up b,	w₁ : m ∈ b	⊢ (m.fst, m.snd - 1) ≠ m		b : pgame.domineering.board,	m : ℤ × ℤ,	h : m ∈ b ∩ finset.map pgame.domineering.shift_up b,	w₁ : m ∈ b	⊢ (m.fst, m.snd - 1) ∈ b
b : pgame.domineering.board,	m : ℤ × ℤ,	h : m ∈ b ∩ finset.map pgame.domineering.shift_up b,	w₁ : m ∈ b	⊢ (m.fst, m.snd - 1) ≠ m
b : pgame.domineering.board,	m : ℤ × ℤ,	h : m ∈ b ∩ finset.map pgame.domineering.shift_up b,	w₁ : m ∈ b	⊢ (m.fst, m.snd - 1) ∈ b
b : pgame.domineering.board,	m : ℤ × ℤ,	w₁ : m ∈ b,	h : m ∈ b ∧ m ∈ finset.map pgame.domineering.shift_up b,	h₂ : m ∈ finset.map pgame.domineering.shift_up b	⊢ (m.fst, m.snd - 1) ∈ b
b : pgame.domineering.board,	m : ℤ × ℤ,	w₁ : m ∈ b,	h : m ∈ b ∧ m ∈ finset.map pgame.domineering.shift_up b	⊢ (m.fst, m.snd - 1) ∈ b
b : pgame.domineering.board,	m : ℤ × ℤ,	w₁ : m ∈ b,	h₂ : m ∈ finset.map pgame.domineering.shift_up b	⊢ (m.fst, m.snd - 1) ∈ b
b : pgame.domineering.board,	m : ℤ × ℤ,	w₁ : m ∈ b,	h₂ : ∃ (a : ℤ × ℤ) (H : a ∈ b), ⇑pgame.domineering.shift_up a = m	⊢ (m.fst, m.snd - 1) ∈ b
b : pgame.domineering.board,	m' : ℤ × ℤ,	h₂ : m' ∈ b,	w₁ : ⇑pgame.domineering.shift_up m' ∈ b	⊢ ((⇑pgame.domineering.shift_up m').fst, (⇑pgame.domineering.shift_up m').snd - 1) ∈ b
b : pgame.domineering.board,	m : ℤ × ℤ,	h : m ∈ b ∩ finset.map pgame.domineering.shift_up b,	w₁ : m ∈ b	⊢ (m.fst, m.snd - 1) ∈ finset.erase b m		b : pgame.domineering.board,	m : ℤ × ℤ,	h : m ∈ b ∩ finset.map pgame.domineering.shift_up b,	w₁ : m ∈ b,	w₂ : (m.fst, m.snd - 1) ∈ finset.erase b m	⊢ 2 ≤ finset.card b
b : pgame.domineering.board,	m' : ℤ × ℤ,	h₂ : m' ∈ b,	w₁ : ⇑pgame.domineering.shift_up m' ∈ b	⊢ (m'.fst, m'.snd + 1 - 1) ∈ b
b : pgame.domineering.board,	m : ℤ × ℤ,	h : m ∈ b ∩ finset.map pgame.domineering.shift_up b,	w₁ : m ∈ b,	w₂ : (m.fst, m.snd - 1) ∈ finset.erase b m	⊢ 2 ≤ finset.card b
b : pgame.domineering.board,	m : ℤ × ℤ,	h : m ∈ b ∩ finset.map pgame.domineering.shift_up b,	w₁ : m ∈ b,	w₂ : (m.fst, m.snd - 1) ∈ finset.erase b m,	i₁ : (finset.erase b m).card < finset.card b	⊢ 2 ≤ finset.card b
b : pgame.domineering.board,	m : ℤ × ℤ,	h : m ∈ b ∩ finset.map pgame.domineering.shift_up b,	w₁ : m ∈ b,	w₂ : (m.fst, m.snd - 1) ∈ finset.erase b m,	i₁ : (finset.erase b m).card < finset.card b,	i₂ : 0 < (finset.erase b m).card	⊢ 2 ≤ finset.card b
⊢ 0.short
⊢ 1.short
⊢ 2.short
⊢ (-2).short
⊢ (pgame.of_lists [0] [1]).short
⊢ (pgame.of_lists [-2, -1] [1]).short
⊢ (0 + 0).short
⊢ decidable (1 ≤ 1)
S : Type u,	_inst_1 : pgame.state S,	of_aux : Π (n : ℕ) (s : S), pgame.state.turn_bound s ≤ n → pgame,	s : S,	h : pgame.state.turn_bound s ≤ 0,	t : {t // t ∈ pgame.state.L s}	⊢ pgame
S : Type u,	_inst_1 : pgame.state S,	of_aux : Π (n : ℕ) (s : S), pgame.state.turn_bound s ≤ n → pgame,	s : S,	h : pgame.state.turn_bound s ≤ 0,	t : {t // t ∈ pgame.state.L s}	⊢ false
S : Type u,	_inst_1 : pgame.state S,	of_aux : Π (n : ℕ) (s : S), pgame.state.turn_bound s ≤ n → pgame,	s : S,	h : pgame.state.turn_bound s ≤ 0,	t : {t // t ∈ pgame.state.R s}	⊢ pgame
S : Type u,	_inst_1 : pgame.state S,	of_aux : Π (n : ℕ) (s : S), pgame.state.turn_bound s ≤ n → pgame,	s : S,	h : pgame.state.turn_bound s ≤ 0,	t : {t // t ∈ pgame.state.R s}	⊢ false
α : Type u_1,	l₁ l₂ : lists' α bool.tt	⊢ lists.of' l₁ ~ lists.of' l₂ ↔ l₁ ⊆ l₂ ∧ l₂ ⊆ l₁
α : Type u_1,	l₁ l₂ : lists' α bool.tt,	h : lists.of' l₁ ~ lists.of' l₂	⊢ l₁ ⊆ l₂ ∧ l₂ ⊆ l₁
α : Type u_1,	l₁ : lists' α bool.tt,	h : lists.of' l₁ ~ lists.of' l₁	⊢ l₁ ⊆ l₁ ∧ l₁ ⊆ l₁		case lists.equiv.antisymm	α : Type u_1,	l₁ l₂ : lists' α bool.tt,	h₁ : l₁.subset l₂,	h₂ : l₂.subset l₁	⊢ l₁ ⊆ l₂ ∧ l₂ ⊆ l₁
α : Type u_1,	l₁ l₂ : lists' α bool.tt,	h₁ : l₁.subset l₂,	h₂ : l₂.subset l₁	⊢ l₁ ⊆ l₂ ∧ l₂ ⊆ l₁
α : Type u_1,	l₁ : lists' α bool.tt,	h : lists.of' l₁ ~ lists.of' l₁	⊢ l₁ ⊆ l₁ ∧ l₁ ⊆ l₁
α : Type u	⊢ is_well_order α well_ordering_rel
c : cardinal,	o : ordinal,	α β : Type u_1,	s : β → β → Prop,	_x : is_well_order β s,	_let_match : (∃ (r : α → α → Prop) [wo : is_well_order α r], (# α).ord = ordinal.type r) → (cardinal.ord ⟦α⟧ ≤ ordinal.type s ↔ ⟦α⟧ ≤ (ordinal.type s).card),	r : α → α → Prop,	_x : is_well_order α r,	e : (# α).ord = ordinal.type r	⊢ cardinal.ord ⟦α⟧ ≤ ordinal.type s ↔ ⟦α⟧ ≤ (ordinal.type s).card
c : cardinal,	o : ordinal,	α β : Type u_1,	s : β → β → Prop,	_x : is_well_order β s,	_let_match : (∃ (r : α → α → Prop) [wo : is_well_order α r], (# α).ord = ordinal.type r) → (cardinal.ord ⟦α⟧ ≤ ordinal.type s ↔ ⟦α⟧ ≤ (ordinal.type s).card),	r : α → α → Prop,	_x : is_well_order α r,	e : (# α).ord = ordinal.type r	⊢ cardinal.ord ⟦α⟧ ≤ ordinal.type s ↔ ⟦α⟧ ≤ (ordinal.type s).card
c : cardinal,	o : ordinal,	α β : Type u_1,	s : β → β → Prop,	_x : is_well_order β s,	_let_match : (∃ (r : α → α → Prop) [wo : is_well_order α r], (# α).ord = ordinal.type r) → (cardinal.ord ⟦α⟧ ≤ ordinal.type s ↔ ⟦α⟧ ≤ (ordinal.type s).card),	r : α → α → Prop,	_x : is_well_order α r,	e : (# α).ord = ordinal.type r	⊢ (# α).ord ≤ ordinal.type s ↔ # α ≤ # β
c : cardinal,	o : ordinal,	α β : Type u_1,	s : β → β → Prop,	_x : is_well_order β s,	_let_match : (∃ (r : α → α → Prop) [wo : is_well_order α r], (# α).ord = ordinal.type r) → (cardinal.ord ⟦α⟧ ≤ ordinal.type s ↔ ⟦α⟧ ≤ (ordinal.type s).card),	r : α → α → Prop,	_x : is_well_order α r,	e : (# α).ord = ordinal.type r	⊢ (# α).ord ≤ ordinal.type s ↔ # α ≤ # β
c : cardinal,	o : ordinal,	α β : Type u_1,	s : β → β → Prop,	_x : is_well_order β s,	_let_match : (∃ (r : α → α → Prop) [wo : is_well_order α r], (# α).ord = ordinal.type r) → (cardinal.ord ⟦α⟧ ≤ ordinal.type s ↔ ⟦α⟧ ≤ (ordinal.type s).card),	r : α → α → Prop,	_x : is_well_order α r,	e : (# α).ord = ordinal.type r	⊢ (# α).ord ≤ ordinal.type s → # α ≤ # β
c : cardinal,	o : ordinal,	α β : Type u_1,	s : β → β → Prop,	_x : is_well_order β s,	_let_match : (∃ (r : α → α → Prop) [wo : is_well_order α r], (# α).ord = ordinal.type r) → (cardinal.ord ⟦α⟧ ≤ ordinal.type s ↔ ⟦α⟧ ≤ (ordinal.type s).card),	r : α → α → Prop,	_x : is_well_order α r,	e : (# α).ord = ordinal.type r	⊢ # α ≤ # β → (# α).ord ≤ ordinal.type s
c : cardinal,	o : ordinal,	α β : Type u_1,	s : β → β → Prop,	_x : is_well_order β s,	_let_match : (∃ (r : α → α → Prop) [wo : is_well_order α r], (# α).ord = ordinal.type r) → (cardinal.ord ⟦α⟧ ≤ ordinal.type s ↔ ⟦α⟧ ≤ (ordinal.type s).card),	r : α → α → Prop,	_x : is_well_order α r,	e : (# α).ord = ordinal.type r,	h : ordinal.type r ≤ ordinal.type s	⊢ # α ≤ # β
c : cardinal,	o : ordinal,	α β : Type u_1,	s : β → β → Prop,	_x : is_well_order β s,	_let_match : (∃ (r : α → α → Prop) [wo : is_well_order α r], (# α).ord = ordinal.type r) → (cardinal.ord ⟦α⟧ ≤ ordinal.type s ↔ ⟦α⟧ ≤ (ordinal.type s).card),	r : α → α → Prop,	_x : is_well_order α r,	e : (# α).ord = ordinal.type r,	h : (# α).ord ≤ ordinal.type s	⊢ # α ≤ # β		c : cardinal,	o : ordinal,	α β : Type u_1,	s : β → β → Prop,	_x : is_well_order β s,	_let_match : (∃ (r : α → α → Prop) [wo : is_well_order α r], (# α).ord = ordinal.type r) → (cardinal.ord ⟦α⟧ ≤ ordinal.type s ↔ ⟦α⟧ ≤ (ordinal.type s).card),	r : α → α → Prop,	_x : is_well_order α r,	e : (# α).ord = ordinal.type r,	h : # α ≤ # β	⊢ (# α).ord ≤ ordinal.type s
c : cardinal,	o : ordinal,	α β : Type u_1,	s : β → β → Prop,	_x : is_well_order β s,	_let_match : (∃ (r : α → α → Prop) [wo : is_well_order α r], (# α).ord = ordinal.type r) → (cardinal.ord ⟦α⟧ ≤ ordinal.type s ↔ ⟦α⟧ ≤ (ordinal.type s).card),	r : α → α → Prop,	_x : is_well_order α r,	e : (# α).ord = ordinal.type r,	h : (# α).ord ≤ ordinal.type s	⊢ # α ≤ # β
c : cardinal,	o : ordinal,	α β : Type u_1,	s : β → β → Prop,	_x : is_well_order β s,	_let_match : (∃ (r : α → α → Prop) [wo : is_well_order α r], (# α).ord = ordinal.type r) → (cardinal.ord ⟦α⟧ ≤ ordinal.type s ↔ ⟦α⟧ ≤ (ordinal.type s).card),	r : α → α → Prop,	_x : is_well_order α r,	e : (# α).ord = ordinal.type r,	h : # α ≤ # β	⊢ (# α).ord ≤ ordinal.type s
c : cardinal,	o : ordinal,	α β : Type u_1,	s : β → β → Prop,	_x : is_well_order β s,	_let_match : (∃ (r : α → α → Prop) [wo : is_well_order α r], (# α).ord = ordinal.type r) → (cardinal.ord ⟦α⟧ ≤ ordinal.type s ↔ ⟦α⟧ ≤ (ordinal.type s).card),	r : α → α → Prop,	_x : is_well_order α r,	e : (# α).ord = ordinal.type r,	f : α ↪ β	⊢ (# α).ord ≤ ordinal.type s
c : cardinal,	o : ordinal,	α β : Type u_1,	s : β → β → Prop,	_x : is_well_order β s,	_let_match : (∃ (r : α → α → Prop) [wo : is_well_order α r], (# α).ord = ordinal.type r) → (cardinal.ord ⟦α⟧ ≤ ordinal.type s ↔ ⟦α⟧ ≤ (ordinal.type s).card),	r : α → α → Prop,	_x : is_well_order α r,	e : (# α).ord = ordinal.type r,	f : α ↪ β,	g : ⇑f ⁻¹'o s ↪r s	⊢ (# α).ord ≤ ordinal.type s
c : cardinal,	o : ordinal,	α β : Type u_1,	s : β → β → Prop,	_x : is_well_order β s,	_let_match : (∃ (r : α → α → Prop) [wo : is_well_order α r], (# α).ord = ordinal.type r) → (cardinal.ord ⟦α⟧ ≤ ordinal.type s ↔ ⟦α⟧ ≤ (ordinal.type s).card),	r : α → α → Prop,	_x : is_well_order α r,	e : (# α).ord = ordinal.type r,	f : α ↪ β,	g : ⇑f ⁻¹'o s ↪r s,	_inst : is_well_order α (⇑f ⁻¹'o s)	⊢ (# α).ord ≤ ordinal.type s
α : Type u_1,	β : Type u_2,	γ : Type u_3,	r : α → α → Prop,	s : β → β → Prop,	t : γ → γ → Prop,	f : r ≼i s,	g : s ≼i t,	a : α,	c : γ,	h : t c (⇑(f.to_rel_embedding.trans g.to_rel_embedding) a)	⊢ ∃ (a' : α), ⇑(f.to_rel_embedding.trans g.to_rel_embedding) a' = c
c₁ c₂ : cardinal	⊢ c₁.ord ≤ c₂.ord ↔ c₁ ≤ c₂
α : Type u_1,	β : Type u_2,	γ : Type u_3,	r : α → α → Prop,	s : β → β → Prop,	t : γ → γ → Prop,	f : r ≼i s,	g : s ≼i t,	a : α,	b : β,	h : t (⇑(g.to_rel_embedding) b) (⇑g (⇑f a))	⊢ ∃ (a' : α), ⇑g (⇑f a') = ⇑(g.to_rel_embedding) b
α : Type u_1,	β : Type u_2,	γ : Type u_3,	r : α → α → Prop,	s : β → β → Prop,	t : γ → γ → Prop,	f : r ≼i s,	g : s ≼i t,	a : α,	c : γ,	h : t c (⇑g (⇑f a))	⊢ ∃ (a' : α), ⇑g (⇑f a') = c
α : Type u_1,	β : Type u_2,	γ : Type u_3,	r : α → α → Prop,	s : β → β → Prop,	t : γ → γ → Prop,	f : r ≼i s,	g : s ≼i t,	a a' : α,	h : t (⇑(g.to_rel_embedding) (⇑(f.to_rel_embedding) a')) (⇑g (⇑f a)),	h : s (⇑(f.to_rel_embedding) a') (⇑f a)	⊢ ∃ (a'_1 : α), ⇑g (⇑f a'_1) = ⇑(g.to_rel_embedding) (⇑(f.to_rel_embedding) a')
α : Type u_1,	β : Type u_2,	γ : Type u_3,	r : α → α → Prop,	s : β → β → Prop,	t : γ → γ → Prop,	f : r ≼i s,	g : s ≼i t,	a : α,	b : β,	h : t (⇑(g.to_rel_embedding) b) (⇑g (⇑f a)),	h : s b (⇑f a)	⊢ ∃ (a' : α), ⇑g (⇑f a') = ⇑(g.to_rel_embedding) b
α : Type u_1,	β : Type u_2,	r : α → α → Prop,	s : β → β → Prop,	_inst_1 : is_well_order β s,	f g : r ≺i s	⊢ f = g
α : Type u_1,	β : Type u_2,	r : α → α → Prop,	s : β → β → Prop,	_inst_1 : is_well_order β s,	f g : r ≺i s	⊢ ⇑f = ⇑g
α : Type u_1,	β : Type u_2,	r : α → α → Prop,	s : β → β → Prop,	_inst_1 : is_well_order β s,	f g : r ≺i s	⊢ ⇑↑g = ⇑g
α : Type u_1,	β : Type u_2,	r : α → α → Prop,	s : β → β → Prop,	_inst_1 : is_well_order β s,	f g : r ≺i s	⊢ ⇑f = ⇑g		α : Type u_1,	β : Type u_2,	r : α → α → Prop,	s : β → β → Prop,	_inst_1 : is_well_order β s,	f g : r ≺i s,	ef : ⇑f = ⇑g	⊢ f = g
α : Type u_1,	β : Type u_2,	r : α → α → Prop,	s : β → β → Prop,	_inst_1 : is_well_order β s,	f g : r ≺i s	⊢ ⇑↑f = ⇑g
α : Type u_1,	β : Type u_2,	r : α → α → Prop,	s : β → β → Prop,	_inst_1 : is_well_order β s,	f g : r ≺i s,	ef : ⇑f = ⇑g	⊢ f = g
α : Type u_1,	β : Type u_2,	r : α → α → Prop,	s : β → β → Prop,	_inst_1 : is_well_order β s,	f g : r ≺i s,	ef : ⇑f = ⇑g	⊢ f.top = g.top
α : Type u_1,	β : Type u_2,	r : α → α → Prop,	s : β → β → Prop,	_inst_1 : is_well_order β s,	f g : r ≺i s,	ef : ⇑f = ⇑g,	x : β	⊢ s x f.top ↔ s x g.top
α : Type u_1,	β : Type u_2,	r : α → α → Prop,	s : β → β → Prop,	_inst_1 : is_well_order β s,	f g : r ≺i s,	ef : ⇑f = ⇑g	⊢ f.top = g.top		α : Type u_1,	β : Type u_2,	r : α → α → Prop,	s : β → β → Prop,	_inst_1 : is_well_order β s,	f g : r ≺i s,	ef : ⇑f = ⇑g,	et : f.top = g.top	⊢ f = g
α : Type u_1,	β : Type u_2,	r : α → α → Prop,	s : β → β → Prop,	_inst_1 : is_well_order β s,	g : r ≺i s,	f__to_rel_embedding : r ↪r s,	f_top : β,	f_down : ∀ (b : β), s b f_top ↔ ∃ (a : α), ⇑f__to_rel_embedding a = b,	ef : ⇑{to_rel_embedding := f__to_rel_embedding, top := f_top, down := f_down} = ⇑g,	et : {to_rel_embedding := f__to_rel_embedding, top := f_top, down := f_down}.top = g.top	⊢ {to_rel_embedding := f__to_rel_embedding, top := f_top, down := f_down} = g
α : Type u_1,	β : Type u_2,	r : α → α → Prop,	s : β → β → Prop,	_inst_1 : is_well_order β s,	f g : r ≺i s,	ef : ⇑f = ⇑g,	et : f.top = g.top	⊢ f = g
α : Type u_1,	β : Type u_2,	r : α → α → Prop,	s : β → β → Prop,	_inst_1 : is_well_order β s,	f__to_rel_embedding : r ↪r s,	f_top : β,	f_down : ∀ (b : β), s b f_top ↔ ∃ (a : α), ⇑f__to_rel_embedding a = b,	g__to_rel_embedding : r ↪r s,	g_top : β,	g_down : ∀ (b : β), s b g_top ↔ ∃ (a : α), ⇑g__to_rel_embedding a = b,	ef : ⇑{to_rel_embedding := f__to_rel_embedding, top := f_top, down := f_down} = ⇑{to_rel_embedding := g__to_rel_embedding, top := g_top, down := g_down},	et : {to_rel_embedding := f__to_rel_embedding, top := f_top, down := f_down}.top = {to_rel_embedding := g__to_rel_embedding, top := g_top, down := g_down}.top	⊢ {to_rel_embedding := f__to_rel_embedding, top := f_top, down := f_down} = {to_rel_embedding := g__to_rel_embedding, top := g_top, down := g_down}
α : Type u_1,	β : Type u_2,	r : α → α → Prop,	s : β → β → Prop,	_inst_1 : is_well_order β s,	f__to_rel_embedding : r ↪r s,	f_top : β,	f_down : ∀ (b : β), s b f_top ↔ ∃ (a : α), ⇑f__to_rel_embedding a = b,	g__to_rel_embedding : r ↪r s,	g_top : β,	g_down : ∀ (b : β), s b g_top ↔ ∃ (a : α), ⇑g__to_rel_embedding a = b,	ef : ⇑{to_rel_embedding := f__to_rel_embedding, top := f_top, down := f_down} = ⇑{to_rel_embedding := g__to_rel_embedding, top := g_top, down := g_down},	et : {to_rel_embedding := f__to_rel_embedding, top := f_top, down := f_down}.top = {to_rel_embedding := g__to_rel_embedding, top := g_top, down := g_down}.top	⊢ {to_rel_embedding := f__to_rel_embedding, top := f_top, down := f_down} = {to_rel_embedding := g__to_rel_embedding, top := g_top, down := g_down}
α : Type u_1,	β : Type u_2,	r : α → α → Prop,	s : β → β → Prop,	_inst_1 : is_well_order β s,	f__to_rel_embedding : r ↪r s,	f_top : β,	f_down : ∀ (b : β), s b f_top ↔ ∃ (a : α), ⇑f__to_rel_embedding a = b,	g__to_rel_embedding : r ↪r s,	g_top : β,	g_down : ∀ (b : β), s b g_top ↔ ∃ (a : α), ⇑g__to_rel_embedding a = b,	ef : ⇑{to_rel_embedding := f__to_rel_embedding, top := f_top, down := f_down} = ⇑{to_rel_embedding := g__to_rel_embedding, top := g_top, down := g_down},	et : {to_rel_embedding := f__to_rel_embedding, top := f_top, down := f_down}.top = {to_rel_embedding := g__to_rel_embedding, top := g_top, down := g_down}.top,	this : has_coe_t_aux.coe {to_rel_embedding := f__to_rel_embedding, top := f_top, down := f_down} = has_coe_t_aux.coe {to_rel_embedding := g__to_rel_embedding, top := g_top, down := g_down}	⊢ {to_rel_embedding := f__to_rel_embedding, top := f_top, down := f_down} = {to_rel_embedding := g__to_rel_embedding, top := g_top, down := g_down}
a b : ordinal	⊢ a.lift = b.lift ↔ a = b
a : cardinal,	b : ordinal,	h : b.card ≤ a.lift,	_let_match : (∃ (a' : cardinal), a'.lift = b.card) → (∃ (a' : ordinal), a'.lift = b),	c : cardinal,	e : c.lift = b.card,	α : Type u,	β : Type (max u v),	s : β → β → Prop,	_x : is_well_order β s,	e' : cardinal.lift ⟦α⟧ = (ordinal.type s).card	⊢ ∃ (a' : ordinal), a'.lift = ordinal.type s
a : cardinal,	b : ordinal,	h : b.card ≤ a.lift,	_let_match : (∃ (a' : cardinal), a'.lift = b.card) → (∃ (a' : ordinal), a'.lift = b),	c : cardinal,	e : c.lift = b.card,	α : Type u,	β : Type (max u v),	s : β → β → Prop,	_x : is_well_order β s,	e' : cardinal.lift ⟦α⟧ = (ordinal.type s).card	⊢ ∃ (a' : ordinal), a'.lift = ordinal.type s
a : cardinal,	b : ordinal,	h : b.card ≤ a.lift,	_let_match : (∃ (a' : cardinal), a'.lift = b.card) → (∃ (a' : ordinal), a'.lift = b),	c : cardinal,	e : c.lift = b.card,	α : Type u,	β : Type (max u v),	s : β → β → Prop,	_x : is_well_order β s,	e' : nonempty (α ≃ β)	⊢ ∃ (a' : ordinal), a'.lift = ordinal.type s
a : cardinal,	b : ordinal,	h : b.card ≤ a.lift,	_let_match : (∃ (a' : cardinal), a'.lift = b.card) → (∃ (a' : ordinal), a'.lift = b),	c : cardinal,	e : c.lift = b.card,	α : Type u,	β : Type (max u v),	s : β → β → Prop,	_x : is_well_order β s,	f : α ≃ β	⊢ ∃ (a' : ordinal), a'.lift = ordinal.type s
a : cardinal,	b : ordinal,	h : b.card ≤ a.lift,	_let_match : (∃ (a' : cardinal), a'.lift = b.card) → (∃ (a' : ordinal), a'.lift = b),	c : cardinal,	e : c.lift = b.card,	α : Type u,	β : Type (max u v),	s : β → β → Prop,	_x : is_well_order β s,	f : α ≃ β,	g : ⇑f ⁻¹'o s ≃r s	⊢ ∃ (a' : ordinal), a'.lift = ordinal.type s
a : cardinal,	b : ordinal,	h : b.card ≤ a.lift,	_let_match : (∃ (a' : cardinal), a'.lift = b.card) → (∃ (a' : ordinal), a'.lift = b),	c : cardinal,	e : c.lift = b.card,	α : Type u,	β : Type (max u v),	s : β → β → Prop,	_x : is_well_order β s,	f : α ≃ β,	g : ⇑f ⁻¹'o s ≃r s,	_inst : is_well_order α (⇑f ⁻¹'o s)	⊢ ∃ (a' : ordinal), a'.lift = ordinal.type s
a : cardinal,	b : ordinal,	h : b.card ≤ a.lift,	_let_match : (∃ (a' : cardinal), a'.lift = b.card) → (∃ (a' : ordinal), a'.lift = b),	c : cardinal,	e : c.lift = b.card,	α : Type u,	β : Type (max u v),	s : β → β → Prop,	_x : is_well_order β s,	f : α ≃ β,	g : ⇑f ⁻¹'o s ≃r s,	_inst : is_well_order α (⇑f ⁻¹'o s),	this : (ordinal.type (⇑f ⁻¹'o s)).lift = (ordinal.type s).lift	⊢ ∃ (a' : ordinal), a'.lift = ordinal.type s
a : cardinal,	b : ordinal,	h : b.card ≤ a.lift,	_let_match : (∃ (a' : cardinal), a'.lift = b.card) → (∃ (a' : ordinal), a'.lift = b),	c : cardinal,	e : c.lift = b.card,	α : Type u,	β : Type (max u v),	s : β → β → Prop,	_x : is_well_order β s,	f : α ≃ β,	g : ⇑f ⁻¹'o s ≃r s,	_inst : is_well_order α (⇑f ⁻¹'o s),	this : (ordinal.type (⇑f ⁻¹'o s)).lift = ordinal.type s	⊢ ∃ (a' : ordinal), a'.lift = ordinal.type s
a b c : ordinal,	h₁ : 0 < a,	h₂ : b ≤ c	⊢ a ^ b ≤ a ^ c
a b c : ordinal,	h₁ : 0 < a,	h₂ : b ≤ c,	h₁ : 1 < a	⊢ a ^ b ≤ a ^ c		case or.inr	a b c : ordinal,	h₁ : 0 < a,	h₂ : b ≤ c,	h₁ : 1 = a	⊢ a ^ b ≤ a ^ c
a b c : ordinal,	h₁ : 0 < a,	h₂ : b ≤ c,	h₁ : 1 < a	⊢ a ^ b ≤ a ^ c
b c : ordinal,	h₂ : b ≤ c,	h₁ : 0 < 1	⊢ 1 ^ b ≤ 1 ^ c
a b c : ordinal,	h₁ : 0 < a,	h₂ : b ≤ c,	h₁ : 1 = a	⊢ a ^ b ≤ a ^ c
m n : ℕ,	n0 : n = 0	⊢ ↑(m / n) = ↑m / ↑n
m n : ℕ,	n0 : ¬n = 0,	n0' : ↑n ≠ 0	⊢ ↑(m / n) ≤ ↑m / ↑n
m n : ℕ,	n0 : ¬n = 0,	n0' : ↑n ≠ 0	⊢ ↑(m / n) ≤ ↑m / ↑n
m n : ℕ,	n0 : ¬n = 0,	n0' : ↑n ≠ 0	⊢ m / n * n ≤ m
m n : ℕ,	n0 : ¬n = 0,	n0' : ↑n ≠ 0	⊢ ↑m / ↑n ≤ ↑(m / n)
m n : ℕ,	n0 : ¬n = 0,	n0' : ↑n ≠ 0	⊢ ↑m / ↑n ≤ ↑(m / n)
m n : ℕ,	n0 : ¬n = 0,	n0' : ↑n ≠ 0	⊢ m / n < (m / n).succ
a : ordinal,	a0 : 0 < a,	ha : a < ordinal.omega	⊢ ordinal.omega ≤ a * ordinal.omega
o : ordinal,	_x : ∃ (a : ordinal), o.lift = a.succ,	_fun_match : (∃ (a : ordinal), o.lift = a.succ) → (∃ (a : ordinal), o = a.succ),	a : ordinal,	h : o.lift = a.succ,	_let_match : (∃ (a' : ordinal), a'.lift = a) → (∃ (a : ordinal), o = a.succ),	b : ordinal,	e : b.lift = a	⊢ o.lift = b.succ.lift
o : ordinal,	_x : ∃ (a : ordinal), o = a.succ,	_fun_match : (∃ (a : ordinal), o = a.succ) → (∃ (a : ordinal), o.lift = a.succ),	a : ordinal,	h : o = a.succ	⊢ o.lift = a.lift.succ
C : ordinal → Sort u_2,	H₁ : C 0,	H₂ : Π (o : ordinal), C o → C o.succ,	H₃ : Π (o : ordinal), o.is_limit → (Π (o' : ordinal), o' < o → C o') → C o	⊢ 0.limit_rec_on H₁ H₂ H₃ = H₁
C : ordinal → Sort u_2,	H₁ : C 0,	H₂ : Π (o : ordinal), C o → C o.succ,	H₃ : Π (o : ordinal), o.is_limit → (Π (o' : ordinal), o' < o → C o') → C o	⊢ 0.limit_rec_on H₁ H₂ H₃ = H₁
C : ordinal → Sort u_2,	H₁ : C 0,	H₂ : Π (o : ordinal), C o → C o.succ,	H₃ : Π (o : ordinal), o.is_limit → (Π (o' : ordinal), o' < o → C o') → C o	⊢ _.mpr H₁ = H₁
a b : ordinal,	l : a.is_limit,	h : b < a	⊢ b + 0 < a
a b : ordinal,	l : a.is_limit,	h : b < a,	c : ordinal,	h : c < a - b	⊢ c.succ < a - b
a b : ordinal,	l : a.is_limit,	h : b < a,	c : ordinal,	h : c < a - b	⊢ c.succ < a - b
a b : ordinal,	l : a.is_limit,	h : b < a,	c : ordinal,	h : c < a - b	⊢ (b + c).succ < a
a : ordinal,	a0 : a ≠ 0	⊢ 0 ^ a = 0
a b : ordinal,	a0 : a ≠ 0,	h : b.is_limit	⊢ a ^ b = b.bsup (λ (c : ordinal) (_x : c < b), a ^ c)
a b : ordinal,	a0 : a ≠ 0,	h : b.is_limit	⊢ a ^ b = b.bsup (λ (c : ordinal) (_x : c < b), a ^ c)
a b : ordinal,	a0 : a ≠ 0,	h : b.is_limit	⊢ b.limit_rec_on 1 (λ (_x IH : ordinal), IH * a) (λ (b : ordinal) (_x : b.is_limit), b.bsup) = b.bsup (λ (c : ordinal) (_x : c < b), c.limit_rec_on 1 (λ (_x IH : ordinal), IH * a) (λ (b : ordinal) (_x : b.is_limit), b.bsup))
a b : ordinal,	a0 : a ≠ 0,	h : b.is_limit	⊢ a ^ b = b.bsup (λ (c : ordinal) (_x : c < b), a ^ c)
mul_NF : ∀ (o₁ o₂ : onote) [_inst_1 : onote.NF o₁] [_inst_2 : onote.NF o₂], onote.NF (o₁ * o₂),	o : onote,	h₁ : onote.NF 0,	h₂ : onote.NF o	⊢ onote.NF (0 * o)
mul_NF : ∀ (o₁ o₂ : onote) [_inst_1 : onote.NF o₁] [_inst_2 : onote.NF o₂], onote.NF (o₁ * o₂),	o : onote,	h₁ : onote.NF 0,	h₂ : onote.NF o	⊢ onote.NF (0 * o)
mul_NF : ∀ (o₁ o₂ : onote) [_inst_1 : onote.NF o₁] [_inst_2 : onote.NF o₂], onote.NF (o₁ * o₂),	h₁ : onote.NF 0,	h₂ : onote.NF onote.zero	⊢ onote.NF (0 * onote.zero)
mul_NF : ∀ (o₁ o₂ : onote) [_inst_1 : onote.NF o₁] [_inst_2 : onote.NF o₂], onote.NF (o₁ * o₂),	h₁ : onote.NF 0,	o_ᾰ : onote,	o_ᾰ_1 : ℕ+,	o_ᾰ_2 : onote,	h₂ : onote.NF (o_ᾰ.oadd o_ᾰ_1 o_ᾰ_2)	⊢ onote.NF (0 * o_ᾰ.oadd o_ᾰ_1 o_ᾰ_2)
x : Set,	h : ∅ ∉ x,	y : Set,	yx : y ∈ x,	n : ¬∃ (y_1 : Set), (λ (z : Set), z ∈ y) y_1	⊢ ∅ ∈ x
α : Type u,	β : Type v,	_inst_1 : complete_lattice α,	s : set β,	f : β → α	⊢ has_Inf.Inf (f '' s) = ⨅ (a : β) (H : a ∈ s), f a
α : Type u,	β : Type v,	_inst_1 : complete_lattice α,	s : set β,	f : β → α	⊢ (⨅ (a : α) (i : β) (h₁ : i ∈ s) (h₂ : f i = a), a) = ⨅ (a : β) (H : a ∈ s), f a
α : Type u,	β : Type v,	_inst_1 : complete_lattice α,	s : set β,	f : β → α	⊢ has_Sup.Sup (f '' s) = ⨆ (a : β) (H : a ∈ s), f a
α : Type u,	β : Type v,	_inst_1 : complete_lattice α,	s : set β,	f : β → α	⊢ (⨆ (a : α) (i : β) (h₁ : i ∈ s) (h₂ : f i = a), a) = ⨆ (a : β) (H : a ∈ s), f a
n : ℕ	⊢ ↑(bit0 n) = bit0 ↑n
n : ℕ	⊢ ↑(bit1 n) = bit1 ↑n
n1 n2 : ℕ,	z1 z2 : ℤ,	hn : n1 < n2,	h1 : ↑n1 = z1,	h2 : ↑n2 = z2	⊢ z1 < z2
α : Type u_1,	_inst_1 : ordered_semiring α,	a b : α,	ha : a = 0,	hb : b ≤ 0	⊢ a + b ≤ 0
α : Sort u,	R : α → α → Sort v,	x y x' y' : α,	h : R x y,	hx : x = x',	hy : y = y'	⊢ R x y
α : Sort u,	R : α → α → Sort v,	x y x' y' : α,	h : R x y,	hx : x = x',	hy : y = y'	⊢ R x' y'
n : ℕ,	a : fin n,	n' a' b k nk : ℕ,	hn : n = n',	h : tactic.norm_fin.normalize_fin n a a',	e1 : n' * k = nk,	e2 : nk + b = a'	⊢ tactic.norm_fin.normalize_fin n a b
n : ℕ,	a b : fin n,	a' b' c' : ℕ,	ha : tactic.norm_fin.normalize_fin n a a',	hb : tactic.norm_fin.normalize_fin n b b',	h : a' + b' = c'	⊢ tactic.norm_fin.normalize_fin n (a + b) c'
n : ℕ,	a b : fin n,	a' b' c' : ℕ,	ha : a.val = a' % n,	hb : b.val = b' % n,	h : a' + b' = a' + b'	⊢ (a + b).val = (a' + b') % n
n : ℕ,	a b : fin n,	a' b' c' : ℕ,	ha : tactic.norm_fin.normalize_fin n a a',	hb : tactic.norm_fin.normalize_fin n b b',	h : a' + b' = c'	⊢ tactic.norm_fin.normalize_fin n (a + b) c'
α : Type u_1,	_inst_1 : semiring α,	a b c : α,	h : a + b = c	⊢ bit0 a + bit0 b = bit0 (a + b)
α : Type u_1,	_inst_1 : semiring α,	a b : α,	h : a + 1 = b	⊢ 1 + bit0 a + 1 = bit0 (a + 1)
t s : omega.nat.preterm,	v : ℕ → ℕ,	h : omega.nat.preform.holds v (t =* s)	⊢ omega.nat.preform.holds v (omega.nat.neg_elim_core (t =* s))
t s : omega.nat.preterm,	v : ℕ → ℕ,	h : omega.nat.preform.holds v (t ≤* s)	⊢ omega.nat.preform.holds v (omega.nat.neg_elim_core (t ≤* s))
p q : omega.nat.preform,	ihp : p.implies (omega.nat.neg_elim_core p),	ihq : q.implies (omega.nat.neg_elim_core q),	v : ℕ → ℕ,	h : omega.nat.preform.holds v (p ∧* q)	⊢ omega.nat.preform.holds v (omega.nat.neg_elim_core (p ∧* q))
⊢ ∀ {p : omega.nat.preform}, p.implies (omega.nat.neg_elim_core p)
p : omega.nat.preform,	ih : p.implies (omega.nat.neg_elim_core p),	v : ℕ → ℕ,	h : omega.nat.preform.holds v (¬* p)	⊢ omega.nat.preform.holds v (omega.nat.neg_elim_core (¬* p))
v : ℕ → ℕ,	t s : omega.nat.preterm,	ih : (t =* s).implies (omega.nat.neg_elim_core (t =* s)),	h : omega.nat.preform.holds v (¬* (t =* s))	⊢ omega.nat.preform.holds v (omega.nat.neg_elim_core (¬* (t =* s)))
v : ℕ → ℕ,	t s : omega.nat.preterm,	ih : (t ≤* s).implies (omega.nat.neg_elim_core (t ≤* s)),	h : omega.nat.preform.holds v (¬* (t ≤* s))	⊢ omega.nat.preform.holds v (omega.nat.neg_elim_core (¬* (t ≤* s)))
v : ℕ → ℕ,	p : omega.nat.preform,	ih : (¬* p).implies (omega.nat.neg_elim_core (¬* p)),	h : omega.nat.preform.holds v (¬* ¬* p)	⊢ omega.nat.preform.holds v (omega.nat.neg_elim_core (¬* ¬* p))
v : ℕ → ℕ,	p_ᾰ p_ᾰ_1 : omega.nat.preform,	ih : (p_ᾰ ∨* p_ᾰ_1).implies (omega.nat.neg_elim_core (p_ᾰ ∨* p_ᾰ_1)),	h : omega.nat.preform.holds v (¬* (p_ᾰ ∨* p_ᾰ_1))	⊢ omega.nat.preform.holds v (omega.nat.neg_elim_core (¬* (p_ᾰ ∨* p_ᾰ_1)))
v : ℕ → ℕ,	p_ᾰ p_ᾰ_1 : omega.nat.preform,	ih : (p_ᾰ ∧* p_ᾰ_1).implies (omega.nat.neg_elim_core (p_ᾰ ∧* p_ᾰ_1)),	h : omega.nat.preform.holds v (¬* (p_ᾰ ∧* p_ᾰ_1))	⊢ omega.nat.preform.holds v (omega.nat.neg_elim_core (¬* (p_ᾰ ∧* p_ᾰ_1)))
v : ℕ → ℕ,	p_ᾰ p_ᾰ_1 : omega.nat.preform,	ih : (p_ᾰ ∧* p_ᾰ_1).implies (omega.nat.neg_elim_core (p_ᾰ ∧* p_ᾰ_1)),	h : omega.nat.preform.holds v (¬* (p_ᾰ ∧* p_ᾰ_1))	⊢ omega.nat.preform.holds v (omega.nat.neg_elim_core (¬* (p_ᾰ ∧* p_ᾰ_1)))
p : omega.nat.preform,	ih : p.implies (omega.nat.neg_elim_core p),	v : ℕ → ℕ,	h : omega.nat.preform.holds v (¬* p)	⊢ omega.nat.preform.holds v (omega.nat.neg_elim_core (¬* p))
v : ℕ → ℕ,	t s : omega.nat.preterm,	ih : (t =* s).implies (omega.nat.neg_elim_core (t =* s)),	h : omega.nat.preform.holds v (¬* (t =* s))	⊢ omega.nat.preform.holds v (omega.nat.neg_elim_core (¬* (t =* s)))
v : ℕ → ℕ,	t s : omega.nat.preterm,	ih : (t =* s).implies (omega.nat.neg_elim_core (t =* s)),	h : omega.nat.preform.holds v (¬* (t =* s))	⊢ omega.nat.preform.holds v (s.add_one ≤* t) ∨ omega.nat.preform.holds v (t.add_one ≤* s)
v : ℕ → ℕ,	t s : omega.nat.preterm,	ih : (t =* s).implies (omega.nat.neg_elim_core (t =* s)),	h : omega.nat.preform.holds v (¬* (t =* s))	⊢ omega.nat.preform.holds v (omega.nat.neg_elim_core (¬* (t =* s)))		case omega.nat.preform.not, omega.nat.preform.le	v : ℕ → ℕ,	t s : omega.nat.preterm,	ih : (t ≤* s).implies (omega.nat.neg_elim_core (t ≤* s)),	h : omega.nat.preform.holds v (¬* (t ≤* s))	⊢ omega.nat.preform.holds v (omega.nat.neg_elim_core (¬* (t ≤* s)))
v : ℕ → ℕ,	t s : omega.nat.preterm,	ih : (t ≤* s).implies (omega.nat.neg_elim_core (t ≤* s)),	h : omega.nat.preform.holds v (¬* (t ≤* s))	⊢ omega.nat.preform.holds v (omega.nat.neg_elim_core (¬* (t ≤* s)))
p : omega.nat.preform,	ih : p.implies (omega.nat.neg_elim_core p),	v : ℕ → ℕ,	h : omega.nat.preform.holds v (¬* p)	⊢ omega.nat.preform.holds v (omega.nat.neg_elim_core (¬* p))		case omega.nat.preform.or	p q : omega.nat.preform,	ihp : p.implies (omega.nat.neg_elim_core p),	ihq : q.implies (omega.nat.neg_elim_core q),	v : ℕ → ℕ,	h : omega.nat.preform.holds v (p ∨* q)	⊢ omega.nat.preform.holds v (omega.nat.neg_elim_core (p ∨* q))		case omega.nat.preform.and	p q : omega.nat.preform,	ihp : p.implies (omega.nat.neg_elim_core p),	ihq : q.implies (omega.nat.neg_elim_core q),	v : ℕ → ℕ,	h : omega.nat.preform.holds v (p ∧* q)	⊢ omega.nat.preform.holds v (omega.nat.neg_elim_core (p ∧* q))
p q : omega.nat.preform,	ihp : p.implies (omega.nat.neg_elim_core p),	ihq : q.implies (omega.nat.neg_elim_core q),	v : ℕ → ℕ,	h : omega.nat.preform.holds v (p ∨* q)	⊢ omega.nat.preform.holds v (omega.nat.neg_elim_core p ∨* omega.nat.neg_elim_core q)
p q : omega.nat.preform,	ihp : p.implies (omega.nat.neg_elim_core p),	ihq : q.implies (omega.nat.neg_elim_core q),	v : ℕ → ℕ,	h : omega.nat.preform.holds v (p ∨* q)	⊢ omega.nat.preform.holds v (omega.nat.neg_elim_core p ∨* omega.nat.neg_elim_core q)
p q : omega.nat.preform,	ihp : p.implies (omega.nat.neg_elim_core p),	ihq : q.implies (omega.nat.neg_elim_core q),	v : ℕ → ℕ,	h : omega.nat.preform.holds v (p ∨* q)	⊢ omega.nat.preform.holds v (omega.nat.neg_elim_core p ∨* omega.nat.neg_elim_core q)
p q : omega.nat.preform,	ihp : p.implies (omega.nat.neg_elim_core p),	ihq : q.implies (omega.nat.neg_elim_core q),	v : ℕ → ℕ,	h : omega.nat.preform.holds v (p ∨* q)	⊢ omega.nat.preform.holds v (omega.nat.neg_elim_core (p ∨* q))
p q : omega.nat.preform,	ihp : p.implies (omega.nat.neg_elim_core p),	ihq : q.implies (omega.nat.neg_elim_core q),	v : ℕ → ℕ,	h : omega.nat.preform.holds v p	⊢ omega.nat.preform.holds v (omega.nat.neg_elim_core p)
p q : omega.nat.preform,	ihp : p.implies (omega.nat.neg_elim_core p),	ihq : q.implies (omega.nat.neg_elim_core q),	v : ℕ → ℕ,	h : omega.nat.preform.holds v q	⊢ omega.nat.preform.holds v (omega.nat.neg_elim_core p ∨* omega.nat.neg_elim_core q)
p q : omega.nat.preform,	ihp : p.implies (omega.nat.neg_elim_core p),	ihq : q.implies (omega.nat.neg_elim_core q),	v : ℕ → ℕ,	h : omega.nat.preform.holds v q	⊢ omega.nat.preform.holds v (omega.nat.neg_elim_core q)
p q : omega.nat.preform,	ihp : p.implies (omega.nat.neg_elim_core p),	ihq : q.implies (omega.nat.neg_elim_core q),	v : ℕ → ℕ,	h : omega.nat.preform.holds v p	⊢ omega.nat.preform.holds v (omega.nat.neg_elim_core p ∨* omega.nat.neg_elim_core q)
p q : omega.nat.preform,	ihp : p.implies (omega.nat.neg_elim_core p),	ihq : q.implies (omega.nat.neg_elim_core q),	v : ℕ → ℕ,	h : omega.nat.preform.holds v (p ∨* q)	⊢ omega.nat.preform.holds v (omega.nat.neg_elim_core (p ∨* q))		case omega.nat.preform.and	p q : omega.nat.preform,	ihp : p.implies (omega.nat.neg_elim_core p),	ihq : q.implies (omega.nat.neg_elim_core q),	v : ℕ → ℕ,	h : omega.nat.preform.holds v (p ∧* q)	⊢ omega.nat.preform.holds v (omega.nat.neg_elim_core (p ∧* q))
p q : omega.nat.preform,	ihp : p.implies (omega.nat.neg_elim_core p),	ihq : q.implies (omega.nat.neg_elim_core q),	v : ℕ → ℕ,	h : omega.nat.preform.holds v p	⊢ omega.nat.preform.holds v p
p q : omega.nat.preform,	ihp : p.implies (omega.nat.neg_elim_core p),	ihq : q.implies (omega.nat.neg_elim_core q),	v : ℕ → ℕ,	h : omega.nat.preform.holds v q	⊢ omega.nat.preform.holds v q
p q : omega.nat.preform,	ihp : p.implies (omega.nat.neg_elim_core p),	ihq : q.implies (omega.nat.neg_elim_core q),	v : ℕ → ℕ,	h : omega.nat.preform.holds v (p ∧* q)	⊢ omega.nat.preform.holds v (omega.nat.neg_elim_core (p ∧* q))
α : Type u_1,	_inst_1 : comm_semiring α,	a₁ x : α,	n : ℕ,	b₁ a₂ b₂ a' b' t : α,	h₁ : a₁ + a₂ = a',	h₂ : b₁ + b₂ = b',	h₃ : tactic.ring.horner a' x n b' = t	⊢ tactic.ring.horner a₁ x n b₁ + tactic.ring.horner a₂ x n b₂ = t
α : Type u_1,	_inst_1 : comm_semiring α,	a₁ x : α,	n : ℕ,	b₁ a₂ b₂ a' b' t : α,	h₁ : a₁ + a₂ = a',	h₂ : b₁ + b₂ = b',	h₃ : tactic.ring.horner a' x n b' = t	⊢ tactic.ring.horner a₁ x n b₁ + tactic.ring.horner a₂ x n b₂ = t
α : Type u_1,	_inst_1 : comm_semiring α,	a₁ x : α,	n : ℕ,	b₁ a₂ b₂ a' b' t : α,	h₁ : a₁ + a₂ = a',	h₂ : b₁ + b₂ = b',	h₃ : tactic.ring.horner a' x n b' = t	⊢ a₁ * x ^ n + b₁ + (a₂ * x ^ n + b₂) = a₁ * x ^ n + a₂ * x ^ n + (b₁ + b₂)
α : Type u_1,	_inst_1 : comm_semiring α,	t : tree α,	r₁ r₂ : tactic.ring2.csring_expr,	H : tactic.ring2.horner_expr.of_csexpr r₁ = tactic.ring2.horner_expr.of_csexpr r₂	⊢ tactic.ring2.csring_expr.eval t r₁ = tactic.ring2.csring_expr.eval t r₂
α : Type u_1,	_inst_1 : comm_semiring α,	t : tree α,	r₁ r₂ : tactic.ring2.csring_expr,	H : tactic.ring2.horner_expr.of_csexpr r₁ = tactic.ring2.horner_expr.of_csexpr r₂	⊢ tactic.ring2.horner_expr.cseval t (tactic.ring2.horner_expr.of_csexpr r₁) = tactic.ring2.csring_expr.eval t r₂
α : Type u_1,	_inst_1 : comm_semiring α,	t : tree α,	r₁ r₂ : tactic.ring2.csring_expr,	H : tactic.ring2.horner_expr.of_csexpr r₁ = tactic.ring2.horner_expr.of_csexpr r₂	⊢ tactic.ring2.horner_expr.cseval t (tactic.ring2.horner_expr.of_csexpr r₁) = tactic.ring2.horner_expr.cseval t (tactic.ring2.horner_expr.of_csexpr r₂)
α : Type u_1,	_inst_1 : comm_semiring α,	t : tree α,	r₁ r₂ : tactic.ring2.csring_expr,	H : tactic.ring2.horner_expr.of_csexpr r₁ = tactic.ring2.horner_expr.of_csexpr r₂	⊢ tactic.ring2.csring_expr.eval t r₁ = tactic.ring2.csring_expr.eval t r₂
α : Type u_1,	_inst_1 : comm_semiring α,	t : tree α,	r₁ r₂ : tactic.ring2.csring_expr,	H : tactic.ring2.horner_expr.of_csexpr r₁ = tactic.ring2.horner_expr.of_csexpr r₂	⊢ tactic.ring2.csring_expr.eval t r₁ = tactic.ring2.csring_expr.eval t r₂
α : Type u_1,	_inst_1 : comm_semiring α,	t : tree α,	r₁ r₂ : tactic.ring2.csring_expr,	H : tactic.ring2.horner_expr.of_csexpr r₁ = tactic.ring2.horner_expr.of_csexpr r₂	⊢ tactic.ring2.horner_expr.cseval t (tactic.ring2.horner_expr.of_csexpr r₁) = tactic.ring2.horner_expr.cseval t (tactic.ring2.horner_expr.of_csexpr r₂)
n m : ℕ	⊢ n + (m + 1) ≠ n
n m : ℕ	⊢ n < n + (m + 1)
n m : ℕ	⊢ 0 < m + 1
n m : ℕ	⊢ m + 1 ≠ 0
α : Type u,	_inst_1 : decidable_eq α,	xs ys : list α,	h₀ : xs.nodup,	h₁ : xs ~ ys,	x : α	⊢ slim_check.injective_function.list.apply_id (xs.zip ys) x ∈ ys ↔ x ∈ xs
α : Type u,	_inst_1 : decidable_eq α,	xs ys : list α,	h₀ : xs.nodup,	h₁ : xs ~ ys,	x : α	⊢ (list.lookup x (list.map prod.to_sigma (xs.zip ys))).get_or_else x ∈ ys ↔ x ∈ xs
α : Type u,	_inst_1 : decidable_eq α,	xs ys : list α,	h₀ : xs.nodup,	h₁ : xs ~ ys,	x : α,	h₃ : list.lookup x (list.map prod.to_sigma (xs.zip ys)) = option.none	⊢ option.none.get_or_else x ∈ ys ↔ x ∈ xs
α : Type u,	_inst_1 : decidable_eq α,	xs ys : list α,	h₀ : xs.nodup,	h₁ : xs ~ ys,	x : α,	h₃ : list.lookup x (list.map prod.to_sigma (xs.zip ys)) = option.none	⊢ option.none.get_or_else x ∈ ys ↔ x ∈ xs		case option.some	α : Type u,	_inst_1 : decidable_eq α,	xs ys : list α,	h₀ : xs.nodup,	h₁ : xs ~ ys,	x val : α,	h₃ : list.lookup x (list.map prod.to_sigma (xs.zip ys)) = option.some val	⊢ (option.some val).get_or_else x ∈ ys ↔ x ∈ xs
α : Type u,	_inst_1 : decidable_eq α,	xs ys : list α,	h₀ : xs.nodup,	h₁ : xs ~ ys,	x : α,	h₃ : list.lookup x (list.map prod.to_sigma (xs.zip ys)) = option.none	⊢ x ∈ ys ↔ x ∈ xs
α : Type u,	_inst_1 : decidable_eq α,	xs ys : list α,	h₀ : xs.nodup,	h₁ : xs ~ ys,	x val : α,	h₃ : list.lookup x (list.map prod.to_sigma (xs.zip ys)) = option.some val	⊢ (option.some val).get_or_else x ∈ ys ↔ x ∈ xs
α : Type u,	_inst_1 : decidable_eq α,	xs ys : list α,	h₀ : xs.nodup,	h₁ : xs ~ ys,	x val : α,	h₃ : list.lookup x (list.map prod.to_sigma (xs.zip ys)) = option.some val,	h₂ : ys.nodup	⊢ (option.some val).get_or_else x ∈ ys ↔ x ∈ xs
α : Type u,	_inst_1 : decidable_eq α,	xs ys : list α,	h₀ : xs.nodup,	x val : α,	h₃ : list.lookup x (list.map prod.to_sigma (xs.zip ys)) = option.some val,	h₂ : ys.nodup,	h₁ : xs.length = ys.length	⊢ (option.some val).get_or_else x ∈ ys ↔ x ∈ xs
α : Type u,	_inst_1 : decidable_eq α,	xs ys : list α,	h₀ : xs.nodup,	x val : α,	h₃ : list.lookup x (list.map prod.to_sigma (xs.zip ys)) = option.some val,	h₂ : ys.nodup,	h₁ : xs.length = ys.length	⊢ val ∈ ys ↔ x ∈ xs
α : Type u,	_inst_1 : decidable_eq α,	x val : α,	h₀ : list.nil.nodup,	ys : list α,	h₃ : list.lookup x (list.map prod.to_sigma (list.nil.zip ys)) = option.some val,	h₂ : ys.nodup,	h₁ : list.nil.length = ys.length	⊢ val ∈ ys ↔ x ∈ list.nil		case list.cons	α : Type u,	_inst_1 : decidable_eq α,	x val xs_hd : α,	xs_tl : list α,	xs_ih : xs_tl.nodup → ∀ {ys : list α}, list.lookup x (list.map prod.to_sigma (xs_tl.zip ys)) = option.some val → ys.nodup → xs_tl.length = ys.length → (val ∈ ys ↔ x ∈ xs_tl),	h₀ : (xs_hd :: xs_tl).nodup,	ys : list α,	h₃ : list.lookup x (list.map prod.to_sigma ((xs_hd :: xs_tl).zip ys)) = option.some val,	h₂ : ys.nodup,	h₁ : (xs_hd :: xs_tl).length = ys.length	⊢ val ∈ ys ↔ x ∈ xs_hd :: xs_tl
α : Type u,	_inst_1 : decidable_eq α,	x val : α,	h₀ : list.nil.nodup,	ys : list α,	h₃ : list.lookup x (list.map prod.to_sigma (list.nil.zip ys)) = option.some val,	h₂ : ys.nodup,	h₁ : list.nil.length = ys.length	⊢ val ∈ ys ↔ x ∈ list.nil
α : Type u,	_inst_1 : decidable_eq α,	x val xs_hd : α,	xs_tl : list α,	xs_ih : xs_tl.nodup → ∀ {ys : list α}, list.lookup x (list.map prod.to_sigma (xs_tl.zip ys)) = option.some val → ys.nodup → xs_tl.length = ys.length → (val ∈ ys ↔ x ∈ xs_tl),	h₀ : (xs_hd :: xs_tl).nodup,	ys : list α,	h₃ : list.lookup x (list.map prod.to_sigma ((xs_hd :: xs_tl).zip ys)) = option.some val,	h₂ : ys.nodup,	h₁ : (xs_hd :: xs_tl).length = ys.length	⊢ val ∈ ys ↔ x ∈ xs_hd :: xs_tl
α : Type u,	_inst_1 : decidable_eq α,	x val x' : α,	xs : list α,	xs_ih : xs.nodup → ∀ {ys : list α}, list.lookup x (list.map prod.to_sigma (xs.zip ys)) = option.some val → ys.nodup → xs.length = ys.length → (val ∈ ys ↔ x ∈ xs),	h₀ : (x' :: xs).nodup,	ys : list α,	h₃ : list.lookup x (list.map prod.to_sigma ((x' :: xs).zip ys)) = option.some val,	h₂ : ys.nodup,	h₁ : (x' :: xs).length = ys.length	⊢ val ∈ ys ↔ x ∈ x' :: xs
α : Type u,	_inst_1 : decidable_eq α,	x val x' : α,	xs : list α,	xs_ih : xs.nodup → ∀ {ys : list α}, list.lookup x (list.map prod.to_sigma (xs.zip ys)) = option.some val → ys.nodup → xs.length = ys.length → (val ∈ ys ↔ x ∈ xs),	h₀ : (x' :: xs).nodup,	h₃ : list.lookup x (list.map prod.to_sigma ((x' :: xs).zip list.nil)) = option.some val,	h₂ : list.nil.nodup,	h₁ : (x' :: xs).length = list.nil.length	⊢ val ∈ list.nil ↔ x ∈ x' :: xs		case list.cons, list.cons	α : Type u,	_inst_1 : decidable_eq α,	x val x' : α,	xs : list α,	xs_ih : xs.nodup → ∀ {ys : list α}, list.lookup x (list.map prod.to_sigma (xs.zip ys)) = option.some val → ys.nodup → xs.length = ys.length → (val ∈ ys ↔ x ∈ xs),	h₀ : (x' :: xs).nodup,	y : α,	ys : list α,	h₃ : list.lookup x (list.map prod.to_sigma ((x' :: xs).zip (y :: ys))) = option.some val,	h₂ : (y :: ys).nodup,	h₁ : (x' :: xs).length = (y :: ys).length	⊢ val ∈ y :: ys ↔ x ∈ x' :: xs
α : Type u,	_inst_1 : decidable_eq α,	x val x' : α,	xs : list α,	xs_ih : xs.nodup → ∀ {ys : list α}, list.lookup x (list.map prod.to_sigma (xs.zip ys)) = option.some val → ys.nodup → xs.length = ys.length → (val ∈ ys ↔ x ∈ xs),	h₀ : (x' :: xs).nodup,	h₃ : list.lookup x (list.map prod.to_sigma ((x' :: xs).zip list.nil)) = option.some val,	h₂ : list.nil.nodup,	h₁ : (x' :: xs).length = list.nil.length	⊢ val ∈ list.nil ↔ x ∈ x' :: xs
α : Type u,	_inst_1 : decidable_eq α,	x val x' : α,	xs : list α,	xs_ih : xs.nodup → ∀ {ys : list α}, list.lookup x (list.map prod.to_sigma (xs.zip ys)) = option.some val → ys.nodup → xs.length = ys.length → (val ∈ ys ↔ x ∈ xs),	h₀ : (x' :: xs).nodup,	y : α,	ys : list α,	h₂ : (y :: ys).nodup,	h₁ : (x' :: xs).length = (y :: ys).length,	h₃ : dite (x' = x) (λ (h : x' = x), option.some (eq.rec y h)) (λ (h : ¬x' = x), list.lookup x (list.map prod.to_sigma (xs.zip ys))) = option.some val	⊢ val ∈ y :: ys ↔ x ∈ x' :: xs
α : Type u,	_inst_1 : decidable_eq α,	x val x' : α,	xs : list α,	xs_ih : xs.nodup → ∀ {ys : list α}, list.lookup x (list.map prod.to_sigma (xs.zip ys)) = option.some val → ys.nodup → xs.length = ys.length → (val ∈ ys ↔ x ∈ xs),	h₀ : (x' :: xs).nodup,	y : α,	ys : list α,	h₃ : list.lookup x (list.map prod.to_sigma ((x' :: xs).zip (y :: ys))) = option.some val,	h₂ : (y :: ys).nodup,	h₁ : (x' :: xs).length = (y :: ys).length	⊢ val ∈ y :: ys ↔ x ∈ x' :: xs
α : Type u,	_inst_1 : decidable_eq α,	x val : α,	xs : list α,	xs_ih : xs.nodup → ∀ {ys : list α}, list.lookup x (list.map prod.to_sigma (xs.zip ys)) = option.some val → ys.nodup → xs.length = ys.length → (val ∈ ys ↔ x ∈ xs),	y : α,	ys : list α,	h₂ : (y :: ys).nodup,	h₀ : (x :: xs).nodup,	h₁ : (x :: xs).length = (y :: ys).length,	h₃ : eq.rec y _ = val	⊢ val ∈ y :: ys ↔ x ∈ x :: xs
α : Type u,	_inst_1 : decidable_eq α,	x val x' : α,	xs : list α,	xs_ih : xs.nodup → ∀ {ys : list α}, list.lookup x (list.map prod.to_sigma (xs.zip ys)) = option.some val → ys.nodup → xs.length = ys.length → (val ∈ ys ↔ x ∈ xs),	h₀ : (x' :: xs).nodup,	y : α,	ys : list α,	h₂ : (y :: ys).nodup,	h₁ : (x' :: xs).length = (y :: ys).length,	h : x' = x,	h₃ : eq.rec y h = val	⊢ val ∈ y :: ys ↔ x ∈ x' :: xs
α : Type u,	_inst_1 : decidable_eq α,	x val x' : α,	xs : list α,	xs_ih : xs.nodup → ∀ {ys : list α}, list.lookup x (list.map prod.to_sigma (xs.zip ys)) = option.some val → ys.nodup → xs.length = ys.length → (val ∈ ys ↔ x ∈ xs),	h₀ : (x' :: xs).nodup,	y : α,	ys : list α,	h₂ : (y :: ys).nodup,	h₁ : (x' :: xs).length = (y :: ys).length,	h : x' = x,	h₃ : eq.rec y h = val	⊢ val ∈ y :: ys ↔ x ∈ x' :: xs		α : Type u,	_inst_1 : decidable_eq α,	x val x' : α,	xs : list α,	xs_ih : xs.nodup → ∀ {ys : list α}, list.lookup x (list.map prod.to_sigma (xs.zip ys)) = option.some val → ys.nodup → xs.length = ys.length → (val ∈ ys ↔ x ∈ xs),	h₀ : (x' :: xs).nodup,	y : α,	ys : list α,	h₂ : (y :: ys).nodup,	h₁ : (x' :: xs).length = (y :: ys).length,	h : ¬x' = x,	h₃ : list.lookup x (list.map prod.to_sigma (xs.zip ys)) = option.some val	⊢ val ∈ y :: ys ↔ x ∈ x' :: xs
α : Type u,	_inst_1 : decidable_eq α,	x : α,	xs : list α,	y : α,	ys : list α,	h₂ : (y :: ys).nodup,	h₀ : (x :: xs).nodup,	h₁ : (x :: xs).length = (y :: ys).length,	xs_ih : xs.nodup → ∀ {ys : list α}, list.lookup x (list.map prod.to_sigma (xs.zip ys)) = option.some (eq.rec y _) → ys.nodup → xs.length = ys.length → (eq.rec y _ ∈ ys ↔ x ∈ xs)	⊢ eq.rec y _ ∈ y :: ys ↔ x ∈ x :: xs
α : Type u,	_inst_1 : decidable_eq α,	x val x' : α,	xs : list α,	xs_ih : xs.nodup → ∀ {ys : list α}, list.lookup x (list.map prod.to_sigma (xs.zip ys)) = option.some val → ys.nodup → xs.length = ys.length → (val ∈ ys ↔ x ∈ xs),	h₀ : (x' :: xs).nodup,	y : α,	ys : list α,	h₂ : (y :: ys).nodup,	h₁ : (x' :: xs).length = (y :: ys).length,	h : ¬x' = x,	h₃ : list.lookup x (list.map prod.to_sigma (xs.zip ys)) = option.some val	⊢ val ∈ y :: ys ↔ x ∈ x' :: xs
α : Type u,	_inst_1 : decidable_eq α,	x val x' : α,	xs : list α,	xs_ih : xs.nodup → ∀ {ys : list α}, list.lookup x (list.map prod.to_sigma (xs.zip ys)) = option.some val → ys.nodup → xs.length = ys.length → (val ∈ ys ↔ x ∈ xs),	y : α,	ys : list α,	h₂ : (y :: ys).nodup,	h₁ : (x' :: xs).length = (y :: ys).length,	h : ¬x' = x,	h₃ : list.lookup x (list.map prod.to_sigma (xs.zip ys)) = option.some val,	h₅ : list.pairwise ne xs,	h₀ : ∀ (a' : α), a' ∈ xs → x' ≠ a'	⊢ val ∈ y :: ys ↔ x ∈ x' :: xs
α : Type u,	_inst_1 : decidable_eq α,	x val x' : α,	xs : list α,	xs_ih : xs.nodup → ∀ {ys : list α}, list.lookup x (list.map prod.to_sigma (xs.zip ys)) = option.some val → ys.nodup → xs.length = ys.length → (val ∈ ys ↔ x ∈ xs),	y : α,	ys : list α,	h₁ : (x' :: xs).length = (y :: ys).length,	h : ¬x' = x,	h₃ : list.lookup x (list.map prod.to_sigma (xs.zip ys)) = option.some val,	h₅ : list.pairwise ne xs,	h₀ : ∀ (a' : α), a' ∈ xs → x' ≠ a',	h₄ : list.pairwise ne ys,	h₂ : ∀ (a' : α), a' ∈ ys → y ≠ a'	⊢ val ∈ y :: ys ↔ x ∈ x' :: xs
α : Type u,	_inst_1 : decidable_eq α,	x val x' : α,	xs : list α,	xs_ih : xs.nodup → ∀ {ys : list α}, list.lookup x (list.map prod.to_sigma (xs.zip ys)) = option.some val → ys.nodup → xs.length = ys.length → (val ∈ ys ↔ x ∈ xs),	y : α,	ys : list α,	h₁ : (x' :: xs).length = (y :: ys).length,	h : ¬x' = x,	h₃ : list.lookup x (list.map prod.to_sigma (xs.zip ys)) = option.some val,	h₅ : list.pairwise ne xs,	h₀ : ∀ (a' : α), a' ∈ xs → x' ≠ a',	h₄ : list.pairwise ne ys,	h₂ : ∀ (a' : α), a' ∈ ys → y ≠ a',	h₆ : xs.length = ys.length	⊢ val ∈ y :: ys ↔ x ∈ x' :: xs
α : Type u,	_inst_1 : decidable_eq α,	x val x' : α,	xs : list α,	y : α,	ys : list α,	h₁ : (x' :: xs).length = (y :: ys).length,	h : ¬x' = x,	h₃ : list.lookup x (list.map prod.to_sigma (xs.zip ys)) = option.some val,	h₅ : list.pairwise ne xs,	h₀ : ∀ (a' : α), a' ∈ xs → x' ≠ a',	h₄ : list.pairwise ne ys,	h₂ : ∀ (a' : α), a' ∈ ys → y ≠ a',	h₆ : xs.length = ys.length,	xs_ih : val ∈ ys ↔ x ∈ xs	⊢ val ∈ y :: ys ↔ x ∈ x' :: xs
α : Type u,	_inst_1 : decidable_eq α,	x val x' : α,	xs : list α,	y : α,	ys : list α,	h₁ : (x' :: xs).length = (y :: ys).length,	h : ¬x' = x,	h₃ : list.lookup x (list.map prod.to_sigma (xs.zip ys)) = option.some val,	h₅ : list.pairwise ne xs,	h₀ : ∀ (a' : α), a' ∈ xs → x' ≠ a',	h₄ : list.pairwise ne ys,	h₂ : ∀ (a' : α), a' ∈ ys → y ≠ a',	h₆ : xs.length = ys.length,	xs_ih : val ∈ ys ↔ x ∈ xs,	this : val ∈ ys	⊢ val = y ∨ x ∈ xs ↔ x ∈ xs		α : Type u,	_inst_1 : decidable_eq α,	x val x' : α,	xs : list α,	y : α,	ys : list α,	h₁ : (x' :: xs).length = (y :: ys).length,	h : ¬x' = x,	h₃ : list.lookup x (list.map prod.to_sigma (xs.zip ys)) = option.some val,	h₅ : list.pairwise ne xs,	h₀ : ∀ (a' : α), a' ∈ xs → x' ≠ a',	h₄ : list.pairwise ne ys,	h₂ : ∀ (a' : α), a' ∈ ys → y ≠ a',	h₆ : xs.length = ys.length,	xs_ih : val ∈ ys ↔ x ∈ xs	⊢ val ∈ ys
α : Type u,	_inst_1 : decidable_eq α,	x val x' : α,	xs : list α,	y : α,	ys : list α,	h₁ : (x' :: xs).length = (y :: ys).length,	h : ¬x' = x,	h₃ : list.lookup x (list.map prod.to_sigma (xs.zip ys)) = option.some val,	h₅ : list.pairwise ne xs,	h₀ : ∀ (a' : α), a' ∈ xs → x' ≠ a',	h₄ : list.pairwise ne ys,	h₂ : ∀ (a' : α), a' ∈ ys → y ≠ a',	h₆ : xs.length = ys.length,	xs_ih : val ∈ ys ↔ x ∈ xs	⊢ val = y ∨ x ∈ xs ↔ x ∈ xs
α : Type u,	_inst_1 : decidable_eq α,	x val x' : α,	xs : list α,	y : α,	ys : list α,	h₁ : (x' :: xs).length = (y :: ys).length,	h : ¬x' = x,	h₃ : list.lookup x (list.map prod.to_sigma (xs.zip ys)) = option.some val,	h₅ : list.pairwise ne xs,	h₀ : ∀ (a' : α), a' ∈ xs → x' ≠ a',	h₄ : list.pairwise ne ys,	h₂ : ∀ (a' : α), a' ∈ ys → y ≠ a',	h₆ : xs.length = ys.length,	xs_ih : val ∈ ys ↔ x ∈ xs	⊢ val ∈ ys
α : Type u,	_inst_1 : decidable_eq α,	x val x' : α,	xs : list α,	y : α,	ys : list α,	h₁ : (x' :: xs).length = (y :: ys).length,	h : ¬x' = x,	h₅ : list.pairwise ne xs,	h₀ : ∀ (a' : α), a' ∈ xs → x' ≠ a',	h₄ : list.pairwise ne ys,	h₂ : ∀ (a' : α), a' ∈ ys → y ≠ a',	h₆ : xs.length = ys.length,	xs_ih : val ∈ ys ↔ x ∈ xs,	h₃ : ⟨x, val⟩ ∈ list.map prod.to_sigma (xs.zip ys)	⊢ val ∈ ys		α : Type u,	_inst_1 : decidable_eq α,	x val x' : α,	xs : list α,	y : α,	ys : list α,	h₁ : (x' :: xs).length = (y :: ys).length,	h : ¬x' = x,	h₅ : list.pairwise ne xs,	h₀ : ∀ (a' : α), a' ∈ xs → x' ≠ a',	h₄ : list.pairwise ne ys,	h₂ : ∀ (a' : α), a' ∈ ys → y ≠ a',	h₆ : xs.length = ys.length,	xs_ih : val ∈ ys ↔ x ∈ xs,	h₃ : val ∈ list.lookup x (list.map prod.to_sigma (xs.zip ys))	⊢ (list.map prod.to_sigma (xs.zip ys)).nodupkeys
α : Type u,	_inst_1 : decidable_eq α,	x val x' : α,	xs : list α,	y : α,	ys : list α,	h₁ : (x' :: xs).length = (y :: ys).length,	h : ¬x' = x,	h₅ : list.pairwise ne xs,	h₀ : ∀ (a' : α), a' ∈ xs → x' ≠ a',	h₄ : list.pairwise ne ys,	h₂ : ∀ (a' : α), a' ∈ ys → y ≠ a',	h₆ : xs.length = ys.length,	xs_ih : val ∈ ys ↔ x ∈ xs,	h₃ : ∃ (a b : α), (a, b) ∈ xs.zip ys ∧ a = x ∧ b = val	⊢ val ∈ ys		α : Type u,	_inst_1 : decidable_eq α,	x val x' : α,	xs : list α,	y : α,	ys : list α,	h₁ : (x' :: xs).length = (y :: ys).length,	h : ¬x' = x,	h₅ : list.pairwise ne xs,	h₀ : ∀ (a' : α), a' ∈ xs → x' ≠ a',	h₄ : list.pairwise ne ys,	h₂ : ∀ (a' : α), a' ∈ ys → y ≠ a',	h₆ : xs.length = ys.length,	xs_ih : val ∈ ys ↔ x ∈ xs,	h₃ : val ∈ list.lookup x (list.map prod.to_sigma (xs.zip ys))	⊢ (list.map prod.to_sigma (xs.zip ys)).nodupkeys
α : Type u,	_inst_1 : decidable_eq α,	x val x' : α,	xs : list α,	y : α,	ys : list α,	h₁ : (x' :: xs).length = (y :: ys).length,	h : ¬x' = x,	h₅ : list.pairwise ne xs,	h₀ : ∀ (a' : α), a' ∈ xs → x' ≠ a',	h₄ : list.pairwise ne ys,	h₂ : ∀ (a' : α), a' ∈ ys → y ≠ a',	h₆ : xs.length = ys.length,	xs_ih : val ∈ ys ↔ x ∈ xs,	b : α,	h₃ : (x, b) ∈ xs.zip ys,	h₅ : b = val	⊢ val ∈ ys		α : Type u,	_inst_1 : decidable_eq α,	x val x' : α,	xs : list α,	y : α,	ys : list α,	h₁ : (x' :: xs).length = (y :: ys).length,	h : ¬x' = x,	h₅ : list.pairwise ne xs,	h₀ : ∀ (a' : α), a' ∈ xs → x' ≠ a',	h₄ : list.pairwise ne ys,	h₂ : ∀ (a' : α), a' ∈ ys → y ≠ a',	h₆ : xs.length = ys.length,	xs_ih : val ∈ ys ↔ x ∈ xs,	h₃ : val ∈ list.lookup x (list.map prod.to_sigma (xs.zip ys))	⊢ (list.map prod.to_sigma (xs.zip ys)).nodupkeys
α : Type u,	_inst_1 : decidable_eq α,	x val x' : α,	xs : list α,	y : α,	ys : list α,	h₁ : (x' :: xs).length = (y :: ys).length,	h : ¬x' = x,	h₅ : list.pairwise ne xs,	h₀ : ∀ (a' : α), a' ∈ xs → x' ≠ a',	h₄ : list.pairwise ne ys,	h₂ : ∀ (a' : α), a' ∈ ys → y ≠ a',	h₆ : xs.length = ys.length,	xs_ih : val ∈ ys ↔ x ∈ xs,	a b : α,	h₃ : (a, b) ∈ xs.zip ys,	h₄ : a = x,	h₅ : b = val	⊢ val ∈ ys		α : Type u,	_inst_1 : decidable_eq α,	x val x' : α,	xs : list α,	y : α,	ys : list α,	h₁ : (x' :: xs).length = (y :: ys).length,	h : ¬x' = x,	h₅ : list.pairwise ne xs,	h₀ : ∀ (a' : α), a' ∈ xs → x' ≠ a',	h₄ : list.pairwise ne ys,	h₂ : ∀ (a' : α), a' ∈ ys → y ≠ a',	h₆ : xs.length = ys.length,	xs_ih : val ∈ ys ↔ x ∈ xs,	h₃ : val ∈ list.lookup x (list.map prod.to_sigma (xs.zip ys))	⊢ (list.map prod.to_sigma (xs.zip ys)).nodupkeys
α : Type u,	_inst_1 : decidable_eq α,	x val x' : α,	xs : list α,	y : α,	ys : list α,	h₁ : (x' :: xs).length = (y :: ys).length,	h : ¬x' = x,	h₅ : list.pairwise ne xs,	h₀ : ∀ (a' : α), a' ∈ xs → x' ≠ a',	h₄ : list.pairwise ne ys,	h₂ : ∀ (a' : α), a' ∈ ys → y ≠ a',	h₆ : xs.length = ys.length,	xs_ih : val ∈ ys ↔ x ∈ xs,	h₃ : (x, val) ∈ xs.zip ys	⊢ val ∈ ys		α : Type u,	_inst_1 : decidable_eq α,	x val x' : α,	xs : list α,	y : α,	ys : list α,	h₁ : (x' :: xs).length = (y :: ys).length,	h : ¬x' = x,	h₅ : list.pairwise ne xs,	h₀ : ∀ (a' : α), a' ∈ xs → x' ≠ a',	h₄ : list.pairwise ne ys,	h₂ : ∀ (a' : α), a' ∈ ys → y ≠ a',	h₆ : xs.length = ys.length,	xs_ih : val ∈ ys ↔ x ∈ xs,	h₃ : val ∈ list.lookup x (list.map prod.to_sigma (xs.zip ys))	⊢ (list.map prod.to_sigma (xs.zip ys)).nodupkeys
α : Type u,	_inst_1 : decidable_eq α,	x val x' : α,	xs : list α,	y : α,	ys : list α,	h₁ : (x' :: xs).length = (y :: ys).length,	h : ¬x' = x,	h₅ : list.pairwise ne xs,	h₀ : ∀ (a' : α), a' ∈ xs → x' ≠ a',	h₄ : list.pairwise ne ys,	h₂ : ∀ (a' : α), a' ∈ ys → y ≠ a',	h₆ : xs.length = ys.length,	xs_ih : val ∈ ys ↔ x ∈ xs,	h₃ : val ∈ list.lookup x (list.map prod.to_sigma (xs.zip ys))	⊢ (list.map prod.to_sigma (xs.zip ys)).nodupkeys
α : Type u,	_inst_1 : decidable_eq α,	x val x' : α,	xs : list α,	y : α,	ys : list α,	h₁ : (x' :: xs).length = (y :: ys).length,	h : ¬x' = x,	h₅ : list.pairwise ne xs,	h₀ : ∀ (a' : α), a' ∈ xs → x' ≠ a',	h₄ : list.pairwise ne ys,	h₂ : ∀ (a' : α), a' ∈ ys → y ≠ a',	h₆ : xs.length = ys.length,	xs_ih : val ∈ ys ↔ x ∈ xs,	h₃ : val ∈ list.lookup x (list.map prod.to_sigma (xs.zip ys))	⊢ (list.map prod.fst (xs.zip ys)).nodup
X : Type u_1,	_inst_1 : topological_space X,	α : Type u_2,	f : alexandroff X → α,	l : filter α	⊢ filter.tendsto f (has_pure.pure ∞) l ∧ filter.tendsto (f ∘ coe) (filter.coclosed_compact X) l ↔ ∀ (s : set α), s ∈ l → (f ∞ ∈ s ∧ ∃ (t : set X), is_closed t ∧ is_compact t ∧ set.maps_to (f ∘ coe) tᶜ s)
X : Type u_1,	_inst_1 : topological_space X,	Y : Type u_2,	_inst_2 : topological_space Y,	f : alexandroff X → Y,	x : X	⊢ continuous_at f ↑x ↔ continuous_at (f ∘ coe) x
R : Type u_1,	_inst_1 : topological_space R,	_inst_2 : comm_semiring R,	A : Type u,	_inst_3 : topological_space A,	_inst_4 : semiring A,	_inst_5 : algebra R A,	_inst_6 : topological_ring A	⊢ continuous ⇑(algebra_map R A) ↔ continuous (λ (p : R × A), p.fst • p.snd)
R : Type u_1,	_inst_1 : topological_space R,	_inst_2 : comm_semiring R,	A : Type u,	_inst_3 : topological_space A,	_inst_4 : semiring A,	_inst_5 : algebra R A,	_inst_6 : topological_ring A,	h : continuous ⇑(algebra_map R A)	⊢ continuous (λ (p : R × A), ⇑(algebra_map R A) p.fst * p.snd)
R : Type u_1,	_inst_1 : topological_space R,	_inst_2 : comm_semiring R,	A : Type u,	_inst_3 : topological_space A,	_inst_4 : semiring A,	_inst_5 : algebra R A,	_inst_6 : topological_ring A,	h : continuous ⇑(algebra_map R A)	⊢ continuous (λ (p : R × A), p.fst • p.snd)
R : Type u_1,	_inst_1 : topological_space R,	_inst_2 : comm_semiring R,	A : Type u,	_inst_3 : topological_space A,	_inst_4 : semiring A,	_inst_5 : algebra R A,	_inst_6 : topological_ring A,	h : continuous ⇑(algebra_map R A)	⊢ continuous (λ (p : R × A), p.fst • p.snd)		R : Type u_1,	_inst_1 : topological_space R,	_inst_2 : comm_semiring R,	A : Type u,	_inst_3 : topological_space A,	_inst_4 : semiring A,	_inst_5 : algebra R A,	_inst_6 : topological_ring A,	h : continuous (λ (p : R × A), p.fst • p.snd)	⊢ continuous ⇑(algebra_map R A)
R : Type u_1,	_inst_1 : topological_space R,	_inst_2 : comm_semiring R,	A : Type u,	_inst_3 : topological_space A,	_inst_4 : semiring A,	_inst_5 : algebra R A,	_inst_6 : topological_ring A,	h : continuous (λ (p : R × A), p.fst • p.snd)	⊢ continuous (λ (r : R), r • 1)
R : Type u_1,	_inst_1 : topological_space R,	_inst_2 : comm_semiring R,	A : Type u,	_inst_3 : topological_space A,	_inst_4 : semiring A,	_inst_5 : algebra R A,	_inst_6 : topological_ring A,	h : continuous (λ (p : R × A), p.fst • p.snd)	⊢ continuous ⇑(algebra_map R A)
α : Type u_1,	_inst_1 : linear_ordered_ring α,	_inst_2 : floor_ring α,	_inst_3 : topological_space α,	_inst_4 : order_closed_topology α,	n : ℤ	⊢ filter.tendsto (λ (x : α), ↑⌊x⌋) (𝓝[set.Ici ↑n] ↑n) (𝓝 ↑n)
α : Type u_1,	_inst_1 : linear_ordered_ring α,	_inst_2 : floor_ring α,	_inst_3 : topological_space α,	_inst_4 : order_closed_topology α,	n : ℤ	⊢ filter.tendsto (λ (x : α), ↑⌊x⌋) (𝓝[set.Ico ↑n (↑n + 1)] ↑n) (𝓝 ↑n)
G : Type w,	_inst_1 : add_group_with_zero_nhd G,	_x : G × G,	_fun_match : ∀ (_a : G × G), continuous_at (λ (p : G × G), p.fst + p.snd) _a,	a b : G	⊢ continuous_at (λ (p : G × G), p.fst + p.snd) (a, b)
G : Type w,	_inst_1 : add_group_with_zero_nhd G,	_x : G × G,	_fun_match : ∀ (_a : G × G), continuous_at (λ (p : G × G), p.fst + p.snd) _a,	a b : G	⊢ filter.tendsto ((λ (p : G × G), p.fst + p.snd) ∘ λ (p : G × G), (p.fst + a, p.snd + b)) (Z G ×ᶠ Z G) (filter.map (λ (x : G), x + ((a, b).fst + (a, b).snd)) (Z G))
G : Type w,	_inst_1 : add_group_with_zero_nhd G,	_x : G × G,	_fun_match : ∀ (_a : G × G), continuous_at (λ (p : G × G), p.fst + p.snd) _a,	a b : G,	this : filter.tendsto ((λ (x : G), a + b + x) ∘ λ (p : G × G), p.fst + p.snd) (Z G ×ᶠ Z G) (filter.map (λ (x : G), a + b + x) (Z G))	⊢ filter.tendsto ((λ (p : G × G), p.fst + p.snd) ∘ λ (p : G × G), (p.fst + a, p.snd + b)) (Z G ×ᶠ Z G) (filter.map (λ (x : G), x + ((a, b).fst + (a, b).snd)) (Z G))		G : Type w,	_inst_1 : add_group_with_zero_nhd G,	_x : G × G,	_fun_match : ∀ (_a : G × G), continuous_at (λ (p : G × G), p.fst + p.snd) _a,	a b : G	⊢ filter.tendsto ((λ (x : G), a + b + x) ∘ λ (p : G × G), p.fst + p.snd) (Z G ×ᶠ Z G) (filter.map (λ (x : G), a + b + x) (Z G))
G : Type w,	_inst_1 : add_group_with_zero_nhd G,	_x : G × G,	_fun_match : ∀ (_a : G × G), continuous_at (λ (p : G × G), p.fst + p.snd) _a,	a b : G,	this : filter.tendsto ((λ (x : G), a + b + x) ∘ λ (p : G × G), p.fst + p.snd) (Z G ×ᶠ Z G) (filter.map (λ (x : G), a + b + x) (Z G))	⊢ filter.tendsto ((λ (p : G × G), p.fst + p.snd) ∘ λ (p : G × G), (p.fst + a, p.snd + b)) (Z G ×ᶠ Z G) (filter.map (λ (x : G), x + ((a, b).fst + (a, b).snd)) (Z G))
G : Type w,	_inst_1 : add_group_with_zero_nhd G,	_x : G × G,	_fun_match : ∀ (_a : G × G), continuous_at (λ (p : G × G), p.fst + p.snd) _a,	a b : G	⊢ filter.tendsto ((λ (x : G), a + b + x) ∘ λ (p : G × G), p.fst + p.snd) (Z G ×ᶠ Z G) (filter.map (λ (x : G), a + b + x) (Z G))
G : Type w,	_inst_1 : topological_space G,	_inst_2 : group G,	_inst_3 : topological_group G,	_inst_4 : t1_space G,	s : set G,	a : G,	hs : is_closed s,	ha : a ∉ s,	f : G × G → G := λ (p : G × G), p.fst * (p.snd)⁻¹,	hf : continuous f	⊢ (a, 1) ∈ f ⁻¹' sᶜ
G : Type w,	_inst_1 : topological_space G,	_inst_2 : group G,	_inst_3 : topological_group G,	_inst_4 : t1_space G,	s : set G,	a : G,	hs : is_closed s,	ha : a ∉ s,	f : G × G → G := λ (p : G × G), p.fst * (p.snd)⁻¹,	hf : continuous f,	_let_match : (∃ (u v : set G), is_open u ∧ is_open v ∧ a ∈ u ∧ 1 ∈ v ∧ u.prod v ⊆ f ⁻¹' sᶜ) → (∃ (t : set G), is_open t ∧ s ⊆ t ∧ 𝓝[t] a = ⊥),	t₁ t₂ : set G,	ht₁ : is_open t₁,	ht₂ : is_open t₂,	a_mem_t₁ : a ∈ t₁,	one_mem_t₂ : 1 ∈ t₂,	t_subset : t₁.prod t₂ ⊆ f ⁻¹' sᶜ	⊢ ∃ (t : set G), is_open t ∧ s ⊆ t ∧ 𝓝[t] a = ⊥
G : Type w,	_inst_1 : topological_space G,	_inst_2 : group G,	_inst_3 : topological_group G,	_inst_4 : t1_space G,	s : set G,	a : G,	hs : is_closed s,	ha : a ∉ s,	f : G × G → G := λ (p : G × G), p.fst * (p.snd)⁻¹,	hf : continuous f,	_let_match : (∃ (u v : set G), is_open u ∧ is_open v ∧ a ∈ u ∧ 1 ∈ v ∧ u.prod v ⊆ f ⁻¹' sᶜ) → (∃ (t : set G), is_open t ∧ s ⊆ t ∧ 𝓝[t] a = ⊥),	t₁ t₂ : set G,	ht₁ : is_open t₁,	ht₂ : is_open t₂,	a_mem_t₁ : a ∈ t₁,	one_mem_t₂ : 1 ∈ t₂,	t_subset : t₁.prod t₂ ⊆ f ⁻¹' sᶜ	⊢ 𝓝[s * t₂] a = ⊥
G : Type w,	_inst_1 : topological_space G,	_inst_2 : group G,	_inst_3 : topological_group G,	_inst_4 : t1_space G,	s : set G,	a : G,	hs : is_closed s,	ha : a ∉ s,	f : G × G → G := λ (p : G × G), p.fst * (p.snd)⁻¹,	hf : continuous f,	_let_match : (∃ (u v : set G), is_open u ∧ is_open v ∧ a ∈ u ∧ 1 ∈ v ∧ u.prod v ⊆ f ⁻¹' sᶜ) → (∃ (t : set G), is_open t ∧ s ⊆ t ∧ 𝓝[t] a = ⊥),	t₁ t₂ : set G,	ht₁ : is_open t₁,	ht₂ : is_open t₂,	a_mem_t₁ : a ∈ t₁,	one_mem_t₂ : 1 ∈ t₂,	t_subset : t₁.prod t₂ ⊆ f ⁻¹' sᶜ	⊢ ∃ (t : set G) (H : t ⊆ (s * t₂)ᶜ), is_open t ∧ a ∈ t
G : Type w,	_inst_1 : topological_space G,	_inst_2 : group G,	_inst_3 : topological_group G,	_inst_4 : t1_space G,	s : set G,	a : G,	hs : is_closed s,	ha : a ∉ s,	f : G × G → G := λ (p : G × G), p.fst * (p.snd)⁻¹,	hf : continuous f,	_let_match : (∃ (u v : set G), is_open u ∧ is_open v ∧ a ∈ u ∧ 1 ∈ v ∧ u.prod v ⊆ f ⁻¹' sᶜ) → (∃ (t : set G), is_open t ∧ s ⊆ t ∧ 𝓝[t] a = ⊥),	t₁ t₂ : set G,	ht₁ : is_open t₁,	ht₂ : is_open t₂,	a_mem_t₁ : a ∈ t₁,	one_mem_t₂ : 1 ∈ t₂,	t_subset : t₁.prod t₂ ⊆ f ⁻¹' sᶜ	⊢ t₁ ⊆ (s * t₂)ᶜ
G : Type w,	_inst_1 : topological_space G,	_inst_2 : group G,	_inst_3 : topological_group G,	_inst_4 : t1_space G,	s : set G,	a : G,	hs : is_closed s,	ha : a ∉ s,	f : G × G → G := λ (p : G × G), p.fst * (p.snd)⁻¹,	hf : continuous f,	_let_match : (∃ (u v : set G), is_open u ∧ is_open v ∧ a ∈ u ∧ 1 ∈ v ∧ u.prod v ⊆ f ⁻¹' sᶜ) → (∃ (t : set G), is_open t ∧ s ⊆ t ∧ 𝓝[t] a = ⊥),	t₁ t₂ : set G,	ht₁ : is_open t₁,	ht₂ : is_open t₂,	a_mem_t₁ : a ∈ t₁,	one_mem_t₂ : 1 ∈ t₂,	t_subset : t₁.prod t₂ ⊆ f ⁻¹' sᶜ,	x : G,	hx : x ∈ t₁,	y z : G,	hy : y ∈ s,	hz : z ∈ t₂,	yz : y * z = x	⊢ false
G : Type w,	_inst_1 : topological_space G,	_inst_2 : group G,	_inst_3 : topological_group G,	_inst_4 : t1_space G,	s : set G,	a : G,	hs : is_closed s,	ha : a ∉ s,	f : G × G → G := λ (p : G × G), p.fst * (p.snd)⁻¹,	hf : continuous f,	_let_match : (∃ (u v : set G), is_open u ∧ is_open v ∧ a ∈ u ∧ 1 ∈ v ∧ u.prod v ⊆ f ⁻¹' sᶜ) → (∃ (t : set G), is_open t ∧ s ⊆ t ∧ 𝓝[t] a = ⊥),	t₁ t₂ : set G,	ht₁ : is_open t₁,	ht₂ : is_open t₂,	a_mem_t₁ : a ∈ t₁,	one_mem_t₂ : 1 ∈ t₂,	t_subset : t₁.prod t₂ ⊆ f ⁻¹' sᶜ,	x : G,	hx : x ∈ t₁,	y z : G,	hy : y ∈ s,	hz : z ∈ t₂,	yz : y * z = x,	this : x * z⁻¹ ∈ sᶜ	⊢ x * z⁻¹ ∈ s		G : Type w,	_inst_1 : topological_space G,	_inst_2 : group G,	_inst_3 : topological_group G,	_inst_4 : t1_space G,	s : set G,	a : G,	hs : is_closed s,	ha : a ∉ s,	f : G × G → G := λ (p : G × G), p.fst * (p.snd)⁻¹,	hf : continuous f,	_let_match : (∃ (u v : set G), is_open u ∧ is_open v ∧ a ∈ u ∧ 1 ∈ v ∧ u.prod v ⊆ f ⁻¹' sᶜ) → (∃ (t : set G), is_open t ∧ s ⊆ t ∧ 𝓝[t] a = ⊥),	t₁ t₂ : set G,	ht₁ : is_open t₁,	ht₂ : is_open t₂,	a_mem_t₁ : a ∈ t₁,	one_mem_t₂ : 1 ∈ t₂,	t_subset : t₁.prod t₂ ⊆ f ⁻¹' sᶜ,	x : G,	hx : x ∈ t₁,	y z : G,	hy : y ∈ s,	hz : z ∈ t₂,	yz : y * z = x,	this : x * z⁻¹ ∈ sᶜ,	this : x * z⁻¹ ∈ s	⊢ false
G : Type w,	_inst_1 : topological_space G,	_inst_2 : group G,	_inst_3 : topological_group G,	_inst_4 : t1_space G,	s : set G,	a : G,	hs : is_closed s,	ha : a ∉ s,	f : G × G → G := λ (p : G × G), p.fst * (p.snd)⁻¹,	hf : continuous f,	_let_match : (∃ (u v : set G), is_open u ∧ is_open v ∧ a ∈ u ∧ 1 ∈ v ∧ u.prod v ⊆ f ⁻¹' sᶜ) → (∃ (t : set G), is_open t ∧ s ⊆ t ∧ 𝓝[t] a = ⊥),	t₁ t₂ : set G,	ht₁ : is_open t₁,	ht₂ : is_open t₂,	a_mem_t₁ : a ∈ t₁,	one_mem_t₂ : 1 ∈ t₂,	t_subset : t₁.prod t₂ ⊆ f ⁻¹' sᶜ,	x : G,	hx : x ∈ t₁,	y z : G,	hy : y ∈ s,	hz : z ∈ t₂,	yz : y * z = x,	this : x * z⁻¹ ∈ sᶜ	⊢ y * z * z⁻¹ ∈ s		G : Type w,	_inst_1 : topological_space G,	_inst_2 : group G,	_inst_3 : topological_group G,	_inst_4 : t1_space G,	s : set G,	a : G,	hs : is_closed s,	ha : a ∉ s,	f : G × G → G := λ (p : G × G), p.fst * (p.snd)⁻¹,	hf : continuous f,	_let_match : (∃ (u v : set G), is_open u ∧ is_open v ∧ a ∈ u ∧ 1 ∈ v ∧ u.prod v ⊆ f ⁻¹' sᶜ) → (∃ (t : set G), is_open t ∧ s ⊆ t ∧ 𝓝[t] a = ⊥),	t₁ t₂ : set G,	ht₁ : is_open t₁,	ht₂ : is_open t₂,	a_mem_t₁ : a ∈ t₁,	one_mem_t₂ : 1 ∈ t₂,	t_subset : t₁.prod t₂ ⊆ f ⁻¹' sᶜ,	x : G,	hx : x ∈ t₁,	y z : G,	hy : y ∈ s,	hz : z ∈ t₂,	yz : y * z = x,	this : x * z⁻¹ ∈ sᶜ,	this : x * z⁻¹ ∈ s	⊢ false
G : Type w,	_inst_1 : topological_space G,	_inst_2 : group G,	_inst_3 : topological_group G,	_inst_4 : t1_space G,	s : set G,	a : G,	hs : is_closed s,	ha : a ∉ s,	f : G × G → G := λ (p : G × G), p.fst * (p.snd)⁻¹,	hf : continuous f,	_let_match : (∃ (u v : set G), is_open u ∧ is_open v ∧ a ∈ u ∧ 1 ∈ v ∧ u.prod v ⊆ f ⁻¹' sᶜ) → (∃ (t : set G), is_open t ∧ s ⊆ t ∧ 𝓝[t] a = ⊥),	t₁ t₂ : set G,	ht₁ : is_open t₁,	ht₂ : is_open t₂,	a_mem_t₁ : a ∈ t₁,	one_mem_t₂ : 1 ∈ t₂,	t_subset : t₁.prod t₂ ⊆ f ⁻¹' sᶜ,	x : G,	hx : x ∈ t₁,	y z : G,	hy : y ∈ s,	hz : z ∈ t₂,	yz : y * z = x,	this : x * z⁻¹ ∈ sᶜ	⊢ false
G : Type w,	_inst_1 : topological_space G,	_inst_2 : group G,	_inst_3 : topological_group G,	_inst_4 : t1_space G,	s : set G,	a : G,	hs : is_closed s,	ha : a ∉ s,	f : G × G → G := λ (p : G × G), p.fst * (p.snd)⁻¹,	hf : continuous f,	_let_match : (∃ (u v : set G), is_open u ∧ is_open v ∧ a ∈ u ∧ 1 ∈ v ∧ u.prod v ⊆ f ⁻¹' sᶜ) → (∃ (t : set G), is_open t ∧ s ⊆ t ∧ 𝓝[t] a = ⊥),	t₁ t₂ : set G,	ht₁ : is_open t₁,	ht₂ : is_open t₂,	a_mem_t₁ : a ∈ t₁,	one_mem_t₂ : 1 ∈ t₂,	t_subset : t₁.prod t₂ ⊆ f ⁻¹' sᶜ,	x : G,	hx : x ∈ t₁,	y z : G,	hy : y ∈ s,	hz : z ∈ t₂,	yz : y * z = x,	this : x * z⁻¹ ∈ sᶜ,	this : x * z⁻¹ ∈ s	⊢ false
α : Type u_1,	β : Type u_2,	_inst_1 : add_comm_monoid α,	_inst_2 : topological_space α,	_inst_3 : t2_space α,	P : Prop,	_inst_4 : decidable P,	x : β → P → α	⊢ ∑' (b : β), dite P (λ (h : P), x b h) (λ (h : ¬P), 0) = dite P (λ (h : P), ∑' (b : β), x b h) (λ (h : ¬P), 0)
α : Type u_1,	β : Type u_2,	_inst_1 : add_comm_monoid α,	_inst_2 : topological_space α,	_inst_3 : t2_space α,	P : Prop,	_inst_4 : decidable P,	x : β → P → α,	hP : P	⊢ ∑' (b : β), dite P (λ (h : P), x b h) (λ (h : ¬P), 0) = dite P (λ (h : P), ∑' (b : β), x b h) (λ (h : ¬P), 0)
α : Type u_1,	β : Type u_2,	_inst_1 : add_comm_monoid α,	_inst_2 : topological_space α,	_inst_3 : t2_space α,	P : Prop,	_inst_4 : decidable P,	x : β → P → α,	hP : ¬P	⊢ ∑' (b : β), dite P (λ (h : P), x b h) (λ (h : ¬P), 0) = dite P (λ (h : P), ∑' (b : β), x b h) (λ (h : ¬P), 0)
α : Type u_1,	β : Type u_2,	_inst_1 : add_comm_monoid α,	_inst_2 : topological_space α,	_inst_3 : t2_space α,	P : Prop,	_inst_4 : decidable P,	x : β → P → α	⊢ ∑' (b : β), dite P (λ (h : P), x b h) (λ (h : ¬P), 0) = dite P (λ (h : P), ∑' (b : β), x b h) (λ (h : ¬P), 0)
α : Type u_1,	β : Type u_2,	_inst_1 : division_ring α,	_inst_2 : topological_space α,	_inst_3 : topological_ring α,	f : β → α,	a : α,	_inst_4 : t2_space α,	hf : ¬summable f,	ha : a = 0	⊢ ∑' (x : β), f x * a = (∑' (x : β), f x) * a
α : Type u_1,	β : Type u_2,	_inst_1 : division_ring α,	_inst_2 : topological_space α,	_inst_3 : topological_ring α,	f : β → α,	a : α,	_inst_4 : t2_space α,	hf : ¬summable f,	ha : ¬a = 0	⊢ ∑' (x : β), f x * a = (∑' (x : β), f x) * a
α : Type u_1,	β : Type u_2,	_inst_1 : ordered_add_comm_monoid α,	_inst_2 : topological_space α,	_inst_3 : order_closed_topology α,	g : β → α,	h : ∀ (b : β), 0 ≤ g b	⊢ 0 ≤ ∑' (b : β), g b
α : Type u_1,	β : Type u_2,	_inst_1 : ordered_add_comm_monoid α,	_inst_2 : topological_space α,	_inst_3 : order_closed_topology α,	g : β → α,	h : ∀ (b : β), 0 ≤ g b,	hg : summable g	⊢ 0 ≤ ∑' (b : β), g b		α : Type u_1,	β : Type u_2,	_inst_1 : ordered_add_comm_monoid α,	_inst_2 : topological_space α,	_inst_3 : order_closed_topology α,	g : β → α,	h : ∀ (b : β), 0 ≤ g b,	hg : ¬summable g	⊢ 0 ≤ ∑' (b : β), g b
α : Type u_1,	β : Type u_2,	_inst_1 : ordered_add_comm_monoid α,	_inst_2 : topological_space α,	_inst_3 : order_closed_topology α,	g : β → α,	h : ∀ (b : β), 0 ≤ g b,	hg : summable g	⊢ 0 ≤ ∑' (b : β), g b
α : Type u_1,	β : Type u_2,	_inst_1 : ordered_add_comm_monoid α,	_inst_2 : topological_space α,	_inst_3 : order_closed_topology α,	g : β → α,	h : ∀ (b : β), 0 ≤ g b,	hg : ¬summable g	⊢ 0 ≤ ∑' (b : β), g b
α : Type u_1,	β : Type u_2,	_inst_1 : ordered_add_comm_monoid α,	_inst_2 : topological_space α,	_inst_3 : order_closed_topology α,	f : β → α,	h : ∀ (b : β), f b ≤ 0	⊢ ∑' (b : β), f b ≤ 0
α : Type u_1,	β : Type u_2,	_inst_1 : ordered_add_comm_monoid α,	_inst_2 : topological_space α,	_inst_3 : order_closed_topology α,	f : β → α,	h : ∀ (b : β), f b ≤ 0,	hf : summable f	⊢ ∑' (b : β), f b ≤ 0		α : Type u_1,	β : Type u_2,	_inst_1 : ordered_add_comm_monoid α,	_inst_2 : topological_space α,	_inst_3 : order_closed_topology α,	f : β → α,	h : ∀ (b : β), f b ≤ 0,	hf : ¬summable f	⊢ ∑' (b : β), f b ≤ 0
α : Type u_1,	β : Type u_2,	_inst_1 : ordered_add_comm_monoid α,	_inst_2 : topological_space α,	_inst_3 : order_closed_topology α,	f : β → α,	h : ∀ (b : β), f b ≤ 0,	hf : summable f	⊢ ∑' (b : β), f b ≤ 0
α : Type u_1,	β : Type u_2,	_inst_1 : ordered_add_comm_monoid α,	_inst_2 : topological_space α,	_inst_3 : order_closed_topology α,	f : β → α,	h : ∀ (b : β), f b ≤ 0,	hf : ¬summable f	⊢ ∑' (b : β), f b ≤ 0
R : Type u_1,	_inst_1 : semiring R,	M : Type u_2,	_inst_2 : topological_space M,	_inst_3 : add_comm_monoid M,	M₂ : Type u_3,	_inst_4 : topological_space M₂,	_inst_5 : add_comm_monoid M₂,	_inst_10 : module R M,	_inst_11 : module R M₂,	e : M ≃L[R] M₂,	x : M	⊢ ⇑(e.symm.symm) x = ⇑e x
R : Type u_1,	_inst_1 : semiring R,	M : Type u_2,	_inst_2 : topological_space M,	_inst_3 : add_comm_monoid M,	M₂ : Type u_3,	_inst_4 : topological_space M₂,	_inst_5 : add_comm_monoid M₂,	_inst_10 : module R M,	_inst_11 : module R M₂,	e : M ≃L[R] M₂	⊢ e.symm.symm = e
R : Type u_1,	_inst_1 : ring R,	_inst_8 : topological_space R,	_inst_9 : has_continuous_mul R,	u : units R,	x : R	⊢ ⇑(1.smul_right ↑u⁻¹) (⇑(1.smul_right ↑u) x) = x
R : Type u_1,	_inst_1 : ring R,	_inst_8 : topological_space R,	_inst_9 : has_continuous_mul R,	u : units R,	x : R	⊢ ⇑(1.smul_right ↑u) (⇑(1.smul_right ↑u⁻¹) x) = x
R : Type u_1,	_inst_1 : ring R,	_inst_8 : topological_space R,	_inst_9 : has_continuous_mul R,	e : R ≃L[R] R	⊢ ⇑e 1 * ⇑(e.symm) 1 = 1
R : Type u_1,	_inst_1 : ring R,	_inst_8 : topological_space R,	_inst_9 : has_continuous_mul R,	e : R ≃L[R] R	⊢ ⇑(e.symm) 1 * ⇑e 1 = 1
R : Type u_1,	_inst_1 : ring R,	_inst_8 : topological_space R,	_inst_9 : has_continuous_mul R,	u : units R	⊢ ↑((λ (e : R ≃L[R] R), {val := ⇑e 1, inv := ⇑(e.symm) 1, val_inv := _, inv_val := _}) ((λ (u : units R), continuous_linear_equiv.equiv_of_inverse (1.smul_right ↑u) (1.smul_right ↑u⁻¹) _ _) u)) = ↑u
R : Type u_1,	_inst_1 : ring R,	_inst_8 : topological_space R,	_inst_9 : has_continuous_mul R,	e : R ≃L[R] R	⊢ ⇑((λ (u : units R), continuous_linear_equiv.equiv_of_inverse (1.smul_right ↑u) (1.smul_right ↑u⁻¹) _ _) ((λ (e : R ≃L[R] R), {val := ⇑e 1, inv := ⇑(e.symm) 1, val_inv := _, inv_val := _}) e)) 1 = ⇑e 1
R : Type u_1,	_inst_1 : semiring R,	M : Type u_2,	_inst_2 : topological_space M,	_inst_3 : add_comm_monoid M,	M₂ : Type u_3,	_inst_4 : topological_space M₂,	_inst_5 : add_comm_monoid M₂,	_inst_10 : module R M,	_inst_11 : module R M₂,	_inst_14 : topological_space R,	_inst_15 : has_continuous_smul R M,	_inst_16 : has_continuous_add M,	_inst_17 : has_continuous_smul R M₂,	_inst_18 : has_continuous_add M₂,	f : M →L[R] M₂,	hf' : dense_range ⇑f,	s : submodule R M,	hs : s.topological_closure = ⊤	⊢ (submodule.map ↑f s).topological_closure = ⊤
R : Type u_1,	_inst_1 : semiring R,	M : Type u_2,	_inst_2 : topological_space M,	_inst_3 : add_comm_monoid M,	M₂ : Type u_3,	_inst_4 : topological_space M₂,	_inst_5 : add_comm_monoid M₂,	_inst_10 : module R M,	_inst_11 : module R M₂,	_inst_14 : topological_space R,	_inst_15 : has_continuous_smul R M,	_inst_16 : has_continuous_add M,	_inst_17 : has_continuous_smul R M₂,	_inst_18 : has_continuous_add M₂,	f : M →L[R] M₂,	hf' : dense_range ⇑f,	s : submodule R M,	hs : ↑(s.topological_closure) = ↑⊤	⊢ ↑((submodule.map ↑f s).topological_closure) = ↑⊤
R : Type u_1,	_inst_1 : semiring R,	M : Type u_2,	_inst_2 : topological_space M,	_inst_3 : add_comm_monoid M,	M₂ : Type u_3,	_inst_4 : topological_space M₂,	_inst_5 : add_comm_monoid M₂,	_inst_10 : module R M,	_inst_11 : module R M₂,	_inst_14 : topological_space R,	_inst_15 : has_continuous_smul R M,	_inst_16 : has_continuous_add M,	_inst_17 : has_continuous_smul R M₂,	_inst_18 : has_continuous_add M₂,	f : M →L[R] M₂,	hf' : dense_range ⇑f,	s : submodule R M,	hs : dense ↑s	⊢ dense ↑(submodule.map ↑f s)
R : Type u_1,	_inst_1 : ring R,	M : Type u_2,	_inst_2 : topological_space M,	_inst_3 : add_comm_group M,	M₂ : Type u_3,	_inst_4 : topological_space M₂,	_inst_5 : add_comm_group M₂,	_inst_10 : module R M,	_inst_11 : module R M₂,	_inst_14 : topological_add_group M₂	⊢ add_comm_group (M →L[R] M₂)
R : Type u_1,	_inst_1 : ring R,	M : Type u_2,	_inst_2 : topological_space M,	_inst_3 : add_comm_group M,	M₂ : Type u_3,	_inst_4 : topological_space M₂,	_inst_5 : add_comm_group M₂,	_inst_10 : module R M,	_inst_11 : module R M₂,	_inst_14 : topological_add_group M₂,	n : ℕ,	f : M →L[R] M₂	⊢ ∀ (x y : M), n • ⇑f (x + y) = n • ⇑f x + n • ⇑f y
R : Type u_1,	_inst_1 : ring R,	M : Type u_2,	_inst_2 : topological_space M,	_inst_3 : add_comm_group M,	M₂ : Type u_3,	_inst_4 : topological_space M₂,	_inst_5 : add_comm_group M₂,	_inst_10 : module R M,	_inst_11 : module R M₂,	_inst_14 : topological_add_group M₂,	n : ℕ,	f : M →L[R] M₂	⊢ ∀ (r : R) (x : M), n • ⇑f (r • x) = ⇑(ring_hom.id R) r • n • ⇑f x
R : Type u_1,	_inst_1 : ring R,	M : Type u_2,	_inst_2 : topological_space M,	_inst_3 : add_comm_group M,	M₂ : Type u_3,	_inst_4 : topological_space M₂,	_inst_5 : add_comm_group M₂,	_inst_10 : module R M,	_inst_11 : module R M₂,	_inst_14 : topological_add_group M₂,	n : ℤ,	f : M →L[R] M₂	⊢ ∀ (x y : M), n • ⇑f (x + y) = n • ⇑f x + n • ⇑f y
R : Type u_1,	_inst_1 : ring R,	M : Type u_2,	_inst_2 : topological_space M,	_inst_3 : add_comm_group M,	M₂ : Type u_3,	_inst_4 : topological_space M₂,	_inst_5 : add_comm_group M₂,	_inst_10 : module R M,	_inst_11 : module R M₂,	_inst_14 : topological_add_group M₂,	n : ℤ,	f : M →L[R] M₂	⊢ ∀ (r : R) (x : M), n • ⇑f (r • x) = ⇑(ring_hom.id R) r • n • ⇑f x
R : Type u_1,	_inst_1 : ring R,	M : Type u_2,	_inst_2 : topological_space M,	_inst_3 : add_comm_group M,	M₂ : Type u_3,	_inst_4 : topological_space M₂,	_inst_5 : add_comm_group M₂,	_inst_10 : module R M,	_inst_11 : module R M₂,	_inst_14 : topological_add_group M₂,	f : M →L[R] M₂	⊢ {to_linear_map := {to_fun := λ (x : M), 0 • ⇑f x, map_add' := _, map_smul' := _}, cont := _} = 0
R : Type u_1,	_inst_1 : ring R,	M : Type u_2,	_inst_2 : topological_space M,	_inst_3 : add_comm_group M,	M₂ : Type u_3,	_inst_4 : topological_space M₂,	_inst_5 : add_comm_group M₂,	_inst_10 : module R M,	_inst_11 : module R M₂,	_inst_14 : topological_add_group M₂,	f : M →L[R] M₂,	x : M	⊢ ⇑{to_linear_map := {to_fun := λ (x : M), 0 • ⇑f x, map_add' := _, map_smul' := _}, cont := _} x = ⇑0 x
R : Type u_1,	_inst_1 : ring R,	M : Type u_2,	_inst_2 : topological_space M,	_inst_3 : add_comm_group M,	M₂ : Type u_3,	_inst_4 : topological_space M₂,	_inst_5 : add_comm_group M₂,	_inst_10 : module R M,	_inst_11 : module R M₂,	_inst_14 : topological_add_group M₂,	n : ℕ,	f : M →L[R] M₂	⊢ {to_linear_map := {to_fun := λ (x : M), int.of_nat n.succ • ⇑f x, map_add' := _, map_smul' := _}, cont := _} = f + {to_linear_map := {to_fun := λ (x : M), int.of_nat n • ⇑f x, map_add' := _, map_smul' := _}, cont := _}
R : Type u_1,	_inst_1 : ring R,	M : Type u_2,	_inst_2 : topological_space M,	_inst_3 : add_comm_group M,	M₂ : Type u_3,	_inst_4 : topological_space M₂,	_inst_5 : add_comm_group M₂,	_inst_10 : module R M,	_inst_11 : module R M₂,	_inst_14 : topological_add_group M₂,	n : ℕ,	f : M →L[R] M₂,	x : M	⊢ ⇑{to_linear_map := {to_fun := λ (x : M), int.of_nat n.succ • ⇑f x, map_add' := _, map_smul' := _}, cont := _} x = ⇑(f + {to_linear_map := {to_fun := λ (x : M), int.of_nat n • ⇑f x, map_add' := _, map_smul' := _}, cont := _}) x
R : Type u_1,	_inst_1 : ring R,	M : Type u_2,	_inst_2 : topological_space M,	_inst_3 : add_comm_group M,	M₂ : Type u_3,	_inst_4 : topological_space M₂,	_inst_5 : add_comm_group M₂,	_inst_10 : module R M,	_inst_11 : module R M₂,	_inst_14 : topological_add_group M₂,	n : ℕ,	f : M →L[R] M₂	⊢ {to_linear_map := {to_fun := λ (x : M), -[1+ n] • ⇑f x, map_add' := _, map_smul' := _}, cont := _} = -{to_linear_map := {to_fun := λ (x : M), ↑(n.succ) • ⇑f x, map_add' := _, map_smul' := _}, cont := _}
R : Type u_1,	_inst_1 : ring R,	M : Type u_2,	_inst_2 : topological_space M,	_inst_3 : add_comm_group M,	M₂ : Type u_3,	_inst_4 : topological_space M₂,	_inst_5 : add_comm_group M₂,	_inst_10 : module R M,	_inst_11 : module R M₂,	_inst_14 : topological_add_group M₂,	n : ℕ,	f : M →L[R] M₂,	x : M	⊢ ⇑{to_linear_map := {to_fun := λ (x : M), -[1+ n] • ⇑f x, map_add' := _, map_smul' := _}, cont := _} x = (⇑-{to_linear_map := {to_fun := λ (x : M), ↑(n.succ) • ⇑f x, map_add' := _, map_smul' := _}, cont := _}) x
R : Type u_1,	_inst_1 : ring R,	M : Type u_2,	_inst_2 : topological_space M,	_inst_3 : add_comm_group M,	M₂ : Type u_3,	_inst_4 : topological_space M₂,	_inst_5 : add_comm_group M₂,	_inst_10 : module R M,	_inst_11 : module R M₂,	_inst_14 : topological_add_group M₂	⊢ add_comm_group (M →L[R] M₂)
R : Type u_1,	_inst_1 : ring R,	M : Type u_2,	_inst_2 : topological_space M,	_inst_3 : add_comm_group M,	M₂ : Type u_3,	_inst_4 : topological_space M₂,	_inst_5 : add_comm_group M₂,	_inst_10 : module R M,	_inst_11 : module R M₂,	_inst_14 : topological_add_group M₂	⊢ add_comm_group (M →L[R] M₂)
R : Type u_1,	_inst_1 : ring R,	M : Type u_2,	_inst_2 : topological_space M,	_inst_3 : add_comm_group M,	M₂ : Type u_3,	_inst_4 : topological_space M₂,	_inst_5 : add_comm_group M₂,	_inst_10 : module R M,	_inst_11 : module R M₂,	_inst_14 : topological_add_group M₂	⊢ add_comm_group (M →L[R] M₂)
R : Type u_1,	_inst_1 : ring R,	M : Type u_2,	_inst_2 : topological_space M,	_inst_3 : add_comm_group M,	M₂ : Type u_3,	_inst_4 : topological_space M₂,	_inst_5 : add_comm_group M₂,	_inst_10 : module R M,	_inst_11 : module R M₂,	_inst_14 : topological_add_group M₂,	a b : M →L[R] M₂,	x : M	⊢ ⇑(a - b) x = ⇑(a + -b) x
R : Type u_1,	_inst_1 : ring R,	M : Type u_2,	_inst_2 : topological_space M,	_inst_3 : add_comm_group M,	M₂ : Type u_3,	_inst_4 : topological_space M₂,	_inst_5 : add_comm_group M₂,	_inst_10 : module R M,	_inst_11 : module R M₂,	_inst_14 : topological_add_group M₂,	a : M →L[R] M₂,	x : M	⊢ ⇑(-a + a) x = ⇑0 x
R : Type u_1,	_inst_1 : ring R,	M : Type u_2,	_inst_2 : topological_space M,	_inst_3 : add_comm_group M,	M₂ : Type u_3,	_inst_4 : topological_space M₂,	_inst_5 : add_comm_group M₂,	_inst_10 : module R M,	_inst_11 : module R M₂,	_inst_14 : topological_add_group M₂	⊢ ∀ (a b : M →L[R] M₂), a - b = a + -b
R : Type u_1,	_inst_1 : ring R,	M : Type u_2,	_inst_2 : topological_space M,	_inst_3 : add_comm_group M,	M₂ : Type u_3,	_inst_4 : topological_space M₂,	_inst_5 : add_comm_group M₂,	_inst_10 : module R M,	_inst_11 : module R M₂,	_inst_14 : topological_add_group M₂	⊢ ∀ (a : M →L[R] M₂), -a + a = 0
R : Type u_1,	_inst_1 : ring R,	M : Type u_2,	_inst_2 : topological_space M,	_inst_3 : add_comm_group M,	M₂ : Type u_3,	_inst_4 : topological_space M₂,	_inst_5 : add_comm_group M₂,	_inst_10 : module R M,	_inst_11 : module R M₂,	_inst_14 : topological_add_group M₂,	a b : M →L[R] M₂	⊢ a - b = a + -b
R : Type u_1,	_inst_1 : ring R,	M : Type u_2,	_inst_2 : topological_space M,	_inst_3 : add_comm_group M,	M₂ : Type u_3,	_inst_4 : topological_space M₂,	_inst_5 : add_comm_group M₂,	_inst_10 : module R M,	_inst_11 : module R M₂,	_inst_14 : topological_add_group M₂,	a : M →L[R] M₂	⊢ -a + a = 0
α : Type u_2,	_inst_2 : topological_space α,	_inst_3 : monoid α	⊢ topological_space (α × αᵒᵖ)
ι : Type u_1,	X : Type u_3,	M : Type u_4,	_inst_1 : topological_space X,	_inst_2 : topological_space M,	_inst_3 : comm_monoid M,	_inst_4 : has_continuous_mul M,	f : ι → X → M,	hc : ∀ (i : ι), continuous (f i),	hf : locally_finite (λ (i : ι), function.mul_support (f i))	⊢ continuous (λ (x : X), ∏ᶠ (i : ι), f i x)
ι : Type u_1,	X : Type u_3,	M : Type u_4,	_inst_1 : topological_space X,	_inst_2 : topological_space M,	_inst_3 : comm_monoid M,	_inst_4 : has_continuous_mul M,	f : ι → X → M,	hc : ∀ (i : ι), continuous (f i),	hf : locally_finite (λ (i : ι), function.mul_support (f i)),	x : X	⊢ continuous_at (λ (x : X), ∏ᶠ (i : ι), f i x) x
ι : Type u_1,	X : Type u_3,	M : Type u_4,	_inst_1 : topological_space X,	_inst_2 : topological_space M,	_inst_3 : comm_monoid M,	_inst_4 : has_continuous_mul M,	f : ι → X → M,	hc : ∀ (i : ι), continuous (f i),	hf : locally_finite (λ (i : ι), function.mul_support (f i)),	x : X,	U : set X,	hxU : U ∈ 𝓝 x,	hUf : {i : ι | ((λ (i : ι), function.mul_support (f i)) i ∩ U).nonempty}.finite	⊢ continuous_at (λ (x : X), ∏ᶠ (i : ι), f i x) x
ι : Type u_1,	X : Type u_3,	M : Type u_4,	_inst_1 : topological_space X,	_inst_2 : topological_space M,	_inst_3 : comm_monoid M,	_inst_4 : has_continuous_mul M,	f : ι → X → M,	hc : ∀ (i : ι), continuous (f i),	hf : locally_finite (λ (i : ι), function.mul_support (f i)),	x : X,	U : set X,	hxU : U ∈ 𝓝 x,	hUf : {i : ι | ((λ (i : ι), function.mul_support (f i)) i ∩ U).nonempty}.finite	⊢ continuous_at (λ (x : X), ∏ (i : ι) in hUf.to_finset, f i x) x		ι : Type u_1,	X : Type u_3,	M : Type u_4,	_inst_1 : topological_space X,	_inst_2 : topological_space M,	_inst_3 : comm_monoid M,	_inst_4 : has_continuous_mul M,	f : ι → X → M,	hc : ∀ (i : ι), continuous (f i),	hf : locally_finite (λ (i : ι), function.mul_support (f i)),	x : X,	U : set X,	hxU : U ∈ 𝓝 x,	hUf : {i : ι | ((λ (i : ι), function.mul_support (f i)) i ∩ U).nonempty}.finite,	this : continuous_at (λ (x : X), ∏ (i : ι) in hUf.to_finset, f i x) x	⊢ continuous_at (λ (x : X), ∏ᶠ (i : ι), f i x) x
ι : Type u_1,	X : Type u_3,	M : Type u_4,	_inst_1 : topological_space X,	_inst_2 : topological_space M,	_inst_3 : comm_monoid M,	_inst_4 : has_continuous_mul M,	f : ι → X → M,	hc : ∀ (i : ι), continuous (f i),	hf : locally_finite (λ (i : ι), function.mul_support (f i)),	x : X,	U : set X,	hxU : U ∈ 𝓝 x,	hUf : {i : ι | ((λ (i : ι), function.mul_support (f i)) i ∩ U).nonempty}.finite,	this : continuous_at (λ (x : X), ∏ (i : ι) in hUf.to_finset, f i x) x	⊢ continuous_at (λ (x : X), ∏ᶠ (i : ι), f i x) x
ι : Type u_1,	X : Type u_3,	M : Type u_4,	_inst_1 : topological_space X,	_inst_2 : topological_space M,	_inst_3 : comm_monoid M,	_inst_4 : has_continuous_mul M,	f : ι → X → M,	hc : ∀ (i : ι), continuous (f i),	hf : locally_finite (λ (i : ι), function.mul_support (f i)),	x : X,	U : set X,	hxU : U ∈ 𝓝 x,	hUf : {i : ι | ((λ (i : ι), function.mul_support (f i)) i ∩ U).nonempty}.finite,	this : continuous_at (λ (x : X), ∏ (i : ι) in hUf.to_finset, f i x) x,	y : X,	hy : y ∈ U	⊢ y ∈ {x : X | (λ (x : X), ∏ (i : ι) in hUf.to_finset, f i x = ∏ᶠ (i : ι), f i x) x}
ι : Type u_1,	X : Type u_3,	M : Type u_4,	_inst_1 : topological_space X,	_inst_2 : topological_space M,	_inst_3 : comm_monoid M,	_inst_4 : has_continuous_mul M,	f : ι → X → M,	hc : ∀ (i : ι), continuous (f i),	hf : locally_finite (λ (i : ι), function.mul_support (f i)),	x : X,	U : set X,	hxU : U ∈ 𝓝 x,	hUf : {i : ι | ((λ (i : ι), function.mul_support (f i)) i ∩ U).nonempty}.finite,	this : continuous_at (λ (x : X), ∏ (i : ι) in hUf.to_finset, f i x) x,	y : X,	hy : y ∈ U,	i : ι,	hi : i ∈ function.mul_support (λ (i : ι), f i y)	⊢ i ∈ ↑(hUf.to_finset)
ι : Type u_1,	X : Type u_3,	M : Type u_4,	_inst_1 : topological_space X,	_inst_2 : topological_space M,	_inst_3 : comm_monoid M,	_inst_4 : has_continuous_mul M,	f : ι → X → M,	hc : ∀ (i : ι), continuous (f i),	hf : locally_finite (λ (i : ι), function.mul_support (f i)),	x : X,	U : set X,	hxU : U ∈ 𝓝 x,	hUf : {i : ι | ((λ (i : ι), function.mul_support (f i)) i ∩ U).nonempty}.finite,	this : continuous_at (λ (x : X), ∏ (i : ι) in hUf.to_finset, f i x) x,	y : X,	hy : y ∈ U,	i : ι,	hi : i ∈ function.mul_support (λ (i : ι), f i y)	⊢ i ∈ {i : ι | ((λ (i : ι), function.mul_support (f i)) i ∩ U).nonempty}
α : Type u,	_inst_1 : topological_space α,	_inst_2 : linear_order α,	_inst_3 : order_topology α,	s : set α,	a : α,	hs : is_closed s,	ha : a ∉ s,	hs' : sᶜ ∈ 𝓝 a,	this : ∃ (t : set α), is_open t ∧ (∀ (l : α), l ∈ s → l < a → l ∈ t) ∧ 𝓝[t] a = ⊥,	_let_match : (∃ (t : set α), is_open t ∧ (∀ (l : α), l ∈ s → l < a → l ∈ t) ∧ 𝓝[t] a = ⊥) → (∃ (t : set α), is_open t ∧ s ⊆ t ∧ 𝓝[t] a = ⊥),	t₁ : set α,	ht₁o : is_open t₁,	ht₁s : ∀ (l : α), l ∈ s → l < a → l ∈ t₁,	ht₁a : 𝓝[t₁] a = ⊥,	this : ∃ (t : set α), is_open t ∧ (∀ (u : α), u ∈ s → u > a → u ∈ t) ∧ 𝓝[t] a = ⊥,	_let_match : (∃ (t : set α), is_open t ∧ (∀ (u : α), u ∈ s → u > a → u ∈ t) ∧ 𝓝[t] a = ⊥) → (∃ (t : set α), is_open t ∧ s ⊆ t ∧ 𝓝[t] a = ⊥),	t₂ : set α,	ht₂o : is_open t₂,	ht₂s : ∀ (u : α), u ∈ s → u > a → u ∈ t₂,	ht₂a : 𝓝[t₂] a = ⊥	⊢ 𝓝[t₁ ∪ t₂] a = ⊥
α : Type u,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α	⊢ filter.tendsto (function.uncurry has_mul.mul) (𝓝 1 ×ᶠ 𝓝 1) (𝓝 1)
α : Type u,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α	⊢ ∀ (ib : α), (λ (ε : α), 0 < ε ∧ ε ≤ 1) ib → (∃ (ia : α × α) (hia : (λ (i : α × α), 0 < i.fst ∧ 0 < i.snd) ia), ∀ (x : α × α), x ∈ (λ (i : α × α), (set.Ioo (1 - i.fst) (1 + i.fst)).prod (set.Ioo (1 - i.snd) (1 + i.snd))) ia → function.uncurry has_mul.mul x ∈ (λ (ε : α), set.Ioo (1 - ε) (1 + ε)) ib)
α : Type u,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	ε : α,	hε : 0 < ε ∧ ε ≤ 1	⊢ 0 ≤ 1 - ε / 4
α : Type u,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	ε : α,	hε : 0 < ε ∧ ε ≤ 1	⊢ ∃ (ia : α × α) (hia : (λ (i : α × α), 0 < i.fst ∧ 0 < i.snd) ia), ∀ (x : α × α), x ∈ (λ (i : α × α), (set.Ioo (1 - i.fst) (1 + i.fst)).prod (set.Ioo (1 - i.snd) (1 + i.snd))) ia → function.uncurry has_mul.mul x ∈ (λ (ε : α), set.Ioo (1 - ε) (1 + ε)) ε
α : Type u,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	ε : α,	hε : 0 < ε ∧ ε ≤ 1,	hε' : 0 ≤ 1 - ε / 4	⊢ 0 < ε / 4
α : Type u,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	ε : α,	hε : 0 < ε ∧ ε ≤ 1,	hε' : 0 ≤ 1 - ε / 4	⊢ ∃ (ia : α × α) (hia : (λ (i : α × α), 0 < i.fst ∧ 0 < i.snd) ia), ∀ (x : α × α), x ∈ (λ (i : α × α), (set.Ioo (1 - i.fst) (1 + i.fst)).prod (set.Ioo (1 - i.snd) (1 + i.snd))) ia → function.uncurry has_mul.mul x ∈ (λ (ε : α), set.Ioo (1 - ε) (1 + ε)) ε
α : Type u,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	ε : α,	hε : 0 < ε ∧ ε ≤ 1,	hε' : 0 ≤ 1 - ε / 4,	ε_pos : 0 < ε / 4	⊢ 0 < ε / 2
α : Type u,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	ε : α,	hε : 0 < ε ∧ ε ≤ 1,	hε' : 0 ≤ 1 - ε / 4,	ε_pos : 0 < ε / 4	⊢ ∃ (ia : α × α) (hia : (λ (i : α × α), 0 < i.fst ∧ 0 < i.snd) ia), ∀ (x : α × α), x ∈ (λ (i : α × α), (set.Ioo (1 - i.fst) (1 + i.fst)).prod (set.Ioo (1 - i.snd) (1 + i.snd))) ia → function.uncurry has_mul.mul x ∈ (λ (ε : α), set.Ioo (1 - ε) (1 + ε)) ε
α : Type u,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	ε : α,	hε : 0 < ε ∧ ε ≤ 1,	hε' : 0 ≤ 1 - ε / 4,	ε_pos : 0 < ε / 4,	ε_pos' : 0 < ε / 2	⊢ ∃ (ia : α × α) (hia : (λ (i : α × α), 0 < i.fst ∧ 0 < i.snd) ia), ∀ (x : α × α), x ∈ (λ (i : α × α), (set.Ioo (1 - i.fst) (1 + i.fst)).prod (set.Ioo (1 - i.snd) (1 + i.snd))) ia → function.uncurry has_mul.mul x ∈ (λ (ε : α), set.Ioo (1 - ε) (1 + ε)) ε
α : Type u,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	ε : α,	hε : 0 < ε ∧ ε ≤ 1,	hε' : 0 ≤ 1 - ε / 4,	ε_pos : 0 < ε / 4,	ε_pos' : 0 < ε / 2	⊢ ∃ (a b : α) (hia : (λ (i : α × α), 0 < i.fst ∧ 0 < i.snd) (a, b)), ∀ (a_1 b_1 : α), 1 - a < a_1 → a_1 < 1 + a → 1 - b < b_1 → b_1 < 1 + b → 1 - ε < a_1 * b_1 ∧ a_1 * b_1 < 1 + ε
α : Type u,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	ε : α,	hε : 0 < ε ∧ ε ≤ 1,	hε' : 0 ≤ 1 - ε / 4,	ε_pos : 0 < ε / 4,	ε_pos' : 0 < ε / 2,	a b : α,	ha : 1 - ε / 4 < a,	ha' : a < 1 + ε / 4,	hb : 1 - ε / 4 < b,	hb' : b < 1 + ε / 4	⊢ 1 - ε < a * b ∧ a * b < 1 + ε
α : Type u,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	ε : α,	hε : 0 < ε ∧ ε ≤ 1,	hε' : 0 ≤ 1 - ε / 4,	ε_pos : 0 < ε / 4,	ε_pos' : 0 < ε / 2,	a b : α,	ha : 1 - ε / 4 < a,	ha' : a < 1 + ε / 4,	hb : 1 - ε / 4 < b,	hb' : b < 1 + ε / 4,	ha0 : 0 ≤ a	⊢ 1 - ε < a * b ∧ a * b < 1 + ε
α : Type u,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	ε : α,	hε : 0 < ε ∧ ε ≤ 1,	hε' : 0 ≤ 1 - ε / 4,	ε_pos : 0 < ε / 4,	ε_pos' : 0 < ε / 2,	a b : α,	ha : 1 - ε / 4 < a,	ha' : a < 1 + ε / 4,	hb : 1 - ε / 4 < b,	hb' : b < 1 + ε / 4,	ha0 : 0 ≤ a,	hb0 : 0 ≤ b	⊢ 1 - ε < a * b ∧ a * b < 1 + ε
α : Type u,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	ε : α,	hε : 0 < ε ∧ ε ≤ 1,	hε' : 0 ≤ 1 - ε / 4,	ε_pos : 0 < ε / 4,	ε_pos' : 0 < ε / 2,	a b : α,	ha : 1 - ε / 4 < a,	ha' : a < 1 + ε / 4,	hb : 1 - ε / 4 < b,	hb' : b < 1 + ε / 4,	ha0 : 0 ≤ a,	hb0 : 0 ≤ b	⊢ 1 - ε = 1 - ε / 2 - ε / 2
α : Type u,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	ε : α,	hε : 0 < ε ∧ ε ≤ 1,	hε' : 0 ≤ 1 - ε / 4,	ε_pos : 0 < ε / 4,	ε_pos' : 0 < ε / 2,	a b : α,	ha : 1 - ε / 4 < a,	ha' : a < 1 + ε / 4,	hb : 1 - ε / 4 < b,	hb' : b < 1 + ε / 4,	ha0 : 0 ≤ a,	hb0 : 0 ≤ b	⊢ 1 - ε ≤ (1 - ε / 4) * (1 - ε / 4)
α : Type u,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	ε : α,	hε : 0 < ε ∧ ε ≤ 1,	hε' : 0 ≤ 1 - ε / 4,	ε_pos : 0 < ε / 4,	ε_pos' : 0 < ε / 2,	a b : α,	ha : 1 - ε / 4 < a,	ha' : a < 1 + ε / 4,	hb : 1 - ε / 4 < b,	hb' : b < 1 + ε / 4,	ha0 : 0 ≤ a,	hb0 : 0 ≤ b	⊢ 1 - ε / 2 - ε / 2 + ε / 2 * (ε / 2) = (1 - ε / 2) * (1 - ε / 2)
α : Type u,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	ε : α,	hε : 0 < ε ∧ ε ≤ 1,	hε' : 0 ≤ 1 - ε / 4,	ε_pos : 0 < ε / 4,	ε_pos' : 0 < ε / 2,	a b : α,	ha : 1 - ε / 4 < a,	ha' : a < 1 + ε / 4,	hb : 1 - ε / 4 < b,	hb' : b < 1 + ε / 4,	ha0 : 0 ≤ a,	hb0 : 0 ≤ b	⊢ 1 - ε / 2 ≤ 1 - ε / 4
α : Type u,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	ε : α,	hε : 0 < ε ∧ ε ≤ 1,	hε' : 0 ≤ 1 - ε / 4,	ε_pos : 0 < ε / 4,	ε_pos' : 0 < ε / 2,	a b : α,	ha : 1 - ε / 4 < a,	ha' : a < 1 + ε / 4,	hb : 1 - ε / 4 < b,	hb' : b < 1 + ε / 4,	ha0 : 0 ≤ a,	hb0 : 0 ≤ b	⊢ 0 ≤ 1 - ε / 2
α : Type u,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	ε : α,	hε : 0 < ε ∧ ε ≤ 1,	hε' : 0 ≤ 1 - ε / 4,	ε_pos : 0 < ε / 4,	ε_pos' : 0 < ε / 2,	a b : α,	ha : 1 - ε / 4 < a,	ha' : a < 1 + ε / 4,	hb : 1 - ε / 4 < b,	hb' : b < 1 + ε / 4,	ha0 : 0 ≤ a,	hb0 : 0 ≤ b	⊢ 1 - ε ≤ (1 - ε / 4) * (1 - ε / 4)		α : Type u,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	ε : α,	hε : 0 < ε ∧ ε ≤ 1,	hε' : 0 ≤ 1 - ε / 4,	ε_pos : 0 < ε / 4,	ε_pos' : 0 < ε / 2,	a b : α,	ha : 1 - ε / 4 < a,	ha' : a < 1 + ε / 4,	hb : 1 - ε / 4 < b,	hb' : b < 1 + ε / 4,	ha0 : 0 ≤ a,	hb0 : 0 ≤ b	⊢ (1 + ε / 4) * (1 + ε / 4) ≤ 1 + ε
α : Type u,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	ε : α,	hε : 0 < ε ∧ ε ≤ 1,	hε' : 0 ≤ 1 - ε / 4,	ε_pos : 0 < ε / 4,	ε_pos' : 0 < ε / 2,	a b : α,	ha : 1 - ε / 4 < a,	ha' : a < 1 + ε / 4,	hb : 1 - ε / 4 < b,	hb' : b < 1 + ε / 4,	ha0 : 0 ≤ a,	hb0 : 0 ≤ b	⊢ (1 + ε / 4) * (1 + ε / 4) ≤ 1 + ε
α : Type u,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	ε : α,	hε : 0 < ε ∧ ε ≤ 1,	hε' : 0 ≤ 1 - ε / 4,	ε_pos : 0 < ε / 4,	ε_pos' : 0 < ε / 2,	a b : α,	ha : 1 - ε / 4 < a,	ha' : a < 1 + ε / 4,	hb : 1 - ε / 4 < b,	hb' : b < 1 + ε / 4,	ha0 : 0 ≤ a,	hb0 : 0 ≤ b	⊢ (1 + ε / 4) * (1 + ε / 4) = 1 + ε / 2 + ε / 4 * (ε / 4)
α : Type u,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	ε : α,	hε : 0 < ε ∧ ε ≤ 1,	hε' : 0 ≤ 1 - ε / 4,	ε_pos : 0 < ε / 4,	ε_pos' : 0 < ε / 2,	a b : α,	ha : 1 - ε / 4 < a,	ha' : a < 1 + ε / 4,	hb : 1 - ε / 4 < b,	hb' : b < 1 + ε / 4,	ha0 : 0 ≤ a,	hb0 : 0 ≤ b	⊢ 1 + ε / 2 + ε / 4 * (ε / 4) = 1 + ε / 2 + ε * ε / 16
α : Type u,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	ε : α,	hε : 0 < ε ∧ ε ≤ 1,	hε' : 0 ≤ 1 - ε / 4,	ε_pos : 0 < ε / 4,	ε_pos' : 0 < ε / 2,	a b : α,	ha : 1 - ε / 4 < a,	ha' : a < 1 + ε / 4,	hb : 1 - ε / 4 < b,	hb' : b < 1 + ε / 4,	ha0 : 0 ≤ a,	hb0 : 0 ≤ b	⊢ 2 ≤ 16
α : Type u,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	ε : α,	hε : 0 < ε ∧ ε ≤ 1,	hε' : 0 ≤ 1 - ε / 4,	ε_pos : 0 < ε / 4,	ε_pos' : 0 < ε / 2,	a b : α,	ha : 1 - ε / 4 < a,	ha' : a < 1 + ε / 4,	hb : 1 - ε / 4 < b,	hb' : b < 1 + ε / 4,	ha0 : 0 ≤ a,	hb0 : 0 ≤ b	⊢ 1 + ε / 2 + ε / 2 ≤ 1 + ε
α : Type u,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α	⊢ filter.tendsto (λ (r : α), r⁻¹) filter.at_top (𝓝[set.Ioi 0] 0)
α : Type u,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α	⊢ ∀ (ib : α), ib ∈ set.Ioi 0 → (∃ (ia : α) (hia : true), ∀ (x : α), x ∈ set.Ici ia → x⁻¹ ∈ set.Ioc 0 ib)
α : Type u,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	b : α,	hb : b ∈ set.Ioi 0,	x : α,	hx : x ∈ set.Ici b⁻¹	⊢ x⁻¹ ∈ set.Ioc 0 b
α : Type u,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	b : α,	hb : b ∈ set.Ioi 0,	x : α,	hx : x ∈ set.Ici b⁻¹,	this : 0 < x	⊢ x⁻¹ ∈ set.Ioc 0 b
α : Type u,	_inst_1 : topological_space α,	_inst_2 : linear_order α,	_inst_3 : order_topology α,	_inst_4 : densely_ordered α,	_inst_5 : no_top_order α,	a : α	⊢ frontier (set.Iic a) = {a}
α : Type u,	_inst_1 : topological_space α,	_inst_2 : linear_order α,	_inst_3 : order_topology α,	_inst_4 : densely_ordered α,	a : α,	s : set α,	ha : s ⊆ set.Ioi a,	hs : ∀ (b' : α), b' > a → (∃ (b : α) (H : b > a), set.Ioo a b ⊆ s)	⊢ filter.map coe filter.at_bot = 𝓝[set.Ioi a] a
α : Type u,	_inst_1 : topological_space α,	_inst_2 : linear_order α,	_inst_3 : order_topology α,	_inst_4 : densely_ordered α,	a : α,	s : set α,	ha : s ⊆ set.Ioi a,	hs : ∀ (b' : α), b' > a → (∃ (b : α) (H : b > a), set.Ioo a b ⊆ s),	b' : order_dual α,	hb' : b' < a	⊢ ∃ (a_1 : order_dual α) (H : a_1 < a), set.Ioo a_1 a ⊆ s
α : Type u,	_inst_1 : topological_space α,	_inst_2 : linear_order α,	_inst_3 : order_topology α,	_inst_4 : densely_ordered α,	a : α,	s : set α,	ha : s ⊆ set.Ioi a,	hs : ∀ (b' : α), b' > a → (∃ (b : α) (H : b > a), set.Ioo a b ⊆ s),	b' : order_dual α,	hb' : b' < a,	b : α,	hab : b > a,	hbs : set.Ioo a b ⊆ s	⊢ ∃ (a_1 : order_dual α) (H : a_1 < a), set.Ioo a_1 a ⊆ s
α : Type u,	_inst_1 : topological_space α,	_inst_2 : linear_order α,	_inst_3 : order_topology α,	_inst_4 : densely_ordered α,	a : α,	s : set α,	ha : s ⊆ set.Ioi a,	hs : ∀ (b' : α), b' > a → (∃ (b : α) (H : b > a), set.Ioo a b ⊆ s),	b' : order_dual α,	hb' : b' < a,	b : α,	hab : b > a,	hbs : set.Ioo a b ⊆ s	⊢ set.Ioo b a ⊆ s
α : Type u,	_inst_1 : conditionally_complete_linear_order α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	_inst_8 : densely_ordered α,	δ : Type u_1,	_inst_9 : linear_order δ,	_inst_10 : topological_space δ,	_inst_11 : order_closed_topology δ,	a b : α,	f : α → δ,	hf : continuous_on f (set.interval a b)	⊢ set.interval (f a) (f b) ⊆ f '' set.interval a b
α : Type u,	_inst_1 : conditionally_complete_linear_order α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	_inst_8 : densely_ordered α,	δ : Type u_1,	_inst_9 : linear_order δ,	_inst_10 : topological_space δ,	_inst_11 : order_closed_topology δ,	a b : α,	f : α → δ,	hf : continuous_on f (set.interval a b),	h : f a ≤ f b	⊢ set.interval (f a) (f b) ⊆ f '' set.interval a b
α : Type u,	_inst_1 : conditionally_complete_linear_order α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	_inst_8 : densely_ordered α,	δ : Type u_1,	_inst_9 : linear_order δ,	_inst_10 : topological_space δ,	_inst_11 : order_closed_topology δ,	a b : α,	f : α → δ,	hf : continuous_on f (set.interval a b),	h : f b ≤ f a	⊢ set.interval (f a) (f b) ⊆ f '' set.interval a b
α : Type u,	_inst_1 : conditionally_complete_linear_order α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	_inst_8 : densely_ordered α,	δ : Type u_1,	_inst_9 : linear_order δ,	_inst_10 : topological_space δ,	_inst_11 : order_closed_topology δ,	a b : α,	f : α → δ,	hf : continuous_on f (set.interval a b)	⊢ set.interval (f a) (f b) ⊆ f '' set.interval a b
α : Type u,	β : Type v,	_inst_1 : topological_space α,	_inst_2 : linear_order α,	_inst_3 : order_closed_topology α,	_inst_5 : topological_space β,	a b : α,	f : α → β,	h : a < b	⊢ continuous_within_at f (set.Ioo a b) a ↔ continuous_within_at f (set.Ioi a) a
α : Type u,	_inst_1 : topological_space α,	_inst_2 : linear_order α,	_inst_3 : order_closed_topology α,	a b : α,	h : a < b	⊢ 𝓝[set.Ioc a b] b = 𝓝[set.Iic b] b
α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : semiring α,	_inst_3 : topological_ring α,	s : subsemiring α	⊢ is_closed ↑(s.topological_closure)
α : Type u_1,	β : Type u_2,	_inst_1 : uniform_space α,	_inst_2 : add_group α,	_inst_3 : uniform_add_group α,	_inst_4 : uniform_space β,	_inst_5 : add_group β,	_inst_6 : uniform_add_group β,	f : α →+ β,	hf : continuous_at ⇑f 0	⊢ filter.tendsto ⇑f (𝓝 0) (𝓝 0)
α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	G : Type u_5,	_inst_1 : topological_space α,	_inst_2 : add_comm_group α,	_inst_3 : topological_add_group α,	_inst_4 : topological_space β,	_inst_5 : add_comm_group β,	_inst_6 : topological_add_group β,	_inst_7 : topological_space γ,	_inst_8 : add_comm_group γ,	_inst_9 : topological_add_group γ,	_inst_10 : topological_space δ,	_inst_11 : add_comm_group δ,	_inst_12 : topological_add_group δ,	_inst_13 : uniform_space G,	_inst_14 : add_comm_group G,	_inst_15 : uniform_add_group G,	_inst_16 : separated_space G,	_inst_17 : complete_space G,	e : β →+ α,	de : dense_inducing ⇑e,	f : δ →+ γ,	df : dense_inducing ⇑f,	φ : β →+ δ →+ G,	hφ : continuous (λ (p : β × δ), ⇑(⇑φ p.fst) p.snd),	W' : set G,	W'_nhd : W' ∈ 𝓝 0,	x₀ : α,	y₁ : δ	⊢ ∃ (U₂ : set β) (H : U₂ ∈ filter.comap ⇑e (𝓝 x₀)), ∀ (x x' : β), x ∈ U₂ → x' ∈ U₂ → (λ (p : β × δ), ⇑(⇑φ p.fst) p.snd) (x' - x, y₁) ∈ W'
α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	G : Type u_5,	_inst_1 : topological_space α,	_inst_2 : add_comm_group α,	_inst_3 : topological_add_group α,	_inst_4 : topological_space β,	_inst_5 : add_comm_group β,	_inst_6 : topological_add_group β,	_inst_7 : topological_space γ,	_inst_8 : add_comm_group γ,	_inst_9 : topological_add_group γ,	_inst_10 : topological_space δ,	_inst_11 : add_comm_group δ,	_inst_12 : topological_add_group δ,	_inst_13 : uniform_space G,	_inst_14 : add_comm_group G,	_inst_15 : uniform_add_group G,	_inst_16 : separated_space G,	_inst_17 : complete_space G,	e : β →+ α,	de : dense_inducing ⇑e,	f : δ →+ γ,	df : dense_inducing ⇑f,	φ : β →+ δ →+ G,	hφ : continuous (λ (p : β × δ), ⇑(⇑φ p.fst) p.snd),	W' : set G,	W'_nhd : W' ∈ 𝓝 0,	x₀ : α,	y₁ : δ,	Nx : filter α := 𝓝 x₀	⊢ ∃ (U₂ : set β) (H : U₂ ∈ filter.comap ⇑e (𝓝 x₀)), ∀ (x x' : β), x ∈ U₂ → x' ∈ U₂ → (λ (p : β × δ), ⇑(⇑φ p.fst) p.snd) (x' - x, y₁) ∈ W'
α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	G : Type u_5,	_inst_1 : topological_space α,	_inst_2 : add_comm_group α,	_inst_3 : topological_add_group α,	_inst_4 : topological_space β,	_inst_5 : add_comm_group β,	_inst_6 : topological_add_group β,	_inst_7 : topological_space γ,	_inst_8 : add_comm_group γ,	_inst_9 : topological_add_group γ,	_inst_10 : topological_space δ,	_inst_11 : add_comm_group δ,	_inst_12 : topological_add_group δ,	_inst_13 : uniform_space G,	_inst_14 : add_comm_group G,	_inst_15 : uniform_add_group G,	_inst_16 : separated_space G,	_inst_17 : complete_space G,	e : β →+ α,	de : dense_inducing ⇑e,	f : δ →+ γ,	df : dense_inducing ⇑f,	φ : β →+ δ →+ G,	hφ : continuous (λ (p : β × δ), ⇑(⇑φ p.fst) p.snd),	W' : set G,	W'_nhd : W' ∈ 𝓝 0,	x₀ : α,	y₁ : δ,	Nx : filter α := 𝓝 x₀,	ee : β × β → α × α := λ (u : β × β), (⇑e u.fst, ⇑e u.snd)	⊢ ∃ (U₂ : set β) (H : U₂ ∈ filter.comap ⇑e (𝓝 x₀)), ∀ (x x' : β), x ∈ U₂ → x' ∈ U₂ → (λ (p : β × δ), ⇑(⇑φ p.fst) p.snd) (x' - x, y₁) ∈ W'
α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	G : Type u_5,	_inst_1 : topological_space α,	_inst_2 : add_comm_group α,	_inst_3 : topological_add_group α,	_inst_4 : topological_space β,	_inst_5 : add_comm_group β,	_inst_6 : topological_add_group β,	_inst_7 : topological_space γ,	_inst_8 : add_comm_group γ,	_inst_9 : topological_add_group γ,	_inst_10 : topological_space δ,	_inst_11 : add_comm_group δ,	_inst_12 : topological_add_group δ,	_inst_13 : uniform_space G,	_inst_14 : add_comm_group G,	_inst_15 : uniform_add_group G,	_inst_16 : separated_space G,	_inst_17 : complete_space G,	e : β →+ α,	de : dense_inducing ⇑e,	f : δ →+ γ,	df : dense_inducing ⇑f,	φ : β →+ δ →+ G,	hφ : continuous (λ (p : β × δ), ⇑(⇑φ p.fst) p.snd),	W' : set G,	W'_nhd : W' ∈ 𝓝 0,	x₀ : α,	y₁ : δ,	Nx : filter α := 𝓝 x₀,	ee : β × β → α × α := λ (u : β × β), (⇑e u.fst, ⇑e u.snd)	⊢ filter.tendsto (λ (a : β × β), (a.snd - a.fst, y₁)) (filter.comap ⇑e Nx ×ᶠ filter.comap ⇑e Nx) (𝓝 (0, y₁))
α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	G : Type u_5,	_inst_1 : topological_space α,	_inst_2 : add_comm_group α,	_inst_3 : topological_add_group α,	_inst_4 : topological_space β,	_inst_5 : add_comm_group β,	_inst_6 : topological_add_group β,	_inst_7 : topological_space γ,	_inst_8 : add_comm_group γ,	_inst_9 : topological_add_group γ,	_inst_10 : topological_space δ,	_inst_11 : add_comm_group δ,	_inst_12 : topological_add_group δ,	_inst_13 : uniform_space G,	_inst_14 : add_comm_group G,	_inst_15 : uniform_add_group G,	_inst_16 : separated_space G,	_inst_17 : complete_space G,	e : β →+ α,	de : dense_inducing ⇑e,	f : δ →+ γ,	df : dense_inducing ⇑f,	φ : β →+ δ →+ G,	hφ : continuous (λ (p : β × δ), ⇑(⇑φ p.fst) p.snd),	W' : set G,	W'_nhd : W' ∈ 𝓝 0,	x₀ : α,	y₁ : δ,	Nx : filter α := 𝓝 x₀,	ee : β × β → α × α := λ (u : β × β), (⇑e u.fst, ⇑e u.snd),	this : filter.tendsto (λ (x : β × β), ((λ (t : β × β), t.snd - t.fst) x, (λ (b : β × β), y₁) x)) (filter.comap (λ (p : β × β), (⇑e p.fst, ⇑e p.snd)) (𝓝 (x₀, x₀))) (𝓝 0 ×ᶠ 𝓝 y₁)	⊢ filter.tendsto (λ (a : β × β), (a.snd - a.fst, y₁)) (filter.comap ⇑e Nx ×ᶠ filter.comap ⇑e Nx) (𝓝 (0, y₁))
α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	G : Type u_5,	_inst_1 : topological_space α,	_inst_2 : add_comm_group α,	_inst_3 : topological_add_group α,	_inst_4 : topological_space β,	_inst_5 : add_comm_group β,	_inst_6 : topological_add_group β,	_inst_7 : topological_space γ,	_inst_8 : add_comm_group γ,	_inst_9 : topological_add_group γ,	_inst_10 : topological_space δ,	_inst_11 : add_comm_group δ,	_inst_12 : topological_add_group δ,	_inst_13 : uniform_space G,	_inst_14 : add_comm_group G,	_inst_15 : uniform_add_group G,	_inst_16 : separated_space G,	_inst_17 : complete_space G,	e : β →+ α,	de : dense_inducing ⇑e,	f : δ →+ γ,	df : dense_inducing ⇑f,	φ : β →+ δ →+ G,	hφ : continuous (λ (p : β × δ), ⇑(⇑φ p.fst) p.snd),	W' : set G,	W'_nhd : W' ∈ 𝓝 0,	x₀ : α,	y₁ : δ,	Nx : filter α := 𝓝 x₀,	ee : β × β → α × α := λ (u : β × β), (⇑e u.fst, ⇑e u.snd)	⊢ filter.tendsto (λ (a : β × β), (a.snd - a.fst, y₁)) (filter.comap ⇑e Nx ×ᶠ filter.comap ⇑e Nx) (𝓝 (0, y₁))		α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	G : Type u_5,	_inst_1 : topological_space α,	_inst_2 : add_comm_group α,	_inst_3 : topological_add_group α,	_inst_4 : topological_space β,	_inst_5 : add_comm_group β,	_inst_6 : topological_add_group β,	_inst_7 : topological_space γ,	_inst_8 : add_comm_group γ,	_inst_9 : topological_add_group γ,	_inst_10 : topological_space δ,	_inst_11 : add_comm_group δ,	_inst_12 : topological_add_group δ,	_inst_13 : uniform_space G,	_inst_14 : add_comm_group G,	_inst_15 : uniform_add_group G,	_inst_16 : separated_space G,	_inst_17 : complete_space G,	e : β →+ α,	de : dense_inducing ⇑e,	f : δ →+ γ,	df : dense_inducing ⇑f,	φ : β →+ δ →+ G,	hφ : continuous (λ (p : β × δ), ⇑(⇑φ p.fst) p.snd),	W' : set G,	W'_nhd : W' ∈ 𝓝 0,	x₀ : α,	y₁ : δ,	Nx : filter α := 𝓝 x₀,	ee : β × β → α × α := λ (u : β × β), (⇑e u.fst, ⇑e u.snd),	lim1 : filter.tendsto (λ (a : β × β), (a.snd - a.fst, y₁)) (filter.comap ⇑e Nx ×ᶠ filter.comap ⇑e Nx) (𝓝 (0, y₁))	⊢ ∃ (U₂ : set β) (H : U₂ ∈ filter.comap ⇑e (𝓝 x₀)), ∀ (x x' : β), x ∈ U₂ → x' ∈ U₂ → (λ (p : β × δ), ⇑(⇑φ p.fst) p.snd) (x' - x, y₁) ∈ W'
α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	G : Type u_5,	_inst_1 : topological_space α,	_inst_2 : add_comm_group α,	_inst_3 : topological_add_group α,	_inst_4 : topological_space β,	_inst_5 : add_comm_group β,	_inst_6 : topological_add_group β,	_inst_7 : topological_space γ,	_inst_8 : add_comm_group γ,	_inst_9 : topological_add_group γ,	_inst_10 : topological_space δ,	_inst_11 : add_comm_group δ,	_inst_12 : topological_add_group δ,	_inst_13 : uniform_space G,	_inst_14 : add_comm_group G,	_inst_15 : uniform_add_group G,	_inst_16 : separated_space G,	_inst_17 : complete_space G,	e : β →+ α,	de : dense_inducing ⇑e,	f : δ →+ γ,	df : dense_inducing ⇑f,	φ : β →+ δ →+ G,	hφ : continuous (λ (p : β × δ), ⇑(⇑φ p.fst) p.snd),	W' : set G,	W'_nhd : W' ∈ 𝓝 0,	x₀ : α,	y₁ : δ,	Nx : filter α := 𝓝 x₀,	ee : β × β → α × α := λ (u : β × β), (⇑e u.fst, ⇑e u.snd),	this : filter.tendsto (λ (x : β × β), ((λ (t : β × β), t.snd - t.fst) x, (λ (b : β × β), y₁) x)) (filter.comap (λ (p : β × β), (⇑e p.fst, ⇑e p.snd)) (𝓝 (x₀, x₀))) (𝓝 0 ×ᶠ 𝓝 y₁)	⊢ filter.tendsto (λ (a : β × β), (a.snd - a.fst, y₁)) (filter.comap (λ (p : β × β), (⇑e p.fst, ⇑e p.snd)) (𝓝 (x₀, x₀))) (𝓝 0 ×ᶠ 𝓝 y₁)
α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	G : Type u_5,	_inst_1 : topological_space α,	_inst_2 : add_comm_group α,	_inst_3 : topological_add_group α,	_inst_4 : topological_space β,	_inst_5 : add_comm_group β,	_inst_6 : topological_add_group β,	_inst_7 : topological_space γ,	_inst_8 : add_comm_group γ,	_inst_9 : topological_add_group γ,	_inst_10 : topological_space δ,	_inst_11 : add_comm_group δ,	_inst_12 : topological_add_group δ,	_inst_13 : uniform_space G,	_inst_14 : add_comm_group G,	_inst_15 : uniform_add_group G,	_inst_16 : separated_space G,	_inst_17 : complete_space G,	e : β →+ α,	de : dense_inducing ⇑e,	f : δ →+ γ,	df : dense_inducing ⇑f,	φ : β →+ δ →+ G,	hφ : continuous (λ (p : β × δ), ⇑(⇑φ p.fst) p.snd),	W' : set G,	W'_nhd : W' ∈ 𝓝 0,	x₀ : α,	y₁ : δ,	Nx : filter α := 𝓝 x₀,	ee : β × β → α × α := λ (u : β × β), (⇑e u.fst, ⇑e u.snd),	lim1 : filter.tendsto (λ (a : β × β), (a.snd - a.fst, y₁)) (filter.comap ⇑e Nx ×ᶠ filter.comap ⇑e Nx) (𝓝 (0, y₁))	⊢ ∃ (U₂ : set β) (H : U₂ ∈ filter.comap ⇑e (𝓝 x₀)), ∀ (x x' : β), x ∈ U₂ → x' ∈ U₂ → (λ (p : β × δ), ⇑(⇑φ p.fst) p.snd) (x' - x, y₁) ∈ W'
α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	G : Type u_5,	_inst_1 : topological_space α,	_inst_2 : add_comm_group α,	_inst_3 : topological_add_group α,	_inst_4 : topological_space β,	_inst_5 : add_comm_group β,	_inst_6 : topological_add_group β,	_inst_7 : topological_space γ,	_inst_8 : add_comm_group γ,	_inst_9 : topological_add_group γ,	_inst_10 : topological_space δ,	_inst_11 : add_comm_group δ,	_inst_12 : topological_add_group δ,	_inst_13 : uniform_space G,	_inst_14 : add_comm_group G,	_inst_15 : uniform_add_group G,	_inst_16 : separated_space G,	_inst_17 : complete_space G,	e : β →+ α,	de : dense_inducing ⇑e,	f : δ →+ γ,	df : dense_inducing ⇑f,	φ : β →+ δ →+ G,	hφ : continuous (λ (p : β × δ), ⇑(⇑φ p.fst) p.snd),	W' : set G,	W'_nhd : W' ∈ 𝓝 0,	x₀ : α,	y₁ : δ,	Nx : filter α := 𝓝 x₀,	ee : β × β → α × α := λ (u : β × β), (⇑e u.fst, ⇑e u.snd),	lim1 : filter.tendsto (λ (a : β × β), (a.snd - a.fst, y₁)) (filter.comap ⇑e Nx ×ᶠ filter.comap ⇑e Nx) (𝓝 (0, y₁))	⊢ filter.tendsto (λ (p : β × δ), ⇑(⇑φ p.fst) p.snd) (𝓝 (0, y₁)) (𝓝 0)
α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	G : Type u_5,	_inst_1 : topological_space α,	_inst_2 : add_comm_group α,	_inst_3 : topological_add_group α,	_inst_4 : topological_space β,	_inst_5 : add_comm_group β,	_inst_6 : topological_add_group β,	_inst_7 : topological_space γ,	_inst_8 : add_comm_group γ,	_inst_9 : topological_add_group γ,	_inst_10 : topological_space δ,	_inst_11 : add_comm_group δ,	_inst_12 : topological_add_group δ,	_inst_13 : uniform_space G,	_inst_14 : add_comm_group G,	_inst_15 : uniform_add_group G,	_inst_16 : separated_space G,	_inst_17 : complete_space G,	e : β →+ α,	de : dense_inducing ⇑e,	f : δ →+ γ,	df : dense_inducing ⇑f,	φ : β →+ δ →+ G,	hφ : continuous (λ (p : β × δ), ⇑(⇑φ p.fst) p.snd),	W' : set G,	W'_nhd : W' ∈ 𝓝 0,	x₀ : α,	y₁ : δ,	Nx : filter α := 𝓝 x₀,	ee : β × β → α × α := λ (u : β × β), (⇑e u.fst, ⇑e u.snd),	lim1 : filter.tendsto (λ (a : β × β), (a.snd - a.fst, y₁)) (filter.comap ⇑e Nx ×ᶠ filter.comap ⇑e Nx) (𝓝 (0, y₁)),	lim2 : filter.tendsto (λ (p : β × δ), ⇑(⇑φ p.fst) p.snd) (𝓝 (0, y₁)) (𝓝 0)	⊢ ∃ (U₂ : set β) (H : U₂ ∈ filter.comap ⇑e (𝓝 x₀)), ∀ (x x' : β), x ∈ U₂ → x' ∈ U₂ → (λ (p : β × δ), ⇑(⇑φ p.fst) p.snd) (x' - x, y₁) ∈ W'
α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	G : Type u_5,	_inst_1 : topological_space α,	_inst_2 : add_comm_group α,	_inst_3 : topological_add_group α,	_inst_4 : topological_space β,	_inst_5 : add_comm_group β,	_inst_6 : topological_add_group β,	_inst_7 : topological_space γ,	_inst_8 : add_comm_group γ,	_inst_9 : topological_add_group γ,	_inst_10 : topological_space δ,	_inst_11 : add_comm_group δ,	_inst_12 : topological_add_group δ,	_inst_13 : uniform_space G,	_inst_14 : add_comm_group G,	_inst_15 : uniform_add_group G,	_inst_16 : separated_space G,	_inst_17 : complete_space G,	e : β →+ α,	de : dense_inducing ⇑e,	f : δ →+ γ,	df : dense_inducing ⇑f,	φ : β →+ δ →+ G,	hφ : continuous (λ (p : β × δ), ⇑(⇑φ p.fst) p.snd),	W' : set G,	W'_nhd : W' ∈ 𝓝 0,	x₀ : α,	y₁ : δ,	Nx : filter α := 𝓝 x₀,	ee : β × β → α × α := λ (u : β × β), (⇑e u.fst, ⇑e u.snd),	lim1 : filter.tendsto (λ (a : β × β), (a.snd - a.fst, y₁)) (filter.comap ⇑e Nx ×ᶠ filter.comap ⇑e Nx) (𝓝 (0, y₁)),	lim2 : filter.tendsto (λ (p : β × δ), ⇑(⇑φ p.fst) p.snd) (𝓝 (0, y₁)) (𝓝 0),	lim : filter.tendsto ((λ (p : β × δ), ⇑(⇑φ p.fst) p.snd) ∘ λ (a : β × β), (a.snd - a.fst, y₁)) (filter.comap ⇑e Nx ×ᶠ filter.comap ⇑e Nx) (𝓝 0)	⊢ ∃ (U₂ : set β) (H : U₂ ∈ filter.comap ⇑e (𝓝 x₀)), ∀ (x x' : β), x ∈ U₂ → x' ∈ U₂ → (λ (p : β × δ), ⇑(⇑φ p.fst) p.snd) (x' - x, y₁) ∈ W'
α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	G : Type u_5,	_inst_1 : topological_space α,	_inst_2 : add_comm_group α,	_inst_3 : topological_add_group α,	_inst_4 : topological_space β,	_inst_5 : add_comm_group β,	_inst_6 : topological_add_group β,	_inst_7 : topological_space γ,	_inst_8 : add_comm_group γ,	_inst_9 : topological_add_group γ,	_inst_10 : topological_space δ,	_inst_11 : add_comm_group δ,	_inst_12 : topological_add_group δ,	_inst_13 : uniform_space G,	_inst_14 : add_comm_group G,	_inst_15 : uniform_add_group G,	_inst_16 : separated_space G,	_inst_17 : complete_space G,	e : β →+ α,	de : dense_inducing ⇑e,	f : δ →+ γ,	df : dense_inducing ⇑f,	φ : β →+ δ →+ G,	hφ : continuous (λ (p : β × δ), ⇑(⇑φ p.fst) p.snd),	W' : set G,	W'_nhd : W' ∈ 𝓝 0,	x₀ : α,	y₁ : δ,	Nx : filter α := 𝓝 x₀,	ee : β × β → α × α := λ (u : β × β), (⇑e u.fst, ⇑e u.snd),	lim1 : filter.tendsto (λ (a : β × β), (a.snd - a.fst, y₁)) (filter.comap ⇑e Nx ×ᶠ filter.comap ⇑e Nx) (𝓝 (0, y₁)),	lim2 : filter.tendsto (λ (p : β × δ), ⇑(⇑φ p.fst) p.snd) (𝓝 (0, y₁)) (𝓝 0),	lim : ∀ (W : set G), W ∈ 𝓝 0 → (∃ (U : set β) (H : U ∈ filter.comap ⇑e Nx), ∀ (x x' : β), x ∈ U → x' ∈ U → ((λ (p : β × δ), ⇑(⇑φ p.fst) p.snd) ∘ λ (a : β × β), (a.snd - a.fst, y₁)) (x, x') ∈ W)	⊢ ∃ (U₂ : set β) (H : U₂ ∈ filter.comap ⇑e (𝓝 x₀)), ∀ (x x' : β), x ∈ U₂ → x' ∈ U₂ → (λ (p : β × δ), ⇑(⇑φ p.fst) p.snd) (x' - x, y₁) ∈ W'
α : Type u,	t : topological_space α,	b : set (set α),	hb : topological_space.is_topological_basis b,	a : α,	s : set α	⊢ (∃ (t : set α) (H : t ∈ b), a ∈ t ∧ t ⊆ s) ↔ ∃ (i : set α) (hi : i ∈ b ∧ a ∈ i), i ⊆ s
α : Type u,	t : topological_space α,	_inst_1 : topological_space.second_countable_topology α,	_let_match : (∃ (b : set (set α)), b.countable ∧ t = topological_space.generate_from b) → (∃ (b : set (set α)), b.countable ∧ ∅ ∉ b ∧ topological_space.is_topological_basis b),	b : set (set α),	hb₁ : b.countable,	hb₂ : t = topological_space.generate_from b,	b' : set (set α) := (λ (s : set (set α)), ⋂₀ s) '' {s : set (set α) | s.finite ∧ s ⊆ b ∧ (⋂₀ s).nonempty}	⊢ {s : set (set α) | s.finite ∧ s ⊆ b ∧ (⋂₀ s).nonempty} ⊆ {t : set (set α) | t.finite ∧ t ⊆ b}
α : Type u,	t : topological_space α,	_inst_1 : topological_space.second_countable_topology α,	_let_match : (∃ (b : set (set α)), b.countable ∧ t = topological_space.generate_from b) → (∃ (b : set (set α)), b.countable ∧ ∅ ∉ b ∧ topological_space.is_topological_basis b),	b : set (set α),	hb₁ : b.countable,	hb₂ : t = topological_space.generate_from b,	b' : set (set α) := (λ (s : set (set α)), ⋂₀ s) '' {s : set (set α) | s.finite ∧ s ⊆ b ∧ (⋂₀ s).nonempty}	⊢ {s : set (set α) | (s.finite ∧ s ⊆ b) ∧ (⋂₀ s).nonempty} ⊆ {t : set (set α) | t.finite ∧ t ⊆ b}
α : Type u_1,	β : Type u_2,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	f : α → β,	s : set α,	h : continuous f	⊢ f '' closure s ⊆ closure (f '' s)
α : Type u_1,	β : Type u_2,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	f : α → β,	s : set α,	h : continuous f	⊢ closure s ⊆ f ⁻¹' closure (f '' s)
α : Type u,	s : set α,	_inst_1 : topological_space α	⊢ is_open s ↔ ∀ (x : α), x ∈ s → (∃ (t : set α) (H : t ⊆ s), is_open t ∧ x ∈ t)
α : Type u,	s : set α,	_inst_1 : topological_space α	⊢ s ⊆ interior s ↔ ∀ (x : α), x ∈ s → (∃ (t : set α) (H : t ⊆ s), is_open t ∧ x ∈ t)
α : Type u,	s : set α,	_inst_1 : topological_space α	⊢ is_open s ↔ ∀ (x : α), x ∈ s → (∃ (t : set α) (H : t ⊆ s), is_open t ∧ x ∈ t)
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s,	G : finset ↥S,	hG : U ⊆ ⋃ (i : ↥S) (H : i ∈ G), (λ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s) i,	j0 : J,	hj0 : ∀ {X : J}, X ∈ finset.image j G → nonempty (j0 ⟶ X),	f : Π (s : ↥S), s ∈ G → (j0 ⟶ j s) := λ (s : ↥S) (hs : s ∈ G), _.some,	W : ↥S → set ↥(F.obj j0) := λ (s : ↥S), dite (s ∈ G) (λ (hs : s ∈ G), ⇑(F.map (f s hs)) ⁻¹' V s) (λ (hs : s ∉ G), set.univ),	x : ↥(C.X)	⊢ x ∈ U ↔ x ∈ ⇑(C.π.app j0) ⁻¹' ⋃ (s : ↥S) (hs : s ∈ G), W s
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s,	G : finset ↥S,	hG : U ⊆ ⋃ (i : ↥S) (H : i ∈ G), (λ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s) i,	j0 : J,	hj0 : ∀ {X : J}, X ∈ finset.image j G → nonempty (j0 ⟶ X),	f : Π (s : ↥S), s ∈ G → (j0 ⟶ j s) := λ (s : ↥S) (hs : s ∈ G), _.some,	W : ↥S → set ↥(F.obj j0) := λ (s : ↥S), dite (s ∈ G) (λ (hs : s ∈ G), ⇑(F.map (f s hs)) ⁻¹' V s) (λ (hs : s ∉ G), set.univ),	x : ↥(C.X)	⊢ x ∈ U → (x ∈ ⇑(C.π.app j0) ⁻¹' ⋃ (s : ↥S) (hs : s ∈ G), W s)
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s,	G : finset ↥S,	hG : U ⊆ ⋃ (i : ↥S) (H : i ∈ G), (λ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s) i,	j0 : J,	hj0 : ∀ {X : J}, X ∈ finset.image j G → nonempty (j0 ⟶ X),	f : Π (s : ↥S), s ∈ G → (j0 ⟶ j s) := λ (s : ↥S) (hs : s ∈ G), _.some,	W : ↥S → set ↥(F.obj j0) := λ (s : ↥S), dite (s ∈ G) (λ (hs : s ∈ G), ⇑(F.map (f s hs)) ⁻¹' V s) (λ (hs : s ∉ G), set.univ),	x : ↥(C.X),	hx : x ∈ U	⊢ x ∈ ⇑(C.π.app j0) ⁻¹' ⋃ (s : ↥S) (hs : s ∈ G), W s
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s,	G : finset ↥S,	hG : U ⊆ ⋃ (i : ↥S) (H : i ∈ G), (λ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s) i,	j0 : J,	hj0 : ∀ {X : J}, X ∈ finset.image j G → nonempty (j0 ⟶ X),	f : Π (s : ↥S), s ∈ G → (j0 ⟶ j s) := λ (s : ↥S) (hs : s ∈ G), _.some,	W : ↥S → set ↥(F.obj j0) := λ (s : ↥S), dite (s ∈ G) (λ (hs : s ∈ G), ⇑(F.map (f s hs)) ⁻¹' V s) (λ (hs : s ∉ G), set.univ),	x : ↥(C.X),	hx : x ∈ U	⊢ ∃ (i : ↥S) (i_1 : i ∈ G), x ∈ ⇑(C.π.app j0) ⁻¹' W i
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s,	G : finset ↥S,	hG : U ⊆ ⋃ (i : ↥S) (H : i ∈ G), (λ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s) i,	j0 : J,	hj0 : ∀ {X : J}, X ∈ finset.image j G → nonempty (j0 ⟶ X),	f : Π (s : ↥S), s ∈ G → (j0 ⟶ j s) := λ (s : ↥S) (hs : s ∈ G), _.some,	W : ↥S → set ↥(F.obj j0) := λ (s : ↥S), dite (s ∈ G) (λ (hs : s ∈ G), ⇑(F.map (f s hs)) ⁻¹' V s) (λ (hs : s ∉ G), set.univ),	x : ↥(C.X),	hx : x ∈ U,	s : ↥S,	hs : s ∈ G,	hh : x ∈ (λ (H : s ∈ G), (λ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s) s) hs	⊢ ∃ (i : ↥S) (i_1 : i ∈ G), x ∈ ⇑(C.π.app j0) ⁻¹' W i
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s,	G : finset ↥S,	hG : U ⊆ ⋃ (i : ↥S) (H : i ∈ G), (λ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s) i,	j0 : J,	hj0 : ∀ {X : J}, X ∈ finset.image j G → nonempty (j0 ⟶ X),	f : Π (s : ↥S), s ∈ G → (j0 ⟶ j s) := λ (s : ↥S) (hs : s ∈ G), _.some,	W : ↥S → set ↥(F.obj j0) := λ (s : ↥S), dite (s ∈ G) (λ (hs : s ∈ G), ⇑(F.map (f s hs)) ⁻¹' V s) (λ (hs : s ∉ G), set.univ),	x : ↥(C.X),	hx : x ∈ U,	s : ↥S,	hs : s ∈ G,	hh : x ∈ (λ (H : s ∈ G), (λ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s) s) hs	⊢ x ∈ ⇑(C.π.app j0) ⁻¹' W s
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s,	G : finset ↥S,	hG : U ⊆ ⋃ (i : ↥S) (H : i ∈ G), (λ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s) i,	j0 : J,	hj0 : ∀ {X : J}, X ∈ finset.image j G → nonempty (j0 ⟶ X),	f : Π (s : ↥S), s ∈ G → (j0 ⟶ j s) := λ (s : ↥S) (hs : s ∈ G), _.some,	W : ↥S → set ↥(F.obj j0) := λ (s : ↥S), dite (s ∈ G) (λ (hs : s ∈ G), ⇑(F.map (f s hs)) ⁻¹' V s) (λ (hs : s ∉ G), set.univ),	x : ↥(C.X)	⊢ x ∈ U → (x ∈ ⇑(C.π.app j0) ⁻¹' ⋃ (s : ↥S) (hs : s ∈ G), W s)		J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s,	G : finset ↥S,	hG : U ⊆ ⋃ (i : ↥S) (H : i ∈ G), (λ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s) i,	j0 : J,	hj0 : ∀ {X : J}, X ∈ finset.image j G → nonempty (j0 ⟶ X),	f : Π (s : ↥S), s ∈ G → (j0 ⟶ j s) := λ (s : ↥S) (hs : s ∈ G), _.some,	W : ↥S → set ↥(F.obj j0) := λ (s : ↥S), dite (s ∈ G) (λ (hs : s ∈ G), ⇑(F.map (f s hs)) ⁻¹' V s) (λ (hs : s ∉ G), set.univ),	x : ↥(C.X)	⊢ (x ∈ ⇑(C.π.app j0) ⁻¹' ⋃ (s : ↥S) (hs : s ∈ G), W s) → x ∈ U
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s,	G : finset ↥S,	hG : U ⊆ ⋃ (i : ↥S) (H : i ∈ G), (λ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s) i,	j0 : J,	hj0 : ∀ {X : J}, X ∈ finset.image j G → nonempty (j0 ⟶ X),	f : Π (s : ↥S), s ∈ G → (j0 ⟶ j s) := λ (s : ↥S) (hs : s ∈ G), _.some,	W : ↥S → set ↥(F.obj j0) := λ (s : ↥S), dite (s ∈ G) (λ (hs : s ∈ G), ⇑(F.map (f s hs)) ⁻¹' V s) (λ (hs : s ∉ G), set.univ),	x : ↥(C.X),	hx : x ∈ U,	s : ↥S,	hs : s ∈ G,	hh : x ∈ ⇑(C.π.app (j s)) ⁻¹' V s	⊢ x ∈ ⇑(C.π.app j0) ⁻¹' dite (s ∈ G) (λ (hs : s ∈ G), ⇑(F.map (f s hs)) ⁻¹' V s) (λ (hs : s ∉ G), set.univ)
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s,	G : finset ↥S,	hG : U ⊆ ⋃ (i : ↥S) (H : i ∈ G), (λ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s) i,	j0 : J,	hj0 : ∀ {X : J}, X ∈ finset.image j G → nonempty (j0 ⟶ X),	f : Π (s : ↥S), s ∈ G → (j0 ⟶ j s) := λ (s : ↥S) (hs : s ∈ G), _.some,	W : ↥S → set ↥(F.obj j0) := λ (s : ↥S), dite (s ∈ G) (λ (hs : s ∈ G), ⇑(F.map (f s hs)) ⁻¹' V s) (λ (hs : s ∉ G), set.univ),	x : ↥(C.X)	⊢ (x ∈ ⇑(C.π.app j0) ⁻¹' ⋃ (s : ↥S) (hs : s ∈ G), W s) → x ∈ U
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s,	G : finset ↥S,	hG : U ⊆ ⋃ (i : ↥S) (H : i ∈ G), (λ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s) i,	j0 : J,	hj0 : ∀ {X : J}, X ∈ finset.image j G → nonempty (j0 ⟶ X),	f : Π (s : ↥S), s ∈ G → (j0 ⟶ j s) := λ (s : ↥S) (hs : s ∈ G), _.some,	W : ↥S → set ↥(F.obj j0) := λ (s : ↥S), dite (s ∈ G) (λ (hs : s ∈ G), ⇑(F.map (f s hs)) ⁻¹' V s) (λ (hs : s ∉ G), set.univ),	x : ↥(C.X),	hx : x ∈ ⇑(C.π.app j0) ⁻¹' ⋃ (s : ↥S) (hs : s ∈ G), W s	⊢ x ∈ U
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s,	G : finset ↥S,	hG : U ⊆ ⋃ (i : ↥S) (H : i ∈ G), (λ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s) i,	j0 : J,	hj0 : ∀ {X : J}, X ∈ finset.image j G → nonempty (j0 ⟶ X),	f : Π (s : ↥S), s ∈ G → (j0 ⟶ j s) := λ (s : ↥S) (hs : s ∈ G), _.some,	W : ↥S → set ↥(F.obj j0) := λ (s : ↥S), dite (s ∈ G) (λ (hs : s ∈ G), ⇑(F.map (f s hs)) ⁻¹' V s) (λ (hs : s ∉ G), set.univ),	x : ↥(C.X),	hx : ∃ (i : ↥S) (i_1 : i ∈ G), x ∈ ⇑(C.π.app j0) ⁻¹' W i	⊢ x ∈ U
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s,	G : finset ↥S,	hG : U ⊆ ⋃ (i : ↥S) (H : i ∈ G), (λ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s) i,	j0 : J,	hj0 : ∀ {X : J}, X ∈ finset.image j G → nonempty (j0 ⟶ X),	f : Π (s : ↥S), s ∈ G → (j0 ⟶ j s) := λ (s : ↥S) (hs : s ∈ G), _.some,	W : ↥S → set ↥(F.obj j0) := λ (s : ↥S), dite (s ∈ G) (λ (hs : s ∈ G), ⇑(F.map (f s hs)) ⁻¹' V s) (λ (hs : s ∉ G), set.univ),	x : ↥(C.X),	s : ↥S,	hs : s ∈ G,	hx : x ∈ ⇑(C.π.app j0) ⁻¹' W s	⊢ x ∈ U
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s,	G : finset ↥S,	hG : U ⊆ ⋃ (i : ↥S) (H : i ∈ G), (λ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s) i,	j0 : J,	hj0 : ∀ {X : J}, X ∈ finset.image j G → nonempty (j0 ⟶ X),	f : Π (s : ↥S), s ∈ G → (j0 ⟶ j s) := λ (s : ↥S) (hs : s ∈ G), _.some,	W : ↥S → set ↥(F.obj j0) := λ (s : ↥S), dite (s ∈ G) (λ (hs : s ∈ G), ⇑(F.map (f s hs)) ⁻¹' V s) (λ (hs : s ∉ G), set.univ),	x : ↥(C.X),	s : ↥S,	hs : s ∈ G,	hx : x ∈ ⇑(C.π.app j0) ⁻¹' W s	⊢ x ∈ ⋃₀ S
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s,	G : finset ↥S,	hG : U ⊆ ⋃ (i : ↥S) (H : i ∈ G), (λ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s) i,	j0 : J,	hj0 : ∀ {X : J}, X ∈ finset.image j G → nonempty (j0 ⟶ X),	f : Π (s : ↥S), s ∈ G → (j0 ⟶ j s) := λ (s : ↥S) (hs : s ∈ G), _.some,	W : ↥S → set ↥(F.obj j0) := λ (s : ↥S), dite (s ∈ G) (λ (hs : s ∈ G), ⇑(F.map (f s hs)) ⁻¹' V s) (λ (hs : s ∉ G), set.univ),	x : ↥(C.X),	s : ↥S,	hs : s ∈ G,	hx : x ∈ ⇑(C.π.app j0) ⁻¹' W s	⊢ x ∈ s.val
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s,	G : finset ↥S,	hG : U ⊆ ⋃ (i : ↥S) (H : i ∈ G), (λ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s) i,	j0 : J,	hj0 : ∀ {X : J}, X ∈ finset.image j G → nonempty (j0 ⟶ X),	f : Π (s : ↥S), s ∈ G → (j0 ⟶ j s) := λ (s : ↥S) (hs : s ∈ G), _.some,	W : ↥S → set ↥(F.obj j0) := λ (s : ↥S), dite (s ∈ G) (λ (hs : s ∈ G), ⇑(F.map (f s hs)) ⁻¹' V s) (λ (hs : s ∉ G), set.univ),	x : ↥(C.X),	s : ↥S,	hs : s ∈ G,	hx : x ∈ ⇑(C.π.app j0) ⁻¹' W s	⊢ x ∈ ⇑(C.π.app (j s)) ⁻¹' V s
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s,	G : finset ↥S,	hG : U ⊆ ⋃ (i : ↥S) (H : i ∈ G), (λ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s) i,	j0 : J,	hj0 : ∀ {X : J}, X ∈ finset.image j G → nonempty (j0 ⟶ X),	f : Π (s : ↥S), s ∈ G → (j0 ⟶ j s) := λ (s : ↥S) (hs : s ∈ G), _.some,	W : ↥S → set ↥(F.obj j0) := λ (s : ↥S), dite (s ∈ G) (λ (hs : s ∈ G), ⇑(F.map (f s hs)) ⁻¹' V s) (λ (hs : s ∉ G), set.univ),	x : ↥(C.X),	s : ↥S,	hs : s ∈ G,	hx : x ∈ ⇑(C.π.app j0) ⁻¹' dite (s ∈ G) (λ (hs : s ∈ G), ⇑(F.map (f s hs)) ⁻¹' V s) (λ (hs : s ∉ G), set.univ)	⊢ x ∈ ⇑(C.π.app (j s)) ⁻¹' V s
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U	⊢ ∃ (j : J) (V : set ↥(F.obj j)) (hV : is_clopen V), U = ⇑(C.π.app j) ⁻¹' V
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	hB : topological_space.is_topological_basis {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V}	⊢ ∃ (j : J) (V : set ↥(F.obj j)) (hV : is_clopen V), U = ⇑(C.π.app j) ⁻¹' V		J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U	⊢ ∀ (j : J), topological_space.is_topological_basis ((λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j)		J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U	⊢ ∀ (i j : J) (f : i ⟶ j) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j → ⇑((F ⋙ Profinite.to_Top).map f) ⁻¹' V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) i
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U	⊢ ∀ (j : J), topological_space.is_topological_basis ((λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j)
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	i : J	⊢ topological_space.is_topological_basis ((λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) i)
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U	⊢ ∀ (j : J), topological_space.is_topological_basis ((λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j)		J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U	⊢ ∀ (i j : J) (f : i ⟶ j) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j → ⇑((F ⋙ Profinite.to_Top).map f) ⁻¹' V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) i		J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	hB : topological_space.is_topological_basis {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V}	⊢ ∃ (j : J) (V : set ↥(F.obj j)) (hV : is_clopen V), U = ⇑(C.π.app j) ⁻¹' V
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	i : J	⊢ topological_space.is_topological_basis {W : set ↥(F.obj i) | is_clopen W}
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U	⊢ ∀ (i j : J) (f : i ⟶ j) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j → ⇑((F ⋙ Profinite.to_Top).map f) ⁻¹' V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) i
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	i j : J,	f : i ⟶ j,	V : set ↥((F ⋙ Profinite.to_Top).obj j),	hV : is_clopen V	⊢ ⇑((F ⋙ Profinite.to_Top).map f) ⁻¹' V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) i
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	i j : J,	f : i ⟶ j,	V : set ↥((F ⋙ Profinite.to_Top).obj j),	hV : is_clopen V	⊢ ⇑((F ⋙ Profinite.to_Top).map f) ⁻¹' V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) i
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U	⊢ ∀ (i j : J) (f : i ⟶ j) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j → ⇑((F ⋙ Profinite.to_Top).map f) ⁻¹' V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) i		J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	hB : topological_space.is_topological_basis {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V}	⊢ ∃ (j : J) (V : set ↥(F.obj j)) (hV : is_clopen V), U = ⇑(C.π.app j) ⁻¹' V
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	i j : J,	f : i ⟶ j,	V : set ↥((F ⋙ Profinite.to_Top).obj j),	hV : is_clopen V	⊢ continuous ⇑((F ⋙ Profinite.to_Top).map f)
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	hB : topological_space.is_topological_basis {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V}	⊢ ∃ (j : J) (V : set ↥(F.obj j)) (hV : is_clopen V), U = ⇑(C.π.app j) ⁻¹' V
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	hB : topological_space.is_topological_basis {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S	⊢ ∃ (j : J) (V : set ↥(F.obj j)) (hV : is_clopen V), U = ⇑(C.π.app j) ⁻¹' V
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S	⊢ ∃ (j : J) (V : set ↥(F.obj j)) (hV : is_clopen V), U = ⇑(C.π.app j) ⁻¹' V
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _	⊢ ∃ (j : J) (V : set ↥(F.obj j)) (hV : is_clopen V), U = ⇑(C.π.app j) ⁻¹' V
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _	⊢ ∃ (j : J) (V : set ↥(F.obj j)) (hV : is_clopen V), U = ⇑(C.π.app j) ⁻¹' V
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s	⊢ ∃ (j : J) (V : set ↥(F.obj j)) (hV : is_clopen V), U = ⇑(C.π.app j) ⁻¹' V
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s,	this : ∃ (t : finset ↥S), U ⊆ ⋃ (i : ↥S) (H : i ∈ t), (λ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s) i	⊢ ∃ (j : J) (V : set ↥(F.obj j)) (hV : is_clopen V), U = ⇑(C.π.app j) ⁻¹' V		J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s	⊢ ∀ (i : ↥S), is_open ((λ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s) i)		J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s	⊢ U ⊆ ⋃ (i : ↥S), (λ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s) i
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s	⊢ ∀ (i : ↥S), is_open ((λ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s) i)
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s,	s : ↥S	⊢ is_open ((λ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s) s)
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s	⊢ ∀ (i : ↥S), is_open ((λ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s) i)		J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s	⊢ U ⊆ ⋃ (i : ↥S), (λ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s) i		J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s,	this : ∃ (t : finset ↥S), U ⊆ ⋃ (i : ↥S) (H : i ∈ t), (λ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s) i	⊢ ∃ (j : J) (V : set ↥(F.obj j)) (hV : is_clopen V), U = ⇑(C.π.app j) ⁻¹' V
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s,	s : ↥S	⊢ continuous ⇑(C.π.app (j s))
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s	⊢ U ⊆ ⋃ (i : ↥S), (λ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s) i
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s	⊢ U ⊆ ⋃ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s	⊢ ⋃₀ S ⊆ ⋃ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s,	x : ↥(C.X),	T : set ↥((Profinite.to_Top.map_cone C).X),	hT : T ∈ S,	hx : x ∈ T	⊢ x ∈ ⋃ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s,	x : ↥(C.X),	T : set ↥((Profinite.to_Top.map_cone C).X),	hT : T ∈ S,	hx : x ∈ T	⊢ x ∈ (λ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s) ⟨T, hT⟩
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s	⊢ U ⊆ ⋃ (i : ↥S), (λ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s) i		J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s,	this : ∃ (t : finset ↥S), U ⊆ ⋃ (i : ↥S) (H : i ∈ t), (λ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s) i	⊢ ∃ (j : J) (V : set ↥(F.obj j)) (hV : is_clopen V), U = ⇑(C.π.app j) ⁻¹' V
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s,	x : ↥(C.X),	T : set ↥((Profinite.to_Top.map_cone C).X),	hT : T ∈ S,	hx : x ∈ T	⊢ x ∈ ⇑(C.π.app (j ⟨T, hT⟩)) ⁻¹' V ⟨T, hT⟩
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s,	this : ∃ (t : finset ↥S), U ⊆ ⋃ (i : ↥S) (H : i ∈ t), (λ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s) i	⊢ ∃ (j : J) (V : set ↥(F.obj j)) (hV : is_clopen V), U = ⇑(C.π.app j) ⁻¹' V
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s,	G : finset ↥S,	hG : U ⊆ ⋃ (i : ↥S) (H : i ∈ G), (λ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s) i	⊢ ∃ (j : J) (V : set ↥(F.obj j)) (hV : is_clopen V), U = ⇑(C.π.app j) ⁻¹' V
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s,	G : finset ↥S,	hG : U ⊆ ⋃ (i : ↥S) (H : i ∈ G), (λ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s) i,	j0 : J,	hj0 : ∀ {X : J}, X ∈ finset.image j G → nonempty (j0 ⟶ X)	⊢ ∃ (j : J) (V : set ↥(F.obj j)) (hV : is_clopen V), U = ⇑(C.π.app j) ⁻¹' V
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s,	G : finset ↥S,	hG : U ⊆ ⋃ (i : ↥S) (H : i ∈ G), (λ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s) i,	j0 : J,	hj0 : ∀ {X : J}, X ∈ finset.image j G → nonempty (j0 ⟶ X),	f : Π (s : ↥S), s ∈ G → (j0 ⟶ j s) := λ (s : ↥S) (hs : s ∈ G), _.some	⊢ ∃ (j : J) (V : set ↥(F.obj j)) (hV : is_clopen V), U = ⇑(C.π.app j) ⁻¹' V
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s,	G : finset ↥S,	hG : U ⊆ ⋃ (i : ↥S) (H : i ∈ G), (λ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s) i,	j0 : J,	hj0 : ∀ {X : J}, X ∈ finset.image j G → nonempty (j0 ⟶ X),	f : Π (s : ↥S), s ∈ G → (j0 ⟶ j s) := λ (s : ↥S) (hs : s ∈ G), _.some,	W : ↥S → set ↥(F.obj j0) := λ (s : ↥S), dite (s ∈ G) (λ (hs : s ∈ G), ⇑(F.map (f s hs)) ⁻¹' V s) (λ (hs : s ∉ G), set.univ)	⊢ ∃ (j : J) (V : set ↥(F.obj j)) (hV : is_clopen V), U = ⇑(C.π.app j) ⁻¹' V
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s,	G : finset ↥S,	hG : U ⊆ ⋃ (i : ↥S) (H : i ∈ G), (λ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s) i,	j0 : J,	hj0 : ∀ {X : J}, X ∈ finset.image j G → nonempty (j0 ⟶ X),	f : Π (s : ↥S), s ∈ G → (j0 ⟶ j s) := λ (s : ↥S) (hs : s ∈ G), _.some,	W : ↥S → set ↥(F.obj j0) := λ (s : ↥S), dite (s ∈ G) (λ (hs : s ∈ G), ⇑(F.map (f s hs)) ⁻¹' V s) (λ (hs : s ∉ G), set.univ)	⊢ is_clopen (⋃ (s : ↥S) (hs : s ∈ G), W s)
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s,	G : finset ↥S,	hG : U ⊆ ⋃ (i : ↥S) (H : i ∈ G), (λ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s) i,	j0 : J,	hj0 : ∀ {X : J}, X ∈ finset.image j G → nonempty (j0 ⟶ X),	f : Π (s : ↥S), s ∈ G → (j0 ⟶ j s) := λ (s : ↥S) (hs : s ∈ G), _.some,	W : ↥S → set ↥(F.obj j0) := λ (s : ↥S), dite (s ∈ G) (λ (hs : s ∈ G), ⇑(F.map (f s hs)) ⁻¹' V s) (λ (hs : s ∉ G), set.univ)	⊢ ∀ (i : ↥S), i ∈ G → is_clopen (W i)
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s,	G : finset ↥S,	hG : U ⊆ ⋃ (i : ↥S) (H : i ∈ G), (λ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s) i,	j0 : J,	hj0 : ∀ {X : J}, X ∈ finset.image j G → nonempty (j0 ⟶ X),	f : Π (s : ↥S), s ∈ G → (j0 ⟶ j s) := λ (s : ↥S) (hs : s ∈ G), _.some,	W : ↥S → set ↥(F.obj j0) := λ (s : ↥S), dite (s ∈ G) (λ (hs : s ∈ G), ⇑(F.map (f s hs)) ⁻¹' V s) (λ (hs : s ∉ G), set.univ),	s : ↥S,	hs : s ∈ G	⊢ is_clopen (W s)
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s,	G : finset ↥S,	hG : U ⊆ ⋃ (i : ↥S) (H : i ∈ G), (λ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s) i,	j0 : J,	hj0 : ∀ {X : J}, X ∈ finset.image j G → nonempty (j0 ⟶ X),	f : Π (s : ↥S), s ∈ G → (j0 ⟶ j s) := λ (s : ↥S) (hs : s ∈ G), _.some,	W : ↥S → set ↥(F.obj j0) := λ (s : ↥S), dite (s ∈ G) (λ (hs : s ∈ G), ⇑(F.map (f s hs)) ⁻¹' V s) (λ (hs : s ∉ G), set.univ),	s : ↥S,	hs : s ∈ G	⊢ is_clopen (dite (s ∈ G) (λ (hs : s ∈ G), ⇑(F.map (f s hs)) ⁻¹' V s) (λ (hs : s ∉ G), set.univ))
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s,	G : finset ↥S,	hG : U ⊆ ⋃ (i : ↥S) (H : i ∈ G), (λ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s) i,	j0 : J,	hj0 : ∀ {X : J}, X ∈ finset.image j G → nonempty (j0 ⟶ X),	f : Π (s : ↥S), s ∈ G → (j0 ⟶ j s) := λ (s : ↥S) (hs : s ∈ G), _.some,	W : ↥S → set ↥(F.obj j0) := λ (s : ↥S), dite (s ∈ G) (λ (hs : s ∈ G), ⇑(F.map (f s hs)) ⁻¹' V s) (λ (hs : s ∉ G), set.univ),	s : ↥S,	hs : s ∈ G	⊢ is_clopen (⇑(F.map (f s hs)) ⁻¹' V s)
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s,	G : finset ↥S,	hG : U ⊆ ⋃ (i : ↥S) (H : i ∈ G), (λ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s) i,	j0 : J,	hj0 : ∀ {X : J}, X ∈ finset.image j G → nonempty (j0 ⟶ X),	f : Π (s : ↥S), s ∈ G → (j0 ⟶ j s) := λ (s : ↥S) (hs : s ∈ G), _.some,	W : ↥S → set ↥(F.obj j0) := λ (s : ↥S), dite (s ∈ G) (λ (hs : s ∈ G), ⇑(F.map (f s hs)) ⁻¹' V s) (λ (hs : s ∉ G), set.univ),	s : ↥S,	hs : s ∈ G	⊢ is_clopen (⇑(F.map (f s hs)) ⁻¹' V s)
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s,	G : finset ↥S,	hG : U ⊆ ⋃ (i : ↥S) (H : i ∈ G), (λ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s) i,	j0 : J,	hj0 : ∀ {X : J}, X ∈ finset.image j G → nonempty (j0 ⟶ X),	f : Π (s : ↥S), s ∈ G → (j0 ⟶ j s) := λ (s : ↥S) (hs : s ∈ G), _.some,	W : ↥S → set ↥(F.obj j0) := λ (s : ↥S), dite (s ∈ G) (λ (hs : s ∈ G), ⇑(F.map (f s hs)) ⁻¹' V s) (λ (hs : s ∉ G), set.univ)	⊢ is_clopen (⋃ (s : ↥S) (hs : s ∈ G), W s)		J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s,	G : finset ↥S,	hG : U ⊆ ⋃ (i : ↥S) (H : i ∈ G), (λ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s) i,	j0 : J,	hj0 : ∀ {X : J}, X ∈ finset.image j G → nonempty (j0 ⟶ X),	f : Π (s : ↥S), s ∈ G → (j0 ⟶ j s) := λ (s : ↥S) (hs : s ∈ G), _.some,	W : ↥S → set ↥(F.obj j0) := λ (s : ↥S), dite (s ∈ G) (λ (hs : s ∈ G), ⇑(F.map (f s hs)) ⁻¹' V s) (λ (hs : s ∉ G), set.univ)	⊢ U = ⇑(C.π.app j0) ⁻¹' ⋃ (s : ↥S) (hs : s ∈ G), W s
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s,	G : finset ↥S,	hG : U ⊆ ⋃ (i : ↥S) (H : i ∈ G), (λ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s) i,	j0 : J,	hj0 : ∀ {X : J}, X ∈ finset.image j G → nonempty (j0 ⟶ X),	f : Π (s : ↥S), s ∈ G → (j0 ⟶ j s) := λ (s : ↥S) (hs : s ∈ G), _.some,	W : ↥S → set ↥(F.obj j0) := λ (s : ↥S), dite (s ∈ G) (λ (hs : s ∈ G), ⇑(F.map (f s hs)) ⁻¹' V s) (λ (hs : s ∉ G), set.univ),	s : ↥S,	hs : s ∈ G	⊢ continuous ⇑(F.map (f s hs))
J : Type u,	_inst_1 : category_theory.small_category J,	_inst_2 : category_theory.is_cofiltered J,	F : J ⥤ Profinite,	C : category_theory.limits.cone F,	hC : category_theory.limits.is_limit C,	U : set ↥(C.X),	hU : is_clopen U,	S : set (set ↥((Profinite.to_Top.map_cone C).X)),	hS : S ⊆ {U : set ↥((Profinite.to_Top.map_cone C).X) | ∃ (j : J) (V : set ↥((F ⋙ Profinite.to_Top).obj j)), V ∈ (λ (j : J), {W : set ↥((F ⋙ Profinite.to_Top).obj j) | is_clopen W}) j ∧ U = ⇑((Profinite.to_Top.map_cone C).π.app j) ⁻¹' V},	h : U = ⋃₀ S,	j : ↥S → J := λ (s : ↥S), Exists.some _,	V : Π (s : ↥S), set ↥(F.obj (j s)) := λ (s : ↥S), Exists.some _,	hV : ∀ (s : ↥S), is_clopen (V s) ∧ s.val = ⇑(C.π.app (j s)) ⁻¹' V s,	G : finset ↥S,	hG : U ⊆ ⋃ (i : ↥S) (H : i ∈ G), (λ (s : ↥S), ⇑(C.π.app (j s)) ⁻¹' V s) i,	j0 : J,	hj0 : ∀ {X : J}, X ∈ finset.image j G → nonempty (j0 ⟶ X),	f : Π (s : ↥S), s ∈ G → (j0 ⟶ j s) := λ (s : ↥S) (hs : s ∈ G), _.some,	W : ↥S → set ↥(F.obj j0) := λ (s : ↥S), dite (s ∈ G) (λ (hs : s ∈ G), ⇑(F.map (f s hs)) ⁻¹' V s) (λ (hs : s ∉ G), set.univ)	⊢ U = ⇑(C.π.app j0) ⁻¹' ⋃ (s : ↥S) (hs : s ∈ G), W s
α : Type u,	_inst_1 : topological_space α,	x y : α	⊢ ⟦x⟧ = ⟦y⟧ ↔ connected_component x = connected_component y
α : Type u,	_inst_1 : topological_space α,	x y : α	⊢ ⟦x⟧ ≠ ⟦y⟧ ↔ connected_component x ≠ connected_component y
α : Type u,	β : Type v,	γ : Type w,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	_inst_3 : topological_space γ,	g : α × β → γ,	a : α,	h : continuous g	⊢ continuous (λ (b : β), (a, b))
ι : Type u_1,	π : ι → Type u_2,	_inst_1 : Π (a : ι), topological_space (π a),	a : ι,	s : set (Π (a : ι), π a),	_x : (topological_space.induced (λ (f : Π (a : ι), (λ (a : ι), π a) a), f a) ((λ (a : ι), _inst_1 a) a)).is_open s,	_fun_match : (topological_space.induced (λ (f : Π (a : ι), (λ (a : ι), π a) a), f a) ((λ (a : ι), _inst_1 a) a)).is_open s → (topological_space.generate_from {g : set (Π (a : ι), π a) | ∃ (s : Π (a : ι), set (π a)) (i : finset ι), (∀ (a : ι), a ∈ i → is_open (s a)) ∧ g = ↑i.pi s}).is_open s,	t : set ((λ (a : ι), π a) a),	ht : ((λ (a : ι), _inst_1 a) a).is_open t,	s_eq : (λ (f : Π (a : ι), (λ (a : ι), π a) a), f a) ⁻¹' t = s	⊢ ∀ (a_1 : ι), a_1 ∈ {a} → is_open (function.update (λ (a : ι), set.univ) a t a_1)
ι : Type u_1,	π : ι → Type u_2,	_inst_1 : Π (a : ι), topological_space (π a),	a : ι,	s : set (Π (a : ι), π a),	_x : (topological_space.induced (λ (f : Π (a : ι), (λ (a : ι), π a) a), f a) ((λ (a : ι), _inst_1 a) a)).is_open s,	_fun_match : (topological_space.induced (λ (f : Π (a : ι), (λ (a : ι), π a) a), f a) ((λ (a : ι), _inst_1 a) a)).is_open s → (topological_space.generate_from {g : set (Π (a : ι), π a) | ∃ (s : Π (a : ι), set (π a)) (i : finset ι), (∀ (a : ι), a ∈ i → is_open (s a)) ∧ g = ↑i.pi s}).is_open s,	t : set ((λ (a : ι), π a) a),	ht : ((λ (a : ι), _inst_1 a) a).is_open t,	s_eq : (λ (f : Π (a : ι), (λ (a : ι), π a) a), f a) ⁻¹' t = s	⊢ s = ↑{a}.pi (function.update (λ (a : ι), set.univ) a t)
ι : Type u_1,	π : ι → Type u_2,	_inst_1 : Π (a : ι), topological_space (π a),	a : ι,	s : set (Π (a : ι), π a),	_x : (topological_space.induced (λ (f : Π (a : ι), (λ (a : ι), π a) a), f a) ((λ (a : ι), _inst_1 a) a)).is_open s,	_fun_match : (topological_space.induced (λ (f : Π (a : ι), (λ (a : ι), π a) a), f a) ((λ (a : ι), _inst_1 a) a)).is_open s → (topological_space.generate_from {g : set (Π (a : ι), π a) | ∃ (s : Π (a : ι), set (π a)) (i : finset ι), (∀ (a : ι), a ∈ i → is_open (s a)) ∧ g = ↑i.pi s}).is_open s,	t : set ((λ (a : ι), π a) a),	ht : ((λ (a : ι), _inst_1 a) a).is_open t,	s_eq : (λ (f : Π (a : ι), (λ (a : ι), π a) a), f a) ⁻¹' t = s	⊢ s = ↑{a}.pi (function.update (λ (a : ι), set.univ) a t)
ι : Type u_1,	π : ι → Type u_2,	_inst_1 : Π (a : ι), topological_space (π a),	a : ι,	s : set (Π (a : ι), π a),	_x : (topological_space.induced (λ (f : Π (a : ι), (λ (a : ι), π a) a), f a) ((λ (a : ι), _inst_1 a) a)).is_open s,	_fun_match : (topological_space.induced (λ (f : Π (a : ι), (λ (a : ι), π a) a), f a) ((λ (a : ι), _inst_1 a) a)).is_open s → (topological_space.generate_from {g : set (Π (a : ι), π a) | ∃ (s : Π (a : ι), set (π a)) (i : finset ι), (∀ (a : ι), a ∈ i → is_open (s a)) ∧ g = ↑i.pi s}).is_open s,	t : set ((λ (a : ι), π a) a),	ht : ((λ (a : ι), _inst_1 a) a).is_open t,	s_eq : (λ (f : Π (a : ι), (λ (a : ι), π a) a), f a) ⁻¹' t = s,	f : Π (a : ι), π a	⊢ f ∈ s ↔ f ∈ ↑{a}.pi (function.update (λ (a : ι), set.univ) a t)
α : Type u_1,	β : Type u_2,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	A : set (set α),	F : Π (s : set α), s ∈ A → C(↥s, β),	hF : ∀ (s : set α) (hs : s ∈ A) (t : set α) (ht : t ∈ A) (x : α) (hxi : x ∈ s) (hxj : x ∈ t), ⇑(F s hs) ⟨x, hxi⟩ = ⇑(F t ht) ⟨x, hxj⟩,	hA : ∀ (x : α), ∃ (i : set α) (H : i ∈ A), i ∈ nhds x	⊢ C(α, β)
α : Type u_1,	β : Type u_2,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	A : set (set α),	F : Π (s : set α), s ∈ A → C(↥s, β),	hF : ∀ (s : set α) (hs : s ∈ A) (t : set α) (ht : t ∈ A) (x : α) (hxi : x ∈ s) (hxj : x ∈ t), ⇑(F s hs) ⟨x, hxi⟩ = ⇑(F t ht) ⟨x, hxj⟩,	hA : ∀ (x : α), ∃ (i : set α) (H : i ∈ A), i ∈ nhds x,	S : ↥A → set α := coe	⊢ C(α, β)
α : Type u_1,	β : Type u_2,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	A : set (set α),	F : Π (s : set α), s ∈ A → C(↥s, β),	hF : ∀ (s : set α) (hs : s ∈ A) (t : set α) (ht : t ∈ A) (x : α) (hxi : x ∈ s) (hxj : x ∈ t), ⇑(F s hs) ⟨x, hxi⟩ = ⇑(F t ht) ⟨x, hxj⟩,	hA : ∀ (x : α), ∃ (i : set α) (H : i ∈ A), i ∈ nhds x,	S : ↥A → set α := coe,	F : Π (i : ↥A), C(↥i, β) := λ (i : ↥A), F ↑i _	⊢ C(α, β)
α : Type u_1,	β : Type u_2,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	A : set (set α),	F : Π (s : set α), s ∈ A → C(↥s, β),	hF : ∀ (s : set α) (hs : s ∈ A) (t : set α) (ht : t ∈ A) (x : α) (hxi : x ∈ s) (hxj : x ∈ t), ⇑(F s hs) ⟨x, hxi⟩ = ⇑(F t ht) ⟨x, hxj⟩,	hA : ∀ (x : α), ∃ (i : set α) (H : i ∈ A), i ∈ nhds x,	S : ↥A → set α := coe,	F : Π (i : ↥A), C(↥i, β) := λ (i : ↥A), F ↑i _	⊢ ∀ (x : α), ∃ (i : ↥A), S i ∈ nhds x
α : Type u_1,	β : Type u_2,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	A : set (set α),	F : Π (s : set α), s ∈ A → C(↥s, β),	hF : ∀ (s : set α) (hs : s ∈ A) (t : set α) (ht : t ∈ A) (x : α) (hxi : x ∈ s) (hxj : x ∈ t), ⇑(F s hs) ⟨x, hxi⟩ = ⇑(F t ht) ⟨x, hxj⟩,	hA : ∀ (x : α), ∃ (i : set α) (H : i ∈ A), i ∈ nhds x,	S : ↥A → set α := coe,	F : Π (i : ↥A), C(↥i, β) := λ (i : ↥A), F ↑i _,	x : α	⊢ ∃ (i : ↥A), S i ∈ nhds x
α : Type u_1,	β : Type u_2,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	A : set (set α),	F : Π (s : set α), s ∈ A → C(↥s, β),	hF : ∀ (s : set α) (hs : s ∈ A) (t : set α) (ht : t ∈ A) (x : α) (hxi : x ∈ s) (hxj : x ∈ t), ⇑(F s hs) ⟨x, hxi⟩ = ⇑(F t ht) ⟨x, hxj⟩,	hA : ∀ (x : α), ∃ (i : set α) (H : i ∈ A), i ∈ nhds x,	S : ↥A → set α := coe,	F : Π (i : ↥A), C(↥i, β) := λ (i : ↥A), F ↑i _,	x : α,	s : set α,	hs : s ∈ A,	hsx : s ∈ nhds x	⊢ ∃ (i : ↥A), S i ∈ nhds x
α : Type u,	β : Type v,	_inst_1 : topological_space α,	_inst_2 : metric_space β,	f : α →ᵇ β,	x : α	⊢ has_dist.dist (⇑f x) (⇑f x) ≤ 0
α : Type u,	β : Type v,	_inst_1 : topological_space α,	_inst_2 : metric_space β,	f g : α →ᵇ β,	hfg : has_dist.dist f g = 0	⊢ f = g
α : Type u,	β : Type v,	_inst_1 : topological_space α,	_inst_2 : metric_space β,	f g : α →ᵇ β,	hfg : has_dist.dist f g = 0	⊢ f = g
α : Type u,	β : Type v,	_inst_1 : topological_space α,	_inst_2 : metric_space β,	f g : α →ᵇ β,	hfg : has_dist.dist f g = 0,	x : α	⊢ ⇑f x = ⇑g x
α : Type u,	β : Type v,	_inst_1 : topological_space α,	_inst_2 : metric_space β,	f g : α →ᵇ β	⊢ has_dist.dist f g = has_dist.dist g f
α : Type u,	β : Type v,	_inst_1 : topological_space α,	_inst_2 : metric_space β,	_inst_3 : add_monoid β,	_inst_4 : has_lipschitz_add β,	f g h : α →ᵇ β	⊢ f + g + h = f + (g + h)
α : Type u,	β : Type v,	_inst_1 : topological_space α,	_inst_2 : metric_space β,	_inst_3 : add_monoid β,	_inst_4 : has_lipschitz_add β,	f g h : α →ᵇ β	⊢ f + g + h = f + (g + h)
α : Type u,	β : Type v,	_inst_1 : topological_space α,	_inst_2 : metric_space β,	_inst_3 : add_monoid β,	_inst_4 : has_lipschitz_add β,	f g h : α →ᵇ β,	x : α	⊢ ⇑(f + g + h) x = ⇑(f + (g + h)) x
α : Type u,	β : Type v,	_inst_1 : topological_space α,	_inst_2 : metric_space β,	_inst_3 : add_monoid β,	_inst_4 : has_lipschitz_add β,	f : α →ᵇ β	⊢ 0 + f = f
α : Type u,	β : Type v,	_inst_1 : topological_space α,	_inst_2 : metric_space β,	_inst_3 : add_monoid β,	_inst_4 : has_lipschitz_add β,	f : α →ᵇ β	⊢ 0 + f = f
α : Type u,	β : Type v,	_inst_1 : topological_space α,	_inst_2 : metric_space β,	_inst_3 : add_monoid β,	_inst_4 : has_lipschitz_add β,	f : α →ᵇ β,	x : α	⊢ ⇑(0 + f) x = ⇑f x
α : Type u,	β : Type v,	_inst_1 : topological_space α,	_inst_2 : metric_space β,	_inst_3 : add_monoid β,	_inst_4 : has_lipschitz_add β,	f : α →ᵇ β	⊢ f + 0 = f
α : Type u,	β : Type v,	_inst_1 : topological_space α,	_inst_2 : metric_space β,	_inst_3 : add_monoid β,	_inst_4 : has_lipschitz_add β,	f : α →ᵇ β	⊢ f + 0 = f
α : Type u,	β : Type v,	_inst_1 : topological_space α,	_inst_2 : metric_space β,	_inst_3 : add_monoid β,	_inst_4 : has_lipschitz_add β,	f : α →ᵇ β,	x : α	⊢ ⇑(f + 0) x = ⇑f x
α : Type u,	β : Type v,	_inst_1 : topological_space α,	_inst_2 : normed_group β,	f : α →ᵇ β	⊢ -f + f = 0
α : Type u,	β : Type v,	_inst_1 : topological_space α,	_inst_2 : normed_group β,	f : α →ᵇ β	⊢ -f + f = 0
α : Type u,	β : Type v,	_inst_1 : topological_space α,	_inst_2 : normed_group β,	f : α →ᵇ β,	x : α	⊢ ⇑(-f + f) x = ⇑0 x
α : Type u,	β : Type v,	_inst_1 : topological_space α,	_inst_2 : normed_group β,	f g : α →ᵇ β	⊢ f + g = g + f
α : Type u,	β : Type v,	_inst_1 : topological_space α,	_inst_2 : normed_group β,	f g : α →ᵇ β	⊢ f + g = g + f
α : Type u,	β : Type v,	_inst_1 : topological_space α,	_inst_2 : normed_group β,	f g : α →ᵇ β,	x : α	⊢ ⇑(f + g) x = ⇑(g + f) x
α : Type u,	β : Type v,	_inst_1 : topological_space α,	_inst_2 : normed_group β,	f g : α →ᵇ β	⊢ f - g = f + -g
α : Type u,	β : Type v,	_inst_1 : topological_space α,	_inst_2 : normed_group β,	f g : α →ᵇ β,	x : α	⊢ ⇑(f - g) x = ⇑(f + -g) x
α : Type u,	β : Type v,	𝕜 : Type u_1,	_inst_1 : metric_space 𝕜,	_inst_2 : semiring 𝕜,	_inst_3 : topological_space α,	_inst_4 : metric_space β,	_inst_5 : add_comm_monoid β,	_inst_6 : module 𝕜 β,	_inst_7 : has_bounded_smul 𝕜 β,	c : 𝕜,	f₁ f₂ : α →ᵇ β	⊢ has_dist.dist (c • f₁) (c • f₂) ≤ has_dist.dist c 0 * has_dist.dist f₁ f₂
α : Type u,	β : Type v,	𝕜 : Type u_1,	_inst_1 : metric_space 𝕜,	_inst_2 : semiring 𝕜,	_inst_3 : topological_space α,	_inst_4 : metric_space β,	_inst_5 : add_comm_monoid β,	_inst_6 : module 𝕜 β,	_inst_7 : has_bounded_smul 𝕜 β,	c : 𝕜,	f₁ f₂ : α →ᵇ β	⊢ ∀ (x : α), has_dist.dist (⇑(c • f₁) x) (⇑(c • f₂) x) ≤ has_dist.dist c 0 * has_dist.dist f₁ f₂
α : Type u,	β : Type v,	𝕜 : Type u_1,	_inst_1 : metric_space 𝕜,	_inst_2 : semiring 𝕜,	_inst_3 : topological_space α,	_inst_4 : metric_space β,	_inst_5 : add_comm_monoid β,	_inst_6 : module 𝕜 β,	_inst_7 : has_bounded_smul 𝕜 β,	c : 𝕜,	f₁ f₂ : α →ᵇ β,	x : α	⊢ has_dist.dist (⇑(c • f₁) x) (⇑(c • f₂) x) ≤ has_dist.dist c 0 * has_dist.dist f₁ f₂
α : Type u,	β : Type v,	𝕜 : Type u_1,	_inst_1 : metric_space 𝕜,	_inst_2 : semiring 𝕜,	_inst_3 : topological_space α,	_inst_4 : metric_space β,	_inst_5 : add_comm_monoid β,	_inst_6 : module 𝕜 β,	_inst_7 : has_bounded_smul 𝕜 β,	c : 𝕜,	f₁ f₂ : α →ᵇ β,	x : α	⊢ has_dist.dist c 0 * has_dist.dist (⇑f₁ x) (⇑f₂ x) ≤ has_dist.dist c 0 * has_dist.dist f₁ f₂
α : Type u,	β : Type v,	𝕜 : Type u_1,	_inst_1 : metric_space 𝕜,	_inst_2 : semiring 𝕜,	_inst_3 : topological_space α,	_inst_4 : metric_space β,	_inst_5 : add_comm_monoid β,	_inst_6 : module 𝕜 β,	_inst_7 : has_bounded_smul 𝕜 β,	c₁ c₂ : 𝕜,	f : α →ᵇ β	⊢ has_dist.dist (c₁ • f) (c₂ • f) ≤ has_dist.dist c₁ c₂ * has_dist.dist f 0
α : Type u,	β : Type v,	𝕜 : Type u_1,	_inst_1 : metric_space 𝕜,	_inst_2 : semiring 𝕜,	_inst_3 : topological_space α,	_inst_4 : metric_space β,	_inst_5 : add_comm_monoid β,	_inst_6 : module 𝕜 β,	_inst_7 : has_bounded_smul 𝕜 β,	c₁ c₂ : 𝕜,	f : α →ᵇ β	⊢ ∀ (x : α), has_dist.dist (⇑(c₁ • f) x) (⇑(c₂ • f) x) ≤ has_dist.dist c₁ c₂ * has_dist.dist f 0
α : Type u,	β : Type v,	𝕜 : Type u_1,	_inst_1 : metric_space 𝕜,	_inst_2 : semiring 𝕜,	_inst_3 : topological_space α,	_inst_4 : metric_space β,	_inst_5 : add_comm_monoid β,	_inst_6 : module 𝕜 β,	_inst_7 : has_bounded_smul 𝕜 β,	c₁ c₂ : 𝕜,	f : α →ᵇ β,	x : α	⊢ has_dist.dist (⇑(c₁ • f) x) (⇑(c₂ • f) x) ≤ has_dist.dist c₁ c₂ * has_dist.dist f 0
α : Type u,	β : Type v,	𝕜 : Type u_1,	_inst_1 : metric_space 𝕜,	_inst_2 : semiring 𝕜,	_inst_3 : topological_space α,	_inst_4 : metric_space β,	_inst_5 : add_comm_monoid β,	_inst_6 : module 𝕜 β,	_inst_7 : has_bounded_smul 𝕜 β,	c₁ c₂ : 𝕜,	f : α →ᵇ β,	x : α	⊢ has_dist.dist c₁ c₂ * has_dist.dist (⇑f x) 0 ≤ has_dist.dist c₁ c₂ * has_dist.dist f 0
α : Type u,	β : Type v,	𝕜 : Type u_1,	_inst_1 : metric_space 𝕜,	_inst_2 : semiring 𝕜,	_inst_3 : topological_space α,	_inst_4 : metric_space β,	_inst_5 : add_comm_monoid β,	_inst_6 : module 𝕜 β,	_inst_7 : has_bounded_smul 𝕜 β,	c₁ c₂ : 𝕜,	f : α →ᵇ β,	x : α	⊢ 0 = ⇑0 x
α : Type u,	β : Type v,	γ : Type w,	𝕜 : Type u_1,	_inst_1 : topological_space α,	_inst_2 : normed_group β,	_inst_3 : nondiscrete_normed_field 𝕜,	_inst_4 : normed_space 𝕜 β,	_inst_5 : normed_group γ,	_inst_6 : normed_space 𝕜 γ,	g : β →L[𝕜] γ,	f g : α →ᵇ β	⊢ bounded_continuous_function.of_normed_group (⇑g ∘ ⇑(f + g)) _ (∥g∥ * ∥f + g∥) _ = bounded_continuous_function.of_normed_group (⇑g ∘ ⇑f) _ (∥g∥ * ∥f∥) _ + bounded_continuous_function.of_normed_group (⇑g ∘ ⇑g) _ (∥g∥ * ∥g∥) _
α : Type u,	β : Type v,	γ : Type w,	𝕜 : Type u_1,	_inst_1 : topological_space α,	_inst_2 : normed_group β,	_inst_3 : nondiscrete_normed_field 𝕜,	_inst_4 : normed_space 𝕜 β,	_inst_5 : normed_group γ,	_inst_6 : normed_space 𝕜 γ,	g : β →L[𝕜] γ,	f g : α →ᵇ β	⊢ bounded_continuous_function.of_normed_group (⇑g ∘ ⇑(f + g)) _ (∥g∥ * ∥f + g∥) _ = bounded_continuous_function.of_normed_group (⇑g ∘ ⇑f) _ (∥g∥ * ∥f∥) _ + bounded_continuous_function.of_normed_group (⇑g ∘ ⇑g) _ (∥g∥ * ∥g∥) _
α : Type u,	β : Type v,	γ : Type w,	𝕜 : Type u_1,	_inst_1 : topological_space α,	_inst_2 : normed_group β,	_inst_3 : nondiscrete_normed_field 𝕜,	_inst_4 : normed_space 𝕜 β,	_inst_5 : normed_group γ,	_inst_6 : normed_space 𝕜 γ,	g : β →L[𝕜] γ,	f g : α →ᵇ β,	x : α	⊢ ⇑(bounded_continuous_function.of_normed_group (⇑g ∘ ⇑(f + g)) _ (∥g∥ * ∥f + g∥) _) x = ⇑(bounded_continuous_function.of_normed_group (⇑g ∘ ⇑f) _ (∥g∥ * ∥f∥) _ + bounded_continuous_function.of_normed_group (⇑g ∘ ⇑g) _ (∥g∥ * ∥g∥) _) x
α : Type u,	β : Type v,	γ : Type w,	𝕜 : Type u_1,	_inst_1 : topological_space α,	_inst_2 : normed_group β,	_inst_3 : nondiscrete_normed_field 𝕜,	_inst_4 : normed_space 𝕜 β,	_inst_5 : normed_group γ,	_inst_6 : normed_space 𝕜 γ,	g : β →L[𝕜] γ,	c : 𝕜,	f : α →ᵇ β	⊢ bounded_continuous_function.of_normed_group (⇑g ∘ ⇑(c • f)) _ (∥g∥ * ∥c • f∥) _ = ⇑(ring_hom.id 𝕜) c • bounded_continuous_function.of_normed_group (⇑g ∘ ⇑f) _ (∥g∥ * ∥f∥) _
α : Type u,	β : Type v,	γ : Type w,	𝕜 : Type u_1,	_inst_1 : topological_space α,	_inst_2 : normed_group β,	_inst_3 : nondiscrete_normed_field 𝕜,	_inst_4 : normed_space 𝕜 β,	_inst_5 : normed_group γ,	_inst_6 : normed_space 𝕜 γ,	g : β →L[𝕜] γ,	c : 𝕜,	f : α →ᵇ β	⊢ bounded_continuous_function.of_normed_group (⇑g ∘ ⇑(c • f)) _ (∥g∥ * ∥c • f∥) _ = ⇑(ring_hom.id 𝕜) c • bounded_continuous_function.of_normed_group (⇑g ∘ ⇑f) _ (∥g∥ * ∥f∥) _
α : Type u,	β : Type v,	γ : Type w,	𝕜 : Type u_1,	_inst_1 : topological_space α,	_inst_2 : normed_group β,	_inst_3 : nondiscrete_normed_field 𝕜,	_inst_4 : normed_space 𝕜 β,	_inst_5 : normed_group γ,	_inst_6 : normed_space 𝕜 γ,	g : β →L[𝕜] γ,	c : 𝕜,	f : α →ᵇ β,	x : α	⊢ ⇑(bounded_continuous_function.of_normed_group (⇑g ∘ ⇑(c • f)) _ (∥g∥ * ∥c • f∥) _) x = ⇑(⇑(ring_hom.id 𝕜) c • bounded_continuous_function.of_normed_group (⇑g ∘ ⇑f) _ (∥g∥ * ∥f∥) _) x
X : Type u_1,	_inst_1 : topological_space X,	_inst_2 : compact_space X,	A : subalgebra ℝ C(X, ℝ),	f : ↥A,	p : C(↥(set.Icc (-∥f∥) ∥f∥), ℝ),	mem_closure : p ∈ (polynomial_functions (set.Icc (-∥f∥) ∥f∥)).topological_closure,	frequently_mem_polynomials : ∃ᶠ (x : C(↥(set.Icc (-∥f∥) ∥f∥), ℝ)) in nhds p, x ∈ ↑(polynomial_functions (set.Icc (-∥f∥) ∥f∥))	⊢ ∃ᶠ (x : C(X, ℝ)) in nhds (p.comp ↑f.attach_bound), x ∈ ↑A
X : Type u_1,	_inst_1 : topological_space X,	_inst_2 : compact_space X,	A : subalgebra ℝ C(X, ℝ),	f : ↥A,	p : C(↥(set.Icc (-∥f∥) ∥f∥), ℝ),	mem_closure : p ∈ (polynomial_functions (set.Icc (-∥f∥) ∥f∥)).topological_closure,	frequently_mem_polynomials : ∃ᶠ (x : C(↥(set.Icc (-∥f∥) ∥f∥), ℝ)) in nhds p, x ∈ ↑(polynomial_functions (set.Icc (-∥f∥) ∥f∥))	⊢ ∀ (x : C(↥(set.Icc (-∥↑f∥) ∥↑f∥), ℝ)), x ∈ ↑(polynomial_functions (set.Icc (-∥f∥) ∥f∥)) → ⇑(continuous_map.comp_right_continuous_map ℝ ↑f.attach_bound) x ∈ ↑A
X : Type u_1,	_inst_1 : topological_space X,	_inst_2 : compact_space X,	A : subalgebra ℝ C(X, ℝ),	f : ↥A,	p : C(↥(set.Icc (-∥f∥) ∥f∥), ℝ),	mem_closure : p ∈ (polynomial_functions (set.Icc (-∥f∥) ∥f∥)).topological_closure,	frequently_mem_polynomials : ∃ᶠ (x : C(↥(set.Icc (-∥f∥) ∥f∥), ℝ)) in nhds p, x ∈ ↑(polynomial_functions (set.Icc (-∥f∥) ∥f∥)),	g : polynomial ℝ	⊢ ⇑(continuous_map.comp_right_continuous_map ℝ ↑f.attach_bound) (⇑↑(polynomial.to_continuous_map_on_alg_hom (set.Icc (-∥f∥) ∥f∥)) g) ∈ ↑A
X : Type u_1,	_inst_1 : topological_space X,	_inst_2 : compact_space X,	A : subalgebra ℝ C(X, ℝ),	f : ↥A,	p : C(↥(set.Icc (-∥f∥) ∥f∥), ℝ),	mem_closure : p ∈ (polynomial_functions (set.Icc (-∥f∥) ∥f∥)).topological_closure,	frequently_mem_polynomials : ∃ᶠ (x : C(↥(set.Icc (-∥f∥) ∥f∥), ℝ)) in nhds p, x ∈ ↑(polynomial_functions (set.Icc (-∥f∥) ∥f∥)),	g : polynomial ℝ	⊢ (g.to_continuous_map_on (set.Icc (-∥f∥) ∥f∥)).comp ↑f.attach_bound ∈ A
X : Type u_1,	_inst_1 : topological_space X,	_inst_2 : compact_space X,	A : subalgebra ℝ C(X, ℝ),	f : ↥A,	p : C(↥(set.Icc (-∥f∥) ∥f∥), ℝ)	⊢ p.comp ↑f.attach_bound ∈ A.topological_closure
X : Type u_1,	_inst_1 : topological_space X,	_inst_2 : compact_space X,	A : subalgebra ℝ C(X, ℝ),	f : ↥A,	p : C(↥(set.Icc (-∥f∥) ∥f∥), ℝ),	mem_closure : p ∈ (polynomial_functions (set.Icc (-∥f∥) ∥f∥)).topological_closure	⊢ p.comp ↑f.attach_bound ∈ A.topological_closure
X : Type u_1,	_inst_1 : topological_space X,	_inst_2 : compact_space X,	A : subalgebra ℝ C(X, ℝ),	f : ↥A,	p : C(↥(set.Icc (-∥f∥) ∥f∥), ℝ),	mem_closure : p ∈ (polynomial_functions (set.Icc (-∥f∥) ∥f∥)).topological_closure,	frequently_mem_polynomials : ∃ᶠ (x : C(↥(set.Icc (-∥f∥) ∥f∥), ℝ)) in nhds p, x ∈ ↑(polynomial_functions (set.Icc (-∥f∥) ∥f∥))	⊢ p.comp ↑f.attach_bound ∈ A.topological_closure
ι : Type u_1,	α : ι → Type u_2,	_inst_2 : Π (i : ι), topological_space (α i),	I : set ι,	hI : I.finite,	s : Π (i : ι), set (α i),	x : Π (i : ι), α i	⊢ 𝓝[I.pi s] x = ⨅ (i : ι), filter.comap (λ (x : Π (i : ι), α i), x i) (𝓝 (x i) ⊓ ⨅ (hi : i ∈ I), 𝓟 (s i))
α : Type u_1,	β : Type u_2,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	f : α → β,	hf : open_embedding f,	s : set β,	x : α	⊢ filter.map f (𝓝[f ⁻¹' s] x) = 𝓝[s] f x
α : Type u_1,	β : Type u_2,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	f : α → β,	hf : open_embedding f,	s : set β,	x : α	⊢ 𝓝[s ∩ set.range f] f x = 𝓝[s] f x
α : Type u_1,	β : Type u_2,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	f : α → β,	hf : open_embedding f,	s : set β,	x : α	⊢ s ∩ set.range f ∩ set.range f = s ∩ set.range f
X : Type u_1,	_inst_1 : topological_space X,	A : discrete_quotient X	⊢ discrete_quotient.le_comap continuous_id A A
X : Type u_1,	_inst_1 : topological_space X,	Y : Type u_2,	_inst_2 : topological_space Y,	f : Y → X,	cont : continuous f,	A : discrete_quotient Y,	B : discrete_quotient X,	C : discrete_quotient Y,	cond : discrete_quotient.le_comap cont A B,	h : C ≤ A	⊢ discrete_quotient.map _ = discrete_quotient.map cond ∘ discrete_quotient.of_le h
X : Type u_1,	_inst_1 : topological_space X,	Y : Type u_2,	_inst_2 : topological_space Y,	f : Y → X,	cont : continuous f,	A : discrete_quotient Y,	B : discrete_quotient X,	C : discrete_quotient Y,	cond : discrete_quotient.le_comap cont A B,	h : C ≤ A,	x : Y	⊢ discrete_quotient.map _ (quot.mk setoid.r x) = (discrete_quotient.map cond ∘ discrete_quotient.of_le h) (quot.mk setoid.r x)
X : Type u,	Y : Type v,	_inst_1 : topological_space X,	_inst_2 : topological_space Y,	f₀ f₁ f₂ : C(X, Y),	F : f₀.homotopy f₁,	G : f₁.homotopy f₂,	x : ↥I × X	⊢ ⇑(F.trans G) x = dite (↑(x.fst) ≤ 1 / 2) (λ (h : ↑(x.fst) ≤ 1 / 2), ⇑F (⟨2 * ↑(x.fst), _⟩, x.snd)) (λ (h : ¬↑(x.fst) ≤ 1 / 2), ⇑G (⟨2 * ↑(x.fst) - 1, _⟩, x.snd))
X : Type u,	Y : Type v,	_inst_1 : topological_space X,	_inst_2 : topological_space Y,	f₀ f₁ f₂ : C(X, Y),	F : f₀.homotopy f₁,	G : f₁.homotopy f₂,	x : ↥I × X	⊢ ite (↑(x.fst) ≤ 1 / 2) (⇑(⇑(F.extend) (2 * ↑(x.fst))) x.snd) (⇑(⇑(G.extend) (2 * ↑(x.fst) - 1)) x.snd) = dite (↑(x.fst) ≤ 1 / 2) (λ (h : ↑(x.fst) ≤ 1 / 2), ⇑F (⟨2 * ↑(x.fst), _⟩, x.snd)) (λ (h : ¬↑(x.fst) ≤ 1 / 2), ⇑G (⟨2 * ↑(x.fst) - 1, _⟩, x.snd))
X : Type u,	Y : Type v,	_inst_1 : topological_space X,	_inst_2 : topological_space Y,	f₀ f₁ f₂ : C(X, Y),	F : f₀.homotopy f₁,	G : f₁.homotopy f₂,	x : ↥I × X,	h : ↑(x.fst) ≤ 1 / 2	⊢ ⇑(⇑(F.extend) (2 * ↑(x.fst))) x.snd = ⇑F (⟨2 * ↑(x.fst), _⟩, x.snd)
X : Type u,	Y : Type v,	_inst_1 : topological_space X,	_inst_2 : topological_space Y,	f₀ f₁ f₂ : C(X, Y),	F : f₀.homotopy f₁,	G : f₁.homotopy f₂,	x : ↥I × X,	h : ↑(x.fst) ≤ 1 / 2	⊢ ⇑(⇑(F.extend) (2 * ↑(x.fst))) x.snd = ⇑F (⟨2 * ↑(x.fst), _⟩, x.snd)		X : Type u,	Y : Type v,	_inst_1 : topological_space X,	_inst_2 : topological_space Y,	f₀ f₁ f₂ : C(X, Y),	F : f₀.homotopy f₁,	G : f₁.homotopy f₂,	x : ↥I × X,	h : ¬↑(x.fst) ≤ 1 / 2	⊢ ⇑(⇑(G.extend) (2 * ↑(x.fst) - 1)) x.snd = ⇑G (⟨2 * ↑(x.fst) - 1, _⟩, x.snd)
X : Type u,	Y : Type v,	_inst_1 : topological_space X,	_inst_2 : topological_space Y,	f₀ f₁ f₂ : C(X, Y),	F : f₀.homotopy f₁,	G : f₁.homotopy f₂,	x : ↥I × X,	h : ↑(x.fst) ≤ 1 / 2	⊢ ⇑(⇑(F.curry) ⟨2 * ↑(x.fst), ?m_1⟩) x.snd = ⇑F (⟨2 * ↑(x.fst), _⟩, x.snd)		X : Type u,	Y : Type v,	_inst_1 : topological_space X,	_inst_2 : topological_space Y,	f₀ f₁ f₂ : C(X, Y),	F : f₀.homotopy f₁,	G : f₁.homotopy f₂,	x : ↥I × X,	h : ↑(x.fst) ≤ 1 / 2	⊢ 2 * ↑(x.fst) ∈ set.Icc 0 1
X : Type u,	Y : Type v,	_inst_1 : topological_space X,	_inst_2 : topological_space Y,	f₀ f₁ f₂ : C(X, Y),	F : f₀.homotopy f₁,	G : f₁.homotopy f₂,	x : ↥I × X,	h : ¬↑(x.fst) ≤ 1 / 2	⊢ ⇑(⇑(G.extend) (2 * ↑(x.fst) - 1)) x.snd = ⇑G (⟨2 * ↑(x.fst) - 1, _⟩, x.snd)
X : Type u,	Y : Type v,	_inst_1 : topological_space X,	_inst_2 : topological_space Y,	f₀ f₁ f₂ : C(X, Y),	F : f₀.homotopy f₁,	G : f₁.homotopy f₂,	x : ↥I × X,	h : ¬↑(x.fst) ≤ 1 / 2	⊢ ⇑(⇑(G.curry) ⟨2 * ↑(x.fst) - 1, ?m_1⟩) x.snd = ⇑G (⟨2 * ↑(x.fst) - 1, _⟩, x.snd)		X : Type u,	Y : Type v,	_inst_1 : topological_space X,	_inst_2 : topological_space Y,	f₀ f₁ f₂ : C(X, Y),	F : f₀.homotopy f₁,	G : f₁.homotopy f₂,	x : ↥I × X,	h : ¬↑(x.fst) ≤ 1 / 2	⊢ 2 * ↑(x.fst) - 1 ∈ set.Icc 0 1
s : set ereal	⊢ s ∈ 𝓝 ⊥ ↔ ∃ (y : ℝ), set.Iio ↑y ⊆ s
s : set ereal	⊢ (∃ (i : ℝ), s ∈ 𝓟 (set.Iio ↑i)) ↔ ∃ (y : ℝ), set.Iio ↑y ⊆ s		s : set ereal	⊢ directed ge (λ (a : ℝ), 𝓟 (set.Iio ↑a))
s : set ereal	⊢ (∃ (i : ℝ), s ∈ 𝓟 (set.Iio ↑i)) ↔ ∃ (y : ℝ), set.Iio ↑y ⊆ s
s : set ereal,	x y : ℝ	⊢ (λ (a : ℝ), 𝓟 (set.Iio ↑a)) x ≥ (λ (a : ℝ), 𝓟 (set.Iio ↑a)) (linear_order.min x y)
s : set ereal	⊢ directed ge (λ (a : ℝ), 𝓟 (set.Iio ↑a))
s : set ereal,	x y : ℝ	⊢ (λ (a : ℝ), 𝓟 (set.Iio ↑a)) y ≥ (λ (a : ℝ), 𝓟 (set.Iio ↑a)) (linear_order.min x y)
x r : ℝ	⊢ is_compact (metric.closed_ball x r)
x r : ℝ	⊢ is_compact (set.Icc (x - r) (x + r))
f : ℝ → ℝ,	a b x y : ℝ,	h : continuous_on f [a, b],	hx : x ∈ [a, b],	hy : y ∈ [a, b]	⊢ [f x, f y] ⊆ f '' [a, b]
f : ℝ → ℝ,	a b x y : ℝ,	h : continuous_on f [a, b],	hx : x ∈ [a, b],	hy : y ∈ [a, b]	⊢ f x ∈ f '' [a, b] ∧ f y ∈ f '' [a, b]
α : Type u_1,	β : Type u_2,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	e : local_homeomorph α β,	x : α,	hx : x ∈ e.to_local_equiv.source,	s : set β	⊢ filter.map ⇑e (𝓝[⇑e ⁻¹' s] x) = 𝓝[s] ⇑e x
α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	_inst_3 : topological_space γ,	_inst_4 : topological_space δ,	η : Type u_5,	ε : Type u_6,	_inst_5 : topological_space η,	_inst_6 : topological_space ε,	e : local_homeomorph α β,	f : local_homeomorph β γ,	e' : local_homeomorph δ η,	f' : local_homeomorph η ε	⊢ ((e.prod e').trans (f.prod f')).to_local_equiv = ((e.trans f).prod (e'.trans f')).to_local_equiv
α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	_inst_3 : topological_space γ,	_inst_4 : topological_space δ,	η : Type u_5,	ε : Type u_6,	_inst_5 : topological_space η,	_inst_6 : topological_space ε,	e : local_homeomorph α β,	f : local_homeomorph β γ,	e' : local_homeomorph δ η,	f' : local_homeomorph η ε	⊢ (e.to_local_equiv.prod e'.to_local_equiv).trans (f.to_local_equiv.prod f'.to_local_equiv) = (e.to_local_equiv.trans f.to_local_equiv).prod (e'.to_local_equiv.trans f'.to_local_equiv)
α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	_inst_3 : topological_space γ,	_inst_4 : topological_space δ,	η : Type u_5,	ε : Type u_6,	_inst_5 : topological_space η,	_inst_6 : topological_space ε,	e : local_homeomorph α β,	f : local_homeomorph β γ,	e' : local_homeomorph δ η,	f' : local_homeomorph η ε	⊢ ((e.prod e').trans (f.prod f')).to_local_equiv = ((e.trans f).prod (e'.trans f')).to_local_equiv
α : Type u_1,	β : Type u_2,	γ : Type u_3,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	_inst_3 : topological_space γ,	f : α → β,	g : β → γ,	hf : continuous f,	hg : continuous g,	hgf : quotient_map (g ∘ f)	⊢ _inst_3 ≤ topological_space.coinduced g _inst_2
α : Type u_1,	β : Type u_2,	γ : Type u_3,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	_inst_3 : topological_space γ,	f : α → β,	g : β → γ,	hf : continuous f,	hg : continuous g,	hgf : quotient_map (g ∘ f)	⊢ _inst_3 ≤ topological_space.coinduced g _inst_2
α : Type u_1,	β : Type u_2,	γ : Type u_3,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	_inst_3 : topological_space γ,	f : α → β,	g : β → γ,	hf : continuous f,	hg : continuous g,	hgf : quotient_map (g ∘ f)	⊢ continuous (g ∘ f)
α : Type u_1,	β : Type u_2,	γ : Type u_3,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	_inst_3 : topological_space γ,	f : α → β,	g : β → γ,	hf : continuous f,	hg : continuous g,	hgf : quotient_map (g ∘ f)	⊢ topological_space.coinduced g _inst_2 ≤ _inst_3
α : Type u_1,	β : Type u_2,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	f : α → β,	open_map : is_open_map f,	cont : continuous f,	surj : function.surjective f	⊢ _inst_2 = topological_space.coinduced f _inst_1
α : Type u_1,	β : Type u_2,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	f : α → β,	open_map : is_open_map f,	cont : continuous f,	surj : function.surjective f,	s : set β	⊢ _inst_2.is_open s ↔ (topological_space.coinduced f _inst_1).is_open s
α : Type u_1,	β : Type u_2,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	f : α → β,	open_map : is_open_map f,	cont : continuous f,	surj : function.surjective f,	s : set β	⊢ is_open s ↔ is_open (f ⁻¹' s)
α : Type u_1,	β : Type u_2,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	f : α → β,	open_map : is_open_map f,	cont : continuous f,	surj : function.surjective f,	s : set β	⊢ is_open s → is_open (f ⁻¹' s)		α : Type u_1,	β : Type u_2,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	f : α → β,	open_map : is_open_map f,	cont : continuous f,	surj : function.surjective f,	s : set β	⊢ is_open (f ⁻¹' s) → is_open s
α : Type u_1,	β : Type u_2,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	f : α → β,	open_map : is_open_map f,	cont : continuous f,	surj : function.surjective f,	s : set β	⊢ is_open s → is_open (f ⁻¹' s)
α : Type u_1,	β : Type u_2,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	f : α → β,	open_map : is_open_map f,	cont : continuous f,	surj : function.surjective f,	s : set β	⊢ is_open (f ⁻¹' s) → is_open s
α : Type u_1,	β : Type u_2,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	f : α → β,	open_map : is_open_map f,	cont : continuous f,	surj : function.surjective f,	s : set β,	h : is_open (f ⁻¹' s)	⊢ is_open s
α : Type u_1,	β : Type u_2,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	f : α → β,	open_map : is_open_map f,	cont : continuous f,	surj : function.surjective f,	s : set β,	h : is_open (f ⁻¹' s)	⊢ is_open (f '' (f ⁻¹' s))
α : Type u_1,	β : Type u_2,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	f : α → β,	hf : inducing f,	h : is_closed (set.range f)	⊢ is_closed_map f
α : Type u_1,	β : Type u_2,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	f : α → β,	hf : inducing f,	h : is_closed (set.range f),	s : set α,	hs : is_closed s	⊢ is_closed (f '' s)
α : Type u_1,	β : Type u_2,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	f : α → β,	hf : inducing f,	h : is_closed (set.range f),	t : set β,	ht : is_closed t,	hs : is_closed (f ⁻¹' t)	⊢ is_closed (f '' (f ⁻¹' t))
α : Type u_1,	β : Type u_2,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	f : α → β,	hf : inducing f,	h : is_closed (set.range f),	t : set β,	ht : is_closed t,	hs : is_closed (f ⁻¹' t)	⊢ is_closed (t ∩ set.range f)
α : Type u_1,	_inst_1 : topological_space α	⊢ is_closed (set.range id)
α : Type u_1,	_inst_1 : topological_space α	⊢ is_closed (set.range id)
α : Type u_1,	_inst_1 : topological_space α	⊢ set.range id = set.univ
α : Type u,	_inst_1 : pseudo_metric_space α,	ι : Type u_1,	f : ι → α × α,	p : filter ι	⊢ filter.tendsto f p (𝓤 α) ↔ filter.tendsto (λ (x : ι), has_dist.dist (f x).fst (f x).snd) p (𝓝 0)
β : Type v,	π : β → Type u_1,	_inst_2 : fintype β,	_inst_3 : Π (b : β), pseudo_metric_space (π b),	f g : Π (b : β), π b,	r : ℝ,	hr : 0 ≤ r	⊢ has_dist.dist f g ≤ r ↔ ∀ (b : β), has_dist.dist (f b) (g b) ≤ r
β : Type v,	π : β → Type u_1,	_inst_2 : fintype β,	_inst_3 : Π (b : β), pseudo_metric_space (π b),	f g : Π (b : β), π b,	r : ℝ≥0	⊢ has_dist.dist f g ≤ ↑r ↔ ∀ (b : β), has_dist.dist (f b) (g b) ≤ ↑r
β : Type v,	π : β → Type u_1,	_inst_2 : fintype β,	_inst_3 : Π (b : β), pseudo_metric_space (π b),	x : Π (b : β), π b,	r : ℝ,	hr : 0 ≤ r,	p : Π (b : β), π b	⊢ p ∈ metric.closed_ball x r ↔ p ∈ set.univ.pi (λ (b : β), metric.closed_ball (x b) r)
β : Type v,	π : β → Type u_1,	_inst_2 : fintype β,	_inst_3 : Π (b : β), pseudo_metric_space (π b),	x : Π (b : β), π b,	r : ℝ,	hr : 0 ≤ r	⊢ metric.closed_ball x r = set.univ.pi (λ (b : β), metric.closed_ball (x b) r)
α : Type u,	_inst_1 : pseudo_metric_space α,	_inst_2 : proper_space α	⊢ ∀ {f : filter α}, cauchy f → (∃ (x : α), f ≤ 𝓝 x)
α : Type u,	_inst_1 : pseudo_metric_space α,	_inst_2 : proper_space α,	f : filter α,	hf : cauchy f	⊢ ∃ (x : α), f ≤ 𝓝 x
α : Type u,	_inst_1 : pseudo_metric_space α,	_inst_2 : proper_space α,	f : filter α,	hf : cauchy f,	t : set α,	t_fset : t ∈ f,	ht : ∀ (x y : α), x ∈ t → y ∈ t → has_dist.dist x y < 1	⊢ ∃ (x : α), f ≤ 𝓝 x
α : Type u,	_inst_1 : pseudo_metric_space α,	_inst_2 : proper_space α,	f : filter α,	hf : cauchy f,	t : set α,	t_fset : t ∈ f,	ht : ∀ (x y : α), x ∈ t → y ∈ t → has_dist.dist x y < 1,	x : α,	xt : x ∈ t	⊢ ∃ (x : α), f ≤ 𝓝 x
α : Type u,	_inst_1 : pseudo_metric_space α,	_inst_2 : proper_space α,	f : filter α,	hf : cauchy f,	t : set α,	t_fset : t ∈ f,	ht : ∀ (x y : α), x ∈ t → y ∈ t → has_dist.dist x y < 1,	x : α,	xt : x ∈ t,	this : metric.closed_ball x 1 ∈ f	⊢ ∃ (x : α), f ≤ 𝓝 x
α : Type u,	_inst_1 : pseudo_metric_space α,	_inst_2 : proper_space α,	f : filter α,	hf : cauchy f,	t : set α,	t_fset : t ∈ f,	ht : ∀ (x y : α), x ∈ t → y ∈ t → has_dist.dist x y < 1,	x : α,	xt : x ∈ t,	this : metric.closed_ball x 1 ∈ f,	y : α,	hy : f ≤ 𝓝 y	⊢ ∃ (x : α), f ≤ 𝓝 x
α : Type u,	_inst_1 : pseudo_metric_space α,	s t : set α,	h : s ⊆ t,	ht : metric.bounded t	⊢ metric.diam s ≤ metric.diam t
α : Type u,	_inst_1 : pseudo_metric_space α,	s t : set α,	h : s ⊆ t,	ht : metric.bounded t	⊢ (emetric.diam s).to_real ≤ (emetric.diam t).to_real
α : Type u,	_inst_1 : pseudo_metric_space α,	s t : set α,	h : s ⊆ t,	ht : metric.bounded t	⊢ emetric.diam s ≤ emetric.diam t
γ : Type w,	_inst_2 : metric_space γ,	x y : γ	⊢ has_dist.dist x y ≤ 0 ↔ x = y
α : Type u,	_inst_3 : pseudo_metric_space α	⊢ ∀ (a₁ a₂ b₁ b₂ : α), a₁ ≈ b₁ → a₂ ≈ b₂ → (λ (p q : α), has_dist.dist p q) a₁ a₂ = (λ (p q : α), has_dist.dist p q) b₁ b₂
α : Type u,	_inst_3 : pseudo_metric_space α,	x y x' y' : α,	hxx' : x ≈ x',	hyy' : y ≈ y'	⊢ (λ (p q : α), has_dist.dist p q) x y = (λ (p q : α), has_dist.dist p q) x' y'
α : Type u,	_inst_3 : pseudo_metric_space α,	x y x' y' : α,	hxx' : x ≈ x',	hyy' : y ≈ y',	Hxx' : has_dist.dist x x' = 0	⊢ (λ (p q : α), has_dist.dist p q) x y = (λ (p q : α), has_dist.dist p q) x' y'
α : Type u,	_inst_3 : pseudo_metric_space α,	x y x' y' : α,	hxx' : x ≈ x',	hyy' : y ≈ y',	Hxx' : has_dist.dist x x' = 0,	Hyy' : has_dist.dist y y' = 0	⊢ (λ (p q : α), has_dist.dist p q) x y = (λ (p q : α), has_dist.dist p q) x' y'
α : Type u,	_inst_3 : pseudo_metric_space α,	x y x' y' : α,	hxx' : x ≈ x',	hyy' : y ≈ y',	Hxx' : has_dist.dist x x' = 0,	Hyy' : has_dist.dist y y' = 0	⊢ has_dist.dist x x' + has_dist.dist x' y = has_dist.dist x' y
α : Type u,	_inst_3 : pseudo_metric_space α,	x y x' y' : α,	hxx' : x ≈ x',	hyy' : y ≈ y',	Hxx' : has_dist.dist x x' = 0,	Hyy' : has_dist.dist y y' = 0	⊢ has_dist.dist x' y' + has_dist.dist y' y = has_dist.dist x' y'
α : Type u,	_inst_3 : pseudo_metric_space α,	x y x' y' : α,	hxx' : x ≈ x',	hyy' : y ≈ y',	Hxx' : has_dist.dist x x' = 0,	Hyy' : has_dist.dist y y' = 0,	A : has_dist.dist x y ≤ has_dist.dist x' y'	⊢ (λ (p q : α), has_dist.dist p q) x y = (λ (p q : α), has_dist.dist p q) x' y'
α : Type u,	_inst_3 : pseudo_metric_space α,	x y x' y' : α,	hxx' : x ≈ x',	hyy' : y ≈ y',	Hxx' : has_dist.dist x x' = 0,	Hyy' : has_dist.dist y y' = 0,	A : has_dist.dist x y ≤ has_dist.dist x' y'	⊢ has_dist.dist x' x + has_dist.dist x y' = has_dist.dist x y'
α : Type u,	_inst_3 : pseudo_metric_space α,	x y x' y' : α,	hxx' : x ≈ x',	hyy' : y ≈ y',	Hxx' : has_dist.dist x x' = 0,	Hyy' : has_dist.dist y y' = 0,	A : has_dist.dist x y ≤ has_dist.dist x' y'	⊢ has_dist.dist x y + has_dist.dist y y' = has_dist.dist x y
α : Type u,	_inst_3 : pseudo_metric_space α,	x y x' y' : α,	hxx' : x ≈ x',	hyy' : y ≈ y',	Hxx' : has_dist.dist x x' = 0,	Hyy' : has_dist.dist y y' = 0,	A : has_dist.dist x y ≤ has_dist.dist x' y',	B : has_dist.dist x' y' ≤ has_dist.dist x y	⊢ (λ (p q : α), has_dist.dist p q) x y = (λ (p q : α), has_dist.dist p q) x' y'
α : Type u,	_inst_1 : pseudo_metric_space α,	x y : α	⊢ has_nndist.nndist x y = (has_edist.edist x y).to_nnreal
α : Type u,	_inst_1 : pseudo_metric_space α,	ε : ℝ,	x x_1 : α	⊢ x_1 ∈ uniform_space.ball x {p : α × α | has_dist.dist p.fst p.snd < ε} ↔ x_1 ∈ metric.ball x ε
α : Type u,	_inst_1 : pseudo_metric_space α,	ε : ℝ,	x : α	⊢ uniform_space.ball x {p : α × α | has_dist.dist p.fst p.snd < ε} = metric.ball x ε
α : Type u,	_inst_1 : pseudo_metric_space α,	x y : α,	ε : ℝ	⊢ x ∈ metric.ball y ε ↔ y ∈ metric.ball x ε
α : Type u,	_inst_1 : pseudo_metric_space α,	x : α,	ε : ℝ,	h : 0 ≤ ε,	y : α	⊢ y ∈ emetric.closed_ball x (ennreal.of_real ε) ↔ y ∈ metric.closed_ball x ε
α : Type u,	_inst_1 : pseudo_metric_space α,	x : α,	ε : ℝ,	h : 0 ≤ ε,	y : α	⊢ ennreal.of_real (has_dist.dist y x) ≤ ennreal.of_real ε ↔ has_dist.dist y x ≤ ε
α : Type u,	_inst_1 : pseudo_metric_space α,	x : α,	ε : ℝ,	h : 0 ≤ ε	⊢ emetric.closed_ball x (ennreal.of_real ε) = metric.closed_ball x ε
α : Type u,	_inst_1 : pseudo_metric_space α,	x : α,	ε : ℝ,	h : 0 ≤ ε	⊢ emetric.closed_ball x (ennreal.of_real ε) = metric.closed_ball x ε
α : Type u,	_inst_1 : pseudo_metric_space α,	x : α,	ε : ℝ,	h : 0 ≤ ε	⊢ emetric.closed_ball x (ennreal.of_real ε) = metric.closed_ball x ε
α : Type u,	_inst_1 : pseudo_emetric_space α,	x y : α,	ε : ℝ≥0∞	⊢ y ∈ emetric.ball x ε ↔ has_edist.edist x y < ε
α : Type u,	_inst_1 : pseudo_emetric_space α,	x y : α,	ε : ℝ≥0∞	⊢ y ∈ emetric.ball x ε ↔ has_edist.edist x y < ε
α : Type u,	_inst_1 : pseudo_emetric_space α,	x y : α,	ε : ℝ≥0∞	⊢ y ∈ emetric.ball x ε ↔ has_edist.edist y x < ε
X : Type u,	Y : Type v,	_inst_1 : metric_space X,	_inst_2 : metric_space Y,	_inst_3 : inhabited X,	_inst_4 : inhabited Y,	x y : X ⊕ Y	⊢ metric.sum.dist x y = metric.sum.dist y x
X : Type u,	Y : Type v,	_inst_1 : metric_space X,	_inst_2 : metric_space Y,	_inst_3 : inhabited X,	_inst_4 : inhabited Y,	x y : X ⊕ Y	⊢ metric.sum.dist x y = metric.sum.dist y x
X : Type u,	Y : Type v,	_inst_1 : metric_space X,	_inst_2 : metric_space Y,	_inst_3 : inhabited X,	_inst_4 : inhabited Y,	y : X ⊕ Y,	x : X	⊢ metric.sum.dist (sum.inl x) y = metric.sum.dist y (sum.inl x)
X : Type u,	Y : Type v,	_inst_1 : metric_space X,	_inst_2 : metric_space Y,	_inst_3 : inhabited X,	_inst_4 : inhabited Y,	y : X ⊕ Y,	x : Y	⊢ metric.sum.dist (sum.inr x) y = metric.sum.dist y (sum.inr x)
X : Type u,	Y : Type v,	_inst_1 : metric_space X,	_inst_2 : metric_space Y,	_inst_3 : inhabited X,	_inst_4 : inhabited Y,	x y : X	⊢ metric.sum.dist (sum.inl x) (sum.inl y) = metric.sum.dist (sum.inl y) (sum.inl x)
X : Type u,	Y : Type v,	_inst_1 : metric_space X,	_inst_2 : metric_space Y,	_inst_3 : inhabited X,	_inst_4 : inhabited Y,	x : X,	y : Y	⊢ metric.sum.dist (sum.inl x) (sum.inr y) = metric.sum.dist (sum.inr y) (sum.inl x)
X : Type u,	Y : Type v,	_inst_1 : metric_space X,	_inst_2 : metric_space Y,	_inst_3 : inhabited X,	_inst_4 : inhabited Y,	x : Y,	y : X	⊢ metric.sum.dist (sum.inr x) (sum.inl y) = metric.sum.dist (sum.inl y) (sum.inr x)
X : Type u,	Y : Type v,	_inst_1 : metric_space X,	_inst_2 : metric_space Y,	_inst_3 : inhabited X,	_inst_4 : inhabited Y,	x y : Y	⊢ metric.sum.dist (sum.inr x) (sum.inr y) = metric.sum.dist (sum.inr y) (sum.inr x)
X : Type u,	Y : Type v,	_inst_1 : metric_space X,	_inst_2 : metric_space Y,	_inst_3 : inhabited X,	_inst_4 : inhabited Y,	x y : X ⊕ Y	⊢ metric.sum.dist x y = metric.sum.dist y x
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed),	isom : ∀ (n : ℕ), isometry (coeZ ∘ Φ n ∘ (Y n).embed)	⊢ ∀ (n : ℕ), metric.Hausdorff_dist (X2 n) (X2 n.succ) < (1 / 2) ^ n		this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed),	isom : ∀ (n : ℕ), isometry (coeZ ∘ Φ n ∘ (Y n).embed),	D2 : ∀ (n : ℕ), metric.Hausdorff_dist (X2 n) (X2 n.succ) < (1 / 2) ^ n	⊢ ∃ (x : Gromov_Hausdorff.GH_space), filter.tendsto u filter.at_top (𝓝 x)
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed),	isom : ∀ (n : ℕ), isometry (coeZ ∘ Φ n ∘ (Y n).embed),	n : ℕ,	X2n : X2 n = coeZ ∘ Φ n.succ ∘ c n ∘ metric.to_glue_r _ _ '' set.range (Gromov_Hausdorff.optimal_GH_injl (X n) (X n.succ)),	X2nsucc : X2 n.succ = coeZ ∘ Φ n.succ ∘ c n ∘ metric.to_glue_r _ _ '' set.range (Gromov_Hausdorff.optimal_GH_injr (X n) (X n.succ))	⊢ isometry (Φ n.succ)
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed),	isom : ∀ (n : ℕ), isometry (coeZ ∘ Φ n ∘ (Y n).embed),	D2 : ∀ (n : ℕ), metric.Hausdorff_dist (X2 n) (X2 n.succ) < (1 / 2) ^ n	⊢ ∃ (x : Gromov_Hausdorff.GH_space), filter.tendsto u filter.at_top (𝓝 x)
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed),	isom : ∀ (n : ℕ), isometry (coeZ ∘ Φ n ∘ (Y n).embed),	D2 : ∀ (n : ℕ), metric.Hausdorff_dist (X2 n) (X2 n.succ) < (1 / 2) ^ n,	X3 : ℕ → topological_space.nonempty_compacts Z := λ (n : ℕ), ⟨X2 n, _⟩	⊢ ∃ (x : Gromov_Hausdorff.GH_space), filter.tendsto u filter.at_top (𝓝 x)
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed),	isom : ∀ (n : ℕ), isometry (coeZ ∘ Φ n ∘ (Y n).embed),	D2 : ∀ (n : ℕ), metric.Hausdorff_dist (X2 n) (X2 n.succ) < (1 / 2) ^ n,	X3 : ℕ → topological_space.nonempty_compacts Z := λ (n : ℕ), ⟨X2 n, _⟩	⊢ 1 / 2 < 1
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed),	isom : ∀ (n : ℕ), isometry (coeZ ∘ Φ n ∘ (Y n).embed),	D2 : ∀ (n : ℕ), metric.Hausdorff_dist (X2 n) (X2 n.succ) < (1 / 2) ^ n,	X3 : ℕ → topological_space.nonempty_compacts Z := λ (n : ℕ), ⟨X2 n, _⟩	⊢ cauchy_seq X3
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed),	isom : ∀ (n : ℕ), isometry (coeZ ∘ Φ n ∘ (Y n).embed),	D2 : ∀ (n : ℕ), metric.Hausdorff_dist (X2 n) (X2 n.succ) < (1 / 2) ^ n,	X3 : ℕ → topological_space.nonempty_compacts Z := λ (n : ℕ), ⟨X2 n, _⟩,	n : ℕ	⊢ has_dist.dist (X3 n) (X3 (n + 1)) ≤ 1 * (1 / 2) ^ n
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed),	isom : ∀ (n : ℕ), isometry (coeZ ∘ Φ n ∘ (Y n).embed),	D2 : ∀ (n : ℕ), metric.Hausdorff_dist (X2 n) (X2 n.succ) < (1 / 2) ^ n,	X3 : ℕ → topological_space.nonempty_compacts Z := λ (n : ℕ), ⟨X2 n, _⟩	⊢ cauchy_seq X3		this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed),	isom : ∀ (n : ℕ), isometry (coeZ ∘ Φ n ∘ (Y n).embed),	D2 : ∀ (n : ℕ), metric.Hausdorff_dist (X2 n) (X2 n.succ) < (1 / 2) ^ n,	X3 : ℕ → topological_space.nonempty_compacts Z := λ (n : ℕ), ⟨X2 n, _⟩,	this : cauchy_seq X3	⊢ ∃ (x : Gromov_Hausdorff.GH_space), filter.tendsto u filter.at_top (𝓝 x)
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed),	isom : ∀ (n : ℕ), isometry (coeZ ∘ Φ n ∘ (Y n).embed),	D2 : ∀ (n : ℕ), metric.Hausdorff_dist (X2 n) (X2 n.succ) < (1 / 2) ^ n,	X3 : ℕ → topological_space.nonempty_compacts Z := λ (n : ℕ), ⟨X2 n, _⟩,	n : ℕ	⊢ has_dist.dist (X3 n) (X3 (n + 1)) ≤ (1 / 2) ^ n
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed),	isom : ∀ (n : ℕ), isometry (coeZ ∘ Φ n ∘ (Y n).embed),	D2 : ∀ (n : ℕ), metric.Hausdorff_dist (X2 n) (X2 n.succ) < (1 / 2) ^ n,	X3 : ℕ → topological_space.nonempty_compacts Z := λ (n : ℕ), ⟨X2 n, _⟩,	this : cauchy_seq X3	⊢ ∃ (x : Gromov_Hausdorff.GH_space), filter.tendsto u filter.at_top (𝓝 x)
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed),	isom : ∀ (n : ℕ), isometry (coeZ ∘ Φ n ∘ (Y n).embed),	D2 : ∀ (n : ℕ), metric.Hausdorff_dist (X2 n) (X2 n.succ) < (1 / 2) ^ n,	X3 : ℕ → topological_space.nonempty_compacts Z := λ (n : ℕ), ⟨X2 n, _⟩,	this : cauchy_seq X3,	L : topological_space.nonempty_compacts Z,	hL : filter.tendsto X3 filter.at_top (𝓝 L)	⊢ ∃ (x : Gromov_Hausdorff.GH_space), filter.tendsto u filter.at_top (𝓝 x)
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed),	isom : ∀ (n : ℕ), isometry (coeZ ∘ Φ n ∘ (Y n).embed),	D2 : ∀ (n : ℕ), metric.Hausdorff_dist (X2 n) (X2 n.succ) < (1 / 2) ^ n,	X3 : ℕ → topological_space.nonempty_compacts Z := λ (n : ℕ), ⟨X2 n, _⟩,	this : cauchy_seq X3,	L : topological_space.nonempty_compacts Z,	hL : filter.tendsto X3 filter.at_top (𝓝 L),	M : filter.tendsto (λ (n : ℕ), (X3 n).to_GH_space) filter.at_top (𝓝 L.to_GH_space)	⊢ ∃ (x : Gromov_Hausdorff.GH_space), filter.tendsto u filter.at_top (𝓝 x)
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed),	isom : ∀ (n : ℕ), isometry (coeZ ∘ Φ n ∘ (Y n).embed),	D2 : ∀ (n : ℕ), metric.Hausdorff_dist (X2 n) (X2 n.succ) < (1 / 2) ^ n,	X3 : ℕ → topological_space.nonempty_compacts Z := λ (n : ℕ), ⟨X2 n, _⟩,	this : cauchy_seq X3,	L : topological_space.nonempty_compacts Z,	hL : filter.tendsto X3 filter.at_top (𝓝 L),	M : filter.tendsto (λ (n : ℕ), (X3 n).to_GH_space) filter.at_top (𝓝 L.to_GH_space)	⊢ ∀ (n : ℕ), (X3 n).to_GH_space = u n
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed),	isom : ∀ (n : ℕ), isometry (coeZ ∘ Φ n ∘ (Y n).embed),	D2 : ∀ (n : ℕ), metric.Hausdorff_dist (X2 n) (X2 n.succ) < (1 / 2) ^ n,	X3 : ℕ → topological_space.nonempty_compacts Z := λ (n : ℕ), ⟨X2 n, _⟩,	this : cauchy_seq X3,	L : topological_space.nonempty_compacts Z,	hL : filter.tendsto X3 filter.at_top (𝓝 L),	M : filter.tendsto (λ (n : ℕ), (X3 n).to_GH_space) filter.at_top (𝓝 L.to_GH_space),	n : ℕ	⊢ (X3 n).to_GH_space = u n
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed),	isom : ∀ (n : ℕ), isometry (coeZ ∘ Φ n ∘ (Y n).embed),	D2 : ∀ (n : ℕ), metric.Hausdorff_dist (X2 n) (X2 n.succ) < (1 / 2) ^ n,	X3 : ℕ → topological_space.nonempty_compacts Z := λ (n : ℕ), ⟨X2 n, _⟩,	this : cauchy_seq X3,	L : topological_space.nonempty_compacts Z,	hL : filter.tendsto X3 filter.at_top (𝓝 L),	M : filter.tendsto (λ (n : ℕ), (X3 n).to_GH_space) filter.at_top (𝓝 L.to_GH_space),	n : ℕ	⊢ nonempty (↥((X3 n).val) ≃ᵢ (u n).rep)
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed),	isom : ∀ (n : ℕ), isometry (coeZ ∘ Φ n ∘ (Y n).embed),	D2 : ∀ (n : ℕ), metric.Hausdorff_dist (X2 n) (X2 n.succ) < (1 / 2) ^ n,	X3 : ℕ → topological_space.nonempty_compacts Z := λ (n : ℕ), ⟨X2 n, _⟩,	this : cauchy_seq X3,	L : topological_space.nonempty_compacts Z,	hL : filter.tendsto X3 filter.at_top (𝓝 L),	M : filter.tendsto (λ (n : ℕ), (X3 n).to_GH_space) filter.at_top (𝓝 L.to_GH_space)	⊢ ∀ (n : ℕ), (X3 n).to_GH_space = u n		this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed),	isom : ∀ (n : ℕ), isometry (coeZ ∘ Φ n ∘ (Y n).embed),	D2 : ∀ (n : ℕ), metric.Hausdorff_dist (X2 n) (X2 n.succ) < (1 / 2) ^ n,	X3 : ℕ → topological_space.nonempty_compacts Z := λ (n : ℕ), ⟨X2 n, _⟩,	this : cauchy_seq X3,	L : topological_space.nonempty_compacts Z,	hL : filter.tendsto X3 filter.at_top (𝓝 L),	M : filter.tendsto (λ (n : ℕ), (X3 n).to_GH_space) filter.at_top (𝓝 L.to_GH_space),	this : ∀ (n : ℕ), (X3 n).to_GH_space = u n	⊢ ∃ (x : Gromov_Hausdorff.GH_space), filter.tendsto u filter.at_top (𝓝 x)
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed),	isom : ∀ (n : ℕ), isometry (coeZ ∘ Φ n ∘ (Y n).embed),	D2 : ∀ (n : ℕ), metric.Hausdorff_dist (X2 n) (X2 n.succ) < (1 / 2) ^ n,	X3 : ℕ → topological_space.nonempty_compacts Z := λ (n : ℕ), ⟨X2 n, _⟩,	this : cauchy_seq X3,	L : topological_space.nonempty_compacts Z,	hL : filter.tendsto X3 filter.at_top (𝓝 L),	M : filter.tendsto (λ (n : ℕ), (X3 n).to_GH_space) filter.at_top (𝓝 L.to_GH_space),	n : ℕ	⊢ ↥((X3 n).val) ≃ᵢ (u n).rep
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed),	isom : ∀ (n : ℕ), isometry (coeZ ∘ Φ n ∘ (Y n).embed),	D2 : ∀ (n : ℕ), metric.Hausdorff_dist (X2 n) (X2 n.succ) < (1 / 2) ^ n,	X3 : ℕ → topological_space.nonempty_compacts Z := λ (n : ℕ), ⟨X2 n, _⟩,	this : cauchy_seq X3,	L : topological_space.nonempty_compacts Z,	hL : filter.tendsto X3 filter.at_top (𝓝 L),	M : filter.tendsto (λ (n : ℕ), (X3 n).to_GH_space) filter.at_top (𝓝 L.to_GH_space),	this : ∀ (n : ℕ), (X3 n).to_GH_space = u n	⊢ filter.tendsto u filter.at_top (𝓝 L.to_GH_space)
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed),	isom : ∀ (n : ℕ), isometry (coeZ ∘ Φ n ∘ (Y n).embed),	D2 : ∀ (n : ℕ), metric.Hausdorff_dist (X2 n) (X2 n.succ) < (1 / 2) ^ n,	X3 : ℕ → topological_space.nonempty_compacts Z := λ (n : ℕ), ⟨X2 n, _⟩,	this : cauchy_seq X3,	L : topological_space.nonempty_compacts Z,	hL : filter.tendsto X3 filter.at_top (𝓝 L),	M : filter.tendsto (λ (n : ℕ), (X3 n).to_GH_space) filter.at_top (𝓝 L.to_GH_space),	this : ∀ (n : ℕ), (X3 n).to_GH_space = u n	⊢ ∃ (x : Gromov_Hausdorff.GH_space), filter.tendsto u filter.at_top (𝓝 x)
⊢ topological_space.second_countable_topology Gromov_Hausdorff.GH_space
δ : ℝ,	δpos : δ > 0	⊢ ∃ (β : Type ?) (_x : encodable β) (F : Gromov_Hausdorff.GH_space → β), ∀ (x y : Gromov_Hausdorff.GH_space), F x = F y → has_dist.dist x y ≤ δ
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ	⊢ 0 < 2 / 5
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ	⊢ ∃ (β : Type ?) (_x : encodable β) (F : Gromov_Hausdorff.GH_space → β), ∀ (x y : Gromov_Hausdorff.GH_space), F x = F y → has_dist.dist x y ≤ δ
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε	⊢ ∃ (β : Type ?) (_x : encodable β) (F : Gromov_Hausdorff.GH_space → β), ∀ (x y : Gromov_Hausdorff.GH_space), F x = F y → has_dist.dist x y ≤ δ
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	p : Gromov_Hausdorff.GH_space	⊢ ∃ (s : set p.rep), s.finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s), metric.ball x ε
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	this : ∀ (p : Gromov_Hausdorff.GH_space), ∃ (s : set p.rep), s.finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s), metric.ball x ε	⊢ ∃ (β : Type ?) (_x : encodable β) (F : Gromov_Hausdorff.GH_space → β), ∀ (x y : Gromov_Hausdorff.GH_space), F x = F y → has_dist.dist x y ≤ δ
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε	⊢ ∃ (β : Type ?) (_x : encodable β) (F : Gromov_Hausdorff.GH_space → β), ∀ (x y : Gromov_Hausdorff.GH_space), F x = F y → has_dist.dist x y ≤ δ
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε	⊢ ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → (∃ (n : ℕ) (e : ↥t ≃ fin n), true)
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	p : Gromov_Hausdorff.GH_space,	t : set p.rep,	ht : t.finite	⊢ ∃ (n : ℕ) (e : ↥t ≃ fin n), true
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε	⊢ ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → (∃ (n : ℕ) (e : ↥t ≃ fin n), true)		δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	this : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → (∃ (n : ℕ) (e : ↥t ≃ fin n), true)	⊢ ∃ (β : Type ?) (_x : encodable β) (F : Gromov_Hausdorff.GH_space → β), ∀ (x y : Gromov_Hausdorff.GH_space), F x = F y → has_dist.dist x y ≤ δ
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	p : Gromov_Hausdorff.GH_space,	t : set p.rep,	ht : t.finite,	_inst : fintype ↥t := ht.fintype	⊢ ∃ (n : ℕ) (e : ↥t ≃ fin n), true
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	this : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → (∃ (n : ℕ) (e : ↥t ≃ fin n), true)	⊢ ∃ (β : Type ?) (_x : encodable β) (F : Gromov_Hausdorff.GH_space → β), ∀ (x y : Gromov_Hausdorff.GH_space), F x = F y → has_dist.dist x y ≤ δ
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true	⊢ ∃ (β : Type ?) (_x : encodable β) (F : Gromov_Hausdorff.GH_space → β), ∀ (x y : Gromov_Hausdorff.GH_space), F x = F y → has_dist.dist x y ≤ δ
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _	⊢ ∃ (β : Type ?) (_x : encodable β) (F : Gromov_Hausdorff.GH_space → β), ∀ (x y : Gromov_Hausdorff.GH_space), F x = F y → has_dist.dist x y ≤ δ
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _	⊢ ∃ (β : Type ?) (_x : encodable β) (F : Gromov_Hausdorff.GH_space → β), ∀ (x y : Gromov_Hausdorff.GH_space), F x = F y → has_dist.dist x y ≤ δ
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩	⊢ encodable (Σ (n : ℕ), fin n → fin n → ℤ)
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩	⊢ ∃ (β : Type ?) (_x : encodable β) (F : Gromov_Hausdorff.GH_space → β), ∀ (x y : Gromov_Hausdorff.GH_space), F x = F y → has_dist.dist x y ≤ δ
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q	⊢ has_dist.dist p q ≤ δ
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q	⊢ has_dist.dist p q ≤ δ
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x))	⊢ has_dist.dist p q ≤ δ
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x)	⊢ has_dist.dist p q ≤ δ
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x)	⊢ Gromov_Hausdorff.GH_dist (Gromov_Hausdorff.GH_space.rep p) (Gromov_Hausdorff.GH_space.rep q) ≤ ε + ε / 2 + ε
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x)	⊢ ∀ (x : Gromov_Hausdorff.GH_space.rep p), ∃ (y : Gromov_Hausdorff.GH_space.rep p) (H : y ∈ s p), has_dist.dist x y ≤ ε		δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x)	⊢ ∀ (x : Gromov_Hausdorff.GH_space.rep q), ∃ (y : ↥(s p)), has_dist.dist x (Φ y) ≤ ε		δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x)	⊢ ∀ (x y : ↥(s p)), abs (has_dist.dist x y - has_dist.dist (Φ x) (Φ y)) ≤ ε
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x)	⊢ ∀ (x : Gromov_Hausdorff.GH_space.rep p), ∃ (y : Gromov_Hausdorff.GH_space.rep p) (H : y ∈ s p), has_dist.dist x y ≤ ε
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x : Gromov_Hausdorff.GH_space.rep p	⊢ ∃ (y : Gromov_Hausdorff.GH_space.rep p) (H : y ∈ s p), has_dist.dist x y ≤ ε
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x : Gromov_Hausdorff.GH_space.rep p,	this : x ∈ ⋃ (y : Gromov_Hausdorff.GH_space.rep p) (H : y ∈ s p), metric.ball y ε	⊢ ∃ (y : Gromov_Hausdorff.GH_space.rep p) (H : y ∈ s p), has_dist.dist x y ≤ ε
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x)	⊢ ∀ (x : Gromov_Hausdorff.GH_space.rep p), ∃ (y : Gromov_Hausdorff.GH_space.rep p) (H : y ∈ s p), has_dist.dist x y ≤ ε		δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x)	⊢ ∀ (x : Gromov_Hausdorff.GH_space.rep q), ∃ (y : ↥(s p)), has_dist.dist x (Φ y) ≤ ε		δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x)	⊢ ∀ (x y : ↥(s p)), abs (has_dist.dist x y - has_dist.dist (Φ x) (Φ y)) ≤ ε
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x : Gromov_Hausdorff.GH_space.rep p,	this : x ∈ ⋃ (y : Gromov_Hausdorff.GH_space.rep p) (H : y ∈ s p), metric.ball y ε,	y : Gromov_Hausdorff.GH_space.rep p,	ys : y ∈ s p,	hy : x ∈ metric.ball y ε	⊢ ∃ (y : Gromov_Hausdorff.GH_space.rep p) (H : y ∈ s p), has_dist.dist x y ≤ ε
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x)	⊢ ∀ (x : Gromov_Hausdorff.GH_space.rep q), ∃ (y : ↥(s p)), has_dist.dist x (Φ y) ≤ ε		δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x)	⊢ ∀ (x y : ↥(s p)), abs (has_dist.dist x y - has_dist.dist (Φ x) (Φ y)) ≤ ε
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x)	⊢ ∀ (x : Gromov_Hausdorff.GH_space.rep q), ∃ (z : ↥(s p)), has_dist.dist x (Φ z) ≤ ε
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x : Gromov_Hausdorff.GH_space.rep q	⊢ ∃ (z : ↥(s p)), has_dist.dist x (Φ z) ≤ ε
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x : Gromov_Hausdorff.GH_space.rep q,	this : x ∈ ⋃ (y : Gromov_Hausdorff.GH_space.rep q) (H : y ∈ s q), metric.ball y ε	⊢ ∃ (z : ↥(s p)), has_dist.dist x (Φ z) ≤ ε
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x : Gromov_Hausdorff.GH_space.rep q,	this : x ∈ ⋃ (y : Gromov_Hausdorff.GH_space.rep q) (H : y ∈ s q), metric.ball y ε,	y : Gromov_Hausdorff.GH_space.rep q,	ys : y ∈ s q,	hy : x ∈ metric.ball y ε	⊢ ∃ (z : ↥(s p)), has_dist.dist x (Φ z) ≤ ε
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x : Gromov_Hausdorff.GH_space.rep q,	this : x ∈ ⋃ (y : Gromov_Hausdorff.GH_space.rep q) (H : y ∈ s q), metric.ball y ε,	y : Gromov_Hausdorff.GH_space.rep q,	ys : y ∈ s q,	hy : x ∈ metric.ball y ε,	i : ℕ := ↑(⇑(E q) ⟨y, ys⟩)	⊢ ∃ (z : ↥(s p)), has_dist.dist x (Φ z) ≤ ε
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x : Gromov_Hausdorff.GH_space.rep q,	this : x ∈ ⋃ (y : Gromov_Hausdorff.GH_space.rep q) (H : y ∈ s q), metric.ball y ε,	y : Gromov_Hausdorff.GH_space.rep q,	ys : y ∈ s q,	hy : x ∈ metric.ball y ε,	i : ℕ := ↑(⇑(E q) ⟨y, ys⟩),	hi : ↑(⇑(E q) ⟨y, ys⟩) < N q (s q) _ := (⇑(E q) ⟨y, ys⟩).is_lt	⊢ ⟨i, hi⟩ = ⇑(E q) ⟨y, ys⟩
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x : Gromov_Hausdorff.GH_space.rep q,	this : x ∈ ⋃ (y : Gromov_Hausdorff.GH_space.rep q) (H : y ∈ s q), metric.ball y ε,	y : Gromov_Hausdorff.GH_space.rep q,	ys : y ∈ s q,	hy : x ∈ metric.ball y ε,	i : ℕ := ↑(⇑(E q) ⟨y, ys⟩),	hi : ↑(⇑(E q) ⟨y, ys⟩) < N q (s q) _ := (⇑(E q) ⟨y, ys⟩).is_lt	⊢ ∃ (z : ↥(s p)), has_dist.dist x (Φ z) ≤ ε
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x : Gromov_Hausdorff.GH_space.rep q,	this : x ∈ ⋃ (y : Gromov_Hausdorff.GH_space.rep q) (H : y ∈ s q), metric.ball y ε,	y : Gromov_Hausdorff.GH_space.rep q,	ys : y ∈ s q,	hy : x ∈ metric.ball y ε,	i : ℕ := ↑(⇑(E q) ⟨y, ys⟩),	hi : ↑(⇑(E q) ⟨y, ys⟩) < N q (s q) _ := (⇑(E q) ⟨y, ys⟩).is_lt,	ihi_eq : ⟨i, hi⟩ = ⇑(E q) ⟨y, ys⟩	⊢ ∃ (z : ↥(s p)), has_dist.dist x (Φ z) ≤ ε
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x : Gromov_Hausdorff.GH_space.rep q,	this : x ∈ ⋃ (y : Gromov_Hausdorff.GH_space.rep q) (H : y ∈ s q), metric.ball y ε,	y : Gromov_Hausdorff.GH_space.rep q,	ys : y ∈ s q,	hy : x ∈ metric.ball y ε,	i : ℕ := ↑(⇑(E q) ⟨y, ys⟩),	hi : ↑(⇑(E q) ⟨y, ys⟩) < N q (s q) _ := (⇑(E q) ⟨y, ys⟩).is_lt,	ihi_eq : ⟨i, hi⟩ = ⇑(E q) ⟨y, ys⟩,	hiq : i < N q	⊢ i < N p
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x : Gromov_Hausdorff.GH_space.rep q,	this : x ∈ ⋃ (y : Gromov_Hausdorff.GH_space.rep q) (H : y ∈ s q), metric.ball y ε,	y : Gromov_Hausdorff.GH_space.rep q,	ys : y ∈ s q,	hy : x ∈ metric.ball y ε,	i : ℕ := ↑(⇑(E q) ⟨y, ys⟩),	hi : ↑(⇑(E q) ⟨y, ys⟩) < N q (s q) _ := (⇑(E q) ⟨y, ys⟩).is_lt,	ihi_eq : ⟨i, hi⟩ = ⇑(E q) ⟨y, ys⟩,	hiq : i < N q	⊢ i < N p		δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x : Gromov_Hausdorff.GH_space.rep q,	this : x ∈ ⋃ (y : Gromov_Hausdorff.GH_space.rep q) (H : y ∈ s q), metric.ball y ε,	y : Gromov_Hausdorff.GH_space.rep q,	ys : y ∈ s q,	hy : x ∈ metric.ball y ε,	i : ℕ := ↑(⇑(E q) ⟨y, ys⟩),	hi : ↑(⇑(E q) ⟨y, ys⟩) < N q (s q) _ := (⇑(E q) ⟨y, ys⟩).is_lt,	ihi_eq : ⟨i, hi⟩ = ⇑(E q) ⟨y, ys⟩,	hiq : i < N q,	hip : i < N p	⊢ ∃ (z : ↥(s p)), has_dist.dist x (Φ z) ≤ ε
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x : Gromov_Hausdorff.GH_space.rep q,	this : x ∈ ⋃ (y : Gromov_Hausdorff.GH_space.rep q) (H : y ∈ s q), metric.ball y ε,	y : Gromov_Hausdorff.GH_space.rep q,	ys : y ∈ s q,	hy : x ∈ metric.ball y ε,	i : ℕ := ↑(⇑(E q) ⟨y, ys⟩),	hi : ↑(⇑(E q) ⟨y, ys⟩) < N q (s q) _ := (⇑(E q) ⟨y, ys⟩).is_lt,	ihi_eq : ⟨i, hi⟩ = ⇑(E q) ⟨y, ys⟩,	hiq : i < N q	⊢ ∃ (z : ↥(s p)), has_dist.dist x (Φ z) ≤ ε
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x : Gromov_Hausdorff.GH_space.rep q,	this : x ∈ ⋃ (y : Gromov_Hausdorff.GH_space.rep q) (H : y ∈ s q), metric.ball y ε,	y : Gromov_Hausdorff.GH_space.rep q,	ys : y ∈ s q,	hy : x ∈ metric.ball y ε,	i : ℕ := ↑(⇑(E q) ⟨y, ys⟩),	hi : ↑(⇑(E q) ⟨y, ys⟩) < N q (s q) _ := (⇑(E q) ⟨y, ys⟩).is_lt,	ihi_eq : ⟨i, hi⟩ = ⇑(E q) ⟨y, ys⟩,	hiq : i < N q,	hip : i < N p	⊢ ∃ (z : ↥(s p)), has_dist.dist x (Φ z) ≤ ε
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x : Gromov_Hausdorff.GH_space.rep q,	this : x ∈ ⋃ (y : Gromov_Hausdorff.GH_space.rep q) (H : y ∈ s q), metric.ball y ε,	y : Gromov_Hausdorff.GH_space.rep q,	ys : y ∈ s q,	hy : x ∈ metric.ball y ε,	i : ℕ := ↑(⇑(E q) ⟨y, ys⟩),	hi : ↑(⇑(E q) ⟨y, ys⟩) < N q (s q) _ := (⇑(E q) ⟨y, ys⟩).is_lt,	ihi_eq : ⟨i, hi⟩ = ⇑(E q) ⟨y, ys⟩,	hiq : i < N q,	hip : i < N p,	z : ↥(s p) := ⇑((E p).symm) ⟨i, hip⟩	⊢ ∃ (z : ↥(s p)), has_dist.dist x (Φ z) ≤ ε
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x : Gromov_Hausdorff.GH_space.rep q,	this : x ∈ ⋃ (y : Gromov_Hausdorff.GH_space.rep q) (H : y ∈ s q), metric.ball y ε,	y : Gromov_Hausdorff.GH_space.rep q,	ys : y ∈ s q,	hy : x ∈ metric.ball y ε,	i : ℕ := ↑(⇑(E q) ⟨y, ys⟩),	hi : ↑(⇑(E q) ⟨y, ys⟩) < N q (s q) _ := (⇑(E q) ⟨y, ys⟩).is_lt,	ihi_eq : ⟨i, hi⟩ = ⇑(E q) ⟨y, ys⟩,	hiq : i < N q,	hip : i < N p,	z : ↥(s p) := ⇑((E p).symm) ⟨i, hip⟩	⊢ has_dist.dist x (Φ z) ≤ ε
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x : Gromov_Hausdorff.GH_space.rep q,	this : x ∈ ⋃ (y : Gromov_Hausdorff.GH_space.rep q) (H : y ∈ s q), metric.ball y ε,	y : Gromov_Hausdorff.GH_space.rep q,	ys : y ∈ s q,	hy : x ∈ metric.ball y ε,	i : ℕ := ↑(⇑(E q) ⟨y, ys⟩),	hi : ↑(⇑(E q) ⟨y, ys⟩) < N q (s q) _ := (⇑(E q) ⟨y, ys⟩).is_lt,	ihi_eq : ⟨i, hi⟩ = ⇑(E q) ⟨y, ys⟩,	hiq : i < N q,	hip : i < N p,	z : ↥(s p) := ⇑((E p).symm) ⟨i, hip⟩,	C1 : ⇑(E p) z = ⟨i, hip⟩	⊢ has_dist.dist x (Φ z) ≤ ε
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x : Gromov_Hausdorff.GH_space.rep q,	this : x ∈ ⋃ (y : Gromov_Hausdorff.GH_space.rep q) (H : y ∈ s q), metric.ball y ε,	y : Gromov_Hausdorff.GH_space.rep q,	ys : y ∈ s q,	hy : x ∈ metric.ball y ε,	i : ℕ := ↑(⇑(E q) ⟨y, ys⟩),	hi : ↑(⇑(E q) ⟨y, ys⟩) < N q (s q) _ := (⇑(E q) ⟨y, ys⟩).is_lt,	ihi_eq : ⟨i, hi⟩ = ⇑(E q) ⟨y, ys⟩,	hiq : i < N q,	hip : i < N p,	z : ↥(s p) := ⇑((E p).symm) ⟨i, hip⟩,	C1 : ⇑(E p) z = ⟨i, hip⟩,	C2 : ⇑(fin.cast Npq) ⟨i, hip⟩ = ⟨i, hi⟩	⊢ has_dist.dist x (Φ z) ≤ ε
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x : Gromov_Hausdorff.GH_space.rep q,	this : x ∈ ⋃ (y : Gromov_Hausdorff.GH_space.rep q) (H : y ∈ s q), metric.ball y ε,	y : Gromov_Hausdorff.GH_space.rep q,	ys : y ∈ s q,	hy : x ∈ metric.ball y ε,	i : ℕ := ↑(⇑(E q) ⟨y, ys⟩),	hi : ↑(⇑(E q) ⟨y, ys⟩) < N q (s q) _ := (⇑(E q) ⟨y, ys⟩).is_lt,	ihi_eq : ⟨i, hi⟩ = ⇑(E q) ⟨y, ys⟩,	hiq : i < N q,	hip : i < N p,	z : ↥(s p) := ⇑((E p).symm) ⟨i, hip⟩,	C1 : ⇑(E p) z = ⟨i, hip⟩,	C2 : ⇑(fin.cast Npq) ⟨i, hip⟩ = ⟨i, hi⟩	⊢ ⇑((E q).symm) ⟨i, hi⟩ = ⟨y, ys⟩
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x : Gromov_Hausdorff.GH_space.rep q,	this : x ∈ ⋃ (y : Gromov_Hausdorff.GH_space.rep q) (H : y ∈ s q), metric.ball y ε,	y : Gromov_Hausdorff.GH_space.rep q,	ys : y ∈ s q,	hy : x ∈ metric.ball y ε,	i : ℕ := ↑(⇑(E q) ⟨y, ys⟩),	hi : ↑(⇑(E q) ⟨y, ys⟩) < N q (s q) _ := (⇑(E q) ⟨y, ys⟩).is_lt,	ihi_eq : ⟨i, hi⟩ = ⇑(E q) ⟨y, ys⟩,	hiq : i < N q,	hip : i < N p,	z : ↥(s p) := ⇑((E p).symm) ⟨i, hip⟩,	C1 : ⇑(E p) z = ⟨i, hip⟩,	C2 : ⇑(fin.cast Npq) ⟨i, hip⟩ = ⟨i, hi⟩	⊢ ⇑((E q).symm) (⇑(E q) ⟨y, ys⟩) = ⟨y, ys⟩
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x : Gromov_Hausdorff.GH_space.rep q,	this : x ∈ ⋃ (y : Gromov_Hausdorff.GH_space.rep q) (H : y ∈ s q), metric.ball y ε,	y : Gromov_Hausdorff.GH_space.rep q,	ys : y ∈ s q,	hy : x ∈ metric.ball y ε,	i : ℕ := ↑(⇑(E q) ⟨y, ys⟩),	hi : ↑(⇑(E q) ⟨y, ys⟩) < N q (s q) _ := (⇑(E q) ⟨y, ys⟩).is_lt,	ihi_eq : ⟨i, hi⟩ = ⇑(E q) ⟨y, ys⟩,	hiq : i < N q,	hip : i < N p,	z : ↥(s p) := ⇑((E p).symm) ⟨i, hip⟩,	C1 : ⇑(E p) z = ⟨i, hip⟩,	C2 : ⇑(fin.cast Npq) ⟨i, hip⟩ = ⟨i, hi⟩,	C3 : ⇑((E q).symm) ⟨i, hi⟩ = ⟨y, ys⟩	⊢ has_dist.dist x (Φ z) ≤ ε
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → q.rep := λ (x : ↥(s p)), ↑(Ψ x),	x : q.rep,	this : x ∈ ⋃ (y : q.rep) (H : y ∈ s q), metric.ball y ε,	y : q.rep,	ys : y ∈ s q,	hy : x ∈ metric.ball y ε,	i : ℕ := ↑(⇑(E q) ⟨y, ys⟩),	hi : ↑(⇑(E q) ⟨y, ys⟩) < N q (s q) _ := (⇑(E q) ⟨y, ys⟩).is_lt,	ihi_eq : ⟨i, hi⟩ = ⇑(E q) ⟨y, ys⟩,	hiq : i < N q,	hip : i < N p,	z : ↥(s p) := ⇑((E p).symm) ⟨i, hip⟩,	C1 : ⇑(E p) z = ⟨i, hip⟩,	C2 : ⇑(fin.cast Npq) ⟨i, hip⟩ = ⟨i, hi⟩,	C3 : ⇑((E q).symm) ⟨i, hi⟩ = ⟨y, ys⟩	⊢ Φ z = y
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → q.rep := λ (x : ↥(s p)), ↑(Ψ x),	x : q.rep,	this : x ∈ ⋃ (y : q.rep) (H : y ∈ s q), metric.ball y ε,	y : q.rep,	ys : y ∈ s q,	hy : x ∈ metric.ball y ε,	i : ℕ := ↑(⇑(E q) ⟨y, ys⟩),	hi : ↑(⇑(E q) ⟨y, ys⟩) < N q (s q) _ := (⇑(E q) ⟨y, ys⟩).is_lt,	ihi_eq : ⟨i, hi⟩ = ⇑(E q) ⟨y, ys⟩,	hiq : i < N q,	hip : i < N p,	z : ↥(s p) := ⇑((E p).symm) ⟨i, hip⟩,	C1 : ⇑(E p) z = ⟨i, hip⟩,	C2 : ⇑(fin.cast Npq) ⟨i, hip⟩ = ⟨i, hi⟩,	C3 : ⇑((E q).symm) ⟨i, hi⟩ = ⟨y, ys⟩	⊢ ↑(⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) z))) = y
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → q.rep := λ (x : ↥(s p)), ↑(Ψ x),	x : q.rep,	this : x ∈ ⋃ (y : q.rep) (H : y ∈ s q), metric.ball y ε,	y : q.rep,	ys : y ∈ s q,	hy : x ∈ metric.ball y ε,	i : ℕ := ↑(⇑(E q) ⟨y, ys⟩),	hi : ↑(⇑(E q) ⟨y, ys⟩) < N q (s q) _ := (⇑(E q) ⟨y, ys⟩).is_lt,	ihi_eq : ⟨i, hi⟩ = ⇑(E q) ⟨y, ys⟩,	hiq : i < N q,	hip : i < N p,	z : ↥(s p) := ⇑((E p).symm) ⟨i, hip⟩,	C1 : ⇑(E p) z = ⟨i, hip⟩,	C2 : ⇑(fin.cast Npq) ⟨i, hip⟩ = ⟨i, hi⟩,	C3 : ⇑((E q).symm) ⟨i, hi⟩ = ⟨y, ys⟩	⊢ ↑⟨y, ys⟩ = y
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x : Gromov_Hausdorff.GH_space.rep q,	this : x ∈ ⋃ (y : Gromov_Hausdorff.GH_space.rep q) (H : y ∈ s q), metric.ball y ε,	y : Gromov_Hausdorff.GH_space.rep q,	ys : y ∈ s q,	hy : x ∈ metric.ball y ε,	i : ℕ := ↑(⇑(E q) ⟨y, ys⟩),	hi : ↑(⇑(E q) ⟨y, ys⟩) < N q (s q) _ := (⇑(E q) ⟨y, ys⟩).is_lt,	ihi_eq : ⟨i, hi⟩ = ⇑(E q) ⟨y, ys⟩,	hiq : i < N q,	hip : i < N p,	z : ↥(s p) := ⇑((E p).symm) ⟨i, hip⟩,	C1 : ⇑(E p) z = ⟨i, hip⟩,	C2 : ⇑(fin.cast Npq) ⟨i, hip⟩ = ⟨i, hi⟩,	C3 : ⇑((E q).symm) ⟨i, hi⟩ = ⟨y, ys⟩,	this : Φ z = y	⊢ has_dist.dist x (Φ z) ≤ ε
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x)	⊢ ∀ (x : Gromov_Hausdorff.GH_space.rep q), ∃ (z : ↥(s p)), has_dist.dist x (Φ z) ≤ ε		δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x)	⊢ ∀ (x y : ↥(s p)), abs (has_dist.dist x y - has_dist.dist (Φ x) (Φ y)) ≤ ε
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x : Gromov_Hausdorff.GH_space.rep q,	this : x ∈ ⋃ (y : Gromov_Hausdorff.GH_space.rep q) (H : y ∈ s q), metric.ball y ε,	y : Gromov_Hausdorff.GH_space.rep q,	ys : y ∈ s q,	hy : x ∈ metric.ball y ε,	i : ℕ := ↑(⇑(E q) ⟨y, ys⟩),	hi : ↑(⇑(E q) ⟨y, ys⟩) < N q (s q) _ := (⇑(E q) ⟨y, ys⟩).is_lt,	ihi_eq : ⟨i, hi⟩ = ⇑(E q) ⟨y, ys⟩,	hiq : i < N q,	hip : i < N p,	z : ↥(s p) := ⇑((E p).symm) ⟨i, hip⟩,	C1 : ⇑(E p) z = ⟨i, hip⟩,	C2 : ⇑(fin.cast Npq) ⟨i, hip⟩ = ⟨i, hi⟩,	C3 : ⇑((E q).symm) ⟨i, hi⟩ = ⟨y, ys⟩,	this : Φ z = y	⊢ has_dist.dist x y ≤ ε
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x)	⊢ ∀ (x y : ↥(s p)), abs (has_dist.dist x y - has_dist.dist (Φ x) (Φ y)) ≤ ε
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x)	⊢ ∀ (x y : ↥(s p)), abs (has_dist.dist x y - has_dist.dist (Φ x) (Φ y)) ≤ ε
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p)	⊢ abs (has_dist.dist x y - has_dist.dist (Φ x) (Φ y)) ≤ ε
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y)	⊢ abs (has_dist.dist x y - has_dist.dist (Φ x) (Φ y)) ≤ ε
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y)	⊢ abs (has_dist.dist x y - has_dist.dist (Ψ x) (Ψ y)) ≤ ε
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x)	⊢ abs (has_dist.dist x y - has_dist.dist (Ψ x) (Ψ y)) ≤ ε
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x),	hip : i < N p	⊢ i < N q
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x),	hip : i < N p	⊢ abs (has_dist.dist x y - has_dist.dist (Ψ x) (Ψ y)) ≤ ε
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x),	hip : i < N p,	hiq : i < N q	⊢ i = ↑(⇑(E q) (Ψ x))
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x),	hip : i < N p,	hiq : i < N q	⊢ abs (has_dist.dist x y - has_dist.dist (Ψ x) (Ψ y)) ≤ ε
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x),	hip : i < N p,	hiq : i < N q,	i' : i = ↑(⇑(E q) (Ψ x))	⊢ abs (has_dist.dist x y - has_dist.dist (Ψ x) (Ψ y)) ≤ ε
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x),	hip : i < N p,	hiq : i < N q,	i' : i = ↑(⇑(E q) (Ψ x)),	j : ℕ := ↑(⇑(E p) y)	⊢ abs (has_dist.dist x y - has_dist.dist (Ψ x) (Ψ y)) ≤ ε
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x),	hip : i < N p,	hiq : i < N q,	i' : i = ↑(⇑(E q) (Ψ x)),	j : ℕ := ↑(⇑(E p) y),	hjp : j < N p	⊢ j < N q
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x),	hip : i < N p,	hiq : i < N q,	i' : i = ↑(⇑(E q) (Ψ x)),	j : ℕ := ↑(⇑(E p) y),	hjp : j < N p	⊢ abs (has_dist.dist x y - has_dist.dist (Ψ x) (Ψ y)) ≤ ε
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x),	hip : i < N p,	hiq : i < N q,	i' : i = ↑(⇑(E q) (Ψ x)),	j : ℕ := ↑(⇑(E p) y),	hjp : j < N p,	hjq : j < N q	⊢ j = (⇑(E q) (Ψ y)).val
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x),	hip : i < N p,	hiq : i < N q,	i' : i = ↑(⇑(E q) (Ψ x)),	j : ℕ := ↑(⇑(E p) y),	hjp : j < N p,	hjq : j < N q	⊢ abs (has_dist.dist x y - has_dist.dist (Ψ x) (Ψ y)) ≤ ε
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x),	hip : i < N p,	hiq : i < N q,	i' : i = ↑(⇑(E q) (Ψ x)),	j : ℕ := ↑(⇑(E p) y),	hjp : j < N p,	hjq : j < N q,	j' : j = (⇑(E q) (Ψ y)).val	⊢ abs (has_dist.dist x y - has_dist.dist (Ψ x) (Ψ y)) ≤ ε
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x),	hip : i < N p,	hiq : i < N q,	i' : i = ↑(⇑(E q) (Ψ x)),	j : ℕ := ↑(⇑(E p) y),	hjp : j < N p,	hjq : j < N q,	j' : j = (⇑(E q) (Ψ y)).val	⊢ (F p).snd (⇑(E p) x) (⇑(E p) y) = ⌊ε⁻¹ * has_dist.dist x y⌋
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x),	hip : i < N p,	hiq : i < N q,	i' : i = ↑(⇑(E q) (Ψ x)),	j : ℕ := ↑(⇑(E p) y),	hjp : j < N p,	hjq : j < N q,	j' : j = (⇑(E q) (Ψ y)).val,	this : (F p).snd (⇑(E p) x) (⇑(E p) y) = ⌊ε⁻¹ * has_dist.dist x y⌋	⊢ abs (has_dist.dist x y - has_dist.dist (Ψ x) (Ψ y)) ≤ ε
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x),	hip : i < N p,	hiq : i < N q,	i' : i = ↑(⇑(E q) (Ψ x)),	j : ℕ := ↑(⇑(E p) y),	hjp : j < N p,	hjq : j < N q,	j' : j = (⇑(E q) (Ψ y)).val,	this : (F p).snd (⇑(E p) x) (⇑(E p) y) = ⌊ε⁻¹ * has_dist.dist x y⌋	⊢ (F p).snd ⟨i, hip⟩ ⟨j, hjp⟩ = ⌊ε⁻¹ * has_dist.dist x y⌋
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x),	hip : i < N p,	hiq : i < N q,	i' : i = ↑(⇑(E q) (Ψ x)),	j : ℕ := ↑(⇑(E p) y),	hjp : j < N p,	hjq : j < N q,	j' : j = (⇑(E q) (Ψ y)).val,	this : (F p).snd (⇑(E p) x) (⇑(E p) y) = ⌊ε⁻¹ * has_dist.dist x y⌋	⊢ (F p).snd ⟨i, hip⟩ ⟨j, hjp⟩ = (F p).snd (⇑(E p) x) (⇑(E p) y)
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x),	hip : i < N p,	hiq : i < N q,	i' : i = ↑(⇑(E q) (Ψ x)),	j : ℕ := ↑(⇑(E p) y),	hjp : j < N p,	hjq : j < N q,	j' : j = (⇑(E q) (Ψ y)).val,	this : (F p).snd (⇑(E p) x) (⇑(E p) y) = ⌊ε⁻¹ * has_dist.dist x y⌋	⊢ (F p).snd ⟨i, hip⟩ ⟨j, hjp⟩ = (F p).snd (⇑(E p) x) (⇑(E p) y)
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x),	hip : i < N p,	hiq : i < N q,	i' : i = ↑(⇑(E q) (Ψ x)),	j : ℕ := ↑(⇑(E p) y),	hjp : j < N p,	hjq : j < N q,	j' : j = (⇑(E q) (Ψ y)).val,	this : (F p).snd (⇑(E p) x) (⇑(E p) y) = ⌊ε⁻¹ * has_dist.dist x y⌋	⊢ (F p).snd ⟨i, hip⟩ ⟨j, hjp⟩ = (F p).snd (⇑(E p) x) (⇑(E p) y)
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x),	hip : i < N p,	hiq : i < N q,	i' : i = ↑(⇑(E q) (Ψ x)),	j : ℕ := ↑(⇑(E p) y),	hjp : j < N p,	hjq : j < N q,	j' : j = (⇑(E q) (Ψ y)).val,	this : (F p).snd (⇑(E p) x) (⇑(E p) y) = ⌊ε⁻¹ * has_dist.dist x y⌋	⊢ ⟨i, hip⟩ = ⇑(E p) x
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x),	hip : i < N p,	hiq : i < N q,	i' : i = ↑(⇑(E q) (Ψ x)),	j : ℕ := ↑(⇑(E p) y),	hjp : j < N p,	hjq : j < N q,	j' : j = (⇑(E q) (Ψ y)).val,	this : (F p).snd (⇑(E p) x) (⇑(E p) y) = ⌊ε⁻¹ * has_dist.dist x y⌋	⊢ ⟨j, hjp⟩ = ⇑(E p) y
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x),	hip : i < N p,	hiq : i < N q,	i' : i = ↑(⇑(E q) (Ψ x)),	j : ℕ := ↑(⇑(E p) y),	hjp : j < N p,	hjq : j < N q,	j' : j = (⇑(E q) (Ψ y)).val,	this : (F p).snd (⇑(E p) x) (⇑(E p) y) = ⌊ε⁻¹ * has_dist.dist x y⌋	⊢ ↑⟨i, hip⟩ = ↑(⇑(E p) x)
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x),	hip : i < N p,	hiq : i < N q,	i' : i = ↑(⇑(E q) (Ψ x)),	j : ℕ := ↑(⇑(E p) y),	hjp : j < N p,	hjq : j < N q,	j' : j = (⇑(E q) (Ψ y)).val,	this : (F p).snd (⇑(E p) x) (⇑(E p) y) = ⌊ε⁻¹ * has_dist.dist x y⌋	⊢ ↑⟨j, hjp⟩ = ↑(⇑(E p) y)
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x),	hip : i < N p,	hiq : i < N q,	i' : i = ↑(⇑(E q) (Ψ x)),	j : ℕ := ↑(⇑(E p) y),	hjp : j < N p,	hjq : j < N q,	j' : j = (⇑(E q) (Ψ y)).val,	this : (F p).snd (⇑(E p) x) (⇑(E p) y) = ⌊ε⁻¹ * has_dist.dist x y⌋,	Ap : (F p).snd ⟨i, hip⟩ ⟨j, hjp⟩ = ⌊ε⁻¹ * has_dist.dist x y⌋	⊢ abs (has_dist.dist x y - has_dist.dist (Ψ x) (Ψ y)) ≤ ε
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x),	hip : i < N p,	hiq : i < N q,	i' : i = ↑(⇑(E q) (Ψ x)),	j : ℕ := ↑(⇑(E p) y),	hjp : j < N p,	hjq : j < N q,	j' : j = (⇑(E q) (Ψ y)).val,	this : (F p).snd (⇑(E p) x) (⇑(E p) y) = ⌊ε⁻¹ * has_dist.dist x y⌋,	Ap : (F p).snd ⟨i, hip⟩ ⟨j, hjp⟩ = ⌊ε⁻¹ * has_dist.dist x y⌋	⊢ (F q).snd (⇑(E q) (Ψ x)) (⇑(E q) (Ψ y)) = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x),	hip : i < N p,	hiq : i < N q,	i' : i = ↑(⇑(E q) (Ψ x)),	j : ℕ := ↑(⇑(E p) y),	hjp : j < N p,	hjq : j < N q,	j' : j = (⇑(E q) (Ψ y)).val,	this : (F p).snd (⇑(E p) x) (⇑(E p) y) = ⌊ε⁻¹ * has_dist.dist x y⌋,	Ap : (F p).snd ⟨i, hip⟩ ⟨j, hjp⟩ = ⌊ε⁻¹ * has_dist.dist x y⌋,	this : (F q).snd (⇑(E q) (Ψ x)) (⇑(E q) (Ψ y)) = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋	⊢ abs (has_dist.dist x y - has_dist.dist (Ψ x) (Ψ y)) ≤ ε
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x),	hip : i < N p,	hiq : i < N q,	i' : i = ↑(⇑(E q) (Ψ x)),	j : ℕ := ↑(⇑(E p) y),	hjp : j < N p,	hjq : j < N q,	j' : j = (⇑(E q) (Ψ y)).val,	this : (F p).snd (⇑(E p) x) (⇑(E p) y) = ⌊ε⁻¹ * has_dist.dist x y⌋,	Ap : (F p).snd ⟨i, hip⟩ ⟨j, hjp⟩ = ⌊ε⁻¹ * has_dist.dist x y⌋,	this : (F q).snd (⇑(E q) (Ψ x)) (⇑(E q) (Ψ y)) = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋	⊢ (F q).snd ⟨i, hiq⟩ ⟨j, hjq⟩ = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x),	hip : i < N p,	hiq : i < N q,	i' : i = ↑(⇑(E q) (Ψ x)),	j : ℕ := ↑(⇑(E p) y),	hjp : j < N p,	hjq : j < N q,	j' : j = (⇑(E q) (Ψ y)).val,	this : (F p).snd (⇑(E p) x) (⇑(E p) y) = ⌊ε⁻¹ * has_dist.dist x y⌋,	Ap : (F p).snd ⟨i, hip⟩ ⟨j, hjp⟩ = ⌊ε⁻¹ * has_dist.dist x y⌋,	this : (F q).snd (⇑(E q) (Ψ x)) (⇑(E q) (Ψ y)) = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋	⊢ (F q).snd ⟨i, hiq⟩ ⟨j, hjq⟩ = (F q).snd (⇑(E q) (Ψ x)) (⇑(E q) (Ψ y))
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x),	hip : i < N p,	hiq : i < N q,	i' : i = ↑(⇑(E q) (Ψ x)),	j : ℕ := ↑(⇑(E p) y),	hjp : j < N p,	hjq : j < N q,	j' : j = (⇑(E q) (Ψ y)).val,	this : (F p).snd (⇑(E p) x) (⇑(E p) y) = ⌊ε⁻¹ * has_dist.dist x y⌋,	Ap : (F p).snd ⟨i, hip⟩ ⟨j, hjp⟩ = ⌊ε⁻¹ * has_dist.dist x y⌋,	this : (F q).snd (⇑(E q) (Ψ x)) (⇑(E q) (Ψ y)) = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋	⊢ (F q).snd ⟨i, hiq⟩ ⟨j, hjq⟩ = (F q).snd (⇑(E q) (Ψ x)) (⇑(E q) (Ψ y))
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x),	hip : i < N p,	hiq : i < N q,	i' : i = ↑(⇑(E q) (Ψ x)),	j : ℕ := ↑(⇑(E p) y),	hjp : j < N p,	hjq : j < N q,	j' : j = (⇑(E q) (Ψ y)).val,	this : (F p).snd (⇑(E p) x) (⇑(E p) y) = ⌊ε⁻¹ * has_dist.dist x y⌋,	Ap : (F p).snd ⟨i, hip⟩ ⟨j, hjp⟩ = ⌊ε⁻¹ * has_dist.dist x y⌋,	this : (F q).snd (⇑(E q) (Ψ x)) (⇑(E q) (Ψ y)) = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋	⊢ (F q).snd ⟨i, hiq⟩ ⟨j, hjq⟩ = (F q).snd (⇑(E q) (Ψ x)) (⇑(E q) (Ψ y))
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x),	hip : i < N p,	hiq : i < N q,	i' : i = ↑(⇑(E q) (Ψ x)),	j : ℕ := ↑(⇑(E p) y),	hjp : j < N p,	hjq : j < N q,	j' : j = (⇑(E q) (Ψ y)).val,	this : (F p).snd (⇑(E p) x) (⇑(E p) y) = ⌊ε⁻¹ * has_dist.dist x y⌋,	Ap : (F p).snd ⟨i, hip⟩ ⟨j, hjp⟩ = ⌊ε⁻¹ * has_dist.dist x y⌋,	this : (F q).snd (⇑(E q) (Ψ x)) (⇑(E q) (Ψ y)) = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋	⊢ ⟨i, hiq⟩ = ⇑(E q) (Ψ x)
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x),	hip : i < N p,	hiq : i < N q,	i' : i = ↑(⇑(E q) (Ψ x)),	j : ℕ := ↑(⇑(E p) y),	hjp : j < N p,	hjq : j < N q,	j' : j = (⇑(E q) (Ψ y)).val,	this : (F p).snd (⇑(E p) x) (⇑(E p) y) = ⌊ε⁻¹ * has_dist.dist x y⌋,	Ap : (F p).snd ⟨i, hip⟩ ⟨j, hjp⟩ = ⌊ε⁻¹ * has_dist.dist x y⌋,	this : (F q).snd (⇑(E q) (Ψ x)) (⇑(E q) (Ψ y)) = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋	⊢ ⟨j, hjq⟩ = ⇑(E q) (Ψ y)
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x),	hip : i < N p,	hiq : i < N q,	i' : i = ↑(⇑(E q) (Ψ x)),	j : ℕ := ↑(⇑(E p) y),	hjp : j < N p,	hjq : j < N q,	j' : j = (⇑(E q) (Ψ y)).val,	this : (F p).snd (⇑(E p) x) (⇑(E p) y) = ⌊ε⁻¹ * has_dist.dist x y⌋,	Ap : (F p).snd ⟨i, hip⟩ ⟨j, hjp⟩ = ⌊ε⁻¹ * has_dist.dist x y⌋,	this : (F q).snd (⇑(E q) (Ψ x)) (⇑(E q) (Ψ y)) = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋	⊢ ↑⟨i, hiq⟩ = ↑(⇑(E q) (Ψ x))
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x),	hip : i < N p,	hiq : i < N q,	i' : i = ↑(⇑(E q) (Ψ x)),	j : ℕ := ↑(⇑(E p) y),	hjp : j < N p,	hjq : j < N q,	j' : j = (⇑(E q) (Ψ y)).val,	this : (F p).snd (⇑(E p) x) (⇑(E p) y) = ⌊ε⁻¹ * has_dist.dist x y⌋,	Ap : (F p).snd ⟨i, hip⟩ ⟨j, hjp⟩ = ⌊ε⁻¹ * has_dist.dist x y⌋,	this : (F q).snd (⇑(E q) (Ψ x)) (⇑(E q) (Ψ y)) = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋	⊢ ↑⟨j, hjq⟩ = ↑(⇑(E q) (Ψ y))
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x),	hip : i < N p,	hiq : i < N q,	i' : i = ↑(⇑(E q) (Ψ x)),	j : ℕ := ↑(⇑(E p) y),	hjp : j < N p,	hjq : j < N q,	j' : j = (⇑(E q) (Ψ y)).val,	this : (F p).snd (⇑(E p) x) (⇑(E p) y) = ⌊ε⁻¹ * has_dist.dist x y⌋,	Ap : (F p).snd ⟨i, hip⟩ ⟨j, hjp⟩ = ⌊ε⁻¹ * has_dist.dist x y⌋,	this : (F q).snd (⇑(E q) (Ψ x)) (⇑(E q) (Ψ y)) = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋,	Aq : (F q).snd ⟨i, hiq⟩ ⟨j, hjq⟩ = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋	⊢ abs (has_dist.dist x y - has_dist.dist (Ψ x) (Ψ y)) ≤ ε
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x),	hip : i < N p,	hiq : i < N q,	i' : i = ↑(⇑(E q) (Ψ x)),	j : ℕ := ↑(⇑(E p) y),	hjp : j < N p,	hjq : j < N q,	j' : j = (⇑(E q) (Ψ y)).val,	this : (F p).snd (⇑(E p) x) (⇑(E p) y) = ⌊ε⁻¹ * has_dist.dist x y⌋,	Ap : (F p).snd ⟨i, hip⟩ ⟨j, hjp⟩ = ⌊ε⁻¹ * has_dist.dist x y⌋,	this : (F q).snd (⇑(E q) (Ψ x)) (⇑(E q) (Ψ y)) = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋,	Aq : (F q).snd ⟨i, hiq⟩ ⟨j, hjq⟩ = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋	⊢ (F p).snd ⟨i, hip⟩ ⟨j, hjp⟩ = (F q).snd ⟨i, hiq⟩ ⟨j, hjq⟩
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x),	hip : i < N p,	i' : i = ↑(⇑(E q) (Ψ x)),	j : ℕ := ↑(⇑(E p) y),	hjp : j < N p,	j' : j = (⇑(E q) (Ψ y)).val,	this : (F p).snd (⇑(E p) x) (⇑(E p) y) = ⌊ε⁻¹ * has_dist.dist x y⌋,	Ap : (F p).snd ⟨i, hip⟩ ⟨j, hjp⟩ = ⌊ε⁻¹ * has_dist.dist x y⌋,	this : (F q).snd (⇑(E q) (Ψ x)) (⇑(E q) (Ψ y)) = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋	⊢ ∀ (hiq : i < N q) (hjq : j < N q), (F q).snd ⟨i, hiq⟩ ⟨j, hjq⟩ = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋ → (F p).snd ⟨i, hip⟩ ⟨j, hjp⟩ = (F q).snd ⟨i, hiq⟩ ⟨j, hjq⟩
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x),	hip : i < N p,	i' : i = ↑(⇑(E q) (Ψ x)),	j : ℕ := ↑(⇑(E p) y),	hjp : j < N p,	j' : j = (⇑(E q) (Ψ y)).val,	this : (F p).snd (⇑(E p) x) (⇑(E p) y) = ⌊ε⁻¹ * has_dist.dist x y⌋,	Ap : (F p).snd ⟨i, hip⟩ ⟨j, hjp⟩ = ⌊ε⁻¹ * has_dist.dist x y⌋,	this : (F q).snd (⇑(E q) (Ψ x)) (⇑(E q) (Ψ y)) = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋	⊢ ∀ (hiq : i < (F q).fst) (hjq : j < (F q).fst), (F q).snd ⟨i, hiq⟩ ⟨j, hjq⟩ = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋ → (F p).snd ⟨i, hip⟩ ⟨j, hjp⟩ = (F q).snd ⟨i, hiq⟩ ⟨j, hjq⟩
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x),	hip : i < N p,	i' : i = ↑(⇑(E q) (Ψ x)),	j : ℕ := ↑(⇑(E p) y),	hjp : j < N p,	j' : j = (⇑(E q) (Ψ y)).val,	this : (F p).snd (⇑(E p) x) (⇑(E p) y) = ⌊ε⁻¹ * has_dist.dist x y⌋,	Ap : (F p).snd ⟨i, hip⟩ ⟨j, hjp⟩ = ⌊ε⁻¹ * has_dist.dist x y⌋,	this : (F q).snd (⇑(E q) (Ψ x)) (⇑(E q) (Ψ y)) = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋,	f : Σ (n : ℕ), fin n → fin n → ℤ,	hpq : F p = f	⊢ ∀ (hiq : i < f.fst) (hjq : j < f.fst), f.snd ⟨i, hiq⟩ ⟨j, hjq⟩ = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋ → (F p).snd ⟨i, hip⟩ ⟨j, hjp⟩ = f.snd ⟨i, hiq⟩ ⟨j, hjq⟩
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x),	hip : i < N p,	i' : i = ↑(⇑(E q) (Ψ x)),	j : ℕ := ↑(⇑(E p) y),	hjp : j < N p,	j' : j = (⇑(E q) (Ψ y)).val,	this : (F p).snd (⇑(E p) x) (⇑(E p) y) = ⌊ε⁻¹ * has_dist.dist x y⌋,	Ap : (F p).snd ⟨i, hip⟩ ⟨j, hjp⟩ = ⌊ε⁻¹ * has_dist.dist x y⌋,	this : (F q).snd (⇑(E q) (Ψ x)) (⇑(E q) (Ψ y)) = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋	⊢ ∀ (hiq : i < (F p).fst) (hjq : j < (F p).fst), (F p).snd ⟨i, hiq⟩ ⟨j, hjq⟩ = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋ → (F p).snd ⟨i, hip⟩ ⟨j, hjp⟩ = (F p).snd ⟨i, hiq⟩ ⟨j, hjq⟩
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x),	hip : i < N p,	hiq : i < N q,	i' : i = ↑(⇑(E q) (Ψ x)),	j : ℕ := ↑(⇑(E p) y),	hjp : j < N p,	hjq : j < N q,	j' : j = (⇑(E q) (Ψ y)).val,	this : (F p).snd (⇑(E p) x) (⇑(E p) y) = ⌊ε⁻¹ * has_dist.dist x y⌋,	Ap : (F p).snd ⟨i, hip⟩ ⟨j, hjp⟩ = ⌊ε⁻¹ * has_dist.dist x y⌋,	this : (F q).snd (⇑(E q) (Ψ x)) (⇑(E q) (Ψ y)) = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋,	Aq : (F q).snd ⟨i, hiq⟩ ⟨j, hjq⟩ = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋	⊢ (F p).snd ⟨i, hip⟩ ⟨j, hjp⟩ = (F q).snd ⟨i, hiq⟩ ⟨j, hjq⟩		δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x),	hip : i < N p,	hiq : i < N q,	i' : i = ↑(⇑(E q) (Ψ x)),	j : ℕ := ↑(⇑(E p) y),	hjp : j < N p,	hjq : j < N q,	j' : j = (⇑(E q) (Ψ y)).val,	this : (F p).snd (⇑(E p) x) (⇑(E p) y) = ⌊ε⁻¹ * has_dist.dist x y⌋,	Ap : (F p).snd ⟨i, hip⟩ ⟨j, hjp⟩ = ⌊ε⁻¹ * has_dist.dist x y⌋,	this : (F q).snd (⇑(E q) (Ψ x)) (⇑(E q) (Ψ y)) = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋,	Aq : (F q).snd ⟨i, hiq⟩ ⟨j, hjq⟩ = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋,	this : (F p).snd ⟨i, hip⟩ ⟨j, hjp⟩ = (F q).snd ⟨i, hiq⟩ ⟨j, hjq⟩	⊢ abs (has_dist.dist x y - has_dist.dist (Ψ x) (Ψ y)) ≤ ε
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x),	hip : i < N p,	i' : i = ↑(⇑(E q) (Ψ x)),	j : ℕ := ↑(⇑(E p) y),	hjp : j < N p,	j' : j = (⇑(E q) (Ψ y)).val,	this : (F p).snd (⇑(E p) x) (⇑(E p) y) = ⌊ε⁻¹ * has_dist.dist x y⌋,	Ap : (F p).snd ⟨i, hip⟩ ⟨j, hjp⟩ = ⌊ε⁻¹ * has_dist.dist x y⌋,	this : (F q).snd (⇑(E q) (Ψ x)) (⇑(E q) (Ψ y)) = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋,	hiq : i < (F p).fst,	hjq : j < (F p).fst,	Aq : (F p).snd ⟨i, hiq⟩ ⟨j, hjq⟩ = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋	⊢ (F p).snd ⟨i, hip⟩ ⟨j, hjp⟩ = (F p).snd ⟨i, hiq⟩ ⟨j, hjq⟩
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x),	hip : i < N p,	hiq : i < N q,	i' : i = ↑(⇑(E q) (Ψ x)),	j : ℕ := ↑(⇑(E p) y),	hjp : j < N p,	hjq : j < N q,	j' : j = (⇑(E q) (Ψ y)).val,	this : (F p).snd (⇑(E p) x) (⇑(E p) y) = ⌊ε⁻¹ * has_dist.dist x y⌋,	Ap : (F p).snd ⟨i, hip⟩ ⟨j, hjp⟩ = ⌊ε⁻¹ * has_dist.dist x y⌋,	this : (F q).snd (⇑(E q) (Ψ x)) (⇑(E q) (Ψ y)) = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋,	Aq : (F q).snd ⟨i, hiq⟩ ⟨j, hjq⟩ = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋,	this : (F p).snd ⟨i, hip⟩ ⟨j, hjp⟩ = (F q).snd ⟨i, hiq⟩ ⟨j, hjq⟩	⊢ abs (has_dist.dist x y - has_dist.dist (Ψ x) (Ψ y)) ≤ ε
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x),	hip : i < N p,	hiq : i < N q,	i' : i = ↑(⇑(E q) (Ψ x)),	j : ℕ := ↑(⇑(E p) y),	hjp : j < N p,	hjq : j < N q,	j' : j = (⇑(E q) (Ψ y)).val,	this : (F p).snd (⇑(E p) x) (⇑(E p) y) = ⌊ε⁻¹ * has_dist.dist x y⌋,	Ap : (F p).snd ⟨i, hip⟩ ⟨j, hjp⟩ = ⌊ε⁻¹ * has_dist.dist x y⌋,	this : (F q).snd (⇑(E q) (Ψ x)) (⇑(E q) (Ψ y)) = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋,	Aq : (F q).snd ⟨i, hiq⟩ ⟨j, hjq⟩ = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋,	this : ⌊ε⁻¹ * has_dist.dist x y⌋ = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋	⊢ abs (has_dist.dist x y - has_dist.dist (Ψ x) (Ψ y)) ≤ ε
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → q.rep := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x),	hip : i < N p,	hiq : i < N q,	i' : i = ↑(⇑(E q) (Ψ x)),	j : ℕ := ↑(⇑(E p) y),	hjp : j < N p,	hjq : j < N q,	j' : j = (⇑(E q) (Ψ y)).val,	this : (F p).snd (⇑(E p) x) (⇑(E p) y) = ⌊ε⁻¹ * has_dist.dist x y⌋,	Ap : (F p).snd ⟨i, hip⟩ ⟨j, hjp⟩ = ⌊ε⁻¹ * has_dist.dist x y⌋,	this : (F q).snd (⇑(E q) (Ψ x)) (⇑(E q) (Ψ y)) = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋,	Aq : (F q).snd ⟨i, hiq⟩ ⟨j, hjq⟩ = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋,	this : ⌊ε⁻¹ * has_dist.dist x y⌋ = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋	⊢ abs (ε⁻¹ * (has_dist.dist x y - has_dist.dist (Ψ x) (Ψ y))) = abs (ε⁻¹ * has_dist.dist x y - ε⁻¹ * has_dist.dist (Ψ x) (Ψ y))
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → q.rep := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x),	hip : i < N p,	hiq : i < N q,	i' : i = ↑(⇑(E q) (Ψ x)),	j : ℕ := ↑(⇑(E p) y),	hjp : j < N p,	hjq : j < N q,	j' : j = (⇑(E q) (Ψ y)).val,	this : (F p).snd (⇑(E p) x) (⇑(E p) y) = ⌊ε⁻¹ * has_dist.dist x y⌋,	Ap : (F p).snd ⟨i, hip⟩ ⟨j, hjp⟩ = ⌊ε⁻¹ * has_dist.dist x y⌋,	this : (F q).snd (⇑(E q) (Ψ x)) (⇑(E q) (Ψ y)) = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋,	Aq : (F q).snd ⟨i, hiq⟩ ⟨j, hjq⟩ = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋,	this : ⌊ε⁻¹ * has_dist.dist x y⌋ = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋	⊢ ε⁻¹ * (has_dist.dist x y - has_dist.dist (Ψ x) (Ψ y)) = ε⁻¹ * has_dist.dist x y - ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x),	hip : i < N p,	hiq : i < N q,	i' : i = ↑(⇑(E q) (Ψ x)),	j : ℕ := ↑(⇑(E p) y),	hjp : j < N p,	hjq : j < N q,	j' : j = (⇑(E q) (Ψ y)).val,	this : (F p).snd (⇑(E p) x) (⇑(E p) y) = ⌊ε⁻¹ * has_dist.dist x y⌋,	Ap : (F p).snd ⟨i, hip⟩ ⟨j, hjp⟩ = ⌊ε⁻¹ * has_dist.dist x y⌋,	this : (F q).snd (⇑(E q) (Ψ x)) (⇑(E q) (Ψ y)) = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋,	Aq : (F q).snd ⟨i, hiq⟩ ⟨j, hjq⟩ = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋,	this : ⌊ε⁻¹ * has_dist.dist x y⌋ = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋,	I : abs ε⁻¹ * abs (has_dist.dist x y - has_dist.dist (Ψ x) (Ψ y)) ≤ 1	⊢ abs (has_dist.dist x y - has_dist.dist (Ψ x) (Ψ y)) ≤ ε
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → q.rep := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x),	hip : i < N p,	hiq : i < N q,	i' : i = ↑(⇑(E q) (Ψ x)),	j : ℕ := ↑(⇑(E p) y),	hjp : j < N p,	hjq : j < N q,	j' : j = (⇑(E q) (Ψ y)).val,	this : (F p).snd (⇑(E p) x) (⇑(E p) y) = ⌊ε⁻¹ * has_dist.dist x y⌋,	Ap : (F p).snd ⟨i, hip⟩ ⟨j, hjp⟩ = ⌊ε⁻¹ * has_dist.dist x y⌋,	this : (F q).snd (⇑(E q) (Ψ x)) (⇑(E q) (Ψ y)) = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋,	Aq : (F q).snd ⟨i, hiq⟩ ⟨j, hjq⟩ = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋,	this : ⌊ε⁻¹ * has_dist.dist x y⌋ = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋,	I : abs ε⁻¹ * abs (has_dist.dist x y - has_dist.dist (Ψ x) (Ψ y)) ≤ 1	⊢ abs (has_dist.dist x y - has_dist.dist (Ψ x) (Ψ y)) = ε * ε⁻¹ * abs (has_dist.dist x y - has_dist.dist (Ψ x) (Ψ y))
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → q.rep := λ (x : ↥(s p)), ↑(Ψ x),	x y : ↥(s p),	this : has_dist.dist (Φ x) (Φ y) = has_dist.dist (Ψ x) (Ψ y),	i : ℕ := ↑(⇑(E p) x),	hip : i < N p,	hiq : i < N q,	i' : i = ↑(⇑(E q) (Ψ x)),	j : ℕ := ↑(⇑(E p) y),	hjp : j < N p,	hjq : j < N q,	j' : j = (⇑(E q) (Ψ y)).val,	this : (F p).snd (⇑(E p) x) (⇑(E p) y) = ⌊ε⁻¹ * has_dist.dist x y⌋,	Ap : (F p).snd ⟨i, hip⟩ ⟨j, hjp⟩ = ⌊ε⁻¹ * has_dist.dist x y⌋,	this : (F q).snd (⇑(E q) (Ψ x)) (⇑(E q) (Ψ y)) = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋,	Aq : (F q).snd ⟨i, hiq⟩ ⟨j, hjq⟩ = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋,	this : ⌊ε⁻¹ * has_dist.dist x y⌋ = ⌊ε⁻¹ * has_dist.dist (Ψ x) (Ψ y)⌋,	I : abs ε⁻¹ * abs (has_dist.dist x y - has_dist.dist (Ψ x) (Ψ y)) ≤ 1	⊢ ε * ε⁻¹ * abs (has_dist.dist x y - has_dist.dist (Ψ x) (Ψ y)) = ε * (abs ε⁻¹ * abs (has_dist.dist x y - has_dist.dist (Ψ x) (Ψ y)))
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x)	⊢ Gromov_Hausdorff.GH_dist (Gromov_Hausdorff.GH_space.rep p) (Gromov_Hausdorff.GH_space.rep q) ≤ ε + ε / 2 + ε		δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	main : Gromov_Hausdorff.GH_dist (Gromov_Hausdorff.GH_space.rep p) (Gromov_Hausdorff.GH_space.rep q) ≤ ε + ε / 2 + ε	⊢ has_dist.dist p q ≤ δ
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → Gromov_Hausdorff.GH_space.rep q := λ (x : ↥(s p)), ↑(Ψ x),	main : Gromov_Hausdorff.GH_dist (Gromov_Hausdorff.GH_space.rep p) (Gromov_Hausdorff.GH_space.rep q) ≤ ε + ε / 2 + ε	⊢ has_dist.dist p q ≤ δ
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → q.rep := λ (x : ↥(s p)), ↑(Ψ x),	main : Gromov_Hausdorff.GH_dist p.rep q.rep ≤ ε + ε / 2 + ε	⊢ ε + ε / 2 + ε = δ
δ : ℝ,	δpos : δ > 0,	ε : ℝ := 2 / 5 * δ,	εpos : 0 < ε,	s : Π (p : Gromov_Hausdorff.GH_space), set p.rep,	hs : ∀ (p : Gromov_Hausdorff.GH_space), (s p).finite ∧ set.univ ⊆ ⋃ (x : p.rep) (H : x ∈ s p), metric.ball x ε,	N : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → ℕ,	e : Π (p : Gromov_Hausdorff.GH_space) (t : set p.rep) (ᾰ : t.finite), ↥t ≃ fin (N p t ᾰ),	hne : ∀ (p : Gromov_Hausdorff.GH_space) (t : set p.rep), t.finite → true,	N : Gromov_Hausdorff.GH_space → ℕ := λ (p : Gromov_Hausdorff.GH_space), N p (s p) _,	E : Π (p : Gromov_Hausdorff.GH_space), ↥(s p) ≃ fin (N p (s p) _) := λ (p : Gromov_Hausdorff.GH_space), e p (s p) _,	F : Gromov_Hausdorff.GH_space → (Σ (n : ℕ), fin n → fin n → ℤ) := λ (p : Gromov_Hausdorff.GH_space), ⟨N p, λ (a b : fin (N p)), ⌊ε⁻¹ * has_dist.dist (⇑((E p).symm) a) (⇑((E p).symm) b)⌋⟩,	p q : Gromov_Hausdorff.GH_space,	hpq : F p = F q,	Npq : N p = N q,	Ψ : ↥(s p) → ↥(s q) := λ (x : ↥(s p)), ⇑((E q).symm) (⇑(fin.cast Npq) (⇑(E p) x)),	Φ : ↥(s p) → q.rep := λ (x : ↥(s p)), ↑(Ψ x),	main : Gromov_Hausdorff.GH_dist p.rep q.rep ≤ ε + ε / 2 + ε	⊢ 2 / 5 * δ + 2 / 5 * δ / 2 + 2 / 5 * δ = δ
⊢ complete_space Gromov_Hausdorff.GH_space
⊢ ∀ (n : ℕ), 0 < (1 / 2) ^ n
⊢ 0 < 1 / 2
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n	⊢ complete_space Gromov_Hausdorff.GH_space
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N	⊢ ∃ (x : Gromov_Hausdorff.GH_space), filter.tendsto u filter.at_top (𝓝 x)
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep	⊢ ∃ (x : Gromov_Hausdorff.GH_space), filter.tendsto u filter.at_top (𝓝 x)
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X	⊢ ∃ (x : Gromov_Hausdorff.GH_space), filter.tendsto u filter.at_top (𝓝 x)
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric	⊢ ∃ (x : Gromov_Hausdorff.GH_space), filter.tendsto u filter.at_top (𝓝 x)
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	n : ℕ	⊢ metric.glue_space _ _ = (Y n.succ).space
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	n : ℕ	⊢ metric.glue_space _ _ = metric.glue_space _ _
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space	⊢ ∃ (x : Gromov_Hausdorff.GH_space), filter.tendsto u filter.at_top (𝓝 x)
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _	⊢ ∃ (x : Gromov_Hausdorff.GH_space), filter.tendsto u filter.at_top (𝓝 x)
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n)	⊢ ∃ (x : Gromov_Hausdorff.GH_space), filter.tendsto u filter.at_top (𝓝 x)
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _	⊢ ∃ (x : Gromov_Hausdorff.GH_space), filter.tendsto u filter.at_top (𝓝 x)
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _	⊢ ∀ (n : ℕ), isometry (f n)
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	n : ℕ	⊢ isometry (f n)
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	n : ℕ,	x y : metric.glue_space _ _	⊢ has_edist.edist (c n x) (c n y) = has_edist.edist x y
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	n : ℕ	⊢ isometry (c n)		this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	n : ℕ	⊢ isometry (metric.to_glue_l _ _)
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	n : ℕ	⊢ isometry (c n)
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _	⊢ ∀ (n : ℕ), isometry (f n)		this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n)	⊢ ∃ (x : Gromov_Hausdorff.GH_space), filter.tendsto u filter.at_top (𝓝 x)
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	n : ℕ	⊢ isometry (metric.to_glue_l _ _)
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n)	⊢ ∃ (x : Gromov_Hausdorff.GH_space), filter.tendsto u filter.at_top (𝓝 x)
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I	⊢ ∃ (x : Gromov_Hausdorff.GH_space), filter.tendsto u filter.at_top (𝓝 x)
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0	⊢ ∃ (x : Gromov_Hausdorff.GH_space), filter.tendsto u filter.at_top (𝓝 x)
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I	⊢ ∃ (x : Gromov_Hausdorff.GH_space), filter.tendsto u filter.at_top (𝓝 x)
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe	⊢ ∃ (x : Gromov_Hausdorff.GH_space), filter.tendsto u filter.at_top (𝓝 x)
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed)	⊢ ∃ (x : Gromov_Hausdorff.GH_space), filter.tendsto u filter.at_top (𝓝 x)
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed)	⊢ ∀ (n : ℕ), isometry (coeZ ∘ Φ n ∘ (Y n).embed)
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed),	n : ℕ	⊢ isometry (coeZ ∘ Φ n ∘ (Y n).embed)
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed),	n : ℕ	⊢ isometry (Φ n ∘ (Y n).embed)
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed)	⊢ ∀ (n : ℕ), isometry (coeZ ∘ Φ n ∘ (Y n).embed)		this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed),	isom : ∀ (n : ℕ), isometry (coeZ ∘ Φ n ∘ (Y n).embed)	⊢ ∃ (x : Gromov_Hausdorff.GH_space), filter.tendsto u filter.at_top (𝓝 x)
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed),	n : ℕ	⊢ isometry (Φ n)
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed),	isom : ∀ (n : ℕ), isometry (coeZ ∘ Φ n ∘ (Y n).embed)	⊢ ∃ (x : Gromov_Hausdorff.GH_space), filter.tendsto u filter.at_top (𝓝 x)
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed),	isom : ∀ (n : ℕ), isometry (coeZ ∘ Φ n ∘ (Y n).embed)	⊢ ∀ (n : ℕ), metric.Hausdorff_dist (X2 n) (X2 n.succ) < (1 / 2) ^ n
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed),	isom : ∀ (n : ℕ), isometry (coeZ ∘ Φ n ∘ (Y n).embed),	n : ℕ	⊢ metric.Hausdorff_dist (X2 n) (X2 n.succ) < (1 / 2) ^ n
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed),	isom : ∀ (n : ℕ), isometry (coeZ ∘ Φ n ∘ (Y n).embed),	n : ℕ	⊢ X2 n = set.range ((coeZ ∘ Φ n.succ ∘ c n ∘ metric.to_glue_r _ _) ∘ Gromov_Hausdorff.optimal_GH_injl (X n) (X n.succ))
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed),	isom : ∀ (n : ℕ), isometry (coeZ ∘ Φ n ∘ (Y n).embed),	n : ℕ	⊢ X2 n = set.range (coeZ ∘ Φ n.succ ∘ c n ∘ metric.to_glue_r _ _ ∘ Gromov_Hausdorff.optimal_GH_injl (X n) (X n.succ))
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed),	isom : ∀ (n : ℕ), isometry (coeZ ∘ Φ n ∘ (Y n).embed),	n : ℕ	⊢ set.range (coeZ ∘ metric.to_inductive_limit I n ∘ (Y n).embed) = set.range (coeZ ∘ metric.to_inductive_limit I n.succ ∘ c n ∘ metric.to_glue_r _ _ ∘ Gromov_Hausdorff.optimal_GH_injl (X n) (X n.succ))
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed),	isom : ∀ (n : ℕ), isometry (coeZ ∘ Φ n ∘ (Y n).embed),	n : ℕ	⊢ set.range (coeZ ∘ (metric.to_inductive_limit I n.succ ∘ (λ (n : ℕ), f n) n) ∘ (Y n).embed) = set.range (coeZ ∘ metric.to_inductive_limit I n.succ ∘ c n ∘ metric.to_glue_r _ _ ∘ Gromov_Hausdorff.optimal_GH_injl (X n) (X n.succ))
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed),	isom : ∀ (n : ℕ), isometry (coeZ ∘ Φ n ∘ (Y n).embed),	n : ℕ	⊢ X2 n = set.range ((coeZ ∘ Φ n.succ ∘ c n ∘ metric.to_glue_r _ _) ∘ Gromov_Hausdorff.optimal_GH_injl (X n) (X n.succ))		this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed),	isom : ∀ (n : ℕ), isometry (coeZ ∘ Φ n ∘ (Y n).embed),	n : ℕ,	X2n : X2 n = set.range ((coeZ ∘ Φ n.succ ∘ c n ∘ metric.to_glue_r _ _) ∘ Gromov_Hausdorff.optimal_GH_injl (X n) (X n.succ))	⊢ metric.Hausdorff_dist (X2 n) (X2 n.succ) < (1 / 2) ^ n
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed),	isom : ∀ (n : ℕ), isometry (coeZ ∘ Φ n ∘ (Y n).embed),	n : ℕ	⊢ set.range (coeZ ∘ (metric.to_inductive_limit I n.succ ∘ c n ∘ metric.to_glue_l _ _) ∘ (Y n).embed) = set.range (coeZ ∘ metric.to_inductive_limit I n.succ ∘ c n ∘ metric.to_glue_r _ _ ∘ Gromov_Hausdorff.optimal_GH_injl (X n) (X n.succ))
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed),	isom : ∀ (n : ℕ), isometry (coeZ ∘ Φ n ∘ (Y n).embed),	n : ℕ,	X2n : X2 n = set.range ((coeZ ∘ Φ n.succ ∘ c n ∘ metric.to_glue_r _ _) ∘ Gromov_Hausdorff.optimal_GH_injl (X n) (X n.succ))	⊢ metric.Hausdorff_dist (X2 n) (X2 n.succ) < (1 / 2) ^ n
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed),	isom : ∀ (n : ℕ), isometry (coeZ ∘ Φ n ∘ (Y n).embed),	n : ℕ,	X2n : X2 n = coeZ ∘ Φ n.succ ∘ c n ∘ metric.to_glue_r _ _ '' set.range (Gromov_Hausdorff.optimal_GH_injl (X n) (X n.succ))	⊢ metric.Hausdorff_dist (X2 n) (X2 n.succ) < (1 / 2) ^ n
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed),	isom : ∀ (n : ℕ), isometry (coeZ ∘ Φ n ∘ (Y n).embed),	n : ℕ,	X2n : X2 n = coeZ ∘ Φ n.succ ∘ c n ∘ metric.to_glue_r _ _ '' set.range (Gromov_Hausdorff.optimal_GH_injl (X n) (X n.succ))	⊢ X2 n.succ = set.range ((coeZ ∘ Φ n.succ ∘ c n ∘ metric.to_glue_r _ _) ∘ Gromov_Hausdorff.optimal_GH_injr (X n) (X n.succ))
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed),	isom : ∀ (n : ℕ), isometry (coeZ ∘ Φ n ∘ (Y n).embed),	n : ℕ,	X2n : X2 n = coeZ ∘ Φ n.succ ∘ c n ∘ metric.to_glue_r _ _ '' set.range (Gromov_Hausdorff.optimal_GH_injl (X n) (X n.succ)),	X2nsucc : X2 n.succ = set.range ((coeZ ∘ Φ n.succ ∘ c n ∘ metric.to_glue_r _ _) ∘ Gromov_Hausdorff.optimal_GH_injr (X n) (X n.succ))	⊢ metric.Hausdorff_dist (X2 n) (X2 n.succ) < (1 / 2) ^ n
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed),	isom : ∀ (n : ℕ), isometry (coeZ ∘ Φ n ∘ (Y n).embed),	n : ℕ,	X2n : X2 n = coeZ ∘ Φ n.succ ∘ c n ∘ metric.to_glue_r _ _ '' set.range (Gromov_Hausdorff.optimal_GH_injl (X n) (X n.succ)),	X2nsucc : X2 n.succ = coeZ ∘ Φ n.succ ∘ c n ∘ metric.to_glue_r _ _ '' set.range (Gromov_Hausdorff.optimal_GH_injr (X n) (X n.succ))	⊢ metric.Hausdorff_dist (X2 n) (X2 n.succ) < (1 / 2) ^ n
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed),	isom : ∀ (n : ℕ), isometry (coeZ ∘ Φ n ∘ (Y n).embed),	n : ℕ,	X2n : X2 n = coeZ ∘ Φ n.succ ∘ c n ∘ metric.to_glue_r _ _ '' set.range (Gromov_Hausdorff.optimal_GH_injl (X n) (X n.succ)),	X2nsucc : X2 n.succ = coeZ ∘ Φ n.succ ∘ c n ∘ metric.to_glue_r _ _ '' set.range (Gromov_Hausdorff.optimal_GH_injr (X n) (X n.succ))	⊢ has_dist.dist (u n) (u n.succ) < (1 / 2) ^ n		this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed),	isom : ∀ (n : ℕ), isometry (coeZ ∘ Φ n ∘ (Y n).embed),	n : ℕ,	X2n : X2 n = coeZ ∘ Φ n.succ ∘ c n ∘ metric.to_glue_r _ _ '' set.range (Gromov_Hausdorff.optimal_GH_injl (X n) (X n.succ)),	X2nsucc : X2 n.succ = coeZ ∘ Φ n.succ ∘ c n ∘ metric.to_glue_r _ _ '' set.range (Gromov_Hausdorff.optimal_GH_injr (X n) (X n.succ))	⊢ isometry (coeZ ∘ Φ n.succ ∘ c n ∘ metric.to_glue_r _ _)
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed),	isom : ∀ (n : ℕ), isometry (coeZ ∘ Φ n ∘ (Y n).embed),	n : ℕ,	X2n : X2 n = coeZ ∘ Φ n.succ ∘ c n ∘ metric.to_glue_r _ _ '' set.range (Gromov_Hausdorff.optimal_GH_injl (X n) (X n.succ)),	X2nsucc : X2 n.succ = coeZ ∘ Φ n.succ ∘ c n ∘ metric.to_glue_r _ _ '' set.range (Gromov_Hausdorff.optimal_GH_injr (X n) (X n.succ))	⊢ has_dist.dist (u n) (u n.succ) < (1 / 2) ^ n
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed),	isom : ∀ (n : ℕ), isometry (coeZ ∘ Φ n ∘ (Y n).embed),	n : ℕ,	X2n : X2 n = coeZ ∘ Φ n.succ ∘ c n ∘ metric.to_glue_r _ _ '' set.range (Gromov_Hausdorff.optimal_GH_injl (X n) (X n.succ)),	X2nsucc : X2 n.succ = coeZ ∘ Φ n.succ ∘ c n ∘ metric.to_glue_r _ _ '' set.range (Gromov_Hausdorff.optimal_GH_injr (X n) (X n.succ))	⊢ isometry (coeZ ∘ Φ n.succ ∘ c n ∘ metric.to_glue_r _ _)
this : ∀ (n : ℕ), 0 < (1 / 2) ^ n,	u : ℕ → Gromov_Hausdorff.GH_space,	hu : ∀ (N n m : ℕ), N ≤ n → N ≤ m → has_dist.dist (u n) (u m) < (1 / 2) ^ N,	X : ℕ → Type := λ (n : ℕ), (u n).rep,	Y : Π (n : ℕ), Gromov_Hausdorff.aux_gluing_struct (X n) := Gromov_Hausdorff.aux_gluing X,	_inst : Π (n : ℕ), metric_space (Y n).space := λ (n : ℕ), (Y n).metric,	E : ∀ (n : ℕ), metric.glue_space _ _ = (Y n.succ).space,	c : Π (n : ℕ), metric.glue_space _ _ → (Y n.succ).space := λ (n : ℕ), cast _,	ic : ∀ (n : ℕ), isometry (c n),	f : Π (n : ℕ), (Y n).space → (Y n.succ).space := λ (n : ℕ), c n ∘ metric.to_glue_l _ _,	I : ∀ (n : ℕ), isometry (f n),	Z0 : Type := metric.inductive_limit I,	Z : Type := uniform_space.completion Z0,	Φ : Π (n : ℕ), (λ (n : ℕ), (Y n).space) n → metric.inductive_limit I := metric.to_inductive_limit I,	coeZ : Z0 → Z := coe,	X2 : ℕ → set Z := λ (n : ℕ), set.range (coeZ ∘ Φ n ∘ (Y n).embed),	isom : ∀ (n : ℕ), isometry (coeZ ∘ Φ n ∘ (Y n).embed),	n : ℕ,	X2n : X2 n = coeZ ∘ Φ n.succ ∘ c n ∘ metric.to_glue_r _ _ '' set.range (Gromov_Hausdorff.optimal_GH_injl (X n) (X n.succ)),	X2nsucc : X2 n.succ = coeZ ∘ Φ n.succ ∘ c n ∘ metric.to_glue_r _ _ '' set.range (Gromov_Hausdorff.optimal_GH_injr (X n) (X n.succ))	⊢ isometry (Φ n.succ ∘ c n ∘ metric.to_glue_r _ _)
α : Type u,	_inst_1 : pseudo_emetric_space α,	s t : set α,	fin : emetric.Hausdorff_edist s t ≠ ⊤	⊢ s = ∅ ∧ t = ∅ ∨ s.nonempty ∧ t.nonempty
α : Type u,	_inst_1 : pseudo_emetric_space α,	s t : set α,	fin : emetric.Hausdorff_edist s t ≠ ⊤,	hs : s = ∅	⊢ s = ∅ ∧ t = ∅ ∨ s.nonempty ∧ t.nonempty
α : Type u,	_inst_1 : pseudo_emetric_space α,	s t : set α,	fin : emetric.Hausdorff_edist s t ≠ ⊤,	hs : s = ∅,	ht : t = ∅	⊢ s = ∅ ∧ t = ∅ ∨ s.nonempty ∧ t.nonempty		case or.inl, or.inr	α : Type u,	_inst_1 : pseudo_emetric_space α,	s t : set α,	fin : emetric.Hausdorff_edist s t ≠ ⊤,	hs : s = ∅,	ht : t.nonempty	⊢ s = ∅ ∧ t = ∅ ∨ s.nonempty ∧ t.nonempty
α : Type u,	_inst_1 : pseudo_emetric_space α,	s t : set α,	fin : emetric.Hausdorff_edist s t ≠ ⊤,	hs : s = ∅,	ht : t = ∅	⊢ s = ∅ ∧ t = ∅ ∨ s.nonempty ∧ t.nonempty
α : Type u,	_inst_1 : pseudo_emetric_space α,	s t : set α,	fin : emetric.Hausdorff_edist s t ≠ ⊤,	hs : s = ∅,	ht : t.nonempty	⊢ s = ∅ ∧ t = ∅ ∨ s.nonempty ∧ t.nonempty
α : Type u,	_inst_1 : pseudo_emetric_space α,	s t : set α,	fin : emetric.Hausdorff_edist s t ≠ ⊤,	hs : s = ∅	⊢ s = ∅ ∧ t = ∅ ∨ s.nonempty ∧ t.nonempty		case or.inr	α : Type u,	_inst_1 : pseudo_emetric_space α,	s t : set α,	fin : emetric.Hausdorff_edist s t ≠ ⊤,	hs : s.nonempty	⊢ s = ∅ ∧ t = ∅ ∨ s.nonempty ∧ t.nonempty
α : Type u,	_inst_1 : pseudo_emetric_space α,	s t : set α,	hs : s = ∅,	ht : t.nonempty,	fin : emetric.Hausdorff_edist t s ≠ ⊤	⊢ s = ∅ ∧ t = ∅ ∨ s.nonempty ∧ t.nonempty
α : Type u,	_inst_1 : pseudo_emetric_space α,	s t : set α,	fin : emetric.Hausdorff_edist s t ≠ ⊤,	hs : s.nonempty	⊢ s = ∅ ∧ t = ∅ ∨ s.nonempty ∧ t.nonempty
α : Type u,	β : Type v,	_inst_1 : pseudo_metric_space α,	_inst_2 : pseudo_metric_space β,	f : α → β,	hf : isometry f,	x y : α	⊢ has_dist.dist (f x) (f y) = has_dist.dist x y
α : Type u,	_inst_1 : preorder α,	c : omega_complete_partial_order.chain α,	x : α	⊢ Scott.is_ωSup c x ↔ is_lub (set.range ⇑c) x
α : Type u_1,	_inst_1 : topological_space α,	B : set (topological_space.opens α)	⊢ topological_space.opens.is_basis B ↔ ∀ (U : topological_space.opens α), ∃ (Us : set (topological_space.opens α)) (H : Us ⊆ B), U = has_Sup.Sup Us
α : Type u_1,	_inst_1 : topological_space α,	B : set (topological_space.opens α)	⊢ topological_space.opens.is_basis B → ∀ (U : topological_space.opens α), ∃ (Us : set (topological_space.opens α)) (H : Us ⊆ B), U = has_Sup.Sup Us
α : Type u_1,	_inst_1 : topological_space α,	B : set (topological_space.opens α),	hB : topological_space.opens.is_basis B,	U : topological_space.opens α	⊢ ∃ (Us : set (topological_space.opens α)) (H : Us ⊆ B), U = has_Sup.Sup Us
α : Type u_1,	_inst_1 : topological_space α,	B : set (topological_space.opens α),	hB : topological_space.opens.is_basis B,	U : topological_space.opens α	⊢ U = has_Sup.Sup {V : topological_space.opens α | V ∈ B ∧ V ⊆ U}
α : Type u_1,	_inst_1 : topological_space α,	B : set (topological_space.opens α),	hB : topological_space.opens.is_basis B,	U : topological_space.opens α	⊢ ↑U = ↑(has_Sup.Sup {V : topological_space.opens α | V ∈ B ∧ V ⊆ U})
α : Type u_1,	_inst_1 : topological_space α,	B : set (topological_space.opens α),	hB : topological_space.opens.is_basis B,	U : topological_space.opens α	⊢ ⋃₀{s ∈ coe '' B | s ⊆ ↑U} = ⋃₀(coe '' {V : topological_space.opens α | V ∈ B ∧ V ⊆ U})
α : Type u_1,	_inst_1 : topological_space α,	B : set (topological_space.opens α)	⊢ topological_space.opens.is_basis B → ∀ (U : topological_space.opens α), ∃ (Us : set (topological_space.opens α)) (H : Us ⊆ B), U = has_Sup.Sup Us		α : Type u_1,	_inst_1 : topological_space α,	B : set (topological_space.opens α)	⊢ (∀ (U : topological_space.opens α), ∃ (Us : set (topological_space.opens α)) (H : Us ⊆ B), U = has_Sup.Sup Us) → topological_space.opens.is_basis B
α : Type u_1,	_inst_1 : topological_space α,	B : set (topological_space.opens α),	hB : topological_space.opens.is_basis B,	U : topological_space.opens α	⊢ (⨆ (b : topological_space.opens α) (H : b ∈ B) (h₂ : (λ (s : set α), s ⊆ ↑U) ↑b), ↑b) = ⨆ (x : topological_space.opens α) (h₁ : x ∈ B) (h₂ : x ⊆ U), ↑x
α : Type u_1,	_inst_1 : topological_space α,	B : set (topological_space.opens α)	⊢ (∀ (U : topological_space.opens α), ∃ (Us : set (topological_space.opens α)) (H : Us ⊆ B), U = has_Sup.Sup Us) → topological_space.opens.is_basis B
α : Type u_1,	_inst_1 : topological_space α,	B : set (topological_space.opens α),	h : ∀ (U : topological_space.opens α), ∃ (Us : set (topological_space.opens α)) (H : Us ⊆ B), U = has_Sup.Sup Us	⊢ topological_space.opens.is_basis B
α : Type u_1,	_inst_1 : topological_space α,	B : set (topological_space.opens α),	h : ∀ (U : topological_space.opens α), ∃ (Us : set (topological_space.opens α)) (H : Us ⊆ B), U = has_Sup.Sup Us	⊢ ∀ {U : topological_space.opens α} {x : α}, x ∈ U → (∃ (U' : topological_space.opens α) (H : U' ∈ B), x ∈ U' ∧ U' ⊆ U)
α : Type u_1,	_inst_1 : topological_space α,	B : set (topological_space.opens α),	h : ∀ (U : topological_space.opens α), ∃ (Us : set (topological_space.opens α)) (H : Us ⊆ B), U = has_Sup.Sup Us,	U : topological_space.opens α,	x : α,	hx : x ∈ U	⊢ ∃ (U' : topological_space.opens α) (H : U' ∈ B), x ∈ U' ∧ U' ⊆ U
α : Type u_1,	_inst_1 : topological_space α,	B : set (topological_space.opens α),	h : ∀ (U : topological_space.opens α), ∃ (Us : set (topological_space.opens α)) (H : Us ⊆ B), U = has_Sup.Sup Us,	x : α,	Us : set (topological_space.opens α),	hUs : Us ⊆ B,	hx : x ∈ has_Sup.Sup Us	⊢ ∃ (U' : topological_space.opens α) (H : U' ∈ B), x ∈ U' ∧ U' ⊆ has_Sup.Sup Us
α : Type u_1,	_inst_1 : topological_space α,	B : set (topological_space.opens α),	h : ∀ (U : topological_space.opens α), ∃ (Us : set (topological_space.opens α)) (H : Us ⊆ B), U = has_Sup.Sup Us,	x : α,	Us : set (topological_space.opens α),	hUs : Us ⊆ B,	hx : x ∈ has_Sup.Sup Us,	U : topological_space.opens α,	Us : U ∈ Us,	xU : x ∈ U	⊢ ∃ (U' : topological_space.opens α) (H : U' ∈ B), x ∈ U' ∧ U' ⊆ has_Sup.Sup Us
α : Type u_1,	β : Type u_2,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	f : α ≃ₜ β	⊢ function.left_inverse (topological_space.opens.comap _) (topological_space.opens.comap _)
α : Type u_1,	β : Type u_2,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	f : α ≃ₜ β,	U : topological_space.opens α	⊢ topological_space.opens.comap _ (topological_space.opens.comap _ U) = U
α : Type u_1,	β : Type u_2,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	f : α ≃ₜ β,	U : topological_space.opens α	⊢ ↑(topological_space.opens.comap _ (topological_space.opens.comap _ U)) = ↑U
α : Type u_1,	β : Type u_2,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	f : α ≃ₜ β	⊢ function.right_inverse (topological_space.opens.comap _) (topological_space.opens.comap _)
α : Type u_1,	β : Type u_2,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	f : α ≃ₜ β,	U : topological_space.opens β	⊢ topological_space.opens.comap _ (topological_space.opens.comap _ U) = U
α : Type u_1,	β : Type u_2,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	f : α ≃ₜ β,	U : topological_space.opens β	⊢ ↑(topological_space.opens.comap _ (topological_space.opens.comap _ U)) = ↑U
ι : Type u,	X : Type v,	_inst_1 : topological_space X,	i : ι,	s : set X,	x : X	⊢ ∃ (t : set X) (H : t ∈ 𝓝 x), {i_1 : ι | ((λ (i_1 : ι), function.support ⇑(pi.single i 1 i_1)) i_1 ∩ t).nonempty}.finite
ι : Type u,	X : Type v,	_inst_1 : topological_space X,	i : ι,	s : set X,	x : X	⊢ {i_1 : ι | ((λ (i_1 : ι), function.support ⇑(pi.single i 1 i_1)) i_1 ∩ set.univ).nonempty} ⊆ {i}
ι : Type u,	X : Type v,	_inst_1 : topological_space X,	i : ι,	s : set X,	x : X,	j : ι,	x : X,	hx : x ∈ (λ (i_1 : ι), function.support ⇑(pi.single i 1 i_1)) j	⊢ j ∈ {i}
ι : Type u,	X : Type v,	_inst_1 : topological_space X,	i : ι,	s : set X,	x : X,	j : ι,	x : X,	hx : j ∉ {i}	⊢ x ∉ function.support ⇑(pi.single i 1 j)
ι : Type u,	X : Type v,	_inst_1 : topological_space X,	i : ι,	s : set X,	x : X,	j : ι,	x : X,	hx : ¬j = i	⊢ x ∉ function.support ⇑(pi.single i 1 j)
ι : Type u,	X : Type v,	_inst_1 : topological_space X,	i : ι,	s : set X,	x : X,	_x : x ∈ s	⊢ ⇑(pi.single i 1 i) =ᶠ[𝓝 x] 1
α : Type u,	_inst_1 : topological_space α,	a : set α,	a : α,	h : a ∈ ∅	⊢ a ∈ ∅
H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H	⊢ topological_space.is_topological_basis {s : set H | is_clopen s}
H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H	⊢ ∀ (a : H) (u : set H), a ∈ u → is_open u → (∃ (v : set H) (H_1 : v ∈ {s : set H | is_clopen s}), a ∈ v ∧ v ⊆ u)
H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U	⊢ ∃ (v : set H) (H_1 : v ∈ {s : set H | is_clopen s}), x ∈ v ∧ v ⊆ U
H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U	⊢ ∃ (v : set H) (H_1 : v ∈ {s : set H | is_clopen s}), x ∈ v ∧ v ⊆ U
H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t	⊢ ∃ (v : set H) (H_1 : v ∈ {s : set H | is_clopen s}), x ∈ v ∧ v ⊆ U
H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s	⊢ ∃ (v : set H) (H_1 : v ∈ {s : set H | is_clopen s}), x ∈ v ∧ v ⊆ U
H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u	⊢ ∃ (v : set H) (H_1 : v ∈ {s : set H | is_clopen s}), x ∈ v ∧ v ⊆ U
H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩	⊢ ∃ (v : set H) (H_1 : v ∈ {s : set H | is_clopen s}), x ∈ v ∧ v ⊆ U
H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u	⊢ ∃ (v : set H) (H_1 : v ∈ {s : set H | is_clopen s}), x ∈ v ∧ v ⊆ U
H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s	⊢ ∃ (v : set H) (H_1 : v ∈ {s : set H | is_clopen s}), x ∈ v ∧ v ⊆ U
H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u	⊢ ∃ (v : set H) (H_1 : v ∈ {s : set H | is_clopen s}), x ∈ v ∧ v ⊆ U
H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u	⊢ is_clopen (coe '' V)
H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u	⊢ is_open (coe '' V)
H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	v : set ↥u := coe ⁻¹' V	⊢ is_open (coe '' V)
H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	v : set ↥u := coe ⁻¹' V,	this : coe = coe ∘ coe	⊢ is_open (coe '' V)
H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	v : set ↥u := coe ⁻¹' V,	this : coe = coe ∘ coe,	f0 : embedding coe	⊢ is_open (coe '' V)
H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	v : set ↥u := coe ⁻¹' V,	this : coe = coe ∘ coe,	f0 : embedding coe	⊢ open_embedding coe
H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	v : set ↥u := coe ⁻¹' V,	this : coe = coe ∘ coe,	f0 : embedding coe	⊢ is_open (set.range coe)
H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	v : set ↥u := coe ⁻¹' V,	this : coe = coe ∘ coe,	f0 : embedding coe	⊢ set.range coe = interior s
H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	v : set ↥u := coe ⁻¹' V,	this : coe = coe ∘ coe,	f0 : embedding coe	⊢ interior s ∩ s = interior s
H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	v : set ↥u := coe ⁻¹' V,	this : coe = coe ∘ coe,	f0 : embedding coe	⊢ set.range coe = interior s		H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	v : set ↥u := coe ⁻¹' V,	this : coe = coe ∘ coe,	f0 : embedding coe,	this : set.range coe = interior s	⊢ is_open (set.range coe)
H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	v : set ↥u := coe ⁻¹' V,	this : coe = coe ∘ coe,	f0 : embedding coe,	this : set.range coe = interior s	⊢ is_open (set.range coe)
H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	v : set ↥u := coe ⁻¹' V,	this : coe = coe ∘ coe,	f0 : embedding coe	⊢ open_embedding coe		H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	v : set ↥u := coe ⁻¹' V,	this : coe = coe ∘ coe,	f0 : embedding coe,	f1 : open_embedding coe	⊢ is_open (coe '' V)
H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	v : set ↥u := coe ⁻¹' V,	this : coe = coe ∘ coe,	f0 : embedding coe,	this : set.range coe = interior s	⊢ is_open (interior s)
H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	v : set ↥u := coe ⁻¹' V,	this : coe = coe ∘ coe,	f0 : embedding coe,	f1 : open_embedding coe	⊢ is_open (coe '' V)
H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	v : set ↥u := coe ⁻¹' V,	this : coe = coe ∘ coe,	f0 : embedding coe,	f1 : open_embedding coe,	f2 : is_open v	⊢ is_open (coe '' V)
H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	v : set ↥u := coe ⁻¹' V,	this : coe = coe ∘ coe,	f0 : embedding coe,	f1 : open_embedding coe,	f2 : is_open v	⊢ coe '' V = coe '' v
H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	v : set ↥u := coe ⁻¹' V,	this : coe = coe ∘ coe,	f0 : embedding coe,	f1 : open_embedding coe,	f2 : is_open v	⊢ coe '' V = coe '' v		H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	v : set ↥u := coe ⁻¹' V,	this : coe = coe ∘ coe,	f0 : embedding coe,	f1 : open_embedding coe,	f2 : is_open v,	f3 : coe '' V = coe '' v	⊢ is_open (coe '' V)
H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	v : set ↥u := coe ⁻¹' V,	this : coe = coe ∘ coe,	f0 : embedding coe,	f1 : open_embedding coe,	f2 : is_open v,	f3 : coe '' V = coe '' v	⊢ is_open (coe '' V)
H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u	⊢ is_clopen (coe '' V)		H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	V_clopen : is_clopen (coe '' V)	⊢ ∃ (v : set H) (H_1 : v ∈ {s : set H | is_clopen s}), x ∈ v ∧ v ⊆ U
H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	v : set ↥u := coe ⁻¹' V,	this : coe = coe ∘ coe,	f0 : embedding coe,	f1 : open_embedding coe,	f2 : is_open v,	f3 : coe '' V = coe '' v	⊢ is_open (coe '' v)
H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	V_clopen : is_clopen (coe '' V)	⊢ x ∈ coe '' V
H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	V_clopen : is_clopen (coe '' V)	⊢ ∃ (v : set H) (H_1 : v ∈ {s : set H | is_clopen s}), x ∈ v ∧ v ⊆ U
H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	V_clopen : is_clopen (coe '' V)	⊢ coe '' V ⊆ U
H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	V_clopen : is_clopen (coe '' V)	⊢ coe '' V ⊆ s		H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	V_clopen : is_clopen (coe '' V)	⊢ s ⊆ U
H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	V_clopen : is_clopen (coe '' V)	⊢ coe '' V ⊆ s
H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	V_clopen : is_clopen (coe '' V)	⊢ s ⊆ U
α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty	⊢ ∃ (x : α), x ∈ S ∧ is_closed {x}
α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V	⊢ ∃ (x : α), x ∈ S ∧ is_closed {x}
α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	hnt : ∃ (x y : α) (hx : x ∈ V) (hy : y ∈ V), x ≠ y	⊢ ∃ (x : α), x ∈ S ∧ is_closed {x}
α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	hnt : ∃ (x y : α) (hx : x ∈ V) (hy : y ∈ V), x ≠ y	⊢ false
α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y	⊢ false
α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y,	U : set α,	hU : is_open U,	hsep : xor (x ∈ U) (y ∈ U)	⊢ false
α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y,	U : set α,	hU : is_open U,	hsep : xor (x ∈ U) (y ∈ U)	⊢ ∀ (z w : α), z ∈ V → w ∈ V → z ∈ U → w ∉ U → false
α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y,	U : set α,	hU : is_open U,	hsep : xor (x ∈ U) (y ∈ U),	z w : α,	hz : z ∈ V,	hw : w ∈ V,	hz' : z ∈ U,	hw' : w ∉ U	⊢ false
α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y,	U : set α,	hU : is_open U,	hsep : xor (x ∈ U) (y ∈ U),	z w : α,	hz : z ∈ V,	hw : w ∈ V,	hz' : z ∈ U,	hw' : w ∉ U	⊢ w ∈ V ∩ Uᶜ
α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y,	U : set α,	hU : is_open U,	hsep : xor (x ∈ U) (y ∈ U),	z w : α,	hz : z ∈ V,	hw : w ∈ V,	hz' : z ∈ U,	hw' : w ∉ U	⊢ (V ∩ Uᶜ).nonempty		α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y,	U : set α,	hU : is_open U,	hsep : xor (x ∈ U) (y ∈ U),	z w : α,	hz : z ∈ V,	hw : w ∈ V,	hz' : z ∈ U,	hw' : w ∉ U,	uvne : (V ∩ Uᶜ).nonempty	⊢ false
α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y,	U : set α,	hU : is_open U,	hsep : xor (x ∈ U) (y ∈ U),	z w : α,	hz : z ∈ V,	hw : w ∈ V,	hz' : z ∈ U,	hw' : w ∉ U	⊢ (V ∩ Uᶜ).nonempty
α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y,	U : set α,	hU : is_open U,	hsep : xor (x ∈ U) (y ∈ U),	z w : α,	hz : z ∈ V,	hw : w ∈ V,	hz' : z ∈ U,	hw' : w ∉ U,	uvne : (V ∩ Uᶜ).nonempty	⊢ false
α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y,	U : set α,	hU : is_open U,	hsep : xor (x ∈ U) (y ∈ U),	z w : α,	hz : z ∈ V,	hw : w ∈ V,	hz' : z ∈ U,	hw' : w ∉ U,	uvne : (V ∩ Uᶜ).nonempty,	hV : V ∩ Uᶜ = V	⊢ false
α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y,	U : set α,	hU : is_open U,	hsep : xor (x ∈ U) (y ∈ U),	z w : α,	hz : z ∈ V,	hw : w ∈ V,	hz' : z ∈ U,	hw' : w ∉ U,	uvne : (V ∩ Uᶜ).nonempty,	hV : V ∩ Uᶜ = V	⊢ V ∩ Uᶜ ⊆ Uᶜ
α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y,	U : set α,	hU : is_open U,	hsep : xor (x ∈ U) (y ∈ U),	z w : α,	hz : z ∈ V,	hw : w ∈ V,	hz' : z ∈ U,	hw' : w ∉ U,	uvne : (V ∩ Uᶜ).nonempty,	hV : V ∩ Uᶜ = V	⊢ V ⊆ Uᶜ		α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y,	U : set α,	hU : is_open U,	hsep : xor (x ∈ U) (y ∈ U),	z w : α,	hz : z ∈ V,	hw : w ∈ V,	hz' : z ∈ U,	hw' : w ∉ U,	uvne : (V ∩ Uᶜ).nonempty,	hV : V ∩ Uᶜ = V,	this : V ⊆ Uᶜ	⊢ false
α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y,	U : set α,	hU : is_open U,	hsep : xor (x ∈ U) (y ∈ U),	z w : α,	hz : z ∈ V,	hw : w ∈ V,	hz' : z ∈ U,	hw' : w ∉ U,	uvne : (V ∩ Uᶜ).nonempty,	hV : V ∩ Uᶜ = V	⊢ V ⊆ Uᶜ
α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y,	U : set α,	hU : is_open U,	hsep : xor (x ∈ U) (y ∈ U)	⊢ ∀ (z w : α), z ∈ V → w ∈ V → z ∈ U → w ∉ U → false		α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y,	U : set α,	hU : is_open U,	hsep : xor (x ∈ U) (y ∈ U),	this : ∀ (z w : α), z ∈ V → w ∈ V → z ∈ U → w ∉ U → false	⊢ false
α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y,	U : set α,	hU : is_open U,	hsep : xor (x ∈ U) (y ∈ U),	z w : α,	hz : z ∈ V,	hw : w ∈ V,	hz' : z ∈ U,	hw' : w ∉ U,	uvne : (V ∩ Uᶜ).nonempty,	hV : V ∩ Uᶜ = V,	this : V ⊆ Uᶜ	⊢ false
α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y,	U : set α,	hU : is_open U,	hsep : xor (x ∈ U) (y ∈ U),	this : ∀ (z w : α), z ∈ V → w ∈ V → z ∈ U → w ∉ U → false	⊢ false
α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y,	U : set α,	hU : is_open U,	this : ∀ (z w : α), z ∈ V → w ∈ V → z ∈ U → w ∉ U → false,	hsep : x ∈ U ∧ y ∉ U	⊢ false		case or.inr	α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y,	U : set α,	hU : is_open U,	this : ∀ (z w : α), z ∈ V → w ∈ V → z ∈ U → w ∉ U → false,	hsep : y ∈ U ∧ x ∉ U	⊢ false
α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y,	U : set α,	hU : is_open U,	this : ∀ (z w : α), z ∈ V → w ∈ V → z ∈ U → w ∉ U → false,	hsep : x ∈ U ∧ y ∉ U	⊢ false
α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	hnt : ∃ (x y : α) (hx : x ∈ V) (hy : y ∈ V), x ≠ y	⊢ ∃ (x : α), x ∈ S ∧ is_closed {x}		α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	hnt : ¬∃ (x y : α) (hx : x ∈ V) (hy : y ∈ V), x ≠ y	⊢ ∃ (x : α), x ∈ S ∧ is_closed {x}
α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y,	U : set α,	hU : is_open U,	this : ∀ (z w : α), z ∈ V → w ∈ V → z ∈ U → w ∉ U → false,	hsep : y ∈ U ∧ x ∉ U	⊢ false
α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	hnt : ¬∃ (x y : α) (hx : x ∈ V) (hy : y ∈ V), x ≠ y	⊢ ∃ (x : α), x ∈ S ∧ is_closed {x}
α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	hnt : ∀ (x y : α), x ∈ V → y ∈ V → x = y	⊢ ∃ (x : α), x ∈ S ∧ is_closed {x}
α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	hnt : ∀ (x y : α), x ∈ V → y ∈ V → x = y,	z : α,	hz : z ∈ V	⊢ ∃ (x : α), x ∈ S ∧ is_closed {x}
α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	hnt : ∀ (x y : α), x ∈ V → y ∈ V → x = y,	z : α,	hz : z ∈ V	⊢ is_closed {z}
α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	hnt : ∀ (x y : α), x ∈ V → y ∈ V → x = y,	z : α,	hz : z ∈ V	⊢ {z} = V
α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	hnt : ∀ (x y : α), x ∈ V → y ∈ V → x = y,	z : α,	hz : z ∈ V,	x : α	⊢ x ∈ {z} ↔ x ∈ V
α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	hnt : ∀ (x y : α), x ∈ V → y ∈ V → x = y,	z : α,	hz : z ∈ V,	x : α	⊢ x = z ↔ x ∈ V
α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	hnt : ∀ (x y : α), x ∈ V → y ∈ V → x = y,	x : α,	hz : x ∈ V	⊢ x ∈ V
α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	hnt : ∀ (x y : α), x ∈ V → y ∈ V → x = y,	z : α,	hz : z ∈ V,	x : α	⊢ x = z → x ∈ V		α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	hnt : ∀ (x y : α), x ∈ V → y ∈ V → x = y,	z : α,	hz : z ∈ V,	x : α	⊢ x ∈ V → x = z
α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	hnt : ∀ (x y : α), x ∈ V → y ∈ V → x = y,	z : α,	hz : z ∈ V,	x : α	⊢ x = z → x ∈ V
α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	hnt : ∀ (x y : α), x ∈ V → y ∈ V → x = y,	z : α,	hz : z ∈ V,	x : α	⊢ x ∈ V → x = z
α : Type u,	_inst_1 : topological_space α,	_inst_2 : t2_space α	⊢ ∀ (s t : finset α), disjoint s t → separated ↑s ↑t
α : Type u,	_inst_1 : topological_space α,	_inst_2 : t2_space α,	a b : α,	ab : disjoint {a} {b}	⊢ separated ↑{a} ↑{b}
α : Type u,	_inst_1 : topological_space α,	_inst_2 : t2_space α,	a b : α,	ab : disjoint {a} {b}	⊢ ?m_2 ≠ ?m_3
α : Type u,	_inst_1 : topological_space α,	_inst_2 : t2_space α,	a b : α,	ab : disjoint {a} {b}	⊢ ?m_2 ∉ {?m_3}
α : Type u,	_inst_1 : topological_space α,	_inst_2 : t2_space α,	a b : α,	ab : disjoint {a} {b},	U V : set α,	oU : is_open U,	oV : is_open V,	aU : a ∈ U,	bV : b ∈ V,	UV : U ∩ V = ∅	⊢ separated ↑{a} ↑{b}
α : Type u,	_inst_1 : topological_space α,	_inst_2 : t2_space α,	a b : α,	ab : disjoint {a} {b},	U V : set α,	oU : is_open U,	oV : is_open V,	aU : a ∈ U,	bV : b ∈ V,	UV : U ∩ V = ∅	⊢ separated ↑{a} ↑{b}
α : Type u,	_inst_1 : topological_space α,	_inst_2 : t2_space α,	a b : α,	ab : disjoint {a} {b}	⊢ separated ↑{a} ↑{b}		α : Type u,	_inst_1 : topological_space α,	_inst_2 : t2_space α	⊢ ∀ {a b c : finset α}, (disjoint a c → separated ↑a ↑c) → (disjoint b c → separated ↑b ↑c) → disjoint (a ∪ b) c → separated ↑(a ∪ b) ↑c
α : Type u,	_inst_1 : topological_space α,	_inst_2 : t2_space α,	a b : α,	ab : disjoint {a} {b},	U V : set α,	oU : is_open U,	oV : is_open V,	aU : a ∈ U,	bV : b ∈ V,	UV : U ∩ V = ∅	⊢ ↑{a} ⊆ U
α : Type u,	_inst_1 : topological_space α,	_inst_2 : t2_space α,	a b : α,	ab : disjoint {a} {b},	U V : set α,	oU : is_open U,	oV : is_open V,	aU : a ∈ U,	bV : b ∈ V,	UV : U ∩ V = ∅	⊢ ↑{b} ⊆ V
α : Type u,	_inst_1 : topological_space α,	_inst_2 : t2_space α	⊢ ∀ {a b c : finset α}, (disjoint a c → separated ↑a ↑c) → (disjoint b c → separated ↑b ↑c) → disjoint (a ∪ b) c → separated ↑(a ∪ b) ↑c
α : Type u,	_inst_1 : topological_space α,	_inst_2 : t2_space α,	a b c : finset α,	ac : disjoint a c → separated ↑a ↑c,	bc : disjoint b c → separated ↑b ↑c,	d : disjoint (a ∪ b) c	⊢ separated ↑(a ∪ b) ↑c
α : Type u,	_inst_1 : topological_space α,	_inst_2 : t2_space α,	a b c : finset α,	ac : disjoint a c → separated ↑a ↑c,	bc : disjoint b c → separated ↑b ↑c,	d : disjoint (a ∪ b) c	⊢ disjoint b c
α : Type u,	_inst_1 : topological_space α,	_inst_3 : t2_space α,	s : set α,	hs : is_compact s,	x : α,	hx : x ∈ sᶜ	⊢ s ∩ {x} = ∅
α : Type u,	_inst_1 : topological_space α,	_inst_3 : t2_space α,	s : set α,	hs : is_compact s,	x : α,	hx : x ∈ sᶜ,	_let_match : (∃ (u v : set α), is_open u ∧ is_open v ∧ s ⊆ u ∧ {x} ⊆ v ∧ u ∩ v = ∅) → (∃ (t : set α) (H : t ⊆ sᶜ), is_open t ∧ x ∈ t),	u v : set α,	uo : is_open u,	vo : is_open v,	su : s ⊆ u,	xv : {x} ⊆ v,	uv : u ∩ v = ∅,	this : v ⊆ sᶜ	⊢ x ∈ v
α : Type u,	_inst_1 : topological_space α,	_inst_2 : regular_space α,	x y : α,	hxy : x ≠ y,	_let_match : (∃ (u v : set α), is_open u ∧ is_open v ∧ x ∈ u ∧ y ∈ v ∧ u ∩ v = ∅) → (∃ (U V : set α), is_open U ∧ is_open V ∧ closure U ∩ closure V = ∅ ∧ x ∈ U ∧ y ∈ V),	U V : set α,	hU : is_open U,	hV : is_open V,	hh_1 : x ∈ U,	hh_2 : y ∈ V,	hUV : U ∩ V = ∅,	hxcV : ¬x ∉ interior Vᶜ := not_not.mpr (interior_maximal (set.subset_compl_iff_disjoint.mpr hUV) hU hh_1)	⊢ ?m_2 ∉ closure ?m_4
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.limits.has_colimits C,	X : Top	⊢ category_theory.limits.has_colimits ((topological_space.opens ↥X)ᵒᵖ ⥤ C)
C : Type u,	_inst_1 : category_theory.category C,	_inst_2 : category_theory.limits.has_colimits C,	X : Top	⊢ category_theory.limits.has_colimits (Top.presheaf C X)
ι : Type u_1,	X : Type u_2,	_inst_1 : topological_space X,	_inst_2 : normal_space X,	u : ι → set X,	s : set X,	hs : is_closed s,	uo : ∀ (i : ι), is_open (u i),	uf : ∀ (x : X), x ∈ s → {i : ι | x ∈ u i}.finite,	us : s ⊆ ⋃ (i : ι), u i	⊢ ∃ (v : ι → set X), s ⊆ set.Union v ∧ (∀ (i : ι), is_open (v i)) ∧ ∀ (i : ι), closure (v i) ⊆ u i
ι : Type u_1,	X : Type u_2,	_inst_1 : topological_space X,	_inst_2 : normal_space X,	u : ι → set X,	s : set X,	hs : is_closed s,	uo : ∀ (i : ι), is_open (u i),	uf : ∀ (x : X), x ∈ s → {i : ι | x ∈ u i}.finite,	us : s ⊆ ⋃ (i : ι), u i,	_inst : Π (a : Prop), decidable a	⊢ ∃ (v : ι → set X), s ⊆ set.Union v ∧ (∀ (i : ι), is_open (v i)) ∧ ∀ (i : ι), closure (v i) ⊆ u i
ι : Type u_1,	X : Type u_2,	_inst_1 : topological_space X,	_inst_2 : normal_space X,	u : ι → set X,	s : set X,	hs : is_closed s,	uo : ∀ (i : ι), is_open (u i),	uf : ∀ (x : X), x ∈ s → {i : ι | x ∈ u i}.finite,	us : s ⊆ ⋃ (i : ι), u i,	_inst : Π (a : Prop), decidable a,	_inst_3 : nonempty (shrinking_lemma.partial_refinement u s)	⊢ ∃ (v : ι → set X), s ⊆ set.Union v ∧ (∀ (i : ι), is_open (v i)) ∧ ∀ (i : ι), closure (v i) ⊆ u i
ι : Type u_1,	X : Type u_2,	_inst_1 : topological_space X,	_inst_2 : normal_space X,	u : ι → set X,	s : set X,	hs : is_closed s,	uo : ∀ (i : ι), is_open (u i),	uf : ∀ (x : X), x ∈ s → {i : ι | x ∈ u i}.finite,	us : s ⊆ ⋃ (i : ι), u i,	_inst : Π (a : Prop), decidable a,	_inst_3 : nonempty (shrinking_lemma.partial_refinement u s)	⊢ ∀ (c : set (shrinking_lemma.partial_refinement u s)), zorn.chain has_le.le c → c.nonempty → (∃ (ub : shrinking_lemma.partial_refinement u s), ∀ (v : shrinking_lemma.partial_refinement u s), v ∈ c → v ≤ ub)		ι : Type u_1,	X : Type u_2,	_inst_1 : topological_space X,	_inst_2 : normal_space X,	u : ι → set X,	s : set X,	hs : is_closed s,	uo : ∀ (i : ι), is_open (u i),	uf : ∀ (x : X), x ∈ s → {i : ι | x ∈ u i}.finite,	us : s ⊆ ⋃ (i : ι), u i,	_inst : Π (a : Prop), decidable a,	_inst_3 : nonempty (shrinking_lemma.partial_refinement u s),	this : ∀ (c : set (shrinking_lemma.partial_refinement u s)), zorn.chain has_le.le c → c.nonempty → (∃ (ub : shrinking_lemma.partial_refinement u s), ∀ (v : shrinking_lemma.partial_refinement u s), v ∈ c → v ≤ ub)	⊢ ∃ (v : ι → set X), s ⊆ set.Union v ∧ (∀ (i : ι), is_open (v i)) ∧ ∀ (i : ι), closure (v i) ⊆ u i
ι : Type u_1,	X : Type u_2,	_inst_1 : topological_space X,	_inst_2 : normal_space X,	u : ι → set X,	s : set X,	hs : is_closed s,	uo : ∀ (i : ι), is_open (u i),	uf : ∀ (x : X), x ∈ s → {i : ι | x ∈ u i}.finite,	us : s ⊆ ⋃ (i : ι), u i,	_inst : Π (a : Prop), decidable a,	_inst_3 : nonempty (shrinking_lemma.partial_refinement u s),	this : ∀ (c : set (shrinking_lemma.partial_refinement u s)), zorn.chain has_le.le c → c.nonempty → (∃ (ub : shrinking_lemma.partial_refinement u s), ∀ (v : shrinking_lemma.partial_refinement u s), v ∈ c → v ≤ ub)	⊢ ∃ (v : ι → set X), s ⊆ set.Union v ∧ (∀ (i : ι), is_open (v i)) ∧ ∀ (i : ι), closure (v i) ⊆ u i
ι : Type u_1,	X : Type u_2,	_inst_1 : topological_space X,	_inst_2 : normal_space X,	u : ι → set X,	s : set X,	hs : is_closed s,	uo : ∀ (i : ι), is_open (u i),	uf : ∀ (x : X), x ∈ s → {i : ι | x ∈ u i}.finite,	us : s ⊆ ⋃ (i : ι), u i,	_inst : Π (a : Prop), decidable a,	_inst_3 : nonempty (shrinking_lemma.partial_refinement u s),	this : ∀ (c : set (shrinking_lemma.partial_refinement u s)), zorn.chain has_le.le c → c.nonempty → (∃ (ub : shrinking_lemma.partial_refinement u s), ∀ (v : shrinking_lemma.partial_refinement u s), v ∈ c → v ≤ ub),	v : shrinking_lemma.partial_refinement u s,	hv : ∀ (a : shrinking_lemma.partial_refinement u s), v ≤ a → a = v	⊢ ∃ (v : ι → set X), s ⊆ set.Union v ∧ (∀ (i : ι), is_open (v i)) ∧ ∀ (i : ι), closure (v i) ⊆ u i
ι : Type u_1,	X : Type u_2,	_inst_1 : topological_space X,	_inst_2 : normal_space X,	u : ι → set X,	s : set X,	hs : is_closed s,	uo : ∀ (i : ι), is_open (u i),	uf : ∀ (x : X), x ∈ s → {i : ι | x ∈ u i}.finite,	us : s ⊆ ⋃ (i : ι), u i,	_inst : Π (a : Prop), decidable a,	_inst_3 : nonempty (shrinking_lemma.partial_refinement u s),	this : ∀ (c : set (shrinking_lemma.partial_refinement u s)), zorn.chain has_le.le c → c.nonempty → (∃ (ub : shrinking_lemma.partial_refinement u s), ∀ (v : shrinking_lemma.partial_refinement u s), v ∈ c → v ≤ ub),	v : shrinking_lemma.partial_refinement u s,	hv : ∀ (a : shrinking_lemma.partial_refinement u s), v ≤ a → a = v,	this : ∀ (i : ι), i ∈ v.carrier	⊢ ∃ (v : ι → set X), s ⊆ set.Union v ∧ (∀ (i : ι), is_open (v i)) ∧ ∀ (i : ι), closure (v i) ⊆ u i		ι : Type u_1,	X : Type u_2,	_inst_1 : topological_space X,	_inst_2 : normal_space X,	u : ι → set X,	s : set X,	hs : is_closed s,	uo : ∀ (i : ι), is_open (u i),	uf : ∀ (x : X), x ∈ s → {i : ι | x ∈ u i}.finite,	us : s ⊆ ⋃ (i : ι), u i,	_inst : Π (a : Prop), decidable a,	_inst_3 : nonempty (shrinking_lemma.partial_refinement u s),	this : ∀ (c : set (shrinking_lemma.partial_refinement u s)), zorn.chain has_le.le c → c.nonempty → (∃ (ub : shrinking_lemma.partial_refinement u s), ∀ (v : shrinking_lemma.partial_refinement u s), v ∈ c → v ≤ ub),	v : shrinking_lemma.partial_refinement u s,	hv : ∀ (a : shrinking_lemma.partial_refinement u s), v ≤ a → a = v	⊢ ∀ (i : ι), i ∈ v.carrier
ι : Type u_1,	X : Type u_2,	_inst_1 : topological_space X,	_inst_2 : normal_space X,	u : ι → set X,	s : set X,	hs : is_closed s,	uo : ∀ (i : ι), is_open (u i),	uf : ∀ (x : X), x ∈ s → {i : ι | x ∈ u i}.finite,	us : s ⊆ ⋃ (i : ι), u i,	_inst : Π (a : Prop), decidable a,	_inst_3 : nonempty (shrinking_lemma.partial_refinement u s),	this : ∀ (c : set (shrinking_lemma.partial_refinement u s)), zorn.chain has_le.le c → c.nonempty → (∃ (ub : shrinking_lemma.partial_refinement u s), ∀ (v : shrinking_lemma.partial_refinement u s), v ∈ c → v ≤ ub),	v : shrinking_lemma.partial_refinement u s,	hv : ∀ (a : shrinking_lemma.partial_refinement u s), v ≤ a → a = v	⊢ ∀ (i : ι), i ∈ v.carrier
ι : Type u_1,	X : Type u_2,	_inst_1 : topological_space X,	_inst_2 : normal_space X,	u : ι → set X,	s : set X,	hs : is_closed s,	uo : ∀ (i : ι), is_open (u i),	uf : ∀ (x : X), x ∈ s → {i : ι | x ∈ u i}.finite,	us : s ⊆ ⋃ (i : ι), u i,	_inst : Π (a : Prop), decidable a,	_inst_3 : nonempty (shrinking_lemma.partial_refinement u s),	this : ∀ (c : set (shrinking_lemma.partial_refinement u s)), zorn.chain has_le.le c → c.nonempty → (∃ (ub : shrinking_lemma.partial_refinement u s), ∀ (v : shrinking_lemma.partial_refinement u s), v ∈ c → v ≤ ub),	v : shrinking_lemma.partial_refinement u s,	hv : ∃ (i : ι), i ∉ v.carrier	⊢ ∃ (a : shrinking_lemma.partial_refinement u s), v ≤ a ∧ a ≠ v
ι : Type u_1,	X : Type u_2,	_inst_1 : topological_space X,	_inst_2 : normal_space X,	u : ι → set X,	s : set X,	hs : is_closed s,	uo : ∀ (i : ι), is_open (u i),	uf : ∀ (x : X), x ∈ s → {i : ι | x ∈ u i}.finite,	us : s ⊆ ⋃ (i : ι), u i,	_inst : Π (a : Prop), decidable a,	_inst_3 : nonempty (shrinking_lemma.partial_refinement u s),	this : ∀ (c : set (shrinking_lemma.partial_refinement u s)), zorn.chain has_le.le c → c.nonempty → (∃ (ub : shrinking_lemma.partial_refinement u s), ∀ (v : shrinking_lemma.partial_refinement u s), v ∈ c → v ≤ ub),	v : shrinking_lemma.partial_refinement u s,	i : ι,	hi : i ∉ v.carrier	⊢ ∃ (a : shrinking_lemma.partial_refinement u s), v ≤ a ∧ a ≠ v
ι : Type u_1,	X : Type u_2,	_inst_1 : topological_space X,	_inst_2 : normal_space X,	u : ι → set X,	s : set X,	hs : is_closed s,	uo : ∀ (i : ι), is_open (u i),	uf : ∀ (x : X), x ∈ s → {i : ι | x ∈ u i}.finite,	us : s ⊆ ⋃ (i : ι), u i,	_inst : Π (a : Prop), decidable a,	_inst_3 : nonempty (shrinking_lemma.partial_refinement u s),	this : ∀ (c : set (shrinking_lemma.partial_refinement u s)), zorn.chain has_le.le c → c.nonempty → (∃ (ub : shrinking_lemma.partial_refinement u s), ∀ (v : shrinking_lemma.partial_refinement u s), v ∈ c → v ≤ ub),	v : shrinking_lemma.partial_refinement u s,	i : ι,	hi : i ∉ v.carrier,	v' : shrinking_lemma.partial_refinement u s,	hlt : v < v'	⊢ ∃ (a : shrinking_lemma.partial_refinement u s), v ≤ a ∧ a ≠ v
α : Type u,	b : ultrafilter α	⊢ filter.comap has_pure.pure (𝓝 b) ≤ ↑b
α : Type u,	b : ultrafilter α	⊢ filter.comap has_pure.pure (⨅ (s : set (ultrafilter α)) (H : s ∈ {s : set (ultrafilter α) | b ∈ s ∧ s ∈ ultrafilter_basis α}), filter.principal s) ≤ ↑b
α : Type u,	b : ultrafilter α	⊢ (⨅ (i : set (ultrafilter α)) (i_1 : i ∈ {s : set (ultrafilter α) | b ∈ s ∧ s ∈ ultrafilter_basis α}), filter.principal (has_pure.pure ⁻¹' i)) ≤ ↑b
α : Type u,	b : ultrafilter α,	s : set α,	hs : s ∈ ↑b	⊢ s ∈ ⨅ (i : set (ultrafilter α)) (i_1 : i ∈ {s : set (ultrafilter α) | b ∈ s ∧ s ∈ ultrafilter_basis α}), filter.principal (has_pure.pure ⁻¹' i)
α : Type u,	b : ultrafilter α,	s : set α,	hs : s ∈ ↑b	⊢ (⨅ (i : set (ultrafilter α)) (i_1 : i ∈ {s : set (ultrafilter α) | b ∈ s ∧ s ∈ ultrafilter_basis α}), filter.principal (has_pure.pure ⁻¹' i)) ≤ filter.principal s
α : Type u,	b : ultrafilter α,	s : set α,	hs : s ∈ ↑b	⊢ (⨅ (i : {u : ultrafilter α | s ∈ u} ∈ {s : set (ultrafilter α) | b ∈ s ∧ s ∈ ultrafilter_basis α}), filter.principal (has_pure.pure ⁻¹' {u : ultrafilter α | s ∈ u})) ≤ filter.principal s
α : Type u,	b : ultrafilter α,	s : set α,	hs : s ∈ ↑b	⊢ filter.principal (has_pure.pure ⁻¹' {u : ultrafilter α | s ∈ u}) ≤ filter.principal s
α : Type u	⊢ topological_space.induced has_pure.pure ultrafilter.topological_space = ⊥
α : Type u	⊢ ∀ (x : α), (topological_space.induced has_pure.pure ultrafilter.topological_space).is_open {x}
α : Type u,	x : α	⊢ (topological_space.induced has_pure.pure ultrafilter.topological_space).is_open {x}
α : Type u,	x : α	⊢ has_pure.pure ⁻¹' {u : ultrafilter α | {x} ∈ u} = {x}
α : Type u,	_inst_1 : topological_space α,	ι : Type v,	hι : nonempty ι,	Z : ι → set α,	hZd : directed superset Z,	hZn : ∀ (i : ι), (Z i).nonempty,	hZc : ∀ (i : ι), is_compact (Z i),	hZcl : ∀ (i : ι), is_closed (Z i)	⊢ (⋂ (i : ι), Z i).nonempty
α : Type u,	_inst_1 : topological_space α,	ι : Type v,	hι : nonempty ι,	Z : ι → set α,	hZd : directed superset Z,	hZn : ∀ (i : ι), (Z i).nonempty,	hZc : ∀ (i : ι), is_compact (Z i),	hZcl : ∀ (i : ι), is_closed (Z i)	⊢ ι → (⋂ (i : ι), Z i).nonempty
α : Type u,	_inst_1 : topological_space α,	ι : Type v,	hι : nonempty ι,	Z : ι → set α,	hZd : directed superset Z,	hZn : ∀ (i : ι), (Z i).nonempty,	hZc : ∀ (i : ι), is_compact (Z i),	hZcl : ∀ (i : ι), is_closed (Z i),	i₀ : ι	⊢ (⋂ (i : ι), Z i).nonempty
α : Type u,	_inst_1 : topological_space α,	ι : Type v,	hι : nonempty ι,	Z : ι → set α,	hZd : directed superset Z,	hZn : ∀ (i : ι), (Z i).nonempty,	hZc : ∀ (i : ι), is_compact (Z i),	hZcl : ∀ (i : ι), is_closed (Z i),	i₀ : ι,	Z' : ι → set α := λ (i : ι), Z i ∩ Z i₀	⊢ (⋂ (i : ι), Z i).nonempty
α : Type u,	_inst_1 : topological_space α,	ι : Type v,	hι : nonempty ι,	Z : ι → set α,	hZd : directed superset Z,	hZn : ∀ (i : ι), (Z i).nonempty,	hZc : ∀ (i : ι), is_compact (Z i),	hZcl : ∀ (i : ι), is_closed (Z i),	i₀ : ι,	Z' : ι → set α := λ (i : ι), Z i ∩ Z i₀,	this : (⋂ (i : ι), Z' i).nonempty	⊢ (⋂ (i : ι), Z i).nonempty
α : Type u,	_inst_1 : topological_space α,	ι : Type v,	hι : nonempty ι,	Z : ι → set α,	hZd : directed superset Z,	hZn : ∀ (i : ι), (Z i).nonempty,	hZc : ∀ (i : ι), is_compact (Z i),	hZcl : ∀ (i : ι), is_closed (Z i),	i₀ : ι,	Z' : ι → set α := λ (i : ι), Z i ∩ Z i₀,	this : (⋂ (i : ι), Z' i).nonempty	⊢ (⋂ (i : ι), Z i).nonempty		α : Type u,	_inst_1 : topological_space α,	ι : Type v,	hι : nonempty ι,	Z : ι → set α,	hZd : directed superset Z,	hZn : ∀ (i : ι), (Z i).nonempty,	hZc : ∀ (i : ι), is_compact (Z i),	hZcl : ∀ (i : ι), is_closed (Z i),	i₀ : ι,	Z' : ι → set α := λ (i : ι), Z i ∩ Z i₀	⊢ (⋂ (i : ι), Z' i).nonempty
α : Type u,	_inst_1 : topological_space α,	ι : Type v,	hι : nonempty ι,	Z : ι → set α,	hZd : directed superset Z,	hZn : ∀ (i : ι), (Z i).nonempty,	hZc : ∀ (i : ι), is_compact (Z i),	hZcl : ∀ (i : ι), is_closed (Z i),	i₀ : ι,	Z' : ι → set α := λ (i : ι), Z i ∩ Z i₀	⊢ (⋂ (i : ι), Z' i).nonempty
α : Type u,	_inst_1 : topological_space α,	ι : Type v,	hι : nonempty ι,	Z : ι → set α,	hZd : directed superset Z,	hZn : ∀ (i : ι), (Z i).nonempty,	hZc : ∀ (i : ι), is_compact (Z i),	hZcl : ∀ (i : ι), is_closed (Z i),	i₀ : ι,	Z' : ι → set α := λ (i : ι), Z i ∩ Z i₀	⊢ (⋂ (i : ι), Z' i) ≠ ∅
α : Type u,	_inst_1 : topological_space α,	ι : Type v,	hι : nonempty ι,	Z : ι → set α,	hZd : directed superset Z,	hZn : ∀ (i : ι), (Z i).nonempty,	hZc : ∀ (i : ι), is_compact (Z i),	hZcl : ∀ (i : ι), is_closed (Z i),	i₀ : ι,	Z' : ι → set α := λ (i : ι), Z i ∩ Z i₀,	H : (⋂ (i : ι), Z' i) = ∅	⊢ false
α : Type u,	_inst_1 : topological_space α,	ι : Type v,	hι : nonempty ι,	Z : ι → set α,	hZd : directed superset Z,	hZn : ∀ (i : ι), (Z i).nonempty,	hZc : ∀ (i : ι), is_compact (Z i),	hZcl : ∀ (i : ι), is_closed (Z i),	i₀ : ι,	Z' : ι → set α := λ (i : ι), Z i ∩ Z i₀,	H : (⋂ (i : ι), Z' i) = ∅	⊢ ∃ (t : finset ι), (Z i₀ ∩ ⋂ (i : ι) (H : i ∈ t), Z' i) = ∅		α : Type u,	_inst_1 : topological_space α,	ι : Type v,	hι : nonempty ι,	Z : ι → set α,	hZd : directed superset Z,	hZn : ∀ (i : ι), (Z i).nonempty,	hZc : ∀ (i : ι), is_compact (Z i),	hZcl : ∀ (i : ι), is_closed (Z i),	i₀ : ι,	Z' : ι → set α := λ (i : ι), Z i ∩ Z i₀,	H : (⋂ (i : ι), Z' i) = ∅,	t : finset ι,	ht : (Z i₀ ∩ ⋂ (i : ι) (H : i ∈ t), Z' i) = ∅	⊢ false
α : Type u,	_inst_1 : topological_space α,	ι : Type v,	hι : nonempty ι,	Z : ι → set α,	hZd : directed superset Z,	hZn : ∀ (i : ι), (Z i).nonempty,	hZc : ∀ (i : ι), is_compact (Z i),	hZcl : ∀ (i : ι), is_closed (Z i),	i₀ : ι,	Z' : ι → set α := λ (i : ι), Z i ∩ Z i₀,	H : (⋂ (i : ι), Z' i) = ∅	⊢ (Z i₀ ∩ ⋂ (i : ι), Z' i) = ∅
α : Type u,	_inst_1 : topological_space α,	ι : Type v,	hι : nonempty ι,	Z : ι → set α,	hZd : directed superset Z,	hZn : ∀ (i : ι), (Z i).nonempty,	hZc : ∀ (i : ι), is_compact (Z i),	hZcl : ∀ (i : ι), is_closed (Z i),	i₀ : ι,	Z' : ι → set α := λ (i : ι), Z i ∩ Z i₀,	H : (⋂ (i : ι), Z' i) = ∅,	t : finset ι,	ht : (Z i₀ ∩ ⋂ (i : ι) (H : i ∈ t), Z' i) = ∅	⊢ false
α : Type u,	_inst_1 : topological_space α,	ι : Type v,	hι : nonempty ι,	Z : ι → set α,	hZd : directed superset Z,	hZn : ∀ (i : ι), (Z i).nonempty,	hZc : ∀ (i : ι), is_compact (Z i),	hZcl : ∀ (i : ι), is_closed (Z i),	i₀ : ι,	Z' : ι → set α := λ (i : ι), Z i ∩ Z i₀,	H : (⋂ (i : ι), Z' i) = ∅,	t : finset ι,	ht : (Z i₀ ∩ ⋂ (i : ι) (H : i ∈ t), Z' i) = ∅	⊢ ∃ (i₁ : ι), Z i₁ ⊆ Z i₀ ∧ ∀ (i : ι), i ∈ t → Z i₁ ⊆ Z' i
α : Type u,	_inst_1 : topological_space α,	ι : Type v,	hι : nonempty ι,	Z : ι → set α,	hZd : directed superset Z,	hZn : ∀ (i : ι), (Z i).nonempty,	hZc : ∀ (i : ι), is_compact (Z i),	hZcl : ∀ (i : ι), is_closed (Z i),	i₀ : ι,	Z' : ι → set α := λ (i : ι), Z i ∩ Z i₀,	H : (⋂ (i : ι), Z' i) = ∅,	t : finset ι,	ht : (Z i₀ ∩ ⋂ (i : ι) (H : i ∈ t), Z' i) = ∅,	i : ι,	hi : ∀ (i_1 : ι), i_1 ∈ t → Z i_1 ⊇ Z i	⊢ ∃ (i₁ : ι), Z i₁ ⊆ Z i₀ ∧ ∀ (i : ι), i ∈ t → Z i₁ ⊆ Z' i
α : Type u,	_inst_1 : topological_space α,	ι : Type v,	hι : nonempty ι,	Z : ι → set α,	hZd : directed superset Z,	hZn : ∀ (i : ι), (Z i).nonempty,	hZc : ∀ (i : ι), is_compact (Z i),	hZcl : ∀ (i : ι), is_closed (Z i),	i₀ : ι,	Z' : ι → set α := λ (i : ι), Z i ∩ Z i₀,	H : (⋂ (i : ι), Z' i) = ∅,	t : finset ι,	ht : (Z i₀ ∩ ⋂ (i : ι) (H : i ∈ t), Z' i) = ∅,	i : ι,	hi : ∀ (i_1 : ι), i_1 ∈ t → Z i_1 ⊇ Z i,	i₁ : ι,	hi₁ : Z i ⊇ Z i₁,	hi₁₀ : Z i₀ ⊇ Z i₁	⊢ ∃ (i₁ : ι), Z i₁ ⊆ Z i₀ ∧ ∀ (i : ι), i ∈ t → Z i₁ ⊆ Z' i
α : Type u,	_inst_1 : topological_space α,	ι : Type v,	hι : nonempty ι,	Z : ι → set α,	hZd : directed superset Z,	hZn : ∀ (i : ι), (Z i).nonempty,	hZc : ∀ (i : ι), is_compact (Z i),	hZcl : ∀ (i : ι), is_closed (Z i),	i₀ : ι,	Z' : ι → set α := λ (i : ι), Z i ∩ Z i₀,	H : (⋂ (i : ι), Z' i) = ∅,	t : finset ι,	ht : (Z i₀ ∩ ⋂ (i : ι) (H : i ∈ t), Z' i) = ∅,	i : ι,	hi : ∀ (i_1 : ι), i_1 ∈ t → Z i_1 ⊇ Z i,	i₁ : ι,	hi₁ : Z i ⊇ Z i₁,	hi₁₀ : Z i₀ ⊇ Z i₁	⊢ ∀ (i : ι), i ∈ t → Z i₁ ⊆ Z' i
α : Type u,	_inst_1 : topological_space α,	ι : Type v,	hι : nonempty ι,	Z : ι → set α,	hZd : directed superset Z,	hZn : ∀ (i : ι), (Z i).nonempty,	hZc : ∀ (i : ι), is_compact (Z i),	hZcl : ∀ (i : ι), is_closed (Z i),	i₀ : ι,	Z' : ι → set α := λ (i : ι), Z i ∩ Z i₀,	H : (⋂ (i : ι), Z' i) = ∅,	t : finset ι,	ht : (Z i₀ ∩ ⋂ (i : ι) (H : i ∈ t), Z' i) = ∅	⊢ ∃ (i₁ : ι), Z i₁ ⊆ Z i₀ ∧ ∀ (i : ι), i ∈ t → Z i₁ ⊆ Z' i		α : Type u,	_inst_1 : topological_space α,	ι : Type v,	hι : nonempty ι,	Z : ι → set α,	hZd : directed superset Z,	hZn : ∀ (i : ι), (Z i).nonempty,	hZc : ∀ (i : ι), is_compact (Z i),	hZcl : ∀ (i : ι), is_closed (Z i),	i₀ : ι,	Z' : ι → set α := λ (i : ι), Z i ∩ Z i₀,	H : (⋂ (i : ι), Z' i) = ∅,	t : finset ι,	ht : (Z i₀ ∩ ⋂ (i : ι) (H : i ∈ t), Z' i) = ∅,	i₁ : ι,	hi₁ : Z i₁ ⊆ Z i₀ ∧ ∀ (i : ι), i ∈ t → Z i₁ ⊆ Z' i	⊢ false
α : Type u,	_inst_1 : topological_space α,	ι : Type v,	hι : nonempty ι,	Z : ι → set α,	hZd : directed superset Z,	hZn : ∀ (i : ι), (Z i).nonempty,	hZc : ∀ (i : ι), is_compact (Z i),	hZcl : ∀ (i : ι), is_closed (Z i),	i₀ : ι,	Z' : ι → set α := λ (i : ι), Z i ∩ Z i₀,	H : (⋂ (i : ι), Z' i) = ∅,	t : finset ι,	ht : (Z i₀ ∩ ⋂ (i : ι) (H : i ∈ t), Z' i) = ∅,	i : ι,	hi : ∀ (i_1 : ι), i_1 ∈ t → Z i_1 ⊇ Z i,	i₁ : ι,	hi₁ : Z i ⊇ Z i₁,	hi₁₀ : Z i₀ ⊇ Z i₁,	j : ι,	hj : j ∈ t	⊢ Z i₁ ⊆ Z' j
α : Type u,	_inst_1 : topological_space α,	ι : Type v,	hι : nonempty ι,	Z : ι → set α,	hZd : directed superset Z,	hZn : ∀ (i : ι), (Z i).nonempty,	hZc : ∀ (i : ι), is_compact (Z i),	hZcl : ∀ (i : ι), is_closed (Z i),	i₀ : ι,	Z' : ι → set α := λ (i : ι), Z i ∩ Z i₀,	H : (⋂ (i : ι), Z' i) = ∅,	t : finset ι,	ht : (Z i₀ ∩ ⋂ (i : ι) (H : i ∈ t), Z' i) = ∅,	i₁ : ι,	hi₁ : Z i₁ ⊆ Z i₀ ∧ ∀ (i : ι), i ∈ t → Z i₁ ⊆ Z' i	⊢ false
α : Type u,	_inst_1 : topological_space α,	ι : Type v,	hι : nonempty ι,	Z : ι → set α,	hZd : directed superset Z,	hZn : ∀ (i : ι), (Z i).nonempty,	hZc : ∀ (i : ι), is_compact (Z i),	hZcl : ∀ (i : ι), is_closed (Z i),	i₀ : ι,	Z' : ι → set α := λ (i : ι), Z i ∩ Z i₀,	H : (⋂ (i : ι), Z' i) = ∅,	t : finset ι,	ht : (Z i₀ ∩ ⋂ (i : ι) (H : i ∈ t), Z' i) = ∅,	i₁ : ι,	hi₁ : Z i₁ ⊆ Z i₀ ∧ ∀ (i : ι), i ∈ t → Z i₁ ⊆ Z' i,	this : (Z i₀ ∩ ⋂ (i : ι) (H : i ∈ t), Z' i) ≠ ∅	⊢ false
α : Type u,	_inst_1 : topological_space α,	ι : Type v,	hι : nonempty ι,	Z : ι → set α,	hZd : directed superset Z,	hZn : ∀ (i : ι), (Z i).nonempty,	hZc : ∀ (i : ι), is_compact (Z i),	hZcl : ∀ (i : ι), is_closed (Z i),	i₀ : ι,	Z' : ι → set α := λ (i : ι), Z i ∩ Z i₀,	H : (⋂ (i : ι), Z' i) = ∅,	t : finset ι,	ht : (Z i₀ ∩ ⋂ (i : ι) (H : i ∈ t), Z' i) = ∅,	i₁ : ι,	hi₁ : Z i₁ ⊆ Z i₀ ∧ ∀ (i : ι), i ∈ t → Z i₁ ⊆ Z' i,	this : (Z i₀ ∩ ⋂ (i : ι) (H : i ∈ t), Z' i).nonempty	⊢ false		α : Type u,	_inst_1 : topological_space α,	ι : Type v,	hι : nonempty ι,	Z : ι → set α,	hZd : directed superset Z,	hZn : ∀ (i : ι), (Z i).nonempty,	hZc : ∀ (i : ι), is_compact (Z i),	hZcl : ∀ (i : ι), is_closed (Z i),	i₀ : ι,	Z' : ι → set α := λ (i : ι), Z i ∩ Z i₀,	H : (⋂ (i : ι), Z' i) = ∅,	t : finset ι,	ht : (Z i₀ ∩ ⋂ (i : ι) (H : i ∈ t), Z' i) = ∅,	i₁ : ι,	hi₁ : Z i₁ ⊆ Z i₀ ∧ ∀ (i : ι), i ∈ t → Z i₁ ⊆ Z' i	⊢ (Z i₀ ∩ ⋂ (i : ι) (H : i ∈ t), Z' i).nonempty
α : Type u,	_inst_1 : topological_space α,	ι : Type v,	hι : nonempty ι,	Z : ι → set α,	hZd : directed superset Z,	hZn : ∀ (i : ι), (Z i).nonempty,	hZc : ∀ (i : ι), is_compact (Z i),	hZcl : ∀ (i : ι), is_closed (Z i),	i₀ : ι,	Z' : ι → set α := λ (i : ι), Z i ∩ Z i₀,	H : (⋂ (i : ι), Z' i) = ∅,	t : finset ι,	ht : (Z i₀ ∩ ⋂ (i : ι) (H : i ∈ t), Z' i) = ∅,	i₁ : ι,	hi₁ : Z i₁ ⊆ Z i₀ ∧ ∀ (i : ι), i ∈ t → Z i₁ ⊆ Z' i,	this : (Z i₀ ∩ ⋂ (i : ι) (H : i ∈ t), Z' i).nonempty	⊢ false
α : Type u,	_inst_1 : topological_space α,	ι : Type v,	hι : nonempty ι,	Z : ι → set α,	hZd : directed superset Z,	hZn : ∀ (i : ι), (Z i).nonempty,	hZc : ∀ (i : ι), is_compact (Z i),	hZcl : ∀ (i : ι), is_closed (Z i),	i₀ : ι,	Z' : ι → set α := λ (i : ι), Z i ∩ Z i₀,	H : (⋂ (i : ι), Z' i) = ∅,	t : finset ι,	ht : (Z i₀ ∩ ⋂ (i : ι) (H : i ∈ t), Z' i) = ∅,	i₁ : ι,	hi₁ : Z i₁ ⊆ Z i₀ ∧ ∀ (i : ι), i ∈ t → Z i₁ ⊆ Z' i	⊢ (Z i₀ ∩ ⋂ (i : ι) (H : i ∈ t), Z' i).nonempty
α : Type u,	_inst_1 : topological_space α,	ι : Type v,	hι : nonempty ι,	Z : ι → set α,	hZd : directed superset Z,	hZn : ∀ (i : ι), (Z i).nonempty,	hZc : ∀ (i : ι), is_compact (Z i),	hZcl : ∀ (i : ι), is_closed (Z i),	i₀ : ι,	Z' : ι → set α := λ (i : ι), Z i ∩ Z i₀,	H : (⋂ (i : ι), Z' i) = ∅,	t : finset ι,	ht : (Z i₀ ∩ ⋂ (i : ι) (H : i ∈ t), Z' i) = ∅,	i₁ : ι,	hi₁ : Z i₁ ⊆ Z i₀ ∧ ∀ (i : ι), i ∈ t → Z i₁ ⊆ Z' i	⊢ Z i₁ ⊆ Z i₀ ∩ ⋂ (i : ι) (H : i ∈ t), Z' i
α : Type u,	_inst_1 : topological_space α,	s t : set α,	hs : is_compact s,	ht : is_compact t	⊢ is_compact (s ∪ t)
α : Type u,	_inst_1 : topological_space α,	s t : set α,	hs : is_compact s,	ht : is_compact t	⊢ is_compact (⋃ (b : bool), cond b s t)
α : Type u,	_inst_1 : topological_space α,	s t : set α,	hs : is_compact s,	ht : is_compact t	⊢ is_compact (s ∪ t)
α : Type u,	_inst_1 : topological_space α,	s t : set α,	hs : is_compact s,	ht : is_compact t,	b : bool	⊢ is_compact (cond b s t)
α : Type u,	_inst_1 : topological_space α,	s t : set α,	hs : is_compact s,	ht : is_compact t,	b : bool	⊢ is_compact (cond b s t)
α : Type u,	_inst_1 : topological_space α,	s t : set α,	hs : is_compact s,	ht : is_compact t	⊢ is_compact (cond bool.ff s t)
α : Type u,	_inst_1 : topological_space α,	s t : set α,	hs : is_compact s,	ht : is_compact t	⊢ is_compact (cond bool.tt s t)
α : Type u,	β : Type v,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	s : set α,	t : set β,	hs : is_compact s,	ht : is_compact t	⊢ is_compact (s.prod t)
α : Type u,	β : Type v,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	s : set α,	t : set β,	ht : ∀ (f : ultrafilter β), ↑f ≤ 𝓟 t → (∃ (a : β) (H : a ∈ t), ↑f ≤ 𝓝 a),	hs : ∀ (f : ultrafilter α), ↑f ≤ 𝓟 s → (∃ (a : α) (H : a ∈ s), ↑f ≤ 𝓝 a)	⊢ ∀ (f : ultrafilter (α × β)), ↑f ≤ 𝓟 (s.prod t) → (∃ (a : α × β) (H : a ∈ s.prod t), ↑f ≤ 𝓝 a)
α : Type u,	β : Type v,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	s : set α,	t : set β,	ht : ∀ (f : ultrafilter β), ↑f ≤ 𝓟 t → (∃ (a : β) (H : a ∈ t), ↑f ≤ 𝓝 a),	hs : ∀ (f : ultrafilter α), ↑f ≤ 𝓟 s → (∃ (a : α) (H : a ∈ s), ↑f ≤ 𝓝 a),	f : ultrafilter (α × β),	hfs : ↑f ≤ 𝓟 (s.prod t)	⊢ ∃ (a : α × β) (H : a ∈ s.prod t), ↑f ≤ 𝓝 a
α : Type u,	β : Type v,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	s : set α,	t : set β,	ht : ∀ (f : ultrafilter β), ↑f ≤ 𝓟 t → (∃ (a : β) (H : a ∈ t), ↑f ≤ 𝓝 a),	hs : ∀ (f : ultrafilter α), ↑f ≤ 𝓟 s → (∃ (a : α) (H : a ∈ s), ↑f ≤ 𝓝 a),	f : ultrafilter (α × β),	hfs : s.prod t ∈ ↑f	⊢ ∃ (a : α × β) (H : a ∈ s.prod t), ↑f ≤ 𝓝 a
α : Type u,	β : Type v,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	s : set α,	t : set β,	ht : ∀ (f : ultrafilter β), ↑f ≤ 𝓟 t → (∃ (a : β) (H : a ∈ t), ↑f ≤ 𝓝 a),	hs : ∀ (f : ultrafilter α), ↑f ≤ 𝓟 s → (∃ (a : α) (H : a ∈ s), ↑f ≤ 𝓝 a),	f : ultrafilter (α × β),	hfs : s.prod t ∈ ↑f,	a : α,	sa : a ∈ s,	ha : filter.map prod.fst ↑f ≤ 𝓝 a	⊢ ∃ (a : α × β) (H : a ∈ s.prod t), ↑f ≤ 𝓝 a
α : Type u,	β : Type v,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	s : set α,	t : set β,	ht : ∀ (f : ultrafilter β), ↑f ≤ 𝓟 t → (∃ (a : β) (H : a ∈ t), ↑f ≤ 𝓝 a),	hs : ∀ (f : ultrafilter α), ↑f ≤ 𝓟 s → (∃ (a : α) (H : a ∈ s), ↑f ≤ 𝓝 a),	f : ultrafilter (α × β),	hfs : s.prod t ∈ ↑f,	a : α,	sa : a ∈ s,	ha : filter.map prod.fst ↑f ≤ 𝓝 a,	b : β,	tb : b ∈ t,	hb : filter.map prod.snd ↑f ≤ 𝓝 b	⊢ ∃ (a : α × β) (H : a ∈ s.prod t), ↑f ≤ 𝓝 a
α : Type u,	β : Type v,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	s : set α,	t : set β,	ht : ∀ (f : ultrafilter β), ↑f ≤ 𝓟 t → (∃ (a : β) (H : a ∈ t), ↑f ≤ 𝓝 a),	hs : ∀ (f : ultrafilter α), ↑f ≤ 𝓟 s → (∃ (a : α) (H : a ∈ s), ↑f ≤ 𝓝 a),	f : ultrafilter (α × β),	hfs : s.prod t ∈ ↑f,	a : α,	sa : a ∈ s,	b : β,	tb : b ∈ t,	hb : ↑f ≤ filter.comap prod.snd (𝓝 b),	ha : ↑f ≤ filter.comap prod.fst (𝓝 a)	⊢ ∃ (a : α × β) (H : a ∈ s.prod t), ↑f ≤ 𝓝 a
α : Type u,	β : Type v,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	s : set α,	t : set β,	ht : ∀ (f : ultrafilter β), ↑f ≤ 𝓟 t → (∃ (a : β) (H : a ∈ t), ↑f ≤ 𝓝 a),	hs : ∀ (f : ultrafilter α), ↑f ≤ 𝓟 s → (∃ (a : α) (H : a ∈ s), ↑f ≤ 𝓝 a),	f : ultrafilter (α × β),	hfs : s.prod t ∈ ↑f,	a : α,	sa : a ∈ s,	b : β,	tb : b ∈ t,	hb : ↑f ≤ filter.comap prod.snd (𝓝 b),	ha : ↑f ≤ filter.comap prod.fst (𝓝 a)	⊢ ↑f ≤ 𝓝 a ×ᶠ 𝓝 b
α : Type u,	β : Type v,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	s : set α,	t : set β,	ht : ∀ (f : ultrafilter β), ↑f ≤ 𝓟 t → (∃ (a : β) (H : a ∈ t), ↑f ≤ 𝓝 a),	hs : ∀ (f : ultrafilter α), ↑f ≤ 𝓟 s → (∃ (a : α) (H : a ∈ s), ↑f ≤ 𝓝 a),	f : ultrafilter (α × β),	hfs : s.prod t ∈ ↑f,	a : α,	sa : a ∈ s,	b : β,	tb : b ∈ t,	hb : ↑f ≤ filter.comap prod.snd (𝓝 b),	ha : ↑f ≤ filter.comap prod.fst (𝓝 a)	⊢ ↑f ≤ 𝓝 (a, b)
α : Type u_1,	β : Type u_2,	_inst_1 : uniform_space α,	_inst_2 : topological_space β,	f : β → α,	b : β,	s : set β	⊢ continuous_within_at f s b ↔ filter.tendsto (λ (x : β), (f b, f x)) (𝓝[s] b) (𝓤 α)
α : Type u_1,	U V : set (α × α),	hU : symmetric_rel U,	hV : symmetric_rel V	⊢ symmetric_rel (U ∩ V)
α : Type u_1,	U V : set (α × α),	hU : prod.swap ⁻¹' U = U,	hV : prod.swap ⁻¹' V = V	⊢ prod.swap ⁻¹' (U ∩ V) = U ∩ V
α : Type u_1,	uniform_space.core_eq : ∀ {u₁ u₂ : uniform_space.core α}, u₁.uniformity = u₂.uniformity → u₁ = u₂,	u₁ : filter (α × α),	_x : 𝓟 id_rel ≤ u₁,	_x : filter.tendsto prod.swap u₁ u₁,	_x : u₁.lift' (λ (s : set (α × α)), s ○ s) ≤ u₁,	u₂ : filter (α × α),	_x : 𝓟 id_rel ≤ u₂,	_x : filter.tendsto prod.swap u₂ u₂,	_x : u₂.lift' (λ (s : set (α × α)), s ○ s) ≤ u₂,	h : {uniformity := u₁, refl := _x, symm := _x, comp := _x}.uniformity = {uniformity := u₂, refl := _x, symm := _x, comp := _x}.uniformity	⊢ {uniformity := u₁, refl := _x, symm := _x, comp := _x} = {uniformity := u₂, refl := _x, symm := _x, comp := _x}
α : Type u_1,	uniform_space.core_eq : ∀ {u₁ u₂ : uniform_space.core α}, u₁.uniformity = u₂.uniformity → u₁ = u₂,	u₁ : filter (α × α),	_x : 𝓟 id_rel ≤ u₁,	_x : filter.tendsto prod.swap u₁ u₁,	_x : u₁.lift' (λ (s : set (α × α)), s ○ s) ≤ u₁,	u₂ : filter (α × α),	_x : 𝓟 id_rel ≤ u₂,	_x : filter.tendsto prod.swap u₂ u₂,	_x : u₂.lift' (λ (s : set (α × α)), s ○ s) ≤ u₂,	h : {uniformity := u₁, refl := _x, symm := _x, comp := _x}.uniformity = {uniformity := u₂, refl := _x, symm := _x, comp := _x}.uniformity	⊢ u₁ = u₂
α : Type u_1,	_inst_1 : uniform_space α,	a b : α	⊢ 𝓝 a ×ᶠ 𝓝 b = (𝓤 α).lift (λ (s : set (α × α)), (𝓤 α).lift' (λ (t : set (α × α)), {y : α | (y, a) ∈ s}.prod {y : α | (b, y) ∈ t}))
α : Type u_1,	_inst_1 : uniform_space α,	a b : α	⊢ (𝓝 a).lift (λ (s : set α), (𝓝 b).lift' s.prod) = (𝓤 α).lift (λ (s : set (α × α)), (𝓤 α).lift' (λ (t : set (α × α)), {y : α | (y, a) ∈ s}.prod {y : α | (b, y) ∈ t}))
α : Type u_1,	_inst_1 : uniform_space α,	a b : α	⊢ (𝓝 a).lift (λ (s : set α), (𝓝 b).lift (λ (t : set α), 𝓟 (s.prod t))) = (𝓤 α).lift (λ (s : set (α × α)), (𝓤 α).lift' (λ (t : set (α × α)), {y : α | (y, a) ∈ s}.prod {y : α | (b, y) ∈ t}))
α : Type u_1,	_inst_1 : uniform_space α,	a b : α	⊢ (λ (s : set (α × α)), (𝓝 b).lift (λ (t : set α), 𝓟 ({y : α | (y, a) ∈ s}.prod t))) = λ (s : set (α × α)), (𝓤 α).lift' (λ (t : set (α × α)), {y : α | (y, a) ∈ s}.prod {y : α | (b, y) ∈ t})		α : Type u_1,	_inst_1 : uniform_space α,	a b : α	⊢ monotone (λ (s : set α), (𝓝 b).lift (λ (t : set α), 𝓟 (s.prod t)))
α : Type u_1,	_inst_1 : uniform_space α,	a b : α	⊢ (𝓤 α).lift (λ (s : set (α × α)), (𝓝 b).lift (λ (t : set α), 𝓟 ({y : α | (y, a) ∈ s}.prod t))) = (𝓤 α).lift (λ (s : set (α × α)), (𝓤 α).lift' (λ (t : set (α × α)), {y : α | (y, a) ∈ s}.prod {y : α | (b, y) ∈ t}))		α : Type u_1,	_inst_1 : uniform_space α,	a b : α	⊢ monotone (λ (s : set α), (𝓝 b).lift (λ (t : set α), 𝓟 (s.prod t)))
α : Type u_1,	_inst_1 : uniform_space α,	a b : α,	s : set (α × α)	⊢ (𝓝 b).lift (λ (t : set α), 𝓟 ({y : α | (y, a) ∈ s}.prod t)) = (𝓤 α).lift' (λ (t : set (α × α)), {y : α | (y, a) ∈ s}.prod {y : α | (b, y) ∈ t})		α : Type u_1,	_inst_1 : uniform_space α,	a b : α	⊢ monotone (λ (s : set α), (𝓝 b).lift (λ (t : set α), 𝓟 (s.prod t)))
α : Type u_1,	_inst_1 : uniform_space α,	a b : α,	s : set (α × α)	⊢ (𝓤 α).lift (λ (s_1 : set (α × α)), 𝓟 ({y : α | (y, a) ∈ s}.prod {y : α | (b, y) ∈ s_1})) = (𝓤 α).lift' (λ (t : set (α × α)), {y : α | (y, a) ∈ s}.prod {y : α | (b, y) ∈ t})		α : Type u_1,	_inst_1 : uniform_space α,	a b : α,	s : set (α × α)	⊢ monotone (λ (t : set α), 𝓟 ({y : α | (y, a) ∈ s}.prod t))		α : Type u_1,	_inst_1 : uniform_space α,	a b : α	⊢ monotone (λ (s : set α), (𝓝 b).lift (λ (t : set α), 𝓟 (s.prod t)))
α : Type u_1,	_inst_1 : uniform_space α,	a b : α,	s : set (α × α)	⊢ monotone (λ (t : set α), 𝓟 ({y : α | (y, a) ∈ s}.prod t))		α : Type u_1,	_inst_1 : uniform_space α,	a b : α	⊢ monotone (λ (s : set α), (𝓝 b).lift (λ (t : set α), 𝓟 (s.prod t)))
α : Type u_1,	_inst_1 : uniform_space α,	a b : α	⊢ monotone (λ (s : set α), (𝓝 b).lift (λ (t : set α), 𝓟 (s.prod t)))
α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	_inst_1 : uniform_space α,	_inst_2 : uniform_space β,	p : γ → Prop,	s : γ → set (α × α),	ha : (𝓤 α).has_basis p s,	q : δ → Prop,	t : δ → set (β × β),	hb : (𝓤 β).has_basis q t,	f : α → β,	S : set α	⊢ (∀ (ib : δ), q ib → (∃ (ia : γ) (hia : p ia), ∀ (x : α × α), x ∈ s ia ∩ S.prod S → (f x.fst, f x.snd) ∈ t ib)) ↔ ∀ (i : δ), q i → (∃ (j : γ) (hj : p j), ∀ (x y : α), x ∈ S → y ∈ S → (x, y) ∈ s j → (f x, f y) ∈ t i)
α : Type u,	β : Type v,	_inst_1 : uniform_space α,	γ : Sort u_1,	_inst_2 : nonempty β,	_inst_3 : semilattice_sup β,	u : β → α,	p : γ → Prop,	s : γ → set (α × α),	H : (𝓤 α).has_basis p s	⊢ cauchy_seq u ↔ ∀ (i : γ), p i → (∃ (N : β), ∀ (n : β), n ≥ N → (u n, u N) ∈ s i)
α : Type u,	β : Type v,	_inst_1 : uniform_space α,	γ : Sort u_1,	_inst_2 : nonempty β,	_inst_3 : semilattice_sup β,	u : β → α,	p : γ → Prop,	s : γ → set (α × α),	H : (𝓤 α).has_basis p s,	h : ∀ (i : γ), p i → (∃ (N : β), ∀ (m n : β), m ≥ N → n ≥ N → (u m, u n) ∈ s i),	i : γ,	hi : p i	⊢ ∃ (N : β), ∀ (n : β), n ≥ N → (u n, u N) ∈ s i
α : Type u,	β : Type v,	_inst_1 : uniform_space α,	γ : Sort u_1,	_inst_2 : nonempty β,	_inst_3 : semilattice_sup β,	u : β → α,	p : γ → Prop,	s : γ → set (α × α),	H : (𝓤 α).has_basis p s,	h : ∀ (i : γ), p i → (∃ (N : β), ∀ (m n : β), m ≥ N → n ≥ N → (u m, u n) ∈ s i),	i : γ,	hi : p i	⊢ ∃ (N : β), ∀ (n : β), n ≥ N → (u n, u N) ∈ s i		α : Type u,	β : Type v,	_inst_1 : uniform_space α,	γ : Sort u_1,	_inst_2 : nonempty β,	_inst_3 : semilattice_sup β,	u : β → α,	p : γ → Prop,	s : γ → set (α × α),	H : (𝓤 α).has_basis p s,	h : ∀ (i : γ), p i → (∃ (N : β), ∀ (n : β), n ≥ N → (u n, u N) ∈ s i),	i : γ,	hi : p i	⊢ ∃ (N : β), ∀ (m n : β), m ≥ N → n ≥ N → (u m, u n) ∈ s i
α : Type u,	β : Type v,	_inst_1 : uniform_space α,	γ : Sort u_1,	_inst_2 : nonempty β,	_inst_3 : semilattice_sup β,	u : β → α,	p : γ → Prop,	s : γ → set (α × α),	H : (𝓤 α).has_basis p s,	h : ∀ (i : γ), p i → (∃ (N : β), ∀ (n : β), n ≥ N → (u n, u N) ∈ s i),	i : γ,	hi : p i	⊢ ∃ (N : β), ∀ (m n : β), m ≥ N → n ≥ N → (u m, u n) ∈ s i
α : Type u,	β : Type v,	_inst_1 : uniform_space α,	γ : Sort u_1,	_inst_2 : nonempty β,	_inst_3 : semilattice_sup β,	u : β → α,	p : γ → Prop,	s : γ → set (α × α),	H : (𝓤 α).has_basis p s,	h : ∀ (i : γ), p i → (∃ (N : β), ∀ (n : β), n ≥ N → (u n, u N) ∈ s i),	i : γ,	hi : p i,	t : set (α × α),	ht : t ∈ 𝓤 α,	ht' : ∀ {a b : α}, (a, b) ∈ t → (b, a) ∈ t,	hts : t ○ t ⊆ s i	⊢ ∃ (N : β), ∀ (m n : β), m ≥ N → n ≥ N → (u m, u n) ∈ s i
α : Type u,	β : Type v,	_inst_1 : uniform_space α,	γ : Sort u_1,	_inst_2 : nonempty β,	_inst_3 : semilattice_sup β,	u : β → α,	p : γ → Prop,	s : γ → set (α × α),	H : (𝓤 α).has_basis p s,	h : ∀ (i : γ), p i → (∃ (N : β), ∀ (n : β), n ≥ N → (u n, u N) ∈ s i),	i : γ,	hi : p i,	t : set (α × α),	ht : t ∈ 𝓤 α,	ht' : ∀ {a b : α}, (a, b) ∈ t → (b, a) ∈ t,	hts : t ○ t ⊆ s i,	j : γ,	hj : p j,	hjt : s j ⊆ t	⊢ ∃ (N : β), ∀ (m n : β), m ≥ N → n ≥ N → (u m, u n) ∈ s i
α : Type u,	β : Type v,	_inst_1 : uniform_space α,	γ : Sort u_1,	_inst_2 : nonempty β,	_inst_3 : semilattice_sup β,	u : β → α,	p : γ → Prop,	s : γ → set (α × α),	H : (𝓤 α).has_basis p s,	h : ∀ (i : γ), p i → (∃ (N : β), ∀ (n : β), n ≥ N → (u n, u N) ∈ s i),	i : γ,	hi : p i,	t : set (α × α),	ht : t ∈ 𝓤 α,	ht' : ∀ {a b : α}, (a, b) ∈ t → (b, a) ∈ t,	hts : t ○ t ⊆ s i,	j : γ,	hj : p j,	hjt : s j ⊆ t,	N : β,	hN : ∀ (n : β), n ≥ N → (u n, u N) ∈ s j,	m n : β,	hm : m ≥ N,	hn : n ≥ N	⊢ ((u m, u n).fst, u N) ∈ s j		α : Type u,	β : Type v,	_inst_1 : uniform_space α,	γ : Sort u_1,	_inst_2 : nonempty β,	_inst_3 : semilattice_sup β,	u : β → α,	p : γ → Prop,	s : γ → set (α × α),	H : (𝓤 α).has_basis p s,	h : ∀ (i : γ), p i → (∃ (N : β), ∀ (n : β), n ≥ N → (u n, u N) ∈ s i),	i : γ,	hi : p i,	t : set (α × α),	ht : t ∈ 𝓤 α,	ht' : ∀ {a b : α}, (a, b) ∈ t → (b, a) ∈ t,	hts : t ○ t ⊆ s i,	j : γ,	hj : p j,	hjt : s j ⊆ t,	N : β,	hN : ∀ (n : β), n ≥ N → (u n, u N) ∈ s j,	m n : β,	hm : m ≥ N,	hn : n ≥ N	⊢ ((u m, u n).snd, u N) ∈ s j
α : Type u,	β : Type v,	_inst_1 : uniform_space α,	γ : Sort u_1,	_inst_2 : nonempty β,	_inst_3 : semilattice_sup β,	u : β → α,	p : γ → Prop,	s : γ → set (α × α),	H : (𝓤 α).has_basis p s,	h : ∀ (i : γ), p i → (∃ (N : β), ∀ (n : β), n ≥ N → (u n, u N) ∈ s i),	i : γ,	hi : p i,	t : set (α × α),	ht : t ∈ 𝓤 α,	ht' : ∀ {a b : α}, (a, b) ∈ t → (b, a) ∈ t,	hts : t ○ t ⊆ s i,	j : γ,	hj : p j,	hjt : s j ⊆ t,	N : β,	hN : ∀ (n : β), n ≥ N → (u n, u N) ∈ s j,	m n : β,	hm : m ≥ N,	hn : n ≥ N	⊢ ((u m, u n).fst, u N) ∈ s j
α : Type u,	β : Type v,	_inst_1 : uniform_space α,	γ : Sort u_1,	_inst_2 : nonempty β,	_inst_3 : semilattice_sup β,	u : β → α,	p : γ → Prop,	s : γ → set (α × α),	H : (𝓤 α).has_basis p s,	h : ∀ (i : γ), p i → (∃ (N : β), ∀ (n : β), n ≥ N → (u n, u N) ∈ s i),	i : γ,	hi : p i,	t : set (α × α),	ht : t ∈ 𝓤 α,	ht' : ∀ {a b : α}, (a, b) ∈ t → (b, a) ∈ t,	hts : t ○ t ⊆ s i,	j : γ,	hj : p j,	hjt : s j ⊆ t,	N : β,	hN : ∀ (n : β), n ≥ N → (u n, u N) ∈ s j,	m n : β,	hm : m ≥ N,	hn : n ≥ N	⊢ ((u m, u n).snd, u N) ∈ s j
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ	⊢ (⨆ (x : γ), 𝓝 (x, x)).lift' (λ (s : set (γ × γ)), s ○ s) ≤ ⨆ (x : γ), 𝓝 (x, x)
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x)	⊢ 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s) ≤ 𝓝Δ
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s)	⊢ F ≤ 𝓝Δ
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s)	⊢ ∀ (V : set (γ × γ)), V ∈ 𝓝Δ → F ⊓ 𝓟 Vᶜ = ⊥
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ	⊢ F ⊓ 𝓟 Vᶜ = ⊥
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥	⊢ false
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot	⊢ false
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ)	⊢ false
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ)	⊢ false
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ)	⊢ (x, y) ∈ closure Vᶜ
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ)	⊢ (x, y) ∉ interior V
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ)	⊢ (x, y) ∉ interior V		γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V	⊢ false
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∈ closure Vᶜ	⊢ (x, y) ∉ interior V
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V	⊢ false
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V	⊢ set.diagonal γ ⊆ interior V
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V	⊢ ∀ (x : γ × γ), x ∈ set.diagonal γ → V ∈ 𝓝 x
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V	⊢ set.diagonal γ ⊆ interior V		γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V	⊢ false
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	x : γ,	H_1 : (x, x) ∈ set.diagonal γ	⊢ V ∈ 𝓝 (x, x)
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V	⊢ false
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V	⊢ x ≠ y
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	h : x = y	⊢ false
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	h : x = y	⊢ (x, y) ∈ interior V
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V	⊢ x ≠ y		γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y	⊢ false
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	h : x = y	⊢ (x, y) ∈ set.diagonal γ
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y	⊢ false
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ	⊢ false
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅	⊢ false
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ	⊢ false
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃	⊢ false
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃	⊢ false
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃	⊢ W ∈ 𝓝Δ
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃	⊢ ∀ (i : γ), W ∈ 𝓝 (i, i)
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃,	x : γ	⊢ W ∈ 𝓝 (x, x)
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃,	x : γ	⊢ (x, x) ∈ U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃,	x : γ,	hx : x ∈ V₁ ∪ V₂	⊢ (x, x) ∈ U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃,	x : γ,	hx : x ∈ V₁ ∪ V₂	⊢ (x, x) ∈ U₁.prod U₁ ∪ U₂.prod U₂
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃,	x : γ,	hx : x ∈ V₁ ∪ V₂	⊢ (x, x) ∈ U₁.prod U₁ ∪ U₂.prod U₂
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃,	x : γ,	hx : x ∈ V₁ ∪ V₂	⊢ (x, x) ∈ U₁.prod U₁ ∪ U₂.prod U₂
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃,	x : γ,	hx : x ∈ V₁ ∪ V₂	⊢ (x, x) ∈ U₁.prod U₁ ∪ U₂.prod U₂
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃,	x : γ,	hx : x ∈ V₁	⊢ (x, x) ∈ U₁.prod U₁ ∪ U₂.prod U₂
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃,	x : γ,	hx : x ∈ V₂	⊢ (x, x) ∈ U₁.prod U₁ ∪ U₂.prod U₂
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃,	x : γ,	hx : x ∈ V₁	⊢ (x, x) ∈ U₁.prod U₁
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃,	x : γ,	hx : x ∈ V₂	⊢ (x, x) ∈ U₂.prod U₂
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃,	x : γ,	hx : x ∈ V₁	⊢ (x, x).fst ∈ U₁
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃,	x : γ,	hx : x ∈ V₁	⊢ (x, x).snd ∈ U₁
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃,	x : γ,	hx : x ∈ V₂	⊢ (x, x).fst ∈ U₂
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃,	x : γ,	hx : x ∈ V₂	⊢ (x, x).snd ∈ U₂
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃,	x : γ,	hx : x ∈ V₁ ∪ V₂	⊢ (x, x) ∈ U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃		γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃,	x : γ,	hx : x ∉ V₁ ∪ V₂	⊢ (x, x) ∈ U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃,	x : γ,	hx : x ∉ V₁ ∪ V₂	⊢ (x, x) ∈ U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃,	x : γ,	hx : x ∉ V₁ ∪ V₂	⊢ (x, x) ∈ U₃.prod U₃
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃,	x : γ,	hx : x ∉ V₁ ∪ V₂	⊢ (x, x).fst ∈ U₃ ∧ (x, x).snd ∈ U₃
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃,	x : γ	⊢ (x, x) ∈ U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃		γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃,	x : γ	⊢ is_open (U₁.prod U₁)		γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃,	x : γ	⊢ is_open (U₂.prod U₂)		γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃,	x : γ	⊢ is_open (U₃.prod U₃)
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃,	x : γ	⊢ is_open (U₁.prod U₁)
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃,	x : γ	⊢ is_open (U₂.prod U₂)
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃,	x : γ	⊢ is_open (U₃.prod U₃)
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃	⊢ W ∈ 𝓝Δ		γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃,	W_in : W ∈ 𝓝Δ	⊢ false
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃,	x : γ	⊢ is_open (U₁.prod U₁)		γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃,	x : γ	⊢ is_open (U₂.prod U₂)		γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃,	x : γ	⊢ is_open (U₃.prod U₃)
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃,	W_in : W ∈ 𝓝Δ	⊢ W ○ W ∈ F
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃,	W_in : W ∈ 𝓝Δ	⊢ false
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃,	W_in : W ∈ 𝓝Δ,	this : W ○ W ∈ F	⊢ false
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃,	W_in : W ∈ 𝓝Δ,	this : W ○ W ∈ F,	hV₁₂ : V₁.prod V₂ ∈ 𝓝 (x, y)	⊢ false
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃,	W_in : W ∈ 𝓝Δ,	this : W ○ W ∈ F,	hV₁₂ : V₁.prod V₂ ∈ 𝓝 (x, y),	clF : cluster_pt (x, y) F	⊢ false
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃,	W_in : W ∈ 𝓝Δ,	this : W ○ W ∈ F,	hV₁₂ : V₁.prod V₂ ∈ 𝓝 (x, y),	clF : cluster_pt (x, y) F,	p : γ × γ,	p_in : p ∈ V₁.prod V₂ ∩ (W ○ W)	⊢ false
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃,	W_in : W ∈ 𝓝Δ,	this : W ○ W ∈ F,	hV₁₂ : V₁.prod V₂ ∈ 𝓝 (x, y),	clF : cluster_pt (x, y) F,	p : γ × γ,	p_in : p ∈ V₁.prod V₂ ∩ (W ○ W)	⊢ V₁.prod V₂ ∩ (W ○ W) = ∅
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃,	W_in : W ∈ 𝓝Δ,	this : W ○ W ∈ F,	hV₁₂ : V₁.prod V₂ ∈ 𝓝 (x, y),	clF : cluster_pt (x, y) F,	p : γ × γ,	p_in : p ∈ V₁.prod V₂ ∩ (W ○ W)	⊢ ∀ (x : γ × γ), x ∉ V₁.prod V₂ ∩ (W ○ W)
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃,	W_in : W ∈ 𝓝Δ,	this : W ○ W ∈ F,	hV₁₂ : V₁.prod V₂ ∈ 𝓝 (x, y),	clF : cluster_pt (x, y) F,	p : γ × γ,	p_in : p ∈ V₁.prod V₂ ∩ (W ○ W),	u v : γ,	u_in : (u, v).fst ∈ V₁,	v_in : (u, v).snd ∈ V₂,	w : γ,	huw : ((u, v).fst, w) ∈ W,	hwv : (w, (u, v).snd) ∈ W	⊢ false
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃,	W_in : W ∈ 𝓝Δ,	this : W ○ W ∈ F,	hV₁₂ : V₁.prod V₂ ∈ 𝓝 (x, y),	clF : cluster_pt (x, y) F,	p : γ × γ,	p_in : p ∈ V₁.prod V₂ ∩ (W ○ W),	u v : γ,	u_in : (u, v).fst ∈ V₁,	v_in : (u, v).snd ∈ V₂,	w : γ,	huw : ((u, v).fst, w) ∈ W,	hwv : (w, (u, v).snd) ∈ W,	h : ((u, v).fst, w) ∈ U₂.prod U₂,	this : u ∈ U₁ ∩ U₂	⊢ false
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃,	W_in : W ∈ 𝓝Δ,	this : W ○ W ∈ F,	hV₁₂ : V₁.prod V₂ ∈ 𝓝 (x, y),	clF : cluster_pt (x, y) F,	p : γ × γ,	p_in : p ∈ V₁.prod V₂ ∩ (W ○ W),	u v : γ,	u_in : (u, v).fst ∈ V₁,	v_in : (u, v).snd ∈ V₂,	w : γ,	huw : ((u, v).fst, w) ∈ W,	hwv : (w, (u, v).snd) ∈ W,	uw_in : (u, w) ∈ U₁.prod U₁	⊢ false
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃,	W_in : W ∈ 𝓝Δ,	this : W ○ W ∈ F,	hV₁₂ : V₁.prod V₂ ∈ 𝓝 (x, y),	clF : cluster_pt (x, y) F,	p : γ × γ,	p_in : p ∈ V₁.prod V₂ ∩ (W ○ W),	u v : γ,	u_in : (u, v).fst ∈ V₁,	v_in : (u, v).snd ∈ V₂,	w : γ,	huw : ((u, v).fst, w) ∈ W,	hwv : (w, (u, v).snd) ∈ W,	uw_in : (u, w) ∈ U₁.prod U₁,	h : (w, (u, v).snd) ∈ U₁.prod U₁,	this : v ∈ U₁ ∩ U₂	⊢ false
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃,	W_in : W ∈ 𝓝Δ,	this : W ○ W ∈ F,	hV₁₂ : V₁.prod V₂ ∈ 𝓝 (x, y),	clF : cluster_pt (x, y) F,	p : γ × γ,	p_in : p ∈ V₁.prod V₂ ∩ (W ○ W),	u v : γ,	u_in : (u, v).fst ∈ V₁,	v_in : (u, v).snd ∈ V₂,	w : γ,	huw : ((u, v).fst, w) ∈ W,	hwv : (w, (u, v).snd) ∈ W,	uw_in : (u, w) ∈ U₁.prod U₁,	wv_in : (w, v) ∈ U₂.prod U₂	⊢ false
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃,	W_in : W ∈ 𝓝Δ,	this : W ○ W ∈ F,	hV₁₂ : V₁.prod V₂ ∈ 𝓝 (x, y),	clF : cluster_pt (x, y) F,	p : γ × γ,	p_in : p ∈ V₁.prod V₂ ∩ (W ○ W)	⊢ V₁.prod V₂ ∩ (W ○ W) = ∅		γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃,	W_in : W ∈ 𝓝Δ,	this : W ○ W ∈ F,	hV₁₂ : V₁.prod V₂ ∈ 𝓝 (x, y),	clF : cluster_pt (x, y) F,	p : γ × γ,	p_in : p ∈ V₁.prod V₂ ∩ (W ○ W),	inter_empty : V₁.prod V₂ ∩ (W ○ W) = ∅	⊢ false
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃,	W_in : W ∈ 𝓝Δ,	this : W ○ W ∈ F,	hV₁₂ : V₁.prod V₂ ∈ 𝓝 (x, y),	clF : cluster_pt (x, y) F,	p : γ × γ,	p_in : p ∈ V₁.prod V₂ ∩ (W ○ W),	u v : γ,	u_in : (u, v).fst ∈ V₁,	v_in : (u, v).snd ∈ V₂,	w : γ,	huw : ((u, v).fst, w) ∈ W,	hwv : (w, (u, v).snd) ∈ W,	uw_in : (u, w) ∈ U₁.prod U₁,	wv_in : (w, v) ∈ U₂.prod U₂,	this : w ∈ U₁ ∩ U₂	⊢ false
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	𝓝Δ : filter (γ × γ) := ⨆ (x : γ), 𝓝 (x, x),	F : filter (γ × γ) := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s),	V : set (γ × γ),	V_in : V ∈ 𝓝Δ,	H : ¬F ⊓ 𝓟 Vᶜ = ⊥,	_inst : (F ⊓ 𝓟 Vᶜ).ne_bot,	x y : γ,	hxy : cluster_pt (x, y) (F ⊓ 𝓟 Vᶜ),	clV : cluster_pt (x, y) (𝓟 Vᶜ),	this : (x, y) ∉ interior V,	diag_subset : set.diagonal γ ⊆ interior V,	x_ne_y : x ≠ y,	_inst_1 : normal_space γ,	U₁ V₁ : set γ,	U₁_in : U₁ ∈ 𝓝 x,	V₁_in : V₁ ∈ 𝓝 x,	U₂ V₂ : set γ,	U₂_in₂ : U₂ ∈ 𝓝 y,	V₂_in : V₂ ∈ 𝓝 y,	V₁_cl : is_closed V₁,	V₂_cl : is_closed V₂,	U₁_op : is_open U₁,	U₂_op : is_open U₂,	VU₁ : V₁ ⊆ U₁,	VU₂ : V₂ ⊆ U₂,	hU₁₂ : U₁ ∩ U₂ = ∅,	U₃ : set γ := (V₁ ∪ V₂)ᶜ,	U₃_op : is_open U₃,	W : set (γ × γ) := U₁.prod U₁ ∪ U₂.prod U₂ ∪ U₃.prod U₃,	W_in : W ∈ 𝓝Δ,	this : W ○ W ∈ F,	hV₁₂ : V₁.prod V₂ ∈ 𝓝 (x, y),	clF : cluster_pt (x, y) F,	p : γ × γ,	p_in : p ∈ V₁.prod V₂ ∩ (W ○ W),	inter_empty : V₁.prod V₂ ∩ (W ○ W) = ∅	⊢ false
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ	⊢ ∀ (s : set γ), _inst_3.is_open s ↔ ∀ (x : γ), x ∈ s → {p : γ × γ | p.fst = x → p.snd ∈ s} ∈ {uniformity := ⨆ (x : γ), 𝓝 (x, x), refl := _, symm := _, comp := _}.uniformity
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	this : ∀ (x : γ), filter.comap (prod.mk x) (⨆ (y : γ), 𝓝 (y, y)) = 𝓝 x	⊢ ∀ (s : set γ), _inst_3.is_open s ↔ ∀ (x : γ), x ∈ s → {p : γ × γ | p.fst = x → p.snd ∈ s} ∈ {uniformity := ⨆ (x : γ), 𝓝 (x, x), refl := _, symm := _, comp := _}.uniformity
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	this : ∀ (x : γ), filter.comap (prod.mk x) (⨆ (y : γ), 𝓝 (y, y)) = 𝓝 x,	s : set γ	⊢ _inst_3.is_open s ↔ ∀ (x : γ), x ∈ s → {p : γ × γ | p.fst = x → p.snd ∈ s} ∈ {uniformity := ⨆ (x : γ), 𝓝 (x, x), refl := _, symm := _, comp := _}.uniformity
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	this : ∀ (x : γ), filter.comap (prod.mk x) (⨆ (y : γ), 𝓝 (y, y)) = 𝓝 x	⊢ ∀ (s : set γ), _inst_3.is_open s ↔ ∀ (x : γ), x ∈ s → {p : γ × γ | p.fst = x → p.snd ∈ s} ∈ {uniformity := ⨆ (x : γ), 𝓝 (x, x), refl := _, symm := _, comp := _}.uniformity		γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ	⊢ ∀ (x : γ), filter.comap (prod.mk x) (⨆ (y : γ), 𝓝 (y, y)) = 𝓝 x
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	this : ∀ (x : γ), filter.comap (prod.mk x) (⨆ (y : γ), 𝓝 (y, y)) = 𝓝 x,	s : set γ	⊢ is_open s ↔ ∀ (x : γ), x ∈ s → {p : γ × γ | p.fst = x → p.snd ∈ s} ∈ {uniformity := ⨆ (x : γ), 𝓝 (x, x), refl := _, symm := _, comp := _}.uniformity
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ	⊢ ∀ (x : γ), filter.comap (prod.mk x) (⨆ (y : γ), 𝓝 (y, y)) = 𝓝 x
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	x : γ	⊢ filter.comap (prod.mk x) (⨆ (y : γ), 𝓝 (y, y)) = 𝓝 x
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	x : γ	⊢ prod.fst ∘ prod.mk x = λ (y : γ), x
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	x : γ	⊢ prod.fst ∘ prod.mk x = λ (y : γ), x
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	x x_1 : γ	⊢ (prod.fst ∘ prod.mk x) x_1 = x
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	x : γ	⊢ prod.snd ∘ prod.mk x = id
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	x : γ	⊢ prod.snd ∘ prod.mk x = id
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	x x_1 : γ	⊢ (prod.snd ∘ prod.mk x) x_1 = id x_1
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	x : γ	⊢ (⨆ (i : γ), filter.comap (λ (y : γ), x) (𝓝 i) ⊓ 𝓝 i) = 𝓝 x
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	x : γ	⊢ (⊤ ⊓ 𝓝 x ⊔ ⨆ (i : γ) (h : i ≠ x), filter.comap (λ (y : γ), x) (𝓝 i) ⊓ 𝓝 i) = 𝓝 x
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	x : γ,	this : ∀ (y : γ), y ≠ x → filter.comap (λ (y : γ), x) (𝓝 y) ⊓ 𝓝 y ≤ 𝓝 x	⊢ (⊤ ⊓ 𝓝 x ⊔ ⨆ (i : γ) (h : i ≠ x), filter.comap (λ (y : γ), x) (𝓝 i) ⊓ 𝓝 i) = 𝓝 x
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	x : γ	⊢ ∀ (y : γ), y ≠ x → filter.comap (λ (y : γ), x) (𝓝 y) ⊓ 𝓝 y ≤ 𝓝 x
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	x y : γ,	hxy : y ≠ x	⊢ filter.comap (λ (y : γ), x) (𝓝 y) ⊓ 𝓝 y ≤ 𝓝 x
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	x y : γ,	hxy : y ≠ x	⊢ ?m_1 ∉ {x}ᶜ
α : Type u_1,	β : Type u_2,	_inst_1 : uniform_space α,	_inst_2 : uniform_space β,	s : set α,	f : α → β,	hs : is_compact s,	hs' : is_separated s,	hf : continuous_on f s	⊢ uniform_continuous_on f s
α : Type u_1,	β : Type u_2,	_inst_1 : uniform_space α,	_inst_2 : uniform_space β,	s : set α,	f : α → β,	hs : is_compact s,	hs' : is_separated s,	hf : continuous_on f s	⊢ uniform_continuous (set.restrict f s)
α : Type u_1,	β : Type u_2,	_inst_1 : uniform_space α,	_inst_2 : uniform_space β,	s : set α,	f : α → β,	hs : is_compact s,	hf : continuous_on f s,	hs' : separated_space ↥s	⊢ uniform_continuous (set.restrict f s)
α : Type u_1,	β : Type u_2,	_inst_1 : uniform_space α,	_inst_2 : uniform_space β,	s : set α,	f : α → β,	hf : continuous_on f s,	hs' : separated_space ↥s,	hs : compact_space ↥s	⊢ uniform_continuous (set.restrict f s)
α : Type u_1,	β : Type u_2,	_inst_1 : uniform_space α,	_inst_2 : uniform_space β,	s : set α,	f : α → β,	hs' : separated_space ↥s,	hs : compact_space ↥s,	hf : continuous (set.restrict f s)	⊢ uniform_continuous (set.restrict f s)
α : Type u_1,	β : Type u_2,	_inst_1 : uniform_space α,	_inst_2 : uniform_space β,	s : set α,	f : α → β,	hs' : separated_space ↥s,	hs : compact_space ↥s,	hf : continuous (set.restrict f s)	⊢ uniform_continuous (set.restrict f s)
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ	⊢ 𝓟 id_rel ≤ ⨆ (x : γ), 𝓝 (x, x)
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ	⊢ ∀ (V : set (γ × γ)), (∀ (i : γ), V ∈ 𝓝 (i, i)) → id_rel ⊆ V
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	V : set (γ × γ),	V_in : ∀ (i : γ), V ∈ 𝓝 (i, i),	x : γ,	ᾰ : (x, x) ∈ id_rel	⊢ (x, x) ∈ V
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ	⊢ filter.tendsto prod.swap (⨆ (x : γ), 𝓝 (x, x)) (⨆ (x : γ), 𝓝 (x, x))
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ	⊢ filter.map prod.swap (⨆ (x : γ), 𝓝 (x, x)) = ⨆ (x : γ), 𝓝 (x, x)
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ	⊢ (⨆ (i : γ), filter.map prod.swap (𝓝 (i, i))) = ⨆ (x : γ), 𝓝 (x, x)
γ : Type u_3,	_inst_3 : topological_space γ,	_inst_4 : compact_space γ,	_inst_5 : t2_space γ,	x : γ	⊢ filter.map prod.swap (𝓝 (x, x)) = 𝓝 (x, x)
α : Type u,	β : Type v,	_inst_1 : uniform_space α,	_inst_2 : uniform_space β,	f : α → β,	hf : uniform_continuous f,	g : uniform_space.separation_quotient α → uniform_space.separation_quotient β,	comm : quotient.mk ∘ f = g ∘ quotient.mk	⊢ uniform_space.separation_quotient.map f = g
α : Type u,	β : Type v,	_inst_1 : uniform_space α,	_inst_2 : uniform_space β,	f : α → β,	hf : uniform_continuous f,	g : uniform_space.separation_quotient α → uniform_space.separation_quotient β,	comm : quotient.mk ∘ f = g ∘ quotient.mk	⊢ uniform_space.separation_quotient.map f = g
α : Type u,	β : Type v,	_inst_1 : uniform_space α,	_inst_2 : uniform_space β,	f : α → β,	hf : uniform_continuous f,	g : uniform_space.separation_quotient α → uniform_space.separation_quotient β,	comm : quotient.mk ∘ f = g ∘ quotient.mk,	a : α	⊢ uniform_space.separation_quotient.map f (quot.mk setoid.r a) = g (quot.mk setoid.r a)
α : Type u,	β : Type v,	γ : Type w,	ι : Type u_1,	_inst_1 : uniform_space β,	F : ι → α → β,	f : α → β,	s : set α,	p : filter ι,	h : tendsto_uniformly_on F f p s,	g : γ → α	⊢ tendsto_uniformly_on (λ (n : ι), F n ∘ g) (f ∘ g) p (g ⁻¹' s)
α : Type u,	β : Type v,	γ : Type w,	ι : Type u_1,	_inst_1 : uniform_space β,	F : ι → α → β,	f : α → β,	s : set α,	p : filter ι,	h : tendsto_uniformly_on F f p s,	g : γ → α,	u : set (β × β),	hu : u ∈ 𝓤 β	⊢ ∀ᶠ (n : ι) in p, ∀ (x : γ), x ∈ g ⁻¹' s → ((f ∘ g) x, (λ (n : ι), F n ∘ g) n x) ∈ u
α : Type u,	β : Type v,	γ : Type w,	ι : Type u_1,	_inst_1 : uniform_space β,	F : ι → α → β,	f : α → β,	s : set α,	p : filter ι,	h : tendsto_uniformly_on F f p s,	g : γ → α,	u : set (β × β),	hu : u ∈ 𝓤 β,	n : ι,	hn : ∀ (x : α), x ∈ s → (f x, F n x) ∈ u	⊢ ∀ (x : γ), x ∈ g ⁻¹' s → ((f ∘ g) x, (λ (n : ι), F n ∘ g) n x) ∈ u
⊢ compact_space ↥I
X : Type u_1,	_inst_1 : topological_space X,	_inst_2 : normal_space X,	s t : set X,	hs : is_closed s,	ht : is_closed t,	hd : disjoint s t	⊢ ∃ (f : C(X, ℝ)), set.eq_on ⇑f 0 s ∧ set.eq_on ⇑f 1 t ∧ ∀ (x : X), ⇑f x ∈ set.Icc 0 1
X : Type u_1,	_inst_1 : topological_space X,	_inst_2 : normal_space X,	s t : set X,	hs : is_closed s,	ht : is_closed t,	hd : disjoint s t,	c : urysohns.CU X := {C := s, U := tᶜ, closed_C := hs, open_U := _, subset := _}	⊢ ∃ (f : C(X, ℝ)), set.eq_on ⇑f 0 s ∧ set.eq_on ⇑f 1 t ∧ ∀ (x : X), ⇑f x ∈ set.Icc 0 1
