abstract { intros, simp, rw [h, h [x]], simp }
intros
simp
rw [h, h [x]]
simp
rw [nth_map, h]
rw corec_eq
refl
unfold even
simp *
min_tac a b
simp
cases a; cases b; simp [fin.add]
cases a; cases b
cases b
simp [fin.add]
cases a
cases m
cases n
reflexivity
{ simp, reflexivity }
simp
reflexivity
{ cases n, { simp, reflexivity }, simp [nat.zero_add], reflexivity }
simp [nat.zero_add]
cases n
reflexivity
{ simp, reflexivity }
simp
reflexivity
simp [nat.succ_add]
simp [neg_succ_of_nat_coe, int.coe_nat_succ, int.coe_nat_add, int.coe_nat_one, int.add_comm, int.add_left_comm, int.neg_add, int.add_right_neg, int.zero_add]
simp
rwa [int.add_neg_cancel_right, int.zero_add] at this
have h := int.add_le_add_right h b
rwa [int.sub_add_cancel, int.zero_add] at h
rwa int.zero_mul at h
rwa int.zero_mul at this
rw [bit_val, div2_val, nat.add_comm, add_mul_div_left, div_eq_of_lt, nat.zero_add]
rw [bit_val, div2_val, nat.add_comm, add_mul_div_left, div_eq_of_lt, nat.zero_add]; cases b; exact dec_trivial
rw [bit_val, div2_val, nat.add_comm, add_mul_div_left, div_eq_of_lt, nat.zero_add]; cases b
exact dec_trivial
exact dec_trivial
exact dec_trivial
cases b
cases b
rw [‚Üê nat.zero_add (m*n), add_mul_mod_self_left, zero_mod]
rwa [nat.zero_add, nat.zero_div, nat.zero_add] at t
rw nat.sub_add_cancel H
rw nat.sub_add_cancel H; exact h‚ÇÅ
exact h‚ÇÅ
rw heq at h
assumption
rw [‚Üê hk, nat.add_sub_cancel_left]
cases y
cases y; refl
refl
refl
{ cases y; refl }
cases x
refl
{ refl }
cases y
refine if_congr iff.rfl (mod_core_congr _ _) rfl
refine if_congr iff.rfl (mod_core_congr _ _) rfl; simp [nat.sub_le]
simp [nat.sub_le]
simp [nat.sub_le]
cases n; simp
simp
simp
cases n
sort_add
simp [mul_succ, right_distrib n m k]
rw [‚Üê vsub_vadd_eq_vsub_sub, vsub_vadd_comm, vsub_vadd_eq_vsub_sub]
haveI := P
exact algebra_map R A r
haveI := Q
exact algebra_map R A r
rcases P with ‚ü®‚ü®P‚ü©‚ü©
rcases Q with ‚ü®‚ü®Q‚ü©‚ü©
unfreezingI { rcases P with ‚ü®‚ü®P‚ü©‚ü©, rcases Q with ‚ü®‚ü®Q‚ü©‚ü© }
rw [algebra_compatible_smul A r (a ‚Ä¢ m), smul_smul, algebra.commutes, mul_smul, ‚Üêalgebra_compatible_smul]
congr
funext r a
replace w := congr_arg (Œª s, s * a) (w r)
simp only [‚Üêalgebra.smul_def''] at w
{ funext r a, replace w := congr_arg (Œª s, s * a) (w r), simp only [‚Üêalgebra.smul_def''] at w, apply w, }
apply w
ext r
{ ext r, exact w r, }
exact w r
{ apply proof_irrel_heq, }
apply proof_irrel_heq
apply proof_irrel_heq
rw [‚Üê mul_assoc, ‚Üê commutes, mul_assoc]
simp [bit1, add_smul]
norm_num
induction n; simp [*, pow_succ, associates.mk_mul_mk.symm]
simp [*, pow_succ, associates.mk_mul_mk.symm]
simp [*, pow_succ, associates.mk_mul_mk.symm]
induction n
rw [dvd_not_unit, dvd_not_unit, ne, ne, mk_eq_zero]
intro ane0
apply and_congr_right
split
rw forall_associated
contrapose!
intros h x hx hbax
rw [mk_mul_mk, mk_eq_mk_iff_associated] at hbax
cases hbax with u hu
apply h (x * ‚Üëu‚Åª¬π)
rw is_unit_mk at hx
rw associated.is_unit_iff
apply hx
use u
{ rw is_unit_mk at hx, rw associated.is_unit_iff, apply hx, use u, simp, }
simp
{ contrapose!, rw forall_associated, intros h x hx hbax, rw [mk_mul_mk, mk_eq_mk_iff_associated] at hbax, cases hbax with u hu, apply h (x * ‚Üëu‚Åª¬π), { rw is_unit_mk at hx, rw associated.is_unit_iff, apply hx, use u, simp, }, simp [‚Üê mul_assoc, ‚Üê hu] }
simp [‚Üê mul_assoc, ‚Üê hu]
rintro ‚ü®x, ‚ü®hx, rfl‚ü©‚ü©
use associates.mk x
simp [is_unit_mk, mk_mul_mk, hx]
rw [mul_comm, mul_prod_erase s f h]
simp
simp [finset.prod_insert (mt list.mem_to_finset.mp not_mem), prod_to_finset hl]
classical
apply finset.induction_on s
{ simp only [prod_empty, prod_const_one] }
simp only [prod_empty, prod_const_one]
intros _ _ H ih
simp only [prod_insert H, prod_mul_distrib, ih]
haveI := classical.dec_eq Œ±; by_cases h‚ÇÅ : a ‚àà s; by_cases h‚ÇÇ : b ‚àà s
haveI := classical.dec_eq Œ±; by_cases h‚ÇÅ : a ‚àà s
haveI := classical.dec_eq Œ±
by_cases h‚ÇÇ : b ‚àà s
by_cases h‚ÇÇ : b ‚àà s
by_cases h‚ÇÅ : a ‚àà s
{ exact prod_eq_mul_of_mem a b h‚ÇÅ h‚ÇÇ hn h‚ÇÄ }
exact prod_eq_mul_of_mem a b h‚ÇÅ h‚ÇÇ hn h‚ÇÄ
rw [hb h‚ÇÇ, mul_one]
apply prod_eq_single_of_mem a h‚ÇÅ
exact Œª c hc hca, h‚ÇÄ c hc ‚ü®hca, ne_of_mem_of_not_mem hc h‚ÇÇ‚ü©
{ rw [hb h‚ÇÇ, mul_one], apply prod_eq_single_of_mem a h‚ÇÅ, exact Œª c hc hca, h‚ÇÄ c hc ‚ü®hca, ne_of_mem_of_not_mem hc h‚ÇÇ‚ü© }
rw [ha h‚ÇÅ, one_mul]
apply prod_eq_single_of_mem b h‚ÇÇ
exact Œª c hc hcb, h‚ÇÄ c hc ‚ü®ne_of_mem_of_not_mem hc h‚ÇÅ, hcb‚ü©
{ rw [ha h‚ÇÅ, one_mul], apply prod_eq_single_of_mem b h‚ÇÇ, exact Œª c hc hcb, h‚ÇÄ c hc ‚ü®ne_of_mem_of_not_mem hc h‚ÇÅ, hcb‚ü© }
rw [ha h‚ÇÅ, hb h‚ÇÇ, mul_one]
exact trans (prod_congr rfl (Œª c hc, h‚ÇÄ c hc ‚ü®ne_of_mem_of_not_mem hc h‚ÇÅ, ne_of_mem_of_not_mem hc h‚ÇÇ‚ü©)) prod_const_one
split_ifs with h
rw [finset.prod_eq_single a, dif_pos rfl]
rw dif_neg
cc
{ intros, rw dif_neg, cc }
intros
{ rw [finset.prod_eq_single a, dif_pos rfl], { intros, rw dif_neg, cc }, { cc } }
cc
rw finset.prod_eq_one
rw dif_neg
intro
cc
intros
rw [univ_filter_zero_lt, sum_map, rel_embedding.coe_fn_to_embedding, coe_succ_embedding]
simp
rcases eq_or_ne x 0 with rfl|hx
{ simp }
exact ((smul_add_hom R M).flip x).map_finsum_of_injective (smul_left_injective R hx) _
lift t to finset Œ± using ht
lift s to finset Œ± using hs
classical
rw [‚Üê finset.coe_union, ‚Üê finset.coe_inter]
simp only [finprod_mem_coe_finset, finset.prod_union_inter]
rw [‚Üê prod_antidiagonal_swap, prod_antidiagonal_succ, ‚Üê prod_antidiagonal_swap]
refl
refine (multiset.prod_le_of_forall_le (s.val.map f) n _).trans _
{ simpa using h }
simpa using h
simpa
classical
split
contrapose!
{ contrapose!, exact Œª h, (sum_lt_top $ Œª i hi, (h i hi)).ne }
exact Œª h, (sum_lt_top $ Œª i hi, (h i hi)).ne
rintro ‚ü®i, his, hi‚ü©
rw [sum_eq_add_sum_diff_singleton his, hi, top_add]
simp only [lt_top_iff_ne_top, ne.def, sum_eq_top_iff, not_exists]
resetI
let i := as_iso ((forget (Algebra.{u} R)).map f)
let e : X ‚âÉ‚Çê[R] Y := { ..f, ..i.to_equiv }
exact ‚ü®(is_iso.of_iso e.to_Algebra_iso).1‚ü©
refine is_limit.of_faithful (forget (Algebra R)) (types.limit_cone_is_limit _) (Œª s, { .. }) (Œª s, rfl)
simp only [forget_map_eq_coe, alg_hom.map_one, functor.map_cone_œÄ_app]
refl
{ simp only [forget_map_eq_coe, alg_hom.map_one, functor.map_cone_œÄ_app], refl, }
simp only [forget_map_eq_coe, alg_hom.map_mul, functor.map_cone_œÄ_app]
intros x y
refl
{ intros x y, simp only [forget_map_eq_coe, alg_hom.map_mul, functor.map_cone_œÄ_app], refl, }
simp only [forget_map_eq_coe, alg_hom.map_zero, functor.map_cone_œÄ_app]
refl
{ simp only [forget_map_eq_coe, alg_hom.map_zero, functor.map_cone_œÄ_app], refl, }
simp only [forget_map_eq_coe, alg_hom.map_add, functor.map_cone_œÄ_app]
intros x y
refl
{ intros x y, simp only [forget_map_eq_coe, alg_hom.map_add, functor.map_cone_œÄ_app], refl, }
ext j
exact (s.œÄ.app j).commutes r
intros r
simp [h]
apply_instance
ext
induction x
induction x
have w' := congr_fun (congr_arg (Œª f : F.obj x_j ‚ü∂ s.X, (f : F.obj x_j ‚Üí s.X)) (w x_j)) x_x
erw w'
{ have w' := congr_fun (congr_arg (Œª f : F.obj x_j ‚ü∂ s.X, (f : F.obj x_j ‚Üí s.X)) (w x_j)) x_x, erw w', refl, }
refl
{ simp, }
simp
{ simp, }
simp
{ simp *, }
simp *
{ simp *, }
simp *
{ simp *, }
simp *
refl
exactI { preserves_limit := Œª F, limits.comp_preserves_limit (forget‚ÇÇ Ring SemiRing) (forget SemiRing) }
apply_instance
change comm_ring (F.obj j)
apply_instance
intros
simp only [preadditive.add_comp]
intros
simp only [preadditive.comp_add]
apply_instance
simp [h]
apply_instance
simp only [h, linear_map.map_zero]
simp
simp
fapply @quot.lift
intro x
{ intro x, exact quot.mk _ (smul s x) }
exact quot.mk _ (smul s x)
intros x x' r
apply quot.sound
exact relation.smul_1 s _ _ r
induction x
dsimp
apply quot.sound
apply relation.one_smul
refl
induction x
dsimp
apply quot.sound
apply relation.mul_smul
refl
induction x
induction y
dsimp
apply quot.sound
apply relation.smul_add
refl
refl
apply quot.sound
apply relation.smul_zero
induction x
dsimp
apply quot.sound
apply relation.add_smul
induction x
dsimp
apply quot.sound
apply relation.zero_smul
apply M.mk_eq
obtain ‚ü®k, f, g, hfg‚ü© := h
use [k, f, g]
simp only [category_theory.functor.comp_map, forget_map_eq_coe] at hfg
rw [linear_map.map_smul, linear_map.map_smul, hfg]
convert colimit.iso_colimit_cocone_Œπ_hom _ _; refl
refl
refl
convert colimit.iso_colimit_cocone_Œπ_hom _ _
tidy
match_target (R : Type u)
match_hyp x : (R : Type u)
exact x * x
simp
rw [mul_assoc x y (x * y), ‚Üêmul_assoc y x y, mul_comm y x, mul_assoc, mul_assoc]
apply_instance
rw function.left_inverse
simp
rw function.right_inverse
rw function.left_inverse
simp
simp
apply_instance
rw [commute.add_pow h, finset.sum_range_succ_comm, nat.sub_self, pow_zero, nat.choose_self]
rw [nat.cast_one, mul_one, mul_one]
congr' 1
convert finset.sum_eq_single 0 _ _
simp only [mul_one, one_mul, nat.choose_zero_right, nat.sub_zero, nat.cast_one, pow_zero]
{ simp only [mul_one, one_mul, nat.choose_zero_right, nat.sub_zero, nat.cast_one, pow_zero] }
intros b h1 h2
rw this
simp
{ rw this, simp }
suffices : (p.choose b : R) = 0
rw char_p.cast_eq_zero_iff R p
refine nat.prime.dvd_choose_self (pos_iff_ne_zero.mpr h2) _ (fact.out _)
{ intros b h1 h2, suffices : (p.choose b : R) = 0, { rw this, simp }, rw char_p.cast_eq_zero_iff R p, refine nat.prime.dvd_choose_self (pos_iff_ne_zero.mpr h2) _ (fact.out _), rwa ‚Üê finset.mem_range }
rwa ‚Üê finset.mem_range
intro h1
contrapose! h1
rw finset.mem_range
exact nat.prime.pos (fact.out _)
convert nat.lcm.char_p R S p p; simp
simp
convert nat.lcm.char_p R S p p
rwa [nat.cast_two] at this
dsimp [bit0] at h
simp only [(two_mul a).symm, (two_mul b).symm] at h
refine nat_mul_inj' _ two_ne_zero
exact_mod_cast h
simp [int_fract_pair.of, v_eq_q, fract]
exact a * b
rw [direct_sum.of_mul_of, semiring.direct_sum_mul]
apply units.dvd_mul_right
rcases hu with ‚ü®u, rfl‚ü©
rw gcd_zero_left
exact ‚ü®dvd_zero _, dvd_rfl‚ü©
rw gcd_val
exact ‚ü®IH‚ÇÇ, (dvd_mod_iff IH‚ÇÇ).1 IH‚ÇÅ‚ü©
have := @xgcd_aux_P _ _ _ a b a b 1 0 0 1 (by rw [P, mul_one, mul_zero, add_zero]) (by rw [P, mul_one, mul_zero, zero_add])
rw [P, mul_one, mul_zero, zero_add]
rw [P, mul_one, mul_zero, add_zero]
rwa [xgcd_aux_val, xgcd_val] at this
intros m n h
rcases h‚ÇÅ.lt_or_lt with H|H
apply (fpow_strict_mono (one_lt_inv h‚ÇÄ H)).injective
show x‚Åª¬π ^ m = x‚Åª¬π ^ n
rw [‚Üê fpow_neg_one, ‚Üê fpow_mul, ‚Üê fpow_mul, mul_comm _ m, mul_comm _ n, fpow_mul, fpow_mul, h]
{ apply (fpow_strict_mono (one_lt_inv h‚ÇÄ H)).injective, show x‚Åª¬π ^ m = x‚Åª¬π ^ n, rw [‚Üê fpow_neg_one, ‚Üê fpow_mul, ‚Üê fpow_mul, mul_comm _ m, mul_comm _ n, fpow_mul, fpow_mul, h], }
exact (fpow_strict_mono H).injective h
rw [ceil, neg_le, le_floor, int.cast_neg, neg_le_neg_iff]
ext
simp [h]
have h1 : gcd (d‚ÇÅ ^ k) b = 1
rw normalize_eq_one
rw ‚Üê normalize_gcd (d‚ÇÅ ^ k) b
apply is_unit_of_dvd_one
transitivity (gcd d‚ÇÅ b) ^ k
{ exact gcd_pow_left_dvd_pow_gcd }
exact gcd_pow_left_dvd_pow_gcd
apply is_unit.pow
apply is_unit_of_dvd_one
apply is_unit.dvd
apply gcd_dvd_gcd hd‚ÇÅ (dvd_refl b)
{ rw ‚Üê normalize_gcd (d‚ÇÅ ^ k) b, rw normalize_eq_one, apply is_unit_of_dvd_one, transitivity (gcd d‚ÇÅ b) ^ k, { exact gcd_pow_left_dvd_pow_gcd }, { apply is_unit.dvd, apply is_unit.pow, apply is_unit_of_dvd_one, rw ‚Üê hab, apply gcd_dvd_gcd hd‚ÇÅ (dvd_refl b) } }
rw ‚Üê hab
use d‚ÇÇ ^ k
have h2 : d‚ÇÅ ^ k ‚à£ a * b
rw [h, hc]
exact mul_pow d‚ÇÅ d‚ÇÇ k
{ use d‚ÇÇ ^ k, rw [h, hc], exact mul_pow d‚ÇÅ d‚ÇÇ k }
rw mul_comm at h2
rw [‚Üê one_mul a, ‚Üê h1]
have h3 : d‚ÇÅ ^ k ‚à£ a
apply dvd_gcd_mul_of_dvd_mul h2
{ rw [‚Üê one_mul a, ‚Üê h1], apply dvd_gcd_mul_of_dvd_mul h2 }
have h4 : d‚ÇÅ ^ k ‚â† 0
rw hdk at h3
apply absurd (zero_dvd_iff.mp h3) ha
intro hdk
{ intro hdk, rw hdk at h3, apply absurd (zero_dvd_iff.mp h3) ha }
tauto
simp
by_cases a ‚àà s; simp [IH, h]
simp [IH, h]
simp [IH, h]
by_cases a ‚àà s
unfold lcm
rw [‚Üê cons_erase h, fold_cons_left, ‚Üê lcm_assoc, lcm_same]
apply lcm_eq_of_associated_left (associated_normalize _)
have f_last : f (n + 1) n = (x + y) ^ n := by { dsimp [f], rw [nat.sub_sub, nat.add_comm, nat.sub_self, pow_zero, mul_one] }
dsimp [f]
rw [nat.sub_sub, nat.add_comm, nat.sub_self, pow_zero, mul_one]
have f_succ : ‚àÄ i, i ‚àà range n ‚Üí f (n + 1) i = y * f n i := Œª i hi, by { dsimp [f], have : commute y ((x + y) ^ i) := (h.symm.add_right (commute.refl y)).pow_right i, rw [‚Üê mul_assoc, this.eq, mul_assoc, ‚Üê pow_succ y (n - 1 - i)], congr' 2, rw [nat.add_sub_cancel, nat.sub_sub, add_comm 1 i], have : i + 1 + (n - (i + 1)) = n := nat.add_sub_of_le (mem_range.mp hi), rw [add_comm (i + 1)] at this, rw [‚Üê this, nat.add_sub_cancel, add_comm i 1, ‚Üê add_assoc, nat.add_sub_cancel] }
dsimp [f]
have : commute y ((x + y) ^ i) := (h.symm.add_right (commute.refl y)).pow_right i
rw [‚Üê mul_assoc, this.eq, mul_assoc, ‚Üê pow_succ y (n - 1 - i)]
congr' 2
rw [nat.add_sub_cancel, nat.sub_sub, add_comm 1 i]
have : i + 1 + (n - (i + 1)) = n := nat.add_sub_of_le (mem_range.mp hi)
rw [add_comm (i + 1)] at this
rw [‚Üê this, nat.add_sub_cancel, add_comm i 1, ‚Üê add_assoc, nat.add_sub_cancel]
rw [pow_succ (x + y), add_mul, sum_range_succ_comm, add_mul, f_last, add_assoc]
rw (((commute.refl x).add_right h).pow_right n).eq
congr' 1
rw [sum_congr rfl f_succ, ‚Üê mul_sum, pow_succ y, mul_assoc, ‚Üê mul_add y, ih]
convert neg_div_neg_eq (x^m - x^n) (1-x)
simp only [geom_sum_Ico hx hmn]
convert neg_div_neg_eq (x^m - x^n) (1-x); abel
abel
abel
let f := Œª (m i : ‚Ñï), (x + y) ^ i * y ^ (m - 1 - i)
change (‚àë i in range n, (f n) i) * x + y ^ n = (x + y) ^ n
induction n with n ih
rw [range_zero, sum_empty, zero_mul, zero_add, pow_zero, pow_zero]
{ rw [range_zero, sum_empty, zero_mul, zero_add, pow_zero, pow_zero] }
rw one_mul
rw [sub_eq_iff_eq_add, sub_add_eq_add_sub, sub_eq_iff_eq_add', add_sub_assoc]
by_cases h : P; simp [h]
simp [h]
simp [h]
by_cases h : P
rw [semiconj_by, mul_comm, ‚Üê units.mul_inv_eq_iff_eq_mul, mul_assoc, c.mul_inv, mul_one] at hc
exact hc
rw h
let iM : div_inv_monoid M := m‚ÇÅ
unfreezingI { cases m‚ÇÅ with mul‚ÇÅ _ one‚ÇÅ one_mul‚ÇÅ mul_one‚ÇÅ npow‚ÇÅ npow_zero‚ÇÅ npow_succ‚ÇÅ inv‚ÇÅ div‚ÇÅ div_eq_mul_inv‚ÇÅ gpow‚ÇÅ gpow_zero'‚ÇÅ gpow_succ'‚ÇÅ gpow_neg'‚ÇÅ, cases m‚ÇÇ with mul‚ÇÇ _ one‚ÇÇ one_mul‚ÇÇ mul_one‚ÇÇ npow‚ÇÇ npow_zero‚ÇÇ npow_succ‚ÇÇ inv‚ÇÇ div‚ÇÇ div_eq_mul_inv‚ÇÇ gpow‚ÇÇ gpow_zero'‚ÇÇ gpow_succ'‚ÇÇ gpow_neg'‚ÇÇ }
cases m‚ÇÅ with mul‚ÇÅ _ one‚ÇÅ one_mul‚ÇÅ mul_one‚ÇÅ npow‚ÇÅ npow_zero‚ÇÅ npow_succ‚ÇÅ inv‚ÇÅ div‚ÇÅ div_eq_mul_inv‚ÇÅ gpow‚ÇÅ gpow_zero'‚ÇÅ gpow_succ'‚ÇÅ gpow_neg'‚ÇÅ
cases m‚ÇÇ with mul‚ÇÇ _ one‚ÇÇ one_mul‚ÇÇ mul_one‚ÇÇ npow‚ÇÇ npow_zero‚ÇÇ npow_succ‚ÇÇ inv‚ÇÇ div‚ÇÇ div_eq_mul_inv‚ÇÇ gpow‚ÇÇ gpow_zero'‚ÇÇ gpow_succ'‚ÇÇ gpow_neg'‚ÇÇ
change mul‚ÇÅ = mul‚ÇÇ at h_mul
subst h_mul
have h_one : one‚ÇÅ = one‚ÇÇ
rw ‚Üêone_mul‚ÇÇ one‚ÇÅ
{ rw ‚Üêone_mul‚ÇÇ one‚ÇÅ, exact mul_one‚ÇÅ one‚ÇÇ }
exact mul_one‚ÇÅ one‚ÇÇ
subst h_one
have h_npow : npow‚ÇÅ = npow‚ÇÇ
ext n
induction n with d hd
{ rw [npow_zero‚ÇÅ, npow_zero‚ÇÇ] }
rw [npow_zero‚ÇÅ, npow_zero‚ÇÇ]
{ ext n, induction n with d hd, { rw [npow_zero‚ÇÅ, npow_zero‚ÇÇ] }, { rw [npow_succ‚ÇÅ, npow_succ‚ÇÇ, hd] } }
rw [npow_succ‚ÇÅ, npow_succ‚ÇÇ, hd]
subst h_npow
change inv‚ÇÅ = inv‚ÇÇ at h_inv
subst h_inv
have h_div : div‚ÇÅ = div‚ÇÇ
ext a b
convert (rfl : a * b‚Åª¬π = a * b‚Åª¬π)
{ exact div_eq_mul_inv‚ÇÅ a b }
exact div_eq_mul_inv‚ÇÅ a b
{ ext a b, convert (rfl : a * b‚Åª¬π = a * b‚Åª¬π), { exact div_eq_mul_inv‚ÇÅ a b }, { exact div_eq_mul_inv‚ÇÇ a b } }
exact div_eq_mul_inv‚ÇÇ a b
subst h_div
have h_gpow_aux : ‚àÄ n g, gpow‚ÇÅ (int.of_nat n) g = gpow‚ÇÇ (int.of_nat n) g
intros n g
induction n with n IH
convert (rfl : (1 : M) = 1)
{ exact gpow_zero'‚ÇÅ g }
exact gpow_zero'‚ÇÅ g
{ convert (rfl : (1 : M) = 1), { exact gpow_zero'‚ÇÅ g }, { exact gpow_zero'‚ÇÇ g } }
exact gpow_zero'‚ÇÇ g
{ intros n g, induction n with n IH, { convert (rfl : (1 : M) = 1), { exact gpow_zero'‚ÇÅ g }, { exact gpow_zero'‚ÇÇ g } }, { rw [gpow_succ'‚ÇÅ, gpow_succ'‚ÇÇ, IH] } }
rw [gpow_succ'‚ÇÅ, gpow_succ'‚ÇÇ, IH]
have h_gpow : gpow‚ÇÅ = gpow‚ÇÇ
ext z
cases z with z z
{ exact h_gpow_aux z x }
exact h_gpow_aux z x
rw [gpow_neg'‚ÇÅ, gpow_neg'‚ÇÇ]
congr'
{ ext z, cases z with z z, { exact h_gpow_aux z x }, { rw [gpow_neg'‚ÇÅ, gpow_neg'‚ÇÇ], congr', exact h_gpow_aux _ _ } }
exact h_gpow_aux _ _
subst h_gpow
cases f; cases g; cases h; refl
cases f; cases g; cases h
cases f; cases g
cases g
cases h
refl
cases f
rw [‚Üê one_hom.comp_apply, h, one_hom.comp_apply]
simp only [one_hom.map_one, one_hom.coe_comp, function.comp_app, one_hom.one_apply]
ext
simp only [map_one, coe_comp, function.comp_app, one_apply]
ext
refine_struct { mul := (*), .. }; tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
refine_struct { mul := (*), .. }
simp [coprod_apply, inl_apply, inr_apply, ‚Üê map_mul]
refine_struct { mul := (*), one := (1 : ulift Œ±), .. }
refine_struct { mul := (*), one := (1 : ulift Œ±), .. }; tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
rw [units.inv_mul, mul_one]
simp
simp
simp only [pow_zero, one_mul]
simp only [pow_succ, ihn, ‚Üê mul_assoc, (h.pow_left n).right_comm]
rw [bit1, gpow_add, gpow_bit0, gpow_one]
rw [mul_add, add_gsmul, one_gsmul]
dsimp [bit0]
rw [pow_zero]
rw [pow_succ]
exact mul_le_one h1 (pow_nonneg h0 _) (pow_le_one n h0 h1)
exact (one_left a).cast_int_mul_left m
rw [‚Üê mul_one (m : R)]
rw [‚Üê abs_of_nonneg hy]
exact abs_lt_abs_of_sq_lt_sq h
simp [*]
rw [mul_inv_rev', div_eq_mul_inv]
rw [div_eq_mul_inv, mul_assoc, mul_comm b, ‚Üê mul_assoc, div_eq_mul_inv]
rw [‚Üê mul_div_assoc, mul_comm, mul_div_assoc]
rw [gpow_coe_nat, gpow_coe_nat, ‚Üê pow_mul, ‚Üê gpow_coe_nat]
refl
rw [gpow_coe_nat, gpow_neg_succ_of_nat, ‚Üê pow_mul, coe_nat_mul_neg_succ, fpow_neg, inv_inj', ‚Üê gpow_coe_nat]
refl
rw [gpow_coe_nat, gpow_neg_succ_of_nat, ‚Üê inv_pow', ‚Üê pow_mul, neg_succ_mul_coe_nat, fpow_neg, inv_pow', inv_inj', ‚Üê gpow_coe_nat]
refl
rw [gpow_neg_succ_of_nat, gpow_neg_succ_of_nat, neg_succ_mul_neg_succ, inv_pow', inv_inv', ‚Üê pow_mul, ‚Üê gpow_coe_nat]
refl
rw [‚Üê congr_arg has_inv.inv (pow_one x), fpow_neg, ‚Üê gpow_coe_nat]
refl
simp [single_map_homological_complex, h]
dsimp [homology_functor]
ext
simp only [limits.cokernel.œÄ_desc, limits.comp_zero, homology.œÄ_map]
convert zero_comp
ext
simp
dsimp [homology_functor]
ext
simp only [homology.œÄ_map, preadditive.comp_add, ‚Üêpreadditive.add_comp]
congr
simp
ext
obtain ‚ü®k, w‚ÇÅ, w‚ÇÇ‚ü© := w
obtain ‚ü®k', w‚ÇÅ', w‚ÇÇ'‚ü© := w'
rw c‚ÇÅ.next_eq w‚ÇÅ w‚ÇÅ' at w‚ÇÇ
exact c‚ÇÇ.next_eq w‚ÇÇ w‚ÇÇ'
obtain ‚ü®k, w‚ÇÅ, w‚ÇÇ‚ü© := w
obtain ‚ü®k', w‚ÇÅ', w‚ÇÇ'‚ü© := w'
rw c‚ÇÇ.prev_eq w‚ÇÇ w‚ÇÇ' at w‚ÇÅ
exact c‚ÇÅ.prev_eq w‚ÇÅ w‚ÇÅ'
rcases h : c.next i with _ | ‚ü®j,w‚ü©
ext
{ refl }
refl
simp only [next, h]
dsimp
symmetry
apply zero_of_target_iso_zero
{ ext, { refl }, { dsimp, simp only [next, h], symmetry, apply zero_of_target_iso_zero, exact X_next_iso_zero _ h } }
exact X_next_iso_zero _ h
refl
dsimp
simp [next, h]
ext
rw [if_pos rfl, category.id_comp]
change ite (1 = 0 + 1) (ùüô X‚ÇÅ ‚â´ d‚ÇÄ) 0 = d‚ÇÄ
dsimp [prev_d]
rcases c.prev j with _|‚ü®j',w‚ü©
{ exact zero_comp.symm, }
exact zero_comp.symm
dsimp [prev_d]
simp
simp
refl
simp
refl
simpa using w
simp
ext
simp
simp
simp
simp
ext
simp only [indicator]
split_ifs
refl
{ refl }
rw mul_zero
funext
simpa [ha] using hfg ha
simpa [ha] using hg ha
exact subset.trans h1 h2
rw mul_indicator_eq_self at h1 ‚ä¢
simp [‚Üêmul_assoc]
rw [‚Üê f.map_mul, inv_of_mul_self, f.map_one]
rw [‚Üê f.map_mul, mul_inv_of_self, f.map_one]
rw [mul_one a, div_eq_mul_inv, mul_comm b, mul_inv_cancel_left]
rw ‚Üê mul_inf_eq_mul_inf_mul 1 (b / a) a
rw inf_comm
rw div_eq_mul_inv
nth_rewrite 0 ‚Üê inv_inv b
rw [‚Üê mul_inv, mul_comm b‚Åª¬π, ‚Üê div_eq_mul_inv]
rw one_inv
rw [‚Üê inv_sup_eq_inv_inf_inv, ‚Üê div_eq_mul_inv]
simp
ext
simp
ext
simp [nat.succ_eq_one_add, add_nsmul]
rw [lie_module.is_trivial.trivial, lie_ring.of_associative_ring_bracket, mul_comm, sub_self, linear_map.to_fun_eq_coe, linear_map.map_zero]
ext
refl
ext
refl
erw mem_skew_adjoint_matrices_submodule
simp only [matrix.is_skew_adjoint, matrix.is_adjoint_pair, matrix.mul_one, matrix.one_mul]
apply matrix.nonsing_inv_left_right
exact PB_inv l R
ext i j
rcases i with ‚ü®‚ü®i‚ÇÅ | i‚ÇÇ‚ü© | i‚ÇÉ‚ü©; rcases j with ‚ü®‚ü®j‚ÇÅ | j‚ÇÇ‚ü© | j‚ÇÉ‚ü©; simp only [indefinite_diagonal, matrix.diagonal, equiv.sum_assoc_apply_in1, matrix.reindex_lie_equiv_apply, matrix.minor_apply, equiv.symm_symm, matrix.reindex_apply, sum.elim_inl, if_true, eq_self_iff_true, matrix.one_apply_eq, matrix.from_blocks_apply‚ÇÅ‚ÇÅ, dmatrix.zero_apply, equiv.sum_assoc_apply_in2, if_false, matrix.from_blocks_apply‚ÇÅ‚ÇÇ, matrix.from_blocks_apply‚ÇÇ‚ÇÅ, matrix.from_blocks_apply‚ÇÇ‚ÇÇ, equiv.sum_assoc_apply_in3, sum.elim_inr]; congr
rcases i with ‚ü®‚ü®i‚ÇÅ | i‚ÇÇ‚ü© | i‚ÇÉ‚ü©; rcases j with ‚ü®‚ü®j‚ÇÅ | j‚ÇÇ‚ü© | j‚ÇÉ‚ü©; simp only [indefinite_diagonal, matrix.diagonal, equiv.sum_assoc_apply_in1, matrix.reindex_lie_equiv_apply, matrix.minor_apply, equiv.symm_symm, matrix.reindex_apply, sum.elim_inl, if_true, eq_self_iff_true, matrix.one_apply_eq, matrix.from_blocks_apply‚ÇÅ‚ÇÅ, dmatrix.zero_apply, equiv.sum_assoc_apply_in2, if_false, matrix.from_blocks_apply‚ÇÅ‚ÇÇ, matrix.from_blocks_apply‚ÇÇ‚ÇÅ, matrix.from_blocks_apply‚ÇÇ‚ÇÇ, equiv.sum_assoc_apply_in3, sum.elim_inr]
rcases i with ‚ü®‚ü®i‚ÇÅ | i‚ÇÇ‚ü© | i‚ÇÉ‚ü©; rcases j with ‚ü®‚ü®j‚ÇÅ | j‚ÇÇ‚ü© | j‚ÇÉ‚ü©
rcases i with ‚ü®‚ü®i‚ÇÅ | i‚ÇÇ‚ü© | i‚ÇÉ‚ü©
rcases j with ‚ü®‚ü®j‚ÇÅ | j‚ÇÇ‚ü© | j‚ÇÉ‚ü©
rcases j with ‚ü®‚ü®j‚ÇÅ | j‚ÇÇ‚ü© | j‚ÇÉ‚ü©
rcases j with ‚ü®‚ü®j‚ÇÅ | j‚ÇÇ‚ü© | j‚ÇÉ‚ü©
simp only [indefinite_diagonal, matrix.diagonal, equiv.sum_assoc_apply_in1, matrix.reindex_lie_equiv_apply, matrix.minor_apply, equiv.symm_symm, matrix.reindex_apply, sum.elim_inl, if_true, eq_self_iff_true, matrix.one_apply_eq, matrix.from_blocks_apply‚ÇÅ‚ÇÅ, dmatrix.zero_apply, equiv.sum_assoc_apply_in2, if_false, matrix.from_blocks_apply‚ÇÅ‚ÇÇ, matrix.from_blocks_apply‚ÇÇ‚ÇÅ, matrix.from_blocks_apply‚ÇÇ‚ÇÇ, equiv.sum_assoc_apply_in3, sum.elim_inr]
simp only [indefinite_diagonal, matrix.diagonal, equiv.sum_assoc_apply_in1, matrix.reindex_lie_equiv_apply, matrix.minor_apply, equiv.symm_symm, matrix.reindex_apply, sum.elim_inl, if_true, eq_self_iff_true, matrix.one_apply_eq, matrix.from_blocks_apply‚ÇÅ‚ÇÅ, dmatrix.zero_apply, equiv.sum_assoc_apply_in2, if_false, matrix.from_blocks_apply‚ÇÅ‚ÇÇ, matrix.from_blocks_apply‚ÇÇ‚ÇÅ, matrix.from_blocks_apply‚ÇÇ‚ÇÇ, equiv.sum_assoc_apply_in3, sum.elim_inr]
simp only [indefinite_diagonal, matrix.diagonal, equiv.sum_assoc_apply_in1, matrix.reindex_lie_equiv_apply, matrix.minor_apply, equiv.symm_symm, matrix.reindex_apply, sum.elim_inl, if_true, eq_self_iff_true, matrix.one_apply_eq, matrix.from_blocks_apply‚ÇÅ‚ÇÅ, dmatrix.zero_apply, equiv.sum_assoc_apply_in2, if_false, matrix.from_blocks_apply‚ÇÅ‚ÇÇ, matrix.from_blocks_apply‚ÇÇ‚ÇÅ, matrix.from_blocks_apply‚ÇÇ‚ÇÇ, equiv.sum_assoc_apply_in3, sum.elim_inr]
simp only [indefinite_diagonal, matrix.diagonal, equiv.sum_assoc_apply_in1, matrix.reindex_lie_equiv_apply, matrix.minor_apply, equiv.symm_symm, matrix.reindex_apply, sum.elim_inl, if_true, eq_self_iff_true, matrix.one_apply_eq, matrix.from_blocks_apply‚ÇÅ‚ÇÅ, dmatrix.zero_apply, equiv.sum_assoc_apply_in2, if_false, matrix.from_blocks_apply‚ÇÅ‚ÇÇ, matrix.from_blocks_apply‚ÇÇ‚ÇÅ, matrix.from_blocks_apply‚ÇÇ‚ÇÇ, equiv.sum_assoc_apply_in3, sum.elim_inr]
simp only [indefinite_diagonal, matrix.diagonal, equiv.sum_assoc_apply_in1, matrix.reindex_lie_equiv_apply, matrix.minor_apply, equiv.symm_symm, matrix.reindex_apply, sum.elim_inl, if_true, eq_self_iff_true, matrix.one_apply_eq, matrix.from_blocks_apply‚ÇÅ‚ÇÅ, dmatrix.zero_apply, equiv.sum_assoc_apply_in2, if_false, matrix.from_blocks_apply‚ÇÅ‚ÇÇ, matrix.from_blocks_apply‚ÇÇ‚ÇÅ, matrix.from_blocks_apply‚ÇÇ‚ÇÇ, equiv.sum_assoc_apply_in3, sum.elim_inr]
simp only [indefinite_diagonal, matrix.diagonal, equiv.sum_assoc_apply_in1, matrix.reindex_lie_equiv_apply, matrix.minor_apply, equiv.symm_symm, matrix.reindex_apply, sum.elim_inl, if_true, eq_self_iff_true, matrix.one_apply_eq, matrix.from_blocks_apply‚ÇÅ‚ÇÅ, dmatrix.zero_apply, equiv.sum_assoc_apply_in2, if_false, matrix.from_blocks_apply‚ÇÅ‚ÇÇ, matrix.from_blocks_apply‚ÇÇ‚ÇÅ, matrix.from_blocks_apply‚ÇÇ‚ÇÇ, equiv.sum_assoc_apply_in3, sum.elim_inr]
simp only [indefinite_diagonal, matrix.diagonal, equiv.sum_assoc_apply_in1, matrix.reindex_lie_equiv_apply, matrix.minor_apply, equiv.symm_symm, matrix.reindex_apply, sum.elim_inl, if_true, eq_self_iff_true, matrix.one_apply_eq, matrix.from_blocks_apply‚ÇÅ‚ÇÅ, dmatrix.zero_apply, equiv.sum_assoc_apply_in2, if_false, matrix.from_blocks_apply‚ÇÅ‚ÇÇ, matrix.from_blocks_apply‚ÇÇ‚ÇÅ, matrix.from_blocks_apply‚ÇÇ‚ÇÇ, equiv.sum_assoc_apply_in3, sum.elim_inr]
simp only [indefinite_diagonal, matrix.diagonal, equiv.sum_assoc_apply_in1, matrix.reindex_lie_equiv_apply, matrix.minor_apply, equiv.symm_symm, matrix.reindex_apply, sum.elim_inl, if_true, eq_self_iff_true, matrix.one_apply_eq, matrix.from_blocks_apply‚ÇÅ‚ÇÅ, dmatrix.zero_apply, equiv.sum_assoc_apply_in2, if_false, matrix.from_blocks_apply‚ÇÅ‚ÇÇ, matrix.from_blocks_apply‚ÇÇ‚ÇÅ, matrix.from_blocks_apply‚ÇÇ‚ÇÇ, equiv.sum_assoc_apply_in3, sum.elim_inr]
simp only [indefinite_diagonal, matrix.diagonal, equiv.sum_assoc_apply_in1, matrix.reindex_lie_equiv_apply, matrix.minor_apply, equiv.symm_symm, matrix.reindex_apply, sum.elim_inl, if_true, eq_self_iff_true, matrix.one_apply_eq, matrix.from_blocks_apply‚ÇÅ‚ÇÅ, dmatrix.zero_apply, equiv.sum_assoc_apply_in2, if_false, matrix.from_blocks_apply‚ÇÅ‚ÇÇ, matrix.from_blocks_apply‚ÇÇ‚ÇÅ, matrix.from_blocks_apply‚ÇÇ‚ÇÇ, equiv.sum_assoc_apply_in3, sum.elim_inr]
congr
congr
erw lie_submodule.lie_span_le
rw map_le_iff_le_comap
obtain ‚ü®‚ü®y‚ÇÅ, hy‚ÇÅ‚ü©, ‚ü®y‚ÇÇ, hy‚ÇÇ‚ü©, hx‚ü© := hx
intros x hx
rw ‚Üê hx
let fy‚ÇÅ : ‚Ü•(map f I‚ÇÅ) := ‚ü®f y‚ÇÅ, mem_map hy‚ÇÅ‚ü©
let fy‚ÇÇ : ‚Ü•(map f I‚ÇÇ) := ‚ü®f y‚ÇÇ, mem_map hy‚ÇÇ‚ü©
change _ ‚àà comap f ‚ÅÖmap f I‚ÇÅ, map f I‚ÇÇ‚ÅÜ
simp only [submodule.coe_mk, mem_comap, lie_hom.map_lie]
exact lie_submodule.lie_coe_mem_lie _ _ fy‚ÇÅ fy‚ÇÇ
ext m
change mk ‚ÅÖ‚ÅÖx, y‚ÅÜ, m‚ÅÜ = mk (‚ÅÖx, ‚ÅÖy, m‚ÅÜ‚ÅÜ - ‚ÅÖy, ‚ÅÖx, m‚ÅÜ‚ÅÜ)
congr
apply lie_lie
rw [is_lie_abelian_iff_center_eq_top R L, center_eq_bot_of_semisimple] at h
exact (lie_submodule.subsingleton_iff R L L).mp (subsingleton_of_bot_eq_top h)
rw [‚Üê coe_to_submodule, Inf_coe_to_submodule, submodule.Inf_coe]
ext x
simpa only [mem_Inter, mem_set_of_eq, forall_apply_eq_imp_iff‚ÇÇ, exists_imp_distrib]
apply set_coe.ext
exact lie_hom.map_lie (‚Üëe : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) ‚Üëx ‚Üëy
rw ‚Üêh
refl
intros h x hx
intros h x hx
split
split; intros h x hx
rw mem_ker at h
exact h
{ specialize h hx, rw mem_ker at h, exact h, }
specialize h hx
apply h x hx
rw mem_ker
suffices : (lift_lie R L M N P f : M ‚äó[R] N ‚Üí‚Çó[R] P) = lift R L M N P f
{ rw [‚Üê this, lie_module_hom.coe_to_linear_map], }
rw [‚Üê this, lie_module_hom.coe_to_linear_map]
ext m n
simp only [lift_lie, linear_equiv.trans_apply, lie_module_equiv.coe_to_linear_equiv, coe_linear_map_max_triv_linear_map_equiv_lie_module_hom, coe_max_triv_equiv_apply, coe_linear_map_max_triv_linear_map_equiv_lie_module_hom_symm]
simp only [coe_lift_lie_eq_lift_coe, lie_module_hom.coe_to_linear_map, lift_apply]
rw [‚Üêfunction.comp_apply (lift R f) (Œπ R) x, Œπ_comp_lift]
have h‚ÇÄ : (0 : L ‚Üí R) ‚àò (‚ä§ : lie_subalgebra R L).incl = 0
ext
refl
{ ext, refl, }
rw [‚Üê lie_submodule.coe_to_submodule_eq_iff, lie_submodule.top_coe_submodule, ‚Üê h‚ÇÄ, coe_weight_space_of_top, ‚Üê infi_max_gen_zero_eigenspace_eq_top_of_nilpotent R L M]
refl
simp only [zero_smul]
simp only [one_smul, add_smul, ih]
simp only [one_smul, sub_smul, ih]
simp only [‚Üêgsmul_eq_smul_cast, f.map_gsmul]
rw [‚Üêneg_neg c, neg_smul, neg_smul (-c), neg_lt_neg_iff]
exact smul_lt_smul_of_pos h (neg_pos_of_neg hc)
rw [‚Üêneg_neg c, neg_smul, neg_smul (-c), neg_lt_neg_iff]
exact smul_lt_smul_iff_of_pos (neg_pos_of_neg hc)
intros
ext x
apply smul_add
intros
ext x
apply smul_zero
rintros x ‚ü®y, h, rfl‚ü© i hi
exact smul_mem_smul_set (h i hi)
rw [infi, Inf_coe]; ext a; simp; exact ‚ü®Œª h i, h _ i rfl, Œª h i x e, e ‚ñ∏ h _‚ü©
rw [infi, Inf_coe]; ext a; simp
rw [infi, Inf_coe]; ext a
ext a
simp
rw [infi, Inf_coe]
ext
simp [smul_zero]
ext
simp [smul_add]
ext
simp only [mem_filter, mem_product, hs, and_comm]
simp only [mem_filter, mem_support_iff, not_and, not_not] at hp ‚ä¢
by_cases h1 : f p.1 = 0
{ rw [h1, zero_mul] }
rw [h1, zero_mul]
rw [hp hps h1, mul_zero]
simp [ha]
{ simp [ha] }
by_cases ha : a = 0
refine (mul_self_eq_mul_self_iff.mp (by rw [‚Üê abv.map_mul, neg_mul_neg, abv.map_mul])).resolve_right _
rw [‚Üê abv.map_mul, neg_mul_neg, abv.map_mul]
exact ((neg_lt_zero.mpr (abv.pos ha)).trans (abv.pos (neg_ne_zero.mpr ha))).ne'
rw [‚Üê neg_sub, abv_neg abv]
exacts [iff.rfl, eq_comm, iff.rfl]
cases o
rw [mul_comm, le_div_iff hc]
rw [div_eq_mul_one_div a c, div_eq_mul_one_div b c]
exact mul_le_mul_of_nonneg_right h (one_div_nonneg.2 hc)
rcases lt_trichotomy b 0 with (hb|rfl|hb)
{ simp [hb, hb.not_lt, hb.ne, div_lt_one_of_neg] }
simp [hb, hb.not_lt, hb.ne, div_lt_one_of_neg]
{ simp [zero_lt_one], }
simp [zero_lt_one]
simp [hb, hb.not_lt, div_lt_one, hb.ne.symm]
simpa using inv_le_inv_of_le ha h
rwa add_halves at this
rw [sub_add_eq_sub_sub, sub_self, zero_sub]
refine ‚ü®eq_or_eq_neg_of_abs_eq, _‚ü©
rintro (rfl|rfl); simp only [abs_neg, abs_of_nonneg hb]
simp only [abs_neg, abs_of_nonneg hb]
simp only [abs_neg, abs_of_nonneg hb]
rintro (rfl|rfl)
rw [‚Üê mul_lt_mul_iff_right a, inv_mul_self, one_mul]
rw [div_le_iff_le_mul, mul_comm]
exact rfl
refine with_top.rec_top_coe _ _
{ simpa }
simpa
intro
rw [‚Üêwith_top.coe_zero, ‚Üêwith_top.coe_add, zero_add]
refine with_top.rec_top_coe _ _
{ simpa }
simpa
intro
rw [‚Üêwith_top.coe_zero, ‚Üêwith_top.coe_add, add_zero]
haveI := @linear_order.decidable_le Œ± _; exact ‚ü®nonneg_and_nonneg_or_nonpos_and_nonpos_of_mul_nnonneg, Œª h, h.elim (and_imp.2 decidable.mul_nonneg) (and_imp.2 decidable.mul_nonneg_of_nonpos_of_nonpos)‚ü©
exact ‚ü®nonneg_and_nonneg_or_nonpos_and_nonpos_of_mul_nnonneg, Œª h, h.elim (and_imp.2 decidable.mul_nonneg) (and_imp.2 decidable.mul_nonneg_of_nonpos_of_nonpos)‚ü©
haveI := @linear_order.decidable_le Œ± _
rw [‚Üê abs_mul_abs_self, ‚Üê abs_mul_abs_self b]
exact mul_self_le_mul_self_iff (abs_nonneg a) (abs_nonneg b)
cases abs_choice b with h h; simp only [h, dvd_neg]
simp only [h, dvd_neg]
simp only [h, dvd_neg]
cases abs_choice b with h h
rw [mul_add, mul_two, add_assoc]
haveI := @linear_order.decidable_le Œ± _; exact lt_of_not_ge (assume h1 : b ‚â§ a, have h2 : c * b ‚â§ c * a, from decidable.mul_le_mul_of_nonneg_left h1 hc, h2.not_lt h)
exact lt_of_not_ge (assume h1 : b ‚â§ a, have h2 : c * b ‚â§ c * a, from decidable.mul_le_mul_of_nonneg_left h1 hc, h2.not_lt h)
haveI := @linear_order.decidable_le Œ± _
haveI := @linear_order.decidable_le Œ± _; exact lt_of_not_ge (assume h1 : b ‚â§ a, have h2 : b * c ‚â§ a * c, from decidable.mul_le_mul_of_nonneg_right h1 hc, h2.not_lt h)
exact lt_of_not_ge (assume h1 : b ‚â§ a, have h2 : b * c ‚â§ a * c, from decidable.mul_le_mul_of_nonneg_right h1 hc, h2.not_lt h)
haveI := @linear_order.decidable_le Œ± _
haveI := @linear_order.decidable_le Œ± _; exact ‚ü®Œª h, nonneg_of_mul_nonneg_right h ha, Œª h, decidable.mul_nonneg h ha.le‚ü©
exact ‚ü®Œª h, nonneg_of_mul_nonneg_right h ha, Œª h, decidable.mul_nonneg h ha.le‚ü©
haveI := @linear_order.decidable_le Œ± _
classical; exact decidable.mul_le_mul_of_nonpos_right
exact decidable.mul_le_mul_of_nonpos_right
classical
rwa [‚Üê hc, zero_smul, zero_smul] at h
rw [sub_sub', add_sub_cancel_of_le h]
exact hc.lt_sub_iff_right_of_le h
rw [add_comm]
rw [hc.lt_sub_iff_left, add_sub_cancel_of_le h]
refine ‚ü®_, Œª h, ha.sub_lt_self hb h.1 h.2‚ü©
intro h
refine ‚ü®(zero_le _).trans_lt h, (zero_le b).lt_of_ne _‚ü©
rintro rfl
rw [sub_zero'] at h
exact h.false
apply min_le_left
rw [‚Üê sub_min, sub_add_cancel_of_le]
simpa using leading_coeff_multiset_prod' (s.1.map f) (by simpa using h)
simpa using h
refine { le_iff_exists_add := Œª _ _, iff_of_true _ ‚ü®star, subsingleton.elim _ _‚ü©, .. punit.comm_ring, .. punit.complete_boolean_algebra, .. }
refine { le_iff_exists_add := Œª _ _, iff_of_true _ ‚ü®star, subsingleton.elim _ _‚ü©, .. punit.comm_ring, .. punit.complete_boolean_algebra, .. }; intros; trivial
refine { le_iff_exists_add := Œª _ _, iff_of_true _ ‚ü®star, subsingleton.elim _ _‚ü©, .. punit.comm_ring, .. punit.complete_boolean_algebra, .. }; intros
intros
intros
trivial
trivial
apply (act x).symm.injective
rintro rfl
refl
split
op_induction x
simp
ext
ext; simp; ring_exp
ext; simp
simp
simp
simp
simp
ring_exp
ring_exp
ring_exp
ring_exp
simpa only [le_antisymm_iff, norm_sq_nonneg, and_true] using @norm_sq_eq_zero _ _ a
simp only [lift, algebra.algebra_map_eq_smul_one]
simp only [add_mul]
simp only [add_mul, mul_add, smul_mul_assoc, mul_smul_comm, one_mul, mul_one, ‚Üêalgebra.smul_def, smul_add, smul_smul]
simp only [i_mul_i, j_mul_j, i_mul_j, j_mul_i, i_mul_k, k_mul_i, k_mul_j, j_mul_k, k_mul_k]
simp only [smul_smul, smul_neg, sub_eq_add_neg, add_smul, ‚Üêadd_assoc, mul_neg_eq_neg_mul_symm, neg_smul]
simp only [mul_right_comm _ _ (c‚ÇÅ * c‚ÇÇ), mul_comm _ (c‚ÇÅ * c‚ÇÇ)]
simp only [mul_comm _ c‚ÇÅ, mul_right_comm _ _ c‚ÇÅ]
simp only [mul_comm _ c‚ÇÇ, mul_right_comm _ _ c‚ÇÇ]
simp only [‚Üêmul_comm c‚ÇÅ c‚ÇÇ, ‚Üêmul_assoc]
simp [sub_eq_add_neg, add_smul, ‚Üêadd_assoc]
abel
simp only [semiconj_by, left_distrib, right_distrib, ha.eq, hb.eq]
simp only [semiconj_by, h.eq, neg_mul_eq_neg_mul_symm, mul_neg_eq_neg_mul_symm]
by_cases h : P; simp [h]
simp [h]
simp [h]
by_cases h : P
rw [bit1, bit0, two_mul]
simpa only [sub_eq_add_neg, neg_mul_eq_neg_mul] using add_mul a (-b) c
rw [mul_add, mul_one, mul_self, add_self]
rw [‚Üêadd_eq_zero, mul_add_mul]
simp
simp
cases x
cases x; simp
simp
dsimp
rw mk_ring_hom_rel h
classical
rw support_single
split_ifs; simp
simp
simp
split_ifs
simpa using h
cases le_total x y with h h
rw [add_eq_left h, add_eq_left (pow_le_pow_of_le_left' h _)]
{ rw [add_eq_left h, add_eq_left (pow_le_pow_of_le_left' h _)] }
rw [add_eq_right h, add_eq_right (pow_le_pow_of_le_left' h _)]
rw [‚Üê restrict_stalk_iso_hom_eq_germ, category.assoc, iso.hom_inv_id, category.comp_id]
rw [simplex_category.hom_zero_zero ([0].const 0), X.map_id, category.comp_id]
dsimp
simp only [tsum_fintype, nnnorm_change_origin_series_term]
rw right_inv
exact false.elim (zero_lt_two.not_le hn)
cases n
{ exact false.elim (zero_lt_two.not_le hn) }
exact false.elim (one_lt_two.not_le hn)
cases n
{ exact false.elim (one_lt_two.not_le hn) }
simp only [right_inv, neg_inj]
congr' 1
ext v
dec_trivial
have N : 0 < n + 2
have : (p 1) (Œª (i : fin 1), 0) = 0 := continuous_multilinear_map.map_zero _
simp [comp_right_inv_aux1 N, lt_irrefl n, this, comp_right_inv_aux2]
rw [is_equivalent, is_o_const_iff h]
intro h
intro h
split
split; intro h; [ { have := h.sub tendsto_const_nhds, rw zero_sub (-c) at this }, { have := h.sub tendsto_const_nhds, rw ‚Üê sub_self c} ]; convert this; try { ext }; simp
split; intro h; [ { have := h.sub tendsto_const_nhds, rw zero_sub (-c) at this }, { have := h.sub tendsto_const_nhds, rw ‚Üê sub_self c} ]; convert this; try { ext }
split; intro h; [ { have := h.sub tendsto_const_nhds, rw zero_sub (-c) at this }, { have := h.sub tendsto_const_nhds, rw ‚Üê sub_self c} ]; convert this
split; intro h; [ { have := h.sub tendsto_const_nhds, rw zero_sub (-c) at this }, { have := h.sub tendsto_const_nhds, rw ‚Üê sub_self c} ]
split; intro h
rw zero_sub (-c) at this
have := h.sub tendsto_const_nhds
rw ‚Üê sub_self c
have := h.sub tendsto_const_nhds
try { ext }
try { ext }
ext
simp
simp
convert this
convert this
rcases (em $ c = 0) with ‚ü®rfl, h‚ü©
exact (tendsto_congr' $ is_equivalent_zero_iff_eventually_zero.mp hu).mpr tendsto_const_nhds
{ exact (tendsto_congr' $ is_equivalent_zero_iff_eventually_zero.mp hu).mpr tendsto_const_nhds }
exact (is_equivalent_const_iff_tendsto h).mp hu
from mt norm_eq_zero.mp hc
have cne0 : ‚à•c‚à• ‚â† 0
simp only [norm_smul]
rw [‚Üêis_O_norm_left]
rw [is_O_const_mul_left_iff cne0, is_O_norm_left]
simp only [is_o, is_O_with_pi, le_of_lt] { contextual := tt }
exact ‚ü®Œª h i c hc, h hc i, Œª h c hc i, h i hc‚ü©
unfold is_O_with
subst c‚ÇÇ
apply filter.eventually_congr
filter_upwards [hf, hg]
assume x e‚ÇÅ e‚ÇÇ
rw [e‚ÇÅ, e‚ÇÇ]
exact forall_congr (Œª _, (forall_congr (Œª _, is_O_with_neg_left)))
unfold is_o
rw tendsto_congr' pow_div_pow_eventually_eq_at_top
apply tendsto_fpow_at_top_at_top
linarith
split
rintros ‚ü®c, hf, hf'‚ü©
rw hf.fderiv
{ rintros ‚ü®c, hf, hf'‚ü©, rw hf.fderiv, exact hf' }
exact hf'
intros H
by_cases h : differentiable_at ‚Ñù f x
{ exact ‚ü®fderiv ‚Ñù f x, h.has_fderiv_at, H‚ü©, }
exact ‚ü®fderiv ‚Ñù f x, h.has_fderiv_at, H‚ü©
cases subsingleton_or_nontrivial X with w w; resetI
resetI
resetI
cases subsingleton_or_nontrivial X with w w
exact ‚ü®(0 : X ‚ÜíL[‚Ñù] Y), has_fderiv_at_of_subsingleton f x, is_conformal_map_of_subsingleton 0‚ü©
{ exact ‚ü®(0 : X ‚ÜíL[‚Ñù] Y), has_fderiv_at_of_subsingleton f x, is_conformal_map_of_subsingleton 0‚ü©, }
exfalso
exact H.ne_zero (fderiv_zero_of_not_differentiable_at h)
have := hf.iterate hx n
rwa [continuous_linear_map.smul_right_one_pow] at this
convert hc.mul ((has_strict_deriv_at_inv hx).comp x hd)
{ simp only [div_eq_mul_inv] }
simp only [div_eq_mul_inv]
ring
field_simp
rw [‚Üê Iic_diff_right, has_deriv_within_at_diff_singleton]
rwa hL.has_deriv_at_filter_iff hx rfl
have := hc.smul (has_deriv_within_at_const x s f)
rwa [smul_zero, zero_add] at this
rw [fderiv_within_zero_of_not_differentiable_within_at h, fderiv_within_zero_of_not_differentiable_within_at, neg_zero]
simpa
rw [‚Üê fderiv_within_univ, ‚Üê fderiv_within_univ]
exact iso.comp_fderiv_within unique_diff_within_at_univ
rw [has_fderiv_at, has_fderiv_at_filter, is_o_iff]
exact (Œª c hc, tendsto_id.prod_mk_nhds tendsto_const_nhds (is_o_iff.1 hf hc))
unfold has_fderiv_at_filter at hg
have : is_o (Œª x', g (f x') - g (f x) - g' (f x' - f x)) (Œª x', f x' - f x) L
from hg.comp_tendsto (le_refl _)
have eq‚ÇÅ : is_o (Œª x', g (f x') - g (f x) - g' (f x' - f x)) (Œª x', x' - x) L
from this.trans_is_O hf.is_O_sub
have eq‚ÇÇ : is_o (Œª x', f x' - f x - f' (x' - x)) (Œª x', x' - x) L
from hf
have : is_O (Œª x', g' (f x' - f x - f' (x' - x))) (Œª x', f x' - f x - f' (x' - x)) L
from g'.is_O_comp _ _
have : is_o (Œª x', g' (f x' - f x - f' (x' - x))) (Œª x', x' - x) L
from this.trans_is_o eq‚ÇÇ
have eq‚ÇÉ : is_o (Œª x', g' (f x' - f x) - (g' (f' (x' - x)))) (Œª x', x' - x) L
refine this.congr_left _
simp
exact eq‚ÇÅ.triangle eq‚ÇÉ
rcases metric.mem_nhds_iff.1 hf with ‚ü®Œµ, Œµpos, hŒµ‚ü©
have A : (interior (metric.ball x Œµ)).nonempty
rwa [metric.is_open_ball.interior_eq, metric.nonempty_ball]
exact convex.second_derivative_within_at_symmetric (convex_ball x Œµ) A (Œª y hy, hŒµ (interior_subset hy)) (metric.mem_ball_self Œµpos) hx.has_fderiv_within_at v w
simp [hf.implicit_to_local_homeomorph_of_complemented_apply]
convert (implicit_function_data_of_complemented f f' hf hf' hker).implicit_function_has_strict_fderiv_at (subtype_val f'.ker) _ _
convert (implicit_function_data_of_complemented f f' hf hf' hker).implicit_function_has_strict_fderiv_at (subtype_val f'.ker) _ _; [skip, ext, ext]; simp [classical.some_spec hker]
convert (implicit_function_data_of_complemented f f' hf hf' hker).implicit_function_has_strict_fderiv_at (subtype_val f'.ker) _ _; [skip, ext, ext]
ext
ext
simp [classical.some_spec hker]
simp [classical.some_spec hker]
simp [classical.some_spec hker]
skip
refine ‚ü®Œõ, Œõ‚ÇÄ, _, _‚ü©
simpa only [ne.def, prod.ext_iff, linear_equiv.map_eq_zero_iff, prod.fst_zero] using h0
{ simpa only [ne.def, prod.ext_iff, linear_equiv.map_eq_zero_iff, prod.fst_zero] using h0 }
simpa [mul_comm] using hsum x
ext x
letI := classical.dec_eq Œπ
replace hextr : is_local_extr_on œÜ {x | (Œª i, f i x) = (Œª i, f i x‚ÇÄ)} x‚ÇÄ
simpa only [function.funext_iff] using hextr
rcases hextr.exists_linear_map_of_has_strict_fderiv_at (has_strict_fderiv_at_pi.2 (Œª i, hf' i)) hœÜ' with ‚ü®Œõ, Œõ‚ÇÄ, h0, hsum‚ü©
rcases (linear_equiv.pi_ring ‚Ñù ‚Ñù Œπ ‚Ñù).symm.surjective Œõ with ‚ü®Œõ, rfl‚ü©
refine lhopital_zero_right_on_Ioo hab hff' hgg' hg' _ _ hdiv
rw [‚Üê hfa, ‚Üê nhds_within_Ioo_eq_nhds_within_Ioi hab]
exact ((hcf a $ left_mem_Ico.mpr hab).mono Ioo_subset_Ico_self).tendsto
{ rw [‚Üê hfa, ‚Üê nhds_within_Ioo_eq_nhds_within_Ioi hab], exact ((hcf a $ left_mem_Ico.mpr hab).mono Ioo_subset_Ico_self).tendsto }
rw [‚Üê hga, ‚Üê nhds_within_Ioo_eq_nhds_within_Ioi hab]
exact ((hcg a $ left_mem_Ico.mpr hab).mono Ioo_subset_Ico_self).tendsto
have hIccIoo := @Ioo_subset_Icc_self ‚Ñù _ 0 1
set g : ‚Ñù ‚Üí E := Œª t, x + t ‚Ä¢ (y - x)
have hseg : ‚àÄ t ‚àà Icc (0:‚Ñù) 1, g t ‚àà segment ‚Ñù x y
rw segment_eq_image'
simp only [mem_image, and_imp, add_right_inj]
exact ‚ü®t, ht, rfl‚ü©
{ rw segment_eq_image', simp only [mem_image, and_imp, add_right_inj], intros t ht, exact ‚ü®t, ht, rfl‚ü© }
intros t ht
have hseg' : Icc 0 1 ‚äÜ g ‚Åª¬π' s
unfold image
change ‚àÄ _, _
rw ‚Üê image_subset_iff
rw mem_set_of_eq at Hz
rcases Hz with ‚ü®t, Ht, hgt‚ü©
intros z Hz
exact hs.segment_subset xs ys (hseg t Ht)
{ rw ‚Üê image_subset_iff, unfold image, change ‚àÄ _, _, intros z Hz, rw mem_set_of_eq at Hz, rcases Hz with ‚ü®t, Ht, hgt‚ü©, rw ‚Üê hgt, exact hs.segment_subset xs ys (hseg t Ht) }
rw ‚Üê hgt
have hfg: ‚àÄ t ‚àà Icc (0:‚Ñù) 1, has_deriv_within_at (f ‚àò g) ((f' (g t) : E ‚Üí ‚Ñù) (y-x)) (Icc (0:‚Ñù) 1) t
intros t Ht
have hg : has_deriv_at g (y-x) t
have := ((has_deriv_at_id t).smul_const (y - x)).const_add x
{ have := ((has_deriv_at_id t).smul_const (y - x)).const_add x, rwa one_smul at this }
rwa one_smul at this
exact (hf (g t) $ hseg' Ht).comp_has_deriv_within_at _ hg.has_deriv_within_at hseg'
{ intros t Ht, have hg : has_deriv_at g (y-x) t, { have := ((has_deriv_at_id t).smul_const (y - x)).const_add x, rwa one_smul at this }, exact (hf (g t) $ hseg' Ht).comp_has_deriv_within_at _ hg.has_deriv_within_at hseg' }
have hMVT : ‚àÉ (t ‚àà Ioo (0:‚Ñù) 1), ((f' (g t) : E ‚Üí ‚Ñù) (y-x)) = (f (g 1) - f (g 0)) / (1 - 0)
norm_num
refine exists_has_deriv_at_eq_slope (f ‚àò g) _ (by norm_num) _ _
unfold continuous_on
{ unfold continuous_on, exact Œª t Ht, (hfg t Ht).continuous_within_at }
exact Œª t Ht, (hfg t Ht).continuous_within_at
refine Œª t Ht, (hfg t $ hIccIoo Ht).has_deriv_at _
refine _root_.mem_nhds_iff.mpr _
use (Ioo (0:‚Ñù) 1)
refine ‚ü®hIccIoo, _, Ht‚ü©
{ refine exists_has_deriv_at_eq_slope (f ‚àò g) _ (by norm_num) _ _, { unfold continuous_on, exact Œª t Ht, (hfg t Ht).continuous_within_at }, { refine Œª t Ht, (hfg t $ hIccIoo Ht).has_deriv_at _, refine _root_.mem_nhds_iff.mpr _, use (Ioo (0:‚Ñù) 1), refine ‚ü®hIccIoo, _, Ht‚ü©, simp [real.Ioo_eq_ball, is_open_ball] } }
simp [real.Ioo_eq_ball, is_open_ball]
rcases hMVT with ‚ü®t, Ht, hMVT'‚ü©
refine ‚ü®hseg t $ hIccIoo Ht, _‚ü©
use g t
simp [g, hMVT']
simp
let h := Œª x, (g b - g a) * f x - (f b - f a) * g x
have hI : h a = h b
ring
{ simp only [h], ring }
simp only [h]
let h' := Œª x, (g b - g a) * f' x - (f b - f a) * g' x
have hhh' : ‚àÄ x ‚àà Ioo a b, has_deriv_at h (h' x) x
from Œª x hx, ((hff' x hx).const_mul (g b - g a)).sub ((hgg' x hx).const_mul (f b - f a))
have hhc : continuous_on h (Icc a b)
from (continuous_on_const.mul hfc).sub (continuous_on_const.mul hgc)
rcases exists_has_deriv_at_eq_zero h h' hab hhc hI hhh' with ‚ü®c, cmem, hc‚ü©
exact ‚ü®c, cmem, sub_eq_zero.1 hc‚ü©
simpa only [zero_mul, sub_nonpos] using hD.image_sub_le_mul_sub_of_deriv_le hf hf' hf'_nonpos
have hm := (continuous_linear_map.smul_rightL ‚Ñù ‚Ñù E 1).continuous.measurable.comp_ae_measurable hF'_meas
cases has_fderiv_at_of_dominated_loc_of_lip Œµ_pos hF_meas hF_int hm h_lipsch bound_integrable h_diff with hF'_int key
replace hF'_int : integrable F' Œº
rw [‚Üê integrable_norm_iff hm] at hF'_int
simpa only [integrable_norm_iff, hF'_meas, one_mul, norm_one, continuous_linear_map.norm_smul_rightL_apply] using hF'_int
{ rw [‚Üê integrable_norm_iff hm] at hF'_int, simpa only [integrable_norm_iff, hF'_meas, one_mul, norm_one, continuous_linear_map.norm_smul_rightL_apply] using hF'_int}
refine ‚ü®hF'_int, _‚ü©
simp_rw has_deriv_at_iff_has_fderiv_at at h_diff ‚ä¢
rwa continuous_linear_map.integral_comp_comm _ hF'_int at key
apply_instance
apply_instance
apply_instance
apply_instance
all_goals { apply_instance, }
simp only [interior_Ici, nonempty_Ioi]
simp only [interior_Ico, nonempty_Ioo, hab]
simp only [Ico_eq_empty hab, unique_diff_on_empty]
simp [times_cont_diff_on, e.comp_times_cont_diff_within_at_iff]
exact Œª x, hf.times_cont_diff_at.inv (h x)
rw times_cont_diff_iff_times_cont_diff_at
simp [norm]
simp [norm]; norm_num
norm_num
have A : times_cont_diff_at ‚Ñù n (coe : ‚Ñù ‚Üí ‚ÑÇ) z
from of_real_clm.times_cont_diff.times_cont_diff_at
have B : times_cont_diff_at ‚Ñù n e z := h.restrict_scalars ‚Ñù
have C : times_cont_diff_at ‚Ñù n re (e z)
from re_clm.times_cont_diff.times_cont_diff_at
exact C.comp z (B.comp z A)
intros x y xs ys a b ha hb hab
rw [mem_preimage, convex.combo_affine_apply hab]
exact hs xs ys ha hb hab
rw [s.center_mass_eq_of_sum_1 _ hws, t.center_mass_eq_of_sum_1 _ hwt, smul_sum, smul_sum, ‚Üê finset.sum_sum_elim, finset.center_mass_eq_of_sum_1]
congr' with ‚ü®‚ü©; simp only [sum.elim_inl, sum.elim_inr, mul_smul]
simp only [sum.elim_inl, sum.elim_inr, mul_smul]
simp only [sum.elim_inl, sum.elim_inr, mul_smul]
congr' with ‚ü®‚ü©
{ congr' with ‚ü®‚ü©; simp only [sum.elim_inl, sum.elim_inr, mul_smul] }
rw [sum_sum_elim, ‚Üê mul_sum, ‚Üê mul_sum, hws, hwt, mul_one, mul_one, hab]
use subset.trans (inter_subset_left _ _) hAB.1
rintro x‚ÇÅ x‚ÇÇ hx‚ÇÅA hx‚ÇÇA x ‚ü®hxB, hxC‚ü© hx
obtain ‚ü®hx‚ÇÅB, hx‚ÇÇB‚ü© := hAB.2 x‚ÇÅ x‚ÇÇ hx‚ÇÅA hx‚ÇÇA x hxB hx
obtain ‚ü®hx‚ÇÅC, hx‚ÇÇC‚ü© := hAC.2 x‚ÇÅ x‚ÇÇ hx‚ÇÅA hx‚ÇÇA x hxC hx
exact ‚ü®‚ü®hx‚ÇÅB, hx‚ÇÅC‚ü©, hx‚ÇÇB, hx‚ÇÇC‚ü©
rintro ‚ü®x, r‚ü© ‚ü®y, t‚ü© ‚ü®hx, hr‚ü© ‚ü®hy, ht‚ü© a b ha hb hab
refine ‚ü®hf.1 hx hy ha hb hab, _‚ü©
calc f (a ‚Ä¢ x + b ‚Ä¢ y) ‚â§ a ‚Ä¢ f x + b ‚Ä¢ f y : hf.2 hx hy ha hb hab ... ‚â§ a ‚Ä¢ r + b ‚Ä¢ t : add_le_add (smul_le_smul_of_nonneg hr ha) (smul_le_smul_of_nonneg ht hb)
abel
simp only [smul_add, add_assoc]
have : (convex_hull ùïú (p '' s)).nonempty := ‚ü®p x, hx‚ü©
rw [convex_hull_nonempty_iff, set.nonempty_image_iff] at this
rwa subsingleton.mem_iff_nonempty
have h‚ÇÅ : Iio 0 ‚äÜ ({0} : set ‚Ñù)·∂ú
intros x hx hx'
rw [mem_singleton_iff] at hx'
rw [hx'] at hx
{ intros x hx hx', rw [mem_singleton_iff] at hx', rw [hx'] at hx, exact lt_irrefl 0 hx }
exact lt_irrefl 0 hx
refine concave_on_open_of_deriv2_nonpos (convex_Iio 0) is_open_Iio _ _ _
{ exact differentiable_on_log.mono h‚ÇÅ }
exact differentiable_on_log.mono h‚ÇÅ
refine ((times_cont_diff_on_log.deriv_of_open _ le_top).differentiable_on le_top).mono h‚ÇÅ
{ refine ((times_cont_diff_on_log.deriv_of_open _ le_top).differentiable_on le_top).mono h‚ÇÅ, exact is_open_compl_singleton }
exact is_open_compl_singleton
intros x hx
rw [function.iterate_succ, function.iterate_one]
change (deriv (deriv log)) x ‚â§ 0
rw [deriv_log', deriv_inv]
exact neg_nonpos.mpr (inv_nonneg.mpr (sq_nonneg x))
use ‚®Ü s : finset Œπ, ‚àë i in s, ‚à•‚ü™v i, x‚ü´‚à• ^ 2
apply has_sum_of_is_lub_of_nonneg
intro b
{ intro b, simp only [norm_nonneg, pow_nonneg], }
simp only [norm_nonneg, pow_nonneg]
refine is_lub_csupr _
use ‚à•x‚à• ^ 2
rintro y ‚ü®s, rfl‚ü©
exact hv.sum_inner_products_le x
rw [‚Üê @of_real_inj ùïú, im_eq_conj_sub]; simp [inner_conj_sym]
simp [inner_conj_sym]
rw [‚Üê @of_real_inj ùïú, im_eq_conj_sub]
rintro rfl
exact inner_zero_left
simp [inner_smul_left, finsupp.sum]
convert sum_inner l.support (Œª a, l a ‚Ä¢ v a) x
simp [inner_sum, inner_smul_right, orthonormal_iff_ite.mp hv]
ext
simp [inner_add_left]
ext
simp [inner_smul_left]
simp only [norm_to_dual'_apply, one_mul, linear_map.coe_mk]
rw [is_R_or_C.norm_eq_abs]
exact abs_inner_le_norm _ _
ext z
simp
ext z
simp [inner_add_left]
convert complex.basis_one_I.equiv_fun_symm_apply x
{ simpa }
simpa
simp
have hm : orthogonal_projection_fn K x + orthogonal_projection_fn K y ‚àà K := submodule.add_mem K (orthogonal_projection_fn_mem x) (orthogonal_projection_fn_mem y)
have ho : ‚àÄ w ‚àà K, ‚ü™x + y - (orthogonal_projection_fn K x + orthogonal_projection_fn K y), w‚ü´ = 0
intros w hw
rw [add_sub_comm, inner_add_left, orthogonal_projection_fn_inner_eq_zero _ w hw, orthogonal_projection_fn_inner_eq_zero _ w hw, add_zero]
{ intros w hw, rw [add_sub_comm, inner_add_left, orthogonal_projection_fn_inner_eq_zero _ w hw, orthogonal_projection_fn_inner_eq_zero _ w hw, add_zero] }
ext
simp [eq_orthogonal_projection_fn_of_mem_of_inner_eq_zero hm ho]
have hm : c ‚Ä¢ orthogonal_projection_fn K x ‚àà K := submodule.smul_mem K _ (orthogonal_projection_fn_mem x)
have ho : ‚àÄ w ‚àà K, ‚ü™c ‚Ä¢ x - c ‚Ä¢ orthogonal_projection_fn K x, w‚ü´ = 0
intros w hw
{ intros w hw, rw [‚Üêsmul_sub, inner_smul_left, orthogonal_projection_fn_inner_eq_zero _ w hw, mul_zero] }
rw [‚Üêsmul_sub, inner_smul_left, orthogonal_projection_fn_inner_eq_zero _ w hw, mul_zero]
ext
simp [eq_orthogonal_projection_fn_of_mem_of_inner_eq_zero hm ho]
simp only [one_mul, linear_map.coe_mk]
norm_num
refine le_of_pow_le_pow 2 (norm_nonneg _) (by norm_num) _
change ‚à•orthogonal_projection_fn K x‚à• ^ 2 ‚â§ ‚à•x‚à• ^ 2
nlinarith [orthogonal_projection_fn_norm_sq K x]
exact_mod_cast real.pow_arith_mean_le_arith_mean_pow s _ _ (Œª i _, (w i).coe_nonneg) (by exact_mod_cast hw') (Œª i _, (z i).coe_nonneg) n
exact_mod_cast hw'
have h := rpow_arith_mean_le_arith_mean_rpow (univ : finset (fin 2)) (fin.cons w‚ÇÅ $ fin.cons w‚ÇÇ fin_zero_elim) (fin.cons z‚ÇÅ $ fin.cons z‚ÇÇ $ fin_zero_elim) _ hp
simpa [fin.sum_univ_succ, fin.sum_univ_zero, fin.cons_succ, fin.cons_zero] using h
{ simpa [fin.sum_univ_succ, fin.sum_univ_zero, fin.cons_succ, fin.cons_zero] using h, }
simp [hw', fin.sum_univ_succ, fin.sum_univ_zero, fin.cons_succ, fin.cons_zero]
split
use Œª i, ((f i) ^ p / f i / (‚àë i in s, (f i) ^ p) ^ (1 / q))
by_cases hf : ‚àë i in s, (f i)^p = 0
{ simp [hf, hpq.ne_zero, hpq.symm.ne_zero] }
simp [hf, hpq.ne_zero, hpq.symm.ne_zero]
simp [hpq.ne_zero]
have A : p + q - q ‚â† 0
have B : ‚àÄ y : ‚Ñù‚â•0, y * y^p / y = y^p
refine Œª y, mul_div_cancel_left_of_imp (Œª h, _)
{ refine Œª y, mul_div_cancel_left_of_imp (Œª h, _), simpa [h, hpq.ne_zero] }
simpa [h, hpq.ne_zero]
simp only [set.mem_set_of_eq, div_rpow, ‚Üê sum_div, ‚Üê rpow_mul, div_mul_cancel _ hpq.symm.ne_zero, rpow_one, div_le_iff hf, one_mul, hpq.mul_eq_add, ‚Üê rpow_sub' _ A, _root_.add_sub_cancel, le_refl, true_and, ‚Üê mul_div_assoc, B]
rw [div_eq_iff, ‚Üê rpow_add hf, hpq.inv_add_inv_conj, rpow_one]
{ use Œª i, ((f i) ^ p / f i / (‚àë i in s, (f i) ^ p) ^ (1 / q)), by_cases hf : ‚àë i in s, (f i)^p = 0, { simp [hf, hpq.ne_zero, hpq.symm.ne_zero] }, { have A : p + q - q ‚â† 0, by simp [hpq.ne_zero], have B : ‚àÄ y : ‚Ñù‚â•0, y * y^p / y = y^p, { refine Œª y, mul_div_cancel_left_of_imp (Œª h, _), simpa [h, hpq.ne_zero] }, simp only [set.mem_set_of_eq, div_rpow, ‚Üê sum_div, ‚Üê rpow_mul, div_mul_cancel _ hpq.symm.ne_zero, rpow_one, div_le_iff hf, one_mul, hpq.mul_eq_add, ‚Üê rpow_sub' _ A, _root_.add_sub_cancel, le_refl, true_and, ‚Üê mul_div_assoc, B], rw [div_eq_iff, ‚Üê rpow_add hf, hpq.inv_add_inv_conj, rpow_one], simpa [hpq.symm.ne_zero] using hf } }
simpa [hpq.symm.ne_zero] using hf
rintros _ ‚ü®g, hg, rfl‚ü©
apply le_trans (inner_le_Lp_mul_Lq s f g hpq)
simpa only [mul_one] using mul_le_mul_left' (nnreal.rpow_le_one hg (le_of_lt hpq.symm.one_div_pos)) _
rcases eq_or_lt_of_le hp with rfl|hp
simp [finset.sum_add_distrib]
{ simp [finset.sum_add_distrib] }
have hpq := real.is_conjugate_exponent_conjugate_exponent hp
have := is_greatest_Lp s (f + g) hpq
simp only [pi.add_apply, add_mul, sum_add_distrib] at this
rcases this.1 with ‚ü®œÜ, hœÜ, H‚ü©
rw ‚Üê H
exact add_le_add ((is_greatest_Lp s f hpq).2 ‚ü®œÜ, hœÜ, rfl‚ü©) ((is_greatest_Lp s g hpq).2 ‚ü®œÜ, hœÜ, rfl‚ü©)
apply_instance
apply_instance
apply_mod_cast nndist_vadd_vadd_le
simp only [edist_nndist]
refl
ext
rw [‚Üê (point_reflection ùïú x).dist_map y x, point_reflection_self]
rw [frontier, closure_closed_ball, interior_closed_ball' x r, closed_ball_diff_ball]
refine isometry_emetric_iff_metric.2 (Œªx y, _)
rw [dist_eq_norm, dist_eq_norm, ‚Üê ring_hom.map_sub, norm_algebra_map_eq]
simpa using (norm_algebra_map_eq ùïú' (1:ùïú))
rwa [real.norm_eq_abs, abs_of_nonneg nn] at this
apply le_antisymm
rw H1
apply H2
{ rw [sub_eq_add_neg, ‚Üê add_right_neg y], apply H2 }
rw [sub_eq_add_neg, ‚Üê add_right_neg y]
rwa [sub_add_cancel, zero_add] at this
have := H2 (x-y) 0 y
simp [le_refl]
haveI := hq.complete_space_coe
haveI := hp.complete_space_coe
refine (p.prod_equiv_of_is_compl q h).to_continuous_linear_equiv_of_continuous _
exact ((subtype_val p).coprod (subtype_val q)).continuous
simpa using continuous_linear_map.le_of_op_norm_le _ (inclusion_in_double_dual_norm_le ùïú E) x
letI := e.emetric_space
refine emetric_space.to_metric_space_of_dist _ (Œª x y, _) (Œª x y, rfl)
change e (x - y) ‚â† ‚ä§
exact ne_top_of_le_ne_top (ennreal.add_lt_top.2 ‚ü®x.2, y.2‚ü©).ne (e.map_sub_le x y)
have : (f : (Œπ ‚Üí ùïú) ‚Üí E) = (Œªx, ‚àë i : Œπ, x i ‚Ä¢ (f (Œªj, if i = j then 1 else 0)))
ext x
exact f.pi_apply_eq_sum_univ x
rw this
refine continuous_finset_sum _ (Œªi hi, _)
exact (continuous_apply i).smul continuous_const
simp only [fintype.linear_independent_iff'] at hf ‚ä¢
rcases linear_map.exists_antilipschitz_with _ hf with ‚ü®K, K0, hK‚ü©
have : tendsto (Œª g : Œπ ‚Üí E, ‚àë i, ‚à•g i - f i‚à•) (ùìù f) (ùìù $ ‚àë i, ‚à•f i - f i‚à•)
from tendsto_finset_sum _ (Œª i hi, tendsto.norm $ ((continuous_apply i).tendsto _).sub tendsto_const_nhds)
simp only [sub_self, norm_zero, finset.sum_const_zero] at this
refine (this.eventually (gt_mem_nhds $ inv_pos.2 K0)).mono (Œª g hg, _)
replace hg : ‚àë i, nnnorm (g i - f i) < K‚Åª¬π
rw ‚Üê nnreal.coe_lt_coe
push_cast
exact hg
rw linear_map.ker_eq_bot
refine (hK.add_sub_lipschitz_with (lipschitz_with.of_dist_le_mul $ Œª v u, _) hg).injective
simp only [dist_eq_norm, linear_map.lsum_apply, pi.sub_apply, linear_map.sum_apply, linear_map.comp_apply, linear_map.proj_apply, linear_map.smul_right_apply, linear_map.id_apply, ‚Üê finset.sum_sub_distrib, ‚Üê smul_sub, ‚Üê sub_smul, nnreal.coe_sum, coe_nnnorm, finset.sum_mul]
refine norm_sum_le_of_le _ (Œª i _, _)
rw [norm_smul, mul_comm]
exact mul_le_mul_of_nonneg_left (norm_le_pi_norm (v - u) i) (norm_nonneg _)
set e := continuous_linear_equiv.of_finrank_eq (@finrank_fin_fun ùïú _ (finrank ùïú E)).symm
have : uniform_embedding e.to_linear_equiv.to_equiv.symm := e.symm.uniform_embedding
exact (complete_space_congr this).1 (by apply_instance)
apply_instance
exact isometric.range_eq_univ _
rw ‚Üê coe_to_isometric
split
assume h
ext m
{ assume h, ext m, simpa [h] using f.le_op_norm m }
simpa [h] using f.le_op_norm m
rintro rfl
apply le_antisymm (op_norm_le_bound 0 le_rfl (Œªm, _)) (op_norm_nonneg _)
simp
ext
ext; refl
refl
refl
ext
ext; refl
refl
refl
dsimp [has_sum] at h ‚ä¢
convert ((continuous_eval_left m).tendsto _).comp h
ext s
simp
rw [one_mul]
refl
simp
intros U
split
intros U_in
rw ‚Üê (mk' S).map_zero at U_in
have := preimage_nhds_coinduced U_in
rcases metric.mem_nhds_iff.mp this with ‚ü®Œµ, Œµ_pos, H‚ü©
use [Œµ/2, half_pos Œµ_pos]
intros x x_in
dsimp at x_in
rcases norm_mk_lt x (half_pos Œµ_pos) with ‚ü®y, rfl, ry‚ü©
apply H
rw ball_zero_eq
dsimp
{ intros U_in, rw ‚Üê (mk' S).map_zero at U_in, have := preimage_nhds_coinduced U_in, rcases metric.mem_nhds_iff.mp this with ‚ü®Œµ, Œµ_pos, H‚ü©, use [Œµ/2, half_pos Œµ_pos], intros x x_in, dsimp at x_in, rcases norm_mk_lt x (half_pos Œµ_pos) with ‚ü®y, rfl, ry‚ü©, apply H, rw ball_zero_eq, dsimp, linarith }
linarith
rintros ‚ü®Œµ, Œµ_pos, h‚ü©
have : (mk' S) '' (ball (0 : M) Œµ) ‚äÜ {x | ‚à•x‚à• < Œµ}
rintros - ‚ü®x, x_in, rfl‚ü©
rw mem_ball_zero_iff at x_in
{ rintros - ‚ü®x, x_in, rfl‚ü©, rw mem_ball_zero_iff at x_in, exact lt_of_le_of_lt (quotient_norm_mk_le S x) x_in }
exact lt_of_le_of_lt (quotient_norm_mk_le S x) x_in
apply filter.mem_of_superset _ (set.subset.trans this h)
clear h U this
apply is_open.mem_nhds
change is_open ((mk' S) ‚Åª¬π' _)
erw quotient_add_group.preimage_image_coe
apply is_open_Union
rintros ‚ü®s, s_in‚ü©
{ change is_open ((mk' S) ‚Åª¬π' _), erw quotient_add_group.preimage_image_coe, apply is_open_Union, rintros ‚ü®s, s_in‚ü©, exact (continuous_add_right s).is_open_preimage _ is_open_ball }
exact (continuous_add_right s).is_open_preimage _ is_open_ball
exact ‚ü®(0 : M), mem_ball_self Œµ_pos, (mk' S).map_zero‚ü©
simpa only [prod_apply, prod.semi_norm_def, max_mul_of_nonneg, norm_nonneg] using max_le_max (le_op_norm f x) (le_op_norm g x)
simp [edist, ennreal.zero_rpow_of_pos pos, ennreal.zero_rpow_of_pos (inv_pos.2 pos)]
simp [edist, edist_comm]
apply ennreal.rpow_le_rpow _ (one_div_nonneg.2 $ le_of_lt pos)
refine finset.sum_le_sum (Œª i hi, _)
exact ennreal.rpow_le_rpow (edist_triangle _ _ _) (le_trans zero_le_one hp)
have pos : 0 < p := lt_of_lt_of_le zero_lt_one hp
have nonneg : 0 ‚â§ 1 / p := one_div_nonneg.2 (le_of_lt pos)
have cancel : p * (1/p) = 1 := mul_div_cancel' 1 (ne_of_gt pos)
assume x y
simp [edist, -one_div]
calc (‚àë (i : Œπ), edist (x i) (y i) ^ p) ^ (1 / p) ‚â§ (‚àë (i : Œπ), edist (pi_Lp.equiv p hp Œ≤ x) (pi_Lp.equiv p hp Œ≤ y) ^ p) ^ (1 / p) : begin apply ennreal.rpow_le_rpow _ nonneg, apply finset.sum_le_sum (Œª i hi, _), apply ennreal.rpow_le_rpow _ (le_of_lt pos), exact finset.le_sup (finset.mem_univ i) end ... = (((fintype.card Œπ : ‚Ñù‚â•0)) ^ (1/p) : ‚Ñù‚â•0) * edist (pi_Lp.equiv p hp Œ≤ x) (pi_Lp.equiv p hp Œ≤ y) : begin simp only [nsmul_eq_mul, finset.card_univ, ennreal.rpow_one, finset.sum_const, ennreal.mul_rpow_of_nonneg _ _ nonneg, ‚Üêennreal.rpow_mul, cancel], have : (fintype.card Œπ : ‚Ñù‚â•0‚àû) = (fintype.card Œπ : ‚Ñù‚â•0) := (ennreal.coe_nat (fintype.card Œπ)).symm, rw [this, ennreal.coe_rpow_of_nonneg _ nonneg] end
apply ennreal.rpow_le_rpow _ nonneg
apply finset.sum_le_sum (Œª i hi, _)
apply ennreal.rpow_le_rpow _ (le_of_lt pos)
exact finset.le_sup (finset.mem_univ i)
simp only [nsmul_eq_mul, finset.card_univ, ennreal.rpow_one, finset.sum_const, ennreal.mul_rpow_of_nonneg _ _ nonneg, ‚Üêennreal.rpow_mul, cancel]
have : (fintype.card Œπ : ‚Ñù‚â•0‚àû) = (fintype.card Œπ : ‚Ñù‚â•0) := (ennreal.coe_nat (fintype.card Œπ)).symm
rw [this, ennreal.coe_rpow_of_nonneg _ nonneg]
have Rpos : 0 < R := (norm_nonneg _).trans_lt hR
rw div_lt_iff Rpos
have : ‚à•c‚à• / R < 1
simpa using hR
rcases riesz_lemma hFc hF this with ‚ü®x, xF, hx‚ü©
simpa [H] using xF
have x0 : x ‚â† 0 := Œª H, by simpa [H] using xF
obtain ‚ü®d, d0, dxlt, ledx, -‚ü© : ‚àÉ (d : ùïú), d ‚â† 0 ‚àß ‚à•d ‚Ä¢ x‚à• < R ‚àß R / ‚à•c‚à• ‚â§ ‚à•d ‚Ä¢ x‚à• ‚àß ‚à•d‚à•‚Åª¬π ‚â§ R‚Åª¬π * ‚à•c‚à• * ‚à•x‚à• := rescale_to_shell hc Rpos x0
refine ‚ü®d ‚Ä¢ x, dxlt.le, Œª y hy, _‚ü©
set y' := d‚Åª¬π ‚Ä¢ y with hy'
simp [hy', submodule.smul_mem _ _ hy]
have y'F : y' ‚àà F
simp [hy', smul_smul, mul_inv_cancel d0]
have yy' : y = d ‚Ä¢ y'
field_simp [Rpos.ne', (zero_lt_one.trans hc).ne']
calc 1 = (‚à•c‚à•/R) * (R/‚à•c‚à•) : by field_simp [Rpos.ne', (zero_lt_one.trans hc).ne'] ... ‚â§ (‚à•c‚à•/R) * (‚à•d ‚Ä¢ x‚à•) : mul_le_mul_of_nonneg_left ledx (div_nonneg (norm_nonneg _) Rpos.le) ... = ‚à•d‚à• * (‚à•c‚à•/R * ‚à•x‚à•) : by { simp [norm_smul], ring } ... ‚â§ ‚à•d‚à• * ‚à•x - y'‚à• : mul_le_mul_of_nonneg_left (hx y' (by simp [hy', submodule.smul_mem _ _ hy])) (norm_nonneg _) ... = ‚à•d ‚Ä¢ x - y‚à• : by simp [yy', ‚Üê smul_sub, norm_smul]
simp [norm_smul]
ring
simp [hy', submodule.smul_mem _ _ hy]
simp [yy', ‚Üê smul_sub, norm_smul]
have h_is_o : is_o (Œª (t : R), ‚à•inverse (‚Üëx + t) - ‚Üëx‚Åª¬π‚à•) (Œª (t : R), (1:‚Ñù)) (ùìù 0)
refine is_o_norm_left.mpr ((inverse_add_norm_diff_first_order x).trans_is_o _)
{ refine is_o_norm_left.mpr ((inverse_add_norm_diff_first_order x).trans_is_o _), exact is_o_norm_left.mpr (is_o_id_const one_ne_zero) }
exact is_o_norm_left.mpr (is_o_id_const one_ne_zero)
have h_lim : tendsto (Œª (y:R), y - x) (ùìù x) (ùìù 0)
refine tendsto_zero_iff_norm_tendsto_zero.mpr _
{ refine tendsto_zero_iff_norm_tendsto_zero.mpr _, exact tendsto_iff_norm_tendsto_zero.mp tendsto_id }
exact tendsto_iff_norm_tendsto_zero.mp tendsto_id
simp only [continuous_at]
rw [tendsto_iff_norm_tendsto_zero, inverse_unit]
convert h_is_o.tendsto_0.comp h_lim
ext
simp
convert add_le_add_left (nsmul_le_nsmul_of_le_right (sum_condensed_le' hf n) 2) (f 1)
simp [sum_range_succ', add_comm, pow_succ, mul_nsmul, sum_nsmul]
simp [arg, hx]
rw [‚Üê exp_lt_exp, exp_log hx, exp_log hy]
exact log_lt_log_iff zero_lt_one hx
rw ‚Üê log_one
rw integral_deriv_eq_sub'; norm_num [continuous_on_exp]
norm_num [continuous_on_exp]
norm_num [continuous_on_exp]
norm_num [continuous_on_exp]
rw integral_deriv_eq_sub'
refine integral_mono_on pi_pos.le _ _ H; exact (continuous_sin.pow _).interval_integrable 0 œÄ
exact (continuous_sin.pow _).interval_integrable 0 œÄ
exact (continuous_sin.pow _).interval_integrable 0 œÄ
refine integral_mono_on pi_pos.le _ _ H
convert integral_sin_pow_even_mul_cos_pow_even 1 1 using 1
have h1 : ‚àÄ c : ‚Ñù, (1 - c) / 2 * ((1 + c) / 2) = (1 - c ^ 2) / 4 := Œª c, by ring
ring
have h2 : continuous (Œª x, cos (2 * x) ^ 2) := by continuity
continuity
have h3 : ‚àÄ x, cos x * sin x = sin (2 * x) / 2
intro
rw sin_two_mul
ring
{ intro, rw sin_two_mul, ring }
have h4 : ‚àÄ d : ‚Ñù, 2 * (2 * d) = 4 * d := Œª d, by ring
ring
simp [h1, h2.interval_integrable, integral_comp_mul_left (Œª x, cos x ^ 2), h3, h4]
ring
simpa only [coe_rpow, coe_pow] using real.rpow_nat_cast x n
simp [rpow_neg]
rw [div_eq_mul_inv, mul_rpow_of_nonneg _ _ hz, inv_rpow, div_eq_mul_inv]
rcases lt_trichotomy z 0 with H|H|H
simp [H, ne_of_lt]
{ simp [H, ne_of_lt] }
cases x
by_cases hx : x = 0
{ simp [hx, H, ne_of_lt] }
simp [hx, H, ne_of_lt]
{ cases x, { simp [H, ne_of_lt] }, by_cases hx : x = 0, { simp [hx, H, ne_of_lt] }, { simp [coe_rpow_of_ne_zero hx] } }
simp [coe_rpow_of_ne_zero hx]
{ simp [H] }
simp [H]
simp [H, ne_of_gt]
{ simp [H, ne_of_gt] }
cases x
simp [coe_rpow_of_nonneg _ (le_of_lt H)]
simp only [rpow_def, complex.cpow_def]; split_ifs; simp [*, (complex.of_real_log hx).symm, -complex.of_real_mul, -is_R_or_C.of_real_mul, (complex.of_real_mul _ _).symm, complex.exp_of_real_re] at *
simp only [rpow_def, complex.cpow_def]; split_ifs
simp only [rpow_def, complex.cpow_def]
split_ifs
simp [*, (complex.of_real_log hx).symm, -complex.of_real_mul, -is_R_or_C.of_real_mul, (complex.of_real_mul _ _).symm, complex.exp_of_real_re] at *
simp [*, (complex.of_real_log hx).symm, -complex.of_real_mul, -is_R_or_C.of_real_mul, (complex.of_real_mul _ _).symm, complex.exp_of_real_re] at *
simp [*, (complex.of_real_log hx).symm, -complex.of_real_mul, -is_R_or_C.of_real_mul, (complex.of_real_mul _ _).symm, complex.exp_of_real_re] at *
simp [*, (complex.of_real_log hx).symm, -complex.of_real_mul, -is_R_or_C.of_real_mul, (complex.of_real_mul _ _).symm, complex.exp_of_real_re] at *
simp [*, (complex.of_real_log hx).symm, -complex.of_real_mul, -is_R_or_C.of_real_mul, (complex.of_real_mul _ _).symm, complex.exp_of_real_re] at *
simp [*, (complex.of_real_log hx).symm, -complex.of_real_mul, -is_R_or_C.of_real_mul, (complex.of_real_mul _ _).symm, complex.exp_of_real_re] at *
simp [*, (complex.of_real_log hx).symm, -complex.of_real_mul, -is_R_or_C.of_real_mul, (complex.of_real_mul _ _).symm, complex.exp_of_real_re] at *
simp [*, (complex.of_real_log hx).symm, -complex.of_real_mul, -is_R_or_C.of_real_mul, (complex.of_real_mul _ _).symm, complex.exp_of_real_re] at *
simp [*, (complex.of_real_log hx).symm, -complex.of_real_mul, -is_R_or_C.of_real_mul, (complex.of_real_mul _ _).symm, complex.exp_of_real_re] at *
rw [‚Üê complex.of_real_inj, complex.of_real_cpow (rpow_nonneg_of_nonneg hx _), complex.of_real_cpow hx, complex.of_real_mul, complex.cpow_mul, complex.of_real_cpow hx]
rw [‚Üê complex.of_real_inj, complex.of_real_cpow (rpow_nonneg_of_nonneg hx _), complex.of_real_cpow hx, complex.of_real_mul, complex.cpow_mul, complex.of_real_cpow hx]; simp only [(complex.of_real_mul _ _).symm, (complex.of_real_log hx).symm, complex.of_real_im, neg_lt_zero, pi_pos, le_of_lt pi_pos]
simp only [(complex.of_real_mul _ _).symm, (complex.of_real_log hx).symm, complex.of_real_im, neg_lt_zero, pi_pos, le_of_lt pi_pos]
simp only [(complex.of_real_mul _ _).symm, (complex.of_real_log hx).symm, complex.of_real_im, neg_lt_zero, pi_pos, le_of_lt pi_pos]
rw [rpow_def_of_pos (lt_of_lt_of_le zero_lt_one hx)]
rw [rpow_def_of_pos (lt_of_lt_of_le zero_lt_one hx)]
rw [rpow_def_of_pos (lt_of_lt_of_le zero_lt_one hx)]
repeat {rw [rpow_def_of_pos (lt_of_lt_of_le zero_lt_one hx)]}
exact mul_le_mul_of_nonneg_left hyz (log_nonneg hx)
rw exp_le_exp
simp
simp; refl
rw gpow_neg_succ_of_nat
rw gpow_neg_succ_of_nat; simp only [int.neg_succ_of_nat_coe, int.cast_neg, complex.cpow_neg, inv_eq_one_div, int.cast_coe_nat, cpow_nat_cast]
simp only [int.neg_succ_of_nat_coe, int.cast_neg, complex.cpow_neg, inv_eq_one_div, int.cast_coe_nat, cpow_nat_cast]
exact_mod_cast h
simpa only [cos_zero] using (cos_periodic.nat_mul n).sub_antiperiod_eq cos_antiperiodic
congr
norm_num
simp
transitivity sin (œÄ / 2 ^ 5)
cases cos_eq_iff_eq_or_eq_neg.mp Hcos with hc hc
exact hc
{ exact hc }
cases sin_eq_iff_eq_or_add_eq_pi.mp Hsin with hs hs
exact hs
{ exact hs }
rw [eq_neg_iff_add_eq_zero, hs] at hc
change n ‚Ä¢ _ = _ at hn
cases quotient.exact' hc with n hn
rw [‚Üê neg_one_mul, add_zero, ‚Üê sub_eq_zero, gsmul_eq_mul, ‚Üê mul_assoc, ‚Üê sub_mul, mul_eq_zero, eq_false_intro (ne_of_gt pi_pos), or_false, sub_neg_eq_add, ‚Üê int.cast_zero, ‚Üê int.cast_one, ‚Üê int.cast_bit0, ‚Üê int.cast_mul, ‚Üê int.cast_add, int.cast_inj] at hn
have : (n * 2 + 1) % (2:‚Ñ§) = 0 % (2:‚Ñ§) := congr_arg (%(2:‚Ñ§)) hn
rw [add_comm, int.add_mul_mod_self] at this
exact absurd this one_ne_zero
simp [cos_add]
rw [real.pi, mul_div_cancel_left _ (@two_ne_zero' ‚Ñù _ _ _)]
rw [real.pi, mul_div_cancel_left _ (@two_ne_zero' ‚Ñù _ _ _)]; exact (classical.some_spec exists_cos_eq_zero).2
exact (classical.some_spec exists_cos_eq_zero).2
rw sin_pi_div_two
simp [arccos, sub_eq_iff_eq_add]
refine cauchy_seq_of_edist_le_of_tsum_ne_top _ hu _
rw [ennreal.tsum_mul_left, ennreal.tsum_geometric]
refine ennreal.mul_ne_top hC (ennreal.inv_ne_top.2 _)
exact (ennreal.sub_pos.2 hr).ne'
convert dist_le_tsum_of_dist_le_of_tendsto _ hu‚ÇÇ (summable_geometric_two' C) ha n
simp only [add_comm n, pow_add, ‚Üê div_div_eq_div_mul]
symmetry
exact ((has_sum_geometric_two' C).div_const _).tsum_eq
exact_mod_cast n.factorial_pos.le
exact_mod_cast n.zero_le
refine (eventually_gt_at_top 0).mono (Œª n hn, _)
rcases nat.exists_eq_succ_of_ne_zero hn.ne.symm with ‚ü®k, rfl‚ü©
rw [‚Üê prod_range_add_one_eq_factorial, pow_eq_prod_const, div_eq_mul_inv, ‚Üê inv_eq_one_div, prod_nat_cast, nat.cast_succ, ‚Üê prod_inv_distrib', ‚Üê prod_mul_distrib, finset.prod_range_succ']
simp only [prod_range_succ', one_mul, nat.cast_add, zero_add, nat.cast_one]
exact_mod_cast hn.le
refine mul_le_of_le_one_left (inv_nonneg.mpr $ by exact_mod_cast hn.le) (prod_le_one _ _)
refine mul_le_of_le_one_left (inv_nonneg.mpr $ by exact_mod_cast hn.le) (prod_le_one _ _); intros x hx; rw finset.mem_range at hx
refine mul_le_of_le_one_left (inv_nonneg.mpr $ by exact_mod_cast hn.le) (prod_le_one _ _); intros x hx
rw finset.mem_range at hx
rw finset.mem_range at hx
intros x hx
intros x hx
refine mul_nonneg _ (inv_nonneg.mpr _); norm_cast; linarith
refine mul_nonneg _ (inv_nonneg.mpr _); norm_cast
norm_cast
norm_cast
linarith
linarith
{ refine mul_nonneg _ (inv_nonneg.mpr _); norm_cast; linarith }
refine mul_nonneg _ (inv_nonneg.mpr _)
exact_mod_cast hn
norm_cast
linarith
refine (div_le_one $ by exact_mod_cast hn).mpr _
apply_instance
apply_instance
convert epi_of_epi_fac (is_limit.cone_point_unique_up_to_iso_hom_comp (limit.is_limit _) hs _)
{ refl }
refl
exact abelian.epi_pullback_of_epi_g _ _
split
introI h
fapply subobject.eq_of_comm
suffices : is_iso (image_to_kernel _ _ h.w)
{ exactI as_iso (image_to_kernel _ _ h.w), }
exactI as_iso (image_to_kernel _ _ h.w)
{ suffices : is_iso (image_to_kernel _ _ h.w), { exactI as_iso (image_to_kernel _ _ h.w), }, exact is_iso_of_mono_of_epi _, }
exact is_iso_of_mono_of_epi _
{ introI h, fapply subobject.eq_of_comm, { suffices : is_iso (image_to_kernel _ _ h.w), { exactI as_iso (image_to_kernel _ _ h.w), }, exact is_iso_of_mono_of_epi _, }, { simp, }, }
simp
apply exact_of_image_eq_kernel
rw [sub_def, ‚Üêlift_sub_lift, sub_def, category.assoc, œÉ_comp, prod.lift_map_assoc]
refl
apply (adj‚ÇÇ.hom_equiv _ _).subtype_equiv _
intro f
rw [‚Üê (adj‚ÇÇ.hom_equiv _ _).injective.eq_iff, eq_comm, adj‚ÇÇ.hom_equiv_naturality_left, other_map, assoc, adj‚ÇÇ.hom_equiv_naturality_left, ‚Üê adj‚ÇÇ.counit_naturality, adj‚ÇÇ.hom_equiv_naturality_left, adj‚ÇÇ.hom_equiv_unit, adj‚ÇÇ.right_triangle_components, comp_id, functor.comp_map, ‚Üê U.map_comp, assoc, ‚Üê adj‚ÇÅ.counit_naturality, adj‚ÇÇ.hom_equiv_unit, adj‚ÇÇ.hom_equiv_unit, F.map_comp, assoc]
refl
apply (adj‚ÇÅ.hom_equiv _ _).symm.subtype_equiv
intro g
rw [‚Üê (adj‚ÇÅ.hom_equiv _ _).symm.injective.eq_iff, adj‚ÇÅ.hom_equiv_counit, adj‚ÇÅ.hom_equiv_counit, adj‚ÇÅ.hom_equiv_counit, F.map_comp, assoc, U.map_comp, F.map_comp, assoc, adj‚ÇÅ.counit_naturality, adj‚ÇÅ.counit_naturality_assoc]
apply eq_comm
refine adjunction.left_adjoint_of_equiv (Œª X Y, construct_left_adjoint_equiv R _ adj‚ÇÅ adj‚ÇÇ Y X) _
intros X Y Y' g h
rw [construct_left_adjoint_equiv_apply, construct_left_adjoint_equiv_apply, function.comp_app, function.comp_app, equiv.trans_apply, equiv.trans_apply, equiv.trans_apply, equiv.trans_apply, equiv.symm_apply_eq, subtype.ext_iff, cofork.is_colimit.hom_iso_natural, equiv.apply_symm_apply, equiv.subtype_equiv_apply, equiv.subtype_equiv_apply, equiv.subtype_equiv_apply, equiv.subtype_equiv_apply, subtype.coe_mk, subtype.coe_mk, subtype.coe_mk, subtype.coe_mk, ‚Üê adj‚ÇÅ.hom_equiv_naturality_right_symm, cofork.is_colimit.hom_iso_natural, adj‚ÇÇ.hom_equiv_naturality_right, functor.comp_map]
simp
rw equiv.symm_apply_eq
simp [unit_comp_partial_bijective, unit_comp_partial_bijective_aux_symm_apply]
apply_instance
tidy
ext
refl
tidy
change f ‚â´ ùüô _ = ùüô _ ‚â´ f
simp
change f ‚â´ ùüô _ = ùüô _ ‚â´ f
ext
change (ùüô _) ‚â´ (ùüô _) = ùüô _
simp
ext
change (ùüô _) ‚â´ (ùüô _) = ùüô _
simp
change (ùüô X) ‚â´ (ùüô X) = ùüô X
simp
haveI := strict_initial t g
haveI := strict_initial t h
exact eq_of_inv_eq_inv (t.hom_ext _ _)
tidy
tidy
dsimp
rw left_unitor_naturality_assoc
letI := functor_category.prod_preserves_colimits F
apply is_left_adjoint_of_preserves_colimits (prod.functor.obj F)
dsimp
rw [‚Üê comp_f, iso.hom_inv_id, id_f]
rw [‚Üê comp_f, iso.inv_hom_id, id_f]
dsimp
apply_instance
dsimp [discrete]
simp
simp
simp only [cancel_mono]
apply_instance
apply_instance
apply_instance
apply_instance
cases F
cases F; refl
refl
cases Œ±
cases Œ±; cases Œ≤; cc
cases Œ±; cases Œ≤
cases Œ≤
cc
rw [iso.hom_inv_id, category.comp_id]
rw [category.assoc, ‚Üêw]
rw [iso.inv_hom_id, category.id_comp]
rw [cone_of_preserves_X_hom, assoc, assoc, (is_limit_of_preserves R t‚ÇÇ).fac, limit_auxiliary_cone_œÄ_app, ‚ÜêL.map_comp_assoc, t‚ÇÅ.fac, R.map_cone_œÄ_app, ‚ÜêR.map_comp, t‚ÇÇ.fac]
exact (s.œÄ.app j).w
simp [‚Üêw]
simp [‚Üêw]
let hG := types.colimit_cocone_is_colimit (F ‚ãô forget C)
let T : E ‚âÖ G := hE.unique_up_to_iso hG
let TX : E.X ‚âÖ G.X := (cocones.forget _).map_iso T
suffices : function.surjective (TX.hom ‚àò ff)
intro a
obtain ‚ü®b, hb‚ü© := this (TX.hom a)
refine ‚ü®b, _‚ü©
apply_fun TX.inv at hb
change (TX.hom ‚â´ TX.inv) (ff b) = (TX.hom ‚â´ TX.inv) _ at hb
{ intro a, obtain ‚ü®b, hb‚ü© := this (TX.hom a), refine ‚ü®b, _‚ü©, apply_fun TX.inv at hb, change (TX.hom ‚â´ TX.inv) (ff b) = (TX.hom ‚â´ TX.inv) _ at hb, simpa only [TX.hom_inv_id] using hb }
simpa only [TX.hom_inv_id] using hb
have : TX.hom ‚àò ff = Œª a, G.Œπ.app a.1 a.2
ext a
change (E.Œπ.app a.1 ‚â´ hE.desc G) a.2 = _
{ ext a, change (E.Œπ.app a.1 ‚â´ hE.desc G) a.2 = _, rw hE.fac }
rw hE.fac
rw this
rintro ‚ü®‚ü®j,a‚ü©‚ü©
exact ‚ü®‚ü®j,a‚ü©,rfl‚ü©
intro ff
let E := (forget C).map_cocone D
let hE : is_colimit E := is_colimit_of_preserves _ hD
let G := types.colimit_cocone (F ‚ãô forget C)
tidy
exactI has_colimit_of_coequalizer_and_coproduct F
apply_instance
apply_instance
resetI
resetI; apply_instance
apply_instance
rw [assoc, (t Y).fac _ j]
simpa using ((t X).fac_assoc ‚ü®s.X.obj X, whisker_right s.œÄ ((evaluation K C).obj X)‚ü© j _).symm
tidy
rw [assoc, limit.post_œÄ, ‚ÜêG.map_comp, limit.lift_œÄ, limit.lift_œÄ]
ext
refl
simp [‚Üê category.assoc]
ext1
ext1; simp [‚Üê category.assoc]
tidy
tidy
apply nat_iso.is_iso_of_is_iso_app _
intros F
apply nat_iso.is_iso_of_is_iso_app _
intros X
dsimp [adjunction]
simp only [category.id_comp]
exact is_iso.of_iso ((limit.is_limit _).cone_point_unique_up_to_iso (limit_of_diagram_initial structured_arrow.mk_id_initial _))
intro l
ext j
simp only [category.id_comp, limit.pre_œÄ]
congr' 1
simp
intros x y z f g
ext j
erw [limit.pre_pre, limit.pre_œÄ, limit.pre_œÄ]
congr' 1
tidy
exactI { has_colimit := Œª F, has_colimit.mk (colimit_cocone F) }
rw [cone_of_cocone_left_op_œÄ_app, colimit.cocone_Œπ, ‚Üêop_comp, colimit.Œπ_desc, cocone_left_op_of_cone_Œπ_app, quiver.hom.op_unop]
refl
have u := (colimit.is_colimit F.left_op).uniq (cocone_left_op_of_cone s) (m.unop)
clear u
convert congr_arg (Œª f : _ ‚ü∂ _, f.op) (u _)
intro j
rw [cocone_left_op_of_cone_Œπ_app, colimit.cocone_Œπ]
clear w
convert congr_arg (Œª f : _ ‚ü∂ _, f.unop) (w (unop j))
rw [cone_of_cocone_left_op_œÄ_app, colimit.cocone_Œπ, quiver.hom.unop_op]
refl
intros
cases a
cases b
congr
split
let equ := e.inv_fun_id_assoc (K ‚ãô F)
have := (is_limit_of_preserves F (t.whisker_equivalence e)).whisker_equivalence e.symm
apply ((is_limit.postcompose_hom_equiv equ _).symm this).of_iso_limit
refine cones.ext (iso.refl _) (Œª j, _)
simp [‚Üêfunctor.map_comp]
dsimp
exactI preserves_colimits_of_shape_of_nat_iso h
intros
cases a
cases b
cc
split
rw ‚Üê preserves_coproduct.inv_hom
apply_instance
ext T f
simpa [cocone_of_representable_Œπ_app] using functor_to_types.naturality _ _ Œ± f.op _
simp
simp
simp
ext
ext; simp
ext
ext; simp [add_comp]
simp [add_comp]
simp [add_comp]
simp [add_comp]
simp [add_comp]
tidy
exactI has_biproduct.of_has_coproduct _
simp [biproduct.lift_eq, biproduct.desc_eq, comp_sum, sum_comp, biproduct.Œπ_œÄ_assoc, comp_dite, dite_comp]
rw [‚Üês.w right, parallel_pair_map_right]
convert h one
exact (category.id_comp _).symm
cases j'
cases j
{ exact {hom.id none} }
exact {hom.id none}
{ cases j, { exact {hom.id none} }, { exact {hom.term j} } }
exact {hom.term j}
by_cases some j' = j
rw h
{ rw h, exact {hom.id j} }
exact {hom.id j}
exact ‚àÖ
tidy
apply_instance
apply_instance
apply_instance
apply_instance
resetI
apply_instance
apply_instance
simp [w]
to_lhs
congr
skip
rw ‚Üêimage_mono_iso_source_inv_Œπ f
conv { to_lhs, congr, skip, rw ‚Üêimage_mono_iso_source_inv_Œπ f, }
rw [‚Üêcategory.assoc, iso.hom_inv_id, category.id_comp]
apply_instance
rw [small_k.comm_assoc]
refine ‚ü®_, _, _, _‚ü©
apply (pullback_cone.is_limit.lift' small_k.is_limit s.fst s.snd _).1
rw [‚Üê cancel_mono f‚ÇÇ, assoc, s.condition, assoc]
apply (pullback_cone.is_limit.lift' small_k.is_limit s.fst s.snd _).2.1
apply (pullback_cone.is_limit.lift' small_k.is_limit s.fst s.snd _).2.2
intros m m‚ÇÅ m‚ÇÇ
apply small_k.is_limit.hom_ext
refine ((pullback_cone.mk a b _) : pullback_cone f‚ÇÅ _).equalizer_ext _ _
rwa (pullback_cone.is_limit.lift' small_k.is_limit s.fst s.snd _).2.1
rwa (pullback_cone.is_limit.lift' small_k.is_limit s.fst s.snd _).2.2
cases j
exact fac s
{ exact fac s, }
simp
rw [cofork.condition, zero_comp]
apply_instance
simp
simp [h]
dsimp
rw [‚Üê F.map_comp, category.comp_id, tX.hom_ext (k ‚â´ tX.from j') (tX.from j)]
refine ‚ü®Œª i, _, _, _‚ü©
apply classical.some (t (s.Œπ i) _)
{ apply classical.some (t (s.Œπ i) _), apply congr_fun s.condition i }
apply congr_fun s.condition i
ext i
{ ext i, apply (classical.some_spec (t (s.Œπ i) _)).1 }
apply (classical.some_spec (t (s.Œπ i) _)).1
intros m hm
ext i
apply (classical.some_spec (t (s.Œπ i) _)).2
apply congr_fun hm i
tidy
cases g
cases g; { dsimp, simp }
dsimp
simp
cases f with _ j
{ apply (ùüô _) }
apply (ùüô _)
exact arrows j
tidy
apply (limit_equiv_sections F).injective
ext j
simp [w j]
change quot.mk _ _ = quot.mk _ _ ‚Üî _
rw [quot.eq, filtered_colimit.rel_eq_eqv_gen_quot_rel]
apply monadic_of_has_preserves_reflects_G_split_coequalizers _
{ apply_instance }
apply_instance
{ assumption }
assumption
{ assumption }
assumption
introsI A B f g i
apply reflects_colimit_of_reflects_isomorphisms
simp [‚Üêunitors_equal]
ext
rw [‚Üêtensor_comp, f.hom_inv_id]
rw [‚Üêh.hom_equiv_naturality_left, ‚Üêh.hom_equiv_naturality_right, equiv.apply_eq_iff_eq, assoc, is_iso.eq_inv_comp, ‚ÜêF.to_lax_monoidal_functor.Œº_natural_assoc, is_iso.hom_inv_id_assoc, ‚Üêtensor_comp, adjunction.counit_naturality, adjunction.counit_naturality, tensor_comp]
rw [‚Üêh.hom_equiv_naturality_right, ‚Üêh.hom_equiv_naturality_left, ‚Üêh.hom_equiv_naturality_left, ‚Üêh.hom_equiv_naturality_left, equiv.apply_eq_iff_eq, ‚Üê cancel_epi (F.to_lax_monoidal_functor.Œº (G.obj X ‚äó G.obj Y) (G.obj Z)), ‚Üê cancel_epi (F.to_lax_monoidal_functor.Œº (G.obj X) (G.obj Y) ‚äó ùüô (F.obj (G.obj Z))), F.to_lax_monoidal_functor.associativity_assoc (G.obj X) (G.obj Y) (G.obj Z), ‚ÜêF.to_lax_monoidal_functor.Œº_natural_assoc, assoc, is_iso.hom_inv_id_assoc, ‚ÜêF.to_lax_monoidal_functor.Œº_natural_assoc, is_iso.hom_inv_id_assoc, ‚Üêtensor_comp, ‚Üêtensor_comp, id_comp, functor.map_id, functor.map_id, id_comp, ‚Üêtensor_comp_assoc, ‚Üêtensor_comp_assoc, id_comp, id_comp, h.hom_equiv_unit, h.hom_equiv_unit, functor.map_comp, assoc, assoc, h.counit_naturality, h.left_triangle_components_assoc, is_iso.hom_inv_id_assoc, functor.map_comp, assoc, h.counit_naturality, h.left_triangle_components_assoc, is_iso.hom_inv_id_assoc]
exact associator_naturality (h.counit.app X) (h.counit.app Y) (h.counit.app Z)
rw [‚Üêh.hom_equiv_naturality_right, ‚Üêh.hom_equiv_naturality_left, ‚Üêequiv.symm_apply_eq, h.hom_equiv_counit, F.map_left_unitor, h.hom_equiv_unit, assoc, assoc, assoc, F.map_tensor, assoc, assoc, is_iso.hom_inv_id_assoc, ‚Üêtensor_comp_assoc, functor.map_id, id_comp, functor.map_comp, assoc, h.counit_naturality, h.left_triangle_components_assoc, ‚Üêleft_unitor_naturality, ‚Üêtensor_comp_assoc, id_comp, comp_id]
rw [‚Üêh.hom_equiv_naturality_right, ‚Üêh.hom_equiv_naturality_left, ‚Üêequiv.symm_apply_eq, h.hom_equiv_counit, F.map_right_unitor, assoc, assoc, ‚Üêright_unitor_naturality, ‚Üêtensor_comp_assoc, comp_id, id_comp, h.hom_equiv_unit, F.map_tensor, assoc, assoc, assoc, is_iso.hom_inv_id_assoc, functor.map_comp, functor.map_id, ‚Üêtensor_comp_assoc, assoc, h.counit_naturality, h.left_triangle_components_assoc, id_comp]
rw [‚Üêcomp_right_adjoint_mate, category.comp_id, right_adjoint_mate_id]
rw [‚Üêcomp_right_adjoint_mate, category.comp_id, right_adjoint_mate_id]
dsimp
simp only [equivalence.inv_fun_map, functor.map_comp, tensor_comp, category.assoc]
simp only [‚Üêe.functor.map_comp]
congr' 1
rw [‚Üêtensor_comp, iso.hom_inv_id_app, iso.hom_inv_id_app, ‚Üêtensor_comp]
dsimp
rw [comp_id, comp_id]
dsimp
simp only [comp_tensor_id, assoc, equivalence.inv_fun_map, functor.map_comp, id_tensor_comp, e.inverse.map_id]
simp only [‚Üêe.functor.map_comp]
congr' 2
rw [‚Üêtensor_id_comp_id_tensor]
slice_lhs 3 3 { rw [‚Üêtensor_id_comp_id_tensor], }
rw [‚Üêcomp_tensor_id, iso.hom_inv_id_app]
slice_lhs 2 3 { rw [‚Üêcomp_tensor_id, iso.hom_inv_id_app], dsimp, rw [tensor_id] }
dsimp
rw [tensor_id]
simp only [id_comp]
rw [‚Üêid_tensor_comp, iso.hom_inv_id_app]
slice_rhs 2 3 { rw [‚Üêid_tensor_comp, iso.hom_inv_id_app], dsimp, rw [tensor_id] }
dsimp
rw [tensor_id]
simp only [id_comp]
rw [‚Üêid_tensor_comp_tensor_id _ (e.unit_inv.app X)]
conv_rhs { rw [‚Üêid_tensor_comp_tensor_id _ (e.unit_inv.app X)], }
dsimp only [functor.comp_obj]
rw [‚Üêid_tensor_comp, iso.hom_inv_id_app]
slice_rhs 3 4 { rw [‚Üêid_tensor_comp, iso.hom_inv_id_app], dsimp, rw [tensor_id] }
dsimp
rw [tensor_id]
simp only [id_comp]
simp [associator_naturality]
dsimp
simp only [tensor_id, assoc, id_comp, functor.map_comp, e.inverse.map_id]
rw equivalence.counit_app_functor
simp only [‚Üêe.functor.map_comp]
congr' 1
rw [‚Üêleft_unitor_naturality]
simp
dsimp
simp only [tensor_id, assoc, id_comp, functor.map_comp, e.inverse.map_id]
rw equivalence.counit_app_functor
simp only [‚Üêe.functor.map_comp]
congr' 1
rw [‚Üêright_unitor_naturality]
simp
have h := congr_arg (Œª f, (app X).inv ‚â´ (f ‚â´ (app Y).inv)) (naturality f).symm
simp only [iso.inv_hom_id_assoc, iso.hom_inv_id, assoc, comp_id, cancel_mono] at h
exact h
tidy
simp
simp
simp
ext ‚ü®‚ü© ‚ü®‚ü©
simp
ext ‚ü®‚ü© ‚ü®‚ü©
simp
ext
dsimp [embedding]
simp only [‚ÜêF.map_comp, biproduct.lift_œÄ, biproduct.matrix_œÄ, category.assoc]
simp only [‚ÜêF.map_comp, ‚ÜêF.map_sum, biproduct.lift_desc, biproduct.lift_œÄ_assoc, comp_sum]
simp only [comp_def, comp_dite, comp_zero, finset.sum_dite_eq', finset.mem_univ, if_true]
dsimp
simp only [finset.sum_singleton, dite_comp, zero_comp]
congr
symmetry
convert finset.sum_fn _ _
simp only [finset.sum_fn, finset.sum_dite_eq]
ext
simp
fapply homotopy.mk_inductive
{ exact lift_homotopy_zero_zero f comm, }
exact lift_homotopy_zero_zero f comm
{ simp [lift_homotopy_zero_zero], }
simp [lift_homotopy_zero_zero]
{ exact lift_homotopy_zero_one f comm, }
exact lift_homotopy_zero_one f comm
{ simp [lift_homotopy_zero_one], }
simp [lift_homotopy_zero_one]
rintro n ‚ü®g, g', w‚ü©
fsplit
{ exact lift_homotopy_zero_succ f n g g' w, }
exact lift_homotopy_zero_succ f n g g' w
simp [lift_homotopy_zero_succ, w]
haveI := subsingleton_of_forall_eq (0 : X ‚ü∂ Y) (Œª f, begin have p := not_congr (is_iso_iff_nonzero f), simp only [not_not, ne.def] at p, refine p.mp (Œª _, by exactI h (as_iso f)), end)
have p := not_congr (is_iso_iff_nonzero f)
simp only [not_not, ne.def] at p
exactI h (as_iso f)
refine p.mp (Œª _, by exactI h (as_iso f))
exact finrank_zero_of_subsingleton
simpa using comp_closure.intro (f ‚â´ x) m‚ÇÅ m‚ÇÇ y h
cases f
cases f; obviously
obviously
simp [covers_iff]
cases J‚ÇÇ
congr
apply h
cases J‚ÇÅ
simpa using trans (ùüô _)
ext T h
split
rintro ‚ü®hk‚ü©
exact pullback_arrows.mk _ _ (of_arrows.mk hk)
{ rintro ‚ü®hk‚ü©, exact pullback_arrows.mk _ _ (of_arrows.mk hk) }
rintro ‚ü®W, k, hk‚ÇÅ‚ü©
cases hk‚ÇÅ with i hi
apply of_arrows.mk
rintros Y Z f ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© g
simp [h‚ÇÅ, h‚ÇÇ]
rw [‚Üê id_mem_iff_eq_top, pullback_apply, category.id_comp]
congr
ext
cases f
ext
simpa using w.symm
simp [of_mk_le, of_le_mk, of_le, of_mk_le_mk, ‚Üêfunctor.map_comp_assoc underlying]
refine quotient.ind' (Œª f, _)
exact ‚ü®mono_over.le_top f‚ü©
simp
simp
simp
have : (limits.prod.fst : A ‚®Ø A ‚ü∂ _) = limits.prod.snd
{ simp [‚Üêcancel_epi (diag A)] }
simp [‚Üêcancel_epi (diag A)]
rw [‚Üêprod.lift_fst f g, this, prod.lift_snd]
apply_instance
apply_instance
simp
simp [blocks_fun, ones, blocks, i.2]
have fiber_none_is_false : (equiv.remove_none.fiber (@none Œ±)) -> false
exact is_empty.false
{ rw equiv.remove_none.fiber_none, exact is_empty.false }
rw equiv.remove_none.fiber_none
calc derangements (option Œ±) ‚âÉ equiv.perm.decompose_option '' derangements (option Œ±) : equiv.image _ _ ... ‚âÉ Œ£ (a : option Œ±), ‚Ü•(equiv.remove_none.fiber a) : set_prod_equiv_sigma _ ... ‚âÉ Œ£ (a : Œ±), ‚Ü•(equiv.remove_none.fiber (some a)) : sigma_option_equiv_of_some _ fiber_none_is_false ... ‚âÉ Œ£ (a : Œ±), {f : perm Œ± | fixed_points f ‚äÜ {a}} : by simp_rw equiv.remove_none.fiber_some
simp_rw equiv.remove_none.fiber_some
refl
{ refl }
induction n with n hn
rw [finset.sum_range_succ, num_derangements_succ, hn, finset.mul_sum, nat.sub_self, nat.asc_factorial_zero, int.coe_nat_one, mul_one, pow_succ, neg_one_mul, sub_eq_add_neg, add_left_inj, finset.sum_congr rfl]
intros x hx
have h_le : x ‚â§ n := finset.mem_range_succ_iff.mp hx
rw [nat.succ_sub h_le, nat.asc_factorial_succ, nat.add_sub_cancel' h_le, int.coe_nat_mul, int.coe_nat_succ, mul_left_comm]
exactI fintype.card Œπ' ‚â§ n ‚Üí (‚àÄ (s' : finset Œπ'), s'.card ‚â§ (s'.bUnion t').card) ‚Üí ‚àÉ (f : Œπ' ‚Üí Œ±), function.injective f ‚àß ‚àÄ x, f x ‚àà t' x
by_cases h : ‚àÄ (s : finset Œπ), s.nonempty ‚Üí s ‚â† univ ‚Üí s.card < (s.bUnion t).card
{ exact hall_hard_inductive_step_A hn ht @ih h, }
exact hall_hard_inductive_step_A hn ht @ih h
push_neg at h
rcases h with ‚ü®s, sne, snu, sle‚ü©
have seq := nat.le_antisymm (ht _) sle
exact hall_hard_inductive_step_B hn ht @ih s sne snu seq
tactic.unfreeze_local_instances
revert Œπ
refine nat.strong_induction_on n (Œª n' ih, _)
intros _ _ t hn ht
rcases n' with (_|_)
{ exact hall_hard_inductive_zero t hn }
exact hall_hard_inductive_zero t hn
apply hall_hard_inductive_step hn ht
introsI Œπ' _ _ hŒπ'
exact ih (fintype.card Œπ') (nat.lt_succ_of_le hŒπ') rfl
rw [multiset.coe_sum, c.blocks_sum]
exact G.irrefl hab
rintro rfl
rw set.disjoint_iff
rintro w ‚ü®h, h'‚ü©
rw [mem_neighbor_set, compl_adj] at h'
exact h'.2 h
refl
rw [common_neighbors, set.inter_comm]
convert univ.card.pred_eq_sub_one
erw [degree, neighbor_finset_eq_filter, filter_ne, card_erase_of_mem (mem_univ v)]
obtain ‚ü®t, ht : _ = _‚ü© := min_of_nonempty (univ_nonempty.image (Œª v, G.degree v))
obtain ‚ü®v, _, rfl‚ü© := mem_image.mp (mem_of_min ht)
simp [min_degree, ht]
refine ‚ü®v, by simp [min_degree, ht]‚ü©
simpa using dart_edge_eq_iff d' d
rcases G.even_card_odd_degree_vertices with ‚ü®k, hg‚ü©
have hk : 0 < k
have hh : (filter (Œª (v : V), odd (G.degree v)) univ).nonempty
use v
simp only [true_and, mem_filter, mem_univ]
{ use v, simp only [true_and, mem_filter, mem_univ], use h, }
use h
rwa [‚Üêcard_pos, hg, zero_lt_mul_left] at hh
{ have hh : (filter (Œª (v : V), odd (G.degree v)) univ).nonempty, { use v, simp only [true_and, mem_filter, mem_univ], use h, }, rwa [‚Üêcard_pos, hg, zero_lt_mul_left] at hh, exact zero_lt_two, }
exact zero_lt_two
have hc : (Œª (w : V), w ‚â† v ‚àß odd (G.degree w)) = (Œª (w : V), odd (G.degree w) ‚àß w ‚â† v)
ext w
{ ext w, rw and_comm, }
rw and_comm
simp only [hc, filter_congr_decidable]
rw [‚Üêfilter_filter, filter_ne', card_erase_of_mem]
use k - 1
rw [nat.pred_eq_succ_iff, hg, nat.mul_sub_left_distrib, ‚Üê nat.sub_add_comm, eq_comm, ‚Üê (nat.sub_eq_iff_eq_add _).symm]
{ ring }
ring
{ exact add_le_add_right (zero_le (2 * k)) 2 }
exact add_le_add_right (zero_le (2 * k)) 2
{ use k - 1, rw [nat.pred_eq_succ_iff, hg, nat.mul_sub_left_distrib, ‚Üê nat.sub_add_comm, eq_comm, ‚Üê (nat.sub_eq_iff_eq_add _).symm], { ring }, { exact add_le_add_right (zero_le (2 * k)) 2 }, { exact nat.mul_le_mul_left _ hk } }
exact nat.mul_le_mul_left _ hk
simpa only [true_and, mem_filter, mem_univ]
classical
haveI : decidable_eq V
apply_instance
{ classical, apply_instance }
rcases G.odd_card_odd_degree_vertices_ne v h with ‚ü®k, hg‚ü©
have hg' : (filter (Œª (w : V), w ‚â† v ‚àß odd (G.degree w)) univ).card > 0
rw hg
{ rw hg, apply nat.succ_pos, }
apply nat.succ_pos
rcases card_pos.mp hg' with ‚ü®w, hw‚ü©
simp only [true_and, mem_filter, mem_univ, ne.def] at hw
exact ‚ü®w, hw‚ü©
rw language.mem_star at hy
rcases hy with ‚ü® S, rfl, hS ‚ü©
induction S with a S ih
{ refl }
refl
have ha := hS a (list.mem_cons_self _ _)
rw set.mem_singleton_iff at ha
rw [list.join, eval_from_of_append, ha, hx]
apply ih
intros z hz
exact hS z (list.mem_cons_of_mem a hz)
simp [vector.m_of_fn]
simp [vector.m_of_fn]; exact (hf 0).bind (partrec.bind ((vector_m_of_fn (Œª i, hf i.succ)).comp fst) (primrec.vector_cons.to_comp.comp (snd.comp fst) snd))
exact (hf 0).bind (partrec.bind ((vector_m_of_fn (Œª i, hf i.succ)).comp fst) (primrec.vector_cons.to_comp.comp (snd.comp fst) snd))
cases f a; refl
refl
refl
cases f a
simp [encode_code_eq, encode_code, -add_comm]
have := nat.mul_le_mul_right _ (dec_trivial : 1 ‚â§ 2*2)
rw [one_mul, mul_assoc, ‚Üê bit0_eq_two_mul, ‚Üê bit0_eq_two_mul] at this
have := lt_of_le_of_lt this (lt_add_of_pos_right _ (dec_trivial:0<4))
exact ‚ü® lt_of_le_of_lt (nat.left_le_mkpair _ _) this, lt_of_le_of_lt (nat.right_le_mkpair _ _) this‚ü©
simp [encode_code_eq, encode_code, -add_comm]
have := nat.mul_le_mul_right _ (dec_trivial : 1 ‚â§ 2*2)
rw [one_mul, mul_assoc, ‚Üê bit0_eq_two_mul, ‚Üê bit0_eq_two_mul] at this
refine lt_of_le_of_lt (le_trans this _) (lt_add_of_pos_right _ (dec_trivial:0<4))
exact le_of_lt (nat.bit0_lt_bit1 $ le_of_lt $ nat.bit0_lt_bit1 $ le_refl _)
simp; induction p.unpair.2; simp [*, pow_succ']
simp; induction p.unpair.2
induction p.unpair.2
simp [*, pow_succ']
simp [*, pow_succ']
simp
simp
induction pf
exact const 0
case nat.primrec'.zero { exact const 0 }
exact primrec.succ.comp vector_head
case nat.primrec'.succ { exact primrec.succ.comp vector_head }
case nat.primrec'.nth : n i { exact vector_nth.comp primrec.id (const i) }
exact vector_nth.comp primrec.id (const i)
case nat.primrec'.comp : m n f g _ _ hf hg { exact hf.comp (vector_of_fn (Œª i, hg i)) }
exact hf.comp (vector_of_fn (Œª i, hg i))
case nat.primrec'.prec : n f g _ _ hf hg { exact nat_elim' vector_head (hf.comp vector_tail) (hg.comp $ vector_cons.comp (fst.comp snd) $ vector_cons.comp (snd.comp snd) $ (@vector_tail _ _ (n+1)).comp fst).to‚ÇÇ }
exact nat_elim' vector_head (hf.comp vector_tail) (hg.comp $ vector_cons.comp (fst.comp snd) $ vector_cons.comp (snd.comp snd) $ (@vector_tail _ _ (n+1)).comp fst).to‚ÇÇ
rw v.eq_nil
rw v.eq_nil; refl
refl
simp
simp
cases decode Œ± n.unpair.1; simp
simp
simp
cases decode Œ± n.unpair.1
cases decode Œ≤ n.unpair.2; simp
simp
simp
cases decode Œ≤ n.unpair.2
simpa [encodek] using h.comp fst ((@primrec.encode Œ≤ _).comp snd)
simpa using cond hc hf hg
cases o‚ÇÅ
cases o‚ÇÅ; cases o‚ÇÇ; refl
cases o‚ÇÅ; cases o‚ÇÇ
cases o‚ÇÇ
cases o‚ÇÇ
refl
refl
refl
refl
letI H := primcodable.prim (list ‚Ñï); exact have primrec‚ÇÇ (Œª (a : Œ±) (o : option (list ‚Ñï)), o.map (list.cons (encode a))), from option_map snd $ (list_cons' H).comp ((@primrec.encode Œ± _).comp (fst.comp fst)) snd, have primrec (Œª n, (of_nat (list ‚Ñï) n).reverse.foldl (Œª o m, (decode Œ± m).bind (Œª a, o.map (list.cons (encode a)))) (some [])), from list_foldl' H ((list_reverse' H).comp (primrec.of_nat (list ‚Ñï))) (const (some [])) (primrec.comp‚ÇÇ (bind_decode_iff.2 $ primrec‚ÇÇ.swap this) primrec‚ÇÇ.right), nat_iff.1 $ (encode_iff.2 this).of_eq $ Œª n, begin rw list.foldl_reverse, apply nat.case_strong_induction_on n, { simp }, intros n IH, simp, cases decode Œ± n.unpair.1 with a, {refl}, simp, suffices : ‚àÄ (o : option (list ‚Ñï)) p (_ : encode o = encode p), encode (option.map (list.cons (encode a)) o) = encode (option.map (list.cons a) p), from this _ _ (IH _ (nat.unpair_right_le n)), intros o p IH, cases o; cases p; injection IH with h, exact congr_arg (Œª k, (nat.mkpair (encode a) k).succ.succ) h end
exact have primrec‚ÇÇ (Œª (a : Œ±) (o : option (list ‚Ñï)), o.map (list.cons (encode a))), from option_map snd $ (list_cons' H).comp ((@primrec.encode Œ± _).comp (fst.comp fst)) snd, have primrec (Œª n, (of_nat (list ‚Ñï) n).reverse.foldl (Œª o m, (decode Œ± m).bind (Œª a, o.map (list.cons (encode a)))) (some [])), from list_foldl' H ((list_reverse' H).comp (primrec.of_nat (list ‚Ñï))) (const (some [])) (primrec.comp‚ÇÇ (bind_decode_iff.2 $ primrec‚ÇÇ.swap this) primrec‚ÇÇ.right), nat_iff.1 $ (encode_iff.2 this).of_eq $ Œª n, begin rw list.foldl_reverse, apply nat.case_strong_induction_on n, { simp }, intros n IH, simp, cases decode Œ± n.unpair.1 with a, {refl}, simp, suffices : ‚àÄ (o : option (list ‚Ñï)) p (_ : encode o = encode p), encode (option.map (list.cons (encode a)) o) = encode (option.map (list.cons a) p), from this _ _ (IH _ (nat.unpair_right_le n)), intros o p IH, cases o; cases p; injection IH with h, exact congr_arg (Œª k, (nat.mkpair (encode a) k).succ.succ) h end
letI H := primcodable.prim (list ‚Ñï)
rw list.foldl_reverse
apply nat.case_strong_induction_on n
simp
{ simp }
simp
intros n IH
refl
cases decode Œ± n.unpair.1 with a
{refl}
simp
suffices : ‚àÄ (o : option (list ‚Ñï)) p (_ : encode o = encode p), encode (option.map (list.cons (encode a)) o) = encode (option.map (list.cons a) p)
from this _ _ (IH _ (nat.unpair_right_le n))
intros o p IH
cases o; cases p; injection IH with h
cases o; cases p
cases p
cases p
injection IH with h
injection IH with h
injection IH with h
injection IH with h
cases o
exact congr_arg (Œª k, (nat.mkpair (encode a) k).succ.succ) h
refl
simp [head]
rcases s with _|_|_; refl
refl
refl
refl
rcases s with _|_|_
rw (_ : TM1.init _ = _)
refine ‚ü®list_blank.mk (L.reverse.map $ Œª a, update (default _) k (some a)), Œª k', _‚ü©
refine list_blank.ext (Œª i, _)
rw [list_blank.map_mk, list_blank.nth_mk, list.inth, list.map_map, (‚àò), list.nth_map, proj, pointed_map.mk_val]
by_cases k' = k
simp only [function.update_same]
subst k'
{ subst k', simp only [function.update_same], rw [list_blank.nth_mk, list.inth, ‚Üê list.map_reverse, list.nth_map] }
rw [list_blank.nth_mk, list.inth, ‚Üê list.map_reverse, list.nth_map]
simp only [function.update_noteq h]
rw [list_blank.nth_mk, list.inth, list.map, list.reverse_nil, list.nth]
cases L.reverse.nth i; refl
refl
refl
{ refine ‚ü®list_blank.mk (L.reverse.map $ Œª a, update (default _) k (some a)), Œª k', _‚ü©, refine list_blank.ext (Œª i, _), rw [list_blank.map_mk, list_blank.nth_mk, list.inth, list.map_map, (‚àò), list.nth_map, proj, pointed_map.mk_val], by_cases k' = k, { subst k', simp only [function.update_same], rw [list_blank.nth_mk, list.inth, ‚Üê list.map_reverse, list.nth_map] }, { simp only [function.update_noteq h], rw [list_blank.nth_mk, list.inth, list.map, list.reverse_nil, list.nth], cases L.reverse.nth i; refl } }
cases L.reverse.nth i
dsimp only
congr
congr; cases L.reverse; try {refl}
congr; cases L.reverse
cases L.reverse
cases L.reverse
rw [tr_init, TM1.init]
try {refl}
try {refl}
try {refl}
try {refl}
refl
refl
simp only [list.map_map, list.tail_cons, list.map]
rw [‚Üê list_blank.cons_head_tail l]
conv {to_lhs, rw [‚Üê list_blank.cons_head_tail l]}
to_lhs
exact quotient.induction_on' l.tail (Œª l, rfl)
induction l‚ÇÅ; simp only [*, list_blank.append, list.nil_append, list.cons_append, list_blank.cons_mk]
simp only [*, list_blank.append, list.nil_append, list.cons_append, list_blank.cons_mk]
simp only [*, list_blank.append, list.nil_append, list.cons_append, list_blank.cons_mk]
induction l‚ÇÅ
intro
intro; simp only [list_blank.append_mk, list.append_assoc]
simp only [list_blank.append_mk, list.append_assoc]
simp [applicative.pure_seq_eq_map'] with functor_norm
refine { .. }; intros; cases x; refl
refine { .. }; intros; cases x
refine { .. }; intros
intros
intros
cases x
cases x
refl
refl
refine { .. }
let p := Œª (i : ‚Ñï), (fix.approx f i x).dom
have : p (nat.find h') := nat.find_spec h'
generalize hk : nat.find h' = k
replace hk : nat.find h' = k + (@upto.zero p).val := hk
rw hk at this
revert hk
rw assert_pos h'
revert this
dsimp [part.fix]
intros
generalize : upto.zero = z
suffices : ‚àÄ x', well_founded.fix (fix._proof_1 f x h') (fix_aux f) z x' = fix.approx f (succ k) x'
from this _
induction k generalizing z; intro
intro
intro
induction k generalizing z
rw [fix.approx,well_founded.fix_eq,fix_aux]
ext : 1
rw assert_neg
refl
congr
rw nat.zero_add at this
{ rw [fix.approx,well_founded.fix_eq,fix_aux], congr, ext : 1, rw assert_neg, refl, rw nat.zero_add at this, simpa only [not_not, subtype.val_eq_coe] }
simpa only [not_not, subtype.val_eq_coe]
rw [fix.approx,well_founded.fix_eq,fix_aux]
ext : 1
congr
have hh : ¬¨(fix.approx f (z.val) x).dom
apply nat.find_min h'
rw [hk,nat.succ_add,‚Üê nat.add_succ]
apply nat.lt_of_succ_le
{ apply nat.find_min h', rw [hk,nat.succ_add,‚Üê nat.add_succ], apply nat.lt_of_succ_le, apply nat.le_add_left }
apply nat.le_add_left
rw succ_add_eq_succ_add at this hk
rw [assert_pos hh, k_ih (upto.succ z hh) this hk]
intros
intros; ext; apply list.mfoldr_append
intros; ext
ext
apply list.mfoldr_append
simp only [list.reverse_reverse]
simp only [list.foldr_eta]
simp only [flip,list.foldr_reverse,foldl.of_free_monoid, unop_op]
have : is_monoid_hom (foldl.of_free_monoid (flip $ @cons Œ±))
apply fold_foldl
{ apply fold_foldl }
rw fold_map_hom_free this
simp only [to_list, foldl, list.reverse_inj, foldl.get, foldl.of_free_monoid_comp_free_mk]
all_goals { apply_instance }
apply_instance
ext1 Œ±
exact funext (h Œ±)
apply coe_inj
funext
funext; refl
refl
simp [this] with functor_norm
simp [traverse_append as bs] with functor_norm
simp [traverse_append as bs] with functor_norm; congr
congr
simp
simpa using h‚ÇÅ
{simpa using h‚ÇÅ}
have h‚ÇÉ : j < n
rw [to_list_nth_le _ h‚ÇÉ]
refine let ‚ü®_, e‚ü© := list.nth_eq_some.1 _ in e.symm
by_cases ij : (i : ‚Ñï) = j
rw [show (‚ü®(i : ‚Ñï), h‚ÇÉ‚ü© : fin _) = i, from fin.eq_of_veq rfl, array.read_write, list.nth_update_nth_of_lt]
subst j
{ subst j, rw [show (‚ü®(i : ‚Ñï), h‚ÇÉ‚ü© : fin _) = i, from fin.eq_of_veq rfl, array.read_write, list.nth_update_nth_of_lt], simp [h‚ÇÉ] }
simp [h‚ÇÉ]
rw [list.nth_update_nth_ne _ _ ij, a.read_write_of_ne, to_list_nth.2 ‚ü®h‚ÇÉ, rfl‚ü©]
exact fin.ne_of_vne ij
rw ‚Üêrev_list_reverse; exact list.mem_reverse.trans mem_rev_list
exact list.mem_reverse.trans mem_rev_list
rw ‚Üêrev_list_reverse
simp [H]
by_cases p; simp *
simp *
simp *
by_cases p
split
introI
constructor
intros _ _ hn
obtain ‚ü®_, _, h‚ü© := bounded.exists (@parser.decorate_errors Œ± msgs p) hn
simp [decorate_errors_eq_fail] at h
{ introI, constructor, intros _ _ hn, obtain ‚ü®_, _, h‚ü© := bounded.exists (@parser.decorate_errors Œ± msgs p) hn, simp [decorate_errors_eq_fail] at h, exact h.right.right }
exact h.right.right
introI
constructor
intros _ _ hn
obtain ‚ü®_, _, h‚ü© := bounded.exists p hn
simp [h]
apply not_step_of_static_done
simp [remaining_eq_done]
simp [eq_comm]
simp [many, foldr_eq_fail]
simp [many1, seq_eq_done, map_eq_done]
apply_instance
simp [bit0]
simp [norm_sq]
rw [fpow_bit1', I_mul_I]
simp [lt_def, mul_re, mul_im, ‚Üê hz.2, ‚Üê hw.2, mul_pos hz.1 hw.1]
cases H _ ij with H‚ÇÅ H‚ÇÇ
apply lt_of_le_of_lt (abs_le_abs_re_add_abs_im _)
dsimp [lim_aux] at *
have := add_lt_add H‚ÇÅ H‚ÇÇ
rwa add_halves at this
simp [cau_seq_conj, (lim_re _).symm, cau_seq_re]
simp [cau_seq_conj, (lim_im _).symm, cau_seq_im, (lim_neg _).symm]; refl
refl
simp [cau_seq_conj, (lim_im _).symm, cau_seq_im, (lim_neg _).symm]
simp only [‚Üê sq, sin_sq_le_one]
simp [sum_range_succ]
simp [two_mul, mul_two, mul_add, mul_comm]
refine (_root_.abs_sub_le _ _ _).trans ((add_le_add_right h _).trans _)
rw [exp_near_succ, exp_near_sub, _root_.abs_mul]
subst e‚ÇÅ
convert mul_le_mul_of_nonneg_left (le_sub_iff_add_le'.1 e) _
simp [mul_add, pow_succ', div_eq_mul_inv, _root_.abs_mul, _root_.abs_inv, ‚Üê pow_abs, mul_inv']
{ simp [mul_add, pow_succ', div_eq_mul_inv, _root_.abs_mul, _root_.abs_inv, ‚Üê pow_abs, mul_inv'], ac_refl }
ac_refl
simp [_root_.div_nonneg, _root_.abs_nonneg]
convert Œµ0
cases j
{ exact absurd hj (not_le_of_gt zero_lt_one) }
exact absurd hj (not_le_of_gt zero_lt_one)
dsimp [exp']
induction j with j ih
dsimp [exp']; simp
simp
{ dsimp [exp']; simp }
dsimp [exp']
rw ‚Üê ih dec_trivial
simp only [sum_range_succ, pow_succ]
simp
rw [nat.cast_zero, zero_mul, exp_zero, pow_zero]
rw [pow_succ', nat.cast_add_one, add_mul, exp_add, ‚Üêexp_nat_mul, one_mul]
simp [norm_sq_eq_def]
simp [div_eq_mul_inv, mul_assoc, sub_eq_add_neg]
tauto
have := I_mul_I_ax
rw [mul_self_abs, add_mul_self_eq, mul_self_abs, mul_self_abs, add_right_comm, norm_sq_add, add_le_add_iff_left, mul_assoc, mul_le_mul_left (@zero_lt_two ‚Ñù _ _)]
simpa [-mul_re] using re_le_abs (z * conj w)
simp only [add_monoid_hom.map_zero]
unfold_coes
unfold_coes; simp [add_zero, id.def, mul_zero]
simp [add_zero, id.def, mul_zero]
simp only [add_monoid_hom.id_apply, algebra.id.map_eq_self]
simp only [add_monoid_hom.zero_apply]
simp only [sub_zero, mul_zero, add_monoid_hom.zero_apply, add_monoid_hom.id_apply]
simp only [add_zero, zero_mul, mul_zero, add_monoid_hom.zero_apply]
simp only [ring_hom.id_apply]
simp only [neg_zero, add_monoid_hom.zero_apply]
simp only [ring_hom.map_zero, neg_zero]
simp only [sq, norm, ‚Üêabs_mul, abs_mul_self z, add_zero, mul_zero, add_monoid_hom.zero_apply, add_monoid_hom.id_apply]
simp only [mul_zero, add_monoid_hom.zero_apply]
simp [sq, real.norm_eq_abs, abs_mul_abs_self, ‚Üê div_eq_mul_inv]
simp only [div_zero, mul_zero, neg_zero]
simp [norm_eq_abs]
rw [ring_hom.map_one, zero_smul, add_zero]
rw [add_mul, mul_add, mul_add, add_comm _ (y‚ÇÅ ‚Ä¢ I' * y‚ÇÇ ‚Ä¢ I'), add_add_add_comm]
congr' 1
rw [smul_mul_smul, hf, smul_neg, ‚Üêalgebra.algebra_map_eq_smul_one, ‚Üêsub_eq_add_neg, ‚Üêring_hom.map_mul, ‚Üêring_hom.map_sub]
{ rw [smul_mul_smul, hf, smul_neg, ‚Üêalgebra.algebra_map_eq_smul_one, ‚Üêsub_eq_add_neg, ‚Üêring_hom.map_mul, ‚Üêring_hom.map_sub], }
rw [algebra.smul_def, algebra.smul_def, algebra.smul_def, ‚Üêalgebra.right_comm _ x‚ÇÇ, ‚Üêmul_assoc, ‚Üêadd_mul, ‚Üêring_hom.map_mul, ‚Üêring_hom.map_mul, ‚Üêring_hom.map_add]
ext
ext; simp [smul_re, smul_im, smul_comm]
simp [smul_re, smul_im, smul_comm]
simp [smul_re, smul_im, smul_comm]
ext
ext; simp [smul_re, smul_im, smul_assoc]
simp [smul_re, smul_im, smul_assoc]
simp [smul_re, smul_im, smul_assoc]
simp only [smul_apply, zero_smul, zero_apply]
simp only [add_apply, smul_apply, add_smul]
simp only [add_apply, subtype_domain_apply]
ext j
have := apply_ite (Œª x : Œ†‚ÇÄ i, Œ≤ i, x j) (p i) (single i x) 0
dsimp at this
rw [filter_apply, this]
obtain rfl | hij := decidable.eq_or_ne i j
{ refl, }
refl
rw [single_eq_of_ne hij, if_t_t, if_t_t]
cases ha
exact ha_h
apply (equiv.set.sum_diff_subset h).injective
simp only [apply_symm_apply, sum_diff_subset_apply_inr]
exact subtype.eq rfl
simp [swap_apply_def] {contextual := tt}
by_cases hab : a = b
{ simp [hab] }
simp [hab]
by_cases hax : x = a
{ simp [hax, eq_comm] }
simp [hax, eq_comm]
by_cases hbx : x = b
{ simp [hbx] }
simp [hbx]
simp [hab, hax, hbx, swap_apply_of_ne_of_ne]
ext x
cases x
simp [sum.map, swap_apply_def]
split_ifs; refl
refl
refl
refl
{ simp [sum.map, swap_apply_def], split_ifs; refl}
split_ifs
simp [sum.map, swap_apply_of_ne_of_ne]
simp
simp [and_assoc]
ext
cases s; simp [encode_sum, decode_sum, encodek]; refl
cases s; simp [encode_sum, decode_sum, encodek]
simp [encode_sum, decode_sum, encodek]
simp [encode_sum, decode_sum, encodek]
cases s
simp
cases n; refl
refl
refl
cases n
subst h
exact w
simp [raise', lower', nat.add_sub_cancel, lower_raise']
mfld_set_tac
rw [h‚ÇÇ x, h‚ÇÇ y]
rw f.map_mul
rw hB.mul_comm
simpa
rw [‚Üê e.map_mul, hxy, e.map_zero]
simpa using congr_arg e.symm hx
simpa using congr_arg e.symm hy
haveI : nontrivial B := hB.to_nontrivial
exact e.symm.injective.ne zero_ne_one
refine_struct { to_fun := ring_equiv.to_add_equiv }
refine_struct { to_fun := ring_equiv.to_add_equiv }; intros; refl
refine_struct { to_fun := ring_equiv.to_add_equiv }; intros
intros
intros
refl
refl
letI := equiv.has_mul e
exact Œ± ‚âÉ+* Œ≤
letI := equiv.has_add e
introsI
exact { map_add' := Œª x y, by { apply e.symm.injective, simp, refl, }, map_mul' := Œª x y, by { apply e.symm.injective, simp, refl, }, ..e }
apply e.symm.injective
simp
refl
apply e.symm.injective
simp
refl
resetI; apply e.injective.mul_zero_class _; intros; exact e.apply_symm_apply _
resetI; apply e.injective.mul_zero_class _; intros
resetI; apply e.injective.mul_zero_class _
apply e.injective.mul_zero_class _
intros
intros
resetI
exact e.apply_symm_apply _
exact e.apply_symm_apply _
show classical.some h = a
let h
have := classical.some_spec h
exact cast (congr_fun this a).symm rfl
from (le_coe_nat_add _ _).not_lt
have : ¬¨ (nat_add m i : ‚Ñï) < m
rw [add_cases, dif_neg this]
refine eq_of_heq ((eq_rec_heq _ _).trans _)
congr' 1
simp
dsimp [pred_above, succ_above]
rcases p with ‚ü®p, _‚ü©
rcases i with ‚ü®i, _‚ü©
cases lt_or_le i p with H H
rw if_pos
refl
exact H
simp
apply le_of_lt H
rw dif_neg
{ rw dif_neg, rw if_pos, refl, exact H, simp, apply le_of_lt H, }
rw if_neg
rw dif_pos
swap 3
{ exact lt_of_le_of_ne H (ne.symm h), }
exact lt_of_le_of_ne H (ne.symm h)
{ simp, }
simp
simp only [subtype.mk_eq_mk, ne.def, fin.cast_succ_mk] at h
simp only [pred, subtype.mk_lt_mk, not_lt]
exact nat.le_pred_of_lt (nat.lt_of_le_and_ne H (ne.symm h))
apply_instance
ext j
by_cases h : j = 0
refl
{ rw h, refl }
rw h
let j' := pred j h
have : j'.succ = j := succ_pred j h
rw [‚Üê this, cons_succ, comp_app, cons_succ]
simp [insert_nth_zero]
rw fin.eq_iff_veq
exact coe_val_of_lt a.property
simp only [nat.mod_eq_of_lt n.lt_succ_self]
rw [‚Üêfin.of_nat_eq_coe, fin.of_nat, fin.last]
ext
exact coe_val_of_lt (nat.lt.step a.is_lt)
rw [ext_iff, coe_pred, coe_cast_lt, coe_add, coe_one, mod_eq_of_lt, nat.add_sub_cancel]
exact add_lt_add_right h 1
exact sup_inf_sdiff _ _
rw union_comm
by_cases hi : i ‚àà s; simpa [hi]
simpa [hi]
simpa [hi]
by_cases hi : i ‚àà s
simp only [mem_filter, mem_union, and_or_distrib_left]
simpa only [mem_filter, mem_sdiff, and_comm, not_and] using Œª a, and_congr_right $ Œª h : a ‚àà s, (imp_iff_right h).symm.trans imp_not_comm
simp only [filter_not, inter_sdiff_self]
rcases s.eq_empty_or_nonempty with rfl|‚ü®x, hx‚ü©
simp
{ simp }
refine (nat.succ_le_of_lt (card_pos.2 ‚ü®x, hx‚ü©)).le_iff_eq.trans (card_eq_one.trans ‚ü®_, _‚ü©)
simp
{ rintro ‚ü®y, rfl‚ü©, simp }
rintro ‚ü®y, rfl‚ü©
exact Œª h, ‚ü®x, eq_singleton_iff_unique_mem.2 ‚ü®hx, Œª y hy, h _ hy _ hx‚ü©‚ü©
rw [‚Üê card_union_add_card_inter]
rw [card_eq_zero]
convert (add_zero _).symm
rwa [disjoint_iff] at h
haveI := classical.dec_eq Œ±; exact finset.induction_on s rfl (Œª a s has ih, by simp only [image_insert, bUnion_insert, ih])
exact finset.induction_on s rfl (Œª a s has ih, by simp only [image_insert, bUnion_insert, ih])
haveI := classical.dec_eq Œ±
simp only [image_insert, bUnion_insert, ih]
simp only [mem_bUnion, mem_image, mem_singleton, eq_comm]
simp only [disjoint_left, mem_insert, or_imp_distrib, forall_and_distrib, forall_eq]
refl
rw [finset.disjoint_left, set.disjoint_left]
intros a b
refine finset.induction_on b empty_right (Œª x s xs hi, symm _)
rw finset.insert_eq
apply union_of _ (symm hi)
refine finset.induction_on a empty_right (Œª a t ta hi, symm _)
rw finset.insert_eq
exact union_of singletons (symm hi)
rw [insert_inter_of_mem H, empty_inter]
simp [‚Üêcoe_inj, ‚Üêinf_eq_min, ‚Üêsup_eq_max, set.Ico_inter_Ico]
simp [Ico_‚Ñ§]
rcases one_lt_card.1 h‚ÇÇ with ‚ü®a, ha, b, hb, hab‚ü©
exact s.min'_lt_max' ha hb hab
rw [antidiagonal, antidiagonal', multiset.to_finsupp_support]
rw [antidiagonal, antidiagonal', multiset.to_finsupp_support]; refl
refl
simpa using (Iic_finset n).finite_to_set
ext a
assume v‚ÇÅ v‚ÇÇ eq
have : map_domain f v‚ÇÅ (f a) = map_domain f v‚ÇÇ (f a)
rw eq
{ rw eq }
rwa [map_domain_apply hf, map_domain_apply hf] at this
simp
simp only [true_and, finset.mem_univ, iff_self, finset.mem_filter, finset.filter_congr_decidable, forall_true_iff]
ext a
refl
intro f
ext a
refl
intro f
rw subsingleton.elim D; refl
refl
rw subsingleton.elim D
rw [finsupp.mem_support_iff, finsupp.on_finset_apply]
rw f.support.prod_ite_eq'
dsimp [finsupp.prod]
subst h
subst h; simp only [add_apply, single_eq_same, erase_same, zero_add]
simp only [add_apply, single_eq_same, erase_same, zero_add]
simp only [add_apply, single_eq_of_ne h, add_zero, erase_ne (ne.symm h)]
rw [‚Üê finset.mem_def, mem_split_support_iff_nonzero]
exact (decidable.em _).symm
refine on_finset (finset.sigma f.support (Œª j, (f j).support)) (Œª ji, f ji.1 ji.2) (Œª g hg, finset.mem_sigma.mpr ‚ü®_, mem_support_iff.mpr hg‚ü©)
simp only [ne.def, dfinsupp.mem_support_to_fun]
intro h
rw h at hg
simpa using hg
ext
simp [split]
ext
simp [split]
simp
ext
simp
apply_instance
simp
haveI := classical.prop_decidable
exact (trunc_equiv_of_card_eq h).nonempty
cases int.units_eq_one_or x
cases int.units_eq_one_or x; simp *
simp *
simp *
simp
simp; exact ‚ü®b, fintype.complete _‚ü©
exact ‚ü®b, fintype.complete _‚ü©
cases b
cases b; apply ulift.fintype
apply ulift.fintype
apply ulift.fintype
rw [‚Üêcard_unit, card_eq]; exact ‚ü®Œª ‚ü®a‚ü©, ‚ü®a.symm (), Œª y, a.injective (subsingleton.elim _ _)‚ü©, Œª ‚ü®x, hx‚ü©, ‚ü®‚ü®Œª _, (), Œª _, x, Œª _, (hx _).trans (hx _).symm, Œª _, subsingleton.elim _ _‚ü©‚ü©‚ü©
exact ‚ü®Œª ‚ü®a‚ü©, ‚ü®a.symm (), Œª y, a.injective (subsingleton.elim _ _)‚ü©, Œª ‚ü®x, hx‚ü©, ‚ü®‚ü®Œª _, (), Œª _, x, Œª _, (hx _).trans (hx _).symm, Œª _, subsingleton.elim _ _‚ü©‚ü©‚ü©
rw [‚Üêcard_unit, card_eq]
simp [fintype.pi_finset, card_map]
let bkt := bkts.read hash_fn a
have nd : (bkt.map sigma.fst).nodup := v.nodup (mk_idx n (hash_fn a))
have lem : Œ† (bkts' : bucket_array Œ± Œ≤ n) (v1 u w) (hl : bucket_array.as_list bkts = u ++ v1 ++ w) (hfl : bucket_array.as_list bkts' = u ++ [‚ü®a, b‚ü©] ++ w) (veq : (v1 = [] ‚àß ¬¨ contains_aux a bkt) ‚à® ‚àÉb'', v1 = [‚ü®a, b''‚ü©]), sigma.mk a' b' ‚àà bkts'.as_list ‚Üî if a = a' then b == b' else sigma.mk a' b' ‚àà bkts.as_list
intros bkts' v1 u w hl hfl veq
rw [hl, hfl]
by_cases h : a = a'
subst a'
suffices : b = b' ‚à® sigma.mk a b' ‚àà u ‚à® sigma.mk a b' ‚àà w ‚Üî b = b'
{ simpa [eq_comm, or.left_comm] }
simpa [eq_comm, or.left_comm]
refine or_iff_left_of_imp (not.elim $ not_or_distrib.2 _)
rcases veq with ‚ü®rfl, Hnc‚ü© | ‚ü®b'', rfl‚ü©
have na := (not_iff_not_of_iff $ v.contains_aux_iff _ _).1 Hnc
simp [na]
{ have na := (not_iff_not_of_iff $ v.contains_aux_iff _ _).1 Hnc, simp [hl, not_or_distrib] at na, simp [na] }
simp [hl, not_or_distrib] at na
have nd' := v.as_list_nodup _
simp [nd']
{ subst a', suffices : b = b' ‚à® sigma.mk a b' ‚àà u ‚à® sigma.mk a b' ‚àà w ‚Üî b = b', { simpa [eq_comm, or.left_comm] }, refine or_iff_left_of_imp (not.elim $ not_or_distrib.2 _), rcases veq with ‚ü®rfl, Hnc‚ü© | ‚ü®b'', rfl‚ü©, { have na := (not_iff_not_of_iff $ v.contains_aux_iff _ _).1 Hnc, simp [hl, not_or_distrib] at na, simp [na] }, { have nd' := v.as_list_nodup _, simp [hl, list.nodup_append] at nd', simp [nd'] } }
simp [hl, list.nodup_append] at nd'
simp [h, ne.symm h, this]
{simp [h, ne.symm h, this]}
suffices : sigma.mk a' b' ‚àâ v1
rcases veq with ‚ü®rfl, Hnc‚ü© | ‚ü®b'', rfl‚ü©; simp [ne.symm h]
simp [ne.symm h]
simp [ne.symm h]
{ intros bkts' v1 u w hl hfl veq, rw [hl, hfl], by_cases h : a = a', { subst a', suffices : b = b' ‚à® sigma.mk a b' ‚àà u ‚à® sigma.mk a b' ‚àà w ‚Üî b = b', { simpa [eq_comm, or.left_comm] }, refine or_iff_left_of_imp (not.elim $ not_or_distrib.2 _), rcases veq with ‚ü®rfl, Hnc‚ü© | ‚ü®b'', rfl‚ü©, { have na := (not_iff_not_of_iff $ v.contains_aux_iff _ _).1 Hnc, simp [hl, not_or_distrib] at na, simp [na] }, { have nd' := v.as_list_nodup _, simp [hl, list.nodup_append] at nd', simp [nd'] } }, { suffices : sigma.mk a' b' ‚àâ v1, {simp [h, ne.symm h, this]}, rcases veq with ‚ü®rfl, Hnc‚ü© | ‚ü®b'', rfl‚ü©; simp [ne.symm h] } }
rcases veq with ‚ü®rfl, Hnc‚ü© | ‚ü®b'', rfl‚ü©
by_cases Hc : (contains_aux a bkt : Prop)
rcases hash_map.valid.replace_aux a b (array.read bkts (mk_idx n (hash_fn a))) ((contains_aux_iff nd).1 Hc) with ‚ü®u', w', b'', hl', hfl'‚ü©
rcases (append_of_modify u' [‚ü®a, b''‚ü©] [‚ü®a, b‚ü©] w' hl' hfl') with ‚ü®u, w, hl, hfl‚ü©
simpa [insert, @dif_pos (contains_aux a bkt) _ Hc] using lem _ _ u w hl hfl (or.inr ‚ü®b'', rfl‚ü©)
{ rcases hash_map.valid.replace_aux a b (array.read bkts (mk_idx n (hash_fn a))) ((contains_aux_iff nd).1 Hc) with ‚ü®u', w', b'', hl', hfl'‚ü©, rcases (append_of_modify u' [‚ü®a, b''‚ü©] [‚ü®a, b‚ü©] w' hl' hfl') with ‚ü®u, w, hl, hfl‚ü©, simpa [insert, @dif_pos (contains_aux a bkt) _ Hc] using lem _ _ u w hl hfl (or.inr ‚ü®b'', rfl‚ü©) }
let size' := size + 1
let bkts' := bkts.modify hash_fn a (Œªl, ‚ü®a, b‚ü©::l)
have mi : sigma.mk a' b' ‚àà bkts'.as_list ‚Üî if a = a' then b == b' else sigma.mk a' b' ‚àà bkts.as_list := let ‚ü®u, w, hl, hfl‚ü© := append_of_modify [] [] [‚ü®a, b‚ü©] _ rfl rfl in lem bkts' _ u w hl hfl $ or.inl ‚ü®rfl, Hc‚ü©
simp [insert, @dif_neg (contains_aux a bkt) _ Hc]
by_cases h : size' ‚â§ n
{ simpa [show size' ‚â§ n, from h] using mi }
simpa [show size' ‚â§ n, from h] using mi
let n' : ‚Ñï+ := ‚ü®n * 2, mul_pos n.2 dec_trivial‚ü©
let bkts'' : bucket_array Œ± Œ≤ n' := bkts'.foldl (mk_array _ []) (reinsert_aux hash_fn)
suffices : sigma.mk a' b' ‚àà bkts''.as_list ‚Üî sigma.mk a' b' ‚àà bkts'.as_list.reverse
{ simpa [show ¬¨ size' ‚â§ n, from h, mi] }
simpa [show ¬¨ size' ‚â§ n, from h, mi]
rw [show bkts'' = bkts'.as_list.foldl _ _, from bkts'.foldl_eq _ _, ‚Üê list.foldr_reverse]
induction bkts'.as_list.reverse with a l IH
{ simp [mk_as_list] }
simp [mk_as_list]
cases a with a'' b''
let B := l.foldr (Œª (y : sigma Œ≤) (x : bucket_array Œ± Œ≤ n'), reinsert_aux hash_fn x y.1 y.2) (mk_array n' [])
rcases append_of_modify [] [] [‚ü®a'', b''‚ü©] _ rfl rfl with ‚ü®u, w, hl, hfl‚ü©
simp [IH.symm, or.left_comm, show B.as_list = _, from hl, show (reinsert_aux hash_fn B a'' b'').as_list = _, from hfl]
rw [‚Üêhiis]
exact t.2
rw h
rw [‚Üê bitwise_diff, bitwise_bit]
simp
simp
apply_instance
simp [m0] at ae
simp [m0] at ae; simp [ae, m0]
simp [ae, m0]
cases eq_coe_of_zero_le (@nonneg_of_mul_nonneg_left ‚Ñ§ _ m a (by simp [ae.symm]) (by simpa using m0l)) with k e
simp [ae.symm]
simpa using m0l
exact ‚ü®k, int.coe_nat_inj ae‚ü©
subst a
rw [e, int.coe_nat_mul]
rw [sub_eq_add_neg, sub_eq_add_neg, int.add_div_of_dvd_right ((dvd_neg c b).mpr hcb)]
congr
exact neg_div_of_dvd hcb
rwa zero_mul
unfold bit1
unfold bit0
simp
apply nat.gcd_mul_right
rw [int.gcd, int.gcd, nat_abs_mul, nat_abs_mul]
exact nat.lcm_comm _ _
rw [int.lcm, int.lcm]
unfold gcd_a gcd_b; cases xgcd x y; refl
unfold gcd_a gcd_b; cases xgcd x y
cases xgcd x y
refl
unfold gcd_a gcd_b
simp [h]
rw [odd_iff_not_even, even_add, not_iff, odd_iff_not_even]
rw even_mul
convert n.even_or_odd
simp with parity_simps
simp [*, (dec_trivial : ¬¨ 2 = 0)] with parity_simps
simp
rw [hm, add_mod]
norm_num
rw h
abel
simpa only [exists_or_distrib, ‚Üê odd, ‚Üê even] using even_or_odd n
rcases le_iff_exists_add.1 h with ‚ü®m, rfl‚ü©
rw [nat.add_sub_cancel_left, add_comm, modify_nth_tail_modify_nth_tail]
simp
simp [list.update_nth]
simp [list.update_nth]
simp only [update_nth, true_and, eq_self_iff_true]
exact update_nth_comm t (Œª h', h $ nat.succ_inj'.mpr h')
dsimp [list.insert_nth]
erw [list.mem_cons_iff, mem_insert_nth (nat.le_of_succ_le_succ h), list.mem_cons_iff, ‚Üê or.assoc, or_comm (a = a'), or.assoc]
cases le_or_lt n l.length with hn hn
rw length_insert_nth _ _ hn
{ rw length_insert_nth _ _ hn, exact (nat.lt_succ_self _).le }
exact (nat.lt_succ_self _).le
rw insert_nth_of_length_lt _ _ _ hn
simp
simp
dsimp
rw [map_take]
induction L‚ÇÅ; [refl, simp only [*, join, cons_append, append_assoc]]
refl
simp only [*, join, cons_append, append_assoc]
induction L‚ÇÅ
contradiction
induction l with b l IH
{contradiction}
by_cases h : p b
cases H
apply mem_cons_self
rw find_cons_of_pos _ h at H
{ rw find_cons_of_pos _ h at H, cases H, apply mem_cons_self }
exact mem_cons_of_mem _ (IH H)
rw find_cons_of_neg _ h at H
simp only [filter_map, h]
induction l with a l IH
intro H
cases H
{ intro H, cases H }
rintro ‚ü®_, H, _‚ü©
cases H
split
{ split, { intro H, cases H }, { rintro ‚ü®_, H, _‚ü©, cases H } }
cases h : f a with b'
rw h
intro
contradiction
{rw h, intro, contradiction}
have : f a ‚â† some b
simp only [filter_map_cons_none _ _ h, IH, mem_cons_iff, or_and_distrib_right, exists_or_distrib, exists_eq_left, this, false_or]
{ have : f a ‚â† some b, {rw h, intro, contradiction}, simp only [filter_map_cons_none _ _ h, IH, mem_cons_iff, or_and_distrib_right, exists_or_distrib, exists_eq_left, this, false_or] }
have : f a = some b ‚Üî b = b'
split; intro t
intro t
intro t
rw t at h
rw t at h; injection h
injection h
{rw t at h; injection h}
exact t.symm ‚ñ∏ h
{ split; intro t, {rw t at h; injection h}, {exact t.symm ‚ñ∏ h} }
split
simp only [filter_map_cons_some _ _ _ h, IH, mem_cons_iff, or_and_distrib_right, exists_or_distrib, this, exists_eq_left]
rw [‚Üêmem_iff_nth, ‚Üêmem_iff_nth, reduce_option_mem_iff]
simp
simp
simp [tails_eq_inits l, append_left_inj]
induction ys generalizing f f'; simp *
simp *
simp *
induction ys generalizing f f'
simp [H]
apply ys_ih
induction ys with y ys ih generalizing l
{ simp {contextual := tt} }
simp {contextual := tt}
rw [permutations_aux2_snd_cons, show (Œª (x : list Œ±), l ++ y :: x) = append (l ++ [y]), by funext; simp, mem_cons_iff, ih]
funext
funext; simp
simp
split
split; intro h
intro h
intro h
rcases h with e | ‚ü®l‚ÇÅ, l‚ÇÇ, l0, ye, _‚ü©
exact ‚ü®[], y::ys, by simp‚ü©
simp
{ subst l', exact ‚ü®[], y::ys, by simp‚ü© }
subst l'
exact ‚ü®y::l‚ÇÅ, l‚ÇÇ, l0, by simp‚ü©
simp
{ rcases h with e | ‚ü®l‚ÇÅ, l‚ÇÇ, l0, ye, _‚ü©, { subst l', exact ‚ü®[], y::ys, by simp‚ü© }, { substs l' ys, exact ‚ü®y::l‚ÇÅ, l‚ÇÇ, l0, by simp‚ü© } }
substs l' ys
rcases h with ‚ü®_ | ‚ü®y', l‚ÇÅ‚ü©, l‚ÇÇ, l0, ye, rfl‚ü©
{ simp [ye] }
simp [ye]
rcases ye with ‚ü®rfl, rfl‚ü©
simp at ye
simp
exact or.inr ‚ü®l‚ÇÅ, l‚ÇÇ, l0, by simp‚ü©
simp only [insert.def, if_neg h]; split; refl
simp only [insert.def, if_neg h]; split
split
refl
refl
simp only [insert.def, if_neg h]
by_cases a ‚àà l; [simp only [insert_of_mem h], simp only [insert_of_not_mem h, suffix_cons]]
simp only [insert_of_mem h]
by_cases a ‚àà l
simp only [insert_of_not_mem h, suffix_cons]
induction l; [refl, simp only [*, diff_cons, erase_of_not_mem (not_mem_nil _)]]
refl
simp only [*, diff_cons, erase_of_not_mem (not_mem_nil _)]
induction l
cases bs; refl
refl
refl
cases bs
induction l; simp only [*, concat]; split; refl
induction l; simp only [*, concat]; split
induction l; simp only [*, concat]
simp only [*, concat]
simp only [*, concat]
split
split
induction l
simp
induction l; [refl, simp only [cons_append, last_cons _ (Œª H, cons_ne_nil _ _ (append_eq_nil.1 H).2), *]]
induction l
simp only [cons_append, last_cons _ (Œª H, cons_ne_nil _ _ (append_eq_nil.1 H).2), *]
refl
intro e; rw e at h; cases h
intro e; rw e at h
rw e at h
cases h
intro e
exact pairwise_singleton _ _
induction c with b b c l r p IH
{exact pairwise_singleton _ _}
simp only [mem_cons_iff, forall_eq_or_imp, r, true_and]
apply IH.cons _
from Œª x m, (tr r (rel_of_pairwise_cons IH m))
show ‚àÄ x ‚àà l, R b x
simp at *
tauto
simp only [cons_append, chain'_cons] at h‚ÇÅ h‚ÇÇ ‚ä¢
simp only [‚Üê cons_append] at h‚ÇÅ h‚ÇÇ ‚ä¢
exact ‚ü®h‚ÇÅ.1, chain'.append_overlap h‚ÇÅ.2 h‚ÇÇ (cons_ne_nil _ _)‚ü©
simpa using l.prop
induction s using quotient.induction_on'
simp
exact ‚ü®‚ü®s, hs‚ü©, by simp‚ü©
rw nat.succ_add; exact prod.lex.right _ (lt_succ_self _)
exact prod.lex.right _ (lt_succ_self _)
rw nat.succ_add
simpa [duplicate_cons_iff, hx.symm] using h
rwa [take_left] at h'
induction h; constructor; solve_by_elim
induction h; constructor
constructor
constructor
solve_by_elim
solve_by_elim
induction h
simp only [map, forall‚ÇÇ_nil_left_iff]
simp only [map, forall‚ÇÇ_cons_left_iff, forall‚ÇÇ_map_left_iff]
cases k; refl
refl
refl
cases k
rcases trichotomous_of r a b with ab | rfl | ab
{ exact or.inl (rel ab) }
exact or.inl (rel ab)
exact (_match l‚ÇÅ l‚ÇÇ).imp cons (or.imp (congr_arg _) cons)
{ exact (_match l‚ÇÅ l‚ÇÇ).imp cons (or.imp (congr_arg _) cons) }
exact or.inr (or.inr (rel ab))
simp [H]
simp
simp
simp [ihn]
rw [‚Üê append_assoc, pairwise_append, @pairwise_append _ _ ([a] ++ l‚ÇÅ), pairwise_append_comm s]
rw [‚Üê append_assoc, pairwise_append, @pairwise_append _ _ ([a] ++ l‚ÇÅ), pairwise_append_comm s]; simp only [mem_append, or_comm]
simp only [mem_append, or_comm]
by_cases (‚àÄ y ‚àà pw_filter R l, R x y)
rw [pw_filter_cons_of_pos h]
{ rw [pw_filter_cons_of_pos h], exact cons_sublist_cons _ (pw_filter_sublist l) }
exact cons_sublist_cons _ (pw_filter_sublist l)
rw [pw_filter_cons_of_neg h]
exact sublist_cons_of_sublist _ (pw_filter_sublist l)
induction hR with a l R1 R2 IH
clear_
induction hR with a l R1 R2 IH; simp only [pairwise.nil, pairwise_cons] at *
simp only [pairwise.nil, pairwise_cons] at *
simp only [pairwise.nil, pairwise_cons] at *
exact ‚ü®Œª b bl, ‚ü®R1 b bl, hS.1 b bl‚ü©, IH hS.2‚ü©
induction l with y l IH generalizing x
{ simp [take_while], }
simp [take_while]
rw [permutations'_aux, count_cons_self]
by_cases hx : x = y
subst hx
{ subst hx, simpa [take_while, nat.succ_inj'] using IH _ }
simpa [take_while, nat.succ_inj'] using IH _
rw take_while
rw if_neg hx
cases permutations'_aux x l with a as
{ simp }
simp
rw [count_eq_zero_of_not_mem, length, zero_add]
simp [hx, ne.symm hx]
rw sublists'_cons; exact (sublists_cons_perm_append _ _).trans (IH.append (IH.map _))
exact (sublists_cons_perm_append _ _).trans (IH.append (IH.map _))
rw sublists'_cons
exact Œª a b c, lt_trans
rw [rotate_eq_rotate', rotate_eq_rotate', rotate_eq_rotate', rotate'_rotate']
rw [rotate_eq_drop_append_take_mod, rotate_eq_drop_append_take_mod, rotate_eq_drop_append_take_mod, h, zip_with_append, ‚Üêzip_with_distrib_drop, ‚Üêzip_with_distrib_take, list.length_zip_with, h, min_self]
rw [length_drop, length_drop, h]
split
intro h
cases l.length.zero_le.eq_or_lt with hl' hl'
{ simp [‚Üêlength_eq_zero, ‚Üêhl'] }
simp [‚Üêlength_eq_zero, ‚Üêhl']
left
rw nodup_iff_nth_le_inj at hl
refine hl _ _ (mod_lt _ hl') hl' _
rw ‚Üênth_le_rotate' _ n
simp_rw [h, nat.sub_add_cancel (mod_lt _ hl').le, mod_self]
{ intro h, cases l.length.zero_le.eq_or_lt with hl' hl', { simp [‚Üêlength_eq_zero, ‚Üêhl'] }, left, rw nodup_iff_nth_le_inj at hl, refine hl _ _ (mod_lt _ hl') hl' _, rw ‚Üênth_le_rotate' _ n, simp_rw [h, nat.sub_add_cancel (mod_lt _ hl').le, mod_self] }
rintro (h|h)
rw [‚Üêrotate_mod, h]
{ rw [‚Üêrotate_mod, h], exact rotate_zero l }
exact rotate_zero l
simp [h]
obtain rfl | h := eq_or_ne l []
{ simp }
simp
rw length_cyclic_permutations_of_ne_nil _ h at hn
simp [init_eq_take, cyclic_permutations_of_ne_nil _ h, nth_le_take', rotate_eq_drop_append_take hn.le]
rw rotate'_eq_drop_append_take (le_refl _); simp
simp
rw rotate'_eq_drop_append_take (le_refl _)
rintro ‚ü®a‚ÇÅ, b‚ÇÇ‚ü© ‚ü®a‚ÇÇ, b‚ÇÇ‚ü©
rintro ‚ü®a‚ÇÅ, b‚ÇÇ‚ü© ‚ü®a‚ÇÇ, b‚ÇÇ‚ü©; dsimp; split_ifs; simp [h] {contextual := tt}
rintro ‚ü®a‚ÇÅ, b‚ÇÇ‚ü© ‚ü®a‚ÇÇ, b‚ÇÇ‚ü©; dsimp; split_ifs
rintro ‚ü®a‚ÇÅ, b‚ÇÇ‚ü© ‚ü®a‚ÇÇ, b‚ÇÇ‚ü©; dsimp
split_ifs
simp [h] {contextual := tt}
simp [h] {contextual := tt}
dsimp
rw [keys, kerase, ‚Üêerasep_map sigma.fst l, erase_eq_erasep]
induction p generalizing l
refl
case list.perm.nil { refl }
case list.perm.cons : hd tl‚ÇÅ tl‚ÇÇ p ih { simp [ih (kerase hd.1 l), perm.cons] }
simp [ih (kerase hd.1 l), perm.cons]
case list.perm.swap : s‚ÇÅ s‚ÇÇ l { simp [kerase_comm, perm.swap] }
simp [kerase_comm, perm.swap]
case list.perm.trans : l‚ÇÅ l‚ÇÇ l‚ÇÉ p‚ÇÅ‚ÇÇ p‚ÇÇ‚ÇÉ ih‚ÇÅ‚ÇÇ ih‚ÇÇ‚ÇÉ { exact perm.trans (ih‚ÇÅ‚ÇÇ l) (ih‚ÇÇ‚ÇÉ l) }
exact perm.trans (ih‚ÇÅ‚ÇÇ l) (ih‚ÇÇ‚ÇÉ l)
simpa [insertion_sort] using (perm_ordered_insert _ _ _).trans ((perm_insertion_sort l).cons b)
split
split; simp only [mem_cons_iff, or_true, mem_zip h]
simp only [mem_cons_iff, or_true, mem_zip h]
simp only [mem_cons_iff, or_true, mem_zip h]
cases l; cases l'; simp
cases l; cases l'
cases l'
cases l'
simp
simp
simp
simp
cases l
rw [‚Üê zip_map, map_id]
ext i j
ext i j; simp
simp
simp only [diagonal, map_apply]
split_ifs
split_ifs; simp [h]
simp [h]
simp [h]
ext
apply dot_product_assoc
ext
simp only [coe_scalar, smul_eq_mul, mul_one, one_apply_eq, pi.smul_apply]
simp [commute, semiconj_by]
ext
simp
unfold std_basis_matrix
simp
ext
ext
exact is_empty_elim i
simp [mul_vec, mul_comm]
ext i
refine fin.cases _ _ i
refine fin.cases _ _ i; simp [vec_head, vec_tail]
simp [vec_head, vec_tail]
simp [vec_head, vec_tail]
ext i
apply quotient.induction_on m
simp only [quot_mk_to_coe, coe_prod, mem_coe]
intros l hl‚ÇÅ hl‚ÇÇ x hx
apply all_one_of_le_one_le_of_prod_eq_one hl‚ÇÅ hl‚ÇÇ _ hx
simp [multiset.sigma, (‚àò)]
simp [function.funext_iff]
simp [countp_eq_card_filter, h, filter_le_filter]
simp [(‚à™), union, sub_add_eq_max, -add_comm]
split
induction h
induction h; simp *
simp *
simp *
{ assume h, induction h; simp * }
assume h
subst h
exact rel_eq_refl
assume h
rw [disjoint_comm, disjoint_cons_left]; tauto
tauto
rw [disjoint_comm, disjoint_cons_left]
simpa using add_le_add_left (zero_le t) s
simp [e]
classical
rw [‚Üê h.le_erase_dup_iff_le, iff.comm, ‚Üê h.le_erase_dup_iff_le]
simp [hn]
simp [ndinter, le_filter, subset_iff]
simp only [antidiagonal, list.nat.antidiagonal_succ, coe_map, cons_coe]
simp; refine list.nodup_map_on _ (nodup_sublists'.2 h); exact Œª x sx y sy e, (h.sublist_ext (mem_sublists'.1 sx) (mem_sublists'.1 sy)).1 (quotient.exact e)
simp; refine list.nodup_map_on _ (nodup_sublists'.2 h)
refine list.nodup_map_on _ (nodup_sublists'.2 h)
exact Œª x sx y sy e, (h.sublist_ext (mem_sublists'.1 sx) (mem_sublists'.1 sy)).1 (quotient.exact e)
simp
simp [powerset_len_aux_eq_map_coe, subperm]; exact Œª l‚ÇÅ, ‚ü®Œª ‚ü®l‚ÇÇ, ‚ü®s, e‚ü©, p‚ü©, ‚ü®‚ü®_, p, s‚ü©, p.symm.length_eq.trans e‚ü©, Œª ‚ü®‚ü®l‚ÇÇ, p, s‚ü©, e‚ü©, ‚ü®_, ‚ü®s, p.length_eq.trans e‚ü©, p‚ü©‚ü©
exact Œª l‚ÇÅ, ‚ü®Œª ‚ü®l‚ÇÇ, ‚ü®s, e‚ü©, p‚ü©, ‚ü®‚ü®_, p, s‚ü©, p.symm.length_eq.trans e‚ü©, Œª ‚ü®‚ü®l‚ÇÇ, p, s‚ü©, e‚ü©, ‚ü®_, ‚ü®s, p.length_eq.trans e‚ü©, p‚ü©‚ü©
simp [powerset_len_aux_eq_map_coe, subperm]
simp [powerset_len_aux_eq_map_coe]
simp
simp [ih, rel_cons_left, -exists_and_distrib_left, exists_and_distrib_left.symm, eq_comm]
simp [support, finsupp.sum, coeff]
congr
simp only [map_C, comp_app, ring_hom.coe_comp]
ext1 a
{ ext1 a, simp only [map_C, comp_app, ring_hom.coe_comp], }
simp only [map_X, comp_app]
ext1 n
simp
simp
ext
ext; simp
rw [œÜ.as_sum, ring_hom.map_sum, finset.sum_eq_zero]
intros d hd
obtain ‚ü®i, hi, hgi‚ü© : ‚àÉ i ‚àà d.support, g i = 0 := h d (finsupp.mem_support_iff.mp hd)
rw [eval‚ÇÇ_hom_monomial, finsupp.prod, finset.prod_eq_zero hi, mul_zero]
rw [hgi, zero_pow]
rwa [pos_iff_ne_zero, ‚Üê finsupp.mem_support_iff]
rw [degrees, support_neg]; refl
refl
rw [degrees, support_neg]
induction n with n ih
{ simp, }
simp
simp [ih]
simpa
simp only [monomial_zero, pderiv_monomial, nat.cast_zero, mul_zero, zero_apply]
simp only [map_C, rename_C]
simp only [hp, hq, alg_hom.map_add, ring_hom.map_add]
simp only [hp, rename_X, map_X, ring_hom.map_mul, alg_hom.map_mul]
simp only [rename, aeval_eq_eval‚ÇÇ_hom]
simp [eval‚ÇÇ_comp_left _ C (X ‚àò f) p, (‚àò), eval‚ÇÇ_C, eval_X]
apply eval‚ÇÇ_hom_congr _ rfl rfl
ext1
simp only [comp_app, ring_hom.coe_comp, eval‚ÇÇ_hom_C]
rw [total_degree_eq]
exact finset.sup_le (assume s hs, multiset.card_le_of_le $ finset.le_sup hs)
cc
rw [bit1, nat.dvd_add_right two_dvd_bit0, nat.dvd_one]
rintros ‚ü®c, rfl‚ü©
rcases nat.eq_zero_or_pos c with (rfl | hc)
{ exact lt_irrefl 0 h1 }
exact lt_irrefl 0 h1
exact not_lt.2 (le_mul_of_pos_right hc) h2
unfold bodd div2; cases bodd_div2 n; refl
unfold bodd div2; cases bodd_div2 n
cases bodd_div2 n
refl
unfold bodd div2
simp
simp only [lt_succ_iff_lt_or_eq, or_and_distrib_right, exists_or_distrib, exists_eq_left]
cases le_or_lt a c with h' h'; [left, right]
left
cases le_or_lt a c with h' h'
right
{ exact h', }
exact h'
rw h at h'
replace h' := add_lt_add_right h' d
rw hb
exact zero_le d
cases b.eq_zero_or_pos with hb hb
{ rw hb, exact zero_le d, }
rw [a.add_sub_assoc hb, add_lt_add_iff_left] at h'
exact nat.le_of_pred_lt h'
apply_instance
simp [hc0]
rw [mul_assoc]; exact nat.mul_le_mul_left _ (nat.div_mul_le_self _ _)
exact nat.mul_le_mul_left _ (nat.div_mul_le_self _ _)
rw [mul_assoc]
simp [land]
rw [eq_div_iff_mul_eq (nat.cast_ne_zero.2 b.factorial_ne_zero : (b! : K) ‚â† 0), ‚Üênat.cast_mul, mul_comm, ‚Üênat.desc_factorial_eq_factorial_mul_choose, ‚Üêcast_desc_factorial]
induction L with d L ih
{ refl, }
refl
simp [of_digits, list.sum_cons, ih]
rw ‚Üêof_digits_one
congr
skip
rw ‚Üê(of_digits_digits b' n)
conv { congr, skip, rw ‚Üê(of_digits_digits b' n) }
convert of_digits_modeq _ _ _
exact h.symm
norm_num
exact succ_pos n
rw [digits, digits_aux_def]
rw [mul_comm k n, mul_comm k m, dist_mul_right, mul_comm]
exact enat.cases_on'
simp only [‚Üê some_eq_coe]
rw [‚Üê coe_inj, coe_get]
simp only [iff_true, le_top, coe_lt_top, ‚Üê @nat.cast_zero enat]
rw [‚Üê nat.cast_zero, ‚Üê nat.cast_one, enat.coe_lt_coe, enat.coe_le_coe]
refl
exact le_of_lt_add_one
split
rcases ne_top_iff.mp hx with ‚ü®m, rfl‚ü©
intro h
induction y using enat.cases_on with n
rw [top_add]
apply coe_lt_top
{ rw [top_add], apply coe_lt_top }
apply_mod_cast h
apply_mod_cast nat.lt_succ_of_le
change (stream.nth (n + 1) $ stream.iterate fib_aux_step ‚ü®0, 1‚ü©) = fib_aux_step (stream.nth n $ stream.iterate fib_aux_step ‚ü®0, 1‚ü©)
rw [stream.nth_succ_iterate, stream.map_iterate, stream.nth_map]
rw [clog, if_neg (Œª h : 1 < b ‚àß 1 < n, h.1.not_le hb)]
norm_num
simpa [modeq, show 2 * 2 = 4, by norm_num] using @modeq.of_modeq_mul_left 2 n 1 2
rwa [nat.succ_eq_add_one, ‚Üêl.rotate_rotate, hn]
simp
rw [mem_filter, Ico.mem, Ico.mem, lt_succ_iff, ‚Üê@enat.coe_le_coe i, enat.coe_get, ‚Üêpow_dvd_iff_le_multiplicity, and.right_comm]
refine (and_iff_left_of_imp (Œª h, _)).symm
cases m
rw [zero_pow, zero_dvd_iff] at h
exact (hn.ne' h.2).elim
exact h.1
{ rw [zero_pow, zero_dvd_iff] at h, exact (hn.ne' h.2).elim, { exact h.1 } }
exact ((pow_le_iff_le_log (succ_lt_succ $ nat.pos_of_ne_zero $ succ_ne_succ.1 hm) hn).1 $ le_of_dvd hn h.2).trans_lt hb
simp [*, (dec_trivial : ¬¨ 2 = 0)] with parity_simps
rw [bit0_val, shiftl_eq_mul_pow, mul_left_comm, mul_comm 2]
simpa using (dvd_prime_two_le h a1).1 (dvd_mul_right _ _)
rintro rfl; cases not_le_of_lt pp (le_of_dvd dec_trivial d)
cases not_le_of_lt pp (le_of_dvd dec_trivial d)
rintro rfl
symmetry
rw ‚Üê list.repeat_perm
apply nat.factors_unique (list.prod_repeat p n)
intros q hq
rwa eq_of_mem_repeat hq
simpa only [pow_two] using eq_sqrt
dsimp [(‚â§)]
dsimp [(‚â§)]; apply_instance
apply_instance
simp
cases n
cases n; refl <|> simp [znum.div]
refl
refl
refl
simp [int.div_zero]
rw ‚Üê num.to_nat_to_int; simp
simp
rw ‚Üê num.to_nat_to_int
rw ‚Üê num.to_nat_to_int; simp
simp
rw ‚Üê num.to_nat_to_int
rw [n.to_int_eq_succ_pred, d.to_int_eq_succ_pred, ‚Üê pos_num.to_nat_to_int, num.succ'_to_nat, num.div_to_nat]
change -[1+ n.pred' / ‚Üëd] = -[1+ n.pred' / (d.pred' + 1)]
rw d.to_nat_eq_succ_pred
rw [n.to_int_eq_succ_pred, d.to_int_eq_succ_pred, ‚Üê pos_num.to_nat_to_int, num.succ'_to_nat, num.div_to_nat]
change (nat.succ (_/d) : ‚Ñ§) = nat.succ (n.pred'/(d.pred' + 1))
rw d.to_nat_eq_succ_pred
have := pos_num.cmp_to_nat a b; revert this; dsimp [cmp]; cases pos_num.cmp a b
have := pos_num.cmp_to_nat a b; revert this; dsimp [cmp]
have := pos_num.cmp_to_nat a b; revert this
revert this
dsimp [cmp]
have := pos_num.cmp_to_nat a b
exacts [id, congr_arg pos, id]
cases pos_num.cmp a b
refine_struct { add := (+), zero := 0, zero_add := zero_add, add_zero := add_zero, mul := (*), one := 1, nsmul := @nsmul_rec _ ‚ü®0‚ü© ‚ü®(+)‚ü©, npow := @npow_rec _ ‚ü®1‚ü© ‚ü®(*)‚ü© }
refine_struct { add := (+), zero := 0, zero_add := zero_add, add_zero := add_zero, mul := (*), one := 1, nsmul := @nsmul_rec _ ‚ü®0‚ü© ‚ü®(+)‚ü©, npow := @npow_rec _ ‚ü®1‚ü© ‚ü®(*)‚ü© }; try { intros, refl }; try { transfer }; simp [mul_add, mul_left_comm, mul_comm, add_comm]
refine_struct { add := (+), zero := 0, zero_add := zero_add, add_zero := add_zero, mul := (*), one := 1, nsmul := @nsmul_rec _ ‚ü®0‚ü© ‚ü®(+)‚ü©, npow := @npow_rec _ ‚ü®1‚ü© ‚ü®(*)‚ü© }; try { intros, refl }; try { transfer }
refine_struct { add := (+), zero := 0, zero_add := zero_add, add_zero := add_zero, mul := (*), one := 1, nsmul := @nsmul_rec _ ‚ü®0‚ü© ‚ü®(+)‚ü©, npow := @npow_rec _ ‚ü®1‚ü© ‚ü®(*)‚ü© }; try { intros, refl }
refl
try { intros, refl }
try { intros, refl }
try { intros, refl }
try { intros, refl }
try { intros, refl }
try { intros, refl }
try { intros, refl }
try { intros, refl }
try { intros, refl }
try { intros, refl }
try { intros, refl }
try { intros, refl }
try { intros, refl }
try { intros, refl }
try { transfer }
try { transfer }
try { transfer }
try { transfer }
try { transfer }
try { transfer }
try { transfer }
try { transfer }
try { transfer }
try { transfer }
transfer
simp [mul_add, mul_left_comm, mul_comm, add_comm]
simp [mul_add, mul_left_comm, mul_comm, add_comm]
simp [mul_add, mul_left_comm, mul_comm, add_comm]
simp [mul_add, mul_left_comm, mul_comm, add_comm]
simp [mul_add, mul_left_comm, mul_comm, add_comm]
intros
cases n
cases n; refl
refl
refl
refl
cases n
cases n; refl
refl
refl
cases n; try {refl}; rw [succ, num.zneg_to_znum_neg]; refl
cases n; try {refl}; rw [succ, num.zneg_to_znum_neg]
cases n; try {refl}
try {refl}
try {refl}
try {refl}
refl
rw [succ, num.zneg_to_znum_neg]
cases n
refl
simp [znum.bit1, _root_.bit1, _root_.bit0]
rw [znum.bit1, cast_pos, cast_pos]
rw [znum.bit1, cast_pos, cast_pos]; refl
refl
rw [znum.bit1, cast_neg, cast_neg]
cases e : pred' p with a; have : p = _ := (succ'_pred' p).symm.trans (congr_arg num.succ' e)
cases e : pred' p with a
have : p = _ := (succ'_pred' p).symm.trans (congr_arg num.succ' e)
have : p = _ := (succ'_pred' p).symm.trans (congr_arg num.succ' e)
subst p
change p=1 at this
{ change p=1 at this, subst p, simp [_root_.bit1, _root_.bit0] }
simp [_root_.bit1, _root_.bit0]
subst p
rw [num.succ'] at this
simp [add_comm]
{simp [add_comm]}
have : (‚Üë(-‚Üëa:‚Ñ§) : Œ±) = -1 + ‚Üë(-‚Üëa + 1 : ‚Ñ§)
simpa [_root_.bit1, _root_.bit0, -add_comm]
rw [‚Üê of_nat_to_znum, zneg_to_znum]
rw [‚Üê add_one, cast_add, cast_one]
intro h; rw [nat.add_right_comm m m 1, add_assoc]; exact add_le_add h h
intro h; rw [nat.add_right_comm m m 1, add_assoc]
rw [nat.add_right_comm m m 1, add_assoc]
intro h
exact add_le_add h h
cases x
cases x; refl
refl
refl
cases x; simp
simp
simp
cases x
cases x; simp [is_some]; exact ‚ü®_, rfl‚ü©
cases x; simp [is_some]
simp [is_some]
simp [is_some]
cases x
rw [dual, dual, dual_dual, dual_dual]
simp [node3_l, node3_r, dual_node']
rw [balance_r_eq_balance' hl hr sl sr H, all_balance']
simp [size_dual, add_comm]
rw [size_dual, size_dual]; exact b.symm
exact b.symm
rw [size_dual, size_dual]
assume a
cases h : g a with b
exact eq_none_iff_forall_not_mem.2 (Œª b hb, option.not_mem_none b $ h ‚ñ∏ fg a b hb)
{ exact eq_none_iff_forall_not_mem.2 (Œª b hb, option.not_mem_none b $ h ‚ñ∏ fg a b hb) }
exact gf _ _ h
simp [restrict]
simp [dom, part.dom_iff_mem]
rw [corec_def,dest_mk]
refl
induction d with d ih
rw [succ_nsmul, prod_add, ih, nat.succ_eq_add_one, pow_succ, mul_comm]
apply le_antisymm
apply le_inf_iff.mpr; split; apply factor_multiset_le_iff.mpr
apply le_inf_iff.mpr; split
split
apply factor_multiset_le_iff.mpr
apply factor_multiset_le_iff.mpr
apply le_inf_iff.mpr
exact gcd_dvd_right m n
{ apply le_inf_iff.mpr; split; apply factor_multiset_le_iff.mpr, exact gcd_dvd_left m n, exact gcd_dvd_right m n}
exact gcd_dvd_left m n
rw[‚Üê prime_multiset.prod_dvd_iff, prod_factor_multiset]
apply dvd_gcd; rw[prime_multiset.prod_dvd_iff']
rw[prime_multiset.prod_dvd_iff']
rw[prime_multiset.prod_dvd_iff']
apply dvd_gcd
exact inf_le_right
exact inf_le_left
replace h := congr_arg subtype.val h
exact h
apply coprime.gcd_mul_left_cancel
rw mul_comm
rcases p
simp [add_to_finsupp, monomial, monomial_fun, coeff, erase]
exact finsupp.single_add_erase _ _
simp [coeff, neg_to_finsupp]
rcases p
unfold nat_degree; rw h
rw h
unfold nat_degree
simpa [monic] using hp
rintro rfl
rw [nat_degree, hn]; refl
refl
rw [nat_degree, hn]
nth_rewrite 0 [‚Üê one_mul p]
rw [‚Üê C_1, ‚Üê au, ring_hom.map_mul, ‚Üê mul_assoc]
simp only [‚ÜêC_eq_nat_cast, nat_trailing_degree_C]
rw [ring_hom.map_add, polynomial.map_add, eval_add, mul_add, Hf, Hg]
congr
refine @inv_unique K _ (i b) bg bf _ _; rwa mul_comm
refine @inv_unique K _ (i b) bg bf _ _
rwa mul_comm
rwa mul_comm
rw [map_C, derivative_C, derivative_C, map_zero]
rw [map_add, derivative_add, ihp, ihq, derivative_add, map_add]
rw [map_mul, map_C, map_pow, map_X, derivative_mul, derivative_pow_succ, derivative_C, zero_mul, zero_add, derivative_X, mul_one, derivative_mul, derivative_pow_succ, derivative_C, zero_mul, zero_add, derivative_X, mul_one, map_mul, map_C, map_mul, map_pow, map_add, map_nat_cast, map_one, map_X]
rw [H, derivative_zero]
by_cases h01 : (0 : R) = 1
haveI := subsingleton_of_zero_eq_one h01
rw [subsingleton.elim (f /‚Çò g) 0, subsingleton.elim f 0, subsingleton.elim g 0, nat_degree_zero]
{ haveI := subsingleton_of_zero_eq_one h01, rw [subsingleton.elim (f /‚Çò g) 0, subsingleton.elim f 0, subsingleton.elim g 0, nat_degree_zero] }
haveI : nontrivial R := ‚ü®‚ü®0, 1, h01‚ü©‚ü©
by_cases hfg : f /‚Çò g = 0
rw div_by_monic_eq_zero_iff hg hg.ne_zero at hfg
rw [hfg, nat_degree_zero]
rw nat.sub_eq_zero_of_le (nat_degree_le_nat_degree $ le_of_lt hfg)
{ rw [hfg, nat_degree_zero], rw div_by_monic_eq_zero_iff hg hg.ne_zero at hfg, rw nat.sub_eq_zero_of_le (nat_degree_le_nat_degree $ le_of_lt hfg) }
rw div_by_monic_eq_zero_iff hg hg.ne_zero at hgf
have hgf := hfg
push_neg at hgf
have := degree_add_div_by_monic hg hgf
intro hf
apply hfg
have hf : f ‚â† 0
rw [hf, zero_div_by_monic]
{ intro hf, apply hfg, rw [hf, zero_div_by_monic] }
rw [degree_eq_nat_degree hf, degree_eq_nat_degree hg.ne_zero, degree_eq_nat_degree hfg, ‚Üê with_bot.coe_add, with_bot.coe_eq_coe] at this
rw [‚Üê this, nat.add_sub_cancel_left]
rw [‚Üê dvd_iff_mod_by_monic_eq_zero hx, ‚Üê dvd_iff_mod_by_monic_eq_zero (monic_map f hx), ‚Üê map_mod_by_monic f hx]
rw [H, map_zero]
exact ‚ü®Œª H, map_injective f hf $ by rw [H, map_zero], Œª H, by rw [H, map_zero]‚ü©
rw [H, map_zero]
apply polynomial.induction_on' p
intros p q ph qh
{ intros p q ph qh, simp only [add_mul, eval_add, ph, qh], }
simp only [add_mul, eval_add, ph, qh]
intros n a
simp only [‚Üêmonomial_one_one_eq_X, monomial_mul_monomial, eval_monomial, mul_one, pow_succ', mul_assoc]
unfold leading_coeff
rw [coeff_map, nat_degree_map_of_leading_coeff_ne_zero f hf]
rw [sub_eq_add_neg, eval‚ÇÇ_add, eval‚ÇÇ_neg, sub_eq_add_neg]
ext x
rw [set.mem_singleton_iff, mem_root_set, aeval_mul, aeval_C, aeval_X_pow, mul_eq_zero]
simp_rw [ring_hom.map_eq_zero, pow_eq_zero_iff (nat.pos_of_ne_zero hn), or_iff_right_iff_imp]
{ simp_rw [ring_hom.map_eq_zero, pow_eq_zero_iff (nat.pos_of_ne_zero hn), or_iff_right_iff_imp], exact Œª ha', (ha ha').elim }
exact Œª ha', (ha ha').elim
exact mul_ne_zero (mt C_eq_zero.mp ha) (pow_ne_zero n X_ne_zero)
rw [eq_C_of_degree_eq_zero (degree_coe_units u), eq_C_of_degree_eq_zero (degree_coe_units u‚Åª¬π), coeff_C, coeff_C, inv_eq_one_div]
split_ifs
rw [div_eq_iff_mul_eq (coeff_coe_units_zero_ne_zero u), coeff_zero_eq_eval_zero, coeff_zero_eq_eval_zero, ‚Üê eval_mul, ‚Üê units.coe_mul, inv_mul_self]
rw [div_eq_iff_mul_eq (coeff_coe_units_zero_ne_zero u), coeff_zero_eq_eval_zero, coeff_zero_eq_eval_zero, ‚Üê eval_mul, ‚Üê units.coe_mul, inv_mul_self]; simp
{ rw [div_eq_iff_mul_eq (coeff_coe_units_zero_ne_zero u), coeff_zero_eq_eval_zero, coeff_zero_eq_eval_zero, ‚Üê eval_mul, ‚Üê units.coe_mul, inv_mul_self]; simp }
simp
simp
simp only [hasse_deriv_apply, derivative_apply, monomial_eq_C_mul_X, nat.choose_one_right, (nat.cast_commute _ _).eq]
simp [integral_normalization, coeff_monomial, this, mem_support_iff] {contextual := tt}
by_cases Rtrivial : nontrivial R
swap
rw not_nontrivial_iff_subsingleton at Rtrivial
obtain ‚ü®q, hq‚ü© := mem_lifts_and_degree_eq hlifts
use q
exact ‚ü®hq.1, hq.2, @monic_of_subsingleton _ _ Rtrivial q‚ü©
{ rw not_nontrivial_iff_subsingleton at Rtrivial, obtain ‚ü®q, hq‚ü© := mem_lifts_and_degree_eq hlifts, use q, exact ‚ü®hq.1, hq.2, @monic_of_subsingleton _ _ Rtrivial q‚ü© }
by_cases er_zero : p.erase_lead = 0
rw [‚Üê erase_lead_add_C_mul_X_pow p, er_zero, zero_add, monic.def.1 hmonic, C_1, one_mul]
use X ^ p.nat_degree
split
split
split
repeat {split}
{ simp only [map_pow, map_X] }
simp only [map_pow, map_X]
{ rw [@degree_X_pow R _ Rtrivial, degree_X_pow] }
rw [@degree_X_pow R _ Rtrivial, degree_X_pow]
{ rw [‚Üê erase_lead_add_C_mul_X_pow p, er_zero, zero_add, monic.def.1 hmonic, C_1, one_mul], use X ^ p.nat_degree, repeat {split}, { simp only [map_pow, map_X] }, { rw [@degree_X_pow R _ Rtrivial, degree_X_pow] }, {exact monic_pow monic_X p.nat_degree } }
exact monic_pow monic_X p.nat_degree
obtain ‚ü®q, hq‚ü© := mem_lifts_and_degree_eq (erase_mem_lifts p.nat_degree hlifts)
have deg_er : p.erase_lead.nat_degree < p.nat_degree := or.resolve_right (erase_lead_nat_degree_lt_or_erase_lead_eq_zero p) er_zero
replace deg_er := with_bot.coe_lt_coe.2 deg_er
rw [‚Üê degree_eq_nat_degree er_zero, erase_lead, ‚Üê hq.2, ‚Üê @degree_X_pow R _ Rtrivial p.nat_degree] at deg_er
use q + X ^ p.nat_degree
split
split
split
repeat {split}
simp only [hq, map_add, map_pow, map_X]
nth_rewrite 3 [‚Üê erase_lead_add_C_mul_X_pow p]
rw [erase_lead, monic.leading_coeff hmonic, C_1, one_mul]
{ simp only [hq, map_add, map_pow, map_X], nth_rewrite 3 [‚Üê erase_lead_add_C_mul_X_pow p], rw [erase_lead, monic.leading_coeff hmonic, C_1, one_mul] }
rw [degree_add_eq_right_of_degree_lt deg_er, @degree_X_pow R _ Rtrivial p.nat_degree, degree_eq_nat_degree (monic.ne_zero hmonic)]
{ rw [degree_add_eq_right_of_degree_lt deg_er, @degree_X_pow R _ Rtrivial p.nat_degree, degree_eq_nat_degree (monic.ne_zero hmonic)] }
rw [monic.def, leading_coeff_add_of_degree_lt deg_er]
exact monic_pow monic_X p.nat_degree
simp only [coe_map_ring_hom, lifts, set.mem_range, ring_hom.mem_srange]
rw [p.as_sum_range_C_mul_X_pow, sum_range_succ_comm]
conv_lhs { rw [p.as_sum_range_C_mul_X_pow, sum_range_succ_comm] }
suffices : C (p.coeff p.nat_degree) = 1
{ rw [this, one_mul] }
rw [this, one_mul]
exact congr_arg C hp
ext
rw [reflect_C_mul, coeff_C_mul, coeff_C_mul, coeff_X_pow, coeff_reflect]
split_ifs with h j
{ rw [h, rev_at_invol, coeff_X_pow_self], }
rw [h, rev_at_invol, coeff_X_pow_self]
rw [not_mem_support_iff.mp]
intro a
rw [‚Üê one_mul (X ^ n), ‚Üê C_1] at a
apply h
rw [‚Üê (mem_support_C_mul_X_pow a), rev_at_invol]
simpa [hm.leading_coeff] using eq_X_add_C_of_degree_eq_one hp1
apply quot.ind
intro x
intros a f' f ih
apply q.P.W_ind _ x
change p ‚ü¶q.P.W_mk a f' f‚üß
rw [‚Üêfix.ind_aux a f' f]
apply h
rw mvqpf.liftp_iff
refine ‚ü®_, _, rfl, _‚ü©
intros i j
cases i
{ apply ih }
apply ih
triv
cases y with b g
cases x with a f
induction h
intro h
case qpf.Wequiv.ind : a f f' h ih { exact Wequiv.ind _ _ _ ih }
exact Wequiv.ind _ _ _ ih
case qpf.Wequiv.abs : a f a' f' h { exact Wequiv.abs _ _ _ _ h.symm }
exact Wequiv.abs _ _ _ _ h.symm
case qpf.Wequiv.trans : x y z e‚ÇÅ e‚ÇÇ ih‚ÇÅ ih‚ÇÇ { exact qpf.Wequiv.trans _ _ _ ih‚ÇÇ ih‚ÇÅ}
exact qpf.Wequiv.trans _ _ _ ih‚ÇÇ ih‚ÇÅ
by_cases a ‚â§ b; simp [h, min_def]
simp [h, min_def]
simp [h, min_def]
by_cases a ‚â§ b
apply_instance
simpa using lt_iff_le_not_le
intro a
intro a; rw mk_le
rw mk_le
simpa using le_trans
simpa [mk_eq] using @cau_seq.le_antisymm _ _ a b
apply_instance
apply tsum_le_tsum _ (summable_cantor_function f h1 h2) (summable_cantor_function g h1 h2)
cases h : f n
simp [h, cantor_function_aux_nonneg h1]
intro n
simp [h, h3]
replace h3 : g n = tt := h3 n h
rwa const_lim_zero
simp[inv_apply, const_apply]
cases h j ij with h‚ÇÅ h‚ÇÇ
have := add_le_add h‚ÇÅ (le_of_lt (abs_lt.1 h‚ÇÇ).1)
rwa [‚Üê sub_eq_add_neg, sub_self_div_two] at this
rwa neg_sub at h
rw [mul_comm, mul_div_cancel h0 hI]
lift a to ‚Ñù‚â•0 using ha
lift b to ‚Ñù‚â•0 using hb
refl
exact_mod_cast (@one_lt_two ‚Ñï _ _)
apply_instance
apply_instance
rw ‚Üêsmul_one_smul ‚Ñù‚â•0 r (s: ‚Ñù‚â•0‚àû)
change ‚Üë(r ‚Ä¢ s) = ‚Üë(r ‚Ä¢ (1 : ‚Ñù‚â•0)) * ‚Üës
rw [‚Üêennreal.coe_mul, smul_mul_assoc, one_mul]
simpa only [lt_top_iff_ne_top] using add_lt_top
simp
simp
simp [(coe_nnreal_lt_top y).ne']
simp [coe_nnreal_eq_coe_real]
simp [real.to_ereal]
unfold_coes
apply add_pos
apply add_pos; norm_num
norm_num
norm_num
split_ifs
unfold st
{ exact classical.some_spec h }
exact classical.some_spec h
unfold st
unfold st; split_ifs; refl
unfold st; split_ifs
split_ifs
refl
exact false.elim (hx (by unfold st; split_ifs; refl))
rwa lt_def
rw mul_comm
rw mul_comm; exact infinite_neg_mul_of_infinite_neg_not_infinitesimal_pos hy hx hp
exact infinite_neg_mul_of_infinite_neg_not_infinitesimal_pos hy hx hp
simp only [not_lt, (set.set_of_eq_eq_singleton).symm]
simp only [not_lt, (set.set_of_eq_eq_singleton).symm]; ext; exact nat.le_zero_iff
simp only [not_lt, (set.set_of_eq_eq_singleton).symm]; ext
ext
exact nat.le_zero_iff
simp only [inv_pos, nat.cast_pos]
exact mem_hyperfilter_of_finite_compl (by convert set.finite_singleton _)
convert set.finite_singleton _
simpa only [sub_eq_add_neg] using h.neg.rat_add q
apply_instance
apply_instance
simp [nnreal.coe_lt_coe.symm, real.to_nnreal, lt_irrefl]
rw [div_eq_inv_mul, ‚Üê mul_le_iff_le_inv hr, mul_comm]
refine lt_of_le_of_ne (sign_mul_nonneg r) (Œª h, hr _)
have hs0 := (zero_eq_mul.mp h).resolve_right hr
exact sign_eq_zero_iff.mp hs0
simp [sqrt]
ext x y
reflexivity
ext x w
split
unfold comp
exact ‚ü®y, rxy, z, syz, tzw‚ü©
rintros ‚ü®z, ‚ü®y, rxy, syz‚ü©, tzw‚ü©
{ rintros ‚ü®z, ‚ü®y, rxy, syz‚ü©, tzw‚ü©, exact ‚ü®y, rxy, z, syz, tzw‚ü© }
exact ‚ü®z, ‚ü®y, rxy, syz‚ü©, tzw‚ü©
rintros ‚ü®y, rxy, z, syz, tzw‚ü©
unfold get; rw lift_on_of_mem q _ _ a h; exact h
unfold get; rw lift_on_of_mem q _ _ a h
rw lift_on_of_mem q _ _ a h
exact h
unfold get
funext n
apply subtype.eq
refl
{refl}
induction h : s.val n
exact ‚ü®‚ü®_, _, h.symm‚ü©‚ü©
refine absurd _ H
have aa := parallel_promises h1 h
have aa := parallel_promises h1 h; rw ‚Üêaa; rw ‚Üêaa at h; exact let ‚ü®s, sS, as‚ü© := exists_of_mem_parallel h, ‚ü®t, tT, st‚ü© := wseq.exists_of_lift_rel_left H sS, aT := (st _).1 as in mem_parallel h2 tT aT
have aa := parallel_promises h1 h; rw ‚Üêaa; rw ‚Üêaa at h
have aa := parallel_promises h1 h; rw ‚Üêaa
rw ‚Üêaa
rw ‚Üêaa at h
exact let ‚ü®s, sS, as‚ü© := exists_of_mem_parallel h, ‚ü®t, tT, st‚ü© := wseq.exists_of_lift_rel_left H sS, aT := (st _).1 as in mem_parallel h2 tT aT
have aa := parallel_promises h2 h; rw ‚Üêaa; rw ‚Üêaa at h; exact let ‚ü®s, sS, as‚ü© := exists_of_mem_parallel h, ‚ü®t, tT, st‚ü© := wseq.exists_of_lift_rel_right H sS, aT := (st _).2 as in mem_parallel h1 tT aT
have aa := parallel_promises h2 h; rw ‚Üêaa; rw ‚Üêaa at h
have aa := parallel_promises h2 h; rw ‚Üêaa
rw ‚Üêaa
rw ‚Üêaa at h
exact let ‚ü®s, sS, as‚ü© := exists_of_mem_parallel h, ‚ü®t, tT, st‚ü© := wseq.exists_of_lift_rel_right H sS, aT := (st _).2 as in mem_parallel h1 tT aT
have aa := parallel_promises h2 h
apply subtype.eq; simp [of_stream, cons]; rw stream.map_cons
apply subtype.eq; simp [of_stream, cons]
simp [of_stream, cons]
rw stream.map_cons
apply subtype.eq
simp [ret_mem]
rw [lift_rel_destruct_iff]; simp
simp
rw [lift_rel_destruct_iff]
rw [lift_rel_destruct_iff, lift_rel_destruct_iff]
rw [lift_rel_destruct_iff, lift_rel_destruct_iff]; simp
simp
simp
apply computation.mem_rec_on h
{ simp }
apply equiv.trans
simp [think_equiv]
intro s'
refine lift_rel_def.2 ‚ü®_, _‚ü©
rw [‚Üêhead_terminates_iff, ‚Üêhead_terminates_iff]
{ rw [‚Üêhead_terminates_iff, ‚Üêhead_terminates_iff], exact terminates_congr (h 0) }
exact terminates_congr (h 0)
intros a b ma mb
cases a with a; cases b with b
cases b with b
cases b with b
cases a with a
{ trivial }
trivial
{ injection mem_unique (mem_map _ ma) ((h 0 _).2 (mem_map _ mb)) }
injection mem_unique (mem_map _ ma) ((h 0 _).2 (mem_map _ mb))
{ injection mem_unique (mem_map _ ma) ((h 0 _).2 (mem_map _ mb)) }
injection mem_unique (mem_map _ ma) ((h 0 _).2 (mem_map _ mb))
cases b with b t'
cases a with a s'
injection mem_unique (mem_map _ ma) ((h 0 _).2 (mem_map _ mb)) with ab
refine ‚ü®ab, Œª n, _‚ü©
refine (nth_congr (flatten_equiv (mem_map _ ma)) n).symm.trans ((_ : nth (tail s) n ~ nth (tail t) n).trans (nth_congr (flatten_equiv (mem_map _ mb)) n))
apply h
rw [nth_tail, nth_tail]
rintro ‚ü®a, h|h, rfl‚ü©
rintro ‚ü®a, h|h, rfl‚ü©; [left, right]; exact ‚ü®_, h, rfl‚ü©
rintro ‚ü®a, h|h, rfl‚ü©; [left, right]
left
right
exact ‚ü®_, h, rfl‚ü©
exact ‚ü®_, h, rfl‚ü©
rintro (‚ü®a, h, rfl‚ü© | ‚ü®a, h, rfl‚ü©); refine ‚ü®_, _, rfl‚ü©; [left, right]; exact h
rintro (‚ü®a, h, rfl‚ü© | ‚ü®a, h, rfl‚ü©); refine ‚ü®_, _, rfl‚ü©; [left, right]
rintro (‚ü®a, h, rfl‚ü© | ‚ü®a, h, rfl‚ü©); refine ‚ü®_, _, rfl‚ü©
refine ‚ü®_, _, rfl‚ü©
refine ‚ü®_, _, rfl‚ü©
left
right
rintro (‚ü®a, h, rfl‚ü© | ‚ü®a, h, rfl‚ü©)
exact h
exact h
simp [diagonal, eq_comm]
ext ‚ü®x, y‚ü©
ext
simp only [range_factorization_coe]
apply apply_range_splitting
ext f
split
split
split; { rintros i ‚ü®his, hpi‚ü©, simpa [*] using h i }
rintros i ‚ü®his, hpi‚ü©
simpa [*] using h i
assume h
{ assume h, split; { rintros i ‚ü®his, hpi‚ü©, simpa [*] using h i } }
rintros ‚ü®ht‚ÇÅ, ht‚ÇÇ‚ü© i his
by_cases p i; simp * at *
simp * at *
simp * at *
by_cases p i
rw update_noteq
exact Œª h, hi (h ‚ñ∏ hj)
rw [union_diff_self, union_eq_self_of_subset_left (singleton_subset_iff.2 hi)]
simp
rw [union_pi, singleton_pi', update_same, pi_update_of_not_mem]
split
ext x
convert h i hi
simp
{ intro h, convert h i hi, simp }
intro h
by_cases h : j = i
intros hx j hj
simpa
{ cases h, simpa }
cases h
exact hf j hj h
rw [update_noteq h]
refine ‚ü®Œª h y, _, surjective.preimage_injective‚ü©
obtain ‚ü®x, hx‚ü© : (f ‚Åª¬π' {y}).nonempty
apply singleton_nonempty
rw [h.nonempty_apply_iff preimage_empty]
{ rw [h.nonempty_apply_iff preimage_empty], apply singleton_nonempty }
exact ‚ü®x, hx‚ü©
exact ‚ü®_, _, (mem_prod.mp ‚Äπ_‚Ä∫).1, (mem_prod.mp ‚Äπ_‚Ä∫).2, rfl‚ü©
rintros ‚ü®_, _, rfl‚ü©
exact ‚ü®(_, _), mem_prod.mpr ‚ü®‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫‚ü©, rfl‚ü©
rintros ‚ü®_, _, _, _, rfl‚ü©
rw [ssubset_iff_subset_ne, subset_singleton_iff_eq, or_and_distrib_right, and_not_self, or_false, and_iff_left_iff_imp]
rintro rfl
refine ne_comm.1 (ne_empty_iff_nonempty.2 (singleton_nonempty _))
rw [fintype_insert', fintype.card_of_finset]; simp [finset.card, to_finset]; refl
rw [fintype_insert', fintype.card_of_finset]; simp [finset.card, to_finset]
rw [fintype_insert', fintype.card_of_finset]
refl
simp [finset.card, to_finset]
simp [(@equiv.plift Œπ).exists_congr_left]
haveI := classical.dec_eq Œ±; exact ‚ü®by apply_instance‚ü©
exact ‚ü®by apply_instance‚ü©
apply_instance
haveI := classical.dec_eq Œ±
rw [‚Üê finset.coe_sort_coe _, h.coe_to_finset]
intro x
simp [nat.lt_succ_iff, nat.find_greatest_le]
rw range_subset_iff
rw [Ioc_union_Ioc, max_self]; exact (min_le_right _ _).trans (le_max_right _ _)
exact (min_le_right _ _).trans (le_max_right _ _)
exact (min_le_right _ _).trans (le_max_right _ _)
rw [Ioc_union_Ioc, max_self]
classical
by_cases ha : a ‚àà s; by_cases hb : b ‚àà s
by_cases hb : b ‚àà s
by_cases hb : b ‚àà s
by_cases ha : a ‚àà s
refine or.inl (subset.antisymm hc _)
rwa [‚Üê Ico_diff_left, diff_singleton_subset_iff, insert_eq_of_mem ha, ‚Üê Icc_diff_right, diff_singleton_subset_iff, insert_eq_of_mem hb] at ho
{ refine or.inl (subset.antisymm hc _), rwa [‚Üê Ico_diff_left, diff_singleton_subset_iff, insert_eq_of_mem ha, ‚Üê Icc_diff_right, diff_singleton_subset_iff, insert_eq_of_mem hb] at ho }
refine (or.inr $ or.inl $ subset.antisymm _ _)
rw [‚Üê Icc_diff_right]
{ rw [‚Üê Icc_diff_right], exact subset_diff_singleton hc hb }
exact subset_diff_singleton hc hb
rwa [‚Üê Ico_diff_left, diff_singleton_subset_iff, insert_eq_of_mem ha] at ho
{ refine (or.inr $ or.inl $ subset.antisymm _ _), { rw [‚Üê Icc_diff_right], exact subset_diff_singleton hc hb }, { rwa [‚Üê Ico_diff_left, diff_singleton_subset_iff, insert_eq_of_mem ha] at ho } }
refine (or.inr $ or.inr $ or.inl $ subset.antisymm _ _)
rw [‚Üê Icc_diff_left]
{ rw [‚Üê Icc_diff_left], exact subset_diff_singleton hc ha }
exact subset_diff_singleton hc ha
rwa [‚Üê Ioc_diff_right, diff_singleton_subset_iff, insert_eq_of_mem hb] at ho
{ refine (or.inr $ or.inr $ or.inl $ subset.antisymm _ _), { rw [‚Üê Icc_diff_left], exact subset_diff_singleton hc ha }, { rwa [‚Üê Ioc_diff_right, diff_singleton_subset_iff, insert_eq_of_mem hb] at ho } }
refine (or.inr $ or.inr $ or.inr $ subset.antisymm _ ho)
rw [‚Üê Ico_diff_left, ‚Üê Icc_diff_right]
apply_rules [subset_diff_singleton]
have := @mem_Ioo_or_eq_left_of_mem_Ico (order_dual Œ±) _ b a x
rw [dual_Ioo, dual_Ico] at this
exact this hmem
rw [Ico_disjoint_Ico, min_eq_left (le_of_lt h2.2), le_max_iff] at h
apply le_antisymm h2.1
exact h.elim (Œª h, absurd hx (not_lt_of_le h)) id
simp [‚Üê Ici_inter_Iio, ‚Üê Ioi_inter_Iic, inter_comm]
simp [‚Üê Ioi_inter_Iic, ‚Üê Ici_inter_Iio, inter_comm]
simp [‚Üê Ioi_inter_Iic, ‚Üê Ici_inter_Iio, inter_comm]
simp [add_comm]
simp
convert image_mul_right_Icc hbc ha using 1; simp only [mul_comm _ a]
simp only [mul_comm _ a]
simp only [mul_comm _ a]
convert image_mul_right_Icc hbc ha using 1
simpa only [ord_connected_def] using h.dual
simp
ext ‚ü®a, b‚ü©
split
exact ‚ü®prod.mk a, ‚ü®a, ha, rfl‚ü©, b, hb, rfl‚ü©
rintro ‚ü®ha, hb‚ü©
{ rintro ‚ü®ha, hb‚ü©, exact ‚ü®prod.mk a, ‚ü®a, ha, rfl‚ü©, b, hb, rfl‚ü© }
rw ‚Üê eq
exact ‚ü®hx, hy‚ü©
rintro ‚ü®f, ‚ü®x, hx, rfl‚ü©, y, hy, eq‚ü©
refine (ht _ x.2 _ y.2 _).mono (hf x) (hf y)
rintro _ ‚ü®x, rfl‚ü© _ ‚ü®y, rfl‚ü© hxy
apply hxy
apply congr_arg f
intro h
exact subtype.eq h
simp
simp [‚Üê ne_empty_iff_nonempty]
rw [bInter_eq_Inter, bInter_eq_Inter, union_distrib_Inter_right]
rw eqv_gen_eq
apply congr_arg Inf
simp only [le_def, or_imp_distrib, ‚Üê forall_and_distrib]
rw [subtype.ext_iff_val, ‚Üêclasses_mk_classes x.1 x.2, ‚Üêclasses_mk_classes y.1 y.2, h]
exact string_imp.mk.inj hl.symm
cases hl : l.as_string
simp [‚Üê multiset.coe_eq_coe, ‚Üê multiset.cons_coe, multiset.cons_eq_cons]
simp [‚Üê multiset.coe_eq_coe, ‚Üê multiset.cons_coe, multiset.cons_eq_cons]; tidy
tidy
intro h
cases h
cases h; rw [h.1, h.2]
rw [h.1, h.2]
rw [h.1, h.2]
apply list.perm.swap'
refl
tidy
tidy; apply rel.trans; assumption
tidy; apply rel.trans
apply rel.trans
assumption
assumption
rw [‚Üê elim_of_mem hl, hvw, elim_of_mem hl]
rw [‚Üê elim_self v, hvw, elim_self]
ext
refine ext (nodup_cons.mp hl).2 (Œª j hj, _)
rw [‚Üê comp_assoc,to_subtype_of_subtype]; simp
simp
rw [‚Üê comp_assoc,to_subtype_of_subtype]
simp [vector.reverse]
cases v
induction n with n ih generalizing u v w
rcases v with ‚ü®_|‚ü®-,-‚ü©,-|-‚ü©
rcases u with ‚ü®_|‚ü®-,-‚ü©,-|-‚ü©
rcases w with ‚ü®_|‚ü®-,-‚ü©,-|-‚ü©
{ rcases u with ‚ü®_|‚ü®-,-‚ü©,-|-‚ü©, rcases v with ‚ü®_|‚ü®-,-‚ü©,-|-‚ü©, rcases w with ‚ü®_|‚ü®-,-‚ü©,-|-‚ü©, exact h_nil, }
exact h_nil
rcases u with ‚ü®_|‚ü®a,u‚ü©,_‚ü©
cases u_property
rcases v with ‚ü®_|‚ü®b,v‚ü©,_‚ü©
cases v_property
rcases w with ‚ü®_|‚ü®c,w‚ü©,_‚ü©
cases w_property
apply @h_cons n _ _ _ ‚ü®u, (add_left_inj 1).mp u_property‚ü© ‚ü®v, (add_left_inj 1).mp v_property‚ü© ‚ü®w, (add_left_inj 1).mp w_property‚ü©
apply ih
casesI n
exact nat.not_lt_zero 0 (fact.out _)
{ exfalso, exact nat.not_lt_zero 0 (fact.out _) }
exfalso
exact fin.is_lt a
rwa [‚Üê h, ‚Üê not_lt, not_iff_self] at this
casesI n
exact nat.not_lt_zero 0 (fact.out (0 < 0))
{ exfalso, exact nat.not_lt_zero 0 (fact.out (0 < 0)) }
exfalso
refl
rintros _ _ ‚ü®p, hp, q, hq, hq0, rfl‚ü© ‚ü®r, hr, s, hs, hs0, rfl‚ü©
rintros _ _ ‚ü®p, hp, q, hq, hq0, rfl‚ü© ‚ü®r, hr, s, hs, hs0, rfl‚ü©; exact ‚ü®p * r, is_submonoid.mul_mem ring.closure.is_subring.to_is_submonoid hp hr, q * s, is_submonoid.mul_mem ring.closure.is_subring.to_is_submonoid hq hs, (div_mul_div _ _ _ _).symm‚ü©
exact ‚ü®p * r, is_submonoid.mul_mem ring.closure.is_subring.to_is_submonoid hp hr, q * s, is_submonoid.mul_mem ring.closure.is_subring.to_is_submonoid hq hs, (div_mul_div _ _ _ _).symm‚ü©
ext x
simp [coe_pow n, pow_succ']
rw [dist_comm, real.dist_eq, abs_lt, lt_sub_iff_add_lt', sub_lt_iff_lt_add', ‚Üê sub_eq_add_neg]
exact ‚ü®f.lt_map_map_zero g, f.map_map_zero_lt g‚ü©
have : 0 < (2^(n+1):‚Ñù) := pow_pos zero_lt_two _
rw [div_div_eq_div_mul, ‚Üê pow_succ, ‚Üê abs_of_pos this]
replace := abs_pos.2 (ne_of_gt this)
convert (div_lt_div_right this).2 ((f^(2^n)).dist_map_map_zero_lt (f^(2^n)))
simp_rw [transnum_aux_seq, real.dist_eq]
rw [‚Üê abs_div, sub_div, pow_succ', pow_succ, ‚Üê two_mul, mul_div_mul_left _ _ (@two_ne_zero ‚Ñù _ _), pow_mul, sq, mul_apply]
refine (tendsto_iff_dist_tendsto_zero.2 $ squeeze_zero (Œª _, dist_nonneg) (Œª n, _) ((tendsto_const_div_at_top_nhds_0_nat 1).comp (tendsto_add_at_top_nat 1)))
dsimp
have : (0:‚Ñù) < n + 1 := n.cast_add_one_pos
rw [real.dist_eq, div_sub' _ _ _ (ne_of_gt this), abs_div, ‚Üê real.dist_eq, abs_of_pos this, div_le_div_right this, ‚Üê nat.cast_add_one]
apply dist_pow_map_zero_mul_translation_number_le
simp only [frequently_at_top, @forall_swap (_ ‚àà s), ae_all_iff]
intro n
filter_upwards [measure_zero_iff_ae_nmem.1 (hf.measure_mem_forall_ge_image_not_mem_eq_zero hs n)]
simp
rw [‚Üê map_map hg.1 hf.1, hf.2, hg.2]
simp [image_image, ‚Üê map_add]
apply nat.eq_prime_pow_of_dvd_least_prime_pow hp.out
apply nat.eq_prime_pow_of_dvd_least_prime_pow hp.out; rwa ‚Üê is_periodic_pt_iff_minimal_period_dvd
rwa ‚Üê is_periodic_pt_iff_minimal_period_dvd
rwa ‚Üê is_periodic_pt_iff_minimal_period_dvd
apply_instance
intros x hx
cases hx with f hf
rw ‚Üê hf
exact adjoin.algebra_map_mem F S f
rwa zmod.card p at h
have h := finite_field.pow_card x
rwa zmod.card p at h
have h := finite_field.expand_card f
simpa only [dim_R] using cardinal.nat_lt_omega (fintype.card (œÉ ‚Üí K))
exact prod_X_sub_smul.monic G F x
simp only [minpoly, polynomial.monic_to_subring]
rw [hx, hx]
ext
refl
ext
refl
ext
refl
cases field.exists_primitive_element F E with Œ± h1
use [minpoly F Œ±, separable F Œ±, is_galois.splits F Œ±]
rw [eq_top_iff, ‚Üêintermediate_field.top_to_subalgebra, ‚Üêh1]
rw intermediate_field.adjoin_simple_to_subalgebra_of_integral F Œ± (integral F Œ±)
apply algebra.adjoin_mono
rw [set.singleton_subset_iff, finset.mem_coe, multiset.mem_to_finset, polynomial.mem_roots]
dsimp only [polynomial.is_root]
rw [polynomial.eval_map, ‚Üêpolynomial.aeval_def]
{ dsimp only [polynomial.is_root], rw [polynomial.eval_map, ‚Üêpolynomial.aeval_def], exact minpoly.aeval _ _ }
exact minpoly.aeval _ _
exact polynomial.map_ne_zero (minpoly.ne_zero (integral F Œ±))
simp only [‚Üê gsmul_one, gsmul_mem, one_mem]
rw [‚Üê is_scalar_tower.aeval_apply, minpoly.aeval]
refine minpoly.dvd K x _
split
intro h
have zero_root := zero_is_root_of_coeff_zero_eq_zero h
rw ‚Üê root hx zero_root
{ intro h, have zero_root := zero_is_root_of_coeff_zero_eq_zero h, rw ‚Üê root hx zero_root, exact ring_hom.map_zero _ }
exact ring_hom.map_zero _
simp
rintro rfl
conv_lhs { rw [hg3, ‚Üê hu] }
rw [hg3, ‚Üê hu]
rwa units.mul_right_dvd
rw [separable_iff_derivative_ne_zero hf, not_not, H]
haveI := is_local_ring_hom_expand F hp.1.pos; exact of_irreducible_map ‚Üë(expand F p) (by rwa ‚Üê expand_contract p H at hf)
exact of_irreducible_map ‚Üë(expand F p) (by rwa ‚Üê expand_contract p H at hf)
haveI := is_local_ring_hom_expand F hp.1.pos
rwa ‚Üê expand_contract p H at hf
contrapose! hq
apply is_unit_of_self_mul_dvd_separable hsep
rw ‚Üê sq
apply multiplicity.pow_dvd_of_le_multiplicity
simpa only [nat.cast_one, nat.cast_bit0] using enat.add_one_le_of_lt hq
rw [root_multiplicity_eq_multiplicity, dif_neg hp, ‚Üê enat.coe_le_coe, enat.coe_get, nat.cast_one]
exact multiplicity_le_one_of_separable (not_unit_X_sub_C _) hsep
apply polynomial.eq_X_sub_C_of_splits_of_single_root i h_splits
apply finset.mk.inj
change _ = {i x}
rw finset.eq_singleton_iff_unique_mem
split
apply finset.mem_mk.mpr
exact map_ne_zero h_ne_zero
rw mem_roots (show h.map i ‚â† 0, by exact map_ne_zero h_ne_zero)
rw [is_root.def,‚Üêeval‚ÇÇ_eq_eval_map,eval‚ÇÇ_hom,h_root]
{ apply finset.mem_mk.mpr, rw mem_roots (show h.map i ‚â† 0, by exact map_ne_zero h_ne_zero), rw [is_root.def,‚Üêeval‚ÇÇ_eq_eval_map,eval‚ÇÇ_hom,h_root], exact ring_hom.map_zero i }
exact ring_hom.map_zero i
{ change _ = {i x}, rw finset.eq_singleton_iff_unique_mem, split, { apply finset.mem_mk.mpr, rw mem_roots (show h.map i ‚â† 0, by exact map_ne_zero h_ne_zero), rw [is_root.def,‚Üêeval‚ÇÇ_eq_eval_map,eval‚ÇÇ_hom,h_root], exact ring_hom.map_zero i }, { exact h_roots } }
exact h_roots
exact nodup_roots (separable.map h_sep)
letI : algebra E E' := ring_hom.to_algebra f.to_ring_hom
haveI : is_scalar_tower F E E' := is_scalar_tower.of_algebra_map_eq (Œª x, (f.commutes x).symm)
exact is_separable_tower_bot_of_is_separable F E E'
refine ‚ü®Œª h, _, inner_eq_neg_mul_norm_of_angle_eq_pi‚ü©
have h‚ÇÅ : (‚à•x‚à• * ‚à•y‚à•) ‚â† 0 := (mul_pos (norm_pos_iff.mpr hx) (norm_pos_iff.mpr hy)).ne'
rw [angle, h, neg_div, div_self h‚ÇÅ, real.arccos_neg_one]
rw [‚Üê sq_eq_sq (norm_nonneg (x + y)) (norm_nonneg (x - y)), ‚Üê inner_eq_zero_iff_angle_eq_pi_div_two x y, norm_add_pow_two_real, norm_sub_pow_two_real]
intro h
intro h
linarith
linarith
split
split; intro h; linarith
split; intro h
rw [dist_eq_norm_vsub V _ p‚ÇÇ, ‚Üêreal_inner_self_eq_norm_sq, vadd_vsub_assoc, real_inner_add_add_self, real_inner_smul_left, real_inner_smul_left, real_inner_smul_right]
ring
intro i
rw dist_comm
exact dist_circumcenter_eq_circumradius _ _
have h := s.circumcenter_circumradius_unique_dist_eq.2 (p, r)
simp only [hp, hr, forall_const, eq_self_iff_true, and_self, prod.ext_iff] at h
exact h.2
convert sum_ite_eq' univ circumcenter_index (function.const _ (1 : ‚Ñù))
ext ‚ü®j‚ü© ; simp [circumcenter_weights_with_circumcenter]
simp [circumcenter_weights_with_circumcenter]
simp [circumcenter_weights_with_circumcenter]
ext ‚ü®j‚ü©
{ ext ‚ü®j‚ü© ; simp [circumcenter_weights_with_circumcenter] }
{ simp }
simp
rw ‚Üêpoints_with_circumcenter_eq_circumcenter
symmetry
refine affine_combination_of_eq_one_of_eq_zero _ _ _ (mem_univ _) rfl _
rintros ‚ü®i‚ü© hi hn ; tauto
tauto
tauto
rintros ‚ü®i‚ü© hi hn
simp_rw [sum_points_with_circumcenter, monge_point_weights_with_circumcenter, sum_const, card_fin, nsmul_eq_mul]
have hn1 : (n + 1 : ‚Ñù) ‚â† 0
{ exact_mod_cast nat.succ_ne_zero _ }
exact_mod_cast nat.succ_ne_zero _
field_simp [hn1]
ring
rw [‚Üêmul_self_inj_of_nonneg dist_nonneg t.circumradius_nonneg, t.reflection_circumcenter_eq_affine_combination_of_points_with_circumcenter h, t.orthocenter_eq_monge_point, monge_point_eq_affine_combination_of_points_with_circumcenter, dist_affine_combination t.points_with_circumcenter (sum_monge_point_weights_with_circumcenter _) (sum_reflection_circumcenter_weights_with_circumcenter h)]
simp_rw [sum_points_with_circumcenter, pi.sub_apply, monge_point_weights_with_circumcenter, reflection_circumcenter_weights_with_circumcenter]
have hu : ({i‚ÇÅ, i‚ÇÇ} : finset (fin 3)) ‚äÜ univ := subset_univ _
obtain ‚ü®i‚ÇÉ, hi‚ÇÉ, hi‚ÇÉ‚ÇÅ, hi‚ÇÉ‚ÇÇ‚ü© : ‚àÉ i‚ÇÉ, univ \ ({i‚ÇÅ, i‚ÇÇ} : finset (fin 3)) = {i‚ÇÉ} ‚àß i‚ÇÉ ‚â† i‚ÇÅ ‚àß i‚ÇÉ ‚â† i‚ÇÇ
dec_trivial!
simp_rw [‚Üêsum_sdiff hu, hi‚ÇÉ]
simp [hi‚ÇÉ‚ÇÅ, hi‚ÇÉ‚ÇÇ]
norm_num
exact ((smooth_mul I).comp (hf.prod_mk hg.inv) : _)
rw div_eq_mul_inv
simp only with mfld_simps
unfold_coes
split
intro Hfh
rw [‚Üê h.symm_apply_apply x] at Hfh
simpa only [(‚àò), h.apply_symm_apply] using Hfh.comp (h x) (h.symm.times_cont_mdiff_within_at.of_le hm) (maps_to_preimage _ _)
{ intro Hfh, rw [‚Üê h.symm_apply_apply x] at Hfh, simpa only [(‚àò), h.apply_symm_apply] using Hfh.comp (h x) (h.symm.times_cont_mdiff_within_at.of_le hm) (maps_to_preimage _ _) }
rw ‚Üê h.image_eq_preimage
exact Œª hf, hf.comp x (h.times_cont_mdiff_within_at.of_le hm) (maps_to_image _ _)
simp
simp [range_comp e, I.unique_diff]
ext
simp only [stereo_to_fun_apply, stereo_inv_fun_apply, smul_add]
set a : ‚Ñù := inner_right v x
set y := orthogonal_projection (‚Ñù ‚àô v)·óÆ x
have split : ‚Üëx = a ‚Ä¢ v + ‚Üëy
convert eq_sum_orthogonal_projection_self_orthogonal_complement (‚Ñù ‚àô v) x
exact (orthogonal_projection_unit_singleton ‚Ñù hv x).symm
{ convert eq_sum_orthogonal_projection_self_orthogonal_complement (‚Ñù ‚àô v) x, exact (orthogonal_projection_unit_singleton ‚Ñù hv x).symm }
have hvy : ‚ü™v, y‚ü´_‚Ñù = 0 := inner_right_of_mem_orthogonal_singleton v y.2
have pythag : 1 = a ^ 2 + ‚à•y‚à• ^ 2
simp [inner_smul_left, hvy]
have hvy' : ‚ü™a ‚Ä¢ v, y‚ü´_‚Ñù = 0 := by simp [inner_smul_left, hvy]
convert norm_add_sq_eq_norm_sq_add_norm_sq_of_inner_eq_zero _ _ hvy' using 2
{ simp [‚Üê split] }
simp [‚Üê split]
{ simp [norm_smul, hv, real.norm_eq_abs, ‚Üê sq, sq_abs] }
simp [norm_smul, hv, real.norm_eq_abs, ‚Üê sq, sq_abs]
{ have hvy' : ‚ü™a ‚Ä¢ v, y‚ü´_‚Ñù = 0 := by simp [inner_smul_left, hvy], convert norm_add_sq_eq_norm_sq_add_norm_sq_of_inner_eq_zero _ _ hvy' using 2, { simp [‚Üê split] }, { simp [norm_smul, hv, real.norm_eq_abs, ‚Üê sq, sq_abs] }, { exact sq _ } }
exact sq _
have ha : 1 - a ‚â† 0
have : a < 1 := (inner_lt_one_iff_real_of_norm_one hv (by simp)).mpr hx.symm
simp
{ have : a < 1 := (inner_lt_one_iff_real_of_norm_one hv (by simp)).mpr hx.symm, linarith }
linarith
have : 2 ^ 2 * ‚à•y‚à• ^ 2 + 4 * (1 - a) ^ 2 ‚â† 0
refine ne_of_gt _
have := norm_nonneg (y:E)
have : 0 < (1 - a) ^ 2 := sq_pos_of_ne_zero (1 - a) ha
{ refine ne_of_gt _, have := norm_nonneg (y:E), have : 0 < (1 - a) ^ 2 := sq_pos_of_ne_zero (1 - a) ha, nlinarith }
nlinarith
have h‚ÇÅ : (2 ^ 2 / (1 - a) ^ 2 * ‚à•y‚à• ^ 2 + 4)‚Åª¬π * 4 * (2 / (1 - a)) = 1
field_simp
{ field_simp, nlinarith }
nlinarith
have h‚ÇÇ : (2 ^ 2 / (1 - a) ^ 2 * ‚à•y‚à• ^ 2 + 4)‚Åª¬π * (2 ^ 2 / (1 - a) ^ 2 * ‚à•y‚à• ^ 2 - 4) = a
field_simp
transitivity (1 - a) ^ 2 * (a * (2 ^ 2 * ‚à•y‚à• ^ 2 + 4 * (1 - a) ^ 2))
congr
{ congr, nlinarith }
nlinarith
ring
{ field_simp, transitivity (1 - a) ^ 2 * (a * (2 ^ 2 * ‚à•y‚à• ^ 2 + 4 * (1 - a) ^ 2)), { congr, nlinarith }, ring_nf, ring }
ring_nf
convert congr_arg2 has_add.add (congr_arg (Œª t, t ‚Ä¢ (y:E)) h‚ÇÅ) (congr_arg (Œª t, t ‚Ä¢ v) h‚ÇÇ) using 1
simp [inner_add_right, inner_smul_right, hvy, real_inner_self_eq_norm_sq, hv, mul_smul, mul_pow, real.norm_eq_abs, sq_abs, norm_smul]
{ simp [inner_add_right, inner_smul_right, hvy, real_inner_self_eq_norm_sq, hv, mul_smul, mul_pow, real.norm_eq_abs, sq_abs, norm_smul] }
simp [split, add_comm]
simp
have := unique_mdiff_within_at.inter (unique_mdiff_within_at_univ I) (is_open.mem_nhds hs xs)
rwa univ_inter at this
simp only [set.pi_univ] with mfld_simps
simp
apply le_antisymm le_top
assume u hu
change u ‚àà times_cont_diff_groupoid 0 I
rw [times_cont_diff_groupoid, mem_groupoid_of_pregroupoid]
simp only [times_cont_diff_on_zero]
split
apply continuous_on.comp (@continuous.continuous_on _ _ _ _ _ univ I.continuous) _ (subset_univ _)
apply continuous_on.comp u.continuous_to_fun I.continuous_symm.continuous_on (inter_subset_left _ _)
{ apply continuous_on.comp (@continuous.continuous_on _ _ _ _ _ univ I.continuous) _ (subset_univ _), apply continuous_on.comp u.continuous_to_fun I.continuous_symm.continuous_on (inter_subset_left _ _) }
apply continuous_on.comp (@continuous.continuous_on _ _ _ _ _ univ I.continuous) _ (subset_univ _)
apply continuous_on.comp u.continuous_inv_fun I.continuous_inv_fun.continuous_on (inter_subset_left _ _)
refine (times_cont_mdiff_within_at_iff' h (mem_chart_source _ _)).2 _
refine ‚ü®(ext_chart_at_continuous_at' _ _ _).continuous_within_at, _‚ü©
{ rwa ext_chart_at_source }
rwa ext_chart_at_source
refine times_cont_diff_within_at_id.congr' _ _
refine times_cont_diff_within_at_id.congr' _ _; simp only [h] with mfld_simps { contextual := tt }
simp only [h] with mfld_simps { contextual := tt }
simp only [h] with mfld_simps { contextual := tt }
simp [‚Üê times_cont_mdiff_within_at_univ, times_cont_mdiff_within_at_iff_times_cont_mdiff_on_nhds, nhds_within_univ]
simp [eq.symm, hb]
simp
simp_rw ‚Üêleft_coset_eq_iff
exact left_coset_equivalence_rel s
rw ‚Üê fintype.card_prod; exact fintype.card_congr (subgroup.group_equiv_quotient_times_subgroup)
rw ‚Üê fintype.card_prod
exact fintype.card_congr (subgroup.group_equiv_quotient_times_subgroup)
rw [singleton_iff] at h‚ÇÅ; subst L'; assumption
rw [singleton_iff] at h‚ÇÅ; subst L'
subst L'
assumption
rw [singleton_iff] at h‚ÇÅ
simp [function.comp, map.comp]
simp [function.comp, map.comp]
rintros ‚ü®m, w, h‚ü© ‚ü®m', w', h'‚ü© he
by_cases hm : m = 1; by_cases hm' : m' = 1
by_cases hm : m = 1
by_cases hm' : m' = 1
by_cases hm' : m' = 1
cc
{ simp only [rcons, dif_pos hm, dif_pos hm'] at he, cc, }
simp only [rcons, dif_pos hm, dif_pos hm'] at he
simp only [rcons, dif_pos hm, dif_neg hm'] at he
exfalso
rw he at h
exact h rfl
{ exfalso, simp only [rcons, dif_pos hm, dif_neg hm'] at he, rw he at h, exact h rfl }
simp only [rcons, dif_pos hm', dif_neg hm] at he
exfalso
rw ‚Üêhe at h'
exact h' rfl
{ exfalso, simp only [rcons, dif_pos hm', dif_neg hm] at he, rw ‚Üêhe at h', exact h' rfl, }
have : m = m' ‚àß w.to_list = w'.to_list
simpa only [rcons, dif_neg hm, dif_neg hm', true_and, eq_self_iff_true, subtype.mk_eq_mk, heq_iff_eq, ‚Üêsubtype.ext_iff_val] using he
{ simpa only [rcons, dif_neg hm, dif_neg hm', true_and, eq_self_iff_true, subtype.mk_eq_mk, heq_iff_eq, ‚Üêsubtype.ext_iff_val] using he }
rcases this with ‚ü®rfl, h‚ü©
exact word.ext _ _ h
congr
rwa [mul_action.mul_smul, hx]
to_rhs
rw [‚Üê hy, ‚Üê mul_one y, ‚Üê inv_mul_self x, ‚Üê mul_assoc, mul_action.mul_smul, hx]
conv {to_rhs, rw [‚Üê hy, ‚Üê mul_one y, ‚Üê inv_mul_self x, ‚Üê mul_assoc, mul_action.mul_smul, hx]}
exact (set.mem_Inter.1 hx g : _)
haveI := comp Œ± g; haveI := comp Œ≤ g; exact is_scalar_tower N Œ± Œ≤
haveI := comp Œ± g; haveI := comp Œ≤ g
haveI := comp Œ≤ g
exact is_scalar_tower N Œ± Œ≤
haveI := comp Œ± g
exact {smul_assoc := Œª n, @smul_assoc _ _ _ _ _ _ _ (g n) }
split_ifs; refl
refl
refl
split_ifs
rw [‚Üê smul_add, neg_add_self, smul_zero]
refine {to_fun := coe, ..}; simp [coe_smul]
simp [coe_smul]
refine {to_fun := coe, ..}
ext
simp
ext
simp
cases f; cases g; simp only; exact funext h
cases f; cases g; simp only
cases f; cases g
cases g
simp only
exact funext h
cases f
rw [mul_assoc, mul_comm _ (f.to_map y), ‚Üêmul_assoc, mul_inv_left, mul_comm]
rw [tree_hom, unique.default_eq]
specialize descending_central_series_ge_lower n
apply (general_commutator_le _ _ _).2
intros x hx q _
exact hH.2 x n (descending_central_series_ge_lower hx) q
induction n with d hd
{ simp [nat.nat_zero_eq_zero] }
simp [nat.nat_zero_eq_zero]
rintros a ‚ü®x, hx : x ‚àà lower_central_series G d.succ, rfl‚ü©
simp [f.map_one, subgroup.one_mem _]
refine closure_induction hx _ (by simp [f.map_one, subgroup.one_mem _]) (Œª y z hy hz, by simp [monoid_hom.map_mul, subgroup.mul_mem _ hy hz]) (Œª y hy, by simp [f.map_inv, subgroup.inv_mem _ hy])
simp [monoid_hom.map_mul, subgroup.mul_mem _ hy hz]
simp [f.map_inv, subgroup.inv_mem _ hy]
rintros a ‚ü®y, hy, z, ‚ü®-, rfl‚ü©‚ü©
apply mem_closure.mpr
simp
exact Œª K hK, hK ‚ü®f y, hd (mem_map_of_mem f hy), by simp‚ü©
convert is_periodic_pt_minimal_period ((*) x) _
rw [order_of, mul_left_iterate, mul_one]
haveI : fact (prime 2) := ‚ü®prime_two‚ü©
exact order_of_eq_prime (int.units_mul_self _) dec_trivial
rw [set.mem_to_finset, set_like.mem_coe, mem_gmultiples_iff_mem_range_add_order_of]
ext x
rw [hœÉ.cycle_type, hœÉ.inv.cycle_type, support_inv]
rw [mul_inv_rev, hœÉœÑ.cycle_type, ‚ÜêhœÉ, ‚ÜêhœÑ, add_comm, disjoint.cycle_type (Œª x, or.imp (Œª h : œÑ x = x, inv_eq_iff_eq.mpr h.symm) (Œª h : œÉ x = x, inv_eq_iff_eq.mpr h.symm) (hœÉœÑ x).symm)]
ext
simp only [mem_map_equiv, perm.coe_mul, comp_app, ne.def, perm.mem_support, equiv.eq_symm_apply]
refl
split
rintro ‚ü®k, rfl‚ü©
use (k + n)
{ rintro ‚ü®k, rfl‚ü©, use (k + n), simp [gpow_add] }
simp [gpow_add]
rintro ‚ü®k, rfl‚ü©
use (k - n)
rw [‚Üêgpow_coe_nat, ‚Üêmul_apply, ‚Üêgpow_add, int.sub_add_cancel]
intros y hy
rw [mem_support, cycle_of_apply] at hy
split_ifs at hy
{ exact mem_support.mpr hy }
exact mem_support.mpr hy
exact absurd rfl hy
simp only [inv_eq_iff_eq, *, forall_prop_of_true, ne.def] at *
cc
simp only [inv_eq_iff_eq, *, forall_prop_of_true, ne.def] at *
cc
rwa [gpow_neg, inv_gpow, inv_inv]
simp [cycle_factors_finset_eq_finset]
cases n
{ simp }
simp
have : j = (fin.cast_le (nat.succ_le_of_lt i.is_lt)).to_embedding ‚ü®j, lt_of_le_of_lt h (nat.lt_succ_self i)‚ü©
{ simp }
simp
ext
rw [this, cycle_range, of_left_inverse'_eq_of_injective, ‚Üêfunction.embedding.to_equiv_range_eq_of_injective, ‚Üêvia_fintype_embedding, via_fintype_embedding_apply_image, rel_embedding.coe_fn_to_embedding, coe_cast_le, coe_fin_rotate]
simp only [fin.ext_iff, coe_last, coe_mk, coe_zero, fin.eta, apply_ite coe, cast_le_mk]
split_ifs with heq
{ refl }
refl
rw fin.coe_add_one_of_lt
exact lt_of_lt_of_le (lt_of_le_of_ne h (mt (congr_arg coe) heq)) (le_last i)
rw [is_three_cycle, cycle_type_cycle_range]
rw [is_three_cycle, cycle_type_cycle_range]; dec_trivial
dec_trivial
dec_trivial
simp [equiv.perm.decompose_fin]
unfold sign_bij_aux at h
rw mem_fin_pairs_lt at *
have : ¬¨b‚ÇÅ < b‚ÇÇ := hb.le.not_lt
split_ifs at h; simp only [*, (equiv.injective f).eq_iff, eq_self_iff_true, and_self, heq_iff_eq] at *
split_ifs at h
simp only [*, (equiv.injective f).eq_iff, eq_self_iff_true, and_self, heq_iff_eq] at *
simp only [*, (equiv.injective f).eq_iff, eq_self_iff_true, and_self, heq_iff_eq] at *
simp only [*, (equiv.injective f).eq_iff, eq_self_iff_true, and_self, heq_iff_eq] at *
simp only [*, (equiv.injective f).eq_iff, eq_self_iff_true, and_self, heq_iff_eq] at *
simp [subtype_congr]
induction n with n ih
{ refl }
refl
rw [pow_succ, perm.mul_apply, apply_mem_support, ih]
simp only [mem_support, swap_apply_def, mul_apply, f.injective.eq_iff] at *
by_cases h : f y = x
split; intro; simp only [*, if_true, eq_self_iff_true, not_true, ne.def] at *
split; intro
intro
intro
simp only [*, if_true, eq_self_iff_true, not_true, ne.def] at *
simp only [*, if_true, eq_self_iff_true, not_true, ne.def] at *
split
{ split; intro; simp only [*, if_true, eq_self_iff_true, not_true, ne.def] at * }
split_ifs at hy; cc
cc
cc
split_ifs at hy
by_cases h : f = 1
exact ne_of_eq_of_ne (card_support_eq_zero.mpr h) zero_ne_one
{ exact ne_of_eq_of_ne (card_support_eq_zero.mpr h) zero_ne_one }
exact ne_of_gt (one_lt_card_support_of_ne_one h)
ext
ext; simp
simp
simp
tidy
let x : equiv.perm (fin 5) := ‚ü®![1, 2, 0, 3, 4], ![2, 0, 1, 3, 4], dec_trivial, dec_trivial‚ü©
let y : equiv.perm (fin 5) := ‚ü®![3, 4, 2, 0, 1], ![3, 4, 2, 0, 1], dec_trivial, dec_trivial‚ü©
let z : equiv.perm (fin 5) := ‚ü®![0, 3, 2, 1, 4], ![0, 3, 2, 1, 4], dec_trivial, dec_trivial‚ü©
rw [ne.def, equiv.ext_iff]
have x_ne_one : x ‚â† 1
dec_trivial
{ rw [ne.def, equiv.ext_iff], dec_trivial }
have key : x = z * (x * (y * x * y‚Åª¬π) * x‚Åª¬π * (y * x * y‚Åª¬π)‚Åª¬π) * z‚Åª¬π
dec_trivial!
{ ext a, dec_trivial! }
ext a
refine not_solvable_of_mem_derived_series x_ne_one (Œª n, _)
induction n with n ih
{ exact mem_top x }
exact mem_top x
rw key
exact (derived_series_normal _ _).conj_mem _ (general_commutator_containment _ _ ih ((derived_series_normal _ _).conj_mem _ ih _)) _
rw [‚Üê fintype.card_eq.mpr ‚ü®fintype_helper‚ü©, fintype.card_sum, zmod.card, two_mul]
rw [gsmul_coe_nat]
exact add_submonoid.nsmul_mem H.to_add_submonoid hx n
rw gsmul_neg_succ_of_nat
apply H.neg_mem'
exact add_submonoid.nsmul_mem H.to_add_submonoid hx n.succ
refine ((iH.comap f).eq_bot_or_eq_top).imp (Œª h, _) (Œª h, _)
rw [‚Üêmap_bot f, ‚Üêh, map_comap_eq_self_of_surjective hf]
{ rw [‚Üêmap_bot f, ‚Üêh, map_comap_eq_self_of_surjective hf] }
exact comap_injective hf h
rw [‚Üêcomap_top f] at h
rw mul_one
simpa using hN.conj_mem _ hn h'‚Åª¬π
simp [‚Üê ha, ‚Üê hb, mul_assoc]
rw [mul_assoc h, inv_mul_cancel_left, ‚Üê hx, mul_inv_rev]
rw [set.mem_set_of_eq, f.map_one, g.map_one]
simp [*]
apply_instance
have := comap_map_mkq (‚®Ö n : ‚Ñï, I ^ n ‚Ä¢ ‚ä§ : submodule R M) (I ^ n ‚Ä¢ ‚ä§)
simp only [sup_of_le_right (infi_le (Œª n, (I ^ n ‚Ä¢ ‚ä§ : submodule R M)) n)] at this
rw [‚Üê this, map_smul'', mem_comap, map_top, range_mkq, ‚Üê smodeq.zero]
exact hx n
rw ker_mkq
exact smul_mono (ideal.pow_le_pow h) (le_refl _)
rw [pi.zero_apply, pi.zero_apply, linear_map.map_zero]
rw [pi.add_apply, pi.add_apply, linear_map.map_add, hf hmn, hg hmn]
rw [pi.smul_apply, pi.smul_apply, linear_map.map_smul, hf hmn]
rw ‚Üêmem_coe at h
rw [‚Üêaffine_span_insert_affine_span, set.insert_eq_of_mem h, affine_span_coe]
rcases hp1 with ‚ü®p1a, ‚ü®hp1a, ‚ü®v1, ‚ü®hv1, hv1p‚ü©‚ü©‚ü©‚ü©
rcases hp2 with ‚ü®p2a, ‚ü®hp2a, ‚ü®v2, ‚ü®hv2, hv2p‚ü©‚ü©‚ü©‚ü©
rw [hv1p, hv2p, vsub_vadd_eq_vsub_sub (v1 +·µ• p1a), vadd_vsub_assoc, add_comm, add_sub_assoc]
have hv1v2 : v1 - v2 ‚àà vector_span k s
rw sub_eq_add_neg
apply (vector_span k s).add_mem hv1
rw ‚Üêneg_one_smul k v2
{ rw sub_eq_add_neg, apply (vector_span k s).add_mem hv1, rw ‚Üêneg_one_smul k v2, exact (vector_span k s).smul_mem (-1 : k) hv2 }
exact (vector_span k s).smul_mem (-1 : k) hv2
refine (vector_span k s).add_mem _ hv1v2
exact vsub_mem_vector_span k hp1a hp2a
rcases hp1 with ‚ü®v1, hv1, hp1‚ü©
rcases hp2 with ‚ü®v2, hv2, hp2‚ü©
rcases hp3 with ‚ü®v3, hv3, hp3‚ü©
use [c ‚Ä¢ (v1 - v2) + v3, direction.add_mem (direction.smul_mem c (direction.sub_mem hv1 hv2)) hv3]
simp [hp1, hp2, hp3, vadd_vadd]
ext v
rw mem_direction_iff_eq_vsub (mk'_nonempty _ _)
split
rintros ‚ü®p1, ‚ü®v1, hv1, hp1‚ü©, p2, ‚ü®v2, hv2, hp2‚ü©, hv‚ü©
rw [hv, hp1, hp2, vadd_vsub_vadd_cancel_right]
{ rintros ‚ü®p1, ‚ü®v1, hv1, hp1‚ü©, p2, ‚ü®v2, hv2, hp2‚ü©, hv‚ü©, rw [hv, hp1, hp2, vadd_vsub_vadd_cancel_right], exact direction.sub_mem hv1 hv2 }
exact direction.sub_mem hv1 hv2
exact Œª hv, ‚ü®v +·µ• p, vadd_mem_mk' _ hv, p, self_mem_mk' _ _, (vadd_vsub _ _).symm‚ü©
cases S.nonempty with p
ext v
refine ‚ü®imp_intro submodule.mem_top, Œª hv, _‚ü©
have hpv : (v +·µ• p -·µ• p : V) ‚àà (‚ä§ : affine_subspace k P).direction := vsub_mem_direction (mem_top k V _) (mem_top k V _)
rwa vadd_vsub at hpv
rw vector_span_def
refine le_antisymm _ (submodule.span_mono _)
rw submodule.span_le
rintros v ‚ü®p1, p2, hp1, hp2, hv‚ü©
rw ‚Üêvsub_sub_vsub_cancel_left p1 p2 p at hv
rw [‚Üêhv, set_like.mem_coe, submodule.mem_span]
exact Œª m hm, submodule.sub_mem _ (hm ‚ü®p2, hp2, rfl‚ü©) (hm ‚ü®p1, hp1, rfl‚ü©)
{ rw submodule.span_le, rintros v ‚ü®p1, p2, hp1, hp2, hv‚ü©, rw ‚Üêvsub_sub_vsub_cancel_left p1 p2 p at hv, rw [‚Üêhv, set_like.mem_coe, submodule.mem_span], exact Œª m hm, submodule.sub_mem _ (hm ‚ü®p2, hp2, rfl‚ü©) (hm ‚ü®p1, hp1, rfl‚ü©) }
rintros v ‚ü®p2, hp2, hv‚ü©
exact ‚ü®p, p2, hp, hp2, hv‚ü©
rw [vector_span_eq_span_vsub_set_left k (set.mem_image_of_mem p hi), ‚Üêset.insert_eq_of_mem hi, ‚Üêset.insert_diff_singleton, set.image_insert_eq, set.image_insert_eq]
conv_lhs { rw [vector_span_eq_span_vsub_set_left k (set.mem_image_of_mem p hi), ‚Üêset.insert_eq_of_mem hi, ‚Üêset.insert_diff_singleton, set.image_insert_eq, set.image_insert_eq] }
simp [submodule.span_insert_eq_span]
rw [‚Üêsmul_sub, vsub_sub_vsub_cancel_left]
rw [‚Üêsum_smul, h, one_smul, vsub_add_vsub_cancel, vsub_self]
split
swap
rcases is_empty_or_nonempty Œπ with hŒπ|‚ü®‚ü®i0‚ü©‚ü©
rw [vector_span_range_eq_span_range_vsub_right k p i0, ‚Üêset.image_univ, finsupp.mem_span_image_iff_total]
rintros ‚ü®l, hl, hv‚ü©
use insert i0 l.support
set w := (l : Œπ ‚Üí k) - function.update (function.const Œπ 0 : Œπ ‚Üí k) i0 (‚àë i in l.support, l i) with hwdef
use w
have hw : ‚àë i in insert i0 l.support, w i = 0
rw hwdef
simp_rw [pi.sub_apply, finset.sum_sub_distrib, finset.sum_update_of_mem (finset.mem_insert_self _ _), finset.sum_const_zero, finset.sum_insert_of_eq_zero_if_not_mem finsupp.not_mem_support_iff.1, add_zero, sub_self]
{ rw hwdef, simp_rw [pi.sub_apply, finset.sum_sub_distrib, finset.sum_update_of_mem (finset.mem_insert_self _ _), finset.sum_const_zero, finset.sum_insert_of_eq_zero_if_not_mem finsupp.not_mem_support_iff.1, add_zero, sub_self] }
use hw
have hz : w i0 ‚Ä¢ (p i0 -·µ• p i0 : V) = 0 := (vsub_self (p i0)).symm ‚ñ∏ smul_zero _
change (Œª i, w i ‚Ä¢ (p i -·µ• p i0 : V)) i0 = 0 at hz
rw [finset.weighted_vsub_eq_weighted_vsub_of_point_of_sum_eq_zero _ w p hw (p i0), finset.weighted_vsub_of_point_apply, ‚Üêhv, finsupp.total_apply, finset.sum_insert_zero hz]
change ‚àë i in l.support, l i ‚Ä¢ _ = _
congr' with i
by_cases h : i = i0
{ simp [h] }
simp [h]
{ rw [vector_span_range_eq_span_range_vsub_right k p i0, ‚Üêset.image_univ, finsupp.mem_span_image_iff_total], rintros ‚ü®l, hl, hv‚ü©, use insert i0 l.support, set w := (l : Œπ ‚Üí k) - function.update (function.const Œπ 0 : Œπ ‚Üí k) i0 (‚àë i in l.support, l i) with hwdef, use w, have hw : ‚àë i in insert i0 l.support, w i = 0, { rw hwdef, simp_rw [pi.sub_apply, finset.sum_sub_distrib, finset.sum_update_of_mem (finset.mem_insert_self _ _), finset.sum_const_zero, finset.sum_insert_of_eq_zero_if_not_mem finsupp.not_mem_support_iff.1, add_zero, sub_self] }, use hw, have hz : w i0 ‚Ä¢ (p i0 -·µ• p i0 : V) = 0 := (vsub_self (p i0)).symm ‚ñ∏ smul_zero _, change (Œª i, w i ‚Ä¢ (p i -·µ• p i0 : V)) i0 = 0 at hz, rw [finset.weighted_vsub_eq_weighted_vsub_of_point_of_sum_eq_zero _ w p hw (p i0), finset.weighted_vsub_of_point_apply, ‚Üêhv, finsupp.total_apply, finset.sum_insert_zero hz], change ‚àë i in l.support, l i ‚Ä¢ _ = _, congr' with i, by_cases h : i = i0, { simp [h] }, { simp [hwdef, h] } }
simp [hwdef, h]
resetI
rw [set.range_eq_empty, vector_span_empty, submodule.mem_bot]
rintro rfl
use [‚àÖ]
{ rcases is_empty_or_nonempty Œπ with hŒπ|‚ü®‚ü®i0‚ü©‚ü©, swap, { rw [vector_span_range_eq_span_range_vsub_right k p i0, ‚Üêset.image_univ, finsupp.mem_span_image_iff_total], rintros ‚ü®l, hl, hv‚ü©, use insert i0 l.support, set w := (l : Œπ ‚Üí k) - function.update (function.const Œπ 0 : Œπ ‚Üí k) i0 (‚àë i in l.support, l i) with hwdef, use w, have hw : ‚àë i in insert i0 l.support, w i = 0, { rw hwdef, simp_rw [pi.sub_apply, finset.sum_sub_distrib, finset.sum_update_of_mem (finset.mem_insert_self _ _), finset.sum_const_zero, finset.sum_insert_of_eq_zero_if_not_mem finsupp.not_mem_support_iff.1, add_zero, sub_self] }, use hw, have hz : w i0 ‚Ä¢ (p i0 -·µ• p i0 : V) = 0 := (vsub_self (p i0)).symm ‚ñ∏ smul_zero _, change (Œª i, w i ‚Ä¢ (p i -·µ• p i0 : V)) i0 = 0 at hz, rw [finset.weighted_vsub_eq_weighted_vsub_of_point_of_sum_eq_zero _ w p hw (p i0), finset.weighted_vsub_of_point_apply, ‚Üêhv, finsupp.total_apply, finset.sum_insert_zero hz], change ‚àë i in l.support, l i ‚Ä¢ _ = _, congr' with i, by_cases h : i = i0, { simp [h] }, { simp [hwdef, h] } }, { resetI, rw [set.range_eq_empty, vector_span_empty, submodule.mem_bot], rintro rfl, use [‚àÖ], simp } }
simp
rintros ‚ü®s, w, hw, rfl‚ü©
exact weighted_vsub_mem_vector_span hw p
erw [weighted_vsub_of_point_apply, weighted_vsub_of_point_apply, ‚Üê@vsub_eq_zero_iff_eq V, vadd_vsub_assoc, vsub_vadd_eq_vsub_sub, ‚Üêadd_sub_assoc, add_comm, add_sub_assoc, ‚Üêsum_sub_distrib]
conv_lhs { congr, skip, congr, skip, funext, rw [‚Üêsmul_sub, vsub_sub_vsub_cancel_left] }
congr
skip
congr
skip
funext
rw [collinear_iff_finrank_le_one, affine_independent_iff_not_finrank_vector_span_le k p (fintype.card_fin 3)]
intros fs w hw hs i0 hi0
let fs' := fs.map f
let w' := Œª i, if h : ‚àÉ i2, f i2 = i then w h.some else 0
have hw' : ‚àÄ i2 : Œπ2, w' (f i2) = w i2
intro i2
have h : ‚àÉ i : Œπ2, f i = f i2 := ‚ü®i2, rfl‚ü©
have hs : h.some = i2 := f.injective h.some_spec
{ intro i2, have h : ‚àÉ i : Œπ2, f i = f i2 := ‚ü®i2, rfl‚ü©, have hs : h.some = i2 := f.injective h.some_spec, simp_rw [w', dif_pos h, hs] }
simp_rw [w', dif_pos h, hs]
have hw's : ‚àë i in fs', w' i = 0
rw [‚Üêhw, finset.sum_map]
{ rw [‚Üêhw, finset.sum_map], simp [hw'] }
simp [hw']
have hs' : fs'.weighted_vsub p w' = (0:V)
rw [‚Üêhs, finset.weighted_vsub_map]
congr' with i
{ rw [‚Üêhs, finset.weighted_vsub_map], congr' with i, simp [hw'] }
simp [hw']
rw [‚Üêha fs' w' hw's hs' (f i0) ((finset.mem_map' _).2 hi0), hw']
rw [slope, slope, ‚Üê neg_vsub_eq_vsub_rev, smul_neg, ‚Üê neg_smul, neg_inv, neg_sub]
simp [f.map_eq_zero_of_eq v h hij]
apply œÉ.induction_on' (Œª œÉ, _)
exact _root_.congr_arg quotient.mk' (equiv.swap_mul_involutive i j œÉ)
dsimp only
rw multilinear_map.sum_apply
exact finset.sum_involution (Œª œÉ _, equiv.swap i j ‚Ä¢ œÉ) (Œª œÉ _, dom_coprod.summand_add_swap_smul_eq_zero a b œÉ hv hij) (Œª œÉ _, mt $ dom_coprod.summand_eq_zero_of_smul_invariant a b œÉ hv hij) (Œª œÉ _, finset.mem_univ _) (Œª œÉ _, equiv.perm.mod_sum_congr.swap_smul_involutive i j œÉ)
rw [set_like.mem_coe, mem_sup, set.mem_add]
simp
ext
rw [ker_comp, hg, submodule.comap_bot]
rw [mem_map_equiv, mem_comap, linear_equiv.coe_coe]
classical
intro g
refine ‚ü®Œª x, if h : ‚àÉ y, f y = x then g h.some else 0, _‚ü©
ext
dsimp only [fun_left_apply]
split_ifs with w
congr
{ congr, exact hf w.some_spec, }
exact hf w.some_spec
simpa only [not_true, exists_apply_eq_apply] using w
obtain ‚ü®m, ne‚ü© := (nontrivial_iff_exists_ne (0 : M)).mp infer_instance
exact nontrivial_of_ne 1 0 (Œª p, ne (linear_map.congr_fun p m))
simp only [pi.sub_apply, map_add, add_sub_comm]
simp [pi.sub_apply, map_smul, smul_sub]
intros
simp
refl
intros
simp
refl
rw [linear_map.comp_assoc, hg, f.comp_id]
by_cases htr : nontrivial R
letI := htr
simp [htr, reindex_range, reindex_apply, equiv.apply_of_injective_symm b b.injective, subtype.coe_mk]
{ letI := htr, simp [htr, reindex_range, reindex_apply, equiv.apply_of_injective_symm b b.injective, subtype.coe_mk] }
letI : subsingleton R := not_nontrivial_iff_subsingleton.mp htr
letI := module.subsingleton R M
simp [reindex_range]
ext i
simp only [basis.prod, basis.coe_of_repr, linear_equiv.symm_trans_apply, linear_equiv.prod_symm, linear_equiv.prod_apply, b.repr.apply_symm_apply, linear_equiv.symm_symm, repr_self, equiv.to_fun_as_coe, finsupp.fst_sum_finsupp_lequiv_prod_finsupp, linear_equiv.map_zero, finsupp.zero_apply]
apply finsupp.single_eq_of_ne sum.inr_ne_inl
rw [linear_map.map_add, add_left]
rw [linear_map.map_smul, smul_left]
rw [linear_map.map_add, add_right]
rw [linear_map.map_smul, smul_right]
classical
rw linear_independent_iff'
intros s w hs i hi
have : B (s.sum $ Œª (i : n), w i ‚Ä¢ v i) (v i) = 0
{ rw [hs, zero_left] }
rw [hs, zero_left]
have hsum : s.sum (Œª (j : n), w j * B (v j) (v i)) = s.sum (Œª (j : n), if i = j then w j * B (v j) (v i) else 0)
refine finset.sum_congr rfl (Œª j hj, _)
by_cases (i = j)
{ rw [if_pos h] }
rw [if_pos h]
{ refine finset.sum_congr rfl (Œª j hj, _), by_cases (i = j), { rw [if_pos h] }, { rw [if_neg h, is_Ortho_def.1 hv‚ÇÅ _ _ h, mul_zero] } }
rw [if_neg h, is_Ortho_def.1 hv‚ÇÅ _ _ h, mul_zero]
simp_rw [sum_left, smul_left, hsum, finset.sum_ite_eq] at this
rw [if_pos, mul_eq_zero] at this
cases this
{ assumption }
assumption
{ exact false.elim (hv‚ÇÇ i $ this) }
exact false.elim (hv‚ÇÇ i $ this)
assumption
induction h
rw [alg_hom.commutes, alg_hom.map_mul, tensor_algebra.lift_Œπ_apply, f.prop]
rw [ linear_map.comp_apply, alg_hom.to_linear_map_apply, comp_Œπ_sq_scalar]
ext
simp only [Œπ, alg_hom.to_linear_map_apply, function.comp_app, linear_map.coe_comp, subtype.coe_mk, ring_quot.lift_alg_hom_mk_alg_hom_apply, tensor_algebra.lift_Œπ_apply]
ext
simp only [Œπ, alg_hom.comp_to_linear_map, alg_hom.to_linear_map_apply, function.comp_app, linear_map.coe_comp, subtype.coe_mk, ring_quot.lift_alg_hom_mk_alg_hom_apply, tensor_algebra.lift_Œπ_apply]
exact alg_hom.congr_fun (map_comp_map Q‚ÇÅ Q‚ÇÇ Q‚ÇÉ _ _ _ _) x
ext x
simp
apply quaternion_algebra.lift.symm.injective
ext1
simp
simp
ext1; dsimp [quaternion_algebra.basis.lift]; simp
ext1; dsimp [quaternion_algebra.basis.lift]
dsimp [quaternion_algebra.basis.lift]
dsimp [quaternion_algebra.basis.lift]
simp
ext
rw [linear_map.coe_det, dif_pos, det_aux_def' _ b]
rw [linear_map.coe_det, dif_pos, det_aux_def' _ b]; assumption
assumption
simp only [‚Üê zero_smul ùïú (1 : M ‚Üí‚Çó[ùïú] M), det_smul, mul_one, monoid_hom.map_one]
dsimp
apply dfinsupp.induction f
{ rw [smul_zero, add_monoid_hom.map_zero, smul_zero] }
rw [smul_zero, add_monoid_hom.map_zero, smul_zero]
intros a b f ha hb hf
rw [smul_add, add_monoid_hom.map_add, add_monoid_hom.map_add, smul_add, hf, ‚Üêsingle_smul, sum_add_hom_single, sum_add_hom_single, linear_map.to_add_monoid_hom_coe, linear_map.map_smul]
ext x y
simp
ext x y
simp
ext x y
simp
ext
simp
refine dim_le_of_submodule _ _ _
exact (linear_map.range_le_iff_comap.2 $ eq_top_iff'.2 $ assume x, show f x + g x ‚àà (f.range ‚äî g.range : submodule K V'), from mem_sup.2 ‚ü®_, ‚ü®x, rfl‚ü©, _, ‚ü®x, rfl‚ü©, rfl‚ü©)
apply le_antisymm
exact f.to_linear_map.lift_dim_le_of_injective f.injective
{ exact f.to_linear_map.lift_dim_le_of_injective f.injective, }
exact f.symm.to_linear_map.lift_dim_le_of_injective f.symm.injective
apply dual_basis_apply
ext i x
rw [h.coeffs_apply, h.dual_lc]
ext i
refine _ ‚â™‚â´‚Çó W.quot_dual_equiv_annihilator
refine linear_equiv.quot_equiv_of_equiv _ (basis.of_vector_space K V).to_dual_equiv
exact (basis.of_vector_space K W).to_dual_equiv.trans W.dual_equiv_dual
obtain ‚ü®c, nu‚ü© := exists_spectrum_of_is_alg_closed_of_finite_dimensional K f
use c
rw linear_map.is_unit_iff at nu
exact has_eigenvalue_of_has_eigenvector (exists_mem_ne_zero_of_ne_bot nu).some_spec
simp only [generalized_eigenspace, preorder_hom.coe_fun_mk, ‚Üê linear_map.ker_comp]
induction k with k ih
rw [pow_zero, pow_zero, linear_map.one_eq_id]
{ rw [pow_zero, pow_zero, linear_map.one_eq_id], apply (submodule.ker_subtype _).symm }
apply (submodule.ker_subtype _).symm
erw [pow_succ', pow_succ', linear_map.ker_comp, linear_map.ker_comp, ih, ‚Üê linear_map.ker_comp, ‚Üê linear_map.ker_comp, linear_map.comp_assoc]
obtain ‚ü®b‚ü© := (basis.basis_singleton_iff punit).mpr ‚ü®v, n, h‚ü©
rw [finrank_eq_card_basis b, fintype.card_punit]
haveI := finite_dimensional_of_finrank (_root_.zero_lt_one.trans_le h.symm.le)
exact (fin_basis_of_finrank_eq K V h).reindex equiv_of_unique_of_unique
rw ‚Üê lift_le.{_ (max v w)}
simpa [‚Üê finrank_eq_dim K V] using cardinal_lift_le_dim_of_linear_independent.{_ _ _ (max v w)} h
rw [finite_dimensional, is_noetherian.iff_dim_lt_omega ] at h ‚ä¢
unfreezingI { rw [finite_dimensional, is_noetherian.iff_dim_lt_omega ] at h ‚ä¢ }
rw [‚Üê cardinal.lift_lt.{v' v}]
rw [‚Üê cardinal.lift_lt.{v v'}] at h
rw [cardinal.lift_omega] at h ‚ä¢
exact (lift_dim_map_le f p).trans_lt h
haveI := classical.dec_pred (Œª (x : Œ±), x ‚àà s)
haveI := classical.dec_pred (Œª (x : Œ±), x ‚àà s); simp [mem_supported, set.subset_def, not_imp_comm]
simp [mem_supported, set.subset_def, not_imp_comm]
refine ‚ü®Œª h x hx, _, disjoint_supported_supported‚ü©
rcases exists_ne (0 : M) with ‚ü®y, hy‚ü©
have := h ‚ü®single_mem_supported R y hx.1, single_mem_supported R y hx.2‚ü©
rw [mem_bot, single_eq_zero] at this
exact hy this
ext x
split
intros hx
rw [linear_map.mem_range] at hx
rcases hx with ‚ü®l, hl‚ü©
rw ‚Üê hl
rw finsupp.total_apply
unfold finsupp.sum
apply sum_mem (span R (range v))
exact Œª i hi, submodule.smul_mem _ _ (subset_span (mem_range_self i))
{ intros hx, rw [linear_map.mem_range] at hx, rcases hx with ‚ü®l, hl‚ü©, rw ‚Üê hl, rw finsupp.total_apply, unfold finsupp.sum, apply sum_mem (span R (range v)), exact Œª i hi, submodule.smul_mem _ _ (subset_span (mem_range_self i)) }
apply span_le.2
intros x hx
rcases hx with ‚ü®i, hi‚ü©
rw [set_like.mem_coe, linear_map.mem_range]
use finsupp.single i 1
simp [hi]
simp [total_apply]
ext
intros
ext
ext; simp only [add_equiv.to_fun_eq_coe, prod.smul_fst, prod.smul_snd, smul_apply, snd_sum_finsupp_add_equiv_prod_finsupp, fst_sum_finsupp_add_equiv_prod_finsupp, ring_hom.id_apply]
simp only [add_equiv.to_fun_eq_coe, prod.smul_fst, prod.smul_snd, smul_apply, snd_sum_finsupp_add_equiv_prod_finsupp, fst_sum_finsupp_add_equiv_prod_finsupp, ring_hom.id_apply]
simp only [add_equiv.to_fun_eq_coe, prod.smul_fst, prod.smul_snd, smul_apply, snd_sum_finsupp_add_equiv_prod_finsupp, fst_sum_finsupp_add_equiv_prod_finsupp, ring_hom.id_apply]
exactI eq_of_fin_equiv I.quotient ((ideal.pi_quot_equiv _ _).symm ‚â™‚â´‚Çó ((induced_equiv _ e) ‚â™‚â´‚Çó (ideal.pi_quot_equiv _ _)))
rw [ker_comp, of_le, comap_cod_restrict, ker_mkq, map_comap_subtype]
exact comap_mono (inf_le_inf_right _ le_sup_left)
rw [‚Üê linear_independent_equiv ((equiv.option_equiv_sum_punit _).trans (equiv.set.insert has).symm), linear_independent_option]
simp [(‚àò), range_comp f]
have p : (span.repr R (set.range v) x).equiv_map_domain (equiv.of_injective _ hv.injective).symm = hv.repr x
apply (linear_independent.total_equiv hv).injective
ext
{ apply (linear_independent.total_equiv hv).injective, ext, simp, }
simp
ext ‚ü®_, ‚ü®i, rfl‚ü©‚ü©
simp [‚Üêp]
ext i j
rw [e.to_matrix_apply, pi.smul_apply, linear_equiv.map_smul]
refl
intro v
ext j
exact e.sum_to_matrix_smul_self v j
intros m
ext k l
simp only [e.to_matrix_apply, ‚Üê e.equiv_fun_apply, ‚Üê e.equiv_fun_symm_apply, linear_equiv.apply_symm_apply]
simp_rw [e.to_matrix_apply, e.sum_repr]
ext i j
change _ = _ + _
rw [e.to_matrix_apply, pi.add_apply, linear_equiv.map_add]
refl
intros c v
ext
ext; simp
simp
convert div_inv_monoid.gpow_neg' 0 A
simp only [gpow_one, int.coe_nat_zero, int.coe_nat_succ, gpow_eq_pow, zero_add]
simp [‚Üê int.coe_nat_succ, pow_succ']
rw [neg_add, neg_add_cancel_right, fpow_neg h, fpow_coe_nat]
rw [mul_inv_rev, matrix.mul_assoc, nonsing_inv_mul _ h, matrix.mul_one]
rw [fpow_neg h, ‚Üê int.coe_nat_succ, fpow_coe_nat, pow_succ, mul_eq_mul, mul_eq_mul]
refine (inv_eq_left_inv _).symm
rw [‚Üêmul_eq_mul, ‚Üêunits.coe_mul, inv_mul_self, units.coe_one]
haveI : subsingleton n := fintype.card_le_one_iff_subsingleton.mp h.le
exact adjugate_subsingleton _
have h1 := (is_unit_det_of_left_inverse h)
have h2 := matrix.invertible_of_is_unit_det h1
have := @inv_of_eq_left_inv (matrix n n Œ±) (infer_instance) A B h2 h
simp* at *
simp only [submodule.eq_bot_iff, linear_map.mem_ker, matrix.to_lin'_apply]
rw [‚Üê matrix.to_lin_mul_apply, hM'M, matrix.to_lin_one, id_apply]
rw [‚Üê matrix.to_lin_mul_apply, hMM', matrix.to_lin_one, id_apply]
ext i j
simp only [matrix.mul_vec_std_basis, matrix.mul_vec_lin_apply]
apply (pi.basis_fun R n).ext
ext i
intro j
simp only [pi.basis_fun_apply, matrix.mul_vec_std_basis, matrix.mul_vec_lin_apply]
ext i j
simp only [pi.add_apply, linear_map.add_apply]
ext i j
simp only [pi.smul_apply, linear_map.smul_apply, ring_hom.id_apply]
simp
simp [add_comm]
simp
rw f.snoc_add
simp only [f.snoc_smul, ring_hom.id_apply]
ext z
change f (snoc (update m i (x + y)) z) = f (snoc (update m i x) z) + f (snoc (update m i y) z)
rw [snoc_update, snoc_update, snoc_update, f.map_add]
ext z
change f (snoc (update m i (c ‚Ä¢ x)) z) = c ‚Ä¢ f (snoc (update m i x) z)
rw [snoc_update, snoc_update, f.map_smul]
intros f g
ext
ext; refl
refl
refl
intros r f
ext
ext; refl
refl
refl
ext ‚ü®x, y‚ü©; simp
simp
ext ‚ü®x, y‚ü©
exact 0
tidy
cases Q'
congr
funext
apply H
cases Q
simp [map_add_self, bit0, add_mul, add_assoc]
rw [‚Üê two_mul (Q x), ‚Üêmul_assoc, inv_of_mul_self, one_mul]
rw [ker_liftq, le_antisymm h h', mkq_map_self]
suffices : (span R‚ÇÇ s).comap f ‚â§ span R (f ‚Åª¬π' s)
{ exact le_antisymm (span_preimage_le f s) this, }
exact le_antisymm (span_preimage_le f s) this
have hk : ker f ‚â§ span R (f ‚Åª¬π' s)
have hy : y ‚àà s
exact classical.some_spec h‚ÇÄ
let y := classical.some h‚ÇÄ
{ exact classical.some_spec h‚ÇÄ, }
use [y, h‚ÇÅ hy]
rw ‚Üê set.singleton_subset_iff at hy
rw ker_le_iff
exact set.subset.trans subset_span (span_mono (set.preimage_mono hy))
{ let y := classical.some h‚ÇÄ, have hy : y ‚àà s, { exact classical.some_spec h‚ÇÄ, }, rw ker_le_iff, use [y, h‚ÇÅ hy], rw ‚Üê set.singleton_subset_iff at hy, exact set.subset.trans subset_span (span_mono (set.preimage_mono hy)), }
rw f.range_coe at h‚ÇÅ
rw ‚Üê left_eq_sup at hk
rw [hk, ‚Üê map_le_map_iff, map_span, map_comap_eq, set.image_preimage_eq_of_subset h‚ÇÅ]
exact inf_le_right
simpa using neg_mem p h
simp [algebra_map_inv]
simp only [‚Üê submodule.map_top, ‚Üê span_tmul_eq_top, submodule.map_span, set.mem_image, set.mem_set_of_eq]
ext t
congr
split
use [m, n]
simp only [map_tmul]
rintros ‚ü®_, ‚ü®‚ü®m, n, rfl‚ü©, rfl‚ü©‚ü©
{ rintros ‚ü®_, ‚ü®‚ü®m, n, rfl‚ü©, rfl‚ü©‚ü©, use [m, n], simp only [map_tmul], }
use [m ‚äó‚Çú n, m, n]
simp only [map_tmul]
rintros ‚ü®m, n, rfl‚ü©
by_cases p; simp *
simp *
simp *
by_cases p
by_cases p; simp *
simp *
simp *
by_cases p
cases h with w
cases w
simp [@eq_comm _ a']
rw h
apply_instance
rcases exists_pair_ne Œ≤ with ‚ü®x, y, h‚ü©
rcases hf x with ‚ü®x', hx'‚ü©
rcases hf y with ‚ü®y', hy'‚ü©
contrapose! h
rw [‚Üê hx', ‚Üê hy', h]
have : x' ‚â† y'
exact ‚ü®‚ü®x', y', this‚ü©‚ü©
classical; exact decidable.exists_ne x
exact decidable.exists_ne x
classical
induction hab generalizing c
exact single hac
case refl_trans_gen.refl : c hac { exact single hac }
case refl_trans_gen.tail : d b hab hdb IH { exact tail (IH hdb) hbc }
exact tail (IH hdb) hbc
simpa [refl_trans_gen_idem] using refl_trans_gen_lift f h hab
congr
congr; rw [h x, h y]
rw [h x, h y]
apply_instance
convert set_integral_fun_unique_pi Œπ volume f s
refine absolutely_continuous.mk (Œª s hs h2s, _)
simp_rw [map_apply measurable_fst hs, ‚Üê prod_univ, prod_prod hs measurable_set.univ]
rw [h2s, zero_mul]
rw [dif_pos (nnreal.coe_nonneg r), real.to_nnreal_coe]
have he‚ÇÅ : ‚àÄn, measurable_set (e n) := assume n, (he n).1
have he‚ÇÇ : ‚àÄn, Œ≥ - (1/2)^n < d (e n) := assume n, (he n).2
let f : ‚Ñï ‚Üí ‚Ñï ‚Üí set Œ± := Œªn m, (finset.Ico n (m + 1)).inf e
have hf : ‚àÄn m, measurable_set (f n m)
assume n m
simp only [f, finset.inf_eq_infi]
exact measurable_set.bInter (countable_encodable _) (assume i _, he‚ÇÅ _)
{ assume n m, simp only [f, finset.inf_eq_infi], exact measurable_set.bInter (countable_encodable _) (assume i _, he‚ÇÅ _) }
have f_subset_f : ‚àÄ{a b c d}, a ‚â§ b ‚Üí c ‚â§ d ‚Üí f a d ‚äÜ f b c
assume a b c d hab hcd
dsimp only [f]
rw [finset.inf_eq_infi, finset.inf_eq_infi]
refine bInter_subset_bInter_left _
simp
rintros j ‚ü®hbj, hjc‚ü©
exact ‚ü®le_trans hab hbj, lt_of_lt_of_le hjc $ add_le_add_right hcd 1‚ü©
{ assume a b c d hab hcd, dsimp only [f], rw [finset.inf_eq_infi, finset.inf_eq_infi], refine bInter_subset_bInter_left _, simp, rintros j ‚ü®hbj, hjc‚ü©, exact ‚ü®le_trans hab hbj, lt_of_lt_of_le hjc $ add_le_add_right hcd 1‚ü© }
have f_succ : ‚àÄn m, n ‚â§ m ‚Üí f n (m + 1) = f n m ‚à© e (m + 1)
assume n m hnm
have : n ‚â§ m + 1 := le_of_lt (nat.succ_le_succ hnm)
simp only [f]
rw [finset.Ico.succ_top this, finset.inf_insert, set.inter_comm]
{ assume n m hnm, have : n ‚â§ m + 1 := le_of_lt (nat.succ_le_succ hnm), simp only [f], rw [finset.Ico.succ_top this, finset.inf_insert, set.inter_comm], refl }
refl
have le_d_f : ‚àÄn m, m ‚â§ n ‚Üí Œ≥ - 2 * ((1 / 2) ^ m) + (1 / 2) ^ n ‚â§ d (f m n)
assume n m h
refine nat.le_induction _ _ n h
have := he‚ÇÇ m
simp only [f]
rw [finset.Ico.succ_singleton, finset.inf_singleton]
{ have := he‚ÇÇ m, simp only [f], rw [finset.Ico.succ_singleton, finset.inf_singleton], exact aux this }
exact aux this
assume n (hmn : m ‚â§ n) ih
have : Œ≥ + (Œ≥ - 2 * (1 / 2)^m + (1 / 2) ^ (n + 1)) ‚â§ Œ≥ + d (f m (n + 1))
calc Œ≥ + (Œ≥ - 2 * (1 / 2)^m + (1 / 2) ^ (n+1)) ‚â§ Œ≥ + (Œ≥ - 2 * (1 / 2)^m + ((1 / 2) ^ n - (1/2)^(n+1))) : begin refine add_le_add_left (add_le_add_left _ _) Œ≥, simp only [pow_add, pow_one, le_sub_iff_add_le], linarith end ... = (Œ≥ - (1 / 2)^(n+1)) + (Œ≥ - 2 * (1 / 2)^m + (1 / 2)^n) : by simp only [sub_eq_add_neg]; ac_refl ... ‚â§ d (e (n + 1)) + d (f m n) : add_le_add (le_of_lt $ he‚ÇÇ _) ih ... ‚â§ d (e (n + 1)) + d (f m n \ e (n + 1)) + d (f m (n + 1)) : by rw [f_succ _ _ hmn, d_split (f m n) (e (n + 1)) (hf _ _) (he‚ÇÅ _), add_assoc] ... = d (e (n + 1) ‚à™ f m n) + d (f m (n + 1)) : begin rw [d_split (e (n + 1) ‚à™ f m n) (e (n + 1)), union_diff_left, union_inter_cancel_left], ac_refl, exact (he‚ÇÅ _).union (hf _ _), exact (he‚ÇÅ _) end ... ‚â§ Œ≥ + d (f m (n + 1)) : add_le_add_right (d_le_Œ≥ _ $ (he‚ÇÅ _).union (hf _ _)) _
refine add_le_add_left (add_le_add_left _ _) Œ≥
simp only [pow_add, pow_one, le_sub_iff_add_le]
linarith
simp only [sub_eq_add_neg]
simp only [sub_eq_add_neg]; ac_refl
ac_refl
rw [f_succ _ _ hmn, d_split (f m n) (e (n + 1)) (hf _ _) (he‚ÇÅ _), add_assoc]
rw [d_split (e (n + 1) ‚à™ f m n) (e (n + 1)), union_diff_left, union_inter_cancel_left]
ac_refl
exact (he‚ÇÅ _).union (hf _ _)
exact (he‚ÇÅ _)
{ calc Œ≥ + (Œ≥ - 2 * (1 / 2)^m + (1 / 2) ^ (n+1)) ‚â§ Œ≥ + (Œ≥ - 2 * (1 / 2)^m + ((1 / 2) ^ n - (1/2)^(n+1))) : begin refine add_le_add_left (add_le_add_left _ _) Œ≥, simp only [pow_add, pow_one, le_sub_iff_add_le], linarith end ... = (Œ≥ - (1 / 2)^(n+1)) + (Œ≥ - 2 * (1 / 2)^m + (1 / 2)^n) : by simp only [sub_eq_add_neg]; ac_refl ... ‚â§ d (e (n + 1)) + d (f m n) : add_le_add (le_of_lt $ he‚ÇÇ _) ih ... ‚â§ d (e (n + 1)) + d (f m n \ e (n + 1)) + d (f m (n + 1)) : by rw [f_succ _ _ hmn, d_split (f m n) (e (n + 1)) (hf _ _) (he‚ÇÅ _), add_assoc] ... = d (e (n + 1) ‚à™ f m n) + d (f m (n + 1)) : begin rw [d_split (e (n + 1) ‚à™ f m n) (e (n + 1)), union_diff_left, union_inter_cancel_left], ac_refl, exact (he‚ÇÅ _).union (hf _ _), exact (he‚ÇÅ _) end ... ‚â§ Œ≥ + d (f m (n + 1)) : add_le_add_right (d_le_Œ≥ _ $ (he‚ÇÅ _).union (hf _ _)) _ }
{ assume n m h, refine nat.le_induction _ _ n h, { have := he‚ÇÇ m, simp only [f], rw [finset.Ico.succ_singleton, finset.inf_singleton], exact aux this }, { assume n (hmn : m ‚â§ n) ih, have : Œ≥ + (Œ≥ - 2 * (1 / 2)^m + (1 / 2) ^ (n + 1)) ‚â§ Œ≥ + d (f m (n + 1)), { calc Œ≥ + (Œ≥ - 2 * (1 / 2)^m + (1 / 2) ^ (n+1)) ‚â§ Œ≥ + (Œ≥ - 2 * (1 / 2)^m + ((1 / 2) ^ n - (1/2)^(n+1))) : begin refine add_le_add_left (add_le_add_left _ _) Œ≥, simp only [pow_add, pow_one, le_sub_iff_add_le], linarith end ... = (Œ≥ - (1 / 2)^(n+1)) + (Œ≥ - 2 * (1 / 2)^m + (1 / 2)^n) : by simp only [sub_eq_add_neg]; ac_refl ... ‚â§ d (e (n + 1)) + d (f m n) : add_le_add (le_of_lt $ he‚ÇÇ _) ih ... ‚â§ d (e (n + 1)) + d (f m n \ e (n + 1)) + d (f m (n + 1)) : by rw [f_succ _ _ hmn, d_split (f m n) (e (n + 1)) (hf _ _) (he‚ÇÅ _), add_assoc] ... = d (e (n + 1) ‚à™ f m n) + d (f m (n + 1)) : begin rw [d_split (e (n + 1) ‚à™ f m n) (e (n + 1)), union_diff_left, union_inter_cancel_left], ac_refl, exact (he‚ÇÅ _).union (hf _ _), exact (he‚ÇÅ _) end ... ‚â§ Œ≥ + d (f m (n + 1)) : add_le_add_right (d_le_Œ≥ _ $ (he‚ÇÅ _).union (hf _ _)) _ }, exact (add_le_add_iff_left Œ≥).1 this } }
exact (add_le_add_iff_left Œ≥).1 this
let s := ‚ãÉ m, ‚ãÇn, f m n
have Œ≥_le_d_s : Œ≥ ‚â§ d s
have hŒ≥ : tendsto (Œªm:‚Ñï, Œ≥ - 2 * (1/2)^m) at_top (ùìù Œ≥)
simpa
suffices : tendsto (Œªm:‚Ñï, Œ≥ - 2 * (1/2)^m) at_top (ùìù (Œ≥ - 2 * 0))
{ simpa }
exact (tendsto_const_nhds.sub $ tendsto_const_nhds.mul $ tendsto_pow_at_top_nhds_0_of_lt_1 (le_of_lt $ half_pos $ zero_lt_one) (half_lt_self zero_lt_one))
{ suffices : tendsto (Œªm:‚Ñï, Œ≥ - 2 * (1/2)^m) at_top (ùìù (Œ≥ - 2 * 0)), { simpa }, exact (tendsto_const_nhds.sub $ tendsto_const_nhds.mul $ tendsto_pow_at_top_nhds_0_of_lt_1 (le_of_lt $ half_pos $ zero_lt_one) (half_lt_self zero_lt_one)) }
have hd : tendsto (Œªm, d (‚ãÇn, f m n)) at_top (ùìù (d (‚ãÉ m, ‚ãÇ n, f m n)))
refine d_Union _ _ _
exact measurable_set.Inter (assume m, hf _ _)
{ assume n, exact measurable_set.Inter (assume m, hf _ _) }
assume n
exact assume n m hnm, subset_Inter (assume i, subset.trans (Inter_subset (f n) i) $ f_subset_f hnm $ le_refl _)
{ refine d_Union _ _ _, { assume n, exact measurable_set.Inter (assume m, hf _ _) }, { exact assume n m hnm, subset_Inter (assume i, subset.trans (Inter_subset (f n) i) $ f_subset_f hnm $ le_refl _) } }
refine le_of_tendsto_of_tendsto' hŒ≥ hd (assume m, _)
have : tendsto (Œªn, d (f m n)) at_top (ùìù (d (‚ãÇ n, f m n)))
refine d_Inter _ _ _
exact hf _ _
{ assume n, exact hf _ _ }
assume n
exact f_subset_f (le_refl _) hnm
{ refine d_Inter _ _ _, { assume n, exact hf _ _ }, { assume n m hnm, exact f_subset_f (le_refl _) hnm } }
assume n m hnm
refine ge_of_tendsto this (eventually_at_top.2 ‚ü®m, assume n hmn, _‚ü©)
change Œ≥ - 2 * (1 / 2) ^ m ‚â§ d (f m n)
refine le_trans _ (le_d_f _ _ hmn)
exact le_add_of_le_of_nonneg (le_refl _) (pow_nonneg (le_of_lt $ half_pos $ zero_lt_one) _)
{ have hŒ≥ : tendsto (Œªm:‚Ñï, Œ≥ - 2 * (1/2)^m) at_top (ùìù Œ≥), { suffices : tendsto (Œªm:‚Ñï, Œ≥ - 2 * (1/2)^m) at_top (ùìù (Œ≥ - 2 * 0)), { simpa }, exact (tendsto_const_nhds.sub $ tendsto_const_nhds.mul $ tendsto_pow_at_top_nhds_0_of_lt_1 (le_of_lt $ half_pos $ zero_lt_one) (half_lt_self zero_lt_one)) }, have hd : tendsto (Œªm, d (‚ãÇn, f m n)) at_top (ùìù (d (‚ãÉ m, ‚ãÇ n, f m n))), { refine d_Union _ _ _, { assume n, exact measurable_set.Inter (assume m, hf _ _) }, { exact assume n m hnm, subset_Inter (assume i, subset.trans (Inter_subset (f n) i) $ f_subset_f hnm $ le_refl _) } }, refine le_of_tendsto_of_tendsto' hŒ≥ hd (assume m, _), have : tendsto (Œªn, d (f m n)) at_top (ùìù (d (‚ãÇ n, f m n))), { refine d_Inter _ _ _, { assume n, exact hf _ _ }, { assume n m hnm, exact f_subset_f (le_refl _) hnm } }, refine ge_of_tendsto this (eventually_at_top.2 ‚ü®m, assume n hmn, _‚ü©), change Œ≥ - 2 * (1 / 2) ^ m ‚â§ d (f m n), refine le_trans _ (le_d_f _ _ hmn), exact le_add_of_le_of_nonneg (le_refl _) (pow_nonneg (le_of_lt $ half_pos $ zero_lt_one) _) }
have hs : measurable_set s := measurable_set.Union (assume n, measurable_set.Inter (assume m, hf _ _))
refine ‚ü®s, hs, _, _‚ü©
assume t ht hts
have : 0 ‚â§ d t := ((add_le_add_iff_left Œ≥).1 $ calc Œ≥ + 0 ‚â§ d s : by rw [add_zero]; exact Œ≥_le_d_s ... = d (s \ t) + d t : by rw [d_split _ _ hs ht, inter_eq_self_of_subset_right hts] ... ‚â§ Œ≥ + d t : add_le_add (d_le_Œ≥ _ (hs.diff ht)) (le_refl _))
rw [add_zero]
rw [add_zero]; exact Œ≥_le_d_s
exact Œ≥_le_d_s
rw [d_split _ _ hs ht, inter_eq_self_of_subset_right hts]
rw [‚Üê to_nnreal_Œº, ‚Üê to_nnreal_ŒΩ, ennreal.coe_le_coe, ‚Üê nnreal.coe_le_coe]
simpa only [d, le_sub_iff_add_le, zero_add] using this
{ assume t ht hts, have : 0 ‚â§ d t := ((add_le_add_iff_left Œ≥).1 $ calc Œ≥ + 0 ‚â§ d s : by rw [add_zero]; exact Œ≥_le_d_s ... = d (s \ t) + d t : by rw [d_split _ _ hs ht, inter_eq_self_of_subset_right hts] ... ‚â§ Œ≥ + d t : add_le_add (d_le_Œ≥ _ (hs.diff ht)) (le_refl _)), rw [‚Üê to_nnreal_Œº, ‚Üê to_nnreal_ŒΩ, ennreal.coe_le_coe, ‚Üê nnreal.coe_le_coe], simpa only [d, le_sub_iff_add_le, zero_add] using this }
assume t ht hts
have : d t ‚â§ 0
exact ((add_le_add_iff_left Œ≥).1 $ calc Œ≥ + d t ‚â§ d s + d t : add_le_add Œ≥_le_d_s (le_refl _) ... = d (s ‚à™ t) : begin rw [d_split _ _ (hs.union ht) ht, union_diff_right, union_inter_cancel_right, diff_eq_self.2], exact assume a ‚ü®hat, has‚ü©, hts hat has end ... ‚â§ Œ≥ + 0 : by rw [add_zero]; exact d_le_Œ≥ _ (hs.union ht))
rw [d_split _ _ (hs.union ht) ht, union_diff_right, union_inter_cancel_right, diff_eq_self.2]
exact assume a ‚ü®hat, has‚ü©, hts hat has
rw [add_zero]
rw [add_zero]; exact d_le_Œ≥ _ (hs.union ht)
exact d_le_Œ≥ _ (hs.union ht)
rw [‚Üê to_nnreal_Œº, ‚Üê to_nnreal_ŒΩ, ennreal.coe_le_coe, ‚Üê nnreal.coe_le_coe]
simpa only [d, sub_le_iff_le_add, zero_add] using this
let d : set Œ± ‚Üí ‚Ñù := Œªs, ((Œº s).to_nnreal : ‚Ñù) - (ŒΩ s).to_nnreal
let c : set ‚Ñù := d '' {s | measurable_set s }
let Œ≥ : ‚Ñù := Sup c
have hŒº : ‚àÄ s, Œº s ‚â† ‚àû := measure_ne_top Œº
have hŒΩ : ‚àÄ s, ŒΩ s ‚â† ‚àû := measure_ne_top ŒΩ
have to_nnreal_Œº : ‚àÄs, ((Œº s).to_nnreal : ‚Ñù‚â•0‚àû) = Œº s := (assume s, ennreal.coe_to_nnreal $ hŒº _)
have to_nnreal_ŒΩ : ‚àÄs, ((ŒΩ s).to_nnreal : ‚Ñù‚â•0‚àû) = ŒΩ s := (assume s, ennreal.coe_to_nnreal $ hŒΩ _)
simp [d]
rw [measure_empty, measure_empty]
have d_empty : d ‚àÖ = 0
simp
{ simp [d], rw [measure_empty, measure_empty], simp }
have d_split : ‚àÄs t, measurable_set s ‚Üí measurable_set t ‚Üí d s = d (s \ t) + d (s ‚à© t)
assume s t hs ht
simp only [d]
rw [measure_eq_inter_diff hs ht, measure_eq_inter_diff hs ht, ennreal.to_nnreal_add (hŒº _) (hŒº _), ennreal.to_nnreal_add (hŒΩ _) (hŒΩ _), nnreal.coe_add, nnreal.coe_add]
simp only [sub_eq_add_neg, neg_add]
{ assume s t hs ht, simp only [d], rw [measure_eq_inter_diff hs ht, measure_eq_inter_diff hs ht, ennreal.to_nnreal_add (hŒº _) (hŒº _), ennreal.to_nnreal_add (hŒΩ _) (hŒΩ _), nnreal.coe_add, nnreal.coe_add], simp only [sub_eq_add_neg, neg_add], ac_refl }
ac_refl
have d_Union : ‚àÄ(s : ‚Ñï ‚Üí set Œ±), (‚àÄn, measurable_set (s n)) ‚Üí monotone s ‚Üí tendsto (Œªn, d (s n)) at_top (ùìù (d (‚ãÉn, s n)))
assume s hs hm
refine tendsto.sub _ _; refine (nnreal.tendsto_coe.2 $ (ennreal.tendsto_to_nnreal _).comp $ tendsto_measure_Union hs hm)
refine tendsto.sub _ _
refine (nnreal.tendsto_coe.2 $ (ennreal.tendsto_to_nnreal _).comp $ tendsto_measure_Union hs hm)
refine (nnreal.tendsto_coe.2 $ (ennreal.tendsto_to_nnreal _).comp $ tendsto_measure_Union hs hm)
exact hŒº _
{ assume s hs hm, refine tendsto.sub _ _; refine (nnreal.tendsto_coe.2 $ (ennreal.tendsto_to_nnreal _).comp $ tendsto_measure_Union hs hm), exact hŒº _, exact hŒΩ _ }
exact hŒΩ _
have d_Inter : ‚àÄ(s : ‚Ñï ‚Üí set Œ±), (‚àÄn, measurable_set (s n)) ‚Üí (‚àÄn m, n ‚â§ m ‚Üí s m ‚äÜ s n) ‚Üí tendsto (Œªn, d (s n)) at_top (ùìù (d (‚ãÇn, s n)))
assume s hs hm
refine tendsto.sub _ _; refine (nnreal.tendsto_coe.2 $ (ennreal.tendsto_to_nnreal $ _).comp $ tendsto_measure_Inter hs hm _)
refine tendsto.sub _ _
refine (nnreal.tendsto_coe.2 $ (ennreal.tendsto_to_nnreal $ _).comp $ tendsto_measure_Inter hs hm _)
refine (nnreal.tendsto_coe.2 $ (ennreal.tendsto_to_nnreal $ _).comp $ tendsto_measure_Inter hs hm _)
{ assume s hs hm, refine tendsto.sub _ _; refine (nnreal.tendsto_coe.2 $ (ennreal.tendsto_to_nnreal $ _).comp $ tendsto_measure_Inter hs hm _), exacts [hŒº _, ‚ü®0, hŒº _‚ü©, hŒΩ _, ‚ü®0, hŒΩ _‚ü©] }
exacts [hŒº _, ‚ü®0, hŒº _‚ü©, hŒΩ _, ‚ü®0, hŒΩ _‚ü©]
have bdd_c : bdd_above c
use (Œº univ).to_nnreal
rintros r ‚ü®s, hs, rfl‚ü©
refine le_trans (sub_le_self _ $ nnreal.coe_nonneg _) _
rw [nnreal.coe_le_coe, ‚Üê ennreal.coe_le_coe, to_nnreal_Œº, to_nnreal_Œº]
{ use (Œº univ).to_nnreal, rintros r ‚ü®s, hs, rfl‚ü©, refine le_trans (sub_le_self _ $ nnreal.coe_nonneg _) _, rw [nnreal.coe_le_coe, ‚Üê ennreal.coe_le_coe, to_nnreal_Œº, to_nnreal_Œº], exact measure_mono (subset_univ _) }
exact measure_mono (subset_univ _)
have c_nonempty : c.nonempty := nonempty.image _ ‚ü®_, measurable_set.empty‚ü©
have d_le_Œ≥ : ‚àÄs, measurable_set s ‚Üí d s ‚â§ Œ≥ := assume s hs, le_cSup bdd_c ‚ü®s, hs, rfl‚ü©
have : ‚àÄn:‚Ñï, ‚àÉs : set Œ±, measurable_set s ‚àß Œ≥ - (1/2)^n < d s
assume n
have : Œ≥ - (1/2)^n < Œ≥ := sub_lt_self Œ≥ (pow_pos (half_pos zero_lt_one) n)
rcases exists_lt_of_lt_cSup c_nonempty this with ‚ü®r, ‚ü®s, hs, rfl‚ü©, hlt‚ü©
{ assume n, have : Œ≥ - (1/2)^n < Œ≥ := sub_lt_self Œ≥ (pow_pos (half_pos zero_lt_one) n), rcases exists_lt_of_lt_cSup c_nonempty this with ‚ü®r, ‚ü®s, hs, rfl‚ü©, hlt‚ü©, exact ‚ü®s, hs, hlt‚ü© }
exact ‚ü®s, hs, hlt‚ü©
rcases classical.axiom_of_choice this with ‚ü®e, he‚ü©
change ‚Ñï ‚Üí set Œ± at e
rw [ae_seq_set, compl_compl, measure_to_measurable]
have hf_eq := Œª i, (hf i).ae_eq_mk
simp_rw [filter.eventually_eq, ‚Üêae_all_iff] at hf_eq
exact filter.eventually.and hf_eq hp
simp only [ae_seq, hx, if_true]
rw funext (Œª n, mk_eq_fun_of_mem_ae_seq_set hf hx n)
have h_ss : ae_seq_set hf p ‚äÜ {x | p x (Œª n, f n x)}
rw [‚Üêcompl_compl {x | p x (Œª n, f n x)}, ae_seq_set, set.compl_subset_compl]
refine set.subset.trans (set.compl_subset_compl.mpr _) (subset_to_measurable _ _)
{ rw [‚Üêcompl_compl {x | p x (Œª n, f n x)}, ae_seq_set, set.compl_subset_compl], refine set.subset.trans (set.compl_subset_compl.mpr _) (subset_to_measurable _ _), exact Œª x hx, hx.2, }
exact Œª x hx, hx.2
have hx' := set.mem_of_subset_of_mem h_ss hx
exact hx'
rcases hf with ‚ü®f', h_f'_meas, hff'‚ü©
rcases hg with ‚ü®g', h_g'_meas, hgg'‚ü©
exact ‚ü®f' + g', @measurable.add _ _ _ _ m _ f' g' h_f'_meas h_g'_meas, hff'.add hgg'‚ü©
let g := Lp_meas_to_Lp_trim_lie F' ‚Ñù 1 Œº hm f
have hfg : f = (Lp_meas_to_Lp_trim_lie F' ‚Ñù 1 Œº hm).symm g
simp only [linear_isometry_equiv.symm_apply_apply]
rw hfg
refine @Lp.induction Œ± F' m _ _ _ _ 1 (Œº.trim hm) _ ennreal.coe_ne_top (Œª g : Œ± ‚Üí‚ÇÅ[Œº.trim hm] F', condexp_L1_clm hm Œº ((Lp_meas_to_Lp_trim_lie F' ‚Ñù 1 Œº hm).symm g : Œ± ‚Üí‚ÇÅ[Œº] F') = ‚Üë((Lp_meas_to_Lp_trim_lie F' ‚Ñù 1 Œº hm).symm g)) _ _ _ g
intros c s hs hŒºs
rw [Lp.simple_func.coe_indicator_const, Lp_meas_to_Lp_trim_lie_symm_indicator hs hŒºs.ne c, condexp_L1_clm_indicator_const_Lp]
exact condexp_ind_of_measurable hs ((le_trim hm).trans_lt hŒºs).ne c
{ intros c s hs hŒºs, rw [Lp.simple_func.coe_indicator_const, Lp_meas_to_Lp_trim_lie_symm_indicator hs hŒºs.ne c, condexp_L1_clm_indicator_const_Lp], exact condexp_ind_of_measurable hs ((le_trim hm).trans_lt hŒºs).ne c, }
intros f g hf hg hfg_disj hf_eq hg_eq
rw linear_isometry_equiv.map_add
push_cast
{ intros f g hf hg hfg_disj hf_eq hg_eq, rw linear_isometry_equiv.map_add, push_cast, rw [map_add, hf_eq, hg_eq], }
rw [map_add, hf_eq, hg_eq]
refine is_closed_eq _ _
refine (condexp_L1_clm hm Œº).continuous.comp (continuous_induced_dom.comp _)
{ refine (condexp_L1_clm hm Œº).continuous.comp (continuous_induced_dom.comp _), exact linear_isometry_equiv.continuous _, }
exact linear_isometry_equiv.continuous _
refine continuous_induced_dom.comp _
exact ‚ü®g, hg_meas, ae_eq_of_ae_eq_trim hfg‚ü©
obtain ‚ü®g, hg_meas, hfg‚ü© := hf
suffices : ‚à´ x in set.univ, Œº[f|hm] x ‚àÇŒº = ‚à´ x in set.univ, f x ‚àÇŒº
simp_rw integral_univ at this
exact this
exact set_integral_condexp hf (@measurable_set.univ _ m)
by_cases hf : integrable f Œº
refine (condexp_ae_eq_condexp_L1 _).trans _
rw condexp_L1_smul c f
refine (@condexp_ae_eq_condexp_L1 _ _ _ _ _ _ _ _ m _ _ hm _ f).mp _
refine (coe_fn_smul c (condexp_L1 hm Œº f)).mono (Œª x hx1 hx2, _)
{ refine (condexp_ae_eq_condexp_L1 _).trans _, rw condexp_L1_smul c f, refine (@condexp_ae_eq_condexp_L1 _ _ _ _ _ _ _ _ m _ _ hm _ f).mp _, refine (coe_fn_smul c (condexp_L1 hm Œº f)).mono (Œª x hx1 hx2, _), rw [hx1, pi.smul_apply, pi.smul_apply, hx2], }
rw [hx1, pi.smul_apply, pi.smul_apply, hx2]
by_cases hc : c = 0
{ rw [hc, zero_smul, zero_smul, condexp_zero], }
rw [hc, zero_smul, zero_smul, condexp_zero]
refine (condexp_undef (mt (integrable_smul_iff hc f).mp hf)).trans _
refine (@condexp_undef _ _ _ _ _ _ _ _ _ _ _ hm _ _ hf).mono (Œª x hx, _)
rw [pi.zero_apply, pi.smul_apply, hx, pi.zero_apply, smul_zero]
intro f
ext1
refine ae_eq_trim_of_measurable hm (Lp.measurable _) (Lp.measurable _) _
exact (Lp_meas_subgroup_to_Lp_trim_ae_eq hm _).trans (Lp_trim_to_Lp_meas_subgroup_ae_eq hm _)
rw [Lp.norm_def, snorm_trim hm (Lp.measurable _)]
apply_instance
{ apply_instance, }
swap
rw [snorm_congr_ae (Lp_meas_subgroup_to_Lp_trim_ae_eq hm _), Lp_meas_subgroup_coe, ‚Üê Lp.norm_def]
congr
let f_meas : Lp_meas E' ùïú m p Œº := ‚ü®f, hf_meas‚ü©
simp only [coe_fn_coe_base, subtype.coe_mk]
have hf_f_meas : f =·µê[Œº] f_meas
refine hf_f_meas.trans _
refine Lp_meas.ae_eq_zero_of_forall_set_integral_eq_zero hm f_meas hp_ne_zero hp_ne_top _ _
intros s hs hŒºs
from ae_restrict_of_ae hf_f_meas
have hfg_restrict : f =·µê[Œº.restrict s] f_meas
rw [integrable_on, integrable_congr hfg_restrict.symm]
{ intros s hs hŒºs, have hfg_restrict : f =·µê[Œº.restrict s] f_meas, from ae_restrict_of_ae hf_f_meas, rw [integrable_on, integrable_congr hfg_restrict.symm], exact hf_int_finite s hs hŒºs, }
exact hf_int_finite s hs hŒºs
intros s hs hŒºs
from ae_restrict_of_ae hf_f_meas
have hfg_restrict : f =·µê[Œº.restrict s] f_meas
rw integral_congr_ae hfg_restrict.symm
exact hf_zero s hs hŒºs
exact ‚ü®f', hf'_meas, hfg.symm.trans hff'‚ü©
obtain ‚ü®f', hf'_meas, hff'‚ü© := hf
simp only [has_finite_integral_iff_norm] at *
calc ‚à´‚Åª a, (ennreal.of_real ‚à•f a‚à•) ‚àÇŒº ‚â§ ‚à´‚Åª (a : Œ±), (ennreal.of_real ‚à•g a‚à•) ‚àÇŒº : lintegral_mono_ae (h.mono $ assume a h, of_real_le_of_real h) ... < ‚àû : hg
simp [real.norm_eq_abs, abs_le, abs_nonneg, le_abs_self]
simp_rw [integrable, has_finite_integral, mem_‚Ñíp, snorm_one_eq_lintegral_nnnorm]
refine induction_on‚ÇÇ f g (Œª f hf g hg hfi hgi, _)
simp only [integrable_mk, mk_add_mk] at hfi hgi ‚ä¢
exact hfi.add hgi
exact ne_of_lt (has_finite_integral_coe_fn f)
rw [norm_def, ennreal.of_real_to_real]
change (snorm ‚áë(0 : Œ± ‚Üí‚Çò[Œº] E) p Œº).to_real = 0
simp [snorm_congr_ae ae_eq_fun.coe_fn_zero, snorm_zero]
by_cases hŒº : Œº = 0
by_cases hp : p.to_real‚Åª¬π = 0
{ simpa [hp, hŒº, norm_def] using hC }
simpa [hp, hŒº, norm_def] using hC
{ by_cases hp : p.to_real‚Åª¬π = 0, { simpa [hp, hŒº, norm_def] using hC }, { simp [hŒº, norm_def, real.zero_rpow hp] } }
simp [hŒº, norm_def, real.zero_rpow hp]
let A : ‚Ñù‚â•0 := (measure_univ_nnreal Œº) ^ (p.to_real)‚Åª¬π * ‚ü®C, hC‚ü©
suffices : snorm f p Œº ‚â§ A
{ exact ennreal.to_real_le_coe_of_le_coe this }
exact ennreal.to_real_le_coe_of_le_coe this
convert snorm_le_of_ae_bound hfC
rw [‚Üê coe_measure_univ_nnreal Œº, ennreal.coe_rpow_of_ne_zero (measure_univ_nnreal_pos hŒº).ne', ennreal.coe_mul]
congr
rw max_eq_left hC
apply_instance
by_cases hp_top : p = ‚àû
simp [hp_top, snorm_ess_sup_indicator_const_eq s c hŒºs]
{ simp [hp_top, snorm_ess_sup_indicator_const_eq s c hŒºs], }
exact snorm_indicator_const hs hp hp_top
rw snorm'_lim_eq_lintegral_liminf hp_pos.le h_lim
rw [‚Üêennreal.le_rpow_one_div_iff (by simp [hp_pos] : 0 < 1 / p), one_div_one_div]
simp [hp_pos]
refine (lintegral_liminf_le' (Œª m, ((hf m).ennnorm.pow_const _))).trans_eq _
have h_pow_liminf : at_top.liminf (Œª n, snorm' (f n) p Œº) ^ p = at_top.liminf (Œª n, (snorm' (f n) p Œº) ^ p)
have h_rpow_mono := ennreal.rpow_left_strict_mono_of_pos hp_pos
have h_rpow_surj := (ennreal.rpow_left_bijective hp_pos.ne.symm).2
refine (h_rpow_mono.order_iso_of_surjective _ h_rpow_surj).liminf_apply _ _ _ _
is_bounded_default
is_bounded_default
is_bounded_default
is_bounded_default
{ have h_rpow_mono := ennreal.rpow_left_strict_mono_of_pos hp_pos, have h_rpow_surj := (ennreal.rpow_left_bijective hp_pos.ne.symm).2, refine (h_rpow_mono.order_iso_of_surjective _ h_rpow_surj).liminf_apply _ _ _ _, all_goals { is_bounded_default }, }
all_goals { is_bounded_default }
rw h_pow_liminf
simp_rw [snorm', ‚Üê ennreal.rpow_mul, one_div, inv_mul_cancel hp_pos.ne.symm, ennreal.rpow_one]
refine ‚ü®h_lim_meas, _‚ü©
rw ennreal.tendsto_at_top_zero at h_tendsto
cases (h_tendsto 1 ennreal.zero_lt_one) with N h_tendsto_1
specialize h_tendsto_1 N (le_refl N)
have h_add : f_lim = f_lim - f N + f N
abel
rw h_add
refine lt_of_le_of_lt (snorm_add_le (h_lim_meas.sub (hf N).1) (hf N).1 hp) _
rw ennreal.add_lt_top
split
refine lt_of_le_of_lt _ ennreal.one_lt_top
simp
have h_neg : f_lim - f N = -(f N - f_lim)
{ refine lt_of_le_of_lt _ ennreal.one_lt_top, have h_neg : f_lim - f N = -(f N - f_lim), by simp, rwa [h_neg, snorm_neg], }
rwa [h_neg, snorm_neg]
exact (hf N).2
simp [snorm'_const c hq_pos, measure_univ]
simp [snorm']
have h_le : ‚à´‚Åª (a : Œ±), ‚Üë(nnnorm (f a)) ^ q ‚àÇŒº ‚â§ ‚à´‚Åª (a : Œ±), (snorm_ess_sup f Œº) ^ q ‚àÇŒº
refine lintegral_mono_ae _
have h_nnnorm_le_snorm_ess_sup := coe_nnnorm_ae_le_snorm_ess_sup f Œº
refine h_nnnorm_le_snorm_ess_sup.mono (Œª x hx, ennreal.rpow_le_rpow hx (le_of_lt hq_pos))
{ refine lintegral_mono_ae _, have h_nnnorm_le_snorm_ess_sup := coe_nnnorm_ae_le_snorm_ess_sup f Œº, refine h_nnnorm_le_snorm_ess_sup.mono (Œª x hx, ennreal.rpow_le_rpow hx (le_of_lt hq_pos)), }
rw [snorm', ‚Üêennreal.rpow_one (snorm_ess_sup f Œº)]
nth_rewrite 1 ‚Üêmul_inv_cancel (ne_of_lt hq_pos).symm
rw [ennreal.rpow_mul, one_div, ‚Üêennreal.mul_rpow_of_nonneg _ _ (by simp [hq_pos.le] : 0 ‚â§ q‚Åª¬π)]
simp [hq_pos.le]
refine ennreal.rpow_le_rpow _ (by simp [hq_pos.le])
rwa lintegral_const at h_le
have h_le_Œº := snorm'_le_snorm'_mul_rpow_measure_univ hp0_lt hpq hf
rwa [measure_univ, ennreal.one_rpow, mul_one] at h_le_Œº
simp [measure_univ]
simpa only [integrable_iff_fin_meas_supp] using fin_meas_supp.pair
rcases is_empty_or_nonempty Œ≤; resetI
resetI
resetI
rcases is_empty_or_nonempty Œ≤
{ exact subsingleton.strongly_measurable f, }
exact subsingleton.strongly_measurable f
inhabit Œ≤
exact ‚ü®simple_func.approx_on f hf set.univ (default Œ≤) (set.mem_univ _), Œª x, simple_func.tendsto_approx_on hf (set.mem_univ _) (by simp)‚ü©
simp
rw [Œº.inv.inv_apply hs, Œº.inv_apply, set.inv_inv]
ext1 s hs
exact measurable_inv hs
apply_instance
suffices : map ((Œª z : G √ó G, (z.2, z.2‚Åª¬π * z.1)) ‚àò (Œª z : G √ó G, (z.2, z.2 * z.1))) (Œº.prod ŒΩ) = Œº.prod ŒΩ
ext1 ‚ü®x, y‚ü©
simp
{ convert this, ext1 ‚ü®x, y‚ü©, simp }
convert this
simp_rw [‚Üê map_map (measurable_snd.prod_mk (measurable_snd.inv.mul measurable_fst)) (measurable_snd.prod_mk (measurable_snd.mul measurable_fst)), map_prod_mul_eq_swap hŒº, map_prod_inv_mul_eq_swap hŒΩ]
let S := (homeomorph.shear_mul_right G).to_measurable_equiv
rw [integral_eq_lintegral_of_nonneg_ae _ hfm.ennreal_to_real]
refine hf.mp (eventually_of_forall _)
rw lintegral_congr_ae
rw [lt_top_iff_ne_top] at hx
simp [hx]
{ rw lintegral_congr_ae, refine hf.mp (eventually_of_forall _), intros x hx, rw [lt_top_iff_ne_top] at hx, simp [hx] }
intros x hx
exact (eventually_of_forall $ Œª x, ennreal.to_real_nonneg)
rw L1.norm_def
congr' 1
apply lintegral_congr_ae
filter_upwards [Lp.coe_fn_pos_part f‚ÇÅ, hf.coe_fn_to_L1]
assume a h‚ÇÅ h‚ÇÇ
rw [h‚ÇÅ, h‚ÇÇ, ennreal.of_real]
congr' 1
apply nnreal.eq
simp [real.norm_of_nonneg, le_max_right, real.coe_to_nnreal]
rw L1.norm_def
congr' 1
apply lintegral_congr_ae
filter_upwards [Lp.coe_fn_neg_part f‚ÇÅ, hf.coe_fn_to_L1]
assume a h‚ÇÅ h‚ÇÇ
rw [h‚ÇÅ, h‚ÇÇ, ennreal.of_real]
congr' 1
apply nnreal.eq
simp only [real.norm_of_nonneg, min_le_right, neg_nonneg, real.coe_to_nnreal', subtype.coe_mk]
rw [‚Üê max_neg_neg, coe_nnnorm, neg_zero, real.norm_of_nonneg (le_max_right (-f a) 0)]
rw [eq‚ÇÅ, eq‚ÇÇ, integral, dif_pos]
exact L1.integral_eq_norm_pos_part_sub _
rcases is_compact.exists_bound_of_continuous_on ht hg with ‚ü®C, hC‚ü©
rw [integrable_on, ‚Üê mem_‚Ñíp_one_iff_integrable] at hf ‚ä¢
have : ‚àÄ·µê x ‚àÇ(Œº.restrict s), ‚à•f x * g x‚à• ‚â§ C * ‚à•f x‚à•
filter_upwards [ae_restrict_mem hs]
assume x hx
rw [real.norm_eq_abs, abs_mul, mul_comm, real.norm_eq_abs]
apply mul_le_mul_of_nonneg_right (hC x (hst hx)) (abs_nonneg _)
{ filter_upwards [ae_restrict_mem hs], assume x hx, rw [real.norm_eq_abs, abs_mul, mul_comm, real.norm_eq_abs], apply mul_le_mul_of_nonneg_right (hC x (hst hx)) (abs_nonneg _) }
exact mem_‚Ñíp.of_le_mul hf (hf.ae_measurable.mul ((hg.mono hst).ae_measurable hs)) this
let œÜ := Œª i, Ioi (a i)
have hœÜ : ae_cover (Œº.restrict $ Iic b) l œÜ := ae_cover_Ioi ha
have hfi : ‚àÄ i, integrable_on f (œÜ i) (Œº.restrict $ Iic b)
intro i
rw [integrable_on, measure.restrict_restrict (hœÜ.measurable i)]
{ intro i, rw [integrable_on, measure.restrict_restrict (hœÜ.measurable i)], exact hfi i }
exact hfi i
refine hœÜ.integrable_of_integral_norm_tendsto hcg _ hfm.restrict hfi (h.congr' _)
filter_upwards [ha.eventually (eventually_le_at_bot b)]
intros i hai
rw [interval_integral.integral_of_le hai, measure.restrict_restrict (hœÜ.measurable i)]
refl
{ erw [ae_measurable_indicator_iff, measure.restrict_restrict, Iic_inter_Ioc_of_le], { rw min‚ÇÅ‚ÇÇ, exact (h_int' h‚ÇÄ).1.ae_measurable }, { exact le_max_of_le_right h‚ÇÄ.2 }, exact measurable_set_Iic, exact measurable_set_Iic }
exact measurable_set_Iic
refine eventually_of_forall (Œª (x : Œ±), eventually_of_forall (Œª (t : Œ±), _))
dsimp [indicator]
split_ifs ; simp
simp
simp
{ refine eventually_of_forall (Œª (x : Œ±), eventually_of_forall (Œª (t : Œ±), _)), dsimp [indicator], split_ifs ; simp }
split_ifs
have : ‚àÄ·µê t ‚àÇŒº.restrict (Œô b‚ÇÅ b‚ÇÇ), t < b‚ÇÄ ‚à® b‚ÇÄ < t
apply ae_restrict_of_ae
apply eventually.mono (compl_mem_ae_iff.mpr hb‚ÇÄ)
intros x hx
{ apply ae_restrict_of_ae, apply eventually.mono (compl_mem_ae_iff.mpr hb‚ÇÄ), intros x hx, exact ne.lt_or_lt hx }
exact ne.lt_or_lt hx
apply this.mono
rintros x‚ÇÄ (hx‚ÇÄ | hx‚ÇÄ)
have : ‚àÄ·∂† x in ùìù[Icc b‚ÇÅ b‚ÇÇ] b‚ÇÄ, {t : Œ± | t ‚â§ x}.indicator f x‚ÇÄ = f x‚ÇÄ
apply mem_nhds_within_of_mem_nhds
apply eventually.mono (Ioi_mem_nhds hx‚ÇÄ)
intros x hx
simp [hx.le]
{ apply mem_nhds_within_of_mem_nhds, apply eventually.mono (Ioi_mem_nhds hx‚ÇÄ), intros x hx, simp [hx.le] }
apply continuous_within_at_const.congr_of_eventually_eq this
{ have : ‚àÄ·∂† x in ùìù[Icc b‚ÇÅ b‚ÇÇ] b‚ÇÄ, {t : Œ± | t ‚â§ x}.indicator f x‚ÇÄ = f x‚ÇÄ, { apply mem_nhds_within_of_mem_nhds, apply eventually.mono (Ioi_mem_nhds hx‚ÇÄ), intros x hx, simp [hx.le] }, apply continuous_within_at_const.congr_of_eventually_eq this, simp [hx‚ÇÄ.le] }
simp [hx‚ÇÄ.le]
have : ‚àÄ·∂† x in ùìù[Icc b‚ÇÅ b‚ÇÇ] b‚ÇÄ, {t : Œ± | t ‚â§ x}.indicator f x‚ÇÄ = 0
apply mem_nhds_within_of_mem_nhds
apply eventually.mono (Iio_mem_nhds hx‚ÇÄ)
intros x hx
simp [hx]
{ apply mem_nhds_within_of_mem_nhds, apply eventually.mono (Iio_mem_nhds hx‚ÇÄ), intros x hx, simp [hx] }
apply continuous_within_at_const.congr_of_eventually_eq this
{ have h‚ÇÅ‚ÇÇ : b‚ÇÅ ‚â§ b‚ÇÇ := h‚ÇÄ.1.trans h‚ÇÄ.2, have min‚ÇÅ‚ÇÇ : min b‚ÇÅ b‚ÇÇ = b‚ÇÅ := min_eq_left h‚ÇÅ‚ÇÇ, have h_int' : ‚àÄ {x}, x ‚àà Icc b‚ÇÅ b‚ÇÇ ‚Üí interval_integrable f Œº b‚ÇÅ x, { rintros x ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©, apply h_int.mono_set, apply interval_subset_interval, { exact ‚ü®min_le_of_left_le (min_le_right a b‚ÇÅ), h‚ÇÅ.trans (h‚ÇÇ.trans $ le_max_of_le_right $ le_max_right _ _)‚ü© }, { exact ‚ü®min_le_of_left_le $ (min_le_right _ _).trans h‚ÇÅ, le_max_of_le_right $ h‚ÇÇ.trans $ le_max_right _ _‚ü© } }, have : ‚àÄ b ‚àà Icc b‚ÇÅ b‚ÇÇ, ‚à´ x in a..b, f x ‚àÇŒº = ‚à´ x in a..b‚ÇÅ, f x ‚àÇŒº + ‚à´ x in b‚ÇÅ..b, f x ‚àÇŒº, { rintros b ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©, rw ‚Üê integral_add_adjacent_intervals _ (h_int' ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©), apply h_int.mono_set, apply interval_subset_interval, { exact ‚ü®min_le_of_left_le (min_le_left a b‚ÇÅ), le_max_of_le_right (le_max_left _ _)‚ü© }, { exact ‚ü®min_le_of_left_le (min_le_right _ _), le_max_of_le_right (h‚ÇÅ.trans $ h‚ÇÇ.trans (le_max_right a b‚ÇÇ))‚ü© } }, apply continuous_within_at.congr _ this (this _ h‚ÇÄ), clear this, refine continuous_within_at_const.add _, have : (Œª b, ‚à´ x in b‚ÇÅ..b, f x ‚àÇŒº) =·∂†[ùìù[Icc b‚ÇÅ b‚ÇÇ] b‚ÇÄ] Œª b, ‚à´ x in b‚ÇÅ..b‚ÇÇ, indicator {x | x ‚â§ b} f x ‚àÇ Œº, { apply eventually_eq_of_mem self_mem_nhds_within, exact Œª b b_in, (integral_indicator b_in).symm }, apply continuous_within_at.congr_of_eventually_eq _ this (integral_indicator h‚ÇÄ).symm, have : interval_integrable (Œª x, ‚à•f x‚à•) Œº b‚ÇÅ b‚ÇÇ, from interval_integrable.norm (h_int' $ right_mem_Icc.mpr h‚ÇÅ‚ÇÇ), refine continuous_within_at_of_dominated_interval _ _ _ this _ ; clear this, { apply eventually.mono (self_mem_nhds_within), intros x hx, erw [ae_measurable_indicator_iff, measure.restrict_restrict, Iic_inter_Ioc_of_le], { rw min‚ÇÅ‚ÇÇ, exact (h_int' hx).1.ae_measurable }, { exact le_max_of_le_right hx.2 }, exacts [measurable_set_Iic, measurable_set_Iic] }, { erw [ae_measurable_indicator_iff, measure.restrict_restrict, Iic_inter_Ioc_of_le], { rw min‚ÇÅ‚ÇÇ, exact (h_int' h‚ÇÄ).1.ae_measurable }, { exact le_max_of_le_right h‚ÇÄ.2 }, exact measurable_set_Iic, exact measurable_set_Iic }, { refine eventually_of_forall (Œª (x : Œ±), eventually_of_forall (Œª (t : Œ±), _)), dsimp [indicator], split_ifs ; simp }, { have : ‚àÄ·µê t ‚àÇŒº.restrict (Œô b‚ÇÅ b‚ÇÇ), t < b‚ÇÄ ‚à® b‚ÇÄ < t, { apply ae_restrict_of_ae, apply eventually.mono (compl_mem_ae_iff.mpr hb‚ÇÄ), intros x hx, exact ne.lt_or_lt hx }, apply this.mono, rintros x‚ÇÄ (hx‚ÇÄ | hx‚ÇÄ), { have : ‚àÄ·∂† x in ùìù[Icc b‚ÇÅ b‚ÇÇ] b‚ÇÄ, {t : Œ± | t ‚â§ x}.indicator f x‚ÇÄ = f x‚ÇÄ, { apply mem_nhds_within_of_mem_nhds, apply eventually.mono (Ioi_mem_nhds hx‚ÇÄ), intros x hx, simp [hx.le] }, apply continuous_within_at_const.congr_of_eventually_eq this, simp [hx‚ÇÄ.le] }, { have : ‚àÄ·∂† x in ùìù[Icc b‚ÇÅ b‚ÇÇ] b‚ÇÄ, {t : Œ± | t ‚â§ x}.indicator f x‚ÇÄ = 0, { apply mem_nhds_within_of_mem_nhds, apply eventually.mono (Iio_mem_nhds hx‚ÇÄ), intros x hx, simp [hx] }, apply continuous_within_at_const.congr_of_eventually_eq this, simp [hx‚ÇÄ] } } }
simp [hx‚ÇÄ]
apply continuous_within_at_of_not_mem_closure
rwa [closure_Icc]
exact FTC_filter.nhds_Icc
haveI : fact (x ‚àà set.Icc (min a b) (max a b)) := h
refine (normed_space.eq_iff_forall_dual_eq ‚Ñù).2 (Œª g, _)
rw [‚Üê g.interval_integral_comp_comm f'int, g.map_sub]
exact integral_eq_sub_of_has_deriv_right_of_le_real' hab (g.continuous.comp_continuous_on hcont) (Œª x hx, g.has_fderiv_at.comp_has_deriv_within_at x (hderiv x hx)) (g.integrable_comp ((interval_integrable_iff_integrable_Icc_of_le hab).1 f'int))
simpa only [mul_comm c] using integral_comp_mul_right f hc
simpa only [one_mul, one_smul, inv_one] using integral_comp_sub_mul f one_ne_zero d
by_cases h‚ÇÄ : b‚ÇÄ ‚àà Icc b‚ÇÅ b‚ÇÇ
have h‚ÇÅ‚ÇÇ : b‚ÇÅ ‚â§ b‚ÇÇ := h‚ÇÄ.1.trans h‚ÇÄ.2
have min‚ÇÅ‚ÇÇ : min b‚ÇÅ b‚ÇÇ = b‚ÇÅ := min_eq_left h‚ÇÅ‚ÇÇ
have h_int' : ‚àÄ {x}, x ‚àà Icc b‚ÇÅ b‚ÇÇ ‚Üí interval_integrable f Œº b‚ÇÅ x
rintros x ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
apply h_int.mono_set
apply interval_subset_interval
exact ‚ü®min_le_of_left_le (min_le_right a b‚ÇÅ), h‚ÇÅ.trans (h‚ÇÇ.trans $ le_max_of_le_right $ le_max_right _ _)‚ü©
{ exact ‚ü®min_le_of_left_le (min_le_right a b‚ÇÅ), h‚ÇÅ.trans (h‚ÇÇ.trans $ le_max_of_le_right $ le_max_right _ _)‚ü© }
exact ‚ü®min_le_of_left_le $ (min_le_right _ _).trans h‚ÇÅ, le_max_of_le_right $ h‚ÇÇ.trans $ le_max_right _ _‚ü©
{ rintros x ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©, apply h_int.mono_set, apply interval_subset_interval, { exact ‚ü®min_le_of_left_le (min_le_right a b‚ÇÅ), h‚ÇÅ.trans (h‚ÇÇ.trans $ le_max_of_le_right $ le_max_right _ _)‚ü© }, { exact ‚ü®min_le_of_left_le $ (min_le_right _ _).trans h‚ÇÅ, le_max_of_le_right $ h‚ÇÇ.trans $ le_max_right _ _‚ü© } }
have : ‚àÄ b ‚àà Icc b‚ÇÅ b‚ÇÇ, ‚à´ x in a..b, f x ‚àÇŒº = ‚à´ x in a..b‚ÇÅ, f x ‚àÇŒº + ‚à´ x in b‚ÇÅ..b, f x ‚àÇŒº
rintros b ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
rw ‚Üê integral_add_adjacent_intervals _ (h_int' ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©)
apply h_int.mono_set
apply interval_subset_interval
{ exact ‚ü®min_le_of_left_le (min_le_left a b‚ÇÅ), le_max_of_le_right (le_max_left _ _)‚ü© }
exact ‚ü®min_le_of_left_le (min_le_left a b‚ÇÅ), le_max_of_le_right (le_max_left _ _)‚ü©
exact ‚ü®min_le_of_left_le (min_le_right _ _), le_max_of_le_right (h‚ÇÅ.trans $ h‚ÇÇ.trans (le_max_right a b‚ÇÇ))‚ü©
{ rintros b ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©, rw ‚Üê integral_add_adjacent_intervals _ (h_int' ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©), apply h_int.mono_set, apply interval_subset_interval, { exact ‚ü®min_le_of_left_le (min_le_left a b‚ÇÅ), le_max_of_le_right (le_max_left _ _)‚ü© }, { exact ‚ü®min_le_of_left_le (min_le_right _ _), le_max_of_le_right (h‚ÇÅ.trans $ h‚ÇÇ.trans (le_max_right a b‚ÇÇ))‚ü© } }
clear this
apply continuous_within_at.congr _ this (this _ h‚ÇÄ)
refine continuous_within_at_const.add _
have : (Œª b, ‚à´ x in b‚ÇÅ..b, f x ‚àÇŒº) =·∂†[ùìù[Icc b‚ÇÅ b‚ÇÇ] b‚ÇÄ] Œª b, ‚à´ x in b‚ÇÅ..b‚ÇÇ, indicator {x | x ‚â§ b} f x ‚àÇ Œº
apply eventually_eq_of_mem self_mem_nhds_within
{ apply eventually_eq_of_mem self_mem_nhds_within, exact Œª b b_in, (integral_indicator b_in).symm }
exact Œª b b_in, (integral_indicator b_in).symm
apply continuous_within_at.congr_of_eventually_eq _ this (integral_indicator h‚ÇÄ).symm
have : interval_integrable (Œª x, ‚à•f x‚à•) Œº b‚ÇÅ b‚ÇÇ
from interval_integrable.norm (h_int' $ right_mem_Icc.mpr h‚ÇÅ‚ÇÇ)
refine continuous_within_at_of_dominated_interval _ _ _ this _
refine continuous_within_at_of_dominated_interval _ _ _ this _ ; clear this
clear this
clear this
clear this
clear this
apply eventually.mono (self_mem_nhds_within)
intros x hx
erw [ae_measurable_indicator_iff, measure.restrict_restrict, Iic_inter_Ioc_of_le]
rw min‚ÇÅ‚ÇÇ
{ rw min‚ÇÅ‚ÇÇ, exact (h_int' hx).1.ae_measurable }
exact (h_int' hx).1.ae_measurable
{ exact le_max_of_le_right hx.2 }
exact le_max_of_le_right hx.2
{ apply eventually.mono (self_mem_nhds_within), intros x hx, erw [ae_measurable_indicator_iff, measure.restrict_restrict, Iic_inter_Ioc_of_le], { rw min‚ÇÅ‚ÇÇ, exact (h_int' hx).1.ae_measurable }, { exact le_max_of_le_right hx.2 }, exacts [measurable_set_Iic, measurable_set_Iic] }
exacts [measurable_set_Iic, measurable_set_Iic]
erw [ae_measurable_indicator_iff, measure.restrict_restrict, Iic_inter_Ioc_of_le]
rw min‚ÇÅ‚ÇÇ
{ rw min‚ÇÅ‚ÇÇ, exact (h_int' h‚ÇÄ).1.ae_measurable }
exact (h_int' h‚ÇÄ).1.ae_measurable
{ exact le_max_of_le_right h‚ÇÄ.2 }
exact le_max_of_le_right h‚ÇÄ.2
exact measurable_set_Iic
rw [lintegral_const, measure.restrict_apply_univ]
set c : ‚Ñù‚â•0 ‚Üí ‚Ñù‚â•0‚àû := coe
set F := Œª a:Œ±, ‚®Ün, f n a
have hF : measurable F := measurable_supr hf
refine le_antisymm _ (supr_lintegral_le _)
rw [lintegral_eq_nnreal]
refine supr_le (assume s, supr_le (assume hsf, _))
refine ennreal.le_of_forall_lt_one_mul_le (assume a ha, _)
rcases ennreal.lt_iff_exists_coe.1 ha with ‚ü®r, rfl, ha‚ü©
have ha : r < 1 := ennreal.coe_lt_coe.1 ha
let rs := s.map (Œªa, r * a)
have eq_rs : (const Œ± r : Œ± ‚Üí‚Çõ ‚Ñù‚â•0‚àû) * map c s = rs.map c
exact ennreal.coe_mul.symm
{ ext1 a, exact ennreal.coe_mul.symm }
ext1 a
have eq : ‚àÄp, (rs.map c) ‚Åª¬π' {p} = (‚ãÉn, (rs.map c) ‚Åª¬π' {p} ‚à© {a | p ‚â§ f n a})
assume p
rw [‚Üê inter_Union, ‚Üê inter_univ ((map c rs) ‚Åª¬π' {p})] {occs := occurrences.pos [1]}
refine set.ext (assume x, and_congr_right $ assume hx, (true_iff _).2 _)
simp [p_eq]
{ simp [p_eq] }
by_cases p_eq : p = 0
subst hx
simp at hx
rwa [(‚â†), ‚Üê ennreal.coe_eq_zero]
have : r * s x ‚â† 0
{ rwa [(‚â†), ‚Üê ennreal.coe_eq_zero] }
refine mt _ this
assume h
rw [h, mul_zero]
have : s x ‚â† 0
{ refine mt _ this, assume h, rw [h, mul_zero] }
have : (rs.map c) x < ‚®Ü (n : ‚Ñï), f n x
refine lt_of_lt_of_le (ennreal.coe_lt_coe.2 (_)) (hsf x)
simpa [rs]
suffices : r * s x < 1 * s x
{ refine lt_of_lt_of_le (ennreal.coe_lt_coe.2 (_)) (hsf x), suffices : r * s x < 1 * s x, simpa [rs], exact mul_lt_mul_of_pos_right ha (pos_iff_ne_zero.2 this) }
exact mul_lt_mul_of_pos_right ha (pos_iff_ne_zero.2 this)
rcases lt_supr_iff.1 this with ‚ü®i, hi‚ü©
{ assume p, rw [‚Üê inter_Union, ‚Üê inter_univ ((map c rs) ‚Åª¬π' {p})] {occs := occurrences.pos [1]}, refine set.ext (assume x, and_congr_right $ assume hx, (true_iff _).2 _), by_cases p_eq : p = 0, { simp [p_eq] }, simp at hx, subst hx, have : r * s x ‚â† 0, { rwa [(‚â†), ‚Üê ennreal.coe_eq_zero] }, have : s x ‚â† 0, { refine mt _ this, assume h, rw [h, mul_zero] }, have : (rs.map c) x < ‚®Ü (n : ‚Ñï), f n x, { refine lt_of_lt_of_le (ennreal.coe_lt_coe.2 (_)) (hsf x), suffices : r * s x < 1 * s x, simpa [rs], exact mul_lt_mul_of_pos_right ha (pos_iff_ne_zero.2 this) }, rcases lt_supr_iff.1 this with ‚ü®i, hi‚ü©, exact mem_Union.2 ‚ü®i, le_of_lt hi‚ü© }
exact mem_Union.2 ‚ü®i, le_of_lt hi‚ü©
have mono : ‚àÄr:‚Ñù‚â•0‚àû, monotone (Œªn, (rs.map c) ‚Åª¬π' {r} ‚à© {a | r ‚â§ f n a})
assume r i j h
refine inter_subset_inter (subset.refl _) _
exact le_trans hx (h_mono h x)
{ assume r i j h, refine inter_subset_inter (subset.refl _) _, assume x hx, exact le_trans hx (h_mono h x) }
assume x hx
have h_meas : ‚àÄn, measurable_set {a : Œ± | ‚áë(map c rs) a ‚â§ f n a} := assume n, measurable_set_le (simple_func.measurable _) (hf n)
calc (r:‚Ñù‚â•0‚àû) * (s.map c).lintegral Œº = ‚àë r in (rs.map c).range, r * Œº ((rs.map c) ‚Åª¬π' {r}) : by rw [‚Üê const_mul_lintegral, eq_rs, simple_func.lintegral] ... ‚â§ ‚àë r in (rs.map c).range, r * Œº (‚ãÉn, (rs.map c) ‚Åª¬π' {r} ‚à© {a | r ‚â§ f n a}) : le_of_eq (finset.sum_congr rfl $ assume x hx, by rw ‚Üê eq) ... ‚â§ ‚àë r in (rs.map c).range, (‚®Ün, r * Œº ((rs.map c) ‚Åª¬π' {r} ‚à© {a | r ‚â§ f n a})) : le_of_eq (finset.sum_congr rfl $ assume x hx, begin rw [measure_Union_eq_supr _ (directed_of_sup $ mono x), ennreal.mul_supr], { assume i, refine ((rs.map c).measurable_set_preimage _).inter _, exact hf i measurable_set_Ici } end) ... ‚â§ ‚®Ün, ‚àë r in (rs.map c).range, r * Œº ((rs.map c) ‚Åª¬π' {r} ‚à© {a | r ‚â§ f n a}) : begin refine le_of_eq _, rw [ennreal.finset_sum_supr_nat], assume p i j h, exact mul_le_mul_left' (measure_mono $ mono p h) _ end ... ‚â§ (‚®Ün:‚Ñï, ((rs.map c).restrict {a | (rs.map c) a ‚â§ f n a}).lintegral Œº) : begin refine supr_le_supr (assume n, _), rw [restrict_lintegral _ (h_meas n)], { refine le_of_eq (finset.sum_congr rfl $ assume r hr, _), congr' 2 with a, refine and_congr_right _, simp {contextual := tt} } end ... ‚â§ (‚®Ün, ‚à´‚Åª a, f n a ‚àÇŒº) : begin refine supr_le_supr (assume n, _), rw [‚Üê simple_func.lintegral_eq_lintegral], refine lintegral_mono (assume a, _), simp only [map_apply] at h_meas, simp only [coe_map, restrict_apply _ (h_meas _), (‚àò)], exact indicator_apply_le id, end
rw [‚Üê const_mul_lintegral, eq_rs, simple_func.lintegral]
rw ‚Üê eq
rw [measure_Union_eq_supr _ (directed_of_sup $ mono x), ennreal.mul_supr]
assume i
refine ((rs.map c).measurable_set_preimage _).inter _
exact hf i measurable_set_Ici
refine le_of_eq _
rw [ennreal.finset_sum_supr_nat]
assume p i j h
exact mul_le_mul_left' (measure_mono $ mono p h) _
refine supr_le_supr (assume n, _)
rw [restrict_lintegral _ (h_meas n)]
refine le_of_eq (finset.sum_congr rfl $ assume r hr, _)
congr' 2 with a
refine and_congr_right _
simp {contextual := tt}
refine supr_le_supr (assume n, _)
rw [‚Üê simple_func.lintegral_eq_lintegral]
refine lintegral_mono (assume a, _)
simp only [map_apply] at h_meas
simp only [coe_map, restrict_apply _ (h_meas _), (‚àò)]
exact indicator_apply_le id
simp only [supr_eapprox_apply, hf, hg]
funext a
congr
refl
{ refl }
rw [ennreal.supr_add_supr_of_monotone]
exact monotone_eapprox _ h a
{ assume i j h, exact monotone_eapprox _ h a }
assume i j h
exact monotone_eapprox _ h a
assume i j h
rw [lintegral_supr]
congr
rw [‚Üê simple_func.add_lintegral, ‚Üê simple_func.lintegral_eq_lintegral]
funext n
{ congr, funext n, rw [‚Üê simple_func.add_lintegral, ‚Üê simple_func.lintegral_eq_lintegral], refl }
refl
{ measurability, }
measurability
exact add_le_add (monotone_eapprox _ h _) (monotone_eapprox _ h _)
assume i j h a
refine (ennreal.supr_add_supr_of_monotone _ _).symm; { assume i j h, exact simple_func.lintegral_mono (monotone_eapprox _ h) (le_refl Œº) }
refine (ennreal.supr_add_supr_of_monotone _ _).symm
exact simple_func.lintegral_mono (monotone_eapprox _ h) (le_refl Œº)
assume i j h
rw [lintegral_eq_supr_eapprox_lintegral hf, lintegral_eq_supr_eapprox_lintegral hg]
rwa [with_density_apply _ measurable_set.univ, measure.restrict_univ, lt_top_iff_ne_top]
set S : set Œ± := { x | f x < 0 } with hSdef
have hS : measurable_set S := measurable_set_lt hf measurable_const
refine ‚ü®S, hS, _, _‚ü©
rw [with_density_apply _ hS, hSdef]
have hf0 : ‚àÄ·µê x ‚àÇŒº, x ‚àà S ‚Üí ennreal.of_real (f x) = 0
refine ae_of_all _ (Œª _ hx, _)
{ refine ae_of_all _ (Œª _ hx, _), rw [ennreal.of_real_eq_zero.2 (le_of_lt hx)] }
rw [ennreal.of_real_eq_zero.2 (le_of_lt hx)]
rw set_lintegral_congr_fun hS hf0
{ rw [with_density_apply _ hS, hSdef], have hf0 : ‚àÄ·µê x ‚àÇŒº, x ‚àà S ‚Üí ennreal.of_real (f x) = 0, { refine ae_of_all _ (Œª _ hx, _), rw [ennreal.of_real_eq_zero.2 (le_of_lt hx)] }, rw set_lintegral_congr_fun hS hf0, exact lintegral_zero }
exact lintegral_zero
rw [with_density_apply _ hS.compl, hSdef]
have hf0 : ‚àÄ·µê x ‚àÇŒº, x ‚àà S·∂ú ‚Üí ennreal.of_real (-f x) = 0
refine ae_of_all _ (Œª x hx, _)
rw ennreal.of_real_eq_zero.2
{ refine ae_of_all _ (Œª x hx, _), rw ennreal.of_real_eq_zero.2, rwa [neg_le, neg_zero, ‚Üê not_lt] }
rwa [neg_le, neg_zero, ‚Üê not_lt]
rw set_lintegral_congr_fun hS.compl hf0
exact lintegral_zero
simp only [coe_range, sep_mem_eq, set.mem_range, function.comp_app, coe_map, finset.coe_filter, ‚Üê mem_preimage, inter_comm, preimage_inter_range]
apply preimage_comp
simp only [coe_restrict _ hs, indicator_le_indicator (H x)]
simp only [restrict_of_not_measurable hs, le_refl]
rw ‚Üê@lintegral_zero_fun Œ± _ Œº
refine lintegral_congr_ae _
suffices h_mul_zero : f * g =·µê[Œº] 0 * g
rwa zero_mul at h_mul_zero
from ae_eq_zero_of_lintegral_rpow_eq_zero hp0_lt hf hf_zero
have hf_eq_zero : f =·µê[Œº] 0
exact filter.eventually_eq.mul hf_eq_zero (ae_eq_refl g)
rw ‚Üê integral_add_compl h_meas hfi.norm
congr' 1
refine set_integral_congr h_meas (Œª x hx, _)
dsimp only
rw [real.norm_eq_abs, abs_eq_self.mpr _]
exact hx
congr' 1
rw ‚Üê integral_neg
refine set_integral_congr h_meas.compl (Œª x hx, _)
dsimp only
rw [real.norm_eq_abs, abs_eq_neg_self.mpr _]
rw [set.mem_compl_iff, set.nmem_set_of_eq] at hx
linarith
congr
ext1 x
rw ‚Üê set_integral_neg_eq_set_integral_nonpos hf hfi
simp
intro f
rw one_mul
exact norm_Lp_to_Lp_restrict_le s f
rw [set_to_L1s, norm_eq_sum_mul f]
exact simple_func.norm_set_to_simple_func_le_sum_mul_norm T hT_norm _
simp only [simple_func.coe_const, simple_func.const_zero, simple_func.coe_zero, set.piecewise_eq_indicator, simple_func.coe_piecewise]
{ refine ‚ü®Œª x, c, Œª x, _, lower_semicontinuous_const, by simp only [ennreal.top_add, le_top, h]‚ü©, simp only [simple_func.coe_const, simple_func.const_zero, simple_func.coe_zero, set.piecewise_eq_indicator, simple_func.coe_piecewise], exact set.indicator_le_self _ _ _ }
exact set.indicator_le_self _ _ _
by_cases hc : c = 0
refine ‚ü®Œª x, 0, _, lower_semicontinuous_const, _‚ü©
simp only [hc, set.indicator_zero', pi.zero_apply, simple_func.const_zero, implies_true_iff, eq_self_iff_true, simple_func.coe_zero, set.piecewise_eq_indicator, simple_func.coe_piecewise, le_zero_iff]
{ simp only [hc, set.indicator_zero', pi.zero_apply, simple_func.const_zero, implies_true_iff, eq_self_iff_true, simple_func.coe_zero, set.piecewise_eq_indicator, simple_func.coe_piecewise, le_zero_iff] }
{ refine ‚ü®Œª x, 0, _, lower_semicontinuous_const, _‚ü©, { simp only [hc, set.indicator_zero', pi.zero_apply, simple_func.const_zero, implies_true_iff, eq_self_iff_true, simple_func.coe_zero, set.piecewise_eq_indicator, simple_func.coe_piecewise, le_zero_iff] }, { simp only [lintegral_const, zero_mul, zero_le, ennreal.coe_zero] } }
simp only [lintegral_const, zero_mul, zero_le, ennreal.coe_zero]
have : Œº s < Œº s + Œµ / c
have : (0 : ‚Ñù‚â•0‚àû) < Œµ / c := ennreal.div_pos_iff.2 ‚ü®Œµ0, ennreal.coe_ne_top‚ü©
simpa using ennreal.add_lt_add_left _ this
simpa only [hs, hc, lt_top_iff_ne_top, true_and, simple_func.coe_const, function.const_apply, lintegral_const, ennreal.coe_indicator, set.univ_inter, ennreal.coe_ne_top, measurable_set.univ, with_top.mul_eq_top_iff, simple_func.const_zero, or_false, lintegral_indicator, ennreal.coe_eq_zero, ne.def, not_false_iff, simple_func.coe_zero, set.piecewise_eq_indicator, simple_func.coe_piecewise, false_and, restrict_apply] using h
{ have : (0 : ‚Ñù‚â•0‚àû) < Œµ / c := ennreal.div_pos_iff.2 ‚ü®Œµ0, ennreal.coe_ne_top‚ü©, simpa using ennreal.add_lt_add_left _ this, simpa only [hs, hc, lt_top_iff_ne_top, true_and, simple_func.coe_const, function.const_apply, lintegral_const, ennreal.coe_indicator, set.univ_inter, ennreal.coe_ne_top, measurable_set.univ, with_top.mul_eq_top_iff, simple_func.const_zero, or_false, lintegral_indicator, ennreal.coe_eq_zero, ne.def, not_false_iff, simple_func.coe_zero, set.piecewise_eq_indicator, simple_func.coe_piecewise, false_and, restrict_apply] using h }
obtain ‚ü®u, su, u_open, Œºu‚ü© : ‚àÉ u ‚äá s, is_open u ‚àß Œº u < Œº s + Œµ / c := s.exists_is_open_lt_of_lt _ this
refine ‚ü®set.indicator u (Œª x, c), Œª x, _, u_open.lower_semicontinuous_indicator (zero_le _), _‚ü©
simp only [simple_func.coe_const, simple_func.const_zero, simple_func.coe_zero, set.piecewise_eq_indicator, simple_func.coe_piecewise]
{ simp only [simple_func.coe_const, simple_func.const_zero, simple_func.coe_zero, set.piecewise_eq_indicator, simple_func.coe_piecewise], exact set.indicator_le_indicator_of_subset su (Œª x, zero_le _) _ }
exact set.indicator_le_indicator_of_subset su (Œª x, zero_le _) _
suffices : (c : ‚Ñù‚â•0‚àû) * Œº u ‚â§ c * Œº s + Œµ
simpa only [hs, u_open.measurable_set, simple_func.coe_const, function.const_apply, lintegral_const, ennreal.coe_indicator, set.univ_inter, measurable_set.univ, simple_func.const_zero, lintegral_indicator, simple_func.coe_zero, set.piecewise_eq_indicator, simple_func.coe_piecewise, restrict_apply]
calc (c : ‚Ñù‚â•0‚àû) * Œº u ‚â§ c * (Œº s + Œµ / c) : ennreal.mul_le_mul (le_refl _) Œºu.le ... = c * Œº s + Œµ : begin simp_rw [mul_add], rw ennreal.mul_div_cancel' _ ennreal.coe_ne_top, simpa using hc, end
simp_rw [mul_add]
rw ennreal.mul_div_cancel' _ ennreal.coe_ne_top
simpa using hc
{ let f := simple_func.piecewise s hs (simple_func.const Œ± c) (simple_func.const Œ± 0), by_cases h : ‚à´‚Åª x, f x ‚àÇŒº = ‚ä§, { refine ‚ü®Œª x, c, Œª x, _, lower_semicontinuous_const, by simp only [ennreal.top_add, le_top, h]‚ü©, simp only [simple_func.coe_const, simple_func.const_zero, simple_func.coe_zero, set.piecewise_eq_indicator, simple_func.coe_piecewise], exact set.indicator_le_self _ _ _ }, by_cases hc : c = 0, { refine ‚ü®Œª x, 0, _, lower_semicontinuous_const, _‚ü©, { simp only [hc, set.indicator_zero', pi.zero_apply, simple_func.const_zero, implies_true_iff, eq_self_iff_true, simple_func.coe_zero, set.piecewise_eq_indicator, simple_func.coe_piecewise, le_zero_iff] }, { simp only [lintegral_const, zero_mul, zero_le, ennreal.coe_zero] } }, have : Œº s < Œº s + Œµ / c, { have : (0 : ‚Ñù‚â•0‚àû) < Œµ / c := ennreal.div_pos_iff.2 ‚ü®Œµ0, ennreal.coe_ne_top‚ü©, simpa using ennreal.add_lt_add_left _ this, simpa only [hs, hc, lt_top_iff_ne_top, true_and, simple_func.coe_const, function.const_apply, lintegral_const, ennreal.coe_indicator, set.univ_inter, ennreal.coe_ne_top, measurable_set.univ, with_top.mul_eq_top_iff, simple_func.const_zero, or_false, lintegral_indicator, ennreal.coe_eq_zero, ne.def, not_false_iff, simple_func.coe_zero, set.piecewise_eq_indicator, simple_func.coe_piecewise, false_and, restrict_apply] using h }, obtain ‚ü®u, su, u_open, Œºu‚ü© : ‚àÉ u ‚äá s, is_open u ‚àß Œº u < Œº s + Œµ / c := s.exists_is_open_lt_of_lt _ this, refine ‚ü®set.indicator u (Œª x, c), Œª x, _, u_open.lower_semicontinuous_indicator (zero_le _), _‚ü©, { simp only [simple_func.coe_const, simple_func.const_zero, simple_func.coe_zero, set.piecewise_eq_indicator, simple_func.coe_piecewise], exact set.indicator_le_indicator_of_subset su (Œª x, zero_le _) _ }, { suffices : (c : ‚Ñù‚â•0‚àû) * Œº u ‚â§ c * Œº s + Œµ, by simpa only [hs, u_open.measurable_set, simple_func.coe_const, function.const_apply, lintegral_const, ennreal.coe_indicator, set.univ_inter, measurable_set.univ, simple_func.const_zero, lintegral_indicator, simple_func.coe_zero, set.piecewise_eq_indicator, simple_func.coe_piecewise, restrict_apply], calc (c : ‚Ñù‚â•0‚àû) * Œº u ‚â§ c * (Œº s + Œµ / c) : ennreal.mul_le_mul (le_refl _) Œºu.le ... = c * Œº s + Œµ : begin simp_rw [mul_add], rw ennreal.mul_div_cancel' _ ennreal.coe_ne_top, simpa using hc, end } }
rcases h‚ÇÅ (ennreal.half_pos Œµ0).ne' with ‚ü®g‚ÇÅ, f‚ÇÅ_le_g‚ÇÅ, g‚ÇÅcont, g‚ÇÅint‚ü©
rcases h‚ÇÇ (ennreal.half_pos Œµ0).ne' with ‚ü®g‚ÇÇ, f‚ÇÇ_le_g‚ÇÇ, g‚ÇÇcont, g‚ÇÇint‚ü©
refine ‚ü®Œª x, g‚ÇÅ x + g‚ÇÇ x, Œª x, add_le_add (f‚ÇÅ_le_g‚ÇÅ x) (f‚ÇÇ_le_g‚ÇÇ x), g‚ÇÅcont.add g‚ÇÇcont, _‚ü©
simp only [simple_func.coe_add, ennreal.coe_add, pi.add_apply]
rw [lintegral_add f‚ÇÅ.measurable.coe_nnreal_ennreal f‚ÇÇ.measurable.coe_nnreal_ennreal, lintegral_add g‚ÇÅcont.measurable.coe_nnreal_ennreal g‚ÇÇcont.measurable.coe_nnreal_ennreal]
convert add_le_add g‚ÇÅint g‚ÇÇint using 1
rw ‚Üê ennreal.add_halves Œµ
conv_lhs { rw ‚Üê ennreal.add_halves Œµ }
abel
induction f using measure_theory.simple_func.induction with c s hs f‚ÇÅ f‚ÇÇ H h‚ÇÅ h‚ÇÇ generalizing Œµ
let f := simple_func.piecewise s hs (simple_func.const Œ± c) (simple_func.const Œ± 0)
by_cases h : ‚à´‚Åª x, f x ‚àÇŒº = ‚ä§
refine ‚ü®Œª x, c, Œª x, _, lower_semicontinuous_const, by simp only [ennreal.top_add, le_top, h]‚ü©
simp only [ennreal.top_add, le_top, h]
simpa using (@measurable_set.empty Œ± _).compl
simp only [join_apply hs]; exact measurable_lintegral (measurable_coe hs)
exact measurable_lintegral (measurable_coe hs)
simp only [join_apply hs]
haveI : locally_compact_space G := K‚ÇÄ.locally_compact_space_of_group
rw [haar_measure_apply K‚ÇÄ.2.1.measurable_set, ennreal.div_self]
exact haar_content_outer_measure_self_pos
rw [‚Üê pos_iff_ne_zero]
{ rw [‚Üê pos_iff_ne_zero], exact haar_content_outer_measure_self_pos }
exact ne_of_lt (content.outer_measure_lt_top_of_is_compact _ K‚ÇÄ.2.1)
rw interior_pi_set
simp only [interior_Icc, univ_pi_nonempty_iff, nonempty_Ioo, implies_true_iff, zero_lt_one]
classical
induction I using finset.induction_on with i I hiI ihI hI
simp
{ simp }
simp only [finset.mem_insert] at hI
rw [finset.set_bUnion_insert, hm, ihI, finset.sum_insert hiI]
exacts [Œª i hi j hj hij, (hI i (or.inr hi) j (or.inr hj) hij), is_metric_separated.finset_Union_right (Œª j hj, hI i (or.inl rfl) j (or.inr hj) (ne_of_mem_of_not_mem hj hiI).symm)]
rw [‚Üê map_coe_Ioi_at_bot, tendsto_map'_iff]
simp only [mk_metric', outer_measure.supr_apply, supr_subtype']
exact tendsto_at_bot_supr (Œª r r' hr, mono_pre _ hr _)
push_neg at H
by_contra H
suffices : ‚àÄ (c : ‚Ñù‚â•0), c ‚â† 0 ‚Üí ŒºH[d‚ÇÇ] s ‚â§ c * ŒºH[d‚ÇÅ] s
rcases ennreal.exists_nnreal_pos_mul_lt H.2 H.1 with ‚ü®c, hc0, hc‚ü©
{ rcases ennreal.exists_nnreal_pos_mul_lt H.2 H.1 with ‚ü®c, hc0, hc‚ü©, exact hc.not_le (this c (pos_iff_ne_zero.1 hc0)) }
exact hc.not_le (this c (pos_iff_ne_zero.1 hc0))
intros c hc
refine le_iff'.1 (mk_metric_mono_smul ennreal.coe_ne_top (by exact_mod_cast hc) _) s
exact_mod_cast hc
have : 0 < (c ^ (d‚ÇÇ - d‚ÇÅ)‚Åª¬π : ‚Ñù‚â•0‚àû)
rw [ennreal.coe_rpow_of_ne_zero hc, pos_iff_ne_zero, ne.def, ennreal.coe_eq_zero, nnreal.rpow_eq_zero_iff]
{ rw [ennreal.coe_rpow_of_ne_zero hc, pos_iff_ne_zero, ne.def, ennreal.coe_eq_zero, nnreal.rpow_eq_zero_iff], exact mt and.left hc }
exact mt and.left hc
filter_upwards [Ioo_mem_nhds_within_Ioi ‚ü®le_rfl, this‚ü©]
rintro r ‚ü®hr‚ÇÄ, hrc‚ü©
lift r to ‚Ñù‚â•0 using ne_top_of_lt hrc
rw [pi.smul_apply, smul_eq_mul, ‚Üê ennreal.div_le_iff_le_mul (or.inr ennreal.coe_ne_top) (or.inr $ mt ennreal.coe_eq_zero.1 hc), ‚Üê ennreal.rpow_sub _ _ hr‚ÇÄ.ne' ennreal.coe_ne_top]
refine (ennreal.rpow_lt_rpow hrc (sub_pos.2 h)).le.trans _
rw [‚Üê ennreal.rpow_mul, inv_mul_cancel (sub_pos.2 h).ne', ennreal.rpow_one]
exact le_rfl
classical
refine (pi_eq_generate_from (Œª i, real.borel_eq_generate_from_Ioo_rat.symm) (Œª i, real.is_pi_system_Ioo_rat) (Œª i, real.finite_spanning_sets_in_Ioo_rat _) _).symm
simp only [mem_Union, mem_singleton_iff]
intros s hs
choose a b H using hs
obtain rfl : s = Œª i, Ioo (a i) (b i)
from funext (Œª i, (H i).2)
replace H := Œª i, (H i).1
apply le_antisymm _
have Hle : volume ‚â§ (ŒºH[fintype.card Œπ] : measure (Œπ ‚Üí ‚Ñù))
refine le_hausdorff_measure _ _ ‚àû ennreal.coe_lt_top (Œª s h‚ÇÅ h‚ÇÇ, _)
rw [ennreal.rpow_nat_cast]
{ refine le_hausdorff_measure _ _ ‚àû ennreal.coe_lt_top (Œª s h‚ÇÅ h‚ÇÇ, _), rw [ennreal.rpow_nat_cast], exact real.volume_pi_le_diam_pow s }
exact real.volume_pi_le_diam_pow s
rw [‚Üê volume_pi_pi (Œª i, Ioo (a i : ‚Ñù) (b i)) (Œª i, measurable_set_Ioo)]
{ have Hle : volume ‚â§ (ŒºH[fintype.card Œπ] : measure (Œπ ‚Üí ‚Ñù)), { refine le_hausdorff_measure _ _ ‚àû ennreal.coe_lt_top (Œª s h‚ÇÅ h‚ÇÇ, _), rw [ennreal.rpow_nat_cast], exact real.volume_pi_le_diam_pow s }, rw [‚Üê volume_pi_pi (Œª i, Ioo (a i : ‚Ñù) (b i)) (Œª i, measurable_set_Ioo)], exact measure.le_iff'.1 Hle _ }
exact measure.le_iff'.1 Hle _
have I : ‚àÄ i, 0 ‚â§ (b i : ‚Ñù) - a i := Œª i, by simpa only [sub_nonneg, rat.cast_le] using (H i).le
simpa only [sub_nonneg, rat.cast_le] using (H i).le
let Œ≥ := Œª (n : ‚Ñï), (Œ† (i : Œπ), fin ‚åà((b i : ‚Ñù) - a i) * n‚åâ‚Çä)
let t : Œ† (n : ‚Ñï), Œ≥ n ‚Üí set (Œπ ‚Üí ‚Ñù) := Œª n f, set.pi univ (Œª i, Icc (a i + f i / n) (a i + (f i + 1) / n))
have A : tendsto (Œª (n : ‚Ñï), 1/(n : ‚Ñù‚â•0‚àû)) at_top (ùìù 0)
simp only [one_div, ennreal.tendsto_inv_nat_nhds_zero]
have B : ‚àÄ·∂† n in at_top, ‚àÄ (i : Œ≥ n), diam (t n i) ‚â§ 1 / n
apply eventually_at_top.2 ‚ü®1, Œª n hn, _‚ü©
assume f
apply diam_pi_le_of_le (Œª b, _)
simp only [real.ediam_Icc, add_div, ennreal.of_real_div_of_pos (nat.cast_pos.mpr hn), le_refl, add_sub_add_left_eq_sub, add_sub_cancel', ennreal.of_real_one, ennreal.of_real_coe_nat]
{ apply eventually_at_top.2 ‚ü®1, Œª n hn, _‚ü©, assume f, apply diam_pi_le_of_le (Œª b, _), simp only [real.ediam_Icc, add_div, ennreal.of_real_div_of_pos (nat.cast_pos.mpr hn), le_refl, add_sub_add_left_eq_sub, add_sub_cancel', ennreal.of_real_one, ennreal.of_real_coe_nat] }
have C : ‚àÄ·∂† n in at_top, set.pi univ (Œª (i : Œπ), Ioo (a i : ‚Ñù) (b i)) ‚äÜ ‚ãÉ (i : Œ≥ n), t n i
apply eventually_at_top.2 ‚ü®1, Œª n hn, _‚ü©
have npos : (0 : ‚Ñù) < n := nat.cast_pos.2 hn
assume x hx
simp only [mem_Ioo, mem_univ_pi] at hx
simp only [mem_Union, mem_Ioo, mem_univ_pi, coe_coe]
let f : Œ≥ n := Œª i, ‚ü®‚åä(x i - a i) * n‚åã‚Çä, begin apply nat_floor_lt_nat_ceil_of_lt_of_pos, { refine (mul_lt_mul_right npos).2 _, simp only [(hx i).right, sub_lt_sub_iff_right] }, { refine mul_pos _ npos, simpa only [rat.cast_lt, sub_pos] using H i } end‚ü©
apply nat_floor_lt_nat_ceil_of_lt_of_pos
refine (mul_lt_mul_right npos).2 _
{ refine (mul_lt_mul_right npos).2 _, simp only [(hx i).right, sub_lt_sub_iff_right] }
simp only [(hx i).right, sub_lt_sub_iff_right]
refine mul_pos _ npos
simpa only [rat.cast_lt, sub_pos] using H i
refine ‚ü®f, Œª i, ‚ü®_, _‚ü©‚ü©
calc (a i : ‚Ñù) + ‚åä(x i - a i) * n‚åã‚Çä / n ‚â§ (a i : ‚Ñù) + ((x i - a i) * n) / n : begin refine add_le_add le_rfl ((div_le_div_right npos).2 _), exact nat_floor_le (mul_nonneg (sub_nonneg.2 (hx i).1.le) npos.le), end ... = x i : by field_simp [npos.ne']
refine add_le_add le_rfl ((div_le_div_right npos).2 _)
exact nat_floor_le (mul_nonneg (sub_nonneg.2 (hx i).1.le) npos.le)
field_simp [npos.ne']
{ calc (a i : ‚Ñù) + ‚åä(x i - a i) * n‚åã‚Çä / n ‚â§ (a i : ‚Ñù) + ((x i - a i) * n) / n : begin refine add_le_add le_rfl ((div_le_div_right npos).2 _), exact nat_floor_le (mul_nonneg (sub_nonneg.2 (hx i).1.le) npos.le), end ... = x i : by field_simp [npos.ne'] }
calc x i = (a i : ‚Ñù) + ((x i - a i) * n) / n : by field_simp [npos.ne'] ... ‚â§ (a i : ‚Ñù) + (‚åä(x i - a i) * n‚åã‚Çä + 1) / n : add_le_add le_rfl ((div_le_div_right npos).2 (lt_nat_floor_add_one _).le)
field_simp [npos.ne']
{ apply eventually_at_top.2 ‚ü®1, Œª n hn, _‚ü©, have npos : (0 : ‚Ñù) < n := nat.cast_pos.2 hn, assume x hx, simp only [mem_Ioo, mem_univ_pi] at hx, simp only [mem_Union, mem_Ioo, mem_univ_pi, coe_coe], let f : Œ≥ n := Œª i, ‚ü®‚åä(x i - a i) * n‚åã‚Çä, begin apply nat_floor_lt_nat_ceil_of_lt_of_pos, { refine (mul_lt_mul_right npos).2 _, simp only [(hx i).right, sub_lt_sub_iff_right] }, { refine mul_pos _ npos, simpa only [rat.cast_lt, sub_pos] using H i } end‚ü©, refine ‚ü®f, Œª i, ‚ü®_, _‚ü©‚ü©, { calc (a i : ‚Ñù) + ‚åä(x i - a i) * n‚åã‚Çä / n ‚â§ (a i : ‚Ñù) + ((x i - a i) * n) / n : begin refine add_le_add le_rfl ((div_le_div_right npos).2 _), exact nat_floor_le (mul_nonneg (sub_nonneg.2 (hx i).1.le) npos.le), end ... = x i : by field_simp [npos.ne'] }, { calc x i = (a i : ‚Ñù) + ((x i - a i) * n) / n : by field_simp [npos.ne'] ... ‚â§ (a i : ‚Ñù) + (‚åä(x i - a i) * n‚åã‚Çä + 1) / n : add_le_add le_rfl ((div_le_div_right npos).2 (lt_nat_floor_add_one _).le) } }
calc ŒºH[fintype.card Œπ] (set.pi univ (Œª (i : Œπ), Ioo (a i : ‚Ñù) (b i))) ‚â§ liminf at_top (Œª (n : ‚Ñï), ‚àë (i : Œ≥ n), diam (t n i) ^ ‚Üë(fintype.card Œπ)) : hausdorff_measure_le_liminf_sum _ (set.pi univ (Œª i, Ioo (a i : ‚Ñù) (b i))) (Œª (n : ‚Ñï), 1/(n : ‚Ñù‚â•0‚àû)) A t B C ... ‚â§ liminf at_top (Œª (n : ‚Ñï), ‚àë (i : Œ≥ n), (1/n) ^ (fintype.card Œπ)) : begin refine liminf_le_liminf _ (by is_bounded_default), filter_upwards [B], assume n hn, apply finset.sum_le_sum (Œª i _, _), rw ennreal.rpow_nat_cast, exact pow_le_pow_of_le_left' (hn i) _, end ... = liminf at_top (Œª (n : ‚Ñï), ‚àè (i : Œπ), (‚åà((b i : ‚Ñù) - a i) * n‚åâ‚Çä : ‚Ñù‚â•0‚àû) / n) : begin simp only [finset.card_univ, nat.cast_prod, one_mul, fintype.card_fin, finset.sum_const, nsmul_eq_mul, fintype.card_pi, div_eq_mul_inv, finset.prod_mul_distrib, finset.prod_const] end ... = ‚àè (i : Œπ), volume (Ioo (a i : ‚Ñù) (b i)) : begin simp only [real.volume_Ioo], apply tendsto.liminf_eq, refine ennreal.tendsto_finset_prod_of_ne_top _ (Œª i hi, _) (Œª i hi, _), { apply tendsto.congr' _ ((ennreal.continuous_of_real.tendsto _).comp ((tendsto_nat_ceil_mul_div_at_top (I i)).comp tendsto_coe_nat_at_top_at_top)), apply eventually_at_top.2 ‚ü®1, Œª n hn, _‚ü©, simp only [ennreal.of_real_div_of_pos (nat.cast_pos.mpr hn), comp_app, ennreal.of_real_coe_nat] }, { simp only [ennreal.of_real_ne_top, ne.def, not_false_iff] } end
is_bounded_default
refine liminf_le_liminf _ (by is_bounded_default)
filter_upwards [B]
assume n hn
apply finset.sum_le_sum (Œª i _, _)
rw ennreal.rpow_nat_cast
exact pow_le_pow_of_le_left' (hn i) _
simp only [finset.card_univ, nat.cast_prod, one_mul, fintype.card_fin, finset.sum_const, nsmul_eq_mul, fintype.card_pi, div_eq_mul_inv, finset.prod_mul_distrib, finset.prod_const]
simp only [real.volume_Ioo]
apply tendsto.liminf_eq
refine ennreal.tendsto_finset_prod_of_ne_top _ (Œª i hi, _) (Œª i hi, _)
apply tendsto.congr' _ ((ennreal.continuous_of_real.tendsto _).comp ((tendsto_nat_ceil_mul_div_at_top (I i)).comp tendsto_coe_nat_at_top_at_top))
apply eventually_at_top.2 ‚ü®1, Œª n hn, _‚ü©
simp only [ennreal.of_real_div_of_pos (nat.cast_pos.mpr hn), comp_app, ennreal.of_real_coe_nat]
{ apply tendsto.congr' _ ((ennreal.continuous_of_real.tendsto _).comp ((tendsto_nat_ceil_mul_div_at_top (I i)).comp tendsto_coe_nat_at_top_at_top)), apply eventually_at_top.2 ‚ü®1, Œª n hn, _‚ü©, simp only [ennreal.of_real_div_of_pos (nat.cast_pos.mpr hn), comp_app, ennreal.of_real_coe_nat] }
simp only [ennreal.of_real_ne_top, ne.def, not_false_iff]
simp [‚Üê measure_congr Ioi_ae_eq_Ici]
simp only [volume_pi_ball a hr, volume_ball, finset.prod_const]
exact (ennreal.of_real_pow (mul_nonneg zero_le_two hr.le) _).symm
by_cases hs : metric.bounded s
rw [real.ediam_eq hs, ‚Üê volume_Icc]
exact volume.mono (real.subset_Icc_Inf_Sup_of_bounded hs)
{ rw [real.ediam_eq hs, ‚Üê volume_Icc], exact volume.mono (real.subset_Icc_Inf_Sup_of_bounded hs) }
exact le_top
rw metric.ediam_of_unbounded hs
rw [‚Üê bUnion_of_singleton s, ‚Üê nonpos_iff_eq_zero]
refine le_trans (measure_bUnion_le h _) _
simp
refine le_antisymm _ (le_map_apply f.measurable s)
rw [measure_eq_infi' Œº]
rintro ‚ü®t, hst, ht‚ü©
refine le_infi _
rw [subtype.coe_mk]
have : f.symm '' s = f ‚Åª¬π' s := f.symm.to_equiv.image_eq_preimage s
rw [‚Üê this, image_subset_iff] at hst
convert measure_mono hst
rw [map_apply, preimage_preimage]
convert preimage_id
exact funext f.left_inv
refine congr_arg Œº (eq.symm _)
{ refine congr_arg Œº (eq.symm _), convert preimage_id, exact funext f.left_inv }
exacts [f.measurable, f.measurable_inv_fun ht]
rw [‚Üê (map_measurable_equiv_injective e).eq_iff, map_map_symm, eq_comm]
contrapose! H
apply tsum_measure_le_measure_univ hs
exact Œª i j hij x hx, H i j hij ‚ü®x, hx‚ü©
simp only [le_iff, not_forall, not_le, exists_prop]
rw [restrict‚Çó_apply, restrict_apply ht, linear_map.comp_apply, map_apply measurable_subtype_coe ht, comap_apply (coe : s ‚Üí Œ±) subtype.val_injective (Œª _, hs.subtype_image) _ (measurable_subtype_coe ht), subtype.image_preimage_coe]
simpa only [‚Üê measure_eq_trim] using Œº.to_outer_measure.exists_measurable_superset_eq_trim s
refine ‚ü®Œª h, ‚ü®_, _‚ü©, Œª h, measure_union_lt_top h.1 h.2‚ü©
exact (measure_mono (set.subset_union_left s t)).trans_lt h
{ exact (measure_mono (set.subset_union_left s t)).trans_lt h, }
exact (measure_mono (set.subset_union_right s t)).trans_lt h
rw [supr, Sup_apply, supr_range, supr]
simp
intros U hU r hr
rcases H' hU r hr with ‚ü®F, hFU, hqF, hF‚ü©
rcases H hqF _ hF with ‚ü®K, hKF, hpK, hrK‚ü©
exact ‚ü®K, hKF.trans hFU, hpK, hrK‚ü©
intros F hF r hr
set B : ‚Ñï ‚Üí set X := compact_covering X
have hBc : ‚àÄ n, is_compact (F ‚à© B n)
from Œª n, (is_compact_compact_covering X n).inter_left hF
rw [‚Üê inter_Union, Union_compact_covering, set.inter_univ]
have hBU : (‚ãÉ n, F ‚à© B n) = F
have : Œº F = ‚®Ü n, Œº (F ‚à© B n)
rw [‚Üê measure_Union_eq_supr, hBU]
exacts [Œª n, (hBc n).measurable_set, monotone.directed_le $ Œª m n h, inter_subset_inter_right _ (compact_covering_subset _ h)]
{ rw [‚Üê measure_Union_eq_supr, hBU], exacts [Œª n, (hBc n).measurable_set, monotone.directed_le $ Œª m n h, inter_subset_inter_right _ (compact_covering_subset _ h)] }
rcases lt_supr_iff.1 hr with ‚ü®n, hn‚ü©
rw this at hr
exact ‚ü®_, inter_subset_left _ _, hBc n, hn‚ü©
exact f.outer_Ioc a b
rw stieltjes_function.measure
simp only [coe_smul, pi.smul_apply, hs‚ÇÇ t ht, smul_zero]
ext i hi
simp [measure.to_signed_measure_apply_measurable hi, to_measure_of_zero_le_apply _ _ _ hi]
ext i hi
simp [measure.to_signed_measure_apply_measurable hi, to_measure_of_le_zero_apply _ _ _ hi]
refine hf.ae_eq_of_forall_set_integral_eq f g hg (Œª i hi _, _)
rw [‚Üê with_density·µ•_apply hf hi, hfg, with_density·µ•_apply hg hi]
by_cases hf : integrable f Œº
ext1 i hi
rw [vector_measure.neg_apply, with_density·µ•_apply hf hi, ‚Üê integral_neg, with_density·µ•_apply hf.neg hi]
{ ext1 i hi, rw [vector_measure.neg_apply, with_density·µ•_apply hf hi, ‚Üê integral_neg, with_density·µ•_apply hf.neg hi], refl }
refl
rw [with_density·µ•, with_density·µ•, dif_neg hf, dif_neg, neg_zero]
rwa integrable_neg_iff
intros t ht
induction ht with s h_s s u h_gen_s h_gen_u h_nonempty h_s h_u
exact generate_pi_system.base (set.mem_of_subset_of_mem hST h_s)
{ exact generate_pi_system.base (set.mem_of_subset_of_mem hST h_s),}
exact is_pi_system_generate_pi_system T _ _ h_s h_u h_nonempty
split_ifs
split_ifs; try { subst a }; try { subst a' }; simp * at *
split_ifs; try { subst a }; try { subst a' }
split_ifs; try { subst a }
try { subst a }
try { subst a }
try { subst a }
try { subst a }
subst a
try { subst a' }
try { subst a' }
try { subst a' }
try { subst a' }
subst a'
simp * at *
simp * at *
simp * at *
simp * at *
simp [this]
ext b
ext b; simp [this]
simp
ext
simp
ext
rw [sigma, zeta_mul_apply]
apply sum_congr rfl
intros x hx
rw [pow_apply, if_neg (not_and_of_not_right _ _)]
contrapose! hx
simp [hx]
simp
{ simp }
cases n
suffices : (n + 1 : ‚Ñö) * ‚àë k in range n, ‚Üë(n.choose k) / (n - k + 1) * bernoulli' k = ‚àë x in range n, ‚Üë(n.succ.choose x) * bernoulli' x
rw_mod_cast [sum_range_succ, bernoulli'_def, ‚Üê this, choose_succ_self_right]
ring
{ rw_mod_cast [sum_range_succ, bernoulli'_def, ‚Üê this, choose_succ_self_right], ring }
simp_rw [mul_sum, ‚Üê mul_assoc]
refine sum_congr rfl (Œª k hk, _)
congr'
have : ((n - k : ‚Ñï) : ‚Ñö) + 1 ‚â† 0 := by apply_mod_cast succ_ne_zero
apply_mod_cast succ_ne_zero
field_simp [‚Üê cast_sub (mem_range.1 hk).le, mul_comm]
rw_mod_cast [nat.sub_add_eq_add_sub (mem_range.1 hk).le, choose_mul_succ_eq]
norm_num [bernoulli]
refl
rw [bernoulli'_def', ‚Üê fin.sum_univ_eq_sum_range]
norm_num
rw bernoulli'_def
set y' : ‚Ñ§ := finset.max' _ him with y'_def
have hy' : ‚àÄ k, abv (bS.repr a k) ‚â§ y'
intro k
exact finset.le_max' _ _ (finset.mem_image.mpr ‚ü®k, finset.mem_univ _, rfl‚ü©)
{ intro k, exact finset.le_max' _ _ (finset.mem_image.mpr ‚ü®k, finset.mem_univ _, rfl‚ü©) }
have : (y' : T) < y
rw [y'_def, ‚Üê finset.max'_image (show monotone (coe : ‚Ñ§ ‚Üí T), from Œª x y h, int.cast_le.mpr h)]
apply (finset.max'_lt_iff _ (him.image _)).mpr
simp only [finset.mem_image, exists_prop]
rintros _ ‚ü®x, ‚ü®k, -, rfl‚ü©, rfl‚ü©
{ rw [y'_def, ‚Üê finset.max'_image (show monotone (coe : ‚Ñ§ ‚Üí T), from Œª x y h, int.cast_le.mpr h)], apply (finset.max'_lt_iff _ (him.image _)).mpr, simp only [finset.mem_image, exists_prop], rintros _ ‚ü®x, ‚ü®k, -, rfl‚ü©, rfl‚ü©, exact hy k }
exact hy k
have y'_nonneg : 0 ‚â§ y' := le_trans (abv.nonneg _) (hy' i)
apply (int.cast_le.mpr (norm_le abv bS a hy')).trans_lt
simp only [int.cast_mul, int.cast_pow]
apply mul_lt_mul' (le_refl _)
exact pow_lt_pow_of_lt_left this (int.cast_nonneg.mpr y'_nonneg) (fintype.card_pos_iff.mpr ‚ü®i‚ü©)
{ exact pow_lt_pow_of_lt_left this (int.cast_nonneg.mpr y'_nonneg) (fintype.card_pos_iff.mpr ‚ü®i‚ü©) }
{ exact pow_nonneg (int.cast_nonneg.mpr y'_nonneg) _ }
exact pow_nonneg (int.cast_nonneg.mpr y'_nonneg) _
{ exact int.cast_pos.mpr (norm_bound_pos abv bS) }
exact int.cast_pos.mpr (norm_bound_pos abv bS)
apply_instance
obtain ‚ü®i‚ü© := bS.index_nonempty
have him : (finset.univ.image (Œª k, abv (bS.repr a k))).nonempty := ‚ü®_, finset.mem_image.mpr ‚ü®i, finset.mem_univ _, rfl‚ü©‚ü©
cases o
cases o; refl
refl
refl
exact ‚ü®df, dg‚ü©
apply finset.subset_iff.2
intros x hx
exact nat.mem_proper_divisors.2 (‚ü®(nat.mem_divisors.1 hx).1.trans h, lt_of_le_of_lt (divisor_le hx) (lt_of_le_of_ne (divisor_le (nat.mem_divisors.2 ‚ü®h, hzero‚ü©)) hdiff)‚ü©)
ext
simp
norm_num
norm_num
lucas_lehmer.run_test
by_cases hx : x = 0
{ simp [hx] }
simp [hx]
exact_mod_cast hp_prime.1.one_lt
have h : (1 : ‚Ñù) < p := by exact_mod_cast hp_prime.1.one_lt
rw [‚Üê neg_nonpos, ‚Üê (fpow_strict_mono h).le_iff_le]
show (p : ‚Ñù) ^ -valuation x ‚â§ p ^ 0
rw [‚Üê norm_eq_pow_val hx]
simpa using x.property
from Œª h', @zero_ne_one ‚Ñö_[p] _ _ (by simpa [h'] using h)
have hk : k ‚â† 0
simpa [h'] using h
split_ifs
unfold padic_int.inv
change (‚ü®k * (1/k), _‚ü© : ‚Ñ§_[p]) = 1
refl
{ change (‚ü®k * (1/k), _‚ü© : ‚Ñ§_[p]) = 1, simp [hk], refl }
simp [hk]
simp [mul_inv_cancel hk]
apply subtype.ext_iff_val.2
simp [hq, padic_norm]
unfold padic_norm; split_ifs
split_ifs
unfold padic_norm
apply fpow_nonneg
exact_mod_cast nat.zero_le _
simp [padic_norm]
simp [padic_norm, hq]
simp [hf, norm]
simp [norm, hf, padic_norm.nonneg]
simpa only [hfg, norm, ne.def, le_max_iff, cau_seq.add_apply, not_true, dif_pos]
change lim_zero (f - 0) at hf
simpa only [sub_zero, add_sub_cancel] using hf
show lim_zero (f + g - g)
rw hcl; exact max_eq_right (norm_nonneg _)
exact max_eq_right (norm_nonneg _)
rw hcl
rw [this, hcfg]
change lim_zero (g - 0) at hg
simpa only [add_sub_cancel', sub_zero] using hg
show lim_zero (f + g - f)
rw hcl; exact max_eq_left (norm_nonneg _)
exact max_eq_left (norm_nonneg _)
rw hcl
rw [this, hcfg]
simpa only [sub_zero, add_sub_cancel]
rw [h1, h2]; rw max_eq_right (norm_nonneg _)
rw max_eq_right (norm_nonneg _)
rw [h1, h2]
rw [add_sub_cancel']
rw [add_sub_cancel']; simpa only [sub_zero]
simpa only [sub_zero]
rw [h1, h2]; rw max_eq_left (norm_nonneg _)
rw max_eq_left (norm_nonneg _)
rw [h1, h2]
split_ifs at ‚ä¢ hfgne
unfold norm at ‚ä¢ hfgne
padic_index_simp [hfg, hf, hg] at ‚ä¢ hfgne
exact padic_norm.add_eq_max_of_ne p hfgne
unfold has_norm.norm
exact_mod_cast nonarchimedean' _ _
apply monotone_nat_of_le_succ
intro n
dsimp [appr]
refl
{ refl, }
split_ifs
apply nat.le_add_right
convert appr_spec n _ using 1
simp
intros
intros x a b ha hb
apply zmod_congr_of_sub_mem_span n x a b
simpa using ha
{ simpa using ha }
simpa using hb
simp [zsqrtd.ext, is_pell, mul_comm]
simp [zsqrtd.ext, is_pell, mul_comm]; ring_nf
ring_nf
simp [zsqrtd.ext]
rw nat.zero_sub at hp
rw nat.zero_sub at hp; contradiction
contradiction
simp [pow_succ]
simp [mul_dvd_mul_left, mul_assoc]
exact b_div_k
{ apply induct k, { intros b b_in_s, exact primes b (finset.mem_insert_of_mem b_in_s), }, { intros b b_in_s, have b_div_n, by exact divs b (finset.mem_insert_of_mem b_in_s), have a_prime : prime a, { exact primes a (finset.mem_insert_self a s), }, have b_prime : prime b, { exact primes b (finset.mem_insert_of_mem b_in_s), }, obtain b_div_a | b_div_k : b ‚à£ a ‚à® b ‚à£ k, exact (prime.dvd_mul b_prime).mp b_div_n, { exfalso, have b_eq_a : b = a, { cases (nat.dvd_prime a_prime).1 b_div_a with b_eq_1 b_eq_a, { subst b_eq_1, exfalso, exact prime.ne_one b_prime rfl, }, { exact b_eq_a } }, subst b_eq_a, exact a_not_in_s b_in_s, }, { exact b_div_k } } }
exact mul_dvd_mul_left a step
apply finset.induction_on s
{ simp, }
simp
intros a s a_not_in_s induct n primes divs
rw finset.prod_insert a_not_in_s
exact divs a (finset.mem_insert_self a s)
obtain ‚ü®k, rfl‚ü© : a ‚à£ n
have step : ‚àè p in s, p ‚à£ k
apply induct k
intros b b_in_s
{ intros b b_in_s, exact primes b (finset.mem_insert_of_mem b_in_s), }
exact primes b (finset.mem_insert_of_mem b_in_s)
intros b b_in_s
exact divs b (finset.mem_insert_of_mem b_in_s)
have b_div_n
exact primes a (finset.mem_insert_self a s)
{ exact primes a (finset.mem_insert_self a s), }
have a_prime : prime a
exact primes b (finset.mem_insert_of_mem b_in_s)
{ exact primes b (finset.mem_insert_of_mem b_in_s), }
have b_prime : prime b
exact (prime.dvd_mul b_prime).mp b_div_n
obtain b_div_a | b_div_k : b ‚à£ a ‚à® b ‚à£ k
exfalso
have b_eq_a : b = a
cases (nat.dvd_prime a_prime).1 b_div_a with b_eq_1 b_eq_a
subst b_eq_1
exfalso
exact prime.ne_one b_prime rfl
{ subst b_eq_1, exfalso, exact prime.ne_one b_prime rfl, }
exact b_eq_a
{ cases (nat.dvd_prime a_prime).1 b_div_a with b_eq_1 b_eq_a, { subst b_eq_1, exfalso, exact prime.ne_one b_prime rfl, }, { exact b_eq_a } }
subst b_eq_a
exact a_not_in_s b_in_s
{ exfalso, have b_eq_a : b = a, { cases (nat.dvd_prime a_prime).1 b_div_a with b_eq_1 b_eq_a, { subst b_eq_1, exfalso, exact prime.ne_one b_prime rfl, }, { exact b_eq_a } }, subst b_eq_a, exact a_not_in_s b_in_s, }
convert h.normalize.mul_is_classified (int.gcd x y) (is_classified_of_is_primitive_classified h.normalize hc)
convert h.normalize.mul_is_classified (int.gcd x y) (is_classified_of_is_primitive_classified h.normalize hc); rw int.mul_div_cancel'
rw int.mul_div_cancel'
rw int.mul_div_cancel'
rw int.mul_div_cancel'
{ exact int.gcd_dvd_left x y }
exact int.gcd_dvd_left x y
{ exact int.gcd_dvd_right x y }
exact int.gcd_dvd_right x y
exact h.gcd_dvd
rintro rfl
norm_num at this
suffices : 0 < z * z
{ rintro rfl, norm_num at this }
rw [‚Üê h.eq, ‚Üê sq, ‚Üê sq]
rw hc
have hc' : int.gcd x y ‚â† 0
exact one_ne_zero
{ rw hc, exact one_ne_zero }
cases int.ne_zero_of_gcd hc' with hxz hyz
apply lt_add_of_pos_of_le (sq_pos_of_ne_zero x hxz) (sq_nonneg y)
{ apply lt_add_of_pos_of_le (sq_pos_of_ne_zero x hxz) (sq_nonneg y) }
apply lt_add_of_le_of_pos (sq_nonneg x) (sq_pos_of_ne_zero y hyz)
by_contradiction H
obtain ‚ü®p, hp, hpy, hpz‚ü© := nat.prime.not_coprime_iff_dvd.mp H
apply hp.not_dvd_one
rw [‚Üê hc]
apply nat.dvd_gcd (int.prime.dvd_nat_abs_of_coe_dvd_sq hp _ _) hpy
rw [sq, eq_sub_of_add_eq h]
rw [‚Üê int.coe_nat_dvd_left] at hpy hpz
exact dvd_sub ((hpz).mul_right _) ((hpy).mul_right _)
cases h.even_odd_of_coprime hc with h1 h2
exact (h.is_primitive_classified_of_coprime_of_odd_of_pos hc h1.right hzpos)
{ exact (h.is_primitive_classified_of_coprime_of_odd_of_pos hc h1.right hzpos) }
rw int.gcd_comm at hc
obtain ‚ü®m, n, H‚ü© := (h.symm.is_primitive_classified_of_coprime_of_odd_of_pos hc h2.left hzpos)
tauto
use [m, n]
rw [‚Üê succ_sub_one p, succ_sub (fact.out p.prime).pos]
conv in (Ico 1 p) { rw [‚Üê succ_sub_one p, succ_sub (fact.out p.prime).pos] }
rw [‚Üê prod_nat_cast, finset.prod_Ico_id_eq_factorial, wilsons_lemma]
simp [ext]
simp [ext, sub_eq_add_neg, mul_comm]
apply complex.ext; simp [to_complex_def]
simp [to_complex_def]
simp [to_complex_def]
apply complex.ext
rw sup_sdiff_of_le hx
refine le_trans (sup_le_sup_left sdiff_le z) _
rw sup_eq_right.2 hz
rw [sdiff_eq, compl_compl]
simp only [disjoint_iff, inf_sup_left, sup_eq_bot_iff]
rw h_top
exact le_top
simp [some_eq_coe, coe_eq_coe]
simp [none_eq_top]
simp [bdd_above]
by_cases h : {c : Œ± | complete_lattice.is_compact_element c ‚àß c ‚â§ b} ‚äÜ {‚ä•}
left
rw [‚Üê Sup_compact_le_eq b, Sup_eq_bot]
{ left, rw [‚Üê Sup_compact_le_eq b, Sup_eq_bot], exact h }
exact h
rcases set.not_subset.1 h with ‚ü®c, ‚ü®hc, hcb‚ü©, hcbot‚ü©
right
have hc' := complete_lattice.Iic_coatomic_of_compact_element hc
rw ‚Üê is_atomic_iff_is_coatomic at hc'
haveI := hc'
obtain con | ‚ü®a, ha, hac‚ü© := eq_bot_or_exists_atom_le (‚ü®c, le_refl c‚ü© : set.Iic c)
exfalso
apply hcbot
simp only [subtype.ext_iff, set.Iic.coe_bot, subtype.coe_mk] at con
{ exfalso, apply hcbot, simp only [subtype.ext_iff, set.Iic.coe_bot, subtype.coe_mk] at con, exact con }
exact con
rw [‚Üê subtype.coe_le_coe, subtype.coe_mk] at hac
exact ‚ü®a, ha.of_is_atom_coe_Iic, hac.trans hcb‚ü©
apply le_antisymm
apply Sup_le (Œª b hb, _)
rcases hb with ‚ü®t, ts, bt‚ü©
apply le_trans _ (le_supr _ t)
{ apply Sup_le (Œª b hb, _), rcases hb with ‚ü®t, ts, bt‚ü©, apply le_trans _ (le_supr _ t), exact le_trans (le_Sup bt) (le_supr _ ts), }
exact le_trans (le_Sup bt) (le_supr _ ts)
apply supr_le (Œª t, _)
exact supr_le (Œª ts, Sup_le_Sup (Œª x xt, ‚ü®t, ts, xt‚ü©))
subst this
have := propext pq
congr' with x
apply f
rw [infi, range_const, Inf_singleton]
refine { le := le, sup := sup, inf := inf, .. }
abstract { subst_vars, casesI c, assumption }
abstract { subst_vars, casesI c, assumption }
abstract { subst_vars, casesI c, assumption }
abstract { subst_vars, casesI c, assumption }
abstract { subst_vars, casesI c, assumption }
abstract { subst_vars, casesI c, assumption }
abstract { subst_vars, casesI c, assumption }
abstract { subst_vars, casesI c, assumption }
abstract { subst_vars, casesI c, assumption }
abstract { subst_vars, casesI c, assumption }
subst_vars
casesI c
all_goals { abstract { subst_vars, casesI c, assumption } }
assumption
refine { le := le, top := top, bot := bot, sup := sup, inf := inf, Sup := Sup, Inf := Inf, .. bounded_lattice.copy (@complete_lattice.to_bounded_lattice Œ± c) le eq_le top eq_top bot eq_bot sup eq_sup inf eq_inf, .. }
abstract { subst_vars, casesI c, assumption }
abstract { subst_vars, casesI c, assumption }
abstract { subst_vars, casesI c, assumption }
abstract { subst_vars, casesI c, assumption }
subst_vars
casesI c
all_goals { abstract { subst_vars, casesI c, assumption } }
assumption
rwa ‚Üêfinset.mem_coe
rw [‚Üêfinset.mem_coe, finset.coe_image, equiv.image_eq_preimage] at hp
rwa ‚Üêfinset.mem_coe
rw [‚Üêfinset.mem_coe, finset.coe_image, equiv.image_eq_preimage] at hq
suffices H : ‚àÄ k, p (f (n + 1) \ partial_sups f k)
{ exact H n }
exact H n
rintro k
induction k with k ih
{ exact hdiff h }
exact hdiff h
rw [partial_sups_succ, ‚Üêsdiff_sdiff_left]
exact hdiff ih
simp only [at_top, tendsto_infi, tendsto_principal, mem_Ici]
rw frequently_at_top' at h
exact extraction_of_frequently_at_top' h
simpa only [neg_mul_neg] using this
simp only [finset.image_singleton, h a, finset.mem_singleton]
refine ‚ü®Ici (max n m), mem_range_self _, _‚ü©
rintros p p_in
split ; rw mem_Ici at *
rw mem_Ici at *
rw mem_Ici at *
split
exact le_of_max_le_left p_in
exact le_of_max_le_right p_in
simp only [h.mem_filter_iff, exists_prop]
refl
simp only [tendsto, (hla.map f).le_iff, image_subset_iff]
rintros _ _ ‚ü®n, rfl‚ü© ‚ü®m, rfl‚ü©
exact image_mem_map univ_mem
rw ‚Üêimage_univ
simp only [preimage_image_eq s h]
rw [filter.prod, comap_sup, inf_sup_right, ‚Üê filter.prod, ‚Üê filter.prod]
rw [prod_eq, map_pure, pure_seq_eq_map]
refine ‚ü®Œª S hSc hS, _‚ü©
choose s hs t ht hst using hS
replace hs : (‚ãÇ i ‚àà S, s i ‚Äπ_‚Ä∫) ‚àà l‚ÇÅ := (countable_bInter_mem hSc).2 hs
replace ht : (‚ãÇ i ‚àà S, t i ‚Äπ_‚Ä∫) ‚àà l‚ÇÇ := (countable_bInter_mem hSc).2 ht
refine mem_of_superset (inter_mem_inf hs ht) (subset_sInter $ Œª i hi, _)
rw hst i hi
apply inter_subset_inter ; exact Inter_subset_of_subset i (Inter_subset _ _)
exact Inter_subset_of_subset i (Inter_subset _ _)
exact Inter_subset_of_subset i (Inter_subset _ _)
apply inter_subset_inter
simpa only [filter.eventually, set_of_forall] using @countable_bInter_mem _ _ l _ _ hS (Œª i hi, {x | p x i hi})
simp [filter.lift]
rintros s ‚ü®t, ‚ü®t‚ÇÅ, t‚ÇÇ, ht‚ÇÅ, ht‚ÇÇ, t‚ÇÅt‚ÇÇ‚ü©, mt‚ü©
refine ‚ü®m ‚Åª¬π' t‚ÇÅ, m ‚Åª¬π' t‚ÇÇ, ‚ü®t‚ÇÅ, ht‚ÇÅ, subset.refl _‚ü©, ‚ü®t‚ÇÇ, ht‚ÇÇ, subset.refl _‚ü©, _‚ü©
have := subset.trans (preimage_mono t‚ÇÅt‚ÇÇ) mt
exact subset.trans (preimage_mul_preimage_subset _) this
simp only [gi.choice_eq]
simp only [gi.choice_eq]; exact Œª a b, gi.gc.l_le inf_le_left
exact Œª a b, gi.gc.l_le inf_le_left
simp only [gi.choice_eq]
simp only [gi.choice_eq]; exact Œª a b, gi.gc.l_le inf_le_right
exact Œª a b, gi.gc.l_le inf_le_right
simp only [gi.choice_eq]
simp only [gi.choice_eq]; exact Œª a b c hac hbc, (gi.le_l_u a).trans $ gi.gc.monotone_l $ le_inf (gi.gc.monotone_u hac) (gi.gc.monotone_u hbc)
exact Œª a b c hac hbc, (gi.le_l_u a).trans $ gi.gc.monotone_l $ le_inf (gi.gc.monotone_u hac) (gi.gc.monotone_u hbc)
rw [‚Üê sup_assoc, sup_idem]
rw [‚Üê sup_assoc, ‚Üê sup_assoc, @sup_comm Œ± _ a]
rwa [or_iff_not_imp_left, not_forall]
simp [le_refl]
obtain ha | ha := le_total a‚ÇÅ a‚ÇÇ; cases lt_or_eq_of_le ha with a_lt a_eq
obtain ha | ha := le_total a‚ÇÅ a‚ÇÇ
cases lt_or_eq_of_le ha with a_lt a_eq
cases lt_or_eq_of_le ha with a_lt a_eq
left
exact a_lt
{ left, left, exact a_lt }
left
swap
left
exact a_lt
{ right, left, exact a_lt }
right
subst a_eq
subst a_eq
obtain hb | hb := le_total b‚ÇÅ b‚ÇÇ
obtain hb | hb := le_total b‚ÇÅ b‚ÇÇ
all_goals { subst a_eq, obtain hb | hb := le_total b‚ÇÅ b‚ÇÇ }
right
exact hb
{ left, right, exact hb }
left
right
exact hb
{ right, right, exact hb }
right
right
exact hb
{ left, right, exact hb }
left
right
exact hb
right
rintros ‚ü®a‚ÇÅ, b‚ÇÅ‚ü© ‚ü®a‚ÇÇ, b‚ÇÇ‚ü©
obtain a_lt | a_le := linear_order.decidable_le a‚ÇÅ a‚ÇÇ
rw not_le at a_lt
rintro ‚ü®l, r‚ü©
left
apply lt_trans
repeat { assumption }
assumption
assumption
assumption
{ apply lt_irrefl a‚ÇÇ, apply lt_trans, repeat { assumption } }
apply lt_irrefl a‚ÇÇ
assumption
{ left, rw not_le at a_lt, rintro ‚ü®l, r‚ü©, { apply lt_irrefl a‚ÇÇ, apply lt_trans, repeat { assumption } }, { apply lt_irrefl a‚ÇÅ, assumption } }
apply lt_irrefl a‚ÇÅ
by_cases h : a‚ÇÅ = a‚ÇÇ
rw h
obtain b_lt | b_le := linear_order.decidable_le b‚ÇÅ b‚ÇÇ
left
rw not_le at b_lt
rintro ‚ü®l, r‚ü©
apply lt_irrefl a‚ÇÇ
assumption
{ apply lt_irrefl a‚ÇÇ, assumption }
apply lt_irrefl b‚ÇÇ
apply lt_of_lt_of_le
repeat { assumption }
assumption
assumption
{ left, rw not_le at b_lt, rintro ‚ü®l, r‚ü©, { apply lt_irrefl a‚ÇÇ, assumption }, { apply lt_irrefl b‚ÇÇ, apply lt_of_lt_of_le, repeat { assumption } } }
right
right
assumption
{ rw h, obtain b_lt | b_le := linear_order.decidable_le b‚ÇÅ b‚ÇÇ, { left, rw not_le at b_lt, rintro ‚ü®l, r‚ü©, { apply lt_irrefl a‚ÇÇ, assumption }, { apply lt_irrefl b‚ÇÇ, apply lt_of_lt_of_le, repeat { assumption } } }, { right, right, assumption } }
left
apply lt_of_le_of_ne
repeat { assumption }
assumption
assumption
right
rintros ‚ü®a‚ÇÅ, b‚ÇÅ‚ü© ‚ü®a‚ÇÇ, b‚ÇÇ‚ü©
exact supr_infi_ge_nat_add f k
simp_rw liminf_eq_supr_infi_of_nat
rw h'
rw h'; apply œâSup_le; intro; apply f.monotone (hx i)
rw h'; apply œâSup_le; intro
rw h'; apply œâSup_le
apply œâSup_le
intro
apply f.monotone (hx i)
rw h'
rw h'; apply le_œâSup (c.map f)
apply le_œâSup (c.map f)
intros
intros
split
split; intros
transitivity œâSup c
assumption
{ transitivity œâSup c, exact le_œâSup _ _, assumption }
exact le_œâSup _ _
exact œâSup_le _ _ ‚Äπ_‚Ä∫
simp only [supr_le_iff, preorder_hom.coe_fun_mk] at ‚ä¢ hs
simp only [supr_le_iff, preorder_hom.coe_fun_mk] at ‚ä¢ hs; intros i; apply hs i
simp only [supr_le_iff, preorder_hom.coe_fun_mk] at ‚ä¢ hs; intros i
apply hs i
intros i
simp only [preorder_hom.coe_fun_mk]
simp only [preorder_hom.coe_fun_mk]; apply le_supr_of_le i; refl
simp only [preorder_hom.coe_fun_mk]; apply le_supr_of_le i
apply le_supr_of_le i
refl
apply Sup_continuous
rw ‚Üê Sup_pair
rintro f (rfl|rfl|_); assumption
assumption
assumption
rintro f (rfl|rfl|_)
apply eq_of_forall_ge_iff
intro z
intro c
simp only [œâSup_le_iff, forall_const, chain.map_coe, (‚àò), function.const, preorder_hom.has_top_top, preorder_hom.const_coe_coe]
split_ifs; simp *
simp *
simp *
split_ifs
rw [hf.map_Sup', Sup_image]
apply_instance
cases le_or_lt m n with h
symmetry
exact strict_mono.monotone (Œª x y, a.swap.map_rel) h
rw [sup_eq_right.mpr h, sup_eq_right]
{ rw [sup_eq_right.mpr h, sup_eq_right], exact strict_mono.monotone (Œª x y, a.swap.map_rel) h, }
exact le_of_lt (a.map_rel h)
rw [sup_eq_left.mpr (le_of_lt h), sup_eq_left]
erw [‚Üê f.map_rel_iff, f.1.apply_symm_apply, f.1.apply_symm_apply]
rw symm_diff_bot
rw symm_diff_right_inj
rw [symm_diff_comm, symm_diff_sdiff_left]
classical
intros h f hf
intros h f hf
split
split; intros h f hf
{ exact h.exists_monotone_subseq f hf }
exact h.exists_monotone_subseq f hf
obtain ‚ü®g, gmon‚ü© := h f hf
refine ‚ü®g 0, g 1, g.lt_iff_lt.2 zero_lt_one, gmon _ _ zero_le_one‚ü©
exact hs.union (is_pwo_singleton a)
rw ‚Üê union_singleton
rwa [set.mem_singleton_iff.mp hs1, set.mem_singleton_iff.mp ht1]
dsimp [conjugate]
simp only [‚Üêi.map_smul, h, ‚Üêmul_smul, single_mul_single, mul_one, mul_left_inv]
change (1 : monoid_algebra k G) ‚Ä¢ v = v
simp
have f'_monic : monic _ := monic_mul_leading_coeff_inv hf
refine (minpoly.unique K _ f'_monic _ _).symm
{ rw [alg_hom.map_mul, aeval_eq, mk_self, zero_mul] }
rw [alg_hom.map_mul, aeval_eq, mk_self, zero_mul]
intros q q_monic q_aeval
have commutes : (lift (algebra_map K (adjoin_root f)) (root f) q_aeval).comp (mk q) = mk f
ext
refl
{ simp only [ring_hom.comp_apply, mk_C, lift_of], refl }
simp only [ring_hom.comp_apply, mk_C, lift_of]
{ ext, { simp only [ring_hom.comp_apply, mk_C, lift_of], refl }, { simp only [ring_hom.comp_apply, mk_X, lift_root] } }
simp only [ring_hom.comp_apply, mk_X, lift_root]
rw [degree_eq_nat_degree f'_monic.ne_zero, degree_eq_nat_degree q_monic.ne_zero, with_bot.coe_le_coe, nat_degree_mul hf, nat_degree_C, add_zero]
apply nat_degree_le_of_dvd
rw [‚Üêcommutes, ring_hom.comp_apply, mk_self, ring_hom.map_zero]
have : mk f q = 0
rwa [‚Üêideal.mem_span_singleton, ‚Üêideal.quotient.eq_zero_iff_mem]
{ have : mk f q = 0, by rw [‚Üêcommutes, ring_hom.comp_apply, mk_self, ring_hom.map_zero], rwa [‚Üêideal.mem_span_singleton, ‚Üêideal.quotient.eq_zero_iff_mem] }
{ exact q_monic.ne_zero }
exact q_monic.ne_zero
rwa [ne.def, C_eq_zero, inv_eq_zero, leading_coeff_eq_zero]
let Jac := ideal.jacobson (‚ä• : ideal R)
let f : ‚Ñï ‚Üí‚Çò order_dual (ideal R) := ‚ü®Œª n, Jac ^ n, Œª _ _ h, ideal.pow_le_pow h‚ü©
obtain ‚ü®n, hn‚ü© : ‚àÉ n, ‚àÄ m, n ‚â§ m ‚Üí Jac ^ n = Jac ^ m := is_artinian.monotone_stabilizes f
refine ‚ü®n, _‚ü©
let J : ideal R := annihilator (Jac ^ n)
suffices : J = ‚ä§
have hJ : J ‚Ä¢ Jac ^ n = ‚ä• := annihilator_smul (Jac ^ n)
simpa only [this, top_smul, ideal.zero_eq_bot] using hJ
{ have hJ : J ‚Ä¢ Jac ^ n = ‚ä• := annihilator_smul (Jac ^ n), simpa only [this, top_smul, ideal.zero_eq_bot] using hJ }
change J ‚â† ‚ä§ at hJ
by_contradiction hJ
rcases is_artinian.set_has_minimal {J' : ideal R | J < J'} ‚ü®‚ä§, hJ.lt_top‚ü© with ‚ü®J', hJJ' : J < J', hJ' : ‚àÄ I, J < I ‚Üí I ‚â§ J' ‚Üí I = J'‚ü©
rcases set_like.exists_of_lt hJJ' with ‚ü®x, hxJ', hxJ‚ü©
obtain rfl : J ‚äî ideal.span {x} = J'
refine hJ' (J ‚äî ideal.span {x}) _ _
rw set_like.lt_iff_le_and_exists
exact ‚ü®le_sup_left, ‚ü®x, mem_sup_right (mem_span_singleton_self x), hxJ‚ü©‚ü©
{ rw set_like.lt_iff_le_and_exists, exact ‚ü®le_sup_left, ‚ü®x, mem_sup_right (mem_span_singleton_self x), hxJ‚ü©‚ü© }
{ refine hJ' (J ‚äî ideal.span {x}) _ _, { rw set_like.lt_iff_le_and_exists, exact ‚ü®le_sup_left, ‚ü®x, mem_sup_right (mem_span_singleton_self x), hxJ‚ü©‚ü© }, { exact (sup_le hJJ'.le (span_le.2 (singleton_subset_iff.2 hxJ'))) } }
exact (sup_le hJJ'.le (span_le.2 (singleton_subset_iff.2 hxJ')))
have : J ‚äî Jac ‚Ä¢ ideal.span {x} ‚â§ J ‚äî ideal.span {x}
from sup_le_sup_left (smul_le.2 (Œª _ _ _, submodule.smul_mem _ _)) _
have : Jac * ideal.span {x} ‚â§ J
by_contradiction H
classical
refine H (smul_sup_le_of_le_smul_of_le_jacobson_bot (fg_span_singleton _) le_rfl (hJ' _ _ this).ge)
exact lt_of_le_of_ne le_sup_left (Œª h, H $ h.symm ‚ñ∏ le_sup_right)
{ classical, by_contradiction H, refine H (smul_sup_le_of_le_smul_of_le_jacobson_bot (fg_span_singleton _) le_rfl (hJ' _ _ this).ge), exact lt_of_le_of_ne le_sup_left (Œª h, H $ h.symm ‚ñ∏ le_sup_right) }
have : ideal.span {x} * Jac ^ (n + 1) ‚â§ ‚ä•
calc ideal.span {x} * Jac ^ (n + 1) = ideal.span {x} * Jac * Jac ^ n : by rw [pow_succ, ‚Üê mul_assoc] ... ‚â§ J * Jac ^ n : mul_le_mul (by rwa mul_comm) (le_refl _) ... = ‚ä• : by simp [J]
rw [pow_succ, ‚Üê mul_assoc]
rwa mul_comm
simp [J]
refine hxJ (mem_annihilator.2 (Œª y hy, (mem_bot R).1 _))
refine this (mul_mem_mul (mem_span_singleton_self x) _)
rwa [‚Üê hn (n + 1) (nat.le_succ _)]
simp only [class_group.mk0, monoid_hom.comp_apply, quotient_group.mk'_eq_mk']
split
rintros ‚ü®_, ‚ü®x, rfl‚ü©, hx‚ü©
refine ‚ü®x, x.ne_zero, _‚ü©
simpa only [mul_comm, coe_mk0, monoid_hom.to_fun_eq_coe, coe_to_principal_ideal, units.coe_mul] using congr_arg (coe : _ ‚Üí fractional_ideal R‚Å∞ K) hx
{ rintros ‚ü®_, ‚ü®x, rfl‚ü©, hx‚ü©, refine ‚ü®x, x.ne_zero, _‚ü©, simpa only [mul_comm, coe_mk0, monoid_hom.to_fun_eq_coe, coe_to_principal_ideal, units.coe_mul] using congr_arg (coe : _ ‚Üí fractional_ideal R‚Å∞ K) hx }
rintros ‚ü®x, hx, eq_J‚ü©
refine ‚ü®_, ‚ü®units.mk0 x hx, rfl‚ü©, units.ext _‚ü©
simpa only [fractional_ideal.mk0_apply, units.coe_mk0, mul_comm, coe_to_principal_ideal, coe_coe, units.coe_mul] using eq_J
rintros ‚ü®I‚ü©
rw [finset.mem_singleton]
exact class_group.mk_eq_one_iff.mpr (I : fractional_ideal R‚Å∞ K).is_principal
rw [finset.prod_insert hbt, is_coprime.mul_left_iff, ih, finset.forall_mem_insert]
refine ‚ü®Œª x hx, _‚ü©
rw [‚Üê set.mem_range, ‚Üê algebra.mem_bot, ‚Üê subalgebra.mem_to_submodule, algebra.to_submodule_bot, ‚Üê coe_span_singleton A‚Å∞ (1 : fraction_ring A), fractional_ideal.span_singleton_one, ‚Üê fractional_ideal.adjoin_integral_eq_one_of_is_unit x hx (h.is_unit _)]
{ exact mem_adjoin_integral_self A‚Å∞ x hx }
exact mem_adjoin_integral_self A‚Å∞ x hx
exact Œª h, one_ne_zero (eq_zero_iff.mp h 1 (subalgebra.one_mem _))
rw mem_inv_iff (fractional_ideal.coe_ideal_ne_zero hI)
intros y hy
rw one_mul
exact coe_ideal_le_one hy
assumption
split
rw iff_quotient_mv_polynomial'
rintro ‚ü®Œπ, hfintype, ‚ü®f, hsur‚ü©‚ü©
letI := hfintype
obtain ‚ü®equiv‚ü© := @fintype.trunc_equiv_fin Œπ (classical.dec_eq Œπ) hfintype
replace equiv := mv_polynomial.rename_equiv R equiv
exact ‚ü®fintype.card Œπ, alg_hom.comp f equiv.symm, function.surjective.comp hsur (alg_equiv.symm equiv).surjective‚ü©
{ rw iff_quotient_mv_polynomial', rintro ‚ü®Œπ, hfintype, ‚ü®f, hsur‚ü©‚ü©, letI := hfintype, obtain ‚ü®equiv‚ü© := @fintype.trunc_equiv_fin Œπ (classical.dec_eq Œπ) hfintype, replace equiv := mv_polynomial.rename_equiv R equiv, exact ‚ü®fintype.card Œπ, alg_hom.comp f equiv.symm, function.surjective.comp hsur (alg_equiv.symm equiv).surjective‚ü© }
rintro ‚ü®n, ‚ü®f, hsur‚ü©‚ü©
exact finite_type.of_surjective (finite_type.mv_polynomial R (fin n)) f hsur
letI := f.to_algebra
letI := g.to_algebra
letI := (g.comp f).to_algebra
letI : is_scalar_tower A B C := restrict_scalars.is_scalar_tower A B C
letI : module.finite A C := h
exact module.finite.of_restrict_scalars_finite A B C
refine ‚ü®Œª h, _, Œª h, submodule.subset_span $ set.mem_image_of_mem (of R M) h‚ü©
rw [of, monoid_hom.coe_mk, ‚Üê finsupp.supported_eq_span_single, finsupp.mem_supported, finsupp.support_single_ne_zero (@one_ne_zero R _ (by apply_instance))] at h
apply_instance
simpa using h
ext
refine (mem_span_singleton S).trans ((exists_congr _).trans (mem_one_iff S).symm)
intro x'
rw [algebra.smul_def, mul_one]
obtain ‚ü®a, a_mem, ha‚ü© := J.is_fractional
use [a, a_mem]
intros b b_mem
exact ha b (hIJ b_mem)
simp [x'_eq_x.symm, x'_eq_zero]
simp [hx]
obtain ‚ü®y, y_mem, y_not_mem‚ü© := set_like.exists_of_lt (bot_lt_iff_ne_bot.mpr hI)
simpa using y_not_mem
have y_ne_zero : y ‚â† 0 := by simpa using y_not_mem
obtain ‚ü®z, ‚ü®x, hx‚ü©‚ü© := exists_integer_multiple R‚Å∞ y
refine ‚ü®x, _, _‚ü©
rw [ne.def, ‚Üê @is_fraction_ring.to_map_eq_zero_iff R _ K, hx, algebra.smul_def]
exact mul_ne_zero (is_fraction_ring.to_map_ne_zero_of_mem_non_zero_divisors z.2) y_ne_zero
{ rw [ne.def, ‚Üê @is_fraction_ring.to_map_eq_zero_iff R _ K, hx, algebra.smul_def], exact mul_ne_zero (is_fraction_ring.to_map_ne_zero_of_mem_non_zero_divisors z.2) y_ne_zero }
rw hx
exact smul_mem _ _ y_mem
rw ‚Üê (algebra_map R‚ÇÅ K).map_one
simpa only [h] using coe_mem_one R‚ÇÅ‚Å∞ 1
ext a
have hwf := (y.is_pwo_support.union z.is_pwo_support)
rw [mul_coeff_right' hwf, add_coeff, mul_coeff_right' hwf (set.subset_union_right _ _), mul_coeff_right' hwf (set.subset_union_left _ _)]
{ simp only [add_coeff, mul_add, sum_add_distrib] }
simp only [add_coeff, mul_add, sum_add_distrib]
intro b
simp only [add_coeff, ne.def, set.mem_union_eq, set.mem_set_of_eq, mem_support]
contrapose!
intro h
rw [h.1, h.2, add_zero]
ext a
have hwf := (x.is_pwo_support.union y.is_pwo_support)
rw [mul_coeff_left' hwf, add_coeff, mul_coeff_left' hwf (set.subset_union_right _ _), mul_coeff_left' hwf (set.subset_union_left _ _)]
{ simp only [add_coeff, add_mul, sum_add_distrib] }
simp only [add_coeff, add_mul, sum_add_distrib]
intro b
simp only [add_coeff, ne.def, set.mem_union_eq, set.mem_set_of_eq, mem_support]
contrapose!
intro h
rw [h.1, h.2, add_zero]
simp [‚Üê ring_equiv.to_ring_hom_eq_coe, comap_comap]
rw [smul_smul, mul_comm, mul_smul]
rw [smul_smul, mul_comm, mul_smul]; exact submodule.smul_mem _ _
exact submodule.smul_mem _ _
rw [smul_eq_mul, mul_smul]
rw [smul_eq_mul, mul_smul]; exact submodule.smul_mem _ _
exact submodule.smul_mem _ _
have : ‚àÉ œÜ : Œπ ‚Üí R, (‚àÄ i, œÜ i - 1 ‚àà f i) ‚àß (‚àÄ i j, i ‚â† j ‚Üí œÜ i ‚àà f j)
have := exists_sub_one_mem_and_mem (finset.univ : finset Œπ) (Œª i _ j _ hij, hf i j hij)
choose œÜ hœÜ
existsi Œª i, œÜ i (finset.mem_univ i)
exact ‚ü®Œª i, (hœÜ i _).1, Œª i j hij, (hœÜ i _).2 j (finset.mem_univ j) hij.symm‚ü©
{ have := exists_sub_one_mem_and_mem (finset.univ : finset Œπ) (Œª i _ j _ hij, hf i j hij), choose œÜ hœÜ, existsi Œª i, œÜ i (finset.mem_univ i), exact ‚ü®Œª i, (hœÜ i _).1, Œª i j hij, (hœÜ i _).2 j (finset.mem_univ j) hij.symm‚ü© }
rcases this with ‚ü®œÜ, hœÜ1, hœÜ2‚ü©
use ‚àë i, g i * œÜ i
intros i
rw [‚Üê quotient.eq, ring_hom.map_sum]
refine eq.trans (finset.sum_eq_single i _ _) _
rw quotient.eq_zero_iff_mem
exact (f i).mul_mem_left _ (hœÜ2 j i hji)
intros j _ hji
{ intros j _ hji, rw quotient.eq_zero_iff_mem, exact (f i).mul_mem_left _ (hœÜ2 j i hji) }
exact (hi $ finset.mem_univ i).elim
{ intros hi, exact (hi $ finset.mem_univ i).elim }
intros hi
rw [‚Üê quotient.eq, ring_hom.map_one] at hœÜ1
specialize hœÜ1 i
rw [ring_hom.map_mul, hœÜ1, mul_one]
obtain ‚ü®p, p_monic, hpx‚ü© := integral
refine comap_lt_comap_of_root_mem_sdiff hIJ mem _ _
swap
apply map_monic_ne_zero p_monic
apply quotient.nontrivial
apply mt comap_eq_top_iff.mp
{ apply map_monic_ne_zero p_monic, apply quotient.nontrivial, apply mt comap_eq_top_iff.mp, apply hI.1 }
apply hI.1
convert I.zero_mem
contrapose!
simp only [ne_top_iff_one, is_prime_iff, not_and, not_forall, not_or_distrib]
exact Œª ‚ü®hI, hJ‚ü© hIJ, ‚ü®‚ü®0, 1‚ü©, ‚ü®1, 0‚ü©, by simp, by simp [hJ], by simp [hI]‚ü©
simp
simp [hJ]
simp [hI]
exactI is_prime_ideal_prod_top
refine is_cyclic_of_subgroup_integral_domain ‚ü®(coe : S ‚Üí R), _, _‚ü© (units.ext.comp subtype.val_injective)
{ simp }
simp
simp
intros
ext n
rw [‚Üê sub_add_cancel n x.order, single_mul_coeff_add, sub_add_cancel, one_mul]
by_cases h : x.order ‚â§ n
rw [int.eq_nat_abs_of_zero_le (sub_nonneg_of_le h), coeff_coe_power_series, power_series_part_coeff, ‚Üê int.eq_nat_abs_of_zero_le (sub_nonneg_of_le h), add_sub_cancel'_right]
{ rw [int.eq_nat_abs_of_zero_le (sub_nonneg_of_le h), coeff_coe_power_series, power_series_part_coeff, ‚Üê int.eq_nat_abs_of_zero_le (sub_nonneg_of_le h), add_sub_cancel'_right] }
rw [coe_power_series, of_power_series_apply, emb_domain_notin_range]
contrapose! h
{ contrapose! h, exact order_le_of_coeff_ne_zero h.symm }
exact order_le_of_coeff_ne_zero h.symm
contrapose! h
simp only [set.mem_range, rel_embedding.coe_fn_mk, function.embedding.coe_fn_mk, int.nat_cast_eq_coe_nat] at h
obtain ‚ü®m, hm‚ü© := h
rw [‚Üê sub_nonneg, ‚Üê hm]
exact int.zero_le_of_nat _
refine alg_equiv.of_bijective (algebra.of_id R S) ‚ü®_, _‚ü©
intros x y hxy
obtain ‚ü®c, eq‚ü© := (is_localization.eq_iff_exists M S).mp hxy
obtain ‚ü®u, hu‚ü© := H c
{ intros x y hxy, obtain ‚ü®c, eq‚ü© := (is_localization.eq_iff_exists M S).mp hxy, obtain ‚ü®u, hu‚ü© := H c, rwa [‚Üê hu, units.mul_left_inj] at eq }
rwa [‚Üê hu, units.mul_left_inj] at eq
intros y
obtain ‚ü®‚ü®x, s‚ü©, eq‚ü© := is_localization.surj M y
obtain ‚ü®u, hu‚ü© := H s
use x * u.inv
dsimp only [algebra.of_id, ring_hom.to_fun_eq_coe, alg_hom.coe_mk]
rw [ring_hom.map_mul, ‚Üê eq, ‚Üê hu, mul_assoc, ‚Üê ring_hom.map_mul]
simp
rw [coe_submodule, submodule.map_top, submodule.one_eq_range]
rw [mul_comm (_ + _), mul_add, mul_mk'_eq_mk'_of_mul, ‚Üêeq_sub_iff_add_eq, mk'_eq_iff_eq_mul, mul_comm _ ((algebra_map R S) _), mul_sub, eq_sub_iff_add_eq, ‚Üêeq_sub_iff_add_eq', ‚Üêmul_assoc, ‚Üê(algebra_map R S).map_mul, mul_mk'_eq_mk'_of_mul, mk'_eq_iff_eq_mul]
simp only [(algebra_map R S).map_add, submonoid.coe_mul, (algebra_map R S).map_mul]
ring_exp
simp
rintros a b ‚ü®a', ha‚ü© ‚ü®b', hb‚ü©
use ‚ü®a'.2 * b'.1 + b'.2 * a'.1, I.add_mem (I.mul_mem_left _ b'.1.2) (I.mul_mem_left _ a'.1.2)‚ü©
use a'.2 * b'.2
simp only [ring_hom.map_add, submodule.coe_mk, submonoid.coe_mul, ring_hom.map_mul]
rw [add_mul, ‚Üê mul_assoc a, ha, mul_comm (algebra_map R S a'.2) (algebra_map R S b'.2), ‚Üê mul_assoc b, hb]
ring
rintros c x ‚ü®x', hx‚ü©
obtain ‚ü®c', hc‚ü© := is_localization.surj M c
use ‚ü®c'.1 * x'.1, I.mul_mem_left c'.1 x'.1.2‚ü©
use c'.2 * x'.2
simp only [‚Üêhx, ‚Üêhc, smul_eq_mul, submodule.coe_mk, submonoid.coe_mul, ring_hom.map_mul]
ring
simp [matrix_equiv_tensor, to_fun_alg_hom, alg_hom_of_linear_map_tensor_product, to_fun_linear]
refl
simp [mul_pow]
exact ‚ü®this, nat.find_min' _ hsucc‚ü©
rw [enat.le_coe_iff]
haveI := classical.dec_eq M
haveI := classical.dec_eq R
haveI := classical.dec_eq P
cases hs2 with t2 ht2
cases hs1 with t1 ht1
have : ‚àÄ y ‚àà t1, ‚àÉ x ‚àà s, f x = y
intros y hy
rw ‚Üê ht1
exact subset_span hy
{ rw ‚Üê ht1, exact subset_span hy }
have : y ‚àà map f s
rcases mem_map.1 this with ‚ü®x, hx1, hx2‚ü©
{ intros y hy, have : y ‚àà map f s, { rw ‚Üê ht1, exact subset_span hy }, rcases mem_map.1 this with ‚ü®x, hx1, hx2‚ü©, exact ‚ü®x, hx1, hx2‚ü© }
exact ‚ü®x, hx1, hx2‚ü©
have : ‚àÉ g : P ‚Üí M, ‚àÄ y ‚àà t1, g y ‚àà s ‚àß f (g y) = y
choose g hg1 hg2
existsi Œª y, if H : y ‚àà t1 then g y H else 0
split
intros y H
apply hg1
{ simp only [dif_pos H], apply hg1 }
simp only [dif_pos H]
apply hg2
{ choose g hg1 hg2, existsi Œª y, if H : y ‚àà t1 then g y H else 0, intros y H, split, { simp only [dif_pos H], apply hg1 }, { simp only [dif_pos H], apply hg2 } }
simp only [dif_pos H]
clear this
cases this with g hg
existsi t1.image g ‚à™ t2
rw [finset.coe_union, span_union, finset.coe_image]
apply le_antisymm
refine sup_le (span_le.2 $ image_subset_iff.2 _) (span_le.2 _)
exact (hg y hy).1
{ intros y hy, exact (hg y hy).1 }
intros y hy
have := subset_span hx
intros x hx
rw ht2 at this
{ refine sup_le (span_le.2 $ image_subset_iff.2 _) (span_le.2 _), { intros y hy, exact (hg y hy).1 }, { intros x hx, have := subset_span hx, rw ht2 at this, exact this.1 } }
exact this.1
intros x hx
rw mem_map
exact ‚ü®x, hx, rfl‚ü©
have : f x ‚àà map f s
{ rw mem_map, exact ‚ü®x, hx, rfl‚ü© }
rw [‚Üê ht1,‚Üê set.image_id ‚Üët1, finsupp.mem_span_image_iff_total] at this
rcases this with ‚ü®l, hl1, hl2‚ü©
refine mem_sup.2 ‚ü®(finsupp.total M M R id).to_fun ((finsupp.lmap_domain R R g : (P ‚Üí‚ÇÄ R) ‚Üí M ‚Üí‚ÇÄ R) l), _, x - finsupp.total M M R id ((finsupp.lmap_domain R R g : (P ‚Üí‚ÇÄ R) ‚Üí M ‚Üí‚ÇÄ R) l), _, add_sub_cancel'_right _ _‚ü©
rw [‚Üê set.image_id (g '' ‚Üët1), finsupp.mem_span_image_iff_total]
refine ‚ü®_, _, rfl‚ü©
haveI : inhabited P := ‚ü®0‚ü©
rw [‚Üê finsupp.lmap_domain_supported _ _ g, mem_map]
refine ‚ü®l, hl1, _‚ü©
{ rw [‚Üê set.image_id (g '' ‚Üët1), finsupp.mem_span_image_iff_total], refine ‚ü®_, _, rfl‚ü©, haveI : inhabited P := ‚ü®0‚ü©, rw [‚Üê finsupp.lmap_domain_supported _ _ g, mem_map], refine ‚ü®l, hl1, _‚ü©, refl, }
refl
split
rw [ht2, mem_inf]
apply s.sub_mem hx
rw [finsupp.total_apply, finsupp.lmap_domain_apply, finsupp.sum_map_domain_index]
refine s.sum_mem _
exact s.smul_mem _ (hg y (hl1 hy)).1
{ intros y hy, exact s.smul_mem _ (hg y (hl1 hy)).1 }
intros y hy
{ exact zero_smul _ }
exact Œª _ _ _, add_smul _ _ _
{ apply s.sub_mem hx, rw [finsupp.total_apply, finsupp.lmap_domain_apply, finsupp.sum_map_domain_index], refine s.sum_mem _, { intros y hy, exact s.smul_mem _ (hg y (hl1 hy)).1 }, { exact zero_smul _ }, { exact Œª _ _ _, add_smul _ _ _ } }
exact zero_smul _
rw [linear_map.mem_ker, f.map_sub, ‚Üê hl2]
rw [finsupp.total_apply, finsupp.total_apply, finsupp.lmap_domain_apply]
rw [finsupp.sum_map_domain_index, finsupp.sum, finsupp.sum, f.map_sum]
rw sub_eq_zero
refine finset.sum_congr rfl (Œª y hy, _)
unfold id
rw [f.map_smul, (hg y (hl1 hy)).2]
refine classical.by_contradiction (Œª hf, (rel_embedding.well_founded_iff_no_descending_seq.1 (well_founded_submodule_gt R M)).elim' _)
from @infinite.nat_embedding s ‚ü®Œª f, hf ‚ü®f‚ü©‚ü©
have f : ‚Ñï ‚Ü™ s
have : ‚àÄ n, (coe ‚àò f) '' {m | m ‚â§ n} ‚äÜ s
subst hy‚ÇÇ
exact (f y).2
{ rintros n x ‚ü®y, hy‚ÇÅ, hy‚ÇÇ‚ü©, subst hy‚ÇÇ, exact (f y).2 }
rintros n x ‚ü®y, hy‚ÇÅ, hy‚ÇÇ‚ü©
have : ‚àÄ a b : ‚Ñï, a ‚â§ b ‚Üî span R ((coe ‚àò f) '' {m | m ‚â§ a}) ‚â§ span R ((coe ‚àò f) '' {m | m ‚â§ b})
assume a b
rw [span_le_span_iff hs (this a) (this b), set.image_subset_image_iff (subtype.coe_injective.comp f.injective), set.subset_def]
exact ‚ü®Œª hab x (hxa : x ‚â§ a), le_trans hxa hab, Œª hx, hx a (le_refl a)‚ü©
{ assume a b, rw [span_le_span_iff hs (this a) (this b), set.image_subset_image_iff (subtype.coe_injective.comp f.injective), set.subset_def], exact ‚ü®Œª hab x (hxa : x ‚â§ a), le_trans hxa hab, Œª hx, hx a (le_refl a)‚ü© }
exact ‚ü®‚ü®Œª n, span R ((coe ‚àò f) '' {m | m ‚â§ n}), Œª x y, by simp [le_antisymm_iff, (this _ _).symm] {contextual := tt}‚ü©, by dsimp [gt]; simp only [lt_iff_le_not_le, (this _ _).symm]; tauto‚ü©
simp [le_antisymm_iff, (this _ _).symm] {contextual := tt}
dsimp [gt]; simp only [lt_iff_le_not_le, (this _ _).symm]; tauto
dsimp [gt]; simp only [lt_iff_le_not_le, (this _ _).symm]
simp only [lt_iff_le_not_le, (this _ _).symm]
tauto
dsimp [gt]
intros p hp x hx
rw ‚Üê mem_vanishing_ideal_singleton_iff
rw radical_eq_Inf at hp
refine (mem_Inf.mp hp) ‚ü®le_trans (le_vanishing_ideal_zero_locus I) (vanishing_ideal_anti_mono (Œª y hy, hy.symm ‚ñ∏ hx)), is_maximal.is_prime' _‚ü©
rw [map_map, perfection.coeff_map]
ext i
simp only [mem_support_iff, not_iff_not, ne.def]
rw [‚Üê coeff_restriction]
conv_rhs { rw [‚Üê coeff_restriction] }
rw H
refl
exact ‚ü®Œª H, by { rw H, refl }, Œª H, subtype.coe_injective H‚ü©
simp only [restriction, finset.sum_empty, support_zero]
simp only [coe_eval‚ÇÇ_ring_hom, eval‚ÇÇ_mul]
simp only [eval‚ÇÇ_add, coe_eval‚ÇÇ_ring_hom]
intro f
apply polynomial.induction_on' f
intros p q hp hq
simp only [coe_eval‚ÇÇ_ring_hom] at hp
simp only [coe_eval‚ÇÇ_ring_hom] at hq
{ intros p q hp hq, simp only [coe_eval‚ÇÇ_ring_hom] at hp, simp only [coe_eval‚ÇÇ_ring_hom] at hq, simp only [coe_eval‚ÇÇ_ring_hom, hp, hq, ring_hom.map_add] }
simp only [coe_eval‚ÇÇ_ring_hom, hp, hq, ring_hom.map_add]
rintros n ‚ü®x‚ü©
simp only [monomial_eq_smul_X, C_mul', quotient.lift_mk, submodule.quotient.quot_mk_eq_mk, quotient.mk_eq_mk, eval‚ÇÇ_X_pow, eval‚ÇÇ_smul, coe_eval‚ÇÇ_ring_hom, ring_hom.map_pow, eval‚ÇÇ_C, ring_hom.coe_comp, ring_hom.map_mul, eval‚ÇÇ_X]
rintro ‚ü®f‚ü©
apply polynomial.induction_on' f
simp_intros p q hp hq
{ simp_intros p q hp hq, rw [hp, hq] }
rw [hp, hq]
intros n a
simp only [monomial_eq_smul_X, ‚Üê C_mul' a (X ^ n), quotient.lift_mk, submodule.quotient.quot_mk_eq_mk, quotient.mk_eq_mk, eval‚ÇÇ_X_pow, eval‚ÇÇ_smul, coe_eval‚ÇÇ_ring_hom, ring_hom.map_pow, eval‚ÇÇ_C, ring_hom.coe_comp, ring_hom.map_mul, eval‚ÇÇ_X]
have : eval‚ÇÇ (ring_hom.id _) (Œª s, (0:R)) (0 : mv_polynomial œÉ R) = eval‚ÇÇ (ring_hom.id _) (Œª s, (0:R)) (1 : mv_polynomial œÉ R)
exact H
{ congr, exact H }
congr
simpa
apply_instance
dsimp [bernstein_polynomial]
suffices : ‚Üë((n + 1).choose (ŒΩ + 1)) * ((‚ÜëŒΩ + 1) * X ^ ŒΩ) * (1 - X) ^ (n - ŒΩ) -(‚Üë((n + 1).choose (ŒΩ + 1)) * X ^ (ŒΩ + 1) * (‚Üë(n - ŒΩ) * (1 - X) ^ (n - ŒΩ - 1))) = (‚Üën + 1) * (‚Üë(n.choose ŒΩ) * X ^ ŒΩ * (1 - X) ^ (n - ŒΩ) - ‚Üë(n.choose (ŒΩ + 1)) * X ^ (ŒΩ + 1) * (1 - X) ^ (n - (ŒΩ + 1)))
{ simpa [polynomial.derivative_pow, ‚Üêsub_eq_add_neg], }
simpa [polynomial.derivative_pow, ‚Üêsub_eq_add_neg]
rw mul_sub
conv_rhs { rw mul_sub, }
refine congr (congr_arg has_sub.sub _) _
simp only [‚Üêmul_assoc]
refine congr (congr_arg (*) (congr (congr_arg (*) _) rfl)) rfl
exact_mod_cast congr_arg (Œª m : ‚Ñï, (m : polynomial R)) (nat.succ_mul_choose_eq n ŒΩ).symm
{ simp only [‚Üêmul_assoc], refine congr (congr_arg (*) (congr (congr_arg (*) _) rfl)) rfl, exact_mod_cast congr_arg (Œª m : ‚Ñï, (m : polynomial R)) (nat.succ_mul_choose_eq n ŒΩ).symm, }
rw [‚Üêmul_assoc,‚Üêmul_assoc]
congr' 1
rw nat.sub_sub
rw [‚Üêmul_assoc,‚Üêmul_assoc]
congr' 1
rw mul_comm
norm_cast
congr' 1
convert (nat.choose_mul_succ_eq n (ŒΩ + 1)).symm using 1
convert mul_comm _ _ using 2
{ convert mul_comm _ _ using 2, simp, }
simp
apply mul_comm
let x : mv_polynomial bool R := mv_polynomial.X tt
let y : mv_polynomial bool R := mv_polynomial.X ff
have pderiv_tt_x : pderiv tt x = 1
simp [x]
{ simp [x], }
have pderiv_tt_y : pderiv tt y = 0
simp [pderiv_X, y]
{ simp [pderiv_X, y], }
let e : bool ‚Üí polynomial R := Œª i, cond i X (1-X)
have h : (x+y)^n = (x+y)^n := rfl
apply_fun (pderiv tt) at h
apply_fun (pderiv tt) at h
apply_fun (aeval e) at h
apply_fun (Œª p, p * X^2) at h
have w : ‚àÄ k : ‚Ñï, ‚Üëk * (‚Üë(k-1) * polynomial.X ^ (k - 1 - 1)) * (1 - polynomial.X) ^ (n - k) * ‚Üë(n.choose k) * polynomial.X^2 = (k * (k-1)) ‚Ä¢ bernstein_polynomial R n k
rintro (_|k)
{ simp, }
simp
rcases k with (_|k)
{ simp, }
simp
dsimp [bernstein_polynomial]
simp only [‚Üênat_cast_mul, nat.succ_eq_add_one, nat.add_succ_sub_one, add_zero, pow_succ]
push_cast
{ rintro (_|k), { simp, }, { rcases k with (_|k), { simp, }, { dsimp [bernstein_polynomial], simp only [‚Üênat_cast_mul, nat.succ_eq_add_one, nat.add_succ_sub_one, add_zero, pow_succ], push_cast, ring, }, }, }
ring
conv at h { to_lhs, rw [add_pow, (pderiv tt).map_sum, (pderiv tt).map_sum, (mv_polynomial.aeval e).map_sum, finset.sum_mul], apply_congr, skip, simp [pderiv_mul, pderiv_tt_x, pderiv_tt_y, e, w] }
to_lhs
rw [add_pow, (pderiv tt).map_sum, (pderiv tt).map_sum, (mv_polynomial.aeval e).map_sum, finset.sum_mul]
skip
apply_congr
simp [pderiv_mul, pderiv_tt_x, pderiv_tt_y, e, w]
conv at h { to_rhs, simp only [pderiv_one, pderiv_mul, pderiv_pow, pderiv_nat_cast, (pderiv tt).map_add, pderiv_tt_x, pderiv_tt_y], simp [e, smul_smul] }
to_rhs
simp only [pderiv_one, pderiv_mul, pderiv_pow, pderiv_nat_cast, (pderiv tt).map_add, pderiv_tt_x, pderiv_tt_y]
simp [e, smul_smul]
simpa using h
norm_num [bernstein_polynomial, choose]
ring
dsimp [bernstein_polynomial]
simp [h, nat.sub_sub_assoc, mul_right_comm]
rw content_eq_gcd_range_of_lt p (max p.nat_degree q.nat_degree).succ (lt_of_le_of_lt (le_max_left _ _) (nat.lt_succ_self _))
rw content_eq_gcd_range_of_lt q (max p.nat_degree q.nat_degree).succ (lt_of_le_of_lt (le_max_right _ _) (nat.lt_succ_self _))
apply finset.gcd_eq_of_dvd_sub
intros x hx
cases h with w hw
use w.coeff x
rw [‚Üê coeff_sub, hw, coeff_C_mul]
apply is_homogeneous_monomial
simp only [finsupp.support_single_ne_zero one_ne_zero, finset.sum_singleton]
exact finsupp.single_eq_same
simp only [monic, leading_coeff, nat_degree_scale_roots, coeff_scale_roots_nat_degree]
apply le_order
rw [coeff_mul, finset.sum_eq_zero]
intros n hn
rintros ‚ü®i,j‚ü© hij
by_cases hi : ‚Üëi < order œÜ
{ rw [coeff_of_lt_order œÜ i hi, zero_mul] }
rw [coeff_of_lt_order œÜ i hi, zero_mul]
by_cases hj : ‚Üëj < order œà
{ rw [coeff_of_lt_order œà j hj, mul_zero] }
rw [coeff_of_lt_order œà j hj, mul_zero]
rw finset.nat.mem_antidiagonal at hij
rw not_lt at hi hj
exfalso
apply ne_of_lt (lt_of_lt_of_le hn $ add_le_add hi hj)
rw [‚Üê nat.cast_add, hij]
rw [order_monomial, if_neg h]
have := coe_monomial 0 (1:R)
rwa power_series.monomial_zero_eq_C_apply at this
simpa using coeff_add_monomial_mul 0 n œÜ a
refine ‚ü®h1, _‚ü©
intros l hl
apply dvd_trans _ (k.gcd_dvd_right l)
rw this
{ rw this }
suffices : k.gcd l = k
rw eq_iff_le_not_lt
refine ‚ü®nat.le_of_dvd hk (k.gcd_dvd_left l), _‚ü©
apply h _ (nat.gcd_pos_of_pos_left _ hk) h'
intro h'
exact pow_gcd_eq_one _ h1 hl
by_cases h0 : 0 ‚â§ i
lift i to ‚Ñï using h0
rw gpow_coe_nat
{ lift i to ‚Ñï using h0, rw gpow_coe_nat, exact h.pow_of_coprime i hi }
exact h.pow_of_coprime i hi
simp only [not_le, neg_nonneg] at h0 ‚ä¢
have : 0 ‚â§ -i
exact le_of_lt h0
{ simp only [not_le, neg_nonneg] at h0 ‚ä¢, exact le_of_lt h0 }
lift -i to ‚Ñï using this with i' hi'
rw [‚Üê inv_iff, ‚Üê gpow_neg, ‚Üê hi', gpow_coe_nat]
apply h.pow_of_coprime
rw [int.gcd, ‚Üê int.nat_abs_neg, ‚Üê hi'] at hi
exact hi
apply (eq_or_eq_neg_of_sq_eq_sq Œ∂ 1 _).resolve_left
apply h.pow_ne_one_of_pos_of_lt
apply h.pow_ne_one_of_pos_of_lt; dec_trivial
dec_trivial
dec_trivial
rw [‚Üê pow_one Œ∂]
{ rw [‚Üê pow_one Œ∂], apply h.pow_ne_one_of_pos_of_lt; dec_trivial }
simp only [h.pow_eq_one, one_pow]
obtain ‚ü®n, rfl‚ü© : ‚àÉ n : ‚Ñ§, Œ∂ ^ n = Œæ
rwa [‚Üê h.gpowers_eq] at hŒæ
exact_mod_cast k.pos
have hk0 : (0 : ‚Ñ§) < k := by exact_mod_cast k.pos
let i := n % k
have hi0 : 0 ‚â§ i := int.mod_nonneg _ (ne_of_gt hk0)
lift i to ‚Ñï using hi0 with i‚ÇÄ hi‚ÇÄ
refine ‚ü®i‚ÇÄ, _, _‚ü©
rw [hi‚ÇÄ]
exact int.mod_lt_of_pos _ hk0
{ zify, rw [hi‚ÇÄ], exact int.mod_lt_of_pos _ hk0 }
zify
rw [‚Üê coe_coe] at aux
have aux := h.gpow_eq_one
rw [‚Üê gpow_coe_nat, hi‚ÇÄ, ‚Üê int.mod_add_div n k, gpow_add, gpow_mul, aux, one_gpow, mul_one]
obtain ‚ü®d, rfl‚ü© := h
intros Œ∂ h
simp only [mem_roots_of_unity, pnat.mul_coe, pow_mul, one_pow, *] at *
apply eq_bot_or_eq_top
have h : (‚ä• : submodule R M) ‚â† ‚ä§ := bot_ne_top
contrapose! h
ext
simp [submodule.mem_bot,submodule.mem_top, h x]
rw [‚Üê ker_eq_bot, ‚Üê ker_eq_top]
rw [coe_range, coe_top]
apply tensor_product.induction_on x
{ simp, }
simp
intros a‚ÇÅ b‚ÇÅ
apply tensor_product.induction_on y
{ simp, }
simp
intros a‚ÇÇ b‚ÇÇ
{ intros a‚ÇÇ b‚ÇÇ, simp [mul_comm], }
simp [mul_comm]
intros a‚ÇÇ b‚ÇÇ ha hb
{ intros a‚ÇÅ b‚ÇÅ, apply tensor_product.induction_on y, { simp, }, { intros a‚ÇÇ b‚ÇÇ, simp [mul_comm], }, { intros a‚ÇÇ b‚ÇÇ ha hb, simp [mul_add, add_mul, ha, hb], }, }
simp [mul_add, add_mul, ha, hb]
intros x‚ÇÅ x‚ÇÇ h‚ÇÅ h‚ÇÇ
simp [mul_add, add_mul, h‚ÇÅ, h‚ÇÇ]
apply_instance
apply_instance
apply_instance
by_cases H : ‚àÉ (s : finset L), nonempty (basis s K L)
rw [trace_algebra_map_of_basis H.some_spec.some, finrank_eq_card_basis H.some_spec.some]
{ rw [trace_algebra_map_of_basis H.some_spec.some, finrank_eq_card_basis H.some_spec.some] }
simp [trace_eq_zero_of_not_exists_basis K H, finrank_eq_zero_of_not_exists_basis_finset H]
split
intros hg p ha hb hp
refine ((associates.prime_mk _).mpr hp).not_unit (is_unit_of_dvd_one _ _)
rw ‚Üê hg
exact le_inf (mk_le_mk_of_dvd ha) (mk_le_mk_of_dvd hb)
{ intros hg p ha hb hp, refine ((associates.prime_mk _).mpr hp).not_unit (is_unit_of_dvd_one _ _), rw ‚Üê hg, exact le_inf (mk_le_mk_of_dvd ha) (mk_le_mk_of_dvd hb) }
contrapose
intros hg hc
obtain ‚ü®p, hp, hpa, hpb‚ü© := exists_prime_dvd_of_not_inf_one ha0 hb0 hg
exact hc hpa hpb hp
obtain ‚ü®p, a_assoc, hp‚ü© := prime_factors_irreducible ha ‚ü®prime_of_factor, factors_prod ha.ne_zero‚ü©
have p_mem : p ‚àà factors a
exact multiset.mem_singleton_self _
{ rw hp, exact multiset.mem_singleton_self _ }
rw hp
convert hp
rwa [‚Üê normalize_factor p p_mem, normalize_eq_normalize_iff, dvd_dvd_iff_associated]
split
rintro ‚ü®c, rfl‚ü©
{ rintro ‚ü®c, rfl‚ü©, simp [hx, right_ne_zero_of_mul hy] }
simp [hx, right_ne_zero_of_mul hy]
rw [‚Üê (factors_prod hx).dvd_iff_dvd_left, ‚Üê (factors_prod hy).dvd_iff_dvd_right]
apply multiset.prod_dvd_prod
simp
simp [hx]
{ simp [hx] }
by_cases hx : x = 0
simp [hy]
{ simp [hy] }
by_cases hy : y = 0
simp [hx, hy]
intro x
dsimp
simp [hx]
{ simp [hx] }
by_cases hx : x = 0
have h : associates.mk_monoid_hom ‚àò (classical.some mk_surjective.has_right_inverse) = (id : associates Œ± ‚Üí associates Œ±)
ext x
rw [function.comp_apply, mk_monoid_hom_apply, classical.some_spec mk_surjective.has_right_inverse x]
{ ext x, rw [function.comp_apply, mk_monoid_hom_apply, classical.some_spec mk_surjective.has_right_inverse x], refl }
refl
rw [if_neg hx, ‚Üê mk_monoid_hom_apply, monoid_hom.map_multiset_prod, map_map, h, map_id, ‚Üê associated_iff_eq]
apply factors_prod hx
rw ‚Üê pow_dvd_iff_le_multiplicity
revert b
simp
{ simp }
induction n with n ih
intros b hb
split
rintro ‚ü®c, rfl‚ü©
rw [ne.def, pow_succ, mul_assoc, mul_eq_zero, decidable.not_or_iff_and_not] at hb
rw [pow_succ, mul_assoc, factors_mul hb.1 hb.2, repeat_succ, factors_irreducible ha, singleton_add, cons_le_cons_iff, ‚Üê ih hb.2]
{ rintro ‚ü®c, rfl‚ü©, rw [ne.def, pow_succ, mul_assoc, mul_eq_zero, decidable.not_or_iff_and_not] at hb, rw [pow_succ, mul_assoc, factors_mul hb.1 hb.2, repeat_succ, factors_irreducible ha, singleton_add, cons_le_cons_iff, ‚Üê ih hb.2], apply dvd.intro _ rfl }
apply dvd.intro _ rfl
rw [multiset.le_iff_exists_add]
rintro ‚ü®u, hu‚ü©
rw [‚Üê (factors_prod hb).dvd_iff_dvd_right, hu, prod_add, prod_repeat]
exact (associated.pow_pow $ associated_normalize a).dvd.trans (dvd.intro u.prod rfl)
simp
simp
rw [‚Üê factor_set.coe_add, prod_coe, prod_coe, prod_coe, multiset.map_add, multiset.prod_add]
rw [hpm.as_sum, eval‚ÇÇ_add, eval‚ÇÇ_pow, eval‚ÇÇ_X, eval‚ÇÇ_finset_sum, add_eq_zero_iff_eq_neg] at hpx
refine ne_of_gt _ hpx
replace hpx := congr_arg v hpx
rw [v.map_neg, v.map_pow]
refine v.map_sum_lt' (zero_lt_one''.trans_le (one_le_pow_of_one_le' hvx.le _)) (Œª i hi, _)
rw [eval‚ÇÇ_mul, eval‚ÇÇ_pow, eval‚ÇÇ_C, eval‚ÇÇ_X, v.map_mul, v.map_pow, ‚Üê one_mul (v x ^ p.nat_degree)]
cases (hv.2 $ p.coeff i).lt_or_eq with hvpi hvpi
exact mul_lt_mul'''' hvpi (pow_lt_pow' hvx $ finset.mem_range.1 hi)
{ exact mul_lt_mul'''' hvpi (pow_lt_pow' hvx $ finset.mem_range.1 hi) }
rw [one_mul, one_mul]
exact pow_lt_pow' hvx (finset.mem_range.1 hi)
erw hvpi
rw from_padic_int_comp_to_padic_int
simp [has_sub.sub, eval]
induction n with n ih
simp only [witt_mul_n, nat.cast_zero, zero_mul, bind‚ÇÅ_zero_witt_polynomial]
{ simp only [witt_mul_n, nat.cast_zero, zero_mul, bind‚ÇÅ_zero_witt_polynomial] }
rw [witt_mul_n, ‚Üê bind‚ÇÅ_bind‚ÇÅ, witt_add, witt_structure_int_prop]
simp only [alg_hom.map_add, nat.cast_succ, bind‚ÇÅ_X_right]
rw [add_mul, one_mul, bind‚ÇÅ_rename, bind‚ÇÅ_rename]
simp only [ih, function.uncurry, function.comp, bind‚ÇÅ_X_left, alg_hom.id_apply, matrix.cons_val_zero, matrix.head_cons, matrix.cons_val_one]
refine ‚ü®witt_structure_rat p Œ¶, _, _‚ü©
apply witt_structure_rat_prop
{ intro n, apply witt_structure_rat_prop }
intro n
intros œÜ H
funext n
rw show œÜ n = bind‚ÇÅ œÜ (bind‚ÇÅ (W_ ‚Ñö) (X_in_terms_of_W p ‚Ñö n)), { rw [bind‚ÇÅ_witt_polynomial_X_in_terms_of_W p, bind‚ÇÅ_X_right] }
rw [bind‚ÇÅ_witt_polynomial_X_in_terms_of_W p, bind‚ÇÅ_X_right]
rw [bind‚ÇÅ_bind‚ÇÅ]
exact eval‚ÇÇ_hom_congr (ring_hom.ext_rat _ _) (funext H) rfl
rw [submodule.eq_bot_iff]
intros x hx
ext
simp only [witt_vector.mem_ker_truncate, ideal.mem_infi, witt_vector.zero_coeff] at hx ‚ä¢
exact hx _ _ (nat.lt_succ_self _)
ext1 x
rw [‚Üê sub_eq_zero, ‚Üê ideal.mem_bot, ‚Üê infi_ker_truncate, ideal.mem_infi]
intro i
simp only [ring_hom.mem_ker, g_compat, ‚Üêring_hom.comp_apply, truncate_comp_lift, ring_hom.map_sub, sub_self]
simp only [witt_polynomial_eq_sum_C_mul_X_pow, sum_range_succ_comm, range_one, sum_singleton, one_mul, pow_one, C_1, pow_zero]
rw [fintype_card, nat_cast_inj, fintype.card_coe]
convert mk_preimage_of_subset_range _ _ h using 1
rw [image_eq_range] at h
refl
rw [mk_sep]
have := H i; rwa [‚Üê quot.out_eq (f i), ‚Üê quot.out_eq (g i)] at this
rwa [‚Üê quot.out_eq (f i), ‚Üê quot.out_eq (g i)] at this
have := H i
rw [‚Üê to_nat_cast 0, nat.cast_zero]
simp [bit0]
rw [‚Üê not_lt, ‚Üê not_lt, aleph_idx_lt]
simpa using cof_le_card 0
rw typein_enum; apply ordinal.lt_succ_self
apply ordinal.lt_succ_self
rw typein_enum
simp_rw [‚Üê succ_le]
exact ordinal.infinite_pigeonhole_card f (#Œ±).succ (succ_le.mpr w) (w'.trans (lt_succ_self _).le) ((lt_succ_self _).trans_le (succ_is_regular w').2.ge)
simp_rw [cardinal.infinite_iff] at ‚ä¢ w'
cases infinite_pigeonhole_card_lt f w w' with a ha
exact ‚ü®a, w'.trans ha.le‚ü©
rintro ‚ü®x‚ü©
apply quot.sound
apply zero_add_equiv
cases y
refl
cases x
dsimp [left] at h
have w‚ÇÅ : m ‚àà b
rw finset.mem_inter at h
{ rw finset.mem_inter at h, exact h.1 }
exact h.1
have w‚ÇÇ : (m.1, m.2 - 1) ‚àà b.erase m
simp only [finset.mem_erase]
fsplit
{ exact Œª w, pred_ne_self m.2 (congr_arg prod.snd w) }
exact Œª w, pred_ne_self m.2 (congr_arg prod.snd w)
rw finset.mem_inter at h
clear h
have h‚ÇÇ := h.2
rw finset.mem_map at h‚ÇÇ
rcases h‚ÇÇ with ‚ü®m', ‚ü®h‚ÇÇ, rfl‚ü©‚ü©
dsimp [shift_up]
{ simp only [finset.mem_erase], fsplit, { exact Œª w, pred_ne_self m.2 (congr_arg prod.snd w) }, { rw finset.mem_inter at h, have h‚ÇÇ := h.2, clear h, rw finset.mem_map at h‚ÇÇ, rcases h‚ÇÇ with ‚ü®m', ‚ü®h‚ÇÇ, rfl‚ü©‚ü©, dsimp [shift_up], simpa, }, }
simpa
have i‚ÇÅ := finset.card_erase_lt_of_mem w‚ÇÅ
have i‚ÇÇ := nat.lt_of_le_of_lt (nat.zero_le _) (finset.card_erase_lt_of_mem w‚ÇÇ)
exact nat.lt_of_le_of_lt i‚ÇÇ i‚ÇÅ
apply_instance
apply_instance
apply_instance
apply_instance
apply_instance
apply_instance
apply_instance
apply_instance
exfalso
exact turn_bound_ne_zero_of_left_move t.2 (nonpos_iff_eq_zero.mp h)
exfalso
exact turn_bound_ne_zero_of_right_move t.2 (nonpos_iff_eq_zero.mp h)
refine ‚ü®Œª h, _, Œª ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©, equiv.antisymm h‚ÇÅ h‚ÇÇ‚ü©
cases h with _ _ _ h‚ÇÅ h‚ÇÇ
{ simp [lists'.subset.refl] }
exact ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
simp [lists'.subset.refl]
apply_instance
simp only [mk_def, card_type]
resetI
split
split; intro h
intro h
intro h
exact let ‚ü®f‚ü© := h in ‚ü®f.to_embedding‚ü©
{ rw e at h, exact let ‚ü®f‚ü© := h in ‚ü®f.to_embedding‚ü© }
rw e at h
cases h with f
have g := rel_embedding.preimage f s
haveI := rel_embedding.is_well_order g
exact le_trans (ord_le_type _) (type_le'.2 ‚ü®g‚ü©)
simp at h ‚ä¢
simp only [ord_le, card_ord]
have h := g.1.map_rel_iff.1 h
rcases g.2 _ _ h with ‚ü®b, rfl‚ü©
exact ‚ü®a', rfl‚ü©
rcases f.2 _ _ h with ‚ü®a', rfl‚ü©
have ef : (f : Œ± ‚Üí Œ≤) = g
show ((f : r ‚âºi s) : Œ± ‚Üí Œ≤) = g
refl
{ show ((f : r ‚âºi s) : Œ± ‚Üí Œ≤) = g, rw @subsingleton.elim _ _ (f : r ‚âºi s) g, refl }
rw @subsingleton.elim _ _ (f : r ‚âºi s) g
have et : f.top = g.top
refine @is_extensional.ext _ s _ _ _ (Œª x, _)
simp only [f.down, g.down, ef, coe_fn_to_rel_embedding]
{ refine @is_extensional.ext _ s _ _ _ (Œª x, _), simp only [f.down, g.down, ef, coe_fn_to_rel_embedding] }
cases g
cases f
have := rel_embedding.coe_fn_injective ef
have := rel_embedding.coe_fn_injective ef; congr'
congr'
simp only [le_antisymm_iff, lift_le]
resetI
rw [mk_def, card_type, ‚Üê cardinal.lift_id'.{(max u v) u} (#Œ≤), ‚Üê cardinal.lift_umax.{u v}, lift_mk_eq.{u (max u v) (max u v)}] at e'
cases e' with f
have g := rel_iso.preimage f s
haveI := (g : ‚áëf ‚Åª¬π'o s ‚Ü™r s).is_well_order
have := lift_type_eq.{u (max u v) (max u v)}.2 ‚ü®g‚ü©
rw [lift_id, lift_umax.{u v}] at this
exact ‚ü®_, this‚ü©
cases lt_or_eq_of_le (one_le_iff_pos.2 h‚ÇÅ) with h‚ÇÅ h‚ÇÅ
{ exact (power_le_power_iff_right h‚ÇÅ).2 h‚ÇÇ }
exact (power_le_power_iff_right h‚ÇÅ).2 h‚ÇÇ
simp only [one_power]
subst a
simp only [n0, nat.div_zero, nat.cast_zero, div_zero]
rw [le_div n0', ‚Üê nat_cast_mul, nat_cast_le, mul_comm]; apply nat.div_mul_le_self
rw [le_div n0', ‚Üê nat_cast_mul, nat_cast_le, mul_comm]
apply nat.div_mul_le_self
rw [div_le n0', succ, ‚Üê nat.cast_succ, ‚Üê nat_cast_mul, nat_cast_lt, mul_comm, ‚Üê nat.div_lt_iff_lt_mul _ _ (nat.pos_of_ne_zero n0)]
rw [div_le n0', succ, ‚Üê nat.cast_succ, ‚Üê nat_cast_mul, nat_cast_lt, mul_comm, ‚Üê nat.div_lt_iff_lt_mul _ _ (nat.pos_of_ne_zero n0)]; apply nat.lt_succ_self
apply nat.lt_succ_self
simpa only [one_mul] using mul_le_mul_right omega (one_le_iff_pos.2 a0)
rw [h, ‚Üê e, lift_succ]
simp only [h, lift_succ]
rw [limit_rec_on, well_founded.fix_eq, dif_pos rfl]
rw [limit_rec_on, well_founded.fix_eq, dif_pos rfl]; refl
refl
rwa add_zero
rw [lt_sub, add_succ]
rw [lt_sub, add_succ]; exact l.2 _ (lt_sub.1 h)
exact l.2 _ (lt_sub.1 h)
rwa [zero_power', ordinal.sub_eq_zero_iff_le, one_le_iff_ne_zero]
simp only [pow, power, if_neg a0]; rw limit_rec_on_limit _ _ _ _ h; refl
simp only [pow, power, if_neg a0]; rw limit_rec_on_limit _ _ _ _ h
rw limit_rec_on_limit _ _ _ _ h
simp only [pow, power, if_neg a0]
cases o
cases o; exact NF.zero
exact NF.zero
exact NF.zero
rwa ‚Üê((eq_empty y).2 $ Œª z zx, n ‚ü®z, zx‚ü©)
simp [Inf_eq_infi, infi_and]
conversion infi_eq_elim.old_conv
simp [Sup_eq_supr, supr_and]
conversion supr_eq_elim.old_conv
simp [bit0]
simp [bit1, bit0]
simpa [eq.symm h1, eq.symm h2, int.coe_nat_lt]
simp *
apply h
rw [‚Üê hx,‚Üê hy]
rwa [‚Üê e2, ‚Üê e1, ‚Üê hn, normalize_fin, add_comm, nat.add_mul_mod_self_left] at h
simp only [normalize_fin, ‚Üê h] at *; rw [nat.add_mod, ‚Üê ha, ‚Üê hb, fin.add_def]
rw [nat.add_mod, ‚Üê ha, ‚Üê hb, fin.add_def]
simp only [normalize_fin, ‚Üê h] at *
simp [bit0, add_left_comm, add_assoc]
simp [bit0, add_left_comm, add_assoc]
apply h
apply h
apply h
preform.induce `[intros v h, try {apply h}]
cases p with t s t s; try {apply h}
try {apply h}
try {apply h}
try {apply h}
try {apply h}
try {apply h}
apply h
cases p with t s t s
apply or.symm
simpa only [preform.holds, le_and_le_iff_eq.symm, not_and_distrib, not_le] using h
{ apply or.symm, simpa only [preform.holds, le_and_le_iff_eq.symm, not_and_distrib, not_le] using h }
simpa only [preform.holds, not_le, int.add_one_le_iff] using h
{ cases p with t s t s; try {apply h}, { apply or.symm, simpa only [preform.holds, le_and_le_iff_eq.symm, not_and_distrib, not_le] using h }, simpa only [preform.holds, not_le, int.add_one_le_iff] using h }
cases h
cases h; [{left, apply ihp}, {right, apply ihq}]; assumption
cases h; [{left, apply ihp}, {right, apply ihq}]
simp only [neg_elim_core]
apply ihp
right
apply ihq
left
{ simp only [neg_elim_core], cases h; [{left, apply ihp}, {right, apply ihq}]; assumption }
assumption
assumption
apply and.imp (ihp _) (ihq _) h
simp [h‚ÇÉ.symm, h‚ÇÇ.symm, h‚ÇÅ.symm, horner, add_mul, mul_comm (x ^ n)]
simp [h‚ÇÉ.symm, h‚ÇÇ.symm, h‚ÇÅ.symm, horner, add_mul, mul_comm (x ^ n)]; cc
cc
rw ‚Üê (horner_expr.cseval_of_csexpr t _).2
rw ‚Üê (horner_expr.cseval_of_csexpr t _).2
rw ‚Üê (horner_expr.cseval_of_csexpr t _).2
repeat {rw ‚Üê (horner_expr.cseval_of_csexpr t _).2}
repeat {rw ‚Üê (horner_expr.cseval_of_csexpr t _).2}; rw H
rw H
apply ne_of_gt
apply nat.lt_add_of_pos_right
apply nat.pos_of_ne_zero
contradiction
simp only [list.apply_id]
cases h‚ÇÉ : (lookup x (map prod.to_sigma (xs.zip ys)))
dsimp [option.get_or_else]
{ dsimp [option.get_or_else], rw h‚ÇÅ.mem_iff }
rw h‚ÇÅ.mem_iff
have h‚ÇÇ : ys.nodup := h‚ÇÅ.nodup_iff.1 h‚ÇÄ
replace h‚ÇÅ : xs.length = ys.length := h‚ÇÅ.length_eq
dsimp
induction xs generalizing ys
case list.nil : ys h‚ÇÉ h‚ÇÇ h‚ÇÅ { contradiction }
contradiction
case list.cons : x' xs xs_ih ys h‚ÇÉ h‚ÇÇ h‚ÇÅ { cases ys with y ys, { cases h‚ÇÉ }, dsimp [lookup] at h‚ÇÉ, split_ifs at h‚ÇÉ, { subst x', subst val, simp only [mem_cons_iff, true_or, eq_self_iff_true], }, { cases h‚ÇÄ with _ _ h‚ÇÄ h‚ÇÖ, cases h‚ÇÇ with _ _ h‚ÇÇ h‚ÇÑ, have h‚ÇÜ := nat.succ.inj h‚ÇÅ, specialize @xs_ih h‚ÇÖ ys h‚ÇÉ h‚ÇÑ h‚ÇÜ, simp only [ne.symm h, xs_ih, mem_cons_iff, false_or], suffices : val ‚àà ys, tauto!, erw [‚Üê option.mem_def, mem_lookup_iff] at h‚ÇÉ, simp only [to_sigma, mem_map, heq_iff_eq, prod.exists] at h‚ÇÉ, rcases h‚ÇÉ with ‚ü®a, b, h‚ÇÉ, h‚ÇÑ, h‚ÇÖ‚ü©, subst a, subst b, apply (mem_zip h‚ÇÉ).2, simp only [nodupkeys, keys, comp, prod.fst_to_sigma, map_map], rwa map_fst_zip _ _ (le_of_eq h‚ÇÜ) } }
cases ys with y ys
{ cases h‚ÇÉ }
cases h‚ÇÉ
split_ifs at h‚ÇÉ
dsimp [lookup] at h‚ÇÉ
subst val
subst x'
{ subst x', subst val, simp only [mem_cons_iff, true_or, eq_self_iff_true], }
simp only [mem_cons_iff, true_or, eq_self_iff_true]
cases h‚ÇÄ with _ _ h‚ÇÄ h‚ÇÖ
cases h‚ÇÇ with _ _ h‚ÇÇ h‚ÇÑ
have h‚ÇÜ := nat.succ.inj h‚ÇÅ
specialize @xs_ih h‚ÇÖ ys h‚ÇÉ h‚ÇÑ h‚ÇÜ
simp only [ne.symm h, xs_ih, mem_cons_iff, false_or]
tauto!
suffices : val ‚àà ys
erw [‚Üê option.mem_def, mem_lookup_iff] at h‚ÇÉ
simp only [to_sigma, mem_map, heq_iff_eq, prod.exists] at h‚ÇÉ
rcases h‚ÇÉ with ‚ü®a, b, h‚ÇÉ, h‚ÇÑ, h‚ÇÖ‚ü©
subst b
subst a
apply (mem_zip h‚ÇÉ).2
simp only [nodupkeys, keys, comp, prod.fst_to_sigma, map_map]
rwa map_fst_zip _ _ (le_of_eq h‚ÇÜ)
simp only [tendsto_pure_left, has_basis_coclosed_compact.tendsto_left_iff, forall_and_distrib, and_assoc, exists_prop]
rw [continuous_at, nhds_coe_eq, tendsto_map'_iff, continuous_at]
refine ‚ü®Œª h, _, Œª h, _‚ü©
exact (h.comp continuous_fst).mul continuous_snd
simp only [algebra.smul_def]
{ simp only [algebra.smul_def], exact (h.comp continuous_fst).mul continuous_snd }
exact h.comp (continuous_id.prod_mk continuous_const)
rw algebra_map_eq_smul_one'
rw ‚Üê nhds_within_Ico_eq_nhds_within_Ici (lt_add_one (n : Œ±))
simpa only [floor_coe] using (continuous_on_floor n _ (left_mem_Ico.mpr $ lt_add_one (_ : Œ±))).tendsto
rw [continuous_at, nhds_prod_eq, nhds_eq, nhds_eq, nhds_eq, filter.prod_map_map_eq, tendsto_map'_iff]
suffices : tendsto ((Œªx:G, (a + b) + x) ‚àò (Œªp:G√óG,p.1 + p.2)) (Z G √ó·∂† Z G) (map (Œªx:G, (a + b) + x) (Z G))
{ simpa [(‚àò), add_comm, add_left_comm] }
simpa [(‚àò), add_comm, add_left_comm]
exact tendsto_map.comp add_Z
simpa [f]
use [s * t‚ÇÇ, ht‚ÇÇ.mul_left, Œª x hx, ‚ü®x, 1, hx, one_mem_t‚ÇÇ, mul_one _‚ü©]
rw [nhds_within, inf_principal_eq_bot, mem_nhds_iff]
refine ‚ü®t‚ÇÅ, _, ht‚ÇÅ, a_mem_t‚ÇÅ‚ü©
rintros x hx ‚ü®y, z, hy, hz, yz‚ü©
have : x * z‚Åª¬π ‚àà s·∂ú := (prod_subset_iff.1 t_subset) x hx z hz
rw ‚Üê yz
simpa
have : x * z‚Åª¬π ‚àà s
contradiction
by_cases hP : P; simp [hP]
simp [hP]
simp [hP]
by_cases hP : P
simp [ha]
rw [tsum_eq_zero_of_not_summable hf, tsum_eq_zero_of_not_summable (mt (summable_mul_right_iff ha).2 hf), zero_mul]
by_cases hg : summable g
{ exact hg.has_sum.nonneg h }
exact hg.has_sum.nonneg h
simp [tsum_eq_zero_of_not_summable hg]
by_cases hf : summable f
{ exact hf.has_sum.nonpos h }
exact hf.has_sum.nonpos h
simp [tsum_eq_zero_of_not_summable hf]
refl
ext x
simp
simp
rw [‚Üê smul_eq_mul, ‚Üê map_smul, smul_eq_mul, mul_one, symm_apply_apply]
rw [‚Üê smul_eq_mul, ‚Üê map_smul, smul_eq_mul, mul_one, apply_symm_apply]
simp
simp
rw set_like.ext'_iff at hs ‚ä¢
simp only [submodule.topological_closure_coe, submodule.top_coe, ‚Üê dense_iff_closure_eq] at hs ‚ä¢
exact hf'.dense_image f.continuous hs
refine { zero := 0, add := (+), neg := has_neg.neg, sub := has_sub.sub, sub_eq_add_neg := _, nsmul := Œª n f, { to_fun := Œª x, n ‚Ä¢ (f x), map_add' := by simp, map_smul' := by simp [smul_comm n] }, gsmul := Œª n f, { to_fun := Œª x, n ‚Ä¢ (f x), map_add' := by simp, map_smul' := by simp [smul_comm n] }, gsmul_zero' := Œª f, by { ext, simp }, gsmul_succ' := Œª n f, by { ext, simp [add_smul, add_comm] }, gsmul_neg' := Œª n f, by { ext, simp [nat.succ_eq_add_one, add_smul], }, .. continuous_linear_map.add_comm_monoid, .. }
simp
simp [smul_comm n]
simp
simp [smul_comm n]
ext
simp
ext
simp [add_smul, add_comm]
ext
simp [nat.succ_eq_add_one, add_smul]
refine { zero := 0, add := (+), neg := has_neg.neg, sub := has_sub.sub, sub_eq_add_neg := _, nsmul := Œª n f, { to_fun := Œª x, n ‚Ä¢ (f x), map_add' := by simp, map_smul' := by simp [smul_comm n] }, gsmul := Œª n f, { to_fun := Œª x, n ‚Ä¢ (f x), map_add' := by simp, map_smul' := by simp [smul_comm n] }, gsmul_zero' := Œª f, by { ext, simp }, gsmul_succ' := Œª n f, by { ext, simp [add_smul, add_comm] }, gsmul_neg' := Œª n f, by { ext, simp [nat.succ_eq_add_one, add_smul], }, .. continuous_linear_map.add_comm_monoid, .. }; intros; ext; apply_rules [zero_add, add_assoc, add_zero, add_left_neg, add_comm, sub_eq_add_neg]
refine { zero := 0, add := (+), neg := has_neg.neg, sub := has_sub.sub, sub_eq_add_neg := _, nsmul := Œª n f, { to_fun := Œª x, n ‚Ä¢ (f x), map_add' := by simp, map_smul' := by simp [smul_comm n] }, gsmul := Œª n f, { to_fun := Œª x, n ‚Ä¢ (f x), map_add' := by simp, map_smul' := by simp [smul_comm n] }, gsmul_zero' := Œª f, by { ext, simp }, gsmul_succ' := Œª n f, by { ext, simp [add_smul, add_comm] }, gsmul_neg' := Œª n f, by { ext, simp [nat.succ_eq_add_one, add_smul], }, .. continuous_linear_map.add_comm_monoid, .. }; intros; ext
refine { zero := 0, add := (+), neg := has_neg.neg, sub := has_sub.sub, sub_eq_add_neg := _, nsmul := Œª n f, { to_fun := Œª x, n ‚Ä¢ (f x), map_add' := by simp, map_smul' := by simp [smul_comm n] }, gsmul := Œª n f, { to_fun := Œª x, n ‚Ä¢ (f x), map_add' := by simp, map_smul' := by simp [smul_comm n] }, gsmul_zero' := Œª f, by { ext, simp }, gsmul_succ' := Œª n f, by { ext, simp [add_smul, add_comm] }, gsmul_neg' := Œª n f, by { ext, simp [nat.succ_eq_add_one, add_smul], }, .. continuous_linear_map.add_comm_monoid, .. }; intros
apply_rules [zero_add, add_assoc, add_zero, add_left_neg, add_comm, sub_eq_add_neg]
apply_rules [zero_add, add_assoc, add_zero, add_left_neg, add_comm, sub_eq_add_neg]
intros
intros
ext
ext
apply_instance
refine continuous_iff_continuous_at.2 (Œª x, _)
rcases hf x with ‚ü®U, hxU, hUf‚ü©
have : continuous_at (Œª x, ‚àè i in hUf.to_finset, f i x) x
from tendsto_finset_prod _ (Œª i hi, (hc i).continuous_at)
refine this.congr (mem_of_superset hxU $ Œª y hy, _)
refine (finprod_eq_prod_of_mul_support_subset _ (Œª i hi, _)).symm
rw [hUf.coe_to_finset]
exact ‚ü®y, hi, hy‚ü©
rw [nhds_within_union, ht‚ÇÅa, ht‚ÇÇa, bot_sup_eq]
rw ((nhds_basis_Ioo_pos (1 : Œ±)).prod $ nhds_basis_Ioo_pos (1 : Œ±)).tendsto_iff (nhds_basis_Ioo_pos_of_pos (zero_lt_one : (0 : Œ±) < 1))
intros Œµ hŒµ
linarith
have hŒµ' : 0 ‚â§ 1 - Œµ / 4 := by linarith
linarith
have Œµ_pos : 0 < Œµ / 4 := by linarith
linarith
have Œµ_pos' : 0 < Œµ / 2 := by linarith
simp only [and_imp, prod.forall, mem_Ioo, function.uncurry_apply_pair, mem_prod, prod.exists]
refine ‚ü®Œµ/4, Œµ/4, ‚ü®Œµ_pos, Œµ_pos‚ü©, Œª a b ha ha' hb hb', _‚ü©
have ha0 : 0 ‚â§ a := le_trans hŒµ' (le_of_lt ha)
have hb0 : 0 ‚â§ b := le_trans hŒµ' (le_of_lt hb)
refine ‚ü®lt_of_le_of_lt _ (mul_lt_mul'' ha hb hŒµ' hŒµ'), lt_of_lt_of_le (mul_lt_mul'' ha' hb' ha0 hb0) _‚ü©
ring_nf
calc 1 - Œµ = 1 - Œµ / 2 - Œµ/2 : by ring_nf ... ‚â§ 1 - Œµ/2 - Œµ/2 + (Œµ/2)*(Œµ/2) : le_add_of_nonneg_right (le_of_lt (mul_pos Œµ_pos' Œµ_pos')) ... = (1 - Œµ/2) * (1 - Œµ/2) : by ring_nf ... ‚â§ (1 - Œµ/4) * (1 - Œµ/4) : mul_le_mul (by linarith) (by linarith) (by linarith) hŒµ'
ring_nf
linarith
linarith
{ calc 1 - Œµ = 1 - Œµ / 2 - Œµ/2 : by ring_nf ... ‚â§ 1 - Œµ/2 - Œµ/2 + (Œµ/2)*(Œµ/2) : le_add_of_nonneg_right (le_of_lt (mul_pos Œµ_pos' Œµ_pos')) ... = (1 - Œµ/2) * (1 - Œµ/2) : by ring_nf ... ‚â§ (1 - Œµ/4) * (1 - Œµ/4) : mul_le_mul (by linarith) (by linarith) (by linarith) hŒµ' }
calc (1 + Œµ/4) * (1 + Œµ/4) = 1 + Œµ/2 + (Œµ/4)*(Œµ/4) : by ring_nf ... = 1 + Œµ/2 + (Œµ * Œµ) / 16 : by ring_nf ... ‚â§ 1 + Œµ/2 + Œµ/2 : add_le_add_left (div_le_div (le_of_lt hŒµ.1) (le_trans ((mul_le_mul_left hŒµ.1).2 hŒµ.2) (le_of_eq $ mul_one Œµ)) zero_lt_two (by linarith)) (1 + Œµ/2) ... ‚â§ 1 + Œµ : by ring_nf
ring_nf
ring_nf
linarith
ring_nf
refine (has_basis.tendsto_iff at_top_basis ‚ü®Œª s, mem_nhds_within_Ioi_iff_exists_Ioc_subset‚ü©).2 _
refine Œª b hb, ‚ü®b‚Åª¬π, trivial, Œª x hx, _‚ü©
have : 0 < x := lt_of_lt_of_le (inv_pos.2 hb) hx
exact ‚ü®inv_pos.2 this, (inv_le this hb).2 hx‚ü©
simp [frontier]
refine @map_coe_at_top_of_Ioo_subset (order_dual Œ±) _ _ _ _ a s ha (Œª b' hb', _)
rcases hs b' hb' with ‚ü®b, hab, hbs‚ü©
use [b, hab]
rwa dual_Ioo
cases le_total (f a) (f b); simp [*, is_preconnected_interval.intermediate_value]
simp [*, is_preconnected_interval.intermediate_value]
simp [*, is_preconnected_interval.intermediate_value]
cases le_total (f a) (f b)
simp only [continuous_within_at, nhds_within_Ioo_eq_nhds_within_Ioi h]
simpa only [dual_Ico] using @nhds_within_Ico_eq_nhds_within_Ici (order_dual Œ±) _ _ _ _ _ h
convert is_closed_closure
simpa using hf.tendsto
let Nx := ùìù x‚ÇÄ
let ee := Œª u : Œ≤ √ó Œ≤, (e u.1, e u.2)
have lim1 : tendsto (Œª a : Œ≤ √ó Œ≤, (a.2 - a.1, y‚ÇÅ)) (comap e Nx √ó·∂† comap e Nx) (ùìù (0, y‚ÇÅ))
have := tendsto.prod_mk (tendsto_sub_comap_self de x‚ÇÄ) (tendsto_const_nhds : tendsto (Œª (p : Œ≤ √ó Œ≤), y‚ÇÅ) (comap ee $ ùìù (x‚ÇÄ, x‚ÇÄ)) (ùìù y‚ÇÅ))
rw [nhds_prod_eq, prod_comap_comap_eq, ‚Üênhds_prod_eq]
{ have := tendsto.prod_mk (tendsto_sub_comap_self de x‚ÇÄ) (tendsto_const_nhds : tendsto (Œª (p : Œ≤ √ó Œ≤), y‚ÇÅ) (comap ee $ ùìù (x‚ÇÄ, x‚ÇÄ)) (ùìù y‚ÇÅ)), rw [nhds_prod_eq, prod_comap_comap_eq, ‚Üênhds_prod_eq], exact (this : _) }
exact (this : _)
have lim2 : tendsto Œ¶ (ùìù (0, y‚ÇÅ)) (ùìù 0)
simpa using hœÜ.tendsto (0, y‚ÇÅ)
have lim := lim2.comp lim1
rw tendsto_prod_self_iff at lim
exact lim W' W'_nhd
simp only [exists_prop, and_assoc]
simp only [‚Üê and_assoc]
apply inter_subset_left
exact image_closure_subset_closure_image h
rw ‚Üê set.image_subset_iff
rw ‚Üê subset_interior_iff_open; simp only [subset_def, mem_interior]
simp only [subset_def, mem_interior]
rw ‚Üê subset_interior_iff_open
split
intro hx
simp_rw [set.preimage_Union, set.mem_Union]
obtain ‚ü®_, ‚ü®s,rfl‚ü©, _, ‚ü®hs, rfl‚ü©, hh‚ü© := hG hx
refine ‚ü®s, hs, _‚ü©
dsimp only [W] at hh ‚ä¢
{ intro hx, simp_rw [set.preimage_Union, set.mem_Union], obtain ‚ü®_, ‚ü®s,rfl‚ü©, _, ‚ü®hs, rfl‚ü©, hh‚ü© := hG hx, refine ‚ü®s, hs, _‚ü©, dsimp only [W] at hh ‚ä¢, rwa [dif_pos hs, ‚Üê set.preimage_comp, ‚Üê Profinite.coe_comp, C.w] }
rwa [dif_pos hs, ‚Üê set.preimage_comp, ‚Üê Profinite.coe_comp, C.w]
intro hx
simp_rw [set.preimage_Union, set.mem_Union] at hx
obtain ‚ü®s,hs,hx‚ü© := hx
rw h
refine ‚ü®s.1,s.2,_‚ü©
rw (hV s).2
dsimp only [W] at hx
rwa [dif_pos hs, ‚Üê set.preimage_comp, ‚Üê Profinite.coe_comp, C.w] at hx
have hB := Top.is_topological_basis_cofiltered_limit (F ‚ãô Profinite.to_Top) (Profinite.to_Top.map_cone C) (is_limit_of_preserves _ hC) (Œª j, {W | is_clopen W}) _ (Œª i, is_clopen_univ) (Œª i U1 U2 hU1 hU2, hU1.inter hU2) _
rotate
intros i
change topological_space.is_topological_basis {W : set (F.obj i) | is_clopen W}
{ intros i, change topological_space.is_topological_basis {W : set (F.obj i) | is_clopen W}, apply is_topological_basis_clopen }
apply is_topological_basis_clopen
rintros i j f V (hV : is_clopen _)
refine ‚ü®hV.1.preimage _, hV.2.preimage _‚ü©; continuity
refine ‚ü®hV.1.preimage _, hV.2.preimage _‚ü©
{ rintros i j f V (hV : is_clopen _), refine ‚ü®hV.1.preimage _, hV.2.preimage _‚ü©; continuity }
continuity
obtain ‚ü®S,hS,h‚ü© := hB.open_eq_sUnion hU.1
clear hB
let j : S ‚Üí J := Œª s, (hS s.2).some
let V : Œ† (s : S), set (F.obj (j s)) := Œª s, (hS s.2).some_spec.some
have hV : ‚àÄ (s : S), is_clopen (V s) ‚àß s.1 = C.œÄ.app (j s) ‚Åª¬π' (V s) := Œª s, (hS s.2).some_spec.some_spec
have := hU.2.is_compact.elim_finite_subcover (Œª s : S, C.œÄ.app (j s) ‚Åª¬π' (V s)) _ _
rotate
intros s
refine (hV s).1.1.preimage _
{ intros s, refine (hV s).1.1.preimage _, continuity }
continuity
dsimp only
rw h
rintro x ‚ü®T,hT,hx‚ü©
refine ‚ü®_,‚ü®‚ü®T,hT‚ü©,rfl‚ü©,_‚ü©
dsimp only
{ dsimp only, rw h, rintro x ‚ü®T,hT,hx‚ü©, refine ‚ü®_,‚ü®‚ü®T,hT‚ü©,rfl‚ü©,_‚ü©, dsimp only, rwa ‚Üê (hV ‚ü®T,hT‚ü©).2 }
rwa ‚Üê (hV ‚ü®T,hT‚ü©).2
obtain ‚ü®G,hG‚ü© := this
obtain ‚ü®j0,hj0‚ü© := is_cofiltered.inf_objs_exists (G.image j)
let f : Œ† (s : S) (hs : s ‚àà G), j0 ‚ü∂ j s := Œª s hs, (hj0 (finset.mem_image.mpr ‚ü®s,hs,rfl‚ü©)).some
let W : S ‚Üí set (F.obj j0) := Œª s, if hs : s ‚àà G then F.map (f s hs) ‚Åª¬π' (V s) else set.univ
refine ‚ü®j0, ‚ãÉ (s : S) (hs : s ‚àà G), W s, _, _‚ü©
apply is_clopen_bUnion
intros s hs
dsimp only [W]
rw dif_pos hs
refine ‚ü®(hV s).1.1.preimage _, (hV s).1.2.preimage _‚ü©; continuity
refine ‚ü®(hV s).1.1.preimage _, (hV s).1.2.preimage _‚ü©
{ apply is_clopen_bUnion, intros s hs, dsimp only [W], rw dif_pos hs, refine ‚ü®(hV s).1.1.preimage _, (hV s).1.2.preimage _‚ü©; continuity }
continuity
ext x
exact connected_component_rel_iff
rw not_iff_not
continuity
simpa using ht
ext f
ext f; simp [s_eq.symm, pi]
simp [s_eq.symm, pi]
let S : A ‚Üí set Œ± := coe
let F : Œ† i : A, C(i, Œ≤) := Œª i, F i i.prop
refine lift_cover S F (Œª i j, hF i i.prop j j.prop) _
intros x
obtain ‚ü®s, hs, hsx‚ü© := hA x
exact ‚ü®‚ü®s, hs‚ü©, hsx‚ü©
simp
ext x
ext x; exact eq_of_dist_eq_zero (le_antisymm (hfg ‚ñ∏ dist_coe_le_dist _) dist_nonneg)
exact eq_of_dist_eq_zero (le_antisymm (hfg ‚ñ∏ dist_coe_le_dist _) dist_nonneg)
simp [dist_eq, dist_comm]
ext
ext; simp [add_assoc]
simp [add_assoc]
ext
ext; simp
simp
ext
ext; simp
simp
ext
ext; simp
simp
ext
ext; simp [add_comm]
simp [add_comm]
ext
apply sub_eq_add_neg
rw dist_le (mul_nonneg dist_nonneg dist_nonneg)
intros x
refine (dist_smul_pair c (f‚ÇÅ x) (f‚ÇÇ x)).trans _
exact mul_le_mul_of_nonneg_left (dist_coe_le_dist x) dist_nonneg
rw dist_le (mul_nonneg dist_nonneg dist_nonneg)
intros x
refine (dist_pair_smul c‚ÇÅ c‚ÇÇ (f x)).trans _
convert mul_le_mul_of_nonneg_left (dist_coe_le_dist x) dist_nonneg
simp
ext
ext; simp
simp
ext
ext; simp
simp
refine ((comp_right_continuous_map ‚Ñù (attach_bound (f : C(X, ‚Ñù)))).continuous_at p).tendsto .frequently_map _ _ frequently_mem_polynomials
rintros _ ‚ü®g, ‚ü®-,rfl‚ü©‚ü©
simp only [set_like.mem_coe, alg_hom.coe_to_ring_hom, comp_right_continuous_map_apply, polynomial.to_continuous_map_on_alg_hom_apply]
apply polynomial_comp_attach_bound_mem
have mem_closure : p ‚àà (polynomial_functions (set.Icc (-‚à•f‚à•) (‚à•f‚à•))).topological_closure := continuous_map_mem_polynomial_functions_closure _ _ p
have frequently_mem_polynomials := mem_closure_iff_frequently.mp mem_closure
apply mem_closure_iff_frequently.mpr
simp only [nhds_within, nhds_pi, comap_inf, comap_infi, pi_def, comap_principal, ‚Üê infi_principal_finite hI, ‚Üê infi_inf_eq]
rw [hf.to_embedding.map_nhds_within_eq, image_preimage_eq_inter_range]
apply nhds_within_eq_nhds_within (mem_range_self _) hf.open_range
rw [inter_assoc, inter_self]
tauto
ext ‚ü®‚ü©
refl
change ite _ _ _ = _
split_ifs
rw [extend, continuous_map.coe_Icc_extend, set.Icc_extend_of_mem]
{ rw [extend, continuous_map.coe_Icc_extend, set.Icc_extend_of_mem], refl }
refl
rw [extend, continuous_map.coe_Icc_extend, set.Icc_extend_of_mem]
refl
rw [nhds_bot', mem_infi_of_directed]
{ refl }
refl
simp [le_refl]
exact Œª x y, ‚ü®min x y, by simp [le_refl], by simp [le_refl]‚ü©
simp [le_refl]
rw real.closed_ball_eq
apply is_compact_Icc
rw [real.image_interval h, interval_subset_interval_iff_mem, ‚Üê real.image_interval h]
exact ‚ü®mem_image_of_mem f hx, mem_image_of_mem f hy‚ü©
rw [e.map_nhds_within_eq hx, e.image_source_inter_eq', e.target_inter_inv_preimage_preimage, e.nhds_within_target_inter (e.map_source hx)]
dsimp only [trans_to_local_equiv, prod_to_local_equiv]; apply local_equiv.prod_trans
apply local_equiv.prod_trans
dsimp only [trans_to_local_equiv, prod_to_local_equiv]
rw [hgf.right, ‚Üê continuous_iff_coinduced_le]; apply continuous_coinduced_rng.comp hf
rw [hgf.right, ‚Üê continuous_iff_coinduced_le]
apply continuous_coinduced_rng.comp hf
rwa ‚Üê continuous_iff_coinduced_le
ext s
show is_open s ‚Üî is_open (f ‚Åª¬π' s)
split
{ exact continuous_def.1 cont s }
exact continuous_def.1 cont s
assume h
rw ‚Üê surj.image_preimage s
exact open_map _ h
intros s hs
rcases hf.is_closed_iff.1 hs with ‚ü®t, ht, rfl‚ü©
rw image_preimage_eq_inter_range
exact is_closed.inter ht h
convert is_closed_univ
convert is_closed_univ; apply range_id
apply range_id
rw [metric.uniformity_eq_comap_nhds_zero, tendsto_comap_iff]
lift r to ‚Ñù‚â•0 using hr
simp [nndist_pi_def]
simp [dist_pi_le_iff hr]
ext p
intros f hf
obtain ‚ü®t, t_fset, ht‚ü© : ‚àÉ t ‚àà f, ‚àÄ x y ‚àà t, dist x y < 1 := (metric.cauchy_iff.1 hf).2 1 zero_lt_one
rcases hf.1.nonempty_of_mem t_fset with ‚ü®x, xt‚ü©
have : closed_ball x 1 ‚àà f := mem_of_superset t_fset (Œª y yt, (ht y x yt xt).le)
rcases (compact_iff_totally_bounded_complete.1 (proper_space.is_compact_closed_ball x 1)).2 f hf (le_principal_iff.2 this) with ‚ü®y, -, hy‚ü©
exact ‚ü®y, hy‚ü©
unfold diam
rw ennreal.to_real_le_to_real (bounded.subset h ht).ediam_ne_top ht.ediam_ne_top
exact emetric.diam_mono h
simpa [le_antisymm_iff, dist_nonneg] using @dist_eq_zero _ _ x y
assume x y x' y' hxx' hyy'
have Hxx' : dist x x' = 0 := hxx'
have Hyy' : dist y y' = 0 := hyy'
have A : dist x y ‚â§ dist x' y' := calc dist x y ‚â§ dist x x' + dist x' y : pseudo_metric_space.dist_triangle _ _ _ ... = dist x' y : by simp [Hxx'] ... ‚â§ dist x' y' + dist y' y : pseudo_metric_space.dist_triangle _ _ _ ... = dist x' y' : by simp [pseudo_metric_space.dist_comm, Hyy']
simp [Hxx']
simp [pseudo_metric_space.dist_comm, Hyy']
have B : dist x' y' ‚â§ dist x y := calc dist x' y' ‚â§ dist x' x + dist x y' : pseudo_metric_space.dist_triangle _ _ _ ... = dist x y' : by simp [pseudo_metric_space.dist_comm, Hxx'] ... ‚â§ dist x y + dist y y' : pseudo_metric_space.dist_triangle _ _ _ ... = dist x y : by simp [Hyy']
simp [pseudo_metric_space.dist_comm, Hxx']
simp [Hyy']
exact le_antisymm A B
simp [nndist, edist_dist, real.to_nnreal, max_eq_left dist_nonneg, ennreal.of_real]
simp [dist_comm, uniform_space.ball]
ext
simp [dist_comm]
simp [edist_dist]
rw ennreal.of_real_le_of_real_iff h
ext y
ext y; simp [edist_dist]; rw ennreal.of_real_le_of_real_iff h
ext y; simp [edist_dist]
rw edist_comm
rw edist_comm; refl
refl
cases x; cases y; simp only [sum.dist, dist_comm, add_comm, add_left_comm]
cases x; cases y
cases y
cases y
simp only [sum.dist, dist_comm, add_comm, add_left_comm]
simp only [sum.dist, dist_comm, add_comm, add_left_comm]
simp only [sum.dist, dist_comm, add_comm, add_left_comm]
simp only [sum.dist, dist_comm, add_comm, add_left_comm]
cases x
{ assume n, have X2n : X2 n = range ((coeZ ‚àò (Œ¶ n.succ) ‚àò (c n) ‚àò (to_glue_r (Y n).isom (isometry_optimal_GH_injl (X n) (X n.succ)))) ‚àò (optimal_GH_injl (X n) (X n.succ))), { change X2 n = range (coeZ ‚àò (Œ¶ n.succ) ‚àò (c n) ‚àò (to_glue_r (Y n).isom (isometry_optimal_GH_injl (X n) (X n.succ))) ‚àò (optimal_GH_injl (X n) (X n.succ))), simp only [X2, Œ¶], rw [‚Üê to_inductive_limit_commute I], simp only [f], rw ‚Üê to_glue_commute }, rw range_comp at X2n, have X2nsucc : X2 n.succ = range ((coeZ ‚àò (Œ¶ n.succ) ‚àò (c n) ‚àò (to_glue_r (Y n).isom (isometry_optimal_GH_injl (X n) (X n.succ)))) ‚àò (optimal_GH_injr (X n) (X n.succ))), by refl, rw range_comp at X2nsucc, rw [X2n, X2nsucc, Hausdorff_dist_image, Hausdorff_dist_optimal, ‚Üê dist_GH_dist], { exact hu n n n.succ (le_refl n) (le_succ n) }, { apply isometry.comp completion.coe_isometry _, apply isometry.comp _ ((ic n).comp (to_glue_r_isometry _ _)), apply to_inductive_limit_isometry } }
apply to_inductive_limit_isometry
let X3 : ‚Ñï ‚Üí nonempty_compacts Z := Œª n, ‚ü®X2 n, ‚ü®range_nonempty _, is_compact_range (isom n).continuous ‚ü©‚ü©
have : cauchy_seq X3
norm_num
refine cauchy_seq_of_le_geometric (1/2) 1 (by norm_num) (Œª n, _)
rw one_mul
{ refine cauchy_seq_of_le_geometric (1/2) 1 (by norm_num) (Œª n, _), rw one_mul, exact le_of_lt (D2 n) }
exact le_of_lt (D2 n)
rcases cauchy_seq_tendsto_of_complete this with ‚ü®L, hL‚ü©
have M : tendsto (Œª n, (X3 n).to_GH_space) at_top (ùìù L.to_GH_space) := tendsto.comp (to_GH_space_continuous.tendsto _) hL
have : ‚àÄ n, (X3 n).to_GH_space = u n
assume n
rw [nonempty_compacts.to_GH_space, ‚Üê (u n).to_GH_space_rep, to_GH_space_eq_to_GH_space_iff_isometric]
constructor
{ assume n, rw [nonempty_compacts.to_GH_space, ‚Üê (u n).to_GH_space_rep, to_GH_space_eq_to_GH_space_iff_isometric], constructor, convert (isom n).isometric_on_range.symm, }
convert (isom n).isometric_on_range.symm
simpa [this] using M
exact ‚ü®L.to_GH_space, by simpa [this] using M‚ü©
refine second_countable_of_countable_discretization (Œª Œ¥ Œ¥pos, _)
let Œµ := (2/5) * Œ¥
norm_num
have Œµpos : 0 < Œµ := mul_pos (by norm_num) Œ¥pos
have : ‚àÄ p:GH_space, ‚àÉ s : set (p.rep), finite s ‚àß (univ ‚äÜ (‚ãÉx‚ààs, ball x Œµ)) := Œª p, by simpa using finite_cover_balls_of_compact (@compact_univ p.rep _ _) Œµpos
simpa using finite_cover_balls_of_compact (@compact_univ p.rep _ _) Œµpos
choose s hs using this
have : ‚àÄ p:GH_space, ‚àÄ t:set (p.rep), finite t ‚Üí ‚àÉ n:‚Ñï, ‚àÉ e:equiv t (fin n), true
assume p t ht
letI : fintype t := finite.fintype ht
{ assume p t ht, letI : fintype t := finite.fintype ht, exact ‚ü®fintype.card t, fintype.equiv_fin t, trivial‚ü© }
exact ‚ü®fintype.card t, fintype.equiv_fin t, trivial‚ü©
choose N e hne using this
let N := Œª p:GH_space, N p (s p) (hs p).1
let E := Œª p:GH_space, e p (s p) (hs p).1
let F : GH_space ‚Üí Œ£n:‚Ñï, (fin n ‚Üí fin n ‚Üí ‚Ñ§) := Œª p, ‚ü®N p, Œª a b, floor (Œµ‚Åª¬π * dist ((E p).symm a) ((E p).symm b))‚ü©
apply_instance
refine ‚ü®_, by apply_instance, F, Œª p q hpq, _‚ü©
have Npq : N p = N q := (sigma.mk.inj_iff.1 hpq).1
let Œ® : s p ‚Üí s q := Œª x, (E q).symm (fin.cast Npq ((E p) x))
let Œ¶ : s p ‚Üí q.rep := Œª x, Œ® x
have main : GH_dist p.rep q.rep ‚â§ Œµ + Œµ/2 + Œµ
refine GH_dist_le_of_approx_subsets Œ¶ _ _ _
show ‚àÄ x : p.rep, ‚àÉ (y : p.rep) (H : y ‚àà s p), dist x y ‚â§ Œµ
assume x
have : x ‚àà ‚ãÉy‚àà(s p), ball y Œµ := (hs p).2 (mem_univ _)
rcases mem_bUnion_iff.1 this with ‚ü®y, ys, hy‚ü©
{ assume x, have : x ‚àà ‚ãÉy‚àà(s p), ball y Œµ := (hs p).2 (mem_univ _), rcases mem_bUnion_iff.1 this with ‚ü®y, ys, hy‚ü©, exact ‚ü®y, ys, le_of_lt hy‚ü© }
exact ‚ü®y, ys, le_of_lt hy‚ü©
show ‚àÄ x : q.rep, ‚àÉ (z : s p), dist x (Œ¶ z) ‚â§ Œµ
assume x
have : x ‚àà ‚ãÉy‚àà(s q), ball y Œµ := (hs q).2 (mem_univ _)
rcases mem_bUnion_iff.1 this with ‚ü®y, ys, hy‚ü©
let i : ‚Ñï := E q ‚ü®y, ys‚ü©
let hi := ((E q) ‚ü®y, ys‚ü©).is_lt
rw [fin.ext_iff, fin.coe_mk]
have ihi_eq : (‚ü®i, hi‚ü© : fin (N q)) = (E q) ‚ü®y, ys‚ü©
have hiq : i < N q := hi
rwa Npq.symm at hiq
{ rwa Npq.symm at hiq }
have hip : i < N p
let z := (E p).symm ‚ü®i, hip‚ü©
use z
have C1 : (E p) z = ‚ü®i, hip‚ü© := (E p).apply_symm_apply ‚ü®i, hip‚ü©
have C2 : fin.cast Npq ‚ü®i, hip‚ü© = ‚ü®i, hi‚ü© := rfl
have C3 : (E q).symm ‚ü®i, hi‚ü© = ‚ü®y, ys‚ü©
rw ihi_eq
exact (E q).symm_apply_apply ‚ü®y, ys‚ü©
have : Œ¶ z = y := by { simp only [Œ¶, Œ®], rw [C1, C2, C3], refl }
simp only [Œ¶, Œ®]
rw [C1, C2, C3]
refl
rw this
{ assume x, have : x ‚àà ‚ãÉy‚àà(s q), ball y Œµ := (hs q).2 (mem_univ _), rcases mem_bUnion_iff.1 this with ‚ü®y, ys, hy‚ü©, let i : ‚Ñï := E q ‚ü®y, ys‚ü©, let hi := ((E q) ‚ü®y, ys‚ü©).is_lt, have ihi_eq : (‚ü®i, hi‚ü© : fin (N q)) = (E q) ‚ü®y, ys‚ü©, by rw [fin.ext_iff, fin.coe_mk], have hiq : i < N q := hi, have hip : i < N p, { rwa Npq.symm at hiq }, let z := (E p).symm ‚ü®i, hip‚ü©, use z, have C1 : (E p) z = ‚ü®i, hip‚ü© := (E p).apply_symm_apply ‚ü®i, hip‚ü©, have C2 : fin.cast Npq ‚ü®i, hip‚ü© = ‚ü®i, hi‚ü© := rfl, have C3 : (E q).symm ‚ü®i, hi‚ü© = ‚ü®y, ys‚ü©, by { rw ihi_eq, exact (E q).symm_apply_apply ‚ü®y, ys‚ü© }, have : Œ¶ z = y := by { simp only [Œ¶, Œ®], rw [C1, C2, C3], refl }, rw this, exact le_of_lt hy }
exact le_of_lt hy
show ‚àÄ x y : s p, abs (dist x y - dist (Œ¶ x) (Œ¶ y)) ‚â§ Œµ
assume x y
have : dist (Œ¶ x) (Œ¶ y) = dist (Œ® x) (Œ® y) := rfl
rw this
let i : ‚Ñï := E p x
have hip : i < N p := ((E p) x).2
rwa Npq at hip
have hiq : i < N q
simp [Œ®]
have i' : i = ((E q) (Œ® x))
let j : ‚Ñï := E p y
have hjp : j < N p := ((E p) y).2
rwa Npq at hjp
have hjq : j < N q
simp [Œ®]
have j' : j = ((E q) (Œ® y)).1
have : (F p).2 ((E p) x) ((E p) y) = floor (Œµ‚Åª¬π * dist x y)
simp only [F, (E p).symm_apply_apply]
have Ap : (F p).2 ‚ü®i, hip‚ü© ‚ü®j, hjp‚ü© = floor (Œµ‚Åª¬π * dist x y)
rw ‚Üê this
congr
congr; apply (fin.ext_iff _ _).2; refl
congr; apply (fin.ext_iff _ _).2
apply (fin.ext_iff _ _).2
apply (fin.ext_iff _ _).2
refl
refl
have : (F q).2 ((E q) (Œ® x)) ((E q) (Œ® y)) = floor (Œµ‚Åª¬π * dist (Œ® x) (Œ® y))
simp only [F, (E q).symm_apply_apply]
have Aq : (F q).2 ‚ü®i, hiq‚ü© ‚ü®j, hjq‚ü© = floor (Œµ‚Åª¬π * dist (Œ® x) (Œ® y))
rw ‚Üê this
congr
congr; apply (fin.ext_iff _ _).2; [exact i', exact j']
congr; apply (fin.ext_iff _ _).2
apply (fin.ext_iff _ _).2
apply (fin.ext_iff _ _).2
exact i'
exact j'
have : (F p).2 ‚ü®i, hip‚ü© ‚ü®j, hjp‚ü© = (F q).2 ‚ü®i, hiq‚ü© ‚ü®j, hjq‚ü©
revert hiq hjq
change N q with (F q).1
generalize_hyp : F q = f at hpq ‚ä¢
subst hpq
intros
{ revert hiq hjq, change N q with (F q).1, generalize_hyp : F q = f at hpq ‚ä¢, subst hpq, intros, refl }
refl
rw [Ap, Aq] at this
have I := calc abs (Œµ‚Åª¬π) * abs (dist x y - dist (Œ® x) (Œ® y)) = abs (Œµ‚Åª¬π * (dist x y - dist (Œ® x) (Œ® y))) : (abs_mul _ _).symm ... = abs ((Œµ‚Åª¬π * dist x y) - (Œµ‚Åª¬π * dist (Œ® x) (Œ® y))) : by { congr, ring } ... ‚â§ 1 : le_of_lt (abs_sub_lt_one_of_floor_eq_floor this)
congr
ring
calc abs (dist x y - dist (Œ® x) (Œ® y)) = (Œµ * Œµ‚Åª¬π) * abs (dist x y - dist (Œ® x) (Œ® y)) : by rw [mul_inv_cancel (ne_of_gt Œµpos), one_mul] ... = Œµ * (abs (Œµ‚Åª¬π) * abs (dist x y - dist (Œ® x) (Œ® y))) : by rw [abs_of_nonneg (le_of_lt (inv_pos.2 Œµpos)), mul_assoc] ... ‚â§ Œµ * 1 : mul_le_mul_of_nonneg_left I (le_of_lt Œµpos) ... = Œµ : mul_one _
rw [mul_inv_cancel (ne_of_gt Œµpos), one_mul]
rw [abs_of_nonneg (le_of_lt (inv_pos.2 Œµpos)), mul_assoc]
{ refine GH_dist_le_of_approx_subsets Œ¶ _ _ _, show ‚àÄ x : p.rep, ‚àÉ (y : p.rep) (H : y ‚àà s p), dist x y ‚â§ Œµ, { assume x, have : x ‚àà ‚ãÉy‚àà(s p), ball y Œµ := (hs p).2 (mem_univ _), rcases mem_bUnion_iff.1 this with ‚ü®y, ys, hy‚ü©, exact ‚ü®y, ys, le_of_lt hy‚ü© }, show ‚àÄ x : q.rep, ‚àÉ (z : s p), dist x (Œ¶ z) ‚â§ Œµ, { assume x, have : x ‚àà ‚ãÉy‚àà(s q), ball y Œµ := (hs q).2 (mem_univ _), rcases mem_bUnion_iff.1 this with ‚ü®y, ys, hy‚ü©, let i : ‚Ñï := E q ‚ü®y, ys‚ü©, let hi := ((E q) ‚ü®y, ys‚ü©).is_lt, have ihi_eq : (‚ü®i, hi‚ü© : fin (N q)) = (E q) ‚ü®y, ys‚ü©, by rw [fin.ext_iff, fin.coe_mk], have hiq : i < N q := hi, have hip : i < N p, { rwa Npq.symm at hiq }, let z := (E p).symm ‚ü®i, hip‚ü©, use z, have C1 : (E p) z = ‚ü®i, hip‚ü© := (E p).apply_symm_apply ‚ü®i, hip‚ü©, have C2 : fin.cast Npq ‚ü®i, hip‚ü© = ‚ü®i, hi‚ü© := rfl, have C3 : (E q).symm ‚ü®i, hi‚ü© = ‚ü®y, ys‚ü©, by { rw ihi_eq, exact (E q).symm_apply_apply ‚ü®y, ys‚ü© }, have : Œ¶ z = y := by { simp only [Œ¶, Œ®], rw [C1, C2, C3], refl }, rw this, exact le_of_lt hy }, show ‚àÄ x y : s p, abs (dist x y - dist (Œ¶ x) (Œ¶ y)) ‚â§ Œµ, { assume x y, have : dist (Œ¶ x) (Œ¶ y) = dist (Œ® x) (Œ® y) := rfl, rw this, let i : ‚Ñï := E p x, have hip : i < N p := ((E p) x).2, have hiq : i < N q, by rwa Npq at hip, have i' : i = ((E q) (Œ® x)), by { simp [Œ®] }, let j : ‚Ñï := E p y, have hjp : j < N p := ((E p) y).2, have hjq : j < N q, by rwa Npq at hjp, have j' : j = ((E q) (Œ® y)).1, by { simp [Œ®] }, have : (F p).2 ((E p) x) ((E p) y) = floor (Œµ‚Åª¬π * dist x y), by simp only [F, (E p).symm_apply_apply], have Ap : (F p).2 ‚ü®i, hip‚ü© ‚ü®j, hjp‚ü© = floor (Œµ‚Åª¬π * dist x y), by { rw ‚Üê this, congr; apply (fin.ext_iff _ _).2; refl }, have : (F q).2 ((E q) (Œ® x)) ((E q) (Œ® y)) = floor (Œµ‚Åª¬π * dist (Œ® x) (Œ® y)), by simp only [F, (E q).symm_apply_apply], have Aq : (F q).2 ‚ü®i, hiq‚ü© ‚ü®j, hjq‚ü© = floor (Œµ‚Åª¬π * dist (Œ® x) (Œ® y)), by { rw ‚Üê this, congr; apply (fin.ext_iff _ _).2; [exact i', exact j'] }, have : (F p).2 ‚ü®i, hip‚ü© ‚ü®j, hjp‚ü© = (F q).2 ‚ü®i, hiq‚ü© ‚ü®j, hjq‚ü©, { revert hiq hjq, change N q with (F q).1, generalize_hyp : F q = f at hpq ‚ä¢, subst hpq, intros, refl }, rw [Ap, Aq] at this, have I := calc abs (Œµ‚Åª¬π) * abs (dist x y - dist (Œ® x) (Œ® y)) = abs (Œµ‚Åª¬π * (dist x y - dist (Œ® x) (Œ® y))) : (abs_mul _ _).symm ... = abs ((Œµ‚Åª¬π * dist x y) - (Œµ‚Åª¬π * dist (Œ® x) (Œ® y))) : by { congr, ring } ... ‚â§ 1 : le_of_lt (abs_sub_lt_one_of_floor_eq_floor this), calc abs (dist x y - dist (Œ® x) (Œ® y)) = (Œµ * Œµ‚Åª¬π) * abs (dist x y - dist (Œ® x) (Œ® y)) : by rw [mul_inv_cancel (ne_of_gt Œµpos), one_mul] ... = Œµ * (abs (Œµ‚Åª¬π) * abs (dist x y - dist (Œ® x) (Œ® y))) : by rw [abs_of_nonneg (le_of_lt (inv_pos.2 Œµpos)), mul_assoc] ... ‚â§ Œµ * 1 : mul_le_mul_of_nonneg_left I (le_of_lt Œµpos) ... = Œµ : mul_one _ } }
calc dist p q = GH_dist (p.rep) (q.rep) : dist_GH_dist p q ... ‚â§ Œµ + Œµ/2 + Œµ : main ... = Œ¥ : by { simp [Œµ], ring }
simp [Œµ]
ring
have : ‚àÄ (n : ‚Ñï), 0 < ((1:‚Ñù) / 2) ^ n
apply pow_pos
norm_num
refine metric.complete_of_convergent_controlled_sequences (Œª n, (1/2)^n) this (Œª u hu, _)
let X := Œª n, (u n).rep
let Y := aux_gluing X
letI : ‚àÄ n, metric_space (Y n).space := Œª n, (Y n).metric
have E : ‚àÄ n : ‚Ñï, glue_space (Y n).isom (isometry_optimal_GH_injl (X n) (X n.succ)) = (Y n.succ).space := Œª n, by { simp [Y, aux_gluing], refl }
simp [Y, aux_gluing]
refl
let c := Œª n, cast (E n)
have ic : ‚àÄ n, isometry (c n) := Œª n x y, rfl
let f : Œ†n, (Y n).space ‚Üí (Y n.succ).space := Œª n, (c n) ‚àò (to_glue_l (aux_gluing X n).isom (isometry_optimal_GH_injl (X n) (X n.succ)))
have I : ‚àÄ n, isometry (f n)
assume n
apply isometry.comp
refl
{ assume x y, refl }
assume x y
{ assume n, apply isometry.comp, { assume x y, refl }, { apply to_glue_l_isometry } }
apply to_glue_l_isometry
let Z0 := metric.inductive_limit I
let Z := uniform_space.completion Z0
let Œ¶ := to_inductive_limit I
let coeZ := (coe : Z0 ‚Üí Z)
let X2 := Œª n, range (coeZ ‚àò (Œ¶ n) ‚àò (Y n).embed)
have isom : ‚àÄ n, isometry (coeZ ‚àò (Œ¶ n) ‚àò (Y n).embed)
assume n
apply isometry.comp completion.coe_isometry _
apply isometry.comp _ (Y n).isom
{ assume n, apply isometry.comp completion.coe_isometry _, apply isometry.comp _ (Y n).isom, apply to_inductive_limit_isometry }
apply to_inductive_limit_isometry
have D2 : ‚àÄ n, Hausdorff_dist (X2 n) (X2 n.succ) < (1/2)^n
assume n
have X2n : X2 n = range ((coeZ ‚àò (Œ¶ n.succ) ‚àò (c n) ‚àò (to_glue_r (Y n).isom (isometry_optimal_GH_injl (X n) (X n.succ)))) ‚àò (optimal_GH_injl (X n) (X n.succ)))
change X2 n = range (coeZ ‚àò (Œ¶ n.succ) ‚àò (c n) ‚àò (to_glue_r (Y n).isom (isometry_optimal_GH_injl (X n) (X n.succ))) ‚àò (optimal_GH_injl (X n) (X n.succ)))
simp only [X2, Œ¶]
rw [‚Üê to_inductive_limit_commute I]
simp only [f]
{ change X2 n = range (coeZ ‚àò (Œ¶ n.succ) ‚àò (c n) ‚àò (to_glue_r (Y n).isom (isometry_optimal_GH_injl (X n) (X n.succ))) ‚àò (optimal_GH_injl (X n) (X n.succ))), simp only [X2, Œ¶], rw [‚Üê to_inductive_limit_commute I], simp only [f], rw ‚Üê to_glue_commute }
rw ‚Üê to_glue_commute
rw range_comp at X2n
have X2nsucc : X2 n.succ = range ((coeZ ‚àò (Œ¶ n.succ) ‚àò (c n) ‚àò (to_glue_r (Y n).isom (isometry_optimal_GH_injl (X n) (X n.succ)))) ‚àò (optimal_GH_injr (X n) (X n.succ)))
refl
rw range_comp at X2nsucc
rw [X2n, X2nsucc, Hausdorff_dist_image, Hausdorff_dist_optimal, ‚Üê dist_GH_dist]
{ exact hu n n n.succ (le_refl n) (le_succ n) }
exact hu n n n.succ (le_refl n) (le_succ n)
apply isometry.comp completion.coe_isometry _
apply isometry.comp _ ((ic n).comp (to_glue_r_isometry _ _))
cases s.eq_empty_or_nonempty with hs hs
cases t.eq_empty_or_nonempty with ht ht
{ exact or.inl ‚ü®hs, ht‚ü© }
exact or.inl ‚ü®hs, ht‚ü©
rw Hausdorff_edist_comm at fin
{ cases t.eq_empty_or_nonempty with ht ht, { exact or.inl ‚ü®hs, ht‚ü© }, { rw Hausdorff_edist_comm at fin, exact or.inr ‚ü®nonempty_of_Hausdorff_edist_ne_top ht fin, ht‚ü© } }
exact or.inr ‚ü®nonempty_of_Hausdorff_edist_ne_top ht fin, ht‚ü©
exact or.inr ‚ü®hs, nonempty_of_Hausdorff_edist_ne_top hs fin‚ü©
rw [dist_edist, dist_edist, hf]
simp [is_œâSup, is_lub, is_least, upper_bounds, lower_bounds]
split
intros hB U
refine ‚ü®{V : opens Œ± | V ‚àà B ‚àß V ‚äÜ U}, Œª U hU, hU.left, _‚ü©
apply ext
rw [Sup_s, hB.open_eq_sUnion' U.prop]
simp_rw [sUnion_image, sUnion_eq_bUnion, Union, supr_and, supr_image]
{ intros hB U, refine ‚ü®{V : opens Œ± | V ‚àà B ‚àß V ‚äÜ U}, Œª U hU, hU.left, _‚ü©, apply ext, rw [Sup_s, hB.open_eq_sUnion' U.prop], simp_rw [sUnion_image, sUnion_eq_bUnion, Union, supr_and, supr_image], refl }
refl
intro h
rw is_basis_iff_nbhd
intros U x hx
rcases h U with ‚ü®Us, hUs, rfl‚ü©
rcases mem_Sup.1 hx with ‚ü®U, Us, xU‚ü©
exact ‚ü®U, hUs Us, xU, le_Sup Us‚ü©
intro U
ext1
simp only [coe_comap, ‚Üê preimage_comp, f.symm_comp_self, preimage_id]
intro U
ext1
simp only [coe_comap, ‚Üê preimage_comp, f.self_comp_symm, preimage_id]
refine ‚ü®univ, univ_mem, (finite_singleton i).subset _‚ü©
rintro j ‚ü®x, hx, -‚ü©
contrapose! hx
rw [mem_singleton_iff] at hx
simp [hx]
simp
cases h
refine is_topological_basis_of_open_of_nhds (Œª u hu, hu.1) _
rintros x U memU hU
obtain ‚ü®s, comp, xs, sU‚ü© := exists_compact_subset hU memU
obtain ‚ü®t, h, ht, xt‚ü© := mem_interior.1 xs
let u : set s := (coe : s ‚Üí H)‚Åª¬π' (interior s)
have u_open_in_s : is_open u := is_open_interior.preimage continuous_subtype_coe
let X : s := ‚ü®x, h xt‚ü©
have Xu : X ‚àà u := xs
haveI : compact_space s := is_compact_iff_compact_space.1 comp
obtain ‚ü®V : set s, clopen_in_s, Vx, V_sub‚ü© := compact_exists_clopen_in_open u_open_in_s Xu
have V_clopen : is_clopen ((coe : s ‚Üí H) '' V)
refine ‚ü®_, (comp.is_closed.closed_embedding_subtype_coe.closed_iff_image_closed).1 clopen_in_s.2‚ü©
let v : set u := (coe : u ‚Üí s)‚Åª¬π' V
have : (coe : u ‚Üí H) = (coe : s ‚Üí H) ‚àò (coe : u ‚Üí s) := rfl
have f0 : embedding (coe : u ‚Üí H) := embedding_subtype_coe.comp embedding_subtype_coe
have f1 : open_embedding (coe : u ‚Üí H)
refine ‚ü®f0, _‚ü©
have : set.range (coe : u ‚Üí H) = interior s
rw [this, set.range_comp, subtype.range_coe, subtype.image_preimage_coe]
apply set.inter_eq_self_of_subset_left interior_subset
{ rw [this, set.range_comp, subtype.range_coe, subtype.image_preimage_coe], apply set.inter_eq_self_of_subset_left interior_subset, }
rw this
{ refine ‚ü®f0, _‚ü©, { have : set.range (coe : u ‚Üí H) = interior s, { rw [this, set.range_comp, subtype.range_coe, subtype.image_preimage_coe], apply set.inter_eq_self_of_subset_left interior_subset, }, rw this, apply is_open_interior } }
apply is_open_interior
have f2 : is_open v := clopen_in_s.1.preimage continuous_subtype_coe
have f3 : (coe : s ‚Üí H) '' V = (coe : u ‚Üí H) '' v
rw [this, image_comp coe coe, subtype.image_preimage_coe, inter_eq_self_of_subset_left V_sub]
{ rw [this, image_comp coe coe, subtype.image_preimage_coe, inter_eq_self_of_subset_left V_sub] }
rw f3
{ refine ‚ü®_, (comp.is_closed.closed_embedding_subtype_coe.closed_iff_image_closed).1 clopen_in_s.2‚ü©, let v : set u := (coe : u ‚Üí s)‚Åª¬π' V, have : (coe : u ‚Üí H) = (coe : s ‚Üí H) ‚àò (coe : u ‚Üí s) := rfl, have f0 : embedding (coe : u ‚Üí H) := embedding_subtype_coe.comp embedding_subtype_coe, have f1 : open_embedding (coe : u ‚Üí H), { refine ‚ü®f0, _‚ü©, { have : set.range (coe : u ‚Üí H) = interior s, { rw [this, set.range_comp, subtype.range_coe, subtype.image_preimage_coe], apply set.inter_eq_self_of_subset_left interior_subset, }, rw this, apply is_open_interior } }, have f2 : is_open v := clopen_in_s.1.preimage continuous_subtype_coe, have f3 : (coe : s ‚Üí H) '' V = (coe : u ‚Üí H) '' v, { rw [this, image_comp coe coe, subtype.image_preimage_coe, inter_eq_self_of_subset_left V_sub] }, rw f3, apply f1.is_open_map v f2 }
apply f1.is_open_map v f2
simp [Vx, h xt]
refine ‚ü®coe '' V, V_clopen, by simp [Vx, h xt], _‚ü©
transitivity s
{ simp }
simp
assumption
obtain ‚ü®V, Vsub, Vne, Vcls, hV‚ü© := hS.exists_minimal_nonempty_closed_subset hne
by_cases hnt : ‚àÉ (x y : Œ±) (hx : x ‚àà V) (hy : y ‚àà V), x ‚â† y
exfalso
obtain ‚ü®x, y, hx, hy, hne‚ü© := hnt
obtain ‚ü®U, hU, hsep‚ü© := t0_space.t0 _ _ hne
have : ‚àÄ (z w : Œ±) (hz : z ‚àà V) (hw : w ‚àà V) (hz' : z ‚àà U) (hw' : ¬¨ w ‚àà U), false
intros z w hz hw hz' hw'
have uvne : (V ‚à© U·∂ú).nonempty
simp only [hw, hw', set.mem_inter_eq, not_false_iff, and_self, set.mem_compl_eq]
{ use w, simp only [hw, hw', set.mem_inter_eq, not_false_iff, and_self, set.mem_compl_eq], }
use w
specialize hV (V ‚à© U·∂ú) (set.inter_subset_left _ _) uvne (is_closed.inter Vcls (is_closed_compl_iff.mpr hU))
have : V ‚äÜ U·∂ú
exact set.inter_subset_right _ _
{ rw ‚ÜêhV, exact set.inter_subset_right _ _ }
rw ‚ÜêhV
{ intros z w hz hw hz' hw', have uvne : (V ‚à© U·∂ú).nonempty, { use w, simp only [hw, hw', set.mem_inter_eq, not_false_iff, and_self, set.mem_compl_eq], }, specialize hV (V ‚à© U·∂ú) (set.inter_subset_left _ _) uvne (is_closed.inter Vcls (is_closed_compl_iff.mpr hU)), have : V ‚äÜ U·∂ú, { rw ‚ÜêhV, exact set.inter_subset_right _ _ }, exact this hz hz', }
exact this hz hz'
cases hsep
{ exact this x y hx hy hsep.1 hsep.2 }
exact this x y hx hy hsep.1 hsep.2
{ exfalso, obtain ‚ü®x, y, hx, hy, hne‚ü© := hnt, obtain ‚ü®U, hU, hsep‚ü© := t0_space.t0 _ _ hne, have : ‚àÄ (z w : Œ±) (hz : z ‚àà V) (hw : w ‚àà V) (hz' : z ‚àà U) (hw' : ¬¨ w ‚àà U), false, { intros z w hz hw hz' hw', have uvne : (V ‚à© U·∂ú).nonempty, { use w, simp only [hw, hw', set.mem_inter_eq, not_false_iff, and_self, set.mem_compl_eq], }, specialize hV (V ‚à© U·∂ú) (set.inter_subset_left _ _) uvne (is_closed.inter Vcls (is_closed_compl_iff.mpr hU)), have : V ‚äÜ U·∂ú, { rw ‚ÜêhV, exact set.inter_subset_right _ _ }, exact this hz hz', }, cases hsep, { exact this x y hx hy hsep.1 hsep.2 }, { exact this y x hy hx hsep.1 hsep.2 } }
exact this y x hy hx hsep.1 hsep.2
push_neg at hnt
obtain ‚ü®z, hz‚ü© := Vne
refine ‚ü®z, Vsub hz, _‚ü©
convert Vcls
ext
simp only [set.mem_singleton_iff, set.mem_compl_eq]
split
exact hz
{ rintro rfl, exact hz, }
rintro rfl
exact Œª hx, hnt x z hx hz
refine induction_on_union _ (Œª a b hi d, (hi d.symm).symm) (Œª a d, empty_right a) (Œª a b ab, _) _
obtain ‚ü®U, V, oU, oV, aU, bV, UV‚ü© := t2_separation (by { rw [ne.def, ‚Üê finset.mem_singleton], exact (disjoint_singleton.mp ab.symm) })
rw [ne.def, ‚Üê finset.mem_singleton]
exact (disjoint_singleton.mp ab.symm)
refine ‚ü®U, V, oU, oV, _, _, set.disjoint_iff_inter_eq_empty.mpr UV‚ü©
refine ‚ü®U, V, oU, oV, _, _, set.disjoint_iff_inter_eq_empty.mpr UV‚ü©; exact singleton_subset_set_iff.mpr ‚Äπ_‚Ä∫
{ obtain ‚ü®U, V, oU, oV, aU, bV, UV‚ü© := t2_separation (by { rw [ne.def, ‚Üê finset.mem_singleton], exact (disjoint_singleton.mp ab.symm) }), refine ‚ü®U, V, oU, oV, _, _, set.disjoint_iff_inter_eq_empty.mpr UV‚ü©; exact singleton_subset_set_iff.mpr ‚Äπ_‚Ä∫ }
exact singleton_subset_set_iff.mpr ‚Äπ_‚Ä∫
exact singleton_subset_set_iff.mpr ‚Äπ_‚Ä∫
intros a b c ac bc d
apply_mod_cast union_left (ac (disjoint_of_subset_left (a.subset_union_left b) d)) (bc _)
exact disjoint_of_subset_left (a.subset_union_right b) d
rwa [inter_comm, ‚Üêsubset_compl_iff_disjoint, singleton_subset_iff]
simpa using xv
rwa closure_eq_compl_interior_compl
apply_instance
dsimp [presheaf]
classical
haveI : nonempty (partial_refinement u s) := ‚ü®‚ü®u, ‚àÖ, uo, us, Œª _, false.elim, Œª _ _, rfl‚ü©‚ü©
have : ‚àÄ c : set (partial_refinement u s), chain (‚â§) c ‚Üí c.nonempty ‚Üí ‚àÉ ub, ‚àÄ v ‚àà c, v ‚â§ ub
from Œª c hc ne, ‚ü®partial_refinement.chain_Sup c hc ne uf us, Œª v hv, partial_refinement.le_chain_Sup _ _ _ _ hv‚ü©
rcases zorn_nonempty_partial_order this with ‚ü®v, hv‚ü©
suffices : ‚àÄ i, i ‚àà v.carrier
from ‚ü®v, v.subset_Union, Œª i, v.is_open _, Œª i, v.closure_subset (this i)‚ü©
contrapose! hv
rcases hv with ‚ü®i, hi‚ü©
rcases v.exists_gt hs i hi with ‚ü®v', hlt‚ü©
exact ‚ü®v', hlt.le, hlt.ne'‚ü©
rw topological_space.nhds_generate_from
simp only [comap_infi, comap_principal]
intros s hs
rw ‚Üêle_principal_iff
refine infi_le_of_le {u | s ‚àà u} _
refine infi_le_of_le ‚ü®hs, ‚ü®s, rfl‚ü©‚ü© _
exact principal_mono.2 (Œª a, id)
apply eq_bot_of_singletons_open
intros x
use [{u : ultrafilter Œ± | {x} ‚àà u}, ultrafilter_is_open_basic _]
simp
apply hŒπ.elim
intro i‚ÇÄ
let Z' := Œª i, Z i ‚à© Z i‚ÇÄ
suffices : (‚ãÇ i, Z' i).nonempty
exact nonempty.mono (Inter_subset_Inter $ assume i, inter_subset_left (Z i) (Z i‚ÇÄ)) this
{ exact nonempty.mono (Inter_subset_Inter $ assume i, inter_subset_left (Z i) (Z i‚ÇÄ)) this }
rw ‚Üê ne_empty_iff_nonempty
intro H
obtain ‚ü®t, ht‚ü© : ‚àÉ (t : finset Œπ), ((Z i‚ÇÄ) ‚à© ‚ãÇ (i ‚àà t), Z' i) = ‚àÖ
from (hZc i‚ÇÄ).elim_finite_subfamily_closed Z' (assume i, is_closed.inter (hZcl i) (hZcl i‚ÇÄ)) (by rw [H, inter_empty])
rw [H, inter_empty]
obtain ‚ü®i‚ÇÅ, hi‚ÇÅ‚ü© : ‚àÉ i‚ÇÅ : Œπ, Z i‚ÇÅ ‚äÜ Z i‚ÇÄ ‚àß ‚àÄ i ‚àà t, Z i‚ÇÅ ‚äÜ Z' i
rcases directed.finset_le hZd t with ‚ü®i, hi‚ü©
rcases hZd i i‚ÇÄ with ‚ü®i‚ÇÅ, hi‚ÇÅ, hi‚ÇÅ‚ÇÄ‚ü©
use [i‚ÇÅ, hi‚ÇÅ‚ÇÄ]
intros j hj
{ rcases directed.finset_le hZd t with ‚ü®i, hi‚ü©, rcases hZd i i‚ÇÄ with ‚ü®i‚ÇÅ, hi‚ÇÅ, hi‚ÇÅ‚ÇÄ‚ü©, use [i‚ÇÅ, hi‚ÇÅ‚ÇÄ], intros j hj, exact subset_inter (subset.trans hi‚ÇÅ (hi j hj)) hi‚ÇÅ‚ÇÄ }
exact subset_inter (subset.trans hi‚ÇÅ (hi j hj)) hi‚ÇÅ‚ÇÄ
suffices : ((Z i‚ÇÄ) ‚à© ‚ãÇ (i ‚àà t), Z' i).nonempty
contradiction
{ rw ‚Üê ne_empty_iff_nonempty at this, contradiction }
rw ‚Üê ne_empty_iff_nonempty at this
refine nonempty.mono _ (hZn i‚ÇÅ)
exact subset_inter hi‚ÇÅ.left (subset_bInter hi‚ÇÅ.right)
rw union_eq_Union; exact compact_Union (Œª b, by cases b; assumption)
exact compact_Union (Œª b, by cases b; assumption)
rw union_eq_Union
cases b
cases b; assumption
assumption
assumption
rw is_compact_iff_ultrafilter_le_nhds at hs ht ‚ä¢
intros f hfs
rw le_principal_iff at hfs
obtain ‚ü®a : Œ±, sa : a ‚àà s, ha : map prod.fst ‚Üëf ‚â§ ùìù a‚ü© := hs (f.map prod.fst) (le_principal_iff.2 $ mem_map.2 $ mem_of_superset hfs (Œª x, and.left))
obtain ‚ü®b : Œ≤, tb : b ‚àà t, hb : map prod.snd ‚Üëf ‚â§ ùìù b‚ü© := ht (f.map prod.snd) (le_principal_iff.2 $ mem_map.2 $ mem_of_superset hfs (Œª x, and.right))
rw map_le_iff_le_comap at ha hb
refine ‚ü®‚ü®a, b‚ü©, ‚ü®sa, tb‚ü©, _‚ü©
exact le_inf ha hb
rw nhds_prod_eq
rw [continuous_within_at, tendsto_nhds_right]
unfold symmetric_rel at *
rw [preimage_inter, hU, hV]
congr
exact h
rw [prod_def]
show (ùìù a).lift (Œªs:set Œ±, (ùìù b).lift (Œªt:set Œ±, ùìü (set.prod s t))) = _
rw [lift_nhds_right]
funext s
apply congr_arg
rw [lift_nhds_left]
refl
exact monotone_principal.comp (monotone_prod monotone_const monotone_id)
exact (monotone_lift' monotone_const $ monotone_lam $ assume x, monotone_prod monotone_id monotone_const)
finish [prod.forall]
refine H.cauchy_seq_iff.trans ‚ü®Œª h i hi, _, Œª h i hi, _‚ü©
exact (h i hi).imp (Œª N hN n hn, hN n N hn (le_refl N))
{ exact (h i hi).imp (Œª N hN n hn, hN n N hn (le_refl N)) }
rcases comp_symm_of_uniformity (H.mem_of_mem hi) with ‚ü®t, ht, ht', hts‚ü©
rcases H.mem_iff.1 ht with ‚ü®j, hj, hjt‚ü©
refine (h j hj).imp (Œª N hN m n hm hn, hts ‚ü®u N, hjt _, ht' $ hjt _‚ü©)
{ exact hN m hm }
exact hN m hm
exact hN n hn
set ùìùŒî := ‚®Ü x : Œ≥, ùìù (x, x)
set F := ùìùŒî.lift' (Œª (s : set (Œ≥ √ó Œ≥)), s ‚óã s)
rw le_iff_forall_inf_principal_compl
intros V V_in
by_contra H
haveI : ne_bot (F ‚äì ùìü V·∂ú) := ‚ü®H‚ü©
obtain ‚ü®‚ü®x, y‚ü©, hxy‚ü© : ‚àÉ (p : Œ≥ √ó Œ≥), cluster_pt p (F ‚äì ùìü V·∂ú) := cluster_point_of_compact _
have clV : cluster_pt (x, y) (ùìü $ V·∂ú) := hxy.of_inf_right
have : (x, y) ‚àâ interior V
rwa mem_closure_iff_cluster_pt
have : (x, y) ‚àà closure (V·∂ú)
{ have : (x, y) ‚àà closure (V·∂ú), by rwa mem_closure_iff_cluster_pt, rwa closure_compl at this }
rwa closure_compl at this
have diag_subset : diagonal Œ≥ ‚äÜ interior V
rw subset_interior_iff_nhds
rintros ‚ü®x, x‚ü© ‚ü®‚ü©
{ rw subset_interior_iff_nhds, rintros ‚ü®x, x‚ü© ‚ü®‚ü©, exact (mem_supr.mp V_in : _) x }
exact (mem_supr.mp V_in : _) x
have x_ne_y : x ‚â† y
intro h
apply this
apply diag_subset
{ intro h, apply this, apply diag_subset, simp [h] }
simp [h]
haveI : normal_space Œ≥ := normal_of_compact_t2
obtain ‚ü®U‚ÇÅ, V‚ÇÅ, U‚ÇÅ_in, V‚ÇÅ_in, U‚ÇÇ, V‚ÇÇ, U‚ÇÇ_in‚ÇÇ, V‚ÇÇ_in, V‚ÇÅ_cl, V‚ÇÇ_cl, U‚ÇÅ_op, U‚ÇÇ_op, VU‚ÇÅ, VU‚ÇÇ, hU‚ÇÅ‚ÇÇ‚ü© : ‚àÉ (U‚ÇÅ V‚ÇÅ ‚àà ùìù x) (U‚ÇÇ V‚ÇÇ ‚àà ùìù y), is_closed V‚ÇÅ ‚àß is_closed V‚ÇÇ ‚àß is_open U‚ÇÅ ‚àß is_open U‚ÇÇ ‚àß V‚ÇÅ ‚äÜ U‚ÇÅ ‚àß V‚ÇÇ ‚äÜ U‚ÇÇ ‚àß U‚ÇÅ ‚à© U‚ÇÇ = ‚àÖ := disjoint_nested_nhds x_ne_y
let U‚ÇÉ := (V‚ÇÅ ‚à™ V‚ÇÇ)·∂ú
have U‚ÇÉ_op : is_open U‚ÇÉ := is_open_compl_iff.mpr (is_closed.union V‚ÇÅ_cl V‚ÇÇ_cl)
let W := (U‚ÇÅ.prod U‚ÇÅ) ‚à™ (U‚ÇÇ.prod U‚ÇÇ) ‚à™ (U‚ÇÉ.prod U‚ÇÉ)
have W_in : W ‚àà ùìùŒî
rw mem_supr
intros x
apply is_open.mem_nhds (is_open.union (is_open.union _ _) _)
by_cases hx : x ‚àà V‚ÇÅ ‚à™ V‚ÇÇ
left
cases hx with hx hx
cases hx with hx hx ; [left, right] ; split ; tauto
cases hx with hx hx ; [left, right] ; split
cases hx with hx hx ; [left, right]
left
right
split
split
tauto
tauto
tauto
tauto
{ left, cases hx with hx hx ; [left, right] ; split ; tauto }
right
rw mem_prod
tauto
{ by_cases hx : x ‚àà V‚ÇÅ ‚à™ V‚ÇÇ, { left, cases hx with hx hx ; [left, right] ; split ; tauto }, { right, rw mem_prod, tauto }, }
simp only [is_open.prod, *]
simp only [is_open.prod, *]
simp only [is_open.prod, *]
{ rw mem_supr, intros x, apply is_open.mem_nhds (is_open.union (is_open.union _ _) _), { by_cases hx : x ‚àà V‚ÇÅ ‚à™ V‚ÇÇ, { left, cases hx with hx hx ; [left, right] ; split ; tauto }, { right, rw mem_prod, tauto }, }, all_goals { simp only [is_open.prod, *] } }
all_goals { simp only [is_open.prod, *] }
simpa only using mem_lift' W_in
have : W ‚óã W ‚àà F
have hV‚ÇÅ‚ÇÇ : V‚ÇÅ.prod V‚ÇÇ ‚àà ùìù (x, y) := prod_is_open.mem_nhds V‚ÇÅ_in V‚ÇÇ_in
have clF : cluster_pt (x, y) F := hxy.of_inf_left
obtain ‚ü®p, p_in‚ü© : ‚àÉ p, p ‚àà (V‚ÇÅ.prod V‚ÇÇ) ‚à© (W ‚óã W) := cluster_pt_iff.mp clF hV‚ÇÅ‚ÇÇ this
have inter_empty : (V‚ÇÅ.prod V‚ÇÇ) ‚à© (W ‚óã W) = ‚àÖ
rw eq_empty_iff_forall_not_mem
rintros ‚ü®u, v‚ü© ‚ü®‚ü®u_in, v_in‚ü©, w, huw, hwv‚ü©
have uw_in : (u, w) ‚àà U‚ÇÅ.prod U‚ÇÅ := set.mem_prod.2 ((huw.resolve_right (Œª h, (h.1 $ or.inl u_in))).resolve_right (Œª h, have u ‚àà U‚ÇÅ ‚à© U‚ÇÇ, from ‚ü®VU‚ÇÅ u_in, h.1‚ü©, by rwa hU‚ÇÅ‚ÇÇ at this))
rwa hU‚ÇÅ‚ÇÇ at this
have wv_in : (w, v) ‚àà U‚ÇÇ.prod U‚ÇÇ := set.mem_prod.2 ((hwv.resolve_right (Œª h, (h.2 $ or.inr v_in))).resolve_left (Œª h, have v ‚àà U‚ÇÅ ‚à© U‚ÇÇ, from ‚ü®h.2, VU‚ÇÇ v_in‚ü©, by rwa hU‚ÇÅ‚ÇÇ at this))
rwa hU‚ÇÅ‚ÇÇ at this
have : w ‚àà U‚ÇÅ ‚à© U‚ÇÇ := ‚ü®uw_in.2, wv_in.1‚ü©
{ rw eq_empty_iff_forall_not_mem, rintros ‚ü®u, v‚ü© ‚ü®‚ü®u_in, v_in‚ü©, w, huw, hwv‚ü©, have uw_in : (u, w) ‚àà U‚ÇÅ.prod U‚ÇÅ := set.mem_prod.2 ((huw.resolve_right (Œª h, (h.1 $ or.inl u_in))).resolve_right (Œª h, have u ‚àà U‚ÇÅ ‚à© U‚ÇÇ, from ‚ü®VU‚ÇÅ u_in, h.1‚ü©, by rwa hU‚ÇÅ‚ÇÇ at this)), have wv_in : (w, v) ‚àà U‚ÇÇ.prod U‚ÇÇ := set.mem_prod.2 ((hwv.resolve_right (Œª h, (h.2 $ or.inr v_in))).resolve_left (Œª h, have v ‚àà U‚ÇÅ ‚à© U‚ÇÇ, from ‚ü®h.2, VU‚ÇÇ v_in‚ü©, by rwa hU‚ÇÅ‚ÇÇ at this)), have : w ‚àà U‚ÇÅ ‚à© U‚ÇÇ := ‚ü®uw_in.2, wv_in.1‚ü©, rwa hU‚ÇÅ‚ÇÇ at this }
rwa hU‚ÇÅ‚ÇÇ at this
rwa inter_empty at p_in
suffices : ‚àÄ x : Œ≥, filter.comap (prod.mk x) (‚®Ü y, ùìù (y ,y)) = ùìù x
intros s
change is_open s ‚Üî _
{ intros s, change is_open s ‚Üî _, simp_rw [is_open_iff_mem_nhds, nhds_eq_comap_uniformity_aux, this] }
simp_rw [is_open_iff_mem_nhds, nhds_eq_comap_uniformity_aux, this]
intros x
simp_rw [comap_supr, nhds_prod_eq, comap_prod, show prod.fst ‚àò prod.mk x = Œª y : Œ≥, x, by ext ; simp, show prod.snd ‚àò (prod.mk x) = (id : Œ≥ ‚Üí Œ≥), by ext ; refl, comap_id]
ext
ext ; simp
simp
ext
ext ; refl
refl
rw [supr_split_single _ x, comap_const_of_mem (Œª V, mem_of_mem_nhds)]
suffices : ‚àÄ y ‚â† x, comap (Œª (y : Œ≥), x) (ùìù y) ‚äì ùìù y ‚â§ ùìù x
simpa
intros y hxy
simp [comap_const_of_not_mem (compl_singleton_mem_nhds hxy) (by simp)]
simp
rw uniform_continuous_on_iff_restrict
rw is_separated_iff_induced at hs'
rw is_compact_iff_compact_space at hs
rw continuous_on_iff_continuous_restrict at hf
resetI
exact compact_space.uniform_continuous_of_continuous hf
simp_rw [filter.principal_le_iff, mem_supr]
rintros V V_in ‚ü®x, _‚ü© ‚ü®‚ü©
exact mem_of_mem_nhds (V_in x)
refine le_of_eq _
rw map_supr
congr' with x : 1
erw [nhds_prod_eq, ‚Üê prod_comm]
ext ‚ü®a‚ü©; calc map f ‚ü¶a‚üß = ‚ü¶f a‚üß : map_mk hf a ... = g ‚ü¶a‚üß : congr_fun comm a
ext ‚ü®a‚ü©
calc map f ‚ü¶a‚üß = ‚ü¶f a‚üß : map_mk hf a ... = g ‚ü¶a‚üß : congr_fun comm a
assume u hu
apply (h u hu).mono (Œª n hn, _)
exact Œª x hx, hn _ hx
apply_instance
set c : urysohns.CU X := ‚ü®s, t·∂ú, hs, ht.is_open_compl, Œª _, disjoint_left.1 hd‚ü©
exact ‚ü®‚ü®c.lim, c.continuous_lim‚ü©, c.lim_of_mem_C, Œª x hx, c.lim_of_nmem_U _ (Œª h, h hx), c.lim_mem_Icc‚ü©
