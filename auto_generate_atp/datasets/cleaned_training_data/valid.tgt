abstract { intros, simp, rw [h, h [x]], simp }
intros
simp
rw [h, h [x]]
simp
rw [nth_map, h]
rw corec_eq
refl
unfold even
simp *
min_tac a b
simp
cases a; cases b; simp [fin.add]
cases a; cases b
cases b
simp [fin.add]
cases a
cases m
cases n
reflexivity
{ simp, reflexivity }
simp
reflexivity
{ cases n, { simp, reflexivity }, simp [nat.zero_add], reflexivity }
simp [nat.zero_add]
cases n
reflexivity
{ simp, reflexivity }
simp
reflexivity
simp [nat.succ_add]
simp [neg_succ_of_nat_coe, int.coe_nat_succ, int.coe_nat_add, int.coe_nat_one, int.add_comm, int.add_left_comm, int.neg_add, int.add_right_neg, int.zero_add]
simp
rwa [int.add_neg_cancel_right, int.zero_add] at this
have h := int.add_le_add_right h b
rwa [int.sub_add_cancel, int.zero_add] at h
rwa int.zero_mul at h
rwa int.zero_mul at this
rw [bit_val, div2_val, nat.add_comm, add_mul_div_left, div_eq_of_lt, nat.zero_add]
rw [bit_val, div2_val, nat.add_comm, add_mul_div_left, div_eq_of_lt, nat.zero_add]; cases b; exact dec_trivial
rw [bit_val, div2_val, nat.add_comm, add_mul_div_left, div_eq_of_lt, nat.zero_add]; cases b
exact dec_trivial
exact dec_trivial
exact dec_trivial
cases b
cases b
rw [← nat.zero_add (m*n), add_mul_mod_self_left, zero_mod]
rwa [nat.zero_add, nat.zero_div, nat.zero_add] at t
rw nat.sub_add_cancel H
rw nat.sub_add_cancel H; exact h₁
exact h₁
rw heq at h
assumption
rw [← hk, nat.add_sub_cancel_left]
cases y
cases y; refl
refl
refl
{ cases y; refl }
cases x
refl
{ refl }
cases y
refine if_congr iff.rfl (mod_core_congr _ _) rfl
refine if_congr iff.rfl (mod_core_congr _ _) rfl; simp [nat.sub_le]
simp [nat.sub_le]
simp [nat.sub_le]
cases n; simp
simp
simp
cases n
sort_add
simp [mul_succ, right_distrib n m k]
rw [← vsub_vadd_eq_vsub_sub, vsub_vadd_comm, vsub_vadd_eq_vsub_sub]
haveI := P
exact algebra_map R A r
haveI := Q
exact algebra_map R A r
rcases P with ⟨⟨P⟩⟩
rcases Q with ⟨⟨Q⟩⟩
unfreezingI { rcases P with ⟨⟨P⟩⟩, rcases Q with ⟨⟨Q⟩⟩ }
rw [algebra_compatible_smul A r (a • m), smul_smul, algebra.commutes, mul_smul, ←algebra_compatible_smul]
congr
funext r a
replace w := congr_arg (λ s, s * a) (w r)
simp only [←algebra.smul_def''] at w
{ funext r a, replace w := congr_arg (λ s, s * a) (w r), simp only [←algebra.smul_def''] at w, apply w, }
apply w
ext r
{ ext r, exact w r, }
exact w r
{ apply proof_irrel_heq, }
apply proof_irrel_heq
apply proof_irrel_heq
rw [← mul_assoc, ← commutes, mul_assoc]
simp [bit1, add_smul]
norm_num
induction n; simp [*, pow_succ, associates.mk_mul_mk.symm]
simp [*, pow_succ, associates.mk_mul_mk.symm]
simp [*, pow_succ, associates.mk_mul_mk.symm]
induction n
rw [dvd_not_unit, dvd_not_unit, ne, ne, mk_eq_zero]
intro ane0
apply and_congr_right
split
rw forall_associated
contrapose!
intros h x hx hbax
rw [mk_mul_mk, mk_eq_mk_iff_associated] at hbax
cases hbax with u hu
apply h (x * ↑u⁻¹)
rw is_unit_mk at hx
rw associated.is_unit_iff
apply hx
use u
{ rw is_unit_mk at hx, rw associated.is_unit_iff, apply hx, use u, simp, }
simp
{ contrapose!, rw forall_associated, intros h x hx hbax, rw [mk_mul_mk, mk_eq_mk_iff_associated] at hbax, cases hbax with u hu, apply h (x * ↑u⁻¹), { rw is_unit_mk at hx, rw associated.is_unit_iff, apply hx, use u, simp, }, simp [← mul_assoc, ← hu] }
simp [← mul_assoc, ← hu]
rintro ⟨x, ⟨hx, rfl⟩⟩
use associates.mk x
simp [is_unit_mk, mk_mul_mk, hx]
rw [mul_comm, mul_prod_erase s f h]
simp
simp [finset.prod_insert (mt list.mem_to_finset.mp not_mem), prod_to_finset hl]
classical
apply finset.induction_on s
{ simp only [prod_empty, prod_const_one] }
simp only [prod_empty, prod_const_one]
intros _ _ H ih
simp only [prod_insert H, prod_mul_distrib, ih]
haveI := classical.dec_eq α; by_cases h₁ : a ∈ s; by_cases h₂ : b ∈ s
haveI := classical.dec_eq α; by_cases h₁ : a ∈ s
haveI := classical.dec_eq α
by_cases h₂ : b ∈ s
by_cases h₂ : b ∈ s
by_cases h₁ : a ∈ s
{ exact prod_eq_mul_of_mem a b h₁ h₂ hn h₀ }
exact prod_eq_mul_of_mem a b h₁ h₂ hn h₀
rw [hb h₂, mul_one]
apply prod_eq_single_of_mem a h₁
exact λ c hc hca, h₀ c hc ⟨hca, ne_of_mem_of_not_mem hc h₂⟩
{ rw [hb h₂, mul_one], apply prod_eq_single_of_mem a h₁, exact λ c hc hca, h₀ c hc ⟨hca, ne_of_mem_of_not_mem hc h₂⟩ }
rw [ha h₁, one_mul]
apply prod_eq_single_of_mem b h₂
exact λ c hc hcb, h₀ c hc ⟨ne_of_mem_of_not_mem hc h₁, hcb⟩
{ rw [ha h₁, one_mul], apply prod_eq_single_of_mem b h₂, exact λ c hc hcb, h₀ c hc ⟨ne_of_mem_of_not_mem hc h₁, hcb⟩ }
rw [ha h₁, hb h₂, mul_one]
exact trans (prod_congr rfl (λ c hc, h₀ c hc ⟨ne_of_mem_of_not_mem hc h₁, ne_of_mem_of_not_mem hc h₂⟩)) prod_const_one
split_ifs with h
rw [finset.prod_eq_single a, dif_pos rfl]
rw dif_neg
cc
{ intros, rw dif_neg, cc }
intros
{ rw [finset.prod_eq_single a, dif_pos rfl], { intros, rw dif_neg, cc }, { cc } }
cc
rw finset.prod_eq_one
rw dif_neg
intro
cc
intros
rw [univ_filter_zero_lt, sum_map, rel_embedding.coe_fn_to_embedding, coe_succ_embedding]
simp
rcases eq_or_ne x 0 with rfl|hx
{ simp }
exact ((smul_add_hom R M).flip x).map_finsum_of_injective (smul_left_injective R hx) _
lift t to finset α using ht
lift s to finset α using hs
classical
rw [← finset.coe_union, ← finset.coe_inter]
simp only [finprod_mem_coe_finset, finset.prod_union_inter]
rw [← prod_antidiagonal_swap, prod_antidiagonal_succ, ← prod_antidiagonal_swap]
refl
refine (multiset.prod_le_of_forall_le (s.val.map f) n _).trans _
{ simpa using h }
simpa using h
simpa
classical
split
contrapose!
{ contrapose!, exact λ h, (sum_lt_top $ λ i hi, (h i hi)).ne }
exact λ h, (sum_lt_top $ λ i hi, (h i hi)).ne
rintro ⟨i, his, hi⟩
rw [sum_eq_add_sum_diff_singleton his, hi, top_add]
simp only [lt_top_iff_ne_top, ne.def, sum_eq_top_iff, not_exists]
resetI
let i := as_iso ((forget (Algebra.{u} R)).map f)
let e : X ≃ₐ[R] Y := { ..f, ..i.to_equiv }
exact ⟨(is_iso.of_iso e.to_Algebra_iso).1⟩
refine is_limit.of_faithful (forget (Algebra R)) (types.limit_cone_is_limit _) (λ s, { .. }) (λ s, rfl)
simp only [forget_map_eq_coe, alg_hom.map_one, functor.map_cone_π_app]
refl
{ simp only [forget_map_eq_coe, alg_hom.map_one, functor.map_cone_π_app], refl, }
simp only [forget_map_eq_coe, alg_hom.map_mul, functor.map_cone_π_app]
intros x y
refl
{ intros x y, simp only [forget_map_eq_coe, alg_hom.map_mul, functor.map_cone_π_app], refl, }
simp only [forget_map_eq_coe, alg_hom.map_zero, functor.map_cone_π_app]
refl
{ simp only [forget_map_eq_coe, alg_hom.map_zero, functor.map_cone_π_app], refl, }
simp only [forget_map_eq_coe, alg_hom.map_add, functor.map_cone_π_app]
intros x y
refl
{ intros x y, simp only [forget_map_eq_coe, alg_hom.map_add, functor.map_cone_π_app], refl, }
ext j
exact (s.π.app j).commutes r
intros r
simp [h]
apply_instance
ext
induction x
induction x
have w' := congr_fun (congr_arg (λ f : F.obj x_j ⟶ s.X, (f : F.obj x_j → s.X)) (w x_j)) x_x
erw w'
{ have w' := congr_fun (congr_arg (λ f : F.obj x_j ⟶ s.X, (f : F.obj x_j → s.X)) (w x_j)) x_x, erw w', refl, }
refl
{ simp, }
simp
{ simp, }
simp
{ simp *, }
simp *
{ simp *, }
simp *
{ simp *, }
simp *
refl
exactI { preserves_limit := λ F, limits.comp_preserves_limit (forget₂ Ring SemiRing) (forget SemiRing) }
apply_instance
change comm_ring (F.obj j)
apply_instance
intros
simp only [preadditive.add_comp]
intros
simp only [preadditive.comp_add]
apply_instance
simp [h]
apply_instance
simp only [h, linear_map.map_zero]
simp
simp
fapply @quot.lift
intro x
{ intro x, exact quot.mk _ (smul s x) }
exact quot.mk _ (smul s x)
intros x x' r
apply quot.sound
exact relation.smul_1 s _ _ r
induction x
dsimp
apply quot.sound
apply relation.one_smul
refl
induction x
dsimp
apply quot.sound
apply relation.mul_smul
refl
induction x
induction y
dsimp
apply quot.sound
apply relation.smul_add
refl
refl
apply quot.sound
apply relation.smul_zero
induction x
dsimp
apply quot.sound
apply relation.add_smul
induction x
dsimp
apply quot.sound
apply relation.zero_smul
apply M.mk_eq
obtain ⟨k, f, g, hfg⟩ := h
use [k, f, g]
simp only [category_theory.functor.comp_map, forget_map_eq_coe] at hfg
rw [linear_map.map_smul, linear_map.map_smul, hfg]
convert colimit.iso_colimit_cocone_ι_hom _ _; refl
refl
refl
convert colimit.iso_colimit_cocone_ι_hom _ _
tidy
match_target (R : Type u)
match_hyp x : (R : Type u)
exact x * x
simp
rw [mul_assoc x y (x * y), ←mul_assoc y x y, mul_comm y x, mul_assoc, mul_assoc]
apply_instance
rw function.left_inverse
simp
rw function.right_inverse
rw function.left_inverse
simp
simp
apply_instance
rw [commute.add_pow h, finset.sum_range_succ_comm, nat.sub_self, pow_zero, nat.choose_self]
rw [nat.cast_one, mul_one, mul_one]
congr' 1
convert finset.sum_eq_single 0 _ _
simp only [mul_one, one_mul, nat.choose_zero_right, nat.sub_zero, nat.cast_one, pow_zero]
{ simp only [mul_one, one_mul, nat.choose_zero_right, nat.sub_zero, nat.cast_one, pow_zero] }
intros b h1 h2
rw this
simp
{ rw this, simp }
suffices : (p.choose b : R) = 0
rw char_p.cast_eq_zero_iff R p
refine nat.prime.dvd_choose_self (pos_iff_ne_zero.mpr h2) _ (fact.out _)
{ intros b h1 h2, suffices : (p.choose b : R) = 0, { rw this, simp }, rw char_p.cast_eq_zero_iff R p, refine nat.prime.dvd_choose_self (pos_iff_ne_zero.mpr h2) _ (fact.out _), rwa ← finset.mem_range }
rwa ← finset.mem_range
intro h1
contrapose! h1
rw finset.mem_range
exact nat.prime.pos (fact.out _)
convert nat.lcm.char_p R S p p; simp
simp
convert nat.lcm.char_p R S p p
rwa [nat.cast_two] at this
dsimp [bit0] at h
simp only [(two_mul a).symm, (two_mul b).symm] at h
refine nat_mul_inj' _ two_ne_zero
exact_mod_cast h
simp [int_fract_pair.of, v_eq_q, fract]
exact a * b
rw [direct_sum.of_mul_of, semiring.direct_sum_mul]
apply units.dvd_mul_right
rcases hu with ⟨u, rfl⟩
rw gcd_zero_left
exact ⟨dvd_zero _, dvd_rfl⟩
rw gcd_val
exact ⟨IH₂, (dvd_mod_iff IH₂).1 IH₁⟩
have := @xgcd_aux_P _ _ _ a b a b 1 0 0 1 (by rw [P, mul_one, mul_zero, add_zero]) (by rw [P, mul_one, mul_zero, zero_add])
rw [P, mul_one, mul_zero, zero_add]
rw [P, mul_one, mul_zero, add_zero]
rwa [xgcd_aux_val, xgcd_val] at this
intros m n h
rcases h₁.lt_or_lt with H|H
apply (fpow_strict_mono (one_lt_inv h₀ H)).injective
show x⁻¹ ^ m = x⁻¹ ^ n
rw [← fpow_neg_one, ← fpow_mul, ← fpow_mul, mul_comm _ m, mul_comm _ n, fpow_mul, fpow_mul, h]
{ apply (fpow_strict_mono (one_lt_inv h₀ H)).injective, show x⁻¹ ^ m = x⁻¹ ^ n, rw [← fpow_neg_one, ← fpow_mul, ← fpow_mul, mul_comm _ m, mul_comm _ n, fpow_mul, fpow_mul, h], }
exact (fpow_strict_mono H).injective h
rw [ceil, neg_le, le_floor, int.cast_neg, neg_le_neg_iff]
ext
simp [h]
have h1 : gcd (d₁ ^ k) b = 1
rw normalize_eq_one
rw ← normalize_gcd (d₁ ^ k) b
apply is_unit_of_dvd_one
transitivity (gcd d₁ b) ^ k
{ exact gcd_pow_left_dvd_pow_gcd }
exact gcd_pow_left_dvd_pow_gcd
apply is_unit.pow
apply is_unit_of_dvd_one
apply is_unit.dvd
apply gcd_dvd_gcd hd₁ (dvd_refl b)
{ rw ← normalize_gcd (d₁ ^ k) b, rw normalize_eq_one, apply is_unit_of_dvd_one, transitivity (gcd d₁ b) ^ k, { exact gcd_pow_left_dvd_pow_gcd }, { apply is_unit.dvd, apply is_unit.pow, apply is_unit_of_dvd_one, rw ← hab, apply gcd_dvd_gcd hd₁ (dvd_refl b) } }
rw ← hab
use d₂ ^ k
have h2 : d₁ ^ k ∣ a * b
rw [h, hc]
exact mul_pow d₁ d₂ k
{ use d₂ ^ k, rw [h, hc], exact mul_pow d₁ d₂ k }
rw mul_comm at h2
rw [← one_mul a, ← h1]
have h3 : d₁ ^ k ∣ a
apply dvd_gcd_mul_of_dvd_mul h2
{ rw [← one_mul a, ← h1], apply dvd_gcd_mul_of_dvd_mul h2 }
have h4 : d₁ ^ k ≠ 0
rw hdk at h3
apply absurd (zero_dvd_iff.mp h3) ha
intro hdk
{ intro hdk, rw hdk at h3, apply absurd (zero_dvd_iff.mp h3) ha }
tauto
simp
by_cases a ∈ s; simp [IH, h]
simp [IH, h]
simp [IH, h]
by_cases a ∈ s
unfold lcm
rw [← cons_erase h, fold_cons_left, ← lcm_assoc, lcm_same]
apply lcm_eq_of_associated_left (associated_normalize _)
have f_last : f (n + 1) n = (x + y) ^ n := by { dsimp [f], rw [nat.sub_sub, nat.add_comm, nat.sub_self, pow_zero, mul_one] }
dsimp [f]
rw [nat.sub_sub, nat.add_comm, nat.sub_self, pow_zero, mul_one]
have f_succ : ∀ i, i ∈ range n → f (n + 1) i = y * f n i := λ i hi, by { dsimp [f], have : commute y ((x + y) ^ i) := (h.symm.add_right (commute.refl y)).pow_right i, rw [← mul_assoc, this.eq, mul_assoc, ← pow_succ y (n - 1 - i)], congr' 2, rw [nat.add_sub_cancel, nat.sub_sub, add_comm 1 i], have : i + 1 + (n - (i + 1)) = n := nat.add_sub_of_le (mem_range.mp hi), rw [add_comm (i + 1)] at this, rw [← this, nat.add_sub_cancel, add_comm i 1, ← add_assoc, nat.add_sub_cancel] }
dsimp [f]
have : commute y ((x + y) ^ i) := (h.symm.add_right (commute.refl y)).pow_right i
rw [← mul_assoc, this.eq, mul_assoc, ← pow_succ y (n - 1 - i)]
congr' 2
rw [nat.add_sub_cancel, nat.sub_sub, add_comm 1 i]
have : i + 1 + (n - (i + 1)) = n := nat.add_sub_of_le (mem_range.mp hi)
rw [add_comm (i + 1)] at this
rw [← this, nat.add_sub_cancel, add_comm i 1, ← add_assoc, nat.add_sub_cancel]
rw [pow_succ (x + y), add_mul, sum_range_succ_comm, add_mul, f_last, add_assoc]
rw (((commute.refl x).add_right h).pow_right n).eq
congr' 1
rw [sum_congr rfl f_succ, ← mul_sum, pow_succ y, mul_assoc, ← mul_add y, ih]
convert neg_div_neg_eq (x^m - x^n) (1-x)
simp only [geom_sum_Ico hx hmn]
convert neg_div_neg_eq (x^m - x^n) (1-x); abel
abel
abel
let f := λ (m i : ℕ), (x + y) ^ i * y ^ (m - 1 - i)
change (∑ i in range n, (f n) i) * x + y ^ n = (x + y) ^ n
induction n with n ih
rw [range_zero, sum_empty, zero_mul, zero_add, pow_zero, pow_zero]
{ rw [range_zero, sum_empty, zero_mul, zero_add, pow_zero, pow_zero] }
rw one_mul
rw [sub_eq_iff_eq_add, sub_add_eq_add_sub, sub_eq_iff_eq_add', add_sub_assoc]
by_cases h : P; simp [h]
simp [h]
simp [h]
by_cases h : P
rw [semiconj_by, mul_comm, ← units.mul_inv_eq_iff_eq_mul, mul_assoc, c.mul_inv, mul_one] at hc
exact hc
rw h
let iM : div_inv_monoid M := m₁
unfreezingI { cases m₁ with mul₁ _ one₁ one_mul₁ mul_one₁ npow₁ npow_zero₁ npow_succ₁ inv₁ div₁ div_eq_mul_inv₁ gpow₁ gpow_zero'₁ gpow_succ'₁ gpow_neg'₁, cases m₂ with mul₂ _ one₂ one_mul₂ mul_one₂ npow₂ npow_zero₂ npow_succ₂ inv₂ div₂ div_eq_mul_inv₂ gpow₂ gpow_zero'₂ gpow_succ'₂ gpow_neg'₂ }
cases m₁ with mul₁ _ one₁ one_mul₁ mul_one₁ npow₁ npow_zero₁ npow_succ₁ inv₁ div₁ div_eq_mul_inv₁ gpow₁ gpow_zero'₁ gpow_succ'₁ gpow_neg'₁
cases m₂ with mul₂ _ one₂ one_mul₂ mul_one₂ npow₂ npow_zero₂ npow_succ₂ inv₂ div₂ div_eq_mul_inv₂ gpow₂ gpow_zero'₂ gpow_succ'₂ gpow_neg'₂
change mul₁ = mul₂ at h_mul
subst h_mul
have h_one : one₁ = one₂
rw ←one_mul₂ one₁
{ rw ←one_mul₂ one₁, exact mul_one₁ one₂ }
exact mul_one₁ one₂
subst h_one
have h_npow : npow₁ = npow₂
ext n
induction n with d hd
{ rw [npow_zero₁, npow_zero₂] }
rw [npow_zero₁, npow_zero₂]
{ ext n, induction n with d hd, { rw [npow_zero₁, npow_zero₂] }, { rw [npow_succ₁, npow_succ₂, hd] } }
rw [npow_succ₁, npow_succ₂, hd]
subst h_npow
change inv₁ = inv₂ at h_inv
subst h_inv
have h_div : div₁ = div₂
ext a b
convert (rfl : a * b⁻¹ = a * b⁻¹)
{ exact div_eq_mul_inv₁ a b }
exact div_eq_mul_inv₁ a b
{ ext a b, convert (rfl : a * b⁻¹ = a * b⁻¹), { exact div_eq_mul_inv₁ a b }, { exact div_eq_mul_inv₂ a b } }
exact div_eq_mul_inv₂ a b
subst h_div
have h_gpow_aux : ∀ n g, gpow₁ (int.of_nat n) g = gpow₂ (int.of_nat n) g
intros n g
induction n with n IH
convert (rfl : (1 : M) = 1)
{ exact gpow_zero'₁ g }
exact gpow_zero'₁ g
{ convert (rfl : (1 : M) = 1), { exact gpow_zero'₁ g }, { exact gpow_zero'₂ g } }
exact gpow_zero'₂ g
{ intros n g, induction n with n IH, { convert (rfl : (1 : M) = 1), { exact gpow_zero'₁ g }, { exact gpow_zero'₂ g } }, { rw [gpow_succ'₁, gpow_succ'₂, IH] } }
rw [gpow_succ'₁, gpow_succ'₂, IH]
have h_gpow : gpow₁ = gpow₂
ext z
cases z with z z
{ exact h_gpow_aux z x }
exact h_gpow_aux z x
rw [gpow_neg'₁, gpow_neg'₂]
congr'
{ ext z, cases z with z z, { exact h_gpow_aux z x }, { rw [gpow_neg'₁, gpow_neg'₂], congr', exact h_gpow_aux _ _ } }
exact h_gpow_aux _ _
subst h_gpow
cases f; cases g; cases h; refl
cases f; cases g; cases h
cases f; cases g
cases g
cases h
refl
cases f
rw [← one_hom.comp_apply, h, one_hom.comp_apply]
simp only [one_hom.map_one, one_hom.coe_comp, function.comp_app, one_hom.one_apply]
ext
simp only [map_one, coe_comp, function.comp_app, one_apply]
ext
refine_struct { mul := (*), .. }; tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
refine_struct { mul := (*), .. }
simp [coprod_apply, inl_apply, inr_apply, ← map_mul]
refine_struct { mul := (*), one := (1 : ulift α), .. }
refine_struct { mul := (*), one := (1 : ulift α), .. }; tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
rw [units.inv_mul, mul_one]
simp
simp
simp only [pow_zero, one_mul]
simp only [pow_succ, ihn, ← mul_assoc, (h.pow_left n).right_comm]
rw [bit1, gpow_add, gpow_bit0, gpow_one]
rw [mul_add, add_gsmul, one_gsmul]
dsimp [bit0]
rw [pow_zero]
rw [pow_succ]
exact mul_le_one h1 (pow_nonneg h0 _) (pow_le_one n h0 h1)
exact (one_left a).cast_int_mul_left m
rw [← mul_one (m : R)]
rw [← abs_of_nonneg hy]
exact abs_lt_abs_of_sq_lt_sq h
simp [*]
rw [mul_inv_rev', div_eq_mul_inv]
rw [div_eq_mul_inv, mul_assoc, mul_comm b, ← mul_assoc, div_eq_mul_inv]
rw [← mul_div_assoc, mul_comm, mul_div_assoc]
rw [gpow_coe_nat, gpow_coe_nat, ← pow_mul, ← gpow_coe_nat]
refl
rw [gpow_coe_nat, gpow_neg_succ_of_nat, ← pow_mul, coe_nat_mul_neg_succ, fpow_neg, inv_inj', ← gpow_coe_nat]
refl
rw [gpow_coe_nat, gpow_neg_succ_of_nat, ← inv_pow', ← pow_mul, neg_succ_mul_coe_nat, fpow_neg, inv_pow', inv_inj', ← gpow_coe_nat]
refl
rw [gpow_neg_succ_of_nat, gpow_neg_succ_of_nat, neg_succ_mul_neg_succ, inv_pow', inv_inv', ← pow_mul, ← gpow_coe_nat]
refl
rw [← congr_arg has_inv.inv (pow_one x), fpow_neg, ← gpow_coe_nat]
refl
simp [single_map_homological_complex, h]
dsimp [homology_functor]
ext
simp only [limits.cokernel.π_desc, limits.comp_zero, homology.π_map]
convert zero_comp
ext
simp
dsimp [homology_functor]
ext
simp only [homology.π_map, preadditive.comp_add, ←preadditive.add_comp]
congr
simp
ext
obtain ⟨k, w₁, w₂⟩ := w
obtain ⟨k', w₁', w₂'⟩ := w'
rw c₁.next_eq w₁ w₁' at w₂
exact c₂.next_eq w₂ w₂'
obtain ⟨k, w₁, w₂⟩ := w
obtain ⟨k', w₁', w₂'⟩ := w'
rw c₂.prev_eq w₂ w₂' at w₁
exact c₁.prev_eq w₁ w₁'
rcases h : c.next i with _ | ⟨j,w⟩
ext
{ refl }
refl
simp only [next, h]
dsimp
symmetry
apply zero_of_target_iso_zero
{ ext, { refl }, { dsimp, simp only [next, h], symmetry, apply zero_of_target_iso_zero, exact X_next_iso_zero _ h } }
exact X_next_iso_zero _ h
refl
dsimp
simp [next, h]
ext
rw [if_pos rfl, category.id_comp]
change ite (1 = 0 + 1) (𝟙 X₁ ≫ d₀) 0 = d₀
dsimp [prev_d]
rcases c.prev j with _|⟨j',w⟩
{ exact zero_comp.symm, }
exact zero_comp.symm
dsimp [prev_d]
simp
simp
refl
simp
refl
simpa using w
simp
ext
simp
simp
simp
simp
ext
simp only [indicator]
split_ifs
refl
{ refl }
rw mul_zero
funext
simpa [ha] using hfg ha
simpa [ha] using hg ha
exact subset.trans h1 h2
rw mul_indicator_eq_self at h1 ⊢
simp [←mul_assoc]
rw [← f.map_mul, inv_of_mul_self, f.map_one]
rw [← f.map_mul, mul_inv_of_self, f.map_one]
rw [mul_one a, div_eq_mul_inv, mul_comm b, mul_inv_cancel_left]
rw ← mul_inf_eq_mul_inf_mul 1 (b / a) a
rw inf_comm
rw div_eq_mul_inv
nth_rewrite 0 ← inv_inv b
rw [← mul_inv, mul_comm b⁻¹, ← div_eq_mul_inv]
rw one_inv
rw [← inv_sup_eq_inv_inf_inv, ← div_eq_mul_inv]
simp
ext
simp
ext
simp [nat.succ_eq_one_add, add_nsmul]
rw [lie_module.is_trivial.trivial, lie_ring.of_associative_ring_bracket, mul_comm, sub_self, linear_map.to_fun_eq_coe, linear_map.map_zero]
ext
refl
ext
refl
erw mem_skew_adjoint_matrices_submodule
simp only [matrix.is_skew_adjoint, matrix.is_adjoint_pair, matrix.mul_one, matrix.one_mul]
apply matrix.nonsing_inv_left_right
exact PB_inv l R
ext i j
rcases i with ⟨⟨i₁ | i₂⟩ | i₃⟩; rcases j with ⟨⟨j₁ | j₂⟩ | j₃⟩; simp only [indefinite_diagonal, matrix.diagonal, equiv.sum_assoc_apply_in1, matrix.reindex_lie_equiv_apply, matrix.minor_apply, equiv.symm_symm, matrix.reindex_apply, sum.elim_inl, if_true, eq_self_iff_true, matrix.one_apply_eq, matrix.from_blocks_apply₁₁, dmatrix.zero_apply, equiv.sum_assoc_apply_in2, if_false, matrix.from_blocks_apply₁₂, matrix.from_blocks_apply₂₁, matrix.from_blocks_apply₂₂, equiv.sum_assoc_apply_in3, sum.elim_inr]; congr
rcases i with ⟨⟨i₁ | i₂⟩ | i₃⟩; rcases j with ⟨⟨j₁ | j₂⟩ | j₃⟩; simp only [indefinite_diagonal, matrix.diagonal, equiv.sum_assoc_apply_in1, matrix.reindex_lie_equiv_apply, matrix.minor_apply, equiv.symm_symm, matrix.reindex_apply, sum.elim_inl, if_true, eq_self_iff_true, matrix.one_apply_eq, matrix.from_blocks_apply₁₁, dmatrix.zero_apply, equiv.sum_assoc_apply_in2, if_false, matrix.from_blocks_apply₁₂, matrix.from_blocks_apply₂₁, matrix.from_blocks_apply₂₂, equiv.sum_assoc_apply_in3, sum.elim_inr]
rcases i with ⟨⟨i₁ | i₂⟩ | i₃⟩; rcases j with ⟨⟨j₁ | j₂⟩ | j₃⟩
rcases i with ⟨⟨i₁ | i₂⟩ | i₃⟩
rcases j with ⟨⟨j₁ | j₂⟩ | j₃⟩
rcases j with ⟨⟨j₁ | j₂⟩ | j₃⟩
rcases j with ⟨⟨j₁ | j₂⟩ | j₃⟩
simp only [indefinite_diagonal, matrix.diagonal, equiv.sum_assoc_apply_in1, matrix.reindex_lie_equiv_apply, matrix.minor_apply, equiv.symm_symm, matrix.reindex_apply, sum.elim_inl, if_true, eq_self_iff_true, matrix.one_apply_eq, matrix.from_blocks_apply₁₁, dmatrix.zero_apply, equiv.sum_assoc_apply_in2, if_false, matrix.from_blocks_apply₁₂, matrix.from_blocks_apply₂₁, matrix.from_blocks_apply₂₂, equiv.sum_assoc_apply_in3, sum.elim_inr]
simp only [indefinite_diagonal, matrix.diagonal, equiv.sum_assoc_apply_in1, matrix.reindex_lie_equiv_apply, matrix.minor_apply, equiv.symm_symm, matrix.reindex_apply, sum.elim_inl, if_true, eq_self_iff_true, matrix.one_apply_eq, matrix.from_blocks_apply₁₁, dmatrix.zero_apply, equiv.sum_assoc_apply_in2, if_false, matrix.from_blocks_apply₁₂, matrix.from_blocks_apply₂₁, matrix.from_blocks_apply₂₂, equiv.sum_assoc_apply_in3, sum.elim_inr]
simp only [indefinite_diagonal, matrix.diagonal, equiv.sum_assoc_apply_in1, matrix.reindex_lie_equiv_apply, matrix.minor_apply, equiv.symm_symm, matrix.reindex_apply, sum.elim_inl, if_true, eq_self_iff_true, matrix.one_apply_eq, matrix.from_blocks_apply₁₁, dmatrix.zero_apply, equiv.sum_assoc_apply_in2, if_false, matrix.from_blocks_apply₁₂, matrix.from_blocks_apply₂₁, matrix.from_blocks_apply₂₂, equiv.sum_assoc_apply_in3, sum.elim_inr]
simp only [indefinite_diagonal, matrix.diagonal, equiv.sum_assoc_apply_in1, matrix.reindex_lie_equiv_apply, matrix.minor_apply, equiv.symm_symm, matrix.reindex_apply, sum.elim_inl, if_true, eq_self_iff_true, matrix.one_apply_eq, matrix.from_blocks_apply₁₁, dmatrix.zero_apply, equiv.sum_assoc_apply_in2, if_false, matrix.from_blocks_apply₁₂, matrix.from_blocks_apply₂₁, matrix.from_blocks_apply₂₂, equiv.sum_assoc_apply_in3, sum.elim_inr]
simp only [indefinite_diagonal, matrix.diagonal, equiv.sum_assoc_apply_in1, matrix.reindex_lie_equiv_apply, matrix.minor_apply, equiv.symm_symm, matrix.reindex_apply, sum.elim_inl, if_true, eq_self_iff_true, matrix.one_apply_eq, matrix.from_blocks_apply₁₁, dmatrix.zero_apply, equiv.sum_assoc_apply_in2, if_false, matrix.from_blocks_apply₁₂, matrix.from_blocks_apply₂₁, matrix.from_blocks_apply₂₂, equiv.sum_assoc_apply_in3, sum.elim_inr]
simp only [indefinite_diagonal, matrix.diagonal, equiv.sum_assoc_apply_in1, matrix.reindex_lie_equiv_apply, matrix.minor_apply, equiv.symm_symm, matrix.reindex_apply, sum.elim_inl, if_true, eq_self_iff_true, matrix.one_apply_eq, matrix.from_blocks_apply₁₁, dmatrix.zero_apply, equiv.sum_assoc_apply_in2, if_false, matrix.from_blocks_apply₁₂, matrix.from_blocks_apply₂₁, matrix.from_blocks_apply₂₂, equiv.sum_assoc_apply_in3, sum.elim_inr]
simp only [indefinite_diagonal, matrix.diagonal, equiv.sum_assoc_apply_in1, matrix.reindex_lie_equiv_apply, matrix.minor_apply, equiv.symm_symm, matrix.reindex_apply, sum.elim_inl, if_true, eq_self_iff_true, matrix.one_apply_eq, matrix.from_blocks_apply₁₁, dmatrix.zero_apply, equiv.sum_assoc_apply_in2, if_false, matrix.from_blocks_apply₁₂, matrix.from_blocks_apply₂₁, matrix.from_blocks_apply₂₂, equiv.sum_assoc_apply_in3, sum.elim_inr]
simp only [indefinite_diagonal, matrix.diagonal, equiv.sum_assoc_apply_in1, matrix.reindex_lie_equiv_apply, matrix.minor_apply, equiv.symm_symm, matrix.reindex_apply, sum.elim_inl, if_true, eq_self_iff_true, matrix.one_apply_eq, matrix.from_blocks_apply₁₁, dmatrix.zero_apply, equiv.sum_assoc_apply_in2, if_false, matrix.from_blocks_apply₁₂, matrix.from_blocks_apply₂₁, matrix.from_blocks_apply₂₂, equiv.sum_assoc_apply_in3, sum.elim_inr]
simp only [indefinite_diagonal, matrix.diagonal, equiv.sum_assoc_apply_in1, matrix.reindex_lie_equiv_apply, matrix.minor_apply, equiv.symm_symm, matrix.reindex_apply, sum.elim_inl, if_true, eq_self_iff_true, matrix.one_apply_eq, matrix.from_blocks_apply₁₁, dmatrix.zero_apply, equiv.sum_assoc_apply_in2, if_false, matrix.from_blocks_apply₁₂, matrix.from_blocks_apply₂₁, matrix.from_blocks_apply₂₂, equiv.sum_assoc_apply_in3, sum.elim_inr]
congr
congr
erw lie_submodule.lie_span_le
rw map_le_iff_le_comap
obtain ⟨⟨y₁, hy₁⟩, ⟨y₂, hy₂⟩, hx⟩ := hx
intros x hx
rw ← hx
let fy₁ : ↥(map f I₁) := ⟨f y₁, mem_map hy₁⟩
let fy₂ : ↥(map f I₂) := ⟨f y₂, mem_map hy₂⟩
change _ ∈ comap f ⁅map f I₁, map f I₂⁆
simp only [submodule.coe_mk, mem_comap, lie_hom.map_lie]
exact lie_submodule.lie_coe_mem_lie _ _ fy₁ fy₂
ext m
change mk ⁅⁅x, y⁆, m⁆ = mk (⁅x, ⁅y, m⁆⁆ - ⁅y, ⁅x, m⁆⁆)
congr
apply lie_lie
rw [is_lie_abelian_iff_center_eq_top R L, center_eq_bot_of_semisimple] at h
exact (lie_submodule.subsingleton_iff R L L).mp (subsingleton_of_bot_eq_top h)
rw [← coe_to_submodule, Inf_coe_to_submodule, submodule.Inf_coe]
ext x
simpa only [mem_Inter, mem_set_of_eq, forall_apply_eq_imp_iff₂, exists_imp_distrib]
apply set_coe.ext
exact lie_hom.map_lie (↑e : L₁ →ₗ⁅R⁆ L₂) ↑x ↑y
rw ←h
refl
intros h x hx
intros h x hx
split
split; intros h x hx
rw mem_ker at h
exact h
{ specialize h hx, rw mem_ker at h, exact h, }
specialize h hx
apply h x hx
rw mem_ker
suffices : (lift_lie R L M N P f : M ⊗[R] N →ₗ[R] P) = lift R L M N P f
{ rw [← this, lie_module_hom.coe_to_linear_map], }
rw [← this, lie_module_hom.coe_to_linear_map]
ext m n
simp only [lift_lie, linear_equiv.trans_apply, lie_module_equiv.coe_to_linear_equiv, coe_linear_map_max_triv_linear_map_equiv_lie_module_hom, coe_max_triv_equiv_apply, coe_linear_map_max_triv_linear_map_equiv_lie_module_hom_symm]
simp only [coe_lift_lie_eq_lift_coe, lie_module_hom.coe_to_linear_map, lift_apply]
rw [←function.comp_apply (lift R f) (ι R) x, ι_comp_lift]
have h₀ : (0 : L → R) ∘ (⊤ : lie_subalgebra R L).incl = 0
ext
refl
{ ext, refl, }
rw [← lie_submodule.coe_to_submodule_eq_iff, lie_submodule.top_coe_submodule, ← h₀, coe_weight_space_of_top, ← infi_max_gen_zero_eigenspace_eq_top_of_nilpotent R L M]
refl
simp only [zero_smul]
simp only [one_smul, add_smul, ih]
simp only [one_smul, sub_smul, ih]
simp only [←gsmul_eq_smul_cast, f.map_gsmul]
rw [←neg_neg c, neg_smul, neg_smul (-c), neg_lt_neg_iff]
exact smul_lt_smul_of_pos h (neg_pos_of_neg hc)
rw [←neg_neg c, neg_smul, neg_smul (-c), neg_lt_neg_iff]
exact smul_lt_smul_iff_of_pos (neg_pos_of_neg hc)
intros
ext x
apply smul_add
intros
ext x
apply smul_zero
rintros x ⟨y, h, rfl⟩ i hi
exact smul_mem_smul_set (h i hi)
rw [infi, Inf_coe]; ext a; simp; exact ⟨λ h i, h _ i rfl, λ h i x e, e ▸ h _⟩
rw [infi, Inf_coe]; ext a; simp
rw [infi, Inf_coe]; ext a
ext a
simp
rw [infi, Inf_coe]
ext
simp [smul_zero]
ext
simp [smul_add]
ext
simp only [mem_filter, mem_product, hs, and_comm]
simp only [mem_filter, mem_support_iff, not_and, not_not] at hp ⊢
by_cases h1 : f p.1 = 0
{ rw [h1, zero_mul] }
rw [h1, zero_mul]
rw [hp hps h1, mul_zero]
simp [ha]
{ simp [ha] }
by_cases ha : a = 0
refine (mul_self_eq_mul_self_iff.mp (by rw [← abv.map_mul, neg_mul_neg, abv.map_mul])).resolve_right _
rw [← abv.map_mul, neg_mul_neg, abv.map_mul]
exact ((neg_lt_zero.mpr (abv.pos ha)).trans (abv.pos (neg_ne_zero.mpr ha))).ne'
rw [← neg_sub, abv_neg abv]
exacts [iff.rfl, eq_comm, iff.rfl]
cases o
rw [mul_comm, le_div_iff hc]
rw [div_eq_mul_one_div a c, div_eq_mul_one_div b c]
exact mul_le_mul_of_nonneg_right h (one_div_nonneg.2 hc)
rcases lt_trichotomy b 0 with (hb|rfl|hb)
{ simp [hb, hb.not_lt, hb.ne, div_lt_one_of_neg] }
simp [hb, hb.not_lt, hb.ne, div_lt_one_of_neg]
{ simp [zero_lt_one], }
simp [zero_lt_one]
simp [hb, hb.not_lt, div_lt_one, hb.ne.symm]
simpa using inv_le_inv_of_le ha h
rwa add_halves at this
rw [sub_add_eq_sub_sub, sub_self, zero_sub]
refine ⟨eq_or_eq_neg_of_abs_eq, _⟩
rintro (rfl|rfl); simp only [abs_neg, abs_of_nonneg hb]
simp only [abs_neg, abs_of_nonneg hb]
simp only [abs_neg, abs_of_nonneg hb]
rintro (rfl|rfl)
rw [← mul_lt_mul_iff_right a, inv_mul_self, one_mul]
rw [div_le_iff_le_mul, mul_comm]
exact rfl
refine with_top.rec_top_coe _ _
{ simpa }
simpa
intro
rw [←with_top.coe_zero, ←with_top.coe_add, zero_add]
refine with_top.rec_top_coe _ _
{ simpa }
simpa
intro
rw [←with_top.coe_zero, ←with_top.coe_add, add_zero]
haveI := @linear_order.decidable_le α _; exact ⟨nonneg_and_nonneg_or_nonpos_and_nonpos_of_mul_nnonneg, λ h, h.elim (and_imp.2 decidable.mul_nonneg) (and_imp.2 decidable.mul_nonneg_of_nonpos_of_nonpos)⟩
exact ⟨nonneg_and_nonneg_or_nonpos_and_nonpos_of_mul_nnonneg, λ h, h.elim (and_imp.2 decidable.mul_nonneg) (and_imp.2 decidable.mul_nonneg_of_nonpos_of_nonpos)⟩
haveI := @linear_order.decidable_le α _
rw [← abs_mul_abs_self, ← abs_mul_abs_self b]
exact mul_self_le_mul_self_iff (abs_nonneg a) (abs_nonneg b)
cases abs_choice b with h h; simp only [h, dvd_neg]
simp only [h, dvd_neg]
simp only [h, dvd_neg]
cases abs_choice b with h h
rw [mul_add, mul_two, add_assoc]
haveI := @linear_order.decidable_le α _; exact lt_of_not_ge (assume h1 : b ≤ a, have h2 : c * b ≤ c * a, from decidable.mul_le_mul_of_nonneg_left h1 hc, h2.not_lt h)
exact lt_of_not_ge (assume h1 : b ≤ a, have h2 : c * b ≤ c * a, from decidable.mul_le_mul_of_nonneg_left h1 hc, h2.not_lt h)
haveI := @linear_order.decidable_le α _
haveI := @linear_order.decidable_le α _; exact lt_of_not_ge (assume h1 : b ≤ a, have h2 : b * c ≤ a * c, from decidable.mul_le_mul_of_nonneg_right h1 hc, h2.not_lt h)
exact lt_of_not_ge (assume h1 : b ≤ a, have h2 : b * c ≤ a * c, from decidable.mul_le_mul_of_nonneg_right h1 hc, h2.not_lt h)
haveI := @linear_order.decidable_le α _
haveI := @linear_order.decidable_le α _; exact ⟨λ h, nonneg_of_mul_nonneg_right h ha, λ h, decidable.mul_nonneg h ha.le⟩
exact ⟨λ h, nonneg_of_mul_nonneg_right h ha, λ h, decidable.mul_nonneg h ha.le⟩
haveI := @linear_order.decidable_le α _
classical; exact decidable.mul_le_mul_of_nonpos_right
exact decidable.mul_le_mul_of_nonpos_right
classical
rwa [← hc, zero_smul, zero_smul] at h
rw [sub_sub', add_sub_cancel_of_le h]
exact hc.lt_sub_iff_right_of_le h
rw [add_comm]
rw [hc.lt_sub_iff_left, add_sub_cancel_of_le h]
refine ⟨_, λ h, ha.sub_lt_self hb h.1 h.2⟩
intro h
refine ⟨(zero_le _).trans_lt h, (zero_le b).lt_of_ne _⟩
rintro rfl
rw [sub_zero'] at h
exact h.false
apply min_le_left
rw [← sub_min, sub_add_cancel_of_le]
simpa using leading_coeff_multiset_prod' (s.1.map f) (by simpa using h)
simpa using h
refine { le_iff_exists_add := λ _ _, iff_of_true _ ⟨star, subsingleton.elim _ _⟩, .. punit.comm_ring, .. punit.complete_boolean_algebra, .. }
refine { le_iff_exists_add := λ _ _, iff_of_true _ ⟨star, subsingleton.elim _ _⟩, .. punit.comm_ring, .. punit.complete_boolean_algebra, .. }; intros; trivial
refine { le_iff_exists_add := λ _ _, iff_of_true _ ⟨star, subsingleton.elim _ _⟩, .. punit.comm_ring, .. punit.complete_boolean_algebra, .. }; intros
intros
intros
trivial
trivial
apply (act x).symm.injective
rintro rfl
refl
split
op_induction x
simp
ext
ext; simp; ring_exp
ext; simp
simp
simp
simp
simp
ring_exp
ring_exp
ring_exp
ring_exp
simpa only [le_antisymm_iff, norm_sq_nonneg, and_true] using @norm_sq_eq_zero _ _ a
simp only [lift, algebra.algebra_map_eq_smul_one]
simp only [add_mul]
simp only [add_mul, mul_add, smul_mul_assoc, mul_smul_comm, one_mul, mul_one, ←algebra.smul_def, smul_add, smul_smul]
simp only [i_mul_i, j_mul_j, i_mul_j, j_mul_i, i_mul_k, k_mul_i, k_mul_j, j_mul_k, k_mul_k]
simp only [smul_smul, smul_neg, sub_eq_add_neg, add_smul, ←add_assoc, mul_neg_eq_neg_mul_symm, neg_smul]
simp only [mul_right_comm _ _ (c₁ * c₂), mul_comm _ (c₁ * c₂)]
simp only [mul_comm _ c₁, mul_right_comm _ _ c₁]
simp only [mul_comm _ c₂, mul_right_comm _ _ c₂]
simp only [←mul_comm c₁ c₂, ←mul_assoc]
simp [sub_eq_add_neg, add_smul, ←add_assoc]
abel
simp only [semiconj_by, left_distrib, right_distrib, ha.eq, hb.eq]
simp only [semiconj_by, h.eq, neg_mul_eq_neg_mul_symm, mul_neg_eq_neg_mul_symm]
by_cases h : P; simp [h]
simp [h]
simp [h]
by_cases h : P
rw [bit1, bit0, two_mul]
simpa only [sub_eq_add_neg, neg_mul_eq_neg_mul] using add_mul a (-b) c
rw [mul_add, mul_one, mul_self, add_self]
rw [←add_eq_zero, mul_add_mul]
simp
simp
cases x
cases x; simp
simp
dsimp
rw mk_ring_hom_rel h
classical
rw support_single
split_ifs; simp
simp
simp
split_ifs
simpa using h
cases le_total x y with h h
rw [add_eq_left h, add_eq_left (pow_le_pow_of_le_left' h _)]
{ rw [add_eq_left h, add_eq_left (pow_le_pow_of_le_left' h _)] }
rw [add_eq_right h, add_eq_right (pow_le_pow_of_le_left' h _)]
rw [← restrict_stalk_iso_hom_eq_germ, category.assoc, iso.hom_inv_id, category.comp_id]
rw [simplex_category.hom_zero_zero ([0].const 0), X.map_id, category.comp_id]
dsimp
simp only [tsum_fintype, nnnorm_change_origin_series_term]
rw right_inv
exact false.elim (zero_lt_two.not_le hn)
cases n
{ exact false.elim (zero_lt_two.not_le hn) }
exact false.elim (one_lt_two.not_le hn)
cases n
{ exact false.elim (one_lt_two.not_le hn) }
simp only [right_inv, neg_inj]
congr' 1
ext v
dec_trivial
have N : 0 < n + 2
have : (p 1) (λ (i : fin 1), 0) = 0 := continuous_multilinear_map.map_zero _
simp [comp_right_inv_aux1 N, lt_irrefl n, this, comp_right_inv_aux2]
rw [is_equivalent, is_o_const_iff h]
intro h
intro h
split
split; intro h; [ { have := h.sub tendsto_const_nhds, rw zero_sub (-c) at this }, { have := h.sub tendsto_const_nhds, rw ← sub_self c} ]; convert this; try { ext }; simp
split; intro h; [ { have := h.sub tendsto_const_nhds, rw zero_sub (-c) at this }, { have := h.sub tendsto_const_nhds, rw ← sub_self c} ]; convert this; try { ext }
split; intro h; [ { have := h.sub tendsto_const_nhds, rw zero_sub (-c) at this }, { have := h.sub tendsto_const_nhds, rw ← sub_self c} ]; convert this
split; intro h; [ { have := h.sub tendsto_const_nhds, rw zero_sub (-c) at this }, { have := h.sub tendsto_const_nhds, rw ← sub_self c} ]
split; intro h
rw zero_sub (-c) at this
have := h.sub tendsto_const_nhds
rw ← sub_self c
have := h.sub tendsto_const_nhds
try { ext }
try { ext }
ext
simp
simp
convert this
convert this
rcases (em $ c = 0) with ⟨rfl, h⟩
exact (tendsto_congr' $ is_equivalent_zero_iff_eventually_zero.mp hu).mpr tendsto_const_nhds
{ exact (tendsto_congr' $ is_equivalent_zero_iff_eventually_zero.mp hu).mpr tendsto_const_nhds }
exact (is_equivalent_const_iff_tendsto h).mp hu
from mt norm_eq_zero.mp hc
have cne0 : ∥c∥ ≠ 0
simp only [norm_smul]
rw [←is_O_norm_left]
rw [is_O_const_mul_left_iff cne0, is_O_norm_left]
simp only [is_o, is_O_with_pi, le_of_lt] { contextual := tt }
exact ⟨λ h i c hc, h hc i, λ h c hc i, h i hc⟩
unfold is_O_with
subst c₂
apply filter.eventually_congr
filter_upwards [hf, hg]
assume x e₁ e₂
rw [e₁, e₂]
exact forall_congr (λ _, (forall_congr (λ _, is_O_with_neg_left)))
unfold is_o
rw tendsto_congr' pow_div_pow_eventually_eq_at_top
apply tendsto_fpow_at_top_at_top
linarith
split
rintros ⟨c, hf, hf'⟩
rw hf.fderiv
{ rintros ⟨c, hf, hf'⟩, rw hf.fderiv, exact hf' }
exact hf'
intros H
by_cases h : differentiable_at ℝ f x
{ exact ⟨fderiv ℝ f x, h.has_fderiv_at, H⟩, }
exact ⟨fderiv ℝ f x, h.has_fderiv_at, H⟩
cases subsingleton_or_nontrivial X with w w; resetI
resetI
resetI
cases subsingleton_or_nontrivial X with w w
exact ⟨(0 : X →L[ℝ] Y), has_fderiv_at_of_subsingleton f x, is_conformal_map_of_subsingleton 0⟩
{ exact ⟨(0 : X →L[ℝ] Y), has_fderiv_at_of_subsingleton f x, is_conformal_map_of_subsingleton 0⟩, }
exfalso
exact H.ne_zero (fderiv_zero_of_not_differentiable_at h)
have := hf.iterate hx n
rwa [continuous_linear_map.smul_right_one_pow] at this
convert hc.mul ((has_strict_deriv_at_inv hx).comp x hd)
{ simp only [div_eq_mul_inv] }
simp only [div_eq_mul_inv]
ring
field_simp
rw [← Iic_diff_right, has_deriv_within_at_diff_singleton]
rwa hL.has_deriv_at_filter_iff hx rfl
have := hc.smul (has_deriv_within_at_const x s f)
rwa [smul_zero, zero_add] at this
rw [fderiv_within_zero_of_not_differentiable_within_at h, fderiv_within_zero_of_not_differentiable_within_at, neg_zero]
simpa
rw [← fderiv_within_univ, ← fderiv_within_univ]
exact iso.comp_fderiv_within unique_diff_within_at_univ
rw [has_fderiv_at, has_fderiv_at_filter, is_o_iff]
exact (λ c hc, tendsto_id.prod_mk_nhds tendsto_const_nhds (is_o_iff.1 hf hc))
unfold has_fderiv_at_filter at hg
have : is_o (λ x', g (f x') - g (f x) - g' (f x' - f x)) (λ x', f x' - f x) L
from hg.comp_tendsto (le_refl _)
have eq₁ : is_o (λ x', g (f x') - g (f x) - g' (f x' - f x)) (λ x', x' - x) L
from this.trans_is_O hf.is_O_sub
have eq₂ : is_o (λ x', f x' - f x - f' (x' - x)) (λ x', x' - x) L
from hf
have : is_O (λ x', g' (f x' - f x - f' (x' - x))) (λ x', f x' - f x - f' (x' - x)) L
from g'.is_O_comp _ _
have : is_o (λ x', g' (f x' - f x - f' (x' - x))) (λ x', x' - x) L
from this.trans_is_o eq₂
have eq₃ : is_o (λ x', g' (f x' - f x) - (g' (f' (x' - x)))) (λ x', x' - x) L
refine this.congr_left _
simp
exact eq₁.triangle eq₃
rcases metric.mem_nhds_iff.1 hf with ⟨ε, εpos, hε⟩
have A : (interior (metric.ball x ε)).nonempty
rwa [metric.is_open_ball.interior_eq, metric.nonempty_ball]
exact convex.second_derivative_within_at_symmetric (convex_ball x ε) A (λ y hy, hε (interior_subset hy)) (metric.mem_ball_self εpos) hx.has_fderiv_within_at v w
simp [hf.implicit_to_local_homeomorph_of_complemented_apply]
convert (implicit_function_data_of_complemented f f' hf hf' hker).implicit_function_has_strict_fderiv_at (subtype_val f'.ker) _ _
convert (implicit_function_data_of_complemented f f' hf hf' hker).implicit_function_has_strict_fderiv_at (subtype_val f'.ker) _ _; [skip, ext, ext]; simp [classical.some_spec hker]
convert (implicit_function_data_of_complemented f f' hf hf' hker).implicit_function_has_strict_fderiv_at (subtype_val f'.ker) _ _; [skip, ext, ext]
ext
ext
simp [classical.some_spec hker]
simp [classical.some_spec hker]
simp [classical.some_spec hker]
skip
refine ⟨Λ, Λ₀, _, _⟩
simpa only [ne.def, prod.ext_iff, linear_equiv.map_eq_zero_iff, prod.fst_zero] using h0
{ simpa only [ne.def, prod.ext_iff, linear_equiv.map_eq_zero_iff, prod.fst_zero] using h0 }
simpa [mul_comm] using hsum x
ext x
letI := classical.dec_eq ι
replace hextr : is_local_extr_on φ {x | (λ i, f i x) = (λ i, f i x₀)} x₀
simpa only [function.funext_iff] using hextr
rcases hextr.exists_linear_map_of_has_strict_fderiv_at (has_strict_fderiv_at_pi.2 (λ i, hf' i)) hφ' with ⟨Λ, Λ₀, h0, hsum⟩
rcases (linear_equiv.pi_ring ℝ ℝ ι ℝ).symm.surjective Λ with ⟨Λ, rfl⟩
refine lhopital_zero_right_on_Ioo hab hff' hgg' hg' _ _ hdiv
rw [← hfa, ← nhds_within_Ioo_eq_nhds_within_Ioi hab]
exact ((hcf a $ left_mem_Ico.mpr hab).mono Ioo_subset_Ico_self).tendsto
{ rw [← hfa, ← nhds_within_Ioo_eq_nhds_within_Ioi hab], exact ((hcf a $ left_mem_Ico.mpr hab).mono Ioo_subset_Ico_self).tendsto }
rw [← hga, ← nhds_within_Ioo_eq_nhds_within_Ioi hab]
exact ((hcg a $ left_mem_Ico.mpr hab).mono Ioo_subset_Ico_self).tendsto
have hIccIoo := @Ioo_subset_Icc_self ℝ _ 0 1
set g : ℝ → E := λ t, x + t • (y - x)
have hseg : ∀ t ∈ Icc (0:ℝ) 1, g t ∈ segment ℝ x y
rw segment_eq_image'
simp only [mem_image, and_imp, add_right_inj]
exact ⟨t, ht, rfl⟩
{ rw segment_eq_image', simp only [mem_image, and_imp, add_right_inj], intros t ht, exact ⟨t, ht, rfl⟩ }
intros t ht
have hseg' : Icc 0 1 ⊆ g ⁻¹' s
unfold image
change ∀ _, _
rw ← image_subset_iff
rw mem_set_of_eq at Hz
rcases Hz with ⟨t, Ht, hgt⟩
intros z Hz
exact hs.segment_subset xs ys (hseg t Ht)
{ rw ← image_subset_iff, unfold image, change ∀ _, _, intros z Hz, rw mem_set_of_eq at Hz, rcases Hz with ⟨t, Ht, hgt⟩, rw ← hgt, exact hs.segment_subset xs ys (hseg t Ht) }
rw ← hgt
have hfg: ∀ t ∈ Icc (0:ℝ) 1, has_deriv_within_at (f ∘ g) ((f' (g t) : E → ℝ) (y-x)) (Icc (0:ℝ) 1) t
intros t Ht
have hg : has_deriv_at g (y-x) t
have := ((has_deriv_at_id t).smul_const (y - x)).const_add x
{ have := ((has_deriv_at_id t).smul_const (y - x)).const_add x, rwa one_smul at this }
rwa one_smul at this
exact (hf (g t) $ hseg' Ht).comp_has_deriv_within_at _ hg.has_deriv_within_at hseg'
{ intros t Ht, have hg : has_deriv_at g (y-x) t, { have := ((has_deriv_at_id t).smul_const (y - x)).const_add x, rwa one_smul at this }, exact (hf (g t) $ hseg' Ht).comp_has_deriv_within_at _ hg.has_deriv_within_at hseg' }
have hMVT : ∃ (t ∈ Ioo (0:ℝ) 1), ((f' (g t) : E → ℝ) (y-x)) = (f (g 1) - f (g 0)) / (1 - 0)
norm_num
refine exists_has_deriv_at_eq_slope (f ∘ g) _ (by norm_num) _ _
unfold continuous_on
{ unfold continuous_on, exact λ t Ht, (hfg t Ht).continuous_within_at }
exact λ t Ht, (hfg t Ht).continuous_within_at
refine λ t Ht, (hfg t $ hIccIoo Ht).has_deriv_at _
refine _root_.mem_nhds_iff.mpr _
use (Ioo (0:ℝ) 1)
refine ⟨hIccIoo, _, Ht⟩
{ refine exists_has_deriv_at_eq_slope (f ∘ g) _ (by norm_num) _ _, { unfold continuous_on, exact λ t Ht, (hfg t Ht).continuous_within_at }, { refine λ t Ht, (hfg t $ hIccIoo Ht).has_deriv_at _, refine _root_.mem_nhds_iff.mpr _, use (Ioo (0:ℝ) 1), refine ⟨hIccIoo, _, Ht⟩, simp [real.Ioo_eq_ball, is_open_ball] } }
simp [real.Ioo_eq_ball, is_open_ball]
rcases hMVT with ⟨t, Ht, hMVT'⟩
refine ⟨hseg t $ hIccIoo Ht, _⟩
use g t
simp [g, hMVT']
simp
let h := λ x, (g b - g a) * f x - (f b - f a) * g x
have hI : h a = h b
ring
{ simp only [h], ring }
simp only [h]
let h' := λ x, (g b - g a) * f' x - (f b - f a) * g' x
have hhh' : ∀ x ∈ Ioo a b, has_deriv_at h (h' x) x
from λ x hx, ((hff' x hx).const_mul (g b - g a)).sub ((hgg' x hx).const_mul (f b - f a))
have hhc : continuous_on h (Icc a b)
from (continuous_on_const.mul hfc).sub (continuous_on_const.mul hgc)
rcases exists_has_deriv_at_eq_zero h h' hab hhc hI hhh' with ⟨c, cmem, hc⟩
exact ⟨c, cmem, sub_eq_zero.1 hc⟩
simpa only [zero_mul, sub_nonpos] using hD.image_sub_le_mul_sub_of_deriv_le hf hf' hf'_nonpos
have hm := (continuous_linear_map.smul_rightL ℝ ℝ E 1).continuous.measurable.comp_ae_measurable hF'_meas
cases has_fderiv_at_of_dominated_loc_of_lip ε_pos hF_meas hF_int hm h_lipsch bound_integrable h_diff with hF'_int key
replace hF'_int : integrable F' μ
rw [← integrable_norm_iff hm] at hF'_int
simpa only [integrable_norm_iff, hF'_meas, one_mul, norm_one, continuous_linear_map.norm_smul_rightL_apply] using hF'_int
{ rw [← integrable_norm_iff hm] at hF'_int, simpa only [integrable_norm_iff, hF'_meas, one_mul, norm_one, continuous_linear_map.norm_smul_rightL_apply] using hF'_int}
refine ⟨hF'_int, _⟩
simp_rw has_deriv_at_iff_has_fderiv_at at h_diff ⊢
rwa continuous_linear_map.integral_comp_comm _ hF'_int at key
apply_instance
apply_instance
apply_instance
apply_instance
all_goals { apply_instance, }
simp only [interior_Ici, nonempty_Ioi]
simp only [interior_Ico, nonempty_Ioo, hab]
simp only [Ico_eq_empty hab, unique_diff_on_empty]
simp [times_cont_diff_on, e.comp_times_cont_diff_within_at_iff]
exact λ x, hf.times_cont_diff_at.inv (h x)
rw times_cont_diff_iff_times_cont_diff_at
simp [norm]
simp [norm]; norm_num
norm_num
have A : times_cont_diff_at ℝ n (coe : ℝ → ℂ) z
from of_real_clm.times_cont_diff.times_cont_diff_at
have B : times_cont_diff_at ℝ n e z := h.restrict_scalars ℝ
have C : times_cont_diff_at ℝ n re (e z)
from re_clm.times_cont_diff.times_cont_diff_at
exact C.comp z (B.comp z A)
intros x y xs ys a b ha hb hab
rw [mem_preimage, convex.combo_affine_apply hab]
exact hs xs ys ha hb hab
rw [s.center_mass_eq_of_sum_1 _ hws, t.center_mass_eq_of_sum_1 _ hwt, smul_sum, smul_sum, ← finset.sum_sum_elim, finset.center_mass_eq_of_sum_1]
congr' with ⟨⟩; simp only [sum.elim_inl, sum.elim_inr, mul_smul]
simp only [sum.elim_inl, sum.elim_inr, mul_smul]
simp only [sum.elim_inl, sum.elim_inr, mul_smul]
congr' with ⟨⟩
{ congr' with ⟨⟩; simp only [sum.elim_inl, sum.elim_inr, mul_smul] }
rw [sum_sum_elim, ← mul_sum, ← mul_sum, hws, hwt, mul_one, mul_one, hab]
use subset.trans (inter_subset_left _ _) hAB.1
rintro x₁ x₂ hx₁A hx₂A x ⟨hxB, hxC⟩ hx
obtain ⟨hx₁B, hx₂B⟩ := hAB.2 x₁ x₂ hx₁A hx₂A x hxB hx
obtain ⟨hx₁C, hx₂C⟩ := hAC.2 x₁ x₂ hx₁A hx₂A x hxC hx
exact ⟨⟨hx₁B, hx₁C⟩, hx₂B, hx₂C⟩
rintro ⟨x, r⟩ ⟨y, t⟩ ⟨hx, hr⟩ ⟨hy, ht⟩ a b ha hb hab
refine ⟨hf.1 hx hy ha hb hab, _⟩
calc f (a • x + b • y) ≤ a • f x + b • f y : hf.2 hx hy ha hb hab ... ≤ a • r + b • t : add_le_add (smul_le_smul_of_nonneg hr ha) (smul_le_smul_of_nonneg ht hb)
abel
simp only [smul_add, add_assoc]
have : (convex_hull 𝕜 (p '' s)).nonempty := ⟨p x, hx⟩
rw [convex_hull_nonempty_iff, set.nonempty_image_iff] at this
rwa subsingleton.mem_iff_nonempty
have h₁ : Iio 0 ⊆ ({0} : set ℝ)ᶜ
intros x hx hx'
rw [mem_singleton_iff] at hx'
rw [hx'] at hx
{ intros x hx hx', rw [mem_singleton_iff] at hx', rw [hx'] at hx, exact lt_irrefl 0 hx }
exact lt_irrefl 0 hx
refine concave_on_open_of_deriv2_nonpos (convex_Iio 0) is_open_Iio _ _ _
{ exact differentiable_on_log.mono h₁ }
exact differentiable_on_log.mono h₁
refine ((times_cont_diff_on_log.deriv_of_open _ le_top).differentiable_on le_top).mono h₁
{ refine ((times_cont_diff_on_log.deriv_of_open _ le_top).differentiable_on le_top).mono h₁, exact is_open_compl_singleton }
exact is_open_compl_singleton
intros x hx
rw [function.iterate_succ, function.iterate_one]
change (deriv (deriv log)) x ≤ 0
rw [deriv_log', deriv_inv]
exact neg_nonpos.mpr (inv_nonneg.mpr (sq_nonneg x))
use ⨆ s : finset ι, ∑ i in s, ∥⟪v i, x⟫∥ ^ 2
apply has_sum_of_is_lub_of_nonneg
intro b
{ intro b, simp only [norm_nonneg, pow_nonneg], }
simp only [norm_nonneg, pow_nonneg]
refine is_lub_csupr _
use ∥x∥ ^ 2
rintro y ⟨s, rfl⟩
exact hv.sum_inner_products_le x
rw [← @of_real_inj 𝕜, im_eq_conj_sub]; simp [inner_conj_sym]
simp [inner_conj_sym]
rw [← @of_real_inj 𝕜, im_eq_conj_sub]
rintro rfl
exact inner_zero_left
simp [inner_smul_left, finsupp.sum]
convert sum_inner l.support (λ a, l a • v a) x
simp [inner_sum, inner_smul_right, orthonormal_iff_ite.mp hv]
ext
simp [inner_add_left]
ext
simp [inner_smul_left]
simp only [norm_to_dual'_apply, one_mul, linear_map.coe_mk]
rw [is_R_or_C.norm_eq_abs]
exact abs_inner_le_norm _ _
ext z
simp
ext z
simp [inner_add_left]
convert complex.basis_one_I.equiv_fun_symm_apply x
{ simpa }
simpa
simp
have hm : orthogonal_projection_fn K x + orthogonal_projection_fn K y ∈ K := submodule.add_mem K (orthogonal_projection_fn_mem x) (orthogonal_projection_fn_mem y)
have ho : ∀ w ∈ K, ⟪x + y - (orthogonal_projection_fn K x + orthogonal_projection_fn K y), w⟫ = 0
intros w hw
rw [add_sub_comm, inner_add_left, orthogonal_projection_fn_inner_eq_zero _ w hw, orthogonal_projection_fn_inner_eq_zero _ w hw, add_zero]
{ intros w hw, rw [add_sub_comm, inner_add_left, orthogonal_projection_fn_inner_eq_zero _ w hw, orthogonal_projection_fn_inner_eq_zero _ w hw, add_zero] }
ext
simp [eq_orthogonal_projection_fn_of_mem_of_inner_eq_zero hm ho]
have hm : c • orthogonal_projection_fn K x ∈ K := submodule.smul_mem K _ (orthogonal_projection_fn_mem x)
have ho : ∀ w ∈ K, ⟪c • x - c • orthogonal_projection_fn K x, w⟫ = 0
intros w hw
{ intros w hw, rw [←smul_sub, inner_smul_left, orthogonal_projection_fn_inner_eq_zero _ w hw, mul_zero] }
rw [←smul_sub, inner_smul_left, orthogonal_projection_fn_inner_eq_zero _ w hw, mul_zero]
ext
simp [eq_orthogonal_projection_fn_of_mem_of_inner_eq_zero hm ho]
simp only [one_mul, linear_map.coe_mk]
norm_num
refine le_of_pow_le_pow 2 (norm_nonneg _) (by norm_num) _
change ∥orthogonal_projection_fn K x∥ ^ 2 ≤ ∥x∥ ^ 2
nlinarith [orthogonal_projection_fn_norm_sq K x]
exact_mod_cast real.pow_arith_mean_le_arith_mean_pow s _ _ (λ i _, (w i).coe_nonneg) (by exact_mod_cast hw') (λ i _, (z i).coe_nonneg) n
exact_mod_cast hw'
have h := rpow_arith_mean_le_arith_mean_rpow (univ : finset (fin 2)) (fin.cons w₁ $ fin.cons w₂ fin_zero_elim) (fin.cons z₁ $ fin.cons z₂ $ fin_zero_elim) _ hp
simpa [fin.sum_univ_succ, fin.sum_univ_zero, fin.cons_succ, fin.cons_zero] using h
{ simpa [fin.sum_univ_succ, fin.sum_univ_zero, fin.cons_succ, fin.cons_zero] using h, }
simp [hw', fin.sum_univ_succ, fin.sum_univ_zero, fin.cons_succ, fin.cons_zero]
split
use λ i, ((f i) ^ p / f i / (∑ i in s, (f i) ^ p) ^ (1 / q))
by_cases hf : ∑ i in s, (f i)^p = 0
{ simp [hf, hpq.ne_zero, hpq.symm.ne_zero] }
simp [hf, hpq.ne_zero, hpq.symm.ne_zero]
simp [hpq.ne_zero]
have A : p + q - q ≠ 0
have B : ∀ y : ℝ≥0, y * y^p / y = y^p
refine λ y, mul_div_cancel_left_of_imp (λ h, _)
{ refine λ y, mul_div_cancel_left_of_imp (λ h, _), simpa [h, hpq.ne_zero] }
simpa [h, hpq.ne_zero]
simp only [set.mem_set_of_eq, div_rpow, ← sum_div, ← rpow_mul, div_mul_cancel _ hpq.symm.ne_zero, rpow_one, div_le_iff hf, one_mul, hpq.mul_eq_add, ← rpow_sub' _ A, _root_.add_sub_cancel, le_refl, true_and, ← mul_div_assoc, B]
rw [div_eq_iff, ← rpow_add hf, hpq.inv_add_inv_conj, rpow_one]
{ use λ i, ((f i) ^ p / f i / (∑ i in s, (f i) ^ p) ^ (1 / q)), by_cases hf : ∑ i in s, (f i)^p = 0, { simp [hf, hpq.ne_zero, hpq.symm.ne_zero] }, { have A : p + q - q ≠ 0, by simp [hpq.ne_zero], have B : ∀ y : ℝ≥0, y * y^p / y = y^p, { refine λ y, mul_div_cancel_left_of_imp (λ h, _), simpa [h, hpq.ne_zero] }, simp only [set.mem_set_of_eq, div_rpow, ← sum_div, ← rpow_mul, div_mul_cancel _ hpq.symm.ne_zero, rpow_one, div_le_iff hf, one_mul, hpq.mul_eq_add, ← rpow_sub' _ A, _root_.add_sub_cancel, le_refl, true_and, ← mul_div_assoc, B], rw [div_eq_iff, ← rpow_add hf, hpq.inv_add_inv_conj, rpow_one], simpa [hpq.symm.ne_zero] using hf } }
simpa [hpq.symm.ne_zero] using hf
rintros _ ⟨g, hg, rfl⟩
apply le_trans (inner_le_Lp_mul_Lq s f g hpq)
simpa only [mul_one] using mul_le_mul_left' (nnreal.rpow_le_one hg (le_of_lt hpq.symm.one_div_pos)) _
rcases eq_or_lt_of_le hp with rfl|hp
simp [finset.sum_add_distrib]
{ simp [finset.sum_add_distrib] }
have hpq := real.is_conjugate_exponent_conjugate_exponent hp
have := is_greatest_Lp s (f + g) hpq
simp only [pi.add_apply, add_mul, sum_add_distrib] at this
rcases this.1 with ⟨φ, hφ, H⟩
rw ← H
exact add_le_add ((is_greatest_Lp s f hpq).2 ⟨φ, hφ, rfl⟩) ((is_greatest_Lp s g hpq).2 ⟨φ, hφ, rfl⟩)
apply_instance
apply_instance
apply_mod_cast nndist_vadd_vadd_le
simp only [edist_nndist]
refl
ext
rw [← (point_reflection 𝕜 x).dist_map y x, point_reflection_self]
rw [frontier, closure_closed_ball, interior_closed_ball' x r, closed_ball_diff_ball]
refine isometry_emetric_iff_metric.2 (λx y, _)
rw [dist_eq_norm, dist_eq_norm, ← ring_hom.map_sub, norm_algebra_map_eq]
simpa using (norm_algebra_map_eq 𝕜' (1:𝕜))
rwa [real.norm_eq_abs, abs_of_nonneg nn] at this
apply le_antisymm
rw H1
apply H2
{ rw [sub_eq_add_neg, ← add_right_neg y], apply H2 }
rw [sub_eq_add_neg, ← add_right_neg y]
rwa [sub_add_cancel, zero_add] at this
have := H2 (x-y) 0 y
simp [le_refl]
haveI := hq.complete_space_coe
haveI := hp.complete_space_coe
refine (p.prod_equiv_of_is_compl q h).to_continuous_linear_equiv_of_continuous _
exact ((subtype_val p).coprod (subtype_val q)).continuous
simpa using continuous_linear_map.le_of_op_norm_le _ (inclusion_in_double_dual_norm_le 𝕜 E) x
letI := e.emetric_space
refine emetric_space.to_metric_space_of_dist _ (λ x y, _) (λ x y, rfl)
change e (x - y) ≠ ⊤
exact ne_top_of_le_ne_top (ennreal.add_lt_top.2 ⟨x.2, y.2⟩).ne (e.map_sub_le x y)
have : (f : (ι → 𝕜) → E) = (λx, ∑ i : ι, x i • (f (λj, if i = j then 1 else 0)))
ext x
exact f.pi_apply_eq_sum_univ x
rw this
refine continuous_finset_sum _ (λi hi, _)
exact (continuous_apply i).smul continuous_const
simp only [fintype.linear_independent_iff'] at hf ⊢
rcases linear_map.exists_antilipschitz_with _ hf with ⟨K, K0, hK⟩
have : tendsto (λ g : ι → E, ∑ i, ∥g i - f i∥) (𝓝 f) (𝓝 $ ∑ i, ∥f i - f i∥)
from tendsto_finset_sum _ (λ i hi, tendsto.norm $ ((continuous_apply i).tendsto _).sub tendsto_const_nhds)
simp only [sub_self, norm_zero, finset.sum_const_zero] at this
refine (this.eventually (gt_mem_nhds $ inv_pos.2 K0)).mono (λ g hg, _)
replace hg : ∑ i, nnnorm (g i - f i) < K⁻¹
rw ← nnreal.coe_lt_coe
push_cast
exact hg
rw linear_map.ker_eq_bot
refine (hK.add_sub_lipschitz_with (lipschitz_with.of_dist_le_mul $ λ v u, _) hg).injective
simp only [dist_eq_norm, linear_map.lsum_apply, pi.sub_apply, linear_map.sum_apply, linear_map.comp_apply, linear_map.proj_apply, linear_map.smul_right_apply, linear_map.id_apply, ← finset.sum_sub_distrib, ← smul_sub, ← sub_smul, nnreal.coe_sum, coe_nnnorm, finset.sum_mul]
refine norm_sum_le_of_le _ (λ i _, _)
rw [norm_smul, mul_comm]
exact mul_le_mul_of_nonneg_left (norm_le_pi_norm (v - u) i) (norm_nonneg _)
set e := continuous_linear_equiv.of_finrank_eq (@finrank_fin_fun 𝕜 _ (finrank 𝕜 E)).symm
have : uniform_embedding e.to_linear_equiv.to_equiv.symm := e.symm.uniform_embedding
exact (complete_space_congr this).1 (by apply_instance)
apply_instance
exact isometric.range_eq_univ _
rw ← coe_to_isometric
split
assume h
ext m
{ assume h, ext m, simpa [h] using f.le_op_norm m }
simpa [h] using f.le_op_norm m
rintro rfl
apply le_antisymm (op_norm_le_bound 0 le_rfl (λm, _)) (op_norm_nonneg _)
simp
ext
ext; refl
refl
refl
ext
ext; refl
refl
refl
dsimp [has_sum] at h ⊢
convert ((continuous_eval_left m).tendsto _).comp h
ext s
simp
rw [one_mul]
refl
simp
intros U
split
intros U_in
rw ← (mk' S).map_zero at U_in
have := preimage_nhds_coinduced U_in
rcases metric.mem_nhds_iff.mp this with ⟨ε, ε_pos, H⟩
use [ε/2, half_pos ε_pos]
intros x x_in
dsimp at x_in
rcases norm_mk_lt x (half_pos ε_pos) with ⟨y, rfl, ry⟩
apply H
rw ball_zero_eq
dsimp
{ intros U_in, rw ← (mk' S).map_zero at U_in, have := preimage_nhds_coinduced U_in, rcases metric.mem_nhds_iff.mp this with ⟨ε, ε_pos, H⟩, use [ε/2, half_pos ε_pos], intros x x_in, dsimp at x_in, rcases norm_mk_lt x (half_pos ε_pos) with ⟨y, rfl, ry⟩, apply H, rw ball_zero_eq, dsimp, linarith }
linarith
rintros ⟨ε, ε_pos, h⟩
have : (mk' S) '' (ball (0 : M) ε) ⊆ {x | ∥x∥ < ε}
rintros - ⟨x, x_in, rfl⟩
rw mem_ball_zero_iff at x_in
{ rintros - ⟨x, x_in, rfl⟩, rw mem_ball_zero_iff at x_in, exact lt_of_le_of_lt (quotient_norm_mk_le S x) x_in }
exact lt_of_le_of_lt (quotient_norm_mk_le S x) x_in
apply filter.mem_of_superset _ (set.subset.trans this h)
clear h U this
apply is_open.mem_nhds
change is_open ((mk' S) ⁻¹' _)
erw quotient_add_group.preimage_image_coe
apply is_open_Union
rintros ⟨s, s_in⟩
{ change is_open ((mk' S) ⁻¹' _), erw quotient_add_group.preimage_image_coe, apply is_open_Union, rintros ⟨s, s_in⟩, exact (continuous_add_right s).is_open_preimage _ is_open_ball }
exact (continuous_add_right s).is_open_preimage _ is_open_ball
exact ⟨(0 : M), mem_ball_self ε_pos, (mk' S).map_zero⟩
simpa only [prod_apply, prod.semi_norm_def, max_mul_of_nonneg, norm_nonneg] using max_le_max (le_op_norm f x) (le_op_norm g x)
simp [edist, ennreal.zero_rpow_of_pos pos, ennreal.zero_rpow_of_pos (inv_pos.2 pos)]
simp [edist, edist_comm]
apply ennreal.rpow_le_rpow _ (one_div_nonneg.2 $ le_of_lt pos)
refine finset.sum_le_sum (λ i hi, _)
exact ennreal.rpow_le_rpow (edist_triangle _ _ _) (le_trans zero_le_one hp)
have pos : 0 < p := lt_of_lt_of_le zero_lt_one hp
have nonneg : 0 ≤ 1 / p := one_div_nonneg.2 (le_of_lt pos)
have cancel : p * (1/p) = 1 := mul_div_cancel' 1 (ne_of_gt pos)
assume x y
simp [edist, -one_div]
calc (∑ (i : ι), edist (x i) (y i) ^ p) ^ (1 / p) ≤ (∑ (i : ι), edist (pi_Lp.equiv p hp β x) (pi_Lp.equiv p hp β y) ^ p) ^ (1 / p) : begin apply ennreal.rpow_le_rpow _ nonneg, apply finset.sum_le_sum (λ i hi, _), apply ennreal.rpow_le_rpow _ (le_of_lt pos), exact finset.le_sup (finset.mem_univ i) end ... = (((fintype.card ι : ℝ≥0)) ^ (1/p) : ℝ≥0) * edist (pi_Lp.equiv p hp β x) (pi_Lp.equiv p hp β y) : begin simp only [nsmul_eq_mul, finset.card_univ, ennreal.rpow_one, finset.sum_const, ennreal.mul_rpow_of_nonneg _ _ nonneg, ←ennreal.rpow_mul, cancel], have : (fintype.card ι : ℝ≥0∞) = (fintype.card ι : ℝ≥0) := (ennreal.coe_nat (fintype.card ι)).symm, rw [this, ennreal.coe_rpow_of_nonneg _ nonneg] end
apply ennreal.rpow_le_rpow _ nonneg
apply finset.sum_le_sum (λ i hi, _)
apply ennreal.rpow_le_rpow _ (le_of_lt pos)
exact finset.le_sup (finset.mem_univ i)
simp only [nsmul_eq_mul, finset.card_univ, ennreal.rpow_one, finset.sum_const, ennreal.mul_rpow_of_nonneg _ _ nonneg, ←ennreal.rpow_mul, cancel]
have : (fintype.card ι : ℝ≥0∞) = (fintype.card ι : ℝ≥0) := (ennreal.coe_nat (fintype.card ι)).symm
rw [this, ennreal.coe_rpow_of_nonneg _ nonneg]
have Rpos : 0 < R := (norm_nonneg _).trans_lt hR
rw div_lt_iff Rpos
have : ∥c∥ / R < 1
simpa using hR
rcases riesz_lemma hFc hF this with ⟨x, xF, hx⟩
simpa [H] using xF
have x0 : x ≠ 0 := λ H, by simpa [H] using xF
obtain ⟨d, d0, dxlt, ledx, -⟩ : ∃ (d : 𝕜), d ≠ 0 ∧ ∥d • x∥ < R ∧ R / ∥c∥ ≤ ∥d • x∥ ∧ ∥d∥⁻¹ ≤ R⁻¹ * ∥c∥ * ∥x∥ := rescale_to_shell hc Rpos x0
refine ⟨d • x, dxlt.le, λ y hy, _⟩
set y' := d⁻¹ • y with hy'
simp [hy', submodule.smul_mem _ _ hy]
have y'F : y' ∈ F
simp [hy', smul_smul, mul_inv_cancel d0]
have yy' : y = d • y'
field_simp [Rpos.ne', (zero_lt_one.trans hc).ne']
calc 1 = (∥c∥/R) * (R/∥c∥) : by field_simp [Rpos.ne', (zero_lt_one.trans hc).ne'] ... ≤ (∥c∥/R) * (∥d • x∥) : mul_le_mul_of_nonneg_left ledx (div_nonneg (norm_nonneg _) Rpos.le) ... = ∥d∥ * (∥c∥/R * ∥x∥) : by { simp [norm_smul], ring } ... ≤ ∥d∥ * ∥x - y'∥ : mul_le_mul_of_nonneg_left (hx y' (by simp [hy', submodule.smul_mem _ _ hy])) (norm_nonneg _) ... = ∥d • x - y∥ : by simp [yy', ← smul_sub, norm_smul]
simp [norm_smul]
ring
simp [hy', submodule.smul_mem _ _ hy]
simp [yy', ← smul_sub, norm_smul]
have h_is_o : is_o (λ (t : R), ∥inverse (↑x + t) - ↑x⁻¹∥) (λ (t : R), (1:ℝ)) (𝓝 0)
refine is_o_norm_left.mpr ((inverse_add_norm_diff_first_order x).trans_is_o _)
{ refine is_o_norm_left.mpr ((inverse_add_norm_diff_first_order x).trans_is_o _), exact is_o_norm_left.mpr (is_o_id_const one_ne_zero) }
exact is_o_norm_left.mpr (is_o_id_const one_ne_zero)
have h_lim : tendsto (λ (y:R), y - x) (𝓝 x) (𝓝 0)
refine tendsto_zero_iff_norm_tendsto_zero.mpr _
{ refine tendsto_zero_iff_norm_tendsto_zero.mpr _, exact tendsto_iff_norm_tendsto_zero.mp tendsto_id }
exact tendsto_iff_norm_tendsto_zero.mp tendsto_id
simp only [continuous_at]
rw [tendsto_iff_norm_tendsto_zero, inverse_unit]
convert h_is_o.tendsto_0.comp h_lim
ext
simp
convert add_le_add_left (nsmul_le_nsmul_of_le_right (sum_condensed_le' hf n) 2) (f 1)
simp [sum_range_succ', add_comm, pow_succ, mul_nsmul, sum_nsmul]
simp [arg, hx]
rw [← exp_lt_exp, exp_log hx, exp_log hy]
exact log_lt_log_iff zero_lt_one hx
rw ← log_one
rw integral_deriv_eq_sub'; norm_num [continuous_on_exp]
norm_num [continuous_on_exp]
norm_num [continuous_on_exp]
norm_num [continuous_on_exp]
rw integral_deriv_eq_sub'
refine integral_mono_on pi_pos.le _ _ H; exact (continuous_sin.pow _).interval_integrable 0 π
exact (continuous_sin.pow _).interval_integrable 0 π
exact (continuous_sin.pow _).interval_integrable 0 π
refine integral_mono_on pi_pos.le _ _ H
convert integral_sin_pow_even_mul_cos_pow_even 1 1 using 1
have h1 : ∀ c : ℝ, (1 - c) / 2 * ((1 + c) / 2) = (1 - c ^ 2) / 4 := λ c, by ring
ring
have h2 : continuous (λ x, cos (2 * x) ^ 2) := by continuity
continuity
have h3 : ∀ x, cos x * sin x = sin (2 * x) / 2
intro
rw sin_two_mul
ring
{ intro, rw sin_two_mul, ring }
have h4 : ∀ d : ℝ, 2 * (2 * d) = 4 * d := λ d, by ring
ring
simp [h1, h2.interval_integrable, integral_comp_mul_left (λ x, cos x ^ 2), h3, h4]
ring
simpa only [coe_rpow, coe_pow] using real.rpow_nat_cast x n
simp [rpow_neg]
rw [div_eq_mul_inv, mul_rpow_of_nonneg _ _ hz, inv_rpow, div_eq_mul_inv]
rcases lt_trichotomy z 0 with H|H|H
simp [H, ne_of_lt]
{ simp [H, ne_of_lt] }
cases x
by_cases hx : x = 0
{ simp [hx, H, ne_of_lt] }
simp [hx, H, ne_of_lt]
{ cases x, { simp [H, ne_of_lt] }, by_cases hx : x = 0, { simp [hx, H, ne_of_lt] }, { simp [coe_rpow_of_ne_zero hx] } }
simp [coe_rpow_of_ne_zero hx]
{ simp [H] }
simp [H]
simp [H, ne_of_gt]
{ simp [H, ne_of_gt] }
cases x
simp [coe_rpow_of_nonneg _ (le_of_lt H)]
simp only [rpow_def, complex.cpow_def]; split_ifs; simp [*, (complex.of_real_log hx).symm, -complex.of_real_mul, -is_R_or_C.of_real_mul, (complex.of_real_mul _ _).symm, complex.exp_of_real_re] at *
simp only [rpow_def, complex.cpow_def]; split_ifs
simp only [rpow_def, complex.cpow_def]
split_ifs
simp [*, (complex.of_real_log hx).symm, -complex.of_real_mul, -is_R_or_C.of_real_mul, (complex.of_real_mul _ _).symm, complex.exp_of_real_re] at *
simp [*, (complex.of_real_log hx).symm, -complex.of_real_mul, -is_R_or_C.of_real_mul, (complex.of_real_mul _ _).symm, complex.exp_of_real_re] at *
simp [*, (complex.of_real_log hx).symm, -complex.of_real_mul, -is_R_or_C.of_real_mul, (complex.of_real_mul _ _).symm, complex.exp_of_real_re] at *
simp [*, (complex.of_real_log hx).symm, -complex.of_real_mul, -is_R_or_C.of_real_mul, (complex.of_real_mul _ _).symm, complex.exp_of_real_re] at *
simp [*, (complex.of_real_log hx).symm, -complex.of_real_mul, -is_R_or_C.of_real_mul, (complex.of_real_mul _ _).symm, complex.exp_of_real_re] at *
simp [*, (complex.of_real_log hx).symm, -complex.of_real_mul, -is_R_or_C.of_real_mul, (complex.of_real_mul _ _).symm, complex.exp_of_real_re] at *
simp [*, (complex.of_real_log hx).symm, -complex.of_real_mul, -is_R_or_C.of_real_mul, (complex.of_real_mul _ _).symm, complex.exp_of_real_re] at *
simp [*, (complex.of_real_log hx).symm, -complex.of_real_mul, -is_R_or_C.of_real_mul, (complex.of_real_mul _ _).symm, complex.exp_of_real_re] at *
simp [*, (complex.of_real_log hx).symm, -complex.of_real_mul, -is_R_or_C.of_real_mul, (complex.of_real_mul _ _).symm, complex.exp_of_real_re] at *
rw [← complex.of_real_inj, complex.of_real_cpow (rpow_nonneg_of_nonneg hx _), complex.of_real_cpow hx, complex.of_real_mul, complex.cpow_mul, complex.of_real_cpow hx]
rw [← complex.of_real_inj, complex.of_real_cpow (rpow_nonneg_of_nonneg hx _), complex.of_real_cpow hx, complex.of_real_mul, complex.cpow_mul, complex.of_real_cpow hx]; simp only [(complex.of_real_mul _ _).symm, (complex.of_real_log hx).symm, complex.of_real_im, neg_lt_zero, pi_pos, le_of_lt pi_pos]
simp only [(complex.of_real_mul _ _).symm, (complex.of_real_log hx).symm, complex.of_real_im, neg_lt_zero, pi_pos, le_of_lt pi_pos]
simp only [(complex.of_real_mul _ _).symm, (complex.of_real_log hx).symm, complex.of_real_im, neg_lt_zero, pi_pos, le_of_lt pi_pos]
rw [rpow_def_of_pos (lt_of_lt_of_le zero_lt_one hx)]
rw [rpow_def_of_pos (lt_of_lt_of_le zero_lt_one hx)]
rw [rpow_def_of_pos (lt_of_lt_of_le zero_lt_one hx)]
repeat {rw [rpow_def_of_pos (lt_of_lt_of_le zero_lt_one hx)]}
exact mul_le_mul_of_nonneg_left hyz (log_nonneg hx)
rw exp_le_exp
simp
simp; refl
rw gpow_neg_succ_of_nat
rw gpow_neg_succ_of_nat; simp only [int.neg_succ_of_nat_coe, int.cast_neg, complex.cpow_neg, inv_eq_one_div, int.cast_coe_nat, cpow_nat_cast]
simp only [int.neg_succ_of_nat_coe, int.cast_neg, complex.cpow_neg, inv_eq_one_div, int.cast_coe_nat, cpow_nat_cast]
exact_mod_cast h
simpa only [cos_zero] using (cos_periodic.nat_mul n).sub_antiperiod_eq cos_antiperiodic
congr
norm_num
simp
transitivity sin (π / 2 ^ 5)
cases cos_eq_iff_eq_or_eq_neg.mp Hcos with hc hc
exact hc
{ exact hc }
cases sin_eq_iff_eq_or_add_eq_pi.mp Hsin with hs hs
exact hs
{ exact hs }
rw [eq_neg_iff_add_eq_zero, hs] at hc
change n • _ = _ at hn
cases quotient.exact' hc with n hn
rw [← neg_one_mul, add_zero, ← sub_eq_zero, gsmul_eq_mul, ← mul_assoc, ← sub_mul, mul_eq_zero, eq_false_intro (ne_of_gt pi_pos), or_false, sub_neg_eq_add, ← int.cast_zero, ← int.cast_one, ← int.cast_bit0, ← int.cast_mul, ← int.cast_add, int.cast_inj] at hn
have : (n * 2 + 1) % (2:ℤ) = 0 % (2:ℤ) := congr_arg (%(2:ℤ)) hn
rw [add_comm, int.add_mul_mod_self] at this
exact absurd this one_ne_zero
simp [cos_add]
rw [real.pi, mul_div_cancel_left _ (@two_ne_zero' ℝ _ _ _)]
rw [real.pi, mul_div_cancel_left _ (@two_ne_zero' ℝ _ _ _)]; exact (classical.some_spec exists_cos_eq_zero).2
exact (classical.some_spec exists_cos_eq_zero).2
rw sin_pi_div_two
simp [arccos, sub_eq_iff_eq_add]
refine cauchy_seq_of_edist_le_of_tsum_ne_top _ hu _
rw [ennreal.tsum_mul_left, ennreal.tsum_geometric]
refine ennreal.mul_ne_top hC (ennreal.inv_ne_top.2 _)
exact (ennreal.sub_pos.2 hr).ne'
convert dist_le_tsum_of_dist_le_of_tendsto _ hu₂ (summable_geometric_two' C) ha n
simp only [add_comm n, pow_add, ← div_div_eq_div_mul]
symmetry
exact ((has_sum_geometric_two' C).div_const _).tsum_eq
exact_mod_cast n.factorial_pos.le
exact_mod_cast n.zero_le
refine (eventually_gt_at_top 0).mono (λ n hn, _)
rcases nat.exists_eq_succ_of_ne_zero hn.ne.symm with ⟨k, rfl⟩
rw [← prod_range_add_one_eq_factorial, pow_eq_prod_const, div_eq_mul_inv, ← inv_eq_one_div, prod_nat_cast, nat.cast_succ, ← prod_inv_distrib', ← prod_mul_distrib, finset.prod_range_succ']
simp only [prod_range_succ', one_mul, nat.cast_add, zero_add, nat.cast_one]
exact_mod_cast hn.le
refine mul_le_of_le_one_left (inv_nonneg.mpr $ by exact_mod_cast hn.le) (prod_le_one _ _)
refine mul_le_of_le_one_left (inv_nonneg.mpr $ by exact_mod_cast hn.le) (prod_le_one _ _); intros x hx; rw finset.mem_range at hx
refine mul_le_of_le_one_left (inv_nonneg.mpr $ by exact_mod_cast hn.le) (prod_le_one _ _); intros x hx
rw finset.mem_range at hx
rw finset.mem_range at hx
intros x hx
intros x hx
refine mul_nonneg _ (inv_nonneg.mpr _); norm_cast; linarith
refine mul_nonneg _ (inv_nonneg.mpr _); norm_cast
norm_cast
norm_cast
linarith
linarith
{ refine mul_nonneg _ (inv_nonneg.mpr _); norm_cast; linarith }
refine mul_nonneg _ (inv_nonneg.mpr _)
exact_mod_cast hn
norm_cast
linarith
refine (div_le_one $ by exact_mod_cast hn).mpr _
apply_instance
apply_instance
convert epi_of_epi_fac (is_limit.cone_point_unique_up_to_iso_hom_comp (limit.is_limit _) hs _)
{ refl }
refl
exact abelian.epi_pullback_of_epi_g _ _
split
introI h
fapply subobject.eq_of_comm
suffices : is_iso (image_to_kernel _ _ h.w)
{ exactI as_iso (image_to_kernel _ _ h.w), }
exactI as_iso (image_to_kernel _ _ h.w)
{ suffices : is_iso (image_to_kernel _ _ h.w), { exactI as_iso (image_to_kernel _ _ h.w), }, exact is_iso_of_mono_of_epi _, }
exact is_iso_of_mono_of_epi _
{ introI h, fapply subobject.eq_of_comm, { suffices : is_iso (image_to_kernel _ _ h.w), { exactI as_iso (image_to_kernel _ _ h.w), }, exact is_iso_of_mono_of_epi _, }, { simp, }, }
simp
apply exact_of_image_eq_kernel
rw [sub_def, ←lift_sub_lift, sub_def, category.assoc, σ_comp, prod.lift_map_assoc]
refl
apply (adj₂.hom_equiv _ _).subtype_equiv _
intro f
rw [← (adj₂.hom_equiv _ _).injective.eq_iff, eq_comm, adj₂.hom_equiv_naturality_left, other_map, assoc, adj₂.hom_equiv_naturality_left, ← adj₂.counit_naturality, adj₂.hom_equiv_naturality_left, adj₂.hom_equiv_unit, adj₂.right_triangle_components, comp_id, functor.comp_map, ← U.map_comp, assoc, ← adj₁.counit_naturality, adj₂.hom_equiv_unit, adj₂.hom_equiv_unit, F.map_comp, assoc]
refl
apply (adj₁.hom_equiv _ _).symm.subtype_equiv
intro g
rw [← (adj₁.hom_equiv _ _).symm.injective.eq_iff, adj₁.hom_equiv_counit, adj₁.hom_equiv_counit, adj₁.hom_equiv_counit, F.map_comp, assoc, U.map_comp, F.map_comp, assoc, adj₁.counit_naturality, adj₁.counit_naturality_assoc]
apply eq_comm
refine adjunction.left_adjoint_of_equiv (λ X Y, construct_left_adjoint_equiv R _ adj₁ adj₂ Y X) _
intros X Y Y' g h
rw [construct_left_adjoint_equiv_apply, construct_left_adjoint_equiv_apply, function.comp_app, function.comp_app, equiv.trans_apply, equiv.trans_apply, equiv.trans_apply, equiv.trans_apply, equiv.symm_apply_eq, subtype.ext_iff, cofork.is_colimit.hom_iso_natural, equiv.apply_symm_apply, equiv.subtype_equiv_apply, equiv.subtype_equiv_apply, equiv.subtype_equiv_apply, equiv.subtype_equiv_apply, subtype.coe_mk, subtype.coe_mk, subtype.coe_mk, subtype.coe_mk, ← adj₁.hom_equiv_naturality_right_symm, cofork.is_colimit.hom_iso_natural, adj₂.hom_equiv_naturality_right, functor.comp_map]
simp
rw equiv.symm_apply_eq
simp [unit_comp_partial_bijective, unit_comp_partial_bijective_aux_symm_apply]
apply_instance
tidy
ext
refl
tidy
change f ≫ 𝟙 _ = 𝟙 _ ≫ f
simp
change f ≫ 𝟙 _ = 𝟙 _ ≫ f
ext
change (𝟙 _) ≫ (𝟙 _) = 𝟙 _
simp
ext
change (𝟙 _) ≫ (𝟙 _) = 𝟙 _
simp
change (𝟙 X) ≫ (𝟙 X) = 𝟙 X
simp
haveI := strict_initial t g
haveI := strict_initial t h
exact eq_of_inv_eq_inv (t.hom_ext _ _)
tidy
tidy
dsimp
rw left_unitor_naturality_assoc
letI := functor_category.prod_preserves_colimits F
apply is_left_adjoint_of_preserves_colimits (prod.functor.obj F)
dsimp
rw [← comp_f, iso.hom_inv_id, id_f]
rw [← comp_f, iso.inv_hom_id, id_f]
dsimp
apply_instance
dsimp [discrete]
simp
simp
simp only [cancel_mono]
apply_instance
apply_instance
apply_instance
apply_instance
cases F
cases F; refl
refl
cases α
cases α; cases β; cc
cases α; cases β
cases β
cc
rw [iso.hom_inv_id, category.comp_id]
rw [category.assoc, ←w]
rw [iso.inv_hom_id, category.id_comp]
rw [cone_of_preserves_X_hom, assoc, assoc, (is_limit_of_preserves R t₂).fac, limit_auxiliary_cone_π_app, ←L.map_comp_assoc, t₁.fac, R.map_cone_π_app, ←R.map_comp, t₂.fac]
exact (s.π.app j).w
simp [←w]
simp [←w]
let hG := types.colimit_cocone_is_colimit (F ⋙ forget C)
let T : E ≅ G := hE.unique_up_to_iso hG
let TX : E.X ≅ G.X := (cocones.forget _).map_iso T
suffices : function.surjective (TX.hom ∘ ff)
intro a
obtain ⟨b, hb⟩ := this (TX.hom a)
refine ⟨b, _⟩
apply_fun TX.inv at hb
change (TX.hom ≫ TX.inv) (ff b) = (TX.hom ≫ TX.inv) _ at hb
{ intro a, obtain ⟨b, hb⟩ := this (TX.hom a), refine ⟨b, _⟩, apply_fun TX.inv at hb, change (TX.hom ≫ TX.inv) (ff b) = (TX.hom ≫ TX.inv) _ at hb, simpa only [TX.hom_inv_id] using hb }
simpa only [TX.hom_inv_id] using hb
have : TX.hom ∘ ff = λ a, G.ι.app a.1 a.2
ext a
change (E.ι.app a.1 ≫ hE.desc G) a.2 = _
{ ext a, change (E.ι.app a.1 ≫ hE.desc G) a.2 = _, rw hE.fac }
rw hE.fac
rw this
rintro ⟨⟨j,a⟩⟩
exact ⟨⟨j,a⟩,rfl⟩
intro ff
let E := (forget C).map_cocone D
let hE : is_colimit E := is_colimit_of_preserves _ hD
let G := types.colimit_cocone (F ⋙ forget C)
tidy
exactI has_colimit_of_coequalizer_and_coproduct F
apply_instance
apply_instance
resetI
resetI; apply_instance
apply_instance
rw [assoc, (t Y).fac _ j]
simpa using ((t X).fac_assoc ⟨s.X.obj X, whisker_right s.π ((evaluation K C).obj X)⟩ j _).symm
tidy
rw [assoc, limit.post_π, ←G.map_comp, limit.lift_π, limit.lift_π]
ext
refl
simp [← category.assoc]
ext1
ext1; simp [← category.assoc]
tidy
tidy
apply nat_iso.is_iso_of_is_iso_app _
intros F
apply nat_iso.is_iso_of_is_iso_app _
intros X
dsimp [adjunction]
simp only [category.id_comp]
exact is_iso.of_iso ((limit.is_limit _).cone_point_unique_up_to_iso (limit_of_diagram_initial structured_arrow.mk_id_initial _))
intro l
ext j
simp only [category.id_comp, limit.pre_π]
congr' 1
simp
intros x y z f g
ext j
erw [limit.pre_pre, limit.pre_π, limit.pre_π]
congr' 1
tidy
exactI { has_colimit := λ F, has_colimit.mk (colimit_cocone F) }
rw [cone_of_cocone_left_op_π_app, colimit.cocone_ι, ←op_comp, colimit.ι_desc, cocone_left_op_of_cone_ι_app, quiver.hom.op_unop]
refl
have u := (colimit.is_colimit F.left_op).uniq (cocone_left_op_of_cone s) (m.unop)
clear u
convert congr_arg (λ f : _ ⟶ _, f.op) (u _)
intro j
rw [cocone_left_op_of_cone_ι_app, colimit.cocone_ι]
clear w
convert congr_arg (λ f : _ ⟶ _, f.unop) (w (unop j))
rw [cone_of_cocone_left_op_π_app, colimit.cocone_ι, quiver.hom.unop_op]
refl
intros
cases a
cases b
congr
split
let equ := e.inv_fun_id_assoc (K ⋙ F)
have := (is_limit_of_preserves F (t.whisker_equivalence e)).whisker_equivalence e.symm
apply ((is_limit.postcompose_hom_equiv equ _).symm this).of_iso_limit
refine cones.ext (iso.refl _) (λ j, _)
simp [←functor.map_comp]
dsimp
exactI preserves_colimits_of_shape_of_nat_iso h
intros
cases a
cases b
cc
split
rw ← preserves_coproduct.inv_hom
apply_instance
ext T f
simpa [cocone_of_representable_ι_app] using functor_to_types.naturality _ _ α f.op _
simp
simp
simp
ext
ext; simp
ext
ext; simp [add_comp]
simp [add_comp]
simp [add_comp]
simp [add_comp]
simp [add_comp]
tidy
exactI has_biproduct.of_has_coproduct _
simp [biproduct.lift_eq, biproduct.desc_eq, comp_sum, sum_comp, biproduct.ι_π_assoc, comp_dite, dite_comp]
rw [←s.w right, parallel_pair_map_right]
convert h one
exact (category.id_comp _).symm
cases j'
cases j
{ exact {hom.id none} }
exact {hom.id none}
{ cases j, { exact {hom.id none} }, { exact {hom.term j} } }
exact {hom.term j}
by_cases some j' = j
rw h
{ rw h, exact {hom.id j} }
exact {hom.id j}
exact ∅
tidy
apply_instance
apply_instance
apply_instance
apply_instance
resetI
apply_instance
apply_instance
simp [w]
to_lhs
congr
skip
rw ←image_mono_iso_source_inv_ι f
conv { to_lhs, congr, skip, rw ←image_mono_iso_source_inv_ι f, }
rw [←category.assoc, iso.hom_inv_id, category.id_comp]
apply_instance
rw [small_k.comm_assoc]
refine ⟨_, _, _, _⟩
apply (pullback_cone.is_limit.lift' small_k.is_limit s.fst s.snd _).1
rw [← cancel_mono f₂, assoc, s.condition, assoc]
apply (pullback_cone.is_limit.lift' small_k.is_limit s.fst s.snd _).2.1
apply (pullback_cone.is_limit.lift' small_k.is_limit s.fst s.snd _).2.2
intros m m₁ m₂
apply small_k.is_limit.hom_ext
refine ((pullback_cone.mk a b _) : pullback_cone f₁ _).equalizer_ext _ _
rwa (pullback_cone.is_limit.lift' small_k.is_limit s.fst s.snd _).2.1
rwa (pullback_cone.is_limit.lift' small_k.is_limit s.fst s.snd _).2.2
cases j
exact fac s
{ exact fac s, }
simp
rw [cofork.condition, zero_comp]
apply_instance
simp
simp [h]
dsimp
rw [← F.map_comp, category.comp_id, tX.hom_ext (k ≫ tX.from j') (tX.from j)]
refine ⟨λ i, _, _, _⟩
apply classical.some (t (s.ι i) _)
{ apply classical.some (t (s.ι i) _), apply congr_fun s.condition i }
apply congr_fun s.condition i
ext i
{ ext i, apply (classical.some_spec (t (s.ι i) _)).1 }
apply (classical.some_spec (t (s.ι i) _)).1
intros m hm
ext i
apply (classical.some_spec (t (s.ι i) _)).2
apply congr_fun hm i
tidy
cases g
cases g; { dsimp, simp }
dsimp
simp
cases f with _ j
{ apply (𝟙 _) }
apply (𝟙 _)
exact arrows j
tidy
apply (limit_equiv_sections F).injective
ext j
simp [w j]
change quot.mk _ _ = quot.mk _ _ ↔ _
rw [quot.eq, filtered_colimit.rel_eq_eqv_gen_quot_rel]
apply monadic_of_has_preserves_reflects_G_split_coequalizers _
{ apply_instance }
apply_instance
{ assumption }
assumption
{ assumption }
assumption
introsI A B f g i
apply reflects_colimit_of_reflects_isomorphisms
simp [←unitors_equal]
ext
rw [←tensor_comp, f.hom_inv_id]
rw [←h.hom_equiv_naturality_left, ←h.hom_equiv_naturality_right, equiv.apply_eq_iff_eq, assoc, is_iso.eq_inv_comp, ←F.to_lax_monoidal_functor.μ_natural_assoc, is_iso.hom_inv_id_assoc, ←tensor_comp, adjunction.counit_naturality, adjunction.counit_naturality, tensor_comp]
rw [←h.hom_equiv_naturality_right, ←h.hom_equiv_naturality_left, ←h.hom_equiv_naturality_left, ←h.hom_equiv_naturality_left, equiv.apply_eq_iff_eq, ← cancel_epi (F.to_lax_monoidal_functor.μ (G.obj X ⊗ G.obj Y) (G.obj Z)), ← cancel_epi (F.to_lax_monoidal_functor.μ (G.obj X) (G.obj Y) ⊗ 𝟙 (F.obj (G.obj Z))), F.to_lax_monoidal_functor.associativity_assoc (G.obj X) (G.obj Y) (G.obj Z), ←F.to_lax_monoidal_functor.μ_natural_assoc, assoc, is_iso.hom_inv_id_assoc, ←F.to_lax_monoidal_functor.μ_natural_assoc, is_iso.hom_inv_id_assoc, ←tensor_comp, ←tensor_comp, id_comp, functor.map_id, functor.map_id, id_comp, ←tensor_comp_assoc, ←tensor_comp_assoc, id_comp, id_comp, h.hom_equiv_unit, h.hom_equiv_unit, functor.map_comp, assoc, assoc, h.counit_naturality, h.left_triangle_components_assoc, is_iso.hom_inv_id_assoc, functor.map_comp, assoc, h.counit_naturality, h.left_triangle_components_assoc, is_iso.hom_inv_id_assoc]
exact associator_naturality (h.counit.app X) (h.counit.app Y) (h.counit.app Z)
rw [←h.hom_equiv_naturality_right, ←h.hom_equiv_naturality_left, ←equiv.symm_apply_eq, h.hom_equiv_counit, F.map_left_unitor, h.hom_equiv_unit, assoc, assoc, assoc, F.map_tensor, assoc, assoc, is_iso.hom_inv_id_assoc, ←tensor_comp_assoc, functor.map_id, id_comp, functor.map_comp, assoc, h.counit_naturality, h.left_triangle_components_assoc, ←left_unitor_naturality, ←tensor_comp_assoc, id_comp, comp_id]
rw [←h.hom_equiv_naturality_right, ←h.hom_equiv_naturality_left, ←equiv.symm_apply_eq, h.hom_equiv_counit, F.map_right_unitor, assoc, assoc, ←right_unitor_naturality, ←tensor_comp_assoc, comp_id, id_comp, h.hom_equiv_unit, F.map_tensor, assoc, assoc, assoc, is_iso.hom_inv_id_assoc, functor.map_comp, functor.map_id, ←tensor_comp_assoc, assoc, h.counit_naturality, h.left_triangle_components_assoc, id_comp]
rw [←comp_right_adjoint_mate, category.comp_id, right_adjoint_mate_id]
rw [←comp_right_adjoint_mate, category.comp_id, right_adjoint_mate_id]
dsimp
simp only [equivalence.inv_fun_map, functor.map_comp, tensor_comp, category.assoc]
simp only [←e.functor.map_comp]
congr' 1
rw [←tensor_comp, iso.hom_inv_id_app, iso.hom_inv_id_app, ←tensor_comp]
dsimp
rw [comp_id, comp_id]
dsimp
simp only [comp_tensor_id, assoc, equivalence.inv_fun_map, functor.map_comp, id_tensor_comp, e.inverse.map_id]
simp only [←e.functor.map_comp]
congr' 2
rw [←tensor_id_comp_id_tensor]
slice_lhs 3 3 { rw [←tensor_id_comp_id_tensor], }
rw [←comp_tensor_id, iso.hom_inv_id_app]
slice_lhs 2 3 { rw [←comp_tensor_id, iso.hom_inv_id_app], dsimp, rw [tensor_id] }
dsimp
rw [tensor_id]
simp only [id_comp]
rw [←id_tensor_comp, iso.hom_inv_id_app]
slice_rhs 2 3 { rw [←id_tensor_comp, iso.hom_inv_id_app], dsimp, rw [tensor_id] }
dsimp
rw [tensor_id]
simp only [id_comp]
rw [←id_tensor_comp_tensor_id _ (e.unit_inv.app X)]
conv_rhs { rw [←id_tensor_comp_tensor_id _ (e.unit_inv.app X)], }
dsimp only [functor.comp_obj]
rw [←id_tensor_comp, iso.hom_inv_id_app]
slice_rhs 3 4 { rw [←id_tensor_comp, iso.hom_inv_id_app], dsimp, rw [tensor_id] }
dsimp
rw [tensor_id]
simp only [id_comp]
simp [associator_naturality]
dsimp
simp only [tensor_id, assoc, id_comp, functor.map_comp, e.inverse.map_id]
rw equivalence.counit_app_functor
simp only [←e.functor.map_comp]
congr' 1
rw [←left_unitor_naturality]
simp
dsimp
simp only [tensor_id, assoc, id_comp, functor.map_comp, e.inverse.map_id]
rw equivalence.counit_app_functor
simp only [←e.functor.map_comp]
congr' 1
rw [←right_unitor_naturality]
simp
have h := congr_arg (λ f, (app X).inv ≫ (f ≫ (app Y).inv)) (naturality f).symm
simp only [iso.inv_hom_id_assoc, iso.hom_inv_id, assoc, comp_id, cancel_mono] at h
exact h
tidy
simp
simp
simp
ext ⟨⟩ ⟨⟩
simp
ext ⟨⟩ ⟨⟩
simp
ext
dsimp [embedding]
simp only [←F.map_comp, biproduct.lift_π, biproduct.matrix_π, category.assoc]
simp only [←F.map_comp, ←F.map_sum, biproduct.lift_desc, biproduct.lift_π_assoc, comp_sum]
simp only [comp_def, comp_dite, comp_zero, finset.sum_dite_eq', finset.mem_univ, if_true]
dsimp
simp only [finset.sum_singleton, dite_comp, zero_comp]
congr
symmetry
convert finset.sum_fn _ _
simp only [finset.sum_fn, finset.sum_dite_eq]
ext
simp
fapply homotopy.mk_inductive
{ exact lift_homotopy_zero_zero f comm, }
exact lift_homotopy_zero_zero f comm
{ simp [lift_homotopy_zero_zero], }
simp [lift_homotopy_zero_zero]
{ exact lift_homotopy_zero_one f comm, }
exact lift_homotopy_zero_one f comm
{ simp [lift_homotopy_zero_one], }
simp [lift_homotopy_zero_one]
rintro n ⟨g, g', w⟩
fsplit
{ exact lift_homotopy_zero_succ f n g g' w, }
exact lift_homotopy_zero_succ f n g g' w
simp [lift_homotopy_zero_succ, w]
haveI := subsingleton_of_forall_eq (0 : X ⟶ Y) (λ f, begin have p := not_congr (is_iso_iff_nonzero f), simp only [not_not, ne.def] at p, refine p.mp (λ _, by exactI h (as_iso f)), end)
have p := not_congr (is_iso_iff_nonzero f)
simp only [not_not, ne.def] at p
exactI h (as_iso f)
refine p.mp (λ _, by exactI h (as_iso f))
exact finrank_zero_of_subsingleton
simpa using comp_closure.intro (f ≫ x) m₁ m₂ y h
cases f
cases f; obviously
obviously
simp [covers_iff]
cases J₂
congr
apply h
cases J₁
simpa using trans (𝟙 _)
ext T h
split
rintro ⟨hk⟩
exact pullback_arrows.mk _ _ (of_arrows.mk hk)
{ rintro ⟨hk⟩, exact pullback_arrows.mk _ _ (of_arrows.mk hk) }
rintro ⟨W, k, hk₁⟩
cases hk₁ with i hi
apply of_arrows.mk
rintros Y Z f ⟨h₁, h₂⟩ g
simp [h₁, h₂]
rw [← id_mem_iff_eq_top, pullback_apply, category.id_comp]
congr
ext
cases f
ext
simpa using w.symm
simp [of_mk_le, of_le_mk, of_le, of_mk_le_mk, ←functor.map_comp_assoc underlying]
refine quotient.ind' (λ f, _)
exact ⟨mono_over.le_top f⟩
simp
simp
simp
have : (limits.prod.fst : A ⨯ A ⟶ _) = limits.prod.snd
{ simp [←cancel_epi (diag A)] }
simp [←cancel_epi (diag A)]
rw [←prod.lift_fst f g, this, prod.lift_snd]
apply_instance
apply_instance
simp
simp [blocks_fun, ones, blocks, i.2]
have fiber_none_is_false : (equiv.remove_none.fiber (@none α)) -> false
exact is_empty.false
{ rw equiv.remove_none.fiber_none, exact is_empty.false }
rw equiv.remove_none.fiber_none
calc derangements (option α) ≃ equiv.perm.decompose_option '' derangements (option α) : equiv.image _ _ ... ≃ Σ (a : option α), ↥(equiv.remove_none.fiber a) : set_prod_equiv_sigma _ ... ≃ Σ (a : α), ↥(equiv.remove_none.fiber (some a)) : sigma_option_equiv_of_some _ fiber_none_is_false ... ≃ Σ (a : α), {f : perm α | fixed_points f ⊆ {a}} : by simp_rw equiv.remove_none.fiber_some
simp_rw equiv.remove_none.fiber_some
refl
{ refl }
induction n with n hn
rw [finset.sum_range_succ, num_derangements_succ, hn, finset.mul_sum, nat.sub_self, nat.asc_factorial_zero, int.coe_nat_one, mul_one, pow_succ, neg_one_mul, sub_eq_add_neg, add_left_inj, finset.sum_congr rfl]
intros x hx
have h_le : x ≤ n := finset.mem_range_succ_iff.mp hx
rw [nat.succ_sub h_le, nat.asc_factorial_succ, nat.add_sub_cancel' h_le, int.coe_nat_mul, int.coe_nat_succ, mul_left_comm]
exactI fintype.card ι' ≤ n → (∀ (s' : finset ι'), s'.card ≤ (s'.bUnion t').card) → ∃ (f : ι' → α), function.injective f ∧ ∀ x, f x ∈ t' x
by_cases h : ∀ (s : finset ι), s.nonempty → s ≠ univ → s.card < (s.bUnion t).card
{ exact hall_hard_inductive_step_A hn ht @ih h, }
exact hall_hard_inductive_step_A hn ht @ih h
push_neg at h
rcases h with ⟨s, sne, snu, sle⟩
have seq := nat.le_antisymm (ht _) sle
exact hall_hard_inductive_step_B hn ht @ih s sne snu seq
tactic.unfreeze_local_instances
revert ι
refine nat.strong_induction_on n (λ n' ih, _)
intros _ _ t hn ht
rcases n' with (_|_)
{ exact hall_hard_inductive_zero t hn }
exact hall_hard_inductive_zero t hn
apply hall_hard_inductive_step hn ht
introsI ι' _ _ hι'
exact ih (fintype.card ι') (nat.lt_succ_of_le hι') rfl
rw [multiset.coe_sum, c.blocks_sum]
exact G.irrefl hab
rintro rfl
rw set.disjoint_iff
rintro w ⟨h, h'⟩
rw [mem_neighbor_set, compl_adj] at h'
exact h'.2 h
refl
rw [common_neighbors, set.inter_comm]
convert univ.card.pred_eq_sub_one
erw [degree, neighbor_finset_eq_filter, filter_ne, card_erase_of_mem (mem_univ v)]
obtain ⟨t, ht : _ = _⟩ := min_of_nonempty (univ_nonempty.image (λ v, G.degree v))
obtain ⟨v, _, rfl⟩ := mem_image.mp (mem_of_min ht)
simp [min_degree, ht]
refine ⟨v, by simp [min_degree, ht]⟩
simpa using dart_edge_eq_iff d' d
rcases G.even_card_odd_degree_vertices with ⟨k, hg⟩
have hk : 0 < k
have hh : (filter (λ (v : V), odd (G.degree v)) univ).nonempty
use v
simp only [true_and, mem_filter, mem_univ]
{ use v, simp only [true_and, mem_filter, mem_univ], use h, }
use h
rwa [←card_pos, hg, zero_lt_mul_left] at hh
{ have hh : (filter (λ (v : V), odd (G.degree v)) univ).nonempty, { use v, simp only [true_and, mem_filter, mem_univ], use h, }, rwa [←card_pos, hg, zero_lt_mul_left] at hh, exact zero_lt_two, }
exact zero_lt_two
have hc : (λ (w : V), w ≠ v ∧ odd (G.degree w)) = (λ (w : V), odd (G.degree w) ∧ w ≠ v)
ext w
{ ext w, rw and_comm, }
rw and_comm
simp only [hc, filter_congr_decidable]
rw [←filter_filter, filter_ne', card_erase_of_mem]
use k - 1
rw [nat.pred_eq_succ_iff, hg, nat.mul_sub_left_distrib, ← nat.sub_add_comm, eq_comm, ← (nat.sub_eq_iff_eq_add _).symm]
{ ring }
ring
{ exact add_le_add_right (zero_le (2 * k)) 2 }
exact add_le_add_right (zero_le (2 * k)) 2
{ use k - 1, rw [nat.pred_eq_succ_iff, hg, nat.mul_sub_left_distrib, ← nat.sub_add_comm, eq_comm, ← (nat.sub_eq_iff_eq_add _).symm], { ring }, { exact add_le_add_right (zero_le (2 * k)) 2 }, { exact nat.mul_le_mul_left _ hk } }
exact nat.mul_le_mul_left _ hk
simpa only [true_and, mem_filter, mem_univ]
classical
haveI : decidable_eq V
apply_instance
{ classical, apply_instance }
rcases G.odd_card_odd_degree_vertices_ne v h with ⟨k, hg⟩
have hg' : (filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) univ).card > 0
rw hg
{ rw hg, apply nat.succ_pos, }
apply nat.succ_pos
rcases card_pos.mp hg' with ⟨w, hw⟩
simp only [true_and, mem_filter, mem_univ, ne.def] at hw
exact ⟨w, hw⟩
rw language.mem_star at hy
rcases hy with ⟨ S, rfl, hS ⟩
induction S with a S ih
{ refl }
refl
have ha := hS a (list.mem_cons_self _ _)
rw set.mem_singleton_iff at ha
rw [list.join, eval_from_of_append, ha, hx]
apply ih
intros z hz
exact hS z (list.mem_cons_of_mem a hz)
simp [vector.m_of_fn]
simp [vector.m_of_fn]; exact (hf 0).bind (partrec.bind ((vector_m_of_fn (λ i, hf i.succ)).comp fst) (primrec.vector_cons.to_comp.comp (snd.comp fst) snd))
exact (hf 0).bind (partrec.bind ((vector_m_of_fn (λ i, hf i.succ)).comp fst) (primrec.vector_cons.to_comp.comp (snd.comp fst) snd))
cases f a; refl
refl
refl
cases f a
simp [encode_code_eq, encode_code, -add_comm]
have := nat.mul_le_mul_right _ (dec_trivial : 1 ≤ 2*2)
rw [one_mul, mul_assoc, ← bit0_eq_two_mul, ← bit0_eq_two_mul] at this
have := lt_of_le_of_lt this (lt_add_of_pos_right _ (dec_trivial:0<4))
exact ⟨ lt_of_le_of_lt (nat.left_le_mkpair _ _) this, lt_of_le_of_lt (nat.right_le_mkpair _ _) this⟩
simp [encode_code_eq, encode_code, -add_comm]
have := nat.mul_le_mul_right _ (dec_trivial : 1 ≤ 2*2)
rw [one_mul, mul_assoc, ← bit0_eq_two_mul, ← bit0_eq_two_mul] at this
refine lt_of_le_of_lt (le_trans this _) (lt_add_of_pos_right _ (dec_trivial:0<4))
exact le_of_lt (nat.bit0_lt_bit1 $ le_of_lt $ nat.bit0_lt_bit1 $ le_refl _)
simp; induction p.unpair.2; simp [*, pow_succ']
simp; induction p.unpair.2
induction p.unpair.2
simp [*, pow_succ']
simp [*, pow_succ']
simp
simp
induction pf
exact const 0
case nat.primrec'.zero { exact const 0 }
exact primrec.succ.comp vector_head
case nat.primrec'.succ { exact primrec.succ.comp vector_head }
case nat.primrec'.nth : n i { exact vector_nth.comp primrec.id (const i) }
exact vector_nth.comp primrec.id (const i)
case nat.primrec'.comp : m n f g _ _ hf hg { exact hf.comp (vector_of_fn (λ i, hg i)) }
exact hf.comp (vector_of_fn (λ i, hg i))
case nat.primrec'.prec : n f g _ _ hf hg { exact nat_elim' vector_head (hf.comp vector_tail) (hg.comp $ vector_cons.comp (fst.comp snd) $ vector_cons.comp (snd.comp snd) $ (@vector_tail _ _ (n+1)).comp fst).to₂ }
exact nat_elim' vector_head (hf.comp vector_tail) (hg.comp $ vector_cons.comp (fst.comp snd) $ vector_cons.comp (snd.comp snd) $ (@vector_tail _ _ (n+1)).comp fst).to₂
rw v.eq_nil
rw v.eq_nil; refl
refl
simp
simp
cases decode α n.unpair.1; simp
simp
simp
cases decode α n.unpair.1
cases decode β n.unpair.2; simp
simp
simp
cases decode β n.unpair.2
simpa [encodek] using h.comp fst ((@primrec.encode β _).comp snd)
simpa using cond hc hf hg
cases o₁
cases o₁; cases o₂; refl
cases o₁; cases o₂
cases o₂
cases o₂
refl
refl
refl
refl
letI H := primcodable.prim (list ℕ); exact have primrec₂ (λ (a : α) (o : option (list ℕ)), o.map (list.cons (encode a))), from option_map snd $ (list_cons' H).comp ((@primrec.encode α _).comp (fst.comp fst)) snd, have primrec (λ n, (of_nat (list ℕ) n).reverse.foldl (λ o m, (decode α m).bind (λ a, o.map (list.cons (encode a)))) (some [])), from list_foldl' H ((list_reverse' H).comp (primrec.of_nat (list ℕ))) (const (some [])) (primrec.comp₂ (bind_decode_iff.2 $ primrec₂.swap this) primrec₂.right), nat_iff.1 $ (encode_iff.2 this).of_eq $ λ n, begin rw list.foldl_reverse, apply nat.case_strong_induction_on n, { simp }, intros n IH, simp, cases decode α n.unpair.1 with a, {refl}, simp, suffices : ∀ (o : option (list ℕ)) p (_ : encode o = encode p), encode (option.map (list.cons (encode a)) o) = encode (option.map (list.cons a) p), from this _ _ (IH _ (nat.unpair_right_le n)), intros o p IH, cases o; cases p; injection IH with h, exact congr_arg (λ k, (nat.mkpair (encode a) k).succ.succ) h end
exact have primrec₂ (λ (a : α) (o : option (list ℕ)), o.map (list.cons (encode a))), from option_map snd $ (list_cons' H).comp ((@primrec.encode α _).comp (fst.comp fst)) snd, have primrec (λ n, (of_nat (list ℕ) n).reverse.foldl (λ o m, (decode α m).bind (λ a, o.map (list.cons (encode a)))) (some [])), from list_foldl' H ((list_reverse' H).comp (primrec.of_nat (list ℕ))) (const (some [])) (primrec.comp₂ (bind_decode_iff.2 $ primrec₂.swap this) primrec₂.right), nat_iff.1 $ (encode_iff.2 this).of_eq $ λ n, begin rw list.foldl_reverse, apply nat.case_strong_induction_on n, { simp }, intros n IH, simp, cases decode α n.unpair.1 with a, {refl}, simp, suffices : ∀ (o : option (list ℕ)) p (_ : encode o = encode p), encode (option.map (list.cons (encode a)) o) = encode (option.map (list.cons a) p), from this _ _ (IH _ (nat.unpair_right_le n)), intros o p IH, cases o; cases p; injection IH with h, exact congr_arg (λ k, (nat.mkpair (encode a) k).succ.succ) h end
letI H := primcodable.prim (list ℕ)
rw list.foldl_reverse
apply nat.case_strong_induction_on n
simp
{ simp }
simp
intros n IH
refl
cases decode α n.unpair.1 with a
{refl}
simp
suffices : ∀ (o : option (list ℕ)) p (_ : encode o = encode p), encode (option.map (list.cons (encode a)) o) = encode (option.map (list.cons a) p)
from this _ _ (IH _ (nat.unpair_right_le n))
intros o p IH
cases o; cases p; injection IH with h
cases o; cases p
cases p
cases p
injection IH with h
injection IH with h
injection IH with h
injection IH with h
cases o
exact congr_arg (λ k, (nat.mkpair (encode a) k).succ.succ) h
refl
simp [head]
rcases s with _|_|_; refl
refl
refl
refl
rcases s with _|_|_
rw (_ : TM1.init _ = _)
refine ⟨list_blank.mk (L.reverse.map $ λ a, update (default _) k (some a)), λ k', _⟩
refine list_blank.ext (λ i, _)
rw [list_blank.map_mk, list_blank.nth_mk, list.inth, list.map_map, (∘), list.nth_map, proj, pointed_map.mk_val]
by_cases k' = k
simp only [function.update_same]
subst k'
{ subst k', simp only [function.update_same], rw [list_blank.nth_mk, list.inth, ← list.map_reverse, list.nth_map] }
rw [list_blank.nth_mk, list.inth, ← list.map_reverse, list.nth_map]
simp only [function.update_noteq h]
rw [list_blank.nth_mk, list.inth, list.map, list.reverse_nil, list.nth]
cases L.reverse.nth i; refl
refl
refl
{ refine ⟨list_blank.mk (L.reverse.map $ λ a, update (default _) k (some a)), λ k', _⟩, refine list_blank.ext (λ i, _), rw [list_blank.map_mk, list_blank.nth_mk, list.inth, list.map_map, (∘), list.nth_map, proj, pointed_map.mk_val], by_cases k' = k, { subst k', simp only [function.update_same], rw [list_blank.nth_mk, list.inth, ← list.map_reverse, list.nth_map] }, { simp only [function.update_noteq h], rw [list_blank.nth_mk, list.inth, list.map, list.reverse_nil, list.nth], cases L.reverse.nth i; refl } }
cases L.reverse.nth i
dsimp only
congr
congr; cases L.reverse; try {refl}
congr; cases L.reverse
cases L.reverse
cases L.reverse
rw [tr_init, TM1.init]
try {refl}
try {refl}
try {refl}
try {refl}
refl
refl
simp only [list.map_map, list.tail_cons, list.map]
rw [← list_blank.cons_head_tail l]
conv {to_lhs, rw [← list_blank.cons_head_tail l]}
to_lhs
exact quotient.induction_on' l.tail (λ l, rfl)
induction l₁; simp only [*, list_blank.append, list.nil_append, list.cons_append, list_blank.cons_mk]
simp only [*, list_blank.append, list.nil_append, list.cons_append, list_blank.cons_mk]
simp only [*, list_blank.append, list.nil_append, list.cons_append, list_blank.cons_mk]
induction l₁
intro
intro; simp only [list_blank.append_mk, list.append_assoc]
simp only [list_blank.append_mk, list.append_assoc]
simp [applicative.pure_seq_eq_map'] with functor_norm
refine { .. }; intros; cases x; refl
refine { .. }; intros; cases x
refine { .. }; intros
intros
intros
cases x
cases x
refl
refl
refine { .. }
let p := λ (i : ℕ), (fix.approx f i x).dom
have : p (nat.find h') := nat.find_spec h'
generalize hk : nat.find h' = k
replace hk : nat.find h' = k + (@upto.zero p).val := hk
rw hk at this
revert hk
rw assert_pos h'
revert this
dsimp [part.fix]
intros
generalize : upto.zero = z
suffices : ∀ x', well_founded.fix (fix._proof_1 f x h') (fix_aux f) z x' = fix.approx f (succ k) x'
from this _
induction k generalizing z; intro
intro
intro
induction k generalizing z
rw [fix.approx,well_founded.fix_eq,fix_aux]
ext : 1
rw assert_neg
refl
congr
rw nat.zero_add at this
{ rw [fix.approx,well_founded.fix_eq,fix_aux], congr, ext : 1, rw assert_neg, refl, rw nat.zero_add at this, simpa only [not_not, subtype.val_eq_coe] }
simpa only [not_not, subtype.val_eq_coe]
rw [fix.approx,well_founded.fix_eq,fix_aux]
ext : 1
congr
have hh : ¬(fix.approx f (z.val) x).dom
apply nat.find_min h'
rw [hk,nat.succ_add,← nat.add_succ]
apply nat.lt_of_succ_le
{ apply nat.find_min h', rw [hk,nat.succ_add,← nat.add_succ], apply nat.lt_of_succ_le, apply nat.le_add_left }
apply nat.le_add_left
rw succ_add_eq_succ_add at this hk
rw [assert_pos hh, k_ih (upto.succ z hh) this hk]
intros
intros; ext; apply list.mfoldr_append
intros; ext
ext
apply list.mfoldr_append
simp only [list.reverse_reverse]
simp only [list.foldr_eta]
simp only [flip,list.foldr_reverse,foldl.of_free_monoid, unop_op]
have : is_monoid_hom (foldl.of_free_monoid (flip $ @cons α))
apply fold_foldl
{ apply fold_foldl }
rw fold_map_hom_free this
simp only [to_list, foldl, list.reverse_inj, foldl.get, foldl.of_free_monoid_comp_free_mk]
all_goals { apply_instance }
apply_instance
ext1 α
exact funext (h α)
apply coe_inj
funext
funext; refl
refl
simp [this] with functor_norm
simp [traverse_append as bs] with functor_norm
simp [traverse_append as bs] with functor_norm; congr
congr
simp
simpa using h₁
{simpa using h₁}
have h₃ : j < n
rw [to_list_nth_le _ h₃]
refine let ⟨_, e⟩ := list.nth_eq_some.1 _ in e.symm
by_cases ij : (i : ℕ) = j
rw [show (⟨(i : ℕ), h₃⟩ : fin _) = i, from fin.eq_of_veq rfl, array.read_write, list.nth_update_nth_of_lt]
subst j
{ subst j, rw [show (⟨(i : ℕ), h₃⟩ : fin _) = i, from fin.eq_of_veq rfl, array.read_write, list.nth_update_nth_of_lt], simp [h₃] }
simp [h₃]
rw [list.nth_update_nth_ne _ _ ij, a.read_write_of_ne, to_list_nth.2 ⟨h₃, rfl⟩]
exact fin.ne_of_vne ij
rw ←rev_list_reverse; exact list.mem_reverse.trans mem_rev_list
exact list.mem_reverse.trans mem_rev_list
rw ←rev_list_reverse
simp [H]
by_cases p; simp *
simp *
simp *
by_cases p
split
introI
constructor
intros _ _ hn
obtain ⟨_, _, h⟩ := bounded.exists (@parser.decorate_errors α msgs p) hn
simp [decorate_errors_eq_fail] at h
{ introI, constructor, intros _ _ hn, obtain ⟨_, _, h⟩ := bounded.exists (@parser.decorate_errors α msgs p) hn, simp [decorate_errors_eq_fail] at h, exact h.right.right }
exact h.right.right
introI
constructor
intros _ _ hn
obtain ⟨_, _, h⟩ := bounded.exists p hn
simp [h]
apply not_step_of_static_done
simp [remaining_eq_done]
simp [eq_comm]
simp [many, foldr_eq_fail]
simp [many1, seq_eq_done, map_eq_done]
apply_instance
simp [bit0]
simp [norm_sq]
rw [fpow_bit1', I_mul_I]
simp [lt_def, mul_re, mul_im, ← hz.2, ← hw.2, mul_pos hz.1 hw.1]
cases H _ ij with H₁ H₂
apply lt_of_le_of_lt (abs_le_abs_re_add_abs_im _)
dsimp [lim_aux] at *
have := add_lt_add H₁ H₂
rwa add_halves at this
simp [cau_seq_conj, (lim_re _).symm, cau_seq_re]
simp [cau_seq_conj, (lim_im _).symm, cau_seq_im, (lim_neg _).symm]; refl
refl
simp [cau_seq_conj, (lim_im _).symm, cau_seq_im, (lim_neg _).symm]
simp only [← sq, sin_sq_le_one]
simp [sum_range_succ]
simp [two_mul, mul_two, mul_add, mul_comm]
refine (_root_.abs_sub_le _ _ _).trans ((add_le_add_right h _).trans _)
rw [exp_near_succ, exp_near_sub, _root_.abs_mul]
subst e₁
convert mul_le_mul_of_nonneg_left (le_sub_iff_add_le'.1 e) _
simp [mul_add, pow_succ', div_eq_mul_inv, _root_.abs_mul, _root_.abs_inv, ← pow_abs, mul_inv']
{ simp [mul_add, pow_succ', div_eq_mul_inv, _root_.abs_mul, _root_.abs_inv, ← pow_abs, mul_inv'], ac_refl }
ac_refl
simp [_root_.div_nonneg, _root_.abs_nonneg]
convert ε0
cases j
{ exact absurd hj (not_le_of_gt zero_lt_one) }
exact absurd hj (not_le_of_gt zero_lt_one)
dsimp [exp']
induction j with j ih
dsimp [exp']; simp
simp
{ dsimp [exp']; simp }
dsimp [exp']
rw ← ih dec_trivial
simp only [sum_range_succ, pow_succ]
simp
rw [nat.cast_zero, zero_mul, exp_zero, pow_zero]
rw [pow_succ', nat.cast_add_one, add_mul, exp_add, ←exp_nat_mul, one_mul]
simp [norm_sq_eq_def]
simp [div_eq_mul_inv, mul_assoc, sub_eq_add_neg]
tauto
have := I_mul_I_ax
rw [mul_self_abs, add_mul_self_eq, mul_self_abs, mul_self_abs, add_right_comm, norm_sq_add, add_le_add_iff_left, mul_assoc, mul_le_mul_left (@zero_lt_two ℝ _ _)]
simpa [-mul_re] using re_le_abs (z * conj w)
simp only [add_monoid_hom.map_zero]
unfold_coes
unfold_coes; simp [add_zero, id.def, mul_zero]
simp [add_zero, id.def, mul_zero]
simp only [add_monoid_hom.id_apply, algebra.id.map_eq_self]
simp only [add_monoid_hom.zero_apply]
simp only [sub_zero, mul_zero, add_monoid_hom.zero_apply, add_monoid_hom.id_apply]
simp only [add_zero, zero_mul, mul_zero, add_monoid_hom.zero_apply]
simp only [ring_hom.id_apply]
simp only [neg_zero, add_monoid_hom.zero_apply]
simp only [ring_hom.map_zero, neg_zero]
simp only [sq, norm, ←abs_mul, abs_mul_self z, add_zero, mul_zero, add_monoid_hom.zero_apply, add_monoid_hom.id_apply]
simp only [mul_zero, add_monoid_hom.zero_apply]
simp [sq, real.norm_eq_abs, abs_mul_abs_self, ← div_eq_mul_inv]
simp only [div_zero, mul_zero, neg_zero]
simp [norm_eq_abs]
rw [ring_hom.map_one, zero_smul, add_zero]
rw [add_mul, mul_add, mul_add, add_comm _ (y₁ • I' * y₂ • I'), add_add_add_comm]
congr' 1
rw [smul_mul_smul, hf, smul_neg, ←algebra.algebra_map_eq_smul_one, ←sub_eq_add_neg, ←ring_hom.map_mul, ←ring_hom.map_sub]
{ rw [smul_mul_smul, hf, smul_neg, ←algebra.algebra_map_eq_smul_one, ←sub_eq_add_neg, ←ring_hom.map_mul, ←ring_hom.map_sub], }
rw [algebra.smul_def, algebra.smul_def, algebra.smul_def, ←algebra.right_comm _ x₂, ←mul_assoc, ←add_mul, ←ring_hom.map_mul, ←ring_hom.map_mul, ←ring_hom.map_add]
ext
ext; simp [smul_re, smul_im, smul_comm]
simp [smul_re, smul_im, smul_comm]
simp [smul_re, smul_im, smul_comm]
ext
ext; simp [smul_re, smul_im, smul_assoc]
simp [smul_re, smul_im, smul_assoc]
simp [smul_re, smul_im, smul_assoc]
simp only [smul_apply, zero_smul, zero_apply]
simp only [add_apply, smul_apply, add_smul]
simp only [add_apply, subtype_domain_apply]
ext j
have := apply_ite (λ x : Π₀ i, β i, x j) (p i) (single i x) 0
dsimp at this
rw [filter_apply, this]
obtain rfl | hij := decidable.eq_or_ne i j
{ refl, }
refl
rw [single_eq_of_ne hij, if_t_t, if_t_t]
cases ha
exact ha_h
apply (equiv.set.sum_diff_subset h).injective
simp only [apply_symm_apply, sum_diff_subset_apply_inr]
exact subtype.eq rfl
simp [swap_apply_def] {contextual := tt}
by_cases hab : a = b
{ simp [hab] }
simp [hab]
by_cases hax : x = a
{ simp [hax, eq_comm] }
simp [hax, eq_comm]
by_cases hbx : x = b
{ simp [hbx] }
simp [hbx]
simp [hab, hax, hbx, swap_apply_of_ne_of_ne]
ext x
cases x
simp [sum.map, swap_apply_def]
split_ifs; refl
refl
refl
refl
{ simp [sum.map, swap_apply_def], split_ifs; refl}
split_ifs
simp [sum.map, swap_apply_of_ne_of_ne]
simp
simp [and_assoc]
ext
cases s; simp [encode_sum, decode_sum, encodek]; refl
cases s; simp [encode_sum, decode_sum, encodek]
simp [encode_sum, decode_sum, encodek]
simp [encode_sum, decode_sum, encodek]
cases s
simp
cases n; refl
refl
refl
cases n
subst h
exact w
simp [raise', lower', nat.add_sub_cancel, lower_raise']
mfld_set_tac
rw [h₂ x, h₂ y]
rw f.map_mul
rw hB.mul_comm
simpa
rw [← e.map_mul, hxy, e.map_zero]
simpa using congr_arg e.symm hx
simpa using congr_arg e.symm hy
haveI : nontrivial B := hB.to_nontrivial
exact e.symm.injective.ne zero_ne_one
refine_struct { to_fun := ring_equiv.to_add_equiv }
refine_struct { to_fun := ring_equiv.to_add_equiv }; intros; refl
refine_struct { to_fun := ring_equiv.to_add_equiv }; intros
intros
intros
refl
refl
letI := equiv.has_mul e
exact α ≃+* β
letI := equiv.has_add e
introsI
exact { map_add' := λ x y, by { apply e.symm.injective, simp, refl, }, map_mul' := λ x y, by { apply e.symm.injective, simp, refl, }, ..e }
apply e.symm.injective
simp
refl
apply e.symm.injective
simp
refl
resetI; apply e.injective.mul_zero_class _; intros; exact e.apply_symm_apply _
resetI; apply e.injective.mul_zero_class _; intros
resetI; apply e.injective.mul_zero_class _
apply e.injective.mul_zero_class _
intros
intros
resetI
exact e.apply_symm_apply _
exact e.apply_symm_apply _
show classical.some h = a
let h
have := classical.some_spec h
exact cast (congr_fun this a).symm rfl
from (le_coe_nat_add _ _).not_lt
have : ¬ (nat_add m i : ℕ) < m
rw [add_cases, dif_neg this]
refine eq_of_heq ((eq_rec_heq _ _).trans _)
congr' 1
simp
dsimp [pred_above, succ_above]
rcases p with ⟨p, _⟩
rcases i with ⟨i, _⟩
cases lt_or_le i p with H H
rw if_pos
refl
exact H
simp
apply le_of_lt H
rw dif_neg
{ rw dif_neg, rw if_pos, refl, exact H, simp, apply le_of_lt H, }
rw if_neg
rw dif_pos
swap 3
{ exact lt_of_le_of_ne H (ne.symm h), }
exact lt_of_le_of_ne H (ne.symm h)
{ simp, }
simp
simp only [subtype.mk_eq_mk, ne.def, fin.cast_succ_mk] at h
simp only [pred, subtype.mk_lt_mk, not_lt]
exact nat.le_pred_of_lt (nat.lt_of_le_and_ne H (ne.symm h))
apply_instance
ext j
by_cases h : j = 0
refl
{ rw h, refl }
rw h
let j' := pred j h
have : j'.succ = j := succ_pred j h
rw [← this, cons_succ, comp_app, cons_succ]
simp [insert_nth_zero]
rw fin.eq_iff_veq
exact coe_val_of_lt a.property
simp only [nat.mod_eq_of_lt n.lt_succ_self]
rw [←fin.of_nat_eq_coe, fin.of_nat, fin.last]
ext
exact coe_val_of_lt (nat.lt.step a.is_lt)
rw [ext_iff, coe_pred, coe_cast_lt, coe_add, coe_one, mod_eq_of_lt, nat.add_sub_cancel]
exact add_lt_add_right h 1
exact sup_inf_sdiff _ _
rw union_comm
by_cases hi : i ∈ s; simpa [hi]
simpa [hi]
simpa [hi]
by_cases hi : i ∈ s
simp only [mem_filter, mem_union, and_or_distrib_left]
simpa only [mem_filter, mem_sdiff, and_comm, not_and] using λ a, and_congr_right $ λ h : a ∈ s, (imp_iff_right h).symm.trans imp_not_comm
simp only [filter_not, inter_sdiff_self]
rcases s.eq_empty_or_nonempty with rfl|⟨x, hx⟩
simp
{ simp }
refine (nat.succ_le_of_lt (card_pos.2 ⟨x, hx⟩)).le_iff_eq.trans (card_eq_one.trans ⟨_, _⟩)
simp
{ rintro ⟨y, rfl⟩, simp }
rintro ⟨y, rfl⟩
exact λ h, ⟨x, eq_singleton_iff_unique_mem.2 ⟨hx, λ y hy, h _ hy _ hx⟩⟩
rw [← card_union_add_card_inter]
rw [card_eq_zero]
convert (add_zero _).symm
rwa [disjoint_iff] at h
haveI := classical.dec_eq α; exact finset.induction_on s rfl (λ a s has ih, by simp only [image_insert, bUnion_insert, ih])
exact finset.induction_on s rfl (λ a s has ih, by simp only [image_insert, bUnion_insert, ih])
haveI := classical.dec_eq α
simp only [image_insert, bUnion_insert, ih]
simp only [mem_bUnion, mem_image, mem_singleton, eq_comm]
simp only [disjoint_left, mem_insert, or_imp_distrib, forall_and_distrib, forall_eq]
refl
rw [finset.disjoint_left, set.disjoint_left]
intros a b
refine finset.induction_on b empty_right (λ x s xs hi, symm _)
rw finset.insert_eq
apply union_of _ (symm hi)
refine finset.induction_on a empty_right (λ a t ta hi, symm _)
rw finset.insert_eq
exact union_of singletons (symm hi)
rw [insert_inter_of_mem H, empty_inter]
simp [←coe_inj, ←inf_eq_min, ←sup_eq_max, set.Ico_inter_Ico]
simp [Ico_ℤ]
rcases one_lt_card.1 h₂ with ⟨a, ha, b, hb, hab⟩
exact s.min'_lt_max' ha hb hab
rw [antidiagonal, antidiagonal', multiset.to_finsupp_support]
rw [antidiagonal, antidiagonal', multiset.to_finsupp_support]; refl
refl
simpa using (Iic_finset n).finite_to_set
ext a
assume v₁ v₂ eq
have : map_domain f v₁ (f a) = map_domain f v₂ (f a)
rw eq
{ rw eq }
rwa [map_domain_apply hf, map_domain_apply hf] at this
simp
simp only [true_and, finset.mem_univ, iff_self, finset.mem_filter, finset.filter_congr_decidable, forall_true_iff]
ext a
refl
intro f
ext a
refl
intro f
rw subsingleton.elim D; refl
refl
rw subsingleton.elim D
rw [finsupp.mem_support_iff, finsupp.on_finset_apply]
rw f.support.prod_ite_eq'
dsimp [finsupp.prod]
subst h
subst h; simp only [add_apply, single_eq_same, erase_same, zero_add]
simp only [add_apply, single_eq_same, erase_same, zero_add]
simp only [add_apply, single_eq_of_ne h, add_zero, erase_ne (ne.symm h)]
rw [← finset.mem_def, mem_split_support_iff_nonzero]
exact (decidable.em _).symm
refine on_finset (finset.sigma f.support (λ j, (f j).support)) (λ ji, f ji.1 ji.2) (λ g hg, finset.mem_sigma.mpr ⟨_, mem_support_iff.mpr hg⟩)
simp only [ne.def, dfinsupp.mem_support_to_fun]
intro h
rw h at hg
simpa using hg
ext
simp [split]
ext
simp [split]
simp
ext
simp
apply_instance
simp
haveI := classical.prop_decidable
exact (trunc_equiv_of_card_eq h).nonempty
cases int.units_eq_one_or x
cases int.units_eq_one_or x; simp *
simp *
simp *
simp
simp; exact ⟨b, fintype.complete _⟩
exact ⟨b, fintype.complete _⟩
cases b
cases b; apply ulift.fintype
apply ulift.fintype
apply ulift.fintype
rw [←card_unit, card_eq]; exact ⟨λ ⟨a⟩, ⟨a.symm (), λ y, a.injective (subsingleton.elim _ _)⟩, λ ⟨x, hx⟩, ⟨⟨λ _, (), λ _, x, λ _, (hx _).trans (hx _).symm, λ _, subsingleton.elim _ _⟩⟩⟩
exact ⟨λ ⟨a⟩, ⟨a.symm (), λ y, a.injective (subsingleton.elim _ _)⟩, λ ⟨x, hx⟩, ⟨⟨λ _, (), λ _, x, λ _, (hx _).trans (hx _).symm, λ _, subsingleton.elim _ _⟩⟩⟩
rw [←card_unit, card_eq]
simp [fintype.pi_finset, card_map]
let bkt := bkts.read hash_fn a
have nd : (bkt.map sigma.fst).nodup := v.nodup (mk_idx n (hash_fn a))
have lem : Π (bkts' : bucket_array α β n) (v1 u w) (hl : bucket_array.as_list bkts = u ++ v1 ++ w) (hfl : bucket_array.as_list bkts' = u ++ [⟨a, b⟩] ++ w) (veq : (v1 = [] ∧ ¬ contains_aux a bkt) ∨ ∃b'', v1 = [⟨a, b''⟩]), sigma.mk a' b' ∈ bkts'.as_list ↔ if a = a' then b == b' else sigma.mk a' b' ∈ bkts.as_list
intros bkts' v1 u w hl hfl veq
rw [hl, hfl]
by_cases h : a = a'
subst a'
suffices : b = b' ∨ sigma.mk a b' ∈ u ∨ sigma.mk a b' ∈ w ↔ b = b'
{ simpa [eq_comm, or.left_comm] }
simpa [eq_comm, or.left_comm]
refine or_iff_left_of_imp (not.elim $ not_or_distrib.2 _)
rcases veq with ⟨rfl, Hnc⟩ | ⟨b'', rfl⟩
have na := (not_iff_not_of_iff $ v.contains_aux_iff _ _).1 Hnc
simp [na]
{ have na := (not_iff_not_of_iff $ v.contains_aux_iff _ _).1 Hnc, simp [hl, not_or_distrib] at na, simp [na] }
simp [hl, not_or_distrib] at na
have nd' := v.as_list_nodup _
simp [nd']
{ subst a', suffices : b = b' ∨ sigma.mk a b' ∈ u ∨ sigma.mk a b' ∈ w ↔ b = b', { simpa [eq_comm, or.left_comm] }, refine or_iff_left_of_imp (not.elim $ not_or_distrib.2 _), rcases veq with ⟨rfl, Hnc⟩ | ⟨b'', rfl⟩, { have na := (not_iff_not_of_iff $ v.contains_aux_iff _ _).1 Hnc, simp [hl, not_or_distrib] at na, simp [na] }, { have nd' := v.as_list_nodup _, simp [hl, list.nodup_append] at nd', simp [nd'] } }
simp [hl, list.nodup_append] at nd'
simp [h, ne.symm h, this]
{simp [h, ne.symm h, this]}
suffices : sigma.mk a' b' ∉ v1
rcases veq with ⟨rfl, Hnc⟩ | ⟨b'', rfl⟩; simp [ne.symm h]
simp [ne.symm h]
simp [ne.symm h]
{ intros bkts' v1 u w hl hfl veq, rw [hl, hfl], by_cases h : a = a', { subst a', suffices : b = b' ∨ sigma.mk a b' ∈ u ∨ sigma.mk a b' ∈ w ↔ b = b', { simpa [eq_comm, or.left_comm] }, refine or_iff_left_of_imp (not.elim $ not_or_distrib.2 _), rcases veq with ⟨rfl, Hnc⟩ | ⟨b'', rfl⟩, { have na := (not_iff_not_of_iff $ v.contains_aux_iff _ _).1 Hnc, simp [hl, not_or_distrib] at na, simp [na] }, { have nd' := v.as_list_nodup _, simp [hl, list.nodup_append] at nd', simp [nd'] } }, { suffices : sigma.mk a' b' ∉ v1, {simp [h, ne.symm h, this]}, rcases veq with ⟨rfl, Hnc⟩ | ⟨b'', rfl⟩; simp [ne.symm h] } }
rcases veq with ⟨rfl, Hnc⟩ | ⟨b'', rfl⟩
by_cases Hc : (contains_aux a bkt : Prop)
rcases hash_map.valid.replace_aux a b (array.read bkts (mk_idx n (hash_fn a))) ((contains_aux_iff nd).1 Hc) with ⟨u', w', b'', hl', hfl'⟩
rcases (append_of_modify u' [⟨a, b''⟩] [⟨a, b⟩] w' hl' hfl') with ⟨u, w, hl, hfl⟩
simpa [insert, @dif_pos (contains_aux a bkt) _ Hc] using lem _ _ u w hl hfl (or.inr ⟨b'', rfl⟩)
{ rcases hash_map.valid.replace_aux a b (array.read bkts (mk_idx n (hash_fn a))) ((contains_aux_iff nd).1 Hc) with ⟨u', w', b'', hl', hfl'⟩, rcases (append_of_modify u' [⟨a, b''⟩] [⟨a, b⟩] w' hl' hfl') with ⟨u, w, hl, hfl⟩, simpa [insert, @dif_pos (contains_aux a bkt) _ Hc] using lem _ _ u w hl hfl (or.inr ⟨b'', rfl⟩) }
let size' := size + 1
let bkts' := bkts.modify hash_fn a (λl, ⟨a, b⟩::l)
have mi : sigma.mk a' b' ∈ bkts'.as_list ↔ if a = a' then b == b' else sigma.mk a' b' ∈ bkts.as_list := let ⟨u, w, hl, hfl⟩ := append_of_modify [] [] [⟨a, b⟩] _ rfl rfl in lem bkts' _ u w hl hfl $ or.inl ⟨rfl, Hc⟩
simp [insert, @dif_neg (contains_aux a bkt) _ Hc]
by_cases h : size' ≤ n
{ simpa [show size' ≤ n, from h] using mi }
simpa [show size' ≤ n, from h] using mi
let n' : ℕ+ := ⟨n * 2, mul_pos n.2 dec_trivial⟩
let bkts'' : bucket_array α β n' := bkts'.foldl (mk_array _ []) (reinsert_aux hash_fn)
suffices : sigma.mk a' b' ∈ bkts''.as_list ↔ sigma.mk a' b' ∈ bkts'.as_list.reverse
{ simpa [show ¬ size' ≤ n, from h, mi] }
simpa [show ¬ size' ≤ n, from h, mi]
rw [show bkts'' = bkts'.as_list.foldl _ _, from bkts'.foldl_eq _ _, ← list.foldr_reverse]
induction bkts'.as_list.reverse with a l IH
{ simp [mk_as_list] }
simp [mk_as_list]
cases a with a'' b''
let B := l.foldr (λ (y : sigma β) (x : bucket_array α β n'), reinsert_aux hash_fn x y.1 y.2) (mk_array n' [])
rcases append_of_modify [] [] [⟨a'', b''⟩] _ rfl rfl with ⟨u, w, hl, hfl⟩
simp [IH.symm, or.left_comm, show B.as_list = _, from hl, show (reinsert_aux hash_fn B a'' b'').as_list = _, from hfl]
rw [←hiis]
exact t.2
rw h
rw [← bitwise_diff, bitwise_bit]
simp
simp
apply_instance
simp [m0] at ae
simp [m0] at ae; simp [ae, m0]
simp [ae, m0]
cases eq_coe_of_zero_le (@nonneg_of_mul_nonneg_left ℤ _ m a (by simp [ae.symm]) (by simpa using m0l)) with k e
simp [ae.symm]
simpa using m0l
exact ⟨k, int.coe_nat_inj ae⟩
subst a
rw [e, int.coe_nat_mul]
rw [sub_eq_add_neg, sub_eq_add_neg, int.add_div_of_dvd_right ((dvd_neg c b).mpr hcb)]
congr
exact neg_div_of_dvd hcb
rwa zero_mul
unfold bit1
unfold bit0
simp
apply nat.gcd_mul_right
rw [int.gcd, int.gcd, nat_abs_mul, nat_abs_mul]
exact nat.lcm_comm _ _
rw [int.lcm, int.lcm]
unfold gcd_a gcd_b; cases xgcd x y; refl
unfold gcd_a gcd_b; cases xgcd x y
cases xgcd x y
refl
unfold gcd_a gcd_b
simp [h]
rw [odd_iff_not_even, even_add, not_iff, odd_iff_not_even]
rw even_mul
convert n.even_or_odd
simp with parity_simps
simp [*, (dec_trivial : ¬ 2 = 0)] with parity_simps
simp
rw [hm, add_mod]
norm_num
rw h
abel
simpa only [exists_or_distrib, ← odd, ← even] using even_or_odd n
rcases le_iff_exists_add.1 h with ⟨m, rfl⟩
rw [nat.add_sub_cancel_left, add_comm, modify_nth_tail_modify_nth_tail]
simp
simp [list.update_nth]
simp [list.update_nth]
simp only [update_nth, true_and, eq_self_iff_true]
exact update_nth_comm t (λ h', h $ nat.succ_inj'.mpr h')
dsimp [list.insert_nth]
erw [list.mem_cons_iff, mem_insert_nth (nat.le_of_succ_le_succ h), list.mem_cons_iff, ← or.assoc, or_comm (a = a'), or.assoc]
cases le_or_lt n l.length with hn hn
rw length_insert_nth _ _ hn
{ rw length_insert_nth _ _ hn, exact (nat.lt_succ_self _).le }
exact (nat.lt_succ_self _).le
rw insert_nth_of_length_lt _ _ _ hn
simp
simp
dsimp
rw [map_take]
induction L₁; [refl, simp only [*, join, cons_append, append_assoc]]
refl
simp only [*, join, cons_append, append_assoc]
induction L₁
contradiction
induction l with b l IH
{contradiction}
by_cases h : p b
cases H
apply mem_cons_self
rw find_cons_of_pos _ h at H
{ rw find_cons_of_pos _ h at H, cases H, apply mem_cons_self }
exact mem_cons_of_mem _ (IH H)
rw find_cons_of_neg _ h at H
simp only [filter_map, h]
induction l with a l IH
intro H
cases H
{ intro H, cases H }
rintro ⟨_, H, _⟩
cases H
split
{ split, { intro H, cases H }, { rintro ⟨_, H, _⟩, cases H } }
cases h : f a with b'
rw h
intro
contradiction
{rw h, intro, contradiction}
have : f a ≠ some b
simp only [filter_map_cons_none _ _ h, IH, mem_cons_iff, or_and_distrib_right, exists_or_distrib, exists_eq_left, this, false_or]
{ have : f a ≠ some b, {rw h, intro, contradiction}, simp only [filter_map_cons_none _ _ h, IH, mem_cons_iff, or_and_distrib_right, exists_or_distrib, exists_eq_left, this, false_or] }
have : f a = some b ↔ b = b'
split; intro t
intro t
intro t
rw t at h
rw t at h; injection h
injection h
{rw t at h; injection h}
exact t.symm ▸ h
{ split; intro t, {rw t at h; injection h}, {exact t.symm ▸ h} }
split
simp only [filter_map_cons_some _ _ _ h, IH, mem_cons_iff, or_and_distrib_right, exists_or_distrib, this, exists_eq_left]
rw [←mem_iff_nth, ←mem_iff_nth, reduce_option_mem_iff]
simp
simp
simp [tails_eq_inits l, append_left_inj]
induction ys generalizing f f'; simp *
simp *
simp *
induction ys generalizing f f'
simp [H]
apply ys_ih
induction ys with y ys ih generalizing l
{ simp {contextual := tt} }
simp {contextual := tt}
rw [permutations_aux2_snd_cons, show (λ (x : list α), l ++ y :: x) = append (l ++ [y]), by funext; simp, mem_cons_iff, ih]
funext
funext; simp
simp
split
split; intro h
intro h
intro h
rcases h with e | ⟨l₁, l₂, l0, ye, _⟩
exact ⟨[], y::ys, by simp⟩
simp
{ subst l', exact ⟨[], y::ys, by simp⟩ }
subst l'
exact ⟨y::l₁, l₂, l0, by simp⟩
simp
{ rcases h with e | ⟨l₁, l₂, l0, ye, _⟩, { subst l', exact ⟨[], y::ys, by simp⟩ }, { substs l' ys, exact ⟨y::l₁, l₂, l0, by simp⟩ } }
substs l' ys
rcases h with ⟨_ | ⟨y', l₁⟩, l₂, l0, ye, rfl⟩
{ simp [ye] }
simp [ye]
rcases ye with ⟨rfl, rfl⟩
simp at ye
simp
exact or.inr ⟨l₁, l₂, l0, by simp⟩
simp only [insert.def, if_neg h]; split; refl
simp only [insert.def, if_neg h]; split
split
refl
refl
simp only [insert.def, if_neg h]
by_cases a ∈ l; [simp only [insert_of_mem h], simp only [insert_of_not_mem h, suffix_cons]]
simp only [insert_of_mem h]
by_cases a ∈ l
simp only [insert_of_not_mem h, suffix_cons]
induction l; [refl, simp only [*, diff_cons, erase_of_not_mem (not_mem_nil _)]]
refl
simp only [*, diff_cons, erase_of_not_mem (not_mem_nil _)]
induction l
cases bs; refl
refl
refl
cases bs
induction l; simp only [*, concat]; split; refl
induction l; simp only [*, concat]; split
induction l; simp only [*, concat]
simp only [*, concat]
simp only [*, concat]
split
split
induction l
simp
induction l; [refl, simp only [cons_append, last_cons _ (λ H, cons_ne_nil _ _ (append_eq_nil.1 H).2), *]]
induction l
simp only [cons_append, last_cons _ (λ H, cons_ne_nil _ _ (append_eq_nil.1 H).2), *]
refl
intro e; rw e at h; cases h
intro e; rw e at h
rw e at h
cases h
intro e
exact pairwise_singleton _ _
induction c with b b c l r p IH
{exact pairwise_singleton _ _}
simp only [mem_cons_iff, forall_eq_or_imp, r, true_and]
apply IH.cons _
from λ x m, (tr r (rel_of_pairwise_cons IH m))
show ∀ x ∈ l, R b x
simp at *
tauto
simp only [cons_append, chain'_cons] at h₁ h₂ ⊢
simp only [← cons_append] at h₁ h₂ ⊢
exact ⟨h₁.1, chain'.append_overlap h₁.2 h₂ (cons_ne_nil _ _)⟩
simpa using l.prop
induction s using quotient.induction_on'
simp
exact ⟨⟨s, hs⟩, by simp⟩
rw nat.succ_add; exact prod.lex.right _ (lt_succ_self _)
exact prod.lex.right _ (lt_succ_self _)
rw nat.succ_add
simpa [duplicate_cons_iff, hx.symm] using h
rwa [take_left] at h'
induction h; constructor; solve_by_elim
induction h; constructor
constructor
constructor
solve_by_elim
solve_by_elim
induction h
simp only [map, forall₂_nil_left_iff]
simp only [map, forall₂_cons_left_iff, forall₂_map_left_iff]
cases k; refl
refl
refl
cases k
rcases trichotomous_of r a b with ab | rfl | ab
{ exact or.inl (rel ab) }
exact or.inl (rel ab)
exact (_match l₁ l₂).imp cons (or.imp (congr_arg _) cons)
{ exact (_match l₁ l₂).imp cons (or.imp (congr_arg _) cons) }
exact or.inr (or.inr (rel ab))
simp [H]
simp
simp
simp [ihn]
rw [← append_assoc, pairwise_append, @pairwise_append _ _ ([a] ++ l₁), pairwise_append_comm s]
rw [← append_assoc, pairwise_append, @pairwise_append _ _ ([a] ++ l₁), pairwise_append_comm s]; simp only [mem_append, or_comm]
simp only [mem_append, or_comm]
by_cases (∀ y ∈ pw_filter R l, R x y)
rw [pw_filter_cons_of_pos h]
{ rw [pw_filter_cons_of_pos h], exact cons_sublist_cons _ (pw_filter_sublist l) }
exact cons_sublist_cons _ (pw_filter_sublist l)
rw [pw_filter_cons_of_neg h]
exact sublist_cons_of_sublist _ (pw_filter_sublist l)
induction hR with a l R1 R2 IH
clear_
induction hR with a l R1 R2 IH; simp only [pairwise.nil, pairwise_cons] at *
simp only [pairwise.nil, pairwise_cons] at *
simp only [pairwise.nil, pairwise_cons] at *
exact ⟨λ b bl, ⟨R1 b bl, hS.1 b bl⟩, IH hS.2⟩
induction l with y l IH generalizing x
{ simp [take_while], }
simp [take_while]
rw [permutations'_aux, count_cons_self]
by_cases hx : x = y
subst hx
{ subst hx, simpa [take_while, nat.succ_inj'] using IH _ }
simpa [take_while, nat.succ_inj'] using IH _
rw take_while
rw if_neg hx
cases permutations'_aux x l with a as
{ simp }
simp
rw [count_eq_zero_of_not_mem, length, zero_add]
simp [hx, ne.symm hx]
rw sublists'_cons; exact (sublists_cons_perm_append _ _).trans (IH.append (IH.map _))
exact (sublists_cons_perm_append _ _).trans (IH.append (IH.map _))
rw sublists'_cons
exact λ a b c, lt_trans
rw [rotate_eq_rotate', rotate_eq_rotate', rotate_eq_rotate', rotate'_rotate']
rw [rotate_eq_drop_append_take_mod, rotate_eq_drop_append_take_mod, rotate_eq_drop_append_take_mod, h, zip_with_append, ←zip_with_distrib_drop, ←zip_with_distrib_take, list.length_zip_with, h, min_self]
rw [length_drop, length_drop, h]
split
intro h
cases l.length.zero_le.eq_or_lt with hl' hl'
{ simp [←length_eq_zero, ←hl'] }
simp [←length_eq_zero, ←hl']
left
rw nodup_iff_nth_le_inj at hl
refine hl _ _ (mod_lt _ hl') hl' _
rw ←nth_le_rotate' _ n
simp_rw [h, nat.sub_add_cancel (mod_lt _ hl').le, mod_self]
{ intro h, cases l.length.zero_le.eq_or_lt with hl' hl', { simp [←length_eq_zero, ←hl'] }, left, rw nodup_iff_nth_le_inj at hl, refine hl _ _ (mod_lt _ hl') hl' _, rw ←nth_le_rotate' _ n, simp_rw [h, nat.sub_add_cancel (mod_lt _ hl').le, mod_self] }
rintro (h|h)
rw [←rotate_mod, h]
{ rw [←rotate_mod, h], exact rotate_zero l }
exact rotate_zero l
simp [h]
obtain rfl | h := eq_or_ne l []
{ simp }
simp
rw length_cyclic_permutations_of_ne_nil _ h at hn
simp [init_eq_take, cyclic_permutations_of_ne_nil _ h, nth_le_take', rotate_eq_drop_append_take hn.le]
rw rotate'_eq_drop_append_take (le_refl _); simp
simp
rw rotate'_eq_drop_append_take (le_refl _)
rintro ⟨a₁, b₂⟩ ⟨a₂, b₂⟩
rintro ⟨a₁, b₂⟩ ⟨a₂, b₂⟩; dsimp; split_ifs; simp [h] {contextual := tt}
rintro ⟨a₁, b₂⟩ ⟨a₂, b₂⟩; dsimp; split_ifs
rintro ⟨a₁, b₂⟩ ⟨a₂, b₂⟩; dsimp
split_ifs
simp [h] {contextual := tt}
simp [h] {contextual := tt}
dsimp
rw [keys, kerase, ←erasep_map sigma.fst l, erase_eq_erasep]
induction p generalizing l
refl
case list.perm.nil { refl }
case list.perm.cons : hd tl₁ tl₂ p ih { simp [ih (kerase hd.1 l), perm.cons] }
simp [ih (kerase hd.1 l), perm.cons]
case list.perm.swap : s₁ s₂ l { simp [kerase_comm, perm.swap] }
simp [kerase_comm, perm.swap]
case list.perm.trans : l₁ l₂ l₃ p₁₂ p₂₃ ih₁₂ ih₂₃ { exact perm.trans (ih₁₂ l) (ih₂₃ l) }
exact perm.trans (ih₁₂ l) (ih₂₃ l)
simpa [insertion_sort] using (perm_ordered_insert _ _ _).trans ((perm_insertion_sort l).cons b)
split
split; simp only [mem_cons_iff, or_true, mem_zip h]
simp only [mem_cons_iff, or_true, mem_zip h]
simp only [mem_cons_iff, or_true, mem_zip h]
cases l; cases l'; simp
cases l; cases l'
cases l'
cases l'
simp
simp
simp
simp
cases l
rw [← zip_map, map_id]
ext i j
ext i j; simp
simp
simp only [diagonal, map_apply]
split_ifs
split_ifs; simp [h]
simp [h]
simp [h]
ext
apply dot_product_assoc
ext
simp only [coe_scalar, smul_eq_mul, mul_one, one_apply_eq, pi.smul_apply]
simp [commute, semiconj_by]
ext
simp
unfold std_basis_matrix
simp
ext
ext
exact is_empty_elim i
simp [mul_vec, mul_comm]
ext i
refine fin.cases _ _ i
refine fin.cases _ _ i; simp [vec_head, vec_tail]
simp [vec_head, vec_tail]
simp [vec_head, vec_tail]
ext i
apply quotient.induction_on m
simp only [quot_mk_to_coe, coe_prod, mem_coe]
intros l hl₁ hl₂ x hx
apply all_one_of_le_one_le_of_prod_eq_one hl₁ hl₂ _ hx
simp [multiset.sigma, (∘)]
simp [function.funext_iff]
simp [countp_eq_card_filter, h, filter_le_filter]
simp [(∪), union, sub_add_eq_max, -add_comm]
split
induction h
induction h; simp *
simp *
simp *
{ assume h, induction h; simp * }
assume h
subst h
exact rel_eq_refl
assume h
rw [disjoint_comm, disjoint_cons_left]; tauto
tauto
rw [disjoint_comm, disjoint_cons_left]
simpa using add_le_add_left (zero_le t) s
simp [e]
classical
rw [← h.le_erase_dup_iff_le, iff.comm, ← h.le_erase_dup_iff_le]
simp [hn]
simp [ndinter, le_filter, subset_iff]
simp only [antidiagonal, list.nat.antidiagonal_succ, coe_map, cons_coe]
simp; refine list.nodup_map_on _ (nodup_sublists'.2 h); exact λ x sx y sy e, (h.sublist_ext (mem_sublists'.1 sx) (mem_sublists'.1 sy)).1 (quotient.exact e)
simp; refine list.nodup_map_on _ (nodup_sublists'.2 h)
refine list.nodup_map_on _ (nodup_sublists'.2 h)
exact λ x sx y sy e, (h.sublist_ext (mem_sublists'.1 sx) (mem_sublists'.1 sy)).1 (quotient.exact e)
simp
simp [powerset_len_aux_eq_map_coe, subperm]; exact λ l₁, ⟨λ ⟨l₂, ⟨s, e⟩, p⟩, ⟨⟨_, p, s⟩, p.symm.length_eq.trans e⟩, λ ⟨⟨l₂, p, s⟩, e⟩, ⟨_, ⟨s, p.length_eq.trans e⟩, p⟩⟩
exact λ l₁, ⟨λ ⟨l₂, ⟨s, e⟩, p⟩, ⟨⟨_, p, s⟩, p.symm.length_eq.trans e⟩, λ ⟨⟨l₂, p, s⟩, e⟩, ⟨_, ⟨s, p.length_eq.trans e⟩, p⟩⟩
simp [powerset_len_aux_eq_map_coe, subperm]
simp [powerset_len_aux_eq_map_coe]
simp
simp [ih, rel_cons_left, -exists_and_distrib_left, exists_and_distrib_left.symm, eq_comm]
simp [support, finsupp.sum, coeff]
congr
simp only [map_C, comp_app, ring_hom.coe_comp]
ext1 a
{ ext1 a, simp only [map_C, comp_app, ring_hom.coe_comp], }
simp only [map_X, comp_app]
ext1 n
simp
simp
ext
ext; simp
rw [φ.as_sum, ring_hom.map_sum, finset.sum_eq_zero]
intros d hd
obtain ⟨i, hi, hgi⟩ : ∃ i ∈ d.support, g i = 0 := h d (finsupp.mem_support_iff.mp hd)
rw [eval₂_hom_monomial, finsupp.prod, finset.prod_eq_zero hi, mul_zero]
rw [hgi, zero_pow]
rwa [pos_iff_ne_zero, ← finsupp.mem_support_iff]
rw [degrees, support_neg]; refl
refl
rw [degrees, support_neg]
induction n with n ih
{ simp, }
simp
simp [ih]
simpa
simp only [monomial_zero, pderiv_monomial, nat.cast_zero, mul_zero, zero_apply]
simp only [map_C, rename_C]
simp only [hp, hq, alg_hom.map_add, ring_hom.map_add]
simp only [hp, rename_X, map_X, ring_hom.map_mul, alg_hom.map_mul]
simp only [rename, aeval_eq_eval₂_hom]
simp [eval₂_comp_left _ C (X ∘ f) p, (∘), eval₂_C, eval_X]
apply eval₂_hom_congr _ rfl rfl
ext1
simp only [comp_app, ring_hom.coe_comp, eval₂_hom_C]
rw [total_degree_eq]
exact finset.sup_le (assume s hs, multiset.card_le_of_le $ finset.le_sup hs)
cc
rw [bit1, nat.dvd_add_right two_dvd_bit0, nat.dvd_one]
rintros ⟨c, rfl⟩
rcases nat.eq_zero_or_pos c with (rfl | hc)
{ exact lt_irrefl 0 h1 }
exact lt_irrefl 0 h1
exact not_lt.2 (le_mul_of_pos_right hc) h2
unfold bodd div2; cases bodd_div2 n; refl
unfold bodd div2; cases bodd_div2 n
cases bodd_div2 n
refl
unfold bodd div2
simp
simp only [lt_succ_iff_lt_or_eq, or_and_distrib_right, exists_or_distrib, exists_eq_left]
cases le_or_lt a c with h' h'; [left, right]
left
cases le_or_lt a c with h' h'
right
{ exact h', }
exact h'
rw h at h'
replace h' := add_lt_add_right h' d
rw hb
exact zero_le d
cases b.eq_zero_or_pos with hb hb
{ rw hb, exact zero_le d, }
rw [a.add_sub_assoc hb, add_lt_add_iff_left] at h'
exact nat.le_of_pred_lt h'
apply_instance
simp [hc0]
rw [mul_assoc]; exact nat.mul_le_mul_left _ (nat.div_mul_le_self _ _)
exact nat.mul_le_mul_left _ (nat.div_mul_le_self _ _)
rw [mul_assoc]
simp [land]
rw [eq_div_iff_mul_eq (nat.cast_ne_zero.2 b.factorial_ne_zero : (b! : K) ≠ 0), ←nat.cast_mul, mul_comm, ←nat.desc_factorial_eq_factorial_mul_choose, ←cast_desc_factorial]
induction L with d L ih
{ refl, }
refl
simp [of_digits, list.sum_cons, ih]
rw ←of_digits_one
congr
skip
rw ←(of_digits_digits b' n)
conv { congr, skip, rw ←(of_digits_digits b' n) }
convert of_digits_modeq _ _ _
exact h.symm
norm_num
exact succ_pos n
rw [digits, digits_aux_def]
rw [mul_comm k n, mul_comm k m, dist_mul_right, mul_comm]
exact enat.cases_on'
simp only [← some_eq_coe]
rw [← coe_inj, coe_get]
simp only [iff_true, le_top, coe_lt_top, ← @nat.cast_zero enat]
rw [← nat.cast_zero, ← nat.cast_one, enat.coe_lt_coe, enat.coe_le_coe]
refl
exact le_of_lt_add_one
split
rcases ne_top_iff.mp hx with ⟨m, rfl⟩
intro h
induction y using enat.cases_on with n
rw [top_add]
apply coe_lt_top
{ rw [top_add], apply coe_lt_top }
apply_mod_cast h
apply_mod_cast nat.lt_succ_of_le
change (stream.nth (n + 1) $ stream.iterate fib_aux_step ⟨0, 1⟩) = fib_aux_step (stream.nth n $ stream.iterate fib_aux_step ⟨0, 1⟩)
rw [stream.nth_succ_iterate, stream.map_iterate, stream.nth_map]
rw [clog, if_neg (λ h : 1 < b ∧ 1 < n, h.1.not_le hb)]
norm_num
simpa [modeq, show 2 * 2 = 4, by norm_num] using @modeq.of_modeq_mul_left 2 n 1 2
rwa [nat.succ_eq_add_one, ←l.rotate_rotate, hn]
simp
rw [mem_filter, Ico.mem, Ico.mem, lt_succ_iff, ←@enat.coe_le_coe i, enat.coe_get, ←pow_dvd_iff_le_multiplicity, and.right_comm]
refine (and_iff_left_of_imp (λ h, _)).symm
cases m
rw [zero_pow, zero_dvd_iff] at h
exact (hn.ne' h.2).elim
exact h.1
{ rw [zero_pow, zero_dvd_iff] at h, exact (hn.ne' h.2).elim, { exact h.1 } }
exact ((pow_le_iff_le_log (succ_lt_succ $ nat.pos_of_ne_zero $ succ_ne_succ.1 hm) hn).1 $ le_of_dvd hn h.2).trans_lt hb
simp [*, (dec_trivial : ¬ 2 = 0)] with parity_simps
rw [bit0_val, shiftl_eq_mul_pow, mul_left_comm, mul_comm 2]
simpa using (dvd_prime_two_le h a1).1 (dvd_mul_right _ _)
rintro rfl; cases not_le_of_lt pp (le_of_dvd dec_trivial d)
cases not_le_of_lt pp (le_of_dvd dec_trivial d)
rintro rfl
symmetry
rw ← list.repeat_perm
apply nat.factors_unique (list.prod_repeat p n)
intros q hq
rwa eq_of_mem_repeat hq
simpa only [pow_two] using eq_sqrt
dsimp [(≤)]
dsimp [(≤)]; apply_instance
apply_instance
simp
cases n
cases n; refl <|> simp [znum.div]
refl
refl
refl
simp [int.div_zero]
rw ← num.to_nat_to_int; simp
simp
rw ← num.to_nat_to_int
rw ← num.to_nat_to_int; simp
simp
rw ← num.to_nat_to_int
rw [n.to_int_eq_succ_pred, d.to_int_eq_succ_pred, ← pos_num.to_nat_to_int, num.succ'_to_nat, num.div_to_nat]
change -[1+ n.pred' / ↑d] = -[1+ n.pred' / (d.pred' + 1)]
rw d.to_nat_eq_succ_pred
rw [n.to_int_eq_succ_pred, d.to_int_eq_succ_pred, ← pos_num.to_nat_to_int, num.succ'_to_nat, num.div_to_nat]
change (nat.succ (_/d) : ℤ) = nat.succ (n.pred'/(d.pred' + 1))
rw d.to_nat_eq_succ_pred
have := pos_num.cmp_to_nat a b; revert this; dsimp [cmp]; cases pos_num.cmp a b
have := pos_num.cmp_to_nat a b; revert this; dsimp [cmp]
have := pos_num.cmp_to_nat a b; revert this
revert this
dsimp [cmp]
have := pos_num.cmp_to_nat a b
exacts [id, congr_arg pos, id]
cases pos_num.cmp a b
refine_struct { add := (+), zero := 0, zero_add := zero_add, add_zero := add_zero, mul := (*), one := 1, nsmul := @nsmul_rec _ ⟨0⟩ ⟨(+)⟩, npow := @npow_rec _ ⟨1⟩ ⟨(*)⟩ }
refine_struct { add := (+), zero := 0, zero_add := zero_add, add_zero := add_zero, mul := (*), one := 1, nsmul := @nsmul_rec _ ⟨0⟩ ⟨(+)⟩, npow := @npow_rec _ ⟨1⟩ ⟨(*)⟩ }; try { intros, refl }; try { transfer }; simp [mul_add, mul_left_comm, mul_comm, add_comm]
refine_struct { add := (+), zero := 0, zero_add := zero_add, add_zero := add_zero, mul := (*), one := 1, nsmul := @nsmul_rec _ ⟨0⟩ ⟨(+)⟩, npow := @npow_rec _ ⟨1⟩ ⟨(*)⟩ }; try { intros, refl }; try { transfer }
refine_struct { add := (+), zero := 0, zero_add := zero_add, add_zero := add_zero, mul := (*), one := 1, nsmul := @nsmul_rec _ ⟨0⟩ ⟨(+)⟩, npow := @npow_rec _ ⟨1⟩ ⟨(*)⟩ }; try { intros, refl }
refl
try { intros, refl }
try { intros, refl }
try { intros, refl }
try { intros, refl }
try { intros, refl }
try { intros, refl }
try { intros, refl }
try { intros, refl }
try { intros, refl }
try { intros, refl }
try { intros, refl }
try { intros, refl }
try { intros, refl }
try { intros, refl }
try { transfer }
try { transfer }
try { transfer }
try { transfer }
try { transfer }
try { transfer }
try { transfer }
try { transfer }
try { transfer }
try { transfer }
transfer
simp [mul_add, mul_left_comm, mul_comm, add_comm]
simp [mul_add, mul_left_comm, mul_comm, add_comm]
simp [mul_add, mul_left_comm, mul_comm, add_comm]
simp [mul_add, mul_left_comm, mul_comm, add_comm]
simp [mul_add, mul_left_comm, mul_comm, add_comm]
intros
cases n
cases n; refl
refl
refl
refl
cases n
cases n; refl
refl
refl
cases n; try {refl}; rw [succ, num.zneg_to_znum_neg]; refl
cases n; try {refl}; rw [succ, num.zneg_to_znum_neg]
cases n; try {refl}
try {refl}
try {refl}
try {refl}
refl
rw [succ, num.zneg_to_znum_neg]
cases n
refl
simp [znum.bit1, _root_.bit1, _root_.bit0]
rw [znum.bit1, cast_pos, cast_pos]
rw [znum.bit1, cast_pos, cast_pos]; refl
refl
rw [znum.bit1, cast_neg, cast_neg]
cases e : pred' p with a; have : p = _ := (succ'_pred' p).symm.trans (congr_arg num.succ' e)
cases e : pred' p with a
have : p = _ := (succ'_pred' p).symm.trans (congr_arg num.succ' e)
have : p = _ := (succ'_pred' p).symm.trans (congr_arg num.succ' e)
subst p
change p=1 at this
{ change p=1 at this, subst p, simp [_root_.bit1, _root_.bit0] }
simp [_root_.bit1, _root_.bit0]
subst p
rw [num.succ'] at this
simp [add_comm]
{simp [add_comm]}
have : (↑(-↑a:ℤ) : α) = -1 + ↑(-↑a + 1 : ℤ)
simpa [_root_.bit1, _root_.bit0, -add_comm]
rw [← of_nat_to_znum, zneg_to_znum]
rw [← add_one, cast_add, cast_one]
intro h; rw [nat.add_right_comm m m 1, add_assoc]; exact add_le_add h h
intro h; rw [nat.add_right_comm m m 1, add_assoc]
rw [nat.add_right_comm m m 1, add_assoc]
intro h
exact add_le_add h h
cases x
cases x; refl
refl
refl
cases x; simp
simp
simp
cases x
cases x; simp [is_some]; exact ⟨_, rfl⟩
cases x; simp [is_some]
simp [is_some]
simp [is_some]
cases x
rw [dual, dual, dual_dual, dual_dual]
simp [node3_l, node3_r, dual_node']
rw [balance_r_eq_balance' hl hr sl sr H, all_balance']
simp [size_dual, add_comm]
rw [size_dual, size_dual]; exact b.symm
exact b.symm
rw [size_dual, size_dual]
assume a
cases h : g a with b
exact eq_none_iff_forall_not_mem.2 (λ b hb, option.not_mem_none b $ h ▸ fg a b hb)
{ exact eq_none_iff_forall_not_mem.2 (λ b hb, option.not_mem_none b $ h ▸ fg a b hb) }
exact gf _ _ h
simp [restrict]
simp [dom, part.dom_iff_mem]
rw [corec_def,dest_mk]
refl
induction d with d ih
rw [succ_nsmul, prod_add, ih, nat.succ_eq_add_one, pow_succ, mul_comm]
apply le_antisymm
apply le_inf_iff.mpr; split; apply factor_multiset_le_iff.mpr
apply le_inf_iff.mpr; split
split
apply factor_multiset_le_iff.mpr
apply factor_multiset_le_iff.mpr
apply le_inf_iff.mpr
exact gcd_dvd_right m n
{ apply le_inf_iff.mpr; split; apply factor_multiset_le_iff.mpr, exact gcd_dvd_left m n, exact gcd_dvd_right m n}
exact gcd_dvd_left m n
rw[← prime_multiset.prod_dvd_iff, prod_factor_multiset]
apply dvd_gcd; rw[prime_multiset.prod_dvd_iff']
rw[prime_multiset.prod_dvd_iff']
rw[prime_multiset.prod_dvd_iff']
apply dvd_gcd
exact inf_le_right
exact inf_le_left
replace h := congr_arg subtype.val h
exact h
apply coprime.gcd_mul_left_cancel
rw mul_comm
rcases p
simp [add_to_finsupp, monomial, monomial_fun, coeff, erase]
exact finsupp.single_add_erase _ _
simp [coeff, neg_to_finsupp]
rcases p
unfold nat_degree; rw h
rw h
unfold nat_degree
simpa [monic] using hp
rintro rfl
rw [nat_degree, hn]; refl
refl
rw [nat_degree, hn]
nth_rewrite 0 [← one_mul p]
rw [← C_1, ← au, ring_hom.map_mul, ← mul_assoc]
simp only [←C_eq_nat_cast, nat_trailing_degree_C]
rw [ring_hom.map_add, polynomial.map_add, eval_add, mul_add, Hf, Hg]
congr
refine @inv_unique K _ (i b) bg bf _ _; rwa mul_comm
refine @inv_unique K _ (i b) bg bf _ _
rwa mul_comm
rwa mul_comm
rw [map_C, derivative_C, derivative_C, map_zero]
rw [map_add, derivative_add, ihp, ihq, derivative_add, map_add]
rw [map_mul, map_C, map_pow, map_X, derivative_mul, derivative_pow_succ, derivative_C, zero_mul, zero_add, derivative_X, mul_one, derivative_mul, derivative_pow_succ, derivative_C, zero_mul, zero_add, derivative_X, mul_one, map_mul, map_C, map_mul, map_pow, map_add, map_nat_cast, map_one, map_X]
rw [H, derivative_zero]
by_cases h01 : (0 : R) = 1
haveI := subsingleton_of_zero_eq_one h01
rw [subsingleton.elim (f /ₘ g) 0, subsingleton.elim f 0, subsingleton.elim g 0, nat_degree_zero]
{ haveI := subsingleton_of_zero_eq_one h01, rw [subsingleton.elim (f /ₘ g) 0, subsingleton.elim f 0, subsingleton.elim g 0, nat_degree_zero] }
haveI : nontrivial R := ⟨⟨0, 1, h01⟩⟩
by_cases hfg : f /ₘ g = 0
rw div_by_monic_eq_zero_iff hg hg.ne_zero at hfg
rw [hfg, nat_degree_zero]
rw nat.sub_eq_zero_of_le (nat_degree_le_nat_degree $ le_of_lt hfg)
{ rw [hfg, nat_degree_zero], rw div_by_monic_eq_zero_iff hg hg.ne_zero at hfg, rw nat.sub_eq_zero_of_le (nat_degree_le_nat_degree $ le_of_lt hfg) }
rw div_by_monic_eq_zero_iff hg hg.ne_zero at hgf
have hgf := hfg
push_neg at hgf
have := degree_add_div_by_monic hg hgf
intro hf
apply hfg
have hf : f ≠ 0
rw [hf, zero_div_by_monic]
{ intro hf, apply hfg, rw [hf, zero_div_by_monic] }
rw [degree_eq_nat_degree hf, degree_eq_nat_degree hg.ne_zero, degree_eq_nat_degree hfg, ← with_bot.coe_add, with_bot.coe_eq_coe] at this
rw [← this, nat.add_sub_cancel_left]
rw [← dvd_iff_mod_by_monic_eq_zero hx, ← dvd_iff_mod_by_monic_eq_zero (monic_map f hx), ← map_mod_by_monic f hx]
rw [H, map_zero]
exact ⟨λ H, map_injective f hf $ by rw [H, map_zero], λ H, by rw [H, map_zero]⟩
rw [H, map_zero]
apply polynomial.induction_on' p
intros p q ph qh
{ intros p q ph qh, simp only [add_mul, eval_add, ph, qh], }
simp only [add_mul, eval_add, ph, qh]
intros n a
simp only [←monomial_one_one_eq_X, monomial_mul_monomial, eval_monomial, mul_one, pow_succ', mul_assoc]
unfold leading_coeff
rw [coeff_map, nat_degree_map_of_leading_coeff_ne_zero f hf]
rw [sub_eq_add_neg, eval₂_add, eval₂_neg, sub_eq_add_neg]
ext x
rw [set.mem_singleton_iff, mem_root_set, aeval_mul, aeval_C, aeval_X_pow, mul_eq_zero]
simp_rw [ring_hom.map_eq_zero, pow_eq_zero_iff (nat.pos_of_ne_zero hn), or_iff_right_iff_imp]
{ simp_rw [ring_hom.map_eq_zero, pow_eq_zero_iff (nat.pos_of_ne_zero hn), or_iff_right_iff_imp], exact λ ha', (ha ha').elim }
exact λ ha', (ha ha').elim
exact mul_ne_zero (mt C_eq_zero.mp ha) (pow_ne_zero n X_ne_zero)
rw [eq_C_of_degree_eq_zero (degree_coe_units u), eq_C_of_degree_eq_zero (degree_coe_units u⁻¹), coeff_C, coeff_C, inv_eq_one_div]
split_ifs
rw [div_eq_iff_mul_eq (coeff_coe_units_zero_ne_zero u), coeff_zero_eq_eval_zero, coeff_zero_eq_eval_zero, ← eval_mul, ← units.coe_mul, inv_mul_self]
rw [div_eq_iff_mul_eq (coeff_coe_units_zero_ne_zero u), coeff_zero_eq_eval_zero, coeff_zero_eq_eval_zero, ← eval_mul, ← units.coe_mul, inv_mul_self]; simp
{ rw [div_eq_iff_mul_eq (coeff_coe_units_zero_ne_zero u), coeff_zero_eq_eval_zero, coeff_zero_eq_eval_zero, ← eval_mul, ← units.coe_mul, inv_mul_self]; simp }
simp
simp
simp only [hasse_deriv_apply, derivative_apply, monomial_eq_C_mul_X, nat.choose_one_right, (nat.cast_commute _ _).eq]
simp [integral_normalization, coeff_monomial, this, mem_support_iff] {contextual := tt}
by_cases Rtrivial : nontrivial R
swap
rw not_nontrivial_iff_subsingleton at Rtrivial
obtain ⟨q, hq⟩ := mem_lifts_and_degree_eq hlifts
use q
exact ⟨hq.1, hq.2, @monic_of_subsingleton _ _ Rtrivial q⟩
{ rw not_nontrivial_iff_subsingleton at Rtrivial, obtain ⟨q, hq⟩ := mem_lifts_and_degree_eq hlifts, use q, exact ⟨hq.1, hq.2, @monic_of_subsingleton _ _ Rtrivial q⟩ }
by_cases er_zero : p.erase_lead = 0
rw [← erase_lead_add_C_mul_X_pow p, er_zero, zero_add, monic.def.1 hmonic, C_1, one_mul]
use X ^ p.nat_degree
split
split
split
repeat {split}
{ simp only [map_pow, map_X] }
simp only [map_pow, map_X]
{ rw [@degree_X_pow R _ Rtrivial, degree_X_pow] }
rw [@degree_X_pow R _ Rtrivial, degree_X_pow]
{ rw [← erase_lead_add_C_mul_X_pow p, er_zero, zero_add, monic.def.1 hmonic, C_1, one_mul], use X ^ p.nat_degree, repeat {split}, { simp only [map_pow, map_X] }, { rw [@degree_X_pow R _ Rtrivial, degree_X_pow] }, {exact monic_pow monic_X p.nat_degree } }
exact monic_pow monic_X p.nat_degree
obtain ⟨q, hq⟩ := mem_lifts_and_degree_eq (erase_mem_lifts p.nat_degree hlifts)
have deg_er : p.erase_lead.nat_degree < p.nat_degree := or.resolve_right (erase_lead_nat_degree_lt_or_erase_lead_eq_zero p) er_zero
replace deg_er := with_bot.coe_lt_coe.2 deg_er
rw [← degree_eq_nat_degree er_zero, erase_lead, ← hq.2, ← @degree_X_pow R _ Rtrivial p.nat_degree] at deg_er
use q + X ^ p.nat_degree
split
split
split
repeat {split}
simp only [hq, map_add, map_pow, map_X]
nth_rewrite 3 [← erase_lead_add_C_mul_X_pow p]
rw [erase_lead, monic.leading_coeff hmonic, C_1, one_mul]
{ simp only [hq, map_add, map_pow, map_X], nth_rewrite 3 [← erase_lead_add_C_mul_X_pow p], rw [erase_lead, monic.leading_coeff hmonic, C_1, one_mul] }
rw [degree_add_eq_right_of_degree_lt deg_er, @degree_X_pow R _ Rtrivial p.nat_degree, degree_eq_nat_degree (monic.ne_zero hmonic)]
{ rw [degree_add_eq_right_of_degree_lt deg_er, @degree_X_pow R _ Rtrivial p.nat_degree, degree_eq_nat_degree (monic.ne_zero hmonic)] }
rw [monic.def, leading_coeff_add_of_degree_lt deg_er]
exact monic_pow monic_X p.nat_degree
simp only [coe_map_ring_hom, lifts, set.mem_range, ring_hom.mem_srange]
rw [p.as_sum_range_C_mul_X_pow, sum_range_succ_comm]
conv_lhs { rw [p.as_sum_range_C_mul_X_pow, sum_range_succ_comm] }
suffices : C (p.coeff p.nat_degree) = 1
{ rw [this, one_mul] }
rw [this, one_mul]
exact congr_arg C hp
ext
rw [reflect_C_mul, coeff_C_mul, coeff_C_mul, coeff_X_pow, coeff_reflect]
split_ifs with h j
{ rw [h, rev_at_invol, coeff_X_pow_self], }
rw [h, rev_at_invol, coeff_X_pow_self]
rw [not_mem_support_iff.mp]
intro a
rw [← one_mul (X ^ n), ← C_1] at a
apply h
rw [← (mem_support_C_mul_X_pow a), rev_at_invol]
simpa [hm.leading_coeff] using eq_X_add_C_of_degree_eq_one hp1
apply quot.ind
intro x
intros a f' f ih
apply q.P.W_ind _ x
change p ⟦q.P.W_mk a f' f⟧
rw [←fix.ind_aux a f' f]
apply h
rw mvqpf.liftp_iff
refine ⟨_, _, rfl, _⟩
intros i j
cases i
{ apply ih }
apply ih
triv
cases y with b g
cases x with a f
induction h
intro h
case qpf.Wequiv.ind : a f f' h ih { exact Wequiv.ind _ _ _ ih }
exact Wequiv.ind _ _ _ ih
case qpf.Wequiv.abs : a f a' f' h { exact Wequiv.abs _ _ _ _ h.symm }
exact Wequiv.abs _ _ _ _ h.symm
case qpf.Wequiv.trans : x y z e₁ e₂ ih₁ ih₂ { exact qpf.Wequiv.trans _ _ _ ih₂ ih₁}
exact qpf.Wequiv.trans _ _ _ ih₂ ih₁
by_cases a ≤ b; simp [h, min_def]
simp [h, min_def]
simp [h, min_def]
by_cases a ≤ b
apply_instance
simpa using lt_iff_le_not_le
intro a
intro a; rw mk_le
rw mk_le
simpa using le_trans
simpa [mk_eq] using @cau_seq.le_antisymm _ _ a b
apply_instance
apply tsum_le_tsum _ (summable_cantor_function f h1 h2) (summable_cantor_function g h1 h2)
cases h : f n
simp [h, cantor_function_aux_nonneg h1]
intro n
simp [h, h3]
replace h3 : g n = tt := h3 n h
rwa const_lim_zero
simp[inv_apply, const_apply]
cases h j ij with h₁ h₂
have := add_le_add h₁ (le_of_lt (abs_lt.1 h₂).1)
rwa [← sub_eq_add_neg, sub_self_div_two] at this
rwa neg_sub at h
rw [mul_comm, mul_div_cancel h0 hI]
lift a to ℝ≥0 using ha
lift b to ℝ≥0 using hb
refl
exact_mod_cast (@one_lt_two ℕ _ _)
apply_instance
apply_instance
rw ←smul_one_smul ℝ≥0 r (s: ℝ≥0∞)
change ↑(r • s) = ↑(r • (1 : ℝ≥0)) * ↑s
rw [←ennreal.coe_mul, smul_mul_assoc, one_mul]
simpa only [lt_top_iff_ne_top] using add_lt_top
simp
simp
simp [(coe_nnreal_lt_top y).ne']
simp [coe_nnreal_eq_coe_real]
simp [real.to_ereal]
unfold_coes
apply add_pos
apply add_pos; norm_num
norm_num
norm_num
split_ifs
unfold st
{ exact classical.some_spec h }
exact classical.some_spec h
unfold st
unfold st; split_ifs; refl
unfold st; split_ifs
split_ifs
refl
exact false.elim (hx (by unfold st; split_ifs; refl))
rwa lt_def
rw mul_comm
rw mul_comm; exact infinite_neg_mul_of_infinite_neg_not_infinitesimal_pos hy hx hp
exact infinite_neg_mul_of_infinite_neg_not_infinitesimal_pos hy hx hp
simp only [not_lt, (set.set_of_eq_eq_singleton).symm]
simp only [not_lt, (set.set_of_eq_eq_singleton).symm]; ext; exact nat.le_zero_iff
simp only [not_lt, (set.set_of_eq_eq_singleton).symm]; ext
ext
exact nat.le_zero_iff
simp only [inv_pos, nat.cast_pos]
exact mem_hyperfilter_of_finite_compl (by convert set.finite_singleton _)
convert set.finite_singleton _
simpa only [sub_eq_add_neg] using h.neg.rat_add q
apply_instance
apply_instance
simp [nnreal.coe_lt_coe.symm, real.to_nnreal, lt_irrefl]
rw [div_eq_inv_mul, ← mul_le_iff_le_inv hr, mul_comm]
refine lt_of_le_of_ne (sign_mul_nonneg r) (λ h, hr _)
have hs0 := (zero_eq_mul.mp h).resolve_right hr
exact sign_eq_zero_iff.mp hs0
simp [sqrt]
ext x y
reflexivity
ext x w
split
unfold comp
exact ⟨y, rxy, z, syz, tzw⟩
rintros ⟨z, ⟨y, rxy, syz⟩, tzw⟩
{ rintros ⟨z, ⟨y, rxy, syz⟩, tzw⟩, exact ⟨y, rxy, z, syz, tzw⟩ }
exact ⟨z, ⟨y, rxy, syz⟩, tzw⟩
rintros ⟨y, rxy, z, syz, tzw⟩
unfold get; rw lift_on_of_mem q _ _ a h; exact h
unfold get; rw lift_on_of_mem q _ _ a h
rw lift_on_of_mem q _ _ a h
exact h
unfold get
funext n
apply subtype.eq
refl
{refl}
induction h : s.val n
exact ⟨⟨_, _, h.symm⟩⟩
refine absurd _ H
have aa := parallel_promises h1 h
have aa := parallel_promises h1 h; rw ←aa; rw ←aa at h; exact let ⟨s, sS, as⟩ := exists_of_mem_parallel h, ⟨t, tT, st⟩ := wseq.exists_of_lift_rel_left H sS, aT := (st _).1 as in mem_parallel h2 tT aT
have aa := parallel_promises h1 h; rw ←aa; rw ←aa at h
have aa := parallel_promises h1 h; rw ←aa
rw ←aa
rw ←aa at h
exact let ⟨s, sS, as⟩ := exists_of_mem_parallel h, ⟨t, tT, st⟩ := wseq.exists_of_lift_rel_left H sS, aT := (st _).1 as in mem_parallel h2 tT aT
have aa := parallel_promises h2 h; rw ←aa; rw ←aa at h; exact let ⟨s, sS, as⟩ := exists_of_mem_parallel h, ⟨t, tT, st⟩ := wseq.exists_of_lift_rel_right H sS, aT := (st _).2 as in mem_parallel h1 tT aT
have aa := parallel_promises h2 h; rw ←aa; rw ←aa at h
have aa := parallel_promises h2 h; rw ←aa
rw ←aa
rw ←aa at h
exact let ⟨s, sS, as⟩ := exists_of_mem_parallel h, ⟨t, tT, st⟩ := wseq.exists_of_lift_rel_right H sS, aT := (st _).2 as in mem_parallel h1 tT aT
have aa := parallel_promises h2 h
apply subtype.eq; simp [of_stream, cons]; rw stream.map_cons
apply subtype.eq; simp [of_stream, cons]
simp [of_stream, cons]
rw stream.map_cons
apply subtype.eq
simp [ret_mem]
rw [lift_rel_destruct_iff]; simp
simp
rw [lift_rel_destruct_iff]
rw [lift_rel_destruct_iff, lift_rel_destruct_iff]
rw [lift_rel_destruct_iff, lift_rel_destruct_iff]; simp
simp
simp
apply computation.mem_rec_on h
{ simp }
apply equiv.trans
simp [think_equiv]
intro s'
refine lift_rel_def.2 ⟨_, _⟩
rw [←head_terminates_iff, ←head_terminates_iff]
{ rw [←head_terminates_iff, ←head_terminates_iff], exact terminates_congr (h 0) }
exact terminates_congr (h 0)
intros a b ma mb
cases a with a; cases b with b
cases b with b
cases b with b
cases a with a
{ trivial }
trivial
{ injection mem_unique (mem_map _ ma) ((h 0 _).2 (mem_map _ mb)) }
injection mem_unique (mem_map _ ma) ((h 0 _).2 (mem_map _ mb))
{ injection mem_unique (mem_map _ ma) ((h 0 _).2 (mem_map _ mb)) }
injection mem_unique (mem_map _ ma) ((h 0 _).2 (mem_map _ mb))
cases b with b t'
cases a with a s'
injection mem_unique (mem_map _ ma) ((h 0 _).2 (mem_map _ mb)) with ab
refine ⟨ab, λ n, _⟩
refine (nth_congr (flatten_equiv (mem_map _ ma)) n).symm.trans ((_ : nth (tail s) n ~ nth (tail t) n).trans (nth_congr (flatten_equiv (mem_map _ mb)) n))
apply h
rw [nth_tail, nth_tail]
rintro ⟨a, h|h, rfl⟩
rintro ⟨a, h|h, rfl⟩; [left, right]; exact ⟨_, h, rfl⟩
rintro ⟨a, h|h, rfl⟩; [left, right]
left
right
exact ⟨_, h, rfl⟩
exact ⟨_, h, rfl⟩
rintro (⟨a, h, rfl⟩ | ⟨a, h, rfl⟩); refine ⟨_, _, rfl⟩; [left, right]; exact h
rintro (⟨a, h, rfl⟩ | ⟨a, h, rfl⟩); refine ⟨_, _, rfl⟩; [left, right]
rintro (⟨a, h, rfl⟩ | ⟨a, h, rfl⟩); refine ⟨_, _, rfl⟩
refine ⟨_, _, rfl⟩
refine ⟨_, _, rfl⟩
left
right
rintro (⟨a, h, rfl⟩ | ⟨a, h, rfl⟩)
exact h
exact h
simp [diagonal, eq_comm]
ext ⟨x, y⟩
ext
simp only [range_factorization_coe]
apply apply_range_splitting
ext f
split
split
split; { rintros i ⟨his, hpi⟩, simpa [*] using h i }
rintros i ⟨his, hpi⟩
simpa [*] using h i
assume h
{ assume h, split; { rintros i ⟨his, hpi⟩, simpa [*] using h i } }
rintros ⟨ht₁, ht₂⟩ i his
by_cases p i; simp * at *
simp * at *
simp * at *
by_cases p i
rw update_noteq
exact λ h, hi (h ▸ hj)
rw [union_diff_self, union_eq_self_of_subset_left (singleton_subset_iff.2 hi)]
simp
rw [union_pi, singleton_pi', update_same, pi_update_of_not_mem]
split
ext x
convert h i hi
simp
{ intro h, convert h i hi, simp }
intro h
by_cases h : j = i
intros hx j hj
simpa
{ cases h, simpa }
cases h
exact hf j hj h
rw [update_noteq h]
refine ⟨λ h y, _, surjective.preimage_injective⟩
obtain ⟨x, hx⟩ : (f ⁻¹' {y}).nonempty
apply singleton_nonempty
rw [h.nonempty_apply_iff preimage_empty]
{ rw [h.nonempty_apply_iff preimage_empty], apply singleton_nonempty }
exact ⟨x, hx⟩
exact ⟨_, _, (mem_prod.mp ‹_›).1, (mem_prod.mp ‹_›).2, rfl⟩
rintros ⟨_, _, rfl⟩
exact ⟨(_, _), mem_prod.mpr ⟨‹_›, ‹_›⟩, rfl⟩
rintros ⟨_, _, _, _, rfl⟩
rw [ssubset_iff_subset_ne, subset_singleton_iff_eq, or_and_distrib_right, and_not_self, or_false, and_iff_left_iff_imp]
rintro rfl
refine ne_comm.1 (ne_empty_iff_nonempty.2 (singleton_nonempty _))
rw [fintype_insert', fintype.card_of_finset]; simp [finset.card, to_finset]; refl
rw [fintype_insert', fintype.card_of_finset]; simp [finset.card, to_finset]
rw [fintype_insert', fintype.card_of_finset]
refl
simp [finset.card, to_finset]
simp [(@equiv.plift ι).exists_congr_left]
haveI := classical.dec_eq α; exact ⟨by apply_instance⟩
exact ⟨by apply_instance⟩
apply_instance
haveI := classical.dec_eq α
rw [← finset.coe_sort_coe _, h.coe_to_finset]
intro x
simp [nat.lt_succ_iff, nat.find_greatest_le]
rw range_subset_iff
rw [Ioc_union_Ioc, max_self]; exact (min_le_right _ _).trans (le_max_right _ _)
exact (min_le_right _ _).trans (le_max_right _ _)
exact (min_le_right _ _).trans (le_max_right _ _)
rw [Ioc_union_Ioc, max_self]
classical
by_cases ha : a ∈ s; by_cases hb : b ∈ s
by_cases hb : b ∈ s
by_cases hb : b ∈ s
by_cases ha : a ∈ s
refine or.inl (subset.antisymm hc _)
rwa [← Ico_diff_left, diff_singleton_subset_iff, insert_eq_of_mem ha, ← Icc_diff_right, diff_singleton_subset_iff, insert_eq_of_mem hb] at ho
{ refine or.inl (subset.antisymm hc _), rwa [← Ico_diff_left, diff_singleton_subset_iff, insert_eq_of_mem ha, ← Icc_diff_right, diff_singleton_subset_iff, insert_eq_of_mem hb] at ho }
refine (or.inr $ or.inl $ subset.antisymm _ _)
rw [← Icc_diff_right]
{ rw [← Icc_diff_right], exact subset_diff_singleton hc hb }
exact subset_diff_singleton hc hb
rwa [← Ico_diff_left, diff_singleton_subset_iff, insert_eq_of_mem ha] at ho
{ refine (or.inr $ or.inl $ subset.antisymm _ _), { rw [← Icc_diff_right], exact subset_diff_singleton hc hb }, { rwa [← Ico_diff_left, diff_singleton_subset_iff, insert_eq_of_mem ha] at ho } }
refine (or.inr $ or.inr $ or.inl $ subset.antisymm _ _)
rw [← Icc_diff_left]
{ rw [← Icc_diff_left], exact subset_diff_singleton hc ha }
exact subset_diff_singleton hc ha
rwa [← Ioc_diff_right, diff_singleton_subset_iff, insert_eq_of_mem hb] at ho
{ refine (or.inr $ or.inr $ or.inl $ subset.antisymm _ _), { rw [← Icc_diff_left], exact subset_diff_singleton hc ha }, { rwa [← Ioc_diff_right, diff_singleton_subset_iff, insert_eq_of_mem hb] at ho } }
refine (or.inr $ or.inr $ or.inr $ subset.antisymm _ ho)
rw [← Ico_diff_left, ← Icc_diff_right]
apply_rules [subset_diff_singleton]
have := @mem_Ioo_or_eq_left_of_mem_Ico (order_dual α) _ b a x
rw [dual_Ioo, dual_Ico] at this
exact this hmem
rw [Ico_disjoint_Ico, min_eq_left (le_of_lt h2.2), le_max_iff] at h
apply le_antisymm h2.1
exact h.elim (λ h, absurd hx (not_lt_of_le h)) id
simp [← Ici_inter_Iio, ← Ioi_inter_Iic, inter_comm]
simp [← Ioi_inter_Iic, ← Ici_inter_Iio, inter_comm]
simp [← Ioi_inter_Iic, ← Ici_inter_Iio, inter_comm]
simp [add_comm]
simp
convert image_mul_right_Icc hbc ha using 1; simp only [mul_comm _ a]
simp only [mul_comm _ a]
simp only [mul_comm _ a]
convert image_mul_right_Icc hbc ha using 1
simpa only [ord_connected_def] using h.dual
simp
ext ⟨a, b⟩
split
exact ⟨prod.mk a, ⟨a, ha, rfl⟩, b, hb, rfl⟩
rintro ⟨ha, hb⟩
{ rintro ⟨ha, hb⟩, exact ⟨prod.mk a, ⟨a, ha, rfl⟩, b, hb, rfl⟩ }
rw ← eq
exact ⟨hx, hy⟩
rintro ⟨f, ⟨x, hx, rfl⟩, y, hy, eq⟩
refine (ht _ x.2 _ y.2 _).mono (hf x) (hf y)
rintro _ ⟨x, rfl⟩ _ ⟨y, rfl⟩ hxy
apply hxy
apply congr_arg f
intro h
exact subtype.eq h
simp
simp [← ne_empty_iff_nonempty]
rw [bInter_eq_Inter, bInter_eq_Inter, union_distrib_Inter_right]
rw eqv_gen_eq
apply congr_arg Inf
simp only [le_def, or_imp_distrib, ← forall_and_distrib]
rw [subtype.ext_iff_val, ←classes_mk_classes x.1 x.2, ←classes_mk_classes y.1 y.2, h]
exact string_imp.mk.inj hl.symm
cases hl : l.as_string
simp [← multiset.coe_eq_coe, ← multiset.cons_coe, multiset.cons_eq_cons]
simp [← multiset.coe_eq_coe, ← multiset.cons_coe, multiset.cons_eq_cons]; tidy
tidy
intro h
cases h
cases h; rw [h.1, h.2]
rw [h.1, h.2]
rw [h.1, h.2]
apply list.perm.swap'
refl
tidy
tidy; apply rel.trans; assumption
tidy; apply rel.trans
apply rel.trans
assumption
assumption
rw [← elim_of_mem hl, hvw, elim_of_mem hl]
rw [← elim_self v, hvw, elim_self]
ext
refine ext (nodup_cons.mp hl).2 (λ j hj, _)
rw [← comp_assoc,to_subtype_of_subtype]; simp
simp
rw [← comp_assoc,to_subtype_of_subtype]
simp [vector.reverse]
cases v
induction n with n ih generalizing u v w
rcases v with ⟨_|⟨-,-⟩,-|-⟩
rcases u with ⟨_|⟨-,-⟩,-|-⟩
rcases w with ⟨_|⟨-,-⟩,-|-⟩
{ rcases u with ⟨_|⟨-,-⟩,-|-⟩, rcases v with ⟨_|⟨-,-⟩,-|-⟩, rcases w with ⟨_|⟨-,-⟩,-|-⟩, exact h_nil, }
exact h_nil
rcases u with ⟨_|⟨a,u⟩,_⟩
cases u_property
rcases v with ⟨_|⟨b,v⟩,_⟩
cases v_property
rcases w with ⟨_|⟨c,w⟩,_⟩
cases w_property
apply @h_cons n _ _ _ ⟨u, (add_left_inj 1).mp u_property⟩ ⟨v, (add_left_inj 1).mp v_property⟩ ⟨w, (add_left_inj 1).mp w_property⟩
apply ih
casesI n
exact nat.not_lt_zero 0 (fact.out _)
{ exfalso, exact nat.not_lt_zero 0 (fact.out _) }
exfalso
exact fin.is_lt a
rwa [← h, ← not_lt, not_iff_self] at this
casesI n
exact nat.not_lt_zero 0 (fact.out (0 < 0))
{ exfalso, exact nat.not_lt_zero 0 (fact.out (0 < 0)) }
exfalso
refl
rintros _ _ ⟨p, hp, q, hq, hq0, rfl⟩ ⟨r, hr, s, hs, hs0, rfl⟩
rintros _ _ ⟨p, hp, q, hq, hq0, rfl⟩ ⟨r, hr, s, hs, hs0, rfl⟩; exact ⟨p * r, is_submonoid.mul_mem ring.closure.is_subring.to_is_submonoid hp hr, q * s, is_submonoid.mul_mem ring.closure.is_subring.to_is_submonoid hq hs, (div_mul_div _ _ _ _).symm⟩
exact ⟨p * r, is_submonoid.mul_mem ring.closure.is_subring.to_is_submonoid hp hr, q * s, is_submonoid.mul_mem ring.closure.is_subring.to_is_submonoid hq hs, (div_mul_div _ _ _ _).symm⟩
ext x
simp [coe_pow n, pow_succ']
rw [dist_comm, real.dist_eq, abs_lt, lt_sub_iff_add_lt', sub_lt_iff_lt_add', ← sub_eq_add_neg]
exact ⟨f.lt_map_map_zero g, f.map_map_zero_lt g⟩
have : 0 < (2^(n+1):ℝ) := pow_pos zero_lt_two _
rw [div_div_eq_div_mul, ← pow_succ, ← abs_of_pos this]
replace := abs_pos.2 (ne_of_gt this)
convert (div_lt_div_right this).2 ((f^(2^n)).dist_map_map_zero_lt (f^(2^n)))
simp_rw [transnum_aux_seq, real.dist_eq]
rw [← abs_div, sub_div, pow_succ', pow_succ, ← two_mul, mul_div_mul_left _ _ (@two_ne_zero ℝ _ _), pow_mul, sq, mul_apply]
refine (tendsto_iff_dist_tendsto_zero.2 $ squeeze_zero (λ _, dist_nonneg) (λ n, _) ((tendsto_const_div_at_top_nhds_0_nat 1).comp (tendsto_add_at_top_nat 1)))
dsimp
have : (0:ℝ) < n + 1 := n.cast_add_one_pos
rw [real.dist_eq, div_sub' _ _ _ (ne_of_gt this), abs_div, ← real.dist_eq, abs_of_pos this, div_le_div_right this, ← nat.cast_add_one]
apply dist_pow_map_zero_mul_translation_number_le
simp only [frequently_at_top, @forall_swap (_ ∈ s), ae_all_iff]
intro n
filter_upwards [measure_zero_iff_ae_nmem.1 (hf.measure_mem_forall_ge_image_not_mem_eq_zero hs n)]
simp
rw [← map_map hg.1 hf.1, hf.2, hg.2]
simp [image_image, ← map_add]
apply nat.eq_prime_pow_of_dvd_least_prime_pow hp.out
apply nat.eq_prime_pow_of_dvd_least_prime_pow hp.out; rwa ← is_periodic_pt_iff_minimal_period_dvd
rwa ← is_periodic_pt_iff_minimal_period_dvd
rwa ← is_periodic_pt_iff_minimal_period_dvd
apply_instance
intros x hx
cases hx with f hf
rw ← hf
exact adjoin.algebra_map_mem F S f
rwa zmod.card p at h
have h := finite_field.pow_card x
rwa zmod.card p at h
have h := finite_field.expand_card f
simpa only [dim_R] using cardinal.nat_lt_omega (fintype.card (σ → K))
exact prod_X_sub_smul.monic G F x
simp only [minpoly, polynomial.monic_to_subring]
rw [hx, hx]
ext
refl
ext
refl
ext
refl
cases field.exists_primitive_element F E with α h1
use [minpoly F α, separable F α, is_galois.splits F α]
rw [eq_top_iff, ←intermediate_field.top_to_subalgebra, ←h1]
rw intermediate_field.adjoin_simple_to_subalgebra_of_integral F α (integral F α)
apply algebra.adjoin_mono
rw [set.singleton_subset_iff, finset.mem_coe, multiset.mem_to_finset, polynomial.mem_roots]
dsimp only [polynomial.is_root]
rw [polynomial.eval_map, ←polynomial.aeval_def]
{ dsimp only [polynomial.is_root], rw [polynomial.eval_map, ←polynomial.aeval_def], exact minpoly.aeval _ _ }
exact minpoly.aeval _ _
exact polynomial.map_ne_zero (minpoly.ne_zero (integral F α))
simp only [← gsmul_one, gsmul_mem, one_mem]
rw [← is_scalar_tower.aeval_apply, minpoly.aeval]
refine minpoly.dvd K x _
split
intro h
have zero_root := zero_is_root_of_coeff_zero_eq_zero h
rw ← root hx zero_root
{ intro h, have zero_root := zero_is_root_of_coeff_zero_eq_zero h, rw ← root hx zero_root, exact ring_hom.map_zero _ }
exact ring_hom.map_zero _
simp
rintro rfl
conv_lhs { rw [hg3, ← hu] }
rw [hg3, ← hu]
rwa units.mul_right_dvd
rw [separable_iff_derivative_ne_zero hf, not_not, H]
haveI := is_local_ring_hom_expand F hp.1.pos; exact of_irreducible_map ↑(expand F p) (by rwa ← expand_contract p H at hf)
exact of_irreducible_map ↑(expand F p) (by rwa ← expand_contract p H at hf)
haveI := is_local_ring_hom_expand F hp.1.pos
rwa ← expand_contract p H at hf
contrapose! hq
apply is_unit_of_self_mul_dvd_separable hsep
rw ← sq
apply multiplicity.pow_dvd_of_le_multiplicity
simpa only [nat.cast_one, nat.cast_bit0] using enat.add_one_le_of_lt hq
rw [root_multiplicity_eq_multiplicity, dif_neg hp, ← enat.coe_le_coe, enat.coe_get, nat.cast_one]
exact multiplicity_le_one_of_separable (not_unit_X_sub_C _) hsep
apply polynomial.eq_X_sub_C_of_splits_of_single_root i h_splits
apply finset.mk.inj
change _ = {i x}
rw finset.eq_singleton_iff_unique_mem
split
apply finset.mem_mk.mpr
exact map_ne_zero h_ne_zero
rw mem_roots (show h.map i ≠ 0, by exact map_ne_zero h_ne_zero)
rw [is_root.def,←eval₂_eq_eval_map,eval₂_hom,h_root]
{ apply finset.mem_mk.mpr, rw mem_roots (show h.map i ≠ 0, by exact map_ne_zero h_ne_zero), rw [is_root.def,←eval₂_eq_eval_map,eval₂_hom,h_root], exact ring_hom.map_zero i }
exact ring_hom.map_zero i
{ change _ = {i x}, rw finset.eq_singleton_iff_unique_mem, split, { apply finset.mem_mk.mpr, rw mem_roots (show h.map i ≠ 0, by exact map_ne_zero h_ne_zero), rw [is_root.def,←eval₂_eq_eval_map,eval₂_hom,h_root], exact ring_hom.map_zero i }, { exact h_roots } }
exact h_roots
exact nodup_roots (separable.map h_sep)
letI : algebra E E' := ring_hom.to_algebra f.to_ring_hom
haveI : is_scalar_tower F E E' := is_scalar_tower.of_algebra_map_eq (λ x, (f.commutes x).symm)
exact is_separable_tower_bot_of_is_separable F E E'
refine ⟨λ h, _, inner_eq_neg_mul_norm_of_angle_eq_pi⟩
have h₁ : (∥x∥ * ∥y∥) ≠ 0 := (mul_pos (norm_pos_iff.mpr hx) (norm_pos_iff.mpr hy)).ne'
rw [angle, h, neg_div, div_self h₁, real.arccos_neg_one]
rw [← sq_eq_sq (norm_nonneg (x + y)) (norm_nonneg (x - y)), ← inner_eq_zero_iff_angle_eq_pi_div_two x y, norm_add_pow_two_real, norm_sub_pow_two_real]
intro h
intro h
linarith
linarith
split
split; intro h; linarith
split; intro h
rw [dist_eq_norm_vsub V _ p₂, ←real_inner_self_eq_norm_sq, vadd_vsub_assoc, real_inner_add_add_self, real_inner_smul_left, real_inner_smul_left, real_inner_smul_right]
ring
intro i
rw dist_comm
exact dist_circumcenter_eq_circumradius _ _
have h := s.circumcenter_circumradius_unique_dist_eq.2 (p, r)
simp only [hp, hr, forall_const, eq_self_iff_true, and_self, prod.ext_iff] at h
exact h.2
convert sum_ite_eq' univ circumcenter_index (function.const _ (1 : ℝ))
ext ⟨j⟩ ; simp [circumcenter_weights_with_circumcenter]
simp [circumcenter_weights_with_circumcenter]
simp [circumcenter_weights_with_circumcenter]
ext ⟨j⟩
{ ext ⟨j⟩ ; simp [circumcenter_weights_with_circumcenter] }
{ simp }
simp
rw ←points_with_circumcenter_eq_circumcenter
symmetry
refine affine_combination_of_eq_one_of_eq_zero _ _ _ (mem_univ _) rfl _
rintros ⟨i⟩ hi hn ; tauto
tauto
tauto
rintros ⟨i⟩ hi hn
simp_rw [sum_points_with_circumcenter, monge_point_weights_with_circumcenter, sum_const, card_fin, nsmul_eq_mul]
have hn1 : (n + 1 : ℝ) ≠ 0
{ exact_mod_cast nat.succ_ne_zero _ }
exact_mod_cast nat.succ_ne_zero _
field_simp [hn1]
ring
rw [←mul_self_inj_of_nonneg dist_nonneg t.circumradius_nonneg, t.reflection_circumcenter_eq_affine_combination_of_points_with_circumcenter h, t.orthocenter_eq_monge_point, monge_point_eq_affine_combination_of_points_with_circumcenter, dist_affine_combination t.points_with_circumcenter (sum_monge_point_weights_with_circumcenter _) (sum_reflection_circumcenter_weights_with_circumcenter h)]
simp_rw [sum_points_with_circumcenter, pi.sub_apply, monge_point_weights_with_circumcenter, reflection_circumcenter_weights_with_circumcenter]
have hu : ({i₁, i₂} : finset (fin 3)) ⊆ univ := subset_univ _
obtain ⟨i₃, hi₃, hi₃₁, hi₃₂⟩ : ∃ i₃, univ \ ({i₁, i₂} : finset (fin 3)) = {i₃} ∧ i₃ ≠ i₁ ∧ i₃ ≠ i₂
dec_trivial!
simp_rw [←sum_sdiff hu, hi₃]
simp [hi₃₁, hi₃₂]
norm_num
exact ((smooth_mul I).comp (hf.prod_mk hg.inv) : _)
rw div_eq_mul_inv
simp only with mfld_simps
unfold_coes
split
intro Hfh
rw [← h.symm_apply_apply x] at Hfh
simpa only [(∘), h.apply_symm_apply] using Hfh.comp (h x) (h.symm.times_cont_mdiff_within_at.of_le hm) (maps_to_preimage _ _)
{ intro Hfh, rw [← h.symm_apply_apply x] at Hfh, simpa only [(∘), h.apply_symm_apply] using Hfh.comp (h x) (h.symm.times_cont_mdiff_within_at.of_le hm) (maps_to_preimage _ _) }
rw ← h.image_eq_preimage
exact λ hf, hf.comp x (h.times_cont_mdiff_within_at.of_le hm) (maps_to_image _ _)
simp
simp [range_comp e, I.unique_diff]
ext
simp only [stereo_to_fun_apply, stereo_inv_fun_apply, smul_add]
set a : ℝ := inner_right v x
set y := orthogonal_projection (ℝ ∙ v)ᗮ x
have split : ↑x = a • v + ↑y
convert eq_sum_orthogonal_projection_self_orthogonal_complement (ℝ ∙ v) x
exact (orthogonal_projection_unit_singleton ℝ hv x).symm
{ convert eq_sum_orthogonal_projection_self_orthogonal_complement (ℝ ∙ v) x, exact (orthogonal_projection_unit_singleton ℝ hv x).symm }
have hvy : ⟪v, y⟫_ℝ = 0 := inner_right_of_mem_orthogonal_singleton v y.2
have pythag : 1 = a ^ 2 + ∥y∥ ^ 2
simp [inner_smul_left, hvy]
have hvy' : ⟪a • v, y⟫_ℝ = 0 := by simp [inner_smul_left, hvy]
convert norm_add_sq_eq_norm_sq_add_norm_sq_of_inner_eq_zero _ _ hvy' using 2
{ simp [← split] }
simp [← split]
{ simp [norm_smul, hv, real.norm_eq_abs, ← sq, sq_abs] }
simp [norm_smul, hv, real.norm_eq_abs, ← sq, sq_abs]
{ have hvy' : ⟪a • v, y⟫_ℝ = 0 := by simp [inner_smul_left, hvy], convert norm_add_sq_eq_norm_sq_add_norm_sq_of_inner_eq_zero _ _ hvy' using 2, { simp [← split] }, { simp [norm_smul, hv, real.norm_eq_abs, ← sq, sq_abs] }, { exact sq _ } }
exact sq _
have ha : 1 - a ≠ 0
have : a < 1 := (inner_lt_one_iff_real_of_norm_one hv (by simp)).mpr hx.symm
simp
{ have : a < 1 := (inner_lt_one_iff_real_of_norm_one hv (by simp)).mpr hx.symm, linarith }
linarith
have : 2 ^ 2 * ∥y∥ ^ 2 + 4 * (1 - a) ^ 2 ≠ 0
refine ne_of_gt _
have := norm_nonneg (y:E)
have : 0 < (1 - a) ^ 2 := sq_pos_of_ne_zero (1 - a) ha
{ refine ne_of_gt _, have := norm_nonneg (y:E), have : 0 < (1 - a) ^ 2 := sq_pos_of_ne_zero (1 - a) ha, nlinarith }
nlinarith
have h₁ : (2 ^ 2 / (1 - a) ^ 2 * ∥y∥ ^ 2 + 4)⁻¹ * 4 * (2 / (1 - a)) = 1
field_simp
{ field_simp, nlinarith }
nlinarith
have h₂ : (2 ^ 2 / (1 - a) ^ 2 * ∥y∥ ^ 2 + 4)⁻¹ * (2 ^ 2 / (1 - a) ^ 2 * ∥y∥ ^ 2 - 4) = a
field_simp
transitivity (1 - a) ^ 2 * (a * (2 ^ 2 * ∥y∥ ^ 2 + 4 * (1 - a) ^ 2))
congr
{ congr, nlinarith }
nlinarith
ring
{ field_simp, transitivity (1 - a) ^ 2 * (a * (2 ^ 2 * ∥y∥ ^ 2 + 4 * (1 - a) ^ 2)), { congr, nlinarith }, ring_nf, ring }
ring_nf
convert congr_arg2 has_add.add (congr_arg (λ t, t • (y:E)) h₁) (congr_arg (λ t, t • v) h₂) using 1
simp [inner_add_right, inner_smul_right, hvy, real_inner_self_eq_norm_sq, hv, mul_smul, mul_pow, real.norm_eq_abs, sq_abs, norm_smul]
{ simp [inner_add_right, inner_smul_right, hvy, real_inner_self_eq_norm_sq, hv, mul_smul, mul_pow, real.norm_eq_abs, sq_abs, norm_smul] }
simp [split, add_comm]
simp
have := unique_mdiff_within_at.inter (unique_mdiff_within_at_univ I) (is_open.mem_nhds hs xs)
rwa univ_inter at this
simp only [set.pi_univ] with mfld_simps
simp
apply le_antisymm le_top
assume u hu
change u ∈ times_cont_diff_groupoid 0 I
rw [times_cont_diff_groupoid, mem_groupoid_of_pregroupoid]
simp only [times_cont_diff_on_zero]
split
apply continuous_on.comp (@continuous.continuous_on _ _ _ _ _ univ I.continuous) _ (subset_univ _)
apply continuous_on.comp u.continuous_to_fun I.continuous_symm.continuous_on (inter_subset_left _ _)
{ apply continuous_on.comp (@continuous.continuous_on _ _ _ _ _ univ I.continuous) _ (subset_univ _), apply continuous_on.comp u.continuous_to_fun I.continuous_symm.continuous_on (inter_subset_left _ _) }
apply continuous_on.comp (@continuous.continuous_on _ _ _ _ _ univ I.continuous) _ (subset_univ _)
apply continuous_on.comp u.continuous_inv_fun I.continuous_inv_fun.continuous_on (inter_subset_left _ _)
refine (times_cont_mdiff_within_at_iff' h (mem_chart_source _ _)).2 _
refine ⟨(ext_chart_at_continuous_at' _ _ _).continuous_within_at, _⟩
{ rwa ext_chart_at_source }
rwa ext_chart_at_source
refine times_cont_diff_within_at_id.congr' _ _
refine times_cont_diff_within_at_id.congr' _ _; simp only [h] with mfld_simps { contextual := tt }
simp only [h] with mfld_simps { contextual := tt }
simp only [h] with mfld_simps { contextual := tt }
simp [← times_cont_mdiff_within_at_univ, times_cont_mdiff_within_at_iff_times_cont_mdiff_on_nhds, nhds_within_univ]
simp [eq.symm, hb]
simp
simp_rw ←left_coset_eq_iff
exact left_coset_equivalence_rel s
rw ← fintype.card_prod; exact fintype.card_congr (subgroup.group_equiv_quotient_times_subgroup)
rw ← fintype.card_prod
exact fintype.card_congr (subgroup.group_equiv_quotient_times_subgroup)
rw [singleton_iff] at h₁; subst L'; assumption
rw [singleton_iff] at h₁; subst L'
subst L'
assumption
rw [singleton_iff] at h₁
simp [function.comp, map.comp]
simp [function.comp, map.comp]
rintros ⟨m, w, h⟩ ⟨m', w', h'⟩ he
by_cases hm : m = 1; by_cases hm' : m' = 1
by_cases hm : m = 1
by_cases hm' : m' = 1
by_cases hm' : m' = 1
cc
{ simp only [rcons, dif_pos hm, dif_pos hm'] at he, cc, }
simp only [rcons, dif_pos hm, dif_pos hm'] at he
simp only [rcons, dif_pos hm, dif_neg hm'] at he
exfalso
rw he at h
exact h rfl
{ exfalso, simp only [rcons, dif_pos hm, dif_neg hm'] at he, rw he at h, exact h rfl }
simp only [rcons, dif_pos hm', dif_neg hm] at he
exfalso
rw ←he at h'
exact h' rfl
{ exfalso, simp only [rcons, dif_pos hm', dif_neg hm] at he, rw ←he at h', exact h' rfl, }
have : m = m' ∧ w.to_list = w'.to_list
simpa only [rcons, dif_neg hm, dif_neg hm', true_and, eq_self_iff_true, subtype.mk_eq_mk, heq_iff_eq, ←subtype.ext_iff_val] using he
{ simpa only [rcons, dif_neg hm, dif_neg hm', true_and, eq_self_iff_true, subtype.mk_eq_mk, heq_iff_eq, ←subtype.ext_iff_val] using he }
rcases this with ⟨rfl, h⟩
exact word.ext _ _ h
congr
rwa [mul_action.mul_smul, hx]
to_rhs
rw [← hy, ← mul_one y, ← inv_mul_self x, ← mul_assoc, mul_action.mul_smul, hx]
conv {to_rhs, rw [← hy, ← mul_one y, ← inv_mul_self x, ← mul_assoc, mul_action.mul_smul, hx]}
exact (set.mem_Inter.1 hx g : _)
haveI := comp α g; haveI := comp β g; exact is_scalar_tower N α β
haveI := comp α g; haveI := comp β g
haveI := comp β g
exact is_scalar_tower N α β
haveI := comp α g
exact {smul_assoc := λ n, @smul_assoc _ _ _ _ _ _ _ (g n) }
split_ifs; refl
refl
refl
split_ifs
rw [← smul_add, neg_add_self, smul_zero]
refine {to_fun := coe, ..}; simp [coe_smul]
simp [coe_smul]
refine {to_fun := coe, ..}
ext
simp
ext
simp
cases f; cases g; simp only; exact funext h
cases f; cases g; simp only
cases f; cases g
cases g
simp only
exact funext h
cases f
rw [mul_assoc, mul_comm _ (f.to_map y), ←mul_assoc, mul_inv_left, mul_comm]
rw [tree_hom, unique.default_eq]
specialize descending_central_series_ge_lower n
apply (general_commutator_le _ _ _).2
intros x hx q _
exact hH.2 x n (descending_central_series_ge_lower hx) q
induction n with d hd
{ simp [nat.nat_zero_eq_zero] }
simp [nat.nat_zero_eq_zero]
rintros a ⟨x, hx : x ∈ lower_central_series G d.succ, rfl⟩
simp [f.map_one, subgroup.one_mem _]
refine closure_induction hx _ (by simp [f.map_one, subgroup.one_mem _]) (λ y z hy hz, by simp [monoid_hom.map_mul, subgroup.mul_mem _ hy hz]) (λ y hy, by simp [f.map_inv, subgroup.inv_mem _ hy])
simp [monoid_hom.map_mul, subgroup.mul_mem _ hy hz]
simp [f.map_inv, subgroup.inv_mem _ hy]
rintros a ⟨y, hy, z, ⟨-, rfl⟩⟩
apply mem_closure.mpr
simp
exact λ K hK, hK ⟨f y, hd (mem_map_of_mem f hy), by simp⟩
convert is_periodic_pt_minimal_period ((*) x) _
rw [order_of, mul_left_iterate, mul_one]
haveI : fact (prime 2) := ⟨prime_two⟩
exact order_of_eq_prime (int.units_mul_self _) dec_trivial
rw [set.mem_to_finset, set_like.mem_coe, mem_gmultiples_iff_mem_range_add_order_of]
ext x
rw [hσ.cycle_type, hσ.inv.cycle_type, support_inv]
rw [mul_inv_rev, hστ.cycle_type, ←hσ, ←hτ, add_comm, disjoint.cycle_type (λ x, or.imp (λ h : τ x = x, inv_eq_iff_eq.mpr h.symm) (λ h : σ x = x, inv_eq_iff_eq.mpr h.symm) (hστ x).symm)]
ext
simp only [mem_map_equiv, perm.coe_mul, comp_app, ne.def, perm.mem_support, equiv.eq_symm_apply]
refl
split
rintro ⟨k, rfl⟩
use (k + n)
{ rintro ⟨k, rfl⟩, use (k + n), simp [gpow_add] }
simp [gpow_add]
rintro ⟨k, rfl⟩
use (k - n)
rw [←gpow_coe_nat, ←mul_apply, ←gpow_add, int.sub_add_cancel]
intros y hy
rw [mem_support, cycle_of_apply] at hy
split_ifs at hy
{ exact mem_support.mpr hy }
exact mem_support.mpr hy
exact absurd rfl hy
simp only [inv_eq_iff_eq, *, forall_prop_of_true, ne.def] at *
cc
simp only [inv_eq_iff_eq, *, forall_prop_of_true, ne.def] at *
cc
rwa [gpow_neg, inv_gpow, inv_inv]
simp [cycle_factors_finset_eq_finset]
cases n
{ simp }
simp
have : j = (fin.cast_le (nat.succ_le_of_lt i.is_lt)).to_embedding ⟨j, lt_of_le_of_lt h (nat.lt_succ_self i)⟩
{ simp }
simp
ext
rw [this, cycle_range, of_left_inverse'_eq_of_injective, ←function.embedding.to_equiv_range_eq_of_injective, ←via_fintype_embedding, via_fintype_embedding_apply_image, rel_embedding.coe_fn_to_embedding, coe_cast_le, coe_fin_rotate]
simp only [fin.ext_iff, coe_last, coe_mk, coe_zero, fin.eta, apply_ite coe, cast_le_mk]
split_ifs with heq
{ refl }
refl
rw fin.coe_add_one_of_lt
exact lt_of_lt_of_le (lt_of_le_of_ne h (mt (congr_arg coe) heq)) (le_last i)
rw [is_three_cycle, cycle_type_cycle_range]
rw [is_three_cycle, cycle_type_cycle_range]; dec_trivial
dec_trivial
dec_trivial
simp [equiv.perm.decompose_fin]
unfold sign_bij_aux at h
rw mem_fin_pairs_lt at *
have : ¬b₁ < b₂ := hb.le.not_lt
split_ifs at h; simp only [*, (equiv.injective f).eq_iff, eq_self_iff_true, and_self, heq_iff_eq] at *
split_ifs at h
simp only [*, (equiv.injective f).eq_iff, eq_self_iff_true, and_self, heq_iff_eq] at *
simp only [*, (equiv.injective f).eq_iff, eq_self_iff_true, and_self, heq_iff_eq] at *
simp only [*, (equiv.injective f).eq_iff, eq_self_iff_true, and_self, heq_iff_eq] at *
simp only [*, (equiv.injective f).eq_iff, eq_self_iff_true, and_self, heq_iff_eq] at *
simp [subtype_congr]
induction n with n ih
{ refl }
refl
rw [pow_succ, perm.mul_apply, apply_mem_support, ih]
simp only [mem_support, swap_apply_def, mul_apply, f.injective.eq_iff] at *
by_cases h : f y = x
split; intro; simp only [*, if_true, eq_self_iff_true, not_true, ne.def] at *
split; intro
intro
intro
simp only [*, if_true, eq_self_iff_true, not_true, ne.def] at *
simp only [*, if_true, eq_self_iff_true, not_true, ne.def] at *
split
{ split; intro; simp only [*, if_true, eq_self_iff_true, not_true, ne.def] at * }
split_ifs at hy; cc
cc
cc
split_ifs at hy
by_cases h : f = 1
exact ne_of_eq_of_ne (card_support_eq_zero.mpr h) zero_ne_one
{ exact ne_of_eq_of_ne (card_support_eq_zero.mpr h) zero_ne_one }
exact ne_of_gt (one_lt_card_support_of_ne_one h)
ext
ext; simp
simp
simp
tidy
let x : equiv.perm (fin 5) := ⟨![1, 2, 0, 3, 4], ![2, 0, 1, 3, 4], dec_trivial, dec_trivial⟩
let y : equiv.perm (fin 5) := ⟨![3, 4, 2, 0, 1], ![3, 4, 2, 0, 1], dec_trivial, dec_trivial⟩
let z : equiv.perm (fin 5) := ⟨![0, 3, 2, 1, 4], ![0, 3, 2, 1, 4], dec_trivial, dec_trivial⟩
rw [ne.def, equiv.ext_iff]
have x_ne_one : x ≠ 1
dec_trivial
{ rw [ne.def, equiv.ext_iff], dec_trivial }
have key : x = z * (x * (y * x * y⁻¹) * x⁻¹ * (y * x * y⁻¹)⁻¹) * z⁻¹
dec_trivial!
{ ext a, dec_trivial! }
ext a
refine not_solvable_of_mem_derived_series x_ne_one (λ n, _)
induction n with n ih
{ exact mem_top x }
exact mem_top x
rw key
exact (derived_series_normal _ _).conj_mem _ (general_commutator_containment _ _ ih ((derived_series_normal _ _).conj_mem _ ih _)) _
rw [← fintype.card_eq.mpr ⟨fintype_helper⟩, fintype.card_sum, zmod.card, two_mul]
rw [gsmul_coe_nat]
exact add_submonoid.nsmul_mem H.to_add_submonoid hx n
rw gsmul_neg_succ_of_nat
apply H.neg_mem'
exact add_submonoid.nsmul_mem H.to_add_submonoid hx n.succ
refine ((iH.comap f).eq_bot_or_eq_top).imp (λ h, _) (λ h, _)
rw [←map_bot f, ←h, map_comap_eq_self_of_surjective hf]
{ rw [←map_bot f, ←h, map_comap_eq_self_of_surjective hf] }
exact comap_injective hf h
rw [←comap_top f] at h
rw mul_one
simpa using hN.conj_mem _ hn h'⁻¹
simp [← ha, ← hb, mul_assoc]
rw [mul_assoc h, inv_mul_cancel_left, ← hx, mul_inv_rev]
rw [set.mem_set_of_eq, f.map_one, g.map_one]
simp [*]
apply_instance
have := comap_map_mkq (⨅ n : ℕ, I ^ n • ⊤ : submodule R M) (I ^ n • ⊤)
simp only [sup_of_le_right (infi_le (λ n, (I ^ n • ⊤ : submodule R M)) n)] at this
rw [← this, map_smul'', mem_comap, map_top, range_mkq, ← smodeq.zero]
exact hx n
rw ker_mkq
exact smul_mono (ideal.pow_le_pow h) (le_refl _)
rw [pi.zero_apply, pi.zero_apply, linear_map.map_zero]
rw [pi.add_apply, pi.add_apply, linear_map.map_add, hf hmn, hg hmn]
rw [pi.smul_apply, pi.smul_apply, linear_map.map_smul, hf hmn]
rw ←mem_coe at h
rw [←affine_span_insert_affine_span, set.insert_eq_of_mem h, affine_span_coe]
rcases hp1 with ⟨p1a, ⟨hp1a, ⟨v1, ⟨hv1, hv1p⟩⟩⟩⟩
rcases hp2 with ⟨p2a, ⟨hp2a, ⟨v2, ⟨hv2, hv2p⟩⟩⟩⟩
rw [hv1p, hv2p, vsub_vadd_eq_vsub_sub (v1 +ᵥ p1a), vadd_vsub_assoc, add_comm, add_sub_assoc]
have hv1v2 : v1 - v2 ∈ vector_span k s
rw sub_eq_add_neg
apply (vector_span k s).add_mem hv1
rw ←neg_one_smul k v2
{ rw sub_eq_add_neg, apply (vector_span k s).add_mem hv1, rw ←neg_one_smul k v2, exact (vector_span k s).smul_mem (-1 : k) hv2 }
exact (vector_span k s).smul_mem (-1 : k) hv2
refine (vector_span k s).add_mem _ hv1v2
exact vsub_mem_vector_span k hp1a hp2a
rcases hp1 with ⟨v1, hv1, hp1⟩
rcases hp2 with ⟨v2, hv2, hp2⟩
rcases hp3 with ⟨v3, hv3, hp3⟩
use [c • (v1 - v2) + v3, direction.add_mem (direction.smul_mem c (direction.sub_mem hv1 hv2)) hv3]
simp [hp1, hp2, hp3, vadd_vadd]
ext v
rw mem_direction_iff_eq_vsub (mk'_nonempty _ _)
split
rintros ⟨p1, ⟨v1, hv1, hp1⟩, p2, ⟨v2, hv2, hp2⟩, hv⟩
rw [hv, hp1, hp2, vadd_vsub_vadd_cancel_right]
{ rintros ⟨p1, ⟨v1, hv1, hp1⟩, p2, ⟨v2, hv2, hp2⟩, hv⟩, rw [hv, hp1, hp2, vadd_vsub_vadd_cancel_right], exact direction.sub_mem hv1 hv2 }
exact direction.sub_mem hv1 hv2
exact λ hv, ⟨v +ᵥ p, vadd_mem_mk' _ hv, p, self_mem_mk' _ _, (vadd_vsub _ _).symm⟩
cases S.nonempty with p
ext v
refine ⟨imp_intro submodule.mem_top, λ hv, _⟩
have hpv : (v +ᵥ p -ᵥ p : V) ∈ (⊤ : affine_subspace k P).direction := vsub_mem_direction (mem_top k V _) (mem_top k V _)
rwa vadd_vsub at hpv
rw vector_span_def
refine le_antisymm _ (submodule.span_mono _)
rw submodule.span_le
rintros v ⟨p1, p2, hp1, hp2, hv⟩
rw ←vsub_sub_vsub_cancel_left p1 p2 p at hv
rw [←hv, set_like.mem_coe, submodule.mem_span]
exact λ m hm, submodule.sub_mem _ (hm ⟨p2, hp2, rfl⟩) (hm ⟨p1, hp1, rfl⟩)
{ rw submodule.span_le, rintros v ⟨p1, p2, hp1, hp2, hv⟩, rw ←vsub_sub_vsub_cancel_left p1 p2 p at hv, rw [←hv, set_like.mem_coe, submodule.mem_span], exact λ m hm, submodule.sub_mem _ (hm ⟨p2, hp2, rfl⟩) (hm ⟨p1, hp1, rfl⟩) }
rintros v ⟨p2, hp2, hv⟩
exact ⟨p, p2, hp, hp2, hv⟩
rw [vector_span_eq_span_vsub_set_left k (set.mem_image_of_mem p hi), ←set.insert_eq_of_mem hi, ←set.insert_diff_singleton, set.image_insert_eq, set.image_insert_eq]
conv_lhs { rw [vector_span_eq_span_vsub_set_left k (set.mem_image_of_mem p hi), ←set.insert_eq_of_mem hi, ←set.insert_diff_singleton, set.image_insert_eq, set.image_insert_eq] }
simp [submodule.span_insert_eq_span]
rw [←smul_sub, vsub_sub_vsub_cancel_left]
rw [←sum_smul, h, one_smul, vsub_add_vsub_cancel, vsub_self]
split
swap
rcases is_empty_or_nonempty ι with hι|⟨⟨i0⟩⟩
rw [vector_span_range_eq_span_range_vsub_right k p i0, ←set.image_univ, finsupp.mem_span_image_iff_total]
rintros ⟨l, hl, hv⟩
use insert i0 l.support
set w := (l : ι → k) - function.update (function.const ι 0 : ι → k) i0 (∑ i in l.support, l i) with hwdef
use w
have hw : ∑ i in insert i0 l.support, w i = 0
rw hwdef
simp_rw [pi.sub_apply, finset.sum_sub_distrib, finset.sum_update_of_mem (finset.mem_insert_self _ _), finset.sum_const_zero, finset.sum_insert_of_eq_zero_if_not_mem finsupp.not_mem_support_iff.1, add_zero, sub_self]
{ rw hwdef, simp_rw [pi.sub_apply, finset.sum_sub_distrib, finset.sum_update_of_mem (finset.mem_insert_self _ _), finset.sum_const_zero, finset.sum_insert_of_eq_zero_if_not_mem finsupp.not_mem_support_iff.1, add_zero, sub_self] }
use hw
have hz : w i0 • (p i0 -ᵥ p i0 : V) = 0 := (vsub_self (p i0)).symm ▸ smul_zero _
change (λ i, w i • (p i -ᵥ p i0 : V)) i0 = 0 at hz
rw [finset.weighted_vsub_eq_weighted_vsub_of_point_of_sum_eq_zero _ w p hw (p i0), finset.weighted_vsub_of_point_apply, ←hv, finsupp.total_apply, finset.sum_insert_zero hz]
change ∑ i in l.support, l i • _ = _
congr' with i
by_cases h : i = i0
{ simp [h] }
simp [h]
{ rw [vector_span_range_eq_span_range_vsub_right k p i0, ←set.image_univ, finsupp.mem_span_image_iff_total], rintros ⟨l, hl, hv⟩, use insert i0 l.support, set w := (l : ι → k) - function.update (function.const ι 0 : ι → k) i0 (∑ i in l.support, l i) with hwdef, use w, have hw : ∑ i in insert i0 l.support, w i = 0, { rw hwdef, simp_rw [pi.sub_apply, finset.sum_sub_distrib, finset.sum_update_of_mem (finset.mem_insert_self _ _), finset.sum_const_zero, finset.sum_insert_of_eq_zero_if_not_mem finsupp.not_mem_support_iff.1, add_zero, sub_self] }, use hw, have hz : w i0 • (p i0 -ᵥ p i0 : V) = 0 := (vsub_self (p i0)).symm ▸ smul_zero _, change (λ i, w i • (p i -ᵥ p i0 : V)) i0 = 0 at hz, rw [finset.weighted_vsub_eq_weighted_vsub_of_point_of_sum_eq_zero _ w p hw (p i0), finset.weighted_vsub_of_point_apply, ←hv, finsupp.total_apply, finset.sum_insert_zero hz], change ∑ i in l.support, l i • _ = _, congr' with i, by_cases h : i = i0, { simp [h] }, { simp [hwdef, h] } }
simp [hwdef, h]
resetI
rw [set.range_eq_empty, vector_span_empty, submodule.mem_bot]
rintro rfl
use [∅]
{ rcases is_empty_or_nonempty ι with hι|⟨⟨i0⟩⟩, swap, { rw [vector_span_range_eq_span_range_vsub_right k p i0, ←set.image_univ, finsupp.mem_span_image_iff_total], rintros ⟨l, hl, hv⟩, use insert i0 l.support, set w := (l : ι → k) - function.update (function.const ι 0 : ι → k) i0 (∑ i in l.support, l i) with hwdef, use w, have hw : ∑ i in insert i0 l.support, w i = 0, { rw hwdef, simp_rw [pi.sub_apply, finset.sum_sub_distrib, finset.sum_update_of_mem (finset.mem_insert_self _ _), finset.sum_const_zero, finset.sum_insert_of_eq_zero_if_not_mem finsupp.not_mem_support_iff.1, add_zero, sub_self] }, use hw, have hz : w i0 • (p i0 -ᵥ p i0 : V) = 0 := (vsub_self (p i0)).symm ▸ smul_zero _, change (λ i, w i • (p i -ᵥ p i0 : V)) i0 = 0 at hz, rw [finset.weighted_vsub_eq_weighted_vsub_of_point_of_sum_eq_zero _ w p hw (p i0), finset.weighted_vsub_of_point_apply, ←hv, finsupp.total_apply, finset.sum_insert_zero hz], change ∑ i in l.support, l i • _ = _, congr' with i, by_cases h : i = i0, { simp [h] }, { simp [hwdef, h] } }, { resetI, rw [set.range_eq_empty, vector_span_empty, submodule.mem_bot], rintro rfl, use [∅], simp } }
simp
rintros ⟨s, w, hw, rfl⟩
exact weighted_vsub_mem_vector_span hw p
erw [weighted_vsub_of_point_apply, weighted_vsub_of_point_apply, ←@vsub_eq_zero_iff_eq V, vadd_vsub_assoc, vsub_vadd_eq_vsub_sub, ←add_sub_assoc, add_comm, add_sub_assoc, ←sum_sub_distrib]
conv_lhs { congr, skip, congr, skip, funext, rw [←smul_sub, vsub_sub_vsub_cancel_left] }
congr
skip
congr
skip
funext
rw [collinear_iff_finrank_le_one, affine_independent_iff_not_finrank_vector_span_le k p (fintype.card_fin 3)]
intros fs w hw hs i0 hi0
let fs' := fs.map f
let w' := λ i, if h : ∃ i2, f i2 = i then w h.some else 0
have hw' : ∀ i2 : ι2, w' (f i2) = w i2
intro i2
have h : ∃ i : ι2, f i = f i2 := ⟨i2, rfl⟩
have hs : h.some = i2 := f.injective h.some_spec
{ intro i2, have h : ∃ i : ι2, f i = f i2 := ⟨i2, rfl⟩, have hs : h.some = i2 := f.injective h.some_spec, simp_rw [w', dif_pos h, hs] }
simp_rw [w', dif_pos h, hs]
have hw's : ∑ i in fs', w' i = 0
rw [←hw, finset.sum_map]
{ rw [←hw, finset.sum_map], simp [hw'] }
simp [hw']
have hs' : fs'.weighted_vsub p w' = (0:V)
rw [←hs, finset.weighted_vsub_map]
congr' with i
{ rw [←hs, finset.weighted_vsub_map], congr' with i, simp [hw'] }
simp [hw']
rw [←ha fs' w' hw's hs' (f i0) ((finset.mem_map' _).2 hi0), hw']
rw [slope, slope, ← neg_vsub_eq_vsub_rev, smul_neg, ← neg_smul, neg_inv, neg_sub]
simp [f.map_eq_zero_of_eq v h hij]
apply σ.induction_on' (λ σ, _)
exact _root_.congr_arg quotient.mk' (equiv.swap_mul_involutive i j σ)
dsimp only
rw multilinear_map.sum_apply
exact finset.sum_involution (λ σ _, equiv.swap i j • σ) (λ σ _, dom_coprod.summand_add_swap_smul_eq_zero a b σ hv hij) (λ σ _, mt $ dom_coprod.summand_eq_zero_of_smul_invariant a b σ hv hij) (λ σ _, finset.mem_univ _) (λ σ _, equiv.perm.mod_sum_congr.swap_smul_involutive i j σ)
rw [set_like.mem_coe, mem_sup, set.mem_add]
simp
ext
rw [ker_comp, hg, submodule.comap_bot]
rw [mem_map_equiv, mem_comap, linear_equiv.coe_coe]
classical
intro g
refine ⟨λ x, if h : ∃ y, f y = x then g h.some else 0, _⟩
ext
dsimp only [fun_left_apply]
split_ifs with w
congr
{ congr, exact hf w.some_spec, }
exact hf w.some_spec
simpa only [not_true, exists_apply_eq_apply] using w
obtain ⟨m, ne⟩ := (nontrivial_iff_exists_ne (0 : M)).mp infer_instance
exact nontrivial_of_ne 1 0 (λ p, ne (linear_map.congr_fun p m))
simp only [pi.sub_apply, map_add, add_sub_comm]
simp [pi.sub_apply, map_smul, smul_sub]
intros
simp
refl
intros
simp
refl
rw [linear_map.comp_assoc, hg, f.comp_id]
by_cases htr : nontrivial R
letI := htr
simp [htr, reindex_range, reindex_apply, equiv.apply_of_injective_symm b b.injective, subtype.coe_mk]
{ letI := htr, simp [htr, reindex_range, reindex_apply, equiv.apply_of_injective_symm b b.injective, subtype.coe_mk] }
letI : subsingleton R := not_nontrivial_iff_subsingleton.mp htr
letI := module.subsingleton R M
simp [reindex_range]
ext i
simp only [basis.prod, basis.coe_of_repr, linear_equiv.symm_trans_apply, linear_equiv.prod_symm, linear_equiv.prod_apply, b.repr.apply_symm_apply, linear_equiv.symm_symm, repr_self, equiv.to_fun_as_coe, finsupp.fst_sum_finsupp_lequiv_prod_finsupp, linear_equiv.map_zero, finsupp.zero_apply]
apply finsupp.single_eq_of_ne sum.inr_ne_inl
rw [linear_map.map_add, add_left]
rw [linear_map.map_smul, smul_left]
rw [linear_map.map_add, add_right]
rw [linear_map.map_smul, smul_right]
classical
rw linear_independent_iff'
intros s w hs i hi
have : B (s.sum $ λ (i : n), w i • v i) (v i) = 0
{ rw [hs, zero_left] }
rw [hs, zero_left]
have hsum : s.sum (λ (j : n), w j * B (v j) (v i)) = s.sum (λ (j : n), if i = j then w j * B (v j) (v i) else 0)
refine finset.sum_congr rfl (λ j hj, _)
by_cases (i = j)
{ rw [if_pos h] }
rw [if_pos h]
{ refine finset.sum_congr rfl (λ j hj, _), by_cases (i = j), { rw [if_pos h] }, { rw [if_neg h, is_Ortho_def.1 hv₁ _ _ h, mul_zero] } }
rw [if_neg h, is_Ortho_def.1 hv₁ _ _ h, mul_zero]
simp_rw [sum_left, smul_left, hsum, finset.sum_ite_eq] at this
rw [if_pos, mul_eq_zero] at this
cases this
{ assumption }
assumption
{ exact false.elim (hv₂ i $ this) }
exact false.elim (hv₂ i $ this)
assumption
induction h
rw [alg_hom.commutes, alg_hom.map_mul, tensor_algebra.lift_ι_apply, f.prop]
rw [ linear_map.comp_apply, alg_hom.to_linear_map_apply, comp_ι_sq_scalar]
ext
simp only [ι, alg_hom.to_linear_map_apply, function.comp_app, linear_map.coe_comp, subtype.coe_mk, ring_quot.lift_alg_hom_mk_alg_hom_apply, tensor_algebra.lift_ι_apply]
ext
simp only [ι, alg_hom.comp_to_linear_map, alg_hom.to_linear_map_apply, function.comp_app, linear_map.coe_comp, subtype.coe_mk, ring_quot.lift_alg_hom_mk_alg_hom_apply, tensor_algebra.lift_ι_apply]
exact alg_hom.congr_fun (map_comp_map Q₁ Q₂ Q₃ _ _ _ _) x
ext x
simp
apply quaternion_algebra.lift.symm.injective
ext1
simp
simp
ext1; dsimp [quaternion_algebra.basis.lift]; simp
ext1; dsimp [quaternion_algebra.basis.lift]
dsimp [quaternion_algebra.basis.lift]
dsimp [quaternion_algebra.basis.lift]
simp
ext
rw [linear_map.coe_det, dif_pos, det_aux_def' _ b]
rw [linear_map.coe_det, dif_pos, det_aux_def' _ b]; assumption
assumption
simp only [← zero_smul 𝕜 (1 : M →ₗ[𝕜] M), det_smul, mul_one, monoid_hom.map_one]
dsimp
apply dfinsupp.induction f
{ rw [smul_zero, add_monoid_hom.map_zero, smul_zero] }
rw [smul_zero, add_monoid_hom.map_zero, smul_zero]
intros a b f ha hb hf
rw [smul_add, add_monoid_hom.map_add, add_monoid_hom.map_add, smul_add, hf, ←single_smul, sum_add_hom_single, sum_add_hom_single, linear_map.to_add_monoid_hom_coe, linear_map.map_smul]
ext x y
simp
ext x y
simp
ext x y
simp
ext
simp
refine dim_le_of_submodule _ _ _
exact (linear_map.range_le_iff_comap.2 $ eq_top_iff'.2 $ assume x, show f x + g x ∈ (f.range ⊔ g.range : submodule K V'), from mem_sup.2 ⟨_, ⟨x, rfl⟩, _, ⟨x, rfl⟩, rfl⟩)
apply le_antisymm
exact f.to_linear_map.lift_dim_le_of_injective f.injective
{ exact f.to_linear_map.lift_dim_le_of_injective f.injective, }
exact f.symm.to_linear_map.lift_dim_le_of_injective f.symm.injective
apply dual_basis_apply
ext i x
rw [h.coeffs_apply, h.dual_lc]
ext i
refine _ ≪≫ₗ W.quot_dual_equiv_annihilator
refine linear_equiv.quot_equiv_of_equiv _ (basis.of_vector_space K V).to_dual_equiv
exact (basis.of_vector_space K W).to_dual_equiv.trans W.dual_equiv_dual
obtain ⟨c, nu⟩ := exists_spectrum_of_is_alg_closed_of_finite_dimensional K f
use c
rw linear_map.is_unit_iff at nu
exact has_eigenvalue_of_has_eigenvector (exists_mem_ne_zero_of_ne_bot nu).some_spec
simp only [generalized_eigenspace, preorder_hom.coe_fun_mk, ← linear_map.ker_comp]
induction k with k ih
rw [pow_zero, pow_zero, linear_map.one_eq_id]
{ rw [pow_zero, pow_zero, linear_map.one_eq_id], apply (submodule.ker_subtype _).symm }
apply (submodule.ker_subtype _).symm
erw [pow_succ', pow_succ', linear_map.ker_comp, linear_map.ker_comp, ih, ← linear_map.ker_comp, ← linear_map.ker_comp, linear_map.comp_assoc]
obtain ⟨b⟩ := (basis.basis_singleton_iff punit).mpr ⟨v, n, h⟩
rw [finrank_eq_card_basis b, fintype.card_punit]
haveI := finite_dimensional_of_finrank (_root_.zero_lt_one.trans_le h.symm.le)
exact (fin_basis_of_finrank_eq K V h).reindex equiv_of_unique_of_unique
rw ← lift_le.{_ (max v w)}
simpa [← finrank_eq_dim K V] using cardinal_lift_le_dim_of_linear_independent.{_ _ _ (max v w)} h
rw [finite_dimensional, is_noetherian.iff_dim_lt_omega ] at h ⊢
unfreezingI { rw [finite_dimensional, is_noetherian.iff_dim_lt_omega ] at h ⊢ }
rw [← cardinal.lift_lt.{v' v}]
rw [← cardinal.lift_lt.{v v'}] at h
rw [cardinal.lift_omega] at h ⊢
exact (lift_dim_map_le f p).trans_lt h
haveI := classical.dec_pred (λ (x : α), x ∈ s)
haveI := classical.dec_pred (λ (x : α), x ∈ s); simp [mem_supported, set.subset_def, not_imp_comm]
simp [mem_supported, set.subset_def, not_imp_comm]
refine ⟨λ h x hx, _, disjoint_supported_supported⟩
rcases exists_ne (0 : M) with ⟨y, hy⟩
have := h ⟨single_mem_supported R y hx.1, single_mem_supported R y hx.2⟩
rw [mem_bot, single_eq_zero] at this
exact hy this
ext x
split
intros hx
rw [linear_map.mem_range] at hx
rcases hx with ⟨l, hl⟩
rw ← hl
rw finsupp.total_apply
unfold finsupp.sum
apply sum_mem (span R (range v))
exact λ i hi, submodule.smul_mem _ _ (subset_span (mem_range_self i))
{ intros hx, rw [linear_map.mem_range] at hx, rcases hx with ⟨l, hl⟩, rw ← hl, rw finsupp.total_apply, unfold finsupp.sum, apply sum_mem (span R (range v)), exact λ i hi, submodule.smul_mem _ _ (subset_span (mem_range_self i)) }
apply span_le.2
intros x hx
rcases hx with ⟨i, hi⟩
rw [set_like.mem_coe, linear_map.mem_range]
use finsupp.single i 1
simp [hi]
simp [total_apply]
ext
intros
ext
ext; simp only [add_equiv.to_fun_eq_coe, prod.smul_fst, prod.smul_snd, smul_apply, snd_sum_finsupp_add_equiv_prod_finsupp, fst_sum_finsupp_add_equiv_prod_finsupp, ring_hom.id_apply]
simp only [add_equiv.to_fun_eq_coe, prod.smul_fst, prod.smul_snd, smul_apply, snd_sum_finsupp_add_equiv_prod_finsupp, fst_sum_finsupp_add_equiv_prod_finsupp, ring_hom.id_apply]
simp only [add_equiv.to_fun_eq_coe, prod.smul_fst, prod.smul_snd, smul_apply, snd_sum_finsupp_add_equiv_prod_finsupp, fst_sum_finsupp_add_equiv_prod_finsupp, ring_hom.id_apply]
exactI eq_of_fin_equiv I.quotient ((ideal.pi_quot_equiv _ _).symm ≪≫ₗ ((induced_equiv _ e) ≪≫ₗ (ideal.pi_quot_equiv _ _)))
rw [ker_comp, of_le, comap_cod_restrict, ker_mkq, map_comap_subtype]
exact comap_mono (inf_le_inf_right _ le_sup_left)
rw [← linear_independent_equiv ((equiv.option_equiv_sum_punit _).trans (equiv.set.insert has).symm), linear_independent_option]
simp [(∘), range_comp f]
have p : (span.repr R (set.range v) x).equiv_map_domain (equiv.of_injective _ hv.injective).symm = hv.repr x
apply (linear_independent.total_equiv hv).injective
ext
{ apply (linear_independent.total_equiv hv).injective, ext, simp, }
simp
ext ⟨_, ⟨i, rfl⟩⟩
simp [←p]
ext i j
rw [e.to_matrix_apply, pi.smul_apply, linear_equiv.map_smul]
refl
intro v
ext j
exact e.sum_to_matrix_smul_self v j
intros m
ext k l
simp only [e.to_matrix_apply, ← e.equiv_fun_apply, ← e.equiv_fun_symm_apply, linear_equiv.apply_symm_apply]
simp_rw [e.to_matrix_apply, e.sum_repr]
ext i j
change _ = _ + _
rw [e.to_matrix_apply, pi.add_apply, linear_equiv.map_add]
refl
intros c v
ext
ext; simp
simp
convert div_inv_monoid.gpow_neg' 0 A
simp only [gpow_one, int.coe_nat_zero, int.coe_nat_succ, gpow_eq_pow, zero_add]
simp [← int.coe_nat_succ, pow_succ']
rw [neg_add, neg_add_cancel_right, fpow_neg h, fpow_coe_nat]
rw [mul_inv_rev, matrix.mul_assoc, nonsing_inv_mul _ h, matrix.mul_one]
rw [fpow_neg h, ← int.coe_nat_succ, fpow_coe_nat, pow_succ, mul_eq_mul, mul_eq_mul]
refine (inv_eq_left_inv _).symm
rw [←mul_eq_mul, ←units.coe_mul, inv_mul_self, units.coe_one]
haveI : subsingleton n := fintype.card_le_one_iff_subsingleton.mp h.le
exact adjugate_subsingleton _
have h1 := (is_unit_det_of_left_inverse h)
have h2 := matrix.invertible_of_is_unit_det h1
have := @inv_of_eq_left_inv (matrix n n α) (infer_instance) A B h2 h
simp* at *
simp only [submodule.eq_bot_iff, linear_map.mem_ker, matrix.to_lin'_apply]
rw [← matrix.to_lin_mul_apply, hM'M, matrix.to_lin_one, id_apply]
rw [← matrix.to_lin_mul_apply, hMM', matrix.to_lin_one, id_apply]
ext i j
simp only [matrix.mul_vec_std_basis, matrix.mul_vec_lin_apply]
apply (pi.basis_fun R n).ext
ext i
intro j
simp only [pi.basis_fun_apply, matrix.mul_vec_std_basis, matrix.mul_vec_lin_apply]
ext i j
simp only [pi.add_apply, linear_map.add_apply]
ext i j
simp only [pi.smul_apply, linear_map.smul_apply, ring_hom.id_apply]
simp
simp [add_comm]
simp
rw f.snoc_add
simp only [f.snoc_smul, ring_hom.id_apply]
ext z
change f (snoc (update m i (x + y)) z) = f (snoc (update m i x) z) + f (snoc (update m i y) z)
rw [snoc_update, snoc_update, snoc_update, f.map_add]
ext z
change f (snoc (update m i (c • x)) z) = c • f (snoc (update m i x) z)
rw [snoc_update, snoc_update, f.map_smul]
intros f g
ext
ext; refl
refl
refl
intros r f
ext
ext; refl
refl
refl
ext ⟨x, y⟩; simp
simp
ext ⟨x, y⟩
exact 0
tidy
cases Q'
congr
funext
apply H
cases Q
simp [map_add_self, bit0, add_mul, add_assoc]
rw [← two_mul (Q x), ←mul_assoc, inv_of_mul_self, one_mul]
rw [ker_liftq, le_antisymm h h', mkq_map_self]
suffices : (span R₂ s).comap f ≤ span R (f ⁻¹' s)
{ exact le_antisymm (span_preimage_le f s) this, }
exact le_antisymm (span_preimage_le f s) this
have hk : ker f ≤ span R (f ⁻¹' s)
have hy : y ∈ s
exact classical.some_spec h₀
let y := classical.some h₀
{ exact classical.some_spec h₀, }
use [y, h₁ hy]
rw ← set.singleton_subset_iff at hy
rw ker_le_iff
exact set.subset.trans subset_span (span_mono (set.preimage_mono hy))
{ let y := classical.some h₀, have hy : y ∈ s, { exact classical.some_spec h₀, }, rw ker_le_iff, use [y, h₁ hy], rw ← set.singleton_subset_iff at hy, exact set.subset.trans subset_span (span_mono (set.preimage_mono hy)), }
rw f.range_coe at h₁
rw ← left_eq_sup at hk
rw [hk, ← map_le_map_iff, map_span, map_comap_eq, set.image_preimage_eq_of_subset h₁]
exact inf_le_right
simpa using neg_mem p h
simp [algebra_map_inv]
simp only [← submodule.map_top, ← span_tmul_eq_top, submodule.map_span, set.mem_image, set.mem_set_of_eq]
ext t
congr
split
use [m, n]
simp only [map_tmul]
rintros ⟨_, ⟨⟨m, n, rfl⟩, rfl⟩⟩
{ rintros ⟨_, ⟨⟨m, n, rfl⟩, rfl⟩⟩, use [m, n], simp only [map_tmul], }
use [m ⊗ₜ n, m, n]
simp only [map_tmul]
rintros ⟨m, n, rfl⟩
by_cases p; simp *
simp *
simp *
by_cases p
by_cases p; simp *
simp *
simp *
by_cases p
cases h with w
cases w
simp [@eq_comm _ a']
rw h
apply_instance
rcases exists_pair_ne β with ⟨x, y, h⟩
rcases hf x with ⟨x', hx'⟩
rcases hf y with ⟨y', hy'⟩
contrapose! h
rw [← hx', ← hy', h]
have : x' ≠ y'
exact ⟨⟨x', y', this⟩⟩
classical; exact decidable.exists_ne x
exact decidable.exists_ne x
classical
induction hab generalizing c
exact single hac
case refl_trans_gen.refl : c hac { exact single hac }
case refl_trans_gen.tail : d b hab hdb IH { exact tail (IH hdb) hbc }
exact tail (IH hdb) hbc
simpa [refl_trans_gen_idem] using refl_trans_gen_lift f h hab
congr
congr; rw [h x, h y]
rw [h x, h y]
apply_instance
convert set_integral_fun_unique_pi ι volume f s
refine absolutely_continuous.mk (λ s hs h2s, _)
simp_rw [map_apply measurable_fst hs, ← prod_univ, prod_prod hs measurable_set.univ]
rw [h2s, zero_mul]
rw [dif_pos (nnreal.coe_nonneg r), real.to_nnreal_coe]
have he₁ : ∀n, measurable_set (e n) := assume n, (he n).1
have he₂ : ∀n, γ - (1/2)^n < d (e n) := assume n, (he n).2
let f : ℕ → ℕ → set α := λn m, (finset.Ico n (m + 1)).inf e
have hf : ∀n m, measurable_set (f n m)
assume n m
simp only [f, finset.inf_eq_infi]
exact measurable_set.bInter (countable_encodable _) (assume i _, he₁ _)
{ assume n m, simp only [f, finset.inf_eq_infi], exact measurable_set.bInter (countable_encodable _) (assume i _, he₁ _) }
have f_subset_f : ∀{a b c d}, a ≤ b → c ≤ d → f a d ⊆ f b c
assume a b c d hab hcd
dsimp only [f]
rw [finset.inf_eq_infi, finset.inf_eq_infi]
refine bInter_subset_bInter_left _
simp
rintros j ⟨hbj, hjc⟩
exact ⟨le_trans hab hbj, lt_of_lt_of_le hjc $ add_le_add_right hcd 1⟩
{ assume a b c d hab hcd, dsimp only [f], rw [finset.inf_eq_infi, finset.inf_eq_infi], refine bInter_subset_bInter_left _, simp, rintros j ⟨hbj, hjc⟩, exact ⟨le_trans hab hbj, lt_of_lt_of_le hjc $ add_le_add_right hcd 1⟩ }
have f_succ : ∀n m, n ≤ m → f n (m + 1) = f n m ∩ e (m + 1)
assume n m hnm
have : n ≤ m + 1 := le_of_lt (nat.succ_le_succ hnm)
simp only [f]
rw [finset.Ico.succ_top this, finset.inf_insert, set.inter_comm]
{ assume n m hnm, have : n ≤ m + 1 := le_of_lt (nat.succ_le_succ hnm), simp only [f], rw [finset.Ico.succ_top this, finset.inf_insert, set.inter_comm], refl }
refl
have le_d_f : ∀n m, m ≤ n → γ - 2 * ((1 / 2) ^ m) + (1 / 2) ^ n ≤ d (f m n)
assume n m h
refine nat.le_induction _ _ n h
have := he₂ m
simp only [f]
rw [finset.Ico.succ_singleton, finset.inf_singleton]
{ have := he₂ m, simp only [f], rw [finset.Ico.succ_singleton, finset.inf_singleton], exact aux this }
exact aux this
assume n (hmn : m ≤ n) ih
have : γ + (γ - 2 * (1 / 2)^m + (1 / 2) ^ (n + 1)) ≤ γ + d (f m (n + 1))
calc γ + (γ - 2 * (1 / 2)^m + (1 / 2) ^ (n+1)) ≤ γ + (γ - 2 * (1 / 2)^m + ((1 / 2) ^ n - (1/2)^(n+1))) : begin refine add_le_add_left (add_le_add_left _ _) γ, simp only [pow_add, pow_one, le_sub_iff_add_le], linarith end ... = (γ - (1 / 2)^(n+1)) + (γ - 2 * (1 / 2)^m + (1 / 2)^n) : by simp only [sub_eq_add_neg]; ac_refl ... ≤ d (e (n + 1)) + d (f m n) : add_le_add (le_of_lt $ he₂ _) ih ... ≤ d (e (n + 1)) + d (f m n \ e (n + 1)) + d (f m (n + 1)) : by rw [f_succ _ _ hmn, d_split (f m n) (e (n + 1)) (hf _ _) (he₁ _), add_assoc] ... = d (e (n + 1) ∪ f m n) + d (f m (n + 1)) : begin rw [d_split (e (n + 1) ∪ f m n) (e (n + 1)), union_diff_left, union_inter_cancel_left], ac_refl, exact (he₁ _).union (hf _ _), exact (he₁ _) end ... ≤ γ + d (f m (n + 1)) : add_le_add_right (d_le_γ _ $ (he₁ _).union (hf _ _)) _
refine add_le_add_left (add_le_add_left _ _) γ
simp only [pow_add, pow_one, le_sub_iff_add_le]
linarith
simp only [sub_eq_add_neg]
simp only [sub_eq_add_neg]; ac_refl
ac_refl
rw [f_succ _ _ hmn, d_split (f m n) (e (n + 1)) (hf _ _) (he₁ _), add_assoc]
rw [d_split (e (n + 1) ∪ f m n) (e (n + 1)), union_diff_left, union_inter_cancel_left]
ac_refl
exact (he₁ _).union (hf _ _)
exact (he₁ _)
{ calc γ + (γ - 2 * (1 / 2)^m + (1 / 2) ^ (n+1)) ≤ γ + (γ - 2 * (1 / 2)^m + ((1 / 2) ^ n - (1/2)^(n+1))) : begin refine add_le_add_left (add_le_add_left _ _) γ, simp only [pow_add, pow_one, le_sub_iff_add_le], linarith end ... = (γ - (1 / 2)^(n+1)) + (γ - 2 * (1 / 2)^m + (1 / 2)^n) : by simp only [sub_eq_add_neg]; ac_refl ... ≤ d (e (n + 1)) + d (f m n) : add_le_add (le_of_lt $ he₂ _) ih ... ≤ d (e (n + 1)) + d (f m n \ e (n + 1)) + d (f m (n + 1)) : by rw [f_succ _ _ hmn, d_split (f m n) (e (n + 1)) (hf _ _) (he₁ _), add_assoc] ... = d (e (n + 1) ∪ f m n) + d (f m (n + 1)) : begin rw [d_split (e (n + 1) ∪ f m n) (e (n + 1)), union_diff_left, union_inter_cancel_left], ac_refl, exact (he₁ _).union (hf _ _), exact (he₁ _) end ... ≤ γ + d (f m (n + 1)) : add_le_add_right (d_le_γ _ $ (he₁ _).union (hf _ _)) _ }
{ assume n m h, refine nat.le_induction _ _ n h, { have := he₂ m, simp only [f], rw [finset.Ico.succ_singleton, finset.inf_singleton], exact aux this }, { assume n (hmn : m ≤ n) ih, have : γ + (γ - 2 * (1 / 2)^m + (1 / 2) ^ (n + 1)) ≤ γ + d (f m (n + 1)), { calc γ + (γ - 2 * (1 / 2)^m + (1 / 2) ^ (n+1)) ≤ γ + (γ - 2 * (1 / 2)^m + ((1 / 2) ^ n - (1/2)^(n+1))) : begin refine add_le_add_left (add_le_add_left _ _) γ, simp only [pow_add, pow_one, le_sub_iff_add_le], linarith end ... = (γ - (1 / 2)^(n+1)) + (γ - 2 * (1 / 2)^m + (1 / 2)^n) : by simp only [sub_eq_add_neg]; ac_refl ... ≤ d (e (n + 1)) + d (f m n) : add_le_add (le_of_lt $ he₂ _) ih ... ≤ d (e (n + 1)) + d (f m n \ e (n + 1)) + d (f m (n + 1)) : by rw [f_succ _ _ hmn, d_split (f m n) (e (n + 1)) (hf _ _) (he₁ _), add_assoc] ... = d (e (n + 1) ∪ f m n) + d (f m (n + 1)) : begin rw [d_split (e (n + 1) ∪ f m n) (e (n + 1)), union_diff_left, union_inter_cancel_left], ac_refl, exact (he₁ _).union (hf _ _), exact (he₁ _) end ... ≤ γ + d (f m (n + 1)) : add_le_add_right (d_le_γ _ $ (he₁ _).union (hf _ _)) _ }, exact (add_le_add_iff_left γ).1 this } }
exact (add_le_add_iff_left γ).1 this
let s := ⋃ m, ⋂n, f m n
have γ_le_d_s : γ ≤ d s
have hγ : tendsto (λm:ℕ, γ - 2 * (1/2)^m) at_top (𝓝 γ)
simpa
suffices : tendsto (λm:ℕ, γ - 2 * (1/2)^m) at_top (𝓝 (γ - 2 * 0))
{ simpa }
exact (tendsto_const_nhds.sub $ tendsto_const_nhds.mul $ tendsto_pow_at_top_nhds_0_of_lt_1 (le_of_lt $ half_pos $ zero_lt_one) (half_lt_self zero_lt_one))
{ suffices : tendsto (λm:ℕ, γ - 2 * (1/2)^m) at_top (𝓝 (γ - 2 * 0)), { simpa }, exact (tendsto_const_nhds.sub $ tendsto_const_nhds.mul $ tendsto_pow_at_top_nhds_0_of_lt_1 (le_of_lt $ half_pos $ zero_lt_one) (half_lt_self zero_lt_one)) }
have hd : tendsto (λm, d (⋂n, f m n)) at_top (𝓝 (d (⋃ m, ⋂ n, f m n)))
refine d_Union _ _ _
exact measurable_set.Inter (assume m, hf _ _)
{ assume n, exact measurable_set.Inter (assume m, hf _ _) }
assume n
exact assume n m hnm, subset_Inter (assume i, subset.trans (Inter_subset (f n) i) $ f_subset_f hnm $ le_refl _)
{ refine d_Union _ _ _, { assume n, exact measurable_set.Inter (assume m, hf _ _) }, { exact assume n m hnm, subset_Inter (assume i, subset.trans (Inter_subset (f n) i) $ f_subset_f hnm $ le_refl _) } }
refine le_of_tendsto_of_tendsto' hγ hd (assume m, _)
have : tendsto (λn, d (f m n)) at_top (𝓝 (d (⋂ n, f m n)))
refine d_Inter _ _ _
exact hf _ _
{ assume n, exact hf _ _ }
assume n
exact f_subset_f (le_refl _) hnm
{ refine d_Inter _ _ _, { assume n, exact hf _ _ }, { assume n m hnm, exact f_subset_f (le_refl _) hnm } }
assume n m hnm
refine ge_of_tendsto this (eventually_at_top.2 ⟨m, assume n hmn, _⟩)
change γ - 2 * (1 / 2) ^ m ≤ d (f m n)
refine le_trans _ (le_d_f _ _ hmn)
exact le_add_of_le_of_nonneg (le_refl _) (pow_nonneg (le_of_lt $ half_pos $ zero_lt_one) _)
{ have hγ : tendsto (λm:ℕ, γ - 2 * (1/2)^m) at_top (𝓝 γ), { suffices : tendsto (λm:ℕ, γ - 2 * (1/2)^m) at_top (𝓝 (γ - 2 * 0)), { simpa }, exact (tendsto_const_nhds.sub $ tendsto_const_nhds.mul $ tendsto_pow_at_top_nhds_0_of_lt_1 (le_of_lt $ half_pos $ zero_lt_one) (half_lt_self zero_lt_one)) }, have hd : tendsto (λm, d (⋂n, f m n)) at_top (𝓝 (d (⋃ m, ⋂ n, f m n))), { refine d_Union _ _ _, { assume n, exact measurable_set.Inter (assume m, hf _ _) }, { exact assume n m hnm, subset_Inter (assume i, subset.trans (Inter_subset (f n) i) $ f_subset_f hnm $ le_refl _) } }, refine le_of_tendsto_of_tendsto' hγ hd (assume m, _), have : tendsto (λn, d (f m n)) at_top (𝓝 (d (⋂ n, f m n))), { refine d_Inter _ _ _, { assume n, exact hf _ _ }, { assume n m hnm, exact f_subset_f (le_refl _) hnm } }, refine ge_of_tendsto this (eventually_at_top.2 ⟨m, assume n hmn, _⟩), change γ - 2 * (1 / 2) ^ m ≤ d (f m n), refine le_trans _ (le_d_f _ _ hmn), exact le_add_of_le_of_nonneg (le_refl _) (pow_nonneg (le_of_lt $ half_pos $ zero_lt_one) _) }
have hs : measurable_set s := measurable_set.Union (assume n, measurable_set.Inter (assume m, hf _ _))
refine ⟨s, hs, _, _⟩
assume t ht hts
have : 0 ≤ d t := ((add_le_add_iff_left γ).1 $ calc γ + 0 ≤ d s : by rw [add_zero]; exact γ_le_d_s ... = d (s \ t) + d t : by rw [d_split _ _ hs ht, inter_eq_self_of_subset_right hts] ... ≤ γ + d t : add_le_add (d_le_γ _ (hs.diff ht)) (le_refl _))
rw [add_zero]
rw [add_zero]; exact γ_le_d_s
exact γ_le_d_s
rw [d_split _ _ hs ht, inter_eq_self_of_subset_right hts]
rw [← to_nnreal_μ, ← to_nnreal_ν, ennreal.coe_le_coe, ← nnreal.coe_le_coe]
simpa only [d, le_sub_iff_add_le, zero_add] using this
{ assume t ht hts, have : 0 ≤ d t := ((add_le_add_iff_left γ).1 $ calc γ + 0 ≤ d s : by rw [add_zero]; exact γ_le_d_s ... = d (s \ t) + d t : by rw [d_split _ _ hs ht, inter_eq_self_of_subset_right hts] ... ≤ γ + d t : add_le_add (d_le_γ _ (hs.diff ht)) (le_refl _)), rw [← to_nnreal_μ, ← to_nnreal_ν, ennreal.coe_le_coe, ← nnreal.coe_le_coe], simpa only [d, le_sub_iff_add_le, zero_add] using this }
assume t ht hts
have : d t ≤ 0
exact ((add_le_add_iff_left γ).1 $ calc γ + d t ≤ d s + d t : add_le_add γ_le_d_s (le_refl _) ... = d (s ∪ t) : begin rw [d_split _ _ (hs.union ht) ht, union_diff_right, union_inter_cancel_right, diff_eq_self.2], exact assume a ⟨hat, has⟩, hts hat has end ... ≤ γ + 0 : by rw [add_zero]; exact d_le_γ _ (hs.union ht))
rw [d_split _ _ (hs.union ht) ht, union_diff_right, union_inter_cancel_right, diff_eq_self.2]
exact assume a ⟨hat, has⟩, hts hat has
rw [add_zero]
rw [add_zero]; exact d_le_γ _ (hs.union ht)
exact d_le_γ _ (hs.union ht)
rw [← to_nnreal_μ, ← to_nnreal_ν, ennreal.coe_le_coe, ← nnreal.coe_le_coe]
simpa only [d, sub_le_iff_le_add, zero_add] using this
let d : set α → ℝ := λs, ((μ s).to_nnreal : ℝ) - (ν s).to_nnreal
let c : set ℝ := d '' {s | measurable_set s }
let γ : ℝ := Sup c
have hμ : ∀ s, μ s ≠ ∞ := measure_ne_top μ
have hν : ∀ s, ν s ≠ ∞ := measure_ne_top ν
have to_nnreal_μ : ∀s, ((μ s).to_nnreal : ℝ≥0∞) = μ s := (assume s, ennreal.coe_to_nnreal $ hμ _)
have to_nnreal_ν : ∀s, ((ν s).to_nnreal : ℝ≥0∞) = ν s := (assume s, ennreal.coe_to_nnreal $ hν _)
simp [d]
rw [measure_empty, measure_empty]
have d_empty : d ∅ = 0
simp
{ simp [d], rw [measure_empty, measure_empty], simp }
have d_split : ∀s t, measurable_set s → measurable_set t → d s = d (s \ t) + d (s ∩ t)
assume s t hs ht
simp only [d]
rw [measure_eq_inter_diff hs ht, measure_eq_inter_diff hs ht, ennreal.to_nnreal_add (hμ _) (hμ _), ennreal.to_nnreal_add (hν _) (hν _), nnreal.coe_add, nnreal.coe_add]
simp only [sub_eq_add_neg, neg_add]
{ assume s t hs ht, simp only [d], rw [measure_eq_inter_diff hs ht, measure_eq_inter_diff hs ht, ennreal.to_nnreal_add (hμ _) (hμ _), ennreal.to_nnreal_add (hν _) (hν _), nnreal.coe_add, nnreal.coe_add], simp only [sub_eq_add_neg, neg_add], ac_refl }
ac_refl
have d_Union : ∀(s : ℕ → set α), (∀n, measurable_set (s n)) → monotone s → tendsto (λn, d (s n)) at_top (𝓝 (d (⋃n, s n)))
assume s hs hm
refine tendsto.sub _ _; refine (nnreal.tendsto_coe.2 $ (ennreal.tendsto_to_nnreal _).comp $ tendsto_measure_Union hs hm)
refine tendsto.sub _ _
refine (nnreal.tendsto_coe.2 $ (ennreal.tendsto_to_nnreal _).comp $ tendsto_measure_Union hs hm)
refine (nnreal.tendsto_coe.2 $ (ennreal.tendsto_to_nnreal _).comp $ tendsto_measure_Union hs hm)
exact hμ _
{ assume s hs hm, refine tendsto.sub _ _; refine (nnreal.tendsto_coe.2 $ (ennreal.tendsto_to_nnreal _).comp $ tendsto_measure_Union hs hm), exact hμ _, exact hν _ }
exact hν _
have d_Inter : ∀(s : ℕ → set α), (∀n, measurable_set (s n)) → (∀n m, n ≤ m → s m ⊆ s n) → tendsto (λn, d (s n)) at_top (𝓝 (d (⋂n, s n)))
assume s hs hm
refine tendsto.sub _ _; refine (nnreal.tendsto_coe.2 $ (ennreal.tendsto_to_nnreal $ _).comp $ tendsto_measure_Inter hs hm _)
refine tendsto.sub _ _
refine (nnreal.tendsto_coe.2 $ (ennreal.tendsto_to_nnreal $ _).comp $ tendsto_measure_Inter hs hm _)
refine (nnreal.tendsto_coe.2 $ (ennreal.tendsto_to_nnreal $ _).comp $ tendsto_measure_Inter hs hm _)
{ assume s hs hm, refine tendsto.sub _ _; refine (nnreal.tendsto_coe.2 $ (ennreal.tendsto_to_nnreal $ _).comp $ tendsto_measure_Inter hs hm _), exacts [hμ _, ⟨0, hμ _⟩, hν _, ⟨0, hν _⟩] }
exacts [hμ _, ⟨0, hμ _⟩, hν _, ⟨0, hν _⟩]
have bdd_c : bdd_above c
use (μ univ).to_nnreal
rintros r ⟨s, hs, rfl⟩
refine le_trans (sub_le_self _ $ nnreal.coe_nonneg _) _
rw [nnreal.coe_le_coe, ← ennreal.coe_le_coe, to_nnreal_μ, to_nnreal_μ]
{ use (μ univ).to_nnreal, rintros r ⟨s, hs, rfl⟩, refine le_trans (sub_le_self _ $ nnreal.coe_nonneg _) _, rw [nnreal.coe_le_coe, ← ennreal.coe_le_coe, to_nnreal_μ, to_nnreal_μ], exact measure_mono (subset_univ _) }
exact measure_mono (subset_univ _)
have c_nonempty : c.nonempty := nonempty.image _ ⟨_, measurable_set.empty⟩
have d_le_γ : ∀s, measurable_set s → d s ≤ γ := assume s hs, le_cSup bdd_c ⟨s, hs, rfl⟩
have : ∀n:ℕ, ∃s : set α, measurable_set s ∧ γ - (1/2)^n < d s
assume n
have : γ - (1/2)^n < γ := sub_lt_self γ (pow_pos (half_pos zero_lt_one) n)
rcases exists_lt_of_lt_cSup c_nonempty this with ⟨r, ⟨s, hs, rfl⟩, hlt⟩
{ assume n, have : γ - (1/2)^n < γ := sub_lt_self γ (pow_pos (half_pos zero_lt_one) n), rcases exists_lt_of_lt_cSup c_nonempty this with ⟨r, ⟨s, hs, rfl⟩, hlt⟩, exact ⟨s, hs, hlt⟩ }
exact ⟨s, hs, hlt⟩
rcases classical.axiom_of_choice this with ⟨e, he⟩
change ℕ → set α at e
rw [ae_seq_set, compl_compl, measure_to_measurable]
have hf_eq := λ i, (hf i).ae_eq_mk
simp_rw [filter.eventually_eq, ←ae_all_iff] at hf_eq
exact filter.eventually.and hf_eq hp
simp only [ae_seq, hx, if_true]
rw funext (λ n, mk_eq_fun_of_mem_ae_seq_set hf hx n)
have h_ss : ae_seq_set hf p ⊆ {x | p x (λ n, f n x)}
rw [←compl_compl {x | p x (λ n, f n x)}, ae_seq_set, set.compl_subset_compl]
refine set.subset.trans (set.compl_subset_compl.mpr _) (subset_to_measurable _ _)
{ rw [←compl_compl {x | p x (λ n, f n x)}, ae_seq_set, set.compl_subset_compl], refine set.subset.trans (set.compl_subset_compl.mpr _) (subset_to_measurable _ _), exact λ x hx, hx.2, }
exact λ x hx, hx.2
have hx' := set.mem_of_subset_of_mem h_ss hx
exact hx'
rcases hf with ⟨f', h_f'_meas, hff'⟩
rcases hg with ⟨g', h_g'_meas, hgg'⟩
exact ⟨f' + g', @measurable.add _ _ _ _ m _ f' g' h_f'_meas h_g'_meas, hff'.add hgg'⟩
let g := Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm f
have hfg : f = (Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm g
simp only [linear_isometry_equiv.symm_apply_apply]
rw hfg
refine @Lp.induction α F' m _ _ _ _ 1 (μ.trim hm) _ ennreal.coe_ne_top (λ g : α →₁[μ.trim hm] F', condexp_L1_clm hm μ ((Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm g : α →₁[μ] F') = ↑((Lp_meas_to_Lp_trim_lie F' ℝ 1 μ hm).symm g)) _ _ _ g
intros c s hs hμs
rw [Lp.simple_func.coe_indicator_const, Lp_meas_to_Lp_trim_lie_symm_indicator hs hμs.ne c, condexp_L1_clm_indicator_const_Lp]
exact condexp_ind_of_measurable hs ((le_trim hm).trans_lt hμs).ne c
{ intros c s hs hμs, rw [Lp.simple_func.coe_indicator_const, Lp_meas_to_Lp_trim_lie_symm_indicator hs hμs.ne c, condexp_L1_clm_indicator_const_Lp], exact condexp_ind_of_measurable hs ((le_trim hm).trans_lt hμs).ne c, }
intros f g hf hg hfg_disj hf_eq hg_eq
rw linear_isometry_equiv.map_add
push_cast
{ intros f g hf hg hfg_disj hf_eq hg_eq, rw linear_isometry_equiv.map_add, push_cast, rw [map_add, hf_eq, hg_eq], }
rw [map_add, hf_eq, hg_eq]
refine is_closed_eq _ _
refine (condexp_L1_clm hm μ).continuous.comp (continuous_induced_dom.comp _)
{ refine (condexp_L1_clm hm μ).continuous.comp (continuous_induced_dom.comp _), exact linear_isometry_equiv.continuous _, }
exact linear_isometry_equiv.continuous _
refine continuous_induced_dom.comp _
exact ⟨g, hg_meas, ae_eq_of_ae_eq_trim hfg⟩
obtain ⟨g, hg_meas, hfg⟩ := hf
suffices : ∫ x in set.univ, μ[f|hm] x ∂μ = ∫ x in set.univ, f x ∂μ
simp_rw integral_univ at this
exact this
exact set_integral_condexp hf (@measurable_set.univ _ m)
by_cases hf : integrable f μ
refine (condexp_ae_eq_condexp_L1 _).trans _
rw condexp_L1_smul c f
refine (@condexp_ae_eq_condexp_L1 _ _ _ _ _ _ _ _ m _ _ hm _ f).mp _
refine (coe_fn_smul c (condexp_L1 hm μ f)).mono (λ x hx1 hx2, _)
{ refine (condexp_ae_eq_condexp_L1 _).trans _, rw condexp_L1_smul c f, refine (@condexp_ae_eq_condexp_L1 _ _ _ _ _ _ _ _ m _ _ hm _ f).mp _, refine (coe_fn_smul c (condexp_L1 hm μ f)).mono (λ x hx1 hx2, _), rw [hx1, pi.smul_apply, pi.smul_apply, hx2], }
rw [hx1, pi.smul_apply, pi.smul_apply, hx2]
by_cases hc : c = 0
{ rw [hc, zero_smul, zero_smul, condexp_zero], }
rw [hc, zero_smul, zero_smul, condexp_zero]
refine (condexp_undef (mt (integrable_smul_iff hc f).mp hf)).trans _
refine (@condexp_undef _ _ _ _ _ _ _ _ _ _ _ hm _ _ hf).mono (λ x hx, _)
rw [pi.zero_apply, pi.smul_apply, hx, pi.zero_apply, smul_zero]
intro f
ext1
refine ae_eq_trim_of_measurable hm (Lp.measurable _) (Lp.measurable _) _
exact (Lp_meas_subgroup_to_Lp_trim_ae_eq hm _).trans (Lp_trim_to_Lp_meas_subgroup_ae_eq hm _)
rw [Lp.norm_def, snorm_trim hm (Lp.measurable _)]
apply_instance
{ apply_instance, }
swap
rw [snorm_congr_ae (Lp_meas_subgroup_to_Lp_trim_ae_eq hm _), Lp_meas_subgroup_coe, ← Lp.norm_def]
congr
let f_meas : Lp_meas E' 𝕜 m p μ := ⟨f, hf_meas⟩
simp only [coe_fn_coe_base, subtype.coe_mk]
have hf_f_meas : f =ᵐ[μ] f_meas
refine hf_f_meas.trans _
refine Lp_meas.ae_eq_zero_of_forall_set_integral_eq_zero hm f_meas hp_ne_zero hp_ne_top _ _
intros s hs hμs
from ae_restrict_of_ae hf_f_meas
have hfg_restrict : f =ᵐ[μ.restrict s] f_meas
rw [integrable_on, integrable_congr hfg_restrict.symm]
{ intros s hs hμs, have hfg_restrict : f =ᵐ[μ.restrict s] f_meas, from ae_restrict_of_ae hf_f_meas, rw [integrable_on, integrable_congr hfg_restrict.symm], exact hf_int_finite s hs hμs, }
exact hf_int_finite s hs hμs
intros s hs hμs
from ae_restrict_of_ae hf_f_meas
have hfg_restrict : f =ᵐ[μ.restrict s] f_meas
rw integral_congr_ae hfg_restrict.symm
exact hf_zero s hs hμs
exact ⟨f', hf'_meas, hfg.symm.trans hff'⟩
obtain ⟨f', hf'_meas, hff'⟩ := hf
simp only [has_finite_integral_iff_norm] at *
calc ∫⁻ a, (ennreal.of_real ∥f a∥) ∂μ ≤ ∫⁻ (a : α), (ennreal.of_real ∥g a∥) ∂μ : lintegral_mono_ae (h.mono $ assume a h, of_real_le_of_real h) ... < ∞ : hg
simp [real.norm_eq_abs, abs_le, abs_nonneg, le_abs_self]
simp_rw [integrable, has_finite_integral, mem_ℒp, snorm_one_eq_lintegral_nnnorm]
refine induction_on₂ f g (λ f hf g hg hfi hgi, _)
simp only [integrable_mk, mk_add_mk] at hfi hgi ⊢
exact hfi.add hgi
exact ne_of_lt (has_finite_integral_coe_fn f)
rw [norm_def, ennreal.of_real_to_real]
change (snorm ⇑(0 : α →ₘ[μ] E) p μ).to_real = 0
simp [snorm_congr_ae ae_eq_fun.coe_fn_zero, snorm_zero]
by_cases hμ : μ = 0
by_cases hp : p.to_real⁻¹ = 0
{ simpa [hp, hμ, norm_def] using hC }
simpa [hp, hμ, norm_def] using hC
{ by_cases hp : p.to_real⁻¹ = 0, { simpa [hp, hμ, norm_def] using hC }, { simp [hμ, norm_def, real.zero_rpow hp] } }
simp [hμ, norm_def, real.zero_rpow hp]
let A : ℝ≥0 := (measure_univ_nnreal μ) ^ (p.to_real)⁻¹ * ⟨C, hC⟩
suffices : snorm f p μ ≤ A
{ exact ennreal.to_real_le_coe_of_le_coe this }
exact ennreal.to_real_le_coe_of_le_coe this
convert snorm_le_of_ae_bound hfC
rw [← coe_measure_univ_nnreal μ, ennreal.coe_rpow_of_ne_zero (measure_univ_nnreal_pos hμ).ne', ennreal.coe_mul]
congr
rw max_eq_left hC
apply_instance
by_cases hp_top : p = ∞
simp [hp_top, snorm_ess_sup_indicator_const_eq s c hμs]
{ simp [hp_top, snorm_ess_sup_indicator_const_eq s c hμs], }
exact snorm_indicator_const hs hp hp_top
rw snorm'_lim_eq_lintegral_liminf hp_pos.le h_lim
rw [←ennreal.le_rpow_one_div_iff (by simp [hp_pos] : 0 < 1 / p), one_div_one_div]
simp [hp_pos]
refine (lintegral_liminf_le' (λ m, ((hf m).ennnorm.pow_const _))).trans_eq _
have h_pow_liminf : at_top.liminf (λ n, snorm' (f n) p μ) ^ p = at_top.liminf (λ n, (snorm' (f n) p μ) ^ p)
have h_rpow_mono := ennreal.rpow_left_strict_mono_of_pos hp_pos
have h_rpow_surj := (ennreal.rpow_left_bijective hp_pos.ne.symm).2
refine (h_rpow_mono.order_iso_of_surjective _ h_rpow_surj).liminf_apply _ _ _ _
is_bounded_default
is_bounded_default
is_bounded_default
is_bounded_default
{ have h_rpow_mono := ennreal.rpow_left_strict_mono_of_pos hp_pos, have h_rpow_surj := (ennreal.rpow_left_bijective hp_pos.ne.symm).2, refine (h_rpow_mono.order_iso_of_surjective _ h_rpow_surj).liminf_apply _ _ _ _, all_goals { is_bounded_default }, }
all_goals { is_bounded_default }
rw h_pow_liminf
simp_rw [snorm', ← ennreal.rpow_mul, one_div, inv_mul_cancel hp_pos.ne.symm, ennreal.rpow_one]
refine ⟨h_lim_meas, _⟩
rw ennreal.tendsto_at_top_zero at h_tendsto
cases (h_tendsto 1 ennreal.zero_lt_one) with N h_tendsto_1
specialize h_tendsto_1 N (le_refl N)
have h_add : f_lim = f_lim - f N + f N
abel
rw h_add
refine lt_of_le_of_lt (snorm_add_le (h_lim_meas.sub (hf N).1) (hf N).1 hp) _
rw ennreal.add_lt_top
split
refine lt_of_le_of_lt _ ennreal.one_lt_top
simp
have h_neg : f_lim - f N = -(f N - f_lim)
{ refine lt_of_le_of_lt _ ennreal.one_lt_top, have h_neg : f_lim - f N = -(f N - f_lim), by simp, rwa [h_neg, snorm_neg], }
rwa [h_neg, snorm_neg]
exact (hf N).2
simp [snorm'_const c hq_pos, measure_univ]
simp [snorm']
have h_le : ∫⁻ (a : α), ↑(nnnorm (f a)) ^ q ∂μ ≤ ∫⁻ (a : α), (snorm_ess_sup f μ) ^ q ∂μ
refine lintegral_mono_ae _
have h_nnnorm_le_snorm_ess_sup := coe_nnnorm_ae_le_snorm_ess_sup f μ
refine h_nnnorm_le_snorm_ess_sup.mono (λ x hx, ennreal.rpow_le_rpow hx (le_of_lt hq_pos))
{ refine lintegral_mono_ae _, have h_nnnorm_le_snorm_ess_sup := coe_nnnorm_ae_le_snorm_ess_sup f μ, refine h_nnnorm_le_snorm_ess_sup.mono (λ x hx, ennreal.rpow_le_rpow hx (le_of_lt hq_pos)), }
rw [snorm', ←ennreal.rpow_one (snorm_ess_sup f μ)]
nth_rewrite 1 ←mul_inv_cancel (ne_of_lt hq_pos).symm
rw [ennreal.rpow_mul, one_div, ←ennreal.mul_rpow_of_nonneg _ _ (by simp [hq_pos.le] : 0 ≤ q⁻¹)]
simp [hq_pos.le]
refine ennreal.rpow_le_rpow _ (by simp [hq_pos.le])
rwa lintegral_const at h_le
have h_le_μ := snorm'_le_snorm'_mul_rpow_measure_univ hp0_lt hpq hf
rwa [measure_univ, ennreal.one_rpow, mul_one] at h_le_μ
simp [measure_univ]
simpa only [integrable_iff_fin_meas_supp] using fin_meas_supp.pair
rcases is_empty_or_nonempty β; resetI
resetI
resetI
rcases is_empty_or_nonempty β
{ exact subsingleton.strongly_measurable f, }
exact subsingleton.strongly_measurable f
inhabit β
exact ⟨simple_func.approx_on f hf set.univ (default β) (set.mem_univ _), λ x, simple_func.tendsto_approx_on hf (set.mem_univ _) (by simp)⟩
simp
rw [μ.inv.inv_apply hs, μ.inv_apply, set.inv_inv]
ext1 s hs
exact measurable_inv hs
apply_instance
suffices : map ((λ z : G × G, (z.2, z.2⁻¹ * z.1)) ∘ (λ z : G × G, (z.2, z.2 * z.1))) (μ.prod ν) = μ.prod ν
ext1 ⟨x, y⟩
simp
{ convert this, ext1 ⟨x, y⟩, simp }
convert this
simp_rw [← map_map (measurable_snd.prod_mk (measurable_snd.inv.mul measurable_fst)) (measurable_snd.prod_mk (measurable_snd.mul measurable_fst)), map_prod_mul_eq_swap hμ, map_prod_inv_mul_eq_swap hν]
let S := (homeomorph.shear_mul_right G).to_measurable_equiv
rw [integral_eq_lintegral_of_nonneg_ae _ hfm.ennreal_to_real]
refine hf.mp (eventually_of_forall _)
rw lintegral_congr_ae
rw [lt_top_iff_ne_top] at hx
simp [hx]
{ rw lintegral_congr_ae, refine hf.mp (eventually_of_forall _), intros x hx, rw [lt_top_iff_ne_top] at hx, simp [hx] }
intros x hx
exact (eventually_of_forall $ λ x, ennreal.to_real_nonneg)
rw L1.norm_def
congr' 1
apply lintegral_congr_ae
filter_upwards [Lp.coe_fn_pos_part f₁, hf.coe_fn_to_L1]
assume a h₁ h₂
rw [h₁, h₂, ennreal.of_real]
congr' 1
apply nnreal.eq
simp [real.norm_of_nonneg, le_max_right, real.coe_to_nnreal]
rw L1.norm_def
congr' 1
apply lintegral_congr_ae
filter_upwards [Lp.coe_fn_neg_part f₁, hf.coe_fn_to_L1]
assume a h₁ h₂
rw [h₁, h₂, ennreal.of_real]
congr' 1
apply nnreal.eq
simp only [real.norm_of_nonneg, min_le_right, neg_nonneg, real.coe_to_nnreal', subtype.coe_mk]
rw [← max_neg_neg, coe_nnnorm, neg_zero, real.norm_of_nonneg (le_max_right (-f a) 0)]
rw [eq₁, eq₂, integral, dif_pos]
exact L1.integral_eq_norm_pos_part_sub _
rcases is_compact.exists_bound_of_continuous_on ht hg with ⟨C, hC⟩
rw [integrable_on, ← mem_ℒp_one_iff_integrable] at hf ⊢
have : ∀ᵐ x ∂(μ.restrict s), ∥f x * g x∥ ≤ C * ∥f x∥
filter_upwards [ae_restrict_mem hs]
assume x hx
rw [real.norm_eq_abs, abs_mul, mul_comm, real.norm_eq_abs]
apply mul_le_mul_of_nonneg_right (hC x (hst hx)) (abs_nonneg _)
{ filter_upwards [ae_restrict_mem hs], assume x hx, rw [real.norm_eq_abs, abs_mul, mul_comm, real.norm_eq_abs], apply mul_le_mul_of_nonneg_right (hC x (hst hx)) (abs_nonneg _) }
exact mem_ℒp.of_le_mul hf (hf.ae_measurable.mul ((hg.mono hst).ae_measurable hs)) this
let φ := λ i, Ioi (a i)
have hφ : ae_cover (μ.restrict $ Iic b) l φ := ae_cover_Ioi ha
have hfi : ∀ i, integrable_on f (φ i) (μ.restrict $ Iic b)
intro i
rw [integrable_on, measure.restrict_restrict (hφ.measurable i)]
{ intro i, rw [integrable_on, measure.restrict_restrict (hφ.measurable i)], exact hfi i }
exact hfi i
refine hφ.integrable_of_integral_norm_tendsto hcg _ hfm.restrict hfi (h.congr' _)
filter_upwards [ha.eventually (eventually_le_at_bot b)]
intros i hai
rw [interval_integral.integral_of_le hai, measure.restrict_restrict (hφ.measurable i)]
refl
{ erw [ae_measurable_indicator_iff, measure.restrict_restrict, Iic_inter_Ioc_of_le], { rw min₁₂, exact (h_int' h₀).1.ae_measurable }, { exact le_max_of_le_right h₀.2 }, exact measurable_set_Iic, exact measurable_set_Iic }
exact measurable_set_Iic
refine eventually_of_forall (λ (x : α), eventually_of_forall (λ (t : α), _))
dsimp [indicator]
split_ifs ; simp
simp
simp
{ refine eventually_of_forall (λ (x : α), eventually_of_forall (λ (t : α), _)), dsimp [indicator], split_ifs ; simp }
split_ifs
have : ∀ᵐ t ∂μ.restrict (Ι b₁ b₂), t < b₀ ∨ b₀ < t
apply ae_restrict_of_ae
apply eventually.mono (compl_mem_ae_iff.mpr hb₀)
intros x hx
{ apply ae_restrict_of_ae, apply eventually.mono (compl_mem_ae_iff.mpr hb₀), intros x hx, exact ne.lt_or_lt hx }
exact ne.lt_or_lt hx
apply this.mono
rintros x₀ (hx₀ | hx₀)
have : ∀ᶠ x in 𝓝[Icc b₁ b₂] b₀, {t : α | t ≤ x}.indicator f x₀ = f x₀
apply mem_nhds_within_of_mem_nhds
apply eventually.mono (Ioi_mem_nhds hx₀)
intros x hx
simp [hx.le]
{ apply mem_nhds_within_of_mem_nhds, apply eventually.mono (Ioi_mem_nhds hx₀), intros x hx, simp [hx.le] }
apply continuous_within_at_const.congr_of_eventually_eq this
{ have : ∀ᶠ x in 𝓝[Icc b₁ b₂] b₀, {t : α | t ≤ x}.indicator f x₀ = f x₀, { apply mem_nhds_within_of_mem_nhds, apply eventually.mono (Ioi_mem_nhds hx₀), intros x hx, simp [hx.le] }, apply continuous_within_at_const.congr_of_eventually_eq this, simp [hx₀.le] }
simp [hx₀.le]
have : ∀ᶠ x in 𝓝[Icc b₁ b₂] b₀, {t : α | t ≤ x}.indicator f x₀ = 0
apply mem_nhds_within_of_mem_nhds
apply eventually.mono (Iio_mem_nhds hx₀)
intros x hx
simp [hx]
{ apply mem_nhds_within_of_mem_nhds, apply eventually.mono (Iio_mem_nhds hx₀), intros x hx, simp [hx] }
apply continuous_within_at_const.congr_of_eventually_eq this
{ have h₁₂ : b₁ ≤ b₂ := h₀.1.trans h₀.2, have min₁₂ : min b₁ b₂ = b₁ := min_eq_left h₁₂, have h_int' : ∀ {x}, x ∈ Icc b₁ b₂ → interval_integrable f μ b₁ x, { rintros x ⟨h₁, h₂⟩, apply h_int.mono_set, apply interval_subset_interval, { exact ⟨min_le_of_left_le (min_le_right a b₁), h₁.trans (h₂.trans $ le_max_of_le_right $ le_max_right _ _)⟩ }, { exact ⟨min_le_of_left_le $ (min_le_right _ _).trans h₁, le_max_of_le_right $ h₂.trans $ le_max_right _ _⟩ } }, have : ∀ b ∈ Icc b₁ b₂, ∫ x in a..b, f x ∂μ = ∫ x in a..b₁, f x ∂μ + ∫ x in b₁..b, f x ∂μ, { rintros b ⟨h₁, h₂⟩, rw ← integral_add_adjacent_intervals _ (h_int' ⟨h₁, h₂⟩), apply h_int.mono_set, apply interval_subset_interval, { exact ⟨min_le_of_left_le (min_le_left a b₁), le_max_of_le_right (le_max_left _ _)⟩ }, { exact ⟨min_le_of_left_le (min_le_right _ _), le_max_of_le_right (h₁.trans $ h₂.trans (le_max_right a b₂))⟩ } }, apply continuous_within_at.congr _ this (this _ h₀), clear this, refine continuous_within_at_const.add _, have : (λ b, ∫ x in b₁..b, f x ∂μ) =ᶠ[𝓝[Icc b₁ b₂] b₀] λ b, ∫ x in b₁..b₂, indicator {x | x ≤ b} f x ∂ μ, { apply eventually_eq_of_mem self_mem_nhds_within, exact λ b b_in, (integral_indicator b_in).symm }, apply continuous_within_at.congr_of_eventually_eq _ this (integral_indicator h₀).symm, have : interval_integrable (λ x, ∥f x∥) μ b₁ b₂, from interval_integrable.norm (h_int' $ right_mem_Icc.mpr h₁₂), refine continuous_within_at_of_dominated_interval _ _ _ this _ ; clear this, { apply eventually.mono (self_mem_nhds_within), intros x hx, erw [ae_measurable_indicator_iff, measure.restrict_restrict, Iic_inter_Ioc_of_le], { rw min₁₂, exact (h_int' hx).1.ae_measurable }, { exact le_max_of_le_right hx.2 }, exacts [measurable_set_Iic, measurable_set_Iic] }, { erw [ae_measurable_indicator_iff, measure.restrict_restrict, Iic_inter_Ioc_of_le], { rw min₁₂, exact (h_int' h₀).1.ae_measurable }, { exact le_max_of_le_right h₀.2 }, exact measurable_set_Iic, exact measurable_set_Iic }, { refine eventually_of_forall (λ (x : α), eventually_of_forall (λ (t : α), _)), dsimp [indicator], split_ifs ; simp }, { have : ∀ᵐ t ∂μ.restrict (Ι b₁ b₂), t < b₀ ∨ b₀ < t, { apply ae_restrict_of_ae, apply eventually.mono (compl_mem_ae_iff.mpr hb₀), intros x hx, exact ne.lt_or_lt hx }, apply this.mono, rintros x₀ (hx₀ | hx₀), { have : ∀ᶠ x in 𝓝[Icc b₁ b₂] b₀, {t : α | t ≤ x}.indicator f x₀ = f x₀, { apply mem_nhds_within_of_mem_nhds, apply eventually.mono (Ioi_mem_nhds hx₀), intros x hx, simp [hx.le] }, apply continuous_within_at_const.congr_of_eventually_eq this, simp [hx₀.le] }, { have : ∀ᶠ x in 𝓝[Icc b₁ b₂] b₀, {t : α | t ≤ x}.indicator f x₀ = 0, { apply mem_nhds_within_of_mem_nhds, apply eventually.mono (Iio_mem_nhds hx₀), intros x hx, simp [hx] }, apply continuous_within_at_const.congr_of_eventually_eq this, simp [hx₀] } } }
simp [hx₀]
apply continuous_within_at_of_not_mem_closure
rwa [closure_Icc]
exact FTC_filter.nhds_Icc
haveI : fact (x ∈ set.Icc (min a b) (max a b)) := h
refine (normed_space.eq_iff_forall_dual_eq ℝ).2 (λ g, _)
rw [← g.interval_integral_comp_comm f'int, g.map_sub]
exact integral_eq_sub_of_has_deriv_right_of_le_real' hab (g.continuous.comp_continuous_on hcont) (λ x hx, g.has_fderiv_at.comp_has_deriv_within_at x (hderiv x hx)) (g.integrable_comp ((interval_integrable_iff_integrable_Icc_of_le hab).1 f'int))
simpa only [mul_comm c] using integral_comp_mul_right f hc
simpa only [one_mul, one_smul, inv_one] using integral_comp_sub_mul f one_ne_zero d
by_cases h₀ : b₀ ∈ Icc b₁ b₂
have h₁₂ : b₁ ≤ b₂ := h₀.1.trans h₀.2
have min₁₂ : min b₁ b₂ = b₁ := min_eq_left h₁₂
have h_int' : ∀ {x}, x ∈ Icc b₁ b₂ → interval_integrable f μ b₁ x
rintros x ⟨h₁, h₂⟩
apply h_int.mono_set
apply interval_subset_interval
exact ⟨min_le_of_left_le (min_le_right a b₁), h₁.trans (h₂.trans $ le_max_of_le_right $ le_max_right _ _)⟩
{ exact ⟨min_le_of_left_le (min_le_right a b₁), h₁.trans (h₂.trans $ le_max_of_le_right $ le_max_right _ _)⟩ }
exact ⟨min_le_of_left_le $ (min_le_right _ _).trans h₁, le_max_of_le_right $ h₂.trans $ le_max_right _ _⟩
{ rintros x ⟨h₁, h₂⟩, apply h_int.mono_set, apply interval_subset_interval, { exact ⟨min_le_of_left_le (min_le_right a b₁), h₁.trans (h₂.trans $ le_max_of_le_right $ le_max_right _ _)⟩ }, { exact ⟨min_le_of_left_le $ (min_le_right _ _).trans h₁, le_max_of_le_right $ h₂.trans $ le_max_right _ _⟩ } }
have : ∀ b ∈ Icc b₁ b₂, ∫ x in a..b, f x ∂μ = ∫ x in a..b₁, f x ∂μ + ∫ x in b₁..b, f x ∂μ
rintros b ⟨h₁, h₂⟩
rw ← integral_add_adjacent_intervals _ (h_int' ⟨h₁, h₂⟩)
apply h_int.mono_set
apply interval_subset_interval
{ exact ⟨min_le_of_left_le (min_le_left a b₁), le_max_of_le_right (le_max_left _ _)⟩ }
exact ⟨min_le_of_left_le (min_le_left a b₁), le_max_of_le_right (le_max_left _ _)⟩
exact ⟨min_le_of_left_le (min_le_right _ _), le_max_of_le_right (h₁.trans $ h₂.trans (le_max_right a b₂))⟩
{ rintros b ⟨h₁, h₂⟩, rw ← integral_add_adjacent_intervals _ (h_int' ⟨h₁, h₂⟩), apply h_int.mono_set, apply interval_subset_interval, { exact ⟨min_le_of_left_le (min_le_left a b₁), le_max_of_le_right (le_max_left _ _)⟩ }, { exact ⟨min_le_of_left_le (min_le_right _ _), le_max_of_le_right (h₁.trans $ h₂.trans (le_max_right a b₂))⟩ } }
clear this
apply continuous_within_at.congr _ this (this _ h₀)
refine continuous_within_at_const.add _
have : (λ b, ∫ x in b₁..b, f x ∂μ) =ᶠ[𝓝[Icc b₁ b₂] b₀] λ b, ∫ x in b₁..b₂, indicator {x | x ≤ b} f x ∂ μ
apply eventually_eq_of_mem self_mem_nhds_within
{ apply eventually_eq_of_mem self_mem_nhds_within, exact λ b b_in, (integral_indicator b_in).symm }
exact λ b b_in, (integral_indicator b_in).symm
apply continuous_within_at.congr_of_eventually_eq _ this (integral_indicator h₀).symm
have : interval_integrable (λ x, ∥f x∥) μ b₁ b₂
from interval_integrable.norm (h_int' $ right_mem_Icc.mpr h₁₂)
refine continuous_within_at_of_dominated_interval _ _ _ this _
refine continuous_within_at_of_dominated_interval _ _ _ this _ ; clear this
clear this
clear this
clear this
clear this
apply eventually.mono (self_mem_nhds_within)
intros x hx
erw [ae_measurable_indicator_iff, measure.restrict_restrict, Iic_inter_Ioc_of_le]
rw min₁₂
{ rw min₁₂, exact (h_int' hx).1.ae_measurable }
exact (h_int' hx).1.ae_measurable
{ exact le_max_of_le_right hx.2 }
exact le_max_of_le_right hx.2
{ apply eventually.mono (self_mem_nhds_within), intros x hx, erw [ae_measurable_indicator_iff, measure.restrict_restrict, Iic_inter_Ioc_of_le], { rw min₁₂, exact (h_int' hx).1.ae_measurable }, { exact le_max_of_le_right hx.2 }, exacts [measurable_set_Iic, measurable_set_Iic] }
exacts [measurable_set_Iic, measurable_set_Iic]
erw [ae_measurable_indicator_iff, measure.restrict_restrict, Iic_inter_Ioc_of_le]
rw min₁₂
{ rw min₁₂, exact (h_int' h₀).1.ae_measurable }
exact (h_int' h₀).1.ae_measurable
{ exact le_max_of_le_right h₀.2 }
exact le_max_of_le_right h₀.2
exact measurable_set_Iic
rw [lintegral_const, measure.restrict_apply_univ]
set c : ℝ≥0 → ℝ≥0∞ := coe
set F := λ a:α, ⨆n, f n a
have hF : measurable F := measurable_supr hf
refine le_antisymm _ (supr_lintegral_le _)
rw [lintegral_eq_nnreal]
refine supr_le (assume s, supr_le (assume hsf, _))
refine ennreal.le_of_forall_lt_one_mul_le (assume a ha, _)
rcases ennreal.lt_iff_exists_coe.1 ha with ⟨r, rfl, ha⟩
have ha : r < 1 := ennreal.coe_lt_coe.1 ha
let rs := s.map (λa, r * a)
have eq_rs : (const α r : α →ₛ ℝ≥0∞) * map c s = rs.map c
exact ennreal.coe_mul.symm
{ ext1 a, exact ennreal.coe_mul.symm }
ext1 a
have eq : ∀p, (rs.map c) ⁻¹' {p} = (⋃n, (rs.map c) ⁻¹' {p} ∩ {a | p ≤ f n a})
assume p
rw [← inter_Union, ← inter_univ ((map c rs) ⁻¹' {p})] {occs := occurrences.pos [1]}
refine set.ext (assume x, and_congr_right $ assume hx, (true_iff _).2 _)
simp [p_eq]
{ simp [p_eq] }
by_cases p_eq : p = 0
subst hx
simp at hx
rwa [(≠), ← ennreal.coe_eq_zero]
have : r * s x ≠ 0
{ rwa [(≠), ← ennreal.coe_eq_zero] }
refine mt _ this
assume h
rw [h, mul_zero]
have : s x ≠ 0
{ refine mt _ this, assume h, rw [h, mul_zero] }
have : (rs.map c) x < ⨆ (n : ℕ), f n x
refine lt_of_lt_of_le (ennreal.coe_lt_coe.2 (_)) (hsf x)
simpa [rs]
suffices : r * s x < 1 * s x
{ refine lt_of_lt_of_le (ennreal.coe_lt_coe.2 (_)) (hsf x), suffices : r * s x < 1 * s x, simpa [rs], exact mul_lt_mul_of_pos_right ha (pos_iff_ne_zero.2 this) }
exact mul_lt_mul_of_pos_right ha (pos_iff_ne_zero.2 this)
rcases lt_supr_iff.1 this with ⟨i, hi⟩
{ assume p, rw [← inter_Union, ← inter_univ ((map c rs) ⁻¹' {p})] {occs := occurrences.pos [1]}, refine set.ext (assume x, and_congr_right $ assume hx, (true_iff _).2 _), by_cases p_eq : p = 0, { simp [p_eq] }, simp at hx, subst hx, have : r * s x ≠ 0, { rwa [(≠), ← ennreal.coe_eq_zero] }, have : s x ≠ 0, { refine mt _ this, assume h, rw [h, mul_zero] }, have : (rs.map c) x < ⨆ (n : ℕ), f n x, { refine lt_of_lt_of_le (ennreal.coe_lt_coe.2 (_)) (hsf x), suffices : r * s x < 1 * s x, simpa [rs], exact mul_lt_mul_of_pos_right ha (pos_iff_ne_zero.2 this) }, rcases lt_supr_iff.1 this with ⟨i, hi⟩, exact mem_Union.2 ⟨i, le_of_lt hi⟩ }
exact mem_Union.2 ⟨i, le_of_lt hi⟩
have mono : ∀r:ℝ≥0∞, monotone (λn, (rs.map c) ⁻¹' {r} ∩ {a | r ≤ f n a})
assume r i j h
refine inter_subset_inter (subset.refl _) _
exact le_trans hx (h_mono h x)
{ assume r i j h, refine inter_subset_inter (subset.refl _) _, assume x hx, exact le_trans hx (h_mono h x) }
assume x hx
have h_meas : ∀n, measurable_set {a : α | ⇑(map c rs) a ≤ f n a} := assume n, measurable_set_le (simple_func.measurable _) (hf n)
calc (r:ℝ≥0∞) * (s.map c).lintegral μ = ∑ r in (rs.map c).range, r * μ ((rs.map c) ⁻¹' {r}) : by rw [← const_mul_lintegral, eq_rs, simple_func.lintegral] ... ≤ ∑ r in (rs.map c).range, r * μ (⋃n, (rs.map c) ⁻¹' {r} ∩ {a | r ≤ f n a}) : le_of_eq (finset.sum_congr rfl $ assume x hx, by rw ← eq) ... ≤ ∑ r in (rs.map c).range, (⨆n, r * μ ((rs.map c) ⁻¹' {r} ∩ {a | r ≤ f n a})) : le_of_eq (finset.sum_congr rfl $ assume x hx, begin rw [measure_Union_eq_supr _ (directed_of_sup $ mono x), ennreal.mul_supr], { assume i, refine ((rs.map c).measurable_set_preimage _).inter _, exact hf i measurable_set_Ici } end) ... ≤ ⨆n, ∑ r in (rs.map c).range, r * μ ((rs.map c) ⁻¹' {r} ∩ {a | r ≤ f n a}) : begin refine le_of_eq _, rw [ennreal.finset_sum_supr_nat], assume p i j h, exact mul_le_mul_left' (measure_mono $ mono p h) _ end ... ≤ (⨆n:ℕ, ((rs.map c).restrict {a | (rs.map c) a ≤ f n a}).lintegral μ) : begin refine supr_le_supr (assume n, _), rw [restrict_lintegral _ (h_meas n)], { refine le_of_eq (finset.sum_congr rfl $ assume r hr, _), congr' 2 with a, refine and_congr_right _, simp {contextual := tt} } end ... ≤ (⨆n, ∫⁻ a, f n a ∂μ) : begin refine supr_le_supr (assume n, _), rw [← simple_func.lintegral_eq_lintegral], refine lintegral_mono (assume a, _), simp only [map_apply] at h_meas, simp only [coe_map, restrict_apply _ (h_meas _), (∘)], exact indicator_apply_le id, end
rw [← const_mul_lintegral, eq_rs, simple_func.lintegral]
rw ← eq
rw [measure_Union_eq_supr _ (directed_of_sup $ mono x), ennreal.mul_supr]
assume i
refine ((rs.map c).measurable_set_preimage _).inter _
exact hf i measurable_set_Ici
refine le_of_eq _
rw [ennreal.finset_sum_supr_nat]
assume p i j h
exact mul_le_mul_left' (measure_mono $ mono p h) _
refine supr_le_supr (assume n, _)
rw [restrict_lintegral _ (h_meas n)]
refine le_of_eq (finset.sum_congr rfl $ assume r hr, _)
congr' 2 with a
refine and_congr_right _
simp {contextual := tt}
refine supr_le_supr (assume n, _)
rw [← simple_func.lintegral_eq_lintegral]
refine lintegral_mono (assume a, _)
simp only [map_apply] at h_meas
simp only [coe_map, restrict_apply _ (h_meas _), (∘)]
exact indicator_apply_le id
simp only [supr_eapprox_apply, hf, hg]
funext a
congr
refl
{ refl }
rw [ennreal.supr_add_supr_of_monotone]
exact monotone_eapprox _ h a
{ assume i j h, exact monotone_eapprox _ h a }
assume i j h
exact monotone_eapprox _ h a
assume i j h
rw [lintegral_supr]
congr
rw [← simple_func.add_lintegral, ← simple_func.lintegral_eq_lintegral]
funext n
{ congr, funext n, rw [← simple_func.add_lintegral, ← simple_func.lintegral_eq_lintegral], refl }
refl
{ measurability, }
measurability
exact add_le_add (monotone_eapprox _ h _) (monotone_eapprox _ h _)
assume i j h a
refine (ennreal.supr_add_supr_of_monotone _ _).symm; { assume i j h, exact simple_func.lintegral_mono (monotone_eapprox _ h) (le_refl μ) }
refine (ennreal.supr_add_supr_of_monotone _ _).symm
exact simple_func.lintegral_mono (monotone_eapprox _ h) (le_refl μ)
assume i j h
rw [lintegral_eq_supr_eapprox_lintegral hf, lintegral_eq_supr_eapprox_lintegral hg]
rwa [with_density_apply _ measurable_set.univ, measure.restrict_univ, lt_top_iff_ne_top]
set S : set α := { x | f x < 0 } with hSdef
have hS : measurable_set S := measurable_set_lt hf measurable_const
refine ⟨S, hS, _, _⟩
rw [with_density_apply _ hS, hSdef]
have hf0 : ∀ᵐ x ∂μ, x ∈ S → ennreal.of_real (f x) = 0
refine ae_of_all _ (λ _ hx, _)
{ refine ae_of_all _ (λ _ hx, _), rw [ennreal.of_real_eq_zero.2 (le_of_lt hx)] }
rw [ennreal.of_real_eq_zero.2 (le_of_lt hx)]
rw set_lintegral_congr_fun hS hf0
{ rw [with_density_apply _ hS, hSdef], have hf0 : ∀ᵐ x ∂μ, x ∈ S → ennreal.of_real (f x) = 0, { refine ae_of_all _ (λ _ hx, _), rw [ennreal.of_real_eq_zero.2 (le_of_lt hx)] }, rw set_lintegral_congr_fun hS hf0, exact lintegral_zero }
exact lintegral_zero
rw [with_density_apply _ hS.compl, hSdef]
have hf0 : ∀ᵐ x ∂μ, x ∈ Sᶜ → ennreal.of_real (-f x) = 0
refine ae_of_all _ (λ x hx, _)
rw ennreal.of_real_eq_zero.2
{ refine ae_of_all _ (λ x hx, _), rw ennreal.of_real_eq_zero.2, rwa [neg_le, neg_zero, ← not_lt] }
rwa [neg_le, neg_zero, ← not_lt]
rw set_lintegral_congr_fun hS.compl hf0
exact lintegral_zero
simp only [coe_range, sep_mem_eq, set.mem_range, function.comp_app, coe_map, finset.coe_filter, ← mem_preimage, inter_comm, preimage_inter_range]
apply preimage_comp
simp only [coe_restrict _ hs, indicator_le_indicator (H x)]
simp only [restrict_of_not_measurable hs, le_refl]
rw ←@lintegral_zero_fun α _ μ
refine lintegral_congr_ae _
suffices h_mul_zero : f * g =ᵐ[μ] 0 * g
rwa zero_mul at h_mul_zero
from ae_eq_zero_of_lintegral_rpow_eq_zero hp0_lt hf hf_zero
have hf_eq_zero : f =ᵐ[μ] 0
exact filter.eventually_eq.mul hf_eq_zero (ae_eq_refl g)
rw ← integral_add_compl h_meas hfi.norm
congr' 1
refine set_integral_congr h_meas (λ x hx, _)
dsimp only
rw [real.norm_eq_abs, abs_eq_self.mpr _]
exact hx
congr' 1
rw ← integral_neg
refine set_integral_congr h_meas.compl (λ x hx, _)
dsimp only
rw [real.norm_eq_abs, abs_eq_neg_self.mpr _]
rw [set.mem_compl_iff, set.nmem_set_of_eq] at hx
linarith
congr
ext1 x
rw ← set_integral_neg_eq_set_integral_nonpos hf hfi
simp
intro f
rw one_mul
exact norm_Lp_to_Lp_restrict_le s f
rw [set_to_L1s, norm_eq_sum_mul f]
exact simple_func.norm_set_to_simple_func_le_sum_mul_norm T hT_norm _
simp only [simple_func.coe_const, simple_func.const_zero, simple_func.coe_zero, set.piecewise_eq_indicator, simple_func.coe_piecewise]
{ refine ⟨λ x, c, λ x, _, lower_semicontinuous_const, by simp only [ennreal.top_add, le_top, h]⟩, simp only [simple_func.coe_const, simple_func.const_zero, simple_func.coe_zero, set.piecewise_eq_indicator, simple_func.coe_piecewise], exact set.indicator_le_self _ _ _ }
exact set.indicator_le_self _ _ _
by_cases hc : c = 0
refine ⟨λ x, 0, _, lower_semicontinuous_const, _⟩
simp only [hc, set.indicator_zero', pi.zero_apply, simple_func.const_zero, implies_true_iff, eq_self_iff_true, simple_func.coe_zero, set.piecewise_eq_indicator, simple_func.coe_piecewise, le_zero_iff]
{ simp only [hc, set.indicator_zero', pi.zero_apply, simple_func.const_zero, implies_true_iff, eq_self_iff_true, simple_func.coe_zero, set.piecewise_eq_indicator, simple_func.coe_piecewise, le_zero_iff] }
{ refine ⟨λ x, 0, _, lower_semicontinuous_const, _⟩, { simp only [hc, set.indicator_zero', pi.zero_apply, simple_func.const_zero, implies_true_iff, eq_self_iff_true, simple_func.coe_zero, set.piecewise_eq_indicator, simple_func.coe_piecewise, le_zero_iff] }, { simp only [lintegral_const, zero_mul, zero_le, ennreal.coe_zero] } }
simp only [lintegral_const, zero_mul, zero_le, ennreal.coe_zero]
have : μ s < μ s + ε / c
have : (0 : ℝ≥0∞) < ε / c := ennreal.div_pos_iff.2 ⟨ε0, ennreal.coe_ne_top⟩
simpa using ennreal.add_lt_add_left _ this
simpa only [hs, hc, lt_top_iff_ne_top, true_and, simple_func.coe_const, function.const_apply, lintegral_const, ennreal.coe_indicator, set.univ_inter, ennreal.coe_ne_top, measurable_set.univ, with_top.mul_eq_top_iff, simple_func.const_zero, or_false, lintegral_indicator, ennreal.coe_eq_zero, ne.def, not_false_iff, simple_func.coe_zero, set.piecewise_eq_indicator, simple_func.coe_piecewise, false_and, restrict_apply] using h
{ have : (0 : ℝ≥0∞) < ε / c := ennreal.div_pos_iff.2 ⟨ε0, ennreal.coe_ne_top⟩, simpa using ennreal.add_lt_add_left _ this, simpa only [hs, hc, lt_top_iff_ne_top, true_and, simple_func.coe_const, function.const_apply, lintegral_const, ennreal.coe_indicator, set.univ_inter, ennreal.coe_ne_top, measurable_set.univ, with_top.mul_eq_top_iff, simple_func.const_zero, or_false, lintegral_indicator, ennreal.coe_eq_zero, ne.def, not_false_iff, simple_func.coe_zero, set.piecewise_eq_indicator, simple_func.coe_piecewise, false_and, restrict_apply] using h }
obtain ⟨u, su, u_open, μu⟩ : ∃ u ⊇ s, is_open u ∧ μ u < μ s + ε / c := s.exists_is_open_lt_of_lt _ this
refine ⟨set.indicator u (λ x, c), λ x, _, u_open.lower_semicontinuous_indicator (zero_le _), _⟩
simp only [simple_func.coe_const, simple_func.const_zero, simple_func.coe_zero, set.piecewise_eq_indicator, simple_func.coe_piecewise]
{ simp only [simple_func.coe_const, simple_func.const_zero, simple_func.coe_zero, set.piecewise_eq_indicator, simple_func.coe_piecewise], exact set.indicator_le_indicator_of_subset su (λ x, zero_le _) _ }
exact set.indicator_le_indicator_of_subset su (λ x, zero_le _) _
suffices : (c : ℝ≥0∞) * μ u ≤ c * μ s + ε
simpa only [hs, u_open.measurable_set, simple_func.coe_const, function.const_apply, lintegral_const, ennreal.coe_indicator, set.univ_inter, measurable_set.univ, simple_func.const_zero, lintegral_indicator, simple_func.coe_zero, set.piecewise_eq_indicator, simple_func.coe_piecewise, restrict_apply]
calc (c : ℝ≥0∞) * μ u ≤ c * (μ s + ε / c) : ennreal.mul_le_mul (le_refl _) μu.le ... = c * μ s + ε : begin simp_rw [mul_add], rw ennreal.mul_div_cancel' _ ennreal.coe_ne_top, simpa using hc, end
simp_rw [mul_add]
rw ennreal.mul_div_cancel' _ ennreal.coe_ne_top
simpa using hc
{ let f := simple_func.piecewise s hs (simple_func.const α c) (simple_func.const α 0), by_cases h : ∫⁻ x, f x ∂μ = ⊤, { refine ⟨λ x, c, λ x, _, lower_semicontinuous_const, by simp only [ennreal.top_add, le_top, h]⟩, simp only [simple_func.coe_const, simple_func.const_zero, simple_func.coe_zero, set.piecewise_eq_indicator, simple_func.coe_piecewise], exact set.indicator_le_self _ _ _ }, by_cases hc : c = 0, { refine ⟨λ x, 0, _, lower_semicontinuous_const, _⟩, { simp only [hc, set.indicator_zero', pi.zero_apply, simple_func.const_zero, implies_true_iff, eq_self_iff_true, simple_func.coe_zero, set.piecewise_eq_indicator, simple_func.coe_piecewise, le_zero_iff] }, { simp only [lintegral_const, zero_mul, zero_le, ennreal.coe_zero] } }, have : μ s < μ s + ε / c, { have : (0 : ℝ≥0∞) < ε / c := ennreal.div_pos_iff.2 ⟨ε0, ennreal.coe_ne_top⟩, simpa using ennreal.add_lt_add_left _ this, simpa only [hs, hc, lt_top_iff_ne_top, true_and, simple_func.coe_const, function.const_apply, lintegral_const, ennreal.coe_indicator, set.univ_inter, ennreal.coe_ne_top, measurable_set.univ, with_top.mul_eq_top_iff, simple_func.const_zero, or_false, lintegral_indicator, ennreal.coe_eq_zero, ne.def, not_false_iff, simple_func.coe_zero, set.piecewise_eq_indicator, simple_func.coe_piecewise, false_and, restrict_apply] using h }, obtain ⟨u, su, u_open, μu⟩ : ∃ u ⊇ s, is_open u ∧ μ u < μ s + ε / c := s.exists_is_open_lt_of_lt _ this, refine ⟨set.indicator u (λ x, c), λ x, _, u_open.lower_semicontinuous_indicator (zero_le _), _⟩, { simp only [simple_func.coe_const, simple_func.const_zero, simple_func.coe_zero, set.piecewise_eq_indicator, simple_func.coe_piecewise], exact set.indicator_le_indicator_of_subset su (λ x, zero_le _) _ }, { suffices : (c : ℝ≥0∞) * μ u ≤ c * μ s + ε, by simpa only [hs, u_open.measurable_set, simple_func.coe_const, function.const_apply, lintegral_const, ennreal.coe_indicator, set.univ_inter, measurable_set.univ, simple_func.const_zero, lintegral_indicator, simple_func.coe_zero, set.piecewise_eq_indicator, simple_func.coe_piecewise, restrict_apply], calc (c : ℝ≥0∞) * μ u ≤ c * (μ s + ε / c) : ennreal.mul_le_mul (le_refl _) μu.le ... = c * μ s + ε : begin simp_rw [mul_add], rw ennreal.mul_div_cancel' _ ennreal.coe_ne_top, simpa using hc, end } }
rcases h₁ (ennreal.half_pos ε0).ne' with ⟨g₁, f₁_le_g₁, g₁cont, g₁int⟩
rcases h₂ (ennreal.half_pos ε0).ne' with ⟨g₂, f₂_le_g₂, g₂cont, g₂int⟩
refine ⟨λ x, g₁ x + g₂ x, λ x, add_le_add (f₁_le_g₁ x) (f₂_le_g₂ x), g₁cont.add g₂cont, _⟩
simp only [simple_func.coe_add, ennreal.coe_add, pi.add_apply]
rw [lintegral_add f₁.measurable.coe_nnreal_ennreal f₂.measurable.coe_nnreal_ennreal, lintegral_add g₁cont.measurable.coe_nnreal_ennreal g₂cont.measurable.coe_nnreal_ennreal]
convert add_le_add g₁int g₂int using 1
rw ← ennreal.add_halves ε
conv_lhs { rw ← ennreal.add_halves ε }
abel
induction f using measure_theory.simple_func.induction with c s hs f₁ f₂ H h₁ h₂ generalizing ε
let f := simple_func.piecewise s hs (simple_func.const α c) (simple_func.const α 0)
by_cases h : ∫⁻ x, f x ∂μ = ⊤
refine ⟨λ x, c, λ x, _, lower_semicontinuous_const, by simp only [ennreal.top_add, le_top, h]⟩
simp only [ennreal.top_add, le_top, h]
simpa using (@measurable_set.empty α _).compl
simp only [join_apply hs]; exact measurable_lintegral (measurable_coe hs)
exact measurable_lintegral (measurable_coe hs)
simp only [join_apply hs]
haveI : locally_compact_space G := K₀.locally_compact_space_of_group
rw [haar_measure_apply K₀.2.1.measurable_set, ennreal.div_self]
exact haar_content_outer_measure_self_pos
rw [← pos_iff_ne_zero]
{ rw [← pos_iff_ne_zero], exact haar_content_outer_measure_self_pos }
exact ne_of_lt (content.outer_measure_lt_top_of_is_compact _ K₀.2.1)
rw interior_pi_set
simp only [interior_Icc, univ_pi_nonempty_iff, nonempty_Ioo, implies_true_iff, zero_lt_one]
classical
induction I using finset.induction_on with i I hiI ihI hI
simp
{ simp }
simp only [finset.mem_insert] at hI
rw [finset.set_bUnion_insert, hm, ihI, finset.sum_insert hiI]
exacts [λ i hi j hj hij, (hI i (or.inr hi) j (or.inr hj) hij), is_metric_separated.finset_Union_right (λ j hj, hI i (or.inl rfl) j (or.inr hj) (ne_of_mem_of_not_mem hj hiI).symm)]
rw [← map_coe_Ioi_at_bot, tendsto_map'_iff]
simp only [mk_metric', outer_measure.supr_apply, supr_subtype']
exact tendsto_at_bot_supr (λ r r' hr, mono_pre _ hr _)
push_neg at H
by_contra H
suffices : ∀ (c : ℝ≥0), c ≠ 0 → μH[d₂] s ≤ c * μH[d₁] s
rcases ennreal.exists_nnreal_pos_mul_lt H.2 H.1 with ⟨c, hc0, hc⟩
{ rcases ennreal.exists_nnreal_pos_mul_lt H.2 H.1 with ⟨c, hc0, hc⟩, exact hc.not_le (this c (pos_iff_ne_zero.1 hc0)) }
exact hc.not_le (this c (pos_iff_ne_zero.1 hc0))
intros c hc
refine le_iff'.1 (mk_metric_mono_smul ennreal.coe_ne_top (by exact_mod_cast hc) _) s
exact_mod_cast hc
have : 0 < (c ^ (d₂ - d₁)⁻¹ : ℝ≥0∞)
rw [ennreal.coe_rpow_of_ne_zero hc, pos_iff_ne_zero, ne.def, ennreal.coe_eq_zero, nnreal.rpow_eq_zero_iff]
{ rw [ennreal.coe_rpow_of_ne_zero hc, pos_iff_ne_zero, ne.def, ennreal.coe_eq_zero, nnreal.rpow_eq_zero_iff], exact mt and.left hc }
exact mt and.left hc
filter_upwards [Ioo_mem_nhds_within_Ioi ⟨le_rfl, this⟩]
rintro r ⟨hr₀, hrc⟩
lift r to ℝ≥0 using ne_top_of_lt hrc
rw [pi.smul_apply, smul_eq_mul, ← ennreal.div_le_iff_le_mul (or.inr ennreal.coe_ne_top) (or.inr $ mt ennreal.coe_eq_zero.1 hc), ← ennreal.rpow_sub _ _ hr₀.ne' ennreal.coe_ne_top]
refine (ennreal.rpow_lt_rpow hrc (sub_pos.2 h)).le.trans _
rw [← ennreal.rpow_mul, inv_mul_cancel (sub_pos.2 h).ne', ennreal.rpow_one]
exact le_rfl
classical
refine (pi_eq_generate_from (λ i, real.borel_eq_generate_from_Ioo_rat.symm) (λ i, real.is_pi_system_Ioo_rat) (λ i, real.finite_spanning_sets_in_Ioo_rat _) _).symm
simp only [mem_Union, mem_singleton_iff]
intros s hs
choose a b H using hs
obtain rfl : s = λ i, Ioo (a i) (b i)
from funext (λ i, (H i).2)
replace H := λ i, (H i).1
apply le_antisymm _
have Hle : volume ≤ (μH[fintype.card ι] : measure (ι → ℝ))
refine le_hausdorff_measure _ _ ∞ ennreal.coe_lt_top (λ s h₁ h₂, _)
rw [ennreal.rpow_nat_cast]
{ refine le_hausdorff_measure _ _ ∞ ennreal.coe_lt_top (λ s h₁ h₂, _), rw [ennreal.rpow_nat_cast], exact real.volume_pi_le_diam_pow s }
exact real.volume_pi_le_diam_pow s
rw [← volume_pi_pi (λ i, Ioo (a i : ℝ) (b i)) (λ i, measurable_set_Ioo)]
{ have Hle : volume ≤ (μH[fintype.card ι] : measure (ι → ℝ)), { refine le_hausdorff_measure _ _ ∞ ennreal.coe_lt_top (λ s h₁ h₂, _), rw [ennreal.rpow_nat_cast], exact real.volume_pi_le_diam_pow s }, rw [← volume_pi_pi (λ i, Ioo (a i : ℝ) (b i)) (λ i, measurable_set_Ioo)], exact measure.le_iff'.1 Hle _ }
exact measure.le_iff'.1 Hle _
have I : ∀ i, 0 ≤ (b i : ℝ) - a i := λ i, by simpa only [sub_nonneg, rat.cast_le] using (H i).le
simpa only [sub_nonneg, rat.cast_le] using (H i).le
let γ := λ (n : ℕ), (Π (i : ι), fin ⌈((b i : ℝ) - a i) * n⌉₊)
let t : Π (n : ℕ), γ n → set (ι → ℝ) := λ n f, set.pi univ (λ i, Icc (a i + f i / n) (a i + (f i + 1) / n))
have A : tendsto (λ (n : ℕ), 1/(n : ℝ≥0∞)) at_top (𝓝 0)
simp only [one_div, ennreal.tendsto_inv_nat_nhds_zero]
have B : ∀ᶠ n in at_top, ∀ (i : γ n), diam (t n i) ≤ 1 / n
apply eventually_at_top.2 ⟨1, λ n hn, _⟩
assume f
apply diam_pi_le_of_le (λ b, _)
simp only [real.ediam_Icc, add_div, ennreal.of_real_div_of_pos (nat.cast_pos.mpr hn), le_refl, add_sub_add_left_eq_sub, add_sub_cancel', ennreal.of_real_one, ennreal.of_real_coe_nat]
{ apply eventually_at_top.2 ⟨1, λ n hn, _⟩, assume f, apply diam_pi_le_of_le (λ b, _), simp only [real.ediam_Icc, add_div, ennreal.of_real_div_of_pos (nat.cast_pos.mpr hn), le_refl, add_sub_add_left_eq_sub, add_sub_cancel', ennreal.of_real_one, ennreal.of_real_coe_nat] }
have C : ∀ᶠ n in at_top, set.pi univ (λ (i : ι), Ioo (a i : ℝ) (b i)) ⊆ ⋃ (i : γ n), t n i
apply eventually_at_top.2 ⟨1, λ n hn, _⟩
have npos : (0 : ℝ) < n := nat.cast_pos.2 hn
assume x hx
simp only [mem_Ioo, mem_univ_pi] at hx
simp only [mem_Union, mem_Ioo, mem_univ_pi, coe_coe]
let f : γ n := λ i, ⟨⌊(x i - a i) * n⌋₊, begin apply nat_floor_lt_nat_ceil_of_lt_of_pos, { refine (mul_lt_mul_right npos).2 _, simp only [(hx i).right, sub_lt_sub_iff_right] }, { refine mul_pos _ npos, simpa only [rat.cast_lt, sub_pos] using H i } end⟩
apply nat_floor_lt_nat_ceil_of_lt_of_pos
refine (mul_lt_mul_right npos).2 _
{ refine (mul_lt_mul_right npos).2 _, simp only [(hx i).right, sub_lt_sub_iff_right] }
simp only [(hx i).right, sub_lt_sub_iff_right]
refine mul_pos _ npos
simpa only [rat.cast_lt, sub_pos] using H i
refine ⟨f, λ i, ⟨_, _⟩⟩
calc (a i : ℝ) + ⌊(x i - a i) * n⌋₊ / n ≤ (a i : ℝ) + ((x i - a i) * n) / n : begin refine add_le_add le_rfl ((div_le_div_right npos).2 _), exact nat_floor_le (mul_nonneg (sub_nonneg.2 (hx i).1.le) npos.le), end ... = x i : by field_simp [npos.ne']
refine add_le_add le_rfl ((div_le_div_right npos).2 _)
exact nat_floor_le (mul_nonneg (sub_nonneg.2 (hx i).1.le) npos.le)
field_simp [npos.ne']
{ calc (a i : ℝ) + ⌊(x i - a i) * n⌋₊ / n ≤ (a i : ℝ) + ((x i - a i) * n) / n : begin refine add_le_add le_rfl ((div_le_div_right npos).2 _), exact nat_floor_le (mul_nonneg (sub_nonneg.2 (hx i).1.le) npos.le), end ... = x i : by field_simp [npos.ne'] }
calc x i = (a i : ℝ) + ((x i - a i) * n) / n : by field_simp [npos.ne'] ... ≤ (a i : ℝ) + (⌊(x i - a i) * n⌋₊ + 1) / n : add_le_add le_rfl ((div_le_div_right npos).2 (lt_nat_floor_add_one _).le)
field_simp [npos.ne']
{ apply eventually_at_top.2 ⟨1, λ n hn, _⟩, have npos : (0 : ℝ) < n := nat.cast_pos.2 hn, assume x hx, simp only [mem_Ioo, mem_univ_pi] at hx, simp only [mem_Union, mem_Ioo, mem_univ_pi, coe_coe], let f : γ n := λ i, ⟨⌊(x i - a i) * n⌋₊, begin apply nat_floor_lt_nat_ceil_of_lt_of_pos, { refine (mul_lt_mul_right npos).2 _, simp only [(hx i).right, sub_lt_sub_iff_right] }, { refine mul_pos _ npos, simpa only [rat.cast_lt, sub_pos] using H i } end⟩, refine ⟨f, λ i, ⟨_, _⟩⟩, { calc (a i : ℝ) + ⌊(x i - a i) * n⌋₊ / n ≤ (a i : ℝ) + ((x i - a i) * n) / n : begin refine add_le_add le_rfl ((div_le_div_right npos).2 _), exact nat_floor_le (mul_nonneg (sub_nonneg.2 (hx i).1.le) npos.le), end ... = x i : by field_simp [npos.ne'] }, { calc x i = (a i : ℝ) + ((x i - a i) * n) / n : by field_simp [npos.ne'] ... ≤ (a i : ℝ) + (⌊(x i - a i) * n⌋₊ + 1) / n : add_le_add le_rfl ((div_le_div_right npos).2 (lt_nat_floor_add_one _).le) } }
calc μH[fintype.card ι] (set.pi univ (λ (i : ι), Ioo (a i : ℝ) (b i))) ≤ liminf at_top (λ (n : ℕ), ∑ (i : γ n), diam (t n i) ^ ↑(fintype.card ι)) : hausdorff_measure_le_liminf_sum _ (set.pi univ (λ i, Ioo (a i : ℝ) (b i))) (λ (n : ℕ), 1/(n : ℝ≥0∞)) A t B C ... ≤ liminf at_top (λ (n : ℕ), ∑ (i : γ n), (1/n) ^ (fintype.card ι)) : begin refine liminf_le_liminf _ (by is_bounded_default), filter_upwards [B], assume n hn, apply finset.sum_le_sum (λ i _, _), rw ennreal.rpow_nat_cast, exact pow_le_pow_of_le_left' (hn i) _, end ... = liminf at_top (λ (n : ℕ), ∏ (i : ι), (⌈((b i : ℝ) - a i) * n⌉₊ : ℝ≥0∞) / n) : begin simp only [finset.card_univ, nat.cast_prod, one_mul, fintype.card_fin, finset.sum_const, nsmul_eq_mul, fintype.card_pi, div_eq_mul_inv, finset.prod_mul_distrib, finset.prod_const] end ... = ∏ (i : ι), volume (Ioo (a i : ℝ) (b i)) : begin simp only [real.volume_Ioo], apply tendsto.liminf_eq, refine ennreal.tendsto_finset_prod_of_ne_top _ (λ i hi, _) (λ i hi, _), { apply tendsto.congr' _ ((ennreal.continuous_of_real.tendsto _).comp ((tendsto_nat_ceil_mul_div_at_top (I i)).comp tendsto_coe_nat_at_top_at_top)), apply eventually_at_top.2 ⟨1, λ n hn, _⟩, simp only [ennreal.of_real_div_of_pos (nat.cast_pos.mpr hn), comp_app, ennreal.of_real_coe_nat] }, { simp only [ennreal.of_real_ne_top, ne.def, not_false_iff] } end
is_bounded_default
refine liminf_le_liminf _ (by is_bounded_default)
filter_upwards [B]
assume n hn
apply finset.sum_le_sum (λ i _, _)
rw ennreal.rpow_nat_cast
exact pow_le_pow_of_le_left' (hn i) _
simp only [finset.card_univ, nat.cast_prod, one_mul, fintype.card_fin, finset.sum_const, nsmul_eq_mul, fintype.card_pi, div_eq_mul_inv, finset.prod_mul_distrib, finset.prod_const]
simp only [real.volume_Ioo]
apply tendsto.liminf_eq
refine ennreal.tendsto_finset_prod_of_ne_top _ (λ i hi, _) (λ i hi, _)
apply tendsto.congr' _ ((ennreal.continuous_of_real.tendsto _).comp ((tendsto_nat_ceil_mul_div_at_top (I i)).comp tendsto_coe_nat_at_top_at_top))
apply eventually_at_top.2 ⟨1, λ n hn, _⟩
simp only [ennreal.of_real_div_of_pos (nat.cast_pos.mpr hn), comp_app, ennreal.of_real_coe_nat]
{ apply tendsto.congr' _ ((ennreal.continuous_of_real.tendsto _).comp ((tendsto_nat_ceil_mul_div_at_top (I i)).comp tendsto_coe_nat_at_top_at_top)), apply eventually_at_top.2 ⟨1, λ n hn, _⟩, simp only [ennreal.of_real_div_of_pos (nat.cast_pos.mpr hn), comp_app, ennreal.of_real_coe_nat] }
simp only [ennreal.of_real_ne_top, ne.def, not_false_iff]
simp [← measure_congr Ioi_ae_eq_Ici]
simp only [volume_pi_ball a hr, volume_ball, finset.prod_const]
exact (ennreal.of_real_pow (mul_nonneg zero_le_two hr.le) _).symm
by_cases hs : metric.bounded s
rw [real.ediam_eq hs, ← volume_Icc]
exact volume.mono (real.subset_Icc_Inf_Sup_of_bounded hs)
{ rw [real.ediam_eq hs, ← volume_Icc], exact volume.mono (real.subset_Icc_Inf_Sup_of_bounded hs) }
exact le_top
rw metric.ediam_of_unbounded hs
rw [← bUnion_of_singleton s, ← nonpos_iff_eq_zero]
refine le_trans (measure_bUnion_le h _) _
simp
refine le_antisymm _ (le_map_apply f.measurable s)
rw [measure_eq_infi' μ]
rintro ⟨t, hst, ht⟩
refine le_infi _
rw [subtype.coe_mk]
have : f.symm '' s = f ⁻¹' s := f.symm.to_equiv.image_eq_preimage s
rw [← this, image_subset_iff] at hst
convert measure_mono hst
rw [map_apply, preimage_preimage]
convert preimage_id
exact funext f.left_inv
refine congr_arg μ (eq.symm _)
{ refine congr_arg μ (eq.symm _), convert preimage_id, exact funext f.left_inv }
exacts [f.measurable, f.measurable_inv_fun ht]
rw [← (map_measurable_equiv_injective e).eq_iff, map_map_symm, eq_comm]
contrapose! H
apply tsum_measure_le_measure_univ hs
exact λ i j hij x hx, H i j hij ⟨x, hx⟩
simp only [le_iff, not_forall, not_le, exists_prop]
rw [restrictₗ_apply, restrict_apply ht, linear_map.comp_apply, map_apply measurable_subtype_coe ht, comap_apply (coe : s → α) subtype.val_injective (λ _, hs.subtype_image) _ (measurable_subtype_coe ht), subtype.image_preimage_coe]
simpa only [← measure_eq_trim] using μ.to_outer_measure.exists_measurable_superset_eq_trim s
refine ⟨λ h, ⟨_, _⟩, λ h, measure_union_lt_top h.1 h.2⟩
exact (measure_mono (set.subset_union_left s t)).trans_lt h
{ exact (measure_mono (set.subset_union_left s t)).trans_lt h, }
exact (measure_mono (set.subset_union_right s t)).trans_lt h
rw [supr, Sup_apply, supr_range, supr]
simp
intros U hU r hr
rcases H' hU r hr with ⟨F, hFU, hqF, hF⟩
rcases H hqF _ hF with ⟨K, hKF, hpK, hrK⟩
exact ⟨K, hKF.trans hFU, hpK, hrK⟩
intros F hF r hr
set B : ℕ → set X := compact_covering X
have hBc : ∀ n, is_compact (F ∩ B n)
from λ n, (is_compact_compact_covering X n).inter_left hF
rw [← inter_Union, Union_compact_covering, set.inter_univ]
have hBU : (⋃ n, F ∩ B n) = F
have : μ F = ⨆ n, μ (F ∩ B n)
rw [← measure_Union_eq_supr, hBU]
exacts [λ n, (hBc n).measurable_set, monotone.directed_le $ λ m n h, inter_subset_inter_right _ (compact_covering_subset _ h)]
{ rw [← measure_Union_eq_supr, hBU], exacts [λ n, (hBc n).measurable_set, monotone.directed_le $ λ m n h, inter_subset_inter_right _ (compact_covering_subset _ h)] }
rcases lt_supr_iff.1 hr with ⟨n, hn⟩
rw this at hr
exact ⟨_, inter_subset_left _ _, hBc n, hn⟩
exact f.outer_Ioc a b
rw stieltjes_function.measure
simp only [coe_smul, pi.smul_apply, hs₂ t ht, smul_zero]
ext i hi
simp [measure.to_signed_measure_apply_measurable hi, to_measure_of_zero_le_apply _ _ _ hi]
ext i hi
simp [measure.to_signed_measure_apply_measurable hi, to_measure_of_le_zero_apply _ _ _ hi]
refine hf.ae_eq_of_forall_set_integral_eq f g hg (λ i hi _, _)
rw [← with_densityᵥ_apply hf hi, hfg, with_densityᵥ_apply hg hi]
by_cases hf : integrable f μ
ext1 i hi
rw [vector_measure.neg_apply, with_densityᵥ_apply hf hi, ← integral_neg, with_densityᵥ_apply hf.neg hi]
{ ext1 i hi, rw [vector_measure.neg_apply, with_densityᵥ_apply hf hi, ← integral_neg, with_densityᵥ_apply hf.neg hi], refl }
refl
rw [with_densityᵥ, with_densityᵥ, dif_neg hf, dif_neg, neg_zero]
rwa integrable_neg_iff
intros t ht
induction ht with s h_s s u h_gen_s h_gen_u h_nonempty h_s h_u
exact generate_pi_system.base (set.mem_of_subset_of_mem hST h_s)
{ exact generate_pi_system.base (set.mem_of_subset_of_mem hST h_s),}
exact is_pi_system_generate_pi_system T _ _ h_s h_u h_nonempty
split_ifs
split_ifs; try { subst a }; try { subst a' }; simp * at *
split_ifs; try { subst a }; try { subst a' }
split_ifs; try { subst a }
try { subst a }
try { subst a }
try { subst a }
try { subst a }
subst a
try { subst a' }
try { subst a' }
try { subst a' }
try { subst a' }
subst a'
simp * at *
simp * at *
simp * at *
simp * at *
simp [this]
ext b
ext b; simp [this]
simp
ext
simp
ext
rw [sigma, zeta_mul_apply]
apply sum_congr rfl
intros x hx
rw [pow_apply, if_neg (not_and_of_not_right _ _)]
contrapose! hx
simp [hx]
simp
{ simp }
cases n
suffices : (n + 1 : ℚ) * ∑ k in range n, ↑(n.choose k) / (n - k + 1) * bernoulli' k = ∑ x in range n, ↑(n.succ.choose x) * bernoulli' x
rw_mod_cast [sum_range_succ, bernoulli'_def, ← this, choose_succ_self_right]
ring
{ rw_mod_cast [sum_range_succ, bernoulli'_def, ← this, choose_succ_self_right], ring }
simp_rw [mul_sum, ← mul_assoc]
refine sum_congr rfl (λ k hk, _)
congr'
have : ((n - k : ℕ) : ℚ) + 1 ≠ 0 := by apply_mod_cast succ_ne_zero
apply_mod_cast succ_ne_zero
field_simp [← cast_sub (mem_range.1 hk).le, mul_comm]
rw_mod_cast [nat.sub_add_eq_add_sub (mem_range.1 hk).le, choose_mul_succ_eq]
norm_num [bernoulli]
refl
rw [bernoulli'_def', ← fin.sum_univ_eq_sum_range]
norm_num
rw bernoulli'_def
set y' : ℤ := finset.max' _ him with y'_def
have hy' : ∀ k, abv (bS.repr a k) ≤ y'
intro k
exact finset.le_max' _ _ (finset.mem_image.mpr ⟨k, finset.mem_univ _, rfl⟩)
{ intro k, exact finset.le_max' _ _ (finset.mem_image.mpr ⟨k, finset.mem_univ _, rfl⟩) }
have : (y' : T) < y
rw [y'_def, ← finset.max'_image (show monotone (coe : ℤ → T), from λ x y h, int.cast_le.mpr h)]
apply (finset.max'_lt_iff _ (him.image _)).mpr
simp only [finset.mem_image, exists_prop]
rintros _ ⟨x, ⟨k, -, rfl⟩, rfl⟩
{ rw [y'_def, ← finset.max'_image (show monotone (coe : ℤ → T), from λ x y h, int.cast_le.mpr h)], apply (finset.max'_lt_iff _ (him.image _)).mpr, simp only [finset.mem_image, exists_prop], rintros _ ⟨x, ⟨k, -, rfl⟩, rfl⟩, exact hy k }
exact hy k
have y'_nonneg : 0 ≤ y' := le_trans (abv.nonneg _) (hy' i)
apply (int.cast_le.mpr (norm_le abv bS a hy')).trans_lt
simp only [int.cast_mul, int.cast_pow]
apply mul_lt_mul' (le_refl _)
exact pow_lt_pow_of_lt_left this (int.cast_nonneg.mpr y'_nonneg) (fintype.card_pos_iff.mpr ⟨i⟩)
{ exact pow_lt_pow_of_lt_left this (int.cast_nonneg.mpr y'_nonneg) (fintype.card_pos_iff.mpr ⟨i⟩) }
{ exact pow_nonneg (int.cast_nonneg.mpr y'_nonneg) _ }
exact pow_nonneg (int.cast_nonneg.mpr y'_nonneg) _
{ exact int.cast_pos.mpr (norm_bound_pos abv bS) }
exact int.cast_pos.mpr (norm_bound_pos abv bS)
apply_instance
obtain ⟨i⟩ := bS.index_nonempty
have him : (finset.univ.image (λ k, abv (bS.repr a k))).nonempty := ⟨_, finset.mem_image.mpr ⟨i, finset.mem_univ _, rfl⟩⟩
cases o
cases o; refl
refl
refl
exact ⟨df, dg⟩
apply finset.subset_iff.2
intros x hx
exact nat.mem_proper_divisors.2 (⟨(nat.mem_divisors.1 hx).1.trans h, lt_of_le_of_lt (divisor_le hx) (lt_of_le_of_ne (divisor_le (nat.mem_divisors.2 ⟨h, hzero⟩)) hdiff)⟩)
ext
simp
norm_num
norm_num
lucas_lehmer.run_test
by_cases hx : x = 0
{ simp [hx] }
simp [hx]
exact_mod_cast hp_prime.1.one_lt
have h : (1 : ℝ) < p := by exact_mod_cast hp_prime.1.one_lt
rw [← neg_nonpos, ← (fpow_strict_mono h).le_iff_le]
show (p : ℝ) ^ -valuation x ≤ p ^ 0
rw [← norm_eq_pow_val hx]
simpa using x.property
from λ h', @zero_ne_one ℚ_[p] _ _ (by simpa [h'] using h)
have hk : k ≠ 0
simpa [h'] using h
split_ifs
unfold padic_int.inv
change (⟨k * (1/k), _⟩ : ℤ_[p]) = 1
refl
{ change (⟨k * (1/k), _⟩ : ℤ_[p]) = 1, simp [hk], refl }
simp [hk]
simp [mul_inv_cancel hk]
apply subtype.ext_iff_val.2
simp [hq, padic_norm]
unfold padic_norm; split_ifs
split_ifs
unfold padic_norm
apply fpow_nonneg
exact_mod_cast nat.zero_le _
simp [padic_norm]
simp [padic_norm, hq]
simp [hf, norm]
simp [norm, hf, padic_norm.nonneg]
simpa only [hfg, norm, ne.def, le_max_iff, cau_seq.add_apply, not_true, dif_pos]
change lim_zero (f - 0) at hf
simpa only [sub_zero, add_sub_cancel] using hf
show lim_zero (f + g - g)
rw hcl; exact max_eq_right (norm_nonneg _)
exact max_eq_right (norm_nonneg _)
rw hcl
rw [this, hcfg]
change lim_zero (g - 0) at hg
simpa only [add_sub_cancel', sub_zero] using hg
show lim_zero (f + g - f)
rw hcl; exact max_eq_left (norm_nonneg _)
exact max_eq_left (norm_nonneg _)
rw hcl
rw [this, hcfg]
simpa only [sub_zero, add_sub_cancel]
rw [h1, h2]; rw max_eq_right (norm_nonneg _)
rw max_eq_right (norm_nonneg _)
rw [h1, h2]
rw [add_sub_cancel']
rw [add_sub_cancel']; simpa only [sub_zero]
simpa only [sub_zero]
rw [h1, h2]; rw max_eq_left (norm_nonneg _)
rw max_eq_left (norm_nonneg _)
rw [h1, h2]
split_ifs at ⊢ hfgne
unfold norm at ⊢ hfgne
padic_index_simp [hfg, hf, hg] at ⊢ hfgne
exact padic_norm.add_eq_max_of_ne p hfgne
unfold has_norm.norm
exact_mod_cast nonarchimedean' _ _
apply monotone_nat_of_le_succ
intro n
dsimp [appr]
refl
{ refl, }
split_ifs
apply nat.le_add_right
convert appr_spec n _ using 1
simp
intros
intros x a b ha hb
apply zmod_congr_of_sub_mem_span n x a b
simpa using ha
{ simpa using ha }
simpa using hb
simp [zsqrtd.ext, is_pell, mul_comm]
simp [zsqrtd.ext, is_pell, mul_comm]; ring_nf
ring_nf
simp [zsqrtd.ext]
rw nat.zero_sub at hp
rw nat.zero_sub at hp; contradiction
contradiction
simp [pow_succ]
simp [mul_dvd_mul_left, mul_assoc]
exact b_div_k
{ apply induct k, { intros b b_in_s, exact primes b (finset.mem_insert_of_mem b_in_s), }, { intros b b_in_s, have b_div_n, by exact divs b (finset.mem_insert_of_mem b_in_s), have a_prime : prime a, { exact primes a (finset.mem_insert_self a s), }, have b_prime : prime b, { exact primes b (finset.mem_insert_of_mem b_in_s), }, obtain b_div_a | b_div_k : b ∣ a ∨ b ∣ k, exact (prime.dvd_mul b_prime).mp b_div_n, { exfalso, have b_eq_a : b = a, { cases (nat.dvd_prime a_prime).1 b_div_a with b_eq_1 b_eq_a, { subst b_eq_1, exfalso, exact prime.ne_one b_prime rfl, }, { exact b_eq_a } }, subst b_eq_a, exact a_not_in_s b_in_s, }, { exact b_div_k } } }
exact mul_dvd_mul_left a step
apply finset.induction_on s
{ simp, }
simp
intros a s a_not_in_s induct n primes divs
rw finset.prod_insert a_not_in_s
exact divs a (finset.mem_insert_self a s)
obtain ⟨k, rfl⟩ : a ∣ n
have step : ∏ p in s, p ∣ k
apply induct k
intros b b_in_s
{ intros b b_in_s, exact primes b (finset.mem_insert_of_mem b_in_s), }
exact primes b (finset.mem_insert_of_mem b_in_s)
intros b b_in_s
exact divs b (finset.mem_insert_of_mem b_in_s)
have b_div_n
exact primes a (finset.mem_insert_self a s)
{ exact primes a (finset.mem_insert_self a s), }
have a_prime : prime a
exact primes b (finset.mem_insert_of_mem b_in_s)
{ exact primes b (finset.mem_insert_of_mem b_in_s), }
have b_prime : prime b
exact (prime.dvd_mul b_prime).mp b_div_n
obtain b_div_a | b_div_k : b ∣ a ∨ b ∣ k
exfalso
have b_eq_a : b = a
cases (nat.dvd_prime a_prime).1 b_div_a with b_eq_1 b_eq_a
subst b_eq_1
exfalso
exact prime.ne_one b_prime rfl
{ subst b_eq_1, exfalso, exact prime.ne_one b_prime rfl, }
exact b_eq_a
{ cases (nat.dvd_prime a_prime).1 b_div_a with b_eq_1 b_eq_a, { subst b_eq_1, exfalso, exact prime.ne_one b_prime rfl, }, { exact b_eq_a } }
subst b_eq_a
exact a_not_in_s b_in_s
{ exfalso, have b_eq_a : b = a, { cases (nat.dvd_prime a_prime).1 b_div_a with b_eq_1 b_eq_a, { subst b_eq_1, exfalso, exact prime.ne_one b_prime rfl, }, { exact b_eq_a } }, subst b_eq_a, exact a_not_in_s b_in_s, }
convert h.normalize.mul_is_classified (int.gcd x y) (is_classified_of_is_primitive_classified h.normalize hc)
convert h.normalize.mul_is_classified (int.gcd x y) (is_classified_of_is_primitive_classified h.normalize hc); rw int.mul_div_cancel'
rw int.mul_div_cancel'
rw int.mul_div_cancel'
rw int.mul_div_cancel'
{ exact int.gcd_dvd_left x y }
exact int.gcd_dvd_left x y
{ exact int.gcd_dvd_right x y }
exact int.gcd_dvd_right x y
exact h.gcd_dvd
rintro rfl
norm_num at this
suffices : 0 < z * z
{ rintro rfl, norm_num at this }
rw [← h.eq, ← sq, ← sq]
rw hc
have hc' : int.gcd x y ≠ 0
exact one_ne_zero
{ rw hc, exact one_ne_zero }
cases int.ne_zero_of_gcd hc' with hxz hyz
apply lt_add_of_pos_of_le (sq_pos_of_ne_zero x hxz) (sq_nonneg y)
{ apply lt_add_of_pos_of_le (sq_pos_of_ne_zero x hxz) (sq_nonneg y) }
apply lt_add_of_le_of_pos (sq_nonneg x) (sq_pos_of_ne_zero y hyz)
by_contradiction H
obtain ⟨p, hp, hpy, hpz⟩ := nat.prime.not_coprime_iff_dvd.mp H
apply hp.not_dvd_one
rw [← hc]
apply nat.dvd_gcd (int.prime.dvd_nat_abs_of_coe_dvd_sq hp _ _) hpy
rw [sq, eq_sub_of_add_eq h]
rw [← int.coe_nat_dvd_left] at hpy hpz
exact dvd_sub ((hpz).mul_right _) ((hpy).mul_right _)
cases h.even_odd_of_coprime hc with h1 h2
exact (h.is_primitive_classified_of_coprime_of_odd_of_pos hc h1.right hzpos)
{ exact (h.is_primitive_classified_of_coprime_of_odd_of_pos hc h1.right hzpos) }
rw int.gcd_comm at hc
obtain ⟨m, n, H⟩ := (h.symm.is_primitive_classified_of_coprime_of_odd_of_pos hc h2.left hzpos)
tauto
use [m, n]
rw [← succ_sub_one p, succ_sub (fact.out p.prime).pos]
conv in (Ico 1 p) { rw [← succ_sub_one p, succ_sub (fact.out p.prime).pos] }
rw [← prod_nat_cast, finset.prod_Ico_id_eq_factorial, wilsons_lemma]
simp [ext]
simp [ext, sub_eq_add_neg, mul_comm]
apply complex.ext; simp [to_complex_def]
simp [to_complex_def]
simp [to_complex_def]
apply complex.ext
rw sup_sdiff_of_le hx
refine le_trans (sup_le_sup_left sdiff_le z) _
rw sup_eq_right.2 hz
rw [sdiff_eq, compl_compl]
simp only [disjoint_iff, inf_sup_left, sup_eq_bot_iff]
rw h_top
exact le_top
simp [some_eq_coe, coe_eq_coe]
simp [none_eq_top]
simp [bdd_above]
by_cases h : {c : α | complete_lattice.is_compact_element c ∧ c ≤ b} ⊆ {⊥}
left
rw [← Sup_compact_le_eq b, Sup_eq_bot]
{ left, rw [← Sup_compact_le_eq b, Sup_eq_bot], exact h }
exact h
rcases set.not_subset.1 h with ⟨c, ⟨hc, hcb⟩, hcbot⟩
right
have hc' := complete_lattice.Iic_coatomic_of_compact_element hc
rw ← is_atomic_iff_is_coatomic at hc'
haveI := hc'
obtain con | ⟨a, ha, hac⟩ := eq_bot_or_exists_atom_le (⟨c, le_refl c⟩ : set.Iic c)
exfalso
apply hcbot
simp only [subtype.ext_iff, set.Iic.coe_bot, subtype.coe_mk] at con
{ exfalso, apply hcbot, simp only [subtype.ext_iff, set.Iic.coe_bot, subtype.coe_mk] at con, exact con }
exact con
rw [← subtype.coe_le_coe, subtype.coe_mk] at hac
exact ⟨a, ha.of_is_atom_coe_Iic, hac.trans hcb⟩
apply le_antisymm
apply Sup_le (λ b hb, _)
rcases hb with ⟨t, ts, bt⟩
apply le_trans _ (le_supr _ t)
{ apply Sup_le (λ b hb, _), rcases hb with ⟨t, ts, bt⟩, apply le_trans _ (le_supr _ t), exact le_trans (le_Sup bt) (le_supr _ ts), }
exact le_trans (le_Sup bt) (le_supr _ ts)
apply supr_le (λ t, _)
exact supr_le (λ ts, Sup_le_Sup (λ x xt, ⟨t, ts, xt⟩))
subst this
have := propext pq
congr' with x
apply f
rw [infi, range_const, Inf_singleton]
refine { le := le, sup := sup, inf := inf, .. }
abstract { subst_vars, casesI c, assumption }
abstract { subst_vars, casesI c, assumption }
abstract { subst_vars, casesI c, assumption }
abstract { subst_vars, casesI c, assumption }
abstract { subst_vars, casesI c, assumption }
abstract { subst_vars, casesI c, assumption }
abstract { subst_vars, casesI c, assumption }
abstract { subst_vars, casesI c, assumption }
abstract { subst_vars, casesI c, assumption }
abstract { subst_vars, casesI c, assumption }
subst_vars
casesI c
all_goals { abstract { subst_vars, casesI c, assumption } }
assumption
refine { le := le, top := top, bot := bot, sup := sup, inf := inf, Sup := Sup, Inf := Inf, .. bounded_lattice.copy (@complete_lattice.to_bounded_lattice α c) le eq_le top eq_top bot eq_bot sup eq_sup inf eq_inf, .. }
abstract { subst_vars, casesI c, assumption }
abstract { subst_vars, casesI c, assumption }
abstract { subst_vars, casesI c, assumption }
abstract { subst_vars, casesI c, assumption }
subst_vars
casesI c
all_goals { abstract { subst_vars, casesI c, assumption } }
assumption
rwa ←finset.mem_coe
rw [←finset.mem_coe, finset.coe_image, equiv.image_eq_preimage] at hp
rwa ←finset.mem_coe
rw [←finset.mem_coe, finset.coe_image, equiv.image_eq_preimage] at hq
suffices H : ∀ k, p (f (n + 1) \ partial_sups f k)
{ exact H n }
exact H n
rintro k
induction k with k ih
{ exact hdiff h }
exact hdiff h
rw [partial_sups_succ, ←sdiff_sdiff_left]
exact hdiff ih
simp only [at_top, tendsto_infi, tendsto_principal, mem_Ici]
rw frequently_at_top' at h
exact extraction_of_frequently_at_top' h
simpa only [neg_mul_neg] using this
simp only [finset.image_singleton, h a, finset.mem_singleton]
refine ⟨Ici (max n m), mem_range_self _, _⟩
rintros p p_in
split ; rw mem_Ici at *
rw mem_Ici at *
rw mem_Ici at *
split
exact le_of_max_le_left p_in
exact le_of_max_le_right p_in
simp only [h.mem_filter_iff, exists_prop]
refl
simp only [tendsto, (hla.map f).le_iff, image_subset_iff]
rintros _ _ ⟨n, rfl⟩ ⟨m, rfl⟩
exact image_mem_map univ_mem
rw ←image_univ
simp only [preimage_image_eq s h]
rw [filter.prod, comap_sup, inf_sup_right, ← filter.prod, ← filter.prod]
rw [prod_eq, map_pure, pure_seq_eq_map]
refine ⟨λ S hSc hS, _⟩
choose s hs t ht hst using hS
replace hs : (⋂ i ∈ S, s i ‹_›) ∈ l₁ := (countable_bInter_mem hSc).2 hs
replace ht : (⋂ i ∈ S, t i ‹_›) ∈ l₂ := (countable_bInter_mem hSc).2 ht
refine mem_of_superset (inter_mem_inf hs ht) (subset_sInter $ λ i hi, _)
rw hst i hi
apply inter_subset_inter ; exact Inter_subset_of_subset i (Inter_subset _ _)
exact Inter_subset_of_subset i (Inter_subset _ _)
exact Inter_subset_of_subset i (Inter_subset _ _)
apply inter_subset_inter
simpa only [filter.eventually, set_of_forall] using @countable_bInter_mem _ _ l _ _ hS (λ i hi, {x | p x i hi})
simp [filter.lift]
rintros s ⟨t, ⟨t₁, t₂, ht₁, ht₂, t₁t₂⟩, mt⟩
refine ⟨m ⁻¹' t₁, m ⁻¹' t₂, ⟨t₁, ht₁, subset.refl _⟩, ⟨t₂, ht₂, subset.refl _⟩, _⟩
have := subset.trans (preimage_mono t₁t₂) mt
exact subset.trans (preimage_mul_preimage_subset _) this
simp only [gi.choice_eq]
simp only [gi.choice_eq]; exact λ a b, gi.gc.l_le inf_le_left
exact λ a b, gi.gc.l_le inf_le_left
simp only [gi.choice_eq]
simp only [gi.choice_eq]; exact λ a b, gi.gc.l_le inf_le_right
exact λ a b, gi.gc.l_le inf_le_right
simp only [gi.choice_eq]
simp only [gi.choice_eq]; exact λ a b c hac hbc, (gi.le_l_u a).trans $ gi.gc.monotone_l $ le_inf (gi.gc.monotone_u hac) (gi.gc.monotone_u hbc)
exact λ a b c hac hbc, (gi.le_l_u a).trans $ gi.gc.monotone_l $ le_inf (gi.gc.monotone_u hac) (gi.gc.monotone_u hbc)
rw [← sup_assoc, sup_idem]
rw [← sup_assoc, ← sup_assoc, @sup_comm α _ a]
rwa [or_iff_not_imp_left, not_forall]
simp [le_refl]
obtain ha | ha := le_total a₁ a₂; cases lt_or_eq_of_le ha with a_lt a_eq
obtain ha | ha := le_total a₁ a₂
cases lt_or_eq_of_le ha with a_lt a_eq
cases lt_or_eq_of_le ha with a_lt a_eq
left
exact a_lt
{ left, left, exact a_lt }
left
swap
left
exact a_lt
{ right, left, exact a_lt }
right
subst a_eq
subst a_eq
obtain hb | hb := le_total b₁ b₂
obtain hb | hb := le_total b₁ b₂
all_goals { subst a_eq, obtain hb | hb := le_total b₁ b₂ }
right
exact hb
{ left, right, exact hb }
left
right
exact hb
{ right, right, exact hb }
right
right
exact hb
{ left, right, exact hb }
left
right
exact hb
right
rintros ⟨a₁, b₁⟩ ⟨a₂, b₂⟩
obtain a_lt | a_le := linear_order.decidable_le a₁ a₂
rw not_le at a_lt
rintro ⟨l, r⟩
left
apply lt_trans
repeat { assumption }
assumption
assumption
assumption
{ apply lt_irrefl a₂, apply lt_trans, repeat { assumption } }
apply lt_irrefl a₂
assumption
{ left, rw not_le at a_lt, rintro ⟨l, r⟩, { apply lt_irrefl a₂, apply lt_trans, repeat { assumption } }, { apply lt_irrefl a₁, assumption } }
apply lt_irrefl a₁
by_cases h : a₁ = a₂
rw h
obtain b_lt | b_le := linear_order.decidable_le b₁ b₂
left
rw not_le at b_lt
rintro ⟨l, r⟩
apply lt_irrefl a₂
assumption
{ apply lt_irrefl a₂, assumption }
apply lt_irrefl b₂
apply lt_of_lt_of_le
repeat { assumption }
assumption
assumption
{ left, rw not_le at b_lt, rintro ⟨l, r⟩, { apply lt_irrefl a₂, assumption }, { apply lt_irrefl b₂, apply lt_of_lt_of_le, repeat { assumption } } }
right
right
assumption
{ rw h, obtain b_lt | b_le := linear_order.decidable_le b₁ b₂, { left, rw not_le at b_lt, rintro ⟨l, r⟩, { apply lt_irrefl a₂, assumption }, { apply lt_irrefl b₂, apply lt_of_lt_of_le, repeat { assumption } } }, { right, right, assumption } }
left
apply lt_of_le_of_ne
repeat { assumption }
assumption
assumption
right
rintros ⟨a₁, b₁⟩ ⟨a₂, b₂⟩
exact supr_infi_ge_nat_add f k
simp_rw liminf_eq_supr_infi_of_nat
rw h'
rw h'; apply ωSup_le; intro; apply f.monotone (hx i)
rw h'; apply ωSup_le; intro
rw h'; apply ωSup_le
apply ωSup_le
intro
apply f.monotone (hx i)
rw h'
rw h'; apply le_ωSup (c.map f)
apply le_ωSup (c.map f)
intros
intros
split
split; intros
transitivity ωSup c
assumption
{ transitivity ωSup c, exact le_ωSup _ _, assumption }
exact le_ωSup _ _
exact ωSup_le _ _ ‹_›
simp only [supr_le_iff, preorder_hom.coe_fun_mk] at ⊢ hs
simp only [supr_le_iff, preorder_hom.coe_fun_mk] at ⊢ hs; intros i; apply hs i
simp only [supr_le_iff, preorder_hom.coe_fun_mk] at ⊢ hs; intros i
apply hs i
intros i
simp only [preorder_hom.coe_fun_mk]
simp only [preorder_hom.coe_fun_mk]; apply le_supr_of_le i; refl
simp only [preorder_hom.coe_fun_mk]; apply le_supr_of_le i
apply le_supr_of_le i
refl
apply Sup_continuous
rw ← Sup_pair
rintro f (rfl|rfl|_); assumption
assumption
assumption
rintro f (rfl|rfl|_)
apply eq_of_forall_ge_iff
intro z
intro c
simp only [ωSup_le_iff, forall_const, chain.map_coe, (∘), function.const, preorder_hom.has_top_top, preorder_hom.const_coe_coe]
split_ifs; simp *
simp *
simp *
split_ifs
rw [hf.map_Sup', Sup_image]
apply_instance
cases le_or_lt m n with h
symmetry
exact strict_mono.monotone (λ x y, a.swap.map_rel) h
rw [sup_eq_right.mpr h, sup_eq_right]
{ rw [sup_eq_right.mpr h, sup_eq_right], exact strict_mono.monotone (λ x y, a.swap.map_rel) h, }
exact le_of_lt (a.map_rel h)
rw [sup_eq_left.mpr (le_of_lt h), sup_eq_left]
erw [← f.map_rel_iff, f.1.apply_symm_apply, f.1.apply_symm_apply]
rw symm_diff_bot
rw symm_diff_right_inj
rw [symm_diff_comm, symm_diff_sdiff_left]
classical
intros h f hf
intros h f hf
split
split; intros h f hf
{ exact h.exists_monotone_subseq f hf }
exact h.exists_monotone_subseq f hf
obtain ⟨g, gmon⟩ := h f hf
refine ⟨g 0, g 1, g.lt_iff_lt.2 zero_lt_one, gmon _ _ zero_le_one⟩
exact hs.union (is_pwo_singleton a)
rw ← union_singleton
rwa [set.mem_singleton_iff.mp hs1, set.mem_singleton_iff.mp ht1]
dsimp [conjugate]
simp only [←i.map_smul, h, ←mul_smul, single_mul_single, mul_one, mul_left_inv]
change (1 : monoid_algebra k G) • v = v
simp
have f'_monic : monic _ := monic_mul_leading_coeff_inv hf
refine (minpoly.unique K _ f'_monic _ _).symm
{ rw [alg_hom.map_mul, aeval_eq, mk_self, zero_mul] }
rw [alg_hom.map_mul, aeval_eq, mk_self, zero_mul]
intros q q_monic q_aeval
have commutes : (lift (algebra_map K (adjoin_root f)) (root f) q_aeval).comp (mk q) = mk f
ext
refl
{ simp only [ring_hom.comp_apply, mk_C, lift_of], refl }
simp only [ring_hom.comp_apply, mk_C, lift_of]
{ ext, { simp only [ring_hom.comp_apply, mk_C, lift_of], refl }, { simp only [ring_hom.comp_apply, mk_X, lift_root] } }
simp only [ring_hom.comp_apply, mk_X, lift_root]
rw [degree_eq_nat_degree f'_monic.ne_zero, degree_eq_nat_degree q_monic.ne_zero, with_bot.coe_le_coe, nat_degree_mul hf, nat_degree_C, add_zero]
apply nat_degree_le_of_dvd
rw [←commutes, ring_hom.comp_apply, mk_self, ring_hom.map_zero]
have : mk f q = 0
rwa [←ideal.mem_span_singleton, ←ideal.quotient.eq_zero_iff_mem]
{ have : mk f q = 0, by rw [←commutes, ring_hom.comp_apply, mk_self, ring_hom.map_zero], rwa [←ideal.mem_span_singleton, ←ideal.quotient.eq_zero_iff_mem] }
{ exact q_monic.ne_zero }
exact q_monic.ne_zero
rwa [ne.def, C_eq_zero, inv_eq_zero, leading_coeff_eq_zero]
let Jac := ideal.jacobson (⊥ : ideal R)
let f : ℕ →ₘ order_dual (ideal R) := ⟨λ n, Jac ^ n, λ _ _ h, ideal.pow_le_pow h⟩
obtain ⟨n, hn⟩ : ∃ n, ∀ m, n ≤ m → Jac ^ n = Jac ^ m := is_artinian.monotone_stabilizes f
refine ⟨n, _⟩
let J : ideal R := annihilator (Jac ^ n)
suffices : J = ⊤
have hJ : J • Jac ^ n = ⊥ := annihilator_smul (Jac ^ n)
simpa only [this, top_smul, ideal.zero_eq_bot] using hJ
{ have hJ : J • Jac ^ n = ⊥ := annihilator_smul (Jac ^ n), simpa only [this, top_smul, ideal.zero_eq_bot] using hJ }
change J ≠ ⊤ at hJ
by_contradiction hJ
rcases is_artinian.set_has_minimal {J' : ideal R | J < J'} ⟨⊤, hJ.lt_top⟩ with ⟨J', hJJ' : J < J', hJ' : ∀ I, J < I → I ≤ J' → I = J'⟩
rcases set_like.exists_of_lt hJJ' with ⟨x, hxJ', hxJ⟩
obtain rfl : J ⊔ ideal.span {x} = J'
refine hJ' (J ⊔ ideal.span {x}) _ _
rw set_like.lt_iff_le_and_exists
exact ⟨le_sup_left, ⟨x, mem_sup_right (mem_span_singleton_self x), hxJ⟩⟩
{ rw set_like.lt_iff_le_and_exists, exact ⟨le_sup_left, ⟨x, mem_sup_right (mem_span_singleton_self x), hxJ⟩⟩ }
{ refine hJ' (J ⊔ ideal.span {x}) _ _, { rw set_like.lt_iff_le_and_exists, exact ⟨le_sup_left, ⟨x, mem_sup_right (mem_span_singleton_self x), hxJ⟩⟩ }, { exact (sup_le hJJ'.le (span_le.2 (singleton_subset_iff.2 hxJ'))) } }
exact (sup_le hJJ'.le (span_le.2 (singleton_subset_iff.2 hxJ')))
have : J ⊔ Jac • ideal.span {x} ≤ J ⊔ ideal.span {x}
from sup_le_sup_left (smul_le.2 (λ _ _ _, submodule.smul_mem _ _)) _
have : Jac * ideal.span {x} ≤ J
by_contradiction H
classical
refine H (smul_sup_le_of_le_smul_of_le_jacobson_bot (fg_span_singleton _) le_rfl (hJ' _ _ this).ge)
exact lt_of_le_of_ne le_sup_left (λ h, H $ h.symm ▸ le_sup_right)
{ classical, by_contradiction H, refine H (smul_sup_le_of_le_smul_of_le_jacobson_bot (fg_span_singleton _) le_rfl (hJ' _ _ this).ge), exact lt_of_le_of_ne le_sup_left (λ h, H $ h.symm ▸ le_sup_right) }
have : ideal.span {x} * Jac ^ (n + 1) ≤ ⊥
calc ideal.span {x} * Jac ^ (n + 1) = ideal.span {x} * Jac * Jac ^ n : by rw [pow_succ, ← mul_assoc] ... ≤ J * Jac ^ n : mul_le_mul (by rwa mul_comm) (le_refl _) ... = ⊥ : by simp [J]
rw [pow_succ, ← mul_assoc]
rwa mul_comm
simp [J]
refine hxJ (mem_annihilator.2 (λ y hy, (mem_bot R).1 _))
refine this (mul_mem_mul (mem_span_singleton_self x) _)
rwa [← hn (n + 1) (nat.le_succ _)]
simp only [class_group.mk0, monoid_hom.comp_apply, quotient_group.mk'_eq_mk']
split
rintros ⟨_, ⟨x, rfl⟩, hx⟩
refine ⟨x, x.ne_zero, _⟩
simpa only [mul_comm, coe_mk0, monoid_hom.to_fun_eq_coe, coe_to_principal_ideal, units.coe_mul] using congr_arg (coe : _ → fractional_ideal R⁰ K) hx
{ rintros ⟨_, ⟨x, rfl⟩, hx⟩, refine ⟨x, x.ne_zero, _⟩, simpa only [mul_comm, coe_mk0, monoid_hom.to_fun_eq_coe, coe_to_principal_ideal, units.coe_mul] using congr_arg (coe : _ → fractional_ideal R⁰ K) hx }
rintros ⟨x, hx, eq_J⟩
refine ⟨_, ⟨units.mk0 x hx, rfl⟩, units.ext _⟩
simpa only [fractional_ideal.mk0_apply, units.coe_mk0, mul_comm, coe_to_principal_ideal, coe_coe, units.coe_mul] using eq_J
rintros ⟨I⟩
rw [finset.mem_singleton]
exact class_group.mk_eq_one_iff.mpr (I : fractional_ideal R⁰ K).is_principal
rw [finset.prod_insert hbt, is_coprime.mul_left_iff, ih, finset.forall_mem_insert]
refine ⟨λ x hx, _⟩
rw [← set.mem_range, ← algebra.mem_bot, ← subalgebra.mem_to_submodule, algebra.to_submodule_bot, ← coe_span_singleton A⁰ (1 : fraction_ring A), fractional_ideal.span_singleton_one, ← fractional_ideal.adjoin_integral_eq_one_of_is_unit x hx (h.is_unit _)]
{ exact mem_adjoin_integral_self A⁰ x hx }
exact mem_adjoin_integral_self A⁰ x hx
exact λ h, one_ne_zero (eq_zero_iff.mp h 1 (subalgebra.one_mem _))
rw mem_inv_iff (fractional_ideal.coe_ideal_ne_zero hI)
intros y hy
rw one_mul
exact coe_ideal_le_one hy
assumption
split
rw iff_quotient_mv_polynomial'
rintro ⟨ι, hfintype, ⟨f, hsur⟩⟩
letI := hfintype
obtain ⟨equiv⟩ := @fintype.trunc_equiv_fin ι (classical.dec_eq ι) hfintype
replace equiv := mv_polynomial.rename_equiv R equiv
exact ⟨fintype.card ι, alg_hom.comp f equiv.symm, function.surjective.comp hsur (alg_equiv.symm equiv).surjective⟩
{ rw iff_quotient_mv_polynomial', rintro ⟨ι, hfintype, ⟨f, hsur⟩⟩, letI := hfintype, obtain ⟨equiv⟩ := @fintype.trunc_equiv_fin ι (classical.dec_eq ι) hfintype, replace equiv := mv_polynomial.rename_equiv R equiv, exact ⟨fintype.card ι, alg_hom.comp f equiv.symm, function.surjective.comp hsur (alg_equiv.symm equiv).surjective⟩ }
rintro ⟨n, ⟨f, hsur⟩⟩
exact finite_type.of_surjective (finite_type.mv_polynomial R (fin n)) f hsur
letI := f.to_algebra
letI := g.to_algebra
letI := (g.comp f).to_algebra
letI : is_scalar_tower A B C := restrict_scalars.is_scalar_tower A B C
letI : module.finite A C := h
exact module.finite.of_restrict_scalars_finite A B C
refine ⟨λ h, _, λ h, submodule.subset_span $ set.mem_image_of_mem (of R M) h⟩
rw [of, monoid_hom.coe_mk, ← finsupp.supported_eq_span_single, finsupp.mem_supported, finsupp.support_single_ne_zero (@one_ne_zero R _ (by apply_instance))] at h
apply_instance
simpa using h
ext
refine (mem_span_singleton S).trans ((exists_congr _).trans (mem_one_iff S).symm)
intro x'
rw [algebra.smul_def, mul_one]
obtain ⟨a, a_mem, ha⟩ := J.is_fractional
use [a, a_mem]
intros b b_mem
exact ha b (hIJ b_mem)
simp [x'_eq_x.symm, x'_eq_zero]
simp [hx]
obtain ⟨y, y_mem, y_not_mem⟩ := set_like.exists_of_lt (bot_lt_iff_ne_bot.mpr hI)
simpa using y_not_mem
have y_ne_zero : y ≠ 0 := by simpa using y_not_mem
obtain ⟨z, ⟨x, hx⟩⟩ := exists_integer_multiple R⁰ y
refine ⟨x, _, _⟩
rw [ne.def, ← @is_fraction_ring.to_map_eq_zero_iff R _ K, hx, algebra.smul_def]
exact mul_ne_zero (is_fraction_ring.to_map_ne_zero_of_mem_non_zero_divisors z.2) y_ne_zero
{ rw [ne.def, ← @is_fraction_ring.to_map_eq_zero_iff R _ K, hx, algebra.smul_def], exact mul_ne_zero (is_fraction_ring.to_map_ne_zero_of_mem_non_zero_divisors z.2) y_ne_zero }
rw hx
exact smul_mem _ _ y_mem
rw ← (algebra_map R₁ K).map_one
simpa only [h] using coe_mem_one R₁⁰ 1
ext a
have hwf := (y.is_pwo_support.union z.is_pwo_support)
rw [mul_coeff_right' hwf, add_coeff, mul_coeff_right' hwf (set.subset_union_right _ _), mul_coeff_right' hwf (set.subset_union_left _ _)]
{ simp only [add_coeff, mul_add, sum_add_distrib] }
simp only [add_coeff, mul_add, sum_add_distrib]
intro b
simp only [add_coeff, ne.def, set.mem_union_eq, set.mem_set_of_eq, mem_support]
contrapose!
intro h
rw [h.1, h.2, add_zero]
ext a
have hwf := (x.is_pwo_support.union y.is_pwo_support)
rw [mul_coeff_left' hwf, add_coeff, mul_coeff_left' hwf (set.subset_union_right _ _), mul_coeff_left' hwf (set.subset_union_left _ _)]
{ simp only [add_coeff, add_mul, sum_add_distrib] }
simp only [add_coeff, add_mul, sum_add_distrib]
intro b
simp only [add_coeff, ne.def, set.mem_union_eq, set.mem_set_of_eq, mem_support]
contrapose!
intro h
rw [h.1, h.2, add_zero]
simp [← ring_equiv.to_ring_hom_eq_coe, comap_comap]
rw [smul_smul, mul_comm, mul_smul]
rw [smul_smul, mul_comm, mul_smul]; exact submodule.smul_mem _ _
exact submodule.smul_mem _ _
rw [smul_eq_mul, mul_smul]
rw [smul_eq_mul, mul_smul]; exact submodule.smul_mem _ _
exact submodule.smul_mem _ _
have : ∃ φ : ι → R, (∀ i, φ i - 1 ∈ f i) ∧ (∀ i j, i ≠ j → φ i ∈ f j)
have := exists_sub_one_mem_and_mem (finset.univ : finset ι) (λ i _ j _ hij, hf i j hij)
choose φ hφ
existsi λ i, φ i (finset.mem_univ i)
exact ⟨λ i, (hφ i _).1, λ i j hij, (hφ i _).2 j (finset.mem_univ j) hij.symm⟩
{ have := exists_sub_one_mem_and_mem (finset.univ : finset ι) (λ i _ j _ hij, hf i j hij), choose φ hφ, existsi λ i, φ i (finset.mem_univ i), exact ⟨λ i, (hφ i _).1, λ i j hij, (hφ i _).2 j (finset.mem_univ j) hij.symm⟩ }
rcases this with ⟨φ, hφ1, hφ2⟩
use ∑ i, g i * φ i
intros i
rw [← quotient.eq, ring_hom.map_sum]
refine eq.trans (finset.sum_eq_single i _ _) _
rw quotient.eq_zero_iff_mem
exact (f i).mul_mem_left _ (hφ2 j i hji)
intros j _ hji
{ intros j _ hji, rw quotient.eq_zero_iff_mem, exact (f i).mul_mem_left _ (hφ2 j i hji) }
exact (hi $ finset.mem_univ i).elim
{ intros hi, exact (hi $ finset.mem_univ i).elim }
intros hi
rw [← quotient.eq, ring_hom.map_one] at hφ1
specialize hφ1 i
rw [ring_hom.map_mul, hφ1, mul_one]
obtain ⟨p, p_monic, hpx⟩ := integral
refine comap_lt_comap_of_root_mem_sdiff hIJ mem _ _
swap
apply map_monic_ne_zero p_monic
apply quotient.nontrivial
apply mt comap_eq_top_iff.mp
{ apply map_monic_ne_zero p_monic, apply quotient.nontrivial, apply mt comap_eq_top_iff.mp, apply hI.1 }
apply hI.1
convert I.zero_mem
contrapose!
simp only [ne_top_iff_one, is_prime_iff, not_and, not_forall, not_or_distrib]
exact λ ⟨hI, hJ⟩ hIJ, ⟨⟨0, 1⟩, ⟨1, 0⟩, by simp, by simp [hJ], by simp [hI]⟩
simp
simp [hJ]
simp [hI]
exactI is_prime_ideal_prod_top
refine is_cyclic_of_subgroup_integral_domain ⟨(coe : S → R), _, _⟩ (units.ext.comp subtype.val_injective)
{ simp }
simp
simp
intros
ext n
rw [← sub_add_cancel n x.order, single_mul_coeff_add, sub_add_cancel, one_mul]
by_cases h : x.order ≤ n
rw [int.eq_nat_abs_of_zero_le (sub_nonneg_of_le h), coeff_coe_power_series, power_series_part_coeff, ← int.eq_nat_abs_of_zero_le (sub_nonneg_of_le h), add_sub_cancel'_right]
{ rw [int.eq_nat_abs_of_zero_le (sub_nonneg_of_le h), coeff_coe_power_series, power_series_part_coeff, ← int.eq_nat_abs_of_zero_le (sub_nonneg_of_le h), add_sub_cancel'_right] }
rw [coe_power_series, of_power_series_apply, emb_domain_notin_range]
contrapose! h
{ contrapose! h, exact order_le_of_coeff_ne_zero h.symm }
exact order_le_of_coeff_ne_zero h.symm
contrapose! h
simp only [set.mem_range, rel_embedding.coe_fn_mk, function.embedding.coe_fn_mk, int.nat_cast_eq_coe_nat] at h
obtain ⟨m, hm⟩ := h
rw [← sub_nonneg, ← hm]
exact int.zero_le_of_nat _
refine alg_equiv.of_bijective (algebra.of_id R S) ⟨_, _⟩
intros x y hxy
obtain ⟨c, eq⟩ := (is_localization.eq_iff_exists M S).mp hxy
obtain ⟨u, hu⟩ := H c
{ intros x y hxy, obtain ⟨c, eq⟩ := (is_localization.eq_iff_exists M S).mp hxy, obtain ⟨u, hu⟩ := H c, rwa [← hu, units.mul_left_inj] at eq }
rwa [← hu, units.mul_left_inj] at eq
intros y
obtain ⟨⟨x, s⟩, eq⟩ := is_localization.surj M y
obtain ⟨u, hu⟩ := H s
use x * u.inv
dsimp only [algebra.of_id, ring_hom.to_fun_eq_coe, alg_hom.coe_mk]
rw [ring_hom.map_mul, ← eq, ← hu, mul_assoc, ← ring_hom.map_mul]
simp
rw [coe_submodule, submodule.map_top, submodule.one_eq_range]
rw [mul_comm (_ + _), mul_add, mul_mk'_eq_mk'_of_mul, ←eq_sub_iff_add_eq, mk'_eq_iff_eq_mul, mul_comm _ ((algebra_map R S) _), mul_sub, eq_sub_iff_add_eq, ←eq_sub_iff_add_eq', ←mul_assoc, ←(algebra_map R S).map_mul, mul_mk'_eq_mk'_of_mul, mk'_eq_iff_eq_mul]
simp only [(algebra_map R S).map_add, submonoid.coe_mul, (algebra_map R S).map_mul]
ring_exp
simp
rintros a b ⟨a', ha⟩ ⟨b', hb⟩
use ⟨a'.2 * b'.1 + b'.2 * a'.1, I.add_mem (I.mul_mem_left _ b'.1.2) (I.mul_mem_left _ a'.1.2)⟩
use a'.2 * b'.2
simp only [ring_hom.map_add, submodule.coe_mk, submonoid.coe_mul, ring_hom.map_mul]
rw [add_mul, ← mul_assoc a, ha, mul_comm (algebra_map R S a'.2) (algebra_map R S b'.2), ← mul_assoc b, hb]
ring
rintros c x ⟨x', hx⟩
obtain ⟨c', hc⟩ := is_localization.surj M c
use ⟨c'.1 * x'.1, I.mul_mem_left c'.1 x'.1.2⟩
use c'.2 * x'.2
simp only [←hx, ←hc, smul_eq_mul, submodule.coe_mk, submonoid.coe_mul, ring_hom.map_mul]
ring
simp [matrix_equiv_tensor, to_fun_alg_hom, alg_hom_of_linear_map_tensor_product, to_fun_linear]
refl
simp [mul_pow]
exact ⟨this, nat.find_min' _ hsucc⟩
rw [enat.le_coe_iff]
haveI := classical.dec_eq M
haveI := classical.dec_eq R
haveI := classical.dec_eq P
cases hs2 with t2 ht2
cases hs1 with t1 ht1
have : ∀ y ∈ t1, ∃ x ∈ s, f x = y
intros y hy
rw ← ht1
exact subset_span hy
{ rw ← ht1, exact subset_span hy }
have : y ∈ map f s
rcases mem_map.1 this with ⟨x, hx1, hx2⟩
{ intros y hy, have : y ∈ map f s, { rw ← ht1, exact subset_span hy }, rcases mem_map.1 this with ⟨x, hx1, hx2⟩, exact ⟨x, hx1, hx2⟩ }
exact ⟨x, hx1, hx2⟩
have : ∃ g : P → M, ∀ y ∈ t1, g y ∈ s ∧ f (g y) = y
choose g hg1 hg2
existsi λ y, if H : y ∈ t1 then g y H else 0
split
intros y H
apply hg1
{ simp only [dif_pos H], apply hg1 }
simp only [dif_pos H]
apply hg2
{ choose g hg1 hg2, existsi λ y, if H : y ∈ t1 then g y H else 0, intros y H, split, { simp only [dif_pos H], apply hg1 }, { simp only [dif_pos H], apply hg2 } }
simp only [dif_pos H]
clear this
cases this with g hg
existsi t1.image g ∪ t2
rw [finset.coe_union, span_union, finset.coe_image]
apply le_antisymm
refine sup_le (span_le.2 $ image_subset_iff.2 _) (span_le.2 _)
exact (hg y hy).1
{ intros y hy, exact (hg y hy).1 }
intros y hy
have := subset_span hx
intros x hx
rw ht2 at this
{ refine sup_le (span_le.2 $ image_subset_iff.2 _) (span_le.2 _), { intros y hy, exact (hg y hy).1 }, { intros x hx, have := subset_span hx, rw ht2 at this, exact this.1 } }
exact this.1
intros x hx
rw mem_map
exact ⟨x, hx, rfl⟩
have : f x ∈ map f s
{ rw mem_map, exact ⟨x, hx, rfl⟩ }
rw [← ht1,← set.image_id ↑t1, finsupp.mem_span_image_iff_total] at this
rcases this with ⟨l, hl1, hl2⟩
refine mem_sup.2 ⟨(finsupp.total M M R id).to_fun ((finsupp.lmap_domain R R g : (P →₀ R) → M →₀ R) l), _, x - finsupp.total M M R id ((finsupp.lmap_domain R R g : (P →₀ R) → M →₀ R) l), _, add_sub_cancel'_right _ _⟩
rw [← set.image_id (g '' ↑t1), finsupp.mem_span_image_iff_total]
refine ⟨_, _, rfl⟩
haveI : inhabited P := ⟨0⟩
rw [← finsupp.lmap_domain_supported _ _ g, mem_map]
refine ⟨l, hl1, _⟩
{ rw [← set.image_id (g '' ↑t1), finsupp.mem_span_image_iff_total], refine ⟨_, _, rfl⟩, haveI : inhabited P := ⟨0⟩, rw [← finsupp.lmap_domain_supported _ _ g, mem_map], refine ⟨l, hl1, _⟩, refl, }
refl
split
rw [ht2, mem_inf]
apply s.sub_mem hx
rw [finsupp.total_apply, finsupp.lmap_domain_apply, finsupp.sum_map_domain_index]
refine s.sum_mem _
exact s.smul_mem _ (hg y (hl1 hy)).1
{ intros y hy, exact s.smul_mem _ (hg y (hl1 hy)).1 }
intros y hy
{ exact zero_smul _ }
exact λ _ _ _, add_smul _ _ _
{ apply s.sub_mem hx, rw [finsupp.total_apply, finsupp.lmap_domain_apply, finsupp.sum_map_domain_index], refine s.sum_mem _, { intros y hy, exact s.smul_mem _ (hg y (hl1 hy)).1 }, { exact zero_smul _ }, { exact λ _ _ _, add_smul _ _ _ } }
exact zero_smul _
rw [linear_map.mem_ker, f.map_sub, ← hl2]
rw [finsupp.total_apply, finsupp.total_apply, finsupp.lmap_domain_apply]
rw [finsupp.sum_map_domain_index, finsupp.sum, finsupp.sum, f.map_sum]
rw sub_eq_zero
refine finset.sum_congr rfl (λ y hy, _)
unfold id
rw [f.map_smul, (hg y (hl1 hy)).2]
refine classical.by_contradiction (λ hf, (rel_embedding.well_founded_iff_no_descending_seq.1 (well_founded_submodule_gt R M)).elim' _)
from @infinite.nat_embedding s ⟨λ f, hf ⟨f⟩⟩
have f : ℕ ↪ s
have : ∀ n, (coe ∘ f) '' {m | m ≤ n} ⊆ s
subst hy₂
exact (f y).2
{ rintros n x ⟨y, hy₁, hy₂⟩, subst hy₂, exact (f y).2 }
rintros n x ⟨y, hy₁, hy₂⟩
have : ∀ a b : ℕ, a ≤ b ↔ span R ((coe ∘ f) '' {m | m ≤ a}) ≤ span R ((coe ∘ f) '' {m | m ≤ b})
assume a b
rw [span_le_span_iff hs (this a) (this b), set.image_subset_image_iff (subtype.coe_injective.comp f.injective), set.subset_def]
exact ⟨λ hab x (hxa : x ≤ a), le_trans hxa hab, λ hx, hx a (le_refl a)⟩
{ assume a b, rw [span_le_span_iff hs (this a) (this b), set.image_subset_image_iff (subtype.coe_injective.comp f.injective), set.subset_def], exact ⟨λ hab x (hxa : x ≤ a), le_trans hxa hab, λ hx, hx a (le_refl a)⟩ }
exact ⟨⟨λ n, span R ((coe ∘ f) '' {m | m ≤ n}), λ x y, by simp [le_antisymm_iff, (this _ _).symm] {contextual := tt}⟩, by dsimp [gt]; simp only [lt_iff_le_not_le, (this _ _).symm]; tauto⟩
simp [le_antisymm_iff, (this _ _).symm] {contextual := tt}
dsimp [gt]; simp only [lt_iff_le_not_le, (this _ _).symm]; tauto
dsimp [gt]; simp only [lt_iff_le_not_le, (this _ _).symm]
simp only [lt_iff_le_not_le, (this _ _).symm]
tauto
dsimp [gt]
intros p hp x hx
rw ← mem_vanishing_ideal_singleton_iff
rw radical_eq_Inf at hp
refine (mem_Inf.mp hp) ⟨le_trans (le_vanishing_ideal_zero_locus I) (vanishing_ideal_anti_mono (λ y hy, hy.symm ▸ hx)), is_maximal.is_prime' _⟩
rw [map_map, perfection.coeff_map]
ext i
simp only [mem_support_iff, not_iff_not, ne.def]
rw [← coeff_restriction]
conv_rhs { rw [← coeff_restriction] }
rw H
refl
exact ⟨λ H, by { rw H, refl }, λ H, subtype.coe_injective H⟩
simp only [restriction, finset.sum_empty, support_zero]
simp only [coe_eval₂_ring_hom, eval₂_mul]
simp only [eval₂_add, coe_eval₂_ring_hom]
intro f
apply polynomial.induction_on' f
intros p q hp hq
simp only [coe_eval₂_ring_hom] at hp
simp only [coe_eval₂_ring_hom] at hq
{ intros p q hp hq, simp only [coe_eval₂_ring_hom] at hp, simp only [coe_eval₂_ring_hom] at hq, simp only [coe_eval₂_ring_hom, hp, hq, ring_hom.map_add] }
simp only [coe_eval₂_ring_hom, hp, hq, ring_hom.map_add]
rintros n ⟨x⟩
simp only [monomial_eq_smul_X, C_mul', quotient.lift_mk, submodule.quotient.quot_mk_eq_mk, quotient.mk_eq_mk, eval₂_X_pow, eval₂_smul, coe_eval₂_ring_hom, ring_hom.map_pow, eval₂_C, ring_hom.coe_comp, ring_hom.map_mul, eval₂_X]
rintro ⟨f⟩
apply polynomial.induction_on' f
simp_intros p q hp hq
{ simp_intros p q hp hq, rw [hp, hq] }
rw [hp, hq]
intros n a
simp only [monomial_eq_smul_X, ← C_mul' a (X ^ n), quotient.lift_mk, submodule.quotient.quot_mk_eq_mk, quotient.mk_eq_mk, eval₂_X_pow, eval₂_smul, coe_eval₂_ring_hom, ring_hom.map_pow, eval₂_C, ring_hom.coe_comp, ring_hom.map_mul, eval₂_X]
have : eval₂ (ring_hom.id _) (λ s, (0:R)) (0 : mv_polynomial σ R) = eval₂ (ring_hom.id _) (λ s, (0:R)) (1 : mv_polynomial σ R)
exact H
{ congr, exact H }
congr
simpa
apply_instance
dsimp [bernstein_polynomial]
suffices : ↑((n + 1).choose (ν + 1)) * ((↑ν + 1) * X ^ ν) * (1 - X) ^ (n - ν) -(↑((n + 1).choose (ν + 1)) * X ^ (ν + 1) * (↑(n - ν) * (1 - X) ^ (n - ν - 1))) = (↑n + 1) * (↑(n.choose ν) * X ^ ν * (1 - X) ^ (n - ν) - ↑(n.choose (ν + 1)) * X ^ (ν + 1) * (1 - X) ^ (n - (ν + 1)))
{ simpa [polynomial.derivative_pow, ←sub_eq_add_neg], }
simpa [polynomial.derivative_pow, ←sub_eq_add_neg]
rw mul_sub
conv_rhs { rw mul_sub, }
refine congr (congr_arg has_sub.sub _) _
simp only [←mul_assoc]
refine congr (congr_arg (*) (congr (congr_arg (*) _) rfl)) rfl
exact_mod_cast congr_arg (λ m : ℕ, (m : polynomial R)) (nat.succ_mul_choose_eq n ν).symm
{ simp only [←mul_assoc], refine congr (congr_arg (*) (congr (congr_arg (*) _) rfl)) rfl, exact_mod_cast congr_arg (λ m : ℕ, (m : polynomial R)) (nat.succ_mul_choose_eq n ν).symm, }
rw [←mul_assoc,←mul_assoc]
congr' 1
rw nat.sub_sub
rw [←mul_assoc,←mul_assoc]
congr' 1
rw mul_comm
norm_cast
congr' 1
convert (nat.choose_mul_succ_eq n (ν + 1)).symm using 1
convert mul_comm _ _ using 2
{ convert mul_comm _ _ using 2, simp, }
simp
apply mul_comm
let x : mv_polynomial bool R := mv_polynomial.X tt
let y : mv_polynomial bool R := mv_polynomial.X ff
have pderiv_tt_x : pderiv tt x = 1
simp [x]
{ simp [x], }
have pderiv_tt_y : pderiv tt y = 0
simp [pderiv_X, y]
{ simp [pderiv_X, y], }
let e : bool → polynomial R := λ i, cond i X (1-X)
have h : (x+y)^n = (x+y)^n := rfl
apply_fun (pderiv tt) at h
apply_fun (pderiv tt) at h
apply_fun (aeval e) at h
apply_fun (λ p, p * X^2) at h
have w : ∀ k : ℕ, ↑k * (↑(k-1) * polynomial.X ^ (k - 1 - 1)) * (1 - polynomial.X) ^ (n - k) * ↑(n.choose k) * polynomial.X^2 = (k * (k-1)) • bernstein_polynomial R n k
rintro (_|k)
{ simp, }
simp
rcases k with (_|k)
{ simp, }
simp
dsimp [bernstein_polynomial]
simp only [←nat_cast_mul, nat.succ_eq_add_one, nat.add_succ_sub_one, add_zero, pow_succ]
push_cast
{ rintro (_|k), { simp, }, { rcases k with (_|k), { simp, }, { dsimp [bernstein_polynomial], simp only [←nat_cast_mul, nat.succ_eq_add_one, nat.add_succ_sub_one, add_zero, pow_succ], push_cast, ring, }, }, }
ring
conv at h { to_lhs, rw [add_pow, (pderiv tt).map_sum, (pderiv tt).map_sum, (mv_polynomial.aeval e).map_sum, finset.sum_mul], apply_congr, skip, simp [pderiv_mul, pderiv_tt_x, pderiv_tt_y, e, w] }
to_lhs
rw [add_pow, (pderiv tt).map_sum, (pderiv tt).map_sum, (mv_polynomial.aeval e).map_sum, finset.sum_mul]
skip
apply_congr
simp [pderiv_mul, pderiv_tt_x, pderiv_tt_y, e, w]
conv at h { to_rhs, simp only [pderiv_one, pderiv_mul, pderiv_pow, pderiv_nat_cast, (pderiv tt).map_add, pderiv_tt_x, pderiv_tt_y], simp [e, smul_smul] }
to_rhs
simp only [pderiv_one, pderiv_mul, pderiv_pow, pderiv_nat_cast, (pderiv tt).map_add, pderiv_tt_x, pderiv_tt_y]
simp [e, smul_smul]
simpa using h
norm_num [bernstein_polynomial, choose]
ring
dsimp [bernstein_polynomial]
simp [h, nat.sub_sub_assoc, mul_right_comm]
rw content_eq_gcd_range_of_lt p (max p.nat_degree q.nat_degree).succ (lt_of_le_of_lt (le_max_left _ _) (nat.lt_succ_self _))
rw content_eq_gcd_range_of_lt q (max p.nat_degree q.nat_degree).succ (lt_of_le_of_lt (le_max_right _ _) (nat.lt_succ_self _))
apply finset.gcd_eq_of_dvd_sub
intros x hx
cases h with w hw
use w.coeff x
rw [← coeff_sub, hw, coeff_C_mul]
apply is_homogeneous_monomial
simp only [finsupp.support_single_ne_zero one_ne_zero, finset.sum_singleton]
exact finsupp.single_eq_same
simp only [monic, leading_coeff, nat_degree_scale_roots, coeff_scale_roots_nat_degree]
apply le_order
rw [coeff_mul, finset.sum_eq_zero]
intros n hn
rintros ⟨i,j⟩ hij
by_cases hi : ↑i < order φ
{ rw [coeff_of_lt_order φ i hi, zero_mul] }
rw [coeff_of_lt_order φ i hi, zero_mul]
by_cases hj : ↑j < order ψ
{ rw [coeff_of_lt_order ψ j hj, mul_zero] }
rw [coeff_of_lt_order ψ j hj, mul_zero]
rw finset.nat.mem_antidiagonal at hij
rw not_lt at hi hj
exfalso
apply ne_of_lt (lt_of_lt_of_le hn $ add_le_add hi hj)
rw [← nat.cast_add, hij]
rw [order_monomial, if_neg h]
have := coe_monomial 0 (1:R)
rwa power_series.monomial_zero_eq_C_apply at this
simpa using coeff_add_monomial_mul 0 n φ a
refine ⟨h1, _⟩
intros l hl
apply dvd_trans _ (k.gcd_dvd_right l)
rw this
{ rw this }
suffices : k.gcd l = k
rw eq_iff_le_not_lt
refine ⟨nat.le_of_dvd hk (k.gcd_dvd_left l), _⟩
apply h _ (nat.gcd_pos_of_pos_left _ hk) h'
intro h'
exact pow_gcd_eq_one _ h1 hl
by_cases h0 : 0 ≤ i
lift i to ℕ using h0
rw gpow_coe_nat
{ lift i to ℕ using h0, rw gpow_coe_nat, exact h.pow_of_coprime i hi }
exact h.pow_of_coprime i hi
simp only [not_le, neg_nonneg] at h0 ⊢
have : 0 ≤ -i
exact le_of_lt h0
{ simp only [not_le, neg_nonneg] at h0 ⊢, exact le_of_lt h0 }
lift -i to ℕ using this with i' hi'
rw [← inv_iff, ← gpow_neg, ← hi', gpow_coe_nat]
apply h.pow_of_coprime
rw [int.gcd, ← int.nat_abs_neg, ← hi'] at hi
exact hi
apply (eq_or_eq_neg_of_sq_eq_sq ζ 1 _).resolve_left
apply h.pow_ne_one_of_pos_of_lt
apply h.pow_ne_one_of_pos_of_lt; dec_trivial
dec_trivial
dec_trivial
rw [← pow_one ζ]
{ rw [← pow_one ζ], apply h.pow_ne_one_of_pos_of_lt; dec_trivial }
simp only [h.pow_eq_one, one_pow]
obtain ⟨n, rfl⟩ : ∃ n : ℤ, ζ ^ n = ξ
rwa [← h.gpowers_eq] at hξ
exact_mod_cast k.pos
have hk0 : (0 : ℤ) < k := by exact_mod_cast k.pos
let i := n % k
have hi0 : 0 ≤ i := int.mod_nonneg _ (ne_of_gt hk0)
lift i to ℕ using hi0 with i₀ hi₀
refine ⟨i₀, _, _⟩
rw [hi₀]
exact int.mod_lt_of_pos _ hk0
{ zify, rw [hi₀], exact int.mod_lt_of_pos _ hk0 }
zify
rw [← coe_coe] at aux
have aux := h.gpow_eq_one
rw [← gpow_coe_nat, hi₀, ← int.mod_add_div n k, gpow_add, gpow_mul, aux, one_gpow, mul_one]
obtain ⟨d, rfl⟩ := h
intros ζ h
simp only [mem_roots_of_unity, pnat.mul_coe, pow_mul, one_pow, *] at *
apply eq_bot_or_eq_top
have h : (⊥ : submodule R M) ≠ ⊤ := bot_ne_top
contrapose! h
ext
simp [submodule.mem_bot,submodule.mem_top, h x]
rw [← ker_eq_bot, ← ker_eq_top]
rw [coe_range, coe_top]
apply tensor_product.induction_on x
{ simp, }
simp
intros a₁ b₁
apply tensor_product.induction_on y
{ simp, }
simp
intros a₂ b₂
{ intros a₂ b₂, simp [mul_comm], }
simp [mul_comm]
intros a₂ b₂ ha hb
{ intros a₁ b₁, apply tensor_product.induction_on y, { simp, }, { intros a₂ b₂, simp [mul_comm], }, { intros a₂ b₂ ha hb, simp [mul_add, add_mul, ha, hb], }, }
simp [mul_add, add_mul, ha, hb]
intros x₁ x₂ h₁ h₂
simp [mul_add, add_mul, h₁, h₂]
apply_instance
apply_instance
apply_instance
by_cases H : ∃ (s : finset L), nonempty (basis s K L)
rw [trace_algebra_map_of_basis H.some_spec.some, finrank_eq_card_basis H.some_spec.some]
{ rw [trace_algebra_map_of_basis H.some_spec.some, finrank_eq_card_basis H.some_spec.some] }
simp [trace_eq_zero_of_not_exists_basis K H, finrank_eq_zero_of_not_exists_basis_finset H]
split
intros hg p ha hb hp
refine ((associates.prime_mk _).mpr hp).not_unit (is_unit_of_dvd_one _ _)
rw ← hg
exact le_inf (mk_le_mk_of_dvd ha) (mk_le_mk_of_dvd hb)
{ intros hg p ha hb hp, refine ((associates.prime_mk _).mpr hp).not_unit (is_unit_of_dvd_one _ _), rw ← hg, exact le_inf (mk_le_mk_of_dvd ha) (mk_le_mk_of_dvd hb) }
contrapose
intros hg hc
obtain ⟨p, hp, hpa, hpb⟩ := exists_prime_dvd_of_not_inf_one ha0 hb0 hg
exact hc hpa hpb hp
obtain ⟨p, a_assoc, hp⟩ := prime_factors_irreducible ha ⟨prime_of_factor, factors_prod ha.ne_zero⟩
have p_mem : p ∈ factors a
exact multiset.mem_singleton_self _
{ rw hp, exact multiset.mem_singleton_self _ }
rw hp
convert hp
rwa [← normalize_factor p p_mem, normalize_eq_normalize_iff, dvd_dvd_iff_associated]
split
rintro ⟨c, rfl⟩
{ rintro ⟨c, rfl⟩, simp [hx, right_ne_zero_of_mul hy] }
simp [hx, right_ne_zero_of_mul hy]
rw [← (factors_prod hx).dvd_iff_dvd_left, ← (factors_prod hy).dvd_iff_dvd_right]
apply multiset.prod_dvd_prod
simp
simp [hx]
{ simp [hx] }
by_cases hx : x = 0
simp [hy]
{ simp [hy] }
by_cases hy : y = 0
simp [hx, hy]
intro x
dsimp
simp [hx]
{ simp [hx] }
by_cases hx : x = 0
have h : associates.mk_monoid_hom ∘ (classical.some mk_surjective.has_right_inverse) = (id : associates α → associates α)
ext x
rw [function.comp_apply, mk_monoid_hom_apply, classical.some_spec mk_surjective.has_right_inverse x]
{ ext x, rw [function.comp_apply, mk_monoid_hom_apply, classical.some_spec mk_surjective.has_right_inverse x], refl }
refl
rw [if_neg hx, ← mk_monoid_hom_apply, monoid_hom.map_multiset_prod, map_map, h, map_id, ← associated_iff_eq]
apply factors_prod hx
rw ← pow_dvd_iff_le_multiplicity
revert b
simp
{ simp }
induction n with n ih
intros b hb
split
rintro ⟨c, rfl⟩
rw [ne.def, pow_succ, mul_assoc, mul_eq_zero, decidable.not_or_iff_and_not] at hb
rw [pow_succ, mul_assoc, factors_mul hb.1 hb.2, repeat_succ, factors_irreducible ha, singleton_add, cons_le_cons_iff, ← ih hb.2]
{ rintro ⟨c, rfl⟩, rw [ne.def, pow_succ, mul_assoc, mul_eq_zero, decidable.not_or_iff_and_not] at hb, rw [pow_succ, mul_assoc, factors_mul hb.1 hb.2, repeat_succ, factors_irreducible ha, singleton_add, cons_le_cons_iff, ← ih hb.2], apply dvd.intro _ rfl }
apply dvd.intro _ rfl
rw [multiset.le_iff_exists_add]
rintro ⟨u, hu⟩
rw [← (factors_prod hb).dvd_iff_dvd_right, hu, prod_add, prod_repeat]
exact (associated.pow_pow $ associated_normalize a).dvd.trans (dvd.intro u.prod rfl)
simp
simp
rw [← factor_set.coe_add, prod_coe, prod_coe, prod_coe, multiset.map_add, multiset.prod_add]
rw [hpm.as_sum, eval₂_add, eval₂_pow, eval₂_X, eval₂_finset_sum, add_eq_zero_iff_eq_neg] at hpx
refine ne_of_gt _ hpx
replace hpx := congr_arg v hpx
rw [v.map_neg, v.map_pow]
refine v.map_sum_lt' (zero_lt_one''.trans_le (one_le_pow_of_one_le' hvx.le _)) (λ i hi, _)
rw [eval₂_mul, eval₂_pow, eval₂_C, eval₂_X, v.map_mul, v.map_pow, ← one_mul (v x ^ p.nat_degree)]
cases (hv.2 $ p.coeff i).lt_or_eq with hvpi hvpi
exact mul_lt_mul'''' hvpi (pow_lt_pow' hvx $ finset.mem_range.1 hi)
{ exact mul_lt_mul'''' hvpi (pow_lt_pow' hvx $ finset.mem_range.1 hi) }
rw [one_mul, one_mul]
exact pow_lt_pow' hvx (finset.mem_range.1 hi)
erw hvpi
rw from_padic_int_comp_to_padic_int
simp [has_sub.sub, eval]
induction n with n ih
simp only [witt_mul_n, nat.cast_zero, zero_mul, bind₁_zero_witt_polynomial]
{ simp only [witt_mul_n, nat.cast_zero, zero_mul, bind₁_zero_witt_polynomial] }
rw [witt_mul_n, ← bind₁_bind₁, witt_add, witt_structure_int_prop]
simp only [alg_hom.map_add, nat.cast_succ, bind₁_X_right]
rw [add_mul, one_mul, bind₁_rename, bind₁_rename]
simp only [ih, function.uncurry, function.comp, bind₁_X_left, alg_hom.id_apply, matrix.cons_val_zero, matrix.head_cons, matrix.cons_val_one]
refine ⟨witt_structure_rat p Φ, _, _⟩
apply witt_structure_rat_prop
{ intro n, apply witt_structure_rat_prop }
intro n
intros φ H
funext n
rw show φ n = bind₁ φ (bind₁ (W_ ℚ) (X_in_terms_of_W p ℚ n)), { rw [bind₁_witt_polynomial_X_in_terms_of_W p, bind₁_X_right] }
rw [bind₁_witt_polynomial_X_in_terms_of_W p, bind₁_X_right]
rw [bind₁_bind₁]
exact eval₂_hom_congr (ring_hom.ext_rat _ _) (funext H) rfl
rw [submodule.eq_bot_iff]
intros x hx
ext
simp only [witt_vector.mem_ker_truncate, ideal.mem_infi, witt_vector.zero_coeff] at hx ⊢
exact hx _ _ (nat.lt_succ_self _)
ext1 x
rw [← sub_eq_zero, ← ideal.mem_bot, ← infi_ker_truncate, ideal.mem_infi]
intro i
simp only [ring_hom.mem_ker, g_compat, ←ring_hom.comp_apply, truncate_comp_lift, ring_hom.map_sub, sub_self]
simp only [witt_polynomial_eq_sum_C_mul_X_pow, sum_range_succ_comm, range_one, sum_singleton, one_mul, pow_one, C_1, pow_zero]
rw [fintype_card, nat_cast_inj, fintype.card_coe]
convert mk_preimage_of_subset_range _ _ h using 1
rw [image_eq_range] at h
refl
rw [mk_sep]
have := H i; rwa [← quot.out_eq (f i), ← quot.out_eq (g i)] at this
rwa [← quot.out_eq (f i), ← quot.out_eq (g i)] at this
have := H i
rw [← to_nat_cast 0, nat.cast_zero]
simp [bit0]
rw [← not_lt, ← not_lt, aleph_idx_lt]
simpa using cof_le_card 0
rw typein_enum; apply ordinal.lt_succ_self
apply ordinal.lt_succ_self
rw typein_enum
simp_rw [← succ_le]
exact ordinal.infinite_pigeonhole_card f (#α).succ (succ_le.mpr w) (w'.trans (lt_succ_self _).le) ((lt_succ_self _).trans_le (succ_is_regular w').2.ge)
simp_rw [cardinal.infinite_iff] at ⊢ w'
cases infinite_pigeonhole_card_lt f w w' with a ha
exact ⟨a, w'.trans ha.le⟩
rintro ⟨x⟩
apply quot.sound
apply zero_add_equiv
cases y
refl
cases x
dsimp [left] at h
have w₁ : m ∈ b
rw finset.mem_inter at h
{ rw finset.mem_inter at h, exact h.1 }
exact h.1
have w₂ : (m.1, m.2 - 1) ∈ b.erase m
simp only [finset.mem_erase]
fsplit
{ exact λ w, pred_ne_self m.2 (congr_arg prod.snd w) }
exact λ w, pred_ne_self m.2 (congr_arg prod.snd w)
rw finset.mem_inter at h
clear h
have h₂ := h.2
rw finset.mem_map at h₂
rcases h₂ with ⟨m', ⟨h₂, rfl⟩⟩
dsimp [shift_up]
{ simp only [finset.mem_erase], fsplit, { exact λ w, pred_ne_self m.2 (congr_arg prod.snd w) }, { rw finset.mem_inter at h, have h₂ := h.2, clear h, rw finset.mem_map at h₂, rcases h₂ with ⟨m', ⟨h₂, rfl⟩⟩, dsimp [shift_up], simpa, }, }
simpa
have i₁ := finset.card_erase_lt_of_mem w₁
have i₂ := nat.lt_of_le_of_lt (nat.zero_le _) (finset.card_erase_lt_of_mem w₂)
exact nat.lt_of_le_of_lt i₂ i₁
apply_instance
apply_instance
apply_instance
apply_instance
apply_instance
apply_instance
apply_instance
apply_instance
exfalso
exact turn_bound_ne_zero_of_left_move t.2 (nonpos_iff_eq_zero.mp h)
exfalso
exact turn_bound_ne_zero_of_right_move t.2 (nonpos_iff_eq_zero.mp h)
refine ⟨λ h, _, λ ⟨h₁, h₂⟩, equiv.antisymm h₁ h₂⟩
cases h with _ _ _ h₁ h₂
{ simp [lists'.subset.refl] }
exact ⟨h₁, h₂⟩
simp [lists'.subset.refl]
apply_instance
simp only [mk_def, card_type]
resetI
split
split; intro h
intro h
intro h
exact let ⟨f⟩ := h in ⟨f.to_embedding⟩
{ rw e at h, exact let ⟨f⟩ := h in ⟨f.to_embedding⟩ }
rw e at h
cases h with f
have g := rel_embedding.preimage f s
haveI := rel_embedding.is_well_order g
exact le_trans (ord_le_type _) (type_le'.2 ⟨g⟩)
simp at h ⊢
simp only [ord_le, card_ord]
have h := g.1.map_rel_iff.1 h
rcases g.2 _ _ h with ⟨b, rfl⟩
exact ⟨a', rfl⟩
rcases f.2 _ _ h with ⟨a', rfl⟩
have ef : (f : α → β) = g
show ((f : r ≼i s) : α → β) = g
refl
{ show ((f : r ≼i s) : α → β) = g, rw @subsingleton.elim _ _ (f : r ≼i s) g, refl }
rw @subsingleton.elim _ _ (f : r ≼i s) g
have et : f.top = g.top
refine @is_extensional.ext _ s _ _ _ (λ x, _)
simp only [f.down, g.down, ef, coe_fn_to_rel_embedding]
{ refine @is_extensional.ext _ s _ _ _ (λ x, _), simp only [f.down, g.down, ef, coe_fn_to_rel_embedding] }
cases g
cases f
have := rel_embedding.coe_fn_injective ef
have := rel_embedding.coe_fn_injective ef; congr'
congr'
simp only [le_antisymm_iff, lift_le]
resetI
rw [mk_def, card_type, ← cardinal.lift_id'.{(max u v) u} (#β), ← cardinal.lift_umax.{u v}, lift_mk_eq.{u (max u v) (max u v)}] at e'
cases e' with f
have g := rel_iso.preimage f s
haveI := (g : ⇑f ⁻¹'o s ↪r s).is_well_order
have := lift_type_eq.{u (max u v) (max u v)}.2 ⟨g⟩
rw [lift_id, lift_umax.{u v}] at this
exact ⟨_, this⟩
cases lt_or_eq_of_le (one_le_iff_pos.2 h₁) with h₁ h₁
{ exact (power_le_power_iff_right h₁).2 h₂ }
exact (power_le_power_iff_right h₁).2 h₂
simp only [one_power]
subst a
simp only [n0, nat.div_zero, nat.cast_zero, div_zero]
rw [le_div n0', ← nat_cast_mul, nat_cast_le, mul_comm]; apply nat.div_mul_le_self
rw [le_div n0', ← nat_cast_mul, nat_cast_le, mul_comm]
apply nat.div_mul_le_self
rw [div_le n0', succ, ← nat.cast_succ, ← nat_cast_mul, nat_cast_lt, mul_comm, ← nat.div_lt_iff_lt_mul _ _ (nat.pos_of_ne_zero n0)]
rw [div_le n0', succ, ← nat.cast_succ, ← nat_cast_mul, nat_cast_lt, mul_comm, ← nat.div_lt_iff_lt_mul _ _ (nat.pos_of_ne_zero n0)]; apply nat.lt_succ_self
apply nat.lt_succ_self
simpa only [one_mul] using mul_le_mul_right omega (one_le_iff_pos.2 a0)
rw [h, ← e, lift_succ]
simp only [h, lift_succ]
rw [limit_rec_on, well_founded.fix_eq, dif_pos rfl]
rw [limit_rec_on, well_founded.fix_eq, dif_pos rfl]; refl
refl
rwa add_zero
rw [lt_sub, add_succ]
rw [lt_sub, add_succ]; exact l.2 _ (lt_sub.1 h)
exact l.2 _ (lt_sub.1 h)
rwa [zero_power', ordinal.sub_eq_zero_iff_le, one_le_iff_ne_zero]
simp only [pow, power, if_neg a0]; rw limit_rec_on_limit _ _ _ _ h; refl
simp only [pow, power, if_neg a0]; rw limit_rec_on_limit _ _ _ _ h
rw limit_rec_on_limit _ _ _ _ h
simp only [pow, power, if_neg a0]
cases o
cases o; exact NF.zero
exact NF.zero
exact NF.zero
rwa ←((eq_empty y).2 $ λ z zx, n ⟨z, zx⟩)
simp [Inf_eq_infi, infi_and]
conversion infi_eq_elim.old_conv
simp [Sup_eq_supr, supr_and]
conversion supr_eq_elim.old_conv
simp [bit0]
simp [bit1, bit0]
simpa [eq.symm h1, eq.symm h2, int.coe_nat_lt]
simp *
apply h
rw [← hx,← hy]
rwa [← e2, ← e1, ← hn, normalize_fin, add_comm, nat.add_mul_mod_self_left] at h
simp only [normalize_fin, ← h] at *; rw [nat.add_mod, ← ha, ← hb, fin.add_def]
rw [nat.add_mod, ← ha, ← hb, fin.add_def]
simp only [normalize_fin, ← h] at *
simp [bit0, add_left_comm, add_assoc]
simp [bit0, add_left_comm, add_assoc]
apply h
apply h
apply h
preform.induce `[intros v h, try {apply h}]
cases p with t s t s; try {apply h}
try {apply h}
try {apply h}
try {apply h}
try {apply h}
try {apply h}
apply h
cases p with t s t s
apply or.symm
simpa only [preform.holds, le_and_le_iff_eq.symm, not_and_distrib, not_le] using h
{ apply or.symm, simpa only [preform.holds, le_and_le_iff_eq.symm, not_and_distrib, not_le] using h }
simpa only [preform.holds, not_le, int.add_one_le_iff] using h
{ cases p with t s t s; try {apply h}, { apply or.symm, simpa only [preform.holds, le_and_le_iff_eq.symm, not_and_distrib, not_le] using h }, simpa only [preform.holds, not_le, int.add_one_le_iff] using h }
cases h
cases h; [{left, apply ihp}, {right, apply ihq}]; assumption
cases h; [{left, apply ihp}, {right, apply ihq}]
simp only [neg_elim_core]
apply ihp
right
apply ihq
left
{ simp only [neg_elim_core], cases h; [{left, apply ihp}, {right, apply ihq}]; assumption }
assumption
assumption
apply and.imp (ihp _) (ihq _) h
simp [h₃.symm, h₂.symm, h₁.symm, horner, add_mul, mul_comm (x ^ n)]
simp [h₃.symm, h₂.symm, h₁.symm, horner, add_mul, mul_comm (x ^ n)]; cc
cc
rw ← (horner_expr.cseval_of_csexpr t _).2
rw ← (horner_expr.cseval_of_csexpr t _).2
rw ← (horner_expr.cseval_of_csexpr t _).2
repeat {rw ← (horner_expr.cseval_of_csexpr t _).2}
repeat {rw ← (horner_expr.cseval_of_csexpr t _).2}; rw H
rw H
apply ne_of_gt
apply nat.lt_add_of_pos_right
apply nat.pos_of_ne_zero
contradiction
simp only [list.apply_id]
cases h₃ : (lookup x (map prod.to_sigma (xs.zip ys)))
dsimp [option.get_or_else]
{ dsimp [option.get_or_else], rw h₁.mem_iff }
rw h₁.mem_iff
have h₂ : ys.nodup := h₁.nodup_iff.1 h₀
replace h₁ : xs.length = ys.length := h₁.length_eq
dsimp
induction xs generalizing ys
case list.nil : ys h₃ h₂ h₁ { contradiction }
contradiction
case list.cons : x' xs xs_ih ys h₃ h₂ h₁ { cases ys with y ys, { cases h₃ }, dsimp [lookup] at h₃, split_ifs at h₃, { subst x', subst val, simp only [mem_cons_iff, true_or, eq_self_iff_true], }, { cases h₀ with _ _ h₀ h₅, cases h₂ with _ _ h₂ h₄, have h₆ := nat.succ.inj h₁, specialize @xs_ih h₅ ys h₃ h₄ h₆, simp only [ne.symm h, xs_ih, mem_cons_iff, false_or], suffices : val ∈ ys, tauto!, erw [← option.mem_def, mem_lookup_iff] at h₃, simp only [to_sigma, mem_map, heq_iff_eq, prod.exists] at h₃, rcases h₃ with ⟨a, b, h₃, h₄, h₅⟩, subst a, subst b, apply (mem_zip h₃).2, simp only [nodupkeys, keys, comp, prod.fst_to_sigma, map_map], rwa map_fst_zip _ _ (le_of_eq h₆) } }
cases ys with y ys
{ cases h₃ }
cases h₃
split_ifs at h₃
dsimp [lookup] at h₃
subst val
subst x'
{ subst x', subst val, simp only [mem_cons_iff, true_or, eq_self_iff_true], }
simp only [mem_cons_iff, true_or, eq_self_iff_true]
cases h₀ with _ _ h₀ h₅
cases h₂ with _ _ h₂ h₄
have h₆ := nat.succ.inj h₁
specialize @xs_ih h₅ ys h₃ h₄ h₆
simp only [ne.symm h, xs_ih, mem_cons_iff, false_or]
tauto!
suffices : val ∈ ys
erw [← option.mem_def, mem_lookup_iff] at h₃
simp only [to_sigma, mem_map, heq_iff_eq, prod.exists] at h₃
rcases h₃ with ⟨a, b, h₃, h₄, h₅⟩
subst b
subst a
apply (mem_zip h₃).2
simp only [nodupkeys, keys, comp, prod.fst_to_sigma, map_map]
rwa map_fst_zip _ _ (le_of_eq h₆)
simp only [tendsto_pure_left, has_basis_coclosed_compact.tendsto_left_iff, forall_and_distrib, and_assoc, exists_prop]
rw [continuous_at, nhds_coe_eq, tendsto_map'_iff, continuous_at]
refine ⟨λ h, _, λ h, _⟩
exact (h.comp continuous_fst).mul continuous_snd
simp only [algebra.smul_def]
{ simp only [algebra.smul_def], exact (h.comp continuous_fst).mul continuous_snd }
exact h.comp (continuous_id.prod_mk continuous_const)
rw algebra_map_eq_smul_one'
rw ← nhds_within_Ico_eq_nhds_within_Ici (lt_add_one (n : α))
simpa only [floor_coe] using (continuous_on_floor n _ (left_mem_Ico.mpr $ lt_add_one (_ : α))).tendsto
rw [continuous_at, nhds_prod_eq, nhds_eq, nhds_eq, nhds_eq, filter.prod_map_map_eq, tendsto_map'_iff]
suffices : tendsto ((λx:G, (a + b) + x) ∘ (λp:G×G,p.1 + p.2)) (Z G ×ᶠ Z G) (map (λx:G, (a + b) + x) (Z G))
{ simpa [(∘), add_comm, add_left_comm] }
simpa [(∘), add_comm, add_left_comm]
exact tendsto_map.comp add_Z
simpa [f]
use [s * t₂, ht₂.mul_left, λ x hx, ⟨x, 1, hx, one_mem_t₂, mul_one _⟩]
rw [nhds_within, inf_principal_eq_bot, mem_nhds_iff]
refine ⟨t₁, _, ht₁, a_mem_t₁⟩
rintros x hx ⟨y, z, hy, hz, yz⟩
have : x * z⁻¹ ∈ sᶜ := (prod_subset_iff.1 t_subset) x hx z hz
rw ← yz
simpa
have : x * z⁻¹ ∈ s
contradiction
by_cases hP : P; simp [hP]
simp [hP]
simp [hP]
by_cases hP : P
simp [ha]
rw [tsum_eq_zero_of_not_summable hf, tsum_eq_zero_of_not_summable (mt (summable_mul_right_iff ha).2 hf), zero_mul]
by_cases hg : summable g
{ exact hg.has_sum.nonneg h }
exact hg.has_sum.nonneg h
simp [tsum_eq_zero_of_not_summable hg]
by_cases hf : summable f
{ exact hf.has_sum.nonpos h }
exact hf.has_sum.nonpos h
simp [tsum_eq_zero_of_not_summable hf]
refl
ext x
simp
simp
rw [← smul_eq_mul, ← map_smul, smul_eq_mul, mul_one, symm_apply_apply]
rw [← smul_eq_mul, ← map_smul, smul_eq_mul, mul_one, apply_symm_apply]
simp
simp
rw set_like.ext'_iff at hs ⊢
simp only [submodule.topological_closure_coe, submodule.top_coe, ← dense_iff_closure_eq] at hs ⊢
exact hf'.dense_image f.continuous hs
refine { zero := 0, add := (+), neg := has_neg.neg, sub := has_sub.sub, sub_eq_add_neg := _, nsmul := λ n f, { to_fun := λ x, n • (f x), map_add' := by simp, map_smul' := by simp [smul_comm n] }, gsmul := λ n f, { to_fun := λ x, n • (f x), map_add' := by simp, map_smul' := by simp [smul_comm n] }, gsmul_zero' := λ f, by { ext, simp }, gsmul_succ' := λ n f, by { ext, simp [add_smul, add_comm] }, gsmul_neg' := λ n f, by { ext, simp [nat.succ_eq_add_one, add_smul], }, .. continuous_linear_map.add_comm_monoid, .. }
simp
simp [smul_comm n]
simp
simp [smul_comm n]
ext
simp
ext
simp [add_smul, add_comm]
ext
simp [nat.succ_eq_add_one, add_smul]
refine { zero := 0, add := (+), neg := has_neg.neg, sub := has_sub.sub, sub_eq_add_neg := _, nsmul := λ n f, { to_fun := λ x, n • (f x), map_add' := by simp, map_smul' := by simp [smul_comm n] }, gsmul := λ n f, { to_fun := λ x, n • (f x), map_add' := by simp, map_smul' := by simp [smul_comm n] }, gsmul_zero' := λ f, by { ext, simp }, gsmul_succ' := λ n f, by { ext, simp [add_smul, add_comm] }, gsmul_neg' := λ n f, by { ext, simp [nat.succ_eq_add_one, add_smul], }, .. continuous_linear_map.add_comm_monoid, .. }; intros; ext; apply_rules [zero_add, add_assoc, add_zero, add_left_neg, add_comm, sub_eq_add_neg]
refine { zero := 0, add := (+), neg := has_neg.neg, sub := has_sub.sub, sub_eq_add_neg := _, nsmul := λ n f, { to_fun := λ x, n • (f x), map_add' := by simp, map_smul' := by simp [smul_comm n] }, gsmul := λ n f, { to_fun := λ x, n • (f x), map_add' := by simp, map_smul' := by simp [smul_comm n] }, gsmul_zero' := λ f, by { ext, simp }, gsmul_succ' := λ n f, by { ext, simp [add_smul, add_comm] }, gsmul_neg' := λ n f, by { ext, simp [nat.succ_eq_add_one, add_smul], }, .. continuous_linear_map.add_comm_monoid, .. }; intros; ext
refine { zero := 0, add := (+), neg := has_neg.neg, sub := has_sub.sub, sub_eq_add_neg := _, nsmul := λ n f, { to_fun := λ x, n • (f x), map_add' := by simp, map_smul' := by simp [smul_comm n] }, gsmul := λ n f, { to_fun := λ x, n • (f x), map_add' := by simp, map_smul' := by simp [smul_comm n] }, gsmul_zero' := λ f, by { ext, simp }, gsmul_succ' := λ n f, by { ext, simp [add_smul, add_comm] }, gsmul_neg' := λ n f, by { ext, simp [nat.succ_eq_add_one, add_smul], }, .. continuous_linear_map.add_comm_monoid, .. }; intros
apply_rules [zero_add, add_assoc, add_zero, add_left_neg, add_comm, sub_eq_add_neg]
apply_rules [zero_add, add_assoc, add_zero, add_left_neg, add_comm, sub_eq_add_neg]
intros
intros
ext
ext
apply_instance
refine continuous_iff_continuous_at.2 (λ x, _)
rcases hf x with ⟨U, hxU, hUf⟩
have : continuous_at (λ x, ∏ i in hUf.to_finset, f i x) x
from tendsto_finset_prod _ (λ i hi, (hc i).continuous_at)
refine this.congr (mem_of_superset hxU $ λ y hy, _)
refine (finprod_eq_prod_of_mul_support_subset _ (λ i hi, _)).symm
rw [hUf.coe_to_finset]
exact ⟨y, hi, hy⟩
rw [nhds_within_union, ht₁a, ht₂a, bot_sup_eq]
rw ((nhds_basis_Ioo_pos (1 : α)).prod $ nhds_basis_Ioo_pos (1 : α)).tendsto_iff (nhds_basis_Ioo_pos_of_pos (zero_lt_one : (0 : α) < 1))
intros ε hε
linarith
have hε' : 0 ≤ 1 - ε / 4 := by linarith
linarith
have ε_pos : 0 < ε / 4 := by linarith
linarith
have ε_pos' : 0 < ε / 2 := by linarith
simp only [and_imp, prod.forall, mem_Ioo, function.uncurry_apply_pair, mem_prod, prod.exists]
refine ⟨ε/4, ε/4, ⟨ε_pos, ε_pos⟩, λ a b ha ha' hb hb', _⟩
have ha0 : 0 ≤ a := le_trans hε' (le_of_lt ha)
have hb0 : 0 ≤ b := le_trans hε' (le_of_lt hb)
refine ⟨lt_of_le_of_lt _ (mul_lt_mul'' ha hb hε' hε'), lt_of_lt_of_le (mul_lt_mul'' ha' hb' ha0 hb0) _⟩
ring_nf
calc 1 - ε = 1 - ε / 2 - ε/2 : by ring_nf ... ≤ 1 - ε/2 - ε/2 + (ε/2)*(ε/2) : le_add_of_nonneg_right (le_of_lt (mul_pos ε_pos' ε_pos')) ... = (1 - ε/2) * (1 - ε/2) : by ring_nf ... ≤ (1 - ε/4) * (1 - ε/4) : mul_le_mul (by linarith) (by linarith) (by linarith) hε'
ring_nf
linarith
linarith
{ calc 1 - ε = 1 - ε / 2 - ε/2 : by ring_nf ... ≤ 1 - ε/2 - ε/2 + (ε/2)*(ε/2) : le_add_of_nonneg_right (le_of_lt (mul_pos ε_pos' ε_pos')) ... = (1 - ε/2) * (1 - ε/2) : by ring_nf ... ≤ (1 - ε/4) * (1 - ε/4) : mul_le_mul (by linarith) (by linarith) (by linarith) hε' }
calc (1 + ε/4) * (1 + ε/4) = 1 + ε/2 + (ε/4)*(ε/4) : by ring_nf ... = 1 + ε/2 + (ε * ε) / 16 : by ring_nf ... ≤ 1 + ε/2 + ε/2 : add_le_add_left (div_le_div (le_of_lt hε.1) (le_trans ((mul_le_mul_left hε.1).2 hε.2) (le_of_eq $ mul_one ε)) zero_lt_two (by linarith)) (1 + ε/2) ... ≤ 1 + ε : by ring_nf
ring_nf
ring_nf
linarith
ring_nf
refine (has_basis.tendsto_iff at_top_basis ⟨λ s, mem_nhds_within_Ioi_iff_exists_Ioc_subset⟩).2 _
refine λ b hb, ⟨b⁻¹, trivial, λ x hx, _⟩
have : 0 < x := lt_of_lt_of_le (inv_pos.2 hb) hx
exact ⟨inv_pos.2 this, (inv_le this hb).2 hx⟩
simp [frontier]
refine @map_coe_at_top_of_Ioo_subset (order_dual α) _ _ _ _ a s ha (λ b' hb', _)
rcases hs b' hb' with ⟨b, hab, hbs⟩
use [b, hab]
rwa dual_Ioo
cases le_total (f a) (f b); simp [*, is_preconnected_interval.intermediate_value]
simp [*, is_preconnected_interval.intermediate_value]
simp [*, is_preconnected_interval.intermediate_value]
cases le_total (f a) (f b)
simp only [continuous_within_at, nhds_within_Ioo_eq_nhds_within_Ioi h]
simpa only [dual_Ico] using @nhds_within_Ico_eq_nhds_within_Ici (order_dual α) _ _ _ _ _ h
convert is_closed_closure
simpa using hf.tendsto
let Nx := 𝓝 x₀
let ee := λ u : β × β, (e u.1, e u.2)
have lim1 : tendsto (λ a : β × β, (a.2 - a.1, y₁)) (comap e Nx ×ᶠ comap e Nx) (𝓝 (0, y₁))
have := tendsto.prod_mk (tendsto_sub_comap_self de x₀) (tendsto_const_nhds : tendsto (λ (p : β × β), y₁) (comap ee $ 𝓝 (x₀, x₀)) (𝓝 y₁))
rw [nhds_prod_eq, prod_comap_comap_eq, ←nhds_prod_eq]
{ have := tendsto.prod_mk (tendsto_sub_comap_self de x₀) (tendsto_const_nhds : tendsto (λ (p : β × β), y₁) (comap ee $ 𝓝 (x₀, x₀)) (𝓝 y₁)), rw [nhds_prod_eq, prod_comap_comap_eq, ←nhds_prod_eq], exact (this : _) }
exact (this : _)
have lim2 : tendsto Φ (𝓝 (0, y₁)) (𝓝 0)
simpa using hφ.tendsto (0, y₁)
have lim := lim2.comp lim1
rw tendsto_prod_self_iff at lim
exact lim W' W'_nhd
simp only [exists_prop, and_assoc]
simp only [← and_assoc]
apply inter_subset_left
exact image_closure_subset_closure_image h
rw ← set.image_subset_iff
rw ← subset_interior_iff_open; simp only [subset_def, mem_interior]
simp only [subset_def, mem_interior]
rw ← subset_interior_iff_open
split
intro hx
simp_rw [set.preimage_Union, set.mem_Union]
obtain ⟨_, ⟨s,rfl⟩, _, ⟨hs, rfl⟩, hh⟩ := hG hx
refine ⟨s, hs, _⟩
dsimp only [W] at hh ⊢
{ intro hx, simp_rw [set.preimage_Union, set.mem_Union], obtain ⟨_, ⟨s,rfl⟩, _, ⟨hs, rfl⟩, hh⟩ := hG hx, refine ⟨s, hs, _⟩, dsimp only [W] at hh ⊢, rwa [dif_pos hs, ← set.preimage_comp, ← Profinite.coe_comp, C.w] }
rwa [dif_pos hs, ← set.preimage_comp, ← Profinite.coe_comp, C.w]
intro hx
simp_rw [set.preimage_Union, set.mem_Union] at hx
obtain ⟨s,hs,hx⟩ := hx
rw h
refine ⟨s.1,s.2,_⟩
rw (hV s).2
dsimp only [W] at hx
rwa [dif_pos hs, ← set.preimage_comp, ← Profinite.coe_comp, C.w] at hx
have hB := Top.is_topological_basis_cofiltered_limit (F ⋙ Profinite.to_Top) (Profinite.to_Top.map_cone C) (is_limit_of_preserves _ hC) (λ j, {W | is_clopen W}) _ (λ i, is_clopen_univ) (λ i U1 U2 hU1 hU2, hU1.inter hU2) _
rotate
intros i
change topological_space.is_topological_basis {W : set (F.obj i) | is_clopen W}
{ intros i, change topological_space.is_topological_basis {W : set (F.obj i) | is_clopen W}, apply is_topological_basis_clopen }
apply is_topological_basis_clopen
rintros i j f V (hV : is_clopen _)
refine ⟨hV.1.preimage _, hV.2.preimage _⟩; continuity
refine ⟨hV.1.preimage _, hV.2.preimage _⟩
{ rintros i j f V (hV : is_clopen _), refine ⟨hV.1.preimage _, hV.2.preimage _⟩; continuity }
continuity
obtain ⟨S,hS,h⟩ := hB.open_eq_sUnion hU.1
clear hB
let j : S → J := λ s, (hS s.2).some
let V : Π (s : S), set (F.obj (j s)) := λ s, (hS s.2).some_spec.some
have hV : ∀ (s : S), is_clopen (V s) ∧ s.1 = C.π.app (j s) ⁻¹' (V s) := λ s, (hS s.2).some_spec.some_spec
have := hU.2.is_compact.elim_finite_subcover (λ s : S, C.π.app (j s) ⁻¹' (V s)) _ _
rotate
intros s
refine (hV s).1.1.preimage _
{ intros s, refine (hV s).1.1.preimage _, continuity }
continuity
dsimp only
rw h
rintro x ⟨T,hT,hx⟩
refine ⟨_,⟨⟨T,hT⟩,rfl⟩,_⟩
dsimp only
{ dsimp only, rw h, rintro x ⟨T,hT,hx⟩, refine ⟨_,⟨⟨T,hT⟩,rfl⟩,_⟩, dsimp only, rwa ← (hV ⟨T,hT⟩).2 }
rwa ← (hV ⟨T,hT⟩).2
obtain ⟨G,hG⟩ := this
obtain ⟨j0,hj0⟩ := is_cofiltered.inf_objs_exists (G.image j)
let f : Π (s : S) (hs : s ∈ G), j0 ⟶ j s := λ s hs, (hj0 (finset.mem_image.mpr ⟨s,hs,rfl⟩)).some
let W : S → set (F.obj j0) := λ s, if hs : s ∈ G then F.map (f s hs) ⁻¹' (V s) else set.univ
refine ⟨j0, ⋃ (s : S) (hs : s ∈ G), W s, _, _⟩
apply is_clopen_bUnion
intros s hs
dsimp only [W]
rw dif_pos hs
refine ⟨(hV s).1.1.preimage _, (hV s).1.2.preimage _⟩; continuity
refine ⟨(hV s).1.1.preimage _, (hV s).1.2.preimage _⟩
{ apply is_clopen_bUnion, intros s hs, dsimp only [W], rw dif_pos hs, refine ⟨(hV s).1.1.preimage _, (hV s).1.2.preimage _⟩; continuity }
continuity
ext x
exact connected_component_rel_iff
rw not_iff_not
continuity
simpa using ht
ext f
ext f; simp [s_eq.symm, pi]
simp [s_eq.symm, pi]
let S : A → set α := coe
let F : Π i : A, C(i, β) := λ i, F i i.prop
refine lift_cover S F (λ i j, hF i i.prop j j.prop) _
intros x
obtain ⟨s, hs, hsx⟩ := hA x
exact ⟨⟨s, hs⟩, hsx⟩
simp
ext x
ext x; exact eq_of_dist_eq_zero (le_antisymm (hfg ▸ dist_coe_le_dist _) dist_nonneg)
exact eq_of_dist_eq_zero (le_antisymm (hfg ▸ dist_coe_le_dist _) dist_nonneg)
simp [dist_eq, dist_comm]
ext
ext; simp [add_assoc]
simp [add_assoc]
ext
ext; simp
simp
ext
ext; simp
simp
ext
ext; simp
simp
ext
ext; simp [add_comm]
simp [add_comm]
ext
apply sub_eq_add_neg
rw dist_le (mul_nonneg dist_nonneg dist_nonneg)
intros x
refine (dist_smul_pair c (f₁ x) (f₂ x)).trans _
exact mul_le_mul_of_nonneg_left (dist_coe_le_dist x) dist_nonneg
rw dist_le (mul_nonneg dist_nonneg dist_nonneg)
intros x
refine (dist_pair_smul c₁ c₂ (f x)).trans _
convert mul_le_mul_of_nonneg_left (dist_coe_le_dist x) dist_nonneg
simp
ext
ext; simp
simp
ext
ext; simp
simp
refine ((comp_right_continuous_map ℝ (attach_bound (f : C(X, ℝ)))).continuous_at p).tendsto .frequently_map _ _ frequently_mem_polynomials
rintros _ ⟨g, ⟨-,rfl⟩⟩
simp only [set_like.mem_coe, alg_hom.coe_to_ring_hom, comp_right_continuous_map_apply, polynomial.to_continuous_map_on_alg_hom_apply]
apply polynomial_comp_attach_bound_mem
have mem_closure : p ∈ (polynomial_functions (set.Icc (-∥f∥) (∥f∥))).topological_closure := continuous_map_mem_polynomial_functions_closure _ _ p
have frequently_mem_polynomials := mem_closure_iff_frequently.mp mem_closure
apply mem_closure_iff_frequently.mpr
simp only [nhds_within, nhds_pi, comap_inf, comap_infi, pi_def, comap_principal, ← infi_principal_finite hI, ← infi_inf_eq]
rw [hf.to_embedding.map_nhds_within_eq, image_preimage_eq_inter_range]
apply nhds_within_eq_nhds_within (mem_range_self _) hf.open_range
rw [inter_assoc, inter_self]
tauto
ext ⟨⟩
refl
change ite _ _ _ = _
split_ifs
rw [extend, continuous_map.coe_Icc_extend, set.Icc_extend_of_mem]
{ rw [extend, continuous_map.coe_Icc_extend, set.Icc_extend_of_mem], refl }
refl
rw [extend, continuous_map.coe_Icc_extend, set.Icc_extend_of_mem]
refl
rw [nhds_bot', mem_infi_of_directed]
{ refl }
refl
simp [le_refl]
exact λ x y, ⟨min x y, by simp [le_refl], by simp [le_refl]⟩
simp [le_refl]
rw real.closed_ball_eq
apply is_compact_Icc
rw [real.image_interval h, interval_subset_interval_iff_mem, ← real.image_interval h]
exact ⟨mem_image_of_mem f hx, mem_image_of_mem f hy⟩
rw [e.map_nhds_within_eq hx, e.image_source_inter_eq', e.target_inter_inv_preimage_preimage, e.nhds_within_target_inter (e.map_source hx)]
dsimp only [trans_to_local_equiv, prod_to_local_equiv]; apply local_equiv.prod_trans
apply local_equiv.prod_trans
dsimp only [trans_to_local_equiv, prod_to_local_equiv]
rw [hgf.right, ← continuous_iff_coinduced_le]; apply continuous_coinduced_rng.comp hf
rw [hgf.right, ← continuous_iff_coinduced_le]
apply continuous_coinduced_rng.comp hf
rwa ← continuous_iff_coinduced_le
ext s
show is_open s ↔ is_open (f ⁻¹' s)
split
{ exact continuous_def.1 cont s }
exact continuous_def.1 cont s
assume h
rw ← surj.image_preimage s
exact open_map _ h
intros s hs
rcases hf.is_closed_iff.1 hs with ⟨t, ht, rfl⟩
rw image_preimage_eq_inter_range
exact is_closed.inter ht h
convert is_closed_univ
convert is_closed_univ; apply range_id
apply range_id
rw [metric.uniformity_eq_comap_nhds_zero, tendsto_comap_iff]
lift r to ℝ≥0 using hr
simp [nndist_pi_def]
simp [dist_pi_le_iff hr]
ext p
intros f hf
obtain ⟨t, t_fset, ht⟩ : ∃ t ∈ f, ∀ x y ∈ t, dist x y < 1 := (metric.cauchy_iff.1 hf).2 1 zero_lt_one
rcases hf.1.nonempty_of_mem t_fset with ⟨x, xt⟩
have : closed_ball x 1 ∈ f := mem_of_superset t_fset (λ y yt, (ht y x yt xt).le)
rcases (compact_iff_totally_bounded_complete.1 (proper_space.is_compact_closed_ball x 1)).2 f hf (le_principal_iff.2 this) with ⟨y, -, hy⟩
exact ⟨y, hy⟩
unfold diam
rw ennreal.to_real_le_to_real (bounded.subset h ht).ediam_ne_top ht.ediam_ne_top
exact emetric.diam_mono h
simpa [le_antisymm_iff, dist_nonneg] using @dist_eq_zero _ _ x y
assume x y x' y' hxx' hyy'
have Hxx' : dist x x' = 0 := hxx'
have Hyy' : dist y y' = 0 := hyy'
have A : dist x y ≤ dist x' y' := calc dist x y ≤ dist x x' + dist x' y : pseudo_metric_space.dist_triangle _ _ _ ... = dist x' y : by simp [Hxx'] ... ≤ dist x' y' + dist y' y : pseudo_metric_space.dist_triangle _ _ _ ... = dist x' y' : by simp [pseudo_metric_space.dist_comm, Hyy']
simp [Hxx']
simp [pseudo_metric_space.dist_comm, Hyy']
have B : dist x' y' ≤ dist x y := calc dist x' y' ≤ dist x' x + dist x y' : pseudo_metric_space.dist_triangle _ _ _ ... = dist x y' : by simp [pseudo_metric_space.dist_comm, Hxx'] ... ≤ dist x y + dist y y' : pseudo_metric_space.dist_triangle _ _ _ ... = dist x y : by simp [Hyy']
simp [pseudo_metric_space.dist_comm, Hxx']
simp [Hyy']
exact le_antisymm A B
simp [nndist, edist_dist, real.to_nnreal, max_eq_left dist_nonneg, ennreal.of_real]
simp [dist_comm, uniform_space.ball]
ext
simp [dist_comm]
simp [edist_dist]
rw ennreal.of_real_le_of_real_iff h
ext y
ext y; simp [edist_dist]; rw ennreal.of_real_le_of_real_iff h
ext y; simp [edist_dist]
rw edist_comm
rw edist_comm; refl
refl
cases x; cases y; simp only [sum.dist, dist_comm, add_comm, add_left_comm]
cases x; cases y
cases y
cases y
simp only [sum.dist, dist_comm, add_comm, add_left_comm]
simp only [sum.dist, dist_comm, add_comm, add_left_comm]
simp only [sum.dist, dist_comm, add_comm, add_left_comm]
simp only [sum.dist, dist_comm, add_comm, add_left_comm]
cases x
{ assume n, have X2n : X2 n = range ((coeZ ∘ (Φ n.succ) ∘ (c n) ∘ (to_glue_r (Y n).isom (isometry_optimal_GH_injl (X n) (X n.succ)))) ∘ (optimal_GH_injl (X n) (X n.succ))), { change X2 n = range (coeZ ∘ (Φ n.succ) ∘ (c n) ∘ (to_glue_r (Y n).isom (isometry_optimal_GH_injl (X n) (X n.succ))) ∘ (optimal_GH_injl (X n) (X n.succ))), simp only [X2, Φ], rw [← to_inductive_limit_commute I], simp only [f], rw ← to_glue_commute }, rw range_comp at X2n, have X2nsucc : X2 n.succ = range ((coeZ ∘ (Φ n.succ) ∘ (c n) ∘ (to_glue_r (Y n).isom (isometry_optimal_GH_injl (X n) (X n.succ)))) ∘ (optimal_GH_injr (X n) (X n.succ))), by refl, rw range_comp at X2nsucc, rw [X2n, X2nsucc, Hausdorff_dist_image, Hausdorff_dist_optimal, ← dist_GH_dist], { exact hu n n n.succ (le_refl n) (le_succ n) }, { apply isometry.comp completion.coe_isometry _, apply isometry.comp _ ((ic n).comp (to_glue_r_isometry _ _)), apply to_inductive_limit_isometry } }
apply to_inductive_limit_isometry
let X3 : ℕ → nonempty_compacts Z := λ n, ⟨X2 n, ⟨range_nonempty _, is_compact_range (isom n).continuous ⟩⟩
have : cauchy_seq X3
norm_num
refine cauchy_seq_of_le_geometric (1/2) 1 (by norm_num) (λ n, _)
rw one_mul
{ refine cauchy_seq_of_le_geometric (1/2) 1 (by norm_num) (λ n, _), rw one_mul, exact le_of_lt (D2 n) }
exact le_of_lt (D2 n)
rcases cauchy_seq_tendsto_of_complete this with ⟨L, hL⟩
have M : tendsto (λ n, (X3 n).to_GH_space) at_top (𝓝 L.to_GH_space) := tendsto.comp (to_GH_space_continuous.tendsto _) hL
have : ∀ n, (X3 n).to_GH_space = u n
assume n
rw [nonempty_compacts.to_GH_space, ← (u n).to_GH_space_rep, to_GH_space_eq_to_GH_space_iff_isometric]
constructor
{ assume n, rw [nonempty_compacts.to_GH_space, ← (u n).to_GH_space_rep, to_GH_space_eq_to_GH_space_iff_isometric], constructor, convert (isom n).isometric_on_range.symm, }
convert (isom n).isometric_on_range.symm
simpa [this] using M
exact ⟨L.to_GH_space, by simpa [this] using M⟩
refine second_countable_of_countable_discretization (λ δ δpos, _)
let ε := (2/5) * δ
norm_num
have εpos : 0 < ε := mul_pos (by norm_num) δpos
have : ∀ p:GH_space, ∃ s : set (p.rep), finite s ∧ (univ ⊆ (⋃x∈s, ball x ε)) := λ p, by simpa using finite_cover_balls_of_compact (@compact_univ p.rep _ _) εpos
simpa using finite_cover_balls_of_compact (@compact_univ p.rep _ _) εpos
choose s hs using this
have : ∀ p:GH_space, ∀ t:set (p.rep), finite t → ∃ n:ℕ, ∃ e:equiv t (fin n), true
assume p t ht
letI : fintype t := finite.fintype ht
{ assume p t ht, letI : fintype t := finite.fintype ht, exact ⟨fintype.card t, fintype.equiv_fin t, trivial⟩ }
exact ⟨fintype.card t, fintype.equiv_fin t, trivial⟩
choose N e hne using this
let N := λ p:GH_space, N p (s p) (hs p).1
let E := λ p:GH_space, e p (s p) (hs p).1
let F : GH_space → Σn:ℕ, (fin n → fin n → ℤ) := λ p, ⟨N p, λ a b, floor (ε⁻¹ * dist ((E p).symm a) ((E p).symm b))⟩
apply_instance
refine ⟨_, by apply_instance, F, λ p q hpq, _⟩
have Npq : N p = N q := (sigma.mk.inj_iff.1 hpq).1
let Ψ : s p → s q := λ x, (E q).symm (fin.cast Npq ((E p) x))
let Φ : s p → q.rep := λ x, Ψ x
have main : GH_dist p.rep q.rep ≤ ε + ε/2 + ε
refine GH_dist_le_of_approx_subsets Φ _ _ _
show ∀ x : p.rep, ∃ (y : p.rep) (H : y ∈ s p), dist x y ≤ ε
assume x
have : x ∈ ⋃y∈(s p), ball y ε := (hs p).2 (mem_univ _)
rcases mem_bUnion_iff.1 this with ⟨y, ys, hy⟩
{ assume x, have : x ∈ ⋃y∈(s p), ball y ε := (hs p).2 (mem_univ _), rcases mem_bUnion_iff.1 this with ⟨y, ys, hy⟩, exact ⟨y, ys, le_of_lt hy⟩ }
exact ⟨y, ys, le_of_lt hy⟩
show ∀ x : q.rep, ∃ (z : s p), dist x (Φ z) ≤ ε
assume x
have : x ∈ ⋃y∈(s q), ball y ε := (hs q).2 (mem_univ _)
rcases mem_bUnion_iff.1 this with ⟨y, ys, hy⟩
let i : ℕ := E q ⟨y, ys⟩
let hi := ((E q) ⟨y, ys⟩).is_lt
rw [fin.ext_iff, fin.coe_mk]
have ihi_eq : (⟨i, hi⟩ : fin (N q)) = (E q) ⟨y, ys⟩
have hiq : i < N q := hi
rwa Npq.symm at hiq
{ rwa Npq.symm at hiq }
have hip : i < N p
let z := (E p).symm ⟨i, hip⟩
use z
have C1 : (E p) z = ⟨i, hip⟩ := (E p).apply_symm_apply ⟨i, hip⟩
have C2 : fin.cast Npq ⟨i, hip⟩ = ⟨i, hi⟩ := rfl
have C3 : (E q).symm ⟨i, hi⟩ = ⟨y, ys⟩
rw ihi_eq
exact (E q).symm_apply_apply ⟨y, ys⟩
have : Φ z = y := by { simp only [Φ, Ψ], rw [C1, C2, C3], refl }
simp only [Φ, Ψ]
rw [C1, C2, C3]
refl
rw this
{ assume x, have : x ∈ ⋃y∈(s q), ball y ε := (hs q).2 (mem_univ _), rcases mem_bUnion_iff.1 this with ⟨y, ys, hy⟩, let i : ℕ := E q ⟨y, ys⟩, let hi := ((E q) ⟨y, ys⟩).is_lt, have ihi_eq : (⟨i, hi⟩ : fin (N q)) = (E q) ⟨y, ys⟩, by rw [fin.ext_iff, fin.coe_mk], have hiq : i < N q := hi, have hip : i < N p, { rwa Npq.symm at hiq }, let z := (E p).symm ⟨i, hip⟩, use z, have C1 : (E p) z = ⟨i, hip⟩ := (E p).apply_symm_apply ⟨i, hip⟩, have C2 : fin.cast Npq ⟨i, hip⟩ = ⟨i, hi⟩ := rfl, have C3 : (E q).symm ⟨i, hi⟩ = ⟨y, ys⟩, by { rw ihi_eq, exact (E q).symm_apply_apply ⟨y, ys⟩ }, have : Φ z = y := by { simp only [Φ, Ψ], rw [C1, C2, C3], refl }, rw this, exact le_of_lt hy }
exact le_of_lt hy
show ∀ x y : s p, abs (dist x y - dist (Φ x) (Φ y)) ≤ ε
assume x y
have : dist (Φ x) (Φ y) = dist (Ψ x) (Ψ y) := rfl
rw this
let i : ℕ := E p x
have hip : i < N p := ((E p) x).2
rwa Npq at hip
have hiq : i < N q
simp [Ψ]
have i' : i = ((E q) (Ψ x))
let j : ℕ := E p y
have hjp : j < N p := ((E p) y).2
rwa Npq at hjp
have hjq : j < N q
simp [Ψ]
have j' : j = ((E q) (Ψ y)).1
have : (F p).2 ((E p) x) ((E p) y) = floor (ε⁻¹ * dist x y)
simp only [F, (E p).symm_apply_apply]
have Ap : (F p).2 ⟨i, hip⟩ ⟨j, hjp⟩ = floor (ε⁻¹ * dist x y)
rw ← this
congr
congr; apply (fin.ext_iff _ _).2; refl
congr; apply (fin.ext_iff _ _).2
apply (fin.ext_iff _ _).2
apply (fin.ext_iff _ _).2
refl
refl
have : (F q).2 ((E q) (Ψ x)) ((E q) (Ψ y)) = floor (ε⁻¹ * dist (Ψ x) (Ψ y))
simp only [F, (E q).symm_apply_apply]
have Aq : (F q).2 ⟨i, hiq⟩ ⟨j, hjq⟩ = floor (ε⁻¹ * dist (Ψ x) (Ψ y))
rw ← this
congr
congr; apply (fin.ext_iff _ _).2; [exact i', exact j']
congr; apply (fin.ext_iff _ _).2
apply (fin.ext_iff _ _).2
apply (fin.ext_iff _ _).2
exact i'
exact j'
have : (F p).2 ⟨i, hip⟩ ⟨j, hjp⟩ = (F q).2 ⟨i, hiq⟩ ⟨j, hjq⟩
revert hiq hjq
change N q with (F q).1
generalize_hyp : F q = f at hpq ⊢
subst hpq
intros
{ revert hiq hjq, change N q with (F q).1, generalize_hyp : F q = f at hpq ⊢, subst hpq, intros, refl }
refl
rw [Ap, Aq] at this
have I := calc abs (ε⁻¹) * abs (dist x y - dist (Ψ x) (Ψ y)) = abs (ε⁻¹ * (dist x y - dist (Ψ x) (Ψ y))) : (abs_mul _ _).symm ... = abs ((ε⁻¹ * dist x y) - (ε⁻¹ * dist (Ψ x) (Ψ y))) : by { congr, ring } ... ≤ 1 : le_of_lt (abs_sub_lt_one_of_floor_eq_floor this)
congr
ring
calc abs (dist x y - dist (Ψ x) (Ψ y)) = (ε * ε⁻¹) * abs (dist x y - dist (Ψ x) (Ψ y)) : by rw [mul_inv_cancel (ne_of_gt εpos), one_mul] ... = ε * (abs (ε⁻¹) * abs (dist x y - dist (Ψ x) (Ψ y))) : by rw [abs_of_nonneg (le_of_lt (inv_pos.2 εpos)), mul_assoc] ... ≤ ε * 1 : mul_le_mul_of_nonneg_left I (le_of_lt εpos) ... = ε : mul_one _
rw [mul_inv_cancel (ne_of_gt εpos), one_mul]
rw [abs_of_nonneg (le_of_lt (inv_pos.2 εpos)), mul_assoc]
{ refine GH_dist_le_of_approx_subsets Φ _ _ _, show ∀ x : p.rep, ∃ (y : p.rep) (H : y ∈ s p), dist x y ≤ ε, { assume x, have : x ∈ ⋃y∈(s p), ball y ε := (hs p).2 (mem_univ _), rcases mem_bUnion_iff.1 this with ⟨y, ys, hy⟩, exact ⟨y, ys, le_of_lt hy⟩ }, show ∀ x : q.rep, ∃ (z : s p), dist x (Φ z) ≤ ε, { assume x, have : x ∈ ⋃y∈(s q), ball y ε := (hs q).2 (mem_univ _), rcases mem_bUnion_iff.1 this with ⟨y, ys, hy⟩, let i : ℕ := E q ⟨y, ys⟩, let hi := ((E q) ⟨y, ys⟩).is_lt, have ihi_eq : (⟨i, hi⟩ : fin (N q)) = (E q) ⟨y, ys⟩, by rw [fin.ext_iff, fin.coe_mk], have hiq : i < N q := hi, have hip : i < N p, { rwa Npq.symm at hiq }, let z := (E p).symm ⟨i, hip⟩, use z, have C1 : (E p) z = ⟨i, hip⟩ := (E p).apply_symm_apply ⟨i, hip⟩, have C2 : fin.cast Npq ⟨i, hip⟩ = ⟨i, hi⟩ := rfl, have C3 : (E q).symm ⟨i, hi⟩ = ⟨y, ys⟩, by { rw ihi_eq, exact (E q).symm_apply_apply ⟨y, ys⟩ }, have : Φ z = y := by { simp only [Φ, Ψ], rw [C1, C2, C3], refl }, rw this, exact le_of_lt hy }, show ∀ x y : s p, abs (dist x y - dist (Φ x) (Φ y)) ≤ ε, { assume x y, have : dist (Φ x) (Φ y) = dist (Ψ x) (Ψ y) := rfl, rw this, let i : ℕ := E p x, have hip : i < N p := ((E p) x).2, have hiq : i < N q, by rwa Npq at hip, have i' : i = ((E q) (Ψ x)), by { simp [Ψ] }, let j : ℕ := E p y, have hjp : j < N p := ((E p) y).2, have hjq : j < N q, by rwa Npq at hjp, have j' : j = ((E q) (Ψ y)).1, by { simp [Ψ] }, have : (F p).2 ((E p) x) ((E p) y) = floor (ε⁻¹ * dist x y), by simp only [F, (E p).symm_apply_apply], have Ap : (F p).2 ⟨i, hip⟩ ⟨j, hjp⟩ = floor (ε⁻¹ * dist x y), by { rw ← this, congr; apply (fin.ext_iff _ _).2; refl }, have : (F q).2 ((E q) (Ψ x)) ((E q) (Ψ y)) = floor (ε⁻¹ * dist (Ψ x) (Ψ y)), by simp only [F, (E q).symm_apply_apply], have Aq : (F q).2 ⟨i, hiq⟩ ⟨j, hjq⟩ = floor (ε⁻¹ * dist (Ψ x) (Ψ y)), by { rw ← this, congr; apply (fin.ext_iff _ _).2; [exact i', exact j'] }, have : (F p).2 ⟨i, hip⟩ ⟨j, hjp⟩ = (F q).2 ⟨i, hiq⟩ ⟨j, hjq⟩, { revert hiq hjq, change N q with (F q).1, generalize_hyp : F q = f at hpq ⊢, subst hpq, intros, refl }, rw [Ap, Aq] at this, have I := calc abs (ε⁻¹) * abs (dist x y - dist (Ψ x) (Ψ y)) = abs (ε⁻¹ * (dist x y - dist (Ψ x) (Ψ y))) : (abs_mul _ _).symm ... = abs ((ε⁻¹ * dist x y) - (ε⁻¹ * dist (Ψ x) (Ψ y))) : by { congr, ring } ... ≤ 1 : le_of_lt (abs_sub_lt_one_of_floor_eq_floor this), calc abs (dist x y - dist (Ψ x) (Ψ y)) = (ε * ε⁻¹) * abs (dist x y - dist (Ψ x) (Ψ y)) : by rw [mul_inv_cancel (ne_of_gt εpos), one_mul] ... = ε * (abs (ε⁻¹) * abs (dist x y - dist (Ψ x) (Ψ y))) : by rw [abs_of_nonneg (le_of_lt (inv_pos.2 εpos)), mul_assoc] ... ≤ ε * 1 : mul_le_mul_of_nonneg_left I (le_of_lt εpos) ... = ε : mul_one _ } }
calc dist p q = GH_dist (p.rep) (q.rep) : dist_GH_dist p q ... ≤ ε + ε/2 + ε : main ... = δ : by { simp [ε], ring }
simp [ε]
ring
have : ∀ (n : ℕ), 0 < ((1:ℝ) / 2) ^ n
apply pow_pos
norm_num
refine metric.complete_of_convergent_controlled_sequences (λ n, (1/2)^n) this (λ u hu, _)
let X := λ n, (u n).rep
let Y := aux_gluing X
letI : ∀ n, metric_space (Y n).space := λ n, (Y n).metric
have E : ∀ n : ℕ, glue_space (Y n).isom (isometry_optimal_GH_injl (X n) (X n.succ)) = (Y n.succ).space := λ n, by { simp [Y, aux_gluing], refl }
simp [Y, aux_gluing]
refl
let c := λ n, cast (E n)
have ic : ∀ n, isometry (c n) := λ n x y, rfl
let f : Πn, (Y n).space → (Y n.succ).space := λ n, (c n) ∘ (to_glue_l (aux_gluing X n).isom (isometry_optimal_GH_injl (X n) (X n.succ)))
have I : ∀ n, isometry (f n)
assume n
apply isometry.comp
refl
{ assume x y, refl }
assume x y
{ assume n, apply isometry.comp, { assume x y, refl }, { apply to_glue_l_isometry } }
apply to_glue_l_isometry
let Z0 := metric.inductive_limit I
let Z := uniform_space.completion Z0
let Φ := to_inductive_limit I
let coeZ := (coe : Z0 → Z)
let X2 := λ n, range (coeZ ∘ (Φ n) ∘ (Y n).embed)
have isom : ∀ n, isometry (coeZ ∘ (Φ n) ∘ (Y n).embed)
assume n
apply isometry.comp completion.coe_isometry _
apply isometry.comp _ (Y n).isom
{ assume n, apply isometry.comp completion.coe_isometry _, apply isometry.comp _ (Y n).isom, apply to_inductive_limit_isometry }
apply to_inductive_limit_isometry
have D2 : ∀ n, Hausdorff_dist (X2 n) (X2 n.succ) < (1/2)^n
assume n
have X2n : X2 n = range ((coeZ ∘ (Φ n.succ) ∘ (c n) ∘ (to_glue_r (Y n).isom (isometry_optimal_GH_injl (X n) (X n.succ)))) ∘ (optimal_GH_injl (X n) (X n.succ)))
change X2 n = range (coeZ ∘ (Φ n.succ) ∘ (c n) ∘ (to_glue_r (Y n).isom (isometry_optimal_GH_injl (X n) (X n.succ))) ∘ (optimal_GH_injl (X n) (X n.succ)))
simp only [X2, Φ]
rw [← to_inductive_limit_commute I]
simp only [f]
{ change X2 n = range (coeZ ∘ (Φ n.succ) ∘ (c n) ∘ (to_glue_r (Y n).isom (isometry_optimal_GH_injl (X n) (X n.succ))) ∘ (optimal_GH_injl (X n) (X n.succ))), simp only [X2, Φ], rw [← to_inductive_limit_commute I], simp only [f], rw ← to_glue_commute }
rw ← to_glue_commute
rw range_comp at X2n
have X2nsucc : X2 n.succ = range ((coeZ ∘ (Φ n.succ) ∘ (c n) ∘ (to_glue_r (Y n).isom (isometry_optimal_GH_injl (X n) (X n.succ)))) ∘ (optimal_GH_injr (X n) (X n.succ)))
refl
rw range_comp at X2nsucc
rw [X2n, X2nsucc, Hausdorff_dist_image, Hausdorff_dist_optimal, ← dist_GH_dist]
{ exact hu n n n.succ (le_refl n) (le_succ n) }
exact hu n n n.succ (le_refl n) (le_succ n)
apply isometry.comp completion.coe_isometry _
apply isometry.comp _ ((ic n).comp (to_glue_r_isometry _ _))
cases s.eq_empty_or_nonempty with hs hs
cases t.eq_empty_or_nonempty with ht ht
{ exact or.inl ⟨hs, ht⟩ }
exact or.inl ⟨hs, ht⟩
rw Hausdorff_edist_comm at fin
{ cases t.eq_empty_or_nonempty with ht ht, { exact or.inl ⟨hs, ht⟩ }, { rw Hausdorff_edist_comm at fin, exact or.inr ⟨nonempty_of_Hausdorff_edist_ne_top ht fin, ht⟩ } }
exact or.inr ⟨nonempty_of_Hausdorff_edist_ne_top ht fin, ht⟩
exact or.inr ⟨hs, nonempty_of_Hausdorff_edist_ne_top hs fin⟩
rw [dist_edist, dist_edist, hf]
simp [is_ωSup, is_lub, is_least, upper_bounds, lower_bounds]
split
intros hB U
refine ⟨{V : opens α | V ∈ B ∧ V ⊆ U}, λ U hU, hU.left, _⟩
apply ext
rw [Sup_s, hB.open_eq_sUnion' U.prop]
simp_rw [sUnion_image, sUnion_eq_bUnion, Union, supr_and, supr_image]
{ intros hB U, refine ⟨{V : opens α | V ∈ B ∧ V ⊆ U}, λ U hU, hU.left, _⟩, apply ext, rw [Sup_s, hB.open_eq_sUnion' U.prop], simp_rw [sUnion_image, sUnion_eq_bUnion, Union, supr_and, supr_image], refl }
refl
intro h
rw is_basis_iff_nbhd
intros U x hx
rcases h U with ⟨Us, hUs, rfl⟩
rcases mem_Sup.1 hx with ⟨U, Us, xU⟩
exact ⟨U, hUs Us, xU, le_Sup Us⟩
intro U
ext1
simp only [coe_comap, ← preimage_comp, f.symm_comp_self, preimage_id]
intro U
ext1
simp only [coe_comap, ← preimage_comp, f.self_comp_symm, preimage_id]
refine ⟨univ, univ_mem, (finite_singleton i).subset _⟩
rintro j ⟨x, hx, -⟩
contrapose! hx
rw [mem_singleton_iff] at hx
simp [hx]
simp
cases h
refine is_topological_basis_of_open_of_nhds (λ u hu, hu.1) _
rintros x U memU hU
obtain ⟨s, comp, xs, sU⟩ := exists_compact_subset hU memU
obtain ⟨t, h, ht, xt⟩ := mem_interior.1 xs
let u : set s := (coe : s → H)⁻¹' (interior s)
have u_open_in_s : is_open u := is_open_interior.preimage continuous_subtype_coe
let X : s := ⟨x, h xt⟩
have Xu : X ∈ u := xs
haveI : compact_space s := is_compact_iff_compact_space.1 comp
obtain ⟨V : set s, clopen_in_s, Vx, V_sub⟩ := compact_exists_clopen_in_open u_open_in_s Xu
have V_clopen : is_clopen ((coe : s → H) '' V)
refine ⟨_, (comp.is_closed.closed_embedding_subtype_coe.closed_iff_image_closed).1 clopen_in_s.2⟩
let v : set u := (coe : u → s)⁻¹' V
have : (coe : u → H) = (coe : s → H) ∘ (coe : u → s) := rfl
have f0 : embedding (coe : u → H) := embedding_subtype_coe.comp embedding_subtype_coe
have f1 : open_embedding (coe : u → H)
refine ⟨f0, _⟩
have : set.range (coe : u → H) = interior s
rw [this, set.range_comp, subtype.range_coe, subtype.image_preimage_coe]
apply set.inter_eq_self_of_subset_left interior_subset
{ rw [this, set.range_comp, subtype.range_coe, subtype.image_preimage_coe], apply set.inter_eq_self_of_subset_left interior_subset, }
rw this
{ refine ⟨f0, _⟩, { have : set.range (coe : u → H) = interior s, { rw [this, set.range_comp, subtype.range_coe, subtype.image_preimage_coe], apply set.inter_eq_self_of_subset_left interior_subset, }, rw this, apply is_open_interior } }
apply is_open_interior
have f2 : is_open v := clopen_in_s.1.preimage continuous_subtype_coe
have f3 : (coe : s → H) '' V = (coe : u → H) '' v
rw [this, image_comp coe coe, subtype.image_preimage_coe, inter_eq_self_of_subset_left V_sub]
{ rw [this, image_comp coe coe, subtype.image_preimage_coe, inter_eq_self_of_subset_left V_sub] }
rw f3
{ refine ⟨_, (comp.is_closed.closed_embedding_subtype_coe.closed_iff_image_closed).1 clopen_in_s.2⟩, let v : set u := (coe : u → s)⁻¹' V, have : (coe : u → H) = (coe : s → H) ∘ (coe : u → s) := rfl, have f0 : embedding (coe : u → H) := embedding_subtype_coe.comp embedding_subtype_coe, have f1 : open_embedding (coe : u → H), { refine ⟨f0, _⟩, { have : set.range (coe : u → H) = interior s, { rw [this, set.range_comp, subtype.range_coe, subtype.image_preimage_coe], apply set.inter_eq_self_of_subset_left interior_subset, }, rw this, apply is_open_interior } }, have f2 : is_open v := clopen_in_s.1.preimage continuous_subtype_coe, have f3 : (coe : s → H) '' V = (coe : u → H) '' v, { rw [this, image_comp coe coe, subtype.image_preimage_coe, inter_eq_self_of_subset_left V_sub] }, rw f3, apply f1.is_open_map v f2 }
apply f1.is_open_map v f2
simp [Vx, h xt]
refine ⟨coe '' V, V_clopen, by simp [Vx, h xt], _⟩
transitivity s
{ simp }
simp
assumption
obtain ⟨V, Vsub, Vne, Vcls, hV⟩ := hS.exists_minimal_nonempty_closed_subset hne
by_cases hnt : ∃ (x y : α) (hx : x ∈ V) (hy : y ∈ V), x ≠ y
exfalso
obtain ⟨x, y, hx, hy, hne⟩ := hnt
obtain ⟨U, hU, hsep⟩ := t0_space.t0 _ _ hne
have : ∀ (z w : α) (hz : z ∈ V) (hw : w ∈ V) (hz' : z ∈ U) (hw' : ¬ w ∈ U), false
intros z w hz hw hz' hw'
have uvne : (V ∩ Uᶜ).nonempty
simp only [hw, hw', set.mem_inter_eq, not_false_iff, and_self, set.mem_compl_eq]
{ use w, simp only [hw, hw', set.mem_inter_eq, not_false_iff, and_self, set.mem_compl_eq], }
use w
specialize hV (V ∩ Uᶜ) (set.inter_subset_left _ _) uvne (is_closed.inter Vcls (is_closed_compl_iff.mpr hU))
have : V ⊆ Uᶜ
exact set.inter_subset_right _ _
{ rw ←hV, exact set.inter_subset_right _ _ }
rw ←hV
{ intros z w hz hw hz' hw', have uvne : (V ∩ Uᶜ).nonempty, { use w, simp only [hw, hw', set.mem_inter_eq, not_false_iff, and_self, set.mem_compl_eq], }, specialize hV (V ∩ Uᶜ) (set.inter_subset_left _ _) uvne (is_closed.inter Vcls (is_closed_compl_iff.mpr hU)), have : V ⊆ Uᶜ, { rw ←hV, exact set.inter_subset_right _ _ }, exact this hz hz', }
exact this hz hz'
cases hsep
{ exact this x y hx hy hsep.1 hsep.2 }
exact this x y hx hy hsep.1 hsep.2
{ exfalso, obtain ⟨x, y, hx, hy, hne⟩ := hnt, obtain ⟨U, hU, hsep⟩ := t0_space.t0 _ _ hne, have : ∀ (z w : α) (hz : z ∈ V) (hw : w ∈ V) (hz' : z ∈ U) (hw' : ¬ w ∈ U), false, { intros z w hz hw hz' hw', have uvne : (V ∩ Uᶜ).nonempty, { use w, simp only [hw, hw', set.mem_inter_eq, not_false_iff, and_self, set.mem_compl_eq], }, specialize hV (V ∩ Uᶜ) (set.inter_subset_left _ _) uvne (is_closed.inter Vcls (is_closed_compl_iff.mpr hU)), have : V ⊆ Uᶜ, { rw ←hV, exact set.inter_subset_right _ _ }, exact this hz hz', }, cases hsep, { exact this x y hx hy hsep.1 hsep.2 }, { exact this y x hy hx hsep.1 hsep.2 } }
exact this y x hy hx hsep.1 hsep.2
push_neg at hnt
obtain ⟨z, hz⟩ := Vne
refine ⟨z, Vsub hz, _⟩
convert Vcls
ext
simp only [set.mem_singleton_iff, set.mem_compl_eq]
split
exact hz
{ rintro rfl, exact hz, }
rintro rfl
exact λ hx, hnt x z hx hz
refine induction_on_union _ (λ a b hi d, (hi d.symm).symm) (λ a d, empty_right a) (λ a b ab, _) _
obtain ⟨U, V, oU, oV, aU, bV, UV⟩ := t2_separation (by { rw [ne.def, ← finset.mem_singleton], exact (disjoint_singleton.mp ab.symm) })
rw [ne.def, ← finset.mem_singleton]
exact (disjoint_singleton.mp ab.symm)
refine ⟨U, V, oU, oV, _, _, set.disjoint_iff_inter_eq_empty.mpr UV⟩
refine ⟨U, V, oU, oV, _, _, set.disjoint_iff_inter_eq_empty.mpr UV⟩; exact singleton_subset_set_iff.mpr ‹_›
{ obtain ⟨U, V, oU, oV, aU, bV, UV⟩ := t2_separation (by { rw [ne.def, ← finset.mem_singleton], exact (disjoint_singleton.mp ab.symm) }), refine ⟨U, V, oU, oV, _, _, set.disjoint_iff_inter_eq_empty.mpr UV⟩; exact singleton_subset_set_iff.mpr ‹_› }
exact singleton_subset_set_iff.mpr ‹_›
exact singleton_subset_set_iff.mpr ‹_›
intros a b c ac bc d
apply_mod_cast union_left (ac (disjoint_of_subset_left (a.subset_union_left b) d)) (bc _)
exact disjoint_of_subset_left (a.subset_union_right b) d
rwa [inter_comm, ←subset_compl_iff_disjoint, singleton_subset_iff]
simpa using xv
rwa closure_eq_compl_interior_compl
apply_instance
dsimp [presheaf]
classical
haveI : nonempty (partial_refinement u s) := ⟨⟨u, ∅, uo, us, λ _, false.elim, λ _ _, rfl⟩⟩
have : ∀ c : set (partial_refinement u s), chain (≤) c → c.nonempty → ∃ ub, ∀ v ∈ c, v ≤ ub
from λ c hc ne, ⟨partial_refinement.chain_Sup c hc ne uf us, λ v hv, partial_refinement.le_chain_Sup _ _ _ _ hv⟩
rcases zorn_nonempty_partial_order this with ⟨v, hv⟩
suffices : ∀ i, i ∈ v.carrier
from ⟨v, v.subset_Union, λ i, v.is_open _, λ i, v.closure_subset (this i)⟩
contrapose! hv
rcases hv with ⟨i, hi⟩
rcases v.exists_gt hs i hi with ⟨v', hlt⟩
exact ⟨v', hlt.le, hlt.ne'⟩
rw topological_space.nhds_generate_from
simp only [comap_infi, comap_principal]
intros s hs
rw ←le_principal_iff
refine infi_le_of_le {u | s ∈ u} _
refine infi_le_of_le ⟨hs, ⟨s, rfl⟩⟩ _
exact principal_mono.2 (λ a, id)
apply eq_bot_of_singletons_open
intros x
use [{u : ultrafilter α | {x} ∈ u}, ultrafilter_is_open_basic _]
simp
apply hι.elim
intro i₀
let Z' := λ i, Z i ∩ Z i₀
suffices : (⋂ i, Z' i).nonempty
exact nonempty.mono (Inter_subset_Inter $ assume i, inter_subset_left (Z i) (Z i₀)) this
{ exact nonempty.mono (Inter_subset_Inter $ assume i, inter_subset_left (Z i) (Z i₀)) this }
rw ← ne_empty_iff_nonempty
intro H
obtain ⟨t, ht⟩ : ∃ (t : finset ι), ((Z i₀) ∩ ⋂ (i ∈ t), Z' i) = ∅
from (hZc i₀).elim_finite_subfamily_closed Z' (assume i, is_closed.inter (hZcl i) (hZcl i₀)) (by rw [H, inter_empty])
rw [H, inter_empty]
obtain ⟨i₁, hi₁⟩ : ∃ i₁ : ι, Z i₁ ⊆ Z i₀ ∧ ∀ i ∈ t, Z i₁ ⊆ Z' i
rcases directed.finset_le hZd t with ⟨i, hi⟩
rcases hZd i i₀ with ⟨i₁, hi₁, hi₁₀⟩
use [i₁, hi₁₀]
intros j hj
{ rcases directed.finset_le hZd t with ⟨i, hi⟩, rcases hZd i i₀ with ⟨i₁, hi₁, hi₁₀⟩, use [i₁, hi₁₀], intros j hj, exact subset_inter (subset.trans hi₁ (hi j hj)) hi₁₀ }
exact subset_inter (subset.trans hi₁ (hi j hj)) hi₁₀
suffices : ((Z i₀) ∩ ⋂ (i ∈ t), Z' i).nonempty
contradiction
{ rw ← ne_empty_iff_nonempty at this, contradiction }
rw ← ne_empty_iff_nonempty at this
refine nonempty.mono _ (hZn i₁)
exact subset_inter hi₁.left (subset_bInter hi₁.right)
rw union_eq_Union; exact compact_Union (λ b, by cases b; assumption)
exact compact_Union (λ b, by cases b; assumption)
rw union_eq_Union
cases b
cases b; assumption
assumption
assumption
rw is_compact_iff_ultrafilter_le_nhds at hs ht ⊢
intros f hfs
rw le_principal_iff at hfs
obtain ⟨a : α, sa : a ∈ s, ha : map prod.fst ↑f ≤ 𝓝 a⟩ := hs (f.map prod.fst) (le_principal_iff.2 $ mem_map.2 $ mem_of_superset hfs (λ x, and.left))
obtain ⟨b : β, tb : b ∈ t, hb : map prod.snd ↑f ≤ 𝓝 b⟩ := ht (f.map prod.snd) (le_principal_iff.2 $ mem_map.2 $ mem_of_superset hfs (λ x, and.right))
rw map_le_iff_le_comap at ha hb
refine ⟨⟨a, b⟩, ⟨sa, tb⟩, _⟩
exact le_inf ha hb
rw nhds_prod_eq
rw [continuous_within_at, tendsto_nhds_right]
unfold symmetric_rel at *
rw [preimage_inter, hU, hV]
congr
exact h
rw [prod_def]
show (𝓝 a).lift (λs:set α, (𝓝 b).lift (λt:set α, 𝓟 (set.prod s t))) = _
rw [lift_nhds_right]
funext s
apply congr_arg
rw [lift_nhds_left]
refl
exact monotone_principal.comp (monotone_prod monotone_const monotone_id)
exact (monotone_lift' monotone_const $ monotone_lam $ assume x, monotone_prod monotone_id monotone_const)
finish [prod.forall]
refine H.cauchy_seq_iff.trans ⟨λ h i hi, _, λ h i hi, _⟩
exact (h i hi).imp (λ N hN n hn, hN n N hn (le_refl N))
{ exact (h i hi).imp (λ N hN n hn, hN n N hn (le_refl N)) }
rcases comp_symm_of_uniformity (H.mem_of_mem hi) with ⟨t, ht, ht', hts⟩
rcases H.mem_iff.1 ht with ⟨j, hj, hjt⟩
refine (h j hj).imp (λ N hN m n hm hn, hts ⟨u N, hjt _, ht' $ hjt _⟩)
{ exact hN m hm }
exact hN m hm
exact hN n hn
set 𝓝Δ := ⨆ x : γ, 𝓝 (x, x)
set F := 𝓝Δ.lift' (λ (s : set (γ × γ)), s ○ s)
rw le_iff_forall_inf_principal_compl
intros V V_in
by_contra H
haveI : ne_bot (F ⊓ 𝓟 Vᶜ) := ⟨H⟩
obtain ⟨⟨x, y⟩, hxy⟩ : ∃ (p : γ × γ), cluster_pt p (F ⊓ 𝓟 Vᶜ) := cluster_point_of_compact _
have clV : cluster_pt (x, y) (𝓟 $ Vᶜ) := hxy.of_inf_right
have : (x, y) ∉ interior V
rwa mem_closure_iff_cluster_pt
have : (x, y) ∈ closure (Vᶜ)
{ have : (x, y) ∈ closure (Vᶜ), by rwa mem_closure_iff_cluster_pt, rwa closure_compl at this }
rwa closure_compl at this
have diag_subset : diagonal γ ⊆ interior V
rw subset_interior_iff_nhds
rintros ⟨x, x⟩ ⟨⟩
{ rw subset_interior_iff_nhds, rintros ⟨x, x⟩ ⟨⟩, exact (mem_supr.mp V_in : _) x }
exact (mem_supr.mp V_in : _) x
have x_ne_y : x ≠ y
intro h
apply this
apply diag_subset
{ intro h, apply this, apply diag_subset, simp [h] }
simp [h]
haveI : normal_space γ := normal_of_compact_t2
obtain ⟨U₁, V₁, U₁_in, V₁_in, U₂, V₂, U₂_in₂, V₂_in, V₁_cl, V₂_cl, U₁_op, U₂_op, VU₁, VU₂, hU₁₂⟩ : ∃ (U₁ V₁ ∈ 𝓝 x) (U₂ V₂ ∈ 𝓝 y), is_closed V₁ ∧ is_closed V₂ ∧ is_open U₁ ∧ is_open U₂ ∧ V₁ ⊆ U₁ ∧ V₂ ⊆ U₂ ∧ U₁ ∩ U₂ = ∅ := disjoint_nested_nhds x_ne_y
let U₃ := (V₁ ∪ V₂)ᶜ
have U₃_op : is_open U₃ := is_open_compl_iff.mpr (is_closed.union V₁_cl V₂_cl)
let W := (U₁.prod U₁) ∪ (U₂.prod U₂) ∪ (U₃.prod U₃)
have W_in : W ∈ 𝓝Δ
rw mem_supr
intros x
apply is_open.mem_nhds (is_open.union (is_open.union _ _) _)
by_cases hx : x ∈ V₁ ∪ V₂
left
cases hx with hx hx
cases hx with hx hx ; [left, right] ; split ; tauto
cases hx with hx hx ; [left, right] ; split
cases hx with hx hx ; [left, right]
left
right
split
split
tauto
tauto
tauto
tauto
{ left, cases hx with hx hx ; [left, right] ; split ; tauto }
right
rw mem_prod
tauto
{ by_cases hx : x ∈ V₁ ∪ V₂, { left, cases hx with hx hx ; [left, right] ; split ; tauto }, { right, rw mem_prod, tauto }, }
simp only [is_open.prod, *]
simp only [is_open.prod, *]
simp only [is_open.prod, *]
{ rw mem_supr, intros x, apply is_open.mem_nhds (is_open.union (is_open.union _ _) _), { by_cases hx : x ∈ V₁ ∪ V₂, { left, cases hx with hx hx ; [left, right] ; split ; tauto }, { right, rw mem_prod, tauto }, }, all_goals { simp only [is_open.prod, *] } }
all_goals { simp only [is_open.prod, *] }
simpa only using mem_lift' W_in
have : W ○ W ∈ F
have hV₁₂ : V₁.prod V₂ ∈ 𝓝 (x, y) := prod_is_open.mem_nhds V₁_in V₂_in
have clF : cluster_pt (x, y) F := hxy.of_inf_left
obtain ⟨p, p_in⟩ : ∃ p, p ∈ (V₁.prod V₂) ∩ (W ○ W) := cluster_pt_iff.mp clF hV₁₂ this
have inter_empty : (V₁.prod V₂) ∩ (W ○ W) = ∅
rw eq_empty_iff_forall_not_mem
rintros ⟨u, v⟩ ⟨⟨u_in, v_in⟩, w, huw, hwv⟩
have uw_in : (u, w) ∈ U₁.prod U₁ := set.mem_prod.2 ((huw.resolve_right (λ h, (h.1 $ or.inl u_in))).resolve_right (λ h, have u ∈ U₁ ∩ U₂, from ⟨VU₁ u_in, h.1⟩, by rwa hU₁₂ at this))
rwa hU₁₂ at this
have wv_in : (w, v) ∈ U₂.prod U₂ := set.mem_prod.2 ((hwv.resolve_right (λ h, (h.2 $ or.inr v_in))).resolve_left (λ h, have v ∈ U₁ ∩ U₂, from ⟨h.2, VU₂ v_in⟩, by rwa hU₁₂ at this))
rwa hU₁₂ at this
have : w ∈ U₁ ∩ U₂ := ⟨uw_in.2, wv_in.1⟩
{ rw eq_empty_iff_forall_not_mem, rintros ⟨u, v⟩ ⟨⟨u_in, v_in⟩, w, huw, hwv⟩, have uw_in : (u, w) ∈ U₁.prod U₁ := set.mem_prod.2 ((huw.resolve_right (λ h, (h.1 $ or.inl u_in))).resolve_right (λ h, have u ∈ U₁ ∩ U₂, from ⟨VU₁ u_in, h.1⟩, by rwa hU₁₂ at this)), have wv_in : (w, v) ∈ U₂.prod U₂ := set.mem_prod.2 ((hwv.resolve_right (λ h, (h.2 $ or.inr v_in))).resolve_left (λ h, have v ∈ U₁ ∩ U₂, from ⟨h.2, VU₂ v_in⟩, by rwa hU₁₂ at this)), have : w ∈ U₁ ∩ U₂ := ⟨uw_in.2, wv_in.1⟩, rwa hU₁₂ at this }
rwa hU₁₂ at this
rwa inter_empty at p_in
suffices : ∀ x : γ, filter.comap (prod.mk x) (⨆ y, 𝓝 (y ,y)) = 𝓝 x
intros s
change is_open s ↔ _
{ intros s, change is_open s ↔ _, simp_rw [is_open_iff_mem_nhds, nhds_eq_comap_uniformity_aux, this] }
simp_rw [is_open_iff_mem_nhds, nhds_eq_comap_uniformity_aux, this]
intros x
simp_rw [comap_supr, nhds_prod_eq, comap_prod, show prod.fst ∘ prod.mk x = λ y : γ, x, by ext ; simp, show prod.snd ∘ (prod.mk x) = (id : γ → γ), by ext ; refl, comap_id]
ext
ext ; simp
simp
ext
ext ; refl
refl
rw [supr_split_single _ x, comap_const_of_mem (λ V, mem_of_mem_nhds)]
suffices : ∀ y ≠ x, comap (λ (y : γ), x) (𝓝 y) ⊓ 𝓝 y ≤ 𝓝 x
simpa
intros y hxy
simp [comap_const_of_not_mem (compl_singleton_mem_nhds hxy) (by simp)]
simp
rw uniform_continuous_on_iff_restrict
rw is_separated_iff_induced at hs'
rw is_compact_iff_compact_space at hs
rw continuous_on_iff_continuous_restrict at hf
resetI
exact compact_space.uniform_continuous_of_continuous hf
simp_rw [filter.principal_le_iff, mem_supr]
rintros V V_in ⟨x, _⟩ ⟨⟩
exact mem_of_mem_nhds (V_in x)
refine le_of_eq _
rw map_supr
congr' with x : 1
erw [nhds_prod_eq, ← prod_comm]
ext ⟨a⟩; calc map f ⟦a⟧ = ⟦f a⟧ : map_mk hf a ... = g ⟦a⟧ : congr_fun comm a
ext ⟨a⟩
calc map f ⟦a⟧ = ⟦f a⟧ : map_mk hf a ... = g ⟦a⟧ : congr_fun comm a
assume u hu
apply (h u hu).mono (λ n hn, _)
exact λ x hx, hn _ hx
apply_instance
set c : urysohns.CU X := ⟨s, tᶜ, hs, ht.is_open_compl, λ _, disjoint_left.1 hd⟩
exact ⟨⟨c.lim, c.continuous_lim⟩, c.lim_of_mem_C, λ x hx, c.lim_of_nmem_U _ (λ h, h hx), c.lim_mem_Icc⟩
