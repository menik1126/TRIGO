cases b; unfold read read'; simp [array.read_eq_read']
cases b; unfold read read'
unfold read read'
simp [array.read_eq_read']
cases b
rw [← stream.eta (iterate f a)]
refl
rw tail_iterate
rw [h, nth_even]
reflexivity
cases v
min_tac b a
cases b; simp
simp
simp
cases b
cases b; simp
simp
simp
cases b
cases b; simp
simp
simp
cases b
simp
delta is_whitespace
apply_instance
intro c
delta is_digit
apply_instance
intro c
intro h; unfold of_nat; rw [dif_pos h]
intro h; unfold of_nat
unfold of_nat
rw [dif_pos h]
intro h
simp
simp
have h := nat.lt_or_ge n k
cases h with h h
have h' : succ m * n < succ m * k
exact nat.mul_lt_mul_of_pos_left h (nat.succ_pos m)
rw [sub_nat_nat_of_lt h, sub_nat_nat_of_le (le_of_lt h')]
simp [succ_pred_eq_of_pos (nat.sub_pos_of_lt h), nat.mul_sub_left_distrib]
{ have h' : succ m * n < succ m * k, exact nat.mul_lt_mul_of_pos_left h (nat.succ_pos m), rw [sub_nat_nat_of_lt h, sub_nat_nat_of_le (le_of_lt h')], simp [succ_pred_eq_of_pos (nat.sub_pos_of_lt h), nat.mul_sub_left_distrib]}
have h' : n > k ∨ k = n
exact decidable.lt_or_eq_of_le h
cases h' with h' h'
have h₁ : succ m * n > succ m * k
exact nat.mul_lt_mul_of_pos_left h' (nat.succ_pos m)
simp [nat.mul_sub_left_distrib, nat.mul_comm]
rw [sub_nat_nat_of_le h, sub_nat_nat_of_lt h₁]
rw [nat.mul_comm k, nat.mul_comm n, ← succ_pred_eq_of_pos (nat.sub_pos_of_lt h₁), ← neg_of_nat_of_succ]
{ have h₁ : succ m * n > succ m * k, exact nat.mul_lt_mul_of_pos_left h' (nat.succ_pos m), rw [sub_nat_nat_of_le h, sub_nat_nat_of_lt h₁], simp [nat.mul_sub_left_distrib, nat.mul_comm], rw [nat.mul_comm k, nat.mul_comm n, ← succ_pred_eq_of_pos (nat.sub_pos_of_lt h₁), ← neg_of_nat_of_succ], reflexivity }
reflexivity
simp
reflexivity
subst h'
rwa [e1, e2]
have h := int.neg_lt_neg h
rwa int.neg_neg at h
have h := int.add_le_add_right h (-b)
rwa [int.add_comm b c, int.add_neg_cancel_right] at h
rw int.add_comm at h
exact int.le_add_of_sub_right_le h
have h := int.add_lt_add_right h b
rwa [int.sub_add_cancel, int.add_comm] at h
rwa int.zero_mul at h
simp [min_le_left]
induction n; simp [*]; refl
induction n; simp [*]
simp [*]
simp [*]
induction n
rw n0
rw n0; exact z
exact z
rw div2_val
change div2 n < n
apply (div_lt_iff_lt_mul _ _ (succ_pos 1)).2
have := nat.mul_lt_mul_of_pos_left (lt_succ_self 1) (lt_of_le_of_ne n.zero_le (ne.symm n0))
rwa nat.mul_one at this
rw [← show bit (bodd n) n' = n, from bit_decomp n]; exact f (bodd n) n' (binary_rec n')
exact f (bodd n) n' (binary_rec n')
rw [← show bit (bodd n) n' = n, from bit_decomp n]
unfold bitwise; apply bit_cases_on m; intros; rw [binary_rec_eq, binary_rec_zero]; exact bitwise_bit_aux h
unfold bitwise; apply bit_cases_on m; intros; rw [binary_rec_eq, binary_rec_zero]
unfold bitwise; apply bit_cases_on m; intros
unfold bitwise; apply bit_cases_on m
apply bit_cases_on m
intros
unfold bitwise
exact bitwise_bit_aux h
rw [binary_rec_eq, binary_rec_zero]
simp [gcd]
rw [add_succ, add_succ, add_assoc]
rw [add_succ, add_succ, add_assoc]; refl
refl
rw mod_def
have h : ¬ (0 < 0 ∧ 0 ≤ a)
simp [lt_irrefl]
simp [if_neg, h]
rw mod_def
have h : ¬(0 < b ∧ b ≤ 0)
cases hn with l r
exact absurd (lt_of_lt_of_le l r) (lt_irrefl 0)
intro hn
{intro hn, cases hn with l r, exact absurd (lt_of_lt_of_le l r) (lt_irrefl 0)}
simp [if_neg, h]
apply_instance
refl
ext
ext
simp [algebra.commutes]
ext
simp [algebra.smul_def'']
refl
ext
simp
ext
simp only [lmul_left_apply, linear_map.comp_apply, mul_assoc]
ext
rw ← span_eq M
conv_lhs {rw ← span_eq M}
change span _ _ * span _ _ = _
rw [span_mul_span]
apply le_antisymm
rw span_le
rintros _ ⟨b, m, hb, hm, rfl⟩
rw [set_like.mem_coe, mem_map, set.mem_singleton_iff.mp hb]
{ rw span_le, rintros _ ⟨b, m, hb, hm, rfl⟩, rw [set_like.mem_coe, mem_map, set.mem_singleton_iff.mp hb], exact ⟨m, hm, rfl⟩ }
exact ⟨m, hm, rfl⟩
exact subset_span ⟨a, m, set.mem_singleton a, hm, rfl⟩
rintros _ ⟨m, hm, rfl⟩
rw [← mul_one I] {occs := occurrences.pos [1]}
apply mul_le_mul_right (one_le_one_div.mpr hI)
ext x
simp only [mem_map, mem_div_iff_forall_mul_mem]
split
rintro ⟨x, hx, rfl⟩ _ ⟨y, hy, rfl⟩
{ rintro ⟨x, hx, rfl⟩ _ ⟨y, hy, rfl⟩, exact ⟨x * y, hx _ hy, h.map_mul x y⟩ }
exact ⟨x * y, hx _ hy, h.map_mul x y⟩
rintro hx
refine ⟨h.symm x, λ z hz, _, h.apply_symm_apply x⟩
obtain ⟨xz, xz_mem, hxz⟩ := hx (h z) ⟨z, hz, rfl⟩
convert xz_mem
apply h.injective
erw [h.map_mul, h.apply_symm_apply, hxz]
rw [algebra.smul_def, mul_smul]
refl
apply le_antisymm
rw submodule.mul_le
intros y hy z hz
{ rw submodule.mul_le, intros y hy z hz, exact mul_mem S hy hz }
exact mul_mem S hy hz
intros x hx1
rw ← mul_one x
exact submodule.mul_mem_mul hx1 (one_mem S)
simp [set.ext_iff, algebra.mem_bot]
rw [← mem_restrict_scalars R, H, mem_restrict_scalars]
rcases exists_nat_pow_near (one_le_inv_iff.2 ⟨xpos, hx⟩) (one_lt_inv_iff.2 ⟨ypos, hy⟩) with ⟨n, hn, h'n⟩
refine ⟨n, _, _⟩
rwa [inv_pow', inv_lt_inv xpos (pow_pos ypos _)] at h'n
{ rwa [inv_pow', inv_lt_inv xpos (pow_pos ypos _)] at h'n }
rwa [inv_pow', inv_le_inv (pow_pos ypos _) xpos] at hn
rwa [div_lt_iff y0, ← nsmul_eq_mul] at h
simpa only [exists_prop, multiset.mem_map, exists_exists_and_eq_and] using hp.exists_mem_multiset_dvd h
haveI := classical.dec
refine or_iff_not_imp_right.2 (λ H, _)
simp [h, irreducible_iff] at H ⊢
refine λ a b h, classical.by_contradiction $ λ o, _
simp [not_or_distrib] at o
exact H _ o.1 _ o.2 h.symm
rw [g.map_finprod]
{ simp only [g.map_finprod_Prop] }
simp only [g.map_finprod_Prop]
simpa only [finprod_eq_mul_indicator_apply, mul_support_mul_indicator]
simp
rw [← sum_insert ha, Ico.insert_succ_bot hab]
exactI { has_limit := λ F, has_limit_of_created F (forget₂ CommSemiRing SemiRing.{u}) }
apply_instance
apply w
ext1
exactI { has_biproduct := λ f, by apply_instance }
apply_instance
ext
ext; refl
refl
simp
tidy
tidy
tidy
tidy
tidy
intros
apply quot.sound
apply relation.smul
intros
intros; apply quot.sound; apply relation.add
intros; apply quot.sound
apply quot.sound
apply relation.add
simp [basis.constr]
exactI { preserves_colimit := λ F, preserves_colimit_of_preserves_colimit_cocone (colimit_cocone_is_colimit F) (types.colimit_cocone_is_colimit (F ⋙ forget Mon)) }
apply_instance
rw [this a, this b]
rw one_mul
rw nat.cast_one
rw char_p.cast_eq_zero
rw zero_mul
induction n with n IH
simp [continuants_aux]
case nat.zero { simp [continuants_aux] }
case nat.succ { let g := gcf.of v, let conts := continuants_aux g (n + 2), set pred_conts := continuants_aux g (n + 1) with pred_conts_eq, set ppred_conts := continuants_aux g n with ppred_conts_eq, let pA := pred_conts.a, let pB := pred_conts.b, let ppA := ppred_conts.a, let ppB := ppred_conts.b, change pA * conts.b - pB * conts.a = (-1)^(n + 1), have not_terminated_at_n : ¬terminated_at g n, from or.resolve_left hyp n.succ_ne_zero, obtain ⟨gp, s_nth_eq⟩ : ∃ gp, g.s.nth n = some gp, from option.ne_none_iff_exists'.elim_left not_terminated_at_n, suffices : pA * (ppB + gp.b * pB) - pB * (ppA + gp.b * pA) = (-1)^(n + 1), by { simp only [conts, (continuants_aux_recurrence s_nth_eq ppred_conts_eq pred_conts_eq)], have gp_a_eq_one : gp.a = 1, from of_part_num_eq_one (part_num_eq_s_a s_nth_eq), rw [gp_a_eq_one, this.symm], ring }, suffices : pA * ppB - pB * ppA = (-1)^(n + 1), calc pA * (ppB + gp.b * pB) - pB * (ppA + gp.b * pA) = pA * ppB + pA * gp.b * pB - pB * ppA - pB * gp.b * pA : by ring ... = pA * ppB - pB * ppA : by ring ... = (-1)^(n + 1) : by assumption, suffices : ppA * pB - ppB * pA = (-1)^n, by { have pow_succ_n : (-1 : K)^(n + 1) = (-1) * (-1)^n, from pow_succ (-1) n, rw [pow_succ_n, ←this], ring }, exact (IH $ or.inr $ mt (terminated_stable $ n.sub_le 1) not_terminated_at_n) }
let g := gcf.of v
let conts := continuants_aux g (n + 2)
set pred_conts := continuants_aux g (n + 1) with pred_conts_eq
set ppred_conts := continuants_aux g n with ppred_conts_eq
let pA := pred_conts.a
let pB := pred_conts.b
let ppA := ppred_conts.a
let ppB := ppred_conts.b
change pA * conts.b - pB * conts.a = (-1)^(n + 1)
from or.resolve_left hyp n.succ_ne_zero
have not_terminated_at_n : ¬terminated_at g n
from option.ne_none_iff_exists'.elim_left not_terminated_at_n
obtain ⟨gp, s_nth_eq⟩ : ∃ gp, g.s.nth n = some gp
suffices : pA * (ppB + gp.b * pB) - pB * (ppA + gp.b * pA) = (-1)^(n + 1)
simp only [conts, (continuants_aux_recurrence s_nth_eq ppred_conts_eq pred_conts_eq)]
from of_part_num_eq_one (part_num_eq_s_a s_nth_eq)
have gp_a_eq_one : gp.a = 1
rw [gp_a_eq_one, this.symm]
ring
calc pA * (ppB + gp.b * pB) - pB * (ppA + gp.b * pA) = pA * ppB + pA * gp.b * pB - pB * ppA - pB * gp.b * pA : by ring ... = pA * ppB - pB * ppA : by ring ... = (-1)^(n + 1) : by assumption
suffices : pA * ppB - pB * ppA = (-1)^(n + 1)
ring
ring
assumption
suffices : ppA * pB - ppB * pA = (-1)^n
from pow_succ (-1) n
have pow_succ_n : (-1 : K)^(n + 1) = (-1) * (-1)^n
rw [pow_succ_n, ←this]
ring
exact (IH $ or.inr $ mt (terminated_stable $ n.sub_le 1) not_terminated_at_n)
refine λ h a b c bc, _
rcases le_iff_eq_or_lt.mp bc with rfl | bc
{ exact rfl.le }
exact rfl.le
exact (h _ bc).le
dsimp only [totalize]
dsimp only [totalize]; rw [dif_pos h, dif_pos h]
rw [dif_pos h, dif_pos h]
dsimp only [totalize]
dsimp only [totalize]; rw [dif_neg h, dif_neg h, linear_map.zero_apply]
rw [dif_neg h, dif_neg h, linear_map.zero_apply]
erw [← (ring.direct_limit.of _ _ _).map_mul, mul_inv_cancel (assume h : x = 0, H $ by rw [h, (ring.direct_limit.of _ _ _).map_zero]), (ring.direct_limit.of _ _ _).map_one]
rw [h, (ring.direct_limit.of _ _ _).map_zero]
exact h.mul_right _
rw mul_comm
split
exact hnd (dvd_zero _)
{ rintro rfl, exact hnd (dvd_zero _) }
rintro rfl
rcases hd with ⟨c, rfl⟩
refine ⟨c, _, rfl⟩
rintro ⟨u, rfl⟩
simpa using hnd
exact if_pos rfl
unfold xgcd_aux
rw [lcm, zero_mul, zero_div]
rw neg_inv
refine (lt_floor_add_one a).trans_le (add_le_add_right _ 1)
norm_cast
exact int.le_to_nat _
simpa only [int.succ, int.cast_add, int.cast_one] using lt_succ_floor x
transitivity gcd k m * normalize n
rw ← gcd_mul_right
{ rw ← gcd_mul_right, exact dvd_gcd (dvd_mul_right _ _) H }
exact dvd_gcd (dvd_mul_right _ _) H
apply dvd.intro ↑(norm_unit n)⁻¹
rw [normalize_apply, mul_assoc, mul_assoc, ← units.coe_mul]
simp
rw [this, normalize_zero]
rw [gcd_eq_zero_iff, lcm_eq_zero_iff]
rw [gcd_eq_zero_iff, lcm_eq_zero_iff]; rintros ⟨rfl, rfl⟩; left; refl
rw [gcd_eq_zero_iff, lcm_eq_zero_iff]; rintros ⟨rfl, rfl⟩; left
rw [gcd_eq_zero_iff, lcm_eq_zero_iff]; rintros ⟨rfl, rfl⟩
left
refl
rintros ⟨rfl, rfl⟩
rw [gcd_mul_lcm, normalize_idem]
simpa only [normalize.map_mul, normalize_gcd, one_mul, mul_right_inj' h1] using h2
rw [if_neg (mul_ne_zero ha hb), if_neg ha, if_neg hb, units.ext_iff, units.coe_mul]
suffices : (a * b) * ↑(classical.some (associated_map_mk hinv (a * b))) = (a * ↑(classical.some (associated_map_mk hinv a))) * (b * ↑(classical.some (associated_map_mk hinv b)))
apply mul_left_cancel' (mul_ne_zero ha hb) _
{ apply mul_left_cancel' (mul_ne_zero ha hb) _, simpa only [mul_assoc, mul_comm, mul_left_comm] using this }
simpa only [mul_assoc, mul_comm, mul_left_comm] using this
rw [map_mk_unit_aux hinv a, map_mk_unit_aux hinv (a * b), map_mk_unit_aux hinv b, ← monoid_hom.map_mul, associates.mk_mul_mk]
rw [if_neg (units.ne_zero u), units.ext_iff]
apply mul_left_cancel' (units.ne_zero u)
rw [units.mul_inv, map_mk_unit_aux hinv u, associates.mk_eq_mk_iff_associated.2 (associated_one_iff_is_unit.2 ⟨u, rfl⟩), associates.mk_one, monoid_hom.map_one]
classical
apply s.induction_on
{ simp }
simp
intros b t hbt h
rw [gcd_insert, gcd_insert, h, ← gcd_mul_right]
apply ((normalize_associated a).mul_left _).gcd_eq_right
simp
rw [h.eq, mul_inv_cancel_right]
unfreezingI { cases m₁ with mul₁ _ one₁ one_mul₁ mul_one₁ npow₁ npow_zero₁ npow_succ₁, cases m₂ with mul₂ _ one₂ one_mul₂ mul_one₂ npow₂ npow_zero₂ npow_succ₂ }
cases m₁ with mul₁ _ one₁ one_mul₁ mul_one₁ npow₁ npow_zero₁ npow_succ₁
cases m₂ with mul₂ _ one₂ one_mul₂ mul_one₂ npow₂ npow_zero₂ npow_succ₂
change mul₁ = mul₂ at h_mul
subst h_mul
have h_one : one₁ = one₂
rw ←one_mul₂ one₁
{ rw ←one_mul₂ one₁, exact mul_one₁ one₂ }
exact mul_one₁ one₂
subst h_one
have h_npow : npow₁ = npow₂
ext n
induction n with d hd
{ rw [npow_zero₁, npow_zero₂] }
rw [npow_zero₁, npow_zero₂]
{ ext n, induction n with d hd, { rw [npow_zero₁, npow_zero₂] }, { rw [npow_succ₁, npow_succ₂, hd] } }
rw [npow_succ₁, npow_succ₂, hd]
subst h_npow
simp only [function.comp_app, inv_apply, coe_comp]
ext
refine_struct { zero := (0 : Π i, f i), one := (1 : Π i, f i), mul := (*), npow := λ n x i, npow n (x i) }
refine_struct { zero := (0 : Π i, f i), one := (1 : Π i, f i), mul := (*), npow := λ n x i, npow n (x i) }; tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
simp
simp
simp
simp [units.map]
exact add_monoid_hom.congr_fun h a
ext a
rw [comp_apply, id_apply]
rwa [← add_eq_zero_iff_eq_neg, ← sub_eq_zero, or_comm, ← mul_eq_zero, ← sq_sub_sq a b, sub_eq_zero]
ring
by_cases n0 : 0 ≤ n
lift n to ℕ using n0
{ lift n to ℕ using n0, simp only [abs_nsmul, coe_nat_abs, gsmul_coe_nat] }
simp only [abs_nsmul, coe_nat_abs, gsmul_coe_nat]
lift (- n) to ℕ using int.le_of_lt (neg_pos.mpr (not_le.mp n0)) with m h
rw [← abs_neg (n • a), ← neg_gsmul, ← abs_neg n, ← h, gsmul_coe_nat, coe_nat_abs, gsmul_coe_nat]
exact abs_nsmul m _
rw [nsmul_eq_mul', nsmul_eq_mul', mul_assoc]
simp
obtain ⟨p, rfl⟩ := nat.exists_eq_succ_of_ne_zero h.ne'
refine ⟨λ h, _, is_unit.pow _⟩
obtain ⟨⟨k, k', hk, hk'⟩, h⟩ := h
rw [units.coe_mk] at h
refine ⟨⟨m, m ^ p * k', _, _⟩, _⟩
{ rw [←mul_assoc, ←pow_succ, ←h, hk] }
rw [←mul_assoc, ←pow_succ, ←h, hk]
{ rw [mul_right_comm, ←pow_succ', ←h, hk] }
rw [mul_right_comm, ←pow_succ', ←h, hk]
suffices : function.injective (nat_abs ∘ ((^) x : ℕ → ℤ))
{ exact function.injective.of_comp this }
exact function.injective.of_comp this
convert nat.pow_right_injective h
ext n
exact units.coe_mk _ _ _ _
rw [function.comp_app, nat_abs_pow]
rw [← mul, H, zero]
rwa zero
rwa zero
erw [← mul, ← mul, H]; refl
refl
erw [← mul, ← mul, H]
erw [← mul, ← mul, H]; refl
refl
erw [← mul, ← mul, H]
simpa only [mul_assoc, mul_inv_cancel h, mul_one] using congr_arg (λ y, y * x⁻¹) w
rintro rfl
rintro rfl
rw mul_inv_cancel_left' hb
split
rw inv_mul_cancel_left' hb
split; rintro rfl; [rw mul_inv_cancel_left' hb, rw inv_mul_cancel_left' hb]
split; rintro rfl
simp [hx]
{ simp [hx] }
by_cases hx : x = 0
simp [hy]
{ simp [hy] }
by_cases hy : y = 0
symmetry
apply eq_inv_of_mul_left_eq_one
simp [mul_assoc, hx, hy]
simp [h]
simp
rw [← divp_mk0 _ hc, ← divp_mk0 _ hc, divp_left_inj]
simp [div_eq_mul_inv]
intro h
intro h
split
split; intro h
rintro rfl
simpa using h
{ rw [pos_iff_ne_zero], rintro rfl, simpa using h }
rw [pos_iff_ne_zero]
exact zero_pow' n h.ne.symm
rw [gpow_coe_nat, gpow_coe_nat, inv_pow']
rw [gpow_neg_succ_of_nat, gpow_neg_succ_of_nat, inv_pow']
dsimp at w
rw dif_neg w
substs hij hjk
dsimp at hij hjk
simp only [category.comp_id, eq_to_hom_refl, dif_pos rfl]
exact congr_fun (X.d_squared) i
dsimp at h ⊢
subst h
simp only [category.comp_id, eq_to_hom_refl, dif_pos rfl]
exact (congr_fun f.comm i).symm
rw [←cancel_epi (image_to_kernel (0 : A ⟶ B) g exact.w), ←cancel_epi (factor_thru_image_subobject (0 : A ⟶ B))]
simp
by_cases h : n + 1 = m
subst h
{ subst h, simpa using comm n }
simpa using comm n
simp
rw [of_d_ne X _ _ h, of_d_ne Y _ _ h]
rw [if_pos rfl, category.comp_id]
change ite (2 = 1 + 1) (d₁ ≫ 𝟙 X₂) 0 = d₁
simp [subobject.factor_thru_right]
dunfold cycles_map
simp [homology.π, homology.desc]
ext
simp_rw [category.comp_id, homology.π_map_assoc, homology.π_map, ←category.assoc, ←kernel_subobject_map_comp]
convert category.id_comp _
convert kernel_subobject_map_id
simp
simp
ext
ext; simp
ext
simp_rw [category.comp_id, homology.π_map_assoc, homology.π_map, ←category.assoc, ←kernel_subobject_map_comp]
convert category.id_comp _
convert kernel_subobject_map_id
simp
simp
ext
ext; simp
apply zero_of_target_iso_zero
dsimp
rw [if_neg h]
simp
simp
simp
ext i
dsimp
split_ifs
simp
{ subst h, simp, }
subst h
symmetry
simp [ha]
simp [ha]
split_ifs
refl
{ refl }
rw [mul_zero]
simp only [indicator]
by_cases hx : x ∈ ⋃ i, s i
rw [mul_indicator_of_mem hx]
rw [mem_Union] at hx
refine le_antisymm _ (supr_le $ λ i, mul_indicator_le_self' (λ x hx, h1 ▸ bot_le) x)
rcases hx with ⟨i, hi⟩
exact le_supr_of_le i (ge_of_eq $ mul_indicator_of_mem hi _)
{ rw [mul_indicator_of_mem hx], rw [mem_Union] at hx, refine le_antisymm _ (supr_le $ λ i, mul_indicator_le_self' (λ x hx, h1 ▸ bot_le) x), rcases hx with ⟨i, hi⟩, exact le_supr_of_le i (ge_of_eq $ mul_indicator_of_mem hi _) }
rw [mul_indicator_of_not_mem hx]
simp only [mem_Union, not_exists] at hx
simp [hx, ← h1]
congr
exact left_inv_eq_right_inv hba hac
simp [←mul_assoc]
simp [←mul_assoc]
simp [←mul_div_assoc]
simp [←mul_div_assoc]
simp [mul_assoc]
simp
rintros t ⟨a⟩ ⟨c⟩
change quot.mk _ (a • (t • c)) = quot.mk _ (t • (a • c))
rw ← smul_comm
simp
ext
simp
ext
congr
skip
rw ← I.incl_ideal_range
conv_rhs { congr, skip, rw ← I.incl_ideal_range, }
rw comap_bracket_eq
exact I.incl_is_ideal_morphism
simp only [ker_incl, sup_bot_eq]
introsI h
introsI h
split
split; introsI h
{ exact e.symm.injective.lie_algebra_is_nilpotent, }
exact e.symm.injective.lie_algebra_is_nilpotent
exact e.injective.lie_algebra_is_nilpotent
simp [lie_ring.of_associative_ring_bracket]
ext a b
noncomm_ring
apply lie_equiv.of_subalgebras _ _ e.lie_conj
ext f
simp only [lie_subalgebra.mem_coe, submodule.mem_map_equiv, lie_subalgebra.mem_map_submodule, coe_coe]
exact (bilin_form.is_pair_self_adjoint_equiv (-B) B e f).symm
simp only [mem_skew_adjoint_matrices_submodule] at *
change Aᵀ ⬝ J = J ⬝ -A at hA
change ⁅A, B⁆ᵀ ⬝ J = J ⬝ -⁅A, B⁆
change Bᵀ ⬝ J = J ⬝ -B at hB
simp only [←matrix.mul_eq_mul] at *
rw [matrix.lie_transpose, lie_ring.of_associative_ring_bracket, lie_ring.of_associative_ring_bracket, sub_mul, mul_assoc, mul_assoc, hA, hB, ←mul_assoc, ←mul_assoc, hA, hB]
apply set_coe.ext
simpa
rwa [lie_hom.coe_to_linear_map]
ext
rw [← mem_coe_submodule, h]
refl
rw [← add_smul, add_left_neg, zero_smul]
rw [nsmul_eq_smul_cast R, smul_eq_zero]
simp
intros c x
rw [nsmul_eq_mul, mul_one]
exact linear_map.congr_fun h m
ext m
use b.constr ℕ (λ i, finsupp.single (b i) (1 : R))
intro m
simp only [b.constr_apply, mul_one, id.def, finsupp.smul_single', finsupp.total_single, linear_map.map_finsupp_sum]
exact b.total_repr m
cases c
simp [add_smul]
simp [zero_smul]
ext
simp [single_zero_mul_apply, algebra.smul_def'', pi.smul_apply]
ext
simp [single_zero_mul_apply, mul_single_zero_apply, algebra.commutes]
simp only [lift_apply', algebra.smul_def]
rw [← sum_single a, ← sum_single b]
conv_rhs { rw [← sum_single a, ← sum_single b] }
simp_rw [mul_def, (lift_nc _ g).map_finsupp_sum, lift_nc_single, finsupp.sum_mul, finsupp.mul_sum]
refine finset.sum_congr rfl (λ y hy, finset.sum_congr rfl (λ x hx, _))
simp [mul_assoc, (h_comm hy).left_comm]
refl
ext
simp
split
intro h
rw [← unop_op a, ← unop_op x, ← unop_op y]
{ intro h, rw [← unop_op a, ← unop_op x, ← unop_op y], exact semiconj_by.unop h }
exact semiconj_by.unop h
intro h
exact semiconj_by.op h
unfold cmp cmp_using
by_cases a < b; by_cases h₂ : b < a; simp [h, h₂, gt, ordering.swap]
by_cases a < b; by_cases h₂ : b < a
by_cases h₂ : b < a
by_cases h₂ : b < a
by_cases a < b
simp [h, h₂, gt, ordering.swap]
simp [h, h₂, gt, ordering.swap]
simp [h, h₂, gt, ordering.swap]
simp [h, h₂, gt, ordering.swap]
exact lt_asymm h h₂
rw cmp_eq_eq_iff
rw [mul_comm, inv_mul_lt_iff' h]
rw [← inv_le_inv_of_neg (inv_lt_zero.2 hb) ha, inv_inv']
rw [div_lt_iff_of_neg hb, one_mul]
simpa using inv_le ha hb
rw mul_inv_self
rw mul_inv_self
rw [mul_comm c, mul_inv_lt_inv_mul_iff, mul_comm]
rw [← mul_lt_mul_iff_right b, one_mul, div_eq_mul_inv, inv_mul_cancel_right]
haveI := @linear_order.decidable_le α _
rw [← abs_mul_abs_self x]
exact decidable.mul_self_le_mul_self (abs_nonneg x) (abs_le.2 ⟨neg_le.2 h₂, h₁⟩)
rw abs_mul_abs_self
simp only [mul_add, add_comm, add_left_comm, mul_comm, sub_eq_add_neg, mul_one, mul_neg_eq_neg_mul_symm, neg_add_rev, neg_neg]
classical; exact decidable.mul_nonneg_le_one_le
exact decidable.mul_nonneg_le_one_le
classical
haveI := @linear_order.decidable_le α _; exact ⟨lt_imp_lt_of_le_imp_le $ λ h', decidable.mul_le_mul_of_nonneg_left h' h.le, λ h', mul_lt_mul_of_pos_left h' h⟩
exact ⟨lt_imp_lt_of_le_imp_le $ λ h', decidable.mul_le_mul_of_nonneg_left h' h.le, λ h', mul_lt_mul_of_pos_left h' h⟩
haveI := @linear_order.decidable_le α _
refine le_antisymm (sub_le_iff_left.mpr _) (sub_le_iff_left.mpr $ sub_le_iff_left.mpr _)
refine le_trans le_add_sub (add_le_add_left le_add_sub _)
rw [add_assoc]
{ rw [add_assoc], refine le_trans le_add_sub (add_le_add_left le_add_sub _) }
apply le_add_sub
rw [← add_assoc]
rw [sub_le_iff_right, sub_add_cancel_of_le h]
rw [← nonpos_iff_eq_zero, sub_le_iff_left, add_zero]
rw [← sub_add_cancel_of_le h₁, ← sub_add_cancel_of_le h₂, h₃]
rw [add_comm a, hb.add_sub_assoc_of_le h, add_comm]
refine ⟨_, λ h, sub_le_sub_left' h a⟩
rw [sub_le_iff_left, ← hc.add_sub_assoc_of_le h, hc.le_sub_iff_right (h.trans le_add_self), add_comm b]
apply ha
rw [hba.sub_eq_iff_eq_add_of_le sub_le_self', add_sub_cancel_of_le h]
simpa [h] using hab
rw [ha, zero_mul, zero_lt_iff]
exact mul_ne_zero hb hd
rw [hc, mul_zero, zero_lt_iff]
exact mul_ne_zero hb hd
simpa only [smul_add, smul_inv_smul' ha] using h (a • x)
refine_struct { mul := λ _ _, star, one := star, inv := λ _, star, div := λ _ _, star, npow := λ _ _, star, gpow := λ _ _, star, .. }
refine_struct { mul := λ _ _, star, one := star, inv := λ _, star, div := λ _ _, star, npow := λ _ _, star, gpow := λ _ _, star, .. }; intros; exact subsingleton.elim _ _
refine_struct { mul := λ _ _, star, one := star, inv := λ _, star, div := λ _ _, star, npow := λ _ _, star, gpow := λ _ _, star, .. }; intros
intros
intros
intros
intros
intros
intros
intros
intros
intros
exact subsingleton.elim _ _
exact subsingleton.elim _ _
exact subsingleton.elim _ _
exact subsingleton.elim _ _
exact subsingleton.elim _ _
exact subsingleton.elim _ _
exact subsingleton.elim _ _
exact subsingleton.elim _ _
exact subsingleton.elim _ _
exact subsingleton.elim _ _
rw [←right_inv x y, ←self_distrib]
simpa using h
have h := @self_act_eq_iff_eq _ _ (op x) (op y)
ext
ext; simp [neg_add]
simp [neg_add]
simp [neg_add]
simp [neg_add]
simp [neg_add]
ext
ext; simp
simp
simp
simp
simp
simp
rw [add_comm, self_add_conj]
rw [norm_sq_def, conj_coe, ← coe_mul, coe_re, sq]
rw [←i_mul_j, mul_assoc, j_mul_j, mul_smul_comm, mul_one]
rw [nontrivial_iff, not_iff_comm, is_left_regular_zero_iff_subsingleton, subsingleton_iff]
push_neg
exact iff.rfl
rw h
exact is_regular_one.right
rwa comp_mul_left a b
ac_refl
rw [mul_one_add_self, mul_zero, add_zero, mul_add, mul_one]
ac_refl
rw [add_self, add_zero]
rw mul_self
rw [add_mul, mul_add]
rw mul_self
rwa self_eq_add_left at this
simp
rw [← ring_hom.comp_apply, comp_eq₂]
refine_struct { zero := (0 : Π i, f i), add := (+), mul := (*), .. }
refine_struct { zero := (0 : Π i, f i), add := (+), mul := (*), .. }; tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
refine_struct { zero := (0 : Π i, f i), one := 1, add := (+), mul := (*), neg := has_neg.neg, nsmul := λ n x i, nsmul n (x i), npow := λ n x i, npow n (x i) }
refine_struct { zero := (0 : Π i, f i), one := 1, add := (+), mul := (*), neg := has_neg.neg, nsmul := λ n x i, nsmul n (x i), npow := λ n x i, npow n (x i) }; tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
rw [unop_id, Spec.SheafedSpace_map_id]
rw [unop_comp, Spec.SheafedSpace_map_comp]
apply_instance
rw [Spec.LocallyRingedSpace_map_coe, Spec.SheafedSpace_map_comp]
refl
rw [unop_id, Spec.Top_map_id]
rw [unop_comp, Spec.Top_map_comp]
simp [vanishing_ideal]
split
contrapose!
intro h
apply set.ne_empty_iff_nonempty.mpr
rcases ideal.exists_le_maximal I h with ⟨M, hM, hIM⟩
{ contrapose!, intro h, apply set.ne_empty_iff_nonempty.mpr, rcases ideal.exists_le_maximal I h with ⟨M, hM, hIM⟩, exact ⟨⟨M, hM.is_prime⟩, hIM⟩ }
exact ⟨⟨M, hM.is_prime⟩, hIM⟩
apply zero_locus_empty_of_one_mem
trivial
rintro rfl
simp only [zero_locus_Union]
rw continuous_iff_is_closed
simp only [is_closed_iff_zero_locus]
rintro _ ⟨s, rfl⟩
exact ⟨_, preimage_comap_zero_locus f s⟩
ext1
ext1 i
apply ulift.up.inj
ext1
change (skeletal_functor.map f) ⟨i⟩ = (skeletal_functor.map g) ⟨i⟩
rw h
split
introsI m x y h
have H : const n x ≫ f = const n y ≫ f
rw h
{ dsimp, rw h }
dsimp
change (n.const x).to_preorder_hom 0 = (n.const y).to_preorder_hom 0
rw cancel_mono f at H
{ introsI m x y h, have H : const n x ≫ f = const n y ≫ f, { dsimp, rw h }, change (n.const x).to_preorder_hom 0 = (n.const y).to_preorder_hom 0, rw cancel_mono f at H, rw H }
rw H
exact concrete_category.mono_of_injective f
intros i j g
dsimp
rw ← g.op_unop
simpa only [← X.map_comp, ← category.assoc, category.comp_id, ← op_comp] using w _ _ _
simp only [←X.map_comp, simplex_category.δ_comp_σ_of_gt H]
dsimp [δ, σ]
simp
tidy
rw h
have f_bound : ∀ t ∈ Ico a b, dist (v t (f t)) (v t (f t)) ≤ 0
intros
rw [dist_self]
have g_bound : ∀ t ∈ Ico a b, dist (v t (g t)) (v t (g t)) ≤ 0
intros
rw [dist_self]
assume t ht
have := dist_le_of_approx_trajectories_ODE_of_mem_set hv hf hf' f_bound hfs hg hg' g_bound hgs ha t ht
rwa [zero_add, gronwall_bound_ε0] at this
obtain ⟨a, ha : a ∈ Ioo (0 : ℝ) 1, C, hC : 0 < C, hp⟩ := p.norm_mul_pow_le_mul_pow_of_lt_radius h
exact summable_of_nonneg_of_le (λ n, mul_nonneg (norm_nonneg _) (pow_nonneg r.coe_nonneg _)) hp ((summable_geometric_of_lt_1 ha.1.le ha.2).mul_left _)
rw is_open_iff_mem_nhds
rintro x ⟨p, r, hr⟩
exact mem_of_superset (emetric.ball_mem_nhds _ hr.r_pos) (λ y hy, hr.analytic_at_of_mem hy)
split
intro hequiv
have := hequiv.is_o.tendsto_0
simp only [pi.sub_apply, sub_div] at this
have key : tendsto (λ x, v x / v x) l (𝓝 1)
exact (tendsto_congr' $ hz.mono $ λ x hnz, @div_self _ _ (v x) hnz).mpr tendsto_const_nhds
{ exact (tendsto_congr' $ hz.mono $ λ x hnz, @div_self _ _ (v x) hnz).mpr tendsto_const_nhds }
convert this.add key
simp
{ ext, simp }
ext
{ intro hequiv, have := hequiv.is_o.tendsto_0, simp only [pi.sub_apply, sub_div] at this, have key : tendsto (λ x, v x / v x) l (𝓝 1), { exact (tendsto_congr' $ hz.mono $ λ x hnz, @div_self _ _ (v x) hnz).mpr tendsto_const_nhds }, convert this.add key, { ext, simp }, { norm_num } }
norm_num
exact is_equivalent_of_tendsto_one (hz.mono $ λ x hnvz hz, (hnvz hz).elim)
rw is_O
rw is_O; exact ⟨c, h⟩
exact ⟨c, h⟩
simp [h _ hx, hx]
exact exists_congr (λ C, e.is_O_with_congr hb)
unfold is_O
exact exists_congr (λ C, e.is_O_with_congr)
unfold is_O
simp [subsingleton.elim (f' _) 0, mul_nonneg hc.le]
simp only [is_O_with, norm_neg]
simpa only [sub_eq_add_neg] using h₁.add h₂.neg_left
rw is_O_with
have := (has_fderiv_within_at.mul' hc hd).has_deriv_within_at
rwa [continuous_linear_map.add_apply, continuous_linear_map.smul_apply, continuous_linear_map.smul_right_apply, continuous_linear_map.smul_right_apply, continuous_linear_map.smul_right_apply, continuous_linear_map.one_apply, one_smul, one_smul, add_comm] at this
simp only [div_eq_mul_inv, deriv_mul_const_field]
rw differentiable_at.deriv_within p.differentiable_at hxs
exact p.deriv
rw [← Ici_diff_left, has_deriv_within_at_diff_singleton]
simp only [has_deriv_within_at, nhds_within_union]
exact hs.join ht
simp [deriv]
simpa using (hc.smul hf).has_strict_deriv_at
simpa using h.neg.has_deriv_at_filter
simpa only [sub_eq_add_neg] using hf.add hg.neg
rw [fderiv_within_zero_of_not_differentiable_within_at hf, fderiv_within_zero_of_not_differentiable_within_at]
simpa
have tendsto_arg : tendsto (λ n, x + d n) l (𝓝[s] x)
rw ← add_zero x
conv in (𝓝[s] x) { rw ← add_zero x }
rw [nhds_within, tendsto_inf]
split
{ apply tendsto_const_nhds.add (tangent_cone_at.lim_zero l clim cdlim) }
apply tendsto_const_nhds.add (tangent_cone_at.lim_zero l clim cdlim)
{ conv in (𝓝[s] x) { rw ← add_zero x }, rw [nhds_within, tendsto_inf], split, { apply tendsto_const_nhds.add (tangent_cone_at.lim_zero l clim cdlim) }, { rwa tendsto_principal } }
rwa tendsto_principal
have : is_o (λ y, f y - f x - f' (y - x)) (λ y, y - x) (𝓝[s] x) := h
have : is_o (λ n, f (x + d n) - f x - f' ((x + d n) - x)) (λ n, (x + d n) - x) l := this.comp_tendsto tendsto_arg
have : is_o (λ n, f (x + d n) - f x - f' (d n)) d l := by simpa only [add_sub_cancel']
simpa only [add_sub_cancel']
have : is_o (λn, c n • (f (x + d n) - f x - f' (d n))) (λn, c n • d n) l := (is_O_refl c l).smul_is_o this
have : is_o (λn, c n • (f (x + d n) - f x - f' (d n))) (λn, (1:ℝ)) l := this.trans_is_O (is_O_one_of_tendsto ℝ cdlim)
have L1 : tendsto (λn, c n • (f (x + d n) - f x - f' (d n))) l (𝓝 0) := (is_o_one_iff ℝ).1 this
have L2 : tendsto (λn, f' (c n • d n)) l (𝓝 (f' v)) := tendsto.comp f'.cont.continuous_at cdlim
have L3 : tendsto (λn, (c n • (f (x + d n) - f x - f' (d n)) + f' (c n • d n))) l (𝓝 (0 + f' v)) := L1.add L2
have : (λn, (c n • (f (x + d n) - f x - f' (d n)) + f' (c n • d n))) = (λn, c n • (f (x + d n) - f x))
ext n
simp [smul_add, smul_sub]
rwa [this, zero_add] at L3
refine ⟨λ H, _, λ H, iso.has_strict_fderiv_at.comp x H⟩
convert iso.symm.has_strict_fderiv_at.comp x H
convert iso.symm.has_strict_fderiv_at.comp x H; ext z; apply (iso.symm_apply_apply _).symm
convert iso.symm.has_strict_fderiv_at.comp x H; ext z
ext z
ext z
apply (iso.symm_apply_apply _).symm
apply (iso.symm_apply_apply _).symm
simp
rw [sub_eq_zero.1 (norm_eq_zero.1 hx')]
unfold has_fderiv_at_filter
rw [←is_o_norm_left, ←is_o_norm_right, is_o_iff_tendsto h]
exact tendsto_congr (λ _, div_eq_inv_mul)
refine le_of_forall_pos_le_add (λ ε ε0, op_norm_le_of_nhds_zero _ _)
exact add_nonneg C.coe_nonneg ε0.le
rw [← map_add_left_nhds_zero x₀, mem_map] at hs'
have hs' := hs
filter_upwards [is_o_iff.1 (has_fderiv_at_iff_is_o_nhds_zero.1 hf) ε0, hs']
intros y hy hys
have := hlip.norm_sub_le hys (mem_of_mem_nhds hs)
rw add_sub_cancel' at this
calc ∥f' y∥ ≤ ∥f (x₀ + y) - f x₀∥ + ∥f (x₀ + y) - f x₀ - f' y∥ : norm_le_insert _ _ ... ≤ C * ∥y∥ + ε * ∥y∥ : add_le_add this hy ... = (C + ε) * ∥y∥ : (add_mul _ _ _).symm
simp [has_fderiv_within_at, nhds_within_restrict' s h]
rcases hx with ⟨r', r'mem, hr'⟩
exact hr' _ _ (lt_of_le_of_lt (mem_closed_ball.1 hy) r'mem.1) (lt_of_le_of_lt (mem_closed_ball.1 hz) r'mem.1)
refl
ext x
rw fderiv_within_zero_of_not_differentiable_within_at hf
refl
ext y
apply (h.on univ).has_fderiv_within_at_eq_zero hf.has_fderiv_within_at
apply (h.on univ).has_fderiv_within_at_eq_zero hf.has_fderiv_within_at; rw pos_tangent_cone_at_univ; apply mem_univ
apply (h.on univ).has_fderiv_within_at_eq_zero hf.has_fderiv_within_at; rw pos_tangent_cone_at_univ
apply mem_univ
apply mem_univ
rw pos_tangent_cone_at_univ
rw pos_tangent_cone_at_univ
refine norm_image_sub_le_of_norm_deriv_le_segment' _ bound
exact λ x hx, (hf x hx).has_deriv_within_at
let h := λ x, (lgb - lga) * f x - (lfb - lfa) * g x
have hha : tendsto h (𝓝[Ioi a] a) (𝓝 $ lgb * lfa - lfb * lga)
have : tendsto h (𝓝[Ioi a] a)(𝓝 $ (lgb - lga) * lfa - (lfb - lfa) * lga) := (tendsto_const_nhds.mul hfa).sub (tendsto_const_nhds.mul hga)
convert this using 2
{ have : tendsto h (𝓝[Ioi a] a)(𝓝 $ (lgb - lga) * lfa - (lfb - lfa) * lga) := (tendsto_const_nhds.mul hfa).sub (tendsto_const_nhds.mul hga), convert this using 2, ring }
ring
have hhb : tendsto h (𝓝[Iio b] b) (𝓝 $ lgb * lfa - lfb * lga)
have : tendsto h (𝓝[Iio b] b)(𝓝 $ (lgb - lga) * lfb - (lfb - lfa) * lgb) := (tendsto_const_nhds.mul hfb).sub (tendsto_const_nhds.mul hgb)
convert this using 2
{ have : tendsto h (𝓝[Iio b] b)(𝓝 $ (lgb - lga) * lfb - (lfb - lfa) * lgb) := (tendsto_const_nhds.mul hfb).sub (tendsto_const_nhds.mul hgb), convert this using 2, ring }
ring
let h' := λ x, (lgb - lga) * f' x - (lfb - lfa) * g' x
have hhh' : ∀ x ∈ Ioo a b, has_deriv_at h (h' x) x
intros x hx
exact ((hff' x hx).const_mul _ ).sub (((hgg' x hx)).const_mul _)
{ intros x hx, exact ((hff' x hx).const_mul _ ).sub (((hgg' x hx)).const_mul _) }
rcases exists_has_deriv_at_eq_zero' hab hha hhb hhh' with ⟨c, cmem, hc⟩
exact ⟨c, cmem, sub_eq_zero.1 hc⟩
apply mem_of_superset (ball_mem_nhds _ ε_pos)
intros x x_in
rw [set.mem_set_of_eq, ← norm_smul_of_nonneg (nneg _), integral_smul, integral_sub, integral_sub, ← continuous_linear_map.integral_apply hF'_int]
exacts [hF_int' x x_in, hF_int, (hF_int' x x_in).sub hF_int, hF'_int.apply_continuous_linear_map _]
{ apply mem_of_superset (ball_mem_nhds _ ε_pos), intros x x_in, rw [set.mem_set_of_eq, ← norm_smul_of_nonneg (nneg _), integral_smul, integral_sub, integral_sub, ← continuous_linear_map.integral_apply hF'_int], exacts [hF_int' x x_in, hF_int, (hF_int' x x_in).sub hF_int, hF'_int.apply_continuous_linear_map _] }
rw [has_fderiv_at_iff_tendsto, tendsto_congr' this, ← tendsto_zero_iff_norm_tendsto_zero, ← show ∫ (a : α), ∥x₀ - x₀∥⁻¹ • (F x₀ a - F x₀ a - (F' a) (x₀ - x₀)) ∂μ = 0, by simp]
simp
apply tendsto_integral_filter_of_dominated_convergence
{ apply is_countably_generated_nhds }
apply is_countably_generated_nhds
filter_upwards [h_ball]
intros x x_in
apply ae_measurable.const_smul
exact ((hF_meas _ x_in).sub (hF_meas _ x₀_in)).sub (hF'_meas.apply_continuous_linear_map _)
{ filter_upwards [h_ball], intros x x_in, apply ae_measurable.const_smul, exact ((hF_meas _ x_in).sub (hF_meas _ x₀_in)).sub (hF'_meas.apply_continuous_linear_map _) }
{ simp [measurable_const] }
simp [measurable_const]
apply mem_of_superset h_ball
intros x hx
apply (h_diff.and h_lipsch).mono
rintros a ⟨ha_deriv, ha_bound⟩
show ∥∥x - x₀∥⁻¹ • (F x a - F x₀ a - F' a (x - x₀))∥ ≤ b a + ∥F' a∥
replace ha_bound : ∥F x a - F x₀ a∥ ≤ b a * ∥x - x₀∥
rw lipschitz_on_with_iff_norm_sub_le at ha_bound
{ rw lipschitz_on_with_iff_norm_sub_le at ha_bound, exact ha_bound _ hx _ x₀_in }
exact ha_bound _ hx _ x₀_in
calc ∥∥x - x₀∥⁻¹ • (F x a - F x₀ a - F' a (x - x₀))∥ = ∥∥x - x₀∥⁻¹ • (F x a - F x₀ a) - ∥x - x₀∥⁻¹ • F' a (x - x₀)∥ : by rw smul_sub ... ≤ ∥∥x - x₀∥⁻¹ • (F x a - F x₀ a)∥ + ∥∥x - x₀∥⁻¹ • F' a (x - x₀)∥ : norm_sub_le _ _ ... = ∥x - x₀∥⁻¹ * ∥F x a - F x₀ a∥ + ∥x - x₀∥⁻¹ * ∥F' a (x - x₀)∥ : by { rw [norm_smul_of_nonneg, norm_smul_of_nonneg] ; exact nneg _} ... ≤ ∥x - x₀∥⁻¹ * (b a * ∥x - x₀∥) + ∥x - x₀∥⁻¹ * (∥F' a∥ * ∥x - x₀∥) : add_le_add _ _ ... ≤ b a + ∥F' a∥ : _
rw smul_sub
rw [norm_smul_of_nonneg, norm_smul_of_nonneg]
rw [norm_smul_of_nonneg, norm_smul_of_nonneg] ; exact nneg _
exact nneg _
exact mul_le_mul_of_nonneg_left ha_bound (nneg _)
apply mul_le_mul_of_nonneg_left ((F' a).le_op_norm _) (nneg _)
by_cases h : ∥x - x₀∥ = 0
{ simpa [h] using add_nonneg (b_nonneg a) (norm_nonneg (F' a)) }
simpa [h] using add_nonneg (b_nonneg a) (norm_nonneg (F' a))
{ apply mem_of_superset h_ball, intros x hx, apply (h_diff.and h_lipsch).mono, rintros a ⟨ha_deriv, ha_bound⟩, show ∥∥x - x₀∥⁻¹ • (F x a - F x₀ a - F' a (x - x₀))∥ ≤ b a + ∥F' a∥, replace ha_bound : ∥F x a - F x₀ a∥ ≤ b a * ∥x - x₀∥, { rw lipschitz_on_with_iff_norm_sub_le at ha_bound, exact ha_bound _ hx _ x₀_in }, calc ∥∥x - x₀∥⁻¹ • (F x a - F x₀ a - F' a (x - x₀))∥ = ∥∥x - x₀∥⁻¹ • (F x a - F x₀ a) - ∥x - x₀∥⁻¹ • F' a (x - x₀)∥ : by rw smul_sub ... ≤ ∥∥x - x₀∥⁻¹ • (F x a - F x₀ a)∥ + ∥∥x - x₀∥⁻¹ • F' a (x - x₀)∥ : norm_sub_le _ _ ... = ∥x - x₀∥⁻¹ * ∥F x a - F x₀ a∥ + ∥x - x₀∥⁻¹ * ∥F' a (x - x₀)∥ : by { rw [norm_smul_of_nonneg, norm_smul_of_nonneg] ; exact nneg _} ... ≤ ∥x - x₀∥⁻¹ * (b a * ∥x - x₀∥) + ∥x - x₀∥⁻¹ * (∥F' a∥ * ∥x - x₀∥) : add_le_add _ _ ... ≤ b a + ∥F' a∥ : _, exact mul_le_mul_of_nonneg_left ha_bound (nneg _), apply mul_le_mul_of_nonneg_left ((F' a).le_op_norm _) (nneg _), by_cases h : ∥x - x₀∥ = 0, { simpa [h] using add_nonneg (b_nonneg a) (norm_nonneg (F' a)) }, { field_simp [h] } }
field_simp [h]
{ exact b_int.add hF'_int.norm }
exact b_int.add hF'_int.norm
apply h_diff.mono
intros a ha
suffices : tendsto (λ x, ∥x - x₀∥⁻¹ • (F x a - F x₀ a - F' a (x - x₀))) (𝓝 x₀) (𝓝 0)
simpa
rw tendsto_zero_iff_norm_tendsto_zero
have : (λ x, ∥x - x₀∥⁻¹ * ∥F x a - F x₀ a - F' a (x - x₀)∥) = λ x, ∥∥x - x₀∥⁻¹ • (F x a - F x₀ a - F' a (x - x₀))∥
ext x
{ ext x, rw norm_smul_of_nonneg (nneg _) }
rw norm_smul_of_nonneg (nneg _)
rwa [has_fderiv_at_iff_tendsto, this] at ha
have x₀_in : x₀ ∈ ball x₀ ε := mem_ball_self ε_pos
have nneg : ∀ x, 0 ≤ ∥x - x₀∥⁻¹ := λ x, inv_nonneg.mpr (norm_nonneg _)
set b : α → ℝ := λ a, abs (bound a)
have b_int : integrable b μ := bound_integrable.norm
have b_nonneg : ∀ a, 0 ≤ b a := λ a, abs_nonneg _
have hF_int' : ∀ x ∈ ball x₀ ε, integrable (F x) μ
intros x x_in
have : ∀ᵐ a ∂μ, ∥F x₀ a - F x a∥ ≤ ε * ∥(bound a : ℝ)∥
apply h_lipsch.mono
intros a ha
rw lipschitz_on_with_iff_norm_sub_le at ha
apply (ha x₀ x₀_in x x_in).trans
rw [mul_comm, real.coe_nnabs, real.norm_eq_abs]
rw [mem_ball, dist_eq_norm, norm_sub_rev] at x_in
{ apply h_lipsch.mono, intros a ha, rw lipschitz_on_with_iff_norm_sub_le at ha, apply (ha x₀ x₀_in x x_in).trans, rw [mul_comm, real.coe_nnabs, real.norm_eq_abs], rw [mem_ball, dist_eq_norm, norm_sub_rev] at x_in, exact mul_le_mul_of_nonneg_right (le_of_lt x_in) (abs_nonneg _) }
exact mul_le_mul_of_nonneg_right (le_of_lt x_in) (abs_nonneg _)
exact integrable_of_norm_sub_le (hF_meas x x_in) hF_int (integrable.const_mul bound_integrable.norm ε) this
{ intros x x_in, have : ∀ᵐ a ∂μ, ∥F x₀ a - F x a∥ ≤ ε * ∥(bound a : ℝ)∥, { apply h_lipsch.mono, intros a ha, rw lipschitz_on_with_iff_norm_sub_le at ha, apply (ha x₀ x₀_in x x_in).trans, rw [mul_comm, real.coe_nnabs, real.norm_eq_abs], rw [mem_ball, dist_eq_norm, norm_sub_rev] at x_in, exact mul_le_mul_of_nonneg_right (le_of_lt x_in) (abs_nonneg _) }, exact integrable_of_norm_sub_le (hF_meas x x_in) hF_int (integrable.const_mul bound_integrable.norm ε) this }
have hF'_int : integrable F' μ
have : ∀ᵐ a ∂μ, ∥F' a∥ ≤ b a
apply (h_diff.and h_lipsch).mono
rintros a ⟨ha_diff, ha_lip⟩
{ apply (h_diff.and h_lipsch).mono, rintros a ⟨ha_diff, ha_lip⟩, exact ha_diff.le_of_lip (ball_mem_nhds _ ε_pos) ha_lip }
exact ha_diff.le_of_lip (ball_mem_nhds _ ε_pos) ha_lip
{ have : ∀ᵐ a ∂μ, ∥F' a∥ ≤ b a, { apply (h_diff.and h_lipsch).mono, rintros a ⟨ha_diff, ha_lip⟩, exact ha_diff.le_of_lip (ball_mem_nhds _ ε_pos) ha_lip }, exact b_int.mono' hF'_meas this }
exact b_int.mono' hF'_meas this
refine ⟨hF'_int, _⟩
have h_ball: ball x₀ ε ∈ 𝓝 x₀ := ball_mem_nhds x₀ ε_pos
have : ∀ᶠ x in 𝓝 x₀, ∥x - x₀∥⁻¹ * ∥∫ a, F x a ∂μ - ∫ a, F x₀ a ∂μ - (∫ a, F' a ∂μ) (x - x₀)∥ = ∥∫ a, ∥x - x₀∥⁻¹ • (F x a - F x₀ a - F' a (x - x₀)) ∂μ∥
ext x
suffices : f x ≠ 0 ↔ dist x c < f.R
simpa [mem_support]
cases lt_or_le (dist x c) f.R with hx hx
{ simp [hx, (f.pos_of_mem_ball hx).ne'] }
simp [hx, (f.pos_of_mem_ball hx).ne']
simp [hx.not_lt, f.zero_of_le_dist hx]
rw [f.support_eq, euclidean.closure_ball _ f.R_pos]
have A : tendsto (λn, ∥c n∥⁻¹) l (𝓝 0) := tendsto_inv_at_top_zero.comp hc
have B : tendsto (λn, ∥c n • d n∥) l (𝓝 ∥y∥) := (continuous_norm.tendsto _).comp hd
have C : tendsto (λn, ∥c n∥⁻¹ * ∥c n • d n∥) l (𝓝 (0 * ∥y∥)) := A.mul B
rw zero_mul at C
have : ∀ᶠ n in l, ∥c n∥⁻¹ * ∥c n • d n∥ = ∥d n∥
apply (eventually_ne_of_tendsto_norm_at_top hc 0).mono (λn hn, _)
rw [norm_smul, ← mul_assoc, inv_mul_cancel, one_mul]
{ apply (eventually_ne_of_tendsto_norm_at_top hc 0).mono (λn hn, _), rw [norm_smul, ← mul_assoc, inv_mul_cancel, one_mul], rwa [ne.def, norm_eq_zero] }
rwa [ne.def, norm_eq_zero]
have D : tendsto (λ n, ∥d n∥) l (𝓝 0) := tendsto.congr' this C
rw tendsto_zero_iff_norm_tendsto_zero
exact D
rintros _ ⟨v, ⟨c, d, hd, hc, hy⟩, rfl⟩
have : ∀n, ∃d', y + d' ∈ t ∧ ∥c n • d'∥ < ((1:ℝ)/2)^n
assume n
rcases mem_closure_iff_nhds.1 ht _ (eventually_nhds_norm_smul_sub_lt (c n) y (pow_pos one_half_pos n)) with ⟨z, hz, hzt⟩
simpa using hzt
simpa using hz
{ assume n, rcases mem_closure_iff_nhds.1 ht _ (eventually_nhds_norm_smul_sub_lt (c n) y (pow_pos one_half_pos n)) with ⟨z, hz, hzt⟩, exact ⟨z - y, by simpa using hzt, by simpa using hz⟩ }
exact ⟨z - y, by simpa using hzt, by simpa using hz⟩
choose d' hd' using this
refine ⟨c, λn, (d n, d' n), _, hc, _⟩
show ∀ᶠ n in at_top, (x, y) + (d n, d' n) ∈ set.prod s t
filter_upwards [hd]
assume n hn
{ filter_upwards [hd], assume n hn, simp [hn, (hd' n).1] }
simp [hn, (hd' n).1]
apply tendsto.prod_mk_nhds hy _
refine squeeze_zero_norm (λn, (hd' n).2.le) _
exact tendsto_pow_at_top_nhds_0_of_lt_1 one_half_pos.le one_half_lt_one
rintros _ ⟨w, ⟨c, d, hd, hc, hy⟩, rfl⟩
have : ∀n, ∃d', x + d' ∈ s ∧ ∥c n • d'∥ < ((1:ℝ)/2)^n
assume n
rcases mem_closure_iff_nhds.1 hs _ (eventually_nhds_norm_smul_sub_lt (c n) x (pow_pos one_half_pos n)) with ⟨z, hz, hzs⟩
simpa using hzs
simpa using hz
{ assume n, rcases mem_closure_iff_nhds.1 hs _ (eventually_nhds_norm_smul_sub_lt (c n) x (pow_pos one_half_pos n)) with ⟨z, hz, hzs⟩, exact ⟨z - x, by simpa using hzs, by simpa using hz⟩ }
exact ⟨z - x, by simpa using hzs, by simpa using hz⟩
choose d' hd' using this
refine ⟨c, λn, (d' n, d n), _, hc, _⟩
show ∀ᶠ n in at_top, (x, y) + (d' n, d n) ∈ set.prod s t
filter_upwards [hd]
assume n hn
{ filter_upwards [hd], assume n hn, simp [hn, (hd' n).1] }
simp [hn, (hd' n).1]
apply tendsto.prod_mk_nhds _ hy
refine squeeze_zero_norm (λn, (hd' n).2.le) _
exact tendsto_pow_at_top_nhds_0_of_lt_1 one_half_pos.le one_half_lt_one
classical
rw [← set.univ_pi_piecewise]
refine unique_diff_within_at.univ_pi _ _ _ _ (λ i, _)
by_cases hi : i ∈ I; simp [*, unique_diff_within_at_univ]
simp [*, unique_diff_within_at_univ]
simp [*, unique_diff_within_at_univ]
by_cases hi : i ∈ I
simp [has_ftaylor_series_up_to_on_succ_iff_right, has_ftaylor_series_up_to_on_univ_iff.symm, -add_comm, -with_zero.coe_add]
simpa [nhds_within_univ] using h.eventually
split
assume H
use ftaylor_series_within 𝕜 f univ
rw ← has_ftaylor_series_up_to_on_univ_iff
{ assume H, use ftaylor_series_within 𝕜 f univ, rw ← has_ftaylor_series_up_to_on_univ_iff, exact H.ftaylor_series_within unique_diff_on_univ }
exact H.ftaylor_series_within unique_diff_on_univ
rintros ⟨p, hp⟩ x hx m hm
exact ⟨univ, filter.univ_sets _, p, (hp.has_ftaylor_series_up_to_on univ).of_le hm⟩
rw iterated_fderiv_succ_apply_right
refl
ext m
simp [times_cont_diff_on_univ.symm, differentiable_on_univ.symm, fderiv_within_univ.symm, - fderiv_within_univ, times_cont_diff_on_succ_iff_fderiv_within unique_diff_on_univ, -with_zero.coe_add, -add_comm]
exact times_cont_diff_at_const
rw [subsingleton.elim f (λ _, 0)]
exact times_cont_diff_on_const
rw [subsingleton.elim f (λ _, 0)]
simpa only [div_eq_mul_inv] using hf.mul times_cont_diff_within_at_const
rw times_cont_diff_at at *
convert hf.prod_map hg
simp only [univ_prod_univ]
rw coe_inv_circle_eq_conj
apply eq_inv_of_mul_right_eq_one
rw [mul_comm, ← complex.norm_sq_eq_conj_mul_self]
simp
have h₁ := f.norm_map z
simp only [complex.abs, norm_eq_abs] at h₁
rwa [real.sqrt_inj (norm_sq_nonneg _) (norm_sq_nonneg _), norm_sq_apply (f z), norm_sq_apply z, h₂, add_left_cancel_iff, mul_self_eq_mul_self_iff] at h₁
rw is_primitive_root.iff_def
simp only [← exp_nat_mul, exp_eq_one_iff]
exact_mod_cast h0
have hn0 : (n : ℂ) ≠ 0
split
use i
{ use i, field_simp [hn0, mul_comm (i : ℂ), mul_comm (n : ℂ)] }
field_simp [hn0, mul_comm (i : ℂ), mul_comm (n : ℂ)]
simp only [hn0, mul_right_comm _ _ ↑n, mul_left_inj' two_pi_I_ne_zero, ne.def, not_false_iff, mul_comm _ (i : ℂ), ← mul_assoc _ (i : ℂ), exists_imp_distrib] with field_simps
norm_cast
rintro l k hk
have : n ∣ i * l
apply dvd_mul_left
{ rw [← int.coe_nat_dvd, hk], apply dvd_mul_left }
rw [← int.coe_nat_dvd, hk]
exact hi.symm.dvd_of_dvd_mul_left this
intros x y hx hy a b ha hb hab
have h := hs hx hy ha hb hab
rwa [smul_add, smul_add, add_add_add_comm, ←add_smul, hab, one_smul] at h
simpa only [add_comm] using hs.translate_preimage_right z
obtain rfl | hB := B.eq_empty_or_nonempty
{ exact convex_empty }
exact convex_empty
obtain ⟨l, rfl⟩ := hAB hB
exact λ x₁ x₂ hx₁ hx₂ a b ha hb hab, ⟨hA hx₁.1 hx₂.1 ha hb hab, λ y hy, ((l.to_linear_map.concave_on convex_univ).concave_ge _ ⟨mem_univ _, hx₁.2 y hy⟩ ⟨mem_univ _, hx₂.2 y hy⟩ ha hb hab).2⟩
use subset.trans hBC.1 hAB.1
rintro x₁ x₂ hx₁A hx₂A x hxC hx
obtain ⟨hx₁B, hx₂B⟩ := hAB.2 x₁ x₂ hx₁A hx₂A x (hBC.1 hxC) hx
exact hBC.2 x₁ x₂ hx₁B hx₂B x hxC hx
simpa only [add_comm] using hf.translate_right
obtain ⟨a, b, ha, hb, hab, rfl⟩ := hz
exact hf.le_left_of_right_le' hx hy ha hb.le hab hyz
intros x y hxy
refine ⟨_, ⟨fourier 1, _, rfl⟩, _⟩
{ exact subset_adjoin ⟨1, rfl⟩ }
exact subset_adjoin ⟨1, rfl⟩
simp [hxy]
rw orthonormal_iff_ite
intros i j
rw continuous_map.inner_to_Lp haar_circle (fourier i) (fourier j)
split_ifs
simp [h, is_probability_measure.measure_univ, ← fourier_neg, ← fourier_add, -fourier_to_fun]
{ simp [h, is_probability_measure.measure_univ, ← fourier_neg, ← fourier_add, -fourier_to_fun] }
simp only [← fourier_add, ← fourier_neg, is_R_or_C.conj_to_complex]
have hij : -i + j ≠ 0
rw add_comm
{ rw add_comm, exact sub_ne_zero.mpr (ne.symm h) }
exact sub_ne_zero.mpr (ne.symm h)
exact integral_zero_of_mul_left_eq_neg (is_mul_left_invariant_haar_measure _) (fourier_add_half_inv_index hij)
simp [fpow_add (nonzero_of_mem_circle z)]
simp [norm_eq_zero, hx]
have hx' : ∥x∥ ≠ 0 := by simp [norm_eq_zero, hx]
simp [is_R_or_C.abs_eq_zero, hr]
have hr' : abs r ≠ 0 := by simp [is_R_or_C.abs_eq_zero, hr]
rw [inner_smul_right, is_R_or_C.abs_mul, ←inner_self_re_abs, inner_self_eq_norm_sq, norm_smul]
rw [is_R_or_C.norm_eq_abs, ←mul_assoc, ←div_div_eq_div_mul, mul_div_cancel _ hx', ←div_div_eq_div_mul, mul_comm, mul_div_cancel _ hr', div_self hx']
have H : ∥x∥ * ∥y∥ * (∥x∥ * ∥y∥) = re ⟪y, y⟫ * re ⟪x, x⟫
ring
{ simp only [inner_self_eq_norm_sq], ring, }
simp only [inner_self_eq_norm_sq]
rw H
conv begin to_lhs, congr, rw[inner_abs_conj_sym], end
congr
rw[inner_abs_conj_sym]
to_lhs
exact inner_mul_inner_self_le y x
rw [← zero_smul 𝕜 (0:E), inner_smul_left, ring_hom.map_zero, zero_mul]
assume h
have h : ∀ w ∈ K, ⟪u - v, w - v⟫_ℝ ≤ 0
exacts [K.convex, hv]
rwa [norm_eq_infi_iff_real_inner_le_zero] at h
{ rwa [norm_eq_infi_iff_real_inner_le_zero] at h, exacts [K.convex, hv] }
assume w hw
have le : ⟪u - v, w⟫_ℝ ≤ 0
let w' := w + v
have : w' ∈ K := submodule.add_mem _ hw hv
have h₁ := h w' this
simp only [add_neg_cancel_right, sub_eq_add_neg]
have h₂ : w' - v = w
exact h₁
rw h₂ at h₁
have ge : ⟪u - v, w⟫_ℝ ≥ 0
let w'' := -w + v
have : w'' ∈ K := submodule.add_mem _ (submodule.neg_mem _ hw) hv
have h₁ := h w'' this
simp only [neg_inj, add_neg_cancel_right, sub_eq_add_neg]
have h₂ : w'' - v = -w
rw [h₂, inner_neg_right] at h₁
linarith
exact le_antisymm le ge
assume h
have : ∀ w ∈ K, ⟪u - v, w - v⟫_ℝ ≤ 0
assume w hw
let w' := w - v
have : w' ∈ K := submodule.sub_mem _ hw hv
have h₁ := h w' this
exact le_of_eq h₁
rwa norm_eq_infi_iff_real_inner_le_zero
exacts [submodule.convex _, hv]
simp [hv]
rw ← smul_orthogonal_projection_singleton 𝕜 w
convert inner_le_Lp_mul_Lq s f g hpq using 3; apply sum_congr rfl; intros i hi; simp only [abs_of_nonneg, hf i hi, hg i hi]
convert inner_le_Lp_mul_Lq s f g hpq using 3; apply sum_congr rfl; intros i hi
convert inner_le_Lp_mul_Lq s f g hpq using 3; apply sum_congr rfl
convert inner_le_Lp_mul_Lq s f g hpq using 3
apply sum_congr rfl
apply sum_congr rfl
intros i hi
intros i hi
simp only [abs_of_nonneg, hf i hi, hg i hi]
simp only [abs_of_nonneg, hf i hi, hg i hi]
have hp_pos : 0 < p := lt_of_lt_of_le zero_lt_one hp1
by_cases h_top : a + b = ⊤
rw ←@ennreal.rpow_eq_top_iff_of_pos (a + b) p hp_pos at h_top
rw h_top
{ rw ←@ennreal.rpow_eq_top_iff_of_pos (a + b) p hp_pos at h_top, rw h_top, exact le_top, }
exact le_top
obtain ⟨ha_top, hb_top⟩ := add_ne_top.mp h_top
by_cases h_zero : a + b = 0
simp [add_eq_zero_iff.mp h_zero, ennreal.zero_rpow_of_pos hp_pos]
{ simp [add_eq_zero_iff.mp h_zero, ennreal.zero_rpow_of_pos hp_pos], }
have h_nonzero : ¬(a = 0 ∧ b = 0)
rwa add_eq_zero_iff at h_zero
have h_add : a/(a+b) + b/(a+b) = 1
rw [div_add_div_same, div_self h_zero h_top]
have h := add_rpow_le_one_of_add_le_one (a/(a+b)) (b/(a+b)) h_add.le hp1
rw [div_rpow_of_nonneg a (a+b) hp_pos.le, div_rpow_of_nonneg b (a+b) hp_pos.le] at h
simp [ha_top, hb_top, hp_pos, h_nonzero]
have hab_0 : (a + b)^p ≠ 0
simp [ha_top, hb_top, hp_pos, h_nonzero]
have hab_top : (a + b)^p ≠ ⊤
have h_mul : (a + b)^p * (a ^ p / (a + b) ^ p + b ^ p / (a + b) ^ p) ≤ (a + b)^p
nth_rewrite 3 ←mul_one ((a + b)^p)
{ nth_rewrite 3 ←mul_one ((a + b)^p), exact (mul_le_mul_left hab_0 hab_top).mpr h, }
exact (mul_le_mul_left hab_0 hab_top).mpr h
rwa [div_eq_mul_inv, div_eq_mul_inv, mul_add, mul_comm (a^p), mul_comm (b^p), ←mul_assoc, ←mul_assoc, mul_inv_cancel hab_0 hab_top, one_mul, one_mul] at h_mul
apply (is_colimit_cokernel_cocone f).uniq (cofork.of_π g (by simp [w]))
simp [w]
rintro (_|_)
convert w.symm
{ convert w.symm, simp }
simp
exact he
fsplit
apply normed_group_hom.lift _ s.π.1
rintro _ ⟨b, rfl⟩
change (f ≫ s.π) b = 0
{ apply normed_group_hom.lift _ s.π.1, rintro _ ⟨b, rfl⟩, change (f ≫ s.π) b = 0, simp, }
simp
exact normed_group_hom.lift_norm_noninc _ _ _ s.π.2
simp [homothety_def, norm_smul, ← dist_eq_norm_vsub, dist_comm]
rw [dist_eq_norm_vsub V, dist_eq_norm_vsub V, dist_eq_norm_vsub V, midpoint_vsub_midpoint]
rw [dist_eq_norm_vsub V, dist_eq_norm_vsub V, dist_eq_norm_vsub V, midpoint_vsub_midpoint]; try { apply_instance }
apply_instance
try { apply_instance }
try { apply_instance }
rw [midpoint_eq_smul_add, norm_smul, inv_of_eq_inv, normed_field.norm_inv, ← div_eq_inv_mul]
exact div_le_div_of_le_of_nonneg (norm_add_le _ _) (norm_nonneg _)
rw [summable_iff_cauchy_seq_finset, cauchy_seq_finset_iff_vanishing_norm]
simp only [← nnreal.coe_le_coe, ← nnreal.has_sum_coe, coe_nnnorm] at *
exact tsum_of_norm_bounded hg h
intros x y
apply completion.induction_on₂ x y; clear x y
clear x y
clear x y
apply completion.induction_on₂ x y
refine is_closed_eq (completion.uniform_continuous_extension₂ _).continuous _
{ refine is_closed_eq (completion.uniform_continuous_extension₂ _).continuous _, exact continuous.comp completion.continuous_extension continuous_sub }
exact continuous.comp completion.continuous_extension continuous_sub
intros x y
rw [← completion.coe_sub, norm_coe, metric.completion.dist_eq, dist_eq_norm]
apply_instance
apply_instance
simp [dist_eq_norm]
refine is_linear_map.with_bound ⟨λ f₁ f₂, by { ext m, refl }, λ c f, by { ext m, refl }⟩ (∥g∥ ^ (fintype.card ι)) (λ f, _)
ext m
refl
ext m
refl
apply continuous_multilinear_map.op_norm_le_bound _ _ (λ m, _)
{ apply_rules [mul_nonneg, pow_nonneg, norm_nonneg] }
apply_rules [mul_nonneg, pow_nonneg, norm_nonneg]
calc ∥f (g ∘ m)∥ ≤ ∥f∥ * ∏ i, ∥g (m i)∥ : f.le_op_norm _ ... ≤ ∥f∥ * ∏ i, (∥g∥ * ∥m i∥) : begin apply mul_le_mul_of_nonneg_left _ (norm_nonneg _), exact finset.prod_le_prod (λ i hi, norm_nonneg _) (λ i hi, g.le_op_norm _) end ... = ∥g∥ ^ fintype.card ι * ∥f∥ * ∏ i, ∥m i∥ : by { simp [finset.prod_mul_distrib, finset.card_univ], ring }
apply mul_le_mul_of_nonneg_left _ (norm_nonneg _)
exact finset.prod_le_prod (λ i hi, norm_nonneg _) (λ i hi, g.le_op_norm _)
simp [finset.prod_mul_distrib, finset.card_univ]
ring
rw [f.map_add, continuous_linear_map.add_apply]
rw [f.map_smul _, continuous_linear_map.smul_apply]
apply_rules [mul_le_mul_of_nonneg_right, norm_nonneg, le_max_left]
simp only [hf', pi.smul_def]
simp only [hf', pi.smul_def]; exact (smul_right_injective _ hc).comp li.injective
exact (smul_right_injective _ hc).comp li.injective
simp [finite_norm_eq, ennreal.to_real_mul]
refine funext (λ x, _)
rw [real.exp, complex.exp_eq_exp_ℂ_ℂ, ← exp_ℝ_ℂ_eq_exp_ℂ_ℂ, exp_eq_tsum, exp_eq_tsum_field, ← re_to_complex, ← re_clm_apply, re_clm.map_tsum (exp_series_summable' (x : ℂ))]
refine tsum_congr (λ n, _)
rw [re_clm.map_smul, ← complex.of_real_pow, re_clm_apply, re_to_complex, complex.of_real_re, smul_eq_mul, one_div, mul_comm, div_eq_mul_inv]
set e := continuous_linear_equiv.of_finrank_eq (@finrank_fin_fun 𝕜 _ (finrank 𝕜 E)).symm
exact e.symm.antilipschitz.proper_space e.symm.continuous e.symm.surjective
have : x = 0 := subsingleton.elim _ _
subst this
simpa using f.le_op_norm 0
refine le_antisymm (by simpa using f.le_op_norm 0) _
have : ∥continuous_multilinear_map.curry0 𝕜 G (f.uncurry0)∥ ≤ ∥f.uncurry0∥ := continuous_multilinear_map.op_norm_le_bound _ (norm_nonneg _) (λm, by simp [-continuous_multilinear_map.apply_zero_curry0])
simp [-continuous_multilinear_map.apply_zero_curry0]
simpa
simpa only [prod_apply, prod.norm_def, max_mul_of_nonneg, H] using max_le_max (f.le_op_norm m) (g.le_op_norm m)
refine (continuous_multilinear_map.pi_field_equiv_aux 𝕜 ι G).to_linear_map.continuous_of_bound (1 : ℝ) (λz, _)
rw one_mul
change ∥continuous_multilinear_map.mk_pi_field 𝕜 ι z∥ ≤ ∥z∥
exact multilinear_map.mk_continuous_norm_le _ (norm_nonneg _) _
refine (continuous_multilinear_map.pi_field_equiv_aux 𝕜 ι G).symm.to_linear_map.continuous_of_bound (1 : ℝ) (λf, _)
rw one_mul
change ∥f (λi, 1)∥ ≤ ∥f∥
apply @continuous_multilinear_map.unit_le_op_norm 𝕜 ι (λ (i : ι), 𝕜) G _ _ _ _ _ _ _ f
simp [pi_norm_le_iff zero_le_one, le_refl]
rw [comp_assoc, hf, ← comp_assoc, hf', comp_assoc]
rintro rfl x
rintro rfl x; refl
refl
refine le_antisymm _ _
apply op_norm_le_bound _ (mul_nonneg (norm_nonneg _) (norm_nonneg _)) (λx, _)
calc ∥(c x) • f∥ = ∥c x∥ * ∥f∥ : norm_smul _ _ ... ≤ (∥c∥ * ∥x∥) * ∥f∥ : mul_le_mul_of_nonneg_right (le_op_norm _ _) (norm_nonneg _) ... = ∥c∥ * ∥f∥ * ∥x∥ : by ring
ring
{ apply op_norm_le_bound _ (mul_nonneg (norm_nonneg _) (norm_nonneg _)) (λx, _), calc ∥(c x) • f∥ = ∥c x∥ * ∥f∥ : norm_smul _ _ ... ≤ (∥c∥ * ∥x∥) * ∥f∥ : mul_le_mul_of_nonneg_right (le_op_norm _ _) (norm_nonneg _) ... = ∥c∥ * ∥f∥ * ∥x∥ : by ring }
by_cases h : f = 0
{ simp [h] }
simp [h]
have : 0 < ∥f∥ := norm_pos_iff.2 h
rw ← le_div_iff this
apply op_norm_le_bound _ (div_nonneg (norm_nonneg _) (norm_nonneg f)) (λx, _)
rw [div_mul_eq_mul_div, le_div_iff this]
calc ∥c x∥ * ∥f∥ = ∥c x • f∥ : (norm_smul _ _).symm ... = ∥smul_right c f x∥ : rfl ... ≤ ∥smul_right c f∥ * ∥x∥ : le_op_norm _ _
haveI := normed_algebra.nontrivial 𝕜 𝕜'; exact (lmulₗᵢ 𝕜 𝕜').norm_to_continuous_linear_map
exact (lmulₗᵢ 𝕜 𝕜').norm_to_continuous_linear_map
haveI := normed_algebra.nontrivial 𝕜 𝕜'
exact norm_smul _ _
rw mul_comm
obtain ⟨x, hx⟩ : ∃ (x : E), x ≠ 0 := exists_ne 0
rw ← norm_pos_iff at hx
simpa only [hf, hx, zero_le_mul_right] using norm_nonneg (f x)
have ha : 0 ≤ a
apply le_antisymm (f.op_norm_le_bound ha (λ y, le_of_eq (hf y)))
simpa only [hf, hx, mul_le_mul_right] using f.le_op_norm x
simp [inner_def, mul_comm]
simp only [inner_def, add_mul, add_re]
simp [inner_def]
simp; exact real.cos_nonneg_of_mem_Icc hx₃
exact real.cos_nonneg_of_mem_Icc hx₃
simp
rw [arg, if_pos hx₄]; simp [abs_cos_add_sin_mul_I, sin_of_real_re, real.arcsin_sin hx₃.1 hx₃.2]
rw [arg, if_pos hx₄]
simp [abs_cos_add_sin_mul_I, sin_of_real_re, real.arcsin_sin hx₃.1 hx₃.2]
simpa
rw ← real.cos_neg
rw ← real.cos_neg; apply real.cos_neg_of_pi_div_two_lt_of_lt; linarith
rw ← real.cos_neg; apply real.cos_neg_of_pi_div_two_lt_of_lt
linarith
linarith
apply real.cos_neg_of_pi_div_two_lt_of_lt
simpa
apply real.sin_neg_of_neg_of_neg_pi_lt; linarith
linarith
linarith
apply real.sin_neg_of_neg_of_neg_pi_lt
rw [arg, if_neg hx₅, if_neg hx₆]; simpa [sub_eq_add_neg, add_comm, abs_cos_add_sin_mul_I, sin_of_real_re]
rw [arg, if_neg hx₅, if_neg hx₆]
simpa [sub_eq_add_neg, add_comm, abs_cos_add_sin_mul_I, sin_of_real_re]
rw [← real.arcsin_neg, ← real.sin_add_pi, real.arcsin_sin]; try {simp [add_left_comm]}; linarith
rw [← real.arcsin_neg, ← real.sin_add_pi, real.arcsin_sin]; try {simp [add_left_comm]}
try {simp [add_left_comm]}
try {simp [add_left_comm]}
try {simp [add_left_comm]}
rw [← real.arcsin_neg, ← real.sin_add_pi, real.arcsin_sin]
simp [add_left_comm]
linarith
linarith
cases not_and_distrib.1 hx₃
cases not_and_distrib.1 hx₃; linarith
linarith
linarith
simpa
apply real.cos_neg_of_pi_div_two_lt_of_lt
apply real.cos_neg_of_pi_div_two_lt_of_lt; linarith
linarith
linarith
simpa
apply real.sin_nonneg_of_nonneg_of_le_pi; linarith
linarith
linarith
apply real.sin_nonneg_of_nonneg_of_le_pi
rw [arg, if_neg hx₆, if_pos hx₇]; simpa [sub_eq_add_neg, add_comm, abs_cos_add_sin_mul_I, sin_of_real_re]
rw [arg, if_neg hx₆, if_pos hx₇]
simpa [sub_eq_add_neg, add_comm, abs_cos_add_sin_mul_I, sin_of_real_re]
rw [← real.sin_pi_sub, real.arcsin_sin]; simp [sub_eq_add_neg]; linarith
rw [← real.sin_pi_sub, real.arcsin_sin]; simp [sub_eq_add_neg]
simp [sub_eq_add_neg]
simp [sub_eq_add_neg]
simp [sub_eq_add_neg]
rw [← real.sin_pi_sub, real.arcsin_sin]
linarith
linarith
simp [arg, zero_le_one]
have H : ∀ d e, 0 < d → tendsto (λ (x:ℝ), x^n / (d * (exp x) + e)) at_top (𝓝 0)
intros b' c' h
convert (tendsto_mul_exp_add_div_pow_at_top b' c' n h hn).inv_tendsto_at_top
ext x
{ intros b' c' h, convert (tendsto_mul_exp_add_div_pow_at_top b' c' n h hn).inv_tendsto_at_top , ext x, simpa only [pi.inv_apply] using inv_div.symm }
simpa only [pi.inv_apply] using inv_div.symm
cases lt_or_gt_of_ne hb
{ exact H b c h }
exact H b c h
convert (H (-b) (-c) (neg_pos.mpr h)).neg
ext x
field_simp
{ ext x, field_simp, rw [← neg_add (b * exp x) c, neg_div_neg_eq] }
rw [← neg_add (b * exp x) c, neg_div_neg_eq]
exact neg_zero.symm
by_cases h : 0 ≤ P.leading_coeff/Q.leading_coeff
exact tendsto_abs_at_top_at_top.comp (P.div_tendsto_at_top_of_degree_gt Q hdeg hQ h)
{ exact tendsto_abs_at_top_at_top.comp (P.div_tendsto_at_top_of_degree_gt Q hdeg hQ h) }
push_neg at h
exact tendsto_abs_at_bot_at_top.comp (P.div_tendsto_at_bot_of_degree_gt Q hdeg hQ h.le)
rw [←real.log_lt_log_iff hx (real.rpow_pos_of_pos hy z), real.log_rpow hy]
simpa only [(∘), div_eq_inv_mul, mul_one] using (has_deriv_at_sqrt hx).comp_has_deriv_within_at x hf
simp
have : (2 : ℝ) ≠ 0 := two_ne_zero
rw [div_eq_iff_mul_eq this]
symmetry
symmetry
rw [sqrt_two_add_series, sqrt_eq_iff_sq_eq, mul_pow, cos_sq, ←mul_div_assoc, nat.add_succ, pow_succ, mul_div_mul_left _ _ this, cos_pi_over_two_pow, add_mul]
norm_num
{ norm_num }
congr
rw [mul_comm, sq, mul_assoc, ←mul_div_assoc, mul_div_cancel_left, ←mul_div_assoc, mul_div_cancel_left]
rw [mul_comm, sq, mul_assoc, ←mul_div_assoc, mul_div_cancel_left, ←mul_div_assoc, mul_div_cancel_left]; try { exact this }
try { exact this }
exact this
norm_num
apply sqrt_two_add_series_zero_nonneg
apply add_nonneg
norm_num
apply cos_pos_of_mem_Ioo ⟨_, _⟩
apply le_of_lt
rw neg_lt_zero
apply pi_div_two_pos
transitivity (0 : ℝ)
apply pow_pos
norm_num
{ transitivity (0 : ℝ), rw neg_lt_zero, apply pi_div_two_pos, apply div_pos pi_pos, apply pow_pos, norm_num }
apply div_pos pi_pos
apply div_lt_div' (le_refl π) _ pi_pos _
refine lt_of_le_of_lt (le_of_eq (pow_one _).symm) _
norm_num
apply nat.succ_lt_succ
apply nat.succ_pos
apply pow_lt_pow
all_goals {norm_num}
congr
norm_num
simp
transitivity sin (π / 2 ^ 2)
congr
norm_num
simp
transitivity cos (π / 2 ^ 4)
rcases em (x = -1) with (rfl|h')
convert (has_deriv_within_at_const _ _ (-(π / 2))).congr _ _
convert (has_deriv_within_at_const _ _ (-(π / 2))).congr _ _; simp [arcsin_of_le_neg_one] { contextual := tt }
{ convert (has_deriv_within_at_const _ _ (-(π / 2))).congr _ _; simp [arcsin_of_le_neg_one] { contextual := tt } }
simp [arcsin_of_le_neg_one] { contextual := tt }
simp [arcsin_of_le_neg_one] { contextual := tt }
simp [arcsin_of_le_neg_one] { contextual := tt }
exact (has_deriv_at_arcsin h' h).has_deriv_within_at
simpa only [pow_zero, div_eq_mul_inv, ennreal.inv_one, mul_one] using edist_le_of_edist_le_geometric_two_of_tendsto C hu ha 0
simp [dist_eq_norm, sum_range_succ]
refine summable_of_nonneg_of_le (λ a, one_div_nonneg.mpr (pow_nonneg (zero_le_one.trans hm.le) _)) (λ a, _) (summable_geometric_of_lt_1 (one_div_nonneg.mpr (zero_le_one.trans hm.le)) ((one_div_lt (zero_lt_one.trans hm) zero_lt_one).mpr (one_div_one.le.trans_lt hm)))
rw [div_pow, one_pow]
refine (one_div_le_one_div _ _).mpr (pow_le_pow hm.le (fi a))
refine (one_div_le_one_div _ _).mpr (pow_le_pow hm.le (fi a)); exact pow_pos (zero_lt_one.trans hm) _
exact pow_pos (zero_lt_one.trans hm) _
exact pow_pos (zero_lt_one.trans hm) _
apply_instance
rw [add_def, comp_sub, neg_def, comp_sub, comp_zero, add_def, neg_def]
rw ←hp at hpbar
exact hpbar
dsimp at comm
rw [category.assoc, comm]
apply category.comp_id
dsimp
ext x f
apply L.map_injective
simp
dsimp
ext x f
simp only [adjunction.hom_equiv_counit, preimage_comp, preimage_map, category.assoc]
rw ←h.unit_naturality
simp
let := adjunction.right_adjoint_of_nat_iso comm
exactI adjoint_triangle_lift Q (adjunction.of_right_adjoint V)
erw [← adj.hom_equiv_naturality_right_symm, ← t.naturality, category.id_comp, category.id_comp]
apply functor.ext
tidy
apply functor.ext
tidy
cases h
refl
cases h
rw [uncurry_eq, prod_map_pre_app_comp_ev]
rw [pre, pre, pre, transfer_nat_trans_self_comp, prod.functor.map_comp]
apply_instance
rw ← frobenius_morphism_mate F h
cases G with G_obj _ _ _
cases F with F_obj _ _ _
ext X
ext X; apply h_obj
apply h_obj
have : F_obj = G_obj
subst this
congr
funext X Y f
exact eq_of_heq (h_map X Y f)
cases p; simp
simp
cases p
simp only [cancel_mono]
classical
let O := (finset.univ.image F.obj)
let H : finset (Σ' (X Y : C) (mX : X ∈ O) (mY : Y ∈ O), X ⟶ Y) := finset.univ.bUnion (λ X : J, finset.univ.bUnion (λ Y : J, finset.univ.image (λ f : X ⟶ Y, ⟨F.obj X, F.obj Y, by simp, by simp, F.map f⟩)))
simp
simp
obtain ⟨Z, f, w⟩ := sup_exists O H
simp
refine ⟨⟨Z, ⟨λ X, f (by simp), _⟩⟩⟩
intros j j' g
dsimp
simp only [category.comp_id]
apply w
simp only [finset.mem_univ, finset.mem_bUnion, exists_and_distrib_left, exists_prop_of_true, finset.mem_image]
simp
exact ⟨j, rfl, j', g, (by simp)⟩
simp [←nat_iso.naturality_1 α]
ext X
rw [←cancel_mono (α.app X), ←comp_app, eq, comp_app]
simp
simp
subst h
dsimp
simp
subst h
simp
have w := h {j | F j = F j₀} rfl (λ _ _ f, by simp [a f])
simp [a f]
dsimp at w
intros j j'
rw [w j, w j']
have z : ∀ (j : J), r (classical.arbitrary J) j := induct_on_objects (λ k, r (classical.arbitrary J) k) (hr.1 (classical.arbitrary J)) (λ _ _ f, ⟨λ t, hr.2.2 t (h f), λ t, hr.2.2 t (hr.2.1 (h f))⟩)
apply hr.2.2 (hr.2.1 (z _)) (z _)
intros
ext j
apply nat_trans_from_is_connected f (classical.arbitrary J) j
apply c.w (wide_pullback_shape.hom.term j)
refine ⟨j, rfl, _⟩
simp only [heq_iff_eq]
exact ⟨rfl, rfl, rfl⟩
have gH : ∀ j, (⟨ky, k j, kyO, kjO j, g j⟩ : (Σ' (X Y : K) (mX : X ∈ O) (mY : Y ∈ O), X ⟶ Y)) ∈ H := λ j, (finset.mem_union.mpr (or.inr begin simp only [true_and, finset.mem_univ, eq_self_iff_true, exists_prop_of_true, finset.mem_image, heq_iff_eq], refine ⟨j, rfl, _⟩, simp only [heq_iff_eq], exact ⟨rfl, rfl, rfl⟩, end))
simp only [true_and, finset.mem_univ, eq_self_iff_true, exists_prop_of_true, finset.mem_image, heq_iff_eq]
refine ⟨j, rfl, _⟩
simp only [heq_iff_eq]
exact ⟨rfl, rfl, rfl⟩
apply colimit_sound' (T kxO) (T kyO)
ext
simp only [functor.comp_map, limit.map_π_apply, curry.obj_map_app, swap_map]
rw ←W _ _ (fH j)
rw ←W _ _ (gH j)
simp [w]
classical
intros x y h
obtain ⟨kx, x, rfl⟩ := jointly_surjective' x
obtain ⟨ky, y, rfl⟩ := jointly_surjective' y
dsimp at x y
replace h := λ j, congr_arg (limit.π ((curry.obj F) ⋙ colim) j) h
simp [colimit_eq_iff] at h
let k := λ j, (h j).some
let f : Π j, kx ⟶ k j := λ j, (h j).some_spec.some
let g : Π j, ky ⟶ k j := λ j, (h j).some_spec.some_spec.some
have w : Π j, F.map ((𝟙 j, f j) : (j, kx) ⟶ (j, k j)) (limit.π ((curry.obj (swap K J ⋙ F)).obj kx) j x) = F.map ((𝟙 j, g j) : (j, ky) ⟶ (j, k j)) (limit.π ((curry.obj (swap K J ⋙ F)).obj ky) j y) := λ j, (h j).some_spec.some_spec.some_spec
let O : finset K := (finset.univ).image k ∪ {kx, ky}
have kxO : kx ∈ O := finset.mem_union.mpr (or.inr (by simp))
simp
have kyO : ky ∈ O := finset.mem_union.mpr (or.inr (by simp))
simp
have kjO : ∀ j, k j ∈ O := λ j, finset.mem_union.mpr (or.inl (by simp))
simp
let H : finset (Σ' (X Y : K) (mX : X ∈ O) (mY : Y ∈ O), X ⟶ Y) := (finset.univ).image (λ j : J, ⟨kx, k j, kxO, finset.mem_union.mpr (or.inl (by simp)), f j⟩) ∪ (finset.univ).image (λ j : J, ⟨ky, k j, kyO, finset.mem_union.mpr (or.inl (by simp)), g j⟩)
simp
obtain ⟨S, T, W⟩ := is_filtered.sup_exists O H
have fH : ∀ j, (⟨kx, k j, kxO, kjO j, f j⟩ : (Σ' (X Y : K) (mX : X ∈ O) (mY : Y ∈ O), X ⟶ Y)) ∈ H := λ j, (finset.mem_union.mpr (or.inl begin simp only [true_and, finset.mem_univ, eq_self_iff_true, exists_prop_of_true, finset.mem_image, heq_iff_eq], refine ⟨j, rfl, _⟩, simp only [heq_iff_eq], exact ⟨rfl, rfl, rfl⟩, end))
simp only [true_and, finset.mem_univ, eq_self_iff_true, exists_prop_of_true, finset.mem_image, heq_iff_eq]
dsimp [limit_uncurry_iso_limit_comp_lim, is_limit.cone_point_unique_up_to_iso, is_limit.unique_up_to_iso]
simp
refl
erw is_limit.fac
intro F
apply has_limit_of_equivalence_comp e
apply_instance
constructor
dsimp [colimit.iso_colimit_cocone, is_colimit.cocone_point_unique_up_to_iso]
tidy
apply G.map_injective
apply G.map_injective; rw [G.map_comp, h]; apply ht.fac
apply G.map_injective; rw [G.map_comp, h]
rw [G.map_comp, h]
apply ht.fac
rw h
apply G.map_injective
refine ht.uniq (G.map_cone s) _ (λ j, _)
convert ←congr_arg (λ f, G.map f) (w j)
apply G.map_comp
have h := cocone_fac h s
cases s
injection h with h₁ h₂
simp only [heq_iff_eq] at h₂
rw ← h₂
refl
conv_rhs { rw ← h₂ }
rw ←hom_of_cocone_of_hom h m
congr
rw cocone_of_hom_fac
cases s
congr' with j
exact w j
dsimp [cocone.extend]
exactI { has_limit := λ F, has_limit.mk (limit_cone F) }
intros
cases a
cases b
congr
split
apply is_colimit.of_point_iso (colimit.is_colimit F)
change is_iso ((cocones.forget _).map ((colimit.is_colimit F).desc_cocone_morphism c))
apply (cocones.forget F).map_is_iso _
apply is_iso_of_reflects_iso _ (cocones.functoriality F G)
refine (is_colimit_of_preserves G (colimit.is_colimit F)).hom_is_iso t _
simp [← G.map_comp]
ext
apply preserves_limit_of_preserves_limit_cone (prod_is_prod X Y)
apply (is_limit_map_cone_binary_fan_equiv _ _ _).symm _
apply is_limit.of_point_iso (limit.is_limit (pair (G.obj X) (G.obj Y)))
apply i
apply is_colimit.of_point_iso (colimit.is_colimit (functor_to_representables P))
change is_iso (colimit.desc _ (cocone.extend _ _))
rw [colimit.desc_extend, colimit.desc_cocone]
apply_instance
tidy
simp
simp
simp
ext
ext; simp
simp
simp
ext
cases j; refl
refl
refl
cases j
rw [t.app_zero_left, t.app_zero_right]
rw [←fork.app_zero_left, reassoc_of h]
simp only [←G.map_comp, w]
simp [← G.map_comp]
ext
haveI := @has_finite_wide_pushouts.out C _ _ J (classical.dec_eq _)
apply_instance
exactI has_finite_limits.out _
simp [image.comp_iso]
ext
rw [←fork.app_zero_left, kernel_fork.condition]
apply_instance
exact w
apply colimit.w (wide_pushout_shape.wide_span _ _ _) (wide_pushout_shape.hom.init j)
refl
simp
rw [←w]
simp
equiv_rw (is_limit_equiv_sections t).symm at x
simp
simp
simp
rw [is_iso.eq_comp_inv f.f, category.assoc, ← f.h]
simp
tidy
ext1
dsimp
rw [comp_id]
apply c.w
rw [←triangle_assoc_comp_left, iso.inv_hom_id_assoc]
rintros X Y f
apply quotient.induction_on f
intro f
ext n
induction f generalizing n
simp only [mk_id, functor.map_id, category.id_comp, category.comp_id]
{ simp only [mk_id, functor.map_id, category.id_comp, category.comp_id] }
dsimp
simp only [id_tensor_associator_inv_naturality_assoc, ←pentagon_inv_assoc, tensor_hom_inv_id_assoc, tensor_id, category.id_comp, discrete.functor_map_id, comp_tensor_id, iso.cancel_iso_inv_left, category.assoc]
simp only [category.comp_id]
{ dsimp, simp only [id_tensor_associator_inv_naturality_assoc, ←pentagon_inv_assoc, tensor_hom_inv_id_assoc, tensor_id, category.id_comp, discrete.functor_map_id, comp_tensor_id, iso.cancel_iso_inv_left, category.assoc], dsimp, simp only [category.comp_id] }
dsimp
dsimp
simp only [discrete.functor_map_id, comp_tensor_id, category.assoc, pentagon_inv_assoc, ←associator_inv_naturality_assoc, tensor_id, iso.cancel_iso_inv_left]
simp only [category.comp_id]
{ dsimp, simp only [discrete.functor_map_id, comp_tensor_id, category.assoc, pentagon_inv_assoc, ←associator_inv_naturality_assoc, tensor_id, iso.cancel_iso_inv_left], dsimp, simp only [category.comp_id],}
dsimp
dsimp
rw triangle_assoc_comp_right_assoc
simp only [discrete.functor_map_id, category.assoc]
simp only [category.comp_id]
{ dsimp, rw triangle_assoc_comp_right_assoc, simp only [discrete.functor_map_id, category.assoc], dsimp, simp only [category.comp_id] }
dsimp
dsimp
simp only [triangle_assoc_comp_left_inv_assoc, inv_hom_id_tensor_assoc, tensor_id, category.id_comp, discrete.functor_map_id]
simp only [category.comp_id]
{ dsimp, simp only [triangle_assoc_comp_left_inv_assoc, inv_hom_id_tensor_assoc, tensor_id, category.id_comp, discrete.functor_map_id], dsimp, simp only [category.comp_id] }
dsimp
dsimp
rw [←(iso.inv_comp_eq _).2 (right_unitor_tensor _ _), category.assoc, ←right_unitor_naturality]
simp only [discrete.functor_map_id, iso.cancel_iso_inv_left, category.assoc]
simp only [category.comp_id]
{ dsimp, rw [←(iso.inv_comp_eq _).2 (right_unitor_tensor _ _), category.assoc, ←right_unitor_naturality], simp only [discrete.functor_map_id, iso.cancel_iso_inv_left, category.assoc], dsimp, simp only [category.comp_id] }
dsimp
dsimp
simp only [←(iso.eq_comp_inv _).1 (right_unitor_tensor_inv _ _), iso.hom_inv_id_assoc, right_unitor_conjugation, discrete.functor_map_id, category.assoc]
simp only [category.comp_id]
{ dsimp, simp only [←(iso.eq_comp_inv _).1 (right_unitor_tensor_inv _ _), iso.hom_inv_id_assoc, right_unitor_conjugation, discrete.functor_map_id, category.assoc], dsimp, simp only [category.comp_id], }
dsimp
dsimp at *
rw [id_tensor_comp, category.assoc, f_ih_g ⟦f_g⟧, ←category.assoc, f_ih_f ⟦f_f⟧, category.assoc, ←functor.map_comp]
{ dsimp at *, rw [id_tensor_comp, category.assoc, f_ih_g ⟦f_g⟧, ←category.assoc, f_ih_f ⟦f_f⟧, category.assoc, ←functor.map_comp], congr' 2 }
congr' 2
dsimp at *
rw associator_inv_naturality_assoc
rw [←tensor_comp, f_ih_f ⟦f_f⟧]
slice_lhs 2 3 { rw [←tensor_comp, f_ih_f ⟦f_f⟧] }
rw [←@category.id_comp (F C) _ _ _ ⟦f_g⟧]
conv_lhs { rw [←@category.id_comp (F C) _ _ _ ⟦f_g⟧] }
simp only [category.comp_id, tensor_comp, category.assoc]
congr' 2
rw [←mk_tensor, quotient.lift_mk]
dsimp
rw [functor.map_comp, ←category.assoc, ←f_ih_g ⟦f_g⟧, ←@category.comp_id (F C) _ _ _ ⟦f_g⟧, ←category.id_comp ((discrete.functor inclusion_obj).map _), tensor_comp]
dsimp
simp only [category.assoc, category.comp_id]
congr' 1
convert (normalize_iso_aux C f_Z).hom.naturality ((normalize_map_aux f_f).app n)
exact (tensor_func_obj_map _ _ _).symm
rw [←functor.id_map f, ←functor.id_map g]
simp [←nat_iso.naturality_2 (full_normalize_iso.{u} C), this]
rw [iso.inv_comp_eq, F.left_unitality, category.assoc, category.assoc, ←F.to_functor.map_comp, iso.hom_inv_id, F.to_functor.map_id, comp_id]
apply Q.hom_ext
rintro ⟨⟩
apply P.hom_ext
rintro ⟨⟩
{ apply P.hom_ext, rintro ⟨⟩, }
simp
dsimp [tensor_hom]
simp
simp only [left_adjoint_mate, monoidal_category.tensor_id, category.id_comp, evaluation_coevaluation_assoc, category.comp_id, iso.inv_hom_id]
tidy
tidy
tidy
tidy
tidy
ext
dsimp
simp
tidy
ext
dsimp
simp
ext
ext; simp
simp
simp
simp
simp
rintros _ _ ⟨_, _, _, _, _, _, h⟩
simp [H _ _ _ _ h]
rintros a b c ⟨f⟩ ⟨g⟩
exact F.map_comp f g
rw ← J₂.close_eq_top_iff_mem
have : J₂.is_closed (⊤ : sieve X)
intros Y f hf
{ intros Y f hf, trivial }
trivial
suffices : (⟨J₂.close S, J₂.close_is_closed S⟩ : subtype _) = ⟨⊤, this⟩
rw subtype.ext_iff at this
{ rw subtype.ext_iff at this, exact this }
exact this
apply (h S hS).is_separated_for.ext
intros Y f hf
ext1
dsimp
rw [sieve.pullback_top, ← J₂.pullback_close, S.pullback_eq_top_of_mem hf, J₂.close_eq_top_iff_mem]
apply J₂.top_mem
rintro ⟨Z, g, i, rfl⟩
refine ⟨pullback g f, pullback.snd, _, _⟩
refine ⟨⟨pullback.lift (f ≫ inv g) (𝟙 _) (by simp), ⟨_, by tidy⟩⟩⟩
simp
tidy
resetI
apply pullback.hom_ext
rw [assoc, pullback.lift_fst, ←pullback.condition_assoc]
{ rw [assoc, pullback.lift_fst, ←pullback.condition_assoc], simp }
simp
{ resetI, refine ⟨⟨pullback.lift (f ≫ inv g) (𝟙 _) (by simp), ⟨_, by tidy⟩⟩⟩, apply pullback.hom_ext, { rw [assoc, pullback.lift_fst, ←pullback.condition_assoc], simp }, { simp } }
simp
apply pullback_singleton
rintro X S Ti ⟨Z, g, i, rfl⟩ hS
rcases hS g (singleton_self g) with ⟨Y, f, i, hTi⟩
refine ⟨_, f ≫ g, _, _⟩
apply_instance
{ resetI, apply_instance }
resetI
ext W k
split
rintro ⟨V, h, k, ⟨_⟩, hh, rfl⟩
rw hTi at hh
cases hh
{ rintro ⟨V, h, k, ⟨_⟩, hh, rfl⟩, rw hTi at hh, cases hh, apply singleton.mk }
apply singleton.mk
rintro ⟨_⟩
refine bind_comp g presieve.singleton.mk _
rw hTi
apply presieve.singleton.mk
rw ← is_separated_for_and_exists_is_amalgamation_iff_sheaf_for
exact and.intro t
rw ← generate_of_singleton_split_epi (𝟙 X)
rw ← is_sheaf_for_iff_generate
apply is_sheaf_for_singleton_iso
apply quotient.induction_on' x
intro t
apply quotient.sound
refine ⟨(mono_over.map_comp _ _).app t⟩
simp [hu]
simp [hu]
rcases j with ⟨-, ⟨g, ⟨m, rfl⟩⟩⟩
simpa using m
tidy
simp
rw ←image_subobject_arrow
simp [equalizer_subobject_iso]
apply over.hom_mk (factor_thru_image f.hom ≫ k.left) _
change (factor_thru_image f.hom ≫ k.left) ≫ _ = f.hom
rw [assoc, over.w k]
apply image.fac
refine over.hom_mk _ _
refine image.lift {I := g.val.left, m := g.arrow, e := k.left, fac' := over.w k}
apply image.lift_fac
ext1
change factor_thru_image _ ≫ image.lift _ = _
rw [← cancel_mono g.arrow, assoc, image.lift_fac, image.fac f.hom]
exact (over.w k).symm
apply_instance
change F.repr_f.app X f = (F.repr_f.app (op F.repr_X) ≫ F.map f.op) (𝟙 F.repr_X)
rw ←F.repr_f.naturality
dsimp
simp
tidy
rw [le_iff_le_iff_lt_iff_lt, sdiff_lt_sdiff_iff_lt]
rw [nat.sub_lt_right_iff_lt_add, add_comm, ← size_up_to_succ']
{ exact lt_size_up_to_index_succ _ _ }
exact lt_size_up_to_index_succ _ _
exact size_up_to_index_le _ _
rw [comp_cons, nil_comp]
have hh := card_image_of_injective univ (G.dart_of_neighbor_set_injective v)
rw [finset.card_univ, card_neighbor_set_eq_degree] at hh
rwa dart_fst_fiber
ext a
split
rintro ( ⟨ _, _, h ⟩ | ⟨ _, _, _, h, _ ⟩ )
exact h
{ rintro ( ⟨ _, _, h ⟩ | ⟨ _, _, _, h, _ ⟩ ), exact h, cases h }
cases h
intro h
apply ε_NFA.ε_closure.base
exact h
simp [(<*>)]
simp [(<*>)]; exact ⟨λ ⟨n, h₁, h₂⟩, ⟨_, ⟨_, h₁, rfl⟩, by simpa using h₂⟩, λ ⟨_, ⟨n, h₁, rfl⟩, h₂⟩, ⟨_, h₁, by simpa using h₂⟩⟩
simp [part.bind_assoc, bind_some_eq_map]
cases f a; simp
simp
simp
cases f a
have a := (primrec.of_nat (ℕ × code)).comp list_length
have k := fst.comp a
refine option_some.comp (list_map (list_range.comp k) (_ : primrec _))
have n := snd
replace k := k.comp fst
refine nat_cases k (const none) (_ : primrec _)
have n := n.comp fst
have k := k.comp fst
have k' := snd
have c := snd.comp (a.comp $ fst.comp fst)
apply rec_prim c (const (some 0)) (option_some.comp (primrec.succ.comp n)) (option_some.comp (fst.comp $ primrec.unpair.comp n)) (option_some.comp (snd.comp $ primrec.unpair.comp n))
have L := (fst.comp fst).comp fst
have n := n.comp fst
have k := k.comp fst
have cf := fst.comp snd
have cg := (fst.comp snd).comp snd
exact option_bind (hlup.comp $ L.pair $ (k.pair cf).pair n) (option_map ((hlup.comp $ L.pair $ (k.pair cg).pair n).comp fst) (primrec₂.mkpair.comp (snd.comp fst) snd))
{ have L := (fst.comp fst).comp fst, have k := k.comp fst, have n := n.comp fst, have cf := fst.comp snd, have cg := (fst.comp snd).comp snd, exact option_bind (hlup.comp $ L.pair $ (k.pair cf).pair n) (option_map ((hlup.comp $ L.pair $ (k.pair cg).pair n).comp fst) (primrec₂.mkpair.comp (snd.comp fst) snd)) }
have L := (fst.comp fst).comp fst
have n := n.comp fst
have k := k.comp fst
have cf := fst.comp snd
have cg := (fst.comp snd).comp snd
exact option_bind (hlup.comp $ L.pair $ (k.pair cg).pair n) (hlup.comp ((L.comp fst).pair $ ((k.pair cf).comp fst).pair snd))
{ have L := (fst.comp fst).comp fst, have k := k.comp fst, have n := n.comp fst, have cf := fst.comp snd, have cg := (fst.comp snd).comp snd, exact option_bind (hlup.comp $ L.pair $ (k.pair cg).pair n) (hlup.comp ((L.comp fst).pair $ ((k.pair cf).comp fst).pair snd)) }
have L := (fst.comp fst).comp fst
have n := n.comp fst
have k := k.comp fst
have cf := fst.comp snd
have cg := (fst.comp snd).comp snd
have z := fst.comp (primrec.unpair.comp n)
refine nat_cases (snd.comp (primrec.unpair.comp n)) (hlup.comp $ L.pair $ (k.pair cf).pair z) (_ : primrec _)
have z := z.comp fst
have y := snd
have L := L.comp fst
refine option_bind (hlup.comp $ L.pair $ (((k'.pair c).comp fst).comp fst).pair (primrec₂.mkpair.comp z y)) (_ : primrec _)
have y := y.comp fst
have i := snd
have z := z.comp fst
exact hlup.comp ((L.comp fst).pair $ ((k.pair cg).comp $ fst.comp fst).pair $ primrec₂.mkpair.comp z $ primrec₂.mkpair.comp y i)
{ have L := (fst.comp fst).comp fst, have k := k.comp fst, have n := n.comp fst, have cf := fst.comp snd, have cg := (fst.comp snd).comp snd, have z := fst.comp (primrec.unpair.comp n), refine nat_cases (snd.comp (primrec.unpair.comp n)) (hlup.comp $ L.pair $ (k.pair cf).pair z) (_ : primrec _), have L := L.comp fst, have z := z.comp fst, have y := snd, refine option_bind (hlup.comp $ L.pair $ (((k'.pair c).comp fst).comp fst).pair (primrec₂.mkpair.comp z y)) (_ : primrec _), have z := z.comp fst, have y := y.comp fst, have i := snd, exact hlup.comp ((L.comp fst).pair $ ((k.pair cg).comp $ fst.comp fst).pair $ primrec₂.mkpair.comp z $ primrec₂.mkpair.comp y i) }
have L := (fst.comp fst).comp fst
have n := n.comp fst
have k := k.comp fst
have cf := fst.comp snd
have z := fst.comp (primrec.unpair.comp n)
have m := snd.comp (primrec.unpair.comp n)
refine option_bind (hlup.comp $ L.pair $ (k.pair cf).pair (primrec₂.mkpair.comp z m)) (_ : primrec _)
have m := m.comp fst
exact nat_cases snd (option_some.comp m) ((hlup.comp ((L.comp fst).pair $ ((k'.pair c).comp $ fst.comp fst).pair (primrec₂.mkpair.comp (z.comp fst) (primrec.succ.comp m)))).comp fst)
letI : ∀ a, decidable (a ∈ set.range (encode : α → ℕ)) := decidable_range_encode _
letI : ∀ a, decidable (a ∈ set.range (encode : α → ℕ)) := decidable_range_encode _; exact subtype_mk primrec.encode
exact subtype_mk primrec.encode
refl
{refl}
cases decode α n
simp [encodek]
haveI := primcodable.of_equiv α e; exact primrec e
exact primrec e
haveI := primcodable.of_equiv α e
letI : primcodable β := primcodable.of_equiv α e
letI : primcodable β := primcodable.of_equiv α e; exact encode_iff.1 primrec.encode
exact encode_iff.1 primrec.encode
intros; cases a; [refl, {cases b; refl}]
intros; cases a
cases a
refl
cases b
cases b; refl
refl
refl
intros
simp [primrec₂, primrec, this]
cases o a with b; simp [encodek]; refl
cases o a with b; simp [encodek]
simp [encodek]
simp [encodek]
cases o a with b
simp
induction c with generalizing k v; simp only [cont.then, step_normal, cfg.then, *] {constructor_eq := ff}
induction c with generalizing k v
simp only [cont.then, step_normal, cfg.then, *] {constructor_eq := ff}
simp only [cont.then, step_normal, cfg.then, *] {constructor_eq := ff}
simp only [cont.then, step_normal, cfg.then, *] {constructor_eq := ff}
simp only [cont.then, step_normal, cfg.then, *] {constructor_eq := ff}
simp only [cont.then, step_normal, cfg.then, *] {constructor_eq := ff}
simp only [cont.then, step_normal, cfg.then, *] {constructor_eq := ff}
simp only [cont.then, step_normal, cfg.then, *] {constructor_eq := ff}
case turing.to_partrec.code.cons : c c' ih ih' { rw [← ih, cont.then] }
rw [← ih, cont.then]
case turing.to_partrec.code.comp : c c' ih ih' { rw [← ih', cont.then] }
rw [← ih', cont.then]
cases v.head; simp only [nat.elim]
simp only [nat.elim]
simp only [nat.elim]
{ cases v.head; simp only [nat.elim] }
cases v.head
case turing.to_partrec.code.fix : c ih { rw [← ih, cont.then] }
rw [← ih, cont.then]
rintro _ _ ⟨i, rfl⟩
cases i
cases i; refl
refl
refl
{cases i; refl}
refl
cases a
simp only [list.nth_map, list_blank.map_mk, list_blank.nth_mk, list.inth]
intro l
exact f.2.symm
{exact f.2.symm}
refl
cases l.nth n
cases T; simp [tape.move]
simp [tape.move]
cases T
rcases trans_gen.head'_iff.1 h₁ with ⟨b', hab, hbc⟩
exact hbc
cases option.mem_unique hab h₂
refine { .. }; intros; cases x; refl
refine { .. }; intros; cases x
refine { .. }; intros
intros
intros
cases x
cases x
refl
refl
refl
refl
refine { .. }
refine {..}; intros; simp [functor.map] with functor_norm
refine {..}; intros
intros
intros
simp [functor.map] with functor_norm
simp [functor.map] with functor_norm
refine {..}
simp only [(∘), mfoldr.of_free_monoid, mfoldr.mk, flip, fold_mfoldr_cons]
ext
simp only [mfoldl, fold_map_map, (∘), flip]
apply funext; apply id_map
apply id_map
apply funext
dsimp [approx]
apply @bot_le _ _ (f ⊥)
induction i
apply f.monotone
apply i_ih
intro
simp [add_lsb,two_mul]
congr
cases b
cases b; refl
refl
refl
convert nat.lt_succ_of_lt h
simp
convert array.read_push_back_left _
simp
cases b
simp
convert array.read_push_back_right
cases b
tactic.mk_dec_eq_instance
contrapose! h
constructor
intros cb n hn
cases hp : p cb n
{ exact absurd hn (h _ _ _ _ hp).not_le }
exact absurd hn (h _ _ _ _ hp).not_le
simp [hp]
convert err_static.and_then_of_unfailing
{ exact h' _ }
exact h' _
convert unfailing.mmap'
exact h
rw [any_char_eq_fail, and.comm]
simp
dsimp [fix] at h
exact err_static.of_fail h
haveI := fix_core hF (cb.size - n + 1)
simp_rw bind_eq_done
rintro ⟨_, _, hp, hf⟩
exact (static.of_done hf) ▸ (of_done hp)
convert step.and_then
{ apply_instance }
apply_instance
exact static.pure
simp
simp_rw orelse_eq_done
rintro (h | ⟨h, -⟩)
rintro (h | ⟨h, -⟩); exact of_done h
exact of_done h
exact of_done h
cases hp : p cb n; simp [hp, ←bind_eq_bind, parser.bind, and_assoc]
simp [hp, ←bind_eq_bind, parser.bind, and_assoc]
simp [hp, ←bind_eq_bind, parser.bind, and_assoc]
cases hp : p cb n
simp [mmap, and.comm, and.assoc, and.left_comm, pure_eq_done]
by_cases hn : n < cb.size
by_cases hp : p (cb.read ⟨n, hn⟩)
simp only [sat, hn, hp, dif_pos, if_true, exists_prop_of_true]
split
simp [hp]
{ rintro ⟨rfl, rfl⟩, simp [hp] }
rintro ⟨rfl, rfl⟩
simp
{ simp only [sat, hn, hp, dif_pos, if_true, exists_prop_of_true], split, { rintro ⟨rfl, rfl⟩, simp [hp] }, { rintro ⟨-, rfl, rfl⟩, simp } }
rintro ⟨-, rfl, rfl⟩
simp only [sat, hn, hp, dif_pos, false_iff, not_and, exists_prop_of_true, if_false]
rintro H - rfl
{ by_cases hp : p (cb.read ⟨n, hn⟩), { simp only [sat, hn, hp, dif_pos, if_true, exists_prop_of_true], split, { rintro ⟨rfl, rfl⟩, simp [hp] }, { rintro ⟨-, rfl, rfl⟩, simp } }, { simp only [sat, hn, hp, dif_pos, false_iff, not_and, exists_prop_of_true, if_false], rintro H - rfl, exact hp H } }
exact hp H
simp [sat, hn]
simp [str_eq_char_buf, char_buf_eq_done]
simp only [sub_conj, of_real_mul, of_real_one, of_real_bit0, mul_right_comm, mul_div_cancel_left _ (mul_ne_zero two_ne_zero' I_ne_zero : 2 * I ≠ 0)]
simpa [re_add_im] using abs_add z.re (z.im * I)
rw ← of_real_inj; simp [sinh_add]
simp [sinh_add]
rw ← of_real_inj
rw ← of_real_inj; simp [cosh_two_mul]
simp [cosh_two_mul]
rw ← of_real_inj
rw [two_mul, sinh_add]
ring
rw [tan, sin_mul_I, cos_mul_I, mul_div_right_comm, tanh_eq_sinh_div_cosh]
simp [sub_eq_add_neg, sin_add, sin_neg, cos_neg]
rw [← of_real_sin_of_real_re, of_real_im]
rw [cos_two_mul', eq_sub_iff_add_eq.2 (sin_sq_add_cos_sq x), ← sub_add, sub_add_eq_add_sub, two_mul]
ring
have h1 : x + 2 * x = 3 * x
rw [← h1, cos_add x (2 * x)]
simp only [cos_two_mul, sin_two_mul, mul_add, mul_sub, mul_one, sq]
have h2 : 4 * cos x ^ 3 = 2 * cos x * cos x * cos x + 2 * cos x * cos x ^ 2
ring
rw [h2, cos_sq']
ring
rw [← of_real_inj]; simp [sin, sin_add]
simp [sin, sin_add]
rw [← of_real_inj]
rw [← of_real_inj, of_real_tan, tan_eq_sin_div_cos, of_real_div, of_real_sin, of_real_cos]
simp [tan]
norm_num
simp [bit0]
simp [bit1]
simp [bit0, ext_iff]
simp_rw conj_eq_re_sub_im
simp only [smul_re, smul_im, of_real_mul]
rw smul_sub
simp_rw of_real_alg
simp
by_cases h : (I : K) = 0
{ simp [h] }
simp [h]
field_simp [mul_assoc, I_mul_I_of_nonzero h]
simp only [←sqrt_norm_sq_eq_norm, norm_sq_conj]
rw [← of_real_rat_cast, of_real_re]
rwa [← of_real_nat_cast, of_real_eq_zero, nat.cast_eq_zero] at h
simp
ext i
fin_cases i
fin_cases i; simp
simp
simp
simp
simp
refine quotient.map₂ (λ x y, ⟨λ i, f i (x.1 i) (y.1 i), x.2 + y.2, λ i, _⟩) _
cases x.3 i with h1 h1
rw multiset.mem_add
left
exact h1
{ left, rw multiset.mem_add, left, exact h1 }
left
cases y.3 i with h2 h2
rw multiset.mem_add
right
exact h2
{ left, rw multiset.mem_add, right, exact h2 }
left
simp
rw [h1, h2, hf]
{ cases x.3 i with h1 h1, { left, rw multiset.mem_add, left, exact h1 }, cases y.3 i with h2 h2, { left, rw multiset.mem_add, right, exact h2 }, right, rw [h1, h2, hf] }
right
simp only [H1 i, H2 i]
exact λ x₁ x₂ H1 y₁ y₂ H2 i, by simp only [H1 i, H2 i]
simp only [smul_apply, smul_zero, zero_apply]
simp only [add_apply, smul_apply, smul_add]
simp only [smul_apply, one_smul]
simp only [smul_apply, smul_smul]
intro j
rcases eq_or_ne i j with rfl|hi
split_ifs with hb
{ simp [hb] }
simp [hb]
{ split_ifs with hb, { simp [hb] }, { simp } }
simp
cases x.zero j with hj hj
split_ifs; simp [multiset.mem_erase_of_ne hi.symm, hj]
split_ifs
{ split_ifs; simp [multiset.mem_erase_of_ne hi.symm, hj] }
simp [multiset.mem_erase_of_ne hi.symm, hj]
simp [multiset.mem_erase_of_ne hi.symm, hj]
simp [function.update_noteq hi.symm, hj]
rw (funext h : x.to_fun = y.to_fun)
by_cases h : i = j
ext j
simp [hb]
{ subst h, simp [hb] }
subst h
simp [ne.symm h, h]
exact prod_extend_right_apply_ne _ h _
contrapose! h
rw [list.map_map, e.symm_comp_self, list.map_id]
rw [list.map_map, e.self_comp_symm, list.map_id]
convert (h $ e.symm a).symm
exact (e.apply_symm_apply a).symm
ext ⟨b, a, has, rfl⟩
have : ∀(h : ∃a', a' ∈ s ∧ a' = a), classical.some h = a := λ h, (classical.some_spec h).2
simp [equiv.set.image, equiv.set.image_of_inj_on, hf.eq_iff, this]
simp
ext
rw [← equiv.trans_apply, equiv.swap_swap, equiv.refl_apply]
simp
rintros (⟨x,hx⟩|⟨x,hx⟩)
rintros (⟨x,hx⟩|⟨x,hx⟩); dsimp; [rw dif_pos, rw dif_neg]
rintros (⟨x,hx⟩|⟨x,hx⟩); dsimp
dsimp
dsimp
rw dif_pos
rw dif_neg
dsimp
split_ifs
split_ifs; refl
refl
refl
simp *
dsimp [directed.sequence]
generalize eq : hf.sequence f n = p
cases h : decode α n with a
{ exact (classical.some_spec (hf p p)).1 }
exact (classical.some_spec (hf p p)).1
exact (classical.some_spec (hf p a)).1
dsimp [fin_rotate]
rw fin_add_flip_apply_mk_right
simp
ext ⟨i, h⟩
by_cases h' : i < n
rw [fin_rotate_of_lt h', fin.snoc, fin.cons, dif_pos h']
{ rw [fin_rotate_of_lt h', fin.snoc, fin.cons, dif_pos h'], refl, }
refl
have h'' : n = i
exact (nat.eq_of_le_of_lt_succ h' h).symm
{ simp only [not_lt] at h', exact (nat.eq_of_le_of_lt_succ h' h).symm, }
simp only [not_lt] at h'
subst h''
rw [fin_rotate_last', fin.snoc, fin.cons, dif_neg (lt_irrefl _)]
refl
simp
split
rw [trans_source'', trans_source'', ← he.target_eq, ← hf.1]
exact (he.symm'.eq_on.mono $ inter_subset_left _ _).image_eq
{ rw [trans_source'', trans_source'', ← he.target_eq, ← hf.1], exact (he.symm'.eq_on.mono $ inter_subset_left _ _).image_eq }
assume x hx
rw trans_source at hx
simp [(he.2 hx.1).symm, hf.2 hx.2]
rw [he.eq_on.inter_preimage_eq, he.source_eq]
simp [ext_iff]
simp [ext_iff]
simp [ext_iff]
simp [ext_iff]
tauto
ext x
ext x; simp [ext_iff]; tauto
ext x; simp [ext_iff]
rw [← f.map_one, h₁]
simp
ext
resetI; apply e.injective.division_ring _; intros; exact e.apply_symm_apply _
resetI; apply e.injective.division_ring _; intros
resetI; apply e.injective.division_ring _
apply e.injective.division_ring _
intros
intros
intros
intros
intros
intros
intros
intros
resetI
exact e.apply_symm_apply _
exact e.apply_symm_apply _
exact e.apply_symm_apply _
exact e.apply_symm_apply _
exact e.apply_symm_apply _
exact e.apply_symm_apply _
exact e.apply_symm_apply _
exact e.apply_symm_apply _
dsimp [pred_above]
split_ifs with ha hb hb
simp only [le_iff_coe_le_coe, coe_pred]
simp only [le_iff_coe_le_coe, coe_pred]
simp only [le_iff_coe_le_coe, coe_pred]
simp only [le_iff_coe_le_coe, coe_pred]
all_goals { simp only [le_iff_coe_le_coe, coe_pred] }
{ exact pred_le _, }
exact pred_le _
have : b < a := cast_succ_lt_cast_succ_iff.mpr (hb.trans_le (le_of_not_gt ha))
exact absurd H this.not_le
have : i ≤ (last n).cast_succ := h.trans p.le_last
simp [pred_above, cast_pred, h.not_lt, this.not_lt]
rcases i.le_last.eq_or_lt with rfl|h
{ simp }
simp
rw [cast_pred, pred_above, dif_neg]
{ simp }
simp
simpa [lt_iff_coe_lt_coe, le_iff_coe_le_coe, lt_succ_iff] using h
simp [snoc]
ext j
by_cases h : j = i
simp [init]
{ rw h, simp [init] }
rw h
simp [init, h]
simp [eq_iff_veq, add_def, mod_eq_of_lt (is_lt k)]
simp [eq_iff_veq]
refl
cases j
simp *
simp only [erase_erase, erase_to_finmap]
simp only [mem_inter, mem_filter, and.right_comm]
ext
rw [multiset.mem_to_finset, ←mem_def]
ext
rcases to_finset_surj_on (set.mem_univ s) with ⟨l, -, hls⟩
intro s
exact ⟨l, hls⟩
rw [mem_filter, mem_image]
ext
simp only [and_imp, exists_prop, and_iff_right_iff_imp, exists_imp_distrib]
exact h _ xel
rintros x xel rfl
push_neg
exact card_le_one
rw ← not_iff_not
simpa only [mem_range]
simpa only [mem_range]
ext
simp only [finset.mem_bUnion, exists_prop]
simp_rw [←exists_and_distrib_right, ←exists_and_distrib_left, and_assoc]
rw exists_comm
apply_instance
suffices : (diag s).card + (off_diag s).card = s.card * s.card
finish
{ nth_rewrite 2 ← s.diag_card, finish, }
nth_rewrite 2 ← s.diag_card
rw ← card_product
apply filter_card_add_filter_neg_card_eq_card
rw [insert_val, ndinsert_of_not_mem h]
simp only [mem_union, or_comm]
by_cases n ≤ k
simp [h, and_comm]
simp [h, and_comm]
ext k
ext k; by_cases n ≤ k; simp [h, and_comm]
ext k; by_cases n ≤ k
simp at hb
simp at hb; simp [hb]
simp [hb]
simp [@forall_swap _ β]
classical
induction s using finset.induction_on with x s hx IH generalizing n
{ simpa using h }
simpa using h
cases n
{ simp }
simp
rw [card_insert_of_not_mem hx, nat.succ_lt_succ_iff] at h
rw powerset_len_succ_insert hx
refine nonempty.mono _ ((IH h).image (insert x))
convert (subset_union_right _ _)
refine ext (λ a, ⟨λ ha, _, λ ha, _ ⟩)
rw mem_bUnion
exact ⟨a.card, mem_range.mpr (nat.lt_succ_of_le (card_le_of_subset (mem_powerset.mp ha))), mem_powerset_len.mpr ⟨mem_powerset.mp ha, rfl⟩⟩
{ rw mem_bUnion, exact ⟨a.card, mem_range.mpr (nat.lt_succ_of_le (card_le_of_subset (mem_powerset.mp ha))), mem_powerset_len.mpr ⟨mem_powerset.mp ha, rfl⟩⟩ }
rcases mem_bUnion.mp ha with ⟨i, hi, ha⟩
exact mem_powerset.mpr (mem_powerset_len.mp ha).1
simpa using nat.sub_lt (card_pos.mpr h) zero_lt_one
simp [Iic_finset, le_iff_exists_add, eq_comm]
simp only [h _ H]
simp only [finsupp.support_eq_empty, finset.nonempty_iff_ne_empty, ne.def]
simp only [sum, comap_domain_apply, (∘)]
simp [comap_domain, finset.sum_preimage_of_bij f _ _ (λ x, g x (l x))]
simp
simp only [sum, multiset.count_sum', multiset.count_singleton, mul_boole, coe_mk, multiset.mem_to_finset, iff_self, not_not, mem_support_iff, ite_eq_left_iff, ne.def, multiset.count_eq_zero, multiset.count_nsmul, finset.sum_ite_eq, ite_not]
exact eq.symm
simp only [sum, coe_mk, multiset.to_finset_sum_count_nsmul_eq]
simp [single_apply, set.indicator, @eq_comm _ a]
ext
rw [← card_to_multiset, ← card_to_multiset]
apply multiset.card_lt_of_lt
exact to_multiset_strict_mono h
simp only [single_apply]; ac_refl
ac_refl
simp only [single_apply]
change dite _ _ _ = _
split_ifs; rw [finset.mem_map' f] at h
rw [finset.mem_map' f] at h
rw [finset.mem_map' f] at h
split_ifs
refine congr_arg (v : α → M) (f.inj' _)
{ refine congr_arg (v : α → M) (f.inj' _), exact finset.choose_property (λa₁, f a₁ = f a) _ _ }
exact finset.choose_property (λa₁, f a₁ = f a) _ _
exact (not_mem_support_iff.1 h).symm
rw f.support.prod_ite_eq
dsimp [finsupp.prod]
ext
rw dfinsupp.mem_support_to_fun
exact (finsupp.mem_split_support_iff_nonzero _ _).symm
apply_instance
apply_instance
have := λ a, quotient.fin_choice_aux_eq a (λ i h, quotient.out (f i))
simp [quotient.out_eq] at this
simp [this]
let g := λ a:multiset ι, ⟦λ (i : ι) (h : i ∈ a), quotient.out (f i)⟧
refine eq_of_heq ((eq_rec_heq _ _).trans (_ : g a == g b))
exact quotient.sound h
congr' 1
rintro m n h
letI := classical.dec_eq α
wlog hmlen : m ≤ n using m n
by_contradiction hmn
from lt_of_le_of_ne hmlen hmn
have hmn : m < n
refine (classical.some_spec (exists_not_mem_finset ((multiset.range n).pmap (λ m (hm : m < n), nat_embedding_aux α m) (λ _, multiset.mem_range.1)).to_finset)) _
refine multiset.mem_to_finset.2 (multiset.mem_pmap.2 ⟨m, multiset.mem_range.2 hmn, _⟩)
rw [h, nat_embedding_aux]
simp [function.funext_iff, fintype.complete]
rw multiset.card_map
rw multiset.card_map; refl
refl
rw [list.of_fn_eq_map, fin.prod_univ_def]
rw [← (equiv.sigma_preimage_equiv f).prod_comp, ← univ_sigma_univ, prod_sigma]
refl
simp only [mem_Ico, finset.Ico.mem]
simp only [mem_Icc, finset.Ico.mem, nat.lt_add_one_iff, iff_self, implies_true_iff]
change sub_nat_nat _ _ = _
have h' : n.succ - m = (n - m).succ
apply succ_sub
apply le_of_lt_succ h
simp [*, sub_nat_nat]
cases n; refl
refl
refl
cases n
rw [← int.div_neg]
rw [← int.div_neg]; exact int.div_nonneg Ha (neg_nonneg_of_nonpos Hb)
exact int.div_nonneg Ha (neg_nonneg_of_nonpos Hb)
have := int.add_mul_div_right 0 a H; rwa [zero_add, int.zero_div, zero_add] at this
have := int.add_mul_div_right 0 a H
rwa [zero_add, int.zero_div, zero_add] at this
rw [sub_sub, add_comm]; exact match b, eq_succ_of_zero_lt bpos with ._, ⟨n, rfl⟩ := rfl end
exact match b, eq_succ_of_zero_lt bpos with ._, ⟨n, rfl⟩ := rfl end
rw [sub_sub, add_comm]
have := add_mul_mod_self_left a b 1; rwa mul_one at this
rwa mul_one at this
have := add_mul_mod_self_left a b 1
rw [mul_comm, mul_div_cancel_of_mod_eq_zero H]
simp [cz]
rw [mul_left_comm, int.mul_div_cancel_left _ cz, int.mul_div_cancel_left _ cz]
rw [cast_neg_succ_of_nat, cast_neg_succ_of_nat, neg_apply, add_apply, one_apply, nat_apply]
apply nat.lcm_self
rw int.lcm
refl
{refl}
induction m with d hd
rw [pow_succ, pow_succ]
exact h.mul hd
rw [modeq_iff_dvd, modeq_iff_dvd] at h
rw [modeq_iff_dvd, ← nat_abs_dvd, ← dvd_nat_abs, coe_nat_dvd, nat_abs_mul]
refine hmn.mul_dvd_of_dvd_of_dvd _ _; rw [← coe_nat_dvd, nat_abs_dvd, dvd_nat_abs]; tauto
refine hmn.mul_dvd_of_dvd_of_dvd _ _; rw [← coe_nat_dvd, nat_abs_dvd, dvd_nat_abs]
refine hmn.mul_dvd_of_dvd_of_dvd _ _
tauto
tauto
rw [← coe_nat_dvd, nat_abs_dvd, dvd_nat_abs]
rw [← coe_nat_dvd, nat_abs_dvd, dvd_nat_abs]
refl
induction xs
simp [lazy_list.append, xs_ih]
ext
congr
intro
intro; cc
cc
ext u
ext u; cases u; assumption
ext u; cases u
cases u
assumption
cc
intro
intro; cc
cc
cc
cc
cases l₂; exact if_pos h
exact if_pos h
exact if_pos h
cases l₂
simp [nil_sublist]
by_cases b ∈ l₂; simp [h]
simp [h]
simp [h]
by_cases b ∈ l₂
apply bag_inter_sublist_left
{ apply cons_sublist_cons, apply bag_inter_sublist_left }
apply cons_sublist_cons
apply bag_inter_sublist_left
apply sublist_cons_of_sublist
rw [cons_append, length_cons, nth, nth_concat_length]
cases l; simp only [forall_prop_of_true, map, forall_prop_of_false, not_false_iff]
simp only [forall_prop_of_true, map, forall_prop_of_false, not_false_iff]
simp only [forall_prop_of_true, map, forall_prop_of_false, not_false_iff]
cases l
simp only [cons_bind, map_cons, map_bind l]
induction l with hd tl ih generalizing a
refl
{refl}
unfold foldl
rw [ih (λ a b bin, H a b $ mem_cons_of_mem _ bin), H a hd (mem_cons_self _ _)]
erw [length_cons, length_cons, length_scanl]
rw [foldl,foldl,foldl,← foldl_eq_of_comm',foldl,hf]
induction L with a L ihL
{ simp }
simp
rw [prod_cons, mul_eq_zero, ihL, mem_cons_iff, eq_comm]
simp
{ simp }
induction L generalizing i
simp
{ simp }
cases i
simp [drop_append, L_ih]
induction xs with a t ih generalizing ys
induction xs with a t ih generalizing ys; simp! only [append_nil, eq_self_iff_true, and_self]
simp! only [append_nil, eq_self_iff_true, and_self]
simp! only [append_nil, eq_self_iff_true, and_self]
split_ifs; rw ih
rw ih
rw ih
split_ifs
{ refine ⟨rfl, rfl⟩ }
refine ⟨rfl, rfl⟩
ext
simp
congr
cases h' : f a with b
{ simp [h', lookmap_map_eq] }
simp [h', lookmap_map_eq]
simp [lookmap_cons_some _ _ h', h _ _ h']
rw [← e, append_assoc]
rw [← e, append_assoc]; exact ⟨_, rfl⟩
exact ⟨_, rfl⟩
rw append_assoc
rw append_assoc; exact e
exact e
rw erase_eq_erasep; exact length_erasep_of_mem h rfl
exact length_erasep_of_mem h rfl
rw erase_eq_erasep
rw [← take_append_drop (length s₁) l] at this ⊢
have := h
rw map_append at this
refine ⟨_, _, rfl, append_inj this _⟩
rw [length_map, length_take, min_eq_left]
rw [← length_map f l, h, length_append]
apply nat.le_add_right
induction l; [refl, simp only [*, map]]; split; refl
induction l; [refl, simp only [*, map]]; split
induction l; [refl, simp only [*, map]]
refl
simp only [*, map]
split
induction l
simp
simp
simp [@last'_is_some (b::l)]
induction h with _ _ a _ ih _ _ a _ ih
{ refl }
refl
{ apply sublist_cons_of_sublist a ih }
apply sublist_cons_of_sublist a ih
apply cons_sublist_cons a ih
simpa [hy] using h
rw [next, next, next_or_cons_of_ne _ _ _ _ hy, next_or_eq_next_or_of_mem_of_ne]
{ rwa last_cons at hx }
rwa last_cons at hx
simpa using h.cyclic_permutations.perm
simp [←prev_reverse_eq_next]
rw duplicate_cons_iff at hx ⊢
rcases hx with ⟨rfl, hx⟩|hx
{ simp [h.subset hx] }
simp [h.subset hx]
simp [IH hx]
simp_rw [nodup_iff_sublist, duplicate_iff_sublist]
simp [duplicate_iff_sublist, le_count_iff_repeat_sublist]
induction h with l₁ l₂ y h IH l₁ l₂ y h IH
{ exact hx }
exact hx
{ exact (IH hx).duplicate_cons _ }
exact (IH hx).duplicate_cons _
cases h with h₁ h₂
cases h with h₁ h₂; split; assumption
cases h with h₁ h₂; split
split
assumption
assumption
simp only [mmap_with_index, mmap_with_index_aux_spec, mmap_with_index_aux_eq_mmap_with_index_aux_spec, enum ]
induction l with hd tl hl generalizing f n
{ simp [map_with_index, map_with_index_core] }
simp [map_with_index, map_with_index_core]
rw [map_with_index]
simp [map_with_index_core, hl, add_left_comm, add_assoc, add_comm]
simp only [pairwise_cons, mem_singleton, forall_prop_of_false (not_mem_nil _), forall_true_iff, pairwise.nil, and_true]
simp only [sublists'_cons, pairwise_append, pairwise_map, mem_sublists', mem_map, exists_imp_distrib, and_imp]
have IH := pairwise_sublists' H₂
refine ⟨IH, IH.imp (λ l₁ l₂, lex.cons), _⟩
subst e
intros l₁ sl₁ x l₂ sl₂ e
constructor
{constructor}
cases l₁ with b l₁
exact lex.rel (H₁ _ $ sl₁.subset $ mem_cons_self _ _)
induction s with y s IH generalizing n
simp only [length, permutations'_aux, nat.lt_one_iff] at hn
{ simp only [length, permutations'_aux, nat.lt_one_iff] at hn, simp [hn] }
simp [hn]
cases n
{ simp }
simp
simpa using IH _ _
induction hl
refl
case list.perm.nil { refl }
exact f_congr h ih
case list.perm.cons : a l l' h ih { exact f_congr h ih }
exact f_swap
case list.perm.swap : a a' l { exact f_swap }
case list.perm.trans : l₁ l₂ l₃ h₁ h₂ ih₁ ih₂ { exact heq.trans ih₁ ih₂ }
exact heq.trans ih₁ ih₂
let F := λ a b, ∀ (c ∈ f a) (d ∈ f b), a = b ∧ c = d
change pairwise F l₁ at H
induction p with a l₁ l₂ p IH a b l l₁ l₂ l₃ p₁ p₂ IH₁ IH₂
simp
{simp}
cases h : f a
exact IH (pairwise_cons.1 H).2
{ simp [h], exact IH (pairwise_cons.1 H).2 }
simp [h]
{ cases h : f a, { simp [h], exact IH (pairwise_cons.1 H).2 }, { simp [lookmap_cons_some _ _ h, p] } }
simp [lookmap_cons_some _ _ h, p]
cases h₁ : f a with c; cases h₂ : f b with d
cases h₂ : f b with d
cases h₂ : f b with d
cases h₁ : f a with c
apply swap
{ simp [h₁, h₂], apply swap }
simp [h₁, h₂]
apply swap
{ simp [h₁, lookmap_cons_some _ _ h₂], apply swap }
simp [h₁, lookmap_cons_some _ _ h₂]
apply swap
{ simp [lookmap_cons_some _ _ h₁, h₂], apply swap }
simp [lookmap_cons_some _ _ h₁, h₂]
simp [lookmap_cons_some _ _ h₁, lookmap_cons_some _ _ h₂]
rcases (pairwise_cons.1 H).1 _ (or.inl rfl) _ h₂ _ h₁ with ⟨rfl, rfl⟩
{ cases h₁ : f a with c; cases h₂ : f b with d, { simp [h₁, h₂], apply swap }, { simp [h₁, lookmap_cons_some _ _ h₂], apply swap }, { simp [lookmap_cons_some _ _ h₁, h₂], apply swap }, { simp [lookmap_cons_some _ _ h₁, lookmap_cons_some _ _ h₂], rcases (pairwise_cons.1 H).1 _ (or.inl rfl) _ h₂ _ h₁ with ⟨rfl, rfl⟩, refl } }
refl
refine (IH₁ H).trans (IH₂ ((p₁.pairwise_iff _).1 H))
exact λ a b h c h₁ d h₂, (h d h₂ c h₁).imp eq.symm eq.symm
simp only [range_eq_range', pairwise_lt_range']
simp only [range_eq_range', range'_sublist_right]
cases l.length.zero_le.eq_or_lt with hl hl
{ simp [eq_nil_of_length_eq_zero hl.symm ] }
simp [eq_nil_of_length_eq_zero hl.symm ]
rw [←rotate_eq_drop_append_take (n.mod_lt hl).le, rotate_mod]
rw [is_rotated_comm, is_rotated_nil_iff, eq_comm]
split
intro h
obtain ⟨k, hk, rfl⟩ := nth_le_of_mem h
{ intro h, obtain ⟨k, hk, rfl⟩ := nth_le_of_mem h, simp }
simp
intro h
obtain ⟨k, rfl⟩ := h.symm
rw mem_iff_nth_le
simp only [exists_prop, nth_le_cyclic_permutations]
cases l' with x l
{ simp }
simp
refine ⟨k % length (x :: l), _, rotate_mod _ _⟩
simpa using nat.mod_lt _ (zero_lt_succ _)
by_cases h : a = a'
simp
{ subst a', simp }
subst a'
simp [h, map_lookup_eq_find]
refine (lookmap_congr _).trans (lookmap_id' (option.guard (λ s, a = s.1)) _ _)
dsimp [option.guard]
split_ifs
rintro ⟨a', b'⟩ h'
exact ⟨rfl, heq_of_eq $ nd.eq_of_mk_mem h h'⟩
{ subst a', exact ⟨rfl, heq_of_eq $ nd.eq_of_mk_mem h h'⟩ }
subst a'
{ rintro ⟨a', b'⟩ h', dsimp [option.guard], split_ifs, { subst a', exact ⟨rfl, heq_of_eq $ nd.eq_of_mk_mem h h'⟩ }, { refl } }
refl
dsimp [option.guard]
split_ifs
rintro ⟨a₁, b₁⟩ ⟨a₂, b₂⟩
rintro ⟨⟩
simp
{ subst a₁, rintro ⟨⟩, simp }
rintro ⟨⟩
subst a₁
simp [h]
cases e : split l with l₁ l₂
injection (split_cons_of_eq _ e).symm.trans h
substs l₁' l₂'
cases length_split_le e with h₁ h₂
exact ⟨nat.succ_le_succ h₂, nat.le_succ_of_le h₁⟩
rw [sublists_aux_cons_cons]
refine not_mem_cons_of_ne_of_not_mem (cons_ne_nil _ _).symm _
revert this
have := sublists_aux_ne_nil l
induction sublists_aux l cons; intro
intro
intro
induction sublists_aux l cons
rwa foldr
{rwa foldr}
simp only [foldr, mem_cons_iff, false_or, not_or_distrib]
exact ⟨ne_of_not_mem_cons this, ih (not_mem_of_not_mem_cons this)⟩
induction l generalizing f r; [refl, simp only [*, sublists'_aux]]
refl
simp only [*, sublists'_aux]
induction l generalizing f r
induction l with hd tl hl generalizing l'
{ simp }
simp
cases l'
{ simp }
simp
simp [comm, hl]
rw [← unzip_left, unzip_revzip]
induction l with hd tl hl generalizing f n l'
{ simp }
simp
cases l' with hd' tl'
{ simp, }
simp
simp [hl, mul_add]
ext i j
apply dot_product_add
apply dot_product_neg
ext
simp only [block_diagonal_apply, pi.smul_apply]
split_ifs
split_ifs; simp
ext
simp
simp
ext
simp only [block_diagonal'_apply, pi.add_apply]
split_ifs; simp
simp
simp
split_ifs
by_cases h : i = j
by_cases h : i = j; simp [h]
simp [h]
simp [h]
ext
ext ⟨i, i'⟩ ⟨j, j'⟩
simp only [kronecker_map_bilinear_apply_apply, mul_apply, ← finset.univ_product_univ, finset.sum_product, kronecker_map]
simp_rw [f.map_sum, linear_map.sum_apply, linear_map.map_sum, h_comm]
apply_instance
rw [mul_matrix_apply, equiv.to_pequiv_apply]
ext i j
refine ⟨λ h, revzip_powerset_aux h, λ h, _⟩
simp [antidiagonal_coe]
haveI := classical.dec_eq α
simp [revzip_powerset_aux_lemma l revzip_powerset_aux, h.symm]
cases x with x₁ x₂
rw add_sub_cancel_left _ _
exact ⟨_, le_add_right _ _, by rw add_sub_cancel_left _ _⟩
simp only [l.prod_hom f, quot_mk_to_coe, coe_map, coe_prod]
rw [add_comm, add_sub_of_le h]
rw [add_comm, ← card_add, sub_add_cancel h]
by_contra h
cases lt_iff_cons_le.1 (lt_of_le_of_ne (le_inter (add_le_add_right (inter_le_left s t) u) (add_le_add_right (inter_le_right s t) u)) h) with a hl
rw ← cons_add at hl
exact not_le_of_lt (lt_cons_self (s ∩ t) a) (le_inter (le_of_add_le_add_right (le_trans hl (inter_le_left _ _))) (le_of_add_le_add_right (le_trans hl (inter_le_right _ _))))
split_ifs with h
{ rw [filter_cons_of_pos _ h, singleton_add] }
rw [filter_cons_of_pos _ h, singleton_add]
rw [filter_cons_of_neg _ h, zero_add]
refine ⟨mem_of_mem_nsmul, λ h, _⟩
obtain ⟨n, rfl⟩ := exists_eq_succ_of_ne_zero h0
rw [succ_nsmul, mem_add]
exact or.inl h
simp
simpa
induction k
rw [← multiset.card_eq_zero, multiset.card_map, multiset.card_eq_zero]
simp [mul_left_comm]
simp
intro
simp [traverse]
refl
apply m.induction_on
{ simp }
simp
intros a s h
simp [h]
choose f hf using assume a, quotient.exists_rep (t a)
rw show t = λ a, f a, from (eq.symm $ funext $ λ a, hf a)
simpa using nodup_sigma
rwa [cons_add, cons_add, zero_add] at s_eq
refine λ p, ⟨p.to_fun 0, finsupp.ext (λ a, _)⟩
simpa [(finsupp.ext is_empty_elim : a = 0), C_apply, monomial]
rw [X_pow_eq_single, monomial, monomial, monomial, single_mul_single]
rw [X_pow_eq_single, monomial, monomial, monomial, single_mul_single]; simp
simp
apply @finsupp.induction σ ℕ _ _ s
simp only [C_apply, prod_zero_index]; exact (mul_one _).symm
exact (mul_one _).symm
simp only [C_apply, prod_zero_index]
{ simp only [C_apply, prod_zero_index]; exact (mul_one _).symm }
assume n e s hns he ih
rw [monomial_single_add, ih, prod_add_index, prod_single_index, mul_left_comm]
{ simp only [pow_zero], }
simp only [pow_zero]
simp only [pow_zero]
{ intro a, simp only [pow_zero], }
intro a
rw pow_add
intros
simp
refl
simp only [eval₂_eq, ← finsupp.prod_pow]
simp only [coe_eval₂_hom]
unfold map eval
have h := eval₂_comp_left (eval₂_hom _ g)
dsimp at h
rw h
congr
simp only [coe_eval₂_hom, ring_hom.id_apply, comp_app, eval₂_C, ring_hom.coe_comp]
ext1 a
{ ext1 a, simp only [coe_eval₂_hom, ring_hom.id_apply, comp_app, eval₂_C, ring_hom.coe_comp], }
simp only [comp_app, eval₂_X]
ext1 n
simp
ext i
dsimp
have h₁ : algebra_map R (mv_polynomial σ A₁) r = C (algebra_map R A₁ r) := rfl
have h₂ : algebra_map R (mv_polynomial σ A₂) r = C (algebra_map R A₂ r) := rfl
rw [h₁, h₂, map, eval₂_hom_C, ring_hom.comp_apply, ring_equiv.coe_to_ring_hom, alg_equiv.coe_ring_equiv, alg_equiv.commutes]
apply @mv_polynomial_equiv_mv_polynomial R (S₁ ⊕ S₂) _ _ _ _ (sum_to_iter R S₁ S₂) (iter_to_sum R S₁ S₂)
refine ring_hom.ext (λ p, _)
rw [ring_hom.comp_apply]
convert hom_eq_hom ((sum_to_iter R S₁ S₂).comp ((iter_to_sum R S₁ S₂).comp C)) C _ _ p
dsimp
rw [iter_to_sum_C_C R S₁ S₂, sum_to_iter_C R S₁ S₂]
{ ext1 a, dsimp, rw [iter_to_sum_C_C R S₁ S₂, sum_to_iter_C R S₁ S₂] }
ext1 a
dsimp
rw [iter_to_sum_C_X R S₁ S₂, sum_to_iter_Xr R S₁ S₂]
{ refine ring_hom.ext (λ p, _), rw [ring_hom.comp_apply], convert hom_eq_hom ((sum_to_iter R S₁ S₂).comp ((iter_to_sum R S₁ S₂).comp C)) C _ _ p, { ext1 a, dsimp, rw [iter_to_sum_C_C R S₁ S₂, sum_to_iter_C R S₁ S₂] }, { assume c, dsimp, rw [iter_to_sum_C_X R S₁ S₂, sum_to_iter_Xr R S₁ S₂] } }
assume c
rw [iter_to_sum_X R S₁ S₂, sum_to_iter_Xl R S₁ S₂]
assume b
{ assume b, rw [iter_to_sum_X R S₁ S₂, sum_to_iter_Xl R S₁ S₂] }
rw [ring_hom.comp_apply, ring_hom.comp_apply, sum_to_iter_C R S₁ S₂, iter_to_sum_C_C R S₁ S₂]
ext1 a
{ ext1 a, rw [ring_hom.comp_apply, ring_hom.comp_apply, sum_to_iter_C R S₁ S₂, iter_to_sum_C_C R S₁ S₂] }
cases n with b c
assume n
{ rw [sum_to_iter_Xl, iter_to_sum_X] }
rw [sum_to_iter_Xl, iter_to_sum_X]
rw [sum_to_iter_Xr, iter_to_sum_C_X]
ext : 2; simp
simp
simp
ext : 2
convert linear_map.map_smul (pderiv i) a f; rw C_mul'
rw C_mul'
rw C_mul'
convert linear_map.map_smul (pderiv i) a f
split
intros h i
{ intros h i, simpa using @h (X i) }
simpa using @h (X i)
exact supported_mono
rw [supported, set.image_eq_range, adjoin_range_eq_range_aeval, rename]
apply le_antisymm
{ apply degrees_add }
apply degrees_add
apply multiset.union_le
{ apply le_degrees_add h }
apply le_degrees_add h
apply le_degrees_add h.symm
rw add_comm
apply t.induction_on
{ simp }
simp
intros a s has hsum
rw [finset.bUnion_insert, finset.sum_insert has]
refine finset.subset.trans (vars_add_subset _ _) (finset.union_subset_union (finset.subset.refl _) _)
assumption
rw p.as_sum
conv_lhs { rw p.as_sum }
simp only [ring_hom.map_sum, eval₂_hom_monomial]
by_cases h0 : constant_coeff p = 0
work_on_goal 0 { rw [h0, f.map_zero, finset.sum_eq_zero], intros d hd }
rw [h0, f.map_zero, finset.sum_eq_zero]
intros d hd
work_on_goal 1 { rw [finset.sum_eq_single (0 : σ →₀ ℕ)], { rw [finsupp.prod_zero_index, mul_one], refl }, intros d hd hd0, }
rw [finset.sum_eq_single (0 : σ →₀ ℕ)]
rw [finsupp.prod_zero_index, mul_one]
{ rw [finsupp.prod_zero_index, mul_one], refl }
refl
intros d hd hd0
repeat { obtain ⟨i, hi⟩ : d.support.nonempty, { rw [constant_coeff_eq, coeff, ← finsupp.not_mem_support_iff] at h0, rw [finset.nonempty_iff_ne_empty, ne.def, finsupp.support_eq_empty], rintro rfl, contradiction }, rw [finsupp.prod, finset.prod_eq_zero hi, mul_zero], rw [hp, zero_pow (nat.pos_of_ne_zero $ finsupp.mem_support_iff.mp hi)], rw [mem_vars], exact ⟨d, hd, hi⟩ }
obtain ⟨i, hi⟩ : d.support.nonempty
obtain ⟨i, hi⟩ : d.support.nonempty
obtain ⟨i, hi⟩ : d.support.nonempty
rw [constant_coeff_eq, coeff, ← finsupp.not_mem_support_iff] at h0
rw [finset.nonempty_iff_ne_empty, ne.def, finsupp.support_eq_empty]
contradiction
{ rw [constant_coeff_eq, coeff, ← finsupp.not_mem_support_iff] at h0, rw [finset.nonempty_iff_ne_empty, ne.def, finsupp.support_eq_empty], rintro rfl, contradiction }
{ rw [constant_coeff_eq, coeff, ← finsupp.not_mem_support_iff] at h0, rw [finset.nonempty_iff_ne_empty, ne.def, finsupp.support_eq_empty], rintro rfl, contradiction }
rintro rfl
rw [finsupp.prod, finset.prod_eq_zero hi, mul_zero]
rw [finsupp.prod, finset.prod_eq_zero hi, mul_zero]
rw [hp, zero_pow (nat.pos_of_ne_zero $ finsupp.mem_support_iff.mp hi)]
rw [hp, zero_pow (nat.pos_of_ne_zero $ finsupp.mem_support_iff.mp hi)]
rw [mem_vars]
rw [mem_vars]
exact ⟨d, hd, hi⟩
exact ⟨d, hd, hi⟩
rw [constant_coeff_eq, coeff, ← ne.def, ← finsupp.mem_support_iff] at h0
contradiction
intro
rw [add_comm, mod_add_mod, add_comm]
simp [hb]
simp [hd]
cases exi2 with y hy
cases exi1 with x hx
rw [hx, hy, nat.mul_div_cancel_left, nat.mul_div_cancel_left]
symmetry
apply nat.div_eq_of_eq_mul_left
apply mul_pos
assumption
assumption
repeat {assumption}
cc
rw [←nat.div_mul_cancel w, h, zero_mul]
split
intro
cases b
{ simp * at * }
simp * at *
cases b
refl
{ right, refl }
right
left
simp
have : a / (b + 2) ≤ a / 2 := div_le_div_left (by simp) dec_trivial
refine eq_zero_of_le_half _
{ intro, cases b, { simp * at * }, { cases b, { right, refl }, { left, have : a / (b + 2) ≤ a / 2 := div_le_div_left (by simp) dec_trivial, refine eq_zero_of_le_half _, simp * at * } } }
simp * at *
rintros (rfl|rfl); simp
simp
simp
rintros (rfl|rfl)
subst h
simp
refine le_trans _ h
rw [add_comm, add_one, pred_succ]
simp [ha0]
rw [mul_comm]
rw [mul_comm]; exact mul_div_le_mul_div_assoc _ _ _
exact mul_div_le_mul_div_assoc _ _ _
rw [nat.div_div_eq_div_mul, mul_comm b, mul_comm c, nat.mul_div_mul _ _ (nat.pos_of_ne_zero ha0)]
{ subst hi, simp only [test_bit_zero] at hn hm, have : n = m, { exact eq_of_test_bit_eq (λ i, by convert hnm (i + 1) dec_trivial using 1; rw test_bit_succ) }, rw [hn, hm, this, bit_ff, bit_tt, bit0_val, bit1_val], exact lt_add_one _ }
exact lt_add_one _
obtain ⟨i', rfl⟩ := exists_eq_succ_of_ne_zero hi
simp only [test_bit_succ] at hn hm
convert hnm j.succ (succ_lt_succ hj) using 1
have := hn' _ hn hm (λ j hj, by convert hnm j.succ (succ_lt_succ hj) using 1; rw test_bit_succ)
convert hnm j.succ (succ_lt_succ hj) using 1; rw test_bit_succ
rw test_bit_succ
rw test_bit_succ
cases b; cases b'; simp only [bit_ff, bit_tt, bit0_val n, bit1_val n, bit0_val m, bit1_val m]; linarith
cases b; cases b'; simp only [bit_ff, bit_tt, bit0_val n, bit1_val n, bit0_val m, bit1_val m]
cases b; cases b'
cases b'
cases b'
cases b
simp only [bit_ff, bit_tt, bit0_val n, bit1_val n, bit0_val m, bit1_val m]
simp only [bit_ff, bit_tt, bit0_val n, bit1_val n, bit0_val m, bit1_val m]
simp only [bit_ff, bit_tt, bit0_val n, bit1_val n, bit0_val m, bit1_val m]
simp only [bit_ff, bit_tt, bit0_val n, bit1_val n, bit0_val m, bit1_val m]
linarith
linarith
linarith
linarith
simp [←lxor_assoc, ←h]
simp [←lxor_assoc]
induction n using nat.binary_rec with b n hn
{ exact false.elim (h rfl) }
exact false.elim (h rfl)
by_cases h' : n = 0
subst h'
revert h
cases b
cases b; simp
simp
simp
rw (show b = tt, by { revert h, cases b; simp })
rw [test_bit_zero]
refine ⟨0, ⟨by rw [test_bit_zero], λ j hj, _⟩⟩
obtain ⟨j', rfl⟩ := exists_eq_succ_of_ne_zero (ne_of_gt hj)
{ subst h', rw (show b = tt, by { revert h, cases b; simp }), refine ⟨0, ⟨by rw [test_bit_zero], λ j hj, _⟩⟩, obtain ⟨j', rfl⟩ := exists_eq_succ_of_ne_zero (ne_of_gt hj), rw [test_bit_succ, zero_test_bit] }
rw [test_bit_succ, zero_test_bit]
obtain ⟨k, ⟨hk, hk'⟩⟩ := hn h'
rw [test_bit_succ, hk]
refine ⟨k + 1, ⟨by rw [test_bit_succ, hk], λ j hj, _⟩⟩
obtain ⟨j', rfl⟩ := exists_eq_succ_of_ne_zero (show j ≠ 0, by linarith)
linarith
exact (test_bit_succ _ _ _).trans (hk' _ (lt_of_succ_lt_succ hj))
induction n using nat.binary_rec with b n hn' generalizing i m
contrapose! hm
rw le_zero_iff at hm
{ contrapose! hm, rw le_zero_iff at hm, simp [hm] }
simp [hm]
induction m using nat.binary_rec with b' m hm' generalizing i
exact false.elim (bool.ff_ne_tt ((zero_test_bit i).symm.trans hm))
{ exact false.elim (bool.ff_ne_tt ((zero_test_bit i).symm.trans hm)) }
by_cases hi : i = 0
subst hi
simp only [test_bit_zero] at hn hm
have : n = m
convert hnm (i + 1) dec_trivial using 1
convert hnm (i + 1) dec_trivial using 1; rw test_bit_succ
exact eq_of_test_bit_eq (λ i, by convert hnm (i + 1) dec_trivial using 1; rw test_bit_succ)
rw test_bit_succ
rw test_bit_succ
{ exact eq_of_test_bit_eq (λ i, by convert hnm (i + 1) dec_trivial using 1; rw test_bit_succ) }
rw [hn, hm, this, bit_ff, bit_tt, bit0_val, bit1_val]
simp [h1]
induction l1 with hd tl IH
{ simp [of_digits] }
simp [of_digits]
rw [of_digits, list.cons_append, of_digits, IH, list.length_cons, pow_succ']
ring
cases b with b
cases n with n
{ refl, }
refl
change of_digits 0 [n+1] = n+1
dsimp [of_digits]
{ cases n with n, { refl, }, { change of_digits 0 [n+1] = n+1, dsimp [of_digits], simp, } }
simp
cases b with b
induction n with n ih
{ refl, }
refl
{ induction n with n ih, { refl, }, { simp only [ih, add_comm 1, of_digits_one_cons, nat.cast_id, digits_one_succ], } }
simp only [ih, add_comm 1, of_digits_one_cons, nat.cast_id, digits_one_succ]
clear n
apply nat.strong_induction_on n _
intros n h
cases n
refl
{ rw digits_zero, refl, }
rw digits_zero
simp only [nat.succ_eq_add_one, digits_add_two_add_one]
dsimp [of_digits]
rw h _ (nat.div_lt_self' n b)
rw [nat.cast_id, nat.mod_add_div]
split
intro h
rw h
have : of_digits b (digits b n) = of_digits b []
convert this
{ intro h, have : of_digits b (digits b n) = of_digits b [], by rw h, convert this, rw of_digits_digits }
rw of_digits_digits
rintro rfl
simp
apply nat.strong_induction_on m
intros n IH d hd
cases n with n
cases hd
{ rw digits_zero at hd, cases hd }
rw digits_zero at hd
rw digits_add_two_add_one at hd
cases hd
exact n.succ.mod_lt (by linarith)
linarith
{ rw hd, exact n.succ.mod_lt (by linarith) }
rw hd
linarith
exact IH _ (nat.div_lt_self (nat.succ_pos _) (by linarith)) hd
rw ←int.coe_nat_dvd
exact dvd_iff_dvd_of_dvd_sub (zmodeq_of_digits_digits b b' c (int.modeq_iff_dvd.2 h).symm _).symm.dvd
rw [dist.def, dist.def, right_distrib, nat.mul_sub_right_distrib, nat.mul_sub_right_distrib]
simpa only [← some_eq_coe] using part.some_inj
suffices : n! * (n + 1) ^ (m - n) ≤ m!
apply trans _ this
rw mul_le_mul_left
apply pow_le_pow_of_le_left (zero_le n) (le_succ n)
{ apply trans _ this, rw mul_le_mul_left, apply pow_le_pow_of_le_left (zero_le n) (le_succ n), exact factorial_pos n,}
exact factorial_pos n
convert nat.factorial_mul_pow_le_factorial
exact (nat.add_sub_of_le hnm).symm
rw [asc_factorial_zero, pow_zero]
rw pow_succ
exact nat.mul_le_mul (nat.add_le_add_right le_self_add _) (pow_succ_le_asc_factorial k)
rw gcd_zero_left
rw gcd_zero_left; exact kn
exact kn
rw gcd_rec
rw gcd_rec; exact IH ((dvd_mod_iff H1).2 H2) H1
exact IH ((dvd_mod_iff H1).2 H2) H1
simp [coprime]
rw [← enat.coe_le_coe, ← hp.multiplicity_factorial hbn, ← pow_dvd_iff_le_multiplicity]
simp only [nat.add_sub_cancel' hkn]
simp only [nat.add_div (pow_pos hp.pos _)]
simp [sum_add_distrib, sum_boole]
to_rhs
rw [←nat.sub_add_cancel h, even_add]
conv { to_rhs, rw [←nat.sub_add_cancel h, even_add] }
by_cases h : even n; simp [h]
simp [h]
simp [h]
by_cases h : even n
rw [odd_iff_not_even, even_sub h, not_iff, not_iff_comm, odd_iff_not_even]
cases mod_two_eq_zero_or_one n with h h; simp [h]
simp [h]
simp [h]
cases mod_two_eq_zero_or_one n with h h
revert h
dec_trivial
rintro rfl
intro h
intro h
split
split; intro h
rcases n with (_ | _ | n)
{ exact or.inl rfl }
exact or.inl rfl
{ exact or.inr rfl }
exact or.inr rfl
injection h
{ rcases n with (_ | _ | n), { exact or.inl rfl }, { exact or.inr rfl }, { rw factors at h, injection h }, }
rw factors at h
rcases h with (rfl | rfl)
{ exact factors_zero }
exact factors_zero
exact factors_one
obtain ⟨l, ⟨h, rfl⟩⟩ := (dvd_prime_pow pp).1 h₂
congr
exact le_antisymm h (not_le.1 ((not_congr (pow_dvd_pow_iff_le_right (prime.one_lt pp))).1 h₁))
cases s : psub m n; simp [eq_comm]
simp [eq_comm]
simp [eq_comm]
cases s : psub m n
refine lt_of_not_ge (λ h, _)
show m < n
cases le.dest h with k e
injection s.symm.trans (psub_eq_some.2 $ (add_comm _ _).trans e)
{ show m < n, refine lt_of_not_ge (λ h, _), cases le.dest h with k e, injection s.symm.trans (psub_eq_some.2 $ (add_comm _ _).trans e) }
rw ← psub_eq_some.1 s
apply nat.le_add_left
show n ≤ m
rw sqrt_aux; simp only [h, h₂.symm, int.coe_nat_add, if_false]; rw [add_comm _ (n':ℤ), add_sub_cancel, sqrt_aux._match_1]
rw sqrt_aux; simp only [h, h₂.symm, int.coe_nat_add, if_false]
simp only [h, h₂.symm, int.coe_nat_add, if_false]
rw sqrt_aux
rw [add_comm _ (n':ℤ), add_sub_cancel, sqrt_aux._match_1]
rw [pred'_to_nat, succ'_to_nat, nat.add_one, nat.pred_succ]
rw [size, succ_to_nat, nat_size, size_eq_nat_size]
rw [size, succ_to_nat, nat_size, size_eq_nat_size]
refine_struct {mul := (*), one := (1 : pos_num), npow := @npow_rec _ ⟨1⟩ ⟨(*)⟩}
refine_struct {mul := (*), one := (1 : pos_num), npow := @npow_rec _ ⟨1⟩ ⟨(*)⟩}; try { intros, refl }; transfer
refine_struct {mul := (*), one := (1 : pos_num), npow := @npow_rec _ ⟨1⟩ ⟨(*)⟩}; try { intros, refl }
refl
try { intros, refl }
try { intros, refl }
try { intros, refl }
try { intros, refl }
try { intros, refl }
try { intros, refl }
transfer
transfer
transfer
intros
rw [← bit1_of_bit1, _root_.bit1, bit0_of_bit0, cast_add, cast_bit0]
rw [← bit1_of_bit1, _root_.bit1, bit0_of_bit0, cast_add, cast_bit0]; refl
refl
rw [int.cast_coe_nat, ← num.of_nat_to_znum, num.cast_to_znum, ← num.cast_to_nat, int.nat_cast_eq_coe_nat, num.to_of_nat]
rw [int.cast_neg_succ_of_nat, cast_zneg, add_one, cast_succ, int.neg_succ_of_nat_eq, ← num.of_nat_to_znum, num.cast_to_znum, ← num.cast_to_nat, int.nat_cast_eq_coe_nat, num.to_of_nat]
refine nat.prime_def_min_fac.trans ((and_iff_right _).trans $ eq_comm.trans _)
{ exact bit0_le_bit0.2 (to_nat_pos _) }
exact bit0_le_bit0.2 (to_nat_pos _)
rw [← min_fac_to_nat, to_nat_inj]
exact ⟨bit0.inj, congr_arg _⟩
refine nat.prime_def_min_fac.trans ((and_iff_right _).trans _)
{ exact nat.bit0_le_bit1_iff.2 (to_nat_pos _) }
exact nat.bit0_le_bit1_iff.2 (to_nat_pos _)
refl
rw [← min_fac_to_nat, to_nat_inj]
cases x; refl
refl
refl
cases x
cases x
{ simp }
simp
simp only [pbind]
split
intro h
use x
{ intro h, use x, simpa only [mem_def, exists_prop_of_true] using h }
simpa only [mem_def, exists_prop_of_true] using h
rintro ⟨z, H, hz⟩
simp only [mem_def] at H
simpa only [H] using hz
linarith
exact ⟨hr, (zero_add _).symm⟩
cases l with ls ll lx lr
{exact ⟨hr, (zero_add _).symm⟩ }
exact ⟨hl, rfl⟩
cases r with rs rl rx rr
{exact ⟨hl, rfl⟩ }
split_ifs
dsimp [glue]
rw [split_max_eq, glue]
cases valid'.erase_max_aux hl with v e
suffices H
refine ⟨valid'.balance_r v (hr.of_gt _ _) H, _⟩
refine find_max'_all lx lr hl.1.2.to_nil (sep.2.2.imp _)
{ refine find_max'_all lx lr hl.1.2.to_nil (sep.2.2.imp _), exact λ x h, hr.1.2.to_nil.mono_left (le_of_lt h.2.1) }
exact λ x h, hr.1.2.to_nil.mono_left (le_of_lt h.2.1)
exact @find_max'_all _ (λ a, all (> a) (node rs rl rx rr)) lx lr sep.2.1 sep.2.2
{ exact @find_max'_all _ (λ a, all (> a) (node rs rl rx rr)) lx lr sep.2.1 sep.2.2 }
refl
rw [size_balance_r v.3 hr.3 v.2 hr.2 H, add_right_comm, ← e, hl.2.1]
{ rw [size_balance_r v.3 hr.3 v.2 hr.2 H, add_right_comm, ← e, hl.2.1], refl }
refine or.inl ⟨_, or.inr e, _⟩
{ rw [split_max_eq, glue], cases valid'.erase_max_aux hl with v e, suffices H, refine ⟨valid'.balance_r v (hr.of_gt _ _) H, _⟩, { refine find_max'_all lx lr hl.1.2.to_nil (sep.2.2.imp _), exact λ x h, hr.1.2.to_nil.mono_left (le_of_lt h.2.1) }, { exact @find_max'_all _ (λ a, all (> a) (node rs rl rx rr)) lx lr sep.2.1 sep.2.2 }, { rw [size_balance_r v.3 hr.3 v.2 hr.2 H, add_right_comm, ← e, hl.2.1], refl }, { refine or.inl ⟨_, or.inr e, _⟩, rwa hl.2.eq_node' at bal } }
rwa hl.2.eq_node' at bal
rw [split_min_eq, glue]
cases valid'.erase_min_aux hr with v e
suffices H
refine ⟨valid'.balance_l (hl.of_lt _ _) v H, _⟩
refine @find_min'_all _ (λ a, bounded nil o₁ ↑a) rl rx (sep.2.1.1.imp _) hr.1.1.to_nil
{ refine @find_min'_all _ (λ a, bounded nil o₁ ↑a) rl rx (sep.2.1.1.imp _) hr.1.1.to_nil, exact λ y h, hl.1.1.to_nil.mono_right (le_of_lt h) }
exact λ y h, hl.1.1.to_nil.mono_right (le_of_lt h)
exact @find_min'_all _ (λ a, all (< a) (node ls ll lx lr)) rl rx (all_iff_forall.2 $ λ x hx, sep.imp $ λ y hy, all_iff_forall.1 hy.1 _ hx) (sep.imp $ λ y hy, hy.2.1)
{ exact @find_min'_all _ (λ a, all (< a) (node ls ll lx lr)) rl rx (all_iff_forall.2 $ λ x hx, sep.imp $ λ y hy, all_iff_forall.1 hy.1 _ hx) (sep.imp $ λ y hy, hy.2.1) }
refl
{ rw [size_balance_l hl.3 v.3 hl.2 v.2 H, add_assoc, ← e, hr.2.1], refl }
rw [size_balance_l hl.3 v.3 hl.2 v.2 H, add_assoc, ← e, hr.2.1]
refine or.inr ⟨_, or.inr e, _⟩
rwa hr.2.eq_node' at bal
linarith
unfold balance_l balance_r
cases r with rs rl rx rr
refl
{refl}
cases l with ls ll lx lr
cases ll with lls lll llx llr; cases lr with lrs lrl lrx lrr; dsimp only [dual]; try {refl}
cases ll with lls lll llx llr; cases lr with lrs lrl lrx lrr; dsimp only [dual]
cases ll with lls lll llx llr; cases lr with lrs lrl lrx lrr
cases lr with lrs lrl lrx lrr
cases lr with lrs lrl lrx lrr
cases ll with lls lll llx llr
try {refl}
try {refl}
try {refl}
try {refl}
refl
dsimp only [dual]
dsimp only [dual]
dsimp only [dual]
dsimp only [dual]
split_ifs; repeat {simp [h, add_comm]}
repeat {simp [h, add_comm]}
repeat {simp [h, add_comm]}
simp [h, add_comm]
{ cases l with ls ll lx lr, {refl}, cases ll with lls lll llx llr; cases lr with lrs lrl lrx lrr; dsimp only [dual]; try {refl}, split_ifs; repeat {simp [h, add_comm]} }
split_ifs
refl
{refl}
cases l with ls ll lx lr
dsimp only [dual]
swap
simp [add_comm]
{simp [add_comm]}
split_ifs
cases ll with lls lll llx llr; cases lr with lrs lrl lrx lrr; try {refl}
cases ll with lls lll llx llr; cases lr with lrs lrl lrx lrr
cases lr with lrs lrl lrx lrr
cases lr with lrs lrl lrx lrr
cases ll with lls lll llx llr
try {refl}
try {refl}
try {refl}
try {refl}
refl
dsimp only [dual]
split_ifs; simp [h, add_comm]
simp [h, add_comm]
simp [h, add_comm]
split_ifs
rw ← dual_dual t
rw ← dual_dual t; exact h.dual
exact h.dual
cases r; simp [rotate_l, all_node']; split_ifs; simp [all_node3_l, all_node4_l, all]
cases r; simp [rotate_l, all_node']; split_ifs
cases r; simp [rotate_l, all_node']
simp [rotate_l, all_node']
simp [rotate_l, all_node']
cases r
simp [all_node3_l, all_node4_l, all]
simp [all_node3_l, all_node4_l, all]
split_ifs
rw [balance_l_eq_balance' hl hr sl sr H, size_balance' sl sr]
cases o
cases o; [cases h₁, refl]
cases h₁
refl
rw mem_core_res
by_cases h : x ∈ s
by_cases h : x ∈ s; simp [h]
simp [h]
simp [h]
ext
change (coe_pnat_monoid_hom (u + v)).prod = _
rw coe_pnat_monoid_hom.map_add
exact multiset.prod_add _ _
let u := factor_multiset n
let v := factor_multiset m
have : n = u.prod := (prod_factor_multiset n).symm
rw[this]
have : m = v.prod := (prod_factor_multiset m).symm
rw[this]
rw[← prime_multiset.prod_add]
rw[prime_multiset.factor_multiset_prod]
rw[prime_multiset.factor_multiset_prod]
rw[prime_multiset.factor_multiset_prod]
repeat {rw[prime_multiset.factor_multiset_prod]}
apply factor_multiset_equiv.symm.injective
change (p : ℕ+).factor_multiset.prod = (prime_multiset.of_prime p).prod
rw[(p : ℕ+).prod_factor_multiset, prime_multiset.prod_of_prime]
apply_instance
dsimp [prime_multiset]
rw ← coprime_coe
rw ← coprime_coe
rw ← coprime_coe
rw ← coprime_coe
rw mul_coe
apply nat.coprime.mul_right
repeat {rw ← coprime_coe}
intro h
apply hf
rw [←eval₂_hom, h, f.map_zero]
rw [aeval_def, eval₂]
exact (linear_map.applyₗ v).map_sum
rw [ne.def, set_like.ext_iff, not_forall]
refine ⟨X, _⟩
simp only [algebra.mem_bot, not_exists, set.mem_range, iff_true, algebra.mem_top, algebra_map_apply, not_forall]
intro x
rw [ext_iff, not_forall]
refine ⟨1, _⟩
simp [coeff_C]
rintros ⟨⟩
simp [neg_to_finsupp, add_to_finsupp, ← zero_to_finsupp]
rintro ⟨⟩
simp [smul_to_finsupp, ← zero_to_finsupp]
rintros n ⟨⟩
simp [smul_to_finsupp, add_to_finsupp, add_smul, add_comm]
rintros n ⟨⟩
simp [add_smul, add_mul]
simp only [smul_to_finsupp, neg_to_finsupp]
rw [coeff_C_mul, coeff_smul, smul_eq_mul]
ext
simp [coeff_X_pow]
rw [add_comm _ X, coeff_X_add_one_pow]
simp [bit1, add_mul, coeff_bit0_mul]
simp
rw [C_mul_X_pow_eq_monomial]
exact support_monomial _ _ h
cases le_max_iff.1 (degree_add_le p q)
cases le_max_iff.1 (degree_add_le p q); simp [nat_degree_le_nat_degree h]
simp [nat_degree_le_nat_degree h]
simp [nat_degree_le_nat_degree h]
simp only [monomial_eq_C_mul_X.symm]
convert degree_sum_le _ _
exact mul_eq_sum_sum
refine finset.sup_le (λ a ha, finset.sup_le (λ b hb, le_trans (degree_C_mul_X_pow_le _ _) _))
rw [with_bot.coe_add]
rw mem_support_iff at ha hb
exact add_le_add (le_degree_of_ne_zero ha) (le_degree_of_ne_zero hb)
exact hp.ne_zero
nontriviality R
apply nat_degree_eq_of_degree_eq; rw [degree_add_eq_of_leading_coeff_add_ne_zero hlc, h, max_self]
apply nat_degree_eq_of_degree_eq
rw [degree_add_eq_of_leading_coeff_add_ne_zero hlc, h, max_self]
simp only [leading_coeff, this, nat_degree_eq_of_degree_eq h, coeff_add]
rw [H, leading_coeff_eq_zero.1 H, zero_mul, leading_coeff_zero]
rw [leading_coeff_mul', hq.leading_coeff, mul_one]; rwa [hq.leading_coeff, mul_one]
rw [leading_coeff_mul', hq.leading_coeff, mul_one]
rwa [hq.leading_coeff, mul_one]
haveI : is_commutative (with_bot ℕ) max := ⟨max_comm⟩
haveI : is_associative (with_bot ℕ) max := ⟨max_assoc⟩
calc (∑ i, C (f i) * X ^ (i : ℕ)).degree ≤ finset.univ.fold (⊔) ⊥ (λ i, (C (f i) * X ^ (i : ℕ)).degree) : degree_sum_le _ _ ... = finset.univ.fold max ⊥ (λ i, (C (f i) * X ^ (i : ℕ)).degree) : rfl ... < n : (finset.fold_max_lt (n : with_bot ℕ)).mpr ⟨with_bot.bot_lt_coe _, _⟩
rintros ⟨i, hi⟩ -
calc (C (f ⟨i, hi⟩) * X ^ i).degree ≤ (C _).degree + (X ^ i).degree : degree_mul_le _ _ ... ≤ 0 + i : add_le_add degree_C_le (degree_X_pow_le i) ... = i : zero_add _ ... < n : with_bot.some_lt_some.mpr hi
rw [degree_add_eq_left_of_degree_lt this, degree_X]
refine eq_nat_degree_of_le_mem_support (nat_degree_C_mul_le a p) _
refine mem_support_iff.mpr _
rwa coeff_C_mul
rw [h0, nat_degree_zero]
rw [h0, nat_degree_zero]; exact nat.zero_le _
exact nat.zero_le _
rw [nat_degree_C, with_bot.coe_zero, zero_add, ← with_bot.coe_nsmul, nsmul_eq_mul]
rw [nat_degree_C, with_bot.coe_zero, zero_add, ← with_bot.coe_nsmul, nsmul_eq_mul]; simp
simp
rw [C_mul_X_pow_eq_monomial, trailing_degree_monomial ha]
contrapose! hp
simpa
rw [next_coeff_up, if_neg]
rw [eval₂_C, derivative_C, eval₂_zero, zero_mul]
rw [eval₂_add, derivative_add, ih₁, ih₂, derivative_add, eval₂_add, add_mul]
rw [pow_succ', ← mul_assoc, eval₂_mul, eval₂_X, derivative_mul, ih, @derivative_mul _ _ _ X, derivative_X, mul_one, eval₂_add, @eval₂_mul _ _ _ _ X, eval₂_X, add_mul, mul_right_comm]
rw [this (p /ₘ q), this p, this q]; refl
refl
rw [this (p /ₘ q), this p, this q]
rwa [(≠), div_by_monic_eq_zero_iff hq hq0, not_lt]
rwa [monic.def.1 hq, one_mul, (≠), leading_coeff_eq_zero]
rw [degree_mul' hlc, degree_eq_nat_degree hq0, degree_eq_nat_degree hdiv0, ← with_bot.coe_add, with_bot.coe_le_coe]
rw [degree_mul' hlc, degree_eq_nat_degree hq0, degree_eq_nat_degree hdiv0, ← with_bot.coe_add, with_bot.coe_le_coe]; exact nat.le_add_right _ _
exact nat.le_add_right _ _
simp only [hp0, zero_div_by_monic, le_refl]
rw [← degree_add_div_by_monic hq h, degree_eq_nat_degree hq0, degree_eq_nat_degree (mt (div_by_monic_eq_zero_iff hq hq0).1 (not_lt.2 h))]
rw [← degree_add_div_by_monic hq h, degree_eq_nat_degree hq0, degree_eq_nat_degree (mt (div_by_monic_eq_zero_iff hq hq0).1 (not_lt.2 h))]; exact with_bot.coe_le_coe.2 (nat.le_add_left _ _)
exact with_bot.coe_le_coe.2 (nat.le_add_left _ _)
unfold div_by_monic div_mod_by_monic_aux; simp only [dif_pos hq, h, false_and, if_false, degree_zero, bot_le]
unfold div_by_monic div_mod_by_monic_aux
simp only [dif_pos hq, h, false_and, if_false, degree_zero, bot_le]
exactI nat.find (multiplicity_X_sub_C_finite a h0)
rw [← C_0, comp_C]
rw [← C_1, comp_C]
rw [is_root, eval_mul, is_root.def.1 H, zero_mul]
ext n
simp only [polynomial.sum, X_pow_eq_monomial, coeff_monomial, mul_one, finset_sum_coeff, C_mul_monomial, not_not, mem_support_iff, finset.sum_ite_eq', ite_eq_left_iff]
exact λ h, h.symm
induction n with n ih
exact nat.not_lt_zero 1 h
{ exfalso, exact nat.not_lt_zero 1 h}
exfalso
simp only [iterated_deriv_succ]
by_cases H : n = 1
simp only [iterated_deriv_X_one, derivative_one]
{ rw H, simp only [iterated_deriv_X_one, derivative_one] }
rw H
replace h : 1 < n := array.push_back_idx h (ne.symm H)
simp only [derivative_zero]
rw ih h
by_cases hq : q = 0; simp [h.mul_left_ne_zero, hq]
by_cases hq : q = 0
simp [h.mul_left_ne_zero, hq]
simp [h.mul_left_ne_zero, hq]
refine le_antisymm _ _
rw degree_le_iff_coeff_zero
intros m hm
rw degree_lt_iff_coeff_zero at hm
{ rw degree_le_iff_coeff_zero, intros m hm, rw degree_lt_iff_coeff_zero at hm, simp [hm m le_rfl] }
simp [hm m le_rfl]
rw degree_le_iff_coeff_zero
intros m hm
rw degree_lt_iff_coeff_zero at hm
refine h _
simpa using hm m le_rfl
rw h₁ at h₂; exact absurd h₂ dec_trivial
exact absurd h₂ dec_trivial
rw h₁ at h₂
rw [hg, degree_mul, degree_X_sub_C, degree_eq_zero_of_is_unit hgu, add_zero]
obtain ⟨r, hr⟩ := hdiv
have rzero : r ≠ 0
intro h
{ intro h, simpa [h, monic.ne_zero hq] using hr }
simpa [h, monic.ne_zero hq] using hr
rw [hr, nat_degree_mul (monic.ne_zero hp) rzero] at hdeg
have hdegeq : p.nat_degree + r.nat_degree = p.nat_degree
suffices hdegle : p.nat_degree ≤ p.nat_degree + r.nat_degree
{ exact le_antisymm hdeg hdegle }
exact le_antisymm hdeg hdegle
{ suffices hdegle : p.nat_degree ≤ p.nat_degree + r.nat_degree, { exact le_antisymm hdeg hdegle }, exact nat.le.intro rfl }
exact nat.le.intro rfl
replace hdegeq := eq_C_of_nat_degree_eq_zero (((@add_right_inj _ _ p.nat_degree) _ 0).1 hdegeq)
suffices hlead : 1 = r.leading_coeff
have hcoeff := leading_coeff_C (r.coeff 0)
rw [← hdegeq, ← hlead] at hcoeff
rw [← hcoeff, C_1] at hdegeq
{ have hcoeff := leading_coeff_C (r.coeff 0), rw [← hdegeq, ← hlead] at hcoeff, rw [← hcoeff, C_1] at hdegeq, rwa [hdegeq, mul_one] at hr }
rwa [hdegeq, mul_one] at hr
have hprod : q.leading_coeff = p.leading_coeff * r.leading_coeff
{ simp only [hr, leading_coeff_mul] }
simp only [hr, leading_coeff_mul]
rwa [monic.leading_coeff hp, monic.leading_coeff hq, one_mul] at hprod
rw [← supp_preservation_iff_liftp_preservation, supp_preservation_iff_uniform]
apply cofix.bisim_rel
intros x y rxy
rcases (liftr_iff (rel_last α r) _ _).mp (h x y rxy) with ⟨a, f₀, f₁, dxeq, dyeq, h'⟩
rw [dxeq, dyeq, ←abs_map, ←abs_map, mvpfunctor.map_eq, mvpfunctor.map_eq]
rw [←split_drop_fun_last_fun f₀, ←split_drop_fun_last_fun f₁]
rw [append_fun_comp_split_fun, append_fun_comp_split_fun]
rw [id_comp, id_comp]
cases i with _ i
cases i with _ i; dsimp
congr' 2 with i j
dsimp
dsimp
apply h' _ j
{ apply quot.sound, apply h' _ j }
apply quot.sound
apply h' _ j
change f₀ _ j = f₁ _ j
have : cofix.mk ∘ cofix.dest = @_root_.id (cofix F α) := funext cofix.mk_dest
rw [cofix.mk, cofix.dest_corec, ←comp_map, ←cofix.mk, ← append_fun_comp, this, id_comp, append_fun_id_id, mvfunctor.id_map]
split
intros h α a a' f f' h'
{ intros h α a a' f f' h', rw [← pfunctor.supp_eq,← pfunctor.supp_eq,← h,h',h] }
rw [← pfunctor.supp_eq,← pfunctor.supp_eq,← h,h',h]
rwa [supp_eq_of_is_uniform,pfunctor.supp_eq]
rintros h α ⟨a,f⟩
rw mk_pnat
simp
refl
rcases h with ⟨c, rfl⟩
simp only [mul_comm b, nat.mul_div_assoc c (dvd_refl b), nat.cast_mul, mul_div_assoc, coe_nat_div_self]
rw [←(@num_denom n), inv_def]
conv in n⁻¹.denom { rw [←(@num_denom n), inv_def] }
conv in n⁻¹.denom { rw [←(@num_denom n), inv_def] }; apply denom_dvd
apply denom_dvd
have := congr_arg (coe : ℤ → α) e; rwa [int.cast_mul, int.cast_coe_nat, h, zero_mul] at this
have := congr_arg (coe : ℤ → α) e
rwa [int.cast_mul, int.cast_coe_nat, h, zero_mul] at this
rw [division_def, cast_mul_of_ne_zero md (mt this nn), cast_inv_of_ne_zero nn nd, division_def]
rw [div_eq_mul_inv, div_eq_mul_inv, int.cast_neg, neg_mul_eq_neg_mul]
simp [rat.floor]
rw [num_denom']
have h' := int.coe_nat_lt.2 h
to_rhs
conv { to_rhs, rw [coe_int_eq_mk, rat.le_def zero_lt_one h', mul_one] }
rw [coe_int_eq_mk, rat.le_def zero_lt_one h', mul_one]
exact int.le_div_iff_mul_le h'
simp only [lt_iff_le_not_le]
apply and_congr
{ simp [div_num_denom, (rat.le_def b_pos d_pos)] }
simp [div_num_denom, (rat.le_def b_pos d_pos)]
simp [div_num_denom, (rat.le_def d_pos b_pos)]
apply not_iff_not_of_iff
apply_instance
apply_instance
apply_instance
rw le_iff_lt_or_eq; exact or_congr const_lt const_equiv
exact or_congr const_lt const_equiv
rw le_iff_lt_or_eq
rw [sub_apply, const_apply, le_sub_iff_add_le', add_le_add_iff_right]
exact le_of_lt (abs_lt.1 (H _)).2
have KK := mul_pos K0 K0
have εK := mul_pos ε0 KK
refine ⟨_, εK, λ a b ha hb h, _⟩
have a0 := lt_of_lt_of_le K0 ha
have b0 := lt_of_lt_of_le K0 hb
rw [inv_sub_inv ((abv_pos abv).1 a0) ((abv_pos abv).1 b0), abv_div abv, abv_mul abv, mul_comm, abv_sub abv, ← mul_div_cancel ε (ne_of_gt KK)]
exact div_lt_div h (mul_le_mul hb ha (le_of_lt K0) (abv_nonneg abv _)) (le_of_lt $ mul_pos ε0 KK) KK
rwa ← lim_eq_zero_iff at hf
rw [← one_mul g, ← mul_assoc, ← sub_mul, mul_one, mul_comm, mul_comm f]
rw [← one_mul g, ← mul_assoc, ← sub_mul, mul_one, mul_comm, mul_comm f]; exact mul_lim_zero_right _ (setoid.symm (cau_seq.inv_mul_cancel _))
exact mul_lim_zero_right _ (setoid.symm (cau_seq.inv_mul_cancel _))
rw [sub_mul, ← sub_add, sub_sub, sub_add_eq_sub_sub, sub_right_comm, sub_add]; exact show lim_zero (inv f hf - const abv (lim f) * (inv f hf * const abv (lim f)⁻¹) - (const abv (lim f)⁻¹ - f * (inv f hf * const abv (lim f)⁻¹))), from sub_lim_zero (by rw [← mul_assoc, mul_right_comm, const_inv hl]; exact h₁ _ _ _) (by rw [← mul_assoc]; exact h₁ _ _ _)
rw [sub_mul, ← sub_add, sub_sub, sub_add_eq_sub_sub, sub_right_comm, sub_add]
exact show lim_zero (inv f hf - const abv (lim f) * (inv f hf * const abv (lim f)⁻¹) - (const abv (lim f)⁻¹ - f * (inv f hf * const abv (lim f)⁻¹))), from sub_lim_zero (by rw [← mul_assoc, mul_right_comm, const_inv hl]; exact h₁ _ _ _) (by rw [← mul_assoc]; exact h₁ _ _ _)
rw [← mul_assoc, mul_right_comm, const_inv hl]
rw [← mul_assoc, mul_right_comm, const_inv hl]; exact h₁ _ _ _
exact h₁ _ _ _
rw [← mul_assoc]
rw [← mul_assoc]; exact h₁ _ _ _
exact h₁ _ _ _
rw inv_one
rw inv_one
rcases eq_or_ne b ∞ with rfl|hb
simpa [left_ne_zero_of_mul_eq_one h] using h
have : false
{ have : false, by simpa [left_ne_zero_of_mul_eq_one h] using h, exact this.elim }
exact this.elim
rw [← mul_one a, ← mul_inv_cancel (right_ne_zero_of_mul_eq_one h) hb, ← mul_assoc, h, one_mul]
simp only [ha, top_add, top_to_real, zero_add, to_real_nonneg]
simp only [hb, add_top, top_to_real, add_zero, to_real_nonneg]
lift a to ℝ≥0 using ha
lift b to ℝ≥0 using hb
simp only [coe_eq_coe, nnreal.coe_eq, coe_to_real]
simp_rw [ennreal.of_real, ←coe_finset_prod, coe_eq_coe]
exact real.to_nnreal_prod_of_nonneg hf
have : ↑a.to_nnreal = a := ennreal.coe_to_nnreal (lt_of_le_of_lt h coe_lt_top).ne
rw ← this at h
exact_mod_cast h
rwa [← pos_iff_ne_zero, ← add_lt_add_iff_left ha, add_zero] at hb
simp [add_eq_top]
simp only [hr, inv_zero, coe_zero, le_top]
simp only [coe_inv hr, le_refl]
rw [←ereal.neg_neg a, h, ereal.neg_neg b]
rw [neg_lt, ← inv_gold]
exact inv_lt_one one_lt_gold
convert add_lt_add hxr'.1 hys'.1 using 1; norm_cast; linarith
convert add_lt_add hxr'.1 hys'.1 using 1; norm_cast
norm_cast
linarith
convert add_lt_add hxr'.1 hys'.1 using 1
convert add_lt_add hxr'.2 hys'.2 using 1; norm_cast; linarith
convert add_lt_add hxr'.2 hys'.2 using 1; norm_cast
norm_cast
linarith
convert add_lt_add hxr'.2 hys'.2 using 1
linarith
linarith
norm_cast at *
rw H1 at hxr'
rw H2 at hys'
exact lt_trans hxr' hys'
rw iff_eq_eq
rw iff_eq_eq; refl
refl
rw [←nnreal.coe_eq, nnreal.coe_prod, real.coe_to_nnreal _ (finset.prod_nonneg hf)]
exact finset.prod_congr rfl (λ x hxs, by rw real.coe_to_nnreal _ (hf x hxs))
rw real.coe_to_nnreal _ (hf x hxs)
rcases le_iff_exists_add.1 (le_of_lt hxb) with ⟨ε, rfl⟩
exact h _ ((lt_add_iff_pos_right b).1 hxb)
rw [mul_self_le_mul_self_iff hx (sqrt_nonneg _), sq, mul_self_sqrt hy]
split
{ simpa only [abs_le] using abs_le_sqrt }
simpa only [abs_le] using abs_le_sqrt
rw [← abs_le, ← sq_abs]
exact (le_sqrt (abs_nonneg x) h).mp
rw [sqrt_eq_iff_sq_eq, mul_mul_mul_comm, mul_self_sqrt, mul_self_sqrt]
simp
simp
simp; exact λ c, ⟨λ ⟨b, ⟨a, as, bf⟩, cg⟩, ⟨a, as, b, bf, cg⟩, λ ⟨a, as, b, bf, cg⟩, ⟨b, ⟨a, as, bf⟩, cg⟩⟩
exact λ c, ⟨λ ⟨b, ⟨a, as, bf⟩, cg⟩, ⟨a, as, b, bf, cg⟩, λ ⟨a, as, b, bf, cg⟩, ⟨b, ⟨a, as, bf⟩, cg⟩⟩
simp
simp [eq_comm]
induction h with n h IH
exacts [id, λ h2, al (IH h2)]
cases s with f al
unfold has_orelse.orelse
unfold has_orelse.orelse; simp [orelse]
simp [orelse]
apply cb.cases_on (λ b, _) (λ cb, _)
exact ⟨λ h, ⟨_, ret_mem _, h⟩, λ ⟨b', mb, h⟩, by rw [mem_unique (ret_mem _) mb]; exact h⟩
rw [mem_unique (ret_mem _) mb]; exact h
exact h
{ exact ⟨λ h, ⟨_, ret_mem _, h⟩, λ ⟨b', mb, h⟩, by rw [mem_unique (ret_mem _) mb]; exact h⟩ }
rw [mem_unique (ret_mem _) mb]
rw [destruct_think]
exact ⟨λ ⟨b, h, r⟩, ⟨b, think_mem h, r⟩, λ ⟨b, h, r⟩, ⟨b, of_think_mem h, r⟩⟩
unfold destruct head; cases nth s 0; refl
unfold destruct head; cases nth s 0
cases nth s 0
refl
refl
unfold destruct head
dsimp [corec, destruct, nth]
change stream.corec' (corec.F f) (some b) 0 with (corec.F f (some b)).1
dsimp [corec.F]
refl
{ refl }
induction h : f b with s
dsimp [corec.F]
cases s with a b'
apply congr_arg (λ b', some (a, b'))
apply subtype.eq
dsimp [corec, tail]
rw [stream.corec'_eq, stream.tail_cons]
rw h
refl
dsimp [corec.F]
apply mem_rec_on h; intros; simp [*]
apply mem_rec_on h; intros
intros
simp [*]
apply mem_rec_on h
apply eq_of_bisim (λ c1 c2, ∃ s t, c1 = destruct (append s t) ∧ c2 = (destruct s).bind (destruct_append.aux t)) _ ⟨s, t, rfl, rfl⟩
rcases h with ⟨s, t, h⟩
intros c1 c2 h
rw [h.left, h.right]
apply s.cases_on _ (λ a s, _) (λ s, _)
apply s.cases_on _ (λ a s, _) (λ s, _); simp
simp
simp
simp
apply t.cases_on _ (λ b t, _) (λ t, _); simp
simp
simp
simp
apply t.cases_on _ (λ b t, _) (λ t, _)
refine ⟨nil, t, _, _⟩; simp
simp
simp
{ apply t.cases_on _ (λ b t, _) (λ t, _); simp, { refine ⟨nil, t, _, _⟩; simp } }
refine ⟨nil, t, _, _⟩
exact ⟨s, t, rfl, rfl⟩
simp [ret]; apply think_equiv
apply think_equiv
simp [ret]
simp [destruct, cons, computation.rmap]
rw add_comm; symmetry; apply dropn_add
rw add_comm; symmetry
symmetry
apply dropn_add
rw add_comm
unfold functor.map
simp [join, cons, append]
simp [think, join]
rw ←lift_rel.swap at H; exact exists_of_lift_rel_left H h
exact exists_of_lift_rel_left H h
rw ←lift_rel.swap at H
cases o with a; injection oe with h'; exact ⟨a, om, h'⟩
cases o with a; injection oe with h'
injection oe with h'
injection oe with h'
exact ⟨a, om, h'⟩
cases o with a
subst hT'
cases set.mem_Union.1 x.prop with i hi
rw [Union_lift_of_mem x hi, ← h i]
have : x = (set.inclusion (set.subset_Union S i) ⟨x, hi⟩)
cases x
refl
{ cases x, refl }
have hx' : (set.inclusion (set.subset_Union S i) (ui i ⟨x, hi⟩) : α) ∈ S i
from (ui i ⟨x, hi⟩).prop
rw [this, hui, Union_lift_inclusion]
conv_lhs { rw [this, hui, Union_lift_inclusion] }
simp
refine (iff.symm $ iff.intro (image_subset f) $ assume h, _)
rw [← preimage_image_eq s hf, ← preimage_image_eq t hf]
exact preimage_mono h
exact hx
rintro rfl x hx
split
refine ⟨coe '' s, _, hs⟩
rintro ⟨s, hs⟩
rw [range_coe]
{ rintro ⟨s, hs⟩, refine ⟨coe '' s, _, hs⟩, convert image_subset_range _ _, rw [range_coe] }
convert image_subset_range _ _
refine ⟨coe ⁻¹' s, _⟩
rintro ⟨s, hs₁, hs₂⟩
exact hs₂
rw [image_preimage_eq_of_subset]
rw [range_coe]
exact hs₁
rw [inter_comm, ← image_preimage_coe, nonempty_image_iff]
simp
ext
simp [and_comm]
ext ⟨x, y⟩
simp
simp
simp
ext
split
refine ⟨a, b, ha, hb, rfl⟩
rintro ⟨_, b, ⟨a, ha, rfl⟩, hb, rfl⟩
{ rintro ⟨_, b, ⟨a, ha, rfl⟩, hb, rfl⟩, refine ⟨a, b, ha, hb, rfl⟩ }
refine ⟨_, b, ⟨a, ha, rfl⟩, hb, rfl⟩
rintro ⟨a, b, ha, hb, rfl⟩
exact λ x, or_imp_distrib
rw bUnion_eq_Union
haveI := hs.to_encodable
simpa using ht
exact countable_Union (by simpa using ht)
haveI : encodable s := hs.to_encodable
haveI : encodable t := ht.to_encodable
apply_instance
haveI : encodable (s × t)
{ apply_instance }
have : range (prod.map coe coe : s × t → α × β) = set.prod s t
rw [range_prod_map, subtype.range_coe, subtype.range_coe]
rw ← this
exact countable_range _
apply_instance
simpa only [exists_prop, finite.mem_to_finset] using h1.to_finset.exists_min_image f ⟨x, h1.mem_to_finset.2 hx⟩
rwa [← hx, h hs]
refine ⟨_, h.right_inv_on_inv_fun_on⟩
rintros _ ⟨y, hy, rfl⟩
rw [h.right_inv_on_inv_fun_on hy]
exact h.inj_on_image (ha.inj_on univ) hf
rw ← image_univ at *
rw [Ioc_union_Ioc, min_self]; exact (min_le_left _ _).trans (le_max_left _ _)
exact (min_le_left _ _).trans (le_max_left _ _)
exact (min_le_left _ _).trans (le_max_left _ _)
rw [Ioc_union_Ioc, min_self]
simp [← Ici_inter_Iio]
rw [e.image_eq_preimage, e.symm.preimage_Ioo, e.symm_symm]
rw [insert_eq, ← diff_diff, Icc_diff_left, Ioc_diff_right]
rw [← Icc_diff_left, diff_diff_cancel_left (singleton_subset_iff.2 $ left_mem_Icc.2 h)]
simpa only [dual_Ioc, dual_Icc] using @Ioc_union_left (order_dual α) _ b a hab
rw [diff_eq, compl_Ici, Ioi_inter_Iio]
cases le_total a b with hab hab; simp [hab] at h
simp [hab] at h
simp [hab] at h
cases le_total a b with hab hab
{ exact Ioo_union_Ioi' h }
exact Ioo_union_Ioi' h
rw min_comm
simp [*, min_eq_left_of_lt]
simp [← Ioi_inter_Iio]
simp [add_comm]
cases eq_or_lt_of_le hc
subst c
{ subst c, simp [(nonempty_Icc.2 hab).image_const] }
simp [(nonempty_Icc.2 hab).image_const]
exact image_mul_right_Icc' a b ‹0 < c›
intros a₁ a₂ ha
have ha' : ↑a₁ < ↑a₂ := ha
obtain ⟨x, ha₁x, hxa₂⟩ := exists_between ha'
refine ⟨⟨x, _⟩, ⟨ha₁x, hxa₂⟩⟩
exact (hs.out a₁.2 a₂.2) (Ioo_subset_Icc_self ⟨ha₁x, hxa₂⟩)
simp {contextual := tt}
simp {contextual := tt}
simp only [sUnion_eq_bUnion, prod_bUnion, bUnion_image]
classical
apply subset.antisymm
{ simp [Inter_subset] }
simp [Inter_subset]
intros y y_in
simp only [mem_image, mem_Inter, mem_preimage]
rcases hv with ⟨z, hz⟩
refine ⟨function.update z i y, _, update_same i y z⟩
rw @forall_update_iff ι α _ z i y (λ i t, t ∈ v i)
simpa using hz j
exact ⟨y_in, λ j hj, by simpa using hz j⟩
simp only [Union_or, Union_union_distrib, Union_Union_eq_left]
rw [Union_nonempty_index, bUnion_self]
simp
simpa [pairwise, function.on_fun] using @hr a b
simp [ker_def, quotient.sound h]
ext ⟨x⟩
erw [quotient.lift_mk f H, Hg]
refl
exact hf (f a)
rw [←as_string_inv_to_list s, list.as_string_inj, as_string_inv_to_list s]
cases s'
delta cons
simp
cases s
ext i x; induction i; dsimp only [id, to_subtype', comp, subtype_val, prod.mk] at *; simp *
ext i x; induction i; dsimp only [id, to_subtype', comp, subtype_val, prod.mk] at *
ext i x; induction i
induction i
dsimp only [id, to_subtype', comp, subtype_val, prod.mk] at *
dsimp only [id, to_subtype', comp, subtype_val, prod.mk] at *
ext i x
simp *
simp *
simp [*, left]
simp [*, left]
casesI n
{ apply int.cast_mul }
apply int.cast_mul
simp only [coe_coe]
symmetry
erw [fin.coe_mul, ← nat.cast_mul, ← sub_eq_zero, ← nat.cast_sub (nat.mod_le _ _), @char_p.cast_eq_zero_iff R _ _ m]
exact h.trans (nat.dvd_sub_mod _)
refine {..}
refine {..}; intros; refl
refine {..}; intros
intros
intros
intros
intros
refl
refl
refl
refl
simpa using h this
simp [hf.map_one]; rwa [mem_ker] at hx
rwa [mem_ker] at hx
simp [hf.map_one]
simp [mem_ker, hf.map_one] {contextual := tt}
simp only [pow_add, *]
rw [mul_assoc, list.prod_cons, ← hyzx]
rw [mul_assoc, list.prod_cons, ← hyzx]; refl
refl
rw [← mul_assoc, list.prod_cons, ← hyzx, mul_comm hd]
rw [← mul_assoc, list.prod_cons, ← hyzx, mul_comm hd]; refl
refl
simp only [← gsmul_eq_mul, of_add_gsmul, monoid_hom.map_gpow]
simpa only [nsmul_eq_mul, add_right_iterate] using (f.commute_add_int m).iterate_pos_eq_iff_map_eq f.monotone (strict_mono_id.add_const m) hn
simpa only [not_le] using not_congr (f.iterate_pos_le_iff hn)
simp [transnum_aux_seq]
rw [← translation_number_conj_eq' (translate $ multiplicative.of_add x)]
convert tendsto_translation_number₀ _
ext n
simp [sub_eq_neg_add, units.conj_pow']
have A : ∀ m, measurable_set (f^[m] ⁻¹' s) := λ m, (hf.iterate m).measurable hs
have B : ∀ m, μ (f^[m] ⁻¹' s) = μ s
from λ m, (hf.iterate m).measure_preimage hs
have : μ (univ : set α) < (finset.range n).sum (λ m, μ (f^[m] ⁻¹' s))
simpa only [B, nsmul_eq_mul, finset.sum_const, finset.card_range]
rcases exists_nonempty_inter_of_measure_univ_lt_sum_measure μ (λ m hm, A m) this with ⟨i, hi, j, hj, hij, x, hxi, hxj⟩
wlog hlt : i < j := hij.lt_or_lt using [i j, j i] tactic.skip
simp only [set.mem_preimage, finset.mem_range] at hi hj hxi hxj
refine ⟨f^[i] x, hxi, j - i, ⟨nat.sub_pos_of_lt hlt, lt_of_le_of_lt (j.sub_le i) hj⟩, _⟩
{ simp only [set.mem_preimage, finset.mem_range] at hi hj hxi hxj, refine ⟨f^[i] x, hxi, j - i, ⟨nat.sub_pos_of_lt hlt, lt_of_le_of_lt (j.sub_le i) hj⟩, _⟩, rwa [← iterate_add_apply, nat.sub_add_cancel hlt.le] }
rwa [← iterate_add_apply, nat.sub_add_cancel hlt.le]
exact λ hi hj hij hxi hxj, this hj hi hij.symm hxj hxi
rw [← map_add, neg_add_self, map_zero_apply]
rw [← map_add, add_neg_self, map_zero_apply]
simp only [mul_comm n, hm.mul_const n]
simp only [minimal_period, dif_pos hx, gt_iff_lt.1 (nat.find_spec hx).fst]
ext
rw iff_true_right intermediate_field.mem_top
exact dim_adjoin_simple_eq_one_iff.mp (h x)
rintros ⟨x1, x2⟩ ⟨y1, y2⟩ ⟨hxy1, hxy2⟩ ⟨hyx1, hyx2⟩
have : x1 = y1 := le_antisymm hxy1 hyx1
subst this
congr
exact alg_hom.ext (λ s, hxy2 s s rfl)
cases intermediate_field.mem_bot.mp s.mem with u hu
rw [show s = (algebra_map F _) u, from subtype.ext hu.symm, alg_hom.commutes]
rw [show t = (algebra_map F _) u, from subtype.ext (eq.trans hu hst).symm, alg_hom.commutes]
rw [mem_to_subalgebra, algebra.mem_bot, mem_bot]
ext
rw [← card_units p, pow_card_eq_one]
refine top_unique (set_like.le_def.2 $ assume e _, mem_map.2 _)
refine ⟨∑ n : σ → K, e n • indicator n, _, _⟩
exact sum_mem _ (assume c _, smul_mem _ _ (indicator_mem_restrict_degree _))
{ exact sum_mem _ (assume c _, smul_mem _ _ (indicator_mem_restrict_degree _)) }
ext n
simp only [linear_map.map_sum, @finset.sum_apply (σ → K) (λ_, K) _ _ _ _ _, pi.smul_apply, linear_map.map_smul]
simp only [evalₗ_apply]
transitivity
refine finset.sum_eq_single n _ _
assume b _ h
{ assume b _ h, rw [eval_indicator_apply_eq_zero _ _ h.symm, smul_zero] }
rw [eval_indicator_apply_eq_zero _ _ h.symm, smul_zero]
exact (h $ finset.mem_univ n).elim
{ assume h, exact (h $ finset.mem_univ n).elim }
assume h
rw [eval_indicator_apply_eq_one, smul_eq_mul, mul_one]
let b := basis.of_vector_space K V
rw [← b.mk_eq_dim'', lt_omega_iff_finite]
split
introI
exact finite_of_linear_independent (basis.of_vector_space_index.linear_independent K V)
{ introI, exact finite_of_linear_independent (basis.of_vector_space_index.linear_independent K V) }
assume hbfinite
refine @is_noetherian_of_linear_equiv K (⊤ : submodule K V) V _ _ _ _ _ (linear_equiv.of_top _ rfl) (id _)
refine is_noetherian_of_fg_of_noetherian _ ⟨set.finite.to_finset hbfinite, _⟩
rw [set.finite.coe_to_finset, ← b.span_eq, basis.coe_of_vector_space, subtype.range_coe]
have K_le : K ≤ intermediate_field.fixed_field (intermediate_field.fixing_subgroup K) := (intermediate_field.le_iff_le _ _).mpr (le_refl _)
suffices : finrank K E = finrank (intermediate_field.fixed_field (intermediate_field.fixing_subgroup K)) E
exact (intermediate_field.eq_of_le_of_finrank_eq' K_le this).symm
{ exact (intermediate_field.eq_of_le_of_finrank_eq' K_le this).symm }
rw [intermediate_field.finrank_fixed_field_eq_card, fintype.card_congr (intermediate_field.fixing_subgroup_equiv K).to_equiv]
exact (card_aut_eq_finrank K E).symm
rwa [key, alg_hom.map_sub, aeval_X, aeval_C, sub_eq_zero, eq_comm] at this
have := aeval A x
rw [mul_comm, coeff_expand_mul hp]
ext
have h' : (expand R n g).coeff (n * n_1) = (expand R n g').coeff (n * n_1) := begin apply polynomial.ext_iff.1, exact h, end
apply polynomial.ext_iff.1
exact h
rw [polynomial.coeff_expand hn g (n * n_1), polynomial.coeff_expand hn g' (n * n_1)] at h'
simp only [if_true, dvd_mul_right] at h'
rw (nat.mul_div_right n_1 hn) at h'
exact h'
obtain ⟨p, rfl⟩ := hq
apply is_coprime_self.mp
have : is_coprime (q * (q * p)) (q * (q.derivative * p + q.derivative * p + q * p.derivative))
simp only [← mul_assoc, mul_add]
convert hp
rw [derivative_mul, derivative_mul]
{ simp only [← mul_assoc, mul_add], convert hp, rw [derivative_mul, derivative_mul], ring }
ring
exact is_coprime.of_mul_right_left (is_coprime.of_mul_left_left this)
exact algebra_map K (splitting_field_aux _ _ hfn) = (algebra_map (adjoin_root f.factor) (splitting_field_aux n f.remove_factor (nat_degree_remove_factor' hfn))).comp (adjoin_root.of f.factor)
simp only [← gsmul_one, gsmul_mem, one_mem]
simpa only [field_range_eq_map] using (⊤ : subfield K).map_map g f
rw [← (module.rank F K).lift_id, ← b.mk_eq_dim, ← (module.rank K A).lift_id, ← c.mk_eq_dim, ← lift_umax.{w v}, ← (b.smul c).mk_eq_dim, mk_prod, lift_mul, lift_lift, lift_lift, lift_lift, lift_lift, lift_umax]
rw [angle, ← real_inner_div_norm_mul_norm_eq_one_iff, real.arccos_eq_zero, has_le.le.le_iff_eq, eq_comm]
exact (abs_le.mp (abs_real_inner_div_norm_mul_norm_le_one x y)).2
rw [angle_comm, angle_eq_left]
ext
rw orthogonal_projection_eq_self_iff
exact orthogonal_projection_mem p
symmetry
rw [←h₂, t₂.affine_span_insert_singleton_eq_altitude_iff]
rw [h₂]
use t₁.independent.injective.ne hi₁₂
have he : affine_span ℝ (set.range t₂.points) = affine_span ℝ (set.range t₁.points)
refine ext_of_direction_eq _ ⟨t₁.points i₃, mem_affine_span ℝ ⟨j₃, h₃⟩, mem_affine_span ℝ (set.mem_range_self _)⟩
refine eq_of_le_of_finrank_eq (direction_le (span_points_subset_coe_of_subset_coe _)) _
clear h₁ h₂ h₃
have hu : (finset.univ : finset (fin 3)) = {j₁, j₂, j₃}
dec_trivial!
{ clear h₁ h₂ h₃, dec_trivial! }
rw [←set.image_univ, ←finset.coe_univ, hu, finset.coe_insert, finset.coe_insert, finset.coe_singleton, set.image_insert_eq, set.image_insert_eq, set.image_singleton, h₁, h₂, h₃, set.insert_subset, set.insert_subset, set.singleton_subset_iff]
exact ⟨t₁.orthocenter_mem_affine_span, mem_affine_span ℝ (set.mem_range_self _), mem_affine_span ℝ (set.mem_range_self _)⟩
{ have hu : (finset.univ : finset (fin 3)) = {j₁, j₂, j₃}, { clear h₁ h₂ h₃, dec_trivial! }, rw [←set.image_univ, ←finset.coe_univ, hu, finset.coe_insert, finset.coe_insert, finset.coe_singleton, set.image_insert_eq, set.image_insert_eq, set.image_singleton, h₁, h₂, h₃, set.insert_subset, set.insert_subset, set.singleton_subset_iff], exact ⟨t₁.orthocenter_mem_affine_span, mem_affine_span ℝ (set.mem_range_self _), mem_affine_span ℝ (set.mem_range_self _)⟩ }
rw [direction_affine_span, direction_affine_span, t₁.independent.finrank_vector_span (fintype.card_fin _), t₂.independent.finrank_vector_span (fintype.card_fin _)]
{ refine ext_of_direction_eq _ ⟨t₁.points i₃, mem_affine_span ℝ ⟨j₃, h₃⟩, mem_affine_span ℝ (set.mem_range_self _)⟩, refine eq_of_le_of_finrank_eq (direction_le (span_points_subset_coe_of_subset_coe _)) _, { have hu : (finset.univ : finset (fin 3)) = {j₁, j₂, j₃}, { clear h₁ h₂ h₃, dec_trivial! }, rw [←set.image_univ, ←finset.coe_univ, hu, finset.coe_insert, finset.coe_insert, finset.coe_singleton, set.image_insert_eq, set.image_insert_eq, set.image_singleton, h₁, h₂, h₃, set.insert_subset, set.insert_subset, set.singleton_subset_iff], exact ⟨t₁.orthocenter_mem_affine_span, mem_affine_span ℝ (set.mem_range_self _), mem_affine_span ℝ (set.mem_range_self _)⟩ }, { rw [direction_affine_span, direction_affine_span, t₁.independent.finrank_vector_span (fintype.card_fin _), t₂.independent.finrank_vector_span (fintype.card_fin _)] } }
rw he
use mem_affine_span ℝ (set.mem_range_self _)
have hu : finset.univ.erase j₂ = {j₁, j₃}
clear h₁ h₂ h₃
dec_trivial!
{ clear h₁ h₂ h₃, dec_trivial! }
rw [hu, finset.coe_insert, finset.coe_singleton, set.image_insert_eq, set.image_singleton, h₁, h₃]
have hle : (t₁.altitude i₃).directionᗮ ≤ (affine_span ℝ ({t₁.orthocenter, t₁.points i₃} : set P)).directionᗮ := submodule.orthogonal_le (direction_le (affine_span_orthocenter_point_le_altitude _ _))
refine hle ((t₁.vector_span_le_altitude_direction_orthogonal i₃) _)
have hui : finset.univ.erase i₃ = {i₁, i₂}
clear hle h₂ h₃
dec_trivial!
{ clear hle h₂ h₃, dec_trivial! }
rw [hui, finset.coe_insert, finset.coe_singleton, set.image_insert_eq, set.image_singleton]
refine vsub_mem_vector_span ℝ (set.mem_insert _ _) (set.mem_insert_of_mem _ (set.mem_singleton _))
have h' : dist a' c' ^ 2 = (r * dist a c) ^ 2
calc dist a' c' ^ 2 = dist a' b' ^ 2 + dist c' b' ^ 2 - 2 * dist a' b' * dist c' b' * real.cos (∠ a' b' c') : by { simp [pow_two, law_cos a' b' c'] } ... = r ^ 2 * (dist a b ^ 2 + dist c b ^ 2 - 2 * dist a b * dist c b * real.cos (∠ a b c)) : by { rw [h, hab, hcb], ring } ... = (r * dist a c) ^ 2 : by simp [pow_two, ← law_cos a b c, mul_pow]
simp [pow_two, law_cos a' b' c']
rw [h, hab, hcb]
ring
simp [pow_two, ← law_cos a b c, mul_pow]
by_cases hab₁ : a = b
rw [← dist_eq_zero, hab, dist_eq_zero.mpr hab₁, mul_zero r]
have hab'₁ : a' = b'
{ rw [← dist_eq_zero, hab, dist_eq_zero.mpr hab₁, mul_zero r] }
{ have hab'₁ : a' = b', { rw [← dist_eq_zero, hab, dist_eq_zero.mpr hab₁, mul_zero r] }, rw [hab₁, hab'₁, dist_comm b' c', dist_comm b c, hcb] }
rw [hab₁, hab'₁, dist_comm b' c', dist_comm b c, hcb]
rw ← hab
exact dist_nonneg
have h1 : 0 ≤ r * dist a b
{ rw ← hab, exact dist_nonneg }
have h2 : 0 ≤ r := nonneg_of_mul_nonneg_right h1 (dist_pos.mpr hab₁)
exact (sq_eq_sq dist_nonneg (mul_nonneg h2 dist_nonneg)).mp h'
ext x
ext x; exact algebra.commutes' _ _
exact algebra.commutes' _ _
ext x
ext x; exact algebra.smul_def' _ _
exact algebra.smul_def' _ _
refine times_cont_mdiff_of_support (λ x hx, _)
have : x ∈ (chart_at H c).source := f.closure_support_subset_chart_at_source hx
refine times_cont_mdiff_at.congr_of_eventually_eq _ (f.eq_on_source.eventually_eq_of_mem $ is_open.mem_nhds (chart_at _ _).open_source this)
exact f.to_times_cont_diff_bump.times_cont_diff_at.times_cont_mdiff_at.comp _ (times_cont_mdiff_at_ext_chart_at' this)
obtain ⟨s, hsc, hsU⟩ : ∃ s, countable s ∧ (⋃ x (hx : x ∈ s), (chart_at H x).source) = univ := countable_cover_nhds_of_sigma_compact (λ x : M, is_open.mem_nhds (chart_at H x).open_source (mem_chart_source H x))
exact charted_space.second_countable_of_countable_cover H hsU hsc
have E : e.target ∩ e.symm ⁻¹' e.source = e.target := subset.antisymm (inter_subset_left _ _) (λx hx, ⟨hx, local_equiv.target_subset_preimage_source _ hx⟩)
simpa [local_equiv.trans_source, E] using c.open_source e e he he
simp only [mem_Union, mem_singleton_iff]
exact ⟨c.chart_at x, c.chart_mem_atlas x, rfl⟩
rw [range_comp, image_eq_preimage]
apply_instance
simp
refine ⟨h.1.congr h₁ hx, _⟩
have A : s ∩ g' ⁻¹' (chart_at H' (g' x)).source = s ∩ g ⁻¹' (chart_at H' (g' x)).source
ext y
split
assume hy
simp only with mfld_simps at hy
{ assume hy, simp only with mfld_simps at hy, simp only [hy, ← h₁ _ hy.1] with mfld_simps }
simp only [hy, ← h₁ _ hy.1] with mfld_simps
assume hy
simp only with mfld_simps at hy
{ ext y, split, { assume hy, simp only with mfld_simps at hy, simp only [hy, ← h₁ _ hy.1] with mfld_simps }, { assume hy, simp only with mfld_simps at hy, simp only [hy, h₁ _ hy.1] with mfld_simps } }
simp only [hy, h₁ _ hy.1] with mfld_simps
have := h.2
rw [← hx, ← A] at this
convert hG.congr _ _ this using 2
assume y hy
simp only with mfld_simps at hy
simp only [hy]
have : (chart_at H x).symm y ∈ s
{ assume y hy, simp only with mfld_simps at hy, have : (chart_at H x).symm y ∈ s, by simp only [hy], simp only [hy, h₁ _ this] with mfld_simps }
simp only [hy, h₁ _ this] with mfld_simps
simp only [hx] with mfld_simps
intros s x u f hu hux
split
rintros h hx
rcases h hx.1 with ⟨e, heG, hef, hex⟩
mfld_set_tac
have : s ∩ u ∩ e.source ⊆ s ∩ e.source := by mfld_set_tac
{ rintros h hx, rcases h hx.1 with ⟨e, heG, hef, hex⟩, have : s ∩ u ∩ e.source ⊆ s ∩ e.source := by mfld_set_tac, exact ⟨e, heG, hef.mono this, hex⟩ }
exact ⟨e, heG, hef.mono this, hex⟩
rintros h hx
rcases h ⟨hx, hux⟩ with ⟨e, heG, hef, hex⟩
refine ⟨e.restr (interior u), _, _, _⟩
{ exact closed_under_restriction' heG (is_open_interior) }
exact closed_under_restriction' heG (is_open_interior)
mfld_set_tac
have : s ∩ u ∩ e.source = s ∩ (e.source ∩ u) := by mfld_set_tac
{ have : s ∩ u ∩ e.source = s ∩ (e.source ∩ u) := by mfld_set_tac, simpa only [this, interior_interior, hu.interior_eq] with mfld_simps using hef }
simpa only [this, interior_interior, hu.interior_eq] with mfld_simps using hef
simp only [*, interior_interior, hu.interior_eq] with mfld_simps
intros s x f e' he'G he'x h hx
simpa only [e'.left_inv he'x] with mfld_simps using hx.2
have hxs : x ∈ s := by simpa only [e'.left_inv he'x] with mfld_simps using hx.2
rcases h hxs with ⟨e, heG, hef, hex⟩
refine ⟨e'.symm.trans e, G.trans (G.symm he'G) heG, _, _⟩
intros y hy
simp only with mfld_simps at hy
{ intros y hy, simp only with mfld_simps at hy, simp only [hef ⟨hy.1.2, hy.2.2⟩] with mfld_simps }
simp only [hef ⟨hy.1.2, hy.2.2⟩] with mfld_simps
simp only [hex, he'x] with mfld_simps
intros s x f g hfgs hfg' h hx
rcases h hx with ⟨e, heG, hef, hex⟩
refine ⟨e, heG, _, hex⟩
intros y hy
rw [← hef hy, hfgs y hy.1]
intros s x f e' he'G he' hfx h hx
rcases h hx with ⟨e, heG, hef, hex⟩
refine ⟨e.trans e', G.trans heG he'G, _, _⟩
intros y hy
simp only with mfld_simps at hy
{ intros y hy, simp only with mfld_simps at hy, simp only [hef ⟨hy.1, hy.2.1⟩] with mfld_simps }
simp only [hef ⟨hy.1, hy.2.1⟩] with mfld_simps
simpa only [hex, hef ⟨hx, hex⟩] with mfld_simps using hfx
simp only [tangent_map_within, id.def]
rw mfderiv_within_id
refl
{ rcases p, refl }
rcases p
exact hs
rw [← times_cont_diff_on_univ, ← times_cont_mdiff_on_univ, times_cont_mdiff_on_iff_times_cont_diff_on]
assume x
rw [times_cont_mdiff_at, times_cont_mdiff_within_at_iff]
refine ⟨Z.to_topological_fiber_bundle_core.continuous_proj.continuous_at.continuous_within_at, _⟩
simp only [(∘), chart_at, chart] with mfld_simps
apply times_cont_diff_within_at_fst.congr
rintros ⟨a, b⟩ hab
simp only with mfld_simps at hab
{ rintros ⟨a, b⟩ hab, simp only with mfld_simps at hab, simp only [hab] with mfld_simps }
simp only [hab] with mfld_simps
simp only with mfld_simps
set L := ((continuous_linear_map.fst ℝ E ℝ).comp (@continuous_linear_map.proj ℝ _ ι (λ _, E × ℝ) _ _ (λ _, infer_instance) (f.ind x hx)))
have := L.has_mfderiv_at.comp x f.embedding_pi_tangent.mdifferentiable_at.has_mfderiv_at
convert has_mfderiv_at_unique this _
refine (has_mfderiv_at_ext_chart_at I (f.mem_chart_at_ind_source x hx)).congr_of_eventually_eq _
refine (f.eventually_eq_one x hx).mono (λ y hy, _)
simp only [embedding_pi_tangent_coe, continuous_linear_map.coe_comp', (∘), continuous_linear_map.coe_fst', continuous_linear_map.proj_apply]
rw [hy, pi.one_apply, one_smul]
rw [left_transversals, set.mem_set_of_eq, is_complement_iff_exists_unique]
refine ⟨λ h g, _, λ h g, _⟩
obtain ⟨x, h1, h2⟩ := h g
exact ⟨x.1, (congr_arg (∈ T) (eq_inv_mul_of_mul_eq h1)).mp x.2.2, λ y hy, (prod.ext_iff.mp (h2 ⟨y, y⁻¹ * g, hy⟩ (mul_inv_cancel_left y g))).1⟩
{ obtain ⟨x, h1, h2⟩ := h g, exact ⟨x.1, (congr_arg (∈ T) (eq_inv_mul_of_mul_eq h1)).mp x.2.2, λ y hy, (prod.ext_iff.mp (h2 ⟨y, y⁻¹ * g, hy⟩ (mul_inv_cancel_left y g))).1⟩ }
obtain ⟨x, h1, h2⟩ := h g
refine ⟨⟨x, x⁻¹ * g, h1⟩, mul_inv_cancel_left x g, λ y hy, _⟩
have := h2 y.1 ((congr_arg (∈ T) (eq_inv_mul_of_mul_eq hy)).mp y.2.2)
exact prod.ext this (subtype.ext (eq_inv_mul_of_mul_eq ((congr_arg _ this).mp hy)))
simp [mem_right_coset_iff, mul_mem_cancel_right s (s.inv_mem ha)]
convert (submonoid.fg_iff_add_fg P.to_submonoid).symm
exact set_like.ext' rfl
rw [list.length_append, list.length_append]
rw [list.length_append, list.length_append]; refl
refl
let S : submonoid (free_product M) := ⟨set_of C, h_one, h_mul⟩
convert subtype.prop (lift (λ i, of.cod_mrestrict S (h_of i)) m)
change monoid_hom.id _ m = S.subtype.comp _ m
congr
ext
simp [monoid_hom.cod_mrestrict]
exact general_commutator_le_left ⊥ H
rw eq_bot_iff
rw [← fintype.card_prod, ← fintype.card_sigma, fintype.card_congr (sigma_fixed_by_equiv_orbits_prod_group α β)]
haveI := comp α g; exact smul_comm_class N β α
exact smul_comm_class N β α
haveI := comp α g
exact {smul_comm := λ n, @smul_comm _ _ _ _ _ _ (g n) }
exact p.smul_mem _ h
rw [←one_smul R x, ←smul_assoc]
rw r_eq_r' S; refl
refl
rw r_eq_r' S
rw [mul_inv_left, mul_one]
rw [mul_inv_left, mul_one]; exact f.eq_of_eq hg (by rw [←sec_spec, one_mul])
exact f.eq_of_eq hg (by rw [←sec_spec, one_mul])
rw [←sec_spec, one_mul]
rw [mul_inv_left hg, ←mul_assoc, ←mul_assoc, mul_inv_right hg, mul_comm _ (g (f.sec y).1), ←mul_assoc, ←mul_assoc, mul_inv_right hg]
rw ←g.map_mul
rw ←g.map_mul
rw ←g.map_mul
rw ←g.map_mul
rw ←g.map_mul
repeat { rw ←g.map_mul }
repeat { rw f.to_map.map_mul <|> rw sec_spec' }
rw f.to_map.map_mul
rw f.to_map.map_mul
rw f.to_map.map_mul
rw f.to_map.map_mul
rw f.to_map.map_mul
rw f.to_map.map_mul
rw f.to_map.map_mul
rw f.to_map.map_mul
rw sec_spec'
rw sec_spec'
rw sec_spec'
rw sec_spec'
repeat { rw f.to_map.map_mul <|> rw sec_spec' }; ac_refl
exact f.eq_of_eq hg (by repeat { rw f.to_map.map_mul <|> rw sec_spec' }; ac_refl)
ac_refl
rwa is_periodic_pt_mul_iff_pow_eq_one
simp_rw ←set_like.mem_coe
rw ← multiples_eq_gmultiples
exact decidable_multiples
intro g
obtain ⟨j, hj⟩ := (hH.to_quotient ((H ⊓ K).comap H.subtype)).of_equiv (quotient_group.quotient_inf_equiv_prod_normal_quotient H K) g
obtain ⟨k, hk⟩ := hK ⟨g ^ (p ^ j), (congr_arg (∈ K) ((H ⊔ K).coe_pow g (p ^ j))).mp ((quotient_group.eq_one_iff (g ^ (p ^ j))).mp ((quotient_group.coe_pow (K.comap (H ⊔ K).subtype) g (p ^ j)).trans hj))⟩
rw [subtype.ext_iff, K.coe_pow, subtype.coe_mk, ←pow_mul, ←pow_add] at hk
rwa [subtype.ext_iff, (H ⊔ K).coe_pow]
refine ⟨j + k, by rwa [subtype.ext_iff, (H ⊔ K).coe_pow]⟩
rw [←hG, pow_card_eq_one]
induction s using quot.induction_on
simpa using list.form_perm_eq_self_of_not_mem _ _ hx
exact set.unique_singleton vector.nil
rw zero_eq
rw [is_conj_iff_cycle_type_eq]
refine ⟨λ h, _, λ h, _⟩
rw [partition.ext_iff, parts_partition, parts_partition, ← sum_cycle_type, ← sum_cycle_type, h]
{ rw [partition.ext_iff, parts_partition, parts_partition, ← sum_cycle_type, ← sum_cycle_type, h] }
rw [← filter_parts_partition_eq_cycle_type, ← filter_parts_partition_eq_cycle_type, h]
suffices : ∀ l : list (perm β), (∀ τ : perm β, τ ∈ l → τ.is_cycle) → l.pairwise disjoint → P l.prod
classical
let x := σ.trunc_cycle_factors.out
exact (congr_arg P x.2.1).mp (this x.1 x.2.2.1 x.2.2.2)
{ classical, let x := σ.trunc_cycle_factors.out, exact (congr_arg P x.2.1).mp (this x.1 x.2.2.1 x.2.2.2) }
intro l
induction l with σ l ih
{ exact λ _ _, base_one }
exact λ _ _, base_one
intros h1 h2
rw list.prod_cons
exact induction_disjoint σ l.prod (disjoint_prod_right _ (list.pairwise_cons.mp h2).1) (h1 _ (list.mem_cons_self _ _)) (base_cycles σ (h1 σ (l.mem_cons_self σ))) (ih (λ τ hτ, h1 τ (list.mem_cons_of_mem σ hτ)) (list.pairwise_of_pairwise_cons h2))
refine is_conj_iff.2 ⟨equiv.extend_subtype f, _⟩
rw mul_inv_eq_iff_eq_mul
ext
simp only [perm.mul_apply]
by_cases hx : x ∈ σ.support
rw [equiv.extend_subtype_apply_of_mem, equiv.extend_subtype_apply_of_mem]
{ exact hf x (finset.mem_coe.2 hx) }
{ rw [equiv.extend_subtype_apply_of_mem, equiv.extend_subtype_apply_of_mem], { exact hf x (finset.mem_coe.2 hx) } }
exact hf x (finset.mem_coe.2 hx)
rwa [not_not.1 ((not_congr mem_support).1 (equiv.extend_subtype_not_mem f _ _)), not_not.1 ((not_congr mem_support).mp hx)]
rw [nat.lt_sub_left_iff_add_lt, ← nat.lt_sub_right_iff_add_lt, ← finset.card_compl, finset.compl_filter]
exact one_lt_card_support_of_ne_one h
classical
obtain ⟨_|i, hi, rfl⟩ := h.nat'
refine ⟨order_of f, order_of_pos f, le_rfl, _⟩
{ refine ⟨order_of f, order_of_pos f, le_rfl, _⟩, rw [pow_order_of_eq_one, pow_zero] }
rw [pow_order_of_eq_one, pow_zero]
exact ⟨i.succ, i.zero_lt_succ, hi.le, rfl⟩
by_cases hx : f x = x
rw (cycle_of_eq_one_iff _).mpr hx
{ rw (cycle_of_eq_one_iff _).mpr hx, simp [hx] }
simp [hx]
rw [mem_support, cycle_of_apply]
split_ifs with hy
simp only [hx, hy, iff_true, ne.def, not_false_iff, and_self, mem_support]
rcases hy with ⟨k, rfl⟩
rw ←not_mem_support
{ simp only [hx, hy, iff_true, ne.def, not_false_iff, and_self, mem_support], rcases hy with ⟨k, rfl⟩, rw ←not_mem_support, simpa using hx }
simpa using hx
simpa [hx] using hy
obtain ⟨m, rfl⟩ := exists_add_of_le h
rw [add_comm, cycle_type_fin_rotate]
cases lt_or_ge j.cast_succ i with h h
rw [fin.succ_above_below _ _ h, fin.cycle_range_of_lt h, fin.coe_succ_eq_succ]
{ rw [fin.succ_above_below _ _ h, fin.cycle_range_of_lt h, fin.coe_succ_eq_succ] }
rw [fin.succ_above_above _ _ h, fin.cycle_range_of_gt (fin.le_cast_succ_iff.mp h)]
induction n with n ih
{ simp }
simp
simp [ih, pow_succ]
rw fin_rotate_succ
rw [gpow_neg_succ_of_nat, inv_eq_iff_eq, pow_apply_eq_self_of_apply_eq_self hfx]
rw [sup_eq_union, mem_union, mem_support, mem_support, mem_support, mul_apply, ←not_and_distrib, not_imp_not]
rintro ⟨hf, hg⟩
rw [hg, hf]
cases n
rw [int.of_nat_eq_coe, gpow_coe_nat, pow_apply_mem_support]
{ rw [int.of_nat_eq_coe, gpow_coe_nat, pow_apply_mem_support] }
rw [gpow_neg_succ_of_nat, ← support_inv, ← inv_pow, pow_apply_mem_support]
induction k with k hk
{ simp }
simp
intros x hx
rw [pow_succ', mul_apply, pow_succ', mul_apply, h _ hx, hk]
rwa [mem_inter, apply_mem_support, ←h _ hx, apply_mem_support, ←mem_inter]
simp [disjoint_iff_eq_or_eq, disjoint_iff, finset.ext_iff, not_and_distrib]
simp only [disjoint, or.comm, imp_self]
rw mul_normal H N at hy
rintro ⟨y, (hy : y ∈ ↑(H ⊔ N))⟩
rcases hy with ⟨h, n, hh, hn, rfl⟩
apply quotient.eq.mpr
change h⁻¹ * (h * n) ∈ N
use [h, hh]
rwa [←mul_assoc, inv_mul_self, one_mul]
simp [comap_comap, ←comap_ker]
simp [monoid_hom.mem_ker, eq_comm] {contextual := tt}
ext
ext; simp [*, monoid_hom.mem_ker] at *
simp [*, monoid_hom.mem_ker] at *
simp [*, monoid_hom.mem_ker] at *
rw is_solvable_def at *
cases h with n hn
use n
rw ← map_eq_bot_iff_of_injective _ hf
rw eq_bot_iff at *
calc map f (derived_series G n) ≤ derived_series G' n : map_derived_series_le_derived_series f n ... ≤ ⊥ : hn
introI Hn
refine or_not.imp (id) (λ Hb, _)
rw [eq_bot_iff_forall] at Hb
push_neg at Hb
obtain ⟨⟨g, gA⟩, gH, g1⟩ : ∃ (x : ↥(alternating_group (fin 5))), x ∈ H ∧ x ≠ 1 := Hb
rw [← set_like.mem_coe, ← set.singleton_subset_iff] at gH
refine eq_top_iff.2 (le_trans (ge_of_eq _) (normal_closure_le_normal gH))
by_cases h2 : ∀ n ∈ g.cycle_type, n = 2
rw [ne.def, subtype.ext_iff] at g1
exact (is_conj_swap_mul_swap_of_cycle_type_two gA g1 h2).normal_closure_eq_top_of normal_closure_swap_mul_swap_five
{ rw [ne.def, subtype.ext_iff] at g1, exact (is_conj_swap_mul_swap_of_cycle_type_two gA g1 h2).normal_closure_eq_top_of normal_closure_swap_mul_swap_five }
push_neg at h2
obtain ⟨n, ng, n2⟩ : ∃ (n : ℕ), n ∈ g.cycle_type ∧ n ≠ 2 := h2
have n2' : 2 < n := lt_of_le_of_ne (two_le_of_mem_cycle_type ng) n2.symm
have n5 : n ≤ 5 := le_trans _ g.support.card_le_univ
obtain ⟨m, hm⟩ := multiset.exists_cons_of_mem ng
swap
rw [← sum_cycle_type, hm, multiset.sum_cons]
{ obtain ⟨m, hm⟩ := multiset.exists_cons_of_mem ng, rw [← sum_cycle_type, hm, multiset.sum_cons], exact le_add_right (le_refl _) }
exact le_add_right (le_refl _)
interval_cases n
rw [eq_top_iff, ← (is_three_cycle_sq_of_three_mem_cycle_type_five ng).alternating_normal_closure (by rw card_fin )]
rw card_fin
refine normal_closure_le_normal _
rw [set.singleton_subset_iff, set_like.mem_coe]
have h := set_like.mem_coe.1 (subset_normal_closure (set.mem_singleton _))
{ rw [eq_top_iff, ← (is_three_cycle_sq_of_three_mem_cycle_type_five ng).alternating_normal_closure (by rw card_fin )], refine normal_closure_le_normal _, rw [set.singleton_subset_iff, set_like.mem_coe], have h := set_like.mem_coe.1 (subset_normal_closure (set.mem_singleton _)), exact mul_mem _ h h }
exact mul_mem _ h h
have con := mem_alternating_group.1 gA
contrapose! con
rw [sign_of_cycle_type, cycle_type_of_card_le_mem_cycle_type_add_two dec_trivial ng, multiset.map_singleton, multiset.prod_singleton]
{ have con := mem_alternating_group.1 gA, contrapose! con, rw [sign_of_cycle_type, cycle_type_of_card_le_mem_cycle_type_add_two dec_trivial ng, multiset.map_singleton, multiset.prod_singleton], dec_trivial }
dec_trivial
refine (is_conj_iff_cycle_type_eq.2 _).normal_closure_eq_top_of normal_closure_fin_rotate_five
rw [cycle_type_of_card_le_mem_cycle_type_add_two dec_trivial ng, cycle_type_fin_rotate]
rintros ⟨x, y, rfl⟩
apply subtype.ext
rw [coe_range_restrict, function.comp_apply, subgroup.coe_subtype, subtype.coe_mk, h]
rw [mem_inf, mem_sup] at ha
rcases ha with ⟨⟨b, hb, c, hc, rfl⟩, haz⟩
rw mem_sup
refine ⟨b, hb, c, mem_inf.2 ⟨hc, _⟩, rfl⟩
rw ← inv_mul_cancel_left b c
apply z.mul_mem (z.inv_mem (xz hb)) haz
rw set_like.ext'_iff
simp only [coe_bot, set.eq_singleton_iff_unique_mem, set_like.mem_coe, H.one_mem, true_and]
simp [mem_prod, monoid_hom.coe_snd]
revert a
refine add_submonoid.closure_induction hb _ _ _
refine add_submonoid.closure_induction hb _ _ _; clear hb b
clear hb b
clear hb b
clear hb b
{ exact λ r hr b hb, S.mul_right_mem_add_closure hb hr }
exact λ r hr b hb, S.mul_right_mem_add_closure hb hr
simp only [mul_zero, (add_submonoid.closure (S : set R)).zero_mem]
exact λ b hb, by simp only [mul_zero, (add_submonoid.closure (S : set R)).zero_mem]
{ exact λ b hb, by simp only [mul_zero, (add_submonoid.closure (S : set R)).zero_mem] }
simp_rw mul_add
exact λ r s hr hs b hb, (add_submonoid.closure (S : set R)).add_mem (hr hb) (hs hb)
rw ← coe_multiset_prod
exact m.prod.coe_prop
lift m to multiset S using hm
simp [mem_prod, monoid_hom.coe_fst]
rw [← fintype.card_congr (fixed_points_mul_left_cosets_equiv_quotient H)]
exact ((is_p_group.of_card hH).card_modeq_card_fixed_points _).symm
intros x hx
rw [← ideal.neg_mem_iff, ideal.mem_jacobson_bot]
intros y
rw add_comm
let f : ℕ → R := geom_sum (x * y)
have hf : ∀ m n, m ≤ n → f m ≡ f n [SMOD I ^ m • (⊤ : submodule R R)]
intros m n h
simp only [f, geom_sum_def, algebra.id.smul_eq_mul, ideal.mul_top, smodeq.sub_mem]
rw [← nat.add_sub_cancel' h, finset.sum_range_add, ← sub_sub, sub_self, zero_sub, neg_mem_iff]
apply submodule.sum_mem
intros n hn
rw [mul_pow, pow_add, mul_assoc]
exact ideal.mul_mem_right _ (I ^ m) (ideal.pow_mem_pow hx m)
{ intros m n h, simp only [f, geom_sum_def, algebra.id.smul_eq_mul, ideal.mul_top, smodeq.sub_mem], rw [← nat.add_sub_cancel' h, finset.sum_range_add, ← sub_sub, sub_self, zero_sub, neg_mem_iff], apply submodule.sum_mem, intros n hn, rw [mul_pow, pow_add, mul_assoc], exact ideal.mul_mem_right _ (I ^ m) (ideal.pow_mem_pow hx m) }
obtain ⟨L, hL⟩ := is_precomplete.prec to_is_precomplete hf
rw is_unit_iff_exists_inv
use L
rw [← sub_eq_zero, neg_mul_eq_neg_mul_symm]
apply is_Hausdorff.haus (to_is_Hausdorff : is_Hausdorff I R)
intros n
specialize hL n
rw [smodeq.sub_mem, algebra.id.smul_eq_mul, ideal.mul_top] at ⊢ hL
rw sub_zero
suffices : (1 - x * y) * (f n) - 1 ∈ I ^ n
convert (ideal.sub_mem _ this (ideal.mul_mem_left _ (1 + - (x * y)) hL)) using 1
{ convert (ideal.sub_mem _ this (ideal.mul_mem_left _ (1 + - (x * y)) hL)) using 1, ring }
ring
cases n
{ simp only [ideal.one_eq_top, pow_zero] }
simp only [ideal.one_eq_top, pow_zero]
dsimp [f]
rw [← neg_sub _ (1:R), neg_mul_eq_neg_mul_symm, mul_geom_sum, neg_sub, sub_sub, add_comm, ← sub_sub, sub_self, zero_sub, neg_mem_iff, mul_pow]
exact ideal.mul_mem_right _ (I ^ _) (ideal.pow_mem_pow hx _)
simp [h p']
simp [h (e'.symm (q' -ᵥ e p) +ᵥ p)]
simp [h p', h (v +ᵥ p'), vadd_vsub_assoc, vadd_vadd]
simp only [homothety_def, add_smul, vadd_vadd]
rw ← set.ne_empty_iff_nonempty
rintros rfl
rw affine_subspace.span_empty at h
exact bot_ne_top k V P h
by_contradiction h
rw set.not_nonempty_iff_eq_empty at h
have hlt := sup_direction_lt_of_nonempty_of_inter_empty h1 h2 h
rw hd at hlt
exact not_top_lt hlt
cases inter_nonempty_of_nonempty_of_sup_direction_eq_top h1 h2 hd.sup_eq_top with p hp
use p
ext q
rw set.mem_singleton_iff
split
rintros ⟨hq1, hq2⟩
have hqp : q -ᵥ p ∈ s1.direction ⊓ s2.direction := ⟨vsub_mem_direction hq1 hp.1, vsub_mem_direction hq2 hp.2⟩
rwa [hd.inf_eq_bot, submodule.mem_bot, vsub_eq_zero_iff_eq] at hqp
{ rintros ⟨hq1, hq2⟩, have hqp : q -ᵥ p ∈ s1.direction ⊓ s2.direction := ⟨vsub_mem_direction hq1 hp.1, vsub_mem_direction hq2 hp.2⟩, rwa [hd.inf_eq_bot, submodule.mem_bot, vsub_eq_zero_iff_eq] at hqp }
exact λ h, h.symm ▸ hp
simp [vector_span_eq_span_vsub_set_right_ne _ (finset.mem_coe.mpr hp)]
split
intros ha s1 s2 w1 w2 hw1 hw2 heq
ext i
by_cases hi : i ∈ (s1 ∪ s2)
rw ←sub_eq_zero
rw set.sum_indicator_subset _ (finset.subset_union_left s1 s2) at hw1
rw set.sum_indicator_subset _ (finset.subset_union_right s1 s2) at hw2
have hws : ∑ i in s1 ∪ s2, (set.indicator ↑s1 w1 - set.indicator ↑s2 w2) i = 0
{ simp [hw1, hw2] }
simp [hw1, hw2]
rw [finset.affine_combination_indicator_subset _ _ (finset.subset_union_left s1 s2), finset.affine_combination_indicator_subset _ _ (finset.subset_union_right s1 s2), ←@vsub_eq_zero_iff_eq V, finset.affine_combination_vsub] at heq
exact ha (s1 ∪ s2) (set.indicator ↑s1 w1 - set.indicator ↑s2 w2) hws heq i hi
{ rw ←sub_eq_zero, rw set.sum_indicator_subset _ (finset.subset_union_left s1 s2) at hw1, rw set.sum_indicator_subset _ (finset.subset_union_right s1 s2) at hw2, have hws : ∑ i in s1 ∪ s2, (set.indicator ↑s1 w1 - set.indicator ↑s2 w2) i = 0, { simp [hw1, hw2] }, rw [finset.affine_combination_indicator_subset _ _ (finset.subset_union_left s1 s2), finset.affine_combination_indicator_subset _ _ (finset.subset_union_right s1 s2), ←@vsub_eq_zero_iff_eq V, finset.affine_combination_vsub] at heq, exact ha (s1 ∪ s2) (set.indicator ↑s1 w1 - set.indicator ↑s2 w2) hws heq i hi }
rw [←finset.mem_coe, finset.coe_union] at hi
simp [mt (set.mem_union_left ↑s2) hi, mt (set.mem_union_right ↑s1) hi]
{ intros ha s1 s2 w1 w2 hw1 hw2 heq, ext i, by_cases hi : i ∈ (s1 ∪ s2), { rw ←sub_eq_zero, rw set.sum_indicator_subset _ (finset.subset_union_left s1 s2) at hw1, rw set.sum_indicator_subset _ (finset.subset_union_right s1 s2) at hw2, have hws : ∑ i in s1 ∪ s2, (set.indicator ↑s1 w1 - set.indicator ↑s2 w2) i = 0, { simp [hw1, hw2] }, rw [finset.affine_combination_indicator_subset _ _ (finset.subset_union_left s1 s2), finset.affine_combination_indicator_subset _ _ (finset.subset_union_right s1 s2), ←@vsub_eq_zero_iff_eq V, finset.affine_combination_vsub] at heq, exact ha (s1 ∪ s2) (set.indicator ↑s1 w1 - set.indicator ↑s2 w2) hws heq i hi }, { rw [←finset.mem_coe, finset.coe_union] at hi, simp [mt (set.mem_union_left ↑s2) hi, mt (set.mem_union_right ↑s1) hi] } }
intros ha s w hw hs i0 hi0
let w1 : ι → k := function.update (function.const ι 0) i0 1
have hw1 : ∑ i in s, w1 i = 1
{ rw [finset.sum_update_of_mem hi0, finset.sum_const_zero, add_zero] }
rw [finset.sum_update_of_mem hi0, finset.sum_const_zero, add_zero]
have hw1s : s.affine_combination p w1 = p i0 := s.affine_combination_of_eq_one_of_eq_zero w1 p hi0 (function.update_same _ _ _) (λ _ _ hne, function.update_noteq hne _ _)
let w2 := w + w1
have hw2 : ∑ i in s, w2 i = 1
{ simp [w2, finset.sum_add_distrib, hw, hw1] }
simp [w2, finset.sum_add_distrib, hw, hw1]
have hw2s : s.affine_combination p w2 = p i0
{ simp [w2, ←finset.weighted_vsub_vadd_affine_combination, hs, hw1s] }
simp [w2, ←finset.weighted_vsub_vadd_affine_combination, hs, hw1s]
replace ha := ha s s w2 w1 hw2 hw1 (hw1s.symm ▸ hw2s)
have hws : w2 i0 - w1 i0 = 0
rw ←finset.mem_coe at hi0
rw [←set.indicator_of_mem hi0 w2, ←set.indicator_of_mem hi0 w1, ha, sub_self]
{ rw ←finset.mem_coe at hi0, rw [←set.indicator_of_mem hi0 w2, ←set.indicator_of_mem hi0 w1, ha, sub_self] }
simpa [w2] using hws
simp [ha]
rw [← @vsub_eq_zero_iff_eq V, midpoint_vsub_midpoint, midpoint_eq_iff, point_reflection_apply, vsub_eq_sub, zero_sub, vadd_eq_add, add_zero, neg_eq_iff_neg_eq, neg_vsub_eq_vsub_rev, eq_comm]
rw [← line_map_apply_one_sub, ← line_map_apply_one_sub _ _ r]
generalize : 1 - r = r'
clear r
revert h
intro h
simp_rw [line_map_apply, slope, vsub_eq_sub, vadd_eq_add, smul_eq_mul]
rw [sub_add_eq_sub_sub_swap, sub_self, zero_sub, le_smul_iff_of_pos, inv_inv', smul_smul, neg_mul_eq_mul_neg, neg_sub, mul_inv_cancel_right', le_sub, ← neg_sub (f b), smul_neg, neg_add_eq_sub]
{ exact right_ne_zero_of_mul h.ne' }
exact right_ne_zero_of_mul h.ne'
simpa [mul_sub] using h
simp
haveI : nonempty s := hs.to_subtype
simp only [Sup_eq_supr', mem_supr_of_directed _ hdir.directed_coe, set_coe.exists, subtype.coe_mk]
apply span_induction h
exact ⟨1, by simp⟩
simp
{ rintro y (rfl|⟨⟨⟩⟩), exact ⟨1, by simp⟩ }
rintro y (rfl|⟨⟨⟩⟩)
simp
{ exact ⟨0, by simp⟩ }
exact ⟨0, by simp⟩
rintro _ _ ⟨a, rfl⟩ ⟨b, rfl⟩
simp [add_smul]
{ rintro _ _ ⟨a, rfl⟩ ⟨b, rfl⟩, exact ⟨a + b, by simp [add_smul]⟩ }
exact ⟨a + b, by simp [add_smul]⟩
rintro a _ ⟨b, rfl⟩
simp [smul_smul]
exact ⟨a * b, by simp [smul_smul]⟩
rintro ⟨a, y, rfl⟩; exact smul_mem _ _ (subset_span $ by simp)
exact smul_mem _ _ (subset_span $ by simp)
rintro ⟨a, y, rfl⟩
simp
rwa [submodule.map_comap_eq, inf_eq_right]
rw [of_le, ker_cod_restrict, ker_subtype]
split
rw submodule.mem_map
simp [←hx, hy]
{ rintros ⟨y, hy, hx⟩, simp [←hx, hy], }
rintros ⟨y, hy, hx⟩
refine ⟨e.symm x, hx, by simp⟩
simp
intros hx
rw [iterate_succ]
exact bijective.comp (iterate_bijective n) h
rw [linear_map.comp_apply, linear_map.comp_apply, h', h]
cases D
congr
funext
exact H _ _
cases B
simp only [pair_self_adjoint_matrices_submodule, linear_equiv.coe_coe, linear_map.to_matrix'_apply, submodule.mem_map, bilin_form.mem_is_pair_self_adjoint_submodule]
split
rintros ⟨f, hf, hA⟩
rw [←hA, matrix.to_lin'_to_matrix']
have hf' : f = A.to_lin' := by rw [←hA, matrix.to_lin'_to_matrix']
rw hf' at hf
rw ← is_adjoint_pair_to_bilin'
{ rintros ⟨f, hf, hA⟩, have hf' : f = A.to_lin' := by rw [←hA, matrix.to_lin'_to_matrix'], rw hf' at hf, rw ← is_adjoint_pair_to_bilin', exact hf, }
exact hf
refine ⟨A.to_lin', _, linear_map.to_matrix'_to_lin' _⟩
intros h
exact (is_adjoint_pair_to_bilin' _ _ _ _).mpr h
refine λ m hm, submodule.coe_eq_zero.1 (b₁ m.1 (λ n, _))
have : n ∈ (K ∙ x) ⊔ B.orthogonal (K ∙ x) := (span_singleton_sup_orthogonal_eq_top hx).symm ▸ submodule.mem_top
rcases submodule.mem_sup.1 this with ⟨y, hy, z, hz, rfl⟩
specialize hm ⟨z, hz⟩
rw restrict at hm
erw [add_right, show B m.1 y = 0, by rw b₂; exact m.2 y hy, hm, add_zero]
rw b₂
rw b₂; exact m.2 y hy
exact m.2 y hy
ext w
refine eq_of_sub_eq_zero (b _ _)
intro v
rw [sub_left, ← comp_left_apply, ← comp_left_apply, ← h, sub_self]
simp
ext A x y
rw [B.to_matrix_comp_right b, to_matrix_to_lin]
simp
simp [pow_add, involute_prod_map_ι xs]
rw [alg_equiv.map_mul, mul_comm, alg_equiv.map_mul]
rw [equiv_apply, equiv_apply, to_quaternion_involute_reverse, to_quaternion_of_quaternion, to_quaternion_of_quaternion]
simpa using lift_dim_map_le f p
rw ←dim_range_of_surjective f h
apply dim_range_le
rw @eq_comm _ j i
convert b.to_dual_apply i j using 2
rintro _ ⟨ψ, rfl⟩
simp_rw [submodule.mem_dual_annihilator, mem_ker]
rintro x hx
rw [dual_map_apply, hx, map_zero]
rw algebra.mul_sub_algebra_map_pow_commutes
haveI := span_of_finite K ⟨fin⟩
have : module.rank K (span K s) ≤ #s := dim_span_le s
rw [←finrank_eq_dim, cardinal.fintype_card, ←set.to_finset_card] at this
exact_mod_cast this
exact dim_top F E
rw subalgebra_top_dim_eq_submodule_top_dim
simp [mem_supported, subset_Inter_iff]
apply finsupp.induction_linear l; simp { contextual := tt, }
simp { contextual := tt, }
simp { contextual := tt, }
simp { contextual := tt, }
apply finsupp.induction_linear l
simp only [total_apply]
apply induction_linear f
{ simp only [sum_zero_index], }
simp only [sum_zero_index]
intros f₁ f₂ h₁ h₂
{ intros f₁ f₂ h₁ h₂, simp [sum_add_index, h₁, h₂, add_smul], }
simp [sum_add_index, h₁, h₂, add_smul]
simp [sum_single_index, sum_smul_index, smul_sum, mul_smul]
obtain ⟨f, hf, rfl⟩ : ∃ f ∈ finsupp.supported R R (⋃ i, ↑(p i)), finsupp.total M M R id f = m
have aux : (id : M → M) '' (⋃ (i : ι), ↑(p i)) = (⋃ (i : ι), ↑(p i)) := set.image_id _
rwa [supr_eq_span, ← aux, finsupp.mem_span_image_iff_total R] at hm
{ have aux : (id : M → M) '' (⋃ (i : ι), ↑(p i)) = (⋃ (i : ι), ↑(p i)) := set.image_id _, rwa [supr_eq_span, ← aux, finsupp.mem_span_image_iff_total R] at hm }
let t : finset M := f.support
have ht : ∀ x : {x // x ∈ t}, ∃ i, ↑x ∈ p i
intros x
rw finsupp.mem_supported at hf
specialize hf x.2
{ intros x, rw finsupp.mem_supported at hf, specialize hf x.2, rwa set.mem_Union at hf }
rwa set.mem_Union at hf
choose g hg using ht
let s : finset ι := finset.univ.image g
use s
simp only [mem_supr, supr_le_iff]
assume N hN
rw [finsupp.total_apply, finsupp.sum, ← set_like.mem_coe]
apply N.sum_mem
assume x hx
apply submodule.smul_mem
let i : ι := g ⟨x, hx⟩
rw finset.mem_image
have hi : i ∈ s
exact ⟨⟨x, hx⟩, finset.mem_univ _, rfl⟩
{ rw finset.mem_image, exact ⟨⟨x, hx⟩, finset.mem_univ _, rfl⟩ }
exact hN i hi (hg _)
ext ⟨j, y⟩
by_cases h : i = j
cases h
simp only [basis_repr, single_eq_same, basis.repr_self, basis.finsupp.single_apply_left sigma_mk_injective]
{ cases h, simp only [basis_repr, single_eq_same, basis.repr_self, basis.finsupp.single_apply_left sigma_mk_injective] }
simp only [basis_repr, single_apply, h, false_and, if_false, linear_equiv.map_zero, zero_apply]
simp only [finset.mem_sigma, mem_support_iff, and_iff_right_iff_imp, ne.def]
intros b hg
simpa [hg] using b
rw [ne.def, ← (b i).repr.injective.eq_iff, (b i).repr.apply_symm_apply, ext_iff]
simp only [exists_prop, linear_equiv.map_zero, comap_domain_apply, zero_apply, exists_and_distrib_right, mem_support_iff, exists_eq_right, sigma.exists, finset.mem_image, not_forall]
ext i
rw ← (b i).repr.injective.eq_iff
ext x
simp only [coe_mk, linear_equiv.apply_symm_apply, comap_domain_apply]
ext ⟨i, x⟩
simp only [coe_mk, linear_equiv.apply_symm_apply, comap_domain_apply]
ext ⟨i, x⟩
simp only [coe_mk, add_apply, linear_equiv.map_add]
ext ⟨i, x⟩
simp only [coe_mk, smul_apply, linear_equiv.map_smul, ring_hom.id_apply]
classical
exact of_equiv (linear_map.to_matrix (module.free.choose_basis R M) (module.free.choose_basis R N)).symm
exact ⟨x, hx, rfl⟩
rw [← mem_iff_generator_dvd, submodule.mem_map]
simpa using ortho (-1) x hx
intro hx
let a : R := generator (ϕ.submodule_image N)
let d : R := is_principal.generator (submodule.span R {a, ψ ⟨y, hNO yN⟩})
have d_dvd_left : d ∣ a := (mem_iff_generator_dvd _).mp (subset_span (mem_insert _ _))
have d_dvd_right : d ∣ ψ ⟨y, hNO yN⟩ := (mem_iff_generator_dvd _).mp (subset_span (mem_insert_of_mem _ (mem_singleton _)))
refine dvd_trans _ d_dvd_right
rw [dvd_generator_iff, ideal.span, ← span_singleton_generator (submodule.span R {a, ψ ⟨y, hNO yN⟩})]
obtain ⟨r₁, r₂, d_eq⟩ : ∃ r₁ r₂ : R, d = r₁ * a + r₂ * ψ ⟨y, hNO yN⟩
obtain ⟨r₁, r₂', hr₂', hr₁⟩ := mem_span_insert.mp (is_principal.generator_mem (submodule.span R {a, ψ ⟨y, hNO yN⟩}))
obtain ⟨r₂, rfl⟩ := mem_span_singleton.mp hr₂'
{ obtain ⟨r₁, r₂', hr₂', hr₁⟩ := mem_span_insert.mp (is_principal.generator_mem (submodule.span R {a, ψ ⟨y, hNO yN⟩})), obtain ⟨r₂, rfl⟩ := mem_span_singleton.mp hr₂', exact ⟨r₁, r₂, hr₁⟩ }
exact ⟨r₁, r₂, hr₁⟩
let ψ' : O →ₗ[R] R := r₁ • ϕ + r₂ • ψ
have : span R {d} ≤ ψ'.submodule_image N
rw [span_le, singleton_subset_iff, set_like.mem_coe, linear_map.mem_submodule_image_of_le hNO]
refine ⟨y, yN, _⟩
change r₁ * ϕ ⟨y, hNO yN⟩ + r₂ * ψ ⟨y, hNO yN⟩ = d
{ rw [span_le, singleton_subset_iff, set_like.mem_coe, linear_map.mem_submodule_image_of_le hNO], refine ⟨y, yN, _⟩, change r₁ * ϕ ⟨y, hNO yN⟩ + r₂ * ψ ⟨y, hNO yN⟩ = d, rw [d_eq, ϕy_eq] }
rw [d_eq, ϕy_eq]
refine le_antisymm (this.trans (le_of_eq _)) (ideal.span_singleton_le_span_singleton.mpr d_dvd_left)
rw span_singleton_generator
refine hϕ ψ' (le_trans _ this)
rw [← span_singleton_generator (ϕ.submodule_image N)]
exact ideal.span_singleton_le_span_singleton.mpr d_dvd_left
exact subset_span (mem_insert _ _)
rw submodule.eq_bot_iff
intros x hx
contrapose! rank_eq with x_ne
refine ⟨1, λ _, ⟨x, hx⟩, _, one_ne_zero⟩
rw fintype.linear_independent_iff
rintros g sum_eq i
fin_cases i
simp only [function.const_apply, fin.default_eq_zero, submodule.coe_mk, univ_unique, function.comp_const, finset.sum_singleton] at sum_eq
exact (b.smul_eq_zero.mp sum_eq).resolve_right x_ne
let P := linear_equiv.fun_congr_left R R (fintype.equiv_fin α)
let Q := linear_equiv.fun_congr_left R R (fintype.equiv_fin β)
exact le_of_fin_surjective R ((Q.symm.to_linear_map.comp f).comp P.to_linear_map) (((linear_equiv.symm Q).surjective.comp i).comp (linear_equiv.surjective P))
refine { to_fun := induced_map I e, inv_fun := induced_map I e.symm, .. }
rintro ⟨a⟩ ⟨b⟩
rintro ⟨a⟩ ⟨b⟩
rintro ⟨a⟩ ⟨b⟩
rintro ⟨a⟩ ⟨b⟩
rintro ⟨a⟩
rintro ⟨a⟩
all_goals { rintro ⟨a⟩ ⟨b⟩ <|> rintro ⟨a⟩, change ideal.quotient.mk _ _ = ideal.quotient.mk _ _, congr, simp }
change ideal.quotient.mk _ _ = ideal.quotient.mk _ _
change ideal.quotient.mk _ _ = ideal.quotient.mk _ _
change ideal.quotient.mk _ _ = ideal.quotient.mk _ _
change ideal.quotient.mk _ _ = ideal.quotient.mk _ _
simp
simp
simp
simp
congr
congr
congr
congr
rw [← ker_eq_bot, quotient_inf_to_sup_quotient, ker_liftq_eq_bot]
rw [ker_comp, ker_mkq]
exact λ ⟨x, hx1⟩ hx2, ⟨hx1, hx2⟩
rw [← range_eq_top, quotient_inf_to_sup_quotient, range_liftq, eq_top_iff']
rcases mem_sup.1 hx with ⟨y, hy, z, hz, rfl⟩
rintros ⟨x, hx⟩
apply (submodule.quotient.eq _).2
use [⟨y, hy⟩]
change y - (y + z) ∈ p'
rwa [sub_add_eq_sub_sub, sub_self, zero_sub, neg_mem_iff]
rw [basis, ← coe_eval_ring_hom, (eval_ring_hom x).map_prod, coe_eval_ring_hom, finset.prod_eq_one]
simp_rw [eval_mul, eval_sub, eval_C, eval_X]
intros y hy
exact inv_mul_cancel (sub_ne_zero_of_ne (finset.ne_of_mem_erase hy).symm)
nontriviality R
apply linear_independent.of_subtype_range
rintros ⟨x₁, x₂⟩ ⟨y₁, y₂⟩ hxy
by_cases h_cases : x₁ = y₁
subst h_cases
apply sigma.eq
rw linear_independent.injective (hindep _) hxy
{ apply sigma.eq, rw linear_independent.injective (hindep _) hxy, refl }
refl
have h0 : f x₁ x₂ = 0
apply disjoint_def.1 (hd x₁ {y₁} (finite_singleton y₁) (λ h, h_cases (eq_of_mem_singleton h))) (f x₁ x₂) (subset_span (mem_range_self _))
rw supr_singleton
simp only at hxy
rw hxy
{ apply disjoint_def.1 (hd x₁ {y₁} (finite_singleton y₁) (λ h, h_cases (eq_of_mem_singleton h))) (f x₁ x₂) (subset_span (mem_range_self _)), rw supr_singleton, simp only at hxy, rw hxy, exact (subset_span (mem_range_self y₂)) }
exact (subset_span (mem_range_self y₂))
{ rintros ⟨x₁, x₂⟩ ⟨y₁, y₂⟩ hxy, by_cases h_cases : x₁ = y₁, subst h_cases, { apply sigma.eq, rw linear_independent.injective (hindep _) hxy, refl }, { have h0 : f x₁ x₂ = 0, { apply disjoint_def.1 (hd x₁ {y₁} (finite_singleton y₁) (λ h, h_cases (eq_of_mem_singleton h))) (f x₁ x₂) (subset_span (mem_range_self _)), rw supr_singleton, simp only at hxy, rw hxy, exact (subset_span (mem_range_self y₂)) }, exact false.elim ((hindep x₁).ne_zero _ h0) } }
exact false.elim ((hindep x₁).ne_zero _ h0)
rw range_sigma_eq_Union_range
apply linear_independent_Union_finite_subtype (λ j, (hindep j).to_subtype_range) hd
have : ↑((linear_independent.total_equiv hv : (ι →₀ R) →ₗ[R] span R (range v)) l) = finsupp.total ι M R v l := rfl
have : (linear_independent.total_equiv hv : (ι →₀ R) →ₗ[R] span R (range v)) l = x
rw eq at this
{ rw eq at this, exact subtype.ext_iff.2 this }
exact subtype.ext_iff.2 this
rw ←linear_equiv.symm_apply_apply hv.total_equiv l
rw ←this
refl
rw [hc, zero_smul]
rw basis.to_matrix
ext i j
simp [basis.equiv_fun, matrix.one_apply, finsupp.single, eq_comm]
rw [charpoly, det_apply', ← insert_erase (mem_univ (equiv.refl n)), sum_insert (not_mem_erase (equiv.refl n) univ), add_comm]
simp only [charmatrix_apply_eq, one_mul, equiv.perm.sign_refl, id.def, int.cast_one, units.coe_one, add_sub_cancel, equiv.coe_refl]
apply submodule.sum_mem (degree_lt R (fintype.card n - 1))
rw ← mem_degree_lt
rw [← C_eq_int_cast, C_mul']
intros c hc
apply submodule.smul_mem (degree_lt R (fintype.card n - 1)) ↑↑(equiv.perm.sign c)
apply lt_of_le_of_lt degree_le_nat_degree _
rw mem_degree_lt
rw with_bot.coe_lt_coe
apply lt_of_le_of_lt _ (equiv.perm.fixed_point_card_lt_of_ne_one (ne_of_mem_erase hc))
apply le_trans (polynomial.nat_degree_prod_le univ (λ i : n, (charmatrix M (c i) i))) _
rw sum_filter
apply sum_le_sum
rw card_eq_sum_ones
apply charmatrix_apply_nat_degree_le
intros
ext i j
simp [pi.single_apply, one_apply, sub_eq_zero]
rw [← det_transpose, ← update_row_transpose, ← det_transpose A]
exact det_update_row_add_self Aᵀ hij
rcases nonsing_inv_cancel_or_zero A with ⟨h, h'⟩ | h
{ exact fpow_add (is_unit_det_of_left_inverse h) m n }
exact fpow_add (is_unit_det_of_left_inverse h) m n
obtain ⟨k, rfl⟩ := eq_coe_of_zero_le hm
obtain ⟨l, rfl⟩ := eq_coe_of_zero_le hn
rw [←int.coe_nat_add, fpow_coe_nat, fpow_coe_nat, fpow_coe_nat, pow_add]
simp [← int.coe_nat_succ, pow_succ']
rcases nonsing_inv_cancel_or_zero A with ⟨h, h'⟩ | h
{ apply fpow_add_one (is_unit_det_of_left_inverse h) }
apply fpow_add_one (is_unit_det_of_left_inverse h)
show A ^ (-((n + 1 : ℕ) : ℤ)) = A ^ -((n + 2 : ℕ) : ℤ) * A
simp_rw [fpow_neg_coe_nat, ←inv_pow', h, zero_pow nat.succ_pos', zero_mul]
simp only [one_div, inv_fpow]
rintros ⟨a, b⟩ ⟨c, d⟩ h
simp only [prod.mk.inj_iff, ne.def, not_and_distrib] at h
cases h with hac hbd
{ simp [hA hac] }
simp [hA hac]
simp [hB hbd]
ext i j
rw [mul_apply, pi.smul_apply, pi.smul_apply, one_apply, smul_eq_mul, mul_boole]
simp [mul_adjugate_apply, sum_cramer_apply, cramer_transpose_row_self, pi.single_apply, eq_comm]
simp_rw [linear_map.to_matrix, linear_equiv.trans_apply, linear_equiv.arrow_congr_comp _ v₂.equiv_fun, linear_map.to_matrix'_comp]
induction L with t L IH
{ simp }
simp
simp only [to_matrix_reindex_equiv, IH, function.comp_app, list.prod_cons, mul_eq_mul, reindex_alg_equiv_apply, list.map]
exact (reindex_alg_equiv_mul _ _ _ _).symm
induction hn : fintype.card n with r IH generalizing n M
unfreezingI { induction hn : fintype.card n with r IH generalizing n M }
refine ⟨list.nil, list.nil, λ _, 1, _⟩
ext i j
rw fintype.card_eq_zero_iff at hn
{ refine ⟨list.nil, list.nil, λ _, 1, _⟩, ext i j, rw fintype.card_eq_zero_iff at hn, exact hn.elim' i }
exact hn.elim' i
have e : n ≃ fin r ⊕ unit
refine fintype.equiv_of_card_eq _
rw hn
convert (@fintype.card_sum (fin r) unit _ _).symm
{ refine fintype.equiv_of_card_eq _, rw hn, convert (@fintype.card_sum (fin r) unit _ _).symm, simp }
simp
apply reindex_exists_list_transvec_mul_mul_list_transvec_eq_diagonal M e
apply exists_list_transvec_mul_mul_list_transvec_eq_diagonal_induction (λ N, IH (fin r) N (by simp))
simp
rcases exists_list_transvec_mul_diagonal_mul_list_transvec M with ⟨L, L', D, h⟩
have PD : P (diagonal D) := hdiag D (by simp [h])
simp [h]
suffices H : ∀ (L₁ L₂ : list (transvection_struct n 𝕜)) (E : matrix n n 𝕜), P E → P ((L₁.map to_matrix).prod ⬝ E ⬝ (L₂.map to_matrix).prod)
rw h
apply H L L'
exact PD
assume L₁ L₂ E PE
induction L₁ with t L₁ IH
simp only [matrix.one_mul, list.prod_nil, list.map]
induction L₂ with t L₂ IH generalizing E
{ simpa }
simpa
simp only [←matrix.mul_assoc, list.prod_cons, mul_eq_mul, list.map]
apply IH
{ simp only [matrix.one_mul, list.prod_nil, list.map], induction L₂ with t L₂ IH generalizing E, { simpa }, { simp only [←matrix.mul_assoc, list.prod_cons, mul_eq_mul, list.map], apply IH, exact hmul _ _ PE (htransvec _) } }
exact hmul _ _ PE (htransvec _)
simp only [matrix.mul_assoc, list.prod_cons, mul_eq_mul, list.map] at ⊢ IH
exact hmul _ _ (htransvec _) IH
ext m
refl
ext m
rw [smul_apply]
refl
simp only [← sum.update_elim_inr, f.map_add]
simp only [← sum.update_elim_inr, f.map_smul]
simp only [multilinear_map.coe_mk, add_apply, ← sum.update_elim_inl, f.map_add]
simp only [multilinear_map.coe_mk, smul_apply, ← sum.update_elim_inl, f.map_smul]
induction n using nat.strong_induction_on with n IH generalizing A
by_cases Ai_empty : ∃ i, A i = ∅
rcases Ai_empty with ⟨i, hi⟩
convert sum_empty
have : ∑ j in A i, g i j = 0
rw f.map_coord_zero i this
have : pi_finset A = ∅
apply finset.eq_empty_of_forall_not_mem (λ r hr, _)
have : r i ∈ A i := mem_pi_finset.mp hr i
{ apply finset.eq_empty_of_forall_not_mem (λ r hr, _), have : r i ∈ A i := mem_pi_finset.mp hr i, rwa hi at this }
rwa hi at this
{ rcases Ai_empty with ⟨i, hi⟩, have : ∑ j in A i, g i j = 0, by convert sum_empty, rw f.map_coord_zero i this, have : pi_finset A = ∅, { apply finset.eq_empty_of_forall_not_mem (λ r hr, _), have : r i ∈ A i := mem_pi_finset.mp hr i, rwa hi at this }, convert sum_empty.symm }
convert sum_empty.symm
push_neg at Ai_empty
by_cases Ai_singleton : ∀ i, (A i).card ≤ 1
have Ai_card : ∀ i, (A i).card = 1
assume i
simp [finset.card_eq_zero, Ai_empty i]
have pos : finset.card (A i) ≠ 0
have : finset.card (A i) ≤ 1 := Ai_singleton i
exact le_antisymm this (nat.succ_le_of_lt (_root_.pos_iff_ne_zero.mpr pos))
{ assume i, have pos : finset.card (A i) ≠ 0, by simp [finset.card_eq_zero, Ai_empty i], have : finset.card (A i) ≤ 1 := Ai_singleton i, exact le_antisymm this (nat.succ_le_of_lt (_root_.pos_iff_ne_zero.mpr pos)) }
have : ∀ (r : Π i, α i), r ∈ pi_finset A → f (λ i, g i (r i)) = f (λ i, ∑ j in A i, g i j)
assume r hr
unfold_coes
congr' with i
have : ∀ j ∈ A i, g i j = g i (r i)
assume j hj
congr
apply finset.card_le_one_iff.1 (Ai_singleton i) hj
{ assume j hj, congr, apply finset.card_le_one_iff.1 (Ai_singleton i) hj, exact mem_pi_finset.mp hr i }
exact mem_pi_finset.mp hr i
simp only [finset.sum_congr rfl this, finset.mem_univ, finset.sum_const, Ai_card i, one_nsmul]
{ assume r hr, unfold_coes, congr' with i, have : ∀ j ∈ A i, g i j = g i (r i), { assume j hj, congr, apply finset.card_le_one_iff.1 (Ai_singleton i) hj, exact mem_pi_finset.mp hr i }, simp only [finset.sum_congr rfl this, finset.mem_univ, finset.sum_const, Ai_card i, one_nsmul] }
simp only [sum_congr rfl this, Ai_card, card_pi_finset, prod_const_one, one_nsmul, finset.sum_const]
{ have Ai_card : ∀ i, (A i).card = 1, { assume i, have pos : finset.card (A i) ≠ 0, by simp [finset.card_eq_zero, Ai_empty i], have : finset.card (A i) ≤ 1 := Ai_singleton i, exact le_antisymm this (nat.succ_le_of_lt (_root_.pos_iff_ne_zero.mpr pos)) }, have : ∀ (r : Π i, α i), r ∈ pi_finset A → f (λ i, g i (r i)) = f (λ i, ∑ j in A i, g i j), { assume r hr, unfold_coes, congr' with i, have : ∀ j ∈ A i, g i j = g i (r i), { assume j hj, congr, apply finset.card_le_one_iff.1 (Ai_singleton i) hj, exact mem_pi_finset.mp hr i }, simp only [finset.sum_congr rfl this, finset.mem_univ, finset.sum_const, Ai_card i, one_nsmul] }, simp only [sum_congr rfl this, Ai_card, card_pi_finset, prod_const_one, one_nsmul, finset.sum_const] }
push_neg at Ai_singleton
obtain ⟨i₀, hi₀⟩ : ∃ i, 1 < (A i).card := Ai_singleton
obtain ⟨j₁, j₂, hj₁, hj₂, j₁_ne_j₂⟩ : ∃ j₁ j₂, (j₁ ∈ A i₀) ∧ (j₂ ∈ A i₀) ∧ j₁ ≠ j₂ := finset.one_lt_card_iff.1 hi₀
let B := function.update A i₀ (A i₀ \ {j₂})
let C := function.update A i₀ {j₂}
have B_subset_A : ∀ i, B i ⊆ A i
assume i
by_cases hi : i = i₀
simp only [B, sdiff_subset, update_same]
{ rw hi, simp only [B, sdiff_subset, update_same]}
rw hi
simp only [hi, B, update_noteq, ne.def, not_false_iff, finset.subset.refl]
{ assume i, by_cases hi : i = i₀, { rw hi, simp only [B, sdiff_subset, update_same]}, { simp only [hi, B, update_noteq, ne.def, not_false_iff, finset.subset.refl] } }
have C_subset_A : ∀ i, C i ⊆ A i
assume i
by_cases hi : i = i₀
simp only [C, hj₂, finset.singleton_subset_iff, update_same]
{ rw hi, simp only [C, hj₂, finset.singleton_subset_iff, update_same] }
rw hi
simp only [hi, C, update_noteq, ne.def, not_false_iff, finset.subset.refl]
{ assume i, by_cases hi : i = i₀, { rw hi, simp only [C, hj₂, finset.singleton_subset_iff, update_same] }, { simp only [hi, C, update_noteq, ne.def, not_false_iff, finset.subset.refl] } }
have A_eq_BC : (λ i, ∑ j in A i, g i j) = function.update (λ i, ∑ j in A i, g i j) i₀ (∑ j in B i₀, g i₀ j + ∑ j in C i₀, g i₀ j)
ext i
by_cases hi : i = i₀
rw [hi]
simp only [function.update_same]
have : A i₀ = B i₀ ∪ C i₀
simp only [B, C, function.update_same, finset.sdiff_union_self_eq_union]
symmetry
{ simp only [B, C, function.update_same, finset.sdiff_union_self_eq_union], symmetry, simp only [hj₂, finset.singleton_subset_iff, finset.union_eq_left_iff_subset] }
simp only [hj₂, finset.singleton_subset_iff, finset.union_eq_left_iff_subset]
rw this
apply finset.sum_union
apply finset.disjoint_right.2 (λ j hj, _)
dsimp [C] at hj
simpa using hj
have : j = j₂
rw this
dsimp [B]
simp only [mem_sdiff, eq_self_iff_true, not_true, not_false_iff, finset.mem_singleton, update_same, and_false]
{ rw [hi], simp only [function.update_same], have : A i₀ = B i₀ ∪ C i₀, { simp only [B, C, function.update_same, finset.sdiff_union_self_eq_union], symmetry, simp only [hj₂, finset.singleton_subset_iff, finset.union_eq_left_iff_subset] }, rw this, apply finset.sum_union, apply finset.disjoint_right.2 (λ j hj, _), have : j = j₂, by { dsimp [C] at hj, simpa using hj }, rw this, dsimp [B], simp only [mem_sdiff, eq_self_iff_true, not_true, not_false_iff, finset.mem_singleton, update_same, and_false] }
{ ext i, by_cases hi : i = i₀, { rw [hi], simp only [function.update_same], have : A i₀ = B i₀ ∪ C i₀, { simp only [B, C, function.update_same, finset.sdiff_union_self_eq_union], symmetry, simp only [hj₂, finset.singleton_subset_iff, finset.union_eq_left_iff_subset] }, rw this, apply finset.sum_union, apply finset.disjoint_right.2 (λ j hj, _), have : j = j₂, by { dsimp [C] at hj, simpa using hj }, rw this, dsimp [B], simp only [mem_sdiff, eq_self_iff_true, not_true, not_false_iff, finset.mem_singleton, update_same, and_false] }, { simp [hi] } }
simp [hi]
have Beq : function.update (λ i, ∑ j in A i, g i j) i₀ (∑ j in B i₀, g i₀ j) = (λ i, ∑ j in B i, g i j)
ext i
by_cases hi : i = i₀
simp only [update_same]
{ rw hi, simp only [update_same] }
rw hi
{ ext i, by_cases hi : i = i₀, { rw hi, simp only [update_same] }, { simp only [hi, B, update_noteq, ne.def, not_false_iff] } }
simp only [hi, B, update_noteq, ne.def, not_false_iff]
have Ceq : function.update (λ i, ∑ j in A i, g i j) i₀ (∑ j in C i₀, g i₀ j) = (λ i, ∑ j in C i, g i j)
ext i
by_cases hi : i = i₀
simp only [update_same]
{ rw hi, simp only [update_same] }
rw hi
{ ext i, by_cases hi : i = i₀, { rw hi, simp only [update_same] }, { simp only [hi, C, update_noteq, ne.def, not_false_iff] } }
simp only [hi, C, update_noteq, ne.def, not_false_iff]
have Brec : f (λ i, ∑ j in B i, g i j) = ∑ r in pi_finset B, f (λ i, g i (r i))
have : ∑ i, finset.card (B i) < ∑ i, finset.card (A i)
refine finset.sum_lt_sum (λ i hi, finset.card_le_of_subset (B_subset_A i)) ⟨i₀, finset.mem_univ _, _⟩
simp [hj₂]
have : {j₂} ⊆ A i₀
simp only [B, finset.card_sdiff this, function.update_same, finset.card_singleton]
{ refine finset.sum_lt_sum (λ i hi, finset.card_le_of_subset (B_subset_A i)) ⟨i₀, finset.mem_univ _, _⟩, have : {j₂} ⊆ A i₀, by simp [hj₂], simp only [B, finset.card_sdiff this, function.update_same, finset.card_singleton], exact nat.pred_lt (ne_of_gt (lt_trans nat.zero_lt_one hi₀)) }
exact nat.pred_lt (ne_of_gt (lt_trans nat.zero_lt_one hi₀))
rw h at this
{ have : ∑ i, finset.card (B i) < ∑ i, finset.card (A i), { refine finset.sum_lt_sum (λ i hi, finset.card_le_of_subset (B_subset_A i)) ⟨i₀, finset.mem_univ _, _⟩, have : {j₂} ⊆ A i₀, by simp [hj₂], simp only [B, finset.card_sdiff this, function.update_same, finset.card_singleton], exact nat.pred_lt (ne_of_gt (lt_trans nat.zero_lt_one hi₀)) }, rw h at this, exact IH _ this B rfl }
exact IH _ this B rfl
have Crec : f (λ i, ∑ j in C i, g i j) = ∑ r in pi_finset C, f (λ i, g i (r i))
have : ∑ i, finset.card (C i) < ∑ i, finset.card (A i) := finset.sum_lt_sum (λ i hi, finset.card_le_of_subset (C_subset_A i)) ⟨i₀, finset.mem_univ _, by simp [C, hi₀]⟩
simp [C, hi₀]
rw h at this
{ have : ∑ i, finset.card (C i) < ∑ i, finset.card (A i) := finset.sum_lt_sum (λ i hi, finset.card_le_of_subset (C_subset_A i)) ⟨i₀, finset.mem_univ _, by simp [C, hi₀]⟩, rw h at this, exact IH _ this C rfl }
exact IH _ this C rfl
have D : disjoint (pi_finset B) (pi_finset C)
simp [B, C]
have : disjoint (B i₀) (C i₀)
{ have : disjoint (B i₀) (C i₀), by simp [B, C], exact pi_finset_disjoint_of_disjoint B C this }
exact pi_finset_disjoint_of_disjoint B C this
have pi_BC : pi_finset A = pi_finset B ∪ pi_finset C
apply finset.subset.antisymm
assume r hr
by_cases hri₀ : r i₀ = j₂
apply finset.mem_union_right
apply mem_pi_finset.2 (λ i, _)
by_cases hi : i = i₀
have : r i₀ ∈ C i₀
simp [C, hri₀]
convert this
{ have : r i₀ ∈ C i₀, by simp [C, hri₀], convert this }
simp [C, hi, mem_pi_finset.1 hr i]
{ apply finset.mem_union_right, apply mem_pi_finset.2 (λ i, _), by_cases hi : i = i₀, { have : r i₀ ∈ C i₀, by simp [C, hri₀], convert this }, { simp [C, hi, mem_pi_finset.1 hr i] } }
apply finset.mem_union_left
apply mem_pi_finset.2 (λ i, _)
by_cases hi : i = i₀
have : r i₀ ∈ B i₀
simp [B, hri₀, mem_pi_finset.1 hr i₀]
convert this
{ have : r i₀ ∈ B i₀, by simp [B, hri₀, mem_pi_finset.1 hr i₀], convert this }
simp [B, hi, mem_pi_finset.1 hr i]
{ assume r hr, by_cases hri₀ : r i₀ = j₂, { apply finset.mem_union_right, apply mem_pi_finset.2 (λ i, _), by_cases hi : i = i₀, { have : r i₀ ∈ C i₀, by simp [C, hri₀], convert this }, { simp [C, hi, mem_pi_finset.1 hr i] } }, { apply finset.mem_union_left, apply mem_pi_finset.2 (λ i, _), by_cases hi : i = i₀, { have : r i₀ ∈ B i₀, by simp [B, hri₀, mem_pi_finset.1 hr i₀], convert this }, { simp [B, hi, mem_pi_finset.1 hr i] } } }
exact finset.union_subset (pi_finset_subset _ _ (λ i, B_subset_A i)) (pi_finset_subset _ _ (λ i, C_subset_A i))
{ apply finset.subset.antisymm, { assume r hr, by_cases hri₀ : r i₀ = j₂, { apply finset.mem_union_right, apply mem_pi_finset.2 (λ i, _), by_cases hi : i = i₀, { have : r i₀ ∈ C i₀, by simp [C, hri₀], convert this }, { simp [C, hi, mem_pi_finset.1 hr i] } }, { apply finset.mem_union_left, apply mem_pi_finset.2 (λ i, _), by_cases hi : i = i₀, { have : r i₀ ∈ B i₀, by simp [B, hri₀, mem_pi_finset.1 hr i₀], convert this }, { simp [B, hi, mem_pi_finset.1 hr i] } } }, { exact finset.union_subset (pi_finset_subset _ _ (λ i, B_subset_A i)) (pi_finset_subset _ _ (λ i, C_subset_A i)) } }
rw A_eq_BC
simp only [multilinear_map.map_add, Beq, Ceq, Brec, Crec, pi_BC]
rw ← finset.sum_union D
simp [pi_ring, linear_map.lsum]
ext
ext; simp
simp
apply le_antisymm _ (ker_prod_ker_le_ker_coprod f g)
rintros ⟨y, z⟩ h
simp only [mem_ker, mem_prod, coprod_apply] at h ⊢
have : f y ∈ f.range ⊓ g.range
simp only [true_and, mem_range, mem_inf, exists_apply_eq_apply]
use -z
{ simp only [true_and, mem_range, mem_inf, exists_apply_eq_apply], use -z, rwa [eq_comm, map_neg, ← sub_eq_zero, sub_neg_eq_add] }
rwa [eq_comm, map_neg, ← sub_eq_zero, sub_neg_eq_add]
rw [hd.eq_bot, mem_bot] at this
rw [this] at h
simpa [this] using h
ext x
have : x ∈ p ⊔ f.ker
{ simp only [(is_compl_of_proj hf).sup_eq_top, mem_top] }
simp only [(is_compl_of_proj hf).sup_eq_top, mem_top]
rcases mem_sup'.1 this with ⟨x, y, rfl⟩
simp [hf]
rw [←neg_sub, map_neg]
rw [polar_comm, polar_add_left, polar_comm f y x, polar_comm f y' x]
rw [polar_comm, polar_smul_left, polar_comm f y x, smul_eq_mul]
simp only [discr, to_matrix'_smul, matrix.det_smul]
have hw' : ∀ i : ι, (w i : ℂ) ^ - (1 / 2 : ℂ) ≠ 0
intros i hi
exact (w i).ne_zero ((complex.cpow_eq_zero_iff _ _).1 hi).1
{ intros i hi, exact (w i).ne_zero ((complex.cpow_eq_zero_iff _ _).1 hi).1 }
convert (weighted_sum_squares ℂ w).isometry_basis_repr ((pi.basis_fun ℂ ι).units_smul (λ i, (is_unit_iff_ne_zero.2 $ hw' i).unit))
ext1 v
erw [basis_repr_apply, weighted_sum_squares_apply, weighted_sum_squares_apply]
refine sum_congr rfl (λ j hj, _)
have hsum : (∑ (i : ι), v i • ((is_unit_iff_ne_zero.2 $ hw' i).unit : ℂ) • (pi.basis_fun ℂ ι) i) j = v j • w j ^ - (1 / 2 : ℂ)
rw [finset.sum_apply, sum_eq_single j, pi.basis_fun_apply, is_unit.unit_spec, linear_map.std_basis_apply, pi.smul_apply, pi.smul_apply, function.update_same, smul_eq_mul, smul_eq_mul, smul_eq_mul, mul_one]
intros i _ hij
rw [pi.basis_fun_apply, linear_map.std_basis_apply, pi.smul_apply, pi.smul_apply, function.update_noteq hij.symm, pi.zero_apply, smul_eq_mul, smul_eq_mul, mul_zero, mul_zero]
exact false.elim (hj' hj)
{ rw [finset.sum_apply, sum_eq_single j, pi.basis_fun_apply, is_unit.unit_spec, linear_map.std_basis_apply, pi.smul_apply, pi.smul_apply, function.update_same, smul_eq_mul, smul_eq_mul, smul_eq_mul, mul_one], intros i _ hij, rw [pi.basis_fun_apply, linear_map.std_basis_apply, pi.smul_apply, pi.smul_apply, function.update_noteq hij.symm, pi.zero_apply, smul_eq_mul, smul_eq_mul, mul_zero, mul_zero], intro hj', exact false.elim (hj' hj) }
intro hj'
simp_rw basis.units_smul_apply
erw [hsum, smul_eq_mul]
suffices : 1 * v j * v j = w j ^ - (1 / 2 : ℂ) * w j ^ - (1 / 2 : ℂ) * w j * v j * v j
erw [pi.one_apply, ← mul_assoc, this, smul_eq_mul, smul_eq_mul]
ring
{ erw [pi.one_apply, ← mul_assoc, this, smul_eq_mul, smul_eq_mul], ring }
rw [← complex.cpow_add _ _ (w j).ne_zero, show - (1 / 2 : ℂ) + - (1 / 2) = -1, by ring, complex.cpow_neg_one, inv_mul_cancel (w j).ne_zero]
ring
intros
ext
unfold coe_fn has_coe_to_fun.coe sesq coe_fn has_coe_to_fun.coe sesq
rw add_assoc
intros
ext
unfold coe_fn has_coe_to_fun.coe sesq
rw zero_add
intros
ext
unfold coe_fn has_coe_to_fun.coe sesq
rw add_zero
intros
ext
unfold coe_fn has_coe_to_fun.coe sesq
rw neg_add_self
intros
ext
unfold coe_fn has_coe_to_fun.coe sesq
rw add_comm
simp [add_left]
simp [smul_left]
simp [add_right]
simp [smul_right]
rw [←zero_smul R (0 : M), smul_left, zero_mul]
ext a b
by_cases hi : i = a; by_cases hj : j = b
by_cases hj : j = b
by_cases hj : j = b
by_cases hi : i = a
{ simp [std_basis, hi, hj] }
simp [std_basis, hi, hj]
simp [std_basis, hi, hj, ne.symm hj, linear_map.std_basis_ne]
{ simp [std_basis, hi, hj, ne.symm hj, linear_map.std_basis_ne] }
simp [std_basis, hi, hj, ne.symm hi, linear_map.std_basis_ne]
{ simp [std_basis, hi, hj, ne.symm hi, linear_map.std_basis_ne] }
simp [std_basis, hi, hj, ne.symm hj, ne.symm hi, linear_map.std_basis_ne]
simp [decidable.imp_iff_not_or, or.comm, or.left_comm]
simp [@eq_comm _ a']
intros x y h
dsimp at h
split_ifs at h; try { substI b }; try { simp only [f.injective.eq_iff] at * }; cc
split_ifs at h; try { substI b }; try { simp only [f.injective.eq_iff] at * }
split_ifs at h; try { substI b }
try { substI b }
try { substI b }
try { substI b }
try { substI b }
try { substI b }
try { substI b }
try { substI b }
try { substI b }
try { substI b }
substI b
try { simp only [f.injective.eq_iff] at * }
try { simp only [f.injective.eq_iff] at * }
try { simp only [f.injective.eq_iff] at * }
try { simp only [f.injective.eq_iff] at * }
try { simp only [f.injective.eq_iff] at * }
try { simp only [f.injective.eq_iff] at * }
try { simp only [f.injective.eq_iff] at * }
try { simp only [f.injective.eq_iff] at * }
try { simp only [f.injective.eq_iff] at * }
simp only [f.injective.eq_iff] at *
split_ifs at h
cc
cc
cc
cc
cc
cc
cc
cc
cc
subst hα
have : ∀a, f a == f' a
exact h a a (heq.refl a)
{ intro a, exact h a a (heq.refl a) }
intro a
have : β = β'
exact type_eq_of_heq (this a)
{ funext a, exact type_eq_of_heq (this a) }
funext a
subst this
apply heq_of_eq
funext a
exact eq_of_heq (this a)
rw [nat.add_succ, iterate_succ, iterate_succ, iterate_add]
rcases exists_pair_ne α with ⟨y, y', h⟩
by_cases hx : x = y
rw ← hx at h
{ rw ← hx at h, exact ⟨y', h.symm⟩ }
exact ⟨y', h.symm⟩
exact ⟨y, ne.symm hx⟩
intros x y h
induction h with z w a b c
{ refl }
refl
apply relation.refl_trans_gen.head (h b) c
induction h generalizing P
exact refl
case refl_trans_gen.refl { exact refl }
case refl_trans_gen.tail : b c hab hbc ih { apply ih, show P b _, from head hbc _ refl, show ∀ a a', r a a' → refl_trans_gen r a' b → P a' _ → P a _, from λ a a' hab hbc, head hab _ }
apply ih
from head hbc _ refl
show P b _
show ∀ a a', r a a' → refl_trans_gen r a' b → P a' _ → P a _
from λ a a' hab hbc, head hab _
refine (top_le_iff.1 $ λ s hs, bUnion_of_singleton s ▸ _)
apply measurable_set.bUnion s.countable_encodable
intros x hx
casesI is_empty_or_nonempty β
haveI := function.is_empty f
simp only [(measurable_of_empty (g ∘ f)).ae_measurable, (measurable_of_empty f).ae_measurable]
{ haveI := function.is_empty f, simp only [(measurable_of_empty (g ∘ f)).ae_measurable, (measurable_of_empty f).ae_measurable] }
refine ⟨λ hf, _, λ hf, hg.measurable.comp_ae_measurable hf⟩
convert hg.measurable_inv_fun.comp_ae_measurable hf
ext x
apply measurable_set.of_compl
exact (function.left_inverse_inv_fun hg.to_embedding.inj (f x)).symm
apply generate_measurable.basic
exact is_closed_singleton.is_open_compl
rw hμ
exact ae_measurable_zero_measure
by_cases hμ : μ = 0
{ rw hμ, exact ae_measurable_zero_measure }
simpa [ne_bot_iff]
haveI : μ.ae.ne_bot
{ simpa [ne_bot_iff] }
exact ae_measurable.is_lub_of_nonempty hι hf hg
by_cases hι : nonempty ι
{ exact ae_measurable.is_lub_of_nonempty hι hf hg, }
suffices : ∃ x, g =ᵐ[μ] λ y, g x
exact ⟨(λ y, g this.some), measurable_const, this.some_spec⟩
have h_empty : ∀ x, {a : α | ∃ (i : ι), f i x = a} = ∅
intro x
ext1 y
rw [set.mem_set_of_eq, set.mem_empty_eq, iff_false]
{ intro x, ext1 y, rw [set.mem_set_of_eq, set.mem_empty_eq, iff_false], exact λ hi, hι (nonempty_of_exists hi), }
exact λ hi, hι (nonempty_of_exists hi)
simp_rw h_empty at hg
exact ⟨hg.exists.some, hg.mono (λ y hy, is_lub.unique hy hg.exists.some_spec)⟩
simp_rw [hu.to_has_basis.liminf_eq_supr_infi]
refine measurable_bsupr _ hu.countable _
exact λ i, measurable_binfi _ (hs i) hf
rw [← funext hC, generate_from_pi_eq h2C]
exact pi_Ico_ae_eq_pi_Icc
rw ← pi_univ_Icc
convert set_integral_fun_unique_pi' ι volume f s
refine prod_eq (λ s t hs ht, _)
simp_rw [map_apply measurable_prod_mk_left (hs.prod ht), mk_preimage_prod_right_eq_if, measure_if, dirac_apply' _ hs, ← indicator_mul_left _ _ (λ x, ν t), pi.one_apply, one_mul]
ext1 i hi
rw [vector_measure.smul_apply, to_signed_measure, to_signed_measure, to_signed_measure_sub_apply hi, to_signed_measure_sub_apply hi, smul_sub, smul_pos_part, smul_neg_part, ← ennreal.to_real_smul, ← ennreal.to_real_smul]
refl
rw restrict_le_restrict_iff at hsu hsv
have a := hsu (hu.diff hv) (u.diff_subset v)
have b := hsv (hv.diff hu) (v.diff_subset u)
erw [of_union (set.disjoint_of_subset_left (u.diff_subset v) set.disjoint_diff) (hu.diff hv) (hv.diff hu)] at hs
rw zero_apply at a b
split
linarith
linarith
linarith
linarith
linarith
apply_instance
apply_instance
apply_instance
all_goals { linarith <|> apply_instance <|> assumption }
assumption
assumption
simp [total_variation, to_jordan_decomposition_zero]
haveI : have_lebesgue_decomposition μ ν := ⟨⟨⟨s, f⟩, hf, hs, hadd⟩⟩
obtain ⟨hmeas, hsing, hadd'⟩ := have_lebesgue_decomposition_spec μ ν
obtain ⟨⟨S, hS₁, hS₂, hS₃⟩, ⟨T, hT₁, hT₂, hT₃⟩⟩ := ⟨hs, hsing⟩
rw hadd' at hadd
have hνinter : ν (S ∩ T)ᶜ = 0
rw set.compl_inter
refine nonpos_iff_eq_zero.1 (le_trans (measure_union_le _ _) _)
rw [hT₃, hS₃, add_zero]
{ rw set.compl_inter, refine nonpos_iff_eq_zero.1 (le_trans (measure_union_le _ _) _), rw [hT₃, hS₃, add_zero], exact le_refl _ }
exact le_refl _
have heq : s.restrict (S ∩ T)ᶜ = (μ.singular_part ν).restrict (S ∩ T)ᶜ
ext1 A hA
have hf : ν.with_density f (A ∩ (S ∩ T)ᶜ) = 0
refine with_density_absolutely_continuous ν _ _
rw ← nonpos_iff_eq_zero
{ refine with_density_absolutely_continuous ν _ _, rw ← nonpos_iff_eq_zero, exact hνinter ▸ measure_mono (set.inter_subset_right _ _) }
exact hνinter ▸ measure_mono (set.inter_subset_right _ _)
have hrn : ν.with_density (μ.rn_deriv ν) (A ∩ (S ∩ T)ᶜ) = 0
refine with_density_absolutely_continuous ν _ _
rw ← nonpos_iff_eq_zero
{ refine with_density_absolutely_continuous ν _ _, rw ← nonpos_iff_eq_zero, exact hνinter ▸ measure_mono (set.inter_subset_right _ _) }
exact hνinter ▸ measure_mono (set.inter_subset_right _ _)
rw [restrict_apply hA, restrict_apply hA, ← add_zero (s (A ∩ (S ∩ T)ᶜ)), ← hf, ← add_apply, ← hadd, add_apply, hrn, add_zero]
{ ext1 A hA, have hf : ν.with_density f (A ∩ (S ∩ T)ᶜ) = 0, { refine with_density_absolutely_continuous ν _ _, rw ← nonpos_iff_eq_zero, exact hνinter ▸ measure_mono (set.inter_subset_right _ _) }, have hrn : ν.with_density (μ.rn_deriv ν) (A ∩ (S ∩ T)ᶜ) = 0, { refine with_density_absolutely_continuous ν _ _, rw ← nonpos_iff_eq_zero, exact hνinter ▸ measure_mono (set.inter_subset_right _ _) }, rw [restrict_apply hA, restrict_apply hA, ← add_zero (s (A ∩ (S ∩ T)ᶜ)), ← hf, ← add_apply, ← hadd, add_apply, hrn, add_zero] }
have heq' : ∀ A : set α, measurable_set A → s A = s.restrict (S ∩ T)ᶜ A
intros A hA
have hsinter : s (A ∩ (S ∩ T)) = 0
rw ← nonpos_iff_eq_zero
exact hS₂ ▸ measure_mono (set.subset.trans (set.inter_subset_right _ _) (set.inter_subset_left _ _))
{ rw ← nonpos_iff_eq_zero, exact hS₂ ▸ measure_mono (set.subset.trans (set.inter_subset_right _ _) (set.inter_subset_left _ _)) }
rw [restrict_apply hA, ← add_zero (s (A ∩ (S ∩ T)ᶜ)), ← hsinter, ← measure_union, ← set.inter_union_distrib_left, set.compl_union_self, set.inter_univ]
exact disjoint.inter_left' _ ( disjoint.inter_right' _ disjoint_compl_left)
{ exact disjoint.inter_left' _ ( disjoint.inter_right' _ disjoint_compl_left) }
{ measurability }
measurability
{ intros A hA, have hsinter : s (A ∩ (S ∩ T)) = 0, { rw ← nonpos_iff_eq_zero, exact hS₂ ▸ measure_mono (set.subset.trans (set.inter_subset_right _ _) (set.inter_subset_left _ _)) }, rw [restrict_apply hA, ← add_zero (s (A ∩ (S ∩ T)ᶜ)), ← hsinter, ← measure_union, ← set.inter_union_distrib_left, set.compl_union_self, set.inter_univ], { exact disjoint.inter_left' _ ( disjoint.inter_right' _ disjoint_compl_left) }, { measurability }, { measurability } }
measurability
ext1 A hA
have hμinter : μ.singular_part ν (A ∩ (S ∩ T)) = 0
rw ← nonpos_iff_eq_zero
exact hT₂ ▸ measure_mono (set.subset.trans (set.inter_subset_right _ _) (set.inter_subset_right _ _))
{ rw ← nonpos_iff_eq_zero, exact hT₂ ▸ measure_mono (set.subset.trans (set.inter_subset_right _ _) (set.inter_subset_right _ _)) }
rw [heq' A hA, heq, ← add_zero ((μ.singular_part ν).restrict (S ∩ T)ᶜ A), ← hμinter, restrict_apply hA, ← measure_union, ← set.inter_union_distrib_left, set.compl_union_self, set.inter_univ]
exact disjoint.inter_left' _ ( disjoint.inter_right' _ disjoint_compl_left)
{ exact disjoint.inter_left' _ ( disjoint.inter_right' _ disjoint_compl_left) }
{ measurability }
measurability
measurability
convert supr_mem_measurable_le f hf n
ext
simp
apply coe_fn_mk
rw pair_eq_mk
ext1
refine (mem_ℒp.coe_fn_to_Lp _).trans _
refine eventually_eq.trans _ (Lp.coe_fn_add _ _).symm
refine eventually_eq.trans _ (eventually_eq.add (mem_ℒp.coe_fn_to_Lp _).symm (mem_ℒp.coe_fn_to_Lp _).symm)
rw condexp_ind_smul_add
refine (Lp.coe_fn_add _ _).trans (eventually_of_forall (λ a, _))
refl
exact condexp_L1_clm_indicator_const_Lp hs hμs x
rw Lp.simple_func.coe_indicator_const
rw set_integral_congr_ae (hm s hs) ((condexp_ae_eq_condexp_L1 f).mono (λ x hx _, hx))
exact set_integral_condexp_L1 hf hs
suffices h_nnnorm_eq_zero : ∫⁻ x in s, ∥condexp_L2 ℝ hm f x∥₊ ∂μ = 0
rw lintegral_eq_zero_iff at h_nnnorm_eq_zero
refine h_nnnorm_eq_zero.mono (λ x hx, _)
dsimp only at hx
rw pi.zero_apply at hx ⊢
{ rwa [ennreal.coe_eq_zero, nnnorm_eq_zero] at hx, }
rwa [ennreal.coe_eq_zero, nnnorm_eq_zero] at hx
refine measurable.coe_nnreal_ennreal (measurable.nnnorm _)
rw Lp_meas_coe
{ rw lintegral_eq_zero_iff at h_nnnorm_eq_zero, refine h_nnnorm_eq_zero.mono (λ x hx, _), dsimp only at hx, rw pi.zero_apply at hx ⊢, { rwa [ennreal.coe_eq_zero, nnnorm_eq_zero] at hx, }, { refine measurable.coe_nnreal_ennreal (measurable.nnnorm _), rw Lp_meas_coe, exact Lp.measurable _, }, }
exact Lp.measurable _
refine le_antisymm _ (zero_le _)
refine (lintegral_nnnorm_condexp_L2_le hs hμs f).trans (le_of_eq _)
rw lintegral_eq_zero_iff
refine hf.mono (λ x hx, _)
dsimp only
rw hx
{ refine hf.mono (λ x hx, _), dsimp only, rw hx, simp, }
simp
exact (Lp.measurable _).nnnorm.coe_nnreal_ennreal
rw [inner_def, inner_def, ← smul_eq_mul, ← integral_smul]
refine integral_congr_ae ((coe_fn_smul r f).mono (λ x hx, _))
rw [smul_eq_mul, ← inner_smul_left]
congr
rwa pi.smul_apply at hx
lift c to ℝ≥0 using hc
rw [ennreal.of_real_coe_nnreal, ← c.nnnorm_eq, ← snorm_norm g, ← snorm_const_smul (c : ℝ)]
swap
apply_instance
refine snorm_mono_ae _
simpa
rw [norm_def, norm_def, ennreal.to_real_le_to_real (snorm_ne_top _) (snorm_ne_top _)]
exact snorm_mono_ae h
apply_instance
rw [snorm', ←ennreal.rpow_mul, one_div, inv_mul_cancel, ennreal.rpow_one]
exact (ne_of_lt hq0_lt).symm
rw [snorm', div_zero, ennreal.rpow_zero]
cases le_or_lt 0 q with hq0 hq_neg
{ exact snorm'_zero (lt_of_le_of_ne hq0 hq0_ne.symm), }
exact snorm'_zero (lt_of_le_of_ne hq0 hq0_ne.symm)
simp [snorm', ennreal.rpow_eq_zero_iff, hμ, hq_neg]
by_cases hp_top : p = ∞
simp_rw [hp_top] at *
have h_cau_ae : ∀ᵐ x ∂μ, ∀ N n m, N ≤ n → N ≤ m → (nnnorm ((f n - f m) x) : ℝ≥0∞) < B N
simp_rw [ae_all_iff, ae_imp_iff]
{ simp_rw [ae_all_iff, ae_imp_iff], exact λ N n m hnN hmN, ae_lt_of_ess_sup_lt (h_cau N n m hnN hmN), }
exact λ N n m hnN hmN, ae_lt_of_ess_sup_lt (h_cau N n m hnN hmN)
simp_rw [snorm_exponent_top, snorm_ess_sup] at h_cau
refine h_cau_ae.mono (λ x hx, cauchy_seq_tendsto_of_complete _)
refine cauchy_seq_of_le_tendsto_0 (λ n, (B n).to_real) _ _
intros n m N hnN hmN
specialize hx N n m hnN hmN
rw [dist_eq_norm, ←ennreal.to_real_of_real (norm_nonneg _), ennreal.to_real_le_to_real ennreal.of_real_ne_top (ennreal.ne_top_of_tsum_ne_top hB N)]
rw ←of_real_norm_eq_coe_nnnorm at hx
{ intros n m N hnN hmN, specialize hx N n m hnN hmN, rw [dist_eq_norm, ←ennreal.to_real_of_real (norm_nonneg _), ennreal.to_real_le_to_real ennreal.of_real_ne_top (ennreal.ne_top_of_tsum_ne_top hB N)], rw ←of_real_norm_eq_coe_nnnorm at hx, exact hx.le, }
exact hx.le
rw ← ennreal.zero_to_real
exact tendsto.comp (ennreal.tendsto_to_real ennreal.zero_ne_top) (ennreal.tendsto_at_top_zero_of_tsum_ne_top hB)
{ simp_rw [hp_top] at *, have h_cau_ae : ∀ᵐ x ∂μ, ∀ N n m, N ≤ n → N ≤ m → (nnnorm ((f n - f m) x) : ℝ≥0∞) < B N, { simp_rw [ae_all_iff, ae_imp_iff], exact λ N n m hnN hmN, ae_lt_of_ess_sup_lt (h_cau N n m hnN hmN), }, simp_rw [snorm_exponent_top, snorm_ess_sup] at h_cau, refine h_cau_ae.mono (λ x hx, cauchy_seq_tendsto_of_complete _), refine cauchy_seq_of_le_tendsto_0 (λ n, (B n).to_real) _ _, { intros n m N hnN hmN, specialize hx N n m hnN hmN, rw [dist_eq_norm, ←ennreal.to_real_of_real (norm_nonneg _), ennreal.to_real_le_to_real ennreal.of_real_ne_top (ennreal.ne_top_of_tsum_ne_top hB N)], rw ←of_real_norm_eq_coe_nnnorm at hx, exact hx.le, }, { rw ← ennreal.zero_to_real, exact tendsto.comp (ennreal.tendsto_to_real ennreal.zero_ne_top) (ennreal.tendsto_at_top_zero_of_tsum_ne_top hB), }, }
have hp1 : 1 ≤ p.to_real
rw [← ennreal.of_real_le_iff_le_to_real hp_top, ennreal.of_real_one]
{ rw [← ennreal.of_real_le_iff_le_to_real hp_top, ennreal.of_real_one], exact hp, }
exact hp
have h_cau' : ∀ (N n m : ℕ), N ≤ n → N ≤ m → snorm' (f n - f m) (p.to_real) μ < B N
intros N n m hn hm
specialize h_cau N n m hn hm
rwa snorm_eq_snorm' (ennreal.zero_lt_one.trans_le hp).ne.symm hp_top at h_cau
{ intros N n m hn hm, specialize h_cau N n m hn hm, rwa snorm_eq_snorm' (ennreal.zero_lt_one.trans_le hp).ne.symm hp_top at h_cau, }
exact ae_tendsto_of_cauchy_snorm' hf hp1 hB h_cau'
refine Lp.mem_Lp_of_ae_bound (∥f∥) _
filter_upwards [f.to_continuous_map.coe_fn_to_ae_eq_fun μ]
intros x hx
convert f.norm_coe_le_norm x
simp [eventually_eq, snorm_ess_sup]
exact limsup_trim hm hf
simp_rw ess_sup
by_cases h0 : p = 0
{ simp [h0], }
simp [h0]
by_cases h_top : p = ∞
simpa only [h_top, snorm_exponent_top] using snorm_ess_sup_trim hm hf
{ simpa only [h_top, snorm_exponent_top] using snorm_ess_sup_trim hm hf, }
simpa only [snorm_eq_snorm' h0 h_top] using snorm'_trim hm hf
refine ⟨(approx_on f fmeas s y₀ h₀ n).ae_measurable, _⟩
suffices : snorm (λ x, approx_on f fmeas s y₀ h₀ n x - y₀) p μ < ⊤
have : mem_ℒp (λ x, approx_on f fmeas s y₀ h₀ n x - y₀) p μ := ⟨(approx_on f fmeas s y₀ h₀ n - const β y₀).ae_measurable, this⟩
convert snorm_add_lt_top this hi₀
ext x
{ have : mem_ℒp (λ x, approx_on f fmeas s y₀ h₀ n x - y₀) p μ := ⟨(approx_on f fmeas s y₀ h₀ n - const β y₀).ae_measurable, this⟩, convert snorm_add_lt_top this hi₀, ext x, simp }
simp
have hf' : mem_ℒp (λ x, ∥f x - y₀∥) p μ
have h_meas : measurable (λ x, ∥f x - y₀∥)
simp only [← dist_eq_norm]
{ simp only [← dist_eq_norm], exact (continuous_id.dist continuous_const).measurable.comp fmeas }
exact (continuous_id.dist continuous_const).measurable.comp fmeas
refine ⟨h_meas.ae_measurable, _⟩
rw snorm_norm
convert snorm_add_lt_top hf hi₀.neg
ext x
{ have h_meas : measurable (λ x, ∥f x - y₀∥), { simp only [← dist_eq_norm], exact (continuous_id.dist continuous_const).measurable.comp fmeas }, refine ⟨h_meas.ae_measurable, _⟩, rw snorm_norm, convert snorm_add_lt_top hf hi₀.neg, ext x, simp [sub_eq_add_neg] }
simp [sub_eq_add_neg]
have : ∀ᵐ x ∂μ, ∥approx_on f fmeas s y₀ h₀ n x - y₀∥ ≤ ∥(∥f x - y₀∥ + ∥f x - y₀∥)∥
refine eventually_of_forall _
intros x
convert norm_approx_on_y₀_le fmeas h₀ x n
rw [real.norm_eq_abs, abs_of_nonneg]
{ refine eventually_of_forall _, intros x, convert norm_approx_on_y₀_le fmeas h₀ x n, rw [real.norm_eq_abs, abs_of_nonneg], exact add_nonneg (norm_nonneg _) (norm_nonneg _) }
exact add_nonneg (norm_nonneg _) (norm_nonneg _)
calc snorm (λ x, approx_on f fmeas s y₀ h₀ n x - y₀) p μ ≤ snorm (λ x, ∥f x - y₀∥ + ∥f x - y₀∥) p μ : snorm_mono_ae this ... < ⊤ : snorm_add_lt_top hf' hf'
let fs := simple_func.approx_on f hf_meas set.univ 0 (set.mem_univ _)
refine ⟨fs, _, _⟩
from simple_func.mem_ℒp_approx_on_univ hf_meas hf
have h_fs_Lp : ∀ n, mem_ℒp (fs n) p μ
exact λ n, (fs n).measure_support_lt_top_of_mem_ℒp (h_fs_Lp n) hp_ne_zero hp_ne_top
{ have h_fs_Lp : ∀ n, mem_ℒp (fs n) p μ, from simple_func.mem_ℒp_approx_on_univ hf_meas hf, exact λ n, (fs n).measure_support_lt_top_of_mem_ℒp (h_fs_Lp n) hp_ne_zero hp_ne_top, }
exact λ x, simple_func.tendsto_approx_on hf_meas (set.mem_univ 0) (by simp)
simp
simpa only [inv_inv'] using h.inv
rw [← measure_inv_null hμ hE, ← hμ y⁻¹ (measurable_inv hE), ← measure_inv_null hμ (measurable_mul_const y hE)]
ext x
simp
convert iff.rfl using 3
rw L1.norm_eq_integral_norm
refine integral_congr_ae _
apply hf.coe_fn_to_L1.mono
intros a ha
simp [ha]
simp
rcases eq_or_ne c 0 with rfl|h0
{ simp }
swap
by_cases hfm : ae_measurable f μ
simpa [h0] using hfm
have : ¬ (ae_measurable f (c • μ))
{ have : ¬ (ae_measurable f (c • μ)), by simpa [h0] using hfm, simp [integral_non_ae_measurable, hfm, this] }
simp [integral_non_ae_measurable, hfm, this]
rcases eq_or_ne c ∞ with rfl|hc
rw [ennreal.top_to_real, zero_smul]
by_cases hf : f =ᵐ[μ] 0
have : f =ᵐ[∞ • μ] 0 := ae_smul_measure hf ∞
{ have : f =ᵐ[∞ • μ] 0 := ae_smul_measure hf ∞, exact integral_eq_zero_of_ae this }
exact integral_eq_zero_of_ae this
apply integral_undef
rw [integrable, has_finite_integral, iff_true_intro (hfm.smul_measure ∞), true_and, lintegral_smul_measure, top_mul, if_neg]
{ apply lt_irrefl }
apply lt_irrefl
rw [lintegral_eq_zero_iff' hfm.ennnorm]
refine λ h, hf (h.mono $ λ x, _)
{ rw [ennreal.top_to_real, zero_smul], by_cases hf : f =ᵐ[μ] 0, { have : f =ᵐ[∞ • μ] 0 := ae_smul_measure hf ∞, exact integral_eq_zero_of_ae this }, { apply integral_undef, rw [integrable, has_finite_integral, iff_true_intro (hfm.smul_measure ∞), true_and, lintegral_smul_measure, top_mul, if_neg], { apply lt_irrefl }, { rw [lintegral_eq_zero_iff' hfm.ennnorm], refine λ h, hf (h.mono $ λ x, _), simp } } }
simp
swap
by_cases hfi : integrable f μ
rw [integral_undef hfi, smul_zero]
refine integral_undef (mt (λ h, _) hfi)
convert h.smul_measure (ennreal.inv_ne_top.2 h0)
rw [smul_smul, ennreal.inv_mul_cancel h0 hc, one_smul]
{ rw [integral_undef hfi, smul_zero], refine integral_undef (mt (λ h, _) hfi), convert h.smul_measure (ennreal.inv_ne_top.2 h0), rw [smul_smul, ennreal.inv_mul_cancel h0 hc, one_smul] }
let g := hfm.mk f
calc ∫ x, f x ∂(c • μ) = ∫ x, g x ∂(c • μ) : integral_congr_ae $ ae_smul_measure hfm.ae_eq_mk c ... = c.to_real • ∫ x, g x ∂μ : integral_smul_measure_aux h0 hc hfm.measurable_mk $ hfi.congr hfm.ae_eq_mk ... = c.to_real • ∫ x, f x ∂μ : by { congr' 1, exact integral_congr_ae (hfm.ae_eq_mk.symm) }
congr' 1
exact integral_congr_ae (hfm.ae_eq_mk.symm)
simp [measure.dirac_apply_of_mem]
simp [integral_congr_ae hf, integral_zero]
by_cases hfi : integrable f μ
rw integral_eq_lintegral_pos_part_sub_lintegral_neg_part hfi
have h_min : ∫⁻ a, ennreal.of_real (-f a) ∂μ = 0
rw lintegral_eq_zero_iff'
refine hf.mono _
simp only [pi.zero_apply]
assume a h
{ refine hf.mono _, simp only [pi.zero_apply], assume a h, simp only [h, neg_nonpos, of_real_eq_zero], }
simp only [h, neg_nonpos, of_real_eq_zero]
{ rw lintegral_eq_zero_iff', { refine hf.mono _, simp only [pi.zero_apply], assume a h, simp only [h, neg_nonpos, of_real_eq_zero], }, { exact measurable_of_real.comp_ae_measurable hfm.neg } }
exact measurable_of_real.comp_ae_measurable hfm.neg
{ rw integral_eq_lintegral_pos_part_sub_lintegral_neg_part hfi, have h_min : ∫⁻ a, ennreal.of_real (-f a) ∂μ = 0, { rw lintegral_eq_zero_iff', { refine hf.mono _, simp only [pi.zero_apply], assume a h, simp only [h, neg_nonpos, of_real_eq_zero], }, { exact measurable_of_real.comp_ae_measurable hfm.neg } }, rw [h_min, zero_to_real, _root_.sub_zero] }
rw [h_min, zero_to_real, _root_.sub_zero]
rw integral_undef hfi
simp_rw [integrable, hfm, has_finite_integral_iff_norm, lt_top_iff_ne_top, ne.def, true_and, not_not] at hfi
have : ∫⁻ (a : α), ennreal.of_real (f a) ∂μ = ∫⁻ a, (ennreal.of_real ∥f a∥) ∂μ
refine lintegral_congr_ae (hf.mono $ assume a h, _)
{ refine lintegral_congr_ae (hf.mono $ assume a h, _), rw [real.norm_eq_abs, abs_of_nonneg h] }
rw [real.norm_eq_abs, abs_of_nonneg h]
refl
rw [this, hfi]
rw [← indicator_eq_self.2 (@subset_closure _ _ (support f)), integrable_indicator_iff is_closed_closure.measurable_set]
{ exact hf.integrable_on_compact hfc }
exact hf.integrable_on_compact hfc
apply_instance
simpa [mul_comm] using hf.mul_continuous_on_of_subset hg hs ht hst
rw [measure.restrict_apply_univ]
rw show (λ x, ∫ t in Icc a x, f t ∂μ) = λ x, ∫ t in Ioc a x, f t ∂μ, by { ext x, exact integral_Icc_eq_integral_Ioc }
ext x
exact integral_Icc_eq_integral_Ioc
exact continuous_on_primitive h_int
simpa only [integral_of_le hab] using set_integral_nonneg_of_ae_restrict H
simp [integral_symm (u t), add_comm]
simpa using measure_integral_sub_integral_sub_linear_is_o_of_tendsto_ae hab hmeas measurable_at_bot hf ((tendsto_bot : tendsto _ ⊥ (𝓝 0)).mono_left inf_le_left) hu hv (tendsto_const_pure : tendsto _ _ (pure b)) tendsto_const_pure
simpa [mul_comm] using hf.mul_continuous_on hg
simpa only [sub_eq_add_neg] using integral_comp_add_right f (-d)
ext1 a
simp only [infi_apply]
convert (monotone_lintegral μ).map_infi2_le f
rcases exists_measurable_superset_of_null h with ⟨t, hts, ht, ht0⟩
have : ∀ᵐ x ∂μ, x ∉ t := measure_zero_iff_ae_nmem.1 ht0
refine (supr_le $ assume s, supr_le $ assume hfs, le_supr_of_le (s.restrict tᶜ) $ le_supr_of_le _ _)
assume a
by_cases a ∈ t; simp [h, restrict_apply, ht.compl]
by_cases a ∈ t
simp [h, restrict_apply, ht.compl]
simp [h, restrict_apply, ht.compl]
exact le_trans (hfs a) (by_contradiction $ assume hnfg, h (hts hnfg))
{ assume a, by_cases a ∈ t; simp [h, restrict_apply, ht.compl], exact le_trans (hfs a) (by_contradiction $ assume hnfg, h (hts hnfg)) }
refine le_of_eq (simple_func.lintegral_congr $ this.mono $ λ a hnt, _)
by_cases hat : a ∈ t; simp [hat, ht.compl]
simp [hat, ht.compl]
simp [hat, ht.compl]
by_cases hat : a ∈ t
exact (hnt hat).elim
rw [lintegral, ennreal.mul_supr]
refine supr_le (λs, _)
rw [ennreal.mul_supr]
simp only [supr_le_iff, ge_iff_le]
assume hs
rw ← simple_func.const_mul_lintegral
refine le_supr_of_le (const α r * s) (le_supr_of_le (λx, _) (le_refl _))
exact mul_le_mul_left' (hs x) _
by_cases h : r = 0
{ simp [h] }
simp [h]
apply le_antisymm _ (lintegral_const_mul_le r f)
have rinv : r * r⁻¹ = 1 := ennreal.mul_inv_cancel h hr
rw mul_comm
have rinv' : r ⁻¹ * r = 1
exact rinv
have := lintegral_const_mul_le (r⁻¹) (λx, r * f x)
simp [(mul_assoc _ _ _).symm, rinv'] at this
simpa [(mul_assoc _ _ _).symm, rinv] using mul_le_mul_left' this r
simp [lintegral_const_mul'' _ hg, lintegral_mul_const'' _ hf]
simp [hs, indicator_preimage_of_not_mem _ _ ht, inter_comm]
induction n with n IH
simp only [nat.nat_zero_eq_zero, finset.sum_singleton, finset.range_one]
refl
{ simp only [nat.nat_zero_eq_zero, finset.sum_singleton, finset.range_one], refl }
rw [finset.sum_range_succ, nat.succ_eq_add_one, IH, eapprox_diff, coe_map, function.comp_app, coe_sub, pi.sub_apply, ennreal.coe_to_nnreal, ennreal.add_sub_cancel_of_le (monotone_eapprox f (nat.le_succ _) _)]
apply (lt_of_le_of_lt _ (eapprox_lt_top f (n+1) a)).ne
rw ennreal.sub_le_iff_le_add
exact le_self_add
simpa only [mem_range, exists_prop] using set.exists_range_iff
by_cases hs_empty : s = ∅
simp only [hs_empty, hT_empty, continuous_linear_map.zero_apply, piecewise_empty, const_zero, set_to_simple_func_zero_apply]
{ simp only [hs_empty, hT_empty, continuous_linear_map.zero_apply, piecewise_empty, const_zero, set_to_simple_func_zero_apply], }
by_cases hs_univ : s = univ
casesI hα : is_empty_or_nonempty α
refine absurd _ hs_empty
unfold set
apply_instance
haveI : subsingleton (set α)
{ refine absurd _ hs_empty, haveI : subsingleton (set α), by { unfold set, apply_instance, }, exact subsingleton.elim s ∅, }
exact subsingleton.elim s ∅
{ casesI hα : is_empty_or_nonempty α, { refine absurd _ hs_empty, haveI : subsingleton (set α), by { unfold set, apply_instance, }, exact subsingleton.elim s ∅, }, simp [hs_univ, set_to_simple_func], }
simp [hs_univ, set_to_simple_func]
simp_rw set_to_simple_func
rw [← ne.def, set.ne_empty_iff_nonempty] at hs_empty
rw range_indicator hs hs_empty hs_univ
by_cases hx0 : x = 0
simp
{ simp_rw hx0, simp, }
simp_rw hx0
rw sum_insert
rw finset.mem_singleton
exact hx0
swap
{ rw finset.mem_singleton, exact hx0, }
rw [sum_singleton, (T _).map_zero, add_zero]
congr
simp only [coe_piecewise, piecewise_eq_indicator, coe_const, pi.const_zero, piecewise_eq_indicator]
rw [indicator_preimage, preimage_const_of_mem]
exact set.mem_singleton x
{ exact set.mem_singleton x, }
swap
rw [← pi.const_zero, preimage_const_of_not_mem]
rw set.mem_singleton_iff
exact ne.symm hx0
swap
{ rw set.mem_singleton_iff, exact ne.symm hx0, }
simp
exact measurable_of_empty f
haveI := function.is_empty f
apply div_pos; norm_cast
norm_cast
norm_cast
apply index_pos ⟨K, h1K, h2K⟩ hU
exact index_pos K₀ hU
apply div_pos
let eval : (compacts G → ℝ) → ℝ := λ f, f (K.map _ $ continuous_mul_left g) - f K
have : continuous eval := (continuous_apply (K.map _ _)).sub (continuous_apply K)
show chaar K₀ ∈ eval ⁻¹' {(0 : ℝ)}
rw [← sub_eq_zero]
apply mem_of_subset_of_mem _ (chaar_mem_cl_prehaar K₀ ⟨set.univ, is_open_univ, mem_univ _⟩)
rw is_closed.closure_subset_iff
unfold cl_prehaar
rintro _ ⟨U, ⟨h1U, h2U, h3U⟩, rfl⟩
simp only [mem_singleton_iff, mem_preimage, eval, sub_eq_zero]
rw h2U.interior_eq
exact ⟨1, h3U⟩
apply is_left_invariant_prehaar
{ rintro _ ⟨U, ⟨h1U, h2U, h3U⟩, rfl⟩, simp only [mem_singleton_iff, mem_preimage, eval, sub_eq_zero], apply is_left_invariant_prehaar, rw h2U.interior_eq, exact ⟨1, h3U⟩ }
exact is_closed_singleton
apply continuous_iff_is_closed.mp this
rw [← hf.hausdorff_measure_image hd, image_preimage_eq_inter_range]
simp
simp [measure.map_apply (measurable_const_add a) measurable_set_Ioo, sub_sub_sub_cancel_right]
refine (measure.pi_eq (λ s hs, _)).symm
have A : has_add.add a ⁻¹' (set.pi univ (λ (i : ι), s i)) = set.pi univ (λ (i : ι), ((+) (a i)) ⁻¹' (s i))
ext
simp
rw [measure.map_apply (measurable_const_add a) (measurable_set.univ_pi_fintype hs), A, volume_pi_pi]
{ simp only [volume_preimage_add_left] }
simp only [volume_preimage_add_left]
exact λ i, measurable_const_add (a i) (hs i)
rw [measure_zero_iff_ae_nmem, measure_zero_iff_ae_nmem]
exact λ hs, h hs
rw [smul_apply, ae_iff.1 h, mul_zero]
ext t
simp only [mem_inf_principal, mem_ae_iff, restrict_apply_eq_zero' hs, compl_set_of, not_imp, and_comm (_ ∈ s)]
refl
simp only [ae_restrict_eq hs, exists_prop, mem_principal, mem_inf_iff]
simp only [ae_restrict_eq hs, exists_prop, mem_principal, mem_inf_iff]; exact ⟨_, univ_mem, s, subset.rfl, (univ_inter s).symm⟩
exact ⟨_, univ_mem, s, subset.rfl, (univ_inter s).symm⟩
rw [measure_compl ht (measure_ne_top μ _), measure_compl hs (measure_ne_top μ _), ennreal.sub_le_iff_le_add]
calc μ univ = μ univ - μ s + μ s : (ennreal.sub_add_cancel_of_le $ measure_mono s.subset_univ).symm ... ≤ μ univ - μ s + (μ t + ε) : add_le_add_left h _ ... = _ : by rw [add_right_comm, add_assoc]
rw [add_right_comm, add_assoc]
haveI : is_finite_measure ν := begin constructor, rw ← h_univ, apply is_finite_measure.measure_univ_lt_top, end
constructor
rw ← h_univ
apply is_finite_measure.measure_univ_lt_top
simp
refine induction_on_inter hA hC (by simp) hμν _ _ hs
intros t h1t h2t
from h _ h1t
have h1t_ : @measurable_set α m₀ t
rw [@measure_compl α m₀ μ t h1t_ (@measure_ne_top α m₀ μ _ t), @measure_compl α m₀ ν t h1t_ (@measure_ne_top α m₀ ν _ t), h_univ, h2t]
{ intros t h1t h2t, have h1t_ : @measurable_set α m₀ t, from h _ h1t, rw [@measure_compl α m₀ μ t h1t_ (@measure_ne_top α m₀ μ _ t), @measure_compl α m₀ ν t h1t_ (@measure_ne_top α m₀ ν _ t), h_univ, h2t], }
intros f h1f h2f h3f
from (λ i, h _ (h2f i))
have h2f_ : ∀ (i : ℕ), @measurable_set α m₀ (f i)
from @measurable_set.Union α ℕ m₀ _ f h2f_
have h_Union : @measurable_set α m₀ (⋃ (i : ℕ), f i)
simp [measure_Union, h_Union, h1f, h3f, h2f_]
refine ⟨_, λ h, h.filter_mono inf_le_left⟩
rintros ⟨s, ⟨t, ht, u, hu, rfl⟩, hμ⟩
from ⟨t, ht, this.trans_lt hμ⟩
suffices : μ t ≤ μ (t ∩ u)
exact measure_mono_ae (mem_of_superset hu (λ x hu ht, ⟨ht, hu⟩))
rwa measure_to_measurable
rw [Inf_apply hs, ← to_outer_measure_apply]
rw [Inf_apply hs, ← to_outer_measure_apply]; exact this s
exact this s
rw [← trimmed, outer_measure.trim_congr h, trimmed]
rw [measure_eq_induced_outer_measure, induced_outer_measure_eq_extend _ _ hs]
exact μ.m_Union
simp [eventually_le_antisymm_iff, ae_le_set, union_diff_right, diff_eq_empty.2 (set.subset_union_right _ _)]
rw [h₁ t, h₂ (t ∩ s₁), h₂ (t \ s₁), h₁ (t ∩ (s₁ ∪ s₂)), inter_diff_assoc _ _ s₁, set.inter_assoc _ _ s₁, inter_eq_self_of_subset_right (set.subset_union_left _ _), union_diff_left, h₂ (t ∩ s₁)]
simp [diff_eq, add_assoc]
intros U hU r hr
rcases hU.exists_Union_is_closed with ⟨F, F_closed, -, rfl, F_mono⟩
rw measure_Union_eq_supr (λ n, (F_closed n).measurable_set) F_mono.directed_le at hr
rcases lt_supr_iff.1 hr with ⟨n, hn⟩
exact ⟨F n, subset_Union _ _, F_closed n, hn⟩
simp_rw [ne.def, ← measure_univ_eq_zero, is_open_univ.measure_eq_supr_is_compact, ennreal.supr_eq_zero, not_forall, exists_prop, subset_univ, true_and]
apply outer_measure.of_function_caratheodory (λ t, _)
refine le_infi (λ a, le_infi (λ b, le_infi (λ h, _)))
refine le_trans (add_le_add (f.length_mono $ inter_subset_inter_left _ h) (f.length_mono $ diff_subset_diff_left h)) _
cases le_total a c with hac hac; cases le_total b c with hbc hbc
cases le_total b c with hbc hbc
cases le_total b c with hbc hbc
cases le_total a c with hac hac
simp only [Ioc_inter_Ioi, f.length_Ioc, hac, sup_eq_max, hbc, le_refl, Ioc_eq_empty, max_eq_right, min_eq_left, Ioc_diff_Ioi, f.length_empty, zero_add, not_lt]
{ simp only [Ioc_inter_Ioi, f.length_Ioc, hac, sup_eq_max, hbc, le_refl, Ioc_eq_empty, max_eq_right, min_eq_left, Ioc_diff_Ioi, f.length_empty, zero_add, not_lt] }
simp only [hac, hbc, Ioc_inter_Ioi, Ioc_diff_Ioi, f.length_Ioc, min_eq_right, sup_eq_max, ←ennreal.of_real_add, f.mono hac, f.mono hbc, sub_nonneg, sub_add_sub_cancel, le_refl, max_eq_right]
{ simp only [hac, hbc, Ioc_inter_Ioi, Ioc_diff_Ioi, f.length_Ioc, min_eq_right, sup_eq_max, ←ennreal.of_real_add, f.mono hac, f.mono hbc, sub_nonneg, sub_add_sub_cancel, le_refl, max_eq_right] }
simp only [hbc, le_refl, Ioc_eq_empty, Ioc_inter_Ioi, min_eq_left, Ioc_diff_Ioi, f.length_empty, zero_add, or_true, le_sup_iff, f.length_Ioc, not_lt]
{ simp only [hbc, le_refl, Ioc_eq_empty, Ioc_inter_Ioi, min_eq_left, Ioc_diff_Ioi, f.length_empty, zero_add, or_true, le_sup_iff, f.length_Ioc, not_lt] }
simp only [hac, hbc, Ioc_inter_Ioi, Ioc_diff_Ioi, f.length_Ioc, min_eq_right, sup_eq_max, le_refl, Ioc_eq_empty, add_zero, max_eq_left, f.length_empty, not_lt]
rcases eq_or_lt_of_le h with rfl|hxy
{ exact le_rfl }
exact le_rfl
exact (f.left_lim_le le_rfl).trans (f.le_left_lim hxy)
intros s hs
rw [neg_apply, neg_eq_zero] at hs
exact h hs
simp
convert has_sum_integral_Union hs₁ hs₂ hf.integrable_on
rw if_pos (hs₁ n)
{ ext n, rw if_pos (hs₁ n) }
ext n
rw if_pos (measurable_set.Union hs₁)
induction h_t with s h_s s t' h_gen_s h_gen_t' h_nonempty h_s h_t'
rcases h_s with ⟨t', ⟨⟨b, rfl⟩, h_s_in_t'⟩⟩
refine ⟨{b}, (λ _, s), _⟩
{ rcases h_s with ⟨t', ⟨⟨b, rfl⟩, h_s_in_t'⟩⟩, refine ⟨{b}, (λ _, s), _⟩, simpa using h_s_in_t', }
simpa using h_s_in_t'
rcases h_t' with ⟨T_t', ⟨f_t', ⟨rfl, h_t'⟩⟩⟩
rcases h_s with ⟨T_s, ⟨f_s, ⟨rfl, h_s⟩ ⟩ ⟩
use [(T_s ∪ T_t'), (λ (b:β), if (b ∈ T_s) then (if (b ∈ T_t') then (f_s b ∩ (f_t' b)) else (f_s b)) else (if (b ∈ T_t') then (f_t' b) else (∅ : set α)))]
split
ext a
simp_rw [set.mem_inter_iff, set.mem_Inter, finset.mem_union, or_imp_distrib]
rw ← forall_and_distrib
split; intros h1 b; by_cases hbs : b ∈ T_s; by_cases hbt : b ∈ T_t'; specialize h1 b; simp only [hbs, hbt, if_true, if_false, true_implies_iff, and_self, false_implies_iff, and_true, true_and] at h1 ⊢
split; intros h1 b; by_cases hbs : b ∈ T_s; by_cases hbt : b ∈ T_t'; specialize h1 b
split; intros h1 b; by_cases hbs : b ∈ T_s; by_cases hbt : b ∈ T_t'
split; intros h1 b; by_cases hbs : b ∈ T_s
split; intros h1 b
intros h1 b
intros h1 b
by_cases hbs : b ∈ T_s
by_cases hbs : b ∈ T_s
by_cases hbt : b ∈ T_t'
by_cases hbt : b ∈ T_t'
by_cases hbt : b ∈ T_t'
by_cases hbt : b ∈ T_t'
specialize h1 b
specialize h1 b
specialize h1 b
specialize h1 b
specialize h1 b
specialize h1 b
specialize h1 b
specialize h1 b
split
simp only [hbs, hbt, if_true, if_false, true_implies_iff, and_self, false_implies_iff, and_true, true_and] at h1 ⊢
simp only [hbs, hbt, if_true, if_false, true_implies_iff, and_self, false_implies_iff, and_true, true_and] at h1 ⊢
simp only [hbs, hbt, if_true, if_false, true_implies_iff, and_self, false_implies_iff, and_true, true_and] at h1 ⊢
simp only [hbs, hbt, if_true, if_false, true_implies_iff, and_self, false_implies_iff, and_true, true_and] at h1 ⊢
simp only [hbs, hbt, if_true, if_false, true_implies_iff, and_self, false_implies_iff, and_true, true_and] at h1 ⊢
simp only [hbs, hbt, if_true, if_false, true_implies_iff, and_self, false_implies_iff, and_true, true_and] at h1 ⊢
simp only [hbs, hbt, if_true, if_false, true_implies_iff, and_self, false_implies_iff, and_true, true_and] at h1 ⊢
simp only [hbs, hbt, if_true, if_false, true_implies_iff, and_self, false_implies_iff, and_true, true_and] at h1 ⊢
exact h1
exact h1
exact h1
exact h1
{ ext a, simp_rw [set.mem_inter_iff, set.mem_Inter, finset.mem_union, or_imp_distrib], rw ← forall_and_distrib, split; intros h1 b; by_cases hbs : b ∈ T_s; by_cases hbt : b ∈ T_t'; specialize h1 b; simp only [hbs, hbt, if_true, if_false, true_implies_iff, and_self, false_implies_iff, and_true, true_and] at h1 ⊢, all_goals { exact h1, }, }
all_goals { exact h1, }
intros b h_b
split_ifs with hbs hbt hbt
refine h_pi b (f_s b) (f_t' b) (h_s b hbs) (h_t' b hbt) (set.nonempty.mono _ h_nonempty)
exact set.inter_subset_inter (set.bInter_subset_of_mem hbs) (set.bInter_subset_of_mem hbt)
{ refine h_pi b (f_s b) (f_t' b) (h_s b hbs) (h_t' b hbt) (set.nonempty.mono _ h_nonempty), exact set.inter_subset_inter (set.bInter_subset_of_mem hbs) (set.bInter_subset_of_mem hbt), }
{ exact h_s b hbs, }
exact h_s b hbs
{ exact h_t' b hbt, }
exact h_t' b hbt
rw finset.mem_union at h_b
apply false.elim (h_b.elim hbs hbt)
rw [admissible]
rintro (⟨p', q', H⟩|⟨n, H⟩|H|H|H)
rw [← H, A', sum_inv_pqr, add_assoc]
simp only [lt_add_iff_pos_right, pnat.one_coe, inv_one, nat.cast_one, coe_coe]
apply add_pos; simp only [pnat.pos, nat.cast_pos, inv_pos]
simp only [pnat.pos, nat.cast_pos, inv_pos]
simp only [pnat.pos, nat.cast_pos, inv_pos]
apply add_pos
{ rw [← H, A', sum_inv_pqr, add_assoc], simp only [lt_add_iff_pos_right, pnat.one_coe, inv_one, nat.cast_one, coe_coe], apply add_pos; simp only [pnat.pos, nat.cast_pos, inv_pos] }
rw [← H, D', sum_inv_pqr]
simp only [lt_add_iff_pos_right, pnat.one_coe, inv_one, nat.cast_one, coe_coe, pnat.coe_bit0, nat.cast_bit0]
{ rw [← H, D', sum_inv_pqr], simp only [lt_add_iff_pos_right, pnat.one_coe, inv_one, nat.cast_one, coe_coe, pnat.coe_bit0, nat.cast_bit0], norm_num }
norm_num
rw [← H, E', sum_inv_pqr]
rw [← H, E', sum_inv_pqr]
rw [← H, E', sum_inv_pqr]
all_goals { rw [← H, E', sum_inv_pqr], norm_num }
norm_num
norm_num
norm_num
rw [ppow, dif_pos rfl]
rw [← zeta_mul_pow_eq_sigma]
apply ((is_multiplicative_zeta).mul is_multiplicative_pow)
rw [mul_comm, coe_moebius_mul_coe_zeta]
let B := mk (λ n, bernoulli' n / n!)
suffices : (B - eval_neg_hom B) * (exp ℚ - 1) = X * (exp ℚ - 1)
cases mul_eq_mul_right_iff.mp this; simp only [power_series.ext_iff, eval_neg_hom, coeff_X] at h
cases mul_eq_mul_right_iff.mp this
simp only [power_series.ext_iff, eval_neg_hom, coeff_X] at h
simp only [power_series.ext_iff, eval_neg_hom, coeff_X] at h
apply eq_zero_of_neg_eq
specialize h n
split_ifs at h; simp [neg_one_pow_of_odd h_odd, factorial_ne_zero, *] at *
split_ifs at h
{ apply eq_zero_of_neg_eq, specialize h n, split_ifs at h; simp [neg_one_pow_of_odd h_odd, factorial_ne_zero, *] at * }
simp [neg_one_pow_of_odd h_odd, factorial_ne_zero, *] at *
simp [neg_one_pow_of_odd h_odd, factorial_ne_zero, *] at *
{ cases mul_eq_mul_right_iff.mp this; simp only [power_series.ext_iff, eval_neg_hom, coeff_X] at h, { apply eq_zero_of_neg_eq, specialize h n, split_ifs at h; simp [neg_one_pow_of_odd h_odd, factorial_ne_zero, *] at * }, { simpa using h 1 } }
simpa using h 1
have h : B * (exp ℚ - 1) = X * exp ℚ
simpa [bernoulli'_power_series] using bernoulli'_power_series_mul_exp_sub_one ℚ
{ simpa [bernoulli'_power_series] using bernoulli'_power_series_mul_exp_sub_one ℚ }
rw [sub_mul, h, mul_sub X, sub_right_inj, ← neg_sub, ← neg_mul_eq_mul_neg, neg_eq_iff_neg_eq]
suffices : eval_neg_hom (B * (exp ℚ - 1)) * exp ℚ = eval_neg_hom (X * exp ℚ) * exp ℚ
simpa [mul_assoc, sub_mul, mul_comm (eval_neg_hom (exp ℚ)), exp_mul_exp_neg_eq_one, eq_comm]
{ simpa [mul_assoc, sub_mul, mul_comm (eval_neg_hom (exp ℚ)), exp_mul_exp_neg_eq_one, eq_comm] }
congr'
ext n
simp
{ simp }
cases n
simp only [bernoulli_power_series, coeff_mul, coeff_X, sum_antidiagonal_succ', one_div, coeff_mk, coeff_one, coeff_exp, linear_map.map_sub, factorial, if_pos, cast_succ, cast_one, cast_mul, sub_zero, ring_hom.map_one, add_eq_zero_iff, if_false, inv_one, zero_add, one_ne_zero, mul_zero, and_false, sub_self, ← ring_hom.map_mul, ← ring_hom.map_sum]
suffices : ∑ x in antidiagonal n, bernoulli x.1 / x.1! * ((x.2 + 1) * x.2!)⁻¹ = if n.succ = 1 then 1 else 0
split_ifs
split_ifs; simp [h, this]
simp [h, this]
simp [h, this]
{ split_ifs; simp [h, this] }
simp
{ simp }
cases n
have hfact : ∀ m, (m! : ℚ) ≠ 0 := λ m, by exact_mod_cast factorial_ne_zero m
exact_mod_cast factorial_ne_zero m
have hite1 : ite (n.succ.succ = 1) 1 0 = (0 / n.succ! : ℚ) := by simp
simp
have hite2 : ite (n.succ = 0) 1 0 = (0 : ℚ) := by simp [succ_ne_zero]
simp [succ_ne_zero]
rw [hite1, eq_div_iff (hfact n.succ), ← hite2, ← bernoulli_spec', sum_mul]
apply sum_congr rfl
rintro ⟨i, j⟩ h
rw mem_antidiagonal at h
exact_mod_cast succ_ne_zero j
have hj : (j.succ : ℚ) ≠ 0 := by exact_mod_cast succ_ne_zero j
field_simp [← h, mul_ne_zero hj (hfact j), hfact i, mul_comm _ (bernoulli i), mul_assoc]
rw_mod_cast [mul_comm (j + 1), mul_div_assoc, ← mul_assoc]
rw [cast_mul, cast_mul, mul_div_mul_right _ _ hj, add_choose, cast_dvd_char_zero]
apply factorial_mul_factorial_dvd_factorial_add
have hbε : 0 < card_pow_degree b • ε
rw [algebra.smul_def, ring_hom.eq_int_cast]
exact mul_pos (int.cast_pos.mpr (absolute_value.pos _ hb)) hε
{ rw [algebra.smul_def, ring_hom.eq_int_cast], exact mul_pos (int.cast_pos.mpr (absolute_value.pos _ hb)) hε }
induction n with n ih
{ refine ⟨fin_zero_elim, fin_zero_elim⟩ }
refine ⟨fin_zero_elim, fin_zero_elim⟩
have anti_archim' : ∀ {i j k} {ε : ℝ}, (card_pow_degree (A i % b - A j % b) : ℝ) < ε → (card_pow_degree (A j % b - A k % b) : ℝ) < ε → (card_pow_degree (A i % b - A k % b) : ℝ) < ε
intros i j k ε
rw [← lt_ceil, ← lt_ceil, ← lt_ceil]
{ intros i j k ε, rw [← lt_ceil, ← lt_ceil, ← lt_ceil], exact card_pow_degree_anti_archimedean }
exact card_pow_degree_anti_archimedean
obtain ⟨t', ht'⟩ := ih (fin.tail A)
suffices : ∃ j, ∀ i, t' i = j ↔ (card_pow_degree (A 0 % b - A i.succ % b) : ℝ) < card_pow_degree b • ε
obtain ⟨j, hj⟩ := this
refine ⟨fin.cons j t', λ i₀ i₁, _⟩
refine fin.cases _ (λ i₀, _) i₀; refine fin.cases _ (λ i₁, _) i₁
refine fin.cases _ (λ i₁, _) i₁
refine fin.cases _ (λ i₁, _) i₁
refine fin.cases _ (λ i₀, _) i₀
{ simpa using hbε }
simpa using hbε
rw [fin.cons_succ, fin.cons_zero, eq_comm, absolute_value.map_sub]
{ rw [fin.cons_succ, fin.cons_zero, eq_comm, absolute_value.map_sub], exact hj i₁ }
exact hj i₁
rw [fin.cons_succ, fin.cons_zero]
{ rw [fin.cons_succ, fin.cons_zero], exact hj i₀ }
exact hj i₀
rw [fin.cons_succ, fin.cons_succ]
{ obtain ⟨j, hj⟩ := this, refine ⟨fin.cons j t', λ i₀ i₁, _⟩, refine fin.cases _ (λ i₀, _) i₀; refine fin.cases _ (λ i₁, _) i₁, { simpa using hbε }, { rw [fin.cons_succ, fin.cons_zero, eq_comm, absolute_value.map_sub], exact hj i₁ }, { rw [fin.cons_succ, fin.cons_zero], exact hj i₀ }, { rw [fin.cons_succ, fin.cons_succ], exact ht' i₀ i₁ } }
exact ht' i₀ i₁
obtain ⟨j, hj⟩ : ∃ j, ∀ (i : fin n), t' i = j → (card_pow_degree (A 0 % b - A i.succ % b) : ℝ) < card_pow_degree b • ε
push_neg at this
by_contra this
obtain ⟨j₀, j₁, j_ne, approx⟩ := exists_approx_polynomial hb hε (fin.cons (A 0) (λ j, A (fin.succ (classical.some (this j)))))
revert j_ne approx
refine fin.cases _ (λ j₀, _) j₀; refine fin.cases (λ j_ne approx, _) (λ j₁ j_ne approx, _) j₁
refine fin.cases (λ j_ne approx, _) (λ j₁ j_ne approx, _) j₁
refine fin.cases (λ j_ne approx, _) (λ j₁ j_ne approx, _) j₁
refine fin.cases _ (λ j₀, _) j₀
{ exact absurd rfl j_ne }
exact absurd rfl j_ne
rw [fin.cons_succ, fin.cons_zero, ← not_le, absolute_value.map_sub] at approx
have := (classical.some_spec (this j₁)).2
{ rw [fin.cons_succ, fin.cons_zero, ← not_le, absolute_value.map_sub] at approx, have := (classical.some_spec (this j₁)).2, contradiction }
contradiction
rw [fin.cons_succ, fin.cons_zero, ← not_le] at approx
have := (classical.some_spec (this j₀)).2
{ rw [fin.cons_succ, fin.cons_zero, ← not_le] at approx, have := (classical.some_spec (this j₀)).2, contradiction }
contradiction
rw [fin.cons_succ, fin.cons_succ] at approx
rw [ne.def, fin.succ_inj] at j_ne
have : j₀ = j₁ := (classical.some_spec (this j₀)).1.symm.trans (((ht' (classical.some (this j₀)) (classical.some (this j₁))).mpr approx).trans (classical.some_spec (this j₁)).1)
{ by_contra this, push_neg at this, obtain ⟨j₀, j₁, j_ne, approx⟩ := exists_approx_polynomial hb hε (fin.cons (A 0) (λ j, A (fin.succ (classical.some (this j))))), revert j_ne approx, refine fin.cases _ (λ j₀, _) j₀; refine fin.cases (λ j_ne approx, _) (λ j₁ j_ne approx, _) j₁, { exact absurd rfl j_ne }, { rw [fin.cons_succ, fin.cons_zero, ← not_le, absolute_value.map_sub] at approx, have := (classical.some_spec (this j₁)).2, contradiction }, { rw [fin.cons_succ, fin.cons_zero, ← not_le] at approx, have := (classical.some_spec (this j₀)).2, contradiction }, { rw [fin.cons_succ, fin.cons_succ] at approx, rw [ne.def, fin.succ_inj] at j_ne, have : j₀ = j₁ := (classical.some_spec (this j₀)).1.symm.trans (((ht' (classical.some (this j₀)) (classical.some (this j₁))).mpr approx).trans (classical.some_spec (this j₁)).1), contradiction } }
contradiction
by_cases exists_nonempty_j : ∃ j, (∃ i, t' i = j) ∧ ∀ i, t' i = j → (card_pow_degree (A 0 % b - A i.succ % b) : ℝ) < card_pow_degree b • ε
obtain ⟨j, ⟨i, hi⟩, hj⟩ := exists_nonempty_j
refine ⟨j, λ i', ⟨hj i', λ hi', trans ((ht' _ _).mpr _) hi⟩⟩
apply anti_archim' _ hi'
rw absolute_value.map_sub
{ obtain ⟨j, ⟨i, hi⟩, hj⟩ := exists_nonempty_j, refine ⟨j, λ i', ⟨hj i', λ hi', trans ((ht' _ _).mpr _) hi⟩⟩, apply anti_archim' _ hi', rw absolute_value.map_sub, exact hj _ hi }
exact hj _ hi
refine ⟨j, λ i, ⟨hj i, λ hi, _⟩⟩
have := exists_nonempty_j ⟨t' i, ⟨i, rfl⟩, λ i' hi', anti_archim' hi ((ht' _ _).mp hi')⟩
contradiction
simp [nat.mul_eq_one_iff, prod.ext_iff]
ext
simp only [l_series, add_apply]
rw ← tsum_add hf hg
apply congr rfl (funext (λ n, _))
apply _root_.add_div
by_cases h0 : m = 0
subst h0
have hf : f = 0 := arithmetic_function.ext (λ n, complex.abs_eq_zero.1 (le_antisymm (h n) (complex.abs_nonneg _)))
{ subst h0, have hf : f = 0 := arithmetic_function.ext (λ n, complex.abs_eq_zero.1 (le_antisymm (h n) (complex.abs_nonneg _))), simp [hf] }
simp [hf]
refine summable_of_norm_bounded (λ (n : ℕ), m / (n ^ z)) _ _
simp_rw [div_eq_mul_inv]
exact (summable_mul_left_iff h0).1 (real.summable_nat_rpow_inv.2 hz)
{ simp_rw [div_eq_mul_inv], exact (summable_mul_left_iff h0).1 (real.summable_nat_rpow_inv.2 hz) }
intro n
have hm : 0 ≤ m := le_trans (complex.abs_nonneg _) (h 0)
cases n
{ simp [hm, real.zero_rpow (ne_of_gt (lt_trans real.zero_lt_one hz))] }
simp [hm, real.zero_rpow (ne_of_gt (lt_trans real.zero_lt_one hz))]
simp only [complex.abs_div, complex.norm_eq_abs]
apply div_le_div hm (h _) (real.rpow_pos_of_pos (nat.cast_pos.2 n.succ_pos) _) (le_of_eq _)
rw [complex.abs_cpow_real, complex.abs_cast_nat]
rw add_comm
rw add_comm; simp [hz']
simp [hz']
rw [hq, ha, zero_add]
rw [sq, right_distrib, mul_assoc]
simpa using eq_neg_of_add_eq_zero this
simp [this]
simpa [h]
rw ←this
rw ←this; refl
obtain ⟨k, hk⟩ := @exists_pow_neg_lt p _ ε (by exact_mod_cast hε)
exact_mod_cast hε
use k
simp
rw (show (p : ℝ) = (p : ℚ), by simp) at hk
exact_mod_cast hk
rw [padic_val_nat.pow p _ _ (fact.out p.prime).ne_zero, padic_val_nat_self p, mul_one]
simp [hr]
rw [←padic_norm.mul, div_mul_cancel _ hr]
unfold padic_val_rat; split_ifs; simp *
unfold padic_val_rat; split_ifs
split_ifs
simp *
simp *
unfold padic_val_rat
apply stationary_point_spec hf
apply le_trans
{ apply le_max_left _ v3 }
apply le_max_left _ v3
{ apply le_trans, { apply le_max_left _ v3 }, { apply le_max_right } }
apply le_max_right
apply le_refl
by_cases hf : f ≈ 0
from setoid.trans (setoid.symm h) hf
have hg : g ≈ 0
{ have hg : g ≈ 0, from setoid.trans (setoid.symm h) hf, simp [hf, hg, padic_seq.valuation] }
simp [hf, hg, padic_seq.valuation]
from (λ hg, hf (setoid.trans h hg))
have hg : ¬ g ≈ 0
rw padic_seq.val_eq_iff_norm_eq hf hg
exact padic_seq.norm_equiv h
injection (pell_zd_sub _ h) with h _; repeat {rw ← neg_mul_eq_mul_neg at h}; exact h
injection (pell_zd_sub _ h) with h _; repeat {rw ← neg_mul_eq_mul_neg at h}
repeat {rw ← neg_mul_eq_mul_neg at h}
repeat {rw ← neg_mul_eq_mul_neg at h}
repeat {rw ← neg_mul_eq_mul_neg at h}
injection (pell_zd_sub _ h) with h _
rw ← neg_mul_eq_mul_neg at h
rw ← neg_mul_eq_mul_neg at h
exact h
by_cases h0 : int.gcd x y = 0
apply int.nat_abs_eq_zero.mp
apply nat.eq_zero_of_gcd_eq_zero_left h0
have hx : x = 0
{ apply int.nat_abs_eq_zero.mp, apply nat.eq_zero_of_gcd_eq_zero_left h0 }
apply int.nat_abs_eq_zero.mp
apply nat.eq_zero_of_gcd_eq_zero_right h0
have hy : y = 0
{ apply int.nat_abs_eq_zero.mp, apply nat.eq_zero_of_gcd_eq_zero_right h0 }
norm_num [hx, hy]
{ have hx : x = 0, { apply int.nat_abs_eq_zero.mp, apply nat.eq_zero_of_gcd_eq_zero_left h0 }, have hy : y = 0, { apply int.nat_abs_eq_zero.mp, apply nat.eq_zero_of_gcd_eq_zero_right h0 }, use [0, 1, 0], norm_num [hx, hy], }
use [0, 1, 0]
apply h.is_classified_of_normalize_is_primitive_classified
apply h.normalize.is_primitive_classified_of_coprime
apply int.gcd_div_gcd_div_gcd (nat.pos_of_ne_zero h0)
rw [legendre_sym_eq_pow, gauss_lemma_aux₂ p ha0]; simp
simp
rw [legendre_sym_eq_pow, gauss_lemma_aux₂ p ha0]
cases legendre_sym_eq_one_or_neg_one a p ha0
cases legendre_sym_eq_one_or_neg_one a p ha0; cases neg_one_pow_eq_or ℤ ((Ico 1 (p / 2).succ).filter (λ x : ℕ, p / 2 < (a * x : zmod p).val)).card; simp [*, ne_neg_self p one_ne_zero, (ne_neg_self p one_ne_zero).symm] at *
cases legendre_sym_eq_one_or_neg_one a p ha0; cases neg_one_pow_eq_or ℤ ((Ico 1 (p / 2).succ).filter (λ x : ℕ, p / 2 < (a * x : zmod p).val)).card
cases neg_one_pow_eq_or ℤ ((Ico 1 (p / 2).succ).filter (λ x : ℕ, p / 2 < (a * x : zmod p).val)).card
cases neg_one_pow_eq_or ℤ ((Ico 1 (p / 2).succ).filter (λ x : ℕ, p / 2 < (a * x : zmod p).val)).card
simp [*, ne_neg_self p one_ne_zero, (ne_neg_self p one_ne_zero).symm] at *
simp [*, ne_neg_self p one_ne_zero, (ne_neg_self p one_ne_zero).symm] at *
simp [*, ne_neg_self p one_ne_zero, (ne_neg_self p one_ne_zero).symm] at *
simp [*, ne_neg_self p one_ne_zero, (ne_neg_self p one_ne_zero).symm] at *
apply_instance
simp [ext]
simp [ext]
simp [bit1]
rcases eq_Inf_coatoms b with ⟨s, rfl, hs⟩
cases s.eq_empty_or_nonempty with h h
{ simp [h] }
simp [h]
exact or.intro_right _ ⟨h.some, hs _ h.some_spec, Inf_le h.some_spec⟩
rw [h, hs]
rw [h, hi.eq_bot]
rw disjoint_iff at w
rw [←w, right_eq_inf]
rwa sup_eq_left at h
exact h.1
rw sup_comm
exact h.2
rw inf_comm
cases a; simp [none_eq_bot, some_eq_coe]
simp [none_eq_bot, some_eq_coe]
simp [none_eq_bot, some_eq_coe]
cases a
rcases ha with ⟨b, rfl, c, rfl, rfl⟩
simp at ha
exact ⟨_, rfl, le_sup_left⟩
rcases ha with ⟨b, rfl, c, rfl, rfl⟩
simp at ha
exact ⟨_, rfl, le_sup_right⟩
cases ha
rcases h₁ a rfl with ⟨b, ⟨⟩, ab⟩
rcases h₂ a rfl with ⟨c, ⟨⟩, ac⟩
exact ⟨_, rfl, sup_le ab ac⟩
cases eq_or_lt_of_le (le_sup_right : a ≤ x ⊔ a) with h₁ h₂
{ exact h₁.symm ▸ le_sup_left }
exact h₁.symm ▸ le_sup_left
obtain ⟨y, lty, ylt⟩ := exists_between h₂
apply (not_lt_of_le (sup_le (hx ⟨lty, ylt.trans_le (sup_le _ h.le)⟩) lty.le) ylt).elim
obtain ⟨u, au, ub⟩ := exists_between h
apply (hx ⟨au, ub⟩).trans ub.le
exact is_least_singleton.union hs
rw insert_eq
refl
ext
rw is_compact_element_iff_le_of_directed_Sup_le at hk
by_contradiction
from Sup_le (λ s hs, (hbelow s hs).le)
have sSup : Sup s ≤ k
replace sSup : Sup s = k := eq_iff_le_not_lt.mpr ⟨sSup, h⟩
obtain ⟨x, hxs, hkx⟩ := hk s hemp hdir sSup.symm.le
obtain hxk := hbelow x hxs
exact hxk.ne (hxk.le.antisymm hkx)
obtain ⟨t, ht₁, ht₂⟩ := h s
intros s hne hsc
clear h
cases t.eq_empty_or_nonempty with h h
rw finset.sup_empty at ht₂
rw ht₂
subst h
simp [eq_singleton_bot_of_Sup_eq_bot_of_nonempty ht₂ hne]
{ subst h, rw finset.sup_empty at ht₂, rw ht₂, simp [eq_singleton_bot_of_Sup_eq_bot_of_nonempty ht₂ hne], }
exact t.sup_closed_of_sup_closed h ht₁ hsc
rw ht₂
symmetry
have hle : Sup {a : α | is_atom a ∧ a ≤ b} ≤ b := (Sup_le $ λ _, and.right)
apply (lt_or_eq_of_le hle).resolve_left (λ con, _)
obtain ⟨c, hc⟩ := exists_is_compl (⟨Sup {a : α | is_atom a ∧ a ≤ b}, hle⟩ : set.Iic b)
obtain rfl | ⟨a, ha, hac⟩ := eq_bot_or_exists_atom_le c
exact ne_of_lt con (subtype.ext_iff.1 (eq_top_of_is_compl_bot hc))
{ exact ne_of_lt con (subtype.ext_iff.1 (eq_top_of_is_compl_bot hc)) }
apply ha.1
rw eq_bot_iff
apply le_trans (le_inf _ hac) hc.1
rw [← subtype.coe_le_coe, subtype.coe_mk]
exact le_Sup ⟨ha.of_is_atom_coe_Iic, a.2⟩
simp only [disjoint_iff, supr_inf_eq, supr_eq_bot]
simp [compl_infi]
simpa only [range_comp, subtype.range_coe, supr_subtype'] using @is_lub_supr α s _ (f ∘ coe)
refine (supr_le_supr $ λ i, _).trans (supr_comp_le _ f)
exact supr_le_supr_const hf.ne
simp
simp
refine { le := le, top := top, bot := bot, sup := sup, inf := inf, Sup := Sup, Inf := Inf, .. complete_lattice.copy (@complete_distrib_lattice.to_complete_lattice α c) le eq_le top eq_top bot eq_bot sup eq_sup inf eq_inf Sup eq_Sup Inf eq_Inf, .. }
abstract { subst_vars, casesI c, assumption }
abstract { subst_vars, casesI c, assumption }
subst_vars
casesI c
all_goals { abstract { subst_vars, casesI c, assumption } }
assumption
apply tendsto_at_top.2 (λb, _)
obtain ⟨n : ℕ, hn : 1 ≤ n • r⟩ := archimedean.arch 1 hr
rwa nsmul_eq_mul at hn
have hn' : 1 ≤ (n : R) * r
filter_upwards [tendsto_at_top.1 hf (max b 0 * n)]
assume x hx
rw [mul_one]
calc b ≤ max b 0 * 1 : by { rw [mul_one], exact le_max_left _ _ } ... ≤ max b 0 * (n * r) : mul_le_mul_of_nonneg_left hn' (le_max_right _ _) ... = (max b 0 * n) * r : by rw [mul_assoc] ... ≤ f x * r : mul_le_mul_of_nonneg_right hx (le_of_lt hr)
exact le_max_left _ _
rw [mul_assoc]
apply le_antisymm; refine map_at_top_finset_prod_le_of_prod_eq (λ s, _)
refine map_at_top_finset_prod_le_of_prod_eq (λ s, _)
refine map_at_top_finset_prod_le_of_prod_eq (λ s, _)
apply le_antisymm
refine ⟨s.preimage g (hg.inj_on _), λ t ht, _⟩
refine ⟨t.image g ∪ s, finset.subset_union_right _ _, _⟩
rw [← finset.prod_image (hg.inj_on _)]
refine (prod_subset (subset_union_left _ _) _).symm
simp only [finset.mem_union, finset.mem_image]
refine λ y hy hyt, hf y (mt _ hyt)
rintros ⟨x, rfl⟩
exact ⟨x, ht (finset.mem_preimage.2 $ hy.resolve_left hyt), rfl⟩
{ refine ⟨s.preimage g (hg.inj_on _), λ t ht, _⟩, refine ⟨t.image g ∪ s, finset.subset_union_right _ _, _⟩, rw [← finset.prod_image (hg.inj_on _)], refine (prod_subset (subset_union_left _ _) _).symm, simp only [finset.mem_union, finset.mem_image], refine λ y hy hyt, hf y (mt _ hyt), rintros ⟨x, rfl⟩, exact ⟨x, ht (finset.mem_preimage.2 $ hy.resolve_left hyt), rfl⟩ }
refine ⟨s.image g, λ t ht, _⟩
simp only [← prod_preimage _ _ (hg.inj_on _) _ (λ x _, hf x)]
exact ⟨_, (image_subset_iff_subset_preimage _).1 ht, rfl⟩
refine ⟨λ h, _, λ h, tendsto_neg_const_mul_pow_at_top h.1 h.2⟩
simp only [tendsto_at_bot, eventually_at_top] at h
have : c < 0 := let ⟨x, hx⟩ := h (-1) in neg_of_mul_neg_right (lt_of_le_of_lt (hx (max x 1) (le_max_left x 1)) (by simp [zero_lt_one])) (pow_nonneg (le_trans zero_le_one (le_max_right x 1)) n)
simp [zero_lt_one]
refine ⟨nat.succ_le_iff.mp (lt_of_le_of_ne (zero_le n) (ne.symm (λ hn, _))), this⟩
obtain ⟨x, hx⟩ := h (c - 1)
specialize hx x le_rfl
rw [hn, pow_zero, mul_one, le_sub, sub_self] at hx
exact absurd hx (not_le.mpr zero_lt_one)
apply le_antisymm
intros U U_in
rcases B.mem_filter_iff.mp U_in with ⟨V, V_in, h⟩
exact generate_sets.superset (generate_sets.basic V_in) h
{ intros U U_in, rcases B.mem_filter_iff.mp U_in with ⟨V, V_in, h⟩, exact generate_sets.superset (generate_sets.basic V_in) h }
rw sets_iff_generate
apply mem_filter_of_mem
exact inf_ne_bot_iff_frequently_left
rw inf_comm
rcases cblb.exists_countable_infi_principal with ⟨B, Bcbl, rfl⟩
exact countable_binfi_principal_eq_seq_infi Bcbl
simpa [h]
simp [h]
simp only [has_bind.bind, bind, functor.map, mem_map', mem_join, mem_set_of_eq, function.comp, mem_pure]
simp only [tendsto, le_pure_iff, mem_map', mem_singleton_iff, filter.eventually]
simp only [filter.prod, eq_self_iff_true]
rw [filter.prod, comap_infi, inf_infi]
simp [mem_binfi_of_directed h ne]
simp only [*, hst.1 hxs, indicator_of_mem]
simp only [indicator_of_not_mem hxs, indicator_of_not_mem (mt hst.2 hxs)]
simp only [id, ← exists_mem_subset_iff]
split
ext s
rintros ⟨a, b, ⟨a₁, a₂, ha₁, ha₂, a₁a₂⟩, hb, ab⟩
rw [← mul_assoc]
refine ⟨a₁, a₂ * b, ha₁, mul_mem_mul ha₂ hb, _⟩
exact calc a₁ * a₂ * b ⊆ a * b : mul_subset_mul a₁a₂ (subset.refl _) ... ⊆ s : ab
{ rintros ⟨a, b, ⟨a₁, a₂, ha₁, ha₂, a₁a₂⟩, hb, ab⟩, refine ⟨a₁, a₂ * b, ha₁, mul_mem_mul ha₂ hb, _⟩, rw [← mul_assoc], exact calc a₁ * a₂ * b ⊆ a * b : mul_subset_mul a₁a₂ (subset.refl _) ... ⊆ s : ab }
rintros ⟨a, b, ha, ⟨b₁, b₂, hb₁, hb₂, b₁b₂⟩, ab⟩
rw [mul_assoc]
refine ⟨a * b₁, b₂, mul_mem_mul ha hb₁, hb₂, _⟩
exact calc a * (b₁ * b₂) ⊆ a * b : mul_subset_mul (subset.refl _) b₁b₂ ... ⊆ s : ab
resetI
simp only [← u.unique (map_le_iff_le_comap.2 hgu), comap_map inj, le_rfl]
simp only [image_pair, is_lub_pair]
rw gi.choice_eq
exact (gi.is_glb_of_u_image (is_glb_Inf _)).1
rw gi.choice_eq
exact (gi.is_glb_of_u_image (is_glb_Inf _)).2
simp [upper_bounds, gc _ _]
rw function.iterate_zero
exact le_rfl
rw function.iterate_succ_apply'
exact (id_le_iterate_of_id_le n x).trans (h _)
simp [le_refl]
haveI := A
haveI := A; exact x ≤ y
exact x ≤ y
haveI := A
haveI := A; exact (x ⊔ y)
exact (x ⊔ y)
simp only [sup_le_iff]; rw [← H, @sup_le_iff α A, H, H]
rw [← H, @sup_le_iff α A, H, H]
simp only [sup_le_iff]
rw [sup_eq_right, ←inf_eq_left]
intro
dsimp [continuous] at *
rw [hfc,hgc,chain.map_comp]
intro c; rw [ωSup_bind, ← hf', ← hg']; refl
intro c; rw [ωSup_bind, ← hf', ← hg']
rw [ωSup_bind, ← hf', ← hg']
refl
intro c
suffices : (⨆ (m : ℕ), a m) ≤ monotonic_sequence_limit a
{ exact le_antisymm this (le_supr a _), }
exact le_antisymm this (le_supr a _)
apply supr_le
intros m
by_cases hm : m ≤ monotonic_sequence_limit_index a
{ exact a.monotone hm, }
exact a.monotone hm
replace hm := le_of_not_le hm
let S := { n | ∀ m, n ≤ m → a n = a m }
have hInf : Inf S ∈ S
rw well_founded.monotone_chain_condition at h
exact h a
refine nat.Inf_mem _
{ refine nat.Inf_mem _, rw well_founded.monotone_chain_condition at h, exact h a, }
change Inf S ≤ m at hm
change a m ≤ a (Inf S)
rw hInf m hm
induction n with n ih
{ simp }
simp
dsimp [partial_sups] at ih ⊢
simp_rw @finset.range_succ n.succ
rw [ih, finset.sup'_insert, sup_comm]
intros h
intros h
split
split; intros h
{ exact h 1 0, }
exact h 1 0
have h' : ∀ n a₁ a₂, f^[n] (a₁ ⊔ a₂) ≤ (f^[n] a₁) ⊔ a₂
intros n₁ n₂ a₁ a₂
induction n with n ih
induction n with n ih; intros a₁ a₂
intros a₁ a₂
intros a₁ a₂
intros n
{ refl, }
refl
calc f^[n + 1] (a₁ ⊔ a₂) = (f^[n] (f (a₁ ⊔ a₂))) : function.iterate_succ_apply f n _ ... ≤ (f^[n] ((f a₁) ⊔ a₂)) : f.mono.iterate n (h a₁ a₂) ... ≤ (f^[n] (f a₁)) ⊔ a₂ : ih _ _ ... = (f^[n + 1] a₁) ⊔ a₂ : by rw ← function.iterate_succ_apply
rw ← function.iterate_succ_apply
{ intros n, induction n with n ih; intros a₁ a₂, { refl, }, { calc f^[n + 1] (a₁ ⊔ a₂) = (f^[n] (f (a₁ ⊔ a₂))) : function.iterate_succ_apply f n _ ... ≤ (f^[n] ((f a₁) ⊔ a₂)) : f.mono.iterate n (h a₁ a₂) ... ≤ (f^[n] (f a₁)) ⊔ a₂ : ih _ _ ... = (f^[n + 1] a₁) ⊔ a₂ : by rw ← function.iterate_succ_apply, }, }
calc f^[n₁ + n₂] (a₁ ⊔ a₂) = (f^[n₁] (f^[n₂] (a₁ ⊔ a₂))) : function.iterate_add_apply f n₁ n₂ _ ... = (f^[n₁] (f^[n₂] (a₂ ⊔ a₁))) : by rw sup_comm ... ≤ (f^[n₁] ((f^[n₂] a₂) ⊔ a₁)) : f.mono.iterate n₁ (h' n₂ _ _) ... = (f^[n₁] (a₁ ⊔ (f^[n₂] a₂))) : by rw sup_comm ... ≤ (f^[n₁] a₁) ⊔ (f^[n₂] a₂) : h' n₁ a₁ _
rw sup_comm
rw sup_comm
cases le_or_lt n m with h
symmetry
exact strict_mono.monotone (λ x y, a.map_rel) h
rw [inf_eq_right.mpr h, inf_eq_right]
{ rw [inf_eq_right.mpr h, inf_eq_right], exact strict_mono.monotone (λ x y, a.map_rel) h, }
exact le_of_lt (a.map_rel h)
rw [inf_eq_left.mpr (le_of_lt h), inf_eq_left]
congr
exact h
ext
refl
simp only [(Δ), sdiff_eq]
rw [sdiff_symm_diff, sdiff_sup, sup_comm]
apply min_mem
rw [well_founded.succ, dif_pos h]
classical
revert hf
apply f.induction_on
intro h
{ intro h, simp [set.is_pwo_empty.is_wf], }
simp [set.is_pwo_empty.is_wf]
intros s f sf hf hsf
rw finset.sup_insert
exact (hsf s (finset.mem_insert_self _ _)).union (hf (λ s' s'f, hsf _ (finset.mem_insert_of_mem s'f)))
rcases s.eq_empty_or_nonempty with rfl | ⟨as, has⟩
apply partially_well_ordered_on.mono (finset.partially_well_ordered_on {list.nil})
intros l hl
rw [finset.mem_coe, finset.mem_singleton, list.eq_nil_iff_forall_not_mem]
{ intros l hl, rw [finset.mem_coe, finset.mem_singleton, list.eq_nil_iff_forall_not_mem], exact hl, }
exact hl
{ apply partially_well_ordered_on.mono (finset.partially_well_ordered_on {list.nil}), { intros l hl, rw [finset.mem_coe, finset.mem_singleton, list.eq_nil_iff_forall_not_mem], exact hl, }, apply_instance }
apply_instance
haveI : inhabited α := ⟨as⟩
rw [iff_not_exists_is_min_bad_seq (list.length)]
rintro ⟨f, hf1, hf2⟩
have hnil : ∀ n, f n ≠ list.nil := λ n con, (hf1).2 n n.succ n.lt_succ_self (con.symm ▸ list.sublist_forall₂.nil)
obtain ⟨g, hg⟩ := h.exists_monotone_subseq (list.head ∘ f) _
simp only [set.range_subset_iff, function.comp_apply]
swap
exact λ n, hf1.1 (set.mem_range_self n) _ (list.head_mem_self (hnil n))
{ simp only [set.range_subset_iff, function.comp_apply], exact λ n, hf1.1 (set.mem_range_self n) _ (list.head_mem_self (hnil n)) }
have hf' := hf2 (g 0) (λ n, if n < g 0 then f n else list.tail (f (g (n - g 0)))) (λ m hm, (if_pos hm).symm) _
simp only [if_neg (lt_irrefl (g 0)), nat.sub_self]
swap
rw [list.length_tail, ← nat.pred_eq_sub_one]
exact nat.pred_lt (λ con, hnil _ (list.length_eq_zero.1 con))
{ simp only [if_neg (lt_irrefl (g 0)), nat.sub_self], rw [list.length_tail, ← nat.pred_eq_sub_one], exact nat.pred_lt (λ con, hnil _ (list.length_eq_zero.1 con)) }
rw [is_bad_seq] at hf'
push_neg at hf'
obtain ⟨m, n, mn, hmn⟩ := hf' _
rw set.range_subset_iff
swap
rintro n x hx
split_ifs at hx with hn hn
{ exact hf1.1 (set.mem_range_self _) _ hx }
exact hf1.1 (set.mem_range_self _) _ hx
{ rw set.range_subset_iff, rintro n x hx, split_ifs at hx with hn hn, { exact hf1.1 (set.mem_range_self _) _ hx }, { refine hf1.1 (set.mem_range_self _) _ (list.tail_subset _ hx), } }
refine hf1.1 (set.mem_range_self _) _ (list.tail_subset _ hx)
by_cases hn : n < g 0
apply hf1.2 m n mn
{ apply hf1.2 m n mn, rwa [if_pos hn, if_pos (mn.trans hn)] at hmn }
rwa [if_pos hn, if_pos (mn.trans hn)] at hmn
obtain ⟨n', rfl⟩ := le_iff_exists_add.1 (not_lt.1 hn)
rw [if_neg hn, add_comm (g 0) n', nat.add_sub_cancel] at hmn
split_ifs at hmn with hm hm
apply hf1.2 m (g n') (lt_of_lt_of_le hm (g.monotone n'.zero_le))
{ apply hf1.2 m (g n') (lt_of_lt_of_le hm (g.monotone n'.zero_le)), exact trans hmn (list.tail_sublist_forall₂_self _) }
exact trans hmn (list.tail_sublist_forall₂_self _)
rw [← (nat.sub_lt_left_iff_lt_add (le_of_not_lt hm))] at mn
apply hf1.2 _ _ (g.lt_iff_lt.2 mn)
rw [← list.cons_head_tail (hnil (g (m - g 0))), ← list.cons_head_tail (hnil (g n'))]
exact list.sublist_forall₂.cons (hg _ _ (le_of_lt mn)) hmn
rintro _ ⟨p, hpc, rfl⟩ _ ⟨q, hqc, rfl⟩ hpq
rintro _ ⟨p, hpc, rfl⟩ _ ⟨q, hqc, rfl⟩ hpq; exact hc p hpc q hqc (mt (by rintro rfl; refl) hpq)
exact hc p hpc q hqc (mt (by rintro rfl; refl) hpq)
rintro rfl
rintro rfl; refl
refl
intros t₁ t₂ ht₁ ht₂
have hf_m : ∀ (x : ι), x ∈ {i, j} → (ite (x=i) t₁ t₂) ∈ s x
intros x hx
cases finset.mem_insert.mp hx with hx hx
{ simp [hx, ht₁], }
simp [hx, ht₁]
{ simp [finset.mem_singleton.mp hx, hij.symm, ht₂], }
{ intros x hx, cases finset.mem_insert.mp hx with hx hx, { simp [hx, ht₁], }, { simp [finset.mem_singleton.mp hx, hij.symm, ht₂], }, }
simp [finset.mem_singleton.mp hx, hij.symm, ht₂]
have h1 : t₁ = ite (i = i) t₁ t₂
simp only [if_true, eq_self_iff_true]
have h2 : t₂ = ite (j = i) t₁ t₂
simp only [hij.symm, if_false]
have h_inter : (⋂ (t : ι) (H : t ∈ ({i, j} : finset ι)), ite (t = i) t₁ t₂) = (ite (i = i) t₁ t₂) ∩ (ite (j = i) t₁ t₂)
simp only [finset.set_bInter_singleton, finset.set_bInter_insert]
have h_prod : (∏ (t : ι) in ({i, j} : finset ι), μ (ite (t = i) t₁ t₂)) = μ (ite (i = i) t₁ t₂) * μ (ite (j = i) t₁ t₂)
simp only [hij, finset.prod_singleton, finset.prod_insert, not_false_iff, finset.mem_singleton]
rw h1
nth_rewrite 1 h2
nth_rewrite 3 h2
rw [←h_inter, ←h_prod, h_indep {i, j} hf_m]
rw [← algebra_map_eq, ← aeval_def, aeval_eq, mk_self]
apply ideal.quotient.lift _ (eval₂_ring_hom i x)
intros g H
rcases mem_span_singleton.1 H with ⟨y, hy⟩
rw [hy, ring_hom.map_mul, coe_eval₂_ring_hom, h, zero_mul]
rw [power_basis_gen, minpoly_root hf, polynomial.map_mul, roots_mul, polynomial.map_C, roots_C, add_zero, equiv.refl_apply]
exact map_monic_ne_zero (monic_mul_leading_coeff_inv hf)
rw ← polynomial.map_mul
rw [is_artinian_iff_well_founded]; exact (well_founded.monotone_chain_condition (order_dual (submodule R M))).symm
rw [is_artinian_iff_well_founded]
exact (well_founded.monotone_chain_condition (order_dual (submodule R M))).symm
rw [← hb, gcd_eq_gcd_ab, mul_comm x, mul_comm y, mul_add, mul_assoc, mul_assoc]
refine ⟨λ h, _, algebra.finite_type.of_finite_presentation⟩
obtain ⟨n, f, hf⟩ := algebra.finite_type.iff_quotient_mv_polynomial''.1 h
refine ⟨n, f, hf, _⟩
have hnoet : is_noetherian_ring (mv_polynomial (fin n) R) := by apply_instance
apply_instance
replace hnoet := (is_noetherian_ring_iff.1 hnoet).noetherian
exact hnoet f.to_ring_hom.ker
letI := f.to_algebra
exact module.finite.of_surjective (algebra.of_id A B).to_linear_map hf
rw is_noetherian_iff
intros J hJ
obtain ⟨J, rfl⟩ := le_one_iff_exists_coe_ideal.mp (le_trans hJ coe_ideal_le_one)
exact fg_map (is_noetherian.noetherian J)
intros x hx
convert submodule.zero_mem _
simpa using hx
ext n
simp only [algebra_map_apply, power_series.algebra_map_apply, ring_equiv.to_fun_eq_coe, C_apply, coeff_to_power_series]
cases n
simp only [power_series.coeff_zero_eq_constant_coeff, single_coeff_same]
{ simp only [power_series.coeff_zero_eq_constant_coeff, single_coeff_same], refl }
refl
simp only [n.succ_ne_zero, ne.def, not_false_iff, single_coeff_of_ne]
rw [power_series.coeff_C, if_neg n.succ_ne_zero]
rw [← add_zero a, single_mul_coeff_add, add_zero]
apply le_antisymm
apply order_le_of_coeff_ne_zero
rw [mul_coeff_order_add_order hx hy]
exact mul_ne_zero (coeff_order_ne_zero hx) (coeff_order_ne_zero hy)
{ apply order_le_of_coeff_ne_zero, rw [mul_coeff_order_add_order hx hy], exact mul_ne_zero (coeff_order_ne_zero hx) (coeff_order_ne_zero hy) }
rw [order_of_ne hx, order_of_ne hy, order_of_ne (mul_ne_zero hx hy), ← set.is_wf.min_add]
exact set.is_wf.min_le_min_of_subset (support_mul_subset_add_support)
contrapose! h
rw ← C_zero at h
exact C_injective h
by_cases h : r = 0
{ rw [h, C_zero, order_zero] }
rw [h, C_zero, order_zero]
exact order_single h
intros b
obtain ⟨a, rfl⟩ := hf b
apply (local_ring.is_unit_or_is_unit_one_sub_self a).imp f.is_unit_map _
rw [← f.map_one, ← f.map_sub]
apply f.is_unit_map
rw [h, sub_zero]
rw [h, sub_zero]; exact is_unit_one
exact is_unit_one
rw [radical_eq_Inf, radical_eq_Inf]
have : ∀ J ∈ {J : ideal R | I ≤ J ∧ J.is_prime}, f.ker ≤ J := λ J hJ, le_trans h hJ.left
convert map_Inf hf this
refine funext (λ j, propext ⟨_, _⟩)
rintros ⟨hj, hj'⟩
haveI : j.is_prime := hj'
exact ⟨comap f j, ⟨⟨map_le_iff_le_comap.1 hj, comap_is_prime f j⟩, map_comap_of_surjective f hf j⟩⟩
{ rintros ⟨hj, hj'⟩, haveI : j.is_prime := hj', exact ⟨comap f j, ⟨⟨map_le_iff_le_comap.1 hj, comap_is_prime f j⟩, map_comap_of_surjective f hf j⟩⟩ }
rintro ⟨J, ⟨hJ, hJ'⟩⟩
haveI : J.is_prime := hJ.right
refine ⟨hJ' ▸ map_mono hJ.left, hJ' ▸ map_is_prime_of_surjective hf (le_trans h hJ.left)⟩
obtain ⟨a, rfl⟩ := quotient.mkₐ_surjective R _ x
rw [← alg_hom.map_smul, quotient.mkₐ_eq_mk, ring_hom.ker_lift_mk]
exact f.map_smul _ _
simp [set.singleton_one]
induction n with n ih
{ simp [set.singleton_one], }
simp only [pow_succ, ih, span_singleton_mul_span_singleton]
intros
intros; rw [← int.coe_nat_mul, gcd_mul_lcm, coe_nat_abs_eq_normalize]
rw [← int.coe_nat_mul, gcd_mul_lcm, coe_nat_abs_eq_normalize]
apply unique_factorization_monoid.induction_on_prime
exact h₀
intros n h
rw nat.is_unit_iff.1 h
{ intros n h, rw nat.is_unit_iff.1 h, exact h₁, }
exact h₁
intros a p _ hp ha
exact h p a (nat.prime_iff.2 hp) ha
haveI : decidable_eq R := classical.dec_eq _
refine le_trans _ (nth_roots n (f g₀)).to_finset_card_le
apply card_le_card_of_inj_on f
intros g hg
rw [sep_def, mem_filter] at hg
rw [multiset.mem_to_finset, mem_nth_roots hn, ← f.map_pow, hg.2]
{ intros g hg, rw [sep_def, mem_filter] at hg, rw [multiset.mem_to_finset, mem_nth_roots hn, ← f.map_pow, hg.2] }
apply hf
assumption
intros
letI : is_fraction_ring (integral_closure R L) L := is_fraction_ring_of_finite_extension K L
exact (integral_closure_eq_bot_iff L).mp integral_closure_idem
rw [is_noetherian_ring_iff, is_noetherian_iff_well_founded] at h ⊢
exact order_embedding.well_founded ((is_localization.order_embedding M S).dual) h
rw [zero_mul, h, ring_hom.map_zero]
simp only [smul_mk, zero_nsmul, mk_zero]
simp only [smul_mk, succ_nsmul, add_mk_self]
simp only [smul_mk, zero_gsmul, mk_zero]
simp [smul_mk, add_mk_self, -mk_eq_monoid_of_mk', add_comm (n : ℤ) 1, add_smul]
rw [smul_mk, smul_mk, neg_mk, ← neg_smul]
refl
tac
tac
tac
exact localization.induction_on y (by tac)
tac
tac
tac
tac
rw [← mk_zero (1 : M), mk_one_eq_monoid_of_mk]
simp only [← mk_one_eq_monoid_of_mk, add_mk, submonoid.coe_one, one_mul, add_comm]
rw [enat.get_eq_iff_eq_coe, eq_coe_iff, pow_zero]
simpa [is_unit_iff_dvd_one.symm] using not_unit_of_finite ha
rcases lt_trichotomy (multiplicity p a) (multiplicity p b) with hab|hab|hab
rw [add_comm, multiplicity_add_of_gt hab, min_eq_left]
exact le_of_lt hab
{ rw [add_comm, multiplicity_add_of_gt hab, min_eq_left], exact le_of_lt hab }
{ contradiction }
contradiction
exact le_of_lt hab
rw [multiplicity_add_of_gt hab, min_eq_right]
simp [one_right hp.not_unit]
simp [pow_succ, succ_nsmul, pow, multiplicity.mul hp]
refine le_antisymm _ (submodule.smul_le.2 (λ _ _ _, submodule.smul_mem _ _))
intros n hn
cases submodule.exists_sub_one_mem_and_smul_eq_zero_of_fg_of_le_smul I N hN hIN with r hr
cases exists_mul_sub_mem_of_sub_one_mem_jacobson r (hIjac hr.1) with s hs
have : n = (-(r * s - 1) • n)
rw [neg_sub, sub_smul, mul_comm, mul_smul, hr.2 n hn, one_smul, smul_zero, sub_zero]
{ rw [neg_sub, sub_smul, mul_comm, mul_smul, hr.2 n hn, one_smul, smul_zero, sub_zero] }
rw this
exact submodule.smul_mem_smul (submodule.neg_mem _ hs) hn
obtain ⟨n, hn⟩ := h
use n
rw [neg_pow, hn, mul_zero]
let i := ((quotient.mk I).comp C).range_restrict
have hi' : (polynomial.map_ring_hom i).ker ≤ I
refine λ f hf, polynomial_mem_ideal_of_coeff_mem_ideal I f (λ n, _)
rw [mem_comap, ← quotient.eq_zero_iff_mem, ← ring_hom.comp_apply]
rw [ring_hom.mem_ker, coe_map_ring_hom] at hf
replace hf := congr_arg (λ (f : polynomial _), f.coeff n) hf
simp only [coeff_map, coeff_zero] at hf
rwa [subtype.ext_iff, ring_hom.coe_range_restrict] at hf
{ refine λ f hf, polynomial_mem_ideal_of_coeff_mem_ideal I f (λ n, _), rw [mem_comap, ← quotient.eq_zero_iff_mem, ← ring_hom.comp_apply], rw [ring_hom.mem_ker, coe_map_ring_hom] at hf, replace hf := congr_arg (λ (f : polynomial _), f.coeff n) hf, simp only [coeff_map, coeff_zero] at hf, rwa [subtype.ext_iff, ring_hom.coe_range_restrict] at hf }
obtain ⟨x, hx'⟩ := x
obtain ⟨y, rfl⟩ := (ring_hom.mem_range).1 hx'
refine subtype.eq _
simp only [ring_hom.comp_apply, quotient.eq_zero_iff_mem, subring.coe_zero, subtype.val_eq_coe]
suffices : C (i y) ∈ (I.map (polynomial.map_ring_hom i))
obtain ⟨f, hf⟩ := mem_image_of_mem_map_of_surjective (polynomial.map_ring_hom i) (polynomial.map_surjective _ (((quotient.mk I).comp C).range_restrict_surjective)) this
refine sub_add_cancel (C y) f ▸ I.add_mem (hi' _ : (C y - f) ∈ I) hf.1
rw [ring_hom.mem_ker, ring_hom.map_sub, hf.2, sub_eq_zero, coe_map_ring_hom, map_C]
{ obtain ⟨f, hf⟩ := mem_image_of_mem_map_of_surjective (polynomial.map_ring_hom i) (polynomial.map_surjective _ (((quotient.mk I).comp C).range_restrict_surjective)) this, refine sub_add_cancel (C y) f ▸ I.add_mem (hi' _ : (C y - f) ∈ I) hf.1, rw [ring_hom.mem_ker, ring_hom.map_sub, hf.2, sub_eq_zero, coe_map_ring_hom, map_C] }
exact hx
rw [← C_mul']
exact I.mul_mem_left _ H
apply le_antisymm
replace hp := mem_degree_le.1 hp
intros p hp
rw [← polynomial.sum_monomial_eq p, polynomial.sum]
refine submodule.sum_mem _ (λ k hk, _)
show monomial _ _ ∈ _
have := with_bot.coe_le_coe.1 (finset.sup_le_iff.1 hp k hk)
rw [monomial_eq_C_mul_X, C_mul']
refine submodule.smul_mem _ _ (submodule.subset_span $ finset.mem_coe.2 $ finset.mem_image.2 ⟨_, finset.mem_range.2 (nat.lt_succ_of_le this), rfl⟩)
{ intros p hp, replace hp := mem_degree_le.1 hp, rw [← polynomial.sum_monomial_eq p, polynomial.sum], refine submodule.sum_mem _ (λ k hk, _), show monomial _ _ ∈ _, have := with_bot.coe_le_coe.1 (finset.sup_le_iff.1 hp k hk), rw [monomial_eq_C_mul_X, C_mul'], refine submodule.smul_mem _ _ (submodule.subset_span $ finset.mem_coe.2 $ finset.mem_image.2 ⟨_, finset.mem_range.2 (nat.lt_succ_of_le this), rfl⟩) }
rw [submodule.span_le, finset.coe_image, set.image_subset_iff]
apply mem_degree_le.2
intros k hk
exact (degree_X_pow_le _).trans (with_bot.coe_le_coe.2 $ nat.le_of_lt_succ $ finset.mem_range.1 hk)
intros v hv
rcases submodule.mem_sup.1 hv with ⟨x, hx, y, hy, hxy⟩
have h_eval_x : aeval f (p * q) x = 0
rw [mul_comm, aeval_mul, linear_map.mul_apply, linear_map.mem_ker.1 hx, linear_map.map_zero]
{ rw [mul_comm, aeval_mul, linear_map.mul_apply, linear_map.mem_ker.1 hx, linear_map.map_zero] }
have h_eval_y : aeval f (p * q) y = 0
rw [aeval_mul, linear_map.mul_apply, linear_map.mem_ker.1 hy, linear_map.map_zero]
{ rw [aeval_mul, linear_map.mul_apply, linear_map.mem_ker.1 hy, linear_map.map_zero] }
rw [linear_map.mem_ker, ←hxy, linear_map.map_add, h_eval_x, h_eval_y, add_zero]
simp only [function.comp_app, ring_hom.coe_comp, ideal.quotient.eq_zero_iff_mem]
exact ideal.mem_map_of_mem _ hi
haveI := arbitrary (normalization_monoid D)
haveI := to_gcd_monoid D
exact ufm_of_gcd_of_wf_dvd_monoid
rw [bernstein_polynomial.iterate_derivative_at_1 _ _ _ h, ne.def, neg_one_pow_mul_eq_zero_iff, ←nat.cast_succ, ←pochhammer_eval_cast, ←nat.cast_zero, nat.cast_inj]
exact (pochhammer_pos _ _ (nat.succ_pos ν)).ne'
rw [← one_mul p.prim_part, ← C_1, ← hp.content_eq_one, ← p.eq_C_content_mul_prim_part]
rw content
by_cases h0 : r = 0
{ simp [h0] }
simp [h0]
have h : (C r).support = {0} := support_monomial _ _ h0
simp [h]
simp only [cyclotomic', finset.prod_singleton, ring_hom.map_one, is_primitive_root.primitive_roots_one]
convert finsupp.filter_apply (λ d : σ →₀ ℕ, ∑ i in d.support, d i = n) φ d
simp only [esymm, powerset_len_zero, sum_singleton, prod_empty]
rw [polynomial.aeval_def, polynomial.aeval_def, polynomial.eval₂_map, algebra_map_eq R S A]
rw [coeff_trunc, coeff_C, mv_polynomial.coeff_C]
split_ifs with H; refl <|> try {simp * at *}
refl
refl
refl
refl
refl
refl
try {simp * at *}
try {simp * at *}
try {simp * at *}
simp * at *
split_ifs with H
apply H
subst m
intro s
exact nat.zero_le _
exfalso
rw ← span_singleton_generator S
exact subset_span (mem_singleton _)
conv_rhs { rw ← span_singleton_generator S }
apply is_unit_of_mul_eq_one ζ (ζ ^ (k - 1))
rw [← pow_succ, nat.sub_add_cancel h0, h.pow_eq_one]
apply finset.eq_singleton_iff_unique_mem.2
split
simp only [is_primitive_root.one_right_iff, mem_primitive_roots zero_lt_one]
{ simp only [is_primitive_root.one_right_iff, mem_primitive_roots zero_lt_one] }
intros x hx
rw [mem_primitive_roots zero_lt_one, is_primitive_root.one_right_iff] at hx
exact hx
exact subtype.eq (eq.symm (mk_eq_mk_iff_associated.mpr hpq))
exact mem_factor_set_some.mpr (mem_factors'_of_dvd ha0 hp hd)
rw factors_mk _ ha0
cases count_of_coprime ha hb hab hp with hz hb0
tauto
{ tauto }
apply or.intro_right
rw [count_mul ha hb hp, hb0, add_zero]
apply wf_dvd_monoid.well_founded_associates
have h : (normalize : α → α) = associates.out ∘ associates.mk
rw [function.comp_apply, associates.out_mk]
{ ext, rw [function.comp_apply, associates.out_mk], }
ext
rw [← multiset.map_id' (factors (x * y)), ← multiset.map_id' (factors x), ← multiset.map_id' (factors y), ← multiset.map_congr normalize_factor, ← multiset.map_congr normalize_factor, ← multiset.map_congr normalize_factor, ← multiset.map_add, h, ← multiset.map_map associates.out, eq_comm, ← multiset.map_map associates.out]
refine congr rfl _
apply multiset.map_mk_eq_map_mk_of_rel
apply factors_unique
intros x hx
rcases multiset.mem_add.1 hx with hx | hx; exact irreducible_of_factor x hx
rcases multiset.mem_add.1 hx with hx | hx
{ intros x hx, rcases multiset.mem_add.1 hx with hx | hx; exact irreducible_of_factor x hx }
exact irreducible_of_factor x hx
exact irreducible_of_factor x hx
{ exact irreducible_of_factor }
exact irreducible_of_factor
rw multiset.prod_add
exact ((factors_prod hx).mul_mul (factors_prod hy)).trans (factors_prod (mul_ne_zero hx hy)).symm
rw h
rwa [factors_prod, factors_prod] at this
refine eq_of_factors_eq_factors _
rw [← prod_add, prod_factors, factors_mul, factor_set.sup_add_inf_eq_add]
obtain ⟨q, hq, hpq⟩ := exists_mem_factors_of_dvd ha0 hp hd
use q
use hq
apply multiset.mem_pmap.mpr
ghost_fun_tac (X 0 + X 1) ![x.coeff, y.coeff]
ghost_fun_tac (-X 0) ![x.coeff]
refine is_poly.ext ((frobenius_fun_is_poly p).comp (witt_vector.zero_is_poly)) ((witt_vector.zero_is_poly).comp (frobenius_fun_is_poly p)) _ _ 0
ghost_simp
refine is_poly.ext ((frobenius_fun_is_poly p).comp (witt_vector.one_is_poly)) ((witt_vector.one_is_poly).comp (frobenius_fun_is_poly p)) _ _ 0
ghost_simp
ghost_calc _ _
ghost_calc _ _; ghost_simp
ghost_simp
ghost_calc _ _
ghost_calc _ _; ghost_simp
ghost_simp
init_ring using witt_neg_vars
ext ⟨⟩; { rw zero_coeff, refl }
rw zero_coeff
refl
ext ⟨⟩
cases n
refl
{ refl }
exact f.map_zero
ext n
refine_struct { to_fun := lift_fun f }; { intros, rw [← sub_eq_zero, ← ideal.mem_bot, ← infi_ker_truncate, ideal.mem_infi], simp [ring_hom.mem_ker, f_compat] }
refine_struct { to_fun := lift_fun f }
intros
rw [← sub_eq_zero, ← ideal.mem_bot, ← infi_ker_truncate, ideal.mem_infi]
simp [ring_hom.mem_ker, f_compat]
exact f.map_zero
refl
ext ⟨-, -⟩
split
refine ⟨f $ sum.inl ⟨⟩, f $ sum.inr ⟨⟩, _⟩
rintro ⟨f⟩
intro h
cases f.2 h
{ rintro ⟨f⟩, refine ⟨f $ sum.inl ⟨⟩, f $ sum.inr ⟨⟩, _⟩, intro h, cases f.2 h }
by_contra h'
rintro ⟨x, y, h⟩
rw [not_le, ←nat.cast_two, nat_succ, lt_succ, nat.cast_one, le_one_iff_subsingleton] at h'
exactI subsingleton.elim _ _
apply h
rw [← not_le, succ_le, not_lt]
refine quot.induction_on c (λ α, _) (lt_succ_self c)
refine quot.induction_on (succ (quot.mk setoid.r α)) (λ β h, _)
cases h.left with f
have : ¬ surjective f := λ hn, ne_of_lt h (quotient.sound ⟨equiv.of_bijective f ⟨f.injective, hn⟩⟩)
cases not_forall.1 this with b nex
exact f
refine ⟨⟨sum.rec (by exact f) _, _⟩⟩
{ exact λ _, b }
exact λ _, b
rcases a with a|⟨⟨⟨⟩⟩⟩
rcases a with a|⟨⟨⟨⟩⟩⟩; rcases b with b|⟨⟨⟨⟩⟩⟩
rcases b with b|⟨⟨⟨⟩⟩⟩
rcases b with b|⟨⟨⟨⟩⟩⟩
intros a b h
{ rw f.injective h }
rw f.injective h
{ exact nex.elim ⟨_, h⟩ }
exact nex.elim ⟨_, h⟩
{ exact nex.elim ⟨_, h.symm⟩ }
exact nex.elim ⟨_, h.symm⟩
refl
dsimp [sup]; cases min_eq _ _ with c hc; rw hc; exact c.2 i
dsimp [sup]; cases min_eq _ _ with c hc; rw hc
dsimp [sup]; cases min_eq _ _ with c hc
cases min_eq _ _ with c hc
rw hc
dsimp [sup]
exact c.2 i
have := H i; rwa [← mk_out (f i), ← mk_out (g i)] at this
rwa [← mk_out (f i), ← mk_out (g i)] at this
have := H i
simpa using prod_ne_zero f
simp
have h : 0 < ω := nat_lt_omega 0
rw [dif_pos h, ← cardinal.nat_cast_inj, ← classical.some_spec (lt_omega.1 h), nat.cast_zero]
split
rw [max_le_iff]
intro h
cases (le_or_lt omega a) with ha ha
rintro rfl
exact not_lt_of_le ha omega_pos
{ rintro rfl, exact not_lt_of_le ha omega_pos }
have : a ≠ 0
use ha
left
intro hb
apply ne_of_gt _ h
refine lt_of_lt_of_le hb (le_mul_left this)
{ rw [← not_lt], intro hb, apply ne_of_gt _ h, refine lt_of_lt_of_le hb (le_mul_left this) }
rw [← not_lt]
apply this
rw [_root_.mul_zero] at h
subst h
{ have : a ≠ 0, { rintro rfl, exact not_lt_of_le ha omega_pos }, left, use ha, { rw [← not_lt], intro hb, apply ne_of_gt _ h, refine lt_of_lt_of_le hb (le_mul_left this) }, { rintro rfl, apply this, rw [_root_.mul_zero] at h, subst h }}
rintro rfl
by_cases h2a : a = 0
right
exact h2a
{ right, exact h2a }
right
rintro rfl
apply h2a
rw [mul_zero] at h
have hb : b ≠ 0
subst h
{ rintro rfl, apply h2a, rw [mul_zero] at h, subst h }
rw [← h, mul_lt_omega_iff, lt_omega, lt_omega] at ha
left
contradiction
rcases ha with rfl|rfl|⟨⟨n, rfl⟩, ⟨m, rfl⟩⟩
contradiction
rw [← one_le_iff_ne_zero] at h2a hb
rw [← ne] at h2a
norm_cast at h2a hb h ⊢
rw [← not_lt]
intro h2b
apply le_antisymm _ hb
conv_lhs { rw [← mul_one n] }
rw [← mul_one n]
apply ne_of_gt _ h
apply nat.lt_of_succ_le h2a
{ intro h, cases (le_or_lt omega a) with ha ha, { have : a ≠ 0, { rintro rfl, exact not_lt_of_le ha omega_pos }, left, use ha, { rw [← not_lt], intro hb, apply ne_of_gt _ h, refine lt_of_lt_of_le hb (le_mul_left this) }, { rintro rfl, apply this, rw [_root_.mul_zero] at h, subst h }}, right, by_cases h2a : a = 0, { right, exact h2a }, have hb : b ≠ 0, { rintro rfl, apply h2a, rw [mul_zero] at h, subst h }, left, rw [← h, mul_lt_omega_iff, lt_omega, lt_omega] at ha, rcases ha with rfl|rfl|⟨⟨n, rfl⟩, ⟨m, rfl⟩⟩, contradiction, contradiction, rw [← ne] at h2a, rw [← one_le_iff_ne_zero] at h2a hb, norm_cast at h2a hb h ⊢, apply le_antisymm _ hb, rw [← not_lt], intro h2b, apply ne_of_gt _ h, conv_lhs { rw [← mul_one n] }, rwa [mul_lt_mul_left], apply nat.lt_of_succ_le h2a }
rwa [mul_lt_mul_left]
rintro (⟨⟨ha, hab⟩, hb⟩|rfl|rfl)
{ rw [mul_eq_max_of_omega_le_left ha hb, max_eq_left hab] }
rw [mul_eq_max_of_omega_le_left ha hb, max_eq_left hab]
simp
simp
all_goals {simp}
simpa only [nat.cast_bit0, nat.cast_one, mul_eq_self h, two_mul] using mul_le_mul_right' ((nat_lt_omega 2).le.trans h) c
rw [nat.cast_zero, power_zero]
rw [nat.cast_zero, power_zero]; from one_lt_omega
from one_lt_omega
rw [nat.cast_succ, power_add, power_one]
rw [nat.cast_succ, power_add, power_one]; exact mul_le_mul_right' ih _
exact mul_le_mul_right' ih _
simp [bit0, add_lt_omega_iff]
cases y
refl
cases x
fsplit; rintro (⟨⟨⟩,_⟩ | ⟨⟨⟩,_⟩)
rintro (⟨⟨⟩,_⟩ | ⟨⟨⟩,_⟩)
rintro (⟨⟨⟩,_⟩ | ⟨⟨⟩,_⟩)
rintro (⟨⟨⟩,_⟩ | ⟨⟨⟩,_⟩)
rintro (⟨⟨⟩,_⟩ | ⟨⟨⟩,_⟩)
fsplit
fsplit; rintro (⟨⟨⟩,_⟩ | ⟨⟨⟩,_⟩)
rintro (⟨⟨⟩,_⟩ | ⟨⟨⟩,_⟩)
rintro (⟨⟨⟩,_⟩ | ⟨⟨⟩,_⟩)
rintro (⟨⟨⟩,_⟩ | ⟨⟨⟩,_⟩)
rintro (⟨⟨⟩,_⟩ | ⟨⟨⟩,_⟩)
fsplit
rintro (⟨⟨⟩,_⟩ | ⟨⟨⟩,_⟩)
rintro ⟨⟩
split
intro hi
unfold1 impartial_aux at hi
{ intro hi, unfold1 impartial_aux at hi, exact hi }
exact hi
intro hi
unfold1 impartial_aux
dsimp
simp
rw impartial_def
apply L
casesI S with _ _ _ _ L _ _ _
apply fintype.of_equiv _ (left_moves_of_aux _ _).symm
apply_instance
have i := (left_moves_of_aux _ _).to_fun i
exfalso
exact turn_bound_ne_zero_of_left_move i.2 (nonpos_iff_eq_zero.mp h)
have j := (right_moves_of_aux _ _).to_fun j
exfalso
exact turn_bound_ne_zero_of_right_move j.2 (nonpos_iff_eq_zero.mp h)
rw ← of_to_list l₁
induction to_list l₁
induction to_list l₁; intro
intro
intro
revert H
{ exact subset.nil }
exact subset.nil
exact cons_subset.2 ⟨H.1, ih H.2⟩
simp at H
exact omin_mem _ hs
rw Inf_eq_omin hs
rw subsingleton.elim f (principal_seg.equiv_lt e g)
rw subsingleton.elim f (principal_seg.equiv_lt e g); refl
refl
induction n with n IH; [simp only [nat.cast_zero, nat.mul_zero, mul_zero], rw [nat.mul_succ, nat.cast_add, IH, nat.cast_succ, mul_add_one]]
simp only [nat.cast_zero, nat.mul_zero, mul_zero]
induction n with n IH
rw [nat.mul_succ, nat.cast_add, IH, nat.cast_succ, mul_add_one]
simp only [mul_add, mul_one]
rw [sup_le, comp, H.le_set' (λ_:ι, true) g (let ⟨i⟩ := h in ⟨i, ⟨⟩⟩)]
rw [sup_le, comp, H.le_set' (λ_:ι, true) g (let ⟨i⟩ := h in ⟨i, ⟨⟩⟩)]; intros; simp only [sup_le, true_implies_iff]
rw [sup_le, comp, H.le_set' (λ_:ι, true) g (let ⟨i⟩ := h in ⟨i, ⟨⟩⟩)]; intros
simp only [sup_le, true_implies_iff]
simp only [sup_le, true_implies_iff]
intros
intros
induction h with _ e n a eb b h₁ h₂ h₃ _ IH
{ exact power_pos _ omega_pos }
exact power_pos _ omega_pos
rw repr
refine lt_of_lt_of_le ((ordinal.add_lt_add_iff_left _).2 IH) _
rw ← mul_succ
refine le_trans (mul_le_mul_left _ $ ordinal.succ_le.2 $ nat_lt_omega _) _
rw ← power_succ
exact power_le_power_right omega_pos (ordinal.succ_le.2 h₃)
cases k
cases k; exact NF.zero
exact NF.zero
exact NF.zero
haveI := NF_power_aux k
haveI := NF_power_aux k; simp [power_aux, nat.succ_ne_zero]; apply_instance
haveI := NF_power_aux k; simp [power_aux, nat.succ_ne_zero]
apply_instance
simp [power_aux, nat.succ_ne_zero]
cases m
cases m; simp [power_aux]
simp [power_aux]
simp [power_aux]
by_cases m = 0
by_cases m = 0; simp [h, power_aux, ordinal.mul_add, power_add, mul_assoc, scale_power_aux]
simp [h, power_aux, ordinal.mul_add, power_add, mul_assoc, scale_power_aux]
simp [h, power_aux, ordinal.mul_add, power_add, mul_assoc, scale_power_aux]
rw mk_le_mk
rw mk_le_mk; exact ⟨λ i, lt_mk_of_le (le_refl _), λ i, mk_lt_of_le (le_refl _)⟩
exact ⟨λ i, lt_mk_of_le (le_refl _), λ i, mk_lt_of_le (le_refl _)⟩
cases x with xl xr xL xR
exact o.2.2 j
intros z h₀ h₁
simp only [and_imp, set.mem_Icc]
replace h₀ := bitvec.of_fin_le_of_fin_of_le h₀
replace h₁ := bitvec.of_fin_le_of_fin_of_le h₁
split
rw bitvec.of_fin_to_fin at h₀ h₁
split; assumption
assumption
assumption
simp [prl, prr, prt]
cases x
cases y
refl
cases x
cases y
simp *
rw normalize_fin
norm_num
simpa [normalize_fin_lt, ← e] using h
rw [← h₁, int.dvd_iff_mod_eq_zero]
rwa [← h₁, ← mul_assoc, div_mul_cancel _ h₀]
rw [prl, prr, prt]
unfold val
apply fun_mono_2
apply fun_mono_2; apply val_between_eq_of_le; rw [zero_add, length_add]
apply fun_mono_2; apply val_between_eq_of_le
rw val_between_add
apply val_between_eq_of_le
apply val_between_eq_of_le
rw [zero_add, length_add]
rw [zero_add, length_add]
apply le_max_right
apply le_max_left
apply h1
rw (nat.sub_eq_zero_iff_le.elim_right _)
cases h1
rw le_iff_eq_or_lt at h1
{ rw [h1, add_comm l, nat.add_sub_cancel] }
rw [h1, add_comm l, nat.add_sub_cancel]
have h2 : list.length as ≤ l + m
apply h1
{ rw ← nat.lt_succ_iff, apply h1 }
rw ← nat.lt_succ_iff
simpa [ get_eq_default_of_le _ h2, zero_mul, add_zero, val_between ] using val_between_eq_of_le _ h2
intro h1
unfold symmod
rw [int.mod_eq_of_lt (le_of_lt h1) (lt_add_one _), if_neg]
simp only [add_comm, add_neg_cancel_left, neg_add_rev, sub_eq_add_neg]
have h2 : 2 * i = (1 + 1) * i := rfl
simpa only [h2, add_mul, one_mul, add_lt_add_iff_left, not_lt] using h1
haveI := has_reflect; exact list.reflect l
exact list.reflect l
haveI := has_reflect
haveI := has_reflect; exact list.reflect l
exact list.reflect l
haveI := has_reflect
rw [← H, ← h₂, ← h₁, ← h₃, ← h₄]; simp [horner, mul_add, mul_comm, mul_left_comm, mul_assoc]
rw [← H, ← h₂, ← h₁, ← h₃, ← h₄]
simp [horner, mul_add, mul_comm, mul_left_comm, mul_assoc]
simp [horner, mul_comm]
rw [ps_pf, qs_pf]
rw [pps_pf]
rw [psqs_pf]
induction xs
{ apply h }
apply h
unfold_wf
simp only [list.sizeof, add_lt_add_iff_left]
exact xs_ih
linarith
rcases hs with ⟨S, Sopen, Scount, rfl⟩
rcases ht with ⟨T, Topen, Tcount, rfl⟩
rw [sInter_union_sInter]
apply is_Gδ_bInter_of_open (Scount.prod Tcount)
rintros ⟨a, b⟩ hab
exact is_open.union (Sopen a hab.1) (Topen b hab.2)
rw [dense_range, ← compl_infty]
exact dense_compl_singleton _
rw [continuous_at, nhds_eq, nhds_eq, tendsto_map'_iff]
suffices : tendsto ((λx:G, x - a) ∘ (λx:G, -x)) (Z G) (map (λx:G, x - a) (Z G))
{ simpa [(∘), add_comm, sub_eq_add_neg] using this }
simpa [(∘), add_comm, sub_eq_add_neg] using this
exact tendsto_map.comp neg_Z
simpa [(hf'.has_sum.sigma hf).unique ha] using hf'.has_sum
by_cases hP : P; simp [hP]
simp [hP]
simp [hP]
by_cases hP : P
convert hf.update b 0 using 1
rw function.update_apply
{ ext n, rw function.update_apply, }
ext n
rw [sub_add_eq_add_sub, zero_add]
rw [←has_sum_zero_iff, hf.has_sum_iff]
simp
ext
exact forall_swap
simp only [ext_iff, pi_apply, function.funext_iff]
exact one_smul _ _
norm_num
norm_num
have := @tfae_mem_nhds_within_Ici (order_dual α) _ _ _ _ _ h s
simp only [exists_prop] at this ⊢
rw [dual_Icc, dual_Ioc, dual_Ioi] at this
convert this; ext l; rw [dual_Ico]
convert this; ext l
ext l
ext l
ext l
rw [dual_Ico]
rw [dual_Ico]
rw [dual_Ico]
convert this
refine tendsto_at_top_mono' _ _ (hf.at_top_mul_const (half_pos hC))
filter_upwards [hg.eventually (lt_mem_nhds (half_lt_self hC)), hf.eventually (eventually_ge_at_top 0)]
exact λ x hg hf, mul_le_mul_of_nonneg_left hg.le hf
simpa only [mul_comm] using hg.at_bot_mul hC hf
refine ⟨λ h, _, λ h, _⟩
by_cases hn : 0 ≤ n
lift n to ℕ using hn
simp only [gpow_coe_nat] at h
rw [tendsto_const_mul_pow_nhds_iff hc, ← int.coe_nat_eq_zero] at h
{ lift n to ℕ using hn, simp only [gpow_coe_nat] at h, rw [tendsto_const_mul_pow_nhds_iff hc, ← int.coe_nat_eq_zero] at h, exact or.inl h }
exact or.inl h
rw not_le at hn
refine or.inr ⟨hn, tendsto_nhds_unique h (tendsto_const_mul_fpow_at_top_zero hn)⟩
{ by_cases hn : 0 ≤ n, { lift n to ℕ using hn, simp only [gpow_coe_nat] at h, rw [tendsto_const_mul_pow_nhds_iff hc, ← int.coe_nat_eq_zero] at h, exact or.inl h }, { rw not_le at hn, refine or.inr ⟨hn, tendsto_nhds_unique h (tendsto_const_mul_fpow_at_top_zero hn)⟩ } }
cases h
simp only [h.left, h.right, gpow_zero, mul_one]
{ simp only [h.left, h.right, gpow_zero, mul_one], exact tendsto_const_nhds }
exact tendsto_const_nhds
exact h.2.symm ▸ tendsto_const_mul_fpow_at_top_zero h.1
simp [frontier, h, le_of_lt h, Icc_diff_Ioo_same]
simp [frontier, h, le_of_lt h, Icc_diff_Ioo_same]
rw [← map_coe_Iio_at_top, tendsto_map'_iff]
apply extend_from_eq
rw closure_Ioo hab
{ rw closure_Ioo hab, simp only [le_of_lt hab, left_mem_Icc, right_mem_Icc] }
simp only [le_of_lt hab, left_mem_Icc, right_mem_Icc]
simpa [hab]
exact hf.open_subset_closure_inter hs
rw image_preimage_eq_inter_range
exact is_open_empty
rw [← is_open_compl_iff, compl_univ]
rw subset.antisymm subset_closure h; exact is_closed_closure
exact is_closed_closure
rw subset.antisymm subset_closure h
rwa compl_compl
rw [frontier, hs.interior_eq]
simp only [le_principal_iff]
simp [closure_eq_cluster_pts, cluster_pt, ← exists_ultrafilter_iff, and.comm]
continuity
rw [nhds_within, principal_singleton, inf_eq_right.2 (pure_le_nhds a)]
rw [continuous_within_at, function.update_same]
rw [mem_set_of_eq, function.update_noteq hz.2]
rw [di.nhds_eq_comap a, ((nhds_basis_opens _).comap _).mem_iff] at hs
rcases hs with ⟨U, ⟨haU, hUo⟩, sub : i ⁻¹' U ⊆ s⟩
refine mem_of_superset (hUo.mem_nhds haU) _
calc U ⊆ closure (i '' (i ⁻¹' U)) : di.dense.subset_closure_image_preimage_of_is_open hUo ... ⊆ closure (i '' s) : closure_mono (image_subset i sub)
have cond : is_compact (⊤ : set X) := compact_univ
rw is_compact_iff_finite_subcover at cond
have h := @cond S (λ s, S.proj ⁻¹' {s}) (λ s, fiber_open _ _) (λ x hx, ⟨S.proj ⁻¹' {S.proj x}, ⟨S.proj x, rfl⟩, rfl⟩)
let T := classical.some h
have hT := classical.some_spec h
refine ⟨T,λ s, _⟩
rcases S.proj_surjective s with ⟨x,rfl⟩
tauto
rcases hT (by tauto : x ∈ ⊤) with ⟨j, ⟨j,rfl⟩, h1, ⟨hj, rfl⟩, h2⟩
dsimp only at h2
rwa this
suffices : S.proj x = j
rcases j with ⟨j⟩
apply quotient.sound'
erw fiber_eq at h2
exact S.symm _ _ h2
ext
refl
letI := a.total_space_topology
refine continuous_on_iff'.mpr (λ s hs, ⟨(a.pretrivialization_at x) ⁻¹' s ∩ (a.pretrivialization_at x).source, (is_open_supr_iff.mpr (λ y, _)), by { rw [inter_assoc, inter_self], refl }⟩)
rw [inter_assoc, inter_self]
refl
rw [is_open_coinduced, is_open_induced_iff]
obtain ⟨u, hu1, hu2⟩ := continuous_on_iff'.mp (a.continuous_triv_change x y) s hs
have hu3 := congr_arg (λ s, (λ x : (a.pretrivialization_at y).target, (x : B × F)) ⁻¹' s) hu2
simp only [subtype.coe_preimage_self, preimage_inter, univ_inter] at hu3
refine ⟨u ∩ (a.pretrivialization_at y).to_local_equiv.target ∩ ((a.pretrivialization_at y).to_local_equiv.symm ⁻¹' (a.pretrivialization_at x).source), _, by { simp only [preimage_inter, inter_univ, subtype.coe_preimage_self, hu3.symm], refl }⟩
refl
simp only [preimage_inter, inter_univ, subtype.coe_preimage_self, hu3.symm]
rw inter_assoc
exact hu1.inter (a.is_open_target_pretrivialization_at_inter x y)
lift f to β → ℝ≥0 using λ b, (hg b).trans (hgf b)
lift g to β → ℝ≥0 using hg
rw nnreal.summable_coe at hf ⊢
exact nnreal.summable_of_le (λ b, nnreal.coe_le_coe.1 (hgf b)) hf
simp only [continuous_at, tendsto_nhds_top_iff_real, top_add, nhds_prod_eq]
assume r
rw eventually_prod_iff
refine ⟨λ z, (r : ereal) < z, Ioi_mem_nhds (coe_lt_top _), λ z, ((0 : ℝ) : ereal) < z, Ioi_mem_nhds (by simp [zero_lt_one]), λ x hx y hy, _⟩
simp [zero_lt_one]
dsimp
convert add_lt_add hx hy
simp
lift f to α → ℝ≥0 using hf₁ with f rfl hf₁
simp only [summable_coe, subtype.coe_eta]
simp only [coe_tsum, nnreal.coe_mul, tsum_mul_left]
have := totally_bounded_preimage uniform_embedding_of_rat (totally_bounded_Icc a b)
rwa (set.ext (λ q, _) : Icc _ _ = _)
simp
refine (real.image_interval_eq_Icc h).trans (interval_of_le _).symm
rw [real.image_interval_eq_Icc h]
exact real.Inf_le_Sup _ bdd_below_Icc bdd_above_Icc
subst f
refl
rw [comap, dif_pos hf]
ext x
ext x; simp [mem_image_iff_of_inverse r_inv l_inv]
simp [mem_image_iff_of_inverse r_inv l_inv]
convert ← h.preimage hf.to_embedding.continuous
apply preimage_image_eq _ hf.inj
convert ←hf.closed_iff_image_closed.symm
rwa [image_preimage_eq_inter_range, inter_eq_self_of_subset_left]
rw [diam, ediam_of_unbounded h, ennreal.top_to_real]
cases max_le_iff.1 (le_of_eq h) with h₁ h₂
exact prod.ext_iff.2 ⟨dist_le_zero.1 h₁, dist_le_zero.1 h₂⟩
rw [← not_nonempty_iff_eq_empty, nonempty_ball, not_lt]
simp
convert metric.emetric_ball
refine complete_of_convergent_controlled_sequences B B_pos (λs hs, _)
let t0 := ⋂n, closure (⋃m≥n, (s m).val)
let t : closeds α := ⟨t0, is_closed_Inter (λ_, is_closed_closure)⟩
use t
have I1 : ∀n:ℕ, ∀x ∈ (s n).val, ∃y ∈ t0, edist x y ≤ 2 * B n
assume n x hx
obtain ⟨z, hz₀, hz⟩ : ∃ z : Π l, (s (n+l)).val, (z 0:α) = x ∧ ∀ k, edist (z k:α) (z (k+1):α) ≤ B n / 2^k
have : ∀ (l : ℕ) (z : (s (n+l)).val), ∃ z' : (s (n+l+1)).val, edist (z:α) z' ≤ B n / 2^l
assume l z
obtain ⟨z', z'_mem, hz'⟩ : ∃ z' ∈ (s (n+l+1)).val, edist (z:α) z' < B n / 2^l
apply exists_edist_lt_of_Hausdorff_edist_lt z.2
simp only [B, ennreal.inv_pow, div_eq_mul_inv]
rw [← pow_add]
apply hs
apply hs; simp
simp
simp
{ apply exists_edist_lt_of_Hausdorff_edist_lt z.2, simp only [B, ennreal.inv_pow, div_eq_mul_inv], rw [← pow_add], apply hs; simp }
{ assume l z, obtain ⟨z', z'_mem, hz'⟩ : ∃ z' ∈ (s (n+l+1)).val, edist (z:α) z' < B n / 2^l, { apply exists_edist_lt_of_Hausdorff_edist_lt z.2, simp only [B, ennreal.inv_pow, div_eq_mul_inv], rw [← pow_add], apply hs; simp }, exact ⟨⟨z', z'_mem⟩, le_of_lt hz'⟩ }
exact ⟨⟨z', z'_mem⟩, le_of_lt hz'⟩
use [λ k, nat.rec_on k ⟨x, hx⟩ (λl z, some (this l z)), rfl]
{ have : ∀ (l : ℕ) (z : (s (n+l)).val), ∃ z' : (s (n+l+1)).val, edist (z:α) z' ≤ B n / 2^l, { assume l z, obtain ⟨z', z'_mem, hz'⟩ : ∃ z' ∈ (s (n+l+1)).val, edist (z:α) z' < B n / 2^l, { apply exists_edist_lt_of_Hausdorff_edist_lt z.2, simp only [B, ennreal.inv_pow, div_eq_mul_inv], rw [← pow_add], apply hs; simp }, exact ⟨⟨z', z'_mem⟩, le_of_lt hz'⟩ }, use [λ k, nat.rec_on k ⟨x, hx⟩ (λl z, some (this l z)), rfl], exact λ k, some_spec (this k _) }
exact λ k, some_spec (this k _)
have : cauchy_seq (λ k, ((z k):α))
from cauchy_seq_of_edist_le_geometric_two (B n) (B_ne_top n) hz
rcases cauchy_seq_tendsto_of_complete this with ⟨y, y_lim⟩
use y
have : y ∈ t0 := mem_Inter.2 (λk, mem_closure_of_tendsto y_lim begin simp only [exists_prop, set.mem_Union, filter.eventually_at_top, set.mem_preimage, set.preimage_Union], exact ⟨k, λ m hm, ⟨n+m, zero_add k ▸ add_le_add (zero_le n) hm, (z m).2⟩⟩ end)
simp only [exists_prop, set.mem_Union, filter.eventually_at_top, set.mem_preimage, set.preimage_Union]
exact ⟨k, λ m hm, ⟨n+m, zero_add k ▸ add_le_add (zero_le n) hm, (z m).2⟩⟩
use this
rw [← hz₀]
exact edist_le_of_edist_le_geometric_two_of_tendsto₀ (B n) hz y_lim
{ assume n x hx, obtain ⟨z, hz₀, hz⟩ : ∃ z : Π l, (s (n+l)).val, (z 0:α) = x ∧ ∀ k, edist (z k:α) (z (k+1):α) ≤ B n / 2^k, { have : ∀ (l : ℕ) (z : (s (n+l)).val), ∃ z' : (s (n+l+1)).val, edist (z:α) z' ≤ B n / 2^l, { assume l z, obtain ⟨z', z'_mem, hz'⟩ : ∃ z' ∈ (s (n+l+1)).val, edist (z:α) z' < B n / 2^l, { apply exists_edist_lt_of_Hausdorff_edist_lt z.2, simp only [B, ennreal.inv_pow, div_eq_mul_inv], rw [← pow_add], apply hs; simp }, exact ⟨⟨z', z'_mem⟩, le_of_lt hz'⟩ }, use [λ k, nat.rec_on k ⟨x, hx⟩ (λl z, some (this l z)), rfl], exact λ k, some_spec (this k _) }, have : cauchy_seq (λ k, ((z k):α)), from cauchy_seq_of_edist_le_geometric_two (B n) (B_ne_top n) hz, rcases cauchy_seq_tendsto_of_complete this with ⟨y, y_lim⟩, use y, have : y ∈ t0 := mem_Inter.2 (λk, mem_closure_of_tendsto y_lim begin simp only [exists_prop, set.mem_Union, filter.eventually_at_top, set.mem_preimage, set.preimage_Union], exact ⟨k, λ m hm, ⟨n+m, zero_add k ▸ add_le_add (zero_le n) hm, (z m).2⟩⟩ end), use this, rw [← hz₀], exact edist_le_of_edist_le_geometric_two_of_tendsto₀ (B n) hz y_lim }
have I2 : ∀n:ℕ, ∀x ∈ t0, ∃y ∈ (s n).val, edist x y ≤ 2 * B n
assume n x xt0
apply mem_Inter.1 xt0 n
have : x ∈ closure (⋃m≥n, (s m).val)
rcases mem_closure_iff.1 this (B n) (B_pos n) with ⟨z, hz, Dxz⟩
simp only [exists_prop, set.mem_Union] at hz
rcases hz with ⟨m, ⟨m_ge_n, hm⟩⟩
have : Hausdorff_edist (s m).val (s n).val < B n := hs n m n m_ge_n (le_refl n)
rcases exists_edist_lt_of_Hausdorff_edist_lt hm this with ⟨y, hy, Dzy⟩
exact ⟨y, hy, calc edist x y ≤ edist x z + edist z y : edist_triangle _ _ _ ... ≤ B n + B n : add_le_add (le_of_lt Dxz) (le_of_lt Dzy) ... = 2 * B n : (two_mul _).symm ⟩
{ assume n x xt0, have : x ∈ closure (⋃m≥n, (s m).val), by apply mem_Inter.1 xt0 n, rcases mem_closure_iff.1 this (B n) (B_pos n) with ⟨z, hz, Dxz⟩, simp only [exists_prop, set.mem_Union] at hz, rcases hz with ⟨m, ⟨m_ge_n, hm⟩⟩, have : Hausdorff_edist (s m).val (s n).val < B n := hs n m n m_ge_n (le_refl n), rcases exists_edist_lt_of_Hausdorff_edist_lt hm this with ⟨y, hy, Dzy⟩, exact ⟨y, hy, calc edist x y ≤ edist x z + edist z y : edist_triangle _ _ _ ... ≤ B n + B n : add_le_add (le_of_lt Dxz) (le_of_lt Dzy) ... = 2 * B n : (two_mul _).symm ⟩ }
have main : ∀n:ℕ, edist (s n) t ≤ 2 * B n := λn, Hausdorff_edist_le_of_mem_edist (I1 n) (I2 n)
refine tendsto_at_top.2 (λε εpos, _)
have : tendsto (λn, 2 * B n) at_top (𝓝 (2 * 0))
from ennreal.tendsto.const_mul (ennreal.tendsto_pow_at_top_nhds_0_of_lt_1 $ by simp [ennreal.one_lt_two]) (or.inr $ by simp)
simp [ennreal.one_lt_two]
simp
rw mul_zero at this
obtain ⟨N, hN⟩ : ∃ N, ∀ b ≥ N, ε > 2 * B b
from ((tendsto_order.1 this).2 ε εpos).exists_forall_of_at_top
exact ⟨N, λn hn, lt_of_le_of_lt (main n) (hN n hn)⟩
let B : ℕ → ℝ≥0∞ := λ n, (2⁻¹)^n
have B_pos : ∀ n, (0:ℝ≥0∞) < B n
simp [B, ennreal.pow_pos]
have B_ne_top : ∀ n, B n ≠ ⊤
simp [B, ennreal.pow_ne_top]
refine or_iff_not_imp_right.2 (λ h, edist_le_zero.1 _)
simpa only [hx.eq, edist_self, add_zero, ennreal.zero_div] using hf.edist_le_of_fixed_point h hy
refine ⟨λ H ε hε, H _ (edist_mem_uniformity hε), λ H u hu x hx, _⟩
rcases mem_uniformity_edist.1 hu with ⟨ε, εpos, hε⟩
rcases H ε εpos x hx with ⟨t, ht, Ht⟩
exact ⟨t, ht, Ht.mono (λ n hs x hx, hε (hs x hx))⟩
exactI second_countable_of_separable α
suffices : separable_space α
rcases subset_countable_closure_of_almost_dense_set (univ : set α) (λ ε ε0, _) with ⟨t, -, htc, ht⟩
{ exact ⟨⟨t, htc, λ x, ht (mem_univ x)⟩⟩ }
exact ⟨⟨t, htc, λ x, ht (mem_univ x)⟩⟩
rcases hs ε ε0 with ⟨t, htc, ht⟩
exact ⟨t, htc, univ_subset_iff.2 ht⟩
letI : pseudo_metric_space (X ⊕ Y) := glue_premetric hΦ hΨ
letI : pseudo_metric_space (X ⊕ Y) := glue_premetric hΦ hΨ; exact ⟦inr y⟧
exact ⟦inr y⟧
rw ← image_univ
refine dimH_image_le_of_locally_lipschitz_on (λ x _, _)
simpa only [exists_prop, nhds_within_univ] using hf x
rw [← e.dimH_preimage univ, preimage_univ]
simp only [Hausdorff_edist, sup_le_iff, supr_le_iff]
exact ⟨H1, H2⟩
have ht : t.nonempty := hs.mono h
rw [inf_dist, inf_dist, ennreal.to_real_le_to_real (inf_edist_ne_top ht) (inf_edist_ne_top hs)]
exact inf_edist_le_inf_edist_of_subset h
simp [inf_dist, inf_edist_image hΦ]
rcases empty_or_nonempty_of_Hausdorff_edist_ne_top fin with ⟨hs,ht⟩|⟨hs,ht⟩
simp only [hs, ht, Hausdorff_dist_empty, inf_dist_empty, zero_add]
{ simp only [hs, ht, Hausdorff_dist_empty, inf_dist_empty, zero_add] }
rw [inf_dist, inf_dist, Hausdorff_dist, ← ennreal.to_real_add (inf_edist_ne_top hs) fin, ennreal.to_real_le_to_real (inf_edist_ne_top ht)]
{ exact inf_edist_le_inf_edist_add_Hausdorff_edist }
exact inf_edist_le_inf_edist_add_Hausdorff_edist
exact ennreal.add_ne_top.2 ⟨inf_edist_ne_top hs, fin⟩
intros x hx y hy
rw [ennreal.coe_mul, mul_comm rg, nnreal.coe_mul, ennreal.rpow_mul, mul_assoc, ← ennreal.coe_rpow_of_nonneg _ rg.coe_nonneg, ← ennreal.mul_rpow_of_nonneg _ _ rg.coe_nonneg]
exact hg.edist_le_of_le (hst hx) (hst hy) (hf.edist_le hx hy)
rwa [set.image_univ, isometric.range_eq_univ, ← complete_space_iff_is_complete_univ]
rw subsingleton.elim x y
rw subsingleton.elim x y; simp
simp
simp only [edist_self, zero_le]
rw [← mul_assoc, ennreal.coe_mul]
assume x y
rw [ennreal.coe_mono.map_max, prod.edist_eq, ennreal.max_mul]
exact max_le_max (hf x y) (hg x y)
rcases ⟨h, h'⟩ with ⟨⟨r, r0, hr⟩, ⟨r', r0', hr'⟩⟩
refine ⟨min r r', _, λ x hx y hy, hx.elim _ _⟩
rw [← pos_iff_ne_zero] at r0 r0' ⊢
{ rw [← pos_iff_ne_zero] at r0 r0' ⊢, exact lt_min r0 r0' }
exact lt_min r0 r0'
{ exact λ hx, (min_le_left _ _).trans (hr _ hx _ hy) }
exact λ hx, (min_le_left _ _).trans (hr _ hx _ hy)
exact λ hx, (min_le_right _ _).trans (hr' _ hx _ hy)
simpa only [@comm _ _ s] using finite_Union_left_iff hI
rw induced_generate_from_eq
apply le_generate_from
simp only [mem_image, and_imp, forall_apply_eq_imp_iff₂, exists_imp_distrib]
exact h
simp only [mem_nhds_iff, is_open_induced_iff, exists_prop, set.mem_set_of_eq]
split
rintros ⟨u, usub, ⟨v, openv, ueq⟩, au⟩
rwa ←ueq at au
exact ⟨v, ⟨v, set.subset.refl v, openv, by rwa ←ueq at au⟩, by rw ueq; exact usub⟩
rw ueq
rw ueq; exact usub
exact usub
{ rintros ⟨u, usub, ⟨v, openv, ueq⟩, au⟩, exact ⟨v, ⟨v, set.subset.refl v, openv, by rwa ←ueq at au⟩, by rw ueq; exact usub⟩ }
rintros ⟨u, ⟨v, vsubu, openv, amem⟩, finvsub⟩
exact ⟨f ⁻¹' v, set.subset.trans (set.preimage_mono vsubu) finvsub, ⟨⟨v, openv, rfl⟩, amem⟩⟩
rw min_eq_left h
split
introI h
{ introI h, apply_instance }
apply_instance
introI hX
inhabit X
let x₀ := default X
rw path_connected_space_iff_eq
use x₀
simp
refine eq_univ_of_nonempty_clopen (by simp) ⟨_, _⟩
rw is_open_iff_mem_nhds
intros y y_in
rcases (path_connected_basis y).ex_mem with ⟨U, ⟨U_in, hU⟩⟩
apply mem_of_superset U_in
rw ← path_component_congr y_in
{ rw is_open_iff_mem_nhds, intros y y_in, rcases (path_connected_basis y).ex_mem with ⟨U, ⟨U_in, hU⟩⟩, apply mem_of_superset U_in, rw ← path_component_congr y_in, exact hU.subset_path_component (mem_of_mem_nhds U_in) }
exact hU.subset_path_component (mem_of_mem_nhds U_in)
rw is_closed_iff_nhds
intros y H
rcases (path_connected_basis y).ex_mem with ⟨U, ⟨U_in, hU⟩⟩
rcases H U U_in with ⟨z, hz, hz'⟩
exact ((hU.joined_in z y hz $ mem_of_mem_nhds U_in).joined.mem_path_component hz')
simp only [← lower_semicontinuous_within_at_univ_iff] at hf ⊢
exact hg.comp_lower_semicontinuous_within_at hf gmon
simp [upper_semicontinuous_on, upper_semicontinuous, upper_semicontinuous_within_at_univ_iff]
rwa [mem_compl_eq, mem_singleton_iff]
rw is_open_iff_ultrafilter
refine ⟨λ h F hF, h F.Lim hF F F.le_nhds_Lim, _⟩
intros cond x hx f h
rw [← (ultrafilter.Lim_eq_iff_le_nhds.2 h)] at hx
exact cond _ hx
apply equiv_of_subsingleton_of_subsingleton
intros S ι U
have t₁ := S U
have t₂ := @preserves_limit.preserves _ _ _ _ _ _ _ G _ _ t₁
have t₃ := is_limit.of_iso_limit t₂ (map_cone_fork G F U)
have t₄ := is_limit.postcompose_inv_equiv _ _ t₃
{ intros S ι U, have t₁ := S U, have t₂ := @preserves_limit.preserves _ _ _ _ _ _ _ G _ _ t₁, have t₃ := is_limit.of_iso_limit t₂ (map_cone_fork G F U), have t₄ := is_limit.postcompose_inv_equiv _ _ t₃, exact t₄, }
exact t₄
intros S ι U
let f := equalizer.lift _ (w F U)
suffices : is_iso (G.map f)
resetI
haveI : is_iso f := is_iso_of_reflects_iso f G
apply is_limit.of_iso_limit (limit.is_limit _)
apply iso.symm
fapply cones.ext
exact (as_iso f)
rintro ⟨_|_⟩; { dsimp [f], simp, }
dsimp [f]
simp
{ resetI, haveI : is_iso f := is_iso_of_reflects_iso f G, apply is_limit.of_iso_limit (limit.is_limit _), apply iso.symm, fapply cones.ext, exact (as_iso f), rintro ⟨_|_⟩; { dsimp [f], simp, }, }
rintro ⟨_|_⟩
let c := fork (F ⋙ G) U
have hc : is_limit c := S U
let d := G.map_cone (equalizer.fork (left_res F U) (right_res F U))
have hd : is_limit d := preserves_limit.preserves (limit.is_limit _)
let d' := (cones.postcompose (diagram_comp_preserves_limits G F U).hom).obj d
have hd' : is_limit d' := (is_limit.postcompose_hom_equiv (diagram_comp_preserves_limits G F U) d).symm hd
let f' : c ⟶ d' := fork.mk_hom (G.map f) begin dsimp only [c, d, d', f, diagram_comp_preserves_limits, res], dunfold fork.ι, ext1 j, dsimp, simp only [category.assoc, ←functor.map_comp_assoc, equalizer.lift_ι, map_lift_pi_comparison_assoc], dsimp [res], simp, end
dsimp only [c, d, d', f, diagram_comp_preserves_limits, res]
dunfold fork.ι
ext1 j
dsimp
simp only [category.assoc, ←functor.map_comp_assoc, equalizer.lift_ι, map_lift_pi_comparison_assoc]
simp
dsimp [res]
haveI : is_iso f' := is_limit.hom_is_iso hc hd' f'
exact is_iso.of_iso ((cones.forget _).map_iso (as_iso f'))
choose gl gl_spec gl_uniq using h U sf hsf
exact ⟨gl, gl_spec⟩
intro s
let t : F.gluing U sf := _
change s = t
ext
choose gl gl_spec gl_uniq using h U sf hsf
refine eq.trans (gl_uniq s.1 _) (gl_uniq t.1 _).symm
exacts [s.2, t.2]
wlog hle : v₁ ≤ v₂ := hc.total_of_refl h₁ h₂ using [v₁ v₂, v₂ v₁]
exact hle.2 _ hi₁
rintros _ ⟨a, rfl⟩ _ ⟨b, rfl⟩ u ⟨ua, ub⟩
refine ⟨_, ⟨a ∩ b, rfl⟩, inter_mem ua ub, assume v hv, ⟨_, _⟩⟩
refine ⟨_, ⟨a ∩ b, rfl⟩, inter_mem ua ub, assume v hv, ⟨_, _⟩⟩; apply mem_of_superset hv; simp [inter_subset_right a b]
refine ⟨_, ⟨a ∩ b, rfl⟩, inter_mem ua ub, assume v hv, ⟨_, _⟩⟩; apply mem_of_superset hv
simp [inter_subset_right a b]
simp [inter_subset_right a b]
apply mem_of_superset hv
apply mem_of_superset hv
simpa only [subset_def, not_forall, eq_empty_iff_forall_not_mem, mem_Union, exists_prop, mem_inter_eq, not_and, iff_self, mem_Inter, mem_compl_eq] using hsZ
simpa only [subset_def, not_forall, eq_empty_iff_forall_not_mem, mem_Union, exists_prop, mem_inter_eq, not_and, iff_self, mem_Inter, mem_compl_eq] using ht
rw is_compact_iff_ultrafilter_le_nhds at ⊢ h
intros u us'
have : ↑(u.map f) ≤ 𝓟 (f '' s)
rw [ultrafilter.coe_map, map_le_iff_le_comap, comap_principal]
convert us'
exact preimage_image_eq _ hf.inj
begin rw [ultrafilter.coe_map, map_le_iff_le_comap, comap_principal], convert us', exact preimage_image_eq _ hf.inj end
rcases h (u.map f) this with ⟨_, ⟨a, ha, ⟨⟩⟩, _⟩
refine ⟨a, ha, _⟩
rwa [hf.induced, nhds_induced, ←map_le_iff_le_comap]
rw uniform_space.mem_nhds_iff
split
rintros ⟨V, V_in, V_sub⟩
use [symmetrize_rel V, symmetrize_mem_uniformity V_in, symmetric_symmetrize_rel V]
exact subset.trans (ball_mono (symmetrize_rel_subset_self V) x) V_sub
{ rintros ⟨V, V_in, V_sub⟩, use [symmetrize_rel V, symmetrize_mem_uniformity V_in, symmetric_symmetrize_rel V], exact subset.trans (ball_mono (symmetrize_rel_subset_self V) x) V_sub }
rintros ⟨V, V_in, V_symm, V_sub⟩
exact ⟨V, V_in, V_sub⟩
simp_rw [mem_closure_iff_nhds, uniform_space.mem_nhds_iff]
split
intros h V V_in
{ intros h V V_in, exact h (ball x V) ⟨V, V_in, subset.refl _⟩ }
exact h (ball x V) ⟨V, V_in, subset.refl _⟩
rintros h t ⟨V, V_in, Vt⟩
exact nonempty.mono (inter_subset_inter_left s Vt) (h V_in)
simp
simp; filter_upwards [hs] subset_closure
filter_upwards [hs] subset_closure
intros s hs
intros s hs; rw [closure_eq_inter_uniformity]; exact bInter_subset_of_mem hs
intros s hs; rw [closure_eq_inter_uniformity]
rw [closure_eq_inter_uniformity]
exact bInter_subset_of_mem hs
rcases comp_symm_of_uniformity hd with ⟨r, hr, rs, rd⟩
rcases H r hr with ⟨k, fk, ks⟩
let u := k ∩ {y | ∃ x ∈ s, (x, y) ∈ r}
choose hk f hfs hfr using λ x : u, x.coe_prop
refine ⟨range f, _, _, _⟩
{ exact range_subset_iff.2 hfs }
exact range_subset_iff.2 hfs
haveI : fintype u := (fk.inter_of_left _).fintype
{ haveI : fintype u := (fk.inter_of_left _).fintype, exact finite_range f }
exact finite_range f
intros x xs
from mem_bUnion_iff.1 (ks xs)
obtain ⟨y, hy, xy⟩ : ∃ y ∈ k, (x, y) ∈ r
rw [bUnion_range, mem_Union]
set z : ↥u := ⟨y, hy, ⟨x, xs, xy⟩⟩
exact ⟨z, rd $ mem_comp_rel.2 ⟨y, xy, rs (hfr z)⟩⟩
simp
simp [tendsto_uniformly_on, tendsto_uniformly]
simp [hs]
rw ← hf.comap_uniformity at ht
rcases mem_comap.2 ht with ⟨t', ht', ts⟩
rcases totally_bounded_iff_subset.1 (totally_bounded_subset (image_preimage_subset f s) hs) _ ht' with ⟨c, cs, hfc, hct⟩
refine ⟨f ⁻¹' c, hfc.preimage (hf.inj.inj_on _), λ x h, _⟩
simp at this ⊢
have := hct (mem_image_of_mem f h)
rcases this with ⟨z, zc, zt⟩
rcases cs zc with ⟨y, yc, rfl⟩
exact zt
exact ⟨y, zc, ts (by exact zt)⟩
simp only [uniform_embedding_def, uniform_continuous_def]
simp only [uniform_embedding_def, uniform_continuous_def]; exact ⟨λ ⟨I, H⟩, ⟨I, λ s su, (H _).2 ⟨s, su, λ x y, id⟩, λ s, (H s).1⟩, λ ⟨I, H₁, H₂⟩, ⟨I, λ s, ⟨H₂ s, λ ⟨t, tu, h⟩, mem_of_superset (H₁ t tu) (λ ⟨a, b⟩, h a b)⟩⟩⟩
exact ⟨λ ⟨I, H⟩, ⟨I, λ s su, (H _).2 ⟨s, su, λ x y, id⟩, λ s, (H s).1⟩, λ ⟨I, H₁, H₂⟩, ⟨I, λ s, ⟨H₂ s, λ ⟨t, tu, h⟩, mem_of_superset (H₁ t tu) (λ ⟨a, b⟩, h a b)⟩⟩⟩
apply mem_base_set_trivialization_at
rw topological_fiber_bundle.trivialization.mem_source
