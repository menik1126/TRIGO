cases b; unfold read read'; simp [array.read_eq_read']
cases b; unfold read read'
unfold read read'
simp [array.read_eq_read']
cases b
rw [‚Üê stream.eta (iterate f a)]
refl
rw tail_iterate
rw [h, nth_even]
reflexivity
cases v
min_tac b a
cases b; simp
simp
simp
cases b
cases b; simp
simp
simp
cases b
cases b; simp
simp
simp
cases b
simp
delta is_whitespace
apply_instance
intro c
delta is_digit
apply_instance
intro c
intro h; unfold of_nat; rw [dif_pos h]
intro h; unfold of_nat
unfold of_nat
rw [dif_pos h]
intro h
simp
simp
have h := nat.lt_or_ge n k
cases h with h h
have h' : succ m * n < succ m * k
exact nat.mul_lt_mul_of_pos_left h (nat.succ_pos m)
rw [sub_nat_nat_of_lt h, sub_nat_nat_of_le (le_of_lt h')]
simp [succ_pred_eq_of_pos (nat.sub_pos_of_lt h), nat.mul_sub_left_distrib]
{ have h' : succ m * n < succ m * k, exact nat.mul_lt_mul_of_pos_left h (nat.succ_pos m), rw [sub_nat_nat_of_lt h, sub_nat_nat_of_le (le_of_lt h')], simp [succ_pred_eq_of_pos (nat.sub_pos_of_lt h), nat.mul_sub_left_distrib]}
have h' : n > k ‚à® k = n
exact decidable.lt_or_eq_of_le h
cases h' with h' h'
have h‚ÇÅ : succ m * n > succ m * k
exact nat.mul_lt_mul_of_pos_left h' (nat.succ_pos m)
simp [nat.mul_sub_left_distrib, nat.mul_comm]
rw [sub_nat_nat_of_le h, sub_nat_nat_of_lt h‚ÇÅ]
rw [nat.mul_comm k, nat.mul_comm n, ‚Üê succ_pred_eq_of_pos (nat.sub_pos_of_lt h‚ÇÅ), ‚Üê neg_of_nat_of_succ]
{ have h‚ÇÅ : succ m * n > succ m * k, exact nat.mul_lt_mul_of_pos_left h' (nat.succ_pos m), rw [sub_nat_nat_of_le h, sub_nat_nat_of_lt h‚ÇÅ], simp [nat.mul_sub_left_distrib, nat.mul_comm], rw [nat.mul_comm k, nat.mul_comm n, ‚Üê succ_pred_eq_of_pos (nat.sub_pos_of_lt h‚ÇÅ), ‚Üê neg_of_nat_of_succ], reflexivity }
reflexivity
simp
reflexivity
subst h'
rwa [e1, e2]
have h := int.neg_lt_neg h
rwa int.neg_neg at h
have h := int.add_le_add_right h (-b)
rwa [int.add_comm b c, int.add_neg_cancel_right] at h
rw int.add_comm at h
exact int.le_add_of_sub_right_le h
have h := int.add_lt_add_right h b
rwa [int.sub_add_cancel, int.add_comm] at h
rwa int.zero_mul at h
simp [min_le_left]
induction n; simp [*]; refl
induction n; simp [*]
simp [*]
simp [*]
induction n
rw n0
rw n0; exact z
exact z
rw div2_val
change div2 n < n
apply (div_lt_iff_lt_mul _ _ (succ_pos 1)).2
have := nat.mul_lt_mul_of_pos_left (lt_succ_self 1) (lt_of_le_of_ne n.zero_le (ne.symm n0))
rwa nat.mul_one at this
rw [‚Üê show bit (bodd n) n' = n, from bit_decomp n]; exact f (bodd n) n' (binary_rec n')
exact f (bodd n) n' (binary_rec n')
rw [‚Üê show bit (bodd n) n' = n, from bit_decomp n]
unfold bitwise; apply bit_cases_on m; intros; rw [binary_rec_eq, binary_rec_zero]; exact bitwise_bit_aux h
unfold bitwise; apply bit_cases_on m; intros; rw [binary_rec_eq, binary_rec_zero]
unfold bitwise; apply bit_cases_on m; intros
unfold bitwise; apply bit_cases_on m
apply bit_cases_on m
intros
unfold bitwise
exact bitwise_bit_aux h
rw [binary_rec_eq, binary_rec_zero]
simp [gcd]
rw [add_succ, add_succ, add_assoc]
rw [add_succ, add_succ, add_assoc]; refl
refl
rw mod_def
have h : ¬¨ (0 < 0 ‚àß 0 ‚â§ a)
simp [lt_irrefl]
simp [if_neg, h]
rw mod_def
have h : ¬¨(0 < b ‚àß b ‚â§ 0)
cases hn with l r
exact absurd (lt_of_lt_of_le l r) (lt_irrefl 0)
intro hn
{intro hn, cases hn with l r, exact absurd (lt_of_lt_of_le l r) (lt_irrefl 0)}
simp [if_neg, h]
apply_instance
refl
ext
ext
simp [algebra.commutes]
ext
simp [algebra.smul_def'']
refl
ext
simp
ext
simp only [lmul_left_apply, linear_map.comp_apply, mul_assoc]
ext
rw ‚Üê span_eq M
conv_lhs {rw ‚Üê span_eq M}
change span _ _ * span _ _ = _
rw [span_mul_span]
apply le_antisymm
rw span_le
rintros _ ‚ü®b, m, hb, hm, rfl‚ü©
rw [set_like.mem_coe, mem_map, set.mem_singleton_iff.mp hb]
{ rw span_le, rintros _ ‚ü®b, m, hb, hm, rfl‚ü©, rw [set_like.mem_coe, mem_map, set.mem_singleton_iff.mp hb], exact ‚ü®m, hm, rfl‚ü© }
exact ‚ü®m, hm, rfl‚ü©
exact subset_span ‚ü®a, m, set.mem_singleton a, hm, rfl‚ü©
rintros _ ‚ü®m, hm, rfl‚ü©
rw [‚Üê mul_one I] {occs := occurrences.pos [1]}
apply mul_le_mul_right (one_le_one_div.mpr hI)
ext x
simp only [mem_map, mem_div_iff_forall_mul_mem]
split
rintro ‚ü®x, hx, rfl‚ü© _ ‚ü®y, hy, rfl‚ü©
{ rintro ‚ü®x, hx, rfl‚ü© _ ‚ü®y, hy, rfl‚ü©, exact ‚ü®x * y, hx _ hy, h.map_mul x y‚ü© }
exact ‚ü®x * y, hx _ hy, h.map_mul x y‚ü©
rintro hx
refine ‚ü®h.symm x, Œª z hz, _, h.apply_symm_apply x‚ü©
obtain ‚ü®xz, xz_mem, hxz‚ü© := hx (h z) ‚ü®z, hz, rfl‚ü©
convert xz_mem
apply h.injective
erw [h.map_mul, h.apply_symm_apply, hxz]
rw [algebra.smul_def, mul_smul]
refl
apply le_antisymm
rw submodule.mul_le
intros y hy z hz
{ rw submodule.mul_le, intros y hy z hz, exact mul_mem S hy hz }
exact mul_mem S hy hz
intros x hx1
rw ‚Üê mul_one x
exact submodule.mul_mem_mul hx1 (one_mem S)
simp [set.ext_iff, algebra.mem_bot]
rw [‚Üê mem_restrict_scalars R, H, mem_restrict_scalars]
rcases exists_nat_pow_near (one_le_inv_iff.2 ‚ü®xpos, hx‚ü©) (one_lt_inv_iff.2 ‚ü®ypos, hy‚ü©) with ‚ü®n, hn, h'n‚ü©
refine ‚ü®n, _, _‚ü©
rwa [inv_pow', inv_lt_inv xpos (pow_pos ypos _)] at h'n
{ rwa [inv_pow', inv_lt_inv xpos (pow_pos ypos _)] at h'n }
rwa [inv_pow', inv_le_inv (pow_pos ypos _) xpos] at hn
rwa [div_lt_iff y0, ‚Üê nsmul_eq_mul] at h
simpa only [exists_prop, multiset.mem_map, exists_exists_and_eq_and] using hp.exists_mem_multiset_dvd h
haveI := classical.dec
refine or_iff_not_imp_right.2 (Œª H, _)
simp [h, irreducible_iff] at H ‚ä¢
refine Œª a b h, classical.by_contradiction $ Œª o, _
simp [not_or_distrib] at o
exact H _ o.1 _ o.2 h.symm
rw [g.map_finprod]
{ simp only [g.map_finprod_Prop] }
simp only [g.map_finprod_Prop]
simpa only [finprod_eq_mul_indicator_apply, mul_support_mul_indicator]
simp
rw [‚Üê sum_insert ha, Ico.insert_succ_bot hab]
exactI { has_limit := Œª F, has_limit_of_created F (forget‚ÇÇ CommSemiRing SemiRing.{u}) }
apply_instance
apply w
ext1
exactI { has_biproduct := Œª f, by apply_instance }
apply_instance
ext
ext; refl
refl
simp
tidy
tidy
tidy
tidy
tidy
intros
apply quot.sound
apply relation.smul
intros
intros; apply quot.sound; apply relation.add
intros; apply quot.sound
apply quot.sound
apply relation.add
simp [basis.constr]
exactI { preserves_colimit := Œª F, preserves_colimit_of_preserves_colimit_cocone (colimit_cocone_is_colimit F) (types.colimit_cocone_is_colimit (F ‚ãô forget Mon)) }
apply_instance
rw [this a, this b]
rw one_mul
rw nat.cast_one
rw char_p.cast_eq_zero
rw zero_mul
induction n with n IH
simp [continuants_aux]
case nat.zero { simp [continuants_aux] }
case nat.succ { let g := gcf.of v, let conts := continuants_aux g (n + 2), set pred_conts := continuants_aux g (n + 1) with pred_conts_eq, set ppred_conts := continuants_aux g n with ppred_conts_eq, let pA := pred_conts.a, let pB := pred_conts.b, let ppA := ppred_conts.a, let ppB := ppred_conts.b, change pA * conts.b - pB * conts.a = (-1)^(n + 1), have not_terminated_at_n : ¬¨terminated_at g n, from or.resolve_left hyp n.succ_ne_zero, obtain ‚ü®gp, s_nth_eq‚ü© : ‚àÉ gp, g.s.nth n = some gp, from option.ne_none_iff_exists'.elim_left not_terminated_at_n, suffices : pA * (ppB + gp.b * pB) - pB * (ppA + gp.b * pA) = (-1)^(n + 1), by { simp only [conts, (continuants_aux_recurrence s_nth_eq ppred_conts_eq pred_conts_eq)], have gp_a_eq_one : gp.a = 1, from of_part_num_eq_one (part_num_eq_s_a s_nth_eq), rw [gp_a_eq_one, this.symm], ring }, suffices : pA * ppB - pB * ppA = (-1)^(n + 1), calc pA * (ppB + gp.b * pB) - pB * (ppA + gp.b * pA) = pA * ppB + pA * gp.b * pB - pB * ppA - pB * gp.b * pA : by ring ... = pA * ppB - pB * ppA : by ring ... = (-1)^(n + 1) : by assumption, suffices : ppA * pB - ppB * pA = (-1)^n, by { have pow_succ_n : (-1 : K)^(n + 1) = (-1) * (-1)^n, from pow_succ (-1) n, rw [pow_succ_n, ‚Üêthis], ring }, exact (IH $ or.inr $ mt (terminated_stable $ n.sub_le 1) not_terminated_at_n) }
let g := gcf.of v
let conts := continuants_aux g (n + 2)
set pred_conts := continuants_aux g (n + 1) with pred_conts_eq
set ppred_conts := continuants_aux g n with ppred_conts_eq
let pA := pred_conts.a
let pB := pred_conts.b
let ppA := ppred_conts.a
let ppB := ppred_conts.b
change pA * conts.b - pB * conts.a = (-1)^(n + 1)
from or.resolve_left hyp n.succ_ne_zero
have not_terminated_at_n : ¬¨terminated_at g n
from option.ne_none_iff_exists'.elim_left not_terminated_at_n
obtain ‚ü®gp, s_nth_eq‚ü© : ‚àÉ gp, g.s.nth n = some gp
suffices : pA * (ppB + gp.b * pB) - pB * (ppA + gp.b * pA) = (-1)^(n + 1)
simp only [conts, (continuants_aux_recurrence s_nth_eq ppred_conts_eq pred_conts_eq)]
from of_part_num_eq_one (part_num_eq_s_a s_nth_eq)
have gp_a_eq_one : gp.a = 1
rw [gp_a_eq_one, this.symm]
ring
calc pA * (ppB + gp.b * pB) - pB * (ppA + gp.b * pA) = pA * ppB + pA * gp.b * pB - pB * ppA - pB * gp.b * pA : by ring ... = pA * ppB - pB * ppA : by ring ... = (-1)^(n + 1) : by assumption
suffices : pA * ppB - pB * ppA = (-1)^(n + 1)
ring
ring
assumption
suffices : ppA * pB - ppB * pA = (-1)^n
from pow_succ (-1) n
have pow_succ_n : (-1 : K)^(n + 1) = (-1) * (-1)^n
rw [pow_succ_n, ‚Üêthis]
ring
exact (IH $ or.inr $ mt (terminated_stable $ n.sub_le 1) not_terminated_at_n)
refine Œª h a b c bc, _
rcases le_iff_eq_or_lt.mp bc with rfl | bc
{ exact rfl.le }
exact rfl.le
exact (h _ bc).le
dsimp only [totalize]
dsimp only [totalize]; rw [dif_pos h, dif_pos h]
rw [dif_pos h, dif_pos h]
dsimp only [totalize]
dsimp only [totalize]; rw [dif_neg h, dif_neg h, linear_map.zero_apply]
rw [dif_neg h, dif_neg h, linear_map.zero_apply]
erw [‚Üê (ring.direct_limit.of _ _ _).map_mul, mul_inv_cancel (assume h : x = 0, H $ by rw [h, (ring.direct_limit.of _ _ _).map_zero]), (ring.direct_limit.of _ _ _).map_one]
rw [h, (ring.direct_limit.of _ _ _).map_zero]
exact h.mul_right _
rw mul_comm
split
exact hnd (dvd_zero _)
{ rintro rfl, exact hnd (dvd_zero _) }
rintro rfl
rcases hd with ‚ü®c, rfl‚ü©
refine ‚ü®c, _, rfl‚ü©
rintro ‚ü®u, rfl‚ü©
simpa using hnd
exact if_pos rfl
unfold xgcd_aux
rw [lcm, zero_mul, zero_div]
rw neg_inv
refine (lt_floor_add_one a).trans_le (add_le_add_right _ 1)
norm_cast
exact int.le_to_nat _
simpa only [int.succ, int.cast_add, int.cast_one] using lt_succ_floor x
transitivity gcd k m * normalize n
rw ‚Üê gcd_mul_right
{ rw ‚Üê gcd_mul_right, exact dvd_gcd (dvd_mul_right _ _) H }
exact dvd_gcd (dvd_mul_right _ _) H
apply dvd.intro ‚Üë(norm_unit n)‚Åª¬π
rw [normalize_apply, mul_assoc, mul_assoc, ‚Üê units.coe_mul]
simp
rw [this, normalize_zero]
rw [gcd_eq_zero_iff, lcm_eq_zero_iff]
rw [gcd_eq_zero_iff, lcm_eq_zero_iff]; rintros ‚ü®rfl, rfl‚ü©; left; refl
rw [gcd_eq_zero_iff, lcm_eq_zero_iff]; rintros ‚ü®rfl, rfl‚ü©; left
rw [gcd_eq_zero_iff, lcm_eq_zero_iff]; rintros ‚ü®rfl, rfl‚ü©
left
refl
rintros ‚ü®rfl, rfl‚ü©
rw [gcd_mul_lcm, normalize_idem]
simpa only [normalize.map_mul, normalize_gcd, one_mul, mul_right_inj' h1] using h2
rw [if_neg (mul_ne_zero ha hb), if_neg ha, if_neg hb, units.ext_iff, units.coe_mul]
suffices : (a * b) * ‚Üë(classical.some (associated_map_mk hinv (a * b))) = (a * ‚Üë(classical.some (associated_map_mk hinv a))) * (b * ‚Üë(classical.some (associated_map_mk hinv b)))
apply mul_left_cancel' (mul_ne_zero ha hb) _
{ apply mul_left_cancel' (mul_ne_zero ha hb) _, simpa only [mul_assoc, mul_comm, mul_left_comm] using this }
simpa only [mul_assoc, mul_comm, mul_left_comm] using this
rw [map_mk_unit_aux hinv a, map_mk_unit_aux hinv (a * b), map_mk_unit_aux hinv b, ‚Üê monoid_hom.map_mul, associates.mk_mul_mk]
rw [if_neg (units.ne_zero u), units.ext_iff]
apply mul_left_cancel' (units.ne_zero u)
rw [units.mul_inv, map_mk_unit_aux hinv u, associates.mk_eq_mk_iff_associated.2 (associated_one_iff_is_unit.2 ‚ü®u, rfl‚ü©), associates.mk_one, monoid_hom.map_one]
classical
apply s.induction_on
{ simp }
simp
intros b t hbt h
rw [gcd_insert, gcd_insert, h, ‚Üê gcd_mul_right]
apply ((normalize_associated a).mul_left _).gcd_eq_right
simp
rw [h.eq, mul_inv_cancel_right]
unfreezingI { cases m‚ÇÅ with mul‚ÇÅ _ one‚ÇÅ one_mul‚ÇÅ mul_one‚ÇÅ npow‚ÇÅ npow_zero‚ÇÅ npow_succ‚ÇÅ, cases m‚ÇÇ with mul‚ÇÇ _ one‚ÇÇ one_mul‚ÇÇ mul_one‚ÇÇ npow‚ÇÇ npow_zero‚ÇÇ npow_succ‚ÇÇ }
cases m‚ÇÅ with mul‚ÇÅ _ one‚ÇÅ one_mul‚ÇÅ mul_one‚ÇÅ npow‚ÇÅ npow_zero‚ÇÅ npow_succ‚ÇÅ
cases m‚ÇÇ with mul‚ÇÇ _ one‚ÇÇ one_mul‚ÇÇ mul_one‚ÇÇ npow‚ÇÇ npow_zero‚ÇÇ npow_succ‚ÇÇ
change mul‚ÇÅ = mul‚ÇÇ at h_mul
subst h_mul
have h_one : one‚ÇÅ = one‚ÇÇ
rw ‚Üêone_mul‚ÇÇ one‚ÇÅ
{ rw ‚Üêone_mul‚ÇÇ one‚ÇÅ, exact mul_one‚ÇÅ one‚ÇÇ }
exact mul_one‚ÇÅ one‚ÇÇ
subst h_one
have h_npow : npow‚ÇÅ = npow‚ÇÇ
ext n
induction n with d hd
{ rw [npow_zero‚ÇÅ, npow_zero‚ÇÇ] }
rw [npow_zero‚ÇÅ, npow_zero‚ÇÇ]
{ ext n, induction n with d hd, { rw [npow_zero‚ÇÅ, npow_zero‚ÇÇ] }, { rw [npow_succ‚ÇÅ, npow_succ‚ÇÇ, hd] } }
rw [npow_succ‚ÇÅ, npow_succ‚ÇÇ, hd]
subst h_npow
simp only [function.comp_app, inv_apply, coe_comp]
ext
refine_struct { zero := (0 : Œ† i, f i), one := (1 : Œ† i, f i), mul := (*), npow := Œª n x i, npow n (x i) }
refine_struct { zero := (0 : Œ† i, f i), one := (1 : Œ† i, f i), mul := (*), npow := Œª n x i, npow n (x i) }; tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
simp
simp
simp
simp [units.map]
exact add_monoid_hom.congr_fun h a
ext a
rw [comp_apply, id_apply]
rwa [‚Üê add_eq_zero_iff_eq_neg, ‚Üê sub_eq_zero, or_comm, ‚Üê mul_eq_zero, ‚Üê sq_sub_sq a b, sub_eq_zero]
ring
by_cases n0 : 0 ‚â§ n
lift n to ‚Ñï using n0
{ lift n to ‚Ñï using n0, simp only [abs_nsmul, coe_nat_abs, gsmul_coe_nat] }
simp only [abs_nsmul, coe_nat_abs, gsmul_coe_nat]
lift (- n) to ‚Ñï using int.le_of_lt (neg_pos.mpr (not_le.mp n0)) with m h
rw [‚Üê abs_neg (n ‚Ä¢ a), ‚Üê neg_gsmul, ‚Üê abs_neg n, ‚Üê h, gsmul_coe_nat, coe_nat_abs, gsmul_coe_nat]
exact abs_nsmul m _
rw [nsmul_eq_mul', nsmul_eq_mul', mul_assoc]
simp
obtain ‚ü®p, rfl‚ü© := nat.exists_eq_succ_of_ne_zero h.ne'
refine ‚ü®Œª h, _, is_unit.pow _‚ü©
obtain ‚ü®‚ü®k, k', hk, hk'‚ü©, h‚ü© := h
rw [units.coe_mk] at h
refine ‚ü®‚ü®m, m ^ p * k', _, _‚ü©, _‚ü©
{ rw [‚Üêmul_assoc, ‚Üêpow_succ, ‚Üêh, hk] }
rw [‚Üêmul_assoc, ‚Üêpow_succ, ‚Üêh, hk]
{ rw [mul_right_comm, ‚Üêpow_succ', ‚Üêh, hk] }
rw [mul_right_comm, ‚Üêpow_succ', ‚Üêh, hk]
suffices : function.injective (nat_abs ‚àò ((^) x : ‚Ñï ‚Üí ‚Ñ§))
{ exact function.injective.of_comp this }
exact function.injective.of_comp this
convert nat.pow_right_injective h
ext n
exact units.coe_mk _ _ _ _
rw [function.comp_app, nat_abs_pow]
rw [‚Üê mul, H, zero]
rwa zero
rwa zero
erw [‚Üê mul, ‚Üê mul, H]; refl
refl
erw [‚Üê mul, ‚Üê mul, H]
erw [‚Üê mul, ‚Üê mul, H]; refl
refl
erw [‚Üê mul, ‚Üê mul, H]
simpa only [mul_assoc, mul_inv_cancel h, mul_one] using congr_arg (Œª y, y * x‚Åª¬π) w
rintro rfl
rintro rfl
rw mul_inv_cancel_left' hb
split
rw inv_mul_cancel_left' hb
split; rintro rfl; [rw mul_inv_cancel_left' hb, rw inv_mul_cancel_left' hb]
split; rintro rfl
simp [hx]
{ simp [hx] }
by_cases hx : x = 0
simp [hy]
{ simp [hy] }
by_cases hy : y = 0
symmetry
apply eq_inv_of_mul_left_eq_one
simp [mul_assoc, hx, hy]
simp [h]
simp
rw [‚Üê divp_mk0 _ hc, ‚Üê divp_mk0 _ hc, divp_left_inj]
simp [div_eq_mul_inv]
intro h
intro h
split
split; intro h
rintro rfl
simpa using h
{ rw [pos_iff_ne_zero], rintro rfl, simpa using h }
rw [pos_iff_ne_zero]
exact zero_pow' n h.ne.symm
rw [gpow_coe_nat, gpow_coe_nat, inv_pow']
rw [gpow_neg_succ_of_nat, gpow_neg_succ_of_nat, inv_pow']
dsimp at w
rw dif_neg w
substs hij hjk
dsimp at hij hjk
simp only [category.comp_id, eq_to_hom_refl, dif_pos rfl]
exact congr_fun (X.d_squared) i
dsimp at h ‚ä¢
subst h
simp only [category.comp_id, eq_to_hom_refl, dif_pos rfl]
exact (congr_fun f.comm i).symm
rw [‚Üêcancel_epi (image_to_kernel (0 : A ‚ü∂ B) g exact.w), ‚Üêcancel_epi (factor_thru_image_subobject (0 : A ‚ü∂ B))]
simp
by_cases h : n + 1 = m
subst h
{ subst h, simpa using comm n }
simpa using comm n
simp
rw [of_d_ne X _ _ h, of_d_ne Y _ _ h]
rw [if_pos rfl, category.comp_id]
change ite (2 = 1 + 1) (d‚ÇÅ ‚â´ ùüô X‚ÇÇ) 0 = d‚ÇÅ
simp [subobject.factor_thru_right]
dunfold cycles_map
simp [homology.œÄ, homology.desc]
ext
simp_rw [category.comp_id, homology.œÄ_map_assoc, homology.œÄ_map, ‚Üêcategory.assoc, ‚Üêkernel_subobject_map_comp]
convert category.id_comp _
convert kernel_subobject_map_id
simp
simp
ext
ext; simp
ext
simp_rw [category.comp_id, homology.œÄ_map_assoc, homology.œÄ_map, ‚Üêcategory.assoc, ‚Üêkernel_subobject_map_comp]
convert category.id_comp _
convert kernel_subobject_map_id
simp
simp
ext
ext; simp
apply zero_of_target_iso_zero
dsimp
rw [if_neg h]
simp
simp
simp
ext i
dsimp
split_ifs
simp
{ subst h, simp, }
subst h
symmetry
simp [ha]
simp [ha]
split_ifs
refl
{ refl }
rw [mul_zero]
simp only [indicator]
by_cases hx : x ‚àà ‚ãÉ i, s i
rw [mul_indicator_of_mem hx]
rw [mem_Union] at hx
refine le_antisymm _ (supr_le $ Œª i, mul_indicator_le_self' (Œª x hx, h1 ‚ñ∏ bot_le) x)
rcases hx with ‚ü®i, hi‚ü©
exact le_supr_of_le i (ge_of_eq $ mul_indicator_of_mem hi _)
{ rw [mul_indicator_of_mem hx], rw [mem_Union] at hx, refine le_antisymm _ (supr_le $ Œª i, mul_indicator_le_self' (Œª x hx, h1 ‚ñ∏ bot_le) x), rcases hx with ‚ü®i, hi‚ü©, exact le_supr_of_le i (ge_of_eq $ mul_indicator_of_mem hi _) }
rw [mul_indicator_of_not_mem hx]
simp only [mem_Union, not_exists] at hx
simp [hx, ‚Üê h1]
congr
exact left_inv_eq_right_inv hba hac
simp [‚Üêmul_assoc]
simp [‚Üêmul_assoc]
simp [‚Üêmul_div_assoc]
simp [‚Üêmul_div_assoc]
simp [mul_assoc]
simp
rintros t ‚ü®a‚ü© ‚ü®c‚ü©
change quot.mk _ (a ‚Ä¢ (t ‚Ä¢ c)) = quot.mk _ (t ‚Ä¢ (a ‚Ä¢ c))
rw ‚Üê smul_comm
simp
ext
simp
ext
congr
skip
rw ‚Üê I.incl_ideal_range
conv_rhs { congr, skip, rw ‚Üê I.incl_ideal_range, }
rw comap_bracket_eq
exact I.incl_is_ideal_morphism
simp only [ker_incl, sup_bot_eq]
introsI h
introsI h
split
split; introsI h
{ exact e.symm.injective.lie_algebra_is_nilpotent, }
exact e.symm.injective.lie_algebra_is_nilpotent
exact e.injective.lie_algebra_is_nilpotent
simp [lie_ring.of_associative_ring_bracket]
ext a b
noncomm_ring
apply lie_equiv.of_subalgebras _ _ e.lie_conj
ext f
simp only [lie_subalgebra.mem_coe, submodule.mem_map_equiv, lie_subalgebra.mem_map_submodule, coe_coe]
exact (bilin_form.is_pair_self_adjoint_equiv (-B) B e f).symm
simp only [mem_skew_adjoint_matrices_submodule] at *
change A·µÄ ‚¨ù J = J ‚¨ù -A at hA
change ‚ÅÖA, B‚ÅÜ·µÄ ‚¨ù J = J ‚¨ù -‚ÅÖA, B‚ÅÜ
change B·µÄ ‚¨ù J = J ‚¨ù -B at hB
simp only [‚Üêmatrix.mul_eq_mul] at *
rw [matrix.lie_transpose, lie_ring.of_associative_ring_bracket, lie_ring.of_associative_ring_bracket, sub_mul, mul_assoc, mul_assoc, hA, hB, ‚Üêmul_assoc, ‚Üêmul_assoc, hA, hB]
apply set_coe.ext
simpa
rwa [lie_hom.coe_to_linear_map]
ext
rw [‚Üê mem_coe_submodule, h]
refl
rw [‚Üê add_smul, add_left_neg, zero_smul]
rw [nsmul_eq_smul_cast R, smul_eq_zero]
simp
intros c x
rw [nsmul_eq_mul, mul_one]
exact linear_map.congr_fun h m
ext m
use b.constr ‚Ñï (Œª i, finsupp.single (b i) (1 : R))
intro m
simp only [b.constr_apply, mul_one, id.def, finsupp.smul_single', finsupp.total_single, linear_map.map_finsupp_sum]
exact b.total_repr m
cases c
simp [add_smul]
simp [zero_smul]
ext
simp [single_zero_mul_apply, algebra.smul_def'', pi.smul_apply]
ext
simp [single_zero_mul_apply, mul_single_zero_apply, algebra.commutes]
simp only [lift_apply', algebra.smul_def]
rw [‚Üê sum_single a, ‚Üê sum_single b]
conv_rhs { rw [‚Üê sum_single a, ‚Üê sum_single b] }
simp_rw [mul_def, (lift_nc _ g).map_finsupp_sum, lift_nc_single, finsupp.sum_mul, finsupp.mul_sum]
refine finset.sum_congr rfl (Œª y hy, finset.sum_congr rfl (Œª x hx, _))
simp [mul_assoc, (h_comm hy).left_comm]
refl
ext
simp
split
intro h
rw [‚Üê unop_op a, ‚Üê unop_op x, ‚Üê unop_op y]
{ intro h, rw [‚Üê unop_op a, ‚Üê unop_op x, ‚Üê unop_op y], exact semiconj_by.unop h }
exact semiconj_by.unop h
intro h
exact semiconj_by.op h
unfold cmp cmp_using
by_cases a < b; by_cases h‚ÇÇ : b < a; simp [h, h‚ÇÇ, gt, ordering.swap]
by_cases a < b; by_cases h‚ÇÇ : b < a
by_cases h‚ÇÇ : b < a
by_cases h‚ÇÇ : b < a
by_cases a < b
simp [h, h‚ÇÇ, gt, ordering.swap]
simp [h, h‚ÇÇ, gt, ordering.swap]
simp [h, h‚ÇÇ, gt, ordering.swap]
simp [h, h‚ÇÇ, gt, ordering.swap]
exact lt_asymm h h‚ÇÇ
rw cmp_eq_eq_iff
rw [mul_comm, inv_mul_lt_iff' h]
rw [‚Üê inv_le_inv_of_neg (inv_lt_zero.2 hb) ha, inv_inv']
rw [div_lt_iff_of_neg hb, one_mul]
simpa using inv_le ha hb
rw mul_inv_self
rw mul_inv_self
rw [mul_comm c, mul_inv_lt_inv_mul_iff, mul_comm]
rw [‚Üê mul_lt_mul_iff_right b, one_mul, div_eq_mul_inv, inv_mul_cancel_right]
haveI := @linear_order.decidable_le Œ± _
rw [‚Üê abs_mul_abs_self x]
exact decidable.mul_self_le_mul_self (abs_nonneg x) (abs_le.2 ‚ü®neg_le.2 h‚ÇÇ, h‚ÇÅ‚ü©)
rw abs_mul_abs_self
simp only [mul_add, add_comm, add_left_comm, mul_comm, sub_eq_add_neg, mul_one, mul_neg_eq_neg_mul_symm, neg_add_rev, neg_neg]
classical; exact decidable.mul_nonneg_le_one_le
exact decidable.mul_nonneg_le_one_le
classical
haveI := @linear_order.decidable_le Œ± _; exact ‚ü®lt_imp_lt_of_le_imp_le $ Œª h', decidable.mul_le_mul_of_nonneg_left h' h.le, Œª h', mul_lt_mul_of_pos_left h' h‚ü©
exact ‚ü®lt_imp_lt_of_le_imp_le $ Œª h', decidable.mul_le_mul_of_nonneg_left h' h.le, Œª h', mul_lt_mul_of_pos_left h' h‚ü©
haveI := @linear_order.decidable_le Œ± _
refine le_antisymm (sub_le_iff_left.mpr _) (sub_le_iff_left.mpr $ sub_le_iff_left.mpr _)
refine le_trans le_add_sub (add_le_add_left le_add_sub _)
rw [add_assoc]
{ rw [add_assoc], refine le_trans le_add_sub (add_le_add_left le_add_sub _) }
apply le_add_sub
rw [‚Üê add_assoc]
rw [sub_le_iff_right, sub_add_cancel_of_le h]
rw [‚Üê nonpos_iff_eq_zero, sub_le_iff_left, add_zero]
rw [‚Üê sub_add_cancel_of_le h‚ÇÅ, ‚Üê sub_add_cancel_of_le h‚ÇÇ, h‚ÇÉ]
rw [add_comm a, hb.add_sub_assoc_of_le h, add_comm]
refine ‚ü®_, Œª h, sub_le_sub_left' h a‚ü©
rw [sub_le_iff_left, ‚Üê hc.add_sub_assoc_of_le h, hc.le_sub_iff_right (h.trans le_add_self), add_comm b]
apply ha
rw [hba.sub_eq_iff_eq_add_of_le sub_le_self', add_sub_cancel_of_le h]
simpa [h] using hab
rw [ha, zero_mul, zero_lt_iff]
exact mul_ne_zero hb hd
rw [hc, mul_zero, zero_lt_iff]
exact mul_ne_zero hb hd
simpa only [smul_add, smul_inv_smul' ha] using h (a ‚Ä¢ x)
refine_struct { mul := Œª _ _, star, one := star, inv := Œª _, star, div := Œª _ _, star, npow := Œª _ _, star, gpow := Œª _ _, star, .. }
refine_struct { mul := Œª _ _, star, one := star, inv := Œª _, star, div := Œª _ _, star, npow := Œª _ _, star, gpow := Œª _ _, star, .. }; intros; exact subsingleton.elim _ _
refine_struct { mul := Œª _ _, star, one := star, inv := Œª _, star, div := Œª _ _, star, npow := Œª _ _, star, gpow := Œª _ _, star, .. }; intros
intros
intros
intros
intros
intros
intros
intros
intros
intros
exact subsingleton.elim _ _
exact subsingleton.elim _ _
exact subsingleton.elim _ _
exact subsingleton.elim _ _
exact subsingleton.elim _ _
exact subsingleton.elim _ _
exact subsingleton.elim _ _
exact subsingleton.elim _ _
exact subsingleton.elim _ _
exact subsingleton.elim _ _
rw [‚Üêright_inv x y, ‚Üêself_distrib]
simpa using h
have h := @self_act_eq_iff_eq _ _ (op x) (op y)
ext
ext; simp [neg_add]
simp [neg_add]
simp [neg_add]
simp [neg_add]
simp [neg_add]
ext
ext; simp
simp
simp
simp
simp
simp
rw [add_comm, self_add_conj]
rw [norm_sq_def, conj_coe, ‚Üê coe_mul, coe_re, sq]
rw [‚Üêi_mul_j, mul_assoc, j_mul_j, mul_smul_comm, mul_one]
rw [nontrivial_iff, not_iff_comm, is_left_regular_zero_iff_subsingleton, subsingleton_iff]
push_neg
exact iff.rfl
rw h
exact is_regular_one.right
rwa comp_mul_left a b
ac_refl
rw [mul_one_add_self, mul_zero, add_zero, mul_add, mul_one]
ac_refl
rw [add_self, add_zero]
rw mul_self
rw [add_mul, mul_add]
rw mul_self
rwa self_eq_add_left at this
simp
rw [‚Üê ring_hom.comp_apply, comp_eq‚ÇÇ]
refine_struct { zero := (0 : Œ† i, f i), add := (+), mul := (*), .. }
refine_struct { zero := (0 : Œ† i, f i), add := (+), mul := (*), .. }; tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
refine_struct { zero := (0 : Œ† i, f i), one := 1, add := (+), mul := (*), neg := has_neg.neg, nsmul := Œª n x i, nsmul n (x i), npow := Œª n x i, npow n (x i) }
refine_struct { zero := (0 : Œ† i, f i), one := 1, add := (+), mul := (*), neg := has_neg.neg, nsmul := Œª n x i, nsmul n (x i), npow := Œª n x i, npow n (x i) }; tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
tactic.pi_instance_derive_field
rw [unop_id, Spec.SheafedSpace_map_id]
rw [unop_comp, Spec.SheafedSpace_map_comp]
apply_instance
rw [Spec.LocallyRingedSpace_map_coe, Spec.SheafedSpace_map_comp]
refl
rw [unop_id, Spec.Top_map_id]
rw [unop_comp, Spec.Top_map_comp]
simp [vanishing_ideal]
split
contrapose!
intro h
apply set.ne_empty_iff_nonempty.mpr
rcases ideal.exists_le_maximal I h with ‚ü®M, hM, hIM‚ü©
{ contrapose!, intro h, apply set.ne_empty_iff_nonempty.mpr, rcases ideal.exists_le_maximal I h with ‚ü®M, hM, hIM‚ü©, exact ‚ü®‚ü®M, hM.is_prime‚ü©, hIM‚ü© }
exact ‚ü®‚ü®M, hM.is_prime‚ü©, hIM‚ü©
apply zero_locus_empty_of_one_mem
trivial
rintro rfl
simp only [zero_locus_Union]
rw continuous_iff_is_closed
simp only [is_closed_iff_zero_locus]
rintro _ ‚ü®s, rfl‚ü©
exact ‚ü®_, preimage_comap_zero_locus f s‚ü©
ext1
ext1 i
apply ulift.up.inj
ext1
change (skeletal_functor.map f) ‚ü®i‚ü© = (skeletal_functor.map g) ‚ü®i‚ü©
rw h
split
introsI m x y h
have H : const n x ‚â´ f = const n y ‚â´ f
rw h
{ dsimp, rw h }
dsimp
change (n.const x).to_preorder_hom 0 = (n.const y).to_preorder_hom 0
rw cancel_mono f at H
{ introsI m x y h, have H : const n x ‚â´ f = const n y ‚â´ f, { dsimp, rw h }, change (n.const x).to_preorder_hom 0 = (n.const y).to_preorder_hom 0, rw cancel_mono f at H, rw H }
rw H
exact concrete_category.mono_of_injective f
intros i j g
dsimp
rw ‚Üê g.op_unop
simpa only [‚Üê X.map_comp, ‚Üê category.assoc, category.comp_id, ‚Üê op_comp] using w _ _ _
simp only [‚ÜêX.map_comp, simplex_category.Œ¥_comp_œÉ_of_gt H]
dsimp [Œ¥, œÉ]
simp
tidy
rw h
have f_bound : ‚àÄ t ‚àà Ico a b, dist (v t (f t)) (v t (f t)) ‚â§ 0
intros
rw [dist_self]
have g_bound : ‚àÄ t ‚àà Ico a b, dist (v t (g t)) (v t (g t)) ‚â§ 0
intros
rw [dist_self]
assume t ht
have := dist_le_of_approx_trajectories_ODE_of_mem_set hv hf hf' f_bound hfs hg hg' g_bound hgs ha t ht
rwa [zero_add, gronwall_bound_Œµ0] at this
obtain ‚ü®a, ha : a ‚àà Ioo (0 : ‚Ñù) 1, C, hC : 0 < C, hp‚ü© := p.norm_mul_pow_le_mul_pow_of_lt_radius h
exact summable_of_nonneg_of_le (Œª n, mul_nonneg (norm_nonneg _) (pow_nonneg r.coe_nonneg _)) hp ((summable_geometric_of_lt_1 ha.1.le ha.2).mul_left _)
rw is_open_iff_mem_nhds
rintro x ‚ü®p, r, hr‚ü©
exact mem_of_superset (emetric.ball_mem_nhds _ hr.r_pos) (Œª y hy, hr.analytic_at_of_mem hy)
split
intro hequiv
have := hequiv.is_o.tendsto_0
simp only [pi.sub_apply, sub_div] at this
have key : tendsto (Œª x, v x / v x) l (ùìù 1)
exact (tendsto_congr' $ hz.mono $ Œª x hnz, @div_self _ _ (v x) hnz).mpr tendsto_const_nhds
{ exact (tendsto_congr' $ hz.mono $ Œª x hnz, @div_self _ _ (v x) hnz).mpr tendsto_const_nhds }
convert this.add key
simp
{ ext, simp }
ext
{ intro hequiv, have := hequiv.is_o.tendsto_0, simp only [pi.sub_apply, sub_div] at this, have key : tendsto (Œª x, v x / v x) l (ùìù 1), { exact (tendsto_congr' $ hz.mono $ Œª x hnz, @div_self _ _ (v x) hnz).mpr tendsto_const_nhds }, convert this.add key, { ext, simp }, { norm_num } }
norm_num
exact is_equivalent_of_tendsto_one (hz.mono $ Œª x hnvz hz, (hnvz hz).elim)
rw is_O
rw is_O; exact ‚ü®c, h‚ü©
exact ‚ü®c, h‚ü©
simp [h _ hx, hx]
exact exists_congr (Œª C, e.is_O_with_congr hb)
unfold is_O
exact exists_congr (Œª C, e.is_O_with_congr)
unfold is_O
simp [subsingleton.elim (f' _) 0, mul_nonneg hc.le]
simp only [is_O_with, norm_neg]
simpa only [sub_eq_add_neg] using h‚ÇÅ.add h‚ÇÇ.neg_left
rw is_O_with
have := (has_fderiv_within_at.mul' hc hd).has_deriv_within_at
rwa [continuous_linear_map.add_apply, continuous_linear_map.smul_apply, continuous_linear_map.smul_right_apply, continuous_linear_map.smul_right_apply, continuous_linear_map.smul_right_apply, continuous_linear_map.one_apply, one_smul, one_smul, add_comm] at this
simp only [div_eq_mul_inv, deriv_mul_const_field]
rw differentiable_at.deriv_within p.differentiable_at hxs
exact p.deriv
rw [‚Üê Ici_diff_left, has_deriv_within_at_diff_singleton]
simp only [has_deriv_within_at, nhds_within_union]
exact hs.join ht
simp [deriv]
simpa using (hc.smul hf).has_strict_deriv_at
simpa using h.neg.has_deriv_at_filter
simpa only [sub_eq_add_neg] using hf.add hg.neg
rw [fderiv_within_zero_of_not_differentiable_within_at hf, fderiv_within_zero_of_not_differentiable_within_at]
simpa
have tendsto_arg : tendsto (Œª n, x + d n) l (ùìù[s] x)
rw ‚Üê add_zero x
conv in (ùìù[s] x) { rw ‚Üê add_zero x }
rw [nhds_within, tendsto_inf]
split
{ apply tendsto_const_nhds.add (tangent_cone_at.lim_zero l clim cdlim) }
apply tendsto_const_nhds.add (tangent_cone_at.lim_zero l clim cdlim)
{ conv in (ùìù[s] x) { rw ‚Üê add_zero x }, rw [nhds_within, tendsto_inf], split, { apply tendsto_const_nhds.add (tangent_cone_at.lim_zero l clim cdlim) }, { rwa tendsto_principal } }
rwa tendsto_principal
have : is_o (Œª y, f y - f x - f' (y - x)) (Œª y, y - x) (ùìù[s] x) := h
have : is_o (Œª n, f (x + d n) - f x - f' ((x + d n) - x)) (Œª n, (x + d n) - x) l := this.comp_tendsto tendsto_arg
have : is_o (Œª n, f (x + d n) - f x - f' (d n)) d l := by simpa only [add_sub_cancel']
simpa only [add_sub_cancel']
have : is_o (Œªn, c n ‚Ä¢ (f (x + d n) - f x - f' (d n))) (Œªn, c n ‚Ä¢ d n) l := (is_O_refl c l).smul_is_o this
have : is_o (Œªn, c n ‚Ä¢ (f (x + d n) - f x - f' (d n))) (Œªn, (1:‚Ñù)) l := this.trans_is_O (is_O_one_of_tendsto ‚Ñù cdlim)
have L1 : tendsto (Œªn, c n ‚Ä¢ (f (x + d n) - f x - f' (d n))) l (ùìù 0) := (is_o_one_iff ‚Ñù).1 this
have L2 : tendsto (Œªn, f' (c n ‚Ä¢ d n)) l (ùìù (f' v)) := tendsto.comp f'.cont.continuous_at cdlim
have L3 : tendsto (Œªn, (c n ‚Ä¢ (f (x + d n) - f x - f' (d n)) + f' (c n ‚Ä¢ d n))) l (ùìù (0 + f' v)) := L1.add L2
have : (Œªn, (c n ‚Ä¢ (f (x + d n) - f x - f' (d n)) + f' (c n ‚Ä¢ d n))) = (Œªn, c n ‚Ä¢ (f (x + d n) - f x))
ext n
simp [smul_add, smul_sub]
rwa [this, zero_add] at L3
refine ‚ü®Œª H, _, Œª H, iso.has_strict_fderiv_at.comp x H‚ü©
convert iso.symm.has_strict_fderiv_at.comp x H
convert iso.symm.has_strict_fderiv_at.comp x H; ext z; apply (iso.symm_apply_apply _).symm
convert iso.symm.has_strict_fderiv_at.comp x H; ext z
ext z
ext z
apply (iso.symm_apply_apply _).symm
apply (iso.symm_apply_apply _).symm
simp
rw [sub_eq_zero.1 (norm_eq_zero.1 hx')]
unfold has_fderiv_at_filter
rw [‚Üêis_o_norm_left, ‚Üêis_o_norm_right, is_o_iff_tendsto h]
exact tendsto_congr (Œª _, div_eq_inv_mul)
refine le_of_forall_pos_le_add (Œª Œµ Œµ0, op_norm_le_of_nhds_zero _ _)
exact add_nonneg C.coe_nonneg Œµ0.le
rw [‚Üê map_add_left_nhds_zero x‚ÇÄ, mem_map] at hs'
have hs' := hs
filter_upwards [is_o_iff.1 (has_fderiv_at_iff_is_o_nhds_zero.1 hf) Œµ0, hs']
intros y hy hys
have := hlip.norm_sub_le hys (mem_of_mem_nhds hs)
rw add_sub_cancel' at this
calc ‚à•f' y‚à• ‚â§ ‚à•f (x‚ÇÄ + y) - f x‚ÇÄ‚à• + ‚à•f (x‚ÇÄ + y) - f x‚ÇÄ - f' y‚à• : norm_le_insert _ _ ... ‚â§ C * ‚à•y‚à• + Œµ * ‚à•y‚à• : add_le_add this hy ... = (C + Œµ) * ‚à•y‚à• : (add_mul _ _ _).symm
simp [has_fderiv_within_at, nhds_within_restrict' s h]
rcases hx with ‚ü®r', r'mem, hr'‚ü©
exact hr' _ _ (lt_of_le_of_lt (mem_closed_ball.1 hy) r'mem.1) (lt_of_le_of_lt (mem_closed_ball.1 hz) r'mem.1)
refl
ext x
rw fderiv_within_zero_of_not_differentiable_within_at hf
refl
ext y
apply (h.on univ).has_fderiv_within_at_eq_zero hf.has_fderiv_within_at
apply (h.on univ).has_fderiv_within_at_eq_zero hf.has_fderiv_within_at; rw pos_tangent_cone_at_univ; apply mem_univ
apply (h.on univ).has_fderiv_within_at_eq_zero hf.has_fderiv_within_at; rw pos_tangent_cone_at_univ
apply mem_univ
apply mem_univ
rw pos_tangent_cone_at_univ
rw pos_tangent_cone_at_univ
refine norm_image_sub_le_of_norm_deriv_le_segment' _ bound
exact Œª x hx, (hf x hx).has_deriv_within_at
let h := Œª x, (lgb - lga) * f x - (lfb - lfa) * g x
have hha : tendsto h (ùìù[Ioi a] a) (ùìù $ lgb * lfa - lfb * lga)
have : tendsto h (ùìù[Ioi a] a)(ùìù $ (lgb - lga) * lfa - (lfb - lfa) * lga) := (tendsto_const_nhds.mul hfa).sub (tendsto_const_nhds.mul hga)
convert this using 2
{ have : tendsto h (ùìù[Ioi a] a)(ùìù $ (lgb - lga) * lfa - (lfb - lfa) * lga) := (tendsto_const_nhds.mul hfa).sub (tendsto_const_nhds.mul hga), convert this using 2, ring }
ring
have hhb : tendsto h (ùìù[Iio b] b) (ùìù $ lgb * lfa - lfb * lga)
have : tendsto h (ùìù[Iio b] b)(ùìù $ (lgb - lga) * lfb - (lfb - lfa) * lgb) := (tendsto_const_nhds.mul hfb).sub (tendsto_const_nhds.mul hgb)
convert this using 2
{ have : tendsto h (ùìù[Iio b] b)(ùìù $ (lgb - lga) * lfb - (lfb - lfa) * lgb) := (tendsto_const_nhds.mul hfb).sub (tendsto_const_nhds.mul hgb), convert this using 2, ring }
ring
let h' := Œª x, (lgb - lga) * f' x - (lfb - lfa) * g' x
have hhh' : ‚àÄ x ‚àà Ioo a b, has_deriv_at h (h' x) x
intros x hx
exact ((hff' x hx).const_mul _ ).sub (((hgg' x hx)).const_mul _)
{ intros x hx, exact ((hff' x hx).const_mul _ ).sub (((hgg' x hx)).const_mul _) }
rcases exists_has_deriv_at_eq_zero' hab hha hhb hhh' with ‚ü®c, cmem, hc‚ü©
exact ‚ü®c, cmem, sub_eq_zero.1 hc‚ü©
apply mem_of_superset (ball_mem_nhds _ Œµ_pos)
intros x x_in
rw [set.mem_set_of_eq, ‚Üê norm_smul_of_nonneg (nneg _), integral_smul, integral_sub, integral_sub, ‚Üê continuous_linear_map.integral_apply hF'_int]
exacts [hF_int' x x_in, hF_int, (hF_int' x x_in).sub hF_int, hF'_int.apply_continuous_linear_map _]
{ apply mem_of_superset (ball_mem_nhds _ Œµ_pos), intros x x_in, rw [set.mem_set_of_eq, ‚Üê norm_smul_of_nonneg (nneg _), integral_smul, integral_sub, integral_sub, ‚Üê continuous_linear_map.integral_apply hF'_int], exacts [hF_int' x x_in, hF_int, (hF_int' x x_in).sub hF_int, hF'_int.apply_continuous_linear_map _] }
rw [has_fderiv_at_iff_tendsto, tendsto_congr' this, ‚Üê tendsto_zero_iff_norm_tendsto_zero, ‚Üê show ‚à´ (a : Œ±), ‚à•x‚ÇÄ - x‚ÇÄ‚à•‚Åª¬π ‚Ä¢ (F x‚ÇÄ a - F x‚ÇÄ a - (F' a) (x‚ÇÄ - x‚ÇÄ)) ‚àÇŒº = 0, by simp]
simp
apply tendsto_integral_filter_of_dominated_convergence
{ apply is_countably_generated_nhds }
apply is_countably_generated_nhds
filter_upwards [h_ball]
intros x x_in
apply ae_measurable.const_smul
exact ((hF_meas _ x_in).sub (hF_meas _ x‚ÇÄ_in)).sub (hF'_meas.apply_continuous_linear_map _)
{ filter_upwards [h_ball], intros x x_in, apply ae_measurable.const_smul, exact ((hF_meas _ x_in).sub (hF_meas _ x‚ÇÄ_in)).sub (hF'_meas.apply_continuous_linear_map _) }
{ simp [measurable_const] }
simp [measurable_const]
apply mem_of_superset h_ball
intros x hx
apply (h_diff.and h_lipsch).mono
rintros a ‚ü®ha_deriv, ha_bound‚ü©
show ‚à•‚à•x - x‚ÇÄ‚à•‚Åª¬π ‚Ä¢ (F x a - F x‚ÇÄ a - F' a (x - x‚ÇÄ))‚à• ‚â§ b a + ‚à•F' a‚à•
replace ha_bound : ‚à•F x a - F x‚ÇÄ a‚à• ‚â§ b a * ‚à•x - x‚ÇÄ‚à•
rw lipschitz_on_with_iff_norm_sub_le at ha_bound
{ rw lipschitz_on_with_iff_norm_sub_le at ha_bound, exact ha_bound _ hx _ x‚ÇÄ_in }
exact ha_bound _ hx _ x‚ÇÄ_in
calc ‚à•‚à•x - x‚ÇÄ‚à•‚Åª¬π ‚Ä¢ (F x a - F x‚ÇÄ a - F' a (x - x‚ÇÄ))‚à• = ‚à•‚à•x - x‚ÇÄ‚à•‚Åª¬π ‚Ä¢ (F x a - F x‚ÇÄ a) - ‚à•x - x‚ÇÄ‚à•‚Åª¬π ‚Ä¢ F' a (x - x‚ÇÄ)‚à• : by rw smul_sub ... ‚â§ ‚à•‚à•x - x‚ÇÄ‚à•‚Åª¬π ‚Ä¢ (F x a - F x‚ÇÄ a)‚à• + ‚à•‚à•x - x‚ÇÄ‚à•‚Åª¬π ‚Ä¢ F' a (x - x‚ÇÄ)‚à• : norm_sub_le _ _ ... = ‚à•x - x‚ÇÄ‚à•‚Åª¬π * ‚à•F x a - F x‚ÇÄ a‚à• + ‚à•x - x‚ÇÄ‚à•‚Åª¬π * ‚à•F' a (x - x‚ÇÄ)‚à• : by { rw [norm_smul_of_nonneg, norm_smul_of_nonneg] ; exact nneg _} ... ‚â§ ‚à•x - x‚ÇÄ‚à•‚Åª¬π * (b a * ‚à•x - x‚ÇÄ‚à•) + ‚à•x - x‚ÇÄ‚à•‚Åª¬π * (‚à•F' a‚à• * ‚à•x - x‚ÇÄ‚à•) : add_le_add _ _ ... ‚â§ b a + ‚à•F' a‚à• : _
rw smul_sub
rw [norm_smul_of_nonneg, norm_smul_of_nonneg]
rw [norm_smul_of_nonneg, norm_smul_of_nonneg] ; exact nneg _
exact nneg _
exact mul_le_mul_of_nonneg_left ha_bound (nneg _)
apply mul_le_mul_of_nonneg_left ((F' a).le_op_norm _) (nneg _)
by_cases h : ‚à•x - x‚ÇÄ‚à• = 0
{ simpa [h] using add_nonneg (b_nonneg a) (norm_nonneg (F' a)) }
simpa [h] using add_nonneg (b_nonneg a) (norm_nonneg (F' a))
{ apply mem_of_superset h_ball, intros x hx, apply (h_diff.and h_lipsch).mono, rintros a ‚ü®ha_deriv, ha_bound‚ü©, show ‚à•‚à•x - x‚ÇÄ‚à•‚Åª¬π ‚Ä¢ (F x a - F x‚ÇÄ a - F' a (x - x‚ÇÄ))‚à• ‚â§ b a + ‚à•F' a‚à•, replace ha_bound : ‚à•F x a - F x‚ÇÄ a‚à• ‚â§ b a * ‚à•x - x‚ÇÄ‚à•, { rw lipschitz_on_with_iff_norm_sub_le at ha_bound, exact ha_bound _ hx _ x‚ÇÄ_in }, calc ‚à•‚à•x - x‚ÇÄ‚à•‚Åª¬π ‚Ä¢ (F x a - F x‚ÇÄ a - F' a (x - x‚ÇÄ))‚à• = ‚à•‚à•x - x‚ÇÄ‚à•‚Åª¬π ‚Ä¢ (F x a - F x‚ÇÄ a) - ‚à•x - x‚ÇÄ‚à•‚Åª¬π ‚Ä¢ F' a (x - x‚ÇÄ)‚à• : by rw smul_sub ... ‚â§ ‚à•‚à•x - x‚ÇÄ‚à•‚Åª¬π ‚Ä¢ (F x a - F x‚ÇÄ a)‚à• + ‚à•‚à•x - x‚ÇÄ‚à•‚Åª¬π ‚Ä¢ F' a (x - x‚ÇÄ)‚à• : norm_sub_le _ _ ... = ‚à•x - x‚ÇÄ‚à•‚Åª¬π * ‚à•F x a - F x‚ÇÄ a‚à• + ‚à•x - x‚ÇÄ‚à•‚Åª¬π * ‚à•F' a (x - x‚ÇÄ)‚à• : by { rw [norm_smul_of_nonneg, norm_smul_of_nonneg] ; exact nneg _} ... ‚â§ ‚à•x - x‚ÇÄ‚à•‚Åª¬π * (b a * ‚à•x - x‚ÇÄ‚à•) + ‚à•x - x‚ÇÄ‚à•‚Åª¬π * (‚à•F' a‚à• * ‚à•x - x‚ÇÄ‚à•) : add_le_add _ _ ... ‚â§ b a + ‚à•F' a‚à• : _, exact mul_le_mul_of_nonneg_left ha_bound (nneg _), apply mul_le_mul_of_nonneg_left ((F' a).le_op_norm _) (nneg _), by_cases h : ‚à•x - x‚ÇÄ‚à• = 0, { simpa [h] using add_nonneg (b_nonneg a) (norm_nonneg (F' a)) }, { field_simp [h] } }
field_simp [h]
{ exact b_int.add hF'_int.norm }
exact b_int.add hF'_int.norm
apply h_diff.mono
intros a ha
suffices : tendsto (Œª x, ‚à•x - x‚ÇÄ‚à•‚Åª¬π ‚Ä¢ (F x a - F x‚ÇÄ a - F' a (x - x‚ÇÄ))) (ùìù x‚ÇÄ) (ùìù 0)
simpa
rw tendsto_zero_iff_norm_tendsto_zero
have : (Œª x, ‚à•x - x‚ÇÄ‚à•‚Åª¬π * ‚à•F x a - F x‚ÇÄ a - F' a (x - x‚ÇÄ)‚à•) = Œª x, ‚à•‚à•x - x‚ÇÄ‚à•‚Åª¬π ‚Ä¢ (F x a - F x‚ÇÄ a - F' a (x - x‚ÇÄ))‚à•
ext x
{ ext x, rw norm_smul_of_nonneg (nneg _) }
rw norm_smul_of_nonneg (nneg _)
rwa [has_fderiv_at_iff_tendsto, this] at ha
have x‚ÇÄ_in : x‚ÇÄ ‚àà ball x‚ÇÄ Œµ := mem_ball_self Œµ_pos
have nneg : ‚àÄ x, 0 ‚â§ ‚à•x - x‚ÇÄ‚à•‚Åª¬π := Œª x, inv_nonneg.mpr (norm_nonneg _)
set b : Œ± ‚Üí ‚Ñù := Œª a, abs (bound a)
have b_int : integrable b Œº := bound_integrable.norm
have b_nonneg : ‚àÄ a, 0 ‚â§ b a := Œª a, abs_nonneg _
have hF_int' : ‚àÄ x ‚àà ball x‚ÇÄ Œµ, integrable (F x) Œº
intros x x_in
have : ‚àÄ·µê a ‚àÇŒº, ‚à•F x‚ÇÄ a - F x a‚à• ‚â§ Œµ * ‚à•(bound a : ‚Ñù)‚à•
apply h_lipsch.mono
intros a ha
rw lipschitz_on_with_iff_norm_sub_le at ha
apply (ha x‚ÇÄ x‚ÇÄ_in x x_in).trans
rw [mul_comm, real.coe_nnabs, real.norm_eq_abs]
rw [mem_ball, dist_eq_norm, norm_sub_rev] at x_in
{ apply h_lipsch.mono, intros a ha, rw lipschitz_on_with_iff_norm_sub_le at ha, apply (ha x‚ÇÄ x‚ÇÄ_in x x_in).trans, rw [mul_comm, real.coe_nnabs, real.norm_eq_abs], rw [mem_ball, dist_eq_norm, norm_sub_rev] at x_in, exact mul_le_mul_of_nonneg_right (le_of_lt x_in) (abs_nonneg _) }
exact mul_le_mul_of_nonneg_right (le_of_lt x_in) (abs_nonneg _)
exact integrable_of_norm_sub_le (hF_meas x x_in) hF_int (integrable.const_mul bound_integrable.norm Œµ) this
{ intros x x_in, have : ‚àÄ·µê a ‚àÇŒº, ‚à•F x‚ÇÄ a - F x a‚à• ‚â§ Œµ * ‚à•(bound a : ‚Ñù)‚à•, { apply h_lipsch.mono, intros a ha, rw lipschitz_on_with_iff_norm_sub_le at ha, apply (ha x‚ÇÄ x‚ÇÄ_in x x_in).trans, rw [mul_comm, real.coe_nnabs, real.norm_eq_abs], rw [mem_ball, dist_eq_norm, norm_sub_rev] at x_in, exact mul_le_mul_of_nonneg_right (le_of_lt x_in) (abs_nonneg _) }, exact integrable_of_norm_sub_le (hF_meas x x_in) hF_int (integrable.const_mul bound_integrable.norm Œµ) this }
have hF'_int : integrable F' Œº
have : ‚àÄ·µê a ‚àÇŒº, ‚à•F' a‚à• ‚â§ b a
apply (h_diff.and h_lipsch).mono
rintros a ‚ü®ha_diff, ha_lip‚ü©
{ apply (h_diff.and h_lipsch).mono, rintros a ‚ü®ha_diff, ha_lip‚ü©, exact ha_diff.le_of_lip (ball_mem_nhds _ Œµ_pos) ha_lip }
exact ha_diff.le_of_lip (ball_mem_nhds _ Œµ_pos) ha_lip
{ have : ‚àÄ·µê a ‚àÇŒº, ‚à•F' a‚à• ‚â§ b a, { apply (h_diff.and h_lipsch).mono, rintros a ‚ü®ha_diff, ha_lip‚ü©, exact ha_diff.le_of_lip (ball_mem_nhds _ Œµ_pos) ha_lip }, exact b_int.mono' hF'_meas this }
exact b_int.mono' hF'_meas this
refine ‚ü®hF'_int, _‚ü©
have h_ball: ball x‚ÇÄ Œµ ‚àà ùìù x‚ÇÄ := ball_mem_nhds x‚ÇÄ Œµ_pos
have : ‚àÄ·∂† x in ùìù x‚ÇÄ, ‚à•x - x‚ÇÄ‚à•‚Åª¬π * ‚à•‚à´ a, F x a ‚àÇŒº - ‚à´ a, F x‚ÇÄ a ‚àÇŒº - (‚à´ a, F' a ‚àÇŒº) (x - x‚ÇÄ)‚à• = ‚à•‚à´ a, ‚à•x - x‚ÇÄ‚à•‚Åª¬π ‚Ä¢ (F x a - F x‚ÇÄ a - F' a (x - x‚ÇÄ)) ‚àÇŒº‚à•
ext x
suffices : f x ‚â† 0 ‚Üî dist x c < f.R
simpa [mem_support]
cases lt_or_le (dist x c) f.R with hx hx
{ simp [hx, (f.pos_of_mem_ball hx).ne'] }
simp [hx, (f.pos_of_mem_ball hx).ne']
simp [hx.not_lt, f.zero_of_le_dist hx]
rw [f.support_eq, euclidean.closure_ball _ f.R_pos]
have A : tendsto (Œªn, ‚à•c n‚à•‚Åª¬π) l (ùìù 0) := tendsto_inv_at_top_zero.comp hc
have B : tendsto (Œªn, ‚à•c n ‚Ä¢ d n‚à•) l (ùìù ‚à•y‚à•) := (continuous_norm.tendsto _).comp hd
have C : tendsto (Œªn, ‚à•c n‚à•‚Åª¬π * ‚à•c n ‚Ä¢ d n‚à•) l (ùìù (0 * ‚à•y‚à•)) := A.mul B
rw zero_mul at C
have : ‚àÄ·∂† n in l, ‚à•c n‚à•‚Åª¬π * ‚à•c n ‚Ä¢ d n‚à• = ‚à•d n‚à•
apply (eventually_ne_of_tendsto_norm_at_top hc 0).mono (Œªn hn, _)
rw [norm_smul, ‚Üê mul_assoc, inv_mul_cancel, one_mul]
{ apply (eventually_ne_of_tendsto_norm_at_top hc 0).mono (Œªn hn, _), rw [norm_smul, ‚Üê mul_assoc, inv_mul_cancel, one_mul], rwa [ne.def, norm_eq_zero] }
rwa [ne.def, norm_eq_zero]
have D : tendsto (Œª n, ‚à•d n‚à•) l (ùìù 0) := tendsto.congr' this C
rw tendsto_zero_iff_norm_tendsto_zero
exact D
rintros _ ‚ü®v, ‚ü®c, d, hd, hc, hy‚ü©, rfl‚ü©
have : ‚àÄn, ‚àÉd', y + d' ‚àà t ‚àß ‚à•c n ‚Ä¢ d'‚à• < ((1:‚Ñù)/2)^n
assume n
rcases mem_closure_iff_nhds.1 ht _ (eventually_nhds_norm_smul_sub_lt (c n) y (pow_pos one_half_pos n)) with ‚ü®z, hz, hzt‚ü©
simpa using hzt
simpa using hz
{ assume n, rcases mem_closure_iff_nhds.1 ht _ (eventually_nhds_norm_smul_sub_lt (c n) y (pow_pos one_half_pos n)) with ‚ü®z, hz, hzt‚ü©, exact ‚ü®z - y, by simpa using hzt, by simpa using hz‚ü© }
exact ‚ü®z - y, by simpa using hzt, by simpa using hz‚ü©
choose d' hd' using this
refine ‚ü®c, Œªn, (d n, d' n), _, hc, _‚ü©
show ‚àÄ·∂† n in at_top, (x, y) + (d n, d' n) ‚àà set.prod s t
filter_upwards [hd]
assume n hn
{ filter_upwards [hd], assume n hn, simp [hn, (hd' n).1] }
simp [hn, (hd' n).1]
apply tendsto.prod_mk_nhds hy _
refine squeeze_zero_norm (Œªn, (hd' n).2.le) _
exact tendsto_pow_at_top_nhds_0_of_lt_1 one_half_pos.le one_half_lt_one
rintros _ ‚ü®w, ‚ü®c, d, hd, hc, hy‚ü©, rfl‚ü©
have : ‚àÄn, ‚àÉd', x + d' ‚àà s ‚àß ‚à•c n ‚Ä¢ d'‚à• < ((1:‚Ñù)/2)^n
assume n
rcases mem_closure_iff_nhds.1 hs _ (eventually_nhds_norm_smul_sub_lt (c n) x (pow_pos one_half_pos n)) with ‚ü®z, hz, hzs‚ü©
simpa using hzs
simpa using hz
{ assume n, rcases mem_closure_iff_nhds.1 hs _ (eventually_nhds_norm_smul_sub_lt (c n) x (pow_pos one_half_pos n)) with ‚ü®z, hz, hzs‚ü©, exact ‚ü®z - x, by simpa using hzs, by simpa using hz‚ü© }
exact ‚ü®z - x, by simpa using hzs, by simpa using hz‚ü©
choose d' hd' using this
refine ‚ü®c, Œªn, (d' n, d n), _, hc, _‚ü©
show ‚àÄ·∂† n in at_top, (x, y) + (d' n, d n) ‚àà set.prod s t
filter_upwards [hd]
assume n hn
{ filter_upwards [hd], assume n hn, simp [hn, (hd' n).1] }
simp [hn, (hd' n).1]
apply tendsto.prod_mk_nhds _ hy
refine squeeze_zero_norm (Œªn, (hd' n).2.le) _
exact tendsto_pow_at_top_nhds_0_of_lt_1 one_half_pos.le one_half_lt_one
classical
rw [‚Üê set.univ_pi_piecewise]
refine unique_diff_within_at.univ_pi _ _ _ _ (Œª i, _)
by_cases hi : i ‚àà I; simp [*, unique_diff_within_at_univ]
simp [*, unique_diff_within_at_univ]
simp [*, unique_diff_within_at_univ]
by_cases hi : i ‚àà I
simp [has_ftaylor_series_up_to_on_succ_iff_right, has_ftaylor_series_up_to_on_univ_iff.symm, -add_comm, -with_zero.coe_add]
simpa [nhds_within_univ] using h.eventually
split
assume H
use ftaylor_series_within ùïú f univ
rw ‚Üê has_ftaylor_series_up_to_on_univ_iff
{ assume H, use ftaylor_series_within ùïú f univ, rw ‚Üê has_ftaylor_series_up_to_on_univ_iff, exact H.ftaylor_series_within unique_diff_on_univ }
exact H.ftaylor_series_within unique_diff_on_univ
rintros ‚ü®p, hp‚ü© x hx m hm
exact ‚ü®univ, filter.univ_sets _, p, (hp.has_ftaylor_series_up_to_on univ).of_le hm‚ü©
rw iterated_fderiv_succ_apply_right
refl
ext m
simp [times_cont_diff_on_univ.symm, differentiable_on_univ.symm, fderiv_within_univ.symm, - fderiv_within_univ, times_cont_diff_on_succ_iff_fderiv_within unique_diff_on_univ, -with_zero.coe_add, -add_comm]
exact times_cont_diff_at_const
rw [subsingleton.elim f (Œª _, 0)]
exact times_cont_diff_on_const
rw [subsingleton.elim f (Œª _, 0)]
simpa only [div_eq_mul_inv] using hf.mul times_cont_diff_within_at_const
rw times_cont_diff_at at *
convert hf.prod_map hg
simp only [univ_prod_univ]
rw coe_inv_circle_eq_conj
apply eq_inv_of_mul_right_eq_one
rw [mul_comm, ‚Üê complex.norm_sq_eq_conj_mul_self]
simp
have h‚ÇÅ := f.norm_map z
simp only [complex.abs, norm_eq_abs] at h‚ÇÅ
rwa [real.sqrt_inj (norm_sq_nonneg _) (norm_sq_nonneg _), norm_sq_apply (f z), norm_sq_apply z, h‚ÇÇ, add_left_cancel_iff, mul_self_eq_mul_self_iff] at h‚ÇÅ
rw is_primitive_root.iff_def
simp only [‚Üê exp_nat_mul, exp_eq_one_iff]
exact_mod_cast h0
have hn0 : (n : ‚ÑÇ) ‚â† 0
split
use i
{ use i, field_simp [hn0, mul_comm (i : ‚ÑÇ), mul_comm (n : ‚ÑÇ)] }
field_simp [hn0, mul_comm (i : ‚ÑÇ), mul_comm (n : ‚ÑÇ)]
simp only [hn0, mul_right_comm _ _ ‚Üën, mul_left_inj' two_pi_I_ne_zero, ne.def, not_false_iff, mul_comm _ (i : ‚ÑÇ), ‚Üê mul_assoc _ (i : ‚ÑÇ), exists_imp_distrib] with field_simps
norm_cast
rintro l k hk
have : n ‚à£ i * l
apply dvd_mul_left
{ rw [‚Üê int.coe_nat_dvd, hk], apply dvd_mul_left }
rw [‚Üê int.coe_nat_dvd, hk]
exact hi.symm.dvd_of_dvd_mul_left this
intros x y hx hy a b ha hb hab
have h := hs hx hy ha hb hab
rwa [smul_add, smul_add, add_add_add_comm, ‚Üêadd_smul, hab, one_smul] at h
simpa only [add_comm] using hs.translate_preimage_right z
obtain rfl | hB := B.eq_empty_or_nonempty
{ exact convex_empty }
exact convex_empty
obtain ‚ü®l, rfl‚ü© := hAB hB
exact Œª x‚ÇÅ x‚ÇÇ hx‚ÇÅ hx‚ÇÇ a b ha hb hab, ‚ü®hA hx‚ÇÅ.1 hx‚ÇÇ.1 ha hb hab, Œª y hy, ((l.to_linear_map.concave_on convex_univ).concave_ge _ ‚ü®mem_univ _, hx‚ÇÅ.2 y hy‚ü© ‚ü®mem_univ _, hx‚ÇÇ.2 y hy‚ü© ha hb hab).2‚ü©
use subset.trans hBC.1 hAB.1
rintro x‚ÇÅ x‚ÇÇ hx‚ÇÅA hx‚ÇÇA x hxC hx
obtain ‚ü®hx‚ÇÅB, hx‚ÇÇB‚ü© := hAB.2 x‚ÇÅ x‚ÇÇ hx‚ÇÅA hx‚ÇÇA x (hBC.1 hxC) hx
exact hBC.2 x‚ÇÅ x‚ÇÇ hx‚ÇÅB hx‚ÇÇB x hxC hx
simpa only [add_comm] using hf.translate_right
obtain ‚ü®a, b, ha, hb, hab, rfl‚ü© := hz
exact hf.le_left_of_right_le' hx hy ha hb.le hab hyz
intros x y hxy
refine ‚ü®_, ‚ü®fourier 1, _, rfl‚ü©, _‚ü©
{ exact subset_adjoin ‚ü®1, rfl‚ü© }
exact subset_adjoin ‚ü®1, rfl‚ü©
simp [hxy]
rw orthonormal_iff_ite
intros i j
rw continuous_map.inner_to_Lp haar_circle (fourier i) (fourier j)
split_ifs
simp [h, is_probability_measure.measure_univ, ‚Üê fourier_neg, ‚Üê fourier_add, -fourier_to_fun]
{ simp [h, is_probability_measure.measure_univ, ‚Üê fourier_neg, ‚Üê fourier_add, -fourier_to_fun] }
simp only [‚Üê fourier_add, ‚Üê fourier_neg, is_R_or_C.conj_to_complex]
have hij : -i + j ‚â† 0
rw add_comm
{ rw add_comm, exact sub_ne_zero.mpr (ne.symm h) }
exact sub_ne_zero.mpr (ne.symm h)
exact integral_zero_of_mul_left_eq_neg (is_mul_left_invariant_haar_measure _) (fourier_add_half_inv_index hij)
simp [fpow_add (nonzero_of_mem_circle z)]
simp [norm_eq_zero, hx]
have hx' : ‚à•x‚à• ‚â† 0 := by simp [norm_eq_zero, hx]
simp [is_R_or_C.abs_eq_zero, hr]
have hr' : abs r ‚â† 0 := by simp [is_R_or_C.abs_eq_zero, hr]
rw [inner_smul_right, is_R_or_C.abs_mul, ‚Üêinner_self_re_abs, inner_self_eq_norm_sq, norm_smul]
rw [is_R_or_C.norm_eq_abs, ‚Üêmul_assoc, ‚Üêdiv_div_eq_div_mul, mul_div_cancel _ hx', ‚Üêdiv_div_eq_div_mul, mul_comm, mul_div_cancel _ hr', div_self hx']
have H : ‚à•x‚à• * ‚à•y‚à• * (‚à•x‚à• * ‚à•y‚à•) = re ‚ü™y, y‚ü´ * re ‚ü™x, x‚ü´
ring
{ simp only [inner_self_eq_norm_sq], ring, }
simp only [inner_self_eq_norm_sq]
rw H
conv begin to_lhs, congr, rw[inner_abs_conj_sym], end
congr
rw[inner_abs_conj_sym]
to_lhs
exact inner_mul_inner_self_le y x
rw [‚Üê zero_smul ùïú (0:E), inner_smul_left, ring_hom.map_zero, zero_mul]
assume h
have h : ‚àÄ w ‚àà K, ‚ü™u - v, w - v‚ü´_‚Ñù ‚â§ 0
exacts [K.convex, hv]
rwa [norm_eq_infi_iff_real_inner_le_zero] at h
{ rwa [norm_eq_infi_iff_real_inner_le_zero] at h, exacts [K.convex, hv] }
assume w hw
have le : ‚ü™u - v, w‚ü´_‚Ñù ‚â§ 0
let w' := w + v
have : w' ‚àà K := submodule.add_mem _ hw hv
have h‚ÇÅ := h w' this
simp only [add_neg_cancel_right, sub_eq_add_neg]
have h‚ÇÇ : w' - v = w
exact h‚ÇÅ
rw h‚ÇÇ at h‚ÇÅ
have ge : ‚ü™u - v, w‚ü´_‚Ñù ‚â• 0
let w'' := -w + v
have : w'' ‚àà K := submodule.add_mem _ (submodule.neg_mem _ hw) hv
have h‚ÇÅ := h w'' this
simp only [neg_inj, add_neg_cancel_right, sub_eq_add_neg]
have h‚ÇÇ : w'' - v = -w
rw [h‚ÇÇ, inner_neg_right] at h‚ÇÅ
linarith
exact le_antisymm le ge
assume h
have : ‚àÄ w ‚àà K, ‚ü™u - v, w - v‚ü´_‚Ñù ‚â§ 0
assume w hw
let w' := w - v
have : w' ‚àà K := submodule.sub_mem _ hw hv
have h‚ÇÅ := h w' this
exact le_of_eq h‚ÇÅ
rwa norm_eq_infi_iff_real_inner_le_zero
exacts [submodule.convex _, hv]
simp [hv]
rw ‚Üê smul_orthogonal_projection_singleton ùïú w
convert inner_le_Lp_mul_Lq s f g hpq using 3; apply sum_congr rfl; intros i hi; simp only [abs_of_nonneg, hf i hi, hg i hi]
convert inner_le_Lp_mul_Lq s f g hpq using 3; apply sum_congr rfl; intros i hi
convert inner_le_Lp_mul_Lq s f g hpq using 3; apply sum_congr rfl
convert inner_le_Lp_mul_Lq s f g hpq using 3
apply sum_congr rfl
apply sum_congr rfl
intros i hi
intros i hi
simp only [abs_of_nonneg, hf i hi, hg i hi]
simp only [abs_of_nonneg, hf i hi, hg i hi]
have hp_pos : 0 < p := lt_of_lt_of_le zero_lt_one hp1
by_cases h_top : a + b = ‚ä§
rw ‚Üê@ennreal.rpow_eq_top_iff_of_pos (a + b) p hp_pos at h_top
rw h_top
{ rw ‚Üê@ennreal.rpow_eq_top_iff_of_pos (a + b) p hp_pos at h_top, rw h_top, exact le_top, }
exact le_top
obtain ‚ü®ha_top, hb_top‚ü© := add_ne_top.mp h_top
by_cases h_zero : a + b = 0
simp [add_eq_zero_iff.mp h_zero, ennreal.zero_rpow_of_pos hp_pos]
{ simp [add_eq_zero_iff.mp h_zero, ennreal.zero_rpow_of_pos hp_pos], }
have h_nonzero : ¬¨(a = 0 ‚àß b = 0)
rwa add_eq_zero_iff at h_zero
have h_add : a/(a+b) + b/(a+b) = 1
rw [div_add_div_same, div_self h_zero h_top]
have h := add_rpow_le_one_of_add_le_one (a/(a+b)) (b/(a+b)) h_add.le hp1
rw [div_rpow_of_nonneg a (a+b) hp_pos.le, div_rpow_of_nonneg b (a+b) hp_pos.le] at h
simp [ha_top, hb_top, hp_pos, h_nonzero]
have hab_0 : (a + b)^p ‚â† 0
simp [ha_top, hb_top, hp_pos, h_nonzero]
have hab_top : (a + b)^p ‚â† ‚ä§
have h_mul : (a + b)^p * (a ^ p / (a + b) ^ p + b ^ p / (a + b) ^ p) ‚â§ (a + b)^p
nth_rewrite 3 ‚Üêmul_one ((a + b)^p)
{ nth_rewrite 3 ‚Üêmul_one ((a + b)^p), exact (mul_le_mul_left hab_0 hab_top).mpr h, }
exact (mul_le_mul_left hab_0 hab_top).mpr h
rwa [div_eq_mul_inv, div_eq_mul_inv, mul_add, mul_comm (a^p), mul_comm (b^p), ‚Üêmul_assoc, ‚Üêmul_assoc, mul_inv_cancel hab_0 hab_top, one_mul, one_mul] at h_mul
apply (is_colimit_cokernel_cocone f).uniq (cofork.of_œÄ g (by simp [w]))
simp [w]
rintro (_|_)
convert w.symm
{ convert w.symm, simp }
simp
exact he
fsplit
apply normed_group_hom.lift _ s.œÄ.1
rintro _ ‚ü®b, rfl‚ü©
change (f ‚â´ s.œÄ) b = 0
{ apply normed_group_hom.lift _ s.œÄ.1, rintro _ ‚ü®b, rfl‚ü©, change (f ‚â´ s.œÄ) b = 0, simp, }
simp
exact normed_group_hom.lift_norm_noninc _ _ _ s.œÄ.2
simp [homothety_def, norm_smul, ‚Üê dist_eq_norm_vsub, dist_comm]
rw [dist_eq_norm_vsub V, dist_eq_norm_vsub V, dist_eq_norm_vsub V, midpoint_vsub_midpoint]
rw [dist_eq_norm_vsub V, dist_eq_norm_vsub V, dist_eq_norm_vsub V, midpoint_vsub_midpoint]; try { apply_instance }
apply_instance
try { apply_instance }
try { apply_instance }
rw [midpoint_eq_smul_add, norm_smul, inv_of_eq_inv, normed_field.norm_inv, ‚Üê div_eq_inv_mul]
exact div_le_div_of_le_of_nonneg (norm_add_le _ _) (norm_nonneg _)
rw [summable_iff_cauchy_seq_finset, cauchy_seq_finset_iff_vanishing_norm]
simp only [‚Üê nnreal.coe_le_coe, ‚Üê nnreal.has_sum_coe, coe_nnnorm] at *
exact tsum_of_norm_bounded hg h
intros x y
apply completion.induction_on‚ÇÇ x y; clear x y
clear x y
clear x y
apply completion.induction_on‚ÇÇ x y
refine is_closed_eq (completion.uniform_continuous_extension‚ÇÇ _).continuous _
{ refine is_closed_eq (completion.uniform_continuous_extension‚ÇÇ _).continuous _, exact continuous.comp completion.continuous_extension continuous_sub }
exact continuous.comp completion.continuous_extension continuous_sub
intros x y
rw [‚Üê completion.coe_sub, norm_coe, metric.completion.dist_eq, dist_eq_norm]
apply_instance
apply_instance
simp [dist_eq_norm]
refine is_linear_map.with_bound ‚ü®Œª f‚ÇÅ f‚ÇÇ, by { ext m, refl }, Œª c f, by { ext m, refl }‚ü© (‚à•g‚à• ^ (fintype.card Œπ)) (Œª f, _)
ext m
refl
ext m
refl
apply continuous_multilinear_map.op_norm_le_bound _ _ (Œª m, _)
{ apply_rules [mul_nonneg, pow_nonneg, norm_nonneg] }
apply_rules [mul_nonneg, pow_nonneg, norm_nonneg]
calc ‚à•f (g ‚àò m)‚à• ‚â§ ‚à•f‚à• * ‚àè i, ‚à•g (m i)‚à• : f.le_op_norm _ ... ‚â§ ‚à•f‚à• * ‚àè i, (‚à•g‚à• * ‚à•m i‚à•) : begin apply mul_le_mul_of_nonneg_left _ (norm_nonneg _), exact finset.prod_le_prod (Œª i hi, norm_nonneg _) (Œª i hi, g.le_op_norm _) end ... = ‚à•g‚à• ^ fintype.card Œπ * ‚à•f‚à• * ‚àè i, ‚à•m i‚à• : by { simp [finset.prod_mul_distrib, finset.card_univ], ring }
apply mul_le_mul_of_nonneg_left _ (norm_nonneg _)
exact finset.prod_le_prod (Œª i hi, norm_nonneg _) (Œª i hi, g.le_op_norm _)
simp [finset.prod_mul_distrib, finset.card_univ]
ring
rw [f.map_add, continuous_linear_map.add_apply]
rw [f.map_smul _, continuous_linear_map.smul_apply]
apply_rules [mul_le_mul_of_nonneg_right, norm_nonneg, le_max_left]
simp only [hf', pi.smul_def]
simp only [hf', pi.smul_def]; exact (smul_right_injective _ hc).comp li.injective
exact (smul_right_injective _ hc).comp li.injective
simp [finite_norm_eq, ennreal.to_real_mul]
refine funext (Œª x, _)
rw [real.exp, complex.exp_eq_exp_‚ÑÇ_‚ÑÇ, ‚Üê exp_‚Ñù_‚ÑÇ_eq_exp_‚ÑÇ_‚ÑÇ, exp_eq_tsum, exp_eq_tsum_field, ‚Üê re_to_complex, ‚Üê re_clm_apply, re_clm.map_tsum (exp_series_summable' (x : ‚ÑÇ))]
refine tsum_congr (Œª n, _)
rw [re_clm.map_smul, ‚Üê complex.of_real_pow, re_clm_apply, re_to_complex, complex.of_real_re, smul_eq_mul, one_div, mul_comm, div_eq_mul_inv]
set e := continuous_linear_equiv.of_finrank_eq (@finrank_fin_fun ùïú _ (finrank ùïú E)).symm
exact e.symm.antilipschitz.proper_space e.symm.continuous e.symm.surjective
have : x = 0 := subsingleton.elim _ _
subst this
simpa using f.le_op_norm 0
refine le_antisymm (by simpa using f.le_op_norm 0) _
have : ‚à•continuous_multilinear_map.curry0 ùïú G (f.uncurry0)‚à• ‚â§ ‚à•f.uncurry0‚à• := continuous_multilinear_map.op_norm_le_bound _ (norm_nonneg _) (Œªm, by simp [-continuous_multilinear_map.apply_zero_curry0])
simp [-continuous_multilinear_map.apply_zero_curry0]
simpa
simpa only [prod_apply, prod.norm_def, max_mul_of_nonneg, H] using max_le_max (f.le_op_norm m) (g.le_op_norm m)
refine (continuous_multilinear_map.pi_field_equiv_aux ùïú Œπ G).to_linear_map.continuous_of_bound (1 : ‚Ñù) (Œªz, _)
rw one_mul
change ‚à•continuous_multilinear_map.mk_pi_field ùïú Œπ z‚à• ‚â§ ‚à•z‚à•
exact multilinear_map.mk_continuous_norm_le _ (norm_nonneg _) _
refine (continuous_multilinear_map.pi_field_equiv_aux ùïú Œπ G).symm.to_linear_map.continuous_of_bound (1 : ‚Ñù) (Œªf, _)
rw one_mul
change ‚à•f (Œªi, 1)‚à• ‚â§ ‚à•f‚à•
apply @continuous_multilinear_map.unit_le_op_norm ùïú Œπ (Œª (i : Œπ), ùïú) G _ _ _ _ _ _ _ f
simp [pi_norm_le_iff zero_le_one, le_refl]
rw [comp_assoc, hf, ‚Üê comp_assoc, hf', comp_assoc]
rintro rfl x
rintro rfl x; refl
refl
refine le_antisymm _ _
apply op_norm_le_bound _ (mul_nonneg (norm_nonneg _) (norm_nonneg _)) (Œªx, _)
calc ‚à•(c x) ‚Ä¢ f‚à• = ‚à•c x‚à• * ‚à•f‚à• : norm_smul _ _ ... ‚â§ (‚à•c‚à• * ‚à•x‚à•) * ‚à•f‚à• : mul_le_mul_of_nonneg_right (le_op_norm _ _) (norm_nonneg _) ... = ‚à•c‚à• * ‚à•f‚à• * ‚à•x‚à• : by ring
ring
{ apply op_norm_le_bound _ (mul_nonneg (norm_nonneg _) (norm_nonneg _)) (Œªx, _), calc ‚à•(c x) ‚Ä¢ f‚à• = ‚à•c x‚à• * ‚à•f‚à• : norm_smul _ _ ... ‚â§ (‚à•c‚à• * ‚à•x‚à•) * ‚à•f‚à• : mul_le_mul_of_nonneg_right (le_op_norm _ _) (norm_nonneg _) ... = ‚à•c‚à• * ‚à•f‚à• * ‚à•x‚à• : by ring }
by_cases h : f = 0
{ simp [h] }
simp [h]
have : 0 < ‚à•f‚à• := norm_pos_iff.2 h
rw ‚Üê le_div_iff this
apply op_norm_le_bound _ (div_nonneg (norm_nonneg _) (norm_nonneg f)) (Œªx, _)
rw [div_mul_eq_mul_div, le_div_iff this]
calc ‚à•c x‚à• * ‚à•f‚à• = ‚à•c x ‚Ä¢ f‚à• : (norm_smul _ _).symm ... = ‚à•smul_right c f x‚à• : rfl ... ‚â§ ‚à•smul_right c f‚à• * ‚à•x‚à• : le_op_norm _ _
haveI := normed_algebra.nontrivial ùïú ùïú'; exact (lmul‚Çó·µ¢ ùïú ùïú').norm_to_continuous_linear_map
exact (lmul‚Çó·µ¢ ùïú ùïú').norm_to_continuous_linear_map
haveI := normed_algebra.nontrivial ùïú ùïú'
exact norm_smul _ _
rw mul_comm
obtain ‚ü®x, hx‚ü© : ‚àÉ (x : E), x ‚â† 0 := exists_ne 0
rw ‚Üê norm_pos_iff at hx
simpa only [hf, hx, zero_le_mul_right] using norm_nonneg (f x)
have ha : 0 ‚â§ a
apply le_antisymm (f.op_norm_le_bound ha (Œª y, le_of_eq (hf y)))
simpa only [hf, hx, mul_le_mul_right] using f.le_op_norm x
simp [inner_def, mul_comm]
simp only [inner_def, add_mul, add_re]
simp [inner_def]
simp; exact real.cos_nonneg_of_mem_Icc hx‚ÇÉ
exact real.cos_nonneg_of_mem_Icc hx‚ÇÉ
simp
rw [arg, if_pos hx‚ÇÑ]; simp [abs_cos_add_sin_mul_I, sin_of_real_re, real.arcsin_sin hx‚ÇÉ.1 hx‚ÇÉ.2]
rw [arg, if_pos hx‚ÇÑ]
simp [abs_cos_add_sin_mul_I, sin_of_real_re, real.arcsin_sin hx‚ÇÉ.1 hx‚ÇÉ.2]
simpa
rw ‚Üê real.cos_neg
rw ‚Üê real.cos_neg; apply real.cos_neg_of_pi_div_two_lt_of_lt; linarith
rw ‚Üê real.cos_neg; apply real.cos_neg_of_pi_div_two_lt_of_lt
linarith
linarith
apply real.cos_neg_of_pi_div_two_lt_of_lt
simpa
apply real.sin_neg_of_neg_of_neg_pi_lt; linarith
linarith
linarith
apply real.sin_neg_of_neg_of_neg_pi_lt
rw [arg, if_neg hx‚ÇÖ, if_neg hx‚ÇÜ]; simpa [sub_eq_add_neg, add_comm, abs_cos_add_sin_mul_I, sin_of_real_re]
rw [arg, if_neg hx‚ÇÖ, if_neg hx‚ÇÜ]
simpa [sub_eq_add_neg, add_comm, abs_cos_add_sin_mul_I, sin_of_real_re]
rw [‚Üê real.arcsin_neg, ‚Üê real.sin_add_pi, real.arcsin_sin]; try {simp [add_left_comm]}; linarith
rw [‚Üê real.arcsin_neg, ‚Üê real.sin_add_pi, real.arcsin_sin]; try {simp [add_left_comm]}
try {simp [add_left_comm]}
try {simp [add_left_comm]}
try {simp [add_left_comm]}
rw [‚Üê real.arcsin_neg, ‚Üê real.sin_add_pi, real.arcsin_sin]
simp [add_left_comm]
linarith
linarith
cases not_and_distrib.1 hx‚ÇÉ
cases not_and_distrib.1 hx‚ÇÉ; linarith
linarith
linarith
simpa
apply real.cos_neg_of_pi_div_two_lt_of_lt
apply real.cos_neg_of_pi_div_two_lt_of_lt; linarith
linarith
linarith
simpa
apply real.sin_nonneg_of_nonneg_of_le_pi; linarith
linarith
linarith
apply real.sin_nonneg_of_nonneg_of_le_pi
rw [arg, if_neg hx‚ÇÜ, if_pos hx‚Çá]; simpa [sub_eq_add_neg, add_comm, abs_cos_add_sin_mul_I, sin_of_real_re]
rw [arg, if_neg hx‚ÇÜ, if_pos hx‚Çá]
simpa [sub_eq_add_neg, add_comm, abs_cos_add_sin_mul_I, sin_of_real_re]
rw [‚Üê real.sin_pi_sub, real.arcsin_sin]; simp [sub_eq_add_neg]; linarith
rw [‚Üê real.sin_pi_sub, real.arcsin_sin]; simp [sub_eq_add_neg]
simp [sub_eq_add_neg]
simp [sub_eq_add_neg]
simp [sub_eq_add_neg]
rw [‚Üê real.sin_pi_sub, real.arcsin_sin]
linarith
linarith
simp [arg, zero_le_one]
have H : ‚àÄ d e, 0 < d ‚Üí tendsto (Œª (x:‚Ñù), x^n / (d * (exp x) + e)) at_top (ùìù 0)
intros b' c' h
convert (tendsto_mul_exp_add_div_pow_at_top b' c' n h hn).inv_tendsto_at_top
ext x
{ intros b' c' h, convert (tendsto_mul_exp_add_div_pow_at_top b' c' n h hn).inv_tendsto_at_top , ext x, simpa only [pi.inv_apply] using inv_div.symm }
simpa only [pi.inv_apply] using inv_div.symm
cases lt_or_gt_of_ne hb
{ exact H b c h }
exact H b c h
convert (H (-b) (-c) (neg_pos.mpr h)).neg
ext x
field_simp
{ ext x, field_simp, rw [‚Üê neg_add (b * exp x) c, neg_div_neg_eq] }
rw [‚Üê neg_add (b * exp x) c, neg_div_neg_eq]
exact neg_zero.symm
by_cases h : 0 ‚â§ P.leading_coeff/Q.leading_coeff
exact tendsto_abs_at_top_at_top.comp (P.div_tendsto_at_top_of_degree_gt Q hdeg hQ h)
{ exact tendsto_abs_at_top_at_top.comp (P.div_tendsto_at_top_of_degree_gt Q hdeg hQ h) }
push_neg at h
exact tendsto_abs_at_bot_at_top.comp (P.div_tendsto_at_bot_of_degree_gt Q hdeg hQ h.le)
rw [‚Üêreal.log_lt_log_iff hx (real.rpow_pos_of_pos hy z), real.log_rpow hy]
simpa only [(‚àò), div_eq_inv_mul, mul_one] using (has_deriv_at_sqrt hx).comp_has_deriv_within_at x hf
simp
have : (2 : ‚Ñù) ‚â† 0 := two_ne_zero
rw [div_eq_iff_mul_eq this]
symmetry
symmetry
rw [sqrt_two_add_series, sqrt_eq_iff_sq_eq, mul_pow, cos_sq, ‚Üêmul_div_assoc, nat.add_succ, pow_succ, mul_div_mul_left _ _ this, cos_pi_over_two_pow, add_mul]
norm_num
{ norm_num }
congr
rw [mul_comm, sq, mul_assoc, ‚Üêmul_div_assoc, mul_div_cancel_left, ‚Üêmul_div_assoc, mul_div_cancel_left]
rw [mul_comm, sq, mul_assoc, ‚Üêmul_div_assoc, mul_div_cancel_left, ‚Üêmul_div_assoc, mul_div_cancel_left]; try { exact this }
try { exact this }
exact this
norm_num
apply sqrt_two_add_series_zero_nonneg
apply add_nonneg
norm_num
apply cos_pos_of_mem_Ioo ‚ü®_, _‚ü©
apply le_of_lt
rw neg_lt_zero
apply pi_div_two_pos
transitivity (0 : ‚Ñù)
apply pow_pos
norm_num
{ transitivity (0 : ‚Ñù), rw neg_lt_zero, apply pi_div_two_pos, apply div_pos pi_pos, apply pow_pos, norm_num }
apply div_pos pi_pos
apply div_lt_div' (le_refl œÄ) _ pi_pos _
refine lt_of_le_of_lt (le_of_eq (pow_one _).symm) _
norm_num
apply nat.succ_lt_succ
apply nat.succ_pos
apply pow_lt_pow
all_goals {norm_num}
congr
norm_num
simp
transitivity sin (œÄ / 2 ^ 2)
congr
norm_num
simp
transitivity cos (œÄ / 2 ^ 4)
rcases em (x = -1) with (rfl|h')
convert (has_deriv_within_at_const _ _ (-(œÄ / 2))).congr _ _
convert (has_deriv_within_at_const _ _ (-(œÄ / 2))).congr _ _; simp [arcsin_of_le_neg_one] { contextual := tt }
{ convert (has_deriv_within_at_const _ _ (-(œÄ / 2))).congr _ _; simp [arcsin_of_le_neg_one] { contextual := tt } }
simp [arcsin_of_le_neg_one] { contextual := tt }
simp [arcsin_of_le_neg_one] { contextual := tt }
simp [arcsin_of_le_neg_one] { contextual := tt }
exact (has_deriv_at_arcsin h' h).has_deriv_within_at
simpa only [pow_zero, div_eq_mul_inv, ennreal.inv_one, mul_one] using edist_le_of_edist_le_geometric_two_of_tendsto C hu ha 0
simp [dist_eq_norm, sum_range_succ]
refine summable_of_nonneg_of_le (Œª a, one_div_nonneg.mpr (pow_nonneg (zero_le_one.trans hm.le) _)) (Œª a, _) (summable_geometric_of_lt_1 (one_div_nonneg.mpr (zero_le_one.trans hm.le)) ((one_div_lt (zero_lt_one.trans hm) zero_lt_one).mpr (one_div_one.le.trans_lt hm)))
rw [div_pow, one_pow]
refine (one_div_le_one_div _ _).mpr (pow_le_pow hm.le (fi a))
refine (one_div_le_one_div _ _).mpr (pow_le_pow hm.le (fi a)); exact pow_pos (zero_lt_one.trans hm) _
exact pow_pos (zero_lt_one.trans hm) _
exact pow_pos (zero_lt_one.trans hm) _
apply_instance
rw [add_def, comp_sub, neg_def, comp_sub, comp_zero, add_def, neg_def]
rw ‚Üêhp at hpbar
exact hpbar
dsimp at comm
rw [category.assoc, comm]
apply category.comp_id
dsimp
ext x f
apply L.map_injective
simp
dsimp
ext x f
simp only [adjunction.hom_equiv_counit, preimage_comp, preimage_map, category.assoc]
rw ‚Üêh.unit_naturality
simp
let := adjunction.right_adjoint_of_nat_iso comm
exactI adjoint_triangle_lift Q (adjunction.of_right_adjoint V)
erw [‚Üê adj.hom_equiv_naturality_right_symm, ‚Üê t.naturality, category.id_comp, category.id_comp]
apply functor.ext
tidy
apply functor.ext
tidy
cases h
refl
cases h
rw [uncurry_eq, prod_map_pre_app_comp_ev]
rw [pre, pre, pre, transfer_nat_trans_self_comp, prod.functor.map_comp]
apply_instance
rw ‚Üê frobenius_morphism_mate F h
cases G with G_obj _ _ _
cases F with F_obj _ _ _
ext X
ext X; apply h_obj
apply h_obj
have : F_obj = G_obj
subst this
congr
funext X Y f
exact eq_of_heq (h_map X Y f)
cases p; simp
simp
cases p
simp only [cancel_mono]
classical
let O := (finset.univ.image F.obj)
let H : finset (Œ£' (X Y : C) (mX : X ‚àà O) (mY : Y ‚àà O), X ‚ü∂ Y) := finset.univ.bUnion (Œª X : J, finset.univ.bUnion (Œª Y : J, finset.univ.image (Œª f : X ‚ü∂ Y, ‚ü®F.obj X, F.obj Y, by simp, by simp, F.map f‚ü©)))
simp
simp
obtain ‚ü®Z, f, w‚ü© := sup_exists O H
simp
refine ‚ü®‚ü®Z, ‚ü®Œª X, f (by simp), _‚ü©‚ü©‚ü©
intros j j' g
dsimp
simp only [category.comp_id]
apply w
simp only [finset.mem_univ, finset.mem_bUnion, exists_and_distrib_left, exists_prop_of_true, finset.mem_image]
simp
exact ‚ü®j, rfl, j', g, (by simp)‚ü©
simp [‚Üênat_iso.naturality_1 Œ±]
ext X
rw [‚Üêcancel_mono (Œ±.app X), ‚Üêcomp_app, eq, comp_app]
simp
simp
subst h
dsimp
simp
subst h
simp
have w := h {j | F j = F j‚ÇÄ} rfl (Œª _ _ f, by simp [a f])
simp [a f]
dsimp at w
intros j j'
rw [w j, w j']
have z : ‚àÄ (j : J), r (classical.arbitrary J) j := induct_on_objects (Œª k, r (classical.arbitrary J) k) (hr.1 (classical.arbitrary J)) (Œª _ _ f, ‚ü®Œª t, hr.2.2 t (h f), Œª t, hr.2.2 t (hr.2.1 (h f))‚ü©)
apply hr.2.2 (hr.2.1 (z _)) (z _)
intros
ext j
apply nat_trans_from_is_connected f (classical.arbitrary J) j
apply c.w (wide_pullback_shape.hom.term j)
refine ‚ü®j, rfl, _‚ü©
simp only [heq_iff_eq]
exact ‚ü®rfl, rfl, rfl‚ü©
have gH : ‚àÄ j, (‚ü®ky, k j, kyO, kjO j, g j‚ü© : (Œ£' (X Y : K) (mX : X ‚àà O) (mY : Y ‚àà O), X ‚ü∂ Y)) ‚àà H := Œª j, (finset.mem_union.mpr (or.inr begin simp only [true_and, finset.mem_univ, eq_self_iff_true, exists_prop_of_true, finset.mem_image, heq_iff_eq], refine ‚ü®j, rfl, _‚ü©, simp only [heq_iff_eq], exact ‚ü®rfl, rfl, rfl‚ü©, end))
simp only [true_and, finset.mem_univ, eq_self_iff_true, exists_prop_of_true, finset.mem_image, heq_iff_eq]
refine ‚ü®j, rfl, _‚ü©
simp only [heq_iff_eq]
exact ‚ü®rfl, rfl, rfl‚ü©
apply colimit_sound' (T kxO) (T kyO)
ext
simp only [functor.comp_map, limit.map_œÄ_apply, curry.obj_map_app, swap_map]
rw ‚ÜêW _ _ (fH j)
rw ‚ÜêW _ _ (gH j)
simp [w]
classical
intros x y h
obtain ‚ü®kx, x, rfl‚ü© := jointly_surjective' x
obtain ‚ü®ky, y, rfl‚ü© := jointly_surjective' y
dsimp at x y
replace h := Œª j, congr_arg (limit.œÄ ((curry.obj F) ‚ãô colim) j) h
simp [colimit_eq_iff] at h
let k := Œª j, (h j).some
let f : Œ† j, kx ‚ü∂ k j := Œª j, (h j).some_spec.some
let g : Œ† j, ky ‚ü∂ k j := Œª j, (h j).some_spec.some_spec.some
have w : Œ† j, F.map ((ùüô j, f j) : (j, kx) ‚ü∂ (j, k j)) (limit.œÄ ((curry.obj (swap K J ‚ãô F)).obj kx) j x) = F.map ((ùüô j, g j) : (j, ky) ‚ü∂ (j, k j)) (limit.œÄ ((curry.obj (swap K J ‚ãô F)).obj ky) j y) := Œª j, (h j).some_spec.some_spec.some_spec
let O : finset K := (finset.univ).image k ‚à™ {kx, ky}
have kxO : kx ‚àà O := finset.mem_union.mpr (or.inr (by simp))
simp
have kyO : ky ‚àà O := finset.mem_union.mpr (or.inr (by simp))
simp
have kjO : ‚àÄ j, k j ‚àà O := Œª j, finset.mem_union.mpr (or.inl (by simp))
simp
let H : finset (Œ£' (X Y : K) (mX : X ‚àà O) (mY : Y ‚àà O), X ‚ü∂ Y) := (finset.univ).image (Œª j : J, ‚ü®kx, k j, kxO, finset.mem_union.mpr (or.inl (by simp)), f j‚ü©) ‚à™ (finset.univ).image (Œª j : J, ‚ü®ky, k j, kyO, finset.mem_union.mpr (or.inl (by simp)), g j‚ü©)
simp
obtain ‚ü®S, T, W‚ü© := is_filtered.sup_exists O H
have fH : ‚àÄ j, (‚ü®kx, k j, kxO, kjO j, f j‚ü© : (Œ£' (X Y : K) (mX : X ‚àà O) (mY : Y ‚àà O), X ‚ü∂ Y)) ‚àà H := Œª j, (finset.mem_union.mpr (or.inl begin simp only [true_and, finset.mem_univ, eq_self_iff_true, exists_prop_of_true, finset.mem_image, heq_iff_eq], refine ‚ü®j, rfl, _‚ü©, simp only [heq_iff_eq], exact ‚ü®rfl, rfl, rfl‚ü©, end))
simp only [true_and, finset.mem_univ, eq_self_iff_true, exists_prop_of_true, finset.mem_image, heq_iff_eq]
dsimp [limit_uncurry_iso_limit_comp_lim, is_limit.cone_point_unique_up_to_iso, is_limit.unique_up_to_iso]
simp
refl
erw is_limit.fac
intro F
apply has_limit_of_equivalence_comp e
apply_instance
constructor
dsimp [colimit.iso_colimit_cocone, is_colimit.cocone_point_unique_up_to_iso]
tidy
apply G.map_injective
apply G.map_injective; rw [G.map_comp, h]; apply ht.fac
apply G.map_injective; rw [G.map_comp, h]
rw [G.map_comp, h]
apply ht.fac
rw h
apply G.map_injective
refine ht.uniq (G.map_cone s) _ (Œª j, _)
convert ‚Üêcongr_arg (Œª f, G.map f) (w j)
apply G.map_comp
have h := cocone_fac h s
cases s
injection h with h‚ÇÅ h‚ÇÇ
simp only [heq_iff_eq] at h‚ÇÇ
rw ‚Üê h‚ÇÇ
refl
conv_rhs { rw ‚Üê h‚ÇÇ }
rw ‚Üêhom_of_cocone_of_hom h m
congr
rw cocone_of_hom_fac
cases s
congr' with j
exact w j
dsimp [cocone.extend]
exactI { has_limit := Œª F, has_limit.mk (limit_cone F) }
intros
cases a
cases b
congr
split
apply is_colimit.of_point_iso (colimit.is_colimit F)
change is_iso ((cocones.forget _).map ((colimit.is_colimit F).desc_cocone_morphism c))
apply (cocones.forget F).map_is_iso _
apply is_iso_of_reflects_iso _ (cocones.functoriality F G)
refine (is_colimit_of_preserves G (colimit.is_colimit F)).hom_is_iso t _
simp [‚Üê G.map_comp]
ext
apply preserves_limit_of_preserves_limit_cone (prod_is_prod X Y)
apply (is_limit_map_cone_binary_fan_equiv _ _ _).symm _
apply is_limit.of_point_iso (limit.is_limit (pair (G.obj X) (G.obj Y)))
apply i
apply is_colimit.of_point_iso (colimit.is_colimit (functor_to_representables P))
change is_iso (colimit.desc _ (cocone.extend _ _))
rw [colimit.desc_extend, colimit.desc_cocone]
apply_instance
tidy
simp
simp
simp
ext
ext; simp
simp
simp
ext
cases j; refl
refl
refl
cases j
rw [t.app_zero_left, t.app_zero_right]
rw [‚Üêfork.app_zero_left, reassoc_of h]
simp only [‚ÜêG.map_comp, w]
simp [‚Üê G.map_comp]
ext
haveI := @has_finite_wide_pushouts.out C _ _ J (classical.dec_eq _)
apply_instance
exactI has_finite_limits.out _
simp [image.comp_iso]
ext
rw [‚Üêfork.app_zero_left, kernel_fork.condition]
apply_instance
exact w
apply colimit.w (wide_pushout_shape.wide_span _ _ _) (wide_pushout_shape.hom.init j)
refl
simp
rw [‚Üêw]
simp
equiv_rw (is_limit_equiv_sections t).symm at x
simp
simp
simp
rw [is_iso.eq_comp_inv f.f, category.assoc, ‚Üê f.h]
simp
tidy
ext1
dsimp
rw [comp_id]
apply c.w
rw [‚Üêtriangle_assoc_comp_left, iso.inv_hom_id_assoc]
rintros X Y f
apply quotient.induction_on f
intro f
ext n
induction f generalizing n
simp only [mk_id, functor.map_id, category.id_comp, category.comp_id]
{ simp only [mk_id, functor.map_id, category.id_comp, category.comp_id] }
dsimp
simp only [id_tensor_associator_inv_naturality_assoc, ‚Üêpentagon_inv_assoc, tensor_hom_inv_id_assoc, tensor_id, category.id_comp, discrete.functor_map_id, comp_tensor_id, iso.cancel_iso_inv_left, category.assoc]
simp only [category.comp_id]
{ dsimp, simp only [id_tensor_associator_inv_naturality_assoc, ‚Üêpentagon_inv_assoc, tensor_hom_inv_id_assoc, tensor_id, category.id_comp, discrete.functor_map_id, comp_tensor_id, iso.cancel_iso_inv_left, category.assoc], dsimp, simp only [category.comp_id] }
dsimp
dsimp
simp only [discrete.functor_map_id, comp_tensor_id, category.assoc, pentagon_inv_assoc, ‚Üêassociator_inv_naturality_assoc, tensor_id, iso.cancel_iso_inv_left]
simp only [category.comp_id]
{ dsimp, simp only [discrete.functor_map_id, comp_tensor_id, category.assoc, pentagon_inv_assoc, ‚Üêassociator_inv_naturality_assoc, tensor_id, iso.cancel_iso_inv_left], dsimp, simp only [category.comp_id],}
dsimp
dsimp
rw triangle_assoc_comp_right_assoc
simp only [discrete.functor_map_id, category.assoc]
simp only [category.comp_id]
{ dsimp, rw triangle_assoc_comp_right_assoc, simp only [discrete.functor_map_id, category.assoc], dsimp, simp only [category.comp_id] }
dsimp
dsimp
simp only [triangle_assoc_comp_left_inv_assoc, inv_hom_id_tensor_assoc, tensor_id, category.id_comp, discrete.functor_map_id]
simp only [category.comp_id]
{ dsimp, simp only [triangle_assoc_comp_left_inv_assoc, inv_hom_id_tensor_assoc, tensor_id, category.id_comp, discrete.functor_map_id], dsimp, simp only [category.comp_id] }
dsimp
dsimp
rw [‚Üê(iso.inv_comp_eq _).2 (right_unitor_tensor _ _), category.assoc, ‚Üêright_unitor_naturality]
simp only [discrete.functor_map_id, iso.cancel_iso_inv_left, category.assoc]
simp only [category.comp_id]
{ dsimp, rw [‚Üê(iso.inv_comp_eq _).2 (right_unitor_tensor _ _), category.assoc, ‚Üêright_unitor_naturality], simp only [discrete.functor_map_id, iso.cancel_iso_inv_left, category.assoc], dsimp, simp only [category.comp_id] }
dsimp
dsimp
simp only [‚Üê(iso.eq_comp_inv _).1 (right_unitor_tensor_inv _ _), iso.hom_inv_id_assoc, right_unitor_conjugation, discrete.functor_map_id, category.assoc]
simp only [category.comp_id]
{ dsimp, simp only [‚Üê(iso.eq_comp_inv _).1 (right_unitor_tensor_inv _ _), iso.hom_inv_id_assoc, right_unitor_conjugation, discrete.functor_map_id, category.assoc], dsimp, simp only [category.comp_id], }
dsimp
dsimp at *
rw [id_tensor_comp, category.assoc, f_ih_g ‚ü¶f_g‚üß, ‚Üêcategory.assoc, f_ih_f ‚ü¶f_f‚üß, category.assoc, ‚Üêfunctor.map_comp]
{ dsimp at *, rw [id_tensor_comp, category.assoc, f_ih_g ‚ü¶f_g‚üß, ‚Üêcategory.assoc, f_ih_f ‚ü¶f_f‚üß, category.assoc, ‚Üêfunctor.map_comp], congr' 2 }
congr' 2
dsimp at *
rw associator_inv_naturality_assoc
rw [‚Üêtensor_comp, f_ih_f ‚ü¶f_f‚üß]
slice_lhs 2 3 { rw [‚Üêtensor_comp, f_ih_f ‚ü¶f_f‚üß] }
rw [‚Üê@category.id_comp (F C) _ _ _ ‚ü¶f_g‚üß]
conv_lhs { rw [‚Üê@category.id_comp (F C) _ _ _ ‚ü¶f_g‚üß] }
simp only [category.comp_id, tensor_comp, category.assoc]
congr' 2
rw [‚Üêmk_tensor, quotient.lift_mk]
dsimp
rw [functor.map_comp, ‚Üêcategory.assoc, ‚Üêf_ih_g ‚ü¶f_g‚üß, ‚Üê@category.comp_id (F C) _ _ _ ‚ü¶f_g‚üß, ‚Üêcategory.id_comp ((discrete.functor inclusion_obj).map _), tensor_comp]
dsimp
simp only [category.assoc, category.comp_id]
congr' 1
convert (normalize_iso_aux C f_Z).hom.naturality ((normalize_map_aux f_f).app n)
exact (tensor_func_obj_map _ _ _).symm
rw [‚Üêfunctor.id_map f, ‚Üêfunctor.id_map g]
simp [‚Üênat_iso.naturality_2 (full_normalize_iso.{u} C), this]
rw [iso.inv_comp_eq, F.left_unitality, category.assoc, category.assoc, ‚ÜêF.to_functor.map_comp, iso.hom_inv_id, F.to_functor.map_id, comp_id]
apply Q.hom_ext
rintro ‚ü®‚ü©
apply P.hom_ext
rintro ‚ü®‚ü©
{ apply P.hom_ext, rintro ‚ü®‚ü©, }
simp
dsimp [tensor_hom]
simp
simp only [left_adjoint_mate, monoidal_category.tensor_id, category.id_comp, evaluation_coevaluation_assoc, category.comp_id, iso.inv_hom_id]
tidy
tidy
tidy
tidy
tidy
ext
dsimp
simp
tidy
ext
dsimp
simp
ext
ext; simp
simp
simp
simp
simp
rintros _ _ ‚ü®_, _, _, _, _, _, h‚ü©
simp [H _ _ _ _ h]
rintros a b c ‚ü®f‚ü© ‚ü®g‚ü©
exact F.map_comp f g
rw ‚Üê J‚ÇÇ.close_eq_top_iff_mem
have : J‚ÇÇ.is_closed (‚ä§ : sieve X)
intros Y f hf
{ intros Y f hf, trivial }
trivial
suffices : (‚ü®J‚ÇÇ.close S, J‚ÇÇ.close_is_closed S‚ü© : subtype _) = ‚ü®‚ä§, this‚ü©
rw subtype.ext_iff at this
{ rw subtype.ext_iff at this, exact this }
exact this
apply (h S hS).is_separated_for.ext
intros Y f hf
ext1
dsimp
rw [sieve.pullback_top, ‚Üê J‚ÇÇ.pullback_close, S.pullback_eq_top_of_mem hf, J‚ÇÇ.close_eq_top_iff_mem]
apply J‚ÇÇ.top_mem
rintro ‚ü®Z, g, i, rfl‚ü©
refine ‚ü®pullback g f, pullback.snd, _, _‚ü©
refine ‚ü®‚ü®pullback.lift (f ‚â´ inv g) (ùüô _) (by simp), ‚ü®_, by tidy‚ü©‚ü©‚ü©
simp
tidy
resetI
apply pullback.hom_ext
rw [assoc, pullback.lift_fst, ‚Üêpullback.condition_assoc]
{ rw [assoc, pullback.lift_fst, ‚Üêpullback.condition_assoc], simp }
simp
{ resetI, refine ‚ü®‚ü®pullback.lift (f ‚â´ inv g) (ùüô _) (by simp), ‚ü®_, by tidy‚ü©‚ü©‚ü©, apply pullback.hom_ext, { rw [assoc, pullback.lift_fst, ‚Üêpullback.condition_assoc], simp }, { simp } }
simp
apply pullback_singleton
rintro X S Ti ‚ü®Z, g, i, rfl‚ü© hS
rcases hS g (singleton_self g) with ‚ü®Y, f, i, hTi‚ü©
refine ‚ü®_, f ‚â´ g, _, _‚ü©
apply_instance
{ resetI, apply_instance }
resetI
ext W k
split
rintro ‚ü®V, h, k, ‚ü®_‚ü©, hh, rfl‚ü©
rw hTi at hh
cases hh
{ rintro ‚ü®V, h, k, ‚ü®_‚ü©, hh, rfl‚ü©, rw hTi at hh, cases hh, apply singleton.mk }
apply singleton.mk
rintro ‚ü®_‚ü©
refine bind_comp g presieve.singleton.mk _
rw hTi
apply presieve.singleton.mk
rw ‚Üê is_separated_for_and_exists_is_amalgamation_iff_sheaf_for
exact and.intro t
rw ‚Üê generate_of_singleton_split_epi (ùüô X)
rw ‚Üê is_sheaf_for_iff_generate
apply is_sheaf_for_singleton_iso
apply quotient.induction_on' x
intro t
apply quotient.sound
refine ‚ü®(mono_over.map_comp _ _).app t‚ü©
simp [hu]
simp [hu]
rcases j with ‚ü®-, ‚ü®g, ‚ü®m, rfl‚ü©‚ü©‚ü©
simpa using m
tidy
simp
rw ‚Üêimage_subobject_arrow
simp [equalizer_subobject_iso]
apply over.hom_mk (factor_thru_image f.hom ‚â´ k.left) _
change (factor_thru_image f.hom ‚â´ k.left) ‚â´ _ = f.hom
rw [assoc, over.w k]
apply image.fac
refine over.hom_mk _ _
refine image.lift {I := g.val.left, m := g.arrow, e := k.left, fac' := over.w k}
apply image.lift_fac
ext1
change factor_thru_image _ ‚â´ image.lift _ = _
rw [‚Üê cancel_mono g.arrow, assoc, image.lift_fac, image.fac f.hom]
exact (over.w k).symm
apply_instance
change F.repr_f.app X f = (F.repr_f.app (op F.repr_X) ‚â´ F.map f.op) (ùüô F.repr_X)
rw ‚ÜêF.repr_f.naturality
dsimp
simp
tidy
rw [le_iff_le_iff_lt_iff_lt, sdiff_lt_sdiff_iff_lt]
rw [nat.sub_lt_right_iff_lt_add, add_comm, ‚Üê size_up_to_succ']
{ exact lt_size_up_to_index_succ _ _ }
exact lt_size_up_to_index_succ _ _
exact size_up_to_index_le _ _
rw [comp_cons, nil_comp]
have hh := card_image_of_injective univ (G.dart_of_neighbor_set_injective v)
rw [finset.card_univ, card_neighbor_set_eq_degree] at hh
rwa dart_fst_fiber
ext a
split
rintro ( ‚ü® _, _, h ‚ü© | ‚ü® _, _, _, h, _ ‚ü© )
exact h
{ rintro ( ‚ü® _, _, h ‚ü© | ‚ü® _, _, _, h, _ ‚ü© ), exact h, cases h }
cases h
intro h
apply Œµ_NFA.Œµ_closure.base
exact h
simp [(<*>)]
simp [(<*>)]; exact ‚ü®Œª ‚ü®n, h‚ÇÅ, h‚ÇÇ‚ü©, ‚ü®_, ‚ü®_, h‚ÇÅ, rfl‚ü©, by simpa using h‚ÇÇ‚ü©, Œª ‚ü®_, ‚ü®n, h‚ÇÅ, rfl‚ü©, h‚ÇÇ‚ü©, ‚ü®_, h‚ÇÅ, by simpa using h‚ÇÇ‚ü©‚ü©
simp [part.bind_assoc, bind_some_eq_map]
cases f a; simp
simp
simp
cases f a
have a := (primrec.of_nat (‚Ñï √ó code)).comp list_length
have k := fst.comp a
refine option_some.comp (list_map (list_range.comp k) (_ : primrec _))
have n := snd
replace k := k.comp fst
refine nat_cases k (const none) (_ : primrec _)
have n := n.comp fst
have k := k.comp fst
have k' := snd
have c := snd.comp (a.comp $ fst.comp fst)
apply rec_prim c (const (some 0)) (option_some.comp (primrec.succ.comp n)) (option_some.comp (fst.comp $ primrec.unpair.comp n)) (option_some.comp (snd.comp $ primrec.unpair.comp n))
have L := (fst.comp fst).comp fst
have n := n.comp fst
have k := k.comp fst
have cf := fst.comp snd
have cg := (fst.comp snd).comp snd
exact option_bind (hlup.comp $ L.pair $ (k.pair cf).pair n) (option_map ((hlup.comp $ L.pair $ (k.pair cg).pair n).comp fst) (primrec‚ÇÇ.mkpair.comp (snd.comp fst) snd))
{ have L := (fst.comp fst).comp fst, have k := k.comp fst, have n := n.comp fst, have cf := fst.comp snd, have cg := (fst.comp snd).comp snd, exact option_bind (hlup.comp $ L.pair $ (k.pair cf).pair n) (option_map ((hlup.comp $ L.pair $ (k.pair cg).pair n).comp fst) (primrec‚ÇÇ.mkpair.comp (snd.comp fst) snd)) }
have L := (fst.comp fst).comp fst
have n := n.comp fst
have k := k.comp fst
have cf := fst.comp snd
have cg := (fst.comp snd).comp snd
exact option_bind (hlup.comp $ L.pair $ (k.pair cg).pair n) (hlup.comp ((L.comp fst).pair $ ((k.pair cf).comp fst).pair snd))
{ have L := (fst.comp fst).comp fst, have k := k.comp fst, have n := n.comp fst, have cf := fst.comp snd, have cg := (fst.comp snd).comp snd, exact option_bind (hlup.comp $ L.pair $ (k.pair cg).pair n) (hlup.comp ((L.comp fst).pair $ ((k.pair cf).comp fst).pair snd)) }
have L := (fst.comp fst).comp fst
have n := n.comp fst
have k := k.comp fst
have cf := fst.comp snd
have cg := (fst.comp snd).comp snd
have z := fst.comp (primrec.unpair.comp n)
refine nat_cases (snd.comp (primrec.unpair.comp n)) (hlup.comp $ L.pair $ (k.pair cf).pair z) (_ : primrec _)
have z := z.comp fst
have y := snd
have L := L.comp fst
refine option_bind (hlup.comp $ L.pair $ (((k'.pair c).comp fst).comp fst).pair (primrec‚ÇÇ.mkpair.comp z y)) (_ : primrec _)
have y := y.comp fst
have i := snd
have z := z.comp fst
exact hlup.comp ((L.comp fst).pair $ ((k.pair cg).comp $ fst.comp fst).pair $ primrec‚ÇÇ.mkpair.comp z $ primrec‚ÇÇ.mkpair.comp y i)
{ have L := (fst.comp fst).comp fst, have k := k.comp fst, have n := n.comp fst, have cf := fst.comp snd, have cg := (fst.comp snd).comp snd, have z := fst.comp (primrec.unpair.comp n), refine nat_cases (snd.comp (primrec.unpair.comp n)) (hlup.comp $ L.pair $ (k.pair cf).pair z) (_ : primrec _), have L := L.comp fst, have z := z.comp fst, have y := snd, refine option_bind (hlup.comp $ L.pair $ (((k'.pair c).comp fst).comp fst).pair (primrec‚ÇÇ.mkpair.comp z y)) (_ : primrec _), have z := z.comp fst, have y := y.comp fst, have i := snd, exact hlup.comp ((L.comp fst).pair $ ((k.pair cg).comp $ fst.comp fst).pair $ primrec‚ÇÇ.mkpair.comp z $ primrec‚ÇÇ.mkpair.comp y i) }
have L := (fst.comp fst).comp fst
have n := n.comp fst
have k := k.comp fst
have cf := fst.comp snd
have z := fst.comp (primrec.unpair.comp n)
have m := snd.comp (primrec.unpair.comp n)
refine option_bind (hlup.comp $ L.pair $ (k.pair cf).pair (primrec‚ÇÇ.mkpair.comp z m)) (_ : primrec _)
have m := m.comp fst
exact nat_cases snd (option_some.comp m) ((hlup.comp ((L.comp fst).pair $ ((k'.pair c).comp $ fst.comp fst).pair (primrec‚ÇÇ.mkpair.comp (z.comp fst) (primrec.succ.comp m)))).comp fst)
letI : ‚àÄ a, decidable (a ‚àà set.range (encode : Œ± ‚Üí ‚Ñï)) := decidable_range_encode _
letI : ‚àÄ a, decidable (a ‚àà set.range (encode : Œ± ‚Üí ‚Ñï)) := decidable_range_encode _; exact subtype_mk primrec.encode
exact subtype_mk primrec.encode
refl
{refl}
cases decode Œ± n
simp [encodek]
haveI := primcodable.of_equiv Œ± e; exact primrec e
exact primrec e
haveI := primcodable.of_equiv Œ± e
letI : primcodable Œ≤ := primcodable.of_equiv Œ± e
letI : primcodable Œ≤ := primcodable.of_equiv Œ± e; exact encode_iff.1 primrec.encode
exact encode_iff.1 primrec.encode
intros; cases a; [refl, {cases b; refl}]
intros; cases a
cases a
refl
cases b
cases b; refl
refl
refl
intros
simp [primrec‚ÇÇ, primrec, this]
cases o a with b; simp [encodek]; refl
cases o a with b; simp [encodek]
simp [encodek]
simp [encodek]
cases o a with b
simp
induction c with generalizing k v; simp only [cont.then, step_normal, cfg.then, *] {constructor_eq := ff}
induction c with generalizing k v
simp only [cont.then, step_normal, cfg.then, *] {constructor_eq := ff}
simp only [cont.then, step_normal, cfg.then, *] {constructor_eq := ff}
simp only [cont.then, step_normal, cfg.then, *] {constructor_eq := ff}
simp only [cont.then, step_normal, cfg.then, *] {constructor_eq := ff}
simp only [cont.then, step_normal, cfg.then, *] {constructor_eq := ff}
simp only [cont.then, step_normal, cfg.then, *] {constructor_eq := ff}
simp only [cont.then, step_normal, cfg.then, *] {constructor_eq := ff}
case turing.to_partrec.code.cons : c c' ih ih' { rw [‚Üê ih, cont.then] }
rw [‚Üê ih, cont.then]
case turing.to_partrec.code.comp : c c' ih ih' { rw [‚Üê ih', cont.then] }
rw [‚Üê ih', cont.then]
cases v.head; simp only [nat.elim]
simp only [nat.elim]
simp only [nat.elim]
{ cases v.head; simp only [nat.elim] }
cases v.head
case turing.to_partrec.code.fix : c ih { rw [‚Üê ih, cont.then] }
rw [‚Üê ih, cont.then]
rintro _ _ ‚ü®i, rfl‚ü©
cases i
cases i; refl
refl
refl
{cases i; refl}
refl
cases a
simp only [list.nth_map, list_blank.map_mk, list_blank.nth_mk, list.inth]
intro l
exact f.2.symm
{exact f.2.symm}
refl
cases l.nth n
cases T; simp [tape.move]
simp [tape.move]
cases T
rcases trans_gen.head'_iff.1 h‚ÇÅ with ‚ü®b', hab, hbc‚ü©
exact hbc
cases option.mem_unique hab h‚ÇÇ
refine { .. }; intros; cases x; refl
refine { .. }; intros; cases x
refine { .. }; intros
intros
intros
cases x
cases x
refl
refl
refl
refl
refine { .. }
refine {..}; intros; simp [functor.map] with functor_norm
refine {..}; intros
intros
intros
simp [functor.map] with functor_norm
simp [functor.map] with functor_norm
refine {..}
simp only [(‚àò), mfoldr.of_free_monoid, mfoldr.mk, flip, fold_mfoldr_cons]
ext
simp only [mfoldl, fold_map_map, (‚àò), flip]
apply funext; apply id_map
apply id_map
apply funext
dsimp [approx]
apply @bot_le _ _ (f ‚ä•)
induction i
apply f.monotone
apply i_ih
intro
simp [add_lsb,two_mul]
congr
cases b
cases b; refl
refl
refl
convert nat.lt_succ_of_lt h
simp
convert array.read_push_back_left _
simp
cases b
simp
convert array.read_push_back_right
cases b
tactic.mk_dec_eq_instance
contrapose! h
constructor
intros cb n hn
cases hp : p cb n
{ exact absurd hn (h _ _ _ _ hp).not_le }
exact absurd hn (h _ _ _ _ hp).not_le
simp [hp]
convert err_static.and_then_of_unfailing
{ exact h' _ }
exact h' _
convert unfailing.mmap'
exact h
rw [any_char_eq_fail, and.comm]
simp
dsimp [fix] at h
exact err_static.of_fail h
haveI := fix_core hF (cb.size - n + 1)
simp_rw bind_eq_done
rintro ‚ü®_, _, hp, hf‚ü©
exact (static.of_done hf) ‚ñ∏ (of_done hp)
convert step.and_then
{ apply_instance }
apply_instance
exact static.pure
simp
simp_rw orelse_eq_done
rintro (h | ‚ü®h, -‚ü©)
rintro (h | ‚ü®h, -‚ü©); exact of_done h
exact of_done h
exact of_done h
cases hp : p cb n; simp [hp, ‚Üêbind_eq_bind, parser.bind, and_assoc]
simp [hp, ‚Üêbind_eq_bind, parser.bind, and_assoc]
simp [hp, ‚Üêbind_eq_bind, parser.bind, and_assoc]
cases hp : p cb n
simp [mmap, and.comm, and.assoc, and.left_comm, pure_eq_done]
by_cases hn : n < cb.size
by_cases hp : p (cb.read ‚ü®n, hn‚ü©)
simp only [sat, hn, hp, dif_pos, if_true, exists_prop_of_true]
split
simp [hp]
{ rintro ‚ü®rfl, rfl‚ü©, simp [hp] }
rintro ‚ü®rfl, rfl‚ü©
simp
{ simp only [sat, hn, hp, dif_pos, if_true, exists_prop_of_true], split, { rintro ‚ü®rfl, rfl‚ü©, simp [hp] }, { rintro ‚ü®-, rfl, rfl‚ü©, simp } }
rintro ‚ü®-, rfl, rfl‚ü©
simp only [sat, hn, hp, dif_pos, false_iff, not_and, exists_prop_of_true, if_false]
rintro H - rfl
{ by_cases hp : p (cb.read ‚ü®n, hn‚ü©), { simp only [sat, hn, hp, dif_pos, if_true, exists_prop_of_true], split, { rintro ‚ü®rfl, rfl‚ü©, simp [hp] }, { rintro ‚ü®-, rfl, rfl‚ü©, simp } }, { simp only [sat, hn, hp, dif_pos, false_iff, not_and, exists_prop_of_true, if_false], rintro H - rfl, exact hp H } }
exact hp H
simp [sat, hn]
simp [str_eq_char_buf, char_buf_eq_done]
simp only [sub_conj, of_real_mul, of_real_one, of_real_bit0, mul_right_comm, mul_div_cancel_left _ (mul_ne_zero two_ne_zero' I_ne_zero : 2 * I ‚â† 0)]
simpa [re_add_im] using abs_add z.re (z.im * I)
rw ‚Üê of_real_inj; simp [sinh_add]
simp [sinh_add]
rw ‚Üê of_real_inj
rw ‚Üê of_real_inj; simp [cosh_two_mul]
simp [cosh_two_mul]
rw ‚Üê of_real_inj
rw [two_mul, sinh_add]
ring
rw [tan, sin_mul_I, cos_mul_I, mul_div_right_comm, tanh_eq_sinh_div_cosh]
simp [sub_eq_add_neg, sin_add, sin_neg, cos_neg]
rw [‚Üê of_real_sin_of_real_re, of_real_im]
rw [cos_two_mul', eq_sub_iff_add_eq.2 (sin_sq_add_cos_sq x), ‚Üê sub_add, sub_add_eq_add_sub, two_mul]
ring
have h1 : x + 2 * x = 3 * x
rw [‚Üê h1, cos_add x (2 * x)]
simp only [cos_two_mul, sin_two_mul, mul_add, mul_sub, mul_one, sq]
have h2 : 4 * cos x ^ 3 = 2 * cos x * cos x * cos x + 2 * cos x * cos x ^ 2
ring
rw [h2, cos_sq']
ring
rw [‚Üê of_real_inj]; simp [sin, sin_add]
simp [sin, sin_add]
rw [‚Üê of_real_inj]
rw [‚Üê of_real_inj, of_real_tan, tan_eq_sin_div_cos, of_real_div, of_real_sin, of_real_cos]
simp [tan]
norm_num
simp [bit0]
simp [bit1]
simp [bit0, ext_iff]
simp_rw conj_eq_re_sub_im
simp only [smul_re, smul_im, of_real_mul]
rw smul_sub
simp_rw of_real_alg
simp
by_cases h : (I : K) = 0
{ simp [h] }
simp [h]
field_simp [mul_assoc, I_mul_I_of_nonzero h]
simp only [‚Üêsqrt_norm_sq_eq_norm, norm_sq_conj]
rw [‚Üê of_real_rat_cast, of_real_re]
rwa [‚Üê of_real_nat_cast, of_real_eq_zero, nat.cast_eq_zero] at h
simp
ext i
fin_cases i
fin_cases i; simp
simp
simp
simp
simp
refine quotient.map‚ÇÇ (Œª x y, ‚ü®Œª i, f i (x.1 i) (y.1 i), x.2 + y.2, Œª i, _‚ü©) _
cases x.3 i with h1 h1
rw multiset.mem_add
left
exact h1
{ left, rw multiset.mem_add, left, exact h1 }
left
cases y.3 i with h2 h2
rw multiset.mem_add
right
exact h2
{ left, rw multiset.mem_add, right, exact h2 }
left
simp
rw [h1, h2, hf]
{ cases x.3 i with h1 h1, { left, rw multiset.mem_add, left, exact h1 }, cases y.3 i with h2 h2, { left, rw multiset.mem_add, right, exact h2 }, right, rw [h1, h2, hf] }
right
simp only [H1 i, H2 i]
exact Œª x‚ÇÅ x‚ÇÇ H1 y‚ÇÅ y‚ÇÇ H2 i, by simp only [H1 i, H2 i]
simp only [smul_apply, smul_zero, zero_apply]
simp only [add_apply, smul_apply, smul_add]
simp only [smul_apply, one_smul]
simp only [smul_apply, smul_smul]
intro j
rcases eq_or_ne i j with rfl|hi
split_ifs with hb
{ simp [hb] }
simp [hb]
{ split_ifs with hb, { simp [hb] }, { simp } }
simp
cases x.zero j with hj hj
split_ifs; simp [multiset.mem_erase_of_ne hi.symm, hj]
split_ifs
{ split_ifs; simp [multiset.mem_erase_of_ne hi.symm, hj] }
simp [multiset.mem_erase_of_ne hi.symm, hj]
simp [multiset.mem_erase_of_ne hi.symm, hj]
simp [function.update_noteq hi.symm, hj]
rw (funext h : x.to_fun = y.to_fun)
by_cases h : i = j
ext j
simp [hb]
{ subst h, simp [hb] }
subst h
simp [ne.symm h, h]
exact prod_extend_right_apply_ne _ h _
contrapose! h
rw [list.map_map, e.symm_comp_self, list.map_id]
rw [list.map_map, e.self_comp_symm, list.map_id]
convert (h $ e.symm a).symm
exact (e.apply_symm_apply a).symm
ext ‚ü®b, a, has, rfl‚ü©
have : ‚àÄ(h : ‚àÉa', a' ‚àà s ‚àß a' = a), classical.some h = a := Œª h, (classical.some_spec h).2
simp [equiv.set.image, equiv.set.image_of_inj_on, hf.eq_iff, this]
simp
ext
rw [‚Üê equiv.trans_apply, equiv.swap_swap, equiv.refl_apply]
simp
rintros (‚ü®x,hx‚ü©|‚ü®x,hx‚ü©)
rintros (‚ü®x,hx‚ü©|‚ü®x,hx‚ü©); dsimp; [rw dif_pos, rw dif_neg]
rintros (‚ü®x,hx‚ü©|‚ü®x,hx‚ü©); dsimp
dsimp
dsimp
rw dif_pos
rw dif_neg
dsimp
split_ifs
split_ifs; refl
refl
refl
simp *
dsimp [directed.sequence]
generalize eq : hf.sequence f n = p
cases h : decode Œ± n with a
{ exact (classical.some_spec (hf p p)).1 }
exact (classical.some_spec (hf p p)).1
exact (classical.some_spec (hf p a)).1
dsimp [fin_rotate]
rw fin_add_flip_apply_mk_right
simp
ext ‚ü®i, h‚ü©
by_cases h' : i < n
rw [fin_rotate_of_lt h', fin.snoc, fin.cons, dif_pos h']
{ rw [fin_rotate_of_lt h', fin.snoc, fin.cons, dif_pos h'], refl, }
refl
have h'' : n = i
exact (nat.eq_of_le_of_lt_succ h' h).symm
{ simp only [not_lt] at h', exact (nat.eq_of_le_of_lt_succ h' h).symm, }
simp only [not_lt] at h'
subst h''
rw [fin_rotate_last', fin.snoc, fin.cons, dif_neg (lt_irrefl _)]
refl
simp
split
rw [trans_source'', trans_source'', ‚Üê he.target_eq, ‚Üê hf.1]
exact (he.symm'.eq_on.mono $ inter_subset_left _ _).image_eq
{ rw [trans_source'', trans_source'', ‚Üê he.target_eq, ‚Üê hf.1], exact (he.symm'.eq_on.mono $ inter_subset_left _ _).image_eq }
assume x hx
rw trans_source at hx
simp [(he.2 hx.1).symm, hf.2 hx.2]
rw [he.eq_on.inter_preimage_eq, he.source_eq]
simp [ext_iff]
simp [ext_iff]
simp [ext_iff]
simp [ext_iff]
tauto
ext x
ext x; simp [ext_iff]; tauto
ext x; simp [ext_iff]
rw [‚Üê f.map_one, h‚ÇÅ]
simp
ext
resetI; apply e.injective.division_ring _; intros; exact e.apply_symm_apply _
resetI; apply e.injective.division_ring _; intros
resetI; apply e.injective.division_ring _
apply e.injective.division_ring _
intros
intros
intros
intros
intros
intros
intros
intros
resetI
exact e.apply_symm_apply _
exact e.apply_symm_apply _
exact e.apply_symm_apply _
exact e.apply_symm_apply _
exact e.apply_symm_apply _
exact e.apply_symm_apply _
exact e.apply_symm_apply _
exact e.apply_symm_apply _
dsimp [pred_above]
split_ifs with ha hb hb
simp only [le_iff_coe_le_coe, coe_pred]
simp only [le_iff_coe_le_coe, coe_pred]
simp only [le_iff_coe_le_coe, coe_pred]
simp only [le_iff_coe_le_coe, coe_pred]
all_goals { simp only [le_iff_coe_le_coe, coe_pred] }
{ exact pred_le _, }
exact pred_le _
have : b < a := cast_succ_lt_cast_succ_iff.mpr (hb.trans_le (le_of_not_gt ha))
exact absurd H this.not_le
have : i ‚â§ (last n).cast_succ := h.trans p.le_last
simp [pred_above, cast_pred, h.not_lt, this.not_lt]
rcases i.le_last.eq_or_lt with rfl|h
{ simp }
simp
rw [cast_pred, pred_above, dif_neg]
{ simp }
simp
simpa [lt_iff_coe_lt_coe, le_iff_coe_le_coe, lt_succ_iff] using h
simp [snoc]
ext j
by_cases h : j = i
simp [init]
{ rw h, simp [init] }
rw h
simp [init, h]
simp [eq_iff_veq, add_def, mod_eq_of_lt (is_lt k)]
simp [eq_iff_veq]
refl
cases j
simp *
simp only [erase_erase, erase_to_finmap]
simp only [mem_inter, mem_filter, and.right_comm]
ext
rw [multiset.mem_to_finset, ‚Üêmem_def]
ext
rcases to_finset_surj_on (set.mem_univ s) with ‚ü®l, -, hls‚ü©
intro s
exact ‚ü®l, hls‚ü©
rw [mem_filter, mem_image]
ext
simp only [and_imp, exists_prop, and_iff_right_iff_imp, exists_imp_distrib]
exact h _ xel
rintros x xel rfl
push_neg
exact card_le_one
rw ‚Üê not_iff_not
simpa only [mem_range]
simpa only [mem_range]
ext
simp only [finset.mem_bUnion, exists_prop]
simp_rw [‚Üêexists_and_distrib_right, ‚Üêexists_and_distrib_left, and_assoc]
rw exists_comm
apply_instance
suffices : (diag s).card + (off_diag s).card = s.card * s.card
finish
{ nth_rewrite 2 ‚Üê s.diag_card, finish, }
nth_rewrite 2 ‚Üê s.diag_card
rw ‚Üê card_product
apply filter_card_add_filter_neg_card_eq_card
rw [insert_val, ndinsert_of_not_mem h]
simp only [mem_union, or_comm]
by_cases n ‚â§ k
simp [h, and_comm]
simp [h, and_comm]
ext k
ext k; by_cases n ‚â§ k; simp [h, and_comm]
ext k; by_cases n ‚â§ k
simp at hb
simp at hb; simp [hb]
simp [hb]
simp [@forall_swap _ Œ≤]
classical
induction s using finset.induction_on with x s hx IH generalizing n
{ simpa using h }
simpa using h
cases n
{ simp }
simp
rw [card_insert_of_not_mem hx, nat.succ_lt_succ_iff] at h
rw powerset_len_succ_insert hx
refine nonempty.mono _ ((IH h).image (insert x))
convert (subset_union_right _ _)
refine ext (Œª a, ‚ü®Œª ha, _, Œª ha, _ ‚ü©)
rw mem_bUnion
exact ‚ü®a.card, mem_range.mpr (nat.lt_succ_of_le (card_le_of_subset (mem_powerset.mp ha))), mem_powerset_len.mpr ‚ü®mem_powerset.mp ha, rfl‚ü©‚ü©
{ rw mem_bUnion, exact ‚ü®a.card, mem_range.mpr (nat.lt_succ_of_le (card_le_of_subset (mem_powerset.mp ha))), mem_powerset_len.mpr ‚ü®mem_powerset.mp ha, rfl‚ü©‚ü© }
rcases mem_bUnion.mp ha with ‚ü®i, hi, ha‚ü©
exact mem_powerset.mpr (mem_powerset_len.mp ha).1
simpa using nat.sub_lt (card_pos.mpr h) zero_lt_one
simp [Iic_finset, le_iff_exists_add, eq_comm]
simp only [h _ H]
simp only [finsupp.support_eq_empty, finset.nonempty_iff_ne_empty, ne.def]
simp only [sum, comap_domain_apply, (‚àò)]
simp [comap_domain, finset.sum_preimage_of_bij f _ _ (Œª x, g x (l x))]
simp
simp only [sum, multiset.count_sum', multiset.count_singleton, mul_boole, coe_mk, multiset.mem_to_finset, iff_self, not_not, mem_support_iff, ite_eq_left_iff, ne.def, multiset.count_eq_zero, multiset.count_nsmul, finset.sum_ite_eq, ite_not]
exact eq.symm
simp only [sum, coe_mk, multiset.to_finset_sum_count_nsmul_eq]
simp [single_apply, set.indicator, @eq_comm _ a]
ext
rw [‚Üê card_to_multiset, ‚Üê card_to_multiset]
apply multiset.card_lt_of_lt
exact to_multiset_strict_mono h
simp only [single_apply]; ac_refl
ac_refl
simp only [single_apply]
change dite _ _ _ = _
split_ifs; rw [finset.mem_map' f] at h
rw [finset.mem_map' f] at h
rw [finset.mem_map' f] at h
split_ifs
refine congr_arg (v : Œ± ‚Üí M) (f.inj' _)
{ refine congr_arg (v : Œ± ‚Üí M) (f.inj' _), exact finset.choose_property (Œªa‚ÇÅ, f a‚ÇÅ = f a) _ _ }
exact finset.choose_property (Œªa‚ÇÅ, f a‚ÇÅ = f a) _ _
exact (not_mem_support_iff.1 h).symm
rw f.support.prod_ite_eq
dsimp [finsupp.prod]
ext
rw dfinsupp.mem_support_to_fun
exact (finsupp.mem_split_support_iff_nonzero _ _).symm
apply_instance
apply_instance
have := Œª a, quotient.fin_choice_aux_eq a (Œª i h, quotient.out (f i))
simp [quotient.out_eq] at this
simp [this]
let g := Œª a:multiset Œπ, ‚ü¶Œª (i : Œπ) (h : i ‚àà a), quotient.out (f i)‚üß
refine eq_of_heq ((eq_rec_heq _ _).trans (_ : g a == g b))
exact quotient.sound h
congr' 1
rintro m n h
letI := classical.dec_eq Œ±
wlog hmlen : m ‚â§ n using m n
by_contradiction hmn
from lt_of_le_of_ne hmlen hmn
have hmn : m < n
refine (classical.some_spec (exists_not_mem_finset ((multiset.range n).pmap (Œª m (hm : m < n), nat_embedding_aux Œ± m) (Œª _, multiset.mem_range.1)).to_finset)) _
refine multiset.mem_to_finset.2 (multiset.mem_pmap.2 ‚ü®m, multiset.mem_range.2 hmn, _‚ü©)
rw [h, nat_embedding_aux]
simp [function.funext_iff, fintype.complete]
rw multiset.card_map
rw multiset.card_map; refl
refl
rw [list.of_fn_eq_map, fin.prod_univ_def]
rw [‚Üê (equiv.sigma_preimage_equiv f).prod_comp, ‚Üê univ_sigma_univ, prod_sigma]
refl
simp only [mem_Ico, finset.Ico.mem]
simp only [mem_Icc, finset.Ico.mem, nat.lt_add_one_iff, iff_self, implies_true_iff]
change sub_nat_nat _ _ = _
have h' : n.succ - m = (n - m).succ
apply succ_sub
apply le_of_lt_succ h
simp [*, sub_nat_nat]
cases n; refl
refl
refl
cases n
rw [‚Üê int.div_neg]
rw [‚Üê int.div_neg]; exact int.div_nonneg Ha (neg_nonneg_of_nonpos Hb)
exact int.div_nonneg Ha (neg_nonneg_of_nonpos Hb)
have := int.add_mul_div_right 0 a H; rwa [zero_add, int.zero_div, zero_add] at this
have := int.add_mul_div_right 0 a H
rwa [zero_add, int.zero_div, zero_add] at this
rw [sub_sub, add_comm]; exact match b, eq_succ_of_zero_lt bpos with ._, ‚ü®n, rfl‚ü© := rfl end
exact match b, eq_succ_of_zero_lt bpos with ._, ‚ü®n, rfl‚ü© := rfl end
rw [sub_sub, add_comm]
have := add_mul_mod_self_left a b 1; rwa mul_one at this
rwa mul_one at this
have := add_mul_mod_self_left a b 1
rw [mul_comm, mul_div_cancel_of_mod_eq_zero H]
simp [cz]
rw [mul_left_comm, int.mul_div_cancel_left _ cz, int.mul_div_cancel_left _ cz]
rw [cast_neg_succ_of_nat, cast_neg_succ_of_nat, neg_apply, add_apply, one_apply, nat_apply]
apply nat.lcm_self
rw int.lcm
refl
{refl}
induction m with d hd
rw [pow_succ, pow_succ]
exact h.mul hd
rw [modeq_iff_dvd, modeq_iff_dvd] at h
rw [modeq_iff_dvd, ‚Üê nat_abs_dvd, ‚Üê dvd_nat_abs, coe_nat_dvd, nat_abs_mul]
refine hmn.mul_dvd_of_dvd_of_dvd _ _; rw [‚Üê coe_nat_dvd, nat_abs_dvd, dvd_nat_abs]; tauto
refine hmn.mul_dvd_of_dvd_of_dvd _ _; rw [‚Üê coe_nat_dvd, nat_abs_dvd, dvd_nat_abs]
refine hmn.mul_dvd_of_dvd_of_dvd _ _
tauto
tauto
rw [‚Üê coe_nat_dvd, nat_abs_dvd, dvd_nat_abs]
rw [‚Üê coe_nat_dvd, nat_abs_dvd, dvd_nat_abs]
refl
induction xs
simp [lazy_list.append, xs_ih]
ext
congr
intro
intro; cc
cc
ext u
ext u; cases u; assumption
ext u; cases u
cases u
assumption
cc
intro
intro; cc
cc
cc
cc
cases l‚ÇÇ; exact if_pos h
exact if_pos h
exact if_pos h
cases l‚ÇÇ
simp [nil_sublist]
by_cases b ‚àà l‚ÇÇ; simp [h]
simp [h]
simp [h]
by_cases b ‚àà l‚ÇÇ
apply bag_inter_sublist_left
{ apply cons_sublist_cons, apply bag_inter_sublist_left }
apply cons_sublist_cons
apply bag_inter_sublist_left
apply sublist_cons_of_sublist
rw [cons_append, length_cons, nth, nth_concat_length]
cases l; simp only [forall_prop_of_true, map, forall_prop_of_false, not_false_iff]
simp only [forall_prop_of_true, map, forall_prop_of_false, not_false_iff]
simp only [forall_prop_of_true, map, forall_prop_of_false, not_false_iff]
cases l
simp only [cons_bind, map_cons, map_bind l]
induction l with hd tl ih generalizing a
refl
{refl}
unfold foldl
rw [ih (Œª a b bin, H a b $ mem_cons_of_mem _ bin), H a hd (mem_cons_self _ _)]
erw [length_cons, length_cons, length_scanl]
rw [foldl,foldl,foldl,‚Üê foldl_eq_of_comm',foldl,hf]
induction L with a L ihL
{ simp }
simp
rw [prod_cons, mul_eq_zero, ihL, mem_cons_iff, eq_comm]
simp
{ simp }
induction L generalizing i
simp
{ simp }
cases i
simp [drop_append, L_ih]
induction xs with a t ih generalizing ys
induction xs with a t ih generalizing ys; simp! only [append_nil, eq_self_iff_true, and_self]
simp! only [append_nil, eq_self_iff_true, and_self]
simp! only [append_nil, eq_self_iff_true, and_self]
split_ifs; rw ih
rw ih
rw ih
split_ifs
{ refine ‚ü®rfl, rfl‚ü© }
refine ‚ü®rfl, rfl‚ü©
ext
simp
congr
cases h' : f a with b
{ simp [h', lookmap_map_eq] }
simp [h', lookmap_map_eq]
simp [lookmap_cons_some _ _ h', h _ _ h']
rw [‚Üê e, append_assoc]
rw [‚Üê e, append_assoc]; exact ‚ü®_, rfl‚ü©
exact ‚ü®_, rfl‚ü©
rw append_assoc
rw append_assoc; exact e
exact e
rw erase_eq_erasep; exact length_erasep_of_mem h rfl
exact length_erasep_of_mem h rfl
rw erase_eq_erasep
rw [‚Üê take_append_drop (length s‚ÇÅ) l] at this ‚ä¢
have := h
rw map_append at this
refine ‚ü®_, _, rfl, append_inj this _‚ü©
rw [length_map, length_take, min_eq_left]
rw [‚Üê length_map f l, h, length_append]
apply nat.le_add_right
induction l; [refl, simp only [*, map]]; split; refl
induction l; [refl, simp only [*, map]]; split
induction l; [refl, simp only [*, map]]
refl
simp only [*, map]
split
induction l
simp
simp
simp [@last'_is_some (b::l)]
induction h with _ _ a _ ih _ _ a _ ih
{ refl }
refl
{ apply sublist_cons_of_sublist a ih }
apply sublist_cons_of_sublist a ih
apply cons_sublist_cons a ih
simpa [hy] using h
rw [next, next, next_or_cons_of_ne _ _ _ _ hy, next_or_eq_next_or_of_mem_of_ne]
{ rwa last_cons at hx }
rwa last_cons at hx
simpa using h.cyclic_permutations.perm
simp [‚Üêprev_reverse_eq_next]
rw duplicate_cons_iff at hx ‚ä¢
rcases hx with ‚ü®rfl, hx‚ü©|hx
{ simp [h.subset hx] }
simp [h.subset hx]
simp [IH hx]
simp_rw [nodup_iff_sublist, duplicate_iff_sublist]
simp [duplicate_iff_sublist, le_count_iff_repeat_sublist]
induction h with l‚ÇÅ l‚ÇÇ y h IH l‚ÇÅ l‚ÇÇ y h IH
{ exact hx }
exact hx
{ exact (IH hx).duplicate_cons _ }
exact (IH hx).duplicate_cons _
cases h with h‚ÇÅ h‚ÇÇ
cases h with h‚ÇÅ h‚ÇÇ; split; assumption
cases h with h‚ÇÅ h‚ÇÇ; split
split
assumption
assumption
simp only [mmap_with_index, mmap_with_index_aux_spec, mmap_with_index_aux_eq_mmap_with_index_aux_spec, enum ]
induction l with hd tl hl generalizing f n
{ simp [map_with_index, map_with_index_core] }
simp [map_with_index, map_with_index_core]
rw [map_with_index]
simp [map_with_index_core, hl, add_left_comm, add_assoc, add_comm]
simp only [pairwise_cons, mem_singleton, forall_prop_of_false (not_mem_nil _), forall_true_iff, pairwise.nil, and_true]
simp only [sublists'_cons, pairwise_append, pairwise_map, mem_sublists', mem_map, exists_imp_distrib, and_imp]
have IH := pairwise_sublists' H‚ÇÇ
refine ‚ü®IH, IH.imp (Œª l‚ÇÅ l‚ÇÇ, lex.cons), _‚ü©
subst e
intros l‚ÇÅ sl‚ÇÅ x l‚ÇÇ sl‚ÇÇ e
constructor
{constructor}
cases l‚ÇÅ with b l‚ÇÅ
exact lex.rel (H‚ÇÅ _ $ sl‚ÇÅ.subset $ mem_cons_self _ _)
induction s with y s IH generalizing n
simp only [length, permutations'_aux, nat.lt_one_iff] at hn
{ simp only [length, permutations'_aux, nat.lt_one_iff] at hn, simp [hn] }
simp [hn]
cases n
{ simp }
simp
simpa using IH _ _
induction hl
refl
case list.perm.nil { refl }
exact f_congr h ih
case list.perm.cons : a l l' h ih { exact f_congr h ih }
exact f_swap
case list.perm.swap : a a' l { exact f_swap }
case list.perm.trans : l‚ÇÅ l‚ÇÇ l‚ÇÉ h‚ÇÅ h‚ÇÇ ih‚ÇÅ ih‚ÇÇ { exact heq.trans ih‚ÇÅ ih‚ÇÇ }
exact heq.trans ih‚ÇÅ ih‚ÇÇ
let F := Œª a b, ‚àÄ (c ‚àà f a) (d ‚àà f b), a = b ‚àß c = d
change pairwise F l‚ÇÅ at H
induction p with a l‚ÇÅ l‚ÇÇ p IH a b l l‚ÇÅ l‚ÇÇ l‚ÇÉ p‚ÇÅ p‚ÇÇ IH‚ÇÅ IH‚ÇÇ
simp
{simp}
cases h : f a
exact IH (pairwise_cons.1 H).2
{ simp [h], exact IH (pairwise_cons.1 H).2 }
simp [h]
{ cases h : f a, { simp [h], exact IH (pairwise_cons.1 H).2 }, { simp [lookmap_cons_some _ _ h, p] } }
simp [lookmap_cons_some _ _ h, p]
cases h‚ÇÅ : f a with c; cases h‚ÇÇ : f b with d
cases h‚ÇÇ : f b with d
cases h‚ÇÇ : f b with d
cases h‚ÇÅ : f a with c
apply swap
{ simp [h‚ÇÅ, h‚ÇÇ], apply swap }
simp [h‚ÇÅ, h‚ÇÇ]
apply swap
{ simp [h‚ÇÅ, lookmap_cons_some _ _ h‚ÇÇ], apply swap }
simp [h‚ÇÅ, lookmap_cons_some _ _ h‚ÇÇ]
apply swap
{ simp [lookmap_cons_some _ _ h‚ÇÅ, h‚ÇÇ], apply swap }
simp [lookmap_cons_some _ _ h‚ÇÅ, h‚ÇÇ]
simp [lookmap_cons_some _ _ h‚ÇÅ, lookmap_cons_some _ _ h‚ÇÇ]
rcases (pairwise_cons.1 H).1 _ (or.inl rfl) _ h‚ÇÇ _ h‚ÇÅ with ‚ü®rfl, rfl‚ü©
{ cases h‚ÇÅ : f a with c; cases h‚ÇÇ : f b with d, { simp [h‚ÇÅ, h‚ÇÇ], apply swap }, { simp [h‚ÇÅ, lookmap_cons_some _ _ h‚ÇÇ], apply swap }, { simp [lookmap_cons_some _ _ h‚ÇÅ, h‚ÇÇ], apply swap }, { simp [lookmap_cons_some _ _ h‚ÇÅ, lookmap_cons_some _ _ h‚ÇÇ], rcases (pairwise_cons.1 H).1 _ (or.inl rfl) _ h‚ÇÇ _ h‚ÇÅ with ‚ü®rfl, rfl‚ü©, refl } }
refl
refine (IH‚ÇÅ H).trans (IH‚ÇÇ ((p‚ÇÅ.pairwise_iff _).1 H))
exact Œª a b h c h‚ÇÅ d h‚ÇÇ, (h d h‚ÇÇ c h‚ÇÅ).imp eq.symm eq.symm
simp only [range_eq_range', pairwise_lt_range']
simp only [range_eq_range', range'_sublist_right]
cases l.length.zero_le.eq_or_lt with hl hl
{ simp [eq_nil_of_length_eq_zero hl.symm ] }
simp [eq_nil_of_length_eq_zero hl.symm ]
rw [‚Üêrotate_eq_drop_append_take (n.mod_lt hl).le, rotate_mod]
rw [is_rotated_comm, is_rotated_nil_iff, eq_comm]
split
intro h
obtain ‚ü®k, hk, rfl‚ü© := nth_le_of_mem h
{ intro h, obtain ‚ü®k, hk, rfl‚ü© := nth_le_of_mem h, simp }
simp
intro h
obtain ‚ü®k, rfl‚ü© := h.symm
rw mem_iff_nth_le
simp only [exists_prop, nth_le_cyclic_permutations]
cases l' with x l
{ simp }
simp
refine ‚ü®k % length (x :: l), _, rotate_mod _ _‚ü©
simpa using nat.mod_lt _ (zero_lt_succ _)
by_cases h : a = a'
simp
{ subst a', simp }
subst a'
simp [h, map_lookup_eq_find]
refine (lookmap_congr _).trans (lookmap_id' (option.guard (Œª s, a = s.1)) _ _)
dsimp [option.guard]
split_ifs
rintro ‚ü®a', b'‚ü© h'
exact ‚ü®rfl, heq_of_eq $ nd.eq_of_mk_mem h h'‚ü©
{ subst a', exact ‚ü®rfl, heq_of_eq $ nd.eq_of_mk_mem h h'‚ü© }
subst a'
{ rintro ‚ü®a', b'‚ü© h', dsimp [option.guard], split_ifs, { subst a', exact ‚ü®rfl, heq_of_eq $ nd.eq_of_mk_mem h h'‚ü© }, { refl } }
refl
dsimp [option.guard]
split_ifs
rintro ‚ü®a‚ÇÅ, b‚ÇÅ‚ü© ‚ü®a‚ÇÇ, b‚ÇÇ‚ü©
rintro ‚ü®‚ü©
simp
{ subst a‚ÇÅ, rintro ‚ü®‚ü©, simp }
rintro ‚ü®‚ü©
subst a‚ÇÅ
simp [h]
cases e : split l with l‚ÇÅ l‚ÇÇ
injection (split_cons_of_eq _ e).symm.trans h
substs l‚ÇÅ' l‚ÇÇ'
cases length_split_le e with h‚ÇÅ h‚ÇÇ
exact ‚ü®nat.succ_le_succ h‚ÇÇ, nat.le_succ_of_le h‚ÇÅ‚ü©
rw [sublists_aux_cons_cons]
refine not_mem_cons_of_ne_of_not_mem (cons_ne_nil _ _).symm _
revert this
have := sublists_aux_ne_nil l
induction sublists_aux l cons; intro
intro
intro
induction sublists_aux l cons
rwa foldr
{rwa foldr}
simp only [foldr, mem_cons_iff, false_or, not_or_distrib]
exact ‚ü®ne_of_not_mem_cons this, ih (not_mem_of_not_mem_cons this)‚ü©
induction l generalizing f r; [refl, simp only [*, sublists'_aux]]
refl
simp only [*, sublists'_aux]
induction l generalizing f r
induction l with hd tl hl generalizing l'
{ simp }
simp
cases l'
{ simp }
simp
simp [comm, hl]
rw [‚Üê unzip_left, unzip_revzip]
induction l with hd tl hl generalizing f n l'
{ simp }
simp
cases l' with hd' tl'
{ simp, }
simp
simp [hl, mul_add]
ext i j
apply dot_product_add
apply dot_product_neg
ext
simp only [block_diagonal_apply, pi.smul_apply]
split_ifs
split_ifs; simp
ext
simp
simp
ext
simp only [block_diagonal'_apply, pi.add_apply]
split_ifs; simp
simp
simp
split_ifs
by_cases h : i = j
by_cases h : i = j; simp [h]
simp [h]
simp [h]
ext
ext ‚ü®i, i'‚ü© ‚ü®j, j'‚ü©
simp only [kronecker_map_bilinear_apply_apply, mul_apply, ‚Üê finset.univ_product_univ, finset.sum_product, kronecker_map]
simp_rw [f.map_sum, linear_map.sum_apply, linear_map.map_sum, h_comm]
apply_instance
rw [mul_matrix_apply, equiv.to_pequiv_apply]
ext i j
refine ‚ü®Œª h, revzip_powerset_aux h, Œª h, _‚ü©
simp [antidiagonal_coe]
haveI := classical.dec_eq Œ±
simp [revzip_powerset_aux_lemma l revzip_powerset_aux, h.symm]
cases x with x‚ÇÅ x‚ÇÇ
rw add_sub_cancel_left _ _
exact ‚ü®_, le_add_right _ _, by rw add_sub_cancel_left _ _‚ü©
simp only [l.prod_hom f, quot_mk_to_coe, coe_map, coe_prod]
rw [add_comm, add_sub_of_le h]
rw [add_comm, ‚Üê card_add, sub_add_cancel h]
by_contra h
cases lt_iff_cons_le.1 (lt_of_le_of_ne (le_inter (add_le_add_right (inter_le_left s t) u) (add_le_add_right (inter_le_right s t) u)) h) with a hl
rw ‚Üê cons_add at hl
exact not_le_of_lt (lt_cons_self (s ‚à© t) a) (le_inter (le_of_add_le_add_right (le_trans hl (inter_le_left _ _))) (le_of_add_le_add_right (le_trans hl (inter_le_right _ _))))
split_ifs with h
{ rw [filter_cons_of_pos _ h, singleton_add] }
rw [filter_cons_of_pos _ h, singleton_add]
rw [filter_cons_of_neg _ h, zero_add]
refine ‚ü®mem_of_mem_nsmul, Œª h, _‚ü©
obtain ‚ü®n, rfl‚ü© := exists_eq_succ_of_ne_zero h0
rw [succ_nsmul, mem_add]
exact or.inl h
simp
simpa
induction k
rw [‚Üê multiset.card_eq_zero, multiset.card_map, multiset.card_eq_zero]
simp [mul_left_comm]
simp
intro
simp [traverse]
refl
apply m.induction_on
{ simp }
simp
intros a s h
simp [h]
choose f hf using assume a, quotient.exists_rep (t a)
rw show t = Œª a, f a, from (eq.symm $ funext $ Œª a, hf a)
simpa using nodup_sigma
rwa [cons_add, cons_add, zero_add] at s_eq
refine Œª p, ‚ü®p.to_fun 0, finsupp.ext (Œª a, _)‚ü©
simpa [(finsupp.ext is_empty_elim : a = 0), C_apply, monomial]
rw [X_pow_eq_single, monomial, monomial, monomial, single_mul_single]
rw [X_pow_eq_single, monomial, monomial, monomial, single_mul_single]; simp
simp
apply @finsupp.induction œÉ ‚Ñï _ _ s
simp only [C_apply, prod_zero_index]; exact (mul_one _).symm
exact (mul_one _).symm
simp only [C_apply, prod_zero_index]
{ simp only [C_apply, prod_zero_index]; exact (mul_one _).symm }
assume n e s hns he ih
rw [monomial_single_add, ih, prod_add_index, prod_single_index, mul_left_comm]
{ simp only [pow_zero], }
simp only [pow_zero]
simp only [pow_zero]
{ intro a, simp only [pow_zero], }
intro a
rw pow_add
intros
simp
refl
simp only [eval‚ÇÇ_eq, ‚Üê finsupp.prod_pow]
simp only [coe_eval‚ÇÇ_hom]
unfold map eval
have h := eval‚ÇÇ_comp_left (eval‚ÇÇ_hom _ g)
dsimp at h
rw h
congr
simp only [coe_eval‚ÇÇ_hom, ring_hom.id_apply, comp_app, eval‚ÇÇ_C, ring_hom.coe_comp]
ext1 a
{ ext1 a, simp only [coe_eval‚ÇÇ_hom, ring_hom.id_apply, comp_app, eval‚ÇÇ_C, ring_hom.coe_comp], }
simp only [comp_app, eval‚ÇÇ_X]
ext1 n
simp
ext i
dsimp
have h‚ÇÅ : algebra_map R (mv_polynomial œÉ A‚ÇÅ) r = C (algebra_map R A‚ÇÅ r) := rfl
have h‚ÇÇ : algebra_map R (mv_polynomial œÉ A‚ÇÇ) r = C (algebra_map R A‚ÇÇ r) := rfl
rw [h‚ÇÅ, h‚ÇÇ, map, eval‚ÇÇ_hom_C, ring_hom.comp_apply, ring_equiv.coe_to_ring_hom, alg_equiv.coe_ring_equiv, alg_equiv.commutes]
apply @mv_polynomial_equiv_mv_polynomial R (S‚ÇÅ ‚äï S‚ÇÇ) _ _ _ _ (sum_to_iter R S‚ÇÅ S‚ÇÇ) (iter_to_sum R S‚ÇÅ S‚ÇÇ)
refine ring_hom.ext (Œª p, _)
rw [ring_hom.comp_apply]
convert hom_eq_hom ((sum_to_iter R S‚ÇÅ S‚ÇÇ).comp ((iter_to_sum R S‚ÇÅ S‚ÇÇ).comp C)) C _ _ p
dsimp
rw [iter_to_sum_C_C R S‚ÇÅ S‚ÇÇ, sum_to_iter_C R S‚ÇÅ S‚ÇÇ]
{ ext1 a, dsimp, rw [iter_to_sum_C_C R S‚ÇÅ S‚ÇÇ, sum_to_iter_C R S‚ÇÅ S‚ÇÇ] }
ext1 a
dsimp
rw [iter_to_sum_C_X R S‚ÇÅ S‚ÇÇ, sum_to_iter_Xr R S‚ÇÅ S‚ÇÇ]
{ refine ring_hom.ext (Œª p, _), rw [ring_hom.comp_apply], convert hom_eq_hom ((sum_to_iter R S‚ÇÅ S‚ÇÇ).comp ((iter_to_sum R S‚ÇÅ S‚ÇÇ).comp C)) C _ _ p, { ext1 a, dsimp, rw [iter_to_sum_C_C R S‚ÇÅ S‚ÇÇ, sum_to_iter_C R S‚ÇÅ S‚ÇÇ] }, { assume c, dsimp, rw [iter_to_sum_C_X R S‚ÇÅ S‚ÇÇ, sum_to_iter_Xr R S‚ÇÅ S‚ÇÇ] } }
assume c
rw [iter_to_sum_X R S‚ÇÅ S‚ÇÇ, sum_to_iter_Xl R S‚ÇÅ S‚ÇÇ]
assume b
{ assume b, rw [iter_to_sum_X R S‚ÇÅ S‚ÇÇ, sum_to_iter_Xl R S‚ÇÅ S‚ÇÇ] }
rw [ring_hom.comp_apply, ring_hom.comp_apply, sum_to_iter_C R S‚ÇÅ S‚ÇÇ, iter_to_sum_C_C R S‚ÇÅ S‚ÇÇ]
ext1 a
{ ext1 a, rw [ring_hom.comp_apply, ring_hom.comp_apply, sum_to_iter_C R S‚ÇÅ S‚ÇÇ, iter_to_sum_C_C R S‚ÇÅ S‚ÇÇ] }
cases n with b c
assume n
{ rw [sum_to_iter_Xl, iter_to_sum_X] }
rw [sum_to_iter_Xl, iter_to_sum_X]
rw [sum_to_iter_Xr, iter_to_sum_C_X]
ext : 2; simp
simp
simp
ext : 2
convert linear_map.map_smul (pderiv i) a f; rw C_mul'
rw C_mul'
rw C_mul'
convert linear_map.map_smul (pderiv i) a f
split
intros h i
{ intros h i, simpa using @h (X i) }
simpa using @h (X i)
exact supported_mono
rw [supported, set.image_eq_range, adjoin_range_eq_range_aeval, rename]
apply le_antisymm
{ apply degrees_add }
apply degrees_add
apply multiset.union_le
{ apply le_degrees_add h }
apply le_degrees_add h
apply le_degrees_add h.symm
rw add_comm
apply t.induction_on
{ simp }
simp
intros a s has hsum
rw [finset.bUnion_insert, finset.sum_insert has]
refine finset.subset.trans (vars_add_subset _ _) (finset.union_subset_union (finset.subset.refl _) _)
assumption
rw p.as_sum
conv_lhs { rw p.as_sum }
simp only [ring_hom.map_sum, eval‚ÇÇ_hom_monomial]
by_cases h0 : constant_coeff p = 0
work_on_goal 0 { rw [h0, f.map_zero, finset.sum_eq_zero], intros d hd }
rw [h0, f.map_zero, finset.sum_eq_zero]
intros d hd
work_on_goal 1 { rw [finset.sum_eq_single (0 : œÉ ‚Üí‚ÇÄ ‚Ñï)], { rw [finsupp.prod_zero_index, mul_one], refl }, intros d hd hd0, }
rw [finset.sum_eq_single (0 : œÉ ‚Üí‚ÇÄ ‚Ñï)]
rw [finsupp.prod_zero_index, mul_one]
{ rw [finsupp.prod_zero_index, mul_one], refl }
refl
intros d hd hd0
repeat { obtain ‚ü®i, hi‚ü© : d.support.nonempty, { rw [constant_coeff_eq, coeff, ‚Üê finsupp.not_mem_support_iff] at h0, rw [finset.nonempty_iff_ne_empty, ne.def, finsupp.support_eq_empty], rintro rfl, contradiction }, rw [finsupp.prod, finset.prod_eq_zero hi, mul_zero], rw [hp, zero_pow (nat.pos_of_ne_zero $ finsupp.mem_support_iff.mp hi)], rw [mem_vars], exact ‚ü®d, hd, hi‚ü© }
obtain ‚ü®i, hi‚ü© : d.support.nonempty
obtain ‚ü®i, hi‚ü© : d.support.nonempty
obtain ‚ü®i, hi‚ü© : d.support.nonempty
rw [constant_coeff_eq, coeff, ‚Üê finsupp.not_mem_support_iff] at h0
rw [finset.nonempty_iff_ne_empty, ne.def, finsupp.support_eq_empty]
contradiction
{ rw [constant_coeff_eq, coeff, ‚Üê finsupp.not_mem_support_iff] at h0, rw [finset.nonempty_iff_ne_empty, ne.def, finsupp.support_eq_empty], rintro rfl, contradiction }
{ rw [constant_coeff_eq, coeff, ‚Üê finsupp.not_mem_support_iff] at h0, rw [finset.nonempty_iff_ne_empty, ne.def, finsupp.support_eq_empty], rintro rfl, contradiction }
rintro rfl
rw [finsupp.prod, finset.prod_eq_zero hi, mul_zero]
rw [finsupp.prod, finset.prod_eq_zero hi, mul_zero]
rw [hp, zero_pow (nat.pos_of_ne_zero $ finsupp.mem_support_iff.mp hi)]
rw [hp, zero_pow (nat.pos_of_ne_zero $ finsupp.mem_support_iff.mp hi)]
rw [mem_vars]
rw [mem_vars]
exact ‚ü®d, hd, hi‚ü©
exact ‚ü®d, hd, hi‚ü©
rw [constant_coeff_eq, coeff, ‚Üê ne.def, ‚Üê finsupp.mem_support_iff] at h0
contradiction
intro
rw [add_comm, mod_add_mod, add_comm]
simp [hb]
simp [hd]
cases exi2 with y hy
cases exi1 with x hx
rw [hx, hy, nat.mul_div_cancel_left, nat.mul_div_cancel_left]
symmetry
apply nat.div_eq_of_eq_mul_left
apply mul_pos
assumption
assumption
repeat {assumption}
cc
rw [‚Üênat.div_mul_cancel w, h, zero_mul]
split
intro
cases b
{ simp * at * }
simp * at *
cases b
refl
{ right, refl }
right
left
simp
have : a / (b + 2) ‚â§ a / 2 := div_le_div_left (by simp) dec_trivial
refine eq_zero_of_le_half _
{ intro, cases b, { simp * at * }, { cases b, { right, refl }, { left, have : a / (b + 2) ‚â§ a / 2 := div_le_div_left (by simp) dec_trivial, refine eq_zero_of_le_half _, simp * at * } } }
simp * at *
rintros (rfl|rfl); simp
simp
simp
rintros (rfl|rfl)
subst h
simp
refine le_trans _ h
rw [add_comm, add_one, pred_succ]
simp [ha0]
rw [mul_comm]
rw [mul_comm]; exact mul_div_le_mul_div_assoc _ _ _
exact mul_div_le_mul_div_assoc _ _ _
rw [nat.div_div_eq_div_mul, mul_comm b, mul_comm c, nat.mul_div_mul _ _ (nat.pos_of_ne_zero ha0)]
{ subst hi, simp only [test_bit_zero] at hn hm, have : n = m, { exact eq_of_test_bit_eq (Œª i, by convert hnm (i + 1) dec_trivial using 1; rw test_bit_succ) }, rw [hn, hm, this, bit_ff, bit_tt, bit0_val, bit1_val], exact lt_add_one _ }
exact lt_add_one _
obtain ‚ü®i', rfl‚ü© := exists_eq_succ_of_ne_zero hi
simp only [test_bit_succ] at hn hm
convert hnm j.succ (succ_lt_succ hj) using 1
have := hn' _ hn hm (Œª j hj, by convert hnm j.succ (succ_lt_succ hj) using 1; rw test_bit_succ)
convert hnm j.succ (succ_lt_succ hj) using 1; rw test_bit_succ
rw test_bit_succ
rw test_bit_succ
cases b; cases b'; simp only [bit_ff, bit_tt, bit0_val n, bit1_val n, bit0_val m, bit1_val m]; linarith
cases b; cases b'; simp only [bit_ff, bit_tt, bit0_val n, bit1_val n, bit0_val m, bit1_val m]
cases b; cases b'
cases b'
cases b'
cases b
simp only [bit_ff, bit_tt, bit0_val n, bit1_val n, bit0_val m, bit1_val m]
simp only [bit_ff, bit_tt, bit0_val n, bit1_val n, bit0_val m, bit1_val m]
simp only [bit_ff, bit_tt, bit0_val n, bit1_val n, bit0_val m, bit1_val m]
simp only [bit_ff, bit_tt, bit0_val n, bit1_val n, bit0_val m, bit1_val m]
linarith
linarith
linarith
linarith
simp [‚Üêlxor_assoc, ‚Üêh]
simp [‚Üêlxor_assoc]
induction n using nat.binary_rec with b n hn
{ exact false.elim (h rfl) }
exact false.elim (h rfl)
by_cases h' : n = 0
subst h'
revert h
cases b
cases b; simp
simp
simp
rw (show b = tt, by { revert h, cases b; simp })
rw [test_bit_zero]
refine ‚ü®0, ‚ü®by rw [test_bit_zero], Œª j hj, _‚ü©‚ü©
obtain ‚ü®j', rfl‚ü© := exists_eq_succ_of_ne_zero (ne_of_gt hj)
{ subst h', rw (show b = tt, by { revert h, cases b; simp }), refine ‚ü®0, ‚ü®by rw [test_bit_zero], Œª j hj, _‚ü©‚ü©, obtain ‚ü®j', rfl‚ü© := exists_eq_succ_of_ne_zero (ne_of_gt hj), rw [test_bit_succ, zero_test_bit] }
rw [test_bit_succ, zero_test_bit]
obtain ‚ü®k, ‚ü®hk, hk'‚ü©‚ü© := hn h'
rw [test_bit_succ, hk]
refine ‚ü®k + 1, ‚ü®by rw [test_bit_succ, hk], Œª j hj, _‚ü©‚ü©
obtain ‚ü®j', rfl‚ü© := exists_eq_succ_of_ne_zero (show j ‚â† 0, by linarith)
linarith
exact (test_bit_succ _ _ _).trans (hk' _ (lt_of_succ_lt_succ hj))
induction n using nat.binary_rec with b n hn' generalizing i m
contrapose! hm
rw le_zero_iff at hm
{ contrapose! hm, rw le_zero_iff at hm, simp [hm] }
simp [hm]
induction m using nat.binary_rec with b' m hm' generalizing i
exact false.elim (bool.ff_ne_tt ((zero_test_bit i).symm.trans hm))
{ exact false.elim (bool.ff_ne_tt ((zero_test_bit i).symm.trans hm)) }
by_cases hi : i = 0
subst hi
simp only [test_bit_zero] at hn hm
have : n = m
convert hnm (i + 1) dec_trivial using 1
convert hnm (i + 1) dec_trivial using 1; rw test_bit_succ
exact eq_of_test_bit_eq (Œª i, by convert hnm (i + 1) dec_trivial using 1; rw test_bit_succ)
rw test_bit_succ
rw test_bit_succ
{ exact eq_of_test_bit_eq (Œª i, by convert hnm (i + 1) dec_trivial using 1; rw test_bit_succ) }
rw [hn, hm, this, bit_ff, bit_tt, bit0_val, bit1_val]
simp [h1]
induction l1 with hd tl IH
{ simp [of_digits] }
simp [of_digits]
rw [of_digits, list.cons_append, of_digits, IH, list.length_cons, pow_succ']
ring
cases b with b
cases n with n
{ refl, }
refl
change of_digits 0 [n+1] = n+1
dsimp [of_digits]
{ cases n with n, { refl, }, { change of_digits 0 [n+1] = n+1, dsimp [of_digits], simp, } }
simp
cases b with b
induction n with n ih
{ refl, }
refl
{ induction n with n ih, { refl, }, { simp only [ih, add_comm 1, of_digits_one_cons, nat.cast_id, digits_one_succ], } }
simp only [ih, add_comm 1, of_digits_one_cons, nat.cast_id, digits_one_succ]
clear n
apply nat.strong_induction_on n _
intros n h
cases n
refl
{ rw digits_zero, refl, }
rw digits_zero
simp only [nat.succ_eq_add_one, digits_add_two_add_one]
dsimp [of_digits]
rw h _ (nat.div_lt_self' n b)
rw [nat.cast_id, nat.mod_add_div]
split
intro h
rw h
have : of_digits b (digits b n) = of_digits b []
convert this
{ intro h, have : of_digits b (digits b n) = of_digits b [], by rw h, convert this, rw of_digits_digits }
rw of_digits_digits
rintro rfl
simp
apply nat.strong_induction_on m
intros n IH d hd
cases n with n
cases hd
{ rw digits_zero at hd, cases hd }
rw digits_zero at hd
rw digits_add_two_add_one at hd
cases hd
exact n.succ.mod_lt (by linarith)
linarith
{ rw hd, exact n.succ.mod_lt (by linarith) }
rw hd
linarith
exact IH _ (nat.div_lt_self (nat.succ_pos _) (by linarith)) hd
rw ‚Üêint.coe_nat_dvd
exact dvd_iff_dvd_of_dvd_sub (zmodeq_of_digits_digits b b' c (int.modeq_iff_dvd.2 h).symm _).symm.dvd
rw [dist.def, dist.def, right_distrib, nat.mul_sub_right_distrib, nat.mul_sub_right_distrib]
simpa only [‚Üê some_eq_coe] using part.some_inj
suffices : n! * (n + 1) ^ (m - n) ‚â§ m!
apply trans _ this
rw mul_le_mul_left
apply pow_le_pow_of_le_left (zero_le n) (le_succ n)
{ apply trans _ this, rw mul_le_mul_left, apply pow_le_pow_of_le_left (zero_le n) (le_succ n), exact factorial_pos n,}
exact factorial_pos n
convert nat.factorial_mul_pow_le_factorial
exact (nat.add_sub_of_le hnm).symm
rw [asc_factorial_zero, pow_zero]
rw pow_succ
exact nat.mul_le_mul (nat.add_le_add_right le_self_add _) (pow_succ_le_asc_factorial k)
rw gcd_zero_left
rw gcd_zero_left; exact kn
exact kn
rw gcd_rec
rw gcd_rec; exact IH ((dvd_mod_iff H1).2 H2) H1
exact IH ((dvd_mod_iff H1).2 H2) H1
simp [coprime]
rw [‚Üê enat.coe_le_coe, ‚Üê hp.multiplicity_factorial hbn, ‚Üê pow_dvd_iff_le_multiplicity]
simp only [nat.add_sub_cancel' hkn]
simp only [nat.add_div (pow_pos hp.pos _)]
simp [sum_add_distrib, sum_boole]
to_rhs
rw [‚Üênat.sub_add_cancel h, even_add]
conv { to_rhs, rw [‚Üênat.sub_add_cancel h, even_add] }
by_cases h : even n; simp [h]
simp [h]
simp [h]
by_cases h : even n
rw [odd_iff_not_even, even_sub h, not_iff, not_iff_comm, odd_iff_not_even]
cases mod_two_eq_zero_or_one n with h h; simp [h]
simp [h]
simp [h]
cases mod_two_eq_zero_or_one n with h h
revert h
dec_trivial
rintro rfl
intro h
intro h
split
split; intro h
rcases n with (_ | _ | n)
{ exact or.inl rfl }
exact or.inl rfl
{ exact or.inr rfl }
exact or.inr rfl
injection h
{ rcases n with (_ | _ | n), { exact or.inl rfl }, { exact or.inr rfl }, { rw factors at h, injection h }, }
rw factors at h
rcases h with (rfl | rfl)
{ exact factors_zero }
exact factors_zero
exact factors_one
obtain ‚ü®l, ‚ü®h, rfl‚ü©‚ü© := (dvd_prime_pow pp).1 h‚ÇÇ
congr
exact le_antisymm h (not_le.1 ((not_congr (pow_dvd_pow_iff_le_right (prime.one_lt pp))).1 h‚ÇÅ))
cases s : psub m n; simp [eq_comm]
simp [eq_comm]
simp [eq_comm]
cases s : psub m n
refine lt_of_not_ge (Œª h, _)
show m < n
cases le.dest h with k e
injection s.symm.trans (psub_eq_some.2 $ (add_comm _ _).trans e)
{ show m < n, refine lt_of_not_ge (Œª h, _), cases le.dest h with k e, injection s.symm.trans (psub_eq_some.2 $ (add_comm _ _).trans e) }
rw ‚Üê psub_eq_some.1 s
apply nat.le_add_left
show n ‚â§ m
rw sqrt_aux; simp only [h, h‚ÇÇ.symm, int.coe_nat_add, if_false]; rw [add_comm _ (n':‚Ñ§), add_sub_cancel, sqrt_aux._match_1]
rw sqrt_aux; simp only [h, h‚ÇÇ.symm, int.coe_nat_add, if_false]
simp only [h, h‚ÇÇ.symm, int.coe_nat_add, if_false]
rw sqrt_aux
rw [add_comm _ (n':‚Ñ§), add_sub_cancel, sqrt_aux._match_1]
rw [pred'_to_nat, succ'_to_nat, nat.add_one, nat.pred_succ]
rw [size, succ_to_nat, nat_size, size_eq_nat_size]
rw [size, succ_to_nat, nat_size, size_eq_nat_size]
refine_struct {mul := (*), one := (1 : pos_num), npow := @npow_rec _ ‚ü®1‚ü© ‚ü®(*)‚ü©}
refine_struct {mul := (*), one := (1 : pos_num), npow := @npow_rec _ ‚ü®1‚ü© ‚ü®(*)‚ü©}; try { intros, refl }; transfer
refine_struct {mul := (*), one := (1 : pos_num), npow := @npow_rec _ ‚ü®1‚ü© ‚ü®(*)‚ü©}; try { intros, refl }
refl
try { intros, refl }
try { intros, refl }
try { intros, refl }
try { intros, refl }
try { intros, refl }
try { intros, refl }
transfer
transfer
transfer
intros
rw [‚Üê bit1_of_bit1, _root_.bit1, bit0_of_bit0, cast_add, cast_bit0]
rw [‚Üê bit1_of_bit1, _root_.bit1, bit0_of_bit0, cast_add, cast_bit0]; refl
refl
rw [int.cast_coe_nat, ‚Üê num.of_nat_to_znum, num.cast_to_znum, ‚Üê num.cast_to_nat, int.nat_cast_eq_coe_nat, num.to_of_nat]
rw [int.cast_neg_succ_of_nat, cast_zneg, add_one, cast_succ, int.neg_succ_of_nat_eq, ‚Üê num.of_nat_to_znum, num.cast_to_znum, ‚Üê num.cast_to_nat, int.nat_cast_eq_coe_nat, num.to_of_nat]
refine nat.prime_def_min_fac.trans ((and_iff_right _).trans $ eq_comm.trans _)
{ exact bit0_le_bit0.2 (to_nat_pos _) }
exact bit0_le_bit0.2 (to_nat_pos _)
rw [‚Üê min_fac_to_nat, to_nat_inj]
exact ‚ü®bit0.inj, congr_arg _‚ü©
refine nat.prime_def_min_fac.trans ((and_iff_right _).trans _)
{ exact nat.bit0_le_bit1_iff.2 (to_nat_pos _) }
exact nat.bit0_le_bit1_iff.2 (to_nat_pos _)
refl
rw [‚Üê min_fac_to_nat, to_nat_inj]
cases x; refl
refl
refl
cases x
cases x
{ simp }
simp
simp only [pbind]
split
intro h
use x
{ intro h, use x, simpa only [mem_def, exists_prop_of_true] using h }
simpa only [mem_def, exists_prop_of_true] using h
rintro ‚ü®z, H, hz‚ü©
simp only [mem_def] at H
simpa only [H] using hz
linarith
exact ‚ü®hr, (zero_add _).symm‚ü©
cases l with ls ll lx lr
{exact ‚ü®hr, (zero_add _).symm‚ü© }
exact ‚ü®hl, rfl‚ü©
cases r with rs rl rx rr
{exact ‚ü®hl, rfl‚ü© }
split_ifs
dsimp [glue]
rw [split_max_eq, glue]
cases valid'.erase_max_aux hl with v e
suffices H
refine ‚ü®valid'.balance_r v (hr.of_gt _ _) H, _‚ü©
refine find_max'_all lx lr hl.1.2.to_nil (sep.2.2.imp _)
{ refine find_max'_all lx lr hl.1.2.to_nil (sep.2.2.imp _), exact Œª x h, hr.1.2.to_nil.mono_left (le_of_lt h.2.1) }
exact Œª x h, hr.1.2.to_nil.mono_left (le_of_lt h.2.1)
exact @find_max'_all _ (Œª a, all (> a) (node rs rl rx rr)) lx lr sep.2.1 sep.2.2
{ exact @find_max'_all _ (Œª a, all (> a) (node rs rl rx rr)) lx lr sep.2.1 sep.2.2 }
refl
rw [size_balance_r v.3 hr.3 v.2 hr.2 H, add_right_comm, ‚Üê e, hl.2.1]
{ rw [size_balance_r v.3 hr.3 v.2 hr.2 H, add_right_comm, ‚Üê e, hl.2.1], refl }
refine or.inl ‚ü®_, or.inr e, _‚ü©
{ rw [split_max_eq, glue], cases valid'.erase_max_aux hl with v e, suffices H, refine ‚ü®valid'.balance_r v (hr.of_gt _ _) H, _‚ü©, { refine find_max'_all lx lr hl.1.2.to_nil (sep.2.2.imp _), exact Œª x h, hr.1.2.to_nil.mono_left (le_of_lt h.2.1) }, { exact @find_max'_all _ (Œª a, all (> a) (node rs rl rx rr)) lx lr sep.2.1 sep.2.2 }, { rw [size_balance_r v.3 hr.3 v.2 hr.2 H, add_right_comm, ‚Üê e, hl.2.1], refl }, { refine or.inl ‚ü®_, or.inr e, _‚ü©, rwa hl.2.eq_node' at bal } }
rwa hl.2.eq_node' at bal
rw [split_min_eq, glue]
cases valid'.erase_min_aux hr with v e
suffices H
refine ‚ü®valid'.balance_l (hl.of_lt _ _) v H, _‚ü©
refine @find_min'_all _ (Œª a, bounded nil o‚ÇÅ ‚Üëa) rl rx (sep.2.1.1.imp _) hr.1.1.to_nil
{ refine @find_min'_all _ (Œª a, bounded nil o‚ÇÅ ‚Üëa) rl rx (sep.2.1.1.imp _) hr.1.1.to_nil, exact Œª y h, hl.1.1.to_nil.mono_right (le_of_lt h) }
exact Œª y h, hl.1.1.to_nil.mono_right (le_of_lt h)
exact @find_min'_all _ (Œª a, all (< a) (node ls ll lx lr)) rl rx (all_iff_forall.2 $ Œª x hx, sep.imp $ Œª y hy, all_iff_forall.1 hy.1 _ hx) (sep.imp $ Œª y hy, hy.2.1)
{ exact @find_min'_all _ (Œª a, all (< a) (node ls ll lx lr)) rl rx (all_iff_forall.2 $ Œª x hx, sep.imp $ Œª y hy, all_iff_forall.1 hy.1 _ hx) (sep.imp $ Œª y hy, hy.2.1) }
refl
{ rw [size_balance_l hl.3 v.3 hl.2 v.2 H, add_assoc, ‚Üê e, hr.2.1], refl }
rw [size_balance_l hl.3 v.3 hl.2 v.2 H, add_assoc, ‚Üê e, hr.2.1]
refine or.inr ‚ü®_, or.inr e, _‚ü©
rwa hr.2.eq_node' at bal
linarith
unfold balance_l balance_r
cases r with rs rl rx rr
refl
{refl}
cases l with ls ll lx lr
cases ll with lls lll llx llr; cases lr with lrs lrl lrx lrr; dsimp only [dual]; try {refl}
cases ll with lls lll llx llr; cases lr with lrs lrl lrx lrr; dsimp only [dual]
cases ll with lls lll llx llr; cases lr with lrs lrl lrx lrr
cases lr with lrs lrl lrx lrr
cases lr with lrs lrl lrx lrr
cases ll with lls lll llx llr
try {refl}
try {refl}
try {refl}
try {refl}
refl
dsimp only [dual]
dsimp only [dual]
dsimp only [dual]
dsimp only [dual]
split_ifs; repeat {simp [h, add_comm]}
repeat {simp [h, add_comm]}
repeat {simp [h, add_comm]}
simp [h, add_comm]
{ cases l with ls ll lx lr, {refl}, cases ll with lls lll llx llr; cases lr with lrs lrl lrx lrr; dsimp only [dual]; try {refl}, split_ifs; repeat {simp [h, add_comm]} }
split_ifs
refl
{refl}
cases l with ls ll lx lr
dsimp only [dual]
swap
simp [add_comm]
{simp [add_comm]}
split_ifs
cases ll with lls lll llx llr; cases lr with lrs lrl lrx lrr; try {refl}
cases ll with lls lll llx llr; cases lr with lrs lrl lrx lrr
cases lr with lrs lrl lrx lrr
cases lr with lrs lrl lrx lrr
cases ll with lls lll llx llr
try {refl}
try {refl}
try {refl}
try {refl}
refl
dsimp only [dual]
split_ifs; simp [h, add_comm]
simp [h, add_comm]
simp [h, add_comm]
split_ifs
rw ‚Üê dual_dual t
rw ‚Üê dual_dual t; exact h.dual
exact h.dual
cases r; simp [rotate_l, all_node']; split_ifs; simp [all_node3_l, all_node4_l, all]
cases r; simp [rotate_l, all_node']; split_ifs
cases r; simp [rotate_l, all_node']
simp [rotate_l, all_node']
simp [rotate_l, all_node']
cases r
simp [all_node3_l, all_node4_l, all]
simp [all_node3_l, all_node4_l, all]
split_ifs
rw [balance_l_eq_balance' hl hr sl sr H, size_balance' sl sr]
cases o
cases o; [cases h‚ÇÅ, refl]
cases h‚ÇÅ
refl
rw mem_core_res
by_cases h : x ‚àà s
by_cases h : x ‚àà s; simp [h]
simp [h]
simp [h]
ext
change (coe_pnat_monoid_hom (u + v)).prod = _
rw coe_pnat_monoid_hom.map_add
exact multiset.prod_add _ _
let u := factor_multiset n
let v := factor_multiset m
have : n = u.prod := (prod_factor_multiset n).symm
rw[this]
have : m = v.prod := (prod_factor_multiset m).symm
rw[this]
rw[‚Üê prime_multiset.prod_add]
rw[prime_multiset.factor_multiset_prod]
rw[prime_multiset.factor_multiset_prod]
rw[prime_multiset.factor_multiset_prod]
repeat {rw[prime_multiset.factor_multiset_prod]}
apply factor_multiset_equiv.symm.injective
change (p : ‚Ñï+).factor_multiset.prod = (prime_multiset.of_prime p).prod
rw[(p : ‚Ñï+).prod_factor_multiset, prime_multiset.prod_of_prime]
apply_instance
dsimp [prime_multiset]
rw ‚Üê coprime_coe
rw ‚Üê coprime_coe
rw ‚Üê coprime_coe
rw ‚Üê coprime_coe
rw mul_coe
apply nat.coprime.mul_right
repeat {rw ‚Üê coprime_coe}
intro h
apply hf
rw [‚Üêeval‚ÇÇ_hom, h, f.map_zero]
rw [aeval_def, eval‚ÇÇ]
exact (linear_map.apply‚Çó v).map_sum
rw [ne.def, set_like.ext_iff, not_forall]
refine ‚ü®X, _‚ü©
simp only [algebra.mem_bot, not_exists, set.mem_range, iff_true, algebra.mem_top, algebra_map_apply, not_forall]
intro x
rw [ext_iff, not_forall]
refine ‚ü®1, _‚ü©
simp [coeff_C]
rintros ‚ü®‚ü©
simp [neg_to_finsupp, add_to_finsupp, ‚Üê zero_to_finsupp]
rintro ‚ü®‚ü©
simp [smul_to_finsupp, ‚Üê zero_to_finsupp]
rintros n ‚ü®‚ü©
simp [smul_to_finsupp, add_to_finsupp, add_smul, add_comm]
rintros n ‚ü®‚ü©
simp [add_smul, add_mul]
simp only [smul_to_finsupp, neg_to_finsupp]
rw [coeff_C_mul, coeff_smul, smul_eq_mul]
ext
simp [coeff_X_pow]
rw [add_comm _ X, coeff_X_add_one_pow]
simp [bit1, add_mul, coeff_bit0_mul]
simp
rw [C_mul_X_pow_eq_monomial]
exact support_monomial _ _ h
cases le_max_iff.1 (degree_add_le p q)
cases le_max_iff.1 (degree_add_le p q); simp [nat_degree_le_nat_degree h]
simp [nat_degree_le_nat_degree h]
simp [nat_degree_le_nat_degree h]
simp only [monomial_eq_C_mul_X.symm]
convert degree_sum_le _ _
exact mul_eq_sum_sum
refine finset.sup_le (Œª a ha, finset.sup_le (Œª b hb, le_trans (degree_C_mul_X_pow_le _ _) _))
rw [with_bot.coe_add]
rw mem_support_iff at ha hb
exact add_le_add (le_degree_of_ne_zero ha) (le_degree_of_ne_zero hb)
exact hp.ne_zero
nontriviality R
apply nat_degree_eq_of_degree_eq; rw [degree_add_eq_of_leading_coeff_add_ne_zero hlc, h, max_self]
apply nat_degree_eq_of_degree_eq
rw [degree_add_eq_of_leading_coeff_add_ne_zero hlc, h, max_self]
simp only [leading_coeff, this, nat_degree_eq_of_degree_eq h, coeff_add]
rw [H, leading_coeff_eq_zero.1 H, zero_mul, leading_coeff_zero]
rw [leading_coeff_mul', hq.leading_coeff, mul_one]; rwa [hq.leading_coeff, mul_one]
rw [leading_coeff_mul', hq.leading_coeff, mul_one]
rwa [hq.leading_coeff, mul_one]
haveI : is_commutative (with_bot ‚Ñï) max := ‚ü®max_comm‚ü©
haveI : is_associative (with_bot ‚Ñï) max := ‚ü®max_assoc‚ü©
calc (‚àë i, C (f i) * X ^ (i : ‚Ñï)).degree ‚â§ finset.univ.fold (‚äî) ‚ä• (Œª i, (C (f i) * X ^ (i : ‚Ñï)).degree) : degree_sum_le _ _ ... = finset.univ.fold max ‚ä• (Œª i, (C (f i) * X ^ (i : ‚Ñï)).degree) : rfl ... < n : (finset.fold_max_lt (n : with_bot ‚Ñï)).mpr ‚ü®with_bot.bot_lt_coe _, _‚ü©
rintros ‚ü®i, hi‚ü© -
calc (C (f ‚ü®i, hi‚ü©) * X ^ i).degree ‚â§ (C _).degree + (X ^ i).degree : degree_mul_le _ _ ... ‚â§ 0 + i : add_le_add degree_C_le (degree_X_pow_le i) ... = i : zero_add _ ... < n : with_bot.some_lt_some.mpr hi
rw [degree_add_eq_left_of_degree_lt this, degree_X]
refine eq_nat_degree_of_le_mem_support (nat_degree_C_mul_le a p) _
refine mem_support_iff.mpr _
rwa coeff_C_mul
rw [h0, nat_degree_zero]
rw [h0, nat_degree_zero]; exact nat.zero_le _
exact nat.zero_le _
rw [nat_degree_C, with_bot.coe_zero, zero_add, ‚Üê with_bot.coe_nsmul, nsmul_eq_mul]
rw [nat_degree_C, with_bot.coe_zero, zero_add, ‚Üê with_bot.coe_nsmul, nsmul_eq_mul]; simp
simp
rw [C_mul_X_pow_eq_monomial, trailing_degree_monomial ha]
contrapose! hp
simpa
rw [next_coeff_up, if_neg]
rw [eval‚ÇÇ_C, derivative_C, eval‚ÇÇ_zero, zero_mul]
rw [eval‚ÇÇ_add, derivative_add, ih‚ÇÅ, ih‚ÇÇ, derivative_add, eval‚ÇÇ_add, add_mul]
rw [pow_succ', ‚Üê mul_assoc, eval‚ÇÇ_mul, eval‚ÇÇ_X, derivative_mul, ih, @derivative_mul _ _ _ X, derivative_X, mul_one, eval‚ÇÇ_add, @eval‚ÇÇ_mul _ _ _ _ X, eval‚ÇÇ_X, add_mul, mul_right_comm]
rw [this (p /‚Çò q), this p, this q]; refl
refl
rw [this (p /‚Çò q), this p, this q]
rwa [(‚â†), div_by_monic_eq_zero_iff hq hq0, not_lt]
rwa [monic.def.1 hq, one_mul, (‚â†), leading_coeff_eq_zero]
rw [degree_mul' hlc, degree_eq_nat_degree hq0, degree_eq_nat_degree hdiv0, ‚Üê with_bot.coe_add, with_bot.coe_le_coe]
rw [degree_mul' hlc, degree_eq_nat_degree hq0, degree_eq_nat_degree hdiv0, ‚Üê with_bot.coe_add, with_bot.coe_le_coe]; exact nat.le_add_right _ _
exact nat.le_add_right _ _
simp only [hp0, zero_div_by_monic, le_refl]
rw [‚Üê degree_add_div_by_monic hq h, degree_eq_nat_degree hq0, degree_eq_nat_degree (mt (div_by_monic_eq_zero_iff hq hq0).1 (not_lt.2 h))]
rw [‚Üê degree_add_div_by_monic hq h, degree_eq_nat_degree hq0, degree_eq_nat_degree (mt (div_by_monic_eq_zero_iff hq hq0).1 (not_lt.2 h))]; exact with_bot.coe_le_coe.2 (nat.le_add_left _ _)
exact with_bot.coe_le_coe.2 (nat.le_add_left _ _)
unfold div_by_monic div_mod_by_monic_aux; simp only [dif_pos hq, h, false_and, if_false, degree_zero, bot_le]
unfold div_by_monic div_mod_by_monic_aux
simp only [dif_pos hq, h, false_and, if_false, degree_zero, bot_le]
exactI nat.find (multiplicity_X_sub_C_finite a h0)
rw [‚Üê C_0, comp_C]
rw [‚Üê C_1, comp_C]
rw [is_root, eval_mul, is_root.def.1 H, zero_mul]
ext n
simp only [polynomial.sum, X_pow_eq_monomial, coeff_monomial, mul_one, finset_sum_coeff, C_mul_monomial, not_not, mem_support_iff, finset.sum_ite_eq', ite_eq_left_iff]
exact Œª h, h.symm
induction n with n ih
exact nat.not_lt_zero 1 h
{ exfalso, exact nat.not_lt_zero 1 h}
exfalso
simp only [iterated_deriv_succ]
by_cases H : n = 1
simp only [iterated_deriv_X_one, derivative_one]
{ rw H, simp only [iterated_deriv_X_one, derivative_one] }
rw H
replace h : 1 < n := array.push_back_idx h (ne.symm H)
simp only [derivative_zero]
rw ih h
by_cases hq : q = 0; simp [h.mul_left_ne_zero, hq]
by_cases hq : q = 0
simp [h.mul_left_ne_zero, hq]
simp [h.mul_left_ne_zero, hq]
refine le_antisymm _ _
rw degree_le_iff_coeff_zero
intros m hm
rw degree_lt_iff_coeff_zero at hm
{ rw degree_le_iff_coeff_zero, intros m hm, rw degree_lt_iff_coeff_zero at hm, simp [hm m le_rfl] }
simp [hm m le_rfl]
rw degree_le_iff_coeff_zero
intros m hm
rw degree_lt_iff_coeff_zero at hm
refine h _
simpa using hm m le_rfl
rw h‚ÇÅ at h‚ÇÇ; exact absurd h‚ÇÇ dec_trivial
exact absurd h‚ÇÇ dec_trivial
rw h‚ÇÅ at h‚ÇÇ
rw [hg, degree_mul, degree_X_sub_C, degree_eq_zero_of_is_unit hgu, add_zero]
obtain ‚ü®r, hr‚ü© := hdiv
have rzero : r ‚â† 0
intro h
{ intro h, simpa [h, monic.ne_zero hq] using hr }
simpa [h, monic.ne_zero hq] using hr
rw [hr, nat_degree_mul (monic.ne_zero hp) rzero] at hdeg
have hdegeq : p.nat_degree + r.nat_degree = p.nat_degree
suffices hdegle : p.nat_degree ‚â§ p.nat_degree + r.nat_degree
{ exact le_antisymm hdeg hdegle }
exact le_antisymm hdeg hdegle
{ suffices hdegle : p.nat_degree ‚â§ p.nat_degree + r.nat_degree, { exact le_antisymm hdeg hdegle }, exact nat.le.intro rfl }
exact nat.le.intro rfl
replace hdegeq := eq_C_of_nat_degree_eq_zero (((@add_right_inj _ _ p.nat_degree) _ 0).1 hdegeq)
suffices hlead : 1 = r.leading_coeff
have hcoeff := leading_coeff_C (r.coeff 0)
rw [‚Üê hdegeq, ‚Üê hlead] at hcoeff
rw [‚Üê hcoeff, C_1] at hdegeq
{ have hcoeff := leading_coeff_C (r.coeff 0), rw [‚Üê hdegeq, ‚Üê hlead] at hcoeff, rw [‚Üê hcoeff, C_1] at hdegeq, rwa [hdegeq, mul_one] at hr }
rwa [hdegeq, mul_one] at hr
have hprod : q.leading_coeff = p.leading_coeff * r.leading_coeff
{ simp only [hr, leading_coeff_mul] }
simp only [hr, leading_coeff_mul]
rwa [monic.leading_coeff hp, monic.leading_coeff hq, one_mul] at hprod
rw [‚Üê supp_preservation_iff_liftp_preservation, supp_preservation_iff_uniform]
apply cofix.bisim_rel
intros x y rxy
rcases (liftr_iff (rel_last Œ± r) _ _).mp (h x y rxy) with ‚ü®a, f‚ÇÄ, f‚ÇÅ, dxeq, dyeq, h'‚ü©
rw [dxeq, dyeq, ‚Üêabs_map, ‚Üêabs_map, mvpfunctor.map_eq, mvpfunctor.map_eq]
rw [‚Üêsplit_drop_fun_last_fun f‚ÇÄ, ‚Üêsplit_drop_fun_last_fun f‚ÇÅ]
rw [append_fun_comp_split_fun, append_fun_comp_split_fun]
rw [id_comp, id_comp]
cases i with _ i
cases i with _ i; dsimp
congr' 2 with i j
dsimp
dsimp
apply h' _ j
{ apply quot.sound, apply h' _ j }
apply quot.sound
apply h' _ j
change f‚ÇÄ _ j = f‚ÇÅ _ j
have : cofix.mk ‚àò cofix.dest = @_root_.id (cofix F Œ±) := funext cofix.mk_dest
rw [cofix.mk, cofix.dest_corec, ‚Üêcomp_map, ‚Üêcofix.mk, ‚Üê append_fun_comp, this, id_comp, append_fun_id_id, mvfunctor.id_map]
split
intros h Œ± a a' f f' h'
{ intros h Œ± a a' f f' h', rw [‚Üê pfunctor.supp_eq,‚Üê pfunctor.supp_eq,‚Üê h,h',h] }
rw [‚Üê pfunctor.supp_eq,‚Üê pfunctor.supp_eq,‚Üê h,h',h]
rwa [supp_eq_of_is_uniform,pfunctor.supp_eq]
rintros h Œ± ‚ü®a,f‚ü©
rw mk_pnat
simp
refl
rcases h with ‚ü®c, rfl‚ü©
simp only [mul_comm b, nat.mul_div_assoc c (dvd_refl b), nat.cast_mul, mul_div_assoc, coe_nat_div_self]
rw [‚Üê(@num_denom n), inv_def]
conv in n‚Åª¬π.denom { rw [‚Üê(@num_denom n), inv_def] }
conv in n‚Åª¬π.denom { rw [‚Üê(@num_denom n), inv_def] }; apply denom_dvd
apply denom_dvd
have := congr_arg (coe : ‚Ñ§ ‚Üí Œ±) e; rwa [int.cast_mul, int.cast_coe_nat, h, zero_mul] at this
have := congr_arg (coe : ‚Ñ§ ‚Üí Œ±) e
rwa [int.cast_mul, int.cast_coe_nat, h, zero_mul] at this
rw [division_def, cast_mul_of_ne_zero md (mt this nn), cast_inv_of_ne_zero nn nd, division_def]
rw [div_eq_mul_inv, div_eq_mul_inv, int.cast_neg, neg_mul_eq_neg_mul]
simp [rat.floor]
rw [num_denom']
have h' := int.coe_nat_lt.2 h
to_rhs
conv { to_rhs, rw [coe_int_eq_mk, rat.le_def zero_lt_one h', mul_one] }
rw [coe_int_eq_mk, rat.le_def zero_lt_one h', mul_one]
exact int.le_div_iff_mul_le h'
simp only [lt_iff_le_not_le]
apply and_congr
{ simp [div_num_denom, (rat.le_def b_pos d_pos)] }
simp [div_num_denom, (rat.le_def b_pos d_pos)]
simp [div_num_denom, (rat.le_def d_pos b_pos)]
apply not_iff_not_of_iff
apply_instance
apply_instance
apply_instance
rw le_iff_lt_or_eq; exact or_congr const_lt const_equiv
exact or_congr const_lt const_equiv
rw le_iff_lt_or_eq
rw [sub_apply, const_apply, le_sub_iff_add_le', add_le_add_iff_right]
exact le_of_lt (abs_lt.1 (H _)).2
have KK := mul_pos K0 K0
have ŒµK := mul_pos Œµ0 KK
refine ‚ü®_, ŒµK, Œª a b ha hb h, _‚ü©
have a0 := lt_of_lt_of_le K0 ha
have b0 := lt_of_lt_of_le K0 hb
rw [inv_sub_inv ((abv_pos abv).1 a0) ((abv_pos abv).1 b0), abv_div abv, abv_mul abv, mul_comm, abv_sub abv, ‚Üê mul_div_cancel Œµ (ne_of_gt KK)]
exact div_lt_div h (mul_le_mul hb ha (le_of_lt K0) (abv_nonneg abv _)) (le_of_lt $ mul_pos Œµ0 KK) KK
rwa ‚Üê lim_eq_zero_iff at hf
rw [‚Üê one_mul g, ‚Üê mul_assoc, ‚Üê sub_mul, mul_one, mul_comm, mul_comm f]
rw [‚Üê one_mul g, ‚Üê mul_assoc, ‚Üê sub_mul, mul_one, mul_comm, mul_comm f]; exact mul_lim_zero_right _ (setoid.symm (cau_seq.inv_mul_cancel _))
exact mul_lim_zero_right _ (setoid.symm (cau_seq.inv_mul_cancel _))
rw [sub_mul, ‚Üê sub_add, sub_sub, sub_add_eq_sub_sub, sub_right_comm, sub_add]; exact show lim_zero (inv f hf - const abv (lim f) * (inv f hf * const abv (lim f)‚Åª¬π) - (const abv (lim f)‚Åª¬π - f * (inv f hf * const abv (lim f)‚Åª¬π))), from sub_lim_zero (by rw [‚Üê mul_assoc, mul_right_comm, const_inv hl]; exact h‚ÇÅ _ _ _) (by rw [‚Üê mul_assoc]; exact h‚ÇÅ _ _ _)
rw [sub_mul, ‚Üê sub_add, sub_sub, sub_add_eq_sub_sub, sub_right_comm, sub_add]
exact show lim_zero (inv f hf - const abv (lim f) * (inv f hf * const abv (lim f)‚Åª¬π) - (const abv (lim f)‚Åª¬π - f * (inv f hf * const abv (lim f)‚Åª¬π))), from sub_lim_zero (by rw [‚Üê mul_assoc, mul_right_comm, const_inv hl]; exact h‚ÇÅ _ _ _) (by rw [‚Üê mul_assoc]; exact h‚ÇÅ _ _ _)
rw [‚Üê mul_assoc, mul_right_comm, const_inv hl]
rw [‚Üê mul_assoc, mul_right_comm, const_inv hl]; exact h‚ÇÅ _ _ _
exact h‚ÇÅ _ _ _
rw [‚Üê mul_assoc]
rw [‚Üê mul_assoc]; exact h‚ÇÅ _ _ _
exact h‚ÇÅ _ _ _
rw inv_one
rw inv_one
rcases eq_or_ne b ‚àû with rfl|hb
simpa [left_ne_zero_of_mul_eq_one h] using h
have : false
{ have : false, by simpa [left_ne_zero_of_mul_eq_one h] using h, exact this.elim }
exact this.elim
rw [‚Üê mul_one a, ‚Üê mul_inv_cancel (right_ne_zero_of_mul_eq_one h) hb, ‚Üê mul_assoc, h, one_mul]
simp only [ha, top_add, top_to_real, zero_add, to_real_nonneg]
simp only [hb, add_top, top_to_real, add_zero, to_real_nonneg]
lift a to ‚Ñù‚â•0 using ha
lift b to ‚Ñù‚â•0 using hb
simp only [coe_eq_coe, nnreal.coe_eq, coe_to_real]
simp_rw [ennreal.of_real, ‚Üêcoe_finset_prod, coe_eq_coe]
exact real.to_nnreal_prod_of_nonneg hf
have : ‚Üëa.to_nnreal = a := ennreal.coe_to_nnreal (lt_of_le_of_lt h coe_lt_top).ne
rw ‚Üê this at h
exact_mod_cast h
rwa [‚Üê pos_iff_ne_zero, ‚Üê add_lt_add_iff_left ha, add_zero] at hb
simp [add_eq_top]
simp only [hr, inv_zero, coe_zero, le_top]
simp only [coe_inv hr, le_refl]
rw [‚Üêereal.neg_neg a, h, ereal.neg_neg b]
rw [neg_lt, ‚Üê inv_gold]
exact inv_lt_one one_lt_gold
convert add_lt_add hxr'.1 hys'.1 using 1; norm_cast; linarith
convert add_lt_add hxr'.1 hys'.1 using 1; norm_cast
norm_cast
linarith
convert add_lt_add hxr'.1 hys'.1 using 1
convert add_lt_add hxr'.2 hys'.2 using 1; norm_cast; linarith
convert add_lt_add hxr'.2 hys'.2 using 1; norm_cast
norm_cast
linarith
convert add_lt_add hxr'.2 hys'.2 using 1
linarith
linarith
norm_cast at *
rw H1 at hxr'
rw H2 at hys'
exact lt_trans hxr' hys'
rw iff_eq_eq
rw iff_eq_eq; refl
refl
rw [‚Üênnreal.coe_eq, nnreal.coe_prod, real.coe_to_nnreal _ (finset.prod_nonneg hf)]
exact finset.prod_congr rfl (Œª x hxs, by rw real.coe_to_nnreal _ (hf x hxs))
rw real.coe_to_nnreal _ (hf x hxs)
rcases le_iff_exists_add.1 (le_of_lt hxb) with ‚ü®Œµ, rfl‚ü©
exact h _ ((lt_add_iff_pos_right b).1 hxb)
rw [mul_self_le_mul_self_iff hx (sqrt_nonneg _), sq, mul_self_sqrt hy]
split
{ simpa only [abs_le] using abs_le_sqrt }
simpa only [abs_le] using abs_le_sqrt
rw [‚Üê abs_le, ‚Üê sq_abs]
exact (le_sqrt (abs_nonneg x) h).mp
rw [sqrt_eq_iff_sq_eq, mul_mul_mul_comm, mul_self_sqrt, mul_self_sqrt]
simp
simp
simp; exact Œª c, ‚ü®Œª ‚ü®b, ‚ü®a, as, bf‚ü©, cg‚ü©, ‚ü®a, as, b, bf, cg‚ü©, Œª ‚ü®a, as, b, bf, cg‚ü©, ‚ü®b, ‚ü®a, as, bf‚ü©, cg‚ü©‚ü©
exact Œª c, ‚ü®Œª ‚ü®b, ‚ü®a, as, bf‚ü©, cg‚ü©, ‚ü®a, as, b, bf, cg‚ü©, Œª ‚ü®a, as, b, bf, cg‚ü©, ‚ü®b, ‚ü®a, as, bf‚ü©, cg‚ü©‚ü©
simp
simp [eq_comm]
induction h with n h IH
exacts [id, Œª h2, al (IH h2)]
cases s with f al
unfold has_orelse.orelse
unfold has_orelse.orelse; simp [orelse]
simp [orelse]
apply cb.cases_on (Œª b, _) (Œª cb, _)
exact ‚ü®Œª h, ‚ü®_, ret_mem _, h‚ü©, Œª ‚ü®b', mb, h‚ü©, by rw [mem_unique (ret_mem _) mb]; exact h‚ü©
rw [mem_unique (ret_mem _) mb]; exact h
exact h
{ exact ‚ü®Œª h, ‚ü®_, ret_mem _, h‚ü©, Œª ‚ü®b', mb, h‚ü©, by rw [mem_unique (ret_mem _) mb]; exact h‚ü© }
rw [mem_unique (ret_mem _) mb]
rw [destruct_think]
exact ‚ü®Œª ‚ü®b, h, r‚ü©, ‚ü®b, think_mem h, r‚ü©, Œª ‚ü®b, h, r‚ü©, ‚ü®b, of_think_mem h, r‚ü©‚ü©
unfold destruct head; cases nth s 0; refl
unfold destruct head; cases nth s 0
cases nth s 0
refl
refl
unfold destruct head
dsimp [corec, destruct, nth]
change stream.corec' (corec.F f) (some b) 0 with (corec.F f (some b)).1
dsimp [corec.F]
refl
{ refl }
induction h : f b with s
dsimp [corec.F]
cases s with a b'
apply congr_arg (Œª b', some (a, b'))
apply subtype.eq
dsimp [corec, tail]
rw [stream.corec'_eq, stream.tail_cons]
rw h
refl
dsimp [corec.F]
apply mem_rec_on h; intros; simp [*]
apply mem_rec_on h; intros
intros
simp [*]
apply mem_rec_on h
apply eq_of_bisim (Œª c1 c2, ‚àÉ s t, c1 = destruct (append s t) ‚àß c2 = (destruct s).bind (destruct_append.aux t)) _ ‚ü®s, t, rfl, rfl‚ü©
rcases h with ‚ü®s, t, h‚ü©
intros c1 c2 h
rw [h.left, h.right]
apply s.cases_on _ (Œª a s, _) (Œª s, _)
apply s.cases_on _ (Œª a s, _) (Œª s, _); simp
simp
simp
simp
apply t.cases_on _ (Œª b t, _) (Œª t, _); simp
simp
simp
simp
apply t.cases_on _ (Œª b t, _) (Œª t, _)
refine ‚ü®nil, t, _, _‚ü©; simp
simp
simp
{ apply t.cases_on _ (Œª b t, _) (Œª t, _); simp, { refine ‚ü®nil, t, _, _‚ü©; simp } }
refine ‚ü®nil, t, _, _‚ü©
exact ‚ü®s, t, rfl, rfl‚ü©
simp [ret]; apply think_equiv
apply think_equiv
simp [ret]
simp [destruct, cons, computation.rmap]
rw add_comm; symmetry; apply dropn_add
rw add_comm; symmetry
symmetry
apply dropn_add
rw add_comm
unfold functor.map
simp [join, cons, append]
simp [think, join]
rw ‚Üêlift_rel.swap at H; exact exists_of_lift_rel_left H h
exact exists_of_lift_rel_left H h
rw ‚Üêlift_rel.swap at H
cases o with a; injection oe with h'; exact ‚ü®a, om, h'‚ü©
cases o with a; injection oe with h'
injection oe with h'
injection oe with h'
exact ‚ü®a, om, h'‚ü©
cases o with a
subst hT'
cases set.mem_Union.1 x.prop with i hi
rw [Union_lift_of_mem x hi, ‚Üê h i]
have : x = (set.inclusion (set.subset_Union S i) ‚ü®x, hi‚ü©)
cases x
refl
{ cases x, refl }
have hx' : (set.inclusion (set.subset_Union S i) (ui i ‚ü®x, hi‚ü©) : Œ±) ‚àà S i
from (ui i ‚ü®x, hi‚ü©).prop
rw [this, hui, Union_lift_inclusion]
conv_lhs { rw [this, hui, Union_lift_inclusion] }
simp
refine (iff.symm $ iff.intro (image_subset f) $ assume h, _)
rw [‚Üê preimage_image_eq s hf, ‚Üê preimage_image_eq t hf]
exact preimage_mono h
exact hx
rintro rfl x hx
split
refine ‚ü®coe '' s, _, hs‚ü©
rintro ‚ü®s, hs‚ü©
rw [range_coe]
{ rintro ‚ü®s, hs‚ü©, refine ‚ü®coe '' s, _, hs‚ü©, convert image_subset_range _ _, rw [range_coe] }
convert image_subset_range _ _
refine ‚ü®coe ‚Åª¬π' s, _‚ü©
rintro ‚ü®s, hs‚ÇÅ, hs‚ÇÇ‚ü©
exact hs‚ÇÇ
rw [image_preimage_eq_of_subset]
rw [range_coe]
exact hs‚ÇÅ
rw [inter_comm, ‚Üê image_preimage_coe, nonempty_image_iff]
simp
ext
simp [and_comm]
ext ‚ü®x, y‚ü©
simp
simp
simp
ext
split
refine ‚ü®a, b, ha, hb, rfl‚ü©
rintro ‚ü®_, b, ‚ü®a, ha, rfl‚ü©, hb, rfl‚ü©
{ rintro ‚ü®_, b, ‚ü®a, ha, rfl‚ü©, hb, rfl‚ü©, refine ‚ü®a, b, ha, hb, rfl‚ü© }
refine ‚ü®_, b, ‚ü®a, ha, rfl‚ü©, hb, rfl‚ü©
rintro ‚ü®a, b, ha, hb, rfl‚ü©
exact Œª x, or_imp_distrib
rw bUnion_eq_Union
haveI := hs.to_encodable
simpa using ht
exact countable_Union (by simpa using ht)
haveI : encodable s := hs.to_encodable
haveI : encodable t := ht.to_encodable
apply_instance
haveI : encodable (s √ó t)
{ apply_instance }
have : range (prod.map coe coe : s √ó t ‚Üí Œ± √ó Œ≤) = set.prod s t
rw [range_prod_map, subtype.range_coe, subtype.range_coe]
rw ‚Üê this
exact countable_range _
apply_instance
simpa only [exists_prop, finite.mem_to_finset] using h1.to_finset.exists_min_image f ‚ü®x, h1.mem_to_finset.2 hx‚ü©
rwa [‚Üê hx, h hs]
refine ‚ü®_, h.right_inv_on_inv_fun_on‚ü©
rintros _ ‚ü®y, hy, rfl‚ü©
rw [h.right_inv_on_inv_fun_on hy]
exact h.inj_on_image (ha.inj_on univ) hf
rw ‚Üê image_univ at *
rw [Ioc_union_Ioc, min_self]; exact (min_le_left _ _).trans (le_max_left _ _)
exact (min_le_left _ _).trans (le_max_left _ _)
exact (min_le_left _ _).trans (le_max_left _ _)
rw [Ioc_union_Ioc, min_self]
simp [‚Üê Ici_inter_Iio]
rw [e.image_eq_preimage, e.symm.preimage_Ioo, e.symm_symm]
rw [insert_eq, ‚Üê diff_diff, Icc_diff_left, Ioc_diff_right]
rw [‚Üê Icc_diff_left, diff_diff_cancel_left (singleton_subset_iff.2 $ left_mem_Icc.2 h)]
simpa only [dual_Ioc, dual_Icc] using @Ioc_union_left (order_dual Œ±) _ b a hab
rw [diff_eq, compl_Ici, Ioi_inter_Iio]
cases le_total a b with hab hab; simp [hab] at h
simp [hab] at h
simp [hab] at h
cases le_total a b with hab hab
{ exact Ioo_union_Ioi' h }
exact Ioo_union_Ioi' h
rw min_comm
simp [*, min_eq_left_of_lt]
simp [‚Üê Ioi_inter_Iio]
simp [add_comm]
cases eq_or_lt_of_le hc
subst c
{ subst c, simp [(nonempty_Icc.2 hab).image_const] }
simp [(nonempty_Icc.2 hab).image_const]
exact image_mul_right_Icc' a b ‚Äπ0 < c‚Ä∫
intros a‚ÇÅ a‚ÇÇ ha
have ha' : ‚Üëa‚ÇÅ < ‚Üëa‚ÇÇ := ha
obtain ‚ü®x, ha‚ÇÅx, hxa‚ÇÇ‚ü© := exists_between ha'
refine ‚ü®‚ü®x, _‚ü©, ‚ü®ha‚ÇÅx, hxa‚ÇÇ‚ü©‚ü©
exact (hs.out a‚ÇÅ.2 a‚ÇÇ.2) (Ioo_subset_Icc_self ‚ü®ha‚ÇÅx, hxa‚ÇÇ‚ü©)
simp {contextual := tt}
simp {contextual := tt}
simp only [sUnion_eq_bUnion, prod_bUnion, bUnion_image]
classical
apply subset.antisymm
{ simp [Inter_subset] }
simp [Inter_subset]
intros y y_in
simp only [mem_image, mem_Inter, mem_preimage]
rcases hv with ‚ü®z, hz‚ü©
refine ‚ü®function.update z i y, _, update_same i y z‚ü©
rw @forall_update_iff Œπ Œ± _ z i y (Œª i t, t ‚àà v i)
simpa using hz j
exact ‚ü®y_in, Œª j hj, by simpa using hz j‚ü©
simp only [Union_or, Union_union_distrib, Union_Union_eq_left]
rw [Union_nonempty_index, bUnion_self]
simp
simpa [pairwise, function.on_fun] using @hr a b
simp [ker_def, quotient.sound h]
ext ‚ü®x‚ü©
erw [quotient.lift_mk f H, Hg]
refl
exact hf (f a)
rw [‚Üêas_string_inv_to_list s, list.as_string_inj, as_string_inv_to_list s]
cases s'
delta cons
simp
cases s
ext i x; induction i; dsimp only [id, to_subtype', comp, subtype_val, prod.mk] at *; simp *
ext i x; induction i; dsimp only [id, to_subtype', comp, subtype_val, prod.mk] at *
ext i x; induction i
induction i
dsimp only [id, to_subtype', comp, subtype_val, prod.mk] at *
dsimp only [id, to_subtype', comp, subtype_val, prod.mk] at *
ext i x
simp *
simp *
simp [*, left]
simp [*, left]
casesI n
{ apply int.cast_mul }
apply int.cast_mul
simp only [coe_coe]
symmetry
erw [fin.coe_mul, ‚Üê nat.cast_mul, ‚Üê sub_eq_zero, ‚Üê nat.cast_sub (nat.mod_le _ _), @char_p.cast_eq_zero_iff R _ _ m]
exact h.trans (nat.dvd_sub_mod _)
refine {..}
refine {..}; intros; refl
refine {..}; intros
intros
intros
intros
intros
refl
refl
refl
refl
simpa using h this
simp [hf.map_one]; rwa [mem_ker] at hx
rwa [mem_ker] at hx
simp [hf.map_one]
simp [mem_ker, hf.map_one] {contextual := tt}
simp only [pow_add, *]
rw [mul_assoc, list.prod_cons, ‚Üê hyzx]
rw [mul_assoc, list.prod_cons, ‚Üê hyzx]; refl
refl
rw [‚Üê mul_assoc, list.prod_cons, ‚Üê hyzx, mul_comm hd]
rw [‚Üê mul_assoc, list.prod_cons, ‚Üê hyzx, mul_comm hd]; refl
refl
simp only [‚Üê gsmul_eq_mul, of_add_gsmul, monoid_hom.map_gpow]
simpa only [nsmul_eq_mul, add_right_iterate] using (f.commute_add_int m).iterate_pos_eq_iff_map_eq f.monotone (strict_mono_id.add_const m) hn
simpa only [not_le] using not_congr (f.iterate_pos_le_iff hn)
simp [transnum_aux_seq]
rw [‚Üê translation_number_conj_eq' (translate $ multiplicative.of_add x)]
convert tendsto_translation_number‚ÇÄ _
ext n
simp [sub_eq_neg_add, units.conj_pow']
have A : ‚àÄ m, measurable_set (f^[m] ‚Åª¬π' s) := Œª m, (hf.iterate m).measurable hs
have B : ‚àÄ m, Œº (f^[m] ‚Åª¬π' s) = Œº s
from Œª m, (hf.iterate m).measure_preimage hs
have : Œº (univ : set Œ±) < (finset.range n).sum (Œª m, Œº (f^[m] ‚Åª¬π' s))
simpa only [B, nsmul_eq_mul, finset.sum_const, finset.card_range]
rcases exists_nonempty_inter_of_measure_univ_lt_sum_measure Œº (Œª m hm, A m) this with ‚ü®i, hi, j, hj, hij, x, hxi, hxj‚ü©
wlog hlt : i < j := hij.lt_or_lt using [i j, j i] tactic.skip
simp only [set.mem_preimage, finset.mem_range] at hi hj hxi hxj
refine ‚ü®f^[i] x, hxi, j - i, ‚ü®nat.sub_pos_of_lt hlt, lt_of_le_of_lt (j.sub_le i) hj‚ü©, _‚ü©
{ simp only [set.mem_preimage, finset.mem_range] at hi hj hxi hxj, refine ‚ü®f^[i] x, hxi, j - i, ‚ü®nat.sub_pos_of_lt hlt, lt_of_le_of_lt (j.sub_le i) hj‚ü©, _‚ü©, rwa [‚Üê iterate_add_apply, nat.sub_add_cancel hlt.le] }
rwa [‚Üê iterate_add_apply, nat.sub_add_cancel hlt.le]
exact Œª hi hj hij hxi hxj, this hj hi hij.symm hxj hxi
rw [‚Üê map_add, neg_add_self, map_zero_apply]
rw [‚Üê map_add, add_neg_self, map_zero_apply]
simp only [mul_comm n, hm.mul_const n]
simp only [minimal_period, dif_pos hx, gt_iff_lt.1 (nat.find_spec hx).fst]
ext
rw iff_true_right intermediate_field.mem_top
exact dim_adjoin_simple_eq_one_iff.mp (h x)
rintros ‚ü®x1, x2‚ü© ‚ü®y1, y2‚ü© ‚ü®hxy1, hxy2‚ü© ‚ü®hyx1, hyx2‚ü©
have : x1 = y1 := le_antisymm hxy1 hyx1
subst this
congr
exact alg_hom.ext (Œª s, hxy2 s s rfl)
cases intermediate_field.mem_bot.mp s.mem with u hu
rw [show s = (algebra_map F _) u, from subtype.ext hu.symm, alg_hom.commutes]
rw [show t = (algebra_map F _) u, from subtype.ext (eq.trans hu hst).symm, alg_hom.commutes]
rw [mem_to_subalgebra, algebra.mem_bot, mem_bot]
ext
rw [‚Üê card_units p, pow_card_eq_one]
refine top_unique (set_like.le_def.2 $ assume e _, mem_map.2 _)
refine ‚ü®‚àë n : œÉ ‚Üí K, e n ‚Ä¢ indicator n, _, _‚ü©
exact sum_mem _ (assume c _, smul_mem _ _ (indicator_mem_restrict_degree _))
{ exact sum_mem _ (assume c _, smul_mem _ _ (indicator_mem_restrict_degree _)) }
ext n
simp only [linear_map.map_sum, @finset.sum_apply (œÉ ‚Üí K) (Œª_, K) _ _ _ _ _, pi.smul_apply, linear_map.map_smul]
simp only [eval‚Çó_apply]
transitivity
refine finset.sum_eq_single n _ _
assume b _ h
{ assume b _ h, rw [eval_indicator_apply_eq_zero _ _ h.symm, smul_zero] }
rw [eval_indicator_apply_eq_zero _ _ h.symm, smul_zero]
exact (h $ finset.mem_univ n).elim
{ assume h, exact (h $ finset.mem_univ n).elim }
assume h
rw [eval_indicator_apply_eq_one, smul_eq_mul, mul_one]
let b := basis.of_vector_space K V
rw [‚Üê b.mk_eq_dim'', lt_omega_iff_finite]
split
introI
exact finite_of_linear_independent (basis.of_vector_space_index.linear_independent K V)
{ introI, exact finite_of_linear_independent (basis.of_vector_space_index.linear_independent K V) }
assume hbfinite
refine @is_noetherian_of_linear_equiv K (‚ä§ : submodule K V) V _ _ _ _ _ (linear_equiv.of_top _ rfl) (id _)
refine is_noetherian_of_fg_of_noetherian _ ‚ü®set.finite.to_finset hbfinite, _‚ü©
rw [set.finite.coe_to_finset, ‚Üê b.span_eq, basis.coe_of_vector_space, subtype.range_coe]
have K_le : K ‚â§ intermediate_field.fixed_field (intermediate_field.fixing_subgroup K) := (intermediate_field.le_iff_le _ _).mpr (le_refl _)
suffices : finrank K E = finrank (intermediate_field.fixed_field (intermediate_field.fixing_subgroup K)) E
exact (intermediate_field.eq_of_le_of_finrank_eq' K_le this).symm
{ exact (intermediate_field.eq_of_le_of_finrank_eq' K_le this).symm }
rw [intermediate_field.finrank_fixed_field_eq_card, fintype.card_congr (intermediate_field.fixing_subgroup_equiv K).to_equiv]
exact (card_aut_eq_finrank K E).symm
rwa [key, alg_hom.map_sub, aeval_X, aeval_C, sub_eq_zero, eq_comm] at this
have := aeval A x
rw [mul_comm, coeff_expand_mul hp]
ext
have h' : (expand R n g).coeff (n * n_1) = (expand R n g').coeff (n * n_1) := begin apply polynomial.ext_iff.1, exact h, end
apply polynomial.ext_iff.1
exact h
rw [polynomial.coeff_expand hn g (n * n_1), polynomial.coeff_expand hn g' (n * n_1)] at h'
simp only [if_true, dvd_mul_right] at h'
rw (nat.mul_div_right n_1 hn) at h'
exact h'
obtain ‚ü®p, rfl‚ü© := hq
apply is_coprime_self.mp
have : is_coprime (q * (q * p)) (q * (q.derivative * p + q.derivative * p + q * p.derivative))
simp only [‚Üê mul_assoc, mul_add]
convert hp
rw [derivative_mul, derivative_mul]
{ simp only [‚Üê mul_assoc, mul_add], convert hp, rw [derivative_mul, derivative_mul], ring }
ring
exact is_coprime.of_mul_right_left (is_coprime.of_mul_left_left this)
exact algebra_map K (splitting_field_aux _ _ hfn) = (algebra_map (adjoin_root f.factor) (splitting_field_aux n f.remove_factor (nat_degree_remove_factor' hfn))).comp (adjoin_root.of f.factor)
simp only [‚Üê gsmul_one, gsmul_mem, one_mem]
simpa only [field_range_eq_map] using (‚ä§ : subfield K).map_map g f
rw [‚Üê (module.rank F K).lift_id, ‚Üê b.mk_eq_dim, ‚Üê (module.rank K A).lift_id, ‚Üê c.mk_eq_dim, ‚Üê lift_umax.{w v}, ‚Üê (b.smul c).mk_eq_dim, mk_prod, lift_mul, lift_lift, lift_lift, lift_lift, lift_lift, lift_umax]
rw [angle, ‚Üê real_inner_div_norm_mul_norm_eq_one_iff, real.arccos_eq_zero, has_le.le.le_iff_eq, eq_comm]
exact (abs_le.mp (abs_real_inner_div_norm_mul_norm_le_one x y)).2
rw [angle_comm, angle_eq_left]
ext
rw orthogonal_projection_eq_self_iff
exact orthogonal_projection_mem p
symmetry
rw [‚Üêh‚ÇÇ, t‚ÇÇ.affine_span_insert_singleton_eq_altitude_iff]
rw [h‚ÇÇ]
use t‚ÇÅ.independent.injective.ne hi‚ÇÅ‚ÇÇ
have he : affine_span ‚Ñù (set.range t‚ÇÇ.points) = affine_span ‚Ñù (set.range t‚ÇÅ.points)
refine ext_of_direction_eq _ ‚ü®t‚ÇÅ.points i‚ÇÉ, mem_affine_span ‚Ñù ‚ü®j‚ÇÉ, h‚ÇÉ‚ü©, mem_affine_span ‚Ñù (set.mem_range_self _)‚ü©
refine eq_of_le_of_finrank_eq (direction_le (span_points_subset_coe_of_subset_coe _)) _
clear h‚ÇÅ h‚ÇÇ h‚ÇÉ
have hu : (finset.univ : finset (fin 3)) = {j‚ÇÅ, j‚ÇÇ, j‚ÇÉ}
dec_trivial!
{ clear h‚ÇÅ h‚ÇÇ h‚ÇÉ, dec_trivial! }
rw [‚Üêset.image_univ, ‚Üêfinset.coe_univ, hu, finset.coe_insert, finset.coe_insert, finset.coe_singleton, set.image_insert_eq, set.image_insert_eq, set.image_singleton, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ, set.insert_subset, set.insert_subset, set.singleton_subset_iff]
exact ‚ü®t‚ÇÅ.orthocenter_mem_affine_span, mem_affine_span ‚Ñù (set.mem_range_self _), mem_affine_span ‚Ñù (set.mem_range_self _)‚ü©
{ have hu : (finset.univ : finset (fin 3)) = {j‚ÇÅ, j‚ÇÇ, j‚ÇÉ}, { clear h‚ÇÅ h‚ÇÇ h‚ÇÉ, dec_trivial! }, rw [‚Üêset.image_univ, ‚Üêfinset.coe_univ, hu, finset.coe_insert, finset.coe_insert, finset.coe_singleton, set.image_insert_eq, set.image_insert_eq, set.image_singleton, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ, set.insert_subset, set.insert_subset, set.singleton_subset_iff], exact ‚ü®t‚ÇÅ.orthocenter_mem_affine_span, mem_affine_span ‚Ñù (set.mem_range_self _), mem_affine_span ‚Ñù (set.mem_range_self _)‚ü© }
rw [direction_affine_span, direction_affine_span, t‚ÇÅ.independent.finrank_vector_span (fintype.card_fin _), t‚ÇÇ.independent.finrank_vector_span (fintype.card_fin _)]
{ refine ext_of_direction_eq _ ‚ü®t‚ÇÅ.points i‚ÇÉ, mem_affine_span ‚Ñù ‚ü®j‚ÇÉ, h‚ÇÉ‚ü©, mem_affine_span ‚Ñù (set.mem_range_self _)‚ü©, refine eq_of_le_of_finrank_eq (direction_le (span_points_subset_coe_of_subset_coe _)) _, { have hu : (finset.univ : finset (fin 3)) = {j‚ÇÅ, j‚ÇÇ, j‚ÇÉ}, { clear h‚ÇÅ h‚ÇÇ h‚ÇÉ, dec_trivial! }, rw [‚Üêset.image_univ, ‚Üêfinset.coe_univ, hu, finset.coe_insert, finset.coe_insert, finset.coe_singleton, set.image_insert_eq, set.image_insert_eq, set.image_singleton, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ, set.insert_subset, set.insert_subset, set.singleton_subset_iff], exact ‚ü®t‚ÇÅ.orthocenter_mem_affine_span, mem_affine_span ‚Ñù (set.mem_range_self _), mem_affine_span ‚Ñù (set.mem_range_self _)‚ü© }, { rw [direction_affine_span, direction_affine_span, t‚ÇÅ.independent.finrank_vector_span (fintype.card_fin _), t‚ÇÇ.independent.finrank_vector_span (fintype.card_fin _)] } }
rw he
use mem_affine_span ‚Ñù (set.mem_range_self _)
have hu : finset.univ.erase j‚ÇÇ = {j‚ÇÅ, j‚ÇÉ}
clear h‚ÇÅ h‚ÇÇ h‚ÇÉ
dec_trivial!
{ clear h‚ÇÅ h‚ÇÇ h‚ÇÉ, dec_trivial! }
rw [hu, finset.coe_insert, finset.coe_singleton, set.image_insert_eq, set.image_singleton, h‚ÇÅ, h‚ÇÉ]
have hle : (t‚ÇÅ.altitude i‚ÇÉ).direction·óÆ ‚â§ (affine_span ‚Ñù ({t‚ÇÅ.orthocenter, t‚ÇÅ.points i‚ÇÉ} : set P)).direction·óÆ := submodule.orthogonal_le (direction_le (affine_span_orthocenter_point_le_altitude _ _))
refine hle ((t‚ÇÅ.vector_span_le_altitude_direction_orthogonal i‚ÇÉ) _)
have hui : finset.univ.erase i‚ÇÉ = {i‚ÇÅ, i‚ÇÇ}
clear hle h‚ÇÇ h‚ÇÉ
dec_trivial!
{ clear hle h‚ÇÇ h‚ÇÉ, dec_trivial! }
rw [hui, finset.coe_insert, finset.coe_singleton, set.image_insert_eq, set.image_singleton]
refine vsub_mem_vector_span ‚Ñù (set.mem_insert _ _) (set.mem_insert_of_mem _ (set.mem_singleton _))
have h' : dist a' c' ^ 2 = (r * dist a c) ^ 2
calc dist a' c' ^ 2 = dist a' b' ^ 2 + dist c' b' ^ 2 - 2 * dist a' b' * dist c' b' * real.cos (‚à† a' b' c') : by { simp [pow_two, law_cos a' b' c'] } ... = r ^ 2 * (dist a b ^ 2 + dist c b ^ 2 - 2 * dist a b * dist c b * real.cos (‚à† a b c)) : by { rw [h, hab, hcb], ring } ... = (r * dist a c) ^ 2 : by simp [pow_two, ‚Üê law_cos a b c, mul_pow]
simp [pow_two, law_cos a' b' c']
rw [h, hab, hcb]
ring
simp [pow_two, ‚Üê law_cos a b c, mul_pow]
by_cases hab‚ÇÅ : a = b
rw [‚Üê dist_eq_zero, hab, dist_eq_zero.mpr hab‚ÇÅ, mul_zero r]
have hab'‚ÇÅ : a' = b'
{ rw [‚Üê dist_eq_zero, hab, dist_eq_zero.mpr hab‚ÇÅ, mul_zero r] }
{ have hab'‚ÇÅ : a' = b', { rw [‚Üê dist_eq_zero, hab, dist_eq_zero.mpr hab‚ÇÅ, mul_zero r] }, rw [hab‚ÇÅ, hab'‚ÇÅ, dist_comm b' c', dist_comm b c, hcb] }
rw [hab‚ÇÅ, hab'‚ÇÅ, dist_comm b' c', dist_comm b c, hcb]
rw ‚Üê hab
exact dist_nonneg
have h1 : 0 ‚â§ r * dist a b
{ rw ‚Üê hab, exact dist_nonneg }
have h2 : 0 ‚â§ r := nonneg_of_mul_nonneg_right h1 (dist_pos.mpr hab‚ÇÅ)
exact (sq_eq_sq dist_nonneg (mul_nonneg h2 dist_nonneg)).mp h'
ext x
ext x; exact algebra.commutes' _ _
exact algebra.commutes' _ _
ext x
ext x; exact algebra.smul_def' _ _
exact algebra.smul_def' _ _
refine times_cont_mdiff_of_support (Œª x hx, _)
have : x ‚àà (chart_at H c).source := f.closure_support_subset_chart_at_source hx
refine times_cont_mdiff_at.congr_of_eventually_eq _ (f.eq_on_source.eventually_eq_of_mem $ is_open.mem_nhds (chart_at _ _).open_source this)
exact f.to_times_cont_diff_bump.times_cont_diff_at.times_cont_mdiff_at.comp _ (times_cont_mdiff_at_ext_chart_at' this)
obtain ‚ü®s, hsc, hsU‚ü© : ‚àÉ s, countable s ‚àß (‚ãÉ x (hx : x ‚àà s), (chart_at H x).source) = univ := countable_cover_nhds_of_sigma_compact (Œª x : M, is_open.mem_nhds (chart_at H x).open_source (mem_chart_source H x))
exact charted_space.second_countable_of_countable_cover H hsU hsc
have E : e.target ‚à© e.symm ‚Åª¬π' e.source = e.target := subset.antisymm (inter_subset_left _ _) (Œªx hx, ‚ü®hx, local_equiv.target_subset_preimage_source _ hx‚ü©)
simpa [local_equiv.trans_source, E] using c.open_source e e he he
simp only [mem_Union, mem_singleton_iff]
exact ‚ü®c.chart_at x, c.chart_mem_atlas x, rfl‚ü©
rw [range_comp, image_eq_preimage]
apply_instance
simp
refine ‚ü®h.1.congr h‚ÇÅ hx, _‚ü©
have A : s ‚à© g' ‚Åª¬π' (chart_at H' (g' x)).source = s ‚à© g ‚Åª¬π' (chart_at H' (g' x)).source
ext y
split
assume hy
simp only with mfld_simps at hy
{ assume hy, simp only with mfld_simps at hy, simp only [hy, ‚Üê h‚ÇÅ _ hy.1] with mfld_simps }
simp only [hy, ‚Üê h‚ÇÅ _ hy.1] with mfld_simps
assume hy
simp only with mfld_simps at hy
{ ext y, split, { assume hy, simp only with mfld_simps at hy, simp only [hy, ‚Üê h‚ÇÅ _ hy.1] with mfld_simps }, { assume hy, simp only with mfld_simps at hy, simp only [hy, h‚ÇÅ _ hy.1] with mfld_simps } }
simp only [hy, h‚ÇÅ _ hy.1] with mfld_simps
have := h.2
rw [‚Üê hx, ‚Üê A] at this
convert hG.congr _ _ this using 2
assume y hy
simp only with mfld_simps at hy
simp only [hy]
have : (chart_at H x).symm y ‚àà s
{ assume y hy, simp only with mfld_simps at hy, have : (chart_at H x).symm y ‚àà s, by simp only [hy], simp only [hy, h‚ÇÅ _ this] with mfld_simps }
simp only [hy, h‚ÇÅ _ this] with mfld_simps
simp only [hx] with mfld_simps
intros s x u f hu hux
split
rintros h hx
rcases h hx.1 with ‚ü®e, heG, hef, hex‚ü©
mfld_set_tac
have : s ‚à© u ‚à© e.source ‚äÜ s ‚à© e.source := by mfld_set_tac
{ rintros h hx, rcases h hx.1 with ‚ü®e, heG, hef, hex‚ü©, have : s ‚à© u ‚à© e.source ‚äÜ s ‚à© e.source := by mfld_set_tac, exact ‚ü®e, heG, hef.mono this, hex‚ü© }
exact ‚ü®e, heG, hef.mono this, hex‚ü©
rintros h hx
rcases h ‚ü®hx, hux‚ü© with ‚ü®e, heG, hef, hex‚ü©
refine ‚ü®e.restr (interior u), _, _, _‚ü©
{ exact closed_under_restriction' heG (is_open_interior) }
exact closed_under_restriction' heG (is_open_interior)
mfld_set_tac
have : s ‚à© u ‚à© e.source = s ‚à© (e.source ‚à© u) := by mfld_set_tac
{ have : s ‚à© u ‚à© e.source = s ‚à© (e.source ‚à© u) := by mfld_set_tac, simpa only [this, interior_interior, hu.interior_eq] with mfld_simps using hef }
simpa only [this, interior_interior, hu.interior_eq] with mfld_simps using hef
simp only [*, interior_interior, hu.interior_eq] with mfld_simps
intros s x f e' he'G he'x h hx
simpa only [e'.left_inv he'x] with mfld_simps using hx.2
have hxs : x ‚àà s := by simpa only [e'.left_inv he'x] with mfld_simps using hx.2
rcases h hxs with ‚ü®e, heG, hef, hex‚ü©
refine ‚ü®e'.symm.trans e, G.trans (G.symm he'G) heG, _, _‚ü©
intros y hy
simp only with mfld_simps at hy
{ intros y hy, simp only with mfld_simps at hy, simp only [hef ‚ü®hy.1.2, hy.2.2‚ü©] with mfld_simps }
simp only [hef ‚ü®hy.1.2, hy.2.2‚ü©] with mfld_simps
simp only [hex, he'x] with mfld_simps
intros s x f g hfgs hfg' h hx
rcases h hx with ‚ü®e, heG, hef, hex‚ü©
refine ‚ü®e, heG, _, hex‚ü©
intros y hy
rw [‚Üê hef hy, hfgs y hy.1]
intros s x f e' he'G he' hfx h hx
rcases h hx with ‚ü®e, heG, hef, hex‚ü©
refine ‚ü®e.trans e', G.trans heG he'G, _, _‚ü©
intros y hy
simp only with mfld_simps at hy
{ intros y hy, simp only with mfld_simps at hy, simp only [hef ‚ü®hy.1, hy.2.1‚ü©] with mfld_simps }
simp only [hef ‚ü®hy.1, hy.2.1‚ü©] with mfld_simps
simpa only [hex, hef ‚ü®hx, hex‚ü©] with mfld_simps using hfx
simp only [tangent_map_within, id.def]
rw mfderiv_within_id
refl
{ rcases p, refl }
rcases p
exact hs
rw [‚Üê times_cont_diff_on_univ, ‚Üê times_cont_mdiff_on_univ, times_cont_mdiff_on_iff_times_cont_diff_on]
assume x
rw [times_cont_mdiff_at, times_cont_mdiff_within_at_iff]
refine ‚ü®Z.to_topological_fiber_bundle_core.continuous_proj.continuous_at.continuous_within_at, _‚ü©
simp only [(‚àò), chart_at, chart] with mfld_simps
apply times_cont_diff_within_at_fst.congr
rintros ‚ü®a, b‚ü© hab
simp only with mfld_simps at hab
{ rintros ‚ü®a, b‚ü© hab, simp only with mfld_simps at hab, simp only [hab] with mfld_simps }
simp only [hab] with mfld_simps
simp only with mfld_simps
set L := ((continuous_linear_map.fst ‚Ñù E ‚Ñù).comp (@continuous_linear_map.proj ‚Ñù _ Œπ (Œª _, E √ó ‚Ñù) _ _ (Œª _, infer_instance) (f.ind x hx)))
have := L.has_mfderiv_at.comp x f.embedding_pi_tangent.mdifferentiable_at.has_mfderiv_at
convert has_mfderiv_at_unique this _
refine (has_mfderiv_at_ext_chart_at I (f.mem_chart_at_ind_source x hx)).congr_of_eventually_eq _
refine (f.eventually_eq_one x hx).mono (Œª y hy, _)
simp only [embedding_pi_tangent_coe, continuous_linear_map.coe_comp', (‚àò), continuous_linear_map.coe_fst', continuous_linear_map.proj_apply]
rw [hy, pi.one_apply, one_smul]
rw [left_transversals, set.mem_set_of_eq, is_complement_iff_exists_unique]
refine ‚ü®Œª h g, _, Œª h g, _‚ü©
obtain ‚ü®x, h1, h2‚ü© := h g
exact ‚ü®x.1, (congr_arg (‚àà T) (eq_inv_mul_of_mul_eq h1)).mp x.2.2, Œª y hy, (prod.ext_iff.mp (h2 ‚ü®y, y‚Åª¬π * g, hy‚ü© (mul_inv_cancel_left y g))).1‚ü©
{ obtain ‚ü®x, h1, h2‚ü© := h g, exact ‚ü®x.1, (congr_arg (‚àà T) (eq_inv_mul_of_mul_eq h1)).mp x.2.2, Œª y hy, (prod.ext_iff.mp (h2 ‚ü®y, y‚Åª¬π * g, hy‚ü© (mul_inv_cancel_left y g))).1‚ü© }
obtain ‚ü®x, h1, h2‚ü© := h g
refine ‚ü®‚ü®x, x‚Åª¬π * g, h1‚ü©, mul_inv_cancel_left x g, Œª y hy, _‚ü©
have := h2 y.1 ((congr_arg (‚àà T) (eq_inv_mul_of_mul_eq hy)).mp y.2.2)
exact prod.ext this (subtype.ext (eq_inv_mul_of_mul_eq ((congr_arg _ this).mp hy)))
simp [mem_right_coset_iff, mul_mem_cancel_right s (s.inv_mem ha)]
convert (submonoid.fg_iff_add_fg P.to_submonoid).symm
exact set_like.ext' rfl
rw [list.length_append, list.length_append]
rw [list.length_append, list.length_append]; refl
refl
let S : submonoid (free_product M) := ‚ü®set_of C, h_one, h_mul‚ü©
convert subtype.prop (lift (Œª i, of.cod_mrestrict S (h_of i)) m)
change monoid_hom.id _ m = S.subtype.comp _ m
congr
ext
simp [monoid_hom.cod_mrestrict]
exact general_commutator_le_left ‚ä• H
rw eq_bot_iff
rw [‚Üê fintype.card_prod, ‚Üê fintype.card_sigma, fintype.card_congr (sigma_fixed_by_equiv_orbits_prod_group Œ± Œ≤)]
haveI := comp Œ± g; exact smul_comm_class N Œ≤ Œ±
exact smul_comm_class N Œ≤ Œ±
haveI := comp Œ± g
exact {smul_comm := Œª n, @smul_comm _ _ _ _ _ _ (g n) }
exact p.smul_mem _ h
rw [‚Üêone_smul R x, ‚Üêsmul_assoc]
rw r_eq_r' S; refl
refl
rw r_eq_r' S
rw [mul_inv_left, mul_one]
rw [mul_inv_left, mul_one]; exact f.eq_of_eq hg (by rw [‚Üêsec_spec, one_mul])
exact f.eq_of_eq hg (by rw [‚Üêsec_spec, one_mul])
rw [‚Üêsec_spec, one_mul]
rw [mul_inv_left hg, ‚Üêmul_assoc, ‚Üêmul_assoc, mul_inv_right hg, mul_comm _ (g (f.sec y).1), ‚Üêmul_assoc, ‚Üêmul_assoc, mul_inv_right hg]
rw ‚Üêg.map_mul
rw ‚Üêg.map_mul
rw ‚Üêg.map_mul
rw ‚Üêg.map_mul
rw ‚Üêg.map_mul
repeat { rw ‚Üêg.map_mul }
repeat { rw f.to_map.map_mul <|> rw sec_spec' }
rw f.to_map.map_mul
rw f.to_map.map_mul
rw f.to_map.map_mul
rw f.to_map.map_mul
rw f.to_map.map_mul
rw f.to_map.map_mul
rw f.to_map.map_mul
rw f.to_map.map_mul
rw sec_spec'
rw sec_spec'
rw sec_spec'
rw sec_spec'
repeat { rw f.to_map.map_mul <|> rw sec_spec' }; ac_refl
exact f.eq_of_eq hg (by repeat { rw f.to_map.map_mul <|> rw sec_spec' }; ac_refl)
ac_refl
rwa is_periodic_pt_mul_iff_pow_eq_one
simp_rw ‚Üêset_like.mem_coe
rw ‚Üê multiples_eq_gmultiples
exact decidable_multiples
intro g
obtain ‚ü®j, hj‚ü© := (hH.to_quotient ((H ‚äì K).comap H.subtype)).of_equiv (quotient_group.quotient_inf_equiv_prod_normal_quotient H K) g
obtain ‚ü®k, hk‚ü© := hK ‚ü®g ^ (p ^ j), (congr_arg (‚àà K) ((H ‚äî K).coe_pow g (p ^ j))).mp ((quotient_group.eq_one_iff (g ^ (p ^ j))).mp ((quotient_group.coe_pow (K.comap (H ‚äî K).subtype) g (p ^ j)).trans hj))‚ü©
rw [subtype.ext_iff, K.coe_pow, subtype.coe_mk, ‚Üêpow_mul, ‚Üêpow_add] at hk
rwa [subtype.ext_iff, (H ‚äî K).coe_pow]
refine ‚ü®j + k, by rwa [subtype.ext_iff, (H ‚äî K).coe_pow]‚ü©
rw [‚ÜêhG, pow_card_eq_one]
induction s using quot.induction_on
simpa using list.form_perm_eq_self_of_not_mem _ _ hx
exact set.unique_singleton vector.nil
rw zero_eq
rw [is_conj_iff_cycle_type_eq]
refine ‚ü®Œª h, _, Œª h, _‚ü©
rw [partition.ext_iff, parts_partition, parts_partition, ‚Üê sum_cycle_type, ‚Üê sum_cycle_type, h]
{ rw [partition.ext_iff, parts_partition, parts_partition, ‚Üê sum_cycle_type, ‚Üê sum_cycle_type, h] }
rw [‚Üê filter_parts_partition_eq_cycle_type, ‚Üê filter_parts_partition_eq_cycle_type, h]
suffices : ‚àÄ l : list (perm Œ≤), (‚àÄ œÑ : perm Œ≤, œÑ ‚àà l ‚Üí œÑ.is_cycle) ‚Üí l.pairwise disjoint ‚Üí P l.prod
classical
let x := œÉ.trunc_cycle_factors.out
exact (congr_arg P x.2.1).mp (this x.1 x.2.2.1 x.2.2.2)
{ classical, let x := œÉ.trunc_cycle_factors.out, exact (congr_arg P x.2.1).mp (this x.1 x.2.2.1 x.2.2.2) }
intro l
induction l with œÉ l ih
{ exact Œª _ _, base_one }
exact Œª _ _, base_one
intros h1 h2
rw list.prod_cons
exact induction_disjoint œÉ l.prod (disjoint_prod_right _ (list.pairwise_cons.mp h2).1) (h1 _ (list.mem_cons_self _ _)) (base_cycles œÉ (h1 œÉ (l.mem_cons_self œÉ))) (ih (Œª œÑ hœÑ, h1 œÑ (list.mem_cons_of_mem œÉ hœÑ)) (list.pairwise_of_pairwise_cons h2))
refine is_conj_iff.2 ‚ü®equiv.extend_subtype f, _‚ü©
rw mul_inv_eq_iff_eq_mul
ext
simp only [perm.mul_apply]
by_cases hx : x ‚àà œÉ.support
rw [equiv.extend_subtype_apply_of_mem, equiv.extend_subtype_apply_of_mem]
{ exact hf x (finset.mem_coe.2 hx) }
{ rw [equiv.extend_subtype_apply_of_mem, equiv.extend_subtype_apply_of_mem], { exact hf x (finset.mem_coe.2 hx) } }
exact hf x (finset.mem_coe.2 hx)
rwa [not_not.1 ((not_congr mem_support).1 (equiv.extend_subtype_not_mem f _ _)), not_not.1 ((not_congr mem_support).mp hx)]
rw [nat.lt_sub_left_iff_add_lt, ‚Üê nat.lt_sub_right_iff_add_lt, ‚Üê finset.card_compl, finset.compl_filter]
exact one_lt_card_support_of_ne_one h
classical
obtain ‚ü®_|i, hi, rfl‚ü© := h.nat'
refine ‚ü®order_of f, order_of_pos f, le_rfl, _‚ü©
{ refine ‚ü®order_of f, order_of_pos f, le_rfl, _‚ü©, rw [pow_order_of_eq_one, pow_zero] }
rw [pow_order_of_eq_one, pow_zero]
exact ‚ü®i.succ, i.zero_lt_succ, hi.le, rfl‚ü©
by_cases hx : f x = x
rw (cycle_of_eq_one_iff _).mpr hx
{ rw (cycle_of_eq_one_iff _).mpr hx, simp [hx] }
simp [hx]
rw [mem_support, cycle_of_apply]
split_ifs with hy
simp only [hx, hy, iff_true, ne.def, not_false_iff, and_self, mem_support]
rcases hy with ‚ü®k, rfl‚ü©
rw ‚Üênot_mem_support
{ simp only [hx, hy, iff_true, ne.def, not_false_iff, and_self, mem_support], rcases hy with ‚ü®k, rfl‚ü©, rw ‚Üênot_mem_support, simpa using hx }
simpa using hx
simpa [hx] using hy
obtain ‚ü®m, rfl‚ü© := exists_add_of_le h
rw [add_comm, cycle_type_fin_rotate]
cases lt_or_ge j.cast_succ i with h h
rw [fin.succ_above_below _ _ h, fin.cycle_range_of_lt h, fin.coe_succ_eq_succ]
{ rw [fin.succ_above_below _ _ h, fin.cycle_range_of_lt h, fin.coe_succ_eq_succ] }
rw [fin.succ_above_above _ _ h, fin.cycle_range_of_gt (fin.le_cast_succ_iff.mp h)]
induction n with n ih
{ simp }
simp
simp [ih, pow_succ]
rw fin_rotate_succ
rw [gpow_neg_succ_of_nat, inv_eq_iff_eq, pow_apply_eq_self_of_apply_eq_self hfx]
rw [sup_eq_union, mem_union, mem_support, mem_support, mem_support, mul_apply, ‚Üênot_and_distrib, not_imp_not]
rintro ‚ü®hf, hg‚ü©
rw [hg, hf]
cases n
rw [int.of_nat_eq_coe, gpow_coe_nat, pow_apply_mem_support]
{ rw [int.of_nat_eq_coe, gpow_coe_nat, pow_apply_mem_support] }
rw [gpow_neg_succ_of_nat, ‚Üê support_inv, ‚Üê inv_pow, pow_apply_mem_support]
induction k with k hk
{ simp }
simp
intros x hx
rw [pow_succ', mul_apply, pow_succ', mul_apply, h _ hx, hk]
rwa [mem_inter, apply_mem_support, ‚Üêh _ hx, apply_mem_support, ‚Üêmem_inter]
simp [disjoint_iff_eq_or_eq, disjoint_iff, finset.ext_iff, not_and_distrib]
simp only [disjoint, or.comm, imp_self]
rw mul_normal H N at hy
rintro ‚ü®y, (hy : y ‚àà ‚Üë(H ‚äî N))‚ü©
rcases hy with ‚ü®h, n, hh, hn, rfl‚ü©
apply quotient.eq.mpr
change h‚Åª¬π * (h * n) ‚àà N
use [h, hh]
rwa [‚Üêmul_assoc, inv_mul_self, one_mul]
simp [comap_comap, ‚Üêcomap_ker]
simp [monoid_hom.mem_ker, eq_comm] {contextual := tt}
ext
ext; simp [*, monoid_hom.mem_ker] at *
simp [*, monoid_hom.mem_ker] at *
simp [*, monoid_hom.mem_ker] at *
rw is_solvable_def at *
cases h with n hn
use n
rw ‚Üê map_eq_bot_iff_of_injective _ hf
rw eq_bot_iff at *
calc map f (derived_series G n) ‚â§ derived_series G' n : map_derived_series_le_derived_series f n ... ‚â§ ‚ä• : hn
introI Hn
refine or_not.imp (id) (Œª Hb, _)
rw [eq_bot_iff_forall] at Hb
push_neg at Hb
obtain ‚ü®‚ü®g, gA‚ü©, gH, g1‚ü© : ‚àÉ (x : ‚Ü•(alternating_group (fin 5))), x ‚àà H ‚àß x ‚â† 1 := Hb
rw [‚Üê set_like.mem_coe, ‚Üê set.singleton_subset_iff] at gH
refine eq_top_iff.2 (le_trans (ge_of_eq _) (normal_closure_le_normal gH))
by_cases h2 : ‚àÄ n ‚àà g.cycle_type, n = 2
rw [ne.def, subtype.ext_iff] at g1
exact (is_conj_swap_mul_swap_of_cycle_type_two gA g1 h2).normal_closure_eq_top_of normal_closure_swap_mul_swap_five
{ rw [ne.def, subtype.ext_iff] at g1, exact (is_conj_swap_mul_swap_of_cycle_type_two gA g1 h2).normal_closure_eq_top_of normal_closure_swap_mul_swap_five }
push_neg at h2
obtain ‚ü®n, ng, n2‚ü© : ‚àÉ (n : ‚Ñï), n ‚àà g.cycle_type ‚àß n ‚â† 2 := h2
have n2' : 2 < n := lt_of_le_of_ne (two_le_of_mem_cycle_type ng) n2.symm
have n5 : n ‚â§ 5 := le_trans _ g.support.card_le_univ
obtain ‚ü®m, hm‚ü© := multiset.exists_cons_of_mem ng
swap
rw [‚Üê sum_cycle_type, hm, multiset.sum_cons]
{ obtain ‚ü®m, hm‚ü© := multiset.exists_cons_of_mem ng, rw [‚Üê sum_cycle_type, hm, multiset.sum_cons], exact le_add_right (le_refl _) }
exact le_add_right (le_refl _)
interval_cases n
rw [eq_top_iff, ‚Üê (is_three_cycle_sq_of_three_mem_cycle_type_five ng).alternating_normal_closure (by rw card_fin )]
rw card_fin
refine normal_closure_le_normal _
rw [set.singleton_subset_iff, set_like.mem_coe]
have h := set_like.mem_coe.1 (subset_normal_closure (set.mem_singleton _))
{ rw [eq_top_iff, ‚Üê (is_three_cycle_sq_of_three_mem_cycle_type_five ng).alternating_normal_closure (by rw card_fin )], refine normal_closure_le_normal _, rw [set.singleton_subset_iff, set_like.mem_coe], have h := set_like.mem_coe.1 (subset_normal_closure (set.mem_singleton _)), exact mul_mem _ h h }
exact mul_mem _ h h
have con := mem_alternating_group.1 gA
contrapose! con
rw [sign_of_cycle_type, cycle_type_of_card_le_mem_cycle_type_add_two dec_trivial ng, multiset.map_singleton, multiset.prod_singleton]
{ have con := mem_alternating_group.1 gA, contrapose! con, rw [sign_of_cycle_type, cycle_type_of_card_le_mem_cycle_type_add_two dec_trivial ng, multiset.map_singleton, multiset.prod_singleton], dec_trivial }
dec_trivial
refine (is_conj_iff_cycle_type_eq.2 _).normal_closure_eq_top_of normal_closure_fin_rotate_five
rw [cycle_type_of_card_le_mem_cycle_type_add_two dec_trivial ng, cycle_type_fin_rotate]
rintros ‚ü®x, y, rfl‚ü©
apply subtype.ext
rw [coe_range_restrict, function.comp_apply, subgroup.coe_subtype, subtype.coe_mk, h]
rw [mem_inf, mem_sup] at ha
rcases ha with ‚ü®‚ü®b, hb, c, hc, rfl‚ü©, haz‚ü©
rw mem_sup
refine ‚ü®b, hb, c, mem_inf.2 ‚ü®hc, _‚ü©, rfl‚ü©
rw ‚Üê inv_mul_cancel_left b c
apply z.mul_mem (z.inv_mem (xz hb)) haz
rw set_like.ext'_iff
simp only [coe_bot, set.eq_singleton_iff_unique_mem, set_like.mem_coe, H.one_mem, true_and]
simp [mem_prod, monoid_hom.coe_snd]
revert a
refine add_submonoid.closure_induction hb _ _ _
refine add_submonoid.closure_induction hb _ _ _; clear hb b
clear hb b
clear hb b
clear hb b
{ exact Œª r hr b hb, S.mul_right_mem_add_closure hb hr }
exact Œª r hr b hb, S.mul_right_mem_add_closure hb hr
simp only [mul_zero, (add_submonoid.closure (S : set R)).zero_mem]
exact Œª b hb, by simp only [mul_zero, (add_submonoid.closure (S : set R)).zero_mem]
{ exact Œª b hb, by simp only [mul_zero, (add_submonoid.closure (S : set R)).zero_mem] }
simp_rw mul_add
exact Œª r s hr hs b hb, (add_submonoid.closure (S : set R)).add_mem (hr hb) (hs hb)
rw ‚Üê coe_multiset_prod
exact m.prod.coe_prop
lift m to multiset S using hm
simp [mem_prod, monoid_hom.coe_fst]
rw [‚Üê fintype.card_congr (fixed_points_mul_left_cosets_equiv_quotient H)]
exact ((is_p_group.of_card hH).card_modeq_card_fixed_points _).symm
intros x hx
rw [‚Üê ideal.neg_mem_iff, ideal.mem_jacobson_bot]
intros y
rw add_comm
let f : ‚Ñï ‚Üí R := geom_sum (x * y)
have hf : ‚àÄ m n, m ‚â§ n ‚Üí f m ‚â° f n [SMOD I ^ m ‚Ä¢ (‚ä§ : submodule R R)]
intros m n h
simp only [f, geom_sum_def, algebra.id.smul_eq_mul, ideal.mul_top, smodeq.sub_mem]
rw [‚Üê nat.add_sub_cancel' h, finset.sum_range_add, ‚Üê sub_sub, sub_self, zero_sub, neg_mem_iff]
apply submodule.sum_mem
intros n hn
rw [mul_pow, pow_add, mul_assoc]
exact ideal.mul_mem_right _ (I ^ m) (ideal.pow_mem_pow hx m)
{ intros m n h, simp only [f, geom_sum_def, algebra.id.smul_eq_mul, ideal.mul_top, smodeq.sub_mem], rw [‚Üê nat.add_sub_cancel' h, finset.sum_range_add, ‚Üê sub_sub, sub_self, zero_sub, neg_mem_iff], apply submodule.sum_mem, intros n hn, rw [mul_pow, pow_add, mul_assoc], exact ideal.mul_mem_right _ (I ^ m) (ideal.pow_mem_pow hx m) }
obtain ‚ü®L, hL‚ü© := is_precomplete.prec to_is_precomplete hf
rw is_unit_iff_exists_inv
use L
rw [‚Üê sub_eq_zero, neg_mul_eq_neg_mul_symm]
apply is_Hausdorff.haus (to_is_Hausdorff : is_Hausdorff I R)
intros n
specialize hL n
rw [smodeq.sub_mem, algebra.id.smul_eq_mul, ideal.mul_top] at ‚ä¢ hL
rw sub_zero
suffices : (1 - x * y) * (f n) - 1 ‚àà I ^ n
convert (ideal.sub_mem _ this (ideal.mul_mem_left _ (1 + - (x * y)) hL)) using 1
{ convert (ideal.sub_mem _ this (ideal.mul_mem_left _ (1 + - (x * y)) hL)) using 1, ring }
ring
cases n
{ simp only [ideal.one_eq_top, pow_zero] }
simp only [ideal.one_eq_top, pow_zero]
dsimp [f]
rw [‚Üê neg_sub _ (1:R), neg_mul_eq_neg_mul_symm, mul_geom_sum, neg_sub, sub_sub, add_comm, ‚Üê sub_sub, sub_self, zero_sub, neg_mem_iff, mul_pow]
exact ideal.mul_mem_right _ (I ^ _) (ideal.pow_mem_pow hx _)
simp [h p']
simp [h (e'.symm (q' -·µ• e p) +·µ• p)]
simp [h p', h (v +·µ• p'), vadd_vsub_assoc, vadd_vadd]
simp only [homothety_def, add_smul, vadd_vadd]
rw ‚Üê set.ne_empty_iff_nonempty
rintros rfl
rw affine_subspace.span_empty at h
exact bot_ne_top k V P h
by_contradiction h
rw set.not_nonempty_iff_eq_empty at h
have hlt := sup_direction_lt_of_nonempty_of_inter_empty h1 h2 h
rw hd at hlt
exact not_top_lt hlt
cases inter_nonempty_of_nonempty_of_sup_direction_eq_top h1 h2 hd.sup_eq_top with p hp
use p
ext q
rw set.mem_singleton_iff
split
rintros ‚ü®hq1, hq2‚ü©
have hqp : q -·µ• p ‚àà s1.direction ‚äì s2.direction := ‚ü®vsub_mem_direction hq1 hp.1, vsub_mem_direction hq2 hp.2‚ü©
rwa [hd.inf_eq_bot, submodule.mem_bot, vsub_eq_zero_iff_eq] at hqp
{ rintros ‚ü®hq1, hq2‚ü©, have hqp : q -·µ• p ‚àà s1.direction ‚äì s2.direction := ‚ü®vsub_mem_direction hq1 hp.1, vsub_mem_direction hq2 hp.2‚ü©, rwa [hd.inf_eq_bot, submodule.mem_bot, vsub_eq_zero_iff_eq] at hqp }
exact Œª h, h.symm ‚ñ∏ hp
simp [vector_span_eq_span_vsub_set_right_ne _ (finset.mem_coe.mpr hp)]
split
intros ha s1 s2 w1 w2 hw1 hw2 heq
ext i
by_cases hi : i ‚àà (s1 ‚à™ s2)
rw ‚Üêsub_eq_zero
rw set.sum_indicator_subset _ (finset.subset_union_left s1 s2) at hw1
rw set.sum_indicator_subset _ (finset.subset_union_right s1 s2) at hw2
have hws : ‚àë i in s1 ‚à™ s2, (set.indicator ‚Üës1 w1 - set.indicator ‚Üës2 w2) i = 0
{ simp [hw1, hw2] }
simp [hw1, hw2]
rw [finset.affine_combination_indicator_subset _ _ (finset.subset_union_left s1 s2), finset.affine_combination_indicator_subset _ _ (finset.subset_union_right s1 s2), ‚Üê@vsub_eq_zero_iff_eq V, finset.affine_combination_vsub] at heq
exact ha (s1 ‚à™ s2) (set.indicator ‚Üës1 w1 - set.indicator ‚Üës2 w2) hws heq i hi
{ rw ‚Üêsub_eq_zero, rw set.sum_indicator_subset _ (finset.subset_union_left s1 s2) at hw1, rw set.sum_indicator_subset _ (finset.subset_union_right s1 s2) at hw2, have hws : ‚àë i in s1 ‚à™ s2, (set.indicator ‚Üës1 w1 - set.indicator ‚Üës2 w2) i = 0, { simp [hw1, hw2] }, rw [finset.affine_combination_indicator_subset _ _ (finset.subset_union_left s1 s2), finset.affine_combination_indicator_subset _ _ (finset.subset_union_right s1 s2), ‚Üê@vsub_eq_zero_iff_eq V, finset.affine_combination_vsub] at heq, exact ha (s1 ‚à™ s2) (set.indicator ‚Üës1 w1 - set.indicator ‚Üës2 w2) hws heq i hi }
rw [‚Üêfinset.mem_coe, finset.coe_union] at hi
simp [mt (set.mem_union_left ‚Üës2) hi, mt (set.mem_union_right ‚Üës1) hi]
{ intros ha s1 s2 w1 w2 hw1 hw2 heq, ext i, by_cases hi : i ‚àà (s1 ‚à™ s2), { rw ‚Üêsub_eq_zero, rw set.sum_indicator_subset _ (finset.subset_union_left s1 s2) at hw1, rw set.sum_indicator_subset _ (finset.subset_union_right s1 s2) at hw2, have hws : ‚àë i in s1 ‚à™ s2, (set.indicator ‚Üës1 w1 - set.indicator ‚Üës2 w2) i = 0, { simp [hw1, hw2] }, rw [finset.affine_combination_indicator_subset _ _ (finset.subset_union_left s1 s2), finset.affine_combination_indicator_subset _ _ (finset.subset_union_right s1 s2), ‚Üê@vsub_eq_zero_iff_eq V, finset.affine_combination_vsub] at heq, exact ha (s1 ‚à™ s2) (set.indicator ‚Üës1 w1 - set.indicator ‚Üës2 w2) hws heq i hi }, { rw [‚Üêfinset.mem_coe, finset.coe_union] at hi, simp [mt (set.mem_union_left ‚Üës2) hi, mt (set.mem_union_right ‚Üës1) hi] } }
intros ha s w hw hs i0 hi0
let w1 : Œπ ‚Üí k := function.update (function.const Œπ 0) i0 1
have hw1 : ‚àë i in s, w1 i = 1
{ rw [finset.sum_update_of_mem hi0, finset.sum_const_zero, add_zero] }
rw [finset.sum_update_of_mem hi0, finset.sum_const_zero, add_zero]
have hw1s : s.affine_combination p w1 = p i0 := s.affine_combination_of_eq_one_of_eq_zero w1 p hi0 (function.update_same _ _ _) (Œª _ _ hne, function.update_noteq hne _ _)
let w2 := w + w1
have hw2 : ‚àë i in s, w2 i = 1
{ simp [w2, finset.sum_add_distrib, hw, hw1] }
simp [w2, finset.sum_add_distrib, hw, hw1]
have hw2s : s.affine_combination p w2 = p i0
{ simp [w2, ‚Üêfinset.weighted_vsub_vadd_affine_combination, hs, hw1s] }
simp [w2, ‚Üêfinset.weighted_vsub_vadd_affine_combination, hs, hw1s]
replace ha := ha s s w2 w1 hw2 hw1 (hw1s.symm ‚ñ∏ hw2s)
have hws : w2 i0 - w1 i0 = 0
rw ‚Üêfinset.mem_coe at hi0
rw [‚Üêset.indicator_of_mem hi0 w2, ‚Üêset.indicator_of_mem hi0 w1, ha, sub_self]
{ rw ‚Üêfinset.mem_coe at hi0, rw [‚Üêset.indicator_of_mem hi0 w2, ‚Üêset.indicator_of_mem hi0 w1, ha, sub_self] }
simpa [w2] using hws
simp [ha]
rw [‚Üê @vsub_eq_zero_iff_eq V, midpoint_vsub_midpoint, midpoint_eq_iff, point_reflection_apply, vsub_eq_sub, zero_sub, vadd_eq_add, add_zero, neg_eq_iff_neg_eq, neg_vsub_eq_vsub_rev, eq_comm]
rw [‚Üê line_map_apply_one_sub, ‚Üê line_map_apply_one_sub _ _ r]
generalize : 1 - r = r'
clear r
revert h
intro h
simp_rw [line_map_apply, slope, vsub_eq_sub, vadd_eq_add, smul_eq_mul]
rw [sub_add_eq_sub_sub_swap, sub_self, zero_sub, le_smul_iff_of_pos, inv_inv', smul_smul, neg_mul_eq_mul_neg, neg_sub, mul_inv_cancel_right', le_sub, ‚Üê neg_sub (f b), smul_neg, neg_add_eq_sub]
{ exact right_ne_zero_of_mul h.ne' }
exact right_ne_zero_of_mul h.ne'
simpa [mul_sub] using h
simp
haveI : nonempty s := hs.to_subtype
simp only [Sup_eq_supr', mem_supr_of_directed _ hdir.directed_coe, set_coe.exists, subtype.coe_mk]
apply span_induction h
exact ‚ü®1, by simp‚ü©
simp
{ rintro y (rfl|‚ü®‚ü®‚ü©‚ü©), exact ‚ü®1, by simp‚ü© }
rintro y (rfl|‚ü®‚ü®‚ü©‚ü©)
simp
{ exact ‚ü®0, by simp‚ü© }
exact ‚ü®0, by simp‚ü©
rintro _ _ ‚ü®a, rfl‚ü© ‚ü®b, rfl‚ü©
simp [add_smul]
{ rintro _ _ ‚ü®a, rfl‚ü© ‚ü®b, rfl‚ü©, exact ‚ü®a + b, by simp [add_smul]‚ü© }
exact ‚ü®a + b, by simp [add_smul]‚ü©
rintro a _ ‚ü®b, rfl‚ü©
simp [smul_smul]
exact ‚ü®a * b, by simp [smul_smul]‚ü©
rintro ‚ü®a, y, rfl‚ü©; exact smul_mem _ _ (subset_span $ by simp)
exact smul_mem _ _ (subset_span $ by simp)
rintro ‚ü®a, y, rfl‚ü©
simp
rwa [submodule.map_comap_eq, inf_eq_right]
rw [of_le, ker_cod_restrict, ker_subtype]
split
rw submodule.mem_map
simp [‚Üêhx, hy]
{ rintros ‚ü®y, hy, hx‚ü©, simp [‚Üêhx, hy], }
rintros ‚ü®y, hy, hx‚ü©
refine ‚ü®e.symm x, hx, by simp‚ü©
simp
intros hx
rw [iterate_succ]
exact bijective.comp (iterate_bijective n) h
rw [linear_map.comp_apply, linear_map.comp_apply, h', h]
cases D
congr
funext
exact H _ _
cases B
simp only [pair_self_adjoint_matrices_submodule, linear_equiv.coe_coe, linear_map.to_matrix'_apply, submodule.mem_map, bilin_form.mem_is_pair_self_adjoint_submodule]
split
rintros ‚ü®f, hf, hA‚ü©
rw [‚ÜêhA, matrix.to_lin'_to_matrix']
have hf' : f = A.to_lin' := by rw [‚ÜêhA, matrix.to_lin'_to_matrix']
rw hf' at hf
rw ‚Üê is_adjoint_pair_to_bilin'
{ rintros ‚ü®f, hf, hA‚ü©, have hf' : f = A.to_lin' := by rw [‚ÜêhA, matrix.to_lin'_to_matrix'], rw hf' at hf, rw ‚Üê is_adjoint_pair_to_bilin', exact hf, }
exact hf
refine ‚ü®A.to_lin', _, linear_map.to_matrix'_to_lin' _‚ü©
intros h
exact (is_adjoint_pair_to_bilin' _ _ _ _).mpr h
refine Œª m hm, submodule.coe_eq_zero.1 (b‚ÇÅ m.1 (Œª n, _))
have : n ‚àà (K ‚àô x) ‚äî B.orthogonal (K ‚àô x) := (span_singleton_sup_orthogonal_eq_top hx).symm ‚ñ∏ submodule.mem_top
rcases submodule.mem_sup.1 this with ‚ü®y, hy, z, hz, rfl‚ü©
specialize hm ‚ü®z, hz‚ü©
rw restrict at hm
erw [add_right, show B m.1 y = 0, by rw b‚ÇÇ; exact m.2 y hy, hm, add_zero]
rw b‚ÇÇ
rw b‚ÇÇ; exact m.2 y hy
exact m.2 y hy
ext w
refine eq_of_sub_eq_zero (b _ _)
intro v
rw [sub_left, ‚Üê comp_left_apply, ‚Üê comp_left_apply, ‚Üê h, sub_self]
simp
ext A x y
rw [B.to_matrix_comp_right b, to_matrix_to_lin]
simp
simp [pow_add, involute_prod_map_Œπ xs]
rw [alg_equiv.map_mul, mul_comm, alg_equiv.map_mul]
rw [equiv_apply, equiv_apply, to_quaternion_involute_reverse, to_quaternion_of_quaternion, to_quaternion_of_quaternion]
simpa using lift_dim_map_le f p
rw ‚Üêdim_range_of_surjective f h
apply dim_range_le
rw @eq_comm _ j i
convert b.to_dual_apply i j using 2
rintro _ ‚ü®œà, rfl‚ü©
simp_rw [submodule.mem_dual_annihilator, mem_ker]
rintro x hx
rw [dual_map_apply, hx, map_zero]
rw algebra.mul_sub_algebra_map_pow_commutes
haveI := span_of_finite K ‚ü®fin‚ü©
have : module.rank K (span K s) ‚â§ #s := dim_span_le s
rw [‚Üêfinrank_eq_dim, cardinal.fintype_card, ‚Üêset.to_finset_card] at this
exact_mod_cast this
exact dim_top F E
rw subalgebra_top_dim_eq_submodule_top_dim
simp [mem_supported, subset_Inter_iff]
apply finsupp.induction_linear l; simp { contextual := tt, }
simp { contextual := tt, }
simp { contextual := tt, }
simp { contextual := tt, }
apply finsupp.induction_linear l
simp only [total_apply]
apply induction_linear f
{ simp only [sum_zero_index], }
simp only [sum_zero_index]
intros f‚ÇÅ f‚ÇÇ h‚ÇÅ h‚ÇÇ
{ intros f‚ÇÅ f‚ÇÇ h‚ÇÅ h‚ÇÇ, simp [sum_add_index, h‚ÇÅ, h‚ÇÇ, add_smul], }
simp [sum_add_index, h‚ÇÅ, h‚ÇÇ, add_smul]
simp [sum_single_index, sum_smul_index, smul_sum, mul_smul]
obtain ‚ü®f, hf, rfl‚ü© : ‚àÉ f ‚àà finsupp.supported R R (‚ãÉ i, ‚Üë(p i)), finsupp.total M M R id f = m
have aux : (id : M ‚Üí M) '' (‚ãÉ (i : Œπ), ‚Üë(p i)) = (‚ãÉ (i : Œπ), ‚Üë(p i)) := set.image_id _
rwa [supr_eq_span, ‚Üê aux, finsupp.mem_span_image_iff_total R] at hm
{ have aux : (id : M ‚Üí M) '' (‚ãÉ (i : Œπ), ‚Üë(p i)) = (‚ãÉ (i : Œπ), ‚Üë(p i)) := set.image_id _, rwa [supr_eq_span, ‚Üê aux, finsupp.mem_span_image_iff_total R] at hm }
let t : finset M := f.support
have ht : ‚àÄ x : {x // x ‚àà t}, ‚àÉ i, ‚Üëx ‚àà p i
intros x
rw finsupp.mem_supported at hf
specialize hf x.2
{ intros x, rw finsupp.mem_supported at hf, specialize hf x.2, rwa set.mem_Union at hf }
rwa set.mem_Union at hf
choose g hg using ht
let s : finset Œπ := finset.univ.image g
use s
simp only [mem_supr, supr_le_iff]
assume N hN
rw [finsupp.total_apply, finsupp.sum, ‚Üê set_like.mem_coe]
apply N.sum_mem
assume x hx
apply submodule.smul_mem
let i : Œπ := g ‚ü®x, hx‚ü©
rw finset.mem_image
have hi : i ‚àà s
exact ‚ü®‚ü®x, hx‚ü©, finset.mem_univ _, rfl‚ü©
{ rw finset.mem_image, exact ‚ü®‚ü®x, hx‚ü©, finset.mem_univ _, rfl‚ü© }
exact hN i hi (hg _)
ext ‚ü®j, y‚ü©
by_cases h : i = j
cases h
simp only [basis_repr, single_eq_same, basis.repr_self, basis.finsupp.single_apply_left sigma_mk_injective]
{ cases h, simp only [basis_repr, single_eq_same, basis.repr_self, basis.finsupp.single_apply_left sigma_mk_injective] }
simp only [basis_repr, single_apply, h, false_and, if_false, linear_equiv.map_zero, zero_apply]
simp only [finset.mem_sigma, mem_support_iff, and_iff_right_iff_imp, ne.def]
intros b hg
simpa [hg] using b
rw [ne.def, ‚Üê (b i).repr.injective.eq_iff, (b i).repr.apply_symm_apply, ext_iff]
simp only [exists_prop, linear_equiv.map_zero, comap_domain_apply, zero_apply, exists_and_distrib_right, mem_support_iff, exists_eq_right, sigma.exists, finset.mem_image, not_forall]
ext i
rw ‚Üê (b i).repr.injective.eq_iff
ext x
simp only [coe_mk, linear_equiv.apply_symm_apply, comap_domain_apply]
ext ‚ü®i, x‚ü©
simp only [coe_mk, linear_equiv.apply_symm_apply, comap_domain_apply]
ext ‚ü®i, x‚ü©
simp only [coe_mk, add_apply, linear_equiv.map_add]
ext ‚ü®i, x‚ü©
simp only [coe_mk, smul_apply, linear_equiv.map_smul, ring_hom.id_apply]
classical
exact of_equiv (linear_map.to_matrix (module.free.choose_basis R M) (module.free.choose_basis R N)).symm
exact ‚ü®x, hx, rfl‚ü©
rw [‚Üê mem_iff_generator_dvd, submodule.mem_map]
simpa using ortho (-1) x hx
intro hx
let a : R := generator (œï.submodule_image N)
let d : R := is_principal.generator (submodule.span R {a, œà ‚ü®y, hNO yN‚ü©})
have d_dvd_left : d ‚à£ a := (mem_iff_generator_dvd _).mp (subset_span (mem_insert _ _))
have d_dvd_right : d ‚à£ œà ‚ü®y, hNO yN‚ü© := (mem_iff_generator_dvd _).mp (subset_span (mem_insert_of_mem _ (mem_singleton _)))
refine dvd_trans _ d_dvd_right
rw [dvd_generator_iff, ideal.span, ‚Üê span_singleton_generator (submodule.span R {a, œà ‚ü®y, hNO yN‚ü©})]
obtain ‚ü®r‚ÇÅ, r‚ÇÇ, d_eq‚ü© : ‚àÉ r‚ÇÅ r‚ÇÇ : R, d = r‚ÇÅ * a + r‚ÇÇ * œà ‚ü®y, hNO yN‚ü©
obtain ‚ü®r‚ÇÅ, r‚ÇÇ', hr‚ÇÇ', hr‚ÇÅ‚ü© := mem_span_insert.mp (is_principal.generator_mem (submodule.span R {a, œà ‚ü®y, hNO yN‚ü©}))
obtain ‚ü®r‚ÇÇ, rfl‚ü© := mem_span_singleton.mp hr‚ÇÇ'
{ obtain ‚ü®r‚ÇÅ, r‚ÇÇ', hr‚ÇÇ', hr‚ÇÅ‚ü© := mem_span_insert.mp (is_principal.generator_mem (submodule.span R {a, œà ‚ü®y, hNO yN‚ü©})), obtain ‚ü®r‚ÇÇ, rfl‚ü© := mem_span_singleton.mp hr‚ÇÇ', exact ‚ü®r‚ÇÅ, r‚ÇÇ, hr‚ÇÅ‚ü© }
exact ‚ü®r‚ÇÅ, r‚ÇÇ, hr‚ÇÅ‚ü©
let œà' : O ‚Üí‚Çó[R] R := r‚ÇÅ ‚Ä¢ œï + r‚ÇÇ ‚Ä¢ œà
have : span R {d} ‚â§ œà'.submodule_image N
rw [span_le, singleton_subset_iff, set_like.mem_coe, linear_map.mem_submodule_image_of_le hNO]
refine ‚ü®y, yN, _‚ü©
change r‚ÇÅ * œï ‚ü®y, hNO yN‚ü© + r‚ÇÇ * œà ‚ü®y, hNO yN‚ü© = d
{ rw [span_le, singleton_subset_iff, set_like.mem_coe, linear_map.mem_submodule_image_of_le hNO], refine ‚ü®y, yN, _‚ü©, change r‚ÇÅ * œï ‚ü®y, hNO yN‚ü© + r‚ÇÇ * œà ‚ü®y, hNO yN‚ü© = d, rw [d_eq, œïy_eq] }
rw [d_eq, œïy_eq]
refine le_antisymm (this.trans (le_of_eq _)) (ideal.span_singleton_le_span_singleton.mpr d_dvd_left)
rw span_singleton_generator
refine hœï œà' (le_trans _ this)
rw [‚Üê span_singleton_generator (œï.submodule_image N)]
exact ideal.span_singleton_le_span_singleton.mpr d_dvd_left
exact subset_span (mem_insert _ _)
rw submodule.eq_bot_iff
intros x hx
contrapose! rank_eq with x_ne
refine ‚ü®1, Œª _, ‚ü®x, hx‚ü©, _, one_ne_zero‚ü©
rw fintype.linear_independent_iff
rintros g sum_eq i
fin_cases i
simp only [function.const_apply, fin.default_eq_zero, submodule.coe_mk, univ_unique, function.comp_const, finset.sum_singleton] at sum_eq
exact (b.smul_eq_zero.mp sum_eq).resolve_right x_ne
let P := linear_equiv.fun_congr_left R R (fintype.equiv_fin Œ±)
let Q := linear_equiv.fun_congr_left R R (fintype.equiv_fin Œ≤)
exact le_of_fin_surjective R ((Q.symm.to_linear_map.comp f).comp P.to_linear_map) (((linear_equiv.symm Q).surjective.comp i).comp (linear_equiv.surjective P))
refine { to_fun := induced_map I e, inv_fun := induced_map I e.symm, .. }
rintro ‚ü®a‚ü© ‚ü®b‚ü©
rintro ‚ü®a‚ü© ‚ü®b‚ü©
rintro ‚ü®a‚ü© ‚ü®b‚ü©
rintro ‚ü®a‚ü© ‚ü®b‚ü©
rintro ‚ü®a‚ü©
rintro ‚ü®a‚ü©
all_goals { rintro ‚ü®a‚ü© ‚ü®b‚ü© <|> rintro ‚ü®a‚ü©, change ideal.quotient.mk _ _ = ideal.quotient.mk _ _, congr, simp }
change ideal.quotient.mk _ _ = ideal.quotient.mk _ _
change ideal.quotient.mk _ _ = ideal.quotient.mk _ _
change ideal.quotient.mk _ _ = ideal.quotient.mk _ _
change ideal.quotient.mk _ _ = ideal.quotient.mk _ _
simp
simp
simp
simp
congr
congr
congr
congr
rw [‚Üê ker_eq_bot, quotient_inf_to_sup_quotient, ker_liftq_eq_bot]
rw [ker_comp, ker_mkq]
exact Œª ‚ü®x, hx1‚ü© hx2, ‚ü®hx1, hx2‚ü©
rw [‚Üê range_eq_top, quotient_inf_to_sup_quotient, range_liftq, eq_top_iff']
rcases mem_sup.1 hx with ‚ü®y, hy, z, hz, rfl‚ü©
rintros ‚ü®x, hx‚ü©
apply (submodule.quotient.eq _).2
use [‚ü®y, hy‚ü©]
change y - (y + z) ‚àà p'
rwa [sub_add_eq_sub_sub, sub_self, zero_sub, neg_mem_iff]
rw [basis, ‚Üê coe_eval_ring_hom, (eval_ring_hom x).map_prod, coe_eval_ring_hom, finset.prod_eq_one]
simp_rw [eval_mul, eval_sub, eval_C, eval_X]
intros y hy
exact inv_mul_cancel (sub_ne_zero_of_ne (finset.ne_of_mem_erase hy).symm)
nontriviality R
apply linear_independent.of_subtype_range
rintros ‚ü®x‚ÇÅ, x‚ÇÇ‚ü© ‚ü®y‚ÇÅ, y‚ÇÇ‚ü© hxy
by_cases h_cases : x‚ÇÅ = y‚ÇÅ
subst h_cases
apply sigma.eq
rw linear_independent.injective (hindep _) hxy
{ apply sigma.eq, rw linear_independent.injective (hindep _) hxy, refl }
refl
have h0 : f x‚ÇÅ x‚ÇÇ = 0
apply disjoint_def.1 (hd x‚ÇÅ {y‚ÇÅ} (finite_singleton y‚ÇÅ) (Œª h, h_cases (eq_of_mem_singleton h))) (f x‚ÇÅ x‚ÇÇ) (subset_span (mem_range_self _))
rw supr_singleton
simp only at hxy
rw hxy
{ apply disjoint_def.1 (hd x‚ÇÅ {y‚ÇÅ} (finite_singleton y‚ÇÅ) (Œª h, h_cases (eq_of_mem_singleton h))) (f x‚ÇÅ x‚ÇÇ) (subset_span (mem_range_self _)), rw supr_singleton, simp only at hxy, rw hxy, exact (subset_span (mem_range_self y‚ÇÇ)) }
exact (subset_span (mem_range_self y‚ÇÇ))
{ rintros ‚ü®x‚ÇÅ, x‚ÇÇ‚ü© ‚ü®y‚ÇÅ, y‚ÇÇ‚ü© hxy, by_cases h_cases : x‚ÇÅ = y‚ÇÅ, subst h_cases, { apply sigma.eq, rw linear_independent.injective (hindep _) hxy, refl }, { have h0 : f x‚ÇÅ x‚ÇÇ = 0, { apply disjoint_def.1 (hd x‚ÇÅ {y‚ÇÅ} (finite_singleton y‚ÇÅ) (Œª h, h_cases (eq_of_mem_singleton h))) (f x‚ÇÅ x‚ÇÇ) (subset_span (mem_range_self _)), rw supr_singleton, simp only at hxy, rw hxy, exact (subset_span (mem_range_self y‚ÇÇ)) }, exact false.elim ((hindep x‚ÇÅ).ne_zero _ h0) } }
exact false.elim ((hindep x‚ÇÅ).ne_zero _ h0)
rw range_sigma_eq_Union_range
apply linear_independent_Union_finite_subtype (Œª j, (hindep j).to_subtype_range) hd
have : ‚Üë((linear_independent.total_equiv hv : (Œπ ‚Üí‚ÇÄ R) ‚Üí‚Çó[R] span R (range v)) l) = finsupp.total Œπ M R v l := rfl
have : (linear_independent.total_equiv hv : (Œπ ‚Üí‚ÇÄ R) ‚Üí‚Çó[R] span R (range v)) l = x
rw eq at this
{ rw eq at this, exact subtype.ext_iff.2 this }
exact subtype.ext_iff.2 this
rw ‚Üêlinear_equiv.symm_apply_apply hv.total_equiv l
rw ‚Üêthis
refl
rw [hc, zero_smul]
rw basis.to_matrix
ext i j
simp [basis.equiv_fun, matrix.one_apply, finsupp.single, eq_comm]
rw [charpoly, det_apply', ‚Üê insert_erase (mem_univ (equiv.refl n)), sum_insert (not_mem_erase (equiv.refl n) univ), add_comm]
simp only [charmatrix_apply_eq, one_mul, equiv.perm.sign_refl, id.def, int.cast_one, units.coe_one, add_sub_cancel, equiv.coe_refl]
apply submodule.sum_mem (degree_lt R (fintype.card n - 1))
rw ‚Üê mem_degree_lt
rw [‚Üê C_eq_int_cast, C_mul']
intros c hc
apply submodule.smul_mem (degree_lt R (fintype.card n - 1)) ‚Üë‚Üë(equiv.perm.sign c)
apply lt_of_le_of_lt degree_le_nat_degree _
rw mem_degree_lt
rw with_bot.coe_lt_coe
apply lt_of_le_of_lt _ (equiv.perm.fixed_point_card_lt_of_ne_one (ne_of_mem_erase hc))
apply le_trans (polynomial.nat_degree_prod_le univ (Œª i : n, (charmatrix M (c i) i))) _
rw sum_filter
apply sum_le_sum
rw card_eq_sum_ones
apply charmatrix_apply_nat_degree_le
intros
ext i j
simp [pi.single_apply, one_apply, sub_eq_zero]
rw [‚Üê det_transpose, ‚Üê update_row_transpose, ‚Üê det_transpose A]
exact det_update_row_add_self A·µÄ hij
rcases nonsing_inv_cancel_or_zero A with ‚ü®h, h'‚ü© | h
{ exact fpow_add (is_unit_det_of_left_inverse h) m n }
exact fpow_add (is_unit_det_of_left_inverse h) m n
obtain ‚ü®k, rfl‚ü© := eq_coe_of_zero_le hm
obtain ‚ü®l, rfl‚ü© := eq_coe_of_zero_le hn
rw [‚Üêint.coe_nat_add, fpow_coe_nat, fpow_coe_nat, fpow_coe_nat, pow_add]
simp [‚Üê int.coe_nat_succ, pow_succ']
rcases nonsing_inv_cancel_or_zero A with ‚ü®h, h'‚ü© | h
{ apply fpow_add_one (is_unit_det_of_left_inverse h) }
apply fpow_add_one (is_unit_det_of_left_inverse h)
show A ^ (-((n + 1 : ‚Ñï) : ‚Ñ§)) = A ^ -((n + 2 : ‚Ñï) : ‚Ñ§) * A
simp_rw [fpow_neg_coe_nat, ‚Üêinv_pow', h, zero_pow nat.succ_pos', zero_mul]
simp only [one_div, inv_fpow]
rintros ‚ü®a, b‚ü© ‚ü®c, d‚ü© h
simp only [prod.mk.inj_iff, ne.def, not_and_distrib] at h
cases h with hac hbd
{ simp [hA hac] }
simp [hA hac]
simp [hB hbd]
ext i j
rw [mul_apply, pi.smul_apply, pi.smul_apply, one_apply, smul_eq_mul, mul_boole]
simp [mul_adjugate_apply, sum_cramer_apply, cramer_transpose_row_self, pi.single_apply, eq_comm]
simp_rw [linear_map.to_matrix, linear_equiv.trans_apply, linear_equiv.arrow_congr_comp _ v‚ÇÇ.equiv_fun, linear_map.to_matrix'_comp]
induction L with t L IH
{ simp }
simp
simp only [to_matrix_reindex_equiv, IH, function.comp_app, list.prod_cons, mul_eq_mul, reindex_alg_equiv_apply, list.map]
exact (reindex_alg_equiv_mul _ _ _ _).symm
induction hn : fintype.card n with r IH generalizing n M
unfreezingI { induction hn : fintype.card n with r IH generalizing n M }
refine ‚ü®list.nil, list.nil, Œª _, 1, _‚ü©
ext i j
rw fintype.card_eq_zero_iff at hn
{ refine ‚ü®list.nil, list.nil, Œª _, 1, _‚ü©, ext i j, rw fintype.card_eq_zero_iff at hn, exact hn.elim' i }
exact hn.elim' i
have e : n ‚âÉ fin r ‚äï unit
refine fintype.equiv_of_card_eq _
rw hn
convert (@fintype.card_sum (fin r) unit _ _).symm
{ refine fintype.equiv_of_card_eq _, rw hn, convert (@fintype.card_sum (fin r) unit _ _).symm, simp }
simp
apply reindex_exists_list_transvec_mul_mul_list_transvec_eq_diagonal M e
apply exists_list_transvec_mul_mul_list_transvec_eq_diagonal_induction (Œª N, IH (fin r) N (by simp))
simp
rcases exists_list_transvec_mul_diagonal_mul_list_transvec M with ‚ü®L, L', D, h‚ü©
have PD : P (diagonal D) := hdiag D (by simp [h])
simp [h]
suffices H : ‚àÄ (L‚ÇÅ L‚ÇÇ : list (transvection_struct n ùïú)) (E : matrix n n ùïú), P E ‚Üí P ((L‚ÇÅ.map to_matrix).prod ‚¨ù E ‚¨ù (L‚ÇÇ.map to_matrix).prod)
rw h
apply H L L'
exact PD
assume L‚ÇÅ L‚ÇÇ E PE
induction L‚ÇÅ with t L‚ÇÅ IH
simp only [matrix.one_mul, list.prod_nil, list.map]
induction L‚ÇÇ with t L‚ÇÇ IH generalizing E
{ simpa }
simpa
simp only [‚Üêmatrix.mul_assoc, list.prod_cons, mul_eq_mul, list.map]
apply IH
{ simp only [matrix.one_mul, list.prod_nil, list.map], induction L‚ÇÇ with t L‚ÇÇ IH generalizing E, { simpa }, { simp only [‚Üêmatrix.mul_assoc, list.prod_cons, mul_eq_mul, list.map], apply IH, exact hmul _ _ PE (htransvec _) } }
exact hmul _ _ PE (htransvec _)
simp only [matrix.mul_assoc, list.prod_cons, mul_eq_mul, list.map] at ‚ä¢ IH
exact hmul _ _ (htransvec _) IH
ext m
refl
ext m
rw [smul_apply]
refl
simp only [‚Üê sum.update_elim_inr, f.map_add]
simp only [‚Üê sum.update_elim_inr, f.map_smul]
simp only [multilinear_map.coe_mk, add_apply, ‚Üê sum.update_elim_inl, f.map_add]
simp only [multilinear_map.coe_mk, smul_apply, ‚Üê sum.update_elim_inl, f.map_smul]
induction n using nat.strong_induction_on with n IH generalizing A
by_cases Ai_empty : ‚àÉ i, A i = ‚àÖ
rcases Ai_empty with ‚ü®i, hi‚ü©
convert sum_empty
have : ‚àë j in A i, g i j = 0
rw f.map_coord_zero i this
have : pi_finset A = ‚àÖ
apply finset.eq_empty_of_forall_not_mem (Œª r hr, _)
have : r i ‚àà A i := mem_pi_finset.mp hr i
{ apply finset.eq_empty_of_forall_not_mem (Œª r hr, _), have : r i ‚àà A i := mem_pi_finset.mp hr i, rwa hi at this }
rwa hi at this
{ rcases Ai_empty with ‚ü®i, hi‚ü©, have : ‚àë j in A i, g i j = 0, by convert sum_empty, rw f.map_coord_zero i this, have : pi_finset A = ‚àÖ, { apply finset.eq_empty_of_forall_not_mem (Œª r hr, _), have : r i ‚àà A i := mem_pi_finset.mp hr i, rwa hi at this }, convert sum_empty.symm }
convert sum_empty.symm
push_neg at Ai_empty
by_cases Ai_singleton : ‚àÄ i, (A i).card ‚â§ 1
have Ai_card : ‚àÄ i, (A i).card = 1
assume i
simp [finset.card_eq_zero, Ai_empty i]
have pos : finset.card (A i) ‚â† 0
have : finset.card (A i) ‚â§ 1 := Ai_singleton i
exact le_antisymm this (nat.succ_le_of_lt (_root_.pos_iff_ne_zero.mpr pos))
{ assume i, have pos : finset.card (A i) ‚â† 0, by simp [finset.card_eq_zero, Ai_empty i], have : finset.card (A i) ‚â§ 1 := Ai_singleton i, exact le_antisymm this (nat.succ_le_of_lt (_root_.pos_iff_ne_zero.mpr pos)) }
have : ‚àÄ (r : Œ† i, Œ± i), r ‚àà pi_finset A ‚Üí f (Œª i, g i (r i)) = f (Œª i, ‚àë j in A i, g i j)
assume r hr
unfold_coes
congr' with i
have : ‚àÄ j ‚àà A i, g i j = g i (r i)
assume j hj
congr
apply finset.card_le_one_iff.1 (Ai_singleton i) hj
{ assume j hj, congr, apply finset.card_le_one_iff.1 (Ai_singleton i) hj, exact mem_pi_finset.mp hr i }
exact mem_pi_finset.mp hr i
simp only [finset.sum_congr rfl this, finset.mem_univ, finset.sum_const, Ai_card i, one_nsmul]
{ assume r hr, unfold_coes, congr' with i, have : ‚àÄ j ‚àà A i, g i j = g i (r i), { assume j hj, congr, apply finset.card_le_one_iff.1 (Ai_singleton i) hj, exact mem_pi_finset.mp hr i }, simp only [finset.sum_congr rfl this, finset.mem_univ, finset.sum_const, Ai_card i, one_nsmul] }
simp only [sum_congr rfl this, Ai_card, card_pi_finset, prod_const_one, one_nsmul, finset.sum_const]
{ have Ai_card : ‚àÄ i, (A i).card = 1, { assume i, have pos : finset.card (A i) ‚â† 0, by simp [finset.card_eq_zero, Ai_empty i], have : finset.card (A i) ‚â§ 1 := Ai_singleton i, exact le_antisymm this (nat.succ_le_of_lt (_root_.pos_iff_ne_zero.mpr pos)) }, have : ‚àÄ (r : Œ† i, Œ± i), r ‚àà pi_finset A ‚Üí f (Œª i, g i (r i)) = f (Œª i, ‚àë j in A i, g i j), { assume r hr, unfold_coes, congr' with i, have : ‚àÄ j ‚àà A i, g i j = g i (r i), { assume j hj, congr, apply finset.card_le_one_iff.1 (Ai_singleton i) hj, exact mem_pi_finset.mp hr i }, simp only [finset.sum_congr rfl this, finset.mem_univ, finset.sum_const, Ai_card i, one_nsmul] }, simp only [sum_congr rfl this, Ai_card, card_pi_finset, prod_const_one, one_nsmul, finset.sum_const] }
push_neg at Ai_singleton
obtain ‚ü®i‚ÇÄ, hi‚ÇÄ‚ü© : ‚àÉ i, 1 < (A i).card := Ai_singleton
obtain ‚ü®j‚ÇÅ, j‚ÇÇ, hj‚ÇÅ, hj‚ÇÇ, j‚ÇÅ_ne_j‚ÇÇ‚ü© : ‚àÉ j‚ÇÅ j‚ÇÇ, (j‚ÇÅ ‚àà A i‚ÇÄ) ‚àß (j‚ÇÇ ‚àà A i‚ÇÄ) ‚àß j‚ÇÅ ‚â† j‚ÇÇ := finset.one_lt_card_iff.1 hi‚ÇÄ
let B := function.update A i‚ÇÄ (A i‚ÇÄ \ {j‚ÇÇ})
let C := function.update A i‚ÇÄ {j‚ÇÇ}
have B_subset_A : ‚àÄ i, B i ‚äÜ A i
assume i
by_cases hi : i = i‚ÇÄ
simp only [B, sdiff_subset, update_same]
{ rw hi, simp only [B, sdiff_subset, update_same]}
rw hi
simp only [hi, B, update_noteq, ne.def, not_false_iff, finset.subset.refl]
{ assume i, by_cases hi : i = i‚ÇÄ, { rw hi, simp only [B, sdiff_subset, update_same]}, { simp only [hi, B, update_noteq, ne.def, not_false_iff, finset.subset.refl] } }
have C_subset_A : ‚àÄ i, C i ‚äÜ A i
assume i
by_cases hi : i = i‚ÇÄ
simp only [C, hj‚ÇÇ, finset.singleton_subset_iff, update_same]
{ rw hi, simp only [C, hj‚ÇÇ, finset.singleton_subset_iff, update_same] }
rw hi
simp only [hi, C, update_noteq, ne.def, not_false_iff, finset.subset.refl]
{ assume i, by_cases hi : i = i‚ÇÄ, { rw hi, simp only [C, hj‚ÇÇ, finset.singleton_subset_iff, update_same] }, { simp only [hi, C, update_noteq, ne.def, not_false_iff, finset.subset.refl] } }
have A_eq_BC : (Œª i, ‚àë j in A i, g i j) = function.update (Œª i, ‚àë j in A i, g i j) i‚ÇÄ (‚àë j in B i‚ÇÄ, g i‚ÇÄ j + ‚àë j in C i‚ÇÄ, g i‚ÇÄ j)
ext i
by_cases hi : i = i‚ÇÄ
rw [hi]
simp only [function.update_same]
have : A i‚ÇÄ = B i‚ÇÄ ‚à™ C i‚ÇÄ
simp only [B, C, function.update_same, finset.sdiff_union_self_eq_union]
symmetry
{ simp only [B, C, function.update_same, finset.sdiff_union_self_eq_union], symmetry, simp only [hj‚ÇÇ, finset.singleton_subset_iff, finset.union_eq_left_iff_subset] }
simp only [hj‚ÇÇ, finset.singleton_subset_iff, finset.union_eq_left_iff_subset]
rw this
apply finset.sum_union
apply finset.disjoint_right.2 (Œª j hj, _)
dsimp [C] at hj
simpa using hj
have : j = j‚ÇÇ
rw this
dsimp [B]
simp only [mem_sdiff, eq_self_iff_true, not_true, not_false_iff, finset.mem_singleton, update_same, and_false]
{ rw [hi], simp only [function.update_same], have : A i‚ÇÄ = B i‚ÇÄ ‚à™ C i‚ÇÄ, { simp only [B, C, function.update_same, finset.sdiff_union_self_eq_union], symmetry, simp only [hj‚ÇÇ, finset.singleton_subset_iff, finset.union_eq_left_iff_subset] }, rw this, apply finset.sum_union, apply finset.disjoint_right.2 (Œª j hj, _), have : j = j‚ÇÇ, by { dsimp [C] at hj, simpa using hj }, rw this, dsimp [B], simp only [mem_sdiff, eq_self_iff_true, not_true, not_false_iff, finset.mem_singleton, update_same, and_false] }
{ ext i, by_cases hi : i = i‚ÇÄ, { rw [hi], simp only [function.update_same], have : A i‚ÇÄ = B i‚ÇÄ ‚à™ C i‚ÇÄ, { simp only [B, C, function.update_same, finset.sdiff_union_self_eq_union], symmetry, simp only [hj‚ÇÇ, finset.singleton_subset_iff, finset.union_eq_left_iff_subset] }, rw this, apply finset.sum_union, apply finset.disjoint_right.2 (Œª j hj, _), have : j = j‚ÇÇ, by { dsimp [C] at hj, simpa using hj }, rw this, dsimp [B], simp only [mem_sdiff, eq_self_iff_true, not_true, not_false_iff, finset.mem_singleton, update_same, and_false] }, { simp [hi] } }
simp [hi]
have Beq : function.update (Œª i, ‚àë j in A i, g i j) i‚ÇÄ (‚àë j in B i‚ÇÄ, g i‚ÇÄ j) = (Œª i, ‚àë j in B i, g i j)
ext i
by_cases hi : i = i‚ÇÄ
simp only [update_same]
{ rw hi, simp only [update_same] }
rw hi
{ ext i, by_cases hi : i = i‚ÇÄ, { rw hi, simp only [update_same] }, { simp only [hi, B, update_noteq, ne.def, not_false_iff] } }
simp only [hi, B, update_noteq, ne.def, not_false_iff]
have Ceq : function.update (Œª i, ‚àë j in A i, g i j) i‚ÇÄ (‚àë j in C i‚ÇÄ, g i‚ÇÄ j) = (Œª i, ‚àë j in C i, g i j)
ext i
by_cases hi : i = i‚ÇÄ
simp only [update_same]
{ rw hi, simp only [update_same] }
rw hi
{ ext i, by_cases hi : i = i‚ÇÄ, { rw hi, simp only [update_same] }, { simp only [hi, C, update_noteq, ne.def, not_false_iff] } }
simp only [hi, C, update_noteq, ne.def, not_false_iff]
have Brec : f (Œª i, ‚àë j in B i, g i j) = ‚àë r in pi_finset B, f (Œª i, g i (r i))
have : ‚àë i, finset.card (B i) < ‚àë i, finset.card (A i)
refine finset.sum_lt_sum (Œª i hi, finset.card_le_of_subset (B_subset_A i)) ‚ü®i‚ÇÄ, finset.mem_univ _, _‚ü©
simp [hj‚ÇÇ]
have : {j‚ÇÇ} ‚äÜ A i‚ÇÄ
simp only [B, finset.card_sdiff this, function.update_same, finset.card_singleton]
{ refine finset.sum_lt_sum (Œª i hi, finset.card_le_of_subset (B_subset_A i)) ‚ü®i‚ÇÄ, finset.mem_univ _, _‚ü©, have : {j‚ÇÇ} ‚äÜ A i‚ÇÄ, by simp [hj‚ÇÇ], simp only [B, finset.card_sdiff this, function.update_same, finset.card_singleton], exact nat.pred_lt (ne_of_gt (lt_trans nat.zero_lt_one hi‚ÇÄ)) }
exact nat.pred_lt (ne_of_gt (lt_trans nat.zero_lt_one hi‚ÇÄ))
rw h at this
{ have : ‚àë i, finset.card (B i) < ‚àë i, finset.card (A i), { refine finset.sum_lt_sum (Œª i hi, finset.card_le_of_subset (B_subset_A i)) ‚ü®i‚ÇÄ, finset.mem_univ _, _‚ü©, have : {j‚ÇÇ} ‚äÜ A i‚ÇÄ, by simp [hj‚ÇÇ], simp only [B, finset.card_sdiff this, function.update_same, finset.card_singleton], exact nat.pred_lt (ne_of_gt (lt_trans nat.zero_lt_one hi‚ÇÄ)) }, rw h at this, exact IH _ this B rfl }
exact IH _ this B rfl
have Crec : f (Œª i, ‚àë j in C i, g i j) = ‚àë r in pi_finset C, f (Œª i, g i (r i))
have : ‚àë i, finset.card (C i) < ‚àë i, finset.card (A i) := finset.sum_lt_sum (Œª i hi, finset.card_le_of_subset (C_subset_A i)) ‚ü®i‚ÇÄ, finset.mem_univ _, by simp [C, hi‚ÇÄ]‚ü©
simp [C, hi‚ÇÄ]
rw h at this
{ have : ‚àë i, finset.card (C i) < ‚àë i, finset.card (A i) := finset.sum_lt_sum (Œª i hi, finset.card_le_of_subset (C_subset_A i)) ‚ü®i‚ÇÄ, finset.mem_univ _, by simp [C, hi‚ÇÄ]‚ü©, rw h at this, exact IH _ this C rfl }
exact IH _ this C rfl
have D : disjoint (pi_finset B) (pi_finset C)
simp [B, C]
have : disjoint (B i‚ÇÄ) (C i‚ÇÄ)
{ have : disjoint (B i‚ÇÄ) (C i‚ÇÄ), by simp [B, C], exact pi_finset_disjoint_of_disjoint B C this }
exact pi_finset_disjoint_of_disjoint B C this
have pi_BC : pi_finset A = pi_finset B ‚à™ pi_finset C
apply finset.subset.antisymm
assume r hr
by_cases hri‚ÇÄ : r i‚ÇÄ = j‚ÇÇ
apply finset.mem_union_right
apply mem_pi_finset.2 (Œª i, _)
by_cases hi : i = i‚ÇÄ
have : r i‚ÇÄ ‚àà C i‚ÇÄ
simp [C, hri‚ÇÄ]
convert this
{ have : r i‚ÇÄ ‚àà C i‚ÇÄ, by simp [C, hri‚ÇÄ], convert this }
simp [C, hi, mem_pi_finset.1 hr i]
{ apply finset.mem_union_right, apply mem_pi_finset.2 (Œª i, _), by_cases hi : i = i‚ÇÄ, { have : r i‚ÇÄ ‚àà C i‚ÇÄ, by simp [C, hri‚ÇÄ], convert this }, { simp [C, hi, mem_pi_finset.1 hr i] } }
apply finset.mem_union_left
apply mem_pi_finset.2 (Œª i, _)
by_cases hi : i = i‚ÇÄ
have : r i‚ÇÄ ‚àà B i‚ÇÄ
simp [B, hri‚ÇÄ, mem_pi_finset.1 hr i‚ÇÄ]
convert this
{ have : r i‚ÇÄ ‚àà B i‚ÇÄ, by simp [B, hri‚ÇÄ, mem_pi_finset.1 hr i‚ÇÄ], convert this }
simp [B, hi, mem_pi_finset.1 hr i]
{ assume r hr, by_cases hri‚ÇÄ : r i‚ÇÄ = j‚ÇÇ, { apply finset.mem_union_right, apply mem_pi_finset.2 (Œª i, _), by_cases hi : i = i‚ÇÄ, { have : r i‚ÇÄ ‚àà C i‚ÇÄ, by simp [C, hri‚ÇÄ], convert this }, { simp [C, hi, mem_pi_finset.1 hr i] } }, { apply finset.mem_union_left, apply mem_pi_finset.2 (Œª i, _), by_cases hi : i = i‚ÇÄ, { have : r i‚ÇÄ ‚àà B i‚ÇÄ, by simp [B, hri‚ÇÄ, mem_pi_finset.1 hr i‚ÇÄ], convert this }, { simp [B, hi, mem_pi_finset.1 hr i] } } }
exact finset.union_subset (pi_finset_subset _ _ (Œª i, B_subset_A i)) (pi_finset_subset _ _ (Œª i, C_subset_A i))
{ apply finset.subset.antisymm, { assume r hr, by_cases hri‚ÇÄ : r i‚ÇÄ = j‚ÇÇ, { apply finset.mem_union_right, apply mem_pi_finset.2 (Œª i, _), by_cases hi : i = i‚ÇÄ, { have : r i‚ÇÄ ‚àà C i‚ÇÄ, by simp [C, hri‚ÇÄ], convert this }, { simp [C, hi, mem_pi_finset.1 hr i] } }, { apply finset.mem_union_left, apply mem_pi_finset.2 (Œª i, _), by_cases hi : i = i‚ÇÄ, { have : r i‚ÇÄ ‚àà B i‚ÇÄ, by simp [B, hri‚ÇÄ, mem_pi_finset.1 hr i‚ÇÄ], convert this }, { simp [B, hi, mem_pi_finset.1 hr i] } } }, { exact finset.union_subset (pi_finset_subset _ _ (Œª i, B_subset_A i)) (pi_finset_subset _ _ (Œª i, C_subset_A i)) } }
rw A_eq_BC
simp only [multilinear_map.map_add, Beq, Ceq, Brec, Crec, pi_BC]
rw ‚Üê finset.sum_union D
simp [pi_ring, linear_map.lsum]
ext
ext; simp
simp
apply le_antisymm _ (ker_prod_ker_le_ker_coprod f g)
rintros ‚ü®y, z‚ü© h
simp only [mem_ker, mem_prod, coprod_apply] at h ‚ä¢
have : f y ‚àà f.range ‚äì g.range
simp only [true_and, mem_range, mem_inf, exists_apply_eq_apply]
use -z
{ simp only [true_and, mem_range, mem_inf, exists_apply_eq_apply], use -z, rwa [eq_comm, map_neg, ‚Üê sub_eq_zero, sub_neg_eq_add] }
rwa [eq_comm, map_neg, ‚Üê sub_eq_zero, sub_neg_eq_add]
rw [hd.eq_bot, mem_bot] at this
rw [this] at h
simpa [this] using h
ext x
have : x ‚àà p ‚äî f.ker
{ simp only [(is_compl_of_proj hf).sup_eq_top, mem_top] }
simp only [(is_compl_of_proj hf).sup_eq_top, mem_top]
rcases mem_sup'.1 this with ‚ü®x, y, rfl‚ü©
simp [hf]
rw [‚Üêneg_sub, map_neg]
rw [polar_comm, polar_add_left, polar_comm f y x, polar_comm f y' x]
rw [polar_comm, polar_smul_left, polar_comm f y x, smul_eq_mul]
simp only [discr, to_matrix'_smul, matrix.det_smul]
have hw' : ‚àÄ i : Œπ, (w i : ‚ÑÇ) ^ - (1 / 2 : ‚ÑÇ) ‚â† 0
intros i hi
exact (w i).ne_zero ((complex.cpow_eq_zero_iff _ _).1 hi).1
{ intros i hi, exact (w i).ne_zero ((complex.cpow_eq_zero_iff _ _).1 hi).1 }
convert (weighted_sum_squares ‚ÑÇ w).isometry_basis_repr ((pi.basis_fun ‚ÑÇ Œπ).units_smul (Œª i, (is_unit_iff_ne_zero.2 $ hw' i).unit))
ext1 v
erw [basis_repr_apply, weighted_sum_squares_apply, weighted_sum_squares_apply]
refine sum_congr rfl (Œª j hj, _)
have hsum : (‚àë (i : Œπ), v i ‚Ä¢ ((is_unit_iff_ne_zero.2 $ hw' i).unit : ‚ÑÇ) ‚Ä¢ (pi.basis_fun ‚ÑÇ Œπ) i) j = v j ‚Ä¢ w j ^ - (1 / 2 : ‚ÑÇ)
rw [finset.sum_apply, sum_eq_single j, pi.basis_fun_apply, is_unit.unit_spec, linear_map.std_basis_apply, pi.smul_apply, pi.smul_apply, function.update_same, smul_eq_mul, smul_eq_mul, smul_eq_mul, mul_one]
intros i _ hij
rw [pi.basis_fun_apply, linear_map.std_basis_apply, pi.smul_apply, pi.smul_apply, function.update_noteq hij.symm, pi.zero_apply, smul_eq_mul, smul_eq_mul, mul_zero, mul_zero]
exact false.elim (hj' hj)
{ rw [finset.sum_apply, sum_eq_single j, pi.basis_fun_apply, is_unit.unit_spec, linear_map.std_basis_apply, pi.smul_apply, pi.smul_apply, function.update_same, smul_eq_mul, smul_eq_mul, smul_eq_mul, mul_one], intros i _ hij, rw [pi.basis_fun_apply, linear_map.std_basis_apply, pi.smul_apply, pi.smul_apply, function.update_noteq hij.symm, pi.zero_apply, smul_eq_mul, smul_eq_mul, mul_zero, mul_zero], intro hj', exact false.elim (hj' hj) }
intro hj'
simp_rw basis.units_smul_apply
erw [hsum, smul_eq_mul]
suffices : 1 * v j * v j = w j ^ - (1 / 2 : ‚ÑÇ) * w j ^ - (1 / 2 : ‚ÑÇ) * w j * v j * v j
erw [pi.one_apply, ‚Üê mul_assoc, this, smul_eq_mul, smul_eq_mul]
ring
{ erw [pi.one_apply, ‚Üê mul_assoc, this, smul_eq_mul, smul_eq_mul], ring }
rw [‚Üê complex.cpow_add _ _ (w j).ne_zero, show - (1 / 2 : ‚ÑÇ) + - (1 / 2) = -1, by ring, complex.cpow_neg_one, inv_mul_cancel (w j).ne_zero]
ring
intros
ext
unfold coe_fn has_coe_to_fun.coe sesq coe_fn has_coe_to_fun.coe sesq
rw add_assoc
intros
ext
unfold coe_fn has_coe_to_fun.coe sesq
rw zero_add
intros
ext
unfold coe_fn has_coe_to_fun.coe sesq
rw add_zero
intros
ext
unfold coe_fn has_coe_to_fun.coe sesq
rw neg_add_self
intros
ext
unfold coe_fn has_coe_to_fun.coe sesq
rw add_comm
simp [add_left]
simp [smul_left]
simp [add_right]
simp [smul_right]
rw [‚Üêzero_smul R (0 : M), smul_left, zero_mul]
ext a b
by_cases hi : i = a; by_cases hj : j = b
by_cases hj : j = b
by_cases hj : j = b
by_cases hi : i = a
{ simp [std_basis, hi, hj] }
simp [std_basis, hi, hj]
simp [std_basis, hi, hj, ne.symm hj, linear_map.std_basis_ne]
{ simp [std_basis, hi, hj, ne.symm hj, linear_map.std_basis_ne] }
simp [std_basis, hi, hj, ne.symm hi, linear_map.std_basis_ne]
{ simp [std_basis, hi, hj, ne.symm hi, linear_map.std_basis_ne] }
simp [std_basis, hi, hj, ne.symm hj, ne.symm hi, linear_map.std_basis_ne]
simp [decidable.imp_iff_not_or, or.comm, or.left_comm]
simp [@eq_comm _ a']
intros x y h
dsimp at h
split_ifs at h; try { substI b }; try { simp only [f.injective.eq_iff] at * }; cc
split_ifs at h; try { substI b }; try { simp only [f.injective.eq_iff] at * }
split_ifs at h; try { substI b }
try { substI b }
try { substI b }
try { substI b }
try { substI b }
try { substI b }
try { substI b }
try { substI b }
try { substI b }
try { substI b }
substI b
try { simp only [f.injective.eq_iff] at * }
try { simp only [f.injective.eq_iff] at * }
try { simp only [f.injective.eq_iff] at * }
try { simp only [f.injective.eq_iff] at * }
try { simp only [f.injective.eq_iff] at * }
try { simp only [f.injective.eq_iff] at * }
try { simp only [f.injective.eq_iff] at * }
try { simp only [f.injective.eq_iff] at * }
try { simp only [f.injective.eq_iff] at * }
simp only [f.injective.eq_iff] at *
split_ifs at h
cc
cc
cc
cc
cc
cc
cc
cc
cc
subst hŒ±
have : ‚àÄa, f a == f' a
exact h a a (heq.refl a)
{ intro a, exact h a a (heq.refl a) }
intro a
have : Œ≤ = Œ≤'
exact type_eq_of_heq (this a)
{ funext a, exact type_eq_of_heq (this a) }
funext a
subst this
apply heq_of_eq
funext a
exact eq_of_heq (this a)
rw [nat.add_succ, iterate_succ, iterate_succ, iterate_add]
rcases exists_pair_ne Œ± with ‚ü®y, y', h‚ü©
by_cases hx : x = y
rw ‚Üê hx at h
{ rw ‚Üê hx at h, exact ‚ü®y', h.symm‚ü© }
exact ‚ü®y', h.symm‚ü©
exact ‚ü®y, ne.symm hx‚ü©
intros x y h
induction h with z w a b c
{ refl }
refl
apply relation.refl_trans_gen.head (h b) c
induction h generalizing P
exact refl
case refl_trans_gen.refl { exact refl }
case refl_trans_gen.tail : b c hab hbc ih { apply ih, show P b _, from head hbc _ refl, show ‚àÄ a a', r a a' ‚Üí refl_trans_gen r a' b ‚Üí P a' _ ‚Üí P a _, from Œª a a' hab hbc, head hab _ }
apply ih
from head hbc _ refl
show P b _
show ‚àÄ a a', r a a' ‚Üí refl_trans_gen r a' b ‚Üí P a' _ ‚Üí P a _
from Œª a a' hab hbc, head hab _
refine (top_le_iff.1 $ Œª s hs, bUnion_of_singleton s ‚ñ∏ _)
apply measurable_set.bUnion s.countable_encodable
intros x hx
casesI is_empty_or_nonempty Œ≤
haveI := function.is_empty f
simp only [(measurable_of_empty (g ‚àò f)).ae_measurable, (measurable_of_empty f).ae_measurable]
{ haveI := function.is_empty f, simp only [(measurable_of_empty (g ‚àò f)).ae_measurable, (measurable_of_empty f).ae_measurable] }
refine ‚ü®Œª hf, _, Œª hf, hg.measurable.comp_ae_measurable hf‚ü©
convert hg.measurable_inv_fun.comp_ae_measurable hf
ext x
apply measurable_set.of_compl
exact (function.left_inverse_inv_fun hg.to_embedding.inj (f x)).symm
apply generate_measurable.basic
exact is_closed_singleton.is_open_compl
rw hŒº
exact ae_measurable_zero_measure
by_cases hŒº : Œº = 0
{ rw hŒº, exact ae_measurable_zero_measure }
simpa [ne_bot_iff]
haveI : Œº.ae.ne_bot
{ simpa [ne_bot_iff] }
exact ae_measurable.is_lub_of_nonempty hŒπ hf hg
by_cases hŒπ : nonempty Œπ
{ exact ae_measurable.is_lub_of_nonempty hŒπ hf hg, }
suffices : ‚àÉ x, g =·µê[Œº] Œª y, g x
exact ‚ü®(Œª y, g this.some), measurable_const, this.some_spec‚ü©
have h_empty : ‚àÄ x, {a : Œ± | ‚àÉ (i : Œπ), f i x = a} = ‚àÖ
intro x
ext1 y
rw [set.mem_set_of_eq, set.mem_empty_eq, iff_false]
{ intro x, ext1 y, rw [set.mem_set_of_eq, set.mem_empty_eq, iff_false], exact Œª hi, hŒπ (nonempty_of_exists hi), }
exact Œª hi, hŒπ (nonempty_of_exists hi)
simp_rw h_empty at hg
exact ‚ü®hg.exists.some, hg.mono (Œª y hy, is_lub.unique hy hg.exists.some_spec)‚ü©
simp_rw [hu.to_has_basis.liminf_eq_supr_infi]
refine measurable_bsupr _ hu.countable _
exact Œª i, measurable_binfi _ (hs i) hf
rw [‚Üê funext hC, generate_from_pi_eq h2C]
exact pi_Ico_ae_eq_pi_Icc
rw ‚Üê pi_univ_Icc
convert set_integral_fun_unique_pi' Œπ volume f s
refine prod_eq (Œª s t hs ht, _)
simp_rw [map_apply measurable_prod_mk_left (hs.prod ht), mk_preimage_prod_right_eq_if, measure_if, dirac_apply' _ hs, ‚Üê indicator_mul_left _ _ (Œª x, ŒΩ t), pi.one_apply, one_mul]
ext1 i hi
rw [vector_measure.smul_apply, to_signed_measure, to_signed_measure, to_signed_measure_sub_apply hi, to_signed_measure_sub_apply hi, smul_sub, smul_pos_part, smul_neg_part, ‚Üê ennreal.to_real_smul, ‚Üê ennreal.to_real_smul]
refl
rw restrict_le_restrict_iff at hsu hsv
have a := hsu (hu.diff hv) (u.diff_subset v)
have b := hsv (hv.diff hu) (v.diff_subset u)
erw [of_union (set.disjoint_of_subset_left (u.diff_subset v) set.disjoint_diff) (hu.diff hv) (hv.diff hu)] at hs
rw zero_apply at a b
split
linarith
linarith
linarith
linarith
linarith
apply_instance
apply_instance
apply_instance
all_goals { linarith <|> apply_instance <|> assumption }
assumption
assumption
simp [total_variation, to_jordan_decomposition_zero]
haveI : have_lebesgue_decomposition Œº ŒΩ := ‚ü®‚ü®‚ü®s, f‚ü©, hf, hs, hadd‚ü©‚ü©
obtain ‚ü®hmeas, hsing, hadd'‚ü© := have_lebesgue_decomposition_spec Œº ŒΩ
obtain ‚ü®‚ü®S, hS‚ÇÅ, hS‚ÇÇ, hS‚ÇÉ‚ü©, ‚ü®T, hT‚ÇÅ, hT‚ÇÇ, hT‚ÇÉ‚ü©‚ü© := ‚ü®hs, hsing‚ü©
rw hadd' at hadd
have hŒΩinter : ŒΩ (S ‚à© T)·∂ú = 0
rw set.compl_inter
refine nonpos_iff_eq_zero.1 (le_trans (measure_union_le _ _) _)
rw [hT‚ÇÉ, hS‚ÇÉ, add_zero]
{ rw set.compl_inter, refine nonpos_iff_eq_zero.1 (le_trans (measure_union_le _ _) _), rw [hT‚ÇÉ, hS‚ÇÉ, add_zero], exact le_refl _ }
exact le_refl _
have heq : s.restrict (S ‚à© T)·∂ú = (Œº.singular_part ŒΩ).restrict (S ‚à© T)·∂ú
ext1 A hA
have hf : ŒΩ.with_density f (A ‚à© (S ‚à© T)·∂ú) = 0
refine with_density_absolutely_continuous ŒΩ _ _
rw ‚Üê nonpos_iff_eq_zero
{ refine with_density_absolutely_continuous ŒΩ _ _, rw ‚Üê nonpos_iff_eq_zero, exact hŒΩinter ‚ñ∏ measure_mono (set.inter_subset_right _ _) }
exact hŒΩinter ‚ñ∏ measure_mono (set.inter_subset_right _ _)
have hrn : ŒΩ.with_density (Œº.rn_deriv ŒΩ) (A ‚à© (S ‚à© T)·∂ú) = 0
refine with_density_absolutely_continuous ŒΩ _ _
rw ‚Üê nonpos_iff_eq_zero
{ refine with_density_absolutely_continuous ŒΩ _ _, rw ‚Üê nonpos_iff_eq_zero, exact hŒΩinter ‚ñ∏ measure_mono (set.inter_subset_right _ _) }
exact hŒΩinter ‚ñ∏ measure_mono (set.inter_subset_right _ _)
rw [restrict_apply hA, restrict_apply hA, ‚Üê add_zero (s (A ‚à© (S ‚à© T)·∂ú)), ‚Üê hf, ‚Üê add_apply, ‚Üê hadd, add_apply, hrn, add_zero]
{ ext1 A hA, have hf : ŒΩ.with_density f (A ‚à© (S ‚à© T)·∂ú) = 0, { refine with_density_absolutely_continuous ŒΩ _ _, rw ‚Üê nonpos_iff_eq_zero, exact hŒΩinter ‚ñ∏ measure_mono (set.inter_subset_right _ _) }, have hrn : ŒΩ.with_density (Œº.rn_deriv ŒΩ) (A ‚à© (S ‚à© T)·∂ú) = 0, { refine with_density_absolutely_continuous ŒΩ _ _, rw ‚Üê nonpos_iff_eq_zero, exact hŒΩinter ‚ñ∏ measure_mono (set.inter_subset_right _ _) }, rw [restrict_apply hA, restrict_apply hA, ‚Üê add_zero (s (A ‚à© (S ‚à© T)·∂ú)), ‚Üê hf, ‚Üê add_apply, ‚Üê hadd, add_apply, hrn, add_zero] }
have heq' : ‚àÄ A : set Œ±, measurable_set A ‚Üí s A = s.restrict (S ‚à© T)·∂ú A
intros A hA
have hsinter : s (A ‚à© (S ‚à© T)) = 0
rw ‚Üê nonpos_iff_eq_zero
exact hS‚ÇÇ ‚ñ∏ measure_mono (set.subset.trans (set.inter_subset_right _ _) (set.inter_subset_left _ _))
{ rw ‚Üê nonpos_iff_eq_zero, exact hS‚ÇÇ ‚ñ∏ measure_mono (set.subset.trans (set.inter_subset_right _ _) (set.inter_subset_left _ _)) }
rw [restrict_apply hA, ‚Üê add_zero (s (A ‚à© (S ‚à© T)·∂ú)), ‚Üê hsinter, ‚Üê measure_union, ‚Üê set.inter_union_distrib_left, set.compl_union_self, set.inter_univ]
exact disjoint.inter_left' _ ( disjoint.inter_right' _ disjoint_compl_left)
{ exact disjoint.inter_left' _ ( disjoint.inter_right' _ disjoint_compl_left) }
{ measurability }
measurability
{ intros A hA, have hsinter : s (A ‚à© (S ‚à© T)) = 0, { rw ‚Üê nonpos_iff_eq_zero, exact hS‚ÇÇ ‚ñ∏ measure_mono (set.subset.trans (set.inter_subset_right _ _) (set.inter_subset_left _ _)) }, rw [restrict_apply hA, ‚Üê add_zero (s (A ‚à© (S ‚à© T)·∂ú)), ‚Üê hsinter, ‚Üê measure_union, ‚Üê set.inter_union_distrib_left, set.compl_union_self, set.inter_univ], { exact disjoint.inter_left' _ ( disjoint.inter_right' _ disjoint_compl_left) }, { measurability }, { measurability } }
measurability
ext1 A hA
have hŒºinter : Œº.singular_part ŒΩ (A ‚à© (S ‚à© T)) = 0
rw ‚Üê nonpos_iff_eq_zero
exact hT‚ÇÇ ‚ñ∏ measure_mono (set.subset.trans (set.inter_subset_right _ _) (set.inter_subset_right _ _))
{ rw ‚Üê nonpos_iff_eq_zero, exact hT‚ÇÇ ‚ñ∏ measure_mono (set.subset.trans (set.inter_subset_right _ _) (set.inter_subset_right _ _)) }
rw [heq' A hA, heq, ‚Üê add_zero ((Œº.singular_part ŒΩ).restrict (S ‚à© T)·∂ú A), ‚Üê hŒºinter, restrict_apply hA, ‚Üê measure_union, ‚Üê set.inter_union_distrib_left, set.compl_union_self, set.inter_univ]
exact disjoint.inter_left' _ ( disjoint.inter_right' _ disjoint_compl_left)
{ exact disjoint.inter_left' _ ( disjoint.inter_right' _ disjoint_compl_left) }
{ measurability }
measurability
measurability
convert supr_mem_measurable_le f hf n
ext
simp
apply coe_fn_mk
rw pair_eq_mk
ext1
refine (mem_‚Ñíp.coe_fn_to_Lp _).trans _
refine eventually_eq.trans _ (Lp.coe_fn_add _ _).symm
refine eventually_eq.trans _ (eventually_eq.add (mem_‚Ñíp.coe_fn_to_Lp _).symm (mem_‚Ñíp.coe_fn_to_Lp _).symm)
rw condexp_ind_smul_add
refine (Lp.coe_fn_add _ _).trans (eventually_of_forall (Œª a, _))
refl
exact condexp_L1_clm_indicator_const_Lp hs hŒºs x
rw Lp.simple_func.coe_indicator_const
rw set_integral_congr_ae (hm s hs) ((condexp_ae_eq_condexp_L1 f).mono (Œª x hx _, hx))
exact set_integral_condexp_L1 hf hs
suffices h_nnnorm_eq_zero : ‚à´‚Åª x in s, ‚à•condexp_L2 ‚Ñù hm f x‚à•‚Çä ‚àÇŒº = 0
rw lintegral_eq_zero_iff at h_nnnorm_eq_zero
refine h_nnnorm_eq_zero.mono (Œª x hx, _)
dsimp only at hx
rw pi.zero_apply at hx ‚ä¢
{ rwa [ennreal.coe_eq_zero, nnnorm_eq_zero] at hx, }
rwa [ennreal.coe_eq_zero, nnnorm_eq_zero] at hx
refine measurable.coe_nnreal_ennreal (measurable.nnnorm _)
rw Lp_meas_coe
{ rw lintegral_eq_zero_iff at h_nnnorm_eq_zero, refine h_nnnorm_eq_zero.mono (Œª x hx, _), dsimp only at hx, rw pi.zero_apply at hx ‚ä¢, { rwa [ennreal.coe_eq_zero, nnnorm_eq_zero] at hx, }, { refine measurable.coe_nnreal_ennreal (measurable.nnnorm _), rw Lp_meas_coe, exact Lp.measurable _, }, }
exact Lp.measurable _
refine le_antisymm _ (zero_le _)
refine (lintegral_nnnorm_condexp_L2_le hs hŒºs f).trans (le_of_eq _)
rw lintegral_eq_zero_iff
refine hf.mono (Œª x hx, _)
dsimp only
rw hx
{ refine hf.mono (Œª x hx, _), dsimp only, rw hx, simp, }
simp
exact (Lp.measurable _).nnnorm.coe_nnreal_ennreal
rw [inner_def, inner_def, ‚Üê smul_eq_mul, ‚Üê integral_smul]
refine integral_congr_ae ((coe_fn_smul r f).mono (Œª x hx, _))
rw [smul_eq_mul, ‚Üê inner_smul_left]
congr
rwa pi.smul_apply at hx
lift c to ‚Ñù‚â•0 using hc
rw [ennreal.of_real_coe_nnreal, ‚Üê c.nnnorm_eq, ‚Üê snorm_norm g, ‚Üê snorm_const_smul (c : ‚Ñù)]
swap
apply_instance
refine snorm_mono_ae _
simpa
rw [norm_def, norm_def, ennreal.to_real_le_to_real (snorm_ne_top _) (snorm_ne_top _)]
exact snorm_mono_ae h
apply_instance
rw [snorm', ‚Üêennreal.rpow_mul, one_div, inv_mul_cancel, ennreal.rpow_one]
exact (ne_of_lt hq0_lt).symm
rw [snorm', div_zero, ennreal.rpow_zero]
cases le_or_lt 0 q with hq0 hq_neg
{ exact snorm'_zero (lt_of_le_of_ne hq0 hq0_ne.symm), }
exact snorm'_zero (lt_of_le_of_ne hq0 hq0_ne.symm)
simp [snorm', ennreal.rpow_eq_zero_iff, hŒº, hq_neg]
by_cases hp_top : p = ‚àû
simp_rw [hp_top] at *
have h_cau_ae : ‚àÄ·µê x ‚àÇŒº, ‚àÄ N n m, N ‚â§ n ‚Üí N ‚â§ m ‚Üí (nnnorm ((f n - f m) x) : ‚Ñù‚â•0‚àû) < B N
simp_rw [ae_all_iff, ae_imp_iff]
{ simp_rw [ae_all_iff, ae_imp_iff], exact Œª N n m hnN hmN, ae_lt_of_ess_sup_lt (h_cau N n m hnN hmN), }
exact Œª N n m hnN hmN, ae_lt_of_ess_sup_lt (h_cau N n m hnN hmN)
simp_rw [snorm_exponent_top, snorm_ess_sup] at h_cau
refine h_cau_ae.mono (Œª x hx, cauchy_seq_tendsto_of_complete _)
refine cauchy_seq_of_le_tendsto_0 (Œª n, (B n).to_real) _ _
intros n m N hnN hmN
specialize hx N n m hnN hmN
rw [dist_eq_norm, ‚Üêennreal.to_real_of_real (norm_nonneg _), ennreal.to_real_le_to_real ennreal.of_real_ne_top (ennreal.ne_top_of_tsum_ne_top hB N)]
rw ‚Üêof_real_norm_eq_coe_nnnorm at hx
{ intros n m N hnN hmN, specialize hx N n m hnN hmN, rw [dist_eq_norm, ‚Üêennreal.to_real_of_real (norm_nonneg _), ennreal.to_real_le_to_real ennreal.of_real_ne_top (ennreal.ne_top_of_tsum_ne_top hB N)], rw ‚Üêof_real_norm_eq_coe_nnnorm at hx, exact hx.le, }
exact hx.le
rw ‚Üê ennreal.zero_to_real
exact tendsto.comp (ennreal.tendsto_to_real ennreal.zero_ne_top) (ennreal.tendsto_at_top_zero_of_tsum_ne_top hB)
{ simp_rw [hp_top] at *, have h_cau_ae : ‚àÄ·µê x ‚àÇŒº, ‚àÄ N n m, N ‚â§ n ‚Üí N ‚â§ m ‚Üí (nnnorm ((f n - f m) x) : ‚Ñù‚â•0‚àû) < B N, { simp_rw [ae_all_iff, ae_imp_iff], exact Œª N n m hnN hmN, ae_lt_of_ess_sup_lt (h_cau N n m hnN hmN), }, simp_rw [snorm_exponent_top, snorm_ess_sup] at h_cau, refine h_cau_ae.mono (Œª x hx, cauchy_seq_tendsto_of_complete _), refine cauchy_seq_of_le_tendsto_0 (Œª n, (B n).to_real) _ _, { intros n m N hnN hmN, specialize hx N n m hnN hmN, rw [dist_eq_norm, ‚Üêennreal.to_real_of_real (norm_nonneg _), ennreal.to_real_le_to_real ennreal.of_real_ne_top (ennreal.ne_top_of_tsum_ne_top hB N)], rw ‚Üêof_real_norm_eq_coe_nnnorm at hx, exact hx.le, }, { rw ‚Üê ennreal.zero_to_real, exact tendsto.comp (ennreal.tendsto_to_real ennreal.zero_ne_top) (ennreal.tendsto_at_top_zero_of_tsum_ne_top hB), }, }
have hp1 : 1 ‚â§ p.to_real
rw [‚Üê ennreal.of_real_le_iff_le_to_real hp_top, ennreal.of_real_one]
{ rw [‚Üê ennreal.of_real_le_iff_le_to_real hp_top, ennreal.of_real_one], exact hp, }
exact hp
have h_cau' : ‚àÄ (N n m : ‚Ñï), N ‚â§ n ‚Üí N ‚â§ m ‚Üí snorm' (f n - f m) (p.to_real) Œº < B N
intros N n m hn hm
specialize h_cau N n m hn hm
rwa snorm_eq_snorm' (ennreal.zero_lt_one.trans_le hp).ne.symm hp_top at h_cau
{ intros N n m hn hm, specialize h_cau N n m hn hm, rwa snorm_eq_snorm' (ennreal.zero_lt_one.trans_le hp).ne.symm hp_top at h_cau, }
exact ae_tendsto_of_cauchy_snorm' hf hp1 hB h_cau'
refine Lp.mem_Lp_of_ae_bound (‚à•f‚à•) _
filter_upwards [f.to_continuous_map.coe_fn_to_ae_eq_fun Œº]
intros x hx
convert f.norm_coe_le_norm x
simp [eventually_eq, snorm_ess_sup]
exact limsup_trim hm hf
simp_rw ess_sup
by_cases h0 : p = 0
{ simp [h0], }
simp [h0]
by_cases h_top : p = ‚àû
simpa only [h_top, snorm_exponent_top] using snorm_ess_sup_trim hm hf
{ simpa only [h_top, snorm_exponent_top] using snorm_ess_sup_trim hm hf, }
simpa only [snorm_eq_snorm' h0 h_top] using snorm'_trim hm hf
refine ‚ü®(approx_on f fmeas s y‚ÇÄ h‚ÇÄ n).ae_measurable, _‚ü©
suffices : snorm (Œª x, approx_on f fmeas s y‚ÇÄ h‚ÇÄ n x - y‚ÇÄ) p Œº < ‚ä§
have : mem_‚Ñíp (Œª x, approx_on f fmeas s y‚ÇÄ h‚ÇÄ n x - y‚ÇÄ) p Œº := ‚ü®(approx_on f fmeas s y‚ÇÄ h‚ÇÄ n - const Œ≤ y‚ÇÄ).ae_measurable, this‚ü©
convert snorm_add_lt_top this hi‚ÇÄ
ext x
{ have : mem_‚Ñíp (Œª x, approx_on f fmeas s y‚ÇÄ h‚ÇÄ n x - y‚ÇÄ) p Œº := ‚ü®(approx_on f fmeas s y‚ÇÄ h‚ÇÄ n - const Œ≤ y‚ÇÄ).ae_measurable, this‚ü©, convert snorm_add_lt_top this hi‚ÇÄ, ext x, simp }
simp
have hf' : mem_‚Ñíp (Œª x, ‚à•f x - y‚ÇÄ‚à•) p Œº
have h_meas : measurable (Œª x, ‚à•f x - y‚ÇÄ‚à•)
simp only [‚Üê dist_eq_norm]
{ simp only [‚Üê dist_eq_norm], exact (continuous_id.dist continuous_const).measurable.comp fmeas }
exact (continuous_id.dist continuous_const).measurable.comp fmeas
refine ‚ü®h_meas.ae_measurable, _‚ü©
rw snorm_norm
convert snorm_add_lt_top hf hi‚ÇÄ.neg
ext x
{ have h_meas : measurable (Œª x, ‚à•f x - y‚ÇÄ‚à•), { simp only [‚Üê dist_eq_norm], exact (continuous_id.dist continuous_const).measurable.comp fmeas }, refine ‚ü®h_meas.ae_measurable, _‚ü©, rw snorm_norm, convert snorm_add_lt_top hf hi‚ÇÄ.neg, ext x, simp [sub_eq_add_neg] }
simp [sub_eq_add_neg]
have : ‚àÄ·µê x ‚àÇŒº, ‚à•approx_on f fmeas s y‚ÇÄ h‚ÇÄ n x - y‚ÇÄ‚à• ‚â§ ‚à•(‚à•f x - y‚ÇÄ‚à• + ‚à•f x - y‚ÇÄ‚à•)‚à•
refine eventually_of_forall _
intros x
convert norm_approx_on_y‚ÇÄ_le fmeas h‚ÇÄ x n
rw [real.norm_eq_abs, abs_of_nonneg]
{ refine eventually_of_forall _, intros x, convert norm_approx_on_y‚ÇÄ_le fmeas h‚ÇÄ x n, rw [real.norm_eq_abs, abs_of_nonneg], exact add_nonneg (norm_nonneg _) (norm_nonneg _) }
exact add_nonneg (norm_nonneg _) (norm_nonneg _)
calc snorm (Œª x, approx_on f fmeas s y‚ÇÄ h‚ÇÄ n x - y‚ÇÄ) p Œº ‚â§ snorm (Œª x, ‚à•f x - y‚ÇÄ‚à• + ‚à•f x - y‚ÇÄ‚à•) p Œº : snorm_mono_ae this ... < ‚ä§ : snorm_add_lt_top hf' hf'
let fs := simple_func.approx_on f hf_meas set.univ 0 (set.mem_univ _)
refine ‚ü®fs, _, _‚ü©
from simple_func.mem_‚Ñíp_approx_on_univ hf_meas hf
have h_fs_Lp : ‚àÄ n, mem_‚Ñíp (fs n) p Œº
exact Œª n, (fs n).measure_support_lt_top_of_mem_‚Ñíp (h_fs_Lp n) hp_ne_zero hp_ne_top
{ have h_fs_Lp : ‚àÄ n, mem_‚Ñíp (fs n) p Œº, from simple_func.mem_‚Ñíp_approx_on_univ hf_meas hf, exact Œª n, (fs n).measure_support_lt_top_of_mem_‚Ñíp (h_fs_Lp n) hp_ne_zero hp_ne_top, }
exact Œª x, simple_func.tendsto_approx_on hf_meas (set.mem_univ 0) (by simp)
simp
simpa only [inv_inv'] using h.inv
rw [‚Üê measure_inv_null hŒº hE, ‚Üê hŒº y‚Åª¬π (measurable_inv hE), ‚Üê measure_inv_null hŒº (measurable_mul_const y hE)]
ext x
simp
convert iff.rfl using 3
rw L1.norm_eq_integral_norm
refine integral_congr_ae _
apply hf.coe_fn_to_L1.mono
intros a ha
simp [ha]
simp
rcases eq_or_ne c 0 with rfl|h0
{ simp }
swap
by_cases hfm : ae_measurable f Œº
simpa [h0] using hfm
have : ¬¨ (ae_measurable f (c ‚Ä¢ Œº))
{ have : ¬¨ (ae_measurable f (c ‚Ä¢ Œº)), by simpa [h0] using hfm, simp [integral_non_ae_measurable, hfm, this] }
simp [integral_non_ae_measurable, hfm, this]
rcases eq_or_ne c ‚àû with rfl|hc
rw [ennreal.top_to_real, zero_smul]
by_cases hf : f =·µê[Œº] 0
have : f =·µê[‚àû ‚Ä¢ Œº] 0 := ae_smul_measure hf ‚àû
{ have : f =·µê[‚àû ‚Ä¢ Œº] 0 := ae_smul_measure hf ‚àû, exact integral_eq_zero_of_ae this }
exact integral_eq_zero_of_ae this
apply integral_undef
rw [integrable, has_finite_integral, iff_true_intro (hfm.smul_measure ‚àû), true_and, lintegral_smul_measure, top_mul, if_neg]
{ apply lt_irrefl }
apply lt_irrefl
rw [lintegral_eq_zero_iff' hfm.ennnorm]
refine Œª h, hf (h.mono $ Œª x, _)
{ rw [ennreal.top_to_real, zero_smul], by_cases hf : f =·µê[Œº] 0, { have : f =·µê[‚àû ‚Ä¢ Œº] 0 := ae_smul_measure hf ‚àû, exact integral_eq_zero_of_ae this }, { apply integral_undef, rw [integrable, has_finite_integral, iff_true_intro (hfm.smul_measure ‚àû), true_and, lintegral_smul_measure, top_mul, if_neg], { apply lt_irrefl }, { rw [lintegral_eq_zero_iff' hfm.ennnorm], refine Œª h, hf (h.mono $ Œª x, _), simp } } }
simp
swap
by_cases hfi : integrable f Œº
rw [integral_undef hfi, smul_zero]
refine integral_undef (mt (Œª h, _) hfi)
convert h.smul_measure (ennreal.inv_ne_top.2 h0)
rw [smul_smul, ennreal.inv_mul_cancel h0 hc, one_smul]
{ rw [integral_undef hfi, smul_zero], refine integral_undef (mt (Œª h, _) hfi), convert h.smul_measure (ennreal.inv_ne_top.2 h0), rw [smul_smul, ennreal.inv_mul_cancel h0 hc, one_smul] }
let g := hfm.mk f
calc ‚à´ x, f x ‚àÇ(c ‚Ä¢ Œº) = ‚à´ x, g x ‚àÇ(c ‚Ä¢ Œº) : integral_congr_ae $ ae_smul_measure hfm.ae_eq_mk c ... = c.to_real ‚Ä¢ ‚à´ x, g x ‚àÇŒº : integral_smul_measure_aux h0 hc hfm.measurable_mk $ hfi.congr hfm.ae_eq_mk ... = c.to_real ‚Ä¢ ‚à´ x, f x ‚àÇŒº : by { congr' 1, exact integral_congr_ae (hfm.ae_eq_mk.symm) }
congr' 1
exact integral_congr_ae (hfm.ae_eq_mk.symm)
simp [measure.dirac_apply_of_mem]
simp [integral_congr_ae hf, integral_zero]
by_cases hfi : integrable f Œº
rw integral_eq_lintegral_pos_part_sub_lintegral_neg_part hfi
have h_min : ‚à´‚Åª a, ennreal.of_real (-f a) ‚àÇŒº = 0
rw lintegral_eq_zero_iff'
refine hf.mono _
simp only [pi.zero_apply]
assume a h
{ refine hf.mono _, simp only [pi.zero_apply], assume a h, simp only [h, neg_nonpos, of_real_eq_zero], }
simp only [h, neg_nonpos, of_real_eq_zero]
{ rw lintegral_eq_zero_iff', { refine hf.mono _, simp only [pi.zero_apply], assume a h, simp only [h, neg_nonpos, of_real_eq_zero], }, { exact measurable_of_real.comp_ae_measurable hfm.neg } }
exact measurable_of_real.comp_ae_measurable hfm.neg
{ rw integral_eq_lintegral_pos_part_sub_lintegral_neg_part hfi, have h_min : ‚à´‚Åª a, ennreal.of_real (-f a) ‚àÇŒº = 0, { rw lintegral_eq_zero_iff', { refine hf.mono _, simp only [pi.zero_apply], assume a h, simp only [h, neg_nonpos, of_real_eq_zero], }, { exact measurable_of_real.comp_ae_measurable hfm.neg } }, rw [h_min, zero_to_real, _root_.sub_zero] }
rw [h_min, zero_to_real, _root_.sub_zero]
rw integral_undef hfi
simp_rw [integrable, hfm, has_finite_integral_iff_norm, lt_top_iff_ne_top, ne.def, true_and, not_not] at hfi
have : ‚à´‚Åª (a : Œ±), ennreal.of_real (f a) ‚àÇŒº = ‚à´‚Åª a, (ennreal.of_real ‚à•f a‚à•) ‚àÇŒº
refine lintegral_congr_ae (hf.mono $ assume a h, _)
{ refine lintegral_congr_ae (hf.mono $ assume a h, _), rw [real.norm_eq_abs, abs_of_nonneg h] }
rw [real.norm_eq_abs, abs_of_nonneg h]
refl
rw [this, hfi]
rw [‚Üê indicator_eq_self.2 (@subset_closure _ _ (support f)), integrable_indicator_iff is_closed_closure.measurable_set]
{ exact hf.integrable_on_compact hfc }
exact hf.integrable_on_compact hfc
apply_instance
simpa [mul_comm] using hf.mul_continuous_on_of_subset hg hs ht hst
rw [measure.restrict_apply_univ]
rw show (Œª x, ‚à´ t in Icc a x, f t ‚àÇŒº) = Œª x, ‚à´ t in Ioc a x, f t ‚àÇŒº, by { ext x, exact integral_Icc_eq_integral_Ioc }
ext x
exact integral_Icc_eq_integral_Ioc
exact continuous_on_primitive h_int
simpa only [integral_of_le hab] using set_integral_nonneg_of_ae_restrict H
simp [integral_symm (u t), add_comm]
simpa using measure_integral_sub_integral_sub_linear_is_o_of_tendsto_ae hab hmeas measurable_at_bot hf ((tendsto_bot : tendsto _ ‚ä• (ùìù 0)).mono_left inf_le_left) hu hv (tendsto_const_pure : tendsto _ _ (pure b)) tendsto_const_pure
simpa [mul_comm] using hf.mul_continuous_on hg
simpa only [sub_eq_add_neg] using integral_comp_add_right f (-d)
ext1 a
simp only [infi_apply]
convert (monotone_lintegral Œº).map_infi2_le f
rcases exists_measurable_superset_of_null h with ‚ü®t, hts, ht, ht0‚ü©
have : ‚àÄ·µê x ‚àÇŒº, x ‚àâ t := measure_zero_iff_ae_nmem.1 ht0
refine (supr_le $ assume s, supr_le $ assume hfs, le_supr_of_le (s.restrict t·∂ú) $ le_supr_of_le _ _)
assume a
by_cases a ‚àà t; simp [h, restrict_apply, ht.compl]
by_cases a ‚àà t
simp [h, restrict_apply, ht.compl]
simp [h, restrict_apply, ht.compl]
exact le_trans (hfs a) (by_contradiction $ assume hnfg, h (hts hnfg))
{ assume a, by_cases a ‚àà t; simp [h, restrict_apply, ht.compl], exact le_trans (hfs a) (by_contradiction $ assume hnfg, h (hts hnfg)) }
refine le_of_eq (simple_func.lintegral_congr $ this.mono $ Œª a hnt, _)
by_cases hat : a ‚àà t; simp [hat, ht.compl]
simp [hat, ht.compl]
simp [hat, ht.compl]
by_cases hat : a ‚àà t
exact (hnt hat).elim
rw [lintegral, ennreal.mul_supr]
refine supr_le (Œªs, _)
rw [ennreal.mul_supr]
simp only [supr_le_iff, ge_iff_le]
assume hs
rw ‚Üê simple_func.const_mul_lintegral
refine le_supr_of_le (const Œ± r * s) (le_supr_of_le (Œªx, _) (le_refl _))
exact mul_le_mul_left' (hs x) _
by_cases h : r = 0
{ simp [h] }
simp [h]
apply le_antisymm _ (lintegral_const_mul_le r f)
have rinv : r * r‚Åª¬π = 1 := ennreal.mul_inv_cancel h hr
rw mul_comm
have rinv' : r ‚Åª¬π * r = 1
exact rinv
have := lintegral_const_mul_le (r‚Åª¬π) (Œªx, r * f x)
simp [(mul_assoc _ _ _).symm, rinv'] at this
simpa [(mul_assoc _ _ _).symm, rinv] using mul_le_mul_left' this r
simp [lintegral_const_mul'' _ hg, lintegral_mul_const'' _ hf]
simp [hs, indicator_preimage_of_not_mem _ _ ht, inter_comm]
induction n with n IH
simp only [nat.nat_zero_eq_zero, finset.sum_singleton, finset.range_one]
refl
{ simp only [nat.nat_zero_eq_zero, finset.sum_singleton, finset.range_one], refl }
rw [finset.sum_range_succ, nat.succ_eq_add_one, IH, eapprox_diff, coe_map, function.comp_app, coe_sub, pi.sub_apply, ennreal.coe_to_nnreal, ennreal.add_sub_cancel_of_le (monotone_eapprox f (nat.le_succ _) _)]
apply (lt_of_le_of_lt _ (eapprox_lt_top f (n+1) a)).ne
rw ennreal.sub_le_iff_le_add
exact le_self_add
simpa only [mem_range, exists_prop] using set.exists_range_iff
by_cases hs_empty : s = ‚àÖ
simp only [hs_empty, hT_empty, continuous_linear_map.zero_apply, piecewise_empty, const_zero, set_to_simple_func_zero_apply]
{ simp only [hs_empty, hT_empty, continuous_linear_map.zero_apply, piecewise_empty, const_zero, set_to_simple_func_zero_apply], }
by_cases hs_univ : s = univ
casesI hŒ± : is_empty_or_nonempty Œ±
refine absurd _ hs_empty
unfold set
apply_instance
haveI : subsingleton (set Œ±)
{ refine absurd _ hs_empty, haveI : subsingleton (set Œ±), by { unfold set, apply_instance, }, exact subsingleton.elim s ‚àÖ, }
exact subsingleton.elim s ‚àÖ
{ casesI hŒ± : is_empty_or_nonempty Œ±, { refine absurd _ hs_empty, haveI : subsingleton (set Œ±), by { unfold set, apply_instance, }, exact subsingleton.elim s ‚àÖ, }, simp [hs_univ, set_to_simple_func], }
simp [hs_univ, set_to_simple_func]
simp_rw set_to_simple_func
rw [‚Üê ne.def, set.ne_empty_iff_nonempty] at hs_empty
rw range_indicator hs hs_empty hs_univ
by_cases hx0 : x = 0
simp
{ simp_rw hx0, simp, }
simp_rw hx0
rw sum_insert
rw finset.mem_singleton
exact hx0
swap
{ rw finset.mem_singleton, exact hx0, }
rw [sum_singleton, (T _).map_zero, add_zero]
congr
simp only [coe_piecewise, piecewise_eq_indicator, coe_const, pi.const_zero, piecewise_eq_indicator]
rw [indicator_preimage, preimage_const_of_mem]
exact set.mem_singleton x
{ exact set.mem_singleton x, }
swap
rw [‚Üê pi.const_zero, preimage_const_of_not_mem]
rw set.mem_singleton_iff
exact ne.symm hx0
swap
{ rw set.mem_singleton_iff, exact ne.symm hx0, }
simp
exact measurable_of_empty f
haveI := function.is_empty f
apply div_pos; norm_cast
norm_cast
norm_cast
apply index_pos ‚ü®K, h1K, h2K‚ü© hU
exact index_pos K‚ÇÄ hU
apply div_pos
let eval : (compacts G ‚Üí ‚Ñù) ‚Üí ‚Ñù := Œª f, f (K.map _ $ continuous_mul_left g) - f K
have : continuous eval := (continuous_apply (K.map _ _)).sub (continuous_apply K)
show chaar K‚ÇÄ ‚àà eval ‚Åª¬π' {(0 : ‚Ñù)}
rw [‚Üê sub_eq_zero]
apply mem_of_subset_of_mem _ (chaar_mem_cl_prehaar K‚ÇÄ ‚ü®set.univ, is_open_univ, mem_univ _‚ü©)
rw is_closed.closure_subset_iff
unfold cl_prehaar
rintro _ ‚ü®U, ‚ü®h1U, h2U, h3U‚ü©, rfl‚ü©
simp only [mem_singleton_iff, mem_preimage, eval, sub_eq_zero]
rw h2U.interior_eq
exact ‚ü®1, h3U‚ü©
apply is_left_invariant_prehaar
{ rintro _ ‚ü®U, ‚ü®h1U, h2U, h3U‚ü©, rfl‚ü©, simp only [mem_singleton_iff, mem_preimage, eval, sub_eq_zero], apply is_left_invariant_prehaar, rw h2U.interior_eq, exact ‚ü®1, h3U‚ü© }
exact is_closed_singleton
apply continuous_iff_is_closed.mp this
rw [‚Üê hf.hausdorff_measure_image hd, image_preimage_eq_inter_range]
simp
simp [measure.map_apply (measurable_const_add a) measurable_set_Ioo, sub_sub_sub_cancel_right]
refine (measure.pi_eq (Œª s hs, _)).symm
have A : has_add.add a ‚Åª¬π' (set.pi univ (Œª (i : Œπ), s i)) = set.pi univ (Œª (i : Œπ), ((+) (a i)) ‚Åª¬π' (s i))
ext
simp
rw [measure.map_apply (measurable_const_add a) (measurable_set.univ_pi_fintype hs), A, volume_pi_pi]
{ simp only [volume_preimage_add_left] }
simp only [volume_preimage_add_left]
exact Œª i, measurable_const_add (a i) (hs i)
rw [measure_zero_iff_ae_nmem, measure_zero_iff_ae_nmem]
exact Œª hs, h hs
rw [smul_apply, ae_iff.1 h, mul_zero]
ext t
simp only [mem_inf_principal, mem_ae_iff, restrict_apply_eq_zero' hs, compl_set_of, not_imp, and_comm (_ ‚àà s)]
refl
simp only [ae_restrict_eq hs, exists_prop, mem_principal, mem_inf_iff]
simp only [ae_restrict_eq hs, exists_prop, mem_principal, mem_inf_iff]; exact ‚ü®_, univ_mem, s, subset.rfl, (univ_inter s).symm‚ü©
exact ‚ü®_, univ_mem, s, subset.rfl, (univ_inter s).symm‚ü©
rw [measure_compl ht (measure_ne_top Œº _), measure_compl hs (measure_ne_top Œº _), ennreal.sub_le_iff_le_add]
calc Œº univ = Œº univ - Œº s + Œº s : (ennreal.sub_add_cancel_of_le $ measure_mono s.subset_univ).symm ... ‚â§ Œº univ - Œº s + (Œº t + Œµ) : add_le_add_left h _ ... = _ : by rw [add_right_comm, add_assoc]
rw [add_right_comm, add_assoc]
haveI : is_finite_measure ŒΩ := begin constructor, rw ‚Üê h_univ, apply is_finite_measure.measure_univ_lt_top, end
constructor
rw ‚Üê h_univ
apply is_finite_measure.measure_univ_lt_top
simp
refine induction_on_inter hA hC (by simp) hŒºŒΩ _ _ hs
intros t h1t h2t
from h _ h1t
have h1t_ : @measurable_set Œ± m‚ÇÄ t
rw [@measure_compl Œ± m‚ÇÄ Œº t h1t_ (@measure_ne_top Œ± m‚ÇÄ Œº _ t), @measure_compl Œ± m‚ÇÄ ŒΩ t h1t_ (@measure_ne_top Œ± m‚ÇÄ ŒΩ _ t), h_univ, h2t]
{ intros t h1t h2t, have h1t_ : @measurable_set Œ± m‚ÇÄ t, from h _ h1t, rw [@measure_compl Œ± m‚ÇÄ Œº t h1t_ (@measure_ne_top Œ± m‚ÇÄ Œº _ t), @measure_compl Œ± m‚ÇÄ ŒΩ t h1t_ (@measure_ne_top Œ± m‚ÇÄ ŒΩ _ t), h_univ, h2t], }
intros f h1f h2f h3f
from (Œª i, h _ (h2f i))
have h2f_ : ‚àÄ (i : ‚Ñï), @measurable_set Œ± m‚ÇÄ (f i)
from @measurable_set.Union Œ± ‚Ñï m‚ÇÄ _ f h2f_
have h_Union : @measurable_set Œ± m‚ÇÄ (‚ãÉ (i : ‚Ñï), f i)
simp [measure_Union, h_Union, h1f, h3f, h2f_]
refine ‚ü®_, Œª h, h.filter_mono inf_le_left‚ü©
rintros ‚ü®s, ‚ü®t, ht, u, hu, rfl‚ü©, hŒº‚ü©
from ‚ü®t, ht, this.trans_lt hŒº‚ü©
suffices : Œº t ‚â§ Œº (t ‚à© u)
exact measure_mono_ae (mem_of_superset hu (Œª x hu ht, ‚ü®ht, hu‚ü©))
rwa measure_to_measurable
rw [Inf_apply hs, ‚Üê to_outer_measure_apply]
rw [Inf_apply hs, ‚Üê to_outer_measure_apply]; exact this s
exact this s
rw [‚Üê trimmed, outer_measure.trim_congr h, trimmed]
rw [measure_eq_induced_outer_measure, induced_outer_measure_eq_extend _ _ hs]
exact Œº.m_Union
simp [eventually_le_antisymm_iff, ae_le_set, union_diff_right, diff_eq_empty.2 (set.subset_union_right _ _)]
rw [h‚ÇÅ t, h‚ÇÇ (t ‚à© s‚ÇÅ), h‚ÇÇ (t \ s‚ÇÅ), h‚ÇÅ (t ‚à© (s‚ÇÅ ‚à™ s‚ÇÇ)), inter_diff_assoc _ _ s‚ÇÅ, set.inter_assoc _ _ s‚ÇÅ, inter_eq_self_of_subset_right (set.subset_union_left _ _), union_diff_left, h‚ÇÇ (t ‚à© s‚ÇÅ)]
simp [diff_eq, add_assoc]
intros U hU r hr
rcases hU.exists_Union_is_closed with ‚ü®F, F_closed, -, rfl, F_mono‚ü©
rw measure_Union_eq_supr (Œª n, (F_closed n).measurable_set) F_mono.directed_le at hr
rcases lt_supr_iff.1 hr with ‚ü®n, hn‚ü©
exact ‚ü®F n, subset_Union _ _, F_closed n, hn‚ü©
simp_rw [ne.def, ‚Üê measure_univ_eq_zero, is_open_univ.measure_eq_supr_is_compact, ennreal.supr_eq_zero, not_forall, exists_prop, subset_univ, true_and]
apply outer_measure.of_function_caratheodory (Œª t, _)
refine le_infi (Œª a, le_infi (Œª b, le_infi (Œª h, _)))
refine le_trans (add_le_add (f.length_mono $ inter_subset_inter_left _ h) (f.length_mono $ diff_subset_diff_left h)) _
cases le_total a c with hac hac; cases le_total b c with hbc hbc
cases le_total b c with hbc hbc
cases le_total b c with hbc hbc
cases le_total a c with hac hac
simp only [Ioc_inter_Ioi, f.length_Ioc, hac, sup_eq_max, hbc, le_refl, Ioc_eq_empty, max_eq_right, min_eq_left, Ioc_diff_Ioi, f.length_empty, zero_add, not_lt]
{ simp only [Ioc_inter_Ioi, f.length_Ioc, hac, sup_eq_max, hbc, le_refl, Ioc_eq_empty, max_eq_right, min_eq_left, Ioc_diff_Ioi, f.length_empty, zero_add, not_lt] }
simp only [hac, hbc, Ioc_inter_Ioi, Ioc_diff_Ioi, f.length_Ioc, min_eq_right, sup_eq_max, ‚Üêennreal.of_real_add, f.mono hac, f.mono hbc, sub_nonneg, sub_add_sub_cancel, le_refl, max_eq_right]
{ simp only [hac, hbc, Ioc_inter_Ioi, Ioc_diff_Ioi, f.length_Ioc, min_eq_right, sup_eq_max, ‚Üêennreal.of_real_add, f.mono hac, f.mono hbc, sub_nonneg, sub_add_sub_cancel, le_refl, max_eq_right] }
simp only [hbc, le_refl, Ioc_eq_empty, Ioc_inter_Ioi, min_eq_left, Ioc_diff_Ioi, f.length_empty, zero_add, or_true, le_sup_iff, f.length_Ioc, not_lt]
{ simp only [hbc, le_refl, Ioc_eq_empty, Ioc_inter_Ioi, min_eq_left, Ioc_diff_Ioi, f.length_empty, zero_add, or_true, le_sup_iff, f.length_Ioc, not_lt] }
simp only [hac, hbc, Ioc_inter_Ioi, Ioc_diff_Ioi, f.length_Ioc, min_eq_right, sup_eq_max, le_refl, Ioc_eq_empty, add_zero, max_eq_left, f.length_empty, not_lt]
rcases eq_or_lt_of_le h with rfl|hxy
{ exact le_rfl }
exact le_rfl
exact (f.left_lim_le le_rfl).trans (f.le_left_lim hxy)
intros s hs
rw [neg_apply, neg_eq_zero] at hs
exact h hs
simp
convert has_sum_integral_Union hs‚ÇÅ hs‚ÇÇ hf.integrable_on
rw if_pos (hs‚ÇÅ n)
{ ext n, rw if_pos (hs‚ÇÅ n) }
ext n
rw if_pos (measurable_set.Union hs‚ÇÅ)
induction h_t with s h_s s t' h_gen_s h_gen_t' h_nonempty h_s h_t'
rcases h_s with ‚ü®t', ‚ü®‚ü®b, rfl‚ü©, h_s_in_t'‚ü©‚ü©
refine ‚ü®{b}, (Œª _, s), _‚ü©
{ rcases h_s with ‚ü®t', ‚ü®‚ü®b, rfl‚ü©, h_s_in_t'‚ü©‚ü©, refine ‚ü®{b}, (Œª _, s), _‚ü©, simpa using h_s_in_t', }
simpa using h_s_in_t'
rcases h_t' with ‚ü®T_t', ‚ü®f_t', ‚ü®rfl, h_t'‚ü©‚ü©‚ü©
rcases h_s with ‚ü®T_s, ‚ü®f_s, ‚ü®rfl, h_s‚ü© ‚ü© ‚ü©
use [(T_s ‚à™ T_t'), (Œª (b:Œ≤), if (b ‚àà T_s) then (if (b ‚àà T_t') then (f_s b ‚à© (f_t' b)) else (f_s b)) else (if (b ‚àà T_t') then (f_t' b) else (‚àÖ : set Œ±)))]
split
ext a
simp_rw [set.mem_inter_iff, set.mem_Inter, finset.mem_union, or_imp_distrib]
rw ‚Üê forall_and_distrib
split; intros h1 b; by_cases hbs : b ‚àà T_s; by_cases hbt : b ‚àà T_t'; specialize h1 b; simp only [hbs, hbt, if_true, if_false, true_implies_iff, and_self, false_implies_iff, and_true, true_and] at h1 ‚ä¢
split; intros h1 b; by_cases hbs : b ‚àà T_s; by_cases hbt : b ‚àà T_t'; specialize h1 b
split; intros h1 b; by_cases hbs : b ‚àà T_s; by_cases hbt : b ‚àà T_t'
split; intros h1 b; by_cases hbs : b ‚àà T_s
split; intros h1 b
intros h1 b
intros h1 b
by_cases hbs : b ‚àà T_s
by_cases hbs : b ‚àà T_s
by_cases hbt : b ‚àà T_t'
by_cases hbt : b ‚àà T_t'
by_cases hbt : b ‚àà T_t'
by_cases hbt : b ‚àà T_t'
specialize h1 b
specialize h1 b
specialize h1 b
specialize h1 b
specialize h1 b
specialize h1 b
specialize h1 b
specialize h1 b
split
simp only [hbs, hbt, if_true, if_false, true_implies_iff, and_self, false_implies_iff, and_true, true_and] at h1 ‚ä¢
simp only [hbs, hbt, if_true, if_false, true_implies_iff, and_self, false_implies_iff, and_true, true_and] at h1 ‚ä¢
simp only [hbs, hbt, if_true, if_false, true_implies_iff, and_self, false_implies_iff, and_true, true_and] at h1 ‚ä¢
simp only [hbs, hbt, if_true, if_false, true_implies_iff, and_self, false_implies_iff, and_true, true_and] at h1 ‚ä¢
simp only [hbs, hbt, if_true, if_false, true_implies_iff, and_self, false_implies_iff, and_true, true_and] at h1 ‚ä¢
simp only [hbs, hbt, if_true, if_false, true_implies_iff, and_self, false_implies_iff, and_true, true_and] at h1 ‚ä¢
simp only [hbs, hbt, if_true, if_false, true_implies_iff, and_self, false_implies_iff, and_true, true_and] at h1 ‚ä¢
simp only [hbs, hbt, if_true, if_false, true_implies_iff, and_self, false_implies_iff, and_true, true_and] at h1 ‚ä¢
exact h1
exact h1
exact h1
exact h1
{ ext a, simp_rw [set.mem_inter_iff, set.mem_Inter, finset.mem_union, or_imp_distrib], rw ‚Üê forall_and_distrib, split; intros h1 b; by_cases hbs : b ‚àà T_s; by_cases hbt : b ‚àà T_t'; specialize h1 b; simp only [hbs, hbt, if_true, if_false, true_implies_iff, and_self, false_implies_iff, and_true, true_and] at h1 ‚ä¢, all_goals { exact h1, }, }
all_goals { exact h1, }
intros b h_b
split_ifs with hbs hbt hbt
refine h_pi b (f_s b) (f_t' b) (h_s b hbs) (h_t' b hbt) (set.nonempty.mono _ h_nonempty)
exact set.inter_subset_inter (set.bInter_subset_of_mem hbs) (set.bInter_subset_of_mem hbt)
{ refine h_pi b (f_s b) (f_t' b) (h_s b hbs) (h_t' b hbt) (set.nonempty.mono _ h_nonempty), exact set.inter_subset_inter (set.bInter_subset_of_mem hbs) (set.bInter_subset_of_mem hbt), }
{ exact h_s b hbs, }
exact h_s b hbs
{ exact h_t' b hbt, }
exact h_t' b hbt
rw finset.mem_union at h_b
apply false.elim (h_b.elim hbs hbt)
rw [admissible]
rintro (‚ü®p', q', H‚ü©|‚ü®n, H‚ü©|H|H|H)
rw [‚Üê H, A', sum_inv_pqr, add_assoc]
simp only [lt_add_iff_pos_right, pnat.one_coe, inv_one, nat.cast_one, coe_coe]
apply add_pos; simp only [pnat.pos, nat.cast_pos, inv_pos]
simp only [pnat.pos, nat.cast_pos, inv_pos]
simp only [pnat.pos, nat.cast_pos, inv_pos]
apply add_pos
{ rw [‚Üê H, A', sum_inv_pqr, add_assoc], simp only [lt_add_iff_pos_right, pnat.one_coe, inv_one, nat.cast_one, coe_coe], apply add_pos; simp only [pnat.pos, nat.cast_pos, inv_pos] }
rw [‚Üê H, D', sum_inv_pqr]
simp only [lt_add_iff_pos_right, pnat.one_coe, inv_one, nat.cast_one, coe_coe, pnat.coe_bit0, nat.cast_bit0]
{ rw [‚Üê H, D', sum_inv_pqr], simp only [lt_add_iff_pos_right, pnat.one_coe, inv_one, nat.cast_one, coe_coe, pnat.coe_bit0, nat.cast_bit0], norm_num }
norm_num
rw [‚Üê H, E', sum_inv_pqr]
rw [‚Üê H, E', sum_inv_pqr]
rw [‚Üê H, E', sum_inv_pqr]
all_goals { rw [‚Üê H, E', sum_inv_pqr], norm_num }
norm_num
norm_num
norm_num
rw [ppow, dif_pos rfl]
rw [‚Üê zeta_mul_pow_eq_sigma]
apply ((is_multiplicative_zeta).mul is_multiplicative_pow)
rw [mul_comm, coe_moebius_mul_coe_zeta]
let B := mk (Œª n, bernoulli' n / n!)
suffices : (B - eval_neg_hom B) * (exp ‚Ñö - 1) = X * (exp ‚Ñö - 1)
cases mul_eq_mul_right_iff.mp this; simp only [power_series.ext_iff, eval_neg_hom, coeff_X] at h
cases mul_eq_mul_right_iff.mp this
simp only [power_series.ext_iff, eval_neg_hom, coeff_X] at h
simp only [power_series.ext_iff, eval_neg_hom, coeff_X] at h
apply eq_zero_of_neg_eq
specialize h n
split_ifs at h; simp [neg_one_pow_of_odd h_odd, factorial_ne_zero, *] at *
split_ifs at h
{ apply eq_zero_of_neg_eq, specialize h n, split_ifs at h; simp [neg_one_pow_of_odd h_odd, factorial_ne_zero, *] at * }
simp [neg_one_pow_of_odd h_odd, factorial_ne_zero, *] at *
simp [neg_one_pow_of_odd h_odd, factorial_ne_zero, *] at *
{ cases mul_eq_mul_right_iff.mp this; simp only [power_series.ext_iff, eval_neg_hom, coeff_X] at h, { apply eq_zero_of_neg_eq, specialize h n, split_ifs at h; simp [neg_one_pow_of_odd h_odd, factorial_ne_zero, *] at * }, { simpa using h 1 } }
simpa using h 1
have h : B * (exp ‚Ñö - 1) = X * exp ‚Ñö
simpa [bernoulli'_power_series] using bernoulli'_power_series_mul_exp_sub_one ‚Ñö
{ simpa [bernoulli'_power_series] using bernoulli'_power_series_mul_exp_sub_one ‚Ñö }
rw [sub_mul, h, mul_sub X, sub_right_inj, ‚Üê neg_sub, ‚Üê neg_mul_eq_mul_neg, neg_eq_iff_neg_eq]
suffices : eval_neg_hom (B * (exp ‚Ñö - 1)) * exp ‚Ñö = eval_neg_hom (X * exp ‚Ñö) * exp ‚Ñö
simpa [mul_assoc, sub_mul, mul_comm (eval_neg_hom (exp ‚Ñö)), exp_mul_exp_neg_eq_one, eq_comm]
{ simpa [mul_assoc, sub_mul, mul_comm (eval_neg_hom (exp ‚Ñö)), exp_mul_exp_neg_eq_one, eq_comm] }
congr'
ext n
simp
{ simp }
cases n
simp only [bernoulli_power_series, coeff_mul, coeff_X, sum_antidiagonal_succ', one_div, coeff_mk, coeff_one, coeff_exp, linear_map.map_sub, factorial, if_pos, cast_succ, cast_one, cast_mul, sub_zero, ring_hom.map_one, add_eq_zero_iff, if_false, inv_one, zero_add, one_ne_zero, mul_zero, and_false, sub_self, ‚Üê ring_hom.map_mul, ‚Üê ring_hom.map_sum]
suffices : ‚àë x in antidiagonal n, bernoulli x.1 / x.1! * ((x.2 + 1) * x.2!)‚Åª¬π = if n.succ = 1 then 1 else 0
split_ifs
split_ifs; simp [h, this]
simp [h, this]
simp [h, this]
{ split_ifs; simp [h, this] }
simp
{ simp }
cases n
have hfact : ‚àÄ m, (m! : ‚Ñö) ‚â† 0 := Œª m, by exact_mod_cast factorial_ne_zero m
exact_mod_cast factorial_ne_zero m
have hite1 : ite (n.succ.succ = 1) 1 0 = (0 / n.succ! : ‚Ñö) := by simp
simp
have hite2 : ite (n.succ = 0) 1 0 = (0 : ‚Ñö) := by simp [succ_ne_zero]
simp [succ_ne_zero]
rw [hite1, eq_div_iff (hfact n.succ), ‚Üê hite2, ‚Üê bernoulli_spec', sum_mul]
apply sum_congr rfl
rintro ‚ü®i, j‚ü© h
rw mem_antidiagonal at h
exact_mod_cast succ_ne_zero j
have hj : (j.succ : ‚Ñö) ‚â† 0 := by exact_mod_cast succ_ne_zero j
field_simp [‚Üê h, mul_ne_zero hj (hfact j), hfact i, mul_comm _ (bernoulli i), mul_assoc]
rw_mod_cast [mul_comm (j + 1), mul_div_assoc, ‚Üê mul_assoc]
rw [cast_mul, cast_mul, mul_div_mul_right _ _ hj, add_choose, cast_dvd_char_zero]
apply factorial_mul_factorial_dvd_factorial_add
have hbŒµ : 0 < card_pow_degree b ‚Ä¢ Œµ
rw [algebra.smul_def, ring_hom.eq_int_cast]
exact mul_pos (int.cast_pos.mpr (absolute_value.pos _ hb)) hŒµ
{ rw [algebra.smul_def, ring_hom.eq_int_cast], exact mul_pos (int.cast_pos.mpr (absolute_value.pos _ hb)) hŒµ }
induction n with n ih
{ refine ‚ü®fin_zero_elim, fin_zero_elim‚ü© }
refine ‚ü®fin_zero_elim, fin_zero_elim‚ü©
have anti_archim' : ‚àÄ {i j k} {Œµ : ‚Ñù}, (card_pow_degree (A i % b - A j % b) : ‚Ñù) < Œµ ‚Üí (card_pow_degree (A j % b - A k % b) : ‚Ñù) < Œµ ‚Üí (card_pow_degree (A i % b - A k % b) : ‚Ñù) < Œµ
intros i j k Œµ
rw [‚Üê lt_ceil, ‚Üê lt_ceil, ‚Üê lt_ceil]
{ intros i j k Œµ, rw [‚Üê lt_ceil, ‚Üê lt_ceil, ‚Üê lt_ceil], exact card_pow_degree_anti_archimedean }
exact card_pow_degree_anti_archimedean
obtain ‚ü®t', ht'‚ü© := ih (fin.tail A)
suffices : ‚àÉ j, ‚àÄ i, t' i = j ‚Üî (card_pow_degree (A 0 % b - A i.succ % b) : ‚Ñù) < card_pow_degree b ‚Ä¢ Œµ
obtain ‚ü®j, hj‚ü© := this
refine ‚ü®fin.cons j t', Œª i‚ÇÄ i‚ÇÅ, _‚ü©
refine fin.cases _ (Œª i‚ÇÄ, _) i‚ÇÄ; refine fin.cases _ (Œª i‚ÇÅ, _) i‚ÇÅ
refine fin.cases _ (Œª i‚ÇÅ, _) i‚ÇÅ
refine fin.cases _ (Œª i‚ÇÅ, _) i‚ÇÅ
refine fin.cases _ (Œª i‚ÇÄ, _) i‚ÇÄ
{ simpa using hbŒµ }
simpa using hbŒµ
rw [fin.cons_succ, fin.cons_zero, eq_comm, absolute_value.map_sub]
{ rw [fin.cons_succ, fin.cons_zero, eq_comm, absolute_value.map_sub], exact hj i‚ÇÅ }
exact hj i‚ÇÅ
rw [fin.cons_succ, fin.cons_zero]
{ rw [fin.cons_succ, fin.cons_zero], exact hj i‚ÇÄ }
exact hj i‚ÇÄ
rw [fin.cons_succ, fin.cons_succ]
{ obtain ‚ü®j, hj‚ü© := this, refine ‚ü®fin.cons j t', Œª i‚ÇÄ i‚ÇÅ, _‚ü©, refine fin.cases _ (Œª i‚ÇÄ, _) i‚ÇÄ; refine fin.cases _ (Œª i‚ÇÅ, _) i‚ÇÅ, { simpa using hbŒµ }, { rw [fin.cons_succ, fin.cons_zero, eq_comm, absolute_value.map_sub], exact hj i‚ÇÅ }, { rw [fin.cons_succ, fin.cons_zero], exact hj i‚ÇÄ }, { rw [fin.cons_succ, fin.cons_succ], exact ht' i‚ÇÄ i‚ÇÅ } }
exact ht' i‚ÇÄ i‚ÇÅ
obtain ‚ü®j, hj‚ü© : ‚àÉ j, ‚àÄ (i : fin n), t' i = j ‚Üí (card_pow_degree (A 0 % b - A i.succ % b) : ‚Ñù) < card_pow_degree b ‚Ä¢ Œµ
push_neg at this
by_contra this
obtain ‚ü®j‚ÇÄ, j‚ÇÅ, j_ne, approx‚ü© := exists_approx_polynomial hb hŒµ (fin.cons (A 0) (Œª j, A (fin.succ (classical.some (this j)))))
revert j_ne approx
refine fin.cases _ (Œª j‚ÇÄ, _) j‚ÇÄ; refine fin.cases (Œª j_ne approx, _) (Œª j‚ÇÅ j_ne approx, _) j‚ÇÅ
refine fin.cases (Œª j_ne approx, _) (Œª j‚ÇÅ j_ne approx, _) j‚ÇÅ
refine fin.cases (Œª j_ne approx, _) (Œª j‚ÇÅ j_ne approx, _) j‚ÇÅ
refine fin.cases _ (Œª j‚ÇÄ, _) j‚ÇÄ
{ exact absurd rfl j_ne }
exact absurd rfl j_ne
rw [fin.cons_succ, fin.cons_zero, ‚Üê not_le, absolute_value.map_sub] at approx
have := (classical.some_spec (this j‚ÇÅ)).2
{ rw [fin.cons_succ, fin.cons_zero, ‚Üê not_le, absolute_value.map_sub] at approx, have := (classical.some_spec (this j‚ÇÅ)).2, contradiction }
contradiction
rw [fin.cons_succ, fin.cons_zero, ‚Üê not_le] at approx
have := (classical.some_spec (this j‚ÇÄ)).2
{ rw [fin.cons_succ, fin.cons_zero, ‚Üê not_le] at approx, have := (classical.some_spec (this j‚ÇÄ)).2, contradiction }
contradiction
rw [fin.cons_succ, fin.cons_succ] at approx
rw [ne.def, fin.succ_inj] at j_ne
have : j‚ÇÄ = j‚ÇÅ := (classical.some_spec (this j‚ÇÄ)).1.symm.trans (((ht' (classical.some (this j‚ÇÄ)) (classical.some (this j‚ÇÅ))).mpr approx).trans (classical.some_spec (this j‚ÇÅ)).1)
{ by_contra this, push_neg at this, obtain ‚ü®j‚ÇÄ, j‚ÇÅ, j_ne, approx‚ü© := exists_approx_polynomial hb hŒµ (fin.cons (A 0) (Œª j, A (fin.succ (classical.some (this j))))), revert j_ne approx, refine fin.cases _ (Œª j‚ÇÄ, _) j‚ÇÄ; refine fin.cases (Œª j_ne approx, _) (Œª j‚ÇÅ j_ne approx, _) j‚ÇÅ, { exact absurd rfl j_ne }, { rw [fin.cons_succ, fin.cons_zero, ‚Üê not_le, absolute_value.map_sub] at approx, have := (classical.some_spec (this j‚ÇÅ)).2, contradiction }, { rw [fin.cons_succ, fin.cons_zero, ‚Üê not_le] at approx, have := (classical.some_spec (this j‚ÇÄ)).2, contradiction }, { rw [fin.cons_succ, fin.cons_succ] at approx, rw [ne.def, fin.succ_inj] at j_ne, have : j‚ÇÄ = j‚ÇÅ := (classical.some_spec (this j‚ÇÄ)).1.symm.trans (((ht' (classical.some (this j‚ÇÄ)) (classical.some (this j‚ÇÅ))).mpr approx).trans (classical.some_spec (this j‚ÇÅ)).1), contradiction } }
contradiction
by_cases exists_nonempty_j : ‚àÉ j, (‚àÉ i, t' i = j) ‚àß ‚àÄ i, t' i = j ‚Üí (card_pow_degree (A 0 % b - A i.succ % b) : ‚Ñù) < card_pow_degree b ‚Ä¢ Œµ
obtain ‚ü®j, ‚ü®i, hi‚ü©, hj‚ü© := exists_nonempty_j
refine ‚ü®j, Œª i', ‚ü®hj i', Œª hi', trans ((ht' _ _).mpr _) hi‚ü©‚ü©
apply anti_archim' _ hi'
rw absolute_value.map_sub
{ obtain ‚ü®j, ‚ü®i, hi‚ü©, hj‚ü© := exists_nonempty_j, refine ‚ü®j, Œª i', ‚ü®hj i', Œª hi', trans ((ht' _ _).mpr _) hi‚ü©‚ü©, apply anti_archim' _ hi', rw absolute_value.map_sub, exact hj _ hi }
exact hj _ hi
refine ‚ü®j, Œª i, ‚ü®hj i, Œª hi, _‚ü©‚ü©
have := exists_nonempty_j ‚ü®t' i, ‚ü®i, rfl‚ü©, Œª i' hi', anti_archim' hi ((ht' _ _).mp hi')‚ü©
contradiction
simp [nat.mul_eq_one_iff, prod.ext_iff]
ext
simp only [l_series, add_apply]
rw ‚Üê tsum_add hf hg
apply congr rfl (funext (Œª n, _))
apply _root_.add_div
by_cases h0 : m = 0
subst h0
have hf : f = 0 := arithmetic_function.ext (Œª n, complex.abs_eq_zero.1 (le_antisymm (h n) (complex.abs_nonneg _)))
{ subst h0, have hf : f = 0 := arithmetic_function.ext (Œª n, complex.abs_eq_zero.1 (le_antisymm (h n) (complex.abs_nonneg _))), simp [hf] }
simp [hf]
refine summable_of_norm_bounded (Œª (n : ‚Ñï), m / (n ^ z)) _ _
simp_rw [div_eq_mul_inv]
exact (summable_mul_left_iff h0).1 (real.summable_nat_rpow_inv.2 hz)
{ simp_rw [div_eq_mul_inv], exact (summable_mul_left_iff h0).1 (real.summable_nat_rpow_inv.2 hz) }
intro n
have hm : 0 ‚â§ m := le_trans (complex.abs_nonneg _) (h 0)
cases n
{ simp [hm, real.zero_rpow (ne_of_gt (lt_trans real.zero_lt_one hz))] }
simp [hm, real.zero_rpow (ne_of_gt (lt_trans real.zero_lt_one hz))]
simp only [complex.abs_div, complex.norm_eq_abs]
apply div_le_div hm (h _) (real.rpow_pos_of_pos (nat.cast_pos.2 n.succ_pos) _) (le_of_eq _)
rw [complex.abs_cpow_real, complex.abs_cast_nat]
rw add_comm
rw add_comm; simp [hz']
simp [hz']
rw [hq, ha, zero_add]
rw [sq, right_distrib, mul_assoc]
simpa using eq_neg_of_add_eq_zero this
simp [this]
simpa [h]
rw ‚Üêthis
rw ‚Üêthis; refl
obtain ‚ü®k, hk‚ü© := @exists_pow_neg_lt p _ Œµ (by exact_mod_cast hŒµ)
exact_mod_cast hŒµ
use k
simp
rw (show (p : ‚Ñù) = (p : ‚Ñö), by simp) at hk
exact_mod_cast hk
rw [padic_val_nat.pow p _ _ (fact.out p.prime).ne_zero, padic_val_nat_self p, mul_one]
simp [hr]
rw [‚Üêpadic_norm.mul, div_mul_cancel _ hr]
unfold padic_val_rat; split_ifs; simp *
unfold padic_val_rat; split_ifs
split_ifs
simp *
simp *
unfold padic_val_rat
apply stationary_point_spec hf
apply le_trans
{ apply le_max_left _ v3 }
apply le_max_left _ v3
{ apply le_trans, { apply le_max_left _ v3 }, { apply le_max_right } }
apply le_max_right
apply le_refl
by_cases hf : f ‚âà 0
from setoid.trans (setoid.symm h) hf
have hg : g ‚âà 0
{ have hg : g ‚âà 0, from setoid.trans (setoid.symm h) hf, simp [hf, hg, padic_seq.valuation] }
simp [hf, hg, padic_seq.valuation]
from (Œª hg, hf (setoid.trans h hg))
have hg : ¬¨ g ‚âà 0
rw padic_seq.val_eq_iff_norm_eq hf hg
exact padic_seq.norm_equiv h
injection (pell_zd_sub _ h) with h _; repeat {rw ‚Üê neg_mul_eq_mul_neg at h}; exact h
injection (pell_zd_sub _ h) with h _; repeat {rw ‚Üê neg_mul_eq_mul_neg at h}
repeat {rw ‚Üê neg_mul_eq_mul_neg at h}
repeat {rw ‚Üê neg_mul_eq_mul_neg at h}
repeat {rw ‚Üê neg_mul_eq_mul_neg at h}
injection (pell_zd_sub _ h) with h _
rw ‚Üê neg_mul_eq_mul_neg at h
rw ‚Üê neg_mul_eq_mul_neg at h
exact h
by_cases h0 : int.gcd x y = 0
apply int.nat_abs_eq_zero.mp
apply nat.eq_zero_of_gcd_eq_zero_left h0
have hx : x = 0
{ apply int.nat_abs_eq_zero.mp, apply nat.eq_zero_of_gcd_eq_zero_left h0 }
apply int.nat_abs_eq_zero.mp
apply nat.eq_zero_of_gcd_eq_zero_right h0
have hy : y = 0
{ apply int.nat_abs_eq_zero.mp, apply nat.eq_zero_of_gcd_eq_zero_right h0 }
norm_num [hx, hy]
{ have hx : x = 0, { apply int.nat_abs_eq_zero.mp, apply nat.eq_zero_of_gcd_eq_zero_left h0 }, have hy : y = 0, { apply int.nat_abs_eq_zero.mp, apply nat.eq_zero_of_gcd_eq_zero_right h0 }, use [0, 1, 0], norm_num [hx, hy], }
use [0, 1, 0]
apply h.is_classified_of_normalize_is_primitive_classified
apply h.normalize.is_primitive_classified_of_coprime
apply int.gcd_div_gcd_div_gcd (nat.pos_of_ne_zero h0)
rw [legendre_sym_eq_pow, gauss_lemma_aux‚ÇÇ p ha0]; simp
simp
rw [legendre_sym_eq_pow, gauss_lemma_aux‚ÇÇ p ha0]
cases legendre_sym_eq_one_or_neg_one a p ha0
cases legendre_sym_eq_one_or_neg_one a p ha0; cases neg_one_pow_eq_or ‚Ñ§ ((Ico 1 (p / 2).succ).filter (Œª x : ‚Ñï, p / 2 < (a * x : zmod p).val)).card; simp [*, ne_neg_self p one_ne_zero, (ne_neg_self p one_ne_zero).symm] at *
cases legendre_sym_eq_one_or_neg_one a p ha0; cases neg_one_pow_eq_or ‚Ñ§ ((Ico 1 (p / 2).succ).filter (Œª x : ‚Ñï, p / 2 < (a * x : zmod p).val)).card
cases neg_one_pow_eq_or ‚Ñ§ ((Ico 1 (p / 2).succ).filter (Œª x : ‚Ñï, p / 2 < (a * x : zmod p).val)).card
cases neg_one_pow_eq_or ‚Ñ§ ((Ico 1 (p / 2).succ).filter (Œª x : ‚Ñï, p / 2 < (a * x : zmod p).val)).card
simp [*, ne_neg_self p one_ne_zero, (ne_neg_self p one_ne_zero).symm] at *
simp [*, ne_neg_self p one_ne_zero, (ne_neg_self p one_ne_zero).symm] at *
simp [*, ne_neg_self p one_ne_zero, (ne_neg_self p one_ne_zero).symm] at *
simp [*, ne_neg_self p one_ne_zero, (ne_neg_self p one_ne_zero).symm] at *
apply_instance
simp [ext]
simp [ext]
simp [bit1]
rcases eq_Inf_coatoms b with ‚ü®s, rfl, hs‚ü©
cases s.eq_empty_or_nonempty with h h
{ simp [h] }
simp [h]
exact or.intro_right _ ‚ü®h.some, hs _ h.some_spec, Inf_le h.some_spec‚ü©
rw [h, hs]
rw [h, hi.eq_bot]
rw disjoint_iff at w
rw [‚Üêw, right_eq_inf]
rwa sup_eq_left at h
exact h.1
rw sup_comm
exact h.2
rw inf_comm
cases a; simp [none_eq_bot, some_eq_coe]
simp [none_eq_bot, some_eq_coe]
simp [none_eq_bot, some_eq_coe]
cases a
rcases ha with ‚ü®b, rfl, c, rfl, rfl‚ü©
simp at ha
exact ‚ü®_, rfl, le_sup_left‚ü©
rcases ha with ‚ü®b, rfl, c, rfl, rfl‚ü©
simp at ha
exact ‚ü®_, rfl, le_sup_right‚ü©
cases ha
rcases h‚ÇÅ a rfl with ‚ü®b, ‚ü®‚ü©, ab‚ü©
rcases h‚ÇÇ a rfl with ‚ü®c, ‚ü®‚ü©, ac‚ü©
exact ‚ü®_, rfl, sup_le ab ac‚ü©
cases eq_or_lt_of_le (le_sup_right : a ‚â§ x ‚äî a) with h‚ÇÅ h‚ÇÇ
{ exact h‚ÇÅ.symm ‚ñ∏ le_sup_left }
exact h‚ÇÅ.symm ‚ñ∏ le_sup_left
obtain ‚ü®y, lty, ylt‚ü© := exists_between h‚ÇÇ
apply (not_lt_of_le (sup_le (hx ‚ü®lty, ylt.trans_le (sup_le _ h.le)‚ü©) lty.le) ylt).elim
obtain ‚ü®u, au, ub‚ü© := exists_between h
apply (hx ‚ü®au, ub‚ü©).trans ub.le
exact is_least_singleton.union hs
rw insert_eq
refl
ext
rw is_compact_element_iff_le_of_directed_Sup_le at hk
by_contradiction
from Sup_le (Œª s hs, (hbelow s hs).le)
have sSup : Sup s ‚â§ k
replace sSup : Sup s = k := eq_iff_le_not_lt.mpr ‚ü®sSup, h‚ü©
obtain ‚ü®x, hxs, hkx‚ü© := hk s hemp hdir sSup.symm.le
obtain hxk := hbelow x hxs
exact hxk.ne (hxk.le.antisymm hkx)
obtain ‚ü®t, ht‚ÇÅ, ht‚ÇÇ‚ü© := h s
intros s hne hsc
clear h
cases t.eq_empty_or_nonempty with h h
rw finset.sup_empty at ht‚ÇÇ
rw ht‚ÇÇ
subst h
simp [eq_singleton_bot_of_Sup_eq_bot_of_nonempty ht‚ÇÇ hne]
{ subst h, rw finset.sup_empty at ht‚ÇÇ, rw ht‚ÇÇ, simp [eq_singleton_bot_of_Sup_eq_bot_of_nonempty ht‚ÇÇ hne], }
exact t.sup_closed_of_sup_closed h ht‚ÇÅ hsc
rw ht‚ÇÇ
symmetry
have hle : Sup {a : Œ± | is_atom a ‚àß a ‚â§ b} ‚â§ b := (Sup_le $ Œª _, and.right)
apply (lt_or_eq_of_le hle).resolve_left (Œª con, _)
obtain ‚ü®c, hc‚ü© := exists_is_compl (‚ü®Sup {a : Œ± | is_atom a ‚àß a ‚â§ b}, hle‚ü© : set.Iic b)
obtain rfl | ‚ü®a, ha, hac‚ü© := eq_bot_or_exists_atom_le c
exact ne_of_lt con (subtype.ext_iff.1 (eq_top_of_is_compl_bot hc))
{ exact ne_of_lt con (subtype.ext_iff.1 (eq_top_of_is_compl_bot hc)) }
apply ha.1
rw eq_bot_iff
apply le_trans (le_inf _ hac) hc.1
rw [‚Üê subtype.coe_le_coe, subtype.coe_mk]
exact le_Sup ‚ü®ha.of_is_atom_coe_Iic, a.2‚ü©
simp only [disjoint_iff, supr_inf_eq, supr_eq_bot]
simp [compl_infi]
simpa only [range_comp, subtype.range_coe, supr_subtype'] using @is_lub_supr Œ± s _ (f ‚àò coe)
refine (supr_le_supr $ Œª i, _).trans (supr_comp_le _ f)
exact supr_le_supr_const hf.ne
simp
simp
refine { le := le, top := top, bot := bot, sup := sup, inf := inf, Sup := Sup, Inf := Inf, .. complete_lattice.copy (@complete_distrib_lattice.to_complete_lattice Œ± c) le eq_le top eq_top bot eq_bot sup eq_sup inf eq_inf Sup eq_Sup Inf eq_Inf, .. }
abstract { subst_vars, casesI c, assumption }
abstract { subst_vars, casesI c, assumption }
subst_vars
casesI c
all_goals { abstract { subst_vars, casesI c, assumption } }
assumption
apply tendsto_at_top.2 (Œªb, _)
obtain ‚ü®n : ‚Ñï, hn : 1 ‚â§ n ‚Ä¢ r‚ü© := archimedean.arch 1 hr
rwa nsmul_eq_mul at hn
have hn' : 1 ‚â§ (n : R) * r
filter_upwards [tendsto_at_top.1 hf (max b 0 * n)]
assume x hx
rw [mul_one]
calc b ‚â§ max b 0 * 1 : by { rw [mul_one], exact le_max_left _ _ } ... ‚â§ max b 0 * (n * r) : mul_le_mul_of_nonneg_left hn' (le_max_right _ _) ... = (max b 0 * n) * r : by rw [mul_assoc] ... ‚â§ f x * r : mul_le_mul_of_nonneg_right hx (le_of_lt hr)
exact le_max_left _ _
rw [mul_assoc]
apply le_antisymm; refine map_at_top_finset_prod_le_of_prod_eq (Œª s, _)
refine map_at_top_finset_prod_le_of_prod_eq (Œª s, _)
refine map_at_top_finset_prod_le_of_prod_eq (Œª s, _)
apply le_antisymm
refine ‚ü®s.preimage g (hg.inj_on _), Œª t ht, _‚ü©
refine ‚ü®t.image g ‚à™ s, finset.subset_union_right _ _, _‚ü©
rw [‚Üê finset.prod_image (hg.inj_on _)]
refine (prod_subset (subset_union_left _ _) _).symm
simp only [finset.mem_union, finset.mem_image]
refine Œª y hy hyt, hf y (mt _ hyt)
rintros ‚ü®x, rfl‚ü©
exact ‚ü®x, ht (finset.mem_preimage.2 $ hy.resolve_left hyt), rfl‚ü©
{ refine ‚ü®s.preimage g (hg.inj_on _), Œª t ht, _‚ü©, refine ‚ü®t.image g ‚à™ s, finset.subset_union_right _ _, _‚ü©, rw [‚Üê finset.prod_image (hg.inj_on _)], refine (prod_subset (subset_union_left _ _) _).symm, simp only [finset.mem_union, finset.mem_image], refine Œª y hy hyt, hf y (mt _ hyt), rintros ‚ü®x, rfl‚ü©, exact ‚ü®x, ht (finset.mem_preimage.2 $ hy.resolve_left hyt), rfl‚ü© }
refine ‚ü®s.image g, Œª t ht, _‚ü©
simp only [‚Üê prod_preimage _ _ (hg.inj_on _) _ (Œª x _, hf x)]
exact ‚ü®_, (image_subset_iff_subset_preimage _).1 ht, rfl‚ü©
refine ‚ü®Œª h, _, Œª h, tendsto_neg_const_mul_pow_at_top h.1 h.2‚ü©
simp only [tendsto_at_bot, eventually_at_top] at h
have : c < 0 := let ‚ü®x, hx‚ü© := h (-1) in neg_of_mul_neg_right (lt_of_le_of_lt (hx (max x 1) (le_max_left x 1)) (by simp [zero_lt_one])) (pow_nonneg (le_trans zero_le_one (le_max_right x 1)) n)
simp [zero_lt_one]
refine ‚ü®nat.succ_le_iff.mp (lt_of_le_of_ne (zero_le n) (ne.symm (Œª hn, _))), this‚ü©
obtain ‚ü®x, hx‚ü© := h (c - 1)
specialize hx x le_rfl
rw [hn, pow_zero, mul_one, le_sub, sub_self] at hx
exact absurd hx (not_le.mpr zero_lt_one)
apply le_antisymm
intros U U_in
rcases B.mem_filter_iff.mp U_in with ‚ü®V, V_in, h‚ü©
exact generate_sets.superset (generate_sets.basic V_in) h
{ intros U U_in, rcases B.mem_filter_iff.mp U_in with ‚ü®V, V_in, h‚ü©, exact generate_sets.superset (generate_sets.basic V_in) h }
rw sets_iff_generate
apply mem_filter_of_mem
exact inf_ne_bot_iff_frequently_left
rw inf_comm
rcases cblb.exists_countable_infi_principal with ‚ü®B, Bcbl, rfl‚ü©
exact countable_binfi_principal_eq_seq_infi Bcbl
simpa [h]
simp [h]
simp only [has_bind.bind, bind, functor.map, mem_map', mem_join, mem_set_of_eq, function.comp, mem_pure]
simp only [tendsto, le_pure_iff, mem_map', mem_singleton_iff, filter.eventually]
simp only [filter.prod, eq_self_iff_true]
rw [filter.prod, comap_infi, inf_infi]
simp [mem_binfi_of_directed h ne]
simp only [*, hst.1 hxs, indicator_of_mem]
simp only [indicator_of_not_mem hxs, indicator_of_not_mem (mt hst.2 hxs)]
simp only [id, ‚Üê exists_mem_subset_iff]
split
ext s
rintros ‚ü®a, b, ‚ü®a‚ÇÅ, a‚ÇÇ, ha‚ÇÅ, ha‚ÇÇ, a‚ÇÅa‚ÇÇ‚ü©, hb, ab‚ü©
rw [‚Üê mul_assoc]
refine ‚ü®a‚ÇÅ, a‚ÇÇ * b, ha‚ÇÅ, mul_mem_mul ha‚ÇÇ hb, _‚ü©
exact calc a‚ÇÅ * a‚ÇÇ * b ‚äÜ a * b : mul_subset_mul a‚ÇÅa‚ÇÇ (subset.refl _) ... ‚äÜ s : ab
{ rintros ‚ü®a, b, ‚ü®a‚ÇÅ, a‚ÇÇ, ha‚ÇÅ, ha‚ÇÇ, a‚ÇÅa‚ÇÇ‚ü©, hb, ab‚ü©, refine ‚ü®a‚ÇÅ, a‚ÇÇ * b, ha‚ÇÅ, mul_mem_mul ha‚ÇÇ hb, _‚ü©, rw [‚Üê mul_assoc], exact calc a‚ÇÅ * a‚ÇÇ * b ‚äÜ a * b : mul_subset_mul a‚ÇÅa‚ÇÇ (subset.refl _) ... ‚äÜ s : ab }
rintros ‚ü®a, b, ha, ‚ü®b‚ÇÅ, b‚ÇÇ, hb‚ÇÅ, hb‚ÇÇ, b‚ÇÅb‚ÇÇ‚ü©, ab‚ü©
rw [mul_assoc]
refine ‚ü®a * b‚ÇÅ, b‚ÇÇ, mul_mem_mul ha hb‚ÇÅ, hb‚ÇÇ, _‚ü©
exact calc a * (b‚ÇÅ * b‚ÇÇ) ‚äÜ a * b : mul_subset_mul (subset.refl _) b‚ÇÅb‚ÇÇ ... ‚äÜ s : ab
resetI
simp only [‚Üê u.unique (map_le_iff_le_comap.2 hgu), comap_map inj, le_rfl]
simp only [image_pair, is_lub_pair]
rw gi.choice_eq
exact (gi.is_glb_of_u_image (is_glb_Inf _)).1
rw gi.choice_eq
exact (gi.is_glb_of_u_image (is_glb_Inf _)).2
simp [upper_bounds, gc _ _]
rw function.iterate_zero
exact le_rfl
rw function.iterate_succ_apply'
exact (id_le_iterate_of_id_le n x).trans (h _)
simp [le_refl]
haveI := A
haveI := A; exact x ‚â§ y
exact x ‚â§ y
haveI := A
haveI := A; exact (x ‚äî y)
exact (x ‚äî y)
simp only [sup_le_iff]; rw [‚Üê H, @sup_le_iff Œ± A, H, H]
rw [‚Üê H, @sup_le_iff Œ± A, H, H]
simp only [sup_le_iff]
rw [sup_eq_right, ‚Üêinf_eq_left]
intro
dsimp [continuous] at *
rw [hfc,hgc,chain.map_comp]
intro c; rw [œâSup_bind, ‚Üê hf', ‚Üê hg']; refl
intro c; rw [œâSup_bind, ‚Üê hf', ‚Üê hg']
rw [œâSup_bind, ‚Üê hf', ‚Üê hg']
refl
intro c
suffices : (‚®Ü (m : ‚Ñï), a m) ‚â§ monotonic_sequence_limit a
{ exact le_antisymm this (le_supr a _), }
exact le_antisymm this (le_supr a _)
apply supr_le
intros m
by_cases hm : m ‚â§ monotonic_sequence_limit_index a
{ exact a.monotone hm, }
exact a.monotone hm
replace hm := le_of_not_le hm
let S := { n | ‚àÄ m, n ‚â§ m ‚Üí a n = a m }
have hInf : Inf S ‚àà S
rw well_founded.monotone_chain_condition at h
exact h a
refine nat.Inf_mem _
{ refine nat.Inf_mem _, rw well_founded.monotone_chain_condition at h, exact h a, }
change Inf S ‚â§ m at hm
change a m ‚â§ a (Inf S)
rw hInf m hm
induction n with n ih
{ simp }
simp
dsimp [partial_sups] at ih ‚ä¢
simp_rw @finset.range_succ n.succ
rw [ih, finset.sup'_insert, sup_comm]
intros h
intros h
split
split; intros h
{ exact h 1 0, }
exact h 1 0
have h' : ‚àÄ n a‚ÇÅ a‚ÇÇ, f^[n] (a‚ÇÅ ‚äî a‚ÇÇ) ‚â§ (f^[n] a‚ÇÅ) ‚äî a‚ÇÇ
intros n‚ÇÅ n‚ÇÇ a‚ÇÅ a‚ÇÇ
induction n with n ih
induction n with n ih; intros a‚ÇÅ a‚ÇÇ
intros a‚ÇÅ a‚ÇÇ
intros a‚ÇÅ a‚ÇÇ
intros n
{ refl, }
refl
calc f^[n + 1] (a‚ÇÅ ‚äî a‚ÇÇ) = (f^[n] (f (a‚ÇÅ ‚äî a‚ÇÇ))) : function.iterate_succ_apply f n _ ... ‚â§ (f^[n] ((f a‚ÇÅ) ‚äî a‚ÇÇ)) : f.mono.iterate n (h a‚ÇÅ a‚ÇÇ) ... ‚â§ (f^[n] (f a‚ÇÅ)) ‚äî a‚ÇÇ : ih _ _ ... = (f^[n + 1] a‚ÇÅ) ‚äî a‚ÇÇ : by rw ‚Üê function.iterate_succ_apply
rw ‚Üê function.iterate_succ_apply
{ intros n, induction n with n ih; intros a‚ÇÅ a‚ÇÇ, { refl, }, { calc f^[n + 1] (a‚ÇÅ ‚äî a‚ÇÇ) = (f^[n] (f (a‚ÇÅ ‚äî a‚ÇÇ))) : function.iterate_succ_apply f n _ ... ‚â§ (f^[n] ((f a‚ÇÅ) ‚äî a‚ÇÇ)) : f.mono.iterate n (h a‚ÇÅ a‚ÇÇ) ... ‚â§ (f^[n] (f a‚ÇÅ)) ‚äî a‚ÇÇ : ih _ _ ... = (f^[n + 1] a‚ÇÅ) ‚äî a‚ÇÇ : by rw ‚Üê function.iterate_succ_apply, }, }
calc f^[n‚ÇÅ + n‚ÇÇ] (a‚ÇÅ ‚äî a‚ÇÇ) = (f^[n‚ÇÅ] (f^[n‚ÇÇ] (a‚ÇÅ ‚äî a‚ÇÇ))) : function.iterate_add_apply f n‚ÇÅ n‚ÇÇ _ ... = (f^[n‚ÇÅ] (f^[n‚ÇÇ] (a‚ÇÇ ‚äî a‚ÇÅ))) : by rw sup_comm ... ‚â§ (f^[n‚ÇÅ] ((f^[n‚ÇÇ] a‚ÇÇ) ‚äî a‚ÇÅ)) : f.mono.iterate n‚ÇÅ (h' n‚ÇÇ _ _) ... = (f^[n‚ÇÅ] (a‚ÇÅ ‚äî (f^[n‚ÇÇ] a‚ÇÇ))) : by rw sup_comm ... ‚â§ (f^[n‚ÇÅ] a‚ÇÅ) ‚äî (f^[n‚ÇÇ] a‚ÇÇ) : h' n‚ÇÅ a‚ÇÅ _
rw sup_comm
rw sup_comm
cases le_or_lt n m with h
symmetry
exact strict_mono.monotone (Œª x y, a.map_rel) h
rw [inf_eq_right.mpr h, inf_eq_right]
{ rw [inf_eq_right.mpr h, inf_eq_right], exact strict_mono.monotone (Œª x y, a.map_rel) h, }
exact le_of_lt (a.map_rel h)
rw [inf_eq_left.mpr (le_of_lt h), inf_eq_left]
congr
exact h
ext
refl
simp only [(Œî), sdiff_eq]
rw [sdiff_symm_diff, sdiff_sup, sup_comm]
apply min_mem
rw [well_founded.succ, dif_pos h]
classical
revert hf
apply f.induction_on
intro h
{ intro h, simp [set.is_pwo_empty.is_wf], }
simp [set.is_pwo_empty.is_wf]
intros s f sf hf hsf
rw finset.sup_insert
exact (hsf s (finset.mem_insert_self _ _)).union (hf (Œª s' s'f, hsf _ (finset.mem_insert_of_mem s'f)))
rcases s.eq_empty_or_nonempty with rfl | ‚ü®as, has‚ü©
apply partially_well_ordered_on.mono (finset.partially_well_ordered_on {list.nil})
intros l hl
rw [finset.mem_coe, finset.mem_singleton, list.eq_nil_iff_forall_not_mem]
{ intros l hl, rw [finset.mem_coe, finset.mem_singleton, list.eq_nil_iff_forall_not_mem], exact hl, }
exact hl
{ apply partially_well_ordered_on.mono (finset.partially_well_ordered_on {list.nil}), { intros l hl, rw [finset.mem_coe, finset.mem_singleton, list.eq_nil_iff_forall_not_mem], exact hl, }, apply_instance }
apply_instance
haveI : inhabited Œ± := ‚ü®as‚ü©
rw [iff_not_exists_is_min_bad_seq (list.length)]
rintro ‚ü®f, hf1, hf2‚ü©
have hnil : ‚àÄ n, f n ‚â† list.nil := Œª n con, (hf1).2 n n.succ n.lt_succ_self (con.symm ‚ñ∏ list.sublist_forall‚ÇÇ.nil)
obtain ‚ü®g, hg‚ü© := h.exists_monotone_subseq (list.head ‚àò f) _
simp only [set.range_subset_iff, function.comp_apply]
swap
exact Œª n, hf1.1 (set.mem_range_self n) _ (list.head_mem_self (hnil n))
{ simp only [set.range_subset_iff, function.comp_apply], exact Œª n, hf1.1 (set.mem_range_self n) _ (list.head_mem_self (hnil n)) }
have hf' := hf2 (g 0) (Œª n, if n < g 0 then f n else list.tail (f (g (n - g 0)))) (Œª m hm, (if_pos hm).symm) _
simp only [if_neg (lt_irrefl (g 0)), nat.sub_self]
swap
rw [list.length_tail, ‚Üê nat.pred_eq_sub_one]
exact nat.pred_lt (Œª con, hnil _ (list.length_eq_zero.1 con))
{ simp only [if_neg (lt_irrefl (g 0)), nat.sub_self], rw [list.length_tail, ‚Üê nat.pred_eq_sub_one], exact nat.pred_lt (Œª con, hnil _ (list.length_eq_zero.1 con)) }
rw [is_bad_seq] at hf'
push_neg at hf'
obtain ‚ü®m, n, mn, hmn‚ü© := hf' _
rw set.range_subset_iff
swap
rintro n x hx
split_ifs at hx with hn hn
{ exact hf1.1 (set.mem_range_self _) _ hx }
exact hf1.1 (set.mem_range_self _) _ hx
{ rw set.range_subset_iff, rintro n x hx, split_ifs at hx with hn hn, { exact hf1.1 (set.mem_range_self _) _ hx }, { refine hf1.1 (set.mem_range_self _) _ (list.tail_subset _ hx), } }
refine hf1.1 (set.mem_range_self _) _ (list.tail_subset _ hx)
by_cases hn : n < g 0
apply hf1.2 m n mn
{ apply hf1.2 m n mn, rwa [if_pos hn, if_pos (mn.trans hn)] at hmn }
rwa [if_pos hn, if_pos (mn.trans hn)] at hmn
obtain ‚ü®n', rfl‚ü© := le_iff_exists_add.1 (not_lt.1 hn)
rw [if_neg hn, add_comm (g 0) n', nat.add_sub_cancel] at hmn
split_ifs at hmn with hm hm
apply hf1.2 m (g n') (lt_of_lt_of_le hm (g.monotone n'.zero_le))
{ apply hf1.2 m (g n') (lt_of_lt_of_le hm (g.monotone n'.zero_le)), exact trans hmn (list.tail_sublist_forall‚ÇÇ_self _) }
exact trans hmn (list.tail_sublist_forall‚ÇÇ_self _)
rw [‚Üê (nat.sub_lt_left_iff_lt_add (le_of_not_lt hm))] at mn
apply hf1.2 _ _ (g.lt_iff_lt.2 mn)
rw [‚Üê list.cons_head_tail (hnil (g (m - g 0))), ‚Üê list.cons_head_tail (hnil (g n'))]
exact list.sublist_forall‚ÇÇ.cons (hg _ _ (le_of_lt mn)) hmn
rintro _ ‚ü®p, hpc, rfl‚ü© _ ‚ü®q, hqc, rfl‚ü© hpq
rintro _ ‚ü®p, hpc, rfl‚ü© _ ‚ü®q, hqc, rfl‚ü© hpq; exact hc p hpc q hqc (mt (by rintro rfl; refl) hpq)
exact hc p hpc q hqc (mt (by rintro rfl; refl) hpq)
rintro rfl
rintro rfl; refl
refl
intros t‚ÇÅ t‚ÇÇ ht‚ÇÅ ht‚ÇÇ
have hf_m : ‚àÄ (x : Œπ), x ‚àà {i, j} ‚Üí (ite (x=i) t‚ÇÅ t‚ÇÇ) ‚àà s x
intros x hx
cases finset.mem_insert.mp hx with hx hx
{ simp [hx, ht‚ÇÅ], }
simp [hx, ht‚ÇÅ]
{ simp [finset.mem_singleton.mp hx, hij.symm, ht‚ÇÇ], }
{ intros x hx, cases finset.mem_insert.mp hx with hx hx, { simp [hx, ht‚ÇÅ], }, { simp [finset.mem_singleton.mp hx, hij.symm, ht‚ÇÇ], }, }
simp [finset.mem_singleton.mp hx, hij.symm, ht‚ÇÇ]
have h1 : t‚ÇÅ = ite (i = i) t‚ÇÅ t‚ÇÇ
simp only [if_true, eq_self_iff_true]
have h2 : t‚ÇÇ = ite (j = i) t‚ÇÅ t‚ÇÇ
simp only [hij.symm, if_false]
have h_inter : (‚ãÇ (t : Œπ) (H : t ‚àà ({i, j} : finset Œπ)), ite (t = i) t‚ÇÅ t‚ÇÇ) = (ite (i = i) t‚ÇÅ t‚ÇÇ) ‚à© (ite (j = i) t‚ÇÅ t‚ÇÇ)
simp only [finset.set_bInter_singleton, finset.set_bInter_insert]
have h_prod : (‚àè (t : Œπ) in ({i, j} : finset Œπ), Œº (ite (t = i) t‚ÇÅ t‚ÇÇ)) = Œº (ite (i = i) t‚ÇÅ t‚ÇÇ) * Œº (ite (j = i) t‚ÇÅ t‚ÇÇ)
simp only [hij, finset.prod_singleton, finset.prod_insert, not_false_iff, finset.mem_singleton]
rw h1
nth_rewrite 1 h2
nth_rewrite 3 h2
rw [‚Üêh_inter, ‚Üêh_prod, h_indep {i, j} hf_m]
rw [‚Üê algebra_map_eq, ‚Üê aeval_def, aeval_eq, mk_self]
apply ideal.quotient.lift _ (eval‚ÇÇ_ring_hom i x)
intros g H
rcases mem_span_singleton.1 H with ‚ü®y, hy‚ü©
rw [hy, ring_hom.map_mul, coe_eval‚ÇÇ_ring_hom, h, zero_mul]
rw [power_basis_gen, minpoly_root hf, polynomial.map_mul, roots_mul, polynomial.map_C, roots_C, add_zero, equiv.refl_apply]
exact map_monic_ne_zero (monic_mul_leading_coeff_inv hf)
rw ‚Üê polynomial.map_mul
rw [is_artinian_iff_well_founded]; exact (well_founded.monotone_chain_condition (order_dual (submodule R M))).symm
rw [is_artinian_iff_well_founded]
exact (well_founded.monotone_chain_condition (order_dual (submodule R M))).symm
rw [‚Üê hb, gcd_eq_gcd_ab, mul_comm x, mul_comm y, mul_add, mul_assoc, mul_assoc]
refine ‚ü®Œª h, _, algebra.finite_type.of_finite_presentation‚ü©
obtain ‚ü®n, f, hf‚ü© := algebra.finite_type.iff_quotient_mv_polynomial''.1 h
refine ‚ü®n, f, hf, _‚ü©
have hnoet : is_noetherian_ring (mv_polynomial (fin n) R) := by apply_instance
apply_instance
replace hnoet := (is_noetherian_ring_iff.1 hnoet).noetherian
exact hnoet f.to_ring_hom.ker
letI := f.to_algebra
exact module.finite.of_surjective (algebra.of_id A B).to_linear_map hf
rw is_noetherian_iff
intros J hJ
obtain ‚ü®J, rfl‚ü© := le_one_iff_exists_coe_ideal.mp (le_trans hJ coe_ideal_le_one)
exact fg_map (is_noetherian.noetherian J)
intros x hx
convert submodule.zero_mem _
simpa using hx
ext n
simp only [algebra_map_apply, power_series.algebra_map_apply, ring_equiv.to_fun_eq_coe, C_apply, coeff_to_power_series]
cases n
simp only [power_series.coeff_zero_eq_constant_coeff, single_coeff_same]
{ simp only [power_series.coeff_zero_eq_constant_coeff, single_coeff_same], refl }
refl
simp only [n.succ_ne_zero, ne.def, not_false_iff, single_coeff_of_ne]
rw [power_series.coeff_C, if_neg n.succ_ne_zero]
rw [‚Üê add_zero a, single_mul_coeff_add, add_zero]
apply le_antisymm
apply order_le_of_coeff_ne_zero
rw [mul_coeff_order_add_order hx hy]
exact mul_ne_zero (coeff_order_ne_zero hx) (coeff_order_ne_zero hy)
{ apply order_le_of_coeff_ne_zero, rw [mul_coeff_order_add_order hx hy], exact mul_ne_zero (coeff_order_ne_zero hx) (coeff_order_ne_zero hy) }
rw [order_of_ne hx, order_of_ne hy, order_of_ne (mul_ne_zero hx hy), ‚Üê set.is_wf.min_add]
exact set.is_wf.min_le_min_of_subset (support_mul_subset_add_support)
contrapose! h
rw ‚Üê C_zero at h
exact C_injective h
by_cases h : r = 0
{ rw [h, C_zero, order_zero] }
rw [h, C_zero, order_zero]
exact order_single h
intros b
obtain ‚ü®a, rfl‚ü© := hf b
apply (local_ring.is_unit_or_is_unit_one_sub_self a).imp f.is_unit_map _
rw [‚Üê f.map_one, ‚Üê f.map_sub]
apply f.is_unit_map
rw [h, sub_zero]
rw [h, sub_zero]; exact is_unit_one
exact is_unit_one
rw [radical_eq_Inf, radical_eq_Inf]
have : ‚àÄ J ‚àà {J : ideal R | I ‚â§ J ‚àß J.is_prime}, f.ker ‚â§ J := Œª J hJ, le_trans h hJ.left
convert map_Inf hf this
refine funext (Œª j, propext ‚ü®_, _‚ü©)
rintros ‚ü®hj, hj'‚ü©
haveI : j.is_prime := hj'
exact ‚ü®comap f j, ‚ü®‚ü®map_le_iff_le_comap.1 hj, comap_is_prime f j‚ü©, map_comap_of_surjective f hf j‚ü©‚ü©
{ rintros ‚ü®hj, hj'‚ü©, haveI : j.is_prime := hj', exact ‚ü®comap f j, ‚ü®‚ü®map_le_iff_le_comap.1 hj, comap_is_prime f j‚ü©, map_comap_of_surjective f hf j‚ü©‚ü© }
rintro ‚ü®J, ‚ü®hJ, hJ'‚ü©‚ü©
haveI : J.is_prime := hJ.right
refine ‚ü®hJ' ‚ñ∏ map_mono hJ.left, hJ' ‚ñ∏ map_is_prime_of_surjective hf (le_trans h hJ.left)‚ü©
obtain ‚ü®a, rfl‚ü© := quotient.mk‚Çê_surjective R _ x
rw [‚Üê alg_hom.map_smul, quotient.mk‚Çê_eq_mk, ring_hom.ker_lift_mk]
exact f.map_smul _ _
simp [set.singleton_one]
induction n with n ih
{ simp [set.singleton_one], }
simp only [pow_succ, ih, span_singleton_mul_span_singleton]
intros
intros; rw [‚Üê int.coe_nat_mul, gcd_mul_lcm, coe_nat_abs_eq_normalize]
rw [‚Üê int.coe_nat_mul, gcd_mul_lcm, coe_nat_abs_eq_normalize]
apply unique_factorization_monoid.induction_on_prime
exact h‚ÇÄ
intros n h
rw nat.is_unit_iff.1 h
{ intros n h, rw nat.is_unit_iff.1 h, exact h‚ÇÅ, }
exact h‚ÇÅ
intros a p _ hp ha
exact h p a (nat.prime_iff.2 hp) ha
haveI : decidable_eq R := classical.dec_eq _
refine le_trans _ (nth_roots n (f g‚ÇÄ)).to_finset_card_le
apply card_le_card_of_inj_on f
intros g hg
rw [sep_def, mem_filter] at hg
rw [multiset.mem_to_finset, mem_nth_roots hn, ‚Üê f.map_pow, hg.2]
{ intros g hg, rw [sep_def, mem_filter] at hg, rw [multiset.mem_to_finset, mem_nth_roots hn, ‚Üê f.map_pow, hg.2] }
apply hf
assumption
intros
letI : is_fraction_ring (integral_closure R L) L := is_fraction_ring_of_finite_extension K L
exact (integral_closure_eq_bot_iff L).mp integral_closure_idem
rw [is_noetherian_ring_iff, is_noetherian_iff_well_founded] at h ‚ä¢
exact order_embedding.well_founded ((is_localization.order_embedding M S).dual) h
rw [zero_mul, h, ring_hom.map_zero]
simp only [smul_mk, zero_nsmul, mk_zero]
simp only [smul_mk, succ_nsmul, add_mk_self]
simp only [smul_mk, zero_gsmul, mk_zero]
simp [smul_mk, add_mk_self, -mk_eq_monoid_of_mk', add_comm (n : ‚Ñ§) 1, add_smul]
rw [smul_mk, smul_mk, neg_mk, ‚Üê neg_smul]
refl
tac
tac
tac
exact localization.induction_on y (by tac)
tac
tac
tac
tac
rw [‚Üê mk_zero (1 : M), mk_one_eq_monoid_of_mk]
simp only [‚Üê mk_one_eq_monoid_of_mk, add_mk, submonoid.coe_one, one_mul, add_comm]
rw [enat.get_eq_iff_eq_coe, eq_coe_iff, pow_zero]
simpa [is_unit_iff_dvd_one.symm] using not_unit_of_finite ha
rcases lt_trichotomy (multiplicity p a) (multiplicity p b) with hab|hab|hab
rw [add_comm, multiplicity_add_of_gt hab, min_eq_left]
exact le_of_lt hab
{ rw [add_comm, multiplicity_add_of_gt hab, min_eq_left], exact le_of_lt hab }
{ contradiction }
contradiction
exact le_of_lt hab
rw [multiplicity_add_of_gt hab, min_eq_right]
simp [one_right hp.not_unit]
simp [pow_succ, succ_nsmul, pow, multiplicity.mul hp]
refine le_antisymm _ (submodule.smul_le.2 (Œª _ _ _, submodule.smul_mem _ _))
intros n hn
cases submodule.exists_sub_one_mem_and_smul_eq_zero_of_fg_of_le_smul I N hN hIN with r hr
cases exists_mul_sub_mem_of_sub_one_mem_jacobson r (hIjac hr.1) with s hs
have : n = (-(r * s - 1) ‚Ä¢ n)
rw [neg_sub, sub_smul, mul_comm, mul_smul, hr.2 n hn, one_smul, smul_zero, sub_zero]
{ rw [neg_sub, sub_smul, mul_comm, mul_smul, hr.2 n hn, one_smul, smul_zero, sub_zero] }
rw this
exact submodule.smul_mem_smul (submodule.neg_mem _ hs) hn
obtain ‚ü®n, hn‚ü© := h
use n
rw [neg_pow, hn, mul_zero]
let i := ((quotient.mk I).comp C).range_restrict
have hi' : (polynomial.map_ring_hom i).ker ‚â§ I
refine Œª f hf, polynomial_mem_ideal_of_coeff_mem_ideal I f (Œª n, _)
rw [mem_comap, ‚Üê quotient.eq_zero_iff_mem, ‚Üê ring_hom.comp_apply]
rw [ring_hom.mem_ker, coe_map_ring_hom] at hf
replace hf := congr_arg (Œª (f : polynomial _), f.coeff n) hf
simp only [coeff_map, coeff_zero] at hf
rwa [subtype.ext_iff, ring_hom.coe_range_restrict] at hf
{ refine Œª f hf, polynomial_mem_ideal_of_coeff_mem_ideal I f (Œª n, _), rw [mem_comap, ‚Üê quotient.eq_zero_iff_mem, ‚Üê ring_hom.comp_apply], rw [ring_hom.mem_ker, coe_map_ring_hom] at hf, replace hf := congr_arg (Œª (f : polynomial _), f.coeff n) hf, simp only [coeff_map, coeff_zero] at hf, rwa [subtype.ext_iff, ring_hom.coe_range_restrict] at hf }
obtain ‚ü®x, hx'‚ü© := x
obtain ‚ü®y, rfl‚ü© := (ring_hom.mem_range).1 hx'
refine subtype.eq _
simp only [ring_hom.comp_apply, quotient.eq_zero_iff_mem, subring.coe_zero, subtype.val_eq_coe]
suffices : C (i y) ‚àà (I.map (polynomial.map_ring_hom i))
obtain ‚ü®f, hf‚ü© := mem_image_of_mem_map_of_surjective (polynomial.map_ring_hom i) (polynomial.map_surjective _ (((quotient.mk I).comp C).range_restrict_surjective)) this
refine sub_add_cancel (C y) f ‚ñ∏ I.add_mem (hi' _ : (C y - f) ‚àà I) hf.1
rw [ring_hom.mem_ker, ring_hom.map_sub, hf.2, sub_eq_zero, coe_map_ring_hom, map_C]
{ obtain ‚ü®f, hf‚ü© := mem_image_of_mem_map_of_surjective (polynomial.map_ring_hom i) (polynomial.map_surjective _ (((quotient.mk I).comp C).range_restrict_surjective)) this, refine sub_add_cancel (C y) f ‚ñ∏ I.add_mem (hi' _ : (C y - f) ‚àà I) hf.1, rw [ring_hom.mem_ker, ring_hom.map_sub, hf.2, sub_eq_zero, coe_map_ring_hom, map_C] }
exact hx
rw [‚Üê C_mul']
exact I.mul_mem_left _ H
apply le_antisymm
replace hp := mem_degree_le.1 hp
intros p hp
rw [‚Üê polynomial.sum_monomial_eq p, polynomial.sum]
refine submodule.sum_mem _ (Œª k hk, _)
show monomial _ _ ‚àà _
have := with_bot.coe_le_coe.1 (finset.sup_le_iff.1 hp k hk)
rw [monomial_eq_C_mul_X, C_mul']
refine submodule.smul_mem _ _ (submodule.subset_span $ finset.mem_coe.2 $ finset.mem_image.2 ‚ü®_, finset.mem_range.2 (nat.lt_succ_of_le this), rfl‚ü©)
{ intros p hp, replace hp := mem_degree_le.1 hp, rw [‚Üê polynomial.sum_monomial_eq p, polynomial.sum], refine submodule.sum_mem _ (Œª k hk, _), show monomial _ _ ‚àà _, have := with_bot.coe_le_coe.1 (finset.sup_le_iff.1 hp k hk), rw [monomial_eq_C_mul_X, C_mul'], refine submodule.smul_mem _ _ (submodule.subset_span $ finset.mem_coe.2 $ finset.mem_image.2 ‚ü®_, finset.mem_range.2 (nat.lt_succ_of_le this), rfl‚ü©) }
rw [submodule.span_le, finset.coe_image, set.image_subset_iff]
apply mem_degree_le.2
intros k hk
exact (degree_X_pow_le _).trans (with_bot.coe_le_coe.2 $ nat.le_of_lt_succ $ finset.mem_range.1 hk)
intros v hv
rcases submodule.mem_sup.1 hv with ‚ü®x, hx, y, hy, hxy‚ü©
have h_eval_x : aeval f (p * q) x = 0
rw [mul_comm, aeval_mul, linear_map.mul_apply, linear_map.mem_ker.1 hx, linear_map.map_zero]
{ rw [mul_comm, aeval_mul, linear_map.mul_apply, linear_map.mem_ker.1 hx, linear_map.map_zero] }
have h_eval_y : aeval f (p * q) y = 0
rw [aeval_mul, linear_map.mul_apply, linear_map.mem_ker.1 hy, linear_map.map_zero]
{ rw [aeval_mul, linear_map.mul_apply, linear_map.mem_ker.1 hy, linear_map.map_zero] }
rw [linear_map.mem_ker, ‚Üêhxy, linear_map.map_add, h_eval_x, h_eval_y, add_zero]
simp only [function.comp_app, ring_hom.coe_comp, ideal.quotient.eq_zero_iff_mem]
exact ideal.mem_map_of_mem _ hi
haveI := arbitrary (normalization_monoid D)
haveI := to_gcd_monoid D
exact ufm_of_gcd_of_wf_dvd_monoid
rw [bernstein_polynomial.iterate_derivative_at_1 _ _ _ h, ne.def, neg_one_pow_mul_eq_zero_iff, ‚Üênat.cast_succ, ‚Üêpochhammer_eval_cast, ‚Üênat.cast_zero, nat.cast_inj]
exact (pochhammer_pos _ _ (nat.succ_pos ŒΩ)).ne'
rw [‚Üê one_mul p.prim_part, ‚Üê C_1, ‚Üê hp.content_eq_one, ‚Üê p.eq_C_content_mul_prim_part]
rw content
by_cases h0 : r = 0
{ simp [h0] }
simp [h0]
have h : (C r).support = {0} := support_monomial _ _ h0
simp [h]
simp only [cyclotomic', finset.prod_singleton, ring_hom.map_one, is_primitive_root.primitive_roots_one]
convert finsupp.filter_apply (Œª d : œÉ ‚Üí‚ÇÄ ‚Ñï, ‚àë i in d.support, d i = n) œÜ d
simp only [esymm, powerset_len_zero, sum_singleton, prod_empty]
rw [polynomial.aeval_def, polynomial.aeval_def, polynomial.eval‚ÇÇ_map, algebra_map_eq R S A]
rw [coeff_trunc, coeff_C, mv_polynomial.coeff_C]
split_ifs with H; refl <|> try {simp * at *}
refl
refl
refl
refl
refl
refl
try {simp * at *}
try {simp * at *}
try {simp * at *}
simp * at *
split_ifs with H
apply H
subst m
intro s
exact nat.zero_le _
exfalso
rw ‚Üê span_singleton_generator S
exact subset_span (mem_singleton _)
conv_rhs { rw ‚Üê span_singleton_generator S }
apply is_unit_of_mul_eq_one Œ∂ (Œ∂ ^ (k - 1))
rw [‚Üê pow_succ, nat.sub_add_cancel h0, h.pow_eq_one]
apply finset.eq_singleton_iff_unique_mem.2
split
simp only [is_primitive_root.one_right_iff, mem_primitive_roots zero_lt_one]
{ simp only [is_primitive_root.one_right_iff, mem_primitive_roots zero_lt_one] }
intros x hx
rw [mem_primitive_roots zero_lt_one, is_primitive_root.one_right_iff] at hx
exact hx
exact subtype.eq (eq.symm (mk_eq_mk_iff_associated.mpr hpq))
exact mem_factor_set_some.mpr (mem_factors'_of_dvd ha0 hp hd)
rw factors_mk _ ha0
cases count_of_coprime ha hb hab hp with hz hb0
tauto
{ tauto }
apply or.intro_right
rw [count_mul ha hb hp, hb0, add_zero]
apply wf_dvd_monoid.well_founded_associates
have h : (normalize : Œ± ‚Üí Œ±) = associates.out ‚àò associates.mk
rw [function.comp_apply, associates.out_mk]
{ ext, rw [function.comp_apply, associates.out_mk], }
ext
rw [‚Üê multiset.map_id' (factors (x * y)), ‚Üê multiset.map_id' (factors x), ‚Üê multiset.map_id' (factors y), ‚Üê multiset.map_congr normalize_factor, ‚Üê multiset.map_congr normalize_factor, ‚Üê multiset.map_congr normalize_factor, ‚Üê multiset.map_add, h, ‚Üê multiset.map_map associates.out, eq_comm, ‚Üê multiset.map_map associates.out]
refine congr rfl _
apply multiset.map_mk_eq_map_mk_of_rel
apply factors_unique
intros x hx
rcases multiset.mem_add.1 hx with hx | hx; exact irreducible_of_factor x hx
rcases multiset.mem_add.1 hx with hx | hx
{ intros x hx, rcases multiset.mem_add.1 hx with hx | hx; exact irreducible_of_factor x hx }
exact irreducible_of_factor x hx
exact irreducible_of_factor x hx
{ exact irreducible_of_factor }
exact irreducible_of_factor
rw multiset.prod_add
exact ((factors_prod hx).mul_mul (factors_prod hy)).trans (factors_prod (mul_ne_zero hx hy)).symm
rw h
rwa [factors_prod, factors_prod] at this
refine eq_of_factors_eq_factors _
rw [‚Üê prod_add, prod_factors, factors_mul, factor_set.sup_add_inf_eq_add]
obtain ‚ü®q, hq, hpq‚ü© := exists_mem_factors_of_dvd ha0 hp hd
use q
use hq
apply multiset.mem_pmap.mpr
ghost_fun_tac (X 0 + X 1) ![x.coeff, y.coeff]
ghost_fun_tac (-X 0) ![x.coeff]
refine is_poly.ext ((frobenius_fun_is_poly p).comp (witt_vector.zero_is_poly)) ((witt_vector.zero_is_poly).comp (frobenius_fun_is_poly p)) _ _ 0
ghost_simp
refine is_poly.ext ((frobenius_fun_is_poly p).comp (witt_vector.one_is_poly)) ((witt_vector.one_is_poly).comp (frobenius_fun_is_poly p)) _ _ 0
ghost_simp
ghost_calc _ _
ghost_calc _ _; ghost_simp
ghost_simp
ghost_calc _ _
ghost_calc _ _; ghost_simp
ghost_simp
init_ring using witt_neg_vars
ext ‚ü®‚ü©; { rw zero_coeff, refl }
rw zero_coeff
refl
ext ‚ü®‚ü©
cases n
refl
{ refl }
exact f.map_zero
ext n
refine_struct { to_fun := lift_fun f }; { intros, rw [‚Üê sub_eq_zero, ‚Üê ideal.mem_bot, ‚Üê infi_ker_truncate, ideal.mem_infi], simp [ring_hom.mem_ker, f_compat] }
refine_struct { to_fun := lift_fun f }
intros
rw [‚Üê sub_eq_zero, ‚Üê ideal.mem_bot, ‚Üê infi_ker_truncate, ideal.mem_infi]
simp [ring_hom.mem_ker, f_compat]
exact f.map_zero
refl
ext ‚ü®-, -‚ü©
split
refine ‚ü®f $ sum.inl ‚ü®‚ü©, f $ sum.inr ‚ü®‚ü©, _‚ü©
rintro ‚ü®f‚ü©
intro h
cases f.2 h
{ rintro ‚ü®f‚ü©, refine ‚ü®f $ sum.inl ‚ü®‚ü©, f $ sum.inr ‚ü®‚ü©, _‚ü©, intro h, cases f.2 h }
by_contra h'
rintro ‚ü®x, y, h‚ü©
rw [not_le, ‚Üênat.cast_two, nat_succ, lt_succ, nat.cast_one, le_one_iff_subsingleton] at h'
exactI subsingleton.elim _ _
apply h
rw [‚Üê not_le, succ_le, not_lt]
refine quot.induction_on c (Œª Œ±, _) (lt_succ_self c)
refine quot.induction_on (succ (quot.mk setoid.r Œ±)) (Œª Œ≤ h, _)
cases h.left with f
have : ¬¨ surjective f := Œª hn, ne_of_lt h (quotient.sound ‚ü®equiv.of_bijective f ‚ü®f.injective, hn‚ü©‚ü©)
cases not_forall.1 this with b nex
exact f
refine ‚ü®‚ü®sum.rec (by exact f) _, _‚ü©‚ü©
{ exact Œª _, b }
exact Œª _, b
rcases a with a|‚ü®‚ü®‚ü®‚ü©‚ü©‚ü©
rcases a with a|‚ü®‚ü®‚ü®‚ü©‚ü©‚ü©; rcases b with b|‚ü®‚ü®‚ü®‚ü©‚ü©‚ü©
rcases b with b|‚ü®‚ü®‚ü®‚ü©‚ü©‚ü©
rcases b with b|‚ü®‚ü®‚ü®‚ü©‚ü©‚ü©
intros a b h
{ rw f.injective h }
rw f.injective h
{ exact nex.elim ‚ü®_, h‚ü© }
exact nex.elim ‚ü®_, h‚ü©
{ exact nex.elim ‚ü®_, h.symm‚ü© }
exact nex.elim ‚ü®_, h.symm‚ü©
refl
dsimp [sup]; cases min_eq _ _ with c hc; rw hc; exact c.2 i
dsimp [sup]; cases min_eq _ _ with c hc; rw hc
dsimp [sup]; cases min_eq _ _ with c hc
cases min_eq _ _ with c hc
rw hc
dsimp [sup]
exact c.2 i
have := H i; rwa [‚Üê mk_out (f i), ‚Üê mk_out (g i)] at this
rwa [‚Üê mk_out (f i), ‚Üê mk_out (g i)] at this
have := H i
simpa using prod_ne_zero f
simp
have h : 0 < œâ := nat_lt_omega 0
rw [dif_pos h, ‚Üê cardinal.nat_cast_inj, ‚Üê classical.some_spec (lt_omega.1 h), nat.cast_zero]
split
rw [max_le_iff]
intro h
cases (le_or_lt omega a) with ha ha
rintro rfl
exact not_lt_of_le ha omega_pos
{ rintro rfl, exact not_lt_of_le ha omega_pos }
have : a ‚â† 0
use ha
left
intro hb
apply ne_of_gt _ h
refine lt_of_lt_of_le hb (le_mul_left this)
{ rw [‚Üê not_lt], intro hb, apply ne_of_gt _ h, refine lt_of_lt_of_le hb (le_mul_left this) }
rw [‚Üê not_lt]
apply this
rw [_root_.mul_zero] at h
subst h
{ have : a ‚â† 0, { rintro rfl, exact not_lt_of_le ha omega_pos }, left, use ha, { rw [‚Üê not_lt], intro hb, apply ne_of_gt _ h, refine lt_of_lt_of_le hb (le_mul_left this) }, { rintro rfl, apply this, rw [_root_.mul_zero] at h, subst h }}
rintro rfl
by_cases h2a : a = 0
right
exact h2a
{ right, exact h2a }
right
rintro rfl
apply h2a
rw [mul_zero] at h
have hb : b ‚â† 0
subst h
{ rintro rfl, apply h2a, rw [mul_zero] at h, subst h }
rw [‚Üê h, mul_lt_omega_iff, lt_omega, lt_omega] at ha
left
contradiction
rcases ha with rfl|rfl|‚ü®‚ü®n, rfl‚ü©, ‚ü®m, rfl‚ü©‚ü©
contradiction
rw [‚Üê one_le_iff_ne_zero] at h2a hb
rw [‚Üê ne] at h2a
norm_cast at h2a hb h ‚ä¢
rw [‚Üê not_lt]
intro h2b
apply le_antisymm _ hb
conv_lhs { rw [‚Üê mul_one n] }
rw [‚Üê mul_one n]
apply ne_of_gt _ h
apply nat.lt_of_succ_le h2a
{ intro h, cases (le_or_lt omega a) with ha ha, { have : a ‚â† 0, { rintro rfl, exact not_lt_of_le ha omega_pos }, left, use ha, { rw [‚Üê not_lt], intro hb, apply ne_of_gt _ h, refine lt_of_lt_of_le hb (le_mul_left this) }, { rintro rfl, apply this, rw [_root_.mul_zero] at h, subst h }}, right, by_cases h2a : a = 0, { right, exact h2a }, have hb : b ‚â† 0, { rintro rfl, apply h2a, rw [mul_zero] at h, subst h }, left, rw [‚Üê h, mul_lt_omega_iff, lt_omega, lt_omega] at ha, rcases ha with rfl|rfl|‚ü®‚ü®n, rfl‚ü©, ‚ü®m, rfl‚ü©‚ü©, contradiction, contradiction, rw [‚Üê ne] at h2a, rw [‚Üê one_le_iff_ne_zero] at h2a hb, norm_cast at h2a hb h ‚ä¢, apply le_antisymm _ hb, rw [‚Üê not_lt], intro h2b, apply ne_of_gt _ h, conv_lhs { rw [‚Üê mul_one n] }, rwa [mul_lt_mul_left], apply nat.lt_of_succ_le h2a }
rwa [mul_lt_mul_left]
rintro (‚ü®‚ü®ha, hab‚ü©, hb‚ü©|rfl|rfl)
{ rw [mul_eq_max_of_omega_le_left ha hb, max_eq_left hab] }
rw [mul_eq_max_of_omega_le_left ha hb, max_eq_left hab]
simp
simp
all_goals {simp}
simpa only [nat.cast_bit0, nat.cast_one, mul_eq_self h, two_mul] using mul_le_mul_right' ((nat_lt_omega 2).le.trans h) c
rw [nat.cast_zero, power_zero]
rw [nat.cast_zero, power_zero]; from one_lt_omega
from one_lt_omega
rw [nat.cast_succ, power_add, power_one]
rw [nat.cast_succ, power_add, power_one]; exact mul_le_mul_right' ih _
exact mul_le_mul_right' ih _
simp [bit0, add_lt_omega_iff]
cases y
refl
cases x
fsplit; rintro (‚ü®‚ü®‚ü©,_‚ü© | ‚ü®‚ü®‚ü©,_‚ü©)
rintro (‚ü®‚ü®‚ü©,_‚ü© | ‚ü®‚ü®‚ü©,_‚ü©)
rintro (‚ü®‚ü®‚ü©,_‚ü© | ‚ü®‚ü®‚ü©,_‚ü©)
rintro (‚ü®‚ü®‚ü©,_‚ü© | ‚ü®‚ü®‚ü©,_‚ü©)
rintro (‚ü®‚ü®‚ü©,_‚ü© | ‚ü®‚ü®‚ü©,_‚ü©)
fsplit
fsplit; rintro (‚ü®‚ü®‚ü©,_‚ü© | ‚ü®‚ü®‚ü©,_‚ü©)
rintro (‚ü®‚ü®‚ü©,_‚ü© | ‚ü®‚ü®‚ü©,_‚ü©)
rintro (‚ü®‚ü®‚ü©,_‚ü© | ‚ü®‚ü®‚ü©,_‚ü©)
rintro (‚ü®‚ü®‚ü©,_‚ü© | ‚ü®‚ü®‚ü©,_‚ü©)
rintro (‚ü®‚ü®‚ü©,_‚ü© | ‚ü®‚ü®‚ü©,_‚ü©)
fsplit
rintro (‚ü®‚ü®‚ü©,_‚ü© | ‚ü®‚ü®‚ü©,_‚ü©)
rintro ‚ü®‚ü©
split
intro hi
unfold1 impartial_aux at hi
{ intro hi, unfold1 impartial_aux at hi, exact hi }
exact hi
intro hi
unfold1 impartial_aux
dsimp
simp
rw impartial_def
apply L
casesI S with _ _ _ _ L _ _ _
apply fintype.of_equiv _ (left_moves_of_aux _ _).symm
apply_instance
have i := (left_moves_of_aux _ _).to_fun i
exfalso
exact turn_bound_ne_zero_of_left_move i.2 (nonpos_iff_eq_zero.mp h)
have j := (right_moves_of_aux _ _).to_fun j
exfalso
exact turn_bound_ne_zero_of_right_move j.2 (nonpos_iff_eq_zero.mp h)
rw ‚Üê of_to_list l‚ÇÅ
induction to_list l‚ÇÅ
induction to_list l‚ÇÅ; intro
intro
intro
revert H
{ exact subset.nil }
exact subset.nil
exact cons_subset.2 ‚ü®H.1, ih H.2‚ü©
simp at H
exact omin_mem _ hs
rw Inf_eq_omin hs
rw subsingleton.elim f (principal_seg.equiv_lt e g)
rw subsingleton.elim f (principal_seg.equiv_lt e g); refl
refl
induction n with n IH; [simp only [nat.cast_zero, nat.mul_zero, mul_zero], rw [nat.mul_succ, nat.cast_add, IH, nat.cast_succ, mul_add_one]]
simp only [nat.cast_zero, nat.mul_zero, mul_zero]
induction n with n IH
rw [nat.mul_succ, nat.cast_add, IH, nat.cast_succ, mul_add_one]
simp only [mul_add, mul_one]
rw [sup_le, comp, H.le_set' (Œª_:Œπ, true) g (let ‚ü®i‚ü© := h in ‚ü®i, ‚ü®‚ü©‚ü©)]
rw [sup_le, comp, H.le_set' (Œª_:Œπ, true) g (let ‚ü®i‚ü© := h in ‚ü®i, ‚ü®‚ü©‚ü©)]; intros; simp only [sup_le, true_implies_iff]
rw [sup_le, comp, H.le_set' (Œª_:Œπ, true) g (let ‚ü®i‚ü© := h in ‚ü®i, ‚ü®‚ü©‚ü©)]; intros
simp only [sup_le, true_implies_iff]
simp only [sup_le, true_implies_iff]
intros
intros
induction h with _ e n a eb b h‚ÇÅ h‚ÇÇ h‚ÇÉ _ IH
{ exact power_pos _ omega_pos }
exact power_pos _ omega_pos
rw repr
refine lt_of_lt_of_le ((ordinal.add_lt_add_iff_left _).2 IH) _
rw ‚Üê mul_succ
refine le_trans (mul_le_mul_left _ $ ordinal.succ_le.2 $ nat_lt_omega _) _
rw ‚Üê power_succ
exact power_le_power_right omega_pos (ordinal.succ_le.2 h‚ÇÉ)
cases k
cases k; exact NF.zero
exact NF.zero
exact NF.zero
haveI := NF_power_aux k
haveI := NF_power_aux k; simp [power_aux, nat.succ_ne_zero]; apply_instance
haveI := NF_power_aux k; simp [power_aux, nat.succ_ne_zero]
apply_instance
simp [power_aux, nat.succ_ne_zero]
cases m
cases m; simp [power_aux]
simp [power_aux]
simp [power_aux]
by_cases m = 0
by_cases m = 0; simp [h, power_aux, ordinal.mul_add, power_add, mul_assoc, scale_power_aux]
simp [h, power_aux, ordinal.mul_add, power_add, mul_assoc, scale_power_aux]
simp [h, power_aux, ordinal.mul_add, power_add, mul_assoc, scale_power_aux]
rw mk_le_mk
rw mk_le_mk; exact ‚ü®Œª i, lt_mk_of_le (le_refl _), Œª i, mk_lt_of_le (le_refl _)‚ü©
exact ‚ü®Œª i, lt_mk_of_le (le_refl _), Œª i, mk_lt_of_le (le_refl _)‚ü©
cases x with xl xr xL xR
exact o.2.2 j
intros z h‚ÇÄ h‚ÇÅ
simp only [and_imp, set.mem_Icc]
replace h‚ÇÄ := bitvec.of_fin_le_of_fin_of_le h‚ÇÄ
replace h‚ÇÅ := bitvec.of_fin_le_of_fin_of_le h‚ÇÅ
split
rw bitvec.of_fin_to_fin at h‚ÇÄ h‚ÇÅ
split; assumption
assumption
assumption
simp [prl, prr, prt]
cases x
cases y
refl
cases x
cases y
simp *
rw normalize_fin
norm_num
simpa [normalize_fin_lt, ‚Üê e] using h
rw [‚Üê h‚ÇÅ, int.dvd_iff_mod_eq_zero]
rwa [‚Üê h‚ÇÅ, ‚Üê mul_assoc, div_mul_cancel _ h‚ÇÄ]
rw [prl, prr, prt]
unfold val
apply fun_mono_2
apply fun_mono_2; apply val_between_eq_of_le; rw [zero_add, length_add]
apply fun_mono_2; apply val_between_eq_of_le
rw val_between_add
apply val_between_eq_of_le
apply val_between_eq_of_le
rw [zero_add, length_add]
rw [zero_add, length_add]
apply le_max_right
apply le_max_left
apply h1
rw (nat.sub_eq_zero_iff_le.elim_right _)
cases h1
rw le_iff_eq_or_lt at h1
{ rw [h1, add_comm l, nat.add_sub_cancel] }
rw [h1, add_comm l, nat.add_sub_cancel]
have h2 : list.length as ‚â§ l + m
apply h1
{ rw ‚Üê nat.lt_succ_iff, apply h1 }
rw ‚Üê nat.lt_succ_iff
simpa [ get_eq_default_of_le _ h2, zero_mul, add_zero, val_between ] using val_between_eq_of_le _ h2
intro h1
unfold symmod
rw [int.mod_eq_of_lt (le_of_lt h1) (lt_add_one _), if_neg]
simp only [add_comm, add_neg_cancel_left, neg_add_rev, sub_eq_add_neg]
have h2 : 2 * i = (1 + 1) * i := rfl
simpa only [h2, add_mul, one_mul, add_lt_add_iff_left, not_lt] using h1
haveI := has_reflect; exact list.reflect l
exact list.reflect l
haveI := has_reflect
haveI := has_reflect; exact list.reflect l
exact list.reflect l
haveI := has_reflect
rw [‚Üê H, ‚Üê h‚ÇÇ, ‚Üê h‚ÇÅ, ‚Üê h‚ÇÉ, ‚Üê h‚ÇÑ]; simp [horner, mul_add, mul_comm, mul_left_comm, mul_assoc]
rw [‚Üê H, ‚Üê h‚ÇÇ, ‚Üê h‚ÇÅ, ‚Üê h‚ÇÉ, ‚Üê h‚ÇÑ]
simp [horner, mul_add, mul_comm, mul_left_comm, mul_assoc]
simp [horner, mul_comm]
rw [ps_pf, qs_pf]
rw [pps_pf]
rw [psqs_pf]
induction xs
{ apply h }
apply h
unfold_wf
simp only [list.sizeof, add_lt_add_iff_left]
exact xs_ih
linarith
rcases hs with ‚ü®S, Sopen, Scount, rfl‚ü©
rcases ht with ‚ü®T, Topen, Tcount, rfl‚ü©
rw [sInter_union_sInter]
apply is_GŒ¥_bInter_of_open (Scount.prod Tcount)
rintros ‚ü®a, b‚ü© hab
exact is_open.union (Sopen a hab.1) (Topen b hab.2)
rw [dense_range, ‚Üê compl_infty]
exact dense_compl_singleton _
rw [continuous_at, nhds_eq, nhds_eq, tendsto_map'_iff]
suffices : tendsto ((Œªx:G, x - a) ‚àò (Œªx:G, -x)) (Z G) (map (Œªx:G, x - a) (Z G))
{ simpa [(‚àò), add_comm, sub_eq_add_neg] using this }
simpa [(‚àò), add_comm, sub_eq_add_neg] using this
exact tendsto_map.comp neg_Z
simpa [(hf'.has_sum.sigma hf).unique ha] using hf'.has_sum
by_cases hP : P; simp [hP]
simp [hP]
simp [hP]
by_cases hP : P
convert hf.update b 0 using 1
rw function.update_apply
{ ext n, rw function.update_apply, }
ext n
rw [sub_add_eq_add_sub, zero_add]
rw [‚Üêhas_sum_zero_iff, hf.has_sum_iff]
simp
ext
exact forall_swap
simp only [ext_iff, pi_apply, function.funext_iff]
exact one_smul _ _
norm_num
norm_num
have := @tfae_mem_nhds_within_Ici (order_dual Œ±) _ _ _ _ _ h s
simp only [exists_prop] at this ‚ä¢
rw [dual_Icc, dual_Ioc, dual_Ioi] at this
convert this; ext l; rw [dual_Ico]
convert this; ext l
ext l
ext l
ext l
rw [dual_Ico]
rw [dual_Ico]
rw [dual_Ico]
convert this
refine tendsto_at_top_mono' _ _ (hf.at_top_mul_const (half_pos hC))
filter_upwards [hg.eventually (lt_mem_nhds (half_lt_self hC)), hf.eventually (eventually_ge_at_top 0)]
exact Œª x hg hf, mul_le_mul_of_nonneg_left hg.le hf
simpa only [mul_comm] using hg.at_bot_mul hC hf
refine ‚ü®Œª h, _, Œª h, _‚ü©
by_cases hn : 0 ‚â§ n
lift n to ‚Ñï using hn
simp only [gpow_coe_nat] at h
rw [tendsto_const_mul_pow_nhds_iff hc, ‚Üê int.coe_nat_eq_zero] at h
{ lift n to ‚Ñï using hn, simp only [gpow_coe_nat] at h, rw [tendsto_const_mul_pow_nhds_iff hc, ‚Üê int.coe_nat_eq_zero] at h, exact or.inl h }
exact or.inl h
rw not_le at hn
refine or.inr ‚ü®hn, tendsto_nhds_unique h (tendsto_const_mul_fpow_at_top_zero hn)‚ü©
{ by_cases hn : 0 ‚â§ n, { lift n to ‚Ñï using hn, simp only [gpow_coe_nat] at h, rw [tendsto_const_mul_pow_nhds_iff hc, ‚Üê int.coe_nat_eq_zero] at h, exact or.inl h }, { rw not_le at hn, refine or.inr ‚ü®hn, tendsto_nhds_unique h (tendsto_const_mul_fpow_at_top_zero hn)‚ü© } }
cases h
simp only [h.left, h.right, gpow_zero, mul_one]
{ simp only [h.left, h.right, gpow_zero, mul_one], exact tendsto_const_nhds }
exact tendsto_const_nhds
exact h.2.symm ‚ñ∏ tendsto_const_mul_fpow_at_top_zero h.1
simp [frontier, h, le_of_lt h, Icc_diff_Ioo_same]
simp [frontier, h, le_of_lt h, Icc_diff_Ioo_same]
rw [‚Üê map_coe_Iio_at_top, tendsto_map'_iff]
apply extend_from_eq
rw closure_Ioo hab
{ rw closure_Ioo hab, simp only [le_of_lt hab, left_mem_Icc, right_mem_Icc] }
simp only [le_of_lt hab, left_mem_Icc, right_mem_Icc]
simpa [hab]
exact hf.open_subset_closure_inter hs
rw image_preimage_eq_inter_range
exact is_open_empty
rw [‚Üê is_open_compl_iff, compl_univ]
rw subset.antisymm subset_closure h; exact is_closed_closure
exact is_closed_closure
rw subset.antisymm subset_closure h
rwa compl_compl
rw [frontier, hs.interior_eq]
simp only [le_principal_iff]
simp [closure_eq_cluster_pts, cluster_pt, ‚Üê exists_ultrafilter_iff, and.comm]
continuity
rw [nhds_within, principal_singleton, inf_eq_right.2 (pure_le_nhds a)]
rw [continuous_within_at, function.update_same]
rw [mem_set_of_eq, function.update_noteq hz.2]
rw [di.nhds_eq_comap a, ((nhds_basis_opens _).comap _).mem_iff] at hs
rcases hs with ‚ü®U, ‚ü®haU, hUo‚ü©, sub : i ‚Åª¬π' U ‚äÜ s‚ü©
refine mem_of_superset (hUo.mem_nhds haU) _
calc U ‚äÜ closure (i '' (i ‚Åª¬π' U)) : di.dense.subset_closure_image_preimage_of_is_open hUo ... ‚äÜ closure (i '' s) : closure_mono (image_subset i sub)
have cond : is_compact (‚ä§ : set X) := compact_univ
rw is_compact_iff_finite_subcover at cond
have h := @cond S (Œª s, S.proj ‚Åª¬π' {s}) (Œª s, fiber_open _ _) (Œª x hx, ‚ü®S.proj ‚Åª¬π' {S.proj x}, ‚ü®S.proj x, rfl‚ü©, rfl‚ü©)
let T := classical.some h
have hT := classical.some_spec h
refine ‚ü®T,Œª s, _‚ü©
rcases S.proj_surjective s with ‚ü®x,rfl‚ü©
tauto
rcases hT (by tauto : x ‚àà ‚ä§) with ‚ü®j, ‚ü®j,rfl‚ü©, h1, ‚ü®hj, rfl‚ü©, h2‚ü©
dsimp only at h2
rwa this
suffices : S.proj x = j
rcases j with ‚ü®j‚ü©
apply quotient.sound'
erw fiber_eq at h2
exact S.symm _ _ h2
ext
refl
letI := a.total_space_topology
refine continuous_on_iff'.mpr (Œª s hs, ‚ü®(a.pretrivialization_at x) ‚Åª¬π' s ‚à© (a.pretrivialization_at x).source, (is_open_supr_iff.mpr (Œª y, _)), by { rw [inter_assoc, inter_self], refl }‚ü©)
rw [inter_assoc, inter_self]
refl
rw [is_open_coinduced, is_open_induced_iff]
obtain ‚ü®u, hu1, hu2‚ü© := continuous_on_iff'.mp (a.continuous_triv_change x y) s hs
have hu3 := congr_arg (Œª s, (Œª x : (a.pretrivialization_at y).target, (x : B √ó F)) ‚Åª¬π' s) hu2
simp only [subtype.coe_preimage_self, preimage_inter, univ_inter] at hu3
refine ‚ü®u ‚à© (a.pretrivialization_at y).to_local_equiv.target ‚à© ((a.pretrivialization_at y).to_local_equiv.symm ‚Åª¬π' (a.pretrivialization_at x).source), _, by { simp only [preimage_inter, inter_univ, subtype.coe_preimage_self, hu3.symm], refl }‚ü©
refl
simp only [preimage_inter, inter_univ, subtype.coe_preimage_self, hu3.symm]
rw inter_assoc
exact hu1.inter (a.is_open_target_pretrivialization_at_inter x y)
lift f to Œ≤ ‚Üí ‚Ñù‚â•0 using Œª b, (hg b).trans (hgf b)
lift g to Œ≤ ‚Üí ‚Ñù‚â•0 using hg
rw nnreal.summable_coe at hf ‚ä¢
exact nnreal.summable_of_le (Œª b, nnreal.coe_le_coe.1 (hgf b)) hf
simp only [continuous_at, tendsto_nhds_top_iff_real, top_add, nhds_prod_eq]
assume r
rw eventually_prod_iff
refine ‚ü®Œª z, (r : ereal) < z, Ioi_mem_nhds (coe_lt_top _), Œª z, ((0 : ‚Ñù) : ereal) < z, Ioi_mem_nhds (by simp [zero_lt_one]), Œª x hx y hy, _‚ü©
simp [zero_lt_one]
dsimp
convert add_lt_add hx hy
simp
lift f to Œ± ‚Üí ‚Ñù‚â•0 using hf‚ÇÅ with f rfl hf‚ÇÅ
simp only [summable_coe, subtype.coe_eta]
simp only [coe_tsum, nnreal.coe_mul, tsum_mul_left]
have := totally_bounded_preimage uniform_embedding_of_rat (totally_bounded_Icc a b)
rwa (set.ext (Œª q, _) : Icc _ _ = _)
simp
refine (real.image_interval_eq_Icc h).trans (interval_of_le _).symm
rw [real.image_interval_eq_Icc h]
exact real.Inf_le_Sup _ bdd_below_Icc bdd_above_Icc
subst f
refl
rw [comap, dif_pos hf]
ext x
ext x; simp [mem_image_iff_of_inverse r_inv l_inv]
simp [mem_image_iff_of_inverse r_inv l_inv]
convert ‚Üê h.preimage hf.to_embedding.continuous
apply preimage_image_eq _ hf.inj
convert ‚Üêhf.closed_iff_image_closed.symm
rwa [image_preimage_eq_inter_range, inter_eq_self_of_subset_left]
rw [diam, ediam_of_unbounded h, ennreal.top_to_real]
cases max_le_iff.1 (le_of_eq h) with h‚ÇÅ h‚ÇÇ
exact prod.ext_iff.2 ‚ü®dist_le_zero.1 h‚ÇÅ, dist_le_zero.1 h‚ÇÇ‚ü©
rw [‚Üê not_nonempty_iff_eq_empty, nonempty_ball, not_lt]
simp
convert metric.emetric_ball
refine complete_of_convergent_controlled_sequences B B_pos (Œªs hs, _)
let t0 := ‚ãÇn, closure (‚ãÉm‚â•n, (s m).val)
let t : closeds Œ± := ‚ü®t0, is_closed_Inter (Œª_, is_closed_closure)‚ü©
use t
have I1 : ‚àÄn:‚Ñï, ‚àÄx ‚àà (s n).val, ‚àÉy ‚àà t0, edist x y ‚â§ 2 * B n
assume n x hx
obtain ‚ü®z, hz‚ÇÄ, hz‚ü© : ‚àÉ z : Œ† l, (s (n+l)).val, (z 0:Œ±) = x ‚àß ‚àÄ k, edist (z k:Œ±) (z (k+1):Œ±) ‚â§ B n / 2^k
have : ‚àÄ (l : ‚Ñï) (z : (s (n+l)).val), ‚àÉ z' : (s (n+l+1)).val, edist (z:Œ±) z' ‚â§ B n / 2^l
assume l z
obtain ‚ü®z', z'_mem, hz'‚ü© : ‚àÉ z' ‚àà (s (n+l+1)).val, edist (z:Œ±) z' < B n / 2^l
apply exists_edist_lt_of_Hausdorff_edist_lt z.2
simp only [B, ennreal.inv_pow, div_eq_mul_inv]
rw [‚Üê pow_add]
apply hs
apply hs; simp
simp
simp
{ apply exists_edist_lt_of_Hausdorff_edist_lt z.2, simp only [B, ennreal.inv_pow, div_eq_mul_inv], rw [‚Üê pow_add], apply hs; simp }
{ assume l z, obtain ‚ü®z', z'_mem, hz'‚ü© : ‚àÉ z' ‚àà (s (n+l+1)).val, edist (z:Œ±) z' < B n / 2^l, { apply exists_edist_lt_of_Hausdorff_edist_lt z.2, simp only [B, ennreal.inv_pow, div_eq_mul_inv], rw [‚Üê pow_add], apply hs; simp }, exact ‚ü®‚ü®z', z'_mem‚ü©, le_of_lt hz'‚ü© }
exact ‚ü®‚ü®z', z'_mem‚ü©, le_of_lt hz'‚ü©
use [Œª k, nat.rec_on k ‚ü®x, hx‚ü© (Œªl z, some (this l z)), rfl]
{ have : ‚àÄ (l : ‚Ñï) (z : (s (n+l)).val), ‚àÉ z' : (s (n+l+1)).val, edist (z:Œ±) z' ‚â§ B n / 2^l, { assume l z, obtain ‚ü®z', z'_mem, hz'‚ü© : ‚àÉ z' ‚àà (s (n+l+1)).val, edist (z:Œ±) z' < B n / 2^l, { apply exists_edist_lt_of_Hausdorff_edist_lt z.2, simp only [B, ennreal.inv_pow, div_eq_mul_inv], rw [‚Üê pow_add], apply hs; simp }, exact ‚ü®‚ü®z', z'_mem‚ü©, le_of_lt hz'‚ü© }, use [Œª k, nat.rec_on k ‚ü®x, hx‚ü© (Œªl z, some (this l z)), rfl], exact Œª k, some_spec (this k _) }
exact Œª k, some_spec (this k _)
have : cauchy_seq (Œª k, ((z k):Œ±))
from cauchy_seq_of_edist_le_geometric_two (B n) (B_ne_top n) hz
rcases cauchy_seq_tendsto_of_complete this with ‚ü®y, y_lim‚ü©
use y
have : y ‚àà t0 := mem_Inter.2 (Œªk, mem_closure_of_tendsto y_lim begin simp only [exists_prop, set.mem_Union, filter.eventually_at_top, set.mem_preimage, set.preimage_Union], exact ‚ü®k, Œª m hm, ‚ü®n+m, zero_add k ‚ñ∏ add_le_add (zero_le n) hm, (z m).2‚ü©‚ü© end)
simp only [exists_prop, set.mem_Union, filter.eventually_at_top, set.mem_preimage, set.preimage_Union]
exact ‚ü®k, Œª m hm, ‚ü®n+m, zero_add k ‚ñ∏ add_le_add (zero_le n) hm, (z m).2‚ü©‚ü©
use this
rw [‚Üê hz‚ÇÄ]
exact edist_le_of_edist_le_geometric_two_of_tendsto‚ÇÄ (B n) hz y_lim
{ assume n x hx, obtain ‚ü®z, hz‚ÇÄ, hz‚ü© : ‚àÉ z : Œ† l, (s (n+l)).val, (z 0:Œ±) = x ‚àß ‚àÄ k, edist (z k:Œ±) (z (k+1):Œ±) ‚â§ B n / 2^k, { have : ‚àÄ (l : ‚Ñï) (z : (s (n+l)).val), ‚àÉ z' : (s (n+l+1)).val, edist (z:Œ±) z' ‚â§ B n / 2^l, { assume l z, obtain ‚ü®z', z'_mem, hz'‚ü© : ‚àÉ z' ‚àà (s (n+l+1)).val, edist (z:Œ±) z' < B n / 2^l, { apply exists_edist_lt_of_Hausdorff_edist_lt z.2, simp only [B, ennreal.inv_pow, div_eq_mul_inv], rw [‚Üê pow_add], apply hs; simp }, exact ‚ü®‚ü®z', z'_mem‚ü©, le_of_lt hz'‚ü© }, use [Œª k, nat.rec_on k ‚ü®x, hx‚ü© (Œªl z, some (this l z)), rfl], exact Œª k, some_spec (this k _) }, have : cauchy_seq (Œª k, ((z k):Œ±)), from cauchy_seq_of_edist_le_geometric_two (B n) (B_ne_top n) hz, rcases cauchy_seq_tendsto_of_complete this with ‚ü®y, y_lim‚ü©, use y, have : y ‚àà t0 := mem_Inter.2 (Œªk, mem_closure_of_tendsto y_lim begin simp only [exists_prop, set.mem_Union, filter.eventually_at_top, set.mem_preimage, set.preimage_Union], exact ‚ü®k, Œª m hm, ‚ü®n+m, zero_add k ‚ñ∏ add_le_add (zero_le n) hm, (z m).2‚ü©‚ü© end), use this, rw [‚Üê hz‚ÇÄ], exact edist_le_of_edist_le_geometric_two_of_tendsto‚ÇÄ (B n) hz y_lim }
have I2 : ‚àÄn:‚Ñï, ‚àÄx ‚àà t0, ‚àÉy ‚àà (s n).val, edist x y ‚â§ 2 * B n
assume n x xt0
apply mem_Inter.1 xt0 n
have : x ‚àà closure (‚ãÉm‚â•n, (s m).val)
rcases mem_closure_iff.1 this (B n) (B_pos n) with ‚ü®z, hz, Dxz‚ü©
simp only [exists_prop, set.mem_Union] at hz
rcases hz with ‚ü®m, ‚ü®m_ge_n, hm‚ü©‚ü©
have : Hausdorff_edist (s m).val (s n).val < B n := hs n m n m_ge_n (le_refl n)
rcases exists_edist_lt_of_Hausdorff_edist_lt hm this with ‚ü®y, hy, Dzy‚ü©
exact ‚ü®y, hy, calc edist x y ‚â§ edist x z + edist z y : edist_triangle _ _ _ ... ‚â§ B n + B n : add_le_add (le_of_lt Dxz) (le_of_lt Dzy) ... = 2 * B n : (two_mul _).symm ‚ü©
{ assume n x xt0, have : x ‚àà closure (‚ãÉm‚â•n, (s m).val), by apply mem_Inter.1 xt0 n, rcases mem_closure_iff.1 this (B n) (B_pos n) with ‚ü®z, hz, Dxz‚ü©, simp only [exists_prop, set.mem_Union] at hz, rcases hz with ‚ü®m, ‚ü®m_ge_n, hm‚ü©‚ü©, have : Hausdorff_edist (s m).val (s n).val < B n := hs n m n m_ge_n (le_refl n), rcases exists_edist_lt_of_Hausdorff_edist_lt hm this with ‚ü®y, hy, Dzy‚ü©, exact ‚ü®y, hy, calc edist x y ‚â§ edist x z + edist z y : edist_triangle _ _ _ ... ‚â§ B n + B n : add_le_add (le_of_lt Dxz) (le_of_lt Dzy) ... = 2 * B n : (two_mul _).symm ‚ü© }
have main : ‚àÄn:‚Ñï, edist (s n) t ‚â§ 2 * B n := Œªn, Hausdorff_edist_le_of_mem_edist (I1 n) (I2 n)
refine tendsto_at_top.2 (ŒªŒµ Œµpos, _)
have : tendsto (Œªn, 2 * B n) at_top (ùìù (2 * 0))
from ennreal.tendsto.const_mul (ennreal.tendsto_pow_at_top_nhds_0_of_lt_1 $ by simp [ennreal.one_lt_two]) (or.inr $ by simp)
simp [ennreal.one_lt_two]
simp
rw mul_zero at this
obtain ‚ü®N, hN‚ü© : ‚àÉ N, ‚àÄ b ‚â• N, Œµ > 2 * B b
from ((tendsto_order.1 this).2 Œµ Œµpos).exists_forall_of_at_top
exact ‚ü®N, Œªn hn, lt_of_le_of_lt (main n) (hN n hn)‚ü©
let B : ‚Ñï ‚Üí ‚Ñù‚â•0‚àû := Œª n, (2‚Åª¬π)^n
have B_pos : ‚àÄ n, (0:‚Ñù‚â•0‚àû) < B n
simp [B, ennreal.pow_pos]
have B_ne_top : ‚àÄ n, B n ‚â† ‚ä§
simp [B, ennreal.pow_ne_top]
refine or_iff_not_imp_right.2 (Œª h, edist_le_zero.1 _)
simpa only [hx.eq, edist_self, add_zero, ennreal.zero_div] using hf.edist_le_of_fixed_point h hy
refine ‚ü®Œª H Œµ hŒµ, H _ (edist_mem_uniformity hŒµ), Œª H u hu x hx, _‚ü©
rcases mem_uniformity_edist.1 hu with ‚ü®Œµ, Œµpos, hŒµ‚ü©
rcases H Œµ Œµpos x hx with ‚ü®t, ht, Ht‚ü©
exact ‚ü®t, ht, Ht.mono (Œª n hs x hx, hŒµ (hs x hx))‚ü©
exactI second_countable_of_separable Œ±
suffices : separable_space Œ±
rcases subset_countable_closure_of_almost_dense_set (univ : set Œ±) (Œª Œµ Œµ0, _) with ‚ü®t, -, htc, ht‚ü©
{ exact ‚ü®‚ü®t, htc, Œª x, ht (mem_univ x)‚ü©‚ü© }
exact ‚ü®‚ü®t, htc, Œª x, ht (mem_univ x)‚ü©‚ü©
rcases hs Œµ Œµ0 with ‚ü®t, htc, ht‚ü©
exact ‚ü®t, htc, univ_subset_iff.2 ht‚ü©
letI : pseudo_metric_space (X ‚äï Y) := glue_premetric hŒ¶ hŒ®
letI : pseudo_metric_space (X ‚äï Y) := glue_premetric hŒ¶ hŒ®; exact ‚ü¶inr y‚üß
exact ‚ü¶inr y‚üß
rw ‚Üê image_univ
refine dimH_image_le_of_locally_lipschitz_on (Œª x _, _)
simpa only [exists_prop, nhds_within_univ] using hf x
rw [‚Üê e.dimH_preimage univ, preimage_univ]
simp only [Hausdorff_edist, sup_le_iff, supr_le_iff]
exact ‚ü®H1, H2‚ü©
have ht : t.nonempty := hs.mono h
rw [inf_dist, inf_dist, ennreal.to_real_le_to_real (inf_edist_ne_top ht) (inf_edist_ne_top hs)]
exact inf_edist_le_inf_edist_of_subset h
simp [inf_dist, inf_edist_image hŒ¶]
rcases empty_or_nonempty_of_Hausdorff_edist_ne_top fin with ‚ü®hs,ht‚ü©|‚ü®hs,ht‚ü©
simp only [hs, ht, Hausdorff_dist_empty, inf_dist_empty, zero_add]
{ simp only [hs, ht, Hausdorff_dist_empty, inf_dist_empty, zero_add] }
rw [inf_dist, inf_dist, Hausdorff_dist, ‚Üê ennreal.to_real_add (inf_edist_ne_top hs) fin, ennreal.to_real_le_to_real (inf_edist_ne_top ht)]
{ exact inf_edist_le_inf_edist_add_Hausdorff_edist }
exact inf_edist_le_inf_edist_add_Hausdorff_edist
exact ennreal.add_ne_top.2 ‚ü®inf_edist_ne_top hs, fin‚ü©
intros x hx y hy
rw [ennreal.coe_mul, mul_comm rg, nnreal.coe_mul, ennreal.rpow_mul, mul_assoc, ‚Üê ennreal.coe_rpow_of_nonneg _ rg.coe_nonneg, ‚Üê ennreal.mul_rpow_of_nonneg _ _ rg.coe_nonneg]
exact hg.edist_le_of_le (hst hx) (hst hy) (hf.edist_le hx hy)
rwa [set.image_univ, isometric.range_eq_univ, ‚Üê complete_space_iff_is_complete_univ]
rw subsingleton.elim x y
rw subsingleton.elim x y; simp
simp
simp only [edist_self, zero_le]
rw [‚Üê mul_assoc, ennreal.coe_mul]
assume x y
rw [ennreal.coe_mono.map_max, prod.edist_eq, ennreal.max_mul]
exact max_le_max (hf x y) (hg x y)
rcases ‚ü®h, h'‚ü© with ‚ü®‚ü®r, r0, hr‚ü©, ‚ü®r', r0', hr'‚ü©‚ü©
refine ‚ü®min r r', _, Œª x hx y hy, hx.elim _ _‚ü©
rw [‚Üê pos_iff_ne_zero] at r0 r0' ‚ä¢
{ rw [‚Üê pos_iff_ne_zero] at r0 r0' ‚ä¢, exact lt_min r0 r0' }
exact lt_min r0 r0'
{ exact Œª hx, (min_le_left _ _).trans (hr _ hx _ hy) }
exact Œª hx, (min_le_left _ _).trans (hr _ hx _ hy)
exact Œª hx, (min_le_right _ _).trans (hr' _ hx _ hy)
simpa only [@comm _ _ s] using finite_Union_left_iff hI
rw induced_generate_from_eq
apply le_generate_from
simp only [mem_image, and_imp, forall_apply_eq_imp_iff‚ÇÇ, exists_imp_distrib]
exact h
simp only [mem_nhds_iff, is_open_induced_iff, exists_prop, set.mem_set_of_eq]
split
rintros ‚ü®u, usub, ‚ü®v, openv, ueq‚ü©, au‚ü©
rwa ‚Üêueq at au
exact ‚ü®v, ‚ü®v, set.subset.refl v, openv, by rwa ‚Üêueq at au‚ü©, by rw ueq; exact usub‚ü©
rw ueq
rw ueq; exact usub
exact usub
{ rintros ‚ü®u, usub, ‚ü®v, openv, ueq‚ü©, au‚ü©, exact ‚ü®v, ‚ü®v, set.subset.refl v, openv, by rwa ‚Üêueq at au‚ü©, by rw ueq; exact usub‚ü© }
rintros ‚ü®u, ‚ü®v, vsubu, openv, amem‚ü©, finvsub‚ü©
exact ‚ü®f ‚Åª¬π' v, set.subset.trans (set.preimage_mono vsubu) finvsub, ‚ü®‚ü®v, openv, rfl‚ü©, amem‚ü©‚ü©
rw min_eq_left h
split
introI h
{ introI h, apply_instance }
apply_instance
introI hX
inhabit X
let x‚ÇÄ := default X
rw path_connected_space_iff_eq
use x‚ÇÄ
simp
refine eq_univ_of_nonempty_clopen (by simp) ‚ü®_, _‚ü©
rw is_open_iff_mem_nhds
intros y y_in
rcases (path_connected_basis y).ex_mem with ‚ü®U, ‚ü®U_in, hU‚ü©‚ü©
apply mem_of_superset U_in
rw ‚Üê path_component_congr y_in
{ rw is_open_iff_mem_nhds, intros y y_in, rcases (path_connected_basis y).ex_mem with ‚ü®U, ‚ü®U_in, hU‚ü©‚ü©, apply mem_of_superset U_in, rw ‚Üê path_component_congr y_in, exact hU.subset_path_component (mem_of_mem_nhds U_in) }
exact hU.subset_path_component (mem_of_mem_nhds U_in)
rw is_closed_iff_nhds
intros y H
rcases (path_connected_basis y).ex_mem with ‚ü®U, ‚ü®U_in, hU‚ü©‚ü©
rcases H U U_in with ‚ü®z, hz, hz'‚ü©
exact ((hU.joined_in z y hz $ mem_of_mem_nhds U_in).joined.mem_path_component hz')
simp only [‚Üê lower_semicontinuous_within_at_univ_iff] at hf ‚ä¢
exact hg.comp_lower_semicontinuous_within_at hf gmon
simp [upper_semicontinuous_on, upper_semicontinuous, upper_semicontinuous_within_at_univ_iff]
rwa [mem_compl_eq, mem_singleton_iff]
rw is_open_iff_ultrafilter
refine ‚ü®Œª h F hF, h F.Lim hF F F.le_nhds_Lim, _‚ü©
intros cond x hx f h
rw [‚Üê (ultrafilter.Lim_eq_iff_le_nhds.2 h)] at hx
exact cond _ hx
apply equiv_of_subsingleton_of_subsingleton
intros S Œπ U
have t‚ÇÅ := S U
have t‚ÇÇ := @preserves_limit.preserves _ _ _ _ _ _ _ G _ _ t‚ÇÅ
have t‚ÇÉ := is_limit.of_iso_limit t‚ÇÇ (map_cone_fork G F U)
have t‚ÇÑ := is_limit.postcompose_inv_equiv _ _ t‚ÇÉ
{ intros S Œπ U, have t‚ÇÅ := S U, have t‚ÇÇ := @preserves_limit.preserves _ _ _ _ _ _ _ G _ _ t‚ÇÅ, have t‚ÇÉ := is_limit.of_iso_limit t‚ÇÇ (map_cone_fork G F U), have t‚ÇÑ := is_limit.postcompose_inv_equiv _ _ t‚ÇÉ, exact t‚ÇÑ, }
exact t‚ÇÑ
intros S Œπ U
let f := equalizer.lift _ (w F U)
suffices : is_iso (G.map f)
resetI
haveI : is_iso f := is_iso_of_reflects_iso f G
apply is_limit.of_iso_limit (limit.is_limit _)
apply iso.symm
fapply cones.ext
exact (as_iso f)
rintro ‚ü®_|_‚ü©; { dsimp [f], simp, }
dsimp [f]
simp
{ resetI, haveI : is_iso f := is_iso_of_reflects_iso f G, apply is_limit.of_iso_limit (limit.is_limit _), apply iso.symm, fapply cones.ext, exact (as_iso f), rintro ‚ü®_|_‚ü©; { dsimp [f], simp, }, }
rintro ‚ü®_|_‚ü©
let c := fork (F ‚ãô G) U
have hc : is_limit c := S U
let d := G.map_cone (equalizer.fork (left_res F U) (right_res F U))
have hd : is_limit d := preserves_limit.preserves (limit.is_limit _)
let d' := (cones.postcompose (diagram_comp_preserves_limits G F U).hom).obj d
have hd' : is_limit d' := (is_limit.postcompose_hom_equiv (diagram_comp_preserves_limits G F U) d).symm hd
let f' : c ‚ü∂ d' := fork.mk_hom (G.map f) begin dsimp only [c, d, d', f, diagram_comp_preserves_limits, res], dunfold fork.Œπ, ext1 j, dsimp, simp only [category.assoc, ‚Üêfunctor.map_comp_assoc, equalizer.lift_Œπ, map_lift_pi_comparison_assoc], dsimp [res], simp, end
dsimp only [c, d, d', f, diagram_comp_preserves_limits, res]
dunfold fork.Œπ
ext1 j
dsimp
simp only [category.assoc, ‚Üêfunctor.map_comp_assoc, equalizer.lift_Œπ, map_lift_pi_comparison_assoc]
simp
dsimp [res]
haveI : is_iso f' := is_limit.hom_is_iso hc hd' f'
exact is_iso.of_iso ((cones.forget _).map_iso (as_iso f'))
choose gl gl_spec gl_uniq using h U sf hsf
exact ‚ü®gl, gl_spec‚ü©
intro s
let t : F.gluing U sf := _
change s = t
ext
choose gl gl_spec gl_uniq using h U sf hsf
refine eq.trans (gl_uniq s.1 _) (gl_uniq t.1 _).symm
exacts [s.2, t.2]
wlog hle : v‚ÇÅ ‚â§ v‚ÇÇ := hc.total_of_refl h‚ÇÅ h‚ÇÇ using [v‚ÇÅ v‚ÇÇ, v‚ÇÇ v‚ÇÅ]
exact hle.2 _ hi‚ÇÅ
rintros _ ‚ü®a, rfl‚ü© _ ‚ü®b, rfl‚ü© u ‚ü®ua, ub‚ü©
refine ‚ü®_, ‚ü®a ‚à© b, rfl‚ü©, inter_mem ua ub, assume v hv, ‚ü®_, _‚ü©‚ü©
refine ‚ü®_, ‚ü®a ‚à© b, rfl‚ü©, inter_mem ua ub, assume v hv, ‚ü®_, _‚ü©‚ü©; apply mem_of_superset hv; simp [inter_subset_right a b]
refine ‚ü®_, ‚ü®a ‚à© b, rfl‚ü©, inter_mem ua ub, assume v hv, ‚ü®_, _‚ü©‚ü©; apply mem_of_superset hv
simp [inter_subset_right a b]
simp [inter_subset_right a b]
apply mem_of_superset hv
apply mem_of_superset hv
simpa only [subset_def, not_forall, eq_empty_iff_forall_not_mem, mem_Union, exists_prop, mem_inter_eq, not_and, iff_self, mem_Inter, mem_compl_eq] using hsZ
simpa only [subset_def, not_forall, eq_empty_iff_forall_not_mem, mem_Union, exists_prop, mem_inter_eq, not_and, iff_self, mem_Inter, mem_compl_eq] using ht
rw is_compact_iff_ultrafilter_le_nhds at ‚ä¢ h
intros u us'
have : ‚Üë(u.map f) ‚â§ ùìü (f '' s)
rw [ultrafilter.coe_map, map_le_iff_le_comap, comap_principal]
convert us'
exact preimage_image_eq _ hf.inj
begin rw [ultrafilter.coe_map, map_le_iff_le_comap, comap_principal], convert us', exact preimage_image_eq _ hf.inj end
rcases h (u.map f) this with ‚ü®_, ‚ü®a, ha, ‚ü®‚ü©‚ü©, _‚ü©
refine ‚ü®a, ha, _‚ü©
rwa [hf.induced, nhds_induced, ‚Üêmap_le_iff_le_comap]
rw uniform_space.mem_nhds_iff
split
rintros ‚ü®V, V_in, V_sub‚ü©
use [symmetrize_rel V, symmetrize_mem_uniformity V_in, symmetric_symmetrize_rel V]
exact subset.trans (ball_mono (symmetrize_rel_subset_self V) x) V_sub
{ rintros ‚ü®V, V_in, V_sub‚ü©, use [symmetrize_rel V, symmetrize_mem_uniformity V_in, symmetric_symmetrize_rel V], exact subset.trans (ball_mono (symmetrize_rel_subset_self V) x) V_sub }
rintros ‚ü®V, V_in, V_symm, V_sub‚ü©
exact ‚ü®V, V_in, V_sub‚ü©
simp_rw [mem_closure_iff_nhds, uniform_space.mem_nhds_iff]
split
intros h V V_in
{ intros h V V_in, exact h (ball x V) ‚ü®V, V_in, subset.refl _‚ü© }
exact h (ball x V) ‚ü®V, V_in, subset.refl _‚ü©
rintros h t ‚ü®V, V_in, Vt‚ü©
exact nonempty.mono (inter_subset_inter_left s Vt) (h V_in)
simp
simp; filter_upwards [hs] subset_closure
filter_upwards [hs] subset_closure
intros s hs
intros s hs; rw [closure_eq_inter_uniformity]; exact bInter_subset_of_mem hs
intros s hs; rw [closure_eq_inter_uniformity]
rw [closure_eq_inter_uniformity]
exact bInter_subset_of_mem hs
rcases comp_symm_of_uniformity hd with ‚ü®r, hr, rs, rd‚ü©
rcases H r hr with ‚ü®k, fk, ks‚ü©
let u := k ‚à© {y | ‚àÉ x ‚àà s, (x, y) ‚àà r}
choose hk f hfs hfr using Œª x : u, x.coe_prop
refine ‚ü®range f, _, _, _‚ü©
{ exact range_subset_iff.2 hfs }
exact range_subset_iff.2 hfs
haveI : fintype u := (fk.inter_of_left _).fintype
{ haveI : fintype u := (fk.inter_of_left _).fintype, exact finite_range f }
exact finite_range f
intros x xs
from mem_bUnion_iff.1 (ks xs)
obtain ‚ü®y, hy, xy‚ü© : ‚àÉ y ‚àà k, (x, y) ‚àà r
rw [bUnion_range, mem_Union]
set z : ‚Ü•u := ‚ü®y, hy, ‚ü®x, xs, xy‚ü©‚ü©
exact ‚ü®z, rd $ mem_comp_rel.2 ‚ü®y, xy, rs (hfr z)‚ü©‚ü©
simp
simp [tendsto_uniformly_on, tendsto_uniformly]
simp [hs]
rw ‚Üê hf.comap_uniformity at ht
rcases mem_comap.2 ht with ‚ü®t', ht', ts‚ü©
rcases totally_bounded_iff_subset.1 (totally_bounded_subset (image_preimage_subset f s) hs) _ ht' with ‚ü®c, cs, hfc, hct‚ü©
refine ‚ü®f ‚Åª¬π' c, hfc.preimage (hf.inj.inj_on _), Œª x h, _‚ü©
simp at this ‚ä¢
have := hct (mem_image_of_mem f h)
rcases this with ‚ü®z, zc, zt‚ü©
rcases cs zc with ‚ü®y, yc, rfl‚ü©
exact zt
exact ‚ü®y, zc, ts (by exact zt)‚ü©
simp only [uniform_embedding_def, uniform_continuous_def]
simp only [uniform_embedding_def, uniform_continuous_def]; exact ‚ü®Œª ‚ü®I, H‚ü©, ‚ü®I, Œª s su, (H _).2 ‚ü®s, su, Œª x y, id‚ü©, Œª s, (H s).1‚ü©, Œª ‚ü®I, H‚ÇÅ, H‚ÇÇ‚ü©, ‚ü®I, Œª s, ‚ü®H‚ÇÇ s, Œª ‚ü®t, tu, h‚ü©, mem_of_superset (H‚ÇÅ t tu) (Œª ‚ü®a, b‚ü©, h a b)‚ü©‚ü©‚ü©
exact ‚ü®Œª ‚ü®I, H‚ü©, ‚ü®I, Œª s su, (H _).2 ‚ü®s, su, Œª x y, id‚ü©, Œª s, (H s).1‚ü©, Œª ‚ü®I, H‚ÇÅ, H‚ÇÇ‚ü©, ‚ü®I, Œª s, ‚ü®H‚ÇÇ s, Œª ‚ü®t, tu, h‚ü©, mem_of_superset (H‚ÇÅ t tu) (Œª ‚ü®a, b‚ü©, h a b)‚ü©‚ü©‚ü©
apply mem_base_set_trivialization_at
rw topological_fiber_bundle.trivialization.mem_source
