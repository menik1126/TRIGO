⊢ ∀ {α : Type u} (f : α → α) (a : α), iterate f a = a::iterate f (f a)
α : Type u,	f : α → α,	a : α	⊢ iterate f a = a::iterate f (f a)
α : Type u,	f : α → α,	a : α	⊢ (iterate f a).head::(iterate f a).tail = a::iterate f (f a)
α : Type u,	f : α → α,	a : α	⊢ (iterate f a).head::iterate f (f a) = a::iterate f (f a)
⊢ ∀ {α : Type u} {n : ℕ} (a : α) (v : vector α n), (cons a v).to_list = a :: v.to_list
α : Type u,	n : ℕ,	a : α,	v : vector α n	⊢ (cons a v).to_list = a :: v.to_list
α : Type u,	n : ℕ,	a : α,	v_val : list α,	v_property : v_val.length = n	⊢ (cons a ⟨v_val, v_property⟩).to_list = a :: to_list ⟨v_val, v_property⟩
⊢ ∀ {α : Type u} (b : bool) (a : α), cond b a a = a
α : Type u,	b : bool,	a : α	⊢ cond b a a = a
2 goals	case bool.ff	α : Type u,	a : α	⊢ cond bool.ff a a = a		case bool.tt	α : Type u,	a : α	⊢ cond bool.tt a a = a
case bool.tt	α : Type u,	a : α	⊢ cond bool.tt a a = a
⊢ ∀ (b : bool), bool.ff && b = bool.ff
b : bool	⊢ bool.ff && b = bool.ff
2 goals	case bool.ff	⊢ bool.ff && bool.ff = bool.ff		case bool.tt	⊢ bool.ff && bool.tt = bool.ff
case bool.tt	⊢ bool.ff && bool.tt = bool.ff
⊢ ∀ (b : bool), (¬b = bool.tt) = (b = bool.ff)
b : bool	⊢ (¬b = bool.tt) = (b = bool.ff)
2 goals	case bool.ff	⊢ (¬bool.ff = bool.tt) = (bool.ff = bool.ff)		case bool.tt	⊢ (¬bool.tt = bool.tt) = (bool.tt = bool.ff)
case bool.tt	⊢ (¬bool.tt = bool.tt) = (bool.tt = bool.ff)
⊢ ∀ {a b : ℤ}, a < -b → b < -a
a b : ℤ,	h : a < -b	⊢ b < -a
a b : ℤ,	h : a < -b,	h : - -b < -a	⊢ b < -a
⊢ ∀ {a b c : ℤ}, a ≤ b + c → a - b ≤ c
a b c : ℤ,	h : a ≤ b + c	⊢ a - b ≤ c
a b c : ℤ,	h : a ≤ b + c,	h : a + -b ≤ b + c + -b	⊢ a - b ≤ c
⊢ ∀ {a b c : ℤ}, -c + a ≤ b → a ≤ b + c
a b c : ℤ,	h : -c + a ≤ b	⊢ a ≤ b + c
a b c : ℤ,	h : a + -c ≤ b	⊢ a ≤ b + c
⊢ ∀ {a b c : ℤ}, a - b < c → a < b + c
a b c : ℤ,	h : a - b < c	⊢ a < b + c
a b c : ℤ,	h : a - b < c,	h : a - b + b < c + b	⊢ a < b + c
⊢ ∀ {α : Type u} (n : ℕ) (l : list α), (take n l).length ≤ n
α : Type u,	n : ℕ,	l : list α	⊢ (take n l).length ≤ n
⊢ ∀ {α : Type u} (a : α) (n : ℕ), (repeat a n).length = n
α : Type u,	a : α,	n : ℕ	⊢ (repeat a n).length = n
2 goals	case nat.zero	α : Type u,	a : α	⊢ (repeat a 0).length = 0		case nat.succ	α : Type u,	a : α,	n_n : ℕ,	n_ih : (repeat a n_n).length = n_n	⊢ (repeat a n_n.succ).length = n_n.succ
case nat.succ	α : Type u,	a : α,	n_n : ℕ,	n_ih : (repeat a n_n).length = n_n	⊢ (repeat a n_n.succ).length = n_n.succ
⊢ ∀ (f : bool → bool → bool), f ff ff = ff → ∀ (m : ℕ), bitwise f m 0 = cond (f tt ff) m 0
f : bool → bool → bool,	h : f ff ff = ff,	m : ℕ	⊢ bitwise f m 0 = cond (f tt ff) m 0
f : bool → bool → bool,	h : f ff ff = ff,	m : ℕ	⊢ binary_rec (λ (n : ℕ), cond (f ff tt) n 0)	      (λ (a : bool) (m : ℕ) (Ia : ℕ → ℕ),	         binary_rec (cond (f tt ff) (bit a m) 0) (λ (b : bool) (n _x : ℕ), bit (f a b) (Ia n)))	      m	      0 =	    cond (f tt ff) m 0
f : bool → bool → bool,	h : f ff ff = ff,	m : ℕ	⊢ ∀ (b : bool) (n : ℕ),	    binary_rec (λ (n : ℕ), cond (f ff tt) n 0)	        (λ (a : bool) (m : ℕ) (Ia : ℕ → ℕ),	           binary_rec (cond (f tt ff) (bit a m) 0) (λ (b : bool) (n _x : ℕ), bit (f a b) (Ia n)))	        (bit b n)	        0 =	      cond (f tt ff) (bit b n) 0
f : bool → bool → bool,	h : f ff ff = ff,	m : ℕ,	b : bool,	n : ℕ	⊢ binary_rec (λ (n : ℕ), cond (f ff tt) n 0)	      (λ (a : bool) (m : ℕ) (Ia : ℕ → ℕ),	         binary_rec (cond (f tt ff) (bit a m) 0) (λ (b : bool) (n _x : ℕ), bit (f a b) (Ia n)))	      (bit b n)	      0 =	    cond (f tt ff) (bit b n) 0
f : bool → bool → bool,	h : f ff ff = ff,	m : ℕ,	b : bool,	n : ℕ	⊢ binary_rec (cond (f tt ff) (bit ff 0) 0) (λ (b : bool) (n _x : ℕ), bit (f ff b) (cond (f ff tt) n 0)) =	    λ (n : ℕ), cond (f ff tt) n 0
⊢ ∀ (n : ℕ), 1.gcd n = 1
n : ℕ	⊢ 1.gcd n = 1
⊢ ∀ (a : ℕ), a % 0 = a
a : ℕ	⊢ a % 0 = a
a : ℕ	⊢ ite (0 < 0 ∧ 0 ≤ a) ((a - 0) % 0) a = a
2 goals	a : ℕ	⊢ ¬(0 < 0 ∧ 0 ≤ a)		a : ℕ,	h : ¬(0 < 0 ∧ 0 ≤ a)	⊢ ite (0 < 0 ∧ 0 ≤ a) ((a - 0) % 0) a = a
a : ℕ,	h : ¬(0 < 0 ∧ 0 ≤ a)	⊢ ite (0 < 0 ∧ 0 ≤ a) ((a - 0) % 0) a = a
⊢ ∀ (b : ℕ), 0 % b = 0
b : ℕ	⊢ 0 % b = 0
b : ℕ	⊢ ite (0 < b ∧ b ≤ 0) ((0 - b) % b) 0 = 0
2 goals	b : ℕ	⊢ ¬(0 < b ∧ b ≤ 0)		b : ℕ,	h : ¬(0 < b ∧ b ≤ 0)	⊢ ite (0 < b ∧ b ≤ 0) ((0 - b) % b) 0 = 0
2 goals	b : ℕ,	hn : 0 < b ∧ b ≤ 0	⊢ false		b : ℕ,	h : ¬(0 < b ∧ b ≤ 0)	⊢ ite (0 < b ∧ b ≤ 0) ((0 - b) % b) 0 = 0
2 goals	b : ℕ,	l : 0 < b,	r : b ≤ 0	⊢ false		b : ℕ,	h : ¬(0 < b ∧ b ≤ 0)	⊢ ite (0 < b ∧ b ≤ 0) ((0 - b) % b) 0 = 0
b : ℕ,	h : ¬(0 < b ∧ b ≤ 0)	⊢ ite (0 < b ∧ b ≤ 0) ((0 - b) % b) 0 = 0
⊢ ∀ {R : Type u} {A₁ : Type v} [_inst_1 : comm_semiring R] [_inst_2 : semiring A₁] [_inst_5 : algebra R A₁],	    refl.aut_congr = mul_equiv.refl (A₁ ≃ₐ[R] A₁)
R : Type u,	A₁ : Type v,	_inst_1 : comm_semiring R,	_inst_2 : semiring A₁,	_inst_5 : algebra R A₁	⊢ refl.aut_congr = mul_equiv.refl (A₁ ≃ₐ[R] A₁)
R : Type u,	A₁ : Type v,	_inst_1 : comm_semiring R,	_inst_2 : semiring A₁,	_inst_5 : algebra R A₁,	x : A₁ ≃ₐ[R] A₁,	a : A₁	⊢ ⇑(⇑(refl.aut_congr) x) a = ⇑(⇑(mul_equiv.refl (A₁ ≃ₐ[R] A₁)) x) a
⊢ ∀ {R : Type u} {A : Type v} {B : Type w} [_inst_1 : comm_semiring R] [_inst_2 : semiring A] [_inst_3 : semiring B]	  [_inst_6 : algebra R A] [_inst_7 : algebra R B] (f : A →ₗ[R] B) (map_one : ⇑f 1 = 1)	  (map_mul : ∀ (x y : A), ⇑f (x * y) = ⇑f x * ⇑f y), (of_linear_map f map_one map_mul).to_linear_map = f
R : Type u,	A : Type v,	B : Type w,	_inst_1 : comm_semiring R,	_inst_2 : semiring A,	_inst_3 : semiring B,	_inst_6 : algebra R A,	_inst_7 : algebra R B,	f : A →ₗ[R] B,	map_one : ⇑f 1 = 1,	map_mul : ∀ (x y : A), ⇑f (x * y) = ⇑f x * ⇑f y	⊢ (of_linear_map f map_one map_mul).to_linear_map = f
R : Type u,	A : Type v,	B : Type w,	_inst_1 : comm_semiring R,	_inst_2 : semiring A,	_inst_3 : semiring B,	_inst_6 : algebra R A,	_inst_7 : algebra R B,	f : A →ₗ[R] B,	map_one : ⇑f 1 = 1,	map_mul : ∀ (x y : A), ⇑f (x * y) = ⇑f x * ⇑f y,	x : A	⊢ ⇑((of_linear_map f map_one map_mul).to_linear_map) x = ⇑f x
⊢ ∀ {R : Type u} {A₁ : Type v} {A₂ : Type w} [_inst_1 : comm_semiring R] [_inst_2 : semiring A₁]	  [_inst_3 : semiring A₂] [_inst_5 : algebra R A₁] [_inst_6 : algebra R A₂] (e : A₁ ≃ₐ[R] A₂),	    ↑(e.symm).comp ↑e = alg_hom.id R A₁
R : Type u,	A₁ : Type v,	A₂ : Type w,	_inst_1 : comm_semiring R,	_inst_2 : semiring A₁,	_inst_3 : semiring A₂,	_inst_5 : algebra R A₁,	_inst_6 : algebra R A₂,	e : A₁ ≃ₐ[R] A₂	⊢ ↑(e.symm).comp ↑e = alg_hom.id R A₁
R : Type u,	A₁ : Type v,	A₂ : Type w,	_inst_1 : comm_semiring R,	_inst_2 : semiring A₁,	_inst_3 : semiring A₂,	_inst_5 : algebra R A₁,	_inst_6 : algebra R A₂,	e : A₁ ≃ₐ[R] A₂,	x : A₁	⊢ ⇑(↑(e.symm).comp ↑e) x = ⇑(alg_hom.id R A₁) x
⊢ ∀ {R : Type u_1} {A : Type u_2} [_inst_1 : comm_semiring R] [_inst_2 : semiring A] [_inst_3 : algebra R A]	  (a b : A), lmul_left R (a * b) = (lmul_left R a).comp (lmul_left R b)
R : Type u_1,	A : Type u_2,	_inst_1 : comm_semiring R,	_inst_2 : semiring A,	_inst_3 : algebra R A,	a b : A	⊢ lmul_left R (a * b) = (lmul_left R a).comp (lmul_left R b)
R : Type u_1,	A : Type u_2,	_inst_1 : comm_semiring R,	_inst_2 : semiring A,	_inst_3 : algebra R A,	a b x : A	⊢ ⇑(lmul_left R (a * b)) x = ⇑((lmul_left R a).comp (lmul_left R b)) x
⊢ ∀ {R : Type u} [_inst_1 : comm_semiring R] {A : Type v} [_inst_2 : comm_semiring A] [_inst_3 : algebra R A]	  (a : A) (M : submodule R A), {a}.up • M = map (lmul_left R a) M
R : Type u,	_inst_1 : comm_semiring R,	A : Type v,	_inst_2 : comm_semiring A,	_inst_3 : algebra R A,	a : A,	M : submodule R A	⊢ {a}.up • M = map (lmul_left R a) M
R : Type u,	_inst_1 : comm_semiring R,	A : Type v,	_inst_2 : comm_semiring A,	_inst_3 : algebra R A,	a : A,	M : submodule R A	⊢ {a}.up • span R ↑M = map (lmul_left R a) M
R : Type u,	_inst_1 : comm_semiring R,	A : Type v,	_inst_2 : comm_semiring A,	_inst_3 : algebra R A,	a : A,	M : submodule R A	⊢ span R {a}.up * span R ↑M = map (lmul_left R a) M
R : Type u,	_inst_1 : comm_semiring R,	A : Type v,	_inst_2 : comm_semiring A,	_inst_3 : algebra R A,	a : A,	M : submodule R A	⊢ span R ({a}.up * ↑M) = map (lmul_left R a) M
2 goals	R : Type u,	_inst_1 : comm_semiring R,	A : Type v,	_inst_2 : comm_semiring A,	_inst_3 : algebra R A,	a : A,	M : submodule R A	⊢ span R ({a}.up * ↑M) ≤ map (lmul_left R a) M		R : Type u,	_inst_1 : comm_semiring R,	A : Type v,	_inst_2 : comm_semiring A,	_inst_3 : algebra R A,	a : A,	M : submodule R A	⊢ map (lmul_left R a) M ≤ span R ({a}.up * ↑M)
2 goals	R : Type u,	_inst_1 : comm_semiring R,	A : Type v,	_inst_2 : comm_semiring A,	_inst_3 : algebra R A,	a : A,	M : submodule R A	⊢ {a}.up * ↑M ⊆ ↑(map (lmul_left R a) M)		R : Type u,	_inst_1 : comm_semiring R,	A : Type v,	_inst_2 : comm_semiring A,	_inst_3 : algebra R A,	a : A,	M : submodule R A	⊢ map (lmul_left R a) M ≤ span R ({a}.up * ↑M)
2 goals	R : Type u,	_inst_1 : comm_semiring R,	A : Type v,	_inst_2 : comm_semiring A,	_inst_3 : algebra R A,	a : A,	M : submodule R A,	b m : A,	hb : b ∈ {a}.up,	hm : m ∈ ↑M	⊢ b * m ∈ ↑(map (lmul_left R a) M)		R : Type u,	_inst_1 : comm_semiring R,	A : Type v,	_inst_2 : comm_semiring A,	_inst_3 : algebra R A,	a : A,	M : submodule R A	⊢ map (lmul_left R a) M ≤ span R ({a}.up * ↑M)
2 goals	R : Type u,	_inst_1 : comm_semiring R,	A : Type v,	_inst_2 : comm_semiring A,	_inst_3 : algebra R A,	a : A,	M : submodule R A,	b m : A,	hb : b ∈ {a}.up,	hm : m ∈ ↑M	⊢ ∃ (y : A), y ∈ M ∧ ⇑(lmul_left R a) y = a * m		R : Type u,	_inst_1 : comm_semiring R,	A : Type v,	_inst_2 : comm_semiring A,	_inst_3 : algebra R A,	a : A,	M : submodule R A	⊢ map (lmul_left R a) M ≤ span R ({a}.up * ↑M)
R : Type u,	_inst_1 : comm_semiring R,	A : Type v,	_inst_2 : comm_semiring A,	_inst_3 : algebra R A,	a : A,	M : submodule R A	⊢ map (lmul_left R a) M ≤ span R ({a}.up * ↑M)
R : Type u,	_inst_1 : comm_semiring R,	A : Type v,	_inst_2 : comm_semiring A,	_inst_3 : algebra R A,	a : A,	M : submodule R A,	m : A,	hm : m ∈ ↑M	⊢ ⇑(lmul_left R a) m ∈ span R ({a}.up * ↑M)
⊢ ∀ {R : Type u} [_inst_1 : comm_semiring R] {A : Type v} [_inst_2 : comm_semiring A] [_inst_3 : algebra R A]	  {B : Type u_1} [_inst_4 : comm_ring B] [_inst_5 : algebra R B] (I J : submodule R A) (h : A ≃ₐ[R] B),	    map h.to_linear_map (I / J) = map h.to_linear_map I / map h.to_linear_map J
R : Type u,	_inst_1 : comm_semiring R,	A : Type v,	_inst_2 : comm_semiring A,	_inst_3 : algebra R A,	B : Type u_1,	_inst_4 : comm_ring B,	_inst_5 : algebra R B,	I J : submodule R A,	h : A ≃ₐ[R] B	⊢ map h.to_linear_map (I / J) = map h.to_linear_map I / map h.to_linear_map J
R : Type u,	_inst_1 : comm_semiring R,	A : Type v,	_inst_2 : comm_semiring A,	_inst_3 : algebra R A,	B : Type u_1,	_inst_4 : comm_ring B,	_inst_5 : algebra R B,	I J : submodule R A,	h : A ≃ₐ[R] B,	x : B	⊢ x ∈ map h.to_linear_map (I / J) ↔ x ∈ map h.to_linear_map I / map h.to_linear_map J
R : Type u,	_inst_1 : comm_semiring R,	A : Type v,	_inst_2 : comm_semiring A,	_inst_3 : algebra R A,	B : Type u_1,	_inst_4 : comm_ring B,	_inst_5 : algebra R B,	I J : submodule R A,	h : A ≃ₐ[R] B,	x : B	⊢ (∃ (y : A), (∀ (y_1 : A), y_1 ∈ J → y * y_1 ∈ I) ∧ ⇑(h.to_linear_map) y = x) ↔	    ∀ (y : B),	      (∃ (y_1 : A), y_1 ∈ J ∧ ⇑(h.to_linear_map) y_1 = y) →	      (∃ (y_1 : A), y_1 ∈ I ∧ ⇑(h.to_linear_map) y_1 = x * y)
2 goals	R : Type u,	_inst_1 : comm_semiring R,	A : Type v,	_inst_2 : comm_semiring A,	_inst_3 : algebra R A,	B : Type u_1,	_inst_4 : comm_ring B,	_inst_5 : algebra R B,	I J : submodule R A,	h : A ≃ₐ[R] B,	x : B	⊢ (∃ (y : A), (∀ (y_1 : A), y_1 ∈ J → y * y_1 ∈ I) ∧ ⇑(h.to_linear_map) y = x) →	  ∀ (y : B),	    (∃ (y_1 : A), y_1 ∈ J ∧ ⇑(h.to_linear_map) y_1 = y) →	    (∃ (y_1 : A), y_1 ∈ I ∧ ⇑(h.to_linear_map) y_1 = x * y)		R : Type u,	_inst_1 : comm_semiring R,	A : Type v,	_inst_2 : comm_semiring A,	_inst_3 : algebra R A,	B : Type u_1,	_inst_4 : comm_ring B,	_inst_5 : algebra R B,	I J : submodule R A,	h : A ≃ₐ[R] B,	x : B	⊢ (∀ (y : B),	     (∃ (y_1 : A), y_1 ∈ J ∧ ⇑(h.to_linear_map) y_1 = y) →	     (∃ (y_1 : A), y_1 ∈ I ∧ ⇑(h.to_linear_map) y_1 = x * y)) →	  (∃ (y : A), (∀ (y_1 : A), y_1 ∈ J → y * y_1 ∈ I) ∧ ⇑(h.to_linear_map) y = x)
2 goals	R : Type u,	_inst_1 : comm_semiring R,	A : Type v,	_inst_2 : comm_semiring A,	_inst_3 : algebra R A,	B : Type u_1,	_inst_4 : comm_ring B,	_inst_5 : algebra R B,	I J : submodule R A,	h : A ≃ₐ[R] B,	x : A,	hx : ∀ (y : A), y ∈ J → x * y ∈ I,	y : A,	hy : y ∈ J	⊢ ∃ (y_1 : A), y_1 ∈ I ∧ ⇑(h.to_linear_map) y_1 = ⇑(h.to_linear_map) x * ⇑(h.to_linear_map) y		R : Type u,	_inst_1 : comm_semiring R,	A : Type v,	_inst_2 : comm_semiring A,	_inst_3 : algebra R A,	B : Type u_1,	_inst_4 : comm_ring B,	_inst_5 : algebra R B,	I J : submodule R A,	h : A ≃ₐ[R] B,	x : B	⊢ (∀ (y : B),	     (∃ (y_1 : A), y_1 ∈ J ∧ ⇑(h.to_linear_map) y_1 = y) →	     (∃ (y_1 : A), y_1 ∈ I ∧ ⇑(h.to_linear_map) y_1 = x * y)) →	  (∃ (y : A), (∀ (y_1 : A), y_1 ∈ J → y * y_1 ∈ I) ∧ ⇑(h.to_linear_map) y = x)
R : Type u,	_inst_1 : comm_semiring R,	A : Type v,	_inst_2 : comm_semiring A,	_inst_3 : algebra R A,	B : Type u_1,	_inst_4 : comm_ring B,	_inst_5 : algebra R B,	I J : submodule R A,	h : A ≃ₐ[R] B,	x : B	⊢ (∀ (y : B),	     (∃ (y_1 : A), y_1 ∈ J ∧ ⇑(h.to_linear_map) y_1 = y) →	     (∃ (y_1 : A), y_1 ∈ I ∧ ⇑(h.to_linear_map) y_1 = x * y)) →	  (∃ (y : A), (∀ (y_1 : A), y_1 ∈ J → y * y_1 ∈ I) ∧ ⇑(h.to_linear_map) y = x)
R : Type u,	_inst_1 : comm_semiring R,	A : Type v,	_inst_2 : comm_semiring A,	_inst_3 : algebra R A,	B : Type u_1,	_inst_4 : comm_ring B,	_inst_5 : algebra R B,	I J : submodule R A,	h : A ≃ₐ[R] B,	x : B,	hx :	  ∀ (y : B),	    (∃ (y_1 : A), y_1 ∈ J ∧ ⇑(h.to_linear_map) y_1 = y) →	    (∃ (y_1 : A), y_1 ∈ I ∧ ⇑(h.to_linear_map) y_1 = x * y)	⊢ ∃ (y : A), (∀ (y_1 : A), y_1 ∈ J → y * y_1 ∈ I) ∧ ⇑(h.to_linear_map) y = x
R : Type u,	_inst_1 : comm_semiring R,	A : Type v,	_inst_2 : comm_semiring A,	_inst_3 : algebra R A,	B : Type u_1,	_inst_4 : comm_ring B,	_inst_5 : algebra R B,	I J : submodule R A,	h : A ≃ₐ[R] B,	x : B,	hx :	  ∀ (y : B),	    (∃ (y_1 : A), y_1 ∈ J ∧ ⇑(h.to_linear_map) y_1 = y) →	    (∃ (y_1 : A), y_1 ∈ I ∧ ⇑(h.to_linear_map) y_1 = x * y),	z : A,	hz : z ∈ J	⊢ ⇑(h.symm) x * z ∈ I
R : Type u,	_inst_1 : comm_semiring R,	A : Type v,	_inst_2 : comm_semiring A,	_inst_3 : algebra R A,	B : Type u_1,	_inst_4 : comm_ring B,	_inst_5 : algebra R B,	I J : submodule R A,	h : A ≃ₐ[R] B,	x : B,	hx :	  ∀ (y : B),	    (∃ (y_1 : A), y_1 ∈ J ∧ ⇑(h.to_linear_map) y_1 = y) →	    (∃ (y_1 : A), y_1 ∈ I ∧ ⇑(h.to_linear_map) y_1 = x * y),	z : A,	hz : z ∈ J,	xz : A,	xz_mem : xz ∈ I,	hxz : ⇑(h.to_linear_map) xz = x * ⇑h z	⊢ ⇑(h.symm) x * z ∈ I
R : Type u,	_inst_1 : comm_semiring R,	A : Type v,	_inst_2 : comm_semiring A,	_inst_3 : algebra R A,	B : Type u_1,	_inst_4 : comm_ring B,	_inst_5 : algebra R B,	I J : submodule R A,	h : A ≃ₐ[R] B,	x : B,	hx :	  ∀ (y : B),	    (∃ (y_1 : A), y_1 ∈ J ∧ ⇑(h.to_linear_map) y_1 = y) →	    (∃ (y_1 : A), y_1 ∈ I ∧ ⇑(h.to_linear_map) y_1 = x * y),	z : A,	hz : z ∈ J,	xz : A,	xz_mem : xz ∈ I,	hxz : ⇑(h.to_linear_map) xz = x * ⇑h z	⊢ ⇑(h.symm) x * z = xz
R : Type u,	_inst_1 : comm_semiring R,	A : Type v,	_inst_2 : comm_semiring A,	_inst_3 : algebra R A,	B : Type u_1,	_inst_4 : comm_ring B,	_inst_5 : algebra R B,	I J : submodule R A,	h : A ≃ₐ[R] B,	x : B,	hx :	  ∀ (y : B),	    (∃ (y_1 : A), y_1 ∈ J ∧ ⇑(h.to_linear_map) y_1 = y) →	    (∃ (y_1 : A), y_1 ∈ I ∧ ⇑(h.to_linear_map) y_1 = x * y),	z : A,	hz : z ∈ J,	xz : A,	xz_mem : xz ∈ I,	hxz : ⇑(h.to_linear_map) xz = x * ⇑h z	⊢ ⇑h (⇑(h.symm) x * z) = ⇑h xz
⊢ ∀ {R : Type u} {A : Type v} [_inst_1 : comm_semiring R] [_inst_2 : semiring A] [_inst_3 : algebra R A]	  (S : subalgebra R A), S.to_submodule * S.to_submodule = S.to_submodule
R : Type u,	A : Type v,	_inst_1 : comm_semiring R,	_inst_2 : semiring A,	_inst_3 : algebra R A,	S : subalgebra R A	⊢ S.to_submodule * S.to_submodule = S.to_submodule
2 goals	R : Type u,	A : Type v,	_inst_1 : comm_semiring R,	_inst_2 : semiring A,	_inst_3 : algebra R A,	S : subalgebra R A	⊢ S.to_submodule * S.to_submodule ≤ S.to_submodule		R : Type u,	A : Type v,	_inst_1 : comm_semiring R,	_inst_2 : semiring A,	_inst_3 : algebra R A,	S : subalgebra R A	⊢ S.to_submodule ≤ S.to_submodule * S.to_submodule
2 goals	R : Type u,	A : Type v,	_inst_1 : comm_semiring R,	_inst_2 : semiring A,	_inst_3 : algebra R A,	S : subalgebra R A	⊢ ∀ (m : A), m ∈ S.to_submodule → ∀ (n : A), n ∈ S.to_submodule → m * n ∈ S.to_submodule		R : Type u,	A : Type v,	_inst_1 : comm_semiring R,	_inst_2 : semiring A,	_inst_3 : algebra R A,	S : subalgebra R A	⊢ S.to_submodule ≤ S.to_submodule * S.to_submodule
2 goals	R : Type u,	A : Type v,	_inst_1 : comm_semiring R,	_inst_2 : semiring A,	_inst_3 : algebra R A,	S : subalgebra R A,	y : A,	hy : y ∈ S.to_submodule,	z : A,	hz : z ∈ S.to_submodule	⊢ y * z ∈ S.to_submodule		R : Type u,	A : Type v,	_inst_1 : comm_semiring R,	_inst_2 : semiring A,	_inst_3 : algebra R A,	S : subalgebra R A	⊢ S.to_submodule ≤ S.to_submodule * S.to_submodule
R : Type u,	A : Type v,	_inst_1 : comm_semiring R,	_inst_2 : semiring A,	_inst_3 : algebra R A,	S : subalgebra R A	⊢ S.to_submodule ≤ S.to_submodule * S.to_submodule
R : Type u,	A : Type v,	_inst_1 : comm_semiring R,	_inst_2 : semiring A,	_inst_3 : algebra R A,	S : subalgebra R A,	x : A,	hx1 : x ∈ S.to_submodule	⊢ x ∈ S.to_submodule * S.to_submodule
R : Type u,	A : Type v,	_inst_1 : comm_semiring R,	_inst_2 : semiring A,	_inst_3 : algebra R A,	S : subalgebra R A,	x : A,	hx1 : x ∈ S.to_submodule	⊢ x * 1 ∈ S.to_submodule * S.to_submodule
⊢ ∀ {R : Type u} {A : Type v} [_inst_1 : comm_semiring R] [_inst_2 : semiring A] [_inst_3 : algebra R A],	    ↑⊥ = set.range ⇑(algebra_map R A)
R : Type u,	A : Type v,	_inst_1 : comm_semiring R,	_inst_2 : semiring A,	_inst_3 : algebra R A	⊢ ↑⊥ = set.range ⇑(algebra_map R A)
⊢ ∀ {α : Type u_1} [_inst_1 : monoid α] (x : α),	    ¬is_unit x → (irreducible x ∨ ∃ (a b : α), ¬is_unit a ∧ ¬is_unit b ∧ a * b = x)
α : Type u_1,	_inst_1 : monoid α,	x : α,	h : ¬is_unit x	⊢ irreducible x ∨ ∃ (a b : α), ¬is_unit a ∧ ¬is_unit b ∧ a * b = x
α : Type u_1,	_inst_1 : monoid α,	x : α,	h : ¬is_unit x,	_inst : Π (p : Prop), decidable p	⊢ irreducible x ∨ ∃ (a b : α), ¬is_unit a ∧ ¬is_unit b ∧ a * b = x
α : Type u_1,	_inst_1 : monoid α,	x : α,	h : ¬is_unit x,	_inst : Π (p : Prop), decidable p,	H : ¬∃ (a b : α), ¬is_unit a ∧ ¬is_unit b ∧ a * b = x	⊢ irreducible x
α : Type u_1,	_inst_1 : monoid α,	x : α,	h : ¬is_unit x,	_inst : Π (p : Prop), decidable p,	H : ∀ (x_1 : α), ¬is_unit x_1 → ∀ (x_2 : α), ¬is_unit x_2 → ¬x_1 * x_2 = x	⊢ ∀ (a b : α), x = a * b → is_unit a ∨ is_unit b
α : Type u_1,	_inst_1 : monoid α,	x : α,	h : ¬is_unit x,	_inst : Π (p : Prop), decidable p,	H : ∀ (x_1 : α), ¬is_unit x_1 → ∀ (x_2 : α), ¬is_unit x_2 → ¬x_1 * x_2 = x,	a b : α,	h : x = a * b,	o : ¬(is_unit a ∨ is_unit b)	⊢ false
α : Type u_1,	_inst_1 : monoid α,	x : α,	h : ¬is_unit x,	_inst : Π (p : Prop), decidable p,	H : ∀ (x_1 : α), ¬is_unit x_1 → ∀ (x_2 : α), ¬is_unit x_2 → ¬x_1 * x_2 = x,	a b : α,	h : x = a * b,	o : ¬is_unit a ∧ ¬is_unit b	⊢ false
⊢ ∀ {α : Type u_1} {M : Type u_4} {N : Type u_5} [_inst_1 : comm_monoid M] [_inst_2 : comm_monoid N] {s : set α}	  {f : α → M} (g : M →* N),	    (s ∩ mul_support f).finite →	    ⇑g (finprod (λ (j : α), finprod (λ (H : j ∈ s), f j))) =	      finprod (λ (i : α), finprod (λ (H : i ∈ s), ⇑g (f i)))
α : Type u_1,	M : Type u_4,	N : Type u_5,	_inst_1 : comm_monoid M,	_inst_2 : comm_monoid N,	s : set α,	f : α → M,	g : M →* N,	h₀ : (s ∩ mul_support f).finite	⊢ ⇑g (finprod (λ (j : α), finprod (λ (H : j ∈ s), f j))) =	    finprod (λ (i : α), finprod (λ (H : i ∈ s), ⇑g (f i)))
2 goals	α : Type u_1,	M : Type u_4,	N : Type u_5,	_inst_1 : comm_monoid M,	_inst_2 : comm_monoid N,	s : set α,	f : α → M,	g : M →* N,	h₀ : (s ∩ mul_support f).finite	⊢ finprod (λ (i : α), ⇑g (finprod (λ (H : i ∈ s), f i))) =	    finprod (λ (i : α), finprod (λ (H : i ∈ s), ⇑g (f i)))		α : Type u_1,	M : Type u_4,	N : Type u_5,	_inst_1 : comm_monoid M,	_inst_2 : comm_monoid N,	s : set α,	f : α → M,	g : M →* N,	h₀ : (s ∩ mul_support f).finite	⊢ (mul_support (λ (i : α), finprod (λ (H : i ∈ s), f i))).finite
α : Type u_1,	M : Type u_4,	N : Type u_5,	_inst_1 : comm_monoid M,	_inst_2 : comm_monoid N,	s : set α,	f : α → M,	g : M →* N,	h₀ : (s ∩ mul_support f).finite	⊢ (mul_support (λ (i : α), finprod (λ (H : i ∈ s), f i))).finite
⊢ ∀ (G H : Group) (f₁ f₂ : G ⟶ H), (∀ (x : ↥G), ⇑f₁ x = ⇑f₂ x) → f₁ = f₂
G H : Group,	f₁ f₂ : G ⟶ H,	w : ∀ (x : ↥G), ⇑f₁ x = ⇑f₂ x	⊢ f₁ = f₂
G H : Group,	f₁ f₂ : G ⟶ H,	w : ∀ (x : ↥G), ⇑f₁ x = ⇑f₂ x,	x : ↥G	⊢ ⇑f₁ x = ⇑f₂ x
⊢ ∀ {G H : AddCommGroup} (f : G ⟶ H), (kernel_iso_ker f).hom ≫ (add_monoid_hom.ker f).subtype = kernel.ι f
G H : AddCommGroup,	f : G ⟶ H	⊢ (kernel_iso_ker f).hom ≫ (add_monoid_hom.ker f).subtype = kernel.ι f
G H : AddCommGroup,	f : G ⟶ H,	x : ↥(kernel f)	⊢ ⇑((kernel_iso_ker f).hom ≫ (add_monoid_hom.ker f).subtype) x = ⇑(kernel.ι f) x
⊢ ∀ (R : Type u_1) [_inst_1 : comm_ring R] {C : Type u} [_inst_2 : category C] {D : Type u} [_inst_3 : category D]	  [_inst_4 : preadditive D] [_inst_5 : linear R D] (F : C ⥤ D) {X Y : C} (f : X ⟶ Y) (r : R),	    (Free.lift R F).map (single f r) = r • F.map f
R : Type u_1,	_inst_1 : comm_ring R,	C : Type u,	_inst_2 : category C,	D : Type u,	_inst_3 : category D,	_inst_4 : preadditive D,	_inst_5 : linear R D,	F : C ⥤ D,	X Y : C,	f : X ⟶ Y,	r : R	⊢ (Free.lift R F).map (single f r) = r • F.map f
⊢ ∀ {α : Type u_1} [_inst_1 : comm_monoid α] {a b : α}, a ∣ b → ∀ (c : α), a ∣ c * b
α : Type u_1,	_inst_1 : comm_monoid α,	a b : α,	h : a ∣ b,	c : α	⊢ a ∣ c * b
α : Type u_1,	_inst_1 : comm_monoid α,	a b : α,	h : a ∣ b,	c : α	⊢ a ∣ b * c
⊢ ∀ {α : Type u_1} [_inst_1 : comm_monoid_with_zero α] {a b : α}, a ∣ b → ¬b ∣ a → dvd_not_unit a b
α : Type u_1,	_inst_1 : comm_monoid_with_zero α,	a b : α,	hd : a ∣ b,	hnd : ¬b ∣ a	⊢ dvd_not_unit a b
2 goals	α : Type u_1,	_inst_1 : comm_monoid_with_zero α,	a b : α,	hd : a ∣ b,	hnd : ¬b ∣ a	⊢ a ≠ 0		α : Type u_1,	_inst_1 : comm_monoid_with_zero α,	a b : α,	hd : a ∣ b,	hnd : ¬b ∣ a	⊢ ∃ (x : α), ¬is_unit x ∧ b = a * x
2 goals	α : Type u_1,	_inst_1 : comm_monoid_with_zero α,	b : α,	hd : 0 ∣ b,	hnd : ¬b ∣ 0	⊢ false		α : Type u_1,	_inst_1 : comm_monoid_with_zero α,	a b : α,	hd : a ∣ b,	hnd : ¬b ∣ a	⊢ ∃ (x : α), ¬is_unit x ∧ b = a * x
α : Type u_1,	_inst_1 : comm_monoid_with_zero α,	a b : α,	hd : a ∣ b,	hnd : ¬b ∣ a	⊢ ∃ (x : α), ¬is_unit x ∧ b = a * x
α : Type u_1,	_inst_1 : comm_monoid_with_zero α,	a c : α,	hnd : ¬a * c ∣ a	⊢ ∃ (x : α), ¬is_unit x ∧ a * c = a * x
α : Type u_1,	_inst_1 : comm_monoid_with_zero α,	a c : α,	hnd : ¬a * c ∣ a	⊢ ¬is_unit c
α : Type u_1,	_inst_1 : comm_monoid_with_zero α,	a : α,	u : αˣ,	hnd : ¬a * ↑u ∣ a	⊢ false
⊢ ∀ {R : Type u} [_inst_1 : euclidean_domain R] [_inst_2 : decidable_eq R] {s t r' s' t' : R},	    xgcd_aux 0 s t r' s' t' = (r', s', t')
R : Type u,	_inst_1 : euclidean_domain R,	_inst_2 : decidable_eq R,	s t r' s' t' : R	⊢ xgcd_aux 0 s t r' s' t' = (r', s', t')
R : Type u,	_inst_1 : euclidean_domain R,	_inst_2 : decidable_eq R,	s t r' s' t' : R	⊢ ite (0 = 0) (r', s', t') (let q : R := r' / 0 in xgcd_aux (r' % 0) (s' - q * s) (t' - q * t) 0 s t) = (r', s', t')
⊢ ∀ {K : Type u} [_inst_1 : division_ring K] {a : K}, (-a)⁻¹ = -a⁻¹
K : Type u,	_inst_1 : division_ring K,	a : K	⊢ (-a)⁻¹ = -a⁻¹
⊢ ∀ {α : Type u_1} {β : Type u_2} [_inst_1 : cancel_comm_monoid_with_zero α] [_inst_2 : normalized_gcd_monoid α]	  {s : finset β} {f : β → α} {a : α}, s.gcd (λ (x : β), f x * a) = s.gcd f * ⇑normalize a
α : Type u_1,	β : Type u_2,	_inst_1 : cancel_comm_monoid_with_zero α,	_inst_2 : normalized_gcd_monoid α,	s : finset β,	f : β → α,	a : α	⊢ s.gcd (λ (x : β), f x * a) = s.gcd f * ⇑normalize a
α : Type u_1,	β : Type u_2,	_inst_1 : cancel_comm_monoid_with_zero α,	_inst_2 : normalized_gcd_monoid α,	s : finset β,	f : β → α,	a : α,	_inst : Π (a : Prop), decidable a	⊢ s.gcd (λ (x : β), f x * a) = s.gcd f * ⇑normalize a
2 goals	α : Type u_1,	β : Type u_2,	_inst_1 : cancel_comm_monoid_with_zero α,	_inst_2 : normalized_gcd_monoid α,	s : finset β,	f : β → α,	a : α,	_inst : Π (a : Prop), decidable a	⊢ ∅.gcd (λ (x : β), f x * a) = ∅.gcd f * ⇑normalize a		α : Type u_1,	β : Type u_2,	_inst_1 : cancel_comm_monoid_with_zero α,	_inst_2 : normalized_gcd_monoid α,	s : finset β,	f : β → α,	a : α,	_inst : Π (a : Prop), decidable a	⊢ ∀ ⦃a_1 : β⦄ {s : finset β},	    a_1 ∉ s →	    s.gcd (λ (x : β), f x * a) = s.gcd f * ⇑normalize a →	    (insert a_1 s).gcd (λ (x : β), f x * a) = (insert a_1 s).gcd f * ⇑normalize a
α : Type u_1,	β : Type u_2,	_inst_1 : cancel_comm_monoid_with_zero α,	_inst_2 : normalized_gcd_monoid α,	s : finset β,	f : β → α,	a : α,	_inst : Π (a : Prop), decidable a	⊢ ∀ ⦃a_1 : β⦄ {s : finset β},	    a_1 ∉ s →	    s.gcd (λ (x : β), f x * a) = s.gcd f * ⇑normalize a →	    (insert a_1 s).gcd (λ (x : β), f x * a) = (insert a_1 s).gcd f * ⇑normalize a
α : Type u_1,	β : Type u_2,	_inst_1 : cancel_comm_monoid_with_zero α,	_inst_2 : normalized_gcd_monoid α,	s : finset β,	f : β → α,	a : α,	_inst : Π (a : Prop), decidable a,	b : β,	t : finset β,	hbt : b ∉ t,	h : t.gcd (λ (x : β), f x * a) = t.gcd f * ⇑normalize a	⊢ (insert b t).gcd (λ (x : β), f x * a) = (insert b t).gcd f * ⇑normalize a
α : Type u_1,	β : Type u_2,	_inst_1 : cancel_comm_monoid_with_zero α,	_inst_2 : normalized_gcd_monoid α,	s : finset β,	f : β → α,	a : α,	_inst : Π (a : Prop), decidable a,	b : β,	t : finset β,	hbt : b ∉ t,	h : t.gcd (λ (x : β), f x * a) = t.gcd f * ⇑normalize a	⊢ gcd (f b * a) (t.gcd f * ⇑normalize a) = gcd (f b * a) (t.gcd f * a)
⊢ ∀ {G : Type u_1} [_inst_1 : group G] {a b : G}, commute a b → a * b * a⁻¹ = b
G : Type u_1,	_inst_1 : group G,	a b : G,	h : commute a b	⊢ a * b * a⁻¹ = b
⊢ ∀ {M : Type u} ⦃m₁ m₂ : monoid M⦄, mul = mul → m₁ = m₂
M : Type u,	m₁ m₂ : monoid M,	h_mul : mul = mul	⊢ m₁ = m₂
M : Type u,	m₂ : monoid M,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	h_mul : mul = mul	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁} =	    m₂
M : Type u,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	mul₂ : M → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₂ : M,	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow₂ : ℕ → M → M,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	h_mul : mul = mul	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁} =	    {mul := mul₂,	     mul_assoc := m₂_mul_assoc,	     one := one₂,	     one_mul := one_mul₂,	     mul_one := mul_one₂,	     npow := npow₂,	     npow_zero' := npow_zero₂,	     npow_succ' := npow_succ₂}
M : Type u,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	mul₂ : M → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₂ : M,	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow₂ : ℕ → M → M,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	h_mul : mul₁ = mul₂	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁} =	    {mul := mul₂,	     mul_assoc := m₂_mul_assoc,	     one := one₂,	     one_mul := one_mul₂,	     mul_one := mul_one₂,	     npow := npow₂,	     npow_zero' := npow_zero₂,	     npow_succ' := npow_succ₂}
M : Type u,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	one₂ : M,	npow₂ : ℕ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous)	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁} =	    {mul := mul₁,	     mul_assoc := m₂_mul_assoc,	     one := one₂,	     one_mul := one_mul₂,	     mul_one := mul_one₂,	     npow := npow₂,	     npow_zero' := npow_zero₂,	     npow_succ' := npow_succ₂}
2 goals	M : Type u,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	one₂ : M,	npow₂ : ℕ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous)	⊢ one₁ = one₂		M : Type u,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	one₂ : M,	npow₂ : ℕ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	h_one : one₁ = one₂	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁} =	    {mul := mul₁,	     mul_assoc := m₂_mul_assoc,	     one := one₂,	     one_mul := one_mul₂,	     mul_one := mul_one₂,	     npow := npow₂,	     npow_zero' := npow_zero₂,	     npow_succ' := npow_succ₂}
2 goals	M : Type u,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	one₂ : M,	npow₂ : ℕ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous)	⊢ 1 * one₁ = one₂		M : Type u,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	one₂ : M,	npow₂ : ℕ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	h_one : one₁ = one₂	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁} =	    {mul := mul₁,	     mul_assoc := m₂_mul_assoc,	     one := one₂,	     one_mul := one_mul₂,	     mul_one := mul_one₂,	     npow := npow₂,	     npow_zero' := npow_zero₂,	     npow_succ' := npow_succ₂}
M : Type u,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	one₂ : M,	npow₂ : ℕ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	h_one : one₁ = one₂	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁} =	    {mul := mul₁,	     mul_assoc := m₂_mul_assoc,	     one := one₂,	     one_mul := one_mul₂,	     mul_one := mul_one₂,	     npow := npow₂,	     npow_zero' := npow_zero₂,	     npow_succ' := npow_succ₂}
M : Type u,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	npow₂ : ℕ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous)	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁} =	    {mul := mul₁,	     mul_assoc := m₂_mul_assoc,	     one := one₁,	     one_mul := one_mul₂,	     mul_one := mul_one₂,	     npow := npow₂,	     npow_zero' := npow_zero₂,	     npow_succ' := npow_succ₂}
2 goals	M : Type u,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	npow₂ : ℕ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous)	⊢ npow₁ = npow₂		M : Type u,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	npow₂ : ℕ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	h_npow : npow₁ = npow₂	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁} =	    {mul := mul₁,	     mul_assoc := m₂_mul_assoc,	     one := one₁,	     one_mul := one_mul₂,	     mul_one := mul_one₂,	     npow := npow₂,	     npow_zero' := npow_zero₂,	     npow_succ' := npow_succ₂}
2 goals	M : Type u,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	npow₂ : ℕ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	n : ℕ,	x : M	⊢ npow₁ n x = npow₂ n x		M : Type u,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	npow₂ : ℕ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	h_npow : npow₁ = npow₂	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁} =	    {mul := mul₁,	     mul_assoc := m₂_mul_assoc,	     one := one₁,	     one_mul := one_mul₂,	     mul_one := mul_one₂,	     npow := npow₂,	     npow_zero' := npow_zero₂,	     npow_succ' := npow_succ₂}
3 goals	case nat.zero	M : Type u,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	npow₂ : ℕ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	x : M	⊢ npow₁ 0 x = npow₂ 0 x		case nat.succ	M : Type u,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	npow₂ : ℕ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	x : M,	d : ℕ,	hd : npow₁ d x = npow₂ d x	⊢ npow₁ d.succ x = npow₂ d.succ x		M : Type u,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	npow₂ : ℕ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	h_npow : npow₁ = npow₂	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁} =	    {mul := mul₁,	     mul_assoc := m₂_mul_assoc,	     one := one₁,	     one_mul := one_mul₂,	     mul_one := mul_one₂,	     npow := npow₂,	     npow_zero' := npow_zero₂,	     npow_succ' := npow_succ₂}
2 goals	case nat.succ	M : Type u,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	npow₂ : ℕ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	x : M,	d : ℕ,	hd : npow₁ d x = npow₂ d x	⊢ npow₁ d.succ x = npow₂ d.succ x		M : Type u,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	npow₂ : ℕ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	h_npow : npow₁ = npow₂	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁} =	    {mul := mul₁,	     mul_assoc := m₂_mul_assoc,	     one := one₁,	     one_mul := one_mul₂,	     mul_one := mul_one₂,	     npow := npow₂,	     npow_zero' := npow_zero₂,	     npow_succ' := npow_succ₂}
M : Type u,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	npow₂ : ℕ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	h_npow : npow₁ = npow₂	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁} =	    {mul := mul₁,	     mul_assoc := m₂_mul_assoc,	     one := one₁,	     one_mul := one_mul₂,	     mul_one := mul_one₂,	     npow := npow₂,	     npow_zero' := npow_zero₂,	     npow_succ' := npow_succ₂}
⊢ ∀ {M : Type u_1} {N : Type u_2} {A : Type u_3} {mM : mul_one_class M} {gN : mul_one_class N} {gA : comm_group A}	  (φ : N →* A) (ψ : M →* N), φ⁻¹.comp ψ = (φ.comp ψ)⁻¹
M : Type u_1,	N : Type u_2,	A : Type u_3,	mM : mul_one_class M,	gN : mul_one_class N,	gA : comm_group A,	φ : N →* A,	ψ : M →* N	⊢ φ⁻¹.comp ψ = (φ.comp ψ)⁻¹
M : Type u_1,	N : Type u_2,	A : Type u_3,	mM : mul_one_class M,	gN : mul_one_class N,	gA : comm_group A,	φ : N →* A,	ψ : M →* N,	x : M	⊢ ⇑(φ⁻¹.comp ψ) x = ⇑(φ.comp ψ)⁻¹ x
⊢ ∀ {M : Type u_5} [_inst_4 : monoid M] {A : Type u_6} [_inst_5 : add_monoid A] [_inst_6 : distrib_mul_action M A]	  {B : Type u_8} [_inst_9 : add_monoid B] [_inst_10 : distrib_mul_action M B] {f g : A →+[M] B}, ↑f = ↑g → f = g
M : Type u_5,	_inst_4 : monoid M,	A : Type u_6,	_inst_5 : add_monoid A,	_inst_6 : distrib_mul_action M A,	B : Type u_8,	_inst_9 : add_monoid B,	_inst_10 : distrib_mul_action M B,	f g : A →+[M] B,	h : ↑f = ↑g	⊢ f = g
M : Type u_5,	_inst_4 : monoid M,	A : Type u_6,	_inst_5 : add_monoid A,	_inst_6 : distrib_mul_action M A,	B : Type u_8,	_inst_9 : add_monoid B,	_inst_10 : distrib_mul_action M B,	f g : A →+[M] B,	h : ↑f = ↑g,	a : A	⊢ ⇑f a = ⇑g a
⊢ ∀ {R : Type u₁} [_inst_1 : comm_ring R] [_inst_2 : is_domain R] (a b : R), a ^ 2 = b ^ 2 → a = b ∨ a = -b
R : Type u₁,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	a b : R,	h : a ^ 2 = b ^ 2	⊢ a = b ∨ a = -b
⊢ ∀ {R : Type u_1} [_inst_1 : comm_ring R] {a b : R},	    a ^ 4 + 4 * b ^ 4 = (a ^ 2 - 2 * a * b + 2 * b ^ 2) * (a ^ 2 + 2 * a * b + 2 * b ^ 2)
R : Type u_1,	_inst_1 : comm_ring R,	a b : R	⊢ a ^ 4 + 4 * b ^ 4 = (a ^ 2 - 2 * a * b + 2 * b ^ 2) * (a ^ 2 + 2 * a * b + 2 * b ^ 2)
⊢ ∀ {R : Type u₁} [_inst_1 : semiring R] (a b : R) (n : ℕ), n • (a * b) = a * n • b
R : Type u₁,	_inst_1 : semiring R,	a b : R,	n : ℕ	⊢ n • (a * b) = a * n • b
⊢ ∀ {G₀ : Type u_2} [_inst_1 : group_with_zero G₀] {a : G₀}, a ≠ 0 → 1 / a * a = 1
G₀ : Type u_2,	_inst_1 : group_with_zero G₀,	a : G₀,	h : a ≠ 0	⊢ 1 / a * a = 1
⊢ ∀ {G₀ : Type u_2} [_inst_1 : group_with_zero G₀] (a : G₀), 1 / (1 / a) = a
G₀ : Type u_2,	_inst_1 : group_with_zero G₀,	a : G₀	⊢ 1 / (1 / a) = a
⊢ ∀ {G₀ : Type u_2} [_inst_1 : group_with_zero G₀] {a b c : G₀}, c ≠ 0 → (a / c = b / c ↔ a = b)
G₀ : Type u_2,	_inst_1 : group_with_zero G₀,	a b c : G₀,	hc : c ≠ 0	⊢ a / c = b / c ↔ a = b
⊢ ∀ {M : Type u_1} [_inst_1 : monoid_with_zero M] [_inst_2 : nontrivial M] {n : ℕ}, 0 ^ n = 0 ↔ 0 < n
M : Type u_1,	_inst_1 : monoid_with_zero M,	_inst_2 : nontrivial M,	n : ℕ	⊢ 0 ^ n = 0 ↔ 0 < n
2 goals	M : Type u_1,	_inst_1 : monoid_with_zero M,	_inst_2 : nontrivial M,	n : ℕ	⊢ 0 ^ n = 0 → 0 < n		M : Type u_1,	_inst_1 : monoid_with_zero M,	_inst_2 : nontrivial M,	n : ℕ	⊢ 0 < n → 0 ^ n = 0
2 goals	M : Type u_1,	_inst_1 : monoid_with_zero M,	_inst_2 : nontrivial M,	n : ℕ,	h : 0 ^ n = 0	⊢ 0 < n		M : Type u_1,	_inst_1 : monoid_with_zero M,	_inst_2 : nontrivial M,	n : ℕ	⊢ 0 < n → 0 ^ n = 0
2 goals	M : Type u_1,	_inst_1 : monoid_with_zero M,	_inst_2 : nontrivial M,	n : ℕ,	h : 0 ^ n = 0	⊢ n ≠ 0		M : Type u_1,	_inst_1 : monoid_with_zero M,	_inst_2 : nontrivial M,	n : ℕ	⊢ 0 < n → 0 ^ n = 0
2 goals	M : Type u_1,	_inst_1 : monoid_with_zero M,	_inst_2 : nontrivial M,	h : 0 ^ 0 = 0	⊢ false		M : Type u_1,	_inst_1 : monoid_with_zero M,	_inst_2 : nontrivial M,	n : ℕ	⊢ 0 < n → 0 ^ n = 0
M : Type u_1,	_inst_1 : monoid_with_zero M,	_inst_2 : nontrivial M,	n : ℕ	⊢ 0 < n → 0 ^ n = 0
M : Type u_1,	_inst_1 : monoid_with_zero M,	_inst_2 : nontrivial M,	n : ℕ,	h : 0 < n	⊢ 0 ^ n = 0
⊢ ∀ {V : Type u} [_inst_1 : category V] [_inst_2 : has_images V] (A : V) {B C : V} {g : B ⟶ C}	  [_inst_3 : has_zero_morphisms V] [_inst_4 : has_equalizers V] [_inst_5 : exact 0 g], (kernel_subobject g).arrow = 0
V : Type u,	_inst_1 : category V,	_inst_2 : has_images V,	A B C : V,	g : B ⟶ C,	_inst_3 : has_zero_morphisms V,	_inst_4 : has_equalizers V,	_inst_5 : exact 0 g	⊢ (kernel_subobject g).arrow = 0
V : Type u,	_inst_1 : category V,	_inst_2 : has_images V,	A B C : V,	g : B ⟶ C,	_inst_3 : has_zero_morphisms V,	_inst_4 : has_equalizers V,	_inst_5 : exact 0 g	⊢ factor_thru_image_subobject 0 ≫ image_to_kernel 0 g exact.w ≫ (kernel_subobject g).arrow =	    factor_thru_image_subobject 0 ≫ image_to_kernel 0 g exact.w ≫ 0
⊢ ∀ {V : Type u} [_inst_1 : category V] [_inst_2 : has_zero_morphisms V] (X₀ X₁ X₂ : V) (d₀ : X₀ ⟶ X₁)	  (d₁ : X₁ ⟶ X₂) (s : d₀ ≫ d₁ = 0)	  (succ :	    Π (t : Σ' (X₀ X₁ X₂ : V) (d₀ : X₀ ⟶ X₁) (d₁ : X₁ ⟶ X₂), d₀ ≫ d₁ = 0),	      Σ' (X₃ : V) (d₂ : t.snd.snd.fst ⟶ X₃), t.snd.snd.snd.snd.fst ≫ d₂ = 0),	    (mk X₀ X₁ X₂ d₀ d₁ s succ).d 1 2 = d₁
V : Type u,	_inst_1 : category V,	_inst_2 : has_zero_morphisms V,	X₀ X₁ X₂ : V,	d₀ : X₀ ⟶ X₁,	d₁ : X₁ ⟶ X₂,	s : d₀ ≫ d₁ = 0,	succ :	  Π (t : Σ' (X₀ X₁ X₂ : V) (d₀ : X₀ ⟶ X₁) (d₁ : X₁ ⟶ X₂), d₀ ≫ d₁ = 0),	    Σ' (X₃ : V) (d₂ : t.snd.snd.fst ⟶ X₃), t.snd.snd.snd.snd.fst ≫ d₂ = 0	⊢ (mk X₀ X₁ X₂ d₀ d₁ s succ).d 1 2 = d₁
V : Type u,	_inst_1 : category V,	_inst_2 : has_zero_morphisms V,	X₀ X₁ X₂ : V,	d₀ : X₀ ⟶ X₁,	d₁ : X₁ ⟶ X₂,	s : d₀ ≫ d₁ = 0,	succ :	  Π (t : Σ' (X₀ X₁ X₂ : V) (d₀ : X₀ ⟶ X₁) (d₁ : X₁ ⟶ X₂), d₀ ≫ d₁ = 0),	    Σ' (X₃ : V) (d₂ : t.snd.snd.fst ⟶ X₃), t.snd.snd.snd.snd.fst ≫ d₂ = 0	⊢ ite (2 = 1 + 1) (d₁ ≫ 𝟙 X₂) 0 = d₁
⊢ ∀ {ι : Type u_1} {V : Type u} [_inst_1 : category V] [_inst_2 : has_zero_morphisms V] {c : complex_shape ι}	  [_inst_3 : has_zero_object V] [_inst_4 : has_kernels V] {C₁ C₂ C₃ : homological_complex V c} (f : C₁ ⟶ C₂)	  (g : C₂ ⟶ C₃) (i : ι), cycles_map (f ≫ g) i = cycles_map f i ≫ cycles_map g i
ι : Type u_1,	V : Type u,	_inst_1 : category V,	_inst_2 : has_zero_morphisms V,	c : complex_shape ι,	_inst_3 : has_zero_object V,	_inst_4 : has_kernels V,	C₁ C₂ C₃ : homological_complex V c,	f : C₁ ⟶ C₂,	g : C₂ ⟶ C₃,	i : ι	⊢ cycles_map (f ≫ g) i = cycles_map f i ≫ cycles_map g i
ι : Type u_1,	V : Type u,	_inst_1 : category V,	_inst_2 : has_zero_morphisms V,	c : complex_shape ι,	_inst_3 : has_zero_object V,	_inst_4 : has_kernels V,	C₁ C₂ C₃ : homological_complex V c,	f : C₁ ⟶ C₂,	g : C₂ ⟶ C₃,	i : ι	⊢ (C₃.cycles i).factor_thru ((C₁.cycles i).arrow ≫ (f ≫ g).f i) _ =	    (C₂.cycles i).factor_thru ((C₁.cycles i).arrow ≫ f.f i) _ ≫	      (C₃.cycles i).factor_thru ((C₂.cycles i).arrow ≫ g.f i) _
⊢ ∀ {V : Type u} [_inst_1 : category V] [_inst_2 : has_zero_morphisms V] {A B C : V} (f : A ⟶ B)	  [_inst_3 : has_image f] (g : B ⟶ C) [_inst_4 : has_kernel g] (w : f ≫ g = 0)	  [_inst_5 : has_cokernel (image_to_kernel f g w)] {D : V} (k : ↑(kernel_subobject g) ⟶ D)	  (p : image_to_kernel f g w ≫ k = 0), homology.π f g w ≫ homology.desc f g w k p = k
V : Type u,	_inst_1 : category V,	_inst_2 : has_zero_morphisms V,	A B C : V,	f : A ⟶ B,	_inst_3 : has_image f,	g : B ⟶ C,	_inst_4 : has_kernel g,	w : f ≫ g = 0,	_inst_5 : has_cokernel (image_to_kernel f g w),	D : V,	k : ↑(kernel_subobject g) ⟶ D,	p : image_to_kernel f g w ≫ k = 0	⊢ homology.π f g w ≫ homology.desc f g w k p = k
⊢ ∀ {α : Type u_1} {M : Type u_4} [_inst_1 : mul_zero_class M] {a : α} (s : set α) (f g : α → M),	    s.indicator (λ (a : α), f a * g a) a = f a * s.indicator g a
α : Type u_1,	M : Type u_4,	_inst_1 : mul_zero_class M,	a : α,	s : set α,	f g : α → M	⊢ s.indicator (λ (a : α), f a * g a) a = f a * s.indicator g a
α : Type u_1,	M : Type u_4,	_inst_1 : mul_zero_class M,	a : α,	s : set α,	f g : α → M	⊢ ite (a ∈ s) (f a * g a) 0 = f a * ite (a ∈ s) (g a) 0
2 goals	α : Type u_1,	M : Type u_4,	_inst_1 : mul_zero_class M,	a : α,	s : set α,	f g : α → M,	h : a ∈ s	⊢ f a * g a = f a * g a		α : Type u_1,	M : Type u_4,	_inst_1 : mul_zero_class M,	a : α,	s : set α,	f g : α → M,	h : a ∉ s	⊢ 0 = f a * 0
α : Type u_1,	M : Type u_4,	_inst_1 : mul_zero_class M,	a : α,	s : set α,	f g : α → M,	h : a ∉ s	⊢ 0 = f a * 0
⊢ ∀ {α : Type u_1} {ι : Sort u_2} {M : Type u_3} [_inst_3 : complete_lattice M] [_inst_4 : has_one M],	    ⊥ = 1 →	    ∀ (s : ι → set α) (f : α → M) (x : α),	      (⋃ (i : ι), s i).mul_indicator f x = ⨆ (i : ι), (s i).mul_indicator f x
α : Type u_1,	ι : Sort u_2,	M : Type u_3,	_inst_3 : complete_lattice M,	_inst_4 : has_one M,	h1 : ⊥ = 1,	s : ι → set α,	f : α → M,	x : α	⊢ (⋃ (i : ι), s i).mul_indicator f x = ⨆ (i : ι), (s i).mul_indicator f x
2 goals	α : Type u_1,	ι : Sort u_2,	M : Type u_3,	_inst_3 : complete_lattice M,	_inst_4 : has_one M,	h1 : ⊥ = 1,	s : ι → set α,	f : α → M,	x : α,	hx : x ∈ ⋃ (i : ι), s i	⊢ (⋃ (i : ι), s i).mul_indicator f x = ⨆ (i : ι), (s i).mul_indicator f x		α : Type u_1,	ι : Sort u_2,	M : Type u_3,	_inst_3 : complete_lattice M,	_inst_4 : has_one M,	h1 : ⊥ = 1,	s : ι → set α,	f : α → M,	x : α,	hx : x ∉ ⋃ (i : ι), s i	⊢ (⋃ (i : ι), s i).mul_indicator f x = ⨆ (i : ι), (s i).mul_indicator f x
2 goals	α : Type u_1,	ι : Sort u_2,	M : Type u_3,	_inst_3 : complete_lattice M,	_inst_4 : has_one M,	h1 : ⊥ = 1,	s : ι → set α,	f : α → M,	x : α,	hx : x ∈ ⋃ (i : ι), s i	⊢ f x = ⨆ (i : ι), (s i).mul_indicator f x		α : Type u_1,	ι : Sort u_2,	M : Type u_3,	_inst_3 : complete_lattice M,	_inst_4 : has_one M,	h1 : ⊥ = 1,	s : ι → set α,	f : α → M,	x : α,	hx : x ∉ ⋃ (i : ι), s i	⊢ (⋃ (i : ι), s i).mul_indicator f x = ⨆ (i : ι), (s i).mul_indicator f x
2 goals	α : Type u_1,	ι : Sort u_2,	M : Type u_3,	_inst_3 : complete_lattice M,	_inst_4 : has_one M,	h1 : ⊥ = 1,	s : ι → set α,	f : α → M,	x : α,	hx : ∃ (i : ι), x ∈ s i	⊢ f x = ⨆ (i : ι), (s i).mul_indicator f x		α : Type u_1,	ι : Sort u_2,	M : Type u_3,	_inst_3 : complete_lattice M,	_inst_4 : has_one M,	h1 : ⊥ = 1,	s : ι → set α,	f : α → M,	x : α,	hx : x ∉ ⋃ (i : ι), s i	⊢ (⋃ (i : ι), s i).mul_indicator f x = ⨆ (i : ι), (s i).mul_indicator f x
2 goals	α : Type u_1,	ι : Sort u_2,	M : Type u_3,	_inst_3 : complete_lattice M,	_inst_4 : has_one M,	h1 : ⊥ = 1,	s : ι → set α,	f : α → M,	x : α,	hx : ∃ (i : ι), x ∈ s i	⊢ f x ≤ ⨆ (i : ι), (s i).mul_indicator f x		α : Type u_1,	ι : Sort u_2,	M : Type u_3,	_inst_3 : complete_lattice M,	_inst_4 : has_one M,	h1 : ⊥ = 1,	s : ι → set α,	f : α → M,	x : α,	hx : x ∉ ⋃ (i : ι), s i	⊢ (⋃ (i : ι), s i).mul_indicator f x = ⨆ (i : ι), (s i).mul_indicator f x
2 goals	α : Type u_1,	ι : Sort u_2,	M : Type u_3,	_inst_3 : complete_lattice M,	_inst_4 : has_one M,	h1 : ⊥ = 1,	s : ι → set α,	f : α → M,	x : α,	i : ι,	hi : x ∈ s i	⊢ f x ≤ ⨆ (i : ι), (s i).mul_indicator f x		α : Type u_1,	ι : Sort u_2,	M : Type u_3,	_inst_3 : complete_lattice M,	_inst_4 : has_one M,	h1 : ⊥ = 1,	s : ι → set α,	f : α → M,	x : α,	hx : x ∉ ⋃ (i : ι), s i	⊢ (⋃ (i : ι), s i).mul_indicator f x = ⨆ (i : ι), (s i).mul_indicator f x
α : Type u_1,	ι : Sort u_2,	M : Type u_3,	_inst_3 : complete_lattice M,	_inst_4 : has_one M,	h1 : ⊥ = 1,	s : ι → set α,	f : α → M,	x : α,	hx : x ∉ ⋃ (i : ι), s i	⊢ (⋃ (i : ι), s i).mul_indicator f x = ⨆ (i : ι), (s i).mul_indicator f x
α : Type u_1,	ι : Sort u_2,	M : Type u_3,	_inst_3 : complete_lattice M,	_inst_4 : has_one M,	h1 : ⊥ = 1,	s : ι → set α,	f : α → M,	x : α,	hx : x ∉ ⋃ (i : ι), s i	⊢ 1 = ⨆ (i : ι), (s i).mul_indicator f x
α : Type u_1,	ι : Sort u_2,	M : Type u_3,	_inst_3 : complete_lattice M,	_inst_4 : has_one M,	h1 : ⊥ = 1,	s : ι → set α,	f : α → M,	x : α,	hx : ∀ (x_1 : ι), x ∉ s x_1	⊢ 1 = ⨆ (i : ι), (s i).mul_indicator f x
⊢ ∀ {α : Type u} [_inst_1 : monoid α] (a b : α) [_inst_2 : invertible b], a * b * ⅟ b = a
α : Type u,	_inst_1 : monoid α,	a b : α,	_inst_2 : invertible b	⊢ a * b * ⅟ b = a
⊢ ∀ {R : Type u} {L : Type v} [_inst_1 : comm_ring R] [_inst_2 : lie_ring L] [_inst_3 : lie_algebra R L]	  (I : lie_ideal R L) {I₁ I₂ : lie_ideal R L},	    ⁅comap I.incl I₁,comap I.incl I₂⁆ = comap I.incl ⁅I ⊓ I₁,I ⊓ I₂⁆
R : Type u,	L : Type v,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	I I₁ I₂ : lie_ideal R L	⊢ ⁅comap I.incl I₁,comap I.incl I₂⁆ = comap I.incl ⁅I ⊓ I₁,I ⊓ I₂⁆
R : Type u,	L : Type v,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	I I₁ I₂ : lie_ideal R L	⊢ ⁅comap I.incl I₁,comap I.incl I₂⁆ =	    comap I.incl ⁅I.incl.ideal_range ⊓ I₁,I.incl.ideal_range ⊓ I₂⁆
2 goals	R : Type u,	L : Type v,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	I I₁ I₂ : lie_ideal R L	⊢ ⁅comap I.incl I₁,comap I.incl I₂⁆ = ⁅comap I.incl I₁,comap I.incl I₂⁆ ⊔ I.incl.ker		R : Type u,	L : Type v,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	I I₁ I₂ : lie_ideal R L	⊢ I.incl.is_ideal_morphism
R : Type u,	L : Type v,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	I I₁ I₂ : lie_ideal R L	⊢ I.incl.is_ideal_morphism
⊢ ∀ {R : Type u} {L : Type v} {L' : Type w} [_inst_1 : comm_ring R] [_inst_2 : lie_ring L]	  [_inst_3 : lie_algebra R L] [_inst_4 : lie_ring L'] [_inst_5 : lie_algebra R L'],	    (L ≃ₗ⁅R⁆ L') → (is_nilpotent R L ↔ is_nilpotent R L')
R : Type u,	L : Type v,	L' : Type w,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	e : L ≃ₗ⁅R⁆ L'	⊢ is_nilpotent R L ↔ is_nilpotent R L'
2 goals	R : Type u,	L : Type v,	L' : Type w,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	e : L ≃ₗ⁅R⁆ L'	⊢ is_nilpotent R L → is_nilpotent R L'		R : Type u,	L : Type v,	L' : Type w,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	e : L ≃ₗ⁅R⁆ L'	⊢ is_nilpotent R L' → is_nilpotent R L
2 goals	R : Type u,	L : Type v,	L' : Type w,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	e : L ≃ₗ⁅R⁆ L',	h : is_nilpotent R L	⊢ is_nilpotent R L'		R : Type u,	L : Type v,	L' : Type w,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	e : L ≃ₗ⁅R⁆ L'	⊢ is_nilpotent R L' → is_nilpotent R L
R : Type u,	L : Type v,	L' : Type w,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	e : L ≃ₗ⁅R⁆ L'	⊢ is_nilpotent R L' → is_nilpotent R L
R : Type u,	L : Type v,	L' : Type w,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	e : L ≃ₗ⁅R⁆ L',	h : is_nilpotent R L'	⊢ is_nilpotent R L
⊢ ∀ {R : Type u} [_inst_1 : comm_ring R] (A : Type v) [_inst_8 : ring A] [_inst_9 : algebra R A],	    ⇑(ad R A) = algebra.lmul_left R - algebra.lmul_right R
R : Type u,	_inst_1 : comm_ring R,	A : Type v,	_inst_8 : ring A,	_inst_9 : algebra R A	⊢ ⇑(ad R A) = algebra.lmul_left R - algebra.lmul_right R
R : Type u,	_inst_1 : comm_ring R,	A : Type v,	_inst_8 : ring A,	_inst_9 : algebra R A,	a b : A	⊢ ⇑(⇑(ad R A) a) b = ⇑((algebra.lmul_left R - algebra.lmul_right R) a) b
⊢ ∀ {R : Type u_1} [_inst_1 : semiring R] (m : ℕ), m • 1 = ↑m
R : Type u_1,	_inst_1 : semiring R,	m : ℕ	⊢ m • 1 = ↑m
⊢ ∀ {R : Type u_1} {M : Type u_9} {M₂ : Type u_11} [_inst_1 : semiring R] [_inst_2 : add_comm_monoid M]	  [_inst_3 : add_comm_monoid M₂] [_inst_4 : module R M] [_inst_5 : module R M₂] {f g : M →+[R] M₂},	    ↑f = ↑g → f = g
R : Type u_1,	M : Type u_9,	M₂ : Type u_11,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : add_comm_monoid M₂,	_inst_4 : module R M,	_inst_5 : module R M₂,	f g : M →+[R] M₂,	h : ↑f = ↑g	⊢ f = g
R : Type u_1,	M : Type u_9,	M₂ : Type u_11,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : add_comm_monoid M₂,	_inst_4 : module R M,	_inst_5 : module R M₂,	f g : M →+[R] M₂,	h : ↑f = ↑g,	m : M	⊢ ⇑f m = ⇑g m
⊢ ∀ {k : Type u₁} {G : Type u₂} [_inst_1 : comm_semiring k] [_inst_2 : add_monoid G] {A : Type u₃}	  [_inst_3 : semiring A] [_inst_4 : algebra k A] (F : multiplicative G →* A) (f : monoid_algebra k G),	    ⇑(⇑(lift k G A) F) f = sum f (λ (a : G) (b : k), b • ⇑F (⇑multiplicative.of_add a))
k : Type u₁,	G : Type u₂,	_inst_1 : comm_semiring k,	_inst_2 : add_monoid G,	A : Type u₃,	_inst_3 : semiring A,	_inst_4 : algebra k A,	F : multiplicative G →* A,	f : monoid_algebra k G	⊢ ⇑(⇑(lift k G A) F) f = sum f (λ (a : G) (b : k), b • ⇑F (⇑multiplicative.of_add a))
⊢ ∀ {R : Type u} {A : Type v} {B : Type w} [_inst_1 : monoid R] [_inst_2 : non_unital_non_assoc_semiring A]	  [_inst_3 : distrib_mul_action R A] [_inst_4 : non_unital_non_assoc_semiring B] [_inst_5 : distrib_mul_action R B]	  (f : non_unital_alg_hom R A B) (h₁ : ∀ (m : R) (x : A), ⇑f (m • x) = m • ⇑f x) (h₂ : ⇑f 0 = 0)	  (h₃ : ∀ (x y : A), ⇑f (x + y) = ⇑f x + ⇑f y) (h₄ : ∀ (x y : A), ⇑f (x * y) = ⇑f x * ⇑f y),	    ↑{to_fun := ⇑f, map_smul' := h₁, map_zero' := h₂, map_add' := h₃, map_mul' := h₄} =	      {to_fun := ⇑f, map_smul' := h₁, map_zero' := h₂, map_add' := h₃}
R : Type u,	A : Type v,	B : Type w,	_inst_1 : monoid R,	_inst_2 : non_unital_non_assoc_semiring A,	_inst_3 : distrib_mul_action R A,	_inst_4 : non_unital_non_assoc_semiring B,	_inst_5 : distrib_mul_action R B,	f : non_unital_alg_hom R A B,	h₁ : ∀ (m : R) (x : A), ⇑f (m • x) = m • ⇑f x,	h₂ : ⇑f 0 = 0,	h₃ : ∀ (x y : A), ⇑f (x + y) = ⇑f x + ⇑f y,	h₄ : ∀ (x y : A), ⇑f (x * y) = ⇑f x * ⇑f y	⊢ ↑{to_fun := ⇑f, map_smul' := h₁, map_zero' := h₂, map_add' := h₃, map_mul' := h₄} =	    {to_fun := ⇑f, map_smul' := h₁, map_zero' := h₂, map_add' := h₃}
R : Type u,	A : Type v,	B : Type w,	_inst_1 : monoid R,	_inst_2 : non_unital_non_assoc_semiring A,	_inst_3 : distrib_mul_action R A,	_inst_4 : non_unital_non_assoc_semiring B,	_inst_5 : distrib_mul_action R B,	f : non_unital_alg_hom R A B,	h₁ : ∀ (m : R) (x : A), ⇑f (m • x) = m • ⇑f x,	h₂ : ⇑f 0 = 0,	h₃ : ∀ (x y : A), ⇑f (x + y) = ⇑f x + ⇑f y,	h₄ : ∀ (x y : A), ⇑f (x * y) = ⇑f x * ⇑f y,	x : A	⊢ ⇑↑{to_fun := ⇑f, map_smul' := h₁, map_zero' := h₂, map_add' := h₃, map_mul' := h₄} x =	    ⇑{to_fun := ⇑f, map_smul' := h₁, map_zero' := h₂, map_add' := h₃} x
⊢ ∀ {α : Type u_1} [_inst_1 : preorder α] [_inst_2 : decidable_rel has_lt.lt] (a b : α), (cmp a b).swap = cmp b a
α : Type u_1,	_inst_1 : preorder α,	_inst_2 : decidable_rel has_lt.lt,	a b : α	⊢ (cmp a b).swap = cmp b a
α : Type u_1,	_inst_1 : preorder α,	_inst_2 : decidable_rel has_lt.lt,	a b : α	⊢ (ite (a < b) ordering.lt (ite (b < a) ordering.gt ordering.eq)).swap =	    ite (b < a) ordering.lt (ite (a < b) ordering.gt ordering.eq)
2 goals	α : Type u_1,	_inst_1 : preorder α,	_inst_2 : decidable_rel has_lt.lt,	a b : α,	h : a < b	⊢ (ite (a < b) ordering.lt (ite (b < a) ordering.gt ordering.eq)).swap =	    ite (b < a) ordering.lt (ite (a < b) ordering.gt ordering.eq)		α : Type u_1,	_inst_1 : preorder α,	_inst_2 : decidable_rel has_lt.lt,	a b : α,	h : ¬a < b	⊢ (ite (a < b) ordering.lt (ite (b < a) ordering.gt ordering.eq)).swap =	    ite (b < a) ordering.lt (ite (a < b) ordering.gt ordering.eq)
3 goals	α : Type u_1,	_inst_1 : preorder α,	_inst_2 : decidable_rel has_lt.lt,	a b : α,	h : a < b,	h₂ : b < a	⊢ (ite (a < b) ordering.lt (ite (b < a) ordering.gt ordering.eq)).swap =	    ite (b < a) ordering.lt (ite (a < b) ordering.gt ordering.eq)		α : Type u_1,	_inst_1 : preorder α,	_inst_2 : decidable_rel has_lt.lt,	a b : α,	h : a < b,	h₂ : ¬b < a	⊢ (ite (a < b) ordering.lt (ite (b < a) ordering.gt ordering.eq)).swap =	    ite (b < a) ordering.lt (ite (a < b) ordering.gt ordering.eq)		α : Type u_1,	_inst_1 : preorder α,	_inst_2 : decidable_rel has_lt.lt,	a b : α,	h : ¬a < b	⊢ (ite (a < b) ordering.lt (ite (b < a) ordering.gt ordering.eq)).swap =	    ite (b < a) ordering.lt (ite (a < b) ordering.gt ordering.eq)
3 goals	α : Type u_1,	_inst_1 : preorder α,	_inst_2 : decidable_rel has_lt.lt,	a b : α,	h : a < b,	h₂ : b < a	⊢ false		α : Type u_1,	_inst_1 : preorder α,	_inst_2 : decidable_rel has_lt.lt,	a b : α,	h : a < b,	h₂ : ¬b < a	⊢ (ite (a < b) ordering.lt (ite (b < a) ordering.gt ordering.eq)).swap =	    ite (b < a) ordering.lt (ite (a < b) ordering.gt ordering.eq)		α : Type u_1,	_inst_1 : preorder α,	_inst_2 : decidable_rel has_lt.lt,	a b : α,	h : ¬a < b	⊢ (ite (a < b) ordering.lt (ite (b < a) ordering.gt ordering.eq)).swap =	    ite (b < a) ordering.lt (ite (a < b) ordering.gt ordering.eq)
2 goals	α : Type u_1,	_inst_1 : preorder α,	_inst_2 : decidable_rel has_lt.lt,	a b : α,	h : a < b,	h₂ : ¬b < a	⊢ (ite (a < b) ordering.lt (ite (b < a) ordering.gt ordering.eq)).swap =	    ite (b < a) ordering.lt (ite (a < b) ordering.gt ordering.eq)		α : Type u_1,	_inst_1 : preorder α,	_inst_2 : decidable_rel has_lt.lt,	a b : α,	h : ¬a < b	⊢ (ite (a < b) ordering.lt (ite (b < a) ordering.gt ordering.eq)).swap =	    ite (b < a) ordering.lt (ite (a < b) ordering.gt ordering.eq)
α : Type u_1,	_inst_1 : preorder α,	_inst_2 : decidable_rel has_lt.lt,	a b : α,	h : ¬a < b	⊢ (ite (a < b) ordering.lt (ite (b < a) ordering.gt ordering.eq)).swap =	    ite (b < a) ordering.lt (ite (a < b) ordering.gt ordering.eq)
2 goals	α : Type u_1,	_inst_1 : preorder α,	_inst_2 : decidable_rel has_lt.lt,	a b : α,	h : ¬a < b,	h₂ : b < a	⊢ (ite (a < b) ordering.lt (ite (b < a) ordering.gt ordering.eq)).swap =	    ite (b < a) ordering.lt (ite (a < b) ordering.gt ordering.eq)		α : Type u_1,	_inst_1 : preorder α,	_inst_2 : decidable_rel has_lt.lt,	a b : α,	h : ¬a < b,	h₂ : ¬b < a	⊢ (ite (a < b) ordering.lt (ite (b < a) ordering.gt ordering.eq)).swap =	    ite (b < a) ordering.lt (ite (a < b) ordering.gt ordering.eq)
α : Type u_1,	_inst_1 : preorder α,	_inst_2 : decidable_rel has_lt.lt,	a b : α,	h : ¬a < b,	h₂ : ¬b < a	⊢ (ite (a < b) ordering.lt (ite (b < a) ordering.gt ordering.eq)).swap =	    ite (b < a) ordering.lt (ite (a < b) ordering.gt ordering.eq)
⊢ ∀ {α : Type u_1} [_inst_1 : linear_order α] (x : α), cmp x x = ordering.eq
α : Type u_1,	_inst_1 : linear_order α,	x : α	⊢ cmp x x = ordering.eq
⊢ ∀ {α : Type u_1} [_inst_1 : linear_ordered_field α] {a b c : α}, 0 < b → (a * b⁻¹ < c ↔ a < c * b)
α : Type u_1,	_inst_1 : linear_ordered_field α,	a b c : α,	h : 0 < b	⊢ a * b⁻¹ < c ↔ a < c * b
⊢ ∀ {α : Type u_1} [_inst_1 : linear_ordered_field α] {a b : α}, b < 0 → (a / b < 1 ↔ b < a)
α : Type u_1,	_inst_1 : linear_ordered_field α,	a b : α,	hb : b < 0	⊢ a / b < 1 ↔ b < a
⊢ ∀ {α : Type u_1} [_inst_1 : linear_ordered_field α] {a b : α},	    0 < a → 0 < b → (1 / a ≤ b ↔ 1 / b ≤ a)
α : Type u_1,	_inst_1 : linear_ordered_field α,	a b : α,	ha : 0 < a,	hb : 0 < b	⊢ 1 / a ≤ b ↔ 1 / b ≤ a
⊢ ∀ {α : Type u} [_inst_1 : comm_group α] [_inst_2 : has_lt α]	  [_inst_3 : covariant_class α α has_mul.mul has_lt.lt] {a b c d : α}, a * b⁻¹ < c * d⁻¹ ↔ a * d < c * b
α : Type u,	_inst_1 : comm_group α,	_inst_2 : has_lt α,	_inst_3 : covariant_class α α has_mul.mul has_lt.lt,	a b c d : α	⊢ a * b⁻¹ < c * d⁻¹ ↔ a * d < c * b
⊢ ∀ {α : Type u} [_inst_1 : group α] [_inst_2 : has_lt α]	  [_inst_3 : covariant_class α α (swap has_mul.mul) has_lt.lt] {a b : α}, 1 < a / b ↔ b < a
α : Type u,	_inst_1 : group α,	_inst_2 : has_lt α,	_inst_3 : covariant_class α α (swap has_mul.mul) has_lt.lt,	a b : α	⊢ 1 < a / b ↔ b < a
⊢ ∀ {α : Type u} [_inst_1 : linear_ordered_semiring α] {a b c : α}, 0 < c → (c * a < c * b ↔ a < b)
α : Type u,	_inst_1 : linear_ordered_semiring α,	a b c : α,	h : 0 < c	⊢ c * a < c * b ↔ a < b
α : Type u,	_inst_1 : linear_ordered_semiring α,	a b c : α,	h : 0 < c,	_inst : decidable_rel has_le.le	⊢ c * a < c * b ↔ a < b
⊢ ∀ {R : Type u_1} [_inst_1 : rack R] {x y : R}, shelf.act (shelf.act x x) y = shelf.act x y
R : Type u_1,	_inst_1 : rack R,	x y : R	⊢ shelf.act (shelf.act x x) y = shelf.act x y
⊢ ∀ {R : Type u_1} [_inst_1 : comm_ring R] {c₁ c₂ : R} (a : quaternion_algebra R c₁ c₂),	    ⇑conj a + a = 2 * ↑(a.re)
R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R,	a : quaternion_algebra R c₁ c₂	⊢ ⇑conj a + a = 2 * ↑(a.re)
⊢ ∀ {R : Type u_1} {A : Type u_2} [_inst_1 : comm_ring R] [_inst_2 : ring A] [_inst_4 : algebra R A] {c₁ c₂ : R}	  (q : basis A c₁ c₂), q.k * q.j = c₂ • q.i
R : Type u_1,	A : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : ring A,	_inst_4 : algebra R A,	c₁ c₂ : R,	q : basis A c₁ c₂	⊢ q.k * q.j = c₂ • q.i
⊢ ∀ {R : Type u_1} [_inst_1 : mul_zero_class R], ¬is_left_regular 0 ↔ nontrivial R
R : Type u_1,	_inst_1 : mul_zero_class R	⊢ ¬is_left_regular 0 ↔ nontrivial R
R : Type u_1,	_inst_1 : mul_zero_class R	⊢ (¬∃ (x y : R), x ≠ y) ↔ ∀ (x y : R), x = y
R : Type u_1,	_inst_1 : mul_zero_class R	⊢ (∀ (x y : R), x = y) ↔ ∀ (x y : R), x = y
⊢ ∀ {R₁ : Type u_1} {R₂ : Type u_2} [_inst_1 : semiring R₁] [_inst_2 : semiring R₂] {σ : R₁ →+* R₂}	  {σ' : R₂ →+* R₁} [_inst_4 : ring_hom_inv_pair σ σ'] {x : R₂}, ⇑σ (⇑σ' x) = x
R₁ : Type u_1,	R₂ : Type u_2,	_inst_1 : semiring R₁,	_inst_2 : semiring R₂,	σ : R₁ →+* R₂,	σ' : R₂ →+* R₁,	_inst_4 : ring_hom_inv_pair σ σ',	x : R₂	⊢ ⇑σ (⇑σ' x) = x
R₁ : Type u_1,	R₂ : Type u_2,	_inst_1 : semiring R₁,	_inst_2 : semiring R₂,	σ : R₁ →+* R₂,	σ' : R₂ →+* R₁,	_inst_4 : ring_hom_inv_pair σ σ',	x : R₂	⊢ ⇑(ring_hom.id R₂) x = x
⊢ ∀ {R : Type u} [_inst_1 : comm_ring R] (x : prime_spectrum R), vanishing_ideal {x} = x.as_ideal
R : Type u,	_inst_1 : comm_ring R,	x : prime_spectrum R	⊢ vanishing_ideal {x} = x.as_ideal
⊢ ∀ {R : Type u} [_inst_1 : comm_ring R] {I : ideal R}, zero_locus ↑I = ∅ ↔ I = ⊤
R : Type u,	_inst_1 : comm_ring R,	I : ideal R	⊢ zero_locus ↑I = ∅ ↔ I = ⊤
2 goals	R : Type u,	_inst_1 : comm_ring R,	I : ideal R	⊢ zero_locus ↑I = ∅ → I = ⊤		R : Type u,	_inst_1 : comm_ring R,	I : ideal R	⊢ I = ⊤ → zero_locus ↑I = ∅
2 goals	R : Type u,	_inst_1 : comm_ring R,	I : ideal R	⊢ ¬I = ⊤ → ¬zero_locus ↑I = ∅		R : Type u,	_inst_1 : comm_ring R,	I : ideal R	⊢ I = ⊤ → zero_locus ↑I = ∅
2 goals	R : Type u,	_inst_1 : comm_ring R,	I : ideal R,	h : ¬I = ⊤	⊢ ¬zero_locus ↑I = ∅		R : Type u,	_inst_1 : comm_ring R,	I : ideal R	⊢ I = ⊤ → zero_locus ↑I = ∅
2 goals	R : Type u,	_inst_1 : comm_ring R,	I : ideal R,	h : ¬I = ⊤	⊢ (zero_locus ↑I).nonempty		R : Type u,	_inst_1 : comm_ring R,	I : ideal R	⊢ I = ⊤ → zero_locus ↑I = ∅
2 goals	R : Type u,	_inst_1 : comm_ring R,	I : ideal R,	h : ¬I = ⊤,	M : ideal R,	hM : M.is_maximal,	hIM : I ≤ M	⊢ (zero_locus ↑I).nonempty		R : Type u,	_inst_1 : comm_ring R,	I : ideal R	⊢ I = ⊤ → zero_locus ↑I = ∅
R : Type u,	_inst_1 : comm_ring R,	I : ideal R	⊢ I = ⊤ → zero_locus ↑I = ∅
R : Type u,	_inst_1 : comm_ring R	⊢ zero_locus ↑⊤ = ∅
R : Type u,	_inst_1 : comm_ring R	⊢ 1 ∈ ↑⊤
⊢ ∀ {R : Type u} [_inst_1 : comm_ring R] (s : set (set R)),	    zero_locus (⋃ (s' : set R) (H : s' ∈ s), s') = ⋂ (s' : set R) (H : s' ∈ s), zero_locus s'
R : Type u,	_inst_1 : comm_ring R,	s : set (set R)	⊢ zero_locus (⋃ (s' : set R) (H : s' ∈ s), s') = ⋂ (s' : set R) (H : s' ∈ s), zero_locus s'
⊢ ∀ {C : Type u} [_inst_1 : category C] (X : cosimplicial_object C) {n : ℕ} {i : fin (n + 2)} {j : fin (n + 1)},	    ⇑fin.cast_succ j < i → X.δ i.succ ≫ X.σ (⇑fin.cast_succ j) = X.σ j ≫ X.δ i
C : Type u,	_inst_1 : category C,	X : cosimplicial_object C,	n : ℕ,	i : fin (n + 2),	j : fin (n + 1),	H : ⇑fin.cast_succ j < i	⊢ X.δ i.succ ≫ X.σ (⇑fin.cast_succ j) = X.σ j ≫ X.δ i
C : Type u,	_inst_1 : category C,	X : cosimplicial_object C,	n : ℕ,	i : fin (n + 2),	j : fin (n + 1),	H : ⇑fin.cast_succ j < i	⊢ X.map (simplex_category.δ i.succ) ≫ X.map (simplex_category.σ (⇑fin.cast_succ j)) =	    X.map (simplex_category.σ j) ≫ X.map (simplex_category.δ i)
⊢ ∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field 𝕜] {E : Type u_2} [_inst_2 : normed_group E]	  [_inst_3 : normed_space 𝕜 E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space 𝕜 F]	  (p : formal_multilinear_series 𝕜 E F) {r : nnreal},	    ↑r < p.radius → summable (λ (n : ℕ), ∥p n∥ * ↑r ^ n)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	p : formal_multilinear_series 𝕜 E F,	r : nnreal,	h : ↑r < p.radius	⊢ summable (λ (n : ℕ), ∥p n∥ * ↑r ^ n)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	p : formal_multilinear_series 𝕜 E F,	r : nnreal,	h : ↑r < p.radius,	a : ℝ,	ha : a ∈ Ioo 0 1,	C : ℝ,	hp : ∀ (n : ℕ), ∥p n∥ * ↑r ^ n ≤ C * a ^ n,	hC : 0 < C	⊢ summable (λ (n : ℕ), ∥p n∥ * ↑r ^ n)
⊢ ∀ (𝕜 : Type u_1) [_inst_1 : nondiscrete_normed_field 𝕜] {E : Type u_2} [_inst_2 : normed_group E]	  [_inst_3 : normed_space 𝕜 E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space 𝕜 F]	  [_inst_8 : complete_space F] (f : E → F), is_open {x : E | analytic_at 𝕜 f x}
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	_inst_8 : complete_space F,	f : E → F	⊢ is_open {x : E | analytic_at 𝕜 f x}
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	_inst_8 : complete_space F,	f : E → F	⊢ ∀ (a : E), a ∈ {x : E | analytic_at 𝕜 f x} → {x : E | analytic_at 𝕜 f x} ∈ nhds a
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	_inst_8 : complete_space F,	f : E → F,	x : E,	p : formal_multilinear_series 𝕜 E F,	r : ennreal,	hr : has_fpower_series_on_ball f p x r	⊢ {x : E | analytic_at 𝕜 f x} ∈ nhds x
⊢ ∀ {α : Type u_1} {E : Type u_3} {F : Type u_4} [_inst_1 : has_norm E] [_inst_2 : has_norm F] {c : ℝ}	  {f : α → E} {g : α → F} {l : filter α}, is_O_with c f g l → is_O f g l
α : Type u_1,	E : Type u_3,	F : Type u_4,	_inst_1 : has_norm E,	_inst_2 : has_norm F,	c : ℝ,	f : α → E,	g : α → F,	l : filter α,	h : is_O_with c f g l	⊢ is_O f g l
α : Type u_1,	E : Type u_3,	F : Type u_4,	_inst_1 : has_norm E,	_inst_2 : has_norm F,	c : ℝ,	f : α → E,	g : α → F,	l : filter α,	h : is_O_with c f g l	⊢ ∃ (c : ℝ), is_O_with c f g l
⊢ ∀ {α : Type u_1} {β : Type u_2} [_inst_1 : topological_space α] [_inst_2 : topological_space β] {E : Type u_3}	  [_inst_3 : has_norm E] {F : Type u_4} [_inst_4 : has_norm F] (e : local_homeomorph α β) {b : β},	    b ∈ e.to_local_equiv.target →	    ∀ {f : β → E} {g : β → F}, is_O f g (nhds b) ↔ is_O (f ∘ ⇑e) (g ∘ ⇑e) (nhds (⇑(e.symm) b))
α : Type u_1,	β : Type u_2,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	E : Type u_3,	_inst_3 : has_norm E,	F : Type u_4,	_inst_4 : has_norm F,	e : local_homeomorph α β,	b : β,	hb : b ∈ e.to_local_equiv.target,	f : β → E,	g : β → F	⊢ is_O f g (nhds b) ↔ is_O (f ∘ ⇑e) (g ∘ ⇑e) (nhds (⇑(e.symm) b))
α : Type u_1,	β : Type u_2,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	E : Type u_3,	_inst_3 : has_norm E,	F : Type u_4,	_inst_4 : has_norm F,	e : local_homeomorph α β,	b : β,	hb : b ∈ e.to_local_equiv.target,	f : β → E,	g : β → F	⊢ (∃ (c : ℝ), is_O_with c f g (nhds b)) ↔	    ∃ (c : ℝ), is_O_with c (f ∘ ⇑e) (g ∘ ⇑e) (nhds (⇑(e.symm) b))
⊢ ∀ {α : Type u_1} {β : Type u_2} [_inst_1 : topological_space α] [_inst_2 : topological_space β] {E : Type u_3}	  [_inst_3 : has_norm E] {F : Type u_4} [_inst_4 : has_norm F] (e : α ≃ₜ β) {b : β} {f : β → E}	  {g : β → F}, is_O f g (nhds b) ↔ is_O (f ∘ ⇑e) (g ∘ ⇑e) (nhds (⇑(e.symm) b))
α : Type u_1,	β : Type u_2,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	E : Type u_3,	_inst_3 : has_norm E,	F : Type u_4,	_inst_4 : has_norm F,	e : α ≃ₜ β,	b : β,	f : β → E,	g : β → F	⊢ is_O f g (nhds b) ↔ is_O (f ∘ ⇑e) (g ∘ ⇑e) (nhds (⇑(e.symm) b))
α : Type u_1,	β : Type u_2,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	E : Type u_3,	_inst_3 : has_norm E,	F : Type u_4,	_inst_4 : has_norm F,	e : α ≃ₜ β,	b : β,	f : β → E,	g : β → F	⊢ (∃ (c : ℝ), is_O_with c f g (nhds b)) ↔	    ∃ (c : ℝ), is_O_with c (f ∘ ⇑e) (g ∘ ⇑e) (nhds (⇑(e.symm) b))
⊢ ∀ {α : Type u_1} {F : Type u_4} {E' : Type u_6} [_inst_2 : has_norm F] [_inst_4 : normed_group E'] {c : ℝ}	  {g : α → F} {f' : α → E'} {l : filter α}, is_O_with c (λ (x : α), -f' x) g l ↔ is_O_with c f' g l
α : Type u_1,	F : Type u_4,	E' : Type u_6,	_inst_2 : has_norm F,	_inst_4 : normed_group E',	c : ℝ,	g : α → F,	f' : α → E',	l : filter α	⊢ is_O_with c (λ (x : α), -f' x) g l ↔ is_O_with c f' g l
⊢ ∀ {α : Type u_1} {F : Type u_4} {E' : Type u_6} [_inst_2 : has_norm F] [_inst_4 : normed_group E'] {g : α → F}	  {l : filter α} {f₁ f₂ : α → E'}, is_o f₁ g l → is_o f₂ g l → is_o (λ (x : α), f₁ x - f₂ x) g l
α : Type u_1,	F : Type u_4,	E' : Type u_6,	_inst_2 : has_norm F,	_inst_4 : normed_group E',	g : α → F,	l : filter α,	f₁ f₂ : α → E',	h₁ : is_o f₁ g l,	h₂ : is_o f₂ g l	⊢ is_o (λ (x : α), f₁ x - f₂ x) g l
⊢ ∀ {α : Type u_1} {E : Type u_3} {F : Type u_4} [_inst_1 : has_norm E] [_inst_2 : has_norm F] {c : ℝ}	  {f : α → E} {g : α → F} {l : filter α}, is_O_with c f g l ↔ ∀ᶠ (x : α) in l, ∥f x∥ ≤ c * ∥g x∥
α : Type u_1,	E : Type u_3,	F : Type u_4,	_inst_1 : has_norm E,	_inst_2 : has_norm F,	c : ℝ,	f : α → E,	g : α → F,	l : filter α	⊢ is_O_with c f g l ↔ ∀ᶠ (x : α) in l, ∥f x∥ ≤ c * ∥g x∥
⊢ ∀ {𝕜 : Type u} [_inst_1 : nondiscrete_normed_field 𝕜] {x : 𝕜} {s : set 𝕜} {𝔸 : Type u_2}	  [_inst_7 : normed_ring 𝔸] [_inst_9 : normed_algebra 𝕜 𝔸] {c d : 𝕜 → 𝔸} {c' d' : 𝔸},	    has_deriv_within_at c c' s x →	    has_deriv_within_at d d' s x → has_deriv_within_at (λ (y : 𝕜), c y * d y) (c' * d x + c x * d') s x
𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	x : 𝕜,	s : set 𝕜,	𝔸 : Type u_2,	_inst_7 : normed_ring 𝔸,	_inst_9 : normed_algebra 𝕜 𝔸,	c d : 𝕜 → 𝔸,	c' d' : 𝔸,	hc : has_deriv_within_at c c' s x,	hd : has_deriv_within_at d d' s x	⊢ has_deriv_within_at (λ (y : 𝕜), c y * d y) (c' * d x + c x * d') s x
𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	x : 𝕜,	s : set 𝕜,	𝔸 : Type u_2,	_inst_7 : normed_ring 𝔸,	_inst_9 : normed_algebra 𝕜 𝔸,	c d : 𝕜 → 𝔸,	c' d' : 𝔸,	hc : has_deriv_within_at c c' s x,	hd : has_deriv_within_at d d' s x,	this :	  has_deriv_within_at (λ (y : 𝕜), c y * d y) (⇑(c x • 1.smul_right d' + (1.smul_right c').smul_right (d x)) 1) s	    x	⊢ has_deriv_within_at (λ (y : 𝕜), c y * d y) (c' * d x + c x * d') s x
⊢ ∀ {𝕜 : Type u} [_inst_1 : nondiscrete_normed_field 𝕜] {x : 𝕜} {𝕜' : Type u_1}	  [_inst_6 : nondiscrete_normed_field 𝕜'] [_inst_7 : normed_algebra 𝕜 𝕜'] {c : 𝕜 → 𝕜'} (d : 𝕜'),	    deriv (λ (x : 𝕜), c x / d) x = deriv c x / d
𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	x : 𝕜,	𝕜' : Type u_1,	_inst_6 : nondiscrete_normed_field 𝕜',	_inst_7 : normed_algebra 𝕜 𝕜',	c : 𝕜 → 𝕜',	d : 𝕜'	⊢ deriv (λ (x : 𝕜), c x / d) x = deriv c x / d
⊢ ∀ {𝕜 : Type u} [_inst_1 : nondiscrete_normed_field 𝕜] {x : 𝕜} {s : set 𝕜} (p : polynomial 𝕜),	    unique_diff_within_at 𝕜 s x → deriv_within (λ (x : 𝕜), eval x p) s x = eval x (⇑derivative p)
𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	x : 𝕜,	s : set 𝕜,	p : polynomial 𝕜,	hxs : unique_diff_within_at 𝕜 s x	⊢ deriv_within (λ (x : 𝕜), eval x p) s x = eval x (⇑derivative p)
𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	x : 𝕜,	s : set 𝕜,	p : polynomial 𝕜,	hxs : unique_diff_within_at 𝕜 s x	⊢ deriv (λ (x : 𝕜), eval x p) x = eval x (⇑derivative p)
⊢ ∀ {𝕜 : Type u} [_inst_1 : nondiscrete_normed_field 𝕜] {F : Type v} [_inst_2 : normed_group F]	  [_inst_3 : normed_space 𝕜 F] {f : 𝕜 → F} {f' : F} {x : 𝕜} [_inst_6 : partial_order 𝕜],	    has_deriv_within_at f f' (Ioi x) x ↔ has_deriv_within_at f f' (Ici x) x
𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	F : Type v,	_inst_2 : normed_group F,	_inst_3 : normed_space 𝕜 F,	f : 𝕜 → F,	f' : F,	x : 𝕜,	_inst_6 : partial_order 𝕜	⊢ has_deriv_within_at f f' (Ioi x) x ↔ has_deriv_within_at f f' (Ici x) x
⊢ ∀ {𝕜 : Type u} [_inst_1 : nondiscrete_normed_field 𝕜] {F : Type v} [_inst_2 : normed_group F]	  [_inst_3 : normed_space 𝕜 F] {f : 𝕜 → F} {f' : F} {x : 𝕜} {s t : set 𝕜},	    has_deriv_within_at f f' s x → has_deriv_within_at f f' t x → has_deriv_within_at f f' (s ∪ t) x
𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	F : Type v,	_inst_2 : normed_group F,	_inst_3 : normed_space 𝕜 F,	f : 𝕜 → F,	f' : F,	x : 𝕜,	s t : set 𝕜,	hs : has_deriv_within_at f f' s x,	ht : has_deriv_within_at f f' t x	⊢ has_deriv_within_at f f' (s ∪ t) x
𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	F : Type v,	_inst_2 : normed_group F,	_inst_3 : normed_space 𝕜 F,	f : 𝕜 → F,	f' : F,	x : 𝕜,	s t : set 𝕜,	hs : has_deriv_within_at f f' s x,	ht : has_deriv_within_at f f' t x	⊢ has_deriv_at_filter f f' x (nhds_within x s ⊔ nhds_within x t)
⊢ ∀ {𝕜 : Type u} [_inst_1 : nondiscrete_normed_field 𝕜] {F : Type v} [_inst_2 : normed_group F]	  [_inst_3 : normed_space 𝕜 F] {f : 𝕜 → F} {x : 𝕜}, 1.smul_right (deriv f x) = fderiv 𝕜 f x
𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	F : Type v,	_inst_2 : normed_group F,	_inst_3 : normed_space 𝕜 F,	f : 𝕜 → F,	x : 𝕜	⊢ 1.smul_right (deriv f x) = fderiv 𝕜 f x
⊢ ∀ {𝕜 : Type u} [_inst_1 : nondiscrete_normed_field 𝕜] {F : Type v} [_inst_2 : normed_group F]	  [_inst_3 : normed_space 𝕜 F] {f : 𝕜 → F} {f' : F} {x : 𝕜} {𝕜' : Type u_1}	  [_inst_6 : nondiscrete_normed_field 𝕜'] [_inst_7 : normed_algebra 𝕜 𝕜'] [_inst_8 : normed_space 𝕜' F]	  [_inst_9 : is_scalar_tower 𝕜 𝕜' F] {c : 𝕜 → 𝕜'} {c' : 𝕜'},	    has_strict_deriv_at c c' x →	    has_strict_deriv_at f f' x → has_strict_deriv_at (λ (y : 𝕜), c y • f y) (c x • f' + c' • f x) x
𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	F : Type v,	_inst_2 : normed_group F,	_inst_3 : normed_space 𝕜 F,	f : 𝕜 → F,	f' : F,	x : 𝕜,	𝕜' : Type u_1,	_inst_6 : nondiscrete_normed_field 𝕜',	_inst_7 : normed_algebra 𝕜 𝕜',	_inst_8 : normed_space 𝕜' F,	_inst_9 : is_scalar_tower 𝕜 𝕜' F,	c : 𝕜 → 𝕜',	c' : 𝕜',	hc : has_strict_deriv_at c c' x,	hf : has_strict_deriv_at f f' x	⊢ has_strict_deriv_at (λ (y : 𝕜), c y • f y) (c x • f' + c' • f x) x
⊢ ∀ {𝕜 : Type u} [_inst_1 : nondiscrete_normed_field 𝕜] {F : Type v} [_inst_2 : normed_group F]	  [_inst_3 : normed_space 𝕜 F] {f : 𝕜 → F} {f' : F} {x : 𝕜} {L : filter 𝕜},	    has_deriv_at_filter f f' x L → has_deriv_at_filter (λ (x : 𝕜), -f x) (-f') x L
𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	F : Type v,	_inst_2 : normed_group F,	_inst_3 : normed_space 𝕜 F,	f : 𝕜 → F,	f' : F,	x : 𝕜,	L : filter 𝕜,	h : has_deriv_at_filter f f' x L	⊢ has_deriv_at_filter (λ (x : 𝕜), -f x) (-f') x L
⊢ ∀ {𝕜 : Type u} [_inst_1 : nondiscrete_normed_field 𝕜] {F : Type v} [_inst_2 : normed_group F]	  [_inst_3 : normed_space 𝕜 F] {f g : 𝕜 → F} {f' g' : F} {x : 𝕜} {L : filter 𝕜},	    has_deriv_at_filter f f' x L →	    has_deriv_at_filter g g' x L → has_deriv_at_filter (λ (x : 𝕜), f x - g x) (f' - g') x L
𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	F : Type v,	_inst_2 : normed_group F,	_inst_3 : normed_space 𝕜 F,	f g : 𝕜 → F,	f' g' : F,	x : 𝕜,	L : filter 𝕜,	hf : has_deriv_at_filter f f' x L,	hg : has_deriv_at_filter g g' x L	⊢ has_deriv_at_filter (λ (x : 𝕜), f x - g x) (f' - g') x L
⊢ ∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field 𝕜] {E : Type u_2} [_inst_2 : normed_group E]	  [_inst_3 : normed_space 𝕜 E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space 𝕜 F]	  {G : Type u_4} [_inst_6 : normed_group G] [_inst_7 : normed_space 𝕜 G] (iso : E ≃L[𝕜] F) {f : G → E} {x : G}	  {f' : G →L[𝕜] E}, has_strict_fderiv_at (⇑iso ∘ f) (↑iso.comp f') x ↔ has_strict_fderiv_at f f' x
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	G : Type u_4,	_inst_6 : normed_group G,	_inst_7 : normed_space 𝕜 G,	iso : E ≃L[𝕜] F,	f : G → E,	x : G,	f' : G →L[𝕜] E	⊢ has_strict_fderiv_at (⇑iso ∘ f) (↑iso.comp f') x ↔ has_strict_fderiv_at f f' x
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	G : Type u_4,	_inst_6 : normed_group G,	_inst_7 : normed_space 𝕜 G,	iso : E ≃L[𝕜] F,	f : G → E,	x : G,	f' : G →L[𝕜] E,	H : has_strict_fderiv_at (⇑iso ∘ f) (↑iso.comp f') x	⊢ has_strict_fderiv_at f f' x
2 goals	𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	G : Type u_4,	_inst_6 : normed_group G,	_inst_7 : normed_space 𝕜 G,	iso : E ≃L[𝕜] F,	f : G → E,	x : G,	f' : G →L[𝕜] E,	H : has_strict_fderiv_at (⇑iso ∘ f) (↑iso.comp f') x	⊢ f = λ (x : G), ⇑(iso.symm) ((⇑iso ∘ f) x)		𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	G : Type u_4,	_inst_6 : normed_group G,	_inst_7 : normed_space 𝕜 G,	iso : E ≃L[𝕜] F,	f : G → E,	x : G,	f' : G →L[𝕜] E,	H : has_strict_fderiv_at (⇑iso ∘ f) (↑iso.comp f') x	⊢ f' = ↑(iso.symm).comp (↑iso.comp f')
2 goals	𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	G : Type u_4,	_inst_6 : normed_group G,	_inst_7 : normed_space 𝕜 G,	iso : E ≃L[𝕜] F,	f : G → E,	x : G,	f' : G →L[𝕜] E,	H : has_strict_fderiv_at (⇑iso ∘ f) (↑iso.comp f') x,	z : G	⊢ f z = ⇑(iso.symm) ((⇑iso ∘ f) z)		𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	G : Type u_4,	_inst_6 : normed_group G,	_inst_7 : normed_space 𝕜 G,	iso : E ≃L[𝕜] F,	f : G → E,	x : G,	f' : G →L[𝕜] E,	H : has_strict_fderiv_at (⇑iso ∘ f) (↑iso.comp f') x	⊢ f' = ↑(iso.symm).comp (↑iso.comp f')
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	G : Type u_4,	_inst_6 : normed_group G,	_inst_7 : normed_space 𝕜 G,	iso : E ≃L[𝕜] F,	f : G → E,	x : G,	f' : G →L[𝕜] E,	H : has_strict_fderiv_at (⇑iso ∘ f) (↑iso.comp f') x	⊢ f' = ↑(iso.symm).comp (↑iso.comp f')
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	G : Type u_4,	_inst_6 : normed_group G,	_inst_7 : normed_space 𝕜 G,	iso : E ≃L[𝕜] F,	f : G → E,	x : G,	f' : G →L[𝕜] E,	H : has_strict_fderiv_at (⇑iso ∘ f) (↑iso.comp f') x,	z : G	⊢ ⇑f' z = ⇑(↑(iso.symm).comp (↑iso.comp f')) z
⊢ ∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field 𝕜] {E : Type u_2} [_inst_2 : normed_group E]	  [_inst_3 : normed_space 𝕜 E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space 𝕜 F]	  {f : E → F} {f' : E →L[𝕜] F} {x₀ : E},	    has_fderiv_at f f' x₀ →	    ∀ {s : set E}, s ∈ nhds x₀ → ∀ {C : nnreal}, lipschitz_on_with C f s → ∥f'∥ ≤ ↑C
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	f : E → F,	f' : E →L[𝕜] F,	x₀ : E,	hf : has_fderiv_at f f' x₀,	s : set E,	hs : s ∈ nhds x₀,	C : nnreal,	hlip : lipschitz_on_with C f s	⊢ ∥f'∥ ≤ ↑C
2 goals	𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	f : E → F,	f' : E →L[𝕜] F,	x₀ : E,	hf : has_fderiv_at f f' x₀,	s : set E,	hs : s ∈ nhds x₀,	C : nnreal,	hlip : lipschitz_on_with C f s,	ε : ℝ,	ε0 : 0 < ε	⊢ 0 ≤ ↑C + ε		𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	f : E → F,	f' : E →L[𝕜] F,	x₀ : E,	hf : has_fderiv_at f f' x₀,	s : set E,	hs : s ∈ nhds x₀,	C : nnreal,	hlip : lipschitz_on_with C f s,	ε : ℝ,	ε0 : 0 < ε	⊢ ∀ᶠ (x : E) in nhds 0, ∥⇑f' x∥ ≤ (↑C + ε) * ∥x∥
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	f : E → F,	f' : E →L[𝕜] F,	x₀ : E,	hf : has_fderiv_at f f' x₀,	s : set E,	hs : s ∈ nhds x₀,	C : nnreal,	hlip : lipschitz_on_with C f s,	ε : ℝ,	ε0 : 0 < ε	⊢ ∀ᶠ (x : E) in nhds 0, ∥⇑f' x∥ ≤ (↑C + ε) * ∥x∥
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	f : E → F,	f' : E →L[𝕜] F,	x₀ : E,	hf : has_fderiv_at f f' x₀,	s : set E,	hs : s ∈ nhds x₀,	C : nnreal,	hlip : lipschitz_on_with C f s,	ε : ℝ,	ε0 : 0 < ε,	hs' : s ∈ nhds x₀	⊢ ∀ᶠ (x : E) in nhds 0, ∥⇑f' x∥ ≤ (↑C + ε) * ∥x∥
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	f : E → F,	f' : E →L[𝕜] F,	x₀ : E,	hf : has_fderiv_at f f' x₀,	s : set E,	hs : s ∈ nhds x₀,	C : nnreal,	hlip : lipschitz_on_with C f s,	ε : ℝ,	ε0 : 0 < ε,	hs' : has_add.add x₀ ⁻¹' s ∈ nhds 0	⊢ ∀ᶠ (x : E) in nhds 0, ∥⇑f' x∥ ≤ (↑C + ε) * ∥x∥
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	f : E → F,	f' : E →L[𝕜] F,	x₀ : E,	hf : has_fderiv_at f f' x₀,	s : set E,	hs : s ∈ nhds x₀,	C : nnreal,	hlip : lipschitz_on_with C f s,	ε : ℝ,	ε0 : 0 < ε,	hs' : has_add.add x₀ ⁻¹' s ∈ nhds 0	⊢ ∀ (a : E),	    ∥f (x₀ + a) - f x₀ - ⇑f' a∥ ≤ ε * ∥a∥ →	    a ∈ has_add.add x₀ ⁻¹' s → ∥⇑f' a∥ ≤ (↑C + ε) * ∥a∥
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	f : E → F,	f' : E →L[𝕜] F,	x₀ : E,	hf : has_fderiv_at f f' x₀,	s : set E,	hs : s ∈ nhds x₀,	C : nnreal,	hlip : lipschitz_on_with C f s,	ε : ℝ,	ε0 : 0 < ε,	hs' : has_add.add x₀ ⁻¹' s ∈ nhds 0,	y : E,	hy : ∥f (x₀ + y) - f x₀ - ⇑f' y∥ ≤ ε * ∥y∥,	hys : y ∈ has_add.add x₀ ⁻¹' s	⊢ ∥⇑f' y∥ ≤ (↑C + ε) * ∥y∥
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	f : E → F,	f' : E →L[𝕜] F,	x₀ : E,	hf : has_fderiv_at f f' x₀,	s : set E,	hs : s ∈ nhds x₀,	C : nnreal,	hlip : lipschitz_on_with C f s,	ε : ℝ,	ε0 : 0 < ε,	hs' : has_add.add x₀ ⁻¹' s ∈ nhds 0,	y : E,	hy : ∥f (x₀ + y) - f x₀ - ⇑f' y∥ ≤ ε * ∥y∥,	hys : y ∈ has_add.add x₀ ⁻¹' s,	this : ∥f (x₀ + y) - f x₀∥ ≤ ↑C * ∥x₀ + y - x₀∥	⊢ ∥⇑f' y∥ ≤ (↑C + ε) * ∥y∥
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	f : E → F,	f' : E →L[𝕜] F,	x₀ : E,	hf : has_fderiv_at f f' x₀,	s : set E,	hs : s ∈ nhds x₀,	C : nnreal,	hlip : lipschitz_on_with C f s,	ε : ℝ,	ε0 : 0 < ε,	hs' : has_add.add x₀ ⁻¹' s ∈ nhds 0,	y : E,	hy : ∥f (x₀ + y) - f x₀ - ⇑f' y∥ ≤ ε * ∥y∥,	hys : y ∈ has_add.add x₀ ⁻¹' s,	this : ∥f (x₀ + y) - f x₀∥ ≤ ↑C * ∥y∥	⊢ ∥⇑f' y∥ ≤ (↑C + ε) * ∥y∥
⊢ ∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field 𝕜] {E : Type u_2} [_inst_2 : normed_group E]	  [_inst_3 : normed_space 𝕜 E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space 𝕜 F]	  {f : E → F} {f' : E →L[𝕜] F} {x : E} {s t : set E},	    t ∈ nhds x → (has_fderiv_within_at f f' (s ∩ t) x ↔ has_fderiv_within_at f f' s x)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	f : E → F,	f' : E →L[𝕜] F,	x : E,	s t : set E,	h : t ∈ nhds x	⊢ has_fderiv_within_at f f' (s ∩ t) x ↔ has_fderiv_within_at f f' s x
⊢ ∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field 𝕜] {F : Type u_2} [_inst_2 : normed_group F]	  [_inst_3 : normed_space 𝕜 F] {n : ℕ} {f : 𝕜 → F} {s : set 𝕜},	    iterated_deriv_within n f s =	      ⇑((continuous_multilinear_map.pi_field_equiv 𝕜 (fin n) F).symm) ∘ iterated_fderiv_within 𝕜 n f s
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	F : Type u_2,	_inst_2 : normed_group F,	_inst_3 : normed_space 𝕜 F,	n : ℕ,	f : 𝕜 → F,	s : set 𝕜	⊢ iterated_deriv_within n f s =	    ⇑((continuous_multilinear_map.pi_field_equiv 𝕜 (fin n) F).symm) ∘ iterated_fderiv_within 𝕜 n f s
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	F : Type u_2,	_inst_2 : normed_group F,	_inst_3 : normed_space 𝕜 F,	n : ℕ,	f : 𝕜 → F,	s : set 𝕜,	x : 𝕜	⊢ iterated_deriv_within n f s x =	    (⇑((continuous_multilinear_map.pi_field_equiv 𝕜 (fin n) F).symm) ∘ iterated_fderiv_within 𝕜 n f s) x
⊢ ∀ {E : Type u} [_inst_1 : normed_group E] [_inst_2 : normed_space ℝ E] {f : E → ℝ} {a : E}	  {f' : E →L[ℝ] ℝ}, is_local_min f a → has_fderiv_at f f' a → f' = 0
E : Type u,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	a : E,	f' : E →L[ℝ] ℝ,	h : is_local_min f a,	hf : has_fderiv_at f f' a	⊢ f' = 0
E : Type u,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	a : E,	f' : E →L[ℝ] ℝ,	h : is_local_min f a,	hf : has_fderiv_at f f' a,	y : E	⊢ ⇑f' y = ⇑0 y
2 goals	E : Type u,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	a : E,	f' : E →L[ℝ] ℝ,	h : is_local_min f a,	hf : has_fderiv_at f f' a,	y : E	⊢ y ∈ pos_tangent_cone_at univ a		E : Type u,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	a : E,	f' : E →L[ℝ] ℝ,	h : is_local_min f a,	hf : has_fderiv_at f f' a,	y : E	⊢ -y ∈ pos_tangent_cone_at univ a
2 goals	E : Type u,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	a : E,	f' : E →L[ℝ] ℝ,	h : is_local_min f a,	hf : has_fderiv_at f f' a,	y : E	⊢ y ∈ univ		E : Type u,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	a : E,	f' : E →L[ℝ] ℝ,	h : is_local_min f a,	hf : has_fderiv_at f f' a,	y : E	⊢ -y ∈ pos_tangent_cone_at univ a
E : Type u,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	a : E,	f' : E →L[ℝ] ℝ,	h : is_local_min f a,	hf : has_fderiv_at f f' a,	y : E	⊢ -y ∈ pos_tangent_cone_at univ a
E : Type u,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	a : E,	f' : E →L[ℝ] ℝ,	h : is_local_min f a,	hf : has_fderiv_at f f' a,	y : E	⊢ -y ∈ univ
⊢ ∀ {E : Type u_1} [_inst_1 : inner_product_space ℝ E] {c : E} (f : times_cont_diff_bump_of_inner c),	    support ⇑f = ball c f.R
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	c : E,	f : times_cont_diff_bump_of_inner c	⊢ support ⇑f = ball c f.R
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	c : E,	f : times_cont_diff_bump_of_inner c,	x : E	⊢ x ∈ support ⇑f ↔ x ∈ ball c f.R
2 goals	E : Type u_1,	_inst_1 : inner_product_space ℝ E,	c : E,	f : times_cont_diff_bump_of_inner c,	x : E,	this : ⇑f x ≠ 0 ↔ dist x c < f.R	⊢ x ∈ support ⇑f ↔ x ∈ ball c f.R		E : Type u_1,	_inst_1 : inner_product_space ℝ E,	c : E,	f : times_cont_diff_bump_of_inner c,	x : E	⊢ ⇑f x ≠ 0 ↔ dist x c < f.R
E : Type u_1,	_inst_1 : inner_product_space ℝ E,	c : E,	f : times_cont_diff_bump_of_inner c,	x : E	⊢ ⇑f x ≠ 0 ↔ dist x c < f.R
2 goals	case or.inl	E : Type u_1,	_inst_1 : inner_product_space ℝ E,	c : E,	f : times_cont_diff_bump_of_inner c,	x : E,	hx : dist x c < f.R	⊢ ⇑f x ≠ 0 ↔ dist x c < f.R		case or.inr	E : Type u_1,	_inst_1 : inner_product_space ℝ E,	c : E,	f : times_cont_diff_bump_of_inner c,	x : E,	hx : f.R ≤ dist x c	⊢ ⇑f x ≠ 0 ↔ dist x c < f.R
case or.inr	E : Type u_1,	_inst_1 : inner_product_space ℝ E,	c : E,	f : times_cont_diff_bump_of_inner c,	x : E,	hx : f.R ≤ dist x c	⊢ ⇑f x ≠ 0 ↔ dist x c < f.R
⊢ ∀ {E : Type u_1} [_inst_1 : normed_group E] [_inst_2 : normed_space ℝ E] [_inst_3 : finite_dimensional ℝ E]	  {c : E} (f : times_cont_diff_bump c),	    closure (support ⇑f) = euclidean.closed_ball c f.to_times_cont_diff_bump_of_inner.R
E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	_inst_3 : finite_dimensional ℝ E,	c : E,	f : times_cont_diff_bump c	⊢ closure (support ⇑f) = euclidean.closed_ball c f.to_times_cont_diff_bump_of_inner.R
⊢ ∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field 𝕜] {E : Type u_2} [_inst_2 : normed_group E]	  [_inst_3 : normed_space 𝕜 E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space 𝕜 F] {x : E}	  {s : set E} {t : set F} {y : F},	    y ∈ closure t →	    ⇑(linear_map.inl 𝕜 E F) '' tangent_cone_at 𝕜 s x ⊆ tangent_cone_at 𝕜 (s ×ˢ t) (x, y)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	x : E,	s : set E,	t : set F,	y : F,	ht : y ∈ closure t	⊢ ⇑(linear_map.inl 𝕜 E F) '' tangent_cone_at 𝕜 s x ⊆ tangent_cone_at 𝕜 (s ×ˢ t) (x, y)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	x : E,	s : set E,	t : set F,	y : F,	ht : y ∈ closure t,	v : E,	c : ℕ → 𝕜,	d : ℕ → E,	hd : ∀ᶠ (n : ℕ) in at_top, x + d n ∈ s,	hc : tendsto (λ (n : ℕ), ∥c n∥) at_top at_top,	hy : tendsto (λ (n : ℕ), c n • d n) at_top (nhds v)	⊢ ⇑(linear_map.inl 𝕜 E F) v ∈ tangent_cone_at 𝕜 (s ×ˢ t) (x, y)
2 goals	𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	x : E,	s : set E,	t : set F,	y : F,	ht : y ∈ closure t,	v : E,	c : ℕ → 𝕜,	d : ℕ → E,	hd : ∀ᶠ (n : ℕ) in at_top, x + d n ∈ s,	hc : tendsto (λ (n : ℕ), ∥c n∥) at_top at_top,	hy : tendsto (λ (n : ℕ), c n • d n) at_top (nhds v)	⊢ ∀ (n : ℕ), ∃ (d' : F), y + d' ∈ t ∧ ∥c n • d'∥ < (1 / 2) ^ n		𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	x : E,	s : set E,	t : set F,	y : F,	ht : y ∈ closure t,	v : E,	c : ℕ → 𝕜,	d : ℕ → E,	hd : ∀ᶠ (n : ℕ) in at_top, x + d n ∈ s,	hc : tendsto (λ (n : ℕ), ∥c n∥) at_top at_top,	hy : tendsto (λ (n : ℕ), c n • d n) at_top (nhds v),	this : ∀ (n : ℕ), ∃ (d' : F), y + d' ∈ t ∧ ∥c n • d'∥ < (1 / 2) ^ n	⊢ ⇑(linear_map.inl 𝕜 E F) v ∈ tangent_cone_at 𝕜 (s ×ˢ t) (x, y)
2 goals	𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	x : E,	s : set E,	t : set F,	y : F,	ht : y ∈ closure t,	v : E,	c : ℕ → 𝕜,	d : ℕ → E,	hd : ∀ᶠ (n : ℕ) in at_top, x + d n ∈ s,	hc : tendsto (λ (n : ℕ), ∥c n∥) at_top at_top,	hy : tendsto (λ (n : ℕ), c n • d n) at_top (nhds v),	n : ℕ	⊢ ∃ (d' : F), y + d' ∈ t ∧ ∥c n • d'∥ < (1 / 2) ^ n		𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	x : E,	s : set E,	t : set F,	y : F,	ht : y ∈ closure t,	v : E,	c : ℕ → 𝕜,	d : ℕ → E,	hd : ∀ᶠ (n : ℕ) in at_top, x + d n ∈ s,	hc : tendsto (λ (n : ℕ), ∥c n∥) at_top at_top,	hy : tendsto (λ (n : ℕ), c n • d n) at_top (nhds v),	this : ∀ (n : ℕ), ∃ (d' : F), y + d' ∈ t ∧ ∥c n • d'∥ < (1 / 2) ^ n	⊢ ⇑(linear_map.inl 𝕜 E F) v ∈ tangent_cone_at 𝕜 (s ×ˢ t) (x, y)
2 goals	𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	x : E,	s : set E,	t : set F,	y : F,	ht : y ∈ closure t,	v : E,	c : ℕ → 𝕜,	d : ℕ → E,	hd : ∀ᶠ (n : ℕ) in at_top, x + d n ∈ s,	hc : tendsto (λ (n : ℕ), ∥c n∥) at_top at_top,	hy : tendsto (λ (n : ℕ), c n • d n) at_top (nhds v),	n : ℕ,	z : F,	hz : z ∈ {x : F | (λ (y_1 : F), ∥c n • (y_1 - y)∥ < (1 / 2) ^ n) x},	hzt : z ∈ t	⊢ ∃ (d' : F), y + d' ∈ t ∧ ∥c n • d'∥ < (1 / 2) ^ n		𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	x : E,	s : set E,	t : set F,	y : F,	ht : y ∈ closure t,	v : E,	c : ℕ → 𝕜,	d : ℕ → E,	hd : ∀ᶠ (n : ℕ) in at_top, x + d n ∈ s,	hc : tendsto (λ (n : ℕ), ∥c n∥) at_top at_top,	hy : tendsto (λ (n : ℕ), c n • d n) at_top (nhds v),	this : ∀ (n : ℕ), ∃ (d' : F), y + d' ∈ t ∧ ∥c n • d'∥ < (1 / 2) ^ n	⊢ ⇑(linear_map.inl 𝕜 E F) v ∈ tangent_cone_at 𝕜 (s ×ˢ t) (x, y)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	x : E,	s : set E,	t : set F,	y : F,	ht : y ∈ closure t,	v : E,	c : ℕ → 𝕜,	d : ℕ → E,	hd : ∀ᶠ (n : ℕ) in at_top, x + d n ∈ s,	hc : tendsto (λ (n : ℕ), ∥c n∥) at_top at_top,	hy : tendsto (λ (n : ℕ), c n • d n) at_top (nhds v),	this : ∀ (n : ℕ), ∃ (d' : F), y + d' ∈ t ∧ ∥c n • d'∥ < (1 / 2) ^ n	⊢ ⇑(linear_map.inl 𝕜 E F) v ∈ tangent_cone_at 𝕜 (s ×ˢ t) (x, y)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	x : E,	s : set E,	t : set F,	y : F,	ht : y ∈ closure t,	v : E,	c : ℕ → 𝕜,	d : ℕ → E,	hd : ∀ᶠ (n : ℕ) in at_top, x + d n ∈ s,	hc : tendsto (λ (n : ℕ), ∥c n∥) at_top at_top,	hy : tendsto (λ (n : ℕ), c n • d n) at_top (nhds v),	d' : ℕ → F,	hd' : ∀ (n : ℕ), y + d' n ∈ t ∧ ∥c n • d' n∥ < (1 / 2) ^ n	⊢ ⇑(linear_map.inl 𝕜 E F) v ∈ tangent_cone_at 𝕜 (s ×ˢ t) (x, y)
2 goals	𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	x : E,	s : set E,	t : set F,	y : F,	ht : y ∈ closure t,	v : E,	c : ℕ → 𝕜,	d : ℕ → E,	hd : ∀ᶠ (n : ℕ) in at_top, x + d n ∈ s,	hc : tendsto (λ (n : ℕ), ∥c n∥) at_top at_top,	hy : tendsto (λ (n : ℕ), c n • d n) at_top (nhds v),	d' : ℕ → F,	hd' : ∀ (n : ℕ), y + d' n ∈ t ∧ ∥c n • d' n∥ < (1 / 2) ^ n	⊢ ∀ᶠ (n : ℕ) in at_top, (x, y) + (d n, d' n) ∈ s ×ˢ t		𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	x : E,	s : set E,	t : set F,	y : F,	ht : y ∈ closure t,	v : E,	c : ℕ → 𝕜,	d : ℕ → E,	hd : ∀ᶠ (n : ℕ) in at_top, x + d n ∈ s,	hc : tendsto (λ (n : ℕ), ∥c n∥) at_top at_top,	hy : tendsto (λ (n : ℕ), c n • d n) at_top (nhds v),	d' : ℕ → F,	hd' : ∀ (n : ℕ), y + d' n ∈ t ∧ ∥c n • d' n∥ < (1 / 2) ^ n	⊢ tendsto (λ (n : ℕ), c n • (d n, d' n)) at_top (nhds (⇑(linear_map.inl 𝕜 E F) v))
2 goals	𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	x : E,	s : set E,	t : set F,	y : F,	ht : y ∈ closure t,	v : E,	c : ℕ → 𝕜,	d : ℕ → E,	hd : ∀ᶠ (n : ℕ) in at_top, x + d n ∈ s,	hc : tendsto (λ (n : ℕ), ∥c n∥) at_top at_top,	hy : tendsto (λ (n : ℕ), c n • d n) at_top (nhds v),	d' : ℕ → F,	hd' : ∀ (n : ℕ), y + d' n ∈ t ∧ ∥c n • d' n∥ < (1 / 2) ^ n	⊢ ∀ (a : ℕ), x + d a ∈ s → (x, y) + (d a, d' a) ∈ s ×ˢ t		𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	x : E,	s : set E,	t : set F,	y : F,	ht : y ∈ closure t,	v : E,	c : ℕ → 𝕜,	d : ℕ → E,	hd : ∀ᶠ (n : ℕ) in at_top, x + d n ∈ s,	hc : tendsto (λ (n : ℕ), ∥c n∥) at_top at_top,	hy : tendsto (λ (n : ℕ), c n • d n) at_top (nhds v),	d' : ℕ → F,	hd' : ∀ (n : ℕ), y + d' n ∈ t ∧ ∥c n • d' n∥ < (1 / 2) ^ n	⊢ tendsto (λ (n : ℕ), c n • (d n, d' n)) at_top (nhds (⇑(linear_map.inl 𝕜 E F) v))
2 goals	𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	x : E,	s : set E,	t : set F,	y : F,	ht : y ∈ closure t,	v : E,	c : ℕ → 𝕜,	d : ℕ → E,	hd : ∀ᶠ (n : ℕ) in at_top, x + d n ∈ s,	hc : tendsto (λ (n : ℕ), ∥c n∥) at_top at_top,	hy : tendsto (λ (n : ℕ), c n • d n) at_top (nhds v),	d' : ℕ → F,	hd' : ∀ (n : ℕ), y + d' n ∈ t ∧ ∥c n • d' n∥ < (1 / 2) ^ n,	n : ℕ,	hn : x + d n ∈ s	⊢ (x, y) + (d n, d' n) ∈ s ×ˢ t		𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	x : E,	s : set E,	t : set F,	y : F,	ht : y ∈ closure t,	v : E,	c : ℕ → 𝕜,	d : ℕ → E,	hd : ∀ᶠ (n : ℕ) in at_top, x + d n ∈ s,	hc : tendsto (λ (n : ℕ), ∥c n∥) at_top at_top,	hy : tendsto (λ (n : ℕ), c n • d n) at_top (nhds v),	d' : ℕ → F,	hd' : ∀ (n : ℕ), y + d' n ∈ t ∧ ∥c n • d' n∥ < (1 / 2) ^ n	⊢ tendsto (λ (n : ℕ), c n • (d n, d' n)) at_top (nhds (⇑(linear_map.inl 𝕜 E F) v))
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	x : E,	s : set E,	t : set F,	y : F,	ht : y ∈ closure t,	v : E,	c : ℕ → 𝕜,	d : ℕ → E,	hd : ∀ᶠ (n : ℕ) in at_top, x + d n ∈ s,	hc : tendsto (λ (n : ℕ), ∥c n∥) at_top at_top,	hy : tendsto (λ (n : ℕ), c n • d n) at_top (nhds v),	d' : ℕ → F,	hd' : ∀ (n : ℕ), y + d' n ∈ t ∧ ∥c n • d' n∥ < (1 / 2) ^ n	⊢ tendsto (λ (n : ℕ), c n • (d n, d' n)) at_top (nhds (⇑(linear_map.inl 𝕜 E F) v))
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	x : E,	s : set E,	t : set F,	y : F,	ht : y ∈ closure t,	v : E,	c : ℕ → 𝕜,	d : ℕ → E,	hd : ∀ᶠ (n : ℕ) in at_top, x + d n ∈ s,	hc : tendsto (λ (n : ℕ), ∥c n∥) at_top at_top,	hy : tendsto (λ (n : ℕ), c n • d n) at_top (nhds v),	d' : ℕ → F,	hd' : ∀ (n : ℕ), y + d' n ∈ t ∧ ∥c n • d' n∥ < (1 / 2) ^ n	⊢ tendsto (λ (c_1 : ℕ), c c_1 • (d c_1, d' c_1).snd) at_top (nhds (⇑0 v))
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	x : E,	s : set E,	t : set F,	y : F,	ht : y ∈ closure t,	v : E,	c : ℕ → 𝕜,	d : ℕ → E,	hd : ∀ᶠ (n : ℕ) in at_top, x + d n ∈ s,	hc : tendsto (λ (n : ℕ), ∥c n∥) at_top at_top,	hy : tendsto (λ (n : ℕ), c n • d n) at_top (nhds v),	d' : ℕ → F,	hd' : ∀ (n : ℕ), y + d' n ∈ t ∧ ∥c n • d' n∥ < (1 / 2) ^ n	⊢ tendsto (λ (n : ℕ), (1 / 2) ^ n) at_top (nhds 0)
⊢ ∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field 𝕜] {E : Type u_2} [_inst_2 : normed_group E]	  [_inst_3 : normed_space 𝕜 E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space 𝕜 F] {x : E}	  {s : set E} {t : set F} {y : F},	    x ∈ closure s →	    ⇑(linear_map.inr 𝕜 E F) '' tangent_cone_at 𝕜 t y ⊆ tangent_cone_at 𝕜 (s ×ˢ t) (x, y)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	x : E,	s : set E,	t : set F,	y : F,	hs : x ∈ closure s	⊢ ⇑(linear_map.inr 𝕜 E F) '' tangent_cone_at 𝕜 t y ⊆ tangent_cone_at 𝕜 (s ×ˢ t) (x, y)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	x : E,	s : set E,	t : set F,	y : F,	hs : x ∈ closure s,	w : F,	c : ℕ → 𝕜,	d : ℕ → F,	hd : ∀ᶠ (n : ℕ) in at_top, y + d n ∈ t,	hc : tendsto (λ (n : ℕ), ∥c n∥) at_top at_top,	hy : tendsto (λ (n : ℕ), c n • d n) at_top (nhds w)	⊢ ⇑(linear_map.inr 𝕜 E F) w ∈ tangent_cone_at 𝕜 (s ×ˢ t) (x, y)
2 goals	𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	x : E,	s : set E,	t : set F,	y : F,	hs : x ∈ closure s,	w : F,	c : ℕ → 𝕜,	d : ℕ → F,	hd : ∀ᶠ (n : ℕ) in at_top, y + d n ∈ t,	hc : tendsto (λ (n : ℕ), ∥c n∥) at_top at_top,	hy : tendsto (λ (n : ℕ), c n • d n) at_top (nhds w)	⊢ ∀ (n : ℕ), ∃ (d' : E), x + d' ∈ s ∧ ∥c n • d'∥ < (1 / 2) ^ n		𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	x : E,	s : set E,	t : set F,	y : F,	hs : x ∈ closure s,	w : F,	c : ℕ → 𝕜,	d : ℕ → F,	hd : ∀ᶠ (n : ℕ) in at_top, y + d n ∈ t,	hc : tendsto (λ (n : ℕ), ∥c n∥) at_top at_top,	hy : tendsto (λ (n : ℕ), c n • d n) at_top (nhds w),	this : ∀ (n : ℕ), ∃ (d' : E), x + d' ∈ s ∧ ∥c n • d'∥ < (1 / 2) ^ n	⊢ ⇑(linear_map.inr 𝕜 E F) w ∈ tangent_cone_at 𝕜 (s ×ˢ t) (x, y)
2 goals	𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	x : E,	s : set E,	t : set F,	y : F,	hs : x ∈ closure s,	w : F,	c : ℕ → 𝕜,	d : ℕ → F,	hd : ∀ᶠ (n : ℕ) in at_top, y + d n ∈ t,	hc : tendsto (λ (n : ℕ), ∥c n∥) at_top at_top,	hy : tendsto (λ (n : ℕ), c n • d n) at_top (nhds w),	n : ℕ	⊢ ∃ (d' : E), x + d' ∈ s ∧ ∥c n • d'∥ < (1 / 2) ^ n		𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	x : E,	s : set E,	t : set F,	y : F,	hs : x ∈ closure s,	w : F,	c : ℕ → 𝕜,	d : ℕ → F,	hd : ∀ᶠ (n : ℕ) in at_top, y + d n ∈ t,	hc : tendsto (λ (n : ℕ), ∥c n∥) at_top at_top,	hy : tendsto (λ (n : ℕ), c n • d n) at_top (nhds w),	this : ∀ (n : ℕ), ∃ (d' : E), x + d' ∈ s ∧ ∥c n • d'∥ < (1 / 2) ^ n	⊢ ⇑(linear_map.inr 𝕜 E F) w ∈ tangent_cone_at 𝕜 (s ×ˢ t) (x, y)
2 goals	𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	x : E,	s : set E,	t : set F,	y : F,	hs : x ∈ closure s,	w : F,	c : ℕ → 𝕜,	d : ℕ → F,	hd : ∀ᶠ (n : ℕ) in at_top, y + d n ∈ t,	hc : tendsto (λ (n : ℕ), ∥c n∥) at_top at_top,	hy : tendsto (λ (n : ℕ), c n • d n) at_top (nhds w),	n : ℕ,	z : E,	hz : z ∈ {x_1 : E | (λ (y : E), ∥c n • (y - x)∥ < (1 / 2) ^ n) x_1},	hzs : z ∈ s	⊢ ∃ (d' : E), x + d' ∈ s ∧ ∥c n • d'∥ < (1 / 2) ^ n		𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	x : E,	s : set E,	t : set F,	y : F,	hs : x ∈ closure s,	w : F,	c : ℕ → 𝕜,	d : ℕ → F,	hd : ∀ᶠ (n : ℕ) in at_top, y + d n ∈ t,	hc : tendsto (λ (n : ℕ), ∥c n∥) at_top at_top,	hy : tendsto (λ (n : ℕ), c n • d n) at_top (nhds w),	this : ∀ (n : ℕ), ∃ (d' : E), x + d' ∈ s ∧ ∥c n • d'∥ < (1 / 2) ^ n	⊢ ⇑(linear_map.inr 𝕜 E F) w ∈ tangent_cone_at 𝕜 (s ×ˢ t) (x, y)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	x : E,	s : set E,	t : set F,	y : F,	hs : x ∈ closure s,	w : F,	c : ℕ → 𝕜,	d : ℕ → F,	hd : ∀ᶠ (n : ℕ) in at_top, y + d n ∈ t,	hc : tendsto (λ (n : ℕ), ∥c n∥) at_top at_top,	hy : tendsto (λ (n : ℕ), c n • d n) at_top (nhds w),	this : ∀ (n : ℕ), ∃ (d' : E), x + d' ∈ s ∧ ∥c n • d'∥ < (1 / 2) ^ n	⊢ ⇑(linear_map.inr 𝕜 E F) w ∈ tangent_cone_at 𝕜 (s ×ˢ t) (x, y)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	x : E,	s : set E,	t : set F,	y : F,	hs : x ∈ closure s,	w : F,	c : ℕ → 𝕜,	d : ℕ → F,	hd : ∀ᶠ (n : ℕ) in at_top, y + d n ∈ t,	hc : tendsto (λ (n : ℕ), ∥c n∥) at_top at_top,	hy : tendsto (λ (n : ℕ), c n • d n) at_top (nhds w),	d' : ℕ → E,	hd' : ∀ (n : ℕ), x + d' n ∈ s ∧ ∥c n • d' n∥ < (1 / 2) ^ n	⊢ ⇑(linear_map.inr 𝕜 E F) w ∈ tangent_cone_at 𝕜 (s ×ˢ t) (x, y)
2 goals	𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	x : E,	s : set E,	t : set F,	y : F,	hs : x ∈ closure s,	w : F,	c : ℕ → 𝕜,	d : ℕ → F,	hd : ∀ᶠ (n : ℕ) in at_top, y + d n ∈ t,	hc : tendsto (λ (n : ℕ), ∥c n∥) at_top at_top,	hy : tendsto (λ (n : ℕ), c n • d n) at_top (nhds w),	d' : ℕ → E,	hd' : ∀ (n : ℕ), x + d' n ∈ s ∧ ∥c n • d' n∥ < (1 / 2) ^ n	⊢ ∀ᶠ (n : ℕ) in at_top, (x, y) + (d' n, d n) ∈ s ×ˢ t		𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	x : E,	s : set E,	t : set F,	y : F,	hs : x ∈ closure s,	w : F,	c : ℕ → 𝕜,	d : ℕ → F,	hd : ∀ᶠ (n : ℕ) in at_top, y + d n ∈ t,	hc : tendsto (λ (n : ℕ), ∥c n∥) at_top at_top,	hy : tendsto (λ (n : ℕ), c n • d n) at_top (nhds w),	d' : ℕ → E,	hd' : ∀ (n : ℕ), x + d' n ∈ s ∧ ∥c n • d' n∥ < (1 / 2) ^ n	⊢ tendsto (λ (n : ℕ), c n • (d' n, d n)) at_top (nhds (⇑(linear_map.inr 𝕜 E F) w))
2 goals	𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	x : E,	s : set E,	t : set F,	y : F,	hs : x ∈ closure s,	w : F,	c : ℕ → 𝕜,	d : ℕ → F,	hd : ∀ᶠ (n : ℕ) in at_top, y + d n ∈ t,	hc : tendsto (λ (n : ℕ), ∥c n∥) at_top at_top,	hy : tendsto (λ (n : ℕ), c n • d n) at_top (nhds w),	d' : ℕ → E,	hd' : ∀ (n : ℕ), x + d' n ∈ s ∧ ∥c n • d' n∥ < (1 / 2) ^ n	⊢ ∀ (a : ℕ), y + d a ∈ t → (x, y) + (d' a, d a) ∈ s ×ˢ t		𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	x : E,	s : set E,	t : set F,	y : F,	hs : x ∈ closure s,	w : F,	c : ℕ → 𝕜,	d : ℕ → F,	hd : ∀ᶠ (n : ℕ) in at_top, y + d n ∈ t,	hc : tendsto (λ (n : ℕ), ∥c n∥) at_top at_top,	hy : tendsto (λ (n : ℕ), c n • d n) at_top (nhds w),	d' : ℕ → E,	hd' : ∀ (n : ℕ), x + d' n ∈ s ∧ ∥c n • d' n∥ < (1 / 2) ^ n	⊢ tendsto (λ (n : ℕ), c n • (d' n, d n)) at_top (nhds (⇑(linear_map.inr 𝕜 E F) w))
2 goals	𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	x : E,	s : set E,	t : set F,	y : F,	hs : x ∈ closure s,	w : F,	c : ℕ → 𝕜,	d : ℕ → F,	hd : ∀ᶠ (n : ℕ) in at_top, y + d n ∈ t,	hc : tendsto (λ (n : ℕ), ∥c n∥) at_top at_top,	hy : tendsto (λ (n : ℕ), c n • d n) at_top (nhds w),	d' : ℕ → E,	hd' : ∀ (n : ℕ), x + d' n ∈ s ∧ ∥c n • d' n∥ < (1 / 2) ^ n,	n : ℕ,	hn : y + d n ∈ t	⊢ (x, y) + (d' n, d n) ∈ s ×ˢ t		𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	x : E,	s : set E,	t : set F,	y : F,	hs : x ∈ closure s,	w : F,	c : ℕ → 𝕜,	d : ℕ → F,	hd : ∀ᶠ (n : ℕ) in at_top, y + d n ∈ t,	hc : tendsto (λ (n : ℕ), ∥c n∥) at_top at_top,	hy : tendsto (λ (n : ℕ), c n • d n) at_top (nhds w),	d' : ℕ → E,	hd' : ∀ (n : ℕ), x + d' n ∈ s ∧ ∥c n • d' n∥ < (1 / 2) ^ n	⊢ tendsto (λ (n : ℕ), c n • (d' n, d n)) at_top (nhds (⇑(linear_map.inr 𝕜 E F) w))
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	x : E,	s : set E,	t : set F,	y : F,	hs : x ∈ closure s,	w : F,	c : ℕ → 𝕜,	d : ℕ → F,	hd : ∀ᶠ (n : ℕ) in at_top, y + d n ∈ t,	hc : tendsto (λ (n : ℕ), ∥c n∥) at_top at_top,	hy : tendsto (λ (n : ℕ), c n • d n) at_top (nhds w),	d' : ℕ → E,	hd' : ∀ (n : ℕ), x + d' n ∈ s ∧ ∥c n • d' n∥ < (1 / 2) ^ n	⊢ tendsto (λ (n : ℕ), c n • (d' n, d n)) at_top (nhds (⇑(linear_map.inr 𝕜 E F) w))
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	x : E,	s : set E,	t : set F,	y : F,	hs : x ∈ closure s,	w : F,	c : ℕ → 𝕜,	d : ℕ → F,	hd : ∀ᶠ (n : ℕ) in at_top, y + d n ∈ t,	hc : tendsto (λ (n : ℕ), ∥c n∥) at_top at_top,	hy : tendsto (λ (n : ℕ), c n • d n) at_top (nhds w),	d' : ℕ → E,	hd' : ∀ (n : ℕ), x + d' n ∈ s ∧ ∥c n • d' n∥ < (1 / 2) ^ n	⊢ tendsto (λ (c_1 : ℕ), c c_1 • (d' c_1, d c_1).fst) at_top (nhds (⇑0 w))
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	x : E,	s : set E,	t : set F,	y : F,	hs : x ∈ closure s,	w : F,	c : ℕ → 𝕜,	d : ℕ → F,	hd : ∀ᶠ (n : ℕ) in at_top, y + d n ∈ t,	hc : tendsto (λ (n : ℕ), ∥c n∥) at_top at_top,	hy : tendsto (λ (n : ℕ), c n • d n) at_top (nhds w),	d' : ℕ → E,	hd' : ∀ (n : ℕ), x + d' n ∈ s ∧ ∥c n • d' n∥ < (1 / 2) ^ n	⊢ tendsto (λ (n : ℕ), (1 / 2) ^ n) at_top (nhds 0)
⊢ ∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field 𝕜] (ι : Type u_2) [_inst_8 : fintype ι]	  (E : ι → Type u_3) [_inst_9 : Π (i : ι), normed_group (E i)] [_inst_10 : Π (i : ι), normed_space 𝕜 (E i)]	  (s : Π (i : ι), set (E i)) (x : Π (i : ι), E i) (I : set ι),	    (∀ (i : ι), i ∈ I → unique_diff_within_at 𝕜 (s i) (x i)) → unique_diff_within_at 𝕜 (I.pi s) x
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	ι : Type u_2,	_inst_8 : fintype ι,	E : ι → Type u_3,	_inst_9 : Π (i : ι), normed_group (E i),	_inst_10 : Π (i : ι), normed_space 𝕜 (E i),	s : Π (i : ι), set (E i),	x : Π (i : ι), E i,	I : set ι,	h : ∀ (i : ι), i ∈ I → unique_diff_within_at 𝕜 (s i) (x i)	⊢ unique_diff_within_at 𝕜 (I.pi s) x
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	ι : Type u_2,	_inst_8 : fintype ι,	E : ι → Type u_3,	_inst_9 : Π (i : ι), normed_group (E i),	_inst_10 : Π (i : ι), normed_space 𝕜 (E i),	s : Π (i : ι), set (E i),	x : Π (i : ι), E i,	I : set ι,	h : ∀ (i : ι), i ∈ I → unique_diff_within_at 𝕜 (s i) (x i),	_inst : Π (a : Prop), decidable a	⊢ unique_diff_within_at 𝕜 (I.pi s) x
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	ι : Type u_2,	_inst_8 : fintype ι,	E : ι → Type u_3,	_inst_9 : Π (i : ι), normed_group (E i),	_inst_10 : Π (i : ι), normed_space 𝕜 (E i),	s : Π (i : ι), set (E i),	x : Π (i : ι), E i,	I : set ι,	h : ∀ (i : ι), i ∈ I → unique_diff_within_at 𝕜 (s i) (x i),	_inst : Π (a : Prop), decidable a	⊢ unique_diff_within_at 𝕜 (univ.pi (I.piecewise s (λ (_x : ι), univ))) x
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	ι : Type u_2,	_inst_8 : fintype ι,	E : ι → Type u_3,	_inst_9 : Π (i : ι), normed_group (E i),	_inst_10 : Π (i : ι), normed_space 𝕜 (E i),	s : Π (i : ι), set (E i),	x : Π (i : ι), E i,	I : set ι,	h : ∀ (i : ι), i ∈ I → unique_diff_within_at 𝕜 (s i) (x i),	_inst : Π (a : Prop), decidable a,	i : ι	⊢ unique_diff_within_at 𝕜 (I.piecewise s (λ (_x : ι), univ) i) (x i)
2 goals	𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	ι : Type u_2,	_inst_8 : fintype ι,	E : ι → Type u_3,	_inst_9 : Π (i : ι), normed_group (E i),	_inst_10 : Π (i : ι), normed_space 𝕜 (E i),	s : Π (i : ι), set (E i),	x : Π (i : ι), E i,	I : set ι,	h : ∀ (i : ι), i ∈ I → unique_diff_within_at 𝕜 (s i) (x i),	_inst : Π (a : Prop), decidable a,	i : ι,	hi : i ∈ I	⊢ unique_diff_within_at 𝕜 (I.piecewise s (λ (_x : ι), univ) i) (x i)		𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	ι : Type u_2,	_inst_8 : fintype ι,	E : ι → Type u_3,	_inst_9 : Π (i : ι), normed_group (E i),	_inst_10 : Π (i : ι), normed_space 𝕜 (E i),	s : Π (i : ι), set (E i),	x : Π (i : ι), E i,	I : set ι,	h : ∀ (i : ι), i ∈ I → unique_diff_within_at 𝕜 (s i) (x i),	_inst : Π (a : Prop), decidable a,	i : ι,	hi : i ∉ I	⊢ unique_diff_within_at 𝕜 (I.piecewise s (λ (_x : ι), univ) i) (x i)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	ι : Type u_2,	_inst_8 : fintype ι,	E : ι → Type u_3,	_inst_9 : Π (i : ι), normed_group (E i),	_inst_10 : Π (i : ι), normed_space 𝕜 (E i),	s : Π (i : ι), set (E i),	x : Π (i : ι), E i,	I : set ι,	h : ∀ (i : ι), i ∈ I → unique_diff_within_at 𝕜 (s i) (x i),	_inst : Π (a : Prop), decidable a,	i : ι,	hi : i ∉ I	⊢ unique_diff_within_at 𝕜 (I.piecewise s (λ (_x : ι), univ) i) (x i)
⊢ ∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field 𝕜] {E : Type u_2} [_inst_2 : normed_group E]	  [_inst_3 : normed_space 𝕜 E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space 𝕜 F]	  {f : E → F} {p : E → formal_multilinear_series 𝕜 E F} {n : ℕ},	    has_ftaylor_series_up_to ↑(n + 1) f p ↔	      (∀ (x : E), (p x 0).uncurry0 = f x) ∧	        (∀ (x : E), has_fderiv_at (λ (y : E), p y 0) (p x 1).curry_left x) ∧	          has_ftaylor_series_up_to ↑n (λ (x : E), ⇑(continuous_multilinear_curry_fin1 𝕜 E F) (p x 1))	            (λ (x : E), (p x).shift)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	f : E → F,	p : E → formal_multilinear_series 𝕜 E F,	n : ℕ	⊢ has_ftaylor_series_up_to ↑(n + 1) f p ↔	    (∀ (x : E), (p x 0).uncurry0 = f x) ∧	      (∀ (x : E), has_fderiv_at (λ (y : E), p y 0) (p x 1).curry_left x) ∧	        has_ftaylor_series_up_to ↑n (λ (x : E), ⇑(continuous_multilinear_curry_fin1 𝕜 E F) (p x 1))	          (λ (x : E), (p x).shift)
⊢ ∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field 𝕜] {E : Type u_2} [_inst_2 : normed_group E]	  [_inst_3 : normed_space 𝕜 E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space 𝕜 F]	  {f : E → F} {x : E} {n : ℕ},	    times_cont_diff_at 𝕜 ↑n f x → (∀ᶠ (y : E) in nhds x, times_cont_diff_at 𝕜 ↑n f y)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	f : E → F,	x : E,	n : ℕ,	h : times_cont_diff_at 𝕜 ↑n f x	⊢ ∀ᶠ (y : E) in nhds x, times_cont_diff_at 𝕜 ↑n f y
⊢ ∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field 𝕜] {E : Type u_2} [_inst_2 : normed_group E]	  [_inst_3 : normed_space 𝕜 E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space 𝕜 F]	  {f : E → F} {n : with_top ℕ}, times_cont_diff_on 𝕜 n f univ ↔ times_cont_diff 𝕜 n f
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	f : E → F,	n : with_top ℕ	⊢ times_cont_diff_on 𝕜 n f univ ↔ times_cont_diff 𝕜 n f
2 goals	𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	f : E → F,	n : with_top ℕ	⊢ times_cont_diff_on 𝕜 n f univ → times_cont_diff 𝕜 n f		𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	f : E → F,	n : with_top ℕ	⊢ times_cont_diff 𝕜 n f → times_cont_diff_on 𝕜 n f univ
2 goals	𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	f : E → F,	n : with_top ℕ,	H : times_cont_diff_on 𝕜 n f univ	⊢ times_cont_diff 𝕜 n f		𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	f : E → F,	n : with_top ℕ	⊢ times_cont_diff 𝕜 n f → times_cont_diff_on 𝕜 n f univ
2 goals	𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	f : E → F,	n : with_top ℕ,	H : times_cont_diff_on 𝕜 n f univ	⊢ has_ftaylor_series_up_to n f (ftaylor_series_within 𝕜 f univ)		𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	f : E → F,	n : with_top ℕ	⊢ times_cont_diff 𝕜 n f → times_cont_diff_on 𝕜 n f univ
2 goals	𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	f : E → F,	n : with_top ℕ,	H : times_cont_diff_on 𝕜 n f univ	⊢ has_ftaylor_series_up_to_on n f (ftaylor_series_within 𝕜 f univ) univ		𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	f : E → F,	n : with_top ℕ	⊢ times_cont_diff 𝕜 n f → times_cont_diff_on 𝕜 n f univ
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	f : E → F,	n : with_top ℕ	⊢ times_cont_diff 𝕜 n f → times_cont_diff_on 𝕜 n f univ
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	f : E → F,	n : with_top ℕ,	x : E,	hx : x ∈ univ,	m : ℕ,	hm : ↑m ≤ n,	p : E → formal_multilinear_series 𝕜 E F,	hp : has_ftaylor_series_up_to n f p	⊢ ∃ (u : set E) (H : u ∈ nhds_within x (insert x univ)) (p : E → formal_multilinear_series 𝕜 E F),	    has_ftaylor_series_up_to_on ↑m f p u
⊢ ∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field 𝕜] {E : Type u_2} [_inst_2 : normed_group E]	  [_inst_3 : normed_space 𝕜 E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space 𝕜 F]	  {f : E → F} {x : E} {n : ℕ},	    iterated_fderiv 𝕜 (n + 1) f x =	      (⇑(continuous_multilinear_curry_right_equiv' 𝕜 n E F) ∘	         iterated_fderiv 𝕜 n (λ (y : E), fderiv 𝕜 f y))	        x
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	f : E → F,	x : E,	n : ℕ	⊢ iterated_fderiv 𝕜 (n + 1) f x =	    (⇑(continuous_multilinear_curry_right_equiv' 𝕜 n E F) ∘ iterated_fderiv 𝕜 n (λ (y : E), fderiv 𝕜 f y))	      x
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	f : E → F,	x : E,	n : ℕ,	m : fin (n + 1) → E	⊢ ⇑(iterated_fderiv 𝕜 (n + 1) f x) m =	    ⇑((⇑(continuous_multilinear_curry_right_equiv' 𝕜 n E F) ∘	          iterated_fderiv 𝕜 n (λ (y : E), fderiv 𝕜 f y))	         x)	      m
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	f : E → F,	x : E,	n : ℕ,	m : fin (n + 1) → E	⊢ ⇑(⇑(iterated_fderiv 𝕜 n (λ (y : E), fderiv 𝕜 f y) x) (init m)) (m (last n)) =	    ⇑((⇑(continuous_multilinear_curry_right_equiv' 𝕜 n E F) ∘	          iterated_fderiv 𝕜 n (λ (y : E), fderiv 𝕜 f y))	         x)	      m
⊢ ∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field 𝕜] {E : Type u_2} [_inst_2 : normed_group E]	  [_inst_3 : normed_space 𝕜 E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space 𝕜 F]	  {f : E → F} {n : ℕ},	    times_cont_diff 𝕜 ↑(n + 1) f ↔	      differentiable 𝕜 f ∧ times_cont_diff 𝕜 ↑n (λ (y : E), fderiv 𝕜 f y)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	f : E → F,	n : ℕ	⊢ times_cont_diff 𝕜 ↑(n + 1) f ↔	    differentiable 𝕜 f ∧ times_cont_diff 𝕜 ↑n (λ (y : E), fderiv 𝕜 f y)
⊢ ∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field 𝕜] {E : Type u_2} [_inst_2 : normed_group E]	  [_inst_3 : normed_space 𝕜 E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space 𝕜 F]	  {f : E → F} {x : E} [_inst_8 : subsingleton F] {n : with_top ℕ}, times_cont_diff_at 𝕜 n f x
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	f : E → F,	x : E,	_inst_8 : subsingleton F,	n : with_top ℕ	⊢ times_cont_diff_at 𝕜 n f x
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	f : E → F,	x : E,	_inst_8 : subsingleton F,	n : with_top ℕ	⊢ times_cont_diff_at 𝕜 n (λ (_x : E), 0) x
⊢ ∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field 𝕜] {E : Type u_2} [_inst_2 : normed_group E]	  [_inst_3 : normed_space 𝕜 E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space 𝕜 F] {s : set E}	  {f : E → F} [_inst_8 : subsingleton F] {n : with_top ℕ}, times_cont_diff_on 𝕜 n f s
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	s : set E,	f : E → F,	_inst_8 : subsingleton F,	n : with_top ℕ	⊢ times_cont_diff_on 𝕜 n f s
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	s : set E,	f : E → F,	_inst_8 : subsingleton F,	n : with_top ℕ	⊢ times_cont_diff_on 𝕜 n (λ (_x : E), 0) s
⊢ ∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field 𝕜] {E : Type u_2} [_inst_2 : normed_group E]	  [_inst_3 : normed_space 𝕜 E] {s : set E} {x : E} {f : E → 𝕜} {n : with_top ℕ} {c : 𝕜},	    times_cont_diff_within_at 𝕜 n f s x → times_cont_diff_within_at 𝕜 n (λ (x : E), f x / c) s x
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	s : set E,	x : E,	f : E → 𝕜,	n : with_top ℕ,	c : 𝕜,	hf : times_cont_diff_within_at 𝕜 n f s x	⊢ times_cont_diff_within_at 𝕜 n (λ (x : E), f x / c) s x
⊢ ∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field 𝕜] {E : Type u_2} [_inst_2 : normed_group E]	  [_inst_3 : normed_space 𝕜 E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space 𝕜 F]	  {E' : Type u_5} [_inst_8 : normed_group E'] [_inst_9 : normed_space 𝕜 E'] {F' : Type u_6}	  [_inst_10 : normed_group F'] [_inst_11 : normed_space 𝕜 F'] {n : with_top ℕ} {f : E → F} {g : E' → F'}	  {x : E} {y : E'},	    times_cont_diff_at 𝕜 n f x → times_cont_diff_at 𝕜 n g y → times_cont_diff_at 𝕜 n (prod.map f g) (x, y)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	E' : Type u_5,	_inst_8 : normed_group E',	_inst_9 : normed_space 𝕜 E',	F' : Type u_6,	_inst_10 : normed_group F',	_inst_11 : normed_space 𝕜 F',	n : with_top ℕ,	f : E → F,	g : E' → F',	x : E,	y : E',	hf : times_cont_diff_at 𝕜 n f x,	hg : times_cont_diff_at 𝕜 n g y	⊢ times_cont_diff_at 𝕜 n (prod.map f g) (x, y)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	E' : Type u_5,	_inst_8 : normed_group E',	_inst_9 : normed_space 𝕜 E',	F' : Type u_6,	_inst_10 : normed_group F',	_inst_11 : normed_space 𝕜 F',	n : with_top ℕ,	f : E → F,	g : E' → F',	x : E,	y : E',	hf : times_cont_diff_within_at 𝕜 n f univ x,	hg : times_cont_diff_within_at 𝕜 n g univ y	⊢ times_cont_diff_within_at 𝕜 n (prod.map f g) univ (x, y)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	E' : Type u_5,	_inst_8 : normed_group E',	_inst_9 : normed_space 𝕜 E',	F' : Type u_6,	_inst_10 : normed_group F',	_inst_11 : normed_space 𝕜 F',	n : with_top ℕ,	f : E → F,	g : E' → F',	x : E,	y : E',	hf : times_cont_diff_within_at 𝕜 n f univ x,	hg : times_cont_diff_within_at 𝕜 n g univ y	⊢ univ = univ ×ˢ univ
⊢ ∀ (z : ↥circle), ↑z⁻¹ = (↑z)⁻¹
z : ↥circle	⊢ ↑z⁻¹ = (↑z)⁻¹
z : ↥circle	⊢ ⇑(star_ring_end ℂ) ↑z = (↑z)⁻¹
z : ↥circle	⊢ ↑z * ⇑(star_ring_end ℂ) ↑z = 1
z : ↥circle	⊢ ↑(⇑norm_sq ↑z) = 1
⊢ ∀ {f : ℂ →ₗᵢ[ℝ] ℂ},	    (∀ (z : ℂ), (⇑f z).re = z.re) → ∀ (z : ℂ), (⇑f z).im = z.im ∨ (⇑f z).im = -z.im
f : ℂ →ₗᵢ[ℝ] ℂ,	h₂ : ∀ (z : ℂ), (⇑f z).re = z.re,	z : ℂ	⊢ (⇑f z).im = z.im ∨ (⇑f z).im = -z.im
f : ℂ →ₗᵢ[ℝ] ℂ,	h₂ : ∀ (z : ℂ), (⇑f z).re = z.re,	z : ℂ,	h₁ : ∥⇑f z∥ = ∥z∥	⊢ (⇑f z).im = z.im ∨ (⇑f z).im = -z.im
f : ℂ →ₗᵢ[ℝ] ℂ,	h₂ : ∀ (z : ℂ), (⇑f z).re = z.re,	z : ℂ,	h₁ : real.sqrt (⇑norm_sq (⇑f z)) = real.sqrt (⇑norm_sq z)	⊢ (⇑f z).im = z.im ∨ (⇑f z).im = -z.im
⊢ ∀ {𝕜 : Type u_1} {E : Type u_2} [_inst_1 : ordered_semiring 𝕜] [_inst_2 : add_comm_monoid E]	  [_inst_4 : module 𝕜 E] {s : set E}, convex 𝕜 s → ∀ (z : E), convex 𝕜 ((λ (x : E), z + x) ⁻¹' s)
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : ordered_semiring 𝕜,	_inst_2 : add_comm_monoid E,	_inst_4 : module 𝕜 E,	s : set E,	hs : convex 𝕜 s,	z : E	⊢ convex 𝕜 ((λ (x : E), z + x) ⁻¹' s)
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : ordered_semiring 𝕜,	_inst_2 : add_comm_monoid E,	_inst_4 : module 𝕜 E,	s : set E,	hs : convex 𝕜 s,	z x y : E,	hx : x ∈ (λ (x : E), z + x) ⁻¹' s,	hy : y ∈ (λ (x : E), z + x) ⁻¹' s,	a b : 𝕜,	ha : 0 ≤ a,	hb : 0 ≤ b,	hab : a + b = 1	⊢ a • x + b • y ∈ (λ (x : E), z + x) ⁻¹' s
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : ordered_semiring 𝕜,	_inst_2 : add_comm_monoid E,	_inst_4 : module 𝕜 E,	s : set E,	hs : convex 𝕜 s,	z x y : E,	hx : x ∈ (λ (x : E), z + x) ⁻¹' s,	hy : y ∈ (λ (x : E), z + x) ⁻¹' s,	a b : 𝕜,	ha : 0 ≤ a,	hb : 0 ≤ b,	hab : a + b = 1,	h : a • (λ (x : E), z + x) x + b • (λ (x : E), z + x) y ∈ s	⊢ a • x + b • y ∈ (λ (x : E), z + x) ⁻¹' s
⊢ ∀ {𝕜 : Type u_1} {E : Type u_2} [_inst_1 : ordered_semiring 𝕜] [_inst_2 : add_comm_monoid E]	  [_inst_4 : module 𝕜 E] {s : set E}, convex 𝕜 s → ∀ (z : E), convex 𝕜 ((λ (x : E), x + z) ⁻¹' s)
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : ordered_semiring 𝕜,	_inst_2 : add_comm_monoid E,	_inst_4 : module 𝕜 E,	s : set E,	hs : convex 𝕜 s,	z : E	⊢ convex 𝕜 ((λ (x : E), x + z) ⁻¹' s)
⊢ ∀ {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [_inst_1 : ordered_semiring 𝕜] [_inst_2 : add_comm_monoid E]	  [_inst_4 : linear_ordered_cancel_add_comm_monoid β] [_inst_5 : has_scalar 𝕜 E] [_inst_6 : module 𝕜 β]	  [_inst_7 : ordered_smul 𝕜 β] {s : set E} {f : E → β},	    convex_on 𝕜 s f →	    ∀ {x y z : E}, x ∈ s → y ∈ s → z ∈ open_segment 𝕜 x y → f y ≤ f z → f z ≤ f x
𝕜 : Type u_1,	E : Type u_2,	β : Type u_4,	_inst_1 : ordered_semiring 𝕜,	_inst_2 : add_comm_monoid E,	_inst_4 : linear_ordered_cancel_add_comm_monoid β,	_inst_5 : has_scalar 𝕜 E,	_inst_6 : module 𝕜 β,	_inst_7 : ordered_smul 𝕜 β,	s : set E,	f : E → β,	hf : convex_on 𝕜 s f,	x y z : E,	hx : x ∈ s,	hy : y ∈ s,	hz : z ∈ open_segment 𝕜 x y,	hyz : f y ≤ f z	⊢ f z ≤ f x
𝕜 : Type u_1,	E : Type u_2,	β : Type u_4,	_inst_1 : ordered_semiring 𝕜,	_inst_2 : add_comm_monoid E,	_inst_4 : linear_ordered_cancel_add_comm_monoid β,	_inst_5 : has_scalar 𝕜 E,	_inst_6 : module 𝕜 β,	_inst_7 : ordered_smul 𝕜 β,	s : set E,	f : E → β,	hf : convex_on 𝕜 s f,	x y : E,	hx : x ∈ s,	hy : y ∈ s,	a b : 𝕜,	ha : 0 < a,	hb : 0 < b,	hab : a + b = 1,	hyz : f y ≤ f (a • x + b • y)	⊢ f (a • x + b • y) ≤ f x
⊢ fourier_subalgebra.separates_points
x y : ↥circle,	hxy : x ≠ y	⊢ ∃ (f : ↥circle → ℂ) (H : f ∈ (λ (f : C(↥circle, ℂ)), ⇑f) '' ↑fourier_subalgebra), f x ≠ f y
2 goals	x y : ↥circle,	hxy : x ≠ y	⊢ fourier 1 ∈ ↑fourier_subalgebra		x y : ↥circle,	hxy : x ≠ y	⊢ (λ (f : C(↥circle, ℂ)), ⇑f) (fourier 1) x ≠ (λ (f : C(↥circle, ℂ)), ⇑f) (fourier 1) y
x y : ↥circle,	hxy : x ≠ y	⊢ (λ (f : C(↥circle, ℂ)), ⇑f) (fourier 1) x ≠ (λ (f : C(↥circle, ℂ)), ⇑f) (fourier 1) y
⊢ ∀ {𝕜 : Type u_1} {E : Type u_2} [_inst_1 : is_R_or_C 𝕜] [_inst_2 : inner_product_space 𝕜 E] {x : E},	    inner 0 x = 0
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : inner_product_space 𝕜 E,	x : E	⊢ inner 0 x = 0
⊢ ∀ (𝕜 : Type u_1) {E : Type u_2} [_inst_1 : is_R_or_C 𝕜] [_inst_2 : inner_product_space 𝕜 E] {v : E},	    ∥v∥ = 1 → ∀ (w : E), ↑(⇑(orthogonal_projection (submodule.span 𝕜 {v})) w) = inner v w • v
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : inner_product_space 𝕜 E,	v : E,	hv : ∥v∥ = 1,	w : E	⊢ ↑(⇑(orthogonal_projection (submodule.span 𝕜 {v})) w) = inner v w • v
𝕜 : Type u_1,	E : Type u_2,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : inner_product_space 𝕜 E,	v : E,	hv : ∥v∥ = 1,	w : E	⊢ ↑(⇑(orthogonal_projection (submodule.span 𝕜 {v})) w) =	    ↑∥v∥ ^ 2 • ↑(⇑(orthogonal_projection (submodule.span 𝕜 {v})) w)
⊢ ∀ {ι : Type u} (s : finset ι) {f g : ι → ℝ} {p q : ℝ},	    p.is_conjugate_exponent q →	    (∀ (i : ι), i ∈ s → 0 ≤ f i) →	    (∀ (i : ι), i ∈ s → 0 ≤ g i) →	    s.sum (λ (i : ι), f i * g i) ≤ s.sum (λ (i : ι), f i ^ p) ^ (1 / p) * s.sum (λ (i : ι), g i ^ q) ^ (1 / q)
ι : Type u,	s : finset ι,	f g : ι → ℝ,	p q : ℝ,	hpq : p.is_conjugate_exponent q,	hf : ∀ (i : ι), i ∈ s → 0 ≤ f i,	hg : ∀ (i : ι), i ∈ s → 0 ≤ g i	⊢ s.sum (λ (i : ι), f i * g i) ≤ s.sum (λ (i : ι), f i ^ p) ^ (1 / p) * s.sum (λ (i : ι), g i ^ q) ^ (1 / q)
2 goals	ι : Type u,	s : finset ι,	f g : ι → ℝ,	p q : ℝ,	hpq : p.is_conjugate_exponent q,	hf : ∀ (i : ι), i ∈ s → 0 ≤ f i,	hg : ∀ (i : ι), i ∈ s → 0 ≤ g i	⊢ s.sum (λ (i : ι), f i ^ p) = s.sum (λ (i : ι), |f i| ^ p)		ι : Type u,	s : finset ι,	f g : ι → ℝ,	p q : ℝ,	hpq : p.is_conjugate_exponent q,	hf : ∀ (i : ι), i ∈ s → 0 ≤ f i,	hg : ∀ (i : ι), i ∈ s → 0 ≤ g i	⊢ s.sum (λ (i : ι), g i ^ q) = s.sum (λ (i : ι), |g i| ^ q)
2 goals	ι : Type u,	s : finset ι,	f g : ι → ℝ,	p q : ℝ,	hpq : p.is_conjugate_exponent q,	hf : ∀ (i : ι), i ∈ s → 0 ≤ f i,	hg : ∀ (i : ι), i ∈ s → 0 ≤ g i	⊢ ∀ (x : ι), x ∈ s → f x ^ p = |f x| ^ p		ι : Type u,	s : finset ι,	f g : ι → ℝ,	p q : ℝ,	hpq : p.is_conjugate_exponent q,	hf : ∀ (i : ι), i ∈ s → 0 ≤ f i,	hg : ∀ (i : ι), i ∈ s → 0 ≤ g i	⊢ s.sum (λ (i : ι), g i ^ q) = s.sum (λ (i : ι), |g i| ^ q)
2 goals	ι : Type u,	s : finset ι,	f g : ι → ℝ,	p q : ℝ,	hpq : p.is_conjugate_exponent q,	hf : ∀ (i : ι), i ∈ s → 0 ≤ f i,	hg : ∀ (i : ι), i ∈ s → 0 ≤ g i,	i : ι,	hi : i ∈ s	⊢ f i ^ p = |f i| ^ p		ι : Type u,	s : finset ι,	f g : ι → ℝ,	p q : ℝ,	hpq : p.is_conjugate_exponent q,	hf : ∀ (i : ι), i ∈ s → 0 ≤ f i,	hg : ∀ (i : ι), i ∈ s → 0 ≤ g i	⊢ s.sum (λ (i : ι), g i ^ q) = s.sum (λ (i : ι), |g i| ^ q)
ι : Type u,	s : finset ι,	f g : ι → ℝ,	p q : ℝ,	hpq : p.is_conjugate_exponent q,	hf : ∀ (i : ι), i ∈ s → 0 ≤ f i,	hg : ∀ (i : ι), i ∈ s → 0 ≤ g i	⊢ s.sum (λ (i : ι), g i ^ q) = s.sum (λ (i : ι), |g i| ^ q)
ι : Type u,	s : finset ι,	f g : ι → ℝ,	p q : ℝ,	hpq : p.is_conjugate_exponent q,	hf : ∀ (i : ι), i ∈ s → 0 ≤ f i,	hg : ∀ (i : ι), i ∈ s → 0 ≤ g i	⊢ ∀ (x : ι), x ∈ s → g x ^ q = |g x| ^ q
ι : Type u,	s : finset ι,	f g : ι → ℝ,	p q : ℝ,	hpq : p.is_conjugate_exponent q,	hf : ∀ (i : ι), i ∈ s → 0 ≤ f i,	hg : ∀ (i : ι), i ∈ s → 0 ≤ g i,	i : ι,	hi : i ∈ s	⊢ g i ^ q = |g i| ^ q
⊢ ∀ {X Y Z : SemiNormedGroup} {f : X ⟶ Y} {g : Y ⟶ Z} (w : f ≫ g = 0) (e : explicit_cokernel f ⟶ Z),	    explicit_cokernel_π f ≫ e = g → e = explicit_cokernel_desc w
X Y Z : SemiNormedGroup,	f : X ⟶ Y,	g : Y ⟶ Z,	w : f ≫ g = 0,	e : explicit_cokernel f ⟶ Z,	he : explicit_cokernel_π f ≫ e = g	⊢ e = explicit_cokernel_desc w
X Y Z : SemiNormedGroup,	f : X ⟶ Y,	g : Y ⟶ Z,	w : f ≫ g = 0,	e : explicit_cokernel f ⟶ Z,	he : explicit_cokernel_π f ≫ e = g	⊢ ∀ (j : walking_parallel_pair), (cokernel_cocone f).ι.app j ≫ e = (cofork.of_π g _).ι.app j
2 goals	X Y Z : SemiNormedGroup,	f : X ⟶ Y,	g : Y ⟶ Z,	w : f ≫ g = 0,	e : explicit_cokernel f ⟶ Z,	he : explicit_cokernel_π f ≫ e = g	⊢ (cokernel_cocone f).ι.app walking_parallel_pair.zero ≫ e = (cofork.of_π g _).ι.app walking_parallel_pair.zero		X Y Z : SemiNormedGroup,	f : X ⟶ Y,	g : Y ⟶ Z,	w : f ≫ g = 0,	e : explicit_cokernel f ⟶ Z,	he : explicit_cokernel_π f ≫ e = g	⊢ (cokernel_cocone f).ι.app walking_parallel_pair.one ≫ e = (cofork.of_π g _).ι.app walking_parallel_pair.one
2 goals	X Y Z : SemiNormedGroup,	f : X ⟶ Y,	g : Y ⟶ Z,	w : f ≫ g = 0,	e : explicit_cokernel f ⟶ Z,	he : explicit_cokernel_π f ≫ e = g	⊢ (cokernel_cocone f).ι.app walking_parallel_pair.zero ≫ e = 0		X Y Z : SemiNormedGroup,	f : X ⟶ Y,	g : Y ⟶ Z,	w : f ≫ g = 0,	e : explicit_cokernel f ⟶ Z,	he : explicit_cokernel_π f ≫ e = g	⊢ (cokernel_cocone f).ι.app walking_parallel_pair.one ≫ e = (cofork.of_π g _).ι.app walking_parallel_pair.one
X Y Z : SemiNormedGroup,	f : X ⟶ Y,	g : Y ⟶ Z,	w : f ≫ g = 0,	e : explicit_cokernel f ⟶ Z,	he : explicit_cokernel_π f ≫ e = g	⊢ (cokernel_cocone f).ι.app walking_parallel_pair.one ≫ e = (cofork.of_π g _).ι.app walking_parallel_pair.one
⊢ ∀ {V : Type u_2} {P : Type u_3} [_inst_1 : semi_normed_group V] [_inst_2 : pseudo_metric_space P]	  [_inst_3 : normed_add_torsor V P] {𝕜 : Type u_6} [_inst_7 : normed_field 𝕜] [_inst_8 : normed_space 𝕜 V]	  (p₁ p₂ : P) (c : 𝕜), dist p₁ (⇑(homothety p₁ c) p₂) = ∥c∥ * dist p₁ p₂
V : Type u_2,	P : Type u_3,	_inst_1 : semi_normed_group V,	_inst_2 : pseudo_metric_space P,	_inst_3 : normed_add_torsor V P,	𝕜 : Type u_6,	_inst_7 : normed_field 𝕜,	_inst_8 : normed_space 𝕜 V,	p₁ p₂ : P,	c : 𝕜	⊢ dist p₁ (⇑(homothety p₁ c) p₂) = ∥c∥ * dist p₁ p₂
⊢ ∀ {ι : Type u_1} {E : Type u_3} [_inst_1 : semi_normed_group E] [_inst_3 : complete_space E] {f : ι → E},	    summable f ↔	      ∀ (ε : ℝ),	        ε > 0 → (∃ (s : finset ι), ∀ (t : finset ι), disjoint t s → ∥t.sum (λ (i : ι), f i)∥ < ε)
ι : Type u_1,	E : Type u_3,	_inst_1 : semi_normed_group E,	_inst_3 : complete_space E,	f : ι → E	⊢ summable f ↔	    ∀ (ε : ℝ),	      ε > 0 → (∃ (s : finset ι), ∀ (t : finset ι), disjoint t s → ∥t.sum (λ (i : ι), f i)∥ < ε)
⊢ ∀ {ι : Type u_1} {E : Type u_3} [_inst_1 : semi_normed_group E] {f : ι → E} {g : ι → nnreal} {a : nnreal},	    has_sum g a → (∀ (i : ι), ∥f i∥₊ ≤ g i) → ∥∑' (i : ι), f i∥₊ ≤ a
ι : Type u_1,	E : Type u_3,	_inst_1 : semi_normed_group E,	f : ι → E,	g : ι → nnreal,	a : nnreal,	hg : has_sum g a,	h : ∀ (i : ι), ∥f i∥₊ ≤ g i	⊢ ∥∑' (i : ι), f i∥₊ ≤ a
ι : Type u_1,	E : Type u_3,	_inst_1 : semi_normed_group E,	f : ι → E,	g : ι → nnreal,	a : nnreal,	hg : has_sum (λ (a : ι), ↑(g a)) ↑a,	h : ∀ (i : ι), ∥f i∥ ≤ ↑(g i)	⊢ ∥tsum f∥ ≤ ↑a
⊢ ∀ {E : Type u_3} [_inst_1 : semi_normed_group E] {w : E} {r : ℝ}, w ∈ sphere 0 r ↔ ∥w∥ = r
E : Type u_3,	_inst_1 : semi_normed_group E,	w : E,	r : ℝ	⊢ w ∈ sphere 0 r ↔ ∥w∥ = r
⊢ real.exp = exp ℝ ℝ
x : ℝ	⊢ real.exp x = exp ℝ ℝ x
x : ℝ	⊢ ∑' (z : ℕ), ⇑re_clm ((λ (n : ℕ), (1 / ↑(n.factorial)) • ↑x ^ n) z) =	    (λ (x : ℝ), ∑' (n : ℕ), x ^ n / ↑(n.factorial)) x
x : ℝ,	n : ℕ	⊢ ⇑re_clm ((λ (n : ℕ), (1 / ↑(n.factorial)) • ↑x ^ n) n) = x ^ n / ↑(nat.factorial n)
⊢ ∀ (𝕜 : Type u) [_inst_1 : nondiscrete_normed_field 𝕜] (E : Type v) [_inst_2 : normed_group E]	  [_inst_3 : normed_space 𝕜 E] [_inst_4 : proper_space 𝕜] [_inst_5 : finite_dimensional 𝕜 E], proper_space E
𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type v,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	_inst_4 : proper_space 𝕜,	_inst_5 : finite_dimensional 𝕜 E	⊢ proper_space E
𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type v,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	_inst_4 : proper_space 𝕜,	_inst_5 : finite_dimensional 𝕜 E,	e : E ≃L[𝕜] fin (finrank 𝕜 E) → 𝕜 := continuous_linear_equiv.of_finrank_eq _	⊢ proper_space E
⊢ ∀ {𝕜 : Type u} {G : Type wG} {G' : Type wG'} [_inst_5 : nondiscrete_normed_field 𝕜]	  [_inst_14 : normed_group G] [_inst_15 : normed_space 𝕜 G] [_inst_16 : normed_group G']	  [_inst_17 : normed_space 𝕜 G'] (f : continuous_multilinear_map 𝕜 (λ (i : fin 0), G) G') {x : fin 0 → G},	    ∥⇑f x∥ = ∥f∥
𝕜 : Type u,	G : Type wG,	G' : Type wG',	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_14 : normed_group G,	_inst_15 : normed_space 𝕜 G,	_inst_16 : normed_group G',	_inst_17 : normed_space 𝕜 G',	f : continuous_multilinear_map 𝕜 (λ (i : fin 0), G) G',	x : fin 0 → G	⊢ ∥⇑f x∥ = ∥f∥
𝕜 : Type u,	G : Type wG,	G' : Type wG',	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_14 : normed_group G,	_inst_15 : normed_space 𝕜 G,	_inst_16 : normed_group G',	_inst_17 : normed_space 𝕜 G',	f : continuous_multilinear_map 𝕜 (λ (i : fin 0), G) G',	x : fin 0 → G,	this : x = 0	⊢ ∥⇑f x∥ = ∥f∥
𝕜 : Type u,	G : Type wG,	G' : Type wG',	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_14 : normed_group G,	_inst_15 : normed_space 𝕜 G,	_inst_16 : normed_group G',	_inst_17 : normed_space 𝕜 G',	f : continuous_multilinear_map 𝕜 (λ (i : fin 0), G) G'	⊢ ∥⇑f 0∥ = ∥f∥
𝕜 : Type u,	G : Type wG,	G' : Type wG',	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_14 : normed_group G,	_inst_15 : normed_space 𝕜 G,	_inst_16 : normed_group G',	_inst_17 : normed_space 𝕜 G',	f : continuous_multilinear_map 𝕜 (λ (i : fin 0), G) G'	⊢ ∥f∥ ≤ ∥⇑f 0∥
𝕜 : Type u,	G : Type wG,	G' : Type wG',	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_14 : normed_group G,	_inst_15 : normed_space 𝕜 G,	_inst_16 : normed_group G',	_inst_17 : normed_space 𝕜 G',	f : continuous_multilinear_map 𝕜 (λ (i : fin 0), G) G',	this : ∥curry0 𝕜 G f.uncurry0∥ ≤ ∥f.uncurry0∥	⊢ ∥f∥ ≤ ∥⇑f 0∥
⊢ ∀ {V₁ : Type u_3} {V₂ : Type u_4} {V₃ : Type u_5} [_inst_3 : semi_normed_group V₁]	  [_inst_4 : semi_normed_group V₂] [_inst_5 : semi_normed_group V₃] {W₁ : Type u_6} {W₂ : Type u_7}	  {W₃ : Type u_8} [_inst_6 : semi_normed_group W₁] [_inst_7 : semi_normed_group W₂]	  [_inst_8 : semi_normed_group W₃] {f₁ : normed_group_hom V₁ W₁} {f₂ : normed_group_hom V₂ W₂}	  {f₃ : normed_group_hom V₃ W₃} {φ : normed_group_hom V₁ V₂} {ψ : normed_group_hom W₁ W₂}	  {φ' : normed_group_hom V₂ V₃} {ψ' : normed_group_hom W₂ W₃},	    ψ.comp f₁ = f₂.comp φ → ψ'.comp f₂ = f₃.comp φ' → (ψ'.comp ψ).comp f₁ = f₃.comp (φ'.comp φ)
V₁ : Type u_3,	V₂ : Type u_4,	V₃ : Type u_5,	_inst_3 : semi_normed_group V₁,	_inst_4 : semi_normed_group V₂,	_inst_5 : semi_normed_group V₃,	W₁ : Type u_6,	W₂ : Type u_7,	W₃ : Type u_8,	_inst_6 : semi_normed_group W₁,	_inst_7 : semi_normed_group W₂,	_inst_8 : semi_normed_group W₃,	f₁ : normed_group_hom V₁ W₁,	f₂ : normed_group_hom V₂ W₂,	f₃ : normed_group_hom V₃ W₃,	φ : normed_group_hom V₁ V₂,	ψ : normed_group_hom W₁ W₂,	φ' : normed_group_hom V₂ V₃,	ψ' : normed_group_hom W₂ W₃,	hf : ψ.comp f₁ = f₂.comp φ,	hf' : ψ'.comp f₂ = f₃.comp φ'	⊢ (ψ'.comp ψ).comp f₁ = f₃.comp (φ'.comp φ)
⊢ ∀ {𝕜 : Type u_1} {E : Type u_4} {Fₗ : Type u_6} [_inst_1 : normed_group E] [_inst_4 : normed_group Fₗ]	  [_inst_5 : nondiscrete_normed_field 𝕜] [_inst_8 : normed_space 𝕜 E] [_inst_11 : normed_space 𝕜 Fₗ]	  (c : E →L[𝕜] 𝕜) (f : Fₗ), ∥c.smul_right f∥ = ∥c∥ * ∥f∥
𝕜 : Type u_1,	E : Type u_4,	Fₗ : Type u_6,	_inst_1 : normed_group E,	_inst_4 : normed_group Fₗ,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_8 : normed_space 𝕜 E,	_inst_11 : normed_space 𝕜 Fₗ,	c : E →L[𝕜] 𝕜,	f : Fₗ	⊢ ∥c.smul_right f∥ = ∥c∥ * ∥f∥
2 goals	𝕜 : Type u_1,	E : Type u_4,	Fₗ : Type u_6,	_inst_1 : normed_group E,	_inst_4 : normed_group Fₗ,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_8 : normed_space 𝕜 E,	_inst_11 : normed_space 𝕜 Fₗ,	c : E →L[𝕜] 𝕜,	f : Fₗ	⊢ ∥c.smul_right f∥ ≤ ∥c∥ * ∥f∥		𝕜 : Type u_1,	E : Type u_4,	Fₗ : Type u_6,	_inst_1 : normed_group E,	_inst_4 : normed_group Fₗ,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_8 : normed_space 𝕜 E,	_inst_11 : normed_space 𝕜 Fₗ,	c : E →L[𝕜] 𝕜,	f : Fₗ	⊢ ∥c∥ * ∥f∥ ≤ ∥c.smul_right f∥
2 goals	𝕜 : Type u_1,	E : Type u_4,	Fₗ : Type u_6,	_inst_1 : normed_group E,	_inst_4 : normed_group Fₗ,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_8 : normed_space 𝕜 E,	_inst_11 : normed_space 𝕜 Fₗ,	c : E →L[𝕜] 𝕜,	f : Fₗ,	x : E	⊢ ∥⇑(c.smul_right f) x∥ ≤ ∥c∥ * ∥f∥ * ∥x∥		𝕜 : Type u_1,	E : Type u_4,	Fₗ : Type u_6,	_inst_1 : normed_group E,	_inst_4 : normed_group Fₗ,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_8 : normed_space 𝕜 E,	_inst_11 : normed_space 𝕜 Fₗ,	c : E →L[𝕜] 𝕜,	f : Fₗ	⊢ ∥c∥ * ∥f∥ ≤ ∥c.smul_right f∥
𝕜 : Type u_1,	E : Type u_4,	Fₗ : Type u_6,	_inst_1 : normed_group E,	_inst_4 : normed_group Fₗ,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_8 : normed_space 𝕜 E,	_inst_11 : normed_space 𝕜 Fₗ,	c : E →L[𝕜] 𝕜,	f : Fₗ	⊢ ∥c∥ * ∥f∥ ≤ ∥c.smul_right f∥
2 goals	𝕜 : Type u_1,	E : Type u_4,	Fₗ : Type u_6,	_inst_1 : normed_group E,	_inst_4 : normed_group Fₗ,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_8 : normed_space 𝕜 E,	_inst_11 : normed_space 𝕜 Fₗ,	c : E →L[𝕜] 𝕜,	f : Fₗ,	h : f = 0	⊢ ∥c∥ * ∥f∥ ≤ ∥c.smul_right f∥		𝕜 : Type u_1,	E : Type u_4,	Fₗ : Type u_6,	_inst_1 : normed_group E,	_inst_4 : normed_group Fₗ,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_8 : normed_space 𝕜 E,	_inst_11 : normed_space 𝕜 Fₗ,	c : E →L[𝕜] 𝕜,	f : Fₗ,	h : ¬f = 0	⊢ ∥c∥ * ∥f∥ ≤ ∥c.smul_right f∥
𝕜 : Type u_1,	E : Type u_4,	Fₗ : Type u_6,	_inst_1 : normed_group E,	_inst_4 : normed_group Fₗ,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_8 : normed_space 𝕜 E,	_inst_11 : normed_space 𝕜 Fₗ,	c : E →L[𝕜] 𝕜,	f : Fₗ,	h : ¬f = 0	⊢ ∥c∥ * ∥f∥ ≤ ∥c.smul_right f∥
𝕜 : Type u_1,	E : Type u_4,	Fₗ : Type u_6,	_inst_1 : normed_group E,	_inst_4 : normed_group Fₗ,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_8 : normed_space 𝕜 E,	_inst_11 : normed_space 𝕜 Fₗ,	c : E →L[𝕜] 𝕜,	f : Fₗ,	h : ¬f = 0,	this : 0 < ∥f∥	⊢ ∥c∥ * ∥f∥ ≤ ∥c.smul_right f∥
𝕜 : Type u_1,	E : Type u_4,	Fₗ : Type u_6,	_inst_1 : normed_group E,	_inst_4 : normed_group Fₗ,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_8 : normed_space 𝕜 E,	_inst_11 : normed_space 𝕜 Fₗ,	c : E →L[𝕜] 𝕜,	f : Fₗ,	h : ¬f = 0,	this : 0 < ∥f∥	⊢ ∥c∥ ≤ ∥c.smul_right f∥ / ∥f∥
𝕜 : Type u_1,	E : Type u_4,	Fₗ : Type u_6,	_inst_1 : normed_group E,	_inst_4 : normed_group Fₗ,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_8 : normed_space 𝕜 E,	_inst_11 : normed_space 𝕜 Fₗ,	c : E →L[𝕜] 𝕜,	f : Fₗ,	h : ¬f = 0,	this : 0 < ∥f∥,	x : E	⊢ ∥⇑c x∥ ≤ ∥c.smul_right f∥ / ∥f∥ * ∥x∥
𝕜 : Type u_1,	E : Type u_4,	Fₗ : Type u_6,	_inst_1 : normed_group E,	_inst_4 : normed_group Fₗ,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_8 : normed_space 𝕜 E,	_inst_11 : normed_space 𝕜 Fₗ,	c : E →L[𝕜] 𝕜,	f : Fₗ,	h : ¬f = 0,	this : 0 < ∥f∥,	x : E	⊢ ∥⇑c x∥ * ∥f∥ ≤ ∥c.smul_right f∥ * ∥x∥
⊢ ∀ (𝕜 : Type u_1) [_inst_5 : nondiscrete_normed_field 𝕜] (𝕜' : Type u_11) [_inst_23 : normed_ring 𝕜']	  [_inst_24 : normed_algebra 𝕜 𝕜'], ∥lmul 𝕜 𝕜'∥ = 1
𝕜 : Type u_1,	_inst_5 : nondiscrete_normed_field 𝕜,	𝕜' : Type u_11,	_inst_23 : normed_ring 𝕜',	_inst_24 : normed_algebra 𝕜 𝕜'	⊢ ∥lmul 𝕜 𝕜'∥ = 1
𝕜 : Type u_1,	_inst_5 : nondiscrete_normed_field 𝕜,	𝕜' : Type u_11,	_inst_23 : normed_ring 𝕜',	_inst_24 : normed_algebra 𝕜 𝕜',	_inst : nontrivial 𝕜'	⊢ ∥lmul 𝕜 𝕜'∥ = 1
⊢ ∀ (𝕜 : Type u_1) {E : Type u_4} [_inst_1 : semi_normed_group E] [_inst_6 : nondiscrete_normed_field 𝕜]	  [_inst_9 : normed_space 𝕜 E] (x : E) (c : 𝕜),	    ∥⇑(linear_map.to_span_singleton 𝕜 E x) c∥ = ∥x∥ * ∥c∥
𝕜 : Type u_1,	E : Type u_4,	_inst_1 : semi_normed_group E,	_inst_6 : nondiscrete_normed_field 𝕜,	_inst_9 : normed_space 𝕜 E,	x : E,	c : 𝕜	⊢ ∥⇑(linear_map.to_span_singleton 𝕜 E x) c∥ = ∥x∥ * ∥c∥
𝕜 : Type u_1,	E : Type u_4,	_inst_1 : semi_normed_group E,	_inst_6 : nondiscrete_normed_field 𝕜,	_inst_9 : normed_space 𝕜 E,	x : E,	c : 𝕜	⊢ ∥⇑(linear_map.to_span_singleton 𝕜 E x) c∥ = ∥c∥ * ∥x∥
⊢ ∀ {𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_4} {F : Type u_5} [_inst_1 : normed_group E]	  [_inst_2 : normed_group F] [_inst_5 : nondiscrete_normed_field 𝕜] [_inst_6 : nondiscrete_normed_field 𝕜₂]	  [_inst_8 : normed_space 𝕜 E] [_inst_9 : normed_space 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂}	  [_inst_12 : ring_hom_isometric σ₁₂] [_inst_13 : nontrivial E] (f : E →SL[σ₁₂] F) {a : ℝ},	    (∀ (x : E), ∥⇑f x∥ = a * ∥x∥) → ∥f∥ = a
𝕜 : Type u_1,	𝕜₂ : Type u_2,	E : Type u_4,	F : Type u_5,	_inst_1 : normed_group E,	_inst_2 : normed_group F,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_6 : nondiscrete_normed_field 𝕜₂,	_inst_8 : normed_space 𝕜 E,	_inst_9 : normed_space 𝕜₂ F,	σ₁₂ : 𝕜 →+* 𝕜₂,	_inst_12 : ring_hom_isometric σ₁₂,	_inst_13 : nontrivial E,	f : E →SL[σ₁₂] F,	a : ℝ,	hf : ∀ (x : E), ∥⇑f x∥ = a * ∥x∥	⊢ ∥f∥ = a
𝕜 : Type u_1,	𝕜₂ : Type u_2,	E : Type u_4,	F : Type u_5,	_inst_1 : normed_group E,	_inst_2 : normed_group F,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_6 : nondiscrete_normed_field 𝕜₂,	_inst_8 : normed_space 𝕜 E,	_inst_9 : normed_space 𝕜₂ F,	σ₁₂ : 𝕜 →+* 𝕜₂,	_inst_12 : ring_hom_isometric σ₁₂,	_inst_13 : nontrivial E,	f : E →SL[σ₁₂] F,	a : ℝ,	hf : ∀ (x : E), ∥⇑f x∥ = a * ∥x∥,	x : E,	hx : x ≠ 0	⊢ ∥f∥ = a
𝕜 : Type u_1,	𝕜₂ : Type u_2,	E : Type u_4,	F : Type u_5,	_inst_1 : normed_group E,	_inst_2 : normed_group F,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_6 : nondiscrete_normed_field 𝕜₂,	_inst_8 : normed_space 𝕜 E,	_inst_9 : normed_space 𝕜₂ F,	σ₁₂ : 𝕜 →+* 𝕜₂,	_inst_12 : ring_hom_isometric σ₁₂,	_inst_13 : nontrivial E,	f : E →SL[σ₁₂] F,	a : ℝ,	hf : ∀ (x : E), ∥⇑f x∥ = a * ∥x∥,	x : E,	hx : 0 < ∥x∥	⊢ ∥f∥ = a
2 goals	𝕜 : Type u_1,	𝕜₂ : Type u_2,	E : Type u_4,	F : Type u_5,	_inst_1 : normed_group E,	_inst_2 : normed_group F,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_6 : nondiscrete_normed_field 𝕜₂,	_inst_8 : normed_space 𝕜 E,	_inst_9 : normed_space 𝕜₂ F,	σ₁₂ : 𝕜 →+* 𝕜₂,	_inst_12 : ring_hom_isometric σ₁₂,	_inst_13 : nontrivial E,	f : E →SL[σ₁₂] F,	a : ℝ,	hf : ∀ (x : E), ∥⇑f x∥ = a * ∥x∥,	x : E,	hx : 0 < ∥x∥	⊢ 0 ≤ a		𝕜 : Type u_1,	𝕜₂ : Type u_2,	E : Type u_4,	F : Type u_5,	_inst_1 : normed_group E,	_inst_2 : normed_group F,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_6 : nondiscrete_normed_field 𝕜₂,	_inst_8 : normed_space 𝕜 E,	_inst_9 : normed_space 𝕜₂ F,	σ₁₂ : 𝕜 →+* 𝕜₂,	_inst_12 : ring_hom_isometric σ₁₂,	_inst_13 : nontrivial E,	f : E →SL[σ₁₂] F,	a : ℝ,	hf : ∀ (x : E), ∥⇑f x∥ = a * ∥x∥,	x : E,	hx : 0 < ∥x∥,	ha : 0 ≤ a	⊢ ∥f∥ = a
𝕜 : Type u_1,	𝕜₂ : Type u_2,	E : Type u_4,	F : Type u_5,	_inst_1 : normed_group E,	_inst_2 : normed_group F,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_6 : nondiscrete_normed_field 𝕜₂,	_inst_8 : normed_space 𝕜 E,	_inst_9 : normed_space 𝕜₂ F,	σ₁₂ : 𝕜 →+* 𝕜₂,	_inst_12 : ring_hom_isometric σ₁₂,	_inst_13 : nontrivial E,	f : E →SL[σ₁₂] F,	a : ℝ,	hf : ∀ (x : E), ∥⇑f x∥ = a * ∥x∥,	x : E,	hx : 0 < ∥x∥,	ha : 0 ≤ a	⊢ ∥f∥ = a
𝕜 : Type u_1,	𝕜₂ : Type u_2,	E : Type u_4,	F : Type u_5,	_inst_1 : normed_group E,	_inst_2 : normed_group F,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_6 : nondiscrete_normed_field 𝕜₂,	_inst_8 : normed_space 𝕜 E,	_inst_9 : normed_space 𝕜₂ F,	σ₁₂ : 𝕜 →+* 𝕜₂,	_inst_12 : ring_hom_isometric σ₁₂,	_inst_13 : nontrivial E,	f : E →SL[σ₁₂] F,	a : ℝ,	hf : ∀ (x : E), ∥⇑f x∥ = a * ∥x∥,	x : E,	hx : 0 < ∥x∥,	ha : 0 ≤ a	⊢ a ≤ ∥f∥
⊢ 1.arg = 0
⊢ ∀ {𝕜 : Type u_1} [_inst_1 : normed_linear_ordered_field 𝕜] (P Q : polynomial 𝕜)	  [_inst_2 : order_topology 𝕜],	    Q.degree < P.degree → Q ≠ 0 → tendsto (λ (x : 𝕜), |eval x P / eval x Q|) at_top at_top
𝕜 : Type u_1,	_inst_1 : normed_linear_ordered_field 𝕜,	P Q : polynomial 𝕜,	_inst_2 : order_topology 𝕜,	hdeg : Q.degree < P.degree,	hQ : Q ≠ 0	⊢ tendsto (λ (x : 𝕜), |eval x P / eval x Q|) at_top at_top
2 goals	𝕜 : Type u_1,	_inst_1 : normed_linear_ordered_field 𝕜,	P Q : polynomial 𝕜,	_inst_2 : order_topology 𝕜,	hdeg : Q.degree < P.degree,	hQ : Q ≠ 0,	h : 0 ≤ P.leading_coeff / Q.leading_coeff	⊢ tendsto (λ (x : 𝕜), |eval x P / eval x Q|) at_top at_top		𝕜 : Type u_1,	_inst_1 : normed_linear_ordered_field 𝕜,	P Q : polynomial 𝕜,	_inst_2 : order_topology 𝕜,	hdeg : Q.degree < P.degree,	hQ : Q ≠ 0,	h : ¬0 ≤ P.leading_coeff / Q.leading_coeff	⊢ tendsto (λ (x : 𝕜), |eval x P / eval x Q|) at_top at_top
𝕜 : Type u_1,	_inst_1 : normed_linear_ordered_field 𝕜,	P Q : polynomial 𝕜,	_inst_2 : order_topology 𝕜,	hdeg : Q.degree < P.degree,	hQ : Q ≠ 0,	h : ¬0 ≤ P.leading_coeff / Q.leading_coeff	⊢ tendsto (λ (x : 𝕜), |eval x P / eval x Q|) at_top at_top
𝕜 : Type u_1,	_inst_1 : normed_linear_ordered_field 𝕜,	P Q : polynomial 𝕜,	_inst_2 : order_topology 𝕜,	hdeg : Q.degree < P.degree,	hQ : Q ≠ 0,	h : P.leading_coeff / Q.leading_coeff < 0	⊢ tendsto (λ (x : 𝕜), |eval x P / eval x Q|) at_top at_top
⊢ ∀ {x y z : ℝ}, 0 < x → 0 < y → (x < y ^ z ↔ log x < z * log y)
x y z : ℝ,	hx : 0 < x,	hy : 0 < y	⊢ x < y ^ z ↔ log x < z * log y
⊢ ∀ {f : ℝ → ℝ} {s : set ℝ} {f' x : ℝ},	    has_deriv_within_at f f' s x →	    f x ≠ 0 → has_deriv_within_at (λ (y : ℝ), sqrt (f y)) (f' / (2 * sqrt (f x))) s x
f : ℝ → ℝ,	s : set ℝ,	f' x : ℝ,	hf : has_deriv_within_at f f' s x,	hx : f x ≠ 0	⊢ has_deriv_within_at (λ (y : ℝ), sqrt (f y)) (f' / (2 * sqrt (f x))) s x
⊢ ∀ {α : Type u_1} [_inst_1 : pseudo_emetric_space α] (C : ennreal) {f : ℕ → α},	    (∀ (n : ℕ), edist (f n) (f (n + 1)) ≤ C / 2 ^ n) →	    ∀ {a : α}, tendsto f at_top (nhds a) → edist (f 0) a ≤ 2 * C
α : Type u_1,	_inst_1 : pseudo_emetric_space α,	C : ennreal,	f : ℕ → α,	hu : ∀ (n : ℕ), edist (f n) (f (n + 1)) ≤ C / 2 ^ n,	a : α,	ha : tendsto f at_top (nhds a)	⊢ edist (f 0) a ≤ 2 * C
⊢ ∀ {α : Type u_1} [_inst_1 : semi_normed_group α] (u : ℕ → α) (n : ℕ),	    dist ((range (n + 1)).sum (λ (k : ℕ), u k)) ((range n).sum (λ (k : ℕ), u k)) = ∥u n∥
α : Type u_1,	_inst_1 : semi_normed_group α,	u : ℕ → α,	n : ℕ	⊢ dist ((range (n + 1)).sum (λ (k : ℕ), u k)) ((range n).sum (λ (k : ℕ), u k)) = ∥u n∥
⊢ ∀ {m : ℝ} {f : ℕ → ℕ}, 1 < m → (∀ (i : ℕ), i ≤ f i) → summable (λ (i : ℕ), 1 / m ^ f i)
m : ℝ,	f : ℕ → ℕ,	hm : 1 < m,	fi : ∀ (i : ℕ), i ≤ f i	⊢ summable (λ (i : ℕ), 1 / m ^ f i)
m : ℝ,	f : ℕ → ℕ,	hm : 1 < m,	fi : ∀ (i : ℕ), i ≤ f i,	a : ℕ	⊢ 1 / m ^ f a ≤ (1 / m) ^ a
m : ℝ,	f : ℕ → ℕ,	hm : 1 < m,	fi : ∀ (i : ℕ), i ≤ f i,	a : ℕ	⊢ 1 / m ^ f a ≤ 1 / m ^ a
2 goals	m : ℝ,	f : ℕ → ℕ,	hm : 1 < m,	fi : ∀ (i : ℕ), i ≤ f i,	a : ℕ	⊢ 0 < m ^ f a		m : ℝ,	f : ℕ → ℕ,	hm : 1 < m,	fi : ∀ (i : ℕ), i ≤ f i,	a : ℕ	⊢ 0 < m ^ a
m : ℝ,	f : ℕ → ℕ,	hm : 1 < m,	fi : ∀ (i : ℕ), i ≤ f i,	a : ℕ	⊢ 0 < m ^ a
⊢ ∀ {C : Type u} [_inst_1 : category C] [_inst_2 : non_preadditive_abelian C] (X Y Z : C) (f : X ⟶ Y)	  (g h : Y ⟶ Z), f ≫ (g + h) = f ≫ g + f ≫ h
C : Type u,	_inst_1 : category C,	_inst_2 : non_preadditive_abelian C,	X Y Z : C,	f : X ⟶ Y,	g h : Y ⟶ Z	⊢ f ≫ (g + h) = f ≫ g + f ≫ h
⊢ ∀ {X : Type u} [_inst_1 : preorder X] {x y : X} (h : x ⟶ y), _.hom = h
X : Type u,	_inst_1 : preorder X,	x y : X,	h : x ⟶ y	⊢ _.hom = h
X : Type u,	_inst_1 : preorder X,	x y : X,	h : plift (x ≤ y)	⊢ _.hom = {down := h}
X : Type u,	_inst_1 : preorder X,	x y : X,	h : x ≤ y	⊢ _.hom = {down := {down := h}}
⊢ ∀ {C : Type u} [_inst_1 : category C] {A B : C} [_inst_2 : has_finite_products C] [_inst_3 : exponentiable A]	  (f : B ⟶ A) [_inst_4 : exponentiable B] (X : C),	    uncurry ((pre f).app X) = prod.map f (𝟙 ((exp A).obj X)) ≫ (ev A).app X
C : Type u,	_inst_1 : category C,	A B : C,	_inst_2 : has_finite_products C,	_inst_3 : exponentiable A,	f : B ⟶ A,	_inst_4 : exponentiable B,	X : C	⊢ uncurry ((pre f).app X) = prod.map f (𝟙 ((exp A).obj X)) ≫ (ev A).app X
⊢ ∀ {C : Type u} [_inst_1 : category C] [_inst_2 : has_finite_products C] {A₁ A₂ A₃ : C}	  [_inst_4 : exponentiable A₁] [_inst_5 : exponentiable A₂] [_inst_6 : exponentiable A₃] (f : A₁ ⟶ A₂)	  (g : A₂ ⟶ A₃), pre (f ≫ g) = pre g ≫ pre f
C : Type u,	_inst_1 : category C,	_inst_2 : has_finite_products C,	A₁ A₂ A₃ : C,	_inst_4 : exponentiable A₁,	_inst_5 : exponentiable A₂,	_inst_6 : exponentiable A₃,	f : A₁ ⟶ A₂,	g : A₂ ⟶ A₃	⊢ pre (f ≫ g) = pre g ≫ pre f
⊢ ∀ {C : Type u} [_inst_1 : category C] {D : Type u'} [_inst_2 : category D] [_inst_3 : has_finite_products C]	  [_inst_4 : has_finite_products D] (F : C ⥤ D) {L : D ⥤ C} [_inst_5 : cartesian_closed C]	  [_inst_6 : cartesian_closed D] [_inst_7 : preserves_limits_of_shape (discrete walking_pair) F] (h : L ⊣ F) (A : C)	  [i : is_iso (frobenius_morphism F h A)], is_iso (exp_comparison F A)
C : Type u,	_inst_1 : category C,	D : Type u',	_inst_2 : category D,	_inst_3 : has_finite_products C,	_inst_4 : has_finite_products D,	F : C ⥤ D,	L : D ⥤ C,	_inst_5 : cartesian_closed C,	_inst_6 : cartesian_closed D,	_inst_7 : preserves_limits_of_shape (discrete walking_pair) F,	h : L ⊣ F,	A : C,	i : is_iso (frobenius_morphism F h A)	⊢ is_iso (exp_comparison F A)
C : Type u,	_inst_1 : category C,	D : Type u',	_inst_2 : category D,	_inst_3 : has_finite_products C,	_inst_4 : has_finite_products D,	F : C ⥤ D,	L : D ⥤ C,	_inst_5 : cartesian_closed C,	_inst_6 : cartesian_closed D,	_inst_7 : preserves_limits_of_shape (discrete walking_pair) F,	h : L ⊣ F,	A : C,	i : is_iso (frobenius_morphism F h A)	⊢ is_iso	    (⇑(transfer_nat_trans_self (adjunction.comp (prod.functor.obj A) (exp A) h (exp.adjunction A))	          (adjunction.comp L F (exp.adjunction (F.obj A)) h))	       (frobenius_morphism F h A))
⊢ ∀ {C : Type u₁} [_inst_1 : category C] {D : Type u₂} [_inst_2 : category D] {F G : C ⥤ D},	    (∀ (X : C), F.obj X = G.obj X) → (∀ (X Y : C) (f : X ⟶ Y), F.map f == G.map f) → F = G
C : Type u₁,	_inst_1 : category C,	D : Type u₂,	_inst_2 : category D,	F G : C ⥤ D,	h_obj : ∀ (X : C), F.obj X = G.obj X,	h_map : ∀ (X Y : C) (f : X ⟶ Y), F.map f == G.map f	⊢ F = G
C : Type u₁,	_inst_1 : category C,	D : Type u₂,	_inst_2 : category D,	G : C ⥤ D,	F_obj : C → D,	F_map : Π {X Y : C}, (X ⟶ Y) → (F_obj X ⟶ F_obj Y),	F_map_id' : auto_param (∀ (X : C), F_map (𝟙 X) = 𝟙 (F_obj X)) (name.mk_string "obviously" name.anonymous),	F_map_comp' :	  auto_param (∀ {X Y Z : C} (f : X ⟶ Y) (g : Y ⟶ Z), F_map (f ≫ g) = F_map f ≫ F_map g)	    (name.mk_string "obviously" name.anonymous),	h_obj : ∀ (X : C), {obj := F_obj, map := F_map, map_id' := F_map_id', map_comp' := F_map_comp'}.obj X = G.obj X,	h_map :	  ∀ (X Y : C) (f : X ⟶ Y),	    {obj := F_obj, map := F_map, map_id' := F_map_id', map_comp' := F_map_comp'}.map f == G.map f	⊢ {obj := F_obj, map := F_map, map_id' := F_map_id', map_comp' := F_map_comp'} = G
C : Type u₁,	_inst_1 : category C,	D : Type u₂,	_inst_2 : category D,	F_obj : C → D,	F_map : Π {X Y : C}, (X ⟶ Y) → (F_obj X ⟶ F_obj Y),	F_map_id' : auto_param (∀ (X : C), F_map (𝟙 X) = 𝟙 (F_obj X)) (name.mk_string "obviously" name.anonymous),	F_map_comp' :	  auto_param (∀ {X Y Z : C} (f : X ⟶ Y) (g : Y ⟶ Z), F_map (f ≫ g) = F_map f ≫ F_map g)	    (name.mk_string "obviously" name.anonymous),	G_obj : C → D,	G_map : Π {X Y : C}, (X ⟶ Y) → (G_obj X ⟶ G_obj Y),	G_map_id' : auto_param (∀ (X : C), G_map (𝟙 X) = 𝟙 (G_obj X)) (name.mk_string "obviously" name.anonymous),	G_map_comp' :	  auto_param (∀ {X Y Z : C} (f : X ⟶ Y) (g : Y ⟶ Z), G_map (f ≫ g) = G_map f ≫ G_map g)	    (name.mk_string "obviously" name.anonymous),	h_obj :	  ∀ (X : C),	    {obj := F_obj, map := F_map, map_id' := F_map_id', map_comp' := F_map_comp'}.obj X =	      {obj := G_obj, map := G_map, map_id' := G_map_id', map_comp' := G_map_comp'}.obj X,	h_map :	  ∀ (X Y : C) (f : X ⟶ Y),	    {obj := F_obj, map := F_map, map_id' := F_map_id', map_comp' := F_map_comp'}.map f ==	      {obj := G_obj, map := G_map, map_id' := G_map_id', map_comp' := G_map_comp'}.map f	⊢ {obj := F_obj, map := F_map, map_id' := F_map_id', map_comp' := F_map_comp'} =	    {obj := G_obj, map := G_map, map_id' := G_map_id', map_comp' := G_map_comp'}
2 goals	C : Type u₁,	_inst_1 : category C,	D : Type u₂,	_inst_2 : category D,	F_obj : C → D,	F_map : Π {X Y : C}, (X ⟶ Y) → (F_obj X ⟶ F_obj Y),	F_map_id' : auto_param (∀ (X : C), F_map (𝟙 X) = 𝟙 (F_obj X)) (name.mk_string "obviously" name.anonymous),	F_map_comp' :	  auto_param (∀ {X Y Z : C} (f : X ⟶ Y) (g : Y ⟶ Z), F_map (f ≫ g) = F_map f ≫ F_map g)	    (name.mk_string "obviously" name.anonymous),	G_obj : C → D,	G_map : Π {X Y : C}, (X ⟶ Y) → (G_obj X ⟶ G_obj Y),	G_map_id' : auto_param (∀ (X : C), G_map (𝟙 X) = 𝟙 (G_obj X)) (name.mk_string "obviously" name.anonymous),	G_map_comp' :	  auto_param (∀ {X Y Z : C} (f : X ⟶ Y) (g : Y ⟶ Z), G_map (f ≫ g) = G_map f ≫ G_map g)	    (name.mk_string "obviously" name.anonymous),	h_obj :	  ∀ (X : C),	    {obj := F_obj, map := F_map, map_id' := F_map_id', map_comp' := F_map_comp'}.obj X =	      {obj := G_obj, map := G_map, map_id' := G_map_id', map_comp' := G_map_comp'}.obj X,	h_map :	  ∀ (X Y : C) (f : X ⟶ Y),	    {obj := F_obj, map := F_map, map_id' := F_map_id', map_comp' := F_map_comp'}.map f ==	      {obj := G_obj, map := G_map, map_id' := G_map_id', map_comp' := G_map_comp'}.map f	⊢ F_obj = G_obj		C : Type u₁,	_inst_1 : category C,	D : Type u₂,	_inst_2 : category D,	F_obj : C → D,	F_map : Π {X Y : C}, (X ⟶ Y) → (F_obj X ⟶ F_obj Y),	F_map_id' : auto_param (∀ (X : C), F_map (𝟙 X) = 𝟙 (F_obj X)) (name.mk_string "obviously" name.anonymous),	F_map_comp' :	  auto_param (∀ {X Y Z : C} (f : X ⟶ Y) (g : Y ⟶ Z), F_map (f ≫ g) = F_map f ≫ F_map g)	    (name.mk_string "obviously" name.anonymous),	G_obj : C → D,	G_map : Π {X Y : C}, (X ⟶ Y) → (G_obj X ⟶ G_obj Y),	G_map_id' : auto_param (∀ (X : C), G_map (𝟙 X) = 𝟙 (G_obj X)) (name.mk_string "obviously" name.anonymous),	G_map_comp' :	  auto_param (∀ {X Y Z : C} (f : X ⟶ Y) (g : Y ⟶ Z), G_map (f ≫ g) = G_map f ≫ G_map g)	    (name.mk_string "obviously" name.anonymous),	h_obj :	  ∀ (X : C),	    {obj := F_obj, map := F_map, map_id' := F_map_id', map_comp' := F_map_comp'}.obj X =	      {obj := G_obj, map := G_map, map_id' := G_map_id', map_comp' := G_map_comp'}.obj X,	h_map :	  ∀ (X Y : C) (f : X ⟶ Y),	    {obj := F_obj, map := F_map, map_id' := F_map_id', map_comp' := F_map_comp'}.map f ==	      {obj := G_obj, map := G_map, map_id' := G_map_id', map_comp' := G_map_comp'}.map f,	this : F_obj = G_obj	⊢ {obj := F_obj, map := F_map, map_id' := F_map_id', map_comp' := F_map_comp'} =	    {obj := G_obj, map := G_map, map_id' := G_map_id', map_comp' := G_map_comp'}
2 goals	C : Type u₁,	_inst_1 : category C,	D : Type u₂,	_inst_2 : category D,	F_obj : C → D,	F_map : Π {X Y : C}, (X ⟶ Y) → (F_obj X ⟶ F_obj Y),	F_map_id' : auto_param (∀ (X : C), F_map (𝟙 X) = 𝟙 (F_obj X)) (name.mk_string "obviously" name.anonymous),	F_map_comp' :	  auto_param (∀ {X Y Z : C} (f : X ⟶ Y) (g : Y ⟶ Z), F_map (f ≫ g) = F_map f ≫ F_map g)	    (name.mk_string "obviously" name.anonymous),	G_obj : C → D,	G_map : Π {X Y : C}, (X ⟶ Y) → (G_obj X ⟶ G_obj Y),	G_map_id' : auto_param (∀ (X : C), G_map (𝟙 X) = 𝟙 (G_obj X)) (name.mk_string "obviously" name.anonymous),	G_map_comp' :	  auto_param (∀ {X Y Z : C} (f : X ⟶ Y) (g : Y ⟶ Z), G_map (f ≫ g) = G_map f ≫ G_map g)	    (name.mk_string "obviously" name.anonymous),	h_obj :	  ∀ (X : C),	    {obj := F_obj, map := F_map, map_id' := F_map_id', map_comp' := F_map_comp'}.obj X =	      {obj := G_obj, map := G_map, map_id' := G_map_id', map_comp' := G_map_comp'}.obj X,	h_map :	  ∀ (X Y : C) (f : X ⟶ Y),	    {obj := F_obj, map := F_map, map_id' := F_map_id', map_comp' := F_map_comp'}.map f ==	      {obj := G_obj, map := G_map, map_id' := G_map_id', map_comp' := G_map_comp'}.map f,	X : C	⊢ F_obj X = G_obj X		C : Type u₁,	_inst_1 : category C,	D : Type u₂,	_inst_2 : category D,	F_obj : C → D,	F_map : Π {X Y : C}, (X ⟶ Y) → (F_obj X ⟶ F_obj Y),	F_map_id' : auto_param (∀ (X : C), F_map (𝟙 X) = 𝟙 (F_obj X)) (name.mk_string "obviously" name.anonymous),	F_map_comp' :	  auto_param (∀ {X Y Z : C} (f : X ⟶ Y) (g : Y ⟶ Z), F_map (f ≫ g) = F_map f ≫ F_map g)	    (name.mk_string "obviously" name.anonymous),	G_obj : C → D,	G_map : Π {X Y : C}, (X ⟶ Y) → (G_obj X ⟶ G_obj Y),	G_map_id' : auto_param (∀ (X : C), G_map (𝟙 X) = 𝟙 (G_obj X)) (name.mk_string "obviously" name.anonymous),	G_map_comp' :	  auto_param (∀ {X Y Z : C} (f : X ⟶ Y) (g : Y ⟶ Z), G_map (f ≫ g) = G_map f ≫ G_map g)	    (name.mk_string "obviously" name.anonymous),	h_obj :	  ∀ (X : C),	    {obj := F_obj, map := F_map, map_id' := F_map_id', map_comp' := F_map_comp'}.obj X =	      {obj := G_obj, map := G_map, map_id' := G_map_id', map_comp' := G_map_comp'}.obj X,	h_map :	  ∀ (X Y : C) (f : X ⟶ Y),	    {obj := F_obj, map := F_map, map_id' := F_map_id', map_comp' := F_map_comp'}.map f ==	      {obj := G_obj, map := G_map, map_id' := G_map_id', map_comp' := G_map_comp'}.map f,	this : F_obj = G_obj	⊢ {obj := F_obj, map := F_map, map_id' := F_map_id', map_comp' := F_map_comp'} =	    {obj := G_obj, map := G_map, map_id' := G_map_id', map_comp' := G_map_comp'}
C : Type u₁,	_inst_1 : category C,	D : Type u₂,	_inst_2 : category D,	F_obj : C → D,	F_map : Π {X Y : C}, (X ⟶ Y) → (F_obj X ⟶ F_obj Y),	F_map_id' : auto_param (∀ (X : C), F_map (𝟙 X) = 𝟙 (F_obj X)) (name.mk_string "obviously" name.anonymous),	F_map_comp' :	  auto_param (∀ {X Y Z : C} (f : X ⟶ Y) (g : Y ⟶ Z), F_map (f ≫ g) = F_map f ≫ F_map g)	    (name.mk_string "obviously" name.anonymous),	G_obj : C → D,	G_map : Π {X Y : C}, (X ⟶ Y) → (G_obj X ⟶ G_obj Y),	G_map_id' : auto_param (∀ (X : C), G_map (𝟙 X) = 𝟙 (G_obj X)) (name.mk_string "obviously" name.anonymous),	G_map_comp' :	  auto_param (∀ {X Y Z : C} (f : X ⟶ Y) (g : Y ⟶ Z), G_map (f ≫ g) = G_map f ≫ G_map g)	    (name.mk_string "obviously" name.anonymous),	h_obj :	  ∀ (X : C),	    {obj := F_obj, map := F_map, map_id' := F_map_id', map_comp' := F_map_comp'}.obj X =	      {obj := G_obj, map := G_map, map_id' := G_map_id', map_comp' := G_map_comp'}.obj X,	h_map :	  ∀ (X Y : C) (f : X ⟶ Y),	    {obj := F_obj, map := F_map, map_id' := F_map_id', map_comp' := F_map_comp'}.map f ==	      {obj := G_obj, map := G_map, map_id' := G_map_id', map_comp' := G_map_comp'}.map f,	this : F_obj = G_obj	⊢ {obj := F_obj, map := F_map, map_id' := F_map_id', map_comp' := F_map_comp'} =	    {obj := G_obj, map := G_map, map_id' := G_map_id', map_comp' := G_map_comp'}
C : Type u₁,	_inst_1 : category C,	D : Type u₂,	_inst_2 : category D,	F_obj : C → D,	F_map : Π {X Y : C}, (X ⟶ Y) → (F_obj X ⟶ F_obj Y),	F_map_id' : auto_param (∀ (X : C), F_map (𝟙 X) = 𝟙 (F_obj X)) (name.mk_string "obviously" name.anonymous),	F_map_comp' :	  auto_param (∀ {X Y Z : C} (f : X ⟶ Y) (g : Y ⟶ Z), F_map (f ≫ g) = F_map f ≫ F_map g)	    (name.mk_string "obviously" name.anonymous),	G_map : Π {X Y : C}, (X ⟶ Y) → (F_obj X ⟶ F_obj Y),	G_map_id' : auto_param (∀ (X : C), G_map (𝟙 X) = 𝟙 (F_obj X)) (name.mk_string "obviously" name.anonymous),	G_map_comp' :	  auto_param (∀ {X Y Z : C} (f : X ⟶ Y) (g : Y ⟶ Z), G_map (f ≫ g) = G_map f ≫ G_map g)	    (name.mk_string "obviously" name.anonymous),	h_obj :	  ∀ (X : C),	    {obj := F_obj, map := F_map, map_id' := F_map_id', map_comp' := F_map_comp'}.obj X =	      {obj := F_obj, map := G_map, map_id' := G_map_id', map_comp' := G_map_comp'}.obj X,	h_map :	  ∀ (X Y : C) (f : X ⟶ Y),	    {obj := F_obj, map := F_map, map_id' := F_map_id', map_comp' := F_map_comp'}.map f ==	      {obj := F_obj, map := G_map, map_id' := G_map_id', map_comp' := G_map_comp'}.map f	⊢ {obj := F_obj, map := F_map, map_id' := F_map_id', map_comp' := F_map_comp'} =	    {obj := F_obj, map := G_map, map_id' := G_map_id', map_comp' := G_map_comp'}
C : Type u₁,	_inst_1 : category C,	D : Type u₂,	_inst_2 : category D,	F_obj : C → D,	F_map : Π {X Y : C}, (X ⟶ Y) → (F_obj X ⟶ F_obj Y),	F_map_id' : auto_param (∀ (X : C), F_map (𝟙 X) = 𝟙 (F_obj X)) (name.mk_string "obviously" name.anonymous),	F_map_comp' :	  auto_param (∀ {X Y Z : C} (f : X ⟶ Y) (g : Y ⟶ Z), F_map (f ≫ g) = F_map f ≫ F_map g)	    (name.mk_string "obviously" name.anonymous),	G_map : Π {X Y : C}, (X ⟶ Y) → (F_obj X ⟶ F_obj Y),	G_map_id' : auto_param (∀ (X : C), G_map (𝟙 X) = 𝟙 (F_obj X)) (name.mk_string "obviously" name.anonymous),	G_map_comp' :	  auto_param (∀ {X Y Z : C} (f : X ⟶ Y) (g : Y ⟶ Z), G_map (f ≫ g) = G_map f ≫ G_map g)	    (name.mk_string "obviously" name.anonymous),	h_obj :	  ∀ (X : C),	    {obj := F_obj, map := F_map, map_id' := F_map_id', map_comp' := F_map_comp'}.obj X =	      {obj := F_obj, map := G_map, map_id' := G_map_id', map_comp' := G_map_comp'}.obj X,	h_map :	  ∀ (X Y : C) (f : X ⟶ Y),	    {obj := F_obj, map := F_map, map_id' := F_map_id', map_comp' := F_map_comp'}.map f ==	      {obj := F_obj, map := G_map, map_id' := G_map_id', map_comp' := G_map_comp'}.map f	⊢ F_map = G_map
C : Type u₁,	_inst_1 : category C,	D : Type u₂,	_inst_2 : category D,	F_obj : C → D,	F_map : Π {X Y : C}, (X ⟶ Y) → (F_obj X ⟶ F_obj Y),	F_map_id' : auto_param (∀ (X : C), F_map (𝟙 X) = 𝟙 (F_obj X)) (name.mk_string "obviously" name.anonymous),	F_map_comp' :	  auto_param (∀ {X Y Z : C} (f : X ⟶ Y) (g : Y ⟶ Z), F_map (f ≫ g) = F_map f ≫ F_map g)	    (name.mk_string "obviously" name.anonymous),	G_map : Π {X Y : C}, (X ⟶ Y) → (F_obj X ⟶ F_obj Y),	G_map_id' : auto_param (∀ (X : C), G_map (𝟙 X) = 𝟙 (F_obj X)) (name.mk_string "obviously" name.anonymous),	G_map_comp' :	  auto_param (∀ {X Y Z : C} (f : X ⟶ Y) (g : Y ⟶ Z), G_map (f ≫ g) = G_map f ≫ G_map g)	    (name.mk_string "obviously" name.anonymous),	h_obj :	  ∀ (X : C),	    {obj := F_obj, map := F_map, map_id' := F_map_id', map_comp' := F_map_comp'}.obj X =	      {obj := F_obj, map := G_map, map_id' := G_map_id', map_comp' := G_map_comp'}.obj X,	h_map :	  ∀ (X Y : C) (f : X ⟶ Y),	    {obj := F_obj, map := F_map, map_id' := F_map_id', map_comp' := F_map_comp'}.map f ==	      {obj := F_obj, map := G_map, map_id' := G_map_id', map_comp' := G_map_comp'}.map f,	X Y : C,	f : X ⟶ Y	⊢ F_map f = G_map f
⊢ ∀ {C : Type u₁} [_inst_1 : category C] {D : Type u₂} [_inst_2 : category D] (F : C ⥤ D) {X Y : C}	  (p : X = Y), F.map (eq_to_hom p) = eq_to_hom _
C : Type u₁,	_inst_1 : category C,	D : Type u₂,	_inst_2 : category D,	F : C ⥤ D,	X Y : C,	p : X = Y	⊢ F.map (eq_to_hom p) = eq_to_hom _
C : Type u₁,	_inst_1 : category C,	D : Type u₂,	_inst_2 : category D,	F : C ⥤ D,	X : C,	p : X = X	⊢ F.map (eq_to_hom p) = eq_to_hom _
⊢ ∀ {C : Type u₁} [_inst_1 : category C] {D : Type u₂} [_inst_2 : category D] (e : C ≌ D) {X Y : D}	  (f f' : X ⟶ Y), f ≫ e.counit_inv.app Y = f' ≫ e.counit_inv.app Y ↔ f = f'
C : Type u₁,	_inst_1 : category C,	D : Type u₂,	_inst_2 : category D,	e : C ≌ D,	X Y : D,	f f' : X ⟶ Y	⊢ f ≫ e.counit_inv.app Y = f' ≫ e.counit_inv.app Y ↔ f = f'
⊢ ∀ {C : Type u} [_inst_1 : category C] [_inst_2 : is_filtered C] {J : Type v} [_inst_3 : small_category J]	  [_inst_4 : fin_category J] (F : J ⥤ C), nonempty (cocone F)
C : Type u,	_inst_1 : category C,	_inst_2 : is_filtered C,	J : Type v,	_inst_3 : small_category J,	_inst_4 : fin_category J,	F : J ⥤ C	⊢ nonempty (cocone F)
C : Type u,	_inst_1 : category C,	_inst_2 : is_filtered C,	J : Type v,	_inst_3 : small_category J,	_inst_4 : fin_category J,	F : J ⥤ C,	_inst : Π (a : Prop), decidable a	⊢ nonempty (cocone F)
C : Type u,	_inst_1 : category C,	_inst_2 : is_filtered C,	J : Type v,	_inst_3 : small_category J,	_inst_4 : fin_category J,	F : J ⥤ C,	_inst : Π (a : Prop), decidable a,	O : finset C := finset.image F.obj finset.univ	⊢ nonempty (cocone F)
C : Type u,	_inst_1 : category C,	_inst_2 : is_filtered C,	J : Type v,	_inst_3 : small_category J,	_inst_4 : fin_category J,	F : J ⥤ C,	_inst : Π (a : Prop), decidable a,	O : finset C := finset.image F.obj finset.univ,	H : finset (Σ' (X Y : C) (mX : X ∈ O) (mY : Y ∈ O), X ⟶ Y) :=	  finset.univ.bUnion	    (λ (X : J),	       finset.univ.bUnion	         (λ (Y : J),	            finset.image (λ (f : X ⟶ Y), ⟨F.obj X, ⟨F.obj Y, ⟨_, ⟨_, F.map f⟩⟩⟩⟩) finset.univ))	⊢ nonempty (cocone F)
C : Type u,	_inst_1 : category C,	_inst_2 : is_filtered C,	J : Type v,	_inst_3 : small_category J,	_inst_4 : fin_category J,	F : J ⥤ C,	_inst : Π (a : Prop), decidable a,	O : finset C := finset.image F.obj finset.univ,	H : finset (Σ' (X Y : C) (mX : X ∈ O) (mY : Y ∈ O), X ⟶ Y) :=	  finset.univ.bUnion	    (λ (X : J),	       finset.univ.bUnion	         (λ (Y : J),	            finset.image (λ (f : X ⟶ Y), ⟨F.obj X, ⟨F.obj Y, ⟨_, ⟨_, F.map f⟩⟩⟩⟩) finset.univ)),	Z : C,	f : Π {X : C}, X ∈ O → (X ⟶ Z),	w :	  ∀ {X Y : C} (mX : X ∈ O) (mY : Y ∈ O) {f_1 : X ⟶ Y},	    ⟨X, ⟨Y, ⟨mX, ⟨mY, f_1⟩⟩⟩⟩ ∈ H → f_1 ≫ f mY = f mX	⊢ nonempty (cocone F)
C : Type u,	_inst_1 : category C,	_inst_2 : is_filtered C,	J : Type v,	_inst_3 : small_category J,	_inst_4 : fin_category J,	F : J ⥤ C,	_inst : Π (a : Prop), decidable a,	O : finset C := finset.image F.obj finset.univ,	H : finset (Σ' (X Y : C) (mX : X ∈ O) (mY : Y ∈ O), X ⟶ Y) :=	  finset.univ.bUnion	    (λ (X : J),	       finset.univ.bUnion	         (λ (Y : J),	            finset.image (λ (f : X ⟶ Y), ⟨F.obj X, ⟨F.obj Y, ⟨_, ⟨_, F.map f⟩⟩⟩⟩) finset.univ)),	Z : C,	f : Π {X : C}, X ∈ O → (X ⟶ Z),	w :	  ∀ {X Y : C} (mX : X ∈ O) (mY : Y ∈ O) {f_1 : X ⟶ Y},	    ⟨X, ⟨Y, ⟨mX, ⟨mY, f_1⟩⟩⟩⟩ ∈ H → f_1 ≫ f mY = f mX	⊢ auto_param (∀ ⦃X Y : J⦄ (f_1 : X ⟶ Y), F.map f_1 ≫ f _ = f _ ≫ ((functor.const J).obj Z).map f_1)	    (name.mk_string "obviously" name.anonymous)
C : Type u,	_inst_1 : category C,	_inst_2 : is_filtered C,	J : Type v,	_inst_3 : small_category J,	_inst_4 : fin_category J,	F : J ⥤ C,	_inst : Π (a : Prop), decidable a,	O : finset C := finset.image F.obj finset.univ,	H : finset (Σ' (X Y : C) (mX : X ∈ O) (mY : Y ∈ O), X ⟶ Y) :=	  finset.univ.bUnion	    (λ (X : J),	       finset.univ.bUnion	         (λ (Y : J),	            finset.image (λ (f : X ⟶ Y), ⟨F.obj X, ⟨F.obj Y, ⟨_, ⟨_, F.map f⟩⟩⟩⟩) finset.univ)),	Z : C,	f : Π {X : C}, X ∈ O → (X ⟶ Z),	w :	  ∀ {X Y : C} (mX : X ∈ O) (mY : Y ∈ O) {f_1 : X ⟶ Y},	    ⟨X, ⟨Y, ⟨mX, ⟨mY, f_1⟩⟩⟩⟩ ∈ H → f_1 ≫ f mY = f mX,	j j' : J,	g : j ⟶ j'	⊢ F.map g ≫ f _ = f _ ≫ ((functor.const J).obj Z).map g
C : Type u,	_inst_1 : category C,	_inst_2 : is_filtered C,	J : Type v,	_inst_3 : small_category J,	_inst_4 : fin_category J,	F : J ⥤ C,	_inst : Π (a : Prop), decidable a,	O : finset C := finset.image F.obj finset.univ,	H : finset (Σ' (X Y : C) (mX : X ∈ O) (mY : Y ∈ O), X ⟶ Y) :=	  finset.univ.bUnion	    (λ (X : J),	       finset.univ.bUnion	         (λ (Y : J),	            finset.image (λ (f : X ⟶ Y), ⟨F.obj X, ⟨F.obj Y, ⟨_, ⟨_, F.map f⟩⟩⟩⟩) finset.univ)),	Z : C,	f : Π {X : C}, X ∈ O → (X ⟶ Z),	w :	  ∀ {X Y : C} (mX : X ∈ O) (mY : Y ∈ O) {f_1 : X ⟶ Y},	    ⟨X, ⟨Y, ⟨mX, ⟨mY, f_1⟩⟩⟩⟩ ∈ H → f_1 ≫ f mY = f mX,	j j' : J,	g : j ⟶ j'	⊢ F.map g ≫ f _ = f _ ≫ 𝟙 Z
C : Type u,	_inst_1 : category C,	_inst_2 : is_filtered C,	J : Type v,	_inst_3 : small_category J,	_inst_4 : fin_category J,	F : J ⥤ C,	_inst : Π (a : Prop), decidable a,	O : finset C := finset.image F.obj finset.univ,	H : finset (Σ' (X Y : C) (mX : X ∈ O) (mY : Y ∈ O), X ⟶ Y) :=	  finset.univ.bUnion	    (λ (X : J),	       finset.univ.bUnion	         (λ (Y : J),	            finset.image (λ (f : X ⟶ Y), ⟨F.obj X, ⟨F.obj Y, ⟨_, ⟨_, F.map f⟩⟩⟩⟩) finset.univ)),	Z : C,	f : Π {X : C}, X ∈ O → (X ⟶ Z),	w :	  ∀ {X Y : C} (mX : X ∈ O) (mY : Y ∈ O) {f_1 : X ⟶ Y},	    ⟨X, ⟨Y, ⟨mX, ⟨mY, f_1⟩⟩⟩⟩ ∈ H → f_1 ≫ f mY = f mX,	j j' : J,	g : j ⟶ j'	⊢ F.map g ≫ f _ = f _
C : Type u,	_inst_1 : category C,	_inst_2 : is_filtered C,	J : Type v,	_inst_3 : small_category J,	_inst_4 : fin_category J,	F : J ⥤ C,	_inst : Π (a : Prop), decidable a,	O : finset C := finset.image F.obj finset.univ,	H : finset (Σ' (X Y : C) (mX : X ∈ O) (mY : Y ∈ O), X ⟶ Y) :=	  finset.univ.bUnion	    (λ (X : J),	       finset.univ.bUnion	         (λ (Y : J),	            finset.image (λ (f : X ⟶ Y), ⟨F.obj X, ⟨F.obj Y, ⟨_, ⟨_, F.map f⟩⟩⟩⟩) finset.univ)),	Z : C,	f : Π {X : C}, X ∈ O → (X ⟶ Z),	w :	  ∀ {X Y : C} (mX : X ∈ O) (mY : Y ∈ O) {f_1 : X ⟶ Y},	    ⟨X, ⟨Y, ⟨mX, ⟨mY, f_1⟩⟩⟩⟩ ∈ H → f_1 ≫ f mY = f mX,	j j' : J,	g : j ⟶ j'	⊢ ⟨F.obj j, ⟨F.obj j', ⟨_, ⟨_, F.map g⟩⟩⟩⟩ ∈ H
C : Type u,	_inst_1 : category C,	_inst_2 : is_filtered C,	J : Type v,	_inst_3 : small_category J,	_inst_4 : fin_category J,	F : J ⥤ C,	_inst : Π (a : Prop), decidable a,	O : finset C := finset.image F.obj finset.univ,	H : finset (Σ' (X Y : C) (mX : X ∈ O) (mY : Y ∈ O), X ⟶ Y) :=	  finset.univ.bUnion	    (λ (X : J),	       finset.univ.bUnion	         (λ (Y : J),	            finset.image (λ (f : X ⟶ Y), ⟨F.obj X, ⟨F.obj Y, ⟨_, ⟨_, F.map f⟩⟩⟩⟩) finset.univ)),	Z : C,	f : Π {X : C}, X ∈ O → (X ⟶ Z),	w :	  ∀ {X Y : C} (mX : X ∈ O) (mY : Y ∈ O) {f_1 : X ⟶ Y},	    ⟨X, ⟨Y, ⟨mX, ⟨mY, f_1⟩⟩⟩⟩ ∈ H → f_1 ≫ f mY = f mX,	j j' : J,	g : j ⟶ j'	⊢ ∃ (a : J),	    F.obj a = F.obj j ∧	      ∃ (x : J) (x_1 : a ⟶ x),	        ⟨F.obj x, ⟨_, ⟨_, F.map x_1⟩⟩⟩ == ⟨F.obj j', ⟨_, ⟨_, F.map g⟩⟩⟩
⊢ ∀ {C : Type u_1} [_inst_1 : category C] {F : C ⥤ Cat} {X Y : grothendieck F} {f g : X ⟶ Y} (h : f = g),	    f.fiber = eq_to_hom _ ≫ g.fiber
C : Type u_1,	_inst_1 : category C,	F : C ⥤ Cat,	X Y : grothendieck F,	f g : X ⟶ Y,	h : f = g	⊢ f.fiber = eq_to_hom _ ≫ g.fiber
C : Type u_1,	_inst_1 : category C,	F : C ⥤ Cat,	X Y : grothendieck F,	f : X ⟶ Y	⊢ f.fiber = eq_to_hom _ ≫ f.fiber
C : Type u_1,	_inst_1 : category C,	F : C ⥤ Cat,	X Y : grothendieck F,	f : X ⟶ Y	⊢ f.fiber = 𝟙 ((F.map f.base).obj X.fiber) ≫ f.fiber
⊢ ∀ {J : Type u₁} [_inst_1 : category J] [_inst_3 : is_connected J] (r : J → J → Prop),	    equivalence r → (∀ {j₁ j₂ : J}, (j₁ ⟶ j₂) → r j₁ j₂) → ∀ (j₁ j₂ : J), r j₁ j₂
J : Type u₁,	_inst_1 : category J,	_inst_3 : is_connected J,	r : J → J → Prop,	hr : equivalence r,	h : ∀ {j₁ j₂ : J}, (j₁ ⟶ j₂) → r j₁ j₂,	j₁ j₂ : J	⊢ r j₁ j₂
J : Type u₁,	_inst_1 : category J,	_inst_3 : is_connected J,	r : J → J → Prop,	hr : equivalence r,	h : ∀ {j₁ j₂ : J}, (j₁ ⟶ j₂) → r j₁ j₂,	j₁ j₂ : J,	z : ∀ (j : J), r (classical.arbitrary J) j	⊢ r j₁ j₂
⊢ ∀ {J K : Type v} [_inst_1 : small_category J] [_inst_2 : small_category K] {C : Type u} [_inst_3 : category C]	  (F : J ⥤ K ⥤ C) [_inst_4 : limits.has_limits_of_shape K C] [_inst_5 : limits.has_limit (uncurry.obj F)]	  [_inst_6 : limits.has_limit (F ⋙ limits.lim)] {j : J} {k : K},	    (limits.limit_uncurry_iso_limit_comp_lim F).hom ≫	        limits.limit.π (F ⋙ limits.lim) j ≫ limits.limit.π (F.obj j) k =	      limits.limit.π (uncurry.obj F) (j, k)
J K : Type v,	_inst_1 : small_category J,	_inst_2 : small_category K,	C : Type u,	_inst_3 : category C,	F : J ⥤ K ⥤ C,	_inst_4 : limits.has_limits_of_shape K C,	_inst_5 : limits.has_limit (uncurry.obj F),	_inst_6 : limits.has_limit (F ⋙ limits.lim),	j : J,	k : K	⊢ (limits.limit_uncurry_iso_limit_comp_lim F).hom ≫	      limits.limit.π (F ⋙ limits.lim) j ≫ limits.limit.π (F.obj j) k =	    limits.limit.π (uncurry.obj F) (j, k)
J K : Type v,	_inst_1 : small_category J,	_inst_2 : small_category K,	C : Type u,	_inst_3 : category C,	F : J ⥤ K ⥤ C,	_inst_4 : limits.has_limits_of_shape K C,	_inst_5 : limits.has_limit (uncurry.obj F),	_inst_6 : limits.has_limit (F ⋙ limits.lim),	j : J,	k : K	⊢ limits.limit.lift (F ⋙ limits.lim)	        (limits.cone_of_cone_uncurry (λ (j : J), limits.limit.is_limit (F.obj j))	           (limits.limit.cone (uncurry.obj F))) ≫	      limits.limit.π (F ⋙ limits.lim) j ≫ limits.limit.π (F.obj j) k =	    limits.limit.π (uncurry.obj F) (j, k)
⊢ ∀ {J : Type u₁} [_inst_1 : category J] {K : Type u₂} [_inst_2 : category K] {C : Type u}	  [_inst_3 : category C] (F : J ⥤ C) [_inst_4 : limits.has_limit F] (E : K ⥤ J)	  [_inst_5 : limits.has_limit (E ⋙ F)] (k : K),	    limits.limit.pre F E ≫ limits.limit.π (E ⋙ F) k = limits.limit.π F (E.obj k)
J : Type u₁,	_inst_1 : category J,	K : Type u₂,	_inst_2 : category K,	C : Type u,	_inst_3 : category C,	F : J ⥤ C,	_inst_4 : limits.has_limit F,	E : K ⥤ J,	_inst_5 : limits.has_limit (E ⋙ F),	k : K	⊢ limits.limit.pre F E ≫ limits.limit.π (E ⋙ F) k = limits.limit.π F (E.obj k)
J : Type u₁,	_inst_1 : category J,	K : Type u₂,	_inst_2 : category K,	C : Type u,	_inst_3 : category C,	F : J ⥤ C,	_inst_4 : limits.has_limit F,	E : K ⥤ J,	_inst_5 : limits.has_limit (E ⋙ F),	k : K	⊢ (limits.cone.whisker E (limits.limit.cone F)).π.app k = limits.limit.π F (E.obj k)
⊢ ∀ {J : Type u₁} [_inst_1 : category J] {C : Type u} [_inst_3 : category C] {J' : Type u₂}	  [_inst_4 : category J'],	    (J ≌ J') → ∀ [_inst_5 : limits.has_limits_of_shape J C], limits.has_limits_of_shape J' C
J : Type u₁,	_inst_1 : category J,	C : Type u,	_inst_3 : category C,	J' : Type u₂,	_inst_4 : category J',	e : J ≌ J',	_inst_5 : limits.has_limits_of_shape J C	⊢ limits.has_limits_of_shape J' C
J : Type u₁,	_inst_1 : category J,	C : Type u,	_inst_3 : category C,	J' : Type u₂,	_inst_4 : category J',	e : J ≌ J',	_inst_5 : limits.has_limits_of_shape J C	⊢ auto_param (∀ (F : J' ⥤ C), limits.has_limit F)	    (name.mk_string "apply_instance" (name.mk_string "tactic" name.anonymous))
J : Type u₁,	_inst_1 : category J,	C : Type u,	_inst_3 : category C,	J' : Type u₂,	_inst_4 : category J',	e : J ≌ J',	_inst_5 : limits.has_limits_of_shape J C,	F : J' ⥤ C	⊢ limits.has_limit F
J : Type u₁,	_inst_1 : category J,	C : Type u,	_inst_3 : category C,	J' : Type u₂,	_inst_4 : category J',	e : J ≌ J',	_inst_5 : limits.has_limits_of_shape J C,	F : J' ⥤ C	⊢ limits.has_limit (e.functor ⋙ F)
⊢ ∀ {J : Type u₁} [_inst_1 : category J] {C : Type u} [_inst_3 : category C] {F : J ⥤ C}	  [_inst_4 : limits.has_colimit F] (t : limits.colimit_cocone F) (j : J),	    t.cocone.ι.app j ≫ (limits.colimit.iso_colimit_cocone t).inv = limits.colimit.ι F j
J : Type u₁,	_inst_1 : category J,	C : Type u,	_inst_3 : category C,	F : J ⥤ C,	_inst_4 : limits.has_colimit F,	t : limits.colimit_cocone F,	j : J	⊢ t.cocone.ι.app j ≫ (limits.colimit.iso_colimit_cocone t).inv = limits.colimit.ι F j
J : Type u₁,	_inst_1 : category J,	C : Type u,	_inst_3 : category C,	F : J ⥤ C,	_inst_4 : limits.has_colimit F,	t : limits.colimit_cocone F,	j : J	⊢ t.cocone.ι.app j ≫ t.is_colimit.desc (limits.colimit.cocone F) = limits.colimit.ι F j
⊢ ∀ {C : Type u₁} [_inst_1 : category C] {D : Type u₂} [_inst_2 : category D] (G : C ⥤ D) {J : Type w}	  [_inst_3 : category J] (F : J ⥤ C) [_inst_4 : preserves_limit F G] [_inst_5 : has_limit F]	  [_inst_6 : has_limit (F ⋙ G)] (t : cone F),	    G.map (limit.lift F t) ≫ (preserves_limit_iso G F).hom = limit.lift (F ⋙ G) (G.map_cone t)
C : Type u₁,	_inst_1 : category C,	D : Type u₂,	_inst_2 : category D,	G : C ⥤ D,	J : Type w,	_inst_3 : category J,	F : J ⥤ C,	_inst_4 : preserves_limit F G,	_inst_5 : has_limit F,	_inst_6 : has_limit (F ⋙ G),	t : cone F	⊢ G.map (limit.lift F t) ≫ (preserves_limit_iso G F).hom = limit.lift (F ⋙ G) (G.map_cone t)
C : Type u₁,	_inst_1 : category C,	D : Type u₂,	_inst_2 : category D,	G : C ⥤ D,	J : Type w,	_inst_3 : category J,	F : J ⥤ C,	_inst_4 : preserves_limit F G,	_inst_5 : has_limit F,	_inst_6 : has_limit (F ⋙ G),	t : cone F,	j : J	⊢ (G.map (limit.lift F t) ≫ (preserves_limit_iso G F).hom) ≫ limit.π (F ⋙ G) j =	    limit.lift (F ⋙ G) (G.map_cone t) ≫ limit.π (F ⋙ G) j
⊢ ∀ {C : Type u} [_inst_1 : category C] {X Y : C} [_inst_2 : limits.has_binary_product X Y]	  [_inst_3 : limits.has_binary_product (X ⨯ Y) (X ⨯ Y)],	    limits.diag (X ⨯ Y) ≫ limits.prod.map limits.prod.fst limits.prod.snd = 𝟙 (X ⨯ Y)
C : Type u,	_inst_1 : category C,	X Y : C,	_inst_2 : limits.has_binary_product X Y,	_inst_3 : limits.has_binary_product (X ⨯ Y) (X ⨯ Y)	⊢ limits.diag (X ⨯ Y) ≫ limits.prod.map limits.prod.fst limits.prod.snd = 𝟙 (X ⨯ Y)
⊢ ∀ {C : Type u} [_inst_1 : category C] {S T U V W : C} [_inst_2 : limits.has_binary_coproduct U W]	  [_inst_3 : limits.has_binary_coproduct T V] (f : U ⟶ S) (g : W ⟶ S) (h : T ⟶ U) (k : V ⟶ W),	    limits.coprod.map h k ≫ limits.coprod.desc f g = limits.coprod.desc (h ≫ f) (k ≫ g)
C : Type u,	_inst_1 : category C,	S T U V W : C,	_inst_2 : limits.has_binary_coproduct U W,	_inst_3 : limits.has_binary_coproduct T V,	f : U ⟶ S,	g : W ⟶ S,	h : T ⟶ U,	k : V ⟶ W	⊢ limits.coprod.map h k ≫ limits.coprod.desc f g = limits.coprod.desc (h ≫ f) (k ≫ g)
2 goals	C : Type u,	_inst_1 : category C,	S T U V W : C,	_inst_2 : limits.has_binary_coproduct U W,	_inst_3 : limits.has_binary_coproduct T V,	f : U ⟶ S,	g : W ⟶ S,	h : T ⟶ U,	k : V ⟶ W	⊢ limits.coprod.inl ≫ limits.coprod.map h k ≫ limits.coprod.desc f g =	    limits.coprod.inl ≫ limits.coprod.desc (h ≫ f) (k ≫ g)		C : Type u,	_inst_1 : category C,	S T U V W : C,	_inst_2 : limits.has_binary_coproduct U W,	_inst_3 : limits.has_binary_coproduct T V,	f : U ⟶ S,	g : W ⟶ S,	h : T ⟶ U,	k : V ⟶ W	⊢ limits.coprod.inr ≫ limits.coprod.map h k ≫ limits.coprod.desc f g =	    limits.coprod.inr ≫ limits.coprod.desc (h ≫ f) (k ≫ g)
C : Type u,	_inst_1 : category C,	S T U V W : C,	_inst_2 : limits.has_binary_coproduct U W,	_inst_3 : limits.has_binary_coproduct T V,	f : U ⟶ S,	g : W ⟶ S,	h : T ⟶ U,	k : V ⟶ W	⊢ limits.coprod.inr ≫ limits.coprod.map h k ≫ limits.coprod.desc f g =	    limits.coprod.inr ≫ limits.coprod.desc (h ≫ f) (k ≫ g)
⊢ ∀ {C : Type u} [_inst_1 : category C] [_inst_2 : limits.has_binary_coproducts C]	  {X₁ X₂ X₃ Y₁ Y₂ Y₃ : C} (f₁ : X₁ ⟶ Y₁) (f₂ : X₂ ⟶ Y₂) (f₃ : X₃ ⟶ Y₃),	    limits.coprod.map (limits.coprod.map f₁ f₂) f₃ ≫ (limits.coprod.associator Y₁ Y₂ Y₃).hom =	      (limits.coprod.associator X₁ X₂ X₃).hom ≫ limits.coprod.map f₁ (limits.coprod.map f₂ f₃)
C : Type u,	_inst_1 : category C,	_inst_2 : limits.has_binary_coproducts C,	X₁ X₂ X₃ Y₁ Y₂ Y₃ : C,	f₁ : X₁ ⟶ Y₁,	f₂ : X₂ ⟶ Y₂,	f₃ : X₃ ⟶ Y₃	⊢ limits.coprod.map (limits.coprod.map f₁ f₂) f₃ ≫ (limits.coprod.associator Y₁ Y₂ Y₃).hom =	    (limits.coprod.associator X₁ X₂ X₃).hom ≫ limits.coprod.map f₁ (limits.coprod.map f₂ f₃)
⊢ ∀ {C : Type u} [_inst_1 : category C] [_inst_2 : preadditive C] {J : Type v} [_inst_3 : decidable_eq J]	  [_inst_4 : fintype J] {K : Type v} [_inst_6 : fintype K] [_inst_7 : decidable_eq K]	  [_inst_8 : limits.has_finite_biproducts C] {f : J → C} {g h : K → C} (m : Π (j : J) (k : K), f j ⟶ g k)	  (n : Π (k : K), g k ⟶ h k),	    limits.biproduct.matrix m ≫ limits.biproduct.map n = limits.biproduct.matrix (λ (j : J) (k : K), m j k ≫ n k)
C : Type u,	_inst_1 : category C,	_inst_2 : preadditive C,	J : Type v,	_inst_3 : decidable_eq J,	_inst_4 : fintype J,	K : Type v,	_inst_6 : fintype K,	_inst_7 : decidable_eq K,	_inst_8 : limits.has_finite_biproducts C,	f : J → C,	g h : K → C,	m : Π (j : J) (k : K), f j ⟶ g k,	n : Π (k : K), g k ⟶ h k	⊢ limits.biproduct.matrix m ≫ limits.biproduct.map n = limits.biproduct.matrix (λ (j : J) (k : K), m j k ≫ n k)
C : Type u,	_inst_1 : category C,	_inst_2 : preadditive C,	J : Type v,	_inst_3 : decidable_eq J,	_inst_4 : fintype J,	K : Type v,	_inst_6 : fintype K,	_inst_7 : decidable_eq K,	_inst_8 : limits.has_finite_biproducts C,	f : J → C,	g h : K → C,	m : Π (j : J) (k : K), f j ⟶ g k,	n : Π (k : K), g k ⟶ h k,	j : J,	j_1 : K	⊢ (limits.biproduct.ι (λ (j : J), f j) j ≫ limits.biproduct.matrix m ≫ limits.biproduct.map n) ≫	      limits.biproduct.π (λ (k : K), h k) j_1 =	    (limits.biproduct.ι (λ (j : J), f j) j ≫ limits.biproduct.matrix (λ (j : J) (k : K), m j k ≫ n k)) ≫	      limits.biproduct.π (λ (k : K), h k) j_1
⊢ ∀ {C : Type u} [_inst_1 : category C] {X Y : C} {f g : X ⟶ Y} (t : limits.fork f g), t.ι ≫ f = t.ι ≫ g
C : Type u,	_inst_1 : category C,	X Y : C,	f g : X ⟶ Y,	t : limits.fork f g	⊢ t.ι ≫ f = t.ι ≫ g
⊢ ∀ {C : Type u} [_inst_1 : category C] {X Y : C} (f g : X ⟶ Y) {D : Type u₂} [_inst_2 : category D]	  (G : C ⥤ D) [_inst_3 : limits.has_coequalizer f g] [_inst_4 : limits.has_coequalizer (G.map f) (G.map g)] {Z : C}	  {h : Y ⟶ Z} (w : f ≫ h = g ≫ h),	    limits.coequalizer_comparison f g G ≫ G.map (limits.coequalizer.desc h w) = limits.coequalizer.desc (G.map h) _
C : Type u,	_inst_1 : category C,	X Y : C,	f g : X ⟶ Y,	D : Type u₂,	_inst_2 : category D,	G : C ⥤ D,	_inst_3 : limits.has_coequalizer f g,	_inst_4 : limits.has_coequalizer (G.map f) (G.map g),	Z : C,	h : Y ⟶ Z,	w : f ≫ h = g ≫ h	⊢ limits.coequalizer_comparison f g G ≫ G.map (limits.coequalizer.desc h w) = limits.coequalizer.desc (G.map h) _
C : Type u,	_inst_1 : category C,	X Y : C,	f g : X ⟶ Y,	D : Type u₂,	_inst_2 : category D,	G : C ⥤ D,	_inst_3 : limits.has_coequalizer f g,	_inst_4 : limits.has_coequalizer (G.map f) (G.map g),	Z : C,	h : Y ⟶ Z,	w : f ≫ h = g ≫ h	⊢ limits.coequalizer.π (G.map f) (G.map g) ≫	      limits.coequalizer_comparison f g G ≫ G.map (limits.coequalizer.desc h w) =	    limits.coequalizer.π (G.map f) (G.map g) ≫ limits.coequalizer.desc (G.map h) _
⊢ ∀ {C : Type u} [_inst_1 : category C] {X Y : C} (f : X ⟶ Y) {Z : C} (g : Y ⟶ Z)	  [_inst_2 : limits.has_equalizers C] [_inst_3 : limits.has_image f] [_inst_4 : is_iso g],	    (limits.image.comp_iso f g).inv ≫ limits.image.ι f = limits.image.ι (f ≫ g) ≫ inv g
C : Type u,	_inst_1 : category C,	X Y : C,	f : X ⟶ Y,	Z : C,	g : Y ⟶ Z,	_inst_2 : limits.has_equalizers C,	_inst_3 : limits.has_image f,	_inst_4 : is_iso g	⊢ (limits.image.comp_iso f g).inv ≫ limits.image.ι f = limits.image.ι (f ≫ g) ≫ inv g
C : Type u,	_inst_1 : category C,	X Y : C,	f : X ⟶ Y,	Z : C,	g : Y ⟶ Z,	_inst_2 : limits.has_equalizers C,	_inst_3 : limits.has_image f,	_inst_4 : is_iso g	⊢ limits.factor_thru_image (f ≫ g) ≫ (limits.image.comp_iso f g).inv ≫ limits.image.ι f =	    limits.factor_thru_image (f ≫ g) ≫ limits.image.ι (f ≫ g) ≫ inv g
⊢ ∀ {C : Type u} [_inst_1 : category C] [_inst_2 : limits.has_zero_morphisms C] {X Y : C} {f : X ⟶ Y}	  (s : limits.kernel_fork f), s.π.app one = 0
C : Type u,	_inst_1 : category C,	_inst_2 : limits.has_zero_morphisms C,	X Y : C,	f : X ⟶ Y,	s : limits.kernel_fork f	⊢ s.π.app one = 0
⊢ ∀ {J : Type v} {C : Type u} [_inst_1 : category C] {B : C} {objs : J → C} (arrows : Π (j : J), B ⟶ objs j)	  [_inst_2 : has_wide_pushout B objs arrows] (j : J), arrows j ≫ wide_pushout.ι arrows j = wide_pushout.head arrows
J : Type v,	C : Type u,	_inst_1 : category C,	B : C,	objs : J → C,	arrows : Π (j : J), B ⟶ objs j,	_inst_2 : has_wide_pushout B objs arrows,	j : J	⊢ arrows j ≫ wide_pushout.ι arrows j = wide_pushout.head arrows
⊢ ∀ {J : Type v} {C : Type u} [_inst_1 : category C] {B : C} {objs : J → C} (arrows : Π (j : J), B ⟶ objs j)	  [_inst_2 : has_wide_pushout B objs arrows] {X : C} (f : B ⟶ X) (fs : Π (j : J), objs j ⟶ X)	  (w : ∀ (j : J), arrows j ≫ fs j = f), wide_pushout.head arrows ≫ wide_pushout.desc f fs w = f
J : Type v,	C : Type u,	_inst_1 : category C,	B : C,	objs : J → C,	arrows : Π (j : J), B ⟶ objs j,	_inst_2 : has_wide_pushout B objs arrows,	X : C,	f : B ⟶ X,	fs : Π (j : J), objs j ⟶ X,	w : ∀ (j : J), arrows j ≫ fs j = f	⊢ wide_pushout.head arrows ≫ wide_pushout.desc f fs w = f
J : Type v,	C : Type u,	_inst_1 : category C,	B : C,	objs : J → C,	arrows : Π (j : J), B ⟶ objs j,	_inst_2 : has_wide_pushout B objs arrows,	X : C,	f : B ⟶ X,	fs : Π (j : J), objs j ⟶ X,	w : ∀ (j : J), arrows j ≫ fs j = f	⊢ (wide_pushout_shape.mk_cocone f fs w).ι.app none = f
⊢ ∀ {J : Type u} [_inst_1 : small_category J] {F : J ⥤ Type u} {j j' : J} {x : F.obj j} {x' : F.obj j'}	  (f : j ⟶ j'), F.map f x = x' → colimit.ι F j x = colimit.ι F j' x'
J : Type u,	_inst_1 : small_category J,	F : J ⥤ Type u,	j j' : J,	x : F.obj j,	x' : F.obj j',	f : j ⟶ j',	w : F.map f x = x'	⊢ colimit.ι F j x = colimit.ι F j' x'
J : Type u,	_inst_1 : small_category J,	F : J ⥤ Type u,	j j' : J,	x : F.obj j,	x' : F.obj j',	f : j ⟶ j',	w : F.map f x = x'	⊢ colimit.ι F j x = colimit.ι F j' (F.map f x)
⊢ ∀ {J : Type u} [_inst_1 : small_category J] {F : J ⥤ Type u} {c : cone F} (t : is_limit c) (x : ↥(F.sections))	  (j : J), c.π.app j (⇑((types.is_limit_equiv_sections t).symm) x) = ↑x j
J : Type u,	_inst_1 : small_category J,	F : J ⥤ Type u,	c : cone F,	t : is_limit c,	x : ↥(F.sections),	j : J	⊢ c.π.app j (⇑((types.is_limit_equiv_sections t).symm) x) = ↑x j
J : Type u,	_inst_1 : small_category J,	F : J ⥤ Type u,	c : cone F,	t : is_limit c,	j : J,	x : c.X	⊢ c.π.app j x = ↑(⇑(types.is_limit_equiv_sections t) x) j
⊢ ∀ {C : Type u} [_inst_1 : category C] [_inst_2 : monoidal_category C] (X Y : C),	    (α_ X (𝟙_ C) Y).inv ≫ ((ρ_ X).hom ⊗ 𝟙 Y) = 𝟙 X ⊗ (λ_ Y).hom
C : Type u,	_inst_1 : category C,	_inst_2 : monoidal_category C,	X Y : C	⊢ (α_ X (𝟙_ C) Y).inv ≫ ((ρ_ X).hom ⊗ 𝟙 Y) = 𝟙 X ⊗ (λ_ Y).hom
⊢ ∀ {C : Type u₁} [_inst_1 : category C] [_inst_2 : monoidal_category C] {D : Type u₂} [_inst_3 : category D]	  [_inst_4 : monoidal_category D] (F : lax_monoidal_functor C D) (X : C),	    (λ_ (F.to_functor.obj X)).inv ≫ (F.ε ⊗ 𝟙 (F.to_functor.obj X)) ≫ F.μ (𝟙_ C) X =	      F.to_functor.map (λ_ X).inv
C : Type u₁,	_inst_1 : category C,	_inst_2 : monoidal_category C,	D : Type u₂,	_inst_3 : category D,	_inst_4 : monoidal_category D,	F : lax_monoidal_functor C D,	X : C	⊢ (λ_ (F.to_functor.obj X)).inv ≫ (F.ε ⊗ 𝟙 (F.to_functor.obj X)) ≫ F.μ (𝟙_ C) X =	    F.to_functor.map (λ_ X).inv
⊢ ∀ {C : Type u} [_inst_1 : category C] (𝒯 : limit_cone (functor.empty C))	  (ℬ : Π (X Y : C), limit_cone (pair X Y)) {X₁ X₂ : C} (f : X₁ ⟶ X₂),	    monoidal_of_chosen_finite_products.tensor_hom ℬ f (𝟙 𝒯.cone.X) ≫	        (binary_fan.right_unitor 𝒯.is_limit (ℬ X₂ 𝒯.cone.X).is_limit).hom =	      (binary_fan.right_unitor 𝒯.is_limit (ℬ X₁ 𝒯.cone.X).is_limit).hom ≫ f
C : Type u,	_inst_1 : category C,	𝒯 : limit_cone (functor.empty C),	ℬ : Π (X Y : C), limit_cone (pair X Y),	X₁ X₂ : C,	f : X₁ ⟶ X₂	⊢ monoidal_of_chosen_finite_products.tensor_hom ℬ f (𝟙 𝒯.cone.X) ≫	      (binary_fan.right_unitor 𝒯.is_limit (ℬ X₂ 𝒯.cone.X).is_limit).hom =	    (binary_fan.right_unitor 𝒯.is_limit (ℬ X₁ 𝒯.cone.X).is_limit).hom ≫ f
C : Type u,	_inst_1 : category C,	𝒯 : limit_cone (functor.empty C),	ℬ : Π (X Y : C), limit_cone (pair X Y),	X₁ X₂ : C,	f : X₁ ⟶ X₂	⊢ (ℬ X₂ 𝒯.cone.X).is_limit.lift	        (binary_fan.mk (binary_fan.fst (ℬ X₁ 𝒯.cone.X).cone ≫ f)	           (binary_fan.snd (ℬ X₁ 𝒯.cone.X).cone ≫ 𝟙 𝒯.cone.X)) ≫	      binary_fan.fst (ℬ X₂ 𝒯.cone.X).cone =	    binary_fan.fst (ℬ X₁ 𝒯.cone.X).cone ≫ f
⊢ ∀ {C : Type u₁} [_inst_1 : category C] [_inst_2 : monoidal_category C] {X : C} [_inst_3 : has_left_dual X],	    ᘁ(𝟙 X) = 𝟙 ᘁX
C : Type u₁,	_inst_1 : category C,	_inst_2 : monoidal_category C,	X : C,	_inst_3 : has_left_dual X	⊢ ᘁ(𝟙 X) = 𝟙 ᘁX
⊢ ∀ {C : Type u₁} [_inst_1 : category C] {D : Type u₂} [_inst_2 : category D] {F G : C ⥤ D}	  (app' : Π (X : C), F.obj X ≅ G.obj X)	  (naturality : ∀ {X Y : C} (f : X ⟶ Y), F.map f ≫ (app' Y).hom = (app' X).hom ≫ G.map f) (X : C),	    (nat_iso.of_components app' naturality).app X = app' X
C : Type u₁,	_inst_1 : category C,	D : Type u₂,	_inst_2 : category D,	F G : C ⥤ D,	app' : Π (X : C), F.obj X ≅ G.obj X,	naturality : ∀ {X Y : C} (f : X ⟶ Y), F.map f ≫ (app' Y).hom = (app' X).hom ≫ G.map f,	X : C	⊢ (nat_iso.of_components app' naturality).app X = app' X
⊢ ∀ {C : Type u} [_inst_1 : category C] [_inst_2 : preadditive C] [_inst_3 : has_binary_biproducts C]	  {X₁ X₂ Y₁ Y₂ : C} (f : X₁ ⊞ X₂ ⟶ Y₁ ⊞ Y₂),	    biprod.of_components (biprod.inl ≫ f ≫ biprod.fst) (biprod.inl ≫ f ≫ biprod.snd)	        (biprod.inr ≫ f ≫ biprod.fst)	        (biprod.inr ≫ f ≫ biprod.snd) =	      f
C : Type u,	_inst_1 : category C,	_inst_2 : preadditive C,	_inst_3 : has_binary_biproducts C,	X₁ X₂ Y₁ Y₂ : C,	f : X₁ ⊞ X₂ ⟶ Y₁ ⊞ Y₂	⊢ biprod.of_components (biprod.inl ≫ f ≫ biprod.fst) (biprod.inl ≫ f ≫ biprod.snd)	      (biprod.inr ≫ f ≫ biprod.fst)	      (biprod.inr ≫ f ≫ biprod.snd) =	    f
4 goals	C : Type u,	_inst_1 : category C,	_inst_2 : preadditive C,	_inst_3 : has_binary_biproducts C,	X₁ X₂ Y₁ Y₂ : C,	f : X₁ ⊞ X₂ ⟶ Y₁ ⊞ Y₂	⊢ (biprod.inl ≫	         biprod.of_components (biprod.inl ≫ f ≫ biprod.fst) (biprod.inl ≫ f ≫ biprod.snd)	           (biprod.inr ≫ f ≫ biprod.fst)	           (biprod.inr ≫ f ≫ biprod.snd)) ≫	      biprod.fst =	    (biprod.inl ≫ f) ≫ biprod.fst		C : Type u,	_inst_1 : category C,	_inst_2 : preadditive C,	_inst_3 : has_binary_biproducts C,	X₁ X₂ Y₁ Y₂ : C,	f : X₁ ⊞ X₂ ⟶ Y₁ ⊞ Y₂	⊢ (biprod.inl ≫	         biprod.of_components (biprod.inl ≫ f ≫ biprod.fst) (biprod.inl ≫ f ≫ biprod.snd)	           (biprod.inr ≫ f ≫ biprod.fst)	           (biprod.inr ≫ f ≫ biprod.snd)) ≫	      biprod.snd =	    (biprod.inl ≫ f) ≫ biprod.snd		C : Type u,	_inst_1 : category C,	_inst_2 : preadditive C,	_inst_3 : has_binary_biproducts C,	X₁ X₂ Y₁ Y₂ : C,	f : X₁ ⊞ X₂ ⟶ Y₁ ⊞ Y₂	⊢ (biprod.inr ≫	         biprod.of_components (biprod.inl ≫ f ≫ biprod.fst) (biprod.inl ≫ f ≫ biprod.snd)	           (biprod.inr ≫ f ≫ biprod.fst)	           (biprod.inr ≫ f ≫ biprod.snd)) ≫	      biprod.fst =	    (biprod.inr ≫ f) ≫ biprod.fst		C : Type u,	_inst_1 : category C,	_inst_2 : preadditive C,	_inst_3 : has_binary_biproducts C,	X₁ X₂ Y₁ Y₂ : C,	f : X₁ ⊞ X₂ ⟶ Y₁ ⊞ Y₂	⊢ (biprod.inr ≫	         biprod.of_components (biprod.inl ≫ f ≫ biprod.fst) (biprod.inl ≫ f ≫ biprod.snd)	           (biprod.inr ≫ f ≫ biprod.fst)	           (biprod.inr ≫ f ≫ biprod.snd)) ≫	      biprod.snd =	    (biprod.inr ≫ f) ≫ biprod.snd
3 goals	C : Type u,	_inst_1 : category C,	_inst_2 : preadditive C,	_inst_3 : has_binary_biproducts C,	X₁ X₂ Y₁ Y₂ : C,	f : X₁ ⊞ X₂ ⟶ Y₁ ⊞ Y₂	⊢ (biprod.inl ≫	         biprod.of_components (biprod.inl ≫ f ≫ biprod.fst) (biprod.inl ≫ f ≫ biprod.snd)	           (biprod.inr ≫ f ≫ biprod.fst)	           (biprod.inr ≫ f ≫ biprod.snd)) ≫	      biprod.snd =	    (biprod.inl ≫ f) ≫ biprod.snd		C : Type u,	_inst_1 : category C,	_inst_2 : preadditive C,	_inst_3 : has_binary_biproducts C,	X₁ X₂ Y₁ Y₂ : C,	f : X₁ ⊞ X₂ ⟶ Y₁ ⊞ Y₂	⊢ (biprod.inr ≫	         biprod.of_components (biprod.inl ≫ f ≫ biprod.fst) (biprod.inl ≫ f ≫ biprod.snd)	           (biprod.inr ≫ f ≫ biprod.fst)	           (biprod.inr ≫ f ≫ biprod.snd)) ≫	      biprod.fst =	    (biprod.inr ≫ f) ≫ biprod.fst		C : Type u,	_inst_1 : category C,	_inst_2 : preadditive C,	_inst_3 : has_binary_biproducts C,	X₁ X₂ Y₁ Y₂ : C,	f : X₁ ⊞ X₂ ⟶ Y₁ ⊞ Y₂	⊢ (biprod.inr ≫	         biprod.of_components (biprod.inl ≫ f ≫ biprod.fst) (biprod.inl ≫ f ≫ biprod.snd)	           (biprod.inr ≫ f ≫ biprod.fst)	           (biprod.inr ≫ f ≫ biprod.snd)) ≫	      biprod.snd =	    (biprod.inr ≫ f) ≫ biprod.snd
2 goals	C : Type u,	_inst_1 : category C,	_inst_2 : preadditive C,	_inst_3 : has_binary_biproducts C,	X₁ X₂ Y₁ Y₂ : C,	f : X₁ ⊞ X₂ ⟶ Y₁ ⊞ Y₂	⊢ (biprod.inr ≫	         biprod.of_components (biprod.inl ≫ f ≫ biprod.fst) (biprod.inl ≫ f ≫ biprod.snd)	           (biprod.inr ≫ f ≫ biprod.fst)	           (biprod.inr ≫ f ≫ biprod.snd)) ≫	      biprod.fst =	    (biprod.inr ≫ f) ≫ biprod.fst		C : Type u,	_inst_1 : category C,	_inst_2 : preadditive C,	_inst_3 : has_binary_biproducts C,	X₁ X₂ Y₁ Y₂ : C,	f : X₁ ⊞ X₂ ⟶ Y₁ ⊞ Y₂	⊢ (biprod.inr ≫	         biprod.of_components (biprod.inl ≫ f ≫ biprod.fst) (biprod.inl ≫ f ≫ biprod.snd)	           (biprod.inr ≫ f ≫ biprod.fst)	           (biprod.inr ≫ f ≫ biprod.snd)) ≫	      biprod.snd =	    (biprod.inr ≫ f) ≫ biprod.snd
C : Type u,	_inst_1 : category C,	_inst_2 : preadditive C,	_inst_3 : has_binary_biproducts C,	X₁ X₂ Y₁ Y₂ : C,	f : X₁ ⊞ X₂ ⟶ Y₁ ⊞ Y₂	⊢ (biprod.inr ≫	         biprod.of_components (biprod.inl ≫ f ≫ biprod.fst) (biprod.inl ≫ f ≫ biprod.snd)	           (biprod.inr ≫ f ≫ biprod.fst)	           (biprod.inr ≫ f ≫ biprod.snd)) ≫	      biprod.snd =	    (biprod.inr ≫ f) ≫ biprod.snd
⊢ ∀ {C : Type u₁} [_inst_1 : category C] {X : C} (P : Cᵒᵖ ⥤ Type w), presieve.is_sheaf_for P ⇑⊤
C : Type u₁,	_inst_1 : category C,	X : C,	P : Cᵒᵖ ⥤ Type w	⊢ presieve.is_sheaf_for P ⇑⊤
C : Type u₁,	_inst_1 : category C,	X : C,	P : Cᵒᵖ ⥤ Type w	⊢ presieve.is_sheaf_for P ⇑(sieve.generate (presieve.singleton (𝟙 X)))
C : Type u₁,	_inst_1 : category C,	X : C,	P : Cᵒᵖ ⥤ Type w	⊢ presieve.is_sheaf_for P (presieve.singleton (𝟙 X))
⊢ ∀ {C : Type u₁} [_inst_1 : category C] {X Y Z : C} (f : X ⟶ Y) (g : Y ⟶ Z) [_inst_3 : mono f]	  [_inst_4 : mono g] (x : subobject X),	    (subobject.map (f ≫ g)).obj x = (subobject.map g).obj ((subobject.map f).obj x)
C : Type u₁,	_inst_1 : category C,	X Y Z : C,	f : X ⟶ Y,	g : Y ⟶ Z,	_inst_3 : mono f,	_inst_4 : mono g,	x : subobject X	⊢ (subobject.map (f ≫ g)).obj x = (subobject.map g).obj ((subobject.map f).obj x)
C : Type u₁,	_inst_1 : category C,	X Y Z : C,	f : X ⟶ Y,	g : Y ⟶ Z,	_inst_3 : mono f,	_inst_4 : mono g,	x : subobject X	⊢ ∀ (a : mono_over X),	    (subobject.map (f ≫ g)).obj (quotient.mk' a) = (subobject.map g).obj ((subobject.map f).obj (quotient.mk' a))
C : Type u₁,	_inst_1 : category C,	X Y Z : C,	f : X ⟶ Y,	g : Y ⟶ Z,	_inst_3 : mono f,	_inst_4 : mono g,	x : subobject X,	t : mono_over X	⊢ (subobject.map (f ≫ g)).obj (quotient.mk' t) = (subobject.map g).obj ((subobject.map f).obj (quotient.mk' t))
C : Type u₁,	_inst_1 : category C,	X Y Z : C,	f : X ⟶ Y,	g : Y ⟶ Z,	_inst_3 : mono f,	_inst_4 : mono g,	x : subobject X,	t : mono_over X	⊢ (mono_over.map (f ≫ g)).obj t ≈ (mono_over.map g).obj ((mono_over.map f).obj t)
⊢ ∀ {C : Type u} [_inst_1 : category C] {X Y : C} [_inst_3 : has_zero_morphisms C] [_inst_4 : has_zero_object C],	    (image_subobject 0).arrow = 0
C : Type u,	_inst_1 : category C,	X Y : C,	_inst_3 : has_zero_morphisms C,	_inst_4 : has_zero_object C	⊢ (image_subobject 0).arrow = 0
C : Type u,	_inst_1 : category C,	X Y : C,	_inst_3 : has_zero_morphisms C,	_inst_4 : has_zero_object C	⊢ (image_subobject_iso 0).hom ≫ image.ι 0 = 0
⊢ ∀ {C : Type u} [_inst_1 : category C] {X Y : C} (f g : X ⟶ Y) [_inst_2 : has_equalizer f g],	    (equalizer_subobject_iso f g).inv ≫ (equalizer_subobject f g).arrow = equalizer.ι f g
C : Type u,	_inst_1 : category C,	X Y : C,	f g : X ⟶ Y,	_inst_2 : has_equalizer f g	⊢ (equalizer_subobject_iso f g).inv ≫ (equalizer_subobject f g).arrow = equalizer.ι f g
⊢ ∀ {C : Type u₁} [_inst_1 : category C] (F : Cᵒᵖ ⥤ Type v₁) [_inst_2 : F.representable] (X : Cᵒᵖ)	  (f : unop X ⟶ F.repr_X), (F.repr_w.app X).hom f = F.map f.op F.repr_x
C : Type u₁,	_inst_1 : category C,	F : Cᵒᵖ ⥤ Type v₁,	_inst_2 : F.representable,	X : Cᵒᵖ,	f : unop X ⟶ F.repr_X	⊢ (F.repr_w.app X).hom f = F.map f.op F.repr_x
C : Type u₁,	_inst_1 : category C,	F : Cᵒᵖ ⥤ Type v₁,	_inst_2 : F.representable,	X : Cᵒᵖ,	f : unop X ⟶ F.repr_X	⊢ F.repr_f.app X f = (F.repr_f.app (op F.repr_X) ≫ F.map f.op) (𝟙 F.repr_X)
C : Type u₁,	_inst_1 : category C,	F : Cᵒᵖ ⥤ Type v₁,	_inst_2 : F.representable,	X : Cᵒᵖ,	f : unop X ⟶ F.repr_X	⊢ F.repr_f.app X f = ((yoneda.obj F.repr_X).map f.op ≫ F.repr_f.app (op (unop X))) (𝟙 F.repr_X)
C : Type u₁,	_inst_1 : category C,	F : Cᵒᵖ ⥤ Type v₁,	_inst_2 : F.representable,	X : Cᵒᵖ,	f : unop X ⟶ F.repr_X	⊢ F.repr_f.app X f = F.repr_f.app X (f ≫ 𝟙 F.repr_X)
⊢ ∀ {α : Type u_1} [_inst_1 : linear_order α] (A B : finset α),	    (A \ B).to_colex ≤ (B \ A).to_colex ↔ A.to_colex ≤ B.to_colex
α : Type u_1,	_inst_1 : linear_order α,	A B : finset α	⊢ (A \ B).to_colex ≤ (B \ A).to_colex ↔ A.to_colex ≤ B.to_colex
⊢ ∀ {V : Type u} (G : simple_graph V) [_inst_1 : fintype V] [_inst_2 : decidable_rel G.adj]	  [_inst_3 : decidable_eq V] (v : V), (filter (λ (d : G.dart), d.fst = v) univ).card = G.degree v
V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_rel G.adj,	_inst_3 : decidable_eq V,	v : V	⊢ (filter (λ (d : G.dart), d.fst = v) univ).card = G.degree v
V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_rel G.adj,	_inst_3 : decidable_eq V,	v : V,	hh : (image (G.dart_of_neighbor_set v) univ).card = univ.card	⊢ (filter (λ (d : G.dart), d.fst = v) univ).card = G.degree v
V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_rel G.adj,	_inst_3 : decidable_eq V,	v : V,	hh : (image (G.dart_of_neighbor_set v) univ).card = G.degree v	⊢ (filter (λ (d : G.dart), d.fst = v) univ).card = G.degree v
⊢ ∀ {α : Type u} {σ : Type v} (M : NFA α σ) (S : set σ), M.to_ε_NFA.ε_closure S = S
α : Type u,	σ : Type v,	M : NFA α σ,	S : set σ	⊢ M.to_ε_NFA.ε_closure S = S
α : Type u,	σ : Type v,	M : NFA α σ,	S : set σ,	a : σ	⊢ a ∈ M.to_ε_NFA.ε_closure S ↔ a ∈ S
2 goals	α : Type u,	σ : Type v,	M : NFA α σ,	S : set σ,	a : σ	⊢ a ∈ M.to_ε_NFA.ε_closure S → a ∈ S		α : Type u,	σ : Type v,	M : NFA α σ,	S : set σ,	a : σ	⊢ a ∈ S → a ∈ M.to_ε_NFA.ε_closure S
3 goals	α : Type u,	σ : Type v,	M : NFA α σ,	S : set σ,	a : σ,	h : a ∈ S	⊢ a ∈ S		α : Type u,	σ : Type v,	M : NFA α σ,	S : set σ,	a ᾰ_s : σ,	ᾰ_ᾰ : M.to_ε_NFA.ε_closure S ᾰ_s,	h : a ∈ M.to_ε_NFA.step ᾰ_s none	⊢ a ∈ S		α : Type u,	σ : Type v,	M : NFA α σ,	S : set σ,	a : σ	⊢ a ∈ S → a ∈ M.to_ε_NFA.ε_closure S
2 goals	α : Type u,	σ : Type v,	M : NFA α σ,	S : set σ,	a ᾰ_s : σ,	ᾰ_ᾰ : M.to_ε_NFA.ε_closure S ᾰ_s,	h : a ∈ M.to_ε_NFA.step ᾰ_s none	⊢ a ∈ S		α : Type u,	σ : Type v,	M : NFA α σ,	S : set σ,	a : σ	⊢ a ∈ S → a ∈ M.to_ε_NFA.ε_closure S
α : Type u,	σ : Type v,	M : NFA α σ,	S : set σ,	a : σ	⊢ a ∈ S → a ∈ M.to_ε_NFA.ε_closure S
α : Type u,	σ : Type v,	M : NFA α σ,	S : set σ,	a : σ,	h : a ∈ S	⊢ a ∈ M.to_ε_NFA.ε_closure S
α : Type u,	σ : Type v,	M : NFA α σ,	S : set σ,	a : σ,	h : a ∈ S	⊢ a ∈ S
⊢ ∀ {α : Type u_1} [_inst_1 : primcodable α], primrec ulower.down
α : Type u_1,	_inst_1 : primcodable α	⊢ primrec ulower.down
α : Type u_1,	_inst_1 : primcodable α,	_inst : Π (a : ℕ), decidable (a ∈ set.range encode) := decidable_range_encode α	⊢ primrec ulower.down
⊢ ∀ {α : Type u_1} [_inst_1 : primcodable α] {β : Type u_2} {e : β ≃ α}, primrec ⇑e
α : Type u_1,	_inst_1 : primcodable α,	β : Type u_2,	e : β ≃ α	⊢ primrec ⇑e
α : Type u_1,	_inst_1 : primcodable α,	β : Type u_2,	e : β ≃ α,	_inst : primcodable β := primcodable.of_equiv α e	⊢ primrec ⇑e
⊢ ∀ (c : to_partrec.code) (k k' : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c (k.then k') v = (to_partrec.step_normal c k v).then k'
c : to_partrec.code,	k k' : to_partrec.cont,	v : list ℕ	⊢ to_partrec.step_normal c (k.then k') v = (to_partrec.step_normal c k v).then k'
7 goals	case turing.to_partrec.code.zero'	k' k : to_partrec.cont,	v : list ℕ	⊢ to_partrec.step_normal to_partrec.code.zero' (k.then k') v =	    (to_partrec.step_normal to_partrec.code.zero' k v).then k'		case turing.to_partrec.code.succ	k' k : to_partrec.cont,	v : list ℕ	⊢ to_partrec.step_normal to_partrec.code.succ (k.then k') v =	    (to_partrec.step_normal to_partrec.code.succ k v).then k'		case turing.to_partrec.code.tail	k' k : to_partrec.cont,	v : list ℕ	⊢ to_partrec.step_normal to_partrec.code.tail (k.then k') v =	    (to_partrec.step_normal to_partrec.code.tail k v).then k'		case turing.to_partrec.code.cons	k' : to_partrec.cont,	c_ᾰ c_ᾰ_1 : to_partrec.code,	c_ih_ᾰ :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ (k.then k') v = (to_partrec.step_normal c_ᾰ k v).then k',	c_ih_ᾰ_1 :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ_1 (k.then k') v = (to_partrec.step_normal c_ᾰ_1 k v).then k',	k : to_partrec.cont,	v : list ℕ	⊢ to_partrec.step_normal (c_ᾰ.cons c_ᾰ_1) (k.then k') v =	    (to_partrec.step_normal (c_ᾰ.cons c_ᾰ_1) k v).then k'		case turing.to_partrec.code.comp	k' : to_partrec.cont,	c_ᾰ c_ᾰ_1 : to_partrec.code,	c_ih_ᾰ :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ (k.then k') v = (to_partrec.step_normal c_ᾰ k v).then k',	c_ih_ᾰ_1 :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ_1 (k.then k') v = (to_partrec.step_normal c_ᾰ_1 k v).then k',	k : to_partrec.cont,	v : list ℕ	⊢ to_partrec.step_normal (c_ᾰ.comp c_ᾰ_1) (k.then k') v =	    (to_partrec.step_normal (c_ᾰ.comp c_ᾰ_1) k v).then k'		case turing.to_partrec.code.case	k' : to_partrec.cont,	c_ᾰ c_ᾰ_1 : to_partrec.code,	c_ih_ᾰ :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ (k.then k') v = (to_partrec.step_normal c_ᾰ k v).then k',	c_ih_ᾰ_1 :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ_1 (k.then k') v = (to_partrec.step_normal c_ᾰ_1 k v).then k',	k : to_partrec.cont,	v : list ℕ	⊢ to_partrec.step_normal (c_ᾰ.case c_ᾰ_1) (k.then k') v =	    (to_partrec.step_normal (c_ᾰ.case c_ᾰ_1) k v).then k'		case turing.to_partrec.code.fix	k' : to_partrec.cont,	c_ᾰ : to_partrec.code,	c_ih :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ (k.then k') v = (to_partrec.step_normal c_ᾰ k v).then k',	k : to_partrec.cont,	v : list ℕ	⊢ to_partrec.step_normal c_ᾰ.fix (k.then k') v = (to_partrec.step_normal c_ᾰ.fix k v).then k'
6 goals	case turing.to_partrec.code.succ	k' k : to_partrec.cont,	v : list ℕ	⊢ to_partrec.step_normal to_partrec.code.succ (k.then k') v =	    (to_partrec.step_normal to_partrec.code.succ k v).then k'		case turing.to_partrec.code.tail	k' k : to_partrec.cont,	v : list ℕ	⊢ to_partrec.step_normal to_partrec.code.tail (k.then k') v =	    (to_partrec.step_normal to_partrec.code.tail k v).then k'		case turing.to_partrec.code.cons	k' : to_partrec.cont,	c_ᾰ c_ᾰ_1 : to_partrec.code,	c_ih_ᾰ :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ (k.then k') v = (to_partrec.step_normal c_ᾰ k v).then k',	c_ih_ᾰ_1 :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ_1 (k.then k') v = (to_partrec.step_normal c_ᾰ_1 k v).then k',	k : to_partrec.cont,	v : list ℕ	⊢ to_partrec.step_normal (c_ᾰ.cons c_ᾰ_1) (k.then k') v =	    (to_partrec.step_normal (c_ᾰ.cons c_ᾰ_1) k v).then k'		case turing.to_partrec.code.comp	k' : to_partrec.cont,	c_ᾰ c_ᾰ_1 : to_partrec.code,	c_ih_ᾰ :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ (k.then k') v = (to_partrec.step_normal c_ᾰ k v).then k',	c_ih_ᾰ_1 :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ_1 (k.then k') v = (to_partrec.step_normal c_ᾰ_1 k v).then k',	k : to_partrec.cont,	v : list ℕ	⊢ to_partrec.step_normal (c_ᾰ.comp c_ᾰ_1) (k.then k') v =	    (to_partrec.step_normal (c_ᾰ.comp c_ᾰ_1) k v).then k'		case turing.to_partrec.code.case	k' : to_partrec.cont,	c_ᾰ c_ᾰ_1 : to_partrec.code,	c_ih_ᾰ :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ (k.then k') v = (to_partrec.step_normal c_ᾰ k v).then k',	c_ih_ᾰ_1 :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ_1 (k.then k') v = (to_partrec.step_normal c_ᾰ_1 k v).then k',	k : to_partrec.cont,	v : list ℕ	⊢ to_partrec.step_normal (c_ᾰ.case c_ᾰ_1) (k.then k') v =	    (to_partrec.step_normal (c_ᾰ.case c_ᾰ_1) k v).then k'		case turing.to_partrec.code.fix	k' : to_partrec.cont,	c_ᾰ : to_partrec.code,	c_ih :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ (k.then k') v = (to_partrec.step_normal c_ᾰ k v).then k',	k : to_partrec.cont,	v : list ℕ	⊢ to_partrec.step_normal c_ᾰ.fix (k.then k') v = (to_partrec.step_normal c_ᾰ.fix k v).then k'
5 goals	case turing.to_partrec.code.tail	k' k : to_partrec.cont,	v : list ℕ	⊢ to_partrec.step_normal to_partrec.code.tail (k.then k') v =	    (to_partrec.step_normal to_partrec.code.tail k v).then k'		case turing.to_partrec.code.cons	k' : to_partrec.cont,	c_ᾰ c_ᾰ_1 : to_partrec.code,	c_ih_ᾰ :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ (k.then k') v = (to_partrec.step_normal c_ᾰ k v).then k',	c_ih_ᾰ_1 :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ_1 (k.then k') v = (to_partrec.step_normal c_ᾰ_1 k v).then k',	k : to_partrec.cont,	v : list ℕ	⊢ to_partrec.step_normal (c_ᾰ.cons c_ᾰ_1) (k.then k') v =	    (to_partrec.step_normal (c_ᾰ.cons c_ᾰ_1) k v).then k'		case turing.to_partrec.code.comp	k' : to_partrec.cont,	c_ᾰ c_ᾰ_1 : to_partrec.code,	c_ih_ᾰ :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ (k.then k') v = (to_partrec.step_normal c_ᾰ k v).then k',	c_ih_ᾰ_1 :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ_1 (k.then k') v = (to_partrec.step_normal c_ᾰ_1 k v).then k',	k : to_partrec.cont,	v : list ℕ	⊢ to_partrec.step_normal (c_ᾰ.comp c_ᾰ_1) (k.then k') v =	    (to_partrec.step_normal (c_ᾰ.comp c_ᾰ_1) k v).then k'		case turing.to_partrec.code.case	k' : to_partrec.cont,	c_ᾰ c_ᾰ_1 : to_partrec.code,	c_ih_ᾰ :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ (k.then k') v = (to_partrec.step_normal c_ᾰ k v).then k',	c_ih_ᾰ_1 :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ_1 (k.then k') v = (to_partrec.step_normal c_ᾰ_1 k v).then k',	k : to_partrec.cont,	v : list ℕ	⊢ to_partrec.step_normal (c_ᾰ.case c_ᾰ_1) (k.then k') v =	    (to_partrec.step_normal (c_ᾰ.case c_ᾰ_1) k v).then k'		case turing.to_partrec.code.fix	k' : to_partrec.cont,	c_ᾰ : to_partrec.code,	c_ih :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ (k.then k') v = (to_partrec.step_normal c_ᾰ k v).then k',	k : to_partrec.cont,	v : list ℕ	⊢ to_partrec.step_normal c_ᾰ.fix (k.then k') v = (to_partrec.step_normal c_ᾰ.fix k v).then k'
4 goals	case turing.to_partrec.code.cons	k' : to_partrec.cont,	c_ᾰ c_ᾰ_1 : to_partrec.code,	c_ih_ᾰ :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ (k.then k') v = (to_partrec.step_normal c_ᾰ k v).then k',	c_ih_ᾰ_1 :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ_1 (k.then k') v = (to_partrec.step_normal c_ᾰ_1 k v).then k',	k : to_partrec.cont,	v : list ℕ	⊢ to_partrec.step_normal (c_ᾰ.cons c_ᾰ_1) (k.then k') v =	    (to_partrec.step_normal (c_ᾰ.cons c_ᾰ_1) k v).then k'		case turing.to_partrec.code.comp	k' : to_partrec.cont,	c_ᾰ c_ᾰ_1 : to_partrec.code,	c_ih_ᾰ :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ (k.then k') v = (to_partrec.step_normal c_ᾰ k v).then k',	c_ih_ᾰ_1 :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ_1 (k.then k') v = (to_partrec.step_normal c_ᾰ_1 k v).then k',	k : to_partrec.cont,	v : list ℕ	⊢ to_partrec.step_normal (c_ᾰ.comp c_ᾰ_1) (k.then k') v =	    (to_partrec.step_normal (c_ᾰ.comp c_ᾰ_1) k v).then k'		case turing.to_partrec.code.case	k' : to_partrec.cont,	c_ᾰ c_ᾰ_1 : to_partrec.code,	c_ih_ᾰ :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ (k.then k') v = (to_partrec.step_normal c_ᾰ k v).then k',	c_ih_ᾰ_1 :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ_1 (k.then k') v = (to_partrec.step_normal c_ᾰ_1 k v).then k',	k : to_partrec.cont,	v : list ℕ	⊢ to_partrec.step_normal (c_ᾰ.case c_ᾰ_1) (k.then k') v =	    (to_partrec.step_normal (c_ᾰ.case c_ᾰ_1) k v).then k'		case turing.to_partrec.code.fix	k' : to_partrec.cont,	c_ᾰ : to_partrec.code,	c_ih :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ (k.then k') v = (to_partrec.step_normal c_ᾰ k v).then k',	k : to_partrec.cont,	v : list ℕ	⊢ to_partrec.step_normal c_ᾰ.fix (k.then k') v = (to_partrec.step_normal c_ᾰ.fix k v).then k'
4 goals	case turing.to_partrec.code.cons	k' : to_partrec.cont,	c_ᾰ c_ᾰ_1 : to_partrec.code,	c_ih_ᾰ :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ (k.then k') v = (to_partrec.step_normal c_ᾰ k v).then k',	c_ih_ᾰ_1 :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ_1 (k.then k') v = (to_partrec.step_normal c_ᾰ_1 k v).then k',	k : to_partrec.cont,	v : list ℕ	⊢ to_partrec.step_normal c_ᾰ (to_partrec.cont.cons₁ c_ᾰ_1 v (k.then k')) v =	    (to_partrec.step_normal c_ᾰ (to_partrec.cont.cons₁ c_ᾰ_1 v k) v).then k'		case turing.to_partrec.code.comp	k' : to_partrec.cont,	c_ᾰ c_ᾰ_1 : to_partrec.code,	c_ih_ᾰ :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ (k.then k') v = (to_partrec.step_normal c_ᾰ k v).then k',	c_ih_ᾰ_1 :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ_1 (k.then k') v = (to_partrec.step_normal c_ᾰ_1 k v).then k',	k : to_partrec.cont,	v : list ℕ	⊢ to_partrec.step_normal (c_ᾰ.comp c_ᾰ_1) (k.then k') v =	    (to_partrec.step_normal (c_ᾰ.comp c_ᾰ_1) k v).then k'		case turing.to_partrec.code.case	k' : to_partrec.cont,	c_ᾰ c_ᾰ_1 : to_partrec.code,	c_ih_ᾰ :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ (k.then k') v = (to_partrec.step_normal c_ᾰ k v).then k',	c_ih_ᾰ_1 :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ_1 (k.then k') v = (to_partrec.step_normal c_ᾰ_1 k v).then k',	k : to_partrec.cont,	v : list ℕ	⊢ to_partrec.step_normal (c_ᾰ.case c_ᾰ_1) (k.then k') v =	    (to_partrec.step_normal (c_ᾰ.case c_ᾰ_1) k v).then k'		case turing.to_partrec.code.fix	k' : to_partrec.cont,	c_ᾰ : to_partrec.code,	c_ih :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ (k.then k') v = (to_partrec.step_normal c_ᾰ k v).then k',	k : to_partrec.cont,	v : list ℕ	⊢ to_partrec.step_normal c_ᾰ.fix (k.then k') v = (to_partrec.step_normal c_ᾰ.fix k v).then k'
3 goals	case turing.to_partrec.code.comp	k' : to_partrec.cont,	c_ᾰ c_ᾰ_1 : to_partrec.code,	c_ih_ᾰ :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ (k.then k') v = (to_partrec.step_normal c_ᾰ k v).then k',	c_ih_ᾰ_1 :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ_1 (k.then k') v = (to_partrec.step_normal c_ᾰ_1 k v).then k',	k : to_partrec.cont,	v : list ℕ	⊢ to_partrec.step_normal (c_ᾰ.comp c_ᾰ_1) (k.then k') v =	    (to_partrec.step_normal (c_ᾰ.comp c_ᾰ_1) k v).then k'		case turing.to_partrec.code.case	k' : to_partrec.cont,	c_ᾰ c_ᾰ_1 : to_partrec.code,	c_ih_ᾰ :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ (k.then k') v = (to_partrec.step_normal c_ᾰ k v).then k',	c_ih_ᾰ_1 :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ_1 (k.then k') v = (to_partrec.step_normal c_ᾰ_1 k v).then k',	k : to_partrec.cont,	v : list ℕ	⊢ to_partrec.step_normal (c_ᾰ.case c_ᾰ_1) (k.then k') v =	    (to_partrec.step_normal (c_ᾰ.case c_ᾰ_1) k v).then k'		case turing.to_partrec.code.fix	k' : to_partrec.cont,	c_ᾰ : to_partrec.code,	c_ih :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ (k.then k') v = (to_partrec.step_normal c_ᾰ k v).then k',	k : to_partrec.cont,	v : list ℕ	⊢ to_partrec.step_normal c_ᾰ.fix (k.then k') v = (to_partrec.step_normal c_ᾰ.fix k v).then k'
3 goals	case turing.to_partrec.code.comp	k' : to_partrec.cont,	c_ᾰ c_ᾰ_1 : to_partrec.code,	c_ih_ᾰ :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ (k.then k') v = (to_partrec.step_normal c_ᾰ k v).then k',	c_ih_ᾰ_1 :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ_1 (k.then k') v = (to_partrec.step_normal c_ᾰ_1 k v).then k',	k : to_partrec.cont,	v : list ℕ	⊢ to_partrec.step_normal c_ᾰ_1 (to_partrec.cont.comp c_ᾰ (k.then k')) v =	    (to_partrec.step_normal c_ᾰ_1 (to_partrec.cont.comp c_ᾰ k) v).then k'		case turing.to_partrec.code.case	k' : to_partrec.cont,	c_ᾰ c_ᾰ_1 : to_partrec.code,	c_ih_ᾰ :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ (k.then k') v = (to_partrec.step_normal c_ᾰ k v).then k',	c_ih_ᾰ_1 :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ_1 (k.then k') v = (to_partrec.step_normal c_ᾰ_1 k v).then k',	k : to_partrec.cont,	v : list ℕ	⊢ to_partrec.step_normal (c_ᾰ.case c_ᾰ_1) (k.then k') v =	    (to_partrec.step_normal (c_ᾰ.case c_ᾰ_1) k v).then k'		case turing.to_partrec.code.fix	k' : to_partrec.cont,	c_ᾰ : to_partrec.code,	c_ih :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ (k.then k') v = (to_partrec.step_normal c_ᾰ k v).then k',	k : to_partrec.cont,	v : list ℕ	⊢ to_partrec.step_normal c_ᾰ.fix (k.then k') v = (to_partrec.step_normal c_ᾰ.fix k v).then k'
2 goals	case turing.to_partrec.code.case	k' : to_partrec.cont,	c_ᾰ c_ᾰ_1 : to_partrec.code,	c_ih_ᾰ :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ (k.then k') v = (to_partrec.step_normal c_ᾰ k v).then k',	c_ih_ᾰ_1 :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ_1 (k.then k') v = (to_partrec.step_normal c_ᾰ_1 k v).then k',	k : to_partrec.cont,	v : list ℕ	⊢ to_partrec.step_normal (c_ᾰ.case c_ᾰ_1) (k.then k') v =	    (to_partrec.step_normal (c_ᾰ.case c_ᾰ_1) k v).then k'		case turing.to_partrec.code.fix	k' : to_partrec.cont,	c_ᾰ : to_partrec.code,	c_ih :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ (k.then k') v = (to_partrec.step_normal c_ᾰ k v).then k',	k : to_partrec.cont,	v : list ℕ	⊢ to_partrec.step_normal c_ᾰ.fix (k.then k') v = (to_partrec.step_normal c_ᾰ.fix k v).then k'
2 goals	case turing.to_partrec.code.case	k' : to_partrec.cont,	c_ᾰ c_ᾰ_1 : to_partrec.code,	c_ih_ᾰ :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ (k.then k') v = (to_partrec.step_normal c_ᾰ k v).then k',	c_ih_ᾰ_1 :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ_1 (k.then k') v = (to_partrec.step_normal c_ᾰ_1 k v).then k',	k : to_partrec.cont,	v : list ℕ	⊢ nat.elim ((to_partrec.step_normal c_ᾰ k v.tail).then k')	      (λ (y : ℕ) (_x : to_partrec.cfg), (to_partrec.step_normal c_ᾰ_1 k (y :: v.tail)).then k')	      v.head =	    (nat.elim (to_partrec.step_normal c_ᾰ k v.tail)	       (λ (y : ℕ) (_x : to_partrec.cfg), to_partrec.step_normal c_ᾰ_1 k (y :: v.tail))	       v.head).then	      k'		case turing.to_partrec.code.fix	k' : to_partrec.cont,	c_ᾰ : to_partrec.code,	c_ih :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ (k.then k') v = (to_partrec.step_normal c_ᾰ k v).then k',	k : to_partrec.cont,	v : list ℕ	⊢ to_partrec.step_normal c_ᾰ.fix (k.then k') v = (to_partrec.step_normal c_ᾰ.fix k v).then k'
3 goals	case turing.to_partrec.code.case, nat.zero	k' : to_partrec.cont,	c_ᾰ c_ᾰ_1 : to_partrec.code,	c_ih_ᾰ :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ (k.then k') v = (to_partrec.step_normal c_ᾰ k v).then k',	c_ih_ᾰ_1 :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ_1 (k.then k') v = (to_partrec.step_normal c_ᾰ_1 k v).then k',	k : to_partrec.cont,	v : list ℕ	⊢ nat.elim ((to_partrec.step_normal c_ᾰ k v.tail).then k')	      (λ (y : ℕ) (_x : to_partrec.cfg), (to_partrec.step_normal c_ᾰ_1 k (y :: v.tail)).then k')	      0 =	    (nat.elim (to_partrec.step_normal c_ᾰ k v.tail)	       (λ (y : ℕ) (_x : to_partrec.cfg), to_partrec.step_normal c_ᾰ_1 k (y :: v.tail))	       0).then	      k'		case turing.to_partrec.code.case, nat.succ	k' : to_partrec.cont,	c_ᾰ c_ᾰ_1 : to_partrec.code,	c_ih_ᾰ :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ (k.then k') v = (to_partrec.step_normal c_ᾰ k v).then k',	c_ih_ᾰ_1 :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ_1 (k.then k') v = (to_partrec.step_normal c_ᾰ_1 k v).then k',	k : to_partrec.cont,	v : list ℕ,	n : ℕ	⊢ nat.elim ((to_partrec.step_normal c_ᾰ k v.tail).then k')	      (λ (y : ℕ) (_x : to_partrec.cfg), (to_partrec.step_normal c_ᾰ_1 k (y :: v.tail)).then k')	      n.succ =	    (nat.elim (to_partrec.step_normal c_ᾰ k v.tail)	       (λ (y : ℕ) (_x : to_partrec.cfg), to_partrec.step_normal c_ᾰ_1 k (y :: v.tail))	       n.succ).then	      k'		case turing.to_partrec.code.fix	k' : to_partrec.cont,	c_ᾰ : to_partrec.code,	c_ih :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ (k.then k') v = (to_partrec.step_normal c_ᾰ k v).then k',	k : to_partrec.cont,	v : list ℕ	⊢ to_partrec.step_normal c_ᾰ.fix (k.then k') v = (to_partrec.step_normal c_ᾰ.fix k v).then k'
2 goals	case turing.to_partrec.code.case, nat.succ	k' : to_partrec.cont,	c_ᾰ c_ᾰ_1 : to_partrec.code,	c_ih_ᾰ :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ (k.then k') v = (to_partrec.step_normal c_ᾰ k v).then k',	c_ih_ᾰ_1 :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ_1 (k.then k') v = (to_partrec.step_normal c_ᾰ_1 k v).then k',	k : to_partrec.cont,	v : list ℕ,	n : ℕ	⊢ nat.elim ((to_partrec.step_normal c_ᾰ k v.tail).then k')	      (λ (y : ℕ) (_x : to_partrec.cfg), (to_partrec.step_normal c_ᾰ_1 k (y :: v.tail)).then k')	      n.succ =	    (nat.elim (to_partrec.step_normal c_ᾰ k v.tail)	       (λ (y : ℕ) (_x : to_partrec.cfg), to_partrec.step_normal c_ᾰ_1 k (y :: v.tail))	       n.succ).then	      k'		case turing.to_partrec.code.fix	k' : to_partrec.cont,	c_ᾰ : to_partrec.code,	c_ih :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ (k.then k') v = (to_partrec.step_normal c_ᾰ k v).then k',	k : to_partrec.cont,	v : list ℕ	⊢ to_partrec.step_normal c_ᾰ.fix (k.then k') v = (to_partrec.step_normal c_ᾰ.fix k v).then k'
case turing.to_partrec.code.fix	k' : to_partrec.cont,	c_ᾰ : to_partrec.code,	c_ih :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ (k.then k') v = (to_partrec.step_normal c_ᾰ k v).then k',	k : to_partrec.cont,	v : list ℕ	⊢ to_partrec.step_normal c_ᾰ.fix (k.then k') v = (to_partrec.step_normal c_ᾰ.fix k v).then k'
case turing.to_partrec.code.fix	k' : to_partrec.cont,	c_ᾰ : to_partrec.code,	c_ih :	  ∀ (k : to_partrec.cont) (v : list ℕ),	    to_partrec.step_normal c_ᾰ (k.then k') v = (to_partrec.step_normal c_ᾰ k v).then k',	k : to_partrec.cont,	v : list ℕ	⊢ to_partrec.step_normal c_ᾰ (to_partrec.cont.fix c_ᾰ (k.then k')) v =	    (to_partrec.step_normal c_ᾰ (to_partrec.cont.fix c_ᾰ k) v).then k'
⊢ ∀ {Γ : Type u_1} [_inst_1 : inhabited Γ] (T : tape Γ), tape.move dir.left (tape.move dir.right T) = T
Γ : Type u_1,	_inst_1 : inhabited Γ,	T : tape Γ	⊢ tape.move dir.left (tape.move dir.right T) = T
Γ : Type u_1,	_inst_1 : inhabited Γ,	T_head : Γ,	T_left T_right : list_blank Γ	⊢ tape.move dir.left (tape.move dir.right {head := T_head, left := T_left, right := T_right}) =	    {head := T_head, left := T_left, right := T_right}
⊢ ∀ {σ : Type u_1} {f : σ → option σ} {a b c : σ}, reaches₁ f a c → b ∈ f a → reaches f b c
σ : Type u_1,	f : σ → option σ,	a b c : σ,	h₁ : reaches₁ f a c,	h₂ : b ∈ f a	⊢ reaches f b c
σ : Type u_1,	f : σ → option σ,	a b c : σ,	h₁ : reaches₁ f a c,	h₂ : b ∈ f a,	b' : σ,	hab : b' ∈ f a,	hbc : refl_trans_gen (λ (a b : σ), b ∈ f a) b' c	⊢ reaches f b c
σ : Type u_1,	f : σ → option σ,	a b c : σ,	h₁ : reaches₁ f a c,	h₂ hab : b ∈ f a,	hbc : refl_trans_gen (λ (a b : σ), b ∈ f a) b c,	_x : b = b	⊢ reaches f b c
⊢ ∀ {α β : Type u} {m : Type u → Type u} [_inst_3 : monad m] [_inst_4 : is_lawful_monad m]	  (f : β → α → m α), mfoldr.of_free_monoid f ∘ free.mk = mfoldr.mk ∘ f
α β : Type u,	m : Type u → Type u,	_inst_3 : monad m,	_inst_4 : is_lawful_monad m,	f : β → α → m α	⊢ mfoldr.of_free_monoid f ∘ free.mk = mfoldr.mk ∘ f
α β : Type u,	m : Type u → Type u,	_inst_3 : monad m,	_inst_4 : is_lawful_monad m,	f : β → α → m α,	x : β,	x_1 : Kleisli.mk (λ {α : Type u}, m α) α	⊢ (mfoldr.of_free_monoid f ∘ free.mk) x x_1 = (mfoldr.mk ∘ f) x x_1
⊢ ∀ {x : ℕ} {b : bool}, add_lsb x b = 2 * x + cond b 1 0
x : ℕ,	b : bool	⊢ add_lsb x b = 2 * x + cond b 1 0
⊢ ∀ {α : Type u_1} (b : buffer α) (a : α) {i : ℕ} (h : i < b.size),	    (b.push_back a).read ⟨i, _⟩ = b.read ⟨i, h⟩
α : Type u_1,	b : buffer α,	a : α,	i : ℕ,	h : i < b.size	⊢ (b.push_back a).read ⟨i, _⟩ = b.read ⟨i, h⟩
α : Type u_1,	a : α,	i b_fst : ℕ,	b_snd : array b_fst α,	h : i < size ⟨b_fst, b_snd⟩	⊢ (push_back ⟨b_fst, b_snd⟩ a).read ⟨i, _⟩ = read ⟨b_fst, b_snd⟩ ⟨i, h⟩
α : Type u_1,	a : α,	i b_fst : ℕ,	b_snd : array b_fst α,	h : i < size ⟨b_fst, b_snd⟩	⊢ i = ⟨i, h⟩.val
⊢ ∀ {α : Type u_1} (b : buffer α) (a : α), (b.push_back a).read ⟨b.size, _⟩ = a
α : Type u_1,	b : buffer α,	a : α	⊢ (b.push_back a).read ⟨b.size, _⟩ = a
α : Type u_1,	a : α,	b_fst : ℕ,	b_snd : array b_fst α	⊢ (push_back ⟨b_fst, b_snd⟩ a).read ⟨size ⟨b_fst, b_snd⟩, _⟩ = a
⊢ ∀ {α : Type} {p : parser α},	    ¬p.bounded → (∃ (cb : char_buffer) (n n' : ℕ) (a : α), p cb n = done n' a ∧ buffer.size cb ≤ n)
α : Type,	p : parser α,	h : ¬p.bounded	⊢ ∃ (cb : char_buffer) (n n' : ℕ) (a : α), p cb n = done n' a ∧ buffer.size cb ≤ n
α : Type,	p : parser α,	h : ∀ (cb : char_buffer) (n n' : ℕ) (a : α), p cb n = done n' a → n < buffer.size cb	⊢ p.bounded
α : Type,	p : parser α,	h : ∀ (cb : char_buffer) (n n' : ℕ) (a : α), p cb n = done n' a → n < buffer.size cb	⊢ ∀ {cb : char_buffer} {n : ℕ},	    buffer.size cb ≤ n → (∃ (n' : ℕ) (err : dlist string), p cb n = fail n' err)
α : Type,	p : parser α,	h : ∀ (cb : char_buffer) (n n' : ℕ) (a : α), p cb n = done n' a → n < buffer.size cb,	cb : char_buffer,	n : ℕ,	hn : buffer.size cb ≤ n	⊢ ∃ (n' : ℕ) (err : dlist string), p cb n = fail n' err
2 goals	case parse_result.done	α : Type,	p : parser α,	h : ∀ (cb : char_buffer) (n n' : ℕ) (a : α), p cb n = done n' a → n < buffer.size cb,	cb : char_buffer,	n : ℕ,	hn : buffer.size cb ≤ n,	pos : ℕ,	result : α,	hp : p cb n = done pos result	⊢ ∃ (n' : ℕ) (err : dlist string), done pos result = fail n' err		case parse_result.fail	α : Type,	p : parser α,	h : ∀ (cb : char_buffer) (n n' : ℕ) (a : α), p cb n = done n' a → n < buffer.size cb,	cb : char_buffer,	n : ℕ,	hn : buffer.size cb ≤ n,	pos : ℕ,	expected : dlist string,	hp : p cb n = fail pos expected	⊢ ∃ (n' : ℕ) (err : dlist string), fail pos expected = fail n' err
case parse_result.fail	α : Type,	p : parser α,	h : ∀ (cb : char_buffer) (n n' : ℕ) (a : α), p cb n = done n' a → n < buffer.size cb,	cb : char_buffer,	n : ℕ,	hn : buffer.size cb ≤ n,	pos : ℕ,	expected : dlist string,	hp : p cb n = fail pos expected	⊢ ∃ (n' : ℕ) (err : dlist string), fail pos expected = fail n' err
⊢ ∀ {α β : Type} {p : parser α} {cb : char_buffer} {n n' : ℕ} {b : β} {f : α → parser β},	    (p >>= f) cb n = done n' b ↔ ∃ (np : ℕ) (a : α), p cb n = done np a ∧ f a cb np = done n' b
α β : Type,	p : parser α,	cb : char_buffer,	n n' : ℕ,	b : β,	f : α → parser β	⊢ (p >>= f) cb n = done n' b ↔ ∃ (np : ℕ) (a : α), p cb n = done np a ∧ f a cb np = done n' b
2 goals	case parse_result.done	α β : Type,	p : parser α,	cb : char_buffer,	n n' : ℕ,	b : β,	f : α → parser β,	pos : ℕ,	result : α,	hp : p cb n = done pos result	⊢ (p >>= f) cb n = done n' b ↔ ∃ (np : ℕ) (a : α), done pos result = done np a ∧ f a cb np = done n' b		case parse_result.fail	α β : Type,	p : parser α,	cb : char_buffer,	n n' : ℕ,	b : β,	f : α → parser β,	pos : ℕ,	expected : dlist string,	hp : p cb n = fail pos expected	⊢ (p >>= f) cb n = done n' b ↔ ∃ (np : ℕ) (a : α), fail pos expected = done np a ∧ f a cb np = done n' b
case parse_result.fail	α β : Type,	p : parser α,	cb : char_buffer,	n n' : ℕ,	b : β,	f : α → parser β,	pos : ℕ,	expected : dlist string,	hp : p cb n = fail pos expected	⊢ (p >>= f) cb n = done n' b ↔ ∃ (np : ℕ) (a : α), fail pos expected = done np a ∧ f a cb np = done n' b
⊢ ∀ {α β : Type} {cb : char_buffer} {n n' : ℕ} {f : α → parser β} {a : α} {l : list α} {b : β}	  {l' : list β},	    mmap f (a :: l) cb n = done n' (b :: l') ↔ ∃ (np : ℕ), f a cb n = done np b ∧ mmap f l cb np = done n' l'
α β : Type,	cb : char_buffer,	n n' : ℕ,	f : α → parser β,	a : α,	l : list α,	b : β,	l' : list β	⊢ mmap f (a :: l) cb n = done n' (b :: l') ↔ ∃ (np : ℕ), f a cb n = done np b ∧ mmap f l cb np = done n' l'
⊢ ∀ {cb : char_buffer} {n n' : ℕ} {c : char} {p : char → Prop} [_inst_1 : decidable_pred p],	    sat p cb n = done n' c ↔ ∃ (hn : n < buffer.size cb), p c ∧ n' = n + 1 ∧ buffer.read cb ⟨n, hn⟩ = c
cb : char_buffer,	n n' : ℕ,	c : char,	p : char → Prop,	_inst_1 : decidable_pred p	⊢ sat p cb n = done n' c ↔ ∃ (hn : n < buffer.size cb), p c ∧ n' = n + 1 ∧ buffer.read cb ⟨n, hn⟩ = c
2 goals	cb : char_buffer,	n n' : ℕ,	c : char,	p : char → Prop,	_inst_1 : decidable_pred p,	hn : n < buffer.size cb	⊢ sat p cb n = done n' c ↔ ∃ (hn : n < buffer.size cb), p c ∧ n' = n + 1 ∧ buffer.read cb ⟨n, hn⟩ = c		cb : char_buffer,	n n' : ℕ,	c : char,	p : char → Prop,	_inst_1 : decidable_pred p,	hn : ¬n < buffer.size cb	⊢ sat p cb n = done n' c ↔ ∃ (hn : n < buffer.size cb), p c ∧ n' = n + 1 ∧ buffer.read cb ⟨n, hn⟩ = c
3 goals	cb : char_buffer,	n n' : ℕ,	c : char,	p : char → Prop,	_inst_1 : decidable_pred p,	hn : n < buffer.size cb,	hp : p (buffer.read cb ⟨n, hn⟩)	⊢ sat p cb n = done n' c ↔ ∃ (hn : n < buffer.size cb), p c ∧ n' = n + 1 ∧ buffer.read cb ⟨n, hn⟩ = c		cb : char_buffer,	n n' : ℕ,	c : char,	p : char → Prop,	_inst_1 : decidable_pred p,	hn : n < buffer.size cb,	hp : ¬p (buffer.read cb ⟨n, hn⟩)	⊢ sat p cb n = done n' c ↔ ∃ (hn : n < buffer.size cb), p c ∧ n' = n + 1 ∧ buffer.read cb ⟨n, hn⟩ = c		cb : char_buffer,	n n' : ℕ,	c : char,	p : char → Prop,	_inst_1 : decidable_pred p,	hn : ¬n < buffer.size cb	⊢ sat p cb n = done n' c ↔ ∃ (hn : n < buffer.size cb), p c ∧ n' = n + 1 ∧ buffer.read cb ⟨n, hn⟩ = c
3 goals	cb : char_buffer,	n n' : ℕ,	c : char,	p : char → Prop,	_inst_1 : decidable_pred p,	hn : n < buffer.size cb,	hp : p (buffer.read cb ⟨n, hn⟩)	⊢ n + 1 = n' ∧ buffer.read cb ⟨n, _⟩ = c ↔ p c ∧ n' = n + 1 ∧ buffer.read cb ⟨n, _⟩ = c		cb : char_buffer,	n n' : ℕ,	c : char,	p : char → Prop,	_inst_1 : decidable_pred p,	hn : n < buffer.size cb,	hp : ¬p (buffer.read cb ⟨n, hn⟩)	⊢ sat p cb n = done n' c ↔ ∃ (hn : n < buffer.size cb), p c ∧ n' = n + 1 ∧ buffer.read cb ⟨n, hn⟩ = c		cb : char_buffer,	n n' : ℕ,	c : char,	p : char → Prop,	_inst_1 : decidable_pred p,	hn : ¬n < buffer.size cb	⊢ sat p cb n = done n' c ↔ ∃ (hn : n < buffer.size cb), p c ∧ n' = n + 1 ∧ buffer.read cb ⟨n, hn⟩ = c
4 goals	cb : char_buffer,	n n' : ℕ,	c : char,	p : char → Prop,	_inst_1 : decidable_pred p,	hn : n < buffer.size cb,	hp : p (buffer.read cb ⟨n, hn⟩)	⊢ n + 1 = n' ∧ buffer.read cb ⟨n, _⟩ = c → p c ∧ n' = n + 1 ∧ buffer.read cb ⟨n, _⟩ = c		cb : char_buffer,	n n' : ℕ,	c : char,	p : char → Prop,	_inst_1 : decidable_pred p,	hn : n < buffer.size cb,	hp : p (buffer.read cb ⟨n, hn⟩)	⊢ p c ∧ n' = n + 1 ∧ buffer.read cb ⟨n, _⟩ = c → n + 1 = n' ∧ buffer.read cb ⟨n, _⟩ = c		cb : char_buffer,	n n' : ℕ,	c : char,	p : char → Prop,	_inst_1 : decidable_pred p,	hn : n < buffer.size cb,	hp : ¬p (buffer.read cb ⟨n, hn⟩)	⊢ sat p cb n = done n' c ↔ ∃ (hn : n < buffer.size cb), p c ∧ n' = n + 1 ∧ buffer.read cb ⟨n, hn⟩ = c		cb : char_buffer,	n n' : ℕ,	c : char,	p : char → Prop,	_inst_1 : decidable_pred p,	hn : ¬n < buffer.size cb	⊢ sat p cb n = done n' c ↔ ∃ (hn : n < buffer.size cb), p c ∧ n' = n + 1 ∧ buffer.read cb ⟨n, hn⟩ = c
4 goals	cb : char_buffer,	n : ℕ,	p : char → Prop,	_inst_1 : decidable_pred p,	hn : n < buffer.size cb,	hp : p (buffer.read cb ⟨n, hn⟩)	⊢ p (buffer.read cb ⟨n, _⟩) ∧ n + 1 = n + 1 ∧ buffer.read cb ⟨n, _⟩ = buffer.read cb ⟨n, _⟩		cb : char_buffer,	n n' : ℕ,	c : char,	p : char → Prop,	_inst_1 : decidable_pred p,	hn : n < buffer.size cb,	hp : p (buffer.read cb ⟨n, hn⟩)	⊢ p c ∧ n' = n + 1 ∧ buffer.read cb ⟨n, _⟩ = c → n + 1 = n' ∧ buffer.read cb ⟨n, _⟩ = c		cb : char_buffer,	n n' : ℕ,	c : char,	p : char → Prop,	_inst_1 : decidable_pred p,	hn : n < buffer.size cb,	hp : ¬p (buffer.read cb ⟨n, hn⟩)	⊢ sat p cb n = done n' c ↔ ∃ (hn : n < buffer.size cb), p c ∧ n' = n + 1 ∧ buffer.read cb ⟨n, hn⟩ = c		cb : char_buffer,	n n' : ℕ,	c : char,	p : char → Prop,	_inst_1 : decidable_pred p,	hn : ¬n < buffer.size cb	⊢ sat p cb n = done n' c ↔ ∃ (hn : n < buffer.size cb), p c ∧ n' = n + 1 ∧ buffer.read cb ⟨n, hn⟩ = c
3 goals	cb : char_buffer,	n n' : ℕ,	c : char,	p : char → Prop,	_inst_1 : decidable_pred p,	hn : n < buffer.size cb,	hp : p (buffer.read cb ⟨n, hn⟩)	⊢ p c ∧ n' = n + 1 ∧ buffer.read cb ⟨n, _⟩ = c → n + 1 = n' ∧ buffer.read cb ⟨n, _⟩ = c		cb : char_buffer,	n n' : ℕ,	c : char,	p : char → Prop,	_inst_1 : decidable_pred p,	hn : n < buffer.size cb,	hp : ¬p (buffer.read cb ⟨n, hn⟩)	⊢ sat p cb n = done n' c ↔ ∃ (hn : n < buffer.size cb), p c ∧ n' = n + 1 ∧ buffer.read cb ⟨n, hn⟩ = c		cb : char_buffer,	n n' : ℕ,	c : char,	p : char → Prop,	_inst_1 : decidable_pred p,	hn : ¬n < buffer.size cb	⊢ sat p cb n = done n' c ↔ ∃ (hn : n < buffer.size cb), p c ∧ n' = n + 1 ∧ buffer.read cb ⟨n, hn⟩ = c
3 goals	cb : char_buffer,	n : ℕ,	p : char → Prop,	_inst_1 : decidable_pred p,	hn : n < buffer.size cb,	hp : p (buffer.read cb ⟨n, hn⟩)	⊢ n + 1 = n + 1 ∧ buffer.read cb ⟨n, _⟩ = buffer.read cb ⟨n, _⟩		cb : char_buffer,	n n' : ℕ,	c : char,	p : char → Prop,	_inst_1 : decidable_pred p,	hn : n < buffer.size cb,	hp : ¬p (buffer.read cb ⟨n, hn⟩)	⊢ sat p cb n = done n' c ↔ ∃ (hn : n < buffer.size cb), p c ∧ n' = n + 1 ∧ buffer.read cb ⟨n, hn⟩ = c		cb : char_buffer,	n n' : ℕ,	c : char,	p : char → Prop,	_inst_1 : decidable_pred p,	hn : ¬n < buffer.size cb	⊢ sat p cb n = done n' c ↔ ∃ (hn : n < buffer.size cb), p c ∧ n' = n + 1 ∧ buffer.read cb ⟨n, hn⟩ = c
2 goals	cb : char_buffer,	n n' : ℕ,	c : char,	p : char → Prop,	_inst_1 : decidable_pred p,	hn : n < buffer.size cb,	hp : ¬p (buffer.read cb ⟨n, hn⟩)	⊢ sat p cb n = done n' c ↔ ∃ (hn : n < buffer.size cb), p c ∧ n' = n + 1 ∧ buffer.read cb ⟨n, hn⟩ = c		cb : char_buffer,	n n' : ℕ,	c : char,	p : char → Prop,	_inst_1 : decidable_pred p,	hn : ¬n < buffer.size cb	⊢ sat p cb n = done n' c ↔ ∃ (hn : n < buffer.size cb), p c ∧ n' = n + 1 ∧ buffer.read cb ⟨n, hn⟩ = c
2 goals	cb : char_buffer,	n n' : ℕ,	c : char,	p : char → Prop,	_inst_1 : decidable_pred p,	hn : n < buffer.size cb,	hp : ¬p (buffer.read cb ⟨n, hn⟩)	⊢ p c → n' = n + 1 → ¬buffer.read cb ⟨n, _⟩ = c		cb : char_buffer,	n n' : ℕ,	c : char,	p : char → Prop,	_inst_1 : decidable_pred p,	hn : ¬n < buffer.size cb	⊢ sat p cb n = done n' c ↔ ∃ (hn : n < buffer.size cb), p c ∧ n' = n + 1 ∧ buffer.read cb ⟨n, hn⟩ = c
2 goals	cb : char_buffer,	n n' : ℕ,	p : char → Prop,	_inst_1 : decidable_pred p,	hn : n < buffer.size cb,	hp : ¬p (buffer.read cb ⟨n, hn⟩),	H : p (buffer.read cb ⟨n, _⟩)	⊢ false		cb : char_buffer,	n n' : ℕ,	c : char,	p : char → Prop,	_inst_1 : decidable_pred p,	hn : ¬n < buffer.size cb	⊢ sat p cb n = done n' c ↔ ∃ (hn : n < buffer.size cb), p c ∧ n' = n + 1 ∧ buffer.read cb ⟨n, hn⟩ = c
cb : char_buffer,	n n' : ℕ,	c : char,	p : char → Prop,	_inst_1 : decidable_pred p,	hn : ¬n < buffer.size cb	⊢ sat p cb n = done n' c ↔ ∃ (hn : n < buffer.size cb), p c ∧ n' = n + 1 ∧ buffer.read cb ⟨n, hn⟩ = c
⊢ ∀ {cb : char_buffer} {n n' : ℕ} {u : unit} {s : string},	    str s cb n = done n' u ↔ n + s.length = n' ∧ s.to_list <+: list.drop n (buffer.to_list cb)
cb : char_buffer,	n n' : ℕ,	u : unit,	s : string	⊢ str s cb n = done n' u ↔ n + s.length = n' ∧ s.to_list <+: list.drop n (buffer.to_list cb)
⊢ ∀ (z : ℂ), ↑(z.im) = (z - ⇑(star_ring_end ℂ) z) / (2 * I)
z : ℂ	⊢ ↑(z.im) = (z - ⇑(star_ring_end ℂ) z) / (2 * I)
⊢ ∀ (x y : ℝ), sinh (x + y) = sinh x * cosh y + cosh x * sinh y
x y : ℝ	⊢ sinh (x + y) = sinh x * cosh y + cosh x * sinh y
x y : ℝ	⊢ ↑(sinh (x + y)) = ↑(sinh x * cosh y + cosh x * sinh y)
⊢ ∀ (x : ℝ), cosh (2 * x) = cosh x ^ 2 + sinh x ^ 2
x : ℝ	⊢ cosh (2 * x) = cosh x ^ 2 + sinh x ^ 2
x : ℝ	⊢ ↑(cosh (2 * x)) = ↑(cosh x ^ 2 + sinh x ^ 2)
⊢ ∀ (x : ℂ), sinh (2 * x) = 2 * sinh x * cosh x
x : ℂ	⊢ sinh (2 * x) = 2 * sinh x * cosh x
x : ℂ	⊢ sinh x * cosh x + cosh x * sinh x = 2 * sinh x * cosh x
⊢ ∀ (x y : ℂ), sin (x - y) = sin x * cos y - cos x * sin y
x y : ℂ	⊢ sin (x - y) = sin x * cos y - cos x * sin y
⊢ ∀ (x : ℝ), (sin ↑x).im = 0
x : ℝ	⊢ (sin ↑x).im = 0
⊢ ∀ (x : ℂ), cos (2 * x) = 2 * cos x ^ 2 - 1
x : ℂ	⊢ cos (2 * x) = 2 * cos x ^ 2 - 1
⊢ ∀ (x : ℂ), cos (3 * x) = 4 * cos x ^ 3 - 3 * cos x
x : ℂ	⊢ cos (3 * x) = 4 * cos x ^ 3 - 3 * cos x
2 goals	x : ℂ	⊢ x + 2 * x = 3 * x		x : ℂ,	h1 : x + 2 * x = 3 * x	⊢ cos (3 * x) = 4 * cos x ^ 3 - 3 * cos x
x : ℂ,	h1 : x + 2 * x = 3 * x	⊢ cos (3 * x) = 4 * cos x ^ 3 - 3 * cos x
x : ℂ,	h1 : x + 2 * x = 3 * x	⊢ cos x * cos (2 * x) - sin x * sin (2 * x) = 4 * cos x ^ 3 - 3 * cos x
x : ℂ,	h1 : x + 2 * x = 3 * x	⊢ cos x * (2 * (cos x * cos x)) - cos x - sin x * (2 * sin x * cos x) = 4 * cos x ^ 3 - 3 * cos x
2 goals	x : ℂ,	h1 : x + 2 * x = 3 * x	⊢ 4 * cos x ^ 3 = 2 * cos x * cos x * cos x + 2 * cos x * cos x ^ 2		x : ℂ,	h1 : x + 2 * x = 3 * x,	h2 : 4 * cos x ^ 3 = 2 * cos x * cos x * cos x + 2 * cos x * cos x ^ 2	⊢ cos x * (2 * (cos x * cos x)) - cos x - sin x * (2 * sin x * cos x) = 4 * cos x ^ 3 - 3 * cos x
x : ℂ,	h1 : x + 2 * x = 3 * x,	h2 : 4 * cos x ^ 3 = 2 * cos x * cos x * cos x + 2 * cos x * cos x ^ 2	⊢ cos x * (2 * (cos x * cos x)) - cos x - sin x * (2 * sin x * cos x) = 4 * cos x ^ 3 - 3 * cos x
x : ℂ,	h1 : x + 2 * x = 3 * x,	h2 : 4 * cos x ^ 3 = 2 * cos x * cos x * cos x + 2 * cos x * cos x ^ 2	⊢ cos x * (2 * (cos x * cos x)) - cos x - sin x * (2 * sin x * cos x) =	    2 * cos x * cos x * cos x + 2 * cos x * (1 - sin x ^ 2) - 3 * cos x
⊢ ∀ (x : ℝ), tan x = sin x / cos x
x : ℝ	⊢ tan x = sin x / cos x
⊢ ∀ {K : Type u_1} [_inst_1 : is_R_or_C K] (z : K), ⇑re (bit0 z) = bit0 (⇑re z)
K : Type u_1,	_inst_1 : is_R_or_C K,	z : K	⊢ ⇑re (bit0 z) = bit0 (⇑re z)
⊢ ∀ {K : Type u_1} [_inst_1 : is_R_or_C K] (r : ℝ), ↑(bit1 r) = bit1 ↑r
K : Type u_1,	_inst_1 : is_R_or_C K,	r : ℝ	⊢ ↑(bit1 r) = bit1 ↑r
⊢ ∀ {K : Type u_1} [_inst_1 : is_R_or_C K] (z : K), ⇑(star_ring_end K) (bit0 z) = bit0 (⇑(star_ring_end K) z)
K : Type u_1,	_inst_1 : is_R_or_C K,	z : K	⊢ ⇑(star_ring_end K) (bit0 z) = bit0 (⇑(star_ring_end K) z)
⊢ ∀ {K : Type u_1} [_inst_1 : is_R_or_C K] (r : ℝ) (z : K),	    ⇑(star_ring_end K) (r • z) = r • ⇑(star_ring_end K) z
K : Type u_1,	_inst_1 : is_R_or_C K,	r : ℝ,	z : K	⊢ ⇑(star_ring_end K) (r • z) = r • ⇑(star_ring_end K) z
K : Type u_1,	_inst_1 : is_R_or_C K,	r : ℝ,	z : K	⊢ ↑(⇑re (r • z)) - ↑(⇑im (r • z)) * I = r • (↑(⇑re z) - ↑(⇑im z) * I)
K : Type u_1,	_inst_1 : is_R_or_C K,	r : ℝ,	z : K	⊢ ↑r * ↑(⇑re z) - ↑r * ↑(⇑im z) * I = r • (↑(⇑re z) - ↑(⇑im z) * I)
K : Type u_1,	_inst_1 : is_R_or_C K,	r : ℝ,	z : K	⊢ ↑r * ↑(⇑re z) - ↑r * ↑(⇑im z) * I = r • ↑(⇑re z) - r • (↑(⇑im z) * I)
K : Type u_1,	_inst_1 : is_R_or_C K,	r : ℝ,	z : K	⊢ r • 1 * ⇑re z • 1 - r • 1 * ⇑im z • 1 * I = r • ⇑re z • 1 - r • (⇑im z • 1 * I)
⊢ ∀ {K : Type u_1} [_inst_1 : is_R_or_C K] (z : K), z / I = -(z * I)
K : Type u_1,	_inst_1 : is_R_or_C K,	z : K	⊢ z / I = -(z * I)
2 goals	K : Type u_1,	_inst_1 : is_R_or_C K,	z : K,	h : I = 0	⊢ z / I = -(z * I)		K : Type u_1,	_inst_1 : is_R_or_C K,	z : K,	h : ¬I = 0	⊢ z / I = -(z * I)
K : Type u_1,	_inst_1 : is_R_or_C K,	z : K,	h : ¬I = 0	⊢ z / I = -(z * I)
⊢ ∀ {K : Type u_1} [_inst_1 : is_R_or_C K] {z : K}, ∥⇑(star_ring_end K) z∥ = ∥z∥
K : Type u_1,	_inst_1 : is_R_or_C K,	z : K	⊢ ∥⇑(star_ring_end K) z∥ = ∥z∥
⊢ ∀ {K : Type u_1} [_inst_1 : is_R_or_C K] (q : ℚ), ⇑re ↑q = ↑q
K : Type u_1,	_inst_1 : is_R_or_C K,	q : ℚ	⊢ ⇑re ↑q = ↑q
⊢ ∀ {ι : Type u} {γ : Type w} {β : ι → Type v} [dec : decidable_eq ι]	  [_inst_1 : Π (i : ι), add_zero_class (β i)] [_inst_2 : add_comm_monoid γ] (f : Π (i : ι), β i →+ γ)	  (i : ι), (⇑lift_add_hom f).comp (single_add_hom β i) = f i
ι : Type u,	γ : Type w,	β : ι → Type v,	dec : decidable_eq ι,	_inst_1 : Π (i : ι), add_zero_class (β i),	_inst_2 : add_comm_monoid γ,	f : Π (i : ι), β i →+ γ,	i : ι	⊢ (⇑lift_add_hom f).comp (single_add_hom β i) = f i
⊢ ∀ {ι : Type u} {β : ι → Type v} [dec : decidable_eq ι] [_inst_1 : Π (i : ι), has_zero (β i)]	  [_inst_2 : Π (i : ι) (x : β i), decidable (x ≠ 0)] {i : ι} {b : β i}, b ≠ 0 → (single i b).support = {i}
ι : Type u,	β : ι → Type v,	dec : decidable_eq ι,	_inst_1 : Π (i : ι), has_zero (β i),	_inst_2 : Π (i : ι) (x : β i), decidable (x ≠ 0),	i : ι,	b : β i,	hb : b ≠ 0	⊢ (single i b).support = {i}
ι : Type u,	β : ι → Type v,	dec : decidable_eq ι,	_inst_1 : Π (i : ι), has_zero (β i),	_inst_2 : Π (i : ι) (x : β i), decidable (x ≠ 0),	i : ι,	b : β i,	hb : b ≠ 0,	j : ι	⊢ j ∈ (single i b).support ↔ j ∈ {i}
2 goals	ι : Type u,	β : ι → Type v,	dec : decidable_eq ι,	_inst_1 : Π (i : ι), has_zero (β i),	_inst_2 : Π (i : ι) (x : β i), decidable (x ≠ 0),	i : ι,	b : β i,	hb : b ≠ 0,	j : ι,	h : i = j	⊢ j ∈ (single i b).support ↔ j ∈ {i}		ι : Type u,	β : ι → Type v,	dec : decidable_eq ι,	_inst_1 : Π (i : ι), has_zero (β i),	_inst_2 : Π (i : ι) (x : β i), decidable (x ≠ 0),	i : ι,	b : β i,	hb : b ≠ 0,	j : ι,	h : ¬i = j	⊢ j ∈ (single i b).support ↔ j ∈ {i}
2 goals	ι : Type u,	β : ι → Type v,	dec : decidable_eq ι,	_inst_1 : Π (i : ι), has_zero (β i),	_inst_2 : Π (i : ι) (x : β i), decidable (x ≠ 0),	i : ι,	b : β i,	hb : b ≠ 0	⊢ i ∈ (single i b).support ↔ i ∈ {i}		ι : Type u,	β : ι → Type v,	dec : decidable_eq ι,	_inst_1 : Π (i : ι), has_zero (β i),	_inst_2 : Π (i : ι) (x : β i), decidable (x ≠ 0),	i : ι,	b : β i,	hb : b ≠ 0,	j : ι,	h : ¬i = j	⊢ j ∈ (single i b).support ↔ j ∈ {i}
ι : Type u,	β : ι → Type v,	dec : decidable_eq ι,	_inst_1 : Π (i : ι), has_zero (β i),	_inst_2 : Π (i : ι) (x : β i), decidable (x ≠ 0),	i : ι,	b : β i,	hb : b ≠ 0,	j : ι,	h : ¬i = j	⊢ j ∈ (single i b).support ↔ j ∈ {i}
⊢ ∀ {α₁ : Type u_1} {β₁ : Type u_2} [_inst_1 : decidable_eq α₁] {e : perm β₁} {a a' : α₁}	  {b : β₁}, ⇑(perm.prod_extend_right a e) (a', b) ≠ (a', b) → a' = a
α₁ : Type u_1,	β₁ : Type u_2,	_inst_1 : decidable_eq α₁,	e : perm β₁,	a a' : α₁,	b : β₁,	h : ⇑(perm.prod_extend_right a e) (a', b) ≠ (a', b)	⊢ a' = a
α₁ : Type u_1,	β₁ : Type u_2,	_inst_1 : decidable_eq α₁,	e : perm β₁,	a a' : α₁,	b : β₁,	h : a' ≠ a	⊢ ⇑(perm.prod_extend_right a e) (a', b) = (a', b)
⊢ ∀ {α : Type u_1} {β : Type u_2} {f : α → β} (hf : injective f) (u s : set α),	    (λ (x : ↥(f '' s)), ↑(⇑((set.image f s hf).symm) x)) ⁻¹' u = coe ⁻¹' (f '' u)
α : Type u_1,	β : Type u_2,	f : α → β,	hf : injective f,	u s : set α	⊢ (λ (x : ↥(f '' s)), ↑(⇑((set.image f s hf).symm) x)) ⁻¹' u = coe ⁻¹' (f '' u)
α : Type u_1,	β : Type u_2,	f : α → β,	hf : injective f,	u s : set α,	a : α,	has : a ∈ s	⊢ ⟨f a, _⟩ ∈ (λ (x : ↥(f '' s)), ↑(⇑((set.image f s hf).symm) x)) ⁻¹' u ↔	    ⟨f a, _⟩ ∈ coe ⁻¹' (f '' u)
α : Type u_1,	β : Type u_2,	f : α → β,	hf : injective f,	u s : set α,	a : α,	has : a ∈ s,	this : ∀ (h : ∃ (a' : α), a' ∈ s ∧ a' = a), classical.some h = a	⊢ ⟨f a, _⟩ ∈ (λ (x : ↥(f '' s)), ↑(⇑((set.image f s hf).symm) x)) ⁻¹' u ↔	    ⟨f a, _⟩ ∈ coe ⁻¹' (f '' u)
⊢ ∀ {α : Type u_1} {β : Type u_2} (f : α → β) (f_inv : β → α) (hf : left_inverse f_inv f),	    of_left_inverse' f f_inv hf = of_injective f _
α : Type u_1,	β : Type u_2,	f : α → β,	f_inv : β → α,	hf : left_inverse f_inv f	⊢ of_left_inverse' f f_inv hf = of_injective f _
α : Type u_1,	β : Type u_2,	f : α → β,	f_inv : β → α,	hf : left_inverse f_inv f,	x : α	⊢ ↑(⇑(of_left_inverse' f f_inv hf) x) = ↑(⇑(of_injective f _) x)
⊢ ∀ {α : Sort u} [_inst_1 : decidable_eq α] (i j a : α), ⇑(swap i j) (⇑(swap i j) a) = a
α : Sort u,	_inst_1 : decidable_eq α,	i j a : α	⊢ ⇑(swap i j) (⇑(swap i j) a) = a
⊢ ∀ {n : ℕ}, ⇑(fin_rotate (n + 1)) ⟨n, _⟩ = ⟨0, _⟩
n : ℕ	⊢ ⇑(fin_rotate (n + 1)) ⟨n, _⟩ = ⟨0, _⟩
n : ℕ	⊢ ⇑(fin_congr _) (⇑fin_add_flip ⟨n, _⟩) = 0
2 goals	n : ℕ	⊢ ⇑(fin_congr _) ⟨n - n, _⟩ = 0		n : ℕ	⊢ n ≤ n
⊢ ∀ {n : ℕ} {α : Type u_1} (v : fin n → α) (a : α),	    fin.snoc v a = λ (i : fin (n + 1)), fin.cons a v (⇑(fin_rotate (n + 1)) i)
n : ℕ,	α : Type u_1,	v : fin n → α,	a : α	⊢ fin.snoc v a = λ (i : fin (n + 1)), fin.cons a v (⇑(fin_rotate (n + 1)) i)
n : ℕ,	α : Type u_1,	v : fin n → α,	a : α,	i : ℕ,	h : i < n + 1	⊢ fin.snoc v a ⟨i, h⟩ = fin.cons a v (⇑(fin_rotate (n + 1)) ⟨i, h⟩)
2 goals	n : ℕ,	α : Type u_1,	v : fin n → α,	a : α,	i : ℕ,	h : i < n + 1,	h' : i < n	⊢ fin.snoc v a ⟨i, h⟩ = fin.cons a v (⇑(fin_rotate (n + 1)) ⟨i, h⟩)		n : ℕ,	α : Type u_1,	v : fin n → α,	a : α,	i : ℕ,	h : i < n + 1,	h' : ¬i < n	⊢ fin.snoc v a ⟨i, h⟩ = fin.cons a v (⇑(fin_rotate (n + 1)) ⟨i, h⟩)
2 goals	n : ℕ,	α : Type u_1,	v : fin n → α,	a : α,	i : ℕ,	h : i < n + 1,	h' : i < n	⊢ cast _ (v (fin.cast_lt ⟨i, h⟩ h')) = (λ (j : fin (n + 1)), fin.cases a v j) ⟨i + 1, _⟩		n : ℕ,	α : Type u_1,	v : fin n → α,	a : α,	i : ℕ,	h : i < n + 1,	h' : ¬i < n	⊢ fin.snoc v a ⟨i, h⟩ = fin.cons a v (⇑(fin_rotate (n + 1)) ⟨i, h⟩)
n : ℕ,	α : Type u_1,	v : fin n → α,	a : α,	i : ℕ,	h : i < n + 1,	h' : ¬i < n	⊢ fin.snoc v a ⟨i, h⟩ = fin.cons a v (⇑(fin_rotate (n + 1)) ⟨i, h⟩)
2 goals	n : ℕ,	α : Type u_1,	v : fin n → α,	a : α,	i : ℕ,	h : i < n + 1,	h' : ¬i < n	⊢ n = i		n : ℕ,	α : Type u_1,	v : fin n → α,	a : α,	i : ℕ,	h : i < n + 1,	h' : ¬i < n,	h'' : n = i	⊢ fin.snoc v a ⟨i, h⟩ = fin.cons a v (⇑(fin_rotate (n + 1)) ⟨i, h⟩)
2 goals	n : ℕ,	α : Type u_1,	v : fin n → α,	a : α,	i : ℕ,	h : i < n + 1,	h' : n ≤ i	⊢ n = i		n : ℕ,	α : Type u_1,	v : fin n → α,	a : α,	i : ℕ,	h : i < n + 1,	h' : ¬i < n,	h'' : n = i	⊢ fin.snoc v a ⟨i, h⟩ = fin.cons a v (⇑(fin_rotate (n + 1)) ⟨i, h⟩)
n : ℕ,	α : Type u_1,	v : fin n → α,	a : α,	i : ℕ,	h : i < n + 1,	h' : ¬i < n,	h'' : n = i	⊢ fin.snoc v a ⟨i, h⟩ = fin.cons a v (⇑(fin_rotate (n + 1)) ⟨i, h⟩)
n : ℕ,	α : Type u_1,	v : fin n → α,	a : α,	h : n < n + 1,	h' : ¬n < n	⊢ fin.snoc v a ⟨n, h⟩ = fin.cons a v (⇑(fin_rotate (n + 1)) ⟨n, h⟩)
n : ℕ,	α : Type u_1,	v : fin n → α,	a : α,	h : n < n + 1,	h' : ¬n < n	⊢ cast _ a = (λ (j : fin (n + 1)), fin.cases a v j) ⟨0, _⟩
⊢ ∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {e e' : local_equiv α β} {f f' : local_equiv β γ},	    e ≈ e' → f ≈ f' → e.trans f ≈ e'.trans f'
α : Type u_1,	β : Type u_2,	γ : Type u_3,	e e' : local_equiv α β,	f f' : local_equiv β γ,	he : e ≈ e',	hf : f ≈ f'	⊢ e.trans f ≈ e'.trans f'
2 goals	α : Type u_1,	β : Type u_2,	γ : Type u_3,	e e' : local_equiv α β,	f f' : local_equiv β γ,	he : e ≈ e',	hf : f ≈ f'	⊢ (e.trans f).source = (e'.trans f').source		α : Type u_1,	β : Type u_2,	γ : Type u_3,	e e' : local_equiv α β,	f f' : local_equiv β γ,	he : e ≈ e',	hf : f ≈ f'	⊢ eq_on ⇑(e.trans f) ⇑(e'.trans f') (e.trans f).source
2 goals	α : Type u_1,	β : Type u_2,	γ : Type u_3,	e e' : local_equiv α β,	f f' : local_equiv β γ,	he : e ≈ e',	hf : f ≈ f'	⊢ ⇑(e.symm) '' (e.target ∩ f.source) = ⇑(e'.symm) '' (e.target ∩ f.source)		α : Type u_1,	β : Type u_2,	γ : Type u_3,	e e' : local_equiv α β,	f f' : local_equiv β γ,	he : e ≈ e',	hf : f ≈ f'	⊢ eq_on ⇑(e.trans f) ⇑(e'.trans f') (e.trans f).source
α : Type u_1,	β : Type u_2,	γ : Type u_3,	e e' : local_equiv α β,	f f' : local_equiv β γ,	he : e ≈ e',	hf : f ≈ f'	⊢ eq_on ⇑(e.trans f) ⇑(e'.trans f') (e.trans f).source
α : Type u_1,	β : Type u_2,	γ : Type u_3,	e e' : local_equiv α β,	f f' : local_equiv β γ,	he : e ≈ e',	hf : f ≈ f',	x : α,	hx : x ∈ (e.trans f).source	⊢ ⇑(e.trans f) x = ⇑(e'.trans f') x
α : Type u_1,	β : Type u_2,	γ : Type u_3,	e e' : local_equiv α β,	f f' : local_equiv β γ,	he : e ≈ e',	hf : f ≈ f',	x : α,	hx : x ∈ e.source ∩ ⇑e ⁻¹' f.source	⊢ ⇑(e.trans f) x = ⇑(e'.trans f') x
⊢ ∀ {α : Type u_1} {β : Type u_2} {e e' : local_equiv α β},	    e ≈ e' → ∀ (s : set β), e.source ∩ ⇑e ⁻¹' s = e'.source ∩ ⇑e' ⁻¹' s
α : Type u_1,	β : Type u_2,	e e' : local_equiv α β,	he : e ≈ e',	s : set β	⊢ e.source ∩ ⇑e ⁻¹' s = e'.source ∩ ⇑e' ⁻¹' s
⊢ ∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {δ : Type u_4} {η : Type u_5} {ε : Type u_6}	  (e : local_equiv α β) (f : local_equiv β γ) (e' : local_equiv δ η) (f' : local_equiv η ε),	    (e.prod e').trans (f.prod f') = (e.trans f).prod (e'.trans f')
α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	η : Type u_5,	ε : Type u_6,	e : local_equiv α β,	f : local_equiv β γ,	e' : local_equiv δ η,	f' : local_equiv η ε	⊢ (e.prod e').trans (f.prod f') = (e.trans f).prod (e'.trans f')
4 goals	α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	η : Type u_5,	ε : Type u_6,	e : local_equiv α β,	f : local_equiv β γ,	e' : local_equiv δ η,	f' : local_equiv η ε,	x : α × δ	⊢ (⇑((e.prod e').trans (f.prod f')) x).fst = (⇑((e.trans f).prod (e'.trans f')) x).fst		α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	η : Type u_5,	ε : Type u_6,	e : local_equiv α β,	f : local_equiv β γ,	e' : local_equiv δ η,	f' : local_equiv η ε,	x : α × δ	⊢ (⇑((e.prod e').trans (f.prod f')) x).snd = (⇑((e.trans f).prod (e'.trans f')) x).snd		α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	η : Type u_5,	ε : Type u_6,	e : local_equiv α β,	f : local_equiv β γ,	e' : local_equiv δ η,	f' : local_equiv η ε	⊢ ∀ (x : γ × ε), ⇑(((e.prod e').trans (f.prod f')).symm) x = ⇑(((e.trans f).prod (e'.trans f')).symm) x		α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	η : Type u_5,	ε : Type u_6,	e : local_equiv α β,	f : local_equiv β γ,	e' : local_equiv δ η,	f' : local_equiv η ε	⊢ ((e.prod e').trans (f.prod f')).source = ((e.trans f).prod (e'.trans f')).source
3 goals	α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	η : Type u_5,	ε : Type u_6,	e : local_equiv α β,	f : local_equiv β γ,	e' : local_equiv δ η,	f' : local_equiv η ε,	x : α × δ	⊢ (⇑((e.prod e').trans (f.prod f')) x).snd = (⇑((e.trans f).prod (e'.trans f')) x).snd		α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	η : Type u_5,	ε : Type u_6,	e : local_equiv α β,	f : local_equiv β γ,	e' : local_equiv δ η,	f' : local_equiv η ε	⊢ ∀ (x : γ × ε), ⇑(((e.prod e').trans (f.prod f')).symm) x = ⇑(((e.trans f).prod (e'.trans f')).symm) x		α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	η : Type u_5,	ε : Type u_6,	e : local_equiv α β,	f : local_equiv β γ,	e' : local_equiv δ η,	f' : local_equiv η ε	⊢ ((e.prod e').trans (f.prod f')).source = ((e.trans f).prod (e'.trans f')).source
2 goals	α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	η : Type u_5,	ε : Type u_6,	e : local_equiv α β,	f : local_equiv β γ,	e' : local_equiv δ η,	f' : local_equiv η ε	⊢ ∀ (x : γ × ε), ⇑(((e.prod e').trans (f.prod f')).symm) x = ⇑(((e.trans f).prod (e'.trans f')).symm) x		α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	η : Type u_5,	ε : Type u_6,	e : local_equiv α β,	f : local_equiv β γ,	e' : local_equiv δ η,	f' : local_equiv η ε	⊢ ((e.prod e').trans (f.prod f')).source = ((e.trans f).prod (e'.trans f')).source
α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	η : Type u_5,	ε : Type u_6,	e : local_equiv α β,	f : local_equiv β γ,	e' : local_equiv δ η,	f' : local_equiv η ε	⊢ ((e.prod e').trans (f.prod f')).source = ((e.trans f).prod (e'.trans f')).source
α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	η : Type u_5,	ε : Type u_6,	e : local_equiv α β,	f : local_equiv β γ,	e' : local_equiv δ η,	f' : local_equiv η ε	⊢ ∀ (a : α) (b : δ),	    (a ∈ e.source ∧ b ∈ e'.source) ∧ ⇑e a ∈ f.source ∧ ⇑e' b ∈ f'.source ↔	      (a ∈ e.source ∧ ⇑e a ∈ f.source) ∧ b ∈ e'.source ∧ ⇑e' b ∈ f'.source
⊢ ∀ {R : Type u_1} {S : Type u_2} [_inst_1 : non_assoc_semiring R] [_inst_2 : non_assoc_semiring S] (e : R ≃+* S),	    e.symm.to_ring_hom.comp e.to_ring_hom = ring_hom.id R
R : Type u_1,	S : Type u_2,	_inst_1 : non_assoc_semiring R,	_inst_2 : non_assoc_semiring S,	e : R ≃+* S	⊢ e.symm.to_ring_hom.comp e.to_ring_hom = ring_hom.id R
R : Type u_1,	S : Type u_2,	_inst_1 : non_assoc_semiring R,	_inst_2 : non_assoc_semiring S,	e : R ≃+* S,	x : R	⊢ ⇑(e.symm.to_ring_hom.comp e.to_ring_hom) x = ⇑(ring_hom.id R) x
⊢ ∀ {n : ℕ} {α : fin (n + 1) → Type u} (x : α (last n)) (p : Π (i : fin n), α (⇑cast_succ i)),	    snoc p x (last n) = x
n : ℕ,	α : fin (n + 1) → Type u,	x : α (last n),	p : Π (i : fin n), α (⇑cast_succ i)	⊢ snoc p x (last n) = x
⊢ ∀ {n : ℕ} {α : fin (n + 1) → Type u} (q : Π (i : fin (n + 1)), α i) (i : fin n) (y : α (⇑cast_succ i)),	    init (update q (⇑cast_succ i) y) = update (init q) i y
n : ℕ,	α : fin (n + 1) → Type u,	q : Π (i : fin (n + 1)), α i,	i : fin n,	y : α (⇑cast_succ i)	⊢ init (update q (⇑cast_succ i) y) = update (init q) i y
n : ℕ,	α : fin (n + 1) → Type u,	q : Π (i : fin (n + 1)), α i,	i : fin n,	y : α (⇑cast_succ i),	j : fin n	⊢ init (update q (⇑cast_succ i) y) j = update (init q) i y j
2 goals	n : ℕ,	α : fin (n + 1) → Type u,	q : Π (i : fin (n + 1)), α i,	i : fin n,	y : α (⇑cast_succ i),	j : fin n,	h : j = i	⊢ init (update q (⇑cast_succ i) y) j = update (init q) i y j		n : ℕ,	α : fin (n + 1) → Type u,	q : Π (i : fin (n + 1)), α i,	i : fin n,	y : α (⇑cast_succ i),	j : fin n,	h : ¬j = i	⊢ init (update q (⇑cast_succ i) y) j = update (init q) i y j
2 goals	n : ℕ,	α : fin (n + 1) → Type u,	q : Π (i : fin (n + 1)), α i,	i : fin n,	y : α (⇑cast_succ i),	j : fin n,	h : j = i	⊢ init (update q (⇑cast_succ i) y) i = update (init q) i y i		n : ℕ,	α : fin (n + 1) → Type u,	q : Π (i : fin (n + 1)), α i,	i : fin n,	y : α (⇑cast_succ i),	j : fin n,	h : ¬j = i	⊢ init (update q (⇑cast_succ i) y) j = update (init q) i y j
n : ℕ,	α : fin (n + 1) → Type u,	q : Π (i : fin (n + 1)), α i,	i : fin n,	y : α (⇑cast_succ i),	j : fin n,	h : ¬j = i	⊢ init (update q (⇑cast_succ i) y) j = update (init q) i y j
⊢ ∀ {n m : ℕ} (h : n.succ ≤ m.succ), ⇑(cast_le h) 0 = 0
n m : ℕ,	h : n.succ ≤ m.succ	⊢ ⇑(cast_le h) 0 = 0
⊢ ∀ {n : ℕ} (j : fin (n + 1)) (h : j ≠ 0), ↑(j.pred h) = ↑j - 1
n : ℕ,	j : fin (n + 1),	h : j ≠ 0	⊢ ↑(j.pred h) = ↑j - 1
n j_val : ℕ,	j_property : j_val < n + 1,	h : ⟨j_val, j_property⟩ ≠ 0	⊢ ↑(pred ⟨j_val, j_property⟩ h) = ↑⟨j_val, j_property⟩ - 1
⊢ ∀ {α : Type u_1} [_inst_1 : decidable_eq α] (s : finset α), s.val.to_finset = s
α : Type u_1,	_inst_1 : decidable_eq α,	s : finset α	⊢ s.val.to_finset = s
α : Type u_1,	_inst_1 : decidable_eq α,	s : finset α,	a : α	⊢ a ∈ s.val.to_finset ↔ a ∈ s
⊢ ∀ {α : Type u_1} [_inst_1 : decidable_eq α], surjective to_finset
α : Type u_1,	_inst_1 : decidable_eq α	⊢ surjective to_finset
α : Type u_1,	_inst_1 : decidable_eq α,	s : finset α	⊢ ∃ (a : list α), a.to_finset = s
α : Type u_1,	_inst_1 : decidable_eq α,	s : finset α,	l : list α,	hls : l.to_finset = s	⊢ ∃ (a : list α), a.to_finset = s
⊢ ∀ {α : Type u_1} {s : finset α}, 1 < s.card ↔ ∃ (a : α) (H : a ∈ s) (b : α) (H : b ∈ s), a ≠ b
α : Type u_1,	s : finset α	⊢ 1 < s.card ↔ ∃ (a : α) (H : a ∈ s) (b : α) (H : b ∈ s), a ≠ b
α : Type u_1,	s : finset α	⊢ ¬1 < s.card ↔ ¬∃ (a : α) (H : a ∈ s) (b : α) (H : b ∈ s), a ≠ b
α : Type u_1,	s : finset α	⊢ s.card ≤ 1 ↔ ∀ (a : α), a ∈ s → ∀ (b : α), b ∈ s → a = b
⊢ ∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [_inst_1 : decidable_eq β] [_inst_2 : decidable_eq γ]	  (s : finset α) (f : α → finset β) (g : β → finset γ),	    (s.bUnion f).bUnion g = s.bUnion (λ (a : α), (f a).bUnion g)
α : Type u_1,	β : Type u_2,	γ : Type u_3,	_inst_1 : decidable_eq β,	_inst_2 : decidable_eq γ,	s : finset α,	f : α → finset β,	g : β → finset γ	⊢ (s.bUnion f).bUnion g = s.bUnion (λ (a : α), (f a).bUnion g)
α : Type u_1,	β : Type u_2,	γ : Type u_3,	_inst_1 : decidable_eq β,	_inst_2 : decidable_eq γ,	s : finset α,	f : α → finset β,	g : β → finset γ,	a : γ	⊢ a ∈ (s.bUnion f).bUnion g ↔ a ∈ s.bUnion (λ (a : α), (f a).bUnion g)
α : Type u_1,	β : Type u_2,	γ : Type u_3,	_inst_1 : decidable_eq β,	_inst_2 : decidable_eq γ,	s : finset α,	f : α → finset β,	g : β → finset γ,	a : γ	⊢ (∃ (a_1 : β), (∃ (a : α), a ∈ s ∧ a_1 ∈ f a) ∧ a ∈ g a_1) ↔	    ∃ (a_1 : α), a_1 ∈ s ∧ ∃ (a_2 : β), a_2 ∈ f a_1 ∧ a ∈ g a_2
α : Type u_1,	β : Type u_2,	γ : Type u_3,	_inst_1 : decidable_eq β,	_inst_2 : decidable_eq γ,	s : finset α,	f : α → finset β,	g : β → finset γ,	a : γ	⊢ (∃ (a_1 : β) (x : α), x ∈ s ∧ a_1 ∈ f x ∧ a ∈ g a_1) ↔	    ∃ (a_1 : α) (x : β), a_1 ∈ s ∧ x ∈ f a_1 ∧ a ∈ g x
⊢ ∀ {α : Type u_1} [_inst_1 : decidable_eq α] {a : α} {s : finset α},	    a ∉ s → (insert a s).val = a ::ₘ s.val
α : Type u_1,	_inst_1 : decidable_eq α,	a : α,	s : finset α,	h : a ∉ s	⊢ (insert a s).val = a ::ₘ s.val
⊢ ∀ {α : Type u_1} {n : ℕ} {s : finset α}, n < s.card → (powerset_len n s).nonempty
α : Type u_1,	n : ℕ,	s : finset α,	h : n < s.card	⊢ (powerset_len n s).nonempty
α : Type u_1,	n : ℕ,	s : finset α,	h : n < s.card,	_inst : Π (a : Prop), decidable a	⊢ (powerset_len n s).nonempty
2 goals	case h₁	α : Type u_1,	_inst : Π (a : Prop), decidable a,	n : ℕ,	h : n < ∅.card	⊢ (powerset_len n ∅).nonempty		case h₂	α : Type u_1,	_inst : Π (a : Prop), decidable a,	x : α,	s : finset α,	hx : x ∉ s,	IH : ∀ {n : ℕ}, n < s.card → (powerset_len n s).nonempty,	n : ℕ,	h : n < (insert x s).card	⊢ (powerset_len n (insert x s)).nonempty
case h₂	α : Type u_1,	_inst : Π (a : Prop), decidable a,	x : α,	s : finset α,	hx : x ∉ s,	IH : ∀ {n : ℕ}, n < s.card → (powerset_len n s).nonempty,	n : ℕ,	h : n < (insert x s).card	⊢ (powerset_len n (insert x s)).nonempty
2 goals	case h₂, nat.zero	α : Type u_1,	_inst : Π (a : Prop), decidable a,	x : α,	s : finset α,	hx : x ∉ s,	IH : ∀ {n : ℕ}, n < s.card → (powerset_len n s).nonempty,	h : 0 < (insert x s).card	⊢ (powerset_len 0 (insert x s)).nonempty		case h₂, nat.succ	α : Type u_1,	_inst : Π (a : Prop), decidable a,	x : α,	s : finset α,	hx : x ∉ s,	IH : ∀ {n : ℕ}, n < s.card → (powerset_len n s).nonempty,	n : ℕ,	h : n.succ < (insert x s).card	⊢ (powerset_len n.succ (insert x s)).nonempty
case h₂, nat.succ	α : Type u_1,	_inst : Π (a : Prop), decidable a,	x : α,	s : finset α,	hx : x ∉ s,	IH : ∀ {n : ℕ}, n < s.card → (powerset_len n s).nonempty,	n : ℕ,	h : n.succ < (insert x s).card	⊢ (powerset_len n.succ (insert x s)).nonempty
case h₂, nat.succ	α : Type u_1,	_inst : Π (a : Prop), decidable a,	x : α,	s : finset α,	hx : x ∉ s,	IH : ∀ {n : ℕ}, n < s.card → (powerset_len n s).nonempty,	n : ℕ,	h : n < s.card	⊢ (powerset_len n.succ (insert x s)).nonempty
case h₂, nat.succ	α : Type u_1,	_inst : Π (a : Prop), decidable a,	x : α,	s : finset α,	hx : x ∉ s,	IH : ∀ {n : ℕ}, n < s.card → (powerset_len n s).nonempty,	n : ℕ,	h : n < s.card	⊢ (powerset_len n.succ s ∪ image (insert x) (powerset_len n s)).nonempty
α : Type u_1,	_inst : Π (a : Prop), decidable a,	x : α,	s : finset α,	hx : x ∉ s,	IH : ∀ {n : ℕ}, n < s.card → (powerset_len n s).nonempty,	n : ℕ,	h : n < s.card	⊢ image (insert x) (powerset_len n s) ⊆ powerset_len n.succ s ∪ image (insert x) (powerset_len n s)
⊢ ∀ {α : Type u_1} {M : Type u_5} [_inst_1 : has_zero M] {f : α →₀ M}, f.support.nonempty ↔ f ≠ 0
α : Type u_1,	M : Type u_5,	_inst_1 : has_zero M,	f : α →₀ M	⊢ f.support.nonempty ↔ f ≠ 0
⊢ ∀ {ι : Type u_3} (m n : ι →₀ ℕ), m < n → m.sum (λ (_x : ι), id) < n.sum (λ (_x : ι), id)
ι : Type u_3,	m n : ι →₀ ℕ,	h : m < n	⊢ m.sum (λ (_x : ι), id) < n.sum (λ (_x : ι), id)
ι : Type u_3,	m n : ι →₀ ℕ,	h : m < n	⊢ ⇑multiset.card (⇑to_multiset m) < ⇑multiset.card (⇑to_multiset n)
ι : Type u_3,	m n : ι →₀ ℕ,	h : m < n	⊢ ⇑to_multiset m < ⇑to_multiset n
⊢ ∀ {α : Type u_1} {M : Type u_5} {N : Type u_7} [_inst_1 : has_zero M] [_inst_3 : comm_monoid N]	  [_inst_4 : decidable_eq α] (f : α →₀ M) (a : α) (b : α → M → N),	    f.prod (λ (x : α) (v : M), ite (a = x) (b x v) 1) = ite (a ∈ f.support) (b a (⇑f a)) 1
α : Type u_1,	M : Type u_5,	N : Type u_7,	_inst_1 : has_zero M,	_inst_3 : comm_monoid N,	_inst_4 : decidable_eq α,	f : α →₀ M,	a : α,	b : α → M → N	⊢ f.prod (λ (x : α) (v : M), ite (a = x) (b x v) 1) = ite (a ∈ f.support) (b a (⇑f a)) 1
α : Type u_1,	M : Type u_5,	N : Type u_7,	_inst_1 : has_zero M,	_inst_3 : comm_monoid N,	_inst_4 : decidable_eq α,	f : α →₀ M,	a : α,	b : α → M → N	⊢ f.support.prod (λ (a_1 : α), ite (a = a_1) (b a_1 (⇑f a_1)) 1) = ite (a ∈ f.support) (b a (⇑f a)) 1
⊢ ∀ {ι : Type u_1} {η : ι → Type u_4} {N : Type u_5} [_inst_2 : has_zero N] (f : (Σ (i : ι), η i) →₀ N),	    (⇑sigma_finsupp_equiv_dfinsupp f).support = f.split_support
ι : Type u_1,	η : ι → Type u_4,	N : Type u_5,	_inst_2 : has_zero N,	f : (Σ (i : ι), η i) →₀ N	⊢ (⇑sigma_finsupp_equiv_dfinsupp f).support = f.split_support
ι : Type u_1,	η : ι → Type u_4,	N : Type u_5,	_inst_2 : has_zero N,	f : (Σ (i : ι), η i) →₀ N,	a : ι	⊢ a ∈ (⇑sigma_finsupp_equiv_dfinsupp f).support ↔ a ∈ f.split_support
ι : Type u_1,	η : ι → Type u_4,	N : Type u_5,	_inst_2 : has_zero N,	f : (Σ (i : ι), η i) →₀ N,	a : ι	⊢ ⇑(⇑sigma_finsupp_equiv_dfinsupp f) a ≠ 0 ↔ a ∈ f.split_support
⊢ ∀ {β : Type u_2} [_inst_1 : comm_monoid β] {n : ℕ} (f : fin n → β),	    (list.of_fn f).prod = univ.prod (λ (i : fin n), f i)
β : Type u_2,	_inst_1 : comm_monoid β,	n : ℕ,	f : fin n → β	⊢ (list.of_fn f).prod = univ.prod (λ (i : fin n), f i)
⊢ ∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [_inst_1 : fintype α] [_inst_2 : decidable_eq β]	  [_inst_3 : fintype β] [_inst_4 : comm_monoid γ] (f : α → β) (g : α → γ),	    univ.prod (λ (b : β), univ.prod (λ (a : {a // f a = b}), g ↑a)) = univ.prod (λ (a : α), g a)
α : Type u_1,	β : Type u_2,	γ : Type u_3,	_inst_1 : fintype α,	_inst_2 : decidable_eq β,	_inst_3 : fintype β,	_inst_4 : comm_monoid γ,	f : α → β,	g : α → γ	⊢ univ.prod (λ (b : β), univ.prod (λ (a : {a // f a = b}), g ↑a)) = univ.prod (λ (a : α), g a)
α : Type u_1,	β : Type u_2,	γ : Type u_3,	_inst_1 : fintype α,	_inst_2 : decidable_eq β,	_inst_3 : fintype β,	_inst_4 : comm_monoid γ,	f : α → β,	g : α → γ	⊢ univ.prod (λ (b : β), univ.prod (λ (a : {a // f a = b}), g ↑a)) =	    univ.prod (λ (a : β), univ.prod (λ (s : {x // f x = a}), g (⇑(equiv.sigma_preimage_equiv f) ⟨a, s⟩)))
⊢ ∀ {m n : ℕ}, m < n.succ → of_nat m + -[1+ n] = -[1+ n - m]
m n : ℕ,	h : m < n.succ	⊢ of_nat m + -[1+ n] = -[1+ n - m]
m n : ℕ,	h : m < n.succ	⊢ sub_nat_nat m n.succ = -[1+ n - m]
2 goals	m n : ℕ,	h : m < n.succ	⊢ n.succ - m = (n - m).succ		m n : ℕ,	h : m < n.succ,	h' : n.succ - m = (n - m).succ	⊢ sub_nat_nat m n.succ = -[1+ n - m]
2 goals	m n : ℕ,	h : m < n.succ	⊢ m ≤ n		m n : ℕ,	h : m < n.succ,	h' : n.succ - m = (n - m).succ	⊢ sub_nat_nat m n.succ = -[1+ n - m]
m n : ℕ,	h : m < n.succ,	h' : n.succ - m = (n - m).succ	⊢ sub_nat_nat m n.succ = -[1+ n - m]
⊢ ∀ (n : ℕ), (neg_of_nat n).nat_abs = n
n : ℕ	⊢ (neg_of_nat n).nat_abs = n
2 goals	case nat.zero	⊢ (neg_of_nat 0).nat_abs = 0		case nat.succ	n : ℕ	⊢ (neg_of_nat n.succ).nat_abs = n.succ
case nat.succ	n : ℕ	⊢ (neg_of_nat n.succ).nat_abs = n.succ
⊢ ∀ (a : ℤ) {b : ℤ}, b ≠ 0 → a * b / b = a
a b : ℤ,	H : b ≠ 0	⊢ a * b / b = a
a b : ℤ,	H : b ≠ 0,	this : (0 + a * b) / b = 0 / b + a	⊢ a * b / b = a
⊢ ∀ {a b : ℤ}, (a + b) % b = a % b
a b : ℤ	⊢ (a + b) % b = a % b
a b : ℤ,	this : (a + b * 1) % b = a % b	⊢ (a + b) % b = a % b
⊢ ∀ {a b : ℤ}, a % b = 0 → a / b * b = a
a b : ℤ,	H : a % b = 0	⊢ a / b * b = a
⊢ ∀ (i : ℤ), i.lcm i = i.nat_abs
i : ℤ	⊢ i.lcm i = i.nat_abs
i : ℤ	⊢ i.nat_abs.lcm i.nat_abs = i.nat_abs
⊢ ∀ {n a b : ℤ} (m : ℕ), a ≡ b [ZMOD n] → a ^ m ≡ b ^ m [ZMOD n]
n a b : ℤ,	m : ℕ,	h : a ≡ b [ZMOD n]	⊢ a ^ m ≡ b ^ m [ZMOD n]
2 goals	case nat.zero	n a b : ℤ,	h : a ≡ b [ZMOD n]	⊢ a ^ 0 ≡ b ^ 0 [ZMOD n]		case nat.succ	n a b : ℤ,	h : a ≡ b [ZMOD n],	d : ℕ,	hd : a ^ d ≡ b ^ d [ZMOD n]	⊢ a ^ d.succ ≡ b ^ d.succ [ZMOD n]
case nat.succ	n a b : ℤ,	h : a ≡ b [ZMOD n],	d : ℕ,	hd : a ^ d ≡ b ^ d [ZMOD n]	⊢ a ^ d.succ ≡ b ^ d.succ [ZMOD n]
case nat.succ	n a b : ℤ,	h : a ≡ b [ZMOD n],	d : ℕ,	hd : a ^ d ≡ b ^ d [ZMOD n]	⊢ a * a ^ d ≡ b * b ^ d [ZMOD n]
⊢ ∀ {α : Type u_1} (xs : lazy_list α), xs.append (λ («_» : unit), nil) = xs
α : Type u_1,	xs : lazy_list α	⊢ xs.append (λ («_» : unit), nil) = xs
2 goals	case lazy_list.nil	α : Type u_1	⊢ nil.append (λ («_» : unit), nil) = nil		case lazy_list.cons	α : Type u_1,	xs_hd : α,	xs_tl : thunk (lazy_list α),	xs_ih : ∀ (ᾰ : unit), (λ (xs : lazy_list α), xs.append (λ («_» : unit), nil) = xs) (xs_tl ᾰ)	⊢ (cons xs_hd xs_tl).append (λ («_» : unit), nil) = cons xs_hd xs_tl
case lazy_list.cons	α : Type u_1,	xs_hd : α,	xs_tl : thunk (lazy_list α),	xs_ih : ∀ (ᾰ : unit), (λ (xs : lazy_list α), xs.append (λ («_» : unit), nil) = xs) (xs_tl ᾰ)	⊢ (cons xs_hd xs_tl).append (λ («_» : unit), nil) = cons xs_hd xs_tl
case lazy_list.cons	α : Type u_1,	xs_hd : α,	xs_tl : thunk (lazy_list α),	xs_ih : ∀ (ᾰ : unit), (λ (xs : lazy_list α), xs.append (λ («_» : unit), nil) = xs) (xs_tl ᾰ)	⊢ (λ («_» : unit), xs_tl ()) = xs_tl
α : Type u_1,	xs_hd : α,	xs_tl : thunk (lazy_list α),	xs_ih : ∀ (ᾰ : unit), (λ (xs : lazy_list α), xs.append (λ («_» : unit), nil) = xs) (xs_tl ᾰ),	x : unit	⊢ xs_tl () = xs_tl x
⊢ ∀ {α : Type u_1} {l₂ : list α} {a : α} [_inst_1 : decidable_eq α] (l₁ : list α),	    a ∈ l₂ → (a :: l₁).bag_inter l₂ = a :: l₁.bag_inter (l₂.erase a)
α : Type u_1,	l₂ : list α,	a : α,	_inst_1 : decidable_eq α,	l₁ : list α,	h : a ∈ l₂	⊢ (a :: l₁).bag_inter l₂ = a :: l₁.bag_inter (l₂.erase a)
2 goals	case list.nil	α : Type u_1,	a : α,	_inst_1 : decidable_eq α,	l₁ : list α,	h : a ∈ nil	⊢ (a :: l₁).bag_inter nil = a :: l₁.bag_inter (nil.erase a)		case list.cons	α : Type u_1,	a : α,	_inst_1 : decidable_eq α,	l₁ : list α,	l₂_hd : α,	l₂_tl : list α,	h : a ∈ l₂_hd :: l₂_tl	⊢ (a :: l₁).bag_inter (l₂_hd :: l₂_tl) = a :: l₁.bag_inter ((l₂_hd :: l₂_tl).erase a)
case list.cons	α : Type u_1,	a : α,	_inst_1 : decidable_eq α,	l₁ : list α,	l₂_hd : α,	l₂_tl : list α,	h : a ∈ l₂_hd :: l₂_tl	⊢ (a :: l₁).bag_inter (l₂_hd :: l₂_tl) = a :: l₁.bag_inter ((l₂_hd :: l₂_tl).erase a)
⊢ ∀ {α : Type u} {β : Type v} (f g : α → β → α) (a : α) {l : list β},	    (∀ (a : α) (b : β), b ∈ l → f a b = g a b) → foldl f a l = foldl g a l
α : Type u,	β : Type v,	f g : α → β → α,	a : α,	l : list β,	H : ∀ (a : α) (b : β), b ∈ l → f a b = g a b	⊢ foldl f a l = foldl g a l
2 goals	case list.nil	α : Type u,	β : Type v,	f g : α → β → α,	H : ∀ (a : α) (b : β), b ∈ nil → f a b = g a b,	a : α	⊢ foldl f a nil = foldl g a nil		case list.cons	α : Type u,	β : Type v,	f g : α → β → α,	hd : β,	tl : list β,	ih : (∀ (a : α) (b : β), b ∈ tl → f a b = g a b) → ∀ (a : α), foldl f a tl = foldl g a tl,	H : ∀ (a : α) (b : β), b ∈ hd :: tl → f a b = g a b,	a : α	⊢ foldl f a (hd :: tl) = foldl g a (hd :: tl)
case list.cons	α : Type u,	β : Type v,	f g : α → β → α,	hd : β,	tl : list β,	ih : (∀ (a : α) (b : β), b ∈ tl → f a b = g a b) → ∀ (a : α), foldl f a tl = foldl g a tl,	H : ∀ (a : α) (b : β), b ∈ hd :: tl → f a b = g a b,	a : α	⊢ foldl f a (hd :: tl) = foldl g a (hd :: tl)
α : Type u,	β : Type v,	f g : α → β → α,	hd : β,	tl : list β,	ih : (∀ (a : α) (b : β), b ∈ tl → f a b = g a b) → ∀ (a : α), foldl f a tl = foldl g a tl,	H : ∀ (a : α) (b : β), b ∈ hd :: tl → f a b = g a b,	a : α	⊢ foldl f (f a hd) tl = foldl g (g a hd) tl
⊢ ∀ {M₀ : Type u_5} [_inst_1 : monoid_with_zero M₀] [_inst_2 : nontrivial M₀]	  [_inst_3 : no_zero_divisors M₀] {L : list M₀}, L.prod = 0 ↔ 0 ∈ L
M₀ : Type u_5,	_inst_1 : monoid_with_zero M₀,	_inst_2 : nontrivial M₀,	_inst_3 : no_zero_divisors M₀,	L : list M₀	⊢ L.prod = 0 ↔ 0 ∈ L
2 goals	case list.nil	M₀ : Type u_5,	_inst_1 : monoid_with_zero M₀,	_inst_2 : nontrivial M₀,	_inst_3 : no_zero_divisors M₀	⊢ nil.prod = 0 ↔ 0 ∈ nil		case list.cons	M₀ : Type u_5,	_inst_1 : monoid_with_zero M₀,	_inst_2 : nontrivial M₀,	_inst_3 : no_zero_divisors M₀,	a : M₀,	L : list M₀,	ihL : L.prod = 0 ↔ 0 ∈ L	⊢ (a :: L).prod = 0 ↔ 0 ∈ a :: L
case list.cons	M₀ : Type u_5,	_inst_1 : monoid_with_zero M₀,	_inst_2 : nontrivial M₀,	_inst_3 : no_zero_divisors M₀,	a : M₀,	L : list M₀,	ihL : L.prod = 0 ↔ 0 ∈ L	⊢ (a :: L).prod = 0 ↔ 0 ∈ a :: L
⊢ ∀ {α : Type u_1} (L : list (list α)) (i : ℕ), drop (take i (map length L)).sum L.join = (drop i L).join
α : Type u_1,	L : list (list α),	i : ℕ	⊢ drop (take i (map length L)).sum L.join = (drop i L).join
2 goals	case list.nil	α : Type u_1,	i : ℕ	⊢ drop (take i (map length nil)).sum nil.join = (drop i nil).join		case list.cons	α : Type u_1,	L_hd : list α,	L_tl : list (list α),	L_ih : ∀ (i : ℕ), drop (take i (map length L_tl)).sum L_tl.join = (drop i L_tl).join,	i : ℕ	⊢ drop (take i (map length (L_hd :: L_tl))).sum (L_hd :: L_tl).join = (drop i (L_hd :: L_tl)).join
case list.cons	α : Type u_1,	L_hd : list α,	L_tl : list (list α),	L_ih : ∀ (i : ℕ), drop (take i (map length L_tl)).sum L_tl.join = (drop i L_tl).join,	i : ℕ	⊢ drop (take i (map length (L_hd :: L_tl))).sum (L_hd :: L_tl).join = (drop i (L_hd :: L_tl)).join
2 goals	case list.cons, nat.zero	α : Type u_1,	L_hd : list α,	L_tl : list (list α),	L_ih : ∀ (i : ℕ), drop (take i (map length L_tl)).sum L_tl.join = (drop i L_tl).join	⊢ drop (take 0 (map length (L_hd :: L_tl))).sum (L_hd :: L_tl).join = (drop 0 (L_hd :: L_tl)).join		case list.cons, nat.succ	α : Type u_1,	L_hd : list α,	L_tl : list (list α),	L_ih : ∀ (i : ℕ), drop (take i (map length L_tl)).sum L_tl.join = (drop i L_tl).join,	i : ℕ	⊢ drop (take i.succ (map length (L_hd :: L_tl))).sum (L_hd :: L_tl).join = (drop i.succ (L_hd :: L_tl)).join
case list.cons, nat.succ	α : Type u_1,	L_hd : list α,	L_tl : list (list α),	L_ih : ∀ (i : ℕ), drop (take i (map length L_tl)).sum L_tl.join = (drop i L_tl).join,	i : ℕ	⊢ drop (take i.succ (map length (L_hd :: L_tl))).sum (L_hd :: L_tl).join = (drop i.succ (L_hd :: L_tl)).join
⊢ ∀ {α : Type u} [_inst_1 : decidable_eq α] {a : α} {l : list α}, a ∈ l → (l.erase a).length = l.length.pred
α : Type u,	_inst_1 : decidable_eq α,	a : α,	l : list α,	h : a ∈ l	⊢ (l.erase a).length = l.length.pred
α : Type u,	_inst_1 : decidable_eq α,	a : α,	l : list α,	h : a ∈ l	⊢ (erasep (eq a) l).length = l.length.pred
⊢ ∀ {α : Type u} {β : Type v} {f : α → β} {l : list α} {s₁ s₂ : list β},	    map f l = s₁ ++ s₂ → (∃ (l₁ l₂ : list α), l = l₁ ++ l₂ ∧ map f l₁ = s₁ ∧ map f l₂ = s₂)
α : Type u,	β : Type v,	f : α → β,	l : list α,	s₁ s₂ : list β,	h : map f l = s₁ ++ s₂	⊢ ∃ (l₁ l₂ : list α), l = l₁ ++ l₂ ∧ map f l₁ = s₁ ∧ map f l₂ = s₂
α : Type u,	β : Type v,	f : α → β,	l : list α,	s₁ s₂ : list β,	h this : map f l = s₁ ++ s₂	⊢ ∃ (l₁ l₂ : list α), l = l₁ ++ l₂ ∧ map f l₁ = s₁ ∧ map f l₂ = s₂
α : Type u,	β : Type v,	f : α → β,	l : list α,	s₁ s₂ : list β,	h : map f l = s₁ ++ s₂,	this : map f (take s₁.length l ++ drop s₁.length l) = s₁ ++ s₂	⊢ ∃ (l₁ l₂ : list α),	    take s₁.length l ++ drop s₁.length l = l₁ ++ l₂ ∧ map f l₁ = s₁ ∧ map f l₂ = s₂
α : Type u,	β : Type v,	f : α → β,	l : list α,	s₁ s₂ : list β,	h : map f l = s₁ ++ s₂,	this : map f (take s₁.length l) ++ map f (drop s₁.length l) = s₁ ++ s₂	⊢ ∃ (l₁ l₂ : list α),	    take s₁.length l ++ drop s₁.length l = l₁ ++ l₂ ∧ map f l₁ = s₁ ∧ map f l₂ = s₂
α : Type u,	β : Type v,	f : α → β,	l : list α,	s₁ s₂ : list β,	h : map f l = s₁ ++ s₂,	this : map f (take s₁.length l) ++ map f (drop s₁.length l) = s₁ ++ s₂	⊢ (map f (take s₁.length l)).length = s₁.length
α : Type u,	β : Type v,	f : α → β,	l : list α,	s₁ s₂ : list β,	h : map f l = s₁ ++ s₂,	this : map f (take s₁.length l) ++ map f (drop s₁.length l) = s₁ ++ s₂	⊢ s₁.length ≤ l.length
α : Type u,	β : Type v,	f : α → β,	l : list α,	s₁ s₂ : list β,	h : map f l = s₁ ++ s₂,	this : map f (take s₁.length l) ++ map f (drop s₁.length l) = s₁ ++ s₂	⊢ s₁.length ≤ s₁.length + s₂.length
⊢ ∀ {α : Type u} {β : Type v} (l : list α) (b : β), map (const α b) l = repeat b l.length
α : Type u,	β : Type v,	l : list α,	b : β	⊢ map (const α b) l = repeat b l.length
2 goals	case list.nil	α : Type u,	β : Type v,	b : β	⊢ map (const α b) nil = repeat b nil.length		case list.cons	α : Type u,	β : Type v,	b : β,	l_hd : α,	l_tl : list α,	l_ih : map (const α b) l_tl = repeat b l_tl.length	⊢ map (const α b) (l_hd :: l_tl) = repeat b (l_hd :: l_tl).length
case list.cons	α : Type u,	β : Type v,	b : β,	l_hd : α,	l_tl : list α,	l_ih : map (const α b) l_tl = repeat b l_tl.length	⊢ map (const α b) (l_hd :: l_tl) = repeat b (l_hd :: l_tl).length
case list.cons	α : Type u,	β : Type v,	b : β,	l_hd : α,	l_tl : list α,	l_ih : map (const α b) l_tl = repeat b l_tl.length	⊢ const α b l_hd :: repeat b l_tl.length = repeat b (l_hd :: l_tl).length
⊢ ∀ {α : Type u_1} [_inst_1 : decidable_eq α] (l : list α) (x y : α) (h : x ∈ y :: l) (hy : x ≠ y),	    x ≠ (y :: l).last _ → (y :: l).next x h = l.next x _
α : Type u_1,	_inst_1 : decidable_eq α,	l : list α,	x y : α,	h : x ∈ y :: l,	hy : x ≠ y,	hx : x ≠ (y :: l).last _	⊢ (y :: l).next x h = l.next x _
2 goals	α : Type u_1,	_inst_1 : decidable_eq α,	l : list α,	x y : α,	h : x ∈ y :: l,	hy : x ≠ y,	hx : x ≠ (y :: l).last _	⊢ x ≠ l.last _		α : Type u_1,	_inst_1 : decidable_eq α,	l : list α,	x y : α,	h : x ∈ y :: l,	hy : x ≠ y,	hx : x ≠ (y :: l).last _	⊢ x ∈ l
α : Type u_1,	_inst_1 : decidable_eq α,	l : list α,	x y : α,	h : x ∈ y :: l,	hy : x ≠ y,	hx : x ≠ (y :: l).last _	⊢ x ∈ l
⊢ ∀ {α : Type u_1} {l : list α}, l.nodup ↔ ∀ (x : α), ¬duplicate x l
α : Type u_1,	l : list α	⊢ l.nodup ↔ ∀ (x : α), ¬duplicate x l
⊢ ∀ {α : Type u_1} {l : list α} {x : α} [_inst_1 : decidable_eq α], duplicate x l ↔ 2 ≤ count x l
α : Type u_1,	l : list α,	x : α,	_inst_1 : decidable_eq α	⊢ duplicate x l ↔ 2 ≤ count x l
⊢ ∀ {m : Type u → Type v} [_inst_1 : applicative m] {α : Type u_1} {β : Type u} (f : ℕ → α → m β)	  (as : list α), mmap_with_index f as = list.traverse (uncurry f) as.enum
m : Type u → Type v,	_inst_1 : applicative m,	α : Type u_1,	β : Type u,	f : ℕ → α → m β,	as : list α	⊢ mmap_with_index f as = list.traverse (uncurry f) as.enum
⊢ ∀ {α : Type u} {β : Type v} (l : list α) (f : ℕ → α → β) (n : ℕ),	    map_with_index_core f n l = map_with_index (λ (i : ℕ) (a : α), f (i + n) a) l
α : Type u,	β : Type v,	l : list α,	f : ℕ → α → β,	n : ℕ	⊢ map_with_index_core f n l = map_with_index (λ (i : ℕ) (a : α), f (i + n) a) l
2 goals	case list.nil	α : Type u,	β : Type v,	f : ℕ → α → β,	n : ℕ	⊢ map_with_index_core f n nil = map_with_index (λ (i : ℕ) (a : α), f (i + n) a) nil		case list.cons	α : Type u,	β : Type v,	hd : α,	tl : list α,	hl :	  ∀ (f : ℕ → α → β) (n : ℕ),	    map_with_index_core f n tl = map_with_index (λ (i : ℕ) (a : α), f (i + n) a) tl,	f : ℕ → α → β,	n : ℕ	⊢ map_with_index_core f n (hd :: tl) = map_with_index (λ (i : ℕ) (a : α), f (i + n) a) (hd :: tl)
case list.cons	α : Type u,	β : Type v,	hd : α,	tl : list α,	hl :	  ∀ (f : ℕ → α → β) (n : ℕ),	    map_with_index_core f n tl = map_with_index (λ (i : ℕ) (a : α), f (i + n) a) tl,	f : ℕ → α → β,	n : ℕ	⊢ map_with_index_core f n (hd :: tl) = map_with_index (λ (i : ℕ) (a : α), f (i + n) a) (hd :: tl)
case list.cons	α : Type u,	β : Type v,	hd : α,	tl : list α,	hl :	  ∀ (f : ℕ → α → β) (n : ℕ),	    map_with_index_core f n tl = map_with_index (λ (i : ℕ) (a : α), f (i + n) a) tl,	f : ℕ → α → β,	n : ℕ	⊢ map_with_index_core f n (hd :: tl) = map_with_index_core (λ (i : ℕ) (a : α), f (i + n) a) 0 (hd :: tl)
⊢ ∀ {α : Type u_1} (R : α → α → Prop) (a : α), pairwise R [a]
α : Type u_1,	R : α → α → Prop,	a : α	⊢ pairwise R [a]
⊢ ∀ {α : Type uu} (s : list α) (x : α) (n : ℕ) (hn : n < (permutations'_aux x s).length),	    (permutations'_aux x s).nth_le n hn = insert_nth n x s
α : Type uu,	s : list α,	x : α,	n : ℕ,	hn : n < (permutations'_aux x s).length	⊢ (permutations'_aux x s).nth_le n hn = insert_nth n x s
2 goals	case list.nil	α : Type uu,	x : α,	n : ℕ,	hn : n < (permutations'_aux x nil).length	⊢ (permutations'_aux x nil).nth_le n hn = insert_nth n x nil		case list.cons	α : Type uu,	x y : α,	s : list α,	IH : ∀ (n : ℕ) (hn : n < (permutations'_aux x s).length), (permutations'_aux x s).nth_le n hn = insert_nth n x s,	n : ℕ,	hn : n < (permutations'_aux x (y :: s)).length	⊢ (permutations'_aux x (y :: s)).nth_le n hn = insert_nth n x (y :: s)
2 goals	case list.nil	α : Type uu,	x : α,	n : ℕ,	hn : n < (permutations'_aux x nil).length,	hn : n = 0	⊢ (permutations'_aux x nil).nth_le n hn = insert_nth n x nil		case list.cons	α : Type uu,	x y : α,	s : list α,	IH : ∀ (n : ℕ) (hn : n < (permutations'_aux x s).length), (permutations'_aux x s).nth_le n hn = insert_nth n x s,	n : ℕ,	hn : n < (permutations'_aux x (y :: s)).length	⊢ (permutations'_aux x (y :: s)).nth_le n hn = insert_nth n x (y :: s)
case list.cons	α : Type uu,	x y : α,	s : list α,	IH : ∀ (n : ℕ) (hn : n < (permutations'_aux x s).length), (permutations'_aux x s).nth_le n hn = insert_nth n x s,	n : ℕ,	hn : n < (permutations'_aux x (y :: s)).length	⊢ (permutations'_aux x (y :: s)).nth_le n hn = insert_nth n x (y :: s)
2 goals	case list.cons, nat.zero	α : Type uu,	x y : α,	s : list α,	IH : ∀ (n : ℕ) (hn : n < (permutations'_aux x s).length), (permutations'_aux x s).nth_le n hn = insert_nth n x s,	hn : 0 < (permutations'_aux x (y :: s)).length	⊢ (permutations'_aux x (y :: s)).nth_le 0 hn = insert_nth 0 x (y :: s)		case list.cons, nat.succ	α : Type uu,	x y : α,	s : list α,	IH : ∀ (n : ℕ) (hn : n < (permutations'_aux x s).length), (permutations'_aux x s).nth_le n hn = insert_nth n x s,	n : ℕ,	hn : n.succ < (permutations'_aux x (y :: s)).length	⊢ (permutations'_aux x (y :: s)).nth_le n.succ hn = insert_nth n.succ x (y :: s)
case list.cons, nat.succ	α : Type uu,	x y : α,	s : list α,	IH : ∀ (n : ℕ) (hn : n < (permutations'_aux x s).length), (permutations'_aux x s).nth_le n hn = insert_nth n x s,	n : ℕ,	hn : n.succ < (permutations'_aux x (y :: s)).length	⊢ (permutations'_aux x (y :: s)).nth_le n.succ hn = insert_nth n.succ x (y :: s)
⊢ ∀ {α : Type uu} {β : list α → Sort u_1} {f : Π (a : α) (l : list α), β l → β (a :: l)} {b : β nil}	  {l l' : list α},	    l ~ l' →	    (∀ {a : α} {l l' : list α} {b : β l} {b' : β l'}, l ~ l' → b == b' → f a l b == f a l' b') →	    (∀ {a a' : α} {l : list α} {b : β l}, f a (a' :: l) (f a' l b) == f a' (a :: l) (f a l b)) →	    list.rec b f l == list.rec b f l'
α : Type uu,	β : list α → Sort u_1,	f : Π (a : α) (l : list α), β l → β (a :: l),	b : β nil,	l l' : list α,	hl : l ~ l',	f_congr : ∀ {a : α} {l l' : list α} {b : β l} {b' : β l'}, l ~ l' → b == b' → f a l b == f a l' b',	f_swap : ∀ {a a' : α} {l : list α} {b : β l}, f a (a' :: l) (f a' l b) == f a' (a :: l) (f a l b)	⊢ list.rec b f l == list.rec b f l'
4 goals	case list.perm.nil	α : Type uu,	β : list α → Sort u_1,	f : Π (a : α) (l : list α), β l → β (a :: l),	b : β nil,	f_congr : ∀ {a : α} {l l' : list α} {b : β l} {b' : β l'}, l ~ l' → b == b' → f a l b == f a l' b',	f_swap : ∀ {a a' : α} {l : list α} {b : β l}, f a (a' :: l) (f a' l b) == f a' (a :: l) (f a l b),	l l' : list α	⊢ list.rec b f nil == list.rec b f nil		case list.perm.cons	α : Type uu,	β : list α → Sort u_1,	f : Π (a : α) (l : list α), β l → β (a :: l),	b : β nil,	f_congr : ∀ {a : α} {l l' : list α} {b : β l} {b' : β l'}, l ~ l' → b == b' → f a l b == f a l' b',	f_swap : ∀ {a a' : α} {l : list α} {b : β l}, f a (a' :: l) (f a' l b) == f a' (a :: l) (f a l b),	l l' : list α,	hl_x : α,	hl_l₁ hl_l₂ : list α,	hl_ᾰ : hl_l₁ ~ hl_l₂,	hl_ih : list.rec b f hl_l₁ == list.rec b f hl_l₂	⊢ list.rec b f (hl_x :: hl_l₁) == list.rec b f (hl_x :: hl_l₂)		case list.perm.swap	α : Type uu,	β : list α → Sort u_1,	f : Π (a : α) (l : list α), β l → β (a :: l),	b : β nil,	f_congr : ∀ {a : α} {l l' : list α} {b : β l} {b' : β l'}, l ~ l' → b == b' → f a l b == f a l' b',	f_swap : ∀ {a a' : α} {l : list α} {b : β l}, f a (a' :: l) (f a' l b) == f a' (a :: l) (f a l b),	l l' : list α,	hl_x hl_y : α,	hl_l : list α	⊢ list.rec b f (hl_y :: hl_x :: hl_l) == list.rec b f (hl_x :: hl_y :: hl_l)		case list.perm.trans	α : Type uu,	β : list α → Sort u_1,	f : Π (a : α) (l : list α), β l → β (a :: l),	b : β nil,	f_congr : ∀ {a : α} {l l' : list α} {b : β l} {b' : β l'}, l ~ l' → b == b' → f a l b == f a l' b',	f_swap : ∀ {a a' : α} {l : list α} {b : β l}, f a (a' :: l) (f a' l b) == f a' (a :: l) (f a l b),	l l' hl_l₁ hl_l₂ hl_l₃ : list α,	hl_ᾰ : hl_l₁ ~ hl_l₂,	hl_ᾰ_1 : hl_l₂ ~ hl_l₃,	hl_ih_ᾰ : list.rec b f hl_l₁ == list.rec b f hl_l₂,	hl_ih_ᾰ_1 : list.rec b f hl_l₂ == list.rec b f hl_l₃	⊢ list.rec b f hl_l₁ == list.rec b f hl_l₃
3 goals	case list.perm.cons	α : Type uu,	β : list α → Sort u_1,	f : Π (a : α) (l : list α), β l → β (a :: l),	b : β nil,	f_congr : ∀ {a : α} {l l' : list α} {b : β l} {b' : β l'}, l ~ l' → b == b' → f a l b == f a l' b',	f_swap : ∀ {a a' : α} {l : list α} {b : β l}, f a (a' :: l) (f a' l b) == f a' (a :: l) (f a l b),	l l' : list α,	hl_x : α,	hl_l₁ hl_l₂ : list α,	hl_ᾰ : hl_l₁ ~ hl_l₂,	hl_ih : list.rec b f hl_l₁ == list.rec b f hl_l₂	⊢ list.rec b f (hl_x :: hl_l₁) == list.rec b f (hl_x :: hl_l₂)		case list.perm.swap	α : Type uu,	β : list α → Sort u_1,	f : Π (a : α) (l : list α), β l → β (a :: l),	b : β nil,	f_congr : ∀ {a : α} {l l' : list α} {b : β l} {b' : β l'}, l ~ l' → b == b' → f a l b == f a l' b',	f_swap : ∀ {a a' : α} {l : list α} {b : β l}, f a (a' :: l) (f a' l b) == f a' (a :: l) (f a l b),	l l' : list α,	hl_x hl_y : α,	hl_l : list α	⊢ list.rec b f (hl_y :: hl_x :: hl_l) == list.rec b f (hl_x :: hl_y :: hl_l)		case list.perm.trans	α : Type uu,	β : list α → Sort u_1,	f : Π (a : α) (l : list α), β l → β (a :: l),	b : β nil,	f_congr : ∀ {a : α} {l l' : list α} {b : β l} {b' : β l'}, l ~ l' → b == b' → f a l b == f a l' b',	f_swap : ∀ {a a' : α} {l : list α} {b : β l}, f a (a' :: l) (f a' l b) == f a' (a :: l) (f a l b),	l l' hl_l₁ hl_l₂ hl_l₃ : list α,	hl_ᾰ : hl_l₁ ~ hl_l₂,	hl_ᾰ_1 : hl_l₂ ~ hl_l₃,	hl_ih_ᾰ : list.rec b f hl_l₁ == list.rec b f hl_l₂,	hl_ih_ᾰ_1 : list.rec b f hl_l₂ == list.rec b f hl_l₃	⊢ list.rec b f hl_l₁ == list.rec b f hl_l₃
2 goals	case list.perm.swap	α : Type uu,	β : list α → Sort u_1,	f : Π (a : α) (l : list α), β l → β (a :: l),	b : β nil,	f_congr : ∀ {a : α} {l l' : list α} {b : β l} {b' : β l'}, l ~ l' → b == b' → f a l b == f a l' b',	f_swap : ∀ {a a' : α} {l : list α} {b : β l}, f a (a' :: l) (f a' l b) == f a' (a :: l) (f a l b),	l l' : list α,	hl_x hl_y : α,	hl_l : list α	⊢ list.rec b f (hl_y :: hl_x :: hl_l) == list.rec b f (hl_x :: hl_y :: hl_l)		case list.perm.trans	α : Type uu,	β : list α → Sort u_1,	f : Π (a : α) (l : list α), β l → β (a :: l),	b : β nil,	f_congr : ∀ {a : α} {l l' : list α} {b : β l} {b' : β l'}, l ~ l' → b == b' → f a l b == f a l' b',	f_swap : ∀ {a a' : α} {l : list α} {b : β l}, f a (a' :: l) (f a' l b) == f a' (a :: l) (f a l b),	l l' hl_l₁ hl_l₂ hl_l₃ : list α,	hl_ᾰ : hl_l₁ ~ hl_l₂,	hl_ᾰ_1 : hl_l₂ ~ hl_l₃,	hl_ih_ᾰ : list.rec b f hl_l₁ == list.rec b f hl_l₂,	hl_ih_ᾰ_1 : list.rec b f hl_l₂ == list.rec b f hl_l₃	⊢ list.rec b f hl_l₁ == list.rec b f hl_l₃
case list.perm.trans	α : Type uu,	β : list α → Sort u_1,	f : Π (a : α) (l : list α), β l → β (a :: l),	b : β nil,	f_congr : ∀ {a : α} {l l' : list α} {b : β l} {b' : β l'}, l ~ l' → b == b' → f a l b == f a l' b',	f_swap : ∀ {a a' : α} {l : list α} {b : β l}, f a (a' :: l) (f a' l b) == f a' (a :: l) (f a l b),	l l' hl_l₁ hl_l₂ hl_l₃ : list α,	hl_ᾰ : hl_l₁ ~ hl_l₂,	hl_ᾰ_1 : hl_l₂ ~ hl_l₃,	hl_ih_ᾰ : list.rec b f hl_l₁ == list.rec b f hl_l₂,	hl_ih_ᾰ_1 : list.rec b f hl_l₂ == list.rec b f hl_l₃	⊢ list.rec b f hl_l₁ == list.rec b f hl_l₃
⊢ ∀ {α : Type uu} (f : α → option α) {l₁ l₂ : list α},	    pairwise (λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d) l₁ →	    l₁ ~ l₂ → lookmap f l₁ ~ lookmap f l₂
α : Type uu,	f : α → option α,	l₁ l₂ : list α,	H : pairwise (λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d) l₁,	p : l₁ ~ l₂	⊢ lookmap f l₁ ~ lookmap f l₂
α : Type uu,	f : α → option α,	l₁ l₂ : list α,	H : pairwise (λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d) l₁,	p : l₁ ~ l₂,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d	⊢ lookmap f l₁ ~ lookmap f l₂
α : Type uu,	f : α → option α,	l₁ l₂ : list α,	p : l₁ ~ l₂,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	H : pairwise F l₁	⊢ lookmap f l₁ ~ lookmap f l₂
4 goals	case list.perm.nil	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ : list α,	H : pairwise F nil	⊢ lookmap f nil ~ lookmap f nil		case list.perm.cons	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ : list α,	a : α,	l₁ l₂ : list α,	p : l₁ ~ l₂,	IH : pairwise F l₁ → lookmap f l₁ ~ lookmap f l₂,	H : pairwise F (a :: l₁)	⊢ lookmap f (a :: l₁) ~ lookmap f (a :: l₂)		case list.perm.swap	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ : list α,	a b : α,	l : list α,	H : pairwise F (b :: a :: l)	⊢ lookmap f (b :: a :: l) ~ lookmap f (a :: b :: l)		case list.perm.trans	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ l₁ l₂ l₃ : list α,	p₁ : l₁ ~ l₂,	p₂ : l₂ ~ l₃,	IH₁ : pairwise F l₁ → lookmap f l₁ ~ lookmap f l₂,	IH₂ : pairwise F l₂ → lookmap f l₂ ~ lookmap f l₃,	H : pairwise F l₁	⊢ lookmap f l₁ ~ lookmap f l₃
3 goals	case list.perm.cons	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ : list α,	a : α,	l₁ l₂ : list α,	p : l₁ ~ l₂,	IH : pairwise F l₁ → lookmap f l₁ ~ lookmap f l₂,	H : pairwise F (a :: l₁)	⊢ lookmap f (a :: l₁) ~ lookmap f (a :: l₂)		case list.perm.swap	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ : list α,	a b : α,	l : list α,	H : pairwise F (b :: a :: l)	⊢ lookmap f (b :: a :: l) ~ lookmap f (a :: b :: l)		case list.perm.trans	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ l₁ l₂ l₃ : list α,	p₁ : l₁ ~ l₂,	p₂ : l₂ ~ l₃,	IH₁ : pairwise F l₁ → lookmap f l₁ ~ lookmap f l₂,	IH₂ : pairwise F l₂ → lookmap f l₂ ~ lookmap f l₃,	H : pairwise F l₁	⊢ lookmap f l₁ ~ lookmap f l₃
4 goals	case list.perm.cons, option.none	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ : list α,	a : α,	l₁ l₂ : list α,	p : l₁ ~ l₂,	IH : pairwise F l₁ → lookmap f l₁ ~ lookmap f l₂,	H : pairwise F (a :: l₁),	h : f a = none	⊢ lookmap f (a :: l₁) ~ lookmap f (a :: l₂)		case list.perm.cons, option.some	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ : list α,	a : α,	l₁ l₂ : list α,	p : l₁ ~ l₂,	IH : pairwise F l₁ → lookmap f l₁ ~ lookmap f l₂,	H : pairwise F (a :: l₁),	val : α,	h : f a = some val	⊢ lookmap f (a :: l₁) ~ lookmap f (a :: l₂)		case list.perm.swap	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ : list α,	a b : α,	l : list α,	H : pairwise F (b :: a :: l)	⊢ lookmap f (b :: a :: l) ~ lookmap f (a :: b :: l)		case list.perm.trans	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ l₁ l₂ l₃ : list α,	p₁ : l₁ ~ l₂,	p₂ : l₂ ~ l₃,	IH₁ : pairwise F l₁ → lookmap f l₁ ~ lookmap f l₂,	IH₂ : pairwise F l₂ → lookmap f l₂ ~ lookmap f l₃,	H : pairwise F l₁	⊢ lookmap f l₁ ~ lookmap f l₃
4 goals	case list.perm.cons, option.none	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ : list α,	a : α,	l₁ l₂ : list α,	p : l₁ ~ l₂,	IH : pairwise F l₁ → lookmap f l₁ ~ lookmap f l₂,	H : pairwise F (a :: l₁),	h : f a = none	⊢ lookmap f l₁ ~ lookmap f l₂		case list.perm.cons, option.some	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ : list α,	a : α,	l₁ l₂ : list α,	p : l₁ ~ l₂,	IH : pairwise F l₁ → lookmap f l₁ ~ lookmap f l₂,	H : pairwise F (a :: l₁),	val : α,	h : f a = some val	⊢ lookmap f (a :: l₁) ~ lookmap f (a :: l₂)		case list.perm.swap	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ : list α,	a b : α,	l : list α,	H : pairwise F (b :: a :: l)	⊢ lookmap f (b :: a :: l) ~ lookmap f (a :: b :: l)		case list.perm.trans	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ l₁ l₂ l₃ : list α,	p₁ : l₁ ~ l₂,	p₂ : l₂ ~ l₃,	IH₁ : pairwise F l₁ → lookmap f l₁ ~ lookmap f l₂,	IH₂ : pairwise F l₂ → lookmap f l₂ ~ lookmap f l₃,	H : pairwise F l₁	⊢ lookmap f l₁ ~ lookmap f l₃
3 goals	case list.perm.cons, option.some	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ : list α,	a : α,	l₁ l₂ : list α,	p : l₁ ~ l₂,	IH : pairwise F l₁ → lookmap f l₁ ~ lookmap f l₂,	H : pairwise F (a :: l₁),	val : α,	h : f a = some val	⊢ lookmap f (a :: l₁) ~ lookmap f (a :: l₂)		case list.perm.swap	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ : list α,	a b : α,	l : list α,	H : pairwise F (b :: a :: l)	⊢ lookmap f (b :: a :: l) ~ lookmap f (a :: b :: l)		case list.perm.trans	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ l₁ l₂ l₃ : list α,	p₁ : l₁ ~ l₂,	p₂ : l₂ ~ l₃,	IH₁ : pairwise F l₁ → lookmap f l₁ ~ lookmap f l₂,	IH₂ : pairwise F l₂ → lookmap f l₂ ~ lookmap f l₃,	H : pairwise F l₁	⊢ lookmap f l₁ ~ lookmap f l₃
2 goals	case list.perm.swap	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ : list α,	a b : α,	l : list α,	H : pairwise F (b :: a :: l)	⊢ lookmap f (b :: a :: l) ~ lookmap f (a :: b :: l)		case list.perm.trans	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ l₁ l₂ l₃ : list α,	p₁ : l₁ ~ l₂,	p₂ : l₂ ~ l₃,	IH₁ : pairwise F l₁ → lookmap f l₁ ~ lookmap f l₂,	IH₂ : pairwise F l₂ → lookmap f l₂ ~ lookmap f l₃,	H : pairwise F l₁	⊢ lookmap f l₁ ~ lookmap f l₃
3 goals	case list.perm.swap, option.none	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ : list α,	a b : α,	l : list α,	H : pairwise F (b :: a :: l),	h₁ : f a = none	⊢ lookmap f (b :: a :: l) ~ lookmap f (a :: b :: l)		case list.perm.swap, option.some	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ : list α,	a b : α,	l : list α,	H : pairwise F (b :: a :: l),	c : α,	h₁ : f a = some c	⊢ lookmap f (b :: a :: l) ~ lookmap f (a :: b :: l)		case list.perm.trans	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ l₁ l₂ l₃ : list α,	p₁ : l₁ ~ l₂,	p₂ : l₂ ~ l₃,	IH₁ : pairwise F l₁ → lookmap f l₁ ~ lookmap f l₂,	IH₂ : pairwise F l₂ → lookmap f l₂ ~ lookmap f l₃,	H : pairwise F l₁	⊢ lookmap f l₁ ~ lookmap f l₃
4 goals	case list.perm.swap, option.none, option.none	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ : list α,	a b : α,	l : list α,	H : pairwise F (b :: a :: l),	h₁ : f a = none,	h₂ : f b = none	⊢ lookmap f (b :: a :: l) ~ lookmap f (a :: b :: l)		case list.perm.swap, option.none, option.some	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ : list α,	a b : α,	l : list α,	H : pairwise F (b :: a :: l),	h₁ : f a = none,	d : α,	h₂ : f b = some d	⊢ lookmap f (b :: a :: l) ~ lookmap f (a :: b :: l)		case list.perm.swap, option.some	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ : list α,	a b : α,	l : list α,	H : pairwise F (b :: a :: l),	c : α,	h₁ : f a = some c	⊢ lookmap f (b :: a :: l) ~ lookmap f (a :: b :: l)		case list.perm.trans	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ l₁ l₂ l₃ : list α,	p₁ : l₁ ~ l₂,	p₂ : l₂ ~ l₃,	IH₁ : pairwise F l₁ → lookmap f l₁ ~ lookmap f l₂,	IH₂ : pairwise F l₂ → lookmap f l₂ ~ lookmap f l₃,	H : pairwise F l₁	⊢ lookmap f l₁ ~ lookmap f l₃
4 goals	case list.perm.swap, option.none, option.none	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ : list α,	a b : α,	l : list α,	H : pairwise F (b :: a :: l),	h₁ : f a = none,	h₂ : f b = none	⊢ b :: a :: lookmap f l ~ a :: b :: lookmap f l		case list.perm.swap, option.none, option.some	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ : list α,	a b : α,	l : list α,	H : pairwise F (b :: a :: l),	h₁ : f a = none,	d : α,	h₂ : f b = some d	⊢ lookmap f (b :: a :: l) ~ lookmap f (a :: b :: l)		case list.perm.swap, option.some	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ : list α,	a b : α,	l : list α,	H : pairwise F (b :: a :: l),	c : α,	h₁ : f a = some c	⊢ lookmap f (b :: a :: l) ~ lookmap f (a :: b :: l)		case list.perm.trans	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ l₁ l₂ l₃ : list α,	p₁ : l₁ ~ l₂,	p₂ : l₂ ~ l₃,	IH₁ : pairwise F l₁ → lookmap f l₁ ~ lookmap f l₂,	IH₂ : pairwise F l₂ → lookmap f l₂ ~ lookmap f l₃,	H : pairwise F l₁	⊢ lookmap f l₁ ~ lookmap f l₃
3 goals	case list.perm.swap, option.none, option.some	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ : list α,	a b : α,	l : list α,	H : pairwise F (b :: a :: l),	h₁ : f a = none,	d : α,	h₂ : f b = some d	⊢ lookmap f (b :: a :: l) ~ lookmap f (a :: b :: l)		case list.perm.swap, option.some	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ : list α,	a b : α,	l : list α,	H : pairwise F (b :: a :: l),	c : α,	h₁ : f a = some c	⊢ lookmap f (b :: a :: l) ~ lookmap f (a :: b :: l)		case list.perm.trans	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ l₁ l₂ l₃ : list α,	p₁ : l₁ ~ l₂,	p₂ : l₂ ~ l₃,	IH₁ : pairwise F l₁ → lookmap f l₁ ~ lookmap f l₂,	IH₂ : pairwise F l₂ → lookmap f l₂ ~ lookmap f l₃,	H : pairwise F l₁	⊢ lookmap f l₁ ~ lookmap f l₃
3 goals	case list.perm.swap, option.none, option.some	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ : list α,	a b : α,	l : list α,	H : pairwise F (b :: a :: l),	h₁ : f a = none,	d : α,	h₂ : f b = some d	⊢ d :: a :: l ~ a :: d :: l		case list.perm.swap, option.some	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ : list α,	a b : α,	l : list α,	H : pairwise F (b :: a :: l),	c : α,	h₁ : f a = some c	⊢ lookmap f (b :: a :: l) ~ lookmap f (a :: b :: l)		case list.perm.trans	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ l₁ l₂ l₃ : list α,	p₁ : l₁ ~ l₂,	p₂ : l₂ ~ l₃,	IH₁ : pairwise F l₁ → lookmap f l₁ ~ lookmap f l₂,	IH₂ : pairwise F l₂ → lookmap f l₂ ~ lookmap f l₃,	H : pairwise F l₁	⊢ lookmap f l₁ ~ lookmap f l₃
2 goals	case list.perm.swap, option.some	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ : list α,	a b : α,	l : list α,	H : pairwise F (b :: a :: l),	c : α,	h₁ : f a = some c	⊢ lookmap f (b :: a :: l) ~ lookmap f (a :: b :: l)		case list.perm.trans	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ l₁ l₂ l₃ : list α,	p₁ : l₁ ~ l₂,	p₂ : l₂ ~ l₃,	IH₁ : pairwise F l₁ → lookmap f l₁ ~ lookmap f l₂,	IH₂ : pairwise F l₂ → lookmap f l₂ ~ lookmap f l₃,	H : pairwise F l₁	⊢ lookmap f l₁ ~ lookmap f l₃
3 goals	case list.perm.swap, option.some, option.none	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ : list α,	a b : α,	l : list α,	H : pairwise F (b :: a :: l),	c : α,	h₁ : f a = some c,	h₂ : f b = none	⊢ lookmap f (b :: a :: l) ~ lookmap f (a :: b :: l)		case list.perm.swap, option.some, option.some	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ : list α,	a b : α,	l : list α,	H : pairwise F (b :: a :: l),	c : α,	h₁ : f a = some c,	d : α,	h₂ : f b = some d	⊢ lookmap f (b :: a :: l) ~ lookmap f (a :: b :: l)		case list.perm.trans	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ l₁ l₂ l₃ : list α,	p₁ : l₁ ~ l₂,	p₂ : l₂ ~ l₃,	IH₁ : pairwise F l₁ → lookmap f l₁ ~ lookmap f l₂,	IH₂ : pairwise F l₂ → lookmap f l₂ ~ lookmap f l₃,	H : pairwise F l₁	⊢ lookmap f l₁ ~ lookmap f l₃
3 goals	case list.perm.swap, option.some, option.none	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ : list α,	a b : α,	l : list α,	H : pairwise F (b :: a :: l),	c : α,	h₁ : f a = some c,	h₂ : f b = none	⊢ b :: c :: l ~ c :: b :: l		case list.perm.swap, option.some, option.some	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ : list α,	a b : α,	l : list α,	H : pairwise F (b :: a :: l),	c : α,	h₁ : f a = some c,	d : α,	h₂ : f b = some d	⊢ lookmap f (b :: a :: l) ~ lookmap f (a :: b :: l)		case list.perm.trans	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ l₁ l₂ l₃ : list α,	p₁ : l₁ ~ l₂,	p₂ : l₂ ~ l₃,	IH₁ : pairwise F l₁ → lookmap f l₁ ~ lookmap f l₂,	IH₂ : pairwise F l₂ → lookmap f l₂ ~ lookmap f l₃,	H : pairwise F l₁	⊢ lookmap f l₁ ~ lookmap f l₃
2 goals	case list.perm.swap, option.some, option.some	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ : list α,	a b : α,	l : list α,	H : pairwise F (b :: a :: l),	c : α,	h₁ : f a = some c,	d : α,	h₂ : f b = some d	⊢ lookmap f (b :: a :: l) ~ lookmap f (a :: b :: l)		case list.perm.trans	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ l₁ l₂ l₃ : list α,	p₁ : l₁ ~ l₂,	p₂ : l₂ ~ l₃,	IH₁ : pairwise F l₁ → lookmap f l₁ ~ lookmap f l₂,	IH₂ : pairwise F l₂ → lookmap f l₂ ~ lookmap f l₃,	H : pairwise F l₁	⊢ lookmap f l₁ ~ lookmap f l₃
2 goals	case list.perm.swap, option.some, option.some	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ : list α,	a b : α,	l : list α,	H : pairwise F (b :: a :: l),	c : α,	h₁ : f a = some c,	d : α,	h₂ : f b = some d	⊢ d :: a :: l ~ c :: b :: l		case list.perm.trans	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ l₁ l₂ l₃ : list α,	p₁ : l₁ ~ l₂,	p₂ : l₂ ~ l₃,	IH₁ : pairwise F l₁ → lookmap f l₁ ~ lookmap f l₂,	IH₂ : pairwise F l₂ → lookmap f l₂ ~ lookmap f l₃,	H : pairwise F l₁	⊢ lookmap f l₁ ~ lookmap f l₃
2 goals	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ : list α,	b : α,	l : list α,	d : α,	h₂ : f b = some d,	H : pairwise F (b :: b :: l),	h₁ : f b = some d	⊢ d :: b :: l ~ d :: b :: l		case list.perm.trans	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ l₁ l₂ l₃ : list α,	p₁ : l₁ ~ l₂,	p₂ : l₂ ~ l₃,	IH₁ : pairwise F l₁ → lookmap f l₁ ~ lookmap f l₂,	IH₂ : pairwise F l₂ → lookmap f l₂ ~ lookmap f l₃,	H : pairwise F l₁	⊢ lookmap f l₁ ~ lookmap f l₃
case list.perm.trans	α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ l₁ l₂ l₃ : list α,	p₁ : l₁ ~ l₂,	p₂ : l₂ ~ l₃,	IH₁ : pairwise F l₁ → lookmap f l₁ ~ lookmap f l₂,	IH₂ : pairwise F l₂ → lookmap f l₂ ~ lookmap f l₃,	H : pairwise F l₁	⊢ lookmap f l₁ ~ lookmap f l₃
α : Type uu,	f : α → option α,	F : α → α → Prop := λ (a b : α), ∀ (c : α), c ∈ f a → ∀ (d : α), d ∈ f b → a = b ∧ c = d,	l₁ l₂ l₁ l₂ l₃ : list α,	p₁ : l₁ ~ l₂,	p₂ : l₂ ~ l₃,	IH₁ : pairwise F l₁ → lookmap f l₁ ~ lookmap f l₂,	IH₂ : pairwise F l₂ → lookmap f l₂ ~ lookmap f l₃,	H : pairwise F l₁	⊢ symmetric F
⊢ ∀ (n : ℕ), pairwise has_lt.lt (range n)
n : ℕ	⊢ pairwise has_lt.lt (range n)
⊢ ∀ {m n : ℕ}, range m <+ range n ↔ m ≤ n
m n : ℕ	⊢ range m <+ range n ↔ m ≤ n
⊢ ∀ {α : Type u} {l : list α} {n : ℕ}, l.rotate n = drop (n % l.length) l ++ take (n % l.length) l
α : Type u,	l : list α,	n : ℕ	⊢ l.rotate n = drop (n % l.length) l ++ take (n % l.length) l
2 goals	case or.inl	α : Type u,	l : list α,	n : ℕ,	hl : 0 = l.length	⊢ l.rotate n = drop (n % l.length) l ++ take (n % l.length) l		case or.inr	α : Type u,	l : list α,	n : ℕ,	hl : 0 < l.length	⊢ l.rotate n = drop (n % l.length) l ++ take (n % l.length) l
case or.inr	α : Type u,	l : list α,	n : ℕ,	hl : 0 < l.length	⊢ l.rotate n = drop (n % l.length) l ++ take (n % l.length) l
⊢ ∀ {α : Type u} {l : list α}, nil ~r l ↔ nil = l
α : Type u,	l : list α	⊢ nil ~r l ↔ nil = l
⊢ ∀ {α : Type u} {l l' : list α}, l ∈ l'.cyclic_permutations ↔ l ~r l'
α : Type u,	l l' : list α	⊢ l ∈ l'.cyclic_permutations ↔ l ~r l'
2 goals	α : Type u,	l l' : list α	⊢ l ∈ l'.cyclic_permutations → l ~r l'		α : Type u,	l l' : list α	⊢ l ~r l' → l ∈ l'.cyclic_permutations
2 goals	α : Type u,	l l' : list α,	h : l ∈ l'.cyclic_permutations	⊢ l ~r l'		α : Type u,	l l' : list α	⊢ l ~r l' → l ∈ l'.cyclic_permutations
2 goals	α : Type u,	l' : list α,	k : ℕ,	hk : k < l'.cyclic_permutations.length,	h : l'.cyclic_permutations.nth_le k hk ∈ l'.cyclic_permutations	⊢ l'.cyclic_permutations.nth_le k hk ~r l'		α : Type u,	l l' : list α	⊢ l ~r l' → l ∈ l'.cyclic_permutations
α : Type u,	l l' : list α	⊢ l ~r l' → l ∈ l'.cyclic_permutations
α : Type u,	l l' : list α,	h : l ~r l'	⊢ l ∈ l'.cyclic_permutations
α : Type u,	l' : list α,	k : ℕ,	h : l'.rotate k ~r l'	⊢ l'.rotate k ∈ l'.cyclic_permutations
α : Type u,	l' : list α,	k : ℕ,	h : l'.rotate k ~r l'	⊢ ∃ (n : ℕ) (h : n < l'.cyclic_permutations.length), l'.cyclic_permutations.nth_le n h = l'.rotate k
α : Type u,	l' : list α,	k : ℕ,	h : l'.rotate k ~r l'	⊢ ∃ (n : ℕ), n < l'.cyclic_permutations.length ∧ l'.rotate n = l'.rotate k
2 goals	case list.nil	α : Type u,	k : ℕ,	h : nil.rotate k ~r nil	⊢ ∃ (n : ℕ), n < nil.cyclic_permutations.length ∧ nil.rotate n = nil.rotate k		case list.cons	α : Type u,	k : ℕ,	x : α,	l : list α,	h : (x :: l).rotate k ~r (x :: l)	⊢ ∃ (n : ℕ), n < (x :: l).cyclic_permutations.length ∧ (x :: l).rotate n = (x :: l).rotate k
case list.cons	α : Type u,	k : ℕ,	x : α,	l : list α,	h : (x :: l).rotate k ~r (x :: l)	⊢ ∃ (n : ℕ), n < (x :: l).cyclic_permutations.length ∧ (x :: l).rotate n = (x :: l).rotate k
α : Type u,	k : ℕ,	x : α,	l : list α,	h : (x :: l).rotate k ~r (x :: l)	⊢ k % (x :: l).length < (x :: l).cyclic_permutations.length
⊢ ∀ {α : Type u} {β : α → Type v} [_inst_1 : decidable_eq α] {a a' : α} {b' : β a'} {l : list (sigma β)},	    a ≠ a' → lookup a (kinsert a' b' l) = lookup a l
α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	a a' : α,	b' : β a',	l : list (sigma β),	h : a ≠ a'	⊢ lookup a (kinsert a' b' l) = lookup a l
⊢ ∀ {α : Type u} {β : Type v} {γ : Type w} (g : list β → list γ) (l : list α) (f : list α → list β)	  (r : list (list β)), map g (l.sublists'_aux f r) = l.sublists'_aux (g ∘ f) (map g r)
α : Type u,	β : Type v,	γ : Type w,	g : list β → list γ,	l : list α,	f : list α → list β,	r : list (list β)	⊢ map g (l.sublists'_aux f r) = l.sublists'_aux (g ∘ f) (map g r)
2 goals	case list.nil	α : Type u,	β : Type v,	γ : Type w,	g : list β → list γ,	f : list α → list β,	r : list (list β)	⊢ map g (nil.sublists'_aux f r) = nil.sublists'_aux (g ∘ f) (map g r)		case list.cons	α : Type u,	β : Type v,	γ : Type w,	g : list β → list γ,	l_hd : α,	l_tl : list α,	l_ih :	  ∀ (f : list α → list β) (r : list (list β)),	    map g (l_tl.sublists'_aux f r) = l_tl.sublists'_aux (g ∘ f) (map g r),	f : list α → list β,	r : list (list β)	⊢ map g ((l_hd :: l_tl).sublists'_aux f r) = (l_hd :: l_tl).sublists'_aux (g ∘ f) (map g r)
case list.cons	α : Type u,	β : Type v,	γ : Type w,	g : list β → list γ,	l_hd : α,	l_tl : list α,	l_ih :	  ∀ (f : list α → list β) (r : list (list β)),	    map g (l_tl.sublists'_aux f r) = l_tl.sublists'_aux (g ∘ f) (map g r),	f : list α → list β,	r : list (list β)	⊢ map g ((l_hd :: l_tl).sublists'_aux f r) = (l_hd :: l_tl).sublists'_aux (g ∘ f) (map g r)
⊢ ∀ {α : Type u} {β : Type u_1} (f : α → α → β),	    (∀ (x y : α), f x y = f y x) → ∀ (l l' : list α), zip_with f l l' = zip_with f l' l
α : Type u,	β : Type u_1,	f : α → α → β,	comm : ∀ (x y : α), f x y = f y x,	l l' : list α	⊢ zip_with f l l' = zip_with f l' l
2 goals	case list.nil	α : Type u,	β : Type u_1,	f : α → α → β,	comm : ∀ (x y : α), f x y = f y x,	l' : list α	⊢ zip_with f nil l' = zip_with f l' nil		case list.cons	α : Type u,	β : Type u_1,	f : α → α → β,	comm : ∀ (x y : α), f x y = f y x,	hd : α,	tl : list α,	hl : ∀ (l' : list α), zip_with f tl l' = zip_with f l' tl,	l' : list α	⊢ zip_with f (hd :: tl) l' = zip_with f l' (hd :: tl)
case list.cons	α : Type u,	β : Type u_1,	f : α → α → β,	comm : ∀ (x y : α), f x y = f y x,	hd : α,	tl : list α,	hl : ∀ (l' : list α), zip_with f tl l' = zip_with f l' tl,	l' : list α	⊢ zip_with f (hd :: tl) l' = zip_with f l' (hd :: tl)
2 goals	case list.cons, list.nil	α : Type u,	β : Type u_1,	f : α → α → β,	comm : ∀ (x y : α), f x y = f y x,	hd : α,	tl : list α,	hl : ∀ (l' : list α), zip_with f tl l' = zip_with f l' tl	⊢ zip_with f (hd :: tl) nil = zip_with f nil (hd :: tl)		case list.cons, list.cons	α : Type u,	β : Type u_1,	f : α → α → β,	comm : ∀ (x y : α), f x y = f y x,	hd : α,	tl : list α,	hl : ∀ (l' : list α), zip_with f tl l' = zip_with f l' tl,	l'_hd : α,	l'_tl : list α	⊢ zip_with f (hd :: tl) (l'_hd :: l'_tl) = zip_with f (l'_hd :: l'_tl) (hd :: tl)
case list.cons, list.cons	α : Type u,	β : Type u_1,	f : α → α → β,	comm : ∀ (x y : α), f x y = f y x,	hd : α,	tl : list α,	hl : ∀ (l' : list α), zip_with f tl l' = zip_with f l' tl,	l'_hd : α,	l'_tl : list α	⊢ zip_with f (hd :: tl) (l'_hd :: l'_tl) = zip_with f (l'_hd :: l'_tl) (hd :: tl)
⊢ ∀ {α : Type u} (l : list α), map prod.fst l.revzip = l
α : Type u,	l : list α	⊢ map prod.fst l.revzip = l
⊢ ∀ {α : Type u} {β : Type u_1} {γ : Type u_2} [_inst_1 : semiring γ] (f : α → β → γ) (n : γ)	  (l : list α) (l' : list β), (zip_with (λ (x : α) (y : β), n * f x y) l l').sum = n * (zip_with f l l').sum
α : Type u,	β : Type u_1,	γ : Type u_2,	_inst_1 : semiring γ,	f : α → β → γ,	n : γ,	l : list α,	l' : list β	⊢ (zip_with (λ (x : α) (y : β), n * f x y) l l').sum = n * (zip_with f l l').sum
2 goals	case list.nil	α : Type u,	β : Type u_1,	γ : Type u_2,	_inst_1 : semiring γ,	f : α → β → γ,	n : γ,	l' : list β	⊢ (zip_with (λ (x : α) (y : β), n * f x y) nil l').sum = n * (zip_with f nil l').sum		case list.cons	α : Type u,	β : Type u_1,	γ : Type u_2,	_inst_1 : semiring γ,	hd : α,	tl : list α,	hl :	  ∀ (f : α → β → γ) (n : γ) (l' : list β),	    (zip_with (λ (x : α) (y : β), n * f x y) tl l').sum = n * (zip_with f tl l').sum,	f : α → β → γ,	n : γ,	l' : list β	⊢ (zip_with (λ (x : α) (y : β), n * f x y) (hd :: tl) l').sum = n * (zip_with f (hd :: tl) l').sum
case list.cons	α : Type u,	β : Type u_1,	γ : Type u_2,	_inst_1 : semiring γ,	hd : α,	tl : list α,	hl :	  ∀ (f : α → β → γ) (n : γ) (l' : list β),	    (zip_with (λ (x : α) (y : β), n * f x y) tl l').sum = n * (zip_with f tl l').sum,	f : α → β → γ,	n : γ,	l' : list β	⊢ (zip_with (λ (x : α) (y : β), n * f x y) (hd :: tl) l').sum = n * (zip_with f (hd :: tl) l').sum
2 goals	case list.cons, list.nil	α : Type u,	β : Type u_1,	γ : Type u_2,	_inst_1 : semiring γ,	hd : α,	tl : list α,	hl :	  ∀ (f : α → β → γ) (n : γ) (l' : list β),	    (zip_with (λ (x : α) (y : β), n * f x y) tl l').sum = n * (zip_with f tl l').sum,	f : α → β → γ,	n : γ	⊢ (zip_with (λ (x : α) (y : β), n * f x y) (hd :: tl) nil).sum = n * (zip_with f (hd :: tl) nil).sum		case list.cons, list.cons	α : Type u,	β : Type u_1,	γ : Type u_2,	_inst_1 : semiring γ,	hd : α,	tl : list α,	hl :	  ∀ (f : α → β → γ) (n : γ) (l' : list β),	    (zip_with (λ (x : α) (y : β), n * f x y) tl l').sum = n * (zip_with f tl l').sum,	f : α → β → γ,	n : γ,	hd' : β,	tl' : list β	⊢ (zip_with (λ (x : α) (y : β), n * f x y) (hd :: tl) (hd' :: tl')).sum =	    n * (zip_with f (hd :: tl) (hd' :: tl')).sum
case list.cons, list.cons	α : Type u,	β : Type u_1,	γ : Type u_2,	_inst_1 : semiring γ,	hd : α,	tl : list α,	hl :	  ∀ (f : α → β → γ) (n : γ) (l' : list β),	    (zip_with (λ (x : α) (y : β), n * f x y) tl l').sum = n * (zip_with f tl l').sum,	f : α → β → γ,	n : γ,	hd' : β,	tl' : list β	⊢ (zip_with (λ (x : α) (y : β), n * f x y) (hd :: tl) (hd' :: tl')).sum =	    n * (zip_with f (hd :: tl) (hd' :: tl')).sum
⊢ ∀ {m : Type u_2} {n : Type u_3} {o : Type u_4} {α : Type v} [_inst_1 : non_unital_non_assoc_semiring α]	  [_inst_2 : fintype n] (L : matrix m n α) (M N : matrix n o α), L.mul (M + N) = L.mul M + L.mul N
m : Type u_2,	n : Type u_3,	o : Type u_4,	α : Type v,	_inst_1 : non_unital_non_assoc_semiring α,	_inst_2 : fintype n,	L : matrix m n α,	M N : matrix n o α	⊢ L.mul (M + N) = L.mul M + L.mul N
m : Type u_2,	n : Type u_3,	o : Type u_4,	α : Type v,	_inst_1 : non_unital_non_assoc_semiring α,	_inst_2 : fintype n,	L : matrix m n α,	M N : matrix n o α,	i : m,	j : o	⊢ L.mul (M + N) i j = (L.mul M + L.mul N) i j
⊢ ∀ {m : Type u_2} {n : Type u_3} {o : Type u_4} {α : Type v} [_inst_1 : ring α] [_inst_2 : fintype n]	  (M : matrix m n α) (N : matrix n o α), M.mul (-N) = -M.mul N
m : Type u_2,	n : Type u_3,	o : Type u_4,	α : Type v,	_inst_1 : ring α,	_inst_2 : fintype n,	M : matrix m n α,	N : matrix n o α	⊢ M.mul (-N) = -M.mul N
m : Type u_2,	n : Type u_3,	o : Type u_4,	α : Type v,	_inst_1 : ring α,	_inst_2 : fintype n,	M : matrix m n α,	N : matrix n o α,	i : m,	j : o	⊢ M.mul (-N) i j = (-M.mul N) i j
⊢ ∀ {m : Type u_2} {n : Type u_3} {o : Type u_4} {α : Type u_9} (M : o → matrix m n α)	  [_inst_1 : decidable_eq o] {R : Type u_1} [_inst_2 : semiring R] [_inst_3 : add_comm_monoid α]	  [_inst_4 : module R α] (x : R), block_diagonal (x • M) = x • block_diagonal M
m : Type u_2,	n : Type u_3,	o : Type u_4,	α : Type u_9,	M : o → matrix m n α,	_inst_1 : decidable_eq o,	R : Type u_1,	_inst_2 : semiring R,	_inst_3 : add_comm_monoid α,	_inst_4 : module R α,	x : R	⊢ block_diagonal (x • M) = x • block_diagonal M
m : Type u_2,	n : Type u_3,	o : Type u_4,	α : Type u_9,	M : o → matrix m n α,	_inst_1 : decidable_eq o,	R : Type u_1,	_inst_2 : semiring R,	_inst_3 : add_comm_monoid α,	_inst_4 : module R α,	x : R,	i : m × o,	j : n × o	⊢ block_diagonal (x • M) i j = (x • block_diagonal M) i j
m : Type u_2,	n : Type u_3,	o : Type u_4,	α : Type u_9,	M : o → matrix m n α,	_inst_1 : decidable_eq o,	R : Type u_1,	_inst_2 : semiring R,	_inst_3 : add_comm_monoid α,	_inst_4 : module R α,	x : R,	i : m × o,	j : n × o	⊢ ite (i.snd = j.snd) (x • M i.snd i.fst j.fst) 0 = x • ite (i.snd = j.snd) (M i.snd i.fst j.fst) 0
2 goals	m : Type u_2,	n : Type u_3,	o : Type u_4,	α : Type u_9,	M : o → matrix m n α,	_inst_1 : decidable_eq o,	R : Type u_1,	_inst_2 : semiring R,	_inst_3 : add_comm_monoid α,	_inst_4 : module R α,	x : R,	i : m × o,	j : n × o,	h : i.snd = j.snd	⊢ x • M i.snd i.fst j.fst = x • M i.snd i.fst j.fst		m : Type u_2,	n : Type u_3,	o : Type u_4,	α : Type u_9,	M : o → matrix m n α,	_inst_1 : decidable_eq o,	R : Type u_1,	_inst_2 : semiring R,	_inst_3 : add_comm_monoid α,	_inst_4 : module R α,	x : R,	i : m × o,	j : n × o,	h : ¬i.snd = j.snd	⊢ 0 = x • 0
m : Type u_2,	n : Type u_3,	o : Type u_4,	α : Type u_9,	M : o → matrix m n α,	_inst_1 : decidable_eq o,	R : Type u_1,	_inst_2 : semiring R,	_inst_3 : add_comm_monoid α,	_inst_4 : module R α,	x : R,	i : m × o,	j : n × o,	h : ¬i.snd = j.snd	⊢ 0 = x • 0
⊢ ∀ {o : Type u_4} {m' : o → Type u_5} {n' : o → Type u_6} {α : Type u_9}	  (M N : Π (i : o), matrix (m' i) (n' i) α) [_inst_1 : decidable_eq o] [_inst_2 : add_monoid α],	    block_diagonal' (M + N) = block_diagonal' M + block_diagonal' N
o : Type u_4,	m' : o → Type u_5,	n' : o → Type u_6,	α : Type u_9,	M N : Π (i : o), matrix (m' i) (n' i) α,	_inst_1 : decidable_eq o,	_inst_2 : add_monoid α	⊢ block_diagonal' (M + N) = block_diagonal' M + block_diagonal' N
o : Type u_4,	m' : o → Type u_5,	n' : o → Type u_6,	α : Type u_9,	M N : Π (i : o), matrix (m' i) (n' i) α,	_inst_1 : decidable_eq o,	_inst_2 : add_monoid α,	i : Σ (i : o), (λ (i : o), m' i) i,	j : Σ (i : o), (λ (i : o), n' i) i	⊢ block_diagonal' (M + N) i j = (block_diagonal' M + block_diagonal' N) i j
o : Type u_4,	m' : o → Type u_5,	n' : o → Type u_6,	α : Type u_9,	M N : Π (i : o), matrix (m' i) (n' i) α,	_inst_1 : decidable_eq o,	_inst_2 : add_monoid α,	i : Σ (i : o), (λ (i : o), m' i) i,	j : Σ (i : o), (λ (i : o), n' i) i	⊢ dite (i.fst = j.fst) (λ (h : i.fst = j.fst), M i.fst i.snd (cast _ j.snd) + N i.fst i.snd (cast _ j.snd))	      (λ (h : ¬i.fst = j.fst), 0) =	    dite (i.fst = j.fst) (λ (h : i.fst = j.fst), M i.fst i.snd (cast _ j.snd)) (λ (h : ¬i.fst = j.fst), 0) +	      dite (i.fst = j.fst) (λ (h : i.fst = j.fst), N i.fst i.snd (cast _ j.snd)) (λ (h : ¬i.fst = j.fst), 0)
2 goals	o : Type u_4,	m' : o → Type u_5,	n' : o → Type u_6,	α : Type u_9,	M N : Π (i : o), matrix (m' i) (n' i) α,	_inst_1 : decidable_eq o,	_inst_2 : add_monoid α,	i : Σ (i : o), (λ (i : o), m' i) i,	j : Σ (i : o), (λ (i : o), n' i) i,	h : i.fst = j.fst	⊢ M i.fst i.snd (cast _ j.snd) + N i.fst i.snd (cast _ j.snd) =	    M i.fst i.snd (cast _ j.snd) + N i.fst i.snd (cast _ j.snd)		o : Type u_4,	m' : o → Type u_5,	n' : o → Type u_6,	α : Type u_9,	M N : Π (i : o), matrix (m' i) (n' i) α,	_inst_1 : decidable_eq o,	_inst_2 : add_monoid α,	i : Σ (i : o), (λ (i : o), m' i) i,	j : Σ (i : o), (λ (i : o), n' i) i,	h : ¬i.fst = j.fst	⊢ 0 = 0 + 0
o : Type u_4,	m' : o → Type u_5,	n' : o → Type u_6,	α : Type u_9,	M N : Π (i : o), matrix (m' i) (n' i) α,	_inst_1 : decidable_eq o,	_inst_2 : add_monoid α,	i : Σ (i : o), (λ (i : o), m' i) i,	j : Σ (i : o), (λ (i : o), n' i) i,	h : ¬i.fst = j.fst	⊢ 0 = 0 + 0
⊢ ∀ {α : Type u_1} {n : Type u_5} [_inst_1 : decidable_eq n] [_inst_2 : mul_zero_one_class α] (M : matrix n n α),	    1.hadamard M = diagonal (λ (i : n), M i i)
α : Type u_1,	n : Type u_5,	_inst_1 : decidable_eq n,	_inst_2 : mul_zero_one_class α,	M : matrix n n α	⊢ 1.hadamard M = diagonal (λ (i : n), M i i)
α : Type u_1,	n : Type u_5,	_inst_1 : decidable_eq n,	_inst_2 : mul_zero_one_class α,	M : matrix n n α,	i j : n	⊢ 1.hadamard M i j = diagonal (λ (i : n), M i i) i j
2 goals	α : Type u_1,	n : Type u_5,	_inst_1 : decidable_eq n,	_inst_2 : mul_zero_one_class α,	M : matrix n n α,	i j : n,	h : i = j	⊢ 1.hadamard M i j = diagonal (λ (i : n), M i i) i j		α : Type u_1,	n : Type u_5,	_inst_1 : decidable_eq n,	_inst_2 : mul_zero_one_class α,	M : matrix n n α,	i j : n,	h : ¬i = j	⊢ 1.hadamard M i j = diagonal (λ (i : n), M i i) i j
α : Type u_1,	n : Type u_5,	_inst_1 : decidable_eq n,	_inst_2 : mul_zero_one_class α,	M : matrix n n α,	i j : n,	h : ¬i = j	⊢ 1.hadamard M i j = diagonal (λ (i : n), M i i) i j
⊢ ∀ {R : Type u_1} {α : Type u_2} {β : Type u_4} {γ : Type u_6} {l : Type u_8} {m : Type u_9} {n : Type u_10}	  {l' : Type u_14} {m' : Type u_15} {n' : Type u_16} [_inst_1 : comm_semiring R] [_inst_2 : fintype m]	  [_inst_3 : fintype m'] [_inst_4 : non_unital_non_assoc_semiring α] [_inst_5 : non_unital_non_assoc_semiring β]	  [_inst_6 : non_unital_non_assoc_semiring γ] [_inst_7 : module R α] [_inst_8 : module R β] [_inst_9 : module R γ]	  (f : α →ₗ[R] β →ₗ[R] γ),	    (∀ (a b : α) (a' b' : β), ⇑(⇑f (a * b)) (a' * b') = ⇑(⇑f a) a' * ⇑(⇑f b) b') →	    ∀ (A : matrix l m α) (B : matrix m n α) (A' : matrix l' m' β) (B' : matrix m' n' β),	      ⇑(⇑(kronecker_map_bilinear f) (A.mul B)) (A'.mul B') =	        (⇑(⇑(kronecker_map_bilinear f) A) A').mul (⇑(⇑(kronecker_map_bilinear f) B) B')
R : Type u_1,	α : Type u_2,	β : Type u_4,	γ : Type u_6,	l : Type u_8,	m : Type u_9,	n : Type u_10,	l' : Type u_14,	m' : Type u_15,	n' : Type u_16,	_inst_1 : comm_semiring R,	_inst_2 : fintype m,	_inst_3 : fintype m',	_inst_4 : non_unital_non_assoc_semiring α,	_inst_5 : non_unital_non_assoc_semiring β,	_inst_6 : non_unital_non_assoc_semiring γ,	_inst_7 : module R α,	_inst_8 : module R β,	_inst_9 : module R γ,	f : α →ₗ[R] β →ₗ[R] γ,	h_comm : ∀ (a b : α) (a' b' : β), ⇑(⇑f (a * b)) (a' * b') = ⇑(⇑f a) a' * ⇑(⇑f b) b',	A : matrix l m α,	B : matrix m n α,	A' : matrix l' m' β,	B' : matrix m' n' β	⊢ ⇑(⇑(kronecker_map_bilinear f) (A.mul B)) (A'.mul B') =	    (⇑(⇑(kronecker_map_bilinear f) A) A').mul (⇑(⇑(kronecker_map_bilinear f) B) B')
R : Type u_1,	α : Type u_2,	β : Type u_4,	γ : Type u_6,	l : Type u_8,	m : Type u_9,	n : Type u_10,	l' : Type u_14,	m' : Type u_15,	n' : Type u_16,	_inst_1 : comm_semiring R,	_inst_2 : fintype m,	_inst_3 : fintype m',	_inst_4 : non_unital_non_assoc_semiring α,	_inst_5 : non_unital_non_assoc_semiring β,	_inst_6 : non_unital_non_assoc_semiring γ,	_inst_7 : module R α,	_inst_8 : module R β,	_inst_9 : module R γ,	f : α →ₗ[R] β →ₗ[R] γ,	h_comm : ∀ (a b : α) (a' b' : β), ⇑(⇑f (a * b)) (a' * b') = ⇑(⇑f a) a' * ⇑(⇑f b) b',	A : matrix l m α,	B : matrix m n α,	A' : matrix l' m' β,	B' : matrix m' n' β,	i : l,	i' : l',	j : n,	j' : n'	⊢ ⇑(⇑(kronecker_map_bilinear f) (A.mul B)) (A'.mul B') (i, i') (j, j') =	    (⇑(⇑(kronecker_map_bilinear f) A) A').mul (⇑(⇑(kronecker_map_bilinear f) B) B') (i, i') (j, j')
R : Type u_1,	α : Type u_2,	β : Type u_4,	γ : Type u_6,	l : Type u_8,	m : Type u_9,	n : Type u_10,	l' : Type u_14,	m' : Type u_15,	n' : Type u_16,	_inst_1 : comm_semiring R,	_inst_2 : fintype m,	_inst_3 : fintype m',	_inst_4 : non_unital_non_assoc_semiring α,	_inst_5 : non_unital_non_assoc_semiring β,	_inst_6 : non_unital_non_assoc_semiring γ,	_inst_7 : module R α,	_inst_8 : module R β,	_inst_9 : module R γ,	f : α →ₗ[R] β →ₗ[R] γ,	h_comm : ∀ (a b : α) (a' b' : β), ⇑(⇑f (a * b)) (a' * b') = ⇑(⇑f a) a' * ⇑(⇑f b) b',	A : matrix l m α,	B : matrix m n α,	A' : matrix l' m' β,	B' : matrix m' n' β,	i : l,	i' : l',	j : n,	j' : n'	⊢ ⇑(⇑f (finset.univ.sum (λ (j_1 : m), A i j_1 * B j_1 j))) (finset.univ.sum (λ (j : m'), A' i' j * B' j j')) =	    finset.univ.sum	      (λ (x : m), finset.univ.sum (λ (y : m'), ⇑(⇑f (A i x)) (A' i' y) * ⇑(⇑f (B x j)) (B' y j')))
⊢ ∀ {m : Type u_3} {n : Type u_4} {α : Type v} [_inst_1 : fintype m] [_inst_2 : decidable_eq m]	  [_inst_3 : semiring α] (f : m ≃ m) (M : matrix m n α), f.to_pequiv.to_matrix.mul M = λ (i : m), M (⇑f i)
m : Type u_3,	n : Type u_4,	α : Type v,	_inst_1 : fintype m,	_inst_2 : decidable_eq m,	_inst_3 : semiring α,	f : m ≃ m,	M : matrix m n α	⊢ f.to_pequiv.to_matrix.mul M = λ (i : m), M (⇑f i)
m : Type u_3,	n : Type u_4,	α : Type v,	_inst_1 : fintype m,	_inst_2 : decidable_eq m,	_inst_3 : semiring α,	f : m ≃ m,	M : matrix m n α,	i : m,	j : n	⊢ f.to_pequiv.to_matrix.mul M i j = M (⇑f i) j
⊢ ∀ {α : Type u_1} [_inst_1 : decidable_eq α] (s t u : multiset α), s ∩ t + u = (s + u) ∩ (t + u)
α : Type u_1,	_inst_1 : decidable_eq α,	s t u : multiset α	⊢ s ∩ t + u = (s + u) ∩ (t + u)
α : Type u_1,	_inst_1 : decidable_eq α,	s t u : multiset α,	h : ¬s ∩ t + u = (s + u) ∩ (t + u)	⊢ false
α : Type u_1,	_inst_1 : decidable_eq α,	s t u : multiset α,	h : ¬s ∩ t + u = (s + u) ∩ (t + u),	a : α,	hl : a ::ₘ (s ∩ t + u) ≤ (s + u) ∩ (t + u)	⊢ false
α : Type u_1,	_inst_1 : decidable_eq α,	s t u : multiset α,	h : ¬s ∩ t + u = (s + u) ∩ (t + u),	a : α,	hl : a ::ₘ s ∩ t + u ≤ (s + u) ∩ (t + u)	⊢ false
⊢ ∀ {α : Type u_1} {a : α} {s : multiset α} {n : ℕ}, n ≠ 0 → (a ∈ n • s ↔ a ∈ s)
α : Type u_1,	a : α,	s : multiset α,	n : ℕ,	h0 : n ≠ 0	⊢ a ∈ n • s ↔ a ∈ s
α : Type u_1,	a : α,	s : multiset α,	n : ℕ,	h0 : n ≠ 0,	h : a ∈ s	⊢ a ∈ n • s
α : Type u_1,	a : α,	s : multiset α,	h : a ∈ s,	n : ℕ,	h0 : n.succ ≠ 0	⊢ a ∈ n.succ • s
α : Type u_1,	a : α,	s : multiset α,	h : a ∈ s,	n : ℕ,	h0 : n.succ ≠ 0	⊢ a ∈ s ∨ a ∈ n • s
⊢ ∀ {α : Type u_1} {β : Type u_2} (f : α → β) (a : α) (k : ℕ), map f (repeat a k) = repeat (f a) k
α : Type u_1,	β : Type u_2,	f : α → β,	a : α,	k : ℕ	⊢ map f (repeat a k) = repeat (f a) k
2 goals	case nat.zero	α : Type u_1,	β : Type u_2,	f : α → β,	a : α	⊢ map f (repeat a 0) = repeat (f a) 0		case nat.succ	α : Type u_1,	β : Type u_2,	f : α → β,	a : α,	k_n : ℕ,	k_ih : map f (repeat a k_n) = repeat (f a) k_n	⊢ map f (repeat a k_n.succ) = repeat (f a) k_n.succ
case nat.succ	α : Type u_1,	β : Type u_2,	f : α → β,	a : α,	k_n : ℕ,	k_ih : map f (repeat a k_n) = repeat (f a) k_n	⊢ map f (repeat a k_n.succ) = repeat (f a) k_n.succ
⊢ ∀ {α : Type u_1} {β : Type u_2} {s : multiset α} {f : α → β}, map f s = 0 ↔ s = 0
α : Type u_1,	β : Type u_2,	s : multiset α,	f : α → β	⊢ map f s = 0 ↔ s = 0
⊢ ∀ {ι : Type u_1} {α : Type u_2} [_inst_1 : comm_monoid α] {m : multiset ι}, (map (λ (i : ι), 1) m).prod = 1
ι : Type u_1,	α : Type u_2,	_inst_1 : comm_monoid α,	m : multiset ι	⊢ (map (λ (i : ι), 1) m).prod = 1
⊢ ∀ {α : Type u_1} [_inst_4 : decidable_eq α] {m : multiset (multiset α)},	    m.sup.nodup ↔ ∀ (a : multiset α), a ∈ m → a.nodup
α : Type u_1,	_inst_4 : decidable_eq α,	m : multiset (multiset α)	⊢ m.sup.nodup ↔ ∀ (a : multiset α), a ∈ m → a.nodup
2 goals	α : Type u_1,	_inst_4 : decidable_eq α,	m : multiset (multiset α)	⊢ 0.sup.nodup ↔ ∀ (a : multiset α), a ∈ 0 → a.nodup		α : Type u_1,	_inst_4 : decidable_eq α,	m : multiset (multiset α)	⊢ ∀ ⦃a : multiset α⦄ {s : multiset (multiset α)},	    (s.sup.nodup ↔ ∀ (a : multiset α), a ∈ s → a.nodup) →	    ((a ::ₘ s).sup.nodup ↔ ∀ (a_1 : multiset α), a_1 ∈ a ::ₘ s → a_1.nodup)
α : Type u_1,	_inst_4 : decidable_eq α,	m : multiset (multiset α)	⊢ ∀ ⦃a : multiset α⦄ {s : multiset (multiset α)},	    (s.sup.nodup ↔ ∀ (a : multiset α), a ∈ s → a.nodup) →	    ((a ::ₘ s).sup.nodup ↔ ∀ (a_1 : multiset α), a_1 ∈ a ::ₘ s → a_1.nodup)
α : Type u_1,	_inst_4 : decidable_eq α,	m : multiset (multiset α),	a : multiset α,	s : multiset (multiset α),	h : s.sup.nodup ↔ ∀ (a : multiset α), a ∈ s → a.nodup	⊢ (a ::ₘ s).sup.nodup ↔ ∀ (a_1 : multiset α), a_1 ∈ a ::ₘ s → a_1.nodup
⊢ ∀ {R : Type u_1} [_inst_3 : comm_semiring R] (σ : Type u_2) [_inst_4 : is_empty σ], surjective ⇑C
R : Type u_1,	_inst_3 : comm_semiring R,	σ : Type u_2,	_inst_4 : is_empty σ	⊢ surjective ⇑C
R : Type u_1,	_inst_3 : comm_semiring R,	σ : Type u_2,	_inst_4 : is_empty σ,	p : mv_polynomial σ R,	a : σ →₀ ℕ	⊢ ⇑(⇑C (p.to_fun 0)) a = ⇑p a
⊢ ∀ {R : Type u} {σ : Type u_1} {a : R} {s : σ →₀ ℕ} [_inst_1 : comm_semiring R],	    ⇑(monomial s) a = ⇑C a * s.prod (λ (n : σ) (e : ℕ), X n ^ e)
R : Type u,	σ : Type u_1,	a : R,	s : σ →₀ ℕ,	_inst_1 : comm_semiring R	⊢ ⇑(monomial s) a = ⇑C a * s.prod (λ (n : σ) (e : ℕ), X n ^ e)
2 goals	R : Type u,	σ : Type u_1,	a : R,	s : σ →₀ ℕ,	_inst_1 : comm_semiring R	⊢ ⇑(monomial 0) a = ⇑C a * 0.prod (λ (n : σ) (e : ℕ), X n ^ e)		R : Type u,	σ : Type u_1,	a : R,	s : σ →₀ ℕ,	_inst_1 : comm_semiring R	⊢ ∀ (a_1 : σ) (b : ℕ) (f : σ →₀ ℕ),	    a_1 ∉ f.support →	    b ≠ 0 →	    ⇑(monomial f) a = ⇑C a * f.prod (λ (n : σ) (e : ℕ), X n ^ e) →	    ⇑(monomial (single a_1 b + f)) a = ⇑C a * (single a_1 b + f).prod (λ (n : σ) (e : ℕ), X n ^ e)
2 goals	R : Type u,	σ : Type u_1,	a : R,	s : σ →₀ ℕ,	_inst_1 : comm_semiring R	⊢ ⇑(monomial 0) a = ⇑(monomial 0) a * 1		R : Type u,	σ : Type u_1,	a : R,	s : σ →₀ ℕ,	_inst_1 : comm_semiring R	⊢ ∀ (a_1 : σ) (b : ℕ) (f : σ →₀ ℕ),	    a_1 ∉ f.support →	    b ≠ 0 →	    ⇑(monomial f) a = ⇑C a * f.prod (λ (n : σ) (e : ℕ), X n ^ e) →	    ⇑(monomial (single a_1 b + f)) a = ⇑C a * (single a_1 b + f).prod (λ (n : σ) (e : ℕ), X n ^ e)
R : Type u,	σ : Type u_1,	a : R,	s : σ →₀ ℕ,	_inst_1 : comm_semiring R	⊢ ∀ (a_1 : σ) (b : ℕ) (f : σ →₀ ℕ),	    a_1 ∉ f.support →	    b ≠ 0 →	    ⇑(monomial f) a = ⇑C a * f.prod (λ (n : σ) (e : ℕ), X n ^ e) →	    ⇑(monomial (single a_1 b + f)) a = ⇑C a * (single a_1 b + f).prod (λ (n : σ) (e : ℕ), X n ^ e)
R : Type u,	σ : Type u_1,	a : R,	s : σ →₀ ℕ,	_inst_1 : comm_semiring R,	n : σ,	e : ℕ,	s : σ →₀ ℕ,	hns : n ∉ s.support,	he : e ≠ 0,	ih : ⇑(monomial s) a = ⇑C a * s.prod (λ (n : σ) (e : ℕ), X n ^ e)	⊢ ⇑(monomial (single n e + s)) a = ⇑C a * (single n e + s).prod (λ (n : σ) (e : ℕ), X n ^ e)
3 goals	R : Type u,	σ : Type u_1,	a : R,	s : σ →₀ ℕ,	_inst_1 : comm_semiring R,	n : σ,	e : ℕ,	s : σ →₀ ℕ,	hns : n ∉ s.support,	he : e ≠ 0,	ih : ⇑(monomial s) a = ⇑C a * s.prod (λ (n : σ) (e : ℕ), X n ^ e)	⊢ X n ^ 0 = 1		R : Type u,	σ : Type u_1,	a : R,	s : σ →₀ ℕ,	_inst_1 : comm_semiring R,	n : σ,	e : ℕ,	s : σ →₀ ℕ,	hns : n ∉ s.support,	he : e ≠ 0,	ih : ⇑(monomial s) a = ⇑C a * s.prod (λ (n : σ) (e : ℕ), X n ^ e)	⊢ ∀ (a : σ), X a ^ 0 = 1		R : Type u,	σ : Type u_1,	a : R,	s : σ →₀ ℕ,	_inst_1 : comm_semiring R,	n : σ,	e : ℕ,	s : σ →₀ ℕ,	hns : n ∉ s.support,	he : e ≠ 0,	ih : ⇑(monomial s) a = ⇑C a * s.prod (λ (n : σ) (e : ℕ), X n ^ e)	⊢ ∀ (a : σ) (b₁ b₂ : ℕ), X a ^ (b₁ + b₂) = X a ^ b₁ * X a ^ b₂
2 goals	R : Type u,	σ : Type u_1,	a : R,	s : σ →₀ ℕ,	_inst_1 : comm_semiring R,	n : σ,	e : ℕ,	s : σ →₀ ℕ,	hns : n ∉ s.support,	he : e ≠ 0,	ih : ⇑(monomial s) a = ⇑C a * s.prod (λ (n : σ) (e : ℕ), X n ^ e)	⊢ ∀ (a : σ), X a ^ 0 = 1		R : Type u,	σ : Type u_1,	a : R,	s : σ →₀ ℕ,	_inst_1 : comm_semiring R,	n : σ,	e : ℕ,	s : σ →₀ ℕ,	hns : n ∉ s.support,	he : e ≠ 0,	ih : ⇑(monomial s) a = ⇑C a * s.prod (λ (n : σ) (e : ℕ), X n ^ e)	⊢ ∀ (a : σ) (b₁ b₂ : ℕ), X a ^ (b₁ + b₂) = X a ^ b₁ * X a ^ b₂
2 goals	R : Type u,	σ : Type u_1,	a : R,	s : σ →₀ ℕ,	_inst_1 : comm_semiring R,	n : σ,	e : ℕ,	s : σ →₀ ℕ,	hns : n ∉ s.support,	he : e ≠ 0,	ih : ⇑(monomial s) a = ⇑C a * s.prod (λ (n : σ) (e : ℕ), X n ^ e),	a : σ	⊢ X a ^ 0 = 1		R : Type u,	σ : Type u_1,	a : R,	s : σ →₀ ℕ,	_inst_1 : comm_semiring R,	n : σ,	e : ℕ,	s : σ →₀ ℕ,	hns : n ∉ s.support,	he : e ≠ 0,	ih : ⇑(monomial s) a = ⇑C a * s.prod (λ (n : σ) (e : ℕ), X n ^ e)	⊢ ∀ (a : σ) (b₁ b₂ : ℕ), X a ^ (b₁ + b₂) = X a ^ b₁ * X a ^ b₂
R : Type u,	σ : Type u_1,	a : R,	s : σ →₀ ℕ,	_inst_1 : comm_semiring R,	n : σ,	e : ℕ,	s : σ →₀ ℕ,	hns : n ∉ s.support,	he : e ≠ 0,	ih : ⇑(monomial s) a = ⇑C a * s.prod (λ (n : σ) (e : ℕ), X n ^ e)	⊢ ∀ (a : σ) (b₁ b₂ : ℕ), X a ^ (b₁ + b₂) = X a ^ b₁ * X a ^ b₂
R : Type u,	σ : Type u_1,	a : R,	s : σ →₀ ℕ,	_inst_1 : comm_semiring R,	n : σ,	e : ℕ,	s : σ →₀ ℕ,	hns : n ∉ s.support,	he : e ≠ 0,	ih : ⇑(monomial s) a = ⇑C a * s.prod (λ (n : σ) (e : ℕ), X n ^ e),	a_1 : σ,	b₁ b₂ : ℕ	⊢ X a_1 ^ (b₁ + b₂) = X a_1 ^ b₁ * X a_1 ^ b₂
⊢ ∀ {R : Type u} {σ : Type u_1} [_inst_1 : comm_semiring R] {p : mv_polynomial σ R} {m : σ →₀ ℕ},	    m ∉ p.support ↔ coeff m p = 0
R : Type u,	σ : Type u_1,	_inst_1 : comm_semiring R,	p : mv_polynomial σ R,	m : σ →₀ ℕ	⊢ m ∉ p.support ↔ coeff m p = 0
⊢ ∀ {R : Type u} {S₁ : Type v} {σ : Type u_1} [_inst_1 : comm_semiring R] [_inst_2 : comm_semiring S₁]	  [_inst_3 : fintype σ] (g : R →+* S₁) (x : σ → S₁) (f : mv_polynomial σ R),	    eval₂ g x f =	      f.support.sum (λ (d : σ →₀ ℕ), ⇑g (coeff d f) * finset.univ.prod (λ (i : σ), x i ^ ⇑d i))
R : Type u,	S₁ : Type v,	σ : Type u_1,	_inst_1 : comm_semiring R,	_inst_2 : comm_semiring S₁,	_inst_3 : fintype σ,	g : R →+* S₁,	x : σ → S₁,	f : mv_polynomial σ R	⊢ eval₂ g x f =	    f.support.sum (λ (d : σ →₀ ℕ), ⇑g (coeff d f) * finset.univ.prod (λ (i : σ), x i ^ ⇑d i))
R : Type u,	S₁ : Type v,	σ : Type u_1,	_inst_1 : comm_semiring R,	_inst_2 : comm_semiring S₁,	_inst_3 : fintype σ,	g : R →+* S₁,	x : σ → S₁,	f : mv_polynomial σ R	⊢ f.support.sum (λ (d : σ →₀ ℕ), ⇑g (coeff d f) * d.support.prod (λ (i : σ), x i ^ ⇑d i)) =	    f.support.sum (λ (x_1 : σ →₀ ℕ), ⇑g (coeff x_1 f) * x_1.prod (λ (a : σ), pow (x a)))
⊢ ∀ {R : Type u} {S₁ : Type v} {σ : Type u_1} [_inst_1 : comm_semiring R] [_inst_2 : comm_semiring S₁]	  [_inst_3 : algebra R S₁] (φ : mv_polynomial σ R →ₐ[R] S₁), φ = aeval (⇑φ ∘ X)
R : Type u,	S₁ : Type v,	σ : Type u_1,	_inst_1 : comm_semiring R,	_inst_2 : comm_semiring S₁,	_inst_3 : algebra R S₁,	φ : mv_polynomial σ R →ₐ[R] S₁	⊢ φ = aeval (⇑φ ∘ X)
R : Type u,	S₁ : Type v,	σ : Type u_1,	_inst_1 : comm_semiring R,	_inst_2 : comm_semiring S₁,	_inst_3 : algebra R S₁,	φ : mv_polynomial σ R →ₐ[R] S₁,	i : σ	⊢ ⇑φ (X i) = ⇑(aeval (⇑φ ∘ X)) (X i)
⊢ ∀ {σ : Type u_1} {R : Type u_3} {S : Type u_4} {T : Type u_5} [_inst_1 : comm_semiring R]	  [_inst_2 : comm_semiring S] [_inst_3 : comm_semiring T] (f : S →+* T) (g : σ → T)	  (h : R →+* mv_polynomial σ S), (eval₂_hom f g).comp (bind₂ h) = eval₂_hom ((eval₂_hom f g).comp h) g
σ : Type u_1,	R : Type u_3,	S : Type u_4,	T : Type u_5,	_inst_1 : comm_semiring R,	_inst_2 : comm_semiring S,	_inst_3 : comm_semiring T,	f : S →+* T,	g : σ → T,	h : R →+* mv_polynomial σ S	⊢ (eval₂_hom f g).comp (bind₂ h) = eval₂_hom ((eval₂_hom f g).comp h) g
2 goals	σ : Type u_1,	R : Type u_3,	S : Type u_4,	T : Type u_5,	_inst_1 : comm_semiring R,	_inst_2 : comm_semiring S,	_inst_3 : comm_semiring T,	f : S →+* T,	g : σ → T,	h : R →+* mv_polynomial σ S,	x : R	⊢ ⇑(((eval₂_hom f g).comp (bind₂ h)).comp C) x = ⇑((eval₂_hom ((eval₂_hom f g).comp h) g).comp C) x		σ : Type u_1,	R : Type u_3,	S : Type u_4,	T : Type u_5,	_inst_1 : comm_semiring R,	_inst_2 : comm_semiring S,	_inst_3 : comm_semiring T,	f : S →+* T,	g : σ → T,	h : R →+* mv_polynomial σ S	⊢ ∀ (i : σ), ⇑((eval₂_hom f g).comp (bind₂ h)) (X i) = ⇑(eval₂_hom ((eval₂_hom f g).comp h) g) (X i)
σ : Type u_1,	R : Type u_3,	S : Type u_4,	T : Type u_5,	_inst_1 : comm_semiring R,	_inst_2 : comm_semiring S,	_inst_3 : comm_semiring T,	f : S →+* T,	g : σ → T,	h : R →+* mv_polynomial σ S	⊢ ∀ (i : σ), ⇑((eval₂_hom f g).comp (bind₂ h)) (X i) = ⇑(eval₂_hom ((eval₂_hom f g).comp h) g) (X i)
⊢ ∀ {σ : Type u_1} {R : Type u} [_inst_1 : comm_semiring R] {s t : set σ} [_inst_2 : nontrivial R],	    supported R s ≤ supported R t ↔ s ⊆ t
σ : Type u_1,	R : Type u,	_inst_1 : comm_semiring R,	s t : set σ,	_inst_2 : nontrivial R	⊢ supported R s ≤ supported R t ↔ s ⊆ t
2 goals	σ : Type u_1,	R : Type u,	_inst_1 : comm_semiring R,	s t : set σ,	_inst_2 : nontrivial R	⊢ supported R s ≤ supported R t → s ⊆ t		σ : Type u_1,	R : Type u,	_inst_1 : comm_semiring R,	s t : set σ,	_inst_2 : nontrivial R	⊢ s ⊆ t → supported R s ≤ supported R t
2 goals	σ : Type u_1,	R : Type u,	_inst_1 : comm_semiring R,	s t : set σ,	_inst_2 : nontrivial R,	h : supported R s ≤ supported R t,	i : σ	⊢ i ∈ s → i ∈ t		σ : Type u_1,	R : Type u,	_inst_1 : comm_semiring R,	s t : set σ,	_inst_2 : nontrivial R	⊢ s ⊆ t → supported R s ≤ supported R t
σ : Type u_1,	R : Type u,	_inst_1 : comm_semiring R,	s t : set σ,	_inst_2 : nontrivial R	⊢ s ⊆ t → supported R s ≤ supported R t
⊢ ∀ {σ : Type u_1} {R : Type u} [_inst_1 : comm_semiring R] (s : set σ), supported R s = (rename coe).range
σ : Type u_1,	R : Type u,	_inst_1 : comm_semiring R,	s : set σ	⊢ supported R s = (rename coe).range
⊢ ∀ {R : Type u} {σ : Type u_1} [_inst_1 : comm_semiring R] {p q : mv_polynomial σ R},	    p.degrees.disjoint q.degrees → (p + q).degrees = p.degrees ∪ q.degrees
R : Type u,	σ : Type u_1,	_inst_1 : comm_semiring R,	p q : mv_polynomial σ R,	h : p.degrees.disjoint q.degrees	⊢ (p + q).degrees = p.degrees ∪ q.degrees
2 goals	R : Type u,	σ : Type u_1,	_inst_1 : comm_semiring R,	p q : mv_polynomial σ R,	h : p.degrees.disjoint q.degrees	⊢ (p + q).degrees ≤ p.degrees ∪ q.degrees		R : Type u,	σ : Type u_1,	_inst_1 : comm_semiring R,	p q : mv_polynomial σ R,	h : p.degrees.disjoint q.degrees	⊢ p.degrees ∪ q.degrees ≤ (p + q).degrees
R : Type u,	σ : Type u_1,	_inst_1 : comm_semiring R,	p q : mv_polynomial σ R,	h : p.degrees.disjoint q.degrees	⊢ p.degrees ∪ q.degrees ≤ (p + q).degrees
2 goals	R : Type u,	σ : Type u_1,	_inst_1 : comm_semiring R,	p q : mv_polynomial σ R,	h : p.degrees.disjoint q.degrees	⊢ p.degrees ≤ (p + q).degrees		R : Type u,	σ : Type u_1,	_inst_1 : comm_semiring R,	p q : mv_polynomial σ R,	h : p.degrees.disjoint q.degrees	⊢ q.degrees ≤ (p + q).degrees
R : Type u,	σ : Type u_1,	_inst_1 : comm_semiring R,	p q : mv_polynomial σ R,	h : p.degrees.disjoint q.degrees	⊢ q.degrees ≤ (p + q).degrees
R : Type u,	σ : Type u_1,	_inst_1 : comm_semiring R,	p q : mv_polynomial σ R,	h : p.degrees.disjoint q.degrees	⊢ q.degrees ≤ (q + p).degrees
⊢ ∀ (m n k : ℕ), (m + n % k) % k = (m + n) % k
m n k : ℕ	⊢ (m + n % k) % k = (m + n) % k
⊢ ∀ {a b : ℕ}, a ∣ b → b / a = 0 → b = 0
a b : ℕ,	w : a ∣ b,	h : b / a = 0	⊢ b = 0
⊢ ∀ {a b : ℕ}, a / b = a ↔ a = 0 ∨ b = 1
a b : ℕ	⊢ a / b = a ↔ a = 0 ∨ b = 1
2 goals	a b : ℕ	⊢ a / b = a → a = 0 ∨ b = 1		a b : ℕ	⊢ a = 0 ∨ b = 1 → a / b = a
2 goals	a b : ℕ,	ᾰ : a / b = a	⊢ a = 0 ∨ b = 1		a b : ℕ	⊢ a = 0 ∨ b = 1 → a / b = a
3 goals	case nat.zero	a : ℕ,	ᾰ : a / 0 = a	⊢ a = 0 ∨ 0 = 1		case nat.succ	a b : ℕ,	ᾰ : a / b.succ = a	⊢ a = 0 ∨ b.succ = 1		a b : ℕ	⊢ a = 0 ∨ b = 1 → a / b = a
2 goals	case nat.succ	a b : ℕ,	ᾰ : a / b.succ = a	⊢ a = 0 ∨ b.succ = 1		a b : ℕ	⊢ a = 0 ∨ b = 1 → a / b = a
3 goals	case nat.succ, nat.zero	a : ℕ,	ᾰ : a / 1 = a	⊢ a = 0 ∨ 1 = 1		case nat.succ, nat.succ	a b : ℕ,	ᾰ : a / b.succ.succ = a	⊢ a = 0 ∨ b.succ.succ = 1		a b : ℕ	⊢ a = 0 ∨ b = 1 → a / b = a
3 goals	a : ℕ,	ᾰ : a / 1 = a	⊢ 1 = 1		case nat.succ, nat.succ	a b : ℕ,	ᾰ : a / b.succ.succ = a	⊢ a = 0 ∨ b.succ.succ = 1		a b : ℕ	⊢ a = 0 ∨ b = 1 → a / b = a
2 goals	case nat.succ, nat.succ	a b : ℕ,	ᾰ : a / b.succ.succ = a	⊢ a = 0 ∨ b.succ.succ = 1		a b : ℕ	⊢ a = 0 ∨ b = 1 → a / b = a
2 goals	a b : ℕ,	ᾰ : a / b.succ.succ = a	⊢ a = 0		a b : ℕ	⊢ a = 0 ∨ b = 1 → a / b = a
2 goals	a b : ℕ,	ᾰ : a / b.succ.succ = a,	this : a / (b + 2) ≤ a / 2	⊢ a = 0		a b : ℕ	⊢ a = 0 ∨ b = 1 → a / b = a
2 goals	a b : ℕ,	ᾰ : a / b.succ.succ = a,	this : a / (b + 2) ≤ a / 2	⊢ a ≤ a / 2		a b : ℕ	⊢ a = 0 ∨ b = 1 → a / b = a
a b : ℕ	⊢ a = 0 ∨ b = 1 → a / b = a
2 goals	b : ℕ	⊢ 0 / b = 0		a : ℕ	⊢ a / 1 = a
a : ℕ	⊢ a / 1 = a
⊢ ∀ {a b c : ℕ}, a + b ≤ c → a ≤ c
a b c : ℕ,	h : a + b ≤ c	⊢ a ≤ c
a b c : ℕ,	h : a + b ≤ c	⊢ a ≤ a + b
⊢ ∀ (n : ℕ), (1 + n).pred = n
n : ℕ	⊢ (1 + n).pred = n
⊢ ∀ {n m : ℕ} (i : ℕ),	    n.test_bit i = ff → m.test_bit i = tt → (∀ (j : ℕ), i < j → n.test_bit j = m.test_bit j) → n < m
n m i : ℕ,	hn : n.test_bit i = ff,	hm : m.test_bit i = tt,	hnm : ∀ (j : ℕ), i < j → n.test_bit j = m.test_bit j	⊢ n < m
2 goals	case z	i m : ℕ,	hn : 0.test_bit i = ff,	hm : m.test_bit i = tt,	hnm : ∀ (j : ℕ), i < j → 0.test_bit j = m.test_bit j	⊢ 0 < m		case f	b : bool,	n : ℕ,	hn' :	  ∀ (i : ℕ) {m : ℕ},	    n.test_bit i = ff → m.test_bit i = tt → (∀ (j : ℕ), i < j → n.test_bit j = m.test_bit j) → n < m,	i m : ℕ,	hn : (bit b n).test_bit i = ff,	hm : m.test_bit i = tt,	hnm : ∀ (j : ℕ), i < j → (bit b n).test_bit j = m.test_bit j	⊢ bit b n < m
2 goals	i m : ℕ,	hn : 0.test_bit i = ff,	hnm : ∀ (j : ℕ), i < j → 0.test_bit j = m.test_bit j,	hm : m ≤ 0	⊢ m.test_bit i ≠ tt		case f	b : bool,	n : ℕ,	hn' :	  ∀ (i : ℕ) {m : ℕ},	    n.test_bit i = ff → m.test_bit i = tt → (∀ (j : ℕ), i < j → n.test_bit j = m.test_bit j) → n < m,	i m : ℕ,	hn : (bit b n).test_bit i = ff,	hm : m.test_bit i = tt,	hnm : ∀ (j : ℕ), i < j → (bit b n).test_bit j = m.test_bit j	⊢ bit b n < m
2 goals	i m : ℕ,	hn : 0.test_bit i = ff,	hnm : ∀ (j : ℕ), i < j → 0.test_bit j = m.test_bit j,	hm : m = 0	⊢ m.test_bit i ≠ tt		case f	b : bool,	n : ℕ,	hn' :	  ∀ (i : ℕ) {m : ℕ},	    n.test_bit i = ff → m.test_bit i = tt → (∀ (j : ℕ), i < j → n.test_bit j = m.test_bit j) → n < m,	i m : ℕ,	hn : (bit b n).test_bit i = ff,	hm : m.test_bit i = tt,	hnm : ∀ (j : ℕ), i < j → (bit b n).test_bit j = m.test_bit j	⊢ bit b n < m
case f	b : bool,	n : ℕ,	hn' :	  ∀ (i : ℕ) {m : ℕ},	    n.test_bit i = ff → m.test_bit i = tt → (∀ (j : ℕ), i < j → n.test_bit j = m.test_bit j) → n < m,	i m : ℕ,	hn : (bit b n).test_bit i = ff,	hm : m.test_bit i = tt,	hnm : ∀ (j : ℕ), i < j → (bit b n).test_bit j = m.test_bit j	⊢ bit b n < m
2 goals	case f, z	b : bool,	n : ℕ,	hn' :	  ∀ (i : ℕ) {m : ℕ},	    n.test_bit i = ff → m.test_bit i = tt → (∀ (j : ℕ), i < j → n.test_bit j = m.test_bit j) → n < m,	i : ℕ,	hn : (bit b n).test_bit i = ff,	hm : 0.test_bit i = tt,	hnm : ∀ (j : ℕ), i < j → (bit b n).test_bit j = 0.test_bit j	⊢ bit b n < 0		case f, f	b : bool,	n : ℕ,	hn' :	  ∀ (i : ℕ) {m : ℕ},	    n.test_bit i = ff → m.test_bit i = tt → (∀ (j : ℕ), i < j → n.test_bit j = m.test_bit j) → n < m,	b' : bool,	m : ℕ,	hm' :	  ∀ (i : ℕ),	    (bit b n).test_bit i = ff →	    m.test_bit i = tt → (∀ (j : ℕ), i < j → (bit b n).test_bit j = m.test_bit j) → bit b n < m,	i : ℕ,	hn : (bit b n).test_bit i = ff,	hm : (bit b' m).test_bit i = tt,	hnm : ∀ (j : ℕ), i < j → (bit b n).test_bit j = (bit b' m).test_bit j	⊢ bit b n < bit b' m
case f, f	b : bool,	n : ℕ,	hn' :	  ∀ (i : ℕ) {m : ℕ},	    n.test_bit i = ff → m.test_bit i = tt → (∀ (j : ℕ), i < j → n.test_bit j = m.test_bit j) → n < m,	b' : bool,	m : ℕ,	hm' :	  ∀ (i : ℕ),	    (bit b n).test_bit i = ff →	    m.test_bit i = tt → (∀ (j : ℕ), i < j → (bit b n).test_bit j = m.test_bit j) → bit b n < m,	i : ℕ,	hn : (bit b n).test_bit i = ff,	hm : (bit b' m).test_bit i = tt,	hnm : ∀ (j : ℕ), i < j → (bit b n).test_bit j = (bit b' m).test_bit j	⊢ bit b n < bit b' m
2 goals	b : bool,	n : ℕ,	hn' :	  ∀ (i : ℕ) {m : ℕ},	    n.test_bit i = ff → m.test_bit i = tt → (∀ (j : ℕ), i < j → n.test_bit j = m.test_bit j) → n < m,	b' : bool,	m : ℕ,	hm' :	  ∀ (i : ℕ),	    (bit b n).test_bit i = ff →	    m.test_bit i = tt → (∀ (j : ℕ), i < j → (bit b n).test_bit j = m.test_bit j) → bit b n < m,	i : ℕ,	hn : (bit b n).test_bit i = ff,	hm : (bit b' m).test_bit i = tt,	hnm : ∀ (j : ℕ), i < j → (bit b n).test_bit j = (bit b' m).test_bit j,	hi : i = 0	⊢ bit b n < bit b' m		b : bool,	n : ℕ,	hn' :	  ∀ (i : ℕ) {m : ℕ},	    n.test_bit i = ff → m.test_bit i = tt → (∀ (j : ℕ), i < j → n.test_bit j = m.test_bit j) → n < m,	b' : bool,	m : ℕ,	hm' :	  ∀ (i : ℕ),	    (bit b n).test_bit i = ff →	    m.test_bit i = tt → (∀ (j : ℕ), i < j → (bit b n).test_bit j = m.test_bit j) → bit b n < m,	i : ℕ,	hn : (bit b n).test_bit i = ff,	hm : (bit b' m).test_bit i = tt,	hnm : ∀ (j : ℕ), i < j → (bit b n).test_bit j = (bit b' m).test_bit j,	hi : ¬i = 0	⊢ bit b n < bit b' m
2 goals	b : bool,	n : ℕ,	hn' :	  ∀ (i : ℕ) {m : ℕ},	    n.test_bit i = ff → m.test_bit i = tt → (∀ (j : ℕ), i < j → n.test_bit j = m.test_bit j) → n < m,	b' : bool,	m : ℕ,	hm' :	  ∀ (i : ℕ),	    (bit b n).test_bit i = ff →	    m.test_bit i = tt → (∀ (j : ℕ), i < j → (bit b n).test_bit j = m.test_bit j) → bit b n < m,	hn : (bit b n).test_bit 0 = ff,	hm : (bit b' m).test_bit 0 = tt,	hnm : ∀ (j : ℕ), 0 < j → (bit b n).test_bit j = (bit b' m).test_bit j	⊢ bit b n < bit b' m		b : bool,	n : ℕ,	hn' :	  ∀ (i : ℕ) {m : ℕ},	    n.test_bit i = ff → m.test_bit i = tt → (∀ (j : ℕ), i < j → n.test_bit j = m.test_bit j) → n < m,	b' : bool,	m : ℕ,	hm' :	  ∀ (i : ℕ),	    (bit b n).test_bit i = ff →	    m.test_bit i = tt → (∀ (j : ℕ), i < j → (bit b n).test_bit j = m.test_bit j) → bit b n < m,	i : ℕ,	hn : (bit b n).test_bit i = ff,	hm : (bit b' m).test_bit i = tt,	hnm : ∀ (j : ℕ), i < j → (bit b n).test_bit j = (bit b' m).test_bit j,	hi : ¬i = 0	⊢ bit b n < bit b' m
2 goals	b : bool,	n : ℕ,	hn' :	  ∀ (i : ℕ) {m : ℕ},	    n.test_bit i = ff → m.test_bit i = tt → (∀ (j : ℕ), i < j → n.test_bit j = m.test_bit j) → n < m,	b' : bool,	m : ℕ,	hm' :	  ∀ (i : ℕ),	    (bit b n).test_bit i = ff →	    m.test_bit i = tt → (∀ (j : ℕ), i < j → (bit b n).test_bit j = m.test_bit j) → bit b n < m,	hnm : ∀ (j : ℕ), 0 < j → (bit b n).test_bit j = (bit b' m).test_bit j,	hm : b' = tt,	hn : b = ff	⊢ bit b n < bit b' m		b : bool,	n : ℕ,	hn' :	  ∀ (i : ℕ) {m : ℕ},	    n.test_bit i = ff → m.test_bit i = tt → (∀ (j : ℕ), i < j → n.test_bit j = m.test_bit j) → n < m,	b' : bool,	m : ℕ,	hm' :	  ∀ (i : ℕ),	    (bit b n).test_bit i = ff →	    m.test_bit i = tt → (∀ (j : ℕ), i < j → (bit b n).test_bit j = m.test_bit j) → bit b n < m,	i : ℕ,	hn : (bit b n).test_bit i = ff,	hm : (bit b' m).test_bit i = tt,	hnm : ∀ (j : ℕ), i < j → (bit b n).test_bit j = (bit b' m).test_bit j,	hi : ¬i = 0	⊢ bit b n < bit b' m
3 goals	b : bool,	n : ℕ,	hn' :	  ∀ (i : ℕ) {m : ℕ},	    n.test_bit i = ff → m.test_bit i = tt → (∀ (j : ℕ), i < j → n.test_bit j = m.test_bit j) → n < m,	b' : bool,	m : ℕ,	hm' :	  ∀ (i : ℕ),	    (bit b n).test_bit i = ff →	    m.test_bit i = tt → (∀ (j : ℕ), i < j → (bit b n).test_bit j = m.test_bit j) → bit b n < m,	hnm : ∀ (j : ℕ), 0 < j → (bit b n).test_bit j = (bit b' m).test_bit j,	hm : b' = tt,	hn : b = ff	⊢ n = m		b : bool,	n : ℕ,	hn' :	  ∀ (i : ℕ) {m : ℕ},	    n.test_bit i = ff → m.test_bit i = tt → (∀ (j : ℕ), i < j → n.test_bit j = m.test_bit j) → n < m,	b' : bool,	m : ℕ,	hm' :	  ∀ (i : ℕ),	    (bit b n).test_bit i = ff →	    m.test_bit i = tt → (∀ (j : ℕ), i < j → (bit b n).test_bit j = m.test_bit j) → bit b n < m,	hnm : ∀ (j : ℕ), 0 < j → (bit b n).test_bit j = (bit b' m).test_bit j,	hm : b' = tt,	hn : b = ff,	this : n = m	⊢ bit b n < bit b' m		b : bool,	n : ℕ,	hn' :	  ∀ (i : ℕ) {m : ℕ},	    n.test_bit i = ff → m.test_bit i = tt → (∀ (j : ℕ), i < j → n.test_bit j = m.test_bit j) → n < m,	b' : bool,	m : ℕ,	hm' :	  ∀ (i : ℕ),	    (bit b n).test_bit i = ff →	    m.test_bit i = tt → (∀ (j : ℕ), i < j → (bit b n).test_bit j = m.test_bit j) → bit b n < m,	i : ℕ,	hn : (bit b n).test_bit i = ff,	hm : (bit b' m).test_bit i = tt,	hnm : ∀ (j : ℕ), i < j → (bit b n).test_bit j = (bit b' m).test_bit j,	hi : ¬i = 0	⊢ bit b n < bit b' m
2 goals	b : bool,	n : ℕ,	hn' :	  ∀ (i : ℕ) {m : ℕ},	    n.test_bit i = ff → m.test_bit i = tt → (∀ (j : ℕ), i < j → n.test_bit j = m.test_bit j) → n < m,	b' : bool,	m : ℕ,	hm' :	  ∀ (i : ℕ),	    (bit b n).test_bit i = ff →	    m.test_bit i = tt → (∀ (j : ℕ), i < j → (bit b n).test_bit j = m.test_bit j) → bit b n < m,	hnm : ∀ (j : ℕ), 0 < j → (bit b n).test_bit j = (bit b' m).test_bit j,	hm : b' = tt,	hn : b = ff,	this : n = m	⊢ bit b n < bit b' m		b : bool,	n : ℕ,	hn' :	  ∀ (i : ℕ) {m : ℕ},	    n.test_bit i = ff → m.test_bit i = tt → (∀ (j : ℕ), i < j → n.test_bit j = m.test_bit j) → n < m,	b' : bool,	m : ℕ,	hm' :	  ∀ (i : ℕ),	    (bit b n).test_bit i = ff →	    m.test_bit i = tt → (∀ (j : ℕ), i < j → (bit b n).test_bit j = m.test_bit j) → bit b n < m,	i : ℕ,	hn : (bit b n).test_bit i = ff,	hm : (bit b' m).test_bit i = tt,	hnm : ∀ (j : ℕ), i < j → (bit b n).test_bit j = (bit b' m).test_bit j,	hi : ¬i = 0	⊢ bit b n < bit b' m
2 goals	b : bool,	n : ℕ,	hn' :	  ∀ (i : ℕ) {m : ℕ},	    n.test_bit i = ff → m.test_bit i = tt → (∀ (j : ℕ), i < j → n.test_bit j = m.test_bit j) → n < m,	b' : bool,	m : ℕ,	hm' :	  ∀ (i : ℕ),	    (bit b n).test_bit i = ff →	    m.test_bit i = tt → (∀ (j : ℕ), i < j → (bit b n).test_bit j = m.test_bit j) → bit b n < m,	hnm : ∀ (j : ℕ), 0 < j → (bit b n).test_bit j = (bit b' m).test_bit j,	hm : b' = tt,	hn : b = ff,	this : n = m	⊢ 2 * m < 2 * m + 1		b : bool,	n : ℕ,	hn' :	  ∀ (i : ℕ) {m : ℕ},	    n.test_bit i = ff → m.test_bit i = tt → (∀ (j : ℕ), i < j → n.test_bit j = m.test_bit j) → n < m,	b' : bool,	m : ℕ,	hm' :	  ∀ (i : ℕ),	    (bit b n).test_bit i = ff →	    m.test_bit i = tt → (∀ (j : ℕ), i < j → (bit b n).test_bit j = m.test_bit j) → bit b n < m,	i : ℕ,	hn : (bit b n).test_bit i = ff,	hm : (bit b' m).test_bit i = tt,	hnm : ∀ (j : ℕ), i < j → (bit b n).test_bit j = (bit b' m).test_bit j,	hi : ¬i = 0	⊢ bit b n < bit b' m
b : bool,	n : ℕ,	hn' :	  ∀ (i : ℕ) {m : ℕ},	    n.test_bit i = ff → m.test_bit i = tt → (∀ (j : ℕ), i < j → n.test_bit j = m.test_bit j) → n < m,	b' : bool,	m : ℕ,	hm' :	  ∀ (i : ℕ),	    (bit b n).test_bit i = ff →	    m.test_bit i = tt → (∀ (j : ℕ), i < j → (bit b n).test_bit j = m.test_bit j) → bit b n < m,	i : ℕ,	hn : (bit b n).test_bit i = ff,	hm : (bit b' m).test_bit i = tt,	hnm : ∀ (j : ℕ), i < j → (bit b n).test_bit j = (bit b' m).test_bit j,	hi : ¬i = 0	⊢ bit b n < bit b' m
b : bool,	n : ℕ,	hn' :	  ∀ (i : ℕ) {m : ℕ},	    n.test_bit i = ff → m.test_bit i = tt → (∀ (j : ℕ), i < j → n.test_bit j = m.test_bit j) → n < m,	b' : bool,	m : ℕ,	hm' :	  ∀ (i : ℕ),	    (bit b n).test_bit i = ff →	    m.test_bit i = tt → (∀ (j : ℕ), i < j → (bit b n).test_bit j = m.test_bit j) → bit b n < m,	i' : ℕ,	hn : (bit b n).test_bit i'.succ = ff,	hm : (bit b' m).test_bit i'.succ = tt,	hnm : ∀ (j : ℕ), i'.succ < j → (bit b n).test_bit j = (bit b' m).test_bit j,	hi : ¬i'.succ = 0	⊢ bit b n < bit b' m
b : bool,	n : ℕ,	hn' :	  ∀ (i : ℕ) {m : ℕ},	    n.test_bit i = ff → m.test_bit i = tt → (∀ (j : ℕ), i < j → n.test_bit j = m.test_bit j) → n < m,	b' : bool,	m : ℕ,	hm' :	  ∀ (i : ℕ),	    (bit b n).test_bit i = ff →	    m.test_bit i = tt → (∀ (j : ℕ), i < j → (bit b n).test_bit j = m.test_bit j) → bit b n < m,	i' : ℕ,	hnm : ∀ (j : ℕ), i'.succ < j → (bit b n).test_bit j = (bit b' m).test_bit j,	hi : ¬i'.succ = 0,	hm : m.test_bit i' = tt,	hn : n.test_bit i' = ff	⊢ bit b n < bit b' m
b : bool,	n : ℕ,	hn' :	  ∀ (i : ℕ) {m : ℕ},	    n.test_bit i = ff → m.test_bit i = tt → (∀ (j : ℕ), i < j → n.test_bit j = m.test_bit j) → n < m,	b' : bool,	m : ℕ,	hm' :	  ∀ (i : ℕ),	    (bit b n).test_bit i = ff →	    m.test_bit i = tt → (∀ (j : ℕ), i < j → (bit b n).test_bit j = m.test_bit j) → bit b n < m,	i' : ℕ,	hnm : ∀ (j : ℕ), i'.succ < j → (bit b n).test_bit j = (bit b' m).test_bit j,	hi : ¬i'.succ = 0,	hm : m.test_bit i' = tt,	hn : n.test_bit i' = ff,	this : n < m	⊢ bit b n < bit b' m
2 goals	case bool.ff	n : ℕ,	hn' :	  ∀ (i : ℕ) {m : ℕ},	    n.test_bit i = ff → m.test_bit i = tt → (∀ (j : ℕ), i < j → n.test_bit j = m.test_bit j) → n < m,	b' : bool,	m i' : ℕ,	hi : ¬i'.succ = 0,	hm : m.test_bit i' = tt,	hn : n.test_bit i' = ff,	this : n < m,	hm' :	  ∀ (i : ℕ),	    (bit ff n).test_bit i = ff →	    m.test_bit i = tt → (∀ (j : ℕ), i < j → (bit ff n).test_bit j = m.test_bit j) → bit ff n < m,	hnm : ∀ (j : ℕ), i'.succ < j → (bit ff n).test_bit j = (bit b' m).test_bit j	⊢ bit ff n < bit b' m		case bool.tt	n : ℕ,	hn' :	  ∀ (i : ℕ) {m : ℕ},	    n.test_bit i = ff → m.test_bit i = tt → (∀ (j : ℕ), i < j → n.test_bit j = m.test_bit j) → n < m,	b' : bool,	m i' : ℕ,	hi : ¬i'.succ = 0,	hm : m.test_bit i' = tt,	hn : n.test_bit i' = ff,	this : n < m,	hm' :	  ∀ (i : ℕ),	    (bit tt n).test_bit i = ff →	    m.test_bit i = tt → (∀ (j : ℕ), i < j → (bit tt n).test_bit j = m.test_bit j) → bit tt n < m,	hnm : ∀ (j : ℕ), i'.succ < j → (bit tt n).test_bit j = (bit b' m).test_bit j	⊢ bit tt n < bit b' m
3 goals	case bool.ff, bool.ff	n : ℕ,	hn' :	  ∀ (i : ℕ) {m : ℕ},	    n.test_bit i = ff → m.test_bit i = tt → (∀ (j : ℕ), i < j → n.test_bit j = m.test_bit j) → n < m,	m i' : ℕ,	hi : ¬i'.succ = 0,	hm : m.test_bit i' = tt,	hn : n.test_bit i' = ff,	this : n < m,	hm' :	  ∀ (i : ℕ),	    (bit ff n).test_bit i = ff →	    m.test_bit i = tt → (∀ (j : ℕ), i < j → (bit ff n).test_bit j = m.test_bit j) → bit ff n < m,	hnm : ∀ (j : ℕ), i'.succ < j → (bit ff n).test_bit j = (bit ff m).test_bit j	⊢ bit ff n < bit ff m		case bool.ff, bool.tt	n : ℕ,	hn' :	  ∀ (i : ℕ) {m : ℕ},	    n.test_bit i = ff → m.test_bit i = tt → (∀ (j : ℕ), i < j → n.test_bit j = m.test_bit j) → n < m,	m i' : ℕ,	hi : ¬i'.succ = 0,	hm : m.test_bit i' = tt,	hn : n.test_bit i' = ff,	this : n < m,	hm' :	  ∀ (i : ℕ),	    (bit ff n).test_bit i = ff →	    m.test_bit i = tt → (∀ (j : ℕ), i < j → (bit ff n).test_bit j = m.test_bit j) → bit ff n < m,	hnm : ∀ (j : ℕ), i'.succ < j → (bit ff n).test_bit j = (bit tt m).test_bit j	⊢ bit ff n < bit tt m		case bool.tt	n : ℕ,	hn' :	  ∀ (i : ℕ) {m : ℕ},	    n.test_bit i = ff → m.test_bit i = tt → (∀ (j : ℕ), i < j → n.test_bit j = m.test_bit j) → n < m,	b' : bool,	m i' : ℕ,	hi : ¬i'.succ = 0,	hm : m.test_bit i' = tt,	hn : n.test_bit i' = ff,	this : n < m,	hm' :	  ∀ (i : ℕ),	    (bit tt n).test_bit i = ff →	    m.test_bit i = tt → (∀ (j : ℕ), i < j → (bit tt n).test_bit j = m.test_bit j) → bit tt n < m,	hnm : ∀ (j : ℕ), i'.succ < j → (bit tt n).test_bit j = (bit b' m).test_bit j	⊢ bit tt n < bit b' m
3 goals	case bool.ff, bool.ff	n : ℕ,	hn' :	  ∀ (i : ℕ) {m : ℕ},	    n.test_bit i = ff → m.test_bit i = tt → (∀ (j : ℕ), i < j → n.test_bit j = m.test_bit j) → n < m,	m i' : ℕ,	hi : ¬i'.succ = 0,	hm : m.test_bit i' = tt,	hn : n.test_bit i' = ff,	this : n < m,	hm' :	  ∀ (i : ℕ),	    (bit ff n).test_bit i = ff →	    m.test_bit i = tt → (∀ (j : ℕ), i < j → (bit ff n).test_bit j = m.test_bit j) → bit ff n < m,	hnm : ∀ (j : ℕ), i'.succ < j → (bit ff n).test_bit j = (bit ff m).test_bit j	⊢ 2 * n < 2 * m		case bool.ff, bool.tt	n : ℕ,	hn' :	  ∀ (i : ℕ) {m : ℕ},	    n.test_bit i = ff → m.test_bit i = tt → (∀ (j : ℕ), i < j → n.test_bit j = m.test_bit j) → n < m,	m i' : ℕ,	hi : ¬i'.succ = 0,	hm : m.test_bit i' = tt,	hn : n.test_bit i' = ff,	this : n < m,	hm' :	  ∀ (i : ℕ),	    (bit ff n).test_bit i = ff →	    m.test_bit i = tt → (∀ (j : ℕ), i < j → (bit ff n).test_bit j = m.test_bit j) → bit ff n < m,	hnm : ∀ (j : ℕ), i'.succ < j → (bit ff n).test_bit j = (bit tt m).test_bit j	⊢ bit ff n < bit tt m		case bool.tt	n : ℕ,	hn' :	  ∀ (i : ℕ) {m : ℕ},	    n.test_bit i = ff → m.test_bit i = tt → (∀ (j : ℕ), i < j → n.test_bit j = m.test_bit j) → n < m,	b' : bool,	m i' : ℕ,	hi : ¬i'.succ = 0,	hm : m.test_bit i' = tt,	hn : n.test_bit i' = ff,	this : n < m,	hm' :	  ∀ (i : ℕ),	    (bit tt n).test_bit i = ff →	    m.test_bit i = tt → (∀ (j : ℕ), i < j → (bit tt n).test_bit j = m.test_bit j) → bit tt n < m,	hnm : ∀ (j : ℕ), i'.succ < j → (bit tt n).test_bit j = (bit b' m).test_bit j	⊢ bit tt n < bit b' m
2 goals	case bool.ff, bool.tt	n : ℕ,	hn' :	  ∀ (i : ℕ) {m : ℕ},	    n.test_bit i = ff → m.test_bit i = tt → (∀ (j : ℕ), i < j → n.test_bit j = m.test_bit j) → n < m,	m i' : ℕ,	hi : ¬i'.succ = 0,	hm : m.test_bit i' = tt,	hn : n.test_bit i' = ff,	this : n < m,	hm' :	  ∀ (i : ℕ),	    (bit ff n).test_bit i = ff →	    m.test_bit i = tt → (∀ (j : ℕ), i < j → (bit ff n).test_bit j = m.test_bit j) → bit ff n < m,	hnm : ∀ (j : ℕ), i'.succ < j → (bit ff n).test_bit j = (bit tt m).test_bit j	⊢ bit ff n < bit tt m		case bool.tt	n : ℕ,	hn' :	  ∀ (i : ℕ) {m : ℕ},	    n.test_bit i = ff → m.test_bit i = tt → (∀ (j : ℕ), i < j → n.test_bit j = m.test_bit j) → n < m,	b' : bool,	m i' : ℕ,	hi : ¬i'.succ = 0,	hm : m.test_bit i' = tt,	hn : n.test_bit i' = ff,	this : n < m,	hm' :	  ∀ (i : ℕ),	    (bit tt n).test_bit i = ff →	    m.test_bit i = tt → (∀ (j : ℕ), i < j → (bit tt n).test_bit j = m.test_bit j) → bit tt n < m,	hnm : ∀ (j : ℕ), i'.succ < j → (bit tt n).test_bit j = (bit b' m).test_bit j	⊢ bit tt n < bit b' m
2 goals	case bool.ff, bool.tt	n : ℕ,	hn' :	  ∀ (i : ℕ) {m : ℕ},	    n.test_bit i = ff → m.test_bit i = tt → (∀ (j : ℕ), i < j → n.test_bit j = m.test_bit j) → n < m,	m i' : ℕ,	hi : ¬i'.succ = 0,	hm : m.test_bit i' = tt,	hn : n.test_bit i' = ff,	this : n < m,	hm' :	  ∀ (i : ℕ),	    (bit ff n).test_bit i = ff →	    m.test_bit i = tt → (∀ (j : ℕ), i < j → (bit ff n).test_bit j = m.test_bit j) → bit ff n < m,	hnm : ∀ (j : ℕ), i'.succ < j → (bit ff n).test_bit j = (bit tt m).test_bit j	⊢ 2 * n < 2 * m + 1		case bool.tt	n : ℕ,	hn' :	  ∀ (i : ℕ) {m : ℕ},	    n.test_bit i = ff → m.test_bit i = tt → (∀ (j : ℕ), i < j → n.test_bit j = m.test_bit j) → n < m,	b' : bool,	m i' : ℕ,	hi : ¬i'.succ = 0,	hm : m.test_bit i' = tt,	hn : n.test_bit i' = ff,	this : n < m,	hm' :	  ∀ (i : ℕ),	    (bit tt n).test_bit i = ff →	    m.test_bit i = tt → (∀ (j : ℕ), i < j → (bit tt n).test_bit j = m.test_bit j) → bit tt n < m,	hnm : ∀ (j : ℕ), i'.succ < j → (bit tt n).test_bit j = (bit b' m).test_bit j	⊢ bit tt n < bit b' m
case bool.tt	n : ℕ,	hn' :	  ∀ (i : ℕ) {m : ℕ},	    n.test_bit i = ff → m.test_bit i = tt → (∀ (j : ℕ), i < j → n.test_bit j = m.test_bit j) → n < m,	b' : bool,	m i' : ℕ,	hi : ¬i'.succ = 0,	hm : m.test_bit i' = tt,	hn : n.test_bit i' = ff,	this : n < m,	hm' :	  ∀ (i : ℕ),	    (bit tt n).test_bit i = ff →	    m.test_bit i = tt → (∀ (j : ℕ), i < j → (bit tt n).test_bit j = m.test_bit j) → bit tt n < m,	hnm : ∀ (j : ℕ), i'.succ < j → (bit tt n).test_bit j = (bit b' m).test_bit j	⊢ bit tt n < bit b' m
2 goals	case bool.tt, bool.ff	n : ℕ,	hn' :	  ∀ (i : ℕ) {m : ℕ},	    n.test_bit i = ff → m.test_bit i = tt → (∀ (j : ℕ), i < j → n.test_bit j = m.test_bit j) → n < m,	m i' : ℕ,	hi : ¬i'.succ = 0,	hm : m.test_bit i' = tt,	hn : n.test_bit i' = ff,	this : n < m,	hm' :	  ∀ (i : ℕ),	    (bit tt n).test_bit i = ff →	    m.test_bit i = tt → (∀ (j : ℕ), i < j → (bit tt n).test_bit j = m.test_bit j) → bit tt n < m,	hnm : ∀ (j : ℕ), i'.succ < j → (bit tt n).test_bit j = (bit ff m).test_bit j	⊢ bit tt n < bit ff m		case bool.tt, bool.tt	n : ℕ,	hn' :	  ∀ (i : ℕ) {m : ℕ},	    n.test_bit i = ff → m.test_bit i = tt → (∀ (j : ℕ), i < j → n.test_bit j = m.test_bit j) → n < m,	m i' : ℕ,	hi : ¬i'.succ = 0,	hm : m.test_bit i' = tt,	hn : n.test_bit i' = ff,	this : n < m,	hm' :	  ∀ (i : ℕ),	    (bit tt n).test_bit i = ff →	    m.test_bit i = tt → (∀ (j : ℕ), i < j → (bit tt n).test_bit j = m.test_bit j) → bit tt n < m,	hnm : ∀ (j : ℕ), i'.succ < j → (bit tt n).test_bit j = (bit tt m).test_bit j	⊢ bit tt n < bit tt m
2 goals	case bool.tt, bool.ff	n : ℕ,	hn' :	  ∀ (i : ℕ) {m : ℕ},	    n.test_bit i = ff → m.test_bit i = tt → (∀ (j : ℕ), i < j → n.test_bit j = m.test_bit j) → n < m,	m i' : ℕ,	hi : ¬i'.succ = 0,	hm : m.test_bit i' = tt,	hn : n.test_bit i' = ff,	this : n < m,	hm' :	  ∀ (i : ℕ),	    (bit tt n).test_bit i = ff →	    m.test_bit i = tt → (∀ (j : ℕ), i < j → (bit tt n).test_bit j = m.test_bit j) → bit tt n < m,	hnm : ∀ (j : ℕ), i'.succ < j → (bit tt n).test_bit j = (bit ff m).test_bit j	⊢ 2 * n + 1 < 2 * m		case bool.tt, bool.tt	n : ℕ,	hn' :	  ∀ (i : ℕ) {m : ℕ},	    n.test_bit i = ff → m.test_bit i = tt → (∀ (j : ℕ), i < j → n.test_bit j = m.test_bit j) → n < m,	m i' : ℕ,	hi : ¬i'.succ = 0,	hm : m.test_bit i' = tt,	hn : n.test_bit i' = ff,	this : n < m,	hm' :	  ∀ (i : ℕ),	    (bit tt n).test_bit i = ff →	    m.test_bit i = tt → (∀ (j : ℕ), i < j → (bit tt n).test_bit j = m.test_bit j) → bit tt n < m,	hnm : ∀ (j : ℕ), i'.succ < j → (bit tt n).test_bit j = (bit tt m).test_bit j	⊢ bit tt n < bit tt m
case bool.tt, bool.tt	n : ℕ,	hn' :	  ∀ (i : ℕ) {m : ℕ},	    n.test_bit i = ff → m.test_bit i = tt → (∀ (j : ℕ), i < j → n.test_bit j = m.test_bit j) → n < m,	m i' : ℕ,	hi : ¬i'.succ = 0,	hm : m.test_bit i' = tt,	hn : n.test_bit i' = ff,	this : n < m,	hm' :	  ∀ (i : ℕ),	    (bit tt n).test_bit i = ff →	    m.test_bit i = tt → (∀ (j : ℕ), i < j → (bit tt n).test_bit j = m.test_bit j) → bit tt n < m,	hnm : ∀ (j : ℕ), i'.succ < j → (bit tt n).test_bit j = (bit tt m).test_bit j	⊢ bit tt n < bit tt m
case bool.tt, bool.tt	n : ℕ,	hn' :	  ∀ (i : ℕ) {m : ℕ},	    n.test_bit i = ff → m.test_bit i = tt → (∀ (j : ℕ), i < j → n.test_bit j = m.test_bit j) → n < m,	m i' : ℕ,	hi : ¬i'.succ = 0,	hm : m.test_bit i' = tt,	hn : n.test_bit i' = ff,	this : n < m,	hm' :	  ∀ (i : ℕ),	    (bit tt n).test_bit i = ff →	    m.test_bit i = tt → (∀ (j : ℕ), i < j → (bit tt n).test_bit j = m.test_bit j) → bit tt n < m,	hnm : ∀ (j : ℕ), i'.succ < j → (bit tt n).test_bit j = (bit tt m).test_bit j	⊢ 2 * n + 1 < 2 * m + 1
⊢ ∀ {b : ℕ} {l1 l2 : list ℕ}, of_digits b (l1 ++ l2) = of_digits b l1 + b ^ l1.length * of_digits b l2
b : ℕ,	l1 l2 : list ℕ	⊢ of_digits b (l1 ++ l2) = of_digits b l1 + b ^ l1.length * of_digits b l2
2 goals	case list.nil	b : ℕ,	l2 : list ℕ	⊢ of_digits b (list.nil ++ l2) = of_digits b list.nil + b ^ list.nil.length * of_digits b l2		case list.cons	b : ℕ,	l2 : list ℕ,	hd : ℕ,	tl : list ℕ,	IH : of_digits b (tl ++ l2) = of_digits b tl + b ^ tl.length * of_digits b l2	⊢ of_digits b (hd :: tl ++ l2) = of_digits b (hd :: tl) + b ^ (hd :: tl).length * of_digits b l2
case list.cons	b : ℕ,	l2 : list ℕ,	hd : ℕ,	tl : list ℕ,	IH : of_digits b (tl ++ l2) = of_digits b tl + b ^ tl.length * of_digits b l2	⊢ of_digits b (hd :: tl ++ l2) = of_digits b (hd :: tl) + b ^ (hd :: tl).length * of_digits b l2
case list.cons	b : ℕ,	l2 : list ℕ,	hd : ℕ,	tl : list ℕ,	IH : of_digits b (tl ++ l2) = of_digits b tl + b ^ tl.length * of_digits b l2	⊢ ↑hd + b * (of_digits b tl + b ^ tl.length * of_digits b l2) =	    ↑hd + b * of_digits b tl + b ^ tl.length * b * of_digits b l2
⊢ ∀ (b n : ℕ), of_digits b (b.digits n) = n
b n : ℕ	⊢ of_digits b (b.digits n) = n
2 goals	case nat.zero	n : ℕ	⊢ of_digits 0 (0.digits n) = n		case nat.succ	n b : ℕ	⊢ of_digits b.succ (b.succ.digits n) = n
3 goals	case nat.zero, nat.zero	⊢ of_digits 0 (0.digits 0) = 0		case nat.zero, nat.succ	n : ℕ	⊢ of_digits 0 (0.digits n.succ) = n.succ		case nat.succ	n b : ℕ	⊢ of_digits b.succ (b.succ.digits n) = n
2 goals	case nat.zero, nat.succ	n : ℕ	⊢ of_digits 0 (0.digits n.succ) = n.succ		case nat.succ	n b : ℕ	⊢ of_digits b.succ (b.succ.digits n) = n
2 goals	n : ℕ	⊢ of_digits 0 [n + 1] = n + 1		case nat.succ	n b : ℕ	⊢ of_digits b.succ (b.succ.digits n) = n
2 goals	n : ℕ	⊢ ↑n + 1 + 0 * 0 = n + 1		case nat.succ	n b : ℕ	⊢ of_digits b.succ (b.succ.digits n) = n
case nat.succ	n b : ℕ	⊢ of_digits b.succ (b.succ.digits n) = n
2 goals	case nat.succ, nat.zero	n : ℕ	⊢ of_digits 1 (1.digits n) = n		case nat.succ, nat.succ	n b : ℕ	⊢ of_digits b.succ.succ (b.succ.succ.digits n) = n
3 goals	case nat.succ, nat.zero, nat.zero	⊢ of_digits 1 (1.digits 0) = 0		case nat.succ, nat.zero, nat.succ	n : ℕ,	ih : of_digits 1 (1.digits n) = n	⊢ of_digits 1 (1.digits n.succ) = n.succ		case nat.succ, nat.succ	n b : ℕ	⊢ of_digits b.succ.succ (b.succ.succ.digits n) = n
2 goals	case nat.succ, nat.zero, nat.succ	n : ℕ,	ih : of_digits 1 (1.digits n) = n	⊢ of_digits 1 (1.digits n.succ) = n.succ		case nat.succ, nat.succ	n b : ℕ	⊢ of_digits b.succ.succ (b.succ.succ.digits n) = n
case nat.succ, nat.succ	n b : ℕ	⊢ of_digits b.succ.succ (b.succ.succ.digits n) = n
n b : ℕ	⊢ ∀ (n : ℕ),	    (∀ (m : ℕ), m < n → of_digits b.succ.succ (b.succ.succ.digits m) = m) →	    of_digits b.succ.succ (b.succ.succ.digits n) = n
b : ℕ	⊢ ∀ (n : ℕ),	    (∀ (m : ℕ), m < n → of_digits b.succ.succ (b.succ.succ.digits m) = m) →	    of_digits b.succ.succ (b.succ.succ.digits n) = n
b n : ℕ,	h : ∀ (m : ℕ), m < n → of_digits b.succ.succ (b.succ.succ.digits m) = m	⊢ of_digits b.succ.succ (b.succ.succ.digits n) = n
2 goals	case nat.zero	b : ℕ,	h : ∀ (m : ℕ), m < 0 → of_digits b.succ.succ (b.succ.succ.digits m) = m	⊢ of_digits b.succ.succ (b.succ.succ.digits 0) = 0		case nat.succ	b n : ℕ,	h : ∀ (m : ℕ), m < n.succ → of_digits b.succ.succ (b.succ.succ.digits m) = m	⊢ of_digits b.succ.succ (b.succ.succ.digits n.succ) = n.succ
2 goals	case nat.zero	b : ℕ,	h : ∀ (m : ℕ), m < 0 → of_digits b.succ.succ (b.succ.succ.digits m) = m	⊢ of_digits b.succ.succ list.nil = 0		case nat.succ	b n : ℕ,	h : ∀ (m : ℕ), m < n.succ → of_digits b.succ.succ (b.succ.succ.digits m) = m	⊢ of_digits b.succ.succ (b.succ.succ.digits n.succ) = n.succ
case nat.succ	b n : ℕ,	h : ∀ (m : ℕ), m < n.succ → of_digits b.succ.succ (b.succ.succ.digits m) = m	⊢ of_digits b.succ.succ (b.succ.succ.digits n.succ) = n.succ
case nat.succ	b n : ℕ,	h : ∀ (m : ℕ), m < n.succ → of_digits b.succ.succ (b.succ.succ.digits m) = m	⊢ of_digits (b + 1 + 1) ((n + 1) % (b + 2) :: (b + 2).digits ((n + 1) / (b + 2))) = n + 1
b n : ℕ,	h : ∀ (m : ℕ), m < n.succ → of_digits b.succ.succ (b.succ.succ.digits m) = m	⊢ ↑((n + 1) % (b + 2)) + (b + 1 + 1) * of_digits (b + 1 + 1) ((b + 2).digits ((n + 1) / (b + 2))) = n + 1
b n : ℕ,	h : ∀ (m : ℕ), m < n.succ → of_digits b.succ.succ (b.succ.succ.digits m) = m	⊢ ↑((n + 1) % (b + 2)) + (b + 1 + 1) * ((n + 1) / (b + 2)) = n + 1
⊢ ∀ {b n : ℕ}, b.digits n = list.nil ↔ n = 0
b n : ℕ	⊢ b.digits n = list.nil ↔ n = 0
2 goals	b n : ℕ	⊢ b.digits n = list.nil → n = 0		b n : ℕ	⊢ n = 0 → b.digits n = list.nil
2 goals	b n : ℕ,	h : b.digits n = list.nil	⊢ n = 0		b n : ℕ	⊢ n = 0 → b.digits n = list.nil
3 goals	b n : ℕ,	h : b.digits n = list.nil	⊢ of_digits b (b.digits n) = of_digits b list.nil		b n : ℕ,	h : b.digits n = list.nil,	this : of_digits b (b.digits n) = of_digits b list.nil	⊢ n = 0		b n : ℕ	⊢ n = 0 → b.digits n = list.nil
2 goals	b n : ℕ,	h : b.digits n = list.nil,	this : of_digits b (b.digits n) = of_digits b list.nil	⊢ n = 0		b n : ℕ	⊢ n = 0 → b.digits n = list.nil
2 goals	b n : ℕ,	h : b.digits n = list.nil,	this : of_digits b (b.digits n) = of_digits b list.nil	⊢ n = of_digits b (b.digits n)		b n : ℕ	⊢ n = 0 → b.digits n = list.nil
b n : ℕ	⊢ n = 0 → b.digits n = list.nil
b : ℕ	⊢ b.digits 0 = list.nil
⊢ ∀ (b b' : ℕ) (c : ℤ), ↑b ∣ ↑b' - c → ∀ (n : ℕ), b ∣ n ↔ ↑b ∣ of_digits c (b'.digits n)
b b' : ℕ,	c : ℤ,	h : ↑b ∣ ↑b' - c,	n : ℕ	⊢ b ∣ n ↔ ↑b ∣ of_digits c (b'.digits n)
b b' : ℕ,	c : ℤ,	h : ↑b ∣ ↑b' - c,	n : ℕ	⊢ ↑b ∣ ↑n ↔ ↑b ∣ of_digits c (b'.digits n)
⊢ ∀ (n k m : ℕ), (n * k).dist (m * k) = n.dist m * k
n k m : ℕ	⊢ (n * k).dist (m * k) = n.dist m * k
⊢ ∀ {x y : ℕ}, ↑x = ↑y ↔ x = y
x y : ℕ	⊢ ↑x = ↑y ↔ x = y
⊢ ∀ (n : ℕ), n.coprime 0 ↔ n = 1
n : ℕ	⊢ n.coprime 0 ↔ n = 1
⊢ ∀ {p n r b : ℕ},	    prime p → log p n < b → (p ^ r ∣ n.factorial ↔ r ≤ (Ico 1 b).sum (λ (i : ℕ), n / p ^ i))
p n r b : ℕ,	hp : prime p,	hbn : log p n < b	⊢ p ^ r ∣ n.factorial ↔ r ≤ (Ico 1 b).sum (λ (i : ℕ), n / p ^ i)
⊢ ∀ {m n : ℕ}, n ≤ m → (even (m - n) ↔ (even m ↔ even n))
m n : ℕ,	h : n ≤ m	⊢ even (m - n) ↔ (even m ↔ even n)
m n : ℕ,	h : n ≤ m	⊢ even (m - n) ↔ (even (m - n) ↔ even n ↔ even n)
2 goals	m n : ℕ,	h : n ≤ m,	h : even n	⊢ even (m - n) ↔ (even (m - n) ↔ even n ↔ even n)		m n : ℕ,	h : n ≤ m,	h : ¬even n	⊢ even (m - n) ↔ (even (m - n) ↔ even n ↔ even n)
m n : ℕ,	h : n ≤ m,	h : ¬even n	⊢ even (m - n) ↔ (even (m - n) ↔ even n ↔ even n)
⊢ ∀ {m n : ℕ}, n ≤ m → (odd (m - n) ↔ (odd n ↔ even m))
m n : ℕ,	h : n ≤ m	⊢ odd (m - n) ↔ (odd n ↔ even m)
⊢ ∀ {n : ℕ}, ¬n % 2 = 1 ↔ n % 2 = 0
n : ℕ	⊢ ¬n % 2 = 1 ↔ n % 2 = 0
2 goals	case or.inl	n : ℕ,	h : n % 2 = 0	⊢ ¬n % 2 = 1 ↔ n % 2 = 0		case or.inr	n : ℕ,	h : n % 2 = 1	⊢ ¬n % 2 = 1 ↔ n % 2 = 0
case or.inr	n : ℕ,	h : n % 2 = 1	⊢ ¬n % 2 = 1 ↔ n % 2 = 0
⊢ ∀ (n : ℕ), n.factors = list.nil ↔ n = 0 ∨ n = 1
n : ℕ	⊢ n.factors = list.nil ↔ n = 0 ∨ n = 1
2 goals	n : ℕ	⊢ n.factors = list.nil → n = 0 ∨ n = 1		n : ℕ	⊢ n = 0 ∨ n = 1 → n.factors = list.nil
2 goals	n : ℕ,	h : n.factors = list.nil	⊢ n = 0 ∨ n = 1		n : ℕ	⊢ n = 0 ∨ n = 1 → n.factors = list.nil
4 goals	h : 0.factors = list.nil	⊢ 0 = 0 ∨ 0 = 1		h : 1.factors = list.nil	⊢ 1 = 0 ∨ 1 = 1		n : ℕ,	h : n.succ.succ.factors = list.nil	⊢ n.succ.succ = 0 ∨ n.succ.succ = 1		n : ℕ	⊢ n = 0 ∨ n = 1 → n.factors = list.nil
3 goals	h : 1.factors = list.nil	⊢ 1 = 0 ∨ 1 = 1		n : ℕ,	h : n.succ.succ.factors = list.nil	⊢ n.succ.succ = 0 ∨ n.succ.succ = 1		n : ℕ	⊢ n = 0 ∨ n = 1 → n.factors = list.nil
2 goals	n : ℕ,	h : n.succ.succ.factors = list.nil	⊢ n.succ.succ = 0 ∨ n.succ.succ = 1		n : ℕ	⊢ n = 0 ∨ n = 1 → n.factors = list.nil
2 goals	n : ℕ,	h : (let m : ℕ := (n + 2).min_fac in m :: ((n + 2) / m).factors) = list.nil	⊢ n.succ.succ = 0 ∨ n.succ.succ = 1		n : ℕ	⊢ n = 0 ∨ n = 1 → n.factors = list.nil
n : ℕ	⊢ n = 0 ∨ n = 1 → n.factors = list.nil
n : ℕ,	h : n = 0 ∨ n = 1	⊢ n.factors = list.nil
2 goals	⊢ 0.factors = list.nil		⊢ 1.factors = list.nil
⊢ 1.factors = list.nil
⊢ ∀ {a p k : ℕ}, prime p → ¬a ∣ p ^ k → a ∣ p ^ (k + 1) → a = p ^ (k + 1)
a p k : ℕ,	pp : prime p,	h₁ : ¬a ∣ p ^ k,	h₂ : a ∣ p ^ (k + 1)	⊢ a = p ^ (k + 1)
p k : ℕ,	pp : prime p,	l : ℕ,	h : l ≤ k + 1,	h₁ : ¬p ^ l ∣ p ^ k,	h₂ : p ^ l ∣ p ^ (k + 1)	⊢ p ^ l = p ^ (k + 1)
p k : ℕ,	pp : prime p,	l : ℕ,	h : l ≤ k + 1,	h₁ : ¬p ^ l ∣ p ^ k,	h₂ : p ^ l ∣ p ^ (k + 1)	⊢ l = k + 1
⊢ ∀ {r n b : ℕ},	    b ≠ 0 → ∀ {n' : ℕ}, r + b + n' = n → b.sqrt_aux r n = (b.shiftr 2).sqrt_aux (r.div2 + b) n'
r n b : ℕ,	h : b ≠ 0,	n' : ℕ,	h₂ : r + b + n' = n	⊢ b.sqrt_aux r n = (b.shiftr 2).sqrt_aux (r.div2 + b) n'
r n b : ℕ,	h : b ≠ 0,	n' : ℕ,	h₂ : r + b + n' = n	⊢ ite (b = 0) r	      (let b' : ℕ := b.shiftr 2	       in sqrt_aux._match_1 (λ (n' : ℕ), (b.shiftr 2).sqrt_aux (r.div2 + b) n') ((b.shiftr 2).sqrt_aux r.div2 n)	            (↑n - ↑(r + b))) =	    (b.shiftr 2).sqrt_aux (r.div2 + b) n'
r n b : ℕ,	h : b ≠ 0,	n' : ℕ,	h₂ : r + b + n' = n	⊢ sqrt_aux._match_1 ((b.shiftr 2).sqrt_aux (r.div2 + b)) ((b.shiftr 2).sqrt_aux r.div2 (r + b + n'))	      (↑r + ↑b + ↑n' - (↑r + ↑b)) =	    (b.shiftr 2).sqrt_aux (r.div2 + b) n'
⊢ ∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : α → β) (x : option α)	  (g : Π (b : β), b ∈ option.map f x → option γ),	    (option.map f x).pbind g = x.pbind (λ (a : α) (h : a ∈ x), g (f a) _)
α : Type u_1,	β : Type u_2,	γ : Type u_3,	f : α → β,	x : option α,	g : Π (b : β), b ∈ option.map f x → option γ	⊢ (option.map f x).pbind g = x.pbind (λ (a : α) (h : a ∈ x), g (f a) _)
2 goals	case option.none	α : Type u_1,	β : Type u_2,	γ : Type u_3,	f : α → β,	g : Π (b : β), b ∈ option.map f none → option γ	⊢ (option.map f none).pbind g = none.pbind (λ (a : α) (h : a ∈ none), g (f a) _)		case option.some	α : Type u_1,	β : Type u_2,	γ : Type u_3,	f : α → β,	x : α,	g : Π (b : β), b ∈ option.map f (some x) → option γ	⊢ (option.map f (some x)).pbind g = (some x).pbind (λ (a : α) (h : a ∈ some x), g (f a) _)
case option.some	α : Type u_1,	β : Type u_2,	γ : Type u_3,	f : α → β,	x : α,	g : Π (b : β), b ∈ option.map f (some x) → option γ	⊢ (option.map f (some x)).pbind g = (some x).pbind (λ (a : α) (h : a ∈ some x), g (f a) _)
⊢ ∀ {α : Type u_1} {β : Type u_2} {x : option α} {f : Π (a : α), a ∈ x → option β} {y : β},	    x.pbind f = some y ↔ ∃ (z : α) (H : z ∈ x), f z H = some y
α : Type u_1,	β : Type u_2,	x : option α,	f : Π (a : α), a ∈ x → option β,	y : β	⊢ x.pbind f = some y ↔ ∃ (z : α) (H : z ∈ x), f z H = some y
2 goals	case option.none	α : Type u_1,	β : Type u_2,	y : β,	f : Π (a : α), a ∈ none → option β	⊢ none.pbind f = some y ↔ ∃ (z : α) (H : z ∈ none), f z H = some y		case option.some	α : Type u_1,	β : Type u_2,	y : β,	x : α,	f : Π (a : α), a ∈ some x → option β	⊢ (some x).pbind f = some y ↔ ∃ (z : α) (H : z ∈ some x), f z H = some y
case option.some	α : Type u_1,	β : Type u_2,	y : β,	x : α,	f : Π (a : α), a ∈ some x → option β	⊢ (some x).pbind f = some y ↔ ∃ (z : α) (H : z ∈ some x), f z H = some y
case option.some	α : Type u_1,	β : Type u_2,	y : β,	x : α,	f : Π (a : α), a ∈ some x → option β	⊢ f x _ = some y ↔ ∃ (z : α) (H : z ∈ some x), f z H = some y
2 goals	α : Type u_1,	β : Type u_2,	y : β,	x : α,	f : Π (a : α), a ∈ some x → option β	⊢ f x _ = some y → (∃ (z : α) (H : z ∈ some x), f z H = some y)		α : Type u_1,	β : Type u_2,	y : β,	x : α,	f : Π (a : α), a ∈ some x → option β	⊢ (∃ (z : α) (H : z ∈ some x), f z H = some y) → f x _ = some y
2 goals	α : Type u_1,	β : Type u_2,	y : β,	x : α,	f : Π (a : α), a ∈ some x → option β,	h : f x _ = some y	⊢ ∃ (z : α) (H : z ∈ some x), f z H = some y		α : Type u_1,	β : Type u_2,	y : β,	x : α,	f : Π (a : α), a ∈ some x → option β	⊢ (∃ (z : α) (H : z ∈ some x), f z H = some y) → f x _ = some y
2 goals	α : Type u_1,	β : Type u_2,	y : β,	x : α,	f : Π (a : α), a ∈ some x → option β,	h : f x _ = some y	⊢ ∃ (H : x ∈ some x), f x H = some y		α : Type u_1,	β : Type u_2,	y : β,	x : α,	f : Π (a : α), a ∈ some x → option β	⊢ (∃ (z : α) (H : z ∈ some x), f z H = some y) → f x _ = some y
α : Type u_1,	β : Type u_2,	y : β,	x : α,	f : Π (a : α), a ∈ some x → option β	⊢ (∃ (z : α) (H : z ∈ some x), f z H = some y) → f x _ = some y
α : Type u_1,	β : Type u_2,	y : β,	x : α,	f : Π (a : α), a ∈ some x → option β,	z : α,	H : z ∈ some x,	hz : f z H = some y	⊢ f x _ = some y
α : Type u_1,	β : Type u_2,	y : β,	x : α,	f : Π (a : α), a ∈ some x → option β,	z : α,	H : z ∈ some x,	hz : f z H = some y,	H : x = z	⊢ f x _ = some y
⊢ ∀ {a b c : ℕ}, 3 * a ≤ b + c → b < 2 * c → a + b < 3 * c
a b c : ℕ,	H2 : 3 * a ≤ b + c,	h : b < 2 * c	⊢ a + b < 3 * c
⊢ ∀ {α : Type u_1} [_inst_1 : preorder α] {l r : ordnode α} {o₁ : with_bot α} {o₂ : with_top α},	    valid' o₁ l o₂ →	    valid' o₁ r o₂ →	    all (λ (x : α), all (λ (y : α), x < y) r) l →	    balanced_sz l.size r.size → valid' o₁ (l.glue r) o₂ ∧ (l.glue r).size = l.size + r.size
α : Type u_1,	_inst_1 : preorder α,	l r : ordnode α,	o₁ : with_bot α,	o₂ : with_top α,	hl : valid' o₁ l o₂,	hr : valid' o₁ r o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) r) l,	bal : balanced_sz l.size r.size	⊢ valid' o₁ (l.glue r) o₂ ∧ (l.glue r).size = l.size + r.size
2 goals	case ordnode.nil	α : Type u_1,	_inst_1 : preorder α,	r : ordnode α,	o₁ : with_bot α,	o₂ : with_top α,	hr : valid' o₁ r o₂,	hl : valid' o₁ nil o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) r) nil,	bal : balanced_sz nil.size r.size	⊢ valid' o₁ (nil.glue r) o₂ ∧ (nil.glue r).size = nil.size + r.size		case ordnode.node	α : Type u_1,	_inst_1 : preorder α,	r : ordnode α,	o₁ : with_bot α,	o₂ : with_top α,	hr : valid' o₁ r o₂,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) r) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size r.size	⊢ valid' o₁ ((node ls ll lx lr).glue r) o₂ ∧ ((node ls ll lx lr).glue r).size = (node ls ll lx lr).size + r.size
case ordnode.node	α : Type u_1,	_inst_1 : preorder α,	r : ordnode α,	o₁ : with_bot α,	o₂ : with_top α,	hr : valid' o₁ r o₂,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) r) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size r.size	⊢ valid' o₁ ((node ls ll lx lr).glue r) o₂ ∧ ((node ls ll lx lr).glue r).size = (node ls ll lx lr).size + r.size
2 goals	case ordnode.node, ordnode.nil	α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	hr : valid' o₁ nil o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) nil) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size nil.size	⊢ valid' o₁ ((node ls ll lx lr).glue nil) o₂ ∧	    ((node ls ll lx lr).glue nil).size = (node ls ll lx lr).size + nil.size		case ordnode.node, ordnode.node	α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size	⊢ valid' o₁ ((node ls ll lx lr).glue (node rs rl rx rr)) o₂ ∧	    ((node ls ll lx lr).glue (node rs rl rx rr)).size = (node ls ll lx lr).size + (node rs rl rx rr).size
case ordnode.node, ordnode.node	α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size	⊢ valid' o₁ ((node ls ll lx lr).glue (node rs rl rx rr)) o₂ ∧	    ((node ls ll lx lr).glue (node rs rl rx rr)).size = (node ls ll lx lr).size + (node rs rl rx rr).size
α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size	⊢ valid' o₁	      (ite (ls > rs) (glue._match_1 rs rl rx rr (ll.split_max' lx lr))	         (glue._match_2 ls ll lx lr (rl.split_min' rx rr)))	      o₂ ∧	    (ite (ls > rs) (glue._match_1 rs rl rx rr (ll.split_max' lx lr))	         (glue._match_2 ls ll lx lr (rl.split_min' rx rr))).size =	      ls + rs
2 goals	α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ls > rs	⊢ valid' o₁ (glue._match_1 rs rl rx rr (ll.split_max' lx lr)) o₂ ∧	    (glue._match_1 rs rl rx rr (ll.split_max' lx lr)).size = ls + rs		α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ¬ls > rs	⊢ valid' o₁ (glue._match_2 ls ll lx lr (rl.split_min' rx rr)) o₂ ∧	    (glue._match_2 ls ll lx lr (rl.split_min' rx rr)).size = ls + rs
3 goals	α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ls > rs	⊢ valid' o₁ ((node ?m_1 ll lx lr).erase_max.balance_r (find_max' lx lr) (node rs rl rx rr)) o₂ ∧	    ((node ?m_1 ll lx lr).erase_max.balance_r (find_max' lx lr) (node rs rl rx rr)).size = ls + rs		α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ls > rs	⊢ ℕ		α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ¬ls > rs	⊢ valid' o₁ (glue._match_2 ls ll lx lr (rl.split_min' rx rr)) o₂ ∧	    (glue._match_2 ls ll lx lr (rl.split_min' rx rr)).size = ls + rs
3 goals	α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ls > rs,	v : valid' o₁ (ll.node' lx lr).erase_max ↑(find_max' lx lr),	e : (ll.node' lx lr).size = (ll.node' lx lr).erase_max.size + 1	⊢ valid' o₁ ((node ?m_1 ll lx lr).erase_max.balance_r (find_max' lx lr) (node rs rl rx rr)) o₂ ∧	    ((node ?m_1 ll lx lr).erase_max.balance_r (find_max' lx lr) (node rs rl rx rr)).size = ls + rs		α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ls > rs	⊢ ℕ		α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ¬ls > rs	⊢ valid' o₁ (glue._match_2 ls ll lx lr (rl.split_min' rx rr)) o₂ ∧	    (glue._match_2 ls ll lx lr (rl.split_min' rx rr)).size = ls + rs
4 goals	α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ls > rs,	v : valid' o₁ (ll.node' lx lr).erase_max ↑(find_max' lx lr),	e : (ll.node' lx lr).size = (ll.node' lx lr).erase_max.size + 1,	H : ?m_1	⊢ valid' o₁ ((node ?m_2 ll lx lr).erase_max.balance_r (find_max' lx lr) (node rs rl rx rr)) o₂ ∧	    ((node ?m_2 ll lx lr).erase_max.balance_r (find_max' lx lr) (node rs rl rx rr)).size = ls + rs		α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ls > rs,	v : valid' o₁ (ll.node' lx lr).erase_max ↑(find_max' lx lr),	e : (ll.node' lx lr).size = (ll.node' lx lr).erase_max.size + 1	⊢ ?m_1		α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ls > rs	⊢ ℕ		α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ¬ls > rs	⊢ valid' o₁ (glue._match_2 ls ll lx lr (rl.split_min' rx rr)) o₂ ∧	    (glue._match_2 ls ll lx lr (rl.split_min' rx rr)).size = ls + rs
5 goals	α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ls > rs,	v : valid' o₁ (ll.node' lx lr).erase_max ↑(find_max' lx lr),	e : (ll.node' lx lr).size = (ll.node' lx lr).erase_max.size + 1,	H :	  (∃ (l' : ℕ),	       raised (node (ll.size + lr.size + 1) ll lx lr).erase_max.size l' ∧ balanced_sz l' (node rs rl rx rr).size) ∨	    ∃ (r' : ℕ),	      raised r' (node rs rl rx rr).size ∧ balanced_sz (node (ll.size + lr.size + 1) ll lx lr).erase_max.size r'	⊢ nil.bounded ↑(find_max' lx lr) o₂		α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ls > rs,	v : valid' o₁ (ll.node' lx lr).erase_max ↑(find_max' lx lr),	e : (ll.node' lx lr).size = (ll.node' lx lr).erase_max.size + 1,	H :	  (∃ (l' : ℕ),	       raised (node (ll.size + lr.size + 1) ll lx lr).erase_max.size l' ∧ balanced_sz l' (node rs rl rx rr).size) ∨	    ∃ (r' : ℕ),	      raised r' (node rs rl rx rr).size ∧ balanced_sz (node (ll.size + lr.size + 1) ll lx lr).erase_max.size r'	⊢ all (λ (_x : α), _x > find_max' lx lr) (node rs rl rx rr)		α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ls > rs,	v : valid' o₁ (ll.node' lx lr).erase_max ↑(find_max' lx lr),	e : (ll.node' lx lr).size = (ll.node' lx lr).erase_max.size + 1,	H :	  (∃ (l' : ℕ),	       raised (node (ll.size + lr.size + 1) ll lx lr).erase_max.size l' ∧ balanced_sz l' (node rs rl rx rr).size) ∨	    ∃ (r' : ℕ),	      raised r' (node rs rl rx rr).size ∧ balanced_sz (node (ll.size + lr.size + 1) ll lx lr).erase_max.size r'	⊢ ((node (ll.size + lr.size + 1) ll lx lr).erase_max.balance_r (find_max' lx lr) (node rs rl rx rr)).size = ls + rs		α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ls > rs,	v : valid' o₁ (ll.node' lx lr).erase_max ↑(find_max' lx lr),	e : (ll.node' lx lr).size = (ll.node' lx lr).erase_max.size + 1	⊢ (∃ (l' : ℕ),	       raised (node (ll.size + lr.size + 1) ll lx lr).erase_max.size l' ∧ balanced_sz l' (node rs rl rx rr).size) ∨	    ∃ (r' : ℕ),	      raised r' (node rs rl rx rr).size ∧ balanced_sz (node (ll.size + lr.size + 1) ll lx lr).erase_max.size r'		α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ¬ls > rs	⊢ valid' o₁ (glue._match_2 ls ll lx lr (rl.split_min' rx rr)) o₂ ∧	    (glue._match_2 ls ll lx lr (rl.split_min' rx rr)).size = ls + rs
5 goals	α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ls > rs,	v : valid' o₁ (ll.node' lx lr).erase_max ↑(find_max' lx lr),	e : (ll.node' lx lr).size = (ll.node' lx lr).erase_max.size + 1,	H :	  (∃ (l' : ℕ),	       raised (node (ll.size + lr.size + 1) ll lx lr).erase_max.size l' ∧ balanced_sz l' (node rs rl rx rr).size) ∨	    ∃ (r' : ℕ),	      raised r' (node rs rl rx rr).size ∧ balanced_sz (node (ll.size + lr.size + 1) ll lx lr).erase_max.size r'	⊢ ∀ (a : α), all (λ (y : α), a < y) (node rs rl rx rr) → nil.bounded ↑a o₂		α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ls > rs,	v : valid' o₁ (ll.node' lx lr).erase_max ↑(find_max' lx lr),	e : (ll.node' lx lr).size = (ll.node' lx lr).erase_max.size + 1,	H :	  (∃ (l' : ℕ),	       raised (node (ll.size + lr.size + 1) ll lx lr).erase_max.size l' ∧ balanced_sz l' (node rs rl rx rr).size) ∨	    ∃ (r' : ℕ),	      raised r' (node rs rl rx rr).size ∧ balanced_sz (node (ll.size + lr.size + 1) ll lx lr).erase_max.size r'	⊢ all (λ (_x : α), _x > find_max' lx lr) (node rs rl rx rr)		α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ls > rs,	v : valid' o₁ (ll.node' lx lr).erase_max ↑(find_max' lx lr),	e : (ll.node' lx lr).size = (ll.node' lx lr).erase_max.size + 1,	H :	  (∃ (l' : ℕ),	       raised (node (ll.size + lr.size + 1) ll lx lr).erase_max.size l' ∧ balanced_sz l' (node rs rl rx rr).size) ∨	    ∃ (r' : ℕ),	      raised r' (node rs rl rx rr).size ∧ balanced_sz (node (ll.size + lr.size + 1) ll lx lr).erase_max.size r'	⊢ ((node (ll.size + lr.size + 1) ll lx lr).erase_max.balance_r (find_max' lx lr) (node rs rl rx rr)).size = ls + rs		α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ls > rs,	v : valid' o₁ (ll.node' lx lr).erase_max ↑(find_max' lx lr),	e : (ll.node' lx lr).size = (ll.node' lx lr).erase_max.size + 1	⊢ (∃ (l' : ℕ),	       raised (node (ll.size + lr.size + 1) ll lx lr).erase_max.size l' ∧ balanced_sz l' (node rs rl rx rr).size) ∨	    ∃ (r' : ℕ),	      raised r' (node rs rl rx rr).size ∧ balanced_sz (node (ll.size + lr.size + 1) ll lx lr).erase_max.size r'		α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ¬ls > rs	⊢ valid' o₁ (glue._match_2 ls ll lx lr (rl.split_min' rx rr)) o₂ ∧	    (glue._match_2 ls ll lx lr (rl.split_min' rx rr)).size = ls + rs
4 goals	α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ls > rs,	v : valid' o₁ (ll.node' lx lr).erase_max ↑(find_max' lx lr),	e : (ll.node' lx lr).size = (ll.node' lx lr).erase_max.size + 1,	H :	  (∃ (l' : ℕ),	       raised (node (ll.size + lr.size + 1) ll lx lr).erase_max.size l' ∧ balanced_sz l' (node rs rl rx rr).size) ∨	    ∃ (r' : ℕ),	      raised r' (node rs rl rx rr).size ∧ balanced_sz (node (ll.size + lr.size + 1) ll lx lr).erase_max.size r'	⊢ all (λ (_x : α), _x > find_max' lx lr) (node rs rl rx rr)		α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ls > rs,	v : valid' o₁ (ll.node' lx lr).erase_max ↑(find_max' lx lr),	e : (ll.node' lx lr).size = (ll.node' lx lr).erase_max.size + 1,	H :	  (∃ (l' : ℕ),	       raised (node (ll.size + lr.size + 1) ll lx lr).erase_max.size l' ∧ balanced_sz l' (node rs rl rx rr).size) ∨	    ∃ (r' : ℕ),	      raised r' (node rs rl rx rr).size ∧ balanced_sz (node (ll.size + lr.size + 1) ll lx lr).erase_max.size r'	⊢ ((node (ll.size + lr.size + 1) ll lx lr).erase_max.balance_r (find_max' lx lr) (node rs rl rx rr)).size = ls + rs		α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ls > rs,	v : valid' o₁ (ll.node' lx lr).erase_max ↑(find_max' lx lr),	e : (ll.node' lx lr).size = (ll.node' lx lr).erase_max.size + 1	⊢ (∃ (l' : ℕ),	       raised (node (ll.size + lr.size + 1) ll lx lr).erase_max.size l' ∧ balanced_sz l' (node rs rl rx rr).size) ∨	    ∃ (r' : ℕ),	      raised r' (node rs rl rx rr).size ∧ balanced_sz (node (ll.size + lr.size + 1) ll lx lr).erase_max.size r'		α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ¬ls > rs	⊢ valid' o₁ (glue._match_2 ls ll lx lr (rl.split_min' rx rr)) o₂ ∧	    (glue._match_2 ls ll lx lr (rl.split_min' rx rr)).size = ls + rs
3 goals	α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ls > rs,	v : valid' o₁ (ll.node' lx lr).erase_max ↑(find_max' lx lr),	e : (ll.node' lx lr).size = (ll.node' lx lr).erase_max.size + 1,	H :	  (∃ (l' : ℕ),	       raised (node (ll.size + lr.size + 1) ll lx lr).erase_max.size l' ∧ balanced_sz l' (node rs rl rx rr).size) ∨	    ∃ (r' : ℕ),	      raised r' (node rs rl rx rr).size ∧ balanced_sz (node (ll.size + lr.size + 1) ll lx lr).erase_max.size r'	⊢ ((node (ll.size + lr.size + 1) ll lx lr).erase_max.balance_r (find_max' lx lr) (node rs rl rx rr)).size = ls + rs		α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ls > rs,	v : valid' o₁ (ll.node' lx lr).erase_max ↑(find_max' lx lr),	e : (ll.node' lx lr).size = (ll.node' lx lr).erase_max.size + 1	⊢ (∃ (l' : ℕ),	       raised (node (ll.size + lr.size + 1) ll lx lr).erase_max.size l' ∧ balanced_sz l' (node rs rl rx rr).size) ∨	    ∃ (r' : ℕ),	      raised r' (node rs rl rx rr).size ∧ balanced_sz (node (ll.size + lr.size + 1) ll lx lr).erase_max.size r'		α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ¬ls > rs	⊢ valid' o₁ (glue._match_2 ls ll lx lr (rl.split_min' rx rr)) o₂ ∧	    (glue._match_2 ls ll lx lr (rl.split_min' rx rr)).size = ls + rs
3 goals	α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ls > rs,	v : valid' o₁ (ll.node' lx lr).erase_max ↑(find_max' lx lr),	e : (ll.node' lx lr).size = (ll.node' lx lr).erase_max.size + 1,	H :	  (∃ (l' : ℕ),	       raised (node (ll.size + lr.size + 1) ll lx lr).erase_max.size l' ∧ balanced_sz l' (node rs rl rx rr).size) ∨	    ∃ (r' : ℕ),	      raised r' (node rs rl rx rr).size ∧ balanced_sz (node (ll.size + lr.size + 1) ll lx lr).erase_max.size r'	⊢ (ll.node' lx lr).size + (node rs rl rx rr).size = ll.size + lr.size + 1 + rs		α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ls > rs,	v : valid' o₁ (ll.node' lx lr).erase_max ↑(find_max' lx lr),	e : (ll.node' lx lr).size = (ll.node' lx lr).erase_max.size + 1	⊢ (∃ (l' : ℕ),	       raised (node (ll.size + lr.size + 1) ll lx lr).erase_max.size l' ∧ balanced_sz l' (node rs rl rx rr).size) ∨	    ∃ (r' : ℕ),	      raised r' (node rs rl rx rr).size ∧ balanced_sz (node (ll.size + lr.size + 1) ll lx lr).erase_max.size r'		α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ¬ls > rs	⊢ valid' o₁ (glue._match_2 ls ll lx lr (rl.split_min' rx rr)) o₂ ∧	    (glue._match_2 ls ll lx lr (rl.split_min' rx rr)).size = ls + rs
2 goals	α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ls > rs,	v : valid' o₁ (ll.node' lx lr).erase_max ↑(find_max' lx lr),	e : (ll.node' lx lr).size = (ll.node' lx lr).erase_max.size + 1	⊢ (∃ (l' : ℕ),	       raised (node (ll.size + lr.size + 1) ll lx lr).erase_max.size l' ∧ balanced_sz l' (node rs rl rx rr).size) ∨	    ∃ (r' : ℕ),	      raised r' (node rs rl rx rr).size ∧ balanced_sz (node (ll.size + lr.size + 1) ll lx lr).erase_max.size r'		α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ¬ls > rs	⊢ valid' o₁ (glue._match_2 ls ll lx lr (rl.split_min' rx rr)) o₂ ∧	    (glue._match_2 ls ll lx lr (rl.split_min' rx rr)).size = ls + rs
2 goals	α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ls > rs,	v : valid' o₁ (ll.node' lx lr).erase_max ↑(find_max' lx lr),	e : (ll.node' lx lr).size = (ll.node' lx lr).erase_max.size + 1	⊢ balanced_sz (ll.node' lx lr).size (node rs rl rx rr).size		α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ¬ls > rs	⊢ valid' o₁ (glue._match_2 ls ll lx lr (rl.split_min' rx rr)) o₂ ∧	    (glue._match_2 ls ll lx lr (rl.split_min' rx rr)).size = ls + rs
α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ¬ls > rs	⊢ valid' o₁ (glue._match_2 ls ll lx lr (rl.split_min' rx rr)) o₂ ∧	    (glue._match_2 ls ll lx lr (rl.split_min' rx rr)).size = ls + rs
2 goals	α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ¬ls > rs	⊢ valid' o₁ ((node ls ll lx lr).balance_l (rl.find_min' rx) (node ?m_1 rl rx rr).erase_min) o₂ ∧	    ((node ls ll lx lr).balance_l (rl.find_min' rx) (node ?m_1 rl rx rr).erase_min).size = ls + rs		α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ¬ls > rs	⊢ ℕ
2 goals	α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ¬ls > rs,	v : valid' ↑(rl.find_min' rx) (rl.node' rx rr).erase_min o₂,	e : (rl.node' rx rr).size = (rl.node' rx rr).erase_min.size + 1	⊢ valid' o₁ ((node ls ll lx lr).balance_l (rl.find_min' rx) (node ?m_1 rl rx rr).erase_min) o₂ ∧	    ((node ls ll lx lr).balance_l (rl.find_min' rx) (node ?m_1 rl rx rr).erase_min).size = ls + rs		α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ¬ls > rs	⊢ ℕ
3 goals	α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ¬ls > rs,	v : valid' ↑(rl.find_min' rx) (rl.node' rx rr).erase_min o₂,	e : (rl.node' rx rr).size = (rl.node' rx rr).erase_min.size + 1,	H : ?m_1	⊢ valid' o₁ ((node ls ll lx lr).balance_l (rl.find_min' rx) (node ?m_2 rl rx rr).erase_min) o₂ ∧	    ((node ls ll lx lr).balance_l (rl.find_min' rx) (node ?m_2 rl rx rr).erase_min).size = ls + rs		α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ¬ls > rs,	v : valid' ↑(rl.find_min' rx) (rl.node' rx rr).erase_min o₂,	e : (rl.node' rx rr).size = (rl.node' rx rr).erase_min.size + 1	⊢ ?m_1		α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ¬ls > rs	⊢ ℕ
4 goals	α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ¬ls > rs,	v : valid' ↑(rl.find_min' rx) (rl.node' rx rr).erase_min o₂,	e : (rl.node' rx rr).size = (rl.node' rx rr).erase_min.size + 1,	H :	  (∃ (l' : ℕ),	       raised l' (node ls ll lx lr).size ∧ balanced_sz l' (node (rl.size + rr.size + 1) rl rx rr).erase_min.size) ∨	    ∃ (r' : ℕ),	      raised (node (rl.size + rr.size + 1) rl rx rr).erase_min.size r' ∧ balanced_sz (node ls ll lx lr).size r'	⊢ nil.bounded o₁ ↑(rl.find_min' rx)		α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ¬ls > rs,	v : valid' ↑(rl.find_min' rx) (rl.node' rx rr).erase_min o₂,	e : (rl.node' rx rr).size = (rl.node' rx rr).erase_min.size + 1,	H :	  (∃ (l' : ℕ),	       raised l' (node ls ll lx lr).size ∧ balanced_sz l' (node (rl.size + rr.size + 1) rl rx rr).erase_min.size) ∨	    ∃ (r' : ℕ),	      raised (node (rl.size + rr.size + 1) rl rx rr).erase_min.size r' ∧ balanced_sz (node ls ll lx lr).size r'	⊢ all (λ (_x : α), _x < rl.find_min' rx) (node ls ll lx lr)		α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ¬ls > rs,	v : valid' ↑(rl.find_min' rx) (rl.node' rx rr).erase_min o₂,	e : (rl.node' rx rr).size = (rl.node' rx rr).erase_min.size + 1,	H :	  (∃ (l' : ℕ),	       raised l' (node ls ll lx lr).size ∧ balanced_sz l' (node (rl.size + rr.size + 1) rl rx rr).erase_min.size) ∨	    ∃ (r' : ℕ),	      raised (node (rl.size + rr.size + 1) rl rx rr).erase_min.size r' ∧ balanced_sz (node ls ll lx lr).size r'	⊢ ((node ls ll lx lr).balance_l (rl.find_min' rx) (node (rl.size + rr.size + 1) rl rx rr).erase_min).size = ls + rs		α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ¬ls > rs,	v : valid' ↑(rl.find_min' rx) (rl.node' rx rr).erase_min o₂,	e : (rl.node' rx rr).size = (rl.node' rx rr).erase_min.size + 1	⊢ (∃ (l' : ℕ),	       raised l' (node ls ll lx lr).size ∧ balanced_sz l' (node (rl.size + rr.size + 1) rl rx rr).erase_min.size) ∨	    ∃ (r' : ℕ),	      raised (node (rl.size + rr.size + 1) rl rx rr).erase_min.size r' ∧ balanced_sz (node ls ll lx lr).size r'
4 goals	α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ¬ls > rs,	v : valid' ↑(rl.find_min' rx) (rl.node' rx rr).erase_min o₂,	e : (rl.node' rx rr).size = (rl.node' rx rr).erase_min.size + 1,	H :	  (∃ (l' : ℕ),	       raised l' (node ls ll lx lr).size ∧ balanced_sz l' (node (rl.size + rr.size + 1) rl rx rr).erase_min.size) ∨	    ∃ (r' : ℕ),	      raised (node (rl.size + rr.size + 1) rl rx rr).erase_min.size r' ∧ balanced_sz (node ls ll lx lr).size r'	⊢ ∀ (a : α), lx < a → nil.bounded o₁ ↑a		α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ¬ls > rs,	v : valid' ↑(rl.find_min' rx) (rl.node' rx rr).erase_min o₂,	e : (rl.node' rx rr).size = (rl.node' rx rr).erase_min.size + 1,	H :	  (∃ (l' : ℕ),	       raised l' (node ls ll lx lr).size ∧ balanced_sz l' (node (rl.size + rr.size + 1) rl rx rr).erase_min.size) ∨	    ∃ (r' : ℕ),	      raised (node (rl.size + rr.size + 1) rl rx rr).erase_min.size r' ∧ balanced_sz (node ls ll lx lr).size r'	⊢ all (λ (_x : α), _x < rl.find_min' rx) (node ls ll lx lr)		α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ¬ls > rs,	v : valid' ↑(rl.find_min' rx) (rl.node' rx rr).erase_min o₂,	e : (rl.node' rx rr).size = (rl.node' rx rr).erase_min.size + 1,	H :	  (∃ (l' : ℕ),	       raised l' (node ls ll lx lr).size ∧ balanced_sz l' (node (rl.size + rr.size + 1) rl rx rr).erase_min.size) ∨	    ∃ (r' : ℕ),	      raised (node (rl.size + rr.size + 1) rl rx rr).erase_min.size r' ∧ balanced_sz (node ls ll lx lr).size r'	⊢ ((node ls ll lx lr).balance_l (rl.find_min' rx) (node (rl.size + rr.size + 1) rl rx rr).erase_min).size = ls + rs		α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ¬ls > rs,	v : valid' ↑(rl.find_min' rx) (rl.node' rx rr).erase_min o₂,	e : (rl.node' rx rr).size = (rl.node' rx rr).erase_min.size + 1	⊢ (∃ (l' : ℕ),	       raised l' (node ls ll lx lr).size ∧ balanced_sz l' (node (rl.size + rr.size + 1) rl rx rr).erase_min.size) ∨	    ∃ (r' : ℕ),	      raised (node (rl.size + rr.size + 1) rl rx rr).erase_min.size r' ∧ balanced_sz (node ls ll lx lr).size r'
3 goals	α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ¬ls > rs,	v : valid' ↑(rl.find_min' rx) (rl.node' rx rr).erase_min o₂,	e : (rl.node' rx rr).size = (rl.node' rx rr).erase_min.size + 1,	H :	  (∃ (l' : ℕ),	       raised l' (node ls ll lx lr).size ∧ balanced_sz l' (node (rl.size + rr.size + 1) rl rx rr).erase_min.size) ∨	    ∃ (r' : ℕ),	      raised (node (rl.size + rr.size + 1) rl rx rr).erase_min.size r' ∧ balanced_sz (node ls ll lx lr).size r'	⊢ all (λ (_x : α), _x < rl.find_min' rx) (node ls ll lx lr)		α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ¬ls > rs,	v : valid' ↑(rl.find_min' rx) (rl.node' rx rr).erase_min o₂,	e : (rl.node' rx rr).size = (rl.node' rx rr).erase_min.size + 1,	H :	  (∃ (l' : ℕ),	       raised l' (node ls ll lx lr).size ∧ balanced_sz l' (node (rl.size + rr.size + 1) rl rx rr).erase_min.size) ∨	    ∃ (r' : ℕ),	      raised (node (rl.size + rr.size + 1) rl rx rr).erase_min.size r' ∧ balanced_sz (node ls ll lx lr).size r'	⊢ ((node ls ll lx lr).balance_l (rl.find_min' rx) (node (rl.size + rr.size + 1) rl rx rr).erase_min).size = ls + rs		α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ¬ls > rs,	v : valid' ↑(rl.find_min' rx) (rl.node' rx rr).erase_min o₂,	e : (rl.node' rx rr).size = (rl.node' rx rr).erase_min.size + 1	⊢ (∃ (l' : ℕ),	       raised l' (node ls ll lx lr).size ∧ balanced_sz l' (node (rl.size + rr.size + 1) rl rx rr).erase_min.size) ∨	    ∃ (r' : ℕ),	      raised (node (rl.size + rr.size + 1) rl rx rr).erase_min.size r' ∧ balanced_sz (node ls ll lx lr).size r'
2 goals	α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ¬ls > rs,	v : valid' ↑(rl.find_min' rx) (rl.node' rx rr).erase_min o₂,	e : (rl.node' rx rr).size = (rl.node' rx rr).erase_min.size + 1,	H :	  (∃ (l' : ℕ),	       raised l' (node ls ll lx lr).size ∧ balanced_sz l' (node (rl.size + rr.size + 1) rl rx rr).erase_min.size) ∨	    ∃ (r' : ℕ),	      raised (node (rl.size + rr.size + 1) rl rx rr).erase_min.size r' ∧ balanced_sz (node ls ll lx lr).size r'	⊢ ((node ls ll lx lr).balance_l (rl.find_min' rx) (node (rl.size + rr.size + 1) rl rx rr).erase_min).size = ls + rs		α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ¬ls > rs,	v : valid' ↑(rl.find_min' rx) (rl.node' rx rr).erase_min o₂,	e : (rl.node' rx rr).size = (rl.node' rx rr).erase_min.size + 1	⊢ (∃ (l' : ℕ),	       raised l' (node ls ll lx lr).size ∧ balanced_sz l' (node (rl.size + rr.size + 1) rl rx rr).erase_min.size) ∨	    ∃ (r' : ℕ),	      raised (node (rl.size + rr.size + 1) rl rx rr).erase_min.size r' ∧ balanced_sz (node ls ll lx lr).size r'
2 goals	α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ¬ls > rs,	v : valid' ↑(rl.find_min' rx) (rl.node' rx rr).erase_min o₂,	e : (rl.node' rx rr).size = (rl.node' rx rr).erase_min.size + 1,	H :	  (∃ (l' : ℕ),	       raised l' (node ls ll lx lr).size ∧ balanced_sz l' (node (rl.size + rr.size + 1) rl rx rr).erase_min.size) ∨	    ∃ (r' : ℕ),	      raised (node (rl.size + rr.size + 1) rl rx rr).erase_min.size r' ∧ balanced_sz (node ls ll lx lr).size r'	⊢ (node ls ll lx lr).size + (rl.node' rx rr).size = ls + (rl.size + rr.size + 1)		α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ¬ls > rs,	v : valid' ↑(rl.find_min' rx) (rl.node' rx rr).erase_min o₂,	e : (rl.node' rx rr).size = (rl.node' rx rr).erase_min.size + 1	⊢ (∃ (l' : ℕ),	       raised l' (node ls ll lx lr).size ∧ balanced_sz l' (node (rl.size + rr.size + 1) rl rx rr).erase_min.size) ∨	    ∃ (r' : ℕ),	      raised (node (rl.size + rr.size + 1) rl rx rr).erase_min.size r' ∧ balanced_sz (node ls ll lx lr).size r'
α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ¬ls > rs,	v : valid' ↑(rl.find_min' rx) (rl.node' rx rr).erase_min o₂,	e : (rl.node' rx rr).size = (rl.node' rx rr).erase_min.size + 1	⊢ (∃ (l' : ℕ),	       raised l' (node ls ll lx lr).size ∧ balanced_sz l' (node (rl.size + rr.size + 1) rl rx rr).erase_min.size) ∨	    ∃ (r' : ℕ),	      raised (node (rl.size + rr.size + 1) rl rx rr).erase_min.size r' ∧ balanced_sz (node ls ll lx lr).size r'
α : Type u_1,	_inst_1 : preorder α,	o₁ : with_bot α,	o₂ : with_top α,	ls : ℕ,	ll : ordnode α,	lx : α,	lr : ordnode α,	hl : valid' o₁ (node ls ll lx lr) o₂,	rs : ℕ,	rl : ordnode α,	rx : α,	rr : ordnode α,	hr : valid' o₁ (node rs rl rx rr) o₂,	sep : all (λ (x : α), all (λ (y : α), x < y) (node rs rl rx rr)) (node ls ll lx lr),	bal : balanced_sz (node ls ll lx lr).size (node rs rl rx rr).size,	h : ¬ls > rs,	v : valid' ↑(rl.find_min' rx) (rl.node' rx rr).erase_min o₂,	e : (rl.node' rx rr).size = (rl.node' rx rr).erase_min.size + 1	⊢ balanced_sz (node ls ll lx lr).size (rl.node' rx rr).size
⊢ ∀ {a b c : ℕ}, 3 * a < b + c + 1 → b ≤ 3 * c → 2 * (a + b) ≤ 9 * c + 5
a b c : ℕ,	h₁ : 3 * a < b + c + 1,	h₂ : b ≤ 3 * c	⊢ 2 * (a + b) ≤ 9 * c + 5
⊢ ∀ {α : Type u_1} {P : α → Prop} {l : ordnode α} {x : α} {r : ordnode α},	    all P (l.rotate_l x r) ↔ all P l ∧ P x ∧ all P r
α : Type u_1,	P : α → Prop,	l : ordnode α,	x : α,	r : ordnode α	⊢ all P (l.rotate_l x r) ↔ all P l ∧ P x ∧ all P r
2 goals	case ordnode.nil	α : Type u_1,	P : α → Prop,	l : ordnode α,	x : α	⊢ all P (l.rotate_l x nil) ↔ all P l ∧ P x ∧ all P nil		case ordnode.node	α : Type u_1,	P : α → Prop,	l : ordnode α,	x : α,	r_size : ℕ,	r_l : ordnode α,	r_x : α,	r_r : ordnode α	⊢ all P (l.rotate_l x (node r_size r_l r_x r_r)) ↔ all P l ∧ P x ∧ all P (node r_size r_l r_x r_r)
case ordnode.node	α : Type u_1,	P : α → Prop,	l : ordnode α,	x : α,	r_size : ℕ,	r_l : ordnode α,	r_x : α,	r_r : ordnode α	⊢ all P (l.rotate_l x (node r_size r_l r_x r_r)) ↔ all P l ∧ P x ∧ all P (node r_size r_l r_x r_r)
case ordnode.node	α : Type u_1,	P : α → Prop,	l : ordnode α,	x : α,	r_size : ℕ,	r_l : ordnode α,	r_x : α,	r_r : ordnode α	⊢ all P (ite (r_l.size < ratio * r_r.size) (l.node3_l x r_l r_x r_r) (l.node4_l x r_l r_x r_r)) ↔	    all P l ∧ P x ∧ all P (node r_size r_l r_x r_r)
2 goals	α : Type u_1,	P : α → Prop,	l : ordnode α,	x : α,	r_size : ℕ,	r_l : ordnode α,	r_x : α,	r_r : ordnode α,	h : r_l.size < ratio * r_r.size	⊢ all P (l.node3_l x r_l r_x r_r) ↔ all P l ∧ P x ∧ all P (node r_size r_l r_x r_r)		α : Type u_1,	P : α → Prop,	l : ordnode α,	x : α,	r_size : ℕ,	r_l : ordnode α,	r_x : α,	r_r : ordnode α,	h : ¬r_l.size < ratio * r_r.size	⊢ all P (l.node4_l x r_l r_x r_r) ↔ all P l ∧ P x ∧ all P (node r_size r_l r_x r_r)
α : Type u_1,	P : α → Prop,	l : ordnode α,	x : α,	r_size : ℕ,	r_l : ordnode α,	r_x : α,	r_r : ordnode α,	h : ¬r_l.size < ratio * r_r.size	⊢ all P (l.node4_l x r_l r_x r_r) ↔ all P l ∧ P x ∧ all P (node r_size r_l r_x r_r)
⊢ ∀ {α : Type u_1} {l : ordnode α} {x : α} {r : ordnode α},	    l.balanced →	    r.balanced →	    l.sized →	    r.sized →	    ((∃ (l' : ℕ), raised l' l.size ∧ balanced_sz l' r.size) ∨	       ∃ (r' : ℕ), raised r.size r' ∧ balanced_sz l.size r') →	    (l.balance_l x r).size = l.size + r.size + 1
α : Type u_1,	l : ordnode α,	x : α,	r : ordnode α,	hl : l.balanced,	hr : r.balanced,	sl : l.sized,	sr : r.sized,	H :	  (∃ (l' : ℕ), raised l' l.size ∧ balanced_sz l' r.size) ∨	    ∃ (r' : ℕ), raised r.size r' ∧ balanced_sz l.size r'	⊢ (l.balance_l x r).size = l.size + r.size + 1
⊢ ∀ {α : Type u_1} {β : Type u_2} (f : α → β) (s : set α) (t : set β),	    (res f s).core t = sᶜ ∪ f ⁻¹' t
α : Type u_1,	β : Type u_2,	f : α → β,	s : set α,	t : set β	⊢ (res f s).core t = sᶜ ∪ f ⁻¹' t
α : Type u_1,	β : Type u_2,	f : α → β,	s : set α,	t : set β,	x : α	⊢ x ∈ (res f s).core t ↔ x ∈ sᶜ ∪ f ⁻¹' t
α : Type u_1,	β : Type u_2,	f : α → β,	s : set α,	t : set β,	x : α	⊢ x ∈ s → f x ∈ t ↔ x ∈ sᶜ ∪ f ⁻¹' t
2 goals	α : Type u_1,	β : Type u_2,	f : α → β,	s : set α,	t : set β,	x : α,	h : x ∈ s	⊢ x ∈ s → f x ∈ t ↔ x ∈ sᶜ ∪ f ⁻¹' t		α : Type u_1,	β : Type u_2,	f : α → β,	s : set α,	t : set β,	x : α,	h : x ∉ s	⊢ x ∈ s → f x ∈ t ↔ x ∈ sᶜ ∪ f ⁻¹' t
α : Type u_1,	β : Type u_2,	f : α → β,	s : set α,	t : set β,	x : α,	h : x ∉ s	⊢ x ∈ s → f x ∈ t ↔ x ∈ sᶜ ∪ f ⁻¹' t
⊢ ∀ (u v : prime_multiset), (u + v).prod = u.prod * v.prod
u v : prime_multiset	⊢ (u + v).prod = u.prod * v.prod
u v : prime_multiset	⊢ (⇑coe_pnat_monoid_hom (u + v)).prod = u.prod * v.prod
u v : prime_multiset	⊢ (⇑coe_pnat_monoid_hom u + ⇑coe_pnat_monoid_hom v).prod = u.prod * v.prod
⊢ ∀ (n m : ℕ+), (n * m).factor_multiset = n.factor_multiset + m.factor_multiset
n m : ℕ+	⊢ (n * m).factor_multiset = n.factor_multiset + m.factor_multiset
n m : ℕ+,	u : prime_multiset := n.factor_multiset	⊢ (n * m).factor_multiset = n.factor_multiset + m.factor_multiset
n m : ℕ+,	u : prime_multiset := n.factor_multiset,	v : prime_multiset := m.factor_multiset	⊢ (n * m).factor_multiset = n.factor_multiset + m.factor_multiset
n m : ℕ+,	u : prime_multiset := n.factor_multiset,	v : prime_multiset := m.factor_multiset,	this : n = u.prod	⊢ (n * m).factor_multiset = n.factor_multiset + m.factor_multiset
n m : ℕ+,	u : prime_multiset := n.factor_multiset,	v : prime_multiset := m.factor_multiset,	this : n = u.prod	⊢ (u.prod * m).factor_multiset = u.prod.factor_multiset + m.factor_multiset
n m : ℕ+,	u : prime_multiset := n.factor_multiset,	v : prime_multiset := m.factor_multiset,	this : n = u.prod,	this : m = v.prod	⊢ (u.prod * m).factor_multiset = u.prod.factor_multiset + m.factor_multiset
n m : ℕ+,	u : prime_multiset := n.factor_multiset,	v : prime_multiset := m.factor_multiset,	this : n = u.prod,	this : m = v.prod	⊢ (u.prod * v.prod).factor_multiset = u.prod.factor_multiset + v.prod.factor_multiset
n m : ℕ+,	u : prime_multiset := n.factor_multiset,	v : prime_multiset := m.factor_multiset,	this : n = u.prod,	this : m = v.prod	⊢ (u + v).prod.factor_multiset = u.prod.factor_multiset + v.prod.factor_multiset
n m : ℕ+,	u : prime_multiset := n.factor_multiset,	v : prime_multiset := m.factor_multiset,	this : n = u.prod,	this : m = v.prod	⊢ u + v = u.prod.factor_multiset + v.prod.factor_multiset
n m : ℕ+,	u : prime_multiset := n.factor_multiset,	v : prime_multiset := m.factor_multiset,	this : n = u.prod,	this : m = v.prod	⊢ u + v = u + v.prod.factor_multiset
⊢ ∀ (p : nat.primes), ↑p.factor_multiset = prime_multiset.of_prime p
p : nat.primes	⊢ ↑p.factor_multiset = prime_multiset.of_prime p
p : nat.primes	⊢ ⇑(factor_multiset_equiv.symm) ↑p.factor_multiset = ⇑(factor_multiset_equiv.symm) (prime_multiset.of_prime p)
p : nat.primes	⊢ ↑p.factor_multiset.prod = (prime_multiset.of_prime p).prod
⊢ ∀ {R : Type u} {M : Type u_1} [_inst_3 : comm_ring R] [_inst_4 : add_comm_group M] [_inst_5 : module R M]	  (f : M →ₗ[R] M) (v : M) (p : polynomial R),	    ⇑(⇑(aeval f) p) v = p.sum (λ (n : ℕ) (b : R), b • ⇑(f ^ n) v)
R : Type u,	M : Type u_1,	_inst_3 : comm_ring R,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	f : M →ₗ[R] M,	v : M,	p : polynomial R	⊢ ⇑(⇑(aeval f) p) v = p.sum (λ (n : ℕ) (b : R), b • ⇑(f ^ n) v)
R : Type u,	M : Type u_1,	_inst_3 : comm_ring R,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	f : M →ₗ[R] M,	v : M,	p : polynomial R	⊢ ⇑(p.sum (λ (e : ℕ) (a : R), ⇑(algebra_map R (M →ₗ[R] M)) a * f ^ e)) v =	    p.sum (λ (n : ℕ) (b : R), b • ⇑(f ^ n) v)
⊢ ∀ {R : Type u} [_inst_1 : semiring R] (a : R) (f : polynomial R), ⇑C a * f = a • f
R : Type u,	_inst_1 : semiring R,	a : R,	f : polynomial R	⊢ ⇑C a * f = a • f
R : Type u,	_inst_1 : semiring R,	a : R,	f : polynomial R,	n : ℕ	⊢ (⇑C a * f).coeff n = (a • f).coeff n
⊢ ∀ {R : Type u} [_inst_1 : semiring R] (n : ℕ), (X ^ n).coeff n = 1
R : Type u,	_inst_1 : semiring R,	n : ℕ	⊢ (X ^ n).coeff n = 1
⊢ ∀ (R : Type u_1) [_inst_2 : semiring R] (n k : ℕ), ((1 + X) ^ n).coeff k = ↑(n.choose k)
R : Type u_1,	_inst_2 : semiring R,	n k : ℕ	⊢ ((1 + X) ^ n).coeff k = ↑(n.choose k)
⊢ ∀ {R : Type u} [_inst_1 : semiring R] (P Q : polynomial R) (n : ℕ),	    (bit1 P * Q).coeff n = 2 * (P * Q).coeff n + Q.coeff n
R : Type u,	_inst_1 : semiring R,	P Q : polynomial R,	n : ℕ	⊢ (bit1 P * Q).coeff n = 2 * (P * Q).coeff n + Q.coeff n
⊢ ∀ {R : Type u} [_inst_1 : semiring R] (p : polynomial R), (p * X).coeff 0 = 0
R : Type u,	_inst_1 : semiring R,	p : polynomial R	⊢ (p * X).coeff 0 = 0
⊢ ∀ {R : Type u} [_inst_1 : semiring R] {c : R} {n : ℕ}, c ≠ 0 → (⇑C c * X ^ n).support = {n}
R : Type u,	_inst_1 : semiring R,	c : R,	n : ℕ,	h : c ≠ 0	⊢ (⇑C c * X ^ n).support = {n}
R : Type u,	_inst_1 : semiring R,	c : R,	n : ℕ,	h : c ≠ 0	⊢ (⇑(monomial n) c).support = {n}
⊢ ∀ {R : Type u} [_inst_1 : semiring R] (p q : polynomial R), (p + q).nat_degree ≤ max p.nat_degree q.nat_degree
R : Type u,	_inst_1 : semiring R,	p q : polynomial R	⊢ (p + q).nat_degree ≤ max p.nat_degree q.nat_degree
2 goals	case or.inl	R : Type u,	_inst_1 : semiring R,	p q : polynomial R,	h : (p + q).degree ≤ p.degree	⊢ (p + q).nat_degree ≤ max p.nat_degree q.nat_degree		case or.inr	R : Type u,	_inst_1 : semiring R,	p q : polynomial R,	h : (p + q).degree ≤ q.degree	⊢ (p + q).nat_degree ≤ max p.nat_degree q.nat_degree
case or.inr	R : Type u,	_inst_1 : semiring R,	p q : polynomial R,	h : (p + q).degree ≤ q.degree	⊢ (p + q).nat_degree ≤ max p.nat_degree q.nat_degree
⊢ ∀ {R : Type u} [_inst_1 : semiring R], 0 ≠ 1 → ∀ {p : polynomial R}, p.monic → p ≠ 0
R : Type u,	_inst_1 : semiring R,	h : 0 ≠ 1,	p : polynomial R,	hp : p.monic	⊢ p ≠ 0
R : Type u,	_inst_1 : semiring R,	h : 0 ≠ 1,	p : polynomial R,	hp : p.monic,	_inst : nontrivial R	⊢ p ≠ 0
⊢ ∀ {R : Type u} {a : R} [_inst_1 : semiring R] (n : ℕ), a ≠ 0 → (⇑C a * X ^ n).trailing_degree = ↑n
R : Type u,	a : R,	_inst_1 : semiring R,	n : ℕ,	ha : a ≠ 0	⊢ (⇑C a * X ^ n).trailing_degree = ↑n
⊢ ∀ {R : Type u} [_inst_1 : semiring R] (p : polynomial R),	    0 < p.nat_trailing_degree → p.next_coeff_up = p.coeff (p.nat_trailing_degree + 1)
R : Type u,	_inst_1 : semiring R,	p : polynomial R,	hp : 0 < p.nat_trailing_degree	⊢ p.next_coeff_up = p.coeff (p.nat_trailing_degree + 1)
R : Type u,	_inst_1 : semiring R,	p : polynomial R,	hp : 0 < p.nat_trailing_degree	⊢ ¬p.nat_trailing_degree = 0
R : Type u,	_inst_1 : semiring R,	p : polynomial R,	hp : p.nat_trailing_degree = 0	⊢ p.nat_trailing_degree ≤ 0
⊢ ∀ {R : Type u} [_inst_1 : semiring R] {p : polynomial R}, p.comp 0 = ⇑C (eval 0 p)
R : Type u,	_inst_1 : semiring R,	p : polynomial R	⊢ p.comp 0 = ⇑C (eval 0 p)
⊢ ∀ {R : Type u} [_inst_1 : semiring R] {p : polynomial R}, p.comp 1 = ⇑C (eval 1 p)
R : Type u,	_inst_1 : semiring R,	p : polynomial R	⊢ p.comp 1 = ⇑C (eval 1 p)
⊢ ∀ {R : Type u} [_inst_1 : semiring R] (n : ℕ), 1 < n → X.iterated_deriv n = 0
R : Type u,	_inst_1 : semiring R,	n : ℕ,	h : 1 < n	⊢ X.iterated_deriv n = 0
2 goals	case nat.zero	R : Type u,	_inst_1 : semiring R,	h : 1 < 0	⊢ X.iterated_deriv 0 = 0		case nat.succ	R : Type u,	_inst_1 : semiring R,	n : ℕ,	ih : 1 < n → X.iterated_deriv n = 0,	h : 1 < n.succ	⊢ X.iterated_deriv n.succ = 0
2 goals	R : Type u,	_inst_1 : semiring R,	h : 1 < 0	⊢ false		case nat.succ	R : Type u,	_inst_1 : semiring R,	n : ℕ,	ih : 1 < n → X.iterated_deriv n = 0,	h : 1 < n.succ	⊢ X.iterated_deriv n.succ = 0
case nat.succ	R : Type u,	_inst_1 : semiring R,	n : ℕ,	ih : 1 < n → X.iterated_deriv n = 0,	h : 1 < n.succ	⊢ X.iterated_deriv n.succ = 0
case nat.succ	R : Type u,	_inst_1 : semiring R,	n : ℕ,	ih : 1 < n → X.iterated_deriv n = 0,	h : 1 < n.succ	⊢ ⇑derivative (X.iterated_deriv n) = 0
2 goals	R : Type u,	_inst_1 : semiring R,	n : ℕ,	ih : 1 < n → X.iterated_deriv n = 0,	h : 1 < n.succ,	H : n = 1	⊢ ⇑derivative (X.iterated_deriv n) = 0		R : Type u,	_inst_1 : semiring R,	n : ℕ,	ih : 1 < n → X.iterated_deriv n = 0,	h : 1 < n.succ,	H : ¬n = 1	⊢ ⇑derivative (X.iterated_deriv n) = 0
2 goals	R : Type u,	_inst_1 : semiring R,	n : ℕ,	ih : 1 < n → X.iterated_deriv n = 0,	h : 1 < n.succ,	H : n = 1	⊢ ⇑derivative (X.iterated_deriv 1) = 0		R : Type u,	_inst_1 : semiring R,	n : ℕ,	ih : 1 < n → X.iterated_deriv n = 0,	h : 1 < n.succ,	H : ¬n = 1	⊢ ⇑derivative (X.iterated_deriv n) = 0
R : Type u,	_inst_1 : semiring R,	n : ℕ,	ih : 1 < n → X.iterated_deriv n = 0,	h : 1 < n.succ,	H : ¬n = 1	⊢ ⇑derivative (X.iterated_deriv n) = 0
R : Type u,	_inst_1 : semiring R,	n : ℕ,	ih : 1 < n → X.iterated_deriv n = 0,	H : ¬n = 1,	h : 1 < n	⊢ ⇑derivative (X.iterated_deriv n) = 0
R : Type u,	_inst_1 : semiring R,	n : ℕ,	ih : 1 < n → X.iterated_deriv n = 0,	H : ¬n = 1,	h : 1 < n	⊢ ⇑derivative 0 = 0
⊢ ∀ {R : Type u} [_inst_1 : semiring R] {p : polynomial R}, p.monic → ∀ {q : polynomial R}, q * p = 0 ↔ q = 0
R : Type u,	_inst_1 : semiring R,	p : polynomial R,	h : p.monic,	q : polynomial R	⊢ q * p = 0 ↔ q = 0
2 goals	R : Type u,	_inst_1 : semiring R,	p : polynomial R,	h : p.monic,	q : polynomial R,	hq : q = 0	⊢ q * p = 0 ↔ q = 0		R : Type u,	_inst_1 : semiring R,	p : polynomial R,	h : p.monic,	q : polynomial R,	hq : ¬q = 0	⊢ q * p = 0 ↔ q = 0
R : Type u,	_inst_1 : semiring R,	p : polynomial R,	h : p.monic,	q : polynomial R,	hq : ¬q = 0	⊢ q * p = 0 ↔ q = 0
⊢ ∀ {R : Type u} [_inst_1 : semiring R] {S : Type u_1} [_inst_2 : monoid S] [_inst_3 : distrib_mul_action S R]	  {k : S} (p : polynomial R), is_smul_regular R k → (k • p).degree = p.degree
R : Type u,	_inst_1 : semiring R,	S : Type u_1,	_inst_2 : monoid S,	_inst_3 : distrib_mul_action S R,	k : S,	p : polynomial R,	h : is_smul_regular R k	⊢ (k • p).degree = p.degree
2 goals	R : Type u,	_inst_1 : semiring R,	S : Type u_1,	_inst_2 : monoid S,	_inst_3 : distrib_mul_action S R,	k : S,	p : polynomial R,	h : is_smul_regular R k	⊢ (k • p).degree ≤ p.degree		R : Type u,	_inst_1 : semiring R,	S : Type u_1,	_inst_2 : monoid S,	_inst_3 : distrib_mul_action S R,	k : S,	p : polynomial R,	h : is_smul_regular R k	⊢ p.degree ≤ (k • p).degree
2 goals	R : Type u,	_inst_1 : semiring R,	S : Type u_1,	_inst_2 : monoid S,	_inst_3 : distrib_mul_action S R,	k : S,	p : polynomial R,	h : is_smul_regular R k	⊢ ∀ (m : ℕ), p.degree < ↑m → (k • p).coeff m = 0		R : Type u,	_inst_1 : semiring R,	S : Type u_1,	_inst_2 : monoid S,	_inst_3 : distrib_mul_action S R,	k : S,	p : polynomial R,	h : is_smul_regular R k	⊢ p.degree ≤ (k • p).degree
2 goals	R : Type u,	_inst_1 : semiring R,	S : Type u_1,	_inst_2 : monoid S,	_inst_3 : distrib_mul_action S R,	k : S,	p : polynomial R,	h : is_smul_regular R k,	m : ℕ,	hm : p.degree < ↑m	⊢ (k • p).coeff m = 0		R : Type u,	_inst_1 : semiring R,	S : Type u_1,	_inst_2 : monoid S,	_inst_3 : distrib_mul_action S R,	k : S,	p : polynomial R,	h : is_smul_regular R k	⊢ p.degree ≤ (k • p).degree
2 goals	R : Type u,	_inst_1 : semiring R,	S : Type u_1,	_inst_2 : monoid S,	_inst_3 : distrib_mul_action S R,	k : S,	p : polynomial R,	h : is_smul_regular R k,	m : ℕ,	hm : ∀ (m_1 : ℕ), m ≤ m_1 → p.coeff m_1 = 0	⊢ (k • p).coeff m = 0		R : Type u,	_inst_1 : semiring R,	S : Type u_1,	_inst_2 : monoid S,	_inst_3 : distrib_mul_action S R,	k : S,	p : polynomial R,	h : is_smul_regular R k	⊢ p.degree ≤ (k • p).degree
R : Type u,	_inst_1 : semiring R,	S : Type u_1,	_inst_2 : monoid S,	_inst_3 : distrib_mul_action S R,	k : S,	p : polynomial R,	h : is_smul_regular R k	⊢ p.degree ≤ (k • p).degree
R : Type u,	_inst_1 : semiring R,	S : Type u_1,	_inst_2 : monoid S,	_inst_3 : distrib_mul_action S R,	k : S,	p : polynomial R,	h : is_smul_regular R k	⊢ ∀ (m : ℕ), (k • p).degree < ↑m → p.coeff m = 0
R : Type u,	_inst_1 : semiring R,	S : Type u_1,	_inst_2 : monoid S,	_inst_3 : distrib_mul_action S R,	k : S,	p : polynomial R,	h : is_smul_regular R k,	m : ℕ,	hm : (k • p).degree < ↑m	⊢ p.coeff m = 0
R : Type u,	_inst_1 : semiring R,	S : Type u_1,	_inst_2 : monoid S,	_inst_3 : distrib_mul_action S R,	k : S,	p : polynomial R,	h : is_smul_regular R k,	m : ℕ,	hm : ∀ (m_1 : ℕ), m ≤ m_1 → (k • p).coeff m_1 = 0	⊢ p.coeff m = 0
R : Type u,	_inst_1 : semiring R,	S : Type u_1,	_inst_2 : monoid S,	_inst_3 : distrib_mul_action S R,	k : S,	p : polynomial R,	h : is_smul_regular R k,	m : ℕ,	hm : ∀ (m_1 : ℕ), m ≤ m_1 → (k • p).coeff m_1 = 0	⊢ k • p.coeff m = k • 0
⊢ ∀ {R : Type u} [_inst_1 : comm_ring R] [_inst_2 : is_domain R] {p q : polynomial R},	    p.monic → q.monic → p ∣ q → q.nat_degree ≤ p.nat_degree → q = p
R : Type u,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	p q : polynomial R,	hp : p.monic,	hq : q.monic,	hdiv : p ∣ q,	hdeg : q.nat_degree ≤ p.nat_degree	⊢ q = p
R : Type u,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	p q : polynomial R,	hp : p.monic,	hq : q.monic,	hdeg : q.nat_degree ≤ p.nat_degree,	r : polynomial R,	hr : q = p * r	⊢ q = p
2 goals	R : Type u,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	p q : polynomial R,	hp : p.monic,	hq : q.monic,	hdeg : q.nat_degree ≤ p.nat_degree,	r : polynomial R,	hr : q = p * r	⊢ r ≠ 0		R : Type u,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	p q : polynomial R,	hp : p.monic,	hq : q.monic,	hdeg : q.nat_degree ≤ p.nat_degree,	r : polynomial R,	hr : q = p * r,	rzero : r ≠ 0	⊢ q = p
2 goals	R : Type u,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	p q : polynomial R,	hp : p.monic,	hq : q.monic,	hdeg : q.nat_degree ≤ p.nat_degree,	r : polynomial R,	hr : q = p * r,	h : r = 0	⊢ false		R : Type u,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	p q : polynomial R,	hp : p.monic,	hq : q.monic,	hdeg : q.nat_degree ≤ p.nat_degree,	r : polynomial R,	hr : q = p * r,	rzero : r ≠ 0	⊢ q = p
R : Type u,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	p q : polynomial R,	hp : p.monic,	hq : q.monic,	hdeg : q.nat_degree ≤ p.nat_degree,	r : polynomial R,	hr : q = p * r,	rzero : r ≠ 0	⊢ q = p
R : Type u,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	p q : polynomial R,	hp : p.monic,	hq : q.monic,	r : polynomial R,	hr : q = p * r,	rzero : r ≠ 0,	hdeg : p.nat_degree + r.nat_degree ≤ p.nat_degree	⊢ q = p
2 goals	R : Type u,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	p q : polynomial R,	hp : p.monic,	hq : q.monic,	r : polynomial R,	hr : q = p * r,	rzero : r ≠ 0,	hdeg : p.nat_degree + r.nat_degree ≤ p.nat_degree	⊢ p.nat_degree + r.nat_degree = p.nat_degree		R : Type u,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	p q : polynomial R,	hp : p.monic,	hq : q.monic,	r : polynomial R,	hr : q = p * r,	rzero : r ≠ 0,	hdeg : p.nat_degree + r.nat_degree ≤ p.nat_degree,	hdegeq : p.nat_degree + r.nat_degree = p.nat_degree	⊢ q = p
3 goals	R : Type u,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	p q : polynomial R,	hp : p.monic,	hq : q.monic,	r : polynomial R,	hr : q = p * r,	rzero : r ≠ 0,	hdeg : p.nat_degree + r.nat_degree ≤ p.nat_degree,	hdegle : p.nat_degree ≤ p.nat_degree + r.nat_degree	⊢ p.nat_degree + r.nat_degree = p.nat_degree		R : Type u,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	p q : polynomial R,	hp : p.monic,	hq : q.monic,	r : polynomial R,	hr : q = p * r,	rzero : r ≠ 0,	hdeg : p.nat_degree + r.nat_degree ≤ p.nat_degree	⊢ p.nat_degree ≤ p.nat_degree + r.nat_degree		R : Type u,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	p q : polynomial R,	hp : p.monic,	hq : q.monic,	r : polynomial R,	hr : q = p * r,	rzero : r ≠ 0,	hdeg : p.nat_degree + r.nat_degree ≤ p.nat_degree,	hdegeq : p.nat_degree + r.nat_degree = p.nat_degree	⊢ q = p
2 goals	R : Type u,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	p q : polynomial R,	hp : p.monic,	hq : q.monic,	r : polynomial R,	hr : q = p * r,	rzero : r ≠ 0,	hdeg : p.nat_degree + r.nat_degree ≤ p.nat_degree	⊢ p.nat_degree ≤ p.nat_degree + r.nat_degree		R : Type u,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	p q : polynomial R,	hp : p.monic,	hq : q.monic,	r : polynomial R,	hr : q = p * r,	rzero : r ≠ 0,	hdeg : p.nat_degree + r.nat_degree ≤ p.nat_degree,	hdegeq : p.nat_degree + r.nat_degree = p.nat_degree	⊢ q = p
R : Type u,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	p q : polynomial R,	hp : p.monic,	hq : q.monic,	r : polynomial R,	hr : q = p * r,	rzero : r ≠ 0,	hdeg : p.nat_degree + r.nat_degree ≤ p.nat_degree,	hdegeq : p.nat_degree + r.nat_degree = p.nat_degree	⊢ q = p
R : Type u,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	p q : polynomial R,	hp : p.monic,	hq : q.monic,	r : polynomial R,	hr : q = p * r,	rzero : r ≠ 0,	hdeg : p.nat_degree + r.nat_degree ≤ p.nat_degree,	hdegeq : r = ⇑C (r.coeff 0)	⊢ q = p
2 goals	R : Type u,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	p q : polynomial R,	hp : p.monic,	hq : q.monic,	r : polynomial R,	hr : q = p * r,	rzero : r ≠ 0,	hdeg : p.nat_degree + r.nat_degree ≤ p.nat_degree,	hdegeq : r = ⇑C (r.coeff 0),	hlead : 1 = r.leading_coeff	⊢ q = p		R : Type u,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	p q : polynomial R,	hp : p.monic,	hq : q.monic,	r : polynomial R,	hr : q = p * r,	rzero : r ≠ 0,	hdeg : p.nat_degree + r.nat_degree ≤ p.nat_degree,	hdegeq : r = ⇑C (r.coeff 0)	⊢ 1 = r.leading_coeff
2 goals	R : Type u,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	p q : polynomial R,	hp : p.monic,	hq : q.monic,	r : polynomial R,	hr : q = p * r,	rzero : r ≠ 0,	hdeg : p.nat_degree + r.nat_degree ≤ p.nat_degree,	hdegeq : r = ⇑C (r.coeff 0),	hlead : 1 = r.leading_coeff,	hcoeff : (⇑C (r.coeff 0)).leading_coeff = r.coeff 0	⊢ q = p		R : Type u,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	p q : polynomial R,	hp : p.monic,	hq : q.monic,	r : polynomial R,	hr : q = p * r,	rzero : r ≠ 0,	hdeg : p.nat_degree + r.nat_degree ≤ p.nat_degree,	hdegeq : r = ⇑C (r.coeff 0)	⊢ 1 = r.leading_coeff
2 goals	R : Type u,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	p q : polynomial R,	hp : p.monic,	hq : q.monic,	r : polynomial R,	hr : q = p * r,	rzero : r ≠ 0,	hdeg : p.nat_degree + r.nat_degree ≤ p.nat_degree,	hdegeq : r = ⇑C (r.coeff 0),	hlead : 1 = r.leading_coeff,	hcoeff : 1 = r.coeff 0	⊢ q = p		R : Type u,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	p q : polynomial R,	hp : p.monic,	hq : q.monic,	r : polynomial R,	hr : q = p * r,	rzero : r ≠ 0,	hdeg : p.nat_degree + r.nat_degree ≤ p.nat_degree,	hdegeq : r = ⇑C (r.coeff 0)	⊢ 1 = r.leading_coeff
2 goals	R : Type u,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	p q : polynomial R,	hp : p.monic,	hq : q.monic,	r : polynomial R,	hr : q = p * r,	rzero : r ≠ 0,	hdeg : p.nat_degree + r.nat_degree ≤ p.nat_degree,	hlead : 1 = r.leading_coeff,	hcoeff : 1 = r.coeff 0,	hdegeq : r = 1	⊢ q = p		R : Type u,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	p q : polynomial R,	hp : p.monic,	hq : q.monic,	r : polynomial R,	hr : q = p * r,	rzero : r ≠ 0,	hdeg : p.nat_degree + r.nat_degree ≤ p.nat_degree,	hdegeq : r = ⇑C (r.coeff 0)	⊢ 1 = r.leading_coeff
R : Type u,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	p q : polynomial R,	hp : p.monic,	hq : q.monic,	r : polynomial R,	hr : q = p * r,	rzero : r ≠ 0,	hdeg : p.nat_degree + r.nat_degree ≤ p.nat_degree,	hdegeq : r = ⇑C (r.coeff 0)	⊢ 1 = r.leading_coeff
2 goals	R : Type u,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	p q : polynomial R,	hp : p.monic,	hq : q.monic,	r : polynomial R,	hr : q = p * r,	rzero : r ≠ 0,	hdeg : p.nat_degree + r.nat_degree ≤ p.nat_degree,	hdegeq : r = ⇑C (r.coeff 0)	⊢ q.leading_coeff = p.leading_coeff * r.leading_coeff		R : Type u,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	p q : polynomial R,	hp : p.monic,	hq : q.monic,	r : polynomial R,	hr : q = p * r,	rzero : r ≠ 0,	hdeg : p.nat_degree + r.nat_degree ≤ p.nat_degree,	hdegeq : r = ⇑C (r.coeff 0),	hprod : q.leading_coeff = p.leading_coeff * r.leading_coeff	⊢ 1 = r.leading_coeff
R : Type u,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	p q : polynomial R,	hp : p.monic,	hq : q.monic,	r : polynomial R,	hr : q = p * r,	rzero : r ≠ 0,	hdeg : p.nat_degree + r.nat_degree ≤ p.nat_degree,	hdegeq : r = ⇑C (r.coeff 0),	hprod : q.leading_coeff = p.leading_coeff * r.leading_coeff	⊢ 1 = r.leading_coeff
⊢ ∀ {n : ℕ} {F : typevec n → Type u_1} [_inst_1 : mvfunctor F] [q : mvqpf F],	    q.liftp_preservation ↔ q.is_uniform
n : ℕ,	F : typevec n → Type u_1,	_inst_1 : mvfunctor F,	q : mvqpf F	⊢ q.liftp_preservation ↔ q.is_uniform
⊢ ∀ {F : Type u → Type u} [_inst_1 : functor F] [q : qpf F], q.supp_preservation ↔ q.is_uniform
F : Type u → Type u,	_inst_1 : functor F,	q : qpf F	⊢ q.supp_preservation ↔ q.is_uniform
2 goals	F : Type u → Type u,	_inst_1 : functor F,	q : qpf F	⊢ q.supp_preservation → q.is_uniform		F : Type u → Type u,	_inst_1 : functor F,	q : qpf F	⊢ q.is_uniform → q.supp_preservation
2 goals	F : Type u → Type u,	_inst_1 : functor F,	q : qpf F,	h : q.supp_preservation,	α : Type u,	a a' : (P F).A,	f : (P F).B a → α,	f' : (P F).B a' → α,	h' : abs ⟨a, f⟩ = abs ⟨a', f'⟩	⊢ f '' univ = f' '' univ		F : Type u → Type u,	_inst_1 : functor F,	q : qpf F	⊢ q.is_uniform → q.supp_preservation
F : Type u → Type u,	_inst_1 : functor F,	q : qpf F	⊢ q.is_uniform → q.supp_preservation
F : Type u → Type u,	_inst_1 : functor F,	q : qpf F,	h : q.is_uniform,	α : Type u,	a : (P F).A,	f : (P F).B a → α	⊢ supp (abs ⟨a, f⟩) = supp ⟨a, f⟩
⊢ ∀ (a b : ℕ), b ∣ a → ↑(a / b) = ↑a / ↑b
a b : ℕ,	h : b ∣ a	⊢ ↑(a / b) = ↑a / ↑b
b c : ℕ	⊢ ↑(b * c / b) = ↑(b * c) / ↑b
⊢ ∀ {a b c d : ℤ}, 0 < b → 0 < d → (↑a / ↑b < ↑c / ↑d ↔ a * d < c * b)
a b c d : ℤ,	b_pos : 0 < b,	d_pos : 0 < d	⊢ ↑a / ↑b < ↑c / ↑d ↔ a * d < c * b
a b c d : ℤ,	b_pos : 0 < b,	d_pos : 0 < d	⊢ ↑a / ↑b ≤ ↑c / ↑d ∧ ¬↑c / ↑d ≤ ↑a / ↑b ↔ a * d ≤ c * b ∧ ¬c * b ≤ a * d
2 goals	a b c d : ℤ,	b_pos : 0 < b,	d_pos : 0 < d	⊢ ↑a / ↑b ≤ ↑c / ↑d ↔ a * d ≤ c * b		a b c d : ℤ,	b_pos : 0 < b,	d_pos : 0 < d	⊢ ¬↑c / ↑d ≤ ↑a / ↑b ↔ ¬c * b ≤ a * d
a b c d : ℤ,	b_pos : 0 < b,	d_pos : 0 < d	⊢ ¬↑c / ↑d ≤ ↑a / ↑b ↔ ¬c * b ≤ a * d
a b c d : ℤ,	b_pos : 0 < b,	d_pos : 0 < d	⊢ ↑c / ↑d ≤ ↑a / ↑b ↔ c * b ≤ a * d
⊢ ∀ {α : Type u_1} [_inst_1 : linear_ordered_field α] {x y : α}, const abs x ≤ const abs y ↔ x ≤ y
α : Type u_1,	_inst_1 : linear_ordered_field α,	x y : α	⊢ const abs x ≤ const abs y ↔ x ≤ y
α : Type u_1,	_inst_1 : linear_ordered_field α,	x y : α	⊢ const abs x ≤ const abs y ↔ x < y ∨ x = y
⊢ ∀ {α : Type u_1} [_inst_1 : linear_ordered_field α] {β : Type u_2} [_inst_4 : field β] (abv : β → α)	  [_inst_5 : is_absolute_value abv] {ε K : α},	    0 < ε →	    0 < K →	    (∃ (δ : α) (H : δ > 0),	       ∀ {a b : β}, K ≤ abv a → K ≤ abv b → abv (a - b) < δ → abv (a⁻¹ - b⁻¹) < ε)
α : Type u_1,	_inst_1 : linear_ordered_field α,	β : Type u_2,	_inst_4 : field β,	abv : β → α,	_inst_5 : is_absolute_value abv,	ε K : α,	ε0 : 0 < ε,	K0 : 0 < K	⊢ ∃ (δ : α) (H : δ > 0),	    ∀ {a b : β}, K ≤ abv a → K ≤ abv b → abv (a - b) < δ → abv (a⁻¹ - b⁻¹) < ε
α : Type u_1,	_inst_1 : linear_ordered_field α,	β : Type u_2,	_inst_4 : field β,	abv : β → α,	_inst_5 : is_absolute_value abv,	ε K : α,	ε0 : 0 < ε,	K0 : 0 < K,	KK : 0 < K * K	⊢ ∃ (δ : α) (H : δ > 0),	    ∀ {a b : β}, K ≤ abv a → K ≤ abv b → abv (a - b) < δ → abv (a⁻¹ - b⁻¹) < ε
α : Type u_1,	_inst_1 : linear_ordered_field α,	β : Type u_2,	_inst_4 : field β,	abv : β → α,	_inst_5 : is_absolute_value abv,	ε K : α,	ε0 : 0 < ε,	K0 : 0 < K,	KK : 0 < K * K,	εK : 0 < ε * (K * K)	⊢ ∃ (δ : α) (H : δ > 0),	    ∀ {a b : β}, K ≤ abv a → K ≤ abv b → abv (a - b) < δ → abv (a⁻¹ - b⁻¹) < ε
α : Type u_1,	_inst_1 : linear_ordered_field α,	β : Type u_2,	_inst_4 : field β,	abv : β → α,	_inst_5 : is_absolute_value abv,	ε K : α,	ε0 : 0 < ε,	K0 : 0 < K,	KK : 0 < K * K,	εK : 0 < ε * (K * K),	a b : β,	ha : K ≤ abv a,	hb : K ≤ abv b,	h : abv (a - b) < ε * (K * K)	⊢ abv (a⁻¹ - b⁻¹) < ε
α : Type u_1,	_inst_1 : linear_ordered_field α,	β : Type u_2,	_inst_4 : field β,	abv : β → α,	_inst_5 : is_absolute_value abv,	ε K : α,	ε0 : 0 < ε,	K0 : 0 < K,	KK : 0 < K * K,	εK : 0 < ε * (K * K),	a b : β,	ha : K ≤ abv a,	hb : K ≤ abv b,	h : abv (a - b) < ε * (K * K),	a0 : 0 < abv a	⊢ abv (a⁻¹ - b⁻¹) < ε
α : Type u_1,	_inst_1 : linear_ordered_field α,	β : Type u_2,	_inst_4 : field β,	abv : β → α,	_inst_5 : is_absolute_value abv,	ε K : α,	ε0 : 0 < ε,	K0 : 0 < K,	KK : 0 < K * K,	εK : 0 < ε * (K * K),	a b : β,	ha : K ≤ abv a,	hb : K ≤ abv b,	h : abv (a - b) < ε * (K * K),	a0 : 0 < abv a,	b0 : 0 < abv b	⊢ abv (a⁻¹ - b⁻¹) < ε
α : Type u_1,	_inst_1 : linear_ordered_field α,	β : Type u_2,	_inst_4 : field β,	abv : β → α,	_inst_5 : is_absolute_value abv,	ε K : α,	ε0 : 0 < ε,	K0 : 0 < K,	KK : 0 < K * K,	εK : 0 < ε * (K * K),	a b : β,	ha : K ≤ abv a,	hb : K ≤ abv b,	h : abv (a - b) < ε * (K * K),	a0 : 0 < abv a,	b0 : 0 < abv b	⊢ abv (a - b) / (abv b * abv a) < ε * (K * K) / (K * K)
⊢ ∀ {α : Type u_1} {s : finset α} {f : α → ℝ},	    (∀ (i : α), i ∈ s → 0 ≤ f i) →	    ennreal.of_real (s.prod (λ (i : α), f i)) = s.prod (λ (i : α), ennreal.of_real (f i))
α : Type u_1,	s : finset α,	f : α → ℝ,	hf : ∀ (i : α), i ∈ s → 0 ≤ f i	⊢ ennreal.of_real (s.prod (λ (i : α), f i)) = s.prod (λ (i : α), ennreal.of_real (f i))
α : Type u_1,	s : finset α,	f : α → ℝ,	hf : ∀ (i : α), i ∈ s → 0 ≤ f i	⊢ (s.prod f).to_nnreal = s.prod (λ (a : α), (f a).to_nnreal)
⊢ ∀ {a : ennreal} {b : nnreal}, a ≤ ↑b → a.to_real ≤ ↑b
a : ennreal,	b : nnreal,	h : a ≤ ↑b	⊢ a.to_real ≤ ↑b
a : ennreal,	b : nnreal,	h : a ≤ ↑b,	this : ↑(a.to_nnreal) = a	⊢ a.to_real ≤ ↑b
a : ennreal,	b : nnreal,	this : ↑(a.to_nnreal) = a,	h : ↑(a.to_nnreal) ≤ ↑b	⊢ a.to_real ≤ ↑b
⊢ ∀ {a b : ennreal}, a ≠ ⊤ → b ≠ 0 → a < a + b
a b : ennreal,	ha : a ≠ ⊤,	hb : b ≠ 0	⊢ a < a + b
⊢ ∀ {r : nnreal}, ⊤ - ↑r = ⊤
r : nnreal	⊢ ⊤ - ↑r = ⊤
⊢ ∀ {a b : ereal}, -a = -b → a = b
a b : ereal,	h : -a = -b	⊢ a = b
⊢ -1 < golden_conj
⊢ golden_ratio⁻¹ < 1
⊢ ∀ {x : ℝ*}, x.infinite_neg ↔ ∀ (r : ℝ), x < ↑r
x : ℝ*	⊢ x.infinite_neg ↔ ∀ (r : ℝ), x < ↑r
x : ℝ*	⊢ x.infinite_neg = ∀ (r : ℝ), x < ↑r
⊢ ∀ {α : Type u_1} {s : finset α} {f : α → ℝ},	    (∀ (a : α), a ∈ s → 0 ≤ f a) →	    (s.prod (λ (a : α), f a)).to_nnreal = s.prod (λ (a : α), (f a).to_nnreal)
α : Type u_1,	s : finset α,	f : α → ℝ,	hf : ∀ (a : α), a ∈ s → 0 ≤ f a	⊢ (s.prod (λ (a : α), f a)).to_nnreal = s.prod (λ (a : α), (f a).to_nnreal)
α : Type u_1,	s : finset α,	f : α → ℝ,	hf : ∀ (a : α), a ∈ s → 0 ≤ f a	⊢ s.prod (λ (i : α), f i) = s.prod (λ (a : α), ↑((f a).to_nnreal))
⊢ ∀ {x y : ℝ}, 0 ≤ x → 0 ≤ y → (x ≤ sqrt y ↔ x ^ 2 ≤ y)
x y : ℝ,	hx : 0 ≤ x,	hy : 0 ≤ y	⊢ x ≤ sqrt y ↔ x ^ 2 ≤ y
⊢ ∀ {x y : ℝ}, 0 ≤ y → (x ^ 2 ≤ y ↔ -sqrt y ≤ x ∧ x ≤ sqrt y)
x y : ℝ,	h : 0 ≤ y	⊢ x ^ 2 ≤ y ↔ -sqrt y ≤ x ∧ x ≤ sqrt y
2 goals	x y : ℝ,	h : 0 ≤ y	⊢ x ^ 2 ≤ y → -sqrt y ≤ x ∧ x ≤ sqrt y		x y : ℝ,	h : 0 ≤ y	⊢ -sqrt y ≤ x ∧ x ≤ sqrt y → x ^ 2 ≤ y
x y : ℝ,	h : 0 ≤ y	⊢ -sqrt y ≤ x ∧ x ≤ sqrt y → x ^ 2 ≤ y
x y : ℝ,	h : 0 ≤ y	⊢ |x| ≤ sqrt y → |x| ^ 2 ≤ y
⊢ ∀ (x y : nnreal), ⇑sqrt (x * y) = ⇑sqrt x * ⇑sqrt y
x y : nnreal	⊢ ⇑sqrt (x * y) = ⇑sqrt x * ⇑sqrt y
⊢ ∀ {α : Type u} {s₁ s₂ : seq α} {a : α}, a ∈ s₁ → a ∈ s₁.append s₂
α : Type u,	s₁ s₂ : seq α,	a : α,	h : a ∈ s₁	⊢ a ∈ s₁.append s₂
α : Type u,	s₁ s₂ : seq α,	a : α,	h : a ∈ s₁	⊢ ∀ (b : α) (s' : seq α), a = b ∨ a ∈ s'.append s₂ → a ∈ (cons b s').append s₂
α : Type u,	s₁ s₂ : seq α,	a : α,	h : a ∈ s₁,	b : α,	s' : seq α,	ᾰ : a = b ∨ a ∈ s'.append s₂	⊢ a ∈ (cons b s').append s₂
⊢ ∀ {α : Type u} (s : wseq α) (n : ℕ), s.tail.drop n = s.drop (n + 1)
α : Type u,	s : wseq α,	n : ℕ	⊢ s.tail.drop n = s.drop (n + 1)
α : Type u,	s : wseq α,	n : ℕ	⊢ s.tail.drop n = s.drop (1 + n)
α : Type u,	s : wseq α,	n : ℕ	⊢ s.drop (1 + n) = s.tail.drop n
⊢ ∀ {α : Type u_1} {ι : Type u_2} {β : Type u_3} {S : ι → set α} {f : Π (i : ι), ↥(S i) → β}	  {hf : ∀ (i j : ι) (x : α) (hxi : x ∈ S i) (hxj : x ∈ S j), f i ⟨x, hxi⟩ = f j ⟨x, hxj⟩} {T : set α}	  (hT' : T = Union S) (u : ↥T → ↥T) (ui : Π (i : ι), ↥(S i) → ↥(S i)),	    (∀ (i : ι) (x : ↥(S i)), u (inclusion _ x) = inclusion _ (ui i x)) →	    ∀ (uβ : β → β),	      (∀ (i : ι) (x : ↥(S i)), f i (ui i x) = uβ (f i x)) →	      ∀ (x : ↥T), Union_lift S f hf T _ (u x) = uβ (Union_lift S f hf T _ x)
α : Type u_1,	ι : Type u_2,	β : Type u_3,	S : ι → set α,	f : Π (i : ι), ↥(S i) → β,	hf : ∀ (i j : ι) (x : α) (hxi : x ∈ S i) (hxj : x ∈ S j), f i ⟨x, hxi⟩ = f j ⟨x, hxj⟩,	T : set α,	hT' : T = Union S,	u : ↥T → ↥T,	ui : Π (i : ι), ↥(S i) → ↥(S i),	hui : ∀ (i : ι) (x : ↥(S i)), u (inclusion _ x) = inclusion _ (ui i x),	uβ : β → β,	h : ∀ (i : ι) (x : ↥(S i)), f i (ui i x) = uβ (f i x),	x : ↥T	⊢ Union_lift S f hf T _ (u x) = uβ (Union_lift S f hf T _ x)
α : Type u_1,	ι : Type u_2,	β : Type u_3,	S : ι → set α,	f : Π (i : ι), ↥(S i) → β,	hf : ∀ (i j : ι) (x : α) (hxi : x ∈ S i) (hxj : x ∈ S j), f i ⟨x, hxi⟩ = f j ⟨x, hxj⟩,	ui : Π (i : ι), ↥(S i) → ↥(S i),	uβ : β → β,	h : ∀ (i : ι) (x : ↥(S i)), f i (ui i x) = uβ (f i x),	u : ↥(Union S) → ↥(Union S),	hui : ∀ (i : ι) (x : ↥(S i)), u (inclusion _ x) = inclusion _ (ui i x),	x : ↥(Union S)	⊢ Union_lift S f hf (Union S) _ (u x) = uβ (Union_lift S f hf (Union S) _ x)
α : Type u_1,	ι : Type u_2,	β : Type u_3,	S : ι → set α,	f : Π (i : ι), ↥(S i) → β,	hf : ∀ (i j : ι) (x : α) (hxi : x ∈ S i) (hxj : x ∈ S j), f i ⟨x, hxi⟩ = f j ⟨x, hxj⟩,	ui : Π (i : ι), ↥(S i) → ↥(S i),	uβ : β → β,	h : ∀ (i : ι) (x : ↥(S i)), f i (ui i x) = uβ (f i x),	u : ↥(Union S) → ↥(Union S),	hui : ∀ (i : ι) (x : ↥(S i)), u (inclusion _ x) = inclusion _ (ui i x),	x : ↥(Union S),	i : ι,	hi : ↑x ∈ S i	⊢ Union_lift S f hf (Union S) _ (u x) = uβ (Union_lift S f hf (Union S) _ x)
α : Type u_1,	ι : Type u_2,	β : Type u_3,	S : ι → set α,	f : Π (i : ι), ↥(S i) → β,	hf : ∀ (i j : ι) (x : α) (hxi : x ∈ S i) (hxj : x ∈ S j), f i ⟨x, hxi⟩ = f j ⟨x, hxj⟩,	ui : Π (i : ι), ↥(S i) → ↥(S i),	uβ : β → β,	h : ∀ (i : ι) (x : ↥(S i)), f i (ui i x) = uβ (f i x),	u : ↥(Union S) → ↥(Union S),	hui : ∀ (i : ι) (x : ↥(S i)), u (inclusion _ x) = inclusion _ (ui i x),	x : ↥(Union S),	i : ι,	hi : ↑x ∈ S i	⊢ Union_lift S f hf (Union S) _ (u x) = f i (ui i ⟨↑x, hi⟩)
2 goals	α : Type u_1,	ι : Type u_2,	β : Type u_3,	S : ι → set α,	f : Π (i : ι), ↥(S i) → β,	hf : ∀ (i j : ι) (x : α) (hxi : x ∈ S i) (hxj : x ∈ S j), f i ⟨x, hxi⟩ = f j ⟨x, hxj⟩,	ui : Π (i : ι), ↥(S i) → ↥(S i),	uβ : β → β,	h : ∀ (i : ι) (x : ↥(S i)), f i (ui i x) = uβ (f i x),	u : ↥(Union S) → ↥(Union S),	hui : ∀ (i : ι) (x : ↥(S i)), u (inclusion _ x) = inclusion _ (ui i x),	x : ↥(Union S),	i : ι,	hi : ↑x ∈ S i	⊢ x = inclusion _ ⟨↑x, hi⟩		α : Type u_1,	ι : Type u_2,	β : Type u_3,	S : ι → set α,	f : Π (i : ι), ↥(S i) → β,	hf : ∀ (i j : ι) (x : α) (hxi : x ∈ S i) (hxj : x ∈ S j), f i ⟨x, hxi⟩ = f j ⟨x, hxj⟩,	ui : Π (i : ι), ↥(S i) → ↥(S i),	uβ : β → β,	h : ∀ (i : ι) (x : ↥(S i)), f i (ui i x) = uβ (f i x),	u : ↥(Union S) → ↥(Union S),	hui : ∀ (i : ι) (x : ↥(S i)), u (inclusion _ x) = inclusion _ (ui i x),	x : ↥(Union S),	i : ι,	hi : ↑x ∈ S i,	this : x = inclusion _ ⟨↑x, hi⟩	⊢ Union_lift S f hf (Union S) _ (u x) = f i (ui i ⟨↑x, hi⟩)
2 goals	α : Type u_1,	ι : Type u_2,	β : Type u_3,	S : ι → set α,	f : Π (i : ι), ↥(S i) → β,	hf : ∀ (i j : ι) (x : α) (hxi : x ∈ S i) (hxj : x ∈ S j), f i ⟨x, hxi⟩ = f j ⟨x, hxj⟩,	ui : Π (i : ι), ↥(S i) → ↥(S i),	uβ : β → β,	h : ∀ (i : ι) (x : ↥(S i)), f i (ui i x) = uβ (f i x),	u : ↥(Union S) → ↥(Union S),	hui : ∀ (i : ι) (x : ↥(S i)), u (inclusion _ x) = inclusion _ (ui i x),	i : ι,	x_val : α,	x_property : x_val ∈ Union S,	hi : ↑⟨x_val, x_property⟩ ∈ S i	⊢ ⟨x_val, x_property⟩ = inclusion _ ⟨↑⟨x_val, x_property⟩, hi⟩		α : Type u_1,	ι : Type u_2,	β : Type u_3,	S : ι → set α,	f : Π (i : ι), ↥(S i) → β,	hf : ∀ (i j : ι) (x : α) (hxi : x ∈ S i) (hxj : x ∈ S j), f i ⟨x, hxi⟩ = f j ⟨x, hxj⟩,	ui : Π (i : ι), ↥(S i) → ↥(S i),	uβ : β → β,	h : ∀ (i : ι) (x : ↥(S i)), f i (ui i x) = uβ (f i x),	u : ↥(Union S) → ↥(Union S),	hui : ∀ (i : ι) (x : ↥(S i)), u (inclusion _ x) = inclusion _ (ui i x),	x : ↥(Union S),	i : ι,	hi : ↑x ∈ S i,	this : x = inclusion _ ⟨↑x, hi⟩	⊢ Union_lift S f hf (Union S) _ (u x) = f i (ui i ⟨↑x, hi⟩)
α : Type u_1,	ι : Type u_2,	β : Type u_3,	S : ι → set α,	f : Π (i : ι), ↥(S i) → β,	hf : ∀ (i j : ι) (x : α) (hxi : x ∈ S i) (hxj : x ∈ S j), f i ⟨x, hxi⟩ = f j ⟨x, hxj⟩,	ui : Π (i : ι), ↥(S i) → ↥(S i),	uβ : β → β,	h : ∀ (i : ι) (x : ↥(S i)), f i (ui i x) = uβ (f i x),	u : ↥(Union S) → ↥(Union S),	hui : ∀ (i : ι) (x : ↥(S i)), u (inclusion _ x) = inclusion _ (ui i x),	x : ↥(Union S),	i : ι,	hi : ↑x ∈ S i,	this : x = inclusion _ ⟨↑x, hi⟩	⊢ Union_lift S f hf (Union S) _ (u x) = f i (ui i ⟨↑x, hi⟩)
2 goals	α : Type u_1,	ι : Type u_2,	β : Type u_3,	S : ι → set α,	f : Π (i : ι), ↥(S i) → β,	hf : ∀ (i j : ι) (x : α) (hxi : x ∈ S i) (hxj : x ∈ S j), f i ⟨x, hxi⟩ = f j ⟨x, hxj⟩,	ui : Π (i : ι), ↥(S i) → ↥(S i),	uβ : β → β,	h : ∀ (i : ι) (x : ↥(S i)), f i (ui i x) = uβ (f i x),	u : ↥(Union S) → ↥(Union S),	hui : ∀ (i : ι) (x : ↥(S i)), u (inclusion _ x) = inclusion _ (ui i x),	x : ↥(Union S),	i : ι,	hi : ↑x ∈ S i,	this : x = inclusion _ ⟨↑x, hi⟩	⊢ ↑(inclusion _ (ui i ⟨↑x, hi⟩)) ∈ S i		α : Type u_1,	ι : Type u_2,	β : Type u_3,	S : ι → set α,	f : Π (i : ι), ↥(S i) → β,	hf : ∀ (i j : ι) (x : α) (hxi : x ∈ S i) (hxj : x ∈ S j), f i ⟨x, hxi⟩ = f j ⟨x, hxj⟩,	ui : Π (i : ι), ↥(S i) → ↥(S i),	uβ : β → β,	h : ∀ (i : ι) (x : ↥(S i)), f i (ui i x) = uβ (f i x),	u : ↥(Union S) → ↥(Union S),	hui : ∀ (i : ι) (x : ↥(S i)), u (inclusion _ x) = inclusion _ (ui i x),	x : ↥(Union S),	i : ι,	hi : ↑x ∈ S i,	this : x = inclusion _ ⟨↑x, hi⟩,	hx' : ↑(inclusion _ (ui i ⟨↑x, hi⟩)) ∈ S i	⊢ Union_lift S f hf (Union S) _ (u x) = f i (ui i ⟨↑x, hi⟩)
α : Type u_1,	ι : Type u_2,	β : Type u_3,	S : ι → set α,	f : Π (i : ι), ↥(S i) → β,	hf : ∀ (i j : ι) (x : α) (hxi : x ∈ S i) (hxj : x ∈ S j), f i ⟨x, hxi⟩ = f j ⟨x, hxj⟩,	ui : Π (i : ι), ↥(S i) → ↥(S i),	uβ : β → β,	h : ∀ (i : ι) (x : ↥(S i)), f i (ui i x) = uβ (f i x),	u : ↥(Union S) → ↥(Union S),	hui : ∀ (i : ι) (x : ↥(S i)), u (inclusion _ x) = inclusion _ (ui i x),	x : ↥(Union S),	i : ι,	hi : ↑x ∈ S i,	this : x = inclusion _ ⟨↑x, hi⟩,	hx' : ↑(inclusion _ (ui i ⟨↑x, hi⟩)) ∈ S i	⊢ Union_lift S f hf (Union S) _ (u x) = f i (ui i ⟨↑x, hi⟩)
⊢ ∀ {α : Type u} {β : Type v} {f : α → β} {s : set α} {p : β → Prop},	    (∀ (y : β), y ∈ f '' s → p y) ↔ ∀ (x : α), x ∈ s → p (f x)
α : Type u,	β : Type v,	f : α → β,	s : set α,	p : β → Prop	⊢ (∀ (y : β), y ∈ f '' s → p y) ↔ ∀ (x : α), x ∈ s → p (f x)
⊢ ∀ {α : Type u} {β : Type v} {s t : set α} {f : α → β}, injective f → (f '' s ⊆ f '' t ↔ s ⊆ t)
α : Type u,	β : Type v,	s t : set α,	f : α → β,	hf : injective f	⊢ f '' s ⊆ f '' t ↔ s ⊆ t
α : Type u,	β : Type v,	s t : set α,	f : α → β,	hf : injective f,	h : f '' s ⊆ f '' t	⊢ s ⊆ t
α : Type u,	β : Type v,	s t : set α,	f : α → β,	hf : injective f,	h : f '' s ⊆ f '' t	⊢ f ⁻¹' (f '' s) ⊆ f ⁻¹' (f '' t)
⊢ ∀ {α : Type u_1} {t : set α} (p : set α → Prop),	    (∃ (s : set ↥t), p (coe '' s)) ↔ ∃ (s : set α), s ⊆ t ∧ p s
α : Type u_1,	t : set α,	p : set α → Prop	⊢ (∃ (s : set ↥t), p (coe '' s)) ↔ ∃ (s : set α), s ⊆ t ∧ p s
2 goals	α : Type u_1,	t : set α,	p : set α → Prop	⊢ (∃ (s : set ↥t), p (coe '' s)) → (∃ (s : set α), s ⊆ t ∧ p s)		α : Type u_1,	t : set α,	p : set α → Prop	⊢ (∃ (s : set α), s ⊆ t ∧ p s) → (∃ (s : set ↥t), p (coe '' s))
2 goals	α : Type u_1,	t : set α,	p : set α → Prop,	s : set ↥t,	hs : p (coe '' s)	⊢ ∃ (s : set α), s ⊆ t ∧ p s		α : Type u_1,	t : set α,	p : set α → Prop	⊢ (∃ (s : set α), s ⊆ t ∧ p s) → (∃ (s : set ↥t), p (coe '' s))
2 goals	α : Type u_1,	t : set α,	p : set α → Prop,	s : set ↥t,	hs : p (coe '' s)	⊢ coe '' s ⊆ t		α : Type u_1,	t : set α,	p : set α → Prop	⊢ (∃ (s : set α), s ⊆ t ∧ p s) → (∃ (s : set ↥t), p (coe '' s))
2 goals	α : Type u_1,	t : set α,	p : set α → Prop,	s : set ↥t,	hs : p (coe '' s)	⊢ t = range coe		α : Type u_1,	t : set α,	p : set α → Prop	⊢ (∃ (s : set α), s ⊆ t ∧ p s) → (∃ (s : set ↥t), p (coe '' s))
α : Type u_1,	t : set α,	p : set α → Prop	⊢ (∃ (s : set α), s ⊆ t ∧ p s) → (∃ (s : set ↥t), p (coe '' s))
α : Type u_1,	t : set α,	p : set α → Prop,	s : set α,	hs₁ : s ⊆ t,	hs₂ : p s	⊢ ∃ (s : set ↥t), p (coe '' s)
α : Type u_1,	t : set α,	p : set α → Prop,	s : set α,	hs₁ : s ⊆ t,	hs₂ : p s	⊢ p (coe '' (coe ⁻¹' s))
2 goals	α : Type u_1,	t : set α,	p : set α → Prop,	s : set α,	hs₁ : s ⊆ t,	hs₂ : p s	⊢ p s		α : Type u_1,	t : set α,	p : set α → Prop,	s : set α,	hs₁ : s ⊆ t,	hs₂ : p s	⊢ s ⊆ range coe
α : Type u_1,	t : set α,	p : set α → Prop,	s : set α,	hs₁ : s ⊆ t,	hs₂ : p s	⊢ s ⊆ range coe
α : Type u_1,	t : set α,	p : set α → Prop,	s : set α,	hs₁ : s ⊆ t,	hs₂ : p s	⊢ s ⊆ t
⊢ ∀ {α : Type u_1} {s t : set α}, (coe ⁻¹' t).nonempty ↔ (s ∩ t).nonempty
α : Type u_1,	s t : set α	⊢ (coe ⁻¹' t).nonempty ↔ (s ∩ t).nonempty
⊢ ∀ {α : Type u_1} {β : Type u_2} {t : set β}, ∅ ×ˢ t = ∅
α : Type u_1,	β : Type u_2,	t : set β	⊢ ∅ ×ˢ t = ∅
α : Type u_1,	β : Type u_2,	t : set β,	x : α × β	⊢ x ∈ ∅ ×ˢ t ↔ x ∈ ∅
⊢ ∀ {α : Type u_1} {β : Type u_2} {s : set α} {t : set β}, prod.swap ⁻¹' (t ×ˢ s) = s ×ˢ t
α : Type u_1,	β : Type u_2,	s : set α,	t : set β	⊢ prod.swap ⁻¹' (t ×ˢ s) = s ×ˢ t
α : Type u_1,	β : Type u_2,	s : set α,	t : set β,	x : α,	y : β	⊢ (x, y) ∈ prod.swap ⁻¹' (t ×ˢ s) ↔ (x, y) ∈ s ×ˢ t
⊢ ∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {δ : Type u_4} {s : set α} {t : set β} (f : γ → β → δ)	  (g : α → γ), image2 f (g '' s) t = image2 (λ (a : α) (b : β), f (g a) b) s t
α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	s : set α,	t : set β,	f : γ → β → δ,	g : α → γ	⊢ image2 f (g '' s) t = image2 (λ (a : α) (b : β), f (g a) b) s t
α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	s : set α,	t : set β,	f : γ → β → δ,	g : α → γ,	x : δ	⊢ x ∈ image2 f (g '' s) t ↔ x ∈ image2 (λ (a : α) (b : β), f (g a) b) s t
2 goals	α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	s : set α,	t : set β,	f : γ → β → δ,	g : α → γ,	x : δ	⊢ x ∈ image2 f (g '' s) t → x ∈ image2 (λ (a : α) (b : β), f (g a) b) s t		α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	s : set α,	t : set β,	f : γ → β → δ,	g : α → γ,	x : δ	⊢ x ∈ image2 (λ (a : α) (b : β), f (g a) b) s t → x ∈ image2 f (g '' s) t
2 goals	α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	s : set α,	t : set β,	f : γ → β → δ,	g : α → γ,	b : β,	a : α,	ha : a ∈ s,	hb : b ∈ t	⊢ f (g a) b ∈ image2 (λ (a : α) (b : β), f (g a) b) s t		α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	s : set α,	t : set β,	f : γ → β → δ,	g : α → γ,	x : δ	⊢ x ∈ image2 (λ (a : α) (b : β), f (g a) b) s t → x ∈ image2 f (g '' s) t
α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	s : set α,	t : set β,	f : γ → β → δ,	g : α → γ,	x : δ	⊢ x ∈ image2 (λ (a : α) (b : β), f (g a) b) s t → x ∈ image2 f (g '' s) t
α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	s : set α,	t : set β,	f : γ → β → δ,	g : α → γ,	a : α,	b : β,	ha : a ∈ s,	hb : b ∈ t	⊢ (λ (a : α) (b : β), f (g a) b) a b ∈ image2 f (g '' s) t
⊢ ∀ {α : Type u} {β : Type v} {s : set α} {t : Π (x : α), x ∈ s → set β},	    s.countable → (∀ (a : α) (H : a ∈ s), (t a H).countable) → (⋃ (a : α) (H : a ∈ s), t a H).countable
α : Type u,	β : Type v,	s : set α,	t : Π (x : α), x ∈ s → set β,	hs : s.countable,	ht : ∀ (a : α) (H : a ∈ s), (t a H).countable	⊢ (⋃ (a : α) (H : a ∈ s), t a H).countable
α : Type u,	β : Type v,	s : set α,	t : Π (x : α), x ∈ s → set β,	hs : s.countable,	ht : ∀ (a : α) (H : a ∈ s), (t a H).countable	⊢ (⋃ (x : ↥s), t ↑x _).countable
α : Type u,	β : Type v,	s : set α,	t : Π (x : α), x ∈ s → set β,	hs : s.countable,	ht : ∀ (a : α) (H : a ∈ s), (t a H).countable,	_inst : encodable ↥s	⊢ (⋃ (x : ↥s), t ↑x _).countable
⊢ ∀ {α : Type u} {β : Type v} {s : set α} {t : set β} {f : α → β} [_inst_1 : nonempty α],	    surj_on f s t → inv_on (inv_fun_on f s) f (inv_fun_on f s '' t) t
α : Type u,	β : Type v,	s : set α,	t : set β,	f : α → β,	_inst_1 : nonempty α,	h : surj_on f s t	⊢ inv_on (inv_fun_on f s) f (inv_fun_on f s '' t) t
α : Type u,	β : Type v,	s : set α,	t : set β,	f : α → β,	_inst_1 : nonempty α,	h : surj_on f s t	⊢ left_inv_on (inv_fun_on f s) f (inv_fun_on f s '' t)
α : Type u,	β : Type v,	s : set α,	t : set β,	f : α → β,	_inst_1 : nonempty α,	h : surj_on f s t,	y : β,	hy : y ∈ t	⊢ inv_fun_on f s (f (inv_fun_on f s y)) = inv_fun_on f s y
⊢ ∀ {α : Type u} {β : Type v} {fa : α → α} {fb : β → β} {f : α → β},	    semiconj f fa fb → injective fa → inj_on f (range fa) → inj_on fb (range f)
α : Type u,	β : Type v,	fa : α → α,	fb : β → β,	f : α → β,	h : semiconj f fa fb,	ha : injective fa,	hf : inj_on f (range fa)	⊢ inj_on fb (range f)
α : Type u,	β : Type v,	fa : α → α,	fb : β → β,	f : α → β,	h : semiconj f fa fb,	ha : injective fa,	hf : inj_on f (fa '' univ)	⊢ inj_on fb (f '' univ)
⊢ ∀ {α : Type u} [_inst_1 : linear_order α] {a b c : α}, Ioc a b ∪ Ioc a c = Ioc a (max b c)
α : Type u,	_inst_1 : linear_order α,	a b c : α	⊢ Ioc a b ∪ Ioc a c = Ioc a (max b c)
2 goals	α : Type u,	_inst_1 : linear_order α,	a b c : α	⊢ min a b ≤ max a c		α : Type u,	_inst_1 : linear_order α,	a b c : α	⊢ min a c ≤ max a b
α : Type u,	_inst_1 : linear_order α,	a b c : α	⊢ min a c ≤ max a b
⊢ ∀ {α : Type u_1} {β : Type u_2} [_inst_1 : preorder α] [_inst_2 : preorder β] (e : α ≃o β) (a b : β),	    ⇑e ⁻¹' Ico a b = Ico (⇑(e.symm) a) (⇑(e.symm) b)
α : Type u_1,	β : Type u_2,	_inst_1 : preorder α,	_inst_2 : preorder β,	e : α ≃o β,	a b : β	⊢ ⇑e ⁻¹' Ico a b = Ico (⇑(e.symm) a) (⇑(e.symm) b)
⊢ ∀ {α : Type u_1} {β : Type u_2} [_inst_1 : preorder α] [_inst_2 : preorder β] (e : α ≃o β) (a b : α),	    ⇑e '' Ioo a b = Ioo (⇑e a) (⇑e b)
α : Type u_1,	β : Type u_2,	_inst_1 : preorder α,	_inst_2 : preorder β,	e : α ≃o β,	a b : α	⊢ ⇑e '' Ioo a b = Ioo (⇑e a) (⇑e b)
⊢ ∀ {α : Type u} [_inst_1 : partial_order α] {a b : α}, Icc a b \ {a, b} = Ioo a b
α : Type u,	_inst_1 : partial_order α,	a b : α	⊢ Icc a b \ {a, b} = Ioo a b
⊢ ∀ {α : Type u} [_inst_1 : partial_order α] {a b : α}, a ≤ b → Icc a b \ Ioc a b = {a}
α : Type u,	_inst_1 : partial_order α,	a b : α,	h : a ≤ b	⊢ Icc a b \ Ioc a b = {a}
⊢ ∀ {α : Type u} [_inst_1 : linear_order α] {a b : α}, Ioi a \ Ici b = Ioo a b
α : Type u,	_inst_1 : linear_order α,	a b : α	⊢ Ioi a \ Ici b = Ioo a b
⊢ ∀ {G : Type u} [_inst_1 : ordered_add_comm_group G] (a b c : G),	    (λ (x : G), x + a) ⁻¹' Ioo b c = Ioo (b - a) (c - a)
G : Type u,	_inst_1 : ordered_add_comm_group G,	a b c : G	⊢ (λ (x : G), x + a) ⁻¹' Ioo b c = Ioo (b - a) (c - a)
⊢ ∀ {G : Type u} [_inst_1 : ordered_add_comm_group G] (a b c : G),	    (λ (x : G), a + x) '' Ioo b c = Ioo (a + b) (a + c)
G : Type u,	_inst_1 : ordered_add_comm_group G,	a b c : G	⊢ (λ (x : G), a + x) '' Ioo b c = Ioo (a + b) (a + c)
⊢ ∀ {k : Type u} [_inst_1 : linear_ordered_field k] {a b c : k},	    a ≤ b → 0 ≤ c → (λ (x : k), x * c) '' Icc a b = Icc (a * c) (b * c)
k : Type u,	_inst_1 : linear_ordered_field k,	a b c : k,	hab : a ≤ b,	hc : 0 ≤ c	⊢ (λ (x : k), x * c) '' Icc a b = Icc (a * c) (b * c)
2 goals	case or.inl	k : Type u,	_inst_1 : linear_ordered_field k,	a b c : k,	hab : a ≤ b,	hc : 0 ≤ c,	h : 0 = c	⊢ (λ (x : k), x * c) '' Icc a b = Icc (a * c) (b * c)		case or.inr	k : Type u,	_inst_1 : linear_ordered_field k,	a b c : k,	hab : a ≤ b,	hc : 0 ≤ c,	h : 0 < c	⊢ (λ (x : k), x * c) '' Icc a b = Icc (a * c) (b * c)
2 goals	k : Type u,	_inst_1 : linear_ordered_field k,	a b : k,	hab : a ≤ b,	hc : 0 ≤ 0	⊢ (λ (x : k), x * 0) '' Icc a b = Icc (a * 0) (b * 0)		case or.inr	k : Type u,	_inst_1 : linear_ordered_field k,	a b c : k,	hab : a ≤ b,	hc : 0 ≤ c,	h : 0 < c	⊢ (λ (x : k), x * c) '' Icc a b = Icc (a * c) (b * c)
case or.inr	k : Type u,	_inst_1 : linear_ordered_field k,	a b c : k,	hab : a ≤ b,	hc : 0 ≤ c,	h : 0 < c	⊢ (λ (x : k), x * c) '' Icc a b = Icc (a * c) (b * c)
⊢ ∀ {ι : Type u_1} {α : ι → Type u_2} {v : Π (i : ι), set (α i)},	    (univ.pi v).nonempty →	    ∀ (i : ι),	      ((λ (x : Π (i : ι), α i), x i) '' ⋂ (k : ι), (λ (x : Π (j : ι), α j), x k) ⁻¹' v k) = v i
ι : Type u_1,	α : ι → Type u_2,	v : Π (i : ι), set (α i),	hv : (univ.pi v).nonempty,	i : ι	⊢ ((λ (x : Π (i : ι), α i), x i) '' ⋂ (k : ι), (λ (x : Π (j : ι), α j), x k) ⁻¹' v k) = v i
ι : Type u_1,	α : ι → Type u_2,	v : Π (i : ι), set (α i),	hv : (univ.pi v).nonempty,	i : ι,	_inst : Π (a : Prop), decidable a	⊢ ((λ (x : Π (i : ι), α i), x i) '' ⋂ (k : ι), (λ (x : Π (j : ι), α j), x k) ⁻¹' v k) = v i
2 goals	ι : Type u_1,	α : ι → Type u_2,	v : Π (i : ι), set (α i),	hv : (univ.pi v).nonempty,	i : ι,	_inst : Π (a : Prop), decidable a	⊢ ((λ (x : Π (i : ι), α i), x i) '' ⋂ (k : ι), (λ (x : Π (j : ι), α j), x k) ⁻¹' v k) ⊆ v i		ι : Type u_1,	α : ι → Type u_2,	v : Π (i : ι), set (α i),	hv : (univ.pi v).nonempty,	i : ι,	_inst : Π (a : Prop), decidable a	⊢ v i ⊆ (λ (x : Π (i : ι), α i), x i) '' ⋂ (k : ι), (λ (x : Π (j : ι), α j), x k) ⁻¹' v k
ι : Type u_1,	α : ι → Type u_2,	v : Π (i : ι), set (α i),	hv : (univ.pi v).nonempty,	i : ι,	_inst : Π (a : Prop), decidable a	⊢ v i ⊆ (λ (x : Π (i : ι), α i), x i) '' ⋂ (k : ι), (λ (x : Π (j : ι), α j), x k) ⁻¹' v k
ι : Type u_1,	α : ι → Type u_2,	v : Π (i : ι), set (α i),	hv : (univ.pi v).nonempty,	i : ι,	_inst : Π (a : Prop), decidable a,	y : α i,	y_in : y ∈ v i	⊢ y ∈ (λ (x : Π (i : ι), α i), x i) '' ⋂ (k : ι), (λ (x : Π (j : ι), α j), x k) ⁻¹' v k
ι : Type u_1,	α : ι → Type u_2,	v : Π (i : ι), set (α i),	hv : (univ.pi v).nonempty,	i : ι,	_inst : Π (a : Prop), decidable a,	y : α i,	y_in : y ∈ v i	⊢ ∃ (x : Π (i : ι), α i), (∀ (i : ι), x i ∈ v i) ∧ x i = y
ι : Type u_1,	α : ι → Type u_2,	v : Π (i : ι), set (α i),	i : ι,	_inst : Π (a : Prop), decidable a,	y : α i,	y_in : y ∈ v i,	z : Π (i : ι), α i,	hz : z ∈ univ.pi v	⊢ ∃ (x : Π (i : ι), α i), (∀ (i : ι), x i ∈ v i) ∧ x i = y
ι : Type u_1,	α : ι → Type u_2,	v : Π (i : ι), set (α i),	i : ι,	_inst : Π (a : Prop), decidable a,	y : α i,	y_in : y ∈ v i,	z : Π (i : ι), α i,	hz : z ∈ univ.pi v	⊢ ∀ (i_1 : ι), update z i y i_1 ∈ v i_1
ι : Type u_1,	α : ι → Type u_2,	v : Π (i : ι), set (α i),	i : ι,	_inst : Π (a : Prop), decidable a,	y : α i,	y_in : y ∈ v i,	z : Π (i : ι), α i,	hz : z ∈ univ.pi v	⊢ (λ (i : ι) (t : α i), t ∈ v i) i y ∧ ∀ (x : ι), x ≠ i → (λ (i : ι) (t : α i), t ∈ v i) x (z x)
⊢ ∀ {α : Type u_1} {β : Type u_2} {b : β} {p : β → Prop} {s : Π (x : β), x = b ∨ p x → set α},	    (⋃ (x : β) (h : x = b ∨ p x), s x h) = s b _ ∪ ⋃ (x : β) (h : p x), s x _
α : Type u_1,	β : Type u_2,	b : β,	p : β → Prop,	s : Π (x : β), x = b ∨ p x → set α	⊢ (⋃ (x : β) (h : x = b ∨ p x), s x h) = s b _ ∪ ⋃ (x : β) (h : p x), s x _
⊢ ∀ {α : Type u_1} (s : set α), (⋃ (h : s.nonempty), s) = s
α : Type u_1,	s : set α	⊢ (⋃ (h : s.nonempty), s) = s
⊢ ∀ {α : Type u_1} {r : α → α → Prop},	    symmetric r → ∀ {a b : α}, pairwise (r on λ (c : bool), cond c a b) ↔ r a b
α : Type u_1,	r : α → α → Prop,	hr : symmetric r,	a b : α	⊢ pairwise (r on λ (c : bool), cond c a b) ↔ r a b
⊢ ∀ {α : Type u_1} {β : Type u_2} {r : setoid α} {f : α → β} (H : r ≤ ker f) (g : quotient r → β),	    f = g ∘ quotient.mk → quotient.lift f H = g
α : Type u_1,	β : Type u_2,	r : setoid α,	f : α → β,	H : r ≤ ker f,	g : quotient r → β,	Hg : f = g ∘ quotient.mk	⊢ quotient.lift f H = g
α : Type u_1,	β : Type u_2,	r : setoid α,	f : α → β,	H : r ≤ ker f,	g : quotient r → β,	Hg : f = g ∘ quotient.mk,	x : α	⊢ quotient.lift f H (quot.mk setoid.r x) = g (quot.mk setoid.r x)
α : Type u_1,	β : Type u_2,	r : setoid α,	f : α → β,	H : r ≤ ker f,	g : quotient r → β,	Hg : f = g ∘ quotient.mk,	x : α	⊢ (g ∘ quotient.mk) x = g (quot.mk setoid.r x)
⊢ ∀ {l : list char} {s : string}, l.as_string = s ↔ l = s.to_list
l : list char,	s : string	⊢ l.as_string = s ↔ l = s.to_list
⊢ ∀ {n : ℕ} {R : Type u_1} [_inst_1 : ring R] {m : ℕ} [_inst_2 : char_p R m],	    m ∣ n → ∀ (a b : zmod n), ↑(a * b) = ↑a * ↑b
n : ℕ,	R : Type u_1,	_inst_1 : ring R,	m : ℕ,	_inst_2 : char_p R m,	h : m ∣ n,	a b : zmod n	⊢ ↑(a * b) = ↑a * ↑b
2 goals	R : Type u_1,	_inst_1 : ring R,	m : ℕ,	_inst_2 : char_p R m,	h : m ∣ 0,	a b : zmod 0	⊢ ↑(a * b) = ↑a * ↑b		R : Type u_1,	_inst_1 : ring R,	m : ℕ,	_inst_2 : char_p R m,	n : ℕ,	h : m ∣ n.succ,	a b : zmod n.succ	⊢ ↑(a * b) = ↑a * ↑b
R : Type u_1,	_inst_1 : ring R,	m : ℕ,	_inst_2 : char_p R m,	n : ℕ,	h : m ∣ n.succ,	a b : zmod n.succ	⊢ ↑(a * b) = ↑a * ↑b
R : Type u_1,	_inst_1 : ring R,	m : ℕ,	_inst_2 : char_p R m,	n : ℕ,	h : m ∣ n.succ,	a b : zmod n.succ	⊢ ↑↑(a * b) = ↑↑a * ↑↑b
R : Type u_1,	_inst_1 : ring R,	m : ℕ,	_inst_2 : char_p R m,	n : ℕ,	h : m ∣ n.succ,	a b : zmod n.succ	⊢ ↑↑a * ↑↑b = ↑↑(a * b)
R : Type u_1,	_inst_1 : ring R,	m : ℕ,	_inst_2 : char_p R m,	n : ℕ,	h : m ∣ n.succ,	a b : zmod n.succ	⊢ m ∣ ↑a * ↑b - ↑a * ↑b % (n + 1)
⊢ ∀ {α : Type u} [_inst_1 : semiring α], is_semiring_hom id
α : Type u,	_inst_1 : semiring α	⊢ is_semiring_hom id
4 goals	α : Type u,	_inst_1 : semiring α	⊢ id 0 = 0		α : Type u,	_inst_1 : semiring α	⊢ id 1 = 1		α : Type u,	_inst_1 : semiring α	⊢ ∀ {x y : α}, id (x + y) = id x + id y		α : Type u,	_inst_1 : semiring α	⊢ ∀ {x y : α}, id (x * y) = id x * id y
3 goals	α : Type u,	_inst_1 : semiring α	⊢ id 1 = 1		α : Type u,	_inst_1 : semiring α	⊢ ∀ {x y : α}, id (x + y) = id x + id y		α : Type u,	_inst_1 : semiring α	⊢ ∀ {x y : α}, id (x * y) = id x * id y
2 goals	α : Type u,	_inst_1 : semiring α	⊢ ∀ {x y : α}, id (x + y) = id x + id y		α : Type u,	_inst_1 : semiring α	⊢ ∀ {x y : α}, id (x * y) = id x * id y
2 goals	α : Type u,	_inst_1 : semiring α,	x y : α	⊢ id (x + y) = id x + id y		α : Type u,	_inst_1 : semiring α	⊢ ∀ {x y : α}, id (x * y) = id x * id y
α : Type u,	_inst_1 : semiring α	⊢ ∀ {x y : α}, id (x * y) = id x * id y
α : Type u,	_inst_1 : semiring α,	x y : α	⊢ id (x * y) = id x * id y
⊢ ∀ (f : circle_deg1_lift) {x : ℝ} {m : ℤ} {n : ℕ},	    0 < n → (⇑f^[n] x = x + ↑n * ↑m ↔ ⇑f x = x + ↑m)
f : circle_deg1_lift,	x : ℝ,	m : ℤ,	n : ℕ,	hn : 0 < n	⊢ ⇑f^[n] x = x + ↑n * ↑m ↔ ⇑f x = x + ↑m
⊢ ∀ (f : circle_deg1_lift) {x : ℝ} {m : ℤ} {n : ℕ},	    0 < n → (x + ↑n * ↑m < ⇑f^[n] x ↔ x + ↑m < ⇑f x)
f : circle_deg1_lift,	x : ℝ,	m : ℤ,	n : ℕ,	hn : 0 < n	⊢ x + ↑n * ↑m < ⇑f^[n] x ↔ x + ↑m < ⇑f x
⊢ ∀ (f : circle_deg1_lift), f.transnum_aux_seq 0 = ⇑f 0
f : circle_deg1_lift	⊢ f.transnum_aux_seq 0 = ⇑f 0
⊢ ∀ (f : circle_deg1_lift) (x : ℝ),	    tendsto (λ (n : ℕ), (⇑(f ^ n) x - x) / ↑n) at_top (nhds f.translation_number)
f : circle_deg1_lift,	x : ℝ	⊢ tendsto (λ (n : ℕ), (⇑(f ^ n) x - x) / ↑n) at_top (nhds f.translation_number)
f : circle_deg1_lift,	x : ℝ	⊢ tendsto (λ (n : ℕ), (⇑(f ^ n) x - x) / ↑n) at_top	    (nhds	       (↑(⇑translate (⇑multiplicative.of_add x))⁻¹ * f *	          ↑(⇑translate (⇑multiplicative.of_add x))).translation_number)
f : circle_deg1_lift,	x : ℝ	⊢ (λ (n : ℕ), (⇑(f ^ n) x - x) / ↑n) =	    λ (n : ℕ),	      ⇑((↑(⇑translate (⇑multiplicative.of_add x))⁻¹ * f * ↑(⇑translate (⇑multiplicative.of_add x))) ^	             n)	          0 /	        ↑n
f : circle_deg1_lift,	x : ℝ,	n : ℕ	⊢ (⇑(f ^ n) x - x) / ↑n =	    ⇑((↑(⇑translate (⇑multiplicative.of_add x))⁻¹ * f * ↑(⇑translate (⇑multiplicative.of_add x))) ^ n)	        0 /	      ↑n
⊢ ∀ {α : Type u_1} [_inst_1 : measurable_space α] {μ : measure α} {f : α → α} {s : set α},	    measure_preserving f μ μ →	    measurable_set s →	    ∀ {n : ℕ},	      ⇑μ univ < ↑n * ⇑μ s → (∃ (x : α) (H : x ∈ s) (m : ℕ) (H : m ∈ Ioo 0 n), f^[m] x ∈ s)
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure α,	f : α → α,	s : set α,	hf : measure_preserving f μ μ,	hs : measurable_set s,	n : ℕ,	hvol : ⇑μ univ < ↑n * ⇑μ s	⊢ ∃ (x : α) (H : x ∈ s) (m : ℕ) (H : m ∈ Ioo 0 n), f^[m] x ∈ s
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure α,	f : α → α,	s : set α,	hf : measure_preserving f μ μ,	hs : measurable_set s,	n : ℕ,	hvol : ⇑μ univ < ↑n * ⇑μ s,	A : ∀ (m : ℕ), measurable_set (f^[m] ⁻¹' s)	⊢ ∃ (x : α) (H : x ∈ s) (m : ℕ) (H : m ∈ Ioo 0 n), f^[m] x ∈ s
2 goals	α : Type u_1,	_inst_1 : measurable_space α,	μ : measure α,	f : α → α,	s : set α,	hf : measure_preserving f μ μ,	hs : measurable_set s,	n : ℕ,	hvol : ⇑μ univ < ↑n * ⇑μ s,	A : ∀ (m : ℕ), measurable_set (f^[m] ⁻¹' s)	⊢ ∀ (m : ℕ), ⇑μ (f^[m] ⁻¹' s) = ⇑μ s		α : Type u_1,	_inst_1 : measurable_space α,	μ : measure α,	f : α → α,	s : set α,	hf : measure_preserving f μ μ,	hs : measurable_set s,	n : ℕ,	hvol : ⇑μ univ < ↑n * ⇑μ s,	A : ∀ (m : ℕ), measurable_set (f^[m] ⁻¹' s),	B : ∀ (m : ℕ), ⇑μ (f^[m] ⁻¹' s) = ⇑μ s	⊢ ∃ (x : α) (H : x ∈ s) (m : ℕ) (H : m ∈ Ioo 0 n), f^[m] x ∈ s
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure α,	f : α → α,	s : set α,	hf : measure_preserving f μ μ,	hs : measurable_set s,	n : ℕ,	hvol : ⇑μ univ < ↑n * ⇑μ s,	A : ∀ (m : ℕ), measurable_set (f^[m] ⁻¹' s),	B : ∀ (m : ℕ), ⇑μ (f^[m] ⁻¹' s) = ⇑μ s	⊢ ∃ (x : α) (H : x ∈ s) (m : ℕ) (H : m ∈ Ioo 0 n), f^[m] x ∈ s
2 goals	α : Type u_1,	_inst_1 : measurable_space α,	μ : measure α,	f : α → α,	s : set α,	hf : measure_preserving f μ μ,	hs : measurable_set s,	n : ℕ,	hvol : ⇑μ univ < ↑n * ⇑μ s,	A : ∀ (m : ℕ), measurable_set (f^[m] ⁻¹' s),	B : ∀ (m : ℕ), ⇑μ (f^[m] ⁻¹' s) = ⇑μ s	⊢ ⇑μ univ < (finset.range n).sum (λ (m : ℕ), ⇑μ (f^[m] ⁻¹' s))		α : Type u_1,	_inst_1 : measurable_space α,	μ : measure α,	f : α → α,	s : set α,	hf : measure_preserving f μ μ,	hs : measurable_set s,	n : ℕ,	hvol : ⇑μ univ < ↑n * ⇑μ s,	A : ∀ (m : ℕ), measurable_set (f^[m] ⁻¹' s),	B : ∀ (m : ℕ), ⇑μ (f^[m] ⁻¹' s) = ⇑μ s,	this : ⇑μ univ < (finset.range n).sum (λ (m : ℕ), ⇑μ (f^[m] ⁻¹' s))	⊢ ∃ (x : α) (H : x ∈ s) (m : ℕ) (H : m ∈ Ioo 0 n), f^[m] x ∈ s
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure α,	f : α → α,	s : set α,	hf : measure_preserving f μ μ,	hs : measurable_set s,	n : ℕ,	hvol : ⇑μ univ < ↑n * ⇑μ s,	A : ∀ (m : ℕ), measurable_set (f^[m] ⁻¹' s),	B : ∀ (m : ℕ), ⇑μ (f^[m] ⁻¹' s) = ⇑μ s,	this : ⇑μ univ < (finset.range n).sum (λ (m : ℕ), ⇑μ (f^[m] ⁻¹' s))	⊢ ∃ (x : α) (H : x ∈ s) (m : ℕ) (H : m ∈ Ioo 0 n), f^[m] x ∈ s
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure α,	f : α → α,	s : set α,	hf : measure_preserving f μ μ,	hs : measurable_set s,	n : ℕ,	hvol : ⇑μ univ < ↑n * ⇑μ s,	A : ∀ (m : ℕ), measurable_set (f^[m] ⁻¹' s),	B : ∀ (m : ℕ), ⇑μ (f^[m] ⁻¹' s) = ⇑μ s,	this : ⇑μ univ < (finset.range n).sum (λ (m : ℕ), ⇑μ (f^[m] ⁻¹' s)),	i : ℕ,	hi : i ∈ finset.range n,	j : ℕ,	hj : j ∈ finset.range n,	hij : i ≠ j,	x : α,	hxi : x ∈ (λ (m : ℕ), f^[m] ⁻¹' s) i,	hxj : x ∈ (λ (m : ℕ), f^[m] ⁻¹' s) j	⊢ ∃ (x : α) (H : x ∈ s) (m : ℕ) (H : m ∈ Ioo 0 n), f^[m] x ∈ s
2 goals	case main	α : Type u_1,	_inst_1 : measurable_space α,	μ : measure α,	f : α → α,	s : set α,	hf : measure_preserving f μ μ,	hs : measurable_set s,	n : ℕ,	hvol : ⇑μ univ < ↑n * ⇑μ s,	A : ∀ (m : ℕ), measurable_set (f^[m] ⁻¹' s),	B : ∀ (m : ℕ), ⇑μ (f^[m] ⁻¹' s) = ⇑μ s,	this : ⇑μ univ < (finset.range n).sum (λ (m : ℕ), ⇑μ (f^[m] ⁻¹' s)),	x : α,	i j : ℕ,	hlt : i < j,	hi : i ∈ finset.range n,	hj : j ∈ finset.range n,	hij : i ≠ j,	hxi : x ∈ (λ (m : ℕ), f^[m] ⁻¹' s) i,	hxj : x ∈ (λ (m : ℕ), f^[m] ⁻¹' s) j	⊢ ∃ (x : α) (H : x ∈ s) (m : ℕ) (H : m ∈ Ioo 0 n), f^[m] x ∈ s		case invariant	α : Type u_1,	_inst_1 : measurable_space α,	μ : measure α,	f : α → α,	s : set α,	hf : measure_preserving f μ μ,	hs : measurable_set s,	n : ℕ,	hvol : ⇑μ univ < ↑n * ⇑μ s,	A : ∀ (m : ℕ), measurable_set (f^[m] ⁻¹' s),	B : ∀ (m : ℕ), ⇑μ (f^[m] ⁻¹' s) = ⇑μ s,	this : ⇑μ univ < (finset.range n).sum (λ (m : ℕ), ⇑μ (f^[m] ⁻¹' s)),	x : α,	i j : ℕ,	hlt : j < i,	this :	  j ∈ finset.range n →	  i ∈ finset.range n →	  j ≠ i →	  x ∈ (λ (m : ℕ), f^[m] ⁻¹' s) j →	  x ∈ (λ (m : ℕ), f^[m] ⁻¹' s) i → (∃ (x : α) (H : x ∈ s) (m : ℕ) (H : m ∈ Ioo 0 n), f^[m] x ∈ s)	⊢ i ∈ finset.range n →	  j ∈ finset.range n →	  i ≠ j →	  x ∈ (λ (m : ℕ), f^[m] ⁻¹' s) i →	  x ∈ (λ (m : ℕ), f^[m] ⁻¹' s) j → (∃ (x : α) (H : x ∈ s) (m : ℕ) (H : m ∈ Ioo 0 n), f^[m] x ∈ s)
2 goals	case main	α : Type u_1,	_inst_1 : measurable_space α,	μ : measure α,	f : α → α,	s : set α,	hf : measure_preserving f μ μ,	hs : measurable_set s,	n : ℕ,	hvol : ⇑μ univ < ↑n * ⇑μ s,	A : ∀ (m : ℕ), measurable_set (f^[m] ⁻¹' s),	B : ∀ (m : ℕ), ⇑μ (f^[m] ⁻¹' s) = ⇑μ s,	this : ⇑μ univ < (finset.range n).sum (λ (m : ℕ), ⇑μ (f^[m] ⁻¹' s)),	x : α,	i j : ℕ,	hlt : i < j,	hij : i ≠ j,	hxj : f^[j] x ∈ s,	hxi : f^[i] x ∈ s,	hj : j < n,	hi : i < n	⊢ ∃ (x : α) (H : x ∈ s) (m : ℕ) (H : m ∈ Ioo 0 n), f^[m] x ∈ s		case invariant	α : Type u_1,	_inst_1 : measurable_space α,	μ : measure α,	f : α → α,	s : set α,	hf : measure_preserving f μ μ,	hs : measurable_set s,	n : ℕ,	hvol : ⇑μ univ < ↑n * ⇑μ s,	A : ∀ (m : ℕ), measurable_set (f^[m] ⁻¹' s),	B : ∀ (m : ℕ), ⇑μ (f^[m] ⁻¹' s) = ⇑μ s,	this : ⇑μ univ < (finset.range n).sum (λ (m : ℕ), ⇑μ (f^[m] ⁻¹' s)),	x : α,	i j : ℕ,	hlt : j < i,	this :	  j ∈ finset.range n →	  i ∈ finset.range n →	  j ≠ i →	  x ∈ (λ (m : ℕ), f^[m] ⁻¹' s) j →	  x ∈ (λ (m : ℕ), f^[m] ⁻¹' s) i → (∃ (x : α) (H : x ∈ s) (m : ℕ) (H : m ∈ Ioo 0 n), f^[m] x ∈ s)	⊢ i ∈ finset.range n →	  j ∈ finset.range n →	  i ≠ j →	  x ∈ (λ (m : ℕ), f^[m] ⁻¹' s) i →	  x ∈ (λ (m : ℕ), f^[m] ⁻¹' s) j → (∃ (x : α) (H : x ∈ s) (m : ℕ) (H : m ∈ Ioo 0 n), f^[m] x ∈ s)
2 goals	α : Type u_1,	_inst_1 : measurable_space α,	μ : measure α,	f : α → α,	s : set α,	hf : measure_preserving f μ μ,	hs : measurable_set s,	n : ℕ,	hvol : ⇑μ univ < ↑n * ⇑μ s,	A : ∀ (m : ℕ), measurable_set (f^[m] ⁻¹' s),	B : ∀ (m : ℕ), ⇑μ (f^[m] ⁻¹' s) = ⇑μ s,	this : ⇑μ univ < (finset.range n).sum (λ (m : ℕ), ⇑μ (f^[m] ⁻¹' s)),	x : α,	i j : ℕ,	hlt : i < j,	hij : i ≠ j,	hxj : f^[j] x ∈ s,	hxi : f^[i] x ∈ s,	hj : j < n,	hi : i < n	⊢ f^[j - i] (f^[i] x) ∈ s		case invariant	α : Type u_1,	_inst_1 : measurable_space α,	μ : measure α,	f : α → α,	s : set α,	hf : measure_preserving f μ μ,	hs : measurable_set s,	n : ℕ,	hvol : ⇑μ univ < ↑n * ⇑μ s,	A : ∀ (m : ℕ), measurable_set (f^[m] ⁻¹' s),	B : ∀ (m : ℕ), ⇑μ (f^[m] ⁻¹' s) = ⇑μ s,	this : ⇑μ univ < (finset.range n).sum (λ (m : ℕ), ⇑μ (f^[m] ⁻¹' s)),	x : α,	i j : ℕ,	hlt : j < i,	this :	  j ∈ finset.range n →	  i ∈ finset.range n →	  j ≠ i →	  x ∈ (λ (m : ℕ), f^[m] ⁻¹' s) j →	  x ∈ (λ (m : ℕ), f^[m] ⁻¹' s) i → (∃ (x : α) (H : x ∈ s) (m : ℕ) (H : m ∈ Ioo 0 n), f^[m] x ∈ s)	⊢ i ∈ finset.range n →	  j ∈ finset.range n →	  i ≠ j →	  x ∈ (λ (m : ℕ), f^[m] ⁻¹' s) i →	  x ∈ (λ (m : ℕ), f^[m] ⁻¹' s) j → (∃ (x : α) (H : x ∈ s) (m : ℕ) (H : m ∈ Ioo 0 n), f^[m] x ∈ s)
case invariant	α : Type u_1,	_inst_1 : measurable_space α,	μ : measure α,	f : α → α,	s : set α,	hf : measure_preserving f μ μ,	hs : measurable_set s,	n : ℕ,	hvol : ⇑μ univ < ↑n * ⇑μ s,	A : ∀ (m : ℕ), measurable_set (f^[m] ⁻¹' s),	B : ∀ (m : ℕ), ⇑μ (f^[m] ⁻¹' s) = ⇑μ s,	this : ⇑μ univ < (finset.range n).sum (λ (m : ℕ), ⇑μ (f^[m] ⁻¹' s)),	x : α,	i j : ℕ,	hlt : j < i,	this :	  j ∈ finset.range n →	  i ∈ finset.range n →	  j ≠ i →	  x ∈ (λ (m : ℕ), f^[m] ⁻¹' s) j →	  x ∈ (λ (m : ℕ), f^[m] ⁻¹' s) i → (∃ (x : α) (H : x ∈ s) (m : ℕ) (H : m ∈ Ioo 0 n), f^[m] x ∈ s)	⊢ i ∈ finset.range n →	  j ∈ finset.range n →	  i ≠ j →	  x ∈ (λ (m : ℕ), f^[m] ⁻¹' s) i →	  x ∈ (λ (m : ℕ), f^[m] ⁻¹' s) j → (∃ (x : α) (H : x ∈ s) (m : ℕ) (H : m ∈ Ioo 0 n), f^[m] x ∈ s)
⊢ ∀ {α : Type u_1} {f : α → α} {x : α} {m : ℕ},	    is_periodic_pt f m x → ∀ (n : ℕ), is_periodic_pt f (n * m) x
α : Type u_1,	f : α → α,	x : α,	m : ℕ,	hm : is_periodic_pt f m x,	n : ℕ	⊢ is_periodic_pt f (n * m) x
⊢ ∀ {F : Type u_1} [_inst_1 : field F] {E : Type u_2} [_inst_2 : field E] [_inst_3 : algebra F E],	    (∀ (x : E), module.rank F ↥F⟮x⟯ = 1) → ⊥ = ⊤
F : Type u_1,	_inst_1 : field F,	E : Type u_2,	_inst_2 : field E,	_inst_3 : algebra F E,	h : ∀ (x : E), module.rank F ↥F⟮x⟯ = 1	⊢ ⊥ = ⊤
F : Type u_1,	_inst_1 : field F,	E : Type u_2,	_inst_2 : field E,	_inst_3 : algebra F E,	h : ∀ (x : E), module.rank F ↥F⟮x⟯ = 1,	x : E	⊢ x ∈ ⊥ ↔ x ∈ ⊤
F : Type u_1,	_inst_1 : field F,	E : Type u_2,	_inst_2 : field E,	_inst_3 : algebra F E,	h : ∀ (x : E), module.rank F ↥F⟮x⟯ = 1,	x : E	⊢ x ∈ ⊥
⊢ ∀ {F : Type u_1} [_inst_1 : field F] {E : Type u_2} [_inst_2 : field E] [_inst_3 : algebra F E],	    ⊥.to_subalgebra = ⊥
F : Type u_1,	_inst_1 : field F,	E : Type u_2,	_inst_2 : field E,	_inst_3 : algebra F E	⊢ ⊥.to_subalgebra = ⊥
F : Type u_1,	_inst_1 : field F,	E : Type u_2,	_inst_2 : field E,	_inst_3 : algebra F E,	x : E	⊢ x ∈ ⊥.to_subalgebra ↔ x ∈ ⊥
⊢ ∀ (p : ℕ) [_inst_1 : fact (nat.prime p)] (a : (zmod p)ˣ), a ^ (p - 1) = 1
p : ℕ,	_inst_1 : fact (nat.prime p),	a : (zmod p)ˣ	⊢ a ^ (p - 1) = 1
⊢ ∀ {K : Type u} {V : Type v} [_inst_1 : division_ring K] [_inst_2 : add_comm_group V] [_inst_3 : module K V]	  [_inst_4 : is_noetherian_ring K], is_noetherian K V ↔ module.rank K V < omega
K : Type u,	V : Type v,	_inst_1 : division_ring K,	_inst_2 : add_comm_group V,	_inst_3 : module K V,	_inst_4 : is_noetherian_ring K	⊢ is_noetherian K V ↔ module.rank K V < omega
K : Type u,	V : Type v,	_inst_1 : division_ring K,	_inst_2 : add_comm_group V,	_inst_3 : module K V,	_inst_4 : is_noetherian_ring K,	b : basis ↥(basis.of_vector_space_index K V) K V := basis.of_vector_space K V	⊢ is_noetherian K V ↔ module.rank K V < omega
K : Type u,	V : Type v,	_inst_1 : division_ring K,	_inst_2 : add_comm_group V,	_inst_3 : module K V,	_inst_4 : is_noetherian_ring K,	b : basis ↥(basis.of_vector_space_index K V) K V := basis.of_vector_space K V	⊢ is_noetherian K V ↔ (basis.of_vector_space_index K V).finite
2 goals	K : Type u,	V : Type v,	_inst_1 : division_ring K,	_inst_2 : add_comm_group V,	_inst_3 : module K V,	_inst_4 : is_noetherian_ring K,	b : basis ↥(basis.of_vector_space_index K V) K V := basis.of_vector_space K V	⊢ is_noetherian K V → (basis.of_vector_space_index K V).finite		K : Type u,	V : Type v,	_inst_1 : division_ring K,	_inst_2 : add_comm_group V,	_inst_3 : module K V,	_inst_4 : is_noetherian_ring K,	b : basis ↥(basis.of_vector_space_index K V) K V := basis.of_vector_space K V	⊢ (basis.of_vector_space_index K V).finite → is_noetherian K V
2 goals	K : Type u,	V : Type v,	_inst_1 : division_ring K,	_inst_2 : add_comm_group V,	_inst_3 : module K V,	_inst_4 : is_noetherian_ring K,	b : basis ↥(basis.of_vector_space_index K V) K V := basis.of_vector_space K V,	ᾰ : is_noetherian K V	⊢ (basis.of_vector_space_index K V).finite		K : Type u,	V : Type v,	_inst_1 : division_ring K,	_inst_2 : add_comm_group V,	_inst_3 : module K V,	_inst_4 : is_noetherian_ring K,	b : basis ↥(basis.of_vector_space_index K V) K V := basis.of_vector_space K V	⊢ (basis.of_vector_space_index K V).finite → is_noetherian K V
K : Type u,	V : Type v,	_inst_1 : division_ring K,	_inst_2 : add_comm_group V,	_inst_3 : module K V,	_inst_4 : is_noetherian_ring K,	b : basis ↥(basis.of_vector_space_index K V) K V := basis.of_vector_space K V	⊢ (basis.of_vector_space_index K V).finite → is_noetherian K V
K : Type u,	V : Type v,	_inst_1 : division_ring K,	_inst_2 : add_comm_group V,	_inst_3 : module K V,	_inst_4 : is_noetherian_ring K,	b : basis ↥(basis.of_vector_space_index K V) K V := basis.of_vector_space K V,	hbfinite : (basis.of_vector_space_index K V).finite	⊢ is_noetherian K V
K : Type u,	V : Type v,	_inst_1 : division_ring K,	_inst_2 : add_comm_group V,	_inst_3 : module K V,	_inst_4 : is_noetherian_ring K,	b : basis ↥(basis.of_vector_space_index K V) K V := basis.of_vector_space K V,	hbfinite : (basis.of_vector_space_index K V).finite	⊢ is_noetherian K ↥⊤
K : Type u,	V : Type v,	_inst_1 : division_ring K,	_inst_2 : add_comm_group V,	_inst_3 : module K V,	_inst_4 : is_noetherian_ring K,	b : basis ↥(basis.of_vector_space_index K V) K V := basis.of_vector_space K V,	hbfinite : (basis.of_vector_space_index K V).finite	⊢ span K ↑(hbfinite.to_finset) = ⊤
⊢ ∀ {R : Type u} [_inst_1 : comm_semiring R] {p : ℕ},	    0 < p → ∀ (f : polynomial R) (n : ℕ), (⇑(expand R p) f).coeff (p * n) = f.coeff n
R : Type u,	_inst_1 : comm_semiring R,	p : ℕ,	hp : 0 < p,	f : polynomial R,	n : ℕ	⊢ (⇑(expand R p) f).coeff (p * n) = f.coeff n
⊢ ∀ {R : Type u} [_inst_1 : comm_semiring R] {p q : polynomial R}, p.separable → q * q ∣ p → is_unit q
R : Type u,	_inst_1 : comm_semiring R,	p q : polynomial R,	hp : p.separable,	hq : q * q ∣ p	⊢ is_unit q
R : Type u,	_inst_1 : comm_semiring R,	q p : polynomial R,	hp : (q * q * p).separable	⊢ is_unit q
R : Type u,	_inst_1 : comm_semiring R,	q p : polynomial R,	hp : (q * q * p).separable	⊢ is_coprime q q
2 goals	R : Type u,	_inst_1 : comm_semiring R,	q p : polynomial R,	hp : (q * q * p).separable	⊢ is_coprime (q * (q * p)) (q * (⇑derivative q * p + ⇑derivative q * p + q * ⇑derivative p))		R : Type u,	_inst_1 : comm_semiring R,	q p : polynomial R,	hp : (q * q * p).separable,	this : is_coprime (q * (q * p)) (q * (⇑derivative q * p + ⇑derivative q * p + q * ⇑derivative p))	⊢ is_coprime q q
2 goals	R : Type u,	_inst_1 : comm_semiring R,	q p : polynomial R,	hp : (q * q * p).separable	⊢ is_coprime (q * q * p) (q * ⇑derivative q * p + q * ⇑derivative q * p + q * q * ⇑derivative p)		R : Type u,	_inst_1 : comm_semiring R,	q p : polynomial R,	hp : (q * q * p).separable,	this : is_coprime (q * (q * p)) (q * (⇑derivative q * p + ⇑derivative q * p + q * ⇑derivative p))	⊢ is_coprime q q
2 goals	R : Type u,	_inst_1 : comm_semiring R,	q p : polynomial R,	hp : (q * q * p).separable	⊢ q * ⇑derivative q * p + q * ⇑derivative q * p + q * q * ⇑derivative p = ⇑derivative (q * q * p)		R : Type u,	_inst_1 : comm_semiring R,	q p : polynomial R,	hp : (q * q * p).separable,	this : is_coprime (q * (q * p)) (q * (⇑derivative q * p + ⇑derivative q * p + q * ⇑derivative p))	⊢ is_coprime q q
2 goals	R : Type u,	_inst_1 : comm_semiring R,	q p : polynomial R,	hp : (q * q * p).separable	⊢ q * ⇑derivative q * p + q * ⇑derivative q * p + q * q * ⇑derivative p =	    (⇑derivative q * q + q * ⇑derivative q) * p + q * q * ⇑derivative p		R : Type u,	_inst_1 : comm_semiring R,	q p : polynomial R,	hp : (q * q * p).separable,	this : is_coprime (q * (q * p)) (q * (⇑derivative q * p + ⇑derivative q * p + q * ⇑derivative p))	⊢ is_coprime q q
R : Type u,	_inst_1 : comm_semiring R,	q p : polynomial R,	hp : (q * q * p).separable,	this : is_coprime (q * (q * p)) (q * (⇑derivative q * p + ⇑derivative q * p + q * ⇑derivative p))	⊢ is_coprime q q
⊢ ∀ {K : Type u} {L : Type v} {M : Type w} [_inst_1 : field K] [_inst_2 : field L] [_inst_3 : field M]	  (g : L →+* M) (f : K →+* L), subfield.map g f.field_range = (g.comp f).field_range
K : Type u,	L : Type v,	M : Type w,	_inst_1 : field K,	_inst_2 : field L,	_inst_3 : field M,	g : L →+* M,	f : K →+* L	⊢ subfield.map g f.field_range = (g.comp f).field_range
⊢ ∀ {V : Type u_1} [_inst_1 : inner_product_space ℝ V] {x y : V},	    angle x y = 0 ↔ x ≠ 0 ∧ ∃ (r : ℝ), 0 < r ∧ y = r • x
V : Type u_1,	_inst_1 : inner_product_space ℝ V,	x y : V	⊢ angle x y = 0 ↔ x ≠ 0 ∧ ∃ (r : ℝ), 0 < r ∧ y = r • x
V : Type u_1,	_inst_1 : inner_product_space ℝ V,	x y : V	⊢ inner x y / (∥x∥ * ∥y∥) ≤ 1
⊢ ∀ {V : Type u_1} {P : Type u_2} [_inst_1 : inner_product_space ℝ V] [_inst_2 : metric_space P]	  [_inst_3 : normed_add_torsor V P] {t₁ t₂ : triangle ℝ P} {i₁ i₂ i₃ j₁ j₂ j₃ : fin 3},	    i₁ ≠ i₂ →	    i₁ ≠ i₃ →	    i₂ ≠ i₃ →	    j₁ ≠ j₂ →	    j₁ ≠ j₃ →	    j₂ ≠ j₃ →	    t₂.points j₁ = t₁.orthocenter →	    t₂.points j₂ = t₁.points i₂ →	    t₂.points j₃ = t₁.points i₃ → altitude t₂ j₂ = affine_span ℝ {t₁.points i₁, t₁.points i₂}
V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t₁ t₂ : triangle ℝ P,	i₁ i₂ i₃ j₁ j₂ j₃ : fin 3,	hi₁₂ : i₁ ≠ i₂,	hi₁₃ : i₁ ≠ i₃,	hi₂₃ : i₂ ≠ i₃,	hj₁₂ : j₁ ≠ j₂,	hj₁₃ : j₁ ≠ j₃,	hj₂₃ : j₂ ≠ j₃,	h₁ : t₂.points j₁ = t₁.orthocenter,	h₂ : t₂.points j₂ = t₁.points i₂,	h₃ : t₂.points j₃ = t₁.points i₃	⊢ altitude t₂ j₂ = affine_span ℝ {t₁.points i₁, t₁.points i₂}
V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t₁ t₂ : triangle ℝ P,	i₁ i₂ i₃ j₁ j₂ j₃ : fin 3,	hi₁₂ : i₁ ≠ i₂,	hi₁₃ : i₁ ≠ i₃,	hi₂₃ : i₂ ≠ i₃,	hj₁₂ : j₁ ≠ j₂,	hj₁₃ : j₁ ≠ j₃,	hj₂₃ : j₂ ≠ j₃,	h₁ : t₂.points j₁ = t₁.orthocenter,	h₂ : t₂.points j₂ = t₁.points i₂,	h₃ : t₂.points j₃ = t₁.points i₃	⊢ affine_span ℝ {t₁.points i₁, t₁.points i₂} = altitude t₂ j₂
V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t₁ t₂ : triangle ℝ P,	i₁ i₂ i₃ j₁ j₂ j₃ : fin 3,	hi₁₂ : i₁ ≠ i₂,	hi₁₃ : i₁ ≠ i₃,	hi₂₃ : i₂ ≠ i₃,	hj₁₂ : j₁ ≠ j₂,	hj₁₃ : j₁ ≠ j₃,	hj₂₃ : j₂ ≠ j₃,	h₁ : t₂.points j₁ = t₁.orthocenter,	h₂ : t₂.points j₂ = t₁.points i₂,	h₃ : t₂.points j₃ = t₁.points i₃	⊢ t₁.points i₁ ≠ t₂.points j₂ ∧	    t₁.points i₁ ∈ affine_span ℝ (set.range t₂.points) ∧	      t₁.points i₁ -ᵥ t₂.points j₂ ∈ ((affine_span ℝ (t₂.points '' ↑(univ.erase j₂))).direction)ᗮ
V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t₁ t₂ : triangle ℝ P,	i₁ i₂ i₃ j₁ j₂ j₃ : fin 3,	hi₁₂ : i₁ ≠ i₂,	hi₁₃ : i₁ ≠ i₃,	hi₂₃ : i₂ ≠ i₃,	hj₁₂ : j₁ ≠ j₂,	hj₁₃ : j₁ ≠ j₃,	hj₂₃ : j₂ ≠ j₃,	h₁ : t₂.points j₁ = t₁.orthocenter,	h₂ : t₂.points j₂ = t₁.points i₂,	h₃ : t₂.points j₃ = t₁.points i₃	⊢ t₁.points i₁ ≠ t₁.points i₂ ∧	    t₁.points i₁ ∈ affine_span ℝ (set.range t₂.points) ∧	      t₁.points i₁ -ᵥ t₁.points i₂ ∈ ((affine_span ℝ (t₂.points '' ↑(univ.erase j₂))).direction)ᗮ
V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t₁ t₂ : triangle ℝ P,	i₁ i₂ i₃ j₁ j₂ j₃ : fin 3,	hi₁₂ : i₁ ≠ i₂,	hi₁₃ : i₁ ≠ i₃,	hi₂₃ : i₂ ≠ i₃,	hj₁₂ : j₁ ≠ j₂,	hj₁₃ : j₁ ≠ j₃,	hj₂₃ : j₂ ≠ j₃,	h₁ : t₂.points j₁ = t₁.orthocenter,	h₂ : t₂.points j₂ = t₁.points i₂,	h₃ : t₂.points j₃ = t₁.points i₃	⊢ t₁.points i₁ ∈ affine_span ℝ (set.range t₂.points) ∧	    t₁.points i₁ -ᵥ t₁.points i₂ ∈ ((affine_span ℝ (t₂.points '' ↑(univ.erase j₂))).direction)ᗮ
2 goals	V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t₁ t₂ : triangle ℝ P,	i₁ i₂ i₃ j₁ j₂ j₃ : fin 3,	hi₁₂ : i₁ ≠ i₂,	hi₁₃ : i₁ ≠ i₃,	hi₂₃ : i₂ ≠ i₃,	hj₁₂ : j₁ ≠ j₂,	hj₁₃ : j₁ ≠ j₃,	hj₂₃ : j₂ ≠ j₃,	h₁ : t₂.points j₁ = t₁.orthocenter,	h₂ : t₂.points j₂ = t₁.points i₂,	h₃ : t₂.points j₃ = t₁.points i₃	⊢ affine_span ℝ (set.range t₂.points) = affine_span ℝ (set.range t₁.points)		V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t₁ t₂ : triangle ℝ P,	i₁ i₂ i₃ j₁ j₂ j₃ : fin 3,	hi₁₂ : i₁ ≠ i₂,	hi₁₃ : i₁ ≠ i₃,	hi₂₃ : i₂ ≠ i₃,	hj₁₂ : j₁ ≠ j₂,	hj₁₃ : j₁ ≠ j₃,	hj₂₃ : j₂ ≠ j₃,	h₁ : t₂.points j₁ = t₁.orthocenter,	h₂ : t₂.points j₂ = t₁.points i₂,	h₃ : t₂.points j₃ = t₁.points i₃,	he : affine_span ℝ (set.range t₂.points) = affine_span ℝ (set.range t₁.points)	⊢ t₁.points i₁ ∈ affine_span ℝ (set.range t₂.points) ∧	    t₁.points i₁ -ᵥ t₁.points i₂ ∈ ((affine_span ℝ (t₂.points '' ↑(univ.erase j₂))).direction)ᗮ
2 goals	V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t₁ t₂ : triangle ℝ P,	i₁ i₂ i₃ j₁ j₂ j₃ : fin 3,	hi₁₂ : i₁ ≠ i₂,	hi₁₃ : i₁ ≠ i₃,	hi₂₃ : i₂ ≠ i₃,	hj₁₂ : j₁ ≠ j₂,	hj₁₃ : j₁ ≠ j₃,	hj₂₃ : j₂ ≠ j₃,	h₁ : t₂.points j₁ = t₁.orthocenter,	h₂ : t₂.points j₂ = t₁.points i₂,	h₃ : t₂.points j₃ = t₁.points i₃	⊢ (affine_span ℝ (set.range t₂.points)).direction = (affine_span ℝ (set.range t₁.points)).direction		V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t₁ t₂ : triangle ℝ P,	i₁ i₂ i₃ j₁ j₂ j₃ : fin 3,	hi₁₂ : i₁ ≠ i₂,	hi₁₃ : i₁ ≠ i₃,	hi₂₃ : i₂ ≠ i₃,	hj₁₂ : j₁ ≠ j₂,	hj₁₃ : j₁ ≠ j₃,	hj₂₃ : j₂ ≠ j₃,	h₁ : t₂.points j₁ = t₁.orthocenter,	h₂ : t₂.points j₂ = t₁.points i₂,	h₃ : t₂.points j₃ = t₁.points i₃,	he : affine_span ℝ (set.range t₂.points) = affine_span ℝ (set.range t₁.points)	⊢ t₁.points i₁ ∈ affine_span ℝ (set.range t₂.points) ∧	    t₁.points i₁ -ᵥ t₁.points i₂ ∈ ((affine_span ℝ (t₂.points '' ↑(univ.erase j₂))).direction)ᗮ
3 goals	V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t₁ t₂ : triangle ℝ P,	i₁ i₂ i₃ j₁ j₂ j₃ : fin 3,	hi₁₂ : i₁ ≠ i₂,	hi₁₃ : i₁ ≠ i₃,	hi₂₃ : i₂ ≠ i₃,	hj₁₂ : j₁ ≠ j₂,	hj₁₃ : j₁ ≠ j₃,	hj₂₃ : j₂ ≠ j₃,	h₁ : t₂.points j₁ = t₁.orthocenter,	h₂ : t₂.points j₂ = t₁.points i₂,	h₃ : t₂.points j₃ = t₁.points i₃	⊢ set.range t₂.points ⊆ ↑(affine_span ℝ (set.range t₁.points))		V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t₁ t₂ : triangle ℝ P,	i₁ i₂ i₃ j₁ j₂ j₃ : fin 3,	hi₁₂ : i₁ ≠ i₂,	hi₁₃ : i₁ ≠ i₃,	hi₂₃ : i₂ ≠ i₃,	hj₁₂ : j₁ ≠ j₂,	hj₁₃ : j₁ ≠ j₃,	hj₂₃ : j₂ ≠ j₃,	h₁ : t₂.points j₁ = t₁.orthocenter,	h₂ : t₂.points j₂ = t₁.points i₂,	h₃ : t₂.points j₃ = t₁.points i₃	⊢ finrank ℝ ↥((affine_span ℝ (set.range t₂.points)).direction) =	    finrank ℝ ↥((affine_span ℝ (set.range t₁.points)).direction)		V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t₁ t₂ : triangle ℝ P,	i₁ i₂ i₃ j₁ j₂ j₃ : fin 3,	hi₁₂ : i₁ ≠ i₂,	hi₁₃ : i₁ ≠ i₃,	hi₂₃ : i₂ ≠ i₃,	hj₁₂ : j₁ ≠ j₂,	hj₁₃ : j₁ ≠ j₃,	hj₂₃ : j₂ ≠ j₃,	h₁ : t₂.points j₁ = t₁.orthocenter,	h₂ : t₂.points j₂ = t₁.points i₂,	h₃ : t₂.points j₃ = t₁.points i₃,	he : affine_span ℝ (set.range t₂.points) = affine_span ℝ (set.range t₁.points)	⊢ t₁.points i₁ ∈ affine_span ℝ (set.range t₂.points) ∧	    t₁.points i₁ -ᵥ t₁.points i₂ ∈ ((affine_span ℝ (t₂.points '' ↑(univ.erase j₂))).direction)ᗮ
4 goals	V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t₁ t₂ : triangle ℝ P,	i₁ i₂ i₃ j₁ j₂ j₃ : fin 3,	hi₁₂ : i₁ ≠ i₂,	hi₁₃ : i₁ ≠ i₃,	hi₂₃ : i₂ ≠ i₃,	hj₁₂ : j₁ ≠ j₂,	hj₁₃ : j₁ ≠ j₃,	hj₂₃ : j₂ ≠ j₃,	h₁ : t₂.points j₁ = t₁.orthocenter,	h₂ : t₂.points j₂ = t₁.points i₂,	h₃ : t₂.points j₃ = t₁.points i₃	⊢ univ = {j₁, j₂, j₃}		V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t₁ t₂ : triangle ℝ P,	i₁ i₂ i₃ j₁ j₂ j₃ : fin 3,	hi₁₂ : i₁ ≠ i₂,	hi₁₃ : i₁ ≠ i₃,	hi₂₃ : i₂ ≠ i₃,	hj₁₂ : j₁ ≠ j₂,	hj₁₃ : j₁ ≠ j₃,	hj₂₃ : j₂ ≠ j₃,	h₁ : t₂.points j₁ = t₁.orthocenter,	h₂ : t₂.points j₂ = t₁.points i₂,	h₃ : t₂.points j₃ = t₁.points i₃,	hu : univ = {j₁, j₂, j₃}	⊢ set.range t₂.points ⊆ ↑(affine_span ℝ (set.range t₁.points))		V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t₁ t₂ : triangle ℝ P,	i₁ i₂ i₃ j₁ j₂ j₃ : fin 3,	hi₁₂ : i₁ ≠ i₂,	hi₁₃ : i₁ ≠ i₃,	hi₂₃ : i₂ ≠ i₃,	hj₁₂ : j₁ ≠ j₂,	hj₁₃ : j₁ ≠ j₃,	hj₂₃ : j₂ ≠ j₃,	h₁ : t₂.points j₁ = t₁.orthocenter,	h₂ : t₂.points j₂ = t₁.points i₂,	h₃ : t₂.points j₃ = t₁.points i₃	⊢ finrank ℝ ↥((affine_span ℝ (set.range t₂.points)).direction) =	    finrank ℝ ↥((affine_span ℝ (set.range t₁.points)).direction)		V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t₁ t₂ : triangle ℝ P,	i₁ i₂ i₃ j₁ j₂ j₃ : fin 3,	hi₁₂ : i₁ ≠ i₂,	hi₁₃ : i₁ ≠ i₃,	hi₂₃ : i₂ ≠ i₃,	hj₁₂ : j₁ ≠ j₂,	hj₁₃ : j₁ ≠ j₃,	hj₂₃ : j₂ ≠ j₃,	h₁ : t₂.points j₁ = t₁.orthocenter,	h₂ : t₂.points j₂ = t₁.points i₂,	h₃ : t₂.points j₃ = t₁.points i₃,	he : affine_span ℝ (set.range t₂.points) = affine_span ℝ (set.range t₁.points)	⊢ t₁.points i₁ ∈ affine_span ℝ (set.range t₂.points) ∧	    t₁.points i₁ -ᵥ t₁.points i₂ ∈ ((affine_span ℝ (t₂.points '' ↑(univ.erase j₂))).direction)ᗮ
4 goals	V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t₁ t₂ : triangle ℝ P,	i₁ i₂ i₃ j₁ j₂ j₃ : fin 3,	hi₁₂ : i₁ ≠ i₂,	hi₁₃ : i₁ ≠ i₃,	hi₂₃ : i₂ ≠ i₃,	hj₁₂ : j₁ ≠ j₂,	hj₁₃ : j₁ ≠ j₃,	hj₂₃ : j₂ ≠ j₃	⊢ univ = {j₁, j₂, j₃}		V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t₁ t₂ : triangle ℝ P,	i₁ i₂ i₃ j₁ j₂ j₃ : fin 3,	hi₁₂ : i₁ ≠ i₂,	hi₁₃ : i₁ ≠ i₃,	hi₂₃ : i₂ ≠ i₃,	hj₁₂ : j₁ ≠ j₂,	hj₁₃ : j₁ ≠ j₃,	hj₂₃ : j₂ ≠ j₃,	h₁ : t₂.points j₁ = t₁.orthocenter,	h₂ : t₂.points j₂ = t₁.points i₂,	h₃ : t₂.points j₃ = t₁.points i₃,	hu : univ = {j₁, j₂, j₃}	⊢ set.range t₂.points ⊆ ↑(affine_span ℝ (set.range t₁.points))		V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t₁ t₂ : triangle ℝ P,	i₁ i₂ i₃ j₁ j₂ j₃ : fin 3,	hi₁₂ : i₁ ≠ i₂,	hi₁₃ : i₁ ≠ i₃,	hi₂₃ : i₂ ≠ i₃,	hj₁₂ : j₁ ≠ j₂,	hj₁₃ : j₁ ≠ j₃,	hj₂₃ : j₂ ≠ j₃,	h₁ : t₂.points j₁ = t₁.orthocenter,	h₂ : t₂.points j₂ = t₁.points i₂,	h₃ : t₂.points j₃ = t₁.points i₃	⊢ finrank ℝ ↥((affine_span ℝ (set.range t₂.points)).direction) =	    finrank ℝ ↥((affine_span ℝ (set.range t₁.points)).direction)		V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t₁ t₂ : triangle ℝ P,	i₁ i₂ i₃ j₁ j₂ j₃ : fin 3,	hi₁₂ : i₁ ≠ i₂,	hi₁₃ : i₁ ≠ i₃,	hi₂₃ : i₂ ≠ i₃,	hj₁₂ : j₁ ≠ j₂,	hj₁₃ : j₁ ≠ j₃,	hj₂₃ : j₂ ≠ j₃,	h₁ : t₂.points j₁ = t₁.orthocenter,	h₂ : t₂.points j₂ = t₁.points i₂,	h₃ : t₂.points j₃ = t₁.points i₃,	he : affine_span ℝ (set.range t₂.points) = affine_span ℝ (set.range t₁.points)	⊢ t₁.points i₁ ∈ affine_span ℝ (set.range t₂.points) ∧	    t₁.points i₁ -ᵥ t₁.points i₂ ∈ ((affine_span ℝ (t₂.points '' ↑(univ.erase j₂))).direction)ᗮ
3 goals	V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t₁ t₂ : triangle ℝ P,	i₁ i₂ i₃ j₁ j₂ j₃ : fin 3,	hi₁₂ : i₁ ≠ i₂,	hi₁₃ : i₁ ≠ i₃,	hi₂₃ : i₂ ≠ i₃,	hj₁₂ : j₁ ≠ j₂,	hj₁₃ : j₁ ≠ j₃,	hj₂₃ : j₂ ≠ j₃,	h₁ : t₂.points j₁ = t₁.orthocenter,	h₂ : t₂.points j₂ = t₁.points i₂,	h₃ : t₂.points j₃ = t₁.points i₃,	hu : univ = {j₁, j₂, j₃}	⊢ set.range t₂.points ⊆ ↑(affine_span ℝ (set.range t₁.points))		V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t₁ t₂ : triangle ℝ P,	i₁ i₂ i₃ j₁ j₂ j₃ : fin 3,	hi₁₂ : i₁ ≠ i₂,	hi₁₃ : i₁ ≠ i₃,	hi₂₃ : i₂ ≠ i₃,	hj₁₂ : j₁ ≠ j₂,	hj₁₃ : j₁ ≠ j₃,	hj₂₃ : j₂ ≠ j₃,	h₁ : t₂.points j₁ = t₁.orthocenter,	h₂ : t₂.points j₂ = t₁.points i₂,	h₃ : t₂.points j₃ = t₁.points i₃	⊢ finrank ℝ ↥((affine_span ℝ (set.range t₂.points)).direction) =	    finrank ℝ ↥((affine_span ℝ (set.range t₁.points)).direction)		V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t₁ t₂ : triangle ℝ P,	i₁ i₂ i₃ j₁ j₂ j₃ : fin 3,	hi₁₂ : i₁ ≠ i₂,	hi₁₃ : i₁ ≠ i₃,	hi₂₃ : i₂ ≠ i₃,	hj₁₂ : j₁ ≠ j₂,	hj₁₃ : j₁ ≠ j₃,	hj₂₃ : j₂ ≠ j₃,	h₁ : t₂.points j₁ = t₁.orthocenter,	h₂ : t₂.points j₂ = t₁.points i₂,	h₃ : t₂.points j₃ = t₁.points i₃,	he : affine_span ℝ (set.range t₂.points) = affine_span ℝ (set.range t₁.points)	⊢ t₁.points i₁ ∈ affine_span ℝ (set.range t₂.points) ∧	    t₁.points i₁ -ᵥ t₁.points i₂ ∈ ((affine_span ℝ (t₂.points '' ↑(univ.erase j₂))).direction)ᗮ
3 goals	V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t₁ t₂ : triangle ℝ P,	i₁ i₂ i₃ j₁ j₂ j₃ : fin 3,	hi₁₂ : i₁ ≠ i₂,	hi₁₃ : i₁ ≠ i₃,	hi₂₃ : i₂ ≠ i₃,	hj₁₂ : j₁ ≠ j₂,	hj₁₃ : j₁ ≠ j₃,	hj₂₃ : j₂ ≠ j₃,	h₁ : t₂.points j₁ = t₁.orthocenter,	h₂ : t₂.points j₂ = t₁.points i₂,	h₃ : t₂.points j₃ = t₁.points i₃,	hu : univ = {j₁, j₂, j₃}	⊢ t₁.orthocenter ∈ ↑(affine_span ℝ (set.range t₁.points)) ∧	    t₁.points i₂ ∈ ↑(affine_span ℝ (set.range t₁.points)) ∧	      t₁.points i₃ ∈ ↑(affine_span ℝ (set.range t₁.points))		V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t₁ t₂ : triangle ℝ P,	i₁ i₂ i₃ j₁ j₂ j₃ : fin 3,	hi₁₂ : i₁ ≠ i₂,	hi₁₃ : i₁ ≠ i₃,	hi₂₃ : i₂ ≠ i₃,	hj₁₂ : j₁ ≠ j₂,	hj₁₃ : j₁ ≠ j₃,	hj₂₃ : j₂ ≠ j₃,	h₁ : t₂.points j₁ = t₁.orthocenter,	h₂ : t₂.points j₂ = t₁.points i₂,	h₃ : t₂.points j₃ = t₁.points i₃	⊢ finrank ℝ ↥((affine_span ℝ (set.range t₂.points)).direction) =	    finrank ℝ ↥((affine_span ℝ (set.range t₁.points)).direction)		V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t₁ t₂ : triangle ℝ P,	i₁ i₂ i₃ j₁ j₂ j₃ : fin 3,	hi₁₂ : i₁ ≠ i₂,	hi₁₃ : i₁ ≠ i₃,	hi₂₃ : i₂ ≠ i₃,	hj₁₂ : j₁ ≠ j₂,	hj₁₃ : j₁ ≠ j₃,	hj₂₃ : j₂ ≠ j₃,	h₁ : t₂.points j₁ = t₁.orthocenter,	h₂ : t₂.points j₂ = t₁.points i₂,	h₃ : t₂.points j₃ = t₁.points i₃,	he : affine_span ℝ (set.range t₂.points) = affine_span ℝ (set.range t₁.points)	⊢ t₁.points i₁ ∈ affine_span ℝ (set.range t₂.points) ∧	    t₁.points i₁ -ᵥ t₁.points i₂ ∈ ((affine_span ℝ (t₂.points '' ↑(univ.erase j₂))).direction)ᗮ
2 goals	V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t₁ t₂ : triangle ℝ P,	i₁ i₂ i₃ j₁ j₂ j₃ : fin 3,	hi₁₂ : i₁ ≠ i₂,	hi₁₃ : i₁ ≠ i₃,	hi₂₃ : i₂ ≠ i₃,	hj₁₂ : j₁ ≠ j₂,	hj₁₃ : j₁ ≠ j₃,	hj₂₃ : j₂ ≠ j₃,	h₁ : t₂.points j₁ = t₁.orthocenter,	h₂ : t₂.points j₂ = t₁.points i₂,	h₃ : t₂.points j₃ = t₁.points i₃	⊢ finrank ℝ ↥((affine_span ℝ (set.range t₂.points)).direction) =	    finrank ℝ ↥((affine_span ℝ (set.range t₁.points)).direction)		V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t₁ t₂ : triangle ℝ P,	i₁ i₂ i₃ j₁ j₂ j₃ : fin 3,	hi₁₂ : i₁ ≠ i₂,	hi₁₃ : i₁ ≠ i₃,	hi₂₃ : i₂ ≠ i₃,	hj₁₂ : j₁ ≠ j₂,	hj₁₃ : j₁ ≠ j₃,	hj₂₃ : j₂ ≠ j₃,	h₁ : t₂.points j₁ = t₁.orthocenter,	h₂ : t₂.points j₂ = t₁.points i₂,	h₃ : t₂.points j₃ = t₁.points i₃,	he : affine_span ℝ (set.range t₂.points) = affine_span ℝ (set.range t₁.points)	⊢ t₁.points i₁ ∈ affine_span ℝ (set.range t₂.points) ∧	    t₁.points i₁ -ᵥ t₁.points i₂ ∈ ((affine_span ℝ (t₂.points '' ↑(univ.erase j₂))).direction)ᗮ
V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t₁ t₂ : triangle ℝ P,	i₁ i₂ i₃ j₁ j₂ j₃ : fin 3,	hi₁₂ : i₁ ≠ i₂,	hi₁₃ : i₁ ≠ i₃,	hi₂₃ : i₂ ≠ i₃,	hj₁₂ : j₁ ≠ j₂,	hj₁₃ : j₁ ≠ j₃,	hj₂₃ : j₂ ≠ j₃,	h₁ : t₂.points j₁ = t₁.orthocenter,	h₂ : t₂.points j₂ = t₁.points i₂,	h₃ : t₂.points j₃ = t₁.points i₃,	he : affine_span ℝ (set.range t₂.points) = affine_span ℝ (set.range t₁.points)	⊢ t₁.points i₁ ∈ affine_span ℝ (set.range t₂.points) ∧	    t₁.points i₁ -ᵥ t₁.points i₂ ∈ ((affine_span ℝ (t₂.points '' ↑(univ.erase j₂))).direction)ᗮ
V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t₁ t₂ : triangle ℝ P,	i₁ i₂ i₃ j₁ j₂ j₃ : fin 3,	hi₁₂ : i₁ ≠ i₂,	hi₁₃ : i₁ ≠ i₃,	hi₂₃ : i₂ ≠ i₃,	hj₁₂ : j₁ ≠ j₂,	hj₁₃ : j₁ ≠ j₃,	hj₂₃ : j₂ ≠ j₃,	h₁ : t₂.points j₁ = t₁.orthocenter,	h₂ : t₂.points j₂ = t₁.points i₂,	h₃ : t₂.points j₃ = t₁.points i₃,	he : affine_span ℝ (set.range t₂.points) = affine_span ℝ (set.range t₁.points)	⊢ t₁.points i₁ ∈ affine_span ℝ (set.range t₁.points) ∧	    t₁.points i₁ -ᵥ t₁.points i₂ ∈ ((affine_span ℝ (t₂.points '' ↑(univ.erase j₂))).direction)ᗮ
V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t₁ t₂ : triangle ℝ P,	i₁ i₂ i₃ j₁ j₂ j₃ : fin 3,	hi₁₂ : i₁ ≠ i₂,	hi₁₃ : i₁ ≠ i₃,	hi₂₃ : i₂ ≠ i₃,	hj₁₂ : j₁ ≠ j₂,	hj₁₃ : j₁ ≠ j₃,	hj₂₃ : j₂ ≠ j₃,	h₁ : t₂.points j₁ = t₁.orthocenter,	h₂ : t₂.points j₂ = t₁.points i₂,	h₃ : t₂.points j₃ = t₁.points i₃,	he : affine_span ℝ (set.range t₂.points) = affine_span ℝ (set.range t₁.points)	⊢ t₁.points i₁ -ᵥ t₁.points i₂ ∈ ((affine_span ℝ (t₂.points '' ↑(univ.erase j₂))).direction)ᗮ
2 goals	V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t₁ t₂ : triangle ℝ P,	i₁ i₂ i₃ j₁ j₂ j₃ : fin 3,	hi₁₂ : i₁ ≠ i₂,	hi₁₃ : i₁ ≠ i₃,	hi₂₃ : i₂ ≠ i₃,	hj₁₂ : j₁ ≠ j₂,	hj₁₃ : j₁ ≠ j₃,	hj₂₃ : j₂ ≠ j₃,	h₁ : t₂.points j₁ = t₁.orthocenter,	h₂ : t₂.points j₂ = t₁.points i₂,	h₃ : t₂.points j₃ = t₁.points i₃,	he : affine_span ℝ (set.range t₂.points) = affine_span ℝ (set.range t₁.points)	⊢ univ.erase j₂ = {j₁, j₃}		V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t₁ t₂ : triangle ℝ P,	i₁ i₂ i₃ j₁ j₂ j₃ : fin 3,	hi₁₂ : i₁ ≠ i₂,	hi₁₃ : i₁ ≠ i₃,	hi₂₃ : i₂ ≠ i₃,	hj₁₂ : j₁ ≠ j₂,	hj₁₃ : j₁ ≠ j₃,	hj₂₃ : j₂ ≠ j₃,	h₁ : t₂.points j₁ = t₁.orthocenter,	h₂ : t₂.points j₂ = t₁.points i₂,	h₃ : t₂.points j₃ = t₁.points i₃,	he : affine_span ℝ (set.range t₂.points) = affine_span ℝ (set.range t₁.points),	hu : univ.erase j₂ = {j₁, j₃}	⊢ t₁.points i₁ -ᵥ t₁.points i₂ ∈ ((affine_span ℝ (t₂.points '' ↑(univ.erase j₂))).direction)ᗮ
2 goals	V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t₁ t₂ : triangle ℝ P,	i₁ i₂ i₃ j₁ j₂ j₃ : fin 3,	hi₁₂ : i₁ ≠ i₂,	hi₁₃ : i₁ ≠ i₃,	hi₂₃ : i₂ ≠ i₃,	hj₁₂ : j₁ ≠ j₂,	hj₁₃ : j₁ ≠ j₃,	hj₂₃ : j₂ ≠ j₃,	he : affine_span ℝ (set.range t₂.points) = affine_span ℝ (set.range t₁.points)	⊢ univ.erase j₂ = {j₁, j₃}		V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t₁ t₂ : triangle ℝ P,	i₁ i₂ i₃ j₁ j₂ j₃ : fin 3,	hi₁₂ : i₁ ≠ i₂,	hi₁₃ : i₁ ≠ i₃,	hi₂₃ : i₂ ≠ i₃,	hj₁₂ : j₁ ≠ j₂,	hj₁₃ : j₁ ≠ j₃,	hj₂₃ : j₂ ≠ j₃,	h₁ : t₂.points j₁ = t₁.orthocenter,	h₂ : t₂.points j₂ = t₁.points i₂,	h₃ : t₂.points j₃ = t₁.points i₃,	he : affine_span ℝ (set.range t₂.points) = affine_span ℝ (set.range t₁.points),	hu : univ.erase j₂ = {j₁, j₃}	⊢ t₁.points i₁ -ᵥ t₁.points i₂ ∈ ((affine_span ℝ (t₂.points '' ↑(univ.erase j₂))).direction)ᗮ
V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t₁ t₂ : triangle ℝ P,	i₁ i₂ i₃ j₁ j₂ j₃ : fin 3,	hi₁₂ : i₁ ≠ i₂,	hi₁₃ : i₁ ≠ i₃,	hi₂₃ : i₂ ≠ i₃,	hj₁₂ : j₁ ≠ j₂,	hj₁₃ : j₁ ≠ j₃,	hj₂₃ : j₂ ≠ j₃,	h₁ : t₂.points j₁ = t₁.orthocenter,	h₂ : t₂.points j₂ = t₁.points i₂,	h₃ : t₂.points j₃ = t₁.points i₃,	he : affine_span ℝ (set.range t₂.points) = affine_span ℝ (set.range t₁.points),	hu : univ.erase j₂ = {j₁, j₃}	⊢ t₁.points i₁ -ᵥ t₁.points i₂ ∈ ((affine_span ℝ (t₂.points '' ↑(univ.erase j₂))).direction)ᗮ
V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t₁ t₂ : triangle ℝ P,	i₁ i₂ i₃ j₁ j₂ j₃ : fin 3,	hi₁₂ : i₁ ≠ i₂,	hi₁₃ : i₁ ≠ i₃,	hi₂₃ : i₂ ≠ i₃,	hj₁₂ : j₁ ≠ j₂,	hj₁₃ : j₁ ≠ j₃,	hj₂₃ : j₂ ≠ j₃,	h₁ : t₂.points j₁ = t₁.orthocenter,	h₂ : t₂.points j₂ = t₁.points i₂,	h₃ : t₂.points j₃ = t₁.points i₃,	he : affine_span ℝ (set.range t₂.points) = affine_span ℝ (set.range t₁.points),	hu : univ.erase j₂ = {j₁, j₃}	⊢ t₁.points i₁ -ᵥ t₁.points i₂ ∈ ((affine_span ℝ {t₁.orthocenter, t₁.points i₃}).direction)ᗮ
V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t₁ t₂ : triangle ℝ P,	i₁ i₂ i₃ j₁ j₂ j₃ : fin 3,	hi₁₂ : i₁ ≠ i₂,	hi₁₃ : i₁ ≠ i₃,	hi₂₃ : i₂ ≠ i₃,	hj₁₂ : j₁ ≠ j₂,	hj₁₃ : j₁ ≠ j₃,	hj₂₃ : j₂ ≠ j₃,	h₁ : t₂.points j₁ = t₁.orthocenter,	h₂ : t₂.points j₂ = t₁.points i₂,	h₃ : t₂.points j₃ = t₁.points i₃,	he : affine_span ℝ (set.range t₂.points) = affine_span ℝ (set.range t₁.points),	hu : univ.erase j₂ = {j₁, j₃},	hle : ((altitude t₁ i₃).direction)ᗮ ≤ ((affine_span ℝ {t₁.orthocenter, t₁.points i₃}).direction)ᗮ	⊢ t₁.points i₁ -ᵥ t₁.points i₂ ∈ ((affine_span ℝ {t₁.orthocenter, t₁.points i₃}).direction)ᗮ
V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t₁ t₂ : triangle ℝ P,	i₁ i₂ i₃ j₁ j₂ j₃ : fin 3,	hi₁₂ : i₁ ≠ i₂,	hi₁₃ : i₁ ≠ i₃,	hi₂₃ : i₂ ≠ i₃,	hj₁₂ : j₁ ≠ j₂,	hj₁₃ : j₁ ≠ j₃,	hj₂₃ : j₂ ≠ j₃,	h₁ : t₂.points j₁ = t₁.orthocenter,	h₂ : t₂.points j₂ = t₁.points i₂,	h₃ : t₂.points j₃ = t₁.points i₃,	he : affine_span ℝ (set.range t₂.points) = affine_span ℝ (set.range t₁.points),	hu : univ.erase j₂ = {j₁, j₃},	hle : ((altitude t₁ i₃).direction)ᗮ ≤ ((affine_span ℝ {t₁.orthocenter, t₁.points i₃}).direction)ᗮ	⊢ t₁.points i₁ -ᵥ t₁.points i₂ ∈ vector_span ℝ (t₁.points '' ↑(univ.erase i₃))
2 goals	V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t₁ t₂ : triangle ℝ P,	i₁ i₂ i₃ j₁ j₂ j₃ : fin 3,	hi₁₂ : i₁ ≠ i₂,	hi₁₃ : i₁ ≠ i₃,	hi₂₃ : i₂ ≠ i₃,	hj₁₂ : j₁ ≠ j₂,	hj₁₃ : j₁ ≠ j₃,	hj₂₃ : j₂ ≠ j₃,	h₁ : t₂.points j₁ = t₁.orthocenter,	h₂ : t₂.points j₂ = t₁.points i₂,	h₃ : t₂.points j₃ = t₁.points i₃,	he : affine_span ℝ (set.range t₂.points) = affine_span ℝ (set.range t₁.points),	hu : univ.erase j₂ = {j₁, j₃},	hle : ((altitude t₁ i₃).direction)ᗮ ≤ ((affine_span ℝ {t₁.orthocenter, t₁.points i₃}).direction)ᗮ	⊢ univ.erase i₃ = {i₁, i₂}		V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t₁ t₂ : triangle ℝ P,	i₁ i₂ i₃ j₁ j₂ j₃ : fin 3,	hi₁₂ : i₁ ≠ i₂,	hi₁₃ : i₁ ≠ i₃,	hi₂₃ : i₂ ≠ i₃,	hj₁₂ : j₁ ≠ j₂,	hj₁₃ : j₁ ≠ j₃,	hj₂₃ : j₂ ≠ j₃,	h₁ : t₂.points j₁ = t₁.orthocenter,	h₂ : t₂.points j₂ = t₁.points i₂,	h₃ : t₂.points j₃ = t₁.points i₃,	he : affine_span ℝ (set.range t₂.points) = affine_span ℝ (set.range t₁.points),	hu : univ.erase j₂ = {j₁, j₃},	hle : ((altitude t₁ i₃).direction)ᗮ ≤ ((affine_span ℝ {t₁.orthocenter, t₁.points i₃}).direction)ᗮ,	hui : univ.erase i₃ = {i₁, i₂}	⊢ t₁.points i₁ -ᵥ t₁.points i₂ ∈ vector_span ℝ (t₁.points '' ↑(univ.erase i₃))
2 goals	V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t₁ t₂ : triangle ℝ P,	i₁ i₂ i₃ j₁ j₂ j₃ : fin 3,	hi₁₂ : i₁ ≠ i₂,	hi₁₃ : i₁ ≠ i₃,	hi₂₃ : i₂ ≠ i₃,	hj₁₂ : j₁ ≠ j₂,	hj₁₃ : j₁ ≠ j₃,	hj₂₃ : j₂ ≠ j₃,	h₁ : t₂.points j₁ = t₁.orthocenter,	he : affine_span ℝ (set.range t₂.points) = affine_span ℝ (set.range t₁.points),	hu : univ.erase j₂ = {j₁, j₃}	⊢ univ.erase i₃ = {i₁, i₂}		V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t₁ t₂ : triangle ℝ P,	i₁ i₂ i₃ j₁ j₂ j₃ : fin 3,	hi₁₂ : i₁ ≠ i₂,	hi₁₃ : i₁ ≠ i₃,	hi₂₃ : i₂ ≠ i₃,	hj₁₂ : j₁ ≠ j₂,	hj₁₃ : j₁ ≠ j₃,	hj₂₃ : j₂ ≠ j₃,	h₁ : t₂.points j₁ = t₁.orthocenter,	h₂ : t₂.points j₂ = t₁.points i₂,	h₃ : t₂.points j₃ = t₁.points i₃,	he : affine_span ℝ (set.range t₂.points) = affine_span ℝ (set.range t₁.points),	hu : univ.erase j₂ = {j₁, j₃},	hle : ((altitude t₁ i₃).direction)ᗮ ≤ ((affine_span ℝ {t₁.orthocenter, t₁.points i₃}).direction)ᗮ,	hui : univ.erase i₃ = {i₁, i₂}	⊢ t₁.points i₁ -ᵥ t₁.points i₂ ∈ vector_span ℝ (t₁.points '' ↑(univ.erase i₃))
V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t₁ t₂ : triangle ℝ P,	i₁ i₂ i₃ j₁ j₂ j₃ : fin 3,	hi₁₂ : i₁ ≠ i₂,	hi₁₃ : i₁ ≠ i₃,	hi₂₃ : i₂ ≠ i₃,	hj₁₂ : j₁ ≠ j₂,	hj₁₃ : j₁ ≠ j₃,	hj₂₃ : j₂ ≠ j₃,	h₁ : t₂.points j₁ = t₁.orthocenter,	h₂ : t₂.points j₂ = t₁.points i₂,	h₃ : t₂.points j₃ = t₁.points i₃,	he : affine_span ℝ (set.range t₂.points) = affine_span ℝ (set.range t₁.points),	hu : univ.erase j₂ = {j₁, j₃},	hle : ((altitude t₁ i₃).direction)ᗮ ≤ ((affine_span ℝ {t₁.orthocenter, t₁.points i₃}).direction)ᗮ,	hui : univ.erase i₃ = {i₁, i₂}	⊢ t₁.points i₁ -ᵥ t₁.points i₂ ∈ vector_span ℝ (t₁.points '' ↑(univ.erase i₃))
V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	t₁ t₂ : triangle ℝ P,	i₁ i₂ i₃ j₁ j₂ j₃ : fin 3,	hi₁₂ : i₁ ≠ i₂,	hi₁₃ : i₁ ≠ i₃,	hi₂₃ : i₂ ≠ i₃,	hj₁₂ : j₁ ≠ j₂,	hj₁₃ : j₁ ≠ j₃,	hj₂₃ : j₂ ≠ j₃,	h₁ : t₂.points j₁ = t₁.orthocenter,	h₂ : t₂.points j₂ = t₁.points i₂,	h₃ : t₂.points j₃ = t₁.points i₃,	he : affine_span ℝ (set.range t₂.points) = affine_span ℝ (set.range t₁.points),	hu : univ.erase j₂ = {j₁, j₃},	hle : ((altitude t₁ i₃).direction)ᗮ ≤ ((affine_span ℝ {t₁.orthocenter, t₁.points i₃}).direction)ᗮ,	hui : univ.erase i₃ = {i₁, i₂}	⊢ t₁.points i₁ -ᵥ t₁.points i₂ ∈ vector_span ℝ {t₁.points i₁, t₁.points i₂}
⊢ ∀ {E : Type uE} [_inst_1 : normed_group E] [_inst_2 : normed_space ℝ E] [_inst_3 : finite_dimensional ℝ E]	  {H : Type uH} [_inst_4 : topological_space H] {I : model_with_corners ℝ E H} {M : Type uM}	  [_inst_5 : topological_space M] [_inst_6 : charted_space H M] [_inst_7 : smooth_manifold_with_corners I M] {c : M}	  (f : smooth_bump_function I c) [_inst_8 : t2_space M] [_inst_9 : smooth_manifold_with_corners I M],	    smooth I (model_with_corners_self ℝ ℝ) ⇑f
E : Type uE,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	_inst_3 : finite_dimensional ℝ E,	H : Type uH,	_inst_4 : topological_space H,	I : model_with_corners ℝ E H,	M : Type uM,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	_inst_7 : smooth_manifold_with_corners I M,	c : M,	f : smooth_bump_function I c,	_inst_8 : t2_space M,	_inst_9 : smooth_manifold_with_corners I M	⊢ smooth I (model_with_corners_self ℝ ℝ) ⇑f
E : Type uE,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	_inst_3 : finite_dimensional ℝ E,	H : Type uH,	_inst_4 : topological_space H,	I : model_with_corners ℝ E H,	M : Type uM,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	_inst_7 : smooth_manifold_with_corners I M,	c : M,	f : smooth_bump_function I c,	_inst_8 : t2_space M,	_inst_9 : smooth_manifold_with_corners I M,	x : M,	hx : x ∈ closure (support ⇑f)	⊢ times_cont_mdiff_at I (model_with_corners_self ℝ ℝ) ⊤ ⇑f x
E : Type uE,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	_inst_3 : finite_dimensional ℝ E,	H : Type uH,	_inst_4 : topological_space H,	I : model_with_corners ℝ E H,	M : Type uM,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	_inst_7 : smooth_manifold_with_corners I M,	c : M,	f : smooth_bump_function I c,	_inst_8 : t2_space M,	_inst_9 : smooth_manifold_with_corners I M,	x : M,	hx : x ∈ closure (support ⇑f),	this : x ∈ (chart_at H c).to_local_equiv.source	⊢ times_cont_mdiff_at I (model_with_corners_self ℝ ℝ) ⊤ ⇑f x
E : Type uE,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	_inst_3 : finite_dimensional ℝ E,	H : Type uH,	_inst_4 : topological_space H,	I : model_with_corners ℝ E H,	M : Type uM,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	_inst_7 : smooth_manifold_with_corners I M,	c : M,	f : smooth_bump_function I c,	_inst_8 : t2_space M,	_inst_9 : smooth_manifold_with_corners I M,	x : M,	hx : x ∈ closure (support ⇑f),	this : x ∈ (chart_at H c).to_local_equiv.source	⊢ times_cont_mdiff_at I (model_with_corners_self ℝ ℝ) ⊤	    (⇑(f.to_times_cont_diff_bump) ∘ ⇑(ext_chart_at I c))	    x
⊢ ∀ (H : Type u) {M : Type u_2} [_inst_1 : topological_space H] [_inst_2 : topological_space M]	  [_inst_3 : charted_space H M] [_inst_4 : second_countable_topology H] [_inst_5 : sigma_compact_space M],	    second_countable_topology M
H : Type u,	M : Type u_2,	_inst_1 : topological_space H,	_inst_2 : topological_space M,	_inst_3 : charted_space H M,	_inst_4 : second_countable_topology H,	_inst_5 : sigma_compact_space M	⊢ second_countable_topology M
H : Type u,	M : Type u_2,	_inst_1 : topological_space H,	_inst_2 : topological_space M,	_inst_3 : charted_space H M,	_inst_4 : second_countable_topology H,	_inst_5 : sigma_compact_space M,	s : set M,	hsc : s.countable,	hsU : (⋃ (x : M) (hx : x ∈ s), (chart_at H x).to_local_equiv.source) = univ	⊢ second_countable_topology M
⊢ ∀ {H : Type u} {M : Type u_2} [_inst_1 : topological_space H] (c : charted_space_core H M) {e : local_equiv M H},	    e ∈ c.atlas → is_open e.target
H : Type u,	M : Type u_2,	_inst_1 : topological_space H,	c : charted_space_core H M,	e : local_equiv M H,	he : e ∈ c.atlas	⊢ is_open e.target
H : Type u,	M : Type u_2,	_inst_1 : topological_space H,	c : charted_space_core H M,	e : local_equiv M H,	he : e ∈ c.atlas,	E : e.target ∩ ⇑(e.symm) ⁻¹' e.source = e.target	⊢ is_open e.target
⊢ ∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field 𝕜] {E : Type u_2} [_inst_2 : normed_group E]	  [_inst_3 : normed_space 𝕜 E] {F : Type u_4} [_inst_6 : normed_group F] [_inst_7 : normed_space 𝕜 F]	  {H : Type u_5} [_inst_8 : topological_space H] {G : Type u_7} [_inst_10 : topological_space G]	  {I : model_with_corners 𝕜 E H} {J : model_with_corners 𝕜 F G} {M : Type u_8} [_inst_11 : topological_space M]	  [_inst_12 : charted_space H M] {N : Type u_10} [_inst_15 : topological_space N] [_inst_16 : charted_space G N]	  {n : with_top ℕ} {α : Sort u_3} (h : diffeomorph I J M N n) (f : α → M),	    range (⇑h ∘ f) = ⇑(h.symm) ⁻¹' range f
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_4,	_inst_6 : normed_group F,	_inst_7 : normed_space 𝕜 F,	H : Type u_5,	_inst_8 : topological_space H,	G : Type u_7,	_inst_10 : topological_space G,	I : model_with_corners 𝕜 E H,	J : model_with_corners 𝕜 F G,	M : Type u_8,	_inst_11 : topological_space M,	_inst_12 : charted_space H M,	N : Type u_10,	_inst_15 : topological_space N,	_inst_16 : charted_space G N,	n : with_top ℕ,	α : Sort u_3,	h : diffeomorph I J M N n,	f : α → M	⊢ range (⇑h ∘ f) = ⇑(h.symm) ⁻¹' range f
⊢ ∀ (n : ℕ),	    range (λ (x : euclidean_quadrant n), x.val) = {y : euclidean_space ℝ (fin n) | ∀ (i : fin n), 0 ≤ y i}
n : ℕ	⊢ range (λ (x : euclidean_quadrant n), x.val) = {y : euclidean_space ℝ (fin n) | ∀ (i : fin n), 0 ≤ y i}
⊢ ∀ {H : Type u_1} {M : Type u_2} [_inst_1 : topological_space H] [_inst_2 : topological_space M]	  [_inst_3 : charted_space H M] {H' : Type u_3} {M' : Type u_4} [_inst_4 : topological_space H']	  [_inst_5 : topological_space M'] [_inst_6 : charted_space H' M'] {G : structure_groupoid H}	  {G' : structure_groupoid H'} {P : (H → H') → set H → H → Prop} {g g' : M → M'} {s : set M} {x : M},	    G.local_invariant_prop G' P →	    lift_prop_within_at P g s x →	    (∀ (y : M), y ∈ s → g' y = g y) → g' x = g x → lift_prop_within_at P g' s x
H : Type u_1,	M : Type u_2,	_inst_1 : topological_space H,	_inst_2 : topological_space M,	_inst_3 : charted_space H M,	H' : Type u_3,	M' : Type u_4,	_inst_4 : topological_space H',	_inst_5 : topological_space M',	_inst_6 : charted_space H' M',	G : structure_groupoid H,	G' : structure_groupoid H',	P : (H → H') → set H → H → Prop,	g g' : M → M',	s : set M,	x : M,	hG : G.local_invariant_prop G' P,	h : lift_prop_within_at P g s x,	h₁ : ∀ (y : M), y ∈ s → g' y = g y,	hx : g' x = g x	⊢ lift_prop_within_at P g' s x
H : Type u_1,	M : Type u_2,	_inst_1 : topological_space H,	_inst_2 : topological_space M,	_inst_3 : charted_space H M,	H' : Type u_3,	M' : Type u_4,	_inst_4 : topological_space H',	_inst_5 : topological_space M',	_inst_6 : charted_space H' M',	G : structure_groupoid H,	G' : structure_groupoid H',	P : (H → H') → set H → H → Prop,	g g' : M → M',	s : set M,	x : M,	hG : G.local_invariant_prop G' P,	h : lift_prop_within_at P g s x,	h₁ : ∀ (y : M), y ∈ s → g' y = g y,	hx : g' x = g x	⊢ P (⇑(chart_at H' (g' x)) ∘ g' ∘ ⇑((chart_at H x).symm))	    ((chart_at H x).to_local_equiv.target ∩	       ⇑((chart_at H x).symm) ⁻¹' (s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source))	    (⇑(chart_at H x) x)
2 goals	H : Type u_1,	M : Type u_2,	_inst_1 : topological_space H,	_inst_2 : topological_space M,	_inst_3 : charted_space H M,	H' : Type u_3,	M' : Type u_4,	_inst_4 : topological_space H',	_inst_5 : topological_space M',	_inst_6 : charted_space H' M',	G : structure_groupoid H,	G' : structure_groupoid H',	P : (H → H') → set H → H → Prop,	g g' : M → M',	s : set M,	x : M,	hG : G.local_invariant_prop G' P,	h : lift_prop_within_at P g s x,	h₁ : ∀ (y : M), y ∈ s → g' y = g y,	hx : g' x = g x	⊢ s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source =	    s ∩ g ⁻¹' (chart_at H' (g' x)).to_local_equiv.source		H : Type u_1,	M : Type u_2,	_inst_1 : topological_space H,	_inst_2 : topological_space M,	_inst_3 : charted_space H M,	H' : Type u_3,	M' : Type u_4,	_inst_4 : topological_space H',	_inst_5 : topological_space M',	_inst_6 : charted_space H' M',	G : structure_groupoid H,	G' : structure_groupoid H',	P : (H → H') → set H → H → Prop,	g g' : M → M',	s : set M,	x : M,	hG : G.local_invariant_prop G' P,	h : lift_prop_within_at P g s x,	h₁ : ∀ (y : M), y ∈ s → g' y = g y,	hx : g' x = g x,	A :	  s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source = s ∩ g ⁻¹' (chart_at H' (g' x)).to_local_equiv.source	⊢ P (⇑(chart_at H' (g' x)) ∘ g' ∘ ⇑((chart_at H x).symm))	    ((chart_at H x).to_local_equiv.target ∩	       ⇑((chart_at H x).symm) ⁻¹' (s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source))	    (⇑(chart_at H x) x)
2 goals	H : Type u_1,	M : Type u_2,	_inst_1 : topological_space H,	_inst_2 : topological_space M,	_inst_3 : charted_space H M,	H' : Type u_3,	M' : Type u_4,	_inst_4 : topological_space H',	_inst_5 : topological_space M',	_inst_6 : charted_space H' M',	G : structure_groupoid H,	G' : structure_groupoid H',	P : (H → H') → set H → H → Prop,	g g' : M → M',	s : set M,	x : M,	hG : G.local_invariant_prop G' P,	h : lift_prop_within_at P g s x,	h₁ : ∀ (y : M), y ∈ s → g' y = g y,	hx : g' x = g x,	y : M	⊢ y ∈ s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source ↔	    y ∈ s ∩ g ⁻¹' (chart_at H' (g' x)).to_local_equiv.source		H : Type u_1,	M : Type u_2,	_inst_1 : topological_space H,	_inst_2 : topological_space M,	_inst_3 : charted_space H M,	H' : Type u_3,	M' : Type u_4,	_inst_4 : topological_space H',	_inst_5 : topological_space M',	_inst_6 : charted_space H' M',	G : structure_groupoid H,	G' : structure_groupoid H',	P : (H → H') → set H → H → Prop,	g g' : M → M',	s : set M,	x : M,	hG : G.local_invariant_prop G' P,	h : lift_prop_within_at P g s x,	h₁ : ∀ (y : M), y ∈ s → g' y = g y,	hx : g' x = g x,	A :	  s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source = s ∩ g ⁻¹' (chart_at H' (g' x)).to_local_equiv.source	⊢ P (⇑(chart_at H' (g' x)) ∘ g' ∘ ⇑((chart_at H x).symm))	    ((chart_at H x).to_local_equiv.target ∩	       ⇑((chart_at H x).symm) ⁻¹' (s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source))	    (⇑(chart_at H x) x)
3 goals	H : Type u_1,	M : Type u_2,	_inst_1 : topological_space H,	_inst_2 : topological_space M,	_inst_3 : charted_space H M,	H' : Type u_3,	M' : Type u_4,	_inst_4 : topological_space H',	_inst_5 : topological_space M',	_inst_6 : charted_space H' M',	G : structure_groupoid H,	G' : structure_groupoid H',	P : (H → H') → set H → H → Prop,	g g' : M → M',	s : set M,	x : M,	hG : G.local_invariant_prop G' P,	h : lift_prop_within_at P g s x,	h₁ : ∀ (y : M), y ∈ s → g' y = g y,	hx : g' x = g x,	y : M	⊢ y ∈ s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source →	  y ∈ s ∩ g ⁻¹' (chart_at H' (g' x)).to_local_equiv.source		H : Type u_1,	M : Type u_2,	_inst_1 : topological_space H,	_inst_2 : topological_space M,	_inst_3 : charted_space H M,	H' : Type u_3,	M' : Type u_4,	_inst_4 : topological_space H',	_inst_5 : topological_space M',	_inst_6 : charted_space H' M',	G : structure_groupoid H,	G' : structure_groupoid H',	P : (H → H') → set H → H → Prop,	g g' : M → M',	s : set M,	x : M,	hG : G.local_invariant_prop G' P,	h : lift_prop_within_at P g s x,	h₁ : ∀ (y : M), y ∈ s → g' y = g y,	hx : g' x = g x,	y : M	⊢ y ∈ s ∩ g ⁻¹' (chart_at H' (g' x)).to_local_equiv.source →	  y ∈ s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source		H : Type u_1,	M : Type u_2,	_inst_1 : topological_space H,	_inst_2 : topological_space M,	_inst_3 : charted_space H M,	H' : Type u_3,	M' : Type u_4,	_inst_4 : topological_space H',	_inst_5 : topological_space M',	_inst_6 : charted_space H' M',	G : structure_groupoid H,	G' : structure_groupoid H',	P : (H → H') → set H → H → Prop,	g g' : M → M',	s : set M,	x : M,	hG : G.local_invariant_prop G' P,	h : lift_prop_within_at P g s x,	h₁ : ∀ (y : M), y ∈ s → g' y = g y,	hx : g' x = g x,	A :	  s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source = s ∩ g ⁻¹' (chart_at H' (g' x)).to_local_equiv.source	⊢ P (⇑(chart_at H' (g' x)) ∘ g' ∘ ⇑((chart_at H x).symm))	    ((chart_at H x).to_local_equiv.target ∩	       ⇑((chart_at H x).symm) ⁻¹' (s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source))	    (⇑(chart_at H x) x)
3 goals	H : Type u_1,	M : Type u_2,	_inst_1 : topological_space H,	_inst_2 : topological_space M,	_inst_3 : charted_space H M,	H' : Type u_3,	M' : Type u_4,	_inst_4 : topological_space H',	_inst_5 : topological_space M',	_inst_6 : charted_space H' M',	G : structure_groupoid H,	G' : structure_groupoid H',	P : (H → H') → set H → H → Prop,	g g' : M → M',	s : set M,	x : M,	hG : G.local_invariant_prop G' P,	h : lift_prop_within_at P g s x,	h₁ : ∀ (y : M), y ∈ s → g' y = g y,	hx : g' x = g x,	y : M,	hy : y ∈ s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source	⊢ y ∈ s ∩ g ⁻¹' (chart_at H' (g' x)).to_local_equiv.source		H : Type u_1,	M : Type u_2,	_inst_1 : topological_space H,	_inst_2 : topological_space M,	_inst_3 : charted_space H M,	H' : Type u_3,	M' : Type u_4,	_inst_4 : topological_space H',	_inst_5 : topological_space M',	_inst_6 : charted_space H' M',	G : structure_groupoid H,	G' : structure_groupoid H',	P : (H → H') → set H → H → Prop,	g g' : M → M',	s : set M,	x : M,	hG : G.local_invariant_prop G' P,	h : lift_prop_within_at P g s x,	h₁ : ∀ (y : M), y ∈ s → g' y = g y,	hx : g' x = g x,	y : M	⊢ y ∈ s ∩ g ⁻¹' (chart_at H' (g' x)).to_local_equiv.source →	  y ∈ s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source		H : Type u_1,	M : Type u_2,	_inst_1 : topological_space H,	_inst_2 : topological_space M,	_inst_3 : charted_space H M,	H' : Type u_3,	M' : Type u_4,	_inst_4 : topological_space H',	_inst_5 : topological_space M',	_inst_6 : charted_space H' M',	G : structure_groupoid H,	G' : structure_groupoid H',	P : (H → H') → set H → H → Prop,	g g' : M → M',	s : set M,	x : M,	hG : G.local_invariant_prop G' P,	h : lift_prop_within_at P g s x,	h₁ : ∀ (y : M), y ∈ s → g' y = g y,	hx : g' x = g x,	A :	  s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source = s ∩ g ⁻¹' (chart_at H' (g' x)).to_local_equiv.source	⊢ P (⇑(chart_at H' (g' x)) ∘ g' ∘ ⇑((chart_at H x).symm))	    ((chart_at H x).to_local_equiv.target ∩	       ⇑((chart_at H x).symm) ⁻¹' (s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source))	    (⇑(chart_at H x) x)
3 goals	H : Type u_1,	M : Type u_2,	_inst_1 : topological_space H,	_inst_2 : topological_space M,	_inst_3 : charted_space H M,	H' : Type u_3,	M' : Type u_4,	_inst_4 : topological_space H',	_inst_5 : topological_space M',	_inst_6 : charted_space H' M',	G : structure_groupoid H,	G' : structure_groupoid H',	P : (H → H') → set H → H → Prop,	g g' : M → M',	s : set M,	x : M,	hG : G.local_invariant_prop G' P,	h : lift_prop_within_at P g s x,	h₁ : ∀ (y : M), y ∈ s → g' y = g y,	hx : g' x = g x,	y : M,	hy : y ∈ s ∧ g' y ∈ (chart_at H' (g' x)).to_local_equiv.source	⊢ y ∈ s ∩ g ⁻¹' (chart_at H' (g' x)).to_local_equiv.source		H : Type u_1,	M : Type u_2,	_inst_1 : topological_space H,	_inst_2 : topological_space M,	_inst_3 : charted_space H M,	H' : Type u_3,	M' : Type u_4,	_inst_4 : topological_space H',	_inst_5 : topological_space M',	_inst_6 : charted_space H' M',	G : structure_groupoid H,	G' : structure_groupoid H',	P : (H → H') → set H → H → Prop,	g g' : M → M',	s : set M,	x : M,	hG : G.local_invariant_prop G' P,	h : lift_prop_within_at P g s x,	h₁ : ∀ (y : M), y ∈ s → g' y = g y,	hx : g' x = g x,	y : M	⊢ y ∈ s ∩ g ⁻¹' (chart_at H' (g' x)).to_local_equiv.source →	  y ∈ s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source		H : Type u_1,	M : Type u_2,	_inst_1 : topological_space H,	_inst_2 : topological_space M,	_inst_3 : charted_space H M,	H' : Type u_3,	M' : Type u_4,	_inst_4 : topological_space H',	_inst_5 : topological_space M',	_inst_6 : charted_space H' M',	G : structure_groupoid H,	G' : structure_groupoid H',	P : (H → H') → set H → H → Prop,	g g' : M → M',	s : set M,	x : M,	hG : G.local_invariant_prop G' P,	h : lift_prop_within_at P g s x,	h₁ : ∀ (y : M), y ∈ s → g' y = g y,	hx : g' x = g x,	A :	  s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source = s ∩ g ⁻¹' (chart_at H' (g' x)).to_local_equiv.source	⊢ P (⇑(chart_at H' (g' x)) ∘ g' ∘ ⇑((chart_at H x).symm))	    ((chart_at H x).to_local_equiv.target ∩	       ⇑((chart_at H x).symm) ⁻¹' (s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source))	    (⇑(chart_at H x) x)
2 goals	H : Type u_1,	M : Type u_2,	_inst_1 : topological_space H,	_inst_2 : topological_space M,	_inst_3 : charted_space H M,	H' : Type u_3,	M' : Type u_4,	_inst_4 : topological_space H',	_inst_5 : topological_space M',	_inst_6 : charted_space H' M',	G : structure_groupoid H,	G' : structure_groupoid H',	P : (H → H') → set H → H → Prop,	g g' : M → M',	s : set M,	x : M,	hG : G.local_invariant_prop G' P,	h : lift_prop_within_at P g s x,	h₁ : ∀ (y : M), y ∈ s → g' y = g y,	hx : g' x = g x,	y : M	⊢ y ∈ s ∩ g ⁻¹' (chart_at H' (g' x)).to_local_equiv.source →	  y ∈ s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source		H : Type u_1,	M : Type u_2,	_inst_1 : topological_space H,	_inst_2 : topological_space M,	_inst_3 : charted_space H M,	H' : Type u_3,	M' : Type u_4,	_inst_4 : topological_space H',	_inst_5 : topological_space M',	_inst_6 : charted_space H' M',	G : structure_groupoid H,	G' : structure_groupoid H',	P : (H → H') → set H → H → Prop,	g g' : M → M',	s : set M,	x : M,	hG : G.local_invariant_prop G' P,	h : lift_prop_within_at P g s x,	h₁ : ∀ (y : M), y ∈ s → g' y = g y,	hx : g' x = g x,	A :	  s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source = s ∩ g ⁻¹' (chart_at H' (g' x)).to_local_equiv.source	⊢ P (⇑(chart_at H' (g' x)) ∘ g' ∘ ⇑((chart_at H x).symm))	    ((chart_at H x).to_local_equiv.target ∩	       ⇑((chart_at H x).symm) ⁻¹' (s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source))	    (⇑(chart_at H x) x)
2 goals	H : Type u_1,	M : Type u_2,	_inst_1 : topological_space H,	_inst_2 : topological_space M,	_inst_3 : charted_space H M,	H' : Type u_3,	M' : Type u_4,	_inst_4 : topological_space H',	_inst_5 : topological_space M',	_inst_6 : charted_space H' M',	G : structure_groupoid H,	G' : structure_groupoid H',	P : (H → H') → set H → H → Prop,	g g' : M → M',	s : set M,	x : M,	hG : G.local_invariant_prop G' P,	h : lift_prop_within_at P g s x,	h₁ : ∀ (y : M), y ∈ s → g' y = g y,	hx : g' x = g x,	y : M,	hy : y ∈ s ∩ g ⁻¹' (chart_at H' (g' x)).to_local_equiv.source	⊢ y ∈ s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source		H : Type u_1,	M : Type u_2,	_inst_1 : topological_space H,	_inst_2 : topological_space M,	_inst_3 : charted_space H M,	H' : Type u_3,	M' : Type u_4,	_inst_4 : topological_space H',	_inst_5 : topological_space M',	_inst_6 : charted_space H' M',	G : structure_groupoid H,	G' : structure_groupoid H',	P : (H → H') → set H → H → Prop,	g g' : M → M',	s : set M,	x : M,	hG : G.local_invariant_prop G' P,	h : lift_prop_within_at P g s x,	h₁ : ∀ (y : M), y ∈ s → g' y = g y,	hx : g' x = g x,	A :	  s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source = s ∩ g ⁻¹' (chart_at H' (g' x)).to_local_equiv.source	⊢ P (⇑(chart_at H' (g' x)) ∘ g' ∘ ⇑((chart_at H x).symm))	    ((chart_at H x).to_local_equiv.target ∩	       ⇑((chart_at H x).symm) ⁻¹' (s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source))	    (⇑(chart_at H x) x)
2 goals	H : Type u_1,	M : Type u_2,	_inst_1 : topological_space H,	_inst_2 : topological_space M,	_inst_3 : charted_space H M,	H' : Type u_3,	M' : Type u_4,	_inst_4 : topological_space H',	_inst_5 : topological_space M',	_inst_6 : charted_space H' M',	G : structure_groupoid H,	G' : structure_groupoid H',	P : (H → H') → set H → H → Prop,	g g' : M → M',	s : set M,	x : M,	hG : G.local_invariant_prop G' P,	h : lift_prop_within_at P g s x,	h₁ : ∀ (y : M), y ∈ s → g' y = g y,	hx : g' x = g x,	y : M,	hy : y ∈ s ∧ g y ∈ (chart_at H' (g' x)).to_local_equiv.source	⊢ y ∈ s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source		H : Type u_1,	M : Type u_2,	_inst_1 : topological_space H,	_inst_2 : topological_space M,	_inst_3 : charted_space H M,	H' : Type u_3,	M' : Type u_4,	_inst_4 : topological_space H',	_inst_5 : topological_space M',	_inst_6 : charted_space H' M',	G : structure_groupoid H,	G' : structure_groupoid H',	P : (H → H') → set H → H → Prop,	g g' : M → M',	s : set M,	x : M,	hG : G.local_invariant_prop G' P,	h : lift_prop_within_at P g s x,	h₁ : ∀ (y : M), y ∈ s → g' y = g y,	hx : g' x = g x,	A :	  s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source = s ∩ g ⁻¹' (chart_at H' (g' x)).to_local_equiv.source	⊢ P (⇑(chart_at H' (g' x)) ∘ g' ∘ ⇑((chart_at H x).symm))	    ((chart_at H x).to_local_equiv.target ∩	       ⇑((chart_at H x).symm) ⁻¹' (s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source))	    (⇑(chart_at H x) x)
H : Type u_1,	M : Type u_2,	_inst_1 : topological_space H,	_inst_2 : topological_space M,	_inst_3 : charted_space H M,	H' : Type u_3,	M' : Type u_4,	_inst_4 : topological_space H',	_inst_5 : topological_space M',	_inst_6 : charted_space H' M',	G : structure_groupoid H,	G' : structure_groupoid H',	P : (H → H') → set H → H → Prop,	g g' : M → M',	s : set M,	x : M,	hG : G.local_invariant_prop G' P,	h : lift_prop_within_at P g s x,	h₁ : ∀ (y : M), y ∈ s → g' y = g y,	hx : g' x = g x,	A :	  s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source = s ∩ g ⁻¹' (chart_at H' (g' x)).to_local_equiv.source	⊢ P (⇑(chart_at H' (g' x)) ∘ g' ∘ ⇑((chart_at H x).symm))	    ((chart_at H x).to_local_equiv.target ∩	       ⇑((chart_at H x).symm) ⁻¹' (s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source))	    (⇑(chart_at H x) x)
H : Type u_1,	M : Type u_2,	_inst_1 : topological_space H,	_inst_2 : topological_space M,	_inst_3 : charted_space H M,	H' : Type u_3,	M' : Type u_4,	_inst_4 : topological_space H',	_inst_5 : topological_space M',	_inst_6 : charted_space H' M',	G : structure_groupoid H,	G' : structure_groupoid H',	P : (H → H') → set H → H → Prop,	g g' : M → M',	s : set M,	x : M,	hG : G.local_invariant_prop G' P,	h : lift_prop_within_at P g s x,	h₁ : ∀ (y : M), y ∈ s → g' y = g y,	hx : g' x = g x,	A :	  s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source =	    s ∩ g ⁻¹' (chart_at H' (g' x)).to_local_equiv.source,	this :	  P (⇑(chart_at H' (g x)) ∘ g ∘ ⇑((chart_at H x).symm))	    ((chart_at H x).to_local_equiv.target ∩	       ⇑((chart_at H x).symm) ⁻¹' (s ∩ g ⁻¹' (chart_at H' (g x)).to_local_equiv.source))	    (⇑(chart_at H x) x)	⊢ P (⇑(chart_at H' (g' x)) ∘ g' ∘ ⇑((chart_at H x).symm))	    ((chart_at H x).to_local_equiv.target ∩	       ⇑((chart_at H x).symm) ⁻¹' (s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source))	    (⇑(chart_at H x) x)
H : Type u_1,	M : Type u_2,	_inst_1 : topological_space H,	_inst_2 : topological_space M,	_inst_3 : charted_space H M,	H' : Type u_3,	M' : Type u_4,	_inst_4 : topological_space H',	_inst_5 : topological_space M',	_inst_6 : charted_space H' M',	G : structure_groupoid H,	G' : structure_groupoid H',	P : (H → H') → set H → H → Prop,	g g' : M → M',	s : set M,	x : M,	hG : G.local_invariant_prop G' P,	h : lift_prop_within_at P g s x,	h₁ : ∀ (y : M), y ∈ s → g' y = g y,	hx : g' x = g x,	A :	  s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source =	    s ∩ g ⁻¹' (chart_at H' (g' x)).to_local_equiv.source,	this :	  P (⇑(chart_at H' (g' x)) ∘ g ∘ ⇑((chart_at H x).symm))	    ((chart_at H x).to_local_equiv.target ∩	       ⇑((chart_at H x).symm) ⁻¹' (s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source))	    (⇑(chart_at H x) x)	⊢ P (⇑(chart_at H' (g' x)) ∘ g' ∘ ⇑((chart_at H x).symm))	    ((chart_at H x).to_local_equiv.target ∩	       ⇑((chart_at H x).symm) ⁻¹' (s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source))	    (⇑(chart_at H x) x)
2 goals	H : Type u_1,	M : Type u_2,	_inst_1 : topological_space H,	_inst_2 : topological_space M,	_inst_3 : charted_space H M,	H' : Type u_3,	M' : Type u_4,	_inst_4 : topological_space H',	_inst_5 : topological_space M',	_inst_6 : charted_space H' M',	G : structure_groupoid H,	G' : structure_groupoid H',	P : (H → H') → set H → H → Prop,	g g' : M → M',	s : set M,	x : M,	hG : G.local_invariant_prop G' P,	h : lift_prop_within_at P g s x,	h₁ : ∀ (y : M), y ∈ s → g' y = g y,	hx : g' x = g x,	A :	  s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source =	    s ∩ g ⁻¹' (chart_at H' (g' x)).to_local_equiv.source,	this :	  P (⇑(chart_at H' (g' x)) ∘ g ∘ ⇑((chart_at H x).symm))	    ((chart_at H x).to_local_equiv.target ∩	       ⇑((chart_at H x).symm) ⁻¹' (s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source))	    (⇑(chart_at H x) x)	⊢ ∀ (y : H),	    y ∈	      (chart_at H x).to_local_equiv.target ∩	        ⇑((chart_at H x).symm) ⁻¹' (s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source) →	    (⇑(chart_at H' (g' x)) ∘ g ∘ ⇑((chart_at H x).symm)) y =	      (⇑(chart_at H' (g' x)) ∘ g' ∘ ⇑((chart_at H x).symm)) y		H : Type u_1,	M : Type u_2,	_inst_1 : topological_space H,	_inst_2 : topological_space M,	_inst_3 : charted_space H M,	H' : Type u_3,	M' : Type u_4,	_inst_4 : topological_space H',	_inst_5 : topological_space M',	_inst_6 : charted_space H' M',	G : structure_groupoid H,	G' : structure_groupoid H',	P : (H → H') → set H → H → Prop,	g g' : M → M',	s : set M,	x : M,	hG : G.local_invariant_prop G' P,	h : lift_prop_within_at P g s x,	h₁ : ∀ (y : M), y ∈ s → g' y = g y,	hx : g' x = g x,	A :	  s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source =	    s ∩ g ⁻¹' (chart_at H' (g' x)).to_local_equiv.source,	this :	  P (⇑(chart_at H' (g' x)) ∘ g ∘ ⇑((chart_at H x).symm))	    ((chart_at H x).to_local_equiv.target ∩	       ⇑((chart_at H x).symm) ⁻¹' (s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source))	    (⇑(chart_at H x) x)	⊢ (⇑(chart_at H' (g' x)) ∘ g ∘ ⇑((chart_at H x).symm)) (⇑(chart_at H x) x) =	    (⇑(chart_at H' (g' x)) ∘ g' ∘ ⇑((chart_at H x).symm)) (⇑(chart_at H x) x)
2 goals	H : Type u_1,	M : Type u_2,	_inst_1 : topological_space H,	_inst_2 : topological_space M,	_inst_3 : charted_space H M,	H' : Type u_3,	M' : Type u_4,	_inst_4 : topological_space H',	_inst_5 : topological_space M',	_inst_6 : charted_space H' M',	G : structure_groupoid H,	G' : structure_groupoid H',	P : (H → H') → set H → H → Prop,	g g' : M → M',	s : set M,	x : M,	hG : G.local_invariant_prop G' P,	h : lift_prop_within_at P g s x,	h₁ : ∀ (y : M), y ∈ s → g' y = g y,	hx : g' x = g x,	A :	  s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source =	    s ∩ g ⁻¹' (chart_at H' (g' x)).to_local_equiv.source,	this :	  P (⇑(chart_at H' (g' x)) ∘ g ∘ ⇑((chart_at H x).symm))	    ((chart_at H x).to_local_equiv.target ∩	       ⇑((chart_at H x).symm) ⁻¹' (s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source))	    (⇑(chart_at H x) x),	y : H,	hy :	  y ∈	    (chart_at H x).to_local_equiv.target ∩	      ⇑((chart_at H x).symm) ⁻¹' (s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source)	⊢ (⇑(chart_at H' (g' x)) ∘ g ∘ ⇑((chart_at H x).symm)) y =	    (⇑(chart_at H' (g' x)) ∘ g' ∘ ⇑((chart_at H x).symm)) y		H : Type u_1,	M : Type u_2,	_inst_1 : topological_space H,	_inst_2 : topological_space M,	_inst_3 : charted_space H M,	H' : Type u_3,	M' : Type u_4,	_inst_4 : topological_space H',	_inst_5 : topological_space M',	_inst_6 : charted_space H' M',	G : structure_groupoid H,	G' : structure_groupoid H',	P : (H → H') → set H → H → Prop,	g g' : M → M',	s : set M,	x : M,	hG : G.local_invariant_prop G' P,	h : lift_prop_within_at P g s x,	h₁ : ∀ (y : M), y ∈ s → g' y = g y,	hx : g' x = g x,	A :	  s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source =	    s ∩ g ⁻¹' (chart_at H' (g' x)).to_local_equiv.source,	this :	  P (⇑(chart_at H' (g' x)) ∘ g ∘ ⇑((chart_at H x).symm))	    ((chart_at H x).to_local_equiv.target ∩	       ⇑((chart_at H x).symm) ⁻¹' (s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source))	    (⇑(chart_at H x) x)	⊢ (⇑(chart_at H' (g' x)) ∘ g ∘ ⇑((chart_at H x).symm)) (⇑(chart_at H x) x) =	    (⇑(chart_at H' (g' x)) ∘ g' ∘ ⇑((chart_at H x).symm)) (⇑(chart_at H x) x)
2 goals	H : Type u_1,	M : Type u_2,	_inst_1 : topological_space H,	_inst_2 : topological_space M,	_inst_3 : charted_space H M,	H' : Type u_3,	M' : Type u_4,	_inst_4 : topological_space H',	_inst_5 : topological_space M',	_inst_6 : charted_space H' M',	G : structure_groupoid H,	G' : structure_groupoid H',	P : (H → H') → set H → H → Prop,	g g' : M → M',	s : set M,	x : M,	hG : G.local_invariant_prop G' P,	h : lift_prop_within_at P g s x,	h₁ : ∀ (y : M), y ∈ s → g' y = g y,	hx : g' x = g x,	A :	  s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source =	    s ∩ g ⁻¹' (chart_at H' (g' x)).to_local_equiv.source,	this :	  P (⇑(chart_at H' (g' x)) ∘ g ∘ ⇑((chart_at H x).symm))	    ((chart_at H x).to_local_equiv.target ∩	       ⇑((chart_at H x).symm) ⁻¹' (s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source))	    (⇑(chart_at H x) x),	y : H,	hy :	  y ∈ (chart_at H x).to_local_equiv.target ∧	    ⇑((chart_at H x).symm) y ∈ s ∧ g' (⇑((chart_at H x).symm) y) ∈ (chart_at H' (g' x)).to_local_equiv.source	⊢ (⇑(chart_at H' (g' x)) ∘ g ∘ ⇑((chart_at H x).symm)) y =	    (⇑(chart_at H' (g' x)) ∘ g' ∘ ⇑((chart_at H x).symm)) y		H : Type u_1,	M : Type u_2,	_inst_1 : topological_space H,	_inst_2 : topological_space M,	_inst_3 : charted_space H M,	H' : Type u_3,	M' : Type u_4,	_inst_4 : topological_space H',	_inst_5 : topological_space M',	_inst_6 : charted_space H' M',	G : structure_groupoid H,	G' : structure_groupoid H',	P : (H → H') → set H → H → Prop,	g g' : M → M',	s : set M,	x : M,	hG : G.local_invariant_prop G' P,	h : lift_prop_within_at P g s x,	h₁ : ∀ (y : M), y ∈ s → g' y = g y,	hx : g' x = g x,	A :	  s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source =	    s ∩ g ⁻¹' (chart_at H' (g' x)).to_local_equiv.source,	this :	  P (⇑(chart_at H' (g' x)) ∘ g ∘ ⇑((chart_at H x).symm))	    ((chart_at H x).to_local_equiv.target ∩	       ⇑((chart_at H x).symm) ⁻¹' (s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source))	    (⇑(chart_at H x) x)	⊢ (⇑(chart_at H' (g' x)) ∘ g ∘ ⇑((chart_at H x).symm)) (⇑(chart_at H x) x) =	    (⇑(chart_at H' (g' x)) ∘ g' ∘ ⇑((chart_at H x).symm)) (⇑(chart_at H x) x)
3 goals	H : Type u_1,	M : Type u_2,	_inst_1 : topological_space H,	_inst_2 : topological_space M,	_inst_3 : charted_space H M,	H' : Type u_3,	M' : Type u_4,	_inst_4 : topological_space H',	_inst_5 : topological_space M',	_inst_6 : charted_space H' M',	G : structure_groupoid H,	G' : structure_groupoid H',	P : (H → H') → set H → H → Prop,	g g' : M → M',	s : set M,	x : M,	hG : G.local_invariant_prop G' P,	h : lift_prop_within_at P g s x,	h₁ : ∀ (y : M), y ∈ s → g' y = g y,	hx : g' x = g x,	A :	  s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source =	    s ∩ g ⁻¹' (chart_at H' (g' x)).to_local_equiv.source,	this :	  P (⇑(chart_at H' (g' x)) ∘ g ∘ ⇑((chart_at H x).symm))	    ((chart_at H x).to_local_equiv.target ∩	       ⇑((chart_at H x).symm) ⁻¹' (s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source))	    (⇑(chart_at H x) x),	y : H,	hy :	  y ∈ (chart_at H x).to_local_equiv.target ∧	    ⇑((chart_at H x).symm) y ∈ s ∧ g' (⇑((chart_at H x).symm) y) ∈ (chart_at H' (g' x)).to_local_equiv.source	⊢ ⇑((chart_at H x).symm) y ∈ s		H : Type u_1,	M : Type u_2,	_inst_1 : topological_space H,	_inst_2 : topological_space M,	_inst_3 : charted_space H M,	H' : Type u_3,	M' : Type u_4,	_inst_4 : topological_space H',	_inst_5 : topological_space M',	_inst_6 : charted_space H' M',	G : structure_groupoid H,	G' : structure_groupoid H',	P : (H → H') → set H → H → Prop,	g g' : M → M',	s : set M,	x : M,	hG : G.local_invariant_prop G' P,	h : lift_prop_within_at P g s x,	h₁ : ∀ (y : M), y ∈ s → g' y = g y,	hx : g' x = g x,	A :	  s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source =	    s ∩ g ⁻¹' (chart_at H' (g' x)).to_local_equiv.source,	this :	  P (⇑(chart_at H' (g' x)) ∘ g ∘ ⇑((chart_at H x).symm))	    ((chart_at H x).to_local_equiv.target ∩	       ⇑((chart_at H x).symm) ⁻¹' (s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source))	    (⇑(chart_at H x) x),	y : H,	hy :	  y ∈ (chart_at H x).to_local_equiv.target ∧	    ⇑((chart_at H x).symm) y ∈ s ∧ g' (⇑((chart_at H x).symm) y) ∈ (chart_at H' (g' x)).to_local_equiv.source,	this : ⇑((chart_at H x).symm) y ∈ s	⊢ (⇑(chart_at H' (g' x)) ∘ g ∘ ⇑((chart_at H x).symm)) y =	    (⇑(chart_at H' (g' x)) ∘ g' ∘ ⇑((chart_at H x).symm)) y		H : Type u_1,	M : Type u_2,	_inst_1 : topological_space H,	_inst_2 : topological_space M,	_inst_3 : charted_space H M,	H' : Type u_3,	M' : Type u_4,	_inst_4 : topological_space H',	_inst_5 : topological_space M',	_inst_6 : charted_space H' M',	G : structure_groupoid H,	G' : structure_groupoid H',	P : (H → H') → set H → H → Prop,	g g' : M → M',	s : set M,	x : M,	hG : G.local_invariant_prop G' P,	h : lift_prop_within_at P g s x,	h₁ : ∀ (y : M), y ∈ s → g' y = g y,	hx : g' x = g x,	A :	  s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source =	    s ∩ g ⁻¹' (chart_at H' (g' x)).to_local_equiv.source,	this :	  P (⇑(chart_at H' (g' x)) ∘ g ∘ ⇑((chart_at H x).symm))	    ((chart_at H x).to_local_equiv.target ∩	       ⇑((chart_at H x).symm) ⁻¹' (s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source))	    (⇑(chart_at H x) x)	⊢ (⇑(chart_at H' (g' x)) ∘ g ∘ ⇑((chart_at H x).symm)) (⇑(chart_at H x) x) =	    (⇑(chart_at H' (g' x)) ∘ g' ∘ ⇑((chart_at H x).symm)) (⇑(chart_at H x) x)
2 goals	H : Type u_1,	M : Type u_2,	_inst_1 : topological_space H,	_inst_2 : topological_space M,	_inst_3 : charted_space H M,	H' : Type u_3,	M' : Type u_4,	_inst_4 : topological_space H',	_inst_5 : topological_space M',	_inst_6 : charted_space H' M',	G : structure_groupoid H,	G' : structure_groupoid H',	P : (H → H') → set H → H → Prop,	g g' : M → M',	s : set M,	x : M,	hG : G.local_invariant_prop G' P,	h : lift_prop_within_at P g s x,	h₁ : ∀ (y : M), y ∈ s → g' y = g y,	hx : g' x = g x,	A :	  s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source =	    s ∩ g ⁻¹' (chart_at H' (g' x)).to_local_equiv.source,	this :	  P (⇑(chart_at H' (g' x)) ∘ g ∘ ⇑((chart_at H x).symm))	    ((chart_at H x).to_local_equiv.target ∩	       ⇑((chart_at H x).symm) ⁻¹' (s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source))	    (⇑(chart_at H x) x),	y : H,	hy :	  y ∈ (chart_at H x).to_local_equiv.target ∧	    ⇑((chart_at H x).symm) y ∈ s ∧ g' (⇑((chart_at H x).symm) y) ∈ (chart_at H' (g' x)).to_local_equiv.source,	this : ⇑((chart_at H x).symm) y ∈ s	⊢ (⇑(chart_at H' (g' x)) ∘ g ∘ ⇑((chart_at H x).symm)) y =	    (⇑(chart_at H' (g' x)) ∘ g' ∘ ⇑((chart_at H x).symm)) y		H : Type u_1,	M : Type u_2,	_inst_1 : topological_space H,	_inst_2 : topological_space M,	_inst_3 : charted_space H M,	H' : Type u_3,	M' : Type u_4,	_inst_4 : topological_space H',	_inst_5 : topological_space M',	_inst_6 : charted_space H' M',	G : structure_groupoid H,	G' : structure_groupoid H',	P : (H → H') → set H → H → Prop,	g g' : M → M',	s : set M,	x : M,	hG : G.local_invariant_prop G' P,	h : lift_prop_within_at P g s x,	h₁ : ∀ (y : M), y ∈ s → g' y = g y,	hx : g' x = g x,	A :	  s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source =	    s ∩ g ⁻¹' (chart_at H' (g' x)).to_local_equiv.source,	this :	  P (⇑(chart_at H' (g' x)) ∘ g ∘ ⇑((chart_at H x).symm))	    ((chart_at H x).to_local_equiv.target ∩	       ⇑((chart_at H x).symm) ⁻¹' (s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source))	    (⇑(chart_at H x) x)	⊢ (⇑(chart_at H' (g' x)) ∘ g ∘ ⇑((chart_at H x).symm)) (⇑(chart_at H x) x) =	    (⇑(chart_at H' (g' x)) ∘ g' ∘ ⇑((chart_at H x).symm)) (⇑(chart_at H x) x)
H : Type u_1,	M : Type u_2,	_inst_1 : topological_space H,	_inst_2 : topological_space M,	_inst_3 : charted_space H M,	H' : Type u_3,	M' : Type u_4,	_inst_4 : topological_space H',	_inst_5 : topological_space M',	_inst_6 : charted_space H' M',	G : structure_groupoid H,	G' : structure_groupoid H',	P : (H → H') → set H → H → Prop,	g g' : M → M',	s : set M,	x : M,	hG : G.local_invariant_prop G' P,	h : lift_prop_within_at P g s x,	h₁ : ∀ (y : M), y ∈ s → g' y = g y,	hx : g' x = g x,	A :	  s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source =	    s ∩ g ⁻¹' (chart_at H' (g' x)).to_local_equiv.source,	this :	  P (⇑(chart_at H' (g' x)) ∘ g ∘ ⇑((chart_at H x).symm))	    ((chart_at H x).to_local_equiv.target ∩	       ⇑((chart_at H x).symm) ⁻¹' (s ∩ g' ⁻¹' (chart_at H' (g' x)).to_local_equiv.source))	    (⇑(chart_at H x) x)	⊢ (⇑(chart_at H' (g' x)) ∘ g ∘ ⇑((chart_at H x).symm)) (⇑(chart_at H x) x) =	    (⇑(chart_at H' (g' x)) ∘ g' ∘ ⇑((chart_at H x).symm)) (⇑(chart_at H x) x)
⊢ ∀ {H : Type u_1} [_inst_1 : topological_space H] (G : structure_groupoid H)	  [_inst_7 : closed_under_restriction G], G.local_invariant_prop G G.is_local_structomorph_within_at
H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ G.local_invariant_prop G G.is_local_structomorph_within_at
4 goals	H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {u : set H} {f : H → H},	    is_open u →	    x ∈ u → (G.is_local_structomorph_within_at f s x ↔ G.is_local_structomorph_within_at f (s ∩ u) x)		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f : H → H} {e : local_homeomorph H H},	    e ∈ G →	    x ∈ e.to_local_equiv.source →	    G.is_local_structomorph_within_at f s x →	    G.is_local_structomorph_within_at (f ∘ ⇑(e.symm)) (e.to_local_equiv.target ∩ ⇑(e.symm) ⁻¹' s) (⇑e x)		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f g : H → H},	    (∀ (y : H), y ∈ s → f y = g y) →	    f x = g x → G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at g s x		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f : H → H} {e' : local_homeomorph H H},	    e' ∈ G →	    s ⊆ f ⁻¹' e'.to_local_equiv.source →	    f x ∈ e'.to_local_equiv.source →	    G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at (⇑e' ∘ f) s x
4 goals	H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G,	s : set H,	x : H,	u : set H,	f : H → H,	hu : is_open u,	hux : x ∈ u	⊢ G.is_local_structomorph_within_at f s x ↔ G.is_local_structomorph_within_at f (s ∩ u) x		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f : H → H} {e : local_homeomorph H H},	    e ∈ G →	    x ∈ e.to_local_equiv.source →	    G.is_local_structomorph_within_at f s x →	    G.is_local_structomorph_within_at (f ∘ ⇑(e.symm)) (e.to_local_equiv.target ∩ ⇑(e.symm) ⁻¹' s) (⇑e x)		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f g : H → H},	    (∀ (y : H), y ∈ s → f y = g y) →	    f x = g x → G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at g s x		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f : H → H} {e' : local_homeomorph H H},	    e' ∈ G →	    s ⊆ f ⁻¹' e'.to_local_equiv.source →	    f x ∈ e'.to_local_equiv.source →	    G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at (⇑e' ∘ f) s x
5 goals	H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G,	s : set H,	x : H,	u : set H,	f : H → H,	hu : is_open u,	hux : x ∈ u	⊢ G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at f (s ∩ u) x		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G,	s : set H,	x : H,	u : set H,	f : H → H,	hu : is_open u,	hux : x ∈ u	⊢ G.is_local_structomorph_within_at f (s ∩ u) x → G.is_local_structomorph_within_at f s x		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f : H → H} {e : local_homeomorph H H},	    e ∈ G →	    x ∈ e.to_local_equiv.source →	    G.is_local_structomorph_within_at f s x →	    G.is_local_structomorph_within_at (f ∘ ⇑(e.symm)) (e.to_local_equiv.target ∩ ⇑(e.symm) ⁻¹' s) (⇑e x)		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f g : H → H},	    (∀ (y : H), y ∈ s → f y = g y) →	    f x = g x → G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at g s x		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f : H → H} {e' : local_homeomorph H H},	    e' ∈ G →	    s ⊆ f ⁻¹' e'.to_local_equiv.source →	    f x ∈ e'.to_local_equiv.source →	    G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at (⇑e' ∘ f) s x
5 goals	H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G,	s : set H,	x : H,	u : set H,	f : H → H,	hu : is_open u,	hux : x ∈ u,	h : G.is_local_structomorph_within_at f s x,	hx : x ∈ s ∩ u	⊢ ∃ (e : local_homeomorph H H),	    e ∈ G ∧ eq_on f e.to_local_equiv.to_fun (s ∩ u ∩ e.to_local_equiv.source) ∧ x ∈ e.to_local_equiv.source		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G,	s : set H,	x : H,	u : set H,	f : H → H,	hu : is_open u,	hux : x ∈ u	⊢ G.is_local_structomorph_within_at f (s ∩ u) x → G.is_local_structomorph_within_at f s x		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f : H → H} {e : local_homeomorph H H},	    e ∈ G →	    x ∈ e.to_local_equiv.source →	    G.is_local_structomorph_within_at f s x →	    G.is_local_structomorph_within_at (f ∘ ⇑(e.symm)) (e.to_local_equiv.target ∩ ⇑(e.symm) ⁻¹' s) (⇑e x)		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f g : H → H},	    (∀ (y : H), y ∈ s → f y = g y) →	    f x = g x → G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at g s x		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f : H → H} {e' : local_homeomorph H H},	    e' ∈ G →	    s ⊆ f ⁻¹' e'.to_local_equiv.source →	    f x ∈ e'.to_local_equiv.source →	    G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at (⇑e' ∘ f) s x
5 goals	H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G,	s : set H,	x : H,	u : set H,	f : H → H,	hu : is_open u,	hux : x ∈ u,	h : G.is_local_structomorph_within_at f s x,	hx : x ∈ s ∩ u,	e : local_homeomorph H H,	heG : e ∈ G,	hef : eq_on f e.to_local_equiv.to_fun (s ∩ e.to_local_equiv.source),	hex : x ∈ e.to_local_equiv.source	⊢ ∃ (e : local_homeomorph H H),	    e ∈ G ∧ eq_on f e.to_local_equiv.to_fun (s ∩ u ∩ e.to_local_equiv.source) ∧ x ∈ e.to_local_equiv.source		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G,	s : set H,	x : H,	u : set H,	f : H → H,	hu : is_open u,	hux : x ∈ u	⊢ G.is_local_structomorph_within_at f (s ∩ u) x → G.is_local_structomorph_within_at f s x		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f : H → H} {e : local_homeomorph H H},	    e ∈ G →	    x ∈ e.to_local_equiv.source →	    G.is_local_structomorph_within_at f s x →	    G.is_local_structomorph_within_at (f ∘ ⇑(e.symm)) (e.to_local_equiv.target ∩ ⇑(e.symm) ⁻¹' s) (⇑e x)		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f g : H → H},	    (∀ (y : H), y ∈ s → f y = g y) →	    f x = g x → G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at g s x		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f : H → H} {e' : local_homeomorph H H},	    e' ∈ G →	    s ⊆ f ⁻¹' e'.to_local_equiv.source →	    f x ∈ e'.to_local_equiv.source →	    G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at (⇑e' ∘ f) s x
5 goals	H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G,	s : set H,	x : H,	u : set H,	f : H → H,	hu : is_open u,	hux : x ∈ u,	h : G.is_local_structomorph_within_at f s x,	hx : x ∈ s ∩ u,	e : local_homeomorph H H,	heG : e ∈ G,	hef : eq_on f e.to_local_equiv.to_fun (s ∩ e.to_local_equiv.source),	hex : x ∈ e.to_local_equiv.source,	this : s ∩ u ∩ e.to_local_equiv.source ⊆ s ∩ e.to_local_equiv.source	⊢ ∃ (e : local_homeomorph H H),	    e ∈ G ∧ eq_on f e.to_local_equiv.to_fun (s ∩ u ∩ e.to_local_equiv.source) ∧ x ∈ e.to_local_equiv.source		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G,	s : set H,	x : H,	u : set H,	f : H → H,	hu : is_open u,	hux : x ∈ u	⊢ G.is_local_structomorph_within_at f (s ∩ u) x → G.is_local_structomorph_within_at f s x		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f : H → H} {e : local_homeomorph H H},	    e ∈ G →	    x ∈ e.to_local_equiv.source →	    G.is_local_structomorph_within_at f s x →	    G.is_local_structomorph_within_at (f ∘ ⇑(e.symm)) (e.to_local_equiv.target ∩ ⇑(e.symm) ⁻¹' s) (⇑e x)		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f g : H → H},	    (∀ (y : H), y ∈ s → f y = g y) →	    f x = g x → G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at g s x		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f : H → H} {e' : local_homeomorph H H},	    e' ∈ G →	    s ⊆ f ⁻¹' e'.to_local_equiv.source →	    f x ∈ e'.to_local_equiv.source →	    G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at (⇑e' ∘ f) s x
4 goals	H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G,	s : set H,	x : H,	u : set H,	f : H → H,	hu : is_open u,	hux : x ∈ u	⊢ G.is_local_structomorph_within_at f (s ∩ u) x → G.is_local_structomorph_within_at f s x		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f : H → H} {e : local_homeomorph H H},	    e ∈ G →	    x ∈ e.to_local_equiv.source →	    G.is_local_structomorph_within_at f s x →	    G.is_local_structomorph_within_at (f ∘ ⇑(e.symm)) (e.to_local_equiv.target ∩ ⇑(e.symm) ⁻¹' s) (⇑e x)		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f g : H → H},	    (∀ (y : H), y ∈ s → f y = g y) →	    f x = g x → G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at g s x		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f : H → H} {e' : local_homeomorph H H},	    e' ∈ G →	    s ⊆ f ⁻¹' e'.to_local_equiv.source →	    f x ∈ e'.to_local_equiv.source →	    G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at (⇑e' ∘ f) s x
4 goals	H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G,	s : set H,	x : H,	u : set H,	f : H → H,	hu : is_open u,	hux : x ∈ u,	h : G.is_local_structomorph_within_at f (s ∩ u) x,	hx : x ∈ s	⊢ ∃ (e : local_homeomorph H H),	    e ∈ G ∧ eq_on f e.to_local_equiv.to_fun (s ∩ e.to_local_equiv.source) ∧ x ∈ e.to_local_equiv.source		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f : H → H} {e : local_homeomorph H H},	    e ∈ G →	    x ∈ e.to_local_equiv.source →	    G.is_local_structomorph_within_at f s x →	    G.is_local_structomorph_within_at (f ∘ ⇑(e.symm)) (e.to_local_equiv.target ∩ ⇑(e.symm) ⁻¹' s) (⇑e x)		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f g : H → H},	    (∀ (y : H), y ∈ s → f y = g y) →	    f x = g x → G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at g s x		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f : H → H} {e' : local_homeomorph H H},	    e' ∈ G →	    s ⊆ f ⁻¹' e'.to_local_equiv.source →	    f x ∈ e'.to_local_equiv.source →	    G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at (⇑e' ∘ f) s x
4 goals	H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G,	s : set H,	x : H,	u : set H,	f : H → H,	hu : is_open u,	hux : x ∈ u,	h : G.is_local_structomorph_within_at f (s ∩ u) x,	hx : x ∈ s,	e : local_homeomorph H H,	heG : e ∈ G,	hef : eq_on f e.to_local_equiv.to_fun (s ∩ u ∩ e.to_local_equiv.source),	hex : x ∈ e.to_local_equiv.source	⊢ ∃ (e : local_homeomorph H H),	    e ∈ G ∧ eq_on f e.to_local_equiv.to_fun (s ∩ e.to_local_equiv.source) ∧ x ∈ e.to_local_equiv.source		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f : H → H} {e : local_homeomorph H H},	    e ∈ G →	    x ∈ e.to_local_equiv.source →	    G.is_local_structomorph_within_at f s x →	    G.is_local_structomorph_within_at (f ∘ ⇑(e.symm)) (e.to_local_equiv.target ∩ ⇑(e.symm) ⁻¹' s) (⇑e x)		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f g : H → H},	    (∀ (y : H), y ∈ s → f y = g y) →	    f x = g x → G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at g s x		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f : H → H} {e' : local_homeomorph H H},	    e' ∈ G →	    s ⊆ f ⁻¹' e'.to_local_equiv.source →	    f x ∈ e'.to_local_equiv.source →	    G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at (⇑e' ∘ f) s x
6 goals	H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G,	s : set H,	x : H,	u : set H,	f : H → H,	hu : is_open u,	hux : x ∈ u,	h : G.is_local_structomorph_within_at f (s ∩ u) x,	hx : x ∈ s,	e : local_homeomorph H H,	heG : e ∈ G,	hef : eq_on f e.to_local_equiv.to_fun (s ∩ u ∩ e.to_local_equiv.source),	hex : x ∈ e.to_local_equiv.source	⊢ e.restr (interior u) ∈ G		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G,	s : set H,	x : H,	u : set H,	f : H → H,	hu : is_open u,	hux : x ∈ u,	h : G.is_local_structomorph_within_at f (s ∩ u) x,	hx : x ∈ s,	e : local_homeomorph H H,	heG : e ∈ G,	hef : eq_on f e.to_local_equiv.to_fun (s ∩ u ∩ e.to_local_equiv.source),	hex : x ∈ e.to_local_equiv.source	⊢ eq_on f (e.restr (interior u)).to_local_equiv.to_fun (s ∩ (e.restr (interior u)).to_local_equiv.source)		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G,	s : set H,	x : H,	u : set H,	f : H → H,	hu : is_open u,	hux : x ∈ u,	h : G.is_local_structomorph_within_at f (s ∩ u) x,	hx : x ∈ s,	e : local_homeomorph H H,	heG : e ∈ G,	hef : eq_on f e.to_local_equiv.to_fun (s ∩ u ∩ e.to_local_equiv.source),	hex : x ∈ e.to_local_equiv.source	⊢ x ∈ (e.restr (interior u)).to_local_equiv.source		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f : H → H} {e : local_homeomorph H H},	    e ∈ G →	    x ∈ e.to_local_equiv.source →	    G.is_local_structomorph_within_at f s x →	    G.is_local_structomorph_within_at (f ∘ ⇑(e.symm)) (e.to_local_equiv.target ∩ ⇑(e.symm) ⁻¹' s) (⇑e x)		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f g : H → H},	    (∀ (y : H), y ∈ s → f y = g y) →	    f x = g x → G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at g s x		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f : H → H} {e' : local_homeomorph H H},	    e' ∈ G →	    s ⊆ f ⁻¹' e'.to_local_equiv.source →	    f x ∈ e'.to_local_equiv.source →	    G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at (⇑e' ∘ f) s x
5 goals	H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G,	s : set H,	x : H,	u : set H,	f : H → H,	hu : is_open u,	hux : x ∈ u,	h : G.is_local_structomorph_within_at f (s ∩ u) x,	hx : x ∈ s,	e : local_homeomorph H H,	heG : e ∈ G,	hef : eq_on f e.to_local_equiv.to_fun (s ∩ u ∩ e.to_local_equiv.source),	hex : x ∈ e.to_local_equiv.source	⊢ eq_on f (e.restr (interior u)).to_local_equiv.to_fun (s ∩ (e.restr (interior u)).to_local_equiv.source)		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G,	s : set H,	x : H,	u : set H,	f : H → H,	hu : is_open u,	hux : x ∈ u,	h : G.is_local_structomorph_within_at f (s ∩ u) x,	hx : x ∈ s,	e : local_homeomorph H H,	heG : e ∈ G,	hef : eq_on f e.to_local_equiv.to_fun (s ∩ u ∩ e.to_local_equiv.source),	hex : x ∈ e.to_local_equiv.source	⊢ x ∈ (e.restr (interior u)).to_local_equiv.source		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f : H → H} {e : local_homeomorph H H},	    e ∈ G →	    x ∈ e.to_local_equiv.source →	    G.is_local_structomorph_within_at f s x →	    G.is_local_structomorph_within_at (f ∘ ⇑(e.symm)) (e.to_local_equiv.target ∩ ⇑(e.symm) ⁻¹' s) (⇑e x)		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f g : H → H},	    (∀ (y : H), y ∈ s → f y = g y) →	    f x = g x → G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at g s x		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f : H → H} {e' : local_homeomorph H H},	    e' ∈ G →	    s ⊆ f ⁻¹' e'.to_local_equiv.source →	    f x ∈ e'.to_local_equiv.source →	    G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at (⇑e' ∘ f) s x
5 goals	H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G,	s : set H,	x : H,	u : set H,	f : H → H,	hu : is_open u,	hux : x ∈ u,	h : G.is_local_structomorph_within_at f (s ∩ u) x,	hx : x ∈ s,	e : local_homeomorph H H,	heG : e ∈ G,	hef : eq_on f e.to_local_equiv.to_fun (s ∩ u ∩ e.to_local_equiv.source),	hex : x ∈ e.to_local_equiv.source,	this : s ∩ u ∩ e.to_local_equiv.source = s ∩ (e.to_local_equiv.source ∩ u)	⊢ eq_on f (e.restr (interior u)).to_local_equiv.to_fun (s ∩ (e.restr (interior u)).to_local_equiv.source)		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G,	s : set H,	x : H,	u : set H,	f : H → H,	hu : is_open u,	hux : x ∈ u,	h : G.is_local_structomorph_within_at f (s ∩ u) x,	hx : x ∈ s,	e : local_homeomorph H H,	heG : e ∈ G,	hef : eq_on f e.to_local_equiv.to_fun (s ∩ u ∩ e.to_local_equiv.source),	hex : x ∈ e.to_local_equiv.source	⊢ x ∈ (e.restr (interior u)).to_local_equiv.source		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f : H → H} {e : local_homeomorph H H},	    e ∈ G →	    x ∈ e.to_local_equiv.source →	    G.is_local_structomorph_within_at f s x →	    G.is_local_structomorph_within_at (f ∘ ⇑(e.symm)) (e.to_local_equiv.target ∩ ⇑(e.symm) ⁻¹' s) (⇑e x)		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f g : H → H},	    (∀ (y : H), y ∈ s → f y = g y) →	    f x = g x → G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at g s x		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f : H → H} {e' : local_homeomorph H H},	    e' ∈ G →	    s ⊆ f ⁻¹' e'.to_local_equiv.source →	    f x ∈ e'.to_local_equiv.source →	    G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at (⇑e' ∘ f) s x
4 goals	H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G,	s : set H,	x : H,	u : set H,	f : H → H,	hu : is_open u,	hux : x ∈ u,	h : G.is_local_structomorph_within_at f (s ∩ u) x,	hx : x ∈ s,	e : local_homeomorph H H,	heG : e ∈ G,	hef : eq_on f e.to_local_equiv.to_fun (s ∩ u ∩ e.to_local_equiv.source),	hex : x ∈ e.to_local_equiv.source	⊢ x ∈ (e.restr (interior u)).to_local_equiv.source		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f : H → H} {e : local_homeomorph H H},	    e ∈ G →	    x ∈ e.to_local_equiv.source →	    G.is_local_structomorph_within_at f s x →	    G.is_local_structomorph_within_at (f ∘ ⇑(e.symm)) (e.to_local_equiv.target ∩ ⇑(e.symm) ⁻¹' s) (⇑e x)		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f g : H → H},	    (∀ (y : H), y ∈ s → f y = g y) →	    f x = g x → G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at g s x		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f : H → H} {e' : local_homeomorph H H},	    e' ∈ G →	    s ⊆ f ⁻¹' e'.to_local_equiv.source →	    f x ∈ e'.to_local_equiv.source →	    G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at (⇑e' ∘ f) s x
3 goals	H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f : H → H} {e : local_homeomorph H H},	    e ∈ G →	    x ∈ e.to_local_equiv.source →	    G.is_local_structomorph_within_at f s x →	    G.is_local_structomorph_within_at (f ∘ ⇑(e.symm)) (e.to_local_equiv.target ∩ ⇑(e.symm) ⁻¹' s) (⇑e x)		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f g : H → H},	    (∀ (y : H), y ∈ s → f y = g y) →	    f x = g x → G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at g s x		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f : H → H} {e' : local_homeomorph H H},	    e' ∈ G →	    s ⊆ f ⁻¹' e'.to_local_equiv.source →	    f x ∈ e'.to_local_equiv.source →	    G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at (⇑e' ∘ f) s x
3 goals	H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G,	s : set H,	x : H,	f : H → H,	e' : local_homeomorph H H,	he'G : e' ∈ G,	he'x : x ∈ e'.to_local_equiv.source,	h : G.is_local_structomorph_within_at f s x,	hx : ⇑e' x ∈ e'.to_local_equiv.target ∩ ⇑(e'.symm) ⁻¹' s	⊢ ∃ (e : local_homeomorph H H),	    e ∈ G ∧	      eq_on (f ∘ ⇑(e'.symm)) e.to_local_equiv.to_fun	          (e'.to_local_equiv.target ∩ ⇑(e'.symm) ⁻¹' s ∩ e.to_local_equiv.source) ∧	        ⇑e' x ∈ e.to_local_equiv.source		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f g : H → H},	    (∀ (y : H), y ∈ s → f y = g y) →	    f x = g x → G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at g s x		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f : H → H} {e' : local_homeomorph H H},	    e' ∈ G →	    s ⊆ f ⁻¹' e'.to_local_equiv.source →	    f x ∈ e'.to_local_equiv.source →	    G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at (⇑e' ∘ f) s x
3 goals	H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G,	s : set H,	x : H,	f : H → H,	e' : local_homeomorph H H,	he'G : e' ∈ G,	he'x : x ∈ e'.to_local_equiv.source,	h : G.is_local_structomorph_within_at f s x,	hx : ⇑e' x ∈ e'.to_local_equiv.target ∩ ⇑(e'.symm) ⁻¹' s,	hxs : x ∈ s	⊢ ∃ (e : local_homeomorph H H),	    e ∈ G ∧	      eq_on (f ∘ ⇑(e'.symm)) e.to_local_equiv.to_fun	          (e'.to_local_equiv.target ∩ ⇑(e'.symm) ⁻¹' s ∩ e.to_local_equiv.source) ∧	        ⇑e' x ∈ e.to_local_equiv.source		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f g : H → H},	    (∀ (y : H), y ∈ s → f y = g y) →	    f x = g x → G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at g s x		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f : H → H} {e' : local_homeomorph H H},	    e' ∈ G →	    s ⊆ f ⁻¹' e'.to_local_equiv.source →	    f x ∈ e'.to_local_equiv.source →	    G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at (⇑e' ∘ f) s x
3 goals	H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G,	s : set H,	x : H,	f : H → H,	e' : local_homeomorph H H,	he'G : e' ∈ G,	he'x : x ∈ e'.to_local_equiv.source,	h : G.is_local_structomorph_within_at f s x,	hx : ⇑e' x ∈ e'.to_local_equiv.target ∩ ⇑(e'.symm) ⁻¹' s,	hxs : x ∈ s,	e : local_homeomorph H H,	heG : e ∈ G,	hef : eq_on f e.to_local_equiv.to_fun (s ∩ e.to_local_equiv.source),	hex : x ∈ e.to_local_equiv.source	⊢ ∃ (e : local_homeomorph H H),	    e ∈ G ∧	      eq_on (f ∘ ⇑(e'.symm)) e.to_local_equiv.to_fun	          (e'.to_local_equiv.target ∩ ⇑(e'.symm) ⁻¹' s ∩ e.to_local_equiv.source) ∧	        ⇑e' x ∈ e.to_local_equiv.source		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f g : H → H},	    (∀ (y : H), y ∈ s → f y = g y) →	    f x = g x → G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at g s x		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f : H → H} {e' : local_homeomorph H H},	    e' ∈ G →	    s ⊆ f ⁻¹' e'.to_local_equiv.source →	    f x ∈ e'.to_local_equiv.source →	    G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at (⇑e' ∘ f) s x
4 goals	H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G,	s : set H,	x : H,	f : H → H,	e' : local_homeomorph H H,	he'G : e' ∈ G,	he'x : x ∈ e'.to_local_equiv.source,	h : G.is_local_structomorph_within_at f s x,	hx : ⇑e' x ∈ e'.to_local_equiv.target ∩ ⇑(e'.symm) ⁻¹' s,	hxs : x ∈ s,	e : local_homeomorph H H,	heG : e ∈ G,	hef : eq_on f e.to_local_equiv.to_fun (s ∩ e.to_local_equiv.source),	hex : x ∈ e.to_local_equiv.source	⊢ eq_on (f ∘ ⇑(e'.symm)) (e'.symm.trans e).to_local_equiv.to_fun	    (e'.to_local_equiv.target ∩ ⇑(e'.symm) ⁻¹' s ∩ (e'.symm.trans e).to_local_equiv.source)		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G,	s : set H,	x : H,	f : H → H,	e' : local_homeomorph H H,	he'G : e' ∈ G,	he'x : x ∈ e'.to_local_equiv.source,	h : G.is_local_structomorph_within_at f s x,	hx : ⇑e' x ∈ e'.to_local_equiv.target ∩ ⇑(e'.symm) ⁻¹' s,	hxs : x ∈ s,	e : local_homeomorph H H,	heG : e ∈ G,	hef : eq_on f e.to_local_equiv.to_fun (s ∩ e.to_local_equiv.source),	hex : x ∈ e.to_local_equiv.source	⊢ ⇑e' x ∈ (e'.symm.trans e).to_local_equiv.source		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f g : H → H},	    (∀ (y : H), y ∈ s → f y = g y) →	    f x = g x → G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at g s x		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f : H → H} {e' : local_homeomorph H H},	    e' ∈ G →	    s ⊆ f ⁻¹' e'.to_local_equiv.source →	    f x ∈ e'.to_local_equiv.source →	    G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at (⇑e' ∘ f) s x
4 goals	H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G,	s : set H,	x : H,	f : H → H,	e' : local_homeomorph H H,	he'G : e' ∈ G,	he'x : x ∈ e'.to_local_equiv.source,	h : G.is_local_structomorph_within_at f s x,	hx : ⇑e' x ∈ e'.to_local_equiv.target ∩ ⇑(e'.symm) ⁻¹' s,	hxs : x ∈ s,	e : local_homeomorph H H,	heG : e ∈ G,	hef : eq_on f e.to_local_equiv.to_fun (s ∩ e.to_local_equiv.source),	hex : x ∈ e.to_local_equiv.source,	y : H,	hy : y ∈ e'.to_local_equiv.target ∩ ⇑(e'.symm) ⁻¹' s ∩ (e'.symm.trans e).to_local_equiv.source	⊢ (f ∘ ⇑(e'.symm)) y = (e'.symm.trans e).to_local_equiv.to_fun y		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G,	s : set H,	x : H,	f : H → H,	e' : local_homeomorph H H,	he'G : e' ∈ G,	he'x : x ∈ e'.to_local_equiv.source,	h : G.is_local_structomorph_within_at f s x,	hx : ⇑e' x ∈ e'.to_local_equiv.target ∩ ⇑(e'.symm) ⁻¹' s,	hxs : x ∈ s,	e : local_homeomorph H H,	heG : e ∈ G,	hef : eq_on f e.to_local_equiv.to_fun (s ∩ e.to_local_equiv.source),	hex : x ∈ e.to_local_equiv.source	⊢ ⇑e' x ∈ (e'.symm.trans e).to_local_equiv.source		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f g : H → H},	    (∀ (y : H), y ∈ s → f y = g y) →	    f x = g x → G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at g s x		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f : H → H} {e' : local_homeomorph H H},	    e' ∈ G →	    s ⊆ f ⁻¹' e'.to_local_equiv.source →	    f x ∈ e'.to_local_equiv.source →	    G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at (⇑e' ∘ f) s x
4 goals	H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G,	s : set H,	x : H,	f : H → H,	e' : local_homeomorph H H,	he'G : e' ∈ G,	he'x : x ∈ e'.to_local_equiv.source,	h : G.is_local_structomorph_within_at f s x,	hx : ⇑e' x ∈ e'.to_local_equiv.target ∩ ⇑(e'.symm) ⁻¹' s,	hxs : x ∈ s,	e : local_homeomorph H H,	heG : e ∈ G,	hef : eq_on f e.to_local_equiv.to_fun (s ∩ e.to_local_equiv.source),	hex : x ∈ e.to_local_equiv.source,	y : H,	hy :	  (y ∈ e'.to_local_equiv.target ∧ ⇑(e'.symm) y ∈ s) ∧	    y ∈ e'.to_local_equiv.target ∧ ⇑(e'.symm) y ∈ e.to_local_equiv.source	⊢ (f ∘ ⇑(e'.symm)) y = (e'.symm.trans e).to_local_equiv.to_fun y		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G,	s : set H,	x : H,	f : H → H,	e' : local_homeomorph H H,	he'G : e' ∈ G,	he'x : x ∈ e'.to_local_equiv.source,	h : G.is_local_structomorph_within_at f s x,	hx : ⇑e' x ∈ e'.to_local_equiv.target ∩ ⇑(e'.symm) ⁻¹' s,	hxs : x ∈ s,	e : local_homeomorph H H,	heG : e ∈ G,	hef : eq_on f e.to_local_equiv.to_fun (s ∩ e.to_local_equiv.source),	hex : x ∈ e.to_local_equiv.source	⊢ ⇑e' x ∈ (e'.symm.trans e).to_local_equiv.source		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f g : H → H},	    (∀ (y : H), y ∈ s → f y = g y) →	    f x = g x → G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at g s x		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f : H → H} {e' : local_homeomorph H H},	    e' ∈ G →	    s ⊆ f ⁻¹' e'.to_local_equiv.source →	    f x ∈ e'.to_local_equiv.source →	    G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at (⇑e' ∘ f) s x
3 goals	H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G,	s : set H,	x : H,	f : H → H,	e' : local_homeomorph H H,	he'G : e' ∈ G,	he'x : x ∈ e'.to_local_equiv.source,	h : G.is_local_structomorph_within_at f s x,	hx : ⇑e' x ∈ e'.to_local_equiv.target ∩ ⇑(e'.symm) ⁻¹' s,	hxs : x ∈ s,	e : local_homeomorph H H,	heG : e ∈ G,	hef : eq_on f e.to_local_equiv.to_fun (s ∩ e.to_local_equiv.source),	hex : x ∈ e.to_local_equiv.source	⊢ ⇑e' x ∈ (e'.symm.trans e).to_local_equiv.source		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f g : H → H},	    (∀ (y : H), y ∈ s → f y = g y) →	    f x = g x → G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at g s x		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f : H → H} {e' : local_homeomorph H H},	    e' ∈ G →	    s ⊆ f ⁻¹' e'.to_local_equiv.source →	    f x ∈ e'.to_local_equiv.source →	    G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at (⇑e' ∘ f) s x
2 goals	H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f g : H → H},	    (∀ (y : H), y ∈ s → f y = g y) →	    f x = g x → G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at g s x		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f : H → H} {e' : local_homeomorph H H},	    e' ∈ G →	    s ⊆ f ⁻¹' e'.to_local_equiv.source →	    f x ∈ e'.to_local_equiv.source →	    G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at (⇑e' ∘ f) s x
2 goals	H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G,	s : set H,	x : H,	f g : H → H,	hfgs : ∀ (y : H), y ∈ s → f y = g y,	hfg' : f x = g x,	h : G.is_local_structomorph_within_at f s x,	hx : x ∈ s	⊢ ∃ (e : local_homeomorph H H),	    e ∈ G ∧ eq_on g e.to_local_equiv.to_fun (s ∩ e.to_local_equiv.source) ∧ x ∈ e.to_local_equiv.source		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f : H → H} {e' : local_homeomorph H H},	    e' ∈ G →	    s ⊆ f ⁻¹' e'.to_local_equiv.source →	    f x ∈ e'.to_local_equiv.source →	    G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at (⇑e' ∘ f) s x
2 goals	H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G,	s : set H,	x : H,	f g : H → H,	hfgs : ∀ (y : H), y ∈ s → f y = g y,	hfg' : f x = g x,	h : G.is_local_structomorph_within_at f s x,	hx : x ∈ s,	e : local_homeomorph H H,	heG : e ∈ G,	hef : eq_on f e.to_local_equiv.to_fun (s ∩ e.to_local_equiv.source),	hex : x ∈ e.to_local_equiv.source	⊢ ∃ (e : local_homeomorph H H),	    e ∈ G ∧ eq_on g e.to_local_equiv.to_fun (s ∩ e.to_local_equiv.source) ∧ x ∈ e.to_local_equiv.source		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f : H → H} {e' : local_homeomorph H H},	    e' ∈ G →	    s ⊆ f ⁻¹' e'.to_local_equiv.source →	    f x ∈ e'.to_local_equiv.source →	    G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at (⇑e' ∘ f) s x
2 goals	H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G,	s : set H,	x : H,	f g : H → H,	hfgs : ∀ (y : H), y ∈ s → f y = g y,	hfg' : f x = g x,	h : G.is_local_structomorph_within_at f s x,	hx : x ∈ s,	e : local_homeomorph H H,	heG : e ∈ G,	hef : eq_on f e.to_local_equiv.to_fun (s ∩ e.to_local_equiv.source),	hex : x ∈ e.to_local_equiv.source	⊢ eq_on g e.to_local_equiv.to_fun (s ∩ e.to_local_equiv.source)		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f : H → H} {e' : local_homeomorph H H},	    e' ∈ G →	    s ⊆ f ⁻¹' e'.to_local_equiv.source →	    f x ∈ e'.to_local_equiv.source →	    G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at (⇑e' ∘ f) s x
2 goals	H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G,	s : set H,	x : H,	f g : H → H,	hfgs : ∀ (y : H), y ∈ s → f y = g y,	hfg' : f x = g x,	h : G.is_local_structomorph_within_at f s x,	hx : x ∈ s,	e : local_homeomorph H H,	heG : e ∈ G,	hef : eq_on f e.to_local_equiv.to_fun (s ∩ e.to_local_equiv.source),	hex : x ∈ e.to_local_equiv.source,	y : H,	hy : y ∈ s ∩ e.to_local_equiv.source	⊢ g y = e.to_local_equiv.to_fun y		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f : H → H} {e' : local_homeomorph H H},	    e' ∈ G →	    s ⊆ f ⁻¹' e'.to_local_equiv.source →	    f x ∈ e'.to_local_equiv.source →	    G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at (⇑e' ∘ f) s x
H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G	⊢ ∀ {s : set H} {x : H} {f : H → H} {e' : local_homeomorph H H},	    e' ∈ G →	    s ⊆ f ⁻¹' e'.to_local_equiv.source →	    f x ∈ e'.to_local_equiv.source →	    G.is_local_structomorph_within_at f s x → G.is_local_structomorph_within_at (⇑e' ∘ f) s x
H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G,	s : set H,	x : H,	f : H → H,	e' : local_homeomorph H H,	he'G : e' ∈ G,	he' : s ⊆ f ⁻¹' e'.to_local_equiv.source,	hfx : f x ∈ e'.to_local_equiv.source,	h : G.is_local_structomorph_within_at f s x,	hx : x ∈ s	⊢ ∃ (e : local_homeomorph H H),	    e ∈ G ∧	      eq_on (⇑e' ∘ f) e.to_local_equiv.to_fun (s ∩ e.to_local_equiv.source) ∧ x ∈ e.to_local_equiv.source
H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G,	s : set H,	x : H,	f : H → H,	e' : local_homeomorph H H,	he'G : e' ∈ G,	he' : s ⊆ f ⁻¹' e'.to_local_equiv.source,	hfx : f x ∈ e'.to_local_equiv.source,	h : G.is_local_structomorph_within_at f s x,	hx : x ∈ s,	e : local_homeomorph H H,	heG : e ∈ G,	hef : eq_on f e.to_local_equiv.to_fun (s ∩ e.to_local_equiv.source),	hex : x ∈ e.to_local_equiv.source	⊢ ∃ (e : local_homeomorph H H),	    e ∈ G ∧	      eq_on (⇑e' ∘ f) e.to_local_equiv.to_fun (s ∩ e.to_local_equiv.source) ∧ x ∈ e.to_local_equiv.source
2 goals	H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G,	s : set H,	x : H,	f : H → H,	e' : local_homeomorph H H,	he'G : e' ∈ G,	he' : s ⊆ f ⁻¹' e'.to_local_equiv.source,	hfx : f x ∈ e'.to_local_equiv.source,	h : G.is_local_structomorph_within_at f s x,	hx : x ∈ s,	e : local_homeomorph H H,	heG : e ∈ G,	hef : eq_on f e.to_local_equiv.to_fun (s ∩ e.to_local_equiv.source),	hex : x ∈ e.to_local_equiv.source	⊢ eq_on (⇑e' ∘ f) (e.trans e').to_local_equiv.to_fun (s ∩ (e.trans e').to_local_equiv.source)		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G,	s : set H,	x : H,	f : H → H,	e' : local_homeomorph H H,	he'G : e' ∈ G,	he' : s ⊆ f ⁻¹' e'.to_local_equiv.source,	hfx : f x ∈ e'.to_local_equiv.source,	h : G.is_local_structomorph_within_at f s x,	hx : x ∈ s,	e : local_homeomorph H H,	heG : e ∈ G,	hef : eq_on f e.to_local_equiv.to_fun (s ∩ e.to_local_equiv.source),	hex : x ∈ e.to_local_equiv.source	⊢ x ∈ (e.trans e').to_local_equiv.source
2 goals	H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G,	s : set H,	x : H,	f : H → H,	e' : local_homeomorph H H,	he'G : e' ∈ G,	he' : s ⊆ f ⁻¹' e'.to_local_equiv.source,	hfx : f x ∈ e'.to_local_equiv.source,	h : G.is_local_structomorph_within_at f s x,	hx : x ∈ s,	e : local_homeomorph H H,	heG : e ∈ G,	hef : eq_on f e.to_local_equiv.to_fun (s ∩ e.to_local_equiv.source),	hex : x ∈ e.to_local_equiv.source,	y : H,	hy : y ∈ s ∩ (e.trans e').to_local_equiv.source	⊢ (⇑e' ∘ f) y = (e.trans e').to_local_equiv.to_fun y		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G,	s : set H,	x : H,	f : H → H,	e' : local_homeomorph H H,	he'G : e' ∈ G,	he' : s ⊆ f ⁻¹' e'.to_local_equiv.source,	hfx : f x ∈ e'.to_local_equiv.source,	h : G.is_local_structomorph_within_at f s x,	hx : x ∈ s,	e : local_homeomorph H H,	heG : e ∈ G,	hef : eq_on f e.to_local_equiv.to_fun (s ∩ e.to_local_equiv.source),	hex : x ∈ e.to_local_equiv.source	⊢ x ∈ (e.trans e').to_local_equiv.source
2 goals	H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G,	s : set H,	x : H,	f : H → H,	e' : local_homeomorph H H,	he'G : e' ∈ G,	he' : s ⊆ f ⁻¹' e'.to_local_equiv.source,	hfx : f x ∈ e'.to_local_equiv.source,	h : G.is_local_structomorph_within_at f s x,	hx : x ∈ s,	e : local_homeomorph H H,	heG : e ∈ G,	hef : eq_on f e.to_local_equiv.to_fun (s ∩ e.to_local_equiv.source),	hex : x ∈ e.to_local_equiv.source,	y : H,	hy : y ∈ s ∧ y ∈ e.to_local_equiv.source ∧ ⇑e y ∈ e'.to_local_equiv.source	⊢ (⇑e' ∘ f) y = (e.trans e').to_local_equiv.to_fun y		H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G,	s : set H,	x : H,	f : H → H,	e' : local_homeomorph H H,	he'G : e' ∈ G,	he' : s ⊆ f ⁻¹' e'.to_local_equiv.source,	hfx : f x ∈ e'.to_local_equiv.source,	h : G.is_local_structomorph_within_at f s x,	hx : x ∈ s,	e : local_homeomorph H H,	heG : e ∈ G,	hef : eq_on f e.to_local_equiv.to_fun (s ∩ e.to_local_equiv.source),	hex : x ∈ e.to_local_equiv.source	⊢ x ∈ (e.trans e').to_local_equiv.source
H : Type u_1,	_inst_1 : topological_space H,	G : structure_groupoid H,	_inst_7 : closed_under_restriction G,	s : set H,	x : H,	f : H → H,	e' : local_homeomorph H H,	he'G : e' ∈ G,	he' : s ⊆ f ⁻¹' e'.to_local_equiv.source,	hfx : f x ∈ e'.to_local_equiv.source,	h : G.is_local_structomorph_within_at f s x,	hx : x ∈ s,	e : local_homeomorph H H,	heG : e ∈ G,	hef : eq_on f e.to_local_equiv.to_fun (s ∩ e.to_local_equiv.source),	hex : x ∈ e.to_local_equiv.source	⊢ x ∈ (e.trans e').to_local_equiv.source
⊢ ∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field 𝕜] {E : Type u_2} [_inst_2 : normed_group E]	  [_inst_3 : normed_space 𝕜 E] {H : Type u_3} [_inst_4 : topological_space H] (I : model_with_corners 𝕜 E H)	  {M : Type u_4} [_inst_5 : topological_space M] [_inst_6 : charted_space H M]	  [_inst_7 : smooth_manifold_with_corners I M] {s : set M} {p : tangent_bundle I M},	    unique_mdiff_within_at I s (tangent_bundle.proj I M p) → tangent_map_within I I id s p = p
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	M : Type u_4,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	_inst_7 : smooth_manifold_with_corners I M,	s : set M,	p : tangent_bundle I M,	hs : unique_mdiff_within_at I s (tangent_bundle.proj I M p)	⊢ tangent_map_within I I id s p = p
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	M : Type u_4,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	_inst_7 : smooth_manifold_with_corners I M,	s : set M,	p : tangent_bundle I M,	hs : unique_mdiff_within_at I s (tangent_bundle.proj I M p)	⊢ ⟨id p.fst, ⇑(mfderiv_within I I id s p.fst) p.snd⟩ = p
2 goals	𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	M : Type u_4,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	_inst_7 : smooth_manifold_with_corners I M,	s : set M,	p : tangent_bundle I M,	hs : unique_mdiff_within_at I s (tangent_bundle.proj I M p)	⊢ ⟨id p.fst, ⇑(continuous_linear_map.id 𝕜 (tangent_space I p.fst)) p.snd⟩ = p		𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	M : Type u_4,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	_inst_7 : smooth_manifold_with_corners I M,	s : set M,	p : tangent_bundle I M,	hs : unique_mdiff_within_at I s (tangent_bundle.proj I M p)	⊢ unique_mdiff_within_at I s p.fst
2 goals	𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	M : Type u_4,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	_inst_7 : smooth_manifold_with_corners I M,	s : set M,	p_fst : M,	p_snd : tangent_space I p_fst,	hs : unique_mdiff_within_at I s (tangent_bundle.proj I M ⟨p_fst, p_snd⟩)	⊢ ⟨id ⟨p_fst, p_snd⟩.fst,	     ⇑(continuous_linear_map.id 𝕜 (tangent_space I ⟨p_fst, p_snd⟩.fst)) ⟨p_fst, p_snd⟩.snd⟩ =	    ⟨p_fst, p_snd⟩		𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	M : Type u_4,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	_inst_7 : smooth_manifold_with_corners I M,	s : set M,	p : tangent_bundle I M,	hs : unique_mdiff_within_at I s (tangent_bundle.proj I M p)	⊢ unique_mdiff_within_at I s p.fst
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	M : Type u_4,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	_inst_7 : smooth_manifold_with_corners I M,	s : set M,	p : tangent_bundle I M,	hs : unique_mdiff_within_at I s (tangent_bundle.proj I M p)	⊢ unique_mdiff_within_at I s p.fst
⊢ ∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field 𝕜] {E : Type u_2} [_inst_2 : normed_group E]	  [_inst_3 : normed_space 𝕜 E] {E' : Type u_5} [_inst_7 : normed_group E'] [_inst_8 : normed_space 𝕜 E']	  {n : with_top ℕ} {f : E → E'},	    times_cont_mdiff (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') n f ↔ times_cont_diff 𝕜 n f
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	E' : Type u_5,	_inst_7 : normed_group E',	_inst_8 : normed_space 𝕜 E',	n : with_top ℕ,	f : E → E'	⊢ times_cont_mdiff (model_with_corners_self 𝕜 E) (model_with_corners_self 𝕜 E') n f ↔ times_cont_diff 𝕜 n f
⊢ ∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field 𝕜] {E : Type u_2} [_inst_2 : normed_group E]	  [_inst_3 : normed_space 𝕜 E] {H : Type u_3} [_inst_4 : topological_space H] {I : model_with_corners 𝕜 E H}	  {M : Type u_4} [_inst_5 : topological_space M] [_inst_6 : charted_space H M] [Is : smooth_manifold_with_corners I M]	  {E' : Type u_5} [_inst_7 : normed_group E'] [_inst_8 : normed_space 𝕜 E'] {n : with_top ℕ}	  (Z : basic_smooth_bundle_core I M E'),	    times_cont_mdiff (I.prod (model_with_corners_self 𝕜 E')) I n Z.to_topological_fiber_bundle_core.proj
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	M : Type u_4,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	Is : smooth_manifold_with_corners I M,	E' : Type u_5,	_inst_7 : normed_group E',	_inst_8 : normed_space 𝕜 E',	n : with_top ℕ,	Z : basic_smooth_bundle_core I M E'	⊢ times_cont_mdiff (I.prod (model_with_corners_self 𝕜 E')) I n Z.to_topological_fiber_bundle_core.proj
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	M : Type u_4,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	Is : smooth_manifold_with_corners I M,	E' : Type u_5,	_inst_7 : normed_group E',	_inst_8 : normed_space 𝕜 E',	n : with_top ℕ,	Z : basic_smooth_bundle_core I M E',	x : Z.to_topological_fiber_bundle_core.total_space	⊢ times_cont_mdiff_at (I.prod (model_with_corners_self 𝕜 E')) I n Z.to_topological_fiber_bundle_core.proj x
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	M : Type u_4,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	Is : smooth_manifold_with_corners I M,	E' : Type u_5,	_inst_7 : normed_group E',	_inst_8 : normed_space 𝕜 E',	n : with_top ℕ,	Z : basic_smooth_bundle_core I M E',	x : Z.to_topological_fiber_bundle_core.total_space	⊢ continuous_within_at Z.to_topological_fiber_bundle_core.proj univ x ∧	    times_cont_diff_within_at 𝕜 n	      (⇑(ext_chart_at I (Z.to_topological_fiber_bundle_core.proj x)) ∘	         Z.to_topological_fiber_bundle_core.proj ∘	           ⇑((ext_chart_at (I.prod (model_with_corners_self 𝕜 E')) x).symm))	      ((ext_chart_at (I.prod (model_with_corners_self 𝕜 E')) x).target ∩	         ⇑((ext_chart_at (I.prod (model_with_corners_self 𝕜 E')) x).symm) ⁻¹'	           (univ ∩	              Z.to_topological_fiber_bundle_core.proj ⁻¹'	                (ext_chart_at I (Z.to_topological_fiber_bundle_core.proj x)).source))	      (⇑(ext_chart_at (I.prod (model_with_corners_self 𝕜 E')) x) x)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	M : Type u_4,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	Is : smooth_manifold_with_corners I M,	E' : Type u_5,	_inst_7 : normed_group E',	_inst_8 : normed_space 𝕜 E',	n : with_top ℕ,	Z : basic_smooth_bundle_core I M E',	x : Z.to_topological_fiber_bundle_core.total_space	⊢ times_cont_diff_within_at 𝕜 n	    (⇑(ext_chart_at I (Z.to_topological_fiber_bundle_core.proj x)) ∘	       Z.to_topological_fiber_bundle_core.proj ∘	         ⇑((ext_chart_at (I.prod (model_with_corners_self 𝕜 E')) x).symm))	    ((ext_chart_at (I.prod (model_with_corners_self 𝕜 E')) x).target ∩	       ⇑((ext_chart_at (I.prod (model_with_corners_self 𝕜 E')) x).symm) ⁻¹'	         (univ ∩	            Z.to_topological_fiber_bundle_core.proj ⁻¹'	              (ext_chart_at I (Z.to_topological_fiber_bundle_core.proj x)).source))	    (⇑(ext_chart_at (I.prod (model_with_corners_self 𝕜 E')) x) x)
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	M : Type u_4,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	Is : smooth_manifold_with_corners I M,	E' : Type u_5,	_inst_7 : normed_group E',	_inst_8 : normed_space 𝕜 E',	n : with_top ℕ,	Z : basic_smooth_bundle_core I M E',	x : Z.to_topological_fiber_bundle_core.total_space	⊢ times_cont_diff_within_at 𝕜 n	    (λ (x_1 : E × E'), ⇑I (⇑(chart_at H x.fst) (⇑((chart_at H x.fst).symm) (⇑(I.symm) x_1.fst))))	    (range ⇑I ×ˢ univ ∩	         ((λ (p : E × E'), (⇑(I.symm) p.fst, p.snd)) ⁻¹' ((chart_at H x.fst).to_local_equiv.target ×ˢ univ) ∩	            (λ (p : E × E'), (⇑(I.symm) p.fst, p.snd)) ⁻¹'	              ((λ (p : H × E'), (⇑((chart_at H x.fst).symm) p.fst, p.snd)) ⁻¹'	                 (Z.to_topological_fiber_bundle_core.local_triv	                    ⟨chart_at H x.fst, _⟩).to_local_homeomorph.to_local_equiv.target)) ∩	       (λ (x_1 : E × E'),	            ⟨(⇑((chart_at H x.fst).symm) (⇑(I.symm) x_1.fst, x_1.snd).fst,	              (⇑(I.symm) x_1.fst, x_1.snd).snd).fst,	             Z.to_topological_fiber_bundle_core.coord_change ⟨chart_at H x.fst, _⟩	               (Z.to_topological_fiber_bundle_core.index_at (⇑((chart_at H x.fst).symm) (⇑(I.symm) x_1.fst)))	               (⇑((chart_at H x.fst).symm) (⇑(I.symm) x_1.fst))	               x_1.snd⟩) ⁻¹'	         (sigma.fst ⁻¹' (chart_at H x.fst).to_local_equiv.source))	    (⇑I (⇑(chart_at H x.fst) x.fst),	     Z.to_topological_fiber_bundle_core.coord_change (Z.to_topological_fiber_bundle_core.index_at x.fst)	       ⟨chart_at H x.fst, _⟩	       x.fst	       x.snd)
2 goals	𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	M : Type u_4,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	Is : smooth_manifold_with_corners I M,	E' : Type u_5,	_inst_7 : normed_group E',	_inst_8 : normed_space 𝕜 E',	n : with_top ℕ,	Z : basic_smooth_bundle_core I M E',	x : Z.to_topological_fiber_bundle_core.total_space	⊢ ∀ (y : E × E'),	    y ∈	      range ⇑I ×ˢ univ ∩	          ((λ (p : E × E'), (⇑(I.symm) p.fst, p.snd)) ⁻¹'	               ((chart_at H x.fst).to_local_equiv.target ×ˢ univ) ∩	             (λ (p : E × E'), (⇑(I.symm) p.fst, p.snd)) ⁻¹'	               ((λ (p : H × E'), (⇑((chart_at H x.fst).symm) p.fst, p.snd)) ⁻¹'	                  (Z.to_topological_fiber_bundle_core.local_triv	                     ⟨chart_at H x.fst, _⟩).to_local_homeomorph.to_local_equiv.target)) ∩	        (λ (x_1 : E × E'),	             ⟨(⇑((chart_at H x.fst).symm) (⇑(I.symm) x_1.fst, x_1.snd).fst,	               (⇑(I.symm) x_1.fst, x_1.snd).snd).fst,	              Z.to_topological_fiber_bundle_core.coord_change ⟨chart_at H x.fst, _⟩	                (Z.to_topological_fiber_bundle_core.index_at (⇑((chart_at H x.fst).symm) (⇑(I.symm) x_1.fst)))	                (⇑((chart_at H x.fst).symm) (⇑(I.symm) x_1.fst))	                x_1.snd⟩) ⁻¹'	          (sigma.fst ⁻¹' (chart_at H x.fst).to_local_equiv.source) →	    ⇑I (⇑(chart_at H x.fst) (⇑((chart_at H x.fst).symm) (⇑(I.symm) y.fst))) = y.fst		𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	M : Type u_4,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	Is : smooth_manifold_with_corners I M,	E' : Type u_5,	_inst_7 : normed_group E',	_inst_8 : normed_space 𝕜 E',	n : with_top ℕ,	Z : basic_smooth_bundle_core I M E',	x : Z.to_topological_fiber_bundle_core.total_space	⊢ ⇑I	      (⇑(chart_at H x.fst)	         (⇑((chart_at H x.fst).symm)	            (⇑(I.symm)	               (⇑I (⇑(chart_at H x.fst) x.fst),	                Z.to_topological_fiber_bundle_core.coord_change (Z.to_topological_fiber_bundle_core.index_at x.fst)	                  ⟨chart_at H x.fst, _⟩	                  x.fst	                  x.snd).fst))) =	    (⇑I (⇑(chart_at H x.fst) x.fst),	     Z.to_topological_fiber_bundle_core.coord_change (Z.to_topological_fiber_bundle_core.index_at x.fst)	       ⟨chart_at H x.fst, _⟩	       x.fst	       x.snd).fst
2 goals	𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	M : Type u_4,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	Is : smooth_manifold_with_corners I M,	E' : Type u_5,	_inst_7 : normed_group E',	_inst_8 : normed_space 𝕜 E',	n : with_top ℕ,	Z : basic_smooth_bundle_core I M E',	x : Z.to_topological_fiber_bundle_core.total_space,	a : E,	b : E',	hab :	  (a, b) ∈	    range ⇑I ×ˢ univ ∩	        ((λ (p : E × E'), (⇑(I.symm) p.fst, p.snd)) ⁻¹' ((chart_at H x.fst).to_local_equiv.target ×ˢ univ) ∩	           (λ (p : E × E'), (⇑(I.symm) p.fst, p.snd)) ⁻¹'	             ((λ (p : H × E'), (⇑((chart_at H x.fst).symm) p.fst, p.snd)) ⁻¹'	                (Z.to_topological_fiber_bundle_core.local_triv	                   ⟨chart_at H x.fst, _⟩).to_local_homeomorph.to_local_equiv.target)) ∩	      (λ (x_1 : E × E'),	           ⟨(⇑((chart_at H x.fst).symm) (⇑(I.symm) x_1.fst, x_1.snd).fst, (⇑(I.symm) x_1.fst, x_1.snd).snd).fst,	            Z.to_topological_fiber_bundle_core.coord_change ⟨chart_at H x.fst, _⟩	              (Z.to_topological_fiber_bundle_core.index_at (⇑((chart_at H x.fst).symm) (⇑(I.symm) x_1.fst)))	              (⇑((chart_at H x.fst).symm) (⇑(I.symm) x_1.fst))	              x_1.snd⟩) ⁻¹'	        (sigma.fst ⁻¹' (chart_at H x.fst).to_local_equiv.source)	⊢ ⇑I (⇑(chart_at H x.fst) (⇑((chart_at H x.fst).symm) (⇑(I.symm) (a, b).fst))) = (a, b).fst		𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	M : Type u_4,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	Is : smooth_manifold_with_corners I M,	E' : Type u_5,	_inst_7 : normed_group E',	_inst_8 : normed_space 𝕜 E',	n : with_top ℕ,	Z : basic_smooth_bundle_core I M E',	x : Z.to_topological_fiber_bundle_core.total_space	⊢ ⇑I	      (⇑(chart_at H x.fst)	         (⇑((chart_at H x.fst).symm)	            (⇑(I.symm)	               (⇑I (⇑(chart_at H x.fst) x.fst),	                Z.to_topological_fiber_bundle_core.coord_change (Z.to_topological_fiber_bundle_core.index_at x.fst)	                  ⟨chart_at H x.fst, _⟩	                  x.fst	                  x.snd).fst))) =	    (⇑I (⇑(chart_at H x.fst) x.fst),	     Z.to_topological_fiber_bundle_core.coord_change (Z.to_topological_fiber_bundle_core.index_at x.fst)	       ⟨chart_at H x.fst, _⟩	       x.fst	       x.snd).fst
2 goals	𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	M : Type u_4,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	Is : smooth_manifold_with_corners I M,	E' : Type u_5,	_inst_7 : normed_group E',	_inst_8 : normed_space 𝕜 E',	n : with_top ℕ,	Z : basic_smooth_bundle_core I M E',	x : Z.to_topological_fiber_bundle_core.total_space,	a : E,	b : E',	hab :	  (a ∈ range ⇑I ∧	       ⇑(I.symm) a ∈ (chart_at H x.fst).to_local_equiv.target ∧	         ⇑((chart_at H x.fst).symm) (⇑(I.symm) a) ∈ (chart_at H x.fst).to_local_equiv.source) ∧	    ⇑((chart_at H x.fst).symm) (⇑(I.symm) a) ∈ (chart_at H x.fst).to_local_equiv.source	⊢ ⇑I (⇑(chart_at H x.fst) (⇑((chart_at H x.fst).symm) (⇑(I.symm) (a, b).fst))) = (a, b).fst		𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	M : Type u_4,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	Is : smooth_manifold_with_corners I M,	E' : Type u_5,	_inst_7 : normed_group E',	_inst_8 : normed_space 𝕜 E',	n : with_top ℕ,	Z : basic_smooth_bundle_core I M E',	x : Z.to_topological_fiber_bundle_core.total_space	⊢ ⇑I	      (⇑(chart_at H x.fst)	         (⇑((chart_at H x.fst).symm)	            (⇑(I.symm)	               (⇑I (⇑(chart_at H x.fst) x.fst),	                Z.to_topological_fiber_bundle_core.coord_change (Z.to_topological_fiber_bundle_core.index_at x.fst)	                  ⟨chart_at H x.fst, _⟩	                  x.fst	                  x.snd).fst))) =	    (⇑I (⇑(chart_at H x.fst) x.fst),	     Z.to_topological_fiber_bundle_core.coord_change (Z.to_topological_fiber_bundle_core.index_at x.fst)	       ⟨chart_at H x.fst, _⟩	       x.fst	       x.snd).fst
𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	M : Type u_4,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	Is : smooth_manifold_with_corners I M,	E' : Type u_5,	_inst_7 : normed_group E',	_inst_8 : normed_space 𝕜 E',	n : with_top ℕ,	Z : basic_smooth_bundle_core I M E',	x : Z.to_topological_fiber_bundle_core.total_space	⊢ ⇑I	      (⇑(chart_at H x.fst)	         (⇑((chart_at H x.fst).symm)	            (⇑(I.symm)	               (⇑I (⇑(chart_at H x.fst) x.fst),	                Z.to_topological_fiber_bundle_core.coord_change (Z.to_topological_fiber_bundle_core.index_at x.fst)	                  ⟨chart_at H x.fst, _⟩	                  x.fst	                  x.snd).fst))) =	    (⇑I (⇑(chart_at H x.fst) x.fst),	     Z.to_topological_fiber_bundle_core.coord_change (Z.to_topological_fiber_bundle_core.index_at x.fst)	       ⟨chart_at H x.fst, _⟩	       x.fst	       x.snd).fst
⊢ ∀ {ι : Type uι} {E : Type uE} [_inst_1 : normed_group E] [_inst_2 : normed_space ℝ E]	  [_inst_3 : finite_dimensional ℝ E] {H : Type uH} [_inst_4 : topological_space H] {I : model_with_corners ℝ E H}	  {M : Type uM} [_inst_5 : topological_space M] [_inst_6 : charted_space H M]	  [_inst_7 : smooth_manifold_with_corners I M] [_inst_8 : t2_space M] [_inst_9 : fintype ι] {s : set M}	  (f : smooth_bump_covering ι I M s) (x : M) (hx : x ∈ s),	    ((continuous_linear_map.fst ℝ E ℝ).comp (continuous_linear_map.proj (f.ind x hx))).comp	        (mfderiv I (model_with_corners_self ℝ (ι → E × ℝ)) ⇑(f.embedding_pi_tangent) x) =	      mfderiv I I ⇑(chart_at H (f.c (f.ind x hx))) x
ι : Type uι,	E : Type uE,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	_inst_3 : finite_dimensional ℝ E,	H : Type uH,	_inst_4 : topological_space H,	I : model_with_corners ℝ E H,	M : Type uM,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	_inst_7 : smooth_manifold_with_corners I M,	_inst_8 : t2_space M,	_inst_9 : fintype ι,	s : set M,	f : smooth_bump_covering ι I M s,	x : M,	hx : x ∈ s	⊢ ((continuous_linear_map.fst ℝ E ℝ).comp (continuous_linear_map.proj (f.ind x hx))).comp	      (mfderiv I (model_with_corners_self ℝ (ι → E × ℝ)) ⇑(f.embedding_pi_tangent) x) =	    mfderiv I I ⇑(chart_at H (f.c (f.ind x hx))) x
ι : Type uι,	E : Type uE,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	_inst_3 : finite_dimensional ℝ E,	H : Type uH,	_inst_4 : topological_space H,	I : model_with_corners ℝ E H,	M : Type uM,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	_inst_7 : smooth_manifold_with_corners I M,	_inst_8 : t2_space M,	_inst_9 : fintype ι,	s : set M,	f : smooth_bump_covering ι I M s,	x : M,	hx : x ∈ s,	L : (Π (i : ι), (λ (_x : ι), E × ℝ) i) →L[ℝ] E :=	  (continuous_linear_map.fst ℝ E ℝ).comp (continuous_linear_map.proj (f.ind x hx))	⊢ L.comp (mfderiv I (model_with_corners_self ℝ (ι → E × ℝ)) ⇑(f.embedding_pi_tangent) x) =	    mfderiv I I ⇑(chart_at H (f.c (f.ind x hx))) x
ι : Type uι,	E : Type uE,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	_inst_3 : finite_dimensional ℝ E,	H : Type uH,	_inst_4 : topological_space H,	I : model_with_corners ℝ E H,	M : Type uM,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	_inst_7 : smooth_manifold_with_corners I M,	_inst_8 : t2_space M,	_inst_9 : fintype ι,	s : set M,	f : smooth_bump_covering ι I M s,	x : M,	hx : x ∈ s,	L : (Π (i : ι), (λ (_x : ι), E × ℝ) i) →L[ℝ] E :=	  (continuous_linear_map.fst ℝ E ℝ).comp (continuous_linear_map.proj (f.ind x hx)),	this :	  has_mfderiv_at I (model_with_corners_self ℝ E) (⇑L ∘ ⇑(f.embedding_pi_tangent)) x	    (L.comp (mfderiv I (model_with_corners_self ℝ (ι → E × ℝ)) ⇑(f.embedding_pi_tangent) x))	⊢ L.comp (mfderiv I (model_with_corners_self ℝ (ι → E × ℝ)) ⇑(f.embedding_pi_tangent) x) =	    mfderiv I I ⇑(chart_at H (f.c (f.ind x hx))) x
ι : Type uι,	E : Type uE,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	_inst_3 : finite_dimensional ℝ E,	H : Type uH,	_inst_4 : topological_space H,	I : model_with_corners ℝ E H,	M : Type uM,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	_inst_7 : smooth_manifold_with_corners I M,	_inst_8 : t2_space M,	_inst_9 : fintype ι,	s : set M,	f : smooth_bump_covering ι I M s,	x : M,	hx : x ∈ s,	L : (Π (i : ι), (λ (_x : ι), E × ℝ) i) →L[ℝ] E :=	  (continuous_linear_map.fst ℝ E ℝ).comp (continuous_linear_map.proj (f.ind x hx)),	this :	  has_mfderiv_at I (model_with_corners_self ℝ E) (⇑L ∘ ⇑(f.embedding_pi_tangent)) x	    (L.comp (mfderiv I (model_with_corners_self ℝ (ι → E × ℝ)) ⇑(f.embedding_pi_tangent) x))	⊢ has_mfderiv_at I (model_with_corners_self ℝ E) (⇑L ∘ ⇑(f.embedding_pi_tangent)) x	    (mfderiv I I ⇑(chart_at H (f.c (f.ind x hx))) x)
ι : Type uι,	E : Type uE,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	_inst_3 : finite_dimensional ℝ E,	H : Type uH,	_inst_4 : topological_space H,	I : model_with_corners ℝ E H,	M : Type uM,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	_inst_7 : smooth_manifold_with_corners I M,	_inst_8 : t2_space M,	_inst_9 : fintype ι,	s : set M,	f : smooth_bump_covering ι I M s,	x : M,	hx : x ∈ s,	L : (Π (i : ι), (λ (_x : ι), E × ℝ) i) →L[ℝ] E :=	  (continuous_linear_map.fst ℝ E ℝ).comp (continuous_linear_map.proj (f.ind x hx)),	this :	  has_mfderiv_at I (model_with_corners_self ℝ E) (⇑L ∘ ⇑(f.embedding_pi_tangent)) x	    (L.comp (mfderiv I (model_with_corners_self ℝ (ι → E × ℝ)) ⇑(f.embedding_pi_tangent) x))	⊢ ⇑L ∘ ⇑(f.embedding_pi_tangent) =ᶠ[nhds x] ⇑(ext_chart_at I (f.c (f.ind x hx)))
ι : Type uι,	E : Type uE,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	_inst_3 : finite_dimensional ℝ E,	H : Type uH,	_inst_4 : topological_space H,	I : model_with_corners ℝ E H,	M : Type uM,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	_inst_7 : smooth_manifold_with_corners I M,	_inst_8 : t2_space M,	_inst_9 : fintype ι,	s : set M,	f : smooth_bump_covering ι I M s,	x : M,	hx : x ∈ s,	L : (Π (i : ι), (λ (_x : ι), E × ℝ) i) →L[ℝ] E :=	  (continuous_linear_map.fst ℝ E ℝ).comp (continuous_linear_map.proj (f.ind x hx)),	this :	  has_mfderiv_at I (model_with_corners_self ℝ E) (⇑L ∘ ⇑(f.embedding_pi_tangent)) x	    (L.comp (mfderiv I (model_with_corners_self ℝ (ι → E × ℝ)) ⇑(f.embedding_pi_tangent) x)),	y : M,	hy : ⇑(⇑f (f.ind x hx)) y = 1 y	⊢ (⇑L ∘ ⇑(f.embedding_pi_tangent)) y = ⇑(ext_chart_at I (f.c (f.ind x hx))) y
ι : Type uι,	E : Type uE,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	_inst_3 : finite_dimensional ℝ E,	H : Type uH,	_inst_4 : topological_space H,	I : model_with_corners ℝ E H,	M : Type uM,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	_inst_7 : smooth_manifold_with_corners I M,	_inst_8 : t2_space M,	_inst_9 : fintype ι,	s : set M,	f : smooth_bump_covering ι I M s,	x : M,	hx : x ∈ s,	L : (Π (i : ι), (λ (_x : ι), E × ℝ) i) →L[ℝ] E :=	  (continuous_linear_map.fst ℝ E ℝ).comp (continuous_linear_map.proj (f.ind x hx)),	this :	  has_mfderiv_at I (model_with_corners_self ℝ E) (⇑L ∘ ⇑(f.embedding_pi_tangent)) x	    (L.comp (mfderiv I (model_with_corners_self ℝ (ι → E × ℝ)) ⇑(f.embedding_pi_tangent) x)),	y : M,	hy : ⇑(⇑f (f.ind x hx)) y = 1 y	⊢ ⇑(⇑f (f.ind x hx)) y • ⇑(ext_chart_at I (f.c (f.ind x hx))) y = ⇑(ext_chart_at I (f.c (f.ind x hx))) y
⊢ ∀ {G : Type u_1} [_inst_1 : group G] {S T : set G},	    S ∈ left_transversals T ↔ ∀ (g : G), ∃! (s : ↥S), (↑s)⁻¹ * g ∈ T
G : Type u_1,	_inst_1 : group G,	S T : set G	⊢ S ∈ left_transversals T ↔ ∀ (g : G), ∃! (s : ↥S), (↑s)⁻¹ * g ∈ T
G : Type u_1,	_inst_1 : group G,	S T : set G	⊢ (∀ (g : G), ∃! (x : ↥S × ↥T), x.fst.val * x.snd.val = g) ↔	    ∀ (g : G), ∃! (s : ↥S), (↑s)⁻¹ * g ∈ T
2 goals	G : Type u_1,	_inst_1 : group G,	S T : set G,	h : ∀ (g : G), ∃! (x : ↥S × ↥T), x.fst.val * x.snd.val = g,	g : G	⊢ ∃! (s : ↥S), (↑s)⁻¹ * g ∈ T		G : Type u_1,	_inst_1 : group G,	S T : set G,	h : ∀ (g : G), ∃! (s : ↥S), (↑s)⁻¹ * g ∈ T,	g : G	⊢ ∃! (x : ↥S × ↥T), x.fst.val * x.snd.val = g
2 goals	G : Type u_1,	_inst_1 : group G,	S T : set G,	h : ∀ (g : G), ∃! (x : ↥S × ↥T), x.fst.val * x.snd.val = g,	g : G,	x : ↥S × ↥T,	h1 : x.fst.val * x.snd.val = g,	h2 : ∀ (y : ↥S × ↥T), (λ (x : ↥S × ↥T), x.fst.val * x.snd.val = g) y → y = x	⊢ ∃! (s : ↥S), (↑s)⁻¹ * g ∈ T		G : Type u_1,	_inst_1 : group G,	S T : set G,	h : ∀ (g : G), ∃! (s : ↥S), (↑s)⁻¹ * g ∈ T,	g : G	⊢ ∃! (x : ↥S × ↥T), x.fst.val * x.snd.val = g
G : Type u_1,	_inst_1 : group G,	S T : set G,	h : ∀ (g : G), ∃! (s : ↥S), (↑s)⁻¹ * g ∈ T,	g : G	⊢ ∃! (x : ↥S × ↥T), x.fst.val * x.snd.val = g
G : Type u_1,	_inst_1 : group G,	S T : set G,	h : ∀ (g : G), ∃! (s : ↥S), (↑s)⁻¹ * g ∈ T,	g : G,	x : ↥S,	h1 : (↑x)⁻¹ * g ∈ T,	h2 : ∀ (y : ↥S), (λ (s : ↥S), (↑s)⁻¹ * g ∈ T) y → y = x	⊢ ∃! (x : ↥S × ↥T), x.fst.val * x.snd.val = g
G : Type u_1,	_inst_1 : group G,	S T : set G,	h : ∀ (g : G), ∃! (s : ↥S), (↑s)⁻¹ * g ∈ T,	g : G,	x : ↥S,	h1 : (↑x)⁻¹ * g ∈ T,	h2 : ∀ (y : ↥S), (λ (s : ↥S), (↑s)⁻¹ * g ∈ T) y → y = x,	y : ↥S × ↥T,	hy : (λ (x : ↥S × ↥T), x.fst.val * x.snd.val = g) y	⊢ y = (x, ⟨(↑x)⁻¹ * g, h1⟩)
G : Type u_1,	_inst_1 : group G,	S T : set G,	h : ∀ (g : G), ∃! (s : ↥S), (↑s)⁻¹ * g ∈ T,	g : G,	x : ↥S,	h1 : (↑x)⁻¹ * g ∈ T,	h2 : ∀ (y : ↥S), (λ (s : ↥S), (↑s)⁻¹ * g ∈ T) y → y = x,	y : ↥S × ↥T,	hy : (λ (x : ↥S × ↥T), x.fst.val * x.snd.val = g) y,	this : y.fst = x	⊢ y = (x, ⟨(↑x)⁻¹ * g, h1⟩)
⊢ ∀ {N : Type u_2} [_inst_2 : add_monoid N] (P : add_submonoid N), P.fg ↔ (⇑add_submonoid.to_submonoid P).fg
N : Type u_2,	_inst_2 : add_monoid N,	P : add_submonoid N	⊢ P.fg ↔ (⇑add_submonoid.to_submonoid P).fg
N : Type u_2,	_inst_2 : add_monoid N,	P : add_submonoid N	⊢ P = ⇑submonoid.to_add_submonoid (⇑add_submonoid.to_submonoid P)
⊢ ∀ {ι : Type u_1} {M : ι → Type u_2} [_inst_1 : Π (i : ι), monoid (M i)] {C : free_product M → Prop}	  (m : free_product M),	    C 1 → (∀ (i : ι) (m : M i), C (⇑of m)) → (∀ (x y : free_product M), C x → C y → C (x * y)) → C m
ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	C : free_product M → Prop,	m : free_product M,	h_one : C 1,	h_of : ∀ (i : ι) (m : M i), C (⇑of m),	h_mul : ∀ (x y : free_product M), C x → C y → C (x * y)	⊢ C m
ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	C : free_product M → Prop,	m : free_product M,	h_one : C 1,	h_of : ∀ (i : ι) (m : M i), C (⇑of m),	h_mul : ∀ (x y : free_product M), C x → C y → C (x * y),	S : submonoid (free_product M) := {carrier := set_of C, one_mem' := h_one, mul_mem' := h_mul}	⊢ C m
ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	C : free_product M → Prop,	m : free_product M,	h_one : C 1,	h_of : ∀ (i : ι) (m : M i), C (⇑of m),	h_mul : ∀ (x y : free_product M), C x → C y → C (x * y),	S : submonoid (free_product M) := {carrier := set_of C, one_mem' := h_one, mul_mem' := h_mul}	⊢ m = ↑(⇑(⇑lift (λ (i : ι), of.cod_mrestrict S _)) m)
ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	C : free_product M → Prop,	m : free_product M,	h_one : C 1,	h_of : ∀ (i : ι) (m : M i), C (⇑of m),	h_mul : ∀ (x y : free_product M), C x → C y → C (x * y),	S : submonoid (free_product M) := {carrier := set_of C, one_mem' := h_one, mul_mem' := h_mul}	⊢ ⇑(monoid_hom.id (free_product M)) m = ⇑(S.subtype.comp (⇑lift (λ (i : ι), of.cod_mrestrict S _))) m
ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	C : free_product M → Prop,	m : free_product M,	h_one : C 1,	h_of : ∀ (i : ι) (m : M i), C (⇑of m),	h_mul : ∀ (x y : free_product M), C x → C y → C (x * y),	S : submonoid (free_product M) := {carrier := set_of C, one_mem' := h_one, mul_mem' := h_mul}	⊢ monoid_hom.id (free_product M) = S.subtype.comp (⇑lift (λ (i : ι), of.cod_mrestrict S _))
ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	C : free_product M → Prop,	m : free_product M,	h_one : C 1,	h_of : ∀ (i : ι) (m : M i), C (⇑of m),	h_mul : ∀ (x y : free_product M), C x → C y → C (x * y),	S : submonoid (free_product M) := {carrier := set_of C, one_mem' := h_one, mul_mem' := h_mul},	i : ι,	x : M i	⊢ ⇑((monoid_hom.id (free_product M)).comp of) x =	    ⇑((S.subtype.comp (⇑lift (λ (i : ι), of.cod_mrestrict S _))).comp of) x
⊢ ∀ {G : Type u_1} [_inst_1 : group G] (H : subgroup G), ⁅⊥,H⁆ = ⊥
G : Type u_1,	_inst_1 : group G,	H : subgroup G	⊢ ⁅⊥,H⁆ = ⊥
G : Type u_1,	_inst_1 : group G,	H : subgroup G	⊢ ⁅⊥,H⁆ ≤ ⊥
⊢ ∀ (α : Type u) (β : Type v) [_inst_1 : group α] [_inst_2 : mul_action α β] [_inst_3 : fintype α]	  [_inst_4 : Π (a : α), fintype ↥(fixed_by α β a)] [_inst_5 : fintype (quotient (orbit_rel α β))],	    finset.univ.sum (λ (a : α), fintype.card ↥(fixed_by α β a)) =	      fintype.card (quotient (orbit_rel α β)) * fintype.card α
α : Type u,	β : Type v,	_inst_1 : group α,	_inst_2 : mul_action α β,	_inst_3 : fintype α,	_inst_4 : Π (a : α), fintype ↥(fixed_by α β a),	_inst_5 : fintype (quotient (orbit_rel α β))	⊢ finset.univ.sum (λ (a : α), fintype.card ↥(fixed_by α β a)) =	    fintype.card (quotient (orbit_rel α β)) * fintype.card α
⊢ ∀ {M : Type u_1} {N : Type u_2} {α : Type u_6} {β : Type u_7} [_inst_1 : has_scalar M α]	  [_inst_2 : has_scalar β α] [_inst_3 : smul_comm_class M β α] (g : N → M), smul_comm_class N β α
M : Type u_1,	N : Type u_2,	α : Type u_6,	β : Type u_7,	_inst_1 : has_scalar M α,	_inst_2 : has_scalar β α,	_inst_3 : smul_comm_class M β α,	g : N → M	⊢ smul_comm_class N β α
⊢ ∀ {S : Type u'} {R : Type u} {M : Type v} [_inst_1 : monoid R] [_inst_2 : mul_action R M]	  [_inst_3 : has_scalar S R] [_inst_4 : has_scalar S M] [_inst_5 : is_scalar_tower S R M] (p : sub_mul_action R M)	  (s : S) {x : M}, x ∈ p → s • x ∈ p
S : Type u',	R : Type u,	M : Type v,	_inst_1 : monoid R,	_inst_2 : mul_action R M,	_inst_3 : has_scalar S R,	_inst_4 : has_scalar S M,	_inst_5 : is_scalar_tower S R M,	p : sub_mul_action R M,	s : S,	x : M,	h : x ∈ p	⊢ s • x ∈ p
S : Type u',	R : Type u,	M : Type v,	_inst_1 : monoid R,	_inst_2 : mul_action R M,	_inst_3 : has_scalar S R,	_inst_4 : has_scalar S M,	_inst_5 : is_scalar_tower S R M,	p : sub_mul_action R M,	s : S,	x : M,	h : x ∈ p	⊢ (s • 1) • x ∈ p
⊢ ∀ {M : Type u_1} [_inst_1 : comm_monoid M] {S : submonoid M} {x y : M × ↥S},	    ⇑(r S) x y ↔ ∃ (c : ↥S), x.fst * ↑(y.snd) * ↑c = y.fst * ↑(x.snd) * ↑c
M : Type u_1,	_inst_1 : comm_monoid M,	S : submonoid M,	x y : M × ↥S	⊢ ⇑(r S) x y ↔ ∃ (c : ↥S), x.fst * ↑(y.snd) * ↑c = y.fst * ↑(x.snd) * ↑c
M : Type u_1,	_inst_1 : comm_monoid M,	S : submonoid M,	x y : M × ↥S	⊢ ⇑(r' S) x y ↔ ∃ (c : ↥S), x.fst * ↑(y.snd) * ↑c = y.fst * ↑(x.snd) * ↑c
⊢ ∀ {p : ℕ} {G : Type u_1} [_inst_1 : group G] {H K : subgroup G},	    is_p_group p ↥H → is_p_group p ↥K → ∀ [_inst_2 : K.normal], is_p_group p ↥(H ⊔ K)
p : ℕ,	G : Type u_1,	_inst_1 : group G,	H K : subgroup G,	hH : is_p_group p ↥H,	hK : is_p_group p ↥K,	_inst_2 : K.normal	⊢ is_p_group p ↥(H ⊔ K)
p : ℕ,	G : Type u_1,	_inst_1 : group G,	H K : subgroup G,	hH : is_p_group p ↥H,	hK : is_p_group p ↥K,	_inst_2 : K.normal,	g : ↥(H ⊔ K)	⊢ ∃ (k : ℕ), g ^ p ^ k = 1
p : ℕ,	G : Type u_1,	_inst_1 : group G,	H K : subgroup G,	hH : is_p_group p ↥H,	hK : is_p_group p ↥K,	_inst_2 : K.normal,	g : ↥(H ⊔ K),	j : ℕ,	hj : ↑g ^ p ^ j = 1	⊢ ∃ (k : ℕ), g ^ p ^ k = 1
p : ℕ,	G : Type u_1,	_inst_1 : group G,	H K : subgroup G,	hH : is_p_group p ↥H,	hK : is_p_group p ↥K,	_inst_2 : K.normal,	g : ↥(H ⊔ K),	j : ℕ,	hj : ↑g ^ p ^ j = 1,	k : ℕ,	hk : ⟨↑g ^ p ^ j, _⟩ ^ p ^ k = 1	⊢ ∃ (k : ℕ), g ^ p ^ k = 1
p : ℕ,	G : Type u_1,	_inst_1 : group G,	H K : subgroup G,	hH : is_p_group p ↥H,	hK : is_p_group p ↥K,	_inst_2 : K.normal,	g : ↥(H ⊔ K),	j : ℕ,	hj : ↑g ^ p ^ j = 1,	k : ℕ,	hk : ↑g ^ p ^ (j + k) = ↑1	⊢ ∃ (k : ℕ), g ^ p ^ k = 1
⊢ ∀ {α : Type u_1} [_inst_1 : decidable_eq α] (s : cycle α) (h : s.nodup) (x : α),	    x ∉ s → ⇑(s.form_perm h) x = x
α : Type u_1,	_inst_1 : decidable_eq α,	s : cycle α,	h : s.nodup,	x : α,	hx : x ∉ s	⊢ ⇑(s.form_perm h) x = x
α : Type u_1,	_inst_1 : decidable_eq α,	x : α,	s : list α,	h : nodup (quot.mk setoid.r s),	hx : x ∉ quot.mk setoid.r s	⊢ ⇑(form_perm (quot.mk setoid.r s) h) x = x
⊢ ∀ {α : Type u_1} [_inst_1 : decidable_eq α] [_inst_2 : fintype α] {σ τ : perm α}	  (f : {x // x ∈ ↑(σ.support)} ≃ {x // x ∈ ↑(τ.support)}),	    (∀ (x : α) (hx : x ∈ ↑(σ.support)), ↑(⇑f ⟨⇑σ x, _⟩) = ⇑τ ↑(⇑f ⟨x, hx⟩)) →	    is_conj σ τ
α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	σ τ : perm α,	f : {x // x ∈ ↑(σ.support)} ≃ {x // x ∈ ↑(τ.support)},	hf : ∀ (x : α) (hx : x ∈ ↑(σ.support)), ↑(⇑f ⟨⇑σ x, _⟩) = ⇑τ ↑(⇑f ⟨x, hx⟩)	⊢ is_conj σ τ
α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	σ τ : perm α,	f : {x // x ∈ ↑(σ.support)} ≃ {x // x ∈ ↑(τ.support)},	hf : ∀ (x : α) (hx : x ∈ ↑(σ.support)), ↑(⇑f ⟨⇑σ x, _⟩) = ⇑τ ↑(⇑f ⟨x, hx⟩)	⊢ f.extend_subtype * σ * (f.extend_subtype)⁻¹ = τ
α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	σ τ : perm α,	f : {x // x ∈ ↑(σ.support)} ≃ {x // x ∈ ↑(τ.support)},	hf : ∀ (x : α) (hx : x ∈ ↑(σ.support)), ↑(⇑f ⟨⇑σ x, _⟩) = ⇑τ ↑(⇑f ⟨x, hx⟩)	⊢ f.extend_subtype * σ = τ * f.extend_subtype
α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	σ τ : perm α,	f : {x // x ∈ ↑(σ.support)} ≃ {x // x ∈ ↑(τ.support)},	hf : ∀ (x : α) (hx : x ∈ ↑(σ.support)), ↑(⇑f ⟨⇑σ x, _⟩) = ⇑τ ↑(⇑f ⟨x, hx⟩),	x : α	⊢ ⇑(f.extend_subtype * σ) x = ⇑(τ * f.extend_subtype) x
α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	σ τ : perm α,	f : {x // x ∈ ↑(σ.support)} ≃ {x // x ∈ ↑(τ.support)},	hf : ∀ (x : α) (hx : x ∈ ↑(σ.support)), ↑(⇑f ⟨⇑σ x, _⟩) = ⇑τ ↑(⇑f ⟨x, hx⟩),	x : α	⊢ ⇑(f.extend_subtype) (⇑σ x) = ⇑τ (⇑(f.extend_subtype) x)
2 goals	α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	σ τ : perm α,	f : {x // x ∈ ↑(σ.support)} ≃ {x // x ∈ ↑(τ.support)},	hf : ∀ (x : α) (hx : x ∈ ↑(σ.support)), ↑(⇑f ⟨⇑σ x, _⟩) = ⇑τ ↑(⇑f ⟨x, hx⟩),	x : α,	hx : x ∈ σ.support	⊢ ⇑(f.extend_subtype) (⇑σ x) = ⇑τ (⇑(f.extend_subtype) x)		α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	σ τ : perm α,	f : {x // x ∈ ↑(σ.support)} ≃ {x // x ∈ ↑(τ.support)},	hf : ∀ (x : α) (hx : x ∈ ↑(σ.support)), ↑(⇑f ⟨⇑σ x, _⟩) = ⇑τ ↑(⇑f ⟨x, hx⟩),	x : α,	hx : x ∉ σ.support	⊢ ⇑(f.extend_subtype) (⇑σ x) = ⇑τ (⇑(f.extend_subtype) x)
4 goals	α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	σ τ : perm α,	f : {x // x ∈ ↑(σ.support)} ≃ {x // x ∈ ↑(τ.support)},	hf : ∀ (x : α) (hx : x ∈ ↑(σ.support)), ↑(⇑f ⟨⇑σ x, _⟩) = ⇑τ ↑(⇑f ⟨x, hx⟩),	x : α,	hx : x ∈ σ.support	⊢ ↑(⇑f ⟨⇑σ x, ?m_1⟩) = ⇑τ ↑(⇑f ⟨x, ?m_2⟩)		α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	σ τ : perm α,	f : {x // x ∈ ↑(σ.support)} ≃ {x // x ∈ ↑(τ.support)},	hf : ∀ (x : α) (hx : x ∈ ↑(σ.support)), ↑(⇑f ⟨⇑σ x, _⟩) = ⇑τ ↑(⇑f ⟨x, hx⟩),	x : α,	hx : x ∈ σ.support	⊢ x ∈ ↑(σ.support)		α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	σ τ : perm α,	f : {x // x ∈ ↑(σ.support)} ≃ {x // x ∈ ↑(τ.support)},	hf : ∀ (x : α) (hx : x ∈ ↑(σ.support)), ↑(⇑f ⟨⇑σ x, _⟩) = ⇑τ ↑(⇑f ⟨x, hx⟩),	x : α,	hx : x ∈ σ.support	⊢ ⇑σ x ∈ ↑(σ.support)		α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	σ τ : perm α,	f : {x // x ∈ ↑(σ.support)} ≃ {x // x ∈ ↑(τ.support)},	hf : ∀ (x : α) (hx : x ∈ ↑(σ.support)), ↑(⇑f ⟨⇑σ x, _⟩) = ⇑τ ↑(⇑f ⟨x, hx⟩),	x : α,	hx : x ∉ σ.support	⊢ ⇑(f.extend_subtype) (⇑σ x) = ⇑τ (⇑(f.extend_subtype) x)
α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	σ τ : perm α,	f : {x // x ∈ ↑(σ.support)} ≃ {x // x ∈ ↑(τ.support)},	hf : ∀ (x : α) (hx : x ∈ ↑(σ.support)), ↑(⇑f ⟨⇑σ x, _⟩) = ⇑τ ↑(⇑f ⟨x, hx⟩),	x : α,	hx : x ∉ σ.support	⊢ ⇑(f.extend_subtype) (⇑σ x) = ⇑τ (⇑(f.extend_subtype) x)
⊢ ∀ {β : Type u_2} [_inst_2 : fintype β] {f : perm β} {x y : β},	    f.same_cycle x y → (∃ (i : ℕ) (hpos : 0 < i) (h : i ≤ order_of f), ⇑(f ^ i) x = y)
β : Type u_2,	_inst_2 : fintype β,	f : perm β,	x y : β,	h : f.same_cycle x y	⊢ ∃ (i : ℕ) (hpos : 0 < i) (h : i ≤ order_of f), ⇑(f ^ i) x = y
β : Type u_2,	_inst_2 : fintype β,	f : perm β,	x y : β,	h : f.same_cycle x y,	_inst : Π (a : Prop), decidable a	⊢ ∃ (i : ℕ) (hpos : 0 < i) (h : i ≤ order_of f), ⇑(f ^ i) x = y
2 goals	β : Type u_2,	_inst_2 : fintype β,	f : perm β,	x : β,	_inst : Π (a : Prop), decidable a,	hi : 0 < order_of f,	h : f.same_cycle x (⇑(f ^ 0) x)	⊢ ∃ (i : ℕ) (hpos : 0 < i) (h : i ≤ order_of f), ⇑(f ^ i) x = ⇑(f ^ 0) x		β : Type u_2,	_inst_2 : fintype β,	f : perm β,	x : β,	_inst : Π (a : Prop), decidable a,	i : ℕ,	hi : i.succ < order_of f,	h : f.same_cycle x (⇑(f ^ i.succ) x)	⊢ ∃ (i_1 : ℕ) (hpos : 0 < i_1) (h : i_1 ≤ order_of f), ⇑(f ^ i_1) x = ⇑(f ^ i.succ) x
2 goals	β : Type u_2,	_inst_2 : fintype β,	f : perm β,	x : β,	_inst : Π (a : Prop), decidable a,	hi : 0 < order_of f,	h : f.same_cycle x (⇑(f ^ 0) x)	⊢ ⇑(f ^ order_of f) x = ⇑(f ^ 0) x		β : Type u_2,	_inst_2 : fintype β,	f : perm β,	x : β,	_inst : Π (a : Prop), decidable a,	i : ℕ,	hi : i.succ < order_of f,	h : f.same_cycle x (⇑(f ^ i.succ) x)	⊢ ∃ (i_1 : ℕ) (hpos : 0 < i_1) (h : i_1 ≤ order_of f), ⇑(f ^ i_1) x = ⇑(f ^ i.succ) x
β : Type u_2,	_inst_2 : fintype β,	f : perm β,	x : β,	_inst : Π (a : Prop), decidable a,	i : ℕ,	hi : i.succ < order_of f,	h : f.same_cycle x (⇑(f ^ i.succ) x)	⊢ ∃ (i_1 : ℕ) (hpos : 0 < i_1) (h : i_1 ≤ order_of f), ⇑(f ^ i_1) x = ⇑(f ^ i.succ) x
⊢ ∀ {α : Type u_1} [_inst_1 : decidable_eq α] [_inst_2 : fintype α] {f : perm α} {x y : α},	    y ∈ (f.cycle_of x).support ↔ f.same_cycle x y ∧ x ∈ f.support
α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α,	x y : α	⊢ y ∈ (f.cycle_of x).support ↔ f.same_cycle x y ∧ x ∈ f.support
2 goals	α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α,	x y : α,	hx : ⇑f x = x	⊢ y ∈ (f.cycle_of x).support ↔ f.same_cycle x y ∧ x ∈ f.support		α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α,	x y : α,	hx : ¬⇑f x = x	⊢ y ∈ (f.cycle_of x).support ↔ f.same_cycle x y ∧ x ∈ f.support
2 goals	α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α,	x y : α,	hx : ⇑f x = x	⊢ y ∈ 1.support ↔ f.same_cycle x y ∧ x ∈ f.support		α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α,	x y : α,	hx : ¬⇑f x = x	⊢ y ∈ (f.cycle_of x).support ↔ f.same_cycle x y ∧ x ∈ f.support
α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α,	x y : α,	hx : ¬⇑f x = x	⊢ y ∈ (f.cycle_of x).support ↔ f.same_cycle x y ∧ x ∈ f.support
α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α,	x y : α,	hx : ¬⇑f x = x	⊢ ite (f.same_cycle x y) (⇑f y) y ≠ y ↔ f.same_cycle x y ∧ x ∈ f.support
2 goals	α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α,	x y : α,	hx : ¬⇑f x = x,	hy : f.same_cycle x y	⊢ ⇑f y ≠ y ↔ f.same_cycle x y ∧ x ∈ f.support		α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α,	x y : α,	hx : ¬⇑f x = x,	hy : ¬f.same_cycle x y	⊢ y ≠ y ↔ f.same_cycle x y ∧ x ∈ f.support
2 goals	α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α,	x y : α,	hx : ¬⇑f x = x,	hy : f.same_cycle x y	⊢ ¬⇑f y = y		α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α,	x y : α,	hx : ¬⇑f x = x,	hy : ¬f.same_cycle x y	⊢ y ≠ y ↔ f.same_cycle x y ∧ x ∈ f.support
2 goals	α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α,	x : α,	hx : ¬⇑f x = x,	k : ℤ	⊢ ¬⇑f (⇑(f ^ k) x) = ⇑(f ^ k) x		α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α,	x y : α,	hx : ¬⇑f x = x,	hy : ¬f.same_cycle x y	⊢ y ≠ y ↔ f.same_cycle x y ∧ x ∈ f.support
2 goals	α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α,	x : α,	hx : ¬⇑f x = x,	k : ℤ	⊢ ¬⇑(f ^ k) x ∉ f.support		α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α,	x y : α,	hx : ¬⇑f x = x,	hy : ¬f.same_cycle x y	⊢ y ≠ y ↔ f.same_cycle x y ∧ x ∈ f.support
α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α,	x y : α,	hx : ¬⇑f x = x,	hy : ¬f.same_cycle x y	⊢ y ≠ y ↔ f.same_cycle x y ∧ x ∈ f.support
⊢ ∀ {n : ℕ}, 2 ≤ n → (fin_rotate n).cycle_type = {n}
n : ℕ,	h : 2 ≤ n	⊢ (fin_rotate n).cycle_type = {n}
m : ℕ,	h : 2 ≤ 2 + m	⊢ (fin_rotate (2 + m)).cycle_type = {2 + m}
⊢ ∀ {n : ℕ} (i : fin (n + 1)) (j : fin n), ⇑(i.cycle_range) (⇑(i.succ_above) j) = j.succ
n : ℕ,	i : fin (n + 1),	j : fin n	⊢ ⇑(i.cycle_range) (⇑(i.succ_above) j) = j.succ
2 goals	case or.inl	n : ℕ,	i : fin (n + 1),	j : fin n,	h : ⇑cast_succ j < i	⊢ ⇑(i.cycle_range) (⇑(i.succ_above) j) = j.succ		case or.inr	n : ℕ,	i : fin (n + 1),	j : fin n,	h : ⇑cast_succ j ≥ i	⊢ ⇑(i.cycle_range) (⇑(i.succ_above) j) = j.succ
case or.inr	n : ℕ,	i : fin (n + 1),	j : fin n,	h : ⇑cast_succ j ≥ i	⊢ ⇑(i.cycle_range) (⇑(i.succ_above) j) = j.succ
⊢ ∀ (n : ℕ), ⇑sign (fin_rotate (n + 1)) = (-1) ^ n
n : ℕ	⊢ ⇑sign (fin_rotate (n + 1)) = (-1) ^ n
2 goals	case nat.zero	⊢ ⇑sign (fin_rotate (0 + 1)) = (-1) ^ 0		case nat.succ	n : ℕ,	ih : ⇑sign (fin_rotate (n + 1)) = (-1) ^ n	⊢ ⇑sign (fin_rotate (n.succ + 1)) = (-1) ^ n.succ
case nat.succ	n : ℕ,	ih : ⇑sign (fin_rotate (n + 1)) = (-1) ^ n	⊢ ⇑sign (fin_rotate (n.succ + 1)) = (-1) ^ n.succ
case nat.succ	n : ℕ,	ih : ⇑sign (fin_rotate (n + 1)) = (-1) ^ n	⊢ ⇑sign (⇑(decompose_fin.symm) (1, fin_rotate n.succ)) = (-1) ^ n.succ
⊢ ∀ {α : Type u_1} [_inst_1 : decidable_eq α] [_inst_2 : fintype α] {f g : perm α},	    f.disjoint g ↔ disjoint f.support g.support
α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f g : perm α	⊢ f.disjoint g ↔ disjoint f.support g.support
⊢ ∀ {G : Type u_1} {G' : Type u_2} [_inst_1 : group G] [_inst_2 : group G'] {f : G →* G'},	    function.injective ⇑f → ∀ [h : is_solvable G'], is_solvable G
G : Type u_1,	G' : Type u_2,	_inst_1 : group G,	_inst_2 : group G',	f : G →* G',	hf : function.injective ⇑f,	h : is_solvable G'	⊢ is_solvable G
G : Type u_1,	G' : Type u_2,	_inst_1 : group G,	_inst_2 : group G',	f : G →* G',	hf : function.injective ⇑f,	h : ∃ (n : ℕ), derived_series G' n = ⊥	⊢ ∃ (n : ℕ), derived_series G n = ⊥
G : Type u_1,	G' : Type u_2,	_inst_1 : group G,	_inst_2 : group G',	f : G →* G',	hf : function.injective ⇑f,	n : ℕ,	hn : derived_series G' n = ⊥	⊢ ∃ (n : ℕ), derived_series G n = ⊥
G : Type u_1,	G' : Type u_2,	_inst_1 : group G,	_inst_2 : group G',	f : G →* G',	hf : function.injective ⇑f,	n : ℕ,	hn : derived_series G' n = ⊥	⊢ derived_series G n = ⊥
G : Type u_1,	G' : Type u_2,	_inst_1 : group G,	_inst_2 : group G',	f : G →* G',	hf : function.injective ⇑f,	n : ℕ,	hn : derived_series G' n = ⊥	⊢ map f (derived_series G n) = ⊥
G : Type u_1,	G' : Type u_2,	_inst_1 : group G,	_inst_2 : group G',	f : G →* G',	hf : function.injective ⇑f,	n : ℕ,	hn : derived_series G' n ≤ ⊥	⊢ map f (derived_series G n) ≤ ⊥
⊢ ∀ {G : Type u_1} [_inst_1 : group G] (H : subgroup G), H = ⊥ ↔ ∀ (x : G), x ∈ H → x = 1
G : Type u_1,	_inst_1 : group G,	H : subgroup G	⊢ H = ⊥ ↔ ∀ (x : G), x ∈ H → x = 1
G : Type u_1,	_inst_1 : group G,	H : subgroup G	⊢ ↑H = ↑⊥ ↔ ∀ (x : G), x ∈ H → x = 1
⊢ ∀ {R : Type u_3} [_inst_1 : non_assoc_semiring R] (S : submonoid R) {a b : R},	    a ∈ add_submonoid.closure ↑S → b ∈ add_submonoid.closure ↑S → a * b ∈ add_submonoid.closure ↑S
R : Type u_3,	_inst_1 : non_assoc_semiring R,	S : submonoid R,	a b : R,	ha : a ∈ add_submonoid.closure ↑S,	hb : b ∈ add_submonoid.closure ↑S	⊢ a * b ∈ add_submonoid.closure ↑S
R : Type u_3,	_inst_1 : non_assoc_semiring R,	S : submonoid R,	b : R,	hb : b ∈ add_submonoid.closure ↑S	⊢ ∀ {a : R}, a ∈ add_submonoid.closure ↑S → a * b ∈ add_submonoid.closure ↑S
3 goals	R : Type u_3,	_inst_1 : non_assoc_semiring R,	S : submonoid R,	b : R,	hb : b ∈ add_submonoid.closure ↑S	⊢ ∀ (x : R), x ∈ ↑S → ∀ {a : R}, a ∈ add_submonoid.closure ↑S → a * x ∈ add_submonoid.closure ↑S		R : Type u_3,	_inst_1 : non_assoc_semiring R,	S : submonoid R,	b : R,	hb : b ∈ add_submonoid.closure ↑S	⊢ ∀ {a : R}, a ∈ add_submonoid.closure ↑S → a * 0 ∈ add_submonoid.closure ↑S		R : Type u_3,	_inst_1 : non_assoc_semiring R,	S : submonoid R,	b : R,	hb : b ∈ add_submonoid.closure ↑S	⊢ ∀ (x y : R),	    (∀ {a : R}, a ∈ add_submonoid.closure ↑S → a * x ∈ add_submonoid.closure ↑S) →	    (∀ {a : R}, a ∈ add_submonoid.closure ↑S → a * y ∈ add_submonoid.closure ↑S) →	    ∀ {a : R}, a ∈ add_submonoid.closure ↑S → a * (x + y) ∈ add_submonoid.closure ↑S
3 goals	R : Type u_3,	_inst_1 : non_assoc_semiring R,	S : submonoid R	⊢ ∀ (x : R), x ∈ ↑S → ∀ {a : R}, a ∈ add_submonoid.closure ↑S → a * x ∈ add_submonoid.closure ↑S		R : Type u_3,	_inst_1 : non_assoc_semiring R,	S : submonoid R,	b : R,	hb : b ∈ add_submonoid.closure ↑S	⊢ ∀ {a : R}, a ∈ add_submonoid.closure ↑S → a * 0 ∈ add_submonoid.closure ↑S		R : Type u_3,	_inst_1 : non_assoc_semiring R,	S : submonoid R,	b : R,	hb : b ∈ add_submonoid.closure ↑S	⊢ ∀ (x y : R),	    (∀ {a : R}, a ∈ add_submonoid.closure ↑S → a * x ∈ add_submonoid.closure ↑S) →	    (∀ {a : R}, a ∈ add_submonoid.closure ↑S → a * y ∈ add_submonoid.closure ↑S) →	    ∀ {a : R}, a ∈ add_submonoid.closure ↑S → a * (x + y) ∈ add_submonoid.closure ↑S
2 goals	R : Type u_3,	_inst_1 : non_assoc_semiring R,	S : submonoid R,	b : R,	hb : b ∈ add_submonoid.closure ↑S	⊢ ∀ {a : R}, a ∈ add_submonoid.closure ↑S → a * 0 ∈ add_submonoid.closure ↑S		R : Type u_3,	_inst_1 : non_assoc_semiring R,	S : submonoid R,	b : R,	hb : b ∈ add_submonoid.closure ↑S	⊢ ∀ (x y : R),	    (∀ {a : R}, a ∈ add_submonoid.closure ↑S → a * x ∈ add_submonoid.closure ↑S) →	    (∀ {a : R}, a ∈ add_submonoid.closure ↑S → a * y ∈ add_submonoid.closure ↑S) →	    ∀ {a : R}, a ∈ add_submonoid.closure ↑S → a * (x + y) ∈ add_submonoid.closure ↑S
2 goals	R : Type u_3,	_inst_1 : non_assoc_semiring R,	S : submonoid R	⊢ ∀ {a : R}, a ∈ add_submonoid.closure ↑S → a * 0 ∈ add_submonoid.closure ↑S		R : Type u_3,	_inst_1 : non_assoc_semiring R,	S : submonoid R,	b : R,	hb : b ∈ add_submonoid.closure ↑S	⊢ ∀ (x y : R),	    (∀ {a : R}, a ∈ add_submonoid.closure ↑S → a * x ∈ add_submonoid.closure ↑S) →	    (∀ {a : R}, a ∈ add_submonoid.closure ↑S → a * y ∈ add_submonoid.closure ↑S) →	    ∀ {a : R}, a ∈ add_submonoid.closure ↑S → a * (x + y) ∈ add_submonoid.closure ↑S
R : Type u_3,	_inst_1 : non_assoc_semiring R,	S : submonoid R,	b : R,	hb : b ∈ add_submonoid.closure ↑S	⊢ ∀ (x y : R),	    (∀ {a : R}, a ∈ add_submonoid.closure ↑S → a * x ∈ add_submonoid.closure ↑S) →	    (∀ {a : R}, a ∈ add_submonoid.closure ↑S → a * y ∈ add_submonoid.closure ↑S) →	    ∀ {a : R}, a ∈ add_submonoid.closure ↑S → a * (x + y) ∈ add_submonoid.closure ↑S
R : Type u_3,	_inst_1 : non_assoc_semiring R,	S : submonoid R	⊢ ∀ (x y : R),	    (∀ {a : R}, a ∈ add_submonoid.closure ↑S → a * x ∈ add_submonoid.closure ↑S) →	    (∀ {a : R}, a ∈ add_submonoid.closure ↑S → a * y ∈ add_submonoid.closure ↑S) →	    ∀ {a : R}, a ∈ add_submonoid.closure ↑S → a * (x + y) ∈ add_submonoid.closure ↑S
R : Type u_3,	_inst_1 : non_assoc_semiring R,	S : submonoid R	⊢ ∀ (x y : R),	    (∀ {a : R}, a ∈ add_submonoid.closure ↑S → a * x ∈ add_submonoid.closure ↑S) →	    (∀ {a : R}, a ∈ add_submonoid.closure ↑S → a * y ∈ add_submonoid.closure ↑S) →	    ∀ {a : R}, a ∈ add_submonoid.closure ↑S → a * x + a * y ∈ add_submonoid.closure ↑S
⊢ ∀ {M : Type u_1} [_inst_2 : comm_monoid M] (S : submonoid M) (m : multiset M),	    (∀ (a : M), a ∈ m → a ∈ S) → m.prod ∈ S
M : Type u_1,	_inst_2 : comm_monoid M,	S : submonoid M,	m : multiset M,	hm : ∀ (a : M), a ∈ m → a ∈ S	⊢ m.prod ∈ S
M : Type u_1,	_inst_2 : comm_monoid M,	S : submonoid M,	m : multiset ↥S	⊢ (multiset.map coe m).prod ∈ S
M : Type u_1,	_inst_2 : comm_monoid M,	S : submonoid M,	m : multiset ↥S	⊢ ↑(m.prod) ∈ S
⊢ ∀ {k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} [_inst_1 : comm_ring k] [_inst_2 : add_comm_group V1]	  [_inst_3 : module k V1] [_inst_4 : add_torsor V1 P1] (c : P1) (r₁ r₂ : k),	    homothety c (r₁ + r₂) = r₁ • (id k P1 -ᵥ const k P1 c) +ᵥ homothety c r₂
k : Type u_1,	V1 : Type u_2,	P1 : Type u_3,	_inst_1 : comm_ring k,	_inst_2 : add_comm_group V1,	_inst_3 : module k V1,	_inst_4 : add_torsor V1 P1,	c : P1,	r₁ r₂ : k	⊢ homothety c (r₁ + r₂) = r₁ • (id k P1 -ᵥ const k P1 c) +ᵥ homothety c r₂
⊢ ∀ (k : Type u_1) (V : Type u_2) (P : Type u_3) [_inst_1 : ring k] [_inst_2 : add_comm_group V]	  [_inst_3 : module k V] [S : add_torsor V P] {s : set P}, affine_span k s = ⊤ → s.nonempty
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	S : add_torsor V P,	s : set P,	h : affine_span k s = ⊤	⊢ s.nonempty
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	S : add_torsor V P,	s : set P,	h : affine_span k s = ⊤	⊢ s ≠ ∅
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	S : add_torsor V P,	h : affine_span k ∅ = ⊤	⊢ false
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	S : add_torsor V P,	h : ⊥ = ⊤	⊢ false
⊢ ∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [_inst_1 : ring k] [_inst_2 : add_comm_group V]	  [_inst_3 : module k V] [S : add_torsor V P] {s1 s2 : affine_subspace k P},	    ↑s1.nonempty → ↑s2.nonempty → s1.direction ⊔ s2.direction = ⊤ → (↑s1 ∩ ↑s2).nonempty
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	S : add_torsor V P,	s1 s2 : affine_subspace k P,	h1 : ↑s1.nonempty,	h2 : ↑s2.nonempty,	hd : s1.direction ⊔ s2.direction = ⊤	⊢ (↑s1 ∩ ↑s2).nonempty
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	S : add_torsor V P,	s1 s2 : affine_subspace k P,	h1 : ↑s1.nonempty,	h2 : ↑s2.nonempty,	hd : s1.direction ⊔ s2.direction = ⊤,	h : ¬(↑s1 ∩ ↑s2).nonempty	⊢ false
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	S : add_torsor V P,	s1 s2 : affine_subspace k P,	h1 : ↑s1.nonempty,	h2 : ↑s2.nonempty,	hd : s1.direction ⊔ s2.direction = ⊤,	h : ↑s1 ∩ ↑s2 = ∅	⊢ false
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	S : add_torsor V P,	s1 s2 : affine_subspace k P,	h1 : ↑s1.nonempty,	h2 : ↑s2.nonempty,	hd : s1.direction ⊔ s2.direction = ⊤,	h : ↑s1 ∩ ↑s2 = ∅,	hlt : s1.direction ⊔ s2.direction < (s1 ⊔ s2).direction	⊢ false
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	S : add_torsor V P,	s1 s2 : affine_subspace k P,	h1 : ↑s1.nonempty,	h2 : ↑s2.nonempty,	hd : s1.direction ⊔ s2.direction = ⊤,	h : ↑s1 ∩ ↑s2 = ∅,	hlt : ⊤ < (s1 ⊔ s2).direction	⊢ false
⊢ ∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [_inst_1 : ring k] [_inst_2 : add_comm_group V]	  [_inst_3 : module k V] [S : add_torsor V P] {s1 s2 : affine_subspace k P},	    ↑s1.nonempty → ↑s2.nonempty → is_compl s1.direction s2.direction → (∃ (p : P), ↑s1 ∩ ↑s2 = {p})
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	S : add_torsor V P,	s1 s2 : affine_subspace k P,	h1 : ↑s1.nonempty,	h2 : ↑s2.nonempty,	hd : is_compl s1.direction s2.direction	⊢ ∃ (p : P), ↑s1 ∩ ↑s2 = {p}
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	S : add_torsor V P,	s1 s2 : affine_subspace k P,	h1 : ↑s1.nonempty,	h2 : ↑s2.nonempty,	hd : is_compl s1.direction s2.direction,	p : P,	hp : p ∈ ↑s1 ∩ ↑s2	⊢ ∃ (p : P), ↑s1 ∩ ↑s2 = {p}
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	S : add_torsor V P,	s1 s2 : affine_subspace k P,	h1 : ↑s1.nonempty,	h2 : ↑s2.nonempty,	hd : is_compl s1.direction s2.direction,	p : P,	hp : p ∈ ↑s1 ∩ ↑s2	⊢ ↑s1 ∩ ↑s2 = {p}
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	S : add_torsor V P,	s1 s2 : affine_subspace k P,	h1 : ↑s1.nonempty,	h2 : ↑s2.nonempty,	hd : is_compl s1.direction s2.direction,	p : P,	hp : p ∈ ↑s1 ∩ ↑s2,	q : P	⊢ q ∈ ↑s1 ∩ ↑s2 ↔ q ∈ {p}
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	S : add_torsor V P,	s1 s2 : affine_subspace k P,	h1 : ↑s1.nonempty,	h2 : ↑s2.nonempty,	hd : is_compl s1.direction s2.direction,	p : P,	hp : p ∈ ↑s1 ∩ ↑s2,	q : P	⊢ q ∈ ↑s1 ∩ ↑s2 ↔ q = p
2 goals	k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	S : add_torsor V P,	s1 s2 : affine_subspace k P,	h1 : ↑s1.nonempty,	h2 : ↑s2.nonempty,	hd : is_compl s1.direction s2.direction,	p : P,	hp : p ∈ ↑s1 ∩ ↑s2,	q : P	⊢ q ∈ ↑s1 ∩ ↑s2 → q = p		k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	S : add_torsor V P,	s1 s2 : affine_subspace k P,	h1 : ↑s1.nonempty,	h2 : ↑s2.nonempty,	hd : is_compl s1.direction s2.direction,	p : P,	hp : p ∈ ↑s1 ∩ ↑s2,	q : P	⊢ q = p → q ∈ ↑s1 ∩ ↑s2
2 goals	k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	S : add_torsor V P,	s1 s2 : affine_subspace k P,	h1 : ↑s1.nonempty,	h2 : ↑s2.nonempty,	hd : is_compl s1.direction s2.direction,	p : P,	hp : p ∈ ↑s1 ∩ ↑s2,	q : P,	hq1 : q ∈ ↑s1,	hq2 : q ∈ ↑s2	⊢ q = p		k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	S : add_torsor V P,	s1 s2 : affine_subspace k P,	h1 : ↑s1.nonempty,	h2 : ↑s2.nonempty,	hd : is_compl s1.direction s2.direction,	p : P,	hp : p ∈ ↑s1 ∩ ↑s2,	q : P	⊢ q = p → q ∈ ↑s1 ∩ ↑s2
2 goals	k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	S : add_torsor V P,	s1 s2 : affine_subspace k P,	h1 : ↑s1.nonempty,	h2 : ↑s2.nonempty,	hd : is_compl s1.direction s2.direction,	p : P,	hp : p ∈ ↑s1 ∩ ↑s2,	q : P,	hq1 : q ∈ ↑s1,	hq2 : q ∈ ↑s2,	hqp : q -ᵥ p ∈ s1.direction ⊓ s2.direction	⊢ q = p		k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	S : add_torsor V P,	s1 s2 : affine_subspace k P,	h1 : ↑s1.nonempty,	h2 : ↑s2.nonempty,	hd : is_compl s1.direction s2.direction,	p : P,	hp : p ∈ ↑s1 ∩ ↑s2,	q : P	⊢ q = p → q ∈ ↑s1 ∩ ↑s2
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	S : add_torsor V P,	s1 s2 : affine_subspace k P,	h1 : ↑s1.nonempty,	h2 : ↑s2.nonempty,	hd : is_compl s1.direction s2.direction,	p : P,	hp : p ∈ ↑s1 ∩ ↑s2,	q : P	⊢ q = p → q ∈ ↑s1 ∩ ↑s2
⊢ ∀ (k : Type u_1) {V : Type u_2} {P : Type u_3} [_inst_1 : ring k] [_inst_2 : add_comm_group V]	  [_inst_3 : module k V] [_inst_4 : add_torsor V P] {s : finset P} {p : P},	    p ∈ s → vector_span k ↑s = submodule.span k ↑(finset.image (λ (_x : P), _x -ᵥ p) (s.erase p))
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : add_torsor V P,	s : finset P,	p : P,	hp : p ∈ s	⊢ vector_span k ↑s = submodule.span k ↑(finset.image (λ (_x : P), _x -ᵥ p) (s.erase p))
⊢ ∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [_inst_1 : ring k] [_inst_2 : add_comm_group V]	  [_inst_3 : module k V] [_inst_4 : add_torsor V P] {ι : Type u_4} [_inst_5 : nontrivial k] {p : ι → P},	    affine_independent k p → ∀ (i : ι) (s : set ι), p i ∉ affine_span k (p '' (s \ {i}))
k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : add_torsor V P,	ι : Type u_4,	_inst_5 : nontrivial k,	p : ι → P,	ha : affine_independent k p,	i : ι,	s : set ι	⊢ p i ∉ affine_span k (p '' (s \ {i}))
⊢ ∀ (R : Type u_1) {V : Type u_2} {P : Type u_4} [_inst_1 : ring R] [_inst_2 : invertible 2]	  [_inst_3 : add_comm_group V] [_inst_4 : module R V] [_inst_5 : add_torsor V P] {x x' y y' : P},	    midpoint R x y = midpoint R x' y' ↔ x -ᵥ x' = y' -ᵥ y
R : Type u_1,	V : Type u_2,	P : Type u_4,	_inst_1 : ring R,	_inst_2 : invertible 2,	_inst_3 : add_comm_group V,	_inst_4 : module R V,	_inst_5 : add_torsor V P,	x x' y y' : P	⊢ midpoint R x y = midpoint R x' y' ↔ x -ᵥ x' = y' -ᵥ y
⊢ ∀ {R : Type u_1} {M : Type u_9} [_inst_1 : semiring R] [_inst_4 : add_comm_monoid M] [_inst_8 : module R M]	  {s : set (submodule R M)} {z : M},	    s.nonempty → directed_on has_le.le s → (z ∈ Sup s ↔ ∃ (y : submodule R M) (H : y ∈ s), z ∈ y)
R : Type u_1,	M : Type u_9,	_inst_1 : semiring R,	_inst_4 : add_comm_monoid M,	_inst_8 : module R M,	s : set (submodule R M),	z : M,	hs : s.nonempty,	hdir : directed_on has_le.le s	⊢ z ∈ Sup s ↔ ∃ (y : submodule R M) (H : y ∈ s), z ∈ y
R : Type u_1,	M : Type u_9,	_inst_1 : semiring R,	_inst_4 : add_comm_monoid M,	_inst_8 : module R M,	s : set (submodule R M),	z : M,	hs : s.nonempty,	hdir : directed_on has_le.le s,	_inst : nonempty ↥s	⊢ z ∈ Sup s ↔ ∃ (y : submodule R M) (H : y ∈ s), z ∈ y
⊢ ∀ {R : Type u_1} {R₂ : Type u_3} {M : Type u_9} {M₂ : Type u_12} [_inst_1 : semiring R]	  [_inst_2 : semiring R₂] [_inst_4 : add_comm_monoid M] [_inst_5 : add_comm_monoid M₂] [_inst_8 : module R M]	  [_inst_9 : module R₂ M₂] {τ₁₂ : R →+* R₂} [_inst_12 : ring_hom_surjective τ₁₂]	  {f : M →ₛₗ[τ₁₂] M₂} {q : submodule R₂ M₂}, q ≤ f.range → map f (comap f q) = q
R : Type u_1,	R₂ : Type u_3,	M : Type u_9,	M₂ : Type u_12,	_inst_1 : semiring R,	_inst_2 : semiring R₂,	_inst_4 : add_comm_monoid M,	_inst_5 : add_comm_monoid M₂,	_inst_8 : module R M,	_inst_9 : module R₂ M₂,	τ₁₂ : R →+* R₂,	_inst_12 : ring_hom_surjective τ₁₂,	f : M →ₛₗ[τ₁₂] M₂,	q : submodule R₂ M₂,	h : q ≤ f.range	⊢ map f (comap f q) = q
⊢ ∀ {R : Type u_1} {M : Type u_9} [_inst_1 : semiring R] [_inst_3 : add_comm_monoid M] [_inst_5 : module R M]	  (p p' : submodule R M) (h : p ≤ p'), (of_le h).ker = ⊥
R : Type u_1,	M : Type u_9,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_5 : module R M,	p p' : submodule R M,	h : p ≤ p'	⊢ (of_le h).ker = ⊥
⊢ ∀ {R : Type u_1} {R₂ : Type u_3} {M : Type u_9} {M₂ : Type u_12} [_inst_1 : comm_semiring R]	  [_inst_2 : comm_semiring R₂] [_inst_3 : add_comm_monoid M] [_inst_4 : add_comm_monoid M₂] [_inst_5 : module R M]	  [_inst_6 : module R₂ M₂] {τ₁₂ : R →+* R₂} {τ₂₁ : R₂ →+* R}	  [_inst_11 : ring_hom_inv_pair τ₁₂ τ₂₁] [_inst_12 : ring_hom_inv_pair τ₂₁ τ₁₂] (p : submodule R M)	  {e : M ≃ₛₗ[τ₁₂] M₂} {x : M₂}, x ∈ map ↑e p ↔ ⇑(e.symm) x ∈ p
R : Type u_1,	R₂ : Type u_3,	M : Type u_9,	M₂ : Type u_12,	_inst_1 : comm_semiring R,	_inst_2 : comm_semiring R₂,	_inst_3 : add_comm_monoid M,	_inst_4 : add_comm_monoid M₂,	_inst_5 : module R M,	_inst_6 : module R₂ M₂,	τ₁₂ : R →+* R₂,	τ₂₁ : R₂ →+* R,	_inst_11 : ring_hom_inv_pair τ₁₂ τ₂₁,	_inst_12 : ring_hom_inv_pair τ₂₁ τ₁₂,	p : submodule R M,	e : M ≃ₛₗ[τ₁₂] M₂,	x : M₂	⊢ x ∈ map ↑e p ↔ ⇑(e.symm) x ∈ p
R : Type u_1,	R₂ : Type u_3,	M : Type u_9,	M₂ : Type u_12,	_inst_1 : comm_semiring R,	_inst_2 : comm_semiring R₂,	_inst_3 : add_comm_monoid M,	_inst_4 : add_comm_monoid M₂,	_inst_5 : module R M,	_inst_6 : module R₂ M₂,	τ₁₂ : R →+* R₂,	τ₂₁ : R₂ →+* R,	_inst_11 : ring_hom_inv_pair τ₁₂ τ₂₁,	_inst_12 : ring_hom_inv_pair τ₂₁ τ₁₂,	p : submodule R M,	e : M ≃ₛₗ[τ₁₂] M₂,	x : M₂	⊢ (∃ (y : M), y ∈ p ∧ ⇑↑e y = x) ↔ ⇑(e.symm) x ∈ p
2 goals	R : Type u_1,	R₂ : Type u_3,	M : Type u_9,	M₂ : Type u_12,	_inst_1 : comm_semiring R,	_inst_2 : comm_semiring R₂,	_inst_3 : add_comm_monoid M,	_inst_4 : add_comm_monoid M₂,	_inst_5 : module R M,	_inst_6 : module R₂ M₂,	τ₁₂ : R →+* R₂,	τ₂₁ : R₂ →+* R,	_inst_11 : ring_hom_inv_pair τ₁₂ τ₂₁,	_inst_12 : ring_hom_inv_pair τ₂₁ τ₁₂,	p : submodule R M,	e : M ≃ₛₗ[τ₁₂] M₂,	x : M₂	⊢ (∃ (y : M), y ∈ p ∧ ⇑↑e y = x) → ⇑(e.symm) x ∈ p		R : Type u_1,	R₂ : Type u_3,	M : Type u_9,	M₂ : Type u_12,	_inst_1 : comm_semiring R,	_inst_2 : comm_semiring R₂,	_inst_3 : add_comm_monoid M,	_inst_4 : add_comm_monoid M₂,	_inst_5 : module R M,	_inst_6 : module R₂ M₂,	τ₁₂ : R →+* R₂,	τ₂₁ : R₂ →+* R,	_inst_11 : ring_hom_inv_pair τ₁₂ τ₂₁,	_inst_12 : ring_hom_inv_pair τ₂₁ τ₁₂,	p : submodule R M,	e : M ≃ₛₗ[τ₁₂] M₂,	x : M₂	⊢ ⇑(e.symm) x ∈ p → (∃ (y : M), y ∈ p ∧ ⇑↑e y = x)
2 goals	R : Type u_1,	R₂ : Type u_3,	M : Type u_9,	M₂ : Type u_12,	_inst_1 : comm_semiring R,	_inst_2 : comm_semiring R₂,	_inst_3 : add_comm_monoid M,	_inst_4 : add_comm_monoid M₂,	_inst_5 : module R M,	_inst_6 : module R₂ M₂,	τ₁₂ : R →+* R₂,	τ₂₁ : R₂ →+* R,	_inst_11 : ring_hom_inv_pair τ₁₂ τ₂₁,	_inst_12 : ring_hom_inv_pair τ₂₁ τ₁₂,	p : submodule R M,	e : M ≃ₛₗ[τ₁₂] M₂,	x : M₂,	y : M,	hy : y ∈ p,	hx : ⇑↑e y = x	⊢ ⇑(e.symm) x ∈ p		R : Type u_1,	R₂ : Type u_3,	M : Type u_9,	M₂ : Type u_12,	_inst_1 : comm_semiring R,	_inst_2 : comm_semiring R₂,	_inst_3 : add_comm_monoid M,	_inst_4 : add_comm_monoid M₂,	_inst_5 : module R M,	_inst_6 : module R₂ M₂,	τ₁₂ : R →+* R₂,	τ₂₁ : R₂ →+* R,	_inst_11 : ring_hom_inv_pair τ₁₂ τ₂₁,	_inst_12 : ring_hom_inv_pair τ₂₁ τ₁₂,	p : submodule R M,	e : M ≃ₛₗ[τ₁₂] M₂,	x : M₂	⊢ ⇑(e.symm) x ∈ p → (∃ (y : M), y ∈ p ∧ ⇑↑e y = x)
R : Type u_1,	R₂ : Type u_3,	M : Type u_9,	M₂ : Type u_12,	_inst_1 : comm_semiring R,	_inst_2 : comm_semiring R₂,	_inst_3 : add_comm_monoid M,	_inst_4 : add_comm_monoid M₂,	_inst_5 : module R M,	_inst_6 : module R₂ M₂,	τ₁₂ : R →+* R₂,	τ₂₁ : R₂ →+* R,	_inst_11 : ring_hom_inv_pair τ₁₂ τ₂₁,	_inst_12 : ring_hom_inv_pair τ₂₁ τ₁₂,	p : submodule R M,	e : M ≃ₛₗ[τ₁₂] M₂,	x : M₂	⊢ ⇑(e.symm) x ∈ p → (∃ (y : M), y ∈ p ∧ ⇑↑e y = x)
R : Type u_1,	R₂ : Type u_3,	M : Type u_9,	M₂ : Type u_12,	_inst_1 : comm_semiring R,	_inst_2 : comm_semiring R₂,	_inst_3 : add_comm_monoid M,	_inst_4 : add_comm_monoid M₂,	_inst_5 : module R M,	_inst_6 : module R₂ M₂,	τ₁₂ : R →+* R₂,	τ₂₁ : R₂ →+* R,	_inst_11 : ring_hom_inv_pair τ₁₂ τ₂₁,	_inst_12 : ring_hom_inv_pair τ₂₁ τ₁₂,	p : submodule R M,	e : M ≃ₛₗ[τ₁₂] M₂,	x : M₂,	hx : ⇑(e.symm) x ∈ p	⊢ ∃ (y : M), y ∈ p ∧ ⇑↑e y = x
⊢ ∀ {R : Type u_1} {M : Type u_2} [_inst_1 : semiring R] [_inst_2 : add_comm_monoid M] [_inst_3 : module R M]	  {B D : bilin_form R M}, (∀ (x y : M), ⇑B x y = ⇑D x y) → B = D
R : Type u_1,	M : Type u_2,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : module R M,	B D : bilin_form R M,	H : ∀ (x y : M), ⇑B x y = ⇑D x y	⊢ B = D
R : Type u_1,	M : Type u_2,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : module R M,	D : bilin_form R M,	B_bilin : M → M → R,	B_bilin_add_left : ∀ (x y z : M), B_bilin (x + y) z = B_bilin x z + B_bilin y z,	B_bilin_smul_left : ∀ (a : R) (x y : M), B_bilin (a • x) y = a * B_bilin x y,	B_bilin_add_right : ∀ (x y z : M), B_bilin x (y + z) = B_bilin x y + B_bilin x z,	B_bilin_smul_right : ∀ (a : R) (x y : M), B_bilin x (a • y) = a * B_bilin x y,	H :	  ∀ (x y : M),	    ⇑{bilin := B_bilin,	         bilin_add_left := B_bilin_add_left,	         bilin_smul_left := B_bilin_smul_left,	         bilin_add_right := B_bilin_add_right,	         bilin_smul_right := B_bilin_smul_right}	        x	        y =	      ⇑D x y	⊢ {bilin := B_bilin,	     bilin_add_left := B_bilin_add_left,	     bilin_smul_left := B_bilin_smul_left,	     bilin_add_right := B_bilin_add_right,	     bilin_smul_right := B_bilin_smul_right} =	    D
R : Type u_1,	M : Type u_2,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : module R M,	B_bilin : M → M → R,	B_bilin_add_left : ∀ (x y z : M), B_bilin (x + y) z = B_bilin x z + B_bilin y z,	B_bilin_smul_left : ∀ (a : R) (x y : M), B_bilin (a • x) y = a * B_bilin x y,	B_bilin_add_right : ∀ (x y z : M), B_bilin x (y + z) = B_bilin x y + B_bilin x z,	B_bilin_smul_right : ∀ (a : R) (x y : M), B_bilin x (a • y) = a * B_bilin x y,	D_bilin : M → M → R,	D_bilin_add_left : ∀ (x y z : M), D_bilin (x + y) z = D_bilin x z + D_bilin y z,	D_bilin_smul_left : ∀ (a : R) (x y : M), D_bilin (a • x) y = a * D_bilin x y,	D_bilin_add_right : ∀ (x y z : M), D_bilin x (y + z) = D_bilin x y + D_bilin x z,	D_bilin_smul_right : ∀ (a : R) (x y : M), D_bilin x (a • y) = a * D_bilin x y,	H :	  ∀ (x y : M),	    ⇑{bilin := B_bilin,	         bilin_add_left := B_bilin_add_left,	         bilin_smul_left := B_bilin_smul_left,	         bilin_add_right := B_bilin_add_right,	         bilin_smul_right := B_bilin_smul_right}	        x	        y =	      ⇑{bilin := D_bilin,	         bilin_add_left := D_bilin_add_left,	         bilin_smul_left := D_bilin_smul_left,	         bilin_add_right := D_bilin_add_right,	         bilin_smul_right := D_bilin_smul_right}	        x	        y	⊢ {bilin := B_bilin,	     bilin_add_left := B_bilin_add_left,	     bilin_smul_left := B_bilin_smul_left,	     bilin_add_right := B_bilin_add_right,	     bilin_smul_right := B_bilin_smul_right} =	    {bilin := D_bilin,	     bilin_add_left := D_bilin_add_left,	     bilin_smul_left := D_bilin_smul_left,	     bilin_add_right := D_bilin_add_right,	     bilin_smul_right := D_bilin_smul_right}
R : Type u_1,	M : Type u_2,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : module R M,	B_bilin : M → M → R,	B_bilin_add_left : ∀ (x y z : M), B_bilin (x + y) z = B_bilin x z + B_bilin y z,	B_bilin_smul_left : ∀ (a : R) (x y : M), B_bilin (a • x) y = a * B_bilin x y,	B_bilin_add_right : ∀ (x y z : M), B_bilin x (y + z) = B_bilin x y + B_bilin x z,	B_bilin_smul_right : ∀ (a : R) (x y : M), B_bilin x (a • y) = a * B_bilin x y,	D_bilin : M → M → R,	D_bilin_add_left : ∀ (x y z : M), D_bilin (x + y) z = D_bilin x z + D_bilin y z,	D_bilin_smul_left : ∀ (a : R) (x y : M), D_bilin (a • x) y = a * D_bilin x y,	D_bilin_add_right : ∀ (x y z : M), D_bilin x (y + z) = D_bilin x y + D_bilin x z,	D_bilin_smul_right : ∀ (a : R) (x y : M), D_bilin x (a • y) = a * D_bilin x y,	H :	  ∀ (x y : M),	    ⇑{bilin := B_bilin,	         bilin_add_left := B_bilin_add_left,	         bilin_smul_left := B_bilin_smul_left,	         bilin_add_right := B_bilin_add_right,	         bilin_smul_right := B_bilin_smul_right}	        x	        y =	      ⇑{bilin := D_bilin,	         bilin_add_left := D_bilin_add_left,	         bilin_smul_left := D_bilin_smul_left,	         bilin_add_right := D_bilin_add_right,	         bilin_smul_right := D_bilin_smul_right}	        x	        y	⊢ B_bilin = D_bilin
R : Type u_1,	M : Type u_2,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : module R M,	B_bilin : M → M → R,	B_bilin_add_left : ∀ (x y z : M), B_bilin (x + y) z = B_bilin x z + B_bilin y z,	B_bilin_smul_left : ∀ (a : R) (x y : M), B_bilin (a • x) y = a * B_bilin x y,	B_bilin_add_right : ∀ (x y z : M), B_bilin x (y + z) = B_bilin x y + B_bilin x z,	B_bilin_smul_right : ∀ (a : R) (x y : M), B_bilin x (a • y) = a * B_bilin x y,	D_bilin : M → M → R,	D_bilin_add_left : ∀ (x y z : M), D_bilin (x + y) z = D_bilin x z + D_bilin y z,	D_bilin_smul_left : ∀ (a : R) (x y : M), D_bilin (a • x) y = a * D_bilin x y,	D_bilin_add_right : ∀ (x y z : M), D_bilin x (y + z) = D_bilin x y + D_bilin x z,	D_bilin_smul_right : ∀ (a : R) (x y : M), D_bilin x (a • y) = a * D_bilin x y,	H :	  ∀ (x y : M),	    ⇑{bilin := B_bilin,	         bilin_add_left := B_bilin_add_left,	         bilin_smul_left := B_bilin_smul_left,	         bilin_add_right := B_bilin_add_right,	         bilin_smul_right := B_bilin_smul_right}	        x	        y =	      ⇑{bilin := D_bilin,	         bilin_add_left := D_bilin_add_left,	         bilin_smul_left := D_bilin_smul_left,	         bilin_add_right := D_bilin_add_right,	         bilin_smul_right := D_bilin_smul_right}	        x	        y,	x x_1 : M	⊢ B_bilin x x_1 = D_bilin x x_1
⊢ ∀ {R₃ : Type u_7} [_inst_10 : comm_ring R₃] {n : Type w} [_inst_16 : fintype n] (J J₃ A : matrix n n R₃)	  [_inst_17 : decidable_eq n], A ∈ pair_self_adjoint_matrices_submodule J J₃ ↔ J.is_adjoint_pair J₃ A A
R₃ : Type u_7,	_inst_10 : comm_ring R₃,	n : Type w,	_inst_16 : fintype n,	J J₃ A : matrix n n R₃,	_inst_17 : decidable_eq n	⊢ A ∈ pair_self_adjoint_matrices_submodule J J₃ ↔ J.is_adjoint_pair J₃ A A
R₃ : Type u_7,	_inst_10 : comm_ring R₃,	n : Type w,	_inst_16 : fintype n,	J J₃ A : matrix n n R₃,	_inst_17 : decidable_eq n	⊢ (∃ (y : module.End R₃ (n → R₃)),	       (⇑to_bilin' J).is_pair_self_adjoint (⇑to_bilin' J₃) y ∧ ⇑to_matrix' y = A) ↔	    J.is_adjoint_pair J₃ A A
2 goals	R₃ : Type u_7,	_inst_10 : comm_ring R₃,	n : Type w,	_inst_16 : fintype n,	J J₃ A : matrix n n R₃,	_inst_17 : decidable_eq n	⊢ (∃ (y : module.End R₃ (n → R₃)),	     (⇑to_bilin' J).is_pair_self_adjoint (⇑to_bilin' J₃) y ∧ ⇑to_matrix' y = A) →	  J.is_adjoint_pair J₃ A A		R₃ : Type u_7,	_inst_10 : comm_ring R₃,	n : Type w,	_inst_16 : fintype n,	J J₃ A : matrix n n R₃,	_inst_17 : decidable_eq n	⊢ J.is_adjoint_pair J₃ A A →	  (∃ (y : module.End R₃ (n → R₃)),	     (⇑to_bilin' J).is_pair_self_adjoint (⇑to_bilin' J₃) y ∧ ⇑to_matrix' y = A)
2 goals	R₃ : Type u_7,	_inst_10 : comm_ring R₃,	n : Type w,	_inst_16 : fintype n,	J J₃ A : matrix n n R₃,	_inst_17 : decidable_eq n,	f : module.End R₃ (n → R₃),	hf : (⇑to_bilin' J).is_pair_self_adjoint (⇑to_bilin' J₃) f,	hA : ⇑to_matrix' f = A	⊢ J.is_adjoint_pair J₃ A A		R₃ : Type u_7,	_inst_10 : comm_ring R₃,	n : Type w,	_inst_16 : fintype n,	J J₃ A : matrix n n R₃,	_inst_17 : decidable_eq n	⊢ J.is_adjoint_pair J₃ A A →	  (∃ (y : module.End R₃ (n → R₃)),	     (⇑to_bilin' J).is_pair_self_adjoint (⇑to_bilin' J₃) y ∧ ⇑to_matrix' y = A)
2 goals	R₃ : Type u_7,	_inst_10 : comm_ring R₃,	n : Type w,	_inst_16 : fintype n,	J J₃ A : matrix n n R₃,	_inst_17 : decidable_eq n,	f : module.End R₃ (n → R₃),	hf : (⇑to_bilin' J).is_pair_self_adjoint (⇑to_bilin' J₃) f,	hA : ⇑to_matrix' f = A,	hf' : f = ⇑to_lin' A	⊢ J.is_adjoint_pair J₃ A A		R₃ : Type u_7,	_inst_10 : comm_ring R₃,	n : Type w,	_inst_16 : fintype n,	J J₃ A : matrix n n R₃,	_inst_17 : decidable_eq n	⊢ J.is_adjoint_pair J₃ A A →	  (∃ (y : module.End R₃ (n → R₃)),	     (⇑to_bilin' J).is_pair_self_adjoint (⇑to_bilin' J₃) y ∧ ⇑to_matrix' y = A)
2 goals	R₃ : Type u_7,	_inst_10 : comm_ring R₃,	n : Type w,	_inst_16 : fintype n,	J J₃ A : matrix n n R₃,	_inst_17 : decidable_eq n,	f : module.End R₃ (n → R₃),	hA : ⇑to_matrix' f = A,	hf' : f = ⇑to_lin' A,	hf : (⇑to_bilin' J).is_pair_self_adjoint (⇑to_bilin' J₃) (⇑to_lin' A)	⊢ J.is_adjoint_pair J₃ A A		R₃ : Type u_7,	_inst_10 : comm_ring R₃,	n : Type w,	_inst_16 : fintype n,	J J₃ A : matrix n n R₃,	_inst_17 : decidable_eq n	⊢ J.is_adjoint_pair J₃ A A →	  (∃ (y : module.End R₃ (n → R₃)),	     (⇑to_bilin' J).is_pair_self_adjoint (⇑to_bilin' J₃) y ∧ ⇑to_matrix' y = A)
2 goals	R₃ : Type u_7,	_inst_10 : comm_ring R₃,	n : Type w,	_inst_16 : fintype n,	J J₃ A : matrix n n R₃,	_inst_17 : decidable_eq n,	f : module.End R₃ (n → R₃),	hA : ⇑to_matrix' f = A,	hf' : f = ⇑to_lin' A,	hf : (⇑to_bilin' J).is_pair_self_adjoint (⇑to_bilin' J₃) (⇑to_lin' A)	⊢ (⇑to_bilin' J).is_adjoint_pair (⇑to_bilin' J₃) (⇑to_lin' A) (⇑to_lin' A)		R₃ : Type u_7,	_inst_10 : comm_ring R₃,	n : Type w,	_inst_16 : fintype n,	J J₃ A : matrix n n R₃,	_inst_17 : decidable_eq n	⊢ J.is_adjoint_pair J₃ A A →	  (∃ (y : module.End R₃ (n → R₃)),	     (⇑to_bilin' J).is_pair_self_adjoint (⇑to_bilin' J₃) y ∧ ⇑to_matrix' y = A)
R₃ : Type u_7,	_inst_10 : comm_ring R₃,	n : Type w,	_inst_16 : fintype n,	J J₃ A : matrix n n R₃,	_inst_17 : decidable_eq n	⊢ J.is_adjoint_pair J₃ A A →	  (∃ (y : module.End R₃ (n → R₃)),	     (⇑to_bilin' J).is_pair_self_adjoint (⇑to_bilin' J₃) y ∧ ⇑to_matrix' y = A)
R₃ : Type u_7,	_inst_10 : comm_ring R₃,	n : Type w,	_inst_16 : fintype n,	J J₃ A : matrix n n R₃,	_inst_17 : decidable_eq n,	h : J.is_adjoint_pair J₃ A A	⊢ ∃ (y : module.End R₃ (n → R₃)),	    (⇑to_bilin' J).is_pair_self_adjoint (⇑to_bilin' J₃) y ∧ ⇑to_matrix' y = A
R₃ : Type u_7,	_inst_10 : comm_ring R₃,	n : Type w,	_inst_16 : fintype n,	J J₃ A : matrix n n R₃,	_inst_17 : decidable_eq n,	h : J.is_adjoint_pair J₃ A A	⊢ (⇑to_bilin' J).is_pair_self_adjoint (⇑to_bilin' J₃) (⇑to_lin' A)
⊢ ∀ {R : Type u_1} {M : Type u_2} [_inst_1 : semiring R] [_inst_2 : add_comm_monoid M] [_inst_3 : module R M]	  {R₂ : Type u_5} [_inst_7 : comm_semiring R₂] [_inst_16 : algebra R₂ R],	    (flip_hom R₂).trans (flip_hom R₂) = linear_equiv.refl R₂ (bilin_form R M)
R : Type u_1,	M : Type u_2,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : module R M,	R₂ : Type u_5,	_inst_7 : comm_semiring R₂,	_inst_16 : algebra R₂ R	⊢ (flip_hom R₂).trans (flip_hom R₂) = linear_equiv.refl R₂ (bilin_form R M)
R : Type u_1,	M : Type u_2,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : module R M,	R₂ : Type u_5,	_inst_7 : comm_semiring R₂,	_inst_16 : algebra R₂ R,	A : bilin_form R M,	x y : M	⊢ ⇑(⇑((flip_hom R₂).trans (flip_hom R₂)) A) x y = ⇑(⇑(linear_equiv.refl R₂ (bilin_form R M)) A) x y
⊢ ∀ {R₃ : Type u_7} {M₃ : Type u_8} [_inst_10 : comm_ring R₃] [_inst_11 : add_comm_group M₃]	  [_inst_12 : module R₃ M₃] {n : Type u_11} [_inst_16 : fintype n] [_inst_18 : decidable_eq n]	  (b : basis n R₃ M₃) (B : bilin_form R₃ M₃) (M : matrix n n R₃),	    (⇑(to_matrix b) B).mul M = ⇑(to_matrix b) (B.comp_right (⇑(to_lin b b) M))
R₃ : Type u_7,	M₃ : Type u_8,	_inst_10 : comm_ring R₃,	_inst_11 : add_comm_group M₃,	_inst_12 : module R₃ M₃,	n : Type u_11,	_inst_16 : fintype n,	_inst_18 : decidable_eq n,	b : basis n R₃ M₃,	B : bilin_form R₃ M₃,	M : matrix n n R₃	⊢ (⇑(to_matrix b) B).mul M = ⇑(to_matrix b) (B.comp_right (⇑(to_lin b b) M))
⊢ ∀ {R : Type u} [_inst_1 : ring R] {M : Type v} [_inst_2 : add_comm_group M] [_inst_3 : module R M] {M₁ : Type v}	  [_inst_6 : add_comm_group M₁] [_inst_7 : module R M₁] (f : M →ₗ[R] M₁) (p : submodule R M),	    module.rank R ↥(map f p) ≤ module.rank R ↥p
R : Type u,	_inst_1 : ring R,	M : Type v,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	M₁ : Type v,	_inst_6 : add_comm_group M₁,	_inst_7 : module R M₁,	f : M →ₗ[R] M₁,	p : submodule R M	⊢ module.rank R ↥(map f p) ≤ module.rank R ↥p
⊢ ∀ {R : Type u} [_inst_1 : ring R] {M : Type v} [_inst_2 : add_comm_group M] [_inst_3 : module R M] {M₁ : Type v}	  [_inst_6 : add_comm_group M₁] [_inst_7 : module R M₁] (f : M →ₗ[R] M₁),	    surjective ⇑f → module.rank R M₁ ≤ module.rank R M
R : Type u,	_inst_1 : ring R,	M : Type v,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	M₁ : Type v,	_inst_6 : add_comm_group M₁,	_inst_7 : module R M₁,	f : M →ₗ[R] M₁,	h : surjective ⇑f	⊢ module.rank R M₁ ≤ module.rank R M
R : Type u,	_inst_1 : ring R,	M : Type v,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	M₁ : Type v,	_inst_6 : add_comm_group M₁,	_inst_7 : module R M₁,	f : M →ₗ[R] M₁,	h : surjective ⇑f	⊢ module.rank R ↥(f.range) ≤ module.rank R M
⊢ ∀ {R : Type u_1} {M : Type u_2} {ι : Type u_5} [_inst_1 : comm_ring R] [_inst_2 : add_comm_group M]	  [_inst_3 : module R M] [_inst_4 : decidable_eq ι] (b : basis ι R M) [_inst_5 : fintype ι] (i j : ι),	    ⇑(⇑(b.dual_basis) i) (⇑b j) = ite (j = i) 1 0
R : Type u_1,	M : Type u_2,	ι : Type u_5,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_4 : decidable_eq ι,	b : basis ι R M,	_inst_5 : fintype ι,	i j : ι	⊢ ⇑(⇑(b.dual_basis) i) (⇑b j) = ite (j = i) 1 0
R : Type u_1,	M : Type u_2,	ι : Type u_5,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_4 : decidable_eq ι,	b : basis ι R M,	_inst_5 : fintype ι,	i j : ι	⊢ j = i = (i = j)
⊢ ∀ {F : Type u_1} {E : Type u_2} [_inst_6 : field F] [_inst_7 : field E] [_inst_8 : algebra F E],	    module.rank F ↥⊤ = module.rank F E
F : Type u_1,	E : Type u_2,	_inst_6 : field F,	_inst_7 : field E,	_inst_8 : algebra F E	⊢ module.rank F ↥⊤ = module.rank F E
⊢ ∀ {α : Type u_1} {M : Type u_2} (R : Type u_5) [_inst_1 : semiring R] [_inst_3 : add_comm_monoid M]	  [_inst_4 : module R M] {M' : Type u_8} [_inst_9 : add_comm_monoid M'] [_inst_10 : module R M'] (f : M →ₗ[R] M')	  (v : α → M) (l : α →₀ R), ⇑f (⇑(finsupp.total α M R v) l) = ⇑(finsupp.total α M' R (⇑f ∘ v)) l
α : Type u_1,	M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	M' : Type u_8,	_inst_9 : add_comm_monoid M',	_inst_10 : module R M',	f : M →ₗ[R] M',	v : α → M,	l : α →₀ R	⊢ ⇑f (⇑(finsupp.total α M R v) l) = ⇑(finsupp.total α M' R (⇑f ∘ v)) l
3 goals	α : Type u_1,	M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	M' : Type u_8,	_inst_9 : add_comm_monoid M',	_inst_10 : module R M',	f : M →ₗ[R] M',	v : α → M,	l : α →₀ R	⊢ ⇑f (⇑(finsupp.total α M R v) 0) = ⇑(finsupp.total α M' R (⇑f ∘ v)) 0		α : Type u_1,	M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	M' : Type u_8,	_inst_9 : add_comm_monoid M',	_inst_10 : module R M',	f : M →ₗ[R] M',	v : α → M,	l : α →₀ R	⊢ ∀ (f_1 g : α →₀ R),	    ⇑f (⇑(finsupp.total α M R v) f_1) = ⇑(finsupp.total α M' R (⇑f ∘ v)) f_1 →	    ⇑f (⇑(finsupp.total α M R v) g) = ⇑(finsupp.total α M' R (⇑f ∘ v)) g →	    ⇑f (⇑(finsupp.total α M R v) (f_1 + g)) = ⇑(finsupp.total α M' R (⇑f ∘ v)) (f_1 + g)		α : Type u_1,	M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	M' : Type u_8,	_inst_9 : add_comm_monoid M',	_inst_10 : module R M',	f : M →ₗ[R] M',	v : α → M,	l : α →₀ R	⊢ ∀ (a : α) (b : R),	    ⇑f (⇑(finsupp.total α M R v) (single a b)) = ⇑(finsupp.total α M' R (⇑f ∘ v)) (single a b)
2 goals	α : Type u_1,	M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	M' : Type u_8,	_inst_9 : add_comm_monoid M',	_inst_10 : module R M',	f : M →ₗ[R] M',	v : α → M,	l : α →₀ R	⊢ ∀ (f_1 g : α →₀ R),	    ⇑f (⇑(finsupp.total α M R v) f_1) = ⇑(finsupp.total α M' R (⇑f ∘ v)) f_1 →	    ⇑f (⇑(finsupp.total α M R v) g) = ⇑(finsupp.total α M' R (⇑f ∘ v)) g →	    ⇑f (⇑(finsupp.total α M R v) (f_1 + g)) = ⇑(finsupp.total α M' R (⇑f ∘ v)) (f_1 + g)		α : Type u_1,	M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	M' : Type u_8,	_inst_9 : add_comm_monoid M',	_inst_10 : module R M',	f : M →ₗ[R] M',	v : α → M,	l : α →₀ R	⊢ ∀ (a : α) (b : R),	    ⇑f (⇑(finsupp.total α M R v) (single a b)) = ⇑(finsupp.total α M' R (⇑f ∘ v)) (single a b)
α : Type u_1,	M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	M' : Type u_8,	_inst_9 : add_comm_monoid M',	_inst_10 : module R M',	f : M →ₗ[R] M',	v : α → M,	l : α →₀ R	⊢ ∀ (a : α) (b : R),	    ⇑f (⇑(finsupp.total α M R v) (single a b)) = ⇑(finsupp.total α M' R (⇑f ∘ v)) (single a b)
⊢ ∀ {M : Type u_2} (R : Type u_5) [_inst_1 : semiring R] [_inst_3 : add_comm_monoid M] [_inst_4 : module R M]	  {α : Type u_1} {β : Type u_3} (A : α → M) (B : β → α →₀ R) (f : β →₀ R),	    ⇑(finsupp.total α M R A) (⇑(finsupp.total β (α →₀ R) R B) f) =	      ⇑(finsupp.total β M R (λ (b : β), ⇑(finsupp.total α M R A) (B b))) f
M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	α : Type u_1,	β : Type u_3,	A : α → M,	B : β → α →₀ R,	f : β →₀ R	⊢ ⇑(finsupp.total α M R A) (⇑(finsupp.total β (α →₀ R) R B) f) =	    ⇑(finsupp.total β M R (λ (b : β), ⇑(finsupp.total α M R A) (B b))) f
M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	α : Type u_1,	β : Type u_3,	A : α → M,	B : β → α →₀ R,	f : β →₀ R	⊢ (f.sum (λ (i : β) (a : R), a • B i)).sum (λ (i : α) (a : R), a • A i) =	    f.sum (λ (i : β) (a : R), a • (B i).sum (λ (i : α) (a : R), a • A i))
3 goals	M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	α : Type u_1,	β : Type u_3,	A : α → M,	B : β → α →₀ R,	f : β →₀ R	⊢ (0.sum (λ (i : β) (a : R), a • B i)).sum (λ (i : α) (a : R), a • A i) =	    0.sum (λ (i : β) (a : R), a • (B i).sum (λ (i : α) (a : R), a • A i))		M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	α : Type u_1,	β : Type u_3,	A : α → M,	B : β → α →₀ R,	f : β →₀ R	⊢ ∀ (f g : β →₀ R),	    (f.sum (λ (i : β) (a : R), a • B i)).sum (λ (i : α) (a : R), a • A i) =	      f.sum (λ (i : β) (a : R), a • (B i).sum (λ (i : α) (a : R), a • A i)) →	    (g.sum (λ (i : β) (a : R), a • B i)).sum (λ (i : α) (a : R), a • A i) =	      g.sum (λ (i : β) (a : R), a • (B i).sum (λ (i : α) (a : R), a • A i)) →	    ((f + g).sum (λ (i : β) (a : R), a • B i)).sum (λ (i : α) (a : R), a • A i) =	      (f + g).sum (λ (i : β) (a : R), a • (B i).sum (λ (i : α) (a : R), a • A i))		M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	α : Type u_1,	β : Type u_3,	A : α → M,	B : β → α →₀ R,	f : β →₀ R	⊢ ∀ (a : β) (b : R),	    ((single a b).sum (λ (i : β) (a : R), a • B i)).sum (λ (i : α) (a : R), a • A i) =	      (single a b).sum (λ (i : β) (a : R), a • (B i).sum (λ (i : α) (a : R), a • A i))
2 goals	M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	α : Type u_1,	β : Type u_3,	A : α → M,	B : β → α →₀ R,	f : β →₀ R	⊢ ∀ (f g : β →₀ R),	    (f.sum (λ (i : β) (a : R), a • B i)).sum (λ (i : α) (a : R), a • A i) =	      f.sum (λ (i : β) (a : R), a • (B i).sum (λ (i : α) (a : R), a • A i)) →	    (g.sum (λ (i : β) (a : R), a • B i)).sum (λ (i : α) (a : R), a • A i) =	      g.sum (λ (i : β) (a : R), a • (B i).sum (λ (i : α) (a : R), a • A i)) →	    ((f + g).sum (λ (i : β) (a : R), a • B i)).sum (λ (i : α) (a : R), a • A i) =	      (f + g).sum (λ (i : β) (a : R), a • (B i).sum (λ (i : α) (a : R), a • A i))		M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	α : Type u_1,	β : Type u_3,	A : α → M,	B : β → α →₀ R,	f : β →₀ R	⊢ ∀ (a : β) (b : R),	    ((single a b).sum (λ (i : β) (a : R), a • B i)).sum (λ (i : α) (a : R), a • A i) =	      (single a b).sum (λ (i : β) (a : R), a • (B i).sum (λ (i : α) (a : R), a • A i))
2 goals	M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	α : Type u_1,	β : Type u_3,	A : α → M,	B : β → α →₀ R,	f : β →₀ R,	f₁ f₂ : β →₀ R,	h₁ :	  (f₁.sum (λ (i : β) (a : R), a • B i)).sum (λ (i : α) (a : R), a • A i) =	    f₁.sum (λ (i : β) (a : R), a • (B i).sum (λ (i : α) (a : R), a • A i)),	h₂ :	  (f₂.sum (λ (i : β) (a : R), a • B i)).sum (λ (i : α) (a : R), a • A i) =	    f₂.sum (λ (i : β) (a : R), a • (B i).sum (λ (i : α) (a : R), a • A i))	⊢ ((f₁ + f₂).sum (λ (i : β) (a : R), a • B i)).sum (λ (i : α) (a : R), a • A i) =	    (f₁ + f₂).sum (λ (i : β) (a : R), a • (B i).sum (λ (i : α) (a : R), a • A i))		M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	α : Type u_1,	β : Type u_3,	A : α → M,	B : β → α →₀ R,	f : β →₀ R	⊢ ∀ (a : β) (b : R),	    ((single a b).sum (λ (i : β) (a : R), a • B i)).sum (λ (i : α) (a : R), a • A i) =	      (single a b).sum (λ (i : β) (a : R), a • (B i).sum (λ (i : α) (a : R), a • A i))
M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	α : Type u_1,	β : Type u_3,	A : α → M,	B : β → α →₀ R,	f : β →₀ R	⊢ ∀ (a : β) (b : R),	    ((single a b).sum (λ (i : β) (a : R), a • B i)).sum (λ (i : α) (a : R), a • A i) =	      (single a b).sum (λ (i : β) (a : R), a • (B i).sum (λ (i : α) (a : R), a • A i))
⊢ ∀ {R : Type u_2} [_inst_1 : comm_ring R] [_inst_2 : is_domain R] [_inst_3 : is_principal_ideal_ring R]	  {M : Type u_3} [_inst_4 : add_comm_group M] [_inst_5 : module R M] {N O : submodule R M} (hNO : N ≤ O)	  {ϕ : ↥O →ₗ[R] R},	    (∀ (ψ : ↥O →ₗ[R] R),	       ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N) →	    ∀ [_inst_6 : (ϕ.submodule_image N).is_principal] (y : M) (yN : y ∈ N),	      ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N) →	      ∀ (ψ : ↥O →ₗ[R] R), generator (ϕ.submodule_image N) ∣ ⇑ψ ⟨y, _⟩
R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R	⊢ generator (ϕ.submodule_image N) ∣ ⇑ψ ⟨y, _⟩
R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N)	⊢ generator (ϕ.submodule_image N) ∣ ⇑ψ ⟨y, _⟩
R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩})	⊢ generator (ϕ.submodule_image N) ∣ ⇑ψ ⟨y, _⟩
R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a	⊢ generator (ϕ.submodule_image N) ∣ ⇑ψ ⟨y, _⟩
R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩	⊢ generator (ϕ.submodule_image N) ∣ ⇑ψ ⟨y, _⟩
R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩	⊢ generator (ϕ.submodule_image N) ∣ d
3 goals	R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩	⊢ span R {generator (span R {a, ⇑ψ ⟨y, _⟩})} = span R {generator (ϕ.submodule_image N)}		R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩	⊢ (span R {a, ⇑ψ ⟨y, _⟩}).is_principal		R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩	⊢ generator (ϕ.submodule_image N) ∈ span R {a, ⇑ψ ⟨y, _⟩}
4 goals	R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩	⊢ ∃ (r₁ r₂ : R), d = r₁ * a + r₂ * ⇑ψ ⟨y, _⟩		R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩,	r₁ r₂ : R,	d_eq : d = r₁ * a + r₂ * ⇑ψ ⟨y, _⟩	⊢ span R {generator (span R {a, ⇑ψ ⟨y, _⟩})} = span R {generator (ϕ.submodule_image N)}		R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩	⊢ (span R {a, ⇑ψ ⟨y, _⟩}).is_principal		R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩	⊢ generator (ϕ.submodule_image N) ∈ span R {a, ⇑ψ ⟨y, _⟩}
4 goals	R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩,	r₁ r₂' : R,	hr₂' : r₂' ∈ span R {⇑ψ ⟨y, _⟩},	hr₁ : generator (span R {a, ⇑ψ ⟨y, _⟩}) = r₁ • a + r₂'	⊢ ∃ (r₁ r₂ : R), d = r₁ * a + r₂ * ⇑ψ ⟨y, _⟩		R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩,	r₁ r₂ : R,	d_eq : d = r₁ * a + r₂ * ⇑ψ ⟨y, _⟩	⊢ span R {generator (span R {a, ⇑ψ ⟨y, _⟩})} = span R {generator (ϕ.submodule_image N)}		R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩	⊢ (span R {a, ⇑ψ ⟨y, _⟩}).is_principal		R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩	⊢ generator (ϕ.submodule_image N) ∈ span R {a, ⇑ψ ⟨y, _⟩}
4 goals	R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩,	r₁ r₂ : R,	hr₂' : r₂ • ⇑ψ ⟨y, _⟩ ∈ span R {⇑ψ ⟨y, _⟩},	hr₁ : generator (span R {a, ⇑ψ ⟨y, _⟩}) = r₁ • a + r₂ • ⇑ψ ⟨y, _⟩	⊢ ∃ (r₁ r₂ : R), d = r₁ * a + r₂ * ⇑ψ ⟨y, _⟩		R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩,	r₁ r₂ : R,	d_eq : d = r₁ * a + r₂ * ⇑ψ ⟨y, _⟩	⊢ span R {generator (span R {a, ⇑ψ ⟨y, _⟩})} = span R {generator (ϕ.submodule_image N)}		R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩	⊢ (span R {a, ⇑ψ ⟨y, _⟩}).is_principal		R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩	⊢ generator (ϕ.submodule_image N) ∈ span R {a, ⇑ψ ⟨y, _⟩}
3 goals	R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩,	r₁ r₂ : R,	d_eq : d = r₁ * a + r₂ * ⇑ψ ⟨y, _⟩	⊢ span R {generator (span R {a, ⇑ψ ⟨y, _⟩})} = span R {generator (ϕ.submodule_image N)}		R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩	⊢ (span R {a, ⇑ψ ⟨y, _⟩}).is_principal		R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩	⊢ generator (ϕ.submodule_image N) ∈ span R {a, ⇑ψ ⟨y, _⟩}
3 goals	R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩,	r₁ r₂ : R,	d_eq : d = r₁ * a + r₂ * ⇑ψ ⟨y, _⟩,	ψ' : ↥O →ₗ[R] R := r₁ • ϕ + r₂ • ψ	⊢ span R {generator (span R {a, ⇑ψ ⟨y, _⟩})} = span R {generator (ϕ.submodule_image N)}		R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩	⊢ (span R {a, ⇑ψ ⟨y, _⟩}).is_principal		R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩	⊢ generator (ϕ.submodule_image N) ∈ span R {a, ⇑ψ ⟨y, _⟩}
4 goals	R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩,	r₁ r₂ : R,	d_eq : d = r₁ * a + r₂ * ⇑ψ ⟨y, _⟩,	ψ' : ↥O →ₗ[R] R := r₁ • ϕ + r₂ • ψ	⊢ span R {d} ≤ ψ'.submodule_image N		R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩,	r₁ r₂ : R,	d_eq : d = r₁ * a + r₂ * ⇑ψ ⟨y, _⟩,	ψ' : ↥O →ₗ[R] R := r₁ • ϕ + r₂ • ψ,	this : span R {d} ≤ ψ'.submodule_image N	⊢ span R {generator (span R {a, ⇑ψ ⟨y, _⟩})} = span R {generator (ϕ.submodule_image N)}		R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩	⊢ (span R {a, ⇑ψ ⟨y, _⟩}).is_principal		R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩	⊢ generator (ϕ.submodule_image N) ∈ span R {a, ⇑ψ ⟨y, _⟩}
4 goals	R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩,	r₁ r₂ : R,	d_eq : d = r₁ * a + r₂ * ⇑ψ ⟨y, _⟩,	ψ' : ↥O →ₗ[R] R := r₁ • ϕ + r₂ • ψ	⊢ ∃ (y : M) (yN : y ∈ N), ⇑ψ' ⟨y, _⟩ = d		R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩,	r₁ r₂ : R,	d_eq : d = r₁ * a + r₂ * ⇑ψ ⟨y, _⟩,	ψ' : ↥O →ₗ[R] R := r₁ • ϕ + r₂ • ψ,	this : span R {d} ≤ ψ'.submodule_image N	⊢ span R {generator (span R {a, ⇑ψ ⟨y, _⟩})} = span R {generator (ϕ.submodule_image N)}		R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩	⊢ (span R {a, ⇑ψ ⟨y, _⟩}).is_principal		R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩	⊢ generator (ϕ.submodule_image N) ∈ span R {a, ⇑ψ ⟨y, _⟩}
4 goals	R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩,	r₁ r₂ : R,	d_eq : d = r₁ * a + r₂ * ⇑ψ ⟨y, _⟩,	ψ' : ↥O →ₗ[R] R := r₁ • ϕ + r₂ • ψ	⊢ ⇑ψ' ⟨y, _⟩ = d		R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩,	r₁ r₂ : R,	d_eq : d = r₁ * a + r₂ * ⇑ψ ⟨y, _⟩,	ψ' : ↥O →ₗ[R] R := r₁ • ϕ + r₂ • ψ,	this : span R {d} ≤ ψ'.submodule_image N	⊢ span R {generator (span R {a, ⇑ψ ⟨y, _⟩})} = span R {generator (ϕ.submodule_image N)}		R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩	⊢ (span R {a, ⇑ψ ⟨y, _⟩}).is_principal		R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩	⊢ generator (ϕ.submodule_image N) ∈ span R {a, ⇑ψ ⟨y, _⟩}
4 goals	R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩,	r₁ r₂ : R,	d_eq : d = r₁ * a + r₂ * ⇑ψ ⟨y, _⟩,	ψ' : ↥O →ₗ[R] R := r₁ • ϕ + r₂ • ψ	⊢ r₁ * ⇑ϕ ⟨y, _⟩ + r₂ * ⇑ψ ⟨y, _⟩ = d		R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩,	r₁ r₂ : R,	d_eq : d = r₁ * a + r₂ * ⇑ψ ⟨y, _⟩,	ψ' : ↥O →ₗ[R] R := r₁ • ϕ + r₂ • ψ,	this : span R {d} ≤ ψ'.submodule_image N	⊢ span R {generator (span R {a, ⇑ψ ⟨y, _⟩})} = span R {generator (ϕ.submodule_image N)}		R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩	⊢ (span R {a, ⇑ψ ⟨y, _⟩}).is_principal		R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩	⊢ generator (ϕ.submodule_image N) ∈ span R {a, ⇑ψ ⟨y, _⟩}
3 goals	R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩,	r₁ r₂ : R,	d_eq : d = r₁ * a + r₂ * ⇑ψ ⟨y, _⟩,	ψ' : ↥O →ₗ[R] R := r₁ • ϕ + r₂ • ψ,	this : span R {d} ≤ ψ'.submodule_image N	⊢ span R {generator (span R {a, ⇑ψ ⟨y, _⟩})} = span R {generator (ϕ.submodule_image N)}		R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩	⊢ (span R {a, ⇑ψ ⟨y, _⟩}).is_principal		R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩	⊢ generator (ϕ.submodule_image N) ∈ span R {a, ⇑ψ ⟨y, _⟩}
2 goals	R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩,	r₁ r₂ : R,	d_eq : d = r₁ * a + r₂ * ⇑ψ ⟨y, _⟩,	ψ' : ↥O →ₗ[R] R := r₁ • ϕ + r₂ • ψ,	this : span R {d} ≤ ψ'.submodule_image N	⊢ ψ'.submodule_image N = span R {generator (ϕ.submodule_image N)}		R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩	⊢ generator (ϕ.submodule_image N) ∈ span R {a, ⇑ψ ⟨y, _⟩}
2 goals	R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩,	r₁ r₂ : R,	d_eq : d = r₁ * a + r₂ * ⇑ψ ⟨y, _⟩,	ψ' : ↥O →ₗ[R] R := r₁ • ϕ + r₂ • ψ,	this : span R {d} ≤ ψ'.submodule_image N	⊢ ψ'.submodule_image N = ϕ.submodule_image N		R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩	⊢ generator (ϕ.submodule_image N) ∈ span R {a, ⇑ψ ⟨y, _⟩}
2 goals	R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩,	r₁ r₂ : R,	d_eq : d = r₁ * a + r₂ * ⇑ψ ⟨y, _⟩,	ψ' : ↥O →ₗ[R] R := r₁ • ϕ + r₂ • ψ,	this : span R {d} ≤ ψ'.submodule_image N	⊢ ϕ.submodule_image N ≤ span R {d}		R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩	⊢ generator (ϕ.submodule_image N) ∈ span R {a, ⇑ψ ⟨y, _⟩}
2 goals	R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩,	r₁ r₂ : R,	d_eq : d = r₁ * a + r₂ * ⇑ψ ⟨y, _⟩,	ψ' : ↥O →ₗ[R] R := r₁ • ϕ + r₂ • ψ,	this : span R {d} ≤ ψ'.submodule_image N	⊢ span R {generator (ϕ.submodule_image N)} ≤ span R {d}		R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩	⊢ generator (ϕ.submodule_image N) ∈ span R {a, ⇑ψ ⟨y, _⟩}
R : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : is_principal_ideal_ring R,	M : Type u_3,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	N O : submodule R M,	hNO : N ≤ O,	ϕ : ↥O →ₗ[R] R,	hϕ :	  ∀ (ψ : ↥O →ₗ[R] R),	    ϕ.submodule_image N ≤ ψ.submodule_image N → ψ.submodule_image N = ϕ.submodule_image N,	_inst_6 : (ϕ.submodule_image N).is_principal,	y : M,	yN : y ∈ N,	ϕy_eq : ⇑ϕ ⟨y, _⟩ = generator (ϕ.submodule_image N),	ψ : ↥O →ₗ[R] R,	a : R := generator (ϕ.submodule_image N),	d : R := generator (span R {a, ⇑ψ ⟨y, _⟩}),	d_dvd_left : d ∣ a,	d_dvd_right : d ∣ ⇑ψ ⟨y, _⟩	⊢ generator (ϕ.submodule_image N) ∈ span R {a, ⇑ψ ⟨y, _⟩}
⊢ ∀ (R : Type u) [_inst_1 : ring R] [_inst_2 : rank_condition R] {α : Type u_1} {β : Type u_2}	  [_inst_3 : fintype α] [_inst_4 : fintype β] (f : (α → R) →ₗ[R] β → R),	    surjective ⇑f → fintype.card β ≤ fintype.card α
R : Type u,	_inst_1 : ring R,	_inst_2 : rank_condition R,	α : Type u_1,	β : Type u_2,	_inst_3 : fintype α,	_inst_4 : fintype β,	f : (α → R) →ₗ[R] β → R,	i : surjective ⇑f	⊢ fintype.card β ≤ fintype.card α
R : Type u,	_inst_1 : ring R,	_inst_2 : rank_condition R,	α : Type u_1,	β : Type u_2,	_inst_3 : fintype α,	_inst_4 : fintype β,	f : (α → R) →ₗ[R] β → R,	i : surjective ⇑f,	P : (fin (fintype.card α) → R) ≃ₗ[R] α → R := linear_equiv.fun_congr_left R R (fintype.equiv_fin α)	⊢ fintype.card β ≤ fintype.card α
R : Type u,	_inst_1 : ring R,	_inst_2 : rank_condition R,	α : Type u_1,	β : Type u_2,	_inst_3 : fintype α,	_inst_4 : fintype β,	f : (α → R) →ₗ[R] β → R,	i : surjective ⇑f,	P : (fin (fintype.card α) → R) ≃ₗ[R] α → R := linear_equiv.fun_congr_left R R (fintype.equiv_fin α),	Q : (fin (fintype.card β) → R) ≃ₗ[R] β → R := linear_equiv.fun_congr_left R R (fintype.equiv_fin β)	⊢ fintype.card β ≤ fintype.card α
⊢ ∀ {F : Type u} [_inst_1 : decidable_eq F] [_inst_2 : field F] (s : finset F) (x : F), eval x (basis s x) = 1
F : Type u,	_inst_1 : decidable_eq F,	_inst_2 : field F,	s : finset F,	x : F	⊢ eval x (basis s x) = 1
F : Type u,	_inst_1 : decidable_eq F,	_inst_2 : field F,	s : finset F,	x : F	⊢ ∀ (x_1 : F), x_1 ∈ s.erase x → eval x (⇑C (x - x_1)⁻¹ * (X - ⇑C x_1)) = 1
F : Type u,	_inst_1 : decidable_eq F,	_inst_2 : field F,	s : finset F,	x y : F,	hy : y ∈ s.erase x	⊢ eval x (⇑C (x - y)⁻¹ * (X - ⇑C y)) = 1
F : Type u,	_inst_1 : decidable_eq F,	_inst_2 : field F,	s : finset F,	x y : F,	hy : y ∈ s.erase x	⊢ (x - y)⁻¹ * (x - y) = 1
⊢ ∀ {ι : Type u_1} {R : Type u_3} {M : Type u_5} {v : ι → M} [_inst_1 : ring R] [_inst_2 : add_comm_group M]	  [_inst_5 : module R M] (hv : linear_independent R v) {l : ι →₀ R} {x : ↥(span R (range v))},	    ⇑(finsupp.total ι M R v) l = ↑x → ⇑(hv.repr) x = l
ι : Type u_1,	R : Type u_3,	M : Type u_5,	v : ι → M,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_5 : module R M,	hv : linear_independent R v,	l : ι →₀ R,	x : ↥(span R (range v)),	eq : ⇑(finsupp.total ι M R v) l = ↑x	⊢ ⇑(hv.repr) x = l
ι : Type u_1,	R : Type u_3,	M : Type u_5,	v : ι → M,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_5 : module R M,	hv : linear_independent R v,	l : ι →₀ R,	x : ↥(span R (range v)),	eq : ⇑(finsupp.total ι M R v) l = ↑x,	this : ↑(⇑↑(hv.total_equiv) l) = ⇑(finsupp.total ι M R v) l	⊢ ⇑(hv.repr) x = l
2 goals	ι : Type u_1,	R : Type u_3,	M : Type u_5,	v : ι → M,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_5 : module R M,	hv : linear_independent R v,	l : ι →₀ R,	x : ↥(span R (range v)),	eq : ⇑(finsupp.total ι M R v) l = ↑x,	this : ↑(⇑↑(hv.total_equiv) l) = ⇑(finsupp.total ι M R v) l	⊢ ⇑↑(hv.total_equiv) l = x		ι : Type u_1,	R : Type u_3,	M : Type u_5,	v : ι → M,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_5 : module R M,	hv : linear_independent R v,	l : ι →₀ R,	x : ↥(span R (range v)),	eq : ⇑(finsupp.total ι M R v) l = ↑x,	this : ↑(⇑↑(hv.total_equiv) l) = ⇑(finsupp.total ι M R v) l,	this : ⇑↑(hv.total_equiv) l = x	⊢ ⇑(hv.repr) x = l
2 goals	ι : Type u_1,	R : Type u_3,	M : Type u_5,	v : ι → M,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_5 : module R M,	hv : linear_independent R v,	l : ι →₀ R,	x : ↥(span R (range v)),	eq : ⇑(finsupp.total ι M R v) l = ↑x,	this : ↑(⇑↑(hv.total_equiv) l) = ↑x	⊢ ⇑↑(hv.total_equiv) l = x		ι : Type u_1,	R : Type u_3,	M : Type u_5,	v : ι → M,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_5 : module R M,	hv : linear_independent R v,	l : ι →₀ R,	x : ↥(span R (range v)),	eq : ⇑(finsupp.total ι M R v) l = ↑x,	this : ↑(⇑↑(hv.total_equiv) l) = ⇑(finsupp.total ι M R v) l,	this : ⇑↑(hv.total_equiv) l = x	⊢ ⇑(hv.repr) x = l
ι : Type u_1,	R : Type u_3,	M : Type u_5,	v : ι → M,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_5 : module R M,	hv : linear_independent R v,	l : ι →₀ R,	x : ↥(span R (range v)),	eq : ⇑(finsupp.total ι M R v) l = ↑x,	this : ↑(⇑↑(hv.total_equiv) l) = ⇑(finsupp.total ι M R v) l,	this : ⇑↑(hv.total_equiv) l = x	⊢ ⇑(hv.repr) x = l
ι : Type u_1,	R : Type u_3,	M : Type u_5,	v : ι → M,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_5 : module R M,	hv : linear_independent R v,	l : ι →₀ R,	x : ↥(span R (range v)),	eq : ⇑(finsupp.total ι M R v) l = ↑x,	this : ↑(⇑↑(hv.total_equiv) l) = ⇑(finsupp.total ι M R v) l,	this : ⇑↑(hv.total_equiv) l = x	⊢ ⇑(hv.repr) x = ⇑(hv.total_equiv.symm) (⇑(hv.total_equiv) l)
ι : Type u_1,	R : Type u_3,	M : Type u_5,	v : ι → M,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_5 : module R M,	hv : linear_independent R v,	l : ι →₀ R,	x : ↥(span R (range v)),	eq : ⇑(finsupp.total ι M R v) l = ↑x,	this : ↑(⇑↑(hv.total_equiv) l) = ⇑(finsupp.total ι M R v) l,	this : ⇑↑(hv.total_equiv) l = x	⊢ ⇑(hv.repr) (⇑↑(hv.total_equiv) l) = ⇑(hv.total_equiv.symm) (⇑(hv.total_equiv) l)
⊢ ∀ {ι : Type u_1} {R : Type u_5} {M : Type u_6} [_inst_1 : comm_ring R] [_inst_2 : add_comm_group M]	  [_inst_3 : module R M] (e : basis ι R M) [_inst_4 : decidable_eq ι], e.to_matrix ⇑e = 1
ι : Type u_1,	R : Type u_5,	M : Type u_6,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	e : basis ι R M,	_inst_4 : decidable_eq ι	⊢ e.to_matrix ⇑e = 1
ι : Type u_1,	R : Type u_5,	M : Type u_6,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	e : basis ι R M,	_inst_4 : decidable_eq ι	⊢ (λ (i j : ι), ⇑(⇑(e.repr) (⇑e j)) i) = 1
ι : Type u_1,	R : Type u_5,	M : Type u_6,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	e : basis ι R M,	_inst_4 : decidable_eq ι,	i j : ι	⊢ ⇑(⇑(e.repr) (⇑e j)) i = 1 i j
⊢ ∀ {α : Type u_1} (n : Type u_2) [_inst_1 : semiring α] [_inst_2 : decidable_eq n] [_inst_3 : add_group n]	  [_inst_4 : fintype n] (a : α), circulant (pi.single 0 a) = ⇑(scalar n) a
α : Type u_1,	n : Type u_2,	_inst_1 : semiring α,	_inst_2 : decidable_eq n,	_inst_3 : add_group n,	_inst_4 : fintype n,	a : α	⊢ circulant (pi.single 0 a) = ⇑(scalar n) a
α : Type u_1,	n : Type u_2,	_inst_1 : semiring α,	_inst_2 : decidable_eq n,	_inst_3 : add_group n,	_inst_4 : fintype n,	a : α,	i j : n	⊢ circulant (pi.single 0 a) i j = ⇑(scalar n) a i j
⊢ ∀ {α : Type u_1} {n : Type u_4} {m : Type u_5} [_inst_1 : mul_zero_class α] {A : matrix m m α}	  {B : matrix n n α}, A.is_diag → B.is_diag → (kronecker_map has_mul.mul A B).is_diag
α : Type u_1,	n : Type u_4,	m : Type u_5,	_inst_1 : mul_zero_class α,	A : matrix m m α,	B : matrix n n α,	hA : A.is_diag,	hB : B.is_diag	⊢ (kronecker_map has_mul.mul A B).is_diag
α : Type u_1,	n : Type u_4,	m : Type u_5,	_inst_1 : mul_zero_class α,	A : matrix m m α,	B : matrix n n α,	hA : A.is_diag,	hB : B.is_diag,	a : m,	b : n,	c : m,	d : n,	h : (a, b) ≠ (c, d)	⊢ kronecker_map has_mul.mul A B (a, b) (c, d) = 0
α : Type u_1,	n : Type u_4,	m : Type u_5,	_inst_1 : mul_zero_class α,	A : matrix m m α,	B : matrix n n α,	hA : A.is_diag,	hB : B.is_diag,	a : m,	b : n,	c : m,	d : n,	h : ¬a = c ∨ ¬b = d	⊢ kronecker_map has_mul.mul A B (a, b) (c, d) = 0
2 goals	case or.inl	α : Type u_1,	n : Type u_4,	m : Type u_5,	_inst_1 : mul_zero_class α,	A : matrix m m α,	B : matrix n n α,	hA : A.is_diag,	hB : B.is_diag,	a : m,	b : n,	c : m,	d : n,	hac : ¬a = c	⊢ kronecker_map has_mul.mul A B (a, b) (c, d) = 0		case or.inr	α : Type u_1,	n : Type u_4,	m : Type u_5,	_inst_1 : mul_zero_class α,	A : matrix m m α,	B : matrix n n α,	hA : A.is_diag,	hB : B.is_diag,	a : m,	b : n,	c : m,	d : n,	hbd : ¬b = d	⊢ kronecker_map has_mul.mul A B (a, b) (c, d) = 0
case or.inr	α : Type u_1,	n : Type u_4,	m : Type u_5,	_inst_1 : mul_zero_class α,	A : matrix m m α,	B : matrix n n α,	hA : A.is_diag,	hB : B.is_diag,	a : m,	b : n,	c : m,	d : n,	hbd : ¬b = d	⊢ kronecker_map has_mul.mul A B (a, b) (c, d) = 0
⊢ ∀ {R : Type u_1} [_inst_1 : comm_ring R] {l : Type u_2} {m : Type u_3} {n : Type u_4} [_inst_2 : fintype n]	  [_inst_3 : fintype m] [_inst_4 : decidable_eq n] {M₁ : Type u_5} {M₂ : Type u_6} [_inst_5 : add_comm_group M₁]	  [_inst_6 : add_comm_group M₂] [_inst_7 : module R M₁] [_inst_8 : module R M₂] (v₁ : basis n R M₁)	  (v₂ : basis m R M₂) {M₃ : Type u_7} [_inst_9 : add_comm_group M₃] [_inst_10 : module R M₃]	  (v₃ : basis l R M₃) [_inst_11 : fintype l] [_inst_12 : decidable_eq m] (f : M₂ →ₗ[R] M₃)	  (g : M₁ →ₗ[R] M₂),	    ⇑(to_matrix v₁ v₃) (f.comp g) = (⇑(to_matrix v₂ v₃) f).mul (⇑(to_matrix v₁ v₂) g)
R : Type u_1,	_inst_1 : comm_ring R,	l : Type u_2,	m : Type u_3,	n : Type u_4,	_inst_2 : fintype n,	_inst_3 : fintype m,	_inst_4 : decidable_eq n,	M₁ : Type u_5,	M₂ : Type u_6,	_inst_5 : add_comm_group M₁,	_inst_6 : add_comm_group M₂,	_inst_7 : module R M₁,	_inst_8 : module R M₂,	v₁ : basis n R M₁,	v₂ : basis m R M₂,	M₃ : Type u_7,	_inst_9 : add_comm_group M₃,	_inst_10 : module R M₃,	v₃ : basis l R M₃,	_inst_11 : fintype l,	_inst_12 : decidable_eq m,	f : M₂ →ₗ[R] M₃,	g : M₁ →ₗ[R] M₂	⊢ ⇑(to_matrix v₁ v₃) (f.comp g) = (⇑(to_matrix v₂ v₃) f).mul (⇑(to_matrix v₁ v₂) g)
⊢ ∀ {n : Type u_1} {p : Type u_2} {R : Type u₂} [_inst_2 : decidable_eq n] [_inst_3 : decidable_eq p]	  [_inst_4 : comm_ring R] [_inst_5 : fintype n] [_inst_6 : fintype p] (e : n ≃ p)	  (L : list (transvection_struct n R)),	    (list.map (transvection_struct.to_matrix ∘ transvection_struct.reindex_equiv e) L).prod =	      ⇑(reindex_alg_equiv R e) (list.map transvection_struct.to_matrix L).prod
n : Type u_1,	p : Type u_2,	R : Type u₂,	_inst_2 : decidable_eq n,	_inst_3 : decidable_eq p,	_inst_4 : comm_ring R,	_inst_5 : fintype n,	_inst_6 : fintype p,	e : n ≃ p,	L : list (transvection_struct n R)	⊢ (list.map (transvection_struct.to_matrix ∘ transvection_struct.reindex_equiv e) L).prod =	    ⇑(reindex_alg_equiv R e) (list.map transvection_struct.to_matrix L).prod
2 goals	case list.nil	n : Type u_1,	p : Type u_2,	R : Type u₂,	_inst_2 : decidable_eq n,	_inst_3 : decidable_eq p,	_inst_4 : comm_ring R,	_inst_5 : fintype n,	_inst_6 : fintype p,	e : n ≃ p	⊢ (list.map (transvection_struct.to_matrix ∘ transvection_struct.reindex_equiv e) list.nil).prod =	    ⇑(reindex_alg_equiv R e) (list.map transvection_struct.to_matrix list.nil).prod		case list.cons	n : Type u_1,	p : Type u_2,	R : Type u₂,	_inst_2 : decidable_eq n,	_inst_3 : decidable_eq p,	_inst_4 : comm_ring R,	_inst_5 : fintype n,	_inst_6 : fintype p,	e : n ≃ p,	t : transvection_struct n R,	L : list (transvection_struct n R),	IH :	  (list.map (transvection_struct.to_matrix ∘ transvection_struct.reindex_equiv e) L).prod =	    ⇑(reindex_alg_equiv R e) (list.map transvection_struct.to_matrix L).prod	⊢ (list.map (transvection_struct.to_matrix ∘ transvection_struct.reindex_equiv e) (t :: L)).prod =	    ⇑(reindex_alg_equiv R e) (list.map transvection_struct.to_matrix (t :: L)).prod
case list.cons	n : Type u_1,	p : Type u_2,	R : Type u₂,	_inst_2 : decidable_eq n,	_inst_3 : decidable_eq p,	_inst_4 : comm_ring R,	_inst_5 : fintype n,	_inst_6 : fintype p,	e : n ≃ p,	t : transvection_struct n R,	L : list (transvection_struct n R),	IH :	  (list.map (transvection_struct.to_matrix ∘ transvection_struct.reindex_equiv e) L).prod =	    ⇑(reindex_alg_equiv R e) (list.map transvection_struct.to_matrix L).prod	⊢ (list.map (transvection_struct.to_matrix ∘ transvection_struct.reindex_equiv e) (t :: L)).prod =	    ⇑(reindex_alg_equiv R e) (list.map transvection_struct.to_matrix (t :: L)).prod
case list.cons	n : Type u_1,	p : Type u_2,	R : Type u₂,	_inst_2 : decidable_eq n,	_inst_3 : decidable_eq p,	_inst_4 : comm_ring R,	_inst_5 : fintype n,	_inst_6 : fintype p,	e : n ≃ p,	t : transvection_struct n R,	L : list (transvection_struct n R),	IH :	  (list.map (transvection_struct.to_matrix ∘ transvection_struct.reindex_equiv e) L).prod =	    ⇑(reindex_alg_equiv R e) (list.map transvection_struct.to_matrix L).prod	⊢ (⇑(reindex e e) t.to_matrix).mul (⇑(reindex e e) (list.map transvection_struct.to_matrix L).prod) =	    ⇑(reindex e e) (t.to_matrix.mul (list.map transvection_struct.to_matrix L).prod)
⊢ ∀ {𝕜 : Type u_3} [_inst_1 : field 𝕜] (n : Type) [_inst_7 : fintype n] [_inst_8 : decidable_eq n]	  (M : matrix n n 𝕜),	    ∃ (L L' : list (transvection_struct n 𝕜)) (D : n → 𝕜),	      ((list.map to_matrix L).prod.mul M).mul (list.map to_matrix L').prod = diagonal D
𝕜 : Type u_3,	_inst_1 : field 𝕜,	n : Type,	_inst_7 : fintype n,	_inst_8 : decidable_eq n,	M : matrix n n 𝕜	⊢ ∃ (L L' : list (transvection_struct n 𝕜)) (D : n → 𝕜),	    ((list.map to_matrix L).prod.mul M).mul (list.map to_matrix L').prod = diagonal D
2 goals	case nat.zero	𝕜 : Type u_3,	_inst_1 : field 𝕜,	n : Type,	M : matrix n n 𝕜,	_inst_7 : fintype n,	_inst_8 : decidable_eq n,	hn : fintype.card n = 0	⊢ ∃ (L L' : list (transvection_struct n 𝕜)) (D : n → 𝕜),	    ((list.map to_matrix L).prod.mul M).mul (list.map to_matrix L').prod = diagonal D		case nat.succ	𝕜 : Type u_3,	_inst_1 : field 𝕜,	r : ℕ,	IH :	  ∀ (n : Type) (M : matrix n n 𝕜) [_inst_7 : fintype n] [_inst_8 : decidable_eq n],	    fintype.card n = r →	    (∃ (L L' : list (transvection_struct n 𝕜)) (D : n → 𝕜),	       ((list.map to_matrix L).prod.mul M).mul (list.map to_matrix L').prod = diagonal D),	n : Type,	M : matrix n n 𝕜,	_inst_7 : fintype n,	_inst_8 : decidable_eq n,	hn : fintype.card n = r.succ	⊢ ∃ (L L' : list (transvection_struct n 𝕜)) (D : n → 𝕜),	    ((list.map to_matrix L).prod.mul M).mul (list.map to_matrix L').prod = diagonal D
2 goals	𝕜 : Type u_3,	_inst_1 : field 𝕜,	n : Type,	M : matrix n n 𝕜,	_inst_7 : fintype n,	_inst_8 : decidable_eq n,	hn : fintype.card n = 0	⊢ ((list.map to_matrix list.nil).prod.mul M).mul (list.map to_matrix list.nil).prod = diagonal (λ (_x : n), 1)		case nat.succ	𝕜 : Type u_3,	_inst_1 : field 𝕜,	r : ℕ,	IH :	  ∀ (n : Type) (M : matrix n n 𝕜) [_inst_7 : fintype n] [_inst_8 : decidable_eq n],	    fintype.card n = r →	    (∃ (L L' : list (transvection_struct n 𝕜)) (D : n → 𝕜),	       ((list.map to_matrix L).prod.mul M).mul (list.map to_matrix L').prod = diagonal D),	n : Type,	M : matrix n n 𝕜,	_inst_7 : fintype n,	_inst_8 : decidable_eq n,	hn : fintype.card n = r.succ	⊢ ∃ (L L' : list (transvection_struct n 𝕜)) (D : n → 𝕜),	    ((list.map to_matrix L).prod.mul M).mul (list.map to_matrix L').prod = diagonal D
2 goals	𝕜 : Type u_3,	_inst_1 : field 𝕜,	n : Type,	M : matrix n n 𝕜,	_inst_7 : fintype n,	_inst_8 : decidable_eq n,	hn : fintype.card n = 0,	i j : n	⊢ ((list.map to_matrix list.nil).prod.mul M).mul (list.map to_matrix list.nil).prod i j =	    diagonal (λ (_x : n), 1) i j		case nat.succ	𝕜 : Type u_3,	_inst_1 : field 𝕜,	r : ℕ,	IH :	  ∀ (n : Type) (M : matrix n n 𝕜) [_inst_7 : fintype n] [_inst_8 : decidable_eq n],	    fintype.card n = r →	    (∃ (L L' : list (transvection_struct n 𝕜)) (D : n → 𝕜),	       ((list.map to_matrix L).prod.mul M).mul (list.map to_matrix L').prod = diagonal D),	n : Type,	M : matrix n n 𝕜,	_inst_7 : fintype n,	_inst_8 : decidable_eq n,	hn : fintype.card n = r.succ	⊢ ∃ (L L' : list (transvection_struct n 𝕜)) (D : n → 𝕜),	    ((list.map to_matrix L).prod.mul M).mul (list.map to_matrix L').prod = diagonal D
2 goals	𝕜 : Type u_3,	_inst_1 : field 𝕜,	n : Type,	M : matrix n n 𝕜,	_inst_7 : fintype n,	_inst_8 : decidable_eq n,	i j : n,	hn : is_empty n	⊢ ((list.map to_matrix list.nil).prod.mul M).mul (list.map to_matrix list.nil).prod i j =	    diagonal (λ (_x : n), 1) i j		case nat.succ	𝕜 : Type u_3,	_inst_1 : field 𝕜,	r : ℕ,	IH :	  ∀ (n : Type) (M : matrix n n 𝕜) [_inst_7 : fintype n] [_inst_8 : decidable_eq n],	    fintype.card n = r →	    (∃ (L L' : list (transvection_struct n 𝕜)) (D : n → 𝕜),	       ((list.map to_matrix L).prod.mul M).mul (list.map to_matrix L').prod = diagonal D),	n : Type,	M : matrix n n 𝕜,	_inst_7 : fintype n,	_inst_8 : decidable_eq n,	hn : fintype.card n = r.succ	⊢ ∃ (L L' : list (transvection_struct n 𝕜)) (D : n → 𝕜),	    ((list.map to_matrix L).prod.mul M).mul (list.map to_matrix L').prod = diagonal D
case nat.succ	𝕜 : Type u_3,	_inst_1 : field 𝕜,	r : ℕ,	IH :	  ∀ (n : Type) (M : matrix n n 𝕜) [_inst_7 : fintype n] [_inst_8 : decidable_eq n],	    fintype.card n = r →	    (∃ (L L' : list (transvection_struct n 𝕜)) (D : n → 𝕜),	       ((list.map to_matrix L).prod.mul M).mul (list.map to_matrix L').prod = diagonal D),	n : Type,	M : matrix n n 𝕜,	_inst_7 : fintype n,	_inst_8 : decidable_eq n,	hn : fintype.card n = r.succ	⊢ ∃ (L L' : list (transvection_struct n 𝕜)) (D : n → 𝕜),	    ((list.map to_matrix L).prod.mul M).mul (list.map to_matrix L').prod = diagonal D
2 goals	𝕜 : Type u_3,	_inst_1 : field 𝕜,	r : ℕ,	IH :	  ∀ (n : Type) (M : matrix n n 𝕜) [_inst_7 : fintype n] [_inst_8 : decidable_eq n],	    fintype.card n = r →	    (∃ (L L' : list (transvection_struct n 𝕜)) (D : n → 𝕜),	       ((list.map to_matrix L).prod.mul M).mul (list.map to_matrix L').prod = diagonal D),	n : Type,	M : matrix n n 𝕜,	_inst_7 : fintype n,	_inst_8 : decidable_eq n,	hn : fintype.card n = r.succ	⊢ n ≃ fin r ⊕ unit		𝕜 : Type u_3,	_inst_1 : field 𝕜,	r : ℕ,	IH :	  ∀ (n : Type) (M : matrix n n 𝕜) [_inst_7 : fintype n] [_inst_8 : decidable_eq n],	    fintype.card n = r →	    (∃ (L L' : list (transvection_struct n 𝕜)) (D : n → 𝕜),	       ((list.map to_matrix L).prod.mul M).mul (list.map to_matrix L').prod = diagonal D),	n : Type,	M : matrix n n 𝕜,	_inst_7 : fintype n,	_inst_8 : decidable_eq n,	hn : fintype.card n = r.succ,	e : n ≃ fin r ⊕ unit	⊢ ∃ (L L' : list (transvection_struct n 𝕜)) (D : n → 𝕜),	    ((list.map to_matrix L).prod.mul M).mul (list.map to_matrix L').prod = diagonal D
2 goals	𝕜 : Type u_3,	_inst_1 : field 𝕜,	r : ℕ,	IH :	  ∀ (n : Type) (M : matrix n n 𝕜) [_inst_7 : fintype n] [_inst_8 : decidable_eq n],	    fintype.card n = r →	    (∃ (L L' : list (transvection_struct n 𝕜)) (D : n → 𝕜),	       ((list.map to_matrix L).prod.mul M).mul (list.map to_matrix L').prod = diagonal D),	n : Type,	M : matrix n n 𝕜,	_inst_7 : fintype n,	_inst_8 : decidable_eq n,	hn : fintype.card n = r.succ	⊢ fintype.card n = fintype.card (fin r ⊕ unit)		𝕜 : Type u_3,	_inst_1 : field 𝕜,	r : ℕ,	IH :	  ∀ (n : Type) (M : matrix n n 𝕜) [_inst_7 : fintype n] [_inst_8 : decidable_eq n],	    fintype.card n = r →	    (∃ (L L' : list (transvection_struct n 𝕜)) (D : n → 𝕜),	       ((list.map to_matrix L).prod.mul M).mul (list.map to_matrix L').prod = diagonal D),	n : Type,	M : matrix n n 𝕜,	_inst_7 : fintype n,	_inst_8 : decidable_eq n,	hn : fintype.card n = r.succ,	e : n ≃ fin r ⊕ unit	⊢ ∃ (L L' : list (transvection_struct n 𝕜)) (D : n → 𝕜),	    ((list.map to_matrix L).prod.mul M).mul (list.map to_matrix L').prod = diagonal D
2 goals	𝕜 : Type u_3,	_inst_1 : field 𝕜,	r : ℕ,	IH :	  ∀ (n : Type) (M : matrix n n 𝕜) [_inst_7 : fintype n] [_inst_8 : decidable_eq n],	    fintype.card n = r →	    (∃ (L L' : list (transvection_struct n 𝕜)) (D : n → 𝕜),	       ((list.map to_matrix L).prod.mul M).mul (list.map to_matrix L').prod = diagonal D),	n : Type,	M : matrix n n 𝕜,	_inst_7 : fintype n,	_inst_8 : decidable_eq n,	hn : fintype.card n = r.succ	⊢ r.succ = fintype.card (fin r ⊕ unit)		𝕜 : Type u_3,	_inst_1 : field 𝕜,	r : ℕ,	IH :	  ∀ (n : Type) (M : matrix n n 𝕜) [_inst_7 : fintype n] [_inst_8 : decidable_eq n],	    fintype.card n = r →	    (∃ (L L' : list (transvection_struct n 𝕜)) (D : n → 𝕜),	       ((list.map to_matrix L).prod.mul M).mul (list.map to_matrix L').prod = diagonal D),	n : Type,	M : matrix n n 𝕜,	_inst_7 : fintype n,	_inst_8 : decidable_eq n,	hn : fintype.card n = r.succ,	e : n ≃ fin r ⊕ unit	⊢ ∃ (L L' : list (transvection_struct n 𝕜)) (D : n → 𝕜),	    ((list.map to_matrix L).prod.mul M).mul (list.map to_matrix L').prod = diagonal D
2 goals	𝕜 : Type u_3,	_inst_1 : field 𝕜,	r : ℕ,	IH :	  ∀ (n : Type) (M : matrix n n 𝕜) [_inst_7 : fintype n] [_inst_8 : decidable_eq n],	    fintype.card n = r →	    (∃ (L L' : list (transvection_struct n 𝕜)) (D : n → 𝕜),	       ((list.map to_matrix L).prod.mul M).mul (list.map to_matrix L').prod = diagonal D),	n : Type,	M : matrix n n 𝕜,	_inst_7 : fintype n,	_inst_8 : decidable_eq n,	hn : fintype.card n = r.succ	⊢ r = (fintype.card (fin r)).add (list.nil.length.add 0)		𝕜 : Type u_3,	_inst_1 : field 𝕜,	r : ℕ,	IH :	  ∀ (n : Type) (M : matrix n n 𝕜) [_inst_7 : fintype n] [_inst_8 : decidable_eq n],	    fintype.card n = r →	    (∃ (L L' : list (transvection_struct n 𝕜)) (D : n → 𝕜),	       ((list.map to_matrix L).prod.mul M).mul (list.map to_matrix L').prod = diagonal D),	n : Type,	M : matrix n n 𝕜,	_inst_7 : fintype n,	_inst_8 : decidable_eq n,	hn : fintype.card n = r.succ,	e : n ≃ fin r ⊕ unit	⊢ ∃ (L L' : list (transvection_struct n 𝕜)) (D : n → 𝕜),	    ((list.map to_matrix L).prod.mul M).mul (list.map to_matrix L').prod = diagonal D
𝕜 : Type u_3,	_inst_1 : field 𝕜,	r : ℕ,	IH :	  ∀ (n : Type) (M : matrix n n 𝕜) [_inst_7 : fintype n] [_inst_8 : decidable_eq n],	    fintype.card n = r →	    (∃ (L L' : list (transvection_struct n 𝕜)) (D : n → 𝕜),	       ((list.map to_matrix L).prod.mul M).mul (list.map to_matrix L').prod = diagonal D),	n : Type,	M : matrix n n 𝕜,	_inst_7 : fintype n,	_inst_8 : decidable_eq n,	hn : fintype.card n = r.succ,	e : n ≃ fin r ⊕ unit	⊢ ∃ (L L' : list (transvection_struct n 𝕜)) (D : n → 𝕜),	    ((list.map to_matrix L).prod.mul M).mul (list.map to_matrix L').prod = diagonal D
𝕜 : Type u_3,	_inst_1 : field 𝕜,	r : ℕ,	IH :	  ∀ (n : Type) (M : matrix n n 𝕜) [_inst_7 : fintype n] [_inst_8 : decidable_eq n],	    fintype.card n = r →	    (∃ (L L' : list (transvection_struct n 𝕜)) (D : n → 𝕜),	       ((list.map to_matrix L).prod.mul M).mul (list.map to_matrix L').prod = diagonal D),	n : Type,	M : matrix n n 𝕜,	_inst_7 : fintype n,	_inst_8 : decidable_eq n,	hn : fintype.card n = r.succ,	e : n ≃ fin r ⊕ unit	⊢ ∃ (L L' : list (transvection_struct (fin r ⊕ unit) 𝕜)) (D : fin r ⊕ unit → 𝕜),	    ((list.map to_matrix L).prod.mul (⇑(reindex_alg_equiv 𝕜 e) M)).mul (list.map to_matrix L').prod = diagonal D
⊢ ∀ {R : Type u} {M : Type v} {ι : Type x} [_inst_1 : semiring R] (S : Type u_4) [_inst_8 : fintype ι]	  [_inst_9 : decidable_eq ι] [_inst_10 : semiring S] [_inst_11 : add_comm_monoid M] [_inst_12 : module R M]	  [_inst_13 : module S M] [_inst_14 : smul_comm_class R S M] (f : ι → M) (g : ι → R),	    ⇑(⇑((pi_ring R M ι S).symm) f) g = finset.univ.sum (λ (i : ι), g i • f i)
R : Type u,	M : Type v,	ι : Type x,	_inst_1 : semiring R,	S : Type u_4,	_inst_8 : fintype ι,	_inst_9 : decidable_eq ι,	_inst_10 : semiring S,	_inst_11 : add_comm_monoid M,	_inst_12 : module R M,	_inst_13 : module S M,	_inst_14 : smul_comm_class R S M,	f : ι → M,	g : ι → R	⊢ ⇑(⇑((pi_ring R M ι S).symm) f) g = finset.univ.sum (λ (i : ι), g i • f i)
⊢ ∀ {R : Type u} {M : Type v} {M₂ : Type w} [_inst_1 : semiring R] [_inst_3 : add_comm_monoid M]	  [_inst_4 : add_comm_monoid M₂] [_inst_7 : module R M] [_inst_8 : module R M₂], snd R M M₂ = 0.coprod id
R : Type u,	M : Type v,	M₂ : Type w,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : add_comm_monoid M₂,	_inst_7 : module R M,	_inst_8 : module R M₂	⊢ snd R M M₂ = 0.coprod id
R : Type u,	M : Type v,	M₂ : Type w,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : add_comm_monoid M₂,	_inst_7 : module R M,	_inst_8 : module R M₂,	x : M × M₂	⊢ ⇑(snd R M M₂) x = ⇑(0.coprod id) x
⊢ ∀ {R : Type u} {M : Type v} [_inst_1 : semiring R] [_inst_2 : add_comm_monoid M] [_inst_6 : module R M]	  {M₂ : Type u_1} [_inst_10 : add_comm_group M₂] [_inst_11 : module R M₂] {M₃ : Type u_2}	  [_inst_12 : add_comm_group M₃] [_inst_13 : module R M₃] (f : M →ₗ[R] M₃) (g : M₂ →ₗ[R] M₃),	    disjoint f.range g.range → (f.coprod g).ker = f.ker.prod g.ker
R : Type u,	M : Type v,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_6 : module R M,	M₂ : Type u_1,	_inst_10 : add_comm_group M₂,	_inst_11 : module R M₂,	M₃ : Type u_2,	_inst_12 : add_comm_group M₃,	_inst_13 : module R M₃,	f : M →ₗ[R] M₃,	g : M₂ →ₗ[R] M₃,	hd : disjoint f.range g.range	⊢ (f.coprod g).ker = f.ker.prod g.ker
R : Type u,	M : Type v,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_6 : module R M,	M₂ : Type u_1,	_inst_10 : add_comm_group M₂,	_inst_11 : module R M₂,	M₃ : Type u_2,	_inst_12 : add_comm_group M₃,	_inst_13 : module R M₃,	f : M →ₗ[R] M₃,	g : M₂ →ₗ[R] M₃,	hd : disjoint f.range g.range	⊢ (f.coprod g).ker ≤ f.ker.prod g.ker
R : Type u,	M : Type v,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_6 : module R M,	M₂ : Type u_1,	_inst_10 : add_comm_group M₂,	_inst_11 : module R M₂,	M₃ : Type u_2,	_inst_12 : add_comm_group M₃,	_inst_13 : module R M₃,	f : M →ₗ[R] M₃,	g : M₂ →ₗ[R] M₃,	hd : disjoint f.range g.range,	y : M,	z : M₂,	h : (y, z) ∈ (f.coprod g).ker	⊢ (y, z) ∈ f.ker.prod g.ker
R : Type u,	M : Type v,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_6 : module R M,	M₂ : Type u_1,	_inst_10 : add_comm_group M₂,	_inst_11 : module R M₂,	M₃ : Type u_2,	_inst_12 : add_comm_group M₃,	_inst_13 : module R M₃,	f : M →ₗ[R] M₃,	g : M₂ →ₗ[R] M₃,	hd : disjoint f.range g.range,	y : M,	z : M₂,	h : ⇑f y + ⇑g z = 0	⊢ ⇑f y = 0 ∧ ⇑g z = 0
2 goals	R : Type u,	M : Type v,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_6 : module R M,	M₂ : Type u_1,	_inst_10 : add_comm_group M₂,	_inst_11 : module R M₂,	M₃ : Type u_2,	_inst_12 : add_comm_group M₃,	_inst_13 : module R M₃,	f : M →ₗ[R] M₃,	g : M₂ →ₗ[R] M₃,	hd : disjoint f.range g.range,	y : M,	z : M₂,	h : ⇑f y + ⇑g z = 0	⊢ ⇑f y ∈ f.range ⊓ g.range		R : Type u,	M : Type v,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_6 : module R M,	M₂ : Type u_1,	_inst_10 : add_comm_group M₂,	_inst_11 : module R M₂,	M₃ : Type u_2,	_inst_12 : add_comm_group M₃,	_inst_13 : module R M₃,	f : M →ₗ[R] M₃,	g : M₂ →ₗ[R] M₃,	hd : disjoint f.range g.range,	y : M,	z : M₂,	h : ⇑f y + ⇑g z = 0,	this : ⇑f y ∈ f.range ⊓ g.range	⊢ ⇑f y = 0 ∧ ⇑g z = 0
2 goals	R : Type u,	M : Type v,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_6 : module R M,	M₂ : Type u_1,	_inst_10 : add_comm_group M₂,	_inst_11 : module R M₂,	M₃ : Type u_2,	_inst_12 : add_comm_group M₃,	_inst_13 : module R M₃,	f : M →ₗ[R] M₃,	g : M₂ →ₗ[R] M₃,	hd : disjoint f.range g.range,	y : M,	z : M₂,	h : ⇑f y + ⇑g z = 0	⊢ ∃ (y_1 : M₂), ⇑g y_1 = ⇑f y		R : Type u,	M : Type v,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_6 : module R M,	M₂ : Type u_1,	_inst_10 : add_comm_group M₂,	_inst_11 : module R M₂,	M₃ : Type u_2,	_inst_12 : add_comm_group M₃,	_inst_13 : module R M₃,	f : M →ₗ[R] M₃,	g : M₂ →ₗ[R] M₃,	hd : disjoint f.range g.range,	y : M,	z : M₂,	h : ⇑f y + ⇑g z = 0,	this : ⇑f y ∈ f.range ⊓ g.range	⊢ ⇑f y = 0 ∧ ⇑g z = 0
2 goals	R : Type u,	M : Type v,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_6 : module R M,	M₂ : Type u_1,	_inst_10 : add_comm_group M₂,	_inst_11 : module R M₂,	M₃ : Type u_2,	_inst_12 : add_comm_group M₃,	_inst_13 : module R M₃,	f : M →ₗ[R] M₃,	g : M₂ →ₗ[R] M₃,	hd : disjoint f.range g.range,	y : M,	z : M₂,	h : ⇑f y + ⇑g z = 0	⊢ ⇑g (-z) = ⇑f y		R : Type u,	M : Type v,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_6 : module R M,	M₂ : Type u_1,	_inst_10 : add_comm_group M₂,	_inst_11 : module R M₂,	M₃ : Type u_2,	_inst_12 : add_comm_group M₃,	_inst_13 : module R M₃,	f : M →ₗ[R] M₃,	g : M₂ →ₗ[R] M₃,	hd : disjoint f.range g.range,	y : M,	z : M₂,	h : ⇑f y + ⇑g z = 0,	this : ⇑f y ∈ f.range ⊓ g.range	⊢ ⇑f y = 0 ∧ ⇑g z = 0
R : Type u,	M : Type v,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_6 : module R M,	M₂ : Type u_1,	_inst_10 : add_comm_group M₂,	_inst_11 : module R M₂,	M₃ : Type u_2,	_inst_12 : add_comm_group M₃,	_inst_13 : module R M₃,	f : M →ₗ[R] M₃,	g : M₂ →ₗ[R] M₃,	hd : disjoint f.range g.range,	y : M,	z : M₂,	h : ⇑f y + ⇑g z = 0,	this : ⇑f y ∈ f.range ⊓ g.range	⊢ ⇑f y = 0 ∧ ⇑g z = 0
R : Type u,	M : Type v,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_6 : module R M,	M₂ : Type u_1,	_inst_10 : add_comm_group M₂,	_inst_11 : module R M₂,	M₃ : Type u_2,	_inst_12 : add_comm_group M₃,	_inst_13 : module R M₃,	f : M →ₗ[R] M₃,	g : M₂ →ₗ[R] M₃,	hd : disjoint f.range g.range,	y : M,	z : M₂,	h : ⇑f y + ⇑g z = 0,	this : ⇑f y = 0	⊢ ⇑f y = 0 ∧ ⇑g z = 0
R : Type u,	M : Type v,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_6 : module R M,	M₂ : Type u_1,	_inst_10 : add_comm_group M₂,	_inst_11 : module R M₂,	M₃ : Type u_2,	_inst_12 : add_comm_group M₃,	_inst_13 : module R M₃,	f : M →ₗ[R] M₃,	g : M₂ →ₗ[R] M₃,	hd : disjoint f.range g.range,	y : M,	z : M₂,	this : ⇑f y = 0,	h : 0 + ⇑g z = 0	⊢ ⇑f y = 0 ∧ ⇑g z = 0
⊢ ∀ {R : Type u_1} [_inst_1 : ring R] {E : Type u_2} [_inst_2 : add_comm_group E] [_inst_3 : module R E]	  {p : submodule R E} (f : E →ₗ[R] ↥p) (hf : ∀ (x : ↥p), ⇑f ↑x = x), p.linear_proj_of_is_compl f.ker _ = f
R : Type u_1,	_inst_1 : ring R,	E : Type u_2,	_inst_2 : add_comm_group E,	_inst_3 : module R E,	p : submodule R E,	f : E →ₗ[R] ↥p,	hf : ∀ (x : ↥p), ⇑f ↑x = x	⊢ p.linear_proj_of_is_compl f.ker _ = f
R : Type u_1,	_inst_1 : ring R,	E : Type u_2,	_inst_2 : add_comm_group E,	_inst_3 : module R E,	p : submodule R E,	f : E →ₗ[R] ↥p,	hf : ∀ (x : ↥p), ⇑f ↑x = x,	x : E	⊢ ↑(⇑(p.linear_proj_of_is_compl f.ker _) x) = ↑(⇑f x)
2 goals	R : Type u_1,	_inst_1 : ring R,	E : Type u_2,	_inst_2 : add_comm_group E,	_inst_3 : module R E,	p : submodule R E,	f : E →ₗ[R] ↥p,	hf : ∀ (x : ↥p), ⇑f ↑x = x,	x : E	⊢ x ∈ p ⊔ f.ker		R : Type u_1,	_inst_1 : ring R,	E : Type u_2,	_inst_2 : add_comm_group E,	_inst_3 : module R E,	p : submodule R E,	f : E →ₗ[R] ↥p,	hf : ∀ (x : ↥p), ⇑f ↑x = x,	x : E,	this : x ∈ p ⊔ f.ker	⊢ ↑(⇑(p.linear_proj_of_is_compl f.ker _) x) = ↑(⇑f x)
R : Type u_1,	_inst_1 : ring R,	E : Type u_2,	_inst_2 : add_comm_group E,	_inst_3 : module R E,	p : submodule R E,	f : E →ₗ[R] ↥p,	hf : ∀ (x : ↥p), ⇑f ↑x = x,	x : E,	this : x ∈ p ⊔ f.ker	⊢ ↑(⇑(p.linear_proj_of_is_compl f.ker _) x) = ↑(⇑f x)
R : Type u_1,	_inst_1 : ring R,	E : Type u_2,	_inst_2 : add_comm_group E,	_inst_3 : module R E,	p : submodule R E,	f : E →ₗ[R] ↥p,	hf : ∀ (x : ↥p), ⇑f ↑x = x,	x : ↥p,	y : ↥(f.ker),	this : ↑x + ↑y ∈ p ⊔ f.ker	⊢ ↑(⇑(p.linear_proj_of_is_compl f.ker _) (↑x + ↑y)) = ↑(⇑f (↑x + ↑y))
⊢ ∀ {R₁ : Type u_4} [_inst_3 : comm_ring R₁] {n : Type w} [_inst_6 : fintype n] [_inst_7 : decidable_eq n]	  [_inst_8 : invertible 2] {Q : quadratic_form R₁ (n → R₁)} (a : R₁),	    (a • Q).discr = a ^ fintype.card n * Q.discr
R₁ : Type u_4,	_inst_3 : comm_ring R₁,	n : Type w,	_inst_6 : fintype n,	_inst_7 : decidable_eq n,	_inst_8 : invertible 2,	Q : quadratic_form R₁ (n → R₁),	a : R₁	⊢ (a • Q).discr = a ^ fintype.card n * Q.discr
⊢ ∀ {a b c : Prop} [_inst_1 : decidable a], a → b ∨ c ↔ (a → b) ∨ (a → c)
a b c : Prop,	_inst_1 : decidable a	⊢ a → b ∨ c ↔ (a → b) ∨ (a → c)
⊢ ∀ {α : Sort u_1} {p : α → Prop} {a' : α}, (∃ (a : α), a' = a ∧ p a) ↔ p a'
α : Sort u_1,	p : α → Prop,	a' : α	⊢ (∃ (a : α), a' = a ∧ p a) ↔ p a'
⊢ ∀ {α α' : Sort u} {β : α → Sort v} {β' : α' → Sort v} {f : Π (a : α), β a}	  {f' : Π (a : α'), β' a}, α = α' → (∀ (a : α) (a' : α'), a == a' → f a == f' a') → f == f'
α α' : Sort u,	β : α → Sort v,	β' : α' → Sort v,	f : Π (a : α), β a,	f' : Π (a : α'), β' a,	hα : α = α',	h : ∀ (a : α) (a' : α'), a == a' → f a == f' a'	⊢ f == f'
α : Sort u,	β : α → Sort v,	f : Π (a : α), β a,	β' : α → Sort v,	f' : Π (a : α), β' a,	h : ∀ (a a' : α), a == a' → f a == f' a'	⊢ f == f'
2 goals	α : Sort u,	β : α → Sort v,	f : Π (a : α), β a,	β' : α → Sort v,	f' : Π (a : α), β' a,	h : ∀ (a a' : α), a == a' → f a == f' a'	⊢ ∀ (a : α), f a == f' a		α : Sort u,	β : α → Sort v,	f : Π (a : α), β a,	β' : α → Sort v,	f' : Π (a : α), β' a,	h : ∀ (a a' : α), a == a' → f a == f' a',	this : ∀ (a : α), f a == f' a	⊢ f == f'
2 goals	α : Sort u,	β : α → Sort v,	f : Π (a : α), β a,	β' : α → Sort v,	f' : Π (a : α), β' a,	h : ∀ (a a' : α), a == a' → f a == f' a',	a : α	⊢ f a == f' a		α : Sort u,	β : α → Sort v,	f : Π (a : α), β a,	β' : α → Sort v,	f' : Π (a : α), β' a,	h : ∀ (a a' : α), a == a' → f a == f' a',	this : ∀ (a : α), f a == f' a	⊢ f == f'
α : Sort u,	β : α → Sort v,	f : Π (a : α), β a,	β' : α → Sort v,	f' : Π (a : α), β' a,	h : ∀ (a a' : α), a == a' → f a == f' a',	this : ∀ (a : α), f a == f' a	⊢ f == f'
2 goals	α : Sort u,	β : α → Sort v,	f : Π (a : α), β a,	β' : α → Sort v,	f' : Π (a : α), β' a,	h : ∀ (a a' : α), a == a' → f a == f' a',	this : ∀ (a : α), f a == f' a	⊢ β = β'		α : Sort u,	β : α → Sort v,	f : Π (a : α), β a,	β' : α → Sort v,	f' : Π (a : α), β' a,	h : ∀ (a a' : α), a == a' → f a == f' a',	this : ∀ (a : α), f a == f' a,	this : β = β'	⊢ f == f'
2 goals	α : Sort u,	β : α → Sort v,	f : Π (a : α), β a,	β' : α → Sort v,	f' : Π (a : α), β' a,	h : ∀ (a a' : α), a == a' → f a == f' a',	this : ∀ (a : α), f a == f' a,	a : α	⊢ β a = β' a		α : Sort u,	β : α → Sort v,	f : Π (a : α), β a,	β' : α → Sort v,	f' : Π (a : α), β' a,	h : ∀ (a a' : α), a == a' → f a == f' a',	this : ∀ (a : α), f a == f' a,	this : β = β'	⊢ f == f'
α : Sort u,	β : α → Sort v,	f : Π (a : α), β a,	β' : α → Sort v,	f' : Π (a : α), β' a,	h : ∀ (a a' : α), a == a' → f a == f' a',	this : ∀ (a : α), f a == f' a,	this : β = β'	⊢ f == f'
α : Sort u,	β : α → Sort v,	f f' : Π (a : α), β a,	h : ∀ (a a' : α), a == a' → f a == f' a',	this : ∀ (a : α), f a == f' a	⊢ f == f'
α : Sort u,	β : α → Sort v,	f f' : Π (a : α), β a,	h : ∀ (a a' : α), a == a' → f a == f' a',	this : ∀ (a : α), f a == f' a	⊢ f = f'
α : Sort u,	β : α → Sort v,	f f' : Π (a : α), β a,	h : ∀ (a a' : α), a == a' → f a == f' a',	this : ∀ (a : α), f a == f' a,	a : α	⊢ f a = f' a
⊢ ∀ {α : Type u_1} [_inst_1 : nontrivial α] [_inst_2 : decidable_eq α] (x : α), ∃ (y : α), y ≠ x
α : Type u_1,	_inst_1 : nontrivial α,	_inst_2 : decidable_eq α,	x : α	⊢ ∃ (y : α), y ≠ x
α : Type u_1,	_inst_1 : nontrivial α,	_inst_2 : decidable_eq α,	x y y' : α,	h : y ≠ y'	⊢ ∃ (y : α), y ≠ x
2 goals	α : Type u_1,	_inst_1 : nontrivial α,	_inst_2 : decidable_eq α,	x y y' : α,	h : y ≠ y',	hx : x = y	⊢ ∃ (y : α), y ≠ x		α : Type u_1,	_inst_1 : nontrivial α,	_inst_2 : decidable_eq α,	x y y' : α,	h : y ≠ y',	hx : ¬x = y	⊢ ∃ (y : α), y ≠ x
2 goals	α : Type u_1,	_inst_1 : nontrivial α,	_inst_2 : decidable_eq α,	x y y' : α,	hx : x = y,	h : x ≠ y'	⊢ ∃ (y : α), y ≠ x		α : Type u_1,	_inst_1 : nontrivial α,	_inst_2 : decidable_eq α,	x y y' : α,	h : y ≠ y',	hx : ¬x = y	⊢ ∃ (y : α), y ≠ x
α : Type u_1,	_inst_1 : nontrivial α,	_inst_2 : decidable_eq α,	x y y' : α,	h : y ≠ y',	hx : ¬x = y	⊢ ∃ (y : α), y ≠ x
⊢ ∀ {α : Type u_1} {r : α → α → Prop}, symmetric r → symmetric (refl_trans_gen r)
α : Type u_1,	r : α → α → Prop,	h : symmetric r	⊢ symmetric (refl_trans_gen r)
α : Type u_1,	r : α → α → Prop,	h : symmetric r,	x y : α,	h : refl_trans_gen r x y	⊢ refl_trans_gen r y x
2 goals	case relation.refl_trans_gen.refl	α : Type u_1,	r : α → α → Prop,	h : symmetric r,	x y : α	⊢ refl_trans_gen r x x		case relation.refl_trans_gen.tail	α : Type u_1,	r : α → α → Prop,	h : symmetric r,	x y z w : α,	a : refl_trans_gen r x z,	b : r z w,	c : refl_trans_gen r z x	⊢ refl_trans_gen r w x
case relation.refl_trans_gen.tail	α : Type u_1,	r : α → α → Prop,	h : symmetric r,	x y z w : α,	a : refl_trans_gen r x z,	b : r z w,	c : refl_trans_gen r z x	⊢ refl_trans_gen r w x
⊢ ∀ {α : Type u_1} {r : α → α → Prop} {b : α} {P : Π (a : α), refl_trans_gen r a b → Prop} {a : α}	  (h : refl_trans_gen r a b),	    P b refl_trans_gen.refl → (∀ {a c : α} (h' : r a c) (h : refl_trans_gen r c b), P c h → P a _) → P a h
α : Type u_1,	r : α → α → Prop,	b : α,	P : Π (a : α), refl_trans_gen r a b → Prop,	a : α,	h : refl_trans_gen r a b,	refl : P b refl_trans_gen.refl,	head : ∀ {a c : α} (h' : r a c) (h : refl_trans_gen r c b), P c h → P a _	⊢ P a h
2 goals	case relation.refl_trans_gen.refl	α : Type u_1,	r : α → α → Prop,	a b : α,	P : Π (a_1 : α), refl_trans_gen r a_1 a → Prop,	refl : P a refl_trans_gen.refl,	head : ∀ {a_1 c : α} (h' : r a_1 c) (h : refl_trans_gen r c a), P c h → P a_1 _	⊢ P a refl_trans_gen.refl		case relation.refl_trans_gen.tail	α : Type u_1,	r : α → α → Prop,	a b h_b h_c : α,	h_ᾰ : refl_trans_gen r a h_b,	h_ᾰ_1 : r h_b h_c,	h_ih :	  ∀ {P : Π (a : α), refl_trans_gen r a h_b → Prop},	    P h_b refl_trans_gen.refl →	    (∀ {a c : α} (h' : r a c) (h : refl_trans_gen r c h_b), P c h → P a _) → P a h_ᾰ,	P : Π (a : α), refl_trans_gen r a h_c → Prop,	refl : P h_c refl_trans_gen.refl,	head : ∀ {a c : α} (h' : r a c) (h : refl_trans_gen r c h_c), P c h → P a _	⊢ P a _
case relation.refl_trans_gen.tail	α : Type u_1,	r : α → α → Prop,	a b h_b h_c : α,	h_ᾰ : refl_trans_gen r a h_b,	h_ᾰ_1 : r h_b h_c,	h_ih :	  ∀ {P : Π (a : α), refl_trans_gen r a h_b → Prop},	    P h_b refl_trans_gen.refl →	    (∀ {a c : α} (h' : r a c) (h : refl_trans_gen r c h_b), P c h → P a _) → P a h_ᾰ,	P : Π (a : α), refl_trans_gen r a h_c → Prop,	refl : P h_c refl_trans_gen.refl,	head : ∀ {a c : α} (h' : r a c) (h : refl_trans_gen r c h_c), P c h → P a _	⊢ P a _
⊢ ∀ {α : Type u_1} [_inst_1 : topological_space α] [_inst_2 : t1_space α] [_inst_3 : encodable α],	    borel α = ⊤
α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : t1_space α,	_inst_3 : encodable α	⊢ borel α = ⊤
α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : t1_space α,	_inst_3 : encodable α,	s : set α,	hs : ⊤.measurable_set' s	⊢ (borel α).measurable_set' (⋃ (x : α) (H : x ∈ s), {x})
α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : t1_space α,	_inst_3 : encodable α,	s : set α,	hs : ⊤.measurable_set' s	⊢ ∀ (b : α), b ∈ s → measurable_set {b}
α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : t1_space α,	_inst_3 : encodable α,	s : set α,	hs : ⊤.measurable_set' s,	x : α,	hx : x ∈ s	⊢ measurable_set {x}
α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : t1_space α,	_inst_3 : encodable α,	s : set α,	hs : ⊤.measurable_set' s,	x : α,	hx : x ∈ s	⊢ measurable_set {x}ᶜ
α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : t1_space α,	_inst_3 : encodable α,	s : set α,	hs : ⊤.measurable_set' s,	x : α,	hx : x ∈ s	⊢ {x}ᶜ ∈ {s : set α | is_open s}
⊢ ∀ {α : Type u_1} {δ : Type u_5} [_inst_1 : topological_space α] [_inst_2 : measurable_space α]	  [_inst_3 : borel_space α] [_inst_10 : measurable_space δ] [_inst_11 : complete_linear_order α]	  [_inst_12 : order_topology α] [_inst_13 : second_countable_topology α] {ι : Type u_2} {ι' : Type u_3}	  {f : ι → δ → α} {u : filter ι},	    (∀ (i : ι), measurable (f i)) →	    ∀ {p : ι' → Prop} {s : ι' → set ι},	      u.has_countable_basis p s →	      (∀ (i : ι'), (s i).countable) → measurable (λ (x : δ), u.liminf (λ (i : ι), f i x))
α : Type u_1,	δ : Type u_5,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	_inst_10 : measurable_space δ,	_inst_11 : complete_linear_order α,	_inst_12 : order_topology α,	_inst_13 : second_countable_topology α,	ι : Type u_2,	ι' : Type u_3,	f : ι → δ → α,	u : filter ι,	hf : ∀ (i : ι), measurable (f i),	p : ι' → Prop,	s : ι' → set ι,	hu : u.has_countable_basis p s,	hs : ∀ (i : ι'), (s i).countable	⊢ measurable (λ (x : δ), u.liminf (λ (i : ι), f i x))
α : Type u_1,	δ : Type u_5,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	_inst_10 : measurable_space δ,	_inst_11 : complete_linear_order α,	_inst_12 : order_topology α,	_inst_13 : second_countable_topology α,	ι : Type u_2,	ι' : Type u_3,	f : ι → δ → α,	u : filter ι,	hf : ∀ (i : ι), measurable (f i),	p : ι' → Prop,	s : ι' → set ι,	hu : u.has_countable_basis p s,	hs : ∀ (i : ι'), (s i).countable	⊢ measurable (λ (x : δ), ⨆ (i : ι') (hi : p i), ⨅ (a : ι) (H : a ∈ s i), f a x)
α : Type u_1,	δ : Type u_5,	_inst_1 : topological_space α,	_inst_2 : measurable_space α,	_inst_3 : borel_space α,	_inst_10 : measurable_space δ,	_inst_11 : complete_linear_order α,	_inst_12 : order_topology α,	_inst_13 : second_countable_topology α,	ι : Type u_2,	ι' : Type u_3,	f : ι → δ → α,	u : filter ι,	hf : ∀ (i : ι), measurable (f i),	p : ι' → Prop,	s : ι' → set ι,	hu : u.has_countable_basis p s,	hs : ∀ (i : ι'), (s i).countable	⊢ ∀ (i : ι'), measurable (λ (x : δ), ⨅ (a : ι) (H : a ∈ s i), f a x)
⊢ ∀ {ι : Type u_1} {α : ι → Type u_3} [_inst_1 : fintype ι] [h : Π (i : ι), measurable_space (α i)]	  {C : Π (i : ι), set (set (α i))},	    (∀ (i : ι), generate_from (C i) = h i) →	    (∀ (i : ι), is_countably_spanning (C i)) → generate_from (univ.pi '' univ.pi C) = measurable_space.pi
ι : Type u_1,	α : ι → Type u_3,	_inst_1 : fintype ι,	h : Π (i : ι), measurable_space (α i),	C : Π (i : ι), set (set (α i)),	hC : ∀ (i : ι), generate_from (C i) = h i,	h2C : ∀ (i : ι), is_countably_spanning (C i)	⊢ generate_from (univ.pi '' univ.pi C) = measurable_space.pi
⊢ ∀ {ι : Type u_1} {α : ι → Type u_3} [_inst_1 : fintype ι] [_inst_3 : Π (i : ι), measurable_space (α i)]	  {μ : Π (i : ι), measure (α i)} [_inst_4 : ∀ (i : ι), sigma_finite (μ i)]	  [_inst_5 : Π (i : ι), partial_order (α i)] [_inst_6 : ∀ (i : ι), has_no_atoms (μ i)] {f g : Π (i : ι), α i},	    univ.pi (λ (i : ι), Ico (f i) (g i)) =ᵐ[measure.pi μ] Icc f g
ι : Type u_1,	α : ι → Type u_3,	_inst_1 : fintype ι,	_inst_3 : Π (i : ι), measurable_space (α i),	μ : Π (i : ι), measure (α i),	_inst_4 : ∀ (i : ι), sigma_finite (μ i),	_inst_5 : Π (i : ι), partial_order (α i),	_inst_6 : ∀ (i : ι), has_no_atoms (μ i),	f g : Π (i : ι), α i	⊢ univ.pi (λ (i : ι), Ico (f i) (g i)) =ᵐ[measure.pi μ] Icc f g
ι : Type u_1,	α : ι → Type u_3,	_inst_1 : fintype ι,	_inst_3 : Π (i : ι), measurable_space (α i),	μ : Π (i : ι), measure (α i),	_inst_4 : ∀ (i : ι), sigma_finite (μ i),	_inst_5 : Π (i : ι), partial_order (α i),	_inst_6 : ∀ (i : ι), has_no_atoms (μ i),	f g : Π (i : ι), α i	⊢ univ.pi (λ (i : ι), Ico (f i) (g i)) =ᵐ[measure.pi μ] univ.pi (λ (i : ι), Icc (f i) (g i))
⊢ ∀ {α : Type u_1} [_inst_1 : measurable_space α], 0.total_variation = 0
α : Type u_1,	_inst_1 : measurable_space α	⊢ 0.total_variation = 0
⊢ ∀ {α : Type u_1} {m : measurable_space α} {μ ν s : measure α} {f : α → ennreal},	    measurable f → s.mutually_singular ν → μ = s + ν.with_density f → s = μ.singular_part ν
α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	hs : s.mutually_singular ν,	hadd : μ = s + ν.with_density f	⊢ s = μ.singular_part ν
α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	hs : s.mutually_singular ν,	hadd : μ = s + ν.with_density f,	_inst : μ.have_lebesgue_decomposition ν	⊢ s = μ.singular_part ν
α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	hs : s.mutually_singular ν,	hadd : μ = s + ν.with_density f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hsing : (μ.singular_part ν).mutually_singular ν,	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν)	⊢ s = μ.singular_part ν
α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	hadd : μ = s + ν.with_density f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0	⊢ s = μ.singular_part ν
α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f	⊢ s = μ.singular_part ν
2 goals	α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f	⊢ ⇑ν (S ∩ T)ᶜ = 0		α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0	⊢ s = μ.singular_part ν
2 goals	α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f	⊢ ⇑ν (Sᶜ ∪ Tᶜ) = 0		α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0	⊢ s = μ.singular_part ν
2 goals	α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f	⊢ ⇑ν Sᶜ + ⇑ν Tᶜ ≤ 0		α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0	⊢ s = μ.singular_part ν
2 goals	α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f	⊢ 0 ≤ 0		α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0	⊢ s = μ.singular_part ν
α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0	⊢ s = μ.singular_part ν
2 goals	α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0	⊢ s.restrict (S ∩ T)ᶜ = (μ.singular_part ν).restrict (S ∩ T)ᶜ		α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	heq : s.restrict (S ∩ T)ᶜ = (μ.singular_part ν).restrict (S ∩ T)ᶜ	⊢ s = μ.singular_part ν
2 goals	α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	A : set α,	hA : measurable_set A	⊢ ⇑(s.restrict (S ∩ T)ᶜ) A = ⇑((μ.singular_part ν).restrict (S ∩ T)ᶜ) A		α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	heq : s.restrict (S ∩ T)ᶜ = (μ.singular_part ν).restrict (S ∩ T)ᶜ	⊢ s = μ.singular_part ν
3 goals	α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	A : set α,	hA : measurable_set A	⊢ ⇑(ν.with_density f) (A ∩ (S ∩ T)ᶜ) = 0		α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	A : set α,	hA : measurable_set A,	hf : ⇑(ν.with_density f) (A ∩ (S ∩ T)ᶜ) = 0	⊢ ⇑(s.restrict (S ∩ T)ᶜ) A = ⇑((μ.singular_part ν).restrict (S ∩ T)ᶜ) A		α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	heq : s.restrict (S ∩ T)ᶜ = (μ.singular_part ν).restrict (S ∩ T)ᶜ	⊢ s = μ.singular_part ν
3 goals	α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	A : set α,	hA : measurable_set A	⊢ ⇑ν (A ∩ (S ∩ T)ᶜ) = 0		α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	A : set α,	hA : measurable_set A,	hf : ⇑(ν.with_density f) (A ∩ (S ∩ T)ᶜ) = 0	⊢ ⇑(s.restrict (S ∩ T)ᶜ) A = ⇑((μ.singular_part ν).restrict (S ∩ T)ᶜ) A		α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	heq : s.restrict (S ∩ T)ᶜ = (μ.singular_part ν).restrict (S ∩ T)ᶜ	⊢ s = μ.singular_part ν
3 goals	α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	A : set α,	hA : measurable_set A	⊢ ⇑ν (A ∩ (S ∩ T)ᶜ) ≤ 0		α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	A : set α,	hA : measurable_set A,	hf : ⇑(ν.with_density f) (A ∩ (S ∩ T)ᶜ) = 0	⊢ ⇑(s.restrict (S ∩ T)ᶜ) A = ⇑((μ.singular_part ν).restrict (S ∩ T)ᶜ) A		α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	heq : s.restrict (S ∩ T)ᶜ = (μ.singular_part ν).restrict (S ∩ T)ᶜ	⊢ s = μ.singular_part ν
2 goals	α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	A : set α,	hA : measurable_set A,	hf : ⇑(ν.with_density f) (A ∩ (S ∩ T)ᶜ) = 0	⊢ ⇑(s.restrict (S ∩ T)ᶜ) A = ⇑((μ.singular_part ν).restrict (S ∩ T)ᶜ) A		α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	heq : s.restrict (S ∩ T)ᶜ = (μ.singular_part ν).restrict (S ∩ T)ᶜ	⊢ s = μ.singular_part ν
3 goals	α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	A : set α,	hA : measurable_set A,	hf : ⇑(ν.with_density f) (A ∩ (S ∩ T)ᶜ) = 0	⊢ ⇑(ν.with_density (μ.rn_deriv ν)) (A ∩ (S ∩ T)ᶜ) = 0		α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	A : set α,	hA : measurable_set A,	hf : ⇑(ν.with_density f) (A ∩ (S ∩ T)ᶜ) = 0,	hrn : ⇑(ν.with_density (μ.rn_deriv ν)) (A ∩ (S ∩ T)ᶜ) = 0	⊢ ⇑(s.restrict (S ∩ T)ᶜ) A = ⇑((μ.singular_part ν).restrict (S ∩ T)ᶜ) A		α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	heq : s.restrict (S ∩ T)ᶜ = (μ.singular_part ν).restrict (S ∩ T)ᶜ	⊢ s = μ.singular_part ν
3 goals	α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	A : set α,	hA : measurable_set A,	hf : ⇑(ν.with_density f) (A ∩ (S ∩ T)ᶜ) = 0	⊢ ⇑ν (A ∩ (S ∩ T)ᶜ) = 0		α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	A : set α,	hA : measurable_set A,	hf : ⇑(ν.with_density f) (A ∩ (S ∩ T)ᶜ) = 0,	hrn : ⇑(ν.with_density (μ.rn_deriv ν)) (A ∩ (S ∩ T)ᶜ) = 0	⊢ ⇑(s.restrict (S ∩ T)ᶜ) A = ⇑((μ.singular_part ν).restrict (S ∩ T)ᶜ) A		α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	heq : s.restrict (S ∩ T)ᶜ = (μ.singular_part ν).restrict (S ∩ T)ᶜ	⊢ s = μ.singular_part ν
3 goals	α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	A : set α,	hA : measurable_set A,	hf : ⇑(ν.with_density f) (A ∩ (S ∩ T)ᶜ) = 0	⊢ ⇑ν (A ∩ (S ∩ T)ᶜ) ≤ 0		α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	A : set α,	hA : measurable_set A,	hf : ⇑(ν.with_density f) (A ∩ (S ∩ T)ᶜ) = 0,	hrn : ⇑(ν.with_density (μ.rn_deriv ν)) (A ∩ (S ∩ T)ᶜ) = 0	⊢ ⇑(s.restrict (S ∩ T)ᶜ) A = ⇑((μ.singular_part ν).restrict (S ∩ T)ᶜ) A		α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	heq : s.restrict (S ∩ T)ᶜ = (μ.singular_part ν).restrict (S ∩ T)ᶜ	⊢ s = μ.singular_part ν
2 goals	α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	A : set α,	hA : measurable_set A,	hf : ⇑(ν.with_density f) (A ∩ (S ∩ T)ᶜ) = 0,	hrn : ⇑(ν.with_density (μ.rn_deriv ν)) (A ∩ (S ∩ T)ᶜ) = 0	⊢ ⇑(s.restrict (S ∩ T)ᶜ) A = ⇑((μ.singular_part ν).restrict (S ∩ T)ᶜ) A		α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	heq : s.restrict (S ∩ T)ᶜ = (μ.singular_part ν).restrict (S ∩ T)ᶜ	⊢ s = μ.singular_part ν
α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	heq : s.restrict (S ∩ T)ᶜ = (μ.singular_part ν).restrict (S ∩ T)ᶜ	⊢ s = μ.singular_part ν
2 goals	α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	heq : s.restrict (S ∩ T)ᶜ = (μ.singular_part ν).restrict (S ∩ T)ᶜ	⊢ ∀ (A : set α), measurable_set A → ⇑s A = ⇑(s.restrict (S ∩ T)ᶜ) A		α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	heq : s.restrict (S ∩ T)ᶜ = (μ.singular_part ν).restrict (S ∩ T)ᶜ,	heq' : ∀ (A : set α), measurable_set A → ⇑s A = ⇑(s.restrict (S ∩ T)ᶜ) A	⊢ s = μ.singular_part ν
2 goals	α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	heq : s.restrict (S ∩ T)ᶜ = (μ.singular_part ν).restrict (S ∩ T)ᶜ,	A : set α,	hA : measurable_set A	⊢ ⇑s A = ⇑(s.restrict (S ∩ T)ᶜ) A		α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	heq : s.restrict (S ∩ T)ᶜ = (μ.singular_part ν).restrict (S ∩ T)ᶜ,	heq' : ∀ (A : set α), measurable_set A → ⇑s A = ⇑(s.restrict (S ∩ T)ᶜ) A	⊢ s = μ.singular_part ν
3 goals	α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	heq : s.restrict (S ∩ T)ᶜ = (μ.singular_part ν).restrict (S ∩ T)ᶜ,	A : set α,	hA : measurable_set A	⊢ ⇑s (A ∩ (S ∩ T)) = 0		α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	heq : s.restrict (S ∩ T)ᶜ = (μ.singular_part ν).restrict (S ∩ T)ᶜ,	A : set α,	hA : measurable_set A,	hsinter : ⇑s (A ∩ (S ∩ T)) = 0	⊢ ⇑s A = ⇑(s.restrict (S ∩ T)ᶜ) A		α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	heq : s.restrict (S ∩ T)ᶜ = (μ.singular_part ν).restrict (S ∩ T)ᶜ,	heq' : ∀ (A : set α), measurable_set A → ⇑s A = ⇑(s.restrict (S ∩ T)ᶜ) A	⊢ s = μ.singular_part ν
3 goals	α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	heq : s.restrict (S ∩ T)ᶜ = (μ.singular_part ν).restrict (S ∩ T)ᶜ,	A : set α,	hA : measurable_set A	⊢ ⇑s (A ∩ (S ∩ T)) ≤ 0		α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	heq : s.restrict (S ∩ T)ᶜ = (μ.singular_part ν).restrict (S ∩ T)ᶜ,	A : set α,	hA : measurable_set A,	hsinter : ⇑s (A ∩ (S ∩ T)) = 0	⊢ ⇑s A = ⇑(s.restrict (S ∩ T)ᶜ) A		α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	heq : s.restrict (S ∩ T)ᶜ = (μ.singular_part ν).restrict (S ∩ T)ᶜ,	heq' : ∀ (A : set α), measurable_set A → ⇑s A = ⇑(s.restrict (S ∩ T)ᶜ) A	⊢ s = μ.singular_part ν
2 goals	α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	heq : s.restrict (S ∩ T)ᶜ = (μ.singular_part ν).restrict (S ∩ T)ᶜ,	A : set α,	hA : measurable_set A,	hsinter : ⇑s (A ∩ (S ∩ T)) = 0	⊢ ⇑s A = ⇑(s.restrict (S ∩ T)ᶜ) A		α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	heq : s.restrict (S ∩ T)ᶜ = (μ.singular_part ν).restrict (S ∩ T)ᶜ,	heq' : ∀ (A : set α), measurable_set A → ⇑s A = ⇑(s.restrict (S ∩ T)ᶜ) A	⊢ s = μ.singular_part ν
3 goals	α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	heq : s.restrict (S ∩ T)ᶜ = (μ.singular_part ν).restrict (S ∩ T)ᶜ,	A : set α,	hA : measurable_set A,	hsinter : ⇑s (A ∩ (S ∩ T)) = 0	⊢ disjoint (A ∩ (S ∩ T)ᶜ) (A ∩ (S ∩ T))		α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	heq : s.restrict (S ∩ T)ᶜ = (μ.singular_part ν).restrict (S ∩ T)ᶜ,	A : set α,	hA : measurable_set A,	hsinter : ⇑s (A ∩ (S ∩ T)) = 0	⊢ measurable_set (A ∩ (S ∩ T))		α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	heq : s.restrict (S ∩ T)ᶜ = (μ.singular_part ν).restrict (S ∩ T)ᶜ,	heq' : ∀ (A : set α), measurable_set A → ⇑s A = ⇑(s.restrict (S ∩ T)ᶜ) A	⊢ s = μ.singular_part ν
2 goals	α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	heq : s.restrict (S ∩ T)ᶜ = (μ.singular_part ν).restrict (S ∩ T)ᶜ,	A : set α,	hA : measurable_set A,	hsinter : ⇑s (A ∩ (S ∩ T)) = 0	⊢ measurable_set (A ∩ (S ∩ T))		α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	heq : s.restrict (S ∩ T)ᶜ = (μ.singular_part ν).restrict (S ∩ T)ᶜ,	heq' : ∀ (A : set α), measurable_set A → ⇑s A = ⇑(s.restrict (S ∩ T)ᶜ) A	⊢ s = μ.singular_part ν
α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	heq : s.restrict (S ∩ T)ᶜ = (μ.singular_part ν).restrict (S ∩ T)ᶜ,	heq' : ∀ (A : set α), measurable_set A → ⇑s A = ⇑(s.restrict (S ∩ T)ᶜ) A	⊢ s = μ.singular_part ν
α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	heq : s.restrict (S ∩ T)ᶜ = (μ.singular_part ν).restrict (S ∩ T)ᶜ,	heq' : ∀ (A : set α), measurable_set A → ⇑s A = ⇑(s.restrict (S ∩ T)ᶜ) A,	A : set α,	hA : measurable_set A	⊢ ⇑s A = ⇑(μ.singular_part ν) A
2 goals	α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	heq : s.restrict (S ∩ T)ᶜ = (μ.singular_part ν).restrict (S ∩ T)ᶜ,	heq' : ∀ (A : set α), measurable_set A → ⇑s A = ⇑(s.restrict (S ∩ T)ᶜ) A,	A : set α,	hA : measurable_set A	⊢ ⇑(μ.singular_part ν) (A ∩ (S ∩ T)) = 0		α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	heq : s.restrict (S ∩ T)ᶜ = (μ.singular_part ν).restrict (S ∩ T)ᶜ,	heq' : ∀ (A : set α), measurable_set A → ⇑s A = ⇑(s.restrict (S ∩ T)ᶜ) A,	A : set α,	hA : measurable_set A,	hμinter : ⇑(μ.singular_part ν) (A ∩ (S ∩ T)) = 0	⊢ ⇑s A = ⇑(μ.singular_part ν) A
2 goals	α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	heq : s.restrict (S ∩ T)ᶜ = (μ.singular_part ν).restrict (S ∩ T)ᶜ,	heq' : ∀ (A : set α), measurable_set A → ⇑s A = ⇑(s.restrict (S ∩ T)ᶜ) A,	A : set α,	hA : measurable_set A	⊢ ⇑(μ.singular_part ν) (A ∩ (S ∩ T)) ≤ 0		α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	heq : s.restrict (S ∩ T)ᶜ = (μ.singular_part ν).restrict (S ∩ T)ᶜ,	heq' : ∀ (A : set α), measurable_set A → ⇑s A = ⇑(s.restrict (S ∩ T)ᶜ) A,	A : set α,	hA : measurable_set A,	hμinter : ⇑(μ.singular_part ν) (A ∩ (S ∩ T)) = 0	⊢ ⇑s A = ⇑(μ.singular_part ν) A
α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	heq : s.restrict (S ∩ T)ᶜ = (μ.singular_part ν).restrict (S ∩ T)ᶜ,	heq' : ∀ (A : set α), measurable_set A → ⇑s A = ⇑(s.restrict (S ∩ T)ᶜ) A,	A : set α,	hA : measurable_set A,	hμinter : ⇑(μ.singular_part ν) (A ∩ (S ∩ T)) = 0	⊢ ⇑s A = ⇑(μ.singular_part ν) A
2 goals	α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	heq : s.restrict (S ∩ T)ᶜ = (μ.singular_part ν).restrict (S ∩ T)ᶜ,	heq' : ∀ (A : set α), measurable_set A → ⇑s A = ⇑(s.restrict (S ∩ T)ᶜ) A,	A : set α,	hA : measurable_set A,	hμinter : ⇑(μ.singular_part ν) (A ∩ (S ∩ T)) = 0	⊢ disjoint (A ∩ (S ∩ T)ᶜ) (A ∩ (S ∩ T))		α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	heq : s.restrict (S ∩ T)ᶜ = (μ.singular_part ν).restrict (S ∩ T)ᶜ,	heq' : ∀ (A : set α), measurable_set A → ⇑s A = ⇑(s.restrict (S ∩ T)ᶜ) A,	A : set α,	hA : measurable_set A,	hμinter : ⇑(μ.singular_part ν) (A ∩ (S ∩ T)) = 0	⊢ measurable_set (A ∩ (S ∩ T))
α : Type u_1,	m : measurable_space α,	μ ν s : measure α,	f : α → ennreal,	hf : measurable f,	_inst : μ.have_lebesgue_decomposition ν,	hmeas : measurable (μ.rn_deriv ν),	hadd' : μ = μ.singular_part ν + ν.with_density (μ.rn_deriv ν),	S : set α,	hS₁ : measurable_set S,	hS₂ : ⇑s S = 0,	hS₃ : ⇑ν Sᶜ = 0,	T : set α,	hT₁ : measurable_set T,	hT₂ : ⇑(μ.singular_part ν) T = 0,	hT₃ : ⇑ν Tᶜ = 0,	hadd : μ.singular_part ν + ν.with_density (μ.rn_deriv ν) = s + ν.with_density f,	hνinter : ⇑ν (S ∩ T)ᶜ = 0,	heq : s.restrict (S ∩ T)ᶜ = (μ.singular_part ν).restrict (S ∩ T)ᶜ,	heq' : ∀ (A : set α), measurable_set A → ⇑s A = ⇑(s.restrict (S ∩ T)ᶜ) A,	A : set α,	hA : measurable_set A,	hμinter : ⇑(μ.singular_part ν) (A ∩ (S ∩ T)) = 0	⊢ measurable_set (A ∩ (S ∩ T))
⊢ ∀ {α : Type u_1} {m : measurable_space α} {μ ν : measure α} (f : ℕ → α → ennreal),	    (∀ (n : ℕ), f n ∈ measure.lebesgue_decomposition.measurable_le μ ν) →	    ∀ (n : ℕ), (⨆ (k : ℕ) (hk : k ≤ n), f k) ∈ measure.lebesgue_decomposition.measurable_le μ ν
α : Type u_1,	m : measurable_space α,	μ ν : measure α,	f : ℕ → α → ennreal,	hf : ∀ (n : ℕ), f n ∈ measure.lebesgue_decomposition.measurable_le μ ν,	n : ℕ	⊢ (⨆ (k : ℕ) (hk : k ≤ n), f k) ∈ measure.lebesgue_decomposition.measurable_le μ ν
α : Type u_1,	m : measurable_space α,	μ ν : measure α,	f : ℕ → α → ennreal,	hf : ∀ (n : ℕ), f n ∈ measure.lebesgue_decomposition.measurable_le μ ν,	n : ℕ	⊢ (⨆ (k : ℕ) (hk : k ≤ n), f k) = λ (x : α), ⨆ (k : ℕ) (hk : k ≤ n), f k x
α : Type u_1,	m : measurable_space α,	μ ν : measure α,	f : ℕ → α → ennreal,	hf : ∀ (n : ℕ), f n ∈ measure.lebesgue_decomposition.measurable_le μ ν,	n : ℕ,	x : α,	a : nnreal	⊢ a ∈ (⨆ (k : ℕ) (hk : k ≤ n), f k) x ↔ a ∈ ⨆ (k : ℕ) (hk : k ≤ n), f k x
⊢ ∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [_inst_1 : measurable_space α] {μ : measure α}	  [_inst_2 : measurable_space β] [_inst_3 : measurable_space γ] (f : α →ₘ[μ] β) (g : α →ₘ[μ] γ),	    ⇑(f.pair g) =ᵐ[μ] λ (x : α), (⇑f x, ⇑g x)
α : Type u_1,	β : Type u_2,	γ : Type u_3,	_inst_1 : measurable_space α,	μ : measure α,	_inst_2 : measurable_space β,	_inst_3 : measurable_space γ,	f : α →ₘ[μ] β,	g : α →ₘ[μ] γ	⊢ ⇑(f.pair g) =ᵐ[μ] λ (x : α), (⇑f x, ⇑g x)
α : Type u_1,	β : Type u_2,	γ : Type u_3,	_inst_1 : measurable_space α,	μ : measure α,	_inst_2 : measurable_space β,	_inst_3 : measurable_space γ,	f : α →ₘ[μ] β,	g : α →ₘ[μ] γ	⊢ ⇑(ae_eq_fun.mk (λ (x : α), (⇑f x, ⇑g x)) _) =ᵐ[μ] λ (x : α), (⇑f x, ⇑g x)
⊢ ∀ {α : Type u_1} {G : Type u_8} [_inst_25 : normed_group G] [_inst_26 : measurable_space G]	  [_inst_27 : borel_space G] [_inst_28 : second_countable_topology G] {m m0 : measurable_space α} {μ : measure α}	  {s : set α} [_inst_37 : normed_space ℝ G] {hm : m ≤ m0} [_inst_38 : sigma_finite (μ.trim hm)]	  (hs : measurable_set s) (hμs : ⇑μ s ≠ ⊤) (x y : G),	    condexp_ind_L1_fin hm hs hμs (x + y) = condexp_ind_L1_fin hm hs hμs x + condexp_ind_L1_fin hm hs hμs y
α : Type u_1,	G : Type u_8,	_inst_25 : normed_group G,	_inst_26 : measurable_space G,	_inst_27 : borel_space G,	_inst_28 : second_countable_topology G,	m m0 : measurable_space α,	μ : measure α,	s : set α,	_inst_37 : normed_space ℝ G,	hm : m ≤ m0,	_inst_38 : sigma_finite (μ.trim hm),	hs : measurable_set s,	hμs : ⇑μ s ≠ ⊤,	x y : G	⊢ condexp_ind_L1_fin hm hs hμs (x + y) = condexp_ind_L1_fin hm hs hμs x + condexp_ind_L1_fin hm hs hμs y
α : Type u_1,	G : Type u_8,	_inst_25 : normed_group G,	_inst_26 : measurable_space G,	_inst_27 : borel_space G,	_inst_28 : second_countable_topology G,	m m0 : measurable_space α,	μ : measure α,	s : set α,	_inst_37 : normed_space ℝ G,	hm : m ≤ m0,	_inst_38 : sigma_finite (μ.trim hm),	hs : measurable_set s,	hμs : ⇑μ s ≠ ⊤,	x y : G	⊢ ⇑(condexp_ind_L1_fin hm hs hμs (x + y)) =ᵐ[μ]	    ⇑(condexp_ind_L1_fin hm hs hμs x + condexp_ind_L1_fin hm hs hμs y)
α : Type u_1,	G : Type u_8,	_inst_25 : normed_group G,	_inst_26 : measurable_space G,	_inst_27 : borel_space G,	_inst_28 : second_countable_topology G,	m m0 : measurable_space α,	μ : measure α,	s : set α,	_inst_37 : normed_space ℝ G,	hm : m ≤ m0,	_inst_38 : sigma_finite (μ.trim hm),	hs : measurable_set s,	hμs : ⇑μ s ≠ ⊤,	x y : G	⊢ ⇑(condexp_ind_smul hm hs hμs (x + y)) =ᵐ[μ]	    ⇑(condexp_ind_L1_fin hm hs hμs x + condexp_ind_L1_fin hm hs hμs y)
α : Type u_1,	G : Type u_8,	_inst_25 : normed_group G,	_inst_26 : measurable_space G,	_inst_27 : borel_space G,	_inst_28 : second_countable_topology G,	m m0 : measurable_space α,	μ : measure α,	s : set α,	_inst_37 : normed_space ℝ G,	hm : m ≤ m0,	_inst_38 : sigma_finite (μ.trim hm),	hs : measurable_set s,	hμs : ⇑μ s ≠ ⊤,	x y : G	⊢ ⇑(condexp_ind_smul hm hs hμs (x + y)) =ᵐ[μ]	    ⇑(condexp_ind_L1_fin hm hs hμs x) + ⇑(condexp_ind_L1_fin hm hs hμs y)
α : Type u_1,	G : Type u_8,	_inst_25 : normed_group G,	_inst_26 : measurable_space G,	_inst_27 : borel_space G,	_inst_28 : second_countable_topology G,	m m0 : measurable_space α,	μ : measure α,	s : set α,	_inst_37 : normed_space ℝ G,	hm : m ≤ m0,	_inst_38 : sigma_finite (μ.trim hm),	hs : measurable_set s,	hμs : ⇑μ s ≠ ⊤,	x y : G	⊢ ⇑(condexp_ind_smul hm hs hμs (x + y)) =ᵐ[μ]	    λ (x_1 : α), ⇑(condexp_ind_smul hm hs hμs x) x_1 + ⇑(condexp_ind_smul hm hs hμs y) x_1
α : Type u_1,	G : Type u_8,	_inst_25 : normed_group G,	_inst_26 : measurable_space G,	_inst_27 : borel_space G,	_inst_28 : second_countable_topology G,	m m0 : measurable_space α,	μ : measure α,	s : set α,	_inst_37 : normed_space ℝ G,	hm : m ≤ m0,	_inst_38 : sigma_finite (μ.trim hm),	hs : measurable_set s,	hμs : ⇑μ s ≠ ⊤,	x y : G	⊢ ⇑(condexp_ind_smul hm hs hμs x + condexp_ind_smul hm hs hμs y) =ᵐ[μ]	    λ (x_1 : α), ⇑(condexp_ind_smul hm hs hμs x) x_1 + ⇑(condexp_ind_smul hm hs hμs y) x_1
α : Type u_1,	G : Type u_8,	_inst_25 : normed_group G,	_inst_26 : measurable_space G,	_inst_27 : borel_space G,	_inst_28 : second_countable_topology G,	m m0 : measurable_space α,	μ : measure α,	s : set α,	_inst_37 : normed_space ℝ G,	hm : m ≤ m0,	_inst_38 : sigma_finite (μ.trim hm),	hs : measurable_set s,	hμs : ⇑μ s ≠ ⊤,	x y : G,	a : α	⊢ (⇑(condexp_ind_smul hm hs hμs x) + ⇑(condexp_ind_smul hm hs hμs y)) a =	    ⇑(condexp_ind_smul hm hs hμs x) a + ⇑(condexp_ind_smul hm hs hμs y) a
⊢ ∀ {α : Type u_1} {F' : Type u_7} [_inst_18 : normed_group F'] [_inst_20 : measurable_space F']	  [_inst_21 : borel_space F'] [_inst_22 : second_countable_topology F'] [_inst_23 : normed_space ℝ F']	  [_inst_24 : complete_space F'] {m m0 : measurable_space α} {μ : measure α} {hm : m ≤ m0}	  [_inst_37 : sigma_finite (μ.trim hm)] {s : set α} (hs : measurable_set s) (hμs : ⇑μ s ≠ ⊤) (x : F'),	    ⇑(condexp_L1_clm hm μ) ↑(simple_func.indicator_const 1 hs hμs x) = ⇑(condexp_ind hm μ s) x
α : Type u_1,	F' : Type u_7,	_inst_18 : normed_group F',	_inst_20 : measurable_space F',	_inst_21 : borel_space F',	_inst_22 : second_countable_topology F',	_inst_23 : normed_space ℝ F',	_inst_24 : complete_space F',	m m0 : measurable_space α,	μ : measure α,	hm : m ≤ m0,	_inst_37 : sigma_finite (μ.trim hm),	s : set α,	hs : measurable_set s,	hμs : ⇑μ s ≠ ⊤,	x : F'	⊢ ⇑(condexp_L1_clm hm μ) ↑(simple_func.indicator_const 1 hs hμs x) = ⇑(condexp_ind hm μ s) x
α : Type u_1,	F' : Type u_7,	_inst_18 : normed_group F',	_inst_20 : measurable_space F',	_inst_21 : borel_space F',	_inst_22 : second_countable_topology F',	_inst_23 : normed_space ℝ F',	_inst_24 : complete_space F',	m m0 : measurable_space α,	μ : measure α,	hm : m ≤ m0,	_inst_37 : sigma_finite (μ.trim hm),	s : set α,	hs : measurable_set s,	hμs : ⇑μ s ≠ ⊤,	x : F'	⊢ ⇑(condexp_L1_clm hm μ) (indicator_const_Lp 1 hs hμs x) = ⇑(condexp_ind hm μ s) x
⊢ ∀ {α : Type u_1} {F' : Type u_7} [_inst_18 : normed_group F'] [_inst_20 : measurable_space F']	  [_inst_21 : borel_space F'] [_inst_22 : second_countable_topology F'] [_inst_23 : normed_space ℝ F']	  [_inst_24 : complete_space F'] {m m0 : measurable_space α} {μ : measure α} (hm : m ≤ m0)	  [_inst_37 : sigma_finite (μ.trim hm)] {f : α → F'} {s : set α},	    integrable f μ → measurable_set s → ∫ (x : α) in s, condexp m hm μ f x ∂μ = ∫ (x : α) in s, f x ∂μ
α : Type u_1,	F' : Type u_7,	_inst_18 : normed_group F',	_inst_20 : measurable_space F',	_inst_21 : borel_space F',	_inst_22 : second_countable_topology F',	_inst_23 : normed_space ℝ F',	_inst_24 : complete_space F',	m m0 : measurable_space α,	μ : measure α,	hm : m ≤ m0,	_inst_37 : sigma_finite (μ.trim hm),	f : α → F',	s : set α,	hf : integrable f μ,	hs : measurable_set s	⊢ ∫ (x : α) in s, condexp m hm μ f x ∂μ = ∫ (x : α) in s, f x ∂μ
α : Type u_1,	F' : Type u_7,	_inst_18 : normed_group F',	_inst_20 : measurable_space F',	_inst_21 : borel_space F',	_inst_22 : second_countable_topology F',	_inst_23 : normed_space ℝ F',	_inst_24 : complete_space F',	m m0 : measurable_space α,	μ : measure α,	hm : m ≤ m0,	_inst_37 : sigma_finite (μ.trim hm),	f : α → F',	s : set α,	hf : integrable f μ,	hs : measurable_set s	⊢ ∫ (x : α) in s, (λ (x : α), ⇑(condexp_L1 hm μ f) x) x ∂μ = ∫ (x : α) in s, f x ∂μ
⊢ ∀ {α : Type u_1} {m m0 : measurable_space α} {μ : measure α} {s : set α} {hm : m ≤ m0},	    measurable_set s →	    ⇑μ s ≠ ⊤ →	    ∀ {f : ↥(Lp ℝ 2 μ)}, ⇑f =ᵐ[μ.restrict s] 0 → ⇑(⇑(condexp_L2 ℝ hm) f) =ᵐ[μ.restrict s] 0
α : Type u_1,	m m0 : measurable_space α,	μ : measure α,	s : set α,	hm : m ≤ m0,	hs : measurable_set s,	hμs : ⇑μ s ≠ ⊤,	f : ↥(Lp ℝ 2 μ),	hf : ⇑f =ᵐ[μ.restrict s] 0	⊢ ⇑(⇑(condexp_L2 ℝ hm) f) =ᵐ[μ.restrict s] 0
2 goals	α : Type u_1,	m m0 : measurable_space α,	μ : measure α,	s : set α,	hm : m ≤ m0,	hs : measurable_set s,	hμs : ⇑μ s ≠ ⊤,	f : ↥(Lp ℝ 2 μ),	hf : ⇑f =ᵐ[μ.restrict s] 0,	h_nnnorm_eq_zero : ∫⁻ (x : α) in s, ↑∥⇑(⇑(condexp_L2 ℝ hm) f) x∥₊ ∂μ = 0	⊢ ⇑(⇑(condexp_L2 ℝ hm) f) =ᵐ[μ.restrict s] 0		α : Type u_1,	m m0 : measurable_space α,	μ : measure α,	s : set α,	hm : m ≤ m0,	hs : measurable_set s,	hμs : ⇑μ s ≠ ⊤,	f : ↥(Lp ℝ 2 μ),	hf : ⇑f =ᵐ[μ.restrict s] 0	⊢ ∫⁻ (x : α) in s, ↑∥⇑(⇑(condexp_L2 ℝ hm) f) x∥₊ ∂μ = 0
3 goals	α : Type u_1,	m m0 : measurable_space α,	μ : measure α,	s : set α,	hm : m ≤ m0,	hs : measurable_set s,	hμs : ⇑μ s ≠ ⊤,	f : ↥(Lp ℝ 2 μ),	hf : ⇑f =ᵐ[μ.restrict s] 0,	h_nnnorm_eq_zero : (λ (a : α), ↑∥⇑(⇑(condexp_L2 ℝ hm) f) a∥₊) =ᵐ[μ.restrict s] 0	⊢ ⇑(⇑(condexp_L2 ℝ hm) f) =ᵐ[μ.restrict s] 0		α : Type u_1,	m m0 : measurable_space α,	μ : measure α,	s : set α,	hm : m ≤ m0,	hs : measurable_set s,	hμs : ⇑μ s ≠ ⊤,	f : ↥(Lp ℝ 2 μ),	hf : ⇑f =ᵐ[μ.restrict s] 0,	h_nnnorm_eq_zero : ∫⁻ (x : α) in s, ↑∥⇑(⇑(condexp_L2 ℝ hm) f) x∥₊ ∂μ = 0	⊢ measurable (λ (a : α), ↑∥⇑(⇑(condexp_L2 ℝ hm) f) a∥₊)		α : Type u_1,	m m0 : measurable_space α,	μ : measure α,	s : set α,	hm : m ≤ m0,	hs : measurable_set s,	hμs : ⇑μ s ≠ ⊤,	f : ↥(Lp ℝ 2 μ),	hf : ⇑f =ᵐ[μ.restrict s] 0	⊢ ∫⁻ (x : α) in s, ↑∥⇑(⇑(condexp_L2 ℝ hm) f) x∥₊ ∂μ = 0
3 goals	α : Type u_1,	m m0 : measurable_space α,	μ : measure α,	s : set α,	hm : m ≤ m0,	hs : measurable_set s,	hμs : ⇑μ s ≠ ⊤,	f : ↥(Lp ℝ 2 μ),	hf : ⇑f =ᵐ[μ.restrict s] 0,	h_nnnorm_eq_zero : (λ (a : α), ↑∥⇑(⇑(condexp_L2 ℝ hm) f) a∥₊) =ᵐ[μ.restrict s] 0,	x : α,	hx : (λ (a : α), ↑∥⇑(⇑(condexp_L2 ℝ hm) f) a∥₊) x = 0 x	⊢ ⇑(⇑(condexp_L2 ℝ hm) f) x = 0 x		α : Type u_1,	m m0 : measurable_space α,	μ : measure α,	s : set α,	hm : m ≤ m0,	hs : measurable_set s,	hμs : ⇑μ s ≠ ⊤,	f : ↥(Lp ℝ 2 μ),	hf : ⇑f =ᵐ[μ.restrict s] 0,	h_nnnorm_eq_zero : ∫⁻ (x : α) in s, ↑∥⇑(⇑(condexp_L2 ℝ hm) f) x∥₊ ∂μ = 0	⊢ measurable (λ (a : α), ↑∥⇑(⇑(condexp_L2 ℝ hm) f) a∥₊)		α : Type u_1,	m m0 : measurable_space α,	μ : measure α,	s : set α,	hm : m ≤ m0,	hs : measurable_set s,	hμs : ⇑μ s ≠ ⊤,	f : ↥(Lp ℝ 2 μ),	hf : ⇑f =ᵐ[μ.restrict s] 0	⊢ ∫⁻ (x : α) in s, ↑∥⇑(⇑(condexp_L2 ℝ hm) f) x∥₊ ∂μ = 0
3 goals	α : Type u_1,	m m0 : measurable_space α,	μ : measure α,	s : set α,	hm : m ≤ m0,	hs : measurable_set s,	hμs : ⇑μ s ≠ ⊤,	f : ↥(Lp ℝ 2 μ),	hf : ⇑f =ᵐ[μ.restrict s] 0,	h_nnnorm_eq_zero : (λ (a : α), ↑∥⇑(⇑(condexp_L2 ℝ hm) f) a∥₊) =ᵐ[μ.restrict s] 0,	x : α,	hx : ↑∥⇑(⇑(condexp_L2 ℝ hm) f) x∥₊ = 0 x	⊢ ⇑(⇑(condexp_L2 ℝ hm) f) x = 0 x		α : Type u_1,	m m0 : measurable_space α,	μ : measure α,	s : set α,	hm : m ≤ m0,	hs : measurable_set s,	hμs : ⇑μ s ≠ ⊤,	f : ↥(Lp ℝ 2 μ),	hf : ⇑f =ᵐ[μ.restrict s] 0,	h_nnnorm_eq_zero : ∫⁻ (x : α) in s, ↑∥⇑(⇑(condexp_L2 ℝ hm) f) x∥₊ ∂μ = 0	⊢ measurable (λ (a : α), ↑∥⇑(⇑(condexp_L2 ℝ hm) f) a∥₊)		α : Type u_1,	m m0 : measurable_space α,	μ : measure α,	s : set α,	hm : m ≤ m0,	hs : measurable_set s,	hμs : ⇑μ s ≠ ⊤,	f : ↥(Lp ℝ 2 μ),	hf : ⇑f =ᵐ[μ.restrict s] 0	⊢ ∫⁻ (x : α) in s, ↑∥⇑(⇑(condexp_L2 ℝ hm) f) x∥₊ ∂μ = 0
3 goals	α : Type u_1,	m m0 : measurable_space α,	μ : measure α,	s : set α,	hm : m ≤ m0,	hs : measurable_set s,	hμs : ⇑μ s ≠ ⊤,	f : ↥(Lp ℝ 2 μ),	hf : ⇑f =ᵐ[μ.restrict s] 0,	h_nnnorm_eq_zero : (λ (a : α), ↑∥⇑(⇑(condexp_L2 ℝ hm) f) a∥₊) =ᵐ[μ.restrict s] 0,	x : α,	hx : ↑∥⇑(⇑(condexp_L2 ℝ hm) f) x∥₊ = 0	⊢ ⇑(⇑(condexp_L2 ℝ hm) f) x = 0		α : Type u_1,	m m0 : measurable_space α,	μ : measure α,	s : set α,	hm : m ≤ m0,	hs : measurable_set s,	hμs : ⇑μ s ≠ ⊤,	f : ↥(Lp ℝ 2 μ),	hf : ⇑f =ᵐ[μ.restrict s] 0,	h_nnnorm_eq_zero : ∫⁻ (x : α) in s, ↑∥⇑(⇑(condexp_L2 ℝ hm) f) x∥₊ ∂μ = 0	⊢ measurable (λ (a : α), ↑∥⇑(⇑(condexp_L2 ℝ hm) f) a∥₊)		α : Type u_1,	m m0 : measurable_space α,	μ : measure α,	s : set α,	hm : m ≤ m0,	hs : measurable_set s,	hμs : ⇑μ s ≠ ⊤,	f : ↥(Lp ℝ 2 μ),	hf : ⇑f =ᵐ[μ.restrict s] 0	⊢ ∫⁻ (x : α) in s, ↑∥⇑(⇑(condexp_L2 ℝ hm) f) x∥₊ ∂μ = 0
2 goals	α : Type u_1,	m m0 : measurable_space α,	μ : measure α,	s : set α,	hm : m ≤ m0,	hs : measurable_set s,	hμs : ⇑μ s ≠ ⊤,	f : ↥(Lp ℝ 2 μ),	hf : ⇑f =ᵐ[μ.restrict s] 0,	h_nnnorm_eq_zero : ∫⁻ (x : α) in s, ↑∥⇑(⇑(condexp_L2 ℝ hm) f) x∥₊ ∂μ = 0	⊢ measurable (λ (a : α), ↑∥⇑(⇑(condexp_L2 ℝ hm) f) a∥₊)		α : Type u_1,	m m0 : measurable_space α,	μ : measure α,	s : set α,	hm : m ≤ m0,	hs : measurable_set s,	hμs : ⇑μ s ≠ ⊤,	f : ↥(Lp ℝ 2 μ),	hf : ⇑f =ᵐ[μ.restrict s] 0	⊢ ∫⁻ (x : α) in s, ↑∥⇑(⇑(condexp_L2 ℝ hm) f) x∥₊ ∂μ = 0
2 goals	α : Type u_1,	m m0 : measurable_space α,	μ : measure α,	s : set α,	hm : m ≤ m0,	hs : measurable_set s,	hμs : ⇑μ s ≠ ⊤,	f : ↥(Lp ℝ 2 μ),	hf : ⇑f =ᵐ[μ.restrict s] 0,	h_nnnorm_eq_zero : ∫⁻ (x : α) in s, ↑∥⇑(⇑(condexp_L2 ℝ hm) f) x∥₊ ∂μ = 0	⊢ measurable (λ (a : α), ⇑(⇑(condexp_L2 ℝ hm) f) a)		α : Type u_1,	m m0 : measurable_space α,	μ : measure α,	s : set α,	hm : m ≤ m0,	hs : measurable_set s,	hμs : ⇑μ s ≠ ⊤,	f : ↥(Lp ℝ 2 μ),	hf : ⇑f =ᵐ[μ.restrict s] 0	⊢ ∫⁻ (x : α) in s, ↑∥⇑(⇑(condexp_L2 ℝ hm) f) x∥₊ ∂μ = 0
2 goals	α : Type u_1,	m m0 : measurable_space α,	μ : measure α,	s : set α,	hm : m ≤ m0,	hs : measurable_set s,	hμs : ⇑μ s ≠ ⊤,	f : ↥(Lp ℝ 2 μ),	hf : ⇑f =ᵐ[μ.restrict s] 0,	h_nnnorm_eq_zero : ∫⁻ (x : α) in s, ↑∥⇑(⇑(condexp_L2 ℝ hm) f) x∥₊ ∂μ = 0	⊢ measurable (λ (a : α), ⇑↑(⇑(condexp_L2 ℝ hm) f) a)		α : Type u_1,	m m0 : measurable_space α,	μ : measure α,	s : set α,	hm : m ≤ m0,	hs : measurable_set s,	hμs : ⇑μ s ≠ ⊤,	f : ↥(Lp ℝ 2 μ),	hf : ⇑f =ᵐ[μ.restrict s] 0	⊢ ∫⁻ (x : α) in s, ↑∥⇑(⇑(condexp_L2 ℝ hm) f) x∥₊ ∂μ = 0
α : Type u_1,	m m0 : measurable_space α,	μ : measure α,	s : set α,	hm : m ≤ m0,	hs : measurable_set s,	hμs : ⇑μ s ≠ ⊤,	f : ↥(Lp ℝ 2 μ),	hf : ⇑f =ᵐ[μ.restrict s] 0	⊢ ∫⁻ (x : α) in s, ↑∥⇑(⇑(condexp_L2 ℝ hm) f) x∥₊ ∂μ = 0
α : Type u_1,	m m0 : measurable_space α,	μ : measure α,	s : set α,	hm : m ≤ m0,	hs : measurable_set s,	hμs : ⇑μ s ≠ ⊤,	f : ↥(Lp ℝ 2 μ),	hf : ⇑f =ᵐ[μ.restrict s] 0	⊢ ∫⁻ (x : α) in s, ↑∥⇑(⇑(condexp_L2 ℝ hm) f) x∥₊ ∂μ ≤ 0
α : Type u_1,	m m0 : measurable_space α,	μ : measure α,	s : set α,	hm : m ≤ m0,	hs : measurable_set s,	hμs : ⇑μ s ≠ ⊤,	f : ↥(Lp ℝ 2 μ),	hf : ⇑f =ᵐ[μ.restrict s] 0	⊢ ∫⁻ (x : α) in s, ↑∥⇑f x∥₊ ∂μ = 0
2 goals	α : Type u_1,	m m0 : measurable_space α,	μ : measure α,	s : set α,	hm : m ≤ m0,	hs : measurable_set s,	hμs : ⇑μ s ≠ ⊤,	f : ↥(Lp ℝ 2 μ),	hf : ⇑f =ᵐ[μ.restrict s] 0	⊢ (λ (a : α), ↑∥⇑f a∥₊) =ᵐ[μ.restrict s] 0		α : Type u_1,	m m0 : measurable_space α,	μ : measure α,	s : set α,	hm : m ≤ m0,	hs : measurable_set s,	hμs : ⇑μ s ≠ ⊤,	f : ↥(Lp ℝ 2 μ),	hf : ⇑f =ᵐ[μ.restrict s] 0	⊢ measurable (λ (a : α), ↑∥⇑f a∥₊)
2 goals	α : Type u_1,	m m0 : measurable_space α,	μ : measure α,	s : set α,	hm : m ≤ m0,	hs : measurable_set s,	hμs : ⇑μ s ≠ ⊤,	f : ↥(Lp ℝ 2 μ),	hf : ⇑f =ᵐ[μ.restrict s] 0,	x : α,	hx : ⇑f x = 0 x	⊢ (λ (a : α), ↑∥⇑f a∥₊) x = 0 x		α : Type u_1,	m m0 : measurable_space α,	μ : measure α,	s : set α,	hm : m ≤ m0,	hs : measurable_set s,	hμs : ⇑μ s ≠ ⊤,	f : ↥(Lp ℝ 2 μ),	hf : ⇑f =ᵐ[μ.restrict s] 0	⊢ measurable (λ (a : α), ↑∥⇑f a∥₊)
2 goals	α : Type u_1,	m m0 : measurable_space α,	μ : measure α,	s : set α,	hm : m ≤ m0,	hs : measurable_set s,	hμs : ⇑μ s ≠ ⊤,	f : ↥(Lp ℝ 2 μ),	hf : ⇑f =ᵐ[μ.restrict s] 0,	x : α,	hx : ⇑f x = 0 x	⊢ ↑∥⇑f x∥₊ = 0 x		α : Type u_1,	m m0 : measurable_space α,	μ : measure α,	s : set α,	hm : m ≤ m0,	hs : measurable_set s,	hμs : ⇑μ s ≠ ⊤,	f : ↥(Lp ℝ 2 μ),	hf : ⇑f =ᵐ[μ.restrict s] 0	⊢ measurable (λ (a : α), ↑∥⇑f a∥₊)
2 goals	α : Type u_1,	m m0 : measurable_space α,	μ : measure α,	s : set α,	hm : m ≤ m0,	hs : measurable_set s,	hμs : ⇑μ s ≠ ⊤,	f : ↥(Lp ℝ 2 μ),	hf : ⇑f =ᵐ[μ.restrict s] 0,	x : α,	hx : ⇑f x = 0 x	⊢ ↑∥0 x∥₊ = 0 x		α : Type u_1,	m m0 : measurable_space α,	μ : measure α,	s : set α,	hm : m ≤ m0,	hs : measurable_set s,	hμs : ⇑μ s ≠ ⊤,	f : ↥(Lp ℝ 2 μ),	hf : ⇑f =ᵐ[μ.restrict s] 0	⊢ measurable (λ (a : α), ↑∥⇑f a∥₊)
α : Type u_1,	m m0 : measurable_space α,	μ : measure α,	s : set α,	hm : m ≤ m0,	hs : measurable_set s,	hμs : ⇑μ s ≠ ⊤,	f : ↥(Lp ℝ 2 μ),	hf : ⇑f =ᵐ[μ.restrict s] 0	⊢ measurable (λ (a : α), ↑∥⇑f a∥₊)
⊢ ∀ {α : Type u_1} {E : Type u_2} {F : Type u_3} {m0 : measurable_space α} {p : ennreal} {μ : measure α}	  [_inst_1 : measurable_space E] [_inst_2 : normed_group E] [_inst_3 : normed_group F] [_inst_5 : borel_space E]	  [_inst_6 : second_countable_topology E] [_inst_7 : second_countable_topology F] [_inst_8 : measurable_space F]	  [_inst_9 : borel_space F] {f : ↥(Lp E p μ)} {g : ↥(Lp F p μ)},	    (∀ᵐ (x : α) ∂μ, ∥⇑f x∥ ≤ ∥⇑g x∥) → ∥f∥ ≤ ∥g∥
α : Type u_1,	E : Type u_2,	F : Type u_3,	m0 : measurable_space α,	p : ennreal,	μ : measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_3 : normed_group F,	_inst_5 : borel_space E,	_inst_6 : second_countable_topology E,	_inst_7 : second_countable_topology F,	_inst_8 : measurable_space F,	_inst_9 : borel_space F,	f : ↥(Lp E p μ),	g : ↥(Lp F p μ),	h : ∀ᵐ (x : α) ∂μ, ∥⇑f x∥ ≤ ∥⇑g x∥	⊢ ∥f∥ ≤ ∥g∥
α : Type u_1,	E : Type u_2,	F : Type u_3,	m0 : measurable_space α,	p : ennreal,	μ : measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_3 : normed_group F,	_inst_5 : borel_space E,	_inst_6 : second_countable_topology E,	_inst_7 : second_countable_topology F,	_inst_8 : measurable_space F,	_inst_9 : borel_space F,	f : ↥(Lp E p μ),	g : ↥(Lp F p μ),	h : ∀ᵐ (x : α) ∂μ, ∥⇑f x∥ ≤ ∥⇑g x∥	⊢ snorm ⇑f p μ ≤ snorm ⇑g p μ
⊢ ∀ {α : Type u_1} {F : Type u_3} {m0 : measurable_space α} {q : ℝ} {μ : measure α} [_inst_3 : normed_group F]	  {f : α → F}, 0 < q → ∫⁻ (a : α), ↑∥f a∥₊ ^ q ∂μ = snorm' f q μ ^ q
α : Type u_1,	F : Type u_3,	m0 : measurable_space α,	q : ℝ,	μ : measure α,	_inst_3 : normed_group F,	f : α → F,	hq0_lt : 0 < q	⊢ ∫⁻ (a : α), ↑∥f a∥₊ ^ q ∂μ = snorm' f q μ ^ q
α : Type u_1,	F : Type u_3,	m0 : measurable_space α,	q : ℝ,	μ : measure α,	_inst_3 : normed_group F,	f : α → F,	hq0_lt : 0 < q	⊢ q ≠ 0
⊢ ∀ {α : Type u_1} {F : Type u_3} {m0 : measurable_space α} {μ : measure α} [_inst_3 : normed_group F]	  {f : α → F}, snorm' f 0 μ = 1
α : Type u_1,	F : Type u_3,	m0 : measurable_space α,	μ : measure α,	_inst_3 : normed_group F,	f : α → F	⊢ snorm' f 0 μ = 1
⊢ ∀ {α : Type u_1} {F : Type u_3} {m0 : measurable_space α} {q : ℝ} {μ : measure α}	  [_inst_3 : normed_group F], q ≠ 0 → μ ≠ 0 → snorm' 0 q μ = 0
α : Type u_1,	F : Type u_3,	m0 : measurable_space α,	q : ℝ,	μ : measure α,	_inst_3 : normed_group F,	hq0_ne : q ≠ 0,	hμ : μ ≠ 0	⊢ snorm' 0 q μ = 0
2 goals	case or.inl	α : Type u_1,	F : Type u_3,	m0 : measurable_space α,	q : ℝ,	μ : measure α,	_inst_3 : normed_group F,	hq0_ne : q ≠ 0,	hμ : μ ≠ 0,	hq0 : 0 ≤ q	⊢ snorm' 0 q μ = 0		case or.inr	α : Type u_1,	F : Type u_3,	m0 : measurable_space α,	q : ℝ,	μ : measure α,	_inst_3 : normed_group F,	hq0_ne : q ≠ 0,	hμ : μ ≠ 0,	hq_neg : q < 0	⊢ snorm' 0 q μ = 0
case or.inr	α : Type u_1,	F : Type u_3,	m0 : measurable_space α,	q : ℝ,	μ : measure α,	_inst_3 : normed_group F,	hq0_ne : q ≠ 0,	hμ : μ ≠ 0,	hq_neg : q < 0	⊢ snorm' 0 q μ = 0
⊢ ∀ {α : Type u_1} {E : Type u_2} {m0 : measurable_space α} {p : ennreal} {μ : measure α}	  [_inst_1 : measurable_space E] [_inst_2 : normed_group E] [_inst_5 : borel_space E]	  [_inst_6 : second_countable_topology E] [_inst_7 : topological_space α] [_inst_8 : borel_space α]	  [_inst_9 : is_finite_measure μ] (f : bounded_continuous_function α E),	    continuous_map.to_ae_eq_fun μ f.to_continuous_map ∈ Lp E p μ
α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ennreal,	μ : measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : second_countable_topology E,	_inst_7 : topological_space α,	_inst_8 : borel_space α,	_inst_9 : is_finite_measure μ,	f : bounded_continuous_function α E	⊢ continuous_map.to_ae_eq_fun μ f.to_continuous_map ∈ Lp E p μ
α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ennreal,	μ : measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : second_countable_topology E,	_inst_7 : topological_space α,	_inst_8 : borel_space α,	_inst_9 : is_finite_measure μ,	f : bounded_continuous_function α E	⊢ ∀ᵐ (x : α) ∂μ, ∥⇑(continuous_map.to_ae_eq_fun μ f.to_continuous_map) x∥ ≤ ∥f∥
α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ennreal,	μ : measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : second_countable_topology E,	_inst_7 : topological_space α,	_inst_8 : borel_space α,	_inst_9 : is_finite_measure μ,	f : bounded_continuous_function α E	⊢ ∀ (a : α),	    ⇑(continuous_map.to_ae_eq_fun μ f.to_continuous_map) a = ⇑(f.to_continuous_map) a →	    ∥⇑(continuous_map.to_ae_eq_fun μ f.to_continuous_map) a∥ ≤ ∥f∥
α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ennreal,	μ : measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : second_countable_topology E,	_inst_7 : topological_space α,	_inst_8 : borel_space α,	_inst_9 : is_finite_measure μ,	f : bounded_continuous_function α E,	x : α,	hx : ⇑(continuous_map.to_ae_eq_fun μ f.to_continuous_map) x = ⇑(f.to_continuous_map) x	⊢ ∥⇑(continuous_map.to_ae_eq_fun μ f.to_continuous_map) x∥ ≤ ∥f∥
⊢ ∀ {α : Type u_1} {F : Type u_3} {m0 : measurable_space α} {μ : measure α} [_inst_3 : normed_group F]	  {f : α → F}, snorm_ess_sup f μ = 0 ↔ f =ᵐ[μ] 0
α : Type u_1,	F : Type u_3,	m0 : measurable_space α,	μ : measure α,	_inst_3 : normed_group F,	f : α → F	⊢ snorm_ess_sup f μ = 0 ↔ f =ᵐ[μ] 0
⊢ ∀ {α : Type u_1} {m m0 : measurable_space α} {ν : measure α} (hm : m ≤ m0) {f : α → ennreal},	    measurable f → ess_sup f (ν.trim hm) = ess_sup f ν
α : Type u_1,	m m0 : measurable_space α,	ν : measure α,	hm : m ≤ m0,	f : α → ennreal,	hf : measurable f	⊢ ess_sup f (ν.trim hm) = ess_sup f ν
α : Type u_1,	m m0 : measurable_space α,	ν : measure α,	hm : m ≤ m0,	f : α → ennreal,	hf : measurable f	⊢ (ν.trim hm).ae.limsup f = ν.ae.limsup f
⊢ ∀ {α : Type u_1} {G : Type u_2} {p : ennreal} {m0 : measurable_space α} {μ : measure α}	  [_inst_1 : normed_group G] [_inst_2 : measurable_space G] [_inst_3 : borel_space G]	  [_inst_4 : second_countable_topology G] {f : α → G},	    mem_ℒp f p μ → measurable f → p ≠ 0 → p ≠ ⊤ → fin_strongly_measurable f μ
α : Type u_1,	G : Type u_2,	p : ennreal,	m0 : measurable_space α,	μ : measure α,	_inst_1 : normed_group G,	_inst_2 : measurable_space G,	_inst_3 : borel_space G,	_inst_4 : second_countable_topology G,	f : α → G,	hf : mem_ℒp f p μ,	hf_meas : measurable f,	hp_ne_zero : p ≠ 0,	hp_ne_top : p ≠ ⊤	⊢ fin_strongly_measurable f μ
α : Type u_1,	G : Type u_2,	p : ennreal,	m0 : measurable_space α,	μ : measure α,	_inst_1 : normed_group G,	_inst_2 : measurable_space G,	_inst_3 : borel_space G,	_inst_4 : second_countable_topology G,	f : α → G,	hf : mem_ℒp f p μ,	hf_meas : measurable f,	hp_ne_zero : p ≠ 0,	hp_ne_top : p ≠ ⊤,	fs : ℕ → simple_func α G := simple_func.approx_on f hf_meas set.univ 0 _	⊢ fin_strongly_measurable f μ
2 goals	α : Type u_1,	G : Type u_2,	p : ennreal,	m0 : measurable_space α,	μ : measure α,	_inst_1 : normed_group G,	_inst_2 : measurable_space G,	_inst_3 : borel_space G,	_inst_4 : second_countable_topology G,	f : α → G,	hf : mem_ℒp f p μ,	hf_meas : measurable f,	hp_ne_zero : p ≠ 0,	hp_ne_top : p ≠ ⊤,	fs : ℕ → simple_func α G := simple_func.approx_on f hf_meas set.univ 0 _	⊢ ∀ (n : ℕ), ⇑μ (support ⇑(fs n)) < ⊤		α : Type u_1,	G : Type u_2,	p : ennreal,	m0 : measurable_space α,	μ : measure α,	_inst_1 : normed_group G,	_inst_2 : measurable_space G,	_inst_3 : borel_space G,	_inst_4 : second_countable_topology G,	f : α → G,	hf : mem_ℒp f p μ,	hf_meas : measurable f,	hp_ne_zero : p ≠ 0,	hp_ne_top : p ≠ ⊤,	fs : ℕ → simple_func α G := simple_func.approx_on f hf_meas set.univ 0 _	⊢ ∀ (x : α), tendsto (λ (n : ℕ), ⇑(fs n) x) at_top (nhds (f x))
3 goals	α : Type u_1,	G : Type u_2,	p : ennreal,	m0 : measurable_space α,	μ : measure α,	_inst_1 : normed_group G,	_inst_2 : measurable_space G,	_inst_3 : borel_space G,	_inst_4 : second_countable_topology G,	f : α → G,	hf : mem_ℒp f p μ,	hf_meas : measurable f,	hp_ne_zero : p ≠ 0,	hp_ne_top : p ≠ ⊤,	fs : ℕ → simple_func α G := simple_func.approx_on f hf_meas set.univ 0 _	⊢ ∀ (n : ℕ), mem_ℒp ⇑(fs n) p μ		α : Type u_1,	G : Type u_2,	p : ennreal,	m0 : measurable_space α,	μ : measure α,	_inst_1 : normed_group G,	_inst_2 : measurable_space G,	_inst_3 : borel_space G,	_inst_4 : second_countable_topology G,	f : α → G,	hf : mem_ℒp f p μ,	hf_meas : measurable f,	hp_ne_zero : p ≠ 0,	hp_ne_top : p ≠ ⊤,	fs : ℕ → simple_func α G := simple_func.approx_on f hf_meas set.univ 0 _,	h_fs_Lp : ∀ (n : ℕ), mem_ℒp ⇑(fs n) p μ	⊢ ∀ (n : ℕ), ⇑μ (support ⇑(fs n)) < ⊤		α : Type u_1,	G : Type u_2,	p : ennreal,	m0 : measurable_space α,	μ : measure α,	_inst_1 : normed_group G,	_inst_2 : measurable_space G,	_inst_3 : borel_space G,	_inst_4 : second_countable_topology G,	f : α → G,	hf : mem_ℒp f p μ,	hf_meas : measurable f,	hp_ne_zero : p ≠ 0,	hp_ne_top : p ≠ ⊤,	fs : ℕ → simple_func α G := simple_func.approx_on f hf_meas set.univ 0 _	⊢ ∀ (x : α), tendsto (λ (n : ℕ), ⇑(fs n) x) at_top (nhds (f x))
2 goals	α : Type u_1,	G : Type u_2,	p : ennreal,	m0 : measurable_space α,	μ : measure α,	_inst_1 : normed_group G,	_inst_2 : measurable_space G,	_inst_3 : borel_space G,	_inst_4 : second_countable_topology G,	f : α → G,	hf : mem_ℒp f p μ,	hf_meas : measurable f,	hp_ne_zero : p ≠ 0,	hp_ne_top : p ≠ ⊤,	fs : ℕ → simple_func α G := simple_func.approx_on f hf_meas set.univ 0 _,	h_fs_Lp : ∀ (n : ℕ), mem_ℒp ⇑(fs n) p μ	⊢ ∀ (n : ℕ), ⇑μ (support ⇑(fs n)) < ⊤		α : Type u_1,	G : Type u_2,	p : ennreal,	m0 : measurable_space α,	μ : measure α,	_inst_1 : normed_group G,	_inst_2 : measurable_space G,	_inst_3 : borel_space G,	_inst_4 : second_countable_topology G,	f : α → G,	hf : mem_ℒp f p μ,	hf_meas : measurable f,	hp_ne_zero : p ≠ 0,	hp_ne_top : p ≠ ⊤,	fs : ℕ → simple_func α G := simple_func.approx_on f hf_meas set.univ 0 _	⊢ ∀ (x : α), tendsto (λ (n : ℕ), ⇑(fs n) x) at_top (nhds (f x))
α : Type u_1,	G : Type u_2,	p : ennreal,	m0 : measurable_space α,	μ : measure α,	_inst_1 : normed_group G,	_inst_2 : measurable_space G,	_inst_3 : borel_space G,	_inst_4 : second_countable_topology G,	f : α → G,	hf : mem_ℒp f p μ,	hf_meas : measurable f,	hp_ne_zero : p ≠ 0,	hp_ne_top : p ≠ ⊤,	fs : ℕ → simple_func α G := simple_func.approx_on f hf_meas set.univ 0 _	⊢ ∀ (x : α), tendsto (λ (n : ℕ), ⇑(fs n) x) at_top (nhds (f x))
⊢ ∀ {α : Type u_1} {m : measurable_space α} {μ : measure α} {H : Type u_6} [_inst_18 : normed_group H]	  [_inst_19 : second_countable_topology H] [_inst_20 : measurable_space H] [_inst_21 : borel_space H] {f : α → H}	  (hf : integrable f μ), ∥integrable.to_L1 f hf∥ = ∫ (a : α), ∥f a∥ ∂μ
α : Type u_1,	m : measurable_space α,	μ : measure α,	H : Type u_6,	_inst_18 : normed_group H,	_inst_19 : second_countable_topology H,	_inst_20 : measurable_space H,	_inst_21 : borel_space H,	f : α → H,	hf : integrable f μ	⊢ ∥integrable.to_L1 f hf∥ = ∫ (a : α), ∥f a∥ ∂μ
α : Type u_1,	m : measurable_space α,	μ : measure α,	H : Type u_6,	_inst_18 : normed_group H,	_inst_19 : second_countable_topology H,	_inst_20 : measurable_space H,	_inst_21 : borel_space H,	f : α → H,	hf : integrable f μ	⊢ ∫ (a : α), ∥⇑(integrable.to_L1 f hf) a∥ ∂μ = ∫ (a : α), ∥f a∥ ∂μ
α : Type u_1,	m : measurable_space α,	μ : measure α,	H : Type u_6,	_inst_18 : normed_group H,	_inst_19 : second_countable_topology H,	_inst_20 : measurable_space H,	_inst_21 : borel_space H,	f : α → H,	hf : integrable f μ	⊢ (λ (a : α), ∥⇑(integrable.to_L1 f hf) a∥) =ᵐ[μ] λ (a : α), ∥f a∥
α : Type u_1,	m : measurable_space α,	μ : measure α,	H : Type u_6,	_inst_18 : normed_group H,	_inst_19 : second_countable_topology H,	_inst_20 : measurable_space H,	_inst_21 : borel_space H,	f : α → H,	hf : integrable f μ	⊢ ∀ (x : α),	    (λ (x : α), ⇑(integrable.to_L1 f hf) x = f x) x →	    (λ (a : α), ∥⇑(integrable.to_L1 f hf) a∥) x = (λ (a : α), ∥f a∥) x
α : Type u_1,	m : measurable_space α,	μ : measure α,	H : Type u_6,	_inst_18 : normed_group H,	_inst_19 : second_countable_topology H,	_inst_20 : measurable_space H,	_inst_21 : borel_space H,	f : α → H,	hf : integrable f μ,	a : α,	ha : ⇑(integrable.to_L1 f hf) a = f a	⊢ (λ (a : α), ∥⇑(integrable.to_L1 f hf) a∥) a = (λ (a : α), ∥f a∥) a
⊢ ∀ {α : Type u_1} {E : Type u_2} [_inst_1 : normed_group E] [_inst_2 : second_countable_topology E]	  [_inst_3 : normed_space ℝ E] [_inst_4 : complete_space E] [_inst_5 : measurable_space E] [_inst_6 : borel_space E]	  {m : measurable_space α} {μ : measure α} {f : α → E}, f =ᵐ[μ] 0 → ∫ (a : α), f a ∂μ = 0
α : Type u_1,	E : Type u_2,	_inst_1 : normed_group E,	_inst_2 : second_countable_topology E,	_inst_3 : normed_space ℝ E,	_inst_4 : complete_space E,	_inst_5 : measurable_space E,	_inst_6 : borel_space E,	m : measurable_space α,	μ : measure α,	f : α → E,	hf : f =ᵐ[μ] 0	⊢ ∫ (a : α), f a ∂μ = 0
⊢ ∀ {α : Type u_1} {E : Type u_3} [_inst_1 : measurable_space α] [_inst_2 : measurable_space E]	  [_inst_3 : normed_group E] [_inst_4 : topological_space α] [_inst_5 : opens_measurable_space α]	  [_inst_6 : t2_space α] [_inst_7 : borel_space E] {μ : measure α} [_inst_8 : is_locally_finite_measure μ]	  {f : α → E}, continuous f → is_compact (closure (support f)) → integrable f μ
α : Type u_1,	E : Type u_3,	_inst_1 : measurable_space α,	_inst_2 : measurable_space E,	_inst_3 : normed_group E,	_inst_4 : topological_space α,	_inst_5 : opens_measurable_space α,	_inst_6 : t2_space α,	_inst_7 : borel_space E,	μ : measure α,	_inst_8 : is_locally_finite_measure μ,	f : α → E,	hf : continuous f,	hfc : is_compact (closure (support f))	⊢ integrable f μ
2 goals	α : Type u_1,	E : Type u_3,	_inst_1 : measurable_space α,	_inst_2 : measurable_space E,	_inst_3 : normed_group E,	_inst_4 : topological_space α,	_inst_5 : opens_measurable_space α,	_inst_6 : t2_space α,	_inst_7 : borel_space E,	μ : measure α,	_inst_8 : is_locally_finite_measure μ,	f : α → E,	hf : continuous f,	hfc : is_compact (closure (support f))	⊢ integrable_on f (closure (support f)) μ		α : Type u_1,	E : Type u_3,	_inst_1 : measurable_space α,	_inst_2 : measurable_space E,	_inst_3 : normed_group E,	_inst_4 : topological_space α,	_inst_5 : opens_measurable_space α,	_inst_6 : t2_space α,	_inst_7 : borel_space E,	μ : measure α,	_inst_8 : is_locally_finite_measure μ,	f : α → E,	hf : continuous f,	hfc : is_compact (closure (support f))	⊢ opens_measurable_space α
α : Type u_1,	E : Type u_3,	_inst_1 : measurable_space α,	_inst_2 : measurable_space E,	_inst_3 : normed_group E,	_inst_4 : topological_space α,	_inst_5 : opens_measurable_space α,	_inst_6 : t2_space α,	_inst_7 : borel_space E,	μ : measure α,	_inst_8 : is_locally_finite_measure μ,	f : α → E,	hf : continuous f,	hfc : is_compact (closure (support f))	⊢ opens_measurable_space α
⊢ ∀ {α : Type u_1} [_inst_1 : measurable_space α] [_inst_4 : topological_space α]	  [_inst_5 : opens_measurable_space α] {μ : measure α} {s t : set α} {f g : α → ℝ},	    integrable_on f s μ →	    continuous_on g t → measurable_set s → is_compact t → s ⊆ t → integrable_on (λ (x : α), g x * f x) s μ
α : Type u_1,	_inst_1 : measurable_space α,	_inst_4 : topological_space α,	_inst_5 : opens_measurable_space α,	μ : measure α,	s t : set α,	f g : α → ℝ,	hf : integrable_on f s μ,	hg : continuous_on g t,	hs : measurable_set s,	ht : is_compact t,	hst : s ⊆ t	⊢ integrable_on (λ (x : α), g x * f x) s μ
⊢ ∀ {α : Type u_1} {E : Type u_4} [_inst_1 : linear_order α] [_inst_2 : measurable_space α]	  [_inst_3 : measurable_space E] [_inst_4 : normed_group E] [_inst_5 : second_countable_topology E]	  [_inst_6 : complete_space E] [_inst_7 : normed_space ℝ E] [_inst_8 : borel_space E] [_inst_9 : topological_space α]	  [_inst_10 : order_topology α] [_inst_11 : opens_measurable_space α] [_inst_12 : first_countable_topology α]	  {μ : measure α} {f : α → E} {a b : α} [_inst_13 : has_no_atoms μ],	    integrable_on f (Icc a b) μ → continuous_on (λ (x : α), ∫ (t : α) in Icc a x, f t ∂μ) (Icc a b)
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : first_countable_topology α,	μ : measure α,	f : α → E,	a b : α,	_inst_13 : has_no_atoms μ,	h_int : integrable_on f (Icc a b) μ	⊢ continuous_on (λ (x : α), ∫ (t : α) in Icc a x, f t ∂μ) (Icc a b)
α : Type u_1,	E : Type u_4,	_inst_1 : linear_order α,	_inst_2 : measurable_space α,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	_inst_9 : topological_space α,	_inst_10 : order_topology α,	_inst_11 : opens_measurable_space α,	_inst_12 : first_countable_topology α,	μ : measure α,	f : α → E,	a b : α,	_inst_13 : has_no_atoms μ,	h_int : integrable_on f (Icc a b) μ	⊢ continuous_on (λ (x : α), ∫ (t : α) in Ioc a x, f t ∂μ) (Icc a b)
⊢ ∀ {α : Type u_1} [_inst_6 : conditionally_complete_linear_order α] [_inst_7 : measurable_space α]	  [_inst_8 : topological_space α] [_inst_9 : order_topology α] [_inst_10 : opens_measurable_space α]	  {μ : measure α} {a b : α} {f g : α → ℝ},	    interval_integrable f μ a b →	    continuous_on g (interval a b) → interval_integrable (λ (x : α), g x * f x) μ a b
α : Type u_1,	_inst_6 : conditionally_complete_linear_order α,	_inst_7 : measurable_space α,	_inst_8 : topological_space α,	_inst_9 : order_topology α,	_inst_10 : opens_measurable_space α,	μ : measure α,	a b : α,	f g : α → ℝ,	hf : interval_integrable f μ a b,	hg : continuous_on g (interval a b)	⊢ interval_integrable (λ (x : α), g x * f x) μ a b
⊢ ∀ {E : Type u_4} [_inst_3 : measurable_space E] [_inst_4 : normed_group E] [_inst_5 : second_countable_topology E]	  [_inst_6 : complete_space E] [_inst_7 : normed_space ℝ E] [_inst_8 : borel_space E] {a b : ℝ} (f : ℝ → E)	  (d : ℝ), ∫ (x : ℝ) in a..b, f (x - d) = ∫ (x : ℝ) in a - d..b - d, f x
E : Type u_4,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	a b : ℝ,	f : ℝ → E,	d : ℝ	⊢ ∫ (x : ℝ) in a..b, f (x - d) = ∫ (x : ℝ) in a - d..b - d, f x
⊢ ∀ {α : Type u_1} {m : measurable_space α} {μ : measure α} {ι : Sort u_2} {ι' : ι → Sort u_3}	  (f : Π (i : ι), ι' i → α → ennreal),	    ∫⁻ (a : α), (⨅ (i : ι) (h : ι' i), f i h a) ∂μ ≤	      ⨅ (i : ι) (h : ι' i), ∫⁻ (a : α), f i h a ∂μ
α : Type u_1,	m : measurable_space α,	μ : measure α,	ι : Sort u_2,	ι' : ι → Sort u_3,	f : Π (i : ι), ι' i → α → ennreal	⊢ ∫⁻ (a : α), (⨅ (i : ι) (h : ι' i), f i h a) ∂μ ≤	    ⨅ (i : ι) (h : ι' i), ∫⁻ (a : α), f i h a ∂μ
α : Type u_1,	m : measurable_space α,	μ : measure α,	ι : Sort u_2,	ι' : ι → Sort u_3,	f : Π (i : ι), ι' i → α → ennreal	⊢ (λ (a : α), ⨅ (i : ι) (h : ι' i), f i h a) = ⨅ (i : ι), infi (f i)
α : Type u_1,	m : measurable_space α,	μ : measure α,	ι : Sort u_2,	ι' : ι → Sort u_3,	f : Π (i : ι), ι' i → α → ennreal,	a : α	⊢ (⨅ (i : ι) (h : ι' i), f i h a) = (⨅ (i : ι), infi (f i)) a
⊢ ∀ {α : Type u_1} {m : measurable_space α} {μ : measure α} (r : ennreal) (f : α → ennreal),	    r ≠ ⊤ → ∫⁻ (a : α), r * f a ∂μ = r * ∫⁻ (a : α), f a ∂μ
α : Type u_1,	m : measurable_space α,	μ : measure α,	r : ennreal,	f : α → ennreal,	hr : r ≠ ⊤	⊢ ∫⁻ (a : α), r * f a ∂μ = r * ∫⁻ (a : α), f a ∂μ
2 goals	α : Type u_1,	m : measurable_space α,	μ : measure α,	r : ennreal,	f : α → ennreal,	hr : r ≠ ⊤,	h : r = 0	⊢ ∫⁻ (a : α), r * f a ∂μ = r * ∫⁻ (a : α), f a ∂μ		α : Type u_1,	m : measurable_space α,	μ : measure α,	r : ennreal,	f : α → ennreal,	hr : r ≠ ⊤,	h : ¬r = 0	⊢ ∫⁻ (a : α), r * f a ∂μ = r * ∫⁻ (a : α), f a ∂μ
α : Type u_1,	m : measurable_space α,	μ : measure α,	r : ennreal,	f : α → ennreal,	hr : r ≠ ⊤,	h : ¬r = 0	⊢ ∫⁻ (a : α), r * f a ∂μ = r * ∫⁻ (a : α), f a ∂μ
α : Type u_1,	m : measurable_space α,	μ : measure α,	r : ennreal,	f : α → ennreal,	hr : r ≠ ⊤,	h : ¬r = 0	⊢ ∫⁻ (a : α), r * f a ∂μ ≤ r * ∫⁻ (a : α), f a ∂μ
α : Type u_1,	m : measurable_space α,	μ : measure α,	r : ennreal,	f : α → ennreal,	hr : r ≠ ⊤,	h : ¬r = 0,	rinv : r * r⁻¹ = 1	⊢ ∫⁻ (a : α), r * f a ∂μ ≤ r * ∫⁻ (a : α), f a ∂μ
2 goals	α : Type u_1,	m : measurable_space α,	μ : measure α,	r : ennreal,	f : α → ennreal,	hr : r ≠ ⊤,	h : ¬r = 0,	rinv : r * r⁻¹ = 1	⊢ r⁻¹ * r = 1		α : Type u_1,	m : measurable_space α,	μ : measure α,	r : ennreal,	f : α → ennreal,	hr : r ≠ ⊤,	h : ¬r = 0,	rinv : r * r⁻¹ = 1,	rinv' : r⁻¹ * r = 1	⊢ ∫⁻ (a : α), r * f a ∂μ ≤ r * ∫⁻ (a : α), f a ∂μ
2 goals	α : Type u_1,	m : measurable_space α,	μ : measure α,	r : ennreal,	f : α → ennreal,	hr : r ≠ ⊤,	h : ¬r = 0,	rinv : r * r⁻¹ = 1	⊢ r * r⁻¹ = 1		α : Type u_1,	m : measurable_space α,	μ : measure α,	r : ennreal,	f : α → ennreal,	hr : r ≠ ⊤,	h : ¬r = 0,	rinv : r * r⁻¹ = 1,	rinv' : r⁻¹ * r = 1	⊢ ∫⁻ (a : α), r * f a ∂μ ≤ r * ∫⁻ (a : α), f a ∂μ
α : Type u_1,	m : measurable_space α,	μ : measure α,	r : ennreal,	f : α → ennreal,	hr : r ≠ ⊤,	h : ¬r = 0,	rinv : r * r⁻¹ = 1,	rinv' : r⁻¹ * r = 1	⊢ ∫⁻ (a : α), r * f a ∂μ ≤ r * ∫⁻ (a : α), f a ∂μ
3 goals	α : Type u_1,	m : measurable_space α,	μ : measure α,	r : ennreal,	f : α → ennreal,	hr : r ≠ ⊤,	h : ¬r = 0,	rinv : r * r⁻¹ = 1,	rinv' : r⁻¹ * r = 1,	this :	  r⁻¹ * ∫⁻ (a : α), (λ (x : α), r * f x) a ∂?m_2 ≤	    ∫⁻ (a : α), r⁻¹ * (λ (x : α), r * f x) a ∂?m_2	⊢ ∫⁻ (a : α), r * f a ∂μ ≤ r * ∫⁻ (a : α), f a ∂μ		α : Type u_1,	m : measurable_space α,	μ : measure α,	r : ennreal,	f : α → ennreal,	hr : r ≠ ⊤,	h : ¬r = 0,	rinv : r * r⁻¹ = 1,	rinv' : r⁻¹ * r = 1	⊢ measurable_space α		α : Type u_1,	m : measurable_space α,	μ : measure α,	r : ennreal,	f : α → ennreal,	hr : r ≠ ⊤,	h : ¬r = 0,	rinv : r * r⁻¹ = 1,	rinv' : r⁻¹ * r = 1	⊢ measure α
3 goals	α : Type u_1,	m : measurable_space α,	μ : measure α,	r : ennreal,	f : α → ennreal,	hr : r ≠ ⊤,	h : ¬r = 0,	rinv : r * r⁻¹ = 1,	rinv' : r⁻¹ * r = 1,	this : r⁻¹ * ∫⁻ (a : α), r * f a ∂?m_2 ≤ lintegral ?m_2 f	⊢ ∫⁻ (a : α), r * f a ∂μ ≤ r * ∫⁻ (a : α), f a ∂μ		α : Type u_1,	m : measurable_space α,	μ : measure α,	r : ennreal,	f : α → ennreal,	hr : r ≠ ⊤,	h : ¬r = 0,	rinv : r * r⁻¹ = 1,	rinv' : r⁻¹ * r = 1	⊢ measurable_space α		α : Type u_1,	m : measurable_space α,	μ : measure α,	r : ennreal,	f : α → ennreal,	hr : r ≠ ⊤,	h : ¬r = 0,	rinv : r * r⁻¹ = 1,	rinv' : r⁻¹ * r = 1	⊢ measure α
⊢ ∀ {α : Type u_1} {m : measurable_space α} {μ : measure α} {β : Type u_2} [_inst_1 : measurable_space β]	  {ν : measure β} {f : α → ennreal} {g : β → ennreal},	    ae_measurable f μ →	    ae_measurable g ν →	    ∫⁻ (x : α), ∫⁻ (y : β), f x * g y ∂ν ∂μ = ∫⁻ (x : α), f x ∂μ * ∫⁻ (y : β), g y ∂ν
α : Type u_1,	m : measurable_space α,	μ : measure α,	β : Type u_2,	_inst_1 : measurable_space β,	ν : measure β,	f : α → ennreal,	g : β → ennreal,	hf : ae_measurable f μ,	hg : ae_measurable g ν	⊢ ∫⁻ (x : α), ∫⁻ (y : β), f x * g y ∂ν ∂μ = ∫⁻ (x : α), f x ∂μ * ∫⁻ (y : β), g y ∂ν
⊢ ∀ {α : Type u_1} {β : Type u_2} [_inst_1 : measurable_space α] [_inst_2 : has_zero β] (f : simple_func α β)	  {s : set α}, measurable_set s → ∀ {t : set β}, 0 ∉ t → ⇑(f.restrict s) ⁻¹' t = s ∩ ⇑f ⁻¹' t
α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : has_zero β,	f : simple_func α β,	s : set α,	hs : measurable_set s,	t : set β,	ht : 0 ∉ t	⊢ ⇑(f.restrict s) ⁻¹' t = s ∩ ⇑f ⁻¹' t
⊢ ∀ {α : Type u_1} {β : Type u_2} [_inst_1 : measurable_space β] [_inst_3 : measurable_space α]	  [_inst_4 : is_empty β] (f : α → β), measurable f
α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space β,	_inst_3 : measurable_space α,	_inst_4 : is_empty β,	f : α → β	⊢ measurable f
α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space β,	_inst_3 : measurable_space α,	_inst_4 : is_empty β,	f : α → β,	_inst : is_empty α	⊢ measurable f
⊢ ∀ {G : Type u_1} [_inst_1 : group G] [_inst_2 : topological_space G] [_inst_3 : topological_group G]	  (K₀ : positive_compacts G) {U : set G},	    (interior U).nonempty →	    ∀ {K : set G} (h1K : is_compact K), (interior K).nonempty → 0 < measure.haar.prehaar K₀.val U ⟨K, h1K⟩
G : Type u_1,	_inst_1 : group G,	_inst_2 : topological_space G,	_inst_3 : topological_group G,	K₀ : positive_compacts G,	U : set G,	hU : (interior U).nonempty,	K : set G,	h1K : is_compact K,	h2K : (interior K).nonempty	⊢ 0 < measure.haar.prehaar K₀.val U ⟨K, h1K⟩
2 goals	G : Type u_1,	_inst_1 : group G,	_inst_2 : topological_space G,	_inst_3 : topological_group G,	K₀ : positive_compacts G,	U : set G,	hU : (interior U).nonempty,	K : set G,	h1K : is_compact K,	h2K : (interior K).nonempty	⊢ 0 < ↑(measure.haar.index ⟨K, h1K⟩.val U)		G : Type u_1,	_inst_1 : group G,	_inst_2 : topological_space G,	_inst_3 : topological_group G,	K₀ : positive_compacts G,	U : set G,	hU : (interior U).nonempty,	K : set G,	h1K : is_compact K,	h2K : (interior K).nonempty	⊢ 0 < ↑(measure.haar.index K₀.val U)
2 goals	G : Type u_1,	_inst_1 : group G,	_inst_2 : topological_space G,	_inst_3 : topological_group G,	K₀ : positive_compacts G,	U : set G,	hU : (interior U).nonempty,	K : set G,	h1K : is_compact K,	h2K : (interior K).nonempty	⊢ 0 < measure.haar.index ⟨K, h1K⟩.val U		G : Type u_1,	_inst_1 : group G,	_inst_2 : topological_space G,	_inst_3 : topological_group G,	K₀ : positive_compacts G,	U : set G,	hU : (interior U).nonempty,	K : set G,	h1K : is_compact K,	h2K : (interior K).nonempty	⊢ 0 < ↑(measure.haar.index K₀.val U)
G : Type u_1,	_inst_1 : group G,	_inst_2 : topological_space G,	_inst_3 : topological_group G,	K₀ : positive_compacts G,	U : set G,	hU : (interior U).nonempty,	K : set G,	h1K : is_compact K,	h2K : (interior K).nonempty	⊢ 0 < ↑(measure.haar.index K₀.val U)
G : Type u_1,	_inst_1 : group G,	_inst_2 : topological_space G,	_inst_3 : topological_group G,	K₀ : positive_compacts G,	U : set G,	hU : (interior U).nonempty,	K : set G,	h1K : is_compact K,	h2K : (interior K).nonempty	⊢ 0 < measure.haar.index K₀.val U
⊢ ∀ {G : Type u_1} [_inst_1 : group G] [_inst_2 : topological_space G] [_inst_3 : topological_group G]	  {K₀ : positive_compacts G} (g : G) (K : compacts G),	    measure.haar.chaar K₀ (compacts.map (λ (b : G), g * b) _ K) = measure.haar.chaar K₀ K
G : Type u_1,	_inst_1 : group G,	_inst_2 : topological_space G,	_inst_3 : topological_group G,	K₀ : positive_compacts G,	g : G,	K : compacts G	⊢ measure.haar.chaar K₀ (compacts.map (λ (b : G), g * b) _ K) = measure.haar.chaar K₀ K
G : Type u_1,	_inst_1 : group G,	_inst_2 : topological_space G,	_inst_3 : topological_group G,	K₀ : positive_compacts G,	g : G,	K : compacts G,	eval : (compacts G → ℝ) → ℝ := λ (f : compacts G → ℝ), f (compacts.map (λ (b : G), g * b) _ K) - f K	⊢ measure.haar.chaar K₀ (compacts.map (λ (b : G), g * b) _ K) = measure.haar.chaar K₀ K
G : Type u_1,	_inst_1 : group G,	_inst_2 : topological_space G,	_inst_3 : topological_group G,	K₀ : positive_compacts G,	g : G,	K : compacts G,	eval : (compacts G → ℝ) → ℝ := λ (f : compacts G → ℝ), f (compacts.map (λ (b : G), g * b) _ K) - f K,	this : continuous eval	⊢ measure.haar.chaar K₀ (compacts.map (λ (b : G), g * b) _ K) = measure.haar.chaar K₀ K
G : Type u_1,	_inst_1 : group G,	_inst_2 : topological_space G,	_inst_3 : topological_group G,	K₀ : positive_compacts G,	g : G,	K : compacts G,	eval : (compacts G → ℝ) → ℝ := λ (f : compacts G → ℝ), f (compacts.map (λ (b : G), g * b) _ K) - f K,	this : continuous eval	⊢ measure.haar.chaar K₀ (compacts.map (λ (b : G), g * b) _ K) - measure.haar.chaar K₀ K = 0
G : Type u_1,	_inst_1 : group G,	_inst_2 : topological_space G,	_inst_3 : topological_group G,	K₀ : positive_compacts G,	g : G,	K : compacts G,	eval : (compacts G → ℝ) → ℝ := λ (f : compacts G → ℝ), f (compacts.map (λ (b : G), g * b) _ K) - f K,	this : continuous eval	⊢ measure.haar.chaar K₀ ∈ eval ⁻¹' {0}
G : Type u_1,	_inst_1 : group G,	_inst_2 : topological_space G,	_inst_3 : topological_group G,	K₀ : positive_compacts G,	g : G,	K : compacts G,	eval : (compacts G → ℝ) → ℝ := λ (f : compacts G → ℝ), f (compacts.map (λ (b : G), g * b) _ K) - f K,	this : continuous eval	⊢ measure.haar.cl_prehaar K₀.val ⟨univ G, _⟩ ⊆ eval ⁻¹' {0}
G : Type u_1,	_inst_1 : group G,	_inst_2 : topological_space G,	_inst_3 : topological_group G,	K₀ : positive_compacts G,	g : G,	K : compacts G,	eval : (compacts G → ℝ) → ℝ := λ (f : compacts G → ℝ), f (compacts.map (λ (b : G), g * b) _ K) - f K,	this : continuous eval	⊢ closure (measure.haar.prehaar K₀.val '' {U : set G | U ⊆ ⟨univ G, _⟩.val ∧ is_open U ∧ 1 ∈ U}) ⊆	    eval ⁻¹' {0}
2 goals	G : Type u_1,	_inst_1 : group G,	_inst_2 : topological_space G,	_inst_3 : topological_group G,	K₀ : positive_compacts G,	g : G,	K : compacts G,	eval : (compacts G → ℝ) → ℝ := λ (f : compacts G → ℝ), f (compacts.map (λ (b : G), g * b) _ K) - f K,	this : continuous eval	⊢ measure.haar.prehaar K₀.val '' {U : set G | U ⊆ ⟨univ G, _⟩.val ∧ is_open U ∧ 1 ∈ U} ⊆	    eval ⁻¹' {0}		G : Type u_1,	_inst_1 : group G,	_inst_2 : topological_space G,	_inst_3 : topological_group G,	K₀ : positive_compacts G,	g : G,	K : compacts G,	eval : (compacts G → ℝ) → ℝ := λ (f : compacts G → ℝ), f (compacts.map (λ (b : G), g * b) _ K) - f K,	this : continuous eval	⊢ is_closed (eval ⁻¹' {0})
2 goals	G : Type u_1,	_inst_1 : group G,	_inst_2 : topological_space G,	_inst_3 : topological_group G,	K₀ : positive_compacts G,	g : G,	K : compacts G,	eval : (compacts G → ℝ) → ℝ := λ (f : compacts G → ℝ), f (compacts.map (λ (b : G), g * b) _ K) - f K,	this : continuous eval,	U : set G,	h1U : U ⊆ ⟨univ G, _⟩.val,	h2U : is_open U,	h3U : 1 ∈ U	⊢ measure.haar.prehaar K₀.val U ∈ eval ⁻¹' {0}		G : Type u_1,	_inst_1 : group G,	_inst_2 : topological_space G,	_inst_3 : topological_group G,	K₀ : positive_compacts G,	g : G,	K : compacts G,	eval : (compacts G → ℝ) → ℝ := λ (f : compacts G → ℝ), f (compacts.map (λ (b : G), g * b) _ K) - f K,	this : continuous eval	⊢ is_closed (eval ⁻¹' {0})
2 goals	G : Type u_1,	_inst_1 : group G,	_inst_2 : topological_space G,	_inst_3 : topological_group G,	K₀ : positive_compacts G,	g : G,	K : compacts G,	eval : (compacts G → ℝ) → ℝ := λ (f : compacts G → ℝ), f (compacts.map (λ (b : G), g * b) _ K) - f K,	this : continuous eval,	U : set G,	h1U : U ⊆ ⟨univ G, _⟩.val,	h2U : is_open U,	h3U : 1 ∈ U	⊢ measure.haar.prehaar K₀.val U (compacts.map (has_mul.mul g) _ K) = measure.haar.prehaar K₀.val U K		G : Type u_1,	_inst_1 : group G,	_inst_2 : topological_space G,	_inst_3 : topological_group G,	K₀ : positive_compacts G,	g : G,	K : compacts G,	eval : (compacts G → ℝ) → ℝ := λ (f : compacts G → ℝ), f (compacts.map (λ (b : G), g * b) _ K) - f K,	this : continuous eval	⊢ is_closed (eval ⁻¹' {0})
2 goals	G : Type u_1,	_inst_1 : group G,	_inst_2 : topological_space G,	_inst_3 : topological_group G,	K₀ : positive_compacts G,	g : G,	K : compacts G,	eval : (compacts G → ℝ) → ℝ := λ (f : compacts G → ℝ), f (compacts.map (λ (b : G), g * b) _ K) - f K,	this : continuous eval,	U : set G,	h1U : U ⊆ ⟨univ G, _⟩.val,	h2U : is_open U,	h3U : 1 ∈ U	⊢ (interior U).nonempty		G : Type u_1,	_inst_1 : group G,	_inst_2 : topological_space G,	_inst_3 : topological_group G,	K₀ : positive_compacts G,	g : G,	K : compacts G,	eval : (compacts G → ℝ) → ℝ := λ (f : compacts G → ℝ), f (compacts.map (λ (b : G), g * b) _ K) - f K,	this : continuous eval	⊢ is_closed (eval ⁻¹' {0})
2 goals	G : Type u_1,	_inst_1 : group G,	_inst_2 : topological_space G,	_inst_3 : topological_group G,	K₀ : positive_compacts G,	g : G,	K : compacts G,	eval : (compacts G → ℝ) → ℝ := λ (f : compacts G → ℝ), f (compacts.map (λ (b : G), g * b) _ K) - f K,	this : continuous eval,	U : set G,	h1U : U ⊆ ⟨univ G, _⟩.val,	h2U : is_open U,	h3U : 1 ∈ U	⊢ U.nonempty		G : Type u_1,	_inst_1 : group G,	_inst_2 : topological_space G,	_inst_3 : topological_group G,	K₀ : positive_compacts G,	g : G,	K : compacts G,	eval : (compacts G → ℝ) → ℝ := λ (f : compacts G → ℝ), f (compacts.map (λ (b : G), g * b) _ K) - f K,	this : continuous eval	⊢ is_closed (eval ⁻¹' {0})
G : Type u_1,	_inst_1 : group G,	_inst_2 : topological_space G,	_inst_3 : topological_group G,	K₀ : positive_compacts G,	g : G,	K : compacts G,	eval : (compacts G → ℝ) → ℝ := λ (f : compacts G → ℝ), f (compacts.map (λ (b : G), g * b) _ K) - f K,	this : continuous eval	⊢ is_closed (eval ⁻¹' {0})
G : Type u_1,	_inst_1 : group G,	_inst_2 : topological_space G,	_inst_3 : topological_group G,	K₀ : positive_compacts G,	g : G,	K : compacts G,	eval : (compacts G → ℝ) → ℝ := λ (f : compacts G → ℝ), f (compacts.map (λ (b : G), g * b) _ K) - f K,	this : continuous eval	⊢ is_closed {0}
⊢ ∀ {X : Type u_2} {Y : Type u_3} [_inst_1 : emetric_space X] [_inst_2 : emetric_space Y]	  [_inst_3 : measurable_space X] [_inst_4 : borel_space X] [_inst_5 : measurable_space Y] [_inst_6 : borel_space Y]	  {f : X → Y} {d : ℝ},	    isometry f →	    0 ≤ d ∨ surjective f →	    ∀ (s : set Y), ⇑(measure.hausdorff_measure d) (f ⁻¹' s) = ⇑(measure.hausdorff_measure d) (s ∩ range f)
X : Type u_2,	Y : Type u_3,	_inst_1 : emetric_space X,	_inst_2 : emetric_space Y,	_inst_3 : measurable_space X,	_inst_4 : borel_space X,	_inst_5 : measurable_space Y,	_inst_6 : borel_space Y,	f : X → Y,	d : ℝ,	hf : isometry f,	hd : 0 ≤ d ∨ surjective f,	s : set Y	⊢ ⇑(measure.hausdorff_measure d) (f ⁻¹' s) = ⇑(measure.hausdorff_measure d) (s ∩ range f)
⊢ ∀ {α : Type u_1} {m0 : measurable_space α} {μ : measure α} {s : set α},	    measurable_set s → (μ.restrict s).ae = μ.ae ⊓ principal s
α : Type u_1,	m0 : measurable_space α,	μ : measure α,	s : set α,	hs : measurable_set s	⊢ (μ.restrict s).ae = μ.ae ⊓ principal s
α : Type u_1,	m0 : measurable_space α,	μ : measure α,	s : set α,	hs : measurable_set s,	t : set α	⊢ t ∈ (μ.restrict s).ae ↔ t ∈ μ.ae ⊓ principal s
α : Type u_1,	m0 : measurable_space α,	μ : measure α,	s : set α,	hs : measurable_set s,	t : set α	⊢ ⇑μ (tᶜ ∩ s) = 0 ↔ ⇑μ {a : α | a ∉ t ∧ a ∈ s} = 0
⊢ ∀ {α : Type u_1} {m0 : measurable_space α} {μ : measure α} {s : set α},	    measurable_set s → s ∈ (μ.restrict s).ae
α : Type u_1,	m0 : measurable_space α,	μ : measure α,	s : set α,	hs : measurable_set s	⊢ s ∈ (μ.restrict s).ae
α : Type u_1,	m0 : measurable_space α,	μ : measure α,	s : set α,	hs : measurable_set s	⊢ ∃ (t₁ : set α), t₁ ∈ μ.ae ∧ ∃ (a : set α), s ⊆ a ∧ s = t₁ ∩ a
⊢ ∀ {α : Type u_1} (m₀ : measurable_space α) {μ ν : measure α} [_inst_3 : is_finite_measure μ]	  (C : set (set α)),	    (∀ (s : set α), s ∈ C → ⇑μ s = ⇑ν s) →	    ∀ {m : measurable_space α},	      m ≤ m₀ →	      m = generate_from C →	      is_pi_system C → ⇑μ univ = ⇑ν univ → ∀ {s : set α}, m.measurable_set' s → ⇑μ s = ⇑ν s
α : Type u_1,	m₀ : measurable_space α,	μ ν : measure α,	_inst_3 : is_finite_measure μ,	C : set (set α),	hμν : ∀ (s : set α), s ∈ C → ⇑μ s = ⇑ν s,	m : measurable_space α,	h : m ≤ m₀,	hA : m = generate_from C,	hC : is_pi_system C,	h_univ : ⇑μ univ = ⇑ν univ,	s : set α,	hs : m.measurable_set' s	⊢ ⇑μ s = ⇑ν s
α : Type u_1,	m₀ : measurable_space α,	μ ν : measure α,	_inst_3 : is_finite_measure μ,	C : set (set α),	hμν : ∀ (s : set α), s ∈ C → ⇑μ s = ⇑ν s,	m : measurable_space α,	h : m ≤ m₀,	hA : m = generate_from C,	hC : is_pi_system C,	h_univ : ⇑μ univ = ⇑ν univ,	s : set α,	hs : m.measurable_set' s,	_inst : is_finite_measure ν	⊢ ⇑μ s = ⇑ν s
2 goals	α : Type u_1,	m₀ : measurable_space α,	μ ν : measure α,	_inst_3 : is_finite_measure μ,	C : set (set α),	hμν : ∀ (s : set α), s ∈ C → ⇑μ s = ⇑ν s,	m : measurable_space α,	h : m ≤ m₀,	hA : m = generate_from C,	hC : is_pi_system C,	h_univ : ⇑μ univ = ⇑ν univ,	s : set α,	hs : m.measurable_set' s,	_inst : is_finite_measure ν	⊢ ∀ (t : set α), measurable_set t → ⇑μ t = ⇑ν t → ⇑μ tᶜ = ⇑ν tᶜ		α : Type u_1,	m₀ : measurable_space α,	μ ν : measure α,	_inst_3 : is_finite_measure μ,	C : set (set α),	hμν : ∀ (s : set α), s ∈ C → ⇑μ s = ⇑ν s,	m : measurable_space α,	h : m ≤ m₀,	hA : m = generate_from C,	hC : is_pi_system C,	h_univ : ⇑μ univ = ⇑ν univ,	s : set α,	hs : m.measurable_set' s,	_inst : is_finite_measure ν	⊢ ∀ (f : ℕ → set α),	    pairwise (disjoint on f) →	    (∀ (i : ℕ), measurable_set (f i)) →	    (∀ (i : ℕ), ⇑μ (f i) = ⇑ν (f i)) → ⇑μ (⋃ (i : ℕ), f i) = ⇑ν (⋃ (i : ℕ), f i)
2 goals	α : Type u_1,	m₀ : measurable_space α,	μ ν : measure α,	_inst_3 : is_finite_measure μ,	C : set (set α),	hμν : ∀ (s : set α), s ∈ C → ⇑μ s = ⇑ν s,	m : measurable_space α,	h : m ≤ m₀,	hA : m = generate_from C,	hC : is_pi_system C,	h_univ : ⇑μ univ = ⇑ν univ,	s : set α,	hs : m.measurable_set' s,	_inst : is_finite_measure ν,	t : set α,	h1t : measurable_set t,	h2t : ⇑μ t = ⇑ν t	⊢ ⇑μ tᶜ = ⇑ν tᶜ		α : Type u_1,	m₀ : measurable_space α,	μ ν : measure α,	_inst_3 : is_finite_measure μ,	C : set (set α),	hμν : ∀ (s : set α), s ∈ C → ⇑μ s = ⇑ν s,	m : measurable_space α,	h : m ≤ m₀,	hA : m = generate_from C,	hC : is_pi_system C,	h_univ : ⇑μ univ = ⇑ν univ,	s : set α,	hs : m.measurable_set' s,	_inst : is_finite_measure ν	⊢ ∀ (f : ℕ → set α),	    pairwise (disjoint on f) →	    (∀ (i : ℕ), measurable_set (f i)) →	    (∀ (i : ℕ), ⇑μ (f i) = ⇑ν (f i)) → ⇑μ (⋃ (i : ℕ), f i) = ⇑ν (⋃ (i : ℕ), f i)
3 goals	α : Type u_1,	m₀ : measurable_space α,	μ ν : measure α,	_inst_3 : is_finite_measure μ,	C : set (set α),	hμν : ∀ (s : set α), s ∈ C → ⇑μ s = ⇑ν s,	m : measurable_space α,	h : m ≤ m₀,	hA : m = generate_from C,	hC : is_pi_system C,	h_univ : ⇑μ univ = ⇑ν univ,	s : set α,	hs : m.measurable_set' s,	_inst : is_finite_measure ν,	t : set α,	h1t : measurable_set t,	h2t : ⇑μ t = ⇑ν t	⊢ measurable_set t		α : Type u_1,	m₀ : measurable_space α,	μ ν : measure α,	_inst_3 : is_finite_measure μ,	C : set (set α),	hμν : ∀ (s : set α), s ∈ C → ⇑μ s = ⇑ν s,	m : measurable_space α,	h : m ≤ m₀,	hA : m = generate_from C,	hC : is_pi_system C,	h_univ : ⇑μ univ = ⇑ν univ,	s : set α,	hs : m.measurable_set' s,	_inst : is_finite_measure ν,	t : set α,	h1t : measurable_set t,	h2t : ⇑μ t = ⇑ν t,	h1t_ : measurable_set t	⊢ ⇑μ tᶜ = ⇑ν tᶜ		α : Type u_1,	m₀ : measurable_space α,	μ ν : measure α,	_inst_3 : is_finite_measure μ,	C : set (set α),	hμν : ∀ (s : set α), s ∈ C → ⇑μ s = ⇑ν s,	m : measurable_space α,	h : m ≤ m₀,	hA : m = generate_from C,	hC : is_pi_system C,	h_univ : ⇑μ univ = ⇑ν univ,	s : set α,	hs : m.measurable_set' s,	_inst : is_finite_measure ν	⊢ ∀ (f : ℕ → set α),	    pairwise (disjoint on f) →	    (∀ (i : ℕ), measurable_set (f i)) →	    (∀ (i : ℕ), ⇑μ (f i) = ⇑ν (f i)) → ⇑μ (⋃ (i : ℕ), f i) = ⇑ν (⋃ (i : ℕ), f i)
2 goals	α : Type u_1,	m₀ : measurable_space α,	μ ν : measure α,	_inst_3 : is_finite_measure μ,	C : set (set α),	hμν : ∀ (s : set α), s ∈ C → ⇑μ s = ⇑ν s,	m : measurable_space α,	h : m ≤ m₀,	hA : m = generate_from C,	hC : is_pi_system C,	h_univ : ⇑μ univ = ⇑ν univ,	s : set α,	hs : m.measurable_set' s,	_inst : is_finite_measure ν,	t : set α,	h1t : measurable_set t,	h2t : ⇑μ t = ⇑ν t,	h1t_ : measurable_set t	⊢ ⇑μ tᶜ = ⇑ν tᶜ		α : Type u_1,	m₀ : measurable_space α,	μ ν : measure α,	_inst_3 : is_finite_measure μ,	C : set (set α),	hμν : ∀ (s : set α), s ∈ C → ⇑μ s = ⇑ν s,	m : measurable_space α,	h : m ≤ m₀,	hA : m = generate_from C,	hC : is_pi_system C,	h_univ : ⇑μ univ = ⇑ν univ,	s : set α,	hs : m.measurable_set' s,	_inst : is_finite_measure ν	⊢ ∀ (f : ℕ → set α),	    pairwise (disjoint on f) →	    (∀ (i : ℕ), measurable_set (f i)) →	    (∀ (i : ℕ), ⇑μ (f i) = ⇑ν (f i)) → ⇑μ (⋃ (i : ℕ), f i) = ⇑ν (⋃ (i : ℕ), f i)
α : Type u_1,	m₀ : measurable_space α,	μ ν : measure α,	_inst_3 : is_finite_measure μ,	C : set (set α),	hμν : ∀ (s : set α), s ∈ C → ⇑μ s = ⇑ν s,	m : measurable_space α,	h : m ≤ m₀,	hA : m = generate_from C,	hC : is_pi_system C,	h_univ : ⇑μ univ = ⇑ν univ,	s : set α,	hs : m.measurable_set' s,	_inst : is_finite_measure ν	⊢ ∀ (f : ℕ → set α),	    pairwise (disjoint on f) →	    (∀ (i : ℕ), measurable_set (f i)) →	    (∀ (i : ℕ), ⇑μ (f i) = ⇑ν (f i)) → ⇑μ (⋃ (i : ℕ), f i) = ⇑ν (⋃ (i : ℕ), f i)
α : Type u_1,	m₀ : measurable_space α,	μ ν : measure α,	_inst_3 : is_finite_measure μ,	C : set (set α),	hμν : ∀ (s : set α), s ∈ C → ⇑μ s = ⇑ν s,	m : measurable_space α,	h : m ≤ m₀,	hA : m = generate_from C,	hC : is_pi_system C,	h_univ : ⇑μ univ = ⇑ν univ,	s : set α,	hs : m.measurable_set' s,	_inst : is_finite_measure ν,	f : ℕ → set α,	h1f : pairwise (disjoint on f),	h2f : ∀ (i : ℕ), measurable_set (f i),	h3f : ∀ (i : ℕ), ⇑μ (f i) = ⇑ν (f i)	⊢ ⇑μ (⋃ (i : ℕ), f i) = ⇑ν (⋃ (i : ℕ), f i)
2 goals	α : Type u_1,	m₀ : measurable_space α,	μ ν : measure α,	_inst_3 : is_finite_measure μ,	C : set (set α),	hμν : ∀ (s : set α), s ∈ C → ⇑μ s = ⇑ν s,	m : measurable_space α,	h : m ≤ m₀,	hA : m = generate_from C,	hC : is_pi_system C,	h_univ : ⇑μ univ = ⇑ν univ,	s : set α,	hs : m.measurable_set' s,	_inst : is_finite_measure ν,	f : ℕ → set α,	h1f : pairwise (disjoint on f),	h2f : ∀ (i : ℕ), measurable_set (f i),	h3f : ∀ (i : ℕ), ⇑μ (f i) = ⇑ν (f i)	⊢ ∀ (i : ℕ), measurable_set (f i)		α : Type u_1,	m₀ : measurable_space α,	μ ν : measure α,	_inst_3 : is_finite_measure μ,	C : set (set α),	hμν : ∀ (s : set α), s ∈ C → ⇑μ s = ⇑ν s,	m : measurable_space α,	h : m ≤ m₀,	hA : m = generate_from C,	hC : is_pi_system C,	h_univ : ⇑μ univ = ⇑ν univ,	s : set α,	hs : m.measurable_set' s,	_inst : is_finite_measure ν,	f : ℕ → set α,	h1f : pairwise (disjoint on f),	h2f : ∀ (i : ℕ), measurable_set (f i),	h3f : ∀ (i : ℕ), ⇑μ (f i) = ⇑ν (f i),	h2f_ : ∀ (i : ℕ), measurable_set (f i)	⊢ ⇑μ (⋃ (i : ℕ), f i) = ⇑ν (⋃ (i : ℕ), f i)
α : Type u_1,	m₀ : measurable_space α,	μ ν : measure α,	_inst_3 : is_finite_measure μ,	C : set (set α),	hμν : ∀ (s : set α), s ∈ C → ⇑μ s = ⇑ν s,	m : measurable_space α,	h : m ≤ m₀,	hA : m = generate_from C,	hC : is_pi_system C,	h_univ : ⇑μ univ = ⇑ν univ,	s : set α,	hs : m.measurable_set' s,	_inst : is_finite_measure ν,	f : ℕ → set α,	h1f : pairwise (disjoint on f),	h2f : ∀ (i : ℕ), measurable_set (f i),	h3f : ∀ (i : ℕ), ⇑μ (f i) = ⇑ν (f i),	h2f_ : ∀ (i : ℕ), measurable_set (f i)	⊢ ⇑μ (⋃ (i : ℕ), f i) = ⇑ν (⋃ (i : ℕ), f i)
2 goals	α : Type u_1,	m₀ : measurable_space α,	μ ν : measure α,	_inst_3 : is_finite_measure μ,	C : set (set α),	hμν : ∀ (s : set α), s ∈ C → ⇑μ s = ⇑ν s,	m : measurable_space α,	h : m ≤ m₀,	hA : m = generate_from C,	hC : is_pi_system C,	h_univ : ⇑μ univ = ⇑ν univ,	s : set α,	hs : m.measurable_set' s,	_inst : is_finite_measure ν,	f : ℕ → set α,	h1f : pairwise (disjoint on f),	h2f : ∀ (i : ℕ), measurable_set (f i),	h3f : ∀ (i : ℕ), ⇑μ (f i) = ⇑ν (f i),	h2f_ : ∀ (i : ℕ), measurable_set (f i)	⊢ measurable_set (⋃ (i : ℕ), f i)		α : Type u_1,	m₀ : measurable_space α,	μ ν : measure α,	_inst_3 : is_finite_measure μ,	C : set (set α),	hμν : ∀ (s : set α), s ∈ C → ⇑μ s = ⇑ν s,	m : measurable_space α,	h : m ≤ m₀,	hA : m = generate_from C,	hC : is_pi_system C,	h_univ : ⇑μ univ = ⇑ν univ,	s : set α,	hs : m.measurable_set' s,	_inst : is_finite_measure ν,	f : ℕ → set α,	h1f : pairwise (disjoint on f),	h2f : ∀ (i : ℕ), measurable_set (f i),	h3f : ∀ (i : ℕ), ⇑μ (f i) = ⇑ν (f i),	h2f_ : ∀ (i : ℕ), measurable_set (f i),	h_Union : measurable_set (⋃ (i : ℕ), f i)	⊢ ⇑μ (⋃ (i : ℕ), f i) = ⇑ν (⋃ (i : ℕ), f i)
α : Type u_1,	m₀ : measurable_space α,	μ ν : measure α,	_inst_3 : is_finite_measure μ,	C : set (set α),	hμν : ∀ (s : set α), s ∈ C → ⇑μ s = ⇑ν s,	m : measurable_space α,	h : m ≤ m₀,	hA : m = generate_from C,	hC : is_pi_system C,	h_univ : ⇑μ univ = ⇑ν univ,	s : set α,	hs : m.measurable_set' s,	_inst : is_finite_measure ν,	f : ℕ → set α,	h1f : pairwise (disjoint on f),	h2f : ∀ (i : ℕ), measurable_set (f i),	h3f : ∀ (i : ℕ), ⇑μ (f i) = ⇑ν (f i),	h2f_ : ∀ (i : ℕ), measurable_set (f i),	h_Union : measurable_set (⋃ (i : ℕ), f i)	⊢ ⇑μ (⋃ (i : ℕ), f i) = ⇑ν (⋃ (i : ℕ), f i)
⊢ ∀ {α : Type u_1} {m0 : measurable_space α} {μ : measure α} {f : filter α},	    μ.finite_at_filter (f ⊓ μ.ae) ↔ μ.finite_at_filter f
α : Type u_1,	m0 : measurable_space α,	μ : measure α,	f : filter α	⊢ μ.finite_at_filter (f ⊓ μ.ae) ↔ μ.finite_at_filter f
α : Type u_1,	m0 : measurable_space α,	μ : measure α,	f : filter α	⊢ μ.finite_at_filter (f ⊓ μ.ae) → μ.finite_at_filter f
α : Type u_1,	m0 : measurable_space α,	μ : measure α,	f : filter α,	t : set α,	ht : t ∈ f,	u : set α,	hu : u ∈ μ.ae,	hμ : ⇑μ (t ∩ u) < ⊤	⊢ μ.finite_at_filter f
2 goals	α : Type u_1,	m0 : measurable_space α,	μ : measure α,	f : filter α,	t : set α,	ht : t ∈ f,	u : set α,	hu : u ∈ μ.ae,	hμ : ⇑μ (t ∩ u) < ⊤,	this : ⇑μ t ≤ ⇑μ (t ∩ u)	⊢ μ.finite_at_filter f		α : Type u_1,	m0 : measurable_space α,	μ : measure α,	f : filter α,	t : set α,	ht : t ∈ f,	u : set α,	hu : u ∈ μ.ae,	hμ : ⇑μ (t ∩ u) < ⊤	⊢ ⇑μ t ≤ ⇑μ (t ∩ u)
α : Type u_1,	m0 : measurable_space α,	μ : measure α,	f : filter α,	t : set α,	ht : t ∈ f,	u : set α,	hu : u ∈ μ.ae,	hμ : ⇑μ (t ∩ u) < ⊤	⊢ ⇑μ t ≤ ⇑μ (t ∩ u)
⊢ ∀ {α : Type u_1} [_inst_1 : measurable_space α] {μ : measure α} {s : set α},	    measurable_set s → ⇑μ s = extend (λ (t : set α) (ht : measurable_set t), ⇑μ t) s
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure α,	s : set α,	hs : measurable_set s	⊢ ⇑μ s = extend (λ (t : set α) (ht : measurable_set t), ⇑μ t) s
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure α,	s : set α,	hs : measurable_set s	⊢ ∀ ⦃f : ℕ → set α⦄,	    (∀ (i : ℕ), measurable_set (f i)) →	    pairwise (disjoint on f) → ⇑μ (⋃ (i : ℕ), f i) = ∑' (i : ℕ), ⇑μ (f i)
⊢ ∀ {α : Type u_1} [_inst_1 : measurable_space α] {μ : measure α} {s t : set α},	    s ∪ t =ᵐ[μ] t ↔ ⇑μ (s \ t) = 0
α : Type u_1,	_inst_1 : measurable_space α,	μ : measure α,	s t : set α	⊢ s ∪ t =ᵐ[μ] t ↔ ⇑μ (s \ t) = 0
⊢ ∀ (f : stieltjes_function) {x y : ℝ}, x ≤ y → f.left_lim x ≤ f.left_lim y
f : stieltjes_function,	x y : ℝ,	h : x ≤ y	⊢ f.left_lim x ≤ f.left_lim y
2 goals	f : stieltjes_function,	x : ℝ,	h : x ≤ x	⊢ f.left_lim x ≤ f.left_lim x		f : stieltjes_function,	x y : ℝ,	h : x ≤ y,	hxy : x < y	⊢ f.left_lim x ≤ f.left_lim y
f : stieltjes_function,	x y : ℝ,	h : x ≤ y,	hxy : x < y	⊢ f.left_lim x ≤ f.left_lim y
⊢ ∀ {α : Type u_1} {m : measurable_space α} {M : Type u_4} [_inst_3 : add_comm_monoid M]	  [_inst_4 : topological_space M] {N : Type u_2} [_inst_7 : add_comm_group N] [_inst_8 : topological_space N]	  [_inst_9 : topological_add_group N] {v : vector_measure α M} {w : vector_measure α N},	    v.absolutely_continuous w → v.absolutely_continuous (-w)
α : Type u_1,	m : measurable_space α,	M : Type u_4,	_inst_3 : add_comm_monoid M,	_inst_4 : topological_space M,	N : Type u_2,	_inst_7 : add_comm_group N,	_inst_8 : topological_space N,	_inst_9 : topological_add_group N,	v : vector_measure α M,	w : vector_measure α N,	h : v.absolutely_continuous w	⊢ v.absolutely_continuous (-w)
α : Type u_1,	m : measurable_space α,	M : Type u_4,	_inst_3 : add_comm_monoid M,	_inst_4 : topological_space M,	N : Type u_2,	_inst_7 : add_comm_group N,	_inst_8 : topological_space N,	_inst_9 : topological_add_group N,	v : vector_measure α M,	w : vector_measure α N,	h : v.absolutely_continuous w,	s : set α,	hs : (⇑-w) s = 0	⊢ ⇑v s = 0
α : Type u_1,	m : measurable_space α,	M : Type u_4,	_inst_3 : add_comm_monoid M,	_inst_4 : topological_space M,	N : Type u_2,	_inst_7 : add_comm_group N,	_inst_8 : topological_space N,	_inst_9 : topological_add_group N,	v : vector_measure α M,	w : vector_measure α N,	h : v.absolutely_continuous w,	s : set α,	hs : ⇑w s = 0	⊢ ⇑v s = 0
⊢ ∀ {R : Type u_1} [_inst_1 : semiring R] {f : arithmetic_function R}, f.ppow 0 = ↑arithmetic_function.zeta
R : Type u_1,	_inst_1 : semiring R,	f : arithmetic_function R	⊢ f.ppow 0 = ↑arithmetic_function.zeta
⊢ ∀ {R : Type u_1} [_inst_1 : comm_ring R], ↑arithmetic_function.zeta * ↑arithmetic_function.moebius = 1
R : Type u_1,	_inst_1 : comm_ring R	⊢ ↑arithmetic_function.zeta * ↑arithmetic_function.moebius = 1
⊢ 1.divisors_antidiagonal = {(1, 1)}
a : ℕ × ℕ	⊢ a ∈ 1.divisors_antidiagonal ↔ a ∈ {(1, 1)}
⊢ ∀ {f g : arithmetic_function ℂ} {z : ℂ},	    f.l_series_summable z → g.l_series_summable z → (f + g).l_series z = f.l_series z + g.l_series z
f g : arithmetic_function ℂ,	z : ℂ,	hf : f.l_series_summable z,	hg : g.l_series_summable z	⊢ (f + g).l_series z = f.l_series z + g.l_series z
f g : arithmetic_function ℂ,	z : ℂ,	hf : f.l_series_summable z,	hg : g.l_series_summable z	⊢ ∑' (n : ℕ), (⇑f n + ⇑g n) / ↑n ^ z = ∑' (n : ℕ), ⇑f n / ↑n ^ z + ∑' (n : ℕ), ⇑g n / ↑n ^ z
f g : arithmetic_function ℂ,	z : ℂ,	hf : f.l_series_summable z,	hg : g.l_series_summable z	⊢ ∑' (n : ℕ), (⇑f n + ⇑g n) / ↑n ^ z =	    ∑' (b : ℕ), ((λ (n : ℕ), ⇑f n / ↑n ^ z) b + (λ (n : ℕ), ⇑g n / ↑n ^ z) b)
f g : arithmetic_function ℂ,	z : ℂ,	hf : f.l_series_summable z,	hg : g.l_series_summable z,	n : ℕ	⊢ (⇑f n + ⇑g n) / ↑n ^ z = (λ (n : ℕ), ⇑f n / ↑n ^ z) n + (λ (n : ℕ), ⇑g n / ↑n ^ z) n
⊢ ∀ {f : arithmetic_function ℂ} {m : ℝ},	    (∀ (n : ℕ), complex.abs (⇑f n) ≤ m) → ∀ {z : ℝ}, 1 < z → f.l_series_summable ↑z
f : arithmetic_function ℂ,	m : ℝ,	h : ∀ (n : ℕ), complex.abs (⇑f n) ≤ m,	z : ℝ,	hz : 1 < z	⊢ f.l_series_summable ↑z
2 goals	f : arithmetic_function ℂ,	m : ℝ,	h : ∀ (n : ℕ), complex.abs (⇑f n) ≤ m,	z : ℝ,	hz : 1 < z,	h0 : m = 0	⊢ f.l_series_summable ↑z		f : arithmetic_function ℂ,	m : ℝ,	h : ∀ (n : ℕ), complex.abs (⇑f n) ≤ m,	z : ℝ,	hz : 1 < z,	h0 : ¬m = 0	⊢ f.l_series_summable ↑z
2 goals	f : arithmetic_function ℂ,	z : ℝ,	hz : 1 < z,	h : ∀ (n : ℕ), complex.abs (⇑f n) ≤ 0	⊢ f.l_series_summable ↑z		f : arithmetic_function ℂ,	m : ℝ,	h : ∀ (n : ℕ), complex.abs (⇑f n) ≤ m,	z : ℝ,	hz : 1 < z,	h0 : ¬m = 0	⊢ f.l_series_summable ↑z
2 goals	f : arithmetic_function ℂ,	z : ℝ,	hz : 1 < z,	h : ∀ (n : ℕ), complex.abs (⇑f n) ≤ 0,	hf : f = 0	⊢ f.l_series_summable ↑z		f : arithmetic_function ℂ,	m : ℝ,	h : ∀ (n : ℕ), complex.abs (⇑f n) ≤ m,	z : ℝ,	hz : 1 < z,	h0 : ¬m = 0	⊢ f.l_series_summable ↑z
f : arithmetic_function ℂ,	m : ℝ,	h : ∀ (n : ℕ), complex.abs (⇑f n) ≤ m,	z : ℝ,	hz : 1 < z,	h0 : ¬m = 0	⊢ f.l_series_summable ↑z
2 goals	f : arithmetic_function ℂ,	m : ℝ,	h : ∀ (n : ℕ), complex.abs (⇑f n) ≤ m,	z : ℝ,	hz : 1 < z,	h0 : ¬m = 0	⊢ summable (λ (n : ℕ), m / ↑n ^ z)		f : arithmetic_function ℂ,	m : ℝ,	h : ∀ (n : ℕ), complex.abs (⇑f n) ≤ m,	z : ℝ,	hz : 1 < z,	h0 : ¬m = 0	⊢ ∀ (i : ℕ), ∥⇑f i / ↑i ^ ↑z∥ ≤ m / ↑i ^ z
2 goals	f : arithmetic_function ℂ,	m : ℝ,	h : ∀ (n : ℕ), complex.abs (⇑f n) ≤ m,	z : ℝ,	hz : 1 < z,	h0 : ¬m = 0	⊢ summable (λ (n : ℕ), m * (↑n ^ z)⁻¹)		f : arithmetic_function ℂ,	m : ℝ,	h : ∀ (n : ℕ), complex.abs (⇑f n) ≤ m,	z : ℝ,	hz : 1 < z,	h0 : ¬m = 0	⊢ ∀ (i : ℕ), ∥⇑f i / ↑i ^ ↑z∥ ≤ m / ↑i ^ z
f : arithmetic_function ℂ,	m : ℝ,	h : ∀ (n : ℕ), complex.abs (⇑f n) ≤ m,	z : ℝ,	hz : 1 < z,	h0 : ¬m = 0	⊢ ∀ (i : ℕ), ∥⇑f i / ↑i ^ ↑z∥ ≤ m / ↑i ^ z
f : arithmetic_function ℂ,	m : ℝ,	h : ∀ (n : ℕ), complex.abs (⇑f n) ≤ m,	z : ℝ,	hz : 1 < z,	h0 : ¬m = 0,	n : ℕ	⊢ ∥⇑f n / ↑n ^ ↑z∥ ≤ m / ↑n ^ z
f : arithmetic_function ℂ,	m : ℝ,	h : ∀ (n : ℕ), complex.abs (⇑f n) ≤ m,	z : ℝ,	hz : 1 < z,	h0 : ¬m = 0,	n : ℕ,	hm : 0 ≤ m	⊢ ∥⇑f n / ↑n ^ ↑z∥ ≤ m / ↑n ^ z
2 goals	case nat.zero	f : arithmetic_function ℂ,	m : ℝ,	h : ∀ (n : ℕ), complex.abs (⇑f n) ≤ m,	z : ℝ,	hz : 1 < z,	h0 : ¬m = 0,	hm : 0 ≤ m	⊢ ∥⇑f 0 / ↑0 ^ ↑z∥ ≤ m / ↑0 ^ z		case nat.succ	f : arithmetic_function ℂ,	m : ℝ,	h : ∀ (n : ℕ), complex.abs (⇑f n) ≤ m,	z : ℝ,	hz : 1 < z,	h0 : ¬m = 0,	hm : 0 ≤ m,	n : ℕ	⊢ ∥⇑f n.succ / ↑(n.succ) ^ ↑z∥ ≤ m / ↑(n.succ) ^ z
case nat.succ	f : arithmetic_function ℂ,	m : ℝ,	h : ∀ (n : ℕ), complex.abs (⇑f n) ≤ m,	z : ℝ,	hz : 1 < z,	h0 : ¬m = 0,	hm : 0 ≤ m,	n : ℕ	⊢ ∥⇑f n.succ / ↑(n.succ) ^ ↑z∥ ≤ m / ↑(n.succ) ^ z
case nat.succ	f : arithmetic_function ℂ,	m : ℝ,	h : ∀ (n : ℕ), complex.abs (⇑f n) ≤ m,	z : ℝ,	hz : 1 < z,	h0 : ¬m = 0,	hm : 0 ≤ m,	n : ℕ	⊢ complex.abs (⇑f n.succ) / complex.abs (↑(n.succ) ^ ↑z) ≤ m / ↑(n.succ) ^ z
f : arithmetic_function ℂ,	m : ℝ,	h : ∀ (n : ℕ), complex.abs (⇑f n) ≤ m,	z : ℝ,	hz : 1 < z,	h0 : ¬m = 0,	hm : 0 ≤ m,	n : ℕ	⊢ ↑(n.succ) ^ z = complex.abs (↑(n.succ) ^ ↑z)
⊢ ∀ (p : ℕ) [hp_prime : fact (nat.prime p)] {ε : ℚ}, 0 < ε → (∃ (k : ℕ), ↑p ^ -↑k < ε)
p : ℕ,	hp_prime : fact (nat.prime p),	ε : ℚ,	hε : 0 < ε	⊢ ∃ (k : ℕ), ↑p ^ -↑k < ε
p : ℕ,	hp_prime : fact (nat.prime p),	ε : ℚ,	hε : 0 < ε,	k : ℕ,	hk : ↑p ^ -↑k < ↑ε	⊢ ∃ (k : ℕ), ↑p ^ -↑k < ε
p : ℕ,	hp_prime : fact (nat.prime p),	ε : ℚ,	hε : 0 < ε,	k : ℕ,	hk : ↑p ^ -↑k < ↑ε	⊢ ↑p ^ -↑k < ε
p : ℕ,	hp_prime : fact (nat.prime p),	ε : ℚ,	hε : 0 < ε,	k : ℕ,	hk : ↑↑p ^ -↑k < ↑ε	⊢ ↑p ^ -↑k < ε
⊢ ∀ {p : ℕ}, padic_val_rat p 1 = 0
p : ℕ	⊢ padic_val_rat p 1 = 0
p : ℕ	⊢ dite (1 ≠ 0 ∧ p ≠ 1)	      (λ (h : 1 ≠ 0 ∧ p ≠ 1), ↑((multiplicity ↑p 1.num).get _) - ↑((multiplicity ↑p ↑(1.denom)).get _))	      (λ (h : ¬(1 ≠ 0 ∧ p ≠ 1)), 0) =	    0
2 goals	p : ℕ,	h : 1 ≠ 0 ∧ p ≠ 1	⊢ ↑((multiplicity ↑p 1.num).get _) - ↑((multiplicity ↑p ↑(1.denom)).get _) = 0		p : ℕ,	h : ¬(1 ≠ 0 ∧ p ≠ 1)	⊢ 0 = 0
⊢ ∀ {a : ℕ} (a1 : 1 < a) {m n : ℕ},	    n ≤ m → xz a1 (m - n) = xz a1 m * xz a1 n - ↑(d a1) * yz a1 m * yz a1 n
a : ℕ,	a1 : 1 < a,	m n : ℕ,	h : n ≤ m	⊢ xz a1 (m - n) = xz a1 m * xz a1 n - ↑(d a1) * yz a1 m * yz a1 n
3 goals	a : ℕ,	a1 : 1 < a,	m n : ℕ,	h : n ≤ m,	h : ↑(xn ?m_2 (m - n)) = ↑(xn ?m_2 m) * ↑(xn ?m_2 n) + ↑(d ?m_2) * ↑(yn ?m_2 m) * -↑(yn ?m_2 n),	a_1 : ↑(yn ?m_2 (m - n)) = ↑(xn ?m_2 m) * -↑(yn ?m_2 n) + ↑(yn ?m_2 m) * ↑(xn ?m_2 n)	⊢ xz a1 (m - n) = xz a1 m * xz a1 n - ↑(d a1) * yz a1 m * yz a1 n		a : ℕ,	a1 : 1 < a,	m n : ℕ,	h : n ≤ m	⊢ ℕ		a : ℕ,	a1 : 1 < a,	m n : ℕ,	h : n ≤ m	⊢ 1 < ?m_1
3 goals	a : ℕ,	a1 : 1 < a,	m n : ℕ,	h : n ≤ m,	a_1 : ↑(yn ?m_2 (m - n)) = ↑(xn ?m_2 m) * -↑(yn ?m_2 n) + ↑(yn ?m_2 m) * ↑(xn ?m_2 n),	h : ↑(xn ?m_2 (m - n)) = ↑(xn ?m_2 m) * ↑(xn ?m_2 n) + -(↑(d ?m_2) * ↑(yn ?m_2 m) * ↑(yn ?m_2 n))	⊢ xz a1 (m - n) = xz a1 m * xz a1 n - ↑(d a1) * yz a1 m * yz a1 n		a : ℕ,	a1 : 1 < a,	m n : ℕ,	h : n ≤ m	⊢ ℕ		a : ℕ,	a1 : 1 < a,	m n : ℕ,	h : n ≤ m	⊢ 1 < ?m_1
⊢ ∀ {x y z : ℤ} (h : pythagorean_triple x y z), h.is_classified
x y z : ℤ,	h : pythagorean_triple x y z	⊢ h.is_classified
2 goals	x y z : ℤ,	h : pythagorean_triple x y z,	h0 : x.gcd y = 0	⊢ h.is_classified		x y z : ℤ,	h : pythagorean_triple x y z,	h0 : ¬x.gcd y = 0	⊢ h.is_classified
3 goals	x y z : ℤ,	h : pythagorean_triple x y z,	h0 : x.gcd y = 0	⊢ x = 0		x y z : ℤ,	h : pythagorean_triple x y z,	h0 : x.gcd y = 0,	hx : x = 0	⊢ h.is_classified		x y z : ℤ,	h : pythagorean_triple x y z,	h0 : ¬x.gcd y = 0	⊢ h.is_classified
3 goals	x y z : ℤ,	h : pythagorean_triple x y z,	h0 : x.gcd y = 0	⊢ x.nat_abs = 0		x y z : ℤ,	h : pythagorean_triple x y z,	h0 : x.gcd y = 0,	hx : x = 0	⊢ h.is_classified		x y z : ℤ,	h : pythagorean_triple x y z,	h0 : ¬x.gcd y = 0	⊢ h.is_classified
2 goals	x y z : ℤ,	h : pythagorean_triple x y z,	h0 : x.gcd y = 0,	hx : x = 0	⊢ h.is_classified		x y z : ℤ,	h : pythagorean_triple x y z,	h0 : ¬x.gcd y = 0	⊢ h.is_classified
3 goals	x y z : ℤ,	h : pythagorean_triple x y z,	h0 : x.gcd y = 0,	hx : x = 0	⊢ y = 0		x y z : ℤ,	h : pythagorean_triple x y z,	h0 : x.gcd y = 0,	hx : x = 0,	hy : y = 0	⊢ h.is_classified		x y z : ℤ,	h : pythagorean_triple x y z,	h0 : ¬x.gcd y = 0	⊢ h.is_classified
3 goals	x y z : ℤ,	h : pythagorean_triple x y z,	h0 : x.gcd y = 0,	hx : x = 0	⊢ y.nat_abs = 0		x y z : ℤ,	h : pythagorean_triple x y z,	h0 : x.gcd y = 0,	hx : x = 0,	hy : y = 0	⊢ h.is_classified		x y z : ℤ,	h : pythagorean_triple x y z,	h0 : ¬x.gcd y = 0	⊢ h.is_classified
2 goals	x y z : ℤ,	h : pythagorean_triple x y z,	h0 : x.gcd y = 0,	hx : x = 0,	hy : y = 0	⊢ h.is_classified		x y z : ℤ,	h : pythagorean_triple x y z,	h0 : ¬x.gcd y = 0	⊢ h.is_classified
2 goals	x y z : ℤ,	h : pythagorean_triple x y z,	h0 : x.gcd y = 0,	hx : x = 0,	hy : y = 0	⊢ (x = 0 * (1 ^ 2 - 0 ^ 2) ∧ y = 0 * (2 * 1 * 0) ∨ x = 0 * (2 * 1 * 0) ∧ y = 0 * (1 ^ 2 - 0 ^ 2)) ∧	    1.gcd 0 = 1		x y z : ℤ,	h : pythagorean_triple x y z,	h0 : ¬x.gcd y = 0	⊢ h.is_classified
x y z : ℤ,	h : pythagorean_triple x y z,	h0 : ¬x.gcd y = 0	⊢ h.is_classified
x y z : ℤ,	h : pythagorean_triple x y z,	h0 : ¬x.gcd y = 0	⊢ _.is_primitive_classified
x y z : ℤ,	h : pythagorean_triple x y z,	h0 : ¬x.gcd y = 0	⊢ (x / ↑(x.gcd y)).gcd (y / ↑(x.gcd y)) = 1
⊢ ∀ {d : ℤ} (n x y : ℤ), sqrtd * ↑n * {re := x, im := y} = {re := d * n * y, im := n * x}
d n x y : ℤ	⊢ sqrtd * ↑n * {re := x, im := y} = {re := d * n * y, im := n * x}
⊢ ∀ {d : ℤ} (z : ℤ√d), (bit1 z).im = bit0 z.im
d : ℤ,	z : ℤ√d	⊢ (bit1 z).im = bit0 z.im
⊢ ∀ {α : Type u} [_inst_1 : lattice α] [_inst_2 : bounded_order α] {a b : α},	    disjoint a b → a ⊔ b = a → b = ⊥
α : Type u,	_inst_1 : lattice α,	_inst_2 : bounded_order α,	a b : α,	w : disjoint a b,	h : a ⊔ b = a	⊢ b = ⊥
α : Type u,	_inst_1 : lattice α,	_inst_2 : bounded_order α,	a b : α,	h : a ⊔ b = a,	w : a ⊓ b = ⊥	⊢ b = ⊥
α : Type u,	_inst_1 : lattice α,	_inst_2 : bounded_order α,	a b : α,	h : a ⊔ b = a,	w : a ⊓ b = ⊥	⊢ b ≤ a
⊢ ∀ {γ : Type w} [_inst_3 : linear_order γ] (a : γ) {b : γ} {s : set γ},	    is_least s b → is_least (insert a s) (min a b)
γ : Type w,	_inst_3 : linear_order γ,	a b : γ,	s : set γ,	hs : is_least s b	⊢ is_least (insert a s) (min a b)
⊢ ∀ {α : Type u_1} [_inst_1 : partial_order α] (c : closure_operator α), c = mk₃ ⇑c c.closed _ _ _
α : Type u_1,	_inst_1 : partial_order α,	c : closure_operator α	⊢ c = mk₃ ⇑c c.closed _ _ _
α : Type u_1,	_inst_1 : partial_order α,	c : closure_operator α,	x : α	⊢ ⇑c x = ⇑(mk₃ ⇑c c.closed _ _ _) x
⊢ ∀ {α : Type u} {ι : Sort w} [_inst_1 : complete_distrib_lattice α] {a : α} {f : ι → α},	    disjoint (⨆ (i : ι), f i) a ↔ ∀ (i : ι), disjoint (f i) a
α : Type u,	ι : Sort w,	_inst_1 : complete_distrib_lattice α,	a : α,	f : ι → α	⊢ disjoint (⨆ (i : ι), f i) a ↔ ∀ (i : ι), disjoint (f i) a
⊢ ∀ {α : Type u_1} {β : Type u_2} [_inst_1 : complete_lattice α] {s : set β} {f : β → α},	    is_lub (f '' s) (⨆ (x : β) (H : x ∈ s), f x)
α : Type u_1,	β : Type u_2,	_inst_1 : complete_lattice α,	s : set β,	f : β → α	⊢ is_lub (f '' s) (⨆ (x : β) (H : x ∈ s), f x)
⊢ ∀ {α : Type u_1} {β : Type u_2} [_inst_1 : complete_lattice α] {f : β → α},	    (⨆ (x : β) (H : x ∈ ∅), f x) = ⊥
α : Type u_1,	β : Type u_2,	_inst_1 : complete_lattice α,	f : β → α	⊢ (⨆ (x : β) (H : x ∈ ∅), f x) = ⊥
⊢ ∀ {α : Type u_1} {β : Type u_2} [_inst_1 : complete_lattice α] {f : β → α},	    (⨅ (x : β) (H : x ∈ univ), f x) = ⨅ (x : β), f x
α : Type u_1,	β : Type u_2,	_inst_1 : complete_lattice α,	f : β → α	⊢ (⨅ (x : β) (H : x ∈ univ), f x) = ⨅ (x : β), f x
⊢ ∀ {α : Type u_1} {R : Type u_2} [_inst_1 : linear_ordered_semiring R] [_inst_2 : archimedean R] {l : filter α}	  {f : α → R} {r : R}, 0 < r → tendsto f l at_top → tendsto (λ (x : α), f x * r) l at_top
α : Type u_1,	R : Type u_2,	_inst_1 : linear_ordered_semiring R,	_inst_2 : archimedean R,	l : filter α,	f : α → R,	r : R,	hr : 0 < r,	hf : tendsto f l at_top	⊢ tendsto (λ (x : α), f x * r) l at_top
α : Type u_1,	R : Type u_2,	_inst_1 : linear_ordered_semiring R,	_inst_2 : archimedean R,	l : filter α,	f : α → R,	r : R,	hr : 0 < r,	hf : tendsto f l at_top,	b : R	⊢ ∀ᶠ (a : α) in l, b ≤ f a * r
α : Type u_1,	R : Type u_2,	_inst_1 : linear_ordered_semiring R,	_inst_2 : archimedean R,	l : filter α,	f : α → R,	r : R,	hr : 0 < r,	hf : tendsto f l at_top,	b : R,	n : ℕ,	hn : 1 ≤ n • r	⊢ ∀ᶠ (a : α) in l, b ≤ f a * r
2 goals	α : Type u_1,	R : Type u_2,	_inst_1 : linear_ordered_semiring R,	_inst_2 : archimedean R,	l : filter α,	f : α → R,	r : R,	hr : 0 < r,	hf : tendsto f l at_top,	b : R,	n : ℕ,	hn : 1 ≤ n • r	⊢ 1 ≤ ↑n * r		α : Type u_1,	R : Type u_2,	_inst_1 : linear_ordered_semiring R,	_inst_2 : archimedean R,	l : filter α,	f : α → R,	r : R,	hr : 0 < r,	hf : tendsto f l at_top,	b : R,	n : ℕ,	hn : 1 ≤ n • r,	hn' : 1 ≤ ↑n * r	⊢ ∀ᶠ (a : α) in l, b ≤ f a * r
α : Type u_1,	R : Type u_2,	_inst_1 : linear_ordered_semiring R,	_inst_2 : archimedean R,	l : filter α,	f : α → R,	r : R,	hr : 0 < r,	hf : tendsto f l at_top,	b : R,	n : ℕ,	hn : 1 ≤ n • r,	hn' : 1 ≤ ↑n * r	⊢ ∀ᶠ (a : α) in l, b ≤ f a * r
α : Type u_1,	R : Type u_2,	_inst_1 : linear_ordered_semiring R,	_inst_2 : archimedean R,	l : filter α,	f : α → R,	r : R,	hr : 0 < r,	hf : tendsto f l at_top,	b : R,	n : ℕ,	hn : 1 ≤ n • r,	hn' : 1 ≤ ↑n * r	⊢ ∀ (a : α), max b 0 * ↑n ≤ f a → b ≤ f a * r
α : Type u_1,	R : Type u_2,	_inst_1 : linear_ordered_semiring R,	_inst_2 : archimedean R,	l : filter α,	f : α → R,	r : R,	hr : 0 < r,	hf : tendsto f l at_top,	b : R,	n : ℕ,	hn : 1 ≤ n • r,	hn' : 1 ≤ ↑n * r,	x : α,	hx : max b 0 * ↑n ≤ f x	⊢ b ≤ f x * r
⊢ ∀ {α : Type u_1} (B : filter_basis α), generate B.sets = B.filter
α : Type u_1,	B : filter_basis α	⊢ generate B.sets = B.filter
2 goals	α : Type u_1,	B : filter_basis α	⊢ generate B.sets ≤ B.filter		α : Type u_1,	B : filter_basis α	⊢ B.filter ≤ generate B.sets
2 goals	α : Type u_1,	B : filter_basis α,	U : set α,	U_in : U ∈ B.filter	⊢ U ∈ generate B.sets		α : Type u_1,	B : filter_basis α	⊢ B.filter ≤ generate B.sets
2 goals	α : Type u_1,	B : filter_basis α,	U : set α,	U_in : U ∈ B.filter,	V : set α,	V_in : V ∈ B,	h : V ⊆ U	⊢ U ∈ generate B.sets		α : Type u_1,	B : filter_basis α	⊢ B.filter ≤ generate B.sets
α : Type u_1,	B : filter_basis α	⊢ B.filter ≤ generate B.sets
α : Type u_1,	B : filter_basis α	⊢ B.sets ⊆ B.filter.sets
⊢ ∀ {α : Type u_1} {f g : filter α},	    (f ⊓ g).ne_bot ↔ ∀ {p : α → Prop}, (∀ᶠ (x : α) in g, p x) → (∃ᶠ (x : α) in f, p x)
α : Type u_1,	f g : filter α	⊢ (f ⊓ g).ne_bot ↔ ∀ {p : α → Prop}, (∀ᶠ (x : α) in g, p x) → (∃ᶠ (x : α) in f, p x)
α : Type u_1,	f g : filter α	⊢ (g ⊓ f).ne_bot ↔ ∀ {p : α → Prop}, (∀ᶠ (x : α) in g, p x) → (∃ᶠ (x : α) in f, p x)
⊢ ∀ {α : Type u} {β : Type v} {f : α → β} {a : filter α} {b : β},	    tendsto f a (pure b) ↔ ∀ᶠ (x : α) in a, f x = b
α : Type u,	β : Type v,	f : α → β,	a : filter α,	b : β	⊢ tendsto f a (pure b) ↔ ∀ᶠ (x : α) in a, f x = b
⊢ ∀ {α : Type u} {β : Type v} {ι : Sort x} [_inst_1 : nonempty ι] {f : filter α} {g : ι → filter β},	    f.prod (⨅ (i : ι), g i) = ⨅ (i : ι), f.prod (g i)
α : Type u,	β : Type v,	ι : Sort x,	_inst_1 : nonempty ι,	f : filter α,	g : ι → filter β	⊢ f.prod (⨅ (i : ι), g i) = ⨅ (i : ι), f.prod (g i)
α : Type u,	β : Type v,	ι : Sort x,	_inst_1 : nonempty ι,	f : filter α,	g : ι → filter β	⊢ (⨅ (x : ι), comap prod.fst f ⊓ comap prod.snd (g x)) = ⨅ (i : ι), f.prod (g i)
⊢ ∀ {α : Type u} {β : Type v} [_inst_1 : preorder α] [_inst_2 : preorder β] {l : α → β} {u : β → α},	    galois_connection l u → ∀ (s : set α), upper_bounds (l '' s) = u ⁻¹' upper_bounds s
α : Type u,	β : Type v,	_inst_1 : preorder α,	_inst_2 : preorder β,	l : α → β,	u : β → α,	gc : galois_connection l u,	s : set α	⊢ upper_bounds (l '' s) = u ⁻¹' upper_bounds s
⊢ ∀ {α : Type u} [_inst_1 : lattice α] {a b : α}, a ⊔ b = b ↔ a ⊓ b = a
α : Type u,	_inst_1 : lattice α,	a b : α	⊢ a ⊔ b = b ↔ a ⊓ b = a
⊢ ∀ {α : Type u} {β : Type v} {γ : Type u_1} [_inst_1 : omega_complete_partial_order α]	  [_inst_2 : omega_complete_partial_order β] [_inst_3 : omega_complete_partial_order γ] (f : α →o β)	  (g : β →o γ), continuous f → continuous g → continuous (g.comp f)
α : Type u,	β : Type v,	γ : Type u_1,	_inst_1 : omega_complete_partial_order α,	_inst_2 : omega_complete_partial_order β,	_inst_3 : omega_complete_partial_order γ,	f : α →o β,	g : β →o γ,	hfc : continuous f,	hgc : continuous g	⊢ continuous (g.comp f)
α : Type u,	β : Type v,	γ : Type u_1,	_inst_1 : omega_complete_partial_order α,	_inst_2 : omega_complete_partial_order β,	_inst_3 : omega_complete_partial_order γ,	f : α →o β,	g : β →o γ,	hfc : ∀ (c : chain α), ⇑f (ωSup c) = ωSup (c.map f),	hgc : ∀ (c : chain β), ⇑g (ωSup c) = ωSup (c.map g)	⊢ ∀ (c : chain α), ⇑g (⇑f (ωSup c)) = ωSup (c.map (g.comp f))
α : Type u,	β : Type v,	γ : Type u_1,	_inst_1 : omega_complete_partial_order α,	_inst_2 : omega_complete_partial_order β,	_inst_3 : omega_complete_partial_order γ,	f : α →o β,	g : β →o γ,	hfc : ∀ (c : chain α), ⇑f (ωSup c) = ωSup (c.map f),	hgc : ∀ (c : chain β), ⇑g (ωSup c) = ωSup (c.map g),	c : chain α	⊢ ⇑g (⇑f (ωSup c)) = ωSup (c.map (g.comp f))
⊢ ∀ {α : Type u_1} [_inst_1 : semilattice_sup α] (f : ℕ → α) (n : ℕ),	    ⇑(partial_sups f) n = (finset.range (n + 1)).sup' _ f
α : Type u_1,	_inst_1 : semilattice_sup α,	f : ℕ → α,	n : ℕ	⊢ ⇑(partial_sups f) n = (finset.range (n + 1)).sup' _ f
2 goals	case nat.zero	α : Type u_1,	_inst_1 : semilattice_sup α,	f : ℕ → α	⊢ ⇑(partial_sups f) 0 = (finset.range (0 + 1)).sup' _ f		case nat.succ	α : Type u_1,	_inst_1 : semilattice_sup α,	f : ℕ → α,	n : ℕ,	ih : ⇑(partial_sups f) n = (finset.range (n + 1)).sup' _ f	⊢ ⇑(partial_sups f) n.succ = (finset.range (n.succ + 1)).sup' _ f
case nat.succ	α : Type u_1,	_inst_1 : semilattice_sup α,	f : ℕ → α,	n : ℕ,	ih : ⇑(partial_sups f) n = (finset.range (n + 1)).sup' _ f	⊢ ⇑(partial_sups f) n.succ = (finset.range (n.succ + 1)).sup' _ f
α : Type u_1,	_inst_1 : semilattice_sup α,	f : ℕ → α,	n : ℕ,	ih : nat.rec (f 0) (λ (n : ℕ) (a : α), a ⊔ f (n + 1)) n = (finset.range (n + 1)).sup' _ f	⊢ nat.rec (f 0) (λ (n : ℕ) (a : α), a ⊔ f (n + 1)) n ⊔ f (n + 1) = (finset.range (n.succ + 1)).sup' _ f
α : Type u_1,	_inst_1 : semilattice_sup α,	f : ℕ → α,	n : ℕ,	ih : nat.rec (f 0) (λ (n : ℕ) (a : α), a ⊔ f (n + 1)) n = (finset.range (n + 1)).sup' _ f	⊢ nat.rec (f 0) (λ (n : ℕ) (a : α), a ⊔ f (n + 1)) n ⊔ f (n + 1) =	    (has_insert.insert n.succ (finset.range n.succ)).sup' _ (λ (x : ℕ), f x)
⊢ ∀ {α : Type u_1} {β : Type u_2} [_inst_1 : has_le α] [_inst_2 : has_le β] (e : α ≃o β), e.symm.symm = e
α : Type u_1,	β : Type u_2,	_inst_1 : has_le α,	_inst_2 : has_le β,	e : α ≃o β	⊢ e.symm.symm = e
α : Type u_1,	β : Type u_2,	_inst_1 : has_le α,	_inst_2 : has_le β,	e : α ≃o β,	x : α	⊢ ⇑(e.symm.symm) x = ⇑e x
⊢ ∀ {α : Type u_1} [_inst_1 : boolean_algebra α] (a b : α), a Δ b = a ⊓ bᶜ ⊔ b ⊓ aᶜ
α : Type u_1,	_inst_1 : boolean_algebra α,	a b : α	⊢ a Δ b = a ⊓ bᶜ ⊔ b ⊓ aᶜ
⊢ ∀ {α : Type u_1} [_inst_1 : generalized_boolean_algebra α] (a b c : α),	    c \ a Δ b = c ⊓ a ⊓ b ⊔ c \ (a ⊔ b)
α : Type u_1,	_inst_1 : generalized_boolean_algebra α,	a b c : α	⊢ c \ a Δ b = c ⊓ a ⊓ b ⊔ c \ (a ⊔ b)
⊢ ∀ {α : Type u_1} {ι : Type u_2} [_inst_1 : partial_order α] (f : finset ι) (g : ι → set α),	    (∀ (i : ι), i ∈ f → (g i).is_wf) → (f.sup g).is_wf
α : Type u_1,	ι : Type u_2,	_inst_1 : partial_order α,	f : finset ι,	g : ι → set α,	hf : ∀ (i : ι), i ∈ f → (g i).is_wf	⊢ (f.sup g).is_wf
α : Type u_1,	ι : Type u_2,	_inst_1 : partial_order α,	f : finset ι,	g : ι → set α,	hf : ∀ (i : ι), i ∈ f → (g i).is_wf,	_inst : Π (a : Prop), decidable a	⊢ (f.sup g).is_wf
α : Type u_1,	ι : Type u_2,	_inst_1 : partial_order α,	f : finset ι,	g : ι → set α,	_inst : Π (a : Prop), decidable a	⊢ (∀ (i : ι), i ∈ f → (g i).is_wf) → (f.sup g).is_wf
2 goals	α : Type u_1,	ι : Type u_2,	_inst_1 : partial_order α,	f : finset ι,	g : ι → set α,	_inst : Π (a : Prop), decidable a	⊢ (∀ (i : ι), i ∈ ∅ → (g i).is_wf) → (∅.sup g).is_wf		α : Type u_1,	ι : Type u_2,	_inst_1 : partial_order α,	f : finset ι,	g : ι → set α,	_inst : Π (a : Prop), decidable a	⊢ ∀ ⦃a : ι⦄ {s : finset ι},	    a ∉ s →	    ((∀ (i : ι), i ∈ s → (g i).is_wf) → (s.sup g).is_wf) →	    (∀ (i : ι), i ∈ has_insert.insert a s → (g i).is_wf) → ((has_insert.insert a s).sup g).is_wf
2 goals	α : Type u_1,	ι : Type u_2,	_inst_1 : partial_order α,	f : finset ι,	g : ι → set α,	_inst : Π (a : Prop), decidable a,	h : ∀ (i : ι), i ∈ ∅ → (g i).is_wf	⊢ (∅.sup g).is_wf		α : Type u_1,	ι : Type u_2,	_inst_1 : partial_order α,	f : finset ι,	g : ι → set α,	_inst : Π (a : Prop), decidable a	⊢ ∀ ⦃a : ι⦄ {s : finset ι},	    a ∉ s →	    ((∀ (i : ι), i ∈ s → (g i).is_wf) → (s.sup g).is_wf) →	    (∀ (i : ι), i ∈ has_insert.insert a s → (g i).is_wf) → ((has_insert.insert a s).sup g).is_wf
α : Type u_1,	ι : Type u_2,	_inst_1 : partial_order α,	f : finset ι,	g : ι → set α,	_inst : Π (a : Prop), decidable a	⊢ ∀ ⦃a : ι⦄ {s : finset ι},	    a ∉ s →	    ((∀ (i : ι), i ∈ s → (g i).is_wf) → (s.sup g).is_wf) →	    (∀ (i : ι), i ∈ has_insert.insert a s → (g i).is_wf) → ((has_insert.insert a s).sup g).is_wf
α : Type u_1,	ι : Type u_2,	_inst_1 : partial_order α,	f : finset ι,	g : ι → set α,	_inst : Π (a : Prop), decidable a,	s : ι,	f : finset ι,	sf : s ∉ f,	hf : (∀ (i : ι), i ∈ f → (g i).is_wf) → (f.sup g).is_wf,	hsf : ∀ (i : ι), i ∈ has_insert.insert s f → (g i).is_wf	⊢ ((has_insert.insert s f).sup g).is_wf
α : Type u_1,	ι : Type u_2,	_inst_1 : partial_order α,	f : finset ι,	g : ι → set α,	_inst : Π (a : Prop), decidable a,	s : ι,	f : finset ι,	sf : s ∉ f,	hf : (∀ (i : ι), i ∈ f → (g i).is_wf) → (f.sup g).is_wf,	hsf : ∀ (i : ι), i ∈ has_insert.insert s f → (g i).is_wf	⊢ (g s ⊔ f.sup g).is_wf
⊢ ∀ {R : Type u} [_inst_1 : comm_ring R] (f : polynomial R), eval₂ (of f) (root f) f = 0
R : Type u,	_inst_1 : comm_ring R,	f : polynomial R	⊢ eval₂ (of f) (root f) f = 0
⊢ ∀ {R : Type u_1} {M : Type u_2} [_inst_1 : ring R] [_inst_2 : add_comm_group M] [_inst_3 : module R M],	    (∀ (f : ℕ →o order_dual (submodule R M)), ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑f n = ⇑f m) ↔	      is_artinian R M
R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M	⊢ (∀ (f : ℕ →o order_dual (submodule R M)), ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑f n = ⇑f m) ↔	    is_artinian R M
R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M	⊢ (∀ (f : ℕ →o order_dual (submodule R M)), ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑f n = ⇑f m) ↔	    well_founded has_lt.lt
⊢ ∀ {R : Type u_1} {A : Type u_2} [_inst_1 : comm_ring R] [_inst_2 : comm_ring A] [_inst_3 : algebra R A]	  [_inst_10 : is_noetherian_ring R], finite_type R A ↔ finite_presentation R A
R : Type u_1,	A : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_ring A,	_inst_3 : algebra R A,	_inst_10 : is_noetherian_ring R	⊢ finite_type R A ↔ finite_presentation R A
R : Type u_1,	A : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_ring A,	_inst_3 : algebra R A,	_inst_10 : is_noetherian_ring R,	h : finite_type R A	⊢ finite_presentation R A
R : Type u_1,	A : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_ring A,	_inst_3 : algebra R A,	_inst_10 : is_noetherian_ring R,	h : finite_type R A,	n : ℕ,	f : mv_polynomial (fin n) R →ₐ[R] A,	hf : surjective ⇑f	⊢ finite_presentation R A
R : Type u_1,	A : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_ring A,	_inst_3 : algebra R A,	_inst_10 : is_noetherian_ring R,	h : finite_type R A,	n : ℕ,	f : mv_polynomial (fin n) R →ₐ[R] A,	hf : surjective ⇑f	⊢ f.to_ring_hom.ker.fg
R : Type u_1,	A : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_ring A,	_inst_3 : algebra R A,	_inst_10 : is_noetherian_ring R,	h : finite_type R A,	n : ℕ,	f : mv_polynomial (fin n) R →ₐ[R] A,	hf : surjective ⇑f,	hnoet : is_noetherian_ring (mv_polynomial (fin n) R)	⊢ f.to_ring_hom.ker.fg
R : Type u_1,	A : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_ring A,	_inst_3 : algebra R A,	_inst_10 : is_noetherian_ring R,	h : finite_type R A,	n : ℕ,	f : mv_polynomial (fin n) R →ₐ[R] A,	hf : surjective ⇑f,	hnoet : ∀ (s : submodule (mv_polynomial (fin n) R) (mv_polynomial (fin n) R)), s.fg	⊢ f.to_ring_hom.ker.fg
⊢ ∀ {A : Type u_1} {B : Type u_2} [_inst_1 : comm_ring A] [_inst_2 : comm_ring B] (f : A →+* B),	    surjective ⇑f → f.finite
A : Type u_1,	B : Type u_2,	_inst_1 : comm_ring A,	_inst_2 : comm_ring B,	f : A →+* B,	hf : surjective ⇑f	⊢ f.finite
A : Type u_1,	B : Type u_2,	_inst_1 : comm_ring A,	_inst_2 : comm_ring B,	f : A →+* B,	hf : surjective ⇑f,	_inst : algebra A B := f.to_algebra	⊢ f.finite
⊢ ∀ {R : Type u_1} [_inst_1 : comm_ring R] {S : submonoid R} {P : Type u_2} [_inst_2 : comm_ring P]	  [_inst_3 : algebra R P] (I : fractional_ideal S P), 0 ≤ I
R : Type u_1,	_inst_1 : comm_ring R,	S : submonoid R,	P : Type u_2,	_inst_2 : comm_ring P,	_inst_3 : algebra R P,	I : fractional_ideal S P	⊢ 0 ≤ I
R : Type u_1,	_inst_1 : comm_ring R,	S : submonoid R,	P : Type u_2,	_inst_2 : comm_ring P,	_inst_3 : algebra R P,	I : fractional_ideal S P,	x : P,	hx : x ∈ 0	⊢ x ∈ I
R : Type u_1,	_inst_1 : comm_ring R,	S : submonoid R,	P : Type u_2,	_inst_2 : comm_ring P,	_inst_3 : algebra R P,	I : fractional_ideal S P,	x : P,	hx : x ∈ 0	⊢ x = 0
⊢ ∀ {Γ : Type u_1} {R : Type u_2} [_inst_1 : ordered_cancel_add_comm_monoid Γ]	  [_inst_2 : non_unital_non_assoc_semiring R] {r : R} {x : hahn_series Γ R} {a : Γ},	    (⇑(single 0) r * x).coeff a = r * x.coeff a
Γ : Type u_1,	R : Type u_2,	_inst_1 : ordered_cancel_add_comm_monoid Γ,	_inst_2 : non_unital_non_assoc_semiring R,	r : R,	x : hahn_series Γ R,	a : Γ	⊢ (⇑(single 0) r * x).coeff a = r * x.coeff a
⊢ ∀ {Γ : Type u_1} {R : Type u_2} [_inst_1 : ordered_cancel_add_comm_monoid Γ] [_inst_2 : non_assoc_semiring R]	  {r : R}, r ≠ 0 → ⇑C r ≠ 0
Γ : Type u_1,	R : Type u_2,	_inst_1 : ordered_cancel_add_comm_monoid Γ,	_inst_2 : non_assoc_semiring R,	r : R,	h : r ≠ 0	⊢ ⇑C r ≠ 0
Γ : Type u_1,	R : Type u_2,	_inst_1 : ordered_cancel_add_comm_monoid Γ,	_inst_2 : non_assoc_semiring R,	r : R,	h : ⇑C r = 0	⊢ r = 0
Γ : Type u_1,	R : Type u_2,	_inst_1 : ordered_cancel_add_comm_monoid Γ,	_inst_2 : non_assoc_semiring R,	r : R,	h : ⇑C r = ⇑C 0	⊢ r = 0
⊢ ∀ {Γ : Type u_1} {R : Type u_2} [_inst_1 : ordered_cancel_add_comm_monoid Γ] [_inst_2 : non_assoc_semiring R]	  {r : R}, (⇑C r).order = 0
Γ : Type u_1,	R : Type u_2,	_inst_1 : ordered_cancel_add_comm_monoid Γ,	_inst_2 : non_assoc_semiring R,	r : R	⊢ (⇑C r).order = 0
2 goals	Γ : Type u_1,	R : Type u_2,	_inst_1 : ordered_cancel_add_comm_monoid Γ,	_inst_2 : non_assoc_semiring R,	r : R,	h : r = 0	⊢ (⇑C r).order = 0		Γ : Type u_1,	R : Type u_2,	_inst_1 : ordered_cancel_add_comm_monoid Γ,	_inst_2 : non_assoc_semiring R,	r : R,	h : ¬r = 0	⊢ (⇑C r).order = 0
Γ : Type u_1,	R : Type u_2,	_inst_1 : ordered_cancel_add_comm_monoid Γ,	_inst_2 : non_assoc_semiring R,	r : R,	h : ¬r = 0	⊢ (⇑C r).order = 0
⊢ ∀ {R : Type u_1} {S : Type u_2} [_inst_1 : comm_ring R] [_inst_2 : comm_ring S] {f : R →+* S},	    surjective ⇑f → ∀ {I : ideal R}, f.ker ≤ I → map f I.radical = (map f I).radical
R : Type u_1,	S : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_ring S,	f : R →+* S,	hf : surjective ⇑f,	I : ideal R,	h : f.ker ≤ I	⊢ map f I.radical = (map f I).radical
R : Type u_1,	S : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_ring S,	f : R →+* S,	hf : surjective ⇑f,	I : ideal R,	h : f.ker ≤ I	⊢ map f (Inf {J : ideal R | I ≤ J ∧ J.is_prime}) = Inf {J : ideal S | map f I ≤ J ∧ J.is_prime}
R : Type u_1,	S : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_ring S,	f : R →+* S,	hf : surjective ⇑f,	I : ideal R,	h : f.ker ≤ I,	this : ∀ (J : ideal R), J ∈ {J : ideal R | I ≤ J ∧ J.is_prime} → f.ker ≤ J	⊢ map f (Inf {J : ideal R | I ≤ J ∧ J.is_prime}) = Inf {J : ideal S | map f I ≤ J ∧ J.is_prime}
R : Type u_1,	S : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_ring S,	f : R →+* S,	hf : surjective ⇑f,	I : ideal R,	h : f.ker ≤ I,	this : ∀ (J : ideal R), J ∈ {J : ideal R | I ≤ J ∧ J.is_prime} → f.ker ≤ J	⊢ (λ (J : ideal S), map f I ≤ J ∧ J.is_prime) =	    λ (b : ideal S), ∃ (a : ideal R), a ∈ {J : ideal R | I ≤ J ∧ J.is_prime} ∧ map f a = b
2 goals	R : Type u_1,	S : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_ring S,	f : R →+* S,	hf : surjective ⇑f,	I : ideal R,	h : f.ker ≤ I,	this : ∀ (J : ideal R), J ∈ {J : ideal R | I ≤ J ∧ J.is_prime} → f.ker ≤ J,	j : ideal S	⊢ map f I ≤ j ∧ is_prime j → (∃ (a : ideal R), a ∈ {J : ideal R | I ≤ J ∧ J.is_prime} ∧ map f a = j)		R : Type u_1,	S : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_ring S,	f : R →+* S,	hf : surjective ⇑f,	I : ideal R,	h : f.ker ≤ I,	this : ∀ (J : ideal R), J ∈ {J : ideal R | I ≤ J ∧ J.is_prime} → f.ker ≤ J,	j : ideal S	⊢ (∃ (a : ideal R), a ∈ {J : ideal R | I ≤ J ∧ J.is_prime} ∧ map f a = j) → map f I ≤ j ∧ is_prime j
2 goals	R : Type u_1,	S : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_ring S,	f : R →+* S,	hf : surjective ⇑f,	I : ideal R,	h : f.ker ≤ I,	this : ∀ (J : ideal R), J ∈ {J : ideal R | I ≤ J ∧ J.is_prime} → f.ker ≤ J,	j : ideal S,	hj : map f I ≤ j,	hj' : is_prime j	⊢ ∃ (a : ideal R), a ∈ {J : ideal R | I ≤ J ∧ J.is_prime} ∧ map f a = j		R : Type u_1,	S : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_ring S,	f : R →+* S,	hf : surjective ⇑f,	I : ideal R,	h : f.ker ≤ I,	this : ∀ (J : ideal R), J ∈ {J : ideal R | I ≤ J ∧ J.is_prime} → f.ker ≤ J,	j : ideal S	⊢ (∃ (a : ideal R), a ∈ {J : ideal R | I ≤ J ∧ J.is_prime} ∧ map f a = j) → map f I ≤ j ∧ is_prime j
2 goals	R : Type u_1,	S : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_ring S,	f : R →+* S,	hf : surjective ⇑f,	I : ideal R,	h : f.ker ≤ I,	this : ∀ (J : ideal R), J ∈ {J : ideal R | I ≤ J ∧ J.is_prime} → f.ker ≤ J,	j : ideal S,	hj : map f I ≤ j,	hj' _inst : is_prime j	⊢ ∃ (a : ideal R), a ∈ {J : ideal R | I ≤ J ∧ J.is_prime} ∧ map f a = j		R : Type u_1,	S : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_ring S,	f : R →+* S,	hf : surjective ⇑f,	I : ideal R,	h : f.ker ≤ I,	this : ∀ (J : ideal R), J ∈ {J : ideal R | I ≤ J ∧ J.is_prime} → f.ker ≤ J,	j : ideal S	⊢ (∃ (a : ideal R), a ∈ {J : ideal R | I ≤ J ∧ J.is_prime} ∧ map f a = j) → map f I ≤ j ∧ is_prime j
R : Type u_1,	S : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_ring S,	f : R →+* S,	hf : surjective ⇑f,	I : ideal R,	h : f.ker ≤ I,	this : ∀ (J : ideal R), J ∈ {J : ideal R | I ≤ J ∧ J.is_prime} → f.ker ≤ J,	j : ideal S	⊢ (∃ (a : ideal R), a ∈ {J : ideal R | I ≤ J ∧ J.is_prime} ∧ map f a = j) → map f I ≤ j ∧ is_prime j
R : Type u_1,	S : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_ring S,	f : R →+* S,	hf : surjective ⇑f,	I : ideal R,	h : f.ker ≤ I,	this : ∀ (J : ideal R), J ∈ {J : ideal R | I ≤ J ∧ J.is_prime} → f.ker ≤ J,	j : ideal S,	J : ideal R,	hJ : J ∈ {J : ideal R | I ≤ J ∧ J.is_prime},	hJ' : map f J = j	⊢ map f I ≤ j ∧ is_prime j
R : Type u_1,	S : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_ring S,	f : R →+* S,	hf : surjective ⇑f,	I : ideal R,	h : f.ker ≤ I,	this : ∀ (J : ideal R), J ∈ {J : ideal R | I ≤ J ∧ J.is_prime} → f.ker ≤ J,	j : ideal S,	J : ideal R,	hJ : J ∈ {J : ideal R | I ≤ J ∧ J.is_prime},	hJ' : map f J = j,	_inst : J.is_prime	⊢ map f I ≤ j ∧ is_prime j
⊢ ∀ {R : Type u} [_inst_1 : comm_semiring R] (s : R) (n : ℕ), span {s} ^ n = span {s ^ n}
R : Type u,	_inst_1 : comm_semiring R,	s : R,	n : ℕ	⊢ span {s} ^ n = span {s ^ n}
2 goals	case nat.zero	R : Type u,	_inst_1 : comm_semiring R,	s : R	⊢ span {s} ^ 0 = span {s ^ 0}		case nat.succ	R : Type u,	_inst_1 : comm_semiring R,	s : R,	n : ℕ,	ih : span {s} ^ n = span {s ^ n}	⊢ span {s} ^ n.succ = span {s ^ n.succ}
case nat.succ	R : Type u,	_inst_1 : comm_semiring R,	s : R,	n : ℕ,	ih : span {s} ^ n = span {s ^ n}	⊢ span {s} ^ n.succ = span {s ^ n.succ}
⊢ ∀ {P : ℕ → Prop}, P 0 → P 1 → (∀ (p a : ℕ), nat.prime p → P a → P (p * a)) → ∀ (n : ℕ), P n
P : ℕ → Prop,	h₀ : P 0,	h₁ : P 1,	h : ∀ (p a : ℕ), nat.prime p → P a → P (p * a),	n : ℕ	⊢ P n
3 goals	P : ℕ → Prop,	h₀ : P 0,	h₁ : P 1,	h : ∀ (p a : ℕ), nat.prime p → P a → P (p * a),	n : ℕ	⊢ P 0		P : ℕ → Prop,	h₀ : P 0,	h₁ : P 1,	h : ∀ (p a : ℕ), nat.prime p → P a → P (p * a),	n : ℕ	⊢ ∀ (x : ℕ), is_unit x → P x		P : ℕ → Prop,	h₀ : P 0,	h₁ : P 1,	h : ∀ (p a : ℕ), nat.prime p → P a → P (p * a),	n : ℕ	⊢ ∀ (a p : ℕ), a ≠ 0 → prime p → P a → P (p * a)
2 goals	P : ℕ → Prop,	h₀ : P 0,	h₁ : P 1,	h : ∀ (p a : ℕ), nat.prime p → P a → P (p * a),	n : ℕ	⊢ ∀ (x : ℕ), is_unit x → P x		P : ℕ → Prop,	h₀ : P 0,	h₁ : P 1,	h : ∀ (p a : ℕ), nat.prime p → P a → P (p * a),	n : ℕ	⊢ ∀ (a p : ℕ), a ≠ 0 → prime p → P a → P (p * a)
2 goals	P : ℕ → Prop,	h₀ : P 0,	h₁ : P 1,	h : ∀ (p a : ℕ), nat.prime p → P a → P (p * a),	n n : ℕ,	h : is_unit n	⊢ P n		P : ℕ → Prop,	h₀ : P 0,	h₁ : P 1,	h : ∀ (p a : ℕ), nat.prime p → P a → P (p * a),	n : ℕ	⊢ ∀ (a p : ℕ), a ≠ 0 → prime p → P a → P (p * a)
2 goals	P : ℕ → Prop,	h₀ : P 0,	h₁ : P 1,	h : ∀ (p a : ℕ), nat.prime p → P a → P (p * a),	n n : ℕ,	h : is_unit n	⊢ P 1		P : ℕ → Prop,	h₀ : P 0,	h₁ : P 1,	h : ∀ (p a : ℕ), nat.prime p → P a → P (p * a),	n : ℕ	⊢ ∀ (a p : ℕ), a ≠ 0 → prime p → P a → P (p * a)
P : ℕ → Prop,	h₀ : P 0,	h₁ : P 1,	h : ∀ (p a : ℕ), nat.prime p → P a → P (p * a),	n : ℕ	⊢ ∀ (a p : ℕ), a ≠ 0 → prime p → P a → P (p * a)
P : ℕ → Prop,	h₀ : P 0,	h₁ : P 1,	h : ∀ (p a : ℕ), nat.prime p → P a → P (p * a),	n a p : ℕ,	ᾰ : a ≠ 0,	hp : prime p,	ha : P a	⊢ P (p * a)
⊢ ∀ {R : Type u_1} {G : Type u_2} [_inst_1 : comm_ring R] [_inst_2 : is_domain R] [_inst_3 : group G]	  [_inst_4 : fintype G] (f : G →* R),	    injective ⇑f →	    ∀ {n : ℕ},	      0 < n → ∀ (g₀ : G), {g ∈ univ | g ^ n = g₀}.card ≤ ⇑multiset.card (nth_roots n (⇑f g₀))
R : Type u_1,	G : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : group G,	_inst_4 : fintype G,	f : G →* R,	hf : injective ⇑f,	n : ℕ,	hn : 0 < n,	g₀ : G	⊢ {g ∈ univ | g ^ n = g₀}.card ≤ ⇑multiset.card (nth_roots n (⇑f g₀))
R : Type u_1,	G : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : group G,	_inst_4 : fintype G,	f : G →* R,	hf : injective ⇑f,	n : ℕ,	hn : 0 < n,	g₀ : G,	_inst : decidable_eq R	⊢ {g ∈ univ | g ^ n = g₀}.card ≤ ⇑multiset.card (nth_roots n (⇑f g₀))
R : Type u_1,	G : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : group G,	_inst_4 : fintype G,	f : G →* R,	hf : injective ⇑f,	n : ℕ,	hn : 0 < n,	g₀ : G,	_inst : decidable_eq R	⊢ {g ∈ univ | g ^ n = g₀}.card ≤ (nth_roots n (⇑f g₀)).to_finset.card
2 goals	R : Type u_1,	G : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : group G,	_inst_4 : fintype G,	f : G →* R,	hf : injective ⇑f,	n : ℕ,	hn : 0 < n,	g₀ : G,	_inst : decidable_eq R	⊢ ∀ (a : G), a ∈ {g ∈ univ | g ^ n = g₀} → ⇑f a ∈ (nth_roots n (⇑f g₀)).to_finset		R : Type u_1,	G : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : group G,	_inst_4 : fintype G,	f : G →* R,	hf : injective ⇑f,	n : ℕ,	hn : 0 < n,	g₀ : G,	_inst : decidable_eq R	⊢ ∀ (a₁ : G),	    a₁ ∈ {g ∈ univ | g ^ n = g₀} →	    ∀ (a₂ : G), a₂ ∈ {g ∈ univ | g ^ n = g₀} → ⇑f a₁ = ⇑f a₂ → a₁ = a₂
2 goals	R : Type u_1,	G : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : group G,	_inst_4 : fintype G,	f : G →* R,	hf : injective ⇑f,	n : ℕ,	hn : 0 < n,	g₀ : G,	_inst : decidable_eq R,	g : G,	hg : g ∈ {g ∈ univ | g ^ n = g₀}	⊢ ⇑f g ∈ (nth_roots n (⇑f g₀)).to_finset		R : Type u_1,	G : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : group G,	_inst_4 : fintype G,	f : G →* R,	hf : injective ⇑f,	n : ℕ,	hn : 0 < n,	g₀ : G,	_inst : decidable_eq R	⊢ ∀ (a₁ : G),	    a₁ ∈ {g ∈ univ | g ^ n = g₀} →	    ∀ (a₂ : G), a₂ ∈ {g ∈ univ | g ^ n = g₀} → ⇑f a₁ = ⇑f a₂ → a₁ = a₂
2 goals	R : Type u_1,	G : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : group G,	_inst_4 : fintype G,	f : G →* R,	hf : injective ⇑f,	n : ℕ,	hn : 0 < n,	g₀ : G,	_inst : decidable_eq R,	g : G,	hg : g ∈ univ ∧ g ^ n = g₀	⊢ ⇑f g ∈ (nth_roots n (⇑f g₀)).to_finset		R : Type u_1,	G : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : group G,	_inst_4 : fintype G,	f : G →* R,	hf : injective ⇑f,	n : ℕ,	hn : 0 < n,	g₀ : G,	_inst : decidable_eq R	⊢ ∀ (a₁ : G),	    a₁ ∈ {g ∈ univ | g ^ n = g₀} →	    ∀ (a₂ : G), a₂ ∈ {g ∈ univ | g ^ n = g₀} → ⇑f a₁ = ⇑f a₂ → a₁ = a₂
R : Type u_1,	G : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : group G,	_inst_4 : fintype G,	f : G →* R,	hf : injective ⇑f,	n : ℕ,	hn : 0 < n,	g₀ : G,	_inst : decidable_eq R	⊢ ∀ (a₁ : G),	    a₁ ∈ {g ∈ univ | g ^ n = g₀} →	    ∀ (a₂ : G), a₂ ∈ {g ∈ univ | g ^ n = g₀} → ⇑f a₁ = ⇑f a₂ → a₁ = a₂
R : Type u_1,	G : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : group G,	_inst_4 : fintype G,	f : G →* R,	hf : injective ⇑f,	n : ℕ,	hn : 0 < n,	g₀ : G,	_inst : decidable_eq R,	a₁ : G,	H : a₁ ∈ {g ∈ univ | g ^ n = g₀},	a₂ : G,	H_1 : a₂ ∈ {g ∈ univ | g ^ n = g₀},	ᾰ : ⇑f a₁ = ⇑f a₂	⊢ a₁ = a₂
R : Type u_1,	G : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : group G,	_inst_4 : fintype G,	f : G →* R,	hf : injective ⇑f,	n : ℕ,	hn : 0 < n,	g₀ : G,	_inst : decidable_eq R,	a₁ : G,	H : a₁ ∈ {g ∈ univ | g ^ n = g₀},	a₂ : G,	H_1 : a₂ ∈ {g ∈ univ | g ^ n = g₀},	ᾰ : ⇑f a₁ = ⇑f a₂	⊢ ⇑f a₁ = ⇑f a₂
⊢ ∀ {R : Type u_1} [_inst_1 : comm_ring R] [_inst_2 : is_domain R] (K : Type u_2) [_inst_3 : field K]	  [_inst_4 : algebra R K] [_inst_5 : is_fraction_ring R K] {L : Type u_3} [_inst_6 : field L] [_inst_7 : algebra K L]	  [_inst_8 : algebra R L] [_inst_9 : is_scalar_tower R K L] [_inst_10 : finite_dimensional K L],	    is_integrally_closed ↥(integral_closure R L)
R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	K : Type u_2,	_inst_3 : field K,	_inst_4 : algebra R K,	_inst_5 : is_fraction_ring R K,	L : Type u_3,	_inst_6 : field L,	_inst_7 : algebra K L,	_inst_8 : algebra R L,	_inst_9 : is_scalar_tower R K L,	_inst_10 : finite_dimensional K L	⊢ is_integrally_closed ↥(integral_closure R L)
R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	K : Type u_2,	_inst_3 : field K,	_inst_4 : algebra R K,	_inst_5 : is_fraction_ring R K,	L : Type u_3,	_inst_6 : field L,	_inst_7 : algebra K L,	_inst_8 : algebra R L,	_inst_9 : is_scalar_tower R K L,	_inst_10 : finite_dimensional K L,	_inst : is_fraction_ring ↥(integral_closure R L) L := is_fraction_ring_of_finite_extension K L	⊢ is_integrally_closed ↥(integral_closure R L)
⊢ ∀ {R : Type u_1} [_inst_1 : comm_ring R] {M : submonoid R} (S : Type u_2) [_inst_2 : comm_ring S]	  [_inst_3 : algebra R S] [_inst_5 : is_localization M S], is_noetherian_ring R → is_noetherian_ring S
R : Type u_1,	_inst_1 : comm_ring R,	M : submonoid R,	S : Type u_2,	_inst_2 : comm_ring S,	_inst_3 : algebra R S,	_inst_5 : is_localization M S,	h : is_noetherian_ring R	⊢ is_noetherian_ring S
R : Type u_1,	_inst_1 : comm_ring R,	M : submonoid R,	S : Type u_2,	_inst_2 : comm_ring S,	_inst_3 : algebra R S,	_inst_5 : is_localization M S,	h : well_founded gt	⊢ well_founded gt
⊢ ∀ {α : Type u_1} [_inst_1 : comm_monoid α] [_inst_2 : decidable_rel has_dvd.dvd] {a : α} (ha : finite a 1),	    (multiplicity a 1).get ha = 0
α : Type u_1,	_inst_1 : comm_monoid α,	_inst_2 : decidable_rel has_dvd.dvd,	a : α,	ha : finite a 1	⊢ (multiplicity a 1).get ha = 0
α : Type u_1,	_inst_1 : comm_monoid α,	_inst_2 : decidable_rel has_dvd.dvd,	a : α,	ha : finite a 1	⊢ 1 ∣ 1 ∧ ¬a ^ (0 + 1) ∣ 1
⊢ ∀ {α : Type u_1} [_inst_1 : comm_ring α] [_inst_2 : decidable_rel has_dvd.dvd] {p a b : α},	    multiplicity p a ≠ multiplicity p b → multiplicity p (a + b) = min (multiplicity p a) (multiplicity p b)
α : Type u_1,	_inst_1 : comm_ring α,	_inst_2 : decidable_rel has_dvd.dvd,	p a b : α,	h : multiplicity p a ≠ multiplicity p b	⊢ multiplicity p (a + b) = min (multiplicity p a) (multiplicity p b)
3 goals	α : Type u_1,	_inst_1 : comm_ring α,	_inst_2 : decidable_rel has_dvd.dvd,	p a b : α,	h : multiplicity p a ≠ multiplicity p b,	hab : multiplicity p a < multiplicity p b	⊢ multiplicity p (a + b) = min (multiplicity p a) (multiplicity p b)		α : Type u_1,	_inst_1 : comm_ring α,	_inst_2 : decidable_rel has_dvd.dvd,	p a b : α,	h : multiplicity p a ≠ multiplicity p b,	hab : multiplicity p a = multiplicity p b	⊢ multiplicity p (a + b) = min (multiplicity p a) (multiplicity p b)		α : Type u_1,	_inst_1 : comm_ring α,	_inst_2 : decidable_rel has_dvd.dvd,	p a b : α,	h : multiplicity p a ≠ multiplicity p b,	hab : multiplicity p b < multiplicity p a	⊢ multiplicity p (a + b) = min (multiplicity p a) (multiplicity p b)
3 goals	α : Type u_1,	_inst_1 : comm_ring α,	_inst_2 : decidable_rel has_dvd.dvd,	p a b : α,	h : multiplicity p a ≠ multiplicity p b,	hab : multiplicity p a < multiplicity p b	⊢ multiplicity p a ≤ multiplicity p b		α : Type u_1,	_inst_1 : comm_ring α,	_inst_2 : decidable_rel has_dvd.dvd,	p a b : α,	h : multiplicity p a ≠ multiplicity p b,	hab : multiplicity p a = multiplicity p b	⊢ multiplicity p (a + b) = min (multiplicity p a) (multiplicity p b)		α : Type u_1,	_inst_1 : comm_ring α,	_inst_2 : decidable_rel has_dvd.dvd,	p a b : α,	h : multiplicity p a ≠ multiplicity p b,	hab : multiplicity p b < multiplicity p a	⊢ multiplicity p (a + b) = min (multiplicity p a) (multiplicity p b)
2 goals	α : Type u_1,	_inst_1 : comm_ring α,	_inst_2 : decidable_rel has_dvd.dvd,	p a b : α,	h : multiplicity p a ≠ multiplicity p b,	hab : multiplicity p a = multiplicity p b	⊢ multiplicity p (a + b) = min (multiplicity p a) (multiplicity p b)		α : Type u_1,	_inst_1 : comm_ring α,	_inst_2 : decidable_rel has_dvd.dvd,	p a b : α,	h : multiplicity p a ≠ multiplicity p b,	hab : multiplicity p b < multiplicity p a	⊢ multiplicity p (a + b) = min (multiplicity p a) (multiplicity p b)
α : Type u_1,	_inst_1 : comm_ring α,	_inst_2 : decidable_rel has_dvd.dvd,	p a b : α,	h : multiplicity p a ≠ multiplicity p b,	hab : multiplicity p b < multiplicity p a	⊢ multiplicity p (a + b) = min (multiplicity p a) (multiplicity p b)
α : Type u_1,	_inst_1 : comm_ring α,	_inst_2 : decidable_rel has_dvd.dvd,	p a b : α,	h : multiplicity p a ≠ multiplicity p b,	hab : multiplicity p b < multiplicity p a	⊢ multiplicity p b ≤ multiplicity p a
⊢ ∀ {R : Type u_1} {M : Type u_2} [_inst_1 : comm_ring R] [_inst_2 : add_comm_group M] [_inst_3 : module R M]	  {I J : ideal R} {N : submodule R M}, N.fg → N ≤ I • N → I ≤ J.jacobson → N = J • N
R : Type u_1,	M : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	I J : ideal R,	N : submodule R M,	hN : N.fg,	hIN : N ≤ I • N,	hIjac : I ≤ J.jacobson	⊢ N = J • N
R : Type u_1,	M : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	I J : ideal R,	N : submodule R M,	hN : N.fg,	hIN : N ≤ I • N,	hIjac : I ≤ J.jacobson	⊢ N ≤ J • N
R : Type u_1,	M : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	I J : ideal R,	N : submodule R M,	hN : N.fg,	hIN : N ≤ I • N,	hIjac : I ≤ J.jacobson,	n : M,	hn : n ∈ N	⊢ n ∈ J • N
R : Type u_1,	M : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	I J : ideal R,	N : submodule R M,	hN : N.fg,	hIN : N ≤ I • N,	hIjac : I ≤ J.jacobson,	n : M,	hn : n ∈ N,	r : R,	hr : r - 1 ∈ I ∧ ∀ (n : M), n ∈ N → r • n = 0	⊢ n ∈ J • N
R : Type u_1,	M : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	I J : ideal R,	N : submodule R M,	hN : N.fg,	hIN : N ≤ I • N,	hIjac : I ≤ J.jacobson,	n : M,	hn : n ∈ N,	r : R,	hr : r - 1 ∈ I ∧ ∀ (n : M), n ∈ N → r • n = 0,	s : R,	hs : r * s - 1 ∈ J	⊢ n ∈ J • N
2 goals	R : Type u_1,	M : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	I J : ideal R,	N : submodule R M,	hN : N.fg,	hIN : N ≤ I • N,	hIjac : I ≤ J.jacobson,	n : M,	hn : n ∈ N,	r : R,	hr : r - 1 ∈ I ∧ ∀ (n : M), n ∈ N → r • n = 0,	s : R,	hs : r * s - 1 ∈ J	⊢ n = -(r * s - 1) • n		R : Type u_1,	M : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	I J : ideal R,	N : submodule R M,	hN : N.fg,	hIN : N ≤ I • N,	hIjac : I ≤ J.jacobson,	n : M,	hn : n ∈ N,	r : R,	hr : r - 1 ∈ I ∧ ∀ (n : M), n ∈ N → r • n = 0,	s : R,	hs : r * s - 1 ∈ J,	this : n = -(r * s - 1) • n	⊢ n ∈ J • N
R : Type u_1,	M : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	I J : ideal R,	N : submodule R M,	hN : N.fg,	hIN : N ≤ I • N,	hIjac : I ≤ J.jacobson,	n : M,	hn : n ∈ N,	r : R,	hr : r - 1 ∈ I ∧ ∀ (n : M), n ∈ N → r • n = 0,	s : R,	hs : r * s - 1 ∈ J,	this : n = -(r * s - 1) • n	⊢ n ∈ J • N
R : Type u_1,	M : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	I J : ideal R,	N : submodule R M,	hN : N.fg,	hIN : N ≤ I • N,	hIjac : I ≤ J.jacobson,	n : M,	hn : n ∈ N,	r : R,	hr : r - 1 ∈ I ∧ ∀ (n : M), n ∈ N → r • n = 0,	s : R,	hs : r * s - 1 ∈ J,	this : n = -(r * s - 1) • n	⊢ -(r * s - 1) • n ∈ J • N
⊢ ∀ {R : Type u} {x : R} [_inst_1 : ring R], is_nilpotent x → is_nilpotent (-x)
R : Type u,	x : R,	_inst_1 : ring R,	h : is_nilpotent x	⊢ is_nilpotent (-x)
R : Type u,	x : R,	_inst_1 : ring R,	n : ℕ,	hn : x ^ n = 0	⊢ is_nilpotent (-x)
R : Type u,	x : R,	_inst_1 : ring R,	n : ℕ,	hn : x ^ n = 0	⊢ (-x) ^ n = 0
⊢ ∀ {R : Type u} {M : Type w} [_inst_1 : comm_ring R] [_inst_3 : add_comm_group M] [_inst_4 : module R M]	  {f : M →ₗ[R] M} {p q : polynomial R}, (⇑(aeval f) p).ker ⊔ (⇑(aeval f) q).ker ≤ (⇑(aeval f) (p * q)).ker
R : Type u,	M : Type w,	_inst_1 : comm_ring R,	_inst_3 : add_comm_group M,	_inst_4 : module R M,	f : M →ₗ[R] M,	p q : polynomial R	⊢ (⇑(aeval f) p).ker ⊔ (⇑(aeval f) q).ker ≤ (⇑(aeval f) (p * q)).ker
R : Type u,	M : Type w,	_inst_1 : comm_ring R,	_inst_3 : add_comm_group M,	_inst_4 : module R M,	f : M →ₗ[R] M,	p q : polynomial R,	v : M,	hv : v ∈ (⇑(aeval f) p).ker ⊔ (⇑(aeval f) q).ker	⊢ v ∈ (⇑(aeval f) (p * q)).ker
R : Type u,	M : Type w,	_inst_1 : comm_ring R,	_inst_3 : add_comm_group M,	_inst_4 : module R M,	f : M →ₗ[R] M,	p q : polynomial R,	v : M,	hv : v ∈ (⇑(aeval f) p).ker ⊔ (⇑(aeval f) q).ker,	x : M,	hx : x ∈ (⇑(aeval f) p).ker,	y : M,	hy : y ∈ (⇑(aeval f) q).ker,	hxy : x + y = v	⊢ v ∈ (⇑(aeval f) (p * q)).ker
2 goals	R : Type u,	M : Type w,	_inst_1 : comm_ring R,	_inst_3 : add_comm_group M,	_inst_4 : module R M,	f : M →ₗ[R] M,	p q : polynomial R,	v : M,	hv : v ∈ (⇑(aeval f) p).ker ⊔ (⇑(aeval f) q).ker,	x : M,	hx : x ∈ (⇑(aeval f) p).ker,	y : M,	hy : y ∈ (⇑(aeval f) q).ker,	hxy : x + y = v	⊢ ⇑(⇑(aeval f) (p * q)) x = 0		R : Type u,	M : Type w,	_inst_1 : comm_ring R,	_inst_3 : add_comm_group M,	_inst_4 : module R M,	f : M →ₗ[R] M,	p q : polynomial R,	v : M,	hv : v ∈ (⇑(aeval f) p).ker ⊔ (⇑(aeval f) q).ker,	x : M,	hx : x ∈ (⇑(aeval f) p).ker,	y : M,	hy : y ∈ (⇑(aeval f) q).ker,	hxy : x + y = v,	h_eval_x : ⇑(⇑(aeval f) (p * q)) x = 0	⊢ v ∈ (⇑(aeval f) (p * q)).ker
R : Type u,	M : Type w,	_inst_1 : comm_ring R,	_inst_3 : add_comm_group M,	_inst_4 : module R M,	f : M →ₗ[R] M,	p q : polynomial R,	v : M,	hv : v ∈ (⇑(aeval f) p).ker ⊔ (⇑(aeval f) q).ker,	x : M,	hx : x ∈ (⇑(aeval f) p).ker,	y : M,	hy : y ∈ (⇑(aeval f) q).ker,	hxy : x + y = v,	h_eval_x : ⇑(⇑(aeval f) (p * q)) x = 0	⊢ v ∈ (⇑(aeval f) (p * q)).ker
2 goals	R : Type u,	M : Type w,	_inst_1 : comm_ring R,	_inst_3 : add_comm_group M,	_inst_4 : module R M,	f : M →ₗ[R] M,	p q : polynomial R,	v : M,	hv : v ∈ (⇑(aeval f) p).ker ⊔ (⇑(aeval f) q).ker,	x : M,	hx : x ∈ (⇑(aeval f) p).ker,	y : M,	hy : y ∈ (⇑(aeval f) q).ker,	hxy : x + y = v,	h_eval_x : ⇑(⇑(aeval f) (p * q)) x = 0	⊢ ⇑(⇑(aeval f) (p * q)) y = 0		R : Type u,	M : Type w,	_inst_1 : comm_ring R,	_inst_3 : add_comm_group M,	_inst_4 : module R M,	f : M →ₗ[R] M,	p q : polynomial R,	v : M,	hv : v ∈ (⇑(aeval f) p).ker ⊔ (⇑(aeval f) q).ker,	x : M,	hx : x ∈ (⇑(aeval f) p).ker,	y : M,	hy : y ∈ (⇑(aeval f) q).ker,	hxy : x + y = v,	h_eval_x : ⇑(⇑(aeval f) (p * q)) x = 0,	h_eval_y : ⇑(⇑(aeval f) (p * q)) y = 0	⊢ v ∈ (⇑(aeval f) (p * q)).ker
R : Type u,	M : Type w,	_inst_1 : comm_ring R,	_inst_3 : add_comm_group M,	_inst_4 : module R M,	f : M →ₗ[R] M,	p q : polynomial R,	v : M,	hv : v ∈ (⇑(aeval f) p).ker ⊔ (⇑(aeval f) q).ker,	x : M,	hx : x ∈ (⇑(aeval f) p).ker,	y : M,	hy : y ∈ (⇑(aeval f) q).ker,	hxy : x + y = v,	h_eval_x : ⇑(⇑(aeval f) (p * q)) x = 0,	h_eval_y : ⇑(⇑(aeval f) (p * q)) y = 0	⊢ v ∈ (⇑(aeval f) (p * q)).ker
⊢ ∀ {R : Type u} {σ : Type v} [_inst_1 : comm_ring R] {I : ideal R} {i : R},	    i ∈ I → ⇑((ideal.quotient.mk (ideal.map C I)).comp C) i = 0
R : Type u,	σ : Type v,	_inst_1 : comm_ring R,	I : ideal R,	i : R,	hi : i ∈ I	⊢ ⇑((ideal.quotient.mk (ideal.map C I)).comp C) i = 0
R : Type u,	σ : Type v,	_inst_1 : comm_ring R,	I : ideal R,	i : R,	hi : i ∈ I	⊢ ⇑C i ∈ ideal.map C I
⊢ ∀ (R : Type u_1) [_inst_1 : comm_ring R] [_inst_2 : char_zero R] (n ν : ℕ),	    ν ≤ n → eval 1 (⇑derivative^[n - ν] (bernstein_polynomial R n ν)) ≠ 0
R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : char_zero R,	n ν : ℕ,	h : ν ≤ n	⊢ eval 1 (⇑derivative^[n - ν] (bernstein_polynomial R n ν)) ≠ 0
R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : char_zero R,	n ν : ℕ,	h : ν ≤ n	⊢ ¬eval ν.succ (pochhammer ℕ (n - ν)) = 0
⊢ ∀ {R : Type u_1} [_inst_1 : comm_ring R] [_inst_2 : is_domain R] [_inst_3 : normalized_gcd_monoid R]	  {p : polynomial R}, p.is_primitive → p.prim_part = p
R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : normalized_gcd_monoid R,	p : polynomial R,	hp : p.is_primitive	⊢ p.prim_part = p
⊢ ∀ {R : Type u_1} [_inst_1 : comm_ring R] [_inst_2 : is_domain R] [_inst_3 : normalized_gcd_monoid R] {r : R},	    (⇑C r).content = ⇑normalize r
R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : normalized_gcd_monoid R,	r : R	⊢ (⇑C r).content = ⇑normalize r
R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : normalized_gcd_monoid R,	r : R	⊢ (⇑C r).support.gcd (⇑C r).coeff = ⇑normalize r
2 goals	R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : normalized_gcd_monoid R,	r : R,	h0 : r = 0	⊢ (⇑C r).support.gcd (⇑C r).coeff = ⇑normalize r		R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : normalized_gcd_monoid R,	r : R,	h0 : ¬r = 0	⊢ (⇑C r).support.gcd (⇑C r).coeff = ⇑normalize r
R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : normalized_gcd_monoid R,	r : R,	h0 : ¬r = 0	⊢ (⇑C r).support.gcd (⇑C r).coeff = ⇑normalize r
R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : normalized_gcd_monoid R,	r : R,	h0 : ¬r = 0,	h : (⇑C r).support = {0}	⊢ (⇑C r).support.gcd (⇑C r).coeff = ⇑normalize r
⊢ ∀ (R : Type u_1) [_inst_3 : comm_ring R] [_inst_4 : is_domain R], cyclotomic' 1 R = X - 1
R : Type u_1,	_inst_3 : comm_ring R,	_inst_4 : is_domain R	⊢ cyclotomic' 1 R = X - 1
⊢ ∀ (R : Type u) (S : Type v) (A : Type w) [_inst_1 : comm_semiring R] [_inst_2 : comm_semiring S]	  [_inst_3 : semiring A] [_inst_5 : algebra R S] [_inst_6 : algebra S A] [_inst_8 : algebra R A]	  [_inst_10 : is_scalar_tower R S A] (x : A) (p : polynomial R),	    ⇑(polynomial.aeval x) p = ⇑(polynomial.aeval x) (polynomial.map (algebra_map R S) p)
R : Type u,	S : Type v,	A : Type w,	_inst_1 : comm_semiring R,	_inst_2 : comm_semiring S,	_inst_3 : semiring A,	_inst_5 : algebra R S,	_inst_6 : algebra S A,	_inst_8 : algebra R A,	_inst_10 : is_scalar_tower R S A,	x : A,	p : polynomial R	⊢ ⇑(polynomial.aeval x) p = ⇑(polynomial.aeval x) (polynomial.map (algebra_map R S) p)
⊢ ∀ {R : Type u} {M : Type v} [_inst_1 : add_comm_group M] [_inst_2 : ring R] [_inst_3 : module R M]	  (S : submodule R M) [_inst_4 : S.is_principal], is_principal.generator S ∈ S
R : Type u,	M : Type v,	_inst_1 : add_comm_group M,	_inst_2 : ring R,	_inst_3 : module R M,	S : submodule R M,	_inst_4 : S.is_principal	⊢ is_principal.generator S ∈ S
R : Type u,	M : Type v,	_inst_1 : add_comm_group M,	_inst_2 : ring R,	_inst_3 : module R M,	S : submodule R M,	_inst_4 : S.is_principal	⊢ is_principal.generator S ∈ span R {is_principal.generator S}
⊢ ∀ {M : Type u_1} [_inst_1 : comm_monoid M] {k : ℕ} {ζ : M}, is_primitive_root ζ k → 0 < k → is_unit ζ
M : Type u_1,	_inst_1 : comm_monoid M,	k : ℕ,	ζ : M,	h : is_primitive_root ζ k,	h0 : 0 < k	⊢ is_unit ζ
M : Type u_1,	_inst_1 : comm_monoid M,	k : ℕ,	ζ : M,	h : is_primitive_root ζ k,	h0 : 0 < k	⊢ ζ * ζ ^ (k - 1) = 1
⊢ ∀ {R : Type u_5} [_inst_5 : comm_ring R] [_inst_6 : is_domain R], primitive_roots 1 R = {1}
R : Type u_5,	_inst_5 : comm_ring R,	_inst_6 : is_domain R	⊢ primitive_roots 1 R = {1}
R : Type u_5,	_inst_5 : comm_ring R,	_inst_6 : is_domain R	⊢ 1 ∈ primitive_roots 1 R ∧ ∀ (x : R), x ∈ primitive_roots 1 R → x = 1
2 goals	R : Type u_5,	_inst_5 : comm_ring R,	_inst_6 : is_domain R	⊢ 1 ∈ primitive_roots 1 R		R : Type u_5,	_inst_5 : comm_ring R,	_inst_6 : is_domain R	⊢ ∀ (x : R), x ∈ primitive_roots 1 R → x = 1
R : Type u_5,	_inst_5 : comm_ring R,	_inst_6 : is_domain R	⊢ ∀ (x : R), x ∈ primitive_roots 1 R → x = 1
R : Type u_5,	_inst_5 : comm_ring R,	_inst_6 : is_domain R,	x : R,	hx : x ∈ primitive_roots 1 R	⊢ x = 1
R : Type u_5,	_inst_5 : comm_ring R,	_inst_6 : is_domain R,	x : R,	hx : x = 1	⊢ x = 1
⊢ ∀ {α : Type u_1} [_inst_1 : cancel_comm_monoid_with_zero α] [_inst_2 : unique_factorization_monoid α]	  [dec : decidable_eq α] {a p : α},	    a ≠ 0 → ∀ (hp : irreducible p), p ∣ a → ⟨associates.mk p, _⟩ ∈ factors' a
α : Type u_1,	_inst_1 : cancel_comm_monoid_with_zero α,	_inst_2 : unique_factorization_monoid α,	dec : decidable_eq α,	a p : α,	ha0 : a ≠ 0,	hp : irreducible p,	hd : p ∣ a	⊢ ⟨associates.mk p, _⟩ ∈ factors' a
α : Type u_1,	_inst_1 : cancel_comm_monoid_with_zero α,	_inst_2 : unique_factorization_monoid α,	dec : decidable_eq α,	a p : α,	ha0 : a ≠ 0,	hp : irreducible p,	hd : p ∣ a,	q : α,	hq : q ∈ factors a,	hpq : associated p q	⊢ ⟨associates.mk p, _⟩ ∈ factors' a
α : Type u_1,	_inst_1 : cancel_comm_monoid_with_zero α,	_inst_2 : unique_factorization_monoid α,	dec : decidable_eq α,	a p : α,	ha0 : a ≠ 0,	hp : irreducible p,	hd : p ∣ a,	q : α,	hq : q ∈ factors a,	hpq : associated p q	⊢ ∃ (a_1 : α) (h : a_1 ∈ factors a), ⟨associates.mk a_1, _⟩ = ⟨associates.mk p, _⟩
α : Type u_1,	_inst_1 : cancel_comm_monoid_with_zero α,	_inst_2 : unique_factorization_monoid α,	dec : decidable_eq α,	a p : α,	ha0 : a ≠ 0,	hp : irreducible p,	hd : p ∣ a,	q : α,	hq : q ∈ factors a,	hpq : associated p q	⊢ ∃ (h : q ∈ factors a), ⟨associates.mk q, _⟩ = ⟨associates.mk p, _⟩
α : Type u_1,	_inst_1 : cancel_comm_monoid_with_zero α,	_inst_2 : unique_factorization_monoid α,	dec : decidable_eq α,	a p : α,	ha0 : a ≠ 0,	hp : irreducible p,	hd : p ∣ a,	q : α,	hq : q ∈ factors a,	hpq : associated p q	⊢ ⟨associates.mk q, _⟩ = ⟨associates.mk p, _⟩
⊢ ∀ {α : Type u_1} [_inst_1 : cancel_comm_monoid_with_zero α]	  [dec_irr : Π (p : associates α), decidable (irreducible p)] [_inst_2 : unique_factorization_monoid α]	  [dec : decidable_eq α] [dec' : decidable_eq (associates α)] {a p : α},	    a ≠ 0 → irreducible p → p ∣ a → associates.mk p ∈ (associates.mk a).factors
α : Type u_1,	_inst_1 : cancel_comm_monoid_with_zero α,	dec_irr : Π (p : associates α), decidable (irreducible p),	_inst_2 : unique_factorization_monoid α,	dec : decidable_eq α,	dec' : decidable_eq (associates α),	a p : α,	ha0 : a ≠ 0,	hp : irreducible p,	hd : p ∣ a	⊢ associates.mk p ∈ (associates.mk a).factors
α : Type u_1,	_inst_1 : cancel_comm_monoid_with_zero α,	dec_irr : Π (p : associates α), decidable (irreducible p),	_inst_2 : unique_factorization_monoid α,	dec : decidable_eq α,	dec' : decidable_eq (associates α),	a p : α,	ha0 : a ≠ 0,	hp : irreducible p,	hd : p ∣ a	⊢ associates.mk p ∈ ↑(factors' a)
⊢ ∀ (p : ℕ) {R : Type u_1} [hp : fact (nat.prime p)] [_inst_1 : comm_ring R], ⇑(teichmuller p) 0 = 0
p : ℕ,	R : Type u_1,	hp : fact (nat.prime p),	_inst_1 : comm_ring R	⊢ ⇑(teichmuller p) 0 = 0
2 goals	p : ℕ,	R : Type u_1,	hp : fact (nat.prime p),	_inst_1 : comm_ring R	⊢ (⇑(teichmuller p) 0).coeff 0 = 0.coeff 0		p : ℕ,	R : Type u_1,	hp : fact (nat.prime p),	_inst_1 : comm_ring R,	n : ℕ	⊢ (⇑(teichmuller p) 0).coeff n.succ = 0.coeff n.succ
p : ℕ,	R : Type u_1,	hp : fact (nat.prime p),	_inst_1 : comm_ring R,	n : ℕ	⊢ (⇑(teichmuller p) 0).coeff n.succ = 0.coeff n.succ
p : ℕ,	R : Type u_1,	hp : fact (nat.prime p),	_inst_1 : comm_ring R,	n : ℕ	⊢ (⇑(teichmuller p) 0).coeff n.succ = 0
⊢ ∀ {p : ℕ} {R : Type u_1} {S : Type u_2} [hp : fact (nat.prime p)] [_inst_1 : comm_ring R]	  [_inst_2 : comm_ring S] (f : R →+* S) (x : witt_vector p R),	    ⇑(map f) (⇑verschiebung x) = ⇑verschiebung (⇑(map f) x)
p : ℕ,	R : Type u_1,	S : Type u_2,	hp : fact (nat.prime p),	_inst_1 : comm_ring R,	_inst_2 : comm_ring S,	f : R →+* S,	x : witt_vector p R	⊢ ⇑(map f) (⇑verschiebung x) = ⇑verschiebung (⇑(map f) x)
2 goals	p : ℕ,	R : Type u_1,	S : Type u_2,	hp : fact (nat.prime p),	_inst_1 : comm_ring R,	_inst_2 : comm_ring S,	f : R →+* S,	x : witt_vector p R	⊢ (⇑(map f) (⇑verschiebung x)).coeff 0 = (⇑verschiebung (⇑(map f) x)).coeff 0		p : ℕ,	R : Type u_1,	S : Type u_2,	hp : fact (nat.prime p),	_inst_1 : comm_ring R,	_inst_2 : comm_ring S,	f : R →+* S,	x : witt_vector p R,	n : ℕ	⊢ (⇑(map f) (⇑verschiebung x)).coeff n.succ = (⇑verschiebung (⇑(map f) x)).coeff n.succ
p : ℕ,	R : Type u_1,	S : Type u_2,	hp : fact (nat.prime p),	_inst_1 : comm_ring R,	_inst_2 : comm_ring S,	f : R →+* S,	x : witt_vector p R,	n : ℕ	⊢ (⇑(map f) (⇑verschiebung x)).coeff n.succ = (⇑verschiebung (⇑(map f) x)).coeff n.succ
⊢ ∀ {α : Type u}, 2 ≤ mk α ↔ ∃ (x y : α), x ≠ y
α : Type u	⊢ 2 ≤ mk α ↔ ∃ (x y : α), x ≠ y
2 goals	α : Type u	⊢ 2 ≤ mk α → (∃ (x y : α), x ≠ y)		α : Type u	⊢ (∃ (x y : α), x ≠ y) → 2 ≤ mk α
2 goals	α : Type u,	f : punit ⊕ punit ↪ α	⊢ ∃ (x y : α), x ≠ y		α : Type u	⊢ (∃ (x y : α), x ≠ y) → 2 ≤ mk α
2 goals	α : Type u,	f : punit ⊕ punit ↪ α	⊢ ⇑f (inl punit.star) ≠ ⇑f (inr punit.star)		α : Type u	⊢ (∃ (x y : α), x ≠ y) → 2 ≤ mk α
2 goals	α : Type u,	f : punit ⊕ punit ↪ α,	h : ⇑f (inl punit.star) = ⇑f (inr punit.star)	⊢ false		α : Type u	⊢ (∃ (x y : α), x ≠ y) → 2 ≤ mk α
α : Type u	⊢ (∃ (x y : α), x ≠ y) → 2 ≤ mk α
α : Type u,	x y : α,	h : x ≠ y	⊢ 2 ≤ mk α
α : Type u,	x y : α,	h : x ≠ y,	h' : ¬2 ≤ mk α	⊢ false
α : Type u,	x y : α,	h : x ≠ y,	h' : subsingleton α	⊢ false
α : Type u,	x y : α,	h : x ≠ y,	h' : subsingleton α	⊢ x = y
⊢ ∀ {a b : cardinal}, a < b.succ ↔ a ≤ b
a b : cardinal	⊢ a < b.succ ↔ a ≤ b
⊢ ∀ (c : cardinal), c + 1 ≤ c.succ
c : cardinal	⊢ c + 1 ≤ c.succ
c : cardinal,	α : Type u	⊢ quot.mk setoid.r α < succ (quot.mk setoid.r α) → quot.mk setoid.r α + 1 ≤ succ (quot.mk setoid.r α)
c : cardinal,	α β : Type u,	h : quot.mk setoid.r α < quot.mk setoid.r β	⊢ quot.mk setoid.r α + 1 ≤ quot.mk setoid.r β
c : cardinal,	α β : Type u,	h : quot.mk setoid.r α < quot.mk setoid.r β,	f : α ↪ β	⊢ quot.mk setoid.r α + 1 ≤ quot.mk setoid.r β
c : cardinal,	α β : Type u,	h : quot.mk setoid.r α < quot.mk setoid.r β,	f : α ↪ β,	this : ¬surjective ⇑f	⊢ quot.mk setoid.r α + 1 ≤ quot.mk setoid.r β
c : cardinal,	α β : Type u,	h : quot.mk setoid.r α < quot.mk setoid.r β,	f : α ↪ β,	this : ¬surjective ⇑f,	b : β,	nex : ¬∃ (a : α), ⇑f a = b	⊢ quot.mk setoid.r α + 1 ≤ quot.mk setoid.r β
2 goals	c : cardinal,	α β : Type u,	h : quot.mk setoid.r α < quot.mk setoid.r β,	f : α ↪ β,	this : ¬surjective ⇑f,	b : β,	nex : ¬∃ (a : α), ⇑f a = b	⊢ punit → β		c : cardinal,	α β : Type u,	h : quot.mk setoid.r α < quot.mk setoid.r β,	f : α ↪ β,	this : ¬surjective ⇑f,	b : β,	nex : ¬∃ (a : α), ⇑f a = b	⊢ injective (sum.rec ⇑f ?m_1)
c : cardinal,	α β : Type u,	h : quot.mk setoid.r α < quot.mk setoid.r β,	f : α ↪ β,	this : ¬surjective ⇑f,	b : β,	nex : ¬∃ (a : α), ⇑f a = b	⊢ injective (sum.rec ⇑f (λ (_x : punit), b))
c : cardinal,	α β : Type u,	h : quot.mk setoid.r α < quot.mk setoid.r β,	f : α ↪ β,	this : ¬surjective ⇑f,	b : β,	nex : ¬∃ (a : α), ⇑f a = b,	a b : α ⊕ punit,	h : sum.rec ⇑f (λ (_x : punit), b) a = sum.rec ⇑f (λ (_x : punit), b) b	⊢ a = b
2 goals	c : cardinal,	α β : Type u,	h : quot.mk setoid.r α < quot.mk setoid.r β,	f : α ↪ β,	this : ¬surjective ⇑f,	b : β,	nex : ¬∃ (a : α), ⇑f a = b,	b : α ⊕ punit,	a : α,	h : sum.rec ⇑f (λ (_x : punit), b) (inl a) = sum.rec ⇑f (λ (_x : punit), b) b	⊢ inl a = b		c : cardinal,	α β : Type u,	h : quot.mk setoid.r α < quot.mk setoid.r β,	f : α ↪ β,	this : ¬surjective ⇑f,	b : β,	nex : ¬∃ (a : α), ⇑f a = b,	b : α ⊕ punit,	h : sum.rec ⇑f (λ (_x : punit), b) (inr punit.star) = sum.rec ⇑f (λ (_x : punit), b) b	⊢ inr punit.star = b
3 goals	c : cardinal,	α β : Type u,	h : quot.mk setoid.r α < quot.mk setoid.r β,	f : α ↪ β,	this : ¬surjective ⇑f,	b : β,	nex : ¬∃ (a : α), ⇑f a = b,	a b : α,	h : sum.rec ⇑f (λ (_x : punit), b) (inl a) = sum.rec ⇑f (λ (_x : punit), b) (inl b)	⊢ inl a = inl b		c : cardinal,	α β : Type u,	h : quot.mk setoid.r α < quot.mk setoid.r β,	f : α ↪ β,	this : ¬surjective ⇑f,	b : β,	nex : ¬∃ (a : α), ⇑f a = b,	a : α,	h : sum.rec ⇑f (λ (_x : punit), b) (inl a) = sum.rec ⇑f (λ (_x : punit), b) (inr punit.star)	⊢ inl a = inr punit.star		c : cardinal,	α β : Type u,	h : quot.mk setoid.r α < quot.mk setoid.r β,	f : α ↪ β,	this : ¬surjective ⇑f,	b : β,	nex : ¬∃ (a : α), ⇑f a = b,	b : α ⊕ punit,	h : sum.rec ⇑f (λ (_x : punit), b) (inr punit.star) = sum.rec ⇑f (λ (_x : punit), b) b	⊢ inr punit.star = b
2 goals	c : cardinal,	α β : Type u,	h : quot.mk setoid.r α < quot.mk setoid.r β,	f : α ↪ β,	this : ¬surjective ⇑f,	b : β,	nex : ¬∃ (a : α), ⇑f a = b,	a : α,	h : sum.rec ⇑f (λ (_x : punit), b) (inl a) = sum.rec ⇑f (λ (_x : punit), b) (inr punit.star)	⊢ inl a = inr punit.star		c : cardinal,	α β : Type u,	h : quot.mk setoid.r α < quot.mk setoid.r β,	f : α ↪ β,	this : ¬surjective ⇑f,	b : β,	nex : ¬∃ (a : α), ⇑f a = b,	b : α ⊕ punit,	h : sum.rec ⇑f (λ (_x : punit), b) (inr punit.star) = sum.rec ⇑f (λ (_x : punit), b) b	⊢ inr punit.star = b
c : cardinal,	α β : Type u,	h : quot.mk setoid.r α < quot.mk setoid.r β,	f : α ↪ β,	this : ¬surjective ⇑f,	b : β,	nex : ¬∃ (a : α), ⇑f a = b,	b : α ⊕ punit,	h : sum.rec ⇑f (λ (_x : punit), b) (inr punit.star) = sum.rec ⇑f (λ (_x : punit), b) b	⊢ inr punit.star = b
2 goals	c : cardinal,	α β : Type u,	h : quot.mk setoid.r α < quot.mk setoid.r β,	f : α ↪ β,	this : ¬surjective ⇑f,	b : β,	nex : ¬∃ (a : α), ⇑f a = b,	b : α,	h : sum.rec ⇑f (λ (_x : punit), b) (inr punit.star) = sum.rec ⇑f (λ (_x : punit), b) (inl b)	⊢ inr punit.star = inl b		c : cardinal,	α β : Type u,	h : quot.mk setoid.r α < quot.mk setoid.r β,	f : α ↪ β,	this : ¬surjective ⇑f,	b : β,	nex : ¬∃ (a : α), ⇑f a = b,	h : sum.rec ⇑f (λ (_x : punit), b) (inr punit.star) = sum.rec ⇑f (λ (_x : punit), b) (inr punit.star)	⊢ inr punit.star = inr punit.star
c : cardinal,	α β : Type u,	h : quot.mk setoid.r α < quot.mk setoid.r β,	f : α ↪ β,	this : ¬surjective ⇑f,	b : β,	nex : ¬∃ (a : α), ⇑f a = b,	h : sum.rec ⇑f (λ (_x : punit), b) (inr punit.star) = sum.rec ⇑f (λ (_x : punit), b) (inr punit.star)	⊢ inr punit.star = inr punit.star
⊢ ∀ {ι : Type u_1} (f : ι → cardinal) (i : ι), f i ≤ sup f
ι : Type u_1,	f : ι → cardinal,	i : ι	⊢ f i ≤ sup f
ι : Type u_1,	f : ι → cardinal,	i : ι	⊢ f i ≤ min _ subtype.val
4 goals	ι : Type u_1,	f : ι → cardinal,	i : ι,	c : ?m_1,	hc : min ?m_2 ?m_3 = ?m_3 c	⊢ f i ≤ min _ subtype.val		ι : Type u_1,	f : ι → cardinal,	i : ι	⊢ Type ?		ι : Type u_1,	f : ι → cardinal,	i : ι	⊢ nonempty ?m_1		ι : Type u_1,	f : ι → cardinal,	i : ι	⊢ ?m_1 → cardinal
ι : Type u_1,	f : ι → cardinal,	i : ι,	c : {c // ∀ (i : ι), f i ≤ c},	hc : min _ subtype.val = c.val	⊢ f i ≤ c.val
⊢ ∀ {c : cardinal}, bit0 c < omega ↔ c < omega
c : cardinal	⊢ bit0 c < omega ↔ c < omega
⊢ ∀ {x y : pgame} {i : x.right_moves} {j : y.right_moves},	    (x * y).move_left (⇑((x.left_moves_mul y).symm) (sum.inr (i, j))) =	      x.move_right i * y + x * y.move_right j - x.move_right i * y.move_right j
x y : pgame,	i : x.right_moves,	j : y.right_moves	⊢ (x * y).move_left (⇑((x.left_moves_mul y).symm) (sum.inr (i, j))) =	    x.move_right i * y + x * y.move_right j - x.move_right i * y.move_right j
y : pgame,	j : y.right_moves,	x_α x_β : Type u_1,	x_ᾰ : x_α → pgame,	x_ᾰ_1 : x_β → pgame,	i : (mk x_α x_β x_ᾰ x_ᾰ_1).right_moves	⊢ (mk x_α x_β x_ᾰ x_ᾰ_1 * y).move_left	      (⇑(((mk x_α x_β x_ᾰ x_ᾰ_1).left_moves_mul y).symm) (sum.inr (i, j))) =	    (mk x_α x_β x_ᾰ x_ᾰ_1).move_right i * y + mk x_α x_β x_ᾰ x_ᾰ_1 * y.move_right j -	      (mk x_α x_β x_ᾰ x_ᾰ_1).move_right i * y.move_right j
x_α x_β : Type u_1,	x_ᾰ : x_α → pgame,	x_ᾰ_1 : x_β → pgame,	i : (mk x_α x_β x_ᾰ x_ᾰ_1).right_moves,	y_α y_β : Type u_1,	y_ᾰ : y_α → pgame,	y_ᾰ_1 : y_β → pgame,	j : (mk y_α y_β y_ᾰ y_ᾰ_1).right_moves	⊢ (mk x_α x_β x_ᾰ x_ᾰ_1 * mk y_α y_β y_ᾰ y_ᾰ_1).move_left	      (⇑(((mk x_α x_β x_ᾰ x_ᾰ_1).left_moves_mul (mk y_α y_β y_ᾰ y_ᾰ_1)).symm) (sum.inr (i, j))) =	    (mk x_α x_β x_ᾰ x_ᾰ_1).move_right i * mk y_α y_β y_ᾰ y_ᾰ_1 +	        mk x_α x_β x_ᾰ x_ᾰ_1 * (mk y_α y_β y_ᾰ y_ᾰ_1).move_right j -	      (mk x_α x_β x_ᾰ x_ᾰ_1).move_right i * (mk y_α y_β y_ᾰ y_ᾰ_1).move_right j
⊢ ∀ {G : pgame},	    G.impartial_aux ↔	      G.equiv (-G) ∧	        (∀ (i : G.left_moves), (G.move_left i).impartial_aux) ∧	          ∀ (j : G.right_moves), (G.move_right j).impartial_aux
G : pgame	⊢ G.impartial_aux ↔	    G.equiv (-G) ∧	      (∀ (i : G.left_moves), (G.move_left i).impartial_aux) ∧	        ∀ (j : G.right_moves), (G.move_right j).impartial_aux
2 goals	G : pgame	⊢ G.impartial_aux →	  (G.equiv (-G) ∧	     (∀ (i : G.left_moves), (G.move_left i).impartial_aux) ∧	       ∀ (j : G.right_moves), (G.move_right j).impartial_aux)		G : pgame	⊢ (G.equiv (-G) ∧	     (∀ (i : G.left_moves), (G.move_left i).impartial_aux) ∧	       ∀ (j : G.right_moves), (G.move_right j).impartial_aux) →	  G.impartial_aux
2 goals	G : pgame,	hi : G.impartial_aux	⊢ G.equiv (-G) ∧	    (∀ (i : G.left_moves), (G.move_left i).impartial_aux) ∧ ∀ (j : G.right_moves), (G.move_right j).impartial_aux		G : pgame	⊢ (G.equiv (-G) ∧	     (∀ (i : G.left_moves), (G.move_left i).impartial_aux) ∧	       ∀ (j : G.right_moves), (G.move_right j).impartial_aux) →	  G.impartial_aux
2 goals	G : pgame,	hi :	  G.equiv (-G) ∧	    (∀ (i : G.left_moves), (G.move_left i).impartial_aux) ∧ ∀ (j : G.right_moves), (G.move_right j).impartial_aux	⊢ G.equiv (-G) ∧	    (∀ (i : G.left_moves), (G.move_left i).impartial_aux) ∧ ∀ (j : G.right_moves), (G.move_right j).impartial_aux		G : pgame	⊢ (G.equiv (-G) ∧	     (∀ (i : G.left_moves), (G.move_left i).impartial_aux) ∧	       ∀ (j : G.right_moves), (G.move_right j).impartial_aux) →	  G.impartial_aux
G : pgame	⊢ (G.equiv (-G) ∧	     (∀ (i : G.left_moves), (G.move_left i).impartial_aux) ∧	       ∀ (j : G.right_moves), (G.move_right j).impartial_aux) →	  G.impartial_aux
G : pgame,	hi :	  G.equiv (-G) ∧	    (∀ (i : G.left_moves), (G.move_left i).impartial_aux) ∧ ∀ (j : G.right_moves), (G.move_right j).impartial_aux	⊢ G.impartial_aux
G : pgame,	hi :	  G.equiv (-G) ∧	    (∀ (i : G.left_moves), (G.move_left i).impartial_aux) ∧ ∀ (j : G.right_moves), (G.move_right j).impartial_aux	⊢ G.equiv (-G) ∧	    (∀ (i : G.left_moves), (G.move_left i).impartial_aux) ∧ ∀ (j : G.right_moves), (G.move_right j).impartial_aux
⊢ ∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {r : α → α → Prop} {s : β → β → Prop}	  {t : γ → γ → Prop} [_inst_1 : is_well_order γ t],	    r ≃r s → ∀ (f : principal_seg r t) (g : principal_seg s t), f.top = g.top
α : Type u_1,	β : Type u_2,	γ : Type u_3,	r : α → α → Prop,	s : β → β → Prop,	t : γ → γ → Prop,	_inst_1 : is_well_order γ t,	e : r ≃r s,	f : principal_seg r t,	g : principal_seg s t	⊢ f.top = g.top
α : Type u_1,	β : Type u_2,	γ : Type u_3,	r : α → α → Prop,	s : β → β → Prop,	t : γ → γ → Prop,	_inst_1 : is_well_order γ t,	e : r ≃r s,	f : principal_seg r t,	g : principal_seg s t	⊢ (equiv_lt e g).top = g.top
⊢ ∀ {x : pgame}, x.numeric → ∀ (j : x.right_moves), (x.move_right j).numeric
x : pgame,	o : x.numeric,	j : x.right_moves	⊢ (x.move_right j).numeric
xl xr : Type u_1,	xL : xl → pgame,	xR : xr → pgame,	o : (mk xl xr xL xR).numeric,	j : (mk xl xr xL xR).right_moves	⊢ ((mk xl xr xL xR).move_right j).numeric
⊢ ∀ {α : Type u_1} [_inst_1 : add_comm_monoid α] (l : ℕ) (r : α) (tl : ℕ) (tr t : α),	    l = tl → r = tr → abel.smul tl tr = t → abel.smul l r = t
α : Type u_1,	_inst_1 : add_comm_monoid α,	l : ℕ,	r : α,	tl : ℕ,	tr t : α,	prl : l = tl,	prr : r = tr,	prt : abel.smul tl tr = t	⊢ abel.smul l r = t
⊢ ∀ {x y : unit}, x = y
x y : unit	⊢ x = y
y : unit	⊢ punit.star = y
⊢ punit.star = punit.star
⊢ ∀ {x y : punit}, x = y
x y : punit	⊢ x = y
y : punit	⊢ punit.star = y
⊢ punit.star = punit.star
⊢ ∀ {α : Type u_1} [_inst_1 : ordered_semiring α] {a b : α}, a ≤ 0 → b = 0 → a + b ≤ 0
α : Type u_1,	_inst_1 : ordered_semiring α,	a b : α,	ha : a ≤ 0,	hb : b = 0	⊢ a + b ≤ 0
⊢ ∀ (n : ℕ), norm_fin.normalize_fin (n + 1) 0 0
n : ℕ	⊢ norm_fin.normalize_fin (n + 1) 0 0
n : ℕ	⊢ 0.val = 0 % (n + 1)
⊢ ∀ {n : ℕ} {a : fin n} {a' b : ℕ},	    norm_fin.normalize_fin_lt n a a' → a' + 1 = b → norm_fin.normalize_fin_lt n.succ a.succ b
n : ℕ,	a : fin n,	a' b : ℕ,	h : norm_fin.normalize_fin_lt n a a',	e : a' + 1 = b	⊢ norm_fin.normalize_fin_lt n.succ a.succ b
⊢ ∀ {α : Type u_1} [_inst_1 : division_ring α] (a b b' c d : α),	    b ≠ 0 → b * b' = d → a * b' = c → a / b * d = c
α : Type u_1,	_inst_1 : division_ring α,	a b b' c d : α,	h₀ : b ≠ 0,	h₁ : b * b' = d,	h₂ : a * b' = c	⊢ a / b * d = c
⊢ ∀ {α : Type u_1} [_inst_1 : has_add α] (l r tl tr t : α), l = tl → r = tr → tl + tr = t → l + r = t
α : Type u_1,	_inst_1 : has_add α,	l r tl tr t : α,	prl : l = tl,	prr : r = tr,	prt : tl + tr = t	⊢ l + r = t
⊢ ∀ {α : Type u_1} [_inst_1 : comm_semiring α] (a₁ x : α) (n₁ : ℕ) (b₁ a₂ : α) (n₂ : ℕ)	  (b₂ aa haa ab bb t : α),	    ring.horner a₁ x n₁ b₁ * a₂ = aa →	    ring.horner aa x n₂ 0 = haa →	    a₁ * b₂ = ab →	    b₁ * b₂ = bb →	    haa + ring.horner ab x n₁ bb = t → ring.horner a₁ x n₁ b₁ * ring.horner a₂ x n₂ b₂ = t
α : Type u_1,	_inst_1 : comm_semiring α,	a₁ x : α,	n₁ : ℕ,	b₁ a₂ : α,	n₂ : ℕ,	b₂ aa haa ab bb t : α,	h₁ : ring.horner a₁ x n₁ b₁ * a₂ = aa,	h₂ : ring.horner aa x n₂ 0 = haa,	h₃ : a₁ * b₂ = ab,	h₄ : b₁ * b₂ = bb,	H : haa + ring.horner ab x n₁ bb = t	⊢ ring.horner a₁ x n₁ b₁ * ring.horner a₂ x n₂ b₂ = t
α : Type u_1,	_inst_1 : comm_semiring α,	a₁ x : α,	n₁ : ℕ,	b₁ a₂ : α,	n₂ : ℕ,	b₂ aa haa ab bb t : α,	h₁ : ring.horner a₁ x n₁ b₁ * a₂ = aa,	h₂ : ring.horner aa x n₂ 0 = haa,	h₃ : a₁ * b₂ = ab,	h₄ : b₁ * b₂ = bb,	H : haa + ring.horner ab x n₁ bb = t	⊢ ring.horner a₁ x n₁ b₁ * ring.horner a₂ x n₂ b₂ =	    ring.horner (ring.horner a₁ x n₁ b₁ * a₂) x n₂ 0 + ring.horner (a₁ * b₂) x n₁ (b₁ * b₂)
⊢ ∀ {α : Type u_1} [_inst_1 : comm_semiring α] (a x : α) (n : ℕ) (b : α), ring.horner a x n b = x ^ n * a + b
α : Type u_1,	_inst_1 : comm_semiring α,	a x : α,	n : ℕ,	b : α	⊢ ring.horner a x n b = x ^ n * a + b
⊢ ∀ {α : Type u} [_inst_1 : has_sizeof α] {xs ys ys' : list α},	    sizeof ys < sizeof ys' → sizeof (xs ++ ys) < sizeof (xs ++ ys')
α : Type u,	_inst_1 : has_sizeof α,	xs ys ys' : list α,	h : sizeof ys < sizeof ys'	⊢ sizeof (xs ++ ys) < sizeof (xs ++ ys')
2 goals	case list.nil	α : Type u,	_inst_1 : has_sizeof α,	ys ys' : list α,	h : sizeof ys < sizeof ys'	⊢ sizeof (list.nil ++ ys) < sizeof (list.nil ++ ys')		case list.cons	α : Type u,	_inst_1 : has_sizeof α,	ys ys' : list α,	h : sizeof ys < sizeof ys',	xs_hd : α,	xs_tl : list α,	xs_ih : sizeof (xs_tl ++ ys) < sizeof (xs_tl ++ ys')	⊢ sizeof (xs_hd :: xs_tl ++ ys) < sizeof (xs_hd :: xs_tl ++ ys')
case list.cons	α : Type u,	_inst_1 : has_sizeof α,	ys ys' : list α,	h : sizeof ys < sizeof ys',	xs_hd : α,	xs_tl : list α,	xs_ih : sizeof (xs_tl ++ ys) < sizeof (xs_tl ++ ys')	⊢ sizeof (xs_hd :: xs_tl ++ ys) < sizeof (xs_hd :: xs_tl ++ ys')
case list.cons	α : Type u,	_inst_1 : has_sizeof α,	ys ys' : list α,	h : sizeof ys < sizeof ys',	xs_hd : α,	xs_tl : list α,	xs_ih : sizeof (xs_tl ++ ys) < sizeof (xs_tl ++ ys')	⊢ (xs_hd :: (xs_tl ++ ys)).sizeof < (xs_hd :: (xs_tl ++ ys')).sizeof
case list.cons	α : Type u,	_inst_1 : has_sizeof α,	ys ys' : list α,	h : sizeof ys < sizeof ys',	xs_hd : α,	xs_tl : list α,	xs_ih : sizeof (xs_tl ++ ys) < sizeof (xs_tl ++ ys')	⊢ (xs_tl ++ ys).sizeof < (xs_tl ++ ys').sizeof
⊢ ∀ {α : Type u_1} [_inst_1 : topological_space α] {s t : set α}, is_Gδ s → is_Gδ t → is_Gδ (s ∪ t)
α : Type u_1,	_inst_1 : topological_space α,	s t : set α,	hs : is_Gδ s,	ht : is_Gδ t	⊢ is_Gδ (s ∪ t)
α : Type u_1,	_inst_1 : topological_space α,	t : set α,	ht : is_Gδ t,	S : set (set α),	Sopen : ∀ (t : set α), t ∈ S → is_open t,	Scount : S.countable	⊢ is_Gδ (⋂₀ S ∪ t)
α : Type u_1,	_inst_1 : topological_space α,	S : set (set α),	Sopen : ∀ (t : set α), t ∈ S → is_open t,	Scount : S.countable,	T : set (set α),	Topen : ∀ (t : set α), t ∈ T → is_open t,	Tcount : T.countable	⊢ is_Gδ (⋂₀ S ∪ ⋂₀ T)
α : Type u_1,	_inst_1 : topological_space α,	S : set (set α),	Sopen : ∀ (t : set α), t ∈ S → is_open t,	Scount : S.countable,	T : set (set α),	Topen : ∀ (t : set α), t ∈ T → is_open t,	Tcount : T.countable	⊢ is_Gδ (⋂ (p : set α × set α) (H : p ∈ S ×ˢ T), p.fst ∪ p.snd)
α : Type u_1,	_inst_1 : topological_space α,	S : set (set α),	Sopen : ∀ (t : set α), t ∈ S → is_open t,	Scount : S.countable,	T : set (set α),	Topen : ∀ (t : set α), t ∈ T → is_open t,	Tcount : T.countable	⊢ ∀ (i : set α × set α), i ∈ S ×ˢ T → is_open (i.fst ∪ i.snd)
α : Type u_1,	_inst_1 : topological_space α,	S : set (set α),	Sopen : ∀ (t : set α), t ∈ S → is_open t,	Scount : S.countable,	T : set (set α),	Topen : ∀ (t : set α), t ∈ T → is_open t,	Tcount : T.countable,	a b : set α,	hab : (a, b) ∈ S ×ˢ T	⊢ is_open ((a, b).fst ∪ (a, b).snd)
⊢ ∀ {X : Type u_1} [_inst_1 : topological_space X] [_inst_2 : noncompact_space X], dense_range coe
X : Type u_1,	_inst_1 : topological_space X,	_inst_2 : noncompact_space X	⊢ dense_range coe
X : Type u_1,	_inst_1 : topological_space X,	_inst_2 : noncompact_space X	⊢ dense {infty}ᶜ
⊢ ∀ {α : Type u_1} {β : Type u_2} [_inst_1 : add_comm_monoid α] [_inst_2 : topological_space α]	  [_inst_3 : has_continuous_add α] [_inst_4 : regular_space α] {γ : β → Type u_3} {f : (Σ (b : β), γ b) → α}	  {g : β → α} {a : α},	    has_sum g a → (∀ (b : β), has_sum (λ (c : γ b), f ⟨b, c⟩) (g b)) → summable f → has_sum f a
α : Type u_1,	β : Type u_2,	_inst_1 : add_comm_monoid α,	_inst_2 : topological_space α,	_inst_3 : has_continuous_add α,	_inst_4 : regular_space α,	γ : β → Type u_3,	f : (Σ (b : β), γ b) → α,	g : β → α,	a : α,	ha : has_sum g a,	hf : ∀ (b : β), has_sum (λ (c : γ b), f ⟨b, c⟩) (g b),	hf' : summable f	⊢ has_sum f a
⊢ ∀ {α : Type u_1} {β : Type u_2} [_inst_1 : add_comm_monoid α] [_inst_2 : topological_space α]	  [_inst_3 : t2_space α] (P : Prop) [_inst_4 : decidable P] (x : β → ¬P → α),	    ∑' (b : β), dite P (λ (h : P), 0) (λ (h : ¬P), x b h) =	      dite P (λ (h : P), 0) (λ (h : ¬P), ∑' (b : β), x b h)
α : Type u_1,	β : Type u_2,	_inst_1 : add_comm_monoid α,	_inst_2 : topological_space α,	_inst_3 : t2_space α,	P : Prop,	_inst_4 : decidable P,	x : β → ¬P → α	⊢ ∑' (b : β), dite P (λ (h : P), 0) (λ (h : ¬P), x b h) =	    dite P (λ (h : P), 0) (λ (h : ¬P), ∑' (b : β), x b h)
2 goals	α : Type u_1,	β : Type u_2,	_inst_1 : add_comm_monoid α,	_inst_2 : topological_space α,	_inst_3 : t2_space α,	P : Prop,	_inst_4 : decidable P,	x : β → ¬P → α,	hP : P	⊢ ∑' (b : β), dite P (λ (h : P), 0) (λ (h : ¬P), x b h) =	    dite P (λ (h : P), 0) (λ (h : ¬P), ∑' (b : β), x b h)		α : Type u_1,	β : Type u_2,	_inst_1 : add_comm_monoid α,	_inst_2 : topological_space α,	_inst_3 : t2_space α,	P : Prop,	_inst_4 : decidable P,	x : β → ¬P → α,	hP : ¬P	⊢ ∑' (b : β), dite P (λ (h : P), 0) (λ (h : ¬P), x b h) =	    dite P (λ (h : P), 0) (λ (h : ¬P), ∑' (b : β), x b h)
α : Type u_1,	β : Type u_2,	_inst_1 : add_comm_monoid α,	_inst_2 : topological_space α,	_inst_3 : t2_space α,	P : Prop,	_inst_4 : decidable P,	x : β → ¬P → α,	hP : ¬P	⊢ ∑' (b : β), dite P (λ (h : P), 0) (λ (h : ¬P), x b h) =	    dite P (λ (h : P), 0) (λ (h : ¬P), ∑' (b : β), x b h)
⊢ ∀ {α : Type u_1} {β : Type u_2} [_inst_1 : add_comm_group α] [_inst_2 : topological_space α]	  [_inst_3 : topological_add_group α] {f : β → α} {a : α} [_inst_4 : decidable_eq β],	    has_sum f a → ∀ (b : β), has_sum (λ (n : β), ite (n = b) 0 (f n)) (a - f b)
α : Type u_1,	β : Type u_2,	_inst_1 : add_comm_group α,	_inst_2 : topological_space α,	_inst_3 : topological_add_group α,	f : β → α,	a : α,	_inst_4 : decidable_eq β,	hf : has_sum f a,	b : β	⊢ has_sum (λ (n : β), ite (n = b) 0 (f n)) (a - f b)
2 goals	α : Type u_1,	β : Type u_2,	_inst_1 : add_comm_group α,	_inst_2 : topological_space α,	_inst_3 : topological_add_group α,	f : β → α,	a : α,	_inst_4 : decidable_eq β,	hf : has_sum f a,	b : β	⊢ (λ (n : β), ite (n = b) 0 (f n)) = update f b 0		α : Type u_1,	β : Type u_2,	_inst_1 : add_comm_group α,	_inst_2 : topological_space α,	_inst_3 : topological_add_group α,	f : β → α,	a : α,	_inst_4 : decidable_eq β,	hf : has_sum f a,	b : β	⊢ a - f b = 0 - f b + a
2 goals	α : Type u_1,	β : Type u_2,	_inst_1 : add_comm_group α,	_inst_2 : topological_space α,	_inst_3 : topological_add_group α,	f : β → α,	a : α,	_inst_4 : decidable_eq β,	hf : has_sum f a,	b n : β	⊢ ite (n = b) 0 (f n) = update f b 0 n		α : Type u_1,	β : Type u_2,	_inst_1 : add_comm_group α,	_inst_2 : topological_space α,	_inst_3 : topological_add_group α,	f : β → α,	a : α,	_inst_4 : decidable_eq β,	hf : has_sum f a,	b : β	⊢ a - f b = 0 - f b + a
α : Type u_1,	β : Type u_2,	_inst_1 : add_comm_group α,	_inst_2 : topological_space α,	_inst_3 : topological_add_group α,	f : β → α,	a : α,	_inst_4 : decidable_eq β,	hf : has_sum f a,	b : β	⊢ a - f b = 0 - f b + a
⊢ ∀ {α : Type u_1} {β : Type u_2} [_inst_1 : canonically_ordered_add_monoid α] [_inst_2 : topological_space α]	  [_inst_3 : order_closed_topology α] {f : β → α},	    summable f → (∑' (i : β), f i = 0 ↔ ∀ (x : β), f x = 0)
α : Type u_1,	β : Type u_2,	_inst_1 : canonically_ordered_add_monoid α,	_inst_2 : topological_space α,	_inst_3 : order_closed_topology α,	f : β → α,	hf : summable f	⊢ ∑' (i : β), f i = 0 ↔ ∀ (x : β), f x = 0
⊢ ∀ {R₁ : Type u_1} {R₂ : Type u_2} {R₃ : Type u_3} [_inst_1 : semiring R₁] [_inst_2 : semiring R₂]	  [_inst_3 : semiring R₃] {σ₁₂ : R₁ →+* R₂} {σ₂₃ : R₂ →+* R₃} {M₁ : Type u_4}	  [_inst_4 : topological_space M₁] [_inst_5 : add_comm_monoid M₁] {M₂ : Type u_6}	  [_inst_8 : topological_space M₂] [_inst_9 : add_comm_monoid M₂] {M₃ : Type u_7}	  [_inst_10 : topological_space M₃] [_inst_11 : add_comm_monoid M₃] [_inst_14 : module R₁ M₁]	  [_inst_16 : module R₂ M₂] [_inst_17 : module R₃ M₃] {σ₁₃ : R₁ →+* R₃}	  [_inst_18 : ring_hom_comp_triple σ₁₂ σ₂₃ σ₁₃] [_inst_19 : has_continuous_add M₃]	  (g₁ g₂ : M₂ →SL[σ₂₃] M₃) (f : M₁ →SL[σ₁₂] M₂),	    (g₁ + g₂).comp f = g₁.comp f + g₂.comp f
R₁ : Type u_1,	R₂ : Type u_2,	R₃ : Type u_3,	_inst_1 : semiring R₁,	_inst_2 : semiring R₂,	_inst_3 : semiring R₃,	σ₁₂ : R₁ →+* R₂,	σ₂₃ : R₂ →+* R₃,	M₁ : Type u_4,	_inst_4 : topological_space M₁,	_inst_5 : add_comm_monoid M₁,	M₂ : Type u_6,	_inst_8 : topological_space M₂,	_inst_9 : add_comm_monoid M₂,	M₃ : Type u_7,	_inst_10 : topological_space M₃,	_inst_11 : add_comm_monoid M₃,	_inst_14 : module R₁ M₁,	_inst_16 : module R₂ M₂,	_inst_17 : module R₃ M₃,	σ₁₃ : R₁ →+* R₃,	_inst_18 : ring_hom_comp_triple σ₁₂ σ₂₃ σ₁₃,	_inst_19 : has_continuous_add M₃,	g₁ g₂ : M₂ →SL[σ₂₃] M₃,	f : M₁ →SL[σ₁₂] M₂	⊢ (g₁ + g₂).comp f = g₁.comp f + g₂.comp f
R₁ : Type u_1,	R₂ : Type u_2,	R₃ : Type u_3,	_inst_1 : semiring R₁,	_inst_2 : semiring R₂,	_inst_3 : semiring R₃,	σ₁₂ : R₁ →+* R₂,	σ₂₃ : R₂ →+* R₃,	M₁ : Type u_4,	_inst_4 : topological_space M₁,	_inst_5 : add_comm_monoid M₁,	M₂ : Type u_6,	_inst_8 : topological_space M₂,	_inst_9 : add_comm_monoid M₂,	M₃ : Type u_7,	_inst_10 : topological_space M₃,	_inst_11 : add_comm_monoid M₃,	_inst_14 : module R₁ M₁,	_inst_16 : module R₂ M₂,	_inst_17 : module R₃ M₃,	σ₁₃ : R₁ →+* R₃,	_inst_18 : ring_hom_comp_triple σ₁₂ σ₂₃ σ₁₃,	_inst_19 : has_continuous_add M₃,	g₁ g₂ : M₂ →SL[σ₂₃] M₃,	f : M₁ →SL[σ₁₂] M₂,	x : M₁	⊢ ⇑((g₁ + g₂).comp f) x = ⇑(g₁.comp f + g₂.comp f) x
⊢ ∀ {R : Type u_1} [_inst_1 : semiring R] {M : Type u_2} [_inst_2 : topological_space M]	  [_inst_3 : add_comm_monoid M] [_inst_4 : module R M] {ι : Type u_4} {φ : ι → Type u_5}	  [_inst_8 : Π (i : ι), topological_space (φ i)] [_inst_9 : Π (i : ι), add_comm_monoid (φ i)]	  [_inst_10 : Π (i : ι), module R (φ i)] (f : Π (i : ι), M →L[R] φ i), pi f = 0 ↔ ∀ (i : ι), f i = 0
R : Type u_1,	_inst_1 : semiring R,	M : Type u_2,	_inst_2 : topological_space M,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	ι : Type u_4,	φ : ι → Type u_5,	_inst_8 : Π (i : ι), topological_space (φ i),	_inst_9 : Π (i : ι), add_comm_monoid (φ i),	_inst_10 : Π (i : ι), module R (φ i),	f : Π (i : ι), M →L[R] φ i	⊢ pi f = 0 ↔ ∀ (i : ι), f i = 0
R : Type u_1,	_inst_1 : semiring R,	M : Type u_2,	_inst_2 : topological_space M,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	ι : Type u_4,	φ : ι → Type u_5,	_inst_8 : Π (i : ι), topological_space (φ i),	_inst_9 : Π (i : ι), add_comm_monoid (φ i),	_inst_10 : Π (i : ι), module R (φ i),	f : Π (i : ι), M →L[R] φ i	⊢ (∀ (x : M) (a : ι), ⇑(f a) x = ⇑0 x a) ↔ ∀ (i : ι) (x : M), ⇑(f i) x = ⇑0 x
⊢ ∀ {α : Type u} {β : Type v} [_inst_1 : linear_ordered_field α] [_inst_2 : topological_space α]	  [_inst_3 : order_topology α] {l : filter β} {f g : β → α} {C : α},	    0 < C → tendsto f l at_top → tendsto g l (nhds C) → tendsto (λ (x : β), f x * g x) l at_top
α : Type u,	β : Type v,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	l : filter β,	f g : β → α,	C : α,	hC : 0 < C,	hf : tendsto f l at_top,	hg : tendsto g l (nhds C)	⊢ tendsto (λ (x : β), f x * g x) l at_top
α : Type u,	β : Type v,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	l : filter β,	f g : β → α,	C : α,	hC : 0 < C,	hf : tendsto f l at_top,	hg : tendsto g l (nhds C)	⊢ (λ (x : β), f x * (C / 2)) ≤ᶠ[l] λ (x : β), f x * g x
α : Type u,	β : Type v,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	l : filter β,	f g : β → α,	C : α,	hC : 0 < C,	hf : tendsto f l at_top,	hg : tendsto g l (nhds C)	⊢ ∀ (a : β), C / 2 < g a → 0 ≤ f a → f a * (C / 2) ≤ f a * g a
⊢ ∀ {α : Type u} {β : Type v} [_inst_1 : linear_ordered_field α] [_inst_2 : topological_space α]	  [_inst_3 : order_topology α] {l : filter β} {f g : β → α} {C : α},	    0 < C → tendsto f l (nhds C) → tendsto g l at_bot → tendsto (λ (x : β), f x * g x) l at_bot
α : Type u,	β : Type v,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	l : filter β,	f g : β → α,	C : α,	hC : 0 < C,	hf : tendsto f l (nhds C),	hg : tendsto g l at_bot	⊢ tendsto (λ (x : β), f x * g x) l at_bot
⊢ ∀ {α : Type u} {β : Type v} [_inst_1 : topological_space α] [_inst_2 : linear_order α]	  [_inst_3 : order_topology α] [_inst_4 : densely_ordered α] {a : α} {l : filter β} {f : α → β},	    tendsto (λ (x : ↥(Iio a)), f ↑x) at_top l ↔ tendsto f (nhds_within a (Iio a)) l
α : Type u,	β : Type v,	_inst_1 : topological_space α,	_inst_2 : linear_order α,	_inst_3 : order_topology α,	_inst_4 : densely_ordered α,	a : α,	l : filter β,	f : α → β	⊢ tendsto (λ (x : ↥(Iio a)), f ↑x) at_top l ↔ tendsto f (nhds_within a (Iio a)) l
⊢ ∀ {β : Type u_2} [_inst_2 : topological_space β] {κ : Type u_5} {f : κ → β},	    dense_range f → ∀ {s : set β}, is_open s → s ⊆ closure (f '' (f ⁻¹' s))
β : Type u_2,	_inst_2 : topological_space β,	κ : Type u_5,	f : κ → β,	hf : dense_range f,	s : set β,	hs : is_open s	⊢ s ⊆ closure (f '' (f ⁻¹' s))
β : Type u_2,	_inst_2 : topological_space β,	κ : Type u_5,	f : κ → β,	hf : dense_range f,	s : set β,	hs : is_open s	⊢ s ⊆ closure (s ∩ range f)
⊢ ∀ {α : Type u} [_inst_1 : topological_space α], is_closed univ
α : Type u,	_inst_1 : topological_space α	⊢ is_closed univ
α : Type u,	_inst_1 : topological_space α	⊢ is_open ∅
⊢ ∀ {α : Type u} [_inst_1 : topological_space α] {s : set α}, closure s ⊆ s → is_closed s
α : Type u,	_inst_1 : topological_space α,	s : set α,	h : closure s ⊆ s	⊢ is_closed s
α : Type u,	_inst_1 : topological_space α,	s : set α,	h : closure s ⊆ s	⊢ is_closed (closure s)
⊢ ∀ {α : Type u} [_inst_1 : topological_space α] {s : set α}, is_open s → frontier s = closure s \ s
α : Type u,	_inst_1 : topological_space α,	s : set α,	hs : is_open s	⊢ frontier s = closure s \ s
⊢ ∀ {α : Type u} [_inst_1 : topological_space α] {s : set α} {x : α},	    x ∈ closure s ↔ ∃ (u : ultrafilter α), s ∈ u ∧ ↑u ≤ nhds x
α : Type u,	_inst_1 : topological_space α,	s : set α,	x : α	⊢ x ∈ closure s ↔ ∃ (u : ultrafilter α), s ∈ u ∧ ↑u ≤ nhds x
⊢ ∀ {α : Type u_1} [_inst_1 : topological_space α] (a : α), nhds_within a {a} = pure a
α : Type u_1,	_inst_1 : topological_space α,	a : α	⊢ nhds_within a {a} = pure a
⊢ ∀ {α : Type u_1} {β : Type u_2} [_inst_1 : topological_space α] [_inst_2 : topological_space β]	  {i : α → β} {s : set α} {a : α}, dense_inducing i → s ∈ nhds a → closure (i '' s) ∈ nhds (i a)
α : Type u_1,	β : Type u_2,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	i : α → β,	s : set α,	a : α,	di : dense_inducing i,	hs : s ∈ nhds a	⊢ closure (i '' s) ∈ nhds (i a)
α : Type u_1,	β : Type u_2,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	i : α → β,	s : set α,	a : α,	di : dense_inducing i,	hs :	  ∃ (i_1 : set β) (hi : (λ (s : set β), i a ∈ s ∧ is_open s) i_1), (λ (i_1 : set β), i ⁻¹' i_1) i_1 ⊆ s	⊢ closure (i '' s) ∈ nhds (i a)
α : Type u_1,	β : Type u_2,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	i : α → β,	s : set α,	a : α,	di : dense_inducing i,	U : set β,	haU : i a ∈ U,	hUo : is_open U,	sub : i ⁻¹' U ⊆ s	⊢ closure (i '' s) ∈ nhds (i a)
α : Type u_1,	β : Type u_2,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	i : α → β,	s : set α,	a : α,	di : dense_inducing i,	U : set β,	haU : i a ∈ U,	hUo : is_open U,	sub : i ⁻¹' U ⊆ s	⊢ U ⊆ closure (i '' s)
⊢ ∀ {X : Type u_1} [_inst_1 : topological_space X] {α : Type u_2} (f : locally_constant X α),	    ⇑(f.locally_constant_lift) ∘ f.discrete_quotient.proj = ⇑f
X : Type u_1,	_inst_1 : topological_space X,	α : Type u_2,	f : locally_constant X α	⊢ ⇑(f.locally_constant_lift) ∘ f.discrete_quotient.proj = ⇑f
X : Type u_1,	_inst_1 : topological_space X,	α : Type u_2,	f : locally_constant X α,	x : X	⊢ (⇑(f.locally_constant_lift) ∘ f.discrete_quotient.proj) x = ⇑f x
⊢ ∀ {α : Type u_1} {β : Type u_2} [_inst_1 : topological_space α] [_inst_2 : topological_space β]	  {f : α → β}, closed_embedding f → ∀ {s : set β}, s ⊆ range f → (is_closed s ↔ is_closed (f ⁻¹' s))
α : Type u_1,	β : Type u_2,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	f : α → β,	hf : closed_embedding f,	s : set β,	hs : s ⊆ range f	⊢ is_closed s ↔ is_closed (f ⁻¹' s)
α : Type u_1,	β : Type u_2,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	f : α → β,	hf : closed_embedding f,	s : set β,	hs : s ⊆ range f	⊢ f '' (f ⁻¹' s) = s
⊢ ∀ {α : Type u} [_inst_1 : pseudo_metric_space α] {s : set α}, ¬bounded s → diam s = 0
α : Type u,	_inst_1 : pseudo_metric_space α,	s : set α,	h : ¬bounded s	⊢ diam s = 0
⊢ ∀ {α : Type u} [_inst_1 : pseudo_metric_space α] {x : α} {ε : ℝ}, ball x ε = ∅ ↔ ε ≤ 0
α : Type u,	_inst_1 : pseudo_metric_space α,	x : α,	ε : ℝ	⊢ ball x ε = ∅ ↔ ε ≤ 0
⊢ ∀ {α : Type u} [_inst_1 : pseudo_metric_space α] {x : α} {ε : nnreal}, emetric.ball x ↑ε = ball x ↑ε
α : Type u,	_inst_1 : pseudo_metric_space α,	x : α,	ε : nnreal	⊢ emetric.ball x ↑ε = ball x ↑ε
α : Type u,	_inst_1 : pseudo_metric_space α,	x : α,	ε : nnreal	⊢ ε = ↑ε.to_nnreal
⊢ ∀ {α : Type u_1} [_inst_1 : emetric_space α] {K : nnreal} {f : α → α},	    contracting_with K f → ∀ {x y : α}, is_fixed_pt f x → is_fixed_pt f y → x = y ∨ edist x y = ⊤
α : Type u_1,	_inst_1 : emetric_space α,	K : nnreal,	f : α → α,	hf : contracting_with K f,	x y : α,	hx : is_fixed_pt f x,	hy : is_fixed_pt f y	⊢ x = y ∨ edist x y = ⊤
α : Type u_1,	_inst_1 : emetric_space α,	K : nnreal,	f : α → α,	hf : contracting_with K f,	x y : α,	hx : is_fixed_pt f x,	hy : is_fixed_pt f y,	h : ¬edist x y = ⊤	⊢ edist x y ≤ 0
⊢ ∀ {α : Type u} {β : Type v} [_inst_1 : pseudo_emetric_space α] {ι : Type u_1} [_inst_2 : topological_space β]	  {F : ι → β → α} {f : β → α} {p : filter ι} {s : set β},	    tendsto_locally_uniformly_on F f p s ↔	      ∀ (ε : ennreal),	        ε > 0 →	        ∀ (x : β),	          x ∈ s →	          (∃ (t : set β) (H : t ∈ nhds_within x s),	             ∀ᶠ (n : ι) in p, ∀ (y : β), y ∈ t → edist (f y) (F n y) < ε)
α : Type u,	β : Type v,	_inst_1 : pseudo_emetric_space α,	ι : Type u_1,	_inst_2 : topological_space β,	F : ι → β → α,	f : β → α,	p : filter ι,	s : set β	⊢ tendsto_locally_uniformly_on F f p s ↔	    ∀ (ε : ennreal),	      ε > 0 →	      ∀ (x : β),	        x ∈ s →	        (∃ (t : set β) (H : t ∈ nhds_within x s),	           ∀ᶠ (n : ι) in p, ∀ (y : β), y ∈ t → edist (f y) (F n y) < ε)
α : Type u,	β : Type v,	_inst_1 : pseudo_emetric_space α,	ι : Type u_1,	_inst_2 : topological_space β,	F : ι → β → α,	f : β → α,	p : filter ι,	s : set β,	H :	  ∀ (ε : ennreal),	    ε > 0 →	    ∀ (x : β),	      x ∈ s →	      (∃ (t : set β) (H : t ∈ nhds_within x s),	         ∀ᶠ (n : ι) in p, ∀ (y : β), y ∈ t → edist (f y) (F n y) < ε),	u : set (α × α),	hu : u ∈ uniformity α,	x : β,	hx : x ∈ s	⊢ ∃ (t : set β) (H : t ∈ nhds_within x s), ∀ᶠ (n : ι) in p, ∀ (y : β), y ∈ t → (f y, F n y) ∈ u
α : Type u,	β : Type v,	_inst_1 : pseudo_emetric_space α,	ι : Type u_1,	_inst_2 : topological_space β,	F : ι → β → α,	f : β → α,	p : filter ι,	s : set β,	H :	  ∀ (ε : ennreal),	    ε > 0 →	    ∀ (x : β),	      x ∈ s →	      (∃ (t : set β) (H : t ∈ nhds_within x s),	         ∀ᶠ (n : ι) in p, ∀ (y : β), y ∈ t → edist (f y) (F n y) < ε),	u : set (α × α),	hu : u ∈ uniformity α,	x : β,	hx : x ∈ s,	ε : ennreal,	εpos : ε > 0,	hε : ∀ {a b : α}, edist a b < ε → (a, b) ∈ u	⊢ ∃ (t : set β) (H : t ∈ nhds_within x s), ∀ᶠ (n : ι) in p, ∀ (y : β), y ∈ t → (f y, F n y) ∈ u
α : Type u,	β : Type v,	_inst_1 : pseudo_emetric_space α,	ι : Type u_1,	_inst_2 : topological_space β,	F : ι → β → α,	f : β → α,	p : filter ι,	s : set β,	H :	  ∀ (ε : ennreal),	    ε > 0 →	    ∀ (x : β),	      x ∈ s →	      (∃ (t : set β) (H : t ∈ nhds_within x s),	         ∀ᶠ (n : ι) in p, ∀ (y : β), y ∈ t → edist (f y) (F n y) < ε),	u : set (α × α),	hu : u ∈ uniformity α,	x : β,	hx : x ∈ s,	ε : ennreal,	εpos : ε > 0,	hε : ∀ {a b : α}, edist a b < ε → (a, b) ∈ u,	t : set β,	ht : t ∈ nhds_within x s,	Ht : ∀ᶠ (n : ι) in p, ∀ (y : β), y ∈ t → edist (f y) (F n y) < ε	⊢ ∃ (t : set β) (H : t ∈ nhds_within x s), ∀ᶠ (n : ι) in p, ∀ (y : β), y ∈ t → (f y, F n y) ∈ u
⊢ ∀ {X : Type u_2} {Y : Type u_3} [_inst_1 : emetric_space X] [_inst_2 : emetric_space Y]	  [_inst_3 : second_countable_topology X] {f : X → Y},	    (∀ (x : X), ∃ (C : nnreal) (s : set X) (H : s ∈ nhds x), lipschitz_on_with C f s) →	    dimH (range f) ≤ dimH univ
X : Type u_2,	Y : Type u_3,	_inst_1 : emetric_space X,	_inst_2 : emetric_space Y,	_inst_3 : second_countable_topology X,	f : X → Y,	hf : ∀ (x : X), ∃ (C : nnreal) (s : set X) (H : s ∈ nhds x), lipschitz_on_with C f s	⊢ dimH (range f) ≤ dimH univ
X : Type u_2,	Y : Type u_3,	_inst_1 : emetric_space X,	_inst_2 : emetric_space Y,	_inst_3 : second_countable_topology X,	f : X → Y,	hf : ∀ (x : X), ∃ (C : nnreal) (s : set X) (H : s ∈ nhds x), lipschitz_on_with C f s	⊢ dimH (f '' univ) ≤ dimH univ
X : Type u_2,	Y : Type u_3,	_inst_1 : emetric_space X,	_inst_2 : emetric_space Y,	_inst_3 : second_countable_topology X,	f : X → Y,	hf : ∀ (x : X), ∃ (C : nnreal) (s : set X) (H : s ∈ nhds x), lipschitz_on_with C f s,	x : X,	_x : x ∈ univ	⊢ ∃ (C : nnreal) (t : set X) (H : t ∈ nhds_within x univ), lipschitz_on_with C f t
⊢ ∀ {X : Type u_2} {Y : Type u_3} [_inst_1 : emetric_space X] [_inst_2 : emetric_space Y],	    X ≃ᵢ Y → dimH univ = dimH univ
X : Type u_2,	Y : Type u_3,	_inst_1 : emetric_space X,	_inst_2 : emetric_space Y,	e : X ≃ᵢ Y	⊢ dimH univ = dimH univ
⊢ ∀ {α : Type u} [_inst_1 : pseudo_emetric_space α] {s t : set α} {r : ennreal},	    (∀ (x : α), x ∈ s → inf_edist x t ≤ r) →	    (∀ (x : α), x ∈ t → inf_edist x s ≤ r) → Hausdorff_edist s t ≤ r
α : Type u,	_inst_1 : pseudo_emetric_space α,	s t : set α,	r : ennreal,	H1 : ∀ (x : α), x ∈ s → inf_edist x t ≤ r,	H2 : ∀ (x : α), x ∈ t → inf_edist x s ≤ r	⊢ Hausdorff_edist s t ≤ r
α : Type u,	_inst_1 : pseudo_emetric_space α,	s t : set α,	r : ennreal,	H1 : ∀ (x : α), x ∈ s → inf_edist x t ≤ r,	H2 : ∀ (x : α), x ∈ t → inf_edist x s ≤ r	⊢ (∀ (i : α), i ∈ s → inf_edist i t ≤ r) ∧ ∀ (i : α), i ∈ t → inf_edist i s ≤ r
⊢ ∀ {α : Type u} {β : Type v} [_inst_1 : pseudo_metric_space α] [_inst_2 : pseudo_metric_space β] {t : set α}	  {x : α} {Φ : α → β}, isometry Φ → inf_dist (Φ x) (Φ '' t) = inf_dist x t
α : Type u,	β : Type v,	_inst_1 : pseudo_metric_space α,	_inst_2 : pseudo_metric_space β,	t : set α,	x : α,	Φ : α → β,	hΦ : isometry Φ	⊢ inf_dist (Φ x) (Φ '' t) = inf_dist x t
⊢ ∀ {X : Type u_1} {Y : Type u_2} {Z : Type u_3} [_inst_1 : pseudo_emetric_space X]	  [_inst_2 : pseudo_emetric_space Y] [_inst_3 : pseudo_emetric_space Z] {s : set X} {Cg rg : nnreal} {g : Y → Z}	  {t : set Y},	    holder_on_with Cg rg g t →	    ∀ {Cf rf : nnreal} {f : X → Y},	      holder_on_with Cf rf f s → maps_to f s t → holder_on_with (Cg * Cf ^ ↑rg) (rg * rf) (g ∘ f) s
X : Type u_1,	Y : Type u_2,	Z : Type u_3,	_inst_1 : pseudo_emetric_space X,	_inst_2 : pseudo_emetric_space Y,	_inst_3 : pseudo_emetric_space Z,	s : set X,	Cg rg : nnreal,	g : Y → Z,	t : set Y,	hg : holder_on_with Cg rg g t,	Cf rf : nnreal,	f : X → Y,	hf : holder_on_with Cf rf f s,	hst : maps_to f s t	⊢ holder_on_with (Cg * Cf ^ ↑rg) (rg * rf) (g ∘ f) s
X : Type u_1,	Y : Type u_2,	Z : Type u_3,	_inst_1 : pseudo_emetric_space X,	_inst_2 : pseudo_emetric_space Y,	_inst_3 : pseudo_emetric_space Z,	s : set X,	Cg rg : nnreal,	g : Y → Z,	t : set Y,	hg : holder_on_with Cg rg g t,	Cf rf : nnreal,	f : X → Y,	hf : holder_on_with Cf rf f s,	hst : maps_to f s t,	x : X,	hx : x ∈ s,	y : X,	hy : y ∈ s	⊢ edist ((g ∘ f) x) ((g ∘ f) y) ≤ ↑(Cg * Cf ^ ↑rg) * edist x y ^ ↑(rg * rf)
X : Type u_1,	Y : Type u_2,	Z : Type u_3,	_inst_1 : pseudo_emetric_space X,	_inst_2 : pseudo_emetric_space Y,	_inst_3 : pseudo_emetric_space Z,	s : set X,	Cg rg : nnreal,	g : Y → Z,	t : set Y,	hg : holder_on_with Cg rg g t,	Cf rf : nnreal,	f : X → Y,	hf : holder_on_with Cf rf f s,	hst : maps_to f s t,	x : X,	hx : x ∈ s,	y : X,	hy : y ∈ s	⊢ edist ((g ∘ f) x) ((g ∘ f) y) ≤ ↑Cg * (↑Cf * edist x y ^ ↑rf) ^ ↑rg
⊢ ∀ {α : Type u} {β : Type v} {γ : Type w} [_inst_1 : pseudo_emetric_space α]	  [_inst_2 : pseudo_emetric_space β] [_inst_3 : pseudo_emetric_space γ] {f : α → β} {Kf : nnreal},	    lipschitz_with Kf f →	    ∀ {g : α → γ} {Kg : nnreal}, lipschitz_with Kg g → lipschitz_with (max Kf Kg) (λ (x : α), (f x, g x))
α : Type u,	β : Type v,	γ : Type w,	_inst_1 : pseudo_emetric_space α,	_inst_2 : pseudo_emetric_space β,	_inst_3 : pseudo_emetric_space γ,	f : α → β,	Kf : nnreal,	hf : lipschitz_with Kf f,	g : α → γ,	Kg : nnreal,	hg : lipschitz_with Kg g	⊢ lipschitz_with (max Kf Kg) (λ (x : α), (f x, g x))
α : Type u,	β : Type v,	γ : Type w,	_inst_1 : pseudo_emetric_space α,	_inst_2 : pseudo_emetric_space β,	_inst_3 : pseudo_emetric_space γ,	f : α → β,	Kf : nnreal,	hf : lipschitz_with Kf f,	g : α → γ,	Kg : nnreal,	hg : lipschitz_with Kg g,	x y : α	⊢ edist ((λ (x : α), (f x, g x)) x) ((λ (x : α), (f x, g x)) y) ≤ ↑(max Kf Kg) * edist x y
α : Type u,	β : Type v,	γ : Type w,	_inst_1 : pseudo_emetric_space α,	_inst_2 : pseudo_emetric_space β,	_inst_3 : pseudo_emetric_space γ,	f : α → β,	Kf : nnreal,	hf : lipschitz_with Kf f,	g : α → γ,	Kg : nnreal,	hg : lipschitz_with Kg g,	x y : α	⊢ max (edist ((λ (x : α), (f x, g x)) x).fst ((λ (x : α), (f x, g x)) y).fst)	      (edist ((λ (x : α), (f x, g x)) x).snd ((λ (x : α), (f x, g x)) y).snd) ≤	    max (↑Kf * edist x y) (↑Kg * edist x y)
⊢ ∀ {X : Type u_1} [_inst_1 : emetric_space X] {s t s' : set X},	    is_metric_separated s t → is_metric_separated s' t → is_metric_separated (s ∪ s') t
X : Type u_1,	_inst_1 : emetric_space X,	s t s' : set X,	h : is_metric_separated s t,	h' : is_metric_separated s' t	⊢ is_metric_separated (s ∪ s') t
X : Type u_1,	_inst_1 : emetric_space X,	s t s' : set X,	r : ennreal,	r0 : r ≠ 0,	hr : ∀ (x : X), x ∈ s → ∀ (y : X), y ∈ t → r ≤ edist x y,	r' : ennreal,	r0' : r' ≠ 0,	hr' : ∀ (x : X), x ∈ s' → ∀ (y : X), y ∈ t → r' ≤ edist x y	⊢ is_metric_separated (s ∪ s') t
3 goals	X : Type u_1,	_inst_1 : emetric_space X,	s t s' : set X,	r : ennreal,	r0 : r ≠ 0,	hr : ∀ (x : X), x ∈ s → ∀ (y : X), y ∈ t → r ≤ edist x y,	r' : ennreal,	r0' : r' ≠ 0,	hr' : ∀ (x : X), x ∈ s' → ∀ (y : X), y ∈ t → r' ≤ edist x y	⊢ min r r' ≠ 0		X : Type u_1,	_inst_1 : emetric_space X,	s t s' : set X,	r : ennreal,	r0 : r ≠ 0,	hr : ∀ (x : X), x ∈ s → ∀ (y : X), y ∈ t → r ≤ edist x y,	r' : ennreal,	r0' : r' ≠ 0,	hr' : ∀ (x : X), x ∈ s' → ∀ (y : X), y ∈ t → r' ≤ edist x y,	x : X,	hx : x ∈ s ∪ s',	y : X,	hy : y ∈ t	⊢ x ∈ s → min r r' ≤ edist x y		X : Type u_1,	_inst_1 : emetric_space X,	s t s' : set X,	r : ennreal,	r0 : r ≠ 0,	hr : ∀ (x : X), x ∈ s → ∀ (y : X), y ∈ t → r ≤ edist x y,	r' : ennreal,	r0' : r' ≠ 0,	hr' : ∀ (x : X), x ∈ s' → ∀ (y : X), y ∈ t → r' ≤ edist x y,	x : X,	hx : x ∈ s ∪ s',	y : X,	hy : y ∈ t	⊢ x ∈ s' → min r r' ≤ edist x y
3 goals	X : Type u_1,	_inst_1 : emetric_space X,	s t s' : set X,	r : ennreal,	hr : ∀ (x : X), x ∈ s → ∀ (y : X), y ∈ t → r ≤ edist x y,	r' : ennreal,	hr' : ∀ (x : X), x ∈ s' → ∀ (y : X), y ∈ t → r' ≤ edist x y,	r0' : 0 < r',	r0 : 0 < r	⊢ 0 < min r r'		X : Type u_1,	_inst_1 : emetric_space X,	s t s' : set X,	r : ennreal,	r0 : r ≠ 0,	hr : ∀ (x : X), x ∈ s → ∀ (y : X), y ∈ t → r ≤ edist x y,	r' : ennreal,	r0' : r' ≠ 0,	hr' : ∀ (x : X), x ∈ s' → ∀ (y : X), y ∈ t → r' ≤ edist x y,	x : X,	hx : x ∈ s ∪ s',	y : X,	hy : y ∈ t	⊢ x ∈ s → min r r' ≤ edist x y		X : Type u_1,	_inst_1 : emetric_space X,	s t s' : set X,	r : ennreal,	r0 : r ≠ 0,	hr : ∀ (x : X), x ∈ s → ∀ (y : X), y ∈ t → r ≤ edist x y,	r' : ennreal,	r0' : r' ≠ 0,	hr' : ∀ (x : X), x ∈ s' → ∀ (y : X), y ∈ t → r' ≤ edist x y,	x : X,	hx : x ∈ s ∪ s',	y : X,	hy : y ∈ t	⊢ x ∈ s' → min r r' ≤ edist x y
2 goals	X : Type u_1,	_inst_1 : emetric_space X,	s t s' : set X,	r : ennreal,	r0 : r ≠ 0,	hr : ∀ (x : X), x ∈ s → ∀ (y : X), y ∈ t → r ≤ edist x y,	r' : ennreal,	r0' : r' ≠ 0,	hr' : ∀ (x : X), x ∈ s' → ∀ (y : X), y ∈ t → r' ≤ edist x y,	x : X,	hx : x ∈ s ∪ s',	y : X,	hy : y ∈ t	⊢ x ∈ s → min r r' ≤ edist x y		X : Type u_1,	_inst_1 : emetric_space X,	s t s' : set X,	r : ennreal,	r0 : r ≠ 0,	hr : ∀ (x : X), x ∈ s → ∀ (y : X), y ∈ t → r ≤ edist x y,	r' : ennreal,	r0' : r' ≠ 0,	hr' : ∀ (x : X), x ∈ s' → ∀ (y : X), y ∈ t → r' ≤ edist x y,	x : X,	hx : x ∈ s ∪ s',	y : X,	hy : y ∈ t	⊢ x ∈ s' → min r r' ≤ edist x y
X : Type u_1,	_inst_1 : emetric_space X,	s t s' : set X,	r : ennreal,	r0 : r ≠ 0,	hr : ∀ (x : X), x ∈ s → ∀ (y : X), y ∈ t → r ≤ edist x y,	r' : ennreal,	r0' : r' ≠ 0,	hr' : ∀ (x : X), x ∈ s' → ∀ (y : X), y ∈ t → r' ≤ edist x y,	x : X,	hx : x ∈ s ∪ s',	y : X,	hy : y ∈ t	⊢ x ∈ s' → min r r' ≤ edist x y
⊢ ∀ {α : Type u_1} {β : Type u_2} [t : topological_space α] {b : set (set β)} {f : α → β},	    (∀ (a : set β), a ∈ b → is_open (f ⁻¹' a)) → t ≤ induced f (generate_from b)
α : Type u_1,	β : Type u_2,	t : topological_space α,	b : set (set β),	f : α → β,	h : ∀ (a : set β), a ∈ b → is_open (f ⁻¹' a)	⊢ t ≤ induced f (generate_from b)
α : Type u_1,	β : Type u_2,	t : topological_space α,	b : set (set β),	f : α → β,	h : ∀ (a : set β), a ∈ b → is_open (f ⁻¹' a)	⊢ t ≤ generate_from (preimage f '' b)
α : Type u_1,	β : Type u_2,	t : topological_space α,	b : set (set β),	f : α → β,	h : ∀ (a : set β), a ∈ b → is_open (f ⁻¹' a)	⊢ ∀ (s : set α), s ∈ preimage f '' b → is_open s
α : Type u_1,	β : Type u_2,	t : topological_space α,	b : set (set β),	f : α → β,	h : ∀ (a : set β), a ∈ b → is_open (f ⁻¹' a)	⊢ ∀ (a : set β), a ∈ b → is_open (f ⁻¹' a)
⊢ ∀ {α : Type u} {β : Type v} [T : topological_space α] (f : β → α) (a : β) (s : set β),	    s ∈ nhds a ↔ ∃ (u : set α) (H : u ∈ nhds (f a)), f ⁻¹' u ⊆ s
α : Type u,	β : Type v,	T : topological_space α,	f : β → α,	a : β,	s : set β	⊢ s ∈ nhds a ↔ ∃ (u : set α) (H : u ∈ nhds (f a)), f ⁻¹' u ⊆ s
α : Type u,	β : Type v,	T : topological_space α,	f : β → α,	a : β,	s : set β	⊢ (∃ (t : set β), t ⊆ s ∧ (∃ (t_1 : set α), is_open t_1 ∧ f ⁻¹' t_1 = t) ∧ a ∈ t) ↔	    ∃ (u : set α), (∃ (a_1 : set α), a_1 ⊆ u ∧ is_open a_1 ∧ f a ∈ a_1) ∧ f ⁻¹' u ⊆ s
2 goals	α : Type u,	β : Type v,	T : topological_space α,	f : β → α,	a : β,	s : set β	⊢ (∃ (t : set β), t ⊆ s ∧ (∃ (t_1 : set α), is_open t_1 ∧ f ⁻¹' t_1 = t) ∧ a ∈ t) →	  (∃ (u : set α), (∃ (a_1 : set α), a_1 ⊆ u ∧ is_open a_1 ∧ f a ∈ a_1) ∧ f ⁻¹' u ⊆ s)		α : Type u,	β : Type v,	T : topological_space α,	f : β → α,	a : β,	s : set β	⊢ (∃ (u : set α), (∃ (a_1 : set α), a_1 ⊆ u ∧ is_open a_1 ∧ f a ∈ a_1) ∧ f ⁻¹' u ⊆ s) →	  (∃ (t : set β), t ⊆ s ∧ (∃ (t_1 : set α), is_open t_1 ∧ f ⁻¹' t_1 = t) ∧ a ∈ t)
2 goals	α : Type u,	β : Type v,	T : topological_space α,	f : β → α,	a : β,	s u : set β,	usub : u ⊆ s,	au : a ∈ u,	v : set α,	openv : is_open v,	ueq : f ⁻¹' v = u	⊢ ∃ (u : set α), (∃ (a_1 : set α), a_1 ⊆ u ∧ is_open a_1 ∧ f a ∈ a_1) ∧ f ⁻¹' u ⊆ s		α : Type u,	β : Type v,	T : topological_space α,	f : β → α,	a : β,	s : set β	⊢ (∃ (u : set α), (∃ (a_1 : set α), a_1 ⊆ u ∧ is_open a_1 ∧ f a ∈ a_1) ∧ f ⁻¹' u ⊆ s) →	  (∃ (t : set β), t ⊆ s ∧ (∃ (t_1 : set α), is_open t_1 ∧ f ⁻¹' t_1 = t) ∧ a ∈ t)
α : Type u,	β : Type v,	T : topological_space α,	f : β → α,	a : β,	s : set β	⊢ (∃ (u : set α), (∃ (a_1 : set α), a_1 ⊆ u ∧ is_open a_1 ∧ f a ∈ a_1) ∧ f ⁻¹' u ⊆ s) →	  (∃ (t : set β), t ⊆ s ∧ (∃ (t_1 : set α), is_open t_1 ∧ f ⁻¹' t_1 = t) ∧ a ∈ t)
α : Type u,	β : Type v,	T : topological_space α,	f : β → α,	a : β,	s : set β,	u : set α,	finvsub : f ⁻¹' u ⊆ s,	v : set α,	vsubu : v ⊆ u,	openv : is_open v,	amem : f a ∈ v	⊢ ∃ (t : set β), t ⊆ s ∧ (∃ (t_1 : set α), is_open t_1 ∧ f ⁻¹' t_1 = t) ∧ a ∈ t
⊢ ∀ {α : Type u_1} [_inst_1 : topological_space α] {x : α} {γ : Type u_3} [_inst_3 : linear_order γ]	  [_inst_4 : topological_space γ] [_inst_5 : order_topology γ] {δ : Type u_4} [_inst_6 : linear_order δ]	  [_inst_7 : topological_space δ] [_inst_8 : order_topology δ] {g : γ → δ} {f : α → γ},	    continuous_at g (f x) → lower_semicontinuous_at f x → monotone g → lower_semicontinuous_at (g ∘ f) x
α : Type u_1,	_inst_1 : topological_space α,	x : α,	γ : Type u_3,	_inst_3 : linear_order γ,	_inst_4 : topological_space γ,	_inst_5 : order_topology γ,	δ : Type u_4,	_inst_6 : linear_order δ,	_inst_7 : topological_space δ,	_inst_8 : order_topology δ,	g : γ → δ,	f : α → γ,	hg : continuous_at g (f x),	hf : lower_semicontinuous_at f x,	gmon : monotone g	⊢ lower_semicontinuous_at (g ∘ f) x
α : Type u_1,	_inst_1 : topological_space α,	x : α,	γ : Type u_3,	_inst_3 : linear_order γ,	_inst_4 : topological_space γ,	_inst_5 : order_topology γ,	δ : Type u_4,	_inst_6 : linear_order δ,	_inst_7 : topological_space δ,	_inst_8 : order_topology δ,	g : γ → δ,	f : α → γ,	hg : continuous_at g (f x),	gmon : monotone g,	hf : lower_semicontinuous_within_at f univ x	⊢ lower_semicontinuous_within_at (g ∘ f) univ x
⊢ ∀ {α : Type u_1} [_inst_1 : topological_space α] {β : Type u_2} [_inst_2 : preorder β] {f : α → β},	    upper_semicontinuous_on f univ ↔ upper_semicontinuous f
α : Type u_1,	_inst_1 : topological_space α,	β : Type u_2,	_inst_2 : preorder β,	f : α → β	⊢ upper_semicontinuous_on f univ ↔ upper_semicontinuous f
⊢ ∀ {α : Type u} [_inst_1 : topological_space α] [_inst_2 : t2_space α] [_inst_3 : compact_space α]	  (U : set α), is_open U ↔ ∀ (F : ultrafilter α), F.Lim ∈ U → U ∈ F.to_filter
α : Type u,	_inst_1 : topological_space α,	_inst_2 : t2_space α,	_inst_3 : compact_space α,	U : set α	⊢ is_open U ↔ ∀ (F : ultrafilter α), F.Lim ∈ U → U ∈ F.to_filter
α : Type u,	_inst_1 : topological_space α,	_inst_2 : t2_space α,	_inst_3 : compact_space α,	U : set α	⊢ (∀ (x : α), x ∈ U → ∀ (l : ultrafilter α), ↑l ≤ nhds x → U ∈ l) ↔	    ∀ (F : ultrafilter α), F.Lim ∈ U → U ∈ F.to_filter
α : Type u,	_inst_1 : topological_space α,	_inst_2 : t2_space α,	_inst_3 : compact_space α,	U : set α	⊢ (∀ (F : ultrafilter α), F.Lim ∈ U → U ∈ F.to_filter) →	  ∀ (x : α), x ∈ U → ∀ (l : ultrafilter α), ↑l ≤ nhds x → U ∈ l
α : Type u,	_inst_1 : topological_space α,	_inst_2 : t2_space α,	_inst_3 : compact_space α,	U : set α,	cond : ∀ (F : ultrafilter α), F.Lim ∈ U → U ∈ F.to_filter,	x : α,	hx : x ∈ U,	f : ultrafilter α,	h : ↑f ≤ nhds x	⊢ U ∈ f
α : Type u,	_inst_1 : topological_space α,	_inst_2 : t2_space α,	_inst_3 : compact_space α,	U : set α,	cond : ∀ (F : ultrafilter α), F.Lim ∈ U → U ∈ F.to_filter,	x : α,	f : ultrafilter α,	h : ↑f ≤ nhds x,	hx : f.Lim ∈ U	⊢ U ∈ f
⊢ ∀ {ι : Type u_1} {X : Type u_2} [_inst_1 : topological_space X] [_inst_2 : normal_space X] {u : ι → set X}	  {s : set X} {c : set (partial_refinement u s)},	    chain has_le.le c →	    ∀ {v₁ v₂ : partial_refinement u s},	      v₁ ∈ c → v₂ ∈ c → ∀ {i : ι}, i ∈ v₁.carrier → i ∈ v₂.carrier → ⇑v₁ i = ⇑v₂ i
ι : Type u_1,	X : Type u_2,	_inst_1 : topological_space X,	_inst_2 : normal_space X,	u : ι → set X,	s : set X,	c : set (partial_refinement u s),	hc : chain has_le.le c,	v₁ v₂ : partial_refinement u s,	h₁ : v₁ ∈ c,	h₂ : v₂ ∈ c,	i : ι,	hi₁ : i ∈ v₁.carrier,	hi₂ : i ∈ v₂.carrier	⊢ ⇑v₁ i = ⇑v₂ i
case main	ι : Type u_1,	X : Type u_2,	_inst_1 : topological_space X,	_inst_2 : normal_space X,	u : ι → set X,	s : set X,	c : set (partial_refinement u s),	hc : chain has_le.le c,	i : ι,	v₁ v₂ : partial_refinement u s,	hle : v₁ ≤ v₂,	h₁ : v₁ ∈ c,	h₂ : v₂ ∈ c,	hi₁ : i ∈ v₁.carrier,	hi₂ : i ∈ v₂.carrier	⊢ ⇑v₁ i = ⇑v₂ i
⊢ ∀ {α : Type u_1} [_inst_1 : uniform_space α] {x : α} {s : set α},	    s ∈ nhds x ↔ ∃ (V : set (α × α)) (H : V ∈ uniformity α), symmetric_rel V ∧ ball x V ⊆ s
α : Type u_1,	_inst_1 : uniform_space α,	x : α,	s : set α	⊢ s ∈ nhds x ↔ ∃ (V : set (α × α)) (H : V ∈ uniformity α), symmetric_rel V ∧ ball x V ⊆ s
α : Type u_1,	_inst_1 : uniform_space α,	x : α,	s : set α	⊢ (∃ (V : set (α × α)) (H : V ∈ uniformity α), ball x V ⊆ s) ↔	    ∃ (V : set (α × α)) (H : V ∈ uniformity α), symmetric_rel V ∧ ball x V ⊆ s
2 goals	α : Type u_1,	_inst_1 : uniform_space α,	x : α,	s : set α	⊢ (∃ (V : set (α × α)) (H : V ∈ uniformity α), ball x V ⊆ s) →	  (∃ (V : set (α × α)) (H : V ∈ uniformity α), symmetric_rel V ∧ ball x V ⊆ s)		α : Type u_1,	_inst_1 : uniform_space α,	x : α,	s : set α	⊢ (∃ (V : set (α × α)) (H : V ∈ uniformity α), symmetric_rel V ∧ ball x V ⊆ s) →	  (∃ (V : set (α × α)) (H : V ∈ uniformity α), ball x V ⊆ s)
2 goals	α : Type u_1,	_inst_1 : uniform_space α,	x : α,	s : set α,	V : set (α × α),	V_in : V ∈ uniformity α,	V_sub : ball x V ⊆ s	⊢ ∃ (V : set (α × α)) (H : V ∈ uniformity α), symmetric_rel V ∧ ball x V ⊆ s		α : Type u_1,	_inst_1 : uniform_space α,	x : α,	s : set α	⊢ (∃ (V : set (α × α)) (H : V ∈ uniformity α), symmetric_rel V ∧ ball x V ⊆ s) →	  (∃ (V : set (α × α)) (H : V ∈ uniformity α), ball x V ⊆ s)
2 goals	α : Type u_1,	_inst_1 : uniform_space α,	x : α,	s : set α,	V : set (α × α),	V_in : V ∈ uniformity α,	V_sub : ball x V ⊆ s	⊢ ball x (symmetrize_rel V) ⊆ s		α : Type u_1,	_inst_1 : uniform_space α,	x : α,	s : set α	⊢ (∃ (V : set (α × α)) (H : V ∈ uniformity α), symmetric_rel V ∧ ball x V ⊆ s) →	  (∃ (V : set (α × α)) (H : V ∈ uniformity α), ball x V ⊆ s)
α : Type u_1,	_inst_1 : uniform_space α,	x : α,	s : set α	⊢ (∃ (V : set (α × α)) (H : V ∈ uniformity α), symmetric_rel V ∧ ball x V ⊆ s) →	  (∃ (V : set (α × α)) (H : V ∈ uniformity α), ball x V ⊆ s)
α : Type u_1,	_inst_1 : uniform_space α,	x : α,	s : set α,	V : set (α × α),	V_in : V ∈ uniformity α,	V_symm : symmetric_rel V,	V_sub : ball x V ⊆ s	⊢ ∃ (V : set (α × α)) (H : V ∈ uniformity α), ball x V ⊆ s
⊢ ∀ {α : Type u_1} [_inst_1 : uniform_space α] {s : set α} {x : α},	    x ∈ closure s ↔ ∀ {V : set (α × α)}, V ∈ uniformity α → (ball x V ∩ s).nonempty
α : Type u_1,	_inst_1 : uniform_space α,	s : set α,	x : α	⊢ x ∈ closure s ↔ ∀ {V : set (α × α)}, V ∈ uniformity α → (ball x V ∩ s).nonempty
α : Type u_1,	_inst_1 : uniform_space α,	s : set α,	x : α	⊢ (∀ (t : set α), (∃ (V : set (α × α)) (H : V ∈ uniformity α), ball x V ⊆ t) → (t ∩ s).nonempty) ↔	    ∀ {V : set (α × α)}, V ∈ uniformity α → (ball x V ∩ s).nonempty
2 goals	α : Type u_1,	_inst_1 : uniform_space α,	s : set α,	x : α	⊢ (∀ (t : set α), (∃ (V : set (α × α)) (H : V ∈ uniformity α), ball x V ⊆ t) → (t ∩ s).nonempty) →	  ∀ {V : set (α × α)}, V ∈ uniformity α → (ball x V ∩ s).nonempty		α : Type u_1,	_inst_1 : uniform_space α,	s : set α,	x : α	⊢ (∀ {V : set (α × α)}, V ∈ uniformity α → (ball x V ∩ s).nonempty) →	  ∀ (t : set α), (∃ (V : set (α × α)) (H : V ∈ uniformity α), ball x V ⊆ t) → (t ∩ s).nonempty
2 goals	α : Type u_1,	_inst_1 : uniform_space α,	s : set α,	x : α,	h : ∀ (t : set α), (∃ (V : set (α × α)) (H : V ∈ uniformity α), ball x V ⊆ t) → (t ∩ s).nonempty,	V : set (α × α),	V_in : V ∈ uniformity α	⊢ (ball x V ∩ s).nonempty		α : Type u_1,	_inst_1 : uniform_space α,	s : set α,	x : α	⊢ (∀ {V : set (α × α)}, V ∈ uniformity α → (ball x V ∩ s).nonempty) →	  ∀ (t : set α), (∃ (V : set (α × α)) (H : V ∈ uniformity α), ball x V ⊆ t) → (t ∩ s).nonempty
α : Type u_1,	_inst_1 : uniform_space α,	s : set α,	x : α	⊢ (∀ {V : set (α × α)}, V ∈ uniformity α → (ball x V ∩ s).nonempty) →	  ∀ (t : set α), (∃ (V : set (α × α)) (H : V ∈ uniformity α), ball x V ⊆ t) → (t ∩ s).nonempty
α : Type u_1,	_inst_1 : uniform_space α,	s : set α,	x : α,	h : ∀ {V : set (α × α)}, V ∈ uniformity α → (ball x V ∩ s).nonempty,	t : set α,	V : set (α × α),	V_in : V ∈ uniformity α,	Vt : ball x V ⊆ t	⊢ (t ∩ s).nonempty
⊢ ∀ {α : Type u_1} {β : Type u_2} {ι : Type u_4} [_inst_1 : uniform_space β] {F : ι → α → β}	  {f : α → β} {p : filter ι}, tendsto_uniformly_on F f p univ ↔ tendsto_uniformly F f p
α : Type u_1,	β : Type u_2,	ι : Type u_4,	_inst_1 : uniform_space β,	F : ι → α → β,	f : α → β,	p : filter ι	⊢ tendsto_uniformly_on F f p univ ↔ tendsto_uniformly F f p
⊢ ∀ (R : Type u_1) {B : Type u_2} (F : Type u_3) (E : B → Type u_4) [_inst_1 : semiring R]	  [_inst_2 : Π (x : B), add_comm_monoid (E x)] [_inst_3 : Π (x : B), module R (E x)] [_inst_4 : topological_space F]	  [_inst_5 : add_comm_monoid F] [_inst_6 : module R F] [_inst_7 : topological_space (total_space E)]	  [_inst_8 : topological_space B] [_inst_9 : Π (x : B), topological_space (E x)]	  [_inst_10 : topological_vector_bundle R F E] (z : total_space E),	    z ∈ (trivialization_at R F E z.fst).to_fiber_bundle_trivialization.to_local_homeomorph.to_local_equiv.source
R : Type u_1,	B : Type u_2,	F : Type u_3,	E : B → Type u_4,	_inst_1 : semiring R,	_inst_2 : Π (x : B), add_comm_monoid (E x),	_inst_3 : Π (x : B), module R (E x),	_inst_4 : topological_space F,	_inst_5 : add_comm_monoid F,	_inst_6 : module R F,	_inst_7 : topological_space (total_space E),	_inst_8 : topological_space B,	_inst_9 : Π (x : B), topological_space (E x),	_inst_10 : topological_vector_bundle R F E,	z : total_space E	⊢ z ∈ (trivialization_at R F E z.fst).to_fiber_bundle_trivialization.to_local_homeomorph.to_local_equiv.source
R : Type u_1,	B : Type u_2,	F : Type u_3,	E : B → Type u_4,	_inst_1 : semiring R,	_inst_2 : Π (x : B), add_comm_monoid (E x),	_inst_3 : Π (x : B), module R (E x),	_inst_4 : topological_space F,	_inst_5 : add_comm_monoid F,	_inst_6 : module R F,	_inst_7 : topological_space (total_space E),	_inst_8 : topological_space B,	_inst_9 : Π (x : B), topological_space (E x),	_inst_10 : topological_vector_bundle R F E,	z : total_space E	⊢ proj E z ∈ (trivialization_at R F E z.fst).to_fiber_bundle_trivialization.base_set
