{"src": "⊢ ∀ {α : Type u} (s : stream α), s.even.tail = s.tail.tail.even", "decl_nm": "stream.tail_even"
{"src": "α : Type u,	s : stream α	⊢ s.even.tail = s.tail.tail.even", "decl_nm": "stream.tail_even"
{"src": "α : Type u,	s : stream α	⊢ (corec (λ (s : stream α), s.head) (λ (s : stream α), s.tail.tail) s).tail =	    corec (λ (s : stream α), s.head) (λ (s : stream α), s.tail.tail) s.tail.tail", "decl_nm": "stream.tail_even"
{"src": "α : Type u,	s : stream α	⊢ (s.head::corec (λ (s : stream α), s.head) (λ (s : stream α), s.tail.tail) s.tail.tail).tail =	    corec (λ (s : stream α), s.head) (λ (s : stream α), s.tail.tail) s.tail.tail", "decl_nm": "stream.tail_even"
{"src": "⊢ ∀ {a b : ℤ}, 0 ≤ a - b → b ≤ a", "decl_nm": "int.le_of_sub_nonneg"
{"src": "a b : ℤ,	h : 0 ≤ a - b	⊢ b ≤ a", "decl_nm": "int.le_of_sub_nonneg"
{"src": "a b : ℤ,	h : 0 ≤ a - b,	h : 0 + b ≤ a - b + b	⊢ b ≤ a", "decl_nm": "int.le_of_sub_nonneg"
{"src": "⊢ ∀ (b : bool) (n : ℕ), (bit b n).div2 = n", "decl_nm": "nat.div2_bit"
{"src": "b : bool,	n : ℕ	⊢ (bit b n).div2 = n", "decl_nm": "nat.div2_bit"
{"src": "2 goals	b : bool,	n : ℕ	⊢ cond b 1 0 < 2		b : bool,	n : ℕ	⊢ 0 < 2", "decl_nm": "nat.div2_bit"
{"src": "3 goals	case bool.ff	n : ℕ	⊢ cond ff 1 0 < 2		case bool.tt	n : ℕ	⊢ cond tt 1 0 < 2		b : bool,	n : ℕ	⊢ 0 < 2", "decl_nm": "nat.div2_bit"
{"src": "2 goals	case bool.tt	n : ℕ	⊢ cond tt 1 0 < 2		b : bool,	n : ℕ	⊢ 0 < 2", "decl_nm": "nat.div2_bit"
{"src": "b : bool,	n : ℕ	⊢ 0 < 2", "decl_nm": "nat.div2_bit"
{"src": "2 goals	case bool.ff	n : ℕ	⊢ 0 < 2		case bool.tt	n : ℕ	⊢ 0 < 2", "decl_nm": "nat.div2_bit"
{"src": "case bool.tt	n : ℕ	⊢ 0 < 2", "decl_nm": "nat.div2_bit"
{"src": "⊢ ∀ (m n : ℕ), m * n % m = 0", "decl_nm": "nat.mul_mod_right"
{"src": "m n : ℕ	⊢ m * n % m = 0", "decl_nm": "nat.mul_mod_right"
{"src": "⊢ ∀ (n : ℕ), n = 0 ∨ n = n.pred.succ", "decl_nm": "nat.eq_zero_or_eq_succ_pred"
{"src": "n : ℕ	⊢ n = 0 ∨ n = n.pred.succ", "decl_nm": "nat.eq_zero_or_eq_succ_pred"
{"src": "2 goals	case nat.zero	⊢ 0 = 0 ∨ 0 = 0.pred.succ		case nat.succ	n : ℕ	⊢ n.succ = 0 ∨ n.succ = n.succ.pred.succ", "decl_nm": "nat.eq_zero_or_eq_succ_pred"
{"src": "case nat.succ	n : ℕ	⊢ n.succ = 0 ∨ n.succ = n.succ.pred.succ", "decl_nm": "nat.eq_zero_or_eq_succ_pred"
{"src": "⊢ ∀ {G : Type u_1} {P : Type u_2} [_inst_1 : add_comm_group G] [_inst_2 : add_torsor G P] (p₁ p₂ p₃ p₄ : P),	    p₁ -ᵥ p₂ - (p₃ -ᵥ p₄) = p₁ -ᵥ p₃ - (p₂ -ᵥ p₄)", "decl_nm": "vsub_sub_vsub_comm"
{"src": "G : Type u_1,	P : Type u_2,	_inst_1 : add_comm_group G,	_inst_2 : add_torsor G P,	p₁ p₂ p₃ p₄ : P	⊢ p₁ -ᵥ p₂ - (p₃ -ᵥ p₄) = p₁ -ᵥ p₃ - (p₂ -ᵥ p₄)", "decl_nm": "vsub_sub_vsub_comm"
{"src": "⊢ ∀ {R : Type u} {A : Type w} [_inst_1 : comm_semiring R] [_inst_3 : semiring A] [_inst_4 : algebra R A] (x : A)	  (r : R) (y : A), x * (⇑(algebra_map R A) r * y) = ⇑(algebra_map R A) r * (x * y)", "decl_nm": "algebra.left_comm"
{"src": "R : Type u,	A : Type w,	_inst_1 : comm_semiring R,	_inst_3 : semiring A,	_inst_4 : algebra R A,	x : A,	r : R,	y : A	⊢ x * (⇑(algebra_map R A) r * y) = ⇑(algebra_map R A) r * (x * y)", "decl_nm": "algebra.left_comm"
{"src": "⊢ ∀ {R : Type u} {A : Type w} [_inst_1 : comm_semiring R] [_inst_3 : semiring A] [_inst_4 : algebra R A] {r : R},	    bit1 r • 1 = bit1 (r • 1)", "decl_nm": "algebra.bit1_smul_one"
{"src": "R : Type u,	A : Type w,	_inst_1 : comm_semiring R,	_inst_3 : semiring A,	_inst_4 : algebra R A,	r : R	⊢ bit1 r • 1 = bit1 (r • 1)", "decl_nm": "algebra.bit1_smul_one"
{"src": "⊢ ∀ {α : Type u_1} [_inst_1 : comm_monoid α] (a : α) (n : ℕ), associates.mk (a ^ n) = associates.mk a ^ n", "decl_nm": "associates.mk_pow"
{"src": "α : Type u_1,	_inst_1 : comm_monoid α,	a : α,	n : ℕ	⊢ associates.mk (a ^ n) = associates.mk a ^ n", "decl_nm": "associates.mk_pow"
{"src": "2 goals	case nat.zero	α : Type u_1,	_inst_1 : comm_monoid α,	a : α	⊢ associates.mk (a ^ 0) = associates.mk a ^ 0		case nat.succ	α : Type u_1,	_inst_1 : comm_monoid α,	a : α,	n_n : ℕ,	n_ih : associates.mk (a ^ n_n) = associates.mk a ^ n_n	⊢ associates.mk (a ^ n_n.succ) = associates.mk a ^ n_n.succ", "decl_nm": "associates.mk_pow"
{"src": "case nat.succ	α : Type u_1,	_inst_1 : comm_monoid α,	a : α,	n_n : ℕ,	n_ih : associates.mk (a ^ n_n) = associates.mk a ^ n_n	⊢ associates.mk (a ^ n_n.succ) = associates.mk a ^ n_n.succ", "decl_nm": "associates.mk_pow"
{"src": "⊢ ∀ {β : Type u} {α : Type v} [_inst_1 : comm_monoid β] [_inst_2 : decidable_eq α] (s : finset α)	  (f : α → β) {a : α}, a ∈ s → (s.erase a).prod (λ (x : α), f x) * f a = s.prod (λ (x : α), f x)", "decl_nm": "finset.prod_erase_mul"
{"src": "β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	_inst_2 : decidable_eq α,	s : finset α,	f : α → β,	a : α,	h : a ∈ s	⊢ (s.erase a).prod (λ (x : α), f x) * f a = s.prod (λ (x : α), f x)", "decl_nm": "finset.prod_erase_mul"
{"src": "⊢ ∀ {β : Type u} {α : Type v} [_inst_1 : comm_monoid β] {s : finset α} {f : α → β} (a b : α),	    a ≠ b →	    (∀ (c : α), c ∈ s → c ≠ a ∧ c ≠ b → f c = 1) →	    (a ∉ s → f a = 1) → (b ∉ s → f b = 1) → s.prod (λ (x : α), f x) = f a * f b", "decl_nm": "finset.prod_eq_mul"
{"src": "β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	s : finset α,	f : α → β,	a b : α,	hn : a ≠ b,	h₀ : ∀ (c : α), c ∈ s → c ≠ a ∧ c ≠ b → f c = 1,	ha : a ∉ s → f a = 1,	hb : b ∉ s → f b = 1	⊢ s.prod (λ (x : α), f x) = f a * f b", "decl_nm": "finset.prod_eq_mul"
{"src": "β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	s : finset α,	f : α → β,	a b : α,	hn : a ≠ b,	h₀ : ∀ (c : α), c ∈ s → c ≠ a ∧ c ≠ b → f c = 1,	ha : a ∉ s → f a = 1,	hb : b ∉ s → f b = 1,	_inst : decidable_eq α	⊢ s.prod (λ (x : α), f x) = f a * f b", "decl_nm": "finset.prod_eq_mul"
{"src": "2 goals	β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	s : finset α,	f : α → β,	a b : α,	hn : a ≠ b,	h₀ : ∀ (c : α), c ∈ s → c ≠ a ∧ c ≠ b → f c = 1,	ha : a ∉ s → f a = 1,	hb : b ∉ s → f b = 1,	_inst : decidable_eq α,	h₁ : a ∈ s	⊢ s.prod (λ (x : α), f x) = f a * f b		β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	s : finset α,	f : α → β,	a b : α,	hn : a ≠ b,	h₀ : ∀ (c : α), c ∈ s → c ≠ a ∧ c ≠ b → f c = 1,	ha : a ∉ s → f a = 1,	hb : b ∉ s → f b = 1,	_inst : decidable_eq α,	h₁ : a ∉ s	⊢ s.prod (λ (x : α), f x) = f a * f b", "decl_nm": "finset.prod_eq_mul"
{"src": "3 goals	β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	s : finset α,	f : α → β,	a b : α,	hn : a ≠ b,	h₀ : ∀ (c : α), c ∈ s → c ≠ a ∧ c ≠ b → f c = 1,	ha : a ∉ s → f a = 1,	hb : b ∉ s → f b = 1,	_inst : decidable_eq α,	h₁ : a ∈ s,	h₂ : b ∈ s	⊢ s.prod (λ (x : α), f x) = f a * f b		β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	s : finset α,	f : α → β,	a b : α,	hn : a ≠ b,	h₀ : ∀ (c : α), c ∈ s → c ≠ a ∧ c ≠ b → f c = 1,	ha : a ∉ s → f a = 1,	hb : b ∉ s → f b = 1,	_inst : decidable_eq α,	h₁ : a ∈ s,	h₂ : b ∉ s	⊢ s.prod (λ (x : α), f x) = f a * f b		β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	s : finset α,	f : α → β,	a b : α,	hn : a ≠ b,	h₀ : ∀ (c : α), c ∈ s → c ≠ a ∧ c ≠ b → f c = 1,	ha : a ∉ s → f a = 1,	hb : b ∉ s → f b = 1,	_inst : decidable_eq α,	h₁ : a ∉ s	⊢ s.prod (λ (x : α), f x) = f a * f b", "decl_nm": "finset.prod_eq_mul"
{"src": "2 goals	β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	s : finset α,	f : α → β,	a b : α,	hn : a ≠ b,	h₀ : ∀ (c : α), c ∈ s → c ≠ a ∧ c ≠ b → f c = 1,	ha : a ∉ s → f a = 1,	hb : b ∉ s → f b = 1,	_inst : decidable_eq α,	h₁ : a ∈ s,	h₂ : b ∉ s	⊢ s.prod (λ (x : α), f x) = f a * f b		β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	s : finset α,	f : α → β,	a b : α,	hn : a ≠ b,	h₀ : ∀ (c : α), c ∈ s → c ≠ a ∧ c ≠ b → f c = 1,	ha : a ∉ s → f a = 1,	hb : b ∉ s → f b = 1,	_inst : decidable_eq α,	h₁ : a ∉ s	⊢ s.prod (λ (x : α), f x) = f a * f b", "decl_nm": "finset.prod_eq_mul"
{"src": "2 goals	β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	s : finset α,	f : α → β,	a b : α,	hn : a ≠ b,	h₀ : ∀ (c : α), c ∈ s → c ≠ a ∧ c ≠ b → f c = 1,	ha : a ∉ s → f a = 1,	hb : b ∉ s → f b = 1,	_inst : decidable_eq α,	h₁ : a ∈ s,	h₂ : b ∉ s	⊢ s.prod (λ (x : α), f x) = f a		β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	s : finset α,	f : α → β,	a b : α,	hn : a ≠ b,	h₀ : ∀ (c : α), c ∈ s → c ≠ a ∧ c ≠ b → f c = 1,	ha : a ∉ s → f a = 1,	hb : b ∉ s → f b = 1,	_inst : decidable_eq α,	h₁ : a ∉ s	⊢ s.prod (λ (x : α), f x) = f a * f b", "decl_nm": "finset.prod_eq_mul"
{"src": "2 goals	β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	s : finset α,	f : α → β,	a b : α,	hn : a ≠ b,	h₀ : ∀ (c : α), c ∈ s → c ≠ a ∧ c ≠ b → f c = 1,	ha : a ∉ s → f a = 1,	hb : b ∉ s → f b = 1,	_inst : decidable_eq α,	h₁ : a ∈ s,	h₂ : b ∉ s	⊢ ∀ (b : α), b ∈ s → b ≠ a → f b = 1		β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	s : finset α,	f : α → β,	a b : α,	hn : a ≠ b,	h₀ : ∀ (c : α), c ∈ s → c ≠ a ∧ c ≠ b → f c = 1,	ha : a ∉ s → f a = 1,	hb : b ∉ s → f b = 1,	_inst : decidable_eq α,	h₁ : a ∉ s	⊢ s.prod (λ (x : α), f x) = f a * f b", "decl_nm": "finset.prod_eq_mul"
{"src": "β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	s : finset α,	f : α → β,	a b : α,	hn : a ≠ b,	h₀ : ∀ (c : α), c ∈ s → c ≠ a ∧ c ≠ b → f c = 1,	ha : a ∉ s → f a = 1,	hb : b ∉ s → f b = 1,	_inst : decidable_eq α,	h₁ : a ∉ s	⊢ s.prod (λ (x : α), f x) = f a * f b", "decl_nm": "finset.prod_eq_mul"
{"src": "2 goals	β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	s : finset α,	f : α → β,	a b : α,	hn : a ≠ b,	h₀ : ∀ (c : α), c ∈ s → c ≠ a ∧ c ≠ b → f c = 1,	ha : a ∉ s → f a = 1,	hb : b ∉ s → f b = 1,	_inst : decidable_eq α,	h₁ : a ∉ s,	h₂ : b ∈ s	⊢ s.prod (λ (x : α), f x) = f a * f b		β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	s : finset α,	f : α → β,	a b : α,	hn : a ≠ b,	h₀ : ∀ (c : α), c ∈ s → c ≠ a ∧ c ≠ b → f c = 1,	ha : a ∉ s → f a = 1,	hb : b ∉ s → f b = 1,	_inst : decidable_eq α,	h₁ : a ∉ s,	h₂ : b ∉ s	⊢ s.prod (λ (x : α), f x) = f a * f b", "decl_nm": "finset.prod_eq_mul"
{"src": "2 goals	β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	s : finset α,	f : α → β,	a b : α,	hn : a ≠ b,	h₀ : ∀ (c : α), c ∈ s → c ≠ a ∧ c ≠ b → f c = 1,	ha : a ∉ s → f a = 1,	hb : b ∉ s → f b = 1,	_inst : decidable_eq α,	h₁ : a ∉ s,	h₂ : b ∈ s	⊢ s.prod (λ (x : α), f x) = f b		β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	s : finset α,	f : α → β,	a b : α,	hn : a ≠ b,	h₀ : ∀ (c : α), c ∈ s → c ≠ a ∧ c ≠ b → f c = 1,	ha : a ∉ s → f a = 1,	hb : b ∉ s → f b = 1,	_inst : decidable_eq α,	h₁ : a ∉ s,	h₂ : b ∉ s	⊢ s.prod (λ (x : α), f x) = f a * f b", "decl_nm": "finset.prod_eq_mul"
{"src": "2 goals	β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	s : finset α,	f : α → β,	a b : α,	hn : a ≠ b,	h₀ : ∀ (c : α), c ∈ s → c ≠ a ∧ c ≠ b → f c = 1,	ha : a ∉ s → f a = 1,	hb : b ∉ s → f b = 1,	_inst : decidable_eq α,	h₁ : a ∉ s,	h₂ : b ∈ s	⊢ ∀ (b_1 : α), b_1 ∈ s → b_1 ≠ b → f b_1 = 1		β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	s : finset α,	f : α → β,	a b : α,	hn : a ≠ b,	h₀ : ∀ (c : α), c ∈ s → c ≠ a ∧ c ≠ b → f c = 1,	ha : a ∉ s → f a = 1,	hb : b ∉ s → f b = 1,	_inst : decidable_eq α,	h₁ : a ∉ s,	h₂ : b ∉ s	⊢ s.prod (λ (x : α), f x) = f a * f b", "decl_nm": "finset.prod_eq_mul"
{"src": "β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	s : finset α,	f : α → β,	a b : α,	hn : a ≠ b,	h₀ : ∀ (c : α), c ∈ s → c ≠ a ∧ c ≠ b → f c = 1,	ha : a ∉ s → f a = 1,	hb : b ∉ s → f b = 1,	_inst : decidable_eq α,	h₁ : a ∉ s,	h₂ : b ∉ s	⊢ s.prod (λ (x : α), f x) = f a * f b", "decl_nm": "finset.prod_eq_mul"
{"src": "β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	s : finset α,	f : α → β,	a b : α,	hn : a ≠ b,	h₀ : ∀ (c : α), c ∈ s → c ≠ a ∧ c ≠ b → f c = 1,	ha : a ∉ s → f a = 1,	hb : b ∉ s → f b = 1,	_inst : decidable_eq α,	h₁ : a ∉ s,	h₂ : b ∉ s	⊢ s.prod (λ (x : α), f x) = 1", "decl_nm": "finset.prod_eq_mul"
{"src": "⊢ ∀ {β : Type u} {α : Type v} [_inst_1 : comm_monoid β] [_inst_2 : decidable_eq α] (s : finset α) (a : α)	  (b : Π (x : α), x = a → β),	    s.prod (λ (x : α), dite (x = a) (λ (h : x = a), b x h) (λ (h : ¬x = a), 1)) = ite (a ∈ s) (b a rfl) 1", "decl_nm": "finset.prod_dite_eq'"
{"src": "β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	_inst_2 : decidable_eq α,	s : finset α,	a : α,	b : Π (x : α), x = a → β	⊢ s.prod (λ (x : α), dite (x = a) (λ (h : x = a), b x h) (λ (h : ¬x = a), 1)) = ite (a ∈ s) (b a rfl) 1", "decl_nm": "finset.prod_dite_eq'"
{"src": "2 goals	β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	_inst_2 : decidable_eq α,	s : finset α,	a : α,	b : Π (x : α), x = a → β,	h : a ∈ s	⊢ s.prod (λ (x : α), dite (x = a) (b x) (λ (h : ¬x = a), 1)) = b a rfl		β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	_inst_2 : decidable_eq α,	s : finset α,	a : α,	b : Π (x : α), x = a → β,	h : a ∉ s	⊢ s.prod (λ (x : α), dite (x = a) (b x) (λ (h : ¬x = a), 1)) = 1", "decl_nm": "finset.prod_dite_eq'"
{"src": "3 goals	β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	_inst_2 : decidable_eq α,	s : finset α,	a : α,	b : Π (x : α), x = a → β,	h : a ∈ s	⊢ ∀ (b_1 : α), b_1 ∈ s → b_1 ≠ a → dite (b_1 = a) (b b_1) (λ (h : ¬b_1 = a), 1) = 1		β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	_inst_2 : decidable_eq α,	s : finset α,	a : α,	b : Π (x : α), x = a → β,	h : a ∈ s	⊢ a ∉ s → dite (a = a) (b a) (λ (h : ¬a = a), 1) = 1		β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	_inst_2 : decidable_eq α,	s : finset α,	a : α,	b : Π (x : α), x = a → β,	h : a ∉ s	⊢ s.prod (λ (x : α), dite (x = a) (b x) (λ (h : ¬x = a), 1)) = 1", "decl_nm": "finset.prod_dite_eq'"
{"src": "3 goals	β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	_inst_2 : decidable_eq α,	s : finset α,	a : α,	b : Π (x : α), x = a → β,	h : a ∈ s,	b_1 : α,	H : b_1 ∈ s,	ᾰ : b_1 ≠ a	⊢ dite (b_1 = a) (b b_1) (λ (h : ¬b_1 = a), 1) = 1		β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	_inst_2 : decidable_eq α,	s : finset α,	a : α,	b : Π (x : α), x = a → β,	h : a ∈ s	⊢ a ∉ s → dite (a = a) (b a) (λ (h : ¬a = a), 1) = 1		β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	_inst_2 : decidable_eq α,	s : finset α,	a : α,	b : Π (x : α), x = a → β,	h : a ∉ s	⊢ s.prod (λ (x : α), dite (x = a) (b x) (λ (h : ¬x = a), 1)) = 1", "decl_nm": "finset.prod_dite_eq'"
{"src": "3 goals	β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	_inst_2 : decidable_eq α,	s : finset α,	a : α,	b : Π (x : α), x = a → β,	h : a ∈ s,	b_1 : α,	H : b_1 ∈ s,	ᾰ : b_1 ≠ a	⊢ ¬b_1 = a		β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	_inst_2 : decidable_eq α,	s : finset α,	a : α,	b : Π (x : α), x = a → β,	h : a ∈ s	⊢ a ∉ s → dite (a = a) (b a) (λ (h : ¬a = a), 1) = 1		β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	_inst_2 : decidable_eq α,	s : finset α,	a : α,	b : Π (x : α), x = a → β,	h : a ∉ s	⊢ s.prod (λ (x : α), dite (x = a) (b x) (λ (h : ¬x = a), 1)) = 1", "decl_nm": "finset.prod_dite_eq'"
{"src": "2 goals	β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	_inst_2 : decidable_eq α,	s : finset α,	a : α,	b : Π (x : α), x = a → β,	h : a ∈ s	⊢ a ∉ s → dite (a = a) (b a) (λ (h : ¬a = a), 1) = 1		β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	_inst_2 : decidable_eq α,	s : finset α,	a : α,	b : Π (x : α), x = a → β,	h : a ∉ s	⊢ s.prod (λ (x : α), dite (x = a) (b x) (λ (h : ¬x = a), 1)) = 1", "decl_nm": "finset.prod_dite_eq'"
{"src": "β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	_inst_2 : decidable_eq α,	s : finset α,	a : α,	b : Π (x : α), x = a → β,	h : a ∉ s	⊢ s.prod (λ (x : α), dite (x = a) (b x) (λ (h : ¬x = a), 1)) = 1", "decl_nm": "finset.prod_dite_eq'"
{"src": "β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	_inst_2 : decidable_eq α,	s : finset α,	a : α,	b : Π (x : α), x = a → β,	h : a ∉ s	⊢ ∀ (x : α), x ∈ s → dite (x = a) (b x) (λ (h : ¬x = a), 1) = 1", "decl_nm": "finset.prod_dite_eq'"
{"src": "β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	_inst_2 : decidable_eq α,	s : finset α,	a : α,	b : Π (x : α), x = a → β,	h : a ∉ s,	x : α,	H : x ∈ s	⊢ dite (x = a) (b x) (λ (h : ¬x = a), 1) = 1", "decl_nm": "finset.prod_dite_eq'"
{"src": "β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	_inst_2 : decidable_eq α,	s : finset α,	a : α,	b : Π (x : α), x = a → β,	h : a ∉ s,	x : α,	H : x ∈ s	⊢ ¬x = a", "decl_nm": "finset.prod_dite_eq'"
{"src": "β : Type u,	α : Type v,	_inst_1 : comm_monoid β,	_inst_2 : decidable_eq α,	s : finset α,	a : α,	b : Π (x : α), x = a → β,	h : a ∉ s,	x : α,	H : x ∈ s,	ᾰ : x = a	⊢ false", "decl_nm": "finset.prod_dite_eq'"
{"src": "⊢ ∀ {M : Type u_1} [_inst_1 : add_comm_monoid M] {n : ℕ} {v : fin n.succ → M},	    (filter (λ (i : fin n.succ), 0 < i) univ).sum (λ (i : fin n.succ), v i) = univ.sum (λ (j : fin n), v j.succ)", "decl_nm": "fin.sum_filter_zero_lt"
{"src": "M : Type u_1,	_inst_1 : add_comm_monoid M,	n : ℕ,	v : fin n.succ → M	⊢ (filter (λ (i : fin n.succ), 0 < i) univ).sum (λ (i : fin n.succ), v i) = univ.sum (λ (j : fin n), v j.succ)", "decl_nm": "fin.sum_filter_zero_lt"
{"src": "⊢ ∀ {ι : Sort u_5} {R : Type u_1} {M : Type u_2} [_inst_3 : ring R] [_inst_4 : add_comm_group M]	  [_inst_5 : module R M] [_inst_6 : no_zero_smul_divisors R M] (f : ι → R) (x : M),	    finsum (λ (i : ι), f i) • x = finsum (λ (i : ι), f i • x)", "decl_nm": "finsum_smul"
{"src": "ι : Sort u_5,	R : Type u_1,	M : Type u_2,	_inst_3 : ring R,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	_inst_6 : no_zero_smul_divisors R M,	f : ι → R,	x : M	⊢ finsum (λ (i : ι), f i) • x = finsum (λ (i : ι), f i • x)", "decl_nm": "finsum_smul"
{"src": "2 goals	ι : Sort u_5,	R : Type u_1,	M : Type u_2,	_inst_3 : ring R,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	_inst_6 : no_zero_smul_divisors R M,	f : ι → R	⊢ finsum (λ (i : ι), f i) • 0 = finsum (λ (i : ι), f i • 0)		ι : Sort u_5,	R : Type u_1,	M : Type u_2,	_inst_3 : ring R,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	_inst_6 : no_zero_smul_divisors R M,	f : ι → R,	x : M,	hx : x ≠ 0	⊢ finsum (λ (i : ι), f i) • x = finsum (λ (i : ι), f i • x)", "decl_nm": "finsum_smul"
{"src": "ι : Sort u_5,	R : Type u_1,	M : Type u_2,	_inst_3 : ring R,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	_inst_6 : no_zero_smul_divisors R M,	f : ι → R,	x : M,	hx : x ≠ 0	⊢ finsum (λ (i : ι), f i) • x = finsum (λ (i : ι), f i • x)", "decl_nm": "finsum_smul"
{"src": "⊢ ∀ {α : Type u_1} {M : Type u_4} [_inst_1 : comm_monoid M] {f : α → M} {s t : set α},	    s.finite →	    t.finite →	    finprod (λ (i : α), finprod (λ (H : i ∈ s ∪ t), f i)) *	        finprod (λ (i : α), finprod (λ (H : i ∈ s ∩ t), f i)) =	      finprod (λ (i : α), finprod (λ (H : i ∈ s), f i)) * finprod (λ (i : α), finprod (λ (H : i ∈ t), f i))", "decl_nm": "finprod_mem_union_inter"
{"src": "α : Type u_1,	M : Type u_4,	_inst_1 : comm_monoid M,	f : α → M,	s t : set α,	hs : s.finite,	ht : t.finite	⊢ finprod (λ (i : α), finprod (λ (H : i ∈ s ∪ t), f i)) *	      finprod (λ (i : α), finprod (λ (H : i ∈ s ∩ t), f i)) =	    finprod (λ (i : α), finprod (λ (H : i ∈ s), f i)) * finprod (λ (i : α), finprod (λ (H : i ∈ t), f i))", "decl_nm": "finprod_mem_union_inter"
{"src": "α : Type u_1,	M : Type u_4,	_inst_1 : comm_monoid M,	f : α → M,	t : set α,	ht : t.finite,	s : finset α	⊢ finprod (λ (i : α), finprod (λ (H : i ∈ ↑s ∪ t), f i)) *	      finprod (λ (i : α), finprod (λ (H : i ∈ ↑s ∩ t), f i)) =	    finprod (λ (i : α), finprod (λ (H : i ∈ ↑s), f i)) * finprod (λ (i : α), finprod (λ (H : i ∈ t), f i))", "decl_nm": "finprod_mem_union_inter"
{"src": "α : Type u_1,	M : Type u_4,	_inst_1 : comm_monoid M,	f : α → M,	s t : finset α	⊢ finprod (λ (i : α), finprod (λ (H : i ∈ ↑s ∪ ↑t), f i)) *	      finprod (λ (i : α), finprod (λ (H : i ∈ ↑s ∩ ↑t), f i)) =	    finprod (λ (i : α), finprod (λ (H : i ∈ ↑s), f i)) *	      finprod (λ (i : α), finprod (λ (H : i ∈ ↑t), f i))", "decl_nm": "finprod_mem_union_inter"
{"src": "α : Type u_1,	M : Type u_4,	_inst_1 : comm_monoid M,	f : α → M,	s t : finset α,	_inst : Π (a : Prop), decidable a	⊢ finprod (λ (i : α), finprod (λ (H : i ∈ ↑s ∪ ↑t), f i)) *	      finprod (λ (i : α), finprod (λ (H : i ∈ ↑s ∩ ↑t), f i)) =	    finprod (λ (i : α), finprod (λ (H : i ∈ ↑s), f i)) *	      finprod (λ (i : α), finprod (λ (H : i ∈ ↑t), f i))", "decl_nm": "finprod_mem_union_inter"
{"src": "α : Type u_1,	M : Type u_4,	_inst_1 : comm_monoid M,	f : α → M,	s t : finset α,	_inst : Π (a : Prop), decidable a	⊢ finprod (λ (i : α), finprod (λ (H : i ∈ ↑(s ∪ t)), f i)) *	      finprod (λ (i : α), finprod (λ (H : i ∈ ↑(s ∩ t)), f i)) =	    finprod (λ (i : α), finprod (λ (H : i ∈ ↑s), f i)) *	      finprod (λ (i : α), finprod (λ (H : i ∈ ↑t), f i))", "decl_nm": "finprod_mem_union_inter"
{"src": "⊢ ∀ {M : Type u_1} [_inst_1 : comm_monoid M] {n : ℕ} {f : ℕ × ℕ → M},	    (nat.antidiagonal (n + 1)).prod (λ (p : ℕ × ℕ), f p) =	      f (n + 1, 0) * (nat.antidiagonal n).prod (λ (p : ℕ × ℕ), f (p.fst, p.snd + 1))", "decl_nm": "finset.nat.prod_antidiagonal_succ'"
{"src": "M : Type u_1,	_inst_1 : comm_monoid M,	n : ℕ,	f : ℕ × ℕ → M	⊢ (nat.antidiagonal (n + 1)).prod (λ (p : ℕ × ℕ), f p) =	    f (n + 1, 0) * (nat.antidiagonal n).prod (λ (p : ℕ × ℕ), f (p.fst, p.snd + 1))", "decl_nm": "finset.nat.prod_antidiagonal_succ'"
{"src": "M : Type u_1,	_inst_1 : comm_monoid M,	n : ℕ,	f : ℕ × ℕ → M	⊢ f (0, n + 1).swap * (nat.antidiagonal n).prod (λ (p : ℕ × ℕ), f (p.swap.fst + 1, p.swap.snd).swap) =	    f (n + 1, 0) * (nat.antidiagonal n).prod (λ (p : ℕ × ℕ), f (p.fst, p.snd + 1))", "decl_nm": "finset.nat.prod_antidiagonal_succ'"
{"src": "⊢ ∀ {ι : Type u_1} {N : Type u_5} [_inst_2 : ordered_comm_monoid N] (s : finset ι) (f : ι → N) (n : N),	    (∀ (x : ι), x ∈ s → f x ≤ n) → s.prod f ≤ n ^ s.card", "decl_nm": "finset.prod_le_of_forall_le"
{"src": "ι : Type u_1,	N : Type u_5,	_inst_2 : ordered_comm_monoid N,	s : finset ι,	f : ι → N,	n : N,	h : ∀ (x : ι), x ∈ s → f x ≤ n	⊢ s.prod f ≤ n ^ s.card", "decl_nm": "finset.prod_le_of_forall_le"
{"src": "2 goals	ι : Type u_1,	N : Type u_5,	_inst_2 : ordered_comm_monoid N,	s : finset ι,	f : ι → N,	n : N,	h : ∀ (x : ι), x ∈ s → f x ≤ n	⊢ ∀ (x : N), x ∈ multiset.map f s.val → x ≤ n		ι : Type u_1,	N : Type u_5,	_inst_2 : ordered_comm_monoid N,	s : finset ι,	f : ι → N,	n : N,	h : ∀ (x : ι), x ∈ s → f x ≤ n	⊢ n ^ ⇑multiset.card (multiset.map f s.val) ≤ n ^ s.card", "decl_nm": "finset.prod_le_of_forall_le"
{"src": "ι : Type u_1,	N : Type u_5,	_inst_2 : ordered_comm_monoid N,	s : finset ι,	f : ι → N,	n : N,	h : ∀ (x : ι), x ∈ s → f x ≤ n	⊢ n ^ ⇑multiset.card (multiset.map f s.val) ≤ n ^ s.card", "decl_nm": "finset.prod_le_of_forall_le"
{"src": "⊢ ∀ {ι : Type u_1} {M : Type u_4} [_inst_1 : ordered_add_comm_monoid M] {s : finset ι} {f : ι → with_top M},	    s.sum (λ (i : ι), f i) < ⊤ ↔ ∀ (i : ι), i ∈ s → f i < ⊤", "decl_nm": "with_top.sum_lt_top_iff"
{"src": "ι : Type u_1,	M : Type u_4,	_inst_1 : ordered_add_comm_monoid M,	s : finset ι,	f : ι → with_top M	⊢ s.sum (λ (i : ι), f i) < ⊤ ↔ ∀ (i : ι), i ∈ s → f i < ⊤", "decl_nm": "with_top.sum_lt_top_iff"
{"src": "⊢ ∀ {R : Type u} [_inst_1 : ring R] {G H : Module R} (f : G ⟶ H),	    cokernel.π f ≫ (cokernel_iso_range_quotient f).hom = (linear_map.range f).mkq", "decl_nm": "Module.cokernel_π_cokernel_iso_range_quotient_hom"
{"src": "R : Type u,	_inst_1 : ring R,	G H : Module R,	f : G ⟶ H	⊢ cokernel.π f ≫ (cokernel_iso_range_quotient f).hom = (linear_map.range f).mkq", "decl_nm": "Module.cokernel_π_cokernel_iso_range_quotient_hom"
{"src": "5 goals	R : Type u,	_inst_1 : ring R,	G H : Module R,	f : G ⟶ H	⊢ H = (parallel_pair f 0).obj walking_parallel_pair.one		R : Type u,	_inst_1 : ring R,	G H : Module R,	f : G ⟶ H	⊢ of R (↥H ⧸ linear_map.range f) = {cocone := cokernel_cocone f, is_colimit := cokernel_is_colimit f}.cocone.X		R : Type u,	_inst_1 : ring R,	G H : Module R,	f : G ⟶ H	⊢ H = (parallel_pair f 0).obj walking_parallel_pair.one		R : Type u,	_inst_1 : ring R,	G H : Module R,	f : G ⟶ H	⊢ of R (↥H ⧸ linear_map.range f) = {cocone := cokernel_cocone f, is_colimit := cokernel_is_colimit f}.cocone.X		R : Type u,	_inst_1 : ring R,	G H : Module R,	f : G ⟶ H	⊢ of R (↥H ⧸ linear_map.range f) = {cocone := cokernel_cocone f, is_colimit := cokernel_is_colimit f}.cocone.X", "decl_nm": "Module.cokernel_π_cokernel_iso_range_quotient_hom"
{"src": "4 goals	R : Type u,	_inst_1 : ring R,	G H : Module R,	f : G ⟶ H	⊢ of R (↥H ⧸ linear_map.range f) = {cocone := cokernel_cocone f, is_colimit := cokernel_is_colimit f}.cocone.X		R : Type u,	_inst_1 : ring R,	G H : Module R,	f : G ⟶ H	⊢ H = (parallel_pair f 0).obj walking_parallel_pair.one		R : Type u,	_inst_1 : ring R,	G H : Module R,	f : G ⟶ H	⊢ of R (↥H ⧸ linear_map.range f) = {cocone := cokernel_cocone f, is_colimit := cokernel_is_colimit f}.cocone.X		R : Type u,	_inst_1 : ring R,	G H : Module R,	f : G ⟶ H	⊢ of R (↥H ⧸ linear_map.range f) = {cocone := cokernel_cocone f, is_colimit := cokernel_is_colimit f}.cocone.X", "decl_nm": "Module.cokernel_π_cokernel_iso_range_quotient_hom"
{"src": "3 goals	R : Type u,	_inst_1 : ring R,	G H : Module R,	f : G ⟶ H	⊢ H = (parallel_pair f 0).obj walking_parallel_pair.one		R : Type u,	_inst_1 : ring R,	G H : Module R,	f : G ⟶ H	⊢ of R (↥H ⧸ linear_map.range f) = {cocone := cokernel_cocone f, is_colimit := cokernel_is_colimit f}.cocone.X		R : Type u,	_inst_1 : ring R,	G H : Module R,	f : G ⟶ H	⊢ of R (↥H ⧸ linear_map.range f) = {cocone := cokernel_cocone f, is_colimit := cokernel_is_colimit f}.cocone.X", "decl_nm": "Module.cokernel_π_cokernel_iso_range_quotient_hom"
{"src": "2 goals	R : Type u,	_inst_1 : ring R,	G H : Module R,	f : G ⟶ H	⊢ of R (↥H ⧸ linear_map.range f) = {cocone := cokernel_cocone f, is_colimit := cokernel_is_colimit f}.cocone.X		R : Type u,	_inst_1 : ring R,	G H : Module R,	f : G ⟶ H	⊢ of R (↥H ⧸ linear_map.range f) = {cocone := cokernel_cocone f, is_colimit := cokernel_is_colimit f}.cocone.X", "decl_nm": "Module.cokernel_π_cokernel_iso_range_quotient_hom"
{"src": "R : Type u,	_inst_1 : ring R,	G H : Module R,	f : G ⟶ H	⊢ of R (↥H ⧸ linear_map.range f) = {cocone := cokernel_cocone f, is_colimit := cokernel_is_colimit f}.cocone.X", "decl_nm": "Module.cokernel_π_cokernel_iso_range_quotient_hom"
{"src": "⊢ ∀ (R : Type u) [_inst_1 : semiring R] {p : ℕ} [_inst_2 : fact (nat.prime p)] [_inst_3 : char_p R p] (x y : R),	    commute x y → (x + y) ^ p = x ^ p + y ^ p", "decl_nm": "add_pow_char_of_commute"
{"src": "R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y	⊢ (x + y) ^ p = x ^ p + y ^ p", "decl_nm": "add_pow_char_of_commute"
{"src": "R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y	⊢ x ^ p * 1 * ↑1 + (finset.range p).sum (λ (x_1 : ℕ), x ^ x_1 * y ^ (p - x_1) * ↑(p.choose x_1)) =	    x ^ p + y ^ p", "decl_nm": "add_pow_char_of_commute"
{"src": "R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y	⊢ x ^ p + (finset.range p).sum (λ (x_1 : ℕ), x ^ x_1 * y ^ (p - x_1) * ↑(p.choose x_1)) = x ^ p + y ^ p", "decl_nm": "add_pow_char_of_commute"
{"src": "R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y	⊢ (finset.range p).sum (λ (x_1 : ℕ), x ^ x_1 * y ^ (p - x_1) * ↑(p.choose x_1)) = y ^ p", "decl_nm": "add_pow_char_of_commute"
{"src": "3 goals	R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y	⊢ y ^ p = x ^ 0 * y ^ (p - 0) * ↑(p.choose 0)		R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y	⊢ ∀ (b : ℕ), b ∈ finset.range p → b ≠ 0 → x ^ b * y ^ (p - b) * ↑(p.choose b) = 0		R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y	⊢ 0 ∉ finset.range p → x ^ 0 * y ^ (p - 0) * ↑(p.choose 0) = 0", "decl_nm": "add_pow_char_of_commute"
{"src": "2 goals	R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y	⊢ ∀ (b : ℕ), b ∈ finset.range p → b ≠ 0 → x ^ b * y ^ (p - b) * ↑(p.choose b) = 0		R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y	⊢ 0 ∉ finset.range p → x ^ 0 * y ^ (p - 0) * ↑(p.choose 0) = 0", "decl_nm": "add_pow_char_of_commute"
{"src": "2 goals	R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y,	b : ℕ,	h1 : b ∈ finset.range p,	h2 : b ≠ 0	⊢ x ^ b * y ^ (p - b) * ↑(p.choose b) = 0		R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y	⊢ 0 ∉ finset.range p → x ^ 0 * y ^ (p - 0) * ↑(p.choose 0) = 0", "decl_nm": "add_pow_char_of_commute"
{"src": "3 goals	R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y,	b : ℕ,	h1 : b ∈ finset.range p,	h2 : b ≠ 0,	this : ↑(p.choose b) = 0	⊢ x ^ b * y ^ (p - b) * ↑(p.choose b) = 0		R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y,	b : ℕ,	h1 : b ∈ finset.range p,	h2 : b ≠ 0	⊢ ↑(p.choose b) = 0		R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y	⊢ 0 ∉ finset.range p → x ^ 0 * y ^ (p - 0) * ↑(p.choose 0) = 0", "decl_nm": "add_pow_char_of_commute"
{"src": "3 goals	R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y,	b : ℕ,	h1 : b ∈ finset.range p,	h2 : b ≠ 0,	this : ↑(p.choose b) = 0	⊢ x ^ b * y ^ (p - b) * 0 = 0		R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y,	b : ℕ,	h1 : b ∈ finset.range p,	h2 : b ≠ 0	⊢ ↑(p.choose b) = 0		R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y	⊢ 0 ∉ finset.range p → x ^ 0 * y ^ (p - 0) * ↑(p.choose 0) = 0", "decl_nm": "add_pow_char_of_commute"
{"src": "2 goals	R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y,	b : ℕ,	h1 : b ∈ finset.range p,	h2 : b ≠ 0	⊢ ↑(p.choose b) = 0		R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y	⊢ 0 ∉ finset.range p → x ^ 0 * y ^ (p - 0) * ↑(p.choose 0) = 0", "decl_nm": "add_pow_char_of_commute"
{"src": "2 goals	R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y,	b : ℕ,	h1 : b ∈ finset.range p,	h2 : b ≠ 0	⊢ p ∣ p.choose b		R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y	⊢ 0 ∉ finset.range p → x ^ 0 * y ^ (p - 0) * ↑(p.choose 0) = 0", "decl_nm": "add_pow_char_of_commute"
{"src": "2 goals	R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y,	b : ℕ,	h1 : b ∈ finset.range p,	h2 : b ≠ 0	⊢ b < p		R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y	⊢ 0 ∉ finset.range p → x ^ 0 * y ^ (p - 0) * ↑(p.choose 0) = 0", "decl_nm": "add_pow_char_of_commute"
{"src": "R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y	⊢ 0 ∉ finset.range p → x ^ 0 * y ^ (p - 0) * ↑(p.choose 0) = 0", "decl_nm": "add_pow_char_of_commute"
{"src": "R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y,	h1 : 0 ∉ finset.range p	⊢ x ^ 0 * y ^ (p - 0) * ↑(p.choose 0) = 0", "decl_nm": "add_pow_char_of_commute"
{"src": "R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y,	h1 : x ^ 0 * y ^ (p - 0) * ↑(p.choose 0) ≠ 0	⊢ 0 ∈ finset.range p", "decl_nm": "add_pow_char_of_commute"
{"src": "R : Type u,	_inst_1 : semiring R,	p : ℕ,	_inst_2 : fact (nat.prime p),	_inst_3 : char_p R p,	x y : R,	h : commute x y,	h1 : x ^ 0 * y ^ (p - 0) * ↑(p.choose 0) ≠ 0	⊢ 0 < p", "decl_nm": "add_pow_char_of_commute"
{"src": "⊢ ∀ {α : Type u_1} [_inst_1 : monoid α] {a b u : α}, is_unit u → (a ∣ b * u ↔ a ∣ b)", "decl_nm": "is_unit.dvd_mul_right"
{"src": "α : Type u_1,	_inst_1 : monoid α,	a b u : α,	hu : is_unit u	⊢ a ∣ b * u ↔ a ∣ b", "decl_nm": "is_unit.dvd_mul_right"
{"src": "α : Type u_1,	_inst_1 : monoid α,	a b : α,	u : αˣ	⊢ a ∣ b * ↑u ↔ a ∣ b", "decl_nm": "is_unit.dvd_mul_right"
{"src": "⊢ ∀ {α : Type u} [_inst_1 : division_ring α] {x : α},	    x ≠ 1 → ∀ {m n : ℕ}, m ≤ n → (Ico m n).sum (λ (i : ℕ), x ^ i) = (x ^ m - x ^ n) / (1 - x)", "decl_nm": "geom_sum_Ico'"
{"src": "α : Type u,	_inst_1 : division_ring α,	x : α,	hx : x ≠ 1,	m n : ℕ,	hmn : m ≤ n	⊢ (Ico m n).sum (λ (i : ℕ), x ^ i) = (x ^ m - x ^ n) / (1 - x)", "decl_nm": "geom_sum_Ico'"
{"src": "α : Type u,	_inst_1 : division_ring α,	x : α,	hx : x ≠ 1,	m n : ℕ,	hmn : m ≤ n	⊢ (x ^ n - x ^ m) / (x - 1) = (x ^ m - x ^ n) / (1 - x)", "decl_nm": "geom_sum_Ico'"
{"src": "2 goals	α : Type u,	_inst_1 : division_ring α,	x : α,	hx : x ≠ 1,	m n : ℕ,	hmn : m ≤ n	⊢ x ^ n - x ^ m = -(x ^ m - x ^ n)		α : Type u,	_inst_1 : division_ring α,	x : α,	hx : x ≠ 1,	m n : ℕ,	hmn : m ≤ n	⊢ x - 1 = -(1 - x)", "decl_nm": "geom_sum_Ico'"
{"src": "α : Type u,	_inst_1 : division_ring α,	x : α,	hx : x ≠ 1,	m n : ℕ,	hmn : m ≤ n	⊢ x - 1 = -(1 - x)", "decl_nm": "geom_sum_Ico'"
{"src": "⊢ ∀ {G : Type u} [_inst_1 : add_comm_group G] {a b c d : G}, a - b = c - d ↔ a - c = b - d", "decl_nm": "sub_eq_sub_iff_sub_eq_sub"
{"src": "G : Type u,	_inst_1 : add_comm_group G,	a b c d : G	⊢ a - b = c - d ↔ a - c = b - d", "decl_nm": "sub_eq_sub_iff_sub_eq_sub"
{"src": "⊢ ∀ {M : Type u} [_inst_1 : mul_one_class M] {P : Prop} [_inst_2 : decidable P] {a b : M},	    ite P (a * b) 1 = ite P a 1 * ite P b 1", "decl_nm": "ite_mul_one"
{"src": "M : Type u,	_inst_1 : mul_one_class M,	P : Prop,	_inst_2 : decidable P,	a b : M	⊢ ite P (a * b) 1 = ite P a 1 * ite P b 1", "decl_nm": "ite_mul_one"
{"src": "2 goals	M : Type u,	_inst_1 : mul_one_class M,	P : Prop,	_inst_2 : decidable P,	a b : M,	h : P	⊢ ite P (a * b) 1 = ite P a 1 * ite P b 1		M : Type u,	_inst_1 : mul_one_class M,	P : Prop,	_inst_2 : decidable P,	a b : M,	h : ¬P	⊢ ite P (a * b) 1 = ite P a 1 * ite P b 1", "decl_nm": "ite_mul_one"
{"src": "M : Type u,	_inst_1 : mul_one_class M,	P : Prop,	_inst_2 : decidable P,	a b : M,	h : ¬P	⊢ ite P (a * b) 1 = ite P a 1 * ite P b 1", "decl_nm": "ite_mul_one"
{"src": "⊢ ∀ {M : Type u_1} ⦃m₁ m₂ : div_inv_monoid M⦄,	    div_inv_monoid.mul = div_inv_monoid.mul → div_inv_monoid.inv = div_inv_monoid.inv → m₁ = m₂", "decl_nm": "div_inv_monoid.ext"
{"src": "M : Type u_1,	m₁ m₂ : div_inv_monoid M,	h_mul : div_inv_monoid.mul = div_inv_monoid.mul,	h_inv : div_inv_monoid.inv = div_inv_monoid.inv	⊢ m₁ = m₂", "decl_nm": "div_inv_monoid.ext"
{"src": "M : Type u_1,	m₁ m₂ : div_inv_monoid M,	h_mul : div_inv_monoid.mul = div_inv_monoid.mul,	h_inv : div_inv_monoid.inv = div_inv_monoid.inv,	iM : div_inv_monoid M := m₁	⊢ m₁ = m₂", "decl_nm": "div_inv_monoid.ext"
{"src": "M : Type u_1,	m₂ : div_inv_monoid M,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	h_mul : div_inv_monoid.mul = div_inv_monoid.mul,	h_inv : div_inv_monoid.inv = div_inv_monoid.inv,	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁}	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₁,	     zpow := gpow₁,	     zpow_zero' := gpow_zero'₁,	     zpow_succ' := gpow_succ'₁,	     zpow_neg' := gpow_neg'₁} =	    m₂", "decl_nm": "div_inv_monoid.ext"
{"src": "M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	mul₂ : M → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₂ : M,	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow₂ : ℕ → M → M,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₂ : M → M,	div₂ : M → M → M,	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₂ : ℤ → M → M,	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	h_mul : div_inv_monoid.mul = div_inv_monoid.mul,	h_inv : div_inv_monoid.inv = div_inv_monoid.inv	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₁,	     zpow := gpow₁,	     zpow_zero' := gpow_zero'₁,	     zpow_succ' := gpow_succ'₁,	     zpow_neg' := gpow_neg'₁} =	    {mul := mul₂,	     mul_assoc := m₂_mul_assoc,	     one := one₂,	     one_mul := one_mul₂,	     mul_one := mul_one₂,	     npow := npow₂,	     npow_zero' := npow_zero₂,	     npow_succ' := npow_succ₂,	     inv := inv₂,	     div := div₂,	     div_eq_mul_inv := div_eq_mul_inv₂,	     zpow := gpow₂,	     zpow_zero' := gpow_zero'₂,	     zpow_succ' := gpow_succ'₂,	     zpow_neg' := gpow_neg'₂}", "decl_nm": "div_inv_monoid.ext"
{"src": "M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	mul₂ : M → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₂ : M,	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow₂ : ℕ → M → M,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₂ : M → M,	div₂ : M → M → M,	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₂ : ℤ → M → M,	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	h_inv : div_inv_monoid.inv = div_inv_monoid.inv,	h_mul : mul₁ = mul₂	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₁,	     zpow := gpow₁,	     zpow_zero' := gpow_zero'₁,	     zpow_succ' := gpow_succ'₁,	     zpow_neg' := gpow_neg'₁} =	    {mul := mul₂,	     mul_assoc := m₂_mul_assoc,	     one := one₂,	     one_mul := one_mul₂,	     mul_one := mul_one₂,	     npow := npow₂,	     npow_zero' := npow_zero₂,	     npow_succ' := npow_succ₂,	     inv := inv₂,	     div := div₂,	     div_eq_mul_inv := div_eq_mul_inv₂,	     zpow := gpow₂,	     zpow_zero' := gpow_zero'₂,	     zpow_succ' := gpow_succ'₂,	     zpow_neg' := gpow_neg'₂}", "decl_nm": "div_inv_monoid.ext"
{"src": "M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	one₂ : M,	npow₂ : ℕ → M → M,	inv₂ : M → M,	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	h_inv : div_inv_monoid.inv = div_inv_monoid.inv	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₁,	     zpow := gpow₁,	     zpow_zero' := gpow_zero'₁,	     zpow_succ' := gpow_succ'₁,	     zpow_neg' := gpow_neg'₁} =	    {mul := mul₁,	     mul_assoc := m₂_mul_assoc,	     one := one₂,	     one_mul := one_mul₂,	     mul_one := mul_one₂,	     npow := npow₂,	     npow_zero' := npow_zero₂,	     npow_succ' := npow_succ₂,	     inv := inv₂,	     div := div₂,	     div_eq_mul_inv := div_eq_mul_inv₂,	     zpow := gpow₂,	     zpow_zero' := gpow_zero'₂,	     zpow_succ' := gpow_succ'₂,	     zpow_neg' := gpow_neg'₂}", "decl_nm": "div_inv_monoid.ext"
{"src": "2 goals	M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	one₂ : M,	npow₂ : ℕ → M → M,	inv₂ : M → M,	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	h_inv : div_inv_monoid.inv = div_inv_monoid.inv	⊢ one₁ = one₂		M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	one₂ : M,	npow₂ : ℕ → M → M,	inv₂ : M → M,	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	h_inv : div_inv_monoid.inv = div_inv_monoid.inv,	h_one : one₁ = one₂	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₁,	     zpow := gpow₁,	     zpow_zero' := gpow_zero'₁,	     zpow_succ' := gpow_succ'₁,	     zpow_neg' := gpow_neg'₁} =	    {mul := mul₁,	     mul_assoc := m₂_mul_assoc,	     one := one₂,	     one_mul := one_mul₂,	     mul_one := mul_one₂,	     npow := npow₂,	     npow_zero' := npow_zero₂,	     npow_succ' := npow_succ₂,	     inv := inv₂,	     div := div₂,	     div_eq_mul_inv := div_eq_mul_inv₂,	     zpow := gpow₂,	     zpow_zero' := gpow_zero'₂,	     zpow_succ' := gpow_succ'₂,	     zpow_neg' := gpow_neg'₂}", "decl_nm": "div_inv_monoid.ext"
{"src": "2 goals	M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	one₂ : M,	npow₂ : ℕ → M → M,	inv₂ : M → M,	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	h_inv : div_inv_monoid.inv = div_inv_monoid.inv	⊢ 1 * one₁ = one₂		M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	one₂ : M,	npow₂ : ℕ → M → M,	inv₂ : M → M,	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	h_inv : div_inv_monoid.inv = div_inv_monoid.inv,	h_one : one₁ = one₂	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₁,	     zpow := gpow₁,	     zpow_zero' := gpow_zero'₁,	     zpow_succ' := gpow_succ'₁,	     zpow_neg' := gpow_neg'₁} =	    {mul := mul₁,	     mul_assoc := m₂_mul_assoc,	     one := one₂,	     one_mul := one_mul₂,	     mul_one := mul_one₂,	     npow := npow₂,	     npow_zero' := npow_zero₂,	     npow_succ' := npow_succ₂,	     inv := inv₂,	     div := div₂,	     div_eq_mul_inv := div_eq_mul_inv₂,	     zpow := gpow₂,	     zpow_zero' := gpow_zero'₂,	     zpow_succ' := gpow_succ'₂,	     zpow_neg' := gpow_neg'₂}", "decl_nm": "div_inv_monoid.ext"
{"src": "M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	one₂ : M,	npow₂ : ℕ → M → M,	inv₂ : M → M,	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	h_inv : div_inv_monoid.inv = div_inv_monoid.inv,	h_one : one₁ = one₂	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₁,	     zpow := gpow₁,	     zpow_zero' := gpow_zero'₁,	     zpow_succ' := gpow_succ'₁,	     zpow_neg' := gpow_neg'₁} =	    {mul := mul₁,	     mul_assoc := m₂_mul_assoc,	     one := one₂,	     one_mul := one_mul₂,	     mul_one := mul_one₂,	     npow := npow₂,	     npow_zero' := npow_zero₂,	     npow_succ' := npow_succ₂,	     inv := inv₂,	     div := div₂,	     div_eq_mul_inv := div_eq_mul_inv₂,	     zpow := gpow₂,	     zpow_zero' := gpow_zero'₂,	     zpow_succ' := gpow_succ'₂,	     zpow_neg' := gpow_neg'₂}", "decl_nm": "div_inv_monoid.ext"
{"src": "M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	npow₂ : ℕ → M → M,	inv₂ : M → M,	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	h_inv : div_inv_monoid.inv = div_inv_monoid.inv	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₁,	     zpow := gpow₁,	     zpow_zero' := gpow_zero'₁,	     zpow_succ' := gpow_succ'₁,	     zpow_neg' := gpow_neg'₁} =	    {mul := mul₁,	     mul_assoc := m₂_mul_assoc,	     one := one₁,	     one_mul := one_mul₂,	     mul_one := mul_one₂,	     npow := npow₂,	     npow_zero' := npow_zero₂,	     npow_succ' := npow_succ₂,	     inv := inv₂,	     div := div₂,	     div_eq_mul_inv := div_eq_mul_inv₂,	     zpow := gpow₂,	     zpow_zero' := gpow_zero'₂,	     zpow_succ' := gpow_succ'₂,	     zpow_neg' := gpow_neg'₂}", "decl_nm": "div_inv_monoid.ext"
{"src": "2 goals	M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	npow₂ : ℕ → M → M,	inv₂ : M → M,	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	h_inv : div_inv_monoid.inv = div_inv_monoid.inv	⊢ npow₁ = npow₂		M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	npow₂ : ℕ → M → M,	inv₂ : M → M,	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	h_inv : div_inv_monoid.inv = div_inv_monoid.inv,	h_npow : npow₁ = npow₂	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₁,	     zpow := gpow₁,	     zpow_zero' := gpow_zero'₁,	     zpow_succ' := gpow_succ'₁,	     zpow_neg' := gpow_neg'₁} =	    {mul := mul₁,	     mul_assoc := m₂_mul_assoc,	     one := one₁,	     one_mul := one_mul₂,	     mul_one := mul_one₂,	     npow := npow₂,	     npow_zero' := npow_zero₂,	     npow_succ' := npow_succ₂,	     inv := inv₂,	     div := div₂,	     div_eq_mul_inv := div_eq_mul_inv₂,	     zpow := gpow₂,	     zpow_zero' := gpow_zero'₂,	     zpow_succ' := gpow_succ'₂,	     zpow_neg' := gpow_neg'₂}", "decl_nm": "div_inv_monoid.ext"
{"src": "2 goals	M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	npow₂ : ℕ → M → M,	inv₂ : M → M,	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	h_inv : div_inv_monoid.inv = div_inv_monoid.inv,	n : ℕ,	x : M	⊢ npow₁ n x = npow₂ n x		M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	npow₂ : ℕ → M → M,	inv₂ : M → M,	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	h_inv : div_inv_monoid.inv = div_inv_monoid.inv,	h_npow : npow₁ = npow₂	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₁,	     zpow := gpow₁,	     zpow_zero' := gpow_zero'₁,	     zpow_succ' := gpow_succ'₁,	     zpow_neg' := gpow_neg'₁} =	    {mul := mul₁,	     mul_assoc := m₂_mul_assoc,	     one := one₁,	     one_mul := one_mul₂,	     mul_one := mul_one₂,	     npow := npow₂,	     npow_zero' := npow_zero₂,	     npow_succ' := npow_succ₂,	     inv := inv₂,	     div := div₂,	     div_eq_mul_inv := div_eq_mul_inv₂,	     zpow := gpow₂,	     zpow_zero' := gpow_zero'₂,	     zpow_succ' := gpow_succ'₂,	     zpow_neg' := gpow_neg'₂}", "decl_nm": "div_inv_monoid.ext"
{"src": "3 goals	case nat.zero	M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	npow₂ : ℕ → M → M,	inv₂ : M → M,	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	h_inv : div_inv_monoid.inv = div_inv_monoid.inv,	x : M	⊢ npow₁ 0 x = npow₂ 0 x		case nat.succ	M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	npow₂ : ℕ → M → M,	inv₂ : M → M,	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	h_inv : div_inv_monoid.inv = div_inv_monoid.inv,	x : M,	d : ℕ,	hd : npow₁ d x = npow₂ d x	⊢ npow₁ d.succ x = npow₂ d.succ x		M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	npow₂ : ℕ → M → M,	inv₂ : M → M,	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	h_inv : div_inv_monoid.inv = div_inv_monoid.inv,	h_npow : npow₁ = npow₂	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₁,	     zpow := gpow₁,	     zpow_zero' := gpow_zero'₁,	     zpow_succ' := gpow_succ'₁,	     zpow_neg' := gpow_neg'₁} =	    {mul := mul₁,	     mul_assoc := m₂_mul_assoc,	     one := one₁,	     one_mul := one_mul₂,	     mul_one := mul_one₂,	     npow := npow₂,	     npow_zero' := npow_zero₂,	     npow_succ' := npow_succ₂,	     inv := inv₂,	     div := div₂,	     div_eq_mul_inv := div_eq_mul_inv₂,	     zpow := gpow₂,	     zpow_zero' := gpow_zero'₂,	     zpow_succ' := gpow_succ'₂,	     zpow_neg' := gpow_neg'₂}", "decl_nm": "div_inv_monoid.ext"
{"src": "2 goals	case nat.succ	M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	npow₂ : ℕ → M → M,	inv₂ : M → M,	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	h_inv : div_inv_monoid.inv = div_inv_monoid.inv,	x : M,	d : ℕ,	hd : npow₁ d x = npow₂ d x	⊢ npow₁ d.succ x = npow₂ d.succ x		M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	npow₂ : ℕ → M → M,	inv₂ : M → M,	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	h_inv : div_inv_monoid.inv = div_inv_monoid.inv,	h_npow : npow₁ = npow₂	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₁,	     zpow := gpow₁,	     zpow_zero' := gpow_zero'₁,	     zpow_succ' := gpow_succ'₁,	     zpow_neg' := gpow_neg'₁} =	    {mul := mul₁,	     mul_assoc := m₂_mul_assoc,	     one := one₁,	     one_mul := one_mul₂,	     mul_one := mul_one₂,	     npow := npow₂,	     npow_zero' := npow_zero₂,	     npow_succ' := npow_succ₂,	     inv := inv₂,	     div := div₂,	     div_eq_mul_inv := div_eq_mul_inv₂,	     zpow := gpow₂,	     zpow_zero' := gpow_zero'₂,	     zpow_succ' := gpow_succ'₂,	     zpow_neg' := gpow_neg'₂}", "decl_nm": "div_inv_monoid.ext"
{"src": "M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	npow₂ : ℕ → M → M,	inv₂ : M → M,	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₂ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₂ n.succ x = x * npow₂ n x) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	h_inv : div_inv_monoid.inv = div_inv_monoid.inv,	h_npow : npow₁ = npow₂	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₁,	     zpow := gpow₁,	     zpow_zero' := gpow_zero'₁,	     zpow_succ' := gpow_succ'₁,	     zpow_neg' := gpow_neg'₁} =	    {mul := mul₁,	     mul_assoc := m₂_mul_assoc,	     one := one₁,	     one_mul := one_mul₂,	     mul_one := mul_one₂,	     npow := npow₂,	     npow_zero' := npow_zero₂,	     npow_succ' := npow_succ₂,	     inv := inv₂,	     div := div₂,	     div_eq_mul_inv := div_eq_mul_inv₂,	     zpow := gpow₂,	     zpow_zero' := gpow_zero'₂,	     zpow_succ' := gpow_succ'₂,	     zpow_neg' := gpow_neg'₂}", "decl_nm": "div_inv_monoid.ext"
{"src": "M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	inv₂ : M → M,	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	h_inv : div_inv_monoid.inv = div_inv_monoid.inv	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₁,	     zpow := gpow₁,	     zpow_zero' := gpow_zero'₁,	     zpow_succ' := gpow_succ'₁,	     zpow_neg' := gpow_neg'₁} =	    {mul := mul₁,	     mul_assoc := m₂_mul_assoc,	     one := one₁,	     one_mul := one_mul₂,	     mul_one := mul_one₂,	     npow := npow₁,	     npow_zero' := npow_zero₂,	     npow_succ' := npow_succ₂,	     inv := inv₂,	     div := div₂,	     div_eq_mul_inv := div_eq_mul_inv₂,	     zpow := gpow₂,	     zpow_zero' := gpow_zero'₂,	     zpow_succ' := gpow_succ'₂,	     zpow_neg' := gpow_neg'₂}", "decl_nm": "div_inv_monoid.ext"
{"src": "M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	inv₂ : M → M,	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	h_inv : inv₁ = inv₂	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₁,	     zpow := gpow₁,	     zpow_zero' := gpow_zero'₁,	     zpow_succ' := gpow_succ'₁,	     zpow_neg' := gpow_neg'₁} =	    {mul := mul₁,	     mul_assoc := m₂_mul_assoc,	     one := one₁,	     one_mul := one_mul₂,	     mul_one := mul_one₂,	     npow := npow₁,	     npow_zero' := npow_zero₂,	     npow_succ' := npow_succ₂,	     inv := inv₂,	     div := div₂,	     div_eq_mul_inv := div_eq_mul_inv₂,	     zpow := gpow₂,	     zpow_zero' := gpow_zero'₂,	     zpow_succ' := gpow_succ'₂,	     zpow_neg' := gpow_neg'₂}", "decl_nm": "div_inv_monoid.ext"
{"src": "M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous)	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₁,	     zpow := gpow₁,	     zpow_zero' := gpow_zero'₁,	     zpow_succ' := gpow_succ'₁,	     zpow_neg' := gpow_neg'₁} =	    {mul := mul₁,	     mul_assoc := m₂_mul_assoc,	     one := one₁,	     one_mul := one_mul₂,	     mul_one := mul_one₂,	     npow := npow₁,	     npow_zero' := npow_zero₂,	     npow_succ' := npow_succ₂,	     inv := inv₁,	     div := div₂,	     div_eq_mul_inv := div_eq_mul_inv₂,	     zpow := gpow₂,	     zpow_zero' := gpow_zero'₂,	     zpow_succ' := gpow_succ'₂,	     zpow_neg' := gpow_neg'₂}", "decl_nm": "div_inv_monoid.ext"
{"src": "2 goals	M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous)	⊢ div₁ = div₂		M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	h_div : div₁ = div₂	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₁,	     zpow := gpow₁,	     zpow_zero' := gpow_zero'₁,	     zpow_succ' := gpow_succ'₁,	     zpow_neg' := gpow_neg'₁} =	    {mul := mul₁,	     mul_assoc := m₂_mul_assoc,	     one := one₁,	     one_mul := one_mul₂,	     mul_one := mul_one₂,	     npow := npow₁,	     npow_zero' := npow_zero₂,	     npow_succ' := npow_succ₂,	     inv := inv₁,	     div := div₂,	     div_eq_mul_inv := div_eq_mul_inv₂,	     zpow := gpow₂,	     zpow_zero' := gpow_zero'₂,	     zpow_succ' := gpow_succ'₂,	     zpow_neg' := gpow_neg'₂}", "decl_nm": "div_inv_monoid.ext"
{"src": "2 goals	M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	a b : M	⊢ div₁ a b = div₂ a b		M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	h_div : div₁ = div₂	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₁,	     zpow := gpow₁,	     zpow_zero' := gpow_zero'₁,	     zpow_succ' := gpow_succ'₁,	     zpow_neg' := gpow_neg'₁} =	    {mul := mul₁,	     mul_assoc := m₂_mul_assoc,	     one := one₁,	     one_mul := one_mul₂,	     mul_one := mul_one₂,	     npow := npow₁,	     npow_zero' := npow_zero₂,	     npow_succ' := npow_succ₂,	     inv := inv₁,	     div := div₂,	     div_eq_mul_inv := div_eq_mul_inv₂,	     zpow := gpow₂,	     zpow_zero' := gpow_zero'₂,	     zpow_succ' := gpow_succ'₂,	     zpow_neg' := gpow_neg'₂}", "decl_nm": "div_inv_monoid.ext"
{"src": "3 goals	M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	a b : M	⊢ div₁ a b = a * b⁻¹		M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	a b : M	⊢ div₂ a b = a * b⁻¹		M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	h_div : div₁ = div₂	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₁,	     zpow := gpow₁,	     zpow_zero' := gpow_zero'₁,	     zpow_succ' := gpow_succ'₁,	     zpow_neg' := gpow_neg'₁} =	    {mul := mul₁,	     mul_assoc := m₂_mul_assoc,	     one := one₁,	     one_mul := one_mul₂,	     mul_one := mul_one₂,	     npow := npow₁,	     npow_zero' := npow_zero₂,	     npow_succ' := npow_succ₂,	     inv := inv₁,	     div := div₂,	     div_eq_mul_inv := div_eq_mul_inv₂,	     zpow := gpow₂,	     zpow_zero' := gpow_zero'₂,	     zpow_succ' := gpow_succ'₂,	     zpow_neg' := gpow_neg'₂}", "decl_nm": "div_inv_monoid.ext"
{"src": "2 goals	M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	a b : M	⊢ div₂ a b = a * b⁻¹		M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	h_div : div₁ = div₂	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₁,	     zpow := gpow₁,	     zpow_zero' := gpow_zero'₁,	     zpow_succ' := gpow_succ'₁,	     zpow_neg' := gpow_neg'₁} =	    {mul := mul₁,	     mul_assoc := m₂_mul_assoc,	     one := one₁,	     one_mul := one_mul₂,	     mul_one := mul_one₂,	     npow := npow₁,	     npow_zero' := npow_zero₂,	     npow_succ' := npow_succ₂,	     inv := inv₁,	     div := div₂,	     div_eq_mul_inv := div_eq_mul_inv₂,	     zpow := gpow₂,	     zpow_zero' := gpow_zero'₂,	     zpow_succ' := gpow_succ'₂,	     zpow_neg' := gpow_neg'₂}", "decl_nm": "div_inv_monoid.ext"
{"src": "M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	div₂ : M → M → M,	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	h_div : div₁ = div₂	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₁,	     zpow := gpow₁,	     zpow_zero' := gpow_zero'₁,	     zpow_succ' := gpow_succ'₁,	     zpow_neg' := gpow_neg'₁} =	    {mul := mul₁,	     mul_assoc := m₂_mul_assoc,	     one := one₁,	     one_mul := one_mul₂,	     mul_one := mul_one₂,	     npow := npow₁,	     npow_zero' := npow_zero₂,	     npow_succ' := npow_succ₂,	     inv := inv₁,	     div := div₂,	     div_eq_mul_inv := div_eq_mul_inv₂,	     zpow := gpow₂,	     zpow_zero' := gpow_zero'₂,	     zpow_succ' := gpow_succ'₂,	     zpow_neg' := gpow_neg'₂}", "decl_nm": "div_inv_monoid.ext"
{"src": "M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous)	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₁,	     zpow := gpow₁,	     zpow_zero' := gpow_zero'₁,	     zpow_succ' := gpow_succ'₁,	     zpow_neg' := gpow_neg'₁} =	    {mul := mul₁,	     mul_assoc := m₂_mul_assoc,	     one := one₁,	     one_mul := one_mul₂,	     mul_one := mul_one₂,	     npow := npow₁,	     npow_zero' := npow_zero₂,	     npow_succ' := npow_succ₂,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₂,	     zpow := gpow₂,	     zpow_zero' := gpow_zero'₂,	     zpow_succ' := gpow_succ'₂,	     zpow_neg' := gpow_neg'₂}", "decl_nm": "div_inv_monoid.ext"
{"src": "2 goals	M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous)	⊢ ∀ (n : ℕ) (g : M), gpow₁ (int.of_nat n) g = gpow₂ (int.of_nat n) g		M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	h_gpow_aux : ∀ (n : ℕ) (g : M), gpow₁ (int.of_nat n) g = gpow₂ (int.of_nat n) g	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₁,	     zpow := gpow₁,	     zpow_zero' := gpow_zero'₁,	     zpow_succ' := gpow_succ'₁,	     zpow_neg' := gpow_neg'₁} =	    {mul := mul₁,	     mul_assoc := m₂_mul_assoc,	     one := one₁,	     one_mul := one_mul₂,	     mul_one := mul_one₂,	     npow := npow₁,	     npow_zero' := npow_zero₂,	     npow_succ' := npow_succ₂,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₂,	     zpow := gpow₂,	     zpow_zero' := gpow_zero'₂,	     zpow_succ' := gpow_succ'₂,	     zpow_neg' := gpow_neg'₂}", "decl_nm": "div_inv_monoid.ext"
{"src": "2 goals	M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	n : ℕ,	g : M	⊢ gpow₁ (int.of_nat n) g = gpow₂ (int.of_nat n) g		M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	h_gpow_aux : ∀ (n : ℕ) (g : M), gpow₁ (int.of_nat n) g = gpow₂ (int.of_nat n) g	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₁,	     zpow := gpow₁,	     zpow_zero' := gpow_zero'₁,	     zpow_succ' := gpow_succ'₁,	     zpow_neg' := gpow_neg'₁} =	    {mul := mul₁,	     mul_assoc := m₂_mul_assoc,	     one := one₁,	     one_mul := one_mul₂,	     mul_one := mul_one₂,	     npow := npow₁,	     npow_zero' := npow_zero₂,	     npow_succ' := npow_succ₂,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₂,	     zpow := gpow₂,	     zpow_zero' := gpow_zero'₂,	     zpow_succ' := gpow_succ'₂,	     zpow_neg' := gpow_neg'₂}", "decl_nm": "div_inv_monoid.ext"
{"src": "3 goals	case nat.zero	M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	g : M	⊢ gpow₁ (int.of_nat 0) g = gpow₂ (int.of_nat 0) g		case nat.succ	M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	g : M,	n : ℕ,	IH : gpow₁ (int.of_nat n) g = gpow₂ (int.of_nat n) g	⊢ gpow₁ (int.of_nat n.succ) g = gpow₂ (int.of_nat n.succ) g		M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	h_gpow_aux : ∀ (n : ℕ) (g : M), gpow₁ (int.of_nat n) g = gpow₂ (int.of_nat n) g	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₁,	     zpow := gpow₁,	     zpow_zero' := gpow_zero'₁,	     zpow_succ' := gpow_succ'₁,	     zpow_neg' := gpow_neg'₁} =	    {mul := mul₁,	     mul_assoc := m₂_mul_assoc,	     one := one₁,	     one_mul := one_mul₂,	     mul_one := mul_one₂,	     npow := npow₁,	     npow_zero' := npow_zero₂,	     npow_succ' := npow_succ₂,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₂,	     zpow := gpow₂,	     zpow_zero' := gpow_zero'₂,	     zpow_succ' := gpow_succ'₂,	     zpow_neg' := gpow_neg'₂}", "decl_nm": "div_inv_monoid.ext"
{"src": "4 goals	M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	g : M	⊢ gpow₁ (int.of_nat 0) g = 1		M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	g : M	⊢ gpow₂ (int.of_nat 0) g = 1		case nat.succ	M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	g : M,	n : ℕ,	IH : gpow₁ (int.of_nat n) g = gpow₂ (int.of_nat n) g	⊢ gpow₁ (int.of_nat n.succ) g = gpow₂ (int.of_nat n.succ) g		M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	h_gpow_aux : ∀ (n : ℕ) (g : M), gpow₁ (int.of_nat n) g = gpow₂ (int.of_nat n) g	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₁,	     zpow := gpow₁,	     zpow_zero' := gpow_zero'₁,	     zpow_succ' := gpow_succ'₁,	     zpow_neg' := gpow_neg'₁} =	    {mul := mul₁,	     mul_assoc := m₂_mul_assoc,	     one := one₁,	     one_mul := one_mul₂,	     mul_one := mul_one₂,	     npow := npow₁,	     npow_zero' := npow_zero₂,	     npow_succ' := npow_succ₂,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₂,	     zpow := gpow₂,	     zpow_zero' := gpow_zero'₂,	     zpow_succ' := gpow_succ'₂,	     zpow_neg' := gpow_neg'₂}", "decl_nm": "div_inv_monoid.ext"
{"src": "3 goals	M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	g : M	⊢ gpow₂ (int.of_nat 0) g = 1		case nat.succ	M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	g : M,	n : ℕ,	IH : gpow₁ (int.of_nat n) g = gpow₂ (int.of_nat n) g	⊢ gpow₁ (int.of_nat n.succ) g = gpow₂ (int.of_nat n.succ) g		M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	h_gpow_aux : ∀ (n : ℕ) (g : M), gpow₁ (int.of_nat n) g = gpow₂ (int.of_nat n) g	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₁,	     zpow := gpow₁,	     zpow_zero' := gpow_zero'₁,	     zpow_succ' := gpow_succ'₁,	     zpow_neg' := gpow_neg'₁} =	    {mul := mul₁,	     mul_assoc := m₂_mul_assoc,	     one := one₁,	     one_mul := one_mul₂,	     mul_one := mul_one₂,	     npow := npow₁,	     npow_zero' := npow_zero₂,	     npow_succ' := npow_succ₂,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₂,	     zpow := gpow₂,	     zpow_zero' := gpow_zero'₂,	     zpow_succ' := gpow_succ'₂,	     zpow_neg' := gpow_neg'₂}", "decl_nm": "div_inv_monoid.ext"
{"src": "2 goals	case nat.succ	M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	g : M,	n : ℕ,	IH : gpow₁ (int.of_nat n) g = gpow₂ (int.of_nat n) g	⊢ gpow₁ (int.of_nat n.succ) g = gpow₂ (int.of_nat n.succ) g		M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	h_gpow_aux : ∀ (n : ℕ) (g : M), gpow₁ (int.of_nat n) g = gpow₂ (int.of_nat n) g	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₁,	     zpow := gpow₁,	     zpow_zero' := gpow_zero'₁,	     zpow_succ' := gpow_succ'₁,	     zpow_neg' := gpow_neg'₁} =	    {mul := mul₁,	     mul_assoc := m₂_mul_assoc,	     one := one₁,	     one_mul := one_mul₂,	     mul_one := mul_one₂,	     npow := npow₁,	     npow_zero' := npow_zero₂,	     npow_succ' := npow_succ₂,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₂,	     zpow := gpow₂,	     zpow_zero' := gpow_zero'₂,	     zpow_succ' := gpow_succ'₂,	     zpow_neg' := gpow_neg'₂}", "decl_nm": "div_inv_monoid.ext"
{"src": "M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	h_gpow_aux : ∀ (n : ℕ) (g : M), gpow₁ (int.of_nat n) g = gpow₂ (int.of_nat n) g	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₁,	     zpow := gpow₁,	     zpow_zero' := gpow_zero'₁,	     zpow_succ' := gpow_succ'₁,	     zpow_neg' := gpow_neg'₁} =	    {mul := mul₁,	     mul_assoc := m₂_mul_assoc,	     one := one₁,	     one_mul := one_mul₂,	     mul_one := mul_one₂,	     npow := npow₁,	     npow_zero' := npow_zero₂,	     npow_succ' := npow_succ₂,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₂,	     zpow := gpow₂,	     zpow_zero' := gpow_zero'₂,	     zpow_succ' := gpow_succ'₂,	     zpow_neg' := gpow_neg'₂}", "decl_nm": "div_inv_monoid.ext"
{"src": "2 goals	M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	h_gpow_aux : ∀ (n : ℕ) (g : M), gpow₁ (int.of_nat n) g = gpow₂ (int.of_nat n) g	⊢ gpow₁ = gpow₂		M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	h_gpow_aux : ∀ (n : ℕ) (g : M), gpow₁ (int.of_nat n) g = gpow₂ (int.of_nat n) g,	h_gpow : gpow₁ = gpow₂	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₁,	     zpow := gpow₁,	     zpow_zero' := gpow_zero'₁,	     zpow_succ' := gpow_succ'₁,	     zpow_neg' := gpow_neg'₁} =	    {mul := mul₁,	     mul_assoc := m₂_mul_assoc,	     one := one₁,	     one_mul := one_mul₂,	     mul_one := mul_one₂,	     npow := npow₁,	     npow_zero' := npow_zero₂,	     npow_succ' := npow_succ₂,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₂,	     zpow := gpow₂,	     zpow_zero' := gpow_zero'₂,	     zpow_succ' := gpow_succ'₂,	     zpow_neg' := gpow_neg'₂}", "decl_nm": "div_inv_monoid.ext"
{"src": "2 goals	M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	h_gpow_aux : ∀ (n : ℕ) (g : M), gpow₁ (int.of_nat n) g = gpow₂ (int.of_nat n) g,	z : ℤ,	x : M	⊢ gpow₁ z x = gpow₂ z x		M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	h_gpow_aux : ∀ (n : ℕ) (g : M), gpow₁ (int.of_nat n) g = gpow₂ (int.of_nat n) g,	h_gpow : gpow₁ = gpow₂	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₁,	     zpow := gpow₁,	     zpow_zero' := gpow_zero'₁,	     zpow_succ' := gpow_succ'₁,	     zpow_neg' := gpow_neg'₁} =	    {mul := mul₁,	     mul_assoc := m₂_mul_assoc,	     one := one₁,	     one_mul := one_mul₂,	     mul_one := mul_one₂,	     npow := npow₁,	     npow_zero' := npow_zero₂,	     npow_succ' := npow_succ₂,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₂,	     zpow := gpow₂,	     zpow_zero' := gpow_zero'₂,	     zpow_succ' := gpow_succ'₂,	     zpow_neg' := gpow_neg'₂}", "decl_nm": "div_inv_monoid.ext"
{"src": "3 goals	case int.of_nat	M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	h_gpow_aux : ∀ (n : ℕ) (g : M), gpow₁ (int.of_nat n) g = gpow₂ (int.of_nat n) g,	x : M,	z : ℕ	⊢ gpow₁ (int.of_nat z) x = gpow₂ (int.of_nat z) x		case int.neg_succ_of_nat	M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	h_gpow_aux : ∀ (n : ℕ) (g : M), gpow₁ (int.of_nat n) g = gpow₂ (int.of_nat n) g,	x : M,	z : ℕ	⊢ gpow₁ -[1+ z] x = gpow₂ -[1+ z] x		M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	h_gpow_aux : ∀ (n : ℕ) (g : M), gpow₁ (int.of_nat n) g = gpow₂ (int.of_nat n) g,	h_gpow : gpow₁ = gpow₂	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₁,	     zpow := gpow₁,	     zpow_zero' := gpow_zero'₁,	     zpow_succ' := gpow_succ'₁,	     zpow_neg' := gpow_neg'₁} =	    {mul := mul₁,	     mul_assoc := m₂_mul_assoc,	     one := one₁,	     one_mul := one_mul₂,	     mul_one := mul_one₂,	     npow := npow₁,	     npow_zero' := npow_zero₂,	     npow_succ' := npow_succ₂,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₂,	     zpow := gpow₂,	     zpow_zero' := gpow_zero'₂,	     zpow_succ' := gpow_succ'₂,	     zpow_neg' := gpow_neg'₂}", "decl_nm": "div_inv_monoid.ext"
{"src": "2 goals	case int.neg_succ_of_nat	M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	h_gpow_aux : ∀ (n : ℕ) (g : M), gpow₁ (int.of_nat n) g = gpow₂ (int.of_nat n) g,	x : M,	z : ℕ	⊢ gpow₁ -[1+ z] x = gpow₂ -[1+ z] x		M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	h_gpow_aux : ∀ (n : ℕ) (g : M), gpow₁ (int.of_nat n) g = gpow₂ (int.of_nat n) g,	h_gpow : gpow₁ = gpow₂	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₁,	     zpow := gpow₁,	     zpow_zero' := gpow_zero'₁,	     zpow_succ' := gpow_succ'₁,	     zpow_neg' := gpow_neg'₁} =	    {mul := mul₁,	     mul_assoc := m₂_mul_assoc,	     one := one₁,	     one_mul := one_mul₂,	     mul_one := mul_one₂,	     npow := npow₁,	     npow_zero' := npow_zero₂,	     npow_succ' := npow_succ₂,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₂,	     zpow := gpow₂,	     zpow_zero' := gpow_zero'₂,	     zpow_succ' := gpow_succ'₂,	     zpow_neg' := gpow_neg'₂}", "decl_nm": "div_inv_monoid.ext"
{"src": "2 goals	case int.neg_succ_of_nat	M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	h_gpow_aux : ∀ (n : ℕ) (g : M), gpow₁ (int.of_nat n) g = gpow₂ (int.of_nat n) g,	x : M,	z : ℕ	⊢ (gpow₁ ↑(z.succ) x)⁻¹ = (gpow₂ ↑(z.succ) x)⁻¹		M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	h_gpow_aux : ∀ (n : ℕ) (g : M), gpow₁ (int.of_nat n) g = gpow₂ (int.of_nat n) g,	h_gpow : gpow₁ = gpow₂	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₁,	     zpow := gpow₁,	     zpow_zero' := gpow_zero'₁,	     zpow_succ' := gpow_succ'₁,	     zpow_neg' := gpow_neg'₁} =	    {mul := mul₁,	     mul_assoc := m₂_mul_assoc,	     one := one₁,	     one_mul := one_mul₂,	     mul_one := mul_one₂,	     npow := npow₁,	     npow_zero' := npow_zero₂,	     npow_succ' := npow_succ₂,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₂,	     zpow := gpow₂,	     zpow_zero' := gpow_zero'₂,	     zpow_succ' := gpow_succ'₂,	     zpow_neg' := gpow_neg'₂}", "decl_nm": "div_inv_monoid.ext"
{"src": "2 goals	M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	h_gpow_aux : ∀ (n : ℕ) (g : M), gpow₁ (int.of_nat n) g = gpow₂ (int.of_nat n) g,	x : M,	z : ℕ	⊢ gpow₁ ↑(z.succ) x = gpow₂ ↑(z.succ) x		M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	h_gpow_aux : ∀ (n : ℕ) (g : M), gpow₁ (int.of_nat n) g = gpow₂ (int.of_nat n) g,	h_gpow : gpow₁ = gpow₂	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₁,	     zpow := gpow₁,	     zpow_zero' := gpow_zero'₁,	     zpow_succ' := gpow_succ'₁,	     zpow_neg' := gpow_neg'₁} =	    {mul := mul₁,	     mul_assoc := m₂_mul_assoc,	     one := one₁,	     one_mul := one_mul₂,	     mul_one := mul_one₂,	     npow := npow₁,	     npow_zero' := npow_zero₂,	     npow_succ' := npow_succ₂,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₂,	     zpow := gpow₂,	     zpow_zero' := gpow_zero'₂,	     zpow_succ' := gpow_succ'₂,	     zpow_neg' := gpow_neg'₂}", "decl_nm": "div_inv_monoid.ext"
{"src": "M : Type u_1,	mul₁ : M → M → M,	m₁_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one₁ : M,	one_mul₁ : ∀ (a : M), 1 * a = a,	mul_one₁ : ∀ (a : M), a * 1 = a,	npow₁ : ℕ → M → M,	npow_zero₁ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₁ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	inv₁ : M → M,	div₁ : M → M → M,	div_eq_mul_inv₁ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	gpow₁ : ℤ → M → M,	gpow_zero'₁ : auto_param (∀ (a : M), gpow₁ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ (int.of_nat n.succ) a = a * gpow₁ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₁ :	  auto_param (∀ (n : ℕ) (a : M), gpow₁ -[1+ n] a = (gpow₁ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	iM : div_inv_monoid M :=	  {mul := mul₁,	   mul_assoc := m₁_mul_assoc,	   one := one₁,	   one_mul := one_mul₁,	   mul_one := mul_one₁,	   npow := npow₁,	   npow_zero' := npow_zero₁,	   npow_succ' := npow_succ₁,	   inv := inv₁,	   div := div₁,	   div_eq_mul_inv := div_eq_mul_inv₁,	   zpow := gpow₁,	   zpow_zero' := gpow_zero'₁,	   zpow_succ' := gpow_succ'₁,	   zpow_neg' := gpow_neg'₁},	gpow₂ : ℤ → M → M,	m₂_mul_assoc : ∀ (a b c : M), a * b * c = a * (b * c),	one_mul₂ : ∀ (a : M), 1 * a = a,	mul_one₂ : ∀ (a : M), a * 1 = a,	npow_zero₂ : auto_param (∀ (x : M), npow₁ 0 x = 1) (name.mk_string "try_refl_tac" name.anonymous),	npow_succ₂ :	  auto_param (∀ (n : ℕ) (x : M), npow₁ n.succ x = x * npow₁ n x) (name.mk_string "try_refl_tac" name.anonymous),	gpow_zero'₂ : auto_param (∀ (a : M), gpow₂ 0 a = 1) (name.mk_string "try_refl_tac" name.anonymous),	gpow_succ'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ (int.of_nat n.succ) a = a * gpow₂ (int.of_nat n) a)	    (name.mk_string "try_refl_tac" name.anonymous),	gpow_neg'₂ :	  auto_param (∀ (n : ℕ) (a : M), gpow₂ -[1+ n] a = (gpow₂ ↑(n.succ) a)⁻¹)	    (name.mk_string "try_refl_tac" name.anonymous),	div_eq_mul_inv₂ : auto_param (∀ (a b : M), a / b = a * b⁻¹) (name.mk_string "try_refl_tac" name.anonymous),	h_gpow_aux : ∀ (n : ℕ) (g : M), gpow₁ (int.of_nat n) g = gpow₂ (int.of_nat n) g,	h_gpow : gpow₁ = gpow₂	⊢ {mul := mul₁,	     mul_assoc := m₁_mul_assoc,	     one := one₁,	     one_mul := one_mul₁,	     mul_one := mul_one₁,	     npow := npow₁,	     npow_zero' := npow_zero₁,	     npow_succ' := npow_succ₁,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₁,	     zpow := gpow₁,	     zpow_zero' := gpow_zero'₁,	     zpow_succ' := gpow_succ'₁,	     zpow_neg' := gpow_neg'₁} =	    {mul := mul₁,	     mul_assoc := m₂_mul_assoc,	     one := one₁,	     one_mul := one_mul₂,	     mul_one := mul_one₂,	     npow := npow₁,	     npow_zero' := npow_zero₂,	     npow_succ' := npow_succ₂,	     inv := inv₁,	     div := div₁,	     div_eq_mul_inv := div_eq_mul_inv₂,	     zpow := gpow₂,	     zpow_zero' := gpow_zero'₂,	     zpow_succ' := gpow_succ'₂,	     zpow_neg' := gpow_neg'₂}", "decl_nm": "div_inv_monoid.ext"
{"src": "⊢ ∀ {M : Type u_1} {N : Type u_2} [_inst_1 : mul_zero_one_class M] [_inst_2 : mul_zero_one_class N]	  ⦃f g : M →*₀ N⦄, ⇑f = ⇑g → f = g", "decl_nm": "monoid_with_zero_hom.coe_inj"
{"src": "M : Type u_1,	N : Type u_2,	_inst_1 : mul_zero_one_class M,	_inst_2 : mul_zero_one_class N,	f g : M →*₀ N,	h : ⇑f = ⇑g	⊢ f = g", "decl_nm": "monoid_with_zero_hom.coe_inj"
{"src": "M : Type u_1,	N : Type u_2,	_inst_1 : mul_zero_one_class M,	_inst_2 : mul_zero_one_class N,	g : M →*₀ N,	f_to_fun : M → N,	f_map_zero' : f_to_fun 0 = 0,	f_map_one' : f_to_fun 1 = 1,	f_map_mul' : ∀ (x y : M), f_to_fun (x * y) = f_to_fun x * f_to_fun y,	h : ⇑{to_fun := f_to_fun, map_zero' := f_map_zero', map_one' := f_map_one', map_mul' := f_map_mul'} = ⇑g	⊢ {to_fun := f_to_fun, map_zero' := f_map_zero', map_one' := f_map_one', map_mul' := f_map_mul'} = g", "decl_nm": "monoid_with_zero_hom.coe_inj"
{"src": "M : Type u_1,	N : Type u_2,	_inst_1 : mul_zero_one_class M,	_inst_2 : mul_zero_one_class N,	f_to_fun : M → N,	f_map_zero' : f_to_fun 0 = 0,	f_map_one' : f_to_fun 1 = 1,	f_map_mul' : ∀ (x y : M), f_to_fun (x * y) = f_to_fun x * f_to_fun y,	g_to_fun : M → N,	g_map_zero' : g_to_fun 0 = 0,	g_map_one' : g_to_fun 1 = 1,	g_map_mul' : ∀ (x y : M), g_to_fun (x * y) = g_to_fun x * g_to_fun y,	h :	  ⇑{to_fun := f_to_fun, map_zero' := f_map_zero', map_one' := f_map_one', map_mul' := f_map_mul'} =	    ⇑{to_fun := g_to_fun, map_zero' := g_map_zero', map_one' := g_map_one', map_mul' := g_map_mul'}	⊢ {to_fun := f_to_fun, map_zero' := f_map_zero', map_one' := f_map_one', map_mul' := f_map_mul'} =	    {to_fun := g_to_fun, map_zero' := g_map_zero', map_one' := g_map_one', map_mul' := g_map_mul'}", "decl_nm": "monoid_with_zero_hom.coe_inj"
{"src": "M : Type u_1,	N : Type u_2,	_inst_1 : mul_zero_one_class M,	_inst_2 : mul_zero_one_class N,	f_to_fun : M → N,	f_map_zero' : f_to_fun 0 = 0,	f_map_one' : f_to_fun 1 = 1,	f_map_mul' : ∀ (x y : M), f_to_fun (x * y) = f_to_fun x * f_to_fun y,	g_map_zero' : f_to_fun 0 = 0,	g_map_one' : f_to_fun 1 = 1,	g_map_mul' : ∀ (x y : M), f_to_fun (x * y) = f_to_fun x * f_to_fun y,	h :	  ⇑{to_fun := f_to_fun, map_zero' := f_map_zero', map_one' := f_map_one', map_mul' := f_map_mul'} =	    ⇑{to_fun := f_to_fun, map_zero' := g_map_zero', map_one' := g_map_one', map_mul' := g_map_mul'}	⊢ {to_fun := f_to_fun, map_zero' := f_map_zero', map_one' := f_map_one', map_mul' := f_map_mul'} =	    {to_fun := f_to_fun, map_zero' := g_map_zero', map_one' := g_map_one', map_mul' := g_map_mul'}", "decl_nm": "monoid_with_zero_hom.coe_inj"
{"src": "⊢ ∀ {M : Type u_1} {N : Type u_2} {P : Type u_3} [_inst_1 : has_one M] [_inst_2 : has_one N] [_inst_3 : has_one P]	  (f : one_hom N P), f.comp 1 = 1", "decl_nm": "one_hom.comp_one"
{"src": "M : Type u_1,	N : Type u_2,	P : Type u_3,	_inst_1 : has_one M,	_inst_2 : has_one N,	_inst_3 : has_one P,	f : one_hom N P	⊢ f.comp 1 = 1", "decl_nm": "one_hom.comp_one"
{"src": "M : Type u_1,	N : Type u_2,	P : Type u_3,	_inst_1 : has_one M,	_inst_2 : has_one N,	_inst_3 : has_one P,	f : one_hom N P,	x : M	⊢ ⇑(f.comp 1) x = ⇑1 x", "decl_nm": "one_hom.comp_one"
{"src": "⊢ ∀ {M : Type u_1} {N : Type u_2} {P : Type u_3} [_inst_3 : mul_one_class M] [_inst_4 : mul_one_class N]	  [_inst_5 : mul_one_class P] (f : N →* P), f.comp 1 = 1", "decl_nm": "monoid_hom.comp_one"
{"src": "M : Type u_1,	N : Type u_2,	P : Type u_3,	_inst_3 : mul_one_class M,	_inst_4 : mul_one_class N,	_inst_5 : mul_one_class P,	f : N →* P	⊢ f.comp 1 = 1", "decl_nm": "monoid_hom.comp_one"
{"src": "M : Type u_1,	N : Type u_2,	P : Type u_3,	_inst_3 : mul_one_class M,	_inst_4 : mul_one_class N,	_inst_5 : mul_one_class P,	f : N →* P,	x : M	⊢ ⇑(f.comp 1) x = ⇑1 x", "decl_nm": "monoid_hom.comp_one"
{"src": "⊢ ∀ {R : Type u₁} [_inst_3 : ring R] (a : R) (m : ℤ), commute ↑m a", "decl_nm": "commute.cast_int_left"
{"src": "R : Type u₁,	_inst_3 : ring R,	a : R,	m : ℤ	⊢ commute ↑m a", "decl_nm": "commute.cast_int_left"
{"src": "R : Type u₁,	_inst_3 : ring R,	a : R,	m : ℤ	⊢ commute (↑m * 1) a", "decl_nm": "commute.cast_int_left"
{"src": "⊢ ∀ {G₀ : Type u_2} [_inst_1 : comm_group_with_zero G₀] (a b c : G₀), a * b / c = a / c * b", "decl_nm": "mul_div_right_comm"
{"src": "G₀ : Type u_2,	_inst_1 : comm_group_with_zero G₀,	a b c : G₀	⊢ a * b / c = a / c * b", "decl_nm": "mul_div_right_comm"
{"src": "⊢ ∀ {G₀ : Type u_2} [_inst_1 : comm_group_with_zero G₀] (a b c : G₀), a * (b / c) = b * (a / c)", "decl_nm": "mul_div_comm"
{"src": "G₀ : Type u_2,	_inst_1 : comm_group_with_zero G₀,	a b c : G₀	⊢ a * (b / c) = b * (a / c)", "decl_nm": "mul_div_comm"
{"src": "⊢ ∀ {ι : Type u_1} {V : Type u} [_inst_1 : category V] [_inst_2 : preadditive V] (c : complex_shape ι)	  [_inst_3 : has_zero_object V] {W : Type u_2} [_inst_4 : category W] [_inst_5 : preadditive W]	  [_inst_6 : has_zero_object W] (F : V ⥤ W) [_inst_7 : F.additive] {i j : ι},	    i ≠ j → ∀ (X : V), ((single_map_homological_complex F c j).inv.app X).f i = 0", "decl_nm": "homological_complex.single_map_homological_complex_inv_app_ne"
{"src": "ι : Type u_1,	V : Type u,	_inst_1 : category V,	_inst_2 : preadditive V,	c : complex_shape ι,	_inst_3 : has_zero_object V,	W : Type u_2,	_inst_4 : category W,	_inst_5 : preadditive W,	_inst_6 : has_zero_object W,	F : V ⥤ W,	_inst_7 : F.additive,	i j : ι,	h : i ≠ j,	X : V	⊢ ((single_map_homological_complex F c j).inv.app X).f i = 0", "decl_nm": "homological_complex.single_map_homological_complex_inv_app_ne"
{"src": "⊢ ∀ {ι : Type u_1} {V : Type u} [_inst_1 : category V] [_inst_2 : has_zero_morphisms V] {c : complex_shape ι}	  {C₁ C₂ C₃ : homological_complex V c} [_inst_3 : has_zero_object V] (f : C₁ ⟶ C₂) (g : C₂ ⟶ C₃)	  (i : ι), hom.sq_from (f ≫ g) i = hom.sq_from f i ≫ hom.sq_from g i", "decl_nm": "homological_complex.hom.sq_from_comp"
{"src": "ι : Type u_1,	V : Type u,	_inst_1 : category V,	_inst_2 : has_zero_morphisms V,	c : complex_shape ι,	C₁ C₂ C₃ : homological_complex V c,	_inst_3 : has_zero_object V,	f : C₁ ⟶ C₂,	g : C₂ ⟶ C₃,	i : ι	⊢ hom.sq_from (f ≫ g) i = hom.sq_from f i ≫ hom.sq_from g i", "decl_nm": "homological_complex.hom.sq_from_comp"
{"src": "2 goals	ι : Type u_1,	V : Type u,	_inst_1 : category V,	_inst_2 : has_zero_morphisms V,	c : complex_shape ι,	C₁ C₂ C₃ : homological_complex V c,	_inst_3 : has_zero_object V,	f : C₁ ⟶ C₂,	g : C₂ ⟶ C₃,	i : ι,	h : c.next i = none	⊢ hom.sq_from (f ≫ g) i = hom.sq_from f i ≫ hom.sq_from g i		ι : Type u_1,	V : Type u,	_inst_1 : category V,	_inst_2 : has_zero_morphisms V,	c : complex_shape ι,	C₁ C₂ C₃ : homological_complex V c,	_inst_3 : has_zero_object V,	f : C₁ ⟶ C₂,	g : C₂ ⟶ C₃,	i j : ι,	w : c.rel i j,	h : c.next i = some ⟨j, w⟩	⊢ hom.sq_from (f ≫ g) i = hom.sq_from f i ≫ hom.sq_from g i", "decl_nm": "homological_complex.hom.sq_from_comp"
{"src": "3 goals	ι : Type u_1,	V : Type u,	_inst_1 : category V,	_inst_2 : has_zero_morphisms V,	c : complex_shape ι,	C₁ C₂ C₃ : homological_complex V c,	_inst_3 : has_zero_object V,	f : C₁ ⟶ C₂,	g : C₂ ⟶ C₃,	i : ι,	h : c.next i = none	⊢ (hom.sq_from (f ≫ g) i).left = (hom.sq_from f i ≫ hom.sq_from g i).left		ι : Type u_1,	V : Type u,	_inst_1 : category V,	_inst_2 : has_zero_morphisms V,	c : complex_shape ι,	C₁ C₂ C₃ : homological_complex V c,	_inst_3 : has_zero_object V,	f : C₁ ⟶ C₂,	g : C₂ ⟶ C₃,	i : ι,	h : c.next i = none	⊢ (hom.sq_from (f ≫ g) i).right = (hom.sq_from f i ≫ hom.sq_from g i).right		ι : Type u_1,	V : Type u,	_inst_1 : category V,	_inst_2 : has_zero_morphisms V,	c : complex_shape ι,	C₁ C₂ C₃ : homological_complex V c,	_inst_3 : has_zero_object V,	f : C₁ ⟶ C₂,	g : C₂ ⟶ C₃,	i j : ι,	w : c.rel i j,	h : c.next i = some ⟨j, w⟩	⊢ hom.sq_from (f ≫ g) i = hom.sq_from f i ≫ hom.sq_from g i", "decl_nm": "homological_complex.hom.sq_from_comp"
{"src": "2 goals	ι : Type u_1,	V : Type u,	_inst_1 : category V,	_inst_2 : has_zero_morphisms V,	c : complex_shape ι,	C₁ C₂ C₃ : homological_complex V c,	_inst_3 : has_zero_object V,	f : C₁ ⟶ C₂,	g : C₂ ⟶ C₃,	i : ι,	h : c.next i = none	⊢ (hom.sq_from (f ≫ g) i).right = (hom.sq_from f i ≫ hom.sq_from g i).right		ι : Type u_1,	V : Type u,	_inst_1 : category V,	_inst_2 : has_zero_morphisms V,	c : complex_shape ι,	C₁ C₂ C₃ : homological_complex V c,	_inst_3 : has_zero_object V,	f : C₁ ⟶ C₂,	g : C₂ ⟶ C₃,	i j : ι,	w : c.rel i j,	h : c.next i = some ⟨j, w⟩	⊢ hom.sq_from (f ≫ g) i = hom.sq_from f i ≫ hom.sq_from g i", "decl_nm": "homological_complex.hom.sq_from_comp"
{"src": "2 goals	ι : Type u_1,	V : Type u,	_inst_1 : category V,	_inst_2 : has_zero_morphisms V,	c : complex_shape ι,	C₁ C₂ C₃ : homological_complex V c,	_inst_3 : has_zero_object V,	f : C₁ ⟶ C₂,	g : C₂ ⟶ C₃,	i : ι,	h : c.next i = none	⊢ hom.next (f ≫ g) i = hom.next f i ≫ hom.next g i		ι : Type u_1,	V : Type u,	_inst_1 : category V,	_inst_2 : has_zero_morphisms V,	c : complex_shape ι,	C₁ C₂ C₃ : homological_complex V c,	_inst_3 : has_zero_object V,	f : C₁ ⟶ C₂,	g : C₂ ⟶ C₃,	i j : ι,	w : c.rel i j,	h : c.next i = some ⟨j, w⟩	⊢ hom.sq_from (f ≫ g) i = hom.sq_from f i ≫ hom.sq_from g i", "decl_nm": "homological_complex.hom.sq_from_comp"
{"src": "2 goals	ι : Type u_1,	V : Type u,	_inst_1 : category V,	_inst_2 : has_zero_morphisms V,	c : complex_shape ι,	C₁ C₂ C₃ : homological_complex V c,	_inst_3 : has_zero_object V,	f : C₁ ⟶ C₂,	g : C₂ ⟶ C₃,	i : ι,	h : c.next i = none	⊢ 0 = 0 ≫ 0		ι : Type u_1,	V : Type u,	_inst_1 : category V,	_inst_2 : has_zero_morphisms V,	c : complex_shape ι,	C₁ C₂ C₃ : homological_complex V c,	_inst_3 : has_zero_object V,	f : C₁ ⟶ C₂,	g : C₂ ⟶ C₃,	i j : ι,	w : c.rel i j,	h : c.next i = some ⟨j, w⟩	⊢ hom.sq_from (f ≫ g) i = hom.sq_from f i ≫ hom.sq_from g i", "decl_nm": "homological_complex.hom.sq_from_comp"
{"src": "2 goals	ι : Type u_1,	V : Type u,	_inst_1 : category V,	_inst_2 : has_zero_morphisms V,	c : complex_shape ι,	C₁ C₂ C₃ : homological_complex V c,	_inst_3 : has_zero_object V,	f : C₁ ⟶ C₂,	g : C₂ ⟶ C₃,	i : ι,	h : c.next i = none	⊢ 0 ≫ 0 = 0		ι : Type u_1,	V : Type u,	_inst_1 : category V,	_inst_2 : has_zero_morphisms V,	c : complex_shape ι,	C₁ C₂ C₃ : homological_complex V c,	_inst_3 : has_zero_object V,	f : C₁ ⟶ C₂,	g : C₂ ⟶ C₃,	i j : ι,	w : c.rel i j,	h : c.next i = some ⟨j, w⟩	⊢ hom.sq_from (f ≫ g) i = hom.sq_from f i ≫ hom.sq_from g i", "decl_nm": "homological_complex.hom.sq_from_comp"
{"src": "2 goals	ι : Type u_1,	V : Type u,	_inst_1 : category V,	_inst_2 : has_zero_morphisms V,	c : complex_shape ι,	C₁ C₂ C₃ : homological_complex V c,	_inst_3 : has_zero_object V,	f : C₁ ⟶ C₂,	g : C₂ ⟶ C₃,	i : ι,	h : c.next i = none	⊢ C₃.X_next i ≅ 0		ι : Type u_1,	V : Type u,	_inst_1 : category V,	_inst_2 : has_zero_morphisms V,	c : complex_shape ι,	C₁ C₂ C₃ : homological_complex V c,	_inst_3 : has_zero_object V,	f : C₁ ⟶ C₂,	g : C₂ ⟶ C₃,	i j : ι,	w : c.rel i j,	h : c.next i = some ⟨j, w⟩	⊢ hom.sq_from (f ≫ g) i = hom.sq_from f i ≫ hom.sq_from g i", "decl_nm": "homological_complex.hom.sq_from_comp"
{"src": "ι : Type u_1,	V : Type u,	_inst_1 : category V,	_inst_2 : has_zero_morphisms V,	c : complex_shape ι,	C₁ C₂ C₃ : homological_complex V c,	_inst_3 : has_zero_object V,	f : C₁ ⟶ C₂,	g : C₂ ⟶ C₃,	i j : ι,	w : c.rel i j,	h : c.next i = some ⟨j, w⟩	⊢ hom.sq_from (f ≫ g) i = hom.sq_from f i ≫ hom.sq_from g i", "decl_nm": "homological_complex.hom.sq_from_comp"
{"src": "2 goals	ι : Type u_1,	V : Type u,	_inst_1 : category V,	_inst_2 : has_zero_morphisms V,	c : complex_shape ι,	C₁ C₂ C₃ : homological_complex V c,	_inst_3 : has_zero_object V,	f : C₁ ⟶ C₂,	g : C₂ ⟶ C₃,	i j : ι,	w : c.rel i j,	h : c.next i = some ⟨j, w⟩	⊢ (hom.sq_from (f ≫ g) i).left = (hom.sq_from f i ≫ hom.sq_from g i).left		ι : Type u_1,	V : Type u,	_inst_1 : category V,	_inst_2 : has_zero_morphisms V,	c : complex_shape ι,	C₁ C₂ C₃ : homological_complex V c,	_inst_3 : has_zero_object V,	f : C₁ ⟶ C₂,	g : C₂ ⟶ C₃,	i j : ι,	w : c.rel i j,	h : c.next i = some ⟨j, w⟩	⊢ (hom.sq_from (f ≫ g) i).right = (hom.sq_from f i ≫ hom.sq_from g i).right", "decl_nm": "homological_complex.hom.sq_from_comp"
{"src": "ι : Type u_1,	V : Type u,	_inst_1 : category V,	_inst_2 : has_zero_morphisms V,	c : complex_shape ι,	C₁ C₂ C₃ : homological_complex V c,	_inst_3 : has_zero_object V,	f : C₁ ⟶ C₂,	g : C₂ ⟶ C₃,	i j : ι,	w : c.rel i j,	h : c.next i = some ⟨j, w⟩	⊢ (hom.sq_from (f ≫ g) i).right = (hom.sq_from f i ≫ hom.sq_from g i).right", "decl_nm": "homological_complex.hom.sq_from_comp"
{"src": "ι : Type u_1,	V : Type u,	_inst_1 : category V,	_inst_2 : has_zero_morphisms V,	c : complex_shape ι,	C₁ C₂ C₃ : homological_complex V c,	_inst_3 : has_zero_object V,	f : C₁ ⟶ C₂,	g : C₂ ⟶ C₃,	i j : ι,	w : c.rel i j,	h : c.next i = some ⟨j, w⟩	⊢ hom.next (f ≫ g) i = hom.next f i ≫ hom.next g i", "decl_nm": "homological_complex.hom.sq_from_comp"
{"src": "⊢ ∀ {V : Type u} [_inst_1 : category V] [_inst_2 : has_zero_morphisms V] (X₀ X₁ X₂ : V) (d₀ : X₁ ⟶ X₀)	  (d₁ : X₂ ⟶ X₁) (s : d₁ ≫ d₀ = 0)	  (succ :	    Π (t : Σ' (X₀ X₁ X₂ : V) (d₀ : X₁ ⟶ X₀) (d₁ : X₂ ⟶ X₁), d₁ ≫ d₀ = 0),	      Σ' (X₃ : V) (d₂ : X₃ ⟶ t.snd.snd.fst), d₂ ≫ t.snd.snd.snd.snd.fst = 0),	    (mk X₀ X₁ X₂ d₀ d₁ s succ).d 1 0 = d₀", "decl_nm": "chain_complex.mk_d_1_0"
{"src": "V : Type u,	_inst_1 : category V,	_inst_2 : has_zero_morphisms V,	X₀ X₁ X₂ : V,	d₀ : X₁ ⟶ X₀,	d₁ : X₂ ⟶ X₁,	s : d₁ ≫ d₀ = 0,	succ :	  Π (t : Σ' (X₀ X₁ X₂ : V) (d₀ : X₁ ⟶ X₀) (d₁ : X₂ ⟶ X₁), d₁ ≫ d₀ = 0),	    Σ' (X₃ : V) (d₂ : X₃ ⟶ t.snd.snd.fst), d₂ ≫ t.snd.snd.snd.snd.fst = 0	⊢ (mk X₀ X₁ X₂ d₀ d₁ s succ).d 1 0 = d₀", "decl_nm": "chain_complex.mk_d_1_0"
{"src": "V : Type u,	_inst_1 : category V,	_inst_2 : has_zero_morphisms V,	X₀ X₁ X₂ : V,	d₀ : X₁ ⟶ X₀,	d₁ : X₂ ⟶ X₁,	s : d₁ ≫ d₀ = 0,	succ :	  Π (t : Σ' (X₀ X₁ X₂ : V) (d₀ : X₁ ⟶ X₀) (d₁ : X₂ ⟶ X₁), d₁ ≫ d₀ = 0),	    Σ' (X₃ : V) (d₂ : X₃ ⟶ t.snd.snd.fst), d₂ ≫ t.snd.snd.snd.snd.fst = 0	⊢ ite (1 = 0 + 1) (𝟙 X₁ ≫ d₀) 0 = d₀", "decl_nm": "chain_complex.mk_d_1_0"
{"src": "⊢ ∀ {ι : Type u_1} {V : Type u} [_inst_1 : category V] [_inst_2 : preadditive V] {c : complex_shape ι}	  {C D E : homological_complex V c} (f : Π (i j : ι), C.X i ⟶ D.X j) (g : D ⟶ E) (j : ι),	    ⇑(prev_d j) (λ (i j : ι), f i j ≫ g.f j) = ⇑(prev_d j) f ≫ g.f j", "decl_nm": "to_prev'_comp_right"
{"src": "ι : Type u_1,	V : Type u,	_inst_1 : category V,	_inst_2 : preadditive V,	c : complex_shape ι,	C D E : homological_complex V c,	f : Π (i j : ι), C.X i ⟶ D.X j,	g : D ⟶ E,	j : ι	⊢ ⇑(prev_d j) (λ (i j : ι), f i j ≫ g.f j) = ⇑(prev_d j) f ≫ g.f j", "decl_nm": "to_prev'_comp_right"
{"src": "ι : Type u_1,	V : Type u,	_inst_1 : category V,	_inst_2 : preadditive V,	c : complex_shape ι,	C D E : homological_complex V c,	f : Π (i j : ι), C.X i ⟶ D.X j,	g : D ⟶ E,	j : ι	⊢ prev_d._match_1 j (λ (i j : ι), f i j ≫ g.f j) (c.prev j) = prev_d._match_1 j f (c.prev j) ≫ g.f j", "decl_nm": "to_prev'_comp_right"
{"src": "2 goals	ι : Type u_1,	V : Type u,	_inst_1 : category V,	_inst_2 : preadditive V,	c : complex_shape ι,	C D E : homological_complex V c,	f : Π (i j : ι), C.X i ⟶ D.X j,	g : D ⟶ E,	j : ι	⊢ prev_d._match_1 j (λ (i j : ι), f i j ≫ g.f j) none = prev_d._match_1 j f none ≫ g.f j		ι : Type u_1,	V : Type u,	_inst_1 : category V,	_inst_2 : preadditive V,	c : complex_shape ι,	C D E : homological_complex V c,	f : Π (i j : ι), C.X i ⟶ D.X j,	g : D ⟶ E,	j j' : ι,	w : c.rel j' j	⊢ prev_d._match_1 j (λ (i j : ι), f i j ≫ g.f j) (some ⟨j', w⟩) =	    prev_d._match_1 j f (some ⟨j', w⟩) ≫ g.f j", "decl_nm": "to_prev'_comp_right"
{"src": "ι : Type u_1,	V : Type u,	_inst_1 : category V,	_inst_2 : preadditive V,	c : complex_shape ι,	C D E : homological_complex V c,	f : Π (i j : ι), C.X i ⟶ D.X j,	g : D ⟶ E,	j j' : ι,	w : c.rel j' j	⊢ prev_d._match_1 j (λ (i j : ι), f i j ≫ g.f j) (some ⟨j', w⟩) =	    prev_d._match_1 j f (some ⟨j', w⟩) ≫ g.f j", "decl_nm": "to_prev'_comp_right"
{"src": "ι : Type u_1,	V : Type u,	_inst_1 : category V,	_inst_2 : preadditive V,	c : complex_shape ι,	C D E : homological_complex V c,	f : Π (i j : ι), C.X i ⟶ D.X j,	g : D ⟶ E,	j j' : ι,	w : c.rel j' j	⊢ (f j j' ≫ g.f j') ≫ E.d j' j = (f j j' ≫ D.d j' j) ≫ g.f j", "decl_nm": "to_prev'_comp_right"
{"src": "⊢ ∀ {V : Type u} [_inst_1 : category V] [_inst_2 : has_zero_morphisms V] {A B C : V} (f : A ⟶ B) (g : B ⟶ C)	  [_inst_3 : has_kernels V] [_inst_4 : has_images V] {Z : V} (h : Z ⟶ A) [_inst_5 : epi h] (w : (h ≫ f) ≫ g = 0),	    image_to_kernel (h ≫ f) g w = (image_subobject (h ≫ f)).of_le (image_subobject f) _ ≫ image_to_kernel f g _", "decl_nm": "image_to_kernel_epi_comp"
{"src": "V : Type u,	_inst_1 : category V,	_inst_2 : has_zero_morphisms V,	A B C : V,	f : A ⟶ B,	g : B ⟶ C,	_inst_3 : has_kernels V,	_inst_4 : has_images V,	Z : V,	h : Z ⟶ A,	_inst_5 : epi h,	w : (h ≫ f) ≫ g = 0	⊢ image_to_kernel (h ≫ f) g w = (image_subobject (h ≫ f)).of_le (image_subobject f) _ ≫ image_to_kernel f g _", "decl_nm": "image_to_kernel_epi_comp"
{"src": "V : Type u,	_inst_1 : category V,	_inst_2 : has_zero_morphisms V,	A B C : V,	f : A ⟶ B,	g : B ⟶ C,	_inst_3 : has_kernels V,	_inst_4 : has_images V,	Z : V,	h : Z ⟶ A,	_inst_5 : epi h,	w : (h ≫ f) ≫ g = 0	⊢ image_to_kernel (h ≫ f) g w ≫ (kernel_subobject g).arrow =	    ((image_subobject (h ≫ f)).of_le (image_subobject f) _ ≫ image_to_kernel f g _) ≫ (kernel_subobject g).arrow", "decl_nm": "image_to_kernel_epi_comp"
{"src": "⊢ ∀ {V : Type u} [_inst_1 : category V] [_inst_2 : has_zero_morphisms V] {A B C : V} (f : A ⟶ B)	  [_inst_3 : has_image f] (g : B ⟶ C) [_inst_4 : has_kernel g] (w : f ≫ g = 0),	    factor_thru_image_subobject f ≫ image_to_kernel f g w = factor_thru_kernel_subobject g f w", "decl_nm": "factor_thru_image_subobject_comp_image_to_kernel"
{"src": "V : Type u,	_inst_1 : category V,	_inst_2 : has_zero_morphisms V,	A B C : V,	f : A ⟶ B,	_inst_3 : has_image f,	g : B ⟶ C,	_inst_4 : has_kernel g,	w : f ≫ g = 0	⊢ factor_thru_image_subobject f ≫ image_to_kernel f g w = factor_thru_kernel_subobject g f w", "decl_nm": "factor_thru_image_subobject_comp_image_to_kernel"
{"src": "V : Type u,	_inst_1 : category V,	_inst_2 : has_zero_morphisms V,	A B C : V,	f : A ⟶ B,	_inst_3 : has_image f,	g : B ⟶ C,	_inst_4 : has_kernel g,	w : f ≫ g = 0	⊢ (factor_thru_image_subobject f ≫ image_to_kernel f g w) ≫ (kernel_subobject g).arrow =	    factor_thru_kernel_subobject g f w ≫ (kernel_subobject g).arrow", "decl_nm": "factor_thru_image_subobject_comp_image_to_kernel"
{"src": "⊢ ∀ {α : Type u_1} {M : Type u_4} [_inst_1 : mul_zero_class M] (s : set α) (f g : α → M),	    s.indicator (λ (a : α), f a * g a) = λ (a : α), s.indicator f a * s.indicator g a", "decl_nm": "set.indicator_mul"
{"src": "α : Type u_1,	M : Type u_4,	_inst_1 : mul_zero_class M,	s : set α,	f g : α → M	⊢ s.indicator (λ (a : α), f a * g a) = λ (a : α), s.indicator f a * s.indicator g a", "decl_nm": "set.indicator_mul"
{"src": "α : Type u_1,	M : Type u_4,	_inst_1 : mul_zero_class M,	s : set α,	f g : α → M,	x : α	⊢ s.indicator (λ (a : α), f a * g a) x = s.indicator f x * s.indicator g x", "decl_nm": "set.indicator_mul"
{"src": "α : Type u_1,	M : Type u_4,	_inst_1 : mul_zero_class M,	s : set α,	f g : α → M,	x : α	⊢ ite (x ∈ s) (f x * g x) 0 = ite (x ∈ s) (f x) 0 * ite (x ∈ s) (g x) 0", "decl_nm": "set.indicator_mul"
{"src": "2 goals	α : Type u_1,	M : Type u_4,	_inst_1 : mul_zero_class M,	s : set α,	f g : α → M,	x : α,	h : x ∈ s	⊢ f x * g x = f x * g x		α : Type u_1,	M : Type u_4,	_inst_1 : mul_zero_class M,	s : set α,	f g : α → M,	x : α,	h : x ∉ s	⊢ 0 = 0 * 0", "decl_nm": "set.indicator_mul"
{"src": "α : Type u_1,	M : Type u_4,	_inst_1 : mul_zero_class M,	s : set α,	f g : α → M,	x : α,	h : x ∉ s	⊢ 0 = 0 * 0", "decl_nm": "set.indicator_mul"
{"src": "⊢ ∀ {α : Type u_1} {M : Type u_4} [_inst_1 : has_one M] {s t : set α} {f : α → M},	    s.mul_indicator f = f → s ⊆ t → t.mul_indicator f = f", "decl_nm": "set.mul_indicator_eq_self_of_superset"
{"src": "α : Type u_1,	M : Type u_4,	_inst_1 : has_one M,	s t : set α,	f : α → M,	h1 : s.mul_indicator f = f,	h2 : s ⊆ t	⊢ t.mul_indicator f = f", "decl_nm": "set.mul_indicator_eq_self_of_superset"
{"src": "α : Type u_1,	M : Type u_4,	_inst_1 : has_one M,	s t : set α,	f : α → M,	h2 : s ⊆ t,	h1 : mul_support f ⊆ s	⊢ mul_support f ⊆ t", "decl_nm": "set.mul_indicator_eq_self_of_superset"
{"src": "⊢ ∀ (n : Type u_1) (R : Type u₂) [_inst_1 : decidable_eq n] [_inst_5 : comm_ring R] [_inst_6 : fintype n]	  (A : matrix n n R), A ∈ orthogonal.so n R ↔ A.transpose = -A", "decl_nm": "lie_algebra.orthogonal.mem_so"
{"src": "n : Type u_1,	R : Type u₂,	_inst_1 : decidable_eq n,	_inst_5 : comm_ring R,	_inst_6 : fintype n,	A : matrix n n R	⊢ A ∈ orthogonal.so n R ↔ A.transpose = -A", "decl_nm": "lie_algebra.orthogonal.mem_so"
{"src": "n : Type u_1,	R : Type u₂,	_inst_1 : decidable_eq n,	_inst_5 : comm_ring R,	_inst_6 : fintype n,	A : matrix n n R	⊢ 1.is_skew_adjoint A ↔ A.transpose = -A", "decl_nm": "lie_algebra.orthogonal.mem_so"
{"src": "⊢ ∀ {R : Type u} {L : Type v} {L' : Type w₂} [_inst_1 : comm_ring R] [_inst_2 : lie_ring L]	  [_inst_3 : lie_algebra R L] [_inst_4 : lie_ring L'] [_inst_5 : lie_algebra R L'] (f : L →ₗ⁅R⁆ L')	  {I₁ I₂ : lie_ideal R L}, map f ⁅I₁,I₂⁆ ≤ ⁅map f I₁,map f I₂⁆", "decl_nm": "lie_ideal.map_bracket_le"
{"src": "R : Type u,	L : Type v,	L' : Type w₂,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	f : L →ₗ⁅R⁆ L',	I₁ I₂ : lie_ideal R L	⊢ map f ⁅I₁,I₂⁆ ≤ ⁅map f I₁,map f I₂⁆", "decl_nm": "lie_ideal.map_bracket_le"
{"src": "R : Type u,	L : Type v,	L' : Type w₂,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	f : L →ₗ⁅R⁆ L',	I₁ I₂ : lie_ideal R L	⊢ ⁅I₁,I₂⁆ ≤ comap f ⁅map f I₁,map f I₂⁆", "decl_nm": "lie_ideal.map_bracket_le"
{"src": "R : Type u,	L : Type v,	L' : Type w₂,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	f : L →ₗ⁅R⁆ L',	I₁ I₂ : lie_ideal R L	⊢ {m : L | ∃ (x : ↥I₁) (n : ↥I₂), ⁅↑x,↑n⁆ = m} ⊆ ↑(comap f ⁅map f I₁,map f I₂⁆)", "decl_nm": "lie_ideal.map_bracket_le"
{"src": "R : Type u,	L : Type v,	L' : Type w₂,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	f : L →ₗ⁅R⁆ L',	I₁ I₂ : lie_ideal R L,	x : L,	hx : x ∈ {m : L | ∃ (x : ↥I₁) (n : ↥I₂), ⁅↑x,↑n⁆ = m}	⊢ x ∈ ↑(comap f ⁅map f I₁,map f I₂⁆)", "decl_nm": "lie_ideal.map_bracket_le"
{"src": "R : Type u,	L : Type v,	L' : Type w₂,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	f : L →ₗ⁅R⁆ L',	I₁ I₂ : lie_ideal R L,	x y₁ : L,	hy₁ : y₁ ∈ has_coe_t_aux.coe (has_coe_t_aux.coe I₁),	y₂ : L,	hy₂ : y₂ ∈ has_coe_t_aux.coe I₂,	hx : ⁅↑⟨y₁, hy₁⟩,↑⟨y₂, hy₂⟩⁆ = x	⊢ x ∈ ↑(comap f ⁅map f I₁,map f I₂⁆)", "decl_nm": "lie_ideal.map_bracket_le"
{"src": "R : Type u,	L : Type v,	L' : Type w₂,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	f : L →ₗ⁅R⁆ L',	I₁ I₂ : lie_ideal R L,	x y₁ : L,	hy₁ : y₁ ∈ has_coe_t_aux.coe (has_coe_t_aux.coe I₁),	y₂ : L,	hy₂ : y₂ ∈ has_coe_t_aux.coe I₂,	hx : ⁅↑⟨y₁, hy₁⟩,↑⟨y₂, hy₂⟩⁆ = x	⊢ ⁅↑⟨y₁, hy₁⟩,↑⟨y₂, hy₂⟩⁆ ∈ ↑(comap f ⁅map f I₁,map f I₂⁆)", "decl_nm": "lie_ideal.map_bracket_le"
{"src": "R : Type u,	L : Type v,	L' : Type w₂,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	f : L →ₗ⁅R⁆ L',	I₁ I₂ : lie_ideal R L,	x y₁ : L,	hy₁ : y₁ ∈ has_coe_t_aux.coe (has_coe_t_aux.coe I₁),	y₂ : L,	hy₂ : y₂ ∈ has_coe_t_aux.coe I₂,	hx : ⁅↑⟨y₁, hy₁⟩,↑⟨y₂, hy₂⟩⁆ = x,	fy₁ : ↥(map f I₁) := ⟨⇑f y₁, _⟩	⊢ ⁅↑⟨y₁, hy₁⟩,↑⟨y₂, hy₂⟩⁆ ∈ ↑(comap f ⁅map f I₁,map f I₂⁆)", "decl_nm": "lie_ideal.map_bracket_le"
{"src": "R : Type u,	L : Type v,	L' : Type w₂,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	f : L →ₗ⁅R⁆ L',	I₁ I₂ : lie_ideal R L,	x y₁ : L,	hy₁ : y₁ ∈ has_coe_t_aux.coe (has_coe_t_aux.coe I₁),	y₂ : L,	hy₂ : y₂ ∈ has_coe_t_aux.coe I₂,	hx : ⁅↑⟨y₁, hy₁⟩,↑⟨y₂, hy₂⟩⁆ = x,	fy₁ : ↥(map f I₁) := ⟨⇑f y₁, _⟩,	fy₂ : ↥(map f I₂) := ⟨⇑f y₂, _⟩	⊢ ⁅↑⟨y₁, hy₁⟩,↑⟨y₂, hy₂⟩⁆ ∈ ↑(comap f ⁅map f I₁,map f I₂⁆)", "decl_nm": "lie_ideal.map_bracket_le"
{"src": "R : Type u,	L : Type v,	L' : Type w₂,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	f : L →ₗ⁅R⁆ L',	I₁ I₂ : lie_ideal R L,	x y₁ : L,	hy₁ : y₁ ∈ has_coe_t_aux.coe (has_coe_t_aux.coe I₁),	y₂ : L,	hy₂ : y₂ ∈ has_coe_t_aux.coe I₂,	hx : ⁅↑⟨y₁, hy₁⟩,↑⟨y₂, hy₂⟩⁆ = x,	fy₁ : ↥(map f I₁) := ⟨⇑f y₁, _⟩,	fy₂ : ↥(map f I₂) := ⟨⇑f y₂, _⟩	⊢ ⁅↑⟨y₁, hy₁⟩,↑⟨y₂, hy₂⟩⁆ ∈ comap f ⁅map f I₁,map f I₂⁆", "decl_nm": "lie_ideal.map_bracket_le"
{"src": "R : Type u,	L : Type v,	L' : Type w₂,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	f : L →ₗ⁅R⁆ L',	I₁ I₂ : lie_ideal R L,	x y₁ : L,	hy₁ : y₁ ∈ has_coe_t_aux.coe (has_coe_t_aux.coe I₁),	y₂ : L,	hy₂ : y₂ ∈ has_coe_t_aux.coe I₂,	hx : ⁅↑⟨y₁, hy₁⟩,↑⟨y₂, hy₂⟩⁆ = x,	fy₁ : ↥(map f I₁) := ⟨⇑f y₁, _⟩,	fy₂ : ↥(map f I₂) := ⟨⇑f y₂, _⟩	⊢ ⁅⇑f y₁,⇑f y₂⁆ ∈ ⁅map f I₁,map f I₂⁆", "decl_nm": "lie_ideal.map_bracket_le"
{"src": "⊢ ∀ (R : Type u) (L : Type v) [_inst_1 : comm_ring R] [_inst_2 : lie_ring L] [_inst_3 : lie_algebra R L]	  [_inst_4 : is_semisimple R L] [h : is_lie_abelian L], subsingleton L", "decl_nm": "lie_algebra.subsingleton_of_semisimple_lie_abelian"
{"src": "R : Type u,	L : Type v,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : is_semisimple R L,	h : is_lie_abelian L	⊢ subsingleton L", "decl_nm": "lie_algebra.subsingleton_of_semisimple_lie_abelian"
{"src": "R : Type u,	L : Type v,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : is_semisimple R L,	h : ⊥ = ⊤	⊢ subsingleton L", "decl_nm": "lie_algebra.subsingleton_of_semisimple_lie_abelian"
{"src": "⊢ ∀ {R : Type u} {L : Type v} [_inst_1 : comm_ring R] [_inst_2 : lie_ring L] [_inst_3 : lie_algebra R L]	  (S : set (lie_subalgebra R L)), ↑(Inf S) = ⋂ (s : lie_subalgebra R L) (H : s ∈ S), ↑s", "decl_nm": "lie_subalgebra.Inf_coe"
{"src": "R : Type u,	L : Type v,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	S : set (lie_subalgebra R L)	⊢ ↑(Inf S) = ⋂ (s : lie_subalgebra R L) (H : s ∈ S), ↑s", "decl_nm": "lie_subalgebra.Inf_coe"
{"src": "R : Type u,	L : Type v,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	S : set (lie_subalgebra R L)	⊢ (⋂ (p : submodule R L) (H : p ∈ {_x : submodule R L | ∃ (s : lie_subalgebra R L) (H : s ∈ S), ↑s = _x}),	       ↑p) =	    ⋂ (s : lie_subalgebra R L) (H : s ∈ S), ↑s", "decl_nm": "lie_subalgebra.Inf_coe"
{"src": "R : Type u,	L : Type v,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	S : set (lie_subalgebra R L),	x : L	⊢ (x ∈	       ⋂ (p : submodule R L) (H : p ∈ {_x : submodule R L | ∃ (s : lie_subalgebra R L) (H : s ∈ S), ↑s = _x}),	         ↑p) ↔	    x ∈ ⋂ (s : lie_subalgebra R L) (H : s ∈ S), ↑s", "decl_nm": "lie_subalgebra.Inf_coe"
{"src": "⊢ ∀ {R : Type u} {L : Type v} {L' : Type w₂} [_inst_1 : comm_ring R] [_inst_2 : lie_ring L]	  [_inst_3 : lie_algebra R L] [_inst_4 : lie_ring L'] [_inst_5 : lie_algebra R L'] (f : L →ₗ⁅R⁆ L')	  (I : lie_ideal R L), I ≤ f.ker ↔ ∀ (x : L), x ∈ I → ⇑f x = 0", "decl_nm": "lie_hom.le_ker_iff"
{"src": "R : Type u,	L : Type v,	L' : Type w₂,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	f : L →ₗ⁅R⁆ L',	I : lie_ideal R L	⊢ I ≤ f.ker ↔ ∀ (x : L), x ∈ I → ⇑f x = 0", "decl_nm": "lie_hom.le_ker_iff"
{"src": "2 goals	R : Type u,	L : Type v,	L' : Type w₂,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	f : L →ₗ⁅R⁆ L',	I : lie_ideal R L	⊢ I ≤ f.ker → ∀ (x : L), x ∈ I → ⇑f x = 0		R : Type u,	L : Type v,	L' : Type w₂,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	f : L →ₗ⁅R⁆ L',	I : lie_ideal R L	⊢ (∀ (x : L), x ∈ I → ⇑f x = 0) → I ≤ f.ker", "decl_nm": "lie_hom.le_ker_iff"
{"src": "2 goals	R : Type u,	L : Type v,	L' : Type w₂,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	f : L →ₗ⁅R⁆ L',	I : lie_ideal R L,	h : I ≤ f.ker,	x : L,	hx : x ∈ I	⊢ ⇑f x = 0		R : Type u,	L : Type v,	L' : Type w₂,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	f : L →ₗ⁅R⁆ L',	I : lie_ideal R L	⊢ (∀ (x : L), x ∈ I → ⇑f x = 0) → I ≤ f.ker", "decl_nm": "lie_hom.le_ker_iff"
{"src": "2 goals	R : Type u,	L : Type v,	L' : Type w₂,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	f : L →ₗ⁅R⁆ L',	I : lie_ideal R L,	x : L,	hx : x ∈ I,	h : x ∈ f.ker	⊢ ⇑f x = 0		R : Type u,	L : Type v,	L' : Type w₂,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	f : L →ₗ⁅R⁆ L',	I : lie_ideal R L	⊢ (∀ (x : L), x ∈ I → ⇑f x = 0) → I ≤ f.ker", "decl_nm": "lie_hom.le_ker_iff"
{"src": "2 goals	R : Type u,	L : Type v,	L' : Type w₂,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	f : L →ₗ⁅R⁆ L',	I : lie_ideal R L,	x : L,	hx : x ∈ I,	h : ⇑f x = 0	⊢ ⇑f x = 0		R : Type u,	L : Type v,	L' : Type w₂,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	f : L →ₗ⁅R⁆ L',	I : lie_ideal R L	⊢ (∀ (x : L), x ∈ I → ⇑f x = 0) → I ≤ f.ker", "decl_nm": "lie_hom.le_ker_iff"
{"src": "R : Type u,	L : Type v,	L' : Type w₂,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	f : L →ₗ⁅R⁆ L',	I : lie_ideal R L	⊢ (∀ (x : L), x ∈ I → ⇑f x = 0) → I ≤ f.ker", "decl_nm": "lie_hom.le_ker_iff"
{"src": "R : Type u,	L : Type v,	L' : Type w₂,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	f : L →ₗ⁅R⁆ L',	I : lie_ideal R L,	h : ∀ (x : L), x ∈ I → ⇑f x = 0,	x : L,	hx : x ∈ I	⊢ x ∈ f.ker", "decl_nm": "lie_hom.le_ker_iff"
{"src": "R : Type u,	L : Type v,	L' : Type w₂,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : lie_ring L',	_inst_5 : lie_algebra R L',	f : L →ₗ⁅R⁆ L',	I : lie_ideal R L,	h : ∀ (x : L), x ∈ I → ⇑f x = 0,	x : L,	hx : x ∈ I	⊢ ⇑f x = 0", "decl_nm": "lie_hom.le_ker_iff"
{"src": "⊢ ∀ (R : Type u) [_inst_1 : comm_ring R] (L : Type v) (M : Type w) (N : Type w₁) (P : Type w₂)	  [_inst_2 : lie_ring L] [_inst_3 : lie_algebra R L] [_inst_4 : add_comm_group M] [_inst_5 : module R M]	  [_inst_6 : lie_ring_module L M] [_inst_7 : lie_module R L M] [_inst_8 : add_comm_group N] [_inst_9 : module R N]	  [_inst_10 : lie_ring_module L N] [_inst_11 : lie_module R L N] [_inst_12 : add_comm_group P] [_inst_13 : module R P]	  [_inst_14 : lie_ring_module L P] [_inst_15 : lie_module R L P] (f : M →ₗ⁅R,L⁆ N →ₗ[R] P) (m : M) (n : N),	    ⇑(⇑(lie_module.lift_lie R L M N P) f) (m ⊗ₜ[R] n) = ⇑(⇑f m) n", "decl_nm": "tensor_product.lie_module.lift_lie_apply"
{"src": "R : Type u,	_inst_1 : comm_ring R,	L : Type v,	M : Type w,	N : Type w₁,	P : Type w₂,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	_inst_4 : add_comm_group M,	_inst_5 : module R M,	_inst_6 : lie_ring_module L M,	_inst_7 : lie_module R L M,	_inst_8 : add_comm_group N,	_inst_9 : module R N,	_inst_10 : lie_ring_module L N,	_inst_11 : lie_module R L N,	_inst_12 : add_comm_group P,	_inst_13 : module R P,	_inst_14 : lie_ring_module L P,	_inst_15 : lie_module R L P,	f : M →ₗ⁅R,L⁆ N →ₗ[R] P,	m : M,	n : N	⊢ ⇑(⇑(lie_module.lift_lie R L M N P) f) (m ⊗ₜ[R] n) = ⇑(⇑f m) n", "decl_nm": "tensor_product.lie_module.lift_lie_apply"
{"src": "⊢ ∀ (R : Type u₁) {L : Type u₂} [_inst_1 : comm_ring R] [_inst_2 : lie_ring L] [_inst_3 : lie_algebra R L]	  {A : Type u₃} [_inst_4 : ring A] [_inst_5 : algebra R A] (f : L →ₗ⁅R⁆ A) (x : L),	    ⇑(⇑(lift R) f) (⇑(ι R) x) = ⇑f x", "decl_nm": "universal_enveloping_algebra.lift_ι_apply"
{"src": "R : Type u₁,	L : Type u₂,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	A : Type u₃,	_inst_4 : ring A,	_inst_5 : algebra R A,	f : L →ₗ⁅R⁆ A,	x : L	⊢ ⇑(⇑(lift R) f) (⇑(ι R) x) = ⇑f x", "decl_nm": "universal_enveloping_algebra.lift_ι_apply"
{"src": "⊢ ∀ {R : Type u} {L : Type v} [_inst_1 : comm_ring R] [_inst_2 : lie_ring L] [_inst_3 : lie_algebra R L]	  (M : Type w) [_inst_5 : add_comm_group M] [_inst_6 : module R M] [_inst_7 : lie_ring_module L M]	  [_inst_8 : lie_module R L M] [_inst_9 : is_nilpotent R L] [_inst_10 : is_nilpotent R L M], weight_space M 0 = ⊤", "decl_nm": "lie_module.zero_weight_space_eq_top_of_nilpotent"
{"src": "R : Type u,	L : Type v,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	M : Type w,	_inst_5 : add_comm_group M,	_inst_6 : module R M,	_inst_7 : lie_ring_module L M,	_inst_8 : lie_module R L M,	_inst_9 : is_nilpotent R L,	_inst_10 : is_nilpotent R L M	⊢ weight_space M 0 = ⊤", "decl_nm": "lie_module.zero_weight_space_eq_top_of_nilpotent"
{"src": "2 goals	R : Type u,	L : Type v,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	M : Type w,	_inst_5 : add_comm_group M,	_inst_6 : module R M,	_inst_7 : lie_ring_module L M,	_inst_8 : lie_module R L M,	_inst_9 : is_nilpotent R L,	_inst_10 : is_nilpotent R L M	⊢ 0 ∘ ⇑(⊤.incl) = 0		R : Type u,	L : Type v,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	M : Type w,	_inst_5 : add_comm_group M,	_inst_6 : module R M,	_inst_7 : lie_ring_module L M,	_inst_8 : lie_module R L M,	_inst_9 : is_nilpotent R L,	_inst_10 : is_nilpotent R L M,	h₀ : 0 ∘ ⇑(⊤.incl) = 0	⊢ weight_space M 0 = ⊤", "decl_nm": "lie_module.zero_weight_space_eq_top_of_nilpotent"
{"src": "2 goals	R : Type u,	L : Type v,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	M : Type w,	_inst_5 : add_comm_group M,	_inst_6 : module R M,	_inst_7 : lie_ring_module L M,	_inst_8 : lie_module R L M,	_inst_9 : is_nilpotent R L,	_inst_10 : is_nilpotent R L M,	x : ↥⊤	⊢ (0 ∘ ⇑(⊤.incl)) x = 0 x		R : Type u,	L : Type v,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	M : Type w,	_inst_5 : add_comm_group M,	_inst_6 : module R M,	_inst_7 : lie_ring_module L M,	_inst_8 : lie_module R L M,	_inst_9 : is_nilpotent R L,	_inst_10 : is_nilpotent R L M,	h₀ : 0 ∘ ⇑(⊤.incl) = 0	⊢ weight_space M 0 = ⊤", "decl_nm": "lie_module.zero_weight_space_eq_top_of_nilpotent"
{"src": "R : Type u,	L : Type v,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	M : Type w,	_inst_5 : add_comm_group M,	_inst_6 : module R M,	_inst_7 : lie_ring_module L M,	_inst_8 : lie_module R L M,	_inst_9 : is_nilpotent R L,	_inst_10 : is_nilpotent R L M,	h₀ : 0 ∘ ⇑(⊤.incl) = 0	⊢ weight_space M 0 = ⊤", "decl_nm": "lie_module.zero_weight_space_eq_top_of_nilpotent"
{"src": "R : Type u,	L : Type v,	_inst_1 : comm_ring R,	_inst_2 : lie_ring L,	_inst_3 : lie_algebra R L,	M : Type w,	_inst_5 : add_comm_group M,	_inst_6 : module R M,	_inst_7 : lie_ring_module L M,	_inst_8 : lie_module R L M,	_inst_9 : is_nilpotent R L,	_inst_10 : is_nilpotent R L M,	h₀ : 0 ∘ ⇑(⊤.incl) = 0	⊢ ↑(weight_space M 0) = ⨅ (x : L), (⇑(to_endomorphism R L M) x).maximal_generalized_eigenspace 0", "decl_nm": "lie_module.zero_weight_space_eq_top_of_nilpotent"
{"src": "⊢ ∀ {k : Type u_1} {M : Type u_2} [_inst_1 : ordered_ring k] [_inst_2 : ordered_add_comm_group M]	  [_inst_3 : module k M] [_inst_4 : ordered_smul k M] {a b : M} {c : k}, a < b → c < 0 → c • b < c • a", "decl_nm": "smul_lt_smul_of_neg"
{"src": "k : Type u_1,	M : Type u_2,	_inst_1 : ordered_ring k,	_inst_2 : ordered_add_comm_group M,	_inst_3 : module k M,	_inst_4 : ordered_smul k M,	a b : M,	c : k,	h : a < b,	hc : c < 0	⊢ c • b < c • a", "decl_nm": "smul_lt_smul_of_neg"
{"src": "k : Type u_1,	M : Type u_2,	_inst_1 : ordered_ring k,	_inst_2 : ordered_add_comm_group M,	_inst_3 : module k M,	_inst_4 : ordered_smul k M,	a b : M,	c : k,	h : a < b,	hc : c < 0	⊢ -c • a < -c • b", "decl_nm": "smul_lt_smul_of_neg"
{"src": "⊢ ∀ {k : Type u_1} {M : Type u_2} [_inst_1 : ordered_ring k] [_inst_2 : ordered_add_comm_group M]	  [_inst_3 : module k M] [_inst_4 : ordered_smul k M] {a b : M} {c : k}, c < 0 → (c • a < c • b ↔ b < a)", "decl_nm": "smul_lt_smul_iff_of_neg"
{"src": "k : Type u_1,	M : Type u_2,	_inst_1 : ordered_ring k,	_inst_2 : ordered_add_comm_group M,	_inst_3 : module k M,	_inst_4 : ordered_smul k M,	a b : M,	c : k,	hc : c < 0	⊢ c • a < c • b ↔ b < a", "decl_nm": "smul_lt_smul_iff_of_neg"
{"src": "k : Type u_1,	M : Type u_2,	_inst_1 : ordered_ring k,	_inst_2 : ordered_add_comm_group M,	_inst_3 : module k M,	_inst_4 : ordered_smul k M,	a b : M,	c : k,	hc : c < 0	⊢ -c • b < -c • a ↔ b < a", "decl_nm": "smul_lt_smul_iff_of_neg"
{"src": "⊢ ∀ {K : Type u_1} {ι : Type u_2} {R : ι → Type u_3} [_inst_1 : Π (i : ι), has_scalar K (R i)] (r : K)	  (s : set ι) (t : Π (i : ι), set (R i)), r • s.pi t ⊆ s.pi (r • t)", "decl_nm": "smul_pi_subset"
{"src": "K : Type u_1,	ι : Type u_2,	R : ι → Type u_3,	_inst_1 : Π (i : ι), has_scalar K (R i),	r : K,	s : set ι,	t : Π (i : ι), set (R i)	⊢ r • s.pi t ⊆ s.pi (r • t)", "decl_nm": "smul_pi_subset"
{"src": "K : Type u_1,	ι : Type u_2,	R : ι → Type u_3,	_inst_1 : Π (i : ι), has_scalar K (R i),	r : K,	s : set ι,	t : Π (i : ι), set (R i),	i : ι,	hi : i ∈ s,	y : Π (i : ι), R i,	h : y ∈ s.pi t	⊢ (r • y) i ∈ (r • t) i", "decl_nm": "smul_pi_subset"
{"src": "⊢ ∀ {R : Type u_1} {M : Type u_3} [_inst_1 : semiring R] [_inst_3 : add_comm_monoid M] [_inst_4 : module R M]	  {ι : Sort u_2} (p : ι → submodule R M), (↑⨅ (i : ι), p i) = ⋂ (i : ι), ↑(p i)", "decl_nm": "submodule.infi_coe"
{"src": "R : Type u_1,	M : Type u_3,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	ι : Sort u_2,	p : ι → submodule R M	⊢ (↑⨅ (i : ι), p i) = ⋂ (i : ι), ↑(p i)", "decl_nm": "submodule.infi_coe"
{"src": "R : Type u_1,	M : Type u_3,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	ι : Sort u_2,	p : ι → submodule R M	⊢ (⋂ (p_1 : submodule R M) (H : p_1 ∈ set.range (λ (i : ι), p i)), ↑p_1) = ⋂ (i : ι), ↑(p i)", "decl_nm": "submodule.infi_coe"
{"src": "R : Type u_1,	M : Type u_3,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	ι : Sort u_2,	p : ι → submodule R M,	a : M	⊢ (a ∈ ⋂ (p_1 : submodule R M) (H : p_1 ∈ set.range (λ (i : ι), p i)), ↑p_1) ↔	    a ∈ ⋂ (i : ι), ↑(p i)", "decl_nm": "submodule.infi_coe"
{"src": "⊢ ∀ {R : Type u_1} {S : Type u_2} [_inst_1 : ring R] [_inst_2 : linear_ordered_comm_ring S]	  (abv : absolute_value R S) (a : R), ⇑abv (-a) = ⇑abv a", "decl_nm": "absolute_value.map_neg"
{"src": "R : Type u_1,	S : Type u_2,	_inst_1 : ring R,	_inst_2 : linear_ordered_comm_ring S,	abv : absolute_value R S,	a : R	⊢ ⇑abv (-a) = ⇑abv a", "decl_nm": "absolute_value.map_neg"
{"src": "2 goals	R : Type u_1,	S : Type u_2,	_inst_1 : ring R,	_inst_2 : linear_ordered_comm_ring S,	abv : absolute_value R S,	a : R,	ha : a = 0	⊢ ⇑abv (-a) = ⇑abv a		R : Type u_1,	S : Type u_2,	_inst_1 : ring R,	_inst_2 : linear_ordered_comm_ring S,	abv : absolute_value R S,	a : R,	ha : ¬a = 0	⊢ ⇑abv (-a) = ⇑abv a", "decl_nm": "absolute_value.map_neg"
{"src": "R : Type u_1,	S : Type u_2,	_inst_1 : ring R,	_inst_2 : linear_ordered_comm_ring S,	abv : absolute_value R S,	a : R,	ha : ¬a = 0	⊢ ⇑abv (-a) = ⇑abv a", "decl_nm": "absolute_value.map_neg"
{"src": "R : Type u_1,	S : Type u_2,	_inst_1 : ring R,	_inst_2 : linear_ordered_comm_ring S,	abv : absolute_value R S,	a : R,	ha : ¬a = 0	⊢ ¬⇑abv (-a) = -⇑abv a", "decl_nm": "absolute_value.map_neg"
{"src": "⊢ ∀ {S : Type u_1} [_inst_1 : linear_ordered_field S] {R : Type u_2} [_inst_2 : ring R] (abv : R → S)	  [_inst_3 : is_absolute_value abv] (a b : R), abv (a - b) = abv (b - a)", "decl_nm": "is_absolute_value.abv_sub"
{"src": "S : Type u_1,	_inst_1 : linear_ordered_field S,	R : Type u_2,	_inst_2 : ring R,	abv : R → S,	_inst_3 : is_absolute_value abv,	a b : R	⊢ abv (a - b) = abv (b - a)", "decl_nm": "is_absolute_value.abv_sub"
{"src": "⊢ ∀ {α : Type u_1} [_inst_1 : has_lt α] {a b : α} {o : ordering}, o.swap.compares a b ↔ o.compares b a", "decl_nm": "ordering.compares_swap"
{"src": "α : Type u_1,	_inst_1 : has_lt α,	a b : α,	o : ordering	⊢ o.swap.compares a b ↔ o.compares b a", "decl_nm": "ordering.compares_swap"
{"src": "3 goals	case ordering.lt	α : Type u_1,	_inst_1 : has_lt α,	a b : α	⊢ lt.swap.compares a b ↔ lt.compares b a		case ordering.eq	α : Type u_1,	_inst_1 : has_lt α,	a b : α	⊢ eq.swap.compares a b ↔ eq.compares b a		case ordering.gt	α : Type u_1,	_inst_1 : has_lt α,	a b : α	⊢ gt.swap.compares a b ↔ gt.compares b a", "decl_nm": "ordering.compares_swap"
{"src": "⊢ ∀ {α : Type u_1} [_inst_1 : linear_ordered_field α] {a b c : α}, 0 < c → (a ≤ b / c ↔ c * a ≤ b)", "decl_nm": "le_div_iff'"
{"src": "α : Type u_1,	_inst_1 : linear_ordered_field α,	a b c : α,	hc : 0 < c	⊢ a ≤ b / c ↔ c * a ≤ b", "decl_nm": "le_div_iff'"
{"src": "⊢ ∀ {α : Type u_1} [_inst_1 : linear_ordered_field α] {a b c : α}, 0 ≤ c → a ≤ b → a / c ≤ b / c", "decl_nm": "div_le_div_of_le"
{"src": "α : Type u_1,	_inst_1 : linear_ordered_field α,	a b c : α,	hc : 0 ≤ c,	h : a ≤ b	⊢ a / c ≤ b / c", "decl_nm": "div_le_div_of_le"
{"src": "α : Type u_1,	_inst_1 : linear_ordered_field α,	a b c : α,	hc : 0 ≤ c,	h : a ≤ b	⊢ a * (1 / c) ≤ b * (1 / c)", "decl_nm": "div_le_div_of_le"
{"src": "⊢ ∀ {α : Type u_1} [_inst_1 : linear_ordered_field α] {a b : α},	    a / b < 1 ↔ 0 < b ∧ a < b ∨ b = 0 ∨ b < 0 ∧ b < a", "decl_nm": "div_lt_one_iff"
{"src": "α : Type u_1,	_inst_1 : linear_ordered_field α,	a b : α	⊢ a / b < 1 ↔ 0 < b ∧ a < b ∨ b = 0 ∨ b < 0 ∧ b < a", "decl_nm": "div_lt_one_iff"
{"src": "3 goals	α : Type u_1,	_inst_1 : linear_ordered_field α,	a b : α,	hb : b < 0	⊢ a / b < 1 ↔ 0 < b ∧ a < b ∨ b = 0 ∨ b < 0 ∧ b < a		α : Type u_1,	_inst_1 : linear_ordered_field α,	a : α	⊢ a / 0 < 1 ↔ 0 < 0 ∧ a < 0 ∨ 0 = 0 ∨ 0 < 0 ∧ 0 < a		α : Type u_1,	_inst_1 : linear_ordered_field α,	a b : α,	hb : 0 < b	⊢ a / b < 1 ↔ 0 < b ∧ a < b ∨ b = 0 ∨ b < 0 ∧ b < a", "decl_nm": "div_lt_one_iff"
{"src": "2 goals	α : Type u_1,	_inst_1 : linear_ordered_field α,	a : α	⊢ a / 0 < 1 ↔ 0 < 0 ∧ a < 0 ∨ 0 = 0 ∨ 0 < 0 ∧ 0 < a		α : Type u_1,	_inst_1 : linear_ordered_field α,	a b : α,	hb : 0 < b	⊢ a / b < 1 ↔ 0 < b ∧ a < b ∨ b = 0 ∨ b < 0 ∧ b < a", "decl_nm": "div_lt_one_iff"
{"src": "α : Type u_1,	_inst_1 : linear_ordered_field α,	a b : α,	hb : 0 < b	⊢ a / b < 1 ↔ 0 < b ∧ a < b ∨ b = 0 ∨ b < 0 ∧ b < a", "decl_nm": "div_lt_one_iff"
{"src": "⊢ ∀ {α : Type u_1} [_inst_1 : linear_ordered_field α] {a b : α}, 0 < a → a ≤ b → 1 / b ≤ 1 / a", "decl_nm": "one_div_le_one_div_of_le"
{"src": "α : Type u_1,	_inst_1 : linear_ordered_field α,	a b : α,	ha : 0 < a,	h : a ≤ b	⊢ 1 / b ≤ 1 / a", "decl_nm": "one_div_le_one_div_of_le"
{"src": "⊢ ∀ {α : Type u} [_inst_1 : linear_ordered_add_comm_group α] {a b : α},	    0 ≤ b → (|a| = b ↔ a = b ∨ a = -b)", "decl_nm": "abs_eq"
{"src": "α : Type u,	_inst_1 : linear_ordered_add_comm_group α,	a b : α,	hb : 0 ≤ b	⊢ |a| = b ↔ a = b ∨ a = -b", "decl_nm": "abs_eq"
{"src": "α : Type u,	_inst_1 : linear_ordered_add_comm_group α,	a b : α,	hb : 0 ≤ b	⊢ a = b ∨ a = -b → |a| = b", "decl_nm": "abs_eq"
{"src": "2 goals	α : Type u,	_inst_1 : linear_ordered_add_comm_group α,	a : α,	hb : 0 ≤ a	⊢ |a| = a		α : Type u,	_inst_1 : linear_ordered_add_comm_group α,	b : α,	hb : 0 ≤ b	⊢ | -b| = b", "decl_nm": "abs_eq"
{"src": "α : Type u,	_inst_1 : linear_ordered_add_comm_group α,	b : α,	hb : 0 ≤ b	⊢ | -b| = b", "decl_nm": "abs_eq"
{"src": "⊢ ∀ {α : Type u} [_inst_1 : group α] [_inst_2 : has_lt α]	  [_inst_3 : covariant_class α α (swap has_mul.mul) has_lt.lt] {a : α}, 1 < a⁻¹ ↔ a < 1", "decl_nm": "right.one_lt_inv_iff"
{"src": "α : Type u,	_inst_1 : group α,	_inst_2 : has_lt α,	_inst_3 : covariant_class α α (swap has_mul.mul) has_lt.lt,	a : α	⊢ 1 < a⁻¹ ↔ a < 1", "decl_nm": "right.one_lt_inv_iff"
{"src": "⊢ ∀ {α : Type u} [_inst_1 : comm_group α] [_inst_2 : has_le α]	  [_inst_3 : covariant_class α α has_mul.mul has_le.le] {a b c : α}, a / b ≤ c ↔ a ≤ b * c", "decl_nm": "div_le_iff_le_mul'"
{"src": "α : Type u,	_inst_1 : comm_group α,	_inst_2 : has_le α,	_inst_3 : covariant_class α α has_mul.mul has_le.le,	a b c : α	⊢ a / b ≤ c ↔ a ≤ b * c", "decl_nm": "div_le_iff_le_mul'"
{"src": "⊢ ∀ {α : Type u} [_inst_1 : has_neg α] [_inst_2 : linear_order α] {a : α}, |a| = max a (-a)", "decl_nm": "abs_eq_max_neg"
{"src": "α : Type u,	_inst_1 : has_neg α,	_inst_2 : linear_order α,	a : α	⊢ |a| = max a (-a)", "decl_nm": "abs_eq_max_neg"
{"src": "⊢ ∀ {α : Type u} [_inst_1 : linear_ordered_ring α] {a b : α},	    0 ≤ a * b ↔ 0 ≤ a ∧ 0 ≤ b ∨ a ≤ 0 ∧ b ≤ 0", "decl_nm": "mul_nonneg_iff"
{"src": "α : Type u,	_inst_1 : linear_ordered_ring α,	a b : α	⊢ 0 ≤ a * b ↔ 0 ≤ a ∧ 0 ≤ b ∨ a ≤ 0 ∧ b ≤ 0", "decl_nm": "mul_nonneg_iff"
{"src": "α : Type u,	_inst_1 : linear_ordered_ring α,	a b : α,	_inst : decidable_rel has_le.le	⊢ 0 ≤ a * b ↔ 0 ≤ a ∧ 0 ≤ b ∨ a ≤ 0 ∧ b ≤ 0", "decl_nm": "mul_nonneg_iff"
{"src": "⊢ ∀ {α : Type u} [_inst_1 : ring α] [_inst_2 : linear_order α] (a b : α), a ∣ |b| ↔ a ∣ b", "decl_nm": "dvd_abs"
{"src": "α : Type u,	_inst_1 : ring α,	_inst_2 : linear_order α,	a b : α	⊢ a ∣ |b| ↔ a ∣ b", "decl_nm": "dvd_abs"
{"src": "2 goals	case or.inl	α : Type u,	_inst_1 : ring α,	_inst_2 : linear_order α,	a b : α,	h : |b| = b	⊢ a ∣ |b| ↔ a ∣ b		case or.inr	α : Type u,	_inst_1 : ring α,	_inst_2 : linear_order α,	a b : α,	h : |b| = -b	⊢ a ∣ |b| ↔ a ∣ b", "decl_nm": "dvd_abs"
{"src": "case or.inr	α : Type u,	_inst_1 : ring α,	_inst_2 : linear_order α,	a b : α,	h : |b| = -b	⊢ a ∣ |b| ↔ a ∣ b", "decl_nm": "dvd_abs"
{"src": "⊢ ∀ {α : Type u} [_inst_1 : linear_ordered_semiring α] {a b c : α}, c * a < c * b → 0 ≤ c → a < b", "decl_nm": "lt_of_mul_lt_mul_left"
{"src": "α : Type u,	_inst_1 : linear_ordered_semiring α,	a b c : α,	h : c * a < c * b,	hc : 0 ≤ c	⊢ a < b", "decl_nm": "lt_of_mul_lt_mul_left"
{"src": "α : Type u,	_inst_1 : linear_ordered_semiring α,	a b c : α,	h : c * a < c * b,	hc : 0 ≤ c,	_inst : decidable_rel has_le.le	⊢ a < b", "decl_nm": "lt_of_mul_lt_mul_left"
{"src": "⊢ ∀ {α : Type u} [_inst_1 : linear_ordered_semiring α] {a b c : α}, a * c < b * c → 0 ≤ c → a < b", "decl_nm": "lt_of_mul_lt_mul_right"
{"src": "α : Type u,	_inst_1 : linear_ordered_semiring α,	a b c : α,	h : a * c < b * c,	hc : 0 ≤ c	⊢ a < b", "decl_nm": "lt_of_mul_lt_mul_right"
{"src": "α : Type u,	_inst_1 : linear_ordered_semiring α,	a b c : α,	h : a * c < b * c,	hc : 0 ≤ c,	_inst : decidable_rel has_le.le	⊢ a < b", "decl_nm": "lt_of_mul_lt_mul_right"
{"src": "⊢ ∀ {R : Type u} {ι : Type w} (s : finset ι) [_inst_1 : comm_semiring R] (f : ι → polynomial R),	    s.prod (λ (i : ι), (f i).leading_coeff) ≠ 0 →	    (s.prod (λ (i : ι), f i)).leading_coeff = s.prod (λ (i : ι), (f i).leading_coeff)", "decl_nm": "polynomial.leading_coeff_prod'"
{"src": "R : Type u,	ι : Type w,	s : finset ι,	_inst_1 : comm_semiring R,	f : ι → polynomial R,	h : s.prod (λ (i : ι), (f i).leading_coeff) ≠ 0	⊢ (s.prod (λ (i : ι), f i)).leading_coeff = s.prod (λ (i : ι), (f i).leading_coeff)", "decl_nm": "polynomial.leading_coeff_prod'"
{"src": "⊢ ∀ {R : Type u_1} [_inst_1 : rack R] (x : R) {y y' : R}, inv_act x y = inv_act x y' ↔ y = y'", "decl_nm": "rack.left_cancel_inv"
{"src": "R : Type u_1,	_inst_1 : rack R,	x y y' : R	⊢ inv_act x y = inv_act x y' ↔ y = y'", "decl_nm": "rack.left_cancel_inv"
{"src": "2 goals	R : Type u_1,	_inst_1 : rack R,	x y y' : R	⊢ inv_act x y = inv_act x y' → y = y'		R : Type u_1,	_inst_1 : rack R,	x y y' : R	⊢ y = y' → inv_act x y = inv_act x y'", "decl_nm": "rack.left_cancel_inv"
{"src": "R : Type u_1,	_inst_1 : rack R,	x y y' : R	⊢ y = y' → inv_act x y = inv_act x y'", "decl_nm": "rack.left_cancel_inv"
{"src": "R : Type u_1,	_inst_1 : rack R,	x y : R	⊢ inv_act x y = inv_act x y", "decl_nm": "rack.left_cancel_inv"
{"src": "⊢ ∀ {R : Type u_1} [_inst_1 : comm_ring R] {c₁ c₂ : R} (a b : quaternion_algebra R c₁ c₂),	    ⇑conj (a * b) = ⇑conj b * ⇑conj a", "decl_nm": "quaternion_algebra.conj_mul"
{"src": "R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R,	a b : quaternion_algebra R c₁ c₂	⊢ ⇑conj (a * b) = ⇑conj b * ⇑conj a", "decl_nm": "quaternion_algebra.conj_mul"
{"src": "4 goals	R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R,	a b : quaternion_algebra R c₁ c₂	⊢ (⇑conj (a * b)).re = (⇑conj b * ⇑conj a).re		R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R,	a b : quaternion_algebra R c₁ c₂	⊢ (⇑conj (a * b)).im_i = (⇑conj b * ⇑conj a).im_i		R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R,	a b : quaternion_algebra R c₁ c₂	⊢ (⇑conj (a * b)).im_j = (⇑conj b * ⇑conj a).im_j		R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R,	a b : quaternion_algebra R c₁ c₂	⊢ (⇑conj (a * b)).im_k = (⇑conj b * ⇑conj a).im_k", "decl_nm": "quaternion_algebra.conj_mul"
{"src": "4 goals	R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R,	a b : quaternion_algebra R c₁ c₂	⊢ a.re * b.re + c₁ * a.im_i * b.im_i + c₂ * a.im_j * b.im_j - c₁ * c₂ * a.im_k * b.im_k =	    b.re * a.re + c₁ * b.im_i * a.im_i + c₂ * b.im_j * a.im_j - c₁ * c₂ * b.im_k * a.im_k		R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R,	a b : quaternion_algebra R c₁ c₂	⊢ (⇑conj (a * b)).im_i = (⇑conj b * ⇑conj a).im_i		R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R,	a b : quaternion_algebra R c₁ c₂	⊢ (⇑conj (a * b)).im_j = (⇑conj b * ⇑conj a).im_j		R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R,	a b : quaternion_algebra R c₁ c₂	⊢ (⇑conj (a * b)).im_k = (⇑conj b * ⇑conj a).im_k", "decl_nm": "quaternion_algebra.conj_mul"
{"src": "3 goals	R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R,	a b : quaternion_algebra R c₁ c₂	⊢ (⇑conj (a * b)).im_i = (⇑conj b * ⇑conj a).im_i		R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R,	a b : quaternion_algebra R c₁ c₂	⊢ (⇑conj (a * b)).im_j = (⇑conj b * ⇑conj a).im_j		R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R,	a b : quaternion_algebra R c₁ c₂	⊢ (⇑conj (a * b)).im_k = (⇑conj b * ⇑conj a).im_k", "decl_nm": "quaternion_algebra.conj_mul"
{"src": "3 goals	R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R,	a b : quaternion_algebra R c₁ c₂	⊢ -(c₂ * a.im_k * b.im_j) + (c₂ * a.im_j * b.im_k - (a.re * b.im_i + a.im_i * b.re)) =	    -(b.re * a.im_i) + -(b.im_i * a.re) - c₂ * b.im_j * a.im_k + c₂ * b.im_k * a.im_j		R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R,	a b : quaternion_algebra R c₁ c₂	⊢ (⇑conj (a * b)).im_j = (⇑conj b * ⇑conj a).im_j		R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R,	a b : quaternion_algebra R c₁ c₂	⊢ (⇑conj (a * b)).im_k = (⇑conj b * ⇑conj a).im_k", "decl_nm": "quaternion_algebra.conj_mul"
{"src": "2 goals	R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R,	a b : quaternion_algebra R c₁ c₂	⊢ (⇑conj (a * b)).im_j = (⇑conj b * ⇑conj a).im_j		R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R,	a b : quaternion_algebra R c₁ c₂	⊢ (⇑conj (a * b)).im_k = (⇑conj b * ⇑conj a).im_k", "decl_nm": "quaternion_algebra.conj_mul"
{"src": "2 goals	R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R,	a b : quaternion_algebra R c₁ c₂	⊢ c₁ * a.im_k * b.im_i - (a.re * b.im_j + c₁ * a.im_i * b.im_k + a.im_j * b.re) =	    -(b.re * a.im_j) + c₁ * b.im_i * a.im_k + -(b.im_j * a.re) - c₁ * b.im_k * a.im_i		R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R,	a b : quaternion_algebra R c₁ c₂	⊢ (⇑conj (a * b)).im_k = (⇑conj b * ⇑conj a).im_k", "decl_nm": "quaternion_algebra.conj_mul"
{"src": "R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R,	a b : quaternion_algebra R c₁ c₂	⊢ (⇑conj (a * b)).im_k = (⇑conj b * ⇑conj a).im_k", "decl_nm": "quaternion_algebra.conj_mul"
{"src": "R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R,	a b : quaternion_algebra R c₁ c₂	⊢ -(a.im_k * b.re) + (a.im_j * b.im_i - (a.re * b.im_k + a.im_i * b.im_j)) =	    -(b.re * a.im_k) + b.im_i * a.im_j - b.im_j * a.im_i + -(b.im_k * a.re)", "decl_nm": "quaternion_algebra.conj_mul"
{"src": "⊢ ∀ {R : Type u_1} [_inst_1 : linear_ordered_comm_ring R] {a : quaternion R}, ⇑norm_sq a ≤ 0 ↔ a = 0", "decl_nm": "quaternion.norm_sq_le_zero"
{"src": "R : Type u_1,	_inst_1 : linear_ordered_comm_ring R,	a : quaternion R	⊢ ⇑norm_sq a ≤ 0 ↔ a = 0", "decl_nm": "quaternion.norm_sq_le_zero"
{"src": "⊢ ∀ {R : Type x} [_inst_1 : distrib R] {a b x y : R},	    semiconj_by a x y → semiconj_by b x y → semiconj_by (a + b) x y", "decl_nm": "semiconj_by.add_left"
{"src": "R : Type x,	_inst_1 : distrib R,	a b x y : R,	ha : semiconj_by a x y,	hb : semiconj_by b x y	⊢ semiconj_by (a + b) x y", "decl_nm": "semiconj_by.add_left"
{"src": "⊢ ∀ {α : Type u_1} [_inst_2 : mul_zero_class α] (P : Prop) [_inst_3 : decidable P] (a b : α),	    ite P (a * b) 0 = ite P a 0 * b", "decl_nm": "ite_mul_zero_left"
{"src": "α : Type u_1,	_inst_2 : mul_zero_class α,	P : Prop,	_inst_3 : decidable P,	a b : α	⊢ ite P (a * b) 0 = ite P a 0 * b", "decl_nm": "ite_mul_zero_left"
{"src": "2 goals	α : Type u_1,	_inst_2 : mul_zero_class α,	P : Prop,	_inst_3 : decidable P,	a b : α,	h : P	⊢ ite P (a * b) 0 = ite P a 0 * b		α : Type u_1,	_inst_2 : mul_zero_class α,	P : Prop,	_inst_3 : decidable P,	a b : α,	h : ¬P	⊢ ite P (a * b) 0 = ite P a 0 * b", "decl_nm": "ite_mul_zero_left"
{"src": "α : Type u_1,	_inst_2 : mul_zero_class α,	P : Prop,	_inst_3 : decidable P,	a b : α,	h : ¬P	⊢ ite P (a * b) 0 = ite P a 0 * b", "decl_nm": "ite_mul_zero_left"
{"src": "⊢ ∀ {α : Type u} [_inst_1 : ring α] (a b c : α), (a - b) * c = a * c - b * c", "decl_nm": "mul_sub_right_distrib"
{"src": "α : Type u,	_inst_1 : ring α,	a b c : α	⊢ (a - b) * c = a * c - b * c", "decl_nm": "mul_sub_right_distrib"
{"src": "⊢ ∀ {α : Type u_1} [_inst_1 : boolean_ring α] (a : α), a * (1 + a) = 0", "decl_nm": "mul_one_add_self"
{"src": "α : Type u_1,	_inst_1 : boolean_ring α,	a : α	⊢ a * (1 + a) = 0", "decl_nm": "mul_one_add_self"
{"src": "⊢ ∀ {A : Type u_1} {B : Type u_2} [_inst_1 : decidable_eq A] [_inst_2 : has_zero B] {a : A} {b : B},	    support (single a b) ⊆ {a}", "decl_nm": "pi.support_single_subset"
{"src": "A : Type u_1,	B : Type u_2,	_inst_1 : decidable_eq A,	_inst_2 : has_zero B,	a : A,	b : B	⊢ support (single a b) ⊆ {a}", "decl_nm": "pi.support_single_subset"
{"src": "A : Type u_1,	B : Type u_2,	_inst_1 : decidable_eq A,	_inst_2 : has_zero B,	a : A,	b : B,	_inst : Π (a : Prop), decidable a	⊢ support (single a b) ⊆ {a}", "decl_nm": "pi.support_single_subset"
{"src": "A : Type u_1,	B : Type u_2,	_inst_1 : decidable_eq A,	_inst_2 : has_zero B,	a : A,	b : B,	_inst : Π (a : Prop), decidable a	⊢ ite (b = 0) ∅ {a} ⊆ {a}", "decl_nm": "pi.support_single_subset"
{"src": "2 goals	A : Type u_1,	B : Type u_2,	_inst_1 : decidable_eq A,	_inst_2 : has_zero B,	a : A,	b : B,	_inst : Π (a : Prop), decidable a,	h : b = 0	⊢ ∅ ⊆ {a}		A : Type u_1,	B : Type u_2,	_inst_1 : decidable_eq A,	_inst_2 : has_zero B,	a : A,	b : B,	_inst : Π (a : Prop), decidable a,	h : ¬b = 0	⊢ {a} ⊆ {a}", "decl_nm": "pi.support_single_subset"
{"src": "⊢ ∀ {R : Type u} [_inst_1 : linear_order R] [_inst_2 : add_monoid R]	  [_inst_3 : covariant_class R R has_add.add has_le.le]	  [_inst_4 : covariant_class R R (function.swap has_add.add) has_le.le] (x y : tropical R) (n : ℕ),	    (x + y) ^ n = x ^ n + y ^ n", "decl_nm": "tropical.add_pow"
{"src": "R : Type u,	_inst_1 : linear_order R,	_inst_2 : add_monoid R,	_inst_3 : covariant_class R R has_add.add has_le.le,	_inst_4 : covariant_class R R (function.swap has_add.add) has_le.le,	x y : tropical R,	n : ℕ	⊢ (x + y) ^ n = x ^ n + y ^ n", "decl_nm": "tropical.add_pow"
{"src": "2 goals	case or.inl	R : Type u,	_inst_1 : linear_order R,	_inst_2 : add_monoid R,	_inst_3 : covariant_class R R has_add.add has_le.le,	_inst_4 : covariant_class R R (function.swap has_add.add) has_le.le,	x y : tropical R,	n : ℕ,	h : x ≤ y	⊢ (x + y) ^ n = x ^ n + y ^ n		case or.inr	R : Type u,	_inst_1 : linear_order R,	_inst_2 : add_monoid R,	_inst_3 : covariant_class R R has_add.add has_le.le,	_inst_4 : covariant_class R R (function.swap has_add.add) has_le.le,	x y : tropical R,	n : ℕ,	h : y ≤ x	⊢ (x + y) ^ n = x ^ n + y ^ n", "decl_nm": "tropical.add_pow"
{"src": "case or.inr	R : Type u,	_inst_1 : linear_order R,	_inst_2 : add_monoid R,	_inst_3 : covariant_class R R has_add.add has_le.le,	_inst_4 : covariant_class R R (function.swap has_add.add) has_le.le,	x y : tropical R,	n : ℕ,	h : y ≤ x	⊢ (x + y) ^ n = x ^ n + y ^ n", "decl_nm": "tropical.add_pow"
{"src": "⊢ ∀ {C : Type u} [_inst_1 : category C] [_inst_2 : has_colimits C] {U : Top} (X : PresheafedSpace C)	  {f : U ⟶ ↑X} (h : open_embedding ⇑f) (V : opens ↥U) (x : ↥U) (hx : x ∈ V),	    X.presheaf.germ ⟨⇑f x, _⟩ ≫ (X.restrict_stalk_iso h x).inv = (X.restrict h).presheaf.germ ⟨x, hx⟩", "decl_nm": "algebraic_geometry.PresheafedSpace.restrict_stalk_iso_inv_eq_germ"
{"src": "C : Type u,	_inst_1 : category C,	_inst_2 : has_colimits C,	U : Top,	X : PresheafedSpace C,	f : U ⟶ ↑X,	h : open_embedding ⇑f,	V : opens ↥U,	x : ↥U,	hx : x ∈ V	⊢ X.presheaf.germ ⟨⇑f x, _⟩ ≫ (X.restrict_stalk_iso h x).inv = (X.restrict h).presheaf.germ ⟨x, hx⟩", "decl_nm": "algebraic_geometry.PresheafedSpace.restrict_stalk_iso_inv_eq_germ"
{"src": "⊢ ∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field 𝕜] {E : Type u_2} [_inst_2 : normed_group E]	  [_inst_3 : normed_space 𝕜 E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space 𝕜 F]	  (p : formal_multilinear_series 𝕜 E F) (i : E ≃L[𝕜] F), p.right_inv i 0 = 0", "decl_nm": "formal_multilinear_series.right_inv_coeff_zero"
{"src": "𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	p : formal_multilinear_series 𝕜 E F,	i : E ≃L[𝕜] F	⊢ p.right_inv i 0 = 0", "decl_nm": "formal_multilinear_series.right_inv_coeff_zero"
{"src": "⊢ ∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field 𝕜] {E : Type u_2} [_inst_2 : normed_group E]	  [_inst_3 : normed_space 𝕜 E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space 𝕜 F]	  (p : formal_multilinear_series 𝕜 E F) (i : E ≃L[𝕜] F) (n : ℕ),	    2 ≤ n →	    p.right_inv i n =	      -↑(i.symm).comp_continuous_multilinear_map	          ({c : composition n | 1 < c.length}.to_finset.sum	             (λ (c : composition n), p.comp_along_composition (p.right_inv i) c))", "decl_nm": "formal_multilinear_series.right_inv_coeff"
{"src": "𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	p : formal_multilinear_series 𝕜 E F,	i : E ≃L[𝕜] F,	n : ℕ,	hn : 2 ≤ n	⊢ p.right_inv i n =	    -↑(i.symm).comp_continuous_multilinear_map	        ({c : composition n | 1 < c.length}.to_finset.sum	           (λ (c : composition n), p.comp_along_composition (p.right_inv i) c))", "decl_nm": "formal_multilinear_series.right_inv_coeff"
{"src": "2 goals	case nat.zero	𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	p : formal_multilinear_series 𝕜 E F,	i : E ≃L[𝕜] F,	hn : 2 ≤ 0	⊢ p.right_inv i 0 =	    -↑(i.symm).comp_continuous_multilinear_map	        ({c : composition 0 | 1 < c.length}.to_finset.sum	           (λ (c : composition 0), p.comp_along_composition (p.right_inv i) c))		case nat.succ	𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	p : formal_multilinear_series 𝕜 E F,	i : E ≃L[𝕜] F,	n : ℕ,	hn : 2 ≤ n.succ	⊢ p.right_inv i n.succ =	    -↑(i.symm).comp_continuous_multilinear_map	        ({c : composition n.succ | 1 < c.length}.to_finset.sum	           (λ (c : composition n.succ), p.comp_along_composition (p.right_inv i) c))", "decl_nm": "formal_multilinear_series.right_inv_coeff"
{"src": "case nat.succ	𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	p : formal_multilinear_series 𝕜 E F,	i : E ≃L[𝕜] F,	n : ℕ,	hn : 2 ≤ n.succ	⊢ p.right_inv i n.succ =	    -↑(i.symm).comp_continuous_multilinear_map	        ({c : composition n.succ | 1 < c.length}.to_finset.sum	           (λ (c : composition n.succ), p.comp_along_composition (p.right_inv i) c))", "decl_nm": "formal_multilinear_series.right_inv_coeff"
{"src": "2 goals	case nat.succ, nat.zero	𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	p : formal_multilinear_series 𝕜 E F,	i : E ≃L[𝕜] F,	hn : 2 ≤ 1	⊢ p.right_inv i 1 =	    -↑(i.symm).comp_continuous_multilinear_map	        ({c : composition 1 | 1 < c.length}.to_finset.sum	           (λ (c : composition 1), p.comp_along_composition (p.right_inv i) c))		case nat.succ, nat.succ	𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	p : formal_multilinear_series 𝕜 E F,	i : E ≃L[𝕜] F,	n : ℕ,	hn : 2 ≤ n.succ.succ	⊢ p.right_inv i n.succ.succ =	    -↑(i.symm).comp_continuous_multilinear_map	        ({c : composition n.succ.succ | 1 < c.length}.to_finset.sum	           (λ (c : composition n.succ.succ), p.comp_along_composition (p.right_inv i) c))", "decl_nm": "formal_multilinear_series.right_inv_coeff"
{"src": "case nat.succ, nat.succ	𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	p : formal_multilinear_series 𝕜 E F,	i : E ≃L[𝕜] F,	n : ℕ,	hn : 2 ≤ n.succ.succ	⊢ p.right_inv i n.succ.succ =	    -↑(i.symm).comp_continuous_multilinear_map	        ({c : composition n.succ.succ | 1 < c.length}.to_finset.sum	           (λ (c : composition n.succ.succ), p.comp_along_composition (p.right_inv i) c))", "decl_nm": "formal_multilinear_series.right_inv_coeff"
{"src": "case nat.succ, nat.succ	𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	p : formal_multilinear_series 𝕜 E F,	i : E ≃L[𝕜] F,	n : ℕ,	hn : 2 ≤ n.succ.succ	⊢ ↑(i.symm).comp_continuous_multilinear_map (p.comp (λ (k : ℕ), ite (k < n + 2) (p.right_inv i k) 0) (n + 2)) =	    ↑(i.symm).comp_continuous_multilinear_map	      ({c : composition n.succ.succ | 1 < c.length}.to_finset.sum (p.comp_along_composition (p.right_inv i)))", "decl_nm": "formal_multilinear_series.right_inv_coeff"
{"src": "𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	p : formal_multilinear_series 𝕜 E F,	i : E ≃L[𝕜] F,	n : ℕ,	hn : 2 ≤ n.succ.succ	⊢ p.comp (λ (k : ℕ), ite (k < n + 2) (p.right_inv i k) 0) (n + 2) =	    {c : composition n.succ.succ | 1 < c.length}.to_finset.sum (p.comp_along_composition (p.right_inv i))", "decl_nm": "formal_multilinear_series.right_inv_coeff"
{"src": "𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	p : formal_multilinear_series 𝕜 E F,	i : E ≃L[𝕜] F,	n : ℕ,	hn : 2 ≤ n.succ.succ,	v : fin (n + 2) → F	⊢ ⇑(p.comp (λ (k : ℕ), ite (k < n + 2) (p.right_inv i k) 0) (n + 2)) v =	    ⇑({c : composition n.succ.succ | 1 < c.length}.to_finset.sum (p.comp_along_composition (p.right_inv i))) v", "decl_nm": "formal_multilinear_series.right_inv_coeff"
{"src": "2 goals	𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	p : formal_multilinear_series 𝕜 E F,	i : E ≃L[𝕜] F,	n : ℕ,	hn : 2 ≤ n.succ.succ,	v : fin (n + 2) → F	⊢ 0 < n + 2		𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	p : formal_multilinear_series 𝕜 E F,	i : E ≃L[𝕜] F,	n : ℕ,	hn : 2 ≤ n.succ.succ,	v : fin (n + 2) → F,	N : 0 < n + 2	⊢ ⇑(p.comp (λ (k : ℕ), ite (k < n + 2) (p.right_inv i k) 0) (n + 2)) v =	    ⇑({c : composition n.succ.succ | 1 < c.length}.to_finset.sum (p.comp_along_composition (p.right_inv i))) v", "decl_nm": "formal_multilinear_series.right_inv_coeff"
{"src": "𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	p : formal_multilinear_series 𝕜 E F,	i : E ≃L[𝕜] F,	n : ℕ,	hn : 2 ≤ n.succ.succ,	v : fin (n + 2) → F,	N : 0 < n + 2	⊢ ⇑(p.comp (λ (k : ℕ), ite (k < n + 2) (p.right_inv i k) 0) (n + 2)) v =	    ⇑({c : composition n.succ.succ | 1 < c.length}.to_finset.sum (p.comp_along_composition (p.right_inv i))) v", "decl_nm": "formal_multilinear_series.right_inv_coeff"
{"src": "𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	p : formal_multilinear_series 𝕜 E F,	i : E ≃L[𝕜] F,	n : ℕ,	hn : 2 ≤ n.succ.succ,	v : fin (n + 2) → F,	N : 0 < n + 2,	this : ⇑(p 1) (λ (i : fin 1), 0) = 0	⊢ ⇑(p.comp (λ (k : ℕ), ite (k < n + 2) (p.right_inv i k) 0) (n + 2)) v =	    ⇑({c : composition n.succ.succ | 1 < c.length}.to_finset.sum (p.comp_along_composition (p.right_inv i))) v", "decl_nm": "formal_multilinear_series.right_inv_coeff"
{"src": "⊢ ∀ {α : Type u_1} {β : Type u_2} [_inst_1 : normed_group β] {u : α → β} {l : filter α} {c : β},	    is_equivalent u (const α c) l → tendsto u l (nhds c)", "decl_nm": "asymptotics.is_equivalent.tendsto_const"
{"src": "α : Type u_1,	β : Type u_2,	_inst_1 : normed_group β,	u : α → β,	l : filter α,	c : β,	hu : is_equivalent u (const α c) l	⊢ tendsto u l (nhds c)", "decl_nm": "asymptotics.is_equivalent.tendsto_const"
{"src": "2 goals	α : Type u_1,	β : Type u_2,	_inst_1 : normed_group β,	u : α → β,	l : filter α,	hu : is_equivalent u (const α add_comm_group.zero) l,	h : add_comm_group.zero = 0	⊢ tendsto u l (nhds add_comm_group.zero)		α : Type u_1,	β : Type u_2,	_inst_1 : normed_group β,	u : α → β,	l : filter α,	c : β,	hu : is_equivalent u (const α c) l,	h : ¬c = 0	⊢ tendsto u l (nhds c)", "decl_nm": "asymptotics.is_equivalent.tendsto_const"
{"src": "α : Type u_1,	β : Type u_2,	_inst_1 : normed_group β,	u : α → β,	l : filter α,	c : β,	hu : is_equivalent u (const α c) l,	h : ¬c = 0	⊢ tendsto u l (nhds c)", "decl_nm": "asymptotics.is_equivalent.tendsto_const"
{"src": "⊢ ∀ {α : Type u_1} {F : Type u_4} {E' : Type u_6} {𝕜 : Type u_11} [_inst_2 : has_norm F]	  [_inst_4 : normed_group E'] [_inst_9 : normed_field 𝕜] {g : α → F} {f' : α → E'} {l : filter α}	  [_inst_11 : normed_space 𝕜 E'] {c : 𝕜}, c ≠ 0 → (is_O (λ (x : α), c • f' x) g l ↔ is_O f' g l)", "decl_nm": "asymptotics.is_O_const_smul_left_iff"
{"src": "α : Type u_1,	F : Type u_4,	E' : Type u_6,	𝕜 : Type u_11,	_inst_2 : has_norm F,	_inst_4 : normed_group E',	_inst_9 : normed_field 𝕜,	g : α → F,	f' : α → E',	l : filter α,	_inst_11 : normed_space 𝕜 E',	c : 𝕜,	hc : c ≠ 0	⊢ is_O (λ (x : α), c • f' x) g l ↔ is_O f' g l", "decl_nm": "asymptotics.is_O_const_smul_left_iff"
{"src": "2 goals	α : Type u_1,	F : Type u_4,	E' : Type u_6,	𝕜 : Type u_11,	_inst_2 : has_norm F,	_inst_4 : normed_group E',	_inst_9 : normed_field 𝕜,	g : α → F,	f' : α → E',	l : filter α,	_inst_11 : normed_space 𝕜 E',	c : 𝕜,	hc : c ≠ 0	⊢ ∥c∥ ≠ 0		α : Type u_1,	F : Type u_4,	E' : Type u_6,	𝕜 : Type u_11,	_inst_2 : has_norm F,	_inst_4 : normed_group E',	_inst_9 : normed_field 𝕜,	g : α → F,	f' : α → E',	l : filter α,	_inst_11 : normed_space 𝕜 E',	c : 𝕜,	hc : c ≠ 0,	cne0 : ∥c∥ ≠ 0	⊢ is_O (λ (x : α), c • f' x) g l ↔ is_O f' g l", "decl_nm": "asymptotics.is_O_const_smul_left_iff"
{"src": "α : Type u_1,	F : Type u_4,	E' : Type u_6,	𝕜 : Type u_11,	_inst_2 : has_norm F,	_inst_4 : normed_group E',	_inst_9 : normed_field 𝕜,	g : α → F,	f' : α → E',	l : filter α,	_inst_11 : normed_space 𝕜 E',	c : 𝕜,	hc : c ≠ 0,	cne0 : ∥c∥ ≠ 0	⊢ is_O (λ (x : α), c • f' x) g l ↔ is_O f' g l", "decl_nm": "asymptotics.is_O_const_smul_left_iff"
{"src": "α : Type u_1,	F : Type u_4,	E' : Type u_6,	𝕜 : Type u_11,	_inst_2 : has_norm F,	_inst_4 : normed_group E',	_inst_9 : normed_field 𝕜,	g : α → F,	f' : α → E',	l : filter α,	_inst_11 : normed_space 𝕜 E',	c : 𝕜,	hc : c ≠ 0,	cne0 : ∥c∥ ≠ 0	⊢ is_O (λ (x : α), ∥c • f' x∥) g l ↔ is_O f' g l", "decl_nm": "asymptotics.is_O_const_smul_left_iff"
{"src": "α : Type u_1,	F : Type u_4,	E' : Type u_6,	𝕜 : Type u_11,	_inst_2 : has_norm F,	_inst_4 : normed_group E',	_inst_9 : normed_field 𝕜,	g : α → F,	f' : α → E',	l : filter α,	_inst_11 : normed_space 𝕜 E',	c : 𝕜,	hc : c ≠ 0,	cne0 : ∥c∥ ≠ 0	⊢ is_O (λ (x : α), ∥c∥ * ∥f' x∥) g l ↔ is_O f' g l", "decl_nm": "asymptotics.is_O_const_smul_left_iff"
{"src": "⊢ ∀ {α : Type u_1} {F' : Type u_7} [_inst_5 : normed_group F'] {g' : α → F'} {l : filter α} {ι : Type u_2}	  [_inst_11 : fintype ι] {E' : ι → Type u_3} [_inst_12 : Π (i : ι), normed_group (E' i)]	  {f : α → Π (i : ι), E' i}, is_o f g' l ↔ ∀ (i : ι), is_o (λ (x : α), f x i) g' l", "decl_nm": "asymptotics.is_o_pi"
{"src": "α : Type u_1,	F' : Type u_7,	_inst_5 : normed_group F',	g' : α → F',	l : filter α,	ι : Type u_2,	_inst_11 : fintype ι,	E' : ι → Type u_3,	_inst_12 : Π (i : ι), normed_group (E' i),	f : α → Π (i : ι), E' i	⊢ is_o f g' l ↔ ∀ (i : ι), is_o (λ (x : α), f x i) g' l", "decl_nm": "asymptotics.is_o_pi"
{"src": "α : Type u_1,	F' : Type u_7,	_inst_5 : normed_group F',	g' : α → F',	l : filter α,	ι : Type u_2,	_inst_11 : fintype ι,	E' : ι → Type u_3,	_inst_12 : Π (i : ι), normed_group (E' i),	f : α → Π (i : ι), E' i	⊢ (∀ ⦃c : ℝ⦄, 0 < c → ∀ (i : ι), is_O_with c (λ (x : α), f x i) g' l) ↔	    ∀ (i : ι) ⦃c : ℝ⦄, 0 < c → is_O_with c (λ (x : α), f x i) g' l", "decl_nm": "asymptotics.is_o_pi"
{"src": "⊢ ∀ {α : Type u_1} {E : Type u_3} {F : Type u_4} [_inst_1 : has_norm E] [_inst_2 : has_norm F] {c₁ c₂ : ℝ}	  {f₁ f₂ : α → E} {g₁ g₂ : α → F} {l : filter α},	    c₁ = c₂ →	    f₁ =ᶠ[l] f₂ → g₁ =ᶠ[l] g₂ → (is_O_with c₁ f₁ g₁ l ↔ is_O_with c₂ f₂ g₂ l)", "decl_nm": "asymptotics.is_O_with_congr"
{"src": "α : Type u_1,	E : Type u_3,	F : Type u_4,	_inst_1 : has_norm E,	_inst_2 : has_norm F,	c₁ c₂ : ℝ,	f₁ f₂ : α → E,	g₁ g₂ : α → F,	l : filter α,	hc : c₁ = c₂,	hf : f₁ =ᶠ[l] f₂,	hg : g₁ =ᶠ[l] g₂	⊢ is_O_with c₁ f₁ g₁ l ↔ is_O_with c₂ f₂ g₂ l", "decl_nm": "asymptotics.is_O_with_congr"
{"src": "α : Type u_1,	E : Type u_3,	F : Type u_4,	_inst_1 : has_norm E,	_inst_2 : has_norm F,	c₁ c₂ : ℝ,	f₁ f₂ : α → E,	g₁ g₂ : α → F,	l : filter α,	hc : c₁ = c₂,	hf : f₁ =ᶠ[l] f₂,	hg : g₁ =ᶠ[l] g₂	⊢ (∀ᶠ (x : α) in l, ∥f₁ x∥ ≤ c₁ * ∥g₁ x∥) ↔	    ∀ᶠ (x : α) in l, ∥f₂ x∥ ≤ c₂ * ∥g₂ x∥", "decl_nm": "asymptotics.is_O_with_congr"
{"src": "α : Type u_1,	E : Type u_3,	F : Type u_4,	_inst_1 : has_norm E,	_inst_2 : has_norm F,	c₁ : ℝ,	f₁ f₂ : α → E,	g₁ g₂ : α → F,	l : filter α,	hf : f₁ =ᶠ[l] f₂,	hg : g₁ =ᶠ[l] g₂	⊢ (∀ᶠ (x : α) in l, ∥f₁ x∥ ≤ c₁ * ∥g₁ x∥) ↔	    ∀ᶠ (x : α) in l, ∥f₂ x∥ ≤ c₁ * ∥g₂ x∥", "decl_nm": "asymptotics.is_O_with_congr"
{"src": "α : Type u_1,	E : Type u_3,	F : Type u_4,	_inst_1 : has_norm E,	_inst_2 : has_norm F,	c₁ : ℝ,	f₁ f₂ : α → E,	g₁ g₂ : α → F,	l : filter α,	hf : f₁ =ᶠ[l] f₂,	hg : g₁ =ᶠ[l] g₂	⊢ ∀ᶠ (x : α) in l, ∥f₁ x∥ ≤ c₁ * ∥g₁ x∥ ↔ ∥f₂ x∥ ≤ c₁ * ∥g₂ x∥", "decl_nm": "asymptotics.is_O_with_congr"
{"src": "α : Type u_1,	E : Type u_3,	F : Type u_4,	_inst_1 : has_norm E,	_inst_2 : has_norm F,	c₁ : ℝ,	f₁ f₂ : α → E,	g₁ g₂ : α → F,	l : filter α,	hf : f₁ =ᶠ[l] f₂,	hg : g₁ =ᶠ[l] g₂	⊢ ∀ (a : α),	    f₁ a = f₂ a →	    g₁ a = g₂ a → (∥f₁ a∥ ≤ c₁ * ∥g₁ a∥ ↔ ∥f₂ a∥ ≤ c₁ * ∥g₂ a∥)", "decl_nm": "asymptotics.is_O_with_congr"
{"src": "α : Type u_1,	E : Type u_3,	F : Type u_4,	_inst_1 : has_norm E,	_inst_2 : has_norm F,	c₁ : ℝ,	f₁ f₂ : α → E,	g₁ g₂ : α → F,	l : filter α,	hf : f₁ =ᶠ[l] f₂,	hg : g₁ =ᶠ[l] g₂,	x : α,	e₁ : f₁ x = f₂ x,	e₂ : g₁ x = g₂ x	⊢ ∥f₁ x∥ ≤ c₁ * ∥g₁ x∥ ↔ ∥f₂ x∥ ≤ c₁ * ∥g₂ x∥", "decl_nm": "asymptotics.is_O_with_congr"
{"src": "⊢ ∀ {α : Type u_1} {F : Type u_4} {E' : Type u_6} [_inst_2 : has_norm F] [_inst_4 : normed_group E'] {g : α → F}	  {f' : α → E'} {l : filter α}, is_o (λ (x : α), -f' x) g l ↔ is_o f' g l", "decl_nm": "asymptotics.is_o_neg_left"
{"src": "α : Type u_1,	F : Type u_4,	E' : Type u_6,	_inst_2 : has_norm F,	_inst_4 : normed_group E',	g : α → F,	f' : α → E',	l : filter α	⊢ is_o (λ (x : α), -f' x) g l ↔ is_o f' g l", "decl_nm": "asymptotics.is_o_neg_left"
{"src": "α : Type u_1,	F : Type u_4,	E' : Type u_6,	_inst_2 : has_norm F,	_inst_4 : normed_group E',	g : α → F,	f' : α → E',	l : filter α	⊢ (∀ ⦃c : ℝ⦄, 0 < c → is_O_with c (λ (x : α), -f' x) g l) ↔	    ∀ ⦃c : ℝ⦄, 0 < c → is_O_with c f' g l", "decl_nm": "asymptotics.is_o_neg_left"
{"src": "⊢ ∀ {𝕜 : Type u} [_inst_1 : nondiscrete_normed_field 𝕜] (x : 𝕜) {f : 𝕜 → 𝕜} {f' : 𝕜},	    has_strict_deriv_at f f' x → f x = x → ∀ (n : ℕ), has_strict_deriv_at f^[n] (f' ^ n) x", "decl_nm": "has_strict_deriv_at.iterate"
{"src": "𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	x : 𝕜,	f : 𝕜 → 𝕜,	f' : 𝕜,	hf : has_strict_deriv_at f f' x,	hx : f x = x,	n : ℕ	⊢ has_strict_deriv_at f^[n] (f' ^ n) x", "decl_nm": "has_strict_deriv_at.iterate"
{"src": "𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	x : 𝕜,	f : 𝕜 → 𝕜,	f' : 𝕜,	hf : has_strict_deriv_at f f' x,	hx : f x = x,	n : ℕ,	this : has_strict_fderiv_at f^[n] (1.smul_right f' ^ n) x	⊢ has_strict_deriv_at f^[n] (f' ^ n) x", "decl_nm": "has_strict_deriv_at.iterate"
{"src": "⊢ ∀ {𝕜 : Type u} [_inst_1 : nondiscrete_normed_field 𝕜] {x : 𝕜} {𝕜' : Type u_1}	  [_inst_6 : nondiscrete_normed_field 𝕜'] [_inst_7 : normed_algebra 𝕜 𝕜'] {c d : 𝕜 → 𝕜'}	  {c' d' : 𝕜'},	    has_strict_deriv_at c c' x →	    has_strict_deriv_at d d' x →	    d x ≠ 0 → has_strict_deriv_at (λ (y : 𝕜), c y / d y) ((c' * d x - c x * d') / d x ^ 2) x", "decl_nm": "has_strict_deriv_at.div"
{"src": "𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	x : 𝕜,	𝕜' : Type u_1,	_inst_6 : nondiscrete_normed_field 𝕜',	_inst_7 : normed_algebra 𝕜 𝕜',	c d : 𝕜 → 𝕜',	c' d' : 𝕜',	hc : has_strict_deriv_at c c' x,	hd : has_strict_deriv_at d d' x,	hx : d x ≠ 0	⊢ has_strict_deriv_at (λ (y : 𝕜), c y / d y) ((c' * d x - c x * d') / d x ^ 2) x", "decl_nm": "has_strict_deriv_at.div"
{"src": "2 goals	𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	x : 𝕜,	𝕜' : Type u_1,	_inst_6 : nondiscrete_normed_field 𝕜',	_inst_7 : normed_algebra 𝕜 𝕜',	c d : 𝕜 → 𝕜',	c' d' : 𝕜',	hc : has_strict_deriv_at c c' x,	hd : has_strict_deriv_at d d' x,	hx : d x ≠ 0	⊢ (λ (y : 𝕜), c y / d y) = λ (y : 𝕜), c y * (has_inv.inv ∘ d) y		𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	x : 𝕜,	𝕜' : Type u_1,	_inst_6 : nondiscrete_normed_field 𝕜',	_inst_7 : normed_algebra 𝕜 𝕜',	c d : 𝕜 → 𝕜',	c' d' : 𝕜',	hc : has_strict_deriv_at c c' x,	hd : has_strict_deriv_at d d' x,	hx : d x ≠ 0	⊢ (c' * d x - c x * d') / d x ^ 2 = c' * (has_inv.inv ∘ d) x + c x * (-(d x ^ 2)⁻¹ * d')", "decl_nm": "has_strict_deriv_at.div"
{"src": "𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	x : 𝕜,	𝕜' : Type u_1,	_inst_6 : nondiscrete_normed_field 𝕜',	_inst_7 : normed_algebra 𝕜 𝕜',	c d : 𝕜 → 𝕜',	c' d' : 𝕜',	hc : has_strict_deriv_at c c' x,	hd : has_strict_deriv_at d d' x,	hx : d x ≠ 0	⊢ (c' * d x - c x * d') / d x ^ 2 = c' * (has_inv.inv ∘ d) x + c x * (-(d x ^ 2)⁻¹ * d')", "decl_nm": "has_strict_deriv_at.div"
{"src": "𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	x : 𝕜,	𝕜' : Type u_1,	_inst_6 : nondiscrete_normed_field 𝕜',	_inst_7 : normed_algebra 𝕜 𝕜',	c d : 𝕜 → 𝕜',	c' d' : 𝕜',	hc : has_strict_deriv_at c c' x,	hd : has_strict_deriv_at d d' x,	hx : d x ≠ 0	⊢ (c' * d x - c x * d') * (d x * d x ^ 2) = (c' * d x ^ 2 + -(c x * d' * d x)) * d x ^ 2", "decl_nm": "has_strict_deriv_at.div"
{"src": "⊢ ∀ {𝕜 : Type u} [_inst_1 : nondiscrete_normed_field 𝕜] {F : Type v} [_inst_2 : normed_group F]	  [_inst_3 : normed_space 𝕜 F] {f : 𝕜 → F} {f' : F} {x : 𝕜} [_inst_6 : partial_order 𝕜],	    has_deriv_within_at f f' (Iio x) x ↔ has_deriv_within_at f f' (Iic x) x", "decl_nm": "has_deriv_within_at_Iio_iff_Iic"
{"src": "𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	F : Type v,	_inst_2 : normed_group F,	_inst_3 : normed_space 𝕜 F,	f : 𝕜 → F,	f' : F,	x : 𝕜,	_inst_6 : partial_order 𝕜	⊢ has_deriv_within_at f f' (Iio x) x ↔ has_deriv_within_at f f' (Iic x) x", "decl_nm": "has_deriv_within_at_Iio_iff_Iic"
{"src": "⊢ ∀ {𝕜 : Type u} [_inst_1 : nondiscrete_normed_field 𝕜] {F : Type v} [_inst_2 : normed_group F]	  [_inst_3 : normed_space 𝕜 F] {f f₁ : 𝕜 → F} {f' : F} {x : 𝕜} {L : filter 𝕜},	    has_deriv_at_filter f f' x L → f₁ =ᶠ[L] f → f₁ x = f x → has_deriv_at_filter f₁ f' x L", "decl_nm": "has_deriv_at_filter.congr_of_eventually_eq"
{"src": "𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	F : Type v,	_inst_2 : normed_group F,	_inst_3 : normed_space 𝕜 F,	f f₁ : 𝕜 → F,	f' : F,	x : 𝕜,	L : filter 𝕜,	h : has_deriv_at_filter f f' x L,	hL : f₁ =ᶠ[L] f,	hx : f₁ x = f x	⊢ has_deriv_at_filter f₁ f' x L", "decl_nm": "has_deriv_at_filter.congr_of_eventually_eq"
{"src": "⊢ ∀ {𝕜 : Type u} [_inst_1 : nondiscrete_normed_field 𝕜] {F : Type v} [_inst_2 : normed_group F]	  [_inst_3 : normed_space 𝕜 F] {x : 𝕜} {s : set 𝕜} {𝕜' : Type u_1}	  [_inst_6 : nondiscrete_normed_field 𝕜'] [_inst_7 : normed_algebra 𝕜 𝕜'] [_inst_8 : normed_space 𝕜' F]	  [_inst_9 : is_scalar_tower 𝕜 𝕜' F] {c : 𝕜 → 𝕜'} {c' : 𝕜'},	    has_deriv_within_at c c' s x → ∀ (f : F), has_deriv_within_at (λ (y : 𝕜), c y • f) (c' • f) s x", "decl_nm": "has_deriv_within_at.smul_const"
{"src": "𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	F : Type v,	_inst_2 : normed_group F,	_inst_3 : normed_space 𝕜 F,	x : 𝕜,	s : set 𝕜,	𝕜' : Type u_1,	_inst_6 : nondiscrete_normed_field 𝕜',	_inst_7 : normed_algebra 𝕜 𝕜',	_inst_8 : normed_space 𝕜' F,	_inst_9 : is_scalar_tower 𝕜 𝕜' F,	c : 𝕜 → 𝕜',	c' : 𝕜',	hc : has_deriv_within_at c c' s x,	f : F	⊢ has_deriv_within_at (λ (y : 𝕜), c y • f) (c' • f) s x", "decl_nm": "has_deriv_within_at.smul_const"
{"src": "𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	F : Type v,	_inst_2 : normed_group F,	_inst_3 : normed_space 𝕜 F,	x : 𝕜,	s : set 𝕜,	𝕜' : Type u_1,	_inst_6 : nondiscrete_normed_field 𝕜',	_inst_7 : normed_algebra 𝕜 𝕜',	_inst_8 : normed_space 𝕜' F,	_inst_9 : is_scalar_tower 𝕜 𝕜' F,	c : 𝕜 → 𝕜',	c' : 𝕜',	hc : has_deriv_within_at c c' s x,	f : F,	this : has_deriv_within_at (λ (y : 𝕜), c y • (λ (x : 𝕜), f) y) (c x • 0 + c' • (λ (x : 𝕜), f) x) s x	⊢ has_deriv_within_at (λ (y : 𝕜), c y • f) (c' • f) s x", "decl_nm": "has_deriv_within_at.smul_const"
{"src": "⊢ ∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field 𝕜] {E : Type u_2} [_inst_2 : normed_group E]	  [_inst_3 : normed_space 𝕜 E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space 𝕜 F]	  {G : Type u_4} [_inst_6 : normed_group G] [_inst_7 : normed_space 𝕜 G] (iso : E ≃L[𝕜] F) {f : G → E}	  {x : G}, fderiv 𝕜 (⇑iso ∘ f) x = ↑iso.comp (fderiv 𝕜 f x)", "decl_nm": "continuous_linear_equiv.comp_fderiv"
{"src": "𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	G : Type u_4,	_inst_6 : normed_group G,	_inst_7 : normed_space 𝕜 G,	iso : E ≃L[𝕜] F,	f : G → E,	x : G	⊢ fderiv 𝕜 (⇑iso ∘ f) x = ↑iso.comp (fderiv 𝕜 f x)", "decl_nm": "continuous_linear_equiv.comp_fderiv"
{"src": "𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	G : Type u_4,	_inst_6 : normed_group G,	_inst_7 : normed_space 𝕜 G,	iso : E ≃L[𝕜] F,	f : G → E,	x : G	⊢ fderiv_within 𝕜 (⇑iso ∘ f) univ x = ↑iso.comp (fderiv_within 𝕜 f univ x)", "decl_nm": "continuous_linear_equiv.comp_fderiv"
{"src": "⊢ ∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field 𝕜] {E : Type u_2} [_inst_2 : normed_group E]	  [_inst_3 : normed_space 𝕜 E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space 𝕜 F]	  {f : E → F} {f' : E →L[𝕜] F} {x : E}, has_strict_fderiv_at f f' x → has_fderiv_at f f' x", "decl_nm": "has_strict_fderiv_at.has_fderiv_at"
{"src": "𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	f : E → F,	f' : E →L[𝕜] F,	x : E,	hf : has_strict_fderiv_at f f' x	⊢ has_fderiv_at f f' x", "decl_nm": "has_strict_fderiv_at.has_fderiv_at"
{"src": "𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	f : E → F,	f' : E →L[𝕜] F,	x : E,	hf : has_strict_fderiv_at f f' x	⊢ ∀ ⦃c : ℝ⦄, 0 < c → (∀ᶠ (x_1 : E) in nhds x, ∥f x_1 - f x - ⇑f' (x_1 - x)∥ ≤ c * ∥x_1 - x∥)", "decl_nm": "has_strict_fderiv_at.has_fderiv_at"
{"src": "⊢ ∀ {E : Type u_1} {F : Type u_2} [_inst_1 : normed_group E] [_inst_2 : normed_space ℝ E]	  [_inst_3 : normed_group F] [_inst_4 : normed_space ℝ F] {x : E} {f : E → F} {f' : E → (E →L[ℝ] F)}	  {f'' : E →L[ℝ] E →L[ℝ] F},	    (∀ᶠ (y : E) in nhds x, has_fderiv_at f (f' y) y) →	    has_fderiv_at f' f'' x → ∀ (v w : E), ⇑(⇑f'' v) w = ⇑(⇑f'' w) v", "decl_nm": "second_derivative_symmetric_of_eventually"
{"src": "E : Type u_1,	F : Type u_2,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	_inst_3 : normed_group F,	_inst_4 : normed_space ℝ F,	x : E,	f : E → F,	f' : E → (E →L[ℝ] F),	f'' : E →L[ℝ] E →L[ℝ] F,	hf : ∀ᶠ (y : E) in nhds x, has_fderiv_at f (f' y) y,	hx : has_fderiv_at f' f'' x,	v w : E	⊢ ⇑(⇑f'' v) w = ⇑(⇑f'' w) v", "decl_nm": "second_derivative_symmetric_of_eventually"
{"src": "E : Type u_1,	F : Type u_2,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	_inst_3 : normed_group F,	_inst_4 : normed_space ℝ F,	x : E,	f : E → F,	f' : E → (E →L[ℝ] F),	f'' : E →L[ℝ] E →L[ℝ] F,	hf : ∀ᶠ (y : E) in nhds x, has_fderiv_at f (f' y) y,	hx : has_fderiv_at f' f'' x,	v w : E,	ε : ℝ,	εpos : ε > 0,	hε : metric.ball x ε ⊆ {x : E | (λ (y : E), has_fderiv_at f (f' y) y) x}	⊢ ⇑(⇑f'' v) w = ⇑(⇑f'' w) v", "decl_nm": "second_derivative_symmetric_of_eventually"
{"src": "2 goals	E : Type u_1,	F : Type u_2,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	_inst_3 : normed_group F,	_inst_4 : normed_space ℝ F,	x : E,	f : E → F,	f' : E → (E →L[ℝ] F),	f'' : E →L[ℝ] E →L[ℝ] F,	hf : ∀ᶠ (y : E) in nhds x, has_fderiv_at f (f' y) y,	hx : has_fderiv_at f' f'' x,	v w : E,	ε : ℝ,	εpos : ε > 0,	hε : metric.ball x ε ⊆ {x : E | (λ (y : E), has_fderiv_at f (f' y) y) x}	⊢ (interior (metric.ball x ε)).nonempty		E : Type u_1,	F : Type u_2,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	_inst_3 : normed_group F,	_inst_4 : normed_space ℝ F,	x : E,	f : E → F,	f' : E → (E →L[ℝ] F),	f'' : E →L[ℝ] E →L[ℝ] F,	hf : ∀ᶠ (y : E) in nhds x, has_fderiv_at f (f' y) y,	hx : has_fderiv_at f' f'' x,	v w : E,	ε : ℝ,	εpos : ε > 0,	hε : metric.ball x ε ⊆ {x : E | (λ (y : E), has_fderiv_at f (f' y) y) x},	A : (interior (metric.ball x ε)).nonempty	⊢ ⇑(⇑f'' v) w = ⇑(⇑f'' w) v", "decl_nm": "second_derivative_symmetric_of_eventually"
{"src": "E : Type u_1,	F : Type u_2,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	_inst_3 : normed_group F,	_inst_4 : normed_space ℝ F,	x : E,	f : E → F,	f' : E → (E →L[ℝ] F),	f'' : E →L[ℝ] E →L[ℝ] F,	hf : ∀ᶠ (y : E) in nhds x, has_fderiv_at f (f' y) y,	hx : has_fderiv_at f' f'' x,	v w : E,	ε : ℝ,	εpos : ε > 0,	hε : metric.ball x ε ⊆ {x : E | (λ (y : E), has_fderiv_at f (f' y) y) x},	A : (interior (metric.ball x ε)).nonempty	⊢ ⇑(⇑f'' v) w = ⇑(⇑f'' w) v", "decl_nm": "second_derivative_symmetric_of_eventually"
{"src": "⊢ ∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field 𝕜] {E : Type u_2} [_inst_2 : normed_group E]	  [_inst_3 : normed_space 𝕜 E] [_inst_4 : complete_space E] {F : Type u_3} [_inst_5 : normed_group F]	  [_inst_6 : normed_space 𝕜 F] [_inst_7 : complete_space F] {f : E → F} {f' : E →L[𝕜] F} {a : E}	  (hf : has_strict_fderiv_at f f' a) (hf' : f'.range = ⊤) (hker : f'.ker.closed_complemented),	    ⇑(implicit_to_local_homeomorph_of_complemented f f' hf hf' hker) a = (f a, 0)", "decl_nm": "has_strict_fderiv_at.implicit_to_local_homeomorph_of_complemented_self"
{"src": "𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	_inst_4 : complete_space E,	F : Type u_3,	_inst_5 : normed_group F,	_inst_6 : normed_space 𝕜 F,	_inst_7 : complete_space F,	f : E → F,	f' : E →L[𝕜] F,	a : E,	hf : has_strict_fderiv_at f f' a,	hf' : f'.range = ⊤,	hker : f'.ker.closed_complemented	⊢ ⇑(implicit_to_local_homeomorph_of_complemented f f' hf hf' hker) a = (f a, 0)", "decl_nm": "has_strict_fderiv_at.implicit_to_local_homeomorph_of_complemented_self"
{"src": "⊢ ∀ {a b : ℝ},	    a < b →	    ∀ {l : filter ℝ} {f f' g g' : ℝ → ℝ},	      (∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at f (f' x) x) →	      (∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at g (g' x) x) →	      continuous_on f (Ico a b) →	      continuous_on g (Ico a b) →	      (∀ (x : ℝ), x ∈ Ioo a b → g' x ≠ 0) →	      f a = 0 →	      g a = 0 →	      tendsto (λ (x : ℝ), f' x / g' x) (nhds_within a (Ioi a)) l →	      tendsto (λ (x : ℝ), f x / g x) (nhds_within a (Ioi a)) l", "decl_nm": "has_deriv_at.lhopital_zero_right_on_Ico"
{"src": "a b : ℝ,	hab : a < b,	l : filter ℝ,	f f' g g' : ℝ → ℝ,	hff' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at f (f' x) x,	hgg' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at g (g' x) x,	hcf : continuous_on f (Ico a b),	hcg : continuous_on g (Ico a b),	hg' : ∀ (x : ℝ), x ∈ Ioo a b → g' x ≠ 0,	hfa : f a = 0,	hga : g a = 0,	hdiv : tendsto (λ (x : ℝ), f' x / g' x) (nhds_within a (Ioi a)) l	⊢ tendsto (λ (x : ℝ), f x / g x) (nhds_within a (Ioi a)) l", "decl_nm": "has_deriv_at.lhopital_zero_right_on_Ico"
{"src": "2 goals	a b : ℝ,	hab : a < b,	l : filter ℝ,	f f' g g' : ℝ → ℝ,	hff' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at f (f' x) x,	hgg' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at g (g' x) x,	hcf : continuous_on f (Ico a b),	hcg : continuous_on g (Ico a b),	hg' : ∀ (x : ℝ), x ∈ Ioo a b → g' x ≠ 0,	hfa : f a = 0,	hga : g a = 0,	hdiv : tendsto (λ (x : ℝ), f' x / g' x) (nhds_within a (Ioi a)) l	⊢ tendsto (λ (x : ℝ), f x) (nhds_within a (Ioi a)) (nhds 0)		a b : ℝ,	hab : a < b,	l : filter ℝ,	f f' g g' : ℝ → ℝ,	hff' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at f (f' x) x,	hgg' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at g (g' x) x,	hcf : continuous_on f (Ico a b),	hcg : continuous_on g (Ico a b),	hg' : ∀ (x : ℝ), x ∈ Ioo a b → g' x ≠ 0,	hfa : f a = 0,	hga : g a = 0,	hdiv : tendsto (λ (x : ℝ), f' x / g' x) (nhds_within a (Ioi a)) l	⊢ tendsto (λ (x : ℝ), g x) (nhds_within a (Ioi a)) (nhds 0)", "decl_nm": "has_deriv_at.lhopital_zero_right_on_Ico"
{"src": "2 goals	a b : ℝ,	hab : a < b,	l : filter ℝ,	f f' g g' : ℝ → ℝ,	hff' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at f (f' x) x,	hgg' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at g (g' x) x,	hcf : continuous_on f (Ico a b),	hcg : continuous_on g (Ico a b),	hg' : ∀ (x : ℝ), x ∈ Ioo a b → g' x ≠ 0,	hfa : f a = 0,	hga : g a = 0,	hdiv : tendsto (λ (x : ℝ), f' x / g' x) (nhds_within a (Ioi a)) l	⊢ tendsto (λ (x : ℝ), f x) (nhds_within a (Ioo a b)) (nhds (f a))		a b : ℝ,	hab : a < b,	l : filter ℝ,	f f' g g' : ℝ → ℝ,	hff' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at f (f' x) x,	hgg' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at g (g' x) x,	hcf : continuous_on f (Ico a b),	hcg : continuous_on g (Ico a b),	hg' : ∀ (x : ℝ), x ∈ Ioo a b → g' x ≠ 0,	hfa : f a = 0,	hga : g a = 0,	hdiv : tendsto (λ (x : ℝ), f' x / g' x) (nhds_within a (Ioi a)) l	⊢ tendsto (λ (x : ℝ), g x) (nhds_within a (Ioi a)) (nhds 0)", "decl_nm": "has_deriv_at.lhopital_zero_right_on_Ico"
{"src": "a b : ℝ,	hab : a < b,	l : filter ℝ,	f f' g g' : ℝ → ℝ,	hff' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at f (f' x) x,	hgg' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at g (g' x) x,	hcf : continuous_on f (Ico a b),	hcg : continuous_on g (Ico a b),	hg' : ∀ (x : ℝ), x ∈ Ioo a b → g' x ≠ 0,	hfa : f a = 0,	hga : g a = 0,	hdiv : tendsto (λ (x : ℝ), f' x / g' x) (nhds_within a (Ioi a)) l	⊢ tendsto (λ (x : ℝ), g x) (nhds_within a (Ioi a)) (nhds 0)", "decl_nm": "has_deriv_at.lhopital_zero_right_on_Ico"
{"src": "a b : ℝ,	hab : a < b,	l : filter ℝ,	f f' g g' : ℝ → ℝ,	hff' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at f (f' x) x,	hgg' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at g (g' x) x,	hcf : continuous_on f (Ico a b),	hcg : continuous_on g (Ico a b),	hg' : ∀ (x : ℝ), x ∈ Ioo a b → g' x ≠ 0,	hfa : f a = 0,	hga : g a = 0,	hdiv : tendsto (λ (x : ℝ), f' x / g' x) (nhds_within a (Ioi a)) l	⊢ tendsto (λ (x : ℝ), g x) (nhds_within a (Ioo a b)) (nhds (g a))", "decl_nm": "has_deriv_at.lhopital_zero_right_on_Ico"
{"src": "⊢ ∀ {E : Type u_1} [_inst_1 : normed_group E] [_inst_2 : normed_space ℝ E] {f : E → ℝ} {s : set E} {x y : E}	  {f' : E → (E →L[ℝ] ℝ)},	    (∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x) →	    convex ℝ s → x ∈ s → y ∈ s → (∃ (z : E) (H : z ∈ segment ℝ x y), f y - f x = ⇑(f' z) (y - x))", "decl_nm": "domain_mvt"
{"src": "E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s	⊢ ∃ (z : E) (H : z ∈ segment ℝ x y), f y - f x = ⇑(f' z) (y - x)", "decl_nm": "domain_mvt"
{"src": "E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1	⊢ ∃ (z : E) (H : z ∈ segment ℝ x y), f y - f x = ⇑(f' z) (y - x)", "decl_nm": "domain_mvt"
{"src": "E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x)	⊢ ∃ (z : E) (H : z ∈ segment ℝ x y), f y - f x = ⇑(f' z) (y - x)", "decl_nm": "domain_mvt"
{"src": "2 goals	E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x)	⊢ ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y		E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y	⊢ ∃ (z : E) (H : z ∈ segment ℝ x y), f y - f x = ⇑(f' z) (y - x)", "decl_nm": "domain_mvt"
{"src": "2 goals	E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x)	⊢ ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ (λ (θ : ℝ), x + θ • (y - x)) '' Icc 0 1		E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y	⊢ ∃ (z : E) (H : z ∈ segment ℝ x y), f y - f x = ⇑(f' z) (y - x)", "decl_nm": "domain_mvt"
{"src": "2 goals	E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x)	⊢ ∀ (t : ℝ), t ∈ Icc 0 1 → (∃ (x_1 : ℝ), x_1 ∈ Icc 0 1 ∧ x_1 • (y - x) = t • (y - x))		E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y	⊢ ∃ (z : E) (H : z ∈ segment ℝ x y), f y - f x = ⇑(f' z) (y - x)", "decl_nm": "domain_mvt"
{"src": "2 goals	E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	t : ℝ,	ht : t ∈ Icc 0 1	⊢ ∃ (x_1 : ℝ), x_1 ∈ Icc 0 1 ∧ x_1 • (y - x) = t • (y - x)		E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y	⊢ ∃ (z : E) (H : z ∈ segment ℝ x y), f y - f x = ⇑(f' z) (y - x)", "decl_nm": "domain_mvt"
{"src": "E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y	⊢ ∃ (z : E) (H : z ∈ segment ℝ x y), f y - f x = ⇑(f' z) (y - x)", "decl_nm": "domain_mvt"
{"src": "2 goals	E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y	⊢ Icc 0 1 ⊆ g ⁻¹' s		E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : Icc 0 1 ⊆ g ⁻¹' s	⊢ ∃ (z : E) (H : z ∈ segment ℝ x y), f y - f x = ⇑(f' z) (y - x)", "decl_nm": "domain_mvt"
{"src": "2 goals	E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y	⊢ g '' Icc 0 1 ⊆ s		E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : Icc 0 1 ⊆ g ⁻¹' s	⊢ ∃ (z : E) (H : z ∈ segment ℝ x y), f y - f x = ⇑(f' z) (y - x)", "decl_nm": "domain_mvt"
{"src": "2 goals	E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y	⊢ {b : E | ∃ (a : ℝ), a ∈ Icc 0 1 ∧ g a = b} ⊆ s		E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : Icc 0 1 ⊆ g ⁻¹' s	⊢ ∃ (z : E) (H : z ∈ segment ℝ x y), f y - f x = ⇑(f' z) (y - x)", "decl_nm": "domain_mvt"
{"src": "2 goals	E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y	⊢ ∀ (_x : E), _x ∈ {b : E | ∃ (a : ℝ), a ∈ Icc 0 1 ∧ g a = b} → _x ∈ s		E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : Icc 0 1 ⊆ g ⁻¹' s	⊢ ∃ (z : E) (H : z ∈ segment ℝ x y), f y - f x = ⇑(f' z) (y - x)", "decl_nm": "domain_mvt"
{"src": "2 goals	E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y,	z : E,	Hz : z ∈ {b : E | ∃ (a : ℝ), a ∈ Icc 0 1 ∧ g a = b}	⊢ z ∈ s		E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : Icc 0 1 ⊆ g ⁻¹' s	⊢ ∃ (z : E) (H : z ∈ segment ℝ x y), f y - f x = ⇑(f' z) (y - x)", "decl_nm": "domain_mvt"
{"src": "2 goals	E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y,	z : E,	Hz : ∃ (a : ℝ), a ∈ Icc 0 1 ∧ g a = z	⊢ z ∈ s		E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : Icc 0 1 ⊆ g ⁻¹' s	⊢ ∃ (z : E) (H : z ∈ segment ℝ x y), f y - f x = ⇑(f' z) (y - x)", "decl_nm": "domain_mvt"
{"src": "2 goals	E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y,	z : E,	t : ℝ,	Ht : t ∈ Icc 0 1,	hgt : g t = z	⊢ z ∈ s		E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : Icc 0 1 ⊆ g ⁻¹' s	⊢ ∃ (z : E) (H : z ∈ segment ℝ x y), f y - f x = ⇑(f' z) (y - x)", "decl_nm": "domain_mvt"
{"src": "2 goals	E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y,	z : E,	t : ℝ,	Ht : t ∈ Icc 0 1,	hgt : g t = z	⊢ g t ∈ s		E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : Icc 0 1 ⊆ g ⁻¹' s	⊢ ∃ (z : E) (H : z ∈ segment ℝ x y), f y - f x = ⇑(f' z) (y - x)", "decl_nm": "domain_mvt"
{"src": "E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : Icc 0 1 ⊆ g ⁻¹' s	⊢ ∃ (z : E) (H : z ∈ segment ℝ x y), f y - f x = ⇑(f' z) (y - x)", "decl_nm": "domain_mvt"
{"src": "2 goals	E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : Icc 0 1 ⊆ g ⁻¹' s	⊢ ∀ (t : ℝ), t ∈ Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (Icc 0 1) t		E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : Icc 0 1 ⊆ g ⁻¹' s,	hfg : ∀ (t : ℝ), t ∈ Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (Icc 0 1) t	⊢ ∃ (z : E) (H : z ∈ segment ℝ x y), f y - f x = ⇑(f' z) (y - x)", "decl_nm": "domain_mvt"
{"src": "2 goals	E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : Icc 0 1 ⊆ g ⁻¹' s,	t : ℝ,	Ht : t ∈ Icc 0 1	⊢ has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (Icc 0 1) t		E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : Icc 0 1 ⊆ g ⁻¹' s,	hfg : ∀ (t : ℝ), t ∈ Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (Icc 0 1) t	⊢ ∃ (z : E) (H : z ∈ segment ℝ x y), f y - f x = ⇑(f' z) (y - x)", "decl_nm": "domain_mvt"
{"src": "3 goals	E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : Icc 0 1 ⊆ g ⁻¹' s,	t : ℝ,	Ht : t ∈ Icc 0 1	⊢ has_deriv_at g (y - x) t		E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : Icc 0 1 ⊆ g ⁻¹' s,	t : ℝ,	Ht : t ∈ Icc 0 1,	hg : has_deriv_at g (y - x) t	⊢ has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (Icc 0 1) t		E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : Icc 0 1 ⊆ g ⁻¹' s,	hfg : ∀ (t : ℝ), t ∈ Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (Icc 0 1) t	⊢ ∃ (z : E) (H : z ∈ segment ℝ x y), f y - f x = ⇑(f' z) (y - x)", "decl_nm": "domain_mvt"
{"src": "3 goals	E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : Icc 0 1 ⊆ g ⁻¹' s,	t : ℝ,	Ht : t ∈ Icc 0 1,	this : has_deriv_at (λ (x_1 : ℝ), x + (λ (y_1 : ℝ), id y_1 • (y - x)) x_1) (1 • (y - x)) t	⊢ has_deriv_at g (y - x) t		E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : Icc 0 1 ⊆ g ⁻¹' s,	t : ℝ,	Ht : t ∈ Icc 0 1,	hg : has_deriv_at g (y - x) t	⊢ has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (Icc 0 1) t		E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : Icc 0 1 ⊆ g ⁻¹' s,	hfg : ∀ (t : ℝ), t ∈ Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (Icc 0 1) t	⊢ ∃ (z : E) (H : z ∈ segment ℝ x y), f y - f x = ⇑(f' z) (y - x)", "decl_nm": "domain_mvt"
{"src": "2 goals	E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : Icc 0 1 ⊆ g ⁻¹' s,	t : ℝ,	Ht : t ∈ Icc 0 1,	hg : has_deriv_at g (y - x) t	⊢ has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (Icc 0 1) t		E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : Icc 0 1 ⊆ g ⁻¹' s,	hfg : ∀ (t : ℝ), t ∈ Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (Icc 0 1) t	⊢ ∃ (z : E) (H : z ∈ segment ℝ x y), f y - f x = ⇑(f' z) (y - x)", "decl_nm": "domain_mvt"
{"src": "E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : Icc 0 1 ⊆ g ⁻¹' s,	hfg : ∀ (t : ℝ), t ∈ Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (Icc 0 1) t	⊢ ∃ (z : E) (H : z ∈ segment ℝ x y), f y - f x = ⇑(f' z) (y - x)", "decl_nm": "domain_mvt"
{"src": "2 goals	E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : Icc 0 1 ⊆ g ⁻¹' s,	hfg : ∀ (t : ℝ), t ∈ Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (Icc 0 1) t	⊢ ∃ (t : ℝ) (H : t ∈ Ioo 0 1), ⇑(f' (g t)) (y - x) = (f (g 1) - f (g 0)) / (1 - 0)		E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : Icc 0 1 ⊆ g ⁻¹' s,	hfg : ∀ (t : ℝ), t ∈ Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (Icc 0 1) t,	hMVT : ∃ (t : ℝ) (H : t ∈ Ioo 0 1), ⇑(f' (g t)) (y - x) = (f (g 1) - f (g 0)) / (1 - 0)	⊢ ∃ (z : E) (H : z ∈ segment ℝ x y), f y - f x = ⇑(f' z) (y - x)", "decl_nm": "domain_mvt"
{"src": "3 goals	E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : Icc 0 1 ⊆ g ⁻¹' s,	hfg : ∀ (t : ℝ), t ∈ Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (Icc 0 1) t	⊢ continuous_on (f ∘ g) (Icc 0 1)		E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : Icc 0 1 ⊆ g ⁻¹' s,	hfg : ∀ (t : ℝ), t ∈ Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (Icc 0 1) t	⊢ ∀ (x_1 : ℝ), x_1 ∈ Ioo 0 1 → has_deriv_at (f ∘ g) (⇑(f' (g x_1)) (y - x)) x_1		E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : Icc 0 1 ⊆ g ⁻¹' s,	hfg : ∀ (t : ℝ), t ∈ Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (Icc 0 1) t,	hMVT : ∃ (t : ℝ) (H : t ∈ Ioo 0 1), ⇑(f' (g t)) (y - x) = (f (g 1) - f (g 0)) / (1 - 0)	⊢ ∃ (z : E) (H : z ∈ segment ℝ x y), f y - f x = ⇑(f' z) (y - x)", "decl_nm": "domain_mvt"
{"src": "3 goals	E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : Icc 0 1 ⊆ g ⁻¹' s,	hfg : ∀ (t : ℝ), t ∈ Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (Icc 0 1) t	⊢ ∀ (x : ℝ), x ∈ Icc 0 1 → continuous_within_at (f ∘ g) (Icc 0 1) x		E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : Icc 0 1 ⊆ g ⁻¹' s,	hfg : ∀ (t : ℝ), t ∈ Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (Icc 0 1) t	⊢ ∀ (x_1 : ℝ), x_1 ∈ Ioo 0 1 → has_deriv_at (f ∘ g) (⇑(f' (g x_1)) (y - x)) x_1		E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : Icc 0 1 ⊆ g ⁻¹' s,	hfg : ∀ (t : ℝ), t ∈ Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (Icc 0 1) t,	hMVT : ∃ (t : ℝ) (H : t ∈ Ioo 0 1), ⇑(f' (g t)) (y - x) = (f (g 1) - f (g 0)) / (1 - 0)	⊢ ∃ (z : E) (H : z ∈ segment ℝ x y), f y - f x = ⇑(f' z) (y - x)", "decl_nm": "domain_mvt"
{"src": "2 goals	E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : Icc 0 1 ⊆ g ⁻¹' s,	hfg : ∀ (t : ℝ), t ∈ Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (Icc 0 1) t	⊢ ∀ (x_1 : ℝ), x_1 ∈ Ioo 0 1 → has_deriv_at (f ∘ g) (⇑(f' (g x_1)) (y - x)) x_1		E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : Icc 0 1 ⊆ g ⁻¹' s,	hfg : ∀ (t : ℝ), t ∈ Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (Icc 0 1) t,	hMVT : ∃ (t : ℝ) (H : t ∈ Ioo 0 1), ⇑(f' (g t)) (y - x) = (f (g 1) - f (g 0)) / (1 - 0)	⊢ ∃ (z : E) (H : z ∈ segment ℝ x y), f y - f x = ⇑(f' z) (y - x)", "decl_nm": "domain_mvt"
{"src": "2 goals	E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : Icc 0 1 ⊆ g ⁻¹' s,	hfg : ∀ (t : ℝ), t ∈ Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (Icc 0 1) t,	t : ℝ,	Ht : t ∈ Ioo 0 1	⊢ Icc 0 1 ∈ nhds t		E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : Icc 0 1 ⊆ g ⁻¹' s,	hfg : ∀ (t : ℝ), t ∈ Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (Icc 0 1) t,	hMVT : ∃ (t : ℝ) (H : t ∈ Ioo 0 1), ⇑(f' (g t)) (y - x) = (f (g 1) - f (g 0)) / (1 - 0)	⊢ ∃ (z : E) (H : z ∈ segment ℝ x y), f y - f x = ⇑(f' z) (y - x)", "decl_nm": "domain_mvt"
{"src": "2 goals	E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : Icc 0 1 ⊆ g ⁻¹' s,	hfg : ∀ (t : ℝ), t ∈ Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (Icc 0 1) t,	t : ℝ,	Ht : t ∈ Ioo 0 1	⊢ ∃ (t_1 : set ℝ) (H : t_1 ⊆ Icc 0 1), is_open t_1 ∧ t ∈ t_1		E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : Icc 0 1 ⊆ g ⁻¹' s,	hfg : ∀ (t : ℝ), t ∈ Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (Icc 0 1) t,	hMVT : ∃ (t : ℝ) (H : t ∈ Ioo 0 1), ⇑(f' (g t)) (y - x) = (f (g 1) - f (g 0)) / (1 - 0)	⊢ ∃ (z : E) (H : z ∈ segment ℝ x y), f y - f x = ⇑(f' z) (y - x)", "decl_nm": "domain_mvt"
{"src": "2 goals	E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : Icc 0 1 ⊆ g ⁻¹' s,	hfg : ∀ (t : ℝ), t ∈ Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (Icc 0 1) t,	t : ℝ,	Ht : t ∈ Ioo 0 1	⊢ Ioo 0 1 ⊆ Icc 0 1 ∧ is_open (Ioo 0 1) ∧ t ∈ Ioo 0 1		E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : Icc 0 1 ⊆ g ⁻¹' s,	hfg : ∀ (t : ℝ), t ∈ Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (Icc 0 1) t,	hMVT : ∃ (t : ℝ) (H : t ∈ Ioo 0 1), ⇑(f' (g t)) (y - x) = (f (g 1) - f (g 0)) / (1 - 0)	⊢ ∃ (z : E) (H : z ∈ segment ℝ x y), f y - f x = ⇑(f' z) (y - x)", "decl_nm": "domain_mvt"
{"src": "2 goals	E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : Icc 0 1 ⊆ g ⁻¹' s,	hfg : ∀ (t : ℝ), t ∈ Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (Icc 0 1) t,	t : ℝ,	Ht : t ∈ Ioo 0 1	⊢ is_open (Ioo 0 1)		E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : Icc 0 1 ⊆ g ⁻¹' s,	hfg : ∀ (t : ℝ), t ∈ Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (Icc 0 1) t,	hMVT : ∃ (t : ℝ) (H : t ∈ Ioo 0 1), ⇑(f' (g t)) (y - x) = (f (g 1) - f (g 0)) / (1 - 0)	⊢ ∃ (z : E) (H : z ∈ segment ℝ x y), f y - f x = ⇑(f' z) (y - x)", "decl_nm": "domain_mvt"
{"src": "E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : Icc 0 1 ⊆ g ⁻¹' s,	hfg : ∀ (t : ℝ), t ∈ Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (Icc 0 1) t,	hMVT : ∃ (t : ℝ) (H : t ∈ Ioo 0 1), ⇑(f' (g t)) (y - x) = (f (g 1) - f (g 0)) / (1 - 0)	⊢ ∃ (z : E) (H : z ∈ segment ℝ x y), f y - f x = ⇑(f' z) (y - x)", "decl_nm": "domain_mvt"
{"src": "E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : Icc 0 1 ⊆ g ⁻¹' s,	hfg : ∀ (t : ℝ), t ∈ Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (Icc 0 1) t,	t : ℝ,	Ht : t ∈ Ioo 0 1,	hMVT' : ⇑(f' (g t)) (y - x) = (f (g 1) - f (g 0)) / (1 - 0)	⊢ ∃ (z : E) (H : z ∈ segment ℝ x y), f y - f x = ⇑(f' z) (y - x)", "decl_nm": "domain_mvt"
{"src": "E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : Icc 0 1 ⊆ g ⁻¹' s,	hfg : ∀ (t : ℝ), t ∈ Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (Icc 0 1) t,	t : ℝ,	Ht : t ∈ Ioo 0 1,	hMVT' : ⇑(f' (g t)) (y - x) = (f (g 1) - f (g 0)) / (1 - 0)	⊢ g t ∈ segment ℝ x y ∧ f y - f x = ⇑(f' (g t)) (y - x)", "decl_nm": "domain_mvt"
{"src": "E : Type u_1,	_inst_1 : normed_group E,	_inst_2 : normed_space ℝ E,	f : E → ℝ,	s : set E,	x y : E,	f' : E → (E →L[ℝ] ℝ),	hf : ∀ (x : E), x ∈ s → has_fderiv_within_at f (f' x) s x,	hs : convex ℝ s,	xs : x ∈ s,	ys : y ∈ s,	hIccIoo : Ioo 0 1 ⊆ Icc 0 1,	g : ℝ → E := λ (t : ℝ), x + t • (y - x),	hseg : ∀ (t : ℝ), t ∈ Icc 0 1 → g t ∈ segment ℝ x y,	hseg' : Icc 0 1 ⊆ g ⁻¹' s,	hfg : ∀ (t : ℝ), t ∈ Icc 0 1 → has_deriv_within_at (f ∘ g) (⇑(f' (g t)) (y - x)) (Icc 0 1) t,	t : ℝ,	Ht : t ∈ Ioo 0 1,	hMVT' : ⇑(f' (g t)) (y - x) = (f (g 1) - f (g 0)) / (1 - 0)	⊢ f y - f x = ⇑(f' (g t)) (y - x)", "decl_nm": "domain_mvt"
{"src": "⊢ ∀ (f f' : ℝ → ℝ) {a b : ℝ},	    a < b →	    continuous_on f (Icc a b) →	    (∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at f (f' x) x) →	    ∀ (g g' : ℝ → ℝ),	      continuous_on g (Icc a b) →	      (∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at g (g' x) x) →	      (∃ (c : ℝ) (H : c ∈ Ioo a b), (g b - g a) * f' c = (f b - f a) * g' c)", "decl_nm": "exists_ratio_has_deriv_at_eq_ratio_slope"
{"src": "f f' : ℝ → ℝ,	a b : ℝ,	hab : a < b,	hfc : continuous_on f (Icc a b),	hff' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at f (f' x) x,	g g' : ℝ → ℝ,	hgc : continuous_on g (Icc a b),	hgg' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at g (g' x) x	⊢ ∃ (c : ℝ) (H : c ∈ Ioo a b), (g b - g a) * f' c = (f b - f a) * g' c", "decl_nm": "exists_ratio_has_deriv_at_eq_ratio_slope"
{"src": "f f' : ℝ → ℝ,	a b : ℝ,	hab : a < b,	hfc : continuous_on f (Icc a b),	hff' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at f (f' x) x,	g g' : ℝ → ℝ,	hgc : continuous_on g (Icc a b),	hgg' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at g (g' x) x,	h : ℝ → ℝ := λ (x : ℝ), (g b - g a) * f x - (f b - f a) * g x	⊢ ∃ (c : ℝ) (H : c ∈ Ioo a b), (g b - g a) * f' c = (f b - f a) * g' c", "decl_nm": "exists_ratio_has_deriv_at_eq_ratio_slope"
{"src": "2 goals	f f' : ℝ → ℝ,	a b : ℝ,	hab : a < b,	hfc : continuous_on f (Icc a b),	hff' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at f (f' x) x,	g g' : ℝ → ℝ,	hgc : continuous_on g (Icc a b),	hgg' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at g (g' x) x,	h : ℝ → ℝ := λ (x : ℝ), (g b - g a) * f x - (f b - f a) * g x	⊢ h a = h b		f f' : ℝ → ℝ,	a b : ℝ,	hab : a < b,	hfc : continuous_on f (Icc a b),	hff' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at f (f' x) x,	g g' : ℝ → ℝ,	hgc : continuous_on g (Icc a b),	hgg' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at g (g' x) x,	h : ℝ → ℝ := λ (x : ℝ), (g b - g a) * f x - (f b - f a) * g x,	hI : h a = h b	⊢ ∃ (c : ℝ) (H : c ∈ Ioo a b), (g b - g a) * f' c = (f b - f a) * g' c", "decl_nm": "exists_ratio_has_deriv_at_eq_ratio_slope"
{"src": "2 goals	f f' : ℝ → ℝ,	a b : ℝ,	hab : a < b,	hfc : continuous_on f (Icc a b),	hff' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at f (f' x) x,	g g' : ℝ → ℝ,	hgc : continuous_on g (Icc a b),	hgg' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at g (g' x) x,	h : ℝ → ℝ := λ (x : ℝ), (g b - g a) * f x - (f b - f a) * g x	⊢ (g b - g a) * f a - (f b - f a) * g a = (g b - g a) * f b - (f b - f a) * g b		f f' : ℝ → ℝ,	a b : ℝ,	hab : a < b,	hfc : continuous_on f (Icc a b),	hff' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at f (f' x) x,	g g' : ℝ → ℝ,	hgc : continuous_on g (Icc a b),	hgg' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at g (g' x) x,	h : ℝ → ℝ := λ (x : ℝ), (g b - g a) * f x - (f b - f a) * g x,	hI : h a = h b	⊢ ∃ (c : ℝ) (H : c ∈ Ioo a b), (g b - g a) * f' c = (f b - f a) * g' c", "decl_nm": "exists_ratio_has_deriv_at_eq_ratio_slope"
{"src": "f f' : ℝ → ℝ,	a b : ℝ,	hab : a < b,	hfc : continuous_on f (Icc a b),	hff' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at f (f' x) x,	g g' : ℝ → ℝ,	hgc : continuous_on g (Icc a b),	hgg' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at g (g' x) x,	h : ℝ → ℝ := λ (x : ℝ), (g b - g a) * f x - (f b - f a) * g x,	hI : h a = h b	⊢ ∃ (c : ℝ) (H : c ∈ Ioo a b), (g b - g a) * f' c = (f b - f a) * g' c", "decl_nm": "exists_ratio_has_deriv_at_eq_ratio_slope"
{"src": "f f' : ℝ → ℝ,	a b : ℝ,	hab : a < b,	hfc : continuous_on f (Icc a b),	hff' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at f (f' x) x,	g g' : ℝ → ℝ,	hgc : continuous_on g (Icc a b),	hgg' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at g (g' x) x,	h : ℝ → ℝ := λ (x : ℝ), (g b - g a) * f x - (f b - f a) * g x,	hI : h a = h b,	h' : ℝ → ℝ := λ (x : ℝ), (g b - g a) * f' x - (f b - f a) * g' x	⊢ ∃ (c : ℝ) (H : c ∈ Ioo a b), (g b - g a) * f' c = (f b - f a) * g' c", "decl_nm": "exists_ratio_has_deriv_at_eq_ratio_slope"
{"src": "2 goals	f f' : ℝ → ℝ,	a b : ℝ,	hab : a < b,	hfc : continuous_on f (Icc a b),	hff' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at f (f' x) x,	g g' : ℝ → ℝ,	hgc : continuous_on g (Icc a b),	hgg' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at g (g' x) x,	h : ℝ → ℝ := λ (x : ℝ), (g b - g a) * f x - (f b - f a) * g x,	hI : h a = h b,	h' : ℝ → ℝ := λ (x : ℝ), (g b - g a) * f' x - (f b - f a) * g' x	⊢ ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at h (h' x) x		f f' : ℝ → ℝ,	a b : ℝ,	hab : a < b,	hfc : continuous_on f (Icc a b),	hff' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at f (f' x) x,	g g' : ℝ → ℝ,	hgc : continuous_on g (Icc a b),	hgg' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at g (g' x) x,	h : ℝ → ℝ := λ (x : ℝ), (g b - g a) * f x - (f b - f a) * g x,	hI : h a = h b,	h' : ℝ → ℝ := λ (x : ℝ), (g b - g a) * f' x - (f b - f a) * g' x,	hhh' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at h (h' x) x	⊢ ∃ (c : ℝ) (H : c ∈ Ioo a b), (g b - g a) * f' c = (f b - f a) * g' c", "decl_nm": "exists_ratio_has_deriv_at_eq_ratio_slope"
{"src": "f f' : ℝ → ℝ,	a b : ℝ,	hab : a < b,	hfc : continuous_on f (Icc a b),	hff' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at f (f' x) x,	g g' : ℝ → ℝ,	hgc : continuous_on g (Icc a b),	hgg' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at g (g' x) x,	h : ℝ → ℝ := λ (x : ℝ), (g b - g a) * f x - (f b - f a) * g x,	hI : h a = h b,	h' : ℝ → ℝ := λ (x : ℝ), (g b - g a) * f' x - (f b - f a) * g' x,	hhh' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at h (h' x) x	⊢ ∃ (c : ℝ) (H : c ∈ Ioo a b), (g b - g a) * f' c = (f b - f a) * g' c", "decl_nm": "exists_ratio_has_deriv_at_eq_ratio_slope"
{"src": "2 goals	f f' : ℝ → ℝ,	a b : ℝ,	hab : a < b,	hfc : continuous_on f (Icc a b),	hff' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at f (f' x) x,	g g' : ℝ → ℝ,	hgc : continuous_on g (Icc a b),	hgg' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at g (g' x) x,	h : ℝ → ℝ := λ (x : ℝ), (g b - g a) * f x - (f b - f a) * g x,	hI : h a = h b,	h' : ℝ → ℝ := λ (x : ℝ), (g b - g a) * f' x - (f b - f a) * g' x,	hhh' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at h (h' x) x	⊢ continuous_on h (Icc a b)		f f' : ℝ → ℝ,	a b : ℝ,	hab : a < b,	hfc : continuous_on f (Icc a b),	hff' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at f (f' x) x,	g g' : ℝ → ℝ,	hgc : continuous_on g (Icc a b),	hgg' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at g (g' x) x,	h : ℝ → ℝ := λ (x : ℝ), (g b - g a) * f x - (f b - f a) * g x,	hI : h a = h b,	h' : ℝ → ℝ := λ (x : ℝ), (g b - g a) * f' x - (f b - f a) * g' x,	hhh' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at h (h' x) x,	hhc : continuous_on h (Icc a b)	⊢ ∃ (c : ℝ) (H : c ∈ Ioo a b), (g b - g a) * f' c = (f b - f a) * g' c", "decl_nm": "exists_ratio_has_deriv_at_eq_ratio_slope"
{"src": "f f' : ℝ → ℝ,	a b : ℝ,	hab : a < b,	hfc : continuous_on f (Icc a b),	hff' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at f (f' x) x,	g g' : ℝ → ℝ,	hgc : continuous_on g (Icc a b),	hgg' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at g (g' x) x,	h : ℝ → ℝ := λ (x : ℝ), (g b - g a) * f x - (f b - f a) * g x,	hI : h a = h b,	h' : ℝ → ℝ := λ (x : ℝ), (g b - g a) * f' x - (f b - f a) * g' x,	hhh' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at h (h' x) x,	hhc : continuous_on h (Icc a b)	⊢ ∃ (c : ℝ) (H : c ∈ Ioo a b), (g b - g a) * f' c = (f b - f a) * g' c", "decl_nm": "exists_ratio_has_deriv_at_eq_ratio_slope"
{"src": "f f' : ℝ → ℝ,	a b : ℝ,	hab : a < b,	hfc : continuous_on f (Icc a b),	hff' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at f (f' x) x,	g g' : ℝ → ℝ,	hgc : continuous_on g (Icc a b),	hgg' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at g (g' x) x,	h : ℝ → ℝ := λ (x : ℝ), (g b - g a) * f x - (f b - f a) * g x,	hI : h a = h b,	h' : ℝ → ℝ := λ (x : ℝ), (g b - g a) * f' x - (f b - f a) * g' x,	hhh' : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_at h (h' x) x,	hhc : continuous_on h (Icc a b),	c : ℝ,	cmem : c ∈ Ioo a b,	hc : h' c = 0	⊢ ∃ (c : ℝ) (H : c ∈ Ioo a b), (g b - g a) * f' c = (f b - f a) * g' c", "decl_nm": "exists_ratio_has_deriv_at_eq_ratio_slope"
{"src": "⊢ ∀ {D : set ℝ},	    convex ℝ D →	    ∀ {f : ℝ → ℝ},	      continuous_on f D →	      differentiable_on ℝ f (interior D) → (∀ (x : ℝ), x ∈ interior D → deriv f x ≤ 0) → antitone_on f D", "decl_nm": "convex.antitone_on_of_deriv_nonpos"
{"src": "D : set ℝ,	hD : convex ℝ D,	f : ℝ → ℝ,	hf : continuous_on f D,	hf' : differentiable_on ℝ f (interior D),	hf'_nonpos : ∀ (x : ℝ), x ∈ interior D → deriv f x ≤ 0	⊢ antitone_on f D", "decl_nm": "convex.antitone_on_of_deriv_nonpos"
{"src": "⊢ ∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field 𝕜] {E : Type u_2} [_inst_2 : normed_group E]	  [_inst_3 : normed_space 𝕜 E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space 𝕜 F]	  {G : Type u_4} [_inst_6 : normed_group G] [_inst_7 : normed_space 𝕜 G] {s : set E} {f : E → F} {n : with_top ℕ}	  (e : F ≃L[𝕜] G), times_cont_diff_on 𝕜 n (⇑e ∘ f) s ↔ times_cont_diff_on 𝕜 n f s", "decl_nm": "continuous_linear_equiv.comp_times_cont_diff_on_iff"
{"src": "𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	F : Type u_3,	_inst_4 : normed_group F,	_inst_5 : normed_space 𝕜 F,	G : Type u_4,	_inst_6 : normed_group G,	_inst_7 : normed_space 𝕜 G,	s : set E,	f : E → F,	n : with_top ℕ,	e : F ≃L[𝕜] G	⊢ times_cont_diff_on 𝕜 n (⇑e ∘ f) s ↔ times_cont_diff_on 𝕜 n f s", "decl_nm": "continuous_linear_equiv.comp_times_cont_diff_on_iff"
{"src": "⊢ ∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field 𝕜] {E : Type u_2} [_inst_2 : normed_group E]	  [_inst_3 : normed_space 𝕜 E] {𝕜' : Type u_6} [_inst_10 : normed_field 𝕜']	  [_inst_11 : normed_algebra 𝕜 𝕜'] [_inst_12 : complete_space 𝕜'] {f : E → 𝕜'} {n : with_top ℕ},	    times_cont_diff 𝕜 n f → (∀ (x : E), f x ≠ 0) → times_cont_diff 𝕜 n (λ (x : E), (f x)⁻¹)", "decl_nm": "times_cont_diff.inv"
{"src": "𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	𝕜' : Type u_6,	_inst_10 : normed_field 𝕜',	_inst_11 : normed_algebra 𝕜 𝕜',	_inst_12 : complete_space 𝕜',	f : E → 𝕜',	n : with_top ℕ,	hf : times_cont_diff 𝕜 n f,	h : ∀ (x : E), f x ≠ 0	⊢ times_cont_diff 𝕜 n (λ (x : E), (f x)⁻¹)", "decl_nm": "times_cont_diff.inv"
{"src": "𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	𝕜' : Type u_6,	_inst_10 : normed_field 𝕜',	_inst_11 : normed_algebra 𝕜 𝕜',	_inst_12 : complete_space 𝕜',	f : E → 𝕜',	n : with_top ℕ,	hf : times_cont_diff 𝕜 n f,	h : ∀ (x : E), f x ≠ 0	⊢ ∀ (x : E), times_cont_diff_at 𝕜 n (λ (x : E), (f x)⁻¹) x", "decl_nm": "times_cont_diff.inv"
{"src": "⊢ ∀ {e : ℂ → ℂ} {z : ℝ} {n : with_top ℕ},	    times_cont_diff_at ℂ n e ↑z → times_cont_diff_at ℝ n (λ (x : ℝ), (e ↑x).re) z", "decl_nm": "times_cont_diff_at.real_of_complex"
{"src": "e : ℂ → ℂ,	z : ℝ,	n : with_top ℕ,	h : times_cont_diff_at ℂ n e ↑z	⊢ times_cont_diff_at ℝ n (λ (x : ℝ), (e ↑x).re) z", "decl_nm": "times_cont_diff_at.real_of_complex"
{"src": "2 goals	e : ℂ → ℂ,	z : ℝ,	n : with_top ℕ,	h : times_cont_diff_at ℂ n e ↑z	⊢ times_cont_diff_at ℝ n coe z		e : ℂ → ℂ,	z : ℝ,	n : with_top ℕ,	h : times_cont_diff_at ℂ n e ↑z,	A : times_cont_diff_at ℝ n coe z	⊢ times_cont_diff_at ℝ n (λ (x : ℝ), (e ↑x).re) z", "decl_nm": "times_cont_diff_at.real_of_complex"
{"src": "e : ℂ → ℂ,	z : ℝ,	n : with_top ℕ,	h : times_cont_diff_at ℂ n e ↑z,	A : times_cont_diff_at ℝ n coe z	⊢ times_cont_diff_at ℝ n (λ (x : ℝ), (e ↑x).re) z", "decl_nm": "times_cont_diff_at.real_of_complex"
{"src": "e : ℂ → ℂ,	z : ℝ,	n : with_top ℕ,	h : times_cont_diff_at ℂ n e ↑z,	A : times_cont_diff_at ℝ n coe z,	B : times_cont_diff_at ℝ n e ↑z	⊢ times_cont_diff_at ℝ n (λ (x : ℝ), (e ↑x).re) z", "decl_nm": "times_cont_diff_at.real_of_complex"
{"src": "2 goals	e : ℂ → ℂ,	z : ℝ,	n : with_top ℕ,	h : times_cont_diff_at ℂ n e ↑z,	A : times_cont_diff_at ℝ n coe z,	B : times_cont_diff_at ℝ n e ↑z	⊢ times_cont_diff_at ℝ n re (e ↑z)		e : ℂ → ℂ,	z : ℝ,	n : with_top ℕ,	h : times_cont_diff_at ℂ n e ↑z,	A : times_cont_diff_at ℝ n coe z,	B : times_cont_diff_at ℝ n e ↑z,	C : times_cont_diff_at ℝ n re (e ↑z)	⊢ times_cont_diff_at ℝ n (λ (x : ℝ), (e ↑x).re) z", "decl_nm": "times_cont_diff_at.real_of_complex"
{"src": "e : ℂ → ℂ,	z : ℝ,	n : with_top ℕ,	h : times_cont_diff_at ℂ n e ↑z,	A : times_cont_diff_at ℝ n coe z,	B : times_cont_diff_at ℝ n e ↑z,	C : times_cont_diff_at ℝ n re (e ↑z)	⊢ times_cont_diff_at ℝ n (λ (x : ℝ), (e ↑x).re) z", "decl_nm": "times_cont_diff_at.real_of_complex"
{"src": "⊢ ∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [_inst_1 : ordered_ring 𝕜] [_inst_2 : add_comm_group E]	  [_inst_3 : add_comm_group F] [_inst_4 : module 𝕜 E] [_inst_5 : module 𝕜 F] (f : E →ᵃ[𝕜] F) {s : set F},	    convex 𝕜 s → convex 𝕜 (⇑f ⁻¹' s)", "decl_nm": "convex.affine_preimage"
{"src": "𝕜 : Type u_1,	E : Type u_2,	F : Type u_3,	_inst_1 : ordered_ring 𝕜,	_inst_2 : add_comm_group E,	_inst_3 : add_comm_group F,	_inst_4 : module 𝕜 E,	_inst_5 : module 𝕜 F,	f : E →ᵃ[𝕜] F,	s : set F,	hs : convex 𝕜 s	⊢ convex 𝕜 (⇑f ⁻¹' s)", "decl_nm": "convex.affine_preimage"
{"src": "𝕜 : Type u_1,	E : Type u_2,	F : Type u_3,	_inst_1 : ordered_ring 𝕜,	_inst_2 : add_comm_group E,	_inst_3 : add_comm_group F,	_inst_4 : module 𝕜 E,	_inst_5 : module 𝕜 F,	f : E →ᵃ[𝕜] F,	s : set F,	hs : convex 𝕜 s,	x y : E,	xs : x ∈ ⇑f ⁻¹' s,	ys : y ∈ ⇑f ⁻¹' s,	a b : 𝕜,	ha : 0 ≤ a,	hb : 0 ≤ b,	hab : a + b = 1	⊢ a • x + b • y ∈ ⇑f ⁻¹' s", "decl_nm": "convex.affine_preimage"
{"src": "𝕜 : Type u_1,	E : Type u_2,	F : Type u_3,	_inst_1 : ordered_ring 𝕜,	_inst_2 : add_comm_group E,	_inst_3 : add_comm_group F,	_inst_4 : module 𝕜 E,	_inst_5 : module 𝕜 F,	f : E →ᵃ[𝕜] F,	s : set F,	hs : convex 𝕜 s,	x y : E,	xs : x ∈ ⇑f ⁻¹' s,	ys : y ∈ ⇑f ⁻¹' s,	a b : 𝕜,	ha : 0 ≤ a,	hb : 0 ≤ b,	hab : a + b = 1	⊢ a • ⇑f x + b • ⇑f y ∈ s", "decl_nm": "convex.affine_preimage"
{"src": "⊢ ∀ {𝕜 : Type u_1} {E : Type u_2} [_inst_1 : ordered_semiring 𝕜] [_inst_2 : add_comm_monoid E]	  [_inst_3 : has_scalar 𝕜 E] {A B C : set E},	    is_extreme 𝕜 A B → is_extreme 𝕜 A C → is_extreme 𝕜 A (B ∩ C)", "decl_nm": "is_extreme.inter"
{"src": "𝕜 : Type u_1,	E : Type u_2,	_inst_1 : ordered_semiring 𝕜,	_inst_2 : add_comm_monoid E,	_inst_3 : has_scalar 𝕜 E,	A B C : set E,	hAB : is_extreme 𝕜 A B,	hAC : is_extreme 𝕜 A C	⊢ is_extreme 𝕜 A (B ∩ C)", "decl_nm": "is_extreme.inter"
{"src": "𝕜 : Type u_1,	E : Type u_2,	_inst_1 : ordered_semiring 𝕜,	_inst_2 : add_comm_monoid E,	_inst_3 : has_scalar 𝕜 E,	A B C : set E,	hAB : is_extreme 𝕜 A B,	hAC : is_extreme 𝕜 A C	⊢ ∀ (x₁ : E),	    x₁ ∈ A →	    ∀ (x₂ : E),	      x₂ ∈ A →	      ∀ (x : E), x ∈ B ∩ C → x ∈ open_segment 𝕜 x₁ x₂ → x₁ ∈ B ∩ C ∧ x₂ ∈ B ∩ C", "decl_nm": "is_extreme.inter"
{"src": "𝕜 : Type u_1,	E : Type u_2,	_inst_1 : ordered_semiring 𝕜,	_inst_2 : add_comm_monoid E,	_inst_3 : has_scalar 𝕜 E,	A B C : set E,	hAB : is_extreme 𝕜 A B,	hAC : is_extreme 𝕜 A C,	x₁ : E,	x₂ : x₁ ∈ A,	hx₁A : E,	hx₂A : hx₁A ∈ A,	x : E,	hx : x ∈ open_segment 𝕜 x₁ hx₁A,	hxB : x ∈ B,	hxC : x ∈ C	⊢ x₁ ∈ B ∩ C ∧ hx₁A ∈ B ∩ C", "decl_nm": "is_extreme.inter"
{"src": "𝕜 : Type u_1,	E : Type u_2,	_inst_1 : ordered_semiring 𝕜,	_inst_2 : add_comm_monoid E,	_inst_3 : has_scalar 𝕜 E,	A B C : set E,	hAB : is_extreme 𝕜 A B,	hAC : is_extreme 𝕜 A C,	x₁ : E,	x₂ : x₁ ∈ A,	hx₁A : E,	hx₂A : hx₁A ∈ A,	x : E,	hx : x ∈ open_segment 𝕜 x₁ hx₁A,	hxB : x ∈ B,	hxC : x ∈ C,	hx₁B : x₁ ∈ B,	hx₂B : hx₁A ∈ B	⊢ x₁ ∈ B ∩ C ∧ hx₁A ∈ B ∩ C", "decl_nm": "is_extreme.inter"
{"src": "𝕜 : Type u_1,	E : Type u_2,	_inst_1 : ordered_semiring 𝕜,	_inst_2 : add_comm_monoid E,	_inst_3 : has_scalar 𝕜 E,	A B C : set E,	hAB : is_extreme 𝕜 A B,	hAC : is_extreme 𝕜 A C,	x₁ : E,	x₂ : x₁ ∈ A,	hx₁A : E,	hx₂A : hx₁A ∈ A,	x : E,	hx : x ∈ open_segment 𝕜 x₁ hx₁A,	hxB : x ∈ B,	hxC : x ∈ C,	hx₁B : x₁ ∈ B,	hx₂B : hx₁A ∈ B,	hx₁C : x₁ ∈ C,	hx₂C : hx₁A ∈ C	⊢ x₁ ∈ B ∩ C ∧ hx₁A ∈ B ∩ C", "decl_nm": "is_extreme.inter"
{"src": "⊢ ∀ {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [_inst_1 : ordered_semiring 𝕜] [_inst_2 : add_comm_monoid E]	  [_inst_4 : ordered_add_comm_monoid β] [_inst_5 : has_scalar 𝕜 E] [_inst_6 : module 𝕜 β]	  [_inst_7 : ordered_smul 𝕜 β] {s : set E} {f : E → β},	    convex_on 𝕜 s f → convex 𝕜 {p : E × β | p.fst ∈ s ∧ f p.fst ≤ p.snd}", "decl_nm": "convex_on.convex_epigraph"
{"src": "𝕜 : Type u_1,	E : Type u_2,	β : Type u_4,	_inst_1 : ordered_semiring 𝕜,	_inst_2 : add_comm_monoid E,	_inst_4 : ordered_add_comm_monoid β,	_inst_5 : has_scalar 𝕜 E,	_inst_6 : module 𝕜 β,	_inst_7 : ordered_smul 𝕜 β,	s : set E,	f : E → β,	hf : convex_on 𝕜 s f	⊢ convex 𝕜 {p : E × β | p.fst ∈ s ∧ f p.fst ≤ p.snd}", "decl_nm": "convex_on.convex_epigraph"
{"src": "𝕜 : Type u_1,	E : Type u_2,	β : Type u_4,	_inst_1 : ordered_semiring 𝕜,	_inst_2 : add_comm_monoid E,	_inst_4 : ordered_add_comm_monoid β,	_inst_5 : has_scalar 𝕜 E,	_inst_6 : module 𝕜 β,	_inst_7 : ordered_smul 𝕜 β,	s : set E,	f : E → β,	hf : convex_on 𝕜 s f,	a b : 𝕜,	ha : 0 ≤ a,	hb : 0 ≤ b,	hab : a + b = 1,	x : E,	r : β,	y : E,	t : β,	hx : (x, r).fst ∈ s,	hr : f (x, r).fst ≤ (x, r).snd,	hy : (y, t).fst ∈ s,	ht : f (y, t).fst ≤ (y, t).snd	⊢ a • (x, r) + b • (y, t) ∈ {p : E × β | p.fst ∈ s ∧ f p.fst ≤ p.snd}", "decl_nm": "convex_on.convex_epigraph"
{"src": "𝕜 : Type u_1,	E : Type u_2,	β : Type u_4,	_inst_1 : ordered_semiring 𝕜,	_inst_2 : add_comm_monoid E,	_inst_4 : ordered_add_comm_monoid β,	_inst_5 : has_scalar 𝕜 E,	_inst_6 : module 𝕜 β,	_inst_7 : ordered_smul 𝕜 β,	s : set E,	f : E → β,	hf : convex_on 𝕜 s f,	a b : 𝕜,	ha : 0 ≤ a,	hb : 0 ≤ b,	hab : a + b = 1,	x : E,	r : β,	y : E,	t : β,	hx : (x, r).fst ∈ s,	hr : f (x, r).fst ≤ (x, r).snd,	hy : (y, t).fst ∈ s,	ht : f (y, t).fst ≤ (y, t).snd	⊢ f (a • (x, r) + b • (y, t)).fst ≤ (a • (x, r) + b • (y, t)).snd", "decl_nm": "convex_on.convex_epigraph"
{"src": "⊢ ∀ {𝕜 : Type u_1} {F : Type u_3} [_inst_1 : is_R_or_C 𝕜] [_inst_2 : add_comm_group F]	  [_inst_3 : module 𝕜 F] [c : inner_product_space.core 𝕜 F] {x : F}, ⇑im (inner x x) = 0", "decl_nm": "inner_product_space.of_core.inner_self_nonneg_im"
{"src": "𝕜 : Type u_1,	F : Type u_3,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : add_comm_group F,	_inst_3 : module 𝕜 F,	c : inner_product_space.core 𝕜 F,	x : F	⊢ ⇑im (inner x x) = 0", "decl_nm": "inner_product_space.of_core.inner_self_nonneg_im"
{"src": "𝕜 : Type u_1,	F : Type u_3,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : add_comm_group F,	_inst_3 : module 𝕜 F,	c : inner_product_space.core 𝕜 F,	x : F	⊢ I * (⇑(star_ring_end 𝕜) (inner x x) - inner x x) / 2 = ↑0", "decl_nm": "inner_product_space.of_core.inner_self_nonneg_im"
{"src": "⊢ ∀ {𝕜 : Type u_1} {E : Type u_2} [_inst_1 : is_R_or_C 𝕜] [_inst_2 : inner_product_space 𝕜 E]	  {ι : Type u_3} (l : ι →₀ 𝕜) (v : ι → E) (x : E),	    inner (l.sum (λ (i : ι) (a : 𝕜), a • v i)) x =	      l.sum (λ (i : ι) (a : 𝕜), ⇑(star_ring_end 𝕜) a • inner (v i) x)", "decl_nm": "finsupp.sum_inner"
{"src": "𝕜 : Type u_1,	E : Type u_2,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : inner_product_space 𝕜 E,	ι : Type u_3,	l : ι →₀ 𝕜,	v : ι → E,	x : E	⊢ inner (l.sum (λ (i : ι) (a : 𝕜), a • v i)) x =	    l.sum (λ (i : ι) (a : 𝕜), ⇑(star_ring_end 𝕜) a • inner (v i) x)", "decl_nm": "finsupp.sum_inner"
{"src": "𝕜 : Type u_1,	E : Type u_2,	_inst_1 : is_R_or_C 𝕜,	_inst_2 : inner_product_space 𝕜 E,	ι : Type u_3,	l : ι →₀ 𝕜,	v : ι → E,	x : E	⊢ l.sum (λ (i : ι) (a : 𝕜), ⇑(star_ring_end 𝕜) a • inner (v i) x) =	    l.support.sum (λ (i : ι), inner (⇑l i • v i) x)", "decl_nm": "finsupp.sum_inner"
{"src": "⊢ ∀ (x : euclidean_space ℝ (fin 2)), ⇑(complex.isometry_euclidean.symm) x = ↑(x 0) + ↑(x 1) * I", "decl_nm": "complex.isometry_euclidean_symm_apply"
{"src": "x : euclidean_space ℝ (fin 2)	⊢ ⇑(complex.isometry_euclidean.symm) x = ↑(x 0) + ↑(x 1) * I", "decl_nm": "complex.isometry_euclidean_symm_apply"
{"src": "2 goals	x : euclidean_space ℝ (fin 2)	⊢ ↑(x 0) = (λ (i : fin 2), x i • ⇑complex.basis_one_I i) (fin.mk 0 _)		x : euclidean_space ℝ (fin 2)	⊢ ↑(x 1) * I =	    list.foldr has_add.add 0	      (list.map (λ (i : fin 2), x i • ⇑complex.basis_one_I i) (list.pmap fin.mk [1.add 0] _))", "decl_nm": "complex.isometry_euclidean_symm_apply"
{"src": "x : euclidean_space ℝ (fin 2)	⊢ ↑(x 1) * I =	    list.foldr has_add.add 0	      (list.map (λ (i : fin 2), x i • ⇑complex.basis_one_I i) (list.pmap fin.mk [1.add 0] _))", "decl_nm": "complex.isometry_euclidean_symm_apply"
{"src": "⊢ ∀ {ι : Type u} (s : finset ι) (w z : ι → nnreal),	    s.sum (λ (i : ι), w i) = 1 →	    ∀ (n : ℕ), s.sum (λ (i : ι), w i * z i) ^ n ≤ s.sum (λ (i : ι), w i * z i ^ n)", "decl_nm": "nnreal.pow_arith_mean_le_arith_mean_pow"
{"src": "ι : Type u,	s : finset ι,	w z : ι → nnreal,	hw' : s.sum (λ (i : ι), w i) = 1,	n : ℕ	⊢ s.sum (λ (i : ι), w i * z i) ^ n ≤ s.sum (λ (i : ι), w i * z i ^ n)", "decl_nm": "nnreal.pow_arith_mean_le_arith_mean_pow"
{"src": "⊢ ∀ (w₁ w₂ z₁ z₂ : nnreal),	    w₁ + w₂ = 1 → ∀ {p : ℝ}, 1 ≤ p → (w₁ * z₁ + w₂ * z₂) ^ p ≤ w₁ * z₁ ^ p + w₂ * z₂ ^ p", "decl_nm": "nnreal.rpow_arith_mean_le_arith_mean2_rpow"
{"src": "w₁ w₂ z₁ z₂ : nnreal,	hw' : w₁ + w₂ = 1,	p : ℝ,	hp : 1 ≤ p	⊢ (w₁ * z₁ + w₂ * z₂) ^ p ≤ w₁ * z₁ ^ p + w₂ * z₂ ^ p", "decl_nm": "nnreal.rpow_arith_mean_le_arith_mean2_rpow"
{"src": "2 goals	w₁ w₂ z₁ z₂ : nnreal,	hw' : w₁ + w₂ = 1,	p : ℝ,	hp : 1 ≤ p,	h :	  univ.sum	        (λ (i : fin 2),	           fin.cons w₁ (fin.cons w₂ fin_zero_elim) i * fin.cons z₁ (fin.cons z₂ fin_zero_elim) i) ^	      p ≤	    univ.sum	      (λ (i : fin 2),	         fin.cons w₁ (fin.cons w₂ fin_zero_elim) i * fin.cons z₁ (fin.cons z₂ fin_zero_elim) i ^ p)	⊢ (w₁ * z₁ + w₂ * z₂) ^ p ≤ w₁ * z₁ ^ p + w₂ * z₂ ^ p		w₁ w₂ z₁ z₂ : nnreal,	hw' : w₁ + w₂ = 1,	p : ℝ,	hp : 1 ≤ p	⊢ univ.sum (λ (i : fin 2), fin.cons w₁ (fin.cons w₂ fin_zero_elim) i) = 1", "decl_nm": "nnreal.rpow_arith_mean_le_arith_mean2_rpow"
{"src": "w₁ w₂ z₁ z₂ : nnreal,	hw' : w₁ + w₂ = 1,	p : ℝ,	hp : 1 ≤ p	⊢ univ.sum (λ (i : fin 2), fin.cons w₁ (fin.cons w₂ fin_zero_elim) i) = 1", "decl_nm": "nnreal.rpow_arith_mean_le_arith_mean2_rpow"
{"src": "⊢ ∀ {ι : Type u} (s : finset ι) (f g : ι → nnreal) {p : ℝ},	    1 ≤ p →	    s.sum (λ (i : ι), (f i + g i) ^ p) ^ (1 / p) ≤	      s.sum (λ (i : ι), f i ^ p) ^ (1 / p) + s.sum (λ (i : ι), g i ^ p) ^ (1 / p)", "decl_nm": "nnreal.Lp_add_le"
{"src": "ι : Type u,	s : finset ι,	f g : ι → nnreal,	p : ℝ,	hp : 1 ≤ p	⊢ s.sum (λ (i : ι), (f i + g i) ^ p) ^ (1 / p) ≤	    s.sum (λ (i : ι), f i ^ p) ^ (1 / p) + s.sum (λ (i : ι), g i ^ p) ^ (1 / p)", "decl_nm": "nnreal.Lp_add_le"
{"src": "2 goals	ι : Type u,	s : finset ι,	f g : ι → nnreal,	hp : 1 ≤ 1	⊢ s.sum (λ (i : ι), (f i + g i) ^ 1) ^ (1 / 1) ≤	    s.sum (λ (i : ι), f i ^ 1) ^ (1 / 1) + s.sum (λ (i : ι), g i ^ 1) ^ (1 / 1)		ι : Type u,	s : finset ι,	f g : ι → nnreal,	p : ℝ,	hp : 1 ≤ p,	hp : 1 < p	⊢ s.sum (λ (i : ι), (f i + g i) ^ p) ^ (1 / p) ≤	    s.sum (λ (i : ι), f i ^ p) ^ (1 / p) + s.sum (λ (i : ι), g i ^ p) ^ (1 / p)", "decl_nm": "nnreal.Lp_add_le"
{"src": "ι : Type u,	s : finset ι,	f g : ι → nnreal,	p : ℝ,	hp : 1 ≤ p,	hp : 1 < p	⊢ s.sum (λ (i : ι), (f i + g i) ^ p) ^ (1 / p) ≤	    s.sum (λ (i : ι), f i ^ p) ^ (1 / p) + s.sum (λ (i : ι), g i ^ p) ^ (1 / p)", "decl_nm": "nnreal.Lp_add_le"
{"src": "ι : Type u,	s : finset ι,	f g : ι → nnreal,	p : ℝ,	hp : 1 ≤ p,	hp : 1 < p,	hpq : p.is_conjugate_exponent p.conjugate_exponent	⊢ s.sum (λ (i : ι), (f i + g i) ^ p) ^ (1 / p) ≤	    s.sum (λ (i : ι), f i ^ p) ^ (1 / p) + s.sum (λ (i : ι), g i ^ p) ^ (1 / p)", "decl_nm": "nnreal.Lp_add_le"
{"src": "ι : Type u,	s : finset ι,	f g : ι → nnreal,	p : ℝ,	hp : 1 ≤ p,	hp : 1 < p,	hpq : p.is_conjugate_exponent p.conjugate_exponent,	this :	  is_greatest	    ((λ (g_1 : ι → nnreal), s.sum (λ (i : ι), (f + g) i * g_1 i)) ''	       {g : ι → nnreal | s.sum (λ (i : ι), g i ^ p.conjugate_exponent) ≤ 1})	    (s.sum (λ (i : ι), (f + g) i ^ p) ^ (1 / p))	⊢ s.sum (λ (i : ι), (f i + g i) ^ p) ^ (1 / p) ≤	    s.sum (λ (i : ι), f i ^ p) ^ (1 / p) + s.sum (λ (i : ι), g i ^ p) ^ (1 / p)", "decl_nm": "nnreal.Lp_add_le"
{"src": "ι : Type u,	s : finset ι,	f g : ι → nnreal,	p : ℝ,	hp : 1 ≤ p,	hp : 1 < p,	hpq : p.is_conjugate_exponent p.conjugate_exponent,	this :	  is_greatest	    ((λ (a : ι → nnreal), s.sum (λ (x : ι), f x * a x) + s.sum (λ (x : ι), g x * a x)) ''	       {g : ι → nnreal | s.sum (λ (i : ι), g i ^ p.conjugate_exponent) ≤ 1})	    (s.sum (λ (x : ι), (f x + g x) ^ p) ^ (1 / p))	⊢ s.sum (λ (i : ι), (f i + g i) ^ p) ^ (1 / p) ≤	    s.sum (λ (i : ι), f i ^ p) ^ (1 / p) + s.sum (λ (i : ι), g i ^ p) ^ (1 / p)", "decl_nm": "nnreal.Lp_add_le"
{"src": "ι : Type u,	s : finset ι,	f g : ι → nnreal,	p : ℝ,	hp : 1 ≤ p,	hp : 1 < p,	hpq : p.is_conjugate_exponent p.conjugate_exponent,	this :	  is_greatest	    ((λ (a : ι → nnreal), s.sum (λ (x : ι), f x * a x) + s.sum (λ (x : ι), g x * a x)) ''	       {g : ι → nnreal | s.sum (λ (i : ι), g i ^ p.conjugate_exponent) ≤ 1})	    (s.sum (λ (x : ι), (f x + g x) ^ p) ^ (1 / p)),	φ : ι → nnreal,	hφ : φ ∈ {g : ι → nnreal | s.sum (λ (i : ι), g i ^ p.conjugate_exponent) ≤ 1},	H :	  (λ (a : ι → nnreal), s.sum (λ (x : ι), f x * a x) + s.sum (λ (x : ι), g x * a x)) φ =	    s.sum (λ (x : ι), (f x + g x) ^ p) ^ (1 / p)	⊢ s.sum (λ (i : ι), (f i + g i) ^ p) ^ (1 / p) ≤	    s.sum (λ (i : ι), f i ^ p) ^ (1 / p) + s.sum (λ (i : ι), g i ^ p) ^ (1 / p)", "decl_nm": "nnreal.Lp_add_le"
{"src": "ι : Type u,	s : finset ι,	f g : ι → nnreal,	p : ℝ,	hp : 1 ≤ p,	hp : 1 < p,	hpq : p.is_conjugate_exponent p.conjugate_exponent,	this :	  is_greatest	    ((λ (a : ι → nnreal), s.sum (λ (x : ι), f x * a x) + s.sum (λ (x : ι), g x * a x)) ''	       {g : ι → nnreal | s.sum (λ (i : ι), g i ^ p.conjugate_exponent) ≤ 1})	    (s.sum (λ (x : ι), (f x + g x) ^ p) ^ (1 / p)),	φ : ι → nnreal,	hφ : φ ∈ {g : ι → nnreal | s.sum (λ (i : ι), g i ^ p.conjugate_exponent) ≤ 1},	H :	  (λ (a : ι → nnreal), s.sum (λ (x : ι), f x * a x) + s.sum (λ (x : ι), g x * a x)) φ =	    s.sum (λ (x : ι), (f x + g x) ^ p) ^ (1 / p)	⊢ (λ (a : ι → nnreal), s.sum (λ (x : ι), f x * a x) + s.sum (λ (x : ι), g x * a x)) φ ≤	    s.sum (λ (i : ι), f i ^ p) ^ (1 / p) + s.sum (λ (i : ι), g i ^ p) ^ (1 / p)", "decl_nm": "nnreal.Lp_add_le"
{"src": "⊢ ∀ {V : Type u_2} {P : Type u_3} [_inst_1 : semi_normed_group V] [_inst_2 : pseudo_metric_space P]	  [_inst_3 : normed_add_torsor V P] (v v' : V) (p p' : P), edist (v +ᵥ p) (v' +ᵥ p') ≤ edist v v' + edist p p'", "decl_nm": "edist_vadd_vadd_le"
{"src": "V : Type u_2,	P : Type u_3,	_inst_1 : semi_normed_group V,	_inst_2 : pseudo_metric_space P,	_inst_3 : normed_add_torsor V P,	v v' : V,	p p' : P	⊢ edist (v +ᵥ p) (v' +ᵥ p') ≤ edist v v' + edist p p'", "decl_nm": "edist_vadd_vadd_le"
{"src": "V : Type u_2,	P : Type u_3,	_inst_1 : semi_normed_group V,	_inst_2 : pseudo_metric_space P,	_inst_3 : normed_add_torsor V P,	v v' : V,	p p' : P	⊢ ↑(nndist (v +ᵥ p) (v' +ᵥ p')) ≤ ↑(nndist v v') + ↑(nndist p p')", "decl_nm": "edist_vadd_vadd_le"
{"src": "⊢ ∀ {𝕜 : Type u_1} {V : Type u_2} {V₂ : Type u_4} [_inst_1 : normed_field 𝕜] [_inst_2 : semi_normed_group V]	  [_inst_4 : semi_normed_group V₂] [_inst_7 : normed_space 𝕜 V] [_inst_9 : normed_space 𝕜 V₂]	  (e : V ≃ₗᵢ[𝕜] V₂), e.to_affine_isometry_equiv.linear_isometry_equiv = e", "decl_nm": "linear_isometry_equiv.to_affine_isometry_equiv_linear_isometry_equiv"
{"src": "𝕜 : Type u_1,	V : Type u_2,	V₂ : Type u_4,	_inst_1 : normed_field 𝕜,	_inst_2 : semi_normed_group V,	_inst_4 : semi_normed_group V₂,	_inst_7 : normed_space 𝕜 V,	_inst_9 : normed_space 𝕜 V₂,	e : V ≃ₗᵢ[𝕜] V₂	⊢ e.to_affine_isometry_equiv.linear_isometry_equiv = e", "decl_nm": "linear_isometry_equiv.to_affine_isometry_equiv_linear_isometry_equiv"
{"src": "𝕜 : Type u_1,	V : Type u_2,	V₂ : Type u_4,	_inst_1 : normed_field 𝕜,	_inst_2 : semi_normed_group V,	_inst_4 : semi_normed_group V₂,	_inst_7 : normed_space 𝕜 V,	_inst_9 : normed_space 𝕜 V₂,	e : V ≃ₗᵢ[𝕜] V₂,	x : V	⊢ ⇑(e.to_affine_isometry_equiv.linear_isometry_equiv) x = ⇑e x", "decl_nm": "linear_isometry_equiv.to_affine_isometry_equiv_linear_isometry_equiv"
{"src": "⊢ ∀ {𝕜 : Type u_1} {V : Type u_2} {P : Type u_8} [_inst_1 : normed_field 𝕜] [_inst_2 : semi_normed_group V]	  [_inst_7 : normed_space 𝕜 V] [_inst_12 : pseudo_metric_space P] [_inst_17 : normed_add_torsor V P] (x y : P),	    dist (⇑(point_reflection 𝕜 x) y) x = dist y x", "decl_nm": "affine_isometry_equiv.dist_point_reflection_fixed"
{"src": "𝕜 : Type u_1,	V : Type u_2,	P : Type u_8,	_inst_1 : normed_field 𝕜,	_inst_2 : semi_normed_group V,	_inst_7 : normed_space 𝕜 V,	_inst_12 : pseudo_metric_space P,	_inst_17 : normed_add_torsor V P,	x y : P	⊢ dist (⇑(point_reflection 𝕜 x) y) x = dist y x", "decl_nm": "affine_isometry_equiv.dist_point_reflection_fixed"
{"src": "⊢ ∀ {E : Type u_5} [_inst_2 : normed_group E] [_inst_6 : normed_space ℝ E] [_inst_7 : nontrivial E] (x : E)	  (r : ℝ), frontier (closed_ball x r) = sphere x r", "decl_nm": "frontier_closed_ball'"
{"src": "E : Type u_5,	_inst_2 : normed_group E,	_inst_6 : normed_space ℝ E,	_inst_7 : nontrivial E,	x : E,	r : ℝ	⊢ frontier (closed_ball x r) = sphere x r", "decl_nm": "frontier_closed_ball'"
{"src": "⊢ ∀ (𝕜 : Type u_1) (𝕜' : Type u_2) [_inst_1 : normed_field 𝕜] [_inst_2 : semi_normed_ring 𝕜']	  [_inst_3 : normed_algebra 𝕜 𝕜'], isometry ⇑(algebra_map 𝕜 𝕜')", "decl_nm": "algebra_map_isometry"
{"src": "𝕜 : Type u_1,	𝕜' : Type u_2,	_inst_1 : normed_field 𝕜,	_inst_2 : semi_normed_ring 𝕜',	_inst_3 : normed_algebra 𝕜 𝕜'	⊢ isometry ⇑(algebra_map 𝕜 𝕜')", "decl_nm": "algebra_map_isometry"
{"src": "𝕜 : Type u_1,	𝕜' : Type u_2,	_inst_1 : normed_field 𝕜,	_inst_2 : semi_normed_ring 𝕜',	_inst_3 : normed_algebra 𝕜 𝕜',	x y : 𝕜	⊢ dist (⇑(algebra_map 𝕜 𝕜') x) (⇑(algebra_map 𝕜 𝕜') y) = dist x y", "decl_nm": "algebra_map_isometry"
{"src": "⊢ ∀ (𝕜 : Type u_5) (𝕜' : Type u_6) [_inst_1 : normed_field 𝕜] [_inst_2 : semi_normed_ring 𝕜']	  [_inst_3 : normed_algebra 𝕜 𝕜'], ∥1∥ = 1", "decl_nm": "normed_algebra.norm_one"
{"src": "𝕜 : Type u_5,	𝕜' : Type u_6,	_inst_1 : normed_field 𝕜,	_inst_2 : semi_normed_ring 𝕜',	_inst_3 : normed_algebra 𝕜 𝕜'	⊢ ∥1∥ = 1", "decl_nm": "normed_algebra.norm_one"
{"src": "⊢ ∀ (𝕜 : Type u_1) [_inst_1 : nondiscrete_normed_field 𝕜] (E : Type u_2) [_inst_2 : semi_normed_group E]	  [_inst_3 : normed_space 𝕜 E] (x : E), ∥⇑(inclusion_in_double_dual 𝕜 E) x∥ ≤ ∥x∥", "decl_nm": "normed_space.double_dual_bound"
{"src": "𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : semi_normed_group E,	_inst_3 : normed_space 𝕜 E,	x : E	⊢ ∥⇑(inclusion_in_double_dual 𝕜 E) x∥ ≤ ∥x∥", "decl_nm": "normed_space.double_dual_bound"
{"src": "⊢ ∀ (𝕜 : Type u) [_inst_1 : nondiscrete_normed_field 𝕜] (E : Type v) [_inst_2 : normed_group E]	  [_inst_3 : normed_space 𝕜 E] [_inst_11 : complete_space 𝕜] [_inst_13 : finite_dimensional 𝕜 E],	    complete_space E", "decl_nm": "finite_dimensional.complete"
{"src": "𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type v,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	_inst_11 : complete_space 𝕜,	_inst_13 : finite_dimensional 𝕜 E	⊢ complete_space E", "decl_nm": "finite_dimensional.complete"
{"src": "𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type v,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	_inst_11 : complete_space 𝕜,	_inst_13 : finite_dimensional 𝕜 E,	e : E ≃L[𝕜] fin (finrank 𝕜 E) → 𝕜 := continuous_linear_equiv.of_finrank_eq _	⊢ complete_space E", "decl_nm": "finite_dimensional.complete"
{"src": "𝕜 : Type u,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type v,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	_inst_11 : complete_space 𝕜,	_inst_13 : finite_dimensional 𝕜 E,	e : E ≃L[𝕜] fin (finrank 𝕜 E) → 𝕜 := continuous_linear_equiv.of_finrank_eq _,	this : uniform_embedding ⇑(e.to_linear_equiv.to_equiv.symm)	⊢ complete_space E", "decl_nm": "finite_dimensional.complete"
{"src": "⊢ ∀ {R : Type u_1} {R₂ : Type u_2} {E : Type u_5} {E₂ : Type u_6} [_inst_1 : semiring R]	  [_inst_2 : semiring R₂] {σ₁₂ : R →+* R₂} {σ₂₁ : R₂ →+* R}	  [_inst_5 : ring_hom_inv_pair σ₁₂ σ₂₁] [_inst_6 : ring_hom_inv_pair σ₂₁ σ₁₂]	  [_inst_25 : semi_normed_group E] [_inst_26 : semi_normed_group E₂] [_inst_29 : module R E]	  [_inst_30 : module R₂ E₂] (e : E ≃ₛₗᵢ[σ₁₂] E₂), range ⇑e = univ", "decl_nm": "linear_isometry_equiv.range_eq_univ"
{"src": "R : Type u_1,	R₂ : Type u_2,	E : Type u_5,	E₂ : Type u_6,	_inst_1 : semiring R,	_inst_2 : semiring R₂,	σ₁₂ : R →+* R₂,	σ₂₁ : R₂ →+* R,	_inst_5 : ring_hom_inv_pair σ₁₂ σ₂₁,	_inst_6 : ring_hom_inv_pair σ₂₁ σ₁₂,	_inst_25 : semi_normed_group E,	_inst_26 : semi_normed_group E₂,	_inst_29 : module R E,	_inst_30 : module R₂ E₂,	e : E ≃ₛₗᵢ[σ₁₂] E₂	⊢ range ⇑e = univ", "decl_nm": "linear_isometry_equiv.range_eq_univ"
{"src": "R : Type u_1,	R₂ : Type u_2,	E : Type u_5,	E₂ : Type u_6,	_inst_1 : semiring R,	_inst_2 : semiring R₂,	σ₁₂ : R →+* R₂,	σ₂₁ : R₂ →+* R,	_inst_5 : ring_hom_inv_pair σ₁₂ σ₂₁,	_inst_6 : ring_hom_inv_pair σ₂₁ σ₁₂,	_inst_25 : semi_normed_group E,	_inst_26 : semi_normed_group E₂,	_inst_29 : module R E,	_inst_30 : module R₂ E₂,	e : E ≃ₛₗᵢ[σ₁₂] E₂	⊢ range ⇑(e.to_isometric) = univ", "decl_nm": "linear_isometry_equiv.range_eq_univ"
{"src": "⊢ ∀ {𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [_inst_1 : decidable_eq ι]	  [_inst_2 : fintype ι] [_inst_5 : nondiscrete_normed_field 𝕜] [_inst_6 : Π (i : ι), normed_group (E i)]	  [_inst_7 : Π (i : ι), normed_space 𝕜 (E i)] [_inst_14 : normed_group G] [_inst_15 : normed_space 𝕜 G]	  (f : continuous_multilinear_map 𝕜 E G), ∥f∥ = 0 ↔ f = 0", "decl_nm": "continuous_multilinear_map.op_norm_zero_iff"
{"src": "𝕜 : Type u,	ι : Type v,	E : ι → Type wE,	G : Type wG,	_inst_1 : decidable_eq ι,	_inst_2 : fintype ι,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_6 : Π (i : ι), normed_group (E i),	_inst_7 : Π (i : ι), normed_space 𝕜 (E i),	_inst_14 : normed_group G,	_inst_15 : normed_space 𝕜 G,	f : continuous_multilinear_map 𝕜 E G	⊢ ∥f∥ = 0 ↔ f = 0", "decl_nm": "continuous_multilinear_map.op_norm_zero_iff"
{"src": "2 goals	𝕜 : Type u,	ι : Type v,	E : ι → Type wE,	G : Type wG,	_inst_1 : decidable_eq ι,	_inst_2 : fintype ι,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_6 : Π (i : ι), normed_group (E i),	_inst_7 : Π (i : ι), normed_space 𝕜 (E i),	_inst_14 : normed_group G,	_inst_15 : normed_space 𝕜 G,	f : continuous_multilinear_map 𝕜 E G	⊢ ∥f∥ = 0 → f = 0		𝕜 : Type u,	ι : Type v,	E : ι → Type wE,	G : Type wG,	_inst_1 : decidable_eq ι,	_inst_2 : fintype ι,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_6 : Π (i : ι), normed_group (E i),	_inst_7 : Π (i : ι), normed_space 𝕜 (E i),	_inst_14 : normed_group G,	_inst_15 : normed_space 𝕜 G,	f : continuous_multilinear_map 𝕜 E G	⊢ f = 0 → ∥f∥ = 0", "decl_nm": "continuous_multilinear_map.op_norm_zero_iff"
{"src": "2 goals	𝕜 : Type u,	ι : Type v,	E : ι → Type wE,	G : Type wG,	_inst_1 : decidable_eq ι,	_inst_2 : fintype ι,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_6 : Π (i : ι), normed_group (E i),	_inst_7 : Π (i : ι), normed_space 𝕜 (E i),	_inst_14 : normed_group G,	_inst_15 : normed_space 𝕜 G,	f : continuous_multilinear_map 𝕜 E G,	h : ∥f∥ = 0	⊢ f = 0		𝕜 : Type u,	ι : Type v,	E : ι → Type wE,	G : Type wG,	_inst_1 : decidable_eq ι,	_inst_2 : fintype ι,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_6 : Π (i : ι), normed_group (E i),	_inst_7 : Π (i : ι), normed_space 𝕜 (E i),	_inst_14 : normed_group G,	_inst_15 : normed_space 𝕜 G,	f : continuous_multilinear_map 𝕜 E G	⊢ f = 0 → ∥f∥ = 0", "decl_nm": "continuous_multilinear_map.op_norm_zero_iff"
{"src": "2 goals	𝕜 : Type u,	ι : Type v,	E : ι → Type wE,	G : Type wG,	_inst_1 : decidable_eq ι,	_inst_2 : fintype ι,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_6 : Π (i : ι), normed_group (E i),	_inst_7 : Π (i : ι), normed_space 𝕜 (E i),	_inst_14 : normed_group G,	_inst_15 : normed_space 𝕜 G,	f : continuous_multilinear_map 𝕜 E G,	h : ∥f∥ = 0,	m : Π (i : ι), E i	⊢ ⇑f m = ⇑0 m		𝕜 : Type u,	ι : Type v,	E : ι → Type wE,	G : Type wG,	_inst_1 : decidable_eq ι,	_inst_2 : fintype ι,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_6 : Π (i : ι), normed_group (E i),	_inst_7 : Π (i : ι), normed_space 𝕜 (E i),	_inst_14 : normed_group G,	_inst_15 : normed_space 𝕜 G,	f : continuous_multilinear_map 𝕜 E G	⊢ f = 0 → ∥f∥ = 0", "decl_nm": "continuous_multilinear_map.op_norm_zero_iff"
{"src": "𝕜 : Type u,	ι : Type v,	E : ι → Type wE,	G : Type wG,	_inst_1 : decidable_eq ι,	_inst_2 : fintype ι,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_6 : Π (i : ι), normed_group (E i),	_inst_7 : Π (i : ι), normed_space 𝕜 (E i),	_inst_14 : normed_group G,	_inst_15 : normed_space 𝕜 G,	f : continuous_multilinear_map 𝕜 E G	⊢ f = 0 → ∥f∥ = 0", "decl_nm": "continuous_multilinear_map.op_norm_zero_iff"
{"src": "𝕜 : Type u,	ι : Type v,	E : ι → Type wE,	G : Type wG,	_inst_1 : decidable_eq ι,	_inst_2 : fintype ι,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_6 : Π (i : ι), normed_group (E i),	_inst_7 : Π (i : ι), normed_space 𝕜 (E i),	_inst_14 : normed_group G,	_inst_15 : normed_space 𝕜 G	⊢ ∥0∥ = 0", "decl_nm": "continuous_multilinear_map.op_norm_zero_iff"
{"src": "𝕜 : Type u,	ι : Type v,	E : ι → Type wE,	G : Type wG,	_inst_1 : decidable_eq ι,	_inst_2 : fintype ι,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_6 : Π (i : ι), normed_group (E i),	_inst_7 : Π (i : ι), normed_space 𝕜 (E i),	_inst_14 : normed_group G,	_inst_15 : normed_space 𝕜 G,	m : Π (i : ι), E i	⊢ ∥⇑0 m∥ ≤ 0 * univ.prod (λ (i : ι), ∥m i∥)", "decl_nm": "continuous_multilinear_map.op_norm_zero_iff"
{"src": "⊢ ∀ {𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [_inst_1 : decidable_eq ι]	  [_inst_2 : fintype ι] [_inst_5 : nondiscrete_normed_field 𝕜] [_inst_6 : Π (i : ι), normed_group (E i)]	  [_inst_7 : Π (i : ι), normed_space 𝕜 (E i)] [_inst_14 : normed_group G] [_inst_15 : normed_space 𝕜 G]	  {α : Type u_1} {p : α → continuous_multilinear_map 𝕜 E G} {q : continuous_multilinear_map 𝕜 E G},	    has_sum p q → ∀ (m : Π (i : ι), E i), has_sum (λ (a : α), ⇑(p a) m) (⇑q m)", "decl_nm": "continuous_multilinear_map.has_sum_eval"
{"src": "𝕜 : Type u,	ι : Type v,	E : ι → Type wE,	G : Type wG,	_inst_1 : decidable_eq ι,	_inst_2 : fintype ι,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_6 : Π (i : ι), normed_group (E i),	_inst_7 : Π (i : ι), normed_space 𝕜 (E i),	_inst_14 : normed_group G,	_inst_15 : normed_space 𝕜 G,	α : Type u_1,	p : α → continuous_multilinear_map 𝕜 E G,	q : continuous_multilinear_map 𝕜 E G,	h : has_sum p q,	m : Π (i : ι), E i	⊢ has_sum (λ (a : α), ⇑(p a) m) (⇑q m)", "decl_nm": "continuous_multilinear_map.has_sum_eval"
{"src": "𝕜 : Type u,	ι : Type v,	E : ι → Type wE,	G : Type wG,	_inst_1 : decidable_eq ι,	_inst_2 : fintype ι,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_6 : Π (i : ι), normed_group (E i),	_inst_7 : Π (i : ι), normed_space 𝕜 (E i),	_inst_14 : normed_group G,	_inst_15 : normed_space 𝕜 G,	α : Type u_1,	p : α → continuous_multilinear_map 𝕜 E G,	q : continuous_multilinear_map 𝕜 E G,	m : Π (i : ι), E i,	h : filter.tendsto (λ (s : finset α), s.sum p) filter.at_top (nhds q)	⊢ filter.tendsto (λ (s : finset α), s.sum (λ (b : α), ⇑(p b) m)) filter.at_top (nhds (⇑q m))", "decl_nm": "continuous_multilinear_map.has_sum_eval"
{"src": "𝕜 : Type u,	ι : Type v,	E : ι → Type wE,	G : Type wG,	_inst_1 : decidable_eq ι,	_inst_2 : fintype ι,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_6 : Π (i : ι), normed_group (E i),	_inst_7 : Π (i : ι), normed_space 𝕜 (E i),	_inst_14 : normed_group G,	_inst_15 : normed_space 𝕜 G,	α : Type u_1,	p : α → continuous_multilinear_map 𝕜 E G,	q : continuous_multilinear_map 𝕜 E G,	m : Π (i : ι), E i,	h : filter.tendsto (λ (s : finset α), s.sum p) filter.at_top (nhds q)	⊢ (λ (s : finset α), s.sum (λ (b : α), ⇑(p b) m)) =	    (λ (p : continuous_multilinear_map 𝕜 E G), ⇑p m) ∘ λ (s : finset α), s.sum p", "decl_nm": "continuous_multilinear_map.has_sum_eval"
{"src": "𝕜 : Type u,	ι : Type v,	E : ι → Type wE,	G : Type wG,	_inst_1 : decidable_eq ι,	_inst_2 : fintype ι,	_inst_5 : nondiscrete_normed_field 𝕜,	_inst_6 : Π (i : ι), normed_group (E i),	_inst_7 : Π (i : ι), normed_space 𝕜 (E i),	_inst_14 : normed_group G,	_inst_15 : normed_space 𝕜 G,	α : Type u_1,	p : α → continuous_multilinear_map 𝕜 E G,	q : continuous_multilinear_map 𝕜 E G,	m : Π (i : ι), E i,	h : filter.tendsto (λ (s : finset α), s.sum p) filter.at_top (nhds q),	s : finset α	⊢ s.sum (λ (b : α), ⇑(p b) m) =	    ((λ (p : continuous_multilinear_map 𝕜 E G), ⇑p m) ∘ λ (s : finset α), s.sum p) s", "decl_nm": "continuous_multilinear_map.has_sum_eval"
{"src": "⊢ ∀ {𝕜 : Type u_1} [_inst_1 : normed_field 𝕜] {E : Type u_2} [_inst_2 : normed_group E]	  [_inst_3 : normed_space 𝕜 E] {c : 𝕜},	    1 < ∥c∥ →	    ∀ {R : ℝ},	      ∥c∥ < R →	      ∀ {F : subspace 𝕜 E},	        is_closed ↑F →	        (∃ (x : E), x ∉ F) → (∃ (x₀ : E), ∥x₀∥ ≤ R ∧ ∀ (y : E), y ∈ F → 1 ≤ ∥x₀ - y∥)", "decl_nm": "riesz_lemma_of_norm_lt"
{"src": "𝕜 : Type u_1,	_inst_1 : normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	c : 𝕜,	hc : 1 < ∥c∥,	R : ℝ,	hR : ∥c∥ < R,	F : subspace 𝕜 E,	hFc : is_closed ↑F,	hF : ∃ (x : E), x ∉ F	⊢ ∃ (x₀ : E), ∥x₀∥ ≤ R ∧ ∀ (y : E), y ∈ F → 1 ≤ ∥x₀ - y∥", "decl_nm": "riesz_lemma_of_norm_lt"
{"src": "𝕜 : Type u_1,	_inst_1 : normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	c : 𝕜,	hc : 1 < ∥c∥,	R : ℝ,	hR : ∥c∥ < R,	F : subspace 𝕜 E,	hFc : is_closed ↑F,	hF : ∃ (x : E), x ∉ F,	Rpos : 0 < R	⊢ ∃ (x₀ : E), ∥x₀∥ ≤ R ∧ ∀ (y : E), y ∈ F → 1 ≤ ∥x₀ - y∥", "decl_nm": "riesz_lemma_of_norm_lt"
{"src": "2 goals	𝕜 : Type u_1,	_inst_1 : normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	c : 𝕜,	hc : 1 < ∥c∥,	R : ℝ,	hR : ∥c∥ < R,	F : subspace 𝕜 E,	hFc : is_closed ↑F,	hF : ∃ (x : E), x ∉ F,	Rpos : 0 < R	⊢ ∥c∥ / R < 1		𝕜 : Type u_1,	_inst_1 : normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	c : 𝕜,	hc : 1 < ∥c∥,	R : ℝ,	hR : ∥c∥ < R,	F : subspace 𝕜 E,	hFc : is_closed ↑F,	hF : ∃ (x : E), x ∉ F,	Rpos : 0 < R,	this : ∥c∥ / R < 1	⊢ ∃ (x₀ : E), ∥x₀∥ ≤ R ∧ ∀ (y : E), y ∈ F → 1 ≤ ∥x₀ - y∥", "decl_nm": "riesz_lemma_of_norm_lt"
{"src": "2 goals	𝕜 : Type u_1,	_inst_1 : normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	c : 𝕜,	hc : 1 < ∥c∥,	R : ℝ,	hR : ∥c∥ < R,	F : subspace 𝕜 E,	hFc : is_closed ↑F,	hF : ∃ (x : E), x ∉ F,	Rpos : 0 < R	⊢ ∥c∥ < 1 * R		𝕜 : Type u_1,	_inst_1 : normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	c : 𝕜,	hc : 1 < ∥c∥,	R : ℝ,	hR : ∥c∥ < R,	F : subspace 𝕜 E,	hFc : is_closed ↑F,	hF : ∃ (x : E), x ∉ F,	Rpos : 0 < R,	this : ∥c∥ / R < 1	⊢ ∃ (x₀ : E), ∥x₀∥ ≤ R ∧ ∀ (y : E), y ∈ F → 1 ≤ ∥x₀ - y∥", "decl_nm": "riesz_lemma_of_norm_lt"
{"src": "𝕜 : Type u_1,	_inst_1 : normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	c : 𝕜,	hc : 1 < ∥c∥,	R : ℝ,	hR : ∥c∥ < R,	F : subspace 𝕜 E,	hFc : is_closed ↑F,	hF : ∃ (x : E), x ∉ F,	Rpos : 0 < R,	this : ∥c∥ / R < 1	⊢ ∃ (x₀ : E), ∥x₀∥ ≤ R ∧ ∀ (y : E), y ∈ F → 1 ≤ ∥x₀ - y∥", "decl_nm": "riesz_lemma_of_norm_lt"
{"src": "𝕜 : Type u_1,	_inst_1 : normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	c : 𝕜,	hc : 1 < ∥c∥,	R : ℝ,	hR : ∥c∥ < R,	F : subspace 𝕜 E,	hFc : is_closed ↑F,	hF : ∃ (x : E), x ∉ F,	Rpos : 0 < R,	this : ∥c∥ / R < 1,	x : E,	xF : x ∉ F,	hx : ∀ (y : E), y ∈ F → ∥c∥ / R * ∥x∥ ≤ ∥x - y∥	⊢ ∃ (x₀ : E), ∥x₀∥ ≤ R ∧ ∀ (y : E), y ∈ F → 1 ≤ ∥x₀ - y∥", "decl_nm": "riesz_lemma_of_norm_lt"
{"src": "𝕜 : Type u_1,	_inst_1 : normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	c : 𝕜,	hc : 1 < ∥c∥,	R : ℝ,	hR : ∥c∥ < R,	F : subspace 𝕜 E,	hFc : is_closed ↑F,	hF : ∃ (x : E), x ∉ F,	Rpos : 0 < R,	this : ∥c∥ / R < 1,	x : E,	xF : x ∉ F,	hx : ∀ (y : E), y ∈ F → ∥c∥ / R * ∥x∥ ≤ ∥x - y∥,	x0 : x ≠ 0	⊢ ∃ (x₀ : E), ∥x₀∥ ≤ R ∧ ∀ (y : E), y ∈ F → 1 ≤ ∥x₀ - y∥", "decl_nm": "riesz_lemma_of_norm_lt"
{"src": "𝕜 : Type u_1,	_inst_1 : normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	c : 𝕜,	hc : 1 < ∥c∥,	R : ℝ,	hR : ∥c∥ < R,	F : subspace 𝕜 E,	hFc : is_closed ↑F,	hF : ∃ (x : E), x ∉ F,	Rpos : 0 < R,	this : ∥c∥ / R < 1,	x : E,	xF : x ∉ F,	hx : ∀ (y : E), y ∈ F → ∥c∥ / R * ∥x∥ ≤ ∥x - y∥,	x0 : x ≠ 0,	d : 𝕜,	d0 : d ≠ 0,	dxlt : ∥d • x∥ < R,	ledx : R / ∥c∥ ≤ ∥d • x∥	⊢ ∃ (x₀ : E), ∥x₀∥ ≤ R ∧ ∀ (y : E), y ∈ F → 1 ≤ ∥x₀ - y∥", "decl_nm": "riesz_lemma_of_norm_lt"
{"src": "𝕜 : Type u_1,	_inst_1 : normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	c : 𝕜,	hc : 1 < ∥c∥,	R : ℝ,	hR : ∥c∥ < R,	F : subspace 𝕜 E,	hFc : is_closed ↑F,	hF : ∃ (x : E), x ∉ F,	Rpos : 0 < R,	this : ∥c∥ / R < 1,	x : E,	xF : x ∉ F,	hx : ∀ (y : E), y ∈ F → ∥c∥ / R * ∥x∥ ≤ ∥x - y∥,	x0 : x ≠ 0,	d : 𝕜,	d0 : d ≠ 0,	dxlt : ∥d • x∥ < R,	ledx : R / ∥c∥ ≤ ∥d • x∥,	y : E,	hy : y ∈ F	⊢ 1 ≤ ∥d • x - y∥", "decl_nm": "riesz_lemma_of_norm_lt"
{"src": "𝕜 : Type u_1,	_inst_1 : normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	c : 𝕜,	hc : 1 < ∥c∥,	R : ℝ,	hR : ∥c∥ < R,	F : subspace 𝕜 E,	hFc : is_closed ↑F,	hF : ∃ (x : E), x ∉ F,	Rpos : 0 < R,	this : ∥c∥ / R < 1,	x : E,	xF : x ∉ F,	hx : ∀ (y : E), y ∈ F → ∥c∥ / R * ∥x∥ ≤ ∥x - y∥,	x0 : x ≠ 0,	d : 𝕜,	d0 : d ≠ 0,	dxlt : ∥d • x∥ < R,	ledx : R / ∥c∥ ≤ ∥d • x∥,	y : E,	hy : y ∈ F,	y' : E := d⁻¹ • y,	hy' : y' = d⁻¹ • y	⊢ 1 ≤ ∥d • x - y∥", "decl_nm": "riesz_lemma_of_norm_lt"
{"src": "2 goals	𝕜 : Type u_1,	_inst_1 : normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	c : 𝕜,	hc : 1 < ∥c∥,	R : ℝ,	hR : ∥c∥ < R,	F : subspace 𝕜 E,	hFc : is_closed ↑F,	hF : ∃ (x : E), x ∉ F,	Rpos : 0 < R,	this : ∥c∥ / R < 1,	x : E,	xF : x ∉ F,	hx : ∀ (y : E), y ∈ F → ∥c∥ / R * ∥x∥ ≤ ∥x - y∥,	x0 : x ≠ 0,	d : 𝕜,	d0 : d ≠ 0,	dxlt : ∥d • x∥ < R,	ledx : R / ∥c∥ ≤ ∥d • x∥,	y : E,	hy : y ∈ F,	y' : E := d⁻¹ • y,	hy' : y' = d⁻¹ • y	⊢ y' ∈ F		𝕜 : Type u_1,	_inst_1 : normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	c : 𝕜,	hc : 1 < ∥c∥,	R : ℝ,	hR : ∥c∥ < R,	F : subspace 𝕜 E,	hFc : is_closed ↑F,	hF : ∃ (x : E), x ∉ F,	Rpos : 0 < R,	this : ∥c∥ / R < 1,	x : E,	xF : x ∉ F,	hx : ∀ (y : E), y ∈ F → ∥c∥ / R * ∥x∥ ≤ ∥x - y∥,	x0 : x ≠ 0,	d : 𝕜,	d0 : d ≠ 0,	dxlt : ∥d • x∥ < R,	ledx : R / ∥c∥ ≤ ∥d • x∥,	y : E,	hy : y ∈ F,	y' : E := d⁻¹ • y,	hy' : y' = d⁻¹ • y,	y'F : y' ∈ F	⊢ 1 ≤ ∥d • x - y∥", "decl_nm": "riesz_lemma_of_norm_lt"
{"src": "𝕜 : Type u_1,	_inst_1 : normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	c : 𝕜,	hc : 1 < ∥c∥,	R : ℝ,	hR : ∥c∥ < R,	F : subspace 𝕜 E,	hFc : is_closed ↑F,	hF : ∃ (x : E), x ∉ F,	Rpos : 0 < R,	this : ∥c∥ / R < 1,	x : E,	xF : x ∉ F,	hx : ∀ (y : E), y ∈ F → ∥c∥ / R * ∥x∥ ≤ ∥x - y∥,	x0 : x ≠ 0,	d : 𝕜,	d0 : d ≠ 0,	dxlt : ∥d • x∥ < R,	ledx : R / ∥c∥ ≤ ∥d • x∥,	y : E,	hy : y ∈ F,	y' : E := d⁻¹ • y,	hy' : y' = d⁻¹ • y,	y'F : y' ∈ F	⊢ 1 ≤ ∥d • x - y∥", "decl_nm": "riesz_lemma_of_norm_lt"
{"src": "2 goals	𝕜 : Type u_1,	_inst_1 : normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	c : 𝕜,	hc : 1 < ∥c∥,	R : ℝ,	hR : ∥c∥ < R,	F : subspace 𝕜 E,	hFc : is_closed ↑F,	hF : ∃ (x : E), x ∉ F,	Rpos : 0 < R,	this : ∥c∥ / R < 1,	x : E,	xF : x ∉ F,	hx : ∀ (y : E), y ∈ F → ∥c∥ / R * ∥x∥ ≤ ∥x - y∥,	x0 : x ≠ 0,	d : 𝕜,	d0 : d ≠ 0,	dxlt : ∥d • x∥ < R,	ledx : R / ∥c∥ ≤ ∥d • x∥,	y : E,	hy : y ∈ F,	y' : E := d⁻¹ • y,	hy' : y' = d⁻¹ • y,	y'F : y' ∈ F	⊢ y = d • y'		𝕜 : Type u_1,	_inst_1 : normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	c : 𝕜,	hc : 1 < ∥c∥,	R : ℝ,	hR : ∥c∥ < R,	F : subspace 𝕜 E,	hFc : is_closed ↑F,	hF : ∃ (x : E), x ∉ F,	Rpos : 0 < R,	this : ∥c∥ / R < 1,	x : E,	xF : x ∉ F,	hx : ∀ (y : E), y ∈ F → ∥c∥ / R * ∥x∥ ≤ ∥x - y∥,	x0 : x ≠ 0,	d : 𝕜,	d0 : d ≠ 0,	dxlt : ∥d • x∥ < R,	ledx : R / ∥c∥ ≤ ∥d • x∥,	y : E,	hy : y ∈ F,	y' : E := d⁻¹ • y,	hy' : y' = d⁻¹ • y,	y'F : y' ∈ F,	yy' : y = d • y'	⊢ 1 ≤ ∥d • x - y∥", "decl_nm": "riesz_lemma_of_norm_lt"
{"src": "𝕜 : Type u_1,	_inst_1 : normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	c : 𝕜,	hc : 1 < ∥c∥,	R : ℝ,	hR : ∥c∥ < R,	F : subspace 𝕜 E,	hFc : is_closed ↑F,	hF : ∃ (x : E), x ∉ F,	Rpos : 0 < R,	this : ∥c∥ / R < 1,	x : E,	xF : x ∉ F,	hx : ∀ (y : E), y ∈ F → ∥c∥ / R * ∥x∥ ≤ ∥x - y∥,	x0 : x ≠ 0,	d : 𝕜,	d0 : d ≠ 0,	dxlt : ∥d • x∥ < R,	ledx : R / ∥c∥ ≤ ∥d • x∥,	y : E,	hy : y ∈ F,	y' : E := d⁻¹ • y,	hy' : y' = d⁻¹ • y,	y'F : y' ∈ F,	yy' : y = d • y'	⊢ 1 ≤ ∥d • x - y∥", "decl_nm": "riesz_lemma_of_norm_lt"
{"src": "⊢ ∀ {M : Type u_1} [_inst_1 : ordered_add_comm_monoid M] {f : ℕ → M},	    (∀ ⦃m n : ℕ⦄, 1 < m → m ≤ n → f n ≤ f m) →	    ∀ (n : ℕ),	      (range (n + 1)).sum (λ (k : ℕ), 2 ^ k • f (2 ^ k)) ≤	        f 1 + 2 • (Ico 2 (2 ^ n + 1)).sum (λ (k : ℕ), f k)", "decl_nm": "finset.sum_condensed_le"
{"src": "M : Type u_1,	_inst_1 : ordered_add_comm_monoid M,	f : ℕ → M,	hf : ∀ ⦃m n : ℕ⦄, 1 < m → m ≤ n → f n ≤ f m,	n : ℕ	⊢ (range (n + 1)).sum (λ (k : ℕ), 2 ^ k • f (2 ^ k)) ≤ f 1 + 2 • (Ico 2 (2 ^ n + 1)).sum (λ (k : ℕ), f k)", "decl_nm": "finset.sum_condensed_le"
{"src": "M : Type u_1,	_inst_1 : ordered_add_comm_monoid M,	f : ℕ → M,	hf : ∀ ⦃m n : ℕ⦄, 1 < m → m ≤ n → f n ≤ f m,	n : ℕ	⊢ (range (n + 1)).sum (λ (k : ℕ), 2 ^ k • f (2 ^ k)) =	    f 1 + 2 • (range n).sum (λ (k : ℕ), 2 ^ k • f (2 ^ (k + 1)))", "decl_nm": "finset.sum_condensed_le"
{"src": "⊢ ∀ {x : ℝ}, 0 ≤ x → ↑x.arg = 0", "decl_nm": "complex.arg_of_real_of_nonneg"
{"src": "x : ℝ,	hx : 0 ≤ x	⊢ ↑x.arg = 0", "decl_nm": "complex.arg_of_real_of_nonneg"
{"src": "⊢ ∀ {x y : ℝ}, 0 < x → 0 < y → (log x < log y ↔ x < y)", "decl_nm": "real.log_lt_log_iff"
{"src": "x y : ℝ,	hx : 0 < x,	hy : 0 < y	⊢ log x < log y ↔ x < y", "decl_nm": "real.log_lt_log_iff"
{"src": "⊢ ∀ {x : ℝ}, 0 < x → (0 < log x ↔ 1 < x)", "decl_nm": "real.log_pos_iff"
{"src": "x : ℝ,	hx : 0 < x	⊢ 0 < log x ↔ 1 < x", "decl_nm": "real.log_pos_iff"
{"src": "x : ℝ,	hx : 0 < x	⊢ log 1 < log x ↔ 1 < x", "decl_nm": "real.log_pos_iff"
{"src": "⊢ ∀ {a b : ℝ}, ∫ (x : ℝ) in a..b, exp x = exp b - exp a", "decl_nm": "integral_exp"
{"src": "a b : ℝ	⊢ ∫ (x : ℝ) in a..b, exp x = exp b - exp a", "decl_nm": "integral_exp"
{"src": "3 goals	a b : ℝ	⊢ deriv (λ {b : ℝ}, exp b) = λ (y : ℝ), exp y		a b : ℝ	⊢ ∀ (x : ℝ), x ∈ interval a b → differentiable_at ℝ (λ {b : ℝ}, exp b) x		a b : ℝ	⊢ continuous_on (λ (y : ℝ), exp y) (interval a b)", "decl_nm": "integral_exp"
{"src": "2 goals	a b : ℝ	⊢ ∀ (x : ℝ), x ∈ interval a b → differentiable_at ℝ (λ {b : ℝ}, exp b) x		a b : ℝ	⊢ continuous_on (λ (y : ℝ), exp y) (interval a b)", "decl_nm": "integral_exp"
{"src": "a b : ℝ	⊢ continuous_on (λ (y : ℝ), exp y) (interval a b)", "decl_nm": "integral_exp"
{"src": "⊢ ∀ {a b : ℝ}, ∫ (x : ℝ) in a..b, sin x ^ 2 * cos x ^ 2 = (b - a) / 8 - (sin (4 * b) - sin (4 * a)) / 32", "decl_nm": "integral_sin_sq_mul_cos_sq"
{"src": "a b : ℝ	⊢ ∫ (x : ℝ) in a..b, sin x ^ 2 * cos x ^ 2 = (b - a) / 8 - (sin (4 * b) - sin (4 * a)) / 32", "decl_nm": "integral_sin_sq_mul_cos_sq"
{"src": "a b : ℝ	⊢ (b - a) / 8 - (sin (4 * b) - sin (4 * a)) / 32 =	    ∫ (x : ℝ) in a..b, ((1 - cos (2 * x)) / 2) ^ 1 * ((1 + cos (2 * x)) / 2) ^ 1", "decl_nm": "integral_sin_sq_mul_cos_sq"
{"src": "a b : ℝ,	h1 : ∀ (c : ℝ), (1 - c) / 2 * ((1 + c) / 2) = (1 - c ^ 2) / 4	⊢ (b - a) / 8 - (sin (4 * b) - sin (4 * a)) / 32 =	    ∫ (x : ℝ) in a..b, ((1 - cos (2 * x)) / 2) ^ 1 * ((1 + cos (2 * x)) / 2) ^ 1", "decl_nm": "integral_sin_sq_mul_cos_sq"
{"src": "a b : ℝ,	h1 : ∀ (c : ℝ), (1 - c) / 2 * ((1 + c) / 2) = (1 - c ^ 2) / 4,	h2 : continuous (λ (x : ℝ), cos (2 * x) ^ 2)	⊢ (b - a) / 8 - (sin (4 * b) - sin (4 * a)) / 32 =	    ∫ (x : ℝ) in a..b, ((1 - cos (2 * x)) / 2) ^ 1 * ((1 + cos (2 * x)) / 2) ^ 1", "decl_nm": "integral_sin_sq_mul_cos_sq"
{"src": "2 goals	a b : ℝ,	h1 : ∀ (c : ℝ), (1 - c) / 2 * ((1 + c) / 2) = (1 - c ^ 2) / 4,	h2 : continuous (λ (x : ℝ), cos (2 * x) ^ 2)	⊢ ∀ (x : ℝ), cos x * sin x = sin (2 * x) / 2		a b : ℝ,	h1 : ∀ (c : ℝ), (1 - c) / 2 * ((1 + c) / 2) = (1 - c ^ 2) / 4,	h2 : continuous (λ (x : ℝ), cos (2 * x) ^ 2),	h3 : ∀ (x : ℝ), cos x * sin x = sin (2 * x) / 2	⊢ (b - a) / 8 - (sin (4 * b) - sin (4 * a)) / 32 =	    ∫ (x : ℝ) in a..b, ((1 - cos (2 * x)) / 2) ^ 1 * ((1 + cos (2 * x)) / 2) ^ 1", "decl_nm": "integral_sin_sq_mul_cos_sq"
{"src": "2 goals	a b : ℝ,	h1 : ∀ (c : ℝ), (1 - c) / 2 * ((1 + c) / 2) = (1 - c ^ 2) / 4,	h2 : continuous (λ (x : ℝ), cos (2 * x) ^ 2),	x : ℝ	⊢ cos x * sin x = sin (2 * x) / 2		a b : ℝ,	h1 : ∀ (c : ℝ), (1 - c) / 2 * ((1 + c) / 2) = (1 - c ^ 2) / 4,	h2 : continuous (λ (x : ℝ), cos (2 * x) ^ 2),	h3 : ∀ (x : ℝ), cos x * sin x = sin (2 * x) / 2	⊢ (b - a) / 8 - (sin (4 * b) - sin (4 * a)) / 32 =	    ∫ (x : ℝ) in a..b, ((1 - cos (2 * x)) / 2) ^ 1 * ((1 + cos (2 * x)) / 2) ^ 1", "decl_nm": "integral_sin_sq_mul_cos_sq"
{"src": "2 goals	a b : ℝ,	h1 : ∀ (c : ℝ), (1 - c) / 2 * ((1 + c) / 2) = (1 - c ^ 2) / 4,	h2 : continuous (λ (x : ℝ), cos (2 * x) ^ 2),	x : ℝ	⊢ cos x * sin x = 2 * sin x * cos x / 2		a b : ℝ,	h1 : ∀ (c : ℝ), (1 - c) / 2 * ((1 + c) / 2) = (1 - c ^ 2) / 4,	h2 : continuous (λ (x : ℝ), cos (2 * x) ^ 2),	h3 : ∀ (x : ℝ), cos x * sin x = sin (2 * x) / 2	⊢ (b - a) / 8 - (sin (4 * b) - sin (4 * a)) / 32 =	    ∫ (x : ℝ) in a..b, ((1 - cos (2 * x)) / 2) ^ 1 * ((1 + cos (2 * x)) / 2) ^ 1", "decl_nm": "integral_sin_sq_mul_cos_sq"
{"src": "a b : ℝ,	h1 : ∀ (c : ℝ), (1 - c) / 2 * ((1 + c) / 2) = (1 - c ^ 2) / 4,	h2 : continuous (λ (x : ℝ), cos (2 * x) ^ 2),	h3 : ∀ (x : ℝ), cos x * sin x = sin (2 * x) / 2	⊢ (b - a) / 8 - (sin (4 * b) - sin (4 * a)) / 32 =	    ∫ (x : ℝ) in a..b, ((1 - cos (2 * x)) / 2) ^ 1 * ((1 + cos (2 * x)) / 2) ^ 1", "decl_nm": "integral_sin_sq_mul_cos_sq"
{"src": "a b : ℝ,	h1 : ∀ (c : ℝ), (1 - c) / 2 * ((1 + c) / 2) = (1 - c ^ 2) / 4,	h2 : continuous (λ (x : ℝ), cos (2 * x) ^ 2),	h3 : ∀ (x : ℝ), cos x * sin x = sin (2 * x) / 2,	h4 : ∀ (d : ℝ), 2 * (2 * d) = 4 * d	⊢ (b - a) / 8 - (sin (4 * b) - sin (4 * a)) / 32 =	    ∫ (x : ℝ) in a..b, ((1 - cos (2 * x)) / 2) ^ 1 * ((1 + cos (2 * x)) / 2) ^ 1", "decl_nm": "integral_sin_sq_mul_cos_sq"
{"src": "a b : ℝ,	h1 : ∀ (c : ℝ), (1 - c) / 2 * ((1 + c) / 2) = (1 - c ^ 2) / 4,	h2 : continuous (λ (x : ℝ), cos (2 * x) ^ 2),	h3 : ∀ (x : ℝ), cos x * sin x = sin (2 * x) / 2,	h4 : ∀ (d : ℝ), 2 * (2 * d) = 4 * d	⊢ (b - a) / 8 - (sin (4 * b) - sin (4 * a)) / 32 =	    (b - a - 2⁻¹ * ((sin (4 * b) / 2 - sin (4 * a) / 2 + 2 * b - 2 * a) / 2)) / 4", "decl_nm": "integral_sin_sq_mul_cos_sq"
{"src": "⊢ ∀ (x : ennreal) (z : ℝ), x.to_nnreal ^ z = (x ^ z).to_nnreal", "decl_nm": "ennreal.to_nnreal_rpow"
{"src": "x : ennreal,	z : ℝ	⊢ x.to_nnreal ^ z = (x ^ z).to_nnreal", "decl_nm": "ennreal.to_nnreal_rpow"
{"src": "3 goals	x : ennreal,	z : ℝ,	H : z < 0	⊢ x.to_nnreal ^ z = (x ^ z).to_nnreal		x : ennreal,	z : ℝ,	H : z = 0	⊢ x.to_nnreal ^ z = (x ^ z).to_nnreal		x : ennreal,	z : ℝ,	H : 0 < z	⊢ x.to_nnreal ^ z = (x ^ z).to_nnreal", "decl_nm": "ennreal.to_nnreal_rpow"
{"src": "4 goals	case option.none	z : ℝ,	H : z < 0	⊢ ennreal.to_nnreal none ^ z = (none ^ z).to_nnreal		case option.some	z : ℝ,	H : z < 0,	x : nnreal	⊢ ennreal.to_nnreal (some x) ^ z = (some x ^ z).to_nnreal		x : ennreal,	z : ℝ,	H : z = 0	⊢ x.to_nnreal ^ z = (x ^ z).to_nnreal		x : ennreal,	z : ℝ,	H : 0 < z	⊢ x.to_nnreal ^ z = (x ^ z).to_nnreal", "decl_nm": "ennreal.to_nnreal_rpow"
{"src": "3 goals	case option.some	z : ℝ,	H : z < 0,	x : nnreal	⊢ ennreal.to_nnreal (some x) ^ z = (some x ^ z).to_nnreal		x : ennreal,	z : ℝ,	H : z = 0	⊢ x.to_nnreal ^ z = (x ^ z).to_nnreal		x : ennreal,	z : ℝ,	H : 0 < z	⊢ x.to_nnreal ^ z = (x ^ z).to_nnreal", "decl_nm": "ennreal.to_nnreal_rpow"
{"src": "4 goals	z : ℝ,	H : z < 0,	x : nnreal,	hx : x = 0	⊢ ennreal.to_nnreal (some x) ^ z = (some x ^ z).to_nnreal		z : ℝ,	H : z < 0,	x : nnreal,	hx : ¬x = 0	⊢ ennreal.to_nnreal (some x) ^ z = (some x ^ z).to_nnreal		x : ennreal,	z : ℝ,	H : z = 0	⊢ x.to_nnreal ^ z = (x ^ z).to_nnreal		x : ennreal,	z : ℝ,	H : 0 < z	⊢ x.to_nnreal ^ z = (x ^ z).to_nnreal", "decl_nm": "ennreal.to_nnreal_rpow"
{"src": "3 goals	z : ℝ,	H : z < 0,	x : nnreal,	hx : ¬x = 0	⊢ ennreal.to_nnreal (some x) ^ z = (some x ^ z).to_nnreal		x : ennreal,	z : ℝ,	H : z = 0	⊢ x.to_nnreal ^ z = (x ^ z).to_nnreal		x : ennreal,	z : ℝ,	H : 0 < z	⊢ x.to_nnreal ^ z = (x ^ z).to_nnreal", "decl_nm": "ennreal.to_nnreal_rpow"
{"src": "2 goals	x : ennreal,	z : ℝ,	H : z = 0	⊢ x.to_nnreal ^ z = (x ^ z).to_nnreal		x : ennreal,	z : ℝ,	H : 0 < z	⊢ x.to_nnreal ^ z = (x ^ z).to_nnreal", "decl_nm": "ennreal.to_nnreal_rpow"
{"src": "x : ennreal,	z : ℝ,	H : 0 < z	⊢ x.to_nnreal ^ z = (x ^ z).to_nnreal", "decl_nm": "ennreal.to_nnreal_rpow"
{"src": "2 goals	case option.none	z : ℝ,	H : 0 < z	⊢ ennreal.to_nnreal none ^ z = (none ^ z).to_nnreal		case option.some	z : ℝ,	H : 0 < z,	x : nnreal	⊢ ennreal.to_nnreal (some x) ^ z = (some x ^ z).to_nnreal", "decl_nm": "ennreal.to_nnreal_rpow"
{"src": "case option.some	z : ℝ,	H : 0 < z,	x : nnreal	⊢ ennreal.to_nnreal (some x) ^ z = (some x ^ z).to_nnreal", "decl_nm": "ennreal.to_nnreal_rpow"
{"src": "⊢ ∀ {x : ℝ}, 0 ≤ x → ∀ (y : ℝ), x ^ y = ite (x = 0) (ite (y = 0) 1 0) (exp (log x * y))", "decl_nm": "real.rpow_def_of_nonneg"
{"src": "x : ℝ,	hx : 0 ≤ x,	y : ℝ	⊢ x ^ y = ite (x = 0) (ite (y = 0) 1 0) (exp (log x * y))", "decl_nm": "real.rpow_def_of_nonneg"
{"src": "x : ℝ,	hx : 0 ≤ x,	y : ℝ	⊢ (ite (↑x = 0) (ite (↑y = 0) 1 0) (exp (log ↑x * ↑y))).re = ite (x = 0) (ite (y = 0) 1 0) (exp (log x * y))", "decl_nm": "real.rpow_def_of_nonneg"
{"src": "9 goals	x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ↑x = 0,	h_1 : ↑y = 0,	h_2 : x = 0,	h_3 : y = 0	⊢ 1.re = 1		x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ↑x = 0,	h_1 : ↑y = 0,	h_2 : x = 0,	h_3 : ¬y = 0	⊢ 1.re = 0		x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ↑x = 0,	h_1 : ↑y = 0,	h_2 : ¬x = 0	⊢ 1.re = exp (log x * y)		x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ↑x = 0,	h_1 : ¬↑y = 0,	h_2 : x = 0,	h_3 : y = 0	⊢ 0.re = 1		x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ↑x = 0,	h_1 : ¬↑y = 0,	h_2 : x = 0,	h_3 : ¬y = 0	⊢ 0.re = 0		x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ↑x = 0,	h_1 : ¬↑y = 0,	h_2 : ¬x = 0	⊢ 0.re = exp (log x * y)		x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ¬↑x = 0,	h_1 : x = 0,	h_2 : y = 0	⊢ (exp (log ↑x * ↑y)).re = 1		x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ¬↑x = 0,	h_1 : x = 0,	h_2 : ¬y = 0	⊢ (exp (log ↑x * ↑y)).re = 0		x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ¬↑x = 0,	h_1 : ¬x = 0	⊢ (exp (log ↑x * ↑y)).re = exp (log x * y)", "decl_nm": "real.rpow_def_of_nonneg"
{"src": "8 goals	x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ↑x = 0,	h_1 : ↑y = 0,	h_2 : x = 0,	h_3 : ¬y = 0	⊢ 1.re = 0		x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ↑x = 0,	h_1 : ↑y = 0,	h_2 : ¬x = 0	⊢ 1.re = exp (log x * y)		x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ↑x = 0,	h_1 : ¬↑y = 0,	h_2 : x = 0,	h_3 : y = 0	⊢ 0.re = 1		x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ↑x = 0,	h_1 : ¬↑y = 0,	h_2 : x = 0,	h_3 : ¬y = 0	⊢ 0.re = 0		x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ↑x = 0,	h_1 : ¬↑y = 0,	h_2 : ¬x = 0	⊢ 0.re = exp (log x * y)		x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ¬↑x = 0,	h_1 : x = 0,	h_2 : y = 0	⊢ (exp (log ↑x * ↑y)).re = 1		x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ¬↑x = 0,	h_1 : x = 0,	h_2 : ¬y = 0	⊢ (exp (log ↑x * ↑y)).re = 0		x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ¬↑x = 0,	h_1 : ¬x = 0	⊢ (exp (log ↑x * ↑y)).re = exp (log x * y)", "decl_nm": "real.rpow_def_of_nonneg"
{"src": "7 goals	x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ↑x = 0,	h_1 : ↑y = 0,	h_2 : ¬x = 0	⊢ 1.re = exp (log x * y)		x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ↑x = 0,	h_1 : ¬↑y = 0,	h_2 : x = 0,	h_3 : y = 0	⊢ 0.re = 1		x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ↑x = 0,	h_1 : ¬↑y = 0,	h_2 : x = 0,	h_3 : ¬y = 0	⊢ 0.re = 0		x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ↑x = 0,	h_1 : ¬↑y = 0,	h_2 : ¬x = 0	⊢ 0.re = exp (log x * y)		x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ¬↑x = 0,	h_1 : x = 0,	h_2 : y = 0	⊢ (exp (log ↑x * ↑y)).re = 1		x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ¬↑x = 0,	h_1 : x = 0,	h_2 : ¬y = 0	⊢ (exp (log ↑x * ↑y)).re = 0		x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ¬↑x = 0,	h_1 : ¬x = 0	⊢ (exp (log ↑x * ↑y)).re = exp (log x * y)", "decl_nm": "real.rpow_def_of_nonneg"
{"src": "6 goals	x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ↑x = 0,	h_1 : ¬↑y = 0,	h_2 : x = 0,	h_3 : y = 0	⊢ 0.re = 1		x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ↑x = 0,	h_1 : ¬↑y = 0,	h_2 : x = 0,	h_3 : ¬y = 0	⊢ 0.re = 0		x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ↑x = 0,	h_1 : ¬↑y = 0,	h_2 : ¬x = 0	⊢ 0.re = exp (log x * y)		x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ¬↑x = 0,	h_1 : x = 0,	h_2 : y = 0	⊢ (exp (log ↑x * ↑y)).re = 1		x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ¬↑x = 0,	h_1 : x = 0,	h_2 : ¬y = 0	⊢ (exp (log ↑x * ↑y)).re = 0		x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ¬↑x = 0,	h_1 : ¬x = 0	⊢ (exp (log ↑x * ↑y)).re = exp (log x * y)", "decl_nm": "real.rpow_def_of_nonneg"
{"src": "5 goals	x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ↑x = 0,	h_1 : ¬↑y = 0,	h_2 : x = 0,	h_3 : ¬y = 0	⊢ 0.re = 0		x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ↑x = 0,	h_1 : ¬↑y = 0,	h_2 : ¬x = 0	⊢ 0.re = exp (log x * y)		x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ¬↑x = 0,	h_1 : x = 0,	h_2 : y = 0	⊢ (exp (log ↑x * ↑y)).re = 1		x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ¬↑x = 0,	h_1 : x = 0,	h_2 : ¬y = 0	⊢ (exp (log ↑x * ↑y)).re = 0		x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ¬↑x = 0,	h_1 : ¬x = 0	⊢ (exp (log ↑x * ↑y)).re = exp (log x * y)", "decl_nm": "real.rpow_def_of_nonneg"
{"src": "4 goals	x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ↑x = 0,	h_1 : ¬↑y = 0,	h_2 : ¬x = 0	⊢ 0.re = exp (log x * y)		x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ¬↑x = 0,	h_1 : x = 0,	h_2 : y = 0	⊢ (exp (log ↑x * ↑y)).re = 1		x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ¬↑x = 0,	h_1 : x = 0,	h_2 : ¬y = 0	⊢ (exp (log ↑x * ↑y)).re = 0		x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ¬↑x = 0,	h_1 : ¬x = 0	⊢ (exp (log ↑x * ↑y)).re = exp (log x * y)", "decl_nm": "real.rpow_def_of_nonneg"
{"src": "3 goals	x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ¬↑x = 0,	h_1 : x = 0,	h_2 : y = 0	⊢ (exp (log ↑x * ↑y)).re = 1		x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ¬↑x = 0,	h_1 : x = 0,	h_2 : ¬y = 0	⊢ (exp (log ↑x * ↑y)).re = 0		x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ¬↑x = 0,	h_1 : ¬x = 0	⊢ (exp (log ↑x * ↑y)).re = exp (log x * y)", "decl_nm": "real.rpow_def_of_nonneg"
{"src": "2 goals	x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ¬↑x = 0,	h_1 : x = 0,	h_2 : ¬y = 0	⊢ (exp (log ↑x * ↑y)).re = 0		x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ¬↑x = 0,	h_1 : ¬x = 0	⊢ (exp (log ↑x * ↑y)).re = exp (log x * y)", "decl_nm": "real.rpow_def_of_nonneg"
{"src": "x : ℝ,	hx : 0 ≤ x,	y : ℝ,	h : ¬↑x = 0,	h_1 : ¬x = 0	⊢ (exp (log ↑x * ↑y)).re = exp (log x * y)", "decl_nm": "real.rpow_def_of_nonneg"
{"src": "⊢ ∀ {x : ℝ}, 0 ≤ x → ∀ (y z : ℝ), x ^ (y * z) = (x ^ y) ^ z", "decl_nm": "real.rpow_mul"
{"src": "x : ℝ,	hx : 0 ≤ x,	y z : ℝ	⊢ x ^ (y * z) = (x ^ y) ^ z", "decl_nm": "real.rpow_mul"
{"src": "2 goals	x : ℝ,	hx : 0 ≤ x,	y z : ℝ	⊢ -real.pi < (log ↑x * ↑y).im		x : ℝ,	hx : 0 ≤ x,	y z : ℝ	⊢ (log ↑x * ↑y).im ≤ real.pi", "decl_nm": "real.rpow_mul"
{"src": "x : ℝ,	hx : 0 ≤ x,	y z : ℝ	⊢ (log ↑x * ↑y).im ≤ real.pi", "decl_nm": "real.rpow_mul"
{"src": "⊢ ∀ {x y z : ℝ}, 1 ≤ x → y ≤ z → x ^ y ≤ x ^ z", "decl_nm": "real.rpow_le_rpow_of_exponent_le"
{"src": "x y z : ℝ,	hx : 1 ≤ x,	hyz : y ≤ z	⊢ x ^ y ≤ x ^ z", "decl_nm": "real.rpow_le_rpow_of_exponent_le"
{"src": "x y z : ℝ,	hx : 1 ≤ x,	hyz : y ≤ z	⊢ exp (log x * y) ≤ x ^ z", "decl_nm": "real.rpow_le_rpow_of_exponent_le"
{"src": "x y z : ℝ,	hx : 1 ≤ x,	hyz : y ≤ z	⊢ exp (log x * y) ≤ exp (log x * z)", "decl_nm": "real.rpow_le_rpow_of_exponent_le"
{"src": "x y z : ℝ,	hx : 1 ≤ x,	hyz : y ≤ z	⊢ log x * y ≤ log x * z", "decl_nm": "real.rpow_le_rpow_of_exponent_le"
{"src": "⊢ ∀ (n : ℕ), cos (↑n * (2 * real.pi) - real.pi) = -1", "decl_nm": "real.cos_nat_mul_two_pi_sub_pi"
{"src": "n : ℕ	⊢ cos (↑n * (2 * real.pi) - real.pi) = -1", "decl_nm": "real.cos_nat_mul_two_pi_sub_pi"
{"src": "⊢ cos (real.pi / 2) = 0", "decl_nm": "real.cos_pi_div_two"
{"src": "⊢ cos (classical.some exists_cos_eq_zero) = 0", "decl_nm": "real.cos_pi_div_two"
{"src": "⊢ ∀ {x : ℝ}, arccos x = real.pi / 2 ↔ x = 0", "decl_nm": "real.arccos_eq_pi_div_two"
{"src": "x : ℝ	⊢ arccos x = real.pi / 2 ↔ x = 0", "decl_nm": "real.arccos_eq_pi_div_two"
{"src": "⊢ ∀ {α : Type u_1} [_inst_1 : pseudo_metric_space α] (C : ℝ) {f : ℕ → α},	    (∀ (n : ℕ), dist (f n) (f (n + 1)) ≤ C / 2 / 2 ^ n) →	    ∀ {a : α}, tendsto f at_top (nhds a) → ∀ (n : ℕ), dist (f n) a ≤ C / 2 ^ n", "decl_nm": "dist_le_of_le_geometric_two_of_tendsto"
{"src": "α : Type u_1,	_inst_1 : pseudo_metric_space α,	C : ℝ,	f : ℕ → α,	hu₂ : ∀ (n : ℕ), dist (f n) (f (n + 1)) ≤ C / 2 / 2 ^ n,	a : α,	ha : tendsto f at_top (nhds a),	n : ℕ	⊢ dist (f n) a ≤ C / 2 ^ n", "decl_nm": "dist_le_of_le_geometric_two_of_tendsto"
{"src": "α : Type u_1,	_inst_1 : pseudo_metric_space α,	C : ℝ,	f : ℕ → α,	hu₂ : ∀ (n : ℕ), dist (f n) (f (n + 1)) ≤ C / 2 / 2 ^ n,	a : α,	ha : tendsto f at_top (nhds a),	n : ℕ	⊢ C / 2 ^ n = ∑' (m : ℕ), C / 2 / 2 ^ (n + m)", "decl_nm": "dist_le_of_le_geometric_two_of_tendsto"
{"src": "α : Type u_1,	_inst_1 : pseudo_metric_space α,	C : ℝ,	f : ℕ → α,	hu₂ : ∀ (n : ℕ), dist (f n) (f (n + 1)) ≤ C / 2 / 2 ^ n,	a : α,	ha : tendsto f at_top (nhds a),	n : ℕ	⊢ C / 2 ^ n = ∑' (m : ℕ), C / 2 / 2 ^ m / 2 ^ n", "decl_nm": "dist_le_of_le_geometric_two_of_tendsto"
{"src": "α : Type u_1,	_inst_1 : pseudo_metric_space α,	C : ℝ,	f : ℕ → α,	hu₂ : ∀ (n : ℕ), dist (f n) (f (n + 1)) ≤ C / 2 / 2 ^ n,	a : α,	ha : tendsto f at_top (nhds a),	n : ℕ	⊢ ∑' (m : ℕ), C / 2 / 2 ^ m / 2 ^ n = C / 2 ^ n", "decl_nm": "dist_le_of_le_geometric_two_of_tendsto"
{"src": "⊢ ∀ {C : Type u} [_inst_1 : category C] [_inst_2 : non_preadditive_abelian C] {X Y : C} (a b c d : X ⟶ Y),	    a - c - (b - d) = a - b - (c - d)", "decl_nm": "category_theory.non_preadditive_abelian.sub_sub_sub"
{"src": "C : Type u,	_inst_1 : category C,	_inst_2 : non_preadditive_abelian C,	X Y : C,	a b c d : X ⟶ Y	⊢ a - c - (b - d) = a - b - (c - d)", "decl_nm": "category_theory.non_preadditive_abelian.sub_sub_sub"
{"src": "C : Type u,	_inst_1 : category C,	_inst_2 : non_preadditive_abelian C,	X Y : C,	a b c d : X ⟶ Y	⊢ prod.lift (prod.lift a b ≫ non_preadditive_abelian.σ) (prod.lift c d ≫ non_preadditive_abelian.σ) ≫	      non_preadditive_abelian.σ =	    a - b - (c - d)", "decl_nm": "category_theory.non_preadditive_abelian.sub_sub_sub"
{"src": "⊢ ∀ {C : Type u₁} {D : Type u₂} [_inst_1 : category C] [_inst_2 : category D] {L₁ : C ⥤ D} {R₁ : D ⥤ C}	  (adj₁ : L₁ ⊣ R₁), ⇑((transfer_nat_trans_self adj₁ adj₁).symm) (𝟙 R₁) = 𝟙 L₁", "decl_nm": "category_theory.transfer_nat_trans_self_symm_id"
{"src": "C : Type u₁,	D : Type u₂,	_inst_1 : category C,	_inst_2 : category D,	L₁ : C ⥤ D,	R₁ : D ⥤ C,	adj₁ : L₁ ⊣ R₁	⊢ ⇑((transfer_nat_trans_self adj₁ adj₁).symm) (𝟙 R₁) = 𝟙 L₁", "decl_nm": "category_theory.transfer_nat_trans_self_symm_id"
{"src": "C : Type u₁,	D : Type u₂,	_inst_1 : category C,	_inst_2 : category D,	L₁ : C ⥤ D,	R₁ : D ⥤ C,	adj₁ : L₁ ⊣ R₁	⊢ 𝟙 R₁ = ⇑(transfer_nat_trans_self adj₁ adj₁) (𝟙 L₁)", "decl_nm": "category_theory.transfer_nat_trans_self_symm_id"
{"src": "⊢ ∀ {C : Type u₁} {D : Type u₂} [_inst_1 : category C] [_inst_2 : category D] {i : D ⥤ C}	  [_inst_4 : reflective i] (A : C) {B : C} (hB : B ∈ i.ess_image) (f : i.obj ((left_adjoint i).obj A) ⟶ B),	    ⇑((unit_comp_partial_bijective A hB).symm) f = (of_right_adjoint i).unit.app A ≫ f", "decl_nm": "category_theory.unit_comp_partial_bijective_symm_apply"
{"src": "C : Type u₁,	D : Type u₂,	_inst_1 : category C,	_inst_2 : category D,	i : D ⥤ C,	_inst_4 : reflective i,	A B : C,	hB : B ∈ i.ess_image,	f : i.obj ((left_adjoint i).obj A) ⟶ B	⊢ ⇑((unit_comp_partial_bijective A hB).symm) f = (of_right_adjoint i).unit.app A ≫ f", "decl_nm": "category_theory.unit_comp_partial_bijective_symm_apply"
{"src": "⊢ ∀ {C : Type u₁} [_inst_1 : category C] {D : Type u₂} [_inst_2 : category D] (e : C ≌ D) {X Y : D}	  (f f' : X ⟶ e.functor.obj (e.inverse.obj Y)), f ≫ e.counit.app Y = f' ≫ e.counit.app Y ↔ f = f'", "decl_nm": "category_theory.equivalence.cancel_counit_right"
{"src": "C : Type u₁,	_inst_1 : category C,	D : Type u₂,	_inst_2 : category D,	e : C ≌ D,	X Y : D,	f f' : X ⟶ e.functor.obj (e.inverse.obj Y)	⊢ f ≫ e.counit.app Y = f' ≫ e.counit.app Y ↔ f = f'", "decl_nm": "category_theory.equivalence.cancel_counit_right"
{"src": "⊢ ∀ {C : Type u₁} [_inst_1 : category C] {D : Type u₂} [_inst_2 : category D] (F : C ⥤ D), F ⋙ 𝟭 D = F", "decl_nm": "category_theory.functor.comp_id"
{"src": "C : Type u₁,	_inst_1 : category C,	D : Type u₂,	_inst_2 : category D,	F : C ⥤ D	⊢ F ⋙ 𝟭 D = F", "decl_nm": "category_theory.functor.comp_id"
{"src": "C : Type u₁,	_inst_1 : category C,	D : Type u₂,	_inst_2 : category D,	F_obj : C → D,	F_map : Π {X Y : C}, (X ⟶ Y) → (F_obj X ⟶ F_obj Y),	F_map_id' : auto_param (∀ (X : C), F_map (𝟙 X) = 𝟙 (F_obj X)) (name.mk_string "obviously" name.anonymous),	F_map_comp' :	  auto_param (∀ {X Y Z : C} (f : X ⟶ Y) (g : Y ⟶ Z), F_map (f ≫ g) = F_map f ≫ F_map g)	    (name.mk_string "obviously" name.anonymous)	⊢ {obj := F_obj, map := F_map, map_id' := F_map_id', map_comp' := F_map_comp'} ⋙ 𝟭 D =	    {obj := F_obj, map := F_map, map_id' := F_map_id', map_comp' := F_map_comp'}", "decl_nm": "category_theory.functor.comp_id"
{"src": "⊢ ∀ {C : Type u} [_inst_1 : category C] [_inst_2 : concrete_category C] {J : Type v} [_inst_3 : small_category J]	  (F : J ⥤ C) [_inst_4 : limits.preserves_colimit F (forget C)] {D : limits.cocone F},	    limits.is_colimit D →	    (let ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd	     in function.surjective ff)", "decl_nm": "category_theory.limits.concrete.from_union_surjective_of_is_colimit"
{"src": "C : Type u,	_inst_1 : category C,	_inst_2 : concrete_category C,	J : Type v,	_inst_3 : small_category J,	F : J ⥤ C,	_inst_4 : limits.preserves_colimit F (forget C),	D : limits.cocone F,	hD : limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd	⊢ function.surjective ff", "decl_nm": "category_theory.limits.concrete.from_union_surjective_of_is_colimit"
{"src": "C : Type u,	_inst_1 : category C,	_inst_2 : concrete_category C,	J : Type v,	_inst_3 : small_category J,	F : J ⥤ C,	_inst_4 : limits.preserves_colimit F (forget C),	D : limits.cocone F,	hD : limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : limits.cocone (F ⋙ forget C) := (forget C).map_cocone D	⊢ function.surjective ff", "decl_nm": "category_theory.limits.concrete.from_union_surjective_of_is_colimit"
{"src": "C : Type u,	_inst_1 : category C,	_inst_2 : concrete_category C,	J : Type v,	_inst_3 : small_category J,	F : J ⥤ C,	_inst_4 : limits.preserves_colimit F (forget C),	D : limits.cocone F,	hD : limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : limits.cocone (F ⋙ forget C) := (forget C).map_cocone D,	hE : limits.is_colimit E := limits.is_colimit_of_preserves (forget C) hD	⊢ function.surjective ff", "decl_nm": "category_theory.limits.concrete.from_union_surjective_of_is_colimit"
{"src": "C : Type u,	_inst_1 : category C,	_inst_2 : concrete_category C,	J : Type v,	_inst_3 : small_category J,	F : J ⥤ C,	_inst_4 : limits.preserves_colimit F (forget C),	D : limits.cocone F,	hD : limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : limits.cocone (F ⋙ forget C) := (forget C).map_cocone D,	hE : limits.is_colimit E := limits.is_colimit_of_preserves (forget C) hD,	G : limits.cocone (F ⋙ forget C) := limits.types.colimit_cocone (F ⋙ forget C)	⊢ function.surjective ff", "decl_nm": "category_theory.limits.concrete.from_union_surjective_of_is_colimit"
{"src": "C : Type u,	_inst_1 : category C,	_inst_2 : concrete_category C,	J : Type v,	_inst_3 : small_category J,	F : J ⥤ C,	_inst_4 : limits.preserves_colimit F (forget C),	D : limits.cocone F,	hD : limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : limits.cocone (F ⋙ forget C) := (forget C).map_cocone D,	hE : limits.is_colimit E := limits.is_colimit_of_preserves (forget C) hD,	G : limits.cocone (F ⋙ forget C) := limits.types.colimit_cocone (F ⋙ forget C),	hG : limits.is_colimit (limits.types.colimit_cocone (F ⋙ forget C)) :=	  limits.types.colimit_cocone_is_colimit (F ⋙ forget C)	⊢ function.surjective ff", "decl_nm": "category_theory.limits.concrete.from_union_surjective_of_is_colimit"
{"src": "C : Type u,	_inst_1 : category C,	_inst_2 : concrete_category C,	J : Type v,	_inst_3 : small_category J,	F : J ⥤ C,	_inst_4 : limits.preserves_colimit F (forget C),	D : limits.cocone F,	hD : limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : limits.cocone (F ⋙ forget C) := (forget C).map_cocone D,	hE : limits.is_colimit E := limits.is_colimit_of_preserves (forget C) hD,	G : limits.cocone (F ⋙ forget C) := limits.types.colimit_cocone (F ⋙ forget C),	hG : limits.is_colimit (limits.types.colimit_cocone (F ⋙ forget C)) :=	  limits.types.colimit_cocone_is_colimit (F ⋙ forget C),	T : E ≅ G := hE.unique_up_to_iso hG	⊢ function.surjective ff", "decl_nm": "category_theory.limits.concrete.from_union_surjective_of_is_colimit"
{"src": "C : Type u,	_inst_1 : category C,	_inst_2 : concrete_category C,	J : Type v,	_inst_3 : small_category J,	F : J ⥤ C,	_inst_4 : limits.preserves_colimit F (forget C),	D : limits.cocone F,	hD : limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : limits.cocone (F ⋙ forget C) := (forget C).map_cocone D,	hE : limits.is_colimit E := limits.is_colimit_of_preserves (forget C) hD,	G : limits.cocone (F ⋙ forget C) := limits.types.colimit_cocone (F ⋙ forget C),	hG : limits.is_colimit (limits.types.colimit_cocone (F ⋙ forget C)) :=	  limits.types.colimit_cocone_is_colimit (F ⋙ forget C),	T : E ≅ G := hE.unique_up_to_iso hG,	TX : E.X ≅ G.X := (limits.cocones.forget (F ⋙ forget C)).map_iso T	⊢ function.surjective ff", "decl_nm": "category_theory.limits.concrete.from_union_surjective_of_is_colimit"
{"src": "2 goals	C : Type u,	_inst_1 : category C,	_inst_2 : concrete_category C,	J : Type v,	_inst_3 : small_category J,	F : J ⥤ C,	_inst_4 : limits.preserves_colimit F (forget C),	D : limits.cocone F,	hD : limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : limits.cocone (F ⋙ forget C) := (forget C).map_cocone D,	hE : limits.is_colimit E := limits.is_colimit_of_preserves (forget C) hD,	G : limits.cocone (F ⋙ forget C) := limits.types.colimit_cocone (F ⋙ forget C),	hG : limits.is_colimit (limits.types.colimit_cocone (F ⋙ forget C)) :=	  limits.types.colimit_cocone_is_colimit (F ⋙ forget C),	T : E ≅ G := hE.unique_up_to_iso hG,	TX : E.X ≅ G.X := (limits.cocones.forget (F ⋙ forget C)).map_iso T,	this : function.surjective (TX.hom ∘ ff)	⊢ function.surjective ff		C : Type u,	_inst_1 : category C,	_inst_2 : concrete_category C,	J : Type v,	_inst_3 : small_category J,	F : J ⥤ C,	_inst_4 : limits.preserves_colimit F (forget C),	D : limits.cocone F,	hD : limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : limits.cocone (F ⋙ forget C) := (forget C).map_cocone D,	hE : limits.is_colimit E := limits.is_colimit_of_preserves (forget C) hD,	G : limits.cocone (F ⋙ forget C) := limits.types.colimit_cocone (F ⋙ forget C),	hG : limits.is_colimit (limits.types.colimit_cocone (F ⋙ forget C)) :=	  limits.types.colimit_cocone_is_colimit (F ⋙ forget C),	T : E ≅ G := hE.unique_up_to_iso hG,	TX : E.X ≅ G.X := (limits.cocones.forget (F ⋙ forget C)).map_iso T	⊢ function.surjective (TX.hom ∘ ff)", "decl_nm": "category_theory.limits.concrete.from_union_surjective_of_is_colimit"
{"src": "2 goals	C : Type u,	_inst_1 : category C,	_inst_2 : concrete_category C,	J : Type v,	_inst_3 : small_category J,	F : J ⥤ C,	_inst_4 : limits.preserves_colimit F (forget C),	D : limits.cocone F,	hD : limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : limits.cocone (F ⋙ forget C) := (forget C).map_cocone D,	hE : limits.is_colimit E := limits.is_colimit_of_preserves (forget C) hD,	G : limits.cocone (F ⋙ forget C) := limits.types.colimit_cocone (F ⋙ forget C),	hG : limits.is_colimit (limits.types.colimit_cocone (F ⋙ forget C)) :=	  limits.types.colimit_cocone_is_colimit (F ⋙ forget C),	T : E ≅ G := hE.unique_up_to_iso hG,	TX : E.X ≅ G.X := (limits.cocones.forget (F ⋙ forget C)).map_iso T,	this : function.surjective (TX.hom ∘ ff),	a : ↥(D.X)	⊢ ∃ (a_1 : Σ (j : J), ↥(F.obj j)), ff a_1 = a		C : Type u,	_inst_1 : category C,	_inst_2 : concrete_category C,	J : Type v,	_inst_3 : small_category J,	F : J ⥤ C,	_inst_4 : limits.preserves_colimit F (forget C),	D : limits.cocone F,	hD : limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : limits.cocone (F ⋙ forget C) := (forget C).map_cocone D,	hE : limits.is_colimit E := limits.is_colimit_of_preserves (forget C) hD,	G : limits.cocone (F ⋙ forget C) := limits.types.colimit_cocone (F ⋙ forget C),	hG : limits.is_colimit (limits.types.colimit_cocone (F ⋙ forget C)) :=	  limits.types.colimit_cocone_is_colimit (F ⋙ forget C),	T : E ≅ G := hE.unique_up_to_iso hG,	TX : E.X ≅ G.X := (limits.cocones.forget (F ⋙ forget C)).map_iso T	⊢ function.surjective (TX.hom ∘ ff)", "decl_nm": "category_theory.limits.concrete.from_union_surjective_of_is_colimit"
{"src": "2 goals	C : Type u,	_inst_1 : category C,	_inst_2 : concrete_category C,	J : Type v,	_inst_3 : small_category J,	F : J ⥤ C,	_inst_4 : limits.preserves_colimit F (forget C),	D : limits.cocone F,	hD : limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : limits.cocone (F ⋙ forget C) := (forget C).map_cocone D,	hE : limits.is_colimit E := limits.is_colimit_of_preserves (forget C) hD,	G : limits.cocone (F ⋙ forget C) := limits.types.colimit_cocone (F ⋙ forget C),	hG : limits.is_colimit (limits.types.colimit_cocone (F ⋙ forget C)) :=	  limits.types.colimit_cocone_is_colimit (F ⋙ forget C),	T : E ≅ G := hE.unique_up_to_iso hG,	TX : E.X ≅ G.X := (limits.cocones.forget (F ⋙ forget C)).map_iso T,	this : function.surjective (TX.hom ∘ ff),	a : ↥(D.X),	b : Σ (j : J), ↥(F.obj j),	hb : (TX.hom ∘ ff) b = TX.hom a	⊢ ∃ (a_1 : Σ (j : J), ↥(F.obj j)), ff a_1 = a		C : Type u,	_inst_1 : category C,	_inst_2 : concrete_category C,	J : Type v,	_inst_3 : small_category J,	F : J ⥤ C,	_inst_4 : limits.preserves_colimit F (forget C),	D : limits.cocone F,	hD : limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : limits.cocone (F ⋙ forget C) := (forget C).map_cocone D,	hE : limits.is_colimit E := limits.is_colimit_of_preserves (forget C) hD,	G : limits.cocone (F ⋙ forget C) := limits.types.colimit_cocone (F ⋙ forget C),	hG : limits.is_colimit (limits.types.colimit_cocone (F ⋙ forget C)) :=	  limits.types.colimit_cocone_is_colimit (F ⋙ forget C),	T : E ≅ G := hE.unique_up_to_iso hG,	TX : E.X ≅ G.X := (limits.cocones.forget (F ⋙ forget C)).map_iso T	⊢ function.surjective (TX.hom ∘ ff)", "decl_nm": "category_theory.limits.concrete.from_union_surjective_of_is_colimit"
{"src": "2 goals	C : Type u,	_inst_1 : category C,	_inst_2 : concrete_category C,	J : Type v,	_inst_3 : small_category J,	F : J ⥤ C,	_inst_4 : limits.preserves_colimit F (forget C),	D : limits.cocone F,	hD : limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : limits.cocone (F ⋙ forget C) := (forget C).map_cocone D,	hE : limits.is_colimit E := limits.is_colimit_of_preserves (forget C) hD,	G : limits.cocone (F ⋙ forget C) := limits.types.colimit_cocone (F ⋙ forget C),	hG : limits.is_colimit (limits.types.colimit_cocone (F ⋙ forget C)) :=	  limits.types.colimit_cocone_is_colimit (F ⋙ forget C),	T : E ≅ G := hE.unique_up_to_iso hG,	TX : E.X ≅ G.X := (limits.cocones.forget (F ⋙ forget C)).map_iso T,	this : function.surjective (TX.hom ∘ ff),	a : ↥(D.X),	b : Σ (j : J), ↥(F.obj j),	hb : (TX.hom ∘ ff) b = TX.hom a	⊢ ff b = a		C : Type u,	_inst_1 : category C,	_inst_2 : concrete_category C,	J : Type v,	_inst_3 : small_category J,	F : J ⥤ C,	_inst_4 : limits.preserves_colimit F (forget C),	D : limits.cocone F,	hD : limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : limits.cocone (F ⋙ forget C) := (forget C).map_cocone D,	hE : limits.is_colimit E := limits.is_colimit_of_preserves (forget C) hD,	G : limits.cocone (F ⋙ forget C) := limits.types.colimit_cocone (F ⋙ forget C),	hG : limits.is_colimit (limits.types.colimit_cocone (F ⋙ forget C)) :=	  limits.types.colimit_cocone_is_colimit (F ⋙ forget C),	T : E ≅ G := hE.unique_up_to_iso hG,	TX : E.X ≅ G.X := (limits.cocones.forget (F ⋙ forget C)).map_iso T	⊢ function.surjective (TX.hom ∘ ff)", "decl_nm": "category_theory.limits.concrete.from_union_surjective_of_is_colimit"
{"src": "2 goals	C : Type u,	_inst_1 : category C,	_inst_2 : concrete_category C,	J : Type v,	_inst_3 : small_category J,	F : J ⥤ C,	_inst_4 : limits.preserves_colimit F (forget C),	D : limits.cocone F,	hD : limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : limits.cocone (F ⋙ forget C) := (forget C).map_cocone D,	hE : limits.is_colimit E := limits.is_colimit_of_preserves (forget C) hD,	G : limits.cocone (F ⋙ forget C) := limits.types.colimit_cocone (F ⋙ forget C),	hG : limits.is_colimit (limits.types.colimit_cocone (F ⋙ forget C)) :=	  limits.types.colimit_cocone_is_colimit (F ⋙ forget C),	T : E ≅ G := hE.unique_up_to_iso hG,	TX : E.X ≅ G.X := (limits.cocones.forget (F ⋙ forget C)).map_iso T,	this : function.surjective (TX.hom ∘ ff),	a : ↥(D.X),	b : Σ (j : J), ↥(F.obj j),	hb : TX.inv ((TX.hom ∘ ff) b) = TX.inv (TX.hom a)	⊢ ff b = a		C : Type u,	_inst_1 : category C,	_inst_2 : concrete_category C,	J : Type v,	_inst_3 : small_category J,	F : J ⥤ C,	_inst_4 : limits.preserves_colimit F (forget C),	D : limits.cocone F,	hD : limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : limits.cocone (F ⋙ forget C) := (forget C).map_cocone D,	hE : limits.is_colimit E := limits.is_colimit_of_preserves (forget C) hD,	G : limits.cocone (F ⋙ forget C) := limits.types.colimit_cocone (F ⋙ forget C),	hG : limits.is_colimit (limits.types.colimit_cocone (F ⋙ forget C)) :=	  limits.types.colimit_cocone_is_colimit (F ⋙ forget C),	T : E ≅ G := hE.unique_up_to_iso hG,	TX : E.X ≅ G.X := (limits.cocones.forget (F ⋙ forget C)).map_iso T	⊢ function.surjective (TX.hom ∘ ff)", "decl_nm": "category_theory.limits.concrete.from_union_surjective_of_is_colimit"
{"src": "2 goals	C : Type u,	_inst_1 : category C,	_inst_2 : concrete_category C,	J : Type v,	_inst_3 : small_category J,	F : J ⥤ C,	_inst_4 : limits.preserves_colimit F (forget C),	D : limits.cocone F,	hD : limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : limits.cocone (F ⋙ forget C) := (forget C).map_cocone D,	hE : limits.is_colimit E := limits.is_colimit_of_preserves (forget C) hD,	G : limits.cocone (F ⋙ forget C) := limits.types.colimit_cocone (F ⋙ forget C),	hG : limits.is_colimit (limits.types.colimit_cocone (F ⋙ forget C)) :=	  limits.types.colimit_cocone_is_colimit (F ⋙ forget C),	T : E ≅ G := hE.unique_up_to_iso hG,	TX : E.X ≅ G.X := (limits.cocones.forget (F ⋙ forget C)).map_iso T,	this : function.surjective (TX.hom ∘ ff),	a : ↥(D.X),	b : Σ (j : J), ↥(F.obj j),	hb : (TX.hom ≫ TX.inv) (ff b) = (TX.hom ≫ TX.inv) a	⊢ ff b = a		C : Type u,	_inst_1 : category C,	_inst_2 : concrete_category C,	J : Type v,	_inst_3 : small_category J,	F : J ⥤ C,	_inst_4 : limits.preserves_colimit F (forget C),	D : limits.cocone F,	hD : limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : limits.cocone (F ⋙ forget C) := (forget C).map_cocone D,	hE : limits.is_colimit E := limits.is_colimit_of_preserves (forget C) hD,	G : limits.cocone (F ⋙ forget C) := limits.types.colimit_cocone (F ⋙ forget C),	hG : limits.is_colimit (limits.types.colimit_cocone (F ⋙ forget C)) :=	  limits.types.colimit_cocone_is_colimit (F ⋙ forget C),	T : E ≅ G := hE.unique_up_to_iso hG,	TX : E.X ≅ G.X := (limits.cocones.forget (F ⋙ forget C)).map_iso T	⊢ function.surjective (TX.hom ∘ ff)", "decl_nm": "category_theory.limits.concrete.from_union_surjective_of_is_colimit"
{"src": "C : Type u,	_inst_1 : category C,	_inst_2 : concrete_category C,	J : Type v,	_inst_3 : small_category J,	F : J ⥤ C,	_inst_4 : limits.preserves_colimit F (forget C),	D : limits.cocone F,	hD : limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : limits.cocone (F ⋙ forget C) := (forget C).map_cocone D,	hE : limits.is_colimit E := limits.is_colimit_of_preserves (forget C) hD,	G : limits.cocone (F ⋙ forget C) := limits.types.colimit_cocone (F ⋙ forget C),	hG : limits.is_colimit (limits.types.colimit_cocone (F ⋙ forget C)) :=	  limits.types.colimit_cocone_is_colimit (F ⋙ forget C),	T : E ≅ G := hE.unique_up_to_iso hG,	TX : E.X ≅ G.X := (limits.cocones.forget (F ⋙ forget C)).map_iso T	⊢ function.surjective (TX.hom ∘ ff)", "decl_nm": "category_theory.limits.concrete.from_union_surjective_of_is_colimit"
{"src": "2 goals	C : Type u,	_inst_1 : category C,	_inst_2 : concrete_category C,	J : Type v,	_inst_3 : small_category J,	F : J ⥤ C,	_inst_4 : limits.preserves_colimit F (forget C),	D : limits.cocone F,	hD : limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : limits.cocone (F ⋙ forget C) := (forget C).map_cocone D,	hE : limits.is_colimit E := limits.is_colimit_of_preserves (forget C) hD,	G : limits.cocone (F ⋙ forget C) := limits.types.colimit_cocone (F ⋙ forget C),	hG : limits.is_colimit (limits.types.colimit_cocone (F ⋙ forget C)) :=	  limits.types.colimit_cocone_is_colimit (F ⋙ forget C),	T : E ≅ G := hE.unique_up_to_iso hG,	TX : E.X ≅ G.X := (limits.cocones.forget (F ⋙ forget C)).map_iso T	⊢ TX.hom ∘ ff = λ (a : Σ (j : J), ↥(F.obj j)), G.ι.app a.fst a.snd		C : Type u,	_inst_1 : category C,	_inst_2 : concrete_category C,	J : Type v,	_inst_3 : small_category J,	F : J ⥤ C,	_inst_4 : limits.preserves_colimit F (forget C),	D : limits.cocone F,	hD : limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : limits.cocone (F ⋙ forget C) := (forget C).map_cocone D,	hE : limits.is_colimit E := limits.is_colimit_of_preserves (forget C) hD,	G : limits.cocone (F ⋙ forget C) := limits.types.colimit_cocone (F ⋙ forget C),	hG : limits.is_colimit (limits.types.colimit_cocone (F ⋙ forget C)) :=	  limits.types.colimit_cocone_is_colimit (F ⋙ forget C),	T : E ≅ G := hE.unique_up_to_iso hG,	TX : E.X ≅ G.X := (limits.cocones.forget (F ⋙ forget C)).map_iso T,	this : TX.hom ∘ ff = λ (a : Σ (j : J), ↥(F.obj j)), G.ι.app a.fst a.snd	⊢ function.surjective (TX.hom ∘ ff)", "decl_nm": "category_theory.limits.concrete.from_union_surjective_of_is_colimit"
{"src": "2 goals	C : Type u,	_inst_1 : category C,	_inst_2 : concrete_category C,	J : Type v,	_inst_3 : small_category J,	F : J ⥤ C,	_inst_4 : limits.preserves_colimit F (forget C),	D : limits.cocone F,	hD : limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : limits.cocone (F ⋙ forget C) := (forget C).map_cocone D,	hE : limits.is_colimit E := limits.is_colimit_of_preserves (forget C) hD,	G : limits.cocone (F ⋙ forget C) := limits.types.colimit_cocone (F ⋙ forget C),	hG : limits.is_colimit (limits.types.colimit_cocone (F ⋙ forget C)) :=	  limits.types.colimit_cocone_is_colimit (F ⋙ forget C),	T : E ≅ G := hE.unique_up_to_iso hG,	TX : E.X ≅ G.X := (limits.cocones.forget (F ⋙ forget C)).map_iso T,	a : Σ (j : J), ↥(F.obj j)	⊢ (TX.hom ∘ ff) a = G.ι.app a.fst a.snd		C : Type u,	_inst_1 : category C,	_inst_2 : concrete_category C,	J : Type v,	_inst_3 : small_category J,	F : J ⥤ C,	_inst_4 : limits.preserves_colimit F (forget C),	D : limits.cocone F,	hD : limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : limits.cocone (F ⋙ forget C) := (forget C).map_cocone D,	hE : limits.is_colimit E := limits.is_colimit_of_preserves (forget C) hD,	G : limits.cocone (F ⋙ forget C) := limits.types.colimit_cocone (F ⋙ forget C),	hG : limits.is_colimit (limits.types.colimit_cocone (F ⋙ forget C)) :=	  limits.types.colimit_cocone_is_colimit (F ⋙ forget C),	T : E ≅ G := hE.unique_up_to_iso hG,	TX : E.X ≅ G.X := (limits.cocones.forget (F ⋙ forget C)).map_iso T,	this : TX.hom ∘ ff = λ (a : Σ (j : J), ↥(F.obj j)), G.ι.app a.fst a.snd	⊢ function.surjective (TX.hom ∘ ff)", "decl_nm": "category_theory.limits.concrete.from_union_surjective_of_is_colimit"
{"src": "2 goals	C : Type u,	_inst_1 : category C,	_inst_2 : concrete_category C,	J : Type v,	_inst_3 : small_category J,	F : J ⥤ C,	_inst_4 : limits.preserves_colimit F (forget C),	D : limits.cocone F,	hD : limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : limits.cocone (F ⋙ forget C) := (forget C).map_cocone D,	hE : limits.is_colimit E := limits.is_colimit_of_preserves (forget C) hD,	G : limits.cocone (F ⋙ forget C) := limits.types.colimit_cocone (F ⋙ forget C),	hG : limits.is_colimit (limits.types.colimit_cocone (F ⋙ forget C)) :=	  limits.types.colimit_cocone_is_colimit (F ⋙ forget C),	T : E ≅ G := hE.unique_up_to_iso hG,	TX : E.X ≅ G.X := (limits.cocones.forget (F ⋙ forget C)).map_iso T,	a : Σ (j : J), ↥(F.obj j)	⊢ (E.ι.app a.fst ≫ hE.desc G) a.snd = G.ι.app a.fst a.snd		C : Type u,	_inst_1 : category C,	_inst_2 : concrete_category C,	J : Type v,	_inst_3 : small_category J,	F : J ⥤ C,	_inst_4 : limits.preserves_colimit F (forget C),	D : limits.cocone F,	hD : limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : limits.cocone (F ⋙ forget C) := (forget C).map_cocone D,	hE : limits.is_colimit E := limits.is_colimit_of_preserves (forget C) hD,	G : limits.cocone (F ⋙ forget C) := limits.types.colimit_cocone (F ⋙ forget C),	hG : limits.is_colimit (limits.types.colimit_cocone (F ⋙ forget C)) :=	  limits.types.colimit_cocone_is_colimit (F ⋙ forget C),	T : E ≅ G := hE.unique_up_to_iso hG,	TX : E.X ≅ G.X := (limits.cocones.forget (F ⋙ forget C)).map_iso T,	this : TX.hom ∘ ff = λ (a : Σ (j : J), ↥(F.obj j)), G.ι.app a.fst a.snd	⊢ function.surjective (TX.hom ∘ ff)", "decl_nm": "category_theory.limits.concrete.from_union_surjective_of_is_colimit"
{"src": "C : Type u,	_inst_1 : category C,	_inst_2 : concrete_category C,	J : Type v,	_inst_3 : small_category J,	F : J ⥤ C,	_inst_4 : limits.preserves_colimit F (forget C),	D : limits.cocone F,	hD : limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : limits.cocone (F ⋙ forget C) := (forget C).map_cocone D,	hE : limits.is_colimit E := limits.is_colimit_of_preserves (forget C) hD,	G : limits.cocone (F ⋙ forget C) := limits.types.colimit_cocone (F ⋙ forget C),	hG : limits.is_colimit (limits.types.colimit_cocone (F ⋙ forget C)) :=	  limits.types.colimit_cocone_is_colimit (F ⋙ forget C),	T : E ≅ G := hE.unique_up_to_iso hG,	TX : E.X ≅ G.X := (limits.cocones.forget (F ⋙ forget C)).map_iso T,	this : TX.hom ∘ ff = λ (a : Σ (j : J), ↥(F.obj j)), G.ι.app a.fst a.snd	⊢ function.surjective (TX.hom ∘ ff)", "decl_nm": "category_theory.limits.concrete.from_union_surjective_of_is_colimit"
{"src": "C : Type u,	_inst_1 : category C,	_inst_2 : concrete_category C,	J : Type v,	_inst_3 : small_category J,	F : J ⥤ C,	_inst_4 : limits.preserves_colimit F (forget C),	D : limits.cocone F,	hD : limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : limits.cocone (F ⋙ forget C) := (forget C).map_cocone D,	hE : limits.is_colimit E := limits.is_colimit_of_preserves (forget C) hD,	G : limits.cocone (F ⋙ forget C) := limits.types.colimit_cocone (F ⋙ forget C),	hG : limits.is_colimit (limits.types.colimit_cocone (F ⋙ forget C)) :=	  limits.types.colimit_cocone_is_colimit (F ⋙ forget C),	T : E ≅ G := hE.unique_up_to_iso hG,	TX : E.X ≅ G.X := (limits.cocones.forget (F ⋙ forget C)).map_iso T,	this : TX.hom ∘ ff = λ (a : Σ (j : J), ↥(F.obj j)), G.ι.app a.fst a.snd	⊢ function.surjective (λ (a : Σ (j : J), ↥(F.obj j)), G.ι.app a.fst a.snd)", "decl_nm": "category_theory.limits.concrete.from_union_surjective_of_is_colimit"
{"src": "C : Type u,	_inst_1 : category C,	_inst_2 : concrete_category C,	J : Type v,	_inst_3 : small_category J,	F : J ⥤ C,	_inst_4 : limits.preserves_colimit F (forget C),	D : limits.cocone F,	hD : limits.is_colimit D,	ff : (Σ (j : J), ↥(F.obj j)) → ↥(D.X) := λ (a : Σ (j : J), ↥(F.obj j)), ⇑(D.ι.app a.fst) a.snd,	E : limits.cocone (F ⋙ forget C) := (forget C).map_cocone D,	hE : limits.is_colimit E := limits.is_colimit_of_preserves (forget C) hD,	G : limits.cocone (F ⋙ forget C) := limits.types.colimit_cocone (F ⋙ forget C),	hG : limits.is_colimit (limits.types.colimit_cocone (F ⋙ forget C)) :=	  limits.types.colimit_cocone_is_colimit (F ⋙ forget C),	T : E ≅ G := hE.unique_up_to_iso hG,	TX : E.X ≅ G.X := (limits.cocones.forget (F ⋙ forget C)).map_iso T,	this : TX.hom ∘ ff = λ (a : Σ (j : J), ↥(F.obj j)), G.ι.app a.fst a.snd,	j : J,	a : (F ⋙ forget C).obj j	⊢ ∃ (a_1 : Σ (j : J), ↥(F.obj j)),	    (λ (a : Σ (j : J), ↥(F.obj j)), G.ι.app a.fst a.snd) a_1 =	      quot.mk (limits.types.quot.rel (F ⋙ forget C)) ⟨j, a⟩", "decl_nm": "category_theory.limits.concrete.from_union_surjective_of_is_colimit"
{"src": "⊢ ∀ {J : Type u₁} [_inst_1 : category J] {C : Type u} [_inst_3 : category C] (F : J ⥤ C) {D : Type u'}	  [_inst_4 : category D] [_inst_5 : limits.has_limit F] (G : C ⥤ D) [_inst_6 : limits.has_limit (F ⋙ G)]	  (c : limits.cone F),	    G.map (limits.limit.lift F c) ≫ limits.limit.post F G = limits.limit.lift (F ⋙ G) (G.map_cone c)", "decl_nm": "category_theory.limits.limit.lift_post"
{"src": "J : Type u₁,	_inst_1 : category J,	C : Type u,	_inst_3 : category C,	F : J ⥤ C,	D : Type u',	_inst_4 : category D,	_inst_5 : limits.has_limit F,	G : C ⥤ D,	_inst_6 : limits.has_limit (F ⋙ G),	c : limits.cone F	⊢ G.map (limits.limit.lift F c) ≫ limits.limit.post F G = limits.limit.lift (F ⋙ G) (G.map_cone c)", "decl_nm": "category_theory.limits.limit.lift_post"
{"src": "J : Type u₁,	_inst_1 : category J,	C : Type u,	_inst_3 : category C,	F : J ⥤ C,	D : Type u',	_inst_4 : category D,	_inst_5 : limits.has_limit F,	G : C ⥤ D,	_inst_6 : limits.has_limit (F ⋙ G),	c : limits.cone F,	j : J	⊢ (G.map (limits.limit.lift F c) ≫ limits.limit.post F G) ≫ limits.limit.π (F ⋙ G) j =	    limits.limit.lift (F ⋙ G) (G.map_cone c) ≫ limits.limit.π (F ⋙ G) j", "decl_nm": "category_theory.limits.limit.lift_post"
{"src": "J : Type u₁,	_inst_1 : category J,	C : Type u,	_inst_3 : category C,	F : J ⥤ C,	D : Type u',	_inst_4 : category D,	_inst_5 : limits.has_limit F,	G : C ⥤ D,	_inst_6 : limits.has_limit (F ⋙ G),	c : limits.cone F,	j : J	⊢ G.map (c.π.app j) = (G.map_cone c).π.app j", "decl_nm": "category_theory.limits.limit.lift_post"
{"src": "⊢ ∀ {J : Type u₁} [_inst_1 : category J] {K : Type u₂} [_inst_2 : category K] {C : Type u}	  [_inst_3 : category C] [_inst_4 : limits.has_limits_of_shape J C] [_inst_5 : limits.has_limits_of_shape K C]	  (F : J ⥤ C) {E₁ E₂ : K ⥤ J} (α : E₁ ⟶ E₂),	    limits.limit.pre F E₂ = limits.limit.pre F E₁ ≫ limits.lim.map (whisker_right α F)", "decl_nm": "category_theory.limits.limit.map_pre'"
{"src": "J : Type u₁,	_inst_1 : category J,	K : Type u₂,	_inst_2 : category K,	C : Type u,	_inst_3 : category C,	_inst_4 : limits.has_limits_of_shape J C,	_inst_5 : limits.has_limits_of_shape K C,	F : J ⥤ C,	E₁ E₂ : K ⥤ J,	α : E₁ ⟶ E₂	⊢ limits.limit.pre F E₂ = limits.limit.pre F E₁ ≫ limits.lim.map (whisker_right α F)", "decl_nm": "category_theory.limits.limit.map_pre'"
{"src": "J : Type u₁,	_inst_1 : category J,	K : Type u₂,	_inst_2 : category K,	C : Type u,	_inst_3 : category C,	_inst_4 : limits.has_limits_of_shape J C,	_inst_5 : limits.has_limits_of_shape K C,	F : J ⥤ C,	E₁ E₂ : K ⥤ J,	α : E₁ ⟶ E₂,	j : K	⊢ limits.limit.pre F E₂ ≫ limits.limit.π (E₂ ⋙ F) j =	    (limits.limit.pre F E₁ ≫ limits.lim.map (whisker_right α F)) ≫ limits.limit.π (E₂ ⋙ F) j", "decl_nm": "category_theory.limits.limit.map_pre'"
{"src": "⊢ ∀ {C : Type u₁} [_inst_1 : small_category C] {P₁ P₂ : Cᵒᵖ ⥤ Type u₁} (α : P₁ ⟶ P₂)	  (j : (P₁.elements)ᵒᵖ),	    (cocone_of_representable P₁).ι.app j ≫ α =	      (cocone_of_representable P₂).ι.app ((category_of_elements.map α).op.obj j)", "decl_nm": "category_theory.cocone_of_representable_naturality"
{"src": "C : Type u₁,	_inst_1 : small_category C,	P₁ P₂ : Cᵒᵖ ⥤ Type u₁,	α : P₁ ⟶ P₂,	j : (P₁.elements)ᵒᵖ	⊢ (cocone_of_representable P₁).ι.app j ≫ α =	    (cocone_of_representable P₂).ι.app ((category_of_elements.map α).op.obj j)", "decl_nm": "category_theory.cocone_of_representable_naturality"
{"src": "C : Type u₁,	_inst_1 : small_category C,	P₁ P₂ : Cᵒᵖ ⥤ Type u₁,	α : P₁ ⟶ P₂,	j : (P₁.elements)ᵒᵖ,	T : Cᵒᵖ,	f : ((functor_to_representables P₁).obj j).obj T	⊢ ((cocone_of_representable P₁).ι.app j ≫ α).app T f =	    ((cocone_of_representable P₂).ι.app ((category_of_elements.map α).op.obj j)).app T f", "decl_nm": "category_theory.cocone_of_representable_naturality"
{"src": "⊢ ∀ {C : Type u} [_inst_1 : category C] {X Y : C} [_inst_2 : limits.has_binary_product Y Y] (f : X ⟶ Y),	    f ≫ limits.diag Y = limits.prod.lift f f", "decl_nm": "category_theory.limits.prod.comp_diag"
{"src": "C : Type u,	_inst_1 : category C,	X Y : C,	_inst_2 : limits.has_binary_product Y Y,	f : X ⟶ Y	⊢ f ≫ limits.diag Y = limits.prod.lift f f", "decl_nm": "category_theory.limits.prod.comp_diag"
{"src": "⊢ ∀ {C : Type u} [_inst_1 : category C] {X Y : C} [_inst_2 : limits.has_binary_coproduct X Y],	    limits.coprod.map (𝟙 X) (𝟙 Y) = 𝟙 (X ⨿ Y)", "decl_nm": "category_theory.limits.coprod.map_id_id"
{"src": "C : Type u,	_inst_1 : category C,	X Y : C,	_inst_2 : limits.has_binary_coproduct X Y	⊢ limits.coprod.map (𝟙 X) (𝟙 Y) = 𝟙 (X ⨿ Y)", "decl_nm": "category_theory.limits.coprod.map_id_id"
{"src": "2 goals	C : Type u,	_inst_1 : category C,	X Y : C,	_inst_2 : limits.has_binary_coproduct X Y	⊢ limits.coprod.inl ≫ limits.coprod.map (𝟙 X) (𝟙 Y) = limits.coprod.inl ≫ 𝟙 (X ⨿ Y)		C : Type u,	_inst_1 : category C,	X Y : C,	_inst_2 : limits.has_binary_coproduct X Y	⊢ limits.coprod.inr ≫ limits.coprod.map (𝟙 X) (𝟙 Y) = limits.coprod.inr ≫ 𝟙 (X ⨿ Y)", "decl_nm": "category_theory.limits.coprod.map_id_id"
{"src": "C : Type u,	_inst_1 : category C,	X Y : C,	_inst_2 : limits.has_binary_coproduct X Y	⊢ limits.coprod.inr ≫ limits.coprod.map (𝟙 X) (𝟙 Y) = limits.coprod.inr ≫ 𝟙 (X ⨿ Y)", "decl_nm": "category_theory.limits.coprod.map_id_id"
{"src": "⊢ ∀ {C : Type u} [_inst_1 : category C] [_inst_2 : preadditive C] {X Y : C}	  [_inst_5 : limits.has_binary_biproduct X Y],	    limits.biprod.fst ≫ limits.biprod.inl + limits.biprod.snd ≫ limits.biprod.inr = 𝟙 (X ⊞ Y)", "decl_nm": "category_theory.limits.biprod.total"
{"src": "C : Type u,	_inst_1 : category C,	_inst_2 : preadditive C,	X Y : C,	_inst_5 : limits.has_binary_biproduct X Y	⊢ limits.biprod.fst ≫ limits.biprod.inl + limits.biprod.snd ≫ limits.biprod.inr = 𝟙 (X ⊞ Y)", "decl_nm": "category_theory.limits.biprod.total"
{"src": "4 goals	C : Type u,	_inst_1 : category C,	_inst_2 : preadditive C,	X Y : C,	_inst_5 : limits.has_binary_biproduct X Y	⊢ (limits.biprod.inl ≫ (limits.biprod.fst ≫ limits.biprod.inl + limits.biprod.snd ≫ limits.biprod.inr)) ≫	      limits.biprod.fst =	    (limits.biprod.inl ≫ 𝟙 (X ⊞ Y)) ≫ limits.biprod.fst		C : Type u,	_inst_1 : category C,	_inst_2 : preadditive C,	X Y : C,	_inst_5 : limits.has_binary_biproduct X Y	⊢ (limits.biprod.inl ≫ (limits.biprod.fst ≫ limits.biprod.inl + limits.biprod.snd ≫ limits.biprod.inr)) ≫	      limits.biprod.snd =	    (limits.biprod.inl ≫ 𝟙 (X ⊞ Y)) ≫ limits.biprod.snd		C : Type u,	_inst_1 : category C,	_inst_2 : preadditive C,	X Y : C,	_inst_5 : limits.has_binary_biproduct X Y	⊢ (limits.biprod.inr ≫ (limits.biprod.fst ≫ limits.biprod.inl + limits.biprod.snd ≫ limits.biprod.inr)) ≫	      limits.biprod.fst =	    (limits.biprod.inr ≫ 𝟙 (X ⊞ Y)) ≫ limits.biprod.fst		C : Type u,	_inst_1 : category C,	_inst_2 : preadditive C,	X Y : C,	_inst_5 : limits.has_binary_biproduct X Y	⊢ (limits.biprod.inr ≫ (limits.biprod.fst ≫ limits.biprod.inl + limits.biprod.snd ≫ limits.biprod.inr)) ≫	      limits.biprod.snd =	    (limits.biprod.inr ≫ 𝟙 (X ⊞ Y)) ≫ limits.biprod.snd", "decl_nm": "category_theory.limits.biprod.total"
{"src": "3 goals	C : Type u,	_inst_1 : category C,	_inst_2 : preadditive C,	X Y : C,	_inst_5 : limits.has_binary_biproduct X Y	⊢ (limits.biprod.inl ≫ (limits.biprod.fst ≫ limits.biprod.inl + limits.biprod.snd ≫ limits.biprod.inr)) ≫	      limits.biprod.snd =	    (limits.biprod.inl ≫ 𝟙 (X ⊞ Y)) ≫ limits.biprod.snd		C : Type u,	_inst_1 : category C,	_inst_2 : preadditive C,	X Y : C,	_inst_5 : limits.has_binary_biproduct X Y	⊢ (limits.biprod.inr ≫ (limits.biprod.fst ≫ limits.biprod.inl + limits.biprod.snd ≫ limits.biprod.inr)) ≫	      limits.biprod.fst =	    (limits.biprod.inr ≫ 𝟙 (X ⊞ Y)) ≫ limits.biprod.fst		C : Type u,	_inst_1 : category C,	_inst_2 : preadditive C,	X Y : C,	_inst_5 : limits.has_binary_biproduct X Y	⊢ (limits.biprod.inr ≫ (limits.biprod.fst ≫ limits.biprod.inl + limits.biprod.snd ≫ limits.biprod.inr)) ≫	      limits.biprod.snd =	    (limits.biprod.inr ≫ 𝟙 (X ⊞ Y)) ≫ limits.biprod.snd", "decl_nm": "category_theory.limits.biprod.total"
{"src": "2 goals	C : Type u,	_inst_1 : category C,	_inst_2 : preadditive C,	X Y : C,	_inst_5 : limits.has_binary_biproduct X Y	⊢ (limits.biprod.inr ≫ (limits.biprod.fst ≫ limits.biprod.inl + limits.biprod.snd ≫ limits.biprod.inr)) ≫	      limits.biprod.fst =	    (limits.biprod.inr ≫ 𝟙 (X ⊞ Y)) ≫ limits.biprod.fst		C : Type u,	_inst_1 : category C,	_inst_2 : preadditive C,	X Y : C,	_inst_5 : limits.has_binary_biproduct X Y	⊢ (limits.biprod.inr ≫ (limits.biprod.fst ≫ limits.biprod.inl + limits.biprod.snd ≫ limits.biprod.inr)) ≫	      limits.biprod.snd =	    (limits.biprod.inr ≫ 𝟙 (X ⊞ Y)) ≫ limits.biprod.snd", "decl_nm": "category_theory.limits.biprod.total"
{"src": "C : Type u,	_inst_1 : category C,	_inst_2 : preadditive C,	X Y : C,	_inst_5 : limits.has_binary_biproduct X Y	⊢ (limits.biprod.inr ≫ (limits.biprod.fst ≫ limits.biprod.inl + limits.biprod.snd ≫ limits.biprod.inr)) ≫	      limits.biprod.snd =	    (limits.biprod.inr ≫ 𝟙 (X ⊞ Y)) ≫ limits.biprod.snd", "decl_nm": "category_theory.limits.biprod.total"
{"src": "⊢ ∀ {C : Type u} [_inst_1 : category C] [_inst_2 : preadditive C] {J : Type v} [_inst_3 : decidable_eq J]	  [_inst_4 : fintype J] {f : J → C} [_inst_5 : limits.has_biproduct f] {T U : C} {g : Π (j : J), T ⟶ f j}	  {h : Π (j : J), f j ⟶ U},	    limits.biproduct.lift g ≫ limits.biproduct.desc h = finset.univ.sum (λ (j : J), g j ≫ h j)", "decl_nm": "category_theory.limits.biproduct.lift_desc"
{"src": "C : Type u,	_inst_1 : category C,	_inst_2 : preadditive C,	J : Type v,	_inst_3 : decidable_eq J,	_inst_4 : fintype J,	f : J → C,	_inst_5 : limits.has_biproduct f,	T U : C,	g : Π (j : J), T ⟶ f j,	h : Π (j : J), f j ⟶ U	⊢ limits.biproduct.lift g ≫ limits.biproduct.desc h = finset.univ.sum (λ (j : J), g j ≫ h j)", "decl_nm": "category_theory.limits.biproduct.lift_desc"
{"src": "⊢ ∀ {C : Type u} [_inst_1 : category C] {X Y : C} {f g : X ⟶ Y} (s : limits.fork f g),	    s.π.app zero ≫ g = s.π.app one", "decl_nm": "category_theory.limits.fork.app_zero_right"
{"src": "C : Type u,	_inst_1 : category C,	X Y : C,	f g : X ⟶ Y,	s : limits.fork f g	⊢ s.π.app zero ≫ g = s.π.app one", "decl_nm": "category_theory.limits.fork.app_zero_right"
{"src": "⊢ ∀ {C : Type u} [_inst_1 : category C] {X Y : C} (f : X ⟶ Y) [_inst_2 : limits.has_image f] [_inst_3 : mono f],	    (limits.image_mono_iso_source f).hom ≫ f = limits.image.ι f", "decl_nm": "category_theory.limits.image_mono_iso_source_hom_self"
{"src": "C : Type u,	_inst_1 : category C,	X Y : C,	f : X ⟶ Y,	_inst_2 : limits.has_image f,	_inst_3 : mono f	⊢ (limits.image_mono_iso_source f).hom ≫ f = limits.image.ι f", "decl_nm": "category_theory.limits.image_mono_iso_source_hom_self"
{"src": "C : Type u,	_inst_1 : category C,	X Y : C,	f : X ⟶ Y,	_inst_2 : limits.has_image f,	_inst_3 : mono f	⊢ (limits.image_mono_iso_source f).hom ≫ (limits.image_mono_iso_source f).inv ≫ limits.image.ι f =	    limits.image.ι f", "decl_nm": "category_theory.limits.image_mono_iso_source_hom_self"
{"src": "⊢ ∀ {C : Type u} [_inst_1 : category C] [_inst_2 : limits.has_zero_morphisms C] {X Y : C} {f : X ⟶ Y}	  (s : limits.cokernel_cofork f), f ≫ limits.cofork.π s = 0", "decl_nm": "category_theory.limits.cokernel_cofork.condition"
{"src": "C : Type u,	_inst_1 : category C,	_inst_2 : limits.has_zero_morphisms C,	X Y : C,	f : X ⟶ Y,	s : limits.cokernel_cofork f	⊢ f ≫ limits.cofork.π s = 0", "decl_nm": "category_theory.limits.cokernel_cofork.condition"
{"src": "⊢ ∀ {J : Type u} [_inst_1 : small_category J] (F : J ⥤ Type u) (x y : limit F),	    (∀ (j : J), limit.π F j x = limit.π F j y) → x = y", "decl_nm": "category_theory.limits.types.limit_ext"
{"src": "J : Type u,	_inst_1 : small_category J,	F : J ⥤ Type u,	x y : limit F,	w : ∀ (j : J), limit.π F j x = limit.π F j y	⊢ x = y", "decl_nm": "category_theory.limits.types.limit_ext"
{"src": "J : Type u,	_inst_1 : small_category J,	F : J ⥤ Type u,	x y : limit F,	w : ∀ (j : J), limit.π F j x = limit.π F j y	⊢ ⇑(types.limit_equiv_sections F) x = ⇑(types.limit_equiv_sections F) y", "decl_nm": "category_theory.limits.types.limit_ext"
{"src": "J : Type u,	_inst_1 : small_category J,	F : J ⥤ Type u,	x y : limit F,	w : ∀ (j : J), limit.π F j x = limit.π F j y,	j : J	⊢ ↑(⇑(types.limit_equiv_sections F) x) j = ↑(⇑(types.limit_equiv_sections F) y) j", "decl_nm": "category_theory.limits.types.limit_ext"
{"src": "⊢ ∀ {J : Type u} [_inst_1 : small_category J] (F : J ⥤ Type u) [_inst_2 : is_filtered_or_empty J] {i j : J}	  {xi : F.obj i} {xj : F.obj j},	    (types.colimit_cocone F).ι.app i xi = (types.colimit_cocone F).ι.app j xj ↔	      types.filtered_colimit.rel F ⟨i, xi⟩ ⟨j, xj⟩", "decl_nm": "category_theory.limits.types.filtered_colimit.colimit_eq_iff_aux"
{"src": "J : Type u,	_inst_1 : small_category J,	F : J ⥤ Type u,	_inst_2 : is_filtered_or_empty J,	i j : J,	xi : F.obj i,	xj : F.obj j	⊢ (types.colimit_cocone F).ι.app i xi = (types.colimit_cocone F).ι.app j xj ↔	    types.filtered_colimit.rel F ⟨i, xi⟩ ⟨j, xj⟩", "decl_nm": "category_theory.limits.types.filtered_colimit.colimit_eq_iff_aux"
{"src": "J : Type u,	_inst_1 : small_category J,	F : J ⥤ Type u,	_inst_2 : is_filtered_or_empty J,	i j : J,	xi : F.obj i,	xj : F.obj j	⊢ quot.mk (types.quot.rel F) ⟨i, xi⟩ = quot.mk (types.quot.rel F) ⟨j, xj⟩ ↔	    types.filtered_colimit.rel F ⟨i, xi⟩ ⟨j, xj⟩", "decl_nm": "category_theory.limits.types.filtered_colimit.colimit_eq_iff_aux"
{"src": "⊢ ∀ {C : Type u} [_inst_1 : category C] [_inst_2 : monoidal_category C], (λ_ (𝟙_ C)).inv = (ρ_ (𝟙_ C)).inv", "decl_nm": "category_theory.monoidal_category.unitors_inv_equal"
{"src": "C : Type u,	_inst_1 : category C,	_inst_2 : monoidal_category C	⊢ (λ_ (𝟙_ C)).inv = (ρ_ (𝟙_ C)).inv", "decl_nm": "category_theory.monoidal_category.unitors_inv_equal"
{"src": "C : Type u,	_inst_1 : category C,	_inst_2 : monoidal_category C	⊢ (ρ_ (𝟙_ C)).hom ≫ (λ_ (𝟙_ C)).inv = 𝟙 (𝟙_ C ⊗ 𝟙_ C)", "decl_nm": "category_theory.monoidal_category.unitors_inv_equal"
{"src": "⊢ ∀ {C : Type u} [_inst_1 : category C] [_inst_2 : monoidal_category C] {V W X Y Z : C} (f : V ≅ W) (g : X ⟶ Y)	  (h : Y ⟶ Z), (g ⊗ f.hom) ≫ (h ⊗ f.inv) = g ≫ h ⊗ 𝟙 V", "decl_nm": "category_theory.monoidal_category.tensor_hom_inv_id"
{"src": "C : Type u,	_inst_1 : category C,	_inst_2 : monoidal_category C,	V W X Y Z : C,	f : V ≅ W,	g : X ⟶ Y,	h : Y ⟶ Z	⊢ (g ⊗ f.hom) ≫ (h ⊗ f.inv) = g ≫ h ⊗ 𝟙 V", "decl_nm": "category_theory.monoidal_category.tensor_hom_inv_id"
{"src": "⊢ ∀ {C : Type u₁} [_inst_1 : category C] [_inst_2 : preadditive C] {D : Type u₁} [_inst_3 : category D]	  [_inst_4 : preadditive D] [_inst_5 : has_finite_biproducts D] (F : Mat_ C ⥤ D) [_inst_6 : F.additive] {M N : Mat_ C}	  (f : M ⟶ N),	    F.map f ≫ (Mat_.additive_obj_iso_biproduct F N).hom =	      (Mat_.additive_obj_iso_biproduct F M).hom ≫	        biproduct.matrix (λ (i : M.ι) (j : N.ι), F.map ((Mat_.embedding C).map (f i j)))", "decl_nm": "category_theory.Mat_.additive_obj_iso_biproduct_naturality"
{"src": "C : Type u₁,	_inst_1 : category C,	_inst_2 : preadditive C,	D : Type u₁,	_inst_3 : category D,	_inst_4 : preadditive D,	_inst_5 : has_finite_biproducts D,	F : Mat_ C ⥤ D,	_inst_6 : F.additive,	M N : Mat_ C,	f : M ⟶ N	⊢ F.map f ≫ (Mat_.additive_obj_iso_biproduct F N).hom =	    (Mat_.additive_obj_iso_biproduct F M).hom ≫	      biproduct.matrix (λ (i : M.ι) (j : N.ι), F.map ((Mat_.embedding C).map (f i j)))", "decl_nm": "category_theory.Mat_.additive_obj_iso_biproduct_naturality"
{"src": "C : Type u₁,	_inst_1 : category C,	_inst_2 : preadditive C,	D : Type u₁,	_inst_3 : category D,	_inst_4 : preadditive D,	_inst_5 : has_finite_biproducts D,	F : Mat_ C ⥤ D,	_inst_6 : F.additive,	M N : Mat_ C,	f : M ⟶ N,	j : N.ι	⊢ (F.map f ≫ (Mat_.additive_obj_iso_biproduct F N).hom) ≫	      biproduct.π (λ (i : N.ι), F.obj ((Mat_.embedding C).obj (N.X i))) j =	    ((Mat_.additive_obj_iso_biproduct F M).hom ≫	         biproduct.matrix (λ (i : M.ι) (j : N.ι), F.map ((Mat_.embedding C).map (f i j)))) ≫	      biproduct.π (λ (i : N.ι), F.obj ((Mat_.embedding C).obj (N.X i))) j", "decl_nm": "category_theory.Mat_.additive_obj_iso_biproduct_naturality"
{"src": "C : Type u₁,	_inst_1 : category C,	_inst_2 : preadditive C,	D : Type u₁,	_inst_3 : category D,	_inst_4 : preadditive D,	_inst_5 : has_finite_biproducts D,	F : Mat_ C ⥤ D,	_inst_6 : F.additive,	M N : Mat_ C,	f : M ⟶ N,	j : N.ι	⊢ (F.map f ≫	         F.map	             (biproduct.lift	                (λ (i j : N.ι) (k : punit), dite (j = i) (λ (h : j = i), eq_to_hom _) (λ (h : ¬j = i), 0))) ≫	           biproduct.lift	             (λ (j : N.ι),	                F.map	                  (biproduct.π	                     (λ (i : N.ι),	                        {ι := punit, F := punit.fintype, D := punit.decidable_eq, X := λ (_x : punit), N.X i})	                     j))) ≫	      biproduct.π	        (λ (i : N.ι), F.obj {ι := punit, F := punit.fintype, D := punit.decidable_eq, X := λ (_x : punit), N.X i})	        j =	    ((F.map	              (biproduct.lift	                 (λ (i j : M.ι) (k : punit), dite (j = i) (λ (h : j = i), eq_to_hom _) (λ (h : ¬j = i), 0))) ≫	            biproduct.lift	              (λ (j : M.ι),	                 F.map	                   (biproduct.π	                      (λ (i : M.ι),	                         {ι := punit, F := punit.fintype, D := punit.decidable_eq, X := λ (_x : punit), M.X i})	                      j))) ≫	         biproduct.matrix (λ (i : M.ι) (j : N.ι), F.map (λ (_x _x : punit), f i j))) ≫	      biproduct.π	        (λ (i : N.ι), F.obj {ι := punit, F := punit.fintype, D := punit.decidable_eq, X := λ (_x : punit), N.X i})	        j", "decl_nm": "category_theory.Mat_.additive_obj_iso_biproduct_naturality"
{"src": "C : Type u₁,	_inst_1 : category C,	_inst_2 : preadditive C,	D : Type u₁,	_inst_3 : category D,	_inst_4 : preadditive D,	_inst_5 : has_finite_biproducts D,	F : Mat_ C ⥤ D,	_inst_6 : F.additive,	M N : Mat_ C,	f : M ⟶ N,	j : N.ι	⊢ F.map (f ≫ λ (j_1 : N.ι) (k : punit), dite (j_1 = j) (λ (h : j_1 = j), eq_to_hom _) (λ (h : ¬j_1 = j), 0)) =	    F.map	        (biproduct.lift	           (λ (i j : M.ι) (k : punit), dite (j = i) (λ (h : j = i), eq_to_hom _) (λ (h : ¬j = i), 0))) ≫	      biproduct.lift	          (λ (j : M.ι),	             F.map	               (biproduct.π	                  (λ (i : M.ι),	                     {ι := punit, F := punit.fintype, D := punit.decidable_eq, X := λ (_x : punit), M.X i})	                  j)) ≫	        biproduct.desc (λ (j_1 : M.ι), F.map (λ (_x _x : punit), f j_1 j))", "decl_nm": "category_theory.Mat_.additive_obj_iso_biproduct_naturality"
{"src": "C : Type u₁,	_inst_1 : category C,	_inst_2 : preadditive C,	D : Type u₁,	_inst_3 : category D,	_inst_4 : preadditive D,	_inst_5 : has_finite_biproducts D,	F : Mat_ C ⥤ D,	_inst_6 : F.additive,	M N : Mat_ C,	f : M ⟶ N,	j : N.ι	⊢ F.map (f ≫ λ (j_1 : N.ι) (k : punit), dite (j_1 = j) (λ (h : j_1 = j), eq_to_hom _) (λ (h : ¬j_1 = j), 0)) =	    F.map	      (finset.univ.sum	         (λ (x : M.ι),	            (λ (j : M.ι) (k : punit), dite (j = x) (λ (h : j = x), eq_to_hom _) (λ (h : ¬j = x), 0)) ≫	              λ (_x _x : punit), f x j))", "decl_nm": "category_theory.Mat_.additive_obj_iso_biproduct_naturality"
{"src": "C : Type u₁,	_inst_1 : category C,	_inst_2 : preadditive C,	D : Type u₁,	_inst_3 : category D,	_inst_4 : preadditive D,	_inst_5 : has_finite_biproducts D,	F : Mat_ C ⥤ D,	_inst_6 : F.additive,	M N : Mat_ C,	f : M ⟶ N,	j : N.ι	⊢ F.map	      (λ (i : M.ι) (k : {ι := punit, F := punit.fintype, D := punit.decidable_eq, X := λ (_x : punit), N.X j}.ι),	         f i j ≫ eq_to_hom _) =	    F.map	      (finset.univ.sum	         (λ (x i : M.ι)	          (k : {ι := punit, F := punit.fintype, D := punit.decidable_eq, X := λ (_x : punit), N.X j}.ι),	            finset.univ.sum	              (λ (j_1 : {ι := punit, F := punit.fintype, D := punit.decidable_eq, X := λ (_x : punit), M.X x}.ι),	                 dite (i = x) (λ (h : i = x), eq_to_hom _) (λ (h : ¬i = x), 0) ≫ f x j)))", "decl_nm": "category_theory.Mat_.additive_obj_iso_biproduct_naturality"
{"src": "C : Type u₁,	_inst_1 : category C,	_inst_2 : preadditive C,	D : Type u₁,	_inst_3 : category D,	_inst_4 : preadditive D,	_inst_5 : has_finite_biproducts D,	F : Mat_ C ⥤ D,	_inst_6 : F.additive,	M N : Mat_ C,	f : M ⟶ N,	j : N.ι	⊢ F.map (λ (i : M.ι) (k : punit), f i j ≫ 𝟙 (N.X j)) =	    F.map	      (finset.univ.sum	         (λ (x i : M.ι) (k : punit),	            {punit.star}.sum	              (λ (j_1 : punit), dite (i = x) (λ (h : i = x), eq_to_hom _) (λ (h : ¬i = x), 0) ≫ f x j)))", "decl_nm": "category_theory.Mat_.additive_obj_iso_biproduct_naturality"
{"src": "C : Type u₁,	_inst_1 : category C,	_inst_2 : preadditive C,	D : Type u₁,	_inst_3 : category D,	_inst_4 : preadditive D,	_inst_5 : has_finite_biproducts D,	F : Mat_ C ⥤ D,	_inst_6 : F.additive,	M N : Mat_ C,	f : M ⟶ N,	j : N.ι	⊢ F.map (λ (i : M.ι) (k : punit), f i j ≫ 𝟙 (N.X j)) =	    F.map	      (finset.univ.sum	         (λ (x i : M.ι) (k : punit), dite (i = x) (λ (h : i = x), eq_to_hom _ ≫ f x j) (λ (h : ¬i = x), 0)))", "decl_nm": "category_theory.Mat_.additive_obj_iso_biproduct_naturality"
{"src": "C : Type u₁,	_inst_1 : category C,	_inst_2 : preadditive C,	D : Type u₁,	_inst_3 : category D,	_inst_4 : preadditive D,	_inst_5 : has_finite_biproducts D,	F : Mat_ C ⥤ D,	_inst_6 : F.additive,	M N : Mat_ C,	f : M ⟶ N,	j : N.ι	⊢ (λ (i : M.ι) (k : punit), f i j ≫ 𝟙 (N.X j)) =	    finset.univ.sum	      (λ (x i : M.ι) (k : punit), dite (i = x) (λ (h : i = x), eq_to_hom _ ≫ f x j) (λ (h : ¬i = x), 0))", "decl_nm": "category_theory.Mat_.additive_obj_iso_biproduct_naturality"
{"src": "C : Type u₁,	_inst_1 : category C,	_inst_2 : preadditive C,	D : Type u₁,	_inst_3 : category D,	_inst_4 : preadditive D,	_inst_5 : has_finite_biproducts D,	F : Mat_ C ⥤ D,	_inst_6 : F.additive,	M N : Mat_ C,	f : M ⟶ N,	j : N.ι	⊢ finset.univ.sum	      (λ (x i : M.ι) (k : punit), dite (i = x) (λ (h : i = x), eq_to_hom _ ≫ f x j) (λ (h : ¬i = x), 0)) =	    λ (i : M.ι) (k : punit), f i j ≫ 𝟙 (N.X j)", "decl_nm": "category_theory.Mat_.additive_obj_iso_biproduct_naturality"
{"src": "C : Type u₁,	_inst_1 : category C,	_inst_2 : preadditive C,	D : Type u₁,	_inst_3 : category D,	_inst_4 : preadditive D,	_inst_5 : has_finite_biproducts D,	F : Mat_ C ⥤ D,	_inst_6 : F.additive,	M N : Mat_ C,	f : M ⟶ N,	j : N.ι	⊢ (λ (i : M.ι) (k : punit), f i j ≫ 𝟙 (N.X j)) =	    λ (a : M.ι),	      finset.univ.sum	        (λ (c : M.ι) (k : punit), dite (a = c) (λ (h : a = c), eq_to_hom _ ≫ f c j) (λ (h : ¬a = c), 0))", "decl_nm": "category_theory.Mat_.additive_obj_iso_biproduct_naturality"
{"src": "C : Type u₁,	_inst_1 : category C,	_inst_2 : preadditive C,	D : Type u₁,	_inst_3 : category D,	_inst_4 : preadditive D,	_inst_5 : has_finite_biproducts D,	F : Mat_ C ⥤ D,	_inst_6 : F.additive,	M N : Mat_ C,	f : M ⟶ N,	j : N.ι	⊢ (λ (i : M.ι) (k : punit), f i j ≫ 𝟙 (N.X j)) =	    λ (a : M.ι) (a_1 : punit), ite (a ∈ finset.univ) (eq_to_hom _ ≫ f a j) 0", "decl_nm": "category_theory.Mat_.additive_obj_iso_biproduct_naturality"
{"src": "C : Type u₁,	_inst_1 : category C,	_inst_2 : preadditive C,	D : Type u₁,	_inst_3 : category D,	_inst_4 : preadditive D,	_inst_5 : has_finite_biproducts D,	F : Mat_ C ⥤ D,	_inst_6 : F.additive,	M N : Mat_ C,	f : M ⟶ N,	j : N.ι,	x : M.ι,	x_1 : punit	⊢ f x j ≫ 𝟙 (N.X j) = ite (x ∈ finset.univ) (eq_to_hom _ ≫ f x j) 0", "decl_nm": "category_theory.Mat_.additive_obj_iso_biproduct_naturality"
{"src": "⊢ ∀ {C : Type u} [_inst_1 : category C] [_inst_2 : preadditive C] (𝕜 : Type u_1) [_inst_3 : field 𝕜]	  [_inst_4 : has_kernels C] [_inst_5 : linear 𝕜 C] {X Y : C} [_inst_6 : simple X] [_inst_7 : simple Y],	    ((X ≅ Y) → false) → finrank 𝕜 (X ⟶ Y) = 0", "decl_nm": "category_theory.finrank_hom_simple_simple_eq_zero_of_not_iso"
{"src": "C : Type u,	_inst_1 : category C,	_inst_2 : preadditive C,	𝕜 : Type u_1,	_inst_3 : field 𝕜,	_inst_4 : has_kernels C,	_inst_5 : linear 𝕜 C,	X Y : C,	_inst_6 : simple X,	_inst_7 : simple Y,	h : (X ≅ Y) → false	⊢ finrank 𝕜 (X ⟶ Y) = 0", "decl_nm": "category_theory.finrank_hom_simple_simple_eq_zero_of_not_iso"
{"src": "C : Type u,	_inst_1 : category C,	_inst_2 : preadditive C,	𝕜 : Type u_1,	_inst_3 : field 𝕜,	_inst_4 : has_kernels C,	_inst_5 : linear 𝕜 C,	X Y : C,	_inst_6 : simple X,	_inst_7 : simple Y,	h : (X ≅ Y) → false,	_inst : subsingleton (X ⟶ Y)	⊢ finrank 𝕜 (X ⟶ Y) = 0", "decl_nm": "category_theory.finrank_hom_simple_simple_eq_zero_of_not_iso"
{"src": "⊢ ∀ {C : Type u} [_inst_1 : category C] {X : C} (J : grothendieck_topology C) (S : sieve X),	    S ∈ ⇑J X ↔ J.covers S (𝟙 X)", "decl_nm": "category_theory.grothendieck_topology.covering_iff_covers_id"
{"src": "C : Type u,	_inst_1 : category C,	X : C,	J : grothendieck_topology C,	S : sieve X	⊢ S ∈ ⇑J X ↔ J.covers S (𝟙 X)", "decl_nm": "category_theory.grothendieck_topology.covering_iff_covers_id"
{"src": "⊢ ∀ {C : Type u} [_inst_1 : category C] {J₁ J₂ : grothendieck_topology C}, ⇑J₁ = ⇑J₂ → J₁ = J₂", "decl_nm": "category_theory.grothendieck_topology.ext"
{"src": "C : Type u,	_inst_1 : category C,	J₁ J₂ : grothendieck_topology C,	h : ⇑J₁ = ⇑J₂	⊢ J₁ = J₂", "decl_nm": "category_theory.grothendieck_topology.ext"
{"src": "C : Type u,	_inst_1 : category C,	J₂ : grothendieck_topology C,	J₁_sieves : Π (X : C), set (sieve X),	J₁_top_mem' : ∀ (X : C), ⊤ ∈ J₁_sieves X,	J₁_pullback_stable' :	  ∀ ⦃X Y : C⦄ ⦃S : sieve X⦄ (f : Y ⟶ X), S ∈ J₁_sieves X → sieve.pullback f S ∈ J₁_sieves Y,	J₁_transitive' :	  ∀ ⦃X : C⦄ ⦃S : sieve X⦄,	    S ∈ J₁_sieves X →	    ∀ (R : sieve X),	      (∀ ⦃Y : C⦄ ⦃f : Y ⟶ X⦄, ⇑S f → sieve.pullback f R ∈ J₁_sieves Y) → R ∈ J₁_sieves X,	h :	  ⇑{sieves := J₁_sieves,	       top_mem' := J₁_top_mem',	       pullback_stable' := J₁_pullback_stable',	       transitive' := J₁_transitive'} =	    ⇑J₂	⊢ {sieves := J₁_sieves,	     top_mem' := J₁_top_mem',	     pullback_stable' := J₁_pullback_stable',	     transitive' := J₁_transitive'} =	    J₂", "decl_nm": "category_theory.grothendieck_topology.ext"
{"src": "C : Type u,	_inst_1 : category C,	J₁_sieves : Π (X : C), set (sieve X),	J₁_top_mem' : ∀ (X : C), ⊤ ∈ J₁_sieves X,	J₁_pullback_stable' :	  ∀ ⦃X Y : C⦄ ⦃S : sieve X⦄ (f : Y ⟶ X), S ∈ J₁_sieves X → sieve.pullback f S ∈ J₁_sieves Y,	J₁_transitive' :	  ∀ ⦃X : C⦄ ⦃S : sieve X⦄,	    S ∈ J₁_sieves X →	    ∀ (R : sieve X),	      (∀ ⦃Y : C⦄ ⦃f : Y ⟶ X⦄, ⇑S f → sieve.pullback f R ∈ J₁_sieves Y) → R ∈ J₁_sieves X,	J₂_sieves : Π (X : C), set (sieve X),	J₂_top_mem' : ∀ (X : C), ⊤ ∈ J₂_sieves X,	J₂_pullback_stable' :	  ∀ ⦃X Y : C⦄ ⦃S : sieve X⦄ (f : Y ⟶ X), S ∈ J₂_sieves X → sieve.pullback f S ∈ J₂_sieves Y,	J₂_transitive' :	  ∀ ⦃X : C⦄ ⦃S : sieve X⦄,	    S ∈ J₂_sieves X →	    ∀ (R : sieve X),	      (∀ ⦃Y : C⦄ ⦃f : Y ⟶ X⦄, ⇑S f → sieve.pullback f R ∈ J₂_sieves Y) → R ∈ J₂_sieves X,	h :	  ⇑{sieves := J₁_sieves,	       top_mem' := J₁_top_mem',	       pullback_stable' := J₁_pullback_stable',	       transitive' := J₁_transitive'} =	    ⇑{sieves := J₂_sieves,	       top_mem' := J₂_top_mem',	       pullback_stable' := J₂_pullback_stable',	       transitive' := J₂_transitive'}	⊢ {sieves := J₁_sieves,	     top_mem' := J₁_top_mem',	     pullback_stable' := J₁_pullback_stable',	     transitive' := J₁_transitive'} =	    {sieves := J₂_sieves,	     top_mem' := J₂_top_mem',	     pullback_stable' := J₂_pullback_stable',	     transitive' := J₂_transitive'}", "decl_nm": "category_theory.grothendieck_topology.ext"
{"src": "C : Type u,	_inst_1 : category C,	J₁_sieves : Π (X : C), set (sieve X),	J₁_top_mem' : ∀ (X : C), ⊤ ∈ J₁_sieves X,	J₁_pullback_stable' :	  ∀ ⦃X Y : C⦄ ⦃S : sieve X⦄ (f : Y ⟶ X), S ∈ J₁_sieves X → sieve.pullback f S ∈ J₁_sieves Y,	J₁_transitive' :	  ∀ ⦃X : C⦄ ⦃S : sieve X⦄,	    S ∈ J₁_sieves X →	    ∀ (R : sieve X),	      (∀ ⦃Y : C⦄ ⦃f : Y ⟶ X⦄, ⇑S f → sieve.pullback f R ∈ J₁_sieves Y) → R ∈ J₁_sieves X,	J₂_sieves : Π (X : C), set (sieve X),	J₂_top_mem' : ∀ (X : C), ⊤ ∈ J₂_sieves X,	J₂_pullback_stable' :	  ∀ ⦃X Y : C⦄ ⦃S : sieve X⦄ (f : Y ⟶ X), S ∈ J₂_sieves X → sieve.pullback f S ∈ J₂_sieves Y,	J₂_transitive' :	  ∀ ⦃X : C⦄ ⦃S : sieve X⦄,	    S ∈ J₂_sieves X →	    ∀ (R : sieve X),	      (∀ ⦃Y : C⦄ ⦃f : Y ⟶ X⦄, ⇑S f → sieve.pullback f R ∈ J₂_sieves Y) → R ∈ J₂_sieves X,	h :	  ⇑{sieves := J₁_sieves,	       top_mem' := J₁_top_mem',	       pullback_stable' := J₁_pullback_stable',	       transitive' := J₁_transitive'} =	    ⇑{sieves := J₂_sieves,	       top_mem' := J₂_top_mem',	       pullback_stable' := J₂_pullback_stable',	       transitive' := J₂_transitive'}	⊢ J₁_sieves = J₂_sieves", "decl_nm": "category_theory.grothendieck_topology.ext"
{"src": "⊢ ∀ {C : Type u₁} [_inst_1 : category C] {X Y : C} (f : Y ⟶ X) [_inst_3 : has_pullbacks C] {ι : Type u_1}	  (Z : ι → C) (g : Π (i : ι), Z i ⟶ X),	    presieve.of_arrows (λ (i : ι), pullback (g i) f) (λ (i : ι), pullback.snd) =	      presieve.pullback_arrows f (presieve.of_arrows Z g)", "decl_nm": "category_theory.presieve.of_arrows_pullback"
{"src": "C : Type u₁,	_inst_1 : category C,	X Y : C,	f : Y ⟶ X,	_inst_3 : has_pullbacks C,	ι : Type u_1,	Z : ι → C,	g : Π (i : ι), Z i ⟶ X	⊢ presieve.of_arrows (λ (i : ι), pullback (g i) f) (λ (i : ι), pullback.snd) =	    presieve.pullback_arrows f (presieve.of_arrows Z g)", "decl_nm": "category_theory.presieve.of_arrows_pullback"
{"src": "C : Type u₁,	_inst_1 : category C,	X Y : C,	f : Y ⟶ X,	_inst_3 : has_pullbacks C,	ι : Type u_1,	Z : ι → C,	g : Π (i : ι), Z i ⟶ X,	T : C,	h : T ⟶ Y	⊢ h ∈ presieve.of_arrows (λ (i : ι), pullback (g i) f) (λ (i : ι), pullback.snd) ↔	    h ∈ presieve.pullback_arrows f (presieve.of_arrows Z g)", "decl_nm": "category_theory.presieve.of_arrows_pullback"
{"src": "2 goals	C : Type u₁,	_inst_1 : category C,	X Y : C,	f : Y ⟶ X,	_inst_3 : has_pullbacks C,	ι : Type u_1,	Z : ι → C,	g : Π (i : ι), Z i ⟶ X,	T : C,	h : T ⟶ Y	⊢ h ∈ presieve.of_arrows (λ (i : ι), pullback (g i) f) (λ (i : ι), pullback.snd) →	  h ∈ presieve.pullback_arrows f (presieve.of_arrows Z g)		C : Type u₁,	_inst_1 : category C,	X Y : C,	f : Y ⟶ X,	_inst_3 : has_pullbacks C,	ι : Type u_1,	Z : ι → C,	g : Π (i : ι), Z i ⟶ X,	T : C,	h : T ⟶ Y	⊢ h ∈ presieve.pullback_arrows f (presieve.of_arrows Z g) →	  h ∈ presieve.of_arrows (λ (i : ι), pullback (g i) f) (λ (i : ι), pullback.snd)", "decl_nm": "category_theory.presieve.of_arrows_pullback"
{"src": "2 goals	C : Type u₁,	_inst_1 : category C,	X Y : C,	f : Y ⟶ X,	_inst_3 : has_pullbacks C,	ι : Type u_1,	Z : ι → C,	g : Π (i : ι), Z i ⟶ X,	hk : ι,	ᾰ :	  (limit.cone (cospan (g hk) f)).π.app walking_cospan.right ∈	    presieve.of_arrows (λ (i : ι), pullback (g i) f) (λ (i : ι), pullback.snd)	⊢ (limit.cone (cospan (g hk) f)).π.app walking_cospan.right ∈ presieve.pullback_arrows f (presieve.of_arrows Z g)		C : Type u₁,	_inst_1 : category C,	X Y : C,	f : Y ⟶ X,	_inst_3 : has_pullbacks C,	ι : Type u_1,	Z : ι → C,	g : Π (i : ι), Z i ⟶ X,	T : C,	h : T ⟶ Y	⊢ h ∈ presieve.pullback_arrows f (presieve.of_arrows Z g) →	  h ∈ presieve.of_arrows (λ (i : ι), pullback (g i) f) (λ (i : ι), pullback.snd)", "decl_nm": "category_theory.presieve.of_arrows_pullback"
{"src": "C : Type u₁,	_inst_1 : category C,	X Y : C,	f : Y ⟶ X,	_inst_3 : has_pullbacks C,	ι : Type u_1,	Z : ι → C,	g : Π (i : ι), Z i ⟶ X,	T : C,	h : T ⟶ Y	⊢ h ∈ presieve.pullback_arrows f (presieve.of_arrows Z g) →	  h ∈ presieve.of_arrows (λ (i : ι), pullback (g i) f) (λ (i : ι), pullback.snd)", "decl_nm": "category_theory.presieve.of_arrows_pullback"
{"src": "C : Type u₁,	_inst_1 : category C,	X Y : C,	f : Y ⟶ X,	_inst_3 : has_pullbacks C,	ι : Type u_1,	Z : ι → C,	g : Π (i : ι), Z i ⟶ X,	W : C,	k : W ⟶ X,	hk₁ : presieve.of_arrows Z g k,	ᾰ : (limit.cone (cospan k f)).π.app walking_cospan.right ∈ presieve.pullback_arrows f (presieve.of_arrows Z g)	⊢ (limit.cone (cospan k f)).π.app walking_cospan.right ∈	    presieve.of_arrows (λ (i : ι), pullback (g i) f) (λ (i : ι), pullback.snd)", "decl_nm": "category_theory.presieve.of_arrows_pullback"
{"src": "C : Type u₁,	_inst_1 : category C,	X Y : C,	f : Y ⟶ X,	_inst_3 : has_pullbacks C,	ι : Type u_1,	Z : ι → C,	g : Π (i : ι), Z i ⟶ X,	i : ι,	hk₁ : presieve.of_arrows Z g (g i),	ᾰ : (limit.cone (cospan (g i) f)).π.app walking_cospan.right ∈ presieve.pullback_arrows f (presieve.of_arrows Z g)	⊢ (limit.cone (cospan (g i) f)).π.app walking_cospan.right ∈	    presieve.of_arrows (λ (i : ι), pullback (g i) f) (λ (i : ι), pullback.snd)", "decl_nm": "category_theory.presieve.of_arrows_pullback"
{"src": "⊢ ∀ {C : Type u₁} [_inst_1 : category C] {X Y : C} {S : sieve X} (f : Y ⟶ X),	    ⇑S f ↔ sieve.pullback f S = ⊤", "decl_nm": "category_theory.sieve.pullback_eq_top_iff_mem"
{"src": "C : Type u₁,	_inst_1 : category C,	X Y : C,	S : sieve X,	f : Y ⟶ X	⊢ ⇑S f ↔ sieve.pullback f S = ⊤", "decl_nm": "category_theory.sieve.pullback_eq_top_iff_mem"
{"src": "⊢ ∀ {C : Type u₁} [_inst_1 : category C] {D : Type u₂} [_inst_2 : category D] {S : D} {T : C ⥤ D}	  (f : structured_arrow S T), f = structured_arrow.mk f.hom", "decl_nm": "category_theory.structured_arrow.eq_mk"
{"src": "C : Type u₁,	_inst_1 : category C,	D : Type u₂,	_inst_2 : category D,	S : D,	T : C ⥤ D,	f : structured_arrow S T	⊢ f = structured_arrow.mk f.hom", "decl_nm": "category_theory.structured_arrow.eq_mk"
{"src": "C : Type u₁,	_inst_1 : category C,	D : Type u₂,	_inst_2 : category D,	S : D,	T : C ⥤ D,	f_left : auto_param (discrete punit) (name.mk_string "obviously" name.anonymous),	f_right : auto_param C (name.mk_string "obviously" name.anonymous),	f_hom : (functor.from_punit S).obj f_left ⟶ T.obj f_right	⊢ {left := f_left, right := f_right, hom := f_hom} =	    structured_arrow.mk {left := f_left, right := f_right, hom := f_hom}.hom", "decl_nm": "category_theory.structured_arrow.eq_mk"
{"src": "C : Type u₁,	_inst_1 : category C,	D : Type u₂,	_inst_2 : category D,	S : D,	T : C ⥤ D,	f_left : auto_param (discrete punit) (name.mk_string "obviously" name.anonymous),	f_right : auto_param C (name.mk_string "obviously" name.anonymous),	f_hom : (functor.from_punit S).obj f_left ⟶ T.obj f_right	⊢ f_left = punit.star", "decl_nm": "category_theory.structured_arrow.eq_mk"
{"src": "⊢ ∀ {C : Type u₁} [_inst_1 : category C] {B A₁ A₂ : C} (X : subobject B) (f : A₁ ⟶ B) [_inst_3 : mono f]	  (g : A₂ ⟶ B) [_inst_4 : mono g] (h₁ : X ≤ subobject.mk f) (h₂ : subobject.mk f ≤ subobject.mk g),	    X.of_le_mk f h₁ ≫ subobject.of_mk_le_mk f g h₂ = X.of_le_mk g _", "decl_nm": "category_theory.subobject.of_le_mk_comp_of_mk_le_mk"
{"src": "C : Type u₁,	_inst_1 : category C,	B A₁ A₂ : C,	X : subobject B,	f : A₁ ⟶ B,	_inst_3 : mono f,	g : A₂ ⟶ B,	_inst_4 : mono g,	h₁ : X ≤ subobject.mk f,	h₂ : subobject.mk f ≤ subobject.mk g	⊢ X.of_le_mk f h₁ ≫ subobject.of_mk_le_mk f g h₂ = X.of_le_mk g _", "decl_nm": "category_theory.subobject.of_le_mk_comp_of_mk_le_mk"
{"src": "⊢ ∀ (n : ℕ) (i : fin (ones n).length), (ones n).blocks_fun i = 1", "decl_nm": "composition.ones_blocks_fun"
{"src": "n : ℕ,	i : fin (ones n).length	⊢ (ones n).blocks_fun i = 1", "decl_nm": "composition.ones_blocks_fun"
{"src": "⊢ ∀ {ι : Type u} {α : Type v} [_inst_1 : fintype ι] {t : ι → finset α} [_inst_2 : decidable_eq α] {n : ℕ},	    fintype.card ι = n + 1 →	    (∀ (s : finset ι), s.card ≤ (s.bUnion t).card) →	    (∀ {ι' : Type u} [_inst_3 : fintype ι'] (t' : ι' → finset α),	       fintype.card ι' ≤ n →	       (∀ (s' : finset ι'), s'.card ≤ (s'.bUnion t').card) →	       (∃ (f : ι' → α), function.injective f ∧ ∀ (x : ι'), f x ∈ t' x)) →	    (∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x)", "decl_nm": "hall_marriage_theorem.hall_hard_inductive_step"
{"src": "ι : Type u,	α : Type v,	_inst_1 : fintype ι,	t : ι → finset α,	_inst_2 : decidable_eq α,	n : ℕ,	hn : fintype.card ι = n + 1,	ht : ∀ (s : finset ι), s.card ≤ (s.bUnion t).card,	ih :	  ∀ {ι' : Type u} [_inst_3 : fintype ι'] (t' : ι' → finset α),	    fintype.card ι' ≤ n →	    (∀ (s' : finset ι'), s'.card ≤ (s'.bUnion t').card) →	    (∃ (f : ι' → α), function.injective f ∧ ∀ (x : ι'), f x ∈ t' x)	⊢ ∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x", "decl_nm": "hall_marriage_theorem.hall_hard_inductive_step"
{"src": "2 goals	ι : Type u,	α : Type v,	_inst_1 : fintype ι,	t : ι → finset α,	_inst_2 : decidable_eq α,	n : ℕ,	hn : fintype.card ι = n + 1,	ht : ∀ (s : finset ι), s.card ≤ (s.bUnion t).card,	ih :	  ∀ {ι' : Type u} [_inst_3 : fintype ι'] (t' : ι' → finset α),	    fintype.card ι' ≤ n →	    (∀ (s' : finset ι'), s'.card ≤ (s'.bUnion t').card) →	    (∃ (f : ι' → α), function.injective f ∧ ∀ (x : ι'), f x ∈ t' x),	h : ∀ (s : finset ι), s.nonempty → s ≠ univ → s.card < (s.bUnion t).card	⊢ ∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x		ι : Type u,	α : Type v,	_inst_1 : fintype ι,	t : ι → finset α,	_inst_2 : decidable_eq α,	n : ℕ,	hn : fintype.card ι = n + 1,	ht : ∀ (s : finset ι), s.card ≤ (s.bUnion t).card,	ih :	  ∀ {ι' : Type u} [_inst_3 : fintype ι'] (t' : ι' → finset α),	    fintype.card ι' ≤ n →	    (∀ (s' : finset ι'), s'.card ≤ (s'.bUnion t').card) →	    (∃ (f : ι' → α), function.injective f ∧ ∀ (x : ι'), f x ∈ t' x),	h : ¬∀ (s : finset ι), s.nonempty → s ≠ univ → s.card < (s.bUnion t).card	⊢ ∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x", "decl_nm": "hall_marriage_theorem.hall_hard_inductive_step"
{"src": "ι : Type u,	α : Type v,	_inst_1 : fintype ι,	t : ι → finset α,	_inst_2 : decidable_eq α,	n : ℕ,	hn : fintype.card ι = n + 1,	ht : ∀ (s : finset ι), s.card ≤ (s.bUnion t).card,	ih :	  ∀ {ι' : Type u} [_inst_3 : fintype ι'] (t' : ι' → finset α),	    fintype.card ι' ≤ n →	    (∀ (s' : finset ι'), s'.card ≤ (s'.bUnion t').card) →	    (∃ (f : ι' → α), function.injective f ∧ ∀ (x : ι'), f x ∈ t' x),	h : ¬∀ (s : finset ι), s.nonempty → s ≠ univ → s.card < (s.bUnion t).card	⊢ ∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x", "decl_nm": "hall_marriage_theorem.hall_hard_inductive_step"
{"src": "ι : Type u,	α : Type v,	_inst_1 : fintype ι,	t : ι → finset α,	_inst_2 : decidable_eq α,	n : ℕ,	hn : fintype.card ι = n + 1,	ht : ∀ (s : finset ι), s.card ≤ (s.bUnion t).card,	ih :	  ∀ {ι' : Type u} [_inst_3 : fintype ι'] (t' : ι' → finset α),	    fintype.card ι' ≤ n →	    (∀ (s' : finset ι'), s'.card ≤ (s'.bUnion t').card) →	    (∃ (f : ι' → α), function.injective f ∧ ∀ (x : ι'), f x ∈ t' x),	h : ∃ (s : finset ι), s.nonempty ∧ s ≠ univ ∧ (s.bUnion t).card ≤ s.card	⊢ ∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x", "decl_nm": "hall_marriage_theorem.hall_hard_inductive_step"
{"src": "ι : Type u,	α : Type v,	_inst_1 : fintype ι,	t : ι → finset α,	_inst_2 : decidable_eq α,	n : ℕ,	hn : fintype.card ι = n + 1,	ht : ∀ (s : finset ι), s.card ≤ (s.bUnion t).card,	ih :	  ∀ {ι' : Type u} [_inst_3 : fintype ι'] (t' : ι' → finset α),	    fintype.card ι' ≤ n →	    (∀ (s' : finset ι'), s'.card ≤ (s'.bUnion t').card) →	    (∃ (f : ι' → α), function.injective f ∧ ∀ (x : ι'), f x ∈ t' x),	s : finset ι,	sne : s.nonempty,	snu : s ≠ univ,	sle : (s.bUnion t).card ≤ s.card	⊢ ∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x", "decl_nm": "hall_marriage_theorem.hall_hard_inductive_step"
{"src": "ι : Type u,	α : Type v,	_inst_1 : fintype ι,	t : ι → finset α,	_inst_2 : decidable_eq α,	n : ℕ,	hn : fintype.card ι = n + 1,	ht : ∀ (s : finset ι), s.card ≤ (s.bUnion t).card,	ih :	  ∀ {ι' : Type u} [_inst_3 : fintype ι'] (t' : ι' → finset α),	    fintype.card ι' ≤ n →	    (∀ (s' : finset ι'), s'.card ≤ (s'.bUnion t').card) →	    (∃ (f : ι' → α), function.injective f ∧ ∀ (x : ι'), f x ∈ t' x),	s : finset ι,	sne : s.nonempty,	snu : s ≠ univ,	sle : (s.bUnion t).card ≤ s.card,	seq : s.card = (s.bUnion t).card	⊢ ∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x", "decl_nm": "hall_marriage_theorem.hall_hard_inductive_step"
{"src": "⊢ ∀ {ι : Type u} {α : Type v} [_inst_1 : fintype ι] {t : ι → finset α} [_inst_2 : decidable_eq α] {n : ℕ},	    fintype.card ι = n →	    (∀ (s : finset ι), s.card ≤ (s.bUnion t).card) →	    (∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x)", "decl_nm": "hall_marriage_theorem.hall_hard_inductive"
{"src": "ι : Type u,	α : Type v,	_inst_1 : fintype ι,	t : ι → finset α,	_inst_2 : decidable_eq α,	n : ℕ,	hn : fintype.card ι = n,	ht : ∀ (s : finset ι), s.card ≤ (s.bUnion t).card	⊢ ∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x", "decl_nm": "hall_marriage_theorem.hall_hard_inductive"
{"src": "α : Type v,	_inst_2 : decidable_eq α,	n : ℕ	⊢ ∀ {ι : Type u} [_inst_1 : fintype ι] {t : ι → finset α},	    fintype.card ι = n →	    (∀ (s : finset ι), s.card ≤ (s.bUnion t).card) →	    (∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x)", "decl_nm": "hall_marriage_theorem.hall_hard_inductive"
{"src": "α : Type v,	_inst_2 : decidable_eq α,	n n' : ℕ,	ih :	  ∀ (m : ℕ),	    m < n' →	    ∀ {ι : Type u} [_inst_1 : fintype ι] {t : ι → finset α},	      fintype.card ι = m →	      (∀ (s : finset ι), s.card ≤ (s.bUnion t).card) →	      (∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x)	⊢ ∀ {ι : Type u} [_inst_1 : fintype ι] {t : ι → finset α},	    fintype.card ι = n' →	    (∀ (s : finset ι), s.card ≤ (s.bUnion t).card) →	    (∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x)", "decl_nm": "hall_marriage_theorem.hall_hard_inductive"
{"src": "α : Type v,	_inst_2 : decidable_eq α,	n n' : ℕ,	ih :	  ∀ (m : ℕ),	    m < n' →	    ∀ {ι : Type u} [_inst_1 : fintype ι] {t : ι → finset α},	      fintype.card ι = m →	      (∀ (s : finset ι), s.card ≤ (s.bUnion t).card) →	      (∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x),	ι : Type u,	_inst_1 : fintype ι,	t : ι → finset α,	hn : fintype.card ι = n',	ht : ∀ (s : finset ι), s.card ≤ (s.bUnion t).card	⊢ ∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x", "decl_nm": "hall_marriage_theorem.hall_hard_inductive"
{"src": "2 goals	α : Type v,	_inst_2 : decidable_eq α,	n : ℕ,	ι : Type u,	_inst_1 : fintype ι,	t : ι → finset α,	ht : ∀ (s : finset ι), s.card ≤ (s.bUnion t).card,	ih :	  ∀ (m : ℕ),	    m < 0 →	    ∀ {ι : Type u} [_inst_1 : fintype ι] {t : ι → finset α},	      fintype.card ι = m →	      (∀ (s : finset ι), s.card ≤ (s.bUnion t).card) →	      (∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x),	hn : fintype.card ι = 0	⊢ ∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x		α : Type v,	_inst_2 : decidable_eq α,	n : ℕ,	ι : Type u,	_inst_1 : fintype ι,	t : ι → finset α,	ht : ∀ (s : finset ι), s.card ≤ (s.bUnion t).card,	n' : ℕ,	ih :	  ∀ (m : ℕ),	    m < n'.succ →	    ∀ {ι : Type u} [_inst_1 : fintype ι] {t : ι → finset α},	      fintype.card ι = m →	      (∀ (s : finset ι), s.card ≤ (s.bUnion t).card) →	      (∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x),	hn : fintype.card ι = n'.succ	⊢ ∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x", "decl_nm": "hall_marriage_theorem.hall_hard_inductive"
{"src": "α : Type v,	_inst_2 : decidable_eq α,	n : ℕ,	ι : Type u,	_inst_1 : fintype ι,	t : ι → finset α,	ht : ∀ (s : finset ι), s.card ≤ (s.bUnion t).card,	n' : ℕ,	ih :	  ∀ (m : ℕ),	    m < n'.succ →	    ∀ {ι : Type u} [_inst_1 : fintype ι] {t : ι → finset α},	      fintype.card ι = m →	      (∀ (s : finset ι), s.card ≤ (s.bUnion t).card) →	      (∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x),	hn : fintype.card ι = n'.succ	⊢ ∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x", "decl_nm": "hall_marriage_theorem.hall_hard_inductive"
{"src": "α : Type v,	_inst_2 : decidable_eq α,	n : ℕ,	ι : Type u,	_inst_1 : fintype ι,	t : ι → finset α,	ht : ∀ (s : finset ι), s.card ≤ (s.bUnion t).card,	n' : ℕ,	ih :	  ∀ (m : ℕ),	    m < n'.succ →	    ∀ {ι : Type u} [_inst_1 : fintype ι] {t : ι → finset α},	      fintype.card ι = m →	      (∀ (s : finset ι), s.card ≤ (s.bUnion t).card) →	      (∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x),	hn : fintype.card ι = n'.succ	⊢ ∀ {ι' : Type u} [_inst_3 : fintype ι'] (t' : ι' → finset α),	    fintype.card ι' ≤ n' →	    (∀ (s' : finset ι'), s'.card ≤ (s'.bUnion t').card) →	    (∃ (f : ι' → α), function.injective f ∧ ∀ (x : ι'), f x ∈ t' x)", "decl_nm": "hall_marriage_theorem.hall_hard_inductive"
{"src": "α : Type v,	_inst_2 : decidable_eq α,	n : ℕ,	ι : Type u,	_inst_1 : fintype ι,	t : ι → finset α,	ht : ∀ (s : finset ι), s.card ≤ (s.bUnion t).card,	n' : ℕ,	ih :	  ∀ (m : ℕ),	    m < n'.succ →	    ∀ {ι : Type u} [_inst_1 : fintype ι] {t : ι → finset α},	      fintype.card ι = m →	      (∀ (s : finset ι), s.card ≤ (s.bUnion t).card) →	      (∃ (f : ι → α), function.injective f ∧ ∀ (x : ι), f x ∈ t x),	hn : fintype.card ι = n'.succ,	ι' : Type u,	_inst_3 : fintype ι',	t' : ι' → finset α,	hι' : fintype.card ι' ≤ n'	⊢ (∀ (s' : finset ι'), s'.card ≤ (s'.bUnion t').card) →	  (∃ (f : ι' → α), function.injective f ∧ ∀ (x : ι'), f x ∈ t' x)", "decl_nm": "hall_marriage_theorem.hall_hard_inductive"
{"src": "⊢ ∀ {V : Type u} (G : simple_graph V) (v : V), disjoint (G.neighbor_set v) (Gᶜ.neighbor_set v)", "decl_nm": "simple_graph.compl_neighbor_set_disjoint"
{"src": "V : Type u,	G : simple_graph V,	v : V	⊢ disjoint (G.neighbor_set v) (Gᶜ.neighbor_set v)", "decl_nm": "simple_graph.compl_neighbor_set_disjoint"
{"src": "V : Type u,	G : simple_graph V,	v : V	⊢ G.neighbor_set v ∩ Gᶜ.neighbor_set v ⊆ ∅", "decl_nm": "simple_graph.compl_neighbor_set_disjoint"
{"src": "V : Type u,	G : simple_graph V,	v w : V,	h : w ∈ G.neighbor_set v,	h' : w ∈ Gᶜ.neighbor_set v	⊢ w ∈ ∅", "decl_nm": "simple_graph.compl_neighbor_set_disjoint"
{"src": "V : Type u,	G : simple_graph V,	v w : V,	h : w ∈ G.neighbor_set v,	h' : v ≠ w ∧ ¬G.adj v w	⊢ w ∈ ∅", "decl_nm": "simple_graph.compl_neighbor_set_disjoint"
{"src": "⊢ ∀ {V : Type u} (G : simple_graph V) (v w : V), G.common_neighbors v w = G.common_neighbors w v", "decl_nm": "simple_graph.common_neighbors_symm"
{"src": "V : Type u,	G : simple_graph V,	v w : V	⊢ G.common_neighbors v w = G.common_neighbors w v", "decl_nm": "simple_graph.common_neighbors_symm"
{"src": "V : Type u,	G : simple_graph V,	v w : V	⊢ G.neighbor_set w ∩ G.neighbor_set v = G.common_neighbors w v", "decl_nm": "simple_graph.common_neighbors_symm"
{"src": "⊢ ∀ {V : Type u} [_inst_1 : fintype V] [_inst_2 : decidable_eq V] (v : V), ⊤.degree v = fintype.card V - 1", "decl_nm": "simple_graph.complete_graph_degree"
{"src": "V : Type u,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	v : V	⊢ ⊤.degree v = fintype.card V - 1", "decl_nm": "simple_graph.complete_graph_degree"
{"src": "2 goals	V : Type u,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	v : V	⊢ ⊤.degree v = univ.card.pred		V : Type u,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	v : V	⊢ fintype V", "decl_nm": "simple_graph.complete_graph_degree"
{"src": "⊢ ∀ {V : Type u} (G : simple_graph V) [_inst_1 : fintype V] [_inst_2 : decidable_rel G.adj] [_inst_3 : nonempty V],	    ∃ (v : V), G.min_degree = G.degree v", "decl_nm": "simple_graph.exists_minimal_degree_vertex"
{"src": "V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_rel G.adj,	_inst_3 : nonempty V	⊢ ∃ (v : V), G.min_degree = G.degree v", "decl_nm": "simple_graph.exists_minimal_degree_vertex"
{"src": "V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_rel G.adj,	_inst_3 : nonempty V,	t : ℕ,	ht : (image (λ (v : V), G.degree v) univ).min = some t	⊢ ∃ (v : V), G.min_degree = G.degree v", "decl_nm": "simple_graph.exists_minimal_degree_vertex"
{"src": "V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_rel G.adj,	_inst_3 : nonempty V,	v : V,	h_w : v ∈ univ,	ht : (image (λ (v : V), G.degree v) univ).min = some (G.degree v)	⊢ ∃ (v : V), G.min_degree = G.degree v", "decl_nm": "simple_graph.exists_minimal_degree_vertex"
{"src": "⊢ ∀ {V : Type u} (G : simple_graph V) [_inst_1 : fintype V] [_inst_2 : decidable_eq V]	  [_inst_3 : decidable_rel G.adj] (v : V),	    odd (G.degree v) → odd (filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) univ).card", "decl_nm": "simple_graph.odd_card_odd_degree_vertices_ne"
{"src": "V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v)	⊢ odd (filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) univ).card", "decl_nm": "simple_graph.odd_card_odd_degree_vertices_ne"
{"src": "V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (filter (λ (v : V), odd (G.degree v)) univ).card = 2 * k	⊢ odd (filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) univ).card", "decl_nm": "simple_graph.odd_card_odd_degree_vertices_ne"
{"src": "2 goals	V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (filter (λ (v : V), odd (G.degree v)) univ).card = 2 * k	⊢ 0 < k		V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (filter (λ (v : V), odd (G.degree v)) univ).card = 2 * k,	hk : 0 < k	⊢ odd (filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) univ).card", "decl_nm": "simple_graph.odd_card_odd_degree_vertices_ne"
{"src": "3 goals	V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (filter (λ (v : V), odd (G.degree v)) univ).card = 2 * k	⊢ (filter (λ (v : V), odd (G.degree v)) univ).nonempty		V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (filter (λ (v : V), odd (G.degree v)) univ).card = 2 * k,	hh : (filter (λ (v : V), odd (G.degree v)) univ).nonempty	⊢ 0 < k		V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (filter (λ (v : V), odd (G.degree v)) univ).card = 2 * k,	hk : 0 < k	⊢ odd (filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) univ).card", "decl_nm": "simple_graph.odd_card_odd_degree_vertices_ne"
{"src": "3 goals	V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (filter (λ (v : V), odd (G.degree v)) univ).card = 2 * k	⊢ v ∈ filter (λ (v : V), odd (G.degree v)) univ		V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (filter (λ (v : V), odd (G.degree v)) univ).card = 2 * k,	hh : (filter (λ (v : V), odd (G.degree v)) univ).nonempty	⊢ 0 < k		V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (filter (λ (v : V), odd (G.degree v)) univ).card = 2 * k,	hk : 0 < k	⊢ odd (filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) univ).card", "decl_nm": "simple_graph.odd_card_odd_degree_vertices_ne"
{"src": "3 goals	V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (filter (λ (v : V), odd (G.degree v)) univ).card = 2 * k	⊢ odd (G.degree v)		V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (filter (λ (v : V), odd (G.degree v)) univ).card = 2 * k,	hh : (filter (λ (v : V), odd (G.degree v)) univ).nonempty	⊢ 0 < k		V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (filter (λ (v : V), odd (G.degree v)) univ).card = 2 * k,	hk : 0 < k	⊢ odd (filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) univ).card", "decl_nm": "simple_graph.odd_card_odd_degree_vertices_ne"
{"src": "2 goals	V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (filter (λ (v : V), odd (G.degree v)) univ).card = 2 * k,	hh : (filter (λ (v : V), odd (G.degree v)) univ).nonempty	⊢ 0 < k		V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (filter (λ (v : V), odd (G.degree v)) univ).card = 2 * k,	hk : 0 < k	⊢ odd (filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) univ).card", "decl_nm": "simple_graph.odd_card_odd_degree_vertices_ne"
{"src": "2 goals	V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (filter (λ (v : V), odd (G.degree v)) univ).card = 2 * k,	hh : 0 < 2 * k	⊢ 0 < 2		V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (filter (λ (v : V), odd (G.degree v)) univ).card = 2 * k,	hk : 0 < k	⊢ odd (filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) univ).card", "decl_nm": "simple_graph.odd_card_odd_degree_vertices_ne"
{"src": "V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (filter (λ (v : V), odd (G.degree v)) univ).card = 2 * k,	hk : 0 < k	⊢ odd (filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) univ).card", "decl_nm": "simple_graph.odd_card_odd_degree_vertices_ne"
{"src": "2 goals	V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (filter (λ (v : V), odd (G.degree v)) univ).card = 2 * k,	hk : 0 < k	⊢ (λ (w : V), w ≠ v ∧ odd (G.degree w)) = λ (w : V), odd (G.degree w) ∧ w ≠ v		V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (filter (λ (v : V), odd (G.degree v)) univ).card = 2 * k,	hk : 0 < k,	hc : (λ (w : V), w ≠ v ∧ odd (G.degree w)) = λ (w : V), odd (G.degree w) ∧ w ≠ v	⊢ odd (filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) univ).card", "decl_nm": "simple_graph.odd_card_odd_degree_vertices_ne"
{"src": "2 goals	V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (filter (λ (v : V), odd (G.degree v)) univ).card = 2 * k,	hk : 0 < k,	w : V	⊢ w ≠ v ∧ odd (G.degree w) ↔ odd (G.degree w) ∧ w ≠ v		V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (filter (λ (v : V), odd (G.degree v)) univ).card = 2 * k,	hk : 0 < k,	hc : (λ (w : V), w ≠ v ∧ odd (G.degree w)) = λ (w : V), odd (G.degree w) ∧ w ≠ v	⊢ odd (filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) univ).card", "decl_nm": "simple_graph.odd_card_odd_degree_vertices_ne"
{"src": "V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (filter (λ (v : V), odd (G.degree v)) univ).card = 2 * k,	hk : 0 < k,	hc : (λ (w : V), w ≠ v ∧ odd (G.degree w)) = λ (w : V), odd (G.degree w) ∧ w ≠ v	⊢ odd (filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) univ).card", "decl_nm": "simple_graph.odd_card_odd_degree_vertices_ne"
{"src": "V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (filter (λ (v : V), odd (G.degree v)) univ).card = 2 * k,	hk : 0 < k,	hc : (λ (w : V), w ≠ v ∧ odd (G.degree w)) = λ (w : V), odd (G.degree w) ∧ w ≠ v	⊢ odd (filter (λ (w : V), odd (G.degree w) ∧ w ≠ v) univ).card", "decl_nm": "simple_graph.odd_card_odd_degree_vertices_ne"
{"src": "2 goals	V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (filter (λ (v : V), odd (G.degree v)) univ).card = 2 * k,	hk : 0 < k,	hc : (λ (w : V), w ≠ v ∧ odd (G.degree w)) = λ (w : V), odd (G.degree w) ∧ w ≠ v	⊢ odd (filter (λ (a : V), odd (G.degree a)) univ).card.pred		V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (filter (λ (v : V), odd (G.degree v)) univ).card = 2 * k,	hk : 0 < k,	hc : (λ (w : V), w ≠ v ∧ odd (G.degree w)) = λ (w : V), odd (G.degree w) ∧ w ≠ v	⊢ v ∈ filter (λ (a : V), odd (G.degree a)) univ", "decl_nm": "simple_graph.odd_card_odd_degree_vertices_ne"
{"src": "2 goals	V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (filter (λ (v : V), odd (G.degree v)) univ).card = 2 * k,	hk : 0 < k,	hc : (λ (w : V), w ≠ v ∧ odd (G.degree w)) = λ (w : V), odd (G.degree w) ∧ w ≠ v	⊢ (filter (λ (a : V), odd (G.degree a)) univ).card.pred = 2 * (k - 1) + 1		V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (filter (λ (v : V), odd (G.degree v)) univ).card = 2 * k,	hk : 0 < k,	hc : (λ (w : V), w ≠ v ∧ odd (G.degree w)) = λ (w : V), odd (G.degree w) ∧ w ≠ v	⊢ v ∈ filter (λ (a : V), odd (G.degree a)) univ", "decl_nm": "simple_graph.odd_card_odd_degree_vertices_ne"
{"src": "4 goals	V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (filter (λ (v : V), odd (G.degree v)) univ).card = 2 * k,	hk : 0 < k,	hc : (λ (w : V), w ≠ v ∧ odd (G.degree w)) = λ (w : V), odd (G.degree w) ∧ w ≠ v	⊢ 2 * k + 2 = 2 * k + 2 * 1		V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (filter (λ (v : V), odd (G.degree v)) univ).card = 2 * k,	hk : 0 < k,	hc : (λ (w : V), w ≠ v ∧ odd (G.degree w)) = λ (w : V), odd (G.degree w) ∧ w ≠ v	⊢ 2 * 1 ≤ 2 * k + 2		V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (filter (λ (v : V), odd (G.degree v)) univ).card = 2 * k,	hk : 0 < k,	hc : (λ (w : V), w ≠ v ∧ odd (G.degree w)) = λ (w : V), odd (G.degree w) ∧ w ≠ v	⊢ 2 * 1 ≤ 2 * k		V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (filter (λ (v : V), odd (G.degree v)) univ).card = 2 * k,	hk : 0 < k,	hc : (λ (w : V), w ≠ v ∧ odd (G.degree w)) = λ (w : V), odd (G.degree w) ∧ w ≠ v	⊢ v ∈ filter (λ (a : V), odd (G.degree a)) univ", "decl_nm": "simple_graph.odd_card_odd_degree_vertices_ne"
{"src": "3 goals	V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (filter (λ (v : V), odd (G.degree v)) univ).card = 2 * k,	hk : 0 < k,	hc : (λ (w : V), w ≠ v ∧ odd (G.degree w)) = λ (w : V), odd (G.degree w) ∧ w ≠ v	⊢ 2 * 1 ≤ 2 * k + 2		V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (filter (λ (v : V), odd (G.degree v)) univ).card = 2 * k,	hk : 0 < k,	hc : (λ (w : V), w ≠ v ∧ odd (G.degree w)) = λ (w : V), odd (G.degree w) ∧ w ≠ v	⊢ 2 * 1 ≤ 2 * k		V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (filter (λ (v : V), odd (G.degree v)) univ).card = 2 * k,	hk : 0 < k,	hc : (λ (w : V), w ≠ v ∧ odd (G.degree w)) = λ (w : V), odd (G.degree w) ∧ w ≠ v	⊢ v ∈ filter (λ (a : V), odd (G.degree a)) univ", "decl_nm": "simple_graph.odd_card_odd_degree_vertices_ne"
{"src": "2 goals	V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (filter (λ (v : V), odd (G.degree v)) univ).card = 2 * k,	hk : 0 < k,	hc : (λ (w : V), w ≠ v ∧ odd (G.degree w)) = λ (w : V), odd (G.degree w) ∧ w ≠ v	⊢ 2 * 1 ≤ 2 * k		V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (filter (λ (v : V), odd (G.degree v)) univ).card = 2 * k,	hk : 0 < k,	hc : (λ (w : V), w ≠ v ∧ odd (G.degree w)) = λ (w : V), odd (G.degree w) ∧ w ≠ v	⊢ v ∈ filter (λ (a : V), odd (G.degree a)) univ", "decl_nm": "simple_graph.odd_card_odd_degree_vertices_ne"
{"src": "V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_eq V,	_inst_3 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	k : ℕ,	hg : (filter (λ (v : V), odd (G.degree v)) univ).card = 2 * k,	hk : 0 < k,	hc : (λ (w : V), w ≠ v ∧ odd (G.degree w)) = λ (w : V), odd (G.degree w) ∧ w ≠ v	⊢ v ∈ filter (λ (a : V), odd (G.degree a)) univ", "decl_nm": "simple_graph.odd_card_odd_degree_vertices_ne"
{"src": "⊢ ∀ {V : Type u} (G : simple_graph V) [_inst_1 : fintype V] [_inst_2 : decidable_rel G.adj] (v : V),	    odd (G.degree v) → (∃ (w : V), w ≠ v ∧ odd (G.degree w))", "decl_nm": "simple_graph.exists_ne_odd_degree_of_exists_odd_degree"
{"src": "V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_rel G.adj,	v : V,	h : odd (G.degree v)	⊢ ∃ (w : V), w ≠ v ∧ odd (G.degree w)", "decl_nm": "simple_graph.exists_ne_odd_degree_of_exists_odd_degree"
{"src": "2 goals	V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_rel G.adj,	v : V,	h : odd (G.degree v)	⊢ decidable_eq V		V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	_inst : decidable_eq V	⊢ ∃ (w : V), w ≠ v ∧ odd (G.degree w)", "decl_nm": "simple_graph.exists_ne_odd_degree_of_exists_odd_degree"
{"src": "2 goals	V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	_inst : Π (a : Prop), decidable a	⊢ decidable_eq V		V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	_inst : decidable_eq V	⊢ ∃ (w : V), w ≠ v ∧ odd (G.degree w)", "decl_nm": "simple_graph.exists_ne_odd_degree_of_exists_odd_degree"
{"src": "V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	_inst : decidable_eq V	⊢ ∃ (w : V), w ≠ v ∧ odd (G.degree w)", "decl_nm": "simple_graph.exists_ne_odd_degree_of_exists_odd_degree"
{"src": "V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	_inst : decidable_eq V,	k : ℕ,	hg : (filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) univ).card = 2 * k + 1	⊢ ∃ (w : V), w ≠ v ∧ odd (G.degree w)", "decl_nm": "simple_graph.exists_ne_odd_degree_of_exists_odd_degree"
{"src": "2 goals	V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	_inst : decidable_eq V,	k : ℕ,	hg : (filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) univ).card = 2 * k + 1	⊢ (filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) univ).card > 0		V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	_inst : decidable_eq V,	k : ℕ,	hg : (filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) univ).card = 2 * k + 1,	hg' : (filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) univ).card > 0	⊢ ∃ (w : V), w ≠ v ∧ odd (G.degree w)", "decl_nm": "simple_graph.exists_ne_odd_degree_of_exists_odd_degree"
{"src": "2 goals	V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	_inst : decidable_eq V,	k : ℕ,	hg : (filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) univ).card = 2 * k + 1	⊢ 2 * k + 1 > 0		V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	_inst : decidable_eq V,	k : ℕ,	hg : (filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) univ).card = 2 * k + 1,	hg' : (filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) univ).card > 0	⊢ ∃ (w : V), w ≠ v ∧ odd (G.degree w)", "decl_nm": "simple_graph.exists_ne_odd_degree_of_exists_odd_degree"
{"src": "V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	_inst : decidable_eq V,	k : ℕ,	hg : (filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) univ).card = 2 * k + 1,	hg' : (filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) univ).card > 0	⊢ ∃ (w : V), w ≠ v ∧ odd (G.degree w)", "decl_nm": "simple_graph.exists_ne_odd_degree_of_exists_odd_degree"
{"src": "V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	_inst : decidable_eq V,	k : ℕ,	hg : (filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) univ).card = 2 * k + 1,	hg' : (filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) univ).card > 0,	w : V,	hw : w ∈ filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) univ	⊢ ∃ (w : V), w ≠ v ∧ odd (G.degree w)", "decl_nm": "simple_graph.exists_ne_odd_degree_of_exists_odd_degree"
{"src": "V : Type u,	G : simple_graph V,	_inst_1 : fintype V,	_inst_2 : decidable_rel G.adj,	v : V,	h : odd (G.degree v),	_inst : decidable_eq V,	k : ℕ,	hg : (filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) univ).card = 2 * k + 1,	hg' : (filter (λ (w : V), w ≠ v ∧ odd (G.degree w)) univ).card > 0,	w : V,	hw : ¬w = v ∧ odd (G.degree w)	⊢ ∃ (w : V), w ≠ v ∧ odd (G.degree w)", "decl_nm": "simple_graph.exists_ne_odd_degree_of_exists_odd_degree"
{"src": "⊢ ∀ {α : Type u} {σ : Type v} (M : DFA α σ) {x y : list α} {s : σ},	    M.eval_from s x = s → y ∈ {x}.star → M.eval_from s y = s", "decl_nm": "DFA.eval_from_of_pow"
{"src": "α : Type u,	σ : Type v,	M : DFA α σ,	x y : list α,	s : σ,	hx : M.eval_from s x = s,	hy : y ∈ {x}.star	⊢ M.eval_from s y = s", "decl_nm": "DFA.eval_from_of_pow"
{"src": "α : Type u,	σ : Type v,	M : DFA α σ,	x y : list α,	s : σ,	hx : M.eval_from s x = s,	hy : ∃ (S : list (list α)), y = S.join ∧ ∀ (y : list α), y ∈ S → y ∈ {x}	⊢ M.eval_from s y = s", "decl_nm": "DFA.eval_from_of_pow"
{"src": "α : Type u,	σ : Type v,	M : DFA α σ,	x : list α,	s : σ,	hx : M.eval_from s x = s,	S : list (list α),	hS : ∀ (y : list α), y ∈ S → y ∈ {x}	⊢ M.eval_from s S.join = s", "decl_nm": "DFA.eval_from_of_pow"
{"src": "2 goals	case list.nil	α : Type u,	σ : Type v,	M : DFA α σ,	x : list α,	s : σ,	hx : M.eval_from s x = s,	hS : ∀ (y : list α), y ∈ list.nil → y ∈ {x}	⊢ M.eval_from s list.nil.join = s		case list.cons	α : Type u,	σ : Type v,	M : DFA α σ,	x : list α,	s : σ,	hx : M.eval_from s x = s,	a : list α,	S : list (list α),	ih : (∀ (y : list α), y ∈ S → y ∈ {x}) → M.eval_from s S.join = s,	hS : ∀ (y : list α), y ∈ a :: S → y ∈ {x}	⊢ M.eval_from s (a :: S).join = s", "decl_nm": "DFA.eval_from_of_pow"
{"src": "case list.cons	α : Type u,	σ : Type v,	M : DFA α σ,	x : list α,	s : σ,	hx : M.eval_from s x = s,	a : list α,	S : list (list α),	ih : (∀ (y : list α), y ∈ S → y ∈ {x}) → M.eval_from s S.join = s,	hS : ∀ (y : list α), y ∈ a :: S → y ∈ {x}	⊢ M.eval_from s (a :: S).join = s", "decl_nm": "DFA.eval_from_of_pow"
{"src": "α : Type u,	σ : Type v,	M : DFA α σ,	x : list α,	s : σ,	hx : M.eval_from s x = s,	a : list α,	S : list (list α),	ih : (∀ (y : list α), y ∈ S → y ∈ {x}) → M.eval_from s S.join = s,	hS : ∀ (y : list α), y ∈ a :: S → y ∈ {x},	ha : a ∈ {x}	⊢ M.eval_from s (a :: S).join = s", "decl_nm": "DFA.eval_from_of_pow"
{"src": "α : Type u,	σ : Type v,	M : DFA α σ,	x : list α,	s : σ,	hx : M.eval_from s x = s,	a : list α,	S : list (list α),	ih : (∀ (y : list α), y ∈ S → y ∈ {x}) → M.eval_from s S.join = s,	hS : ∀ (y : list α), y ∈ a :: S → y ∈ {x},	ha : a = x	⊢ M.eval_from s (a :: S).join = s", "decl_nm": "DFA.eval_from_of_pow"
{"src": "α : Type u,	σ : Type v,	M : DFA α σ,	x : list α,	s : σ,	hx : M.eval_from s x = s,	a : list α,	S : list (list α),	ih : (∀ (y : list α), y ∈ S → y ∈ {x}) → M.eval_from s S.join = s,	hS : ∀ (y : list α), y ∈ a :: S → y ∈ {x},	ha : a = x	⊢ M.eval_from s S.join = s", "decl_nm": "DFA.eval_from_of_pow"
{"src": "α : Type u,	σ : Type v,	M : DFA α σ,	x : list α,	s : σ,	hx : M.eval_from s x = s,	a : list α,	S : list (list α),	ih : (∀ (y : list α), y ∈ S → y ∈ {x}) → M.eval_from s S.join = s,	hS : ∀ (y : list α), y ∈ a :: S → y ∈ {x},	ha : a = x	⊢ ∀ (y : list α), y ∈ S → y ∈ {x}", "decl_nm": "DFA.eval_from_of_pow"
{"src": "α : Type u,	σ : Type v,	M : DFA α σ,	x : list α,	s : σ,	hx : M.eval_from s x = s,	a : list α,	S : list (list α),	ih : (∀ (y : list α), y ∈ S → y ∈ {x}) → M.eval_from s S.join = s,	hS : ∀ (y : list α), y ∈ a :: S → y ∈ {x},	ha : a = x,	z : list α,	hz : z ∈ S	⊢ z ∈ {x}", "decl_nm": "DFA.eval_from_of_pow"
{"src": "⊢ ∀ (cf cg : partrec.code), encode cf < encode (cf.pair cg) ∧ encode cg < encode (cf.pair cg)", "decl_nm": "nat.partrec.code.encode_lt_pair"
{"src": "cf cg : partrec.code	⊢ encode cf < encode (cf.pair cg) ∧ encode cg < encode (cf.pair cg)", "decl_nm": "nat.partrec.code.encode_lt_pair"
{"src": "cf cg : partrec.code	⊢ cf.encode_code < bit0 (bit0 (mkpair cf.encode_code cg.encode_code)) + 4 ∧	    cg.encode_code < bit0 (bit0 (mkpair cf.encode_code cg.encode_code)) + 4", "decl_nm": "nat.partrec.code.encode_lt_pair"
{"src": "2 goals	cf cg : partrec.code,	this : 1 * ?m_1 ≤ 2 * 2 * ?m_1	⊢ cf.encode_code < bit0 (bit0 (mkpair cf.encode_code cg.encode_code)) + 4 ∧	    cg.encode_code < bit0 (bit0 (mkpair cf.encode_code cg.encode_code)) + 4		cf cg : partrec.code	⊢ ℕ", "decl_nm": "nat.partrec.code.encode_lt_pair"
{"src": "2 goals	cf cg : partrec.code,	this : ?m_1 ≤ bit0 (bit0 ?m_1)	⊢ cf.encode_code < bit0 (bit0 (mkpair cf.encode_code cg.encode_code)) + 4 ∧	    cg.encode_code < bit0 (bit0 (mkpair cf.encode_code cg.encode_code)) + 4		cf cg : partrec.code	⊢ ℕ", "decl_nm": "nat.partrec.code.encode_lt_pair"
{"src": "3 goals	cf cg : partrec.code,	this : ?m_1 ≤ bit0 (bit0 ?m_1),	this : ?m_1 < bit0 (bit0 ?m_1) + 4	⊢ cf.encode_code < bit0 (bit0 (mkpair cf.encode_code cg.encode_code)) + 4 ∧	    cg.encode_code < bit0 (bit0 (mkpair cf.encode_code cg.encode_code)) + 4		cf cg : partrec.code	⊢ ℕ		cf cg : partrec.code	⊢ ℕ", "decl_nm": "nat.partrec.code.encode_lt_pair"
{"src": "⊢ ∀ (cf : partrec.code), encode cf < encode cf.rfind'", "decl_nm": "nat.partrec.code.encode_lt_rfind'"
{"src": "cf : partrec.code	⊢ encode cf < encode cf.rfind'", "decl_nm": "nat.partrec.code.encode_lt_rfind'"
{"src": "cf : partrec.code	⊢ cf.encode_code < bit1 (bit1 cf.encode_code) + 4", "decl_nm": "nat.partrec.code.encode_lt_rfind'"
{"src": "2 goals	cf : partrec.code,	this : 1 * ?m_1 ≤ 2 * 2 * ?m_1	⊢ cf.encode_code < bit1 (bit1 cf.encode_code) + 4		cf : partrec.code	⊢ ℕ", "decl_nm": "nat.partrec.code.encode_lt_rfind'"
{"src": "2 goals	cf : partrec.code,	this : ?m_1 ≤ bit0 (bit0 ?m_1)	⊢ cf.encode_code < bit1 (bit1 cf.encode_code) + 4		cf : partrec.code	⊢ ℕ", "decl_nm": "nat.partrec.code.encode_lt_rfind'"
{"src": "cf : partrec.code,	this : cf.encode_code ≤ bit0 (bit0 cf.encode_code)	⊢ bit0 (bit0 cf.encode_code) ≤ bit1 (bit1 cf.encode_code)", "decl_nm": "nat.partrec.code.encode_lt_rfind'"
{"src": "⊢ ∀ {n : ℕ} {f : vector ℕ n → ℕ}, primrec' f → primrec f", "decl_nm": "nat.primrec'.to_prim"
{"src": "n : ℕ,	f : vector ℕ n → ℕ,	pf : primrec' f	⊢ primrec f", "decl_nm": "nat.primrec'.to_prim"
{"src": "5 goals	case nat.primrec'.zero	n : ℕ,	f : vector ℕ n → ℕ	⊢ primrec (λ (_x : vector ℕ 0), 0)		case nat.primrec'.succ	n : ℕ,	f : vector ℕ n → ℕ	⊢ primrec (λ (v : vector ℕ 1), v.head.succ)		case nat.primrec'.nth	n : ℕ,	f : vector ℕ n → ℕ,	pf_n : ℕ,	pf_i : fin pf_n	⊢ primrec (λ (v : vector ℕ pf_n), v.nth pf_i)		case nat.primrec'.comp	n : ℕ,	f : vector ℕ n → ℕ,	pf_m pf_n : ℕ,	pf_f : vector ℕ pf_n → ℕ,	pf_g : fin pf_n → vector ℕ pf_m → ℕ,	pf_ᾰ : primrec' pf_f,	pf_ᾰ_1 : ∀ (i : fin pf_n), primrec' (pf_g i),	pf_ih_ᾰ : primrec pf_f,	pf_ih_ᾰ_1 : ∀ (i : fin pf_n), (λ {n : ℕ} {f : vector ℕ n → ℕ} (pf : primrec' f), primrec f) _	⊢ primrec (λ (a : vector ℕ pf_m), pf_f (of_fn (λ (i : fin pf_n), pf_g i a)))		case nat.primrec'.prec	n : ℕ,	f : vector ℕ n → ℕ,	pf_n : ℕ,	pf_f : vector ℕ pf_n → ℕ,	pf_g : vector ℕ (pf_n + 2) → ℕ,	pf_ᾰ : primrec' pf_f,	pf_ᾰ_1 : primrec' pf_g,	pf_ih_ᾰ : primrec pf_f,	pf_ih_ᾰ_1 : primrec pf_g	⊢ primrec (λ (v : vector ℕ (pf_n + 1)), elim (pf_f v.tail) (λ (y IH : ℕ), pf_g (y::ᵥ IH::ᵥ v.tail)) v.head)", "decl_nm": "nat.primrec'.to_prim"
{"src": "4 goals	case nat.primrec'.succ	n : ℕ,	f : vector ℕ n → ℕ	⊢ primrec (λ (v : vector ℕ 1), v.head.succ)		case nat.primrec'.nth	n : ℕ,	f : vector ℕ n → ℕ,	pf_n : ℕ,	pf_i : fin pf_n	⊢ primrec (λ (v : vector ℕ pf_n), v.nth pf_i)		case nat.primrec'.comp	n : ℕ,	f : vector ℕ n → ℕ,	pf_m pf_n : ℕ,	pf_f : vector ℕ pf_n → ℕ,	pf_g : fin pf_n → vector ℕ pf_m → ℕ,	pf_ᾰ : primrec' pf_f,	pf_ᾰ_1 : ∀ (i : fin pf_n), primrec' (pf_g i),	pf_ih_ᾰ : primrec pf_f,	pf_ih_ᾰ_1 : ∀ (i : fin pf_n), (λ {n : ℕ} {f : vector ℕ n → ℕ} (pf : primrec' f), primrec f) _	⊢ primrec (λ (a : vector ℕ pf_m), pf_f (of_fn (λ (i : fin pf_n), pf_g i a)))		case nat.primrec'.prec	n : ℕ,	f : vector ℕ n → ℕ,	pf_n : ℕ,	pf_f : vector ℕ pf_n → ℕ,	pf_g : vector ℕ (pf_n + 2) → ℕ,	pf_ᾰ : primrec' pf_f,	pf_ᾰ_1 : primrec' pf_g,	pf_ih_ᾰ : primrec pf_f,	pf_ih_ᾰ_1 : primrec pf_g	⊢ primrec (λ (v : vector ℕ (pf_n + 1)), elim (pf_f v.tail) (λ (y IH : ℕ), pf_g (y::ᵥ IH::ᵥ v.tail)) v.head)", "decl_nm": "nat.primrec'.to_prim"
{"src": "3 goals	case nat.primrec'.nth	n : ℕ,	f : vector ℕ n → ℕ,	pf_n : ℕ,	pf_i : fin pf_n	⊢ primrec (λ (v : vector ℕ pf_n), v.nth pf_i)		case nat.primrec'.comp	n : ℕ,	f : vector ℕ n → ℕ,	pf_m pf_n : ℕ,	pf_f : vector ℕ pf_n → ℕ,	pf_g : fin pf_n → vector ℕ pf_m → ℕ,	pf_ᾰ : primrec' pf_f,	pf_ᾰ_1 : ∀ (i : fin pf_n), primrec' (pf_g i),	pf_ih_ᾰ : primrec pf_f,	pf_ih_ᾰ_1 : ∀ (i : fin pf_n), (λ {n : ℕ} {f : vector ℕ n → ℕ} (pf : primrec' f), primrec f) _	⊢ primrec (λ (a : vector ℕ pf_m), pf_f (of_fn (λ (i : fin pf_n), pf_g i a)))		case nat.primrec'.prec	n : ℕ,	f : vector ℕ n → ℕ,	pf_n : ℕ,	pf_f : vector ℕ pf_n → ℕ,	pf_g : vector ℕ (pf_n + 2) → ℕ,	pf_ᾰ : primrec' pf_f,	pf_ᾰ_1 : primrec' pf_g,	pf_ih_ᾰ : primrec pf_f,	pf_ih_ᾰ_1 : primrec pf_g	⊢ primrec (λ (v : vector ℕ (pf_n + 1)), elim (pf_f v.tail) (λ (y IH : ℕ), pf_g (y::ᵥ IH::ᵥ v.tail)) v.head)", "decl_nm": "nat.primrec'.to_prim"
{"src": "2 goals	case nat.primrec'.comp	n : ℕ,	f : vector ℕ n → ℕ,	pf_m pf_n : ℕ,	pf_f : vector ℕ pf_n → ℕ,	pf_g : fin pf_n → vector ℕ pf_m → ℕ,	pf_ᾰ : primrec' pf_f,	pf_ᾰ_1 : ∀ (i : fin pf_n), primrec' (pf_g i),	pf_ih_ᾰ : primrec pf_f,	pf_ih_ᾰ_1 : ∀ (i : fin pf_n), (λ {n : ℕ} {f : vector ℕ n → ℕ} (pf : primrec' f), primrec f) _	⊢ primrec (λ (a : vector ℕ pf_m), pf_f (of_fn (λ (i : fin pf_n), pf_g i a)))		case nat.primrec'.prec	n : ℕ,	f : vector ℕ n → ℕ,	pf_n : ℕ,	pf_f : vector ℕ pf_n → ℕ,	pf_g : vector ℕ (pf_n + 2) → ℕ,	pf_ᾰ : primrec' pf_f,	pf_ᾰ_1 : primrec' pf_g,	pf_ih_ᾰ : primrec pf_f,	pf_ih_ᾰ_1 : primrec pf_g	⊢ primrec (λ (v : vector ℕ (pf_n + 1)), elim (pf_f v.tail) (λ (y IH : ℕ), pf_g (y::ᵥ IH::ᵥ v.tail)) v.head)", "decl_nm": "nat.primrec'.to_prim"
{"src": "case nat.primrec'.prec	n : ℕ,	f : vector ℕ n → ℕ,	pf_n : ℕ,	pf_f : vector ℕ pf_n → ℕ,	pf_g : vector ℕ (pf_n + 2) → ℕ,	pf_ᾰ : primrec' pf_f,	pf_ᾰ_1 : primrec' pf_g,	pf_ih_ᾰ : primrec pf_f,	pf_ih_ᾰ_1 : primrec pf_g	⊢ primrec (λ (v : vector ℕ (pf_n + 1)), elim (pf_f v.tail) (λ (y IH : ℕ), pf_g (y::ᵥ IH::ᵥ v.tail)) v.head)", "decl_nm": "nat.primrec'.to_prim"
{"src": "⊢ ∀ {α : Type u_1} {σ : Type u_5} [_inst_1 : primcodable α] [_inst_5 : primcodable σ] {c : α → Prop}	  [_inst_6 : decidable_pred c] {f g : α → σ},	    primrec_pred c → primrec f → primrec g → primrec (λ (a : α), ite (c a) (f a) (g a))", "decl_nm": "primrec.ite"
{"src": "α : Type u_1,	σ : Type u_5,	_inst_1 : primcodable α,	_inst_5 : primcodable σ,	c : α → Prop,	_inst_6 : decidable_pred c,	f g : α → σ,	hc : primrec_pred c,	hf : primrec f,	hg : primrec g	⊢ primrec (λ (a : α), ite (c a) (f a) (g a))", "decl_nm": "primrec.ite"
{"src": "⊢ ∀ (v : list ℕ), to_partrec.code.head.eval v = pure [v.head]", "decl_nm": "turing.to_partrec.code.head_eval"
{"src": "v : list ℕ	⊢ to_partrec.code.head.eval v = pure [v.head]", "decl_nm": "turing.to_partrec.code.head_eval"
{"src": "⊢ ∀ {K : Type u_1} [_inst_1 : decidable_eq K] {Γ : K → Type u_2} {Λ : Type u_3} [_inst_2 : inhabited Λ]	  {σ : Type u_4} [_inst_3 : inhabited σ] (S : finset Λ) {k : K} (s : TM2to1.st_act k) (q : TM2.stmt Γ Λ σ),	    TM2.supports_stmt S (TM2to1.st_run s q) ↔ TM2.supports_stmt S q", "decl_nm": "turing.TM2to1.supports_run"
{"src": "K : Type u_1,	_inst_1 : decidable_eq K,	Γ : K → Type u_2,	Λ : Type u_3,	_inst_2 : inhabited Λ,	σ : Type u_4,	_inst_3 : inhabited σ,	S : finset Λ,	k : K,	s : TM2to1.st_act k,	q : TM2.stmt Γ Λ σ	⊢ TM2.supports_stmt S (TM2to1.st_run s q) ↔ TM2.supports_stmt S q", "decl_nm": "turing.TM2to1.supports_run"
{"src": "3 goals	K : Type u_1,	_inst_1 : decidable_eq K,	Γ : K → Type u_2,	Λ : Type u_3,	_inst_2 : inhabited Λ,	σ : Type u_4,	_inst_3 : inhabited σ,	S : finset Λ,	k : K,	q : TM2.stmt Γ Λ σ,	s : σ → Γ k	⊢ TM2.supports_stmt S (TM2to1.st_run (push s) q) ↔ TM2.supports_stmt S q		K : Type u_1,	_inst_1 : decidable_eq K,	Γ : K → Type u_2,	Λ : Type u_3,	_inst_2 : inhabited Λ,	σ : Type u_4,	_inst_3 : inhabited σ,	S : finset Λ,	k : K,	q : TM2.stmt Γ Λ σ,	s : σ → option (Γ k) → σ	⊢ TM2.supports_stmt S (TM2to1.st_run (peek s) q) ↔ TM2.supports_stmt S q		K : Type u_1,	_inst_1 : decidable_eq K,	Γ : K → Type u_2,	Λ : Type u_3,	_inst_2 : inhabited Λ,	σ : Type u_4,	_inst_3 : inhabited σ,	S : finset Λ,	k : K,	q : TM2.stmt Γ Λ σ,	s : σ → option (Γ k) → σ	⊢ TM2.supports_stmt S (TM2to1.st_run (pop s) q) ↔ TM2.supports_stmt S q", "decl_nm": "turing.TM2to1.supports_run"
{"src": "2 goals	K : Type u_1,	_inst_1 : decidable_eq K,	Γ : K → Type u_2,	Λ : Type u_3,	_inst_2 : inhabited Λ,	σ : Type u_4,	_inst_3 : inhabited σ,	S : finset Λ,	k : K,	q : TM2.stmt Γ Λ σ,	s : σ → option (Γ k) → σ	⊢ TM2.supports_stmt S (TM2to1.st_run (peek s) q) ↔ TM2.supports_stmt S q		K : Type u_1,	_inst_1 : decidable_eq K,	Γ : K → Type u_2,	Λ : Type u_3,	_inst_2 : inhabited Λ,	σ : Type u_4,	_inst_3 : inhabited σ,	S : finset Λ,	k : K,	q : TM2.stmt Γ Λ σ,	s : σ → option (Γ k) → σ	⊢ TM2.supports_stmt S (TM2to1.st_run (pop s) q) ↔ TM2.supports_stmt S q", "decl_nm": "turing.TM2to1.supports_run"
{"src": "K : Type u_1,	_inst_1 : decidable_eq K,	Γ : K → Type u_2,	Λ : Type u_3,	_inst_2 : inhabited Λ,	σ : Type u_4,	_inst_3 : inhabited σ,	S : finset Λ,	k : K,	q : TM2.stmt Γ Λ σ,	s : σ → option (Γ k) → σ	⊢ TM2.supports_stmt S (TM2to1.st_run (pop s) q) ↔ TM2.supports_stmt S q", "decl_nm": "turing.TM2to1.supports_run"
{"src": "⊢ ∀ {Γ : Type u_1} [_inst_1 : inhabited Γ] (l : list_blank Γ), l.nth 0 = l.head", "decl_nm": "turing.list_blank.nth_zero"
{"src": "Γ : Type u_1,	_inst_1 : inhabited Γ,	l : list_blank Γ	⊢ l.nth 0 = l.head", "decl_nm": "turing.list_blank.nth_zero"
{"src": "Γ : Type u_1,	_inst_1 : inhabited Γ,	l : list_blank Γ	⊢ (list_blank.cons l.head l.tail).nth 0 = l.head", "decl_nm": "turing.list_blank.nth_zero"
{"src": "⊢ ∀ {Γ : Type u_1} [_inst_1 : inhabited Γ] (l₁ l₂ : list Γ),	    list_blank.append l₁ (list_blank.mk l₂) = list_blank.mk (l₁ ++ l₂)", "decl_nm": "turing.list_blank.append_mk"
{"src": "Γ : Type u_1,	_inst_1 : inhabited Γ,	l₁ l₂ : list Γ	⊢ list_blank.append l₁ (list_blank.mk l₂) = list_blank.mk (l₁ ++ l₂)", "decl_nm": "turing.list_blank.append_mk"
{"src": "2 goals	case list.nil	Γ : Type u_1,	_inst_1 : inhabited Γ,	l₂ : list Γ	⊢ list_blank.append list.nil (list_blank.mk l₂) = list_blank.mk (list.nil ++ l₂)		case list.cons	Γ : Type u_1,	_inst_1 : inhabited Γ,	l₂ : list Γ,	l₁_hd : Γ,	l₁_tl : list Γ,	l₁_ih : list_blank.append l₁_tl (list_blank.mk l₂) = list_blank.mk (l₁_tl ++ l₂)	⊢ list_blank.append (l₁_hd :: l₁_tl) (list_blank.mk l₂) = list_blank.mk (l₁_hd :: l₁_tl ++ l₂)", "decl_nm": "turing.list_blank.append_mk"
{"src": "case list.cons	Γ : Type u_1,	_inst_1 : inhabited Γ,	l₂ : list Γ,	l₁_hd : Γ,	l₁_tl : list Γ,	l₁_ih : list_blank.append l₁_tl (list_blank.mk l₂) = list_blank.mk (l₁_tl ++ l₂)	⊢ list_blank.append (l₁_hd :: l₁_tl) (list_blank.mk l₂) = list_blank.mk (l₁_hd :: l₁_tl ++ l₂)", "decl_nm": "turing.list_blank.append_mk"
{"src": "⊢ ∀ {F : Type u → Type v} [_inst_1 : applicative F] [_inst_2 : is_lawful_applicative F] {G : Type u → Type w}	  [_inst_3 : applicative G] [_inst_4 : is_lawful_applicative G] ⦃η η' : applicative_transformation F G⦄,	    (∀ (α : Type u) (x : F α), ⇑η x = ⇑η' x) → η = η'", "decl_nm": "applicative_transformation.ext"
{"src": "F : Type u → Type v,	_inst_1 : applicative F,	_inst_2 : is_lawful_applicative F,	G : Type u → Type w,	_inst_3 : applicative G,	_inst_4 : is_lawful_applicative G,	η η' : applicative_transformation F G,	h : ∀ (α : Type u) (x : F α), ⇑η x = ⇑η' x	⊢ η = η'", "decl_nm": "applicative_transformation.ext"
{"src": "F : Type u → Type v,	_inst_1 : applicative F,	_inst_2 : is_lawful_applicative F,	G : Type u → Type w,	_inst_3 : applicative G,	_inst_4 : is_lawful_applicative G,	η η' : applicative_transformation F G,	h : ∀ (α : Type u) (x : F α), ⇑η x = ⇑η' x	⊢ ⇑η = ⇑η'", "decl_nm": "applicative_transformation.ext"
{"src": "F : Type u → Type v,	_inst_1 : applicative F,	_inst_2 : is_lawful_applicative F,	G : Type u → Type w,	_inst_3 : applicative G,	_inst_4 : is_lawful_applicative G,	η η' : applicative_transformation F G,	h : ∀ (α : Type u) (x : F α), ⇑η x = ⇑η' x,	α : Type u	⊢ ⇑η = ⇑η'", "decl_nm": "applicative_transformation.ext"
{"src": "⊢ ∀ {n : ℕ} {α : Type u} {v : α} {a : array n α}, v ∈ a.to_list ↔ v ∈ a", "decl_nm": "array.mem_to_list"
{"src": "n : ℕ,	α : Type u,	v : α,	a : array n α	⊢ v ∈ a.to_list ↔ v ∈ a", "decl_nm": "array.mem_to_list"
{"src": "n : ℕ,	α : Type u,	v : α,	a : array n α	⊢ v ∈ a.rev_list.reverse ↔ v ∈ a", "decl_nm": "array.mem_to_list"
{"src": "⊢ ∀ {a b : bool}, ↥a → ↥(a || b)", "decl_nm": "bool.bor_inl"
{"src": "a b : bool,	H : ↥a	⊢ ↥(a || b)", "decl_nm": "bool.bor_inl"
{"src": "⊢ ∀ {α : Type u_1} (p : Prop) [_inst_1 : decidable p] (t e : α), cond (to_bool p) t e = ite p t e", "decl_nm": "bool.cond_to_bool"
{"src": "α : Type u_1,	p : Prop,	_inst_1 : decidable p,	t e : α	⊢ cond (to_bool p) t e = ite p t e", "decl_nm": "bool.cond_to_bool"
{"src": "2 goals	α : Type u_1,	p : Prop,	_inst_1 : decidable p,	t e : α,	h : p	⊢ cond (to_bool p) t e = ite p t e		α : Type u_1,	p : Prop,	_inst_1 : decidable p,	t e : α,	h : ¬p	⊢ cond (to_bool p) t e = ite p t e", "decl_nm": "bool.cond_to_bool"
{"src": "α : Type u_1,	p : Prop,	_inst_1 : decidable p,	t e : α,	h : ¬p	⊢ cond (to_bool p) t e = ite p t e", "decl_nm": "bool.cond_to_bool"
{"src": "⊢ ∀ {α : Type} {msgs : thunk (list string)} {p : parser α}, (decorate_errors msgs p).bounded ↔ p.bounded", "decl_nm": "parser.bounded.decorate_errors_iff"
{"src": "α : Type,	msgs : thunk (list string),	p : parser α	⊢ (decorate_errors msgs p).bounded ↔ p.bounded", "decl_nm": "parser.bounded.decorate_errors_iff"
{"src": "2 goals	α : Type,	msgs : thunk (list string),	p : parser α	⊢ (decorate_errors msgs p).bounded → p.bounded		α : Type,	msgs : thunk (list string),	p : parser α	⊢ p.bounded → (decorate_errors msgs p).bounded", "decl_nm": "parser.bounded.decorate_errors_iff"
{"src": "2 goals	α : Type,	msgs : thunk (list string),	p : parser α,	ᾰ : (decorate_errors msgs p).bounded	⊢ p.bounded		α : Type,	msgs : thunk (list string),	p : parser α	⊢ p.bounded → (decorate_errors msgs p).bounded", "decl_nm": "parser.bounded.decorate_errors_iff"
{"src": "2 goals	α : Type,	msgs : thunk (list string),	p : parser α,	ᾰ : (decorate_errors msgs p).bounded	⊢ ∀ {cb : char_buffer} {n : ℕ},	    buffer.size cb ≤ n → (∃ (n' : ℕ) (err : dlist string), p cb n = fail n' err)		α : Type,	msgs : thunk (list string),	p : parser α	⊢ p.bounded → (decorate_errors msgs p).bounded", "decl_nm": "parser.bounded.decorate_errors_iff"
{"src": "2 goals	α : Type,	msgs : thunk (list string),	p : parser α,	ᾰ : (decorate_errors msgs p).bounded,	cb : char_buffer,	n : ℕ,	hn : buffer.size cb ≤ n	⊢ ∃ (n' : ℕ) (err : dlist string), p cb n = fail n' err		α : Type,	msgs : thunk (list string),	p : parser α	⊢ p.bounded → (decorate_errors msgs p).bounded", "decl_nm": "parser.bounded.decorate_errors_iff"
{"src": "2 goals	α : Type,	msgs : thunk (list string),	p : parser α,	ᾰ : (decorate_errors msgs p).bounded,	cb : char_buffer,	n : ℕ,	hn : buffer.size cb ≤ n,	w : ℕ,	h_w : dlist string,	h : decorate_errors msgs p cb n = fail w h_w	⊢ ∃ (n' : ℕ) (err : dlist string), p cb n = fail n' err		α : Type,	msgs : thunk (list string),	p : parser α	⊢ p.bounded → (decorate_errors msgs p).bounded", "decl_nm": "parser.bounded.decorate_errors_iff"
{"src": "2 goals	α : Type,	msgs : thunk (list string),	p : parser α,	ᾰ : (decorate_errors msgs p).bounded,	cb : char_buffer,	n : ℕ,	hn : buffer.size cb ≤ n,	w : ℕ,	h_w : dlist string,	h : n = w ∧ h_w = dlist.of_list (msgs ()) ∧ ∃ (np : ℕ) (err' : dlist string), p cb n = fail np err'	⊢ ∃ (n' : ℕ) (err : dlist string), p cb n = fail n' err		α : Type,	msgs : thunk (list string),	p : parser α	⊢ p.bounded → (decorate_errors msgs p).bounded", "decl_nm": "parser.bounded.decorate_errors_iff"
{"src": "α : Type,	msgs : thunk (list string),	p : parser α	⊢ p.bounded → (decorate_errors msgs p).bounded", "decl_nm": "parser.bounded.decorate_errors_iff"
{"src": "α : Type,	msgs : thunk (list string),	p : parser α,	ᾰ : p.bounded	⊢ (decorate_errors msgs p).bounded", "decl_nm": "parser.bounded.decorate_errors_iff"
{"src": "α : Type,	msgs : thunk (list string),	p : parser α,	ᾰ : p.bounded	⊢ ∀ {cb : char_buffer} {n : ℕ},	    buffer.size cb ≤ n → (∃ (n' : ℕ) (err : dlist string), decorate_errors msgs p cb n = fail n' err)", "decl_nm": "parser.bounded.decorate_errors_iff"
{"src": "α : Type,	msgs : thunk (list string),	p : parser α,	ᾰ : p.bounded,	cb : char_buffer,	n : ℕ,	hn : buffer.size cb ≤ n	⊢ ∃ (n' : ℕ) (err : dlist string), decorate_errors msgs p cb n = fail n' err", "decl_nm": "parser.bounded.decorate_errors_iff"
{"src": "α : Type,	msgs : thunk (list string),	p : parser α,	ᾰ : p.bounded,	cb : char_buffer,	n : ℕ,	hn : buffer.size cb ≤ n,	w : ℕ,	h_w : dlist string,	h : p cb n = fail w h_w	⊢ ∃ (n' : ℕ) (err : dlist string), decorate_errors msgs p cb n = fail n' err", "decl_nm": "parser.bounded.decorate_errors_iff"
{"src": "⊢ ¬remaining.step", "decl_nm": "parser.step.remaining"
{"src": "⊢ ∃ (cb : char_buffer) (n n' a : ℕ), remaining cb n = done n' a", "decl_nm": "parser.step.remaining"
{"src": "⊢ ∀ {α : Type} {cb : char_buffer} {n n' : ℕ} {err : dlist string},	    failure cb n = fail n' err ↔ n = n' ∧ err = dlist.empty", "decl_nm": "parser.failure_eq_fail"
{"src": "α : Type,	cb : char_buffer,	n n' : ℕ,	err : dlist string	⊢ failure cb n = fail n' err ↔ n = n' ∧ err = dlist.empty", "decl_nm": "parser.failure_eq_fail"
{"src": "⊢ ∀ {α : Type} {cb : char_buffer} {n n' : ℕ} {p : parser α} {err : dlist string},	    p.many cb n = fail n' err ↔	      n ≠ n' ∧	        (p cb n = fail n' err ∨	           ∃ (np : ℕ) (a : α),	             p cb n = done np a ∧ foldr_core list.cons p list.nil (buffer.size cb - n) cb np = fail n' err)", "decl_nm": "parser.many_eq_fail"
{"src": "α : Type,	cb : char_buffer,	n n' : ℕ,	p : parser α,	err : dlist string	⊢ p.many cb n = fail n' err ↔	    n ≠ n' ∧	      (p cb n = fail n' err ∨	         ∃ (np : ℕ) (a : α),	           p cb n = done np a ∧ foldr_core list.cons p list.nil (buffer.size cb - n) cb np = fail n' err)", "decl_nm": "parser.many_eq_fail"
{"src": "⊢ ∀ {α : Type} {cb : char_buffer} {n n' : ℕ} {a : α} {p : parser α} {l : list α},	    p.many1 cb n = done n' (a :: l) ↔ ∃ (np : ℕ), p cb n = done np a ∧ p.many cb np = done n' l", "decl_nm": "parser.many1_eq_done"
{"src": "α : Type,	cb : char_buffer,	n n' : ℕ,	a : α,	p : parser α,	l : list α	⊢ p.many1 cb n = done n' (a :: l) ↔ ∃ (np : ℕ), p cb n = done np a ∧ p.many cb np = done n' l", "decl_nm": "parser.many1_eq_done"
{"src": "⊢ ∀ (z : ℂ), ⇑(star_ring_end ℂ) (bit0 z) = bit0 (⇑(star_ring_end ℂ) z)", "decl_nm": "complex.conj_bit0"
{"src": "z : ℂ	⊢ ⇑(star_ring_end ℂ) (bit0 z) = bit0 (⇑(star_ring_end ℂ) z)", "decl_nm": "complex.conj_bit0"
{"src": "⊢ ∀ (z : ℂ), ⇑norm_sq (-z) = ⇑norm_sq z", "decl_nm": "complex.norm_sq_neg"
{"src": "z : ℂ	⊢ ⇑norm_sq (-z) = ⇑norm_sq z", "decl_nm": "complex.norm_sq_neg"
{"src": "⊢ ∀ {K : Type u_1} [_inst_1 : is_R_or_C K] (r : ℝ), ∥↑r∥ ^ 2 = r * r", "decl_nm": "is_R_or_C.norm_sq_of_real"
{"src": "K : Type u_1,	_inst_1 : is_R_or_C K,	r : ℝ	⊢ ∥↑r∥ ^ 2 = r * r", "decl_nm": "is_R_or_C.norm_sq_of_real"
{"src": "⊢ ∀ {K : Type u_1} [_inst_1 : is_R_or_C K] (z w : K),	    ⇑re (z / w) = ⇑re z * ⇑re w / ⇑norm_sq w + ⇑im z * ⇑im w / ⇑norm_sq w", "decl_nm": "is_R_or_C.div_re"
{"src": "K : Type u_1,	_inst_1 : is_R_or_C K,	z w : K	⊢ ⇑re (z / w) = ⇑re z * ⇑re w / ⇑norm_sq w + ⇑im z * ⇑im w / ⇑norm_sq w", "decl_nm": "is_R_or_C.div_re"
{"src": "⊢ ∀ {K : Type u_1} [_inst_1 : is_R_or_C K], I ≠ 0 → I * I = -1", "decl_nm": "is_R_or_C.I_mul_I_of_nonzero"
{"src": "K : Type u_1,	_inst_1 : is_R_or_C K,	ᾰ : I ≠ 0	⊢ I * I = -1", "decl_nm": "is_R_or_C.I_mul_I_of_nonzero"
{"src": "3 goals	K : Type u_1,	_inst_1 : is_R_or_C K,	ᾰ : I ≠ 0,	this : I = 0 ∨ I * I = -1	⊢ I * I = -1		K : Type u_1,	_inst_1 : is_R_or_C K,	ᾰ : I ≠ 0	⊢ Type ?		K : Type u_1,	_inst_1 : is_R_or_C K,	ᾰ : I ≠ 0	⊢ is_R_or_C ?m_1", "decl_nm": "is_R_or_C.I_mul_I_of_nonzero"
{"src": "⊢ ∀ {ι : Type u} {β : ι → Type v} [dec : decidable_eq ι] [_inst_1 : Π (i : ι), has_zero (β i)]	  (p : ι → Prop) [_inst_2 : decidable_pred p] (i : ι) (x : β i), filter p (single i x) = ite (p i) (single i x) 0", "decl_nm": "dfinsupp.filter_single"
{"src": "ι : Type u,	β : ι → Type v,	dec : decidable_eq ι,	_inst_1 : Π (i : ι), has_zero (β i),	p : ι → Prop,	_inst_2 : decidable_pred p,	i : ι,	x : β i	⊢ filter p (single i x) = ite (p i) (single i x) 0", "decl_nm": "dfinsupp.filter_single"
{"src": "ι : Type u,	β : ι → Type v,	dec : decidable_eq ι,	_inst_1 : Π (i : ι), has_zero (β i),	p : ι → Prop,	_inst_2 : decidable_pred p,	i : ι,	x : β i,	j : ι	⊢ ⇑(filter p (single i x)) j = ⇑(ite (p i) (single i x) 0) j", "decl_nm": "dfinsupp.filter_single"
{"src": "ι : Type u,	β : ι → Type v,	dec : decidable_eq ι,	_inst_1 : Π (i : ι), has_zero (β i),	p : ι → Prop,	_inst_2 : decidable_pred p,	i : ι,	x : β i,	j : ι,	this :	  (λ (x : Π₀ (i : ι), β i), ⇑x j) (ite (p i) (single i x) 0) =	    ite (p i) ((λ (x : Π₀ (i : ι), β i), ⇑x j) (single i x)) ((λ (x : Π₀ (i : ι), β i), ⇑x j) 0)	⊢ ⇑(filter p (single i x)) j = ⇑(ite (p i) (single i x) 0) j", "decl_nm": "dfinsupp.filter_single"
{"src": "ι : Type u,	β : ι → Type v,	dec : decidable_eq ι,	_inst_1 : Π (i : ι), has_zero (β i),	p : ι → Prop,	_inst_2 : decidable_pred p,	i : ι,	x : β i,	j : ι,	this : ⇑(ite (p i) (single i x) 0) j = ite (p i) (⇑(single i x) j) 0	⊢ ⇑(filter p (single i x)) j = ⇑(ite (p i) (single i x) 0) j", "decl_nm": "dfinsupp.filter_single"
{"src": "ι : Type u,	β : ι → Type v,	dec : decidable_eq ι,	_inst_1 : Π (i : ι), has_zero (β i),	p : ι → Prop,	_inst_2 : decidable_pred p,	i : ι,	x : β i,	j : ι,	this : ⇑(ite (p i) (single i x) 0) j = ite (p i) (⇑(single i x) j) 0	⊢ ite (p j) (⇑(single i x) j) 0 = ite (p i) (⇑(single i x) j) 0", "decl_nm": "dfinsupp.filter_single"
{"src": "2 goals	ι : Type u,	β : ι → Type v,	dec : decidable_eq ι,	_inst_1 : Π (i : ι), has_zero (β i),	p : ι → Prop,	_inst_2 : decidable_pred p,	i : ι,	x : β i,	this : ⇑(ite (p i) (single i x) 0) i = ite (p i) (⇑(single i x) i) 0	⊢ ite (p i) (⇑(single i x) i) 0 = ite (p i) (⇑(single i x) i) 0		ι : Type u,	β : ι → Type v,	dec : decidable_eq ι,	_inst_1 : Π (i : ι), has_zero (β i),	p : ι → Prop,	_inst_2 : decidable_pred p,	i : ι,	x : β i,	j : ι,	this : ⇑(ite (p i) (single i x) 0) j = ite (p i) (⇑(single i x) j) 0,	hij : i ≠ j	⊢ ite (p j) (⇑(single i x) j) 0 = ite (p i) (⇑(single i x) j) 0", "decl_nm": "dfinsupp.filter_single"
{"src": "ι : Type u,	β : ι → Type v,	dec : decidable_eq ι,	_inst_1 : Π (i : ι), has_zero (β i),	p : ι → Prop,	_inst_2 : decidable_pred p,	i : ι,	x : β i,	j : ι,	this : ⇑(ite (p i) (single i x) 0) j = ite (p i) (⇑(single i x) j) 0,	hij : i ≠ j	⊢ ite (p j) (⇑(single i x) j) 0 = ite (p i) (⇑(single i x) j) 0", "decl_nm": "dfinsupp.filter_single"
{"src": "⊢ ∀ {α : Type u_1} {s t : set α} (h : s ⊆ t) [_inst_1 : decidable_pred (λ (_x : α), _x ∈ s)] {x : ↥t}	  (hx : x.val ∉ s), ⇑((set.sum_diff_subset h).symm) x = inr ⟨↑x, _⟩", "decl_nm": "equiv.set.sum_diff_subset_symm_apply_of_not_mem"
{"src": "α : Type u_1,	s t : set α,	h : s ⊆ t,	_inst_1 : decidable_pred (λ (_x : α), _x ∈ s),	x : ↥t,	hx : x.val ∉ s	⊢ ⇑((set.sum_diff_subset h).symm) x = inr ⟨↑x, _⟩", "decl_nm": "equiv.set.sum_diff_subset_symm_apply_of_not_mem"
{"src": "α : Type u_1,	s t : set α,	h : s ⊆ t,	_inst_1 : decidable_pred (λ (_x : α), _x ∈ s),	x : ↥t,	hx : x.val ∉ s	⊢ ⇑(set.sum_diff_subset h) (⇑((set.sum_diff_subset h).symm) x) = ⇑(set.sum_diff_subset h) (inr ⟨↑x, _⟩)", "decl_nm": "equiv.set.sum_diff_subset_symm_apply_of_not_mem"
{"src": "α : Type u_1,	s t : set α,	h : s ⊆ t,	_inst_1 : decidable_pred (λ (_x : α), _x ∈ s),	x : ↥t,	hx : x.val ∉ s	⊢ x = inclusion _ ⟨↑x, _⟩", "decl_nm": "equiv.set.sum_diff_subset_symm_apply_of_not_mem"
{"src": "⊢ ∀ {α : Sort u} [_inst_1 : decidable_eq α] {a b x : α}, ⇑(swap a b) x ≠ x ↔ a ≠ b ∧ (x = a ∨ x = b)", "decl_nm": "equiv.swap_apply_ne_self_iff"
{"src": "α : Sort u,	_inst_1 : decidable_eq α,	a b x : α	⊢ ⇑(swap a b) x ≠ x ↔ a ≠ b ∧ (x = a ∨ x = b)", "decl_nm": "equiv.swap_apply_ne_self_iff"
{"src": "2 goals	α : Sort u,	_inst_1 : decidable_eq α,	a b x : α,	hab : a = b	⊢ ⇑(swap a b) x ≠ x ↔ a ≠ b ∧ (x = a ∨ x = b)		α : Sort u,	_inst_1 : decidable_eq α,	a b x : α,	hab : ¬a = b	⊢ ⇑(swap a b) x ≠ x ↔ a ≠ b ∧ (x = a ∨ x = b)", "decl_nm": "equiv.swap_apply_ne_self_iff"
{"src": "α : Sort u,	_inst_1 : decidable_eq α,	a b x : α,	hab : ¬a = b	⊢ ⇑(swap a b) x ≠ x ↔ a ≠ b ∧ (x = a ∨ x = b)", "decl_nm": "equiv.swap_apply_ne_self_iff"
{"src": "2 goals	α : Sort u,	_inst_1 : decidable_eq α,	a b x : α,	hab : ¬a = b,	hax : x = a	⊢ ⇑(swap a b) x ≠ x ↔ a ≠ b ∧ (x = a ∨ x = b)		α : Sort u,	_inst_1 : decidable_eq α,	a b x : α,	hab : ¬a = b,	hax : ¬x = a	⊢ ⇑(swap a b) x ≠ x ↔ a ≠ b ∧ (x = a ∨ x = b)", "decl_nm": "equiv.swap_apply_ne_self_iff"
{"src": "α : Sort u,	_inst_1 : decidable_eq α,	a b x : α,	hab : ¬a = b,	hax : ¬x = a	⊢ ⇑(swap a b) x ≠ x ↔ a ≠ b ∧ (x = a ∨ x = b)", "decl_nm": "equiv.swap_apply_ne_self_iff"
{"src": "2 goals	α : Sort u,	_inst_1 : decidable_eq α,	a b x : α,	hab : ¬a = b,	hax : ¬x = a,	hbx : x = b	⊢ ⇑(swap a b) x ≠ x ↔ a ≠ b ∧ (x = a ∨ x = b)		α : Sort u,	_inst_1 : decidable_eq α,	a b x : α,	hab : ¬a = b,	hax : ¬x = a,	hbx : ¬x = b	⊢ ⇑(swap a b) x ≠ x ↔ a ≠ b ∧ (x = a ∨ x = b)", "decl_nm": "equiv.swap_apply_ne_self_iff"
{"src": "α : Sort u,	_inst_1 : decidable_eq α,	a b x : α,	hab : ¬a = b,	hax : ¬x = a,	hbx : ¬x = b	⊢ ⇑(swap a b) x ≠ x ↔ a ≠ b ∧ (x = a ∨ x = b)", "decl_nm": "equiv.swap_apply_ne_self_iff"
{"src": "⊢ ∀ {α : Type u_1} {β : Type u_2} [_inst_2 : decidable_eq α] [_inst_3 : decidable_eq β] (i j : α),	    (swap i j).sum_congr (equiv.refl β) = swap (inl i) (inl j)", "decl_nm": "equiv.perm.sum_congr_swap_refl"
{"src": "α : Type u_1,	β : Type u_2,	_inst_2 : decidable_eq α,	_inst_3 : decidable_eq β,	i j : α	⊢ (swap i j).sum_congr (equiv.refl β) = swap (inl i) (inl j)", "decl_nm": "equiv.perm.sum_congr_swap_refl"
{"src": "α : Type u_1,	β : Type u_2,	_inst_2 : decidable_eq α,	_inst_3 : decidable_eq β,	i j : α,	x : α ⊕ β	⊢ ⇑((swap i j).sum_congr (equiv.refl β)) x = ⇑(swap (inl i) (inl j)) x", "decl_nm": "equiv.perm.sum_congr_swap_refl"
{"src": "2 goals	case sum.inl	α : Type u_1,	β : Type u_2,	_inst_2 : decidable_eq α,	_inst_3 : decidable_eq β,	i j x : α	⊢ ⇑((swap i j).sum_congr (equiv.refl β)) (inl x) = ⇑(swap (inl i) (inl j)) (inl x)		case sum.inr	α : Type u_1,	β : Type u_2,	_inst_2 : decidable_eq α,	_inst_3 : decidable_eq β,	i j : α,	x : β	⊢ ⇑((swap i j).sum_congr (equiv.refl β)) (inr x) = ⇑(swap (inl i) (inl j)) (inr x)", "decl_nm": "equiv.perm.sum_congr_swap_refl"
{"src": "2 goals	case sum.inl	α : Type u_1,	β : Type u_2,	_inst_2 : decidable_eq α,	_inst_3 : decidable_eq β,	i j x : α	⊢ inl (ite (x = i) j (ite (x = j) i x)) = ite (x = i) (inl j) (ite (x = j) (inl i) (inl x))		case sum.inr	α : Type u_1,	β : Type u_2,	_inst_2 : decidable_eq α,	_inst_3 : decidable_eq β,	i j : α,	x : β	⊢ ⇑((swap i j).sum_congr (equiv.refl β)) (inr x) = ⇑(swap (inl i) (inl j)) (inr x)", "decl_nm": "equiv.perm.sum_congr_swap_refl"
{"src": "4 goals	α : Type u_1,	β : Type u_2,	_inst_2 : decidable_eq α,	_inst_3 : decidable_eq β,	i j x : α,	h : x = i	⊢ j = j		α : Type u_1,	β : Type u_2,	_inst_2 : decidable_eq α,	_inst_3 : decidable_eq β,	i j x : α,	h : ¬x = i,	h_1 : x = j	⊢ i = i		α : Type u_1,	β : Type u_2,	_inst_2 : decidable_eq α,	_inst_3 : decidable_eq β,	i j x : α,	h : ¬x = i,	h_1 : ¬x = j	⊢ x = x		case sum.inr	α : Type u_1,	β : Type u_2,	_inst_2 : decidable_eq α,	_inst_3 : decidable_eq β,	i j : α,	x : β	⊢ ⇑((swap i j).sum_congr (equiv.refl β)) (inr x) = ⇑(swap (inl i) (inl j)) (inr x)", "decl_nm": "equiv.perm.sum_congr_swap_refl"
{"src": "3 goals	α : Type u_1,	β : Type u_2,	_inst_2 : decidable_eq α,	_inst_3 : decidable_eq β,	i j x : α,	h : ¬x = i,	h_1 : x = j	⊢ i = i		α : Type u_1,	β : Type u_2,	_inst_2 : decidable_eq α,	_inst_3 : decidable_eq β,	i j x : α,	h : ¬x = i,	h_1 : ¬x = j	⊢ x = x		case sum.inr	α : Type u_1,	β : Type u_2,	_inst_2 : decidable_eq α,	_inst_3 : decidable_eq β,	i j : α,	x : β	⊢ ⇑((swap i j).sum_congr (equiv.refl β)) (inr x) = ⇑(swap (inl i) (inl j)) (inr x)", "decl_nm": "equiv.perm.sum_congr_swap_refl"
{"src": "2 goals	α : Type u_1,	β : Type u_2,	_inst_2 : decidable_eq α,	_inst_3 : decidable_eq β,	i j x : α,	h : ¬x = i,	h_1 : ¬x = j	⊢ x = x		case sum.inr	α : Type u_1,	β : Type u_2,	_inst_2 : decidable_eq α,	_inst_3 : decidable_eq β,	i j : α,	x : β	⊢ ⇑((swap i j).sum_congr (equiv.refl β)) (inr x) = ⇑(swap (inl i) (inl j)) (inr x)", "decl_nm": "equiv.perm.sum_congr_swap_refl"
{"src": "case sum.inr	α : Type u_1,	β : Type u_2,	_inst_2 : decidable_eq α,	_inst_3 : decidable_eq β,	i j : α,	x : β	⊢ ⇑((swap i j).sum_congr (equiv.refl β)) (inr x) = ⇑(swap (inl i) (inl j)) (inr x)", "decl_nm": "equiv.perm.sum_congr_swap_refl"
{"src": "⊢ ∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {s : set α} {t : set β} {u : set γ},	    ⇑(prod_assoc α β γ) ⁻¹' (s ×ˢ (t ×ˢ u)) = s ×ˢ t ×ˢ u", "decl_nm": "equiv.prod_assoc_preimage"
{"src": "α : Type u_1,	β : Type u_2,	γ : Type u_3,	s : set α,	t : set β,	u : set γ	⊢ ⇑(prod_assoc α β γ) ⁻¹' (s ×ˢ (t ×ˢ u)) = s ×ˢ t ×ˢ u", "decl_nm": "equiv.prod_assoc_preimage"
{"src": "α : Type u_1,	β : Type u_2,	γ : Type u_3,	s : set α,	t : set β,	u : set γ,	x : (α × β) × γ	⊢ x ∈ ⇑(prod_assoc α β γ) ⁻¹' (s ×ˢ (t ×ˢ u)) ↔ x ∈ s ×ˢ t ×ˢ u", "decl_nm": "equiv.prod_assoc_preimage"
{"src": "⊢ ∀ {n : ℕ}, ⇑(fin_succ_equiv n) 0 = option.none", "decl_nm": "fin_succ_equiv_zero"
{"src": "n : ℕ	⊢ ⇑(fin_succ_equiv n) 0 = option.none", "decl_nm": "fin_succ_equiv_zero"
{"src": "2 goals	case nat.zero	⊢ ⇑(fin_succ_equiv 0) 0 = option.none		case nat.succ	n : ℕ	⊢ ⇑(fin_succ_equiv n.succ) 0 = option.none", "decl_nm": "fin_succ_equiv_zero"
{"src": "case nat.succ	n : ℕ	⊢ ⇑(fin_succ_equiv n.succ) 0 = option.none", "decl_nm": "fin_succ_equiv_zero"
{"src": "⊢ ∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} (e : local_equiv α β) (e' : local_equiv β γ),	    (e.trans e').source = e.source ∩ ⇑e ⁻¹' (e.target ∩ e'.source)", "decl_nm": "local_equiv.trans_source'"
{"src": "α : Type u_1,	β : Type u_2,	γ : Type u_3,	e : local_equiv α β,	e' : local_equiv β γ	⊢ (e.trans e').source = e.source ∩ ⇑e ⁻¹' (e.target ∩ e'.source)", "decl_nm": "local_equiv.trans_source'"
{"src": "⊢ ∀ {α : Sort u_1} (a : α), (mk a).out = a", "decl_nm": "erased.out_mk"
{"src": "α : Sort u_1,	a : α	⊢ (mk a).out = a", "decl_nm": "erased.out_mk"
{"src": "2 goals	α : Sort u_1,	a : α	⊢ ?m_1		α : Sort u_1,	a : α,	h : ?m_2 := ?m_1	⊢ (mk a).out = a", "decl_nm": "erased.out_mk"
{"src": "α : Sort u_1,	a : α,	h : ∃ (x : α), (λ (b : α), x = b) = λ (b : α), a = b := mk._proof_1 a	⊢ classical.some h = a", "decl_nm": "erased.out_mk"
{"src": "α : Sort u_1,	a : α,	h : ∃ (x : α), (λ (b : α), x = b) = λ (b : α), a = b := mk._proof_1 a,	this : (λ (b : α), classical.some h = b) = λ (b : α), a = b	⊢ classical.some h = a", "decl_nm": "erased.out_mk"
{"src": "⊢ ∀ {m n : ℕ} {C : fin (m + n) → Sort u_1} (hleft : Π (i : fin m), C (⇑(cast_add n) i))	  (hright : Π (i : fin n), C (⇑(nat_add m) i)) (i : fin n), add_cases hleft hright (⇑(nat_add m) i) = hright i", "decl_nm": "fin.add_cases_right"
{"src": "m n : ℕ,	C : fin (m + n) → Sort u_1,	hleft : Π (i : fin m), C (⇑(cast_add n) i),	hright : Π (i : fin n), C (⇑(nat_add m) i),	i : fin n	⊢ add_cases hleft hright (⇑(nat_add m) i) = hright i", "decl_nm": "fin.add_cases_right"
{"src": "2 goals	m n : ℕ,	C : fin (m + n) → Sort u_1,	hleft : Π (i : fin m), C (⇑(cast_add n) i),	hright : Π (i : fin n), C (⇑(nat_add m) i),	i : fin n	⊢ ¬↑(⇑(nat_add m) i) < m		m n : ℕ,	C : fin (m + n) → Sort u_1,	hleft : Π (i : fin m), C (⇑(cast_add n) i),	hright : Π (i : fin n), C (⇑(nat_add m) i),	i : fin n,	this : ¬↑(⇑(nat_add m) i) < m	⊢ add_cases hleft hright (⇑(nat_add m) i) = hright i", "decl_nm": "fin.add_cases_right"
{"src": "m n : ℕ,	C : fin (m + n) → Sort u_1,	hleft : Π (i : fin m), C (⇑(cast_add n) i),	hright : Π (i : fin n), C (⇑(nat_add m) i),	i : fin n,	this : ¬↑(⇑(nat_add m) i) < m	⊢ add_cases hleft hright (⇑(nat_add m) i) = hright i", "decl_nm": "fin.add_cases_right"
{"src": "m n : ℕ,	C : fin (m + n) → Sort u_1,	hleft : Π (i : fin m), C (⇑(cast_add n) i),	hright : Π (i : fin n), C (⇑(nat_add m) i),	i : fin n,	this : ¬↑(⇑(nat_add m) i) < m	⊢ _.rec_on (hright (sub_nat m (⇑(cast _) (⇑(nat_add m) i)) _)) = hright i", "decl_nm": "fin.add_cases_right"
{"src": "m n : ℕ,	C : fin (m + n) → Sort u_1,	hleft : Π (i : fin m), C (⇑(cast_add n) i),	hright : Π (i : fin n), C (⇑(nat_add m) i),	i : fin n,	this : ¬↑(⇑(nat_add m) i) < m	⊢ hright (sub_nat m (⇑(cast _) (⇑(nat_add m) i)) _) == hright i", "decl_nm": "fin.add_cases_right"
{"src": "m n : ℕ,	C : fin (m + n) → Sort u_1,	hleft : Π (i : fin m), C (⇑(cast_add n) i),	hright : Π (i : fin n), C (⇑(nat_add m) i),	i : fin n,	this : ¬↑(⇑(nat_add m) i) < m	⊢ sub_nat m (⇑(cast _) (⇑(nat_add m) i)) _ = i", "decl_nm": "fin.add_cases_right"
{"src": "⊢ ∀ {n : ℕ} {α : Type u_1} {β : Type u_2} (g : α → β) (y : α) (q : fin n → α),	    g ∘ cons y q = cons (g y) (g ∘ q)", "decl_nm": "fin.comp_cons"
{"src": "n : ℕ,	α : Type u_1,	β : Type u_2,	g : α → β,	y : α,	q : fin n → α	⊢ g ∘ cons y q = cons (g y) (g ∘ q)", "decl_nm": "fin.comp_cons"
{"src": "n : ℕ,	α : Type u_1,	β : Type u_2,	g : α → β,	y : α,	q : fin n → α,	j : fin (n + 1)	⊢ (g ∘ cons y q) j = cons (g y) (g ∘ q) j", "decl_nm": "fin.comp_cons"
{"src": "2 goals	n : ℕ,	α : Type u_1,	β : Type u_2,	g : α → β,	y : α,	q : fin n → α,	j : fin (n + 1),	h : j = 0	⊢ (g ∘ cons y q) j = cons (g y) (g ∘ q) j		n : ℕ,	α : Type u_1,	β : Type u_2,	g : α → β,	y : α,	q : fin n → α,	j : fin (n + 1),	h : ¬j = 0	⊢ (g ∘ cons y q) j = cons (g y) (g ∘ q) j", "decl_nm": "fin.comp_cons"
{"src": "2 goals	n : ℕ,	α : Type u_1,	β : Type u_2,	g : α → β,	y : α,	q : fin n → α,	j : fin (n + 1),	h : j = 0	⊢ (g ∘ cons y q) 0 = cons (g y) (g ∘ q) 0		n : ℕ,	α : Type u_1,	β : Type u_2,	g : α → β,	y : α,	q : fin n → α,	j : fin (n + 1),	h : ¬j = 0	⊢ (g ∘ cons y q) j = cons (g y) (g ∘ q) j", "decl_nm": "fin.comp_cons"
{"src": "n : ℕ,	α : Type u_1,	β : Type u_2,	g : α → β,	y : α,	q : fin n → α,	j : fin (n + 1),	h : ¬j = 0	⊢ (g ∘ cons y q) j = cons (g y) (g ∘ q) j", "decl_nm": "fin.comp_cons"
{"src": "n : ℕ,	α : Type u_1,	β : Type u_2,	g : α → β,	y : α,	q : fin n → α,	j : fin (n + 1),	h : ¬j = 0,	j' : fin n := j.pred h	⊢ (g ∘ cons y q) j = cons (g y) (g ∘ q) j", "decl_nm": "fin.comp_cons"
{"src": "n : ℕ,	α : Type u_1,	β : Type u_2,	g : α → β,	y : α,	q : fin n → α,	j : fin (n + 1),	h : ¬j = 0,	j' : fin n := j.pred h,	this : j'.succ = j	⊢ (g ∘ cons y q) j = cons (g y) (g ∘ q) j", "decl_nm": "fin.comp_cons"
{"src": "⊢ ∀ {n : ℕ} {β : Type v} (x : β) (p : fin n → β), 0.insert_nth x p = cons x p", "decl_nm": "fin.insert_nth_zero'"
{"src": "n : ℕ,	β : Type v,	x : β,	p : fin n → β	⊢ 0.insert_nth x p = cons x p", "decl_nm": "fin.insert_nth_zero'"
{"src": "⊢ ∀ {n : ℕ} (a : fin (n + 1)), ↑(a.val) = a", "decl_nm": "fin.coe_val_eq_self"
{"src": "n : ℕ,	a : fin (n + 1)	⊢ ↑(a.val) = a", "decl_nm": "fin.coe_val_eq_self"
{"src": "n : ℕ,	a : fin (n + 1)	⊢ ↑(a.val).val = a.val", "decl_nm": "fin.coe_val_eq_self"
{"src": "⊢ ∀ (n : ℕ), ↑n = last n", "decl_nm": "fin.coe_nat_eq_last"
{"src": "n : ℕ	⊢ ↑n = last n", "decl_nm": "fin.coe_nat_eq_last"
{"src": "n : ℕ	⊢ ⟨n % n.succ, _⟩ = ⟨n, _⟩", "decl_nm": "fin.coe_nat_eq_last"
{"src": "⊢ ∀ {n : ℕ} {a : fin n}, ↑a = ⇑cast_succ a", "decl_nm": "fin.coe_eq_cast_succ"
{"src": "n : ℕ,	a : fin n	⊢ ↑a = ⇑cast_succ a", "decl_nm": "fin.coe_eq_cast_succ"
{"src": "n : ℕ,	a : fin n	⊢ ↑↑a = ↑(⇑cast_succ a)", "decl_nm": "fin.coe_eq_cast_succ"
{"src": "⊢ ∀ {α : Type u_1} {δ : α → Sort u_4} (s : finset α) (f g : Π (i : α), δ i)	  [_inst_1 : Π (j : α), decidable (j ∈ s)] {i : α} (p : δ i → Prop),	    p (f i) → p (g i) → p (s.piecewise f g i)", "decl_nm": "finset.piecewise_cases"
{"src": "α : Type u_1,	δ : α → Sort u_4,	s : finset α,	f g : Π (i : α), δ i,	_inst_1 : Π (j : α), decidable (j ∈ s),	i : α,	p : δ i → Prop,	hf : p (f i),	hg : p (g i)	⊢ p (s.piecewise f g i)", "decl_nm": "finset.piecewise_cases"
{"src": "2 goals	α : Type u_1,	δ : α → Sort u_4,	s : finset α,	f g : Π (i : α), δ i,	_inst_1 : Π (j : α), decidable (j ∈ s),	i : α,	p : δ i → Prop,	hf : p (f i),	hg : p (g i),	hi : i ∈ s	⊢ p (s.piecewise f g i)		α : Type u_1,	δ : α → Sort u_4,	s : finset α,	f g : Π (i : α), δ i,	_inst_1 : Π (j : α), decidable (j ∈ s),	i : α,	p : δ i → Prop,	hf : p (f i),	hg : p (g i),	hi : i ∉ s	⊢ p (s.piecewise f g i)", "decl_nm": "finset.piecewise_cases"
{"src": "α : Type u_1,	δ : α → Sort u_4,	s : finset α,	f g : Π (i : α), δ i,	_inst_1 : Π (j : α), decidable (j ∈ s),	i : α,	p : δ i → Prop,	hf : p (f i),	hg : p (g i),	hi : i ∉ s	⊢ p (s.piecewise f g i)", "decl_nm": "finset.piecewise_cases"
{"src": "⊢ ∀ {α : Type u_1} (p : α → Prop) [_inst_1 : decidable_pred p] [_inst_3 : decidable_eq α]	  [_inst_4 : decidable_pred (λ (a : α), ¬p a)] (s : finset α), filter p s ∩ filter (λ (a : α), ¬p a) s = ∅", "decl_nm": "finset.filter_inter_filter_neg_eq"
{"src": "α : Type u_1,	p : α → Prop,	_inst_1 : decidable_pred p,	_inst_3 : decidable_eq α,	_inst_4 : decidable_pred (λ (a : α), ¬p a),	s : finset α	⊢ filter p s ∩ filter (λ (a : α), ¬p a) s = ∅", "decl_nm": "finset.filter_inter_filter_neg_eq"
{"src": "⊢ ∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [_inst_1 : decidable_eq β] [_inst_2 : decidable_eq γ]	  {f : α → β} {s : finset α} {t : β → finset γ}, (image f s).bUnion t = s.bUnion (λ (a : α), t (f a))", "decl_nm": "finset.image_bUnion"
{"src": "α : Type u_1,	β : Type u_2,	γ : Type u_3,	_inst_1 : decidable_eq β,	_inst_2 : decidable_eq γ,	f : α → β,	s : finset α,	t : β → finset γ	⊢ (image f s).bUnion t = s.bUnion (λ (a : α), t (f a))", "decl_nm": "finset.image_bUnion"
{"src": "α : Type u_1,	β : Type u_2,	γ : Type u_3,	_inst_1 : decidable_eq β,	_inst_2 : decidable_eq γ,	f : α → β,	s : finset α,	t : β → finset γ,	_inst : decidable_eq α	⊢ (image f s).bUnion t = s.bUnion (λ (a : α), t (f a))", "decl_nm": "finset.image_bUnion"
{"src": "⊢ ∀ {α : Type u_1} {a b : finset α} [_inst_2 : decidable_eq α], disjoint a b ↔ disjoint ↑a ↑b", "decl_nm": "finset.disjoint_iff_disjoint_coe"
{"src": "α : Type u_1,	a b : finset α,	_inst_2 : decidable_eq α	⊢ disjoint a b ↔ disjoint ↑a ↑b", "decl_nm": "finset.disjoint_iff_disjoint_coe"
{"src": "α : Type u_1,	a b : finset α,	_inst_2 : decidable_eq α	⊢ (∀ {a_1 : α}, a_1 ∈ a → a_1 ∉ b) ↔ ∀ {a_1 : α}, a_1 ∈ ↑a → a_1 ∉ ↑b", "decl_nm": "finset.disjoint_iff_disjoint_coe"
{"src": "⊢ ∀ {α : Type u_1} [_inst_1 : linear_order α] (s : finset α) (h₂ : 1 < s.card), s.min' _ < s.max' _", "decl_nm": "finset.min'_lt_max'_of_card"
{"src": "α : Type u_1,	_inst_1 : linear_order α,	s : finset α,	h₂ : 1 < s.card	⊢ s.min' _ < s.max' _", "decl_nm": "finset.min'_lt_max'_of_card"
{"src": "α : Type u_1,	_inst_1 : linear_order α,	s : finset α,	h₂ : 1 < s.card,	a : α,	ha : a ∈ s,	b : α,	hb : b ∈ s,	hab : a ≠ b	⊢ s.min' _ < s.max' _", "decl_nm": "finset.min'_lt_max'_of_card"
{"src": "⊢ ∀ {α : Type u_1} {β : Type u_2} {M : Type u_5} [_inst_1 : add_comm_monoid M] {f : α → β},	    function.injective f → function.injective (map_domain f)", "decl_nm": "finsupp.map_domain_injective"
{"src": "α : Type u_1,	β : Type u_2,	M : Type u_5,	_inst_1 : add_comm_monoid M,	f : α → β,	hf : function.injective f	⊢ function.injective (map_domain f)", "decl_nm": "finsupp.map_domain_injective"
{"src": "α : Type u_1,	β : Type u_2,	M : Type u_5,	_inst_1 : add_comm_monoid M,	f : α → β,	hf : function.injective f,	v₁ v₂ : α →₀ M,	eq : map_domain f v₁ = map_domain f v₂	⊢ v₁ = v₂", "decl_nm": "finsupp.map_domain_injective"
{"src": "α : Type u_1,	β : Type u_2,	M : Type u_5,	_inst_1 : add_comm_monoid M,	f : α → β,	hf : function.injective f,	v₁ v₂ : α →₀ M,	eq : map_domain f v₁ = map_domain f v₂,	a : α	⊢ ⇑v₁ a = ⇑v₂ a", "decl_nm": "finsupp.map_domain_injective"
{"src": "2 goals	α : Type u_1,	β : Type u_2,	M : Type u_5,	_inst_1 : add_comm_monoid M,	f : α → β,	hf : function.injective f,	v₁ v₂ : α →₀ M,	eq : map_domain f v₁ = map_domain f v₂,	a : α	⊢ ⇑(map_domain f v₁) (f a) = ⇑(map_domain f v₂) (f a)		α : Type u_1,	β : Type u_2,	M : Type u_5,	_inst_1 : add_comm_monoid M,	f : α → β,	hf : function.injective f,	v₁ v₂ : α →₀ M,	eq : map_domain f v₁ = map_domain f v₂,	a : α,	this : ⇑(map_domain f v₁) (f a) = ⇑(map_domain f v₂) (f a)	⊢ ⇑v₁ a = ⇑v₂ a", "decl_nm": "finsupp.map_domain_injective"
{"src": "α : Type u_1,	β : Type u_2,	M : Type u_5,	_inst_1 : add_comm_monoid M,	f : α → β,	hf : function.injective f,	v₁ v₂ : α →₀ M,	eq : map_domain f v₁ = map_domain f v₂,	a : α,	this : ⇑(map_domain f v₁) (f a) = ⇑(map_domain f v₂) (f a)	⊢ ⇑v₁ a = ⇑v₂ a", "decl_nm": "finsupp.map_domain_injective"
{"src": "⊢ ∀ {α : Type u_1} {M : Type u_5} [_inst_1 : has_zero M] {s : finset α} {f : α → M}	  (hf : ∀ (a : α), f a ≠ 0 → a ∈ s) {a : α}, a ∈ (on_finset s f hf).support ↔ f a ≠ 0", "decl_nm": "finsupp.mem_support_on_finset"
{"src": "α : Type u_1,	M : Type u_5,	_inst_1 : has_zero M,	s : finset α,	f : α → M,	hf : ∀ (a : α), f a ≠ 0 → a ∈ s,	a : α	⊢ a ∈ (on_finset s f hf).support ↔ f a ≠ 0", "decl_nm": "finsupp.mem_support_on_finset"
{"src": "⊢ ∀ {α : Type u_1} {M : Type u_5} {N : Type u_7} [_inst_1 : has_zero M] [_inst_3 : comm_monoid N]	  [_inst_4 : decidable_eq α] (f : α →₀ M) (a : α) (b : α → M → N),	    f.prod (λ (x : α) (v : M), ite (x = a) (b x v) 1) = ite (a ∈ f.support) (b a (⇑f a)) 1", "decl_nm": "finsupp.prod_ite_eq'"
{"src": "α : Type u_1,	M : Type u_5,	N : Type u_7,	_inst_1 : has_zero M,	_inst_3 : comm_monoid N,	_inst_4 : decidable_eq α,	f : α →₀ M,	a : α,	b : α → M → N	⊢ f.prod (λ (x : α) (v : M), ite (x = a) (b x v) 1) = ite (a ∈ f.support) (b a (⇑f a)) 1", "decl_nm": "finsupp.prod_ite_eq'"
{"src": "α : Type u_1,	M : Type u_5,	N : Type u_7,	_inst_1 : has_zero M,	_inst_3 : comm_monoid N,	_inst_4 : decidable_eq α,	f : α →₀ M,	a : α,	b : α → M → N	⊢ f.support.prod (λ (a_1 : α), ite (a_1 = a) (b a_1 (⇑f a_1)) 1) = ite (a ∈ f.support) (b a (⇑f a)) 1", "decl_nm": "finsupp.prod_ite_eq'"
{"src": "⊢ ∀ {α : Type u_1} {β : α → Type u_2} [_inst_1 : decidable_eq α] [_inst_2 : fintype α]	  [_inst_3 : Π (a : α), fintype (β a)], univ.pi (λ (a : α), univ) = univ", "decl_nm": "finset.univ_pi_univ"
{"src": "α : Type u_1,	β : α → Type u_2,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	_inst_3 : Π (a : α), fintype (β a)	⊢ univ.pi (λ (a : α), univ) = univ", "decl_nm": "finset.univ_pi_univ"
{"src": "α : Type u_1,	β : α → Type u_2,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	_inst_3 : Π (a : α), fintype (β a),	a : Π (a : α), a ∈ univ → (λ (a : α), β a) a	⊢ a ∈ univ.pi (λ (a : α), univ) ↔ a ∈ univ", "decl_nm": "finset.univ_pi_univ"
{"src": "⊢ ∀ {α : Type u_1} [_inst_1 : decidable_eq α] [_inst_2 : fintype α] {δ : α → Type u_2}	  (t : Π (a : α), finset (δ a)), (fintype.pi_finset t).card = univ.prod (λ (a : α), (t a).card)", "decl_nm": "fintype.card_pi_finset"
{"src": "α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	δ : α → Type u_2,	t : Π (a : α), finset (δ a)	⊢ (fintype.pi_finset t).card = univ.prod (λ (a : α), (t a).card)", "decl_nm": "fintype.card_pi_finset"
{"src": "⊢ ∀ (a : ℤ) {b c : ℤ}, c ∣ b → (a - b) / c = a / c - b / c", "decl_nm": "int.sub_div_of_dvd"
{"src": "a b c : ℤ,	hcb : c ∣ b	⊢ (a - b) / c = a / c - b / c", "decl_nm": "int.sub_div_of_dvd"
{"src": "a b c : ℤ,	hcb : c ∣ b	⊢ a / c + -b / c = a / c + -(b / c)", "decl_nm": "int.sub_div_of_dvd"
{"src": "a b c : ℤ,	hcb : c ∣ b	⊢ -b / c = -(b / c)", "decl_nm": "int.sub_div_of_dvd"
{"src": "⊢ ∀ (n : ℕ), ↑(bit1 n) = bit1 ↑n", "decl_nm": "int.coe_nat_bit1"
{"src": "n : ℕ	⊢ ↑(bit1 n) = bit1 ↑n", "decl_nm": "int.coe_nat_bit1"
{"src": "n : ℕ	⊢ ↑(bit0 n + 1) = bit0 ↑n + 1", "decl_nm": "int.coe_nat_bit1"
{"src": "n : ℕ	⊢ ↑(n + n + 1) = ↑n + ↑n + 1", "decl_nm": "int.coe_nat_bit1"
{"src": "⊢ ∀ (i j k : ℤ), (i * j).gcd (k * j) = i.gcd k * j.nat_abs", "decl_nm": "int.gcd_mul_right"
{"src": "i j k : ℤ	⊢ (i * j).gcd (k * j) = i.gcd k * j.nat_abs", "decl_nm": "int.gcd_mul_right"
{"src": "i j k : ℤ	⊢ (i.nat_abs * j.nat_abs).gcd (k.nat_abs * j.nat_abs) = i.nat_abs.gcd k.nat_abs * j.nat_abs", "decl_nm": "int.gcd_mul_right"
{"src": "⊢ ∀ (i j : ℤ), i.lcm j = j.lcm i", "decl_nm": "int.lcm_comm"
{"src": "i j : ℤ	⊢ i.lcm j = j.lcm i", "decl_nm": "int.lcm_comm"
{"src": "i j : ℤ	⊢ i.nat_abs.lcm j.nat_abs = j.nat_abs.lcm i.nat_abs", "decl_nm": "int.lcm_comm"
{"src": "⊢ ∀ (x y : ℕ), x.xgcd y = (x.gcd_a y, x.gcd_b y)", "decl_nm": "nat.xgcd_val"
{"src": "x y : ℕ	⊢ x.xgcd y = (x.gcd_a y, x.gcd_b y)", "decl_nm": "nat.xgcd_val"
{"src": "x y : ℕ	⊢ x.xgcd y = ((x.xgcd y).fst, (x.xgcd y).snd)", "decl_nm": "nat.xgcd_val"
{"src": "x y : ℕ,	fst snd : ℤ	⊢ (fst, snd) = ((fst, snd).fst, (fst, snd).snd)", "decl_nm": "nat.xgcd_val"
{"src": "⊢ ∀ {m n : ℤ}, odd (m + n) ↔ (odd m ↔ even n)", "decl_nm": "int.odd_add"
{"src": "m n : ℤ	⊢ odd (m + n) ↔ (odd m ↔ even n)", "decl_nm": "int.odd_add"
{"src": "⊢ ∀ (n : ℤ), even (n * (n + 1))", "decl_nm": "int.even_mul_succ_self"
{"src": "n : ℤ	⊢ even (n * (n + 1))", "decl_nm": "int.even_mul_succ_self"
{"src": "n : ℤ	⊢ even n ∨ even (n + 1)", "decl_nm": "int.even_mul_succ_self"
{"src": "n : ℤ	⊢ even (n + 1) = odd n", "decl_nm": "int.even_mul_succ_self"
{"src": "⊢ ∀ (n : ℤ), ∃ (k : ℤ), n = 2 * k ∨ n = 2 * k + 1", "decl_nm": "int.even_or_odd'"
{"src": "n : ℤ	⊢ ∃ (k : ℤ), n = 2 * k ∨ n = 2 * k + 1", "decl_nm": "int.even_or_odd'"
{"src": "⊢ ∀ {α : Type u} {f g : list α → list α} (m n : ℕ) (l : list α),	    n ≤ m →	    modify_nth_tail g m (modify_nth_tail f n l) =	      modify_nth_tail (λ (l : list α), modify_nth_tail g (m - n) (f l)) n l", "decl_nm": "list.modify_nth_tail_modify_nth_tail_le"
{"src": "α : Type u,	f g : list α → list α,	m n : ℕ,	l : list α,	h : n ≤ m	⊢ modify_nth_tail g m (modify_nth_tail f n l) =	    modify_nth_tail (λ (l : list α), modify_nth_tail g (m - n) (f l)) n l", "decl_nm": "list.modify_nth_tail_modify_nth_tail_le"
{"src": "α : Type u,	f g : list α → list α,	n : ℕ,	l : list α,	m : ℕ,	h : n ≤ n + m	⊢ modify_nth_tail g (n + m) (modify_nth_tail f n l) =	    modify_nth_tail (λ (l : list α), modify_nth_tail g (n + m - n) (f l)) n l", "decl_nm": "list.modify_nth_tail_modify_nth_tail_le"
{"src": "⊢ ∀ {α : Type u} (l : list α) (x : α) (n : ℕ), l.length ≤ (insert_nth n x l).length", "decl_nm": "list.length_le_length_insert_nth"
{"src": "α : Type u,	l : list α,	x : α,	n : ℕ	⊢ l.length ≤ (insert_nth n x l).length", "decl_nm": "list.length_le_length_insert_nth"
{"src": "2 goals	case or.inl	α : Type u,	l : list α,	x : α,	n : ℕ,	hn : n ≤ l.length	⊢ l.length ≤ (insert_nth n x l).length		case or.inr	α : Type u,	l : list α,	x : α,	n : ℕ,	hn : l.length < n	⊢ l.length ≤ (insert_nth n x l).length", "decl_nm": "list.length_le_length_insert_nth"
{"src": "2 goals	case or.inl	α : Type u,	l : list α,	x : α,	n : ℕ,	hn : n ≤ l.length	⊢ l.length ≤ l.length + 1		case or.inr	α : Type u,	l : list α,	x : α,	n : ℕ,	hn : l.length < n	⊢ l.length ≤ (insert_nth n x l).length", "decl_nm": "list.length_le_length_insert_nth"
{"src": "case or.inr	α : Type u,	l : list α,	x : α,	n : ℕ,	hn : l.length < n	⊢ l.length ≤ (insert_nth n x l).length", "decl_nm": "list.length_le_length_insert_nth"
{"src": "⊢ ∀ {α : Type u_1} (L₁ L₂ : list (list α)), (L₁ ++ L₂).join = L₁.join ++ L₂.join", "decl_nm": "list.join_append"
{"src": "α : Type u_1,	L₁ L₂ : list (list α)	⊢ (L₁ ++ L₂).join = L₁.join ++ L₂.join", "decl_nm": "list.join_append"
{"src": "2 goals	case list.nil	α : Type u_1,	L₂ : list (list α)	⊢ (nil ++ L₂).join = nil.join ++ L₂.join		case list.cons	α : Type u_1,	L₂ : list (list α),	L₁_hd : list α,	L₁_tl : list (list α),	L₁_ih : (L₁_tl ++ L₂).join = L₁_tl.join ++ L₂.join	⊢ (L₁_hd :: L₁_tl ++ L₂).join = (L₁_hd :: L₁_tl).join ++ L₂.join", "decl_nm": "list.join_append"
{"src": "case list.cons	α : Type u_1,	L₂ : list (list α),	L₁_hd : list α,	L₁_tl : list (list α),	L₁_ih : (L₁_tl ++ L₂).join = L₁_tl.join ++ L₂.join	⊢ (L₁_hd :: L₁_tl ++ L₂).join = (L₁_hd :: L₁_tl).join ++ L₂.join", "decl_nm": "list.join_append"
{"src": "⊢ ∀ {α : Type u} {p : α → Prop} [_inst_1 : decidable_pred p] {l : list α} {a : α},	    find p l = some a → a ∈ l", "decl_nm": "list.find_mem"
{"src": "α : Type u,	p : α → Prop,	_inst_1 : decidable_pred p,	l : list α,	a : α,	H : find p l = some a	⊢ a ∈ l", "decl_nm": "list.find_mem"
{"src": "2 goals	case list.nil	α : Type u,	p : α → Prop,	_inst_1 : decidable_pred p,	a : α,	H : find p nil = some a	⊢ a ∈ nil		case list.cons	α : Type u,	p : α → Prop,	_inst_1 : decidable_pred p,	a b : α,	l : list α,	IH : find p l = some a → a ∈ l,	H : find p (b :: l) = some a	⊢ a ∈ b :: l", "decl_nm": "list.find_mem"
{"src": "case list.cons	α : Type u,	p : α → Prop,	_inst_1 : decidable_pred p,	a b : α,	l : list α,	IH : find p l = some a → a ∈ l,	H : find p (b :: l) = some a	⊢ a ∈ b :: l", "decl_nm": "list.find_mem"
{"src": "2 goals	α : Type u,	p : α → Prop,	_inst_1 : decidable_pred p,	a b : α,	l : list α,	IH : find p l = some a → a ∈ l,	H : find p (b :: l) = some a,	h : p b	⊢ a ∈ b :: l		α : Type u,	p : α → Prop,	_inst_1 : decidable_pred p,	a b : α,	l : list α,	IH : find p l = some a → a ∈ l,	H : find p (b :: l) = some a,	h : ¬p b	⊢ a ∈ b :: l", "decl_nm": "list.find_mem"
{"src": "2 goals	α : Type u,	p : α → Prop,	_inst_1 : decidable_pred p,	a b : α,	l : list α,	IH : find p l = some a → a ∈ l,	h : p b,	H : some b = some a	⊢ a ∈ b :: l		α : Type u,	p : α → Prop,	_inst_1 : decidable_pred p,	a b : α,	l : list α,	IH : find p l = some a → a ∈ l,	H : find p (b :: l) = some a,	h : ¬p b	⊢ a ∈ b :: l", "decl_nm": "list.find_mem"
{"src": "2 goals	α : Type u,	p : α → Prop,	_inst_1 : decidable_pred p,	a : α,	l : list α,	IH : find p l = some a → a ∈ l,	h : p a,	H : some a = some a	⊢ a ∈ a :: l		α : Type u,	p : α → Prop,	_inst_1 : decidable_pred p,	a b : α,	l : list α,	IH : find p l = some a → a ∈ l,	H : find p (b :: l) = some a,	h : ¬p b	⊢ a ∈ b :: l", "decl_nm": "list.find_mem"
{"src": "α : Type u,	p : α → Prop,	_inst_1 : decidable_pred p,	a b : α,	l : list α,	IH : find p l = some a → a ∈ l,	H : find p (b :: l) = some a,	h : ¬p b	⊢ a ∈ b :: l", "decl_nm": "list.find_mem"
{"src": "α : Type u,	p : α → Prop,	_inst_1 : decidable_pred p,	a b : α,	l : list α,	IH : find p l = some a → a ∈ l,	h : ¬p b,	H : find p l = some a	⊢ a ∈ b :: l", "decl_nm": "list.find_mem"
{"src": "⊢ ∀ {α : Type u} {β : Type v} {f : α → option β} (a : α) (l : list α),	    f a = none → filter_map f (a :: l) = filter_map f l", "decl_nm": "list.filter_map_cons_none"
{"src": "α : Type u,	β : Type v,	f : α → option β,	a : α,	l : list α,	h : f a = none	⊢ filter_map f (a :: l) = filter_map f l", "decl_nm": "list.filter_map_cons_none"
{"src": "⊢ ∀ {α : Type u} {l : list (option α)} {x : α},	    (∃ (i : ℕ), l.nth i = some (some x)) ↔ ∃ (i : ℕ), l.reduce_option.nth i = some x", "decl_nm": "list.reduce_option_nth_iff"
{"src": "α : Type u,	l : list (option α),	x : α	⊢ (∃ (i : ℕ), l.nth i = some (some x)) ↔ ∃ (i : ℕ), l.reduce_option.nth i = some x", "decl_nm": "list.reduce_option_nth_iff"
{"src": "⊢ ∀ {α : Type u_1} (a : α) (l : list α), (a :: l).inits = nil :: map (λ (t : list α), a :: t) l.inits", "decl_nm": "list.inits_cons"
{"src": "α : Type u_1,	a : α,	l : list α	⊢ (a :: l).inits = nil :: map (λ (t : list α), a :: t) l.inits", "decl_nm": "list.inits_cons"
{"src": "⊢ ∀ {α : Type u_1} {β : Type u_2} {α' : Type u_3} {β' : Type u_4} (g : α → α') (g' : β → β') (t : α)	  (ts ys : list α) (r : list β) (f : list α → β) (f' : list α' → β'),	    (∀ (a : list α), g' (f a) = f' (map g a)) →	    map g' (permutations_aux2 t ts r ys f).snd = (permutations_aux2 (g t) (map g ts) (map g' r) (map g ys) f').snd", "decl_nm": "list.map_permutations_aux2'"
{"src": "α : Type u_1,	β : Type u_2,	α' : Type u_3,	β' : Type u_4,	g : α → α',	g' : β → β',	t : α,	ts ys : list α,	r : list β,	f : list α → β,	f' : list α' → β',	H : ∀ (a : list α), g' (f a) = f' (map g a)	⊢ map g' (permutations_aux2 t ts r ys f).snd = (permutations_aux2 (g t) (map g ts) (map g' r) (map g ys) f').snd", "decl_nm": "list.map_permutations_aux2'"
{"src": "2 goals	case list.nil	α : Type u_1,	β : Type u_2,	α' : Type u_3,	β' : Type u_4,	g : α → α',	g' : β → β',	t : α,	ts : list α,	r : list β,	f : list α → β,	f' : list α' → β',	H : ∀ (a : list α), g' (f a) = f' (map g a)	⊢ map g' (permutations_aux2 t ts r nil f).snd = (permutations_aux2 (g t) (map g ts) (map g' r) (map g nil) f').snd		case list.cons	α : Type u_1,	β : Type u_2,	α' : Type u_3,	β' : Type u_4,	g : α → α',	g' : β → β',	t : α,	ts : list α,	r : list β,	ys_hd : α,	ys_tl : list α,	ys_ih :	  ∀ (f : list α → β) (f' : list α' → β'),	    (∀ (a : list α), g' (f a) = f' (map g a)) →	    map g' (permutations_aux2 t ts r ys_tl f).snd =	      (permutations_aux2 (g t) (map g ts) (map g' r) (map g ys_tl) f').snd,	f : list α → β,	f' : list α' → β',	H : ∀ (a : list α), g' (f a) = f' (map g a)	⊢ map g' (permutations_aux2 t ts r (ys_hd :: ys_tl) f).snd =	    (permutations_aux2 (g t) (map g ts) (map g' r) (map g (ys_hd :: ys_tl)) f').snd", "decl_nm": "list.map_permutations_aux2'"
{"src": "case list.cons	α : Type u_1,	β : Type u_2,	α' : Type u_3,	β' : Type u_4,	g : α → α',	g' : β → β',	t : α,	ts : list α,	r : list β,	ys_hd : α,	ys_tl : list α,	ys_ih :	  ∀ (f : list α → β) (f' : list α' → β'),	    (∀ (a : list α), g' (f a) = f' (map g a)) →	    map g' (permutations_aux2 t ts r ys_tl f).snd =	      (permutations_aux2 (g t) (map g ts) (map g' r) (map g ys_tl) f').snd,	f : list α → β,	f' : list α' → β',	H : ∀ (a : list α), g' (f a) = f' (map g a)	⊢ map g' (permutations_aux2 t ts r (ys_hd :: ys_tl) f).snd =	    (permutations_aux2 (g t) (map g ts) (map g' r) (map g (ys_hd :: ys_tl)) f').snd", "decl_nm": "list.map_permutations_aux2'"
{"src": "case list.cons	α : Type u_1,	β : Type u_2,	α' : Type u_3,	β' : Type u_4,	g : α → α',	g' : β → β',	t : α,	ts : list α,	r : list β,	ys_hd : α,	ys_tl : list α,	ys_ih :	  ∀ (f : list α → β) (f' : list α' → β'),	    (∀ (a : list α), g' (f a) = f' (map g a)) →	    map g' (permutations_aux2 t ts r ys_tl f).snd =	      (permutations_aux2 (g t) (map g ts) (map g' r) (map g ys_tl) f').snd,	f : list α → β,	f' : list α' → β',	H : ∀ (a : list α), g' (f a) = f' (map g a)	⊢ map g' (permutations_aux2 t ts r ys_tl (λ (x : list α), f (ys_hd :: x))).snd =	    (permutations_aux2 (g t) (map g ts) (map g' r) (map g ys_tl) (λ (x : list α'), f' (g ys_hd :: x))).snd", "decl_nm": "list.map_permutations_aux2'"
{"src": "α : Type u_1,	β : Type u_2,	α' : Type u_3,	β' : Type u_4,	g : α → α',	g' : β → β',	t : α,	ts : list α,	r : list β,	ys_hd : α,	ys_tl : list α,	ys_ih :	  ∀ (f : list α → β) (f' : list α' → β'),	    (∀ (a : list α), g' (f a) = f' (map g a)) →	    map g' (permutations_aux2 t ts r ys_tl f).snd =	      (permutations_aux2 (g t) (map g ts) (map g' r) (map g ys_tl) f').snd,	f : list α → β,	f' : list α' → β',	H : ∀ (a : list α), g' (f a) = f' (map g a)	⊢ ∀ (a : list α), g' (f (ys_hd :: a)) = f' (g ys_hd :: map g a)", "decl_nm": "list.map_permutations_aux2'"
{"src": "⊢ ∀ {α : Type u_1} {t : α} {ts ys l l' : list α},	    l' ∈ (permutations_aux2 t ts nil ys (append l)).snd ↔	      ∃ (l₁ l₂ : list α), l₂ ≠ nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts", "decl_nm": "list.mem_permutations_aux2"
{"src": "α : Type u_1,	t : α,	ts ys l l' : list α	⊢ l' ∈ (permutations_aux2 t ts nil ys (append l)).snd ↔	    ∃ (l₁ l₂ : list α), l₂ ≠ nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts", "decl_nm": "list.mem_permutations_aux2"
{"src": "2 goals	case list.nil	α : Type u_1,	t : α,	ts l' l : list α	⊢ l' ∈ (permutations_aux2 t ts nil nil (append l)).snd ↔	    ∃ (l₁ l₂ : list α), l₂ ≠ nil ∧ nil = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts		case list.cons	α : Type u_1,	t : α,	ts l' : list α,	y : α,	ys : list α,	ih :	  ∀ {l : list α},	    l' ∈ (permutations_aux2 t ts nil ys (append l)).snd ↔	      ∃ (l₁ l₂ : list α), l₂ ≠ nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts,	l : list α	⊢ l' ∈ (permutations_aux2 t ts nil (y :: ys) (append l)).snd ↔	    ∃ (l₁ l₂ : list α), l₂ ≠ nil ∧ y :: ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts", "decl_nm": "list.mem_permutations_aux2"
{"src": "case list.cons	α : Type u_1,	t : α,	ts l' : list α,	y : α,	ys : list α,	ih :	  ∀ {l : list α},	    l' ∈ (permutations_aux2 t ts nil ys (append l)).snd ↔	      ∃ (l₁ l₂ : list α), l₂ ≠ nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts,	l : list α	⊢ l' ∈ (permutations_aux2 t ts nil (y :: ys) (append l)).snd ↔	    ∃ (l₁ l₂ : list α), l₂ ≠ nil ∧ y :: ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts", "decl_nm": "list.mem_permutations_aux2"
{"src": "case list.cons	α : Type u_1,	t : α,	ts l' : list α,	y : α,	ys : list α,	ih :	  ∀ {l : list α},	    l' ∈ (permutations_aux2 t ts nil ys (append l)).snd ↔	      ∃ (l₁ l₂ : list α), l₂ ≠ nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts,	l : list α	⊢ (l' = l ++ (t :: y :: ys ++ ts) ∨	       ∃ (l₁ l₂ : list α), l₂ ≠ nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ [y] ++ l₁ ++ t :: l₂ ++ ts) ↔	    ∃ (l₁ l₂ : list α), l₂ ≠ nil ∧ y :: ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts", "decl_nm": "list.mem_permutations_aux2"
{"src": "2 goals	α : Type u_1,	t : α,	ts l' : list α,	y : α,	ys : list α,	ih :	  ∀ {l : list α},	    l' ∈ (permutations_aux2 t ts nil ys (append l)).snd ↔	      ∃ (l₁ l₂ : list α), l₂ ≠ nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts,	l : list α	⊢ (l' = l ++ (t :: y :: ys ++ ts) ∨	     ∃ (l₁ l₂ : list α), l₂ ≠ nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ [y] ++ l₁ ++ t :: l₂ ++ ts) →	  (∃ (l₁ l₂ : list α), l₂ ≠ nil ∧ y :: ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts)		α : Type u_1,	t : α,	ts l' : list α,	y : α,	ys : list α,	ih :	  ∀ {l : list α},	    l' ∈ (permutations_aux2 t ts nil ys (append l)).snd ↔	      ∃ (l₁ l₂ : list α), l₂ ≠ nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts,	l : list α	⊢ (∃ (l₁ l₂ : list α), l₂ ≠ nil ∧ y :: ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts) →	  (l' = l ++ (t :: y :: ys ++ ts) ∨	     ∃ (l₁ l₂ : list α), l₂ ≠ nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ [y] ++ l₁ ++ t :: l₂ ++ ts)", "decl_nm": "list.mem_permutations_aux2"
{"src": "2 goals	α : Type u_1,	t : α,	ts l' : list α,	y : α,	ys : list α,	ih :	  ∀ {l : list α},	    l' ∈ (permutations_aux2 t ts nil ys (append l)).snd ↔	      ∃ (l₁ l₂ : list α), l₂ ≠ nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts,	l : list α,	h :	  l' = l ++ (t :: y :: ys ++ ts) ∨	    ∃ (l₁ l₂ : list α), l₂ ≠ nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ [y] ++ l₁ ++ t :: l₂ ++ ts	⊢ ∃ (l₁ l₂ : list α), l₂ ≠ nil ∧ y :: ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts		α : Type u_1,	t : α,	ts l' : list α,	y : α,	ys : list α,	ih :	  ∀ {l : list α},	    l' ∈ (permutations_aux2 t ts nil ys (append l)).snd ↔	      ∃ (l₁ l₂ : list α), l₂ ≠ nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts,	l : list α	⊢ (∃ (l₁ l₂ : list α), l₂ ≠ nil ∧ y :: ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts) →	  (l' = l ++ (t :: y :: ys ++ ts) ∨	     ∃ (l₁ l₂ : list α), l₂ ≠ nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ [y] ++ l₁ ++ t :: l₂ ++ ts)", "decl_nm": "list.mem_permutations_aux2"
{"src": "3 goals	α : Type u_1,	t : α,	ts l' : list α,	y : α,	ys : list α,	ih :	  ∀ {l : list α},	    l' ∈ (permutations_aux2 t ts nil ys (append l)).snd ↔	      ∃ (l₁ l₂ : list α), l₂ ≠ nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts,	l : list α,	e : l' = l ++ (t :: y :: ys ++ ts)	⊢ ∃ (l₁ l₂ : list α), l₂ ≠ nil ∧ y :: ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts		α : Type u_1,	t : α,	ts l' : list α,	y : α,	ys : list α,	ih :	  ∀ {l : list α},	    l' ∈ (permutations_aux2 t ts nil ys (append l)).snd ↔	      ∃ (l₁ l₂ : list α), l₂ ≠ nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts,	l l₁ l₂ : list α,	l0 : l₂ ≠ nil,	ye : ys = l₁ ++ l₂,	h_h_h_right_right : l' = l ++ [y] ++ l₁ ++ t :: l₂ ++ ts	⊢ ∃ (l₁ l₂ : list α), l₂ ≠ nil ∧ y :: ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts		α : Type u_1,	t : α,	ts l' : list α,	y : α,	ys : list α,	ih :	  ∀ {l : list α},	    l' ∈ (permutations_aux2 t ts nil ys (append l)).snd ↔	      ∃ (l₁ l₂ : list α), l₂ ≠ nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts,	l : list α	⊢ (∃ (l₁ l₂ : list α), l₂ ≠ nil ∧ y :: ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts) →	  (l' = l ++ (t :: y :: ys ++ ts) ∨	     ∃ (l₁ l₂ : list α), l₂ ≠ nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ [y] ++ l₁ ++ t :: l₂ ++ ts)", "decl_nm": "list.mem_permutations_aux2"
{"src": "3 goals	α : Type u_1,	t : α,	ts : list α,	y : α,	ys l : list α,	ih :	  ∀ {l_1 : list α},	    l ++ (t :: y :: ys ++ ts) ∈ (permutations_aux2 t ts nil ys (append l_1)).snd ↔	      ∃ (l₁ l₂ : list α),	        l₂ ≠ nil ∧ ys = l₁ ++ l₂ ∧ l ++ (t :: y :: ys ++ ts) = l_1 ++ l₁ ++ t :: l₂ ++ ts	⊢ ∃ (l₁ l₂ : list α),	    l₂ ≠ nil ∧ y :: ys = l₁ ++ l₂ ∧ l ++ (t :: y :: ys ++ ts) = l ++ l₁ ++ t :: l₂ ++ ts		α : Type u_1,	t : α,	ts l' : list α,	y : α,	ys : list α,	ih :	  ∀ {l : list α},	    l' ∈ (permutations_aux2 t ts nil ys (append l)).snd ↔	      ∃ (l₁ l₂ : list α), l₂ ≠ nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts,	l l₁ l₂ : list α,	l0 : l₂ ≠ nil,	ye : ys = l₁ ++ l₂,	h_h_h_right_right : l' = l ++ [y] ++ l₁ ++ t :: l₂ ++ ts	⊢ ∃ (l₁ l₂ : list α), l₂ ≠ nil ∧ y :: ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts		α : Type u_1,	t : α,	ts l' : list α,	y : α,	ys : list α,	ih :	  ∀ {l : list α},	    l' ∈ (permutations_aux2 t ts nil ys (append l)).snd ↔	      ∃ (l₁ l₂ : list α), l₂ ≠ nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts,	l : list α	⊢ (∃ (l₁ l₂ : list α), l₂ ≠ nil ∧ y :: ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts) →	  (l' = l ++ (t :: y :: ys ++ ts) ∨	     ∃ (l₁ l₂ : list α), l₂ ≠ nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ [y] ++ l₁ ++ t :: l₂ ++ ts)", "decl_nm": "list.mem_permutations_aux2"
{"src": "2 goals	α : Type u_1,	t : α,	ts l' : list α,	y : α,	ys : list α,	ih :	  ∀ {l : list α},	    l' ∈ (permutations_aux2 t ts nil ys (append l)).snd ↔	      ∃ (l₁ l₂ : list α), l₂ ≠ nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts,	l l₁ l₂ : list α,	l0 : l₂ ≠ nil,	ye : ys = l₁ ++ l₂,	h_h_h_right_right : l' = l ++ [y] ++ l₁ ++ t :: l₂ ++ ts	⊢ ∃ (l₁ l₂ : list α), l₂ ≠ nil ∧ y :: ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts		α : Type u_1,	t : α,	ts l' : list α,	y : α,	ys : list α,	ih :	  ∀ {l : list α},	    l' ∈ (permutations_aux2 t ts nil ys (append l)).snd ↔	      ∃ (l₁ l₂ : list α), l₂ ≠ nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts,	l : list α	⊢ (∃ (l₁ l₂ : list α), l₂ ≠ nil ∧ y :: ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts) →	  (l' = l ++ (t :: y :: ys ++ ts) ∨	     ∃ (l₁ l₂ : list α), l₂ ≠ nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ [y] ++ l₁ ++ t :: l₂ ++ ts)", "decl_nm": "list.mem_permutations_aux2"
{"src": "2 goals	α : Type u_1,	t : α,	ts : list α,	y : α,	l l₁ l₂ : list α,	l0 : l₂ ≠ nil,	ih :	  ∀ {l_1 : list α},	    l ++ [y] ++ l₁ ++ t :: l₂ ++ ts ∈ (permutations_aux2 t ts nil (l₁ ++ l₂) (append l_1)).snd ↔	      ∃ (l₁_1 l₂_1 : list α),	        l₂_1 ≠ nil ∧	          l₁ ++ l₂ = l₁_1 ++ l₂_1 ∧ l ++ [y] ++ l₁ ++ t :: l₂ ++ ts = l_1 ++ l₁_1 ++ t :: l₂_1 ++ ts	⊢ ∃ (l₁_1 l₂_1 : list α),	    l₂_1 ≠ nil ∧	      y :: (l₁ ++ l₂) = l₁_1 ++ l₂_1 ∧ l ++ [y] ++ l₁ ++ t :: l₂ ++ ts = l ++ l₁_1 ++ t :: l₂_1 ++ ts		α : Type u_1,	t : α,	ts l' : list α,	y : α,	ys : list α,	ih :	  ∀ {l : list α},	    l' ∈ (permutations_aux2 t ts nil ys (append l)).snd ↔	      ∃ (l₁ l₂ : list α), l₂ ≠ nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts,	l : list α	⊢ (∃ (l₁ l₂ : list α), l₂ ≠ nil ∧ y :: ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts) →	  (l' = l ++ (t :: y :: ys ++ ts) ∨	     ∃ (l₁ l₂ : list α), l₂ ≠ nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ [y] ++ l₁ ++ t :: l₂ ++ ts)", "decl_nm": "list.mem_permutations_aux2"
{"src": "α : Type u_1,	t : α,	ts l' : list α,	y : α,	ys : list α,	ih :	  ∀ {l : list α},	    l' ∈ (permutations_aux2 t ts nil ys (append l)).snd ↔	      ∃ (l₁ l₂ : list α), l₂ ≠ nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts,	l : list α	⊢ (∃ (l₁ l₂ : list α), l₂ ≠ nil ∧ y :: ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts) →	  (l' = l ++ (t :: y :: ys ++ ts) ∨	     ∃ (l₁ l₂ : list α), l₂ ≠ nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ [y] ++ l₁ ++ t :: l₂ ++ ts)", "decl_nm": "list.mem_permutations_aux2"
{"src": "α : Type u_1,	t : α,	ts l' : list α,	y : α,	ys : list α,	ih :	  ∀ {l : list α},	    l' ∈ (permutations_aux2 t ts nil ys (append l)).snd ↔	      ∃ (l₁ l₂ : list α), l₂ ≠ nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts,	l : list α,	h : ∃ (l₁ l₂ : list α), l₂ ≠ nil ∧ y :: ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts	⊢ l' = l ++ (t :: y :: ys ++ ts) ∨	    ∃ (l₁ l₂ : list α), l₂ ≠ nil ∧ ys = l₁ ++ l₂ ∧ l' = l ++ [y] ++ l₁ ++ t :: l₂ ++ ts", "decl_nm": "list.mem_permutations_aux2"
{"src": "2 goals	α : Type u_1,	t : α,	ts : list α,	y : α,	ys l l₂ : list α,	l0 : l₂ ≠ nil,	ye : y :: ys = nil ++ l₂,	ih :	  ∀ {l_1 : list α},	    l ++ nil ++ t :: l₂ ++ ts ∈ (permutations_aux2 t ts nil ys (append l_1)).snd ↔	      ∃ (l₁ l₂_1 : list α),	        l₂_1 ≠ nil ∧ ys = l₁ ++ l₂_1 ∧ l ++ nil ++ t :: l₂ ++ ts = l_1 ++ l₁ ++ t :: l₂_1 ++ ts	⊢ l ++ nil ++ t :: l₂ ++ ts = l ++ (t :: y :: ys ++ ts) ∨	    ∃ (l₁ l₂_1 : list α),	      l₂_1 ≠ nil ∧ ys = l₁ ++ l₂_1 ∧ l ++ nil ++ t :: l₂ ++ ts = l ++ [y] ++ l₁ ++ t :: l₂_1 ++ ts		α : Type u_1,	t : α,	ts : list α,	y : α,	ys l : list α,	y' : α,	l₁ l₂ : list α,	l0 : l₂ ≠ nil,	ye : y :: ys = y' :: l₁ ++ l₂,	ih :	  ∀ {l_1 : list α},	    l ++ y' :: l₁ ++ t :: l₂ ++ ts ∈ (permutations_aux2 t ts nil ys (append l_1)).snd ↔	      ∃ (l₁_1 l₂_1 : list α),	        l₂_1 ≠ nil ∧	          ys = l₁_1 ++ l₂_1 ∧ l ++ y' :: l₁ ++ t :: l₂ ++ ts = l_1 ++ l₁_1 ++ t :: l₂_1 ++ ts	⊢ l ++ y' :: l₁ ++ t :: l₂ ++ ts = l ++ (t :: y :: ys ++ ts) ∨	    ∃ (l₁_1 l₂_1 : list α),	      l₂_1 ≠ nil ∧	        ys = l₁_1 ++ l₂_1 ∧ l ++ y' :: l₁ ++ t :: l₂ ++ ts = l ++ [y] ++ l₁_1 ++ t :: l₂_1 ++ ts", "decl_nm": "list.mem_permutations_aux2"
{"src": "α : Type u_1,	t : α,	ts : list α,	y : α,	ys l : list α,	y' : α,	l₁ l₂ : list α,	l0 : l₂ ≠ nil,	ye : y :: ys = y' :: l₁ ++ l₂,	ih :	  ∀ {l_1 : list α},	    l ++ y' :: l₁ ++ t :: l₂ ++ ts ∈ (permutations_aux2 t ts nil ys (append l_1)).snd ↔	      ∃ (l₁_1 l₂_1 : list α),	        l₂_1 ≠ nil ∧	          ys = l₁_1 ++ l₂_1 ∧ l ++ y' :: l₁ ++ t :: l₂ ++ ts = l_1 ++ l₁_1 ++ t :: l₂_1 ++ ts	⊢ l ++ y' :: l₁ ++ t :: l₂ ++ ts = l ++ (t :: y :: ys ++ ts) ∨	    ∃ (l₁_1 l₂_1 : list α),	      l₂_1 ≠ nil ∧	        ys = l₁_1 ++ l₂_1 ∧ l ++ y' :: l₁ ++ t :: l₂ ++ ts = l ++ [y] ++ l₁_1 ++ t :: l₂_1 ++ ts", "decl_nm": "list.mem_permutations_aux2"
{"src": "α : Type u_1,	t : α,	ts : list α,	y : α,	ys l : list α,	y' : α,	l₁ l₂ : list α,	l0 : l₂ ≠ nil,	ih :	  ∀ {l_1 : list α},	    l ++ y' :: l₁ ++ t :: l₂ ++ ts ∈ (permutations_aux2 t ts nil ys (append l_1)).snd ↔	      ∃ (l₁_1 l₂_1 : list α),	        l₂_1 ≠ nil ∧	          ys = l₁_1 ++ l₂_1 ∧ l ++ y' :: l₁ ++ t :: l₂ ++ ts = l_1 ++ l₁_1 ++ t :: l₂_1 ++ ts,	ye : y = y' ∧ ys = l₁ ++ l₂	⊢ l ++ y' :: l₁ ++ t :: l₂ ++ ts = l ++ (t :: y :: ys ++ ts) ∨	    ∃ (l₁_1 l₂_1 : list α),	      l₂_1 ≠ nil ∧	        ys = l₁_1 ++ l₂_1 ∧ l ++ y' :: l₁ ++ t :: l₂ ++ ts = l ++ [y] ++ l₁_1 ++ t :: l₂_1 ++ ts", "decl_nm": "list.mem_permutations_aux2"
{"src": "α : Type u_1,	t : α,	ts : list α,	y : α,	l l₁ l₂ : list α,	l0 : l₂ ≠ nil,	ih :	  ∀ {l_1 : list α},	    l ++ y :: l₁ ++ t :: l₂ ++ ts ∈ (permutations_aux2 t ts nil (l₁ ++ l₂) (append l_1)).snd ↔	      ∃ (l₁_1 l₂_1 : list α),	        l₂_1 ≠ nil ∧	          l₁ ++ l₂ = l₁_1 ++ l₂_1 ∧ l ++ y :: l₁ ++ t :: l₂ ++ ts = l_1 ++ l₁_1 ++ t :: l₂_1 ++ ts	⊢ l ++ y :: l₁ ++ t :: l₂ ++ ts = l ++ (t :: y :: (l₁ ++ l₂) ++ ts) ∨	    ∃ (l₁_1 l₂_1 : list α),	      l₂_1 ≠ nil ∧	        l₁ ++ l₂ = l₁_1 ++ l₂_1 ∧ l ++ y :: l₁ ++ t :: l₂ ++ ts = l ++ [y] ++ l₁_1 ++ t :: l₂_1 ++ ts", "decl_nm": "list.mem_permutations_aux2"
{"src": "⊢ ∀ {α : Type u_1} [_inst_1 : decidable_eq α] (a : α) (l : list α), l <:+ insert a l", "decl_nm": "list.suffix_insert"
{"src": "α : Type u_1,	_inst_1 : decidable_eq α,	a : α,	l : list α	⊢ l <:+ insert a l", "decl_nm": "list.suffix_insert"
{"src": "2 goals	α : Type u_1,	_inst_1 : decidable_eq α,	a : α,	l : list α,	h : a ∈ l	⊢ l <:+ insert a l		α : Type u_1,	_inst_1 : decidable_eq α,	a : α,	l : list α,	h : a ∉ l	⊢ l <:+ insert a l", "decl_nm": "list.suffix_insert"
{"src": "α : Type u_1,	_inst_1 : decidable_eq α,	a : α,	l : list α,	h : a ∉ l	⊢ l <:+ insert a l", "decl_nm": "list.suffix_insert"
{"src": "⊢ ∀ {α : Type u} [_inst_1 : decidable_eq α] (l : list α), nil.diff l = nil", "decl_nm": "list.nil_diff"
{"src": "α : Type u,	_inst_1 : decidable_eq α,	l : list α	⊢ nil.diff l = nil", "decl_nm": "list.nil_diff"
{"src": "2 goals	case list.nil	α : Type u,	_inst_1 : decidable_eq α	⊢ nil.diff nil = nil		case list.cons	α : Type u,	_inst_1 : decidable_eq α,	l_hd : α,	l_tl : list α,	l_ih : nil.diff l_tl = nil	⊢ nil.diff (l_hd :: l_tl) = nil", "decl_nm": "list.nil_diff"
{"src": "case list.cons	α : Type u,	_inst_1 : decidable_eq α,	l_hd : α,	l_tl : list α,	l_ih : nil.diff l_tl = nil	⊢ nil.diff (l_hd :: l_tl) = nil", "decl_nm": "list.nil_diff"
{"src": "⊢ ∀ {α : Type u} {β : Type v} {γ : Type w} (f : option α → β → γ) (bs : list β),	    map₂_right' f nil bs = (map (f none) bs, nil α)", "decl_nm": "list.map₂_right'_nil_left"
{"src": "α : Type u,	β : Type v,	γ : Type w,	f : option α → β → γ,	bs : list β	⊢ map₂_right' f nil bs = (map (f none) bs, nil α)", "decl_nm": "list.map₂_right'_nil_left"
{"src": "2 goals	case list.nil	α : Type u,	β : Type v,	γ : Type w,	f : option α → β → γ	⊢ map₂_right' f nil nil = (map (f none) nil, nil α)		case list.cons	α : Type u,	β : Type v,	γ : Type w,	f : option α → β → γ,	bs_hd : β,	bs_tl : list β	⊢ map₂_right' f nil (bs_hd :: bs_tl) = (map (f none) (bs_hd :: bs_tl), nil α)", "decl_nm": "list.map₂_right'_nil_left"
{"src": "case list.cons	α : Type u,	β : Type v,	γ : Type w,	f : option α → β → γ,	bs_hd : β,	bs_tl : list β	⊢ map₂_right' f nil (bs_hd :: bs_tl) = (map (f none) (bs_hd :: bs_tl), nil α)", "decl_nm": "list.map₂_right'_nil_left"
{"src": "⊢ ∀ {α : Type u} (a : α) (l : list α), l.concat a = l ++ [a]", "decl_nm": "list.concat_eq_append"
{"src": "α : Type u,	a : α,	l : list α	⊢ l.concat a = l ++ [a]", "decl_nm": "list.concat_eq_append"
{"src": "2 goals	case list.nil	α : Type u,	a : α	⊢ nil.concat a = nil ++ [a]		case list.cons	α : Type u,	a l_hd : α,	l_tl : list α,	l_ih : l_tl.concat a = l_tl ++ [a]	⊢ (l_hd :: l_tl).concat a = l_hd :: l_tl ++ [a]", "decl_nm": "list.concat_eq_append"
{"src": "2 goals	case list.nil	α : Type u,	a : α	⊢ [a] = nil ++ [a]		case list.cons	α : Type u,	a l_hd : α,	l_tl : list α,	l_ih : l_tl.concat a = l_tl ++ [a]	⊢ (l_hd :: l_tl).concat a = l_hd :: l_tl ++ [a]", "decl_nm": "list.concat_eq_append"
{"src": "case list.cons	α : Type u,	a l_hd : α,	l_tl : list α,	l_ih : l_tl.concat a = l_tl ++ [a]	⊢ (l_hd :: l_tl).concat a = l_hd :: l_tl ++ [a]", "decl_nm": "list.concat_eq_append"
{"src": "case list.cons	α : Type u,	a l_hd : α,	l_tl : list α,	l_ih : l_tl.concat a = l_tl ++ [a]	⊢ l_hd :: (l_tl ++ [a]) = l_hd :: l_tl ++ [a]", "decl_nm": "list.concat_eq_append"
{"src": "⊢ ∀ {α : Type u} (a : α) (l₁ l₂ : list α), l₁.concat a ++ l₂ = l₁ ++ a :: l₂", "decl_nm": "list.concat_append"
{"src": "α : Type u,	a : α,	l₁ l₂ : list α	⊢ l₁.concat a ++ l₂ = l₁ ++ a :: l₂", "decl_nm": "list.concat_append"
{"src": "⊢ ∀ {α : Type u} {a : α} (l : list α) (h : l ++ [a] ≠ nil), (l ++ [a]).last h = a", "decl_nm": "list.last_append"
{"src": "α : Type u,	a : α,	l : list α,	h : l ++ [a] ≠ nil	⊢ (l ++ [a]).last h = a", "decl_nm": "list.last_append"
{"src": "2 goals	case list.nil	α : Type u,	a : α,	h : nil ++ [a] ≠ nil	⊢ (nil ++ [a]).last h = a		case list.cons	α : Type u,	a l_hd : α,	l_tl : list α,	l_ih : ∀ (h : l_tl ++ [a] ≠ nil), (l_tl ++ [a]).last h = a,	h : l_hd :: l_tl ++ [a] ≠ nil	⊢ (l_hd :: l_tl ++ [a]).last h = a", "decl_nm": "list.last_append"
{"src": "case list.cons	α : Type u,	a l_hd : α,	l_tl : list α,	l_ih : ∀ (h : l_tl ++ [a] ≠ nil), (l_tl ++ [a]).last h = a,	h : l_hd :: l_tl ++ [a] ≠ nil	⊢ (l_hd :: l_tl ++ [a]).last h = a", "decl_nm": "list.last_append"
{"src": "⊢ ∀ {α : Type u} {a : α} {l : list α}, a ∈ l → l ≠ nil", "decl_nm": "list.ne_nil_of_mem"
{"src": "α : Type u,	a : α,	l : list α,	h : a ∈ l	⊢ l ≠ nil", "decl_nm": "list.ne_nil_of_mem"
{"src": "α : Type u,	a : α,	l : list α,	h : a ∈ l,	e : l = nil	⊢ false", "decl_nm": "list.ne_nil_of_mem"
{"src": "α : Type u,	a : α,	l : list α,	e : l = nil,	h : a ∈ nil	⊢ false", "decl_nm": "list.ne_nil_of_mem"
{"src": "⊢ ∀ {α : Type u_1} {l : list α} {x y : α}, duplicate x (y :: l) → x ≠ y → duplicate x l", "decl_nm": "list.duplicate.of_duplicate_cons"
{"src": "α : Type u_1,	l : list α,	x y : α,	h : duplicate x (y :: l),	hx : x ≠ y	⊢ duplicate x l", "decl_nm": "list.duplicate.of_duplicate_cons"
{"src": "⊢ ∀ {α : Type u_1} {β : Type u_2} {R S : α → β → Prop},	    (∀ (a : α) (b : β), R a b → S a b) →	    ∀ {l₁ : list α} {l₂ : list β}, forall₂ R l₁ l₂ → forall₂ S l₁ l₂", "decl_nm": "list.forall₂.imp"
{"src": "α : Type u_1,	β : Type u_2,	R S : α → β → Prop,	H : ∀ (a : α) (b : β), R a b → S a b,	l₁ : list α,	l₂ : list β,	h : forall₂ R l₁ l₂	⊢ forall₂ S l₁ l₂", "decl_nm": "list.forall₂.imp"
{"src": "2 goals	case list.forall₂.nil	α : Type u_1,	β : Type u_2,	R S : α → β → Prop,	H : ∀ (a : α) (b : β), R a b → S a b,	l₁ : list α,	l₂ : list β	⊢ forall₂ S nil nil		case list.forall₂.cons	α : Type u_1,	β : Type u_2,	R S : α → β → Prop,	H : ∀ (a : α) (b : β), R a b → S a b,	l₁ : list α,	l₂ : list β,	h_a : α,	h_b : β,	h_l₁ : list α,	h_l₂ : list β,	h_ᾰ : R h_a h_b,	h_ᾰ_1 : forall₂ R h_l₁ h_l₂,	h_ih : forall₂ S h_l₁ h_l₂	⊢ forall₂ S (h_a :: h_l₁) (h_b :: h_l₂)", "decl_nm": "list.forall₂.imp"
{"src": "case list.forall₂.cons	α : Type u_1,	β : Type u_2,	R S : α → β → Prop,	H : ∀ (a : α) (b : β), R a b → S a b,	l₁ : list α,	l₂ : list β,	h_a : α,	h_b : β,	h_l₁ : list α,	h_l₂ : list β,	h_ᾰ : R h_a h_b,	h_ᾰ_1 : forall₂ R h_l₁ h_l₂,	h_ih : forall₂ S h_l₁ h_l₂	⊢ forall₂ S (h_a :: h_l₁) (h_b :: h_l₂)", "decl_nm": "list.forall₂.imp"
{"src": "2 goals	α : Type u_1,	β : Type u_2,	R S : α → β → Prop,	H : ∀ (a : α) (b : β), R a b → S a b,	l₁ : list α,	l₂ : list β,	h_a : α,	h_b : β,	h_l₁ : list α,	h_l₂ : list β,	h_ᾰ : R h_a h_b,	h_ᾰ_1 : forall₂ R h_l₁ h_l₂,	h_ih : forall₂ S h_l₁ h_l₂	⊢ S h_a h_b		α : Type u_1,	β : Type u_2,	R S : α → β → Prop,	H : ∀ (a : α) (b : β), R a b → S a b,	l₁ : list α,	l₂ : list β,	h_a : α,	h_b : β,	h_l₁ : list α,	h_l₂ : list β,	h_ᾰ : R h_a h_b,	h_ᾰ_1 : forall₂ R h_l₁ h_l₂,	h_ih : forall₂ S h_l₁ h_l₂	⊢ forall₂ S h_l₁ h_l₂", "decl_nm": "list.forall₂.imp"
{"src": "α : Type u_1,	β : Type u_2,	R S : α → β → Prop,	H : ∀ (a : α) (b : β), R a b → S a b,	l₁ : list α,	l₂ : list β,	h_a : α,	h_b : β,	h_l₁ : list α,	h_l₂ : list β,	h_ᾰ : R h_a h_b,	h_ᾰ_1 : forall₂ R h_l₁ h_l₂,	h_ih : forall₂ S h_l₁ h_l₂	⊢ forall₂ S h_l₁ h_l₂", "decl_nm": "list.forall₂.imp"
{"src": "⊢ ∀ {α : Type u} [_inst_1 : inhabited α] {k : ℕ}, func.get k nil = default", "decl_nm": "list.func.get_nil"
{"src": "α : Type u,	_inst_1 : inhabited α,	k : ℕ	⊢ func.get k nil = default", "decl_nm": "list.func.get_nil"
{"src": "2 goals	case nat.zero	α : Type u,	_inst_1 : inhabited α	⊢ func.get 0 nil = default		case nat.succ	α : Type u,	_inst_1 : inhabited α,	k : ℕ	⊢ func.get k.succ nil = default", "decl_nm": "list.func.get_nil"
{"src": "case nat.succ	α : Type u,	_inst_1 : inhabited α,	k : ℕ	⊢ func.get k.succ nil = default", "decl_nm": "list.func.get_nil"
{"src": "⊢ ∀ {α : Type uu} [_inst_1 : decidable_eq α] (l : list α) (x : α),	    count (x :: l) (permutations'_aux x l) = (take_while (eq x) l).length + 1", "decl_nm": "list.count_permutations'_aux_self"
{"src": "α : Type uu,	_inst_1 : decidable_eq α,	l : list α,	x : α	⊢ count (x :: l) (permutations'_aux x l) = (take_while (eq x) l).length + 1", "decl_nm": "list.count_permutations'_aux_self"
{"src": "2 goals	case list.nil	α : Type uu,	_inst_1 : decidable_eq α,	x : α	⊢ count [x] (permutations'_aux x nil) = (take_while (eq x) nil).length + 1		case list.cons	α : Type uu,	_inst_1 : decidable_eq α,	y : α,	l : list α,	IH : ∀ (x : α), count (x :: l) (permutations'_aux x l) = (take_while (eq x) l).length + 1,	x : α	⊢ count (x :: y :: l) (permutations'_aux x (y :: l)) = (take_while (eq x) (y :: l)).length + 1", "decl_nm": "list.count_permutations'_aux_self"
{"src": "case list.cons	α : Type uu,	_inst_1 : decidable_eq α,	y : α,	l : list α,	IH : ∀ (x : α), count (x :: l) (permutations'_aux x l) = (take_while (eq x) l).length + 1,	x : α	⊢ count (x :: y :: l) (permutations'_aux x (y :: l)) = (take_while (eq x) (y :: l)).length + 1", "decl_nm": "list.count_permutations'_aux_self"
{"src": "case list.cons	α : Type uu,	_inst_1 : decidable_eq α,	y : α,	l : list α,	IH : ∀ (x : α), count (x :: l) (permutations'_aux x l) = (take_while (eq x) l).length + 1,	x : α	⊢ (count (x :: y :: l) (map (cons y) (permutations'_aux x l))).succ = (take_while (eq x) (y :: l)).length + 1", "decl_nm": "list.count_permutations'_aux_self"
{"src": "2 goals	α : Type uu,	_inst_1 : decidable_eq α,	y : α,	l : list α,	IH : ∀ (x : α), count (x :: l) (permutations'_aux x l) = (take_while (eq x) l).length + 1,	x : α,	hx : x = y	⊢ (count (x :: y :: l) (map (cons y) (permutations'_aux x l))).succ = (take_while (eq x) (y :: l)).length + 1		α : Type uu,	_inst_1 : decidable_eq α,	y : α,	l : list α,	IH : ∀ (x : α), count (x :: l) (permutations'_aux x l) = (take_while (eq x) l).length + 1,	x : α,	hx : ¬x = y	⊢ (count (x :: y :: l) (map (cons y) (permutations'_aux x l))).succ = (take_while (eq x) (y :: l)).length + 1", "decl_nm": "list.count_permutations'_aux_self"
{"src": "2 goals	α : Type uu,	_inst_1 : decidable_eq α,	l : list α,	IH : ∀ (x : α), count (x :: l) (permutations'_aux x l) = (take_while (eq x) l).length + 1,	x : α	⊢ (count (x :: x :: l) (map (cons x) (permutations'_aux x l))).succ = (take_while (eq x) (x :: l)).length + 1		α : Type uu,	_inst_1 : decidable_eq α,	y : α,	l : list α,	IH : ∀ (x : α), count (x :: l) (permutations'_aux x l) = (take_while (eq x) l).length + 1,	x : α,	hx : ¬x = y	⊢ (count (x :: y :: l) (map (cons y) (permutations'_aux x l))).succ = (take_while (eq x) (y :: l)).length + 1", "decl_nm": "list.count_permutations'_aux_self"
{"src": "α : Type uu,	_inst_1 : decidable_eq α,	y : α,	l : list α,	IH : ∀ (x : α), count (x :: l) (permutations'_aux x l) = (take_while (eq x) l).length + 1,	x : α,	hx : ¬x = y	⊢ (count (x :: y :: l) (map (cons y) (permutations'_aux x l))).succ = (take_while (eq x) (y :: l)).length + 1", "decl_nm": "list.count_permutations'_aux_self"
{"src": "α : Type uu,	_inst_1 : decidable_eq α,	y : α,	l : list α,	IH : ∀ (x : α), count (x :: l) (permutations'_aux x l) = (take_while (eq x) l).length + 1,	x : α,	hx : ¬x = y	⊢ (count (x :: y :: l) (map (cons y) (permutations'_aux x l))).succ =	    (ite (x = y) (y :: take_while (eq x) l) nil).length + 1", "decl_nm": "list.count_permutations'_aux_self"
{"src": "α : Type uu,	_inst_1 : decidable_eq α,	y : α,	l : list α,	IH : ∀ (x : α), count (x :: l) (permutations'_aux x l) = (take_while (eq x) l).length + 1,	x : α,	hx : ¬x = y	⊢ (count (x :: y :: l) (map (cons y) (permutations'_aux x l))).succ = nil.length + 1", "decl_nm": "list.count_permutations'_aux_self"
{"src": "2 goals	case list.nil	α : Type uu,	_inst_1 : decidable_eq α,	y : α,	l : list α,	IH : ∀ (x : α), count (x :: l) (permutations'_aux x l) = (take_while (eq x) l).length + 1,	x : α,	hx : ¬x = y	⊢ (count (x :: y :: l) (map (cons y) nil)).succ = nil.length + 1		case list.cons	α : Type uu,	_inst_1 : decidable_eq α,	y : α,	l : list α,	IH : ∀ (x : α), count (x :: l) (permutations'_aux x l) = (take_while (eq x) l).length + 1,	x : α,	hx : ¬x = y,	a : list α,	as : list (list α)	⊢ (count (x :: y :: l) (map (cons y) (a :: as))).succ = nil.length + 1", "decl_nm": "list.count_permutations'_aux_self"
{"src": "case list.cons	α : Type uu,	_inst_1 : decidable_eq α,	y : α,	l : list α,	IH : ∀ (x : α), count (x :: l) (permutations'_aux x l) = (take_while (eq x) l).length + 1,	x : α,	hx : ¬x = y,	a : list α,	as : list (list α)	⊢ (count (x :: y :: l) (map (cons y) (a :: as))).succ = nil.length + 1", "decl_nm": "list.count_permutations'_aux_self"
{"src": "case list.cons	α : Type uu,	_inst_1 : decidable_eq α,	y : α,	l : list α,	IH : ∀ (x : α), count (x :: l) (permutations'_aux x l) = (take_while (eq x) l).length + 1,	x : α,	hx : ¬x = y,	a : list α,	as : list (list α)	⊢ x :: y :: l ∉ map (cons y) (a :: as)", "decl_nm": "list.count_permutations'_aux_self"
{"src": "⊢ ∀ {α : Type u} (l : list α) (n m : ℕ), (l.rotate n).rotate m = l.rotate (n + m)", "decl_nm": "list.rotate_rotate"
{"src": "α : Type u,	l : list α,	n m : ℕ	⊢ (l.rotate n).rotate m = l.rotate (n + m)", "decl_nm": "list.rotate_rotate"
{"src": "⊢ ∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : α → β → γ) (l : list α) (l' : list β) (n : ℕ),	    l.length = l'.length → (zip_with f l l').rotate n = zip_with f (l.rotate n) (l'.rotate n)", "decl_nm": "list.zip_with_rotate_distrib"
{"src": "α : Type u_1,	β : Type u_2,	γ : Type u_3,	f : α → β → γ,	l : list α,	l' : list β,	n : ℕ,	h : l.length = l'.length	⊢ (zip_with f l l').rotate n = zip_with f (l.rotate n) (l'.rotate n)", "decl_nm": "list.zip_with_rotate_distrib"
{"src": "α : Type u_1,	β : Type u_2,	γ : Type u_3,	f : α → β → γ,	l : list α,	l' : list β,	n : ℕ,	h : l.length = l'.length	⊢ (drop (n % l'.length) l).length = (drop (n % l'.length) l').length", "decl_nm": "list.zip_with_rotate_distrib"
{"src": "⊢ ∀ {α : Type u} {l : list α}, l.nodup → ∀ {n : ℕ}, l.rotate n = l ↔ n % l.length = 0 ∨ l = nil", "decl_nm": "list.nodup.rotate_eq_self_iff"
{"src": "α : Type u,	l : list α,	hl : l.nodup,	n : ℕ	⊢ l.rotate n = l ↔ n % l.length = 0 ∨ l = nil", "decl_nm": "list.nodup.rotate_eq_self_iff"
{"src": "2 goals	α : Type u,	l : list α,	hl : l.nodup,	n : ℕ	⊢ l.rotate n = l → n % l.length = 0 ∨ l = nil		α : Type u,	l : list α,	hl : l.nodup,	n : ℕ	⊢ n % l.length = 0 ∨ l = nil → l.rotate n = l", "decl_nm": "list.nodup.rotate_eq_self_iff"
{"src": "2 goals	α : Type u,	l : list α,	hl : l.nodup,	n : ℕ,	h : l.rotate n = l	⊢ n % l.length = 0 ∨ l = nil		α : Type u,	l : list α,	hl : l.nodup,	n : ℕ	⊢ n % l.length = 0 ∨ l = nil → l.rotate n = l", "decl_nm": "list.nodup.rotate_eq_self_iff"
{"src": "3 goals	case or.inl	α : Type u,	l : list α,	hl : l.nodup,	n : ℕ,	h : l.rotate n = l,	hl' : 0 = l.length	⊢ n % l.length = 0 ∨ l = nil		case or.inr	α : Type u,	l : list α,	hl : l.nodup,	n : ℕ,	h : l.rotate n = l,	hl' : 0 < l.length	⊢ n % l.length = 0 ∨ l = nil		α : Type u,	l : list α,	hl : l.nodup,	n : ℕ	⊢ n % l.length = 0 ∨ l = nil → l.rotate n = l", "decl_nm": "list.nodup.rotate_eq_self_iff"
{"src": "2 goals	case or.inr	α : Type u,	l : list α,	hl : l.nodup,	n : ℕ,	h : l.rotate n = l,	hl' : 0 < l.length	⊢ n % l.length = 0 ∨ l = nil		α : Type u,	l : list α,	hl : l.nodup,	n : ℕ	⊢ n % l.length = 0 ∨ l = nil → l.rotate n = l", "decl_nm": "list.nodup.rotate_eq_self_iff"
{"src": "2 goals	α : Type u,	l : list α,	hl : l.nodup,	n : ℕ,	h : l.rotate n = l,	hl' : 0 < l.length	⊢ n % l.length = 0		α : Type u,	l : list α,	hl : l.nodup,	n : ℕ	⊢ n % l.length = 0 ∨ l = nil → l.rotate n = l", "decl_nm": "list.nodup.rotate_eq_self_iff"
{"src": "2 goals	α : Type u,	l : list α,	n : ℕ,	h : l.rotate n = l,	hl' : 0 < l.length,	hl : ∀ (i j : ℕ) (h₁ : i < l.length) (h₂ : j < l.length), l.nth_le i h₁ = l.nth_le j h₂ → i = j	⊢ n % l.length = 0		α : Type u,	l : list α,	hl : l.nodup,	n : ℕ	⊢ n % l.length = 0 ∨ l = nil → l.rotate n = l", "decl_nm": "list.nodup.rotate_eq_self_iff"
{"src": "2 goals	α : Type u,	l : list α,	n : ℕ,	h : l.rotate n = l,	hl' : 0 < l.length,	hl : ∀ (i j : ℕ) (h₁ : i < l.length) (h₂ : j < l.length), l.nth_le i h₁ = l.nth_le j h₂ → i = j	⊢ l.nth_le (n % l.length) _ = l.nth_le 0 hl'		α : Type u,	l : list α,	hl : l.nodup,	n : ℕ	⊢ n % l.length = 0 ∨ l = nil → l.rotate n = l", "decl_nm": "list.nodup.rotate_eq_self_iff"
{"src": "2 goals	α : Type u,	l : list α,	n : ℕ,	h : l.rotate n = l,	hl' : 0 < l.length,	hl : ∀ (i j : ℕ) (h₁ : i < l.length) (h₂ : j < l.length), l.nth_le i h₁ = l.nth_le j h₂ → i = j	⊢ (l.rotate n).nth_le ((l.length - n % l.length + n % l.length) % l.length) _ = l.nth_le 0 hl'		α : Type u,	l : list α,	hl : l.nodup,	n : ℕ	⊢ n % l.length = 0 ∨ l = nil → l.rotate n = l", "decl_nm": "list.nodup.rotate_eq_self_iff"
{"src": "α : Type u,	l : list α,	hl : l.nodup,	n : ℕ	⊢ n % l.length = 0 ∨ l = nil → l.rotate n = l", "decl_nm": "list.nodup.rotate_eq_self_iff"
{"src": "2 goals	α : Type u,	l : list α,	hl : l.nodup,	n : ℕ,	h : n % l.length = 0	⊢ l.rotate n = l		α : Type u,	l : list α,	hl : l.nodup,	n : ℕ,	h : l = nil	⊢ l.rotate n = l", "decl_nm": "list.nodup.rotate_eq_self_iff"
{"src": "2 goals	α : Type u,	l : list α,	hl : l.nodup,	n : ℕ,	h : n % l.length = 0	⊢ l.rotate 0 = l		α : Type u,	l : list α,	hl : l.nodup,	n : ℕ,	h : l = nil	⊢ l.rotate n = l", "decl_nm": "list.nodup.rotate_eq_self_iff"
{"src": "α : Type u,	l : list α,	hl : l.nodup,	n : ℕ,	h : l = nil	⊢ l.rotate n = l", "decl_nm": "list.nodup.rotate_eq_self_iff"
{"src": "⊢ ∀ {α : Type u} (l : list α) (n : ℕ) (hn : n < l.cyclic_permutations.length),	    l.cyclic_permutations.nth_le n hn = l.rotate n", "decl_nm": "list.nth_le_cyclic_permutations"
{"src": "α : Type u,	l : list α,	n : ℕ,	hn : n < l.cyclic_permutations.length	⊢ l.cyclic_permutations.nth_le n hn = l.rotate n", "decl_nm": "list.nth_le_cyclic_permutations"
{"src": "2 goals	α : Type u,	n : ℕ,	hn : n < nil.cyclic_permutations.length	⊢ nil.cyclic_permutations.nth_le n hn = nil.rotate n		α : Type u,	l : list α,	n : ℕ,	hn : n < l.cyclic_permutations.length,	h : l ≠ nil	⊢ l.cyclic_permutations.nth_le n hn = l.rotate n", "decl_nm": "list.nth_le_cyclic_permutations"
{"src": "α : Type u,	l : list α,	n : ℕ,	hn : n < l.cyclic_permutations.length,	h : l ≠ nil	⊢ l.cyclic_permutations.nth_le n hn = l.rotate n", "decl_nm": "list.nth_le_cyclic_permutations"
{"src": "α : Type u,	l : list α,	n : ℕ,	hn : n < l.cyclic_permutations.length,	h : l ≠ nil,	hn : n < l.length	⊢ l.cyclic_permutations.nth_le n hn = l.rotate n", "decl_nm": "list.nth_le_cyclic_permutations"
{"src": "⊢ ∀ {α : Type u} (l : list α), l.rotate' l.length = l", "decl_nm": "list.rotate'_length"
{"src": "α : Type u,	l : list α	⊢ l.rotate' l.length = l", "decl_nm": "list.rotate'_length"
{"src": "α : Type u,	l : list α	⊢ drop l.length l ++ take l.length l = l", "decl_nm": "list.rotate'_length"
{"src": "⊢ ∀ {α : Type u} {β : α → Type v} [_inst_1 : decidable_eq α] {a : α} {l : list (sigma β)},	    (kerase a l).keys = l.keys.erase a", "decl_nm": "list.keys_kerase"
{"src": "α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	a : α,	l : list (sigma β)	⊢ (kerase a l).keys = l.keys.erase a", "decl_nm": "list.keys_kerase"
{"src": "⊢ ∀ {α : Type u} {β : α → Type v} [_inst_1 : decidable_eq α] {l₁ l₂ : list (sigma β)},	    l₁ ~ l₂ → ∀ (l : list (sigma β)), l₁.kunion l ~ l₂.kunion l", "decl_nm": "list.perm.kunion_right"
{"src": "α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	l₁ l₂ : list (sigma β),	p : l₁ ~ l₂,	l : list (sigma β)	⊢ l₁.kunion l ~ l₂.kunion l", "decl_nm": "list.perm.kunion_right"
{"src": "4 goals	case list.perm.nil	α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	l₁ l₂ l : list (sigma β)	⊢ nil.kunion l ~ nil.kunion l		case list.perm.cons	α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	l₁ l₂ : list (sigma β),	p_x : sigma β,	p_l₁ p_l₂ : list (sigma β),	p_ᾰ : p_l₁ ~ p_l₂,	p_ih : ∀ (l : list (sigma β)), p_l₁.kunion l ~ p_l₂.kunion l,	l : list (sigma β)	⊢ (p_x :: p_l₁).kunion l ~ (p_x :: p_l₂).kunion l		case list.perm.swap	α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	l₁ l₂ : list (sigma β),	p_x p_y : sigma β,	p_l l : list (sigma β)	⊢ (p_y :: p_x :: p_l).kunion l ~ (p_x :: p_y :: p_l).kunion l		case list.perm.trans	α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	l₁ l₂ p_l₁ p_l₂ p_l₃ : list (sigma β),	p_ᾰ : p_l₁ ~ p_l₂,	p_ᾰ_1 : p_l₂ ~ p_l₃,	p_ih_ᾰ : ∀ (l : list (sigma β)), p_l₁.kunion l ~ p_l₂.kunion l,	p_ih_ᾰ_1 : ∀ (l : list (sigma β)), p_l₂.kunion l ~ p_l₃.kunion l,	l : list (sigma β)	⊢ p_l₁.kunion l ~ p_l₃.kunion l", "decl_nm": "list.perm.kunion_right"
{"src": "3 goals	case list.perm.cons	α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	l₁ l₂ : list (sigma β),	p_x : sigma β,	p_l₁ p_l₂ : list (sigma β),	p_ᾰ : p_l₁ ~ p_l₂,	p_ih : ∀ (l : list (sigma β)), p_l₁.kunion l ~ p_l₂.kunion l,	l : list (sigma β)	⊢ (p_x :: p_l₁).kunion l ~ (p_x :: p_l₂).kunion l		case list.perm.swap	α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	l₁ l₂ : list (sigma β),	p_x p_y : sigma β,	p_l l : list (sigma β)	⊢ (p_y :: p_x :: p_l).kunion l ~ (p_x :: p_y :: p_l).kunion l		case list.perm.trans	α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	l₁ l₂ p_l₁ p_l₂ p_l₃ : list (sigma β),	p_ᾰ : p_l₁ ~ p_l₂,	p_ᾰ_1 : p_l₂ ~ p_l₃,	p_ih_ᾰ : ∀ (l : list (sigma β)), p_l₁.kunion l ~ p_l₂.kunion l,	p_ih_ᾰ_1 : ∀ (l : list (sigma β)), p_l₂.kunion l ~ p_l₃.kunion l,	l : list (sigma β)	⊢ p_l₁.kunion l ~ p_l₃.kunion l", "decl_nm": "list.perm.kunion_right"
{"src": "2 goals	case list.perm.swap	α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	l₁ l₂ : list (sigma β),	p_x p_y : sigma β,	p_l l : list (sigma β)	⊢ (p_y :: p_x :: p_l).kunion l ~ (p_x :: p_y :: p_l).kunion l		case list.perm.trans	α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	l₁ l₂ p_l₁ p_l₂ p_l₃ : list (sigma β),	p_ᾰ : p_l₁ ~ p_l₂,	p_ᾰ_1 : p_l₂ ~ p_l₃,	p_ih_ᾰ : ∀ (l : list (sigma β)), p_l₁.kunion l ~ p_l₂.kunion l,	p_ih_ᾰ_1 : ∀ (l : list (sigma β)), p_l₂.kunion l ~ p_l₃.kunion l,	l : list (sigma β)	⊢ p_l₁.kunion l ~ p_l₃.kunion l", "decl_nm": "list.perm.kunion_right"
{"src": "case list.perm.trans	α : Type u,	β : α → Type v,	_inst_1 : decidable_eq α,	l₁ l₂ p_l₁ p_l₂ p_l₃ : list (sigma β),	p_ᾰ : p_l₁ ~ p_l₂,	p_ᾰ_1 : p_l₂ ~ p_l₃,	p_ih_ᾰ : ∀ (l : list (sigma β)), p_l₁.kunion l ~ p_l₂.kunion l,	p_ih_ᾰ_1 : ∀ (l : list (sigma β)), p_l₂.kunion l ~ p_l₃.kunion l,	l : list (sigma β)	⊢ p_l₁.kunion l ~ p_l₃.kunion l", "decl_nm": "list.perm.kunion_right"
{"src": "⊢ ∀ {α : Type u} {β : Type u_1} {γ : Type u_2} {f : α → β → γ} {l : list α} {l' : list β},	    zip_with f l l' = nil ↔ l = nil ∨ l' = nil", "decl_nm": "list.zip_with_eq_nil_iff"
{"src": "α : Type u,	β : Type u_1,	γ : Type u_2,	f : α → β → γ,	l : list α,	l' : list β	⊢ zip_with f l l' = nil ↔ l = nil ∨ l' = nil", "decl_nm": "list.zip_with_eq_nil_iff"
{"src": "2 goals	case list.nil	α : Type u,	β : Type u_1,	γ : Type u_2,	f : α → β → γ,	l' : list β	⊢ zip_with f nil l' = nil ↔ nil = nil ∨ l' = nil		case list.cons	α : Type u,	β : Type u_1,	γ : Type u_2,	f : α → β → γ,	l' : list β,	l_hd : α,	l_tl : list α	⊢ zip_with f (l_hd :: l_tl) l' = nil ↔ l_hd :: l_tl = nil ∨ l' = nil", "decl_nm": "list.zip_with_eq_nil_iff"
{"src": "3 goals	case list.nil, list.nil	α : Type u,	β : Type u_1,	γ : Type u_2,	f : α → β → γ	⊢ zip_with f nil nil = nil ↔ nil = nil ∨ nil = nil		case list.nil, list.cons	α : Type u,	β : Type u_1,	γ : Type u_2,	f : α → β → γ,	l'_hd : β,	l'_tl : list β	⊢ zip_with f nil (l'_hd :: l'_tl) = nil ↔ nil = nil ∨ l'_hd :: l'_tl = nil		case list.cons	α : Type u,	β : Type u_1,	γ : Type u_2,	f : α → β → γ,	l' : list β,	l_hd : α,	l_tl : list α	⊢ zip_with f (l_hd :: l_tl) l' = nil ↔ l_hd :: l_tl = nil ∨ l' = nil", "decl_nm": "list.zip_with_eq_nil_iff"
{"src": "2 goals	case list.nil, list.cons	α : Type u,	β : Type u_1,	γ : Type u_2,	f : α → β → γ,	l'_hd : β,	l'_tl : list β	⊢ zip_with f nil (l'_hd :: l'_tl) = nil ↔ nil = nil ∨ l'_hd :: l'_tl = nil		case list.cons	α : Type u,	β : Type u_1,	γ : Type u_2,	f : α → β → γ,	l' : list β,	l_hd : α,	l_tl : list α	⊢ zip_with f (l_hd :: l_tl) l' = nil ↔ l_hd :: l_tl = nil ∨ l' = nil", "decl_nm": "list.zip_with_eq_nil_iff"
{"src": "case list.cons	α : Type u,	β : Type u_1,	γ : Type u_2,	f : α → β → γ,	l' : list β,	l_hd : α,	l_tl : list α	⊢ zip_with f (l_hd :: l_tl) l' = nil ↔ l_hd :: l_tl = nil ∨ l' = nil", "decl_nm": "list.zip_with_eq_nil_iff"
{"src": "2 goals	case list.cons, list.nil	α : Type u,	β : Type u_1,	γ : Type u_2,	f : α → β → γ,	l_hd : α,	l_tl : list α	⊢ zip_with f (l_hd :: l_tl) nil = nil ↔ l_hd :: l_tl = nil ∨ nil = nil		case list.cons, list.cons	α : Type u,	β : Type u_1,	γ : Type u_2,	f : α → β → γ,	l_hd : α,	l_tl : list α,	l'_hd : β,	l'_tl : list β	⊢ zip_with f (l_hd :: l_tl) (l'_hd :: l'_tl) = nil ↔ l_hd :: l_tl = nil ∨ l'_hd :: l'_tl = nil", "decl_nm": "list.zip_with_eq_nil_iff"
{"src": "case list.cons, list.cons	α : Type u,	β : Type u_1,	γ : Type u_2,	f : α → β → γ,	l_hd : α,	l_tl : list α,	l'_hd : β,	l'_tl : list β	⊢ zip_with f (l_hd :: l_tl) (l'_hd :: l'_tl) = nil ↔ l_hd :: l_tl = nil ∨ l'_hd :: l'_tl = nil", "decl_nm": "list.zip_with_eq_nil_iff"
{"src": "⊢ ∀ {α : Type u} {β : Type u_1} {γ : Type u_2} (f : α → γ) (l₁ : list α) (l₂ : list β),	    (map f l₁).zip l₂ = map (prod.map f id) (l₁.zip l₂)", "decl_nm": "list.zip_map_left"
{"src": "α : Type u,	β : Type u_1,	γ : Type u_2,	f : α → γ,	l₁ : list α,	l₂ : list β	⊢ (map f l₁).zip l₂ = map (prod.map f id) (l₁.zip l₂)", "decl_nm": "list.zip_map_left"
{"src": "⊢ ∀ {m : Type u_2} {n : Type u_3} {α : Type v} [_inst_1 : add_group α] [_inst_2 : star_add_monoid α]	  (M N : matrix m n α), (M - N).conj_transpose = M.conj_transpose - N.conj_transpose", "decl_nm": "matrix.conj_transpose_sub"
{"src": "m : Type u_2,	n : Type u_3,	α : Type v,	_inst_1 : add_group α,	_inst_2 : star_add_monoid α,	M N : matrix m n α	⊢ (M - N).conj_transpose = M.conj_transpose - N.conj_transpose", "decl_nm": "matrix.conj_transpose_sub"
{"src": "m : Type u_2,	n : Type u_3,	α : Type v,	_inst_1 : add_group α,	_inst_2 : star_add_monoid α,	M N : matrix m n α,	i : n,	j : m	⊢ (M - N).conj_transpose i j = (M.conj_transpose - N.conj_transpose) i j", "decl_nm": "matrix.conj_transpose_sub"
{"src": "⊢ ∀ {n : Type u_3} {α : Type v} {β : Type w} [_inst_1 : decidable_eq n] [_inst_2 : has_zero α]	  [_inst_3 : has_zero β] {f : α → β},	    f 0 = 0 → ∀ {d : n → α}, (diagonal d).map f = diagonal (λ (m : n), f (d m))", "decl_nm": "matrix.diagonal_map"
{"src": "n : Type u_3,	α : Type v,	β : Type w,	_inst_1 : decidable_eq n,	_inst_2 : has_zero α,	_inst_3 : has_zero β,	f : α → β,	h : f 0 = 0,	d : n → α	⊢ (diagonal d).map f = diagonal (λ (m : n), f (d m))", "decl_nm": "matrix.diagonal_map"
{"src": "n : Type u_3,	α : Type v,	β : Type w,	_inst_1 : decidable_eq n,	_inst_2 : has_zero α,	_inst_3 : has_zero β,	f : α → β,	h : f 0 = 0,	d : n → α,	i j : n	⊢ (diagonal d).map f i j = diagonal (λ (m : n), f (d m)) i j", "decl_nm": "matrix.diagonal_map"
{"src": "n : Type u_3,	α : Type v,	β : Type w,	_inst_1 : decidable_eq n,	_inst_2 : has_zero α,	_inst_3 : has_zero β,	f : α → β,	h : f 0 = 0,	d : n → α,	i j : n	⊢ f (ite (i = j) (d i) 0) = ite (i = j) (f (d i)) 0", "decl_nm": "matrix.diagonal_map"
{"src": "2 goals	n : Type u_3,	α : Type v,	β : Type w,	_inst_1 : decidable_eq n,	_inst_2 : has_zero α,	_inst_3 : has_zero β,	f : α → β,	h : f 0 = 0,	d : n → α,	i j : n,	h_1 : i = j	⊢ f (d i) = f (d i)		n : Type u_3,	α : Type v,	β : Type w,	_inst_1 : decidable_eq n,	_inst_2 : has_zero α,	_inst_3 : has_zero β,	f : α → β,	h : f 0 = 0,	d : n → α,	i j : n,	h_1 : ¬i = j	⊢ f 0 = 0", "decl_nm": "matrix.diagonal_map"
{"src": "n : Type u_3,	α : Type v,	β : Type w,	_inst_1 : decidable_eq n,	_inst_2 : has_zero α,	_inst_3 : has_zero β,	f : α → β,	h : f 0 = 0,	d : n → α,	i j : n,	h_1 : ¬i = j	⊢ f 0 = 0", "decl_nm": "matrix.diagonal_map"
{"src": "⊢ ∀ {l : Type u_1} {m : Type u_2} {n : Type u_3} {o : Type u_4} {α : Type v} [_inst_1 : non_unital_semiring α]	  [_inst_2 : fintype m] [_inst_3 : fintype n] (L : matrix l m α) (M : matrix m n α) (N : matrix n o α),	    (L.mul M).mul N = L.mul (M.mul N)", "decl_nm": "matrix.mul_assoc"
{"src": "l : Type u_1,	m : Type u_2,	n : Type u_3,	o : Type u_4,	α : Type v,	_inst_1 : non_unital_semiring α,	_inst_2 : fintype m,	_inst_3 : fintype n,	L : matrix l m α,	M : matrix m n α,	N : matrix n o α	⊢ (L.mul M).mul N = L.mul (M.mul N)", "decl_nm": "matrix.mul_assoc"
{"src": "l : Type u_1,	m : Type u_2,	n : Type u_3,	o : Type u_4,	α : Type v,	_inst_1 : non_unital_semiring α,	_inst_2 : fintype m,	_inst_3 : fintype n,	L : matrix l m α,	M : matrix m n α,	N : matrix n o α,	i : l,	j : o	⊢ (L.mul M).mul N i j = L.mul (M.mul N) i j", "decl_nm": "matrix.mul_assoc"
{"src": "⊢ ∀ {n : Type u_3} {α : Type v} [_inst_1 : semiring α] [_inst_2 : decidable_eq n] [_inst_3 : fintype n] (a : α)	  (i : n), ⇑(scalar n) a i i = a", "decl_nm": "matrix.scalar_apply_eq"
{"src": "n : Type u_3,	α : Type v,	_inst_1 : semiring α,	_inst_2 : decidable_eq n,	_inst_3 : fintype n,	a : α,	i : n	⊢ ⇑(scalar n) a i i = a", "decl_nm": "matrix.scalar_apply_eq"
{"src": "⊢ ∀ {n : Type u_3} {α : Type v} [_inst_1 : comm_semiring α] [_inst_2 : fintype n] [_inst_3 : decidable_eq n]	  (r : α) (M : matrix n n α), commute (⇑(scalar n) r) M", "decl_nm": "matrix.scalar.commute"
{"src": "n : Type u_3,	α : Type v,	_inst_1 : comm_semiring α,	_inst_2 : fintype n,	_inst_3 : decidable_eq n,	r : α,	M : matrix n n α	⊢ commute (⇑(scalar n) r) M", "decl_nm": "matrix.scalar.commute"
{"src": "⊢ ∀ {m : Type u_2} {n : Type u_3} {α : Type u_5} [_inst_2 : decidable_eq m] [_inst_3 : decidable_eq n]	  [_inst_4 : semiring α] (i : m) (j : n) (a b : α), b • std_basis_matrix i j a = std_basis_matrix i j (b • a)", "decl_nm": "matrix.smul_std_basis_matrix"
{"src": "m : Type u_2,	n : Type u_3,	α : Type u_5,	_inst_2 : decidable_eq m,	_inst_3 : decidable_eq n,	_inst_4 : semiring α,	i : m,	j : n,	a b : α	⊢ b • std_basis_matrix i j a = std_basis_matrix i j (b • a)", "decl_nm": "matrix.smul_std_basis_matrix"
{"src": "m : Type u_2,	n : Type u_3,	α : Type u_5,	_inst_2 : decidable_eq m,	_inst_3 : decidable_eq n,	_inst_4 : semiring α,	i : m,	j : n,	a b : α	⊢ (b • λ (i' : m) (j' : n), ite (i = i' ∧ j = j') a 0) =	    λ (i' : m) (j' : n), ite (i = i' ∧ j = j') (b • a) 0", "decl_nm": "matrix.smul_std_basis_matrix"
{"src": "m : Type u_2,	n : Type u_3,	α : Type u_5,	_inst_2 : decidable_eq m,	_inst_3 : decidable_eq n,	_inst_4 : semiring α,	i : m,	j : n,	a b : α,	x : m,	x_1 : n	⊢ (b • λ (i' : m) (j' : n), ite (i = i' ∧ j = j') a 0) x x_1 = ite (i = x ∧ j = x_1) (b • a) 0", "decl_nm": "matrix.smul_std_basis_matrix"
{"src": "⊢ ∀ {m : Type u_2} {n : Type u_3} [_inst_2 : fintype m] [_inst_3 : fintype n] {α : m → n → Type v}	  [_inst_5 : Π (i : m) (j : n), add_group (α i j)] {β : m → n → Type w}	  [_inst_6 : Π (i : m) (j : n), add_group (β i j)] (f : Π ⦃i : m⦄ ⦃j : n⦄, α i j →+ β i j)	  (M N : dmatrix m n α),	    (M - N).map (λ (i : m) (j : n), ⇑f) = M.map (λ (i : m) (j : n), ⇑f) - N.map (λ (i : m) (j : n), ⇑f)", "decl_nm": "dmatrix.map_sub"
{"src": "m : Type u_2,	n : Type u_3,	_inst_2 : fintype m,	_inst_3 : fintype n,	α : m → n → Type v,	_inst_5 : Π (i : m) (j : n), add_group (α i j),	β : m → n → Type w,	_inst_6 : Π (i : m) (j : n), add_group (β i j),	f : Π ⦃i : m⦄ ⦃j : n⦄, α i j →+ β i j,	M N : dmatrix m n α	⊢ (M - N).map (λ (i : m) (j : n), ⇑f) = M.map (λ (i : m) (j : n), ⇑f) - N.map (λ (i : m) (j : n), ⇑f)", "decl_nm": "dmatrix.map_sub"
{"src": "m : Type u_2,	n : Type u_3,	_inst_2 : fintype m,	_inst_3 : fintype n,	α : m → n → Type v,	_inst_5 : Π (i : m) (j : n), add_group (α i j),	β : m → n → Type w,	_inst_6 : Π (i : m) (j : n), add_group (β i j),	f : Π ⦃i : m⦄ ⦃j : n⦄, α i j →+ β i j,	M N : dmatrix m n α,	i : m,	j : n	⊢ (M - N).map (λ (i : m) (j : n), ⇑f) i j =	    (M.map (λ (i : m) (j : n), ⇑f) - N.map (λ (i : m) (j : n), ⇑f)) i j", "decl_nm": "dmatrix.map_sub"
{"src": "⊢ ∀ {n : ℕ} {m' : Type u_1} {α : Type u_2} [_inst_2 : comm_semiring α] (A : m' → fin n.succ → α) (x : α)	  (v : fin n → α), mul_vec A (vec_cons x v) = x • vec_head ∘ A + mul_vec (vec_tail ∘ A) v", "decl_nm": "matrix.mul_vec_cons"
{"src": "n : ℕ,	m' : Type u_1,	α : Type u_2,	_inst_2 : comm_semiring α,	A : m' → fin n.succ → α,	x : α,	v : fin n → α	⊢ mul_vec A (vec_cons x v) = x • vec_head ∘ A + mul_vec (vec_tail ∘ A) v", "decl_nm": "matrix.mul_vec_cons"
{"src": "n : ℕ,	m' : Type u_1,	α : Type u_2,	_inst_2 : comm_semiring α,	A : m' → fin n.succ → α,	x : α,	v : fin n → α,	i : m'	⊢ mul_vec A (vec_cons x v) i = (x • vec_head ∘ A + mul_vec (vec_tail ∘ A) v) i", "decl_nm": "matrix.mul_vec_cons"
{"src": "⊢ ∀ {α : Type u} {n : ℕ} [_inst_1 : has_add α] (x : α) (v : fin n → α) (w : fin n.succ → α),	    vec_cons x v + w = vec_cons (x + vec_head w) (v + vec_tail w)", "decl_nm": "matrix.cons_add"
{"src": "α : Type u,	n : ℕ,	_inst_1 : has_add α,	x : α,	v : fin n → α,	w : fin n.succ → α	⊢ vec_cons x v + w = vec_cons (x + vec_head w) (v + vec_tail w)", "decl_nm": "matrix.cons_add"
{"src": "α : Type u,	n : ℕ,	_inst_1 : has_add α,	x : α,	v : fin n → α,	w : fin n.succ → α,	i : fin n.succ	⊢ (vec_cons x v + w) i = vec_cons (x + vec_head w) (v + vec_tail w) i", "decl_nm": "matrix.cons_add"
{"src": "2 goals	α : Type u,	n : ℕ,	_inst_1 : has_add α,	x : α,	v : fin n → α,	w : fin n.succ → α,	i : fin n.succ	⊢ (vec_cons x v + w) 0 = vec_cons (x + vec_head w) (v + vec_tail w) 0		α : Type u,	n : ℕ,	_inst_1 : has_add α,	x : α,	v : fin n → α,	w : fin n.succ → α,	i : fin n.succ	⊢ ∀ (i : fin n), (vec_cons x v + w) i.succ = vec_cons (x + vec_head w) (v + vec_tail w) i.succ", "decl_nm": "matrix.cons_add"
{"src": "α : Type u,	n : ℕ,	_inst_1 : has_add α,	x : α,	v : fin n → α,	w : fin n.succ → α,	i : fin n.succ	⊢ ∀ (i : fin n), (vec_cons x v + w) i.succ = vec_cons (x + vec_head w) (v + vec_tail w) i.succ", "decl_nm": "matrix.cons_add"
{"src": "⊢ ∀ {α : Type u_1} {σ : α → Type u_5} (s : multiset α) (t : Π (a : α), multiset (σ a)),	    ⇑card (s.sigma t) = (map (λ (a : α), ⇑card (t a)) s).sum", "decl_nm": "multiset.card_sigma"
{"src": "α : Type u_1,	σ : α → Type u_5,	s : multiset α,	t : Π (a : α), multiset (σ a)	⊢ ⇑card (s.sigma t) = (map (λ (a : α), ⇑card (t a)) s).sum", "decl_nm": "multiset.card_sigma"
{"src": "⊢ ∀ {α : Type u_1} (p : α → Prop) [_inst_1 : decidable_pred p] [_inst_2 : decidable_eq α] {s t : multiset α},	    t ≤ s → countp p (s - t) = countp p s - countp p t", "decl_nm": "multiset.countp_sub"
{"src": "α : Type u_1,	p : α → Prop,	_inst_1 : decidable_pred p,	_inst_2 : decidable_eq α,	s t : multiset α,	h : t ≤ s	⊢ countp p (s - t) = countp p s - countp p t", "decl_nm": "multiset.countp_sub"
{"src": "⊢ ∀ {α : Type u_1} {s t : multiset α}, rel eq s t ↔ s = t", "decl_nm": "multiset.rel_eq"
{"src": "α : Type u_1,	s t : multiset α	⊢ rel eq s t ↔ s = t", "decl_nm": "multiset.rel_eq"
{"src": "2 goals	α : Type u_1,	s t : multiset α	⊢ rel eq s t → s = t		α : Type u_1,	s t : multiset α	⊢ s = t → rel eq s t", "decl_nm": "multiset.rel_eq"
{"src": "2 goals	α : Type u_1,	s t : multiset α,	h : rel eq s t	⊢ s = t		α : Type u_1,	s t : multiset α	⊢ s = t → rel eq s t", "decl_nm": "multiset.rel_eq"
{"src": "3 goals	case multiset.rel.zero	α : Type u_1,	s t : multiset α	⊢ 0 = 0		case multiset.rel.cons	α : Type u_1,	s t : multiset α,	h_a h_b : α,	h_as h_bs : multiset α,	h_ᾰ : h_a = h_b,	h_ᾰ_1 : rel eq h_as h_bs,	h_ih : h_as = h_bs	⊢ h_a ::ₘ h_as = h_b ::ₘ h_bs		α : Type u_1,	s t : multiset α	⊢ s = t → rel eq s t", "decl_nm": "multiset.rel_eq"
{"src": "2 goals	case multiset.rel.cons	α : Type u_1,	s t : multiset α,	h_a h_b : α,	h_as h_bs : multiset α,	h_ᾰ : h_a = h_b,	h_ᾰ_1 : rel eq h_as h_bs,	h_ih : h_as = h_bs	⊢ h_a ::ₘ h_as = h_b ::ₘ h_bs		α : Type u_1,	s t : multiset α	⊢ s = t → rel eq s t", "decl_nm": "multiset.rel_eq"
{"src": "α : Type u_1,	s t : multiset α	⊢ s = t → rel eq s t", "decl_nm": "multiset.rel_eq"
{"src": "α : Type u_1,	s t : multiset α,	h : s = t	⊢ rel eq s t", "decl_nm": "multiset.rel_eq"
{"src": "α : Type u_1,	s : multiset α	⊢ rel eq s s", "decl_nm": "multiset.rel_eq"
{"src": "⊢ ∀ {α : Type u_1} (s t : multiset α), s ≤ s + t", "decl_nm": "multiset.le_add_right"
{"src": "α : Type u_1,	s t : multiset α	⊢ s ≤ s + t", "decl_nm": "multiset.le_add_right"
{"src": "⊢ ∀ {α : Type u_1} {s t : multiset α} {n : ℕ}, s.nodup → n ≠ 0 → (s ≤ n • t ↔ s ≤ t)", "decl_nm": "multiset.nodup.le_nsmul_iff_le"
{"src": "α : Type u_1,	s t : multiset α,	n : ℕ,	h : s.nodup,	hn : n ≠ 0	⊢ s ≤ n • t ↔ s ≤ t", "decl_nm": "multiset.nodup.le_nsmul_iff_le"
{"src": "α : Type u_1,	s t : multiset α,	n : ℕ,	h : s.nodup,	hn : n ≠ 0,	_inst : Π (a : Prop), decidable a	⊢ s ≤ n • t ↔ s ≤ t", "decl_nm": "multiset.nodup.le_nsmul_iff_le"
{"src": "α : Type u_1,	s t : multiset α,	n : ℕ,	h : s.nodup,	hn : n ≠ 0,	_inst : Π (a : Prop), decidable a	⊢ s ≤ t.erase_dup ↔ s ≤ (n • t).erase_dup", "decl_nm": "multiset.nodup.le_nsmul_iff_le"
{"src": "⊢ ∀ {α : Type u_1} [_inst_1 : decidable_eq α] {s t u : multiset α}, s ≤ t.ndinter u ↔ s ≤ t ∧ s ⊆ u", "decl_nm": "multiset.le_ndinter"
{"src": "α : Type u_1,	_inst_1 : decidable_eq α,	s t u : multiset α	⊢ s ≤ t.ndinter u ↔ s ≤ t ∧ s ⊆ u", "decl_nm": "multiset.le_ndinter"
{"src": "⊢ ∀ {n : ℕ}, nat.antidiagonal (n + 1) = (0, n + 1) ::ₘ map (prod.map nat.succ id) (nat.antidiagonal n)", "decl_nm": "multiset.nat.antidiagonal_succ"
{"src": "n : ℕ	⊢ nat.antidiagonal (n + 1) = (0, n + 1) ::ₘ map (prod.map nat.succ id) (nat.antidiagonal n)", "decl_nm": "multiset.nat.antidiagonal_succ"
{"src": "⊢ ∀ {α : Type u_1} (l : list α), powerset_len_aux 0 l = [0]", "decl_nm": "multiset.powerset_len_aux_zero"
{"src": "α : Type u_1,	l : list α	⊢ powerset_len_aux 0 l = [0]", "decl_nm": "multiset.powerset_len_aux_zero"
{"src": "⊢ ∀ {R : Type u} {S₁ : Type v} {σ : Type u_1} [_inst_1 : comm_semiring R] [_inst_2 : comm_semiring S₁]	  (f : R →+* S₁), constant_coeff.comp (map f) = f.comp constant_coeff", "decl_nm": "mv_polynomial.constant_coeff_comp_map"
{"src": "R : Type u,	S₁ : Type v,	σ : Type u_1,	_inst_1 : comm_semiring R,	_inst_2 : comm_semiring S₁,	f : R →+* S₁	⊢ constant_coeff.comp (map f) = f.comp constant_coeff", "decl_nm": "mv_polynomial.constant_coeff_comp_map"
{"src": "2 goals	R : Type u,	S₁ : Type v,	σ : Type u_1,	_inst_1 : comm_semiring R,	_inst_2 : comm_semiring S₁,	f : R →+* S₁,	x : R	⊢ ⇑((constant_coeff.comp (map f)).comp C) x = ⇑((f.comp constant_coeff).comp C) x		R : Type u,	S₁ : Type v,	σ : Type u_1,	_inst_1 : comm_semiring R,	_inst_2 : comm_semiring S₁,	f : R →+* S₁	⊢ ∀ (i : σ), ⇑(constant_coeff.comp (map f)) (X i) = ⇑(f.comp constant_coeff) (X i)", "decl_nm": "mv_polynomial.constant_coeff_comp_map"
{"src": "R : Type u,	S₁ : Type v,	σ : Type u_1,	_inst_1 : comm_semiring R,	_inst_2 : comm_semiring S₁,	f : R →+* S₁	⊢ ∀ (i : σ), ⇑(constant_coeff.comp (map f)) (X i) = ⇑(f.comp constant_coeff) (X i)", "decl_nm": "mv_polynomial.constant_coeff_comp_map"
{"src": "⊢ ∀ {R : Type u} {S₂ : Type w} {σ : Type u_1} [_inst_1 : comm_semiring R] [_inst_4 : comm_semiring S₂]	  (f : R →+* S₂) (g : σ → S₂) (φ : mv_polynomial σ R),	    (∀ (d : σ →₀ ℕ), coeff d φ ≠ 0 → (∃ (i : σ) (H : i ∈ d.support), g i = 0)) →	    ⇑(eval₂_hom f g) φ = 0", "decl_nm": "mv_polynomial.eval₂_hom_eq_zero"
{"src": "R : Type u,	S₂ : Type w,	σ : Type u_1,	_inst_1 : comm_semiring R,	_inst_4 : comm_semiring S₂,	f : R →+* S₂,	g : σ → S₂,	φ : mv_polynomial σ R,	h : ∀ (d : σ →₀ ℕ), coeff d φ ≠ 0 → (∃ (i : σ) (H : i ∈ d.support), g i = 0)	⊢ ⇑(eval₂_hom f g) φ = 0", "decl_nm": "mv_polynomial.eval₂_hom_eq_zero"
{"src": "R : Type u,	S₂ : Type w,	σ : Type u_1,	_inst_1 : comm_semiring R,	_inst_4 : comm_semiring S₂,	f : R →+* S₂,	g : σ → S₂,	φ : mv_polynomial σ R,	h : ∀ (d : σ →₀ ℕ), coeff d φ ≠ 0 → (∃ (i : σ) (H : i ∈ d.support), g i = 0)	⊢ ∀ (x : σ →₀ ℕ), x ∈ φ.support → ⇑(eval₂_hom f g) (⇑(monomial x) (coeff x φ)) = 0", "decl_nm": "mv_polynomial.eval₂_hom_eq_zero"
{"src": "R : Type u,	S₂ : Type w,	σ : Type u_1,	_inst_1 : comm_semiring R,	_inst_4 : comm_semiring S₂,	f : R →+* S₂,	g : σ → S₂,	φ : mv_polynomial σ R,	h : ∀ (d : σ →₀ ℕ), coeff d φ ≠ 0 → (∃ (i : σ) (H : i ∈ d.support), g i = 0),	d : σ →₀ ℕ,	hd : d ∈ φ.support	⊢ ⇑(eval₂_hom f g) (⇑(monomial d) (coeff d φ)) = 0", "decl_nm": "mv_polynomial.eval₂_hom_eq_zero"
{"src": "R : Type u,	S₂ : Type w,	σ : Type u_1,	_inst_1 : comm_semiring R,	_inst_4 : comm_semiring S₂,	f : R →+* S₂,	g : σ → S₂,	φ : mv_polynomial σ R,	h : ∀ (d : σ →₀ ℕ), coeff d φ ≠ 0 → (∃ (i : σ) (H : i ∈ d.support), g i = 0),	d : σ →₀ ℕ,	hd : d ∈ φ.support,	i : σ,	hi : i ∈ d.support,	hgi : g i = 0	⊢ ⇑(eval₂_hom f g) (⇑(monomial d) (coeff d φ)) = 0", "decl_nm": "mv_polynomial.eval₂_hom_eq_zero"
{"src": "R : Type u,	S₂ : Type w,	σ : Type u_1,	_inst_1 : comm_semiring R,	_inst_4 : comm_semiring S₂,	f : R →+* S₂,	g : σ → S₂,	φ : mv_polynomial σ R,	h : ∀ (d : σ →₀ ℕ), coeff d φ ≠ 0 → (∃ (i : σ) (H : i ∈ d.support), g i = 0),	d : σ →₀ ℕ,	hd : d ∈ φ.support,	i : σ,	hi : i ∈ d.support,	hgi : g i = 0	⊢ g i ^ ⇑d i = 0", "decl_nm": "mv_polynomial.eval₂_hom_eq_zero"
{"src": "R : Type u,	S₂ : Type w,	σ : Type u_1,	_inst_1 : comm_semiring R,	_inst_4 : comm_semiring S₂,	f : R →+* S₂,	g : σ → S₂,	φ : mv_polynomial σ R,	h : ∀ (d : σ →₀ ℕ), coeff d φ ≠ 0 → (∃ (i : σ) (H : i ∈ d.support), g i = 0),	d : σ →₀ ℕ,	hd : d ∈ φ.support,	i : σ,	hi : i ∈ d.support,	hgi : g i = 0	⊢ 0 < ⇑d i", "decl_nm": "mv_polynomial.eval₂_hom_eq_zero"
{"src": "⊢ ∀ (n : ℕ), ¬2 ∣ bit1 n", "decl_nm": "nat.not_two_dvd_bit1"
{"src": "n : ℕ	⊢ ¬2 ∣ bit1 n", "decl_nm": "nat.not_two_dvd_bit1"
{"src": "n : ℕ	⊢ ¬2 = 1", "decl_nm": "nat.not_two_dvd_bit1"
{"src": "⊢ ∀ {a b : ℕ}, 0 < b → b < a → ¬a ∣ b", "decl_nm": "nat.not_dvd_of_pos_of_lt"
{"src": "a b : ℕ,	h1 : 0 < b,	h2 : b < a	⊢ ¬a ∣ b", "decl_nm": "nat.not_dvd_of_pos_of_lt"
{"src": "a c : ℕ,	h1 : 0 < a * c,	h2 : a * c < a	⊢ false", "decl_nm": "nat.not_dvd_of_pos_of_lt"
{"src": "2 goals	a : ℕ,	h1 : 0 < a * 0,	h2 : a * 0 < a	⊢ false		a c : ℕ,	h1 : 0 < a * c,	h2 : a * c < a,	hc : 0 < c	⊢ false", "decl_nm": "nat.not_dvd_of_pos_of_lt"
{"src": "a c : ℕ,	h1 : 0 < a * c,	h2 : a * c < a,	hc : 0 < c	⊢ false", "decl_nm": "nat.not_dvd_of_pos_of_lt"
{"src": "⊢ ∀ (n : ℕ), n.bodd_div2 = (n.bodd, n.div2)", "decl_nm": "nat.bodd_div2_eq"
{"src": "n : ℕ	⊢ n.bodd_div2 = (n.bodd, n.div2)", "decl_nm": "nat.bodd_div2_eq"
{"src": "n : ℕ	⊢ n.bodd_div2 = (n.bodd_div2.fst, n.bodd_div2.snd)", "decl_nm": "nat.bodd_div2_eq"
{"src": "n : ℕ,	fst : bool,	snd : ℕ	⊢ (fst, snd) = ((fst, snd).fst, (fst, snd).snd)", "decl_nm": "nat.bodd_div2_eq"
{"src": "⊢ ∀ {a b c d : ℕ}, c + d = a + b - 1 → a ≤ c ∨ b ≤ d", "decl_nm": "nat.le_or_le_of_add_eq_add_pred"
{"src": "a b c d : ℕ,	h : c + d = a + b - 1	⊢ a ≤ c ∨ b ≤ d", "decl_nm": "nat.le_or_le_of_add_eq_add_pred"
{"src": "2 goals	case or.inl	a b c d : ℕ,	h : c + d = a + b - 1,	h' : a ≤ c	⊢ a ≤ c ∨ b ≤ d		case or.inr	a b c d : ℕ,	h : c + d = a + b - 1,	h' : c < a	⊢ a ≤ c ∨ b ≤ d", "decl_nm": "nat.le_or_le_of_add_eq_add_pred"
{"src": "2 goals	a b c d : ℕ,	h : c + d = a + b - 1,	h' : a ≤ c	⊢ a ≤ c		case or.inr	a b c d : ℕ,	h : c + d = a + b - 1,	h' : c < a	⊢ a ≤ c ∨ b ≤ d", "decl_nm": "nat.le_or_le_of_add_eq_add_pred"
{"src": "case or.inr	a b c d : ℕ,	h : c + d = a + b - 1,	h' : c < a	⊢ a ≤ c ∨ b ≤ d", "decl_nm": "nat.le_or_le_of_add_eq_add_pred"
{"src": "a b c d : ℕ,	h : c + d = a + b - 1,	h' : c < a	⊢ b ≤ d", "decl_nm": "nat.le_or_le_of_add_eq_add_pred"
{"src": "a b c d : ℕ,	h : c + d = a + b - 1,	h' : c + d < a + d	⊢ b ≤ d", "decl_nm": "nat.le_or_le_of_add_eq_add_pred"
{"src": "a b c d : ℕ,	h : c + d = a + b - 1,	h' : a + b - 1 < a + d	⊢ b ≤ d", "decl_nm": "nat.le_or_le_of_add_eq_add_pred"
{"src": "2 goals	case or.inl	a b c d : ℕ,	h : c + d = a + b - 1,	h' : a + b - 1 < a + d,	hb : b = 0	⊢ b ≤ d		case or.inr	a b c d : ℕ,	h : c + d = a + b - 1,	h' : a + b - 1 < a + d,	hb : 0 < b	⊢ b ≤ d", "decl_nm": "nat.le_or_le_of_add_eq_add_pred"
{"src": "2 goals	case or.inl	a b c d : ℕ,	h : c + d = a + b - 1,	h' : a + b - 1 < a + d,	hb : b = 0	⊢ 0 ≤ d		case or.inr	a b c d : ℕ,	h : c + d = a + b - 1,	h' : a + b - 1 < a + d,	hb : 0 < b	⊢ b ≤ d", "decl_nm": "nat.le_or_le_of_add_eq_add_pred"
{"src": "case or.inr	a b c d : ℕ,	h : c + d = a + b - 1,	h' : a + b - 1 < a + d,	hb : 0 < b	⊢ b ≤ d", "decl_nm": "nat.le_or_le_of_add_eq_add_pred"
{"src": "case or.inr	a b c d : ℕ,	h : c + d = a + b - 1,	hb : 0 < b,	h' : b - 1 < d	⊢ b ≤ d", "decl_nm": "nat.le_or_le_of_add_eq_add_pred"
{"src": "⊢ ∀ (n : ℕ), n.land 0 = 0", "decl_nm": "nat.land_zero"
{"src": "n : ℕ	⊢ n.land 0 = 0", "decl_nm": "nat.land_zero"
{"src": "⊢ ∀ (L : list ℕ), of_digits 1 L = L.sum", "decl_nm": "nat.of_digits_one"
{"src": "L : list ℕ	⊢ of_digits 1 L = L.sum", "decl_nm": "nat.of_digits_one"
{"src": "2 goals	case list.nil	⊢ of_digits 1 list.nil = list.nil.sum		case list.cons	d : ℕ,	L : list ℕ,	ih : of_digits 1 L = L.sum	⊢ of_digits 1 (d :: L) = (d :: L).sum", "decl_nm": "nat.of_digits_one"
{"src": "case list.cons	d : ℕ,	L : list ℕ,	ih : of_digits 1 L = L.sum	⊢ of_digits 1 (d :: L) = (d :: L).sum", "decl_nm": "nat.of_digits_one"
{"src": "⊢ ∀ (b b' : ℕ), b' % b = 1 → ∀ (n : ℕ), n ≡ (b'.digits n).sum [MOD b]", "decl_nm": "nat.modeq_digits_sum"
{"src": "b b' : ℕ,	h : b' % b = 1,	n : ℕ	⊢ n ≡ (b'.digits n).sum [MOD b]", "decl_nm": "nat.modeq_digits_sum"
{"src": "b b' : ℕ,	h : b' % b = 1,	n : ℕ	⊢ n ≡ of_digits 1 (b'.digits n) [MOD b]", "decl_nm": "nat.modeq_digits_sum"
{"src": "b b' : ℕ,	h : b' % b = 1,	n : ℕ	⊢ of_digits b' (b'.digits n) ≡ of_digits 1 (b'.digits n) [MOD b]", "decl_nm": "nat.modeq_digits_sum"
{"src": "b b' : ℕ,	h : b' % b = 1,	n : ℕ	⊢ 1 = b' % b", "decl_nm": "nat.modeq_digits_sum"
{"src": "⊢ ∀ (b n : ℕ), (b + 2).digits (n + 1) = (n + 1) % (b + 2) :: (b + 2).digits ((n + 1) / (b + 2))", "decl_nm": "nat.digits_add_two_add_one"
{"src": "b n : ℕ	⊢ (b + 2).digits (n + 1) = (n + 1) % (b + 2) :: (b + 2).digits ((n + 1) / (b + 2))", "decl_nm": "nat.digits_add_two_add_one"
{"src": "b n : ℕ	⊢ 0 < n + 1", "decl_nm": "nat.digits_add_two_add_one"
{"src": "⊢ ∀ (k n m : ℕ), (k * n).dist (k * m) = k * n.dist m", "decl_nm": "nat.dist_mul_left"
{"src": "k n m : ℕ	⊢ (k * n).dist (k * m) = k * n.dist m", "decl_nm": "nat.dist_mul_left"
{"src": "⊢ ∀ (x : ℕ) (h : ↑x.dom), ↑x.get h = x", "decl_nm": "enat.get_coe'"
{"src": "x : ℕ,	h : ↑x.dom	⊢ ↑x.get h = x", "decl_nm": "enat.get_coe'"
{"src": "⊢ ∀ {b : ℕ}, b ≤ 1 → ∀ (n : ℕ), clog b n = 0", "decl_nm": "nat.clog_of_left_le_one"
{"src": "b : ℕ,	hb : b ≤ 1,	n : ℕ	⊢ clog b n = 0", "decl_nm": "nat.clog_of_left_le_one"
{"src": "⊢ ∀ {p : ℕ}, prime p → ∀ (n : ℕ), (p ^ n).factors = repeat p n", "decl_nm": "nat.prime.factors_pow"
{"src": "p : ℕ,	hp : prime p,	n : ℕ	⊢ (p ^ n).factors = repeat p n", "decl_nm": "nat.prime.factors_pow"
{"src": "p : ℕ,	hp : prime p,	n : ℕ	⊢ repeat p n = (p ^ n).factors", "decl_nm": "nat.prime.factors_pow"
{"src": "p : ℕ,	hp : prime p,	n : ℕ	⊢ repeat p n ~ (p ^ n).factors", "decl_nm": "nat.prime.factors_pow"
{"src": "p : ℕ,	hp : prime p,	n : ℕ	⊢ ∀ (p_1 : ℕ), p_1 ∈ repeat p n → prime p_1", "decl_nm": "nat.prime.factors_pow"
{"src": "p : ℕ,	hp : prime p,	n q : ℕ,	hq : q ∈ repeat p n	⊢ prime q", "decl_nm": "nat.prime.factors_pow"
{"src": "⊢ ∀ {n q : ℕ}, q = sqrt n ↔ q ^ 2 ≤ n ∧ n < (q + 1) ^ 2", "decl_nm": "nat.eq_sqrt'"
{"src": "n q : ℕ	⊢ q = sqrt n ↔ q ^ 2 ≤ n ∧ n < (q + 1) ^ 2", "decl_nm": "nat.eq_sqrt'"
{"src": "⊢ ∀ (n : znum), n / 0 = 0", "decl_nm": "znum.div_zero"
{"src": "n : znum	⊢ n / 0 = 0", "decl_nm": "znum.div_zero"
{"src": "3 goals	case znum.zero	⊢ zero / 0 = 0		case znum.pos	n : pos_num	⊢ pos n / 0 = 0		case znum.neg	n : pos_num	⊢ neg n / 0 = 0", "decl_nm": "znum.div_zero"
{"src": "2 goals	case znum.pos	n : pos_num	⊢ pos n / 0 = 0		case znum.neg	n : pos_num	⊢ neg n / 0 = 0", "decl_nm": "znum.div_zero"
{"src": "case znum.neg	n : pos_num	⊢ neg n / 0 = 0", "decl_nm": "znum.div_zero"
{"src": "⊢ ∀ (n : pos_num), 1 + n = n.succ", "decl_nm": "pos_num.one_add"
{"src": "n : pos_num	⊢ 1 + n = n.succ", "decl_nm": "pos_num.one_add"
{"src": "3 goals	case pos_num.one	⊢ 1 + one = one.succ		case pos_num.bit1	n : pos_num	⊢ 1 + n.bit1 = n.bit1.succ		case pos_num.bit0	n : pos_num	⊢ 1 + n.bit0 = n.bit0.succ", "decl_nm": "pos_num.one_add"
{"src": "2 goals	case pos_num.bit1	n : pos_num	⊢ 1 + n.bit1 = n.bit1.succ		case pos_num.bit0	n : pos_num	⊢ 1 + n.bit0 = n.bit0.succ", "decl_nm": "pos_num.one_add"
{"src": "case pos_num.bit0	n : pos_num	⊢ 1 + n.bit0 = n.bit0.succ", "decl_nm": "pos_num.one_add"
{"src": "⊢ ∀ (n : num), -n.to_znum_neg = n.to_znum", "decl_nm": "num.zneg_to_znum_neg"
{"src": "n : num	⊢ -n.to_znum_neg = n.to_znum", "decl_nm": "num.zneg_to_znum_neg"
{"src": "2 goals	case num.zero	⊢ -zero.to_znum_neg = zero.to_znum		case num.pos	n : pos_num	⊢ -(pos n).to_znum_neg = (pos n).to_znum", "decl_nm": "num.zneg_to_znum_neg"
{"src": "case num.pos	n : pos_num	⊢ -(pos n).to_znum_neg = (pos n).to_znum", "decl_nm": "num.zneg_to_znum_neg"
{"src": "⊢ ∀ (n : ℕ), ↑n.to_znum_neg = -↑n", "decl_nm": "num.of_nat_to_znum_neg"
{"src": "n : ℕ	⊢ ↑n.to_znum_neg = -↑n", "decl_nm": "num.of_nat_to_znum_neg"
{"src": "⊢ ∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} (x : option α) (f : α → option β) (g : β → option γ),	    (x.bind f).bind g = x.bind (λ (y : α), (f y).bind g)", "decl_nm": "option.bind_assoc"
{"src": "α : Type u_1,	β : Type u_2,	γ : Type u_3,	x : option α,	f : α → option β,	g : β → option γ	⊢ (x.bind f).bind g = x.bind (λ (y : α), (f y).bind g)", "decl_nm": "option.bind_assoc"
{"src": "2 goals	case option.none	α : Type u_1,	β : Type u_2,	γ : Type u_3,	f : α → option β,	g : β → option γ	⊢ (none.bind f).bind g = none.bind (λ (y : α), (f y).bind g)		case option.some	α : Type u_1,	β : Type u_2,	γ : Type u_3,	f : α → option β,	g : β → option γ,	x : α	⊢ ((some x).bind f).bind g = (some x).bind (λ (y : α), (f y).bind g)", "decl_nm": "option.bind_assoc"
{"src": "case option.some	α : Type u_1,	β : Type u_2,	γ : Type u_3,	f : α → option β,	g : β → option γ,	x : α	⊢ ((some x).bind f).bind g = (some x).bind (λ (y : α), (f y).bind g)", "decl_nm": "option.bind_assoc"
{"src": "⊢ ∀ {α β : Type u_1} {x : option α} {f : α → β} {b : β},	    f <$> x = some b ↔ ∃ (a : α), x = some a ∧ f a = b", "decl_nm": "option.map_eq_some"
{"src": "α β : Type u_1,	x : option α,	f : α → β,	b : β	⊢ f <$> x = some b ↔ ∃ (a : α), x = some a ∧ f a = b", "decl_nm": "option.map_eq_some"
{"src": "2 goals	case option.none	α β : Type u_1,	f : α → β,	b : β	⊢ f <$> none = some b ↔ ∃ (a : α), none = some a ∧ f a = b		case option.some	α β : Type u_1,	f : α → β,	b : β,	x : α	⊢ f <$> some x = some b ↔ ∃ (a : α), some x = some a ∧ f a = b", "decl_nm": "option.map_eq_some"
{"src": "case option.some	α β : Type u_1,	f : α → β,	b : β,	x : α	⊢ f <$> some x = some b ↔ ∃ (a : α), some x = some a ∧ f a = b", "decl_nm": "option.map_eq_some"
{"src": "⊢ ∀ {α : Type u_1} {x : option α}, ↥(x.is_some) ↔ ∃ (a : α), x = some a", "decl_nm": "option.is_some_iff_exists"
{"src": "α : Type u_1,	x : option α	⊢ ↥(x.is_some) ↔ ∃ (a : α), x = some a", "decl_nm": "option.is_some_iff_exists"
{"src": "2 goals	case option.none	α : Type u_1	⊢ ↥(none.is_some) ↔ ∃ (a : α), none = some a		case option.some	α : Type u_1,	x : α	⊢ ↥((some x).is_some) ↔ ∃ (a : α), some x = some a", "decl_nm": "option.is_some_iff_exists"
{"src": "case option.some	α : Type u_1,	x : α	⊢ ↥((some x).is_some) ↔ ∃ (a : α), some x = some a", "decl_nm": "option.is_some_iff_exists"
{"src": "⊢ ∀ {α : Type u_1} (l : ordnode α) (x : α) (m : ordnode α) (y : α) (r : ordnode α),	    (l.node3_r x m y r).dual = r.dual.node3_l y m.dual x l.dual", "decl_nm": "ordnode.dual_node3_r"
{"src": "α : Type u_1,	l : ordnode α,	x : α,	m : ordnode α,	y : α,	r : ordnode α	⊢ (l.node3_r x m y r).dual = r.dual.node3_l y m.dual x l.dual", "decl_nm": "ordnode.dual_node3_r"
{"src": "⊢ ∀ {α : Type u_1} {P : α → Prop} {l : ordnode α} {x : α} {r : ordnode α},	    l.balanced →	    r.balanced →	    l.sized →	    r.sized →	    ((∃ (l' : ℕ), raised l.size l' ∧ balanced_sz l' r.size) ∨	       ∃ (r' : ℕ), raised r' r.size ∧ balanced_sz l.size r') →	    (all P (l.balance_r x r) ↔ all P l ∧ P x ∧ all P r)", "decl_nm": "ordnode.all_balance_r"
{"src": "α : Type u_1,	P : α → Prop,	l : ordnode α,	x : α,	r : ordnode α,	hl : l.balanced,	hr : r.balanced,	sl : l.sized,	sr : r.sized,	H :	  (∃ (l' : ℕ), raised l.size l' ∧ balanced_sz l' r.size) ∨	    ∃ (r' : ℕ), raised r' r.size ∧ balanced_sz l.size r'	⊢ all P (l.balance_r x r) ↔ all P l ∧ P x ∧ all P r", "decl_nm": "ordnode.all_balance_r"
{"src": "⊢ ∀ {α : Type u_1} {β : Type u_2} {f : α →. β} {s : set α} (h : s ⊆ f.dom) (a : α) (b : β),	    b ∈ f.restrict h a ↔ a ∈ s ∧ b ∈ f a", "decl_nm": "pfun.mem_restrict"
{"src": "α : Type u_1,	β : Type u_2,	f : α →. β,	s : set α,	h : s ⊆ f.dom,	a : α,	b : β	⊢ b ∈ f.restrict h a ↔ a ∈ s ∧ b ∈ f a", "decl_nm": "pfun.mem_restrict"
{"src": "⊢ ∀ {α : Type u_1} {β : Type u_2} (f : α →. β) (x : α), x ∈ f.dom ↔ ∃ (y : β), y ∈ f x", "decl_nm": "pfun.mem_dom"
{"src": "α : Type u_1,	β : Type u_2,	f : α →. β,	x : α	⊢ x ∈ f.dom ↔ ∃ (y : β), y ∈ f x", "decl_nm": "pfun.mem_dom"
{"src": "⊢ ∀ {P : pfunctor} {α : Type u} (g : α → P.obj α) (x : α), (M.corec g x).dest = M.corec g <$> g x", "decl_nm": "pfunctor.M.dest_corec"
{"src": "P : pfunctor,	α : Type u,	g : α → P.obj α,	x : α	⊢ (M.corec g x).dest = M.corec g <$> g x", "decl_nm": "pfunctor.M.dest_corec"
{"src": "⊢ ∀ (d : ℕ) (u : prime_multiset), (d • u).prod = u.prod ^ d", "decl_nm": "prime_multiset.prod_smul"
{"src": "d : ℕ,	u : prime_multiset	⊢ (d • u).prod = u.prod ^ d", "decl_nm": "prime_multiset.prod_smul"
{"src": "2 goals	case nat.zero	u : prime_multiset	⊢ (0 • u).prod = u.prod ^ 0		case nat.succ	u : prime_multiset,	d : ℕ,	ih : (d • u).prod = u.prod ^ d	⊢ (d.succ • u).prod = u.prod ^ d.succ", "decl_nm": "prime_multiset.prod_smul"
{"src": "case nat.succ	u : prime_multiset,	d : ℕ,	ih : (d • u).prod = u.prod ^ d	⊢ (d.succ • u).prod = u.prod ^ d.succ", "decl_nm": "prime_multiset.prod_smul"
{"src": "⊢ ∀ (m n : ℕ+), (m.gcd n).factor_multiset = m.factor_multiset ⊓ n.factor_multiset", "decl_nm": "pnat.factor_multiset_gcd"
{"src": "m n : ℕ+	⊢ (m.gcd n).factor_multiset = m.factor_multiset ⊓ n.factor_multiset", "decl_nm": "pnat.factor_multiset_gcd"
{"src": "2 goals	m n : ℕ+	⊢ (m.gcd n).factor_multiset ≤ m.factor_multiset ⊓ n.factor_multiset		m n : ℕ+	⊢ m.factor_multiset ⊓ n.factor_multiset ≤ (m.gcd n).factor_multiset", "decl_nm": "pnat.factor_multiset_gcd"
{"src": "2 goals	m n : ℕ+	⊢ (m.gcd n).factor_multiset ≤ m.factor_multiset ∧ (m.gcd n).factor_multiset ≤ n.factor_multiset		m n : ℕ+	⊢ m.factor_multiset ⊓ n.factor_multiset ≤ (m.gcd n).factor_multiset", "decl_nm": "pnat.factor_multiset_gcd"
{"src": "3 goals	m n : ℕ+	⊢ (m.gcd n).factor_multiset ≤ m.factor_multiset		m n : ℕ+	⊢ (m.gcd n).factor_multiset ≤ n.factor_multiset		m n : ℕ+	⊢ m.factor_multiset ⊓ n.factor_multiset ≤ (m.gcd n).factor_multiset", "decl_nm": "pnat.factor_multiset_gcd"
{"src": "3 goals	m n : ℕ+	⊢ m.gcd n ∣ m		m n : ℕ+	⊢ (m.gcd n).factor_multiset ≤ n.factor_multiset		m n : ℕ+	⊢ m.factor_multiset ⊓ n.factor_multiset ≤ (m.gcd n).factor_multiset", "decl_nm": "pnat.factor_multiset_gcd"
{"src": "2 goals	m n : ℕ+	⊢ (m.gcd n).factor_multiset ≤ n.factor_multiset		m n : ℕ+	⊢ m.factor_multiset ⊓ n.factor_multiset ≤ (m.gcd n).factor_multiset", "decl_nm": "pnat.factor_multiset_gcd"
{"src": "2 goals	m n : ℕ+	⊢ m.gcd n ∣ n		m n : ℕ+	⊢ m.factor_multiset ⊓ n.factor_multiset ≤ (m.gcd n).factor_multiset", "decl_nm": "pnat.factor_multiset_gcd"
{"src": "m n : ℕ+	⊢ m.factor_multiset ⊓ n.factor_multiset ≤ (m.gcd n).factor_multiset", "decl_nm": "pnat.factor_multiset_gcd"
{"src": "m n : ℕ+	⊢ (m.factor_multiset ⊓ n.factor_multiset).prod ∣ m.gcd n", "decl_nm": "pnat.factor_multiset_gcd"
{"src": "2 goals	m n : ℕ+	⊢ (m.factor_multiset ⊓ n.factor_multiset).prod ∣ m		m n : ℕ+	⊢ (m.factor_multiset ⊓ n.factor_multiset).prod ∣ n", "decl_nm": "pnat.factor_multiset_gcd"
{"src": "2 goals	m n : ℕ+	⊢ m.factor_multiset ⊓ n.factor_multiset ≤ m.factor_multiset		m n : ℕ+	⊢ (m.factor_multiset ⊓ n.factor_multiset).prod ∣ n", "decl_nm": "pnat.factor_multiset_gcd"
{"src": "m n : ℕ+	⊢ (m.factor_multiset ⊓ n.factor_multiset).prod ∣ n", "decl_nm": "pnat.factor_multiset_gcd"
{"src": "m n : ℕ+	⊢ m.factor_multiset ⊓ n.factor_multiset ≤ n.factor_multiset", "decl_nm": "pnat.factor_multiset_gcd"
{"src": "⊢ ∀ {R : Type u} [_inst_1 : ring R] (p : polynomial R) (n : ℕ), (-p).coeff n = -p.coeff n", "decl_nm": "polynomial.coeff_neg"
{"src": "R : Type u,	_inst_1 : ring R,	p : polynomial R,	n : ℕ	⊢ (-p).coeff n = -p.coeff n", "decl_nm": "polynomial.coeff_neg"
{"src": "R : Type u,	_inst_1 : ring R,	n : ℕ,	p : add_monoid_algebra R ℕ	⊢ (-{to_finsupp := p}).coeff n = -{to_finsupp := p}.coeff n", "decl_nm": "polynomial.coeff_neg"
{"src": "⊢ ∀ {R : Type u} {S : Type v} [_inst_1 : semiring R] {p : polynomial R} [_inst_2 : semiring S] {q : polynomial S},	    p.degree = q.degree → p.nat_degree = q.nat_degree", "decl_nm": "polynomial.nat_degree_eq_of_degree_eq"
{"src": "R : Type u,	S : Type v,	_inst_1 : semiring R,	p : polynomial R,	_inst_2 : semiring S,	q : polynomial S,	h : p.degree = q.degree	⊢ p.nat_degree = q.nat_degree", "decl_nm": "polynomial.nat_degree_eq_of_degree_eq"
{"src": "R : Type u,	S : Type v,	_inst_1 : semiring R,	p : polynomial R,	_inst_2 : semiring S,	q : polynomial S,	h : p.degree = q.degree	⊢ option.get_or_else p.degree 0 = option.get_or_else q.degree 0", "decl_nm": "polynomial.nat_degree_eq_of_degree_eq"
{"src": "⊢ ∀ {R : Type u_1} [_inst_2 : semiring R] [_inst_3 : nontrivial R] {p : polynomial R}, p.monic → p ≠ 0", "decl_nm": "polynomial.monic.ne_zero"
{"src": "R : Type u_1,	_inst_2 : semiring R,	_inst_3 : nontrivial R,	p : polynomial R,	hp : p.monic	⊢ p ≠ 0", "decl_nm": "polynomial.monic.ne_zero"
{"src": "R : Type u_1,	_inst_2 : semiring R,	_inst_3 : nontrivial R,	hp : 0.monic	⊢ false", "decl_nm": "polynomial.monic.ne_zero"
{"src": "⊢ ∀ {R : Type u} [_inst_1 : semiring R] (n : ℕ), ↑n.nat_trailing_degree = 0", "decl_nm": "polynomial.nat_trailing_degree_nat_cast"
{"src": "R : Type u,	_inst_1 : semiring R,	n : ℕ	⊢ ↑n.nat_trailing_degree = 0", "decl_nm": "polynomial.nat_trailing_degree_nat_cast"
{"src": "⊢ ∀ {R : Type u} [_inst_1 : semiring R] {p : polynomial R} {x : R}, eval x (p * X) = eval x p * x", "decl_nm": "polynomial.eval_mul_X"
{"src": "R : Type u,	_inst_1 : semiring R,	p : polynomial R,	x : R	⊢ eval x (p * X) = eval x p * x", "decl_nm": "polynomial.eval_mul_X"
{"src": "2 goals	R : Type u,	_inst_1 : semiring R,	p : polynomial R,	x : R	⊢ ∀ (p q : polynomial R),	    eval x (p * X) = eval x p * x → eval x (q * X) = eval x q * x → eval x ((p + q) * X) = eval x (p + q) * x		R : Type u,	_inst_1 : semiring R,	p : polynomial R,	x : R	⊢ ∀ (n : ℕ) (a : R), eval x (⇑(monomial n) a * X) = eval x (⇑(monomial n) a) * x", "decl_nm": "polynomial.eval_mul_X"
{"src": "2 goals	R : Type u,	_inst_1 : semiring R,	p : polynomial R,	x : R,	p q : polynomial R,	ph : eval x (p * X) = eval x p * x,	qh : eval x (q * X) = eval x q * x	⊢ eval x ((p + q) * X) = eval x (p + q) * x		R : Type u,	_inst_1 : semiring R,	p : polynomial R,	x : R	⊢ ∀ (n : ℕ) (a : R), eval x (⇑(monomial n) a * X) = eval x (⇑(monomial n) a) * x", "decl_nm": "polynomial.eval_mul_X"
{"src": "R : Type u,	_inst_1 : semiring R,	p : polynomial R,	x : R	⊢ ∀ (n : ℕ) (a : R), eval x (⇑(monomial n) a * X) = eval x (⇑(monomial n) a) * x", "decl_nm": "polynomial.eval_mul_X"
{"src": "R : Type u,	_inst_1 : semiring R,	p : polynomial R,	x : R,	n : ℕ,	a : R	⊢ eval x (⇑(monomial n) a * X) = eval x (⇑(monomial n) a) * x", "decl_nm": "polynomial.eval_mul_X"
{"src": "⊢ ∀ {R : Type u} {S : Type v} [_inst_1 : semiring R] {p : polynomial R} [_inst_2 : semiring S] (f : R →+* S),	    ⇑f p.leading_coeff ≠ 0 → (map f p).leading_coeff = ⇑f p.leading_coeff", "decl_nm": "polynomial.leading_coeff_map_of_leading_coeff_ne_zero"
{"src": "R : Type u,	S : Type v,	_inst_1 : semiring R,	p : polynomial R,	_inst_2 : semiring S,	f : R →+* S,	hf : ⇑f p.leading_coeff ≠ 0	⊢ (map f p).leading_coeff = ⇑f p.leading_coeff", "decl_nm": "polynomial.leading_coeff_map_of_leading_coeff_ne_zero"
{"src": "R : Type u,	S : Type v,	_inst_1 : semiring R,	p : polynomial R,	_inst_2 : semiring S,	f : R →+* S,	hf : ⇑f p.leading_coeff ≠ 0	⊢ (map f p).coeff (map f p).nat_degree = ⇑f (p.coeff p.nat_degree)", "decl_nm": "polynomial.leading_coeff_map_of_leading_coeff_ne_zero"
{"src": "⊢ ∀ {R : Type u} [_inst_1 : ring R] {p q : polynomial R} {S : Type u_1} [_inst_2 : ring S] (f : R →+* S) {x : S},	    eval₂ f x (p - q) = eval₂ f x p - eval₂ f x q", "decl_nm": "polynomial.eval₂_sub"
{"src": "R : Type u,	_inst_1 : ring R,	p q : polynomial R,	S : Type u_1,	_inst_2 : ring S,	f : R →+* S,	x : S	⊢ eval₂ f x (p - q) = eval₂ f x p - eval₂ f x q", "decl_nm": "polynomial.eval₂_sub"
{"src": "⊢ ∀ {R : Type u_1} {S : Type u_2} [_inst_2 : field R] [_inst_3 : field S] [_inst_4 : algebra R S] {n : ℕ},	    n ≠ 0 → ∀ {a : R}, a ≠ 0 → (⇑C a * X ^ n).root_set S = {0}", "decl_nm": "polynomial.root_set_C_mul_X_pow"
{"src": "R : Type u_1,	S : Type u_2,	_inst_2 : field R,	_inst_3 : field S,	_inst_4 : algebra R S,	n : ℕ,	hn : n ≠ 0,	a : R,	ha : a ≠ 0	⊢ (⇑C a * X ^ n).root_set S = {0}", "decl_nm": "polynomial.root_set_C_mul_X_pow"
{"src": "R : Type u_1,	S : Type u_2,	_inst_2 : field R,	_inst_3 : field S,	_inst_4 : algebra R S,	n : ℕ,	hn : n ≠ 0,	a : R,	ha : a ≠ 0,	x : S	⊢ x ∈ (⇑C a * X ^ n).root_set S ↔ x ∈ {0}", "decl_nm": "polynomial.root_set_C_mul_X_pow"
{"src": "2 goals	R : Type u_1,	S : Type u_2,	_inst_2 : field R,	_inst_3 : field S,	_inst_4 : algebra R S,	n : ℕ,	hn : n ≠ 0,	a : R,	ha : a ≠ 0,	x : S	⊢ ⇑(algebra_map R S) a = 0 ∨ x ^ n = 0 ↔ x = 0		R : Type u_1,	S : Type u_2,	_inst_2 : field R,	_inst_3 : field S,	_inst_4 : algebra R S,	n : ℕ,	hn : n ≠ 0,	a : R,	ha : a ≠ 0,	x : S	⊢ ⇑C a * X ^ n ≠ 0", "decl_nm": "polynomial.root_set_C_mul_X_pow"
{"src": "2 goals	R : Type u_1,	S : Type u_2,	_inst_2 : field R,	_inst_3 : field S,	_inst_4 : algebra R S,	n : ℕ,	hn : n ≠ 0,	a : R,	ha : a ≠ 0,	x : S	⊢ a = 0 → x = 0		R : Type u_1,	S : Type u_2,	_inst_2 : field R,	_inst_3 : field S,	_inst_4 : algebra R S,	n : ℕ,	hn : n ≠ 0,	a : R,	ha : a ≠ 0,	x : S	⊢ ⇑C a * X ^ n ≠ 0", "decl_nm": "polynomial.root_set_C_mul_X_pow"
{"src": "R : Type u_1,	S : Type u_2,	_inst_2 : field R,	_inst_3 : field S,	_inst_4 : algebra R S,	n : ℕ,	hn : n ≠ 0,	a : R,	ha : a ≠ 0,	x : S	⊢ ⇑C a * X ^ n ≠ 0", "decl_nm": "polynomial.root_set_C_mul_X_pow"
{"src": "⊢ ∀ {R : Type u} [_inst_1 : field R] (u : (polynomial R)ˣ) (n : ℕ), (↑u.coeff n)⁻¹ = ↑u⁻¹.coeff n", "decl_nm": "polynomial.coeff_inv_units"
{"src": "R : Type u,	_inst_1 : field R,	u : (polynomial R)ˣ,	n : ℕ	⊢ (↑u.coeff n)⁻¹ = ↑u⁻¹.coeff n", "decl_nm": "polynomial.coeff_inv_units"
{"src": "R : Type u,	_inst_1 : field R,	u : (polynomial R)ˣ,	n : ℕ	⊢ 1 / ite (n = 0) (↑u.coeff 0) 0 = ite (n = 0) (↑u⁻¹.coeff 0) 0", "decl_nm": "polynomial.coeff_inv_units"
{"src": "2 goals	R : Type u,	_inst_1 : field R,	u : (polynomial R)ˣ,	n : ℕ,	h : n = 0	⊢ 1 / ↑u.coeff 0 = ↑u⁻¹.coeff 0		R : Type u,	_inst_1 : field R,	u : (polynomial R)ˣ,	n : ℕ,	h : ¬n = 0	⊢ 1 / 0 = 0", "decl_nm": "polynomial.coeff_inv_units"
{"src": "2 goals	R : Type u,	_inst_1 : field R,	u : (polynomial R)ˣ,	n : ℕ,	h : n = 0	⊢ eval 0 ↑1 = 1		R : Type u,	_inst_1 : field R,	u : (polynomial R)ˣ,	n : ℕ,	h : ¬n = 0	⊢ 1 / 0 = 0", "decl_nm": "polynomial.coeff_inv_units"
{"src": "R : Type u,	_inst_1 : field R,	u : (polynomial R)ˣ,	n : ℕ,	h : ¬n = 0	⊢ 1 / 0 = 0", "decl_nm": "polynomial.coeff_inv_units"
{"src": "⊢ ∀ {R : Type u_1} [_inst_1 : semiring R] (f : polynomial R), ⇑(hasse_deriv 1) f = ⇑derivative f", "decl_nm": "polynomial.hasse_deriv_one'"
{"src": "R : Type u_1,	_inst_1 : semiring R,	f : polynomial R	⊢ ⇑(hasse_deriv 1) f = ⇑derivative f", "decl_nm": "polynomial.hasse_deriv_one'"
{"src": "⊢ ∀ {R : Type u} [_inst_1 : semiring R] {S : Type v} [_inst_2 : semiring S] {f : R →+* S} (p : polynomial S),	    p ∈ lifts f ↔ p ∈ (map_ring_hom f).srange", "decl_nm": "polynomial.lifts_iff_ring_hom_srange"
{"src": "R : Type u,	_inst_1 : semiring R,	S : Type v,	_inst_2 : semiring S,	f : R →+* S,	p : polynomial S	⊢ p ∈ lifts f ↔ p ∈ (map_ring_hom f).srange", "decl_nm": "polynomial.lifts_iff_ring_hom_srange"
{"src": "⊢ ∀ {R : Type u} [_inst_1 : semiring R] {p : polynomial R},	    p.monic → p = X ^ p.nat_degree + (range p.nat_degree).sum (λ (i : ℕ), ⇑C (p.coeff i) * X ^ i)", "decl_nm": "polynomial.monic.as_sum"
{"src": "R : Type u,	_inst_1 : semiring R,	p : polynomial R,	hp : p.monic	⊢ p = X ^ p.nat_degree + (range p.nat_degree).sum (λ (i : ℕ), ⇑C (p.coeff i) * X ^ i)", "decl_nm": "polynomial.monic.as_sum"
{"src": "R : Type u,	_inst_1 : semiring R,	p : polynomial R,	hp : p.monic	⊢ ⇑C (p.coeff p.nat_degree) * X ^ p.nat_degree + (range p.nat_degree).sum (λ (x : ℕ), ⇑C (p.coeff x) * X ^ x) =	    X ^ p.nat_degree + (range p.nat_degree).sum (λ (i : ℕ), ⇑C (p.coeff i) * X ^ i)", "decl_nm": "polynomial.monic.as_sum"
{"src": "2 goals	R : Type u,	_inst_1 : semiring R,	p : polynomial R,	hp : p.monic,	this : ⇑C (p.coeff p.nat_degree) = 1	⊢ ⇑C (p.coeff p.nat_degree) * X ^ p.nat_degree + (range p.nat_degree).sum (λ (x : ℕ), ⇑C (p.coeff x) * X ^ x) =	    X ^ p.nat_degree + (range p.nat_degree).sum (λ (i : ℕ), ⇑C (p.coeff i) * X ^ i)		R : Type u,	_inst_1 : semiring R,	p : polynomial R,	hp : p.monic	⊢ ⇑C (p.coeff p.nat_degree) = 1", "decl_nm": "polynomial.monic.as_sum"
{"src": "R : Type u,	_inst_1 : semiring R,	p : polynomial R,	hp : p.monic	⊢ ⇑C (p.coeff p.nat_degree) = 1", "decl_nm": "polynomial.monic.as_sum"
{"src": "⊢ ∀ {α : Type u_1} [_inst_1 : linear_ordered_field α] {a b : ℚ}, ↑(min a b) = min ↑a ↑b", "decl_nm": "rat.cast_min"
{"src": "α : Type u_1,	_inst_1 : linear_ordered_field α,	a b : ℚ	⊢ ↑(min a b) = min ↑a ↑b", "decl_nm": "rat.cast_min"
{"src": "2 goals	α : Type u_1,	_inst_1 : linear_ordered_field α,	a b : ℚ,	h : a ≤ b	⊢ ↑(min a b) = min ↑a ↑b		α : Type u_1,	_inst_1 : linear_ordered_field α,	a b : ℚ,	h : ¬a ≤ b	⊢ ↑(min a b) = min ↑a ↑b", "decl_nm": "rat.cast_min"
{"src": "α : Type u_1,	_inst_1 : linear_ordered_field α,	a b : ℚ,	h : ¬a ≤ b	⊢ ↑(min a b) = min ↑a ↑b", "decl_nm": "rat.cast_min"
{"src": "⊢ ∀ {c : ℝ} {f g : ℕ → bool},	    0 ≤ c → c < 1 → (∀ (n : ℕ), ↥(f n) → ↥(g n)) → cantor_function c f ≤ cantor_function c g", "decl_nm": "cardinal.cantor_function_le"
{"src": "c : ℝ,	f g : ℕ → bool,	h1 : 0 ≤ c,	h2 : c < 1,	h3 : ∀ (n : ℕ), ↥(f n) → ↥(g n)	⊢ cantor_function c f ≤ cantor_function c g", "decl_nm": "cardinal.cantor_function_le"
{"src": "c : ℝ,	f g : ℕ → bool,	h1 : 0 ≤ c,	h2 : c < 1,	h3 : ∀ (n : ℕ), ↥(f n) → ↥(g n)	⊢ ∀ (b : ℕ), cantor_function_aux c f b ≤ cantor_function_aux c g b", "decl_nm": "cardinal.cantor_function_le"
{"src": "c : ℝ,	f g : ℕ → bool,	h1 : 0 ≤ c,	h2 : c < 1,	h3 : ∀ (n : ℕ), ↥(f n) → ↥(g n),	n : ℕ	⊢ cantor_function_aux c f n ≤ cantor_function_aux c g n", "decl_nm": "cardinal.cantor_function_le"
{"src": "2 goals	case bool.ff	c : ℝ,	f g : ℕ → bool,	h1 : 0 ≤ c,	h2 : c < 1,	h3 : ∀ (n : ℕ), ↥(f n) → ↥(g n),	n : ℕ,	h : f n = ff	⊢ cantor_function_aux c f n ≤ cantor_function_aux c g n		case bool.tt	c : ℝ,	f g : ℕ → bool,	h1 : 0 ≤ c,	h2 : c < 1,	h3 : ∀ (n : ℕ), ↥(f n) → ↥(g n),	n : ℕ,	h : f n = tt	⊢ cantor_function_aux c f n ≤ cantor_function_aux c g n", "decl_nm": "cardinal.cantor_function_le"
{"src": "case bool.tt	c : ℝ,	f g : ℕ → bool,	h1 : 0 ≤ c,	h2 : c < 1,	h3 : ∀ (n : ℕ), ↥(f n) → ↥(g n),	n : ℕ,	h : f n = tt	⊢ cantor_function_aux c f n ≤ cantor_function_aux c g n", "decl_nm": "cardinal.cantor_function_le"
{"src": "c : ℝ,	f g : ℕ → bool,	h1 : 0 ≤ c,	h2 : c < 1,	n : ℕ,	h : f n = tt,	h3 : g n = tt	⊢ cantor_function_aux c f n ≤ cantor_function_aux c g n", "decl_nm": "cardinal.cantor_function_le"
{"src": "⊢ ∀ {a b : ennreal}, a ≠ 0 → a ≠ ⊤ → a * (b / a) = b", "decl_nm": "ennreal.mul_div_cancel'"
{"src": "a b : ennreal,	h0 : a ≠ 0,	hI : a ≠ ⊤	⊢ a * (b / a) = b", "decl_nm": "ennreal.mul_div_cancel'"
{"src": "⊢ ∀ {a b : ennreal}, a + b ≠ ⊤ ↔ a ≠ ⊤ ∧ b ≠ ⊤", "decl_nm": "ennreal.add_ne_top"
{"src": "a b : ennreal	⊢ a + b ≠ ⊤ ↔ a ≠ ⊤ ∧ b ≠ ⊤", "decl_nm": "ennreal.add_ne_top"
{"src": "⊢ ∀ {x y : ℝ}, ↑x < ↑y ↔ x < y", "decl_nm": "ereal.coe_lt_coe_iff"
{"src": "x y : ℝ	⊢ ↑x < ↑y ↔ x < y", "decl_nm": "ereal.coe_lt_coe_iff"
{"src": "x y : ℝ	⊢ x.to_ereal < y.to_ereal ↔ x < y", "decl_nm": "ereal.coe_lt_coe_iff"
{"src": "⊢ ∀ {x : ℝ*}, x.st ≠ 0 → x.is_st x.st", "decl_nm": "hyperreal.is_st_st"
{"src": "x : ℝ*,	hx : x.st ≠ 0	⊢ x.is_st x.st", "decl_nm": "hyperreal.is_st_st"
{"src": "x : ℝ*,	hx : x.st ≠ 0	⊢ x.is_st	    (dite (∃ (r : ℝ), x.is_st r) (λ (h : ∃ (r : ℝ), x.is_st r), classical.some h)	       (λ (h : ¬∃ (r : ℝ), x.is_st r), 0))", "decl_nm": "hyperreal.is_st_st"
{"src": "2 goals	x : ℝ*,	hx : x.st ≠ 0,	h : ∃ (r : ℝ), x.is_st r	⊢ x.is_st (classical.some h)		x : ℝ*,	hx : x.st ≠ 0,	h : ¬∃ (r : ℝ), x.is_st r	⊢ x.is_st 0", "decl_nm": "hyperreal.is_st_st"
{"src": "x : ℝ*,	hx : x.st ≠ 0,	h : ¬∃ (r : ℝ), x.is_st r	⊢ x.is_st 0", "decl_nm": "hyperreal.is_st_st"
{"src": "⊢ ∀ (q : ℚ) {x : ℝ}, irrational x → irrational (↑q - x)", "decl_nm": "irrational.rat_sub"
{"src": "q : ℚ,	x : ℝ,	h : irrational x	⊢ irrational (↑q - x)", "decl_nm": "irrational.rat_sub"
{"src": "⊢ ∀ {r p : ℝ}, r.to_nnreal < p.to_nnreal ↔ r < p ∧ 0 < p", "decl_nm": "real.to_nnreal_lt_to_nnreal_iff'"
{"src": "r p : ℝ	⊢ r.to_nnreal < p.to_nnreal ↔ r < p ∧ 0 < p", "decl_nm": "real.to_nnreal_lt_to_nnreal_iff'"
{"src": "⊢ ∀ {a b r : nnreal}, r ≠ 0 → (a ≤ b / r ↔ a * r ≤ b)", "decl_nm": "nnreal.le_div_iff_mul_le"
{"src": "a b r : nnreal,	hr : r ≠ 0	⊢ a ≤ b / r ↔ a * r ≤ b", "decl_nm": "nnreal.le_div_iff_mul_le"
{"src": "⊢ ∀ (r : ℝ), r ≠ 0 → 0 < r.sign * r", "decl_nm": "real.sign_mul_pos_of_ne_zero"
{"src": "r : ℝ,	hr : r ≠ 0	⊢ 0 < r.sign * r", "decl_nm": "real.sign_mul_pos_of_ne_zero"
{"src": "r : ℝ,	hr : r ≠ 0,	h : 0 = r.sign * r	⊢ r = 0", "decl_nm": "real.sign_mul_pos_of_ne_zero"
{"src": "r : ℝ,	hr : r ≠ 0,	h : 0 = r.sign * r,	hs0 : r.sign = 0	⊢ r = 0", "decl_nm": "real.sign_mul_pos_of_ne_zero"
{"src": "⊢ sqrt 1 = 1", "decl_nm": "real.sqrt_one"
{"src": "⊢ ∀ {α : Type u_1} {β : Type u_2} (r : rel α β), r.inv.dom = r.codom", "decl_nm": "rel.dom_inv"
{"src": "α : Type u_1,	β : Type u_2,	r : rel α β	⊢ r.inv.dom = r.codom", "decl_nm": "rel.dom_inv"
{"src": "α : Type u_1,	β : Type u_2,	r : rel α β,	x : β	⊢ x ∈ r.inv.dom ↔ x ∈ r.codom", "decl_nm": "rel.dom_inv"
{"src": "⊢ ∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {δ : Type u_4} (r : rel α β) (s : rel β γ) (t : rel γ δ),	    (r.comp s).comp t = r.comp (s.comp t)", "decl_nm": "rel.comp_assoc"
{"src": "α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	r : rel α β,	s : rel β γ,	t : rel γ δ	⊢ (r.comp s).comp t = r.comp (s.comp t)", "decl_nm": "rel.comp_assoc"
{"src": "α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	r : rel α β,	s : rel β γ,	t : rel γ δ	⊢ (λ (x : α) (z : δ), ∃ (y : γ), (∃ (y_1 : β), r x y_1 ∧ s y_1 y) ∧ t y z) =	    λ (x : α) (z : δ), ∃ (y : β), r x y ∧ ∃ (y_1 : γ), s y y_1 ∧ t y_1 z", "decl_nm": "rel.comp_assoc"
{"src": "α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	r : rel α β,	s : rel β γ,	t : rel γ δ,	x : α,	w : δ	⊢ (∃ (y : γ), (∃ (y_1 : β), r x y_1 ∧ s y_1 y) ∧ t y w) ↔	    ∃ (y : β), r x y ∧ ∃ (y_1 : γ), s y y_1 ∧ t y_1 w", "decl_nm": "rel.comp_assoc"
{"src": "2 goals	α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	r : rel α β,	s : rel β γ,	t : rel γ δ,	x : α,	w : δ	⊢ (∃ (y : γ), (∃ (y_1 : β), r x y_1 ∧ s y_1 y) ∧ t y w) →	  (∃ (y : β), r x y ∧ ∃ (y_1 : γ), s y y_1 ∧ t y_1 w)		α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	r : rel α β,	s : rel β γ,	t : rel γ δ,	x : α,	w : δ	⊢ (∃ (y : β), r x y ∧ ∃ (y_1 : γ), s y y_1 ∧ t y_1 w) →	  (∃ (y : γ), (∃ (y_1 : β), r x y_1 ∧ s y_1 y) ∧ t y w)", "decl_nm": "rel.comp_assoc"
{"src": "2 goals	α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	r : rel α β,	s : rel β γ,	t : rel γ δ,	x : α,	w : δ,	z : γ,	tzw : t z w,	y : β,	rxy : r x y,	syz : s y z	⊢ ∃ (y : β), r x y ∧ ∃ (y_1 : γ), s y y_1 ∧ t y_1 w		α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	r : rel α β,	s : rel β γ,	t : rel γ δ,	x : α,	w : δ	⊢ (∃ (y : β), r x y ∧ ∃ (y_1 : γ), s y y_1 ∧ t y_1 w) →	  (∃ (y : γ), (∃ (y_1 : β), r x y_1 ∧ s y_1 y) ∧ t y w)", "decl_nm": "rel.comp_assoc"
{"src": "α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	r : rel α β,	s : rel β γ,	t : rel γ δ,	x : α,	w : δ	⊢ (∃ (y : β), r x y ∧ ∃ (y_1 : γ), s y y_1 ∧ t y_1 w) →	  (∃ (y : γ), (∃ (y_1 : β), r x y_1 ∧ s y_1 y) ∧ t y w)", "decl_nm": "rel.comp_assoc"
{"src": "α : Type u_1,	β : Type u_2,	γ : Type u_3,	δ : Type u_4,	r : rel α β,	s : rel β γ,	t : rel γ δ,	x : α,	w : δ,	y : β,	rxy : r x y,	z : γ,	syz : s y z,	tzw : t z w	⊢ ∃ (y : γ), (∃ (y_1 : β), r x y_1 ∧ s y_1 y) ∧ t y w", "decl_nm": "rel.comp_assoc"
{"src": "⊢ ∀ {α : Type u} {s : computation α}, ¬s.terminates → s = empty α", "decl_nm": "computation.eq_empty_of_not_terminates"
{"src": "α : Type u,	s : computation α,	H : ¬s.terminates	⊢ s = empty α", "decl_nm": "computation.eq_empty_of_not_terminates"
{"src": "α : Type u,	s : computation α,	H : ¬s.terminates	⊢ s.val = (empty α).val", "decl_nm": "computation.eq_empty_of_not_terminates"
{"src": "α : Type u,	s : computation α,	H : ¬s.terminates,	n : ℕ	⊢ s.val n = (empty α).val n", "decl_nm": "computation.eq_empty_of_not_terminates"
{"src": "2 goals	case option.none	α : Type u,	s : computation α,	H : ¬s.terminates,	n : ℕ,	h : s.val n = none	⊢ none = (empty α).val n		case option.some	α : Type u,	s : computation α,	H : ¬s.terminates,	n : ℕ,	val : α,	h : s.val n = some val	⊢ some val = (empty α).val n", "decl_nm": "computation.eq_empty_of_not_terminates"
{"src": "case option.some	α : Type u,	s : computation α,	H : ¬s.terminates,	n : ℕ,	val : α,	h : s.val n = some val	⊢ some val = (empty α).val n", "decl_nm": "computation.eq_empty_of_not_terminates"
{"src": "α : Type u,	s : computation α,	H : ¬s.terminates,	n : ℕ,	val : α,	h : s.val n = some val	⊢ s.terminates", "decl_nm": "computation.eq_empty_of_not_terminates"
{"src": "⊢ ∀ {α : Type u} (a : α) (s : stream α), of_stream (a::s) = cons a (of_stream s)", "decl_nm": "seq.of_stream_cons"
{"src": "α : Type u,	a : α,	s : stream α	⊢ of_stream (a::s) = cons a (of_stream s)", "decl_nm": "seq.of_stream_cons"
{"src": "α : Type u,	a : α,	s : stream α	⊢ (of_stream (a::s)).val = (cons a (of_stream s)).val", "decl_nm": "seq.of_stream_cons"
{"src": "α : Type u,	a : α,	s : stream α	⊢ stream.map some (a::s) = some a::stream.map some s", "decl_nm": "seq.of_stream_cons"
{"src": "⊢ ∀ {α : Type u} {β : Type v} (R : α → β → Prop), lift_rel R nil nil", "decl_nm": "wseq.lift_rel_nil"
{"src": "α : Type u,	β : Type v,	R : α → β → Prop	⊢ lift_rel R nil nil", "decl_nm": "wseq.lift_rel_nil"
{"src": "α : Type u,	β : Type v,	R : α → β → Prop	⊢ lift_rel (lift_rel_o R (lift_rel R)) nil.destruct nil.destruct", "decl_nm": "wseq.lift_rel_nil"
{"src": "⊢ ∀ {α : Type u} {β : Type v} (R : α → β → Prop) (s : wseq α) (t : wseq β),	    lift_rel R s.think t ↔ lift_rel R s t", "decl_nm": "wseq.lift_rel_think_left"
{"src": "α : Type u,	β : Type v,	R : α → β → Prop,	s : wseq α,	t : wseq β	⊢ lift_rel R s.think t ↔ lift_rel R s t", "decl_nm": "wseq.lift_rel_think_left"
{"src": "α : Type u,	β : Type v,	R : α → β → Prop,	s : wseq α,	t : wseq β	⊢ lift_rel (lift_rel_o R (lift_rel R)) s.think.destruct t.destruct ↔	    lift_rel (lift_rel_o R (lift_rel R)) s.destruct t.destruct", "decl_nm": "wseq.lift_rel_think_left"
{"src": "⊢ ∀ {α : Type u_1}, diagonal α = range (λ (x : α), (x, x))", "decl_nm": "set.diagonal_eq_range"
{"src": "α : Type u_1	⊢ diagonal α = range (λ (x : α), (x, x))", "decl_nm": "set.diagonal_eq_range"
{"src": "α : Type u_1,	x y : α	⊢ (x, y) ∈ diagonal α ↔ (x, y) ∈ range (λ (x : α), (x, x))", "decl_nm": "set.diagonal_eq_range"
{"src": "⊢ ∀ {ι : Type u_1} {α : ι → Type u_2} {p : ι → Prop} [h : decidable_pred p] (s : set ι)	  (t₁ t₂ : Π (i : ι), set (α i)),	    s.pi (λ (i : ι), ite (p i) (t₁ i) (t₂ i)) = {i ∈ s | p i}.pi t₁ ∩ {i ∈ s | ¬p i}.pi t₂", "decl_nm": "set.pi_if"
{"src": "ι : Type u_1,	α : ι → Type u_2,	p : ι → Prop,	h : decidable_pred p,	s : set ι,	t₁ t₂ : Π (i : ι), set (α i)	⊢ s.pi (λ (i : ι), ite (p i) (t₁ i) (t₂ i)) = {i ∈ s | p i}.pi t₁ ∩ {i ∈ s | ¬p i}.pi t₂", "decl_nm": "set.pi_if"
{"src": "ι : Type u_1,	α : ι → Type u_2,	p : ι → Prop,	h : decidable_pred p,	s : set ι,	t₁ t₂ : Π (i : ι), set (α i),	f : Π (i : ι), (λ (i : ι), α i) i	⊢ f ∈ s.pi (λ (i : ι), ite (p i) (t₁ i) (t₂ i)) ↔	    f ∈ {i ∈ s | p i}.pi t₁ ∩ {i ∈ s | ¬p i}.pi t₂", "decl_nm": "set.pi_if"
{"src": "2 goals	ι : Type u_1,	α : ι → Type u_2,	p : ι → Prop,	h : decidable_pred p,	s : set ι,	t₁ t₂ : Π (i : ι), set (α i),	f : Π (i : ι), (λ (i : ι), α i) i	⊢ f ∈ s.pi (λ (i : ι), ite (p i) (t₁ i) (t₂ i)) →	  f ∈ {i ∈ s | p i}.pi t₁ ∩ {i ∈ s | ¬p i}.pi t₂		ι : Type u_1,	α : ι → Type u_2,	p : ι → Prop,	h : decidable_pred p,	s : set ι,	t₁ t₂ : Π (i : ι), set (α i),	f : Π (i : ι), (λ (i : ι), α i) i	⊢ f ∈ {i ∈ s | p i}.pi t₁ ∩ {i ∈ s | ¬p i}.pi t₂ →	  f ∈ s.pi (λ (i : ι), ite (p i) (t₁ i) (t₂ i))", "decl_nm": "set.pi_if"
{"src": "2 goals	ι : Type u_1,	α : ι → Type u_2,	p : ι → Prop,	h : decidable_pred p,	s : set ι,	t₁ t₂ : Π (i : ι), set (α i),	f : Π (i : ι), (λ (i : ι), α i) i,	h : f ∈ s.pi (λ (i : ι), ite (p i) (t₁ i) (t₂ i))	⊢ f ∈ {i ∈ s | p i}.pi t₁ ∩ {i ∈ s | ¬p i}.pi t₂		ι : Type u_1,	α : ι → Type u_2,	p : ι → Prop,	h : decidable_pred p,	s : set ι,	t₁ t₂ : Π (i : ι), set (α i),	f : Π (i : ι), (λ (i : ι), α i) i	⊢ f ∈ {i ∈ s | p i}.pi t₁ ∩ {i ∈ s | ¬p i}.pi t₂ →	  f ∈ s.pi (λ (i : ι), ite (p i) (t₁ i) (t₂ i))", "decl_nm": "set.pi_if"
{"src": "3 goals	ι : Type u_1,	α : ι → Type u_2,	p : ι → Prop,	h : decidable_pred p,	s : set ι,	t₁ t₂ : Π (i : ι), set (α i),	f : Π (i : ι), (λ (i : ι), α i) i,	h : f ∈ s.pi (λ (i : ι), ite (p i) (t₁ i) (t₂ i))	⊢ f ∈ {i ∈ s | p i}.pi t₁		ι : Type u_1,	α : ι → Type u_2,	p : ι → Prop,	h : decidable_pred p,	s : set ι,	t₁ t₂ : Π (i : ι), set (α i),	f : Π (i : ι), (λ (i : ι), α i) i,	h : f ∈ s.pi (λ (i : ι), ite (p i) (t₁ i) (t₂ i))	⊢ f ∈ {i ∈ s | ¬p i}.pi t₂		ι : Type u_1,	α : ι → Type u_2,	p : ι → Prop,	h : decidable_pred p,	s : set ι,	t₁ t₂ : Π (i : ι), set (α i),	f : Π (i : ι), (λ (i : ι), α i) i	⊢ f ∈ {i ∈ s | p i}.pi t₁ ∩ {i ∈ s | ¬p i}.pi t₂ →	  f ∈ s.pi (λ (i : ι), ite (p i) (t₁ i) (t₂ i))", "decl_nm": "set.pi_if"
{"src": "2 goals	ι : Type u_1,	α : ι → Type u_2,	p : ι → Prop,	h : decidable_pred p,	s : set ι,	t₁ t₂ : Π (i : ι), set (α i),	f : Π (i : ι), (λ (i : ι), α i) i,	h : f ∈ s.pi (λ (i : ι), ite (p i) (t₁ i) (t₂ i))	⊢ f ∈ {i ∈ s | ¬p i}.pi t₂		ι : Type u_1,	α : ι → Type u_2,	p : ι → Prop,	h : decidable_pred p,	s : set ι,	t₁ t₂ : Π (i : ι), set (α i),	f : Π (i : ι), (λ (i : ι), α i) i	⊢ f ∈ {i ∈ s | p i}.pi t₁ ∩ {i ∈ s | ¬p i}.pi t₂ →	  f ∈ s.pi (λ (i : ι), ite (p i) (t₁ i) (t₂ i))", "decl_nm": "set.pi_if"
{"src": "2 goals	ι : Type u_1,	α : ι → Type u_2,	p : ι → Prop,	h : decidable_pred p,	s : set ι,	t₁ t₂ : Π (i : ι), set (α i),	f : Π (i : ι), (λ (i : ι), α i) i,	h : f ∈ s.pi (λ (i : ι), ite (p i) (t₁ i) (t₂ i)),	i : ι,	his : i ∈ s,	hpi : ¬p i	⊢ f i ∈ t₂ i		ι : Type u_1,	α : ι → Type u_2,	p : ι → Prop,	h : decidable_pred p,	s : set ι,	t₁ t₂ : Π (i : ι), set (α i),	f : Π (i : ι), (λ (i : ι), α i) i	⊢ f ∈ {i ∈ s | p i}.pi t₁ ∩ {i ∈ s | ¬p i}.pi t₂ →	  f ∈ s.pi (λ (i : ι), ite (p i) (t₁ i) (t₂ i))", "decl_nm": "set.pi_if"
{"src": "ι : Type u_1,	α : ι → Type u_2,	p : ι → Prop,	h : decidable_pred p,	s : set ι,	t₁ t₂ : Π (i : ι), set (α i),	f : Π (i : ι), (λ (i : ι), α i) i	⊢ f ∈ {i ∈ s | p i}.pi t₁ ∩ {i ∈ s | ¬p i}.pi t₂ →	  f ∈ s.pi (λ (i : ι), ite (p i) (t₁ i) (t₂ i))", "decl_nm": "set.pi_if"
{"src": "ι : Type u_1,	α : ι → Type u_2,	p : ι → Prop,	h : decidable_pred p,	s : set ι,	t₁ t₂ : Π (i : ι), set (α i),	f : Π (i : ι), (λ (i : ι), α i) i,	i : ι,	his : i ∈ s,	ht₁ : f ∈ {i ∈ s | p i}.pi t₁,	ht₂ : f ∈ {i ∈ s | ¬p i}.pi t₂	⊢ f i ∈ (λ (i : ι), ite (p i) (t₁ i) (t₂ i)) i", "decl_nm": "set.pi_if"
{"src": "2 goals	ι : Type u_1,	α : ι → Type u_2,	p : ι → Prop,	h : decidable_pred p,	s : set ι,	t₁ t₂ : Π (i : ι), set (α i),	f : Π (i : ι), (λ (i : ι), α i) i,	i : ι,	his : i ∈ s,	ht₁ : f ∈ {i ∈ s | p i}.pi t₁,	ht₂ : f ∈ {i ∈ s | ¬p i}.pi t₂,	h : p i	⊢ f i ∈ (λ (i : ι), ite (p i) (t₁ i) (t₂ i)) i		ι : Type u_1,	α : ι → Type u_2,	p : ι → Prop,	h : decidable_pred p,	s : set ι,	t₁ t₂ : Π (i : ι), set (α i),	f : Π (i : ι), (λ (i : ι), α i) i,	i : ι,	his : i ∈ s,	ht₁ : f ∈ {i ∈ s | p i}.pi t₁,	ht₂ : f ∈ {i ∈ s | ¬p i}.pi t₂,	h : ¬p i	⊢ f i ∈ (λ (i : ι), ite (p i) (t₁ i) (t₂ i)) i", "decl_nm": "set.pi_if"
{"src": "ι : Type u_1,	α : ι → Type u_2,	p : ι → Prop,	h : decidable_pred p,	s : set ι,	t₁ t₂ : Π (i : ι), set (α i),	f : Π (i : ι), (λ (i : ι), α i) i,	i : ι,	his : i ∈ s,	ht₁ : f ∈ {i ∈ s | p i}.pi t₁,	ht₂ : f ∈ {i ∈ s | ¬p i}.pi t₂,	h : ¬p i	⊢ f i ∈ (λ (i : ι), ite (p i) (t₁ i) (t₂ i)) i", "decl_nm": "set.pi_if"
{"src": "⊢ ∀ {ι : Type u_1} {α : ι → Type u_2} {s : set ι} {t : Π (i : ι), set (α i)} {i : ι}	  [_inst_1 : decidable_eq ι] {f : Π (i : ι), α i},	    i ∈ s → (∀ (j : ι), j ∈ s → j ≠ i → f j ∈ t j) → update f i ⁻¹' s.pi t = t i", "decl_nm": "set.update_preimage_pi"
{"src": "ι : Type u_1,	α : ι → Type u_2,	s : set ι,	t : Π (i : ι), set (α i),	i : ι,	_inst_1 : decidable_eq ι,	f : Π (i : ι), α i,	hi : i ∈ s,	hf : ∀ (j : ι), j ∈ s → j ≠ i → f j ∈ t j	⊢ update f i ⁻¹' s.pi t = t i", "decl_nm": "set.update_preimage_pi"
{"src": "ι : Type u_1,	α : ι → Type u_2,	s : set ι,	t : Π (i : ι), set (α i),	i : ι,	_inst_1 : decidable_eq ι,	f : Π (i : ι), α i,	hi : i ∈ s,	hf : ∀ (j : ι), j ∈ s → j ≠ i → f j ∈ t j,	x : α i	⊢ x ∈ update f i ⁻¹' s.pi t ↔ x ∈ t i", "decl_nm": "set.update_preimage_pi"
{"src": "2 goals	ι : Type u_1,	α : ι → Type u_2,	s : set ι,	t : Π (i : ι), set (α i),	i : ι,	_inst_1 : decidable_eq ι,	f : Π (i : ι), α i,	hi : i ∈ s,	hf : ∀ (j : ι), j ∈ s → j ≠ i → f j ∈ t j,	x : α i	⊢ x ∈ update f i ⁻¹' s.pi t → x ∈ t i		ι : Type u_1,	α : ι → Type u_2,	s : set ι,	t : Π (i : ι), set (α i),	i : ι,	_inst_1 : decidable_eq ι,	f : Π (i : ι), α i,	hi : i ∈ s,	hf : ∀ (j : ι), j ∈ s → j ≠ i → f j ∈ t j,	x : α i	⊢ x ∈ t i → x ∈ update f i ⁻¹' s.pi t", "decl_nm": "set.update_preimage_pi"
{"src": "2 goals	ι : Type u_1,	α : ι → Type u_2,	s : set ι,	t : Π (i : ι), set (α i),	i : ι,	_inst_1 : decidable_eq ι,	f : Π (i : ι), α i,	hi : i ∈ s,	hf : ∀ (j : ι), j ∈ s → j ≠ i → f j ∈ t j,	x : α i,	h : x ∈ update f i ⁻¹' s.pi t	⊢ x ∈ t i		ι : Type u_1,	α : ι → Type u_2,	s : set ι,	t : Π (i : ι), set (α i),	i : ι,	_inst_1 : decidable_eq ι,	f : Π (i : ι), α i,	hi : i ∈ s,	hf : ∀ (j : ι), j ∈ s → j ≠ i → f j ∈ t j,	x : α i	⊢ x ∈ t i → x ∈ update f i ⁻¹' s.pi t", "decl_nm": "set.update_preimage_pi"
{"src": "2 goals	ι : Type u_1,	α : ι → Type u_2,	s : set ι,	t : Π (i : ι), set (α i),	i : ι,	_inst_1 : decidable_eq ι,	f : Π (i : ι), α i,	hi : i ∈ s,	hf : ∀ (j : ι), j ∈ s → j ≠ i → f j ∈ t j,	x : α i,	h : x ∈ update f i ⁻¹' s.pi t	⊢ x = update f i x i		ι : Type u_1,	α : ι → Type u_2,	s : set ι,	t : Π (i : ι), set (α i),	i : ι,	_inst_1 : decidable_eq ι,	f : Π (i : ι), α i,	hi : i ∈ s,	hf : ∀ (j : ι), j ∈ s → j ≠ i → f j ∈ t j,	x : α i	⊢ x ∈ t i → x ∈ update f i ⁻¹' s.pi t", "decl_nm": "set.update_preimage_pi"
{"src": "ι : Type u_1,	α : ι → Type u_2,	s : set ι,	t : Π (i : ι), set (α i),	i : ι,	_inst_1 : decidable_eq ι,	f : Π (i : ι), α i,	hi : i ∈ s,	hf : ∀ (j : ι), j ∈ s → j ≠ i → f j ∈ t j,	x : α i	⊢ x ∈ t i → x ∈ update f i ⁻¹' s.pi t", "decl_nm": "set.update_preimage_pi"
{"src": "ι : Type u_1,	α : ι → Type u_2,	s : set ι,	t : Π (i : ι), set (α i),	i : ι,	_inst_1 : decidable_eq ι,	f : Π (i : ι), α i,	hi : i ∈ s,	hf : ∀ (j : ι), j ∈ s → j ≠ i → f j ∈ t j,	x : α i,	hx : x ∈ t i,	j : ι,	hj : j ∈ s	⊢ update f i x j ∈ t j", "decl_nm": "set.update_preimage_pi"
{"src": "2 goals	ι : Type u_1,	α : ι → Type u_2,	s : set ι,	t : Π (i : ι), set (α i),	i : ι,	_inst_1 : decidable_eq ι,	f : Π (i : ι), α i,	hi : i ∈ s,	hf : ∀ (j : ι), j ∈ s → j ≠ i → f j ∈ t j,	x : α i,	hx : x ∈ t i,	j : ι,	hj : j ∈ s,	h : j = i	⊢ update f i x j ∈ t j		ι : Type u_1,	α : ι → Type u_2,	s : set ι,	t : Π (i : ι), set (α i),	i : ι,	_inst_1 : decidable_eq ι,	f : Π (i : ι), α i,	hi : i ∈ s,	hf : ∀ (j : ι), j ∈ s → j ≠ i → f j ∈ t j,	x : α i,	hx : x ∈ t i,	j : ι,	hj : j ∈ s,	h : ¬j = i	⊢ update f i x j ∈ t j", "decl_nm": "set.update_preimage_pi"
{"src": "2 goals	ι : Type u_1,	α : ι → Type u_2,	s : set ι,	t : Π (i : ι), set (α i),	i : ι,	_inst_1 : decidable_eq ι,	f : Π (i : ι), α i,	hi : i ∈ s,	hf : ∀ (j : ι), j ∈ s → j ≠ i → f j ∈ t j,	x : α i,	hx : x ∈ t i,	hj : i ∈ s,	h : i = i	⊢ update f i x i ∈ t i		ι : Type u_1,	α : ι → Type u_2,	s : set ι,	t : Π (i : ι), set (α i),	i : ι,	_inst_1 : decidable_eq ι,	f : Π (i : ι), α i,	hi : i ∈ s,	hf : ∀ (j : ι), j ∈ s → j ≠ i → f j ∈ t j,	x : α i,	hx : x ∈ t i,	j : ι,	hj : j ∈ s,	h : ¬j = i	⊢ update f i x j ∈ t j", "decl_nm": "set.update_preimage_pi"
{"src": "ι : Type u_1,	α : ι → Type u_2,	s : set ι,	t : Π (i : ι), set (α i),	i : ι,	_inst_1 : decidable_eq ι,	f : Π (i : ι), α i,	hi : i ∈ s,	hf : ∀ (j : ι), j ∈ s → j ≠ i → f j ∈ t j,	x : α i,	hx : x ∈ t i,	j : ι,	hj : j ∈ s,	h : ¬j = i	⊢ update f i x j ∈ t j", "decl_nm": "set.update_preimage_pi"
{"src": "ι : Type u_1,	α : ι → Type u_2,	s : set ι,	t : Π (i : ι), set (α i),	i : ι,	_inst_1 : decidable_eq ι,	f : Π (i : ι), α i,	hi : i ∈ s,	hf : ∀ (j : ι), j ∈ s → j ≠ i → f j ∈ t j,	x : α i,	hx : x ∈ t i,	j : ι,	hj : j ∈ s,	h : ¬j = i	⊢ f j ∈ t j", "decl_nm": "set.update_preimage_pi"
{"src": "⊢ ∀ {α : Type u} {β : Type v} {f : α → β}, injective (preimage f) ↔ surjective f", "decl_nm": "set.preimage_injective"
{"src": "α : Type u,	β : Type v,	f : α → β	⊢ injective (preimage f) ↔ surjective f", "decl_nm": "set.preimage_injective"
{"src": "α : Type u,	β : Type v,	f : α → β,	h : injective (preimage f),	y : β	⊢ ∃ (a : α), f a = y", "decl_nm": "set.preimage_injective"
{"src": "2 goals	α : Type u,	β : Type v,	f : α → β,	h : injective (preimage f),	y : β	⊢ (f ⁻¹' {y}).nonempty		α : Type u,	β : Type v,	f : α → β,	h : injective (preimage f),	y : β,	x : α,	hx : x ∈ f ⁻¹' {y}	⊢ ∃ (a : α), f a = y", "decl_nm": "set.preimage_injective"
{"src": "2 goals	α : Type u,	β : Type v,	f : α → β,	h : injective (preimage f),	y : β	⊢ {y}.nonempty		α : Type u,	β : Type v,	f : α → β,	h : injective (preimage f),	y : β,	x : α,	hx : x ∈ f ⁻¹' {y}	⊢ ∃ (a : α), f a = y", "decl_nm": "set.preimage_injective"
{"src": "α : Type u,	β : Type v,	f : α → β,	h : injective (preimage f),	y : β,	x : α,	hx : x ∈ f ⁻¹' {y}	⊢ ∃ (a : α), f a = y", "decl_nm": "set.preimage_injective"
{"src": "⊢ ∀ {α : Type u} {s : set α} {x : α}, s ⊂ {x} ↔ s = ∅", "decl_nm": "set.ssubset_singleton_iff"
{"src": "α : Type u,	s : set α,	x : α	⊢ s ⊂ {x} ↔ s = ∅", "decl_nm": "set.ssubset_singleton_iff"
{"src": "α : Type u,	s : set α,	x : α	⊢ s = ∅ → s ≠ {x}", "decl_nm": "set.ssubset_singleton_iff"
{"src": "α : Type u,	x : α	⊢ ∅ ≠ {x}", "decl_nm": "set.ssubset_singleton_iff"
{"src": "⊢ ∀ {α : Type u} {a : α} (s : set α) [_inst_1 : fintype ↥s] (h : a ∉ s),	    fintype.card ↥(insert a s) = fintype.card ↥s + 1", "decl_nm": "set.card_fintype_insert'"
{"src": "α : Type u,	a : α,	s : set α,	_inst_1 : fintype ↥s,	h : a ∉ s	⊢ fintype.card ↥(insert a s) = fintype.card ↥s + 1", "decl_nm": "set.card_fintype_insert'"
{"src": "α : Type u,	a : α,	s : set α,	_inst_1 : fintype ↥s,	h : a ∉ s	⊢ {val := a ::ₘ s.to_finset.val, nodup := _}.card = fintype.card ↥s + 1", "decl_nm": "set.card_fintype_insert'"
{"src": "α : Type u,	a : α,	s : set α,	_inst_1 : fintype ↥s,	h : a ∉ s	⊢ ⇑multiset.card finset.univ.val = fintype.card ↥s", "decl_nm": "set.card_fintype_insert'"
{"src": "⊢ ∀ {α : Type u} {ι : Sort w} (f : ι → α) [_inst_1 : fintype (plift ι)], (range f).finite", "decl_nm": "set.finite_range"
{"src": "α : Type u,	ι : Sort w,	f : ι → α,	_inst_1 : fintype (plift ι)	⊢ (range f).finite", "decl_nm": "set.finite_range"
{"src": "α : Type u,	ι : Sort w,	f : ι → α,	_inst_1 : fintype (plift ι),	_inst : decidable_eq α	⊢ (range f).finite", "decl_nm": "set.finite_range"
{"src": "⊢ ∀ {α : Type u} {s : set α} (h : s.finite), ↥(h.to_finset) = ↥s", "decl_nm": "set.finite.coe_sort_to_finset"
{"src": "α : Type u,	s : set α,	h : s.finite	⊢ ↥(h.to_finset) = ↥s", "decl_nm": "set.finite.coe_sort_to_finset"
{"src": "⊢ ∀ {α : Type u} {P : α → ℕ → Prop} [_inst_1 : Π (x : α), decidable_pred (P x)] {b : ℕ},	    range (λ (x : α), nat.find_greatest (P x) b) ⊆ ↑(finset.range (b + 1))", "decl_nm": "set.range_find_greatest_subset"
{"src": "α : Type u,	P : α → ℕ → Prop,	_inst_1 : Π (x : α), decidable_pred (P x),	b : ℕ	⊢ range (λ (x : α), nat.find_greatest (P x) b) ⊆ ↑(finset.range (b + 1))", "decl_nm": "set.range_find_greatest_subset"
{"src": "α : Type u,	P : α → ℕ → Prop,	_inst_1 : Π (x : α), decidable_pred (P x),	b : ℕ	⊢ ∀ (y : α), nat.find_greatest (P y) b ∈ ↑(finset.range (b + 1))", "decl_nm": "set.range_find_greatest_subset"
{"src": "α : Type u,	P : α → ℕ → Prop,	_inst_1 : Π (x : α), decidable_pred (P x),	b : ℕ,	x : α	⊢ nat.find_greatest (P x) b ∈ ↑(finset.range (b + 1))", "decl_nm": "set.range_find_greatest_subset"
{"src": "⊢ ∀ {α : Type u} [_inst_1 : linear_order α] {a b c : α}, Ioc a c ∪ Ioc b c = Ioc (min a b) c", "decl_nm": "set.Ioc_union_Ioc_left"
{"src": "α : Type u,	_inst_1 : linear_order α,	a b c : α	⊢ Ioc a c ∪ Ioc b c = Ioc (min a b) c", "decl_nm": "set.Ioc_union_Ioc_left"
{"src": "2 goals	α : Type u,	_inst_1 : linear_order α,	a b c : α	⊢ min a c ≤ max b c		α : Type u,	_inst_1 : linear_order α,	a b c : α	⊢ min b c ≤ max a c", "decl_nm": "set.Ioc_union_Ioc_left"
{"src": "α : Type u,	_inst_1 : linear_order α,	a b c : α	⊢ min b c ≤ max a c", "decl_nm": "set.Ioc_union_Ioc_left"
{"src": "⊢ ∀ {α : Type u} [_inst_1 : partial_order α] {a b : α} {s : set α},	    Ioo a b ⊆ s → s ⊆ Icc a b → s ∈ {Icc a b, Ico a b, Ioc a b, Ioo a b}", "decl_nm": "set.mem_Icc_Ico_Ioc_Ioo_of_subset_of_subset"
{"src": "α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : Ioo a b ⊆ s,	hc : s ⊆ Icc a b	⊢ s ∈ {Icc a b, Ico a b, Ioc a b, Ioo a b}", "decl_nm": "set.mem_Icc_Ico_Ioc_Ioo_of_subset_of_subset"
{"src": "α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : Ioo a b ⊆ s,	hc : s ⊆ Icc a b,	_inst : Π (a : Prop), decidable a	⊢ s ∈ {Icc a b, Ico a b, Ioc a b, Ioo a b}", "decl_nm": "set.mem_Icc_Ico_Ioc_Ioo_of_subset_of_subset"
{"src": "2 goals	α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : Ioo a b ⊆ s,	hc : s ⊆ Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∈ s	⊢ s ∈ {Icc a b, Ico a b, Ioc a b, Ioo a b}		α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : Ioo a b ⊆ s,	hc : s ⊆ Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∉ s	⊢ s ∈ {Icc a b, Ico a b, Ioc a b, Ioo a b}", "decl_nm": "set.mem_Icc_Ico_Ioc_Ioo_of_subset_of_subset"
{"src": "3 goals	α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : Ioo a b ⊆ s,	hc : s ⊆ Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∈ s,	hb : b ∈ s	⊢ s ∈ {Icc a b, Ico a b, Ioc a b, Ioo a b}		α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : Ioo a b ⊆ s,	hc : s ⊆ Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∈ s,	hb : b ∉ s	⊢ s ∈ {Icc a b, Ico a b, Ioc a b, Ioo a b}		α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : Ioo a b ⊆ s,	hc : s ⊆ Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∉ s	⊢ s ∈ {Icc a b, Ico a b, Ioc a b, Ioo a b}", "decl_nm": "set.mem_Icc_Ico_Ioc_Ioo_of_subset_of_subset"
{"src": "3 goals	α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : Ioo a b ⊆ s,	hc : s ⊆ Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∈ s,	hb : b ∈ s	⊢ Icc a b ⊆ s		α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : Ioo a b ⊆ s,	hc : s ⊆ Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∈ s,	hb : b ∉ s	⊢ s ∈ {Icc a b, Ico a b, Ioc a b, Ioo a b}		α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : Ioo a b ⊆ s,	hc : s ⊆ Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∉ s	⊢ s ∈ {Icc a b, Ico a b, Ioc a b, Ioo a b}", "decl_nm": "set.mem_Icc_Ico_Ioc_Ioo_of_subset_of_subset"
{"src": "2 goals	α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : Ioo a b ⊆ s,	hc : s ⊆ Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∈ s,	hb : b ∉ s	⊢ s ∈ {Icc a b, Ico a b, Ioc a b, Ioo a b}		α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : Ioo a b ⊆ s,	hc : s ⊆ Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∉ s	⊢ s ∈ {Icc a b, Ico a b, Ioc a b, Ioo a b}", "decl_nm": "set.mem_Icc_Ico_Ioc_Ioo_of_subset_of_subset"
{"src": "3 goals	α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : Ioo a b ⊆ s,	hc : s ⊆ Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∈ s,	hb : b ∉ s	⊢ s ⊆ Ico a b		α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : Ioo a b ⊆ s,	hc : s ⊆ Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∈ s,	hb : b ∉ s	⊢ Ico a b ⊆ s		α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : Ioo a b ⊆ s,	hc : s ⊆ Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∉ s	⊢ s ∈ {Icc a b, Ico a b, Ioc a b, Ioo a b}", "decl_nm": "set.mem_Icc_Ico_Ioc_Ioo_of_subset_of_subset"
{"src": "3 goals	α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : Ioo a b ⊆ s,	hc : s ⊆ Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∈ s,	hb : b ∉ s	⊢ s ⊆ Icc a b \ {b}		α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : Ioo a b ⊆ s,	hc : s ⊆ Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∈ s,	hb : b ∉ s	⊢ Ico a b ⊆ s		α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : Ioo a b ⊆ s,	hc : s ⊆ Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∉ s	⊢ s ∈ {Icc a b, Ico a b, Ioc a b, Ioo a b}", "decl_nm": "set.mem_Icc_Ico_Ioc_Ioo_of_subset_of_subset"
{"src": "2 goals	α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : Ioo a b ⊆ s,	hc : s ⊆ Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∈ s,	hb : b ∉ s	⊢ Ico a b ⊆ s		α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : Ioo a b ⊆ s,	hc : s ⊆ Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∉ s	⊢ s ∈ {Icc a b, Ico a b, Ioc a b, Ioo a b}", "decl_nm": "set.mem_Icc_Ico_Ioc_Ioo_of_subset_of_subset"
{"src": "α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : Ioo a b ⊆ s,	hc : s ⊆ Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∉ s	⊢ s ∈ {Icc a b, Ico a b, Ioc a b, Ioo a b}", "decl_nm": "set.mem_Icc_Ico_Ioc_Ioo_of_subset_of_subset"
{"src": "2 goals	α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : Ioo a b ⊆ s,	hc : s ⊆ Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∉ s,	hb : b ∈ s	⊢ s ∈ {Icc a b, Ico a b, Ioc a b, Ioo a b}		α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : Ioo a b ⊆ s,	hc : s ⊆ Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∉ s,	hb : b ∉ s	⊢ s ∈ {Icc a b, Ico a b, Ioc a b, Ioo a b}", "decl_nm": "set.mem_Icc_Ico_Ioc_Ioo_of_subset_of_subset"
{"src": "3 goals	α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : Ioo a b ⊆ s,	hc : s ⊆ Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∉ s,	hb : b ∈ s	⊢ s ⊆ Ioc a b		α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : Ioo a b ⊆ s,	hc : s ⊆ Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∉ s,	hb : b ∈ s	⊢ Ioc a b ⊆ s		α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : Ioo a b ⊆ s,	hc : s ⊆ Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∉ s,	hb : b ∉ s	⊢ s ∈ {Icc a b, Ico a b, Ioc a b, Ioo a b}", "decl_nm": "set.mem_Icc_Ico_Ioc_Ioo_of_subset_of_subset"
{"src": "3 goals	α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : Ioo a b ⊆ s,	hc : s ⊆ Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∉ s,	hb : b ∈ s	⊢ s ⊆ Icc a b \ {a}		α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : Ioo a b ⊆ s,	hc : s ⊆ Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∉ s,	hb : b ∈ s	⊢ Ioc a b ⊆ s		α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : Ioo a b ⊆ s,	hc : s ⊆ Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∉ s,	hb : b ∉ s	⊢ s ∈ {Icc a b, Ico a b, Ioc a b, Ioo a b}", "decl_nm": "set.mem_Icc_Ico_Ioc_Ioo_of_subset_of_subset"
{"src": "2 goals	α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : Ioo a b ⊆ s,	hc : s ⊆ Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∉ s,	hb : b ∈ s	⊢ Ioc a b ⊆ s		α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : Ioo a b ⊆ s,	hc : s ⊆ Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∉ s,	hb : b ∉ s	⊢ s ∈ {Icc a b, Ico a b, Ioc a b, Ioo a b}", "decl_nm": "set.mem_Icc_Ico_Ioc_Ioo_of_subset_of_subset"
{"src": "α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : Ioo a b ⊆ s,	hc : s ⊆ Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∉ s,	hb : b ∉ s	⊢ s ∈ {Icc a b, Ico a b, Ioc a b, Ioo a b}", "decl_nm": "set.mem_Icc_Ico_Ioc_Ioo_of_subset_of_subset"
{"src": "α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : Ioo a b ⊆ s,	hc : s ⊆ Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∉ s,	hb : b ∉ s	⊢ s ⊆ Ioo a b", "decl_nm": "set.mem_Icc_Ico_Ioc_Ioo_of_subset_of_subset"
{"src": "α : Type u,	_inst_1 : partial_order α,	a b : α,	s : set α,	ho : Ioo a b ⊆ s,	hc : s ⊆ Icc a b,	_inst : Π (a : Prop), decidable a,	ha : a ∉ s,	hb : b ∉ s	⊢ s ⊆ Icc a b \ {b} \ {a}", "decl_nm": "set.mem_Icc_Ico_Ioc_Ioo_of_subset_of_subset"
{"src": "⊢ ∀ {α : Type v} [_inst_1 : linear_order α] {x₁ x₂ y₁ y₂ : α},	    disjoint (Ico x₁ x₂) (Ico y₁ y₂) → x₁ < x₂ → x₂ ∈ Ico y₁ y₂ → y₁ = x₂", "decl_nm": "set.eq_of_Ico_disjoint"
{"src": "α : Type v,	_inst_1 : linear_order α,	x₁ x₂ y₁ y₂ : α,	h : disjoint (Ico x₁ x₂) (Ico y₁ y₂),	hx : x₁ < x₂,	h2 : x₂ ∈ Ico y₁ y₂	⊢ y₁ = x₂", "decl_nm": "set.eq_of_Ico_disjoint"
{"src": "α : Type v,	_inst_1 : linear_order α,	x₁ x₂ y₁ y₂ : α,	hx : x₁ < x₂,	h2 : x₂ ∈ Ico y₁ y₂,	h : x₂ ≤ x₁ ∨ x₂ ≤ y₁	⊢ y₁ = x₂", "decl_nm": "set.eq_of_Ico_disjoint"
{"src": "α : Type v,	_inst_1 : linear_order α,	x₁ x₂ y₁ y₂ : α,	hx : x₁ < x₂,	h2 : x₂ ∈ Ico y₁ y₂,	h : x₂ ≤ x₁ ∨ x₂ ≤ y₁	⊢ x₂ ≤ y₁", "decl_nm": "set.eq_of_Ico_disjoint"
{"src": "⊢ ∀ {G : Type u} [_inst_1 : ordered_add_comm_group G] (a b : G), -Ico a b = Ioc (-b) (-a)", "decl_nm": "set.preimage_neg_Ico"
{"src": "G : Type u,	_inst_1 : ordered_add_comm_group G,	a b : G	⊢ -Ico a b = Ioc (-b) (-a)", "decl_nm": "set.preimage_neg_Ico"
{"src": "⊢ ∀ {G : Type u} [_inst_1 : ordered_add_comm_group G] (a b : G), -Ioc a b = Ico (-b) (-a)", "decl_nm": "set.preimage_neg_Ioc"
{"src": "G : Type u,	_inst_1 : ordered_add_comm_group G,	a b : G	⊢ -Ioc a b = Ico (-b) (-a)", "decl_nm": "set.preimage_neg_Ioc"
{"src": "⊢ ∀ {G : Type u} [_inst_1 : ordered_add_comm_group G] (a b c : G),	    (λ (x : G), a - x) ⁻¹' Ico b c = Ioc (a - c) (a - b)", "decl_nm": "set.preimage_const_sub_Ico"
{"src": "G : Type u,	_inst_1 : ordered_add_comm_group G,	a b c : G	⊢ (λ (x : G), a - x) ⁻¹' Ico b c = Ioc (a - c) (a - b)", "decl_nm": "set.preimage_const_sub_Ico"
{"src": "⊢ ∀ {G : Type u} [_inst_1 : ordered_add_comm_group G] (a b c : G),	    (λ (x : G), a + x) '' Icc b c = Icc (a + b) (a + c)", "decl_nm": "set.image_const_add_Icc"
{"src": "G : Type u,	_inst_1 : ordered_add_comm_group G,	a b c : G	⊢ (λ (x : G), a + x) '' Icc b c = Icc (a + b) (a + c)", "decl_nm": "set.image_const_add_Icc"
{"src": "⊢ ∀ {G : Type u} [_inst_1 : ordered_add_comm_group G] (a : G), has_neg.neg '' Iio a = Ioi (-a)", "decl_nm": "set.image_neg_Iio"
{"src": "G : Type u,	_inst_1 : ordered_add_comm_group G,	a : G	⊢ has_neg.neg '' Iio a = Ioi (-a)", "decl_nm": "set.image_neg_Iio"
{"src": "⊢ ∀ {k : Type u} [_inst_1 : linear_ordered_field k] {a b c : k},	    0 ≤ a → b ≤ c → has_mul.mul a '' Icc b c = Icc (a * b) (a * c)", "decl_nm": "set.image_mul_left_Icc"
{"src": "k : Type u,	_inst_1 : linear_ordered_field k,	a b c : k,	ha : 0 ≤ a,	hbc : b ≤ c	⊢ has_mul.mul a '' Icc b c = Icc (a * b) (a * c)", "decl_nm": "set.image_mul_left_Icc"
{"src": "2 goals	k : Type u,	_inst_1 : linear_ordered_field k,	a b c : k,	ha : 0 ≤ a,	hbc : b ≤ c	⊢ has_mul.mul a '' Icc b c = (λ (x : k), x * a) '' Icc b c		k : Type u,	_inst_1 : linear_ordered_field k,	a b c : k,	ha : 0 ≤ a,	hbc : b ≤ c	⊢ Icc (a * b) (a * c) = Icc (b * a) (c * a)", "decl_nm": "set.image_mul_left_Icc"
{"src": "k : Type u,	_inst_1 : linear_ordered_field k,	a b c : k,	ha : 0 ≤ a,	hbc : b ≤ c	⊢ Icc (a * b) (a * c) = Icc (b * a) (c * a)", "decl_nm": "set.image_mul_left_Icc"
{"src": "⊢ ∀ {α : Type u_1} {β : Type u_2} {s : set α} {t : set β}, s ×ˢ t = (prod.mk '' s).seq t", "decl_nm": "set.prod_eq_seq"
{"src": "α : Type u_1,	β : Type u_2,	s : set α,	t : set β	⊢ s ×ˢ t = (prod.mk '' s).seq t", "decl_nm": "set.prod_eq_seq"
{"src": "α : Type u_1,	β : Type u_2,	s : set α,	t : set β,	a : α,	b : β	⊢ (a, b) ∈ s ×ˢ t ↔ (a, b) ∈ (prod.mk '' s).seq t", "decl_nm": "set.prod_eq_seq"
{"src": "2 goals	α : Type u_1,	β : Type u_2,	s : set α,	t : set β,	a : α,	b : β	⊢ (a, b) ∈ s ×ˢ t → (a, b) ∈ (prod.mk '' s).seq t		α : Type u_1,	β : Type u_2,	s : set α,	t : set β,	a : α,	b : β	⊢ (a, b) ∈ (prod.mk '' s).seq t → (a, b) ∈ s ×ˢ t", "decl_nm": "set.prod_eq_seq"
{"src": "2 goals	α : Type u_1,	β : Type u_2,	s : set α,	t : set β,	a : α,	b : β,	ha : (a, b).fst ∈ s,	hb : (a, b).snd ∈ t	⊢ (a, b) ∈ (prod.mk '' s).seq t		α : Type u_1,	β : Type u_2,	s : set α,	t : set β,	a : α,	b : β	⊢ (a, b) ∈ (prod.mk '' s).seq t → (a, b) ∈ s ×ˢ t", "decl_nm": "set.prod_eq_seq"
{"src": "α : Type u_1,	β : Type u_2,	s : set α,	t : set β,	a : α,	b : β	⊢ (a, b) ∈ (prod.mk '' s).seq t → (a, b) ∈ s ×ˢ t", "decl_nm": "set.prod_eq_seq"
{"src": "α : Type u_1,	β : Type u_2,	s : set α,	t : set β,	a : α,	b : β,	x : α,	hx : x ∈ s,	y : β,	hy : y ∈ t,	eq : (x, y) = (a, b)	⊢ (a, b) ∈ s ×ˢ t", "decl_nm": "set.prod_eq_seq"
{"src": "α : Type u_1,	β : Type u_2,	s : set α,	t : set β,	a : α,	b : β,	x : α,	hx : x ∈ s,	y : β,	hy : y ∈ t,	eq : (x, y) = (a, b)	⊢ (x, y) ∈ s ×ˢ t", "decl_nm": "set.prod_eq_seq"
{"src": "⊢ ∀ {α : Type u_1} {S : set (set α)}, (⋃₀ S).nonempty ↔ ∃ (s : set α) (H : s ∈ S), s.nonempty", "decl_nm": "set.nonempty_sUnion"
{"src": "α : Type u_1,	S : set (set α)	⊢ (⋃₀ S).nonempty ↔ ∃ (s : set α) (H : s ∈ S), s.nonempty", "decl_nm": "set.nonempty_sUnion"
{"src": "⊢ ∀ {α : Type u_1} (r s : setoid α), r ⊔ s = eqv_gen.setoid (λ (x y : α), r.rel x y ∨ s.rel x y)", "decl_nm": "setoid.sup_eq_eqv_gen"
{"src": "α : Type u_1,	r s : setoid α	⊢ r ⊔ s = eqv_gen.setoid (λ (x y : α), r.rel x y ∨ s.rel x y)", "decl_nm": "setoid.sup_eq_eqv_gen"
{"src": "α : Type u_1,	r s : setoid α	⊢ r ⊔ s = Inf {s_1 : setoid α | ∀ ⦃x y : α⦄, r.rel x y ∨ s.rel x y → s_1.rel x y}", "decl_nm": "setoid.sup_eq_eqv_gen"
{"src": "α : Type u_1,	r s : setoid α	⊢ {x : setoid α | r ≤ x ∧ s ≤ x} =	    {s_1 : setoid α | ∀ ⦃x y : α⦄, r.rel x y ∨ s.rel x y → s_1.rel x y}", "decl_nm": "setoid.sup_eq_eqv_gen"
{"src": "⊢ ∀ (l : list char), l.as_string.to_list = l", "decl_nm": "list.to_list_inv_as_string"
{"src": "l : list char	⊢ l.as_string.to_list = l", "decl_nm": "list.to_list_inv_as_string"
{"src": "l data : list char,	hl : l.as_string = {data := data}	⊢ to_list {data := data} = l", "decl_nm": "list.to_list_inv_as_string"
{"src": "⊢ ∀ {α : Type u_1}, equivalence (rel α)", "decl_nm": "sym2.rel.is_equivalence"
{"src": "α : Type u_1	⊢ equivalence (rel α)", "decl_nm": "sym2.rel.is_equivalence"
{"src": "α : Type u_1,	z_fst z_snd y_fst y_snd : α,	ᾰ_1 : rel α (y_fst, y_snd) (z_fst, z_snd),	x_fst x_snd : α,	ᾰ : rel α (x_fst, x_snd) (y_fst, y_snd)	⊢ rel α (x_fst, x_snd) (z_fst, z_snd)", "decl_nm": "sym2.rel.is_equivalence"
{"src": "3 goals	α : Type u_1,	z_fst z_snd y_fst y_snd : α,	ᾰ_1 : rel α (y_fst, y_snd) (z_fst, z_snd),	x_fst x_snd : α,	ᾰ : rel α (x_fst, x_snd) (y_fst, y_snd)	⊢ rel α (x_fst, x_snd) ?m_1		α : Type u_1,	z_fst z_snd y_fst y_snd : α,	ᾰ_1 : rel α (y_fst, y_snd) (z_fst, z_snd),	x_fst x_snd : α,	ᾰ : rel α (x_fst, x_snd) (y_fst, y_snd)	⊢ rel α ?m_1 (z_fst, z_snd)		α : Type u_1,	z_fst z_snd y_fst y_snd : α,	ᾰ_1 : rel α (y_fst, y_snd) (z_fst, z_snd),	x_fst x_snd : α,	ᾰ : rel α (x_fst, x_snd) (y_fst, y_snd)	⊢ α × α", "decl_nm": "sym2.rel.is_equivalence"
{"src": "α : Type u_1,	z_fst z_snd y_fst y_snd : α,	ᾰ_1 : rel α (y_fst, y_snd) (z_fst, z_snd),	x_fst x_snd : α,	ᾰ : rel α (x_fst, x_snd) (y_fst, y_snd)	⊢ rel α (y_fst, y_snd) (z_fst, z_snd)", "decl_nm": "sym2.rel.is_equivalence"
{"src": "⊢ ∀ {n : ℕ} {α : typevec n} {β : typevec n} (p : α.arrow (repeat n Prop)) (f : β.arrow (subtype_ p)),	    comp (to_subtype p) (comp (of_subtype (λ (i : fin2 n) (x : α i), p i x)) f) = f", "decl_nm": "typevec.to_subtype_of_subtype_assoc"
{"src": "n : ℕ,	α : typevec n,	β : typevec n,	p : α.arrow (repeat n Prop),	f : β.arrow (subtype_ p)	⊢ comp (to_subtype p) (comp (of_subtype (λ (i : fin2 n) (x : α i), p i x)) f) = f", "decl_nm": "typevec.to_subtype_of_subtype_assoc"
{"src": "n : ℕ,	α : typevec n,	β : typevec n,	p : α.arrow (repeat n Prop),	f : β.arrow (subtype_ p)	⊢ comp id f = f", "decl_nm": "typevec.to_subtype_of_subtype_assoc"
{"src": "⊢ ∀ {n : ℕ} {α : Type u_1} {v : vector α n}, v.reverse.reverse = v", "decl_nm": "vector.reverse_reverse"
{"src": "n : ℕ,	α : Type u_1,	v : vector α n	⊢ v.reverse.reverse = v", "decl_nm": "vector.reverse_reverse"
{"src": "n : ℕ,	α : Type u_1,	v_val : list α,	v_property : v_val.length = n	⊢ (reverse ⟨v_val, v_property⟩).reverse = ⟨v_val, v_property⟩", "decl_nm": "vector.reverse_reverse"
{"src": "⊢ ∀ {n : ℕ} [_inst_1 : fact (0 < n)] (a : zmod n), a.val < n", "decl_nm": "zmod.val_lt"
{"src": "n : ℕ,	_inst_1 : fact (0 < n),	a : zmod n	⊢ a.val < n", "decl_nm": "zmod.val_lt"
{"src": "2 goals	_inst_1 : fact (0 < 0),	a : zmod 0	⊢ a.val < 0		n : ℕ,	_inst_1 : fact (0 < n.succ),	a : zmod n.succ	⊢ a.val < n.succ", "decl_nm": "zmod.val_lt"
{"src": "2 goals	_inst_1 : fact (0 < 0),	a : zmod 0	⊢ false		n : ℕ,	_inst_1 : fact (0 < n.succ),	a : zmod n.succ	⊢ a.val < n.succ", "decl_nm": "zmod.val_lt"
{"src": "n : ℕ,	_inst_1 : fact (0 < n.succ),	a : zmod n.succ	⊢ a.val < n.succ", "decl_nm": "zmod.val_lt"
{"src": "⊢ ∀ {n : ℕ} [_inst_1 : fact (0 < n)] (x : zmod n),	    x.val_min_abs = ite (x.val ≤ n / 2) ↑(x.val) (↑(x.val) - ↑n)", "decl_nm": "zmod.val_min_abs_def_pos"
{"src": "n : ℕ,	_inst_1 : fact (0 < n),	x : zmod n	⊢ x.val_min_abs = ite (x.val ≤ n / 2) ↑(x.val) (↑(x.val) - ↑n)", "decl_nm": "zmod.val_min_abs_def_pos"
{"src": "2 goals	_inst_1 : fact (0 < 0),	x : zmod 0	⊢ x.val_min_abs = ite (x.val ≤ 0 / 2) ↑(x.val) (↑(x.val) - ↑0)		n : ℕ,	_inst_1 : fact (0 < n.succ),	x : zmod n.succ	⊢ x.val_min_abs = ite (x.val ≤ n.succ / 2) ↑(x.val) (↑(x.val) - ↑(n.succ))", "decl_nm": "zmod.val_min_abs_def_pos"
{"src": "2 goals	_inst_1 : fact (0 < 0),	x : zmod 0	⊢ false		n : ℕ,	_inst_1 : fact (0 < n.succ),	x : zmod n.succ	⊢ x.val_min_abs = ite (x.val ≤ n.succ / 2) ↑(x.val) (↑(x.val) - ↑(n.succ))", "decl_nm": "zmod.val_min_abs_def_pos"
{"src": "n : ℕ,	_inst_1 : fact (0 < n.succ),	x : zmod n.succ	⊢ x.val_min_abs = ite (x.val ≤ n.succ / 2) ↑(x.val) (↑(x.val) - ↑(n.succ))", "decl_nm": "zmod.val_min_abs_def_pos"
{"src": "⊢ ∀ (f g : circle_deg1_lift), dist (⇑f 0 + ⇑g 0) (⇑f (⇑g 0)) < 1", "decl_nm": "circle_deg1_lift.dist_map_map_zero_lt"
{"src": "f g : circle_deg1_lift	⊢ dist (⇑f 0 + ⇑g 0) (⇑f (⇑g 0)) < 1", "decl_nm": "circle_deg1_lift.dist_map_map_zero_lt"
{"src": "f g : circle_deg1_lift	⊢ ⇑f 0 + ⇑g 0 - 1 < ⇑f (⇑g 0) ∧ ⇑f (⇑g 0) < ⇑f 0 + ⇑g 0 + 1", "decl_nm": "circle_deg1_lift.dist_map_map_zero_lt"
{"src": "⊢ ∀ (f : circle_deg1_lift),	    tendsto (λ (n : ℕ), ⇑(f ^ (n + 1)) 0 / (↑n + 1)) at_top (nhds f.translation_number)", "decl_nm": "circle_deg1_lift.tendsto_translation_number₀'"
{"src": "f : circle_deg1_lift	⊢ tendsto (λ (n : ℕ), ⇑(f ^ (n + 1)) 0 / (↑n + 1)) at_top (nhds f.translation_number)", "decl_nm": "circle_deg1_lift.tendsto_translation_number₀'"
{"src": "f : circle_deg1_lift,	n : ℕ	⊢ dist (⇑(f ^ (n + 1)) 0 / (↑n + 1)) f.translation_number ≤ ((λ (n : ℕ), 1 / ↑n) ∘ λ (a : ℕ), a + 1) n", "decl_nm": "circle_deg1_lift.tendsto_translation_number₀'"
{"src": "f : circle_deg1_lift,	n : ℕ	⊢ dist (⇑(f ^ (n + 1)) 0 / (↑n + 1)) f.translation_number ≤ 1 / (↑n + 1)", "decl_nm": "circle_deg1_lift.tendsto_translation_number₀'"
{"src": "f : circle_deg1_lift,	n : ℕ,	this : 0 < ↑n + 1	⊢ dist (⇑(f ^ (n + 1)) 0 / (↑n + 1)) f.translation_number ≤ 1 / (↑n + 1)", "decl_nm": "circle_deg1_lift.tendsto_translation_number₀'"
{"src": "f : circle_deg1_lift,	n : ℕ,	this : 0 < ↑n + 1	⊢ dist (⇑(f ^ (n + 1)) 0) (↑(n + 1) * f.translation_number) ≤ 1", "decl_nm": "circle_deg1_lift.tendsto_translation_number₀'"
{"src": "⊢ ∀ {α : Type u_2} [_inst_1 : measurable_space α] {f : α → α} {s : set α} {μ : measure α},	    conservative f μ →	    measurable_set s → (∀ᵐ (x : α) ∂μ, x ∈ s → (∃ᶠ (n : ℕ) in at_top, f^[n] x ∈ s))", "decl_nm": "measure_theory.conservative.ae_mem_imp_frequently_image_mem"
{"src": "α : Type u_2,	_inst_1 : measurable_space α,	f : α → α,	s : set α,	μ : measure α,	hf : conservative f μ,	hs : measurable_set s	⊢ ∀ᵐ (x : α) ∂μ, x ∈ s → (∃ᶠ (n : ℕ) in at_top, f^[n] x ∈ s)", "decl_nm": "measure_theory.conservative.ae_mem_imp_frequently_image_mem"
{"src": "α : Type u_2,	_inst_1 : measurable_space α,	f : α → α,	s : set α,	μ : measure α,	hf : conservative f μ,	hs : measurable_set s	⊢ ∀ (i : ℕ), ∀ᵐ (a : α) ∂μ, a ∈ s → (∃ (b : ℕ) (H : b ≥ i), f^[b] a ∈ s)", "decl_nm": "measure_theory.conservative.ae_mem_imp_frequently_image_mem"
{"src": "α : Type u_2,	_inst_1 : measurable_space α,	f : α → α,	s : set α,	μ : measure α,	hf : conservative f μ,	hs : measurable_set s,	n : ℕ	⊢ ∀ᵐ (a : α) ∂μ, a ∈ s → (∃ (b : ℕ) (H : b ≥ n), f^[b] a ∈ s)", "decl_nm": "measure_theory.conservative.ae_mem_imp_frequently_image_mem"
{"src": "α : Type u_2,	_inst_1 : measurable_space α,	f : α → α,	s : set α,	μ : measure α,	hf : conservative f μ,	hs : measurable_set s,	n : ℕ	⊢ ∀ (a : α),	    a ∉ {x ∈ s | ∀ (m : ℕ), m ≥ n → f^[m] x ∉ s} →	    a ∈ s → (∃ (b : ℕ) (H : b ≥ n), f^[b] a ∈ s)", "decl_nm": "measure_theory.conservative.ae_mem_imp_frequently_image_mem"
{"src": "⊢ ∀ {α : Type u_1} {f : α → α} {x : α} {p k : ℕ} [hp : fact (prime p)],	    ¬is_periodic_pt f (p ^ k) x → is_periodic_pt f (p ^ (k + 1)) x → minimal_period f x = p ^ (k + 1)", "decl_nm": "function.minimal_period_eq_prime_pow"
{"src": "α : Type u_1,	f : α → α,	x : α,	p k : ℕ,	hp : fact (prime p),	hk : ¬is_periodic_pt f (p ^ k) x,	hk1 : is_periodic_pt f (p ^ (k + 1)) x	⊢ minimal_period f x = p ^ (k + 1)", "decl_nm": "function.minimal_period_eq_prime_pow"
{"src": "2 goals	α : Type u_1,	f : α → α,	x : α,	p k : ℕ,	hp : fact (prime p),	hk : ¬is_periodic_pt f (p ^ k) x,	hk1 : is_periodic_pt f (p ^ (k + 1)) x	⊢ ¬minimal_period f x ∣ p ^ k		α : Type u_1,	f : α → α,	x : α,	p k : ℕ,	hp : fact (prime p),	hk : ¬is_periodic_pt f (p ^ k) x,	hk1 : is_periodic_pt f (p ^ (k + 1)) x	⊢ minimal_period f x ∣ p ^ (k + 1)", "decl_nm": "function.minimal_period_eq_prime_pow"
{"src": "α : Type u_1,	f : α → α,	x : α,	p k : ℕ,	hp : fact (prime p),	hk : ¬is_periodic_pt f (p ^ k) x,	hk1 : is_periodic_pt f (p ^ (k + 1)) x	⊢ minimal_period f x ∣ p ^ (k + 1)", "decl_nm": "function.minimal_period_eq_prime_pow"
{"src": "⊢ ∀ {F : Type u_1} [_inst_1 : field F] (x : F), is_solvable (⇑C x).gal", "decl_nm": "gal_C_is_solvable"
{"src": "F : Type u_1,	_inst_1 : field F,	x : F	⊢ is_solvable (⇑C x).gal", "decl_nm": "gal_C_is_solvable"
{"src": "⊢ ∀ (F : Type u_1) [_inst_1 : field F] {E : Type u_2} [_inst_2 : field E] [_inst_3 : algebra F E] (S : set E),	    set.range ⇑(algebra_map F E) ⊆ ↑(adjoin F S)", "decl_nm": "intermediate_field.adjoin.range_algebra_map_subset"
{"src": "F : Type u_1,	_inst_1 : field F,	E : Type u_2,	_inst_2 : field E,	_inst_3 : algebra F E,	S : set E	⊢ set.range ⇑(algebra_map F E) ⊆ ↑(adjoin F S)", "decl_nm": "intermediate_field.adjoin.range_algebra_map_subset"
{"src": "F : Type u_1,	_inst_1 : field F,	E : Type u_2,	_inst_2 : field E,	_inst_3 : algebra F E,	S : set E,	x : E,	hx : x ∈ set.range ⇑(algebra_map F E)	⊢ x ∈ ↑(adjoin F S)", "decl_nm": "intermediate_field.adjoin.range_algebra_map_subset"
{"src": "F : Type u_1,	_inst_1 : field F,	E : Type u_2,	_inst_2 : field E,	_inst_3 : algebra F E,	S : set E,	x : E,	f : F,	hf : ⇑(algebra_map F E) f = x	⊢ x ∈ ↑(adjoin F S)", "decl_nm": "intermediate_field.adjoin.range_algebra_map_subset"
{"src": "F : Type u_1,	_inst_1 : field F,	E : Type u_2,	_inst_2 : field E,	_inst_3 : algebra F E,	S : set E,	x : E,	f : F,	hf : ⇑(algebra_map F E) f = x	⊢ ⇑(algebra_map F E) f ∈ ↑(adjoin F S)", "decl_nm": "intermediate_field.adjoin.range_algebra_map_subset"
{"src": "⊢ ∀ {p : ℕ} [_inst_1 : fact (nat.prime p)] (x : zmod p), x ^ p = x", "decl_nm": "zmod.pow_card"
{"src": "p : ℕ,	_inst_1 : fact (nat.prime p),	x : zmod p	⊢ x ^ p = x", "decl_nm": "zmod.pow_card"
{"src": "p : ℕ,	_inst_1 : fact (nat.prime p),	x : zmod p,	h : x ^ fintype.card (zmod p) = x	⊢ x ^ p = x", "decl_nm": "zmod.pow_card"
{"src": "⊢ ∀ {p : ℕ} [_inst_1 : fact (nat.prime p)] (f : polynomial (zmod p)), ⇑(expand (zmod p) p) f = f ^ p", "decl_nm": "zmod.expand_card"
{"src": "p : ℕ,	_inst_1 : fact (nat.prime p),	f : polynomial (zmod p)	⊢ ⇑(expand (zmod p) p) f = f ^ p", "decl_nm": "zmod.expand_card"
{"src": "p : ℕ,	_inst_1 : fact (nat.prime p),	f : polynomial (zmod p),	h : ⇑(expand (zmod p) (fintype.card (zmod p))) f = f ^ fintype.card (zmod p)	⊢ ⇑(expand (zmod p) p) f = f ^ p", "decl_nm": "zmod.expand_card"
{"src": "⊢ ∀ (F : Type u_1) [_inst_1 : field F] (E : Type u_2) [_inst_2 : field E] [_inst_3 : algebra F E]	  [_inst_4 : finite_dimensional F E] [_inst_5 : is_galois F E],	    ∃ (p : polynomial F), p.separable ∧ polynomial.is_splitting_field F E p", "decl_nm": "is_galois.is_separable_splitting_field"
{"src": "F : Type u_1,	_inst_1 : field F,	E : Type u_2,	_inst_2 : field E,	_inst_3 : algebra F E,	_inst_4 : finite_dimensional F E,	_inst_5 : is_galois F E	⊢ ∃ (p : polynomial F), p.separable ∧ polynomial.is_splitting_field F E p", "decl_nm": "is_galois.is_separable_splitting_field"
{"src": "F : Type u_1,	_inst_1 : field F,	E : Type u_2,	_inst_2 : field E,	_inst_3 : algebra F E,	_inst_4 : finite_dimensional F E,	_inst_5 : is_galois F E,	α : E,	h1 : F⟮α⟯ = ⊤	⊢ ∃ (p : polynomial F), p.separable ∧ polynomial.is_splitting_field F E p", "decl_nm": "is_galois.is_separable_splitting_field"
{"src": "F : Type u_1,	_inst_1 : field F,	E : Type u_2,	_inst_2 : field E,	_inst_3 : algebra F E,	_inst_4 : finite_dimensional F E,	_inst_5 : is_galois F E,	α : E,	h1 : F⟮α⟯ = ⊤	⊢ algebra.adjoin F ↑((polynomial.map (algebra_map F E) (minpoly F α)).roots.to_finset) = ⊤", "decl_nm": "is_galois.is_separable_splitting_field"
{"src": "F : Type u_1,	_inst_1 : field F,	E : Type u_2,	_inst_2 : field E,	_inst_3 : algebra F E,	_inst_4 : finite_dimensional F E,	_inst_5 : is_galois F E,	α : E,	h1 : F⟮α⟯ = ⊤	⊢ F⟮α⟯.to_subalgebra ≤ algebra.adjoin F ↑((polynomial.map (algebra_map F E) (minpoly F α)).roots.to_finset)", "decl_nm": "is_galois.is_separable_splitting_field"
{"src": "F : Type u_1,	_inst_1 : field F,	E : Type u_2,	_inst_2 : field E,	_inst_3 : algebra F E,	_inst_4 : finite_dimensional F E,	_inst_5 : is_galois F E,	α : E,	h1 : F⟮α⟯ = ⊤	⊢ algebra.adjoin F {α} ≤ algebra.adjoin F ↑((polynomial.map (algebra_map F E) (minpoly F α)).roots.to_finset)", "decl_nm": "is_galois.is_separable_splitting_field"
{"src": "F : Type u_1,	_inst_1 : field F,	E : Type u_2,	_inst_2 : field E,	_inst_3 : algebra F E,	_inst_4 : finite_dimensional F E,	_inst_5 : is_galois F E,	α : E,	h1 : F⟮α⟯ = ⊤	⊢ {α} ⊆ ↑((polynomial.map (algebra_map F E) (minpoly F α)).roots.to_finset)", "decl_nm": "is_galois.is_separable_splitting_field"
{"src": "2 goals	F : Type u_1,	_inst_1 : field F,	E : Type u_2,	_inst_2 : field E,	_inst_3 : algebra F E,	_inst_4 : finite_dimensional F E,	_inst_5 : is_galois F E,	α : E,	h1 : F⟮α⟯ = ⊤	⊢ (polynomial.map (algebra_map F E) (minpoly F α)).is_root α		F : Type u_1,	_inst_1 : field F,	E : Type u_2,	_inst_2 : field E,	_inst_3 : algebra F E,	_inst_4 : finite_dimensional F E,	_inst_5 : is_galois F E,	α : E,	h1 : F⟮α⟯ = ⊤	⊢ polynomial.map (algebra_map F E) (minpoly F α) ≠ 0", "decl_nm": "is_galois.is_separable_splitting_field"
{"src": "2 goals	F : Type u_1,	_inst_1 : field F,	E : Type u_2,	_inst_2 : field E,	_inst_3 : algebra F E,	_inst_4 : finite_dimensional F E,	_inst_5 : is_galois F E,	α : E,	h1 : F⟮α⟯ = ⊤	⊢ polynomial.eval α (polynomial.map (algebra_map F E) (minpoly F α)) = 0		F : Type u_1,	_inst_1 : field F,	E : Type u_2,	_inst_2 : field E,	_inst_3 : algebra F E,	_inst_4 : finite_dimensional F E,	_inst_5 : is_galois F E,	α : E,	h1 : F⟮α⟯ = ⊤	⊢ polynomial.map (algebra_map F E) (minpoly F α) ≠ 0", "decl_nm": "is_galois.is_separable_splitting_field"
{"src": "2 goals	F : Type u_1,	_inst_1 : field F,	E : Type u_2,	_inst_2 : field E,	_inst_3 : algebra F E,	_inst_4 : finite_dimensional F E,	_inst_5 : is_galois F E,	α : E,	h1 : F⟮α⟯ = ⊤	⊢ ⇑(polynomial.aeval α) (minpoly F α) = 0		F : Type u_1,	_inst_1 : field F,	E : Type u_2,	_inst_2 : field E,	_inst_3 : algebra F E,	_inst_4 : finite_dimensional F E,	_inst_5 : is_galois F E,	α : E,	h1 : F⟮α⟯ = ⊤	⊢ polynomial.map (algebra_map F E) (minpoly F α) ≠ 0", "decl_nm": "is_galois.is_separable_splitting_field"
{"src": "F : Type u_1,	_inst_1 : field F,	E : Type u_2,	_inst_2 : field E,	_inst_3 : algebra F E,	_inst_4 : finite_dimensional F E,	_inst_5 : is_galois F E,	α : E,	h1 : F⟮α⟯ = ⊤	⊢ polynomial.map (algebra_map F E) (minpoly F α) ≠ 0", "decl_nm": "is_galois.is_separable_splitting_field"
{"src": "⊢ ∀ (A : Type u_1) (K : Type u_2) {R : Type u_3} [_inst_4 : comm_ring A] [_inst_5 : field K] [_inst_6 : comm_ring R]	  [_inst_7 : algebra A K] [_inst_8 : algebra A R] [_inst_9 : algebra K R] [_inst_10 : is_scalar_tower A K R] (x : R),	    minpoly K x ∣ map (algebra_map A K) (minpoly A x)", "decl_nm": "minpoly.dvd_map_of_is_scalar_tower"
{"src": "A : Type u_1,	K : Type u_2,	R : Type u_3,	_inst_4 : comm_ring A,	_inst_5 : field K,	_inst_6 : comm_ring R,	_inst_7 : algebra A K,	_inst_8 : algebra A R,	_inst_9 : algebra K R,	_inst_10 : is_scalar_tower A K R,	x : R	⊢ minpoly K x ∣ map (algebra_map A K) (minpoly A x)", "decl_nm": "minpoly.dvd_map_of_is_scalar_tower"
{"src": "A : Type u_1,	K : Type u_2,	R : Type u_3,	_inst_4 : comm_ring A,	_inst_5 : field K,	_inst_6 : comm_ring R,	_inst_7 : algebra A K,	_inst_8 : algebra A R,	_inst_9 : algebra K R,	_inst_10 : is_scalar_tower A K R,	x : R	⊢ ⇑(aeval x) (map (algebra_map A K) (minpoly A x)) = 0", "decl_nm": "minpoly.dvd_map_of_is_scalar_tower"
{"src": "⊢ ∀ {A : Type u_1} {B : Type u_2} [_inst_1 : field A] [_inst_2 : ring B] [_inst_3 : is_domain B]	  [_inst_4 : algebra A B] {x : B}, is_integral A x → ((minpoly A x).coeff 0 = 0 ↔ x = 0)", "decl_nm": "minpoly.coeff_zero_eq_zero"
{"src": "A : Type u_1,	B : Type u_2,	_inst_1 : field A,	_inst_2 : ring B,	_inst_3 : is_domain B,	_inst_4 : algebra A B,	x : B,	hx : is_integral A x	⊢ (minpoly A x).coeff 0 = 0 ↔ x = 0", "decl_nm": "minpoly.coeff_zero_eq_zero"
{"src": "2 goals	A : Type u_1,	B : Type u_2,	_inst_1 : field A,	_inst_2 : ring B,	_inst_3 : is_domain B,	_inst_4 : algebra A B,	x : B,	hx : is_integral A x	⊢ (minpoly A x).coeff 0 = 0 → x = 0		A : Type u_1,	B : Type u_2,	_inst_1 : field A,	_inst_2 : ring B,	_inst_3 : is_domain B,	_inst_4 : algebra A B,	x : B,	hx : is_integral A x	⊢ x = 0 → (minpoly A x).coeff 0 = 0", "decl_nm": "minpoly.coeff_zero_eq_zero"
{"src": "2 goals	A : Type u_1,	B : Type u_2,	_inst_1 : field A,	_inst_2 : ring B,	_inst_3 : is_domain B,	_inst_4 : algebra A B,	x : B,	hx : is_integral A x,	h : (minpoly A x).coeff 0 = 0	⊢ x = 0		A : Type u_1,	B : Type u_2,	_inst_1 : field A,	_inst_2 : ring B,	_inst_3 : is_domain B,	_inst_4 : algebra A B,	x : B,	hx : is_integral A x	⊢ x = 0 → (minpoly A x).coeff 0 = 0", "decl_nm": "minpoly.coeff_zero_eq_zero"
{"src": "2 goals	A : Type u_1,	B : Type u_2,	_inst_1 : field A,	_inst_2 : ring B,	_inst_3 : is_domain B,	_inst_4 : algebra A B,	x : B,	hx : is_integral A x,	h : (minpoly A x).coeff 0 = 0,	zero_root : (minpoly A x).is_root 0	⊢ x = 0		A : Type u_1,	B : Type u_2,	_inst_1 : field A,	_inst_2 : ring B,	_inst_3 : is_domain B,	_inst_4 : algebra A B,	x : B,	hx : is_integral A x	⊢ x = 0 → (minpoly A x).coeff 0 = 0", "decl_nm": "minpoly.coeff_zero_eq_zero"
{"src": "2 goals	A : Type u_1,	B : Type u_2,	_inst_1 : field A,	_inst_2 : ring B,	_inst_3 : is_domain B,	_inst_4 : algebra A B,	x : B,	hx : is_integral A x,	h : (minpoly A x).coeff 0 = 0,	zero_root : (minpoly A x).is_root 0	⊢ ⇑(algebra_map A B) 0 = 0		A : Type u_1,	B : Type u_2,	_inst_1 : field A,	_inst_2 : ring B,	_inst_3 : is_domain B,	_inst_4 : algebra A B,	x : B,	hx : is_integral A x	⊢ x = 0 → (minpoly A x).coeff 0 = 0", "decl_nm": "minpoly.coeff_zero_eq_zero"
{"src": "A : Type u_1,	B : Type u_2,	_inst_1 : field A,	_inst_2 : ring B,	_inst_3 : is_domain B,	_inst_4 : algebra A B,	x : B,	hx : is_integral A x	⊢ x = 0 → (minpoly A x).coeff 0 = 0", "decl_nm": "minpoly.coeff_zero_eq_zero"
{"src": "A : Type u_1,	B : Type u_2,	_inst_1 : field A,	_inst_2 : ring B,	_inst_3 : is_domain B,	_inst_4 : algebra A B,	hx : is_integral A 0	⊢ (minpoly A 0).coeff 0 = 0", "decl_nm": "minpoly.coeff_zero_eq_zero"
{"src": "⊢ ∀ (F : Type u_1) {E : Type u_3} [_inst_1 : field F] [_inst_3 : field E] [_inst_5 : algebra F E] (E' : Type u_2)	  [_inst_8 : field E'] [_inst_9 : algebra F E'],	    (E →ₐ[F] E') → ∀ [_inst_10 : is_separable F E'], is_separable F E", "decl_nm": "is_separable.of_alg_hom"
{"src": "F : Type u_1,	E : Type u_3,	_inst_1 : field F,	_inst_3 : field E,	_inst_5 : algebra F E,	E' : Type u_2,	_inst_8 : field E',	_inst_9 : algebra F E',	f : E →ₐ[F] E',	_inst_10 : is_separable F E'	⊢ is_separable F E", "decl_nm": "is_separable.of_alg_hom"
{"src": "F : Type u_1,	E : Type u_3,	_inst_1 : field F,	_inst_3 : field E,	_inst_5 : algebra F E,	E' : Type u_2,	_inst_8 : field E',	_inst_9 : algebra F E',	f : E →ₐ[F] E',	_inst_10 : is_separable F E',	_inst : algebra E E' := f.to_ring_hom.to_algebra	⊢ is_separable F E", "decl_nm": "is_separable.of_alg_hom"
{"src": "F : Type u_1,	E : Type u_3,	_inst_1 : field F,	_inst_3 : field E,	_inst_5 : algebra F E,	E' : Type u_2,	_inst_8 : field E',	_inst_9 : algebra F E',	f : E →ₐ[F] E',	_inst_10 : is_separable F E',	_inst : algebra E E' := f.to_ring_hom.to_algebra,	_inst_2 : is_scalar_tower F E E'	⊢ is_separable F E", "decl_nm": "is_separable.of_alg_hom"
{"src": "⊢ ∀ {V : Type u_1} [_inst_1 : inner_product_space ℝ V] {x y : V},	    x ≠ 0 → y ≠ 0 → (inner x y = -(∥x∥ * ∥y∥) ↔ angle x y = real.pi)", "decl_nm": "inner_product_geometry.inner_eq_neg_mul_norm_iff_angle_eq_pi"
{"src": "V : Type u_1,	_inst_1 : inner_product_space ℝ V,	x y : V,	hx : x ≠ 0,	hy : y ≠ 0	⊢ inner x y = -(∥x∥ * ∥y∥) ↔ angle x y = real.pi", "decl_nm": "inner_product_geometry.inner_eq_neg_mul_norm_iff_angle_eq_pi"
{"src": "V : Type u_1,	_inst_1 : inner_product_space ℝ V,	x y : V,	hx : x ≠ 0,	hy : y ≠ 0,	h : inner x y = -(∥x∥ * ∥y∥)	⊢ angle x y = real.pi", "decl_nm": "inner_product_geometry.inner_eq_neg_mul_norm_iff_angle_eq_pi"
{"src": "V : Type u_1,	_inst_1 : inner_product_space ℝ V,	x y : V,	hx : x ≠ 0,	hy : y ≠ 0,	h : inner x y = -(∥x∥ * ∥y∥),	h₁ : ∥x∥ * ∥y∥ ≠ 0	⊢ angle x y = real.pi", "decl_nm": "inner_product_geometry.inner_eq_neg_mul_norm_iff_angle_eq_pi"
{"src": "⊢ ∀ {V : Type u_1} {P : Type u_2} [_inst_1 : inner_product_space ℝ V] [_inst_2 : metric_space P]	  [_inst_3 : normed_add_torsor V P] {n : ℕ} (s : simplex ℝ P n) (i : fin (n + 1)),	    dist s.circumcenter (s.points i) = s.circumradius", "decl_nm": "affine.simplex.dist_circumcenter_eq_circumradius'"
{"src": "V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	n : ℕ,	s : simplex ℝ P n,	i : fin (n + 1)	⊢ dist s.circumcenter (s.points i) = s.circumradius", "decl_nm": "affine.simplex.dist_circumcenter_eq_circumradius'"
{"src": "V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	n : ℕ,	s : simplex ℝ P n,	i : fin (n + 1)	⊢ dist (s.points i) s.circumcenter = s.circumradius", "decl_nm": "affine.simplex.dist_circumcenter_eq_circumradius'"
{"src": "⊢ ∀ {V : Type u_1} {P : Type u_2} [_inst_1 : inner_product_space ℝ V] [_inst_2 : metric_space P]	  [_inst_3 : normed_add_torsor V P] {n : ℕ} (s : simplex ℝ P n) {p : P},	    p ∈ affine_span ℝ (set.range s.points) →	    ∀ {r : ℝ}, (∀ (i : fin (n + 1)), dist (s.points i) p = r) → r = s.circumradius", "decl_nm": "affine.simplex.eq_circumradius_of_dist_eq"
{"src": "V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	n : ℕ,	s : simplex ℝ P n,	p : P,	hp : p ∈ affine_span ℝ (set.range s.points),	r : ℝ,	hr : ∀ (i : fin (n + 1)), dist (s.points i) p = r	⊢ r = s.circumradius", "decl_nm": "affine.simplex.eq_circumradius_of_dist_eq"
{"src": "V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	n : ℕ,	s : simplex ℝ P n,	p : P,	hp : p ∈ affine_span ℝ (set.range s.points),	r : ℝ,	hr : ∀ (i : fin (n + 1)), dist (s.points i) p = r,	h :	  ((p, r).fst ∈ affine_span ℝ (set.range s.points) ∧	     ∀ (i : fin (n + 1)), dist (s.points i) (p, r).fst = (p, r).snd) →	  (p, r) = s.circumcenter_circumradius	⊢ r = s.circumradius", "decl_nm": "affine.simplex.eq_circumradius_of_dist_eq"
{"src": "V : Type u_1,	P : Type u_2,	_inst_1 : inner_product_space ℝ V,	_inst_2 : metric_space P,	_inst_3 : normed_add_torsor V P,	n : ℕ,	s : simplex ℝ P n,	p : P,	hp : p ∈ affine_span ℝ (set.range s.points),	r : ℝ,	hr : ∀ (i : fin (n + 1)), dist (s.points i) p = r,	h : p = s.circumcenter_circumradius.fst ∧ r = s.circumcenter_circumradius.snd	⊢ r = s.circumradius", "decl_nm": "affine.simplex.eq_circumradius_of_dist_eq"
{"src": "⊢ ∀ (n : ℕ),	    univ.sum	        (λ (i : simplex.points_with_circumcenter_index (n + 2)), simplex.monge_point_weights_with_circumcenter n i) =	      1", "decl_nm": "affine.simplex.sum_monge_point_weights_with_circumcenter"
{"src": "n : ℕ	⊢ univ.sum	      (λ (i : simplex.points_with_circumcenter_index (n + 2)), simplex.monge_point_weights_with_circumcenter n i) =	    1", "decl_nm": "affine.simplex.sum_monge_point_weights_with_circumcenter"
{"src": "n : ℕ	⊢ ↑(n + 2 + 1) * (↑(n + 1))⁻¹ + (-2) / ↑(n + 1) = 1", "decl_nm": "affine.simplex.sum_monge_point_weights_with_circumcenter"
{"src": "2 goals	n : ℕ	⊢ ↑n + 1 ≠ 0		n : ℕ,	hn1 : ↑n + 1 ≠ 0	⊢ ↑(n + 2 + 1) * (↑(n + 1))⁻¹ + (-2) / ↑(n + 1) = 1", "decl_nm": "affine.simplex.sum_monge_point_weights_with_circumcenter"
{"src": "n : ℕ,	hn1 : ↑n + 1 ≠ 0	⊢ ↑(n + 2 + 1) * (↑(n + 1))⁻¹ + (-2) / ↑(n + 1) = 1", "decl_nm": "affine.simplex.sum_monge_point_weights_with_circumcenter"
{"src": "n : ℕ,	hn1 : ↑n + 1 ≠ 0	⊢ ↑n + 2 + 1 + -2 = ↑n + 1", "decl_nm": "affine.simplex.sum_monge_point_weights_with_circumcenter"
{"src": "⊢ ∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field 𝕜] {H : Type u_2} [_inst_2 : topological_space H]	  {E : Type u_3} [_inst_3 : normed_group E] [_inst_4 : normed_space 𝕜 E] {I : model_with_corners 𝕜 E H}	  {G : Type u_5} [_inst_7 : topological_space G] [_inst_8 : charted_space H G] [_inst_9 : group G]	  [_inst_10 : lie_group I G] {E' : Type u_6} [_inst_11 : normed_group E'] [_inst_12 : normed_space 𝕜 E']	  {H' : Type u_7} [_inst_13 : topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M : Type u_8}	  [_inst_14 : topological_space M] [_inst_15 : charted_space H' M] {f g : M → G},	    smooth I' I f → smooth I' I g → smooth I' I (f / g)", "decl_nm": "smooth.div"
{"src": "𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	H : Type u_2,	_inst_2 : topological_space H,	E : Type u_3,	_inst_3 : normed_group E,	_inst_4 : normed_space 𝕜 E,	I : model_with_corners 𝕜 E H,	G : Type u_5,	_inst_7 : topological_space G,	_inst_8 : charted_space H G,	_inst_9 : group G,	_inst_10 : lie_group I G,	E' : Type u_6,	_inst_11 : normed_group E',	_inst_12 : normed_space 𝕜 E',	H' : Type u_7,	_inst_13 : topological_space H',	I' : model_with_corners 𝕜 E' H',	M : Type u_8,	_inst_14 : topological_space M,	_inst_15 : charted_space H' M,	f g : M → G,	hf : smooth I' I f,	hg : smooth I' I g	⊢ smooth I' I (f / g)", "decl_nm": "smooth.div"
{"src": "𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	H : Type u_2,	_inst_2 : topological_space H,	E : Type u_3,	_inst_3 : normed_group E,	_inst_4 : normed_space 𝕜 E,	I : model_with_corners 𝕜 E H,	G : Type u_5,	_inst_7 : topological_space G,	_inst_8 : charted_space H G,	_inst_9 : group G,	_inst_10 : lie_group I G,	E' : Type u_6,	_inst_11 : normed_group E',	_inst_12 : normed_space 𝕜 E',	H' : Type u_7,	_inst_13 : topological_space H',	I' : model_with_corners 𝕜 E' H',	M : Type u_8,	_inst_14 : topological_space M,	_inst_15 : charted_space H' M,	f g : M → G,	hf : smooth I' I f,	hg : smooth I' I g	⊢ smooth I' I (f * g⁻¹)", "decl_nm": "smooth.div"
{"src": "⊢ ∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field 𝕜] {E : Type u_2} [_inst_2 : normed_group E]	  [_inst_3 : normed_space 𝕜 E] {H : Type u_3} [_inst_4 : topological_space H] (I : model_with_corners 𝕜 E H)	  (p : tangent_bundle I H), ⇑((chart_at (model_prod H E) p).symm) = ⇑((equiv.sigma_equiv_prod H E).symm)", "decl_nm": "tangent_bundle_model_space_coe_chart_at_symm"
{"src": "𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	p : tangent_bundle I H	⊢ ⇑((chart_at (model_prod H E) p).symm) = ⇑((equiv.sigma_equiv_prod H E).symm)", "decl_nm": "tangent_bundle_model_space_coe_chart_at_symm"
{"src": "𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	p : tangent_bundle I H	⊢ (chart_at (model_prod H E) p).symm.to_local_equiv.to_fun = (equiv.sigma_equiv_prod H E).symm.to_fun", "decl_nm": "tangent_bundle_model_space_coe_chart_at_symm"
{"src": "⊢ ∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field 𝕜] {E : Type u_2} [_inst_2 : normed_group E]	  [_inst_3 : normed_space 𝕜 E] {E' : Type u_3} [_inst_4 : normed_group E'] [_inst_5 : normed_space 𝕜 E']	  {F : Type u_4} [_inst_6 : normed_group F] [_inst_7 : normed_space 𝕜 F] {H : Type u_5}	  [_inst_8 : topological_space H] {H' : Type u_6} [_inst_9 : topological_space H'] {G : Type u_7}	  [_inst_10 : topological_space G] {I : model_with_corners 𝕜 E H} {I' : model_with_corners 𝕜 E' H'}	  {J : model_with_corners 𝕜 F G} {M : Type u_8} [_inst_11 : topological_space M] [_inst_12 : charted_space H M]	  {M' : Type u_9} [_inst_13 : topological_space M'] [_inst_14 : charted_space H' M'] {N : Type u_10}	  [_inst_15 : topological_space N] [_inst_16 : charted_space G N] {n m : with_top ℕ} (h : diffeomorph I J M N n)	  {f : N → M'} {s : set M} {x : M},	    m ≤ n →	    (times_cont_mdiff_within_at I I' m (f ∘ ⇑h) s x ↔	       times_cont_mdiff_within_at J I' m f (⇑(h.symm) ⁻¹' s) (⇑h x))", "decl_nm": "diffeomorph.times_cont_mdiff_within_at_comp_diffeomorph_iff"
{"src": "𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	E' : Type u_3,	_inst_4 : normed_group E',	_inst_5 : normed_space 𝕜 E',	F : Type u_4,	_inst_6 : normed_group F,	_inst_7 : normed_space 𝕜 F,	H : Type u_5,	_inst_8 : topological_space H,	H' : Type u_6,	_inst_9 : topological_space H',	G : Type u_7,	_inst_10 : topological_space G,	I : model_with_corners 𝕜 E H,	I' : model_with_corners 𝕜 E' H',	J : model_with_corners 𝕜 F G,	M : Type u_8,	_inst_11 : topological_space M,	_inst_12 : charted_space H M,	M' : Type u_9,	_inst_13 : topological_space M',	_inst_14 : charted_space H' M',	N : Type u_10,	_inst_15 : topological_space N,	_inst_16 : charted_space G N,	n m : with_top ℕ,	h : diffeomorph I J M N n,	f : N → M',	s : set M,	x : M,	hm : m ≤ n	⊢ times_cont_mdiff_within_at I I' m (f ∘ ⇑h) s x ↔	    times_cont_mdiff_within_at J I' m f (⇑(h.symm) ⁻¹' s) (⇑h x)", "decl_nm": "diffeomorph.times_cont_mdiff_within_at_comp_diffeomorph_iff"
{"src": "2 goals	𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	E' : Type u_3,	_inst_4 : normed_group E',	_inst_5 : normed_space 𝕜 E',	F : Type u_4,	_inst_6 : normed_group F,	_inst_7 : normed_space 𝕜 F,	H : Type u_5,	_inst_8 : topological_space H,	H' : Type u_6,	_inst_9 : topological_space H',	G : Type u_7,	_inst_10 : topological_space G,	I : model_with_corners 𝕜 E H,	I' : model_with_corners 𝕜 E' H',	J : model_with_corners 𝕜 F G,	M : Type u_8,	_inst_11 : topological_space M,	_inst_12 : charted_space H M,	M' : Type u_9,	_inst_13 : topological_space M',	_inst_14 : charted_space H' M',	N : Type u_10,	_inst_15 : topological_space N,	_inst_16 : charted_space G N,	n m : with_top ℕ,	h : diffeomorph I J M N n,	f : N → M',	s : set M,	x : M,	hm : m ≤ n	⊢ times_cont_mdiff_within_at I I' m (f ∘ ⇑h) s x →	  times_cont_mdiff_within_at J I' m f (⇑(h.symm) ⁻¹' s) (⇑h x)		𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	E' : Type u_3,	_inst_4 : normed_group E',	_inst_5 : normed_space 𝕜 E',	F : Type u_4,	_inst_6 : normed_group F,	_inst_7 : normed_space 𝕜 F,	H : Type u_5,	_inst_8 : topological_space H,	H' : Type u_6,	_inst_9 : topological_space H',	G : Type u_7,	_inst_10 : topological_space G,	I : model_with_corners 𝕜 E H,	I' : model_with_corners 𝕜 E' H',	J : model_with_corners 𝕜 F G,	M : Type u_8,	_inst_11 : topological_space M,	_inst_12 : charted_space H M,	M' : Type u_9,	_inst_13 : topological_space M',	_inst_14 : charted_space H' M',	N : Type u_10,	_inst_15 : topological_space N,	_inst_16 : charted_space G N,	n m : with_top ℕ,	h : diffeomorph I J M N n,	f : N → M',	s : set M,	x : M,	hm : m ≤ n	⊢ times_cont_mdiff_within_at J I' m f (⇑(h.symm) ⁻¹' s) (⇑h x) →	  times_cont_mdiff_within_at I I' m (f ∘ ⇑h) s x", "decl_nm": "diffeomorph.times_cont_mdiff_within_at_comp_diffeomorph_iff"
{"src": "2 goals	𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	E' : Type u_3,	_inst_4 : normed_group E',	_inst_5 : normed_space 𝕜 E',	F : Type u_4,	_inst_6 : normed_group F,	_inst_7 : normed_space 𝕜 F,	H : Type u_5,	_inst_8 : topological_space H,	H' : Type u_6,	_inst_9 : topological_space H',	G : Type u_7,	_inst_10 : topological_space G,	I : model_with_corners 𝕜 E H,	I' : model_with_corners 𝕜 E' H',	J : model_with_corners 𝕜 F G,	M : Type u_8,	_inst_11 : topological_space M,	_inst_12 : charted_space H M,	M' : Type u_9,	_inst_13 : topological_space M',	_inst_14 : charted_space H' M',	N : Type u_10,	_inst_15 : topological_space N,	_inst_16 : charted_space G N,	n m : with_top ℕ,	h : diffeomorph I J M N n,	f : N → M',	s : set M,	x : M,	hm : m ≤ n,	Hfh : times_cont_mdiff_within_at I I' m (f ∘ ⇑h) s x	⊢ times_cont_mdiff_within_at J I' m f (⇑(h.symm) ⁻¹' s) (⇑h x)		𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	E' : Type u_3,	_inst_4 : normed_group E',	_inst_5 : normed_space 𝕜 E',	F : Type u_4,	_inst_6 : normed_group F,	_inst_7 : normed_space 𝕜 F,	H : Type u_5,	_inst_8 : topological_space H,	H' : Type u_6,	_inst_9 : topological_space H',	G : Type u_7,	_inst_10 : topological_space G,	I : model_with_corners 𝕜 E H,	I' : model_with_corners 𝕜 E' H',	J : model_with_corners 𝕜 F G,	M : Type u_8,	_inst_11 : topological_space M,	_inst_12 : charted_space H M,	M' : Type u_9,	_inst_13 : topological_space M',	_inst_14 : charted_space H' M',	N : Type u_10,	_inst_15 : topological_space N,	_inst_16 : charted_space G N,	n m : with_top ℕ,	h : diffeomorph I J M N n,	f : N → M',	s : set M,	x : M,	hm : m ≤ n	⊢ times_cont_mdiff_within_at J I' m f (⇑(h.symm) ⁻¹' s) (⇑h x) →	  times_cont_mdiff_within_at I I' m (f ∘ ⇑h) s x", "decl_nm": "diffeomorph.times_cont_mdiff_within_at_comp_diffeomorph_iff"
{"src": "2 goals	𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	E' : Type u_3,	_inst_4 : normed_group E',	_inst_5 : normed_space 𝕜 E',	F : Type u_4,	_inst_6 : normed_group F,	_inst_7 : normed_space 𝕜 F,	H : Type u_5,	_inst_8 : topological_space H,	H' : Type u_6,	_inst_9 : topological_space H',	G : Type u_7,	_inst_10 : topological_space G,	I : model_with_corners 𝕜 E H,	I' : model_with_corners 𝕜 E' H',	J : model_with_corners 𝕜 F G,	M : Type u_8,	_inst_11 : topological_space M,	_inst_12 : charted_space H M,	M' : Type u_9,	_inst_13 : topological_space M',	_inst_14 : charted_space H' M',	N : Type u_10,	_inst_15 : topological_space N,	_inst_16 : charted_space G N,	n m : with_top ℕ,	h : diffeomorph I J M N n,	f : N → M',	s : set M,	x : M,	hm : m ≤ n,	Hfh : times_cont_mdiff_within_at I I' m (f ∘ ⇑h) s (⇑(h.symm) (⇑h x))	⊢ times_cont_mdiff_within_at J I' m f (⇑(h.symm) ⁻¹' s) (⇑h x)		𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	E' : Type u_3,	_inst_4 : normed_group E',	_inst_5 : normed_space 𝕜 E',	F : Type u_4,	_inst_6 : normed_group F,	_inst_7 : normed_space 𝕜 F,	H : Type u_5,	_inst_8 : topological_space H,	H' : Type u_6,	_inst_9 : topological_space H',	G : Type u_7,	_inst_10 : topological_space G,	I : model_with_corners 𝕜 E H,	I' : model_with_corners 𝕜 E' H',	J : model_with_corners 𝕜 F G,	M : Type u_8,	_inst_11 : topological_space M,	_inst_12 : charted_space H M,	M' : Type u_9,	_inst_13 : topological_space M',	_inst_14 : charted_space H' M',	N : Type u_10,	_inst_15 : topological_space N,	_inst_16 : charted_space G N,	n m : with_top ℕ,	h : diffeomorph I J M N n,	f : N → M',	s : set M,	x : M,	hm : m ≤ n	⊢ times_cont_mdiff_within_at J I' m f (⇑(h.symm) ⁻¹' s) (⇑h x) →	  times_cont_mdiff_within_at I I' m (f ∘ ⇑h) s x", "decl_nm": "diffeomorph.times_cont_mdiff_within_at_comp_diffeomorph_iff"
{"src": "𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	E' : Type u_3,	_inst_4 : normed_group E',	_inst_5 : normed_space 𝕜 E',	F : Type u_4,	_inst_6 : normed_group F,	_inst_7 : normed_space 𝕜 F,	H : Type u_5,	_inst_8 : topological_space H,	H' : Type u_6,	_inst_9 : topological_space H',	G : Type u_7,	_inst_10 : topological_space G,	I : model_with_corners 𝕜 E H,	I' : model_with_corners 𝕜 E' H',	J : model_with_corners 𝕜 F G,	M : Type u_8,	_inst_11 : topological_space M,	_inst_12 : charted_space H M,	M' : Type u_9,	_inst_13 : topological_space M',	_inst_14 : charted_space H' M',	N : Type u_10,	_inst_15 : topological_space N,	_inst_16 : charted_space G N,	n m : with_top ℕ,	h : diffeomorph I J M N n,	f : N → M',	s : set M,	x : M,	hm : m ≤ n	⊢ times_cont_mdiff_within_at J I' m f (⇑(h.symm) ⁻¹' s) (⇑h x) →	  times_cont_mdiff_within_at I I' m (f ∘ ⇑h) s x", "decl_nm": "diffeomorph.times_cont_mdiff_within_at_comp_diffeomorph_iff"
{"src": "𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	E' : Type u_3,	_inst_4 : normed_group E',	_inst_5 : normed_space 𝕜 E',	F : Type u_4,	_inst_6 : normed_group F,	_inst_7 : normed_space 𝕜 F,	H : Type u_5,	_inst_8 : topological_space H,	H' : Type u_6,	_inst_9 : topological_space H',	G : Type u_7,	_inst_10 : topological_space G,	I : model_with_corners 𝕜 E H,	I' : model_with_corners 𝕜 E' H',	J : model_with_corners 𝕜 F G,	M : Type u_8,	_inst_11 : topological_space M,	_inst_12 : charted_space H M,	M' : Type u_9,	_inst_13 : topological_space M',	_inst_14 : charted_space H' M',	N : Type u_10,	_inst_15 : topological_space N,	_inst_16 : charted_space G N,	n m : with_top ℕ,	h : diffeomorph I J M N n,	f : N → M',	s : set M,	x : M,	hm : m ≤ n	⊢ times_cont_mdiff_within_at J I' m f (⇑h '' s) (⇑h x) → times_cont_mdiff_within_at I I' m (f ∘ ⇑h) s x", "decl_nm": "diffeomorph.times_cont_mdiff_within_at_comp_diffeomorph_iff"
{"src": "⊢ ∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field 𝕜] {E : Type u_2} [_inst_2 : normed_group E]	  [_inst_3 : normed_space 𝕜 E] {H : Type u_3} [_inst_4 : topological_space H] {I : model_with_corners 𝕜 E H}	  {M : Type u_4} [_inst_5 : topological_space M] [_inst_6 : charted_space H M] {x : M} {s : set M},	    x ∈ s → is_open s → unique_mdiff_within_at I s x", "decl_nm": "is_open.unique_mdiff_within_at"
{"src": "𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	M : Type u_4,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	x : M,	s : set M,	xs : x ∈ s,	hs : is_open s	⊢ unique_mdiff_within_at I s x", "decl_nm": "is_open.unique_mdiff_within_at"
{"src": "𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	M : Type u_4,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	x : M,	s : set M,	xs : x ∈ s,	hs : is_open s,	this : unique_mdiff_within_at I (univ ∩ s) x	⊢ unique_mdiff_within_at I s x", "decl_nm": "is_open.unique_mdiff_within_at"
{"src": "⊢ ∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field 𝕜] {E : Type u_2} [_inst_2 : normed_group E]	  [_inst_3 : normed_space 𝕜 E] {H : Type u_3} [_inst_4 : topological_space H] (I : model_with_corners 𝕜 E H),	    times_cont_diff_groupoid 0 I = continuous_groupoid H", "decl_nm": "times_cont_diff_groupoid_zero_eq"
{"src": "𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H	⊢ times_cont_diff_groupoid 0 I = continuous_groupoid H", "decl_nm": "times_cont_diff_groupoid_zero_eq"
{"src": "𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H	⊢ ⊤ ≤ times_cont_diff_groupoid 0 I", "decl_nm": "times_cont_diff_groupoid_zero_eq"
{"src": "𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	u : local_homeomorph H H,	hu : u ∈ ⊤.members	⊢ u ∈ (times_cont_diff_groupoid 0 I).members", "decl_nm": "times_cont_diff_groupoid_zero_eq"
{"src": "𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	u : local_homeomorph H H,	hu : u ∈ ⊤.members	⊢ u ∈ times_cont_diff_groupoid 0 I", "decl_nm": "times_cont_diff_groupoid_zero_eq"
{"src": "𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	u : local_homeomorph H H,	hu : u ∈ ⊤.members	⊢ {property := λ (f : H → H) (s : set H),	                   times_cont_diff_on 𝕜 0 (⇑I ∘ f ∘ ⇑(I.symm)) (⇑(I.symm) ⁻¹' s ∩ range ⇑I),	     comp := _,	     id_mem := _,	     locality := _,	     congr := _}.property	      ⇑u	      u.to_local_equiv.source ∧	    {property := λ (f : H → H) (s : set H),	                   times_cont_diff_on 𝕜 0 (⇑I ∘ f ∘ ⇑(I.symm)) (⇑(I.symm) ⁻¹' s ∩ range ⇑I),	     comp := _,	     id_mem := _,	     locality := _,	     congr := _}.property	      ⇑(u.symm)	      u.to_local_equiv.target", "decl_nm": "times_cont_diff_groupoid_zero_eq"
{"src": "𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	u : local_homeomorph H H,	hu : u ∈ ⊤.members	⊢ continuous_on (⇑I ∘ ⇑u ∘ ⇑(I.symm)) (⇑(I.symm) ⁻¹' u.to_local_equiv.source ∩ range ⇑I) ∧	    continuous_on (⇑I ∘ ⇑(u.symm) ∘ ⇑(I.symm)) (⇑(I.symm) ⁻¹' u.to_local_equiv.target ∩ range ⇑I)", "decl_nm": "times_cont_diff_groupoid_zero_eq"
{"src": "2 goals	𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	u : local_homeomorph H H,	hu : u ∈ ⊤.members	⊢ continuous_on (⇑I ∘ ⇑u ∘ ⇑(I.symm)) (⇑(I.symm) ⁻¹' u.to_local_equiv.source ∩ range ⇑I)		𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	u : local_homeomorph H H,	hu : u ∈ ⊤.members	⊢ continuous_on (⇑I ∘ ⇑(u.symm) ∘ ⇑(I.symm)) (⇑(I.symm) ⁻¹' u.to_local_equiv.target ∩ range ⇑I)", "decl_nm": "times_cont_diff_groupoid_zero_eq"
{"src": "2 goals	𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	u : local_homeomorph H H,	hu : u ∈ ⊤.members	⊢ continuous_on (⇑u ∘ ⇑(I.symm)) (⇑(I.symm) ⁻¹' u.to_local_equiv.source ∩ range ⇑I)		𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	u : local_homeomorph H H,	hu : u ∈ ⊤.members	⊢ continuous_on (⇑I ∘ ⇑(u.symm) ∘ ⇑(I.symm)) (⇑(I.symm) ⁻¹' u.to_local_equiv.target ∩ range ⇑I)", "decl_nm": "times_cont_diff_groupoid_zero_eq"
{"src": "𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	u : local_homeomorph H H,	hu : u ∈ ⊤.members	⊢ continuous_on (⇑I ∘ ⇑(u.symm) ∘ ⇑(I.symm)) (⇑(I.symm) ⁻¹' u.to_local_equiv.target ∩ range ⇑I)", "decl_nm": "times_cont_diff_groupoid_zero_eq"
{"src": "𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	u : local_homeomorph H H,	hu : u ∈ ⊤.members	⊢ continuous_on (⇑(u.symm) ∘ ⇑(I.symm)) (⇑(I.symm) ⁻¹' u.to_local_equiv.target ∩ range ⇑I)", "decl_nm": "times_cont_diff_groupoid_zero_eq"
{"src": "⊢ ∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field 𝕜] {E : Type u_2} [_inst_2 : normed_group E]	  [_inst_3 : normed_space 𝕜 E] {H : Type u_3} [_inst_4 : topological_space H] {I : model_with_corners 𝕜 E H}	  {M : Type u_4} [_inst_5 : topological_space M] [_inst_6 : charted_space H M] [Is : smooth_manifold_with_corners I M]	  {x : M} {n : with_top ℕ} {x' : M},	    x' ∈ (chart_at H x).to_local_equiv.source →	    times_cont_mdiff_at I (model_with_corners_self 𝕜 E) n ⇑(ext_chart_at I x) x'", "decl_nm": "times_cont_mdiff_at_ext_chart_at'"
{"src": "𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	M : Type u_4,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	Is : smooth_manifold_with_corners I M,	x : M,	n : with_top ℕ,	x' : M,	h : x' ∈ (chart_at H x).to_local_equiv.source	⊢ times_cont_mdiff_at I (model_with_corners_self 𝕜 E) n ⇑(ext_chart_at I x) x'", "decl_nm": "times_cont_mdiff_at_ext_chart_at'"
{"src": "𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	M : Type u_4,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	Is : smooth_manifold_with_corners I M,	x : M,	n : with_top ℕ,	x' : M,	h : x' ∈ (chart_at H x).to_local_equiv.source	⊢ continuous_within_at ⇑(ext_chart_at I x) univ x' ∧	    times_cont_diff_within_at 𝕜 n	      (⇑(ext_chart_at (model_with_corners_self 𝕜 E) (⇑(ext_chart_at I x) x')) ∘	         ⇑(ext_chart_at I x) ∘ ⇑((ext_chart_at I x).symm))	      ((ext_chart_at I x).target ∩	         ⇑((ext_chart_at I x).symm) ⁻¹'	           (univ ∩	              ⇑(ext_chart_at I x) ⁻¹'	                (ext_chart_at (model_with_corners_self 𝕜 E) (⇑(ext_chart_at I x) x')).source))	      (⇑(ext_chart_at I x) x')", "decl_nm": "times_cont_mdiff_at_ext_chart_at'"
{"src": "2 goals	𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	M : Type u_4,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	Is : smooth_manifold_with_corners I M,	x : M,	n : with_top ℕ,	x' : M,	h : x' ∈ (chart_at H x).to_local_equiv.source	⊢ x' ∈ (ext_chart_at I x).source		𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	M : Type u_4,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	Is : smooth_manifold_with_corners I M,	x : M,	n : with_top ℕ,	x' : M,	h : x' ∈ (chart_at H x).to_local_equiv.source	⊢ times_cont_diff_within_at 𝕜 n	    (⇑(ext_chart_at (model_with_corners_self 𝕜 E) (⇑(ext_chart_at I x) x')) ∘	       ⇑(ext_chart_at I x) ∘ ⇑((ext_chart_at I x).symm))	    ((ext_chart_at I x).target ∩	       ⇑((ext_chart_at I x).symm) ⁻¹'	         (univ ∩	            ⇑(ext_chart_at I x) ⁻¹'	              (ext_chart_at (model_with_corners_self 𝕜 E) (⇑(ext_chart_at I x) x')).source))	    (⇑(ext_chart_at I x) x')", "decl_nm": "times_cont_mdiff_at_ext_chart_at'"
{"src": "𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	M : Type u_4,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	Is : smooth_manifold_with_corners I M,	x : M,	n : with_top ℕ,	x' : M,	h : x' ∈ (chart_at H x).to_local_equiv.source	⊢ times_cont_diff_within_at 𝕜 n	    (⇑(ext_chart_at (model_with_corners_self 𝕜 E) (⇑(ext_chart_at I x) x')) ∘	       ⇑(ext_chart_at I x) ∘ ⇑((ext_chart_at I x).symm))	    ((ext_chart_at I x).target ∩	       ⇑((ext_chart_at I x).symm) ⁻¹'	         (univ ∩	            ⇑(ext_chart_at I x) ⁻¹'	              (ext_chart_at (model_with_corners_self 𝕜 E) (⇑(ext_chart_at I x) x')).source))	    (⇑(ext_chart_at I x) x')", "decl_nm": "times_cont_mdiff_at_ext_chart_at'"
{"src": "2 goals	𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	M : Type u_4,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	Is : smooth_manifold_with_corners I M,	x : M,	n : with_top ℕ,	x' : M,	h : x' ∈ (chart_at H x).to_local_equiv.source	⊢ ∀ (y : E),	    y ∈	      (ext_chart_at I x).target ∩	        ⇑((ext_chart_at I x).symm) ⁻¹'	          (univ ∩	             ⇑(ext_chart_at I x) ⁻¹'	               (ext_chart_at (model_with_corners_self 𝕜 E) (⇑(ext_chart_at I x) x')).source) →	    (⇑(ext_chart_at (model_with_corners_self 𝕜 E) (⇑(ext_chart_at I x) x')) ∘	         ⇑(ext_chart_at I x) ∘ ⇑((ext_chart_at I x).symm))	        y =	      id y		𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	M : Type u_4,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	Is : smooth_manifold_with_corners I M,	x : M,	n : with_top ℕ,	x' : M,	h : x' ∈ (chart_at H x).to_local_equiv.source	⊢ ⇑(ext_chart_at I x) x' ∈	    (ext_chart_at I x).target ∩	      ⇑((ext_chart_at I x).symm) ⁻¹'	        (univ ∩	           ⇑(ext_chart_at I x) ⁻¹'	             (ext_chart_at (model_with_corners_self 𝕜 E) (⇑(ext_chart_at I x) x')).source)", "decl_nm": "times_cont_mdiff_at_ext_chart_at'"
{"src": "𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	M : Type u_4,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	Is : smooth_manifold_with_corners I M,	x : M,	n : with_top ℕ,	x' : M,	h : x' ∈ (chart_at H x).to_local_equiv.source	⊢ ⇑(ext_chart_at I x) x' ∈	    (ext_chart_at I x).target ∩	      ⇑((ext_chart_at I x).symm) ⁻¹'	        (univ ∩	           ⇑(ext_chart_at I x) ⁻¹'	             (ext_chart_at (model_with_corners_self 𝕜 E) (⇑(ext_chart_at I x) x')).source)", "decl_nm": "times_cont_mdiff_at_ext_chart_at'"
{"src": "⊢ ∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field 𝕜] {E : Type u_2} [_inst_2 : normed_group E]	  [_inst_3 : normed_space 𝕜 E] {H : Type u_3} [_inst_4 : topological_space H] {I : model_with_corners 𝕜 E H}	  {M : Type u_4} [_inst_5 : topological_space M] [_inst_6 : charted_space H M] [Is : smooth_manifold_with_corners I M]	  {E' : Type u_5} [_inst_7 : normed_group E'] [_inst_8 : normed_space 𝕜 E'] {H' : Type u_6}	  [_inst_9 : topological_space H'] {I' : model_with_corners 𝕜 E' H'} {M' : Type u_7}	  [_inst_10 : topological_space M'] [_inst_11 : charted_space H' M'] [I's : smooth_manifold_with_corners I' M']	  {f : M → M'} {x : M} {n : ℕ},	    times_cont_mdiff_at I I' ↑n f x ↔ ∃ (u : set M) (H_1 : u ∈ nhds x), times_cont_mdiff_on I I' ↑n f u", "decl_nm": "times_cont_mdiff_at_iff_times_cont_mdiff_on_nhds"
{"src": "𝕜 : Type u_1,	_inst_1 : nondiscrete_normed_field 𝕜,	E : Type u_2,	_inst_2 : normed_group E,	_inst_3 : normed_space 𝕜 E,	H : Type u_3,	_inst_4 : topological_space H,	I : model_with_corners 𝕜 E H,	M : Type u_4,	_inst_5 : topological_space M,	_inst_6 : charted_space H M,	Is : smooth_manifold_with_corners I M,	E' : Type u_5,	_inst_7 : normed_group E',	_inst_8 : normed_space 𝕜 E',	H' : Type u_6,	_inst_9 : topological_space H',	I' : model_with_corners 𝕜 E' H',	M' : Type u_7,	_inst_10 : topological_space M',	_inst_11 : charted_space H' M',	I's : smooth_manifold_with_corners I' M',	f : M → M',	x : M,	n : ℕ	⊢ times_cont_mdiff_at I I' ↑n f x ↔ ∃ (u : set M) (H_1 : u ∈ nhds x), times_cont_mdiff_on I I' ↑n f u", "decl_nm": "times_cont_mdiff_at_iff_times_cont_mdiff_on_nhds"
{"src": "⊢ ∀ {α : Type u_1} [_inst_1 : group α] [_inst_2 : fintype α] (s : subgroup α) [_inst_3 : fintype ↥s]	  [_inst_4 : decidable_pred (λ (a : α), a ∈ s)], fintype.card α = fintype.card (α ⧸ s) * fintype.card ↥s", "decl_nm": "subgroup.card_eq_card_quotient_mul_card_subgroup"
{"src": "α : Type u_1,	_inst_1 : group α,	_inst_2 : fintype α,	s : subgroup α,	_inst_3 : fintype ↥s,	_inst_4 : decidable_pred (λ (a : α), a ∈ s)	⊢ fintype.card α = fintype.card (α ⧸ s) * fintype.card ↥s", "decl_nm": "subgroup.card_eq_card_quotient_mul_card_subgroup"
{"src": "α : Type u_1,	_inst_1 : group α,	_inst_2 : fintype α,	s : subgroup α,	_inst_3 : fintype ↥s,	_inst_4 : decidable_pred (λ (a : α), a ∈ s)	⊢ fintype.card α = fintype.card ((α ⧸ s) × ↥s)", "decl_nm": "subgroup.card_eq_card_quotient_mul_card_subgroup"
{"src": "⊢ ∀ {ι : Type u_1} {M : ι → Type u_2} [_inst_1 : Π (i : ι), monoid (M i)]	  [_inst_3 : Π (i : ι), decidable_eq (M i)] {i : ι}, function.injective word.rcons", "decl_nm": "free_product.word.rcons_inj"
{"src": "ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι	⊢ function.injective word.rcons", "decl_nm": "free_product.word.rcons_inj"
{"src": "ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : word M,	h : w.fst_idx ≠ some i,	m' : M i,	w' : word M,	h' : w'.fst_idx ≠ some i,	he : word.rcons {head := m, tail := w, fst_idx_ne := h} = word.rcons {head := m', tail := w', fst_idx_ne := h'}	⊢ {head := m, tail := w, fst_idx_ne := h} = {head := m', tail := w', fst_idx_ne := h'}", "decl_nm": "free_product.word.rcons_inj"
{"src": "2 goals	ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : word M,	h : w.fst_idx ≠ some i,	m' : M i,	w' : word M,	h' : w'.fst_idx ≠ some i,	he : word.rcons {head := m, tail := w, fst_idx_ne := h} = word.rcons {head := m', tail := w', fst_idx_ne := h'},	hm : m = 1	⊢ {head := m, tail := w, fst_idx_ne := h} = {head := m', tail := w', fst_idx_ne := h'}		ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : word M,	h : w.fst_idx ≠ some i,	m' : M i,	w' : word M,	h' : w'.fst_idx ≠ some i,	he : word.rcons {head := m, tail := w, fst_idx_ne := h} = word.rcons {head := m', tail := w', fst_idx_ne := h'},	hm : ¬m = 1	⊢ {head := m, tail := w, fst_idx_ne := h} = {head := m', tail := w', fst_idx_ne := h'}", "decl_nm": "free_product.word.rcons_inj"
{"src": "3 goals	ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : word M,	h : w.fst_idx ≠ some i,	m' : M i,	w' : word M,	h' : w'.fst_idx ≠ some i,	he : word.rcons {head := m, tail := w, fst_idx_ne := h} = word.rcons {head := m', tail := w', fst_idx_ne := h'},	hm : m = 1,	hm' : m' = 1	⊢ {head := m, tail := w, fst_idx_ne := h} = {head := m', tail := w', fst_idx_ne := h'}		ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : word M,	h : w.fst_idx ≠ some i,	m' : M i,	w' : word M,	h' : w'.fst_idx ≠ some i,	he : word.rcons {head := m, tail := w, fst_idx_ne := h} = word.rcons {head := m', tail := w', fst_idx_ne := h'},	hm : m = 1,	hm' : ¬m' = 1	⊢ {head := m, tail := w, fst_idx_ne := h} = {head := m', tail := w', fst_idx_ne := h'}		ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : word M,	h : w.fst_idx ≠ some i,	m' : M i,	w' : word M,	h' : w'.fst_idx ≠ some i,	he : word.rcons {head := m, tail := w, fst_idx_ne := h} = word.rcons {head := m', tail := w', fst_idx_ne := h'},	hm : ¬m = 1	⊢ {head := m, tail := w, fst_idx_ne := h} = {head := m', tail := w', fst_idx_ne := h'}", "decl_nm": "free_product.word.rcons_inj"
{"src": "3 goals	ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : word M,	h : w.fst_idx ≠ some i,	m' : M i,	w' : word M,	h' : w'.fst_idx ≠ some i,	hm : m = 1,	hm' : m' = 1,	he : w = w'	⊢ {head := m, tail := w, fst_idx_ne := h} = {head := m', tail := w', fst_idx_ne := h'}		ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : word M,	h : w.fst_idx ≠ some i,	m' : M i,	w' : word M,	h' : w'.fst_idx ≠ some i,	he : word.rcons {head := m, tail := w, fst_idx_ne := h} = word.rcons {head := m', tail := w', fst_idx_ne := h'},	hm : m = 1,	hm' : ¬m' = 1	⊢ {head := m, tail := w, fst_idx_ne := h} = {head := m', tail := w', fst_idx_ne := h'}		ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : word M,	h : w.fst_idx ≠ some i,	m' : M i,	w' : word M,	h' : w'.fst_idx ≠ some i,	he : word.rcons {head := m, tail := w, fst_idx_ne := h} = word.rcons {head := m', tail := w', fst_idx_ne := h'},	hm : ¬m = 1	⊢ {head := m, tail := w, fst_idx_ne := h} = {head := m', tail := w', fst_idx_ne := h'}", "decl_nm": "free_product.word.rcons_inj"
{"src": "2 goals	ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : word M,	h : w.fst_idx ≠ some i,	m' : M i,	w' : word M,	h' : w'.fst_idx ≠ some i,	he : word.rcons {head := m, tail := w, fst_idx_ne := h} = word.rcons {head := m', tail := w', fst_idx_ne := h'},	hm : m = 1,	hm' : ¬m' = 1	⊢ {head := m, tail := w, fst_idx_ne := h} = {head := m', tail := w', fst_idx_ne := h'}		ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : word M,	h : w.fst_idx ≠ some i,	m' : M i,	w' : word M,	h' : w'.fst_idx ≠ some i,	he : word.rcons {head := m, tail := w, fst_idx_ne := h} = word.rcons {head := m', tail := w', fst_idx_ne := h'},	hm : ¬m = 1	⊢ {head := m, tail := w, fst_idx_ne := h} = {head := m', tail := w', fst_idx_ne := h'}", "decl_nm": "free_product.word.rcons_inj"
{"src": "2 goals	ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : word M,	h : w.fst_idx ≠ some i,	m' : M i,	w' : word M,	h' : w'.fst_idx ≠ some i,	he : word.rcons {head := m, tail := w, fst_idx_ne := h} = word.rcons {head := m', tail := w', fst_idx_ne := h'},	hm : m = 1,	hm' : ¬m' = 1	⊢ false		ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : word M,	h : w.fst_idx ≠ some i,	m' : M i,	w' : word M,	h' : w'.fst_idx ≠ some i,	he : word.rcons {head := m, tail := w, fst_idx_ne := h} = word.rcons {head := m', tail := w', fst_idx_ne := h'},	hm : ¬m = 1	⊢ {head := m, tail := w, fst_idx_ne := h} = {head := m', tail := w', fst_idx_ne := h'}", "decl_nm": "free_product.word.rcons_inj"
{"src": "2 goals	ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : word M,	h : w.fst_idx ≠ some i,	m' : M i,	w' : word M,	h' : w'.fst_idx ≠ some i,	hm : m = 1,	hm' : ¬m' = 1,	he : w = {to_list := ⟨i, m'⟩ :: w'.to_list, ne_one := _, chain_ne := _}	⊢ false		ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : word M,	h : w.fst_idx ≠ some i,	m' : M i,	w' : word M,	h' : w'.fst_idx ≠ some i,	he : word.rcons {head := m, tail := w, fst_idx_ne := h} = word.rcons {head := m', tail := w', fst_idx_ne := h'},	hm : ¬m = 1	⊢ {head := m, tail := w, fst_idx_ne := h} = {head := m', tail := w', fst_idx_ne := h'}", "decl_nm": "free_product.word.rcons_inj"
{"src": "2 goals	ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : word M,	m' : M i,	w' : word M,	h' : w'.fst_idx ≠ some i,	hm : m = 1,	hm' : ¬m' = 1,	he : w = {to_list := ⟨i, m'⟩ :: w'.to_list, ne_one := _, chain_ne := _},	h : {to_list := ⟨i, m'⟩ :: w'.to_list, ne_one := _, chain_ne := _}.fst_idx ≠ some i	⊢ false		ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : word M,	h : w.fst_idx ≠ some i,	m' : M i,	w' : word M,	h' : w'.fst_idx ≠ some i,	he : word.rcons {head := m, tail := w, fst_idx_ne := h} = word.rcons {head := m', tail := w', fst_idx_ne := h'},	hm : ¬m = 1	⊢ {head := m, tail := w, fst_idx_ne := h} = {head := m', tail := w', fst_idx_ne := h'}", "decl_nm": "free_product.word.rcons_inj"
{"src": "ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : word M,	h : w.fst_idx ≠ some i,	m' : M i,	w' : word M,	h' : w'.fst_idx ≠ some i,	he : word.rcons {head := m, tail := w, fst_idx_ne := h} = word.rcons {head := m', tail := w', fst_idx_ne := h'},	hm : ¬m = 1	⊢ {head := m, tail := w, fst_idx_ne := h} = {head := m', tail := w', fst_idx_ne := h'}", "decl_nm": "free_product.word.rcons_inj"
{"src": "2 goals	ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : word M,	h : w.fst_idx ≠ some i,	m' : M i,	w' : word M,	h' : w'.fst_idx ≠ some i,	he : word.rcons {head := m, tail := w, fst_idx_ne := h} = word.rcons {head := m', tail := w', fst_idx_ne := h'},	hm : ¬m = 1,	hm' : m' = 1	⊢ {head := m, tail := w, fst_idx_ne := h} = {head := m', tail := w', fst_idx_ne := h'}		ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : word M,	h : w.fst_idx ≠ some i,	m' : M i,	w' : word M,	h' : w'.fst_idx ≠ some i,	he : word.rcons {head := m, tail := w, fst_idx_ne := h} = word.rcons {head := m', tail := w', fst_idx_ne := h'},	hm : ¬m = 1,	hm' : ¬m' = 1	⊢ {head := m, tail := w, fst_idx_ne := h} = {head := m', tail := w', fst_idx_ne := h'}", "decl_nm": "free_product.word.rcons_inj"
{"src": "2 goals	ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : word M,	h : w.fst_idx ≠ some i,	m' : M i,	w' : word M,	h' : w'.fst_idx ≠ some i,	he : word.rcons {head := m, tail := w, fst_idx_ne := h} = word.rcons {head := m', tail := w', fst_idx_ne := h'},	hm : ¬m = 1,	hm' : m' = 1	⊢ false		ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : word M,	h : w.fst_idx ≠ some i,	m' : M i,	w' : word M,	h' : w'.fst_idx ≠ some i,	he : word.rcons {head := m, tail := w, fst_idx_ne := h} = word.rcons {head := m', tail := w', fst_idx_ne := h'},	hm : ¬m = 1,	hm' : ¬m' = 1	⊢ {head := m, tail := w, fst_idx_ne := h} = {head := m', tail := w', fst_idx_ne := h'}", "decl_nm": "free_product.word.rcons_inj"
{"src": "2 goals	ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : word M,	h : w.fst_idx ≠ some i,	m' : M i,	w' : word M,	h' : w'.fst_idx ≠ some i,	hm : ¬m = 1,	hm' : m' = 1,	he : {to_list := ⟨i, m⟩ :: w.to_list, ne_one := _, chain_ne := _} = w'	⊢ false		ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : word M,	h : w.fst_idx ≠ some i,	m' : M i,	w' : word M,	h' : w'.fst_idx ≠ some i,	he : word.rcons {head := m, tail := w, fst_idx_ne := h} = word.rcons {head := m', tail := w', fst_idx_ne := h'},	hm : ¬m = 1,	hm' : ¬m' = 1	⊢ {head := m, tail := w, fst_idx_ne := h} = {head := m', tail := w', fst_idx_ne := h'}", "decl_nm": "free_product.word.rcons_inj"
{"src": "2 goals	ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : word M,	h : w.fst_idx ≠ some i,	m' : M i,	w' : word M,	hm : ¬m = 1,	hm' : m' = 1,	he : {to_list := ⟨i, m⟩ :: w.to_list, ne_one := _, chain_ne := _} = w',	h' : {to_list := ⟨i, m⟩ :: w.to_list, ne_one := _, chain_ne := _}.fst_idx ≠ some i	⊢ false		ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : word M,	h : w.fst_idx ≠ some i,	m' : M i,	w' : word M,	h' : w'.fst_idx ≠ some i,	he : word.rcons {head := m, tail := w, fst_idx_ne := h} = word.rcons {head := m', tail := w', fst_idx_ne := h'},	hm : ¬m = 1,	hm' : ¬m' = 1	⊢ {head := m, tail := w, fst_idx_ne := h} = {head := m', tail := w', fst_idx_ne := h'}", "decl_nm": "free_product.word.rcons_inj"
{"src": "ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : word M,	h : w.fst_idx ≠ some i,	m' : M i,	w' : word M,	h' : w'.fst_idx ≠ some i,	he : word.rcons {head := m, tail := w, fst_idx_ne := h} = word.rcons {head := m', tail := w', fst_idx_ne := h'},	hm : ¬m = 1,	hm' : ¬m' = 1	⊢ {head := m, tail := w, fst_idx_ne := h} = {head := m', tail := w', fst_idx_ne := h'}", "decl_nm": "free_product.word.rcons_inj"
{"src": "2 goals	ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : word M,	h : w.fst_idx ≠ some i,	m' : M i,	w' : word M,	h' : w'.fst_idx ≠ some i,	he : word.rcons {head := m, tail := w, fst_idx_ne := h} = word.rcons {head := m', tail := w', fst_idx_ne := h'},	hm : ¬m = 1,	hm' : ¬m' = 1	⊢ m = m' ∧ w.to_list = w'.to_list		ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : word M,	h : w.fst_idx ≠ some i,	m' : M i,	w' : word M,	h' : w'.fst_idx ≠ some i,	he : word.rcons {head := m, tail := w, fst_idx_ne := h} = word.rcons {head := m', tail := w', fst_idx_ne := h'},	hm : ¬m = 1,	hm' : ¬m' = 1,	this : m = m' ∧ w.to_list = w'.to_list	⊢ {head := m, tail := w, fst_idx_ne := h} = {head := m', tail := w', fst_idx_ne := h'}", "decl_nm": "free_product.word.rcons_inj"
{"src": "ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : word M,	h : w.fst_idx ≠ some i,	m' : M i,	w' : word M,	h' : w'.fst_idx ≠ some i,	he : word.rcons {head := m, tail := w, fst_idx_ne := h} = word.rcons {head := m', tail := w', fst_idx_ne := h'},	hm : ¬m = 1,	hm' : ¬m' = 1,	this : m = m' ∧ w.to_list = w'.to_list	⊢ {head := m, tail := w, fst_idx_ne := h} = {head := m', tail := w', fst_idx_ne := h'}", "decl_nm": "free_product.word.rcons_inj"
{"src": "ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : word M,	h : w.fst_idx ≠ some i,	w' : word M,	h' : w'.fst_idx ≠ some i,	hm : ¬m = 1,	h : w.to_list = w'.to_list,	he : word.rcons {head := m, tail := w, fst_idx_ne := h} = word.rcons {head := m, tail := w', fst_idx_ne := h'},	hm' : ¬m = 1	⊢ {head := m, tail := w, fst_idx_ne := h} = {head := m, tail := w', fst_idx_ne := h'}", "decl_nm": "free_product.word.rcons_inj"
{"src": "ι : Type u_1,	M : ι → Type u_2,	_inst_1 : Π (i : ι), monoid (M i),	_inst_3 : Π (i : ι), decidable_eq (M i),	i : ι,	m : M i,	w : word M,	h : w.fst_idx ≠ some i,	w' : word M,	h' : w'.fst_idx ≠ some i,	hm : ¬m = 1,	h : w.to_list = w'.to_list,	he : word.rcons {head := m, tail := w, fst_idx_ne := h} = word.rcons {head := m, tail := w', fst_idx_ne := h'},	hm' : ¬m = 1	⊢ w = w'", "decl_nm": "free_product.word.rcons_inj"
{"src": "⊢ ∀ {M : Type u_1} {N : Type u_2} {α : Type u_6} {β : Type u_7} [_inst_1 : has_scalar M α]	  [_inst_2 : has_scalar M β] [_inst_3 : has_scalar α β] [_inst_4 : is_scalar_tower M α β] (g : N → M),	    is_scalar_tower N α β", "decl_nm": "has_scalar.comp.is_scalar_tower"
{"src": "M : Type u_1,	N : Type u_2,	α : Type u_6,	β : Type u_7,	_inst_1 : has_scalar M α,	_inst_2 : has_scalar M β,	_inst_3 : has_scalar α β,	_inst_4 : is_scalar_tower M α β,	g : N → M	⊢ is_scalar_tower N α β", "decl_nm": "has_scalar.comp.is_scalar_tower"
{"src": "⊢ ∀ {M : Type u_1} {α : Type u_6} [_inst_1 : has_scalar M α] (p : Prop) [_inst_2 : decidable p] (a : M)	  (b₁ b₂ : α), a • ite p b₁ b₂ = ite p (a • b₁) (a • b₂)", "decl_nm": "smul_ite"
{"src": "M : Type u_1,	α : Type u_6,	_inst_1 : has_scalar M α,	p : Prop,	_inst_2 : decidable p,	a : M,	b₁ b₂ : α	⊢ a • ite p b₁ b₂ = ite p (a • b₁) (a • b₂)", "decl_nm": "smul_ite"
{"src": "2 goals	M : Type u_1,	α : Type u_6,	_inst_1 : has_scalar M α,	p : Prop,	_inst_2 : decidable p,	a : M,	b₁ b₂ : α,	h : p	⊢ a • b₁ = a • b₁		M : Type u_1,	α : Type u_6,	_inst_1 : has_scalar M α,	p : Prop,	_inst_2 : decidable p,	a : M,	b₁ b₂ : α,	h : ¬p	⊢ a • b₂ = a • b₂", "decl_nm": "smul_ite"
{"src": "M : Type u_1,	α : Type u_6,	_inst_1 : has_scalar M α,	p : Prop,	_inst_2 : decidable p,	a : M,	b₁ b₂ : α,	h : ¬p	⊢ a • b₂ = a • b₂", "decl_nm": "smul_ite"
{"src": "⊢ ∀ {G : Type u} [_inst_1 : groupoid G] [_inst_2 : is_free_groupoid G]	  (T : wide_subquiver (symmetrify (generators G))) [_inst_3 : arborescence ↥T] {a : G} (p : path (root ↥T) a),	    spanning_tree.tree_hom T a = spanning_tree.hom_of_path T p", "decl_nm": "is_free_groupoid.spanning_tree.tree_hom_eq"
{"src": "G : Type u,	_inst_1 : groupoid G,	_inst_2 : is_free_groupoid G,	T : wide_subquiver (symmetrify (generators G)),	_inst_3 : arborescence ↥T,	a : G,	p : path (root ↥T) a	⊢ spanning_tree.tree_hom T a = spanning_tree.hom_of_path T p", "decl_nm": "is_free_groupoid.spanning_tree.tree_hom_eq"
{"src": "⊢ ∀ {G : Type u_1} [_inst_1 : group G] {H : Type u_2} [_inst_3 : group H] (f : G →* H) (n : ℕ),	    map f (lower_central_series G n) ≤ lower_central_series H n", "decl_nm": "lower_central_series.map"
{"src": "G : Type u_1,	_inst_1 : group G,	H : Type u_2,	_inst_3 : group H,	f : G →* H,	n : ℕ	⊢ map f (lower_central_series G n) ≤ lower_central_series H n", "decl_nm": "lower_central_series.map"
{"src": "2 goals	case nat.zero	G : Type u_1,	_inst_1 : group G,	H : Type u_2,	_inst_3 : group H,	f : G →* H	⊢ map f (lower_central_series G 0) ≤ lower_central_series H 0		case nat.succ	G : Type u_1,	_inst_1 : group G,	H : Type u_2,	_inst_3 : group H,	f : G →* H,	d : ℕ,	hd : map f (lower_central_series G d) ≤ lower_central_series H d	⊢ map f (lower_central_series G d.succ) ≤ lower_central_series H d.succ", "decl_nm": "lower_central_series.map"
{"src": "case nat.succ	G : Type u_1,	_inst_1 : group G,	H : Type u_2,	_inst_3 : group H,	f : G →* H,	d : ℕ,	hd : map f (lower_central_series G d) ≤ lower_central_series H d	⊢ map f (lower_central_series G d.succ) ≤ lower_central_series H d.succ", "decl_nm": "lower_central_series.map"
{"src": "G : Type u_1,	_inst_1 : group G,	H : Type u_2,	_inst_3 : group H,	f : G →* H,	d : ℕ,	hd : map f (lower_central_series G d) ≤ lower_central_series H d,	x : G,	hx : x ∈ lower_central_series G d.succ	⊢ ⇑f x ∈ lower_central_series H d.succ", "decl_nm": "lower_central_series.map"
{"src": "G : Type u_1,	_inst_1 : group G,	H : Type u_2,	_inst_3 : group H,	f : G →* H,	d : ℕ,	hd : map f (lower_central_series G d) ≤ lower_central_series H d,	x : G,	hx : x ∈ lower_central_series G d.succ	⊢ ∀ (x : G),	    x ∈	      {x :	         G | ∃ (p : G) (H : p ∈ lower_central_series G d) (q : G) (H : q ∈ ⊤), p * q * p⁻¹ * q⁻¹ = x} →	    ⇑f x ∈ lower_central_series H d.succ", "decl_nm": "lower_central_series.map"
{"src": "G : Type u_1,	_inst_1 : group G,	H : Type u_2,	_inst_3 : group H,	f : G →* H,	d : ℕ,	hd : map f (lower_central_series G d) ≤ lower_central_series H d,	x : G,	hx : x ∈ lower_central_series G d.succ,	y : G,	hy : y ∈ lower_central_series G d,	z : G	⊢ ⇑f (y * z * y⁻¹ * z⁻¹) ∈ lower_central_series H d.succ", "decl_nm": "lower_central_series.map"
{"src": "G : Type u_1,	_inst_1 : group G,	H : Type u_2,	_inst_3 : group H,	f : G →* H,	d : ℕ,	hd : map f (lower_central_series G d) ≤ lower_central_series H d,	x : G,	hx : x ∈ lower_central_series G d.succ,	y : G,	hy : y ∈ lower_central_series G d,	z : G	⊢ ∀ (K : subgroup H),	    {x :	         H | ∃ (p : H) (H_1 : p ∈ lower_central_series H d) (q : H) (H_1 : q ∈ ⊤),	         p * q * p⁻¹ * q⁻¹ = x} ⊆	      ↑K →	    ⇑f (y * z * y⁻¹ * z⁻¹) ∈ K", "decl_nm": "lower_central_series.map"
{"src": "⊢ ∀ {G : Type u} [_inst_1 : monoid G] (x : G), x ^ order_of x = 1", "decl_nm": "pow_order_of_eq_one"
{"src": "G : Type u,	_inst_1 : monoid G,	x : G	⊢ x ^ order_of x = 1", "decl_nm": "pow_order_of_eq_one"
{"src": "G : Type u,	_inst_1 : monoid G,	x : G	⊢ x ^ order_of x = has_mul.mul x^[minimal_period (has_mul.mul x) 1] 1", "decl_nm": "pow_order_of_eq_one"
{"src": "⊢ ∀ {α : Type u_1} [_inst_1 : decidable_eq α] [_inst_2 : fintype α] (f : perm α) (x : α),	    (f.cycle_of x).support ≤ f.support", "decl_nm": "equiv.perm.support_cycle_of_le"
{"src": "α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α,	x : α	⊢ (f.cycle_of x).support ≤ f.support", "decl_nm": "equiv.perm.support_cycle_of_le"
{"src": "α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α,	x y : α,	hy : y ∈ (f.cycle_of x).support	⊢ y ∈ f.support", "decl_nm": "equiv.perm.support_cycle_of_le"
{"src": "α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α,	x y : α,	hy : ite (f.same_cycle x y) (⇑f y) y ≠ y	⊢ y ∈ f.support", "decl_nm": "equiv.perm.support_cycle_of_le"
{"src": "2 goals	α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α,	x y : α,	h : f.same_cycle x y,	hy : ⇑f y ≠ y	⊢ y ∈ f.support		α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α,	x y : α,	h : ¬f.same_cycle x y,	hy : y ≠ y	⊢ y ∈ f.support", "decl_nm": "equiv.perm.support_cycle_of_le"
{"src": "α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α,	x y : α,	h : ¬f.same_cycle x y,	hy : y ≠ y	⊢ y ∈ f.support", "decl_nm": "equiv.perm.support_cycle_of_le"
{"src": "⊢ ∀ {α : Type u_1} [_inst_1 : decidable_eq α] [_inst_2 : fintype α] {f : perm α},	    f.cycle_factors_finset = {f} ↔ f.is_cycle", "decl_nm": "equiv.perm.cycle_factors_finset_eq_singleton_self_iff"
{"src": "α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α	⊢ f.cycle_factors_finset = {f} ↔ f.is_cycle", "decl_nm": "equiv.perm.cycle_factors_finset_eq_singleton_self_iff"
{"src": "⊢ ∀ {n : ℕ} {i j : fin n.succ}, j ≤ i → ⇑(i.cycle_range) j = ite (j = i) 0 (j + 1)", "decl_nm": "fin.cycle_range_of_le"
{"src": "n : ℕ,	i j : fin n.succ,	h : j ≤ i	⊢ ⇑(i.cycle_range) j = ite (j = i) 0 (j + 1)", "decl_nm": "fin.cycle_range_of_le"
{"src": "2 goals	case nat.zero	i j : fin 1,	h : j ≤ i	⊢ ⇑(i.cycle_range) j = ite (j = i) 0 (j + 1)		case nat.succ	n : ℕ,	i j : fin n.succ.succ,	h : j ≤ i	⊢ ⇑(i.cycle_range) j = ite (j = i) 0 (j + 1)", "decl_nm": "fin.cycle_range_of_le"
{"src": "case nat.succ	n : ℕ,	i j : fin n.succ.succ,	h : j ≤ i	⊢ ⇑(i.cycle_range) j = ite (j = i) 0 (j + 1)", "decl_nm": "fin.cycle_range_of_le"
{"src": "2 goals	n : ℕ,	i j : fin n.succ.succ,	h : j ≤ i	⊢ j = ⇑((cast_le _).to_embedding) ⟨↑j, _⟩		n : ℕ,	i j : fin n.succ.succ,	h : j ≤ i,	this : j = ⇑((cast_le _).to_embedding) ⟨↑j, _⟩	⊢ ⇑(i.cycle_range) j = ite (j = i) 0 (j + 1)", "decl_nm": "fin.cycle_range_of_le"
{"src": "n : ℕ,	i j : fin n.succ.succ,	h : j ≤ i,	this : j = ⇑((cast_le _).to_embedding) ⟨↑j, _⟩	⊢ ⇑(i.cycle_range) j = ite (j = i) 0 (j + 1)", "decl_nm": "fin.cycle_range_of_le"
{"src": "n : ℕ,	i j : fin n.succ.succ,	h : j ≤ i,	this : j = ⇑((cast_le _).to_embedding) ⟨↑j, _⟩	⊢ ↑(⇑(i.cycle_range) j) = ↑(ite (j = i) 0 (j + 1))", "decl_nm": "fin.cycle_range_of_le"
{"src": "n : ℕ,	i j : fin n.succ.succ,	h : j ≤ i,	this : j = ⇑((cast_le _).to_embedding) ⟨↑j, _⟩	⊢ ite (⟨↑j, _⟩ = last ↑i) 0 (↑⟨↑j, _⟩ + 1) =	    ↑(ite (⇑(cast_le _) ⟨↑j, _⟩ = i) 0 (⇑(cast_le _) ⟨↑j, _⟩ + 1))", "decl_nm": "fin.cycle_range_of_le"
{"src": "n : ℕ,	i j : fin n.succ.succ,	h : j ≤ i,	this : j = ⇑((cast_le _).to_embedding) ⟨↑j, _⟩	⊢ ite (↑j = ↑i) 0 (↑j + 1) = ite (↑j = ↑i) 0 ↑(j + 1)", "decl_nm": "fin.cycle_range_of_le"
{"src": "2 goals	n : ℕ,	i j : fin n.succ.succ,	h : j ≤ i,	this : j = ⇑((cast_le _).to_embedding) ⟨↑j, _⟩,	heq : ↑j = ↑i	⊢ 0 = 0		n : ℕ,	i j : fin n.succ.succ,	h : j ≤ i,	this : j = ⇑((cast_le _).to_embedding) ⟨↑j, _⟩,	heq : ¬↑j = ↑i	⊢ ↑j + 1 = ↑(j + 1)", "decl_nm": "fin.cycle_range_of_le"
{"src": "n : ℕ,	i j : fin n.succ.succ,	h : j ≤ i,	this : j = ⇑((cast_le _).to_embedding) ⟨↑j, _⟩,	heq : ¬↑j = ↑i	⊢ ↑j + 1 = ↑(j + 1)", "decl_nm": "fin.cycle_range_of_le"
{"src": "n : ℕ,	i j : fin n.succ.succ,	h : j ≤ i,	this : j = ⇑((cast_le _).to_embedding) ⟨↑j, _⟩,	heq : ¬↑j = ↑i	⊢ j < last n.succ", "decl_nm": "fin.cycle_range_of_le"
{"src": "⊢ ∀ {n : ℕ}, 2.cycle_range.is_three_cycle", "decl_nm": "fin.is_three_cycle_cycle_range_two"
{"src": "n : ℕ	⊢ 2.cycle_range.is_three_cycle", "decl_nm": "fin.is_three_cycle_cycle_range_two"
{"src": "2 goals	n : ℕ	⊢ {↑2 + 1} = {3}		n : ℕ	⊢ 2 ≠ 0", "decl_nm": "fin.is_three_cycle_cycle_range_two"
{"src": "n : ℕ	⊢ 2 ≠ 0", "decl_nm": "fin.is_three_cycle_cycle_range_two"
{"src": "⊢ ∀ {n : ℕ} (p : fin (n + 1)) (e : perm (fin n)), ⇑(⇑(perm.decompose_fin.symm) (p, e)) 0 = p", "decl_nm": "equiv.perm.decompose_fin_symm_apply_zero"
{"src": "n : ℕ,	p : fin (n + 1),	e : perm (fin n)	⊢ ⇑(⇑(perm.decompose_fin.symm) (p, e)) 0 = p", "decl_nm": "equiv.perm.decompose_fin_symm_apply_zero"
{"src": "⊢ ∀ {α : Type u_1} [_inst_1 : decidable_eq α] [_inst_2 : fintype α] {f : perm α} {n : ℕ} {x : α},	    ⇑(f ^ n) x ∈ f.support ↔ x ∈ f.support", "decl_nm": "equiv.perm.pow_apply_mem_support"
{"src": "α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α,	n : ℕ,	x : α	⊢ ⇑(f ^ n) x ∈ f.support ↔ x ∈ f.support", "decl_nm": "equiv.perm.pow_apply_mem_support"
{"src": "2 goals	case nat.zero	α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α,	x : α	⊢ ⇑(f ^ 0) x ∈ f.support ↔ x ∈ f.support		case nat.succ	α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α,	x : α,	n : ℕ,	ih : ⇑(f ^ n) x ∈ f.support ↔ x ∈ f.support	⊢ ⇑(f ^ n.succ) x ∈ f.support ↔ x ∈ f.support", "decl_nm": "equiv.perm.pow_apply_mem_support"
{"src": "case nat.succ	α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α,	x : α,	n : ℕ,	ih : ⇑(f ^ n) x ∈ f.support ↔ x ∈ f.support	⊢ ⇑(f ^ n.succ) x ∈ f.support ↔ x ∈ f.support", "decl_nm": "equiv.perm.pow_apply_mem_support"
{"src": "⊢ ∀ {α : Type u_1} [_inst_1 : decidable_eq α] [_inst_2 : fintype α] {f : perm α} {x y : α},	    y ∈ (swap x (⇑f x) * f).support → y ∈ f.support ∧ y ≠ x", "decl_nm": "equiv.perm.mem_support_swap_mul_imp_mem_support_ne"
{"src": "α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α,	x y : α,	hy : y ∈ (swap x (⇑f x) * f).support	⊢ y ∈ f.support ∧ y ≠ x", "decl_nm": "equiv.perm.mem_support_swap_mul_imp_mem_support_ne"
{"src": "α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α,	x y : α,	hy : ite (⇑f y = x) (⇑f x) (ite (y = x) x (⇑f y)) ≠ y	⊢ ⇑f y ≠ y ∧ y ≠ x", "decl_nm": "equiv.perm.mem_support_swap_mul_imp_mem_support_ne"
{"src": "2 goals	α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α,	x y : α,	hy : ite (⇑f y = x) (⇑f x) (ite (y = x) x (⇑f y)) ≠ y,	h : ⇑f y = x	⊢ ⇑f y ≠ y ∧ y ≠ x		α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α,	x y : α,	hy : ite (⇑f y = x) (⇑f x) (ite (y = x) x (⇑f y)) ≠ y,	h : ¬⇑f y = x	⊢ ⇑f y ≠ y ∧ y ≠ x", "decl_nm": "equiv.perm.mem_support_swap_mul_imp_mem_support_ne"
{"src": "3 goals	α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α,	x y : α,	hy : ite (⇑f y = x) (⇑f x) (ite (y = x) x (⇑f y)) ≠ y,	h : ⇑f y = x	⊢ ⇑f y ≠ y		α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α,	x y : α,	hy : ite (⇑f y = x) (⇑f x) (ite (y = x) x (⇑f y)) ≠ y,	h : ⇑f y = x	⊢ y ≠ x		α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α,	x y : α,	hy : ite (⇑f y = x) (⇑f x) (ite (y = x) x (⇑f y)) ≠ y,	h : ¬⇑f y = x	⊢ ⇑f y ≠ y ∧ y ≠ x", "decl_nm": "equiv.perm.mem_support_swap_mul_imp_mem_support_ne"
{"src": "3 goals	α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α,	x y : α,	hy : ite (⇑f y = x) (⇑f x) (ite (y = x) x (⇑f y)) ≠ y,	h : ⇑f y = x,	ᾰ : ⇑f y = y	⊢ false		α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α,	x y : α,	hy : ite (⇑f y = x) (⇑f x) (ite (y = x) x (⇑f y)) ≠ y,	h : ⇑f y = x	⊢ y ≠ x		α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α,	x y : α,	hy : ite (⇑f y = x) (⇑f x) (ite (y = x) x (⇑f y)) ≠ y,	h : ¬⇑f y = x	⊢ ⇑f y ≠ y ∧ y ≠ x", "decl_nm": "equiv.perm.mem_support_swap_mul_imp_mem_support_ne"
{"src": "2 goals	α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α,	x y : α,	hy : ite (⇑f y = x) (⇑f x) (ite (y = x) x (⇑f y)) ≠ y,	h : ⇑f y = x	⊢ y ≠ x		α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α,	x y : α,	hy : ite (⇑f y = x) (⇑f x) (ite (y = x) x (⇑f y)) ≠ y,	h : ¬⇑f y = x	⊢ ⇑f y ≠ y ∧ y ≠ x", "decl_nm": "equiv.perm.mem_support_swap_mul_imp_mem_support_ne"
{"src": "2 goals	α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α,	x y : α,	hy : ite (⇑f y = x) (⇑f x) (ite (y = x) x (⇑f y)) ≠ y,	h : ⇑f y = x,	ᾰ : y = x	⊢ false		α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α,	x y : α,	hy : ite (⇑f y = x) (⇑f x) (ite (y = x) x (⇑f y)) ≠ y,	h : ¬⇑f y = x	⊢ ⇑f y ≠ y ∧ y ≠ x", "decl_nm": "equiv.perm.mem_support_swap_mul_imp_mem_support_ne"
{"src": "α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α,	x y : α,	hy : ite (⇑f y = x) (⇑f x) (ite (y = x) x (⇑f y)) ≠ y,	h : ¬⇑f y = x	⊢ ⇑f y ≠ y ∧ y ≠ x", "decl_nm": "equiv.perm.mem_support_swap_mul_imp_mem_support_ne"
{"src": "2 goals	α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α,	x y : α,	h : ¬⇑f y = x,	h_1 : y = x,	hy : x ≠ y	⊢ ⇑f y ≠ y ∧ y ≠ x		α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α,	x y : α,	h : ¬⇑f y = x,	h_1 : ¬y = x,	hy : ⇑f y ≠ y	⊢ ⇑f y ≠ y ∧ y ≠ x", "decl_nm": "equiv.perm.mem_support_swap_mul_imp_mem_support_ne"
{"src": "α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α,	x y : α,	h : ¬⇑f y = x,	h_1 : ¬y = x,	hy : ⇑f y ≠ y	⊢ ⇑f y ≠ y ∧ y ≠ x", "decl_nm": "equiv.perm.mem_support_swap_mul_imp_mem_support_ne"
{"src": "⊢ ∀ {α : Type u_1} [_inst_1 : decidable_eq α] [_inst_2 : fintype α] (f : perm α), f.support.card ≠ 1", "decl_nm": "equiv.perm.card_support_ne_one"
{"src": "α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α	⊢ f.support.card ≠ 1", "decl_nm": "equiv.perm.card_support_ne_one"
{"src": "2 goals	α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α,	h : f = 1	⊢ f.support.card ≠ 1		α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α,	h : ¬f = 1	⊢ f.support.card ≠ 1", "decl_nm": "equiv.perm.card_support_ne_one"
{"src": "α : Type u_1,	_inst_1 : decidable_eq α,	_inst_2 : fintype α,	f : perm α,	h : ¬f = 1	⊢ f.support.card ≠ 1", "decl_nm": "equiv.perm.card_support_ne_one"
{"src": "⊢ ∀ {N : Type u_1} {G : Type u_2} [_inst_1 : group N] [_inst_2 : group G] {φ : G →* mul_aut N} {N₁ : Type u_4}	  {G₁ : Type u_5} [_inst_4 : group N₁] [_inst_5 : group G₁] {φ₁ : G₁ →* mul_aut N₁} (f₁ : N →* N₁)	  (f₂ : G →* G₁)	  (h :	    ∀ (g : G),	      f₁.comp (mul_equiv.to_monoid_hom (⇑φ g)) = (mul_equiv.to_monoid_hom (⇑φ₁ (⇑f₂ g))).comp f₁),	    (map f₁ f₂ h).comp inl = inl.comp f₁", "decl_nm": "semidirect_product.map_comp_inl"
{"src": "N : Type u_1,	G : Type u_2,	_inst_1 : group N,	_inst_2 : group G,	φ : G →* mul_aut N,	N₁ : Type u_4,	G₁ : Type u_5,	_inst_4 : group N₁,	_inst_5 : group G₁,	φ₁ : G₁ →* mul_aut N₁,	f₁ : N →* N₁,	f₂ : G →* G₁,	h :	  ∀ (g : G),	    f₁.comp (mul_equiv.to_monoid_hom (⇑φ g)) = (mul_equiv.to_monoid_hom (⇑φ₁ (⇑f₂ g))).comp f₁	⊢ (map f₁ f₂ h).comp inl = inl.comp f₁", "decl_nm": "semidirect_product.map_comp_inl"
{"src": "2 goals	N : Type u_1,	G : Type u_2,	_inst_1 : group N,	_inst_2 : group G,	φ : G →* mul_aut N,	N₁ : Type u_4,	G₁ : Type u_5,	_inst_4 : group N₁,	_inst_5 : group G₁,	φ₁ : G₁ →* mul_aut N₁,	f₁ : N →* N₁,	f₂ : G →* G₁,	h :	  ∀ (g : G),	    f₁.comp (mul_equiv.to_monoid_hom (⇑φ g)) = (mul_equiv.to_monoid_hom (⇑φ₁ (⇑f₂ g))).comp f₁,	x : N	⊢ (⇑((map f₁ f₂ h).comp inl) x).left = (⇑(inl.comp f₁) x).left		N : Type u_1,	G : Type u_2,	_inst_1 : group N,	_inst_2 : group G,	φ : G →* mul_aut N,	N₁ : Type u_4,	G₁ : Type u_5,	_inst_4 : group N₁,	_inst_5 : group G₁,	φ₁ : G₁ →* mul_aut N₁,	f₁ : N →* N₁,	f₂ : G →* G₁,	h :	  ∀ (g : G),	    f₁.comp (mul_equiv.to_monoid_hom (⇑φ g)) = (mul_equiv.to_monoid_hom (⇑φ₁ (⇑f₂ g))).comp f₁,	x : N	⊢ (⇑((map f₁ f₂ h).comp inl) x).right = (⇑(inl.comp f₁) x).right", "decl_nm": "semidirect_product.map_comp_inl"
{"src": "N : Type u_1,	G : Type u_2,	_inst_1 : group N,	_inst_2 : group G,	φ : G →* mul_aut N,	N₁ : Type u_4,	G₁ : Type u_5,	_inst_4 : group N₁,	_inst_5 : group G₁,	φ₁ : G₁ →* mul_aut N₁,	f₁ : N →* N₁,	f₂ : G →* G₁,	h :	  ∀ (g : G),	    f₁.comp (mul_equiv.to_monoid_hom (⇑φ g)) = (mul_equiv.to_monoid_hom (⇑φ₁ (⇑f₂ g))).comp f₁,	x : N	⊢ (⇑((map f₁ f₂ h).comp inl) x).right = (⇑(inl.comp f₁) x).right", "decl_nm": "semidirect_product.map_comp_inl"
{"src": "⊢ ¬is_solvable (equiv.perm (fin 5))", "decl_nm": "equiv.perm.fin_5_not_solvable"
{"src": "x : equiv.perm (fin 5) := {to_fun := ![1, 2, 0, 3, 4], inv_fun := ![2, 0, 1, 3, 4], left_inv := _, right_inv := _}	⊢ ¬is_solvable (equiv.perm (fin 5))", "decl_nm": "equiv.perm.fin_5_not_solvable"
{"src": "x : equiv.perm (fin 5) := {to_fun := ![1, 2, 0, 3, 4], inv_fun := ![2, 0, 1, 3, 4], left_inv := _, right_inv := _},	y : equiv.perm (fin 5) := {to_fun := ![3, 4, 2, 0, 1], inv_fun := ![3, 4, 2, 0, 1], left_inv := _, right_inv := _}	⊢ ¬is_solvable (equiv.perm (fin 5))", "decl_nm": "equiv.perm.fin_5_not_solvable"
{"src": "x : equiv.perm (fin 5) := {to_fun := ![1, 2, 0, 3, 4], inv_fun := ![2, 0, 1, 3, 4], left_inv := _, right_inv := _},	y : equiv.perm (fin 5) := {to_fun := ![3, 4, 2, 0, 1], inv_fun := ![3, 4, 2, 0, 1], left_inv := _, right_inv := _},	z : equiv.perm (fin 5) := {to_fun := ![0, 3, 2, 1, 4], inv_fun := ![0, 3, 2, 1, 4], left_inv := _, right_inv := _}	⊢ ¬is_solvable (equiv.perm (fin 5))", "decl_nm": "equiv.perm.fin_5_not_solvable"
{"src": "2 goals	x : equiv.perm (fin 5) := {to_fun := ![1, 2, 0, 3, 4], inv_fun := ![2, 0, 1, 3, 4], left_inv := _, right_inv := _},	y : equiv.perm (fin 5) := {to_fun := ![3, 4, 2, 0, 1], inv_fun := ![3, 4, 2, 0, 1], left_inv := _, right_inv := _},	z : equiv.perm (fin 5) := {to_fun := ![0, 3, 2, 1, 4], inv_fun := ![0, 3, 2, 1, 4], left_inv := _, right_inv := _}	⊢ x ≠ 1		x : equiv.perm (fin 5) := {to_fun := ![1, 2, 0, 3, 4], inv_fun := ![2, 0, 1, 3, 4], left_inv := _, right_inv := _},	y : equiv.perm (fin 5) := {to_fun := ![3, 4, 2, 0, 1], inv_fun := ![3, 4, 2, 0, 1], left_inv := _, right_inv := _},	z : equiv.perm (fin 5) := {to_fun := ![0, 3, 2, 1, 4], inv_fun := ![0, 3, 2, 1, 4], left_inv := _, right_inv := _},	x_ne_one : x ≠ 1	⊢ ¬is_solvable (equiv.perm (fin 5))", "decl_nm": "equiv.perm.fin_5_not_solvable"
{"src": "2 goals	x : equiv.perm (fin 5) := {to_fun := ![1, 2, 0, 3, 4], inv_fun := ![2, 0, 1, 3, 4], left_inv := _, right_inv := _},	y : equiv.perm (fin 5) := {to_fun := ![3, 4, 2, 0, 1], inv_fun := ![3, 4, 2, 0, 1], left_inv := _, right_inv := _},	z : equiv.perm (fin 5) := {to_fun := ![0, 3, 2, 1, 4], inv_fun := ![0, 3, 2, 1, 4], left_inv := _, right_inv := _}	⊢ ¬∀ (x_1 : fin 5), ⇑x x_1 = ⇑1 x_1		x : equiv.perm (fin 5) := {to_fun := ![1, 2, 0, 3, 4], inv_fun := ![2, 0, 1, 3, 4], left_inv := _, right_inv := _},	y : equiv.perm (fin 5) := {to_fun := ![3, 4, 2, 0, 1], inv_fun := ![3, 4, 2, 0, 1], left_inv := _, right_inv := _},	z : equiv.perm (fin 5) := {to_fun := ![0, 3, 2, 1, 4], inv_fun := ![0, 3, 2, 1, 4], left_inv := _, right_inv := _},	x_ne_one : x ≠ 1	⊢ ¬is_solvable (equiv.perm (fin 5))", "decl_nm": "equiv.perm.fin_5_not_solvable"
{"src": "x : equiv.perm (fin 5) := {to_fun := ![1, 2, 0, 3, 4], inv_fun := ![2, 0, 1, 3, 4], left_inv := _, right_inv := _},	y : equiv.perm (fin 5) := {to_fun := ![3, 4, 2, 0, 1], inv_fun := ![3, 4, 2, 0, 1], left_inv := _, right_inv := _},	z : equiv.perm (fin 5) := {to_fun := ![0, 3, 2, 1, 4], inv_fun := ![0, 3, 2, 1, 4], left_inv := _, right_inv := _},	x_ne_one : x ≠ 1	⊢ ¬is_solvable (equiv.perm (fin 5))", "decl_nm": "equiv.perm.fin_5_not_solvable"
{"src": "2 goals	x : equiv.perm (fin 5) := {to_fun := ![1, 2, 0, 3, 4], inv_fun := ![2, 0, 1, 3, 4], left_inv := _, right_inv := _},	y : equiv.perm (fin 5) := {to_fun := ![3, 4, 2, 0, 1], inv_fun := ![3, 4, 2, 0, 1], left_inv := _, right_inv := _},	z : equiv.perm (fin 5) := {to_fun := ![0, 3, 2, 1, 4], inv_fun := ![0, 3, 2, 1, 4], left_inv := _, right_inv := _},	x_ne_one : x ≠ 1	⊢ x = z * (x * (y * x * y⁻¹) * x⁻¹ * (y * x * y⁻¹)⁻¹) * z⁻¹		x : equiv.perm (fin 5) := {to_fun := ![1, 2, 0, 3, 4], inv_fun := ![2, 0, 1, 3, 4], left_inv := _, right_inv := _},	y : equiv.perm (fin 5) := {to_fun := ![3, 4, 2, 0, 1], inv_fun := ![3, 4, 2, 0, 1], left_inv := _, right_inv := _},	z : equiv.perm (fin 5) := {to_fun := ![0, 3, 2, 1, 4], inv_fun := ![0, 3, 2, 1, 4], left_inv := _, right_inv := _},	x_ne_one : x ≠ 1,	key : x = z * (x * (y * x * y⁻¹) * x⁻¹ * (y * x * y⁻¹)⁻¹) * z⁻¹	⊢ ¬is_solvable (equiv.perm (fin 5))", "decl_nm": "equiv.perm.fin_5_not_solvable"
{"src": "2 goals	x : equiv.perm (fin 5) := {to_fun := ![1, 2, 0, 3, 4], inv_fun := ![2, 0, 1, 3, 4], left_inv := _, right_inv := _},	y : equiv.perm (fin 5) := {to_fun := ![3, 4, 2, 0, 1], inv_fun := ![3, 4, 2, 0, 1], left_inv := _, right_inv := _},	z : equiv.perm (fin 5) := {to_fun := ![0, 3, 2, 1, 4], inv_fun := ![0, 3, 2, 1, 4], left_inv := _, right_inv := _},	x_ne_one : x ≠ 1,	a : fin 5	⊢ ↑(⇑x a) = ↑(⇑(z * (x * (y * x * y⁻¹) * x⁻¹ * (y * x * y⁻¹)⁻¹) * z⁻¹) a)		x : equiv.perm (fin 5) := {to_fun := ![1, 2, 0, 3, 4], inv_fun := ![2, 0, 1, 3, 4], left_inv := _, right_inv := _},	y : equiv.perm (fin 5) := {to_fun := ![3, 4, 2, 0, 1], inv_fun := ![3, 4, 2, 0, 1], left_inv := _, right_inv := _},	z : equiv.perm (fin 5) := {to_fun := ![0, 3, 2, 1, 4], inv_fun := ![0, 3, 2, 1, 4], left_inv := _, right_inv := _},	x_ne_one : x ≠ 1,	key : x = z * (x * (y * x * y⁻¹) * x⁻¹ * (y * x * y⁻¹)⁻¹) * z⁻¹	⊢ ¬is_solvable (equiv.perm (fin 5))", "decl_nm": "equiv.perm.fin_5_not_solvable"
{"src": "x : equiv.perm (fin 5) := {to_fun := ![1, 2, 0, 3, 4], inv_fun := ![2, 0, 1, 3, 4], left_inv := _, right_inv := _},	y : equiv.perm (fin 5) := {to_fun := ![3, 4, 2, 0, 1], inv_fun := ![3, 4, 2, 0, 1], left_inv := _, right_inv := _},	z : equiv.perm (fin 5) := {to_fun := ![0, 3, 2, 1, 4], inv_fun := ![0, 3, 2, 1, 4], left_inv := _, right_inv := _},	x_ne_one : x ≠ 1,	key : x = z * (x * (y * x * y⁻¹) * x⁻¹ * (y * x * y⁻¹)⁻¹) * z⁻¹	⊢ ¬is_solvable (equiv.perm (fin 5))", "decl_nm": "equiv.perm.fin_5_not_solvable"
{"src": "x : equiv.perm (fin 5) := {to_fun := ![1, 2, 0, 3, 4], inv_fun := ![2, 0, 1, 3, 4], left_inv := _, right_inv := _},	y : equiv.perm (fin 5) := {to_fun := ![3, 4, 2, 0, 1], inv_fun := ![3, 4, 2, 0, 1], left_inv := _, right_inv := _},	z : equiv.perm (fin 5) := {to_fun := ![0, 3, 2, 1, 4], inv_fun := ![0, 3, 2, 1, 4], left_inv := _, right_inv := _},	x_ne_one : x ≠ 1,	key : x = z * (x * (y * x * y⁻¹) * x⁻¹ * (y * x * y⁻¹)⁻¹) * z⁻¹,	n : ℕ	⊢ x ∈ derived_series (equiv.perm (fin 5)) n", "decl_nm": "equiv.perm.fin_5_not_solvable"
{"src": "2 goals	case nat.zero	x : equiv.perm (fin 5) := {to_fun := ![1, 2, 0, 3, 4], inv_fun := ![2, 0, 1, 3, 4], left_inv := _, right_inv := _},	y : equiv.perm (fin 5) := {to_fun := ![3, 4, 2, 0, 1], inv_fun := ![3, 4, 2, 0, 1], left_inv := _, right_inv := _},	z : equiv.perm (fin 5) := {to_fun := ![0, 3, 2, 1, 4], inv_fun := ![0, 3, 2, 1, 4], left_inv := _, right_inv := _},	x_ne_one : x ≠ 1,	key : x = z * (x * (y * x * y⁻¹) * x⁻¹ * (y * x * y⁻¹)⁻¹) * z⁻¹	⊢ x ∈ derived_series (equiv.perm (fin 5)) 0		case nat.succ	x : equiv.perm (fin 5) := {to_fun := ![1, 2, 0, 3, 4], inv_fun := ![2, 0, 1, 3, 4], left_inv := _, right_inv := _},	y : equiv.perm (fin 5) := {to_fun := ![3, 4, 2, 0, 1], inv_fun := ![3, 4, 2, 0, 1], left_inv := _, right_inv := _},	z : equiv.perm (fin 5) := {to_fun := ![0, 3, 2, 1, 4], inv_fun := ![0, 3, 2, 1, 4], left_inv := _, right_inv := _},	x_ne_one : x ≠ 1,	key : x = z * (x * (y * x * y⁻¹) * x⁻¹ * (y * x * y⁻¹)⁻¹) * z⁻¹,	n : ℕ,	ih : x ∈ derived_series (equiv.perm (fin 5)) n	⊢ x ∈ derived_series (equiv.perm (fin 5)) n.succ", "decl_nm": "equiv.perm.fin_5_not_solvable"
{"src": "case nat.succ	x : equiv.perm (fin 5) := {to_fun := ![1, 2, 0, 3, 4], inv_fun := ![2, 0, 1, 3, 4], left_inv := _, right_inv := _},	y : equiv.perm (fin 5) := {to_fun := ![3, 4, 2, 0, 1], inv_fun := ![3, 4, 2, 0, 1], left_inv := _, right_inv := _},	z : equiv.perm (fin 5) := {to_fun := ![0, 3, 2, 1, 4], inv_fun := ![0, 3, 2, 1, 4], left_inv := _, right_inv := _},	x_ne_one : x ≠ 1,	key : x = z * (x * (y * x * y⁻¹) * x⁻¹ * (y * x * y⁻¹)⁻¹) * z⁻¹,	n : ℕ,	ih : x ∈ derived_series (equiv.perm (fin 5)) n	⊢ x ∈ derived_series (equiv.perm (fin 5)) n.succ", "decl_nm": "equiv.perm.fin_5_not_solvable"
{"src": "case nat.succ	x : equiv.perm (fin 5) := {to_fun := ![1, 2, 0, 3, 4], inv_fun := ![2, 0, 1, 3, 4], left_inv := _, right_inv := _},	y : equiv.perm (fin 5) := {to_fun := ![3, 4, 2, 0, 1], inv_fun := ![3, 4, 2, 0, 1], left_inv := _, right_inv := _},	z : equiv.perm (fin 5) := {to_fun := ![0, 3, 2, 1, 4], inv_fun := ![0, 3, 2, 1, 4], left_inv := _, right_inv := _},	x_ne_one : x ≠ 1,	key : x = z * (x * (y * x * y⁻¹) * x⁻¹ * (y * x * y⁻¹)⁻¹) * z⁻¹,	n : ℕ,	ih : x ∈ derived_series (equiv.perm (fin 5)) n	⊢ z * (x * (y * x * y⁻¹) * x⁻¹ * (y * x * y⁻¹)⁻¹) * z⁻¹ ∈ derived_series (equiv.perm (fin 5)) n.succ", "decl_nm": "equiv.perm.fin_5_not_solvable"
{"src": "⊢ ∀ (k : Type u_1) {V : Type u_2} {P : Type u_3} [_inst_1 : ring k] [_inst_2 : add_comm_group V]	  [_inst_3 : module k V] [_inst_4 : add_torsor V P] {p : P} {ps : set P},	    p ∈ affine_span k ps → affine_span k (insert p ps) = affine_span k ps", "decl_nm": "affine_span_insert_eq_affine_span"
{"src": "k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : add_torsor V P,	p : P,	ps : set P,	h : p ∈ affine_span k ps	⊢ affine_span k (insert p ps) = affine_span k ps", "decl_nm": "affine_span_insert_eq_affine_span"
{"src": "k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : add_torsor V P,	p : P,	ps : set P,	h : p ∈ ↑(affine_span k ps)	⊢ affine_span k (insert p ps) = affine_span k ps", "decl_nm": "affine_span_insert_eq_affine_span"
{"src": "⊢ ∀ (k : Type u_1) {V : Type u_2} {P : Type u_3} [_inst_1 : ring k] [_inst_2 : add_comm_group V]	  [_inst_3 : module k V] [_inst_4 : add_torsor V P] {s : set P} {p1 p2 : P},	    p1 ∈ span_points k s → p2 ∈ span_points k s → p1 -ᵥ p2 ∈ vector_span k s", "decl_nm": "vsub_mem_vector_span_of_mem_span_points_of_mem_span_points"
{"src": "k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : add_torsor V P,	s : set P,	p1 p2 : P,	hp1 : p1 ∈ span_points k s,	hp2 : p2 ∈ span_points k s	⊢ p1 -ᵥ p2 ∈ vector_span k s", "decl_nm": "vsub_mem_vector_span_of_mem_span_points_of_mem_span_points"
{"src": "k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : add_torsor V P,	s : set P,	p1 p2 : P,	hp2 : p2 ∈ span_points k s,	p1a : P,	hp1a : p1a ∈ s,	v1 : V,	hv1 : v1 ∈ vector_span k s,	hv1p : p1 = v1 +ᵥ p1a	⊢ p1 -ᵥ p2 ∈ vector_span k s", "decl_nm": "vsub_mem_vector_span_of_mem_span_points_of_mem_span_points"
{"src": "k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : add_torsor V P,	s : set P,	p1 p2 p1a : P,	hp1a : p1a ∈ s,	v1 : V,	hv1 : v1 ∈ vector_span k s,	hv1p : p1 = v1 +ᵥ p1a,	p2a : P,	hp2a : p2a ∈ s,	v2 : V,	hv2 : v2 ∈ vector_span k s,	hv2p : p2 = v2 +ᵥ p2a	⊢ p1 -ᵥ p2 ∈ vector_span k s", "decl_nm": "vsub_mem_vector_span_of_mem_span_points_of_mem_span_points"
{"src": "k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : add_torsor V P,	s : set P,	p1 p2 p1a : P,	hp1a : p1a ∈ s,	v1 : V,	hv1 : v1 ∈ vector_span k s,	hv1p : p1 = v1 +ᵥ p1a,	p2a : P,	hp2a : p2a ∈ s,	v2 : V,	hv2 : v2 ∈ vector_span k s,	hv2p : p2 = v2 +ᵥ p2a	⊢ p1a -ᵥ p2a + (v1 - v2) ∈ vector_span k s", "decl_nm": "vsub_mem_vector_span_of_mem_span_points_of_mem_span_points"
{"src": "2 goals	k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : add_torsor V P,	s : set P,	p1 p2 p1a : P,	hp1a : p1a ∈ s,	v1 : V,	hv1 : v1 ∈ vector_span k s,	hv1p : p1 = v1 +ᵥ p1a,	p2a : P,	hp2a : p2a ∈ s,	v2 : V,	hv2 : v2 ∈ vector_span k s,	hv2p : p2 = v2 +ᵥ p2a	⊢ v1 - v2 ∈ vector_span k s		k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : add_torsor V P,	s : set P,	p1 p2 p1a : P,	hp1a : p1a ∈ s,	v1 : V,	hv1 : v1 ∈ vector_span k s,	hv1p : p1 = v1 +ᵥ p1a,	p2a : P,	hp2a : p2a ∈ s,	v2 : V,	hv2 : v2 ∈ vector_span k s,	hv2p : p2 = v2 +ᵥ p2a,	hv1v2 : v1 - v2 ∈ vector_span k s	⊢ p1a -ᵥ p2a + (v1 - v2) ∈ vector_span k s", "decl_nm": "vsub_mem_vector_span_of_mem_span_points_of_mem_span_points"
{"src": "2 goals	k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : add_torsor V P,	s : set P,	p1 p2 p1a : P,	hp1a : p1a ∈ s,	v1 : V,	hv1 : v1 ∈ vector_span k s,	hv1p : p1 = v1 +ᵥ p1a,	p2a : P,	hp2a : p2a ∈ s,	v2 : V,	hv2 : v2 ∈ vector_span k s,	hv2p : p2 = v2 +ᵥ p2a	⊢ v1 + -v2 ∈ vector_span k s		k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : add_torsor V P,	s : set P,	p1 p2 p1a : P,	hp1a : p1a ∈ s,	v1 : V,	hv1 : v1 ∈ vector_span k s,	hv1p : p1 = v1 +ᵥ p1a,	p2a : P,	hp2a : p2a ∈ s,	v2 : V,	hv2 : v2 ∈ vector_span k s,	hv2p : p2 = v2 +ᵥ p2a,	hv1v2 : v1 - v2 ∈ vector_span k s	⊢ p1a -ᵥ p2a + (v1 - v2) ∈ vector_span k s", "decl_nm": "vsub_mem_vector_span_of_mem_span_points_of_mem_span_points"
{"src": "2 goals	k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : add_torsor V P,	s : set P,	p1 p2 p1a : P,	hp1a : p1a ∈ s,	v1 : V,	hv1 : v1 ∈ vector_span k s,	hv1p : p1 = v1 +ᵥ p1a,	p2a : P,	hp2a : p2a ∈ s,	v2 : V,	hv2 : v2 ∈ vector_span k s,	hv2p : p2 = v2 +ᵥ p2a	⊢ -v2 ∈ vector_span k s		k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : add_torsor V P,	s : set P,	p1 p2 p1a : P,	hp1a : p1a ∈ s,	v1 : V,	hv1 : v1 ∈ vector_span k s,	hv1p : p1 = v1 +ᵥ p1a,	p2a : P,	hp2a : p2a ∈ s,	v2 : V,	hv2 : v2 ∈ vector_span k s,	hv2p : p2 = v2 +ᵥ p2a,	hv1v2 : v1 - v2 ∈ vector_span k s	⊢ p1a -ᵥ p2a + (v1 - v2) ∈ vector_span k s", "decl_nm": "vsub_mem_vector_span_of_mem_span_points_of_mem_span_points"
{"src": "2 goals	k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : add_torsor V P,	s : set P,	p1 p2 p1a : P,	hp1a : p1a ∈ s,	v1 : V,	hv1 : v1 ∈ vector_span k s,	hv1p : p1 = v1 +ᵥ p1a,	p2a : P,	hp2a : p2a ∈ s,	v2 : V,	hv2 : v2 ∈ vector_span k s,	hv2p : p2 = v2 +ᵥ p2a	⊢ (-1) • v2 ∈ vector_span k s		k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : add_torsor V P,	s : set P,	p1 p2 p1a : P,	hp1a : p1a ∈ s,	v1 : V,	hv1 : v1 ∈ vector_span k s,	hv1p : p1 = v1 +ᵥ p1a,	p2a : P,	hp2a : p2a ∈ s,	v2 : V,	hv2 : v2 ∈ vector_span k s,	hv2p : p2 = v2 +ᵥ p2a,	hv1v2 : v1 - v2 ∈ vector_span k s	⊢ p1a -ᵥ p2a + (v1 - v2) ∈ vector_span k s", "decl_nm": "vsub_mem_vector_span_of_mem_span_points_of_mem_span_points"
{"src": "k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : add_torsor V P,	s : set P,	p1 p2 p1a : P,	hp1a : p1a ∈ s,	v1 : V,	hv1 : v1 ∈ vector_span k s,	hv1p : p1 = v1 +ᵥ p1a,	p2a : P,	hp2a : p2a ∈ s,	v2 : V,	hv2 : v2 ∈ vector_span k s,	hv2p : p2 = v2 +ᵥ p2a,	hv1v2 : v1 - v2 ∈ vector_span k s	⊢ p1a -ᵥ p2a + (v1 - v2) ∈ vector_span k s", "decl_nm": "vsub_mem_vector_span_of_mem_span_points_of_mem_span_points"
{"src": "k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : add_torsor V P,	s : set P,	p1 p2 p1a : P,	hp1a : p1a ∈ s,	v1 : V,	hv1 : v1 ∈ vector_span k s,	hv1p : p1 = v1 +ᵥ p1a,	p2a : P,	hp2a : p2a ∈ s,	v2 : V,	hv2 : v2 ∈ vector_span k s,	hv2p : p2 = v2 +ᵥ p2a,	hv1v2 : v1 - v2 ∈ vector_span k s	⊢ p1a -ᵥ p2a ∈ vector_span k s", "decl_nm": "vsub_mem_vector_span_of_mem_span_points_of_mem_span_points"
{"src": "⊢ ∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [_inst_1 : ring k] [_inst_2 : add_comm_group V]	  [_inst_3 : module k V] [_inst_4 : add_torsor V P] (p : P) (direction : submodule k V),	    (mk' p direction).direction = direction", "decl_nm": "affine_subspace.direction_mk'"
{"src": "k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : add_torsor V P,	p : P,	direction : submodule k V	⊢ (mk' p direction).direction = direction", "decl_nm": "affine_subspace.direction_mk'"
{"src": "k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : add_torsor V P,	p : P,	direction : submodule k V,	v : V	⊢ v ∈ (mk' p direction).direction ↔ v ∈ direction", "decl_nm": "affine_subspace.direction_mk'"
{"src": "k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : add_torsor V P,	p : P,	direction : submodule k V,	v : V	⊢ (∃ (p1 : P) (H : p1 ∈ mk' p direction) (p2 : P) (H : p2 ∈ mk' p direction), v = p1 -ᵥ p2) ↔	    v ∈ direction", "decl_nm": "affine_subspace.direction_mk'"
{"src": "2 goals	k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : add_torsor V P,	p : P,	direction : submodule k V,	v : V	⊢ (∃ (p1 : P) (H : p1 ∈ mk' p direction) (p2 : P) (H : p2 ∈ mk' p direction), v = p1 -ᵥ p2) →	  v ∈ direction		k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : add_torsor V P,	p : P,	direction : submodule k V,	v : V	⊢ v ∈ direction →	  (∃ (p1 : P) (H : p1 ∈ mk' p direction) (p2 : P) (H : p2 ∈ mk' p direction), v = p1 -ᵥ p2)", "decl_nm": "affine_subspace.direction_mk'"
{"src": "2 goals	k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : add_torsor V P,	p : P,	direction : submodule k V,	v : V,	p1 : P,	v1 : V,	hv1 : v1 ∈ direction,	hp1 : p1 = v1 +ᵥ p,	p2 : P,	hv : v = p1 -ᵥ p2,	v2 : V,	hv2 : v2 ∈ direction,	hp2 : p2 = v2 +ᵥ p	⊢ v ∈ direction		k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : add_torsor V P,	p : P,	direction : submodule k V,	v : V	⊢ v ∈ direction →	  (∃ (p1 : P) (H : p1 ∈ mk' p direction) (p2 : P) (H : p2 ∈ mk' p direction), v = p1 -ᵥ p2)", "decl_nm": "affine_subspace.direction_mk'"
{"src": "2 goals	k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : add_torsor V P,	p : P,	direction : submodule k V,	v : V,	p1 : P,	v1 : V,	hv1 : v1 ∈ direction,	hp1 : p1 = v1 +ᵥ p,	p2 : P,	hv : v = p1 -ᵥ p2,	v2 : V,	hv2 : v2 ∈ direction,	hp2 : p2 = v2 +ᵥ p	⊢ v1 - v2 ∈ direction		k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : add_torsor V P,	p : P,	direction : submodule k V,	v : V	⊢ v ∈ direction →	  (∃ (p1 : P) (H : p1 ∈ mk' p direction) (p2 : P) (H : p2 ∈ mk' p direction), v = p1 -ᵥ p2)", "decl_nm": "affine_subspace.direction_mk'"
{"src": "k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : add_torsor V P,	p : P,	direction : submodule k V,	v : V	⊢ v ∈ direction →	  (∃ (p1 : P) (H : p1 ∈ mk' p direction) (p2 : P) (H : p2 ∈ mk' p direction), v = p1 -ᵥ p2)", "decl_nm": "affine_subspace.direction_mk'"
{"src": "⊢ ∀ (k : Type u_1) (V : Type u_2) (P : Type u_3) [_inst_1 : ring k] [_inst_2 : add_comm_group V]	  [_inst_3 : module k V] [S : add_torsor V P], ⊤.direction = ⊤", "decl_nm": "affine_subspace.direction_top"
{"src": "k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	S : add_torsor V P	⊢ ⊤.direction = ⊤", "decl_nm": "affine_subspace.direction_top"
{"src": "k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	S : add_torsor V P,	p : P	⊢ ⊤.direction = ⊤", "decl_nm": "affine_subspace.direction_top"
{"src": "k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	S : add_torsor V P,	p : P,	v : V	⊢ v ∈ ⊤.direction ↔ v ∈ ⊤", "decl_nm": "affine_subspace.direction_top"
{"src": "k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	S : add_torsor V P,	p : P,	v : V,	hv : v ∈ ⊤	⊢ v ∈ ⊤.direction", "decl_nm": "affine_subspace.direction_top"
{"src": "k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	S : add_torsor V P,	p : P,	v : V,	hv : v ∈ ⊤,	hpv : v +ᵥ p -ᵥ p ∈ ⊤.direction	⊢ v ∈ ⊤.direction", "decl_nm": "affine_subspace.direction_top"
{"src": "⊢ ∀ (k : Type u_1) {V : Type u_2} {P : Type u_3} [_inst_1 : ring k] [_inst_2 : add_comm_group V]	  [_inst_3 : module k V] [_inst_4 : add_torsor V P] {s : set P} {p : P},	    p ∈ s → vector_span k s = submodule.span k (has_vsub.vsub p '' s)", "decl_nm": "vector_span_eq_span_vsub_set_left"
{"src": "k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : add_torsor V P,	s : set P,	p : P,	hp : p ∈ s	⊢ vector_span k s = submodule.span k (has_vsub.vsub p '' s)", "decl_nm": "vector_span_eq_span_vsub_set_left"
{"src": "k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : add_torsor V P,	s : set P,	p : P,	hp : p ∈ s	⊢ submodule.span k (s -ᵥ s) = submodule.span k (has_vsub.vsub p '' s)", "decl_nm": "vector_span_eq_span_vsub_set_left"
{"src": "2 goals	k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : add_torsor V P,	s : set P,	p : P,	hp : p ∈ s	⊢ submodule.span k (s -ᵥ s) ≤ submodule.span k (has_vsub.vsub p '' s)		k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : add_torsor V P,	s : set P,	p : P,	hp : p ∈ s	⊢ has_vsub.vsub p '' s ⊆ s -ᵥ s", "decl_nm": "vector_span_eq_span_vsub_set_left"
{"src": "2 goals	k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : add_torsor V P,	s : set P,	p : P,	hp : p ∈ s	⊢ s -ᵥ s ⊆ ↑(submodule.span k (has_vsub.vsub p '' s))		k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : add_torsor V P,	s : set P,	p : P,	hp : p ∈ s	⊢ has_vsub.vsub p '' s ⊆ s -ᵥ s", "decl_nm": "vector_span_eq_span_vsub_set_left"
{"src": "2 goals	k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : add_torsor V P,	s : set P,	p : P,	hp : p ∈ s,	v : V,	p1 p2 : P,	hp1 : p1 ∈ s,	hp2 : p2 ∈ s,	hv : p1 -ᵥ p2 = v	⊢ v ∈ ↑(submodule.span k (has_vsub.vsub p '' s))		k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : add_torsor V P,	s : set P,	p : P,	hp : p ∈ s	⊢ has_vsub.vsub p '' s ⊆ s -ᵥ s", "decl_nm": "vector_span_eq_span_vsub_set_left"
{"src": "2 goals	k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : add_torsor V P,	s : set P,	p : P,	hp : p ∈ s,	v : V,	p1 p2 : P,	hp1 : p1 ∈ s,	hp2 : p2 ∈ s,	hv : p -ᵥ p2 - (p -ᵥ p1) = v	⊢ v ∈ ↑(submodule.span k (has_vsub.vsub p '' s))		k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : add_torsor V P,	s : set P,	p : P,	hp : p ∈ s	⊢ has_vsub.vsub p '' s ⊆ s -ᵥ s", "decl_nm": "vector_span_eq_span_vsub_set_left"
{"src": "2 goals	k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : add_torsor V P,	s : set P,	p : P,	hp : p ∈ s,	v : V,	p1 p2 : P,	hp1 : p1 ∈ s,	hp2 : p2 ∈ s,	hv : p -ᵥ p2 - (p -ᵥ p1) = v	⊢ ∀ (p_1 : submodule k V), has_vsub.vsub p '' s ⊆ ↑p_1 → p -ᵥ p2 - (p -ᵥ p1) ∈ p_1		k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : add_torsor V P,	s : set P,	p : P,	hp : p ∈ s	⊢ has_vsub.vsub p '' s ⊆ s -ᵥ s", "decl_nm": "vector_span_eq_span_vsub_set_left"
{"src": "k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : add_torsor V P,	s : set P,	p : P,	hp : p ∈ s	⊢ has_vsub.vsub p '' s ⊆ s -ᵥ s", "decl_nm": "vector_span_eq_span_vsub_set_left"
{"src": "k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : add_torsor V P,	s : set P,	p : P,	hp : p ∈ s,	v : V,	p2 : P,	hp2 : p2 ∈ s,	hv : p -ᵥ p2 = v	⊢ v ∈ s -ᵥ s", "decl_nm": "vector_span_eq_span_vsub_set_left"
{"src": "⊢ ∀ (k : Type u_1) {V : Type u_2} {P : Type u_3} [_inst_1 : ring k] [_inst_2 : add_comm_group V]	  [_inst_3 : module k V] [_inst_4 : add_torsor V P] {ι : Type u_4} (p : ι → P) {s : set ι} {i : ι},	    i ∈ s → vector_span k (p '' s) = submodule.span k (has_vsub.vsub (p i) '' (p '' (s \ {i})))", "decl_nm": "vector_span_image_eq_span_vsub_set_left_ne"
{"src": "k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : add_torsor V P,	ι : Type u_4,	p : ι → P,	s : set ι,	i : ι,	hi : i ∈ s	⊢ vector_span k (p '' s) = submodule.span k (has_vsub.vsub (p i) '' (p '' (s \ {i})))", "decl_nm": "vector_span_image_eq_span_vsub_set_left_ne"
{"src": "k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : add_torsor V P,	ι : Type u_4,	p : ι → P,	s : set ι,	i : ι,	hi : i ∈ s	⊢ submodule.span k (insert (p i -ᵥ p i) (has_vsub.vsub (p i) '' (p '' (s \ {i})))) =	    submodule.span k (has_vsub.vsub (p i) '' (p '' (s \ {i})))", "decl_nm": "vector_span_image_eq_span_vsub_set_left_ne"
{"src": "⊢ ∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [_inst_1 : ring k] [_inst_2 : add_comm_group V]	  [_inst_3 : module k V] [S : add_torsor V P] {ι : Type u_4} (s : finset ι) (w : ι → k) (p : ι → P),	    s.sum (λ (i : ι), w i) = 1 →	    ∀ (b₁ b₂ : P),	      ⇑(s.weighted_vsub_of_point p b₁) w +ᵥ b₁ = ⇑(s.weighted_vsub_of_point p b₂) w +ᵥ b₂", "decl_nm": "finset.weighted_vsub_of_point_vadd_eq_of_sum_eq_one"
{"src": "k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	S : add_torsor V P,	ι : Type u_4,	s : finset ι,	w : ι → k,	p : ι → P,	h : s.sum (λ (i : ι), w i) = 1,	b₁ b₂ : P	⊢ ⇑(s.weighted_vsub_of_point p b₁) w +ᵥ b₁ = ⇑(s.weighted_vsub_of_point p b₂) w +ᵥ b₂", "decl_nm": "finset.weighted_vsub_of_point_vadd_eq_of_sum_eq_one"
{"src": "k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	S : add_torsor V P,	ι : Type u_4,	s : finset ι,	w : ι → k,	p : ι → P,	h : s.sum (λ (i : ι), w i) = 1,	b₁ b₂ : P	⊢ b₁ -ᵥ b₂ + s.sum (λ (x : ι), w x • (p x -ᵥ b₁) - w x • (p x -ᵥ b₂)) = 0", "decl_nm": "finset.weighted_vsub_of_point_vadd_eq_of_sum_eq_one"
{"src": "k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : ring k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	S : add_torsor V P,	ι : Type u_4,	s : finset ι,	w : ι → k,	p : ι → P,	h : s.sum (λ (i : ι), w i) = 1,	b₁ b₂ : P	⊢ b₁ -ᵥ b₂ + s.sum (λ (x : ι), w x • (b₂ -ᵥ b₁)) = 0", "decl_nm": "finset.weighted_vsub_of_point_vadd_eq_of_sum_eq_one"
{"src": "⊢ ∀ (k : Type u_1) {V : Type u_2} {P : Type u_3} [_inst_1 : field k] [_inst_2 : add_comm_group V]	  [_inst_3 : module k V] [_inst_4 : add_torsor V P] (p : fin 3 → P),	    affine_independent k p ↔ ¬collinear k (set.range p)", "decl_nm": "affine_independent_iff_not_collinear"
{"src": "k : Type u_1,	V : Type u_2,	P : Type u_3,	_inst_1 : field k,	_inst_2 : add_comm_group V,	_inst_3 : module k V,	_inst_4 : add_torsor V P,	p : fin 3 → P	⊢ affine_independent k p ↔ ¬collinear k (set.range p)", "decl_nm": "affine_independent_iff_not_collinear"
{"src": "⊢ ∀ {k : Type u_1} {E : Type u_2} {PE : Type u_3} [_inst_1 : field k] [_inst_2 : add_comm_group E]	  [_inst_3 : module k E] [_inst_4 : add_torsor E PE] (f : k → PE) (a b : k), slope f a b = slope f b a", "decl_nm": "slope_comm"
{"src": "k : Type u_1,	E : Type u_2,	PE : Type u_3,	_inst_1 : field k,	_inst_2 : add_comm_group E,	_inst_3 : module k E,	_inst_4 : add_torsor E PE,	f : k → PE,	a b : k	⊢ slope f a b = slope f b a", "decl_nm": "slope_comm"
{"src": "⊢ ∀ {R : Type u_1} {M : Type u_9} [_inst_1 : semiring R] [_inst_4 : add_comm_monoid M] [_inst_8 : module R M]	  (p p' : submodule R M), ↑(p ⊔ p') = ↑p + ↑p'", "decl_nm": "submodule.coe_sup"
{"src": "R : Type u_1,	M : Type u_9,	_inst_1 : semiring R,	_inst_4 : add_comm_monoid M,	_inst_8 : module R M,	p p' : submodule R M	⊢ ↑(p ⊔ p') = ↑p + ↑p'", "decl_nm": "submodule.coe_sup"
{"src": "R : Type u_1,	M : Type u_9,	_inst_1 : semiring R,	_inst_4 : add_comm_monoid M,	_inst_8 : module R M,	p p' : submodule R M,	x : M	⊢ x ∈ ↑(p ⊔ p') ↔ x ∈ ↑p + ↑p'", "decl_nm": "submodule.coe_sup"
{"src": "R : Type u_1,	M : Type u_9,	_inst_1 : semiring R,	_inst_4 : add_comm_monoid M,	_inst_8 : module R M,	p p' : submodule R M,	x : M	⊢ (∃ (y : M) (H : y ∈ p) (z : M) (H : z ∈ p'), y + z = x) ↔	    ∃ (x_1 y : M), x_1 ∈ ↑p ∧ y ∈ ↑p' ∧ x_1 + y = x", "decl_nm": "submodule.coe_sup"
{"src": "⊢ ∀ {R : Type u_1} {R₂ : Type u_3} {R₃ : Type u_4} {M : Type u_9} {M₂ : Type u_12} {M₃ : Type u_13}	  [_inst_1 : semiring R] [_inst_2 : semiring R₂] [_inst_3 : semiring R₃] [_inst_4 : add_comm_monoid M]	  [_inst_5 : add_comm_monoid M₂] [_inst_6 : add_comm_monoid M₃] [_inst_7 : module R M] [_inst_8 : module R₂ M₂]	  [_inst_9 : module R₃ M₃] {τ₁₂ : R →+* R₂} {τ₂₃ : R₂ →+* R₃} {τ₁₃ : R →+* R₃}	  [_inst_10 : ring_hom_comp_triple τ₁₂ τ₂₃ τ₁₃] (f : M →ₛₗ[τ₁₂] M₂)	  {g : M₂ →ₛₗ[τ₂₃] M₃}, g.ker = ⊥ → (g.comp f).ker = f.ker", "decl_nm": "linear_map.ker_comp_of_ker_eq_bot"
{"src": "R : Type u_1,	R₂ : Type u_3,	R₃ : Type u_4,	M : Type u_9,	M₂ : Type u_12,	M₃ : Type u_13,	_inst_1 : semiring R,	_inst_2 : semiring R₂,	_inst_3 : semiring R₃,	_inst_4 : add_comm_monoid M,	_inst_5 : add_comm_monoid M₂,	_inst_6 : add_comm_monoid M₃,	_inst_7 : module R M,	_inst_8 : module R₂ M₂,	_inst_9 : module R₃ M₃,	τ₁₂ : R →+* R₂,	τ₂₃ : R₂ →+* R₃,	τ₁₃ : R →+* R₃,	_inst_10 : ring_hom_comp_triple τ₁₂ τ₂₃ τ₁₃,	f : M →ₛₗ[τ₁₂] M₂,	g : M₂ →ₛₗ[τ₂₃] M₃,	hg : g.ker = ⊥	⊢ (g.comp f).ker = f.ker", "decl_nm": "linear_map.ker_comp_of_ker_eq_bot"
{"src": "⊢ ∀ (R : Type u_1) (M : Type u_9) [_inst_1 : semiring R] [_inst_2 : add_comm_monoid M] [_inst_3 : module R M]	  {m : Type u_20} {n : Type u_21} (f : m → n), injective f → surjective ⇑(fun_left R M f)", "decl_nm": "linear_map.fun_left_surjective_of_injective"
{"src": "R : Type u_1,	M : Type u_9,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : module R M,	m : Type u_20,	n : Type u_21,	f : m → n,	hf : injective f	⊢ surjective ⇑(fun_left R M f)", "decl_nm": "linear_map.fun_left_surjective_of_injective"
{"src": "R : Type u_1,	M : Type u_9,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : module R M,	m : Type u_20,	n : Type u_21,	f : m → n,	hf : injective f,	_inst : Π (a : Prop), decidable a	⊢ surjective ⇑(fun_left R M f)", "decl_nm": "linear_map.fun_left_surjective_of_injective"
{"src": "R : Type u_1,	M : Type u_9,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : module R M,	m : Type u_20,	n : Type u_21,	f : m → n,	hf : injective f,	_inst : Π (a : Prop), decidable a,	g : m → M	⊢ ∃ (a : n → M), ⇑(fun_left R M f) a = g", "decl_nm": "linear_map.fun_left_surjective_of_injective"
{"src": "R : Type u_1,	M : Type u_9,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : module R M,	m : Type u_20,	n : Type u_21,	f : m → n,	hf : injective f,	_inst : Π (a : Prop), decidable a,	g : m → M	⊢ ⇑(fun_left R M f)	      (λ (x : n),	         dite (∃ (y : m), f y = x) (λ (h : ∃ (y : m), f y = x), g h.some) (λ (h : ¬∃ (y : m), f y = x), 0)) =	    g", "decl_nm": "linear_map.fun_left_surjective_of_injective"
{"src": "R : Type u_1,	M : Type u_9,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : module R M,	m : Type u_20,	n : Type u_21,	f : m → n,	hf : injective f,	_inst : Π (a : Prop), decidable a,	g : m → M,	x : m	⊢ ⇑(fun_left R M f)	      (λ (x : n),	         dite (∃ (y : m), f y = x) (λ (h : ∃ (y : m), f y = x), g h.some) (λ (h : ¬∃ (y : m), f y = x), 0))	      x =	    g x", "decl_nm": "linear_map.fun_left_surjective_of_injective"
{"src": "R : Type u_1,	M : Type u_9,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : module R M,	m : Type u_20,	n : Type u_21,	f : m → n,	hf : injective f,	_inst : Π (a : Prop), decidable a,	g : m → M,	x : m	⊢ dite (∃ (y : m), f y = f x) (λ (h : ∃ (y : m), f y = f x), g h.some) (λ (h : ¬∃ (y : m), f y = f x), 0) =	    g x", "decl_nm": "linear_map.fun_left_surjective_of_injective"
{"src": "2 goals	R : Type u_1,	M : Type u_9,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : module R M,	m : Type u_20,	n : Type u_21,	f : m → n,	hf : injective f,	_inst : Π (a : Prop), decidable a,	g : m → M,	x : m,	w : ∃ (y : m), f y = f x	⊢ g w.some = g x		R : Type u_1,	M : Type u_9,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : module R M,	m : Type u_20,	n : Type u_21,	f : m → n,	hf : injective f,	_inst : Π (a : Prop), decidable a,	g : m → M,	x : m,	w : ¬∃ (y : m), f y = f x	⊢ 0 = g x", "decl_nm": "linear_map.fun_left_surjective_of_injective"
{"src": "2 goals	R : Type u_1,	M : Type u_9,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : module R M,	m : Type u_20,	n : Type u_21,	f : m → n,	hf : injective f,	_inst : Π (a : Prop), decidable a,	g : m → M,	x : m,	w : ∃ (y : m), f y = f x	⊢ w.some = x		R : Type u_1,	M : Type u_9,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : module R M,	m : Type u_20,	n : Type u_21,	f : m → n,	hf : injective f,	_inst : Π (a : Prop), decidable a,	g : m → M,	x : m,	w : ¬∃ (y : m), f y = f x	⊢ 0 = g x", "decl_nm": "linear_map.fun_left_surjective_of_injective"
{"src": "R : Type u_1,	M : Type u_9,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : module R M,	m : Type u_20,	n : Type u_21,	f : m → n,	hf : injective f,	_inst : Π (a : Prop), decidable a,	g : m → M,	x : m,	w : ¬∃ (y : m), f y = f x	⊢ 0 = g x", "decl_nm": "linear_map.fun_left_surjective_of_injective"
{"src": "⊢ ∀ {R : Type u_1} [_inst_1 : comm_ring R] {M₁ : Type u_4} {M₂ : Type u_5} {M₃ : Type u_6}	  [_inst_6 : add_comm_group M₁] [_inst_7 : add_comm_group M₂] [_inst_8 : add_comm_group M₃]	  [_inst_9 : module R M₁] [_inst_10 : module R M₂] [_inst_11 : module R M₃] {Q₁ : quadratic_form R M₁}	  {Q₂ : quadratic_form R M₂} {Q₃ : quadratic_form R M₃} (e₁₂ : Q₁.isometry Q₂)	  (e₂₃ : Q₂.isometry Q₃),	    (equiv_of_isometry e₁₂).trans (equiv_of_isometry e₂₃) = equiv_of_isometry (e₁₂.trans e₂₃)", "decl_nm": "clifford_algebra.equiv_of_isometry_trans"
{"src": "R : Type u_1,	_inst_1 : comm_ring R,	M₁ : Type u_4,	M₂ : Type u_5,	M₃ : Type u_6,	_inst_6 : add_comm_group M₁,	_inst_7 : add_comm_group M₂,	_inst_8 : add_comm_group M₃,	_inst_9 : module R M₁,	_inst_10 : module R M₂,	_inst_11 : module R M₃,	Q₁ : quadratic_form R M₁,	Q₂ : quadratic_form R M₂,	Q₃ : quadratic_form R M₃,	e₁₂ : Q₁.isometry Q₂,	e₂₃ : Q₂.isometry Q₃	⊢ (equiv_of_isometry e₁₂).trans (equiv_of_isometry e₂₃) = equiv_of_isometry (e₁₂.trans e₂₃)", "decl_nm": "clifford_algebra.equiv_of_isometry_trans"
{"src": "R : Type u_1,	_inst_1 : comm_ring R,	M₁ : Type u_4,	M₂ : Type u_5,	M₃ : Type u_6,	_inst_6 : add_comm_group M₁,	_inst_7 : add_comm_group M₂,	_inst_8 : add_comm_group M₃,	_inst_9 : module R M₁,	_inst_10 : module R M₂,	_inst_11 : module R M₃,	Q₁ : quadratic_form R M₁,	Q₂ : quadratic_form R M₂,	Q₃ : quadratic_form R M₃,	e₁₂ : Q₁.isometry Q₂,	e₂₃ : Q₂.isometry Q₃,	x : clifford_algebra Q₁	⊢ ⇑((equiv_of_isometry e₁₂).trans (equiv_of_isometry e₂₃)) x =	    ⇑(equiv_of_isometry (e₁₂.trans e₂₃)) x", "decl_nm": "clifford_algebra.equiv_of_isometry_trans"
{"src": "⊢ ∀ {R : Type u_1} [_inst_1 : comm_ring R] {c₁ c₂ : R},	    to_quaternion.comp of_quaternion = alg_hom.id R (quaternion_algebra R c₁ c₂)", "decl_nm": "clifford_algebra_quaternion.to_quaternion_comp_of_quaternion"
{"src": "R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R	⊢ to_quaternion.comp of_quaternion = alg_hom.id R (quaternion_algebra R c₁ c₂)", "decl_nm": "clifford_algebra_quaternion.to_quaternion_comp_of_quaternion"
{"src": "R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R	⊢ ⇑(lift.symm) (to_quaternion.comp of_quaternion) = ⇑(lift.symm) (alg_hom.id R (quaternion_algebra R c₁ c₂))", "decl_nm": "clifford_algebra_quaternion.to_quaternion_comp_of_quaternion"
{"src": "2 goals	R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R	⊢ (⇑(lift.symm) (to_quaternion.comp of_quaternion)).i =	    (⇑(lift.symm) (alg_hom.id R (quaternion_algebra R c₁ c₂))).i		R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R	⊢ (⇑(lift.symm) (to_quaternion.comp of_quaternion)).j =	    (⇑(lift.symm) (alg_hom.id R (quaternion_algebra R c₁ c₂))).j", "decl_nm": "clifford_algebra_quaternion.to_quaternion_comp_of_quaternion"
{"src": "2 goals	R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R	⊢ ⇑to_quaternion	      (⇑(algebra_map R (clifford_algebra (Q c₁ c₂))) 0 + 1 • ⇑(ι (Q c₁ c₂)) (1, 0) +	           0 • ⇑(ι (Q c₁ c₂)) (0, 1) +	         0 • (⇑(ι (Q c₁ c₂)) (1, 0) * ⇑(ι (Q c₁ c₂)) (0, 1))) =	    {re := 0, im_i := 1, im_j := 0, im_k := 0}		R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R	⊢ (⇑(lift.symm) (to_quaternion.comp of_quaternion)).j =	    (⇑(lift.symm) (alg_hom.id R (quaternion_algebra R c₁ c₂))).j", "decl_nm": "clifford_algebra_quaternion.to_quaternion_comp_of_quaternion"
{"src": "R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R	⊢ (⇑(lift.symm) (to_quaternion.comp of_quaternion)).j =	    (⇑(lift.symm) (alg_hom.id R (quaternion_algebra R c₁ c₂))).j", "decl_nm": "clifford_algebra_quaternion.to_quaternion_comp_of_quaternion"
{"src": "R : Type u_1,	_inst_1 : comm_ring R,	c₁ c₂ : R	⊢ ⇑to_quaternion	      (⇑(algebra_map R (clifford_algebra (Q c₁ c₂))) 0 + 0 • ⇑(ι (Q c₁ c₂)) (1, 0) +	           1 • ⇑(ι (Q c₁ c₂)) (0, 1) +	         0 • (⇑(ι (Q c₁ c₂)) (1, 0) * ⇑(ι (Q c₁ c₂)) (0, 1))) =	    {re := 0, im_i := 0, im_j := 1, im_k := 0}", "decl_nm": "clifford_algebra_quaternion.to_quaternion_comp_of_quaternion"
{"src": "⊢ ∀ {R : Type u_1} [_inst_1 : comm_ring R], involute = alg_hom.id R (clifford_algebra 0)", "decl_nm": "clifford_algebra_ring.involute_eq_id"
{"src": "R : Type u_1,	_inst_1 : comm_ring R	⊢ involute = alg_hom.id R (clifford_algebra 0)", "decl_nm": "clifford_algebra_ring.involute_eq_id"
{"src": "R : Type u_1,	_inst_1 : comm_ring R,	x : unit	⊢ ⇑(involute.to_linear_map.comp (ι 0)) x = ⇑((alg_hom.id R (clifford_algebra 0)).to_linear_map.comp (ι 0)) x", "decl_nm": "clifford_algebra_ring.involute_eq_id"
{"src": "⊢ ∀ {R : Type u} [_inst_1 : ring R] {M : Type v} [_inst_2 : add_comm_group M] [_inst_3 : module R M] {M' : Type v'}	  [_inst_4 : add_comm_group M'] [_inst_5 : module R M'],	    (M ≃ₗ[R] M') → (module.rank R M).lift = (module.rank R M').lift", "decl_nm": "linear_equiv.lift_dim_eq"
{"src": "R : Type u,	_inst_1 : ring R,	M : Type v,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	M' : Type v',	_inst_4 : add_comm_group M',	_inst_5 : module R M',	f : M ≃ₗ[R] M'	⊢ (module.rank R M).lift = (module.rank R M').lift", "decl_nm": "linear_equiv.lift_dim_eq"
{"src": "2 goals	R : Type u,	_inst_1 : ring R,	M : Type v,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	M' : Type v',	_inst_4 : add_comm_group M',	_inst_5 : module R M',	f : M ≃ₗ[R] M'	⊢ (module.rank R M).lift ≤ (module.rank R M').lift		R : Type u,	_inst_1 : ring R,	M : Type v,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	M' : Type v',	_inst_4 : add_comm_group M',	_inst_5 : module R M',	f : M ≃ₗ[R] M'	⊢ (module.rank R M').lift ≤ (module.rank R M).lift", "decl_nm": "linear_equiv.lift_dim_eq"
{"src": "R : Type u,	_inst_1 : ring R,	M : Type v,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	M' : Type v',	_inst_4 : add_comm_group M',	_inst_5 : module R M',	f : M ≃ₗ[R] M'	⊢ (module.rank R M').lift ≤ (module.rank R M).lift", "decl_nm": "linear_equiv.lift_dim_eq"
{"src": "⊢ ∀ {R : Type u_1} {M : Type u_2} {ι : Type u_5} [_inst_1 : comm_ring R] [_inst_2 : add_comm_group M]	  [_inst_3 : module R M] [_inst_4 : decidable_eq ι] (b : basis ι R M) [_inst_5 : fintype ι],	    ⇑(b.dual_basis) = b.coord", "decl_nm": "basis.coe_dual_basis"
{"src": "R : Type u_1,	M : Type u_2,	ι : Type u_5,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_4 : decidable_eq ι,	b : basis ι R M,	_inst_5 : fintype ι	⊢ ⇑(b.dual_basis) = b.coord", "decl_nm": "basis.coe_dual_basis"
{"src": "R : Type u_1,	M : Type u_2,	ι : Type u_5,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_4 : decidable_eq ι,	b : basis ι R M,	_inst_5 : fintype ι,	i : ι,	x : M	⊢ ⇑(⇑(b.dual_basis) i) x = ⇑(b.coord i) x", "decl_nm": "basis.coe_dual_basis"
{"src": "⊢ ∀ {R : Type u_1} {M : Type u_2} {ι : Type u_3} [_inst_1 : comm_ring R] [_inst_2 : add_comm_group M]	  [_inst_3 : module R M] {e : ι → M} {ε : ι → dual R M} [_inst_4 : decidable_eq ι] (h : dual_pair e ε)	  (l : ι →₀ R), h.coeffs (lc e l) = l", "decl_nm": "dual_pair.coeffs_lc"
{"src": "R : Type u_1,	M : Type u_2,	ι : Type u_3,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	e : ι → M,	ε : ι → dual R M,	_inst_4 : decidable_eq ι,	h : dual_pair e ε,	l : ι →₀ R	⊢ h.coeffs (lc e l) = l", "decl_nm": "dual_pair.coeffs_lc"
{"src": "R : Type u_1,	M : Type u_2,	ι : Type u_3,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	e : ι → M,	ε : ι → dual R M,	_inst_4 : decidable_eq ι,	h : dual_pair e ε,	l : ι →₀ R,	i : ι	⊢ ⇑(h.coeffs (lc e l)) i = ⇑l i", "decl_nm": "dual_pair.coeffs_lc"
{"src": "⊢ ∀ {α : Type u_1} {M : Type u_2} (R : Type u_5) [_inst_1 : semiring R] [_inst_3 : add_comm_monoid M]	  [_inst_4 : module R M] {s : set α} (p : α →₀ M), p ∈ supported M R s ↔ ∀ (x : α), x ∉ s → ⇑p x = 0", "decl_nm": "finsupp.mem_supported'"
{"src": "α : Type u_1,	M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	s : set α,	p : α →₀ M	⊢ p ∈ supported M R s ↔ ∀ (x : α), x ∉ s → ⇑p x = 0", "decl_nm": "finsupp.mem_supported'"
{"src": "α : Type u_1,	M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	s : set α,	p : α →₀ M,	_inst : decidable_pred (λ (x : α), x ∈ s)	⊢ p ∈ supported M R s ↔ ∀ (x : α), x ∉ s → ⇑p x = 0", "decl_nm": "finsupp.mem_supported'"
{"src": "⊢ ∀ {α : Type u_1} {M : Type u_2} {R : Type u_5} [_inst_1 : semiring R] [_inst_3 : add_comm_monoid M]	  [_inst_4 : module R M] [_inst_9 : nontrivial M] {s t : set α},	    disjoint (supported M R s) (supported M R t) ↔ disjoint s t", "decl_nm": "finsupp.disjoint_supported_supported_iff"
{"src": "α : Type u_1,	M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	_inst_9 : nontrivial M,	s t : set α	⊢ disjoint (supported M R s) (supported M R t) ↔ disjoint s t", "decl_nm": "finsupp.disjoint_supported_supported_iff"
{"src": "α : Type u_1,	M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	_inst_9 : nontrivial M,	s t : set α,	h : disjoint (supported M R s) (supported M R t),	x : α,	hx : x ∈ s ⊓ t	⊢ x ∈ ⊥", "decl_nm": "finsupp.disjoint_supported_supported_iff"
{"src": "α : Type u_1,	M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	_inst_9 : nontrivial M,	s t : set α,	h : disjoint (supported M R s) (supported M R t),	x : α,	hx : x ∈ s ⊓ t,	y : M,	hy : y ≠ 0	⊢ x ∈ ⊥", "decl_nm": "finsupp.disjoint_supported_supported_iff"
{"src": "α : Type u_1,	M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	_inst_9 : nontrivial M,	s t : set α,	h : disjoint (supported M R s) (supported M R t),	x : α,	hx : x ∈ s ⊓ t,	y : M,	hy : y ≠ 0,	this : single x y ∈ ⊥	⊢ x ∈ ⊥", "decl_nm": "finsupp.disjoint_supported_supported_iff"
{"src": "α : Type u_1,	M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	_inst_9 : nontrivial M,	s t : set α,	h : disjoint (supported M R s) (supported M R t),	x : α,	hx : x ∈ s ⊓ t,	y : M,	hy : y ≠ 0,	this : y = 0	⊢ x ∈ ⊥", "decl_nm": "finsupp.disjoint_supported_supported_iff"
{"src": "⊢ ∀ {α : Type u_1} {M : Type u_2} (R : Type u_5) [_inst_1 : semiring R] [_inst_3 : add_comm_monoid M]	  [_inst_4 : module R M] {α' : Type u_7} {v : α → M} (f : α' → α),	    finsupp.total α' M R (v ∘ f) = (finsupp.total α M R v).comp (lmap_domain R R f)", "decl_nm": "finsupp.total_comp"
{"src": "α : Type u_1,	M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	α' : Type u_7,	v : α → M,	f : α' → α	⊢ finsupp.total α' M R (v ∘ f) = (finsupp.total α M R v).comp (lmap_domain R R f)", "decl_nm": "finsupp.total_comp"
{"src": "α : Type u_1,	M : Type u_2,	R : Type u_5,	_inst_1 : semiring R,	_inst_3 : add_comm_monoid M,	_inst_4 : module R M,	α' : Type u_7,	v : α → M,	f : α' → α,	a : α'	⊢ ⇑((finsupp.total α' M R (v ∘ f)).comp (lsingle a)) 1 =	    ⇑(((finsupp.total α M R v).comp (lmap_domain R R f)).comp (lsingle a)) 1", "decl_nm": "finsupp.total_comp"
{"src": "⊢ ∀ {ι : Type u_1} {R : Type u_3} {M : Type u_5} {v : ι → M} [_inst_1 : ring R] [_inst_2 : add_comm_group M]	  [_inst_5 : module R M] (hv : linear_independent R v) [_inst_8 : nontrivial R] (x : ↥(span R (range v))),	    span.repr R (range v) x = finsupp.equiv_map_domain (equiv.of_injective v _) (⇑(hv.repr) x)", "decl_nm": "linear_independent.span_repr_eq"
{"src": "ι : Type u_1,	R : Type u_3,	M : Type u_5,	v : ι → M,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_5 : module R M,	hv : linear_independent R v,	_inst_8 : nontrivial R,	x : ↥(span R (range v))	⊢ span.repr R (range v) x = finsupp.equiv_map_domain (equiv.of_injective v _) (⇑(hv.repr) x)", "decl_nm": "linear_independent.span_repr_eq"
{"src": "2 goals	ι : Type u_1,	R : Type u_3,	M : Type u_5,	v : ι → M,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_5 : module R M,	hv : linear_independent R v,	_inst_8 : nontrivial R,	x : ↥(span R (range v))	⊢ finsupp.equiv_map_domain (equiv.of_injective v _).symm (span.repr R (range v) x) = ⇑(hv.repr) x		ι : Type u_1,	R : Type u_3,	M : Type u_5,	v : ι → M,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_5 : module R M,	hv : linear_independent R v,	_inst_8 : nontrivial R,	x : ↥(span R (range v)),	p : finsupp.equiv_map_domain (equiv.of_injective v _).symm (span.repr R (range v) x) = ⇑(hv.repr) x	⊢ span.repr R (range v) x = finsupp.equiv_map_domain (equiv.of_injective v _) (⇑(hv.repr) x)", "decl_nm": "linear_independent.span_repr_eq"
{"src": "2 goals	ι : Type u_1,	R : Type u_3,	M : Type u_5,	v : ι → M,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_5 : module R M,	hv : linear_independent R v,	_inst_8 : nontrivial R,	x : ↥(span R (range v))	⊢ ⇑(hv.total_equiv) (finsupp.equiv_map_domain (equiv.of_injective v _).symm (span.repr R (range v) x)) =	    ⇑(hv.total_equiv) (⇑(hv.repr) x)		ι : Type u_1,	R : Type u_3,	M : Type u_5,	v : ι → M,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_5 : module R M,	hv : linear_independent R v,	_inst_8 : nontrivial R,	x : ↥(span R (range v)),	p : finsupp.equiv_map_domain (equiv.of_injective v _).symm (span.repr R (range v) x) = ⇑(hv.repr) x	⊢ span.repr R (range v) x = finsupp.equiv_map_domain (equiv.of_injective v _) (⇑(hv.repr) x)", "decl_nm": "linear_independent.span_repr_eq"
{"src": "2 goals	ι : Type u_1,	R : Type u_3,	M : Type u_5,	v : ι → M,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_5 : module R M,	hv : linear_independent R v,	_inst_8 : nontrivial R,	x : ↥(span R (range v))	⊢ ↑(⇑(hv.total_equiv) (finsupp.equiv_map_domain (equiv.of_injective v _).symm (span.repr R (range v) x))) =	    ↑(⇑(hv.total_equiv) (⇑(hv.repr) x))		ι : Type u_1,	R : Type u_3,	M : Type u_5,	v : ι → M,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_5 : module R M,	hv : linear_independent R v,	_inst_8 : nontrivial R,	x : ↥(span R (range v)),	p : finsupp.equiv_map_domain (equiv.of_injective v _).symm (span.repr R (range v) x) = ⇑(hv.repr) x	⊢ span.repr R (range v) x = finsupp.equiv_map_domain (equiv.of_injective v _) (⇑(hv.repr) x)", "decl_nm": "linear_independent.span_repr_eq"
{"src": "ι : Type u_1,	R : Type u_3,	M : Type u_5,	v : ι → M,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_5 : module R M,	hv : linear_independent R v,	_inst_8 : nontrivial R,	x : ↥(span R (range v)),	p : finsupp.equiv_map_domain (equiv.of_injective v _).symm (span.repr R (range v) x) = ⇑(hv.repr) x	⊢ span.repr R (range v) x = finsupp.equiv_map_domain (equiv.of_injective v _) (⇑(hv.repr) x)", "decl_nm": "linear_independent.span_repr_eq"
{"src": "ι : Type u_1,	R : Type u_3,	M : Type u_5,	v : ι → M,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_5 : module R M,	hv : linear_independent R v,	_inst_8 : nontrivial R,	x : ↥(span R (range v)),	p : finsupp.equiv_map_domain (equiv.of_injective v _).symm (span.repr R (range v) x) = ⇑(hv.repr) x,	i : ι	⊢ ⇑(span.repr R (range v) x) ⟨v i, _⟩ =	    ⇑(finsupp.equiv_map_domain (equiv.of_injective v _) (⇑(hv.repr) x)) ⟨v i, _⟩", "decl_nm": "linear_independent.span_repr_eq"
{"src": "⊢ ∀ {ι : Type u_1} {ι' : Type u_2} {R : Type u_5} {M : Type u_6} [_inst_1 : comm_ring R]	  [_inst_2 : add_comm_group M] [_inst_3 : module R M] (e : basis ι R M) (v : ι' → M) (j : ι')	  [_inst_4 : fintype ι], finset.univ.sum (λ (i : ι), e.to_matrix v i j • ⇑e i) = v j", "decl_nm": "basis.sum_to_matrix_smul_self"
{"src": "ι : Type u_1,	ι' : Type u_2,	R : Type u_5,	M : Type u_6,	_inst_1 : comm_ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	e : basis ι R M,	v : ι' → M,	j : ι',	_inst_4 : fintype ι	⊢ finset.univ.sum (λ (i : ι), e.to_matrix v i j • ⇑e i) = v j", "decl_nm": "basis.sum_to_matrix_smul_self"
{"src": "⊢ ∀ {α : Type u_1} {n : Type u_4} [_inst_1 : has_star α] [_inst_2 : add_group n] (v : n → α),	    (circulant v).conj_transpose = circulant (star (λ (i : n), v (-i)))", "decl_nm": "matrix.conj_transpose_circulant"
{"src": "α : Type u_1,	n : Type u_4,	_inst_1 : has_star α,	_inst_2 : add_group n,	v : n → α	⊢ (circulant v).conj_transpose = circulant (star (λ (i : n), v (-i)))", "decl_nm": "matrix.conj_transpose_circulant"
{"src": "α : Type u_1,	n : Type u_4,	_inst_1 : has_star α,	_inst_2 : add_group n,	v : n → α,	i j : n	⊢ (circulant v).conj_transpose i j = circulant (star (λ (i : n), v (-i))) i j", "decl_nm": "matrix.conj_transpose_circulant"
{"src": "⊢ ∀ {n' : Type u_1} [_inst_1 : decidable_eq n'] [_inst_2 : fintype n'] {R : Type u_2} [_inst_3 : comm_ring R]	  (u : (matrix n' n' R)ˣ), ↑u⁻¹ = (↑u)⁻¹", "decl_nm": "matrix.units.coe_inv''"
{"src": "n' : Type u_1,	_inst_1 : decidable_eq n',	_inst_2 : fintype n',	R : Type u_2,	_inst_3 : comm_ring R,	u : (matrix n' n' R)ˣ	⊢ ↑u⁻¹ = (↑u)⁻¹", "decl_nm": "matrix.units.coe_inv''"
{"src": "n' : Type u_1,	_inst_1 : decidable_eq n',	_inst_2 : fintype n',	R : Type u_2,	_inst_3 : comm_ring R,	u : (matrix n' n' R)ˣ	⊢ ↑u⁻¹.mul ↑u = 1", "decl_nm": "matrix.units.coe_inv''"
{"src": "⊢ ∀ {n : Type u} [_inst_1 : decidable_eq n] [_inst_2 : fintype n] {α : Type v} [_inst_3 : comm_ring α]	  {A : matrix n n α}, fintype.card n = 1 → A.adjugate = 1", "decl_nm": "matrix.adjugate_eq_one_of_card_eq_one"
{"src": "n : Type u,	_inst_1 : decidable_eq n,	_inst_2 : fintype n,	α : Type v,	_inst_3 : comm_ring α,	A : matrix n n α,	h : fintype.card n = 1	⊢ A.adjugate = 1", "decl_nm": "matrix.adjugate_eq_one_of_card_eq_one"
{"src": "n : Type u,	_inst_1 : decidable_eq n,	_inst_2 : fintype n,	α : Type v,	_inst_3 : comm_ring α,	A : matrix n n α,	h : fintype.card n = 1,	_inst : subsingleton n	⊢ A.adjugate = 1", "decl_nm": "matrix.adjugate_eq_one_of_card_eq_one"
{"src": "⊢ ∀ {R : Type u_1} [_inst_1 : comm_ring R] {n : Type u_4} [_inst_2 : fintype n] [_inst_3 : decidable_eq n]	  {M : matrix n n R}, (⇑to_lin' M).ker = ⊥ ↔ ∀ (v : n → R), M.mul_vec v = 0 → v = 0", "decl_nm": "matrix.ker_to_lin'_eq_bot_iff"
{"src": "R : Type u_1,	_inst_1 : comm_ring R,	n : Type u_4,	_inst_2 : fintype n,	_inst_3 : decidable_eq n,	M : matrix n n R	⊢ (⇑to_lin' M).ker = ⊥ ↔ ∀ (v : n → R), M.mul_vec v = 0 → v = 0", "decl_nm": "matrix.ker_to_lin'_eq_bot_iff"
{"src": "⊢ ∀ {R : Type u} {n : ℕ} [_inst_2 : comm_semiring R] {A : Type u_1} [_inst_9 : semiring A]	  [_inst_10 : algebra R A] (a : A), ⇑(multilinear_map.mk_pi_algebra_fin R n A) (λ (_x : fin n), a) = a ^ n", "decl_nm": "multilinear_map.mk_pi_algebra_fin_apply_const"
{"src": "R : Type u,	n : ℕ,	_inst_2 : comm_semiring R,	A : Type u_1,	_inst_9 : semiring A,	_inst_10 : algebra R A,	a : A	⊢ ⇑(multilinear_map.mk_pi_algebra_fin R n A) (λ (_x : fin n), a) = a ^ n", "decl_nm": "multilinear_map.mk_pi_algebra_fin_apply_const"
{"src": "⊢ ∀ {R : Type u} {M : Type v} {M₂ : Type w} [_inst_1 : semiring R] [_inst_2 : add_comm_monoid M]	  [_inst_3 : add_comm_monoid M₂] [_inst_4 : module R M] [_inst_5 : module R M₂] (p : submodule R M),	    comap (fst R M M₂) p = p.prod ⊤", "decl_nm": "submodule.comap_fst"
{"src": "R : Type u,	M : Type v,	M₂ : Type w,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : add_comm_monoid M₂,	_inst_4 : module R M,	_inst_5 : module R M₂,	p : submodule R M	⊢ comap (fst R M M₂) p = p.prod ⊤", "decl_nm": "submodule.comap_fst"
{"src": "R : Type u,	M : Type v,	M₂ : Type w,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : add_comm_monoid M₂,	_inst_4 : module R M,	_inst_5 : module R M₂,	p : submodule R M,	x : M,	y : M₂	⊢ (x, y) ∈ comap (fst R M M₂) p ↔ (x, y) ∈ p.prod ⊤", "decl_nm": "submodule.comap_fst"
{"src": "⊢ ∀ (R : Type u) (M : Type v) (M₂ : Type w) [_inst_1 : semiring R] [_inst_2 : add_comm_monoid M]	  [_inst_3 : add_comm_monoid M₂] [_inst_4 : module R M] [_inst_5 : module R M₂],	    map (fst R M M₂) (snd R M M₂) = ⊥", "decl_nm": "submodule.snd_map_fst"
{"src": "R : Type u,	M : Type v,	M₂ : Type w,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : add_comm_monoid M₂,	_inst_4 : module R M,	_inst_5 : module R M₂	⊢ map (fst R M M₂) (snd R M M₂) = ⊥", "decl_nm": "submodule.snd_map_fst"
{"src": "R : Type u,	M : Type v,	M₂ : Type w,	_inst_1 : semiring R,	_inst_2 : add_comm_monoid M,	_inst_3 : add_comm_monoid M₂,	_inst_4 : module R M,	_inst_5 : module R M₂,	x : M,	ᾰ : x = 0	⊢ M₂", "decl_nm": "submodule.snd_map_fst"
{"src": "⊢ ∀ {R : Type u_2} {M : Type u_3} [_inst_1 : add_comm_group M] [_inst_2 : ring R] [_inst_4 : module R M]	  {Q Q' : quadratic_form R M}, (∀ (x : M), ⇑Q x = ⇑Q' x) → Q = Q'", "decl_nm": "quadratic_form.ext"
{"src": "R : Type u_2,	M : Type u_3,	_inst_1 : add_comm_group M,	_inst_2 : ring R,	_inst_4 : module R M,	Q Q' : quadratic_form R M,	H : ∀ (x : M), ⇑Q x = ⇑Q' x	⊢ Q = Q'", "decl_nm": "quadratic_form.ext"
{"src": "R : Type u_2,	M : Type u_3,	_inst_1 : add_comm_group M,	_inst_2 : ring R,	_inst_4 : module R M,	Q' : quadratic_form R M,	Q_to_fun : M → R,	Q_to_fun_smul : ∀ (a : R) (x : M), Q_to_fun (a • x) = a * a * Q_to_fun x,	Q_polar_add_left' : ∀ (x x' y : M), polar Q_to_fun (x + x') y = polar Q_to_fun x y + polar Q_to_fun x' y,	Q_polar_smul_left' : ∀ (a : R) (x y : M), polar Q_to_fun (a • x) y = a • polar Q_to_fun x y,	Q_polar_add_right' : ∀ (x y y' : M), polar Q_to_fun x (y + y') = polar Q_to_fun x y + polar Q_to_fun x y',	Q_polar_smul_right' : ∀ (a : R) (x y : M), polar Q_to_fun x (a • y) = a • polar Q_to_fun x y,	H :	  ∀ (x : M),	    ⇑{to_fun := Q_to_fun,	         to_fun_smul := Q_to_fun_smul,	         polar_add_left' := Q_polar_add_left',	         polar_smul_left' := Q_polar_smul_left',	         polar_add_right' := Q_polar_add_right',	         polar_smul_right' := Q_polar_smul_right'}	        x =	      ⇑Q' x	⊢ {to_fun := Q_to_fun,	     to_fun_smul := Q_to_fun_smul,	     polar_add_left' := Q_polar_add_left',	     polar_smul_left' := Q_polar_smul_left',	     polar_add_right' := Q_polar_add_right',	     polar_smul_right' := Q_polar_smul_right'} =	    Q'", "decl_nm": "quadratic_form.ext"
{"src": "R : Type u_2,	M : Type u_3,	_inst_1 : add_comm_group M,	_inst_2 : ring R,	_inst_4 : module R M,	Q_to_fun : M → R,	Q_to_fun_smul : ∀ (a : R) (x : M), Q_to_fun (a • x) = a * a * Q_to_fun x,	Q_polar_add_left' : ∀ (x x' y : M), polar Q_to_fun (x + x') y = polar Q_to_fun x y + polar Q_to_fun x' y,	Q_polar_smul_left' : ∀ (a : R) (x y : M), polar Q_to_fun (a • x) y = a • polar Q_to_fun x y,	Q_polar_add_right' : ∀ (x y y' : M), polar Q_to_fun x (y + y') = polar Q_to_fun x y + polar Q_to_fun x y',	Q_polar_smul_right' : ∀ (a : R) (x y : M), polar Q_to_fun x (a • y) = a • polar Q_to_fun x y,	Q'_to_fun : M → R,	Q'_to_fun_smul : ∀ (a : R) (x : M), Q'_to_fun (a • x) = a * a * Q'_to_fun x,	Q'_polar_add_left' : ∀ (x x' y : M), polar Q'_to_fun (x + x') y = polar Q'_to_fun x y + polar Q'_to_fun x' y,	Q'_polar_smul_left' : ∀ (a : R) (x y : M), polar Q'_to_fun (a • x) y = a • polar Q'_to_fun x y,	Q'_polar_add_right' : ∀ (x y y' : M), polar Q'_to_fun x (y + y') = polar Q'_to_fun x y + polar Q'_to_fun x y',	Q'_polar_smul_right' : ∀ (a : R) (x y : M), polar Q'_to_fun x (a • y) = a • polar Q'_to_fun x y,	H :	  ∀ (x : M),	    ⇑{to_fun := Q_to_fun,	         to_fun_smul := Q_to_fun_smul,	         polar_add_left' := Q_polar_add_left',	         polar_smul_left' := Q_polar_smul_left',	         polar_add_right' := Q_polar_add_right',	         polar_smul_right' := Q_polar_smul_right'}	        x =	      ⇑{to_fun := Q'_to_fun,	         to_fun_smul := Q'_to_fun_smul,	         polar_add_left' := Q'_polar_add_left',	         polar_smul_left' := Q'_polar_smul_left',	         polar_add_right' := Q'_polar_add_right',	         polar_smul_right' := Q'_polar_smul_right'}	        x	⊢ {to_fun := Q_to_fun,	     to_fun_smul := Q_to_fun_smul,	     polar_add_left' := Q_polar_add_left',	     polar_smul_left' := Q_polar_smul_left',	     polar_add_right' := Q_polar_add_right',	     polar_smul_right' := Q_polar_smul_right'} =	    {to_fun := Q'_to_fun,	     to_fun_smul := Q'_to_fun_smul,	     polar_add_left' := Q'_polar_add_left',	     polar_smul_left' := Q'_polar_smul_left',	     polar_add_right' := Q'_polar_add_right',	     polar_smul_right' := Q'_polar_smul_right'}", "decl_nm": "quadratic_form.ext"
{"src": "R : Type u_2,	M : Type u_3,	_inst_1 : add_comm_group M,	_inst_2 : ring R,	_inst_4 : module R M,	Q_to_fun : M → R,	Q_to_fun_smul : ∀ (a : R) (x : M), Q_to_fun (a • x) = a * a * Q_to_fun x,	Q_polar_add_left' : ∀ (x x' y : M), polar Q_to_fun (x + x') y = polar Q_to_fun x y + polar Q_to_fun x' y,	Q_polar_smul_left' : ∀ (a : R) (x y : M), polar Q_to_fun (a • x) y = a • polar Q_to_fun x y,	Q_polar_add_right' : ∀ (x y y' : M), polar Q_to_fun x (y + y') = polar Q_to_fun x y + polar Q_to_fun x y',	Q_polar_smul_right' : ∀ (a : R) (x y : M), polar Q_to_fun x (a • y) = a • polar Q_to_fun x y,	Q'_to_fun : M → R,	Q'_to_fun_smul : ∀ (a : R) (x : M), Q'_to_fun (a • x) = a * a * Q'_to_fun x,	Q'_polar_add_left' : ∀ (x x' y : M), polar Q'_to_fun (x + x') y = polar Q'_to_fun x y + polar Q'_to_fun x' y,	Q'_polar_smul_left' : ∀ (a : R) (x y : M), polar Q'_to_fun (a • x) y = a • polar Q'_to_fun x y,	Q'_polar_add_right' : ∀ (x y y' : M), polar Q'_to_fun x (y + y') = polar Q'_to_fun x y + polar Q'_to_fun x y',	Q'_polar_smul_right' : ∀ (a : R) (x y : M), polar Q'_to_fun x (a • y) = a • polar Q'_to_fun x y,	H :	  ∀ (x : M),	    ⇑{to_fun := Q_to_fun,	         to_fun_smul := Q_to_fun_smul,	         polar_add_left' := Q_polar_add_left',	         polar_smul_left' := Q_polar_smul_left',	         polar_add_right' := Q_polar_add_right',	         polar_smul_right' := Q_polar_smul_right'}	        x =	      ⇑{to_fun := Q'_to_fun,	         to_fun_smul := Q'_to_fun_smul,	         polar_add_left' := Q'_polar_add_left',	         polar_smul_left' := Q'_polar_smul_left',	         polar_add_right' := Q'_polar_add_right',	         polar_smul_right' := Q'_polar_smul_right'}	        x	⊢ Q_to_fun = Q'_to_fun", "decl_nm": "quadratic_form.ext"
{"src": "R : Type u_2,	M : Type u_3,	_inst_1 : add_comm_group M,	_inst_2 : ring R,	_inst_4 : module R M,	Q_to_fun : M → R,	Q_to_fun_smul : ∀ (a : R) (x : M), Q_to_fun (a • x) = a * a * Q_to_fun x,	Q_polar_add_left' : ∀ (x x' y : M), polar Q_to_fun (x + x') y = polar Q_to_fun x y + polar Q_to_fun x' y,	Q_polar_smul_left' : ∀ (a : R) (x y : M), polar Q_to_fun (a • x) y = a • polar Q_to_fun x y,	Q_polar_add_right' : ∀ (x y y' : M), polar Q_to_fun x (y + y') = polar Q_to_fun x y + polar Q_to_fun x y',	Q_polar_smul_right' : ∀ (a : R) (x y : M), polar Q_to_fun x (a • y) = a • polar Q_to_fun x y,	Q'_to_fun : M → R,	Q'_to_fun_smul : ∀ (a : R) (x : M), Q'_to_fun (a • x) = a * a * Q'_to_fun x,	Q'_polar_add_left' : ∀ (x x' y : M), polar Q'_to_fun (x + x') y = polar Q'_to_fun x y + polar Q'_to_fun x' y,	Q'_polar_smul_left' : ∀ (a : R) (x y : M), polar Q'_to_fun (a • x) y = a • polar Q'_to_fun x y,	Q'_polar_add_right' : ∀ (x y y' : M), polar Q'_to_fun x (y + y') = polar Q'_to_fun x y + polar Q'_to_fun x y',	Q'_polar_smul_right' : ∀ (a : R) (x y : M), polar Q'_to_fun x (a • y) = a • polar Q'_to_fun x y,	H :	  ∀ (x : M),	    ⇑{to_fun := Q_to_fun,	         to_fun_smul := Q_to_fun_smul,	         polar_add_left' := Q_polar_add_left',	         polar_smul_left' := Q_polar_smul_left',	         polar_add_right' := Q_polar_add_right',	         polar_smul_right' := Q_polar_smul_right'}	        x =	      ⇑{to_fun := Q'_to_fun,	         to_fun_smul := Q'_to_fun_smul,	         polar_add_left' := Q'_polar_add_left',	         polar_smul_left' := Q'_polar_smul_left',	         polar_add_right' := Q'_polar_add_right',	         polar_smul_right' := Q'_polar_smul_right'}	        x,	x : M	⊢ Q_to_fun x = Q'_to_fun x", "decl_nm": "quadratic_form.ext"
{"src": "⊢ ∀ {R : Type u_1} {M : Type u_2} [_inst_1 : ring R] [_inst_2 : add_comm_group M] [_inst_3 : module R M]	  (p : submodule R M) {R₂ : Type u_3} {M₂ : Type u_4} [_inst_4 : ring R₂] [_inst_5 : add_comm_group M₂]	  [_inst_6 : module R₂ M₂] {τ₁₂ : R →+* R₂} (f : M →ₛₗ[τ₁₂] M₂) (h : p ≤ f.ker),	    f.ker ≤ p → (p.liftq f h).ker = ⊥", "decl_nm": "submodule.ker_liftq_eq_bot"
{"src": "R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	p : submodule R M,	R₂ : Type u_3,	M₂ : Type u_4,	_inst_4 : ring R₂,	_inst_5 : add_comm_group M₂,	_inst_6 : module R₂ M₂,	τ₁₂ : R →+* R₂,	f : M →ₛₗ[τ₁₂] M₂,	h : p ≤ f.ker,	h' : f.ker ≤ p	⊢ (p.liftq f h).ker = ⊥", "decl_nm": "submodule.ker_liftq_eq_bot"
{"src": "⊢ ∀ {R : Type u_1} [_inst_1 : comm_semiring R] {M : Type u_4} {N : Type u_5} {P : Type u_6} {Q : Type u_7}	  [_inst_4 : add_comm_monoid M] [_inst_5 : add_comm_monoid N] [_inst_6 : add_comm_monoid P]	  [_inst_7 : add_comm_monoid Q] [_inst_9 : module R M] [_inst_10 : module R N] [_inst_11 : module R P]	  [_inst_12 : module R Q] (f : M →ₗ[R] P) (g : N →ₗ[R] Q),	    (map f g).range = submodule.span R {t : tensor_product R P Q | ∃ (m : M) (n : N), ⇑f m ⊗ₜ[R] ⇑g n = t}", "decl_nm": "tensor_product.map_range_eq_span_tmul"
{"src": "R : Type u_1,	_inst_1 : comm_semiring R,	M : Type u_4,	N : Type u_5,	P : Type u_6,	Q : Type u_7,	_inst_4 : add_comm_monoid M,	_inst_5 : add_comm_monoid N,	_inst_6 : add_comm_monoid P,	_inst_7 : add_comm_monoid Q,	_inst_9 : module R M,	_inst_10 : module R N,	_inst_11 : module R P,	_inst_12 : module R Q,	f : M →ₗ[R] P,	g : N →ₗ[R] Q	⊢ (map f g).range = submodule.span R {t : tensor_product R P Q | ∃ (m : M) (n : N), ⇑f m ⊗ₜ[R] ⇑g n = t}", "decl_nm": "tensor_product.map_range_eq_span_tmul"
{"src": "R : Type u_1,	_inst_1 : comm_semiring R,	M : Type u_4,	N : Type u_5,	P : Type u_6,	Q : Type u_7,	_inst_4 : add_comm_monoid M,	_inst_5 : add_comm_monoid N,	_inst_6 : add_comm_monoid P,	_inst_7 : add_comm_monoid Q,	_inst_9 : module R M,	_inst_10 : module R N,	_inst_11 : module R P,	_inst_12 : module R Q,	f : M →ₗ[R] P,	g : N →ₗ[R] Q	⊢ submodule.span R (⇑(map f g) '' {t : tensor_product R M N | ∃ (m : M) (n : N), m ⊗ₜ[R] n = t}) =	    submodule.span R {t : tensor_product R P Q | ∃ (m : M) (n : N), ⇑f m ⊗ₜ[R] ⇑g n = t}", "decl_nm": "tensor_product.map_range_eq_span_tmul"
{"src": "R : Type u_1,	_inst_1 : comm_semiring R,	M : Type u_4,	N : Type u_5,	P : Type u_6,	Q : Type u_7,	_inst_4 : add_comm_monoid M,	_inst_5 : add_comm_monoid N,	_inst_6 : add_comm_monoid P,	_inst_7 : add_comm_monoid Q,	_inst_9 : module R M,	_inst_10 : module R N,	_inst_11 : module R P,	_inst_12 : module R Q,	f : M →ₗ[R] P,	g : N →ₗ[R] Q	⊢ ⇑(map f g) '' {t : tensor_product R M N | ∃ (m : M) (n : N), m ⊗ₜ[R] n = t} =	    {t : tensor_product R P Q | ∃ (m : M) (n : N), ⇑f m ⊗ₜ[R] ⇑g n = t}", "decl_nm": "tensor_product.map_range_eq_span_tmul"
{"src": "R : Type u_1,	_inst_1 : comm_semiring R,	M : Type u_4,	N : Type u_5,	P : Type u_6,	Q : Type u_7,	_inst_4 : add_comm_monoid M,	_inst_5 : add_comm_monoid N,	_inst_6 : add_comm_monoid P,	_inst_7 : add_comm_monoid Q,	_inst_9 : module R M,	_inst_10 : module R N,	_inst_11 : module R P,	_inst_12 : module R Q,	f : M →ₗ[R] P,	g : N →ₗ[R] Q,	t : tensor_product R P Q	⊢ t ∈ ⇑(map f g) '' {t : tensor_product R M N | ∃ (m : M) (n : N), m ⊗ₜ[R] n = t} ↔	    t ∈ {t : tensor_product R P Q | ∃ (m : M) (n : N), ⇑f m ⊗ₜ[R] ⇑g n = t}", "decl_nm": "tensor_product.map_range_eq_span_tmul"
{"src": "2 goals	R : Type u_1,	_inst_1 : comm_semiring R,	M : Type u_4,	N : Type u_5,	P : Type u_6,	Q : Type u_7,	_inst_4 : add_comm_monoid M,	_inst_5 : add_comm_monoid N,	_inst_6 : add_comm_monoid P,	_inst_7 : add_comm_monoid Q,	_inst_9 : module R M,	_inst_10 : module R N,	_inst_11 : module R P,	_inst_12 : module R Q,	f : M →ₗ[R] P,	g : N →ₗ[R] Q,	t : tensor_product R P Q	⊢ t ∈ ⇑(map f g) '' {t : tensor_product R M N | ∃ (m : M) (n : N), m ⊗ₜ[R] n = t} →	  t ∈ {t : tensor_product R P Q | ∃ (m : M) (n : N), ⇑f m ⊗ₜ[R] ⇑g n = t}		R : Type u_1,	_inst_1 : comm_semiring R,	M : Type u_4,	N : Type u_5,	P : Type u_6,	Q : Type u_7,	_inst_4 : add_comm_monoid M,	_inst_5 : add_comm_monoid N,	_inst_6 : add_comm_monoid P,	_inst_7 : add_comm_monoid Q,	_inst_9 : module R M,	_inst_10 : module R N,	_inst_11 : module R P,	_inst_12 : module R Q,	f : M →ₗ[R] P,	g : N →ₗ[R] Q,	t : tensor_product R P Q	⊢ t ∈ {t : tensor_product R P Q | ∃ (m : M) (n : N), ⇑f m ⊗ₜ[R] ⇑g n = t} →	  t ∈ ⇑(map f g) '' {t : tensor_product R M N | ∃ (m : M) (n : N), m ⊗ₜ[R] n = t}", "decl_nm": "tensor_product.map_range_eq_span_tmul"
{"src": "2 goals	R : Type u_1,	_inst_1 : comm_semiring R,	M : Type u_4,	N : Type u_5,	P : Type u_6,	Q : Type u_7,	_inst_4 : add_comm_monoid M,	_inst_5 : add_comm_monoid N,	_inst_6 : add_comm_monoid P,	_inst_7 : add_comm_monoid Q,	_inst_9 : module R M,	_inst_10 : module R N,	_inst_11 : module R P,	_inst_12 : module R Q,	f : M →ₗ[R] P,	g : N →ₗ[R] Q,	m : M,	n : N	⊢ ⇑(map f g) (m ⊗ₜ[R] n) ∈ {t : tensor_product R P Q | ∃ (m : M) (n : N), ⇑f m ⊗ₜ[R] ⇑g n = t}		R : Type u_1,	_inst_1 : comm_semiring R,	M : Type u_4,	N : Type u_5,	P : Type u_6,	Q : Type u_7,	_inst_4 : add_comm_monoid M,	_inst_5 : add_comm_monoid N,	_inst_6 : add_comm_monoid P,	_inst_7 : add_comm_monoid Q,	_inst_9 : module R M,	_inst_10 : module R N,	_inst_11 : module R P,	_inst_12 : module R Q,	f : M →ₗ[R] P,	g : N →ₗ[R] Q,	t : tensor_product R P Q	⊢ t ∈ {t : tensor_product R P Q | ∃ (m : M) (n : N), ⇑f m ⊗ₜ[R] ⇑g n = t} →	  t ∈ ⇑(map f g) '' {t : tensor_product R M N | ∃ (m : M) (n : N), m ⊗ₜ[R] n = t}", "decl_nm": "tensor_product.map_range_eq_span_tmul"
{"src": "2 goals	R : Type u_1,	_inst_1 : comm_semiring R,	M : Type u_4,	N : Type u_5,	P : Type u_6,	Q : Type u_7,	_inst_4 : add_comm_monoid M,	_inst_5 : add_comm_monoid N,	_inst_6 : add_comm_monoid P,	_inst_7 : add_comm_monoid Q,	_inst_9 : module R M,	_inst_10 : module R N,	_inst_11 : module R P,	_inst_12 : module R Q,	f : M →ₗ[R] P,	g : N →ₗ[R] Q,	m : M,	n : N	⊢ ⇑f m ⊗ₜ[R] ⇑g n = ⇑(map f g) (m ⊗ₜ[R] n)		R : Type u_1,	_inst_1 : comm_semiring R,	M : Type u_4,	N : Type u_5,	P : Type u_6,	Q : Type u_7,	_inst_4 : add_comm_monoid M,	_inst_5 : add_comm_monoid N,	_inst_6 : add_comm_monoid P,	_inst_7 : add_comm_monoid Q,	_inst_9 : module R M,	_inst_10 : module R N,	_inst_11 : module R P,	_inst_12 : module R Q,	f : M →ₗ[R] P,	g : N →ₗ[R] Q,	t : tensor_product R P Q	⊢ t ∈ {t : tensor_product R P Q | ∃ (m : M) (n : N), ⇑f m ⊗ₜ[R] ⇑g n = t} →	  t ∈ ⇑(map f g) '' {t : tensor_product R M N | ∃ (m : M) (n : N), m ⊗ₜ[R] n = t}", "decl_nm": "tensor_product.map_range_eq_span_tmul"
{"src": "R : Type u_1,	_inst_1 : comm_semiring R,	M : Type u_4,	N : Type u_5,	P : Type u_6,	Q : Type u_7,	_inst_4 : add_comm_monoid M,	_inst_5 : add_comm_monoid N,	_inst_6 : add_comm_monoid P,	_inst_7 : add_comm_monoid Q,	_inst_9 : module R M,	_inst_10 : module R N,	_inst_11 : module R P,	_inst_12 : module R Q,	f : M →ₗ[R] P,	g : N →ₗ[R] Q,	t : tensor_product R P Q	⊢ t ∈ {t : tensor_product R P Q | ∃ (m : M) (n : N), ⇑f m ⊗ₜ[R] ⇑g n = t} →	  t ∈ ⇑(map f g) '' {t : tensor_product R M N | ∃ (m : M) (n : N), m ⊗ₜ[R] n = t}", "decl_nm": "tensor_product.map_range_eq_span_tmul"
{"src": "R : Type u_1,	_inst_1 : comm_semiring R,	M : Type u_4,	N : Type u_5,	P : Type u_6,	Q : Type u_7,	_inst_4 : add_comm_monoid M,	_inst_5 : add_comm_monoid N,	_inst_6 : add_comm_monoid P,	_inst_7 : add_comm_monoid Q,	_inst_9 : module R M,	_inst_10 : module R N,	_inst_11 : module R P,	_inst_12 : module R Q,	f : M →ₗ[R] P,	g : N →ₗ[R] Q,	m : M,	n : N	⊢ ⇑f m ⊗ₜ[R] ⇑g n ∈ ⇑(map f g) '' {t : tensor_product R M N | ∃ (m : M) (n : N), m ⊗ₜ[R] n = t}", "decl_nm": "tensor_product.map_range_eq_span_tmul"
{"src": "R : Type u_1,	_inst_1 : comm_semiring R,	M : Type u_4,	N : Type u_5,	P : Type u_6,	Q : Type u_7,	_inst_4 : add_comm_monoid M,	_inst_5 : add_comm_monoid N,	_inst_6 : add_comm_monoid P,	_inst_7 : add_comm_monoid Q,	_inst_9 : module R M,	_inst_10 : module R N,	_inst_11 : module R P,	_inst_12 : module R Q,	f : M →ₗ[R] P,	g : N →ₗ[R] Q,	m : M,	n : N	⊢ ⇑(map f g) (m ⊗ₜ[R] n) = ⇑f m ⊗ₜ[R] ⇑g n", "decl_nm": "tensor_product.map_range_eq_span_tmul"
{"src": "⊢ ∀ {α : Sort u_1} {p : α → Prop} {a' : α}, (∃ (a : α), p a ∧ a' = a) ↔ p a'", "decl_nm": "exists_eq_right'"
{"src": "α : Sort u_1,	p : α → Prop,	a' : α	⊢ (∃ (a : α), p a ∧ a' = a) ↔ p a'", "decl_nm": "exists_eq_right'"
{"src": "⊢ ∀ {α : Type u_1} {β : Type u_2} [_inst_1 : nontrivial β] {f : α → β},	    function.surjective f → nontrivial α", "decl_nm": "function.surjective.nontrivial"
{"src": "α : Type u_1,	β : Type u_2,	_inst_1 : nontrivial β,	f : α → β,	hf : function.surjective f	⊢ nontrivial α", "decl_nm": "function.surjective.nontrivial"
{"src": "α : Type u_1,	β : Type u_2,	_inst_1 : nontrivial β,	f : α → β,	hf : function.surjective f,	x y : β,	h : x ≠ y	⊢ nontrivial α", "decl_nm": "function.surjective.nontrivial"
{"src": "α : Type u_1,	β : Type u_2,	_inst_1 : nontrivial β,	f : α → β,	hf : function.surjective f,	x y : β,	h : x ≠ y,	x' : α,	hx' : f x' = x	⊢ nontrivial α", "decl_nm": "function.surjective.nontrivial"
{"src": "α : Type u_1,	β : Type u_2,	_inst_1 : nontrivial β,	f : α → β,	hf : function.surjective f,	x y : β,	h : x ≠ y,	x' : α,	hx' : f x' = x,	y' : α,	hy' : f y' = y	⊢ nontrivial α", "decl_nm": "function.surjective.nontrivial"
{"src": "2 goals	α : Type u_1,	β : Type u_2,	_inst_1 : nontrivial β,	f : α → β,	hf : function.surjective f,	x y : β,	h : x ≠ y,	x' : α,	hx' : f x' = x,	y' : α,	hy' : f y' = y	⊢ x' ≠ y'		α : Type u_1,	β : Type u_2,	_inst_1 : nontrivial β,	f : α → β,	hf : function.surjective f,	x y : β,	h : x ≠ y,	x' : α,	hx' : f x' = x,	y' : α,	hy' : f y' = y,	this : x' ≠ y'	⊢ nontrivial α", "decl_nm": "function.surjective.nontrivial"
{"src": "2 goals	α : Type u_1,	β : Type u_2,	_inst_1 : nontrivial β,	f : α → β,	hf : function.surjective f,	x y : β,	x' : α,	hx' : f x' = x,	y' : α,	hy' : f y' = y,	h : x' = y'	⊢ x = y		α : Type u_1,	β : Type u_2,	_inst_1 : nontrivial β,	f : α → β,	hf : function.surjective f,	x y : β,	h : x ≠ y,	x' : α,	hx' : f x' = x,	y' : α,	hy' : f y' = y,	this : x' ≠ y'	⊢ nontrivial α", "decl_nm": "function.surjective.nontrivial"
{"src": "α : Type u_1,	β : Type u_2,	_inst_1 : nontrivial β,	f : α → β,	hf : function.surjective f,	x y : β,	h : x ≠ y,	x' : α,	hx' : f x' = x,	y' : α,	hy' : f y' = y,	this : x' ≠ y'	⊢ nontrivial α", "decl_nm": "function.surjective.nontrivial"
{"src": "⊢ ∀ {α : Type u_1} [_inst_1 : nontrivial α] (x : α), ∃ (y : α), y ≠ x", "decl_nm": "exists_ne"
{"src": "α : Type u_1,	_inst_1 : nontrivial α,	x : α	⊢ ∃ (y : α), y ≠ x", "decl_nm": "exists_ne"
{"src": "α : Type u_1,	_inst_1 : nontrivial α,	x : α,	_inst : Π (a : Prop), decidable a	⊢ ∃ (y : α), y ≠ x", "decl_nm": "exists_ne"
{"src": "⊢ ∀ {α : Type u_1} {r : α → α → Prop} {a b c : α}, refl_trans_gen r a b → r b c → trans_gen r a c", "decl_nm": "relation.trans_gen.tail'"
{"src": "α : Type u_1,	r : α → α → Prop,	a b c : α,	hab : refl_trans_gen r a b,	hbc : r b c	⊢ trans_gen r a c", "decl_nm": "relation.trans_gen.tail'"
{"src": "2 goals	case relation.refl_trans_gen.refl	α : Type u_1,	r : α → α → Prop,	a b c : α,	hbc : r a c	⊢ trans_gen r a c		case relation.refl_trans_gen.tail	α : Type u_1,	r : α → α → Prop,	a b hab_b hab_c : α,	hab_ᾰ : refl_trans_gen r a hab_b,	hab_ᾰ_1 : r hab_b hab_c,	hab_ih : ∀ {c : α}, r hab_b c → trans_gen r a c,	c : α,	hbc : r hab_c c	⊢ trans_gen r a c", "decl_nm": "relation.trans_gen.tail'"
{"src": "case relation.refl_trans_gen.tail	α : Type u_1,	r : α → α → Prop,	a b hab_b hab_c : α,	hab_ᾰ : refl_trans_gen r a hab_b,	hab_ᾰ_1 : r hab_b hab_c,	hab_ih : ∀ {c : α}, r hab_b c → trans_gen r a c,	c : α,	hbc : r hab_c c	⊢ trans_gen r a c", "decl_nm": "relation.trans_gen.tail'"
{"src": "⊢ ∀ {α : Type u_1} {β : Type u_2} {ι : Type u_4} [_inst_1 : measurable_space α] [_inst_2 : measurable_space β]	  {f : ι → α → β} {μ : measure α} {p : α → (ι → β) → Prop} [_inst_3 : encodable ι]	  (hf : ∀ (i : ι), ae_measurable (f i) μ),	    (∀ᵐ (x : α) ∂μ, p x (λ (n : ι), f n x)) → ⇑μ (ae_seq_set hf p)ᶜ = 0", "decl_nm": "ae_seq.measure_compl_ae_seq_set_eq_zero"
{"src": "α : Type u_1,	β : Type u_2,	ι : Type u_4,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	f : ι → α → β,	μ : measure α,	p : α → (ι → β) → Prop,	_inst_3 : encodable ι,	hf : ∀ (i : ι), ae_measurable (f i) μ,	hp : ∀ᵐ (x : α) ∂μ, p x (λ (n : ι), f n x)	⊢ ⇑μ (ae_seq_set hf p)ᶜ = 0", "decl_nm": "ae_seq.measure_compl_ae_seq_set_eq_zero"
{"src": "α : Type u_1,	β : Type u_2,	ι : Type u_4,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	f : ι → α → β,	μ : measure α,	p : α → (ι → β) → Prop,	_inst_3 : encodable ι,	hf : ∀ (i : ι), ae_measurable (f i) μ,	hp : ∀ᵐ (x : α) ∂μ, p x (λ (n : ι), f n x)	⊢ ⇑μ {x : α | (∀ (i : ι), f i x = ae_measurable.mk (f i) _ x) ∧ p x (λ (n : ι), f n x)}ᶜ = 0", "decl_nm": "ae_seq.measure_compl_ae_seq_set_eq_zero"
{"src": "α : Type u_1,	β : Type u_2,	ι : Type u_4,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	f : ι → α → β,	μ : measure α,	p : α → (ι → β) → Prop,	_inst_3 : encodable ι,	hf : ∀ (i : ι), ae_measurable (f i) μ,	hp : ∀ᵐ (x : α) ∂μ, p x (λ (n : ι), f n x),	hf_eq : ∀ (i : ι), f i =ᵐ[μ] ae_measurable.mk (f i) _	⊢ ⇑μ {x : α | (∀ (i : ι), f i x = ae_measurable.mk (f i) _ x) ∧ p x (λ (n : ι), f n x)}ᶜ = 0", "decl_nm": "ae_seq.measure_compl_ae_seq_set_eq_zero"
{"src": "α : Type u_1,	β : Type u_2,	ι : Type u_4,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	f : ι → α → β,	μ : measure α,	p : α → (ι → β) → Prop,	_inst_3 : encodable ι,	hf : ∀ (i : ι), ae_measurable (f i) μ,	hp : ∀ᵐ (x : α) ∂μ, p x (λ (n : ι), f n x),	hf_eq : ∀ᵐ (a : α) ∂μ, ∀ (i : ι), f i a = ae_measurable.mk (f i) _ a	⊢ ⇑μ {x : α | (∀ (i : ι), f i x = ae_measurable.mk (f i) _ x) ∧ p x (λ (n : ι), f n x)}ᶜ = 0", "decl_nm": "ae_seq.measure_compl_ae_seq_set_eq_zero"
{"src": "⊢ ∀ {α : Type u_1} {β : Type u_2} {ι : Type u_4} [_inst_1 : measurable_space α] [_inst_2 : measurable_space β]	  {f : ι → α → β} {μ : measure α} {p : α → (ι → β) → Prop} (hf : ∀ (i : ι), ae_measurable (f i) μ)	  {x : α}, x ∈ ae_seq_set hf p → p x (λ (n : ι), ae_seq hf p n x)", "decl_nm": "ae_seq.prop_of_mem_ae_seq_set"
{"src": "α : Type u_1,	β : Type u_2,	ι : Type u_4,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	f : ι → α → β,	μ : measure α,	p : α → (ι → β) → Prop,	hf : ∀ (i : ι), ae_measurable (f i) μ,	x : α,	hx : x ∈ ae_seq_set hf p	⊢ p x (λ (n : ι), ae_seq hf p n x)", "decl_nm": "ae_seq.prop_of_mem_ae_seq_set"
{"src": "α : Type u_1,	β : Type u_2,	ι : Type u_4,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	f : ι → α → β,	μ : measure α,	p : α → (ι → β) → Prop,	hf : ∀ (i : ι), ae_measurable (f i) μ,	x : α,	hx : x ∈ ae_seq_set hf p	⊢ p x (λ (n : ι), ae_measurable.mk (f n) _ x)", "decl_nm": "ae_seq.prop_of_mem_ae_seq_set"
{"src": "α : Type u_1,	β : Type u_2,	ι : Type u_4,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	f : ι → α → β,	μ : measure α,	p : α → (ι → β) → Prop,	hf : ∀ (i : ι), ae_measurable (f i) μ,	x : α,	hx : x ∈ ae_seq_set hf p	⊢ p x (λ (n : ι), f n x)", "decl_nm": "ae_seq.prop_of_mem_ae_seq_set"
{"src": "2 goals	α : Type u_1,	β : Type u_2,	ι : Type u_4,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	f : ι → α → β,	μ : measure α,	p : α → (ι → β) → Prop,	hf : ∀ (i : ι), ae_measurable (f i) μ,	x : α,	hx : x ∈ ae_seq_set hf p	⊢ ae_seq_set hf p ⊆ {x : α | p x (λ (n : ι), f n x)}		α : Type u_1,	β : Type u_2,	ι : Type u_4,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	f : ι → α → β,	μ : measure α,	p : α → (ι → β) → Prop,	hf : ∀ (i : ι), ae_measurable (f i) μ,	x : α,	hx : x ∈ ae_seq_set hf p,	h_ss : ae_seq_set hf p ⊆ {x : α | p x (λ (n : ι), f n x)}	⊢ p x (λ (n : ι), f n x)", "decl_nm": "ae_seq.prop_of_mem_ae_seq_set"
{"src": "2 goals	α : Type u_1,	β : Type u_2,	ι : Type u_4,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	f : ι → α → β,	μ : measure α,	p : α → (ι → β) → Prop,	hf : ∀ (i : ι), ae_measurable (f i) μ,	x : α,	hx : x ∈ ae_seq_set hf p	⊢ {x : α | p x (λ (n : ι), f n x)}ᶜ ⊆	    to_measurable μ {x : α | (∀ (i : ι), f i x = ae_measurable.mk (f i) _ x) ∧ p x (λ (n : ι), f n x)}ᶜ		α : Type u_1,	β : Type u_2,	ι : Type u_4,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	f : ι → α → β,	μ : measure α,	p : α → (ι → β) → Prop,	hf : ∀ (i : ι), ae_measurable (f i) μ,	x : α,	hx : x ∈ ae_seq_set hf p,	h_ss : ae_seq_set hf p ⊆ {x : α | p x (λ (n : ι), f n x)}	⊢ p x (λ (n : ι), f n x)", "decl_nm": "ae_seq.prop_of_mem_ae_seq_set"
{"src": "2 goals	α : Type u_1,	β : Type u_2,	ι : Type u_4,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	f : ι → α → β,	μ : measure α,	p : α → (ι → β) → Prop,	hf : ∀ (i : ι), ae_measurable (f i) μ,	x : α,	hx : x ∈ ae_seq_set hf p	⊢ {x : α | (∀ (i : ι), f i x = ae_measurable.mk (f i) _ x) ∧ p x (λ (n : ι), f n x)} ⊆	    {x : α | p x (λ (n : ι), f n x)}		α : Type u_1,	β : Type u_2,	ι : Type u_4,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	f : ι → α → β,	μ : measure α,	p : α → (ι → β) → Prop,	hf : ∀ (i : ι), ae_measurable (f i) μ,	x : α,	hx : x ∈ ae_seq_set hf p,	h_ss : ae_seq_set hf p ⊆ {x : α | p x (λ (n : ι), f n x)}	⊢ p x (λ (n : ι), f n x)", "decl_nm": "ae_seq.prop_of_mem_ae_seq_set"
{"src": "α : Type u_1,	β : Type u_2,	ι : Type u_4,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	f : ι → α → β,	μ : measure α,	p : α → (ι → β) → Prop,	hf : ∀ (i : ι), ae_measurable (f i) μ,	x : α,	hx : x ∈ ae_seq_set hf p,	h_ss : ae_seq_set hf p ⊆ {x : α | p x (λ (n : ι), f n x)}	⊢ p x (λ (n : ι), f n x)", "decl_nm": "ae_seq.prop_of_mem_ae_seq_set"
{"src": "α : Type u_1,	β : Type u_2,	ι : Type u_4,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	f : ι → α → β,	μ : measure α,	p : α → (ι → β) → Prop,	hf : ∀ (i : ι), ae_measurable (f i) μ,	x : α,	hx : x ∈ ae_seq_set hf p,	h_ss : ae_seq_set hf p ⊆ {x : α | p x (λ (n : ι), f n x)},	hx' : x ∈ {x : α | p x (λ (n : ι), f n x)}	⊢ p x (λ (n : ι), f n x)", "decl_nm": "ae_seq.prop_of_mem_ae_seq_set"
{"src": "⊢ ∀ {α : Type u_1} {β : Type u_2} {m m0 m0' : measurable_space α} [_inst_1 : measurable_space β]	  (hm0 : m0 ≤ m0') {μ : measure α} {f : α → β}, ae_measurable' m f (μ.trim hm0) → ae_measurable' m f μ", "decl_nm": "measure_theory.ae_measurable'_of_ae_measurable'_trim"
{"src": "α : Type u_1,	β : Type u_2,	m m0 m0' : measurable_space α,	_inst_1 : measurable_space β,	hm0 : m0 ≤ m0',	μ : measure α,	f : α → β,	hf : ae_measurable' m f (μ.trim hm0)	⊢ ae_measurable' m f μ", "decl_nm": "measure_theory.ae_measurable'_of_ae_measurable'_trim"
{"src": "α : Type u_1,	β : Type u_2,	m m0 m0' : measurable_space α,	_inst_1 : measurable_space β,	hm0 : m0 ≤ m0',	μ : measure α,	f g : α → β,	hg_meas : measurable g,	hfg : f =ᵐ[μ.trim hm0] g	⊢ ae_measurable' m f μ", "decl_nm": "measure_theory.ae_measurable'_of_ae_measurable'_trim"
{"src": "⊢ ∀ {α : Type u_1} {β : Type u_2} {m m0 : measurable_space α} {μ : measure α} [_inst_1 : measurable_space β]	  {f g : α → β}, ae_measurable' m f μ → f =ᵐ[μ] g → ae_measurable' m g μ", "decl_nm": "measure_theory.ae_measurable'.congr"
{"src": "α : Type u_1,	β : Type u_2,	m m0 : measurable_space α,	μ : measure α,	_inst_1 : measurable_space β,	f g : α → β,	hf : ae_measurable' m f μ,	hfg : f =ᵐ[μ] g	⊢ ae_measurable' m g μ", "decl_nm": "measure_theory.ae_measurable'.congr"
{"src": "α : Type u_1,	β : Type u_2,	m m0 : measurable_space α,	μ : measure α,	_inst_1 : measurable_space β,	f g : α → β,	hfg : f =ᵐ[μ] g,	f' : α → β,	hf'_meas : measurable f',	hff' : f =ᵐ[μ] f'	⊢ ae_measurable' m g μ", "decl_nm": "measure_theory.ae_measurable'.congr"
{"src": "⊢ ∀ {α : Type u_1} {β : Type u_2} {m : measurable_space α} {μ : measure α} [_inst_1 : normed_group β]	  [_inst_3 : measurable_space β] {f : α → β}, mem_ℒp f 1 μ ↔ integrable f μ", "decl_nm": "measure_theory.mem_ℒp_one_iff_integrable"
{"src": "α : Type u_1,	β : Type u_2,	m : measurable_space α,	μ : measure α,	_inst_1 : normed_group β,	_inst_3 : measurable_space β,	f : α → β	⊢ mem_ℒp f 1 μ ↔ integrable f μ", "decl_nm": "measure_theory.mem_ℒp_one_iff_integrable"
{"src": "⊢ ∀ {α : Type u_1} {β : Type u_2} {m : measurable_space α} {μ : measure α} [_inst_1 : normed_group β]	  [_inst_3 : measurable_space β] [_inst_6 : second_countable_topology β] [_inst_7 : borel_space β]	  (f : ↥(Lp β 1 μ)), ennreal.of_real ∥f∥ = ∫⁻ (x : α), ↑∥⇑f x∥₊ ∂μ", "decl_nm": "measure_theory.L1.of_real_norm_eq_lintegral"
{"src": "α : Type u_1,	β : Type u_2,	m : measurable_space α,	μ : measure α,	_inst_1 : normed_group β,	_inst_3 : measurable_space β,	_inst_6 : second_countable_topology β,	_inst_7 : borel_space β,	f : ↥(Lp β 1 μ)	⊢ ennreal.of_real ∥f∥ = ∫⁻ (x : α), ↑∥⇑f x∥₊ ∂μ", "decl_nm": "measure_theory.L1.of_real_norm_eq_lintegral"
{"src": "α : Type u_1,	β : Type u_2,	m : measurable_space α,	μ : measure α,	_inst_1 : normed_group β,	_inst_3 : measurable_space β,	_inst_6 : second_countable_topology β,	_inst_7 : borel_space β,	f : ↥(Lp β 1 μ)	⊢ ∫⁻ (a : α), ↑∥⇑f a∥₊ ∂μ ≠ ⊤", "decl_nm": "measure_theory.L1.of_real_norm_eq_lintegral"
{"src": "⊢ ∀ {α : Type u_1} {E : Type u_2} {m0 : measurable_space α} {p : ennreal} {μ : measure α}	  [_inst_1 : measurable_space E] [_inst_2 : normed_group E] [_inst_5 : borel_space E]	  [_inst_6 : second_countable_topology E], ∥0∥ = 0", "decl_nm": "measure_theory.Lp.norm_zero"
{"src": "α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ennreal,	μ : measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : second_countable_topology E	⊢ ∥0∥ = 0", "decl_nm": "measure_theory.Lp.norm_zero"
{"src": "α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ennreal,	μ : measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : second_countable_topology E	⊢ (snorm ⇑0 p μ).to_real = 0", "decl_nm": "measure_theory.Lp.norm_zero"
{"src": "⊢ ∀ {α : Type u_1} {E : Type u_2} {m0 : measurable_space α} {p : ennreal} {μ : measure α}	  [_inst_1 : measurable_space E] [_inst_2 : normed_group E] [_inst_5 : borel_space E]	  [_inst_6 : second_countable_topology E],	    1 ≤ p →	    ∀ {f : ℕ → α → E},	      (∀ (n : ℕ), mem_ℒp (f n) p μ) →	      ∀ (f_lim : α → E),	        ae_measurable f_lim μ →	        tendsto (λ (n : ℕ), snorm (f n - f_lim) p μ) at_top (nhds 0) → mem_ℒp f_lim p μ", "decl_nm": "measure_theory.Lp.mem_ℒp_of_cauchy_tendsto"
{"src": "α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ennreal,	μ : measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : second_countable_topology E,	hp : 1 ≤ p,	f : ℕ → α → E,	hf : ∀ (n : ℕ), mem_ℒp (f n) p μ,	f_lim : α → E,	h_lim_meas : ae_measurable f_lim μ,	h_tendsto : tendsto (λ (n : ℕ), snorm (f n - f_lim) p μ) at_top (nhds 0)	⊢ mem_ℒp f_lim p μ", "decl_nm": "measure_theory.Lp.mem_ℒp_of_cauchy_tendsto"
{"src": "α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ennreal,	μ : measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : second_countable_topology E,	hp : 1 ≤ p,	f : ℕ → α → E,	hf : ∀ (n : ℕ), mem_ℒp (f n) p μ,	f_lim : α → E,	h_lim_meas : ae_measurable f_lim μ,	h_tendsto : tendsto (λ (n : ℕ), snorm (f n - f_lim) p μ) at_top (nhds 0)	⊢ snorm f_lim p μ < ⊤", "decl_nm": "measure_theory.Lp.mem_ℒp_of_cauchy_tendsto"
{"src": "α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ennreal,	μ : measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : second_countable_topology E,	hp : 1 ≤ p,	f : ℕ → α → E,	hf : ∀ (n : ℕ), mem_ℒp (f n) p μ,	f_lim : α → E,	h_lim_meas : ae_measurable f_lim μ,	h_tendsto : ∀ (ε : ennreal), ε > 0 → (∃ (N : ℕ), ∀ (n : ℕ), n ≥ N → snorm (f n - f_lim) p μ ≤ ε)	⊢ snorm f_lim p μ < ⊤", "decl_nm": "measure_theory.Lp.mem_ℒp_of_cauchy_tendsto"
{"src": "α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ennreal,	μ : measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : second_countable_topology E,	hp : 1 ≤ p,	f : ℕ → α → E,	hf : ∀ (n : ℕ), mem_ℒp (f n) p μ,	f_lim : α → E,	h_lim_meas : ae_measurable f_lim μ,	h_tendsto : ∀ (ε : ennreal), ε > 0 → (∃ (N : ℕ), ∀ (n : ℕ), n ≥ N → snorm (f n - f_lim) p μ ≤ ε),	N : ℕ,	h_tendsto_1 : ∀ (n : ℕ), n ≥ N → snorm (f n - f_lim) p μ ≤ 1	⊢ snorm f_lim p μ < ⊤", "decl_nm": "measure_theory.Lp.mem_ℒp_of_cauchy_tendsto"
{"src": "α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ennreal,	μ : measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : second_countable_topology E,	hp : 1 ≤ p,	f : ℕ → α → E,	hf : ∀ (n : ℕ), mem_ℒp (f n) p μ,	f_lim : α → E,	h_lim_meas : ae_measurable f_lim μ,	h_tendsto : ∀ (ε : ennreal), ε > 0 → (∃ (N : ℕ), ∀ (n : ℕ), n ≥ N → snorm (f n - f_lim) p μ ≤ ε),	N : ℕ,	h_tendsto_1 : snorm (f N - f_lim) p μ ≤ 1	⊢ snorm f_lim p μ < ⊤", "decl_nm": "measure_theory.Lp.mem_ℒp_of_cauchy_tendsto"
{"src": "2 goals	α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ennreal,	μ : measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : second_countable_topology E,	hp : 1 ≤ p,	f : ℕ → α → E,	hf : ∀ (n : ℕ), mem_ℒp (f n) p μ,	f_lim : α → E,	h_lim_meas : ae_measurable f_lim μ,	h_tendsto : ∀ (ε : ennreal), ε > 0 → (∃ (N : ℕ), ∀ (n : ℕ), n ≥ N → snorm (f n - f_lim) p μ ≤ ε),	N : ℕ,	h_tendsto_1 : snorm (f N - f_lim) p μ ≤ 1	⊢ f_lim = f_lim - f N + f N		α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ennreal,	μ : measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : second_countable_topology E,	hp : 1 ≤ p,	f : ℕ → α → E,	hf : ∀ (n : ℕ), mem_ℒp (f n) p μ,	f_lim : α → E,	h_lim_meas : ae_measurable f_lim μ,	h_tendsto : ∀ (ε : ennreal), ε > 0 → (∃ (N : ℕ), ∀ (n : ℕ), n ≥ N → snorm (f n - f_lim) p μ ≤ ε),	N : ℕ,	h_tendsto_1 : snorm (f N - f_lim) p μ ≤ 1,	h_add : f_lim = f_lim - f N + f N	⊢ snorm f_lim p μ < ⊤", "decl_nm": "measure_theory.Lp.mem_ℒp_of_cauchy_tendsto"
{"src": "α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ennreal,	μ : measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : second_countable_topology E,	hp : 1 ≤ p,	f : ℕ → α → E,	hf : ∀ (n : ℕ), mem_ℒp (f n) p μ,	f_lim : α → E,	h_lim_meas : ae_measurable f_lim μ,	h_tendsto : ∀ (ε : ennreal), ε > 0 → (∃ (N : ℕ), ∀ (n : ℕ), n ≥ N → snorm (f n - f_lim) p μ ≤ ε),	N : ℕ,	h_tendsto_1 : snorm (f N - f_lim) p μ ≤ 1,	h_add : f_lim = f_lim - f N + f N	⊢ snorm f_lim p μ < ⊤", "decl_nm": "measure_theory.Lp.mem_ℒp_of_cauchy_tendsto"
{"src": "α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ennreal,	μ : measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : second_countable_topology E,	hp : 1 ≤ p,	f : ℕ → α → E,	hf : ∀ (n : ℕ), mem_ℒp (f n) p μ,	f_lim : α → E,	h_lim_meas : ae_measurable f_lim μ,	h_tendsto : ∀ (ε : ennreal), ε > 0 → (∃ (N : ℕ), ∀ (n : ℕ), n ≥ N → snorm (f n - f_lim) p μ ≤ ε),	N : ℕ,	h_tendsto_1 : snorm (f N - f_lim) p μ ≤ 1,	h_add : f_lim = f_lim - f N + f N	⊢ snorm (f_lim - f N + f N) p μ < ⊤", "decl_nm": "measure_theory.Lp.mem_ℒp_of_cauchy_tendsto"
{"src": "α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ennreal,	μ : measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : second_countable_topology E,	hp : 1 ≤ p,	f : ℕ → α → E,	hf : ∀ (n : ℕ), mem_ℒp (f n) p μ,	f_lim : α → E,	h_lim_meas : ae_measurable f_lim μ,	h_tendsto : ∀ (ε : ennreal), ε > 0 → (∃ (N : ℕ), ∀ (n : ℕ), n ≥ N → snorm (f n - f_lim) p μ ≤ ε),	N : ℕ,	h_tendsto_1 : snorm (f N - f_lim) p μ ≤ 1,	h_add : f_lim = f_lim - f N + f N	⊢ snorm (f_lim - f N) p μ + snorm (f N) p μ < ⊤", "decl_nm": "measure_theory.Lp.mem_ℒp_of_cauchy_tendsto"
{"src": "α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ennreal,	μ : measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : second_countable_topology E,	hp : 1 ≤ p,	f : ℕ → α → E,	hf : ∀ (n : ℕ), mem_ℒp (f n) p μ,	f_lim : α → E,	h_lim_meas : ae_measurable f_lim μ,	h_tendsto : ∀ (ε : ennreal), ε > 0 → (∃ (N : ℕ), ∀ (n : ℕ), n ≥ N → snorm (f n - f_lim) p μ ≤ ε),	N : ℕ,	h_tendsto_1 : snorm (f N - f_lim) p μ ≤ 1,	h_add : f_lim = f_lim - f N + f N	⊢ snorm (f_lim - f N) p μ < ⊤ ∧ snorm (f N) p μ < ⊤", "decl_nm": "measure_theory.Lp.mem_ℒp_of_cauchy_tendsto"
{"src": "2 goals	α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ennreal,	μ : measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : second_countable_topology E,	hp : 1 ≤ p,	f : ℕ → α → E,	hf : ∀ (n : ℕ), mem_ℒp (f n) p μ,	f_lim : α → E,	h_lim_meas : ae_measurable f_lim μ,	h_tendsto : ∀ (ε : ennreal), ε > 0 → (∃ (N : ℕ), ∀ (n : ℕ), n ≥ N → snorm (f n - f_lim) p μ ≤ ε),	N : ℕ,	h_tendsto_1 : snorm (f N - f_lim) p μ ≤ 1,	h_add : f_lim = f_lim - f N + f N	⊢ snorm (f_lim - f N) p μ < ⊤		α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ennreal,	μ : measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : second_countable_topology E,	hp : 1 ≤ p,	f : ℕ → α → E,	hf : ∀ (n : ℕ), mem_ℒp (f n) p μ,	f_lim : α → E,	h_lim_meas : ae_measurable f_lim μ,	h_tendsto : ∀ (ε : ennreal), ε > 0 → (∃ (N : ℕ), ∀ (n : ℕ), n ≥ N → snorm (f n - f_lim) p μ ≤ ε),	N : ℕ,	h_tendsto_1 : snorm (f N - f_lim) p μ ≤ 1,	h_add : f_lim = f_lim - f N + f N	⊢ snorm (f N) p μ < ⊤", "decl_nm": "measure_theory.Lp.mem_ℒp_of_cauchy_tendsto"
{"src": "2 goals	α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ennreal,	μ : measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : second_countable_topology E,	hp : 1 ≤ p,	f : ℕ → α → E,	hf : ∀ (n : ℕ), mem_ℒp (f n) p μ,	f_lim : α → E,	h_lim_meas : ae_measurable f_lim μ,	h_tendsto : ∀ (ε : ennreal), ε > 0 → (∃ (N : ℕ), ∀ (n : ℕ), n ≥ N → snorm (f n - f_lim) p μ ≤ ε),	N : ℕ,	h_tendsto_1 : snorm (f N - f_lim) p μ ≤ 1,	h_add : f_lim = f_lim - f N + f N	⊢ snorm (f_lim - f N) p μ ≤ 1		α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ennreal,	μ : measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : second_countable_topology E,	hp : 1 ≤ p,	f : ℕ → α → E,	hf : ∀ (n : ℕ), mem_ℒp (f n) p μ,	f_lim : α → E,	h_lim_meas : ae_measurable f_lim μ,	h_tendsto : ∀ (ε : ennreal), ε > 0 → (∃ (N : ℕ), ∀ (n : ℕ), n ≥ N → snorm (f n - f_lim) p μ ≤ ε),	N : ℕ,	h_tendsto_1 : snorm (f N - f_lim) p μ ≤ 1,	h_add : f_lim = f_lim - f N + f N	⊢ snorm (f N) p μ < ⊤", "decl_nm": "measure_theory.Lp.mem_ℒp_of_cauchy_tendsto"
{"src": "3 goals	α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ennreal,	μ : measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : second_countable_topology E,	hp : 1 ≤ p,	f : ℕ → α → E,	hf : ∀ (n : ℕ), mem_ℒp (f n) p μ,	f_lim : α → E,	h_lim_meas : ae_measurable f_lim μ,	h_tendsto : ∀ (ε : ennreal), ε > 0 → (∃ (N : ℕ), ∀ (n : ℕ), n ≥ N → snorm (f n - f_lim) p μ ≤ ε),	N : ℕ,	h_tendsto_1 : snorm (f N - f_lim) p μ ≤ 1,	h_add : f_lim = f_lim - f N + f N	⊢ f_lim - f N = -(f N - f_lim)		α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ennreal,	μ : measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : second_countable_topology E,	hp : 1 ≤ p,	f : ℕ → α → E,	hf : ∀ (n : ℕ), mem_ℒp (f n) p μ,	f_lim : α → E,	h_lim_meas : ae_measurable f_lim μ,	h_tendsto : ∀ (ε : ennreal), ε > 0 → (∃ (N : ℕ), ∀ (n : ℕ), n ≥ N → snorm (f n - f_lim) p μ ≤ ε),	N : ℕ,	h_tendsto_1 : snorm (f N - f_lim) p μ ≤ 1,	h_add : f_lim = f_lim - f N + f N,	h_neg : f_lim - f N = -(f N - f_lim)	⊢ snorm (f_lim - f N) p μ ≤ 1		α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ennreal,	μ : measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : second_countable_topology E,	hp : 1 ≤ p,	f : ℕ → α → E,	hf : ∀ (n : ℕ), mem_ℒp (f n) p μ,	f_lim : α → E,	h_lim_meas : ae_measurable f_lim μ,	h_tendsto : ∀ (ε : ennreal), ε > 0 → (∃ (N : ℕ), ∀ (n : ℕ), n ≥ N → snorm (f n - f_lim) p μ ≤ ε),	N : ℕ,	h_tendsto_1 : snorm (f N - f_lim) p μ ≤ 1,	h_add : f_lim = f_lim - f N + f N	⊢ snorm (f N) p μ < ⊤", "decl_nm": "measure_theory.Lp.mem_ℒp_of_cauchy_tendsto"
{"src": "2 goals	α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ennreal,	μ : measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : second_countable_topology E,	hp : 1 ≤ p,	f : ℕ → α → E,	hf : ∀ (n : ℕ), mem_ℒp (f n) p μ,	f_lim : α → E,	h_lim_meas : ae_measurable f_lim μ,	h_tendsto : ∀ (ε : ennreal), ε > 0 → (∃ (N : ℕ), ∀ (n : ℕ), n ≥ N → snorm (f n - f_lim) p μ ≤ ε),	N : ℕ,	h_tendsto_1 : snorm (f N - f_lim) p μ ≤ 1,	h_add : f_lim = f_lim - f N + f N,	h_neg : f_lim - f N = -(f N - f_lim)	⊢ snorm (f_lim - f N) p μ ≤ 1		α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ennreal,	μ : measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : second_countable_topology E,	hp : 1 ≤ p,	f : ℕ → α → E,	hf : ∀ (n : ℕ), mem_ℒp (f n) p μ,	f_lim : α → E,	h_lim_meas : ae_measurable f_lim μ,	h_tendsto : ∀ (ε : ennreal), ε > 0 → (∃ (N : ℕ), ∀ (n : ℕ), n ≥ N → snorm (f n - f_lim) p μ ≤ ε),	N : ℕ,	h_tendsto_1 : snorm (f N - f_lim) p μ ≤ 1,	h_add : f_lim = f_lim - f N + f N	⊢ snorm (f N) p μ < ⊤", "decl_nm": "measure_theory.Lp.mem_ℒp_of_cauchy_tendsto"
{"src": "α : Type u_1,	E : Type u_2,	m0 : measurable_space α,	p : ennreal,	μ : measure α,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	_inst_6 : second_countable_topology E,	hp : 1 ≤ p,	f : ℕ → α → E,	hf : ∀ (n : ℕ), mem_ℒp (f n) p μ,	f_lim : α → E,	h_lim_meas : ae_measurable f_lim μ,	h_tendsto : ∀ (ε : ennreal), ε > 0 → (∃ (N : ℕ), ∀ (n : ℕ), n ≥ N → snorm (f n - f_lim) p μ ≤ ε),	N : ℕ,	h_tendsto_1 : snorm (f N - f_lim) p μ ≤ 1,	h_add : f_lim = f_lim - f N + f N	⊢ snorm (f N) p μ < ⊤", "decl_nm": "measure_theory.Lp.mem_ℒp_of_cauchy_tendsto"
{"src": "⊢ ∀ {α : Type u_1} {F : Type u_3} {m0 : measurable_space α} {q : ℝ} {μ : measure α} [_inst_3 : normed_group F]	  (c : F), 0 < q → ∀ [_inst_5 : is_probability_measure μ], snorm' (λ (x : α), c) q μ = ↑∥c∥₊", "decl_nm": "measure_theory.snorm'_const_of_is_probability_measure"
{"src": "α : Type u_1,	F : Type u_3,	m0 : measurable_space α,	q : ℝ,	μ : measure α,	_inst_3 : normed_group F,	c : F,	hq_pos : 0 < q,	_inst_5 : is_probability_measure μ	⊢ snorm' (λ (x : α), c) q μ = ↑∥c∥₊", "decl_nm": "measure_theory.snorm'_const_of_is_probability_measure"
{"src": "⊢ ∀ {α : Type u_1} {F : Type u_3} {m0 : measurable_space α} {q : ℝ} {μ : measure α} [_inst_3 : normed_group F]	  {f : α → F}, snorm' (λ (a : α), ∥f a∥) q μ = snorm' f q μ", "decl_nm": "measure_theory.snorm'_norm"
{"src": "α : Type u_1,	F : Type u_3,	m0 : measurable_space α,	q : ℝ,	μ : measure α,	_inst_3 : normed_group F,	f : α → F	⊢ snorm' (λ (a : α), ∥f a∥) q μ = snorm' f q μ", "decl_nm": "measure_theory.snorm'_norm"
{"src": "⊢ ∀ {α : Type u_1} {F : Type u_3} {m0 : measurable_space α} {q : ℝ} {μ : measure α}	  [_inst_3 : normed_group F],	    0 < q → ∀ {f : α → F}, snorm' f q μ ≤ snorm_ess_sup f μ * ⇑μ set.univ ^ (1 / q)", "decl_nm": "measure_theory.snorm'_le_snorm_ess_sup_mul_rpow_measure_univ"
{"src": "α : Type u_1,	F : Type u_3,	m0 : measurable_space α,	q : ℝ,	μ : measure α,	_inst_3 : normed_group F,	hq_pos : 0 < q,	f : α → F	⊢ snorm' f q μ ≤ snorm_ess_sup f μ * ⇑μ set.univ ^ (1 / q)", "decl_nm": "measure_theory.snorm'_le_snorm_ess_sup_mul_rpow_measure_univ"
{"src": "2 goals	α : Type u_1,	F : Type u_3,	m0 : measurable_space α,	q : ℝ,	μ : measure α,	_inst_3 : normed_group F,	hq_pos : 0 < q,	f : α → F	⊢ ∫⁻ (a : α), ↑∥f a∥₊ ^ q ∂μ ≤ ∫⁻ (a : α), snorm_ess_sup f μ ^ q ∂μ		α : Type u_1,	F : Type u_3,	m0 : measurable_space α,	q : ℝ,	μ : measure α,	_inst_3 : normed_group F,	hq_pos : 0 < q,	f : α → F,	h_le : ∫⁻ (a : α), ↑∥f a∥₊ ^ q ∂μ ≤ ∫⁻ (a : α), snorm_ess_sup f μ ^ q ∂μ	⊢ snorm' f q μ ≤ snorm_ess_sup f μ * ⇑μ set.univ ^ (1 / q)", "decl_nm": "measure_theory.snorm'_le_snorm_ess_sup_mul_rpow_measure_univ"
{"src": "2 goals	α : Type u_1,	F : Type u_3,	m0 : measurable_space α,	q : ℝ,	μ : measure α,	_inst_3 : normed_group F,	hq_pos : 0 < q,	f : α → F	⊢ ∀ᵐ (a : α) ∂μ, ↑∥f a∥₊ ^ q ≤ snorm_ess_sup f μ ^ q		α : Type u_1,	F : Type u_3,	m0 : measurable_space α,	q : ℝ,	μ : measure α,	_inst_3 : normed_group F,	hq_pos : 0 < q,	f : α → F,	h_le : ∫⁻ (a : α), ↑∥f a∥₊ ^ q ∂μ ≤ ∫⁻ (a : α), snorm_ess_sup f μ ^ q ∂μ	⊢ snorm' f q μ ≤ snorm_ess_sup f μ * ⇑μ set.univ ^ (1 / q)", "decl_nm": "measure_theory.snorm'_le_snorm_ess_sup_mul_rpow_measure_univ"
{"src": "2 goals	α : Type u_1,	F : Type u_3,	m0 : measurable_space α,	q : ℝ,	μ : measure α,	_inst_3 : normed_group F,	hq_pos : 0 < q,	f : α → F,	h_nnnorm_le_snorm_ess_sup : ∀ᵐ (x : α) ∂μ, ↑∥f x∥₊ ≤ snorm_ess_sup f μ	⊢ ∀ᵐ (a : α) ∂μ, ↑∥f a∥₊ ^ q ≤ snorm_ess_sup f μ ^ q		α : Type u_1,	F : Type u_3,	m0 : measurable_space α,	q : ℝ,	μ : measure α,	_inst_3 : normed_group F,	hq_pos : 0 < q,	f : α → F,	h_le : ∫⁻ (a : α), ↑∥f a∥₊ ^ q ∂μ ≤ ∫⁻ (a : α), snorm_ess_sup f μ ^ q ∂μ	⊢ snorm' f q μ ≤ snorm_ess_sup f μ * ⇑μ set.univ ^ (1 / q)", "decl_nm": "measure_theory.snorm'_le_snorm_ess_sup_mul_rpow_measure_univ"
{"src": "α : Type u_1,	F : Type u_3,	m0 : measurable_space α,	q : ℝ,	μ : measure α,	_inst_3 : normed_group F,	hq_pos : 0 < q,	f : α → F,	h_le : ∫⁻ (a : α), ↑∥f a∥₊ ^ q ∂μ ≤ ∫⁻ (a : α), snorm_ess_sup f μ ^ q ∂μ	⊢ snorm' f q μ ≤ snorm_ess_sup f μ * ⇑μ set.univ ^ (1 / q)", "decl_nm": "measure_theory.snorm'_le_snorm_ess_sup_mul_rpow_measure_univ"
{"src": "α : Type u_1,	F : Type u_3,	m0 : measurable_space α,	q : ℝ,	μ : measure α,	_inst_3 : normed_group F,	hq_pos : 0 < q,	f : α → F,	h_le : ∫⁻ (a : α), ↑∥f a∥₊ ^ q ∂μ ≤ ∫⁻ (a : α), snorm_ess_sup f μ ^ q ∂μ	⊢ (∫⁻ (a : α), ↑∥f a∥₊ ^ q ∂μ) ^ (1 / q) ≤ snorm_ess_sup f μ ^ 1 * ⇑μ set.univ ^ (1 / q)", "decl_nm": "measure_theory.snorm'_le_snorm_ess_sup_mul_rpow_measure_univ"
{"src": "α : Type u_1,	F : Type u_3,	m0 : measurable_space α,	q : ℝ,	μ : measure α,	_inst_3 : normed_group F,	hq_pos : 0 < q,	f : α → F,	h_le : ∫⁻ (a : α), ↑∥f a∥₊ ^ q ∂μ ≤ ∫⁻ (a : α), snorm_ess_sup f μ ^ q ∂μ	⊢ (∫⁻ (a : α), ↑∥f a∥₊ ^ q ∂μ) ^ (1 / q) ≤	    snorm_ess_sup f μ ^ (q * q⁻¹) * ⇑μ set.univ ^ (1 / q)", "decl_nm": "measure_theory.snorm'_le_snorm_ess_sup_mul_rpow_measure_univ"
{"src": "α : Type u_1,	F : Type u_3,	m0 : measurable_space α,	q : ℝ,	μ : measure α,	_inst_3 : normed_group F,	hq_pos : 0 < q,	f : α → F,	h_le : ∫⁻ (a : α), ↑∥f a∥₊ ^ q ∂μ ≤ ∫⁻ (a : α), snorm_ess_sup f μ ^ q ∂μ	⊢ (∫⁻ (a : α), ↑∥f a∥₊ ^ q ∂μ) ^ q⁻¹ ≤ (snorm_ess_sup f μ ^ q * ⇑μ set.univ) ^ q⁻¹", "decl_nm": "measure_theory.snorm'_le_snorm_ess_sup_mul_rpow_measure_univ"
{"src": "α : Type u_1,	F : Type u_3,	m0 : measurable_space α,	q : ℝ,	μ : measure α,	_inst_3 : normed_group F,	hq_pos : 0 < q,	f : α → F,	h_le : ∫⁻ (a : α), ↑∥f a∥₊ ^ q ∂μ ≤ ∫⁻ (a : α), snorm_ess_sup f μ ^ q ∂μ	⊢ ∫⁻ (a : α), ↑∥f a∥₊ ^ q ∂μ ≤ snorm_ess_sup f μ ^ q * ⇑μ set.univ", "decl_nm": "measure_theory.snorm'_le_snorm_ess_sup_mul_rpow_measure_univ"
{"src": "⊢ ∀ {α : Type u_1} {E : Type u_2} [_inst_1 : measurable_space E] [_inst_2 : normed_group E]	  [_inst_5 : borel_space E] {m : measurable_space α} {p q : ℝ},	    0 < p →	    p ≤ q →	    ∀ (μ : measure α) [_inst_6 : is_probability_measure μ] {f : α → E},	      ae_measurable f μ → snorm' f p μ ≤ snorm' f q μ", "decl_nm": "measure_theory.snorm'_le_snorm'_of_exponent_le"
{"src": "α : Type u_1,	E : Type u_2,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	m : measurable_space α,	p q : ℝ,	hp0_lt : 0 < p,	hpq : p ≤ q,	μ : measure α,	_inst_6 : is_probability_measure μ,	f : α → E,	hf : ae_measurable f μ	⊢ snorm' f p μ ≤ snorm' f q μ", "decl_nm": "measure_theory.snorm'_le_snorm'_of_exponent_le"
{"src": "α : Type u_1,	E : Type u_2,	_inst_1 : measurable_space E,	_inst_2 : normed_group E,	_inst_5 : borel_space E,	m : measurable_space α,	p q : ℝ,	hp0_lt : 0 < p,	hpq : p ≤ q,	μ : measure α,	_inst_6 : is_probability_measure μ,	f : α → E,	hf : ae_measurable f μ,	h_le_μ : snorm' f p μ ≤ snorm' f q μ * ⇑μ set.univ ^ (1 / p - 1 / q)	⊢ snorm' f p μ ≤ snorm' f q μ", "decl_nm": "measure_theory.snorm'_le_snorm'_of_exponent_le"
{"src": "⊢ ∀ {α : Type u_1} {m : measurable_space α} {μ : measure α} {f : α → ennreal},	    ae_measurable f μ →	    (∀ᵐ (x : α) ∂μ, f x < ⊤) → ∫ (a : α), (f a).to_real ∂μ = (∫⁻ (a : α), f a ∂μ).to_real", "decl_nm": "measure_theory.integral_to_real"
{"src": "α : Type u_1,	m : measurable_space α,	μ : measure α,	f : α → ennreal,	hfm : ae_measurable f μ,	hf : ∀ᵐ (x : α) ∂μ, f x < ⊤	⊢ ∫ (a : α), (f a).to_real ∂μ = (∫⁻ (a : α), f a ∂μ).to_real", "decl_nm": "measure_theory.integral_to_real"
{"src": "2 goals	α : Type u_1,	m : measurable_space α,	μ : measure α,	f : α → ennreal,	hfm : ae_measurable f μ,	hf : ∀ᵐ (x : α) ∂μ, f x < ⊤	⊢ (∫⁻ (a : α), ennreal.of_real ((λ (x : α), (f x).to_real) a) ∂μ).to_real =	    (∫⁻ (a : α), f a ∂μ).to_real		α : Type u_1,	m : measurable_space α,	μ : measure α,	f : α → ennreal,	hfm : ae_measurable f μ,	hf : ∀ᵐ (x : α) ∂μ, f x < ⊤	⊢ 0 ≤ᵐ[μ] λ (x : α), (f x).to_real", "decl_nm": "measure_theory.integral_to_real"
{"src": "2 goals	α : Type u_1,	m : measurable_space α,	μ : measure α,	f : α → ennreal,	hfm : ae_measurable f μ,	hf : ∀ᵐ (x : α) ∂μ, f x < ⊤	⊢ (λ (a : α), ennreal.of_real ((λ (x : α), (f x).to_real) a)) =ᵐ[μ] λ (a : α), f a		α : Type u_1,	m : measurable_space α,	μ : measure α,	f : α → ennreal,	hfm : ae_measurable f μ,	hf : ∀ᵐ (x : α) ∂μ, f x < ⊤	⊢ 0 ≤ᵐ[μ] λ (x : α), (f x).to_real", "decl_nm": "measure_theory.integral_to_real"
{"src": "2 goals	α : Type u_1,	m : measurable_space α,	μ : measure α,	f : α → ennreal,	hfm : ae_measurable f μ,	hf : ∀ᵐ (x : α) ∂μ, f x < ⊤	⊢ ∀ (x : α), f x < ⊤ → (λ (a : α), ennreal.of_real ((λ (x : α), (f x).to_real) a)) x = f x		α : Type u_1,	m : measurable_space α,	μ : measure α,	f : α → ennreal,	hfm : ae_measurable f μ,	hf : ∀ᵐ (x : α) ∂μ, f x < ⊤	⊢ 0 ≤ᵐ[μ] λ (x : α), (f x).to_real", "decl_nm": "measure_theory.integral_to_real"
{"src": "2 goals	α : Type u_1,	m : measurable_space α,	μ : measure α,	f : α → ennreal,	hfm : ae_measurable f μ,	hf : ∀ᵐ (x : α) ∂μ, f x < ⊤,	x : α,	hx : f x < ⊤	⊢ (λ (a : α), ennreal.of_real ((λ (x : α), (f x).to_real) a)) x = f x		α : Type u_1,	m : measurable_space α,	μ : measure α,	f : α → ennreal,	hfm : ae_measurable f μ,	hf : ∀ᵐ (x : α) ∂μ, f x < ⊤	⊢ 0 ≤ᵐ[μ] λ (x : α), (f x).to_real", "decl_nm": "measure_theory.integral_to_real"
{"src": "2 goals	α : Type u_1,	m : measurable_space α,	μ : measure α,	f : α → ennreal,	hfm : ae_measurable f μ,	hf : ∀ᵐ (x : α) ∂μ, f x < ⊤,	x : α,	hx : f x ≠ ⊤	⊢ (λ (a : α), ennreal.of_real ((λ (x : α), (f x).to_real) a)) x = f x		α : Type u_1,	m : measurable_space α,	μ : measure α,	f : α → ennreal,	hfm : ae_measurable f μ,	hf : ∀ᵐ (x : α) ∂μ, f x < ⊤	⊢ 0 ≤ᵐ[μ] λ (x : α), (f x).to_real", "decl_nm": "measure_theory.integral_to_real"
{"src": "α : Type u_1,	m : measurable_space α,	μ : measure α,	f : α → ennreal,	hfm : ae_measurable f μ,	hf : ∀ᵐ (x : α) ∂μ, f x < ⊤	⊢ 0 ≤ᵐ[μ] λ (x : α), (f x).to_real", "decl_nm": "measure_theory.integral_to_real"
{"src": "⊢ ∀ {E : Type u_4} [_inst_3 : measurable_space E] [_inst_4 : normed_group E] [_inst_5 : second_countable_topology E]	  [_inst_6 : complete_space E] [_inst_7 : normed_space ℝ E] [_inst_8 : borel_space E] {f : ℝ → E} {a b : ℝ}	  {f' : ℝ → E},	    a ≤ b →	    continuous_on f (Icc a b) →	    (∀ (x : ℝ), x ∈ Ioo a b → has_deriv_within_at f (f' x) (Ioi x) x) →	    interval_integrable f' volume a b → ∫ (y : ℝ) in a..b, f' y = f b - f a", "decl_nm": "interval_integral.integral_eq_sub_of_has_deriv_right_of_le"
{"src": "E : Type u_4,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	f : ℝ → E,	a b : ℝ,	f' : ℝ → E,	hab : a ≤ b,	hcont : continuous_on f (Icc a b),	hderiv : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_within_at f (f' x) (Ioi x) x,	f'int : interval_integrable f' volume a b	⊢ ∫ (y : ℝ) in a..b, f' y = f b - f a", "decl_nm": "interval_integral.integral_eq_sub_of_has_deriv_right_of_le"
{"src": "E : Type u_4,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	f : ℝ → E,	a b : ℝ,	f' : ℝ → E,	hab : a ≤ b,	hcont : continuous_on f (Icc a b),	hderiv : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_within_at f (f' x) (Ioi x) x,	f'int : interval_integrable f' volume a b,	g : normed_space.dual ℝ E	⊢ ⇑g (∫ (y : ℝ) in a..b, f' y) = ⇑g (f b - f a)", "decl_nm": "interval_integral.integral_eq_sub_of_has_deriv_right_of_le"
{"src": "E : Type u_4,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	f : ℝ → E,	a b : ℝ,	f' : ℝ → E,	hab : a ≤ b,	hcont : continuous_on f (Icc a b),	hderiv : ∀ (x : ℝ), x ∈ Ioo a b → has_deriv_within_at f (f' x) (Ioi x) x,	f'int : interval_integrable f' volume a b,	g : normed_space.dual ℝ E	⊢ ∫ (x : ℝ) in a..b, ⇑g (f' x) = ⇑g (f b) - ⇑g (f a)", "decl_nm": "interval_integral.integral_eq_sub_of_has_deriv_right_of_le"
{"src": "⊢ ∀ {E : Type u_4} [_inst_3 : measurable_space E] [_inst_4 : normed_group E] [_inst_5 : second_countable_topology E]	  [_inst_6 : complete_space E] [_inst_7 : normed_space ℝ E] [_inst_8 : borel_space E] {a b c : ℝ} (f : ℝ → E),	    c ≠ 0 → ∫ (x : ℝ) in a..b, f (c * x) = c⁻¹ • ∫ (x : ℝ) in c * a..c * b, f x", "decl_nm": "interval_integral.integral_comp_mul_left"
{"src": "E : Type u_4,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	a b c : ℝ,	f : ℝ → E,	hc : c ≠ 0	⊢ ∫ (x : ℝ) in a..b, f (c * x) = c⁻¹ • ∫ (x : ℝ) in c * a..c * b, f x", "decl_nm": "interval_integral.integral_comp_mul_left"
{"src": "⊢ ∀ {E : Type u_4} [_inst_3 : measurable_space E] [_inst_4 : normed_group E] [_inst_5 : second_countable_topology E]	  [_inst_6 : complete_space E] [_inst_7 : normed_space ℝ E] [_inst_8 : borel_space E] {a b : ℝ} (f : ℝ → E)	  (d : ℝ), ∫ (x : ℝ) in a..b, f (d - x) = ∫ (x : ℝ) in d - b..d - a, f x", "decl_nm": "interval_integral.integral_comp_sub_left"
{"src": "E : Type u_4,	_inst_3 : measurable_space E,	_inst_4 : normed_group E,	_inst_5 : second_countable_topology E,	_inst_6 : complete_space E,	_inst_7 : normed_space ℝ E,	_inst_8 : borel_space E,	a b : ℝ,	f : ℝ → E,	d : ℝ	⊢ ∫ (x : ℝ) in a..b, f (d - x) = ∫ (x : ℝ) in d - b..d - a, f x", "decl_nm": "interval_integral.integral_comp_sub_left"
{"src": "⊢ ∀ {α : Type u_1} {m : measurable_space α} {μ : measure α} (s : set α) (c : ennreal),	    ∫⁻ (a : α) in s, c ∂μ = c * ⇑μ s", "decl_nm": "measure_theory.set_lintegral_const"
{"src": "α : Type u_1,	m : measurable_space α,	μ : measure α,	s : set α,	c : ennreal	⊢ ∫⁻ (a : α) in s, c ∂μ = c * ⇑μ s", "decl_nm": "measure_theory.set_lintegral_const"
{"src": "⊢ ∀ {α : Type u_1} {m : measurable_space α} {μ : measure α} {f : α → ℝ},	    measurable f →	    (μ.with_density (λ (x : α), ennreal.of_real (f x))).mutually_singular	      (μ.with_density (λ (x : α), ennreal.of_real (-f x)))", "decl_nm": "measure_theory.with_density_of_real_mutually_singular"
{"src": "α : Type u_1,	m : measurable_space α,	μ : measure α,	f : α → ℝ,	hf : measurable f	⊢ (μ.with_density (λ (x : α), ennreal.of_real (f x))).mutually_singular	    (μ.with_density (λ (x : α), ennreal.of_real (-f x)))", "decl_nm": "measure_theory.with_density_of_real_mutually_singular"
{"src": "α : Type u_1,	m : measurable_space α,	μ : measure α,	f : α → ℝ,	hf : measurable f,	S : set α := {x : α | f x < 0},	hSdef : S = {x : α | f x < 0}	⊢ (μ.with_density (λ (x : α), ennreal.of_real (f x))).mutually_singular	    (μ.with_density (λ (x : α), ennreal.of_real (-f x)))", "decl_nm": "measure_theory.with_density_of_real_mutually_singular"
{"src": "α : Type u_1,	m : measurable_space α,	μ : measure α,	f : α → ℝ,	hf : measurable f,	S : set α := {x : α | f x < 0},	hSdef : S = {x : α | f x < 0},	hS : measurable_set S	⊢ (μ.with_density (λ (x : α), ennreal.of_real (f x))).mutually_singular	    (μ.with_density (λ (x : α), ennreal.of_real (-f x)))", "decl_nm": "measure_theory.with_density_of_real_mutually_singular"
{"src": "2 goals	α : Type u_1,	m : measurable_space α,	μ : measure α,	f : α → ℝ,	hf : measurable f,	S : set α := {x : α | f x < 0},	hSdef : S = {x : α | f x < 0},	hS : measurable_set S	⊢ ⇑(μ.with_density (λ (x : α), ennreal.of_real (f x))) S = 0		α : Type u_1,	m : measurable_space α,	μ : measure α,	f : α → ℝ,	hf : measurable f,	S : set α := {x : α | f x < 0},	hSdef : S = {x : α | f x < 0},	hS : measurable_set S	⊢ ⇑(μ.with_density (λ (x : α), ennreal.of_real (-f x))) Sᶜ = 0", "decl_nm": "measure_theory.with_density_of_real_mutually_singular"
{"src": "2 goals	α : Type u_1,	m : measurable_space α,	μ : measure α,	f : α → ℝ,	hf : measurable f,	S : set α := {x : α | f x < 0},	hSdef : S = {x : α | f x < 0},	hS : measurable_set S	⊢ ∫⁻ (a : α) in {x : α | f x < 0}, ennreal.of_real (f a) ∂μ = 0		α : Type u_1,	m : measurable_space α,	μ : measure α,	f : α → ℝ,	hf : measurable f,	S : set α := {x : α | f x < 0},	hSdef : S = {x : α | f x < 0},	hS : measurable_set S	⊢ ⇑(μ.with_density (λ (x : α), ennreal.of_real (-f x))) Sᶜ = 0", "decl_nm": "measure_theory.with_density_of_real_mutually_singular"
{"src": "3 goals	α : Type u_1,	m : measurable_space α,	μ : measure α,	f : α → ℝ,	hf : measurable f,	S : set α := {x : α | f x < 0},	hSdef : S = {x : α | f x < 0},	hS : measurable_set S	⊢ ∀ᵐ (x : α) ∂μ, x ∈ S → ennreal.of_real (f x) = 0		α : Type u_1,	m : measurable_space α,	μ : measure α,	f : α → ℝ,	hf : measurable f,	S : set α := {x : α | f x < 0},	hSdef : S = {x : α | f x < 0},	hS : measurable_set S,	hf0 : ∀ᵐ (x : α) ∂μ, x ∈ S → ennreal.of_real (f x) = 0	⊢ ∫⁻ (a : α) in {x : α | f x < 0}, ennreal.of_real (f a) ∂μ = 0		α : Type u_1,	m : measurable_space α,	μ : measure α,	f : α → ℝ,	hf : measurable f,	S : set α := {x : α | f x < 0},	hSdef : S = {x : α | f x < 0},	hS : measurable_set S	⊢ ⇑(μ.with_density (λ (x : α), ennreal.of_real (-f x))) Sᶜ = 0", "decl_nm": "measure_theory.with_density_of_real_mutually_singular"
{"src": "3 goals	α : Type u_1,	m : measurable_space α,	μ : measure α,	f : α → ℝ,	hf : measurable f,	S : set α := {x : α | f x < 0},	hSdef : S = {x : α | f x < 0},	hS : measurable_set S,	_x : α,	hx : _x ∈ S	⊢ ennreal.of_real (f _x) = 0		α : Type u_1,	m : measurable_space α,	μ : measure α,	f : α → ℝ,	hf : measurable f,	S : set α := {x : α | f x < 0},	hSdef : S = {x : α | f x < 0},	hS : measurable_set S,	hf0 : ∀ᵐ (x : α) ∂μ, x ∈ S → ennreal.of_real (f x) = 0	⊢ ∫⁻ (a : α) in {x : α | f x < 0}, ennreal.of_real (f a) ∂μ = 0		α : Type u_1,	m : measurable_space α,	μ : measure α,	f : α → ℝ,	hf : measurable f,	S : set α := {x : α | f x < 0},	hSdef : S = {x : α | f x < 0},	hS : measurable_set S	⊢ ⇑(μ.with_density (λ (x : α), ennreal.of_real (-f x))) Sᶜ = 0", "decl_nm": "measure_theory.with_density_of_real_mutually_singular"
{"src": "2 goals	α : Type u_1,	m : measurable_space α,	μ : measure α,	f : α → ℝ,	hf : measurable f,	S : set α := {x : α | f x < 0},	hSdef : S = {x : α | f x < 0},	hS : measurable_set S,	hf0 : ∀ᵐ (x : α) ∂μ, x ∈ S → ennreal.of_real (f x) = 0	⊢ ∫⁻ (a : α) in {x : α | f x < 0}, ennreal.of_real (f a) ∂μ = 0		α : Type u_1,	m : measurable_space α,	μ : measure α,	f : α → ℝ,	hf : measurable f,	S : set α := {x : α | f x < 0},	hSdef : S = {x : α | f x < 0},	hS : measurable_set S	⊢ ⇑(μ.with_density (λ (x : α), ennreal.of_real (-f x))) Sᶜ = 0", "decl_nm": "measure_theory.with_density_of_real_mutually_singular"
{"src": "2 goals	α : Type u_1,	m : measurable_space α,	μ : measure α,	f : α → ℝ,	hf : measurable f,	S : set α := {x : α | f x < 0},	hSdef : S = {x : α | f x < 0},	hS : measurable_set S,	hf0 : ∀ᵐ (x : α) ∂μ, x ∈ S → ennreal.of_real (f x) = 0	⊢ ∫⁻ (x : α) in S, (λ (x : α), 0) x ∂μ = 0		α : Type u_1,	m : measurable_space α,	μ : measure α,	f : α → ℝ,	hf : measurable f,	S : set α := {x : α | f x < 0},	hSdef : S = {x : α | f x < 0},	hS : measurable_set S	⊢ ⇑(μ.with_density (λ (x : α), ennreal.of_real (-f x))) Sᶜ = 0", "decl_nm": "measure_theory.with_density_of_real_mutually_singular"
{"src": "α : Type u_1,	m : measurable_space α,	μ : measure α,	f : α → ℝ,	hf : measurable f,	S : set α := {x : α | f x < 0},	hSdef : S = {x : α | f x < 0},	hS : measurable_set S	⊢ ⇑(μ.with_density (λ (x : α), ennreal.of_real (-f x))) Sᶜ = 0", "decl_nm": "measure_theory.with_density_of_real_mutually_singular"
{"src": "α : Type u_1,	m : measurable_space α,	μ : measure α,	f : α → ℝ,	hf : measurable f,	S : set α := {x : α | f x < 0},	hSdef : S = {x : α | f x < 0},	hS : measurable_set S	⊢ ∫⁻ (a : α) in {x : α | f x < 0}ᶜ, ennreal.of_real (-f a) ∂μ = 0", "decl_nm": "measure_theory.with_density_of_real_mutually_singular"
{"src": "2 goals	α : Type u_1,	m : measurable_space α,	μ : measure α,	f : α → ℝ,	hf : measurable f,	S : set α := {x : α | f x < 0},	hSdef : S = {x : α | f x < 0},	hS : measurable_set S	⊢ ∀ᵐ (x : α) ∂μ, x ∈ Sᶜ → ennreal.of_real (-f x) = 0		α : Type u_1,	m : measurable_space α,	μ : measure α,	f : α → ℝ,	hf : measurable f,	S : set α := {x : α | f x < 0},	hSdef : S = {x : α | f x < 0},	hS : measurable_set S,	hf0 : ∀ᵐ (x : α) ∂μ, x ∈ Sᶜ → ennreal.of_real (-f x) = 0	⊢ ∫⁻ (a : α) in {x : α | f x < 0}ᶜ, ennreal.of_real (-f a) ∂μ = 0", "decl_nm": "measure_theory.with_density_of_real_mutually_singular"
{"src": "2 goals	α : Type u_1,	m : measurable_space α,	μ : measure α,	f : α → ℝ,	hf : measurable f,	S : set α := {x : α | f x < 0},	hSdef : S = {x : α | f x < 0},	hS : measurable_set S,	x : α,	hx : x ∈ Sᶜ	⊢ ennreal.of_real (-f x) = 0		α : Type u_1,	m : measurable_space α,	μ : measure α,	f : α → ℝ,	hf : measurable f,	S : set α := {x : α | f x < 0},	hSdef : S = {x : α | f x < 0},	hS : measurable_set S,	hf0 : ∀ᵐ (x : α) ∂μ, x ∈ Sᶜ → ennreal.of_real (-f x) = 0	⊢ ∫⁻ (a : α) in {x : α | f x < 0}ᶜ, ennreal.of_real (-f a) ∂μ = 0", "decl_nm": "measure_theory.with_density_of_real_mutually_singular"
{"src": "2 goals	α : Type u_1,	m : measurable_space α,	μ : measure α,	f : α → ℝ,	hf : measurable f,	S : set α := {x : α | f x < 0},	hSdef : S = {x : α | f x < 0},	hS : measurable_set S,	x : α,	hx : x ∈ Sᶜ	⊢ -f x ≤ 0		α : Type u_1,	m : measurable_space α,	μ : measure α,	f : α → ℝ,	hf : measurable f,	S : set α := {x : α | f x < 0},	hSdef : S = {x : α | f x < 0},	hS : measurable_set S,	hf0 : ∀ᵐ (x : α) ∂μ, x ∈ Sᶜ → ennreal.of_real (-f x) = 0	⊢ ∫⁻ (a : α) in {x : α | f x < 0}ᶜ, ennreal.of_real (-f a) ∂μ = 0", "decl_nm": "measure_theory.with_density_of_real_mutually_singular"
{"src": "α : Type u_1,	m : measurable_space α,	μ : measure α,	f : α → ℝ,	hf : measurable f,	S : set α := {x : α | f x < 0},	hSdef : S = {x : α | f x < 0},	hS : measurable_set S,	hf0 : ∀ᵐ (x : α) ∂μ, x ∈ Sᶜ → ennreal.of_real (-f x) = 0	⊢ ∫⁻ (a : α) in {x : α | f x < 0}ᶜ, ennreal.of_real (-f a) ∂μ = 0", "decl_nm": "measure_theory.with_density_of_real_mutually_singular"
{"src": "α : Type u_1,	m : measurable_space α,	μ : measure α,	f : α → ℝ,	hf : measurable f,	S : set α := {x : α | f x < 0},	hSdef : S = {x : α | f x < 0},	hS : measurable_set S,	hf0 : ∀ᵐ (x : α) ∂μ, x ∈ Sᶜ → ennreal.of_real (-f x) = 0	⊢ ∫⁻ (x : α) in Sᶜ, (λ (x : α), 0) x ∂μ = 0", "decl_nm": "measure_theory.with_density_of_real_mutually_singular"
{"src": "⊢ ∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [_inst_1 : measurable_space α] (f : simple_func α β)	  (g : β → γ) (s : set γ),	    ⇑(simple_func.map g f) ⁻¹' s = ⇑f ⁻¹' ↑(finset.filter (λ (b : β), g b ∈ s) f.range)", "decl_nm": "measure_theory.simple_func.map_preimage"
{"src": "α : Type u_1,	β : Type u_2,	γ : Type u_3,	_inst_1 : measurable_space α,	f : simple_func α β,	g : β → γ,	s : set γ	⊢ ⇑(simple_func.map g f) ⁻¹' s = ⇑f ⁻¹' ↑(finset.filter (λ (b : β), g b ∈ s) f.range)", "decl_nm": "measure_theory.simple_func.map_preimage"
{"src": "α : Type u_1,	β : Type u_2,	γ : Type u_3,	_inst_1 : measurable_space α,	f : simple_func α β,	g : β → γ,	s : set γ	⊢ g ∘ ⇑f ⁻¹' s = ⇑f ⁻¹' (g ⁻¹' s)", "decl_nm": "measure_theory.simple_func.map_preimage"
{"src": "⊢ ∀ {α : Type u_1} [_inst_1 : measurable_space α] {μ : measure α} {p : ℝ},	    0 < p →	    ∀ {f g : α → ennreal},	      ae_measurable f μ → ∫⁻ (a : α), f a ^ p ∂μ = 0 → ∫⁻ (a : α), (f * g) a ∂μ = 0", "decl_nm": "ennreal.lintegral_mul_eq_zero_of_lintegral_rpow_eq_zero"
{"src": "α : Type u_1,	_inst_1 : measurable_space α,	μ : measure α,	p : ℝ,	hp0_lt : 0 < p,	f g : α → ennreal,	hf : ae_measurable f μ,	hf_zero : ∫⁻ (a : α), f a ^ p ∂μ = 0	⊢ ∫⁻ (a : α), (f * g) a ∂μ = 0", "decl_nm": "ennreal.lintegral_mul_eq_zero_of_lintegral_rpow_eq_zero"
{"src": "α : Type u_1,	_inst_1 : measurable_space α,	μ : measure α,	p : ℝ,	hp0_lt : 0 < p,	f g : α → ennreal,	hf : ae_measurable f μ,	hf_zero : ∫⁻ (a : α), f a ^ p ∂μ = 0	⊢ ∫⁻ (a : α), (f * g) a ∂μ = ∫⁻ (a : α), 0 a ∂μ", "decl_nm": "ennreal.lintegral_mul_eq_zero_of_lintegral_rpow_eq_zero"
{"src": "α : Type u_1,	_inst_1 : measurable_space α,	μ : measure α,	p : ℝ,	hp0_lt : 0 < p,	f g : α → ennreal,	hf : ae_measurable f μ,	hf_zero : ∫⁻ (a : α), f a ^ p ∂μ = 0	⊢ (λ (a : α), (f * g) a) =ᵐ[μ] λ (a : α), 0 a", "decl_nm": "ennreal.lintegral_mul_eq_zero_of_lintegral_rpow_eq_zero"
{"src": "2 goals	α : Type u_1,	_inst_1 : measurable_space α,	μ : measure α,	p : ℝ,	hp0_lt : 0 < p,	f g : α → ennreal,	hf : ae_measurable f μ,	hf_zero : ∫⁻ (a : α), f a ^ p ∂μ = 0,	h_mul_zero : f * g =ᵐ[μ] 0 * g	⊢ (λ (a : α), (f * g) a) =ᵐ[μ] λ (a : α), 0 a		α : Type u_1,	_inst_1 : measurable_space α,	μ : measure α,	p : ℝ,	hp0_lt : 0 < p,	f g : α → ennreal,	hf : ae_measurable f μ,	hf_zero : ∫⁻ (a : α), f a ^ p ∂μ = 0	⊢ f * g =ᵐ[μ] 0 * g", "decl_nm": "ennreal.lintegral_mul_eq_zero_of_lintegral_rpow_eq_zero"
{"src": "α : Type u_1,	_inst_1 : measurable_space α,	μ : measure α,	p : ℝ,	hp0_lt : 0 < p,	f g : α → ennreal,	hf : ae_measurable f μ,	hf_zero : ∫⁻ (a : α), f a ^ p ∂μ = 0	⊢ f * g =ᵐ[μ] 0 * g", "decl_nm": "ennreal.lintegral_mul_eq_zero_of_lintegral_rpow_eq_zero"
{"src": "2 goals	α : Type u_1,	_inst_1 : measurable_space α,	μ : measure α,	p : ℝ,	hp0_lt : 0 < p,	f g : α → ennreal,	hf : ae_measurable f μ,	hf_zero : ∫⁻ (a : α), f a ^ p ∂μ = 0	⊢ f =ᵐ[μ] 0		α : Type u_1,	_inst_1 : measurable_space α,	μ : measure α,	p : ℝ,	hp0_lt : 0 < p,	f g : α → ennreal,	hf : ae_measurable f μ,	hf_zero : ∫⁻ (a : α), f a ^ p ∂μ = 0,	hf_eq_zero : f =ᵐ[μ] 0	⊢ f * g =ᵐ[μ] 0 * g", "decl_nm": "ennreal.lintegral_mul_eq_zero_of_lintegral_rpow_eq_zero"
{"src": "α : Type u_1,	_inst_1 : measurable_space α,	μ : measure α,	p : ℝ,	hp0_lt : 0 < p,	f g : α → ennreal,	hf : ae_measurable f μ,	hf_zero : ∫⁻ (a : α), f a ^ p ∂μ = 0,	hf_eq_zero : f =ᵐ[μ] 0	⊢ f * g =ᵐ[μ] 0 * g", "decl_nm": "ennreal.lintegral_mul_eq_zero_of_lintegral_rpow_eq_zero"
{"src": "⊢ ∀ {α : Type u_1} {m : measurable_space α}, measurable_set univ", "decl_nm": "measurable_set.univ"
{"src": "α : Type u_1,	m : measurable_space α	⊢ measurable_set univ", "decl_nm": "measurable_set.univ"
{"src": "⊢ ∀ {G : Type u_1} [_inst_1 : group G] [_inst_2 : topological_space G] [_inst_3 : t2_space G]	  [_inst_4 : topological_group G] [_inst_5 : measurable_space G] [_inst_6 : borel_space G] {K₀ : positive_compacts G},	    ⇑(measure.haar_measure K₀) K₀.val = 1", "decl_nm": "measure_theory.measure.haar_measure_self"
{"src": "G : Type u_1,	_inst_1 : group G,	_inst_2 : topological_space G,	_inst_3 : t2_space G,	_inst_4 : topological_group G,	_inst_5 : measurable_space G,	_inst_6 : borel_space G,	K₀ : positive_compacts G	⊢ ⇑(measure.haar_measure K₀) K₀.val = 1", "decl_nm": "measure_theory.measure.haar_measure_self"
{"src": "G : Type u_1,	_inst_1 : group G,	_inst_2 : topological_space G,	_inst_3 : t2_space G,	_inst_4 : topological_group G,	_inst_5 : measurable_space G,	_inst_6 : borel_space G,	K₀ : positive_compacts G,	_inst : locally_compact_space G	⊢ ⇑(measure.haar_measure K₀) K₀.val = 1", "decl_nm": "measure_theory.measure.haar_measure_self"
{"src": "2 goals	G : Type u_1,	_inst_1 : group G,	_inst_2 : topological_space G,	_inst_3 : t2_space G,	_inst_4 : topological_group G,	_inst_5 : measurable_space G,	_inst_6 : borel_space G,	K₀ : positive_compacts G,	_inst : locally_compact_space G	⊢ ⇑((haar_content K₀).outer_measure) K₀.val ≠ 0		G : Type u_1,	_inst_1 : group G,	_inst_2 : topological_space G,	_inst_3 : t2_space G,	_inst_4 : topological_group G,	_inst_5 : measurable_space G,	_inst_6 : borel_space G,	K₀ : positive_compacts G,	_inst : locally_compact_space G	⊢ ⇑((haar_content K₀).outer_measure) K₀.val ≠ ⊤", "decl_nm": "measure_theory.measure.haar_measure_self"
{"src": "2 goals	G : Type u_1,	_inst_1 : group G,	_inst_2 : topological_space G,	_inst_3 : t2_space G,	_inst_4 : topological_group G,	_inst_5 : measurable_space G,	_inst_6 : borel_space G,	K₀ : positive_compacts G,	_inst : locally_compact_space G	⊢ 0 < ⇑((haar_content K₀).outer_measure) K₀.val		G : Type u_1,	_inst_1 : group G,	_inst_2 : topological_space G,	_inst_3 : t2_space G,	_inst_4 : topological_group G,	_inst_5 : measurable_space G,	_inst_6 : borel_space G,	K₀ : positive_compacts G,	_inst : locally_compact_space G	⊢ ⇑((haar_content K₀).outer_measure) K₀.val ≠ ⊤", "decl_nm": "measure_theory.measure.haar_measure_self"
{"src": "G : Type u_1,	_inst_1 : group G,	_inst_2 : topological_space G,	_inst_3 : t2_space G,	_inst_4 : topological_group G,	_inst_5 : measurable_space G,	_inst_6 : borel_space G,	K₀ : positive_compacts G,	_inst : locally_compact_space G	⊢ ⇑((haar_content K₀).outer_measure) K₀.val ≠ ⊤", "decl_nm": "measure_theory.measure.haar_measure_self"
{"src": "⊢ ∀ {X : Type u_2} [_inst_1 : emetric_space X] (m : set X → ennreal) (s : set X),	    tendsto (λ (r : ennreal), ⇑(outer_measure.mk_metric'.pre m r) s) (nhds_within 0 (Ioi 0))	      (nhds (⇑(outer_measure.mk_metric' m) s))", "decl_nm": "measure_theory.outer_measure.mk_metric'.tendsto_pre"
{"src": "X : Type u_2,	_inst_1 : emetric_space X,	m : set X → ennreal,	s : set X	⊢ tendsto (λ (r : ennreal), ⇑(outer_measure.mk_metric'.pre m r) s) (nhds_within 0 (Ioi 0))	    (nhds (⇑(outer_measure.mk_metric' m) s))", "decl_nm": "measure_theory.outer_measure.mk_metric'.tendsto_pre"
{"src": "X : Type u_2,	_inst_1 : emetric_space X,	m : set X → ennreal,	s : set X	⊢ tendsto ((λ (r : ennreal), ⇑(outer_measure.mk_metric'.pre m r) s) ∘ coe) at_bot	    (nhds (⇑(outer_measure.mk_metric' m) s))", "decl_nm": "measure_theory.outer_measure.mk_metric'.tendsto_pre"
{"src": "X : Type u_2,	_inst_1 : emetric_space X,	m : set X → ennreal,	s : set X	⊢ tendsto ((λ (r : ennreal), ⇑(outer_measure.mk_metric'.pre m r) s) ∘ coe) at_bot	    (nhds (⨆ (i : {i // i > 0}), ⇑(outer_measure.mk_metric'.pre m ↑i) s))", "decl_nm": "measure_theory.outer_measure.mk_metric'.tendsto_pre"
{"src": "⊢ ∀ {a : ℝ}, ⇑volume (Ici a) = ⊤", "decl_nm": "real.volume_Ici"
{"src": "a : ℝ	⊢ ⇑volume (Ici a) = ⊤", "decl_nm": "real.volume_Ici"
{"src": "⊢ ∀ {ι : Type u_1} [_inst_1 : fintype ι] (a : ι → ℝ) {r : ℝ},	    0 < r → ⇑volume (metric.ball a r) = ennreal.of_real ((2 * r) ^ fintype.card ι)", "decl_nm": "real.volume_pi_ball"
{"src": "ι : Type u_1,	_inst_1 : fintype ι,	a : ι → ℝ,	r : ℝ,	hr : 0 < r	⊢ ⇑volume (metric.ball a r) = ennreal.of_real ((2 * r) ^ fintype.card ι)", "decl_nm": "real.volume_pi_ball"
{"src": "ι : Type u_1,	_inst_1 : fintype ι,	a : ι → ℝ,	r : ℝ,	hr : 0 < r	⊢ ennreal.of_real (2 * r) ^ finset.univ.card = ennreal.of_real ((2 * r) ^ fintype.card ι)", "decl_nm": "real.volume_pi_ball"
{"src": "⊢ ∀ {α : Type u_1} {m : measurable_space α} {s : set α},	    s.countable → ∀ (μ : measure α) [_inst_4 : has_no_atoms μ], ⇑μ s = 0", "decl_nm": "set.countable.measure_zero"
{"src": "α : Type u_1,	m : measurable_space α,	s : set α,	h : s.countable,	μ : measure α,	_inst_4 : has_no_atoms μ	⊢ ⇑μ s = 0", "decl_nm": "set.countable.measure_zero"
{"src": "α : Type u_1,	m : measurable_space α,	s : set α,	h : s.countable,	μ : measure α,	_inst_4 : has_no_atoms μ	⊢ ⇑μ (⋃ (x : α) (H : x ∈ s), {x}) ≤ 0", "decl_nm": "set.countable.measure_zero"
{"src": "α : Type u_1,	m : measurable_space α,	s : set α,	h : s.countable,	μ : measure α,	_inst_4 : has_no_atoms μ	⊢ ∑' (p : ↥s), ⇑μ {↑p} ≤ 0", "decl_nm": "set.countable.measure_zero"
{"src": "⊢ ∀ {α : Type u_1} {β : Type u_2} [_inst_1 : measurable_space α] [_inst_2 : measurable_space β]	  {μ : measure α} (f : α ≃ᵐ β) (s : set β), ⇑(⇑(measure.map ⇑f) μ) s = ⇑μ (⇑f ⁻¹' s)", "decl_nm": "measurable_equiv.map_apply"
{"src": "α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	μ : measure α,	f : α ≃ᵐ β,	s : set β	⊢ ⇑(⇑(measure.map ⇑f) μ) s = ⇑μ (⇑f ⁻¹' s)", "decl_nm": "measurable_equiv.map_apply"
{"src": "α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	μ : measure α,	f : α ≃ᵐ β,	s : set β	⊢ ⇑(⇑(measure.map ⇑f) μ) s ≤ ⇑μ (⇑f ⁻¹' s)", "decl_nm": "measurable_equiv.map_apply"
{"src": "α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	μ : measure α,	f : α ≃ᵐ β,	s : set β	⊢ ⇑(⇑(measure.map ⇑f) μ) s ≤ ⨅ (t : {t // ⇑f ⁻¹' s ⊆ t ∧ measurable_set t}), ⇑μ ↑t", "decl_nm": "measurable_equiv.map_apply"
{"src": "α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	μ : measure α,	f : α ≃ᵐ β,	s : set β	⊢ ∀ (i : {t // ⇑f ⁻¹' s ⊆ t ∧ measurable_set t}), ⇑(⇑(measure.map ⇑f) μ) s ≤ ⇑μ ↑i", "decl_nm": "measurable_equiv.map_apply"
{"src": "α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	μ : measure α,	f : α ≃ᵐ β,	s : set β,	t : set α,	hst : ⇑f ⁻¹' s ⊆ t,	ht : measurable_set t	⊢ ⇑(⇑(measure.map ⇑f) μ) s ≤ ⇑μ ↑⟨t, _⟩", "decl_nm": "measurable_equiv.map_apply"
{"src": "α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	μ : measure α,	f : α ≃ᵐ β,	s : set β,	t : set α,	hst : ⇑f ⁻¹' s ⊆ t,	ht : measurable_set t	⊢ ⇑(⇑(measure.map ⇑f) μ) s ≤ ⇑μ t", "decl_nm": "measurable_equiv.map_apply"
{"src": "α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	μ : measure α,	f : α ≃ᵐ β,	s : set β,	t : set α,	hst : ⇑f ⁻¹' s ⊆ t,	ht : measurable_set t,	this : ⇑(f.symm) '' s = ⇑f ⁻¹' s	⊢ ⇑(⇑(measure.map ⇑f) μ) s ≤ ⇑μ t", "decl_nm": "measurable_equiv.map_apply"
{"src": "α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	μ : measure α,	f : α ≃ᵐ β,	s : set β,	t : set α,	ht : measurable_set t,	this : ⇑(f.symm) '' s = ⇑f ⁻¹' s,	hst : s ⊆ ⇑(f.symm) ⁻¹' t	⊢ ⇑(⇑(measure.map ⇑f) μ) s ≤ ⇑μ t", "decl_nm": "measurable_equiv.map_apply"
{"src": "α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	μ : measure α,	f : α ≃ᵐ β,	s : set β,	t : set α,	ht : measurable_set t,	this : ⇑(f.symm) '' s = ⇑f ⁻¹' s,	hst : s ⊆ ⇑(f.symm) ⁻¹' t	⊢ ⇑μ t = ⇑(⇑(measure.map ⇑f) μ) (⇑(f.symm) ⁻¹' t)", "decl_nm": "measurable_equiv.map_apply"
{"src": "3 goals	α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	μ : measure α,	f : α ≃ᵐ β,	s : set β,	t : set α,	ht : measurable_set t,	this : ⇑(f.symm) '' s = ⇑f ⁻¹' s,	hst : s ⊆ ⇑(f.symm) ⁻¹' t	⊢ ⇑μ t = ⇑μ ((λ (x : α), ⇑(f.symm) (⇑f x)) ⁻¹' t)		α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	μ : measure α,	f : α ≃ᵐ β,	s : set β,	t : set α,	ht : measurable_set t,	this : ⇑(f.symm) '' s = ⇑f ⁻¹' s,	hst : s ⊆ ⇑(f.symm) ⁻¹' t	⊢ measurable ⇑f		α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	μ : measure α,	f : α ≃ᵐ β,	s : set β,	t : set α,	ht : measurable_set t,	this : ⇑(f.symm) '' s = ⇑f ⁻¹' s,	hst : s ⊆ ⇑(f.symm) ⁻¹' t	⊢ measurable_set (⇑(f.symm) ⁻¹' t)", "decl_nm": "measurable_equiv.map_apply"
{"src": "3 goals	α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	μ : measure α,	f : α ≃ᵐ β,	s : set β,	t : set α,	ht : measurable_set t,	this : ⇑(f.symm) '' s = ⇑f ⁻¹' s,	hst : s ⊆ ⇑(f.symm) ⁻¹' t	⊢ (λ (x : α), ⇑(f.symm) (⇑f x)) ⁻¹' t = t		α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	μ : measure α,	f : α ≃ᵐ β,	s : set β,	t : set α,	ht : measurable_set t,	this : ⇑(f.symm) '' s = ⇑f ⁻¹' s,	hst : s ⊆ ⇑(f.symm) ⁻¹' t	⊢ measurable ⇑f		α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	μ : measure α,	f : α ≃ᵐ β,	s : set β,	t : set α,	ht : measurable_set t,	this : ⇑(f.symm) '' s = ⇑f ⁻¹' s,	hst : s ⊆ ⇑(f.symm) ⁻¹' t	⊢ measurable_set (⇑(f.symm) ⁻¹' t)", "decl_nm": "measurable_equiv.map_apply"
{"src": "3 goals	α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	μ : measure α,	f : α ≃ᵐ β,	s : set β,	t : set α,	ht : measurable_set t,	this : ⇑(f.symm) '' s = ⇑f ⁻¹' s,	hst : s ⊆ ⇑(f.symm) ⁻¹' t	⊢ (λ (x : α), ⇑(f.symm) (⇑f x)) = id		α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	μ : measure α,	f : α ≃ᵐ β,	s : set β,	t : set α,	ht : measurable_set t,	this : ⇑(f.symm) '' s = ⇑f ⁻¹' s,	hst : s ⊆ ⇑(f.symm) ⁻¹' t	⊢ measurable ⇑f		α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	μ : measure α,	f : α ≃ᵐ β,	s : set β,	t : set α,	ht : measurable_set t,	this : ⇑(f.symm) '' s = ⇑f ⁻¹' s,	hst : s ⊆ ⇑(f.symm) ⁻¹' t	⊢ measurable_set (⇑(f.symm) ⁻¹' t)", "decl_nm": "measurable_equiv.map_apply"
{"src": "2 goals	α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	μ : measure α,	f : α ≃ᵐ β,	s : set β,	t : set α,	ht : measurable_set t,	this : ⇑(f.symm) '' s = ⇑f ⁻¹' s,	hst : s ⊆ ⇑(f.symm) ⁻¹' t	⊢ measurable ⇑f		α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	μ : measure α,	f : α ≃ᵐ β,	s : set β,	t : set α,	ht : measurable_set t,	this : ⇑(f.symm) '' s = ⇑f ⁻¹' s,	hst : s ⊆ ⇑(f.symm) ⁻¹' t	⊢ measurable_set (⇑(f.symm) ⁻¹' t)", "decl_nm": "measurable_equiv.map_apply"
{"src": "⊢ ∀ {α : Type u_1} {β : Type u_2} [_inst_1 : measurable_space α] [_inst_2 : measurable_space β]	  {μ : measure α} {ν : measure β} (e : α ≃ᵐ β),	    ⇑(measure.map ⇑e) μ = ν ↔ ⇑(measure.map ⇑(e.symm)) ν = μ", "decl_nm": "measurable_equiv.map_apply_eq_iff_map_symm_apply_eq"
{"src": "α : Type u_1,	β : Type u_2,	_inst_1 : measurable_space α,	_inst_2 : measurable_space β,	μ : measure α,	ν : measure β,	e : α ≃ᵐ β	⊢ ⇑(measure.map ⇑e) μ = ν ↔ ⇑(measure.map ⇑(e.symm)) ν = μ", "decl_nm": "measurable_equiv.map_apply_eq_iff_map_symm_apply_eq"
{"src": "⊢ ∀ {α : Type u_1} {ι : Type u_5} {m : measurable_space α} (μ : measure α) {s : ι → set α},	    (∀ (i : ι), measurable_set (s i)) →	    ⇑μ univ < ∑' (i : ι), ⇑μ (s i) → (∃ (i j : ι) (h : i ≠ j), (s i ∩ s j).nonempty)", "decl_nm": "measure_theory.exists_nonempty_inter_of_measure_univ_lt_tsum_measure"
{"src": "α : Type u_1,	ι : Type u_5,	m : measurable_space α,	μ : measure α,	s : ι → set α,	hs : ∀ (i : ι), measurable_set (s i),	H : ⇑μ univ < ∑' (i : ι), ⇑μ (s i)	⊢ ∃ (i j : ι) (h : i ≠ j), (s i ∩ s j).nonempty", "decl_nm": "measure_theory.exists_nonempty_inter_of_measure_univ_lt_tsum_measure"
{"src": "α : Type u_1,	ι : Type u_5,	m : measurable_space α,	μ : measure α,	s : ι → set α,	hs : ∀ (i : ι), measurable_set (s i),	H : ∀ (i j : ι), i ≠ j → ¬(s i ∩ s j).nonempty	⊢ ∑' (i : ι), ⇑μ (s i) ≤ ⇑μ univ", "decl_nm": "measure_theory.exists_nonempty_inter_of_measure_univ_lt_tsum_measure"
{"src": "α : Type u_1,	ι : Type u_5,	m : measurable_space α,	μ : measure α,	s : ι → set α,	hs : ∀ (i : ι), measurable_set (s i),	H : ∀ (i j : ι), i ≠ j → ¬(s i ∩ s j).nonempty	⊢ pairwise (disjoint on λ (i : ι), s i)", "decl_nm": "measure_theory.exists_nonempty_inter_of_measure_univ_lt_tsum_measure"
{"src": "⊢ ∀ {α : Type u_1} [_inst_1 : measurable_space α] (μ : measure α) (s : set α),	    ∃ (t : set α), s ⊆ t ∧ measurable_set t ∧ ⇑μ t = ⇑μ s", "decl_nm": "measure_theory.exists_measurable_superset"
{"src": "α : Type u_1,	_inst_1 : measurable_space α,	μ : measure α,	s : set α	⊢ ∃ (t : set α), s ⊆ t ∧ measurable_set t ∧ ⇑μ t = ⇑μ s", "decl_nm": "measure_theory.exists_measurable_superset"
{"src": "⊢ ∀ {α : Type u_1} [_inst_1 : measurable_space α] {μ : measure α} {s t : set α},	    ⇑μ (s ∪ t) < ⊤ ↔ ⇑μ s < ⊤ ∧ ⇑μ t < ⊤", "decl_nm": "measure_theory.measure_union_lt_top_iff"
{"src": "α : Type u_1,	_inst_1 : measurable_space α,	μ : measure α,	s t : set α	⊢ ⇑μ (s ∪ t) < ⊤ ↔ ⇑μ s < ⊤ ∧ ⇑μ t < ⊤", "decl_nm": "measure_theory.measure_union_lt_top_iff"
{"src": "2 goals	α : Type u_1,	_inst_1 : measurable_space α,	μ : measure α,	s t : set α,	h : ⇑μ (s ∪ t) < ⊤	⊢ ⇑μ s < ⊤		α : Type u_1,	_inst_1 : measurable_space α,	μ : measure α,	s t : set α,	h : ⇑μ (s ∪ t) < ⊤	⊢ ⇑μ t < ⊤", "decl_nm": "measure_theory.measure_union_lt_top_iff"
{"src": "α : Type u_1,	_inst_1 : measurable_space α,	μ : measure α,	s t : set α,	h : ⇑μ (s ∪ t) < ⊤	⊢ ⇑μ t < ⊤", "decl_nm": "measure_theory.measure_union_lt_top_iff"
{"src": "⊢ ∀ {α : Type u_1} {m : measurable_space α} {μ : measure α} {p q q' : set α → Prop},	    μ.inner_regular p q → μ.inner_regular q q' → μ.inner_regular p q'", "decl_nm": "measure_theory.measure.inner_regular.trans"
{"src": "α : Type u_1,	m : measurable_space α,	μ : measure α,	p q q' : set α → Prop,	H : μ.inner_regular p q,	H' : μ.inner_regular q q'	⊢ μ.inner_regular p q'", "decl_nm": "measure_theory.measure.inner_regular.trans"
{"src": "α : Type u_1,	m : measurable_space α,	μ : measure α,	p q q' : set α → Prop,	H : μ.inner_regular p q,	H' : μ.inner_regular q q',	U : set α,	hU : q' U,	r : ennreal,	hr : r < ⇑μ U	⊢ ∃ (K : set α) (H : K ⊆ U), p K ∧ r < ⇑μ K", "decl_nm": "measure_theory.measure.inner_regular.trans"
{"src": "α : Type u_1,	m : measurable_space α,	μ : measure α,	p q q' : set α → Prop,	H : μ.inner_regular p q,	H' : μ.inner_regular q q',	U : set α,	hU : q' U,	r : ennreal,	hr : r < ⇑μ U,	F : set α,	hFU : F ⊆ U,	hqF : q F,	hF : r < ⇑μ F	⊢ ∃ (K : set α) (H : K ⊆ U), p K ∧ r < ⇑μ K", "decl_nm": "measure_theory.measure.inner_regular.trans"
{"src": "α : Type u_1,	m : measurable_space α,	μ : measure α,	p q q' : set α → Prop,	H : μ.inner_regular p q,	H' : μ.inner_regular q q',	U : set α,	hU : q' U,	r : ennreal,	hr : r < ⇑μ U,	F : set α,	hFU : F ⊆ U,	hqF : q F,	hF : r < ⇑μ F,	K : set α,	hKF : K ⊆ F,	hpK : p K,	hrK : r < ⇑μ K	⊢ ∃ (K : set α) (H : K ⊆ U), p K ∧ r < ⇑μ K", "decl_nm": "measure_theory.measure.inner_regular.trans"
{"src": "⊢ ∀ (f : stieltjes_function) (a b : ℝ), ⇑(f.measure) (Ioc a b) = ennreal.of_real (⇑f b - ⇑f a)", "decl_nm": "stieltjes_function.measure_Ioc"
{"src": "f : stieltjes_function,	a b : ℝ	⊢ ⇑(f.measure) (Ioc a b) = ennreal.of_real (⇑f b - ⇑f a)", "decl_nm": "stieltjes_function.measure_Ioc"
{"src": "f : stieltjes_function,	a b : ℝ	⊢ ⇑{to_outer_measure := f.outer, m_Union := _, trimmed := _} (Ioc a b) = ennreal.of_real (⇑f b - ⇑f a)", "decl_nm": "stieltjes_function.measure_Ioc"
{"src": "⊢ ∀ {α : Type u_1} {m : measurable_space α} (s : signed_measure α)	  (hs : 0.restrict univ ≤ vector_measure.restrict s univ),	    (s.to_measure_of_zero_le univ measurable_set.univ hs).to_signed_measure = s", "decl_nm": "measure_theory.signed_measure.to_measure_of_zero_le_to_signed_measure"
{"src": "α : Type u_1,	m : measurable_space α,	s : signed_measure α,	hs : 0.restrict univ ≤ vector_measure.restrict s univ	⊢ (s.to_measure_of_zero_le univ measurable_set.univ hs).to_signed_measure = s", "decl_nm": "measure_theory.signed_measure.to_measure_of_zero_le_to_signed_measure"
{"src": "α : Type u_1,	m : measurable_space α,	s : signed_measure α,	hs : 0.restrict univ ≤ vector_measure.restrict s univ,	i : set α,	hi : measurable_set i	⊢ ⇑((s.to_measure_of_zero_le univ measurable_set.univ hs).to_signed_measure) i = ⇑s i", "decl_nm": "measure_theory.signed_measure.to_measure_of_zero_le_to_signed_measure"
{"src": "⊢ ∀ {α : Type u_1} {m : measurable_space α} (s : signed_measure α)	  (hs : vector_measure.restrict s univ ≤ 0.restrict univ),	    (s.to_measure_of_le_zero univ measurable_set.univ hs).to_signed_measure = -s", "decl_nm": "measure_theory.signed_measure.to_measure_of_le_zero_to_signed_measure"
{"src": "α : Type u_1,	m : measurable_space α,	s : signed_measure α,	hs : vector_measure.restrict s univ ≤ 0.restrict univ	⊢ (s.to_measure_of_le_zero univ measurable_set.univ hs).to_signed_measure = -s", "decl_nm": "measure_theory.signed_measure.to_measure_of_le_zero_to_signed_measure"
{"src": "α : Type u_1,	m : measurable_space α,	s : signed_measure α,	hs : vector_measure.restrict s univ ≤ 0.restrict univ,	i : set α,	hi : measurable_set i	⊢ ⇑((s.to_measure_of_le_zero univ measurable_set.univ hs).to_signed_measure) i = (⇑-s) i", "decl_nm": "measure_theory.signed_measure.to_measure_of_le_zero_to_signed_measure"
{"src": "⊢ ∀ {α : Type u_1} {m : measurable_space α} {μ : measure α} {E : Type u_3} [_inst_1 : normed_group E]	  [_inst_2 : measurable_space E] [_inst_3 : second_countable_topology E] [_inst_4 : normed_space ℝ E]	  [_inst_5 : complete_space E] [_inst_6 : borel_space E] {f g : α → E},	    integrable f μ → integrable g μ → μ.with_densityᵥ f = μ.with_densityᵥ g → f =ᵐ[μ] g", "decl_nm": "measure_theory.integrable.ae_eq_of_with_densityᵥ_eq"
{"src": "α : Type u_1,	m : measurable_space α,	μ : measure α,	E : Type u_3,	_inst_1 : normed_group E,	_inst_2 : measurable_space E,	_inst_3 : second_countable_topology E,	_inst_4 : normed_space ℝ E,	_inst_5 : complete_space E,	_inst_6 : borel_space E,	f g : α → E,	hf : integrable f μ,	hg : integrable g μ,	hfg : μ.with_densityᵥ f = μ.with_densityᵥ g	⊢ f =ᵐ[μ] g", "decl_nm": "measure_theory.integrable.ae_eq_of_with_densityᵥ_eq"
{"src": "α : Type u_1,	m : measurable_space α,	μ : measure α,	E : Type u_3,	_inst_1 : normed_group E,	_inst_2 : measurable_space E,	_inst_3 : second_countable_topology E,	_inst_4 : normed_space ℝ E,	_inst_5 : complete_space E,	_inst_6 : borel_space E,	f g : α → E,	hf : integrable f μ,	hg : integrable g μ,	hfg : μ.with_densityᵥ f = μ.with_densityᵥ g,	i : set α,	hi : measurable_set i,	_x : ⇑μ i < ⊤	⊢ ∫ (x : α) in i, f x ∂μ = ∫ (x : α) in i, g x ∂μ", "decl_nm": "measure_theory.integrable.ae_eq_of_with_densityᵥ_eq"
{"src": "⊢ ∀ {L : language} {M : Type u_1} {N : Type u_2} [_inst_1 : L.Structure M] [_inst_2 : L.Structure N]	  [_inst_5 : L.is_algebraic] {f : L.hom M N} (hf : function.injective ⇑f),	    (language.embedding.of_injective hf).to_hom = f", "decl_nm": "first_order.language.embedding.of_injective_to_hom"
{"src": "L : language,	M : Type u_1,	N : Type u_2,	_inst_1 : L.Structure M,	_inst_2 : L.Structure N,	_inst_5 : L.is_algebraic,	f : L.hom M N,	hf : function.injective ⇑f	⊢ (language.embedding.of_injective hf).to_hom = f", "decl_nm": "first_order.language.embedding.of_injective_to_hom"
{"src": "L : language,	M : Type u_1,	N : Type u_2,	_inst_1 : L.Structure M,	_inst_2 : L.Structure N,	_inst_5 : L.is_algebraic,	f : L.hom M N,	hf : function.injective ⇑f,	x : M	⊢ ⇑((language.embedding.of_injective hf).to_hom) x = ⇑f x", "decl_nm": "first_order.language.embedding.of_injective_to_hom"
{"src": "⊢ bernoulli 1 = (-1) / 2", "decl_nm": "bernoulli_one"
{"src": "⊢ ∀ (n : ℕ), bernoulli' n = 1 - (range n).sum (λ (k : ℕ), ↑(n.choose k) / (↑n - ↑k + 1) * bernoulli' k)", "decl_nm": "bernoulli'_def"
{"src": "n : ℕ	⊢ bernoulli' n = 1 - (range n).sum (λ (k : ℕ), ↑(n.choose k) / (↑n - ↑k + 1) * bernoulli' k)", "decl_nm": "bernoulli'_def"
{"src": "n : ℕ	⊢ 1 - univ.sum (λ (k : fin n), ↑(n.choose ↑k) / (↑n - ↑k + 1) * bernoulli' ↑k) =	    1 - univ.sum (λ (i : fin n), ↑(n.choose ↑i) / (↑n - ↑↑i + 1) * bernoulli' ↑i)", "decl_nm": "bernoulli'_def"
{"src": "⊢ bernoulli' 0 = 1", "decl_nm": "bernoulli'_zero"
{"src": "⊢ 1 - (range 0).sum (λ (k : ℕ), ↑(0.choose k) / (↑0 - ↑k + 1) * bernoulli' k) = 1", "decl_nm": "bernoulli'_zero"
{"src": "⊢ ∀ {n m : ℕ}, n ≠ 0 → m ∣ n → m ≠ n → m.divisors ⊆ n.proper_divisors", "decl_nm": "nat.divisors_subset_proper_divisors"
{"src": "n m : ℕ,	hzero : n ≠ 0,	h : m ∣ n,	hdiff : m ≠ n	⊢ m.divisors ⊆ n.proper_divisors", "decl_nm": "nat.divisors_subset_proper_divisors"
{"src": "n m : ℕ,	hzero : n ≠ 0,	h : m ∣ n,	hdiff : m ≠ n	⊢ ∀ ⦃x : ℕ⦄, x ∈ m.divisors → x ∈ n.proper_divisors", "decl_nm": "nat.divisors_subset_proper_divisors"
{"src": "n m : ℕ,	hzero : n ≠ 0,	h : m ∣ n,	hdiff : m ≠ n,	x : ℕ,	hx : x ∈ m.divisors	⊢ x ∈ n.proper_divisors", "decl_nm": "nat.divisors_subset_proper_divisors"
{"src": "⊢ 0.divisors_antidiagonal = ∅", "decl_nm": "nat.divisors_antidiagonal_zero"
{"src": "a : ℕ × ℕ	⊢ a ∈ 0.divisors_antidiagonal ↔ a ∈ ∅", "decl_nm": "nat.divisors_antidiagonal_zero"
{"src": "⊢ ∀ (p : ℕ), padic_norm p 1 = 1", "decl_nm": "padic_norm.one"
{"src": "p : ℕ	⊢ padic_norm p 1 = 1", "decl_nm": "padic_norm.one"
{"src": "⊢ ∀ (p : ℕ) {q : ℚ}, q ≠ 0 → (∃ (z : ℤ), padic_norm p q = ↑p ^ -z)", "decl_nm": "padic_norm.values_discrete"
{"src": "p : ℕ,	q : ℚ,	hq : q ≠ 0	⊢ ∃ (z : ℤ), padic_norm p q = ↑p ^ -z", "decl_nm": "padic_norm.values_discrete"
{"src": "⊢ ∀ {p : ℕ} [hp : fact (prime p)] (q r : ℚ_[p]), ∥q + r∥ ≤ max ∥q∥ ∥r∥", "decl_nm": "padic_norm_e.nonarchimedean"
{"src": "p : ℕ,	hp : fact (prime p),	q r : ℚ_[p]	⊢ ∥q + r∥ ≤ max ∥q∥ ∥r∥", "decl_nm": "padic_norm_e.nonarchimedean"
{"src": "p : ℕ,	hp : fact (prime p),	q r : ℚ_[p]	⊢ ↑(padic_norm_e (q + r)) ≤ max ↑(padic_norm_e q) ↑(padic_norm_e r)", "decl_nm": "padic_norm_e.nonarchimedean"
{"src": "⊢ ∀ {a : ℕ} (a1 : 1 < a) (n : ℕ), pell_zd a1 (n + 1) = pell_zd a1 n * {re := ↑a, im := 1}", "decl_nm": "pell.pell_zd_succ"
{"src": "a : ℕ,	a1 : 1 < a,	n : ℕ	⊢ pell_zd a1 (n + 1) = pell_zd a1 n * {re := ↑a, im := 1}", "decl_nm": "pell.pell_zd_succ"
{"src": "⊢ ∀ {x y z : ℤ} (h : pythagorean_triple x y z), _.is_primitive_classified → h.is_classified", "decl_nm": "pythagorean_triple.is_classified_of_normalize_is_primitive_classified"
{"src": "x y z : ℤ,	h : pythagorean_triple x y z,	hc : _.is_primitive_classified	⊢ h.is_classified", "decl_nm": "pythagorean_triple.is_classified_of_normalize_is_primitive_classified"
{"src": "3 goals	x y z : ℤ,	h : pythagorean_triple x y z,	hc : _.is_primitive_classified	⊢ x = ↑(x.gcd y) * (x / ↑(x.gcd y))		x y z : ℤ,	h : pythagorean_triple x y z,	hc : _.is_primitive_classified	⊢ y = ↑(x.gcd y) * (y / ↑(x.gcd y))		x y z : ℤ,	h : pythagorean_triple x y z,	hc : _.is_primitive_classified	⊢ z = ↑(x.gcd y) * (z / ↑(x.gcd y))", "decl_nm": "pythagorean_triple.is_classified_of_normalize_is_primitive_classified"
{"src": "3 goals	x y z : ℤ,	h : pythagorean_triple x y z,	hc : _.is_primitive_classified	⊢ ↑(x.gcd y) ∣ x		x y z : ℤ,	h : pythagorean_triple x y z,	hc : _.is_primitive_classified	⊢ y = ↑(x.gcd y) * (y / ↑(x.gcd y))		x y z : ℤ,	h : pythagorean_triple x y z,	hc : _.is_primitive_classified	⊢ z = ↑(x.gcd y) * (z / ↑(x.gcd y))", "decl_nm": "pythagorean_triple.is_classified_of_normalize_is_primitive_classified"
{"src": "2 goals	x y z : ℤ,	h : pythagorean_triple x y z,	hc : _.is_primitive_classified	⊢ y = ↑(x.gcd y) * (y / ↑(x.gcd y))		x y z : ℤ,	h : pythagorean_triple x y z,	hc : _.is_primitive_classified	⊢ z = ↑(x.gcd y) * (z / ↑(x.gcd y))", "decl_nm": "pythagorean_triple.is_classified_of_normalize_is_primitive_classified"
{"src": "2 goals	x y z : ℤ,	h : pythagorean_triple x y z,	hc : _.is_primitive_classified	⊢ ↑(x.gcd y) ∣ y		x y z : ℤ,	h : pythagorean_triple x y z,	hc : _.is_primitive_classified	⊢ z = ↑(x.gcd y) * (z / ↑(x.gcd y))", "decl_nm": "pythagorean_triple.is_classified_of_normalize_is_primitive_classified"
{"src": "x y z : ℤ,	h : pythagorean_triple x y z,	hc : _.is_primitive_classified	⊢ z = ↑(x.gcd y) * (z / ↑(x.gcd y))", "decl_nm": "pythagorean_triple.is_classified_of_normalize_is_primitive_classified"
{"src": "x y z : ℤ,	h : pythagorean_triple x y z,	hc : _.is_primitive_classified	⊢ ↑(x.gcd y) ∣ z", "decl_nm": "pythagorean_triple.is_classified_of_normalize_is_primitive_classified"
{"src": "⊢ ∀ {x y z : ℤ}, pythagorean_triple x y z → x.gcd y = 1 → z ≠ 0", "decl_nm": "pythagorean_triple.ne_zero_of_coprime"
{"src": "x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1	⊢ z ≠ 0", "decl_nm": "pythagorean_triple.ne_zero_of_coprime"
{"src": "2 goals	x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1,	this : 0 < z * z	⊢ z ≠ 0		x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1	⊢ 0 < z * z", "decl_nm": "pythagorean_triple.ne_zero_of_coprime"
{"src": "2 goals	x y : ℤ,	hc : x.gcd y = 1,	h : pythagorean_triple x y 0,	this : 0 < 0 * 0	⊢ false		x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1	⊢ 0 < z * z", "decl_nm": "pythagorean_triple.ne_zero_of_coprime"
{"src": "x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1	⊢ 0 < z * z", "decl_nm": "pythagorean_triple.ne_zero_of_coprime"
{"src": "x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1	⊢ 0 < x ^ 2 + y ^ 2", "decl_nm": "pythagorean_triple.ne_zero_of_coprime"
{"src": "2 goals	x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1	⊢ x.gcd y ≠ 0		x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1,	hc' : x.gcd y ≠ 0	⊢ 0 < x ^ 2 + y ^ 2", "decl_nm": "pythagorean_triple.ne_zero_of_coprime"
{"src": "2 goals	x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1	⊢ 1 ≠ 0		x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1,	hc' : x.gcd y ≠ 0	⊢ 0 < x ^ 2 + y ^ 2", "decl_nm": "pythagorean_triple.ne_zero_of_coprime"
{"src": "x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1,	hc' : x.gcd y ≠ 0	⊢ 0 < x ^ 2 + y ^ 2", "decl_nm": "pythagorean_triple.ne_zero_of_coprime"
{"src": "2 goals	case or.inl	x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1,	hc' : x.gcd y ≠ 0,	hxz : x ≠ 0	⊢ 0 < x ^ 2 + y ^ 2		case or.inr	x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1,	hc' : x.gcd y ≠ 0,	hyz : y ≠ 0	⊢ 0 < x ^ 2 + y ^ 2", "decl_nm": "pythagorean_triple.ne_zero_of_coprime"
{"src": "case or.inr	x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1,	hc' : x.gcd y ≠ 0,	hyz : y ≠ 0	⊢ 0 < x ^ 2 + y ^ 2", "decl_nm": "pythagorean_triple.ne_zero_of_coprime"
{"src": "⊢ ∀ {x y z : ℤ}, pythagorean_triple x y z → x.gcd y = 1 → y.gcd z = 1", "decl_nm": "pythagorean_triple.coprime_of_coprime"
{"src": "x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1	⊢ y.gcd z = 1", "decl_nm": "pythagorean_triple.coprime_of_coprime"
{"src": "x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1,	H : ¬y.gcd z = 1	⊢ false", "decl_nm": "pythagorean_triple.coprime_of_coprime"
{"src": "x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1,	H : ¬y.gcd z = 1,	p : ℕ,	hp : nat.prime p,	hpy : p ∣ y.nat_abs,	hpz : p ∣ z.nat_abs	⊢ false", "decl_nm": "pythagorean_triple.coprime_of_coprime"
{"src": "x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1,	H : ¬y.gcd z = 1,	p : ℕ,	hp : nat.prime p,	hpy : p ∣ y.nat_abs,	hpz : p ∣ z.nat_abs	⊢ p ∣ 1", "decl_nm": "pythagorean_triple.coprime_of_coprime"
{"src": "x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1,	H : ¬y.gcd z = 1,	p : ℕ,	hp : nat.prime p,	hpy : p ∣ y.nat_abs,	hpz : p ∣ z.nat_abs	⊢ p ∣ x.gcd y", "decl_nm": "pythagorean_triple.coprime_of_coprime"
{"src": "x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1,	H : ¬y.gcd z = 1,	p : ℕ,	hp : nat.prime p,	hpy : p ∣ y.nat_abs,	hpz : p ∣ z.nat_abs	⊢ ↑p ∣ x ^ 2", "decl_nm": "pythagorean_triple.coprime_of_coprime"
{"src": "x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1,	H : ¬y.gcd z = 1,	p : ℕ,	hp : nat.prime p,	hpy : p ∣ y.nat_abs,	hpz : p ∣ z.nat_abs	⊢ ↑p ∣ z * z - y * y", "decl_nm": "pythagorean_triple.coprime_of_coprime"
{"src": "x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1,	H : ¬y.gcd z = 1,	p : ℕ,	hp : nat.prime p,	hpz : ↑p ∣ z,	hpy : ↑p ∣ y	⊢ ↑p ∣ z * z - y * y", "decl_nm": "pythagorean_triple.coprime_of_coprime"
{"src": "⊢ ∀ {x y z : ℤ} (h : pythagorean_triple x y z), x.gcd y = 1 → 0 < z → h.is_primitive_classified", "decl_nm": "pythagorean_triple.is_primitive_classified_of_coprime_of_pos"
{"src": "x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1,	hzpos : 0 < z	⊢ h.is_primitive_classified", "decl_nm": "pythagorean_triple.is_primitive_classified_of_coprime_of_pos"
{"src": "2 goals	case or.inl	x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1,	hzpos : 0 < z,	h1 : x % 2 = 0 ∧ y % 2 = 1	⊢ h.is_primitive_classified		case or.inr	x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1,	hzpos : 0 < z,	h2 : x % 2 = 1 ∧ y % 2 = 0	⊢ h.is_primitive_classified", "decl_nm": "pythagorean_triple.is_primitive_classified_of_coprime_of_pos"
{"src": "case or.inr	x y z : ℤ,	h : pythagorean_triple x y z,	hc : x.gcd y = 1,	hzpos : 0 < z,	h2 : x % 2 = 1 ∧ y % 2 = 0	⊢ h.is_primitive_classified", "decl_nm": "pythagorean_triple.is_primitive_classified_of_coprime_of_pos"
{"src": "case or.inr	x y z : ℤ,	h : pythagorean_triple x y z,	hzpos : 0 < z,	h2 : x % 2 = 1 ∧ y % 2 = 0,	hc : y.gcd x = 1	⊢ h.is_primitive_classified", "decl_nm": "pythagorean_triple.is_primitive_classified_of_coprime_of_pos"
{"src": "x y z : ℤ,	h : pythagorean_triple x y z,	hzpos : 0 < z,	h2 : x % 2 = 1 ∧ y % 2 = 0,	hc : y.gcd x = 1,	m n : ℤ,	H :	  (y = m ^ 2 - n ^ 2 ∧ x = 2 * m * n ∨ y = 2 * m * n ∧ x = m ^ 2 - n ^ 2) ∧	    m.gcd n = 1 ∧ (m % 2 = 0 ∧ n % 2 = 1 ∨ m % 2 = 1 ∧ n % 2 = 0)	⊢ h.is_primitive_classified", "decl_nm": "pythagorean_triple.is_primitive_classified_of_coprime_of_pos"
{"src": "x y z : ℤ,	h : pythagorean_triple x y z,	hzpos : 0 < z,	h2 : x % 2 = 1 ∧ y % 2 = 0,	hc : y.gcd x = 1,	m n : ℤ,	H :	  (y = m ^ 2 - n ^ 2 ∧ x = 2 * m * n ∨ y = 2 * m * n ∧ x = m ^ 2 - n ^ 2) ∧	    m.gcd n = 1 ∧ (m % 2 = 0 ∧ n % 2 = 1 ∨ m % 2 = 1 ∧ n % 2 = 0)	⊢ (x = m ^ 2 - n ^ 2 ∧ y = 2 * m * n ∨ x = 2 * m * n ∧ y = m ^ 2 - n ^ 2) ∧	    m.gcd n = 1 ∧ (m % 2 = 0 ∧ n % 2 = 1 ∨ m % 2 = 1 ∧ n % 2 = 0)", "decl_nm": "pythagorean_triple.is_primitive_classified_of_coprime_of_pos"
{"src": "⊢ ∀ {d : ℤ} (n : ℕ), ↑n = {re := ↑n, im := 0}", "decl_nm": "zsqrtd.coe_nat_val"
{"src": "d : ℤ,	n : ℕ	⊢ ↑n = {re := ↑n, im := 0}", "decl_nm": "zsqrtd.coe_nat_val"
{"src": "⊢ ∀ {d x y : ℤ}, {re := x, im := y} * {re := x, im := y}.conj = ↑x * ↑x - ↑d * ↑y * ↑y", "decl_nm": "zsqrtd.mul_conj"
{"src": "d x y : ℤ	⊢ {re := x, im := y} * {re := x, im := y}.conj = ↑x * ↑x - ↑d * ↑y * ↑y", "decl_nm": "zsqrtd.mul_conj"
{"src": "⊢ ∀ (x : gaussian_int), ↑x = {re := ↑(x.re), im := ↑(x.im)}", "decl_nm": "gaussian_int.to_complex_def₂"
{"src": "x : gaussian_int	⊢ ↑x = {re := ↑(x.re), im := ↑(x.im)}", "decl_nm": "gaussian_int.to_complex_def₂"
{"src": "2 goals	x : gaussian_int	⊢ ↑x.re = {re := ↑(x.re), im := ↑(x.im)}.re		x : gaussian_int	⊢ ↑x.im = {re := ↑(x.re), im := ↑(x.im)}.im", "decl_nm": "gaussian_int.to_complex_def₂"
{"src": "x : gaussian_int	⊢ ↑x.im = {re := ↑(x.re), im := ↑(x.im)}.im", "decl_nm": "gaussian_int.to_complex_def₂"
{"src": "⊢ ∀ {α : Type u} {x y : α} [_inst_1 : boolean_algebra α], x \ yᶜ = x ⊓ y", "decl_nm": "sdiff_compl"
{"src": "α : Type u,	x y : α,	_inst_1 : boolean_algebra α	⊢ x \ yᶜ = x ⊓ y", "decl_nm": "sdiff_compl"
{"src": "⊢ ∀ {α : Type u} [_inst_1 : distrib_lattice α] [_inst_2 : order_bot α] {a b c : α},	    disjoint a (b ⊔ c) ↔ disjoint a b ∧ disjoint a c", "decl_nm": "disjoint_sup_right"
{"src": "α : Type u,	_inst_1 : distrib_lattice α,	_inst_2 : order_bot α,	a b c : α	⊢ disjoint a (b ⊔ c) ↔ disjoint a b ∧ disjoint a c", "decl_nm": "disjoint_sup_right"
{"src": "⊢ ∀ {α : Type u} [_inst_1 : preorder α] [_inst_3 : no_max_order α], ¬bdd_above univ", "decl_nm": "not_bdd_above_univ"
{"src": "α : Type u,	_inst_1 : preorder α,	_inst_3 : no_max_order α	⊢ ¬bdd_above univ", "decl_nm": "not_bdd_above_univ"
{"src": "⊢ ∀ {α : Type u_1} [_inst_1 : complete_lattice α] {s : set (set α)},	    Sup (⋃₀ s) = ⨆ (t : set α) (H : t ∈ s), Sup t", "decl_nm": "Sup_sUnion"
{"src": "α : Type u_1,	_inst_1 : complete_lattice α,	s : set (set α)	⊢ Sup (⋃₀ s) = ⨆ (t : set α) (H : t ∈ s), Sup t", "decl_nm": "Sup_sUnion"
{"src": "2 goals	α : Type u_1,	_inst_1 : complete_lattice α,	s : set (set α)	⊢ Sup (⋃₀ s) ≤ ⨆ (t : set α) (H : t ∈ s), Sup t		α : Type u_1,	_inst_1 : complete_lattice α,	s : set (set α)	⊢ (⨆ (t : set α) (H : t ∈ s), Sup t) ≤ Sup (⋃₀ s)", "decl_nm": "Sup_sUnion"
{"src": "2 goals	α : Type u_1,	_inst_1 : complete_lattice α,	s : set (set α),	b : α,	hb : b ∈ ⋃₀ s	⊢ b ≤ ⨆ (t : set α) (H : t ∈ s), Sup t		α : Type u_1,	_inst_1 : complete_lattice α,	s : set (set α)	⊢ (⨆ (t : set α) (H : t ∈ s), Sup t) ≤ Sup (⋃₀ s)", "decl_nm": "Sup_sUnion"
{"src": "2 goals	α : Type u_1,	_inst_1 : complete_lattice α,	s : set (set α),	b : α,	t : set α,	ts : t ∈ s,	bt : b ∈ t	⊢ b ≤ ⨆ (t : set α) (H : t ∈ s), Sup t		α : Type u_1,	_inst_1 : complete_lattice α,	s : set (set α)	⊢ (⨆ (t : set α) (H : t ∈ s), Sup t) ≤ Sup (⋃₀ s)", "decl_nm": "Sup_sUnion"
{"src": "2 goals	α : Type u_1,	_inst_1 : complete_lattice α,	s : set (set α),	b : α,	t : set α,	ts : t ∈ s,	bt : b ∈ t	⊢ b ≤ ⨆ (H : t ∈ s), Sup t		α : Type u_1,	_inst_1 : complete_lattice α,	s : set (set α)	⊢ (⨆ (t : set α) (H : t ∈ s), Sup t) ≤ Sup (⋃₀ s)", "decl_nm": "Sup_sUnion"
{"src": "α : Type u_1,	_inst_1 : complete_lattice α,	s : set (set α)	⊢ (⨆ (t : set α) (H : t ∈ s), Sup t) ≤ Sup (⋃₀ s)", "decl_nm": "Sup_sUnion"
{"src": "α : Type u_1,	_inst_1 : complete_lattice α,	s : set (set α),	t : set α	⊢ (⨆ (H : t ∈ s), Sup t) ≤ Sup (⋃₀ s)", "decl_nm": "Sup_sUnion"
{"src": "⊢ ∀ {α : Type u_1} [_inst_2 : has_Sup α] {p q : Prop} {f₁ : p → α} {f₂ : q → α} (pq : p ↔ q),	    (∀ (x : q), f₁ _ = f₂ x) → supr f₁ = supr f₂", "decl_nm": "supr_congr_Prop"
{"src": "α : Type u_1,	_inst_2 : has_Sup α,	p q : Prop,	f₁ : p → α,	f₂ : q → α,	pq : p ↔ q,	f : ∀ (x : q), f₁ _ = f₂ x	⊢ supr f₁ = supr f₂", "decl_nm": "supr_congr_Prop"
{"src": "α : Type u_1,	_inst_2 : has_Sup α,	p q : Prop,	f₁ : p → α,	f₂ : q → α,	pq : p ↔ q,	f : ∀ (x : q), f₁ _ = f₂ x,	this : p = q	⊢ supr f₁ = supr f₂", "decl_nm": "supr_congr_Prop"
{"src": "α : Type u_1,	_inst_2 : has_Sup α,	p : Prop,	f₁ f₂ : p → α,	pq : p ↔ p,	f : ∀ (x : p), f₁ _ = f₂ x	⊢ supr f₁ = supr f₂", "decl_nm": "supr_congr_Prop"
{"src": "α : Type u_1,	_inst_2 : has_Sup α,	p : Prop,	f₁ f₂ : p → α,	pq : p ↔ p,	f : ∀ (x : p), f₁ _ = f₂ x,	x : p	⊢ f₁ x = f₂ x", "decl_nm": "supr_congr_Prop"
{"src": "⊢ ∀ {α : Type u_1} {ι : Sort u_4} [_inst_1 : complete_lattice α] [_inst_2 : nonempty ι] {a : α},	    (⨅ (b : ι), a) = a", "decl_nm": "infi_const"
{"src": "α : Type u_1,	ι : Sort u_4,	_inst_1 : complete_lattice α,	_inst_2 : nonempty ι,	a : α	⊢ (⨅ (b : ι), a) = a", "decl_nm": "infi_const"
{"src": "⊢ ∀ {α : Type u_3} {β : Type u_4} [_inst_1 : preorder β] {m : α → β} {f : filter α},	    tendsto m f at_top ↔ ∀ (b : β), ∀ᶠ (a : α) in f, b ≤ m a", "decl_nm": "filter.tendsto_at_top"
{"src": "α : Type u_3,	β : Type u_4,	_inst_1 : preorder β,	m : α → β,	f : filter α	⊢ tendsto m f at_top ↔ ∀ (b : β), ∀ᶠ (a : α) in f, b ≤ m a", "decl_nm": "filter.tendsto_at_top"
{"src": "⊢ ∀ {P : ℕ → Prop},	    (∃ᶠ (n : ℕ) in at_top, P n) → (∃ (φ : ℕ → ℕ), strict_mono φ ∧ ∀ (n : ℕ), P (φ n))", "decl_nm": "filter.extraction_of_frequently_at_top"
{"src": "P : ℕ → Prop,	h : ∃ᶠ (n : ℕ) in at_top, P n	⊢ ∃ (φ : ℕ → ℕ), strict_mono φ ∧ ∀ (n : ℕ), P (φ n)", "decl_nm": "filter.extraction_of_frequently_at_top"
{"src": "P : ℕ → Prop,	h : ∀ (a : ℕ), ∃ (b : ℕ) (H : b > a), P b	⊢ ∃ (φ : ℕ → ℕ), strict_mono φ ∧ ∀ (n : ℕ), P (φ n)", "decl_nm": "filter.extraction_of_frequently_at_top"
{"src": "⊢ ∀ {α : Type u_1} {β : Type u_2} {ι : Sort u_4} {la : filter α} {pa : ι → Prop} {sa : ι → set α}	  {lb : filter β} {f : α → β},	    la.has_basis pa sa →	    (tendsto f la lb ↔ ∀ (t : set β), t ∈ lb → (∃ (i : ι) (hi : pa i), maps_to f (sa i) t))", "decl_nm": "filter.has_basis.tendsto_left_iff"
{"src": "α : Type u_1,	β : Type u_2,	ι : Sort u_4,	la : filter α,	pa : ι → Prop,	sa : ι → set α,	lb : filter β,	f : α → β,	hla : la.has_basis pa sa	⊢ tendsto f la lb ↔ ∀ (t : set β), t ∈ lb → (∃ (i : ι) (hi : pa i), maps_to f (sa i) t)", "decl_nm": "filter.has_basis.tendsto_left_iff"
{"src": "α : Type u_1,	β : Type u_2,	ι : Sort u_4,	la : filter α,	pa : ι → Prop,	sa : ι → set α,	lb : filter β,	f : α → β,	hla : la.has_basis pa sa	⊢ (∀ (t : set β), t ∈ lb → (∃ (i : ι) (h : pa i), sa i ⊆ f ⁻¹' t)) ↔	    ∀ (t : set β), t ∈ lb → (∃ (i : ι) (hi : pa i), maps_to f (sa i) t)", "decl_nm": "filter.has_basis.tendsto_left_iff"
{"src": "⊢ ∀ {α : Type u} {β : Type v} {f : filter α} {m : α → β}, range m ∈ map m f", "decl_nm": "filter.range_mem_map"
{"src": "α : Type u,	β : Type v,	f : filter α,	m : α → β	⊢ range m ∈ map m f", "decl_nm": "filter.range_mem_map"
{"src": "α : Type u,	β : Type v,	f : filter α,	m : α → β	⊢ m '' univ ∈ map m f", "decl_nm": "filter.range_mem_map"
{"src": "⊢ ∀ {α : Type u} {β : Type v} (f₁ f₂ : filter α) (g : filter β),	    (f₁ ⊔ f₂).prod g = f₁.prod g ⊔ f₂.prod g", "decl_nm": "filter.sup_prod"
{"src": "α : Type u,	β : Type v,	f₁ f₂ : filter α,	g : filter β	⊢ (f₁ ⊔ f₂).prod g = f₁.prod g ⊔ f₂.prod g", "decl_nm": "filter.sup_prod"
{"src": "⊢ ∀ {ι : Type u_1} {α : Type u_2} {l : filter α} [_inst_1 : countable_Inter_filter l] {S : set ι},	    S.countable →	    ∀ {p : α → Π (i : ι), i ∈ S → Prop},	      (∀ᶠ (x : α) in l, ∀ (i : ι) (H : i ∈ S), p x i H) ↔	        ∀ (i : ι) (H : i ∈ S), ∀ᶠ (x : α) in l, p x i H", "decl_nm": "eventually_countable_ball"
{"src": "ι : Type u_1,	α : Type u_2,	l : filter α,	_inst_1 : countable_Inter_filter l,	S : set ι,	hS : S.countable,	p : α → Π (i : ι), i ∈ S → Prop	⊢ (∀ᶠ (x : α) in l, ∀ (i : ι) (H : i ∈ S), p x i H) ↔	    ∀ (i : ι) (H : i ∈ S), ∀ᶠ (x : α) in l, p x i H", "decl_nm": "eventually_countable_ball"
{"src": "⊢ ∀ {α : Type u_1} {β : Type u_2} (g : set α → filter β), ⊤.lift g = g univ", "decl_nm": "filter.lift_top"
{"src": "α : Type u_1,	β : Type u_2,	g : set α → filter β	⊢ ⊤.lift g = g univ", "decl_nm": "filter.lift_top"
{"src": "⊢ ∀ {α : Type u} {β : Type v} [_inst_1 : monoid α] [_inst_2 : monoid β] (m : mul_hom α β)	  {f₁ f₂ : filter β}, comap ⇑m f₁ * comap ⇑m f₂ ≤ comap ⇑m (f₁ * f₂)", "decl_nm": "filter.comap_mul_comap_le"
{"src": "α : Type u,	β : Type v,	_inst_1 : monoid α,	_inst_2 : monoid β,	m : mul_hom α β,	f₁ f₂ : filter β	⊢ comap ⇑m f₁ * comap ⇑m f₂ ≤ comap ⇑m (f₁ * f₂)", "decl_nm": "filter.comap_mul_comap_le"
{"src": "α : Type u,	β : Type v,	_inst_1 : monoid α,	_inst_2 : monoid β,	m : mul_hom α β,	f₁ f₂ : filter β,	s : set α,	t : set β,	mt : ⇑m ⁻¹' t ⊆ s,	t₁ t₂ : set β,	ht₁ : t₁ ∈ f₁,	ht₂ : t₂ ∈ f₂,	t₁t₂ : t₁ * t₂ ⊆ t	⊢ s ∈ comap ⇑m f₁ * comap ⇑m f₂", "decl_nm": "filter.comap_mul_comap_le"
{"src": "α : Type u,	β : Type v,	_inst_1 : monoid α,	_inst_2 : monoid β,	m : mul_hom α β,	f₁ f₂ : filter β,	s : set α,	t : set β,	mt : ⇑m ⁻¹' t ⊆ s,	t₁ t₂ : set β,	ht₁ : t₁ ∈ f₁,	ht₂ : t₂ ∈ f₂,	t₁t₂ : t₁ * t₂ ⊆ t	⊢ ⇑m ⁻¹' t₁ * ⇑m ⁻¹' t₂ ⊆ s", "decl_nm": "filter.comap_mul_comap_le"
{"src": "α : Type u,	β : Type v,	_inst_1 : monoid α,	_inst_2 : monoid β,	m : mul_hom α β,	f₁ f₂ : filter β,	s : set α,	t : set β,	mt : ⇑m ⁻¹' t ⊆ s,	t₁ t₂ : set β,	ht₁ : t₁ ∈ f₁,	ht₂ : t₂ ∈ f₂,	t₁t₂ : t₁ * t₂ ⊆ t,	this : ⇑m ⁻¹' (t₁ * t₂) ⊆ s	⊢ ⇑m ⁻¹' t₁ * ⇑m ⁻¹' t₂ ⊆ s", "decl_nm": "filter.comap_mul_comap_le"
{"src": "⊢ ∀ {α : Type u} [_inst_1 : semilattice_sup α] {a b : α}, a ⊔ (a ⊔ b) = a ⊔ b", "decl_nm": "sup_left_idem"
{"src": "α : Type u,	_inst_1 : semilattice_sup α,	a b : α	⊢ a ⊔ (a ⊔ b) = a ⊔ b", "decl_nm": "sup_left_idem"
{"src": "⊢ ∀ {α : Type u} [_inst_1 : semilattice_sup α] (a b c : α), a ⊔ (b ⊔ c) = b ⊔ (a ⊔ c)", "decl_nm": "sup_left_comm"
{"src": "α : Type u,	_inst_1 : semilattice_sup α,	a b c : α	⊢ a ⊔ (b ⊔ c) = b ⊔ (a ⊔ c)", "decl_nm": "sup_left_comm"
{"src": "⊢ ∀ {α : Type u_1} [_inst_1 : complete_lattice α] (f : ℕ → α) (k : ℕ),	    at_top.liminf (λ (i : ℕ), f (i + k)) = at_top.liminf f", "decl_nm": "filter.liminf_nat_add"
{"src": "α : Type u_1,	_inst_1 : complete_lattice α,	f : ℕ → α,	k : ℕ	⊢ at_top.liminf (λ (i : ℕ), f (i + k)) = at_top.liminf f", "decl_nm": "filter.liminf_nat_add"
{"src": "α : Type u_1,	_inst_1 : complete_lattice α,	f : ℕ → α,	k : ℕ	⊢ (⨆ (n : ℕ), ⨅ (i : ℕ) (H : i ≥ n), f (i + k)) = ⨆ (n : ℕ), ⨅ (i : ℕ) (H : i ≥ n), f i", "decl_nm": "filter.liminf_nat_add"
{"src": "⊢ ∀ {α : Type u} [_inst_1 : omega_complete_partial_order α] (c : chain α) (x : α),	    ωSup c ≤ x ↔ ∀ (i : ℕ), ⇑c i ≤ x", "decl_nm": "omega_complete_partial_order.ωSup_le_iff"
{"src": "α : Type u,	_inst_1 : omega_complete_partial_order α,	c : chain α,	x : α	⊢ ωSup c ≤ x ↔ ∀ (i : ℕ), ⇑c i ≤ x", "decl_nm": "omega_complete_partial_order.ωSup_le_iff"
{"src": "2 goals	α : Type u,	_inst_1 : omega_complete_partial_order α,	c : chain α,	x : α	⊢ ωSup c ≤ x → ∀ (i : ℕ), ⇑c i ≤ x		α : Type u,	_inst_1 : omega_complete_partial_order α,	c : chain α,	x : α	⊢ (∀ (i : ℕ), ⇑c i ≤ x) → ωSup c ≤ x", "decl_nm": "omega_complete_partial_order.ωSup_le_iff"
{"src": "2 goals	α : Type u,	_inst_1 : omega_complete_partial_order α,	c : chain α,	x : α,	ᾰ : ωSup c ≤ x,	i : ℕ	⊢ ⇑c i ≤ x		α : Type u,	_inst_1 : omega_complete_partial_order α,	c : chain α,	x : α	⊢ (∀ (i : ℕ), ⇑c i ≤ x) → ωSup c ≤ x", "decl_nm": "omega_complete_partial_order.ωSup_le_iff"
{"src": "3 goals	α : Type u,	_inst_1 : omega_complete_partial_order α,	c : chain α,	x : α,	ᾰ : ωSup c ≤ x,	i : ℕ	⊢ ⇑c i ≤ ωSup c		α : Type u,	_inst_1 : omega_complete_partial_order α,	c : chain α,	x : α,	ᾰ : ωSup c ≤ x,	i : ℕ	⊢ ωSup c ≤ x		α : Type u,	_inst_1 : omega_complete_partial_order α,	c : chain α,	x : α	⊢ (∀ (i : ℕ), ⇑c i ≤ x) → ωSup c ≤ x", "decl_nm": "omega_complete_partial_order.ωSup_le_iff"
{"src": "2 goals	α : Type u,	_inst_1 : omega_complete_partial_order α,	c : chain α,	x : α,	ᾰ : ωSup c ≤ x,	i : ℕ	⊢ ωSup c ≤ x		α : Type u,	_inst_1 : omega_complete_partial_order α,	c : chain α,	x : α	⊢ (∀ (i : ℕ), ⇑c i ≤ x) → ωSup c ≤ x", "decl_nm": "omega_complete_partial_order.ωSup_le_iff"
{"src": "α : Type u,	_inst_1 : omega_complete_partial_order α,	c : chain α,	x : α	⊢ (∀ (i : ℕ), ⇑c i ≤ x) → ωSup c ≤ x", "decl_nm": "omega_complete_partial_order.ωSup_le_iff"
{"src": "α : Type u,	_inst_1 : omega_complete_partial_order α,	c : chain α,	x : α,	ᾰ : ∀ (i : ℕ), ⇑c i ≤ x	⊢ ωSup c ≤ x", "decl_nm": "omega_complete_partial_order.ωSup_le_iff"
{"src": "⊢ ∀ {α : Type u} {β : Type v} [_inst_1 : omega_complete_partial_order α]	  [_inst_2 : omega_complete_partial_order β] {p : Prop} [hp : decidable p] (f g : α → β),	    continuous' f → continuous' g → continuous' (λ (x : α), ite p (f x) (g x))", "decl_nm": "omega_complete_partial_order.continuous_hom.ite_continuous'"
{"src": "α : Type u,	β : Type v,	_inst_1 : omega_complete_partial_order α,	_inst_2 : omega_complete_partial_order β,	p : Prop,	hp : decidable p,	f g : α → β,	hf : continuous' f,	hg : continuous' g	⊢ continuous' (λ (x : α), ite p (f x) (g x))", "decl_nm": "omega_complete_partial_order.continuous_hom.ite_continuous'"
{"src": "2 goals	α : Type u,	β : Type v,	_inst_1 : omega_complete_partial_order α,	_inst_2 : omega_complete_partial_order β,	p : Prop,	hp : decidable p,	f g : α → β,	hf : continuous' f,	hg : continuous' g,	h : p	⊢ continuous' f		α : Type u,	β : Type v,	_inst_1 : omega_complete_partial_order α,	_inst_2 : omega_complete_partial_order β,	p : Prop,	hp : decidable p,	f g : α → β,	hf : continuous' f,	hg : continuous' g,	h : ¬p	⊢ continuous' g", "decl_nm": "omega_complete_partial_order.continuous_hom.ite_continuous'"
{"src": "α : Type u,	β : Type v,	_inst_1 : omega_complete_partial_order α,	_inst_2 : omega_complete_partial_order β,	p : Prop,	hp : decidable p,	f g : α → β,	hf : continuous' f,	hg : continuous' g,	h : ¬p	⊢ continuous' g", "decl_nm": "omega_complete_partial_order.continuous_hom.ite_continuous'"
{"src": "⊢ ∀ {α : Type u} {β : Type v} [_inst_1 : complete_lattice α] [_inst_2 : complete_lattice β] {f : α → β},	    left_ord_continuous f → ∀ (s : set α), f (Sup s) = ⨆ (x : α) (H : x ∈ s), f x", "decl_nm": "left_ord_continuous.map_Sup"
{"src": "α : Type u,	β : Type v,	_inst_1 : complete_lattice α,	_inst_2 : complete_lattice β,	f : α → β,	hf : left_ord_continuous f,	s : set α	⊢ f (Sup s) = ⨆ (x : α) (H : x ∈ s), f x", "decl_nm": "left_ord_continuous.map_Sup"
{"src": "⊢ ∀ {α : Type u_1} [_inst_1 : generalized_boolean_algebra α] (a b : α), a Δ b \ b = a \ b", "decl_nm": "symm_diff_sdiff_right"
{"src": "α : Type u_1,	_inst_1 : generalized_boolean_algebra α,	a b : α	⊢ a Δ b \ b = a \ b", "decl_nm": "symm_diff_sdiff_right"
{"src": "⊢ ∀ {α : Type u_1} {s : set α} {r : α → α → Prop} [_inst_1 : is_refl α r] [_inst_2 : is_trans α r],	    s.partially_well_ordered_on r ↔	      ∀ (f : ℕ → α),	        range f ⊆ s → (∃ (g : ℕ ↪o ℕ), ∀ (m n : ℕ), m ≤ n → r (f (⇑g m)) (f (⇑g n)))", "decl_nm": "set.partially_well_ordered_on_iff_exists_monotone_subseq"
{"src": "α : Type u_1,	s : set α,	r : α → α → Prop,	_inst_1 : is_refl α r,	_inst_2 : is_trans α r	⊢ s.partially_well_ordered_on r ↔	    ∀ (f : ℕ → α),	      range f ⊆ s → (∃ (g : ℕ ↪o ℕ), ∀ (m n : ℕ), m ≤ n → r (f (⇑g m)) (f (⇑g n)))", "decl_nm": "set.partially_well_ordered_on_iff_exists_monotone_subseq"
{"src": "α : Type u_1,	s : set α,	r : α → α → Prop,	_inst_1 : is_refl α r,	_inst_2 : is_trans α r,	_inst : Π (a : Prop), decidable a	⊢ s.partially_well_ordered_on r ↔	    ∀ (f : ℕ → α),	      range f ⊆ s → (∃ (g : ℕ ↪o ℕ), ∀ (m n : ℕ), m ≤ n → r (f (⇑g m)) (f (⇑g n)))", "decl_nm": "set.partially_well_ordered_on_iff_exists_monotone_subseq"
{"src": "2 goals	α : Type u_1,	s : set α,	r : α → α → Prop,	_inst_1 : is_refl α r,	_inst_2 : is_trans α r,	_inst : Π (a : Prop), decidable a	⊢ s.partially_well_ordered_on r →	  ∀ (f : ℕ → α),	    range f ⊆ s → (∃ (g : ℕ ↪o ℕ), ∀ (m n : ℕ), m ≤ n → r (f (⇑g m)) (f (⇑g n)))		α : Type u_1,	s : set α,	r : α → α → Prop,	_inst_1 : is_refl α r,	_inst_2 : is_trans α r,	_inst : Π (a : Prop), decidable a	⊢ (∀ (f : ℕ → α),	     range f ⊆ s → (∃ (g : ℕ ↪o ℕ), ∀ (m n : ℕ), m ≤ n → r (f (⇑g m)) (f (⇑g n)))) →	  s.partially_well_ordered_on r", "decl_nm": "set.partially_well_ordered_on_iff_exists_monotone_subseq"
{"src": "2 goals	α : Type u_1,	s : set α,	r : α → α → Prop,	_inst_1 : is_refl α r,	_inst_2 : is_trans α r,	_inst : Π (a : Prop), decidable a,	h : s.partially_well_ordered_on r,	f : ℕ → α,	hf : range f ⊆ s	⊢ ∃ (g : ℕ ↪o ℕ), ∀ (m n : ℕ), m ≤ n → r (f (⇑g m)) (f (⇑g n))		α : Type u_1,	s : set α,	r : α → α → Prop,	_inst_1 : is_refl α r,	_inst_2 : is_trans α r,	_inst : Π (a : Prop), decidable a	⊢ (∀ (f : ℕ → α),	     range f ⊆ s → (∃ (g : ℕ ↪o ℕ), ∀ (m n : ℕ), m ≤ n → r (f (⇑g m)) (f (⇑g n)))) →	  s.partially_well_ordered_on r", "decl_nm": "set.partially_well_ordered_on_iff_exists_monotone_subseq"
{"src": "α : Type u_1,	s : set α,	r : α → α → Prop,	_inst_1 : is_refl α r,	_inst_2 : is_trans α r,	_inst : Π (a : Prop), decidable a	⊢ (∀ (f : ℕ → α),	     range f ⊆ s → (∃ (g : ℕ ↪o ℕ), ∀ (m n : ℕ), m ≤ n → r (f (⇑g m)) (f (⇑g n)))) →	  s.partially_well_ordered_on r", "decl_nm": "set.partially_well_ordered_on_iff_exists_monotone_subseq"
{"src": "α : Type u_1,	s : set α,	r : α → α → Prop,	_inst_1 : is_refl α r,	_inst_2 : is_trans α r,	_inst : Π (a : Prop), decidable a,	h :	  ∀ (f : ℕ → α),	    range f ⊆ s → (∃ (g : ℕ ↪o ℕ), ∀ (m n : ℕ), m ≤ n → r (f (⇑g m)) (f (⇑g n))),	f : ℕ → α,	hf : range f ⊆ s	⊢ ∃ (m n : ℕ), m < n ∧ r (f m) (f n)", "decl_nm": "set.partially_well_ordered_on_iff_exists_monotone_subseq"
{"src": "α : Type u_1,	s : set α,	r : α → α → Prop,	_inst_1 : is_refl α r,	_inst_2 : is_trans α r,	_inst : Π (a : Prop), decidable a,	h :	  ∀ (f : ℕ → α),	    range f ⊆ s → (∃ (g : ℕ ↪o ℕ), ∀ (m n : ℕ), m ≤ n → r (f (⇑g m)) (f (⇑g n))),	f : ℕ → α,	hf : range f ⊆ s,	g : ℕ ↪o ℕ,	gmon : ∀ (m n : ℕ), m ≤ n → r (f (⇑g m)) (f (⇑g n))	⊢ ∃ (m n : ℕ), m < n ∧ r (f m) (f n)", "decl_nm": "set.partially_well_ordered_on_iff_exists_monotone_subseq"
{"src": "⊢ ∀ {k : Type u} [_inst_1 : comm_ring k] {G : Type u} [_inst_2 : group G] {V : Type u} [_inst_3 : add_comm_group V]	  [_inst_4 : module k V] [_inst_5 : module (monoid_algebra k G) V] [_inst_6 : is_scalar_tower k (monoid_algebra k G) V]	  {W : Type u} [_inst_7 : add_comm_group W] [_inst_8 : module k W] [_inst_9 : module (monoid_algebra k G) W]	  [_inst_10 : is_scalar_tower k (monoid_algebra k G) W] (π : W →ₗ[k] V) (i : V →ₗ[monoid_algebra k G] W),	    (∀ (v : V), ⇑π (⇑i v) = v) → ∀ (g : G) (v : V), ⇑(π.conjugate g) (⇑i v) = v", "decl_nm": "linear_map.conjugate_i"
{"src": "k : Type u,	_inst_1 : comm_ring k,	G : Type u,	_inst_2 : group G,	V : Type u,	_inst_3 : add_comm_group V,	_inst_4 : module k V,	_inst_5 : module (monoid_algebra k G) V,	_inst_6 : is_scalar_tower k (monoid_algebra k G) V,	W : Type u,	_inst_7 : add_comm_group W,	_inst_8 : module k W,	_inst_9 : module (monoid_algebra k G) W,	_inst_10 : is_scalar_tower k (monoid_algebra k G) W,	π : W →ₗ[k] V,	i : V →ₗ[monoid_algebra k G] W,	h : ∀ (v : V), ⇑π (⇑i v) = v,	g : G,	v : V	⊢ ⇑(π.conjugate g) (⇑i v) = v", "decl_nm": "linear_map.conjugate_i"
{"src": "k : Type u,	_inst_1 : comm_ring k,	G : Type u,	_inst_2 : group G,	V : Type u,	_inst_3 : add_comm_group V,	_inst_4 : module k V,	_inst_5 : module (monoid_algebra k G) V,	_inst_6 : is_scalar_tower k (monoid_algebra k G) V,	W : Type u,	_inst_7 : add_comm_group W,	_inst_8 : module k W,	_inst_9 : module (monoid_algebra k G) W,	_inst_10 : is_scalar_tower k (monoid_algebra k G) W,	π : W →ₗ[k] V,	i : V →ₗ[monoid_algebra k G] W,	h : ∀ (v : V), ⇑π (⇑i v) = v,	g : G,	v : V	⊢ finsupp.single g⁻¹ 1 • ⇑π (finsupp.single g 1 • ⇑i v) = v", "decl_nm": "linear_map.conjugate_i"
{"src": "k : Type u,	_inst_1 : comm_ring k,	G : Type u,	_inst_2 : group G,	V : Type u,	_inst_3 : add_comm_group V,	_inst_4 : module k V,	_inst_5 : module (monoid_algebra k G) V,	_inst_6 : is_scalar_tower k (monoid_algebra k G) V,	W : Type u,	_inst_7 : add_comm_group W,	_inst_8 : module k W,	_inst_9 : module (monoid_algebra k G) W,	_inst_10 : is_scalar_tower k (monoid_algebra k G) W,	π : W →ₗ[k] V,	i : V →ₗ[monoid_algebra k G] W,	h : ∀ (v : V), ⇑π (⇑i v) = v,	g : G,	v : V	⊢ finsupp.single 1 1 • v = v", "decl_nm": "linear_map.conjugate_i"
{"src": "k : Type u,	_inst_1 : comm_ring k,	G : Type u,	_inst_2 : group G,	V : Type u,	_inst_3 : add_comm_group V,	_inst_4 : module k V,	_inst_5 : module (monoid_algebra k G) V,	_inst_6 : is_scalar_tower k (monoid_algebra k G) V,	W : Type u,	_inst_7 : add_comm_group W,	_inst_8 : module k W,	_inst_9 : module (monoid_algebra k G) W,	_inst_10 : is_scalar_tower k (monoid_algebra k G) W,	π : W →ₗ[k] V,	i : V →ₗ[monoid_algebra k G] W,	h : ∀ (v : V), ⇑π (⇑i v) = v,	g : G,	v : V	⊢ 1 • v = v", "decl_nm": "linear_map.conjugate_i"
{"src": "⊢ ∀ {K : Type w} [_inst_2 : field K] {f : polynomial K},	    f ≠ 0 → minpoly K (root f) = f * ⇑C (f.leading_coeff)⁻¹", "decl_nm": "adjoin_root.minpoly_root"
{"src": "K : Type w,	_inst_2 : field K,	f : polynomial K,	hf : f ≠ 0	⊢ minpoly K (root f) = f * ⇑C (f.leading_coeff)⁻¹", "decl_nm": "adjoin_root.minpoly_root"
{"src": "K : Type w,	_inst_2 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑C (f.leading_coeff)⁻¹).monic	⊢ minpoly K (root f) = f * ⇑C (f.leading_coeff)⁻¹", "decl_nm": "adjoin_root.minpoly_root"
{"src": "2 goals	K : Type w,	_inst_2 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑C (f.leading_coeff)⁻¹).monic	⊢ ⇑(aeval (root f)) (f * ⇑C (f.leading_coeff)⁻¹) = 0		K : Type w,	_inst_2 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑C (f.leading_coeff)⁻¹).monic	⊢ ∀ (q : polynomial K),	    q.monic → ⇑(aeval (root f)) q = 0 → (f * ⇑C (f.leading_coeff)⁻¹).degree ≤ q.degree", "decl_nm": "adjoin_root.minpoly_root"
{"src": "K : Type w,	_inst_2 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑C (f.leading_coeff)⁻¹).monic	⊢ ∀ (q : polynomial K),	    q.monic → ⇑(aeval (root f)) q = 0 → (f * ⇑C (f.leading_coeff)⁻¹).degree ≤ q.degree", "decl_nm": "adjoin_root.minpoly_root"
{"src": "K : Type w,	_inst_2 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(aeval (root f)) q = 0	⊢ (f * ⇑C (f.leading_coeff)⁻¹).degree ≤ q.degree", "decl_nm": "adjoin_root.minpoly_root"
{"src": "2 goals	K : Type w,	_inst_2 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(aeval (root f)) q = 0	⊢ (lift (algebra_map K (adjoin_root f)) (root f) q_aeval).comp (mk q) = mk f		K : Type w,	_inst_2 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(aeval (root f)) q = 0,	commutes : (lift (algebra_map K (adjoin_root f)) (root f) q_aeval).comp (mk q) = mk f	⊢ (f * ⇑C (f.leading_coeff)⁻¹).degree ≤ q.degree", "decl_nm": "adjoin_root.minpoly_root"
{"src": "3 goals	K : Type w,	_inst_2 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(aeval (root f)) q = 0,	x : K	⊢ ⇑(((lift (algebra_map K (adjoin_root f)) (root f) q_aeval).comp (mk q)).comp C) x = ⇑((mk f).comp C) x		K : Type w,	_inst_2 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(aeval (root f)) q = 0	⊢ ⇑((lift (algebra_map K (adjoin_root f)) (root f) q_aeval).comp (mk q)) X = ⇑(mk f) X		K : Type w,	_inst_2 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(aeval (root f)) q = 0,	commutes : (lift (algebra_map K (adjoin_root f)) (root f) q_aeval).comp (mk q) = mk f	⊢ (f * ⇑C (f.leading_coeff)⁻¹).degree ≤ q.degree", "decl_nm": "adjoin_root.minpoly_root"
{"src": "3 goals	K : Type w,	_inst_2 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(aeval (root f)) q = 0,	x : K	⊢ ⇑(algebra_map K (adjoin_root f)) x = ↑x		K : Type w,	_inst_2 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(aeval (root f)) q = 0	⊢ ⇑((lift (algebra_map K (adjoin_root f)) (root f) q_aeval).comp (mk q)) X = ⇑(mk f) X		K : Type w,	_inst_2 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(aeval (root f)) q = 0,	commutes : (lift (algebra_map K (adjoin_root f)) (root f) q_aeval).comp (mk q) = mk f	⊢ (f * ⇑C (f.leading_coeff)⁻¹).degree ≤ q.degree", "decl_nm": "adjoin_root.minpoly_root"
{"src": "2 goals	K : Type w,	_inst_2 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(aeval (root f)) q = 0	⊢ ⇑((lift (algebra_map K (adjoin_root f)) (root f) q_aeval).comp (mk q)) X = ⇑(mk f) X		K : Type w,	_inst_2 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(aeval (root f)) q = 0,	commutes : (lift (algebra_map K (adjoin_root f)) (root f) q_aeval).comp (mk q) = mk f	⊢ (f * ⇑C (f.leading_coeff)⁻¹).degree ≤ q.degree", "decl_nm": "adjoin_root.minpoly_root"
{"src": "K : Type w,	_inst_2 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(aeval (root f)) q = 0,	commutes : (lift (algebra_map K (adjoin_root f)) (root f) q_aeval).comp (mk q) = mk f	⊢ (f * ⇑C (f.leading_coeff)⁻¹).degree ≤ q.degree", "decl_nm": "adjoin_root.minpoly_root"
{"src": "2 goals	K : Type w,	_inst_2 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(aeval (root f)) q = 0,	commutes : (lift (algebra_map K (adjoin_root f)) (root f) q_aeval).comp (mk q) = mk f	⊢ f.nat_degree ≤ q.nat_degree		K : Type w,	_inst_2 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(aeval (root f)) q = 0,	commutes : (lift (algebra_map K (adjoin_root f)) (root f) q_aeval).comp (mk q) = mk f	⊢ ⇑C (f.leading_coeff)⁻¹ ≠ 0", "decl_nm": "adjoin_root.minpoly_root"
{"src": "3 goals	K : Type w,	_inst_2 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(aeval (root f)) q = 0,	commutes : (lift (algebra_map K (adjoin_root f)) (root f) q_aeval).comp (mk q) = mk f	⊢ f ∣ q		K : Type w,	_inst_2 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(aeval (root f)) q = 0,	commutes : (lift (algebra_map K (adjoin_root f)) (root f) q_aeval).comp (mk q) = mk f	⊢ q ≠ 0		K : Type w,	_inst_2 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(aeval (root f)) q = 0,	commutes : (lift (algebra_map K (adjoin_root f)) (root f) q_aeval).comp (mk q) = mk f	⊢ ⇑C (f.leading_coeff)⁻¹ ≠ 0", "decl_nm": "adjoin_root.minpoly_root"
{"src": "4 goals	K : Type w,	_inst_2 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(aeval (root f)) q = 0,	commutes : (lift (algebra_map K (adjoin_root f)) (root f) q_aeval).comp (mk q) = mk f	⊢ ⇑(mk f) q = 0		K : Type w,	_inst_2 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(aeval (root f)) q = 0,	commutes : (lift (algebra_map K (adjoin_root f)) (root f) q_aeval).comp (mk q) = mk f,	this : ⇑(mk f) q = 0	⊢ f ∣ q		K : Type w,	_inst_2 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(aeval (root f)) q = 0,	commutes : (lift (algebra_map K (adjoin_root f)) (root f) q_aeval).comp (mk q) = mk f	⊢ q ≠ 0		K : Type w,	_inst_2 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(aeval (root f)) q = 0,	commutes : (lift (algebra_map K (adjoin_root f)) (root f) q_aeval).comp (mk q) = mk f	⊢ ⇑C (f.leading_coeff)⁻¹ ≠ 0", "decl_nm": "adjoin_root.minpoly_root"
{"src": "3 goals	K : Type w,	_inst_2 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(aeval (root f)) q = 0,	commutes : (lift (algebra_map K (adjoin_root f)) (root f) q_aeval).comp (mk q) = mk f,	this : ⇑(mk f) q = 0	⊢ f ∣ q		K : Type w,	_inst_2 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(aeval (root f)) q = 0,	commutes : (lift (algebra_map K (adjoin_root f)) (root f) q_aeval).comp (mk q) = mk f	⊢ q ≠ 0		K : Type w,	_inst_2 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(aeval (root f)) q = 0,	commutes : (lift (algebra_map K (adjoin_root f)) (root f) q_aeval).comp (mk q) = mk f	⊢ ⇑C (f.leading_coeff)⁻¹ ≠ 0", "decl_nm": "adjoin_root.minpoly_root"
{"src": "2 goals	K : Type w,	_inst_2 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(aeval (root f)) q = 0,	commutes : (lift (algebra_map K (adjoin_root f)) (root f) q_aeval).comp (mk q) = mk f	⊢ q ≠ 0		K : Type w,	_inst_2 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(aeval (root f)) q = 0,	commutes : (lift (algebra_map K (adjoin_root f)) (root f) q_aeval).comp (mk q) = mk f	⊢ ⇑C (f.leading_coeff)⁻¹ ≠ 0", "decl_nm": "adjoin_root.minpoly_root"
{"src": "K : Type w,	_inst_2 : field K,	f : polynomial K,	hf : f ≠ 0,	f'_monic : (f * ⇑C (f.leading_coeff)⁻¹).monic,	q : polynomial K,	q_monic : q.monic,	q_aeval : ⇑(aeval (root f)) q = 0,	commutes : (lift (algebra_map K (adjoin_root f)) (root f) q_aeval).comp (mk q) = mk f	⊢ ⇑C (f.leading_coeff)⁻¹ ≠ 0", "decl_nm": "adjoin_root.minpoly_root"
{"src": "⊢ ∀ {A : Type u_2} {K : Type u_3} [_inst_2 : comm_ring A] [_inst_3 : field K] [_inst_4 : is_domain A]	  [_inst_5 : algebra A K] [_inst_6 : is_fraction_ring A K] {I : ideal A}, I ≠ ⊥ → 1 ∈ (↑I)⁻¹", "decl_nm": "fractional_ideal.one_mem_inv_coe_ideal"
{"src": "A : Type u_2,	K : Type u_3,	_inst_2 : comm_ring A,	_inst_3 : field K,	_inst_4 : is_domain A,	_inst_5 : algebra A K,	_inst_6 : is_fraction_ring A K,	I : ideal A,	hI : I ≠ ⊥	⊢ 1 ∈ (↑I)⁻¹", "decl_nm": "fractional_ideal.one_mem_inv_coe_ideal"
{"src": "2 goals	A : Type u_2,	K : Type u_3,	_inst_2 : comm_ring A,	_inst_3 : field K,	_inst_4 : is_domain A,	_inst_5 : algebra A K,	_inst_6 : is_fraction_ring A K,	I : ideal A,	hI : I ≠ ⊥	⊢ ∀ (y : K), y ∈ ↑I → 1 * y ∈ 1		A : Type u_2,	K : Type u_3,	_inst_2 : comm_ring A,	_inst_3 : field K,	_inst_4 : is_domain A,	_inst_5 : algebra A K,	_inst_6 : is_fraction_ring A K,	I : ideal A,	hI : I ≠ ⊥	⊢ is_fraction_ring A K", "decl_nm": "fractional_ideal.one_mem_inv_coe_ideal"
{"src": "2 goals	A : Type u_2,	K : Type u_3,	_inst_2 : comm_ring A,	_inst_3 : field K,	_inst_4 : is_domain A,	_inst_5 : algebra A K,	_inst_6 : is_fraction_ring A K,	I : ideal A,	hI : I ≠ ⊥,	y : K,	hy : y ∈ ↑I	⊢ 1 * y ∈ 1		A : Type u_2,	K : Type u_3,	_inst_2 : comm_ring A,	_inst_3 : field K,	_inst_4 : is_domain A,	_inst_5 : algebra A K,	_inst_6 : is_fraction_ring A K,	I : ideal A,	hI : I ≠ ⊥	⊢ is_fraction_ring A K", "decl_nm": "fractional_ideal.one_mem_inv_coe_ideal"
{"src": "2 goals	A : Type u_2,	K : Type u_3,	_inst_2 : comm_ring A,	_inst_3 : field K,	_inst_4 : is_domain A,	_inst_5 : algebra A K,	_inst_6 : is_fraction_ring A K,	I : ideal A,	hI : I ≠ ⊥,	y : K,	hy : y ∈ ↑I	⊢ y ∈ 1		A : Type u_2,	K : Type u_3,	_inst_2 : comm_ring A,	_inst_3 : field K,	_inst_4 : is_domain A,	_inst_5 : algebra A K,	_inst_6 : is_fraction_ring A K,	I : ideal A,	hI : I ≠ ⊥	⊢ is_fraction_ring A K", "decl_nm": "fractional_ideal.one_mem_inv_coe_ideal"
{"src": "A : Type u_2,	K : Type u_3,	_inst_2 : comm_ring A,	_inst_3 : field K,	_inst_4 : is_domain A,	_inst_5 : algebra A K,	_inst_6 : is_fraction_ring A K,	I : ideal A,	hI : I ≠ ⊥	⊢ is_fraction_ring A K", "decl_nm": "fractional_ideal.one_mem_inv_coe_ideal"
{"src": "⊢ ∀ {R : Type u_1} {A : Type u_2} [_inst_1 : comm_ring R] [_inst_2 : comm_ring A] [_inst_3 : algebra R A],	    finite_type R A ↔ ∃ (n : ℕ) (f : mv_polynomial (fin n) R →ₐ[R] A), surjective ⇑f", "decl_nm": "algebra.finite_type.iff_quotient_mv_polynomial''"
{"src": "R : Type u_1,	A : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_ring A,	_inst_3 : algebra R A	⊢ finite_type R A ↔ ∃ (n : ℕ) (f : mv_polynomial (fin n) R →ₐ[R] A), surjective ⇑f", "decl_nm": "algebra.finite_type.iff_quotient_mv_polynomial''"
{"src": "2 goals	R : Type u_1,	A : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_ring A,	_inst_3 : algebra R A	⊢ finite_type R A → (∃ (n : ℕ) (f : mv_polynomial (fin n) R →ₐ[R] A), surjective ⇑f)		R : Type u_1,	A : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_ring A,	_inst_3 : algebra R A	⊢ (∃ (n : ℕ) (f : mv_polynomial (fin n) R →ₐ[R] A), surjective ⇑f) → finite_type R A", "decl_nm": "algebra.finite_type.iff_quotient_mv_polynomial''"
{"src": "2 goals	R : Type u_1,	A : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_ring A,	_inst_3 : algebra R A	⊢ (∃ (ι : Type u_2) (_x : fintype ι) (f : mv_polynomial ι R →ₐ[R] A), surjective ⇑f) →	  (∃ (n : ℕ) (f : mv_polynomial (fin n) R →ₐ[R] A), surjective ⇑f)		R : Type u_1,	A : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_ring A,	_inst_3 : algebra R A	⊢ (∃ (n : ℕ) (f : mv_polynomial (fin n) R →ₐ[R] A), surjective ⇑f) → finite_type R A", "decl_nm": "algebra.finite_type.iff_quotient_mv_polynomial''"
{"src": "2 goals	R : Type u_1,	A : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_ring A,	_inst_3 : algebra R A,	ι : Type u_2,	hfintype : fintype ι,	f : mv_polynomial ι R →ₐ[R] A,	hsur : surjective ⇑f	⊢ ∃ (n : ℕ) (f : mv_polynomial (fin n) R →ₐ[R] A), surjective ⇑f		R : Type u_1,	A : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_ring A,	_inst_3 : algebra R A	⊢ (∃ (n : ℕ) (f : mv_polynomial (fin n) R →ₐ[R] A), surjective ⇑f) → finite_type R A", "decl_nm": "algebra.finite_type.iff_quotient_mv_polynomial''"
{"src": "2 goals	R : Type u_1,	A : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_ring A,	_inst_3 : algebra R A,	ι : Type u_2,	hfintype : fintype ι,	f : mv_polynomial ι R →ₐ[R] A,	hsur : surjective ⇑f,	_inst : fintype ι := hfintype	⊢ ∃ (n : ℕ) (f : mv_polynomial (fin n) R →ₐ[R] A), surjective ⇑f		R : Type u_1,	A : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_ring A,	_inst_3 : algebra R A	⊢ (∃ (n : ℕ) (f : mv_polynomial (fin n) R →ₐ[R] A), surjective ⇑f) → finite_type R A", "decl_nm": "algebra.finite_type.iff_quotient_mv_polynomial''"
{"src": "2 goals	R : Type u_1,	A : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_ring A,	_inst_3 : algebra R A,	ι : Type u_2,	hfintype : fintype ι,	f : mv_polynomial ι R →ₐ[R] A,	hsur : surjective ⇑f,	_inst : fintype ι := hfintype,	equiv : ι ≃ fin (fintype.card ι)	⊢ ∃ (n : ℕ) (f : mv_polynomial (fin n) R →ₐ[R] A), surjective ⇑f		R : Type u_1,	A : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_ring A,	_inst_3 : algebra R A	⊢ (∃ (n : ℕ) (f : mv_polynomial (fin n) R →ₐ[R] A), surjective ⇑f) → finite_type R A", "decl_nm": "algebra.finite_type.iff_quotient_mv_polynomial''"
{"src": "2 goals	R : Type u_1,	A : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_ring A,	_inst_3 : algebra R A,	ι : Type u_2,	hfintype : fintype ι,	f : mv_polynomial ι R →ₐ[R] A,	hsur : surjective ⇑f,	_inst : fintype ι := hfintype,	equiv : mv_polynomial ι R ≃ₐ[R] mv_polynomial (fin (fintype.card ι)) R	⊢ ∃ (n : ℕ) (f : mv_polynomial (fin n) R →ₐ[R] A), surjective ⇑f		R : Type u_1,	A : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_ring A,	_inst_3 : algebra R A	⊢ (∃ (n : ℕ) (f : mv_polynomial (fin n) R →ₐ[R] A), surjective ⇑f) → finite_type R A", "decl_nm": "algebra.finite_type.iff_quotient_mv_polynomial''"
{"src": "R : Type u_1,	A : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_ring A,	_inst_3 : algebra R A	⊢ (∃ (n : ℕ) (f : mv_polynomial (fin n) R →ₐ[R] A), surjective ⇑f) → finite_type R A", "decl_nm": "algebra.finite_type.iff_quotient_mv_polynomial''"
{"src": "R : Type u_1,	A : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_ring A,	_inst_3 : algebra R A,	n : ℕ,	f : mv_polynomial (fin n) R →ₐ[R] A,	hsur : surjective ⇑f	⊢ finite_type R A", "decl_nm": "algebra.finite_type.iff_quotient_mv_polynomial''"
{"src": "⊢ ∀ {A : Type u_1} {B : Type u_2} {C : Type u_3} [_inst_1 : comm_ring A] [_inst_2 : comm_ring B]	  [_inst_3 : comm_ring C] {f : A →+* B} {g : B →+* C}, (g.comp f).finite → g.finite", "decl_nm": "ring_hom.finite.of_comp_finite"
{"src": "A : Type u_1,	B : Type u_2,	C : Type u_3,	_inst_1 : comm_ring A,	_inst_2 : comm_ring B,	_inst_3 : comm_ring C,	f : A →+* B,	g : B →+* C,	h : (g.comp f).finite	⊢ g.finite", "decl_nm": "ring_hom.finite.of_comp_finite"
{"src": "A : Type u_1,	B : Type u_2,	C : Type u_3,	_inst_1 : comm_ring A,	_inst_2 : comm_ring B,	_inst_3 : comm_ring C,	f : A →+* B,	g : B →+* C,	h : (g.comp f).finite,	_inst : algebra A B := f.to_algebra	⊢ g.finite", "decl_nm": "ring_hom.finite.of_comp_finite"
{"src": "A : Type u_1,	B : Type u_2,	C : Type u_3,	_inst_1 : comm_ring A,	_inst_2 : comm_ring B,	_inst_3 : comm_ring C,	f : A →+* B,	g : B →+* C,	h : (g.comp f).finite,	_inst : algebra A B := f.to_algebra,	_inst_4 : algebra B C := g.to_algebra	⊢ g.finite", "decl_nm": "ring_hom.finite.of_comp_finite"
{"src": "A : Type u_1,	B : Type u_2,	C : Type u_3,	_inst_1 : comm_ring A,	_inst_2 : comm_ring B,	_inst_3 : comm_ring C,	f : A →+* B,	g : B →+* C,	h : (g.comp f).finite,	_inst : algebra A B := f.to_algebra,	_inst_4 : algebra B C := g.to_algebra,	_inst_5 : algebra A C := (g.comp f).to_algebra	⊢ g.finite", "decl_nm": "ring_hom.finite.of_comp_finite"
{"src": "A : Type u_1,	B : Type u_2,	C : Type u_3,	_inst_1 : comm_ring A,	_inst_2 : comm_ring B,	_inst_3 : comm_ring C,	f : A →+* B,	g : B →+* C,	h : (g.comp f).finite,	_inst : algebra A B := f.to_algebra,	_inst_4 : algebra B C := g.to_algebra,	_inst_5 : algebra A C := (g.comp f).to_algebra,	_inst_6 : is_scalar_tower A B C := restrict_scalars.is_scalar_tower A B C	⊢ g.finite", "decl_nm": "ring_hom.finite.of_comp_finite"
{"src": "A : Type u_1,	B : Type u_2,	C : Type u_3,	_inst_1 : comm_ring A,	_inst_2 : comm_ring B,	_inst_3 : comm_ring C,	f : A →+* B,	g : B →+* C,	h : (g.comp f).finite,	_inst : algebra A B := f.to_algebra,	_inst_4 : algebra B C := g.to_algebra,	_inst_5 : algebra A C := (g.comp f).to_algebra,	_inst_6 : is_scalar_tower A B C := restrict_scalars.is_scalar_tower A B C,	_inst_7 : module.finite A C := h	⊢ g.finite", "decl_nm": "ring_hom.finite.of_comp_finite"
{"src": "⊢ ∀ {R : Type u_1} {M : Type u_2} [_inst_1 : comm_ring R] [_inst_2 : comm_monoid M] [_inst_3 : nontrivial R] {m : M}	  {S : set M}, ⇑(of R M) m ∈ span R (⇑(of R M) '' S) ↔ m ∈ S", "decl_nm": "monoid_algebra.of_mem_span_of_iff"
{"src": "R : Type u_1,	M : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_monoid M,	_inst_3 : nontrivial R,	m : M,	S : set M	⊢ ⇑(of R M) m ∈ span R (⇑(of R M) '' S) ↔ m ∈ S", "decl_nm": "monoid_algebra.of_mem_span_of_iff"
{"src": "R : Type u_1,	M : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_monoid M,	_inst_3 : nontrivial R,	m : M,	S : set M,	h : ⇑(of R M) m ∈ span R (⇑(of R M) '' S)	⊢ m ∈ S", "decl_nm": "monoid_algebra.of_mem_span_of_iff"
{"src": "R : Type u_1,	M : Type u_2,	_inst_1 : comm_ring R,	_inst_2 : comm_monoid M,	_inst_3 : nontrivial R,	m : M,	S : set M,	h : ↑{m} ⊆ S	⊢ m ∈ S", "decl_nm": "monoid_algebra.of_mem_span_of_iff"
{"src": "⊢ ∀ {R : Type u_1} [_inst_1 : comm_ring R] {S : submonoid R} {P : Type u_2} [_inst_2 : comm_ring P]	  [_inst_3 : algebra R P] [loc : is_localization S P], span_singleton S 1 = 1", "decl_nm": "fractional_ideal.span_singleton_one"
{"src": "R : Type u_1,	_inst_1 : comm_ring R,	S : submonoid R,	P : Type u_2,	_inst_2 : comm_ring P,	_inst_3 : algebra R P,	loc : is_localization S P	⊢ span_singleton S 1 = 1", "decl_nm": "fractional_ideal.span_singleton_one"
{"src": "R : Type u_1,	_inst_1 : comm_ring R,	S : submonoid R,	P : Type u_2,	_inst_2 : comm_ring P,	_inst_3 : algebra R P,	loc : is_localization S P,	x : P	⊢ x ∈ span_singleton S 1 ↔ x ∈ 1", "decl_nm": "fractional_ideal.span_singleton_one"
{"src": "R : Type u_1,	_inst_1 : comm_ring R,	S : submonoid R,	P : Type u_2,	_inst_2 : comm_ring P,	_inst_3 : algebra R P,	loc : is_localization S P,	x : P	⊢ ∀ (a : R), a • 1 = x ↔ ⇑(algebra_map R P) a = x", "decl_nm": "fractional_ideal.span_singleton_one"
{"src": "R : Type u_1,	_inst_1 : comm_ring R,	S : submonoid R,	P : Type u_2,	_inst_2 : comm_ring P,	_inst_3 : algebra R P,	loc : is_localization S P,	x : P,	x' : R	⊢ x' • 1 = x ↔ ⇑(algebra_map R P) x' = x", "decl_nm": "fractional_ideal.span_singleton_one"
{"src": "⊢ ∀ {R : Type u_1} [_inst_1 : comm_ring R] {S : submonoid R} {P : Type u_2} [_inst_2 : comm_ring P]	  [_inst_3 : algebra R P] {I : submodule R P} {J : fractional_ideal S P}, I ≤ ↑J → is_fractional S I", "decl_nm": "fractional_ideal.is_fractional_of_le"
{"src": "R : Type u_1,	_inst_1 : comm_ring R,	S : submonoid R,	P : Type u_2,	_inst_2 : comm_ring P,	_inst_3 : algebra R P,	I : submodule R P,	J : fractional_ideal S P,	hIJ : I ≤ ↑J	⊢ is_fractional S I", "decl_nm": "fractional_ideal.is_fractional_of_le"
{"src": "R : Type u_1,	_inst_1 : comm_ring R,	S : submonoid R,	P : Type u_2,	_inst_2 : comm_ring P,	_inst_3 : algebra R P,	I : submodule R P,	J : fractional_ideal S P,	hIJ : I ≤ ↑J,	a : R,	a_mem : a ∈ S,	ha : ∀ (b : P), b ∈ ↑J → is_integer R (a • b)	⊢ is_fractional S I", "decl_nm": "fractional_ideal.is_fractional_of_le"
{"src": "R : Type u_1,	_inst_1 : comm_ring R,	S : submonoid R,	P : Type u_2,	_inst_2 : comm_ring P,	_inst_3 : algebra R P,	I : submodule R P,	J : fractional_ideal S P,	hIJ : I ≤ ↑J,	a : R,	a_mem : a ∈ S,	ha : ∀ (b : P), b ∈ ↑J → is_integer R (a • b)	⊢ ∀ (b : P), b ∈ I → is_integer R (a • b)", "decl_nm": "fractional_ideal.is_fractional_of_le"
{"src": "R : Type u_1,	_inst_1 : comm_ring R,	S : submonoid R,	P : Type u_2,	_inst_2 : comm_ring P,	_inst_3 : algebra R P,	I : submodule R P,	J : fractional_ideal S P,	hIJ : I ≤ ↑J,	a : R,	a_mem : a ∈ S,	ha : ∀ (b : P), b ∈ ↑J → is_integer R (a • b),	b : P,	b_mem : b ∈ I	⊢ is_integer R (a • b)", "decl_nm": "fractional_ideal.is_fractional_of_le"
{"src": "⊢ ∀ {R : Type u} {S : Type v} [_inst_1 : ring R] [_inst_2 : ring S] (I : ideal R) (f : R ≃+* S),	    comap ↑f (comap ↑(f.symm) I) = I", "decl_nm": "ideal.comap_of_equiv"
{"src": "R : Type u,	S : Type v,	_inst_1 : ring R,	_inst_2 : ring S,	I : ideal R,	f : R ≃+* S	⊢ comap ↑f (comap ↑(f.symm) I) = I", "decl_nm": "ideal.comap_of_equiv"
{"src": "⊢ ∀ {R : Type u_1} [_inst_1 : comm_ring R] {S : Type u_2} [_inst_2 : comm_ring S] {I J : ideal S}	  [_inst_3 : algebra R S] [hI : I.is_prime],	    I ≤ J →	    ∀ {x : S}, x ∈ ↑J \ ↑I → is_integral R x → comap (algebra_map R S) I < comap (algebra_map R S) J", "decl_nm": "ideal.comap_lt_comap_of_integral_mem_sdiff"
{"src": "R : Type u_1,	_inst_1 : comm_ring R,	S : Type u_2,	_inst_2 : comm_ring S,	I J : ideal S,	_inst_3 : algebra R S,	hI : I.is_prime,	hIJ : I ≤ J,	x : S,	mem : x ∈ ↑J \ ↑I,	integral : is_integral R x	⊢ comap (algebra_map R S) I < comap (algebra_map R S) J", "decl_nm": "ideal.comap_lt_comap_of_integral_mem_sdiff"
{"src": "R : Type u_1,	_inst_1 : comm_ring R,	S : Type u_2,	_inst_2 : comm_ring S,	I J : ideal S,	_inst_3 : algebra R S,	hI : I.is_prime,	hIJ : I ≤ J,	x : S,	mem : x ∈ ↑J \ ↑I,	p : polynomial R,	p_monic : p.monic,	hpx : eval₂ (algebra_map R S) x p = 0	⊢ comap (algebra_map R S) I < comap (algebra_map R S) J", "decl_nm": "ideal.comap_lt_comap_of_integral_mem_sdiff"
{"src": "3 goals	R : Type u_1,	_inst_1 : comm_ring R,	S : Type u_2,	_inst_2 : comm_ring S,	I J : ideal S,	_inst_3 : algebra R S,	hI : I.is_prime,	hIJ : I ≤ J,	x : S,	mem : x ∈ ↑J \ ↑I,	p : polynomial R,	p_monic : p.monic,	hpx : eval₂ (algebra_map R S) x p = 0	⊢ polynomial R		R : Type u_1,	_inst_1 : comm_ring R,	S : Type u_2,	_inst_2 : comm_ring S,	I J : ideal S,	_inst_3 : algebra R S,	hI : I.is_prime,	hIJ : I ≤ J,	x : S,	mem : x ∈ ↑J \ ↑I,	p : polynomial R,	p_monic : p.monic,	hpx : eval₂ (algebra_map R S) x p = 0	⊢ map (quotient.mk (comap (algebra_map R S) I)) ?m_1 ≠ 0		R : Type u_1,	_inst_1 : comm_ring R,	S : Type u_2,	_inst_2 : comm_ring S,	I J : ideal S,	_inst_3 : algebra R S,	hI : I.is_prime,	hIJ : I ≤ J,	x : S,	mem : x ∈ ↑J \ ↑I,	p : polynomial R,	p_monic : p.monic,	hpx : eval₂ (algebra_map R S) x p = 0	⊢ eval₂ (algebra_map R S) x ?m_1 ∈ I", "decl_nm": "ideal.comap_lt_comap_of_integral_mem_sdiff"
{"src": "3 goals	R : Type u_1,	_inst_1 : comm_ring R,	S : Type u_2,	_inst_2 : comm_ring S,	I J : ideal S,	_inst_3 : algebra R S,	hI : I.is_prime,	hIJ : I ≤ J,	x : S,	mem : x ∈ ↑J \ ↑I,	p : polynomial R,	p_monic : p.monic,	hpx : eval₂ (algebra_map R S) x p = 0	⊢ map (quotient.mk (comap (algebra_map R S) I)) ?m_1 ≠ 0		R : Type u_1,	_inst_1 : comm_ring R,	S : Type u_2,	_inst_2 : comm_ring S,	I J : ideal S,	_inst_3 : algebra R S,	hI : I.is_prime,	hIJ : I ≤ J,	x : S,	mem : x ∈ ↑J \ ↑I,	p : polynomial R,	p_monic : p.monic,	hpx : eval₂ (algebra_map R S) x p = 0	⊢ polynomial R		R : Type u_1,	_inst_1 : comm_ring R,	S : Type u_2,	_inst_2 : comm_ring S,	I J : ideal S,	_inst_3 : algebra R S,	hI : I.is_prime,	hIJ : I ≤ J,	x : S,	mem : x ∈ ↑J \ ↑I,	p : polynomial R,	p_monic : p.monic,	hpx : eval₂ (algebra_map R S) x p = 0	⊢ eval₂ (algebra_map R S) x ?m_1 ∈ I", "decl_nm": "ideal.comap_lt_comap_of_integral_mem_sdiff"
{"src": "2 goals	R : Type u_1,	_inst_1 : comm_ring R,	S : Type u_2,	_inst_2 : comm_ring S,	I J : ideal S,	_inst_3 : algebra R S,	hI : I.is_prime,	hIJ : I ≤ J,	x : S,	mem : x ∈ ↑J \ ↑I,	p : polynomial R,	p_monic : p.monic,	hpx : eval₂ (algebra_map R S) x p = 0	⊢ nontrivial (R ⧸ comap (algebra_map R S) I)		R : Type u_1,	_inst_1 : comm_ring R,	S : Type u_2,	_inst_2 : comm_ring S,	I J : ideal S,	_inst_3 : algebra R S,	hI : I.is_prime,	hIJ : I ≤ J,	x : S,	mem : x ∈ ↑J \ ↑I,	p : polynomial R,	p_monic : p.monic,	hpx : eval₂ (algebra_map R S) x p = 0	⊢ eval₂ (algebra_map R S) x p ∈ I", "decl_nm": "ideal.comap_lt_comap_of_integral_mem_sdiff"
{"src": "2 goals	R : Type u_1,	_inst_1 : comm_ring R,	S : Type u_2,	_inst_2 : comm_ring S,	I J : ideal S,	_inst_3 : algebra R S,	hI : I.is_prime,	hIJ : I ≤ J,	x : S,	mem : x ∈ ↑J \ ↑I,	p : polynomial R,	p_monic : p.monic,	hpx : eval₂ (algebra_map R S) x p = 0	⊢ comap (algebra_map R S) I ≠ ⊤		R : Type u_1,	_inst_1 : comm_ring R,	S : Type u_2,	_inst_2 : comm_ring S,	I J : ideal S,	_inst_3 : algebra R S,	hI : I.is_prime,	hIJ : I ≤ J,	x : S,	mem : x ∈ ↑J \ ↑I,	p : polynomial R,	p_monic : p.monic,	hpx : eval₂ (algebra_map R S) x p = 0	⊢ eval₂ (algebra_map R S) x p ∈ I", "decl_nm": "ideal.comap_lt_comap_of_integral_mem_sdiff"
{"src": "2 goals	R : Type u_1,	_inst_1 : comm_ring R,	S : Type u_2,	_inst_2 : comm_ring S,	I J : ideal S,	_inst_3 : algebra R S,	hI : I.is_prime,	hIJ : I ≤ J,	x : S,	mem : x ∈ ↑J \ ↑I,	p : polynomial R,	p_monic : p.monic,	hpx : eval₂ (algebra_map R S) x p = 0	⊢ ¬I = ⊤		R : Type u_1,	_inst_1 : comm_ring R,	S : Type u_2,	_inst_2 : comm_ring S,	I J : ideal S,	_inst_3 : algebra R S,	hI : I.is_prime,	hIJ : I ≤ J,	x : S,	mem : x ∈ ↑J \ ↑I,	p : polynomial R,	p_monic : p.monic,	hpx : eval₂ (algebra_map R S) x p = 0	⊢ eval₂ (algebra_map R S) x p ∈ I", "decl_nm": "ideal.comap_lt_comap_of_integral_mem_sdiff"
{"src": "R : Type u_1,	_inst_1 : comm_ring R,	S : Type u_2,	_inst_2 : comm_ring S,	I J : ideal S,	_inst_3 : algebra R S,	hI : I.is_prime,	hIJ : I ≤ J,	x : S,	mem : x ∈ ↑J \ ↑I,	p : polynomial R,	p_monic : p.monic,	hpx : eval₂ (algebra_map R S) x p = 0	⊢ eval₂ (algebra_map R S) x p ∈ I", "decl_nm": "ideal.comap_lt_comap_of_integral_mem_sdiff"
{"src": "⊢ ∀ {R : Type u} [_inst_1 : semiring R] (x : laurent_series R),	    ⇑(single (order x)) 1 * ↑(x.power_series_part) = x", "decl_nm": "laurent_series.single_order_mul_power_series_part"
{"src": "R : Type u,	_inst_1 : semiring R,	x : laurent_series R	⊢ ⇑(single (order x)) 1 * ↑(x.power_series_part) = x", "decl_nm": "laurent_series.single_order_mul_power_series_part"
{"src": "R : Type u,	_inst_1 : semiring R,	x : laurent_series R,	n : ℤ	⊢ (⇑(single (order x)) 1 * ↑(x.power_series_part)).coeff n = x.coeff n", "decl_nm": "laurent_series.single_order_mul_power_series_part"
{"src": "R : Type u,	_inst_1 : semiring R,	x : laurent_series R,	n : ℤ	⊢ ↑(x.power_series_part).coeff (n - order x) = x.coeff n", "decl_nm": "laurent_series.single_order_mul_power_series_part"
{"src": "2 goals	R : Type u,	_inst_1 : semiring R,	x : laurent_series R,	n : ℤ,	h : order x ≤ n	⊢ ↑(x.power_series_part).coeff (n - order x) = x.coeff n		R : Type u,	_inst_1 : semiring R,	x : laurent_series R,	n : ℤ,	h : ¬order x ≤ n	⊢ ↑(x.power_series_part).coeff (n - order x) = x.coeff n", "decl_nm": "laurent_series.single_order_mul_power_series_part"
{"src": "R : Type u,	_inst_1 : semiring R,	x : laurent_series R,	n : ℤ,	h : ¬order x ≤ n	⊢ ↑(x.power_series_part).coeff (n - order x) = x.coeff n", "decl_nm": "laurent_series.single_order_mul_power_series_part"
{"src": "2 goals	R : Type u,	_inst_1 : semiring R,	x : laurent_series R,	n : ℤ,	h : ¬order x ≤ n	⊢ 0 = x.coeff n		R : Type u,	_inst_1 : semiring R,	x : laurent_series R,	n : ℤ,	h : ¬order x ≤ n	⊢ n - order x ∉ set.range ⇑{to_embedding := {to_fun := coe coe_to_lift, inj' := _}, map_rel_iff' := _}", "decl_nm": "laurent_series.single_order_mul_power_series_part"
{"src": "2 goals	R : Type u,	_inst_1 : semiring R,	x : laurent_series R,	n : ℤ,	h : 0 ≠ x.coeff n	⊢ order x ≤ n		R : Type u,	_inst_1 : semiring R,	x : laurent_series R,	n : ℤ,	h : ¬order x ≤ n	⊢ n - order x ∉ set.range ⇑{to_embedding := {to_fun := coe coe_to_lift, inj' := _}, map_rel_iff' := _}", "decl_nm": "laurent_series.single_order_mul_power_series_part"
{"src": "R : Type u,	_inst_1 : semiring R,	x : laurent_series R,	n : ℤ,	h : ¬order x ≤ n	⊢ n - order x ∉ set.range ⇑{to_embedding := {to_fun := coe coe_to_lift, inj' := _}, map_rel_iff' := _}", "decl_nm": "laurent_series.single_order_mul_power_series_part"
{"src": "R : Type u,	_inst_1 : semiring R,	x : laurent_series R,	n : ℤ,	h : n - order x ∈ set.range ⇑{to_embedding := {to_fun := coe coe_to_lift, inj' := _}, map_rel_iff' := _}	⊢ order x ≤ n", "decl_nm": "laurent_series.single_order_mul_power_series_part"
{"src": "R : Type u,	_inst_1 : semiring R,	x : laurent_series R,	n : ℤ,	h : ∃ (y : ℕ), ↑y = n - order x	⊢ order x ≤ n", "decl_nm": "laurent_series.single_order_mul_power_series_part"
{"src": "R : Type u,	_inst_1 : semiring R,	x : laurent_series R,	n : ℤ,	m : ℕ,	hm : ↑m = n - order x	⊢ order x ≤ n", "decl_nm": "laurent_series.single_order_mul_power_series_part"
{"src": "R : Type u,	_inst_1 : semiring R,	x : laurent_series R,	n : ℤ,	m : ℕ,	hm : ↑m = n - order x	⊢ 0 ≤ ↑m", "decl_nm": "laurent_series.single_order_mul_power_series_part"
{"src": "⊢ ∀ {R : Type u_1} [_inst_1 : comm_ring R] (S : Type u_2) [_inst_2 : comm_ring S] [_inst_3 : algebra R S],	    coe_submodule S ⊤ = 1", "decl_nm": "is_localization.coe_submodule_top"
{"src": "R : Type u_1,	_inst_1 : comm_ring R,	S : Type u_2,	_inst_2 : comm_ring S,	_inst_3 : algebra R S	⊢ coe_submodule S ⊤ = 1", "decl_nm": "is_localization.coe_submodule_top"
{"src": "⊢ ∀ (R : Type u) [_inst_1 : comm_semiring R] (A : Type v) [_inst_2 : semiring A] [_inst_3 : algebra R A]	  (n : Type w) [_inst_4 : fintype n] [_inst_5 : decidable_eq n] (a : A) (M : matrix n n R),	    ⇑((matrix_equiv_tensor R A n).symm) (a ⊗ₜ[R] M) = λ (i j : n), a * ⇑(algebra_map R A) (M i j)", "decl_nm": "matrix_equiv_tensor_apply_symm"
{"src": "R : Type u,	_inst_1 : comm_semiring R,	A : Type v,	_inst_2 : semiring A,	_inst_3 : algebra R A,	n : Type w,	_inst_4 : fintype n,	_inst_5 : decidable_eq n,	a : A,	M : matrix n n R	⊢ ⇑((matrix_equiv_tensor R A n).symm) (a ⊗ₜ[R] M) = λ (i j : n), a * ⇑(algebra_map R A) (M i j)", "decl_nm": "matrix_equiv_tensor_apply_symm"
{"src": "R : Type u,	_inst_1 : comm_semiring R,	A : Type v,	_inst_2 : semiring A,	_inst_3 : algebra R A,	n : Type w,	_inst_4 : fintype n,	_inst_5 : decidable_eq n,	a : A,	M : matrix n n R	⊢ ⇑(⇑(to_fun_bilinear R A n) a) M = λ (i j : n), a * ⇑(algebra_map R A) (M i j)", "decl_nm": "matrix_equiv_tensor_apply_symm"
{"src": "⊢ ∀ {R : Type u_1} {M : Type u_2} [_inst_1 : ring R] [_inst_2 : add_comm_group M] [_inst_3 : module R M]	  [_inst_8 : nontrivial R] [_inst_9 : is_noetherian R M] {s : set M}, linear_independent R coe → s.finite", "decl_nm": "finite_of_linear_independent"
{"src": "R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe	⊢ s.finite", "decl_nm": "finite_of_linear_independent"
{"src": "R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite	⊢ gt ↪r gt", "decl_nm": "finite_of_linear_independent"
{"src": "2 goals	R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite	⊢ ℕ ↪ ↥s		R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s	⊢ gt ↪r gt", "decl_nm": "finite_of_linear_independent"
{"src": "R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s	⊢ gt ↪r gt", "decl_nm": "finite_of_linear_independent"
{"src": "2 goals	R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s	⊢ ∀ (n : ℕ), coe ∘ ⇑f '' {m : ℕ | m ≤ n} ⊆ s		R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s,	this : ∀ (n : ℕ), coe ∘ ⇑f '' {m : ℕ | m ≤ n} ⊆ s	⊢ gt ↪r gt", "decl_nm": "finite_of_linear_independent"
{"src": "2 goals	R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s,	n : ℕ,	x : M,	y : ℕ,	hy₁ : y ∈ {m : ℕ | m ≤ n},	hy₂ : (coe ∘ ⇑f) y = x	⊢ x ∈ s		R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s,	this : ∀ (n : ℕ), coe ∘ ⇑f '' {m : ℕ | m ≤ n} ⊆ s	⊢ gt ↪r gt", "decl_nm": "finite_of_linear_independent"
{"src": "2 goals	R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s,	n y : ℕ,	hy₁ : y ∈ {m : ℕ | m ≤ n}	⊢ (coe ∘ ⇑f) y ∈ s		R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s,	this : ∀ (n : ℕ), coe ∘ ⇑f '' {m : ℕ | m ≤ n} ⊆ s	⊢ gt ↪r gt", "decl_nm": "finite_of_linear_independent"
{"src": "R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s,	this : ∀ (n : ℕ), coe ∘ ⇑f '' {m : ℕ | m ≤ n} ⊆ s	⊢ gt ↪r gt", "decl_nm": "finite_of_linear_independent"
{"src": "8 goals	R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s,	this : ∀ (n : ℕ), coe ∘ ⇑f '' {m : ℕ | m ≤ n} ⊆ s	⊢ ∀ (a b : ℕ),	    a ≤ b ↔ span R (coe ∘ ⇑f '' {m : ℕ | m ≤ a}) ≤ span R (coe ∘ ⇑f '' {m : ℕ | m ≤ b})		R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s,	this : ∀ (n : ℕ), coe ∘ ⇑f '' {m : ℕ | m ≤ n} ⊆ s,	this :	  ∀ (a b : ℕ),	    a ≤ b ↔ span R (coe ∘ ⇑f '' {m : ℕ | m ≤ a}) ≤ span R (coe ∘ ⇑f '' {m : ℕ | m ≤ b})	⊢ gt ↪r gt		R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s,	this : ∀ (n : ℕ), coe ∘ ⇑f '' {m : ℕ | m ≤ n} ⊆ s,	a b : ℕ	⊢ Type ?		R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s,	this : ∀ (n : ℕ), coe ∘ ⇑f '' {m : ℕ | m ≤ n} ⊆ s,	a b : ℕ	⊢ add_comm_monoid ?m_1		R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s,	this : ∀ (n : ℕ), coe ∘ ⇑f '' {m : ℕ | m ≤ n} ⊆ s,	a b : ℕ	⊢ module R ?m_1		R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s,	this : ∀ (n : ℕ), coe ∘ ⇑f '' {m : ℕ | m ≤ n} ⊆ s,	a b : ℕ	⊢ has_le (submodule R ?m_1)		R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s,	this : ∀ (n : ℕ), coe ∘ ⇑f '' {m : ℕ | m ≤ n} ⊆ s,	a b : ℕ	⊢ has_lift_t ↥s ?m_1		R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s,	this : ∀ (n : ℕ), coe ∘ ⇑f '' {m : ℕ | m ≤ n} ⊆ s,	a b : ℕ	⊢ has_lift_t ↥s ?m_1", "decl_nm": "finite_of_linear_independent"
{"src": "8 goals	R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s,	this : ∀ (n : ℕ), coe ∘ ⇑f '' {m : ℕ | m ≤ n} ⊆ s,	a b : ℕ	⊢ a ≤ b ↔ span R (coe ∘ ⇑f '' {m : ℕ | m ≤ a}) ≤ span R (coe ∘ ⇑f '' {m : ℕ | m ≤ b})		R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s,	this : ∀ (n : ℕ), coe ∘ ⇑f '' {m : ℕ | m ≤ n} ⊆ s,	this :	  ∀ (a b : ℕ),	    a ≤ b ↔ span R (coe ∘ ⇑f '' {m : ℕ | m ≤ a}) ≤ span R (coe ∘ ⇑f '' {m : ℕ | m ≤ b})	⊢ gt ↪r gt		R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s,	this : ∀ (n : ℕ), coe ∘ ⇑f '' {m : ℕ | m ≤ n} ⊆ s,	a b : ℕ	⊢ Type ?		R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s,	this : ∀ (n : ℕ), coe ∘ ⇑f '' {m : ℕ | m ≤ n} ⊆ s,	a b : ℕ	⊢ add_comm_monoid ?m_1		R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s,	this : ∀ (n : ℕ), coe ∘ ⇑f '' {m : ℕ | m ≤ n} ⊆ s,	a b : ℕ	⊢ module R ?m_1		R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s,	this : ∀ (n : ℕ), coe ∘ ⇑f '' {m : ℕ | m ≤ n} ⊆ s,	a b : ℕ	⊢ has_le (submodule R ?m_1)		R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s,	this : ∀ (n : ℕ), coe ∘ ⇑f '' {m : ℕ | m ≤ n} ⊆ s,	a b : ℕ	⊢ has_lift_t ↥s ?m_1		R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s,	this : ∀ (n : ℕ), coe ∘ ⇑f '' {m : ℕ | m ≤ n} ⊆ s,	a b : ℕ	⊢ has_lift_t ↥s ?m_1", "decl_nm": "finite_of_linear_independent"
{"src": "2 goals	R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s,	this : ∀ (n : ℕ), coe ∘ ⇑f '' {m : ℕ | m ≤ n} ⊆ s,	a b : ℕ	⊢ a ≤ b ↔ ∀ (x : ℕ), x ∈ {m : ℕ | m ≤ a} → x ∈ {m : ℕ | m ≤ b}		R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s,	this : ∀ (n : ℕ), coe ∘ ⇑f '' {m : ℕ | m ≤ n} ⊆ s,	this :	  ∀ (a b : ℕ),	    a ≤ b ↔ span R (coe ∘ ⇑f '' {m : ℕ | m ≤ a}) ≤ span R (coe ∘ ⇑f '' {m : ℕ | m ≤ b})	⊢ gt ↪r gt", "decl_nm": "finite_of_linear_independent"
{"src": "R : Type u_1,	M : Type u_2,	_inst_1 : ring R,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	_inst_8 : nontrivial R,	_inst_9 : is_noetherian R M,	s : set M,	hs : linear_independent R coe,	hf : ¬s.finite,	f : ℕ ↪ ↥s,	this : ∀ (n : ℕ), coe ∘ ⇑f '' {m : ℕ | m ≤ n} ⊆ s,	this :	  ∀ (a b : ℕ),	    a ≤ b ↔ span R (coe ∘ ⇑f '' {m : ℕ | m ≤ a}) ≤ span R (coe ∘ ⇑f '' {m : ℕ | m ≤ b})	⊢ gt ↪r gt", "decl_nm": "finite_of_linear_independent"
{"src": "⊢ ∀ {k : Type u_1} [_inst_1 : field k] {σ : Type u_2} (I : ideal (mv_polynomial σ k)),	    I.radical ≤ vanishing_ideal (zero_locus I)", "decl_nm": "mv_polynomial.radical_le_vanishing_ideal_zero_locus"
{"src": "k : Type u_1,	_inst_1 : field k,	σ : Type u_2,	I : ideal (mv_polynomial σ k)	⊢ I.radical ≤ vanishing_ideal (zero_locus I)", "decl_nm": "mv_polynomial.radical_le_vanishing_ideal_zero_locus"
{"src": "k : Type u_1,	_inst_1 : field k,	σ : Type u_2,	I : ideal (mv_polynomial σ k),	p : mv_polynomial σ k,	hp : p ∈ I.radical,	x : σ → k,	hx : x ∈ zero_locus I	⊢ ⇑(eval x) p = 0", "decl_nm": "mv_polynomial.radical_le_vanishing_ideal_zero_locus"
{"src": "k : Type u_1,	_inst_1 : field k,	σ : Type u_2,	I : ideal (mv_polynomial σ k),	p : mv_polynomial σ k,	hp : p ∈ I.radical,	x : σ → k,	hx : x ∈ zero_locus I	⊢ p ∈ vanishing_ideal {x}", "decl_nm": "mv_polynomial.radical_le_vanishing_ideal_zero_locus"
{"src": "k : Type u_1,	_inst_1 : field k,	σ : Type u_2,	I : ideal (mv_polynomial σ k),	p : mv_polynomial σ k,	x : σ → k,	hx : x ∈ zero_locus I,	hp : p ∈ Inf {J : ideal (mv_polynomial σ k) | I ≤ J ∧ J.is_prime}	⊢ p ∈ vanishing_ideal {x}", "decl_nm": "mv_polynomial.radical_le_vanishing_ideal_zero_locus"
{"src": "⊢ ∀ {R : Type u} [_inst_1 : comm_ring R] (p : polynomial R), p.restriction.support = p.support", "decl_nm": "polynomial.support_restriction"
{"src": "R : Type u,	_inst_1 : comm_ring R,	p : polynomial R	⊢ p.restriction.support = p.support", "decl_nm": "polynomial.support_restriction"
{"src": "R : Type u,	_inst_1 : comm_ring R,	p : polynomial R,	i : ℕ	⊢ i ∈ p.restriction.support ↔ i ∈ p.support", "decl_nm": "polynomial.support_restriction"
{"src": "R : Type u,	_inst_1 : comm_ring R,	p : polynomial R,	i : ℕ	⊢ p.restriction.coeff i = 0 ↔ p.coeff i = 0", "decl_nm": "polynomial.support_restriction"
{"src": "R : Type u,	_inst_1 : comm_ring R,	p : polynomial R,	i : ℕ	⊢ p.restriction.coeff i = 0 ↔ ↑(p.restriction.coeff i) = 0", "decl_nm": "polynomial.support_restriction"
{"src": "⊢ ∀ {R : Type u} [_inst_1 : comm_ring R], 0.restriction = 0", "decl_nm": "polynomial.restriction_zero"
{"src": "R : Type u,	_inst_1 : comm_ring R	⊢ 0.restriction = 0", "decl_nm": "polynomial.restriction_zero"
{"src": "⊢ ∀ (R : Type u_1) [_inst_1 : comm_ring R] (n ν : ℕ),	    ⇑derivative (bernstein_polynomial R (n + 1) (ν + 1)) =	      (↑n + 1) * (bernstein_polynomial R n ν - bernstein_polynomial R n (ν + 1))", "decl_nm": "bernstein_polynomial.derivative_succ_aux"
{"src": "R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ ⇑derivative (bernstein_polynomial R (n + 1) (ν + 1)) =	    (↑n + 1) * (bernstein_polynomial R n ν - bernstein_polynomial R n (ν + 1))", "decl_nm": "bernstein_polynomial.derivative_succ_aux"
{"src": "R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ ⇑derivative (↑((n + 1).choose (ν + 1)) * X ^ (ν + 1) * (1 - X) ^ (n + 1 - (ν + 1))) =	    (↑n + 1) *	      (↑(n.choose ν) * X ^ ν * (1 - X) ^ (n - ν) -	         ↑(n.choose (ν + 1)) * X ^ (ν + 1) * (1 - X) ^ (n - (ν + 1)))", "decl_nm": "bernstein_polynomial.derivative_succ_aux"
{"src": "44 goals	R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ,	this :	  ↑((n + 1).choose (ν + 1)) * ((↑ν + 1) * X ^ ν) * (1 - X) ^ (n - ν) -	      ↑((n + 1).choose (ν + 1)) * X ^ (ν + 1) * (↑(n - ν) * (1 - X) ^ (n - ν - 1)) =	    (↑n + 1) *	      (↑(n.choose ν) * X ^ ν * (1 - X) ^ (n - ν) -	         ↑(n.choose (ν + 1)) * X ^ (ν + 1) * (1 - X) ^ (n - (ν + 1)))	⊢ ⇑derivative (↑((n + 1).choose (ν + 1)) * X ^ (ν + 1) * (1 - X) ^ (n + 1 - (ν + 1))) =	    (↑n + 1) *	      (↑(n.choose ν) * X ^ ν * (1 - X) ^ (n - ν) -	         ↑(n.choose (ν + 1)) * X ^ (ν + 1) * (1 - X) ^ (n - (ν + 1)))		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ ↑((n + 1).choose (ν + 1)) * ((↑ν + 1) * X ^ ν) * (1 - X) ^ (n - ν) -	      ↑((n + 1).choose (ν + 1)) * X ^ (ν + 1) * (↑(n - ν) * (1 - X) ^ (n - ν - 1)) =	    (↑n + 1) *	      (↑(n.choose ν) * X ^ ν * (1 - X) ^ (n - ν) -	         ↑(n.choose (ν + 1)) * X ^ (ν + 1) * (1 - X) ^ (n - (ν + 1)))		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ Type ?		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ semiring ?m_1		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_sub (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_mul (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_mul (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_lift_t ℕ (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_mul (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_add (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_lift_t ℕ (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_one (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_pow (polynomial ?m_1) ℕ		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_pow (polynomial ?m_1) ℕ		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_sub (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_one (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_mul (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_mul (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_lift_t ℕ (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_pow (polynomial ?m_1) ℕ		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_mul (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_lift_t ℕ (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_pow (polynomial ?m_1) ℕ		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_sub (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_one (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_mul (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_add (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_lift_t ℕ (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_one (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_sub (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_mul (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_mul (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_lift_t ℕ (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_pow (polynomial ?m_1) ℕ		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_pow (polynomial ?m_1) ℕ		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_sub (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_one (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_mul (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_mul (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_lift_t ℕ (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_pow (polynomial ?m_1) ℕ		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_pow (polynomial ?m_1) ℕ		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_sub (polynomial ?m_1)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ has_one (polynomial ?m_1)", "decl_nm": "bernstein_polynomial.derivative_succ_aux"
{"src": "R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ ↑((n + 1).choose (ν + 1)) * ((↑ν + 1) * X ^ ν) * (1 - X) ^ (n - ν) -	      ↑((n + 1).choose (ν + 1)) * X ^ (ν + 1) * (↑(n - ν) * (1 - X) ^ (n - ν - 1)) =	    (↑n + 1) *	      (↑(n.choose ν) * X ^ ν * (1 - X) ^ (n - ν) -	         ↑(n.choose (ν + 1)) * X ^ (ν + 1) * (1 - X) ^ (n - (ν + 1)))", "decl_nm": "bernstein_polynomial.derivative_succ_aux"
{"src": "R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ ↑((n + 1).choose (ν + 1)) * ((↑ν + 1) * X ^ ν) * (1 - X) ^ (n - ν) -	      ↑((n + 1).choose (ν + 1)) * X ^ (ν + 1) * (↑(n - ν) * (1 - X) ^ (n - ν - 1)) =	    (↑n + 1) * (↑(n.choose ν) * X ^ ν * (1 - X) ^ (n - ν)) -	      (↑n + 1) * (↑(n.choose (ν + 1)) * X ^ (ν + 1) * (1 - X) ^ (n - (ν + 1)))", "decl_nm": "bernstein_polynomial.derivative_succ_aux"
{"src": "2 goals	R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ ↑((n + 1).choose (ν + 1)) * ((↑ν + 1) * X ^ ν) * (1 - X) ^ (n - ν) =	    (↑n + 1) * (↑(n.choose ν) * X ^ ν * (1 - X) ^ (n - ν))		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ ↑((n + 1).choose (ν + 1)) * X ^ (ν + 1) * (↑(n - ν) * (1 - X) ^ (n - ν - 1)) =	    (↑n + 1) * (↑(n.choose (ν + 1)) * X ^ (ν + 1) * (1 - X) ^ (n - (ν + 1)))", "decl_nm": "bernstein_polynomial.derivative_succ_aux"
{"src": "2 goals	R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ ↑((n + 1).choose (ν + 1)) * (↑ν + 1) * X ^ ν * (1 - X) ^ (n - ν) =	    (↑n + 1) * ↑(n.choose ν) * X ^ ν * (1 - X) ^ (n - ν)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ ↑((n + 1).choose (ν + 1)) * X ^ (ν + 1) * (↑(n - ν) * (1 - X) ^ (n - ν - 1)) =	    (↑n + 1) * (↑(n.choose (ν + 1)) * X ^ (ν + 1) * (1 - X) ^ (n - (ν + 1)))", "decl_nm": "bernstein_polynomial.derivative_succ_aux"
{"src": "2 goals	R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ ↑((n + 1).choose (ν + 1)) * (↑ν + 1) = (↑n + 1) * ↑(n.choose ν)		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ ↑((n + 1).choose (ν + 1)) * X ^ (ν + 1) * (↑(n - ν) * (1 - X) ^ (n - ν - 1)) =	    (↑n + 1) * (↑(n.choose (ν + 1)) * X ^ (ν + 1) * (1 - X) ^ (n - (ν + 1)))", "decl_nm": "bernstein_polynomial.derivative_succ_aux"
{"src": "R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ ↑((n + 1).choose (ν + 1)) * X ^ (ν + 1) * (↑(n - ν) * (1 - X) ^ (n - ν - 1)) =	    (↑n + 1) * (↑(n.choose (ν + 1)) * X ^ (ν + 1) * (1 - X) ^ (n - (ν + 1)))", "decl_nm": "bernstein_polynomial.derivative_succ_aux"
{"src": "R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ ↑((n + 1).choose (ν + 1)) * X ^ (ν + 1) * (↑(n - ν) * (1 - X) ^ (n - (ν + 1))) =	    (↑n + 1) * (↑(n.choose (ν + 1)) * X ^ (ν + 1) * (1 - X) ^ (n - (ν + 1)))", "decl_nm": "bernstein_polynomial.derivative_succ_aux"
{"src": "R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ ↑((n + 1).choose (ν + 1)) * X ^ (ν + 1) * ↑(n - ν) * (1 - X) ^ (n - (ν + 1)) =	    (↑n + 1) * (↑(n.choose (ν + 1)) * X ^ (ν + 1)) * (1 - X) ^ (n - (ν + 1))", "decl_nm": "bernstein_polynomial.derivative_succ_aux"
{"src": "R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ ↑((n + 1).choose (ν + 1)) * X ^ (ν + 1) * ↑(n - ν) = (↑n + 1) * (↑(n.choose (ν + 1)) * X ^ (ν + 1))", "decl_nm": "bernstein_polynomial.derivative_succ_aux"
{"src": "R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ ↑(n - ν) * (↑((n + 1).choose (ν + 1)) * X ^ (ν + 1)) = (↑n + 1) * (↑(n.choose (ν + 1)) * X ^ (ν + 1))", "decl_nm": "bernstein_polynomial.derivative_succ_aux"
{"src": "R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ ↑(n - ν) * ↑((n + 1).choose (ν + 1)) * X ^ (ν + 1) = (↑n + 1) * ↑(n.choose (ν + 1)) * X ^ (ν + 1)", "decl_nm": "bernstein_polynomial.derivative_succ_aux"
{"src": "R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ ↑(n - ν) * ↑((n + 1).choose (ν + 1)) = (↑n + 1) * ↑(n.choose (ν + 1))", "decl_nm": "bernstein_polynomial.derivative_succ_aux"
{"src": "R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ ↑((n - ν) * (n + 1).choose (ν + 1)) = ↑((n + 1) * n.choose (ν + 1))", "decl_nm": "bernstein_polynomial.derivative_succ_aux"
{"src": "R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ (n - ν) * (n + 1).choose (ν + 1) = (n + 1) * n.choose (ν + 1)", "decl_nm": "bernstein_polynomial.derivative_succ_aux"
{"src": "2 goals	R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ (n - ν) * (n + 1).choose (ν + 1) = (n + 1).choose (ν + 1) * (n + 1 - (ν + 1))		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ (n + 1) * n.choose (ν + 1) = n.choose (ν + 1) * (n + 1)", "decl_nm": "bernstein_polynomial.derivative_succ_aux"
{"src": "2 goals	R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ n + 1 - (ν + 1) = n - ν		R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ (n + 1) * n.choose (ν + 1) = n.choose (ν + 1) * (n + 1)", "decl_nm": "bernstein_polynomial.derivative_succ_aux"
{"src": "R : Type u_1,	_inst_1 : comm_ring R,	n ν : ℕ	⊢ (n + 1) * n.choose (ν + 1) = n.choose (ν + 1) * (n + 1)", "decl_nm": "bernstein_polynomial.derivative_succ_aux"
{"src": "⊢ ∀ {R : Type u_1} [_inst_1 : comm_ring R] [_inst_2 : is_domain R] [_inst_3 : normalized_gcd_monoid R] {a : R}	  {p q : polynomial R}, ⇑C a ∣ p - q → gcd a p.content = gcd a q.content", "decl_nm": "polynomial.gcd_content_eq_of_dvd_sub"
{"src": "R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : normalized_gcd_monoid R,	a : R,	p q : polynomial R,	h : ⇑C a ∣ p - q	⊢ gcd a p.content = gcd a q.content", "decl_nm": "polynomial.gcd_content_eq_of_dvd_sub"
{"src": "R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : normalized_gcd_monoid R,	a : R,	p q : polynomial R,	h : ⇑C a ∣ p - q	⊢ gcd a ((finset.range (max p.nat_degree q.nat_degree).succ).gcd p.coeff) = gcd a q.content", "decl_nm": "polynomial.gcd_content_eq_of_dvd_sub"
{"src": "R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : normalized_gcd_monoid R,	a : R,	p q : polynomial R,	h : ⇑C a ∣ p - q	⊢ gcd a ((finset.range (max p.nat_degree q.nat_degree).succ).gcd p.coeff) =	    gcd a ((finset.range (max p.nat_degree q.nat_degree).succ).gcd q.coeff)", "decl_nm": "polynomial.gcd_content_eq_of_dvd_sub"
{"src": "R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : normalized_gcd_monoid R,	a : R,	p q : polynomial R,	h : ⇑C a ∣ p - q	⊢ ∀ (x : ℕ), x ∈ finset.range (max p.nat_degree q.nat_degree).succ → a ∣ p.coeff x - q.coeff x", "decl_nm": "polynomial.gcd_content_eq_of_dvd_sub"
{"src": "R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : normalized_gcd_monoid R,	a : R,	p q : polynomial R,	h : ⇑C a ∣ p - q,	x : ℕ,	hx : x ∈ finset.range (max p.nat_degree q.nat_degree).succ	⊢ a ∣ p.coeff x - q.coeff x", "decl_nm": "polynomial.gcd_content_eq_of_dvd_sub"
{"src": "R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : normalized_gcd_monoid R,	a : R,	p q : polynomial R,	x : ℕ,	hx : x ∈ finset.range (max p.nat_degree q.nat_degree).succ,	w : polynomial R,	hw : p - q = ⇑C a * w	⊢ a ∣ p.coeff x - q.coeff x", "decl_nm": "polynomial.gcd_content_eq_of_dvd_sub"
{"src": "R : Type u_1,	_inst_1 : comm_ring R,	_inst_2 : is_domain R,	_inst_3 : normalized_gcd_monoid R,	a : R,	p q : polynomial R,	x : ℕ,	hx : x ∈ finset.range (max p.nat_degree q.nat_degree).succ,	w : polynomial R,	hw : p - q = ⇑C a * w	⊢ p.coeff x - q.coeff x = a * w.coeff x", "decl_nm": "polynomial.gcd_content_eq_of_dvd_sub"
{"src": "⊢ ∀ {σ : Type u_1} (R : Type u_3) [_inst_1 : comm_semiring R] (i : σ), (X i).is_homogeneous 1", "decl_nm": "mv_polynomial.is_homogeneous_X"
{"src": "σ : Type u_1,	R : Type u_3,	_inst_1 : comm_semiring R,	i : σ	⊢ (X i).is_homogeneous 1", "decl_nm": "mv_polynomial.is_homogeneous_X"
{"src": "σ : Type u_1,	R : Type u_3,	_inst_1 : comm_semiring R,	i : σ	⊢ (finsupp.single i 1).support.sum (λ (i_1 : σ), ⇑(finsupp.single i 1) i_1) = 1", "decl_nm": "mv_polynomial.is_homogeneous_X"
{"src": "σ : Type u_1,	R : Type u_3,	_inst_1 : comm_semiring R,	i : σ	⊢ ⇑(finsupp.single i 1) i = 1", "decl_nm": "mv_polynomial.is_homogeneous_X"
{"src": "⊢ ∀ {R : Type u_3} [_inst_4 : comm_ring R] {p : polynomial R} (s : R), (scale_roots p s).monic ↔ p.monic", "decl_nm": "monic_scale_roots_iff"
{"src": "R : Type u_3,	_inst_4 : comm_ring R,	p : polynomial R,	s : R	⊢ (scale_roots p s).monic ↔ p.monic", "decl_nm": "monic_scale_roots_iff"
{"src": "⊢ ∀ {R : Type u_2} [_inst_1 : comm_semiring R], ↑1 = 1", "decl_nm": "polynomial.coe_one"
{"src": "R : Type u_2,	_inst_1 : comm_semiring R	⊢ ↑1 = 1", "decl_nm": "polynomial.coe_one"
{"src": "R : Type u_2,	_inst_1 : comm_semiring R,	this : ↑(⇑(monomial 0) 1) = ⇑(power_series.monomial R 0) 1	⊢ ↑1 = 1", "decl_nm": "polynomial.coe_one"
{"src": "⊢ ∀ {σ : Type u_1} {R : Type u_2} [_inst_1 : semiring R] (n : σ →₀ ℕ) (φ : mv_power_series σ R) (a : R),	    ⇑(coeff R n) (⇑(C σ R) a * φ) = a * ⇑(coeff R n) φ", "decl_nm": "mv_power_series.coeff_C_mul"
{"src": "σ : Type u_1,	R : Type u_2,	_inst_1 : semiring R,	n : σ →₀ ℕ,	φ : mv_power_series σ R,	a : R	⊢ ⇑(coeff R n) (⇑(C σ R) a * φ) = a * ⇑(coeff R n) φ", "decl_nm": "mv_power_series.coeff_C_mul"
{"src": "⊢ ∀ {M : Type u_1} [_inst_1 : comm_monoid M] {k : ℕ} (ζ : M),	    0 < k → ζ ^ k = 1 → (∀ (l : ℕ), 0 < l → l < k → ζ ^ l ≠ 1) → is_primitive_root ζ k", "decl_nm": "is_primitive_root.mk_of_lt"
{"src": "M : Type u_1,	_inst_1 : comm_monoid M,	k : ℕ,	ζ : M,	hk : 0 < k,	h1 : ζ ^ k = 1,	h : ∀ (l : ℕ), 0 < l → l < k → ζ ^ l ≠ 1	⊢ is_primitive_root ζ k", "decl_nm": "is_primitive_root.mk_of_lt"
{"src": "M : Type u_1,	_inst_1 : comm_monoid M,	k : ℕ,	ζ : M,	hk : 0 < k,	h1 : ζ ^ k = 1,	h : ∀ (l : ℕ), 0 < l → l < k → ζ ^ l ≠ 1	⊢ ∀ (l : ℕ), ζ ^ l = 1 → k ∣ l", "decl_nm": "is_primitive_root.mk_of_lt"
{"src": "M : Type u_1,	_inst_1 : comm_monoid M,	k : ℕ,	ζ : M,	hk : 0 < k,	h1 : ζ ^ k = 1,	h : ∀ (l : ℕ), 0 < l → l < k → ζ ^ l ≠ 1,	l : ℕ,	hl : ζ ^ l = 1	⊢ k ∣ l", "decl_nm": "is_primitive_root.mk_of_lt"
{"src": "M : Type u_1,	_inst_1 : comm_monoid M,	k : ℕ,	ζ : M,	hk : 0 < k,	h1 : ζ ^ k = 1,	h : ∀ (l : ℕ), 0 < l → l < k → ζ ^ l ≠ 1,	l : ℕ,	hl : ζ ^ l = 1	⊢ k ∣ k.gcd l", "decl_nm": "is_primitive_root.mk_of_lt"
{"src": "2 goals	M : Type u_1,	_inst_1 : comm_monoid M,	k : ℕ,	ζ : M,	hk : 0 < k,	h1 : ζ ^ k = 1,	h : ∀ (l : ℕ), 0 < l → l < k → ζ ^ l ≠ 1,	l : ℕ,	hl : ζ ^ l = 1,	this : k.gcd l = k	⊢ k ∣ k.gcd l		M : Type u_1,	_inst_1 : comm_monoid M,	k : ℕ,	ζ : M,	hk : 0 < k,	h1 : ζ ^ k = 1,	h : ∀ (l : ℕ), 0 < l → l < k → ζ ^ l ≠ 1,	l : ℕ,	hl : ζ ^ l = 1	⊢ k.gcd l = k", "decl_nm": "is_primitive_root.mk_of_lt"
{"src": "M : Type u_1,	_inst_1 : comm_monoid M,	k : ℕ,	ζ : M,	hk : 0 < k,	h1 : ζ ^ k = 1,	h : ∀ (l : ℕ), 0 < l → l < k → ζ ^ l ≠ 1,	l : ℕ,	hl : ζ ^ l = 1	⊢ k.gcd l = k", "decl_nm": "is_primitive_root.mk_of_lt"
{"src": "M : Type u_1,	_inst_1 : comm_monoid M,	k : ℕ,	ζ : M,	hk : 0 < k,	h1 : ζ ^ k = 1,	h : ∀ (l : ℕ), 0 < l → l < k → ζ ^ l ≠ 1,	l : ℕ,	hl : ζ ^ l = 1	⊢ k.gcd l ≤ k ∧ ¬k.gcd l < k", "decl_nm": "is_primitive_root.mk_of_lt"
{"src": "M : Type u_1,	_inst_1 : comm_monoid M,	k : ℕ,	ζ : M,	hk : 0 < k,	h1 : ζ ^ k = 1,	h : ∀ (l : ℕ), 0 < l → l < k → ζ ^ l ≠ 1,	l : ℕ,	hl : ζ ^ l = 1	⊢ ¬k.gcd l < k", "decl_nm": "is_primitive_root.mk_of_lt"
{"src": "M : Type u_1,	_inst_1 : comm_monoid M,	k : ℕ,	ζ : M,	hk : 0 < k,	h1 : ζ ^ k = 1,	h : ∀ (l : ℕ), 0 < l → l < k → ζ ^ l ≠ 1,	l : ℕ,	hl : ζ ^ l = 1,	h' : k.gcd l < k	⊢ false", "decl_nm": "is_primitive_root.mk_of_lt"
{"src": "M : Type u_1,	_inst_1 : comm_monoid M,	k : ℕ,	ζ : M,	hk : 0 < k,	h1 : ζ ^ k = 1,	h : ∀ (l : ℕ), 0 < l → l < k → ζ ^ l ≠ 1,	l : ℕ,	hl : ζ ^ l = 1,	h' : k.gcd l < k	⊢ ζ ^ k.gcd l = 1", "decl_nm": "is_primitive_root.mk_of_lt"
{"src": "⊢ ∀ {R : Type u_5} {ζ : R} [_inst_5 : comm_ring R] [_inst_6 : is_domain R], is_primitive_root ζ 2 → ζ = -1", "decl_nm": "is_primitive_root.eq_neg_one_of_two_right"
{"src": "R : Type u_5,	ζ : R,	_inst_5 : comm_ring R,	_inst_6 : is_domain R,	h : is_primitive_root ζ 2	⊢ ζ = -1", "decl_nm": "is_primitive_root.eq_neg_one_of_two_right"
{"src": "2 goals	R : Type u_5,	ζ : R,	_inst_5 : comm_ring R,	_inst_6 : is_domain R,	h : is_primitive_root ζ 2	⊢ ¬ζ = 1		R : Type u_5,	ζ : R,	_inst_5 : comm_ring R,	_inst_6 : is_domain R,	h : is_primitive_root ζ 2	⊢ ζ ^ 2 = 1 ^ 2", "decl_nm": "is_primitive_root.eq_neg_one_of_two_right"
{"src": "2 goals	R : Type u_5,	ζ : R,	_inst_5 : comm_ring R,	_inst_6 : is_domain R,	h : is_primitive_root ζ 2	⊢ ¬ζ ^ 1 = 1		R : Type u_5,	ζ : R,	_inst_5 : comm_ring R,	_inst_6 : is_domain R,	h : is_primitive_root ζ 2	⊢ ζ ^ 2 = 1 ^ 2", "decl_nm": "is_primitive_root.eq_neg_one_of_two_right"
{"src": "3 goals	R : Type u_5,	ζ : R,	_inst_5 : comm_ring R,	_inst_6 : is_domain R,	h : is_primitive_root ζ 2	⊢ 0 < 1		R : Type u_5,	ζ : R,	_inst_5 : comm_ring R,	_inst_6 : is_domain R,	h : is_primitive_root ζ 2	⊢ 1 < 2		R : Type u_5,	ζ : R,	_inst_5 : comm_ring R,	_inst_6 : is_domain R,	h : is_primitive_root ζ 2	⊢ ζ ^ 2 = 1 ^ 2", "decl_nm": "is_primitive_root.eq_neg_one_of_two_right"
{"src": "2 goals	R : Type u_5,	ζ : R,	_inst_5 : comm_ring R,	_inst_6 : is_domain R,	h : is_primitive_root ζ 2	⊢ 1 < 2		R : Type u_5,	ζ : R,	_inst_5 : comm_ring R,	_inst_6 : is_domain R,	h : is_primitive_root ζ 2	⊢ ζ ^ 2 = 1 ^ 2", "decl_nm": "is_primitive_root.eq_neg_one_of_two_right"
{"src": "R : Type u_5,	ζ : R,	_inst_5 : comm_ring R,	_inst_6 : is_domain R,	h : is_primitive_root ζ 2	⊢ ζ ^ 2 = 1 ^ 2", "decl_nm": "is_primitive_root.eq_neg_one_of_two_right"
{"src": "⊢ ∀ {M : Type u_1} [_inst_1 : comm_monoid M] {k l : ℕ+}, k ∣ l → roots_of_unity k M ≤ roots_of_unity l M", "decl_nm": "roots_of_unity_le_of_dvd"
{"src": "M : Type u_1,	_inst_1 : comm_monoid M,	k l : ℕ+,	h : k ∣ l	⊢ roots_of_unity k M ≤ roots_of_unity l M", "decl_nm": "roots_of_unity_le_of_dvd"
{"src": "M : Type u_1,	_inst_1 : comm_monoid M,	k d : ℕ+	⊢ roots_of_unity k M ≤ roots_of_unity (k * d) M", "decl_nm": "roots_of_unity_le_of_dvd"
{"src": "M : Type u_1,	_inst_1 : comm_monoid M,	k d : ℕ+,	ζ : Mˣ,	h : ζ ∈ roots_of_unity k M	⊢ ζ ∈ roots_of_unity (k * d) M", "decl_nm": "roots_of_unity_le_of_dvd"
{"src": "⊢ ∀ {R : Type u_1} [_inst_1 : ring R] {M : Type u_2} [_inst_2 : add_comm_group M] [_inst_3 : module R M]	  {N : Type u_3} [_inst_4 : add_comm_group N] [_inst_5 : module R N] [_inst_6 : is_simple_module R M]	  (f : M →ₗ[R] N), function.injective ⇑f ∨ f = 0", "decl_nm": "linear_map.injective_or_eq_zero"
{"src": "R : Type u_1,	_inst_1 : ring R,	M : Type u_2,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	N : Type u_3,	_inst_4 : add_comm_group N,	_inst_5 : module R N,	_inst_6 : is_simple_module R M,	f : M →ₗ[R] N	⊢ function.injective ⇑f ∨ f = 0", "decl_nm": "linear_map.injective_or_eq_zero"
{"src": "R : Type u_1,	_inst_1 : ring R,	M : Type u_2,	_inst_2 : add_comm_group M,	_inst_3 : module R M,	N : Type u_3,	_inst_4 : add_comm_group N,	_inst_5 : module R N,	_inst_6 : is_simple_module R M,	f : M →ₗ[R] N	⊢ f.ker = ⊥ ∨ f.ker = ⊤", "decl_nm": "linear_map.injective_or_eq_zero"
{"src": "⊢ ∀ {K : Type u_4} {L : Type u_5} [_inst_6 : field K] [_inst_7 : field L] [_inst_8 : algebra K L] (x : K),	    ⇑(trace K L) (⇑(algebra_map K L) x) = finrank K L • x", "decl_nm": "algebra.trace_algebra_map"
{"src": "K : Type u_4,	L : Type u_5,	_inst_6 : field K,	_inst_7 : field L,	_inst_8 : algebra K L,	x : K	⊢ ⇑(trace K L) (⇑(algebra_map K L) x) = finrank K L • x", "decl_nm": "algebra.trace_algebra_map"
{"src": "2 goals	K : Type u_4,	L : Type u_5,	_inst_6 : field K,	_inst_7 : field L,	_inst_8 : algebra K L,	x : K,	H : ∃ (s : finset L), nonempty (basis ↥s K L)	⊢ ⇑(trace K L) (⇑(algebra_map K L) x) = finrank K L • x		K : Type u_4,	L : Type u_5,	_inst_6 : field K,	_inst_7 : field L,	_inst_8 : algebra K L,	x : K,	H : ¬∃ (s : finset L), nonempty (basis ↥s K L)	⊢ ⇑(trace K L) (⇑(algebra_map K L) x) = finrank K L • x", "decl_nm": "algebra.trace_algebra_map"
{"src": "K : Type u_4,	L : Type u_5,	_inst_6 : field K,	_inst_7 : field L,	_inst_8 : algebra K L,	x : K,	H : ¬∃ (s : finset L), nonempty (basis ↥s K L)	⊢ ⇑(trace K L) (⇑(algebra_map K L) x) = finrank K L • x", "decl_nm": "algebra.trace_algebra_map"
{"src": "⊢ ∀ {α : Type u_1} [_inst_1 : cancel_comm_monoid_with_zero α]	  [dec_irr : Π (p : associates α), decidable (irreducible p)] [_inst_2 : unique_factorization_monoid α]	  [dec : decidable_eq α] [dec' : decidable_eq (associates α)] [_inst_3 : nontrivial α] {a b : α},	    a ≠ 0 →	    b ≠ 0 → (associates.mk a ⊓ associates.mk b = 1 ↔ ∀ {d : α}, d ∣ a → d ∣ b → ¬prime d)", "decl_nm": "associates.coprime_iff_inf_one"
{"src": "α : Type u_1,	_inst_1 : cancel_comm_monoid_with_zero α,	dec_irr : Π (p : associates α), decidable (irreducible p),	_inst_2 : unique_factorization_monoid α,	dec : decidable_eq α,	dec' : decidable_eq (associates α),	_inst_3 : nontrivial α,	a b : α,	ha0 : a ≠ 0,	hb0 : b ≠ 0	⊢ associates.mk a ⊓ associates.mk b = 1 ↔ ∀ {d : α}, d ∣ a → d ∣ b → ¬prime d", "decl_nm": "associates.coprime_iff_inf_one"
{"src": "2 goals	α : Type u_1,	_inst_1 : cancel_comm_monoid_with_zero α,	dec_irr : Π (p : associates α), decidable (irreducible p),	_inst_2 : unique_factorization_monoid α,	dec : decidable_eq α,	dec' : decidable_eq (associates α),	_inst_3 : nontrivial α,	a b : α,	ha0 : a ≠ 0,	hb0 : b ≠ 0	⊢ associates.mk a ⊓ associates.mk b = 1 → ∀ {d : α}, d ∣ a → d ∣ b → ¬prime d		α : Type u_1,	_inst_1 : cancel_comm_monoid_with_zero α,	dec_irr : Π (p : associates α), decidable (irreducible p),	_inst_2 : unique_factorization_monoid α,	dec : decidable_eq α,	dec' : decidable_eq (associates α),	_inst_3 : nontrivial α,	a b : α,	ha0 : a ≠ 0,	hb0 : b ≠ 0	⊢ (∀ {d : α}, d ∣ a → d ∣ b → ¬prime d) → associates.mk a ⊓ associates.mk b = 1", "decl_nm": "associates.coprime_iff_inf_one"
{"src": "2 goals	α : Type u_1,	_inst_1 : cancel_comm_monoid_with_zero α,	dec_irr : Π (p : associates α), decidable (irreducible p),	_inst_2 : unique_factorization_monoid α,	dec : decidable_eq α,	dec' : decidable_eq (associates α),	_inst_3 : nontrivial α,	a b : α,	ha0 : a ≠ 0,	hb0 : b ≠ 0,	hg : associates.mk a ⊓ associates.mk b = 1,	p : α,	ha : p ∣ a,	hb : p ∣ b,	hp : prime p	⊢ false		α : Type u_1,	_inst_1 : cancel_comm_monoid_with_zero α,	dec_irr : Π (p : associates α), decidable (irreducible p),	_inst_2 : unique_factorization_monoid α,	dec : decidable_eq α,	dec' : decidable_eq (associates α),	_inst_3 : nontrivial α,	a b : α,	ha0 : a ≠ 0,	hb0 : b ≠ 0	⊢ (∀ {d : α}, d ∣ a → d ∣ b → ¬prime d) → associates.mk a ⊓ associates.mk b = 1", "decl_nm": "associates.coprime_iff_inf_one"
{"src": "2 goals	α : Type u_1,	_inst_1 : cancel_comm_monoid_with_zero α,	dec_irr : Π (p : associates α), decidable (irreducible p),	_inst_2 : unique_factorization_monoid α,	dec : decidable_eq α,	dec' : decidable_eq (associates α),	_inst_3 : nontrivial α,	a b : α,	ha0 : a ≠ 0,	hb0 : b ≠ 0,	hg : associates.mk a ⊓ associates.mk b = 1,	p : α,	ha : p ∣ a,	hb : p ∣ b,	hp : prime p	⊢ associates.mk p ∣ 1		α : Type u_1,	_inst_1 : cancel_comm_monoid_with_zero α,	dec_irr : Π (p : associates α), decidable (irreducible p),	_inst_2 : unique_factorization_monoid α,	dec : decidable_eq α,	dec' : decidable_eq (associates α),	_inst_3 : nontrivial α,	a b : α,	ha0 : a ≠ 0,	hb0 : b ≠ 0	⊢ (∀ {d : α}, d ∣ a → d ∣ b → ¬prime d) → associates.mk a ⊓ associates.mk b = 1", "decl_nm": "associates.coprime_iff_inf_one"
{"src": "2 goals	α : Type u_1,	_inst_1 : cancel_comm_monoid_with_zero α,	dec_irr : Π (p : associates α), decidable (irreducible p),	_inst_2 : unique_factorization_monoid α,	dec : decidable_eq α,	dec' : decidable_eq (associates α),	_inst_3 : nontrivial α,	a b : α,	ha0 : a ≠ 0,	hb0 : b ≠ 0,	hg : associates.mk a ⊓ associates.mk b = 1,	p : α,	ha : p ∣ a,	hb : p ∣ b,	hp : prime p	⊢ associates.mk p ∣ associates.mk a ⊓ associates.mk b		α : Type u_1,	_inst_1 : cancel_comm_monoid_with_zero α,	dec_irr : Π (p : associates α), decidable (irreducible p),	_inst_2 : unique_factorization_monoid α,	dec : decidable_eq α,	dec' : decidable_eq (associates α),	_inst_3 : nontrivial α,	a b : α,	ha0 : a ≠ 0,	hb0 : b ≠ 0	⊢ (∀ {d : α}, d ∣ a → d ∣ b → ¬prime d) → associates.mk a ⊓ associates.mk b = 1", "decl_nm": "associates.coprime_iff_inf_one"
{"src": "α : Type u_1,	_inst_1 : cancel_comm_monoid_with_zero α,	dec_irr : Π (p : associates α), decidable (irreducible p),	_inst_2 : unique_factorization_monoid α,	dec : decidable_eq α,	dec' : decidable_eq (associates α),	_inst_3 : nontrivial α,	a b : α,	ha0 : a ≠ 0,	hb0 : b ≠ 0	⊢ (∀ {d : α}, d ∣ a → d ∣ b → ¬prime d) → associates.mk a ⊓ associates.mk b = 1", "decl_nm": "associates.coprime_iff_inf_one"
{"src": "α : Type u_1,	_inst_1 : cancel_comm_monoid_with_zero α,	dec_irr : Π (p : associates α), decidable (irreducible p),	_inst_2 : unique_factorization_monoid α,	dec : decidable_eq α,	dec' : decidable_eq (associates α),	_inst_3 : nontrivial α,	a b : α,	ha0 : a ≠ 0,	hb0 : b ≠ 0	⊢ ¬associates.mk a ⊓ associates.mk b = 1 → (¬∀ {d : α}, d ∣ a → d ∣ b → ¬prime d)", "decl_nm": "associates.coprime_iff_inf_one"
{"src": "α : Type u_1,	_inst_1 : cancel_comm_monoid_with_zero α,	dec_irr : Π (p : associates α), decidable (irreducible p),	_inst_2 : unique_factorization_monoid α,	dec : decidable_eq α,	dec' : decidable_eq (associates α),	_inst_3 : nontrivial α,	a b : α,	ha0 : a ≠ 0,	hb0 : b ≠ 0,	hg : ¬associates.mk a ⊓ associates.mk b = 1,	hc : ∀ {d : α}, d ∣ a → d ∣ b → ¬prime d	⊢ false", "decl_nm": "associates.coprime_iff_inf_one"
{"src": "α : Type u_1,	_inst_1 : cancel_comm_monoid_with_zero α,	dec_irr : Π (p : associates α), decidable (irreducible p),	_inst_2 : unique_factorization_monoid α,	dec : decidable_eq α,	dec' : decidable_eq (associates α),	_inst_3 : nontrivial α,	a b : α,	ha0 : a ≠ 0,	hb0 : b ≠ 0,	hg : ¬associates.mk a ⊓ associates.mk b = 1,	hc : ∀ {d : α}, d ∣ a → d ∣ b → ¬prime d,	p : α,	hp : prime p,	hpa : p ∣ a,	hpb : p ∣ b	⊢ false", "decl_nm": "associates.coprime_iff_inf_one"
{"src": "⊢ ∀ (p : ℕ) [hp : fact (nat.prime p)] (x : witt_vector p (zmod p)),	    ⇑((from_padic_int p).comp (to_padic_int p)) x = ⇑(ring_hom.id (witt_vector p (zmod p))) x", "decl_nm": "witt_vector.from_padic_int_comp_to_padic_int_ext"
{"src": "p : ℕ,	hp : fact (nat.prime p),	x : witt_vector p (zmod p)	⊢ ⇑((from_padic_int p).comp (to_padic_int p)) x = ⇑(ring_hom.id (witt_vector p (zmod p))) x", "decl_nm": "witt_vector.from_padic_int_comp_to_padic_int_ext"
{"src": "⊢ ∀ (p : ℕ) [hp : fact (nat.prime p)] (n k : ℕ),	    ⇑(bind₁ (witt_mul_n p n)) (witt_polynomial p ℤ k) = ↑n * witt_polynomial p ℤ k", "decl_nm": "witt_vector.bind₁_witt_mul_n_witt_polynomial"
{"src": "p : ℕ,	hp : fact (nat.prime p),	n k : ℕ	⊢ ⇑(bind₁ (witt_mul_n p n)) (witt_polynomial p ℤ k) = ↑n * witt_polynomial p ℤ k", "decl_nm": "witt_vector.bind₁_witt_mul_n_witt_polynomial"
{"src": "2 goals	case nat.zero	p : ℕ,	hp : fact (nat.prime p),	k : ℕ	⊢ ⇑(bind₁ (witt_mul_n p 0)) (witt_polynomial p ℤ k) = ↑0 * witt_polynomial p ℤ k		case nat.succ	p : ℕ,	hp : fact (nat.prime p),	k n : ℕ,	ih : ⇑(bind₁ (witt_mul_n p n)) (witt_polynomial p ℤ k) = ↑n * witt_polynomial p ℤ k	⊢ ⇑(bind₁ (witt_mul_n p n.succ)) (witt_polynomial p ℤ k) = ↑(n.succ) * witt_polynomial p ℤ k", "decl_nm": "witt_vector.bind₁_witt_mul_n_witt_polynomial"
{"src": "case nat.succ	p : ℕ,	hp : fact (nat.prime p),	k n : ℕ,	ih : ⇑(bind₁ (witt_mul_n p n)) (witt_polynomial p ℤ k) = ↑n * witt_polynomial p ℤ k	⊢ ⇑(bind₁ (witt_mul_n p n.succ)) (witt_polynomial p ℤ k) = ↑(n.succ) * witt_polynomial p ℤ k", "decl_nm": "witt_vector.bind₁_witt_mul_n_witt_polynomial"
{"src": "case nat.succ	p : ℕ,	hp : fact (nat.prime p),	k n : ℕ,	ih : ⇑(bind₁ (witt_mul_n p n)) (witt_polynomial p ℤ k) = ↑n * witt_polynomial p ℤ k	⊢ ⇑(bind₁ (function.uncurry ![witt_mul_n p n, X]))	      (⇑(bind₁ (λ (i : fin 2), ⇑(rename (prod.mk i)) (witt_polynomial p ℤ k))) (X 0 + X 1)) =	    ↑(n.succ) * witt_polynomial p ℤ k", "decl_nm": "witt_vector.bind₁_witt_mul_n_witt_polynomial"
{"src": "case nat.succ	p : ℕ,	hp : fact (nat.prime p),	k n : ℕ,	ih : ⇑(bind₁ (witt_mul_n p n)) (witt_polynomial p ℤ k) = ↑n * witt_polynomial p ℤ k	⊢ ⇑(bind₁ (function.uncurry ![witt_mul_n p n, X])) (⇑(rename (prod.mk 0)) (witt_polynomial p ℤ k)) +	      ⇑(bind₁ (function.uncurry ![witt_mul_n p n, X])) (⇑(rename (prod.mk 1)) (witt_polynomial p ℤ k)) =	    (↑n + 1) * witt_polynomial p ℤ k", "decl_nm": "witt_vector.bind₁_witt_mul_n_witt_polynomial"
{"src": "case nat.succ	p : ℕ,	hp : fact (nat.prime p),	k n : ℕ,	ih : ⇑(bind₁ (witt_mul_n p n)) (witt_polynomial p ℤ k) = ↑n * witt_polynomial p ℤ k	⊢ ⇑(bind₁ (function.uncurry ![witt_mul_n p n, X] ∘ prod.mk 0)) (witt_polynomial p ℤ k) +	      ⇑(bind₁ (function.uncurry ![witt_mul_n p n, X] ∘ prod.mk 1)) (witt_polynomial p ℤ k) =	    ↑n * witt_polynomial p ℤ k + witt_polynomial p ℤ k", "decl_nm": "witt_vector.bind₁_witt_mul_n_witt_polynomial"
{"src": "⊢ ∀ {p : ℕ} [hp : fact (nat.prime p)] {R : Type u_1} [_inst_1 : comm_ring R],	    (⨅ (i : ℕ), (truncate i).ker) = ⊥", "decl_nm": "truncated_witt_vector.infi_ker_truncate"
{"src": "p : ℕ,	hp : fact (nat.prime p),	R : Type u_1,	_inst_1 : comm_ring R	⊢ (⨅ (i : ℕ), (truncate i).ker) = ⊥", "decl_nm": "truncated_witt_vector.infi_ker_truncate"
{"src": "p : ℕ,	hp : fact (nat.prime p),	R : Type u_1,	_inst_1 : comm_ring R	⊢ ∀ (x : witt_vector p R), (x ∈ ⨅ (i : ℕ), (truncate i).ker) → x = 0", "decl_nm": "truncated_witt_vector.infi_ker_truncate"
{"src": "p : ℕ,	hp : fact (nat.prime p),	R : Type u_1,	_inst_1 : comm_ring R,	x : witt_vector p R,	hx : x ∈ ⨅ (i : ℕ), (truncate i).ker	⊢ x = 0", "decl_nm": "truncated_witt_vector.infi_ker_truncate"
{"src": "p : ℕ,	hp : fact (nat.prime p),	R : Type u_1,	_inst_1 : comm_ring R,	x : witt_vector p R,	hx : x ∈ ⨅ (i : ℕ), (truncate i).ker,	n : ℕ	⊢ x.coeff n = 0.coeff n", "decl_nm": "truncated_witt_vector.infi_ker_truncate"
{"src": "p : ℕ,	hp : fact (nat.prime p),	R : Type u_1,	_inst_1 : comm_ring R,	x : witt_vector p R,	n : ℕ,	hx : ∀ (i i_1 : ℕ), i_1 < i → x.coeff i_1 = 0	⊢ x.coeff n = 0", "decl_nm": "truncated_witt_vector.infi_ker_truncate"
{"src": "⊢ ∀ {p : ℕ} [hp : fact (nat.prime p)] {R : Type u_1} [_inst_1 : comm_ring R] {S : Type u_2} [_inst_2 : semiring S]	  {f : Π (k : ℕ), S →+* truncated_witt_vector p k R}	  (f_compat : ∀ (k₁ k₂ : ℕ) (hk : k₁ ≤ k₂), (truncate hk).comp (f k₂) = f k₁)	  (g : S →+* witt_vector p R),	    (∀ (k : ℕ), (truncate k).comp g = f k) → lift (λ (k₂ : ℕ), f k₂) f_compat = g", "decl_nm": "witt_vector.lift_unique"
{"src": "p : ℕ,	hp : fact (nat.prime p),	R : Type u_1,	_inst_1 : comm_ring R,	S : Type u_2,	_inst_2 : semiring S,	f : Π (k : ℕ), S →+* truncated_witt_vector p k R,	f_compat : ∀ (k₁ k₂ : ℕ) (hk : k₁ ≤ k₂), (truncate hk).comp (f k₂) = f k₁,	g : S →+* witt_vector p R,	g_compat : ∀ (k : ℕ), (truncate k).comp g = f k	⊢ lift (λ (k₂ : ℕ), f k₂) f_compat = g", "decl_nm": "witt_vector.lift_unique"
{"src": "p : ℕ,	hp : fact (nat.prime p),	R : Type u_1,	_inst_1 : comm_ring R,	S : Type u_2,	_inst_2 : semiring S,	f : Π (k : ℕ), S →+* truncated_witt_vector p k R,	f_compat : ∀ (k₁ k₂ : ℕ) (hk : k₁ ≤ k₂), (truncate hk).comp (f k₂) = f k₁,	g : S →+* witt_vector p R,	g_compat : ∀ (k : ℕ), (truncate k).comp g = f k,	x : S	⊢ ⇑(lift (λ (k₂ : ℕ), f k₂) f_compat) x = ⇑g x", "decl_nm": "witt_vector.lift_unique"
{"src": "p : ℕ,	hp : fact (nat.prime p),	R : Type u_1,	_inst_1 : comm_ring R,	S : Type u_2,	_inst_2 : semiring S,	f : Π (k : ℕ), S →+* truncated_witt_vector p k R,	f_compat : ∀ (k₁ k₂ : ℕ) (hk : k₁ ≤ k₂), (truncate hk).comp (f k₂) = f k₁,	g : S →+* witt_vector p R,	g_compat : ∀ (k : ℕ), (truncate k).comp g = f k,	x : S	⊢ ∀ (i : ℕ), ⇑(lift (λ (k₂ : ℕ), f k₂) f_compat) x - ⇑g x ∈ (truncate i).ker", "decl_nm": "witt_vector.lift_unique"
{"src": "p : ℕ,	hp : fact (nat.prime p),	R : Type u_1,	_inst_1 : comm_ring R,	S : Type u_2,	_inst_2 : semiring S,	f : Π (k : ℕ), S →+* truncated_witt_vector p k R,	f_compat : ∀ (k₁ k₂ : ℕ) (hk : k₁ ≤ k₂), (truncate hk).comp (f k₂) = f k₁,	g : S →+* witt_vector p R,	g_compat : ∀ (k : ℕ), (truncate k).comp g = f k,	x : S,	i : ℕ	⊢ ⇑(lift (λ (k₂ : ℕ), f k₂) f_compat) x - ⇑g x ∈ (truncate i).ker", "decl_nm": "witt_vector.lift_unique"
{"src": "⊢ ∀ (p : ℕ) (R : Type u_1) [_inst_1 : comm_ring R], witt_polynomial p R 1 = ⇑C ↑p * X 1 + X 0 ^ p", "decl_nm": "witt_polynomial_one"
{"src": "p : ℕ,	R : Type u_1,	_inst_1 : comm_ring R	⊢ witt_polynomial p R 1 = ⇑C ↑p * X 1 + X 0 ^ p", "decl_nm": "witt_polynomial_one"
{"src": "⊢ ∀ {α β : Type u} (f : α → β) {s : set α} {t : set β},	    t ⊆ f '' s → mk ↥t ≤ mk ↥{x ∈ s | f x ∈ t}", "decl_nm": "cardinal.mk_subset_ge_of_subset_image"
{"src": "α β : Type u,	f : α → β,	s : set α,	t : set β,	h : t ⊆ f '' s	⊢ mk ↥t ≤ mk ↥{x ∈ s | f x ∈ t}", "decl_nm": "cardinal.mk_subset_ge_of_subset_image"
{"src": "α β : Type u,	f : α → β,	s : set α,	t : set β,	h : t ⊆ range (λ (x : ↥s), f ↑x)	⊢ mk ↥t ≤ mk ↥{x ∈ s | f x ∈ t}", "decl_nm": "cardinal.mk_subset_ge_of_subset_image"
{"src": "α β : Type u,	f : α → β,	s : set α,	t : set β,	h : t ⊆ range (λ (x : ↥s), f ↑x)	⊢ mk ↥{x ∈ s | f x ∈ t} = mk ↥((λ (x : ↥s), f ↑x) ⁻¹' t)", "decl_nm": "cardinal.mk_subset_ge_of_subset_image"
{"src": "α β : Type u,	f : α → β,	s : set α,	t : set β,	h : t ⊆ range (λ (x : ↥s), f ↑x)	⊢ mk ↥{x : ↥s | f x.val ∈ t} = mk ↥((λ (x : ↥s), f ↑x) ⁻¹' t)", "decl_nm": "cardinal.mk_subset_ge_of_subset_image"
{"src": "⊢ ⇑to_nat 0 = 0", "decl_nm": "cardinal.zero_to_nat"
{"src": "⊢ ∀ (a : cardinal), ¬bit0 a = 0 ↔ ¬a = 0", "decl_nm": "cardinal.bit0_ne_zero"
{"src": "a : cardinal	⊢ ¬bit0 a = 0 ↔ ¬a = 0", "decl_nm": "cardinal.bit0_ne_zero"
{"src": "⊢ ∀ {a b : cardinal}, a.aleph_idx ≤ b.aleph_idx ↔ a ≤ b", "decl_nm": "cardinal.aleph_idx_le"
{"src": "a b : cardinal	⊢ a.aleph_idx ≤ b.aleph_idx ↔ a ≤ b", "decl_nm": "cardinal.aleph_idx_le"
{"src": "⊢ 0.cof = 0", "decl_nm": "ordinal.cof_zero"
{"src": "⊢ ∀ {β α : Type u_1} (f : β → α), mk α < mk β → infinite α → (∃ (a : α), infinite ↥(f ⁻¹' {a}))", "decl_nm": "cardinal.exists_infinite_fiber"
{"src": "β α : Type u_1,	f : β → α,	w : mk α < mk β,	w' : infinite α	⊢ ∃ (a : α), infinite ↥(f ⁻¹' {a})", "decl_nm": "cardinal.exists_infinite_fiber"
{"src": "β α : Type u_1,	f : β → α,	w : mk α < mk β,	w' : omega ≤ mk α	⊢ ∃ (a : α), omega ≤ mk ↥(f ⁻¹' {a})", "decl_nm": "cardinal.exists_infinite_fiber"
{"src": "β α : Type u_1,	f : β → α,	w : mk α < mk β,	w' : omega ≤ mk α,	a : α,	ha : mk α < mk ↥(f ⁻¹' {a})	⊢ ∃ (a : α), omega ≤ mk ↥(f ⁻¹' {a})", "decl_nm": "cardinal.exists_infinite_fiber"
{"src": "⊢ ∀ {c₁ c₂ : cardinal}, c₁.ord ≤ c₂.ord ↔ c₁ ≤ c₂", "decl_nm": "cardinal.ord_le_ord"
{"src": "c₁ c₂ : cardinal	⊢ c₁.ord ≤ c₂.ord ↔ c₁ ≤ c₂", "decl_nm": "cardinal.ord_le_ord"
{"src": "⊢ ∀ {C : ordinal → Sort u_2} (H₁ : C 0) (H₂ : Π (o : ordinal), C o → C o.succ)	  (H₃ : Π (o : ordinal), o.is_limit → (Π (o' : ordinal), o' < o → C o') → C o),	    0.limit_rec_on H₁ H₂ H₃ = H₁", "decl_nm": "ordinal.limit_rec_on_zero"
{"src": "C : ordinal → Sort u_2,	H₁ : C 0,	H₂ : Π (o : ordinal), C o → C o.succ,	H₃ : Π (o : ordinal), o.is_limit → (Π (o' : ordinal), o' < o → C o') → C o	⊢ 0.limit_rec_on H₁ H₂ H₃ = H₁", "decl_nm": "ordinal.limit_rec_on_zero"
{"src": "C : ordinal → Sort u_2,	H₁ : C 0,	H₂ : Π (o : ordinal), C o → C o.succ,	H₃ : Π (o : ordinal), o.is_limit → (Π (o' : ordinal), o' < o → C o') → C o	⊢ _.mpr H₁ = H₁", "decl_nm": "ordinal.limit_rec_on_zero"
{"src": "⊢ ∀ (n : ℕ), ↑(bit0 n) = bit0 ↑n", "decl_nm": "linarith.int.coe_nat_bit0"
{"src": "n : ℕ	⊢ ↑(bit0 n) = bit0 ↑n", "decl_nm": "linarith.int.coe_nat_bit0"
{"src": "⊢ ∀ (n : ℕ), ↑(bit1 n) = bit1 ↑n", "decl_nm": "linarith.int.coe_nat_bit1"
{"src": "n : ℕ	⊢ ↑(bit1 n) = bit1 ↑n", "decl_nm": "linarith.int.coe_nat_bit1"
{"src": "⊢ ∀ {n1 n2 : ℕ} {z1 z2 : ℤ}, n1 < n2 → ↑n1 = z1 → ↑n2 = z2 → z1 < z2", "decl_nm": "linarith.nat_lt_subst"
{"src": "n1 n2 : ℕ,	z1 z2 : ℤ,	hn : n1 < n2,	h1 : ↑n1 = z1,	h2 : ↑n2 = z2	⊢ z1 < z2", "decl_nm": "linarith.nat_lt_subst"
{"src": "⊢ ∀ {α : Type u_1} [_inst_1 : ordered_semiring α] {a b : α}, a = 0 → b ≤ 0 → a + b ≤ 0", "decl_nm": "linarith.le_of_eq_of_le"
{"src": "α : Type u_1,	_inst_1 : ordered_semiring α,	a b : α,	ha : a = 0,	hb : b ≤ 0	⊢ a + b ≤ 0", "decl_nm": "linarith.le_of_eq_of_le"
{"src": "⊢ ∀ {n : ℕ} {a : fin n} {n' a' b k nk : ℕ},	    n = n' → norm_fin.normalize_fin n a a' → n' * k = nk → nk + b = a' → norm_fin.normalize_fin n a b", "decl_nm": "tactic.norm_fin.normalize_fin.reduce"
{"src": "n : ℕ,	a : fin n,	n' a' b k nk : ℕ,	hn : n = n',	h : norm_fin.normalize_fin n a a',	e1 : n' * k = nk,	e2 : nk + b = a'	⊢ norm_fin.normalize_fin n a b", "decl_nm": "tactic.norm_fin.normalize_fin.reduce"
{"src": "⊢ ∀ {n : ℕ} {a b : fin n} {a' b' c' : ℕ},	    norm_fin.normalize_fin n a a' →	    norm_fin.normalize_fin n b b' → a' + b' = c' → norm_fin.normalize_fin n (a + b) c'", "decl_nm": "tactic.norm_fin.normalize_fin.add"
{"src": "n : ℕ,	a b : fin n,	a' b' c' : ℕ,	ha : norm_fin.normalize_fin n a a',	hb : norm_fin.normalize_fin n b b',	h : a' + b' = c'	⊢ norm_fin.normalize_fin n (a + b) c'", "decl_nm": "tactic.norm_fin.normalize_fin.add"
{"src": "n : ℕ,	a b : fin n,	a' b' c' : ℕ,	ha : a.val = a' % n,	hb : b.val = b' % n,	h : a' + b' = a' + b'	⊢ (a + b).val = (a' + b') % n", "decl_nm": "tactic.norm_fin.normalize_fin.add"
{"src": "⊢ ∀ {α : Type u_1} [_inst_1 : comm_semiring α] (a₁ x : α) (n : ℕ) (b₁ a₂ b₂ a' b' t : α),	    a₁ + a₂ = a' →	    b₁ + b₂ = b' → ring.horner a' x n b' = t → ring.horner a₁ x n b₁ + ring.horner a₂ x n b₂ = t", "decl_nm": "tactic.ring.horner_add_horner_eq"
{"src": "α : Type u_1,	_inst_1 : comm_semiring α,	a₁ x : α,	n : ℕ,	b₁ a₂ b₂ a' b' t : α,	h₁ : a₁ + a₂ = a',	h₂ : b₁ + b₂ = b',	h₃ : ring.horner a' x n b' = t	⊢ ring.horner a₁ x n b₁ + ring.horner a₂ x n b₂ = t", "decl_nm": "tactic.ring.horner_add_horner_eq"
{"src": "α : Type u_1,	_inst_1 : comm_semiring α,	a₁ x : α,	n : ℕ,	b₁ a₂ b₂ a' b' t : α,	h₁ : a₁ + a₂ = a',	h₂ : b₁ + b₂ = b',	h₃ : ring.horner a' x n b' = t	⊢ a₁ * x ^ n + b₁ + (a₂ * x ^ n + b₂) = a₁ * x ^ n + a₂ * x ^ n + (b₁ + b₂)", "decl_nm": "tactic.ring.horner_add_horner_eq"
{"src": "⊢ ∀ {α : Type u_1} [_inst_1 : comm_semiring α] (t : tree α) (r₁ r₂ : csring_expr),	    horner_expr.of_csexpr r₁ = horner_expr.of_csexpr r₂ → csring_expr.eval t r₁ = csring_expr.eval t r₂", "decl_nm": "tactic.ring2.correctness"
{"src": "α : Type u_1,	_inst_1 : comm_semiring α,	t : tree α,	r₁ r₂ : csring_expr,	H : horner_expr.of_csexpr r₁ = horner_expr.of_csexpr r₂	⊢ csring_expr.eval t r₁ = csring_expr.eval t r₂", "decl_nm": "tactic.ring2.correctness"
{"src": "α : Type u_1,	_inst_1 : comm_semiring α,	t : tree α,	r₁ r₂ : csring_expr,	H : horner_expr.of_csexpr r₁ = horner_expr.of_csexpr r₂	⊢ horner_expr.cseval t (horner_expr.of_csexpr r₁) = csring_expr.eval t r₂", "decl_nm": "tactic.ring2.correctness"
{"src": "α : Type u_1,	_inst_1 : comm_semiring α,	t : tree α,	r₁ r₂ : csring_expr,	H : horner_expr.of_csexpr r₁ = horner_expr.of_csexpr r₂	⊢ horner_expr.cseval t (horner_expr.of_csexpr r₁) = horner_expr.cseval t (horner_expr.of_csexpr r₂)", "decl_nm": "tactic.ring2.correctness"
{"src": "⊢ ∀ (n m : ℕ), n + (m + 1) ≠ n", "decl_nm": "tactic.unify_equations.add_add_one_ne"
{"src": "n m : ℕ	⊢ n + (m + 1) ≠ n", "decl_nm": "tactic.unify_equations.add_add_one_ne"
{"src": "n m : ℕ	⊢ n < n + (m + 1)", "decl_nm": "tactic.unify_equations.add_add_one_ne"
{"src": "n m : ℕ	⊢ 0 < m + 1", "decl_nm": "tactic.unify_equations.add_add_one_ne"
{"src": "n m : ℕ	⊢ m + 1 ≠ 0", "decl_nm": "tactic.unify_equations.add_add_one_ne"
{"src": "⊢ ∀ {X : Type u_1} [_inst_1 : topological_space X] {Y : Type u_2} [_inst_2 : topological_space Y]	  {f : alexandroff X → Y} {x : X}, continuous_at f ↑x ↔ continuous_at (f ∘ coe) x", "decl_nm": "alexandroff.continuous_at_coe"
{"src": "X : Type u_1,	_inst_1 : topological_space X,	Y : Type u_2,	_inst_2 : topological_space Y,	f : alexandroff X → Y,	x : X	⊢ continuous_at f ↑x ↔ continuous_at (f ∘ coe) x", "decl_nm": "alexandroff.continuous_at_coe"
{"src": "⊢ ∀ (R : Type u_1) [_inst_1 : topological_space R] [_inst_2 : comm_semiring R] (A : Type u)	  [_inst_3 : topological_space A] [_inst_4 : semiring A] [_inst_5 : algebra R A] [_inst_6 : topological_ring A],	    continuous ⇑(algebra_map R A) ↔ continuous (λ (p : R × A), p.fst • p.snd)", "decl_nm": "continuous_algebra_map_iff_smul"
{"src": "R : Type u_1,	_inst_1 : topological_space R,	_inst_2 : comm_semiring R,	A : Type u,	_inst_3 : topological_space A,	_inst_4 : semiring A,	_inst_5 : algebra R A,	_inst_6 : topological_ring A	⊢ continuous ⇑(algebra_map R A) ↔ continuous (λ (p : R × A), p.fst • p.snd)", "decl_nm": "continuous_algebra_map_iff_smul"
{"src": "2 goals	R : Type u_1,	_inst_1 : topological_space R,	_inst_2 : comm_semiring R,	A : Type u,	_inst_3 : topological_space A,	_inst_4 : semiring A,	_inst_5 : algebra R A,	_inst_6 : topological_ring A,	h : continuous ⇑(algebra_map R A)	⊢ continuous (λ (p : R × A), p.fst • p.snd)		R : Type u_1,	_inst_1 : topological_space R,	_inst_2 : comm_semiring R,	A : Type u,	_inst_3 : topological_space A,	_inst_4 : semiring A,	_inst_5 : algebra R A,	_inst_6 : topological_ring A,	h : continuous (λ (p : R × A), p.fst • p.snd)	⊢ continuous ⇑(algebra_map R A)", "decl_nm": "continuous_algebra_map_iff_smul"
{"src": "2 goals	R : Type u_1,	_inst_1 : topological_space R,	_inst_2 : comm_semiring R,	A : Type u,	_inst_3 : topological_space A,	_inst_4 : semiring A,	_inst_5 : algebra R A,	_inst_6 : topological_ring A,	h : continuous ⇑(algebra_map R A)	⊢ continuous (λ (p : R × A), ⇑(algebra_map R A) p.fst * p.snd)		R : Type u_1,	_inst_1 : topological_space R,	_inst_2 : comm_semiring R,	A : Type u,	_inst_3 : topological_space A,	_inst_4 : semiring A,	_inst_5 : algebra R A,	_inst_6 : topological_ring A,	h : continuous (λ (p : R × A), p.fst • p.snd)	⊢ continuous ⇑(algebra_map R A)", "decl_nm": "continuous_algebra_map_iff_smul"
{"src": "R : Type u_1,	_inst_1 : topological_space R,	_inst_2 : comm_semiring R,	A : Type u,	_inst_3 : topological_space A,	_inst_4 : semiring A,	_inst_5 : algebra R A,	_inst_6 : topological_ring A,	h : continuous (λ (p : R × A), p.fst • p.snd)	⊢ continuous ⇑(algebra_map R A)", "decl_nm": "continuous_algebra_map_iff_smul"
{"src": "R : Type u_1,	_inst_1 : topological_space R,	_inst_2 : comm_semiring R,	A : Type u,	_inst_3 : topological_space A,	_inst_4 : semiring A,	_inst_5 : algebra R A,	_inst_6 : topological_ring A,	h : continuous (λ (p : R × A), p.fst • p.snd)	⊢ continuous (λ (r : R), r • 1)", "decl_nm": "continuous_algebra_map_iff_smul"
{"src": "⊢ ∀ {α : Type u_1} {β : Type u_2} [_inst_1 : add_comm_monoid α] [_inst_2 : topological_space α]	  [_inst_3 : t2_space α] (P : Prop) [_inst_4 : decidable P] (x : β → P → α),	    ∑' (b : β), dite P (λ (h : P), x b h) (λ (h : ¬P), 0) =	      dite P (λ (h : P), ∑' (b : β), x b h) (λ (h : ¬P), 0)", "decl_nm": "tsum_dite_left"
{"src": "α : Type u_1,	β : Type u_2,	_inst_1 : add_comm_monoid α,	_inst_2 : topological_space α,	_inst_3 : t2_space α,	P : Prop,	_inst_4 : decidable P,	x : β → P → α	⊢ ∑' (b : β), dite P (λ (h : P), x b h) (λ (h : ¬P), 0) =	    dite P (λ (h : P), ∑' (b : β), x b h) (λ (h : ¬P), 0)", "decl_nm": "tsum_dite_left"
{"src": "2 goals	α : Type u_1,	β : Type u_2,	_inst_1 : add_comm_monoid α,	_inst_2 : topological_space α,	_inst_3 : t2_space α,	P : Prop,	_inst_4 : decidable P,	x : β → P → α,	hP : P	⊢ ∑' (b : β), dite P (λ (h : P), x b h) (λ (h : ¬P), 0) =	    dite P (λ (h : P), ∑' (b : β), x b h) (λ (h : ¬P), 0)		α : Type u_1,	β : Type u_2,	_inst_1 : add_comm_monoid α,	_inst_2 : topological_space α,	_inst_3 : t2_space α,	P : Prop,	_inst_4 : decidable P,	x : β → P → α,	hP : ¬P	⊢ ∑' (b : β), dite P (λ (h : P), x b h) (λ (h : ¬P), 0) =	    dite P (λ (h : P), ∑' (b : β), x b h) (λ (h : ¬P), 0)", "decl_nm": "tsum_dite_left"
{"src": "α : Type u_1,	β : Type u_2,	_inst_1 : add_comm_monoid α,	_inst_2 : topological_space α,	_inst_3 : t2_space α,	P : Prop,	_inst_4 : decidable P,	x : β → P → α,	hP : ¬P	⊢ ∑' (b : β), dite P (λ (h : P), x b h) (λ (h : ¬P), 0) =	    dite P (λ (h : P), ∑' (b : β), x b h) (λ (h : ¬P), 0)", "decl_nm": "tsum_dite_left"
{"src": "⊢ ∀ {α : Type u_1} {β : Type u_2} [_inst_1 : ordered_add_comm_monoid α] [_inst_2 : topological_space α]	  [_inst_3 : order_closed_topology α] {g : β → α}, (∀ (b : β), 0 ≤ g b) → 0 ≤ ∑' (b : β), g b", "decl_nm": "tsum_nonneg"
{"src": "α : Type u_1,	β : Type u_2,	_inst_1 : ordered_add_comm_monoid α,	_inst_2 : topological_space α,	_inst_3 : order_closed_topology α,	g : β → α,	h : ∀ (b : β), 0 ≤ g b	⊢ 0 ≤ ∑' (b : β), g b", "decl_nm": "tsum_nonneg"
{"src": "2 goals	α : Type u_1,	β : Type u_2,	_inst_1 : ordered_add_comm_monoid α,	_inst_2 : topological_space α,	_inst_3 : order_closed_topology α,	g : β → α,	h : ∀ (b : β), 0 ≤ g b,	hg : summable g	⊢ 0 ≤ ∑' (b : β), g b		α : Type u_1,	β : Type u_2,	_inst_1 : ordered_add_comm_monoid α,	_inst_2 : topological_space α,	_inst_3 : order_closed_topology α,	g : β → α,	h : ∀ (b : β), 0 ≤ g b,	hg : ¬summable g	⊢ 0 ≤ ∑' (b : β), g b", "decl_nm": "tsum_nonneg"
{"src": "α : Type u_1,	β : Type u_2,	_inst_1 : ordered_add_comm_monoid α,	_inst_2 : topological_space α,	_inst_3 : order_closed_topology α,	g : β → α,	h : ∀ (b : β), 0 ≤ g b,	hg : ¬summable g	⊢ 0 ≤ ∑' (b : β), g b", "decl_nm": "tsum_nonneg"
{"src": "⊢ ∀ {α : Type u_1} {β : Type u_2} [_inst_1 : ordered_add_comm_monoid α] [_inst_2 : topological_space α]	  [_inst_3 : order_closed_topology α] {f : β → α}, (∀ (b : β), f b ≤ 0) → ∑' (b : β), f b ≤ 0", "decl_nm": "tsum_nonpos"
{"src": "α : Type u_1,	β : Type u_2,	_inst_1 : ordered_add_comm_monoid α,	_inst_2 : topological_space α,	_inst_3 : order_closed_topology α,	f : β → α,	h : ∀ (b : β), f b ≤ 0	⊢ ∑' (b : β), f b ≤ 0", "decl_nm": "tsum_nonpos"
{"src": "2 goals	α : Type u_1,	β : Type u_2,	_inst_1 : ordered_add_comm_monoid α,	_inst_2 : topological_space α,	_inst_3 : order_closed_topology α,	f : β → α,	h : ∀ (b : β), f b ≤ 0,	hf : summable f	⊢ ∑' (b : β), f b ≤ 0		α : Type u_1,	β : Type u_2,	_inst_1 : ordered_add_comm_monoid α,	_inst_2 : topological_space α,	_inst_3 : order_closed_topology α,	f : β → α,	h : ∀ (b : β), f b ≤ 0,	hf : ¬summable f	⊢ ∑' (b : β), f b ≤ 0", "decl_nm": "tsum_nonpos"
{"src": "α : Type u_1,	β : Type u_2,	_inst_1 : ordered_add_comm_monoid α,	_inst_2 : topological_space α,	_inst_3 : order_closed_topology α,	f : β → α,	h : ∀ (b : β), f b ≤ 0,	hf : ¬summable f	⊢ ∑' (b : β), f b ≤ 0", "decl_nm": "tsum_nonpos"
{"src": "⊢ ∀ {R₁ : Type u_1} {R₂ : Type u_2} [_inst_1 : semiring R₁] [_inst_2 : semiring R₂]	  {σ₁₂ : R₁ →+* R₂} {σ₂₁ : R₂ →+* R₁} [_inst_4 : ring_hom_inv_pair σ₁₂ σ₂₁]	  [_inst_5 : ring_hom_inv_pair σ₂₁ σ₁₂] {M₁ : Type u_4} [_inst_12 : topological_space M₁]	  [_inst_13 : add_comm_monoid M₁] {M₂ : Type u_6} [_inst_16 : topological_space M₂]	  [_inst_17 : add_comm_monoid M₂] [_inst_22 : module R₁ M₁] [_inst_24 : module R₂ M₂]	  (e : M₁ ≃SL[σ₁₂] M₂), e.symm.symm = e", "decl_nm": "continuous_linear_equiv.symm_symm"
{"src": "R₁ : Type u_1,	R₂ : Type u_2,	_inst_1 : semiring R₁,	_inst_2 : semiring R₂,	σ₁₂ : R₁ →+* R₂,	σ₂₁ : R₂ →+* R₁,	_inst_4 : ring_hom_inv_pair σ₁₂ σ₂₁,	_inst_5 : ring_hom_inv_pair σ₂₁ σ₁₂,	M₁ : Type u_4,	_inst_12 : topological_space M₁,	_inst_13 : add_comm_monoid M₁,	M₂ : Type u_6,	_inst_16 : topological_space M₂,	_inst_17 : add_comm_monoid M₂,	_inst_22 : module R₁ M₁,	_inst_24 : module R₂ M₂,	e : M₁ ≃SL[σ₁₂] M₂	⊢ e.symm.symm = e", "decl_nm": "continuous_linear_equiv.symm_symm"
{"src": "R₁ : Type u_1,	R₂ : Type u_2,	_inst_1 : semiring R₁,	_inst_2 : semiring R₂,	σ₁₂ : R₁ →+* R₂,	σ₂₁ : R₂ →+* R₁,	_inst_4 : ring_hom_inv_pair σ₁₂ σ₂₁,	_inst_5 : ring_hom_inv_pair σ₂₁ σ₁₂,	M₁ : Type u_4,	_inst_12 : topological_space M₁,	_inst_13 : add_comm_monoid M₁,	M₂ : Type u_6,	_inst_16 : topological_space M₂,	_inst_17 : add_comm_monoid M₂,	_inst_22 : module R₁ M₁,	_inst_24 : module R₂ M₂,	e : M₁ ≃SL[σ₁₂] M₂,	x : M₁	⊢ ⇑(e.symm.symm) x = ⇑e x", "decl_nm": "continuous_linear_equiv.symm_symm"
{"src": "⊢ ∀ {R₁ : Type u_1} {R₂ : Type u_2} [_inst_1 : semiring R₁] [_inst_2 : semiring R₂]	  {σ₁₂ : R₁ →+* R₂} {M₁ : Type u_4} [_inst_4 : topological_space M₁] [_inst_5 : add_comm_monoid M₁]	  {M₂ : Type u_6} [_inst_8 : topological_space M₂] [_inst_9 : add_comm_monoid M₂] [_inst_14 : module R₁ M₁]	  [_inst_16 : module R₂ M₂] [_inst_18 : ring_hom_surjective σ₁₂] [_inst_19 : topological_space R₁]	  [_inst_20 : topological_space R₂] [_inst_21 : has_continuous_smul R₁ M₁] [_inst_22 : has_continuous_add M₁]	  [_inst_23 : has_continuous_smul R₂ M₂] [_inst_24 : has_continuous_add M₂] {f : M₁ →SL[σ₁₂] M₂},	    dense_range ⇑f →	    ∀ {s : submodule R₁ M₁}, s.topological_closure = ⊤ → (submodule.map ↑f s).topological_closure = ⊤", "decl_nm": "dense_range.topological_closure_map_submodule"
{"src": "R₁ : Type u_1,	R₂ : Type u_2,	_inst_1 : semiring R₁,	_inst_2 : semiring R₂,	σ₁₂ : R₁ →+* R₂,	M₁ : Type u_4,	_inst_4 : topological_space M₁,	_inst_5 : add_comm_monoid M₁,	M₂ : Type u_6,	_inst_8 : topological_space M₂,	_inst_9 : add_comm_monoid M₂,	_inst_14 : module R₁ M₁,	_inst_16 : module R₂ M₂,	_inst_18 : ring_hom_surjective σ₁₂,	_inst_19 : topological_space R₁,	_inst_20 : topological_space R₂,	_inst_21 : has_continuous_smul R₁ M₁,	_inst_22 : has_continuous_add M₁,	_inst_23 : has_continuous_smul R₂ M₂,	_inst_24 : has_continuous_add M₂,	f : M₁ →SL[σ₁₂] M₂,	hf' : dense_range ⇑f,	s : submodule R₁ M₁,	hs : s.topological_closure = ⊤	⊢ (submodule.map ↑f s).topological_closure = ⊤", "decl_nm": "dense_range.topological_closure_map_submodule"
{"src": "R₁ : Type u_1,	R₂ : Type u_2,	_inst_1 : semiring R₁,	_inst_2 : semiring R₂,	σ₁₂ : R₁ →+* R₂,	M₁ : Type u_4,	_inst_4 : topological_space M₁,	_inst_5 : add_comm_monoid M₁,	M₂ : Type u_6,	_inst_8 : topological_space M₂,	_inst_9 : add_comm_monoid M₂,	_inst_14 : module R₁ M₁,	_inst_16 : module R₂ M₂,	_inst_18 : ring_hom_surjective σ₁₂,	_inst_19 : topological_space R₁,	_inst_20 : topological_space R₂,	_inst_21 : has_continuous_smul R₁ M₁,	_inst_22 : has_continuous_add M₁,	_inst_23 : has_continuous_smul R₂ M₂,	_inst_24 : has_continuous_add M₂,	f : M₁ →SL[σ₁₂] M₂,	hf' : dense_range ⇑f,	s : submodule R₁ M₁,	hs : ↑(s.topological_closure) = ↑⊤	⊢ ↑((submodule.map ↑f s).topological_closure) = ↑⊤", "decl_nm": "dense_range.topological_closure_map_submodule"
{"src": "R₁ : Type u_1,	R₂ : Type u_2,	_inst_1 : semiring R₁,	_inst_2 : semiring R₂,	σ₁₂ : R₁ →+* R₂,	M₁ : Type u_4,	_inst_4 : topological_space M₁,	_inst_5 : add_comm_monoid M₁,	M₂ : Type u_6,	_inst_8 : topological_space M₂,	_inst_9 : add_comm_monoid M₂,	_inst_14 : module R₁ M₁,	_inst_16 : module R₂ M₂,	_inst_18 : ring_hom_surjective σ₁₂,	_inst_19 : topological_space R₁,	_inst_20 : topological_space R₂,	_inst_21 : has_continuous_smul R₁ M₁,	_inst_22 : has_continuous_add M₁,	_inst_23 : has_continuous_smul R₂ M₂,	_inst_24 : has_continuous_add M₂,	f : M₁ →SL[σ₁₂] M₂,	hf' : dense_range ⇑f,	s : submodule R₁ M₁,	hs : dense ↑s	⊢ dense ↑(submodule.map ↑f s)", "decl_nm": "dense_range.topological_closure_map_submodule"
{"src": "⊢ ∀ {α : Type u} [_inst_1 : linear_ordered_field α] [_inst_2 : topological_space α]	  [_inst_3 : order_topology α], tendsto (uncurry has_mul.mul) ((nhds 1).prod (nhds 1)) (nhds 1)", "decl_nm": "mul_tendsto_nhds_one_nhds_one"
{"src": "α : Type u,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α	⊢ tendsto (uncurry has_mul.mul) ((nhds 1).prod (nhds 1)) (nhds 1)", "decl_nm": "mul_tendsto_nhds_one_nhds_one"
{"src": "α : Type u,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α	⊢ ∀ (ib : α),	    (λ (ε : α), 0 < ε ∧ ε ≤ 1) ib →	    (∃ (ia : α × α) (hia : (λ (i : α × α), 0 < i.fst ∧ 0 < i.snd) ia),	       ∀ (x : α × α),	         x ∈ (λ (i : α × α), Ioo (1 - i.fst) (1 + i.fst) ×ˢ Ioo (1 - i.snd) (1 + i.snd)) ia →	         uncurry has_mul.mul x ∈ (λ (ε : α), Ioo (1 - ε) (1 + ε)) ib)", "decl_nm": "mul_tendsto_nhds_one_nhds_one"
{"src": "α : Type u,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	ε : α,	hε : 0 < ε ∧ ε ≤ 1	⊢ ∃ (ia : α × α) (hia : (λ (i : α × α), 0 < i.fst ∧ 0 < i.snd) ia),	    ∀ (x : α × α),	      x ∈ (λ (i : α × α), Ioo (1 - i.fst) (1 + i.fst) ×ˢ Ioo (1 - i.snd) (1 + i.snd)) ia →	      uncurry has_mul.mul x ∈ (λ (ε : α), Ioo (1 - ε) (1 + ε)) ε", "decl_nm": "mul_tendsto_nhds_one_nhds_one"
{"src": "α : Type u,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	ε : α,	hε : 0 < ε ∧ ε ≤ 1,	hε' : 0 ≤ 1 - ε / 4	⊢ ∃ (ia : α × α) (hia : (λ (i : α × α), 0 < i.fst ∧ 0 < i.snd) ia),	    ∀ (x : α × α),	      x ∈ (λ (i : α × α), Ioo (1 - i.fst) (1 + i.fst) ×ˢ Ioo (1 - i.snd) (1 + i.snd)) ia →	      uncurry has_mul.mul x ∈ (λ (ε : α), Ioo (1 - ε) (1 + ε)) ε", "decl_nm": "mul_tendsto_nhds_one_nhds_one"
{"src": "α : Type u,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	ε : α,	hε : 0 < ε ∧ ε ≤ 1,	hε' : 0 ≤ 1 - ε / 4,	ε_pos : 0 < ε / 4	⊢ ∃ (ia : α × α) (hia : (λ (i : α × α), 0 < i.fst ∧ 0 < i.snd) ia),	    ∀ (x : α × α),	      x ∈ (λ (i : α × α), Ioo (1 - i.fst) (1 + i.fst) ×ˢ Ioo (1 - i.snd) (1 + i.snd)) ia →	      uncurry has_mul.mul x ∈ (λ (ε : α), Ioo (1 - ε) (1 + ε)) ε", "decl_nm": "mul_tendsto_nhds_one_nhds_one"
{"src": "α : Type u,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	ε : α,	hε : 0 < ε ∧ ε ≤ 1,	hε' : 0 ≤ 1 - ε / 4,	ε_pos : 0 < ε / 4,	ε_pos' : 0 < ε / 2	⊢ ∃ (ia : α × α) (hia : (λ (i : α × α), 0 < i.fst ∧ 0 < i.snd) ia),	    ∀ (x : α × α),	      x ∈ (λ (i : α × α), Ioo (1 - i.fst) (1 + i.fst) ×ˢ Ioo (1 - i.snd) (1 + i.snd)) ia →	      uncurry has_mul.mul x ∈ (λ (ε : α), Ioo (1 - ε) (1 + ε)) ε", "decl_nm": "mul_tendsto_nhds_one_nhds_one"
{"src": "α : Type u,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	ε : α,	hε : 0 < ε ∧ ε ≤ 1,	hε' : 0 ≤ 1 - ε / 4,	ε_pos : 0 < ε / 4,	ε_pos' : 0 < ε / 2	⊢ ∃ (a b : α) (h : 0 < (a, b).fst ∧ 0 < (a, b).snd),	    ∀ (a_1 b_1 : α),	      1 - a < a_1 → a_1 < 1 + a → 1 - b < b_1 → b_1 < 1 + b → 1 - ε < a_1 * b_1 ∧ a_1 * b_1 < 1 + ε", "decl_nm": "mul_tendsto_nhds_one_nhds_one"
{"src": "α : Type u,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	ε : α,	hε : 0 < ε ∧ ε ≤ 1,	hε' : 0 ≤ 1 - ε / 4,	ε_pos : 0 < ε / 4,	ε_pos' : 0 < ε / 2,	a b : α,	ha : 1 - ε / 4 < a,	ha' : a < 1 + ε / 4,	hb : 1 - ε / 4 < b,	hb' : b < 1 + ε / 4	⊢ 1 - ε < a * b ∧ a * b < 1 + ε", "decl_nm": "mul_tendsto_nhds_one_nhds_one"
{"src": "α : Type u,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	ε : α,	hε : 0 < ε ∧ ε ≤ 1,	hε' : 0 ≤ 1 - ε / 4,	ε_pos : 0 < ε / 4,	ε_pos' : 0 < ε / 2,	a b : α,	ha : 1 - ε / 4 < a,	ha' : a < 1 + ε / 4,	hb : 1 - ε / 4 < b,	hb' : b < 1 + ε / 4,	ha0 : 0 ≤ a	⊢ 1 - ε < a * b ∧ a * b < 1 + ε", "decl_nm": "mul_tendsto_nhds_one_nhds_one"
{"src": "α : Type u,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	ε : α,	hε : 0 < ε ∧ ε ≤ 1,	hε' : 0 ≤ 1 - ε / 4,	ε_pos : 0 < ε / 4,	ε_pos' : 0 < ε / 2,	a b : α,	ha : 1 - ε / 4 < a,	ha' : a < 1 + ε / 4,	hb : 1 - ε / 4 < b,	hb' : b < 1 + ε / 4,	ha0 : 0 ≤ a,	hb0 : 0 ≤ b	⊢ 1 - ε < a * b ∧ a * b < 1 + ε", "decl_nm": "mul_tendsto_nhds_one_nhds_one"
{"src": "2 goals	α : Type u,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	ε : α,	hε : 0 < ε ∧ ε ≤ 1,	hε' : 0 ≤ 1 - ε / 4,	ε_pos : 0 < ε / 4,	ε_pos' : 0 < ε / 2,	a b : α,	ha : 1 - ε / 4 < a,	ha' : a < 1 + ε / 4,	hb : 1 - ε / 4 < b,	hb' : b < 1 + ε / 4,	ha0 : 0 ≤ a,	hb0 : 0 ≤ b	⊢ 1 - ε ≤ (1 - ε / 4) * (1 - ε / 4)		α : Type u,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	ε : α,	hε : 0 < ε ∧ ε ≤ 1,	hε' : 0 ≤ 1 - ε / 4,	ε_pos : 0 < ε / 4,	ε_pos' : 0 < ε / 2,	a b : α,	ha : 1 - ε / 4 < a,	ha' : a < 1 + ε / 4,	hb : 1 - ε / 4 < b,	hb' : b < 1 + ε / 4,	ha0 : 0 ≤ a,	hb0 : 0 ≤ b	⊢ (1 + ε / 4) * (1 + ε / 4) ≤ 1 + ε", "decl_nm": "mul_tendsto_nhds_one_nhds_one"
{"src": "α : Type u,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	ε : α,	hε : 0 < ε ∧ ε ≤ 1,	hε' : 0 ≤ 1 - ε / 4,	ε_pos : 0 < ε / 4,	ε_pos' : 0 < ε / 2,	a b : α,	ha : 1 - ε / 4 < a,	ha' : a < 1 + ε / 4,	hb : 1 - ε / 4 < b,	hb' : b < 1 + ε / 4,	ha0 : 0 ≤ a,	hb0 : 0 ≤ b	⊢ (1 + ε / 4) * (1 + ε / 4) ≤ 1 + ε", "decl_nm": "mul_tendsto_nhds_one_nhds_one"
{"src": "⊢ ∀ {α : Type u} [_inst_1 : linear_ordered_field α] [_inst_2 : topological_space α]	  [_inst_3 : order_topology α], tendsto (λ (r : α), r⁻¹) at_top (nhds_within 0 (Ioi 0))", "decl_nm": "tendsto_inv_at_top_zero'"
{"src": "α : Type u,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α	⊢ tendsto (λ (r : α), r⁻¹) at_top (nhds_within 0 (Ioi 0))", "decl_nm": "tendsto_inv_at_top_zero'"
{"src": "α : Type u,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α	⊢ ∀ (ib : α), ib ∈ Ioi 0 → (∃ (ia : α) (hia : true), ∀ (x : α), x ∈ Ici ia → x⁻¹ ∈ Ioc 0 ib)", "decl_nm": "tendsto_inv_at_top_zero'"
{"src": "α : Type u,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	b : α,	hb : b ∈ Ioi 0,	x : α,	hx : x ∈ Ici b⁻¹	⊢ x⁻¹ ∈ Ioc 0 b", "decl_nm": "tendsto_inv_at_top_zero'"
{"src": "α : Type u,	_inst_1 : linear_ordered_field α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	b : α,	hb : b ∈ Ioi 0,	x : α,	hx : x ∈ Ici b⁻¹,	this : 0 < x	⊢ x⁻¹ ∈ Ioc 0 b", "decl_nm": "tendsto_inv_at_top_zero'"
{"src": "⊢ ∀ {α : Type u} [_inst_1 : topological_space α] [_inst_2 : linear_order α] [_inst_3 : order_topology α]	  [_inst_4 : densely_ordered α] [_inst_5 : no_max_order α] {a : α}, frontier (Iic a) = {a}", "decl_nm": "frontier_Iic"
{"src": "α : Type u,	_inst_1 : topological_space α,	_inst_2 : linear_order α,	_inst_3 : order_topology α,	_inst_4 : densely_ordered α,	_inst_5 : no_max_order α,	a : α	⊢ frontier (Iic a) = {a}", "decl_nm": "frontier_Iic"
{"src": "⊢ ∀ {α : Type u} [_inst_1 : conditionally_complete_linear_order α] [_inst_2 : topological_space α]	  [_inst_3 : order_topology α] [_inst_8 : densely_ordered α] {δ : Type u_1} [_inst_9 : linear_order δ]	  [_inst_10 : topological_space δ] [_inst_11 : order_closed_topology δ] {a b : α} {f : α → δ},	    continuous_on f (interval a b) → interval (f a) (f b) ⊆ f '' interval a b", "decl_nm": "intermediate_value_interval"
{"src": "α : Type u,	_inst_1 : conditionally_complete_linear_order α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	_inst_8 : densely_ordered α,	δ : Type u_1,	_inst_9 : linear_order δ,	_inst_10 : topological_space δ,	_inst_11 : order_closed_topology δ,	a b : α,	f : α → δ,	hf : continuous_on f (interval a b)	⊢ interval (f a) (f b) ⊆ f '' interval a b", "decl_nm": "intermediate_value_interval"
{"src": "2 goals	case or.inl	α : Type u,	_inst_1 : conditionally_complete_linear_order α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	_inst_8 : densely_ordered α,	δ : Type u_1,	_inst_9 : linear_order δ,	_inst_10 : topological_space δ,	_inst_11 : order_closed_topology δ,	a b : α,	f : α → δ,	hf : continuous_on f (interval a b),	h : f a ≤ f b	⊢ interval (f a) (f b) ⊆ f '' interval a b		case or.inr	α : Type u,	_inst_1 : conditionally_complete_linear_order α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	_inst_8 : densely_ordered α,	δ : Type u_1,	_inst_9 : linear_order δ,	_inst_10 : topological_space δ,	_inst_11 : order_closed_topology δ,	a b : α,	f : α → δ,	hf : continuous_on f (interval a b),	h : f b ≤ f a	⊢ interval (f a) (f b) ⊆ f '' interval a b", "decl_nm": "intermediate_value_interval"
{"src": "case or.inr	α : Type u,	_inst_1 : conditionally_complete_linear_order α,	_inst_2 : topological_space α,	_inst_3 : order_topology α,	_inst_8 : densely_ordered α,	δ : Type u_1,	_inst_9 : linear_order δ,	_inst_10 : topological_space δ,	_inst_11 : order_closed_topology δ,	a b : α,	f : α → δ,	hf : continuous_on f (interval a b),	h : f b ≤ f a	⊢ interval (f a) (f b) ⊆ f '' interval a b", "decl_nm": "intermediate_value_interval"
{"src": "⊢ ∀ {α : Type u} {β : Type v} [_inst_1 : topological_space α] [_inst_2 : linear_order α]	  [_inst_3 : order_closed_topology α] [_inst_5 : topological_space β] {a b : α} {f : α → β},	    a < b → (continuous_within_at f (Ioo a b) a ↔ continuous_within_at f (Ioi a) a)", "decl_nm": "continuous_within_at_Ioo_iff_Ioi"
{"src": "α : Type u,	β : Type v,	_inst_1 : topological_space α,	_inst_2 : linear_order α,	_inst_3 : order_closed_topology α,	_inst_5 : topological_space β,	a b : α,	f : α → β,	h : a < b	⊢ continuous_within_at f (Ioo a b) a ↔ continuous_within_at f (Ioi a) a", "decl_nm": "continuous_within_at_Ioo_iff_Ioi"
{"src": "⊢ ∀ {α : Type u_1} [_inst_1 : topological_space α] [_inst_2 : semiring α] [_inst_3 : topological_ring α]	  (s : subsemiring α), is_closed ↑(s.topological_closure)", "decl_nm": "subsemiring.is_closed_topological_closure"
{"src": "α : Type u_1,	_inst_1 : topological_space α,	_inst_2 : semiring α,	_inst_3 : topological_ring α,	s : subsemiring α	⊢ is_closed ↑(s.topological_closure)", "decl_nm": "subsemiring.is_closed_topological_closure"
{"src": "⊢ ∀ {α : Type u_1} {β : Type u_2} [_inst_1 : topological_space α] [_inst_2 : topological_space β]	  {f : α → β} {s : set α}, continuous f → closure s ⊆ f ⁻¹' closure (f '' s)", "decl_nm": "closure_subset_preimage_closure_image"
{"src": "α : Type u_1,	β : Type u_2,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	f : α → β,	s : set α,	h : continuous f	⊢ closure s ⊆ f ⁻¹' closure (f '' s)", "decl_nm": "closure_subset_preimage_closure_image"
{"src": "α : Type u_1,	β : Type u_2,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	f : α → β,	s : set α,	h : continuous f	⊢ f '' closure s ⊆ closure (f '' s)", "decl_nm": "closure_subset_preimage_closure_image"
{"src": "⊢ ∀ {α : Type u} {s : set α} [_inst_1 : topological_space α],	    is_open s ↔ ∀ (x : α), x ∈ s → (∃ (t : set α) (H : t ⊆ s), is_open t ∧ x ∈ t)", "decl_nm": "is_open_iff_forall_mem_open"
{"src": "α : Type u,	s : set α,	_inst_1 : topological_space α	⊢ is_open s ↔ ∀ (x : α), x ∈ s → (∃ (t : set α) (H : t ⊆ s), is_open t ∧ x ∈ t)", "decl_nm": "is_open_iff_forall_mem_open"
{"src": "α : Type u,	s : set α,	_inst_1 : topological_space α	⊢ s ⊆ interior s ↔ ∀ (x : α), x ∈ s → (∃ (t : set α) (H : t ⊆ s), is_open t ∧ x ∈ t)", "decl_nm": "is_open_iff_forall_mem_open"
{"src": "⊢ ∀ {α : Type u} {β : Type v} {γ : Type w} [_inst_1 : topological_space α] [_inst_2 : topological_space β]	  [_inst_3 : topological_space γ] {g : α × β → γ} (a : α), continuous g → continuous (function.curry g a)", "decl_nm": "continuous_curry"
{"src": "α : Type u,	β : Type v,	γ : Type w,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	_inst_3 : topological_space γ,	g : α × β → γ,	a : α,	h : continuous g	⊢ continuous (function.curry g a)", "decl_nm": "continuous_curry"
{"src": "⊢ ∀ {X : Type u_1} [_inst_1 : topological_space X] [_inst_2 : compact_space X] (A : subalgebra ℝ C(X, ℝ))	  (f : ↥A) (p : C(↥(set.Icc (-∥f∥) ∥f∥), ℝ)), p.comp ↑f.attach_bound ∈ A.topological_closure", "decl_nm": "continuous_map.comp_attach_bound_mem_closure"
{"src": "X : Type u_1,	_inst_1 : topological_space X,	_inst_2 : compact_space X,	A : subalgebra ℝ C(X, ℝ),	f : ↥A,	p : C(↥(set.Icc (-∥f∥) ∥f∥), ℝ)	⊢ p.comp ↑f.attach_bound ∈ A.topological_closure", "decl_nm": "continuous_map.comp_attach_bound_mem_closure"
{"src": "X : Type u_1,	_inst_1 : topological_space X,	_inst_2 : compact_space X,	A : subalgebra ℝ C(X, ℝ),	f : ↥A,	p : C(↥(set.Icc (-∥f∥) ∥f∥), ℝ),	mem_closure : p ∈ (polynomial_functions (set.Icc (-∥f∥) ∥f∥)).topological_closure	⊢ p.comp ↑f.attach_bound ∈ A.topological_closure", "decl_nm": "continuous_map.comp_attach_bound_mem_closure"
{"src": "X : Type u_1,	_inst_1 : topological_space X,	_inst_2 : compact_space X,	A : subalgebra ℝ C(X, ℝ),	f : ↥A,	p : C(↥(set.Icc (-∥f∥) ∥f∥), ℝ),	mem_closure : p ∈ (polynomial_functions (set.Icc (-∥f∥) ∥f∥)).topological_closure,	frequently_mem_polynomials :	  ∃ᶠ (x : C(↥(set.Icc (-∥f∥) ∥f∥), ℝ)) in	    nhds p,	    x ∈ ↑(polynomial_functions (set.Icc (-∥f∥) ∥f∥))	⊢ p.comp ↑f.attach_bound ∈ A.topological_closure", "decl_nm": "continuous_map.comp_attach_bound_mem_closure"
{"src": "X : Type u_1,	_inst_1 : topological_space X,	_inst_2 : compact_space X,	A : subalgebra ℝ C(X, ℝ),	f : ↥A,	p : C(↥(set.Icc (-∥f∥) ∥f∥), ℝ),	mem_closure : p ∈ (polynomial_functions (set.Icc (-∥f∥) ∥f∥)).topological_closure,	frequently_mem_polynomials :	  ∃ᶠ (x : C(↥(set.Icc (-∥f∥) ∥f∥), ℝ)) in	    nhds p,	    x ∈ ↑(polynomial_functions (set.Icc (-∥f∥) ∥f∥))	⊢ ∃ᶠ (x : C(X, ℝ)) in nhds (p.comp ↑f.attach_bound), x ∈ ↑A", "decl_nm": "continuous_map.comp_attach_bound_mem_closure"
{"src": "X : Type u_1,	_inst_1 : topological_space X,	_inst_2 : compact_space X,	A : subalgebra ℝ C(X, ℝ),	f : ↥A,	p : C(↥(set.Icc (-∥f∥) ∥f∥), ℝ),	mem_closure : p ∈ (polynomial_functions (set.Icc (-∥f∥) ∥f∥)).topological_closure,	frequently_mem_polynomials :	  ∃ᶠ (x : C(↥(set.Icc (-∥f∥) ∥f∥), ℝ)) in	    nhds p,	    x ∈ ↑(polynomial_functions (set.Icc (-∥f∥) ∥f∥))	⊢ ∀ (x : C(↥(set.Icc (-∥↑f∥) ∥↑f∥), ℝ)),	    x ∈ ↑(polynomial_functions (set.Icc (-∥f∥) ∥f∥)) →	    ⇑(comp_right_continuous_map ℝ ↑f.attach_bound) x ∈ ↑A", "decl_nm": "continuous_map.comp_attach_bound_mem_closure"
{"src": "X : Type u_1,	_inst_1 : topological_space X,	_inst_2 : compact_space X,	A : subalgebra ℝ C(X, ℝ),	f : ↥A,	p : C(↥(set.Icc (-∥f∥) ∥f∥), ℝ),	mem_closure : p ∈ (polynomial_functions (set.Icc (-∥f∥) ∥f∥)).topological_closure,	frequently_mem_polynomials :	  ∃ᶠ (x : C(↥(set.Icc (-∥f∥) ∥f∥), ℝ)) in	    nhds p,	    x ∈ ↑(polynomial_functions (set.Icc (-∥f∥) ∥f∥)),	g : polynomial ℝ	⊢ ⇑(comp_right_continuous_map ℝ ↑f.attach_bound)	      (⇑↑(polynomial.to_continuous_map_on_alg_hom (set.Icc (-∥f∥) ∥f∥)) g) ∈	    ↑A", "decl_nm": "continuous_map.comp_attach_bound_mem_closure"
{"src": "X : Type u_1,	_inst_1 : topological_space X,	_inst_2 : compact_space X,	A : subalgebra ℝ C(X, ℝ),	f : ↥A,	p : C(↥(set.Icc (-∥f∥) ∥f∥), ℝ),	mem_closure : p ∈ (polynomial_functions (set.Icc (-∥f∥) ∥f∥)).topological_closure,	frequently_mem_polynomials :	  ∃ᶠ (x : C(↥(set.Icc (-∥f∥) ∥f∥), ℝ)) in	    nhds p,	    x ∈ ↑(polynomial_functions (set.Icc (-∥f∥) ∥f∥)),	g : polynomial ℝ	⊢ (g.to_continuous_map_on (set.Icc (-∥f∥) ∥f∥)).comp ↑f.attach_bound ∈ A", "decl_nm": "continuous_map.comp_attach_bound_mem_closure"
{"src": "⊢ ∀ {X : Type u_1} [_inst_1 : topological_space X] (A : discrete_quotient X), le_comap continuous_id A A", "decl_nm": "discrete_quotient.le_comap_id"
{"src": "X : Type u_1,	_inst_1 : topological_space X,	A : discrete_quotient X	⊢ le_comap continuous_id A A", "decl_nm": "discrete_quotient.le_comap_id"
{"src": "⊢ ∀ {X : Type u_1} [_inst_1 : topological_space X] {Y : Type u_2} [_inst_2 : topological_space Y] {f : Y → X}	  {cont : continuous f} {A : discrete_quotient Y} {B : discrete_quotient X} {C : discrete_quotient Y}	  (cond : le_comap cont A B) (h : C ≤ A), map _ = map cond ∘ of_le h", "decl_nm": "discrete_quotient.map_of_le"
{"src": "X : Type u_1,	_inst_1 : topological_space X,	Y : Type u_2,	_inst_2 : topological_space Y,	f : Y → X,	cont : continuous f,	A : discrete_quotient Y,	B : discrete_quotient X,	C : discrete_quotient Y,	cond : le_comap cont A B,	h : C ≤ A	⊢ map _ = map cond ∘ of_le h", "decl_nm": "discrete_quotient.map_of_le"
{"src": "X : Type u_1,	_inst_1 : topological_space X,	Y : Type u_2,	_inst_2 : topological_space Y,	f : Y → X,	cont : continuous f,	A : discrete_quotient Y,	B : discrete_quotient X,	C : discrete_quotient Y,	cond : le_comap cont A B,	h : C ≤ A,	x : Y	⊢ map _ (quot.mk setoid.r x) = (map cond ∘ of_le h) (quot.mk setoid.r x)", "decl_nm": "discrete_quotient.map_of_le"
{"src": "⊢ ∀ {X : Type u} {Y : Type v} [_inst_1 : topological_space X] [_inst_2 : topological_space Y]	  {f₀ f₁ f₂ : C(X, Y)} (F : f₀.homotopy f₁) (G : f₁.homotopy f₂) (x : ↥unit_interval × X),	    ⇑(F.trans G) x =	      dite (↑(x.fst) ≤ 1 / 2) (λ (h : ↑(x.fst) ≤ 1 / 2), ⇑F (⟨2 * ↑(x.fst), _⟩, x.snd))	        (λ (h : ¬↑(x.fst) ≤ 1 / 2), ⇑G (⟨2 * ↑(x.fst) - 1, _⟩, x.snd))", "decl_nm": "continuous_map.homotopy.trans_apply"
{"src": "X : Type u,	Y : Type v,	_inst_1 : topological_space X,	_inst_2 : topological_space Y,	f₀ f₁ f₂ : C(X, Y),	F : f₀.homotopy f₁,	G : f₁.homotopy f₂,	x : ↥unit_interval × X	⊢ ⇑(F.trans G) x =	    dite (↑(x.fst) ≤ 1 / 2) (λ (h : ↑(x.fst) ≤ 1 / 2), ⇑F (⟨2 * ↑(x.fst), _⟩, x.snd))	      (λ (h : ¬↑(x.fst) ≤ 1 / 2), ⇑G (⟨2 * ↑(x.fst) - 1, _⟩, x.snd))", "decl_nm": "continuous_map.homotopy.trans_apply"
{"src": "X : Type u,	Y : Type v,	_inst_1 : topological_space X,	_inst_2 : topological_space Y,	f₀ f₁ f₂ : C(X, Y),	F : f₀.homotopy f₁,	G : f₁.homotopy f₂,	x : ↥unit_interval × X	⊢ ite (↑(x.fst) ≤ 1 / 2) (⇑(⇑(F.extend) (2 * ↑(x.fst))) x.snd)	      (⇑(⇑(G.extend) (2 * ↑(x.fst) - 1)) x.snd) =	    dite (↑(x.fst) ≤ 1 / 2) (λ (h : ↑(x.fst) ≤ 1 / 2), ⇑F (⟨2 * ↑(x.fst), _⟩, x.snd))	      (λ (h : ¬↑(x.fst) ≤ 1 / 2), ⇑G (⟨2 * ↑(x.fst) - 1, _⟩, x.snd))", "decl_nm": "continuous_map.homotopy.trans_apply"
{"src": "2 goals	X : Type u,	Y : Type v,	_inst_1 : topological_space X,	_inst_2 : topological_space Y,	f₀ f₁ f₂ : C(X, Y),	F : f₀.homotopy f₁,	G : f₁.homotopy f₂,	x : ↥unit_interval × X,	h : ↑(x.fst) ≤ 1 / 2	⊢ ⇑(⇑(F.extend) (2 * ↑(x.fst))) x.snd = ⇑F (⟨2 * ↑(x.fst), _⟩, x.snd)		X : Type u,	Y : Type v,	_inst_1 : topological_space X,	_inst_2 : topological_space Y,	f₀ f₁ f₂ : C(X, Y),	F : f₀.homotopy f₁,	G : f₁.homotopy f₂,	x : ↥unit_interval × X,	h : ¬↑(x.fst) ≤ 1 / 2	⊢ ⇑(⇑(G.extend) (2 * ↑(x.fst) - 1)) x.snd = ⇑G (⟨2 * ↑(x.fst) - 1, _⟩, x.snd)", "decl_nm": "continuous_map.homotopy.trans_apply"
{"src": "3 goals	X : Type u,	Y : Type v,	_inst_1 : topological_space X,	_inst_2 : topological_space Y,	f₀ f₁ f₂ : C(X, Y),	F : f₀.homotopy f₁,	G : f₁.homotopy f₂,	x : ↥unit_interval × X,	h : ↑(x.fst) ≤ 1 / 2	⊢ ⇑(⇑(F.curry) ⟨2 * ↑(x.fst), ?m_1⟩) x.snd = ⇑F (⟨2 * ↑(x.fst), _⟩, x.snd)		X : Type u,	Y : Type v,	_inst_1 : topological_space X,	_inst_2 : topological_space Y,	f₀ f₁ f₂ : C(X, Y),	F : f₀.homotopy f₁,	G : f₁.homotopy f₂,	x : ↥unit_interval × X,	h : ↑(x.fst) ≤ 1 / 2	⊢ 2 * ↑(x.fst) ∈ set.Icc 0 1		X : Type u,	Y : Type v,	_inst_1 : topological_space X,	_inst_2 : topological_space Y,	f₀ f₁ f₂ : C(X, Y),	F : f₀.homotopy f₁,	G : f₁.homotopy f₂,	x : ↥unit_interval × X,	h : ¬↑(x.fst) ≤ 1 / 2	⊢ ⇑(⇑(G.extend) (2 * ↑(x.fst) - 1)) x.snd = ⇑G (⟨2 * ↑(x.fst) - 1, _⟩, x.snd)", "decl_nm": "continuous_map.homotopy.trans_apply"
{"src": "X : Type u,	Y : Type v,	_inst_1 : topological_space X,	_inst_2 : topological_space Y,	f₀ f₁ f₂ : C(X, Y),	F : f₀.homotopy f₁,	G : f₁.homotopy f₂,	x : ↥unit_interval × X,	h : ¬↑(x.fst) ≤ 1 / 2	⊢ ⇑(⇑(G.extend) (2 * ↑(x.fst) - 1)) x.snd = ⇑G (⟨2 * ↑(x.fst) - 1, _⟩, x.snd)", "decl_nm": "continuous_map.homotopy.trans_apply"
{"src": "2 goals	X : Type u,	Y : Type v,	_inst_1 : topological_space X,	_inst_2 : topological_space Y,	f₀ f₁ f₂ : C(X, Y),	F : f₀.homotopy f₁,	G : f₁.homotopy f₂,	x : ↥unit_interval × X,	h : ¬↑(x.fst) ≤ 1 / 2	⊢ ⇑(⇑(G.curry) ⟨2 * ↑(x.fst) - 1, ?m_1⟩) x.snd = ⇑G (⟨2 * ↑(x.fst) - 1, _⟩, x.snd)		X : Type u,	Y : Type v,	_inst_1 : topological_space X,	_inst_2 : topological_space Y,	f₀ f₁ f₂ : C(X, Y),	F : f₀.homotopy f₁,	G : f₁.homotopy f₂,	x : ↥unit_interval × X,	h : ¬↑(x.fst) ≤ 1 / 2	⊢ 2 * ↑(x.fst) - 1 ∈ set.Icc 0 1", "decl_nm": "continuous_map.homotopy.trans_apply"
{"src": "⊢ ∀ {s : set ereal}, s ∈ nhds ⊥ ↔ ∃ (y : ℝ), Iio ↑y ⊆ s", "decl_nm": "ereal.mem_nhds_bot_iff"
{"src": "s : set ereal	⊢ s ∈ nhds ⊥ ↔ ∃ (y : ℝ), Iio ↑y ⊆ s", "decl_nm": "ereal.mem_nhds_bot_iff"
{"src": "2 goals	s : set ereal	⊢ (∃ (i : ℝ), s ∈ principal (Iio ↑i)) ↔ ∃ (y : ℝ), Iio ↑y ⊆ s		s : set ereal	⊢ directed ge (λ (a : ℝ), principal (Iio ↑a))", "decl_nm": "ereal.mem_nhds_bot_iff"
{"src": "s : set ereal	⊢ directed ge (λ (a : ℝ), principal (Iio ↑a))", "decl_nm": "ereal.mem_nhds_bot_iff"
{"src": "⊢ ∀ {α : Type u_1} {β : Type u_2} [_inst_1 : topological_space α] [_inst_2 : topological_space β]	  (e : local_homeomorph α β) {x : α},	    x ∈ e.to_local_equiv.source →	    ∀ (s : set β), map ⇑e (nhds_within x (⇑e ⁻¹' s)) = nhds_within (⇑e x) s", "decl_nm": "local_homeomorph.map_nhds_within_preimage_eq"
{"src": "α : Type u_1,	β : Type u_2,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	e : local_homeomorph α β,	x : α,	hx : x ∈ e.to_local_equiv.source,	s : set β	⊢ map ⇑e (nhds_within x (⇑e ⁻¹' s)) = nhds_within (⇑e x) s", "decl_nm": "local_homeomorph.map_nhds_within_preimage_eq"
{"src": "⊢ ∀ {α : Type u_1} {β : Type u_2} [_inst_1 : topological_space α] [_inst_2 : topological_space β]	  {f : α → β}, inducing f → is_closed (range f) → is_closed_map f", "decl_nm": "inducing.is_closed_map"
{"src": "α : Type u_1,	β : Type u_2,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	f : α → β,	hf : inducing f,	h : is_closed (range f)	⊢ is_closed_map f", "decl_nm": "inducing.is_closed_map"
{"src": "α : Type u_1,	β : Type u_2,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	f : α → β,	hf : inducing f,	h : is_closed (range f),	s : set α,	hs : is_closed s	⊢ is_closed (f '' s)", "decl_nm": "inducing.is_closed_map"
{"src": "α : Type u_1,	β : Type u_2,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	f : α → β,	hf : inducing f,	h : is_closed (range f),	t : set β,	ht : is_closed t,	hs : is_closed (f ⁻¹' t)	⊢ is_closed (f '' (f ⁻¹' t))", "decl_nm": "inducing.is_closed_map"
{"src": "α : Type u_1,	β : Type u_2,	_inst_1 : topological_space α,	_inst_2 : topological_space β,	f : α → β,	hf : inducing f,	h : is_closed (range f),	t : set β,	ht : is_closed t,	hs : is_closed (f ⁻¹' t)	⊢ is_closed (t ∩ range f)", "decl_nm": "inducing.is_closed_map"
{"src": "⊢ ∀ {α : Type u} [_inst_1 : pseudo_metric_space α] {ι : Type u_1} {f : ι → α × α} {p : filter ι},	    tendsto f p (uniformity α) ↔ tendsto (λ (x : ι), dist (f x).fst (f x).snd) p (nhds 0)", "decl_nm": "tendsto_uniformity_iff_dist_tendsto_zero"
{"src": "α : Type u,	_inst_1 : pseudo_metric_space α,	ι : Type u_1,	f : ι → α × α,	p : filter ι	⊢ tendsto f p (uniformity α) ↔ tendsto (λ (x : ι), dist (f x).fst (f x).snd) p (nhds 0)", "decl_nm": "tendsto_uniformity_iff_dist_tendsto_zero"
{"src": "⊢ ∀ {β : Type v} {π : β → Type u_1} [_inst_2 : fintype β] [_inst_3 : Π (b : β), pseudo_metric_space (π b)]	  (x : Π (b : β), π b) {r : ℝ}, 0 ≤ r → closed_ball x r = univ.pi (λ (b : β), closed_ball (x b) r)", "decl_nm": "closed_ball_pi"
{"src": "β : Type v,	π : β → Type u_1,	_inst_2 : fintype β,	_inst_3 : Π (b : β), pseudo_metric_space (π b),	x : Π (b : β), π b,	r : ℝ,	hr : 0 ≤ r	⊢ closed_ball x r = univ.pi (λ (b : β), closed_ball (x b) r)", "decl_nm": "closed_ball_pi"
{"src": "β : Type v,	π : β → Type u_1,	_inst_2 : fintype β,	_inst_3 : Π (b : β), pseudo_metric_space (π b),	x : Π (b : β), π b,	r : ℝ,	hr : 0 ≤ r,	p : Π (b : β), π b	⊢ p ∈ closed_ball x r ↔ p ∈ univ.pi (λ (b : β), closed_ball (x b) r)", "decl_nm": "closed_ball_pi"
{"src": "⊢ ∀ {γ : Type w} [_inst_2 : metric_space γ] {x y : γ}, dist x y ≤ 0 ↔ x = y", "decl_nm": "dist_le_zero"
{"src": "γ : Type w,	_inst_2 : metric_space γ,	x y : γ	⊢ dist x y ≤ 0 ↔ x = y", "decl_nm": "dist_le_zero"
{"src": "⊢ ∀ {α : Type u} [_inst_1 : pseudo_metric_space α] (x y : α), nndist x y = (edist x y).to_nnreal", "decl_nm": "nndist_edist"
{"src": "α : Type u,	_inst_1 : pseudo_metric_space α,	x y : α	⊢ nndist x y = (edist x y).to_nnreal", "decl_nm": "nndist_edist"
{"src": "⊢ ∀ {α : Type u} [_inst_1 : pseudo_metric_space α] (ε : ℝ) (x : α),	    uniform_space.ball x {p : α × α | dist p.fst p.snd < ε} = ball x ε", "decl_nm": "metric.ball_eq_ball'"
{"src": "α : Type u,	_inst_1 : pseudo_metric_space α,	ε : ℝ,	x : α	⊢ uniform_space.ball x {p : α × α | dist p.fst p.snd < ε} = ball x ε", "decl_nm": "metric.ball_eq_ball'"
{"src": "α : Type u,	_inst_1 : pseudo_metric_space α,	ε : ℝ,	x x_1 : α	⊢ x_1 ∈ uniform_space.ball x {p : α × α | dist p.fst p.snd < ε} ↔ x_1 ∈ ball x ε", "decl_nm": "metric.ball_eq_ball'"
{"src": "⊢ ∀ {α : Type u} [_inst_1 : pseudo_metric_space α] {x y : α} {ε : ℝ}, x ∈ ball y ε ↔ y ∈ ball x ε", "decl_nm": "metric.mem_ball_comm"
{"src": "α : Type u,	_inst_1 : pseudo_metric_space α,	x y : α,	ε : ℝ	⊢ x ∈ ball y ε ↔ y ∈ ball x ε", "decl_nm": "metric.mem_ball_comm"
{"src": "⊢ ∀ {α : Type u} [_inst_1 : pseudo_metric_space α] {x : α} {ε : ℝ},	    0 ≤ ε → emetric.closed_ball x (ennreal.of_real ε) = closed_ball x ε", "decl_nm": "metric.emetric_closed_ball"
{"src": "α : Type u,	_inst_1 : pseudo_metric_space α,	x : α,	ε : ℝ,	h : 0 ≤ ε	⊢ emetric.closed_ball x (ennreal.of_real ε) = closed_ball x ε", "decl_nm": "metric.emetric_closed_ball"
{"src": "α : Type u,	_inst_1 : pseudo_metric_space α,	x : α,	ε : ℝ,	h : 0 ≤ ε,	y : α	⊢ y ∈ emetric.closed_ball x (ennreal.of_real ε) ↔ y ∈ closed_ball x ε", "decl_nm": "metric.emetric_closed_ball"
{"src": "α : Type u,	_inst_1 : pseudo_metric_space α,	x : α,	ε : ℝ,	h : 0 ≤ ε,	y : α	⊢ ennreal.of_real (dist y x) ≤ ennreal.of_real ε ↔ dist y x ≤ ε", "decl_nm": "metric.emetric_closed_ball"
{"src": "⊢ ∀ {α : Type u} [_inst_1 : pseudo_emetric_space α] {x y : α} {ε : ennreal}, y ∈ ball x ε ↔ edist x y < ε", "decl_nm": "emetric.mem_ball'"
{"src": "α : Type u,	_inst_1 : pseudo_emetric_space α,	x y : α,	ε : ennreal	⊢ y ∈ ball x ε ↔ edist x y < ε", "decl_nm": "emetric.mem_ball'"
{"src": "α : Type u,	_inst_1 : pseudo_emetric_space α,	x y : α,	ε : ennreal	⊢ y ∈ ball x ε ↔ edist y x < ε", "decl_nm": "emetric.mem_ball'"
{"src": "⊢ ∀ {α : Type u} [_inst_1 : pseudo_emetric_space α] {s t : set α},	    Hausdorff_edist s t ≠ ⊤ → s = ∅ ∧ t = ∅ ∨ s.nonempty ∧ t.nonempty", "decl_nm": "emetric.empty_or_nonempty_of_Hausdorff_edist_ne_top"
{"src": "α : Type u,	_inst_1 : pseudo_emetric_space α,	s t : set α,	fin : Hausdorff_edist s t ≠ ⊤	⊢ s = ∅ ∧ t = ∅ ∨ s.nonempty ∧ t.nonempty", "decl_nm": "emetric.empty_or_nonempty_of_Hausdorff_edist_ne_top"
{"src": "2 goals	case or.inl	α : Type u,	_inst_1 : pseudo_emetric_space α,	s t : set α,	fin : Hausdorff_edist s t ≠ ⊤,	hs : s = ∅	⊢ s = ∅ ∧ t = ∅ ∨ s.nonempty ∧ t.nonempty		case or.inr	α : Type u,	_inst_1 : pseudo_emetric_space α,	s t : set α,	fin : Hausdorff_edist s t ≠ ⊤,	hs : s.nonempty	⊢ s = ∅ ∧ t = ∅ ∨ s.nonempty ∧ t.nonempty", "decl_nm": "emetric.empty_or_nonempty_of_Hausdorff_edist_ne_top"
{"src": "3 goals	case or.inl, or.inl	α : Type u,	_inst_1 : pseudo_emetric_space α,	s t : set α,	fin : Hausdorff_edist s t ≠ ⊤,	hs : s = ∅,	ht : t = ∅	⊢ s = ∅ ∧ t = ∅ ∨ s.nonempty ∧ t.nonempty		case or.inl, or.inr	α : Type u,	_inst_1 : pseudo_emetric_space α,	s t : set α,	fin : Hausdorff_edist s t ≠ ⊤,	hs : s = ∅,	ht : t.nonempty	⊢ s = ∅ ∧ t = ∅ ∨ s.nonempty ∧ t.nonempty		case or.inr	α : Type u,	_inst_1 : pseudo_emetric_space α,	s t : set α,	fin : Hausdorff_edist s t ≠ ⊤,	hs : s.nonempty	⊢ s = ∅ ∧ t = ∅ ∨ s.nonempty ∧ t.nonempty", "decl_nm": "emetric.empty_or_nonempty_of_Hausdorff_edist_ne_top"
{"src": "2 goals	case or.inl, or.inr	α : Type u,	_inst_1 : pseudo_emetric_space α,	s t : set α,	fin : Hausdorff_edist s t ≠ ⊤,	hs : s = ∅,	ht : t.nonempty	⊢ s = ∅ ∧ t = ∅ ∨ s.nonempty ∧ t.nonempty		case or.inr	α : Type u,	_inst_1 : pseudo_emetric_space α,	s t : set α,	fin : Hausdorff_edist s t ≠ ⊤,	hs : s.nonempty	⊢ s = ∅ ∧ t = ∅ ∨ s.nonempty ∧ t.nonempty", "decl_nm": "emetric.empty_or_nonempty_of_Hausdorff_edist_ne_top"
{"src": "2 goals	case or.inl, or.inr	α : Type u,	_inst_1 : pseudo_emetric_space α,	s t : set α,	hs : s = ∅,	ht : t.nonempty,	fin : Hausdorff_edist t s ≠ ⊤	⊢ s = ∅ ∧ t = ∅ ∨ s.nonempty ∧ t.nonempty		case or.inr	α : Type u,	_inst_1 : pseudo_emetric_space α,	s t : set α,	fin : Hausdorff_edist s t ≠ ⊤,	hs : s.nonempty	⊢ s = ∅ ∧ t = ∅ ∨ s.nonempty ∧ t.nonempty", "decl_nm": "emetric.empty_or_nonempty_of_Hausdorff_edist_ne_top"
{"src": "case or.inr	α : Type u,	_inst_1 : pseudo_emetric_space α,	s t : set α,	fin : Hausdorff_edist s t ≠ ⊤,	hs : s.nonempty	⊢ s = ∅ ∧ t = ∅ ∨ s.nonempty ∧ t.nonempty", "decl_nm": "emetric.empty_or_nonempty_of_Hausdorff_edist_ne_top"
{"src": "⊢ ∀ {α : Type u} {β : Type v} [_inst_1 : pseudo_metric_space α] [_inst_2 : pseudo_metric_space β]	  {f : α → β}, isometry f → ∀ (x y : α), dist (f x) (f y) = dist x y", "decl_nm": "isometry.dist_eq"
{"src": "α : Type u,	β : Type v,	_inst_1 : pseudo_metric_space α,	_inst_2 : pseudo_metric_space β,	f : α → β,	hf : isometry f,	x y : α	⊢ dist (f x) (f y) = dist x y", "decl_nm": "isometry.dist_eq"
{"src": "⊢ ∀ {α : Type u} [_inst_1 : preorder α] {c : chain α} {x : α}, is_ωSup c x ↔ is_lub (set.range ⇑c) x", "decl_nm": "Scott.is_ωSup_iff_is_lub"
{"src": "α : Type u,	_inst_1 : preorder α,	c : chain α,	x : α	⊢ is_ωSup c x ↔ is_lub (set.range ⇑c) x", "decl_nm": "Scott.is_ωSup_iff_is_lub"
{"src": "⊢ ∀ {H : Type u_1} [_inst_2 : topological_space H] [_inst_3 : locally_compact_space H] [_inst_4 : t2_space H]	  [_inst_5 : totally_disconnected_space H], is_topological_basis {s : set H | is_clopen s}", "decl_nm": "loc_compact_Haus_tot_disc_of_zero_dim"
{"src": "H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H	⊢ is_topological_basis {s : set H | is_clopen s}", "decl_nm": "loc_compact_Haus_tot_disc_of_zero_dim"
{"src": "H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H	⊢ ∀ (a : H) (u : set H),	    a ∈ u → is_open u → (∃ (v : set H) (H_1 : v ∈ {s : set H | is_clopen s}), a ∈ v ∧ v ⊆ u)", "decl_nm": "loc_compact_Haus_tot_disc_of_zero_dim"
{"src": "H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U	⊢ ∃ (v : set H) (H_1 : v ∈ {s : set H | is_clopen s}), x ∈ v ∧ v ⊆ U", "decl_nm": "loc_compact_Haus_tot_disc_of_zero_dim"
{"src": "H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U	⊢ ∃ (v : set H) (H_1 : v ∈ {s : set H | is_clopen s}), x ∈ v ∧ v ⊆ U", "decl_nm": "loc_compact_Haus_tot_disc_of_zero_dim"
{"src": "H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t	⊢ ∃ (v : set H) (H_1 : v ∈ {s : set H | is_clopen s}), x ∈ v ∧ v ⊆ U", "decl_nm": "loc_compact_Haus_tot_disc_of_zero_dim"
{"src": "H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s	⊢ ∃ (v : set H) (H_1 : v ∈ {s : set H | is_clopen s}), x ∈ v ∧ v ⊆ U", "decl_nm": "loc_compact_Haus_tot_disc_of_zero_dim"
{"src": "H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u	⊢ ∃ (v : set H) (H_1 : v ∈ {s : set H | is_clopen s}), x ∈ v ∧ v ⊆ U", "decl_nm": "loc_compact_Haus_tot_disc_of_zero_dim"
{"src": "H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩	⊢ ∃ (v : set H) (H_1 : v ∈ {s : set H | is_clopen s}), x ∈ v ∧ v ⊆ U", "decl_nm": "loc_compact_Haus_tot_disc_of_zero_dim"
{"src": "H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u	⊢ ∃ (v : set H) (H_1 : v ∈ {s : set H | is_clopen s}), x ∈ v ∧ v ⊆ U", "decl_nm": "loc_compact_Haus_tot_disc_of_zero_dim"
{"src": "H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s	⊢ ∃ (v : set H) (H_1 : v ∈ {s : set H | is_clopen s}), x ∈ v ∧ v ⊆ U", "decl_nm": "loc_compact_Haus_tot_disc_of_zero_dim"
{"src": "H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u	⊢ ∃ (v : set H) (H_1 : v ∈ {s : set H | is_clopen s}), x ∈ v ∧ v ⊆ U", "decl_nm": "loc_compact_Haus_tot_disc_of_zero_dim"
{"src": "2 goals	H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u	⊢ is_clopen (coe '' V)		H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	V_clopen : is_clopen (coe '' V)	⊢ ∃ (v : set H) (H_1 : v ∈ {s : set H | is_clopen s}), x ∈ v ∧ v ⊆ U", "decl_nm": "loc_compact_Haus_tot_disc_of_zero_dim"
{"src": "2 goals	H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u	⊢ is_open (coe '' V)		H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	V_clopen : is_clopen (coe '' V)	⊢ ∃ (v : set H) (H_1 : v ∈ {s : set H | is_clopen s}), x ∈ v ∧ v ⊆ U", "decl_nm": "loc_compact_Haus_tot_disc_of_zero_dim"
{"src": "2 goals	H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	v : set ↥u := coe ⁻¹' V	⊢ is_open (coe '' V)		H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	V_clopen : is_clopen (coe '' V)	⊢ ∃ (v : set H) (H_1 : v ∈ {s : set H | is_clopen s}), x ∈ v ∧ v ⊆ U", "decl_nm": "loc_compact_Haus_tot_disc_of_zero_dim"
{"src": "2 goals	H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	v : set ↥u := coe ⁻¹' V,	this : coe = coe ∘ coe	⊢ is_open (coe '' V)		H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	V_clopen : is_clopen (coe '' V)	⊢ ∃ (v : set H) (H_1 : v ∈ {s : set H | is_clopen s}), x ∈ v ∧ v ⊆ U", "decl_nm": "loc_compact_Haus_tot_disc_of_zero_dim"
{"src": "2 goals	H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	v : set ↥u := coe ⁻¹' V,	this : coe = coe ∘ coe,	f0 : embedding coe	⊢ is_open (coe '' V)		H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	V_clopen : is_clopen (coe '' V)	⊢ ∃ (v : set H) (H_1 : v ∈ {s : set H | is_clopen s}), x ∈ v ∧ v ⊆ U", "decl_nm": "loc_compact_Haus_tot_disc_of_zero_dim"
{"src": "3 goals	H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	v : set ↥u := coe ⁻¹' V,	this : coe = coe ∘ coe,	f0 : embedding coe	⊢ open_embedding coe		H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	v : set ↥u := coe ⁻¹' V,	this : coe = coe ∘ coe,	f0 : embedding coe,	f1 : open_embedding coe	⊢ is_open (coe '' V)		H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	V_clopen : is_clopen (coe '' V)	⊢ ∃ (v : set H) (H_1 : v ∈ {s : set H | is_clopen s}), x ∈ v ∧ v ⊆ U", "decl_nm": "loc_compact_Haus_tot_disc_of_zero_dim"
{"src": "3 goals	H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	v : set ↥u := coe ⁻¹' V,	this : coe = coe ∘ coe,	f0 : embedding coe	⊢ is_open (range coe)		H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	v : set ↥u := coe ⁻¹' V,	this : coe = coe ∘ coe,	f0 : embedding coe,	f1 : open_embedding coe	⊢ is_open (coe '' V)		H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	V_clopen : is_clopen (coe '' V)	⊢ ∃ (v : set H) (H_1 : v ∈ {s : set H | is_clopen s}), x ∈ v ∧ v ⊆ U", "decl_nm": "loc_compact_Haus_tot_disc_of_zero_dim"
{"src": "4 goals	H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	v : set ↥u := coe ⁻¹' V,	this : coe = coe ∘ coe,	f0 : embedding coe	⊢ range coe = interior s		H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	v : set ↥u := coe ⁻¹' V,	this : coe = coe ∘ coe,	f0 : embedding coe,	this : range coe = interior s	⊢ is_open (range coe)		H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	v : set ↥u := coe ⁻¹' V,	this : coe = coe ∘ coe,	f0 : embedding coe,	f1 : open_embedding coe	⊢ is_open (coe '' V)		H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	V_clopen : is_clopen (coe '' V)	⊢ ∃ (v : set H) (H_1 : v ∈ {s : set H | is_clopen s}), x ∈ v ∧ v ⊆ U", "decl_nm": "loc_compact_Haus_tot_disc_of_zero_dim"
{"src": "4 goals	H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	v : set ↥u := coe ⁻¹' V,	this : coe = coe ∘ coe,	f0 : embedding coe	⊢ interior s ∩ s = interior s		H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	v : set ↥u := coe ⁻¹' V,	this : coe = coe ∘ coe,	f0 : embedding coe,	this : range coe = interior s	⊢ is_open (range coe)		H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	v : set ↥u := coe ⁻¹' V,	this : coe = coe ∘ coe,	f0 : embedding coe,	f1 : open_embedding coe	⊢ is_open (coe '' V)		H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	V_clopen : is_clopen (coe '' V)	⊢ ∃ (v : set H) (H_1 : v ∈ {s : set H | is_clopen s}), x ∈ v ∧ v ⊆ U", "decl_nm": "loc_compact_Haus_tot_disc_of_zero_dim"
{"src": "3 goals	H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	v : set ↥u := coe ⁻¹' V,	this : coe = coe ∘ coe,	f0 : embedding coe,	this : range coe = interior s	⊢ is_open (range coe)		H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	v : set ↥u := coe ⁻¹' V,	this : coe = coe ∘ coe,	f0 : embedding coe,	f1 : open_embedding coe	⊢ is_open (coe '' V)		H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	V_clopen : is_clopen (coe '' V)	⊢ ∃ (v : set H) (H_1 : v ∈ {s : set H | is_clopen s}), x ∈ v ∧ v ⊆ U", "decl_nm": "loc_compact_Haus_tot_disc_of_zero_dim"
{"src": "3 goals	H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	v : set ↥u := coe ⁻¹' V,	this : coe = coe ∘ coe,	f0 : embedding coe,	this : range coe = interior s	⊢ is_open (interior s)		H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	v : set ↥u := coe ⁻¹' V,	this : coe = coe ∘ coe,	f0 : embedding coe,	f1 : open_embedding coe	⊢ is_open (coe '' V)		H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	V_clopen : is_clopen (coe '' V)	⊢ ∃ (v : set H) (H_1 : v ∈ {s : set H | is_clopen s}), x ∈ v ∧ v ⊆ U", "decl_nm": "loc_compact_Haus_tot_disc_of_zero_dim"
{"src": "2 goals	H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	v : set ↥u := coe ⁻¹' V,	this : coe = coe ∘ coe,	f0 : embedding coe,	f1 : open_embedding coe	⊢ is_open (coe '' V)		H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	V_clopen : is_clopen (coe '' V)	⊢ ∃ (v : set H) (H_1 : v ∈ {s : set H | is_clopen s}), x ∈ v ∧ v ⊆ U", "decl_nm": "loc_compact_Haus_tot_disc_of_zero_dim"
{"src": "2 goals	H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	v : set ↥u := coe ⁻¹' V,	this : coe = coe ∘ coe,	f0 : embedding coe,	f1 : open_embedding coe,	f2 : is_open v	⊢ is_open (coe '' V)		H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	V_clopen : is_clopen (coe '' V)	⊢ ∃ (v : set H) (H_1 : v ∈ {s : set H | is_clopen s}), x ∈ v ∧ v ⊆ U", "decl_nm": "loc_compact_Haus_tot_disc_of_zero_dim"
{"src": "3 goals	H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	v : set ↥u := coe ⁻¹' V,	this : coe = coe ∘ coe,	f0 : embedding coe,	f1 : open_embedding coe,	f2 : is_open v	⊢ coe '' V = coe '' v		H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	v : set ↥u := coe ⁻¹' V,	this : coe = coe ∘ coe,	f0 : embedding coe,	f1 : open_embedding coe,	f2 : is_open v,	f3 : coe '' V = coe '' v	⊢ is_open (coe '' V)		H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	V_clopen : is_clopen (coe '' V)	⊢ ∃ (v : set H) (H_1 : v ∈ {s : set H | is_clopen s}), x ∈ v ∧ v ⊆ U", "decl_nm": "loc_compact_Haus_tot_disc_of_zero_dim"
{"src": "2 goals	H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	v : set ↥u := coe ⁻¹' V,	this : coe = coe ∘ coe,	f0 : embedding coe,	f1 : open_embedding coe,	f2 : is_open v,	f3 : coe '' V = coe '' v	⊢ is_open (coe '' V)		H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	V_clopen : is_clopen (coe '' V)	⊢ ∃ (v : set H) (H_1 : v ∈ {s : set H | is_clopen s}), x ∈ v ∧ v ⊆ U", "decl_nm": "loc_compact_Haus_tot_disc_of_zero_dim"
{"src": "2 goals	H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	v : set ↥u := coe ⁻¹' V,	this : coe = coe ∘ coe,	f0 : embedding coe,	f1 : open_embedding coe,	f2 : is_open v,	f3 : coe '' V = coe '' v	⊢ is_open (coe '' v)		H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	V_clopen : is_clopen (coe '' V)	⊢ ∃ (v : set H) (H_1 : v ∈ {s : set H | is_clopen s}), x ∈ v ∧ v ⊆ U", "decl_nm": "loc_compact_Haus_tot_disc_of_zero_dim"
{"src": "H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	V_clopen : is_clopen (coe '' V)	⊢ ∃ (v : set H) (H_1 : v ∈ {s : set H | is_clopen s}), x ∈ v ∧ v ⊆ U", "decl_nm": "loc_compact_Haus_tot_disc_of_zero_dim"
{"src": "H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	V_clopen : is_clopen (coe '' V)	⊢ coe '' V ⊆ U", "decl_nm": "loc_compact_Haus_tot_disc_of_zero_dim"
{"src": "2 goals	H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	V_clopen : is_clopen (coe '' V)	⊢ coe '' V ⊆ s		H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	V_clopen : is_clopen (coe '' V)	⊢ s ⊆ U", "decl_nm": "loc_compact_Haus_tot_disc_of_zero_dim"
{"src": "H : Type u_1,	_inst_2 : topological_space H,	_inst_3 : locally_compact_space H,	_inst_4 : t2_space H,	_inst_5 : totally_disconnected_space H,	x : H,	U : set H,	memU : x ∈ U,	hU : is_open U,	s : set H,	comp : is_compact s,	xs : x ∈ interior s,	sU : s ⊆ U,	t : set H,	h : t ⊆ s,	ht : is_open t,	xt : x ∈ t,	u : set ↥s := coe ⁻¹' interior s,	u_open_in_s : is_open u,	X : ↥s := ⟨x, _⟩,	Xu : X ∈ u,	_inst : compact_space ↥s,	V : set ↥s,	clopen_in_s : is_clopen V,	Vx : X ∈ V,	V_sub : V ⊆ u,	V_clopen : is_clopen (coe '' V)	⊢ s ⊆ U", "decl_nm": "loc_compact_Haus_tot_disc_of_zero_dim"
{"src": "⊢ ∀ {α : Type u_1} [_inst_2 : topological_space α] [_inst_3 : t0_space α] [_inst_4 : compact_space α]	  {S : set α}, is_closed S → S.nonempty → (∃ (x : α), x ∈ S ∧ is_closed {x})", "decl_nm": "is_closed.exists_closed_singleton"
{"src": "α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty	⊢ ∃ (x : α), x ∈ S ∧ is_closed {x}", "decl_nm": "is_closed.exists_closed_singleton"
{"src": "α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V	⊢ ∃ (x : α), x ∈ S ∧ is_closed {x}", "decl_nm": "is_closed.exists_closed_singleton"
{"src": "2 goals	α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	hnt : ∃ (x y : α) (hx : x ∈ V) (hy : y ∈ V), x ≠ y	⊢ ∃ (x : α), x ∈ S ∧ is_closed {x}		α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	hnt : ¬∃ (x y : α) (hx : x ∈ V) (hy : y ∈ V), x ≠ y	⊢ ∃ (x : α), x ∈ S ∧ is_closed {x}", "decl_nm": "is_closed.exists_closed_singleton"
{"src": "2 goals	α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	hnt : ∃ (x y : α) (hx : x ∈ V) (hy : y ∈ V), x ≠ y	⊢ false		α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	hnt : ¬∃ (x y : α) (hx : x ∈ V) (hy : y ∈ V), x ≠ y	⊢ ∃ (x : α), x ∈ S ∧ is_closed {x}", "decl_nm": "is_closed.exists_closed_singleton"
{"src": "2 goals	α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y	⊢ false		α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	hnt : ¬∃ (x y : α) (hx : x ∈ V) (hy : y ∈ V), x ≠ y	⊢ ∃ (x : α), x ∈ S ∧ is_closed {x}", "decl_nm": "is_closed.exists_closed_singleton"
{"src": "2 goals	α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y,	U : set α,	hU : is_open U,	hsep : xor (x ∈ U) (y ∈ U)	⊢ false		α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	hnt : ¬∃ (x y : α) (hx : x ∈ V) (hy : y ∈ V), x ≠ y	⊢ ∃ (x : α), x ∈ S ∧ is_closed {x}", "decl_nm": "is_closed.exists_closed_singleton"
{"src": "3 goals	α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y,	U : set α,	hU : is_open U,	hsep : xor (x ∈ U) (y ∈ U)	⊢ ∀ (z w : α), z ∈ V → w ∈ V → z ∈ U → w ∉ U → false		α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y,	U : set α,	hU : is_open U,	hsep : xor (x ∈ U) (y ∈ U),	this : ∀ (z w : α), z ∈ V → w ∈ V → z ∈ U → w ∉ U → false	⊢ false		α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	hnt : ¬∃ (x y : α) (hx : x ∈ V) (hy : y ∈ V), x ≠ y	⊢ ∃ (x : α), x ∈ S ∧ is_closed {x}", "decl_nm": "is_closed.exists_closed_singleton"
{"src": "3 goals	α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y,	U : set α,	hU : is_open U,	hsep : xor (x ∈ U) (y ∈ U),	z w : α,	hz : z ∈ V,	hw : w ∈ V,	hz' : z ∈ U,	hw' : w ∉ U	⊢ false		α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y,	U : set α,	hU : is_open U,	hsep : xor (x ∈ U) (y ∈ U),	this : ∀ (z w : α), z ∈ V → w ∈ V → z ∈ U → w ∉ U → false	⊢ false		α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	hnt : ¬∃ (x y : α) (hx : x ∈ V) (hy : y ∈ V), x ≠ y	⊢ ∃ (x : α), x ∈ S ∧ is_closed {x}", "decl_nm": "is_closed.exists_closed_singleton"
{"src": "4 goals	α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y,	U : set α,	hU : is_open U,	hsep : xor (x ∈ U) (y ∈ U),	z w : α,	hz : z ∈ V,	hw : w ∈ V,	hz' : z ∈ U,	hw' : w ∉ U	⊢ (V ∩ Uᶜ).nonempty		α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y,	U : set α,	hU : is_open U,	hsep : xor (x ∈ U) (y ∈ U),	z w : α,	hz : z ∈ V,	hw : w ∈ V,	hz' : z ∈ U,	hw' : w ∉ U,	uvne : (V ∩ Uᶜ).nonempty	⊢ false		α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y,	U : set α,	hU : is_open U,	hsep : xor (x ∈ U) (y ∈ U),	this : ∀ (z w : α), z ∈ V → w ∈ V → z ∈ U → w ∉ U → false	⊢ false		α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	hnt : ¬∃ (x y : α) (hx : x ∈ V) (hy : y ∈ V), x ≠ y	⊢ ∃ (x : α), x ∈ S ∧ is_closed {x}", "decl_nm": "is_closed.exists_closed_singleton"
{"src": "4 goals	α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y,	U : set α,	hU : is_open U,	hsep : xor (x ∈ U) (y ∈ U),	z w : α,	hz : z ∈ V,	hw : w ∈ V,	hz' : z ∈ U,	hw' : w ∉ U	⊢ w ∈ V ∩ Uᶜ		α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y,	U : set α,	hU : is_open U,	hsep : xor (x ∈ U) (y ∈ U),	z w : α,	hz : z ∈ V,	hw : w ∈ V,	hz' : z ∈ U,	hw' : w ∉ U,	uvne : (V ∩ Uᶜ).nonempty	⊢ false		α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y,	U : set α,	hU : is_open U,	hsep : xor (x ∈ U) (y ∈ U),	this : ∀ (z w : α), z ∈ V → w ∈ V → z ∈ U → w ∉ U → false	⊢ false		α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	hnt : ¬∃ (x y : α) (hx : x ∈ V) (hy : y ∈ V), x ≠ y	⊢ ∃ (x : α), x ∈ S ∧ is_closed {x}", "decl_nm": "is_closed.exists_closed_singleton"
{"src": "3 goals	α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y,	U : set α,	hU : is_open U,	hsep : xor (x ∈ U) (y ∈ U),	z w : α,	hz : z ∈ V,	hw : w ∈ V,	hz' : z ∈ U,	hw' : w ∉ U,	uvne : (V ∩ Uᶜ).nonempty	⊢ false		α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y,	U : set α,	hU : is_open U,	hsep : xor (x ∈ U) (y ∈ U),	this : ∀ (z w : α), z ∈ V → w ∈ V → z ∈ U → w ∉ U → false	⊢ false		α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	hnt : ¬∃ (x y : α) (hx : x ∈ V) (hy : y ∈ V), x ≠ y	⊢ ∃ (x : α), x ∈ S ∧ is_closed {x}", "decl_nm": "is_closed.exists_closed_singleton"
{"src": "3 goals	α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y,	U : set α,	hU : is_open U,	hsep : xor (x ∈ U) (y ∈ U),	z w : α,	hz : z ∈ V,	hw : w ∈ V,	hz' : z ∈ U,	hw' : w ∉ U,	uvne : (V ∩ Uᶜ).nonempty,	hV : V ∩ Uᶜ = V	⊢ false		α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y,	U : set α,	hU : is_open U,	hsep : xor (x ∈ U) (y ∈ U),	this : ∀ (z w : α), z ∈ V → w ∈ V → z ∈ U → w ∉ U → false	⊢ false		α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	hnt : ¬∃ (x y : α) (hx : x ∈ V) (hy : y ∈ V), x ≠ y	⊢ ∃ (x : α), x ∈ S ∧ is_closed {x}", "decl_nm": "is_closed.exists_closed_singleton"
{"src": "4 goals	α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y,	U : set α,	hU : is_open U,	hsep : xor (x ∈ U) (y ∈ U),	z w : α,	hz : z ∈ V,	hw : w ∈ V,	hz' : z ∈ U,	hw' : w ∉ U,	uvne : (V ∩ Uᶜ).nonempty,	hV : V ∩ Uᶜ = V	⊢ V ⊆ Uᶜ		α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y,	U : set α,	hU : is_open U,	hsep : xor (x ∈ U) (y ∈ U),	z w : α,	hz : z ∈ V,	hw : w ∈ V,	hz' : z ∈ U,	hw' : w ∉ U,	uvne : (V ∩ Uᶜ).nonempty,	hV : V ∩ Uᶜ = V,	this : V ⊆ Uᶜ	⊢ false		α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y,	U : set α,	hU : is_open U,	hsep : xor (x ∈ U) (y ∈ U),	this : ∀ (z w : α), z ∈ V → w ∈ V → z ∈ U → w ∉ U → false	⊢ false		α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	hnt : ¬∃ (x y : α) (hx : x ∈ V) (hy : y ∈ V), x ≠ y	⊢ ∃ (x : α), x ∈ S ∧ is_closed {x}", "decl_nm": "is_closed.exists_closed_singleton"
{"src": "4 goals	α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y,	U : set α,	hU : is_open U,	hsep : xor (x ∈ U) (y ∈ U),	z w : α,	hz : z ∈ V,	hw : w ∈ V,	hz' : z ∈ U,	hw' : w ∉ U,	uvne : (V ∩ Uᶜ).nonempty,	hV : V ∩ Uᶜ = V	⊢ V ∩ Uᶜ ⊆ Uᶜ		α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y,	U : set α,	hU : is_open U,	hsep : xor (x ∈ U) (y ∈ U),	z w : α,	hz : z ∈ V,	hw : w ∈ V,	hz' : z ∈ U,	hw' : w ∉ U,	uvne : (V ∩ Uᶜ).nonempty,	hV : V ∩ Uᶜ = V,	this : V ⊆ Uᶜ	⊢ false		α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y,	U : set α,	hU : is_open U,	hsep : xor (x ∈ U) (y ∈ U),	this : ∀ (z w : α), z ∈ V → w ∈ V → z ∈ U → w ∉ U → false	⊢ false		α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	hnt : ¬∃ (x y : α) (hx : x ∈ V) (hy : y ∈ V), x ≠ y	⊢ ∃ (x : α), x ∈ S ∧ is_closed {x}", "decl_nm": "is_closed.exists_closed_singleton"
{"src": "3 goals	α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y,	U : set α,	hU : is_open U,	hsep : xor (x ∈ U) (y ∈ U),	z w : α,	hz : z ∈ V,	hw : w ∈ V,	hz' : z ∈ U,	hw' : w ∉ U,	uvne : (V ∩ Uᶜ).nonempty,	hV : V ∩ Uᶜ = V,	this : V ⊆ Uᶜ	⊢ false		α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y,	U : set α,	hU : is_open U,	hsep : xor (x ∈ U) (y ∈ U),	this : ∀ (z w : α), z ∈ V → w ∈ V → z ∈ U → w ∉ U → false	⊢ false		α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	hnt : ¬∃ (x y : α) (hx : x ∈ V) (hy : y ∈ V), x ≠ y	⊢ ∃ (x : α), x ∈ S ∧ is_closed {x}", "decl_nm": "is_closed.exists_closed_singleton"
{"src": "2 goals	α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y,	U : set α,	hU : is_open U,	hsep : xor (x ∈ U) (y ∈ U),	this : ∀ (z w : α), z ∈ V → w ∈ V → z ∈ U → w ∉ U → false	⊢ false		α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	hnt : ¬∃ (x y : α) (hx : x ∈ V) (hy : y ∈ V), x ≠ y	⊢ ∃ (x : α), x ∈ S ∧ is_closed {x}", "decl_nm": "is_closed.exists_closed_singleton"
{"src": "3 goals	case or.inl	α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y,	U : set α,	hU : is_open U,	this : ∀ (z w : α), z ∈ V → w ∈ V → z ∈ U → w ∉ U → false,	hsep : x ∈ U ∧ y ∉ U	⊢ false		case or.inr	α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y,	U : set α,	hU : is_open U,	this : ∀ (z w : α), z ∈ V → w ∈ V → z ∈ U → w ∉ U → false,	hsep : y ∈ U ∧ x ∉ U	⊢ false		α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	hnt : ¬∃ (x y : α) (hx : x ∈ V) (hy : y ∈ V), x ≠ y	⊢ ∃ (x : α), x ∈ S ∧ is_closed {x}", "decl_nm": "is_closed.exists_closed_singleton"
{"src": "2 goals	case or.inr	α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	x y : α,	hx : x ∈ V,	hy : y ∈ V,	hne : x ≠ y,	U : set α,	hU : is_open U,	this : ∀ (z w : α), z ∈ V → w ∈ V → z ∈ U → w ∉ U → false,	hsep : y ∈ U ∧ x ∉ U	⊢ false		α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	hnt : ¬∃ (x y : α) (hx : x ∈ V) (hy : y ∈ V), x ≠ y	⊢ ∃ (x : α), x ∈ S ∧ is_closed {x}", "decl_nm": "is_closed.exists_closed_singleton"
{"src": "α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	hnt : ¬∃ (x y : α) (hx : x ∈ V) (hy : y ∈ V), x ≠ y	⊢ ∃ (x : α), x ∈ S ∧ is_closed {x}", "decl_nm": "is_closed.exists_closed_singleton"
{"src": "α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vne : V.nonempty,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	hnt : ∀ (x y : α), x ∈ V → y ∈ V → x = y	⊢ ∃ (x : α), x ∈ S ∧ is_closed {x}", "decl_nm": "is_closed.exists_closed_singleton"
{"src": "α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	hnt : ∀ (x y : α), x ∈ V → y ∈ V → x = y,	z : α,	hz : z ∈ V	⊢ ∃ (x : α), x ∈ S ∧ is_closed {x}", "decl_nm": "is_closed.exists_closed_singleton"
{"src": "α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	hnt : ∀ (x y : α), x ∈ V → y ∈ V → x = y,	z : α,	hz : z ∈ V	⊢ is_closed {z}", "decl_nm": "is_closed.exists_closed_singleton"
{"src": "α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	hnt : ∀ (x y : α), x ∈ V → y ∈ V → x = y,	z : α,	hz : z ∈ V	⊢ {z} = V", "decl_nm": "is_closed.exists_closed_singleton"
{"src": "α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	hnt : ∀ (x y : α), x ∈ V → y ∈ V → x = y,	z : α,	hz : z ∈ V,	x : α	⊢ x ∈ {z} ↔ x ∈ V", "decl_nm": "is_closed.exists_closed_singleton"
{"src": "α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	hnt : ∀ (x y : α), x ∈ V → y ∈ V → x = y,	z : α,	hz : z ∈ V,	x : α	⊢ x = z ↔ x ∈ V", "decl_nm": "is_closed.exists_closed_singleton"
{"src": "2 goals	α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	hnt : ∀ (x y : α), x ∈ V → y ∈ V → x = y,	z : α,	hz : z ∈ V,	x : α	⊢ x = z → x ∈ V		α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	hnt : ∀ (x y : α), x ∈ V → y ∈ V → x = y,	z : α,	hz : z ∈ V,	x : α	⊢ x ∈ V → x = z", "decl_nm": "is_closed.exists_closed_singleton"
{"src": "2 goals	α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	hnt : ∀ (x y : α), x ∈ V → y ∈ V → x = y,	x : α,	hz : x ∈ V	⊢ x ∈ V		α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	hnt : ∀ (x y : α), x ∈ V → y ∈ V → x = y,	z : α,	hz : z ∈ V,	x : α	⊢ x ∈ V → x = z", "decl_nm": "is_closed.exists_closed_singleton"
{"src": "α : Type u_1,	_inst_2 : topological_space α,	_inst_3 : t0_space α,	_inst_4 : compact_space α,	S : set α,	hS : is_closed S,	hne : S.nonempty,	V : set α,	Vsub : V ⊆ S,	Vcls : is_closed V,	hV : ∀ (V' : set α), V' ⊆ V → V'.nonempty → is_closed V' → V' = V,	hnt : ∀ (x y : α), x ∈ V → y ∈ V → x = y,	z : α,	hz : z ∈ V,	x : α	⊢ x ∈ V → x = z", "decl_nm": "is_closed.exists_closed_singleton"
{"src": "⊢ ∀ {ι : Type u_1} {X : Type u_2} [_inst_1 : topological_space X] [_inst_2 : normal_space X] {u : ι → set X}	  {s : set X},	    is_closed s →	    (∀ (i : ι), is_open (u i)) →	    (∀ (x : X), x ∈ s → {i : ι | x ∈ u i}.finite) →	    (s ⊆ ⋃ (i : ι), u i) →	    (∃ (v : ι → set X), s ⊆ Union v ∧ (∀ (i : ι), is_open (v i)) ∧ ∀ (i : ι), closure (v i) ⊆ u i)", "decl_nm": "exists_subset_Union_closure_subset"
{"src": "ι : Type u_1,	X : Type u_2,	_inst_1 : topological_space X,	_inst_2 : normal_space X,	u : ι → set X,	s : set X,	hs : is_closed s,	uo : ∀ (i : ι), is_open (u i),	uf : ∀ (x : X), x ∈ s → {i : ι | x ∈ u i}.finite,	us : s ⊆ ⋃ (i : ι), u i	⊢ ∃ (v : ι → set X), s ⊆ Union v ∧ (∀ (i : ι), is_open (v i)) ∧ ∀ (i : ι), closure (v i) ⊆ u i", "decl_nm": "exists_subset_Union_closure_subset"
{"src": "ι : Type u_1,	X : Type u_2,	_inst_1 : topological_space X,	_inst_2 : normal_space X,	u : ι → set X,	s : set X,	hs : is_closed s,	uo : ∀ (i : ι), is_open (u i),	uf : ∀ (x : X), x ∈ s → {i : ι | x ∈ u i}.finite,	us : s ⊆ ⋃ (i : ι), u i,	_inst : Π (a : Prop), decidable a	⊢ ∃ (v : ι → set X), s ⊆ Union v ∧ (∀ (i : ι), is_open (v i)) ∧ ∀ (i : ι), closure (v i) ⊆ u i", "decl_nm": "exists_subset_Union_closure_subset"
{"src": "ι : Type u_1,	X : Type u_2,	_inst_1 : topological_space X,	_inst_2 : normal_space X,	u : ι → set X,	s : set X,	hs : is_closed s,	uo : ∀ (i : ι), is_open (u i),	uf : ∀ (x : X), x ∈ s → {i : ι | x ∈ u i}.finite,	us : s ⊆ ⋃ (i : ι), u i,	_inst : Π (a : Prop), decidable a,	_inst_3 : nonempty (partial_refinement u s)	⊢ ∃ (v : ι → set X), s ⊆ Union v ∧ (∀ (i : ι), is_open (v i)) ∧ ∀ (i : ι), closure (v i) ⊆ u i", "decl_nm": "exists_subset_Union_closure_subset"
{"src": "2 goals	ι : Type u_1,	X : Type u_2,	_inst_1 : topological_space X,	_inst_2 : normal_space X,	u : ι → set X,	s : set X,	hs : is_closed s,	uo : ∀ (i : ι), is_open (u i),	uf : ∀ (x : X), x ∈ s → {i : ι | x ∈ u i}.finite,	us : s ⊆ ⋃ (i : ι), u i,	_inst : Π (a : Prop), decidable a,	_inst_3 : nonempty (partial_refinement u s)	⊢ ∀ (c : set (partial_refinement u s)),	    chain has_le.le c →	    c.nonempty → (∃ (ub : partial_refinement u s), ∀ (v : partial_refinement u s), v ∈ c → v ≤ ub)		ι : Type u_1,	X : Type u_2,	_inst_1 : topological_space X,	_inst_2 : normal_space X,	u : ι → set X,	s : set X,	hs : is_closed s,	uo : ∀ (i : ι), is_open (u i),	uf : ∀ (x : X), x ∈ s → {i : ι | x ∈ u i}.finite,	us : s ⊆ ⋃ (i : ι), u i,	_inst : Π (a : Prop), decidable a,	_inst_3 : nonempty (partial_refinement u s),	this :	  ∀ (c : set (partial_refinement u s)),	    chain has_le.le c →	    c.nonempty → (∃ (ub : partial_refinement u s), ∀ (v : partial_refinement u s), v ∈ c → v ≤ ub)	⊢ ∃ (v : ι → set X), s ⊆ Union v ∧ (∀ (i : ι), is_open (v i)) ∧ ∀ (i : ι), closure (v i) ⊆ u i", "decl_nm": "exists_subset_Union_closure_subset"
{"src": "ι : Type u_1,	X : Type u_2,	_inst_1 : topological_space X,	_inst_2 : normal_space X,	u : ι → set X,	s : set X,	hs : is_closed s,	uo : ∀ (i : ι), is_open (u i),	uf : ∀ (x : X), x ∈ s → {i : ι | x ∈ u i}.finite,	us : s ⊆ ⋃ (i : ι), u i,	_inst : Π (a : Prop), decidable a,	_inst_3 : nonempty (partial_refinement u s),	this :	  ∀ (c : set (partial_refinement u s)),	    chain has_le.le c →	    c.nonempty → (∃ (ub : partial_refinement u s), ∀ (v : partial_refinement u s), v ∈ c → v ≤ ub)	⊢ ∃ (v : ι → set X), s ⊆ Union v ∧ (∀ (i : ι), is_open (v i)) ∧ ∀ (i : ι), closure (v i) ⊆ u i", "decl_nm": "exists_subset_Union_closure_subset"
{"src": "ι : Type u_1,	X : Type u_2,	_inst_1 : topological_space X,	_inst_2 : normal_space X,	u : ι → set X,	s : set X,	hs : is_closed s,	uo : ∀ (i : ι), is_open (u i),	uf : ∀ (x : X), x ∈ s → {i : ι | x ∈ u i}.finite,	us : s ⊆ ⋃ (i : ι), u i,	_inst : Π (a : Prop), decidable a,	_inst_3 : nonempty (partial_refinement u s),	this :	  ∀ (c : set (partial_refinement u s)),	    chain has_le.le c →	    c.nonempty → (∃ (ub : partial_refinement u s), ∀ (v : partial_refinement u s), v ∈ c → v ≤ ub),	v : partial_refinement u s,	hv : ∀ (a : partial_refinement u s), v ≤ a → a = v	⊢ ∃ (v : ι → set X), s ⊆ Union v ∧ (∀ (i : ι), is_open (v i)) ∧ ∀ (i : ι), closure (v i) ⊆ u i", "decl_nm": "exists_subset_Union_closure_subset"
{"src": "2 goals	ι : Type u_1,	X : Type u_2,	_inst_1 : topological_space X,	_inst_2 : normal_space X,	u : ι → set X,	s : set X,	hs : is_closed s,	uo : ∀ (i : ι), is_open (u i),	uf : ∀ (x : X), x ∈ s → {i : ι | x ∈ u i}.finite,	us : s ⊆ ⋃ (i : ι), u i,	_inst : Π (a : Prop), decidable a,	_inst_3 : nonempty (partial_refinement u s),	this :	  ∀ (c : set (partial_refinement u s)),	    chain has_le.le c →	    c.nonempty → (∃ (ub : partial_refinement u s), ∀ (v : partial_refinement u s), v ∈ c → v ≤ ub),	v : partial_refinement u s,	hv : ∀ (a : partial_refinement u s), v ≤ a → a = v,	this : ∀ (i : ι), i ∈ v.carrier	⊢ ∃ (v : ι → set X), s ⊆ Union v ∧ (∀ (i : ι), is_open (v i)) ∧ ∀ (i : ι), closure (v i) ⊆ u i		ι : Type u_1,	X : Type u_2,	_inst_1 : topological_space X,	_inst_2 : normal_space X,	u : ι → set X,	s : set X,	hs : is_closed s,	uo : ∀ (i : ι), is_open (u i),	uf : ∀ (x : X), x ∈ s → {i : ι | x ∈ u i}.finite,	us : s ⊆ ⋃ (i : ι), u i,	_inst : Π (a : Prop), decidable a,	_inst_3 : nonempty (partial_refinement u s),	this :	  ∀ (c : set (partial_refinement u s)),	    chain has_le.le c →	    c.nonempty → (∃ (ub : partial_refinement u s), ∀ (v : partial_refinement u s), v ∈ c → v ≤ ub),	v : partial_refinement u s,	hv : ∀ (a : partial_refinement u s), v ≤ a → a = v	⊢ ∀ (i : ι), i ∈ v.carrier", "decl_nm": "exists_subset_Union_closure_subset"
{"src": "ι : Type u_1,	X : Type u_2,	_inst_1 : topological_space X,	_inst_2 : normal_space X,	u : ι → set X,	s : set X,	hs : is_closed s,	uo : ∀ (i : ι), is_open (u i),	uf : ∀ (x : X), x ∈ s → {i : ι | x ∈ u i}.finite,	us : s ⊆ ⋃ (i : ι), u i,	_inst : Π (a : Prop), decidable a,	_inst_3 : nonempty (partial_refinement u s),	this :	  ∀ (c : set (partial_refinement u s)),	    chain has_le.le c →	    c.nonempty → (∃ (ub : partial_refinement u s), ∀ (v : partial_refinement u s), v ∈ c → v ≤ ub),	v : partial_refinement u s,	hv : ∀ (a : partial_refinement u s), v ≤ a → a = v	⊢ ∀ (i : ι), i ∈ v.carrier", "decl_nm": "exists_subset_Union_closure_subset"
{"src": "ι : Type u_1,	X : Type u_2,	_inst_1 : topological_space X,	_inst_2 : normal_space X,	u : ι → set X,	s : set X,	hs : is_closed s,	uo : ∀ (i : ι), is_open (u i),	uf : ∀ (x : X), x ∈ s → {i : ι | x ∈ u i}.finite,	us : s ⊆ ⋃ (i : ι), u i,	_inst : Π (a : Prop), decidable a,	_inst_3 : nonempty (partial_refinement u s),	this :	  ∀ (c : set (partial_refinement u s)),	    chain has_le.le c →	    c.nonempty → (∃ (ub : partial_refinement u s), ∀ (v : partial_refinement u s), v ∈ c → v ≤ ub),	v : partial_refinement u s,	hv : ∃ (i : ι), i ∉ v.carrier	⊢ ∃ (a : partial_refinement u s), v ≤ a ∧ a ≠ v", "decl_nm": "exists_subset_Union_closure_subset"
{"src": "ι : Type u_1,	X : Type u_2,	_inst_1 : topological_space X,	_inst_2 : normal_space X,	u : ι → set X,	s : set X,	hs : is_closed s,	uo : ∀ (i : ι), is_open (u i),	uf : ∀ (x : X), x ∈ s → {i : ι | x ∈ u i}.finite,	us : s ⊆ ⋃ (i : ι), u i,	_inst : Π (a : Prop), decidable a,	_inst_3 : nonempty (partial_refinement u s),	this :	  ∀ (c : set (partial_refinement u s)),	    chain has_le.le c →	    c.nonempty → (∃ (ub : partial_refinement u s), ∀ (v : partial_refinement u s), v ∈ c → v ≤ ub),	v : partial_refinement u s,	i : ι,	hi : i ∉ v.carrier	⊢ ∃ (a : partial_refinement u s), v ≤ a ∧ a ≠ v", "decl_nm": "exists_subset_Union_closure_subset"
{"src": "ι : Type u_1,	X : Type u_2,	_inst_1 : topological_space X,	_inst_2 : normal_space X,	u : ι → set X,	s : set X,	hs : is_closed s,	uo : ∀ (i : ι), is_open (u i),	uf : ∀ (x : X), x ∈ s → {i : ι | x ∈ u i}.finite,	us : s ⊆ ⋃ (i : ι), u i,	_inst : Π (a : Prop), decidable a,	_inst_3 : nonempty (partial_refinement u s),	this :	  ∀ (c : set (partial_refinement u s)),	    chain has_le.le c →	    c.nonempty → (∃ (ub : partial_refinement u s), ∀ (v : partial_refinement u s), v ∈ c → v ≤ ub),	v : partial_refinement u s,	i : ι,	hi : i ∉ v.carrier,	v' : partial_refinement u s,	hlt : v < v'	⊢ ∃ (a : partial_refinement u s), v ≤ a ∧ a ≠ v", "decl_nm": "exists_subset_Union_closure_subset"
{"src": "⊢ ∀ {α : Type u} (b : ultrafilter α), comap pure (nhds b) ≤ ↑b", "decl_nm": "ultrafilter_comap_pure_nhds"
{"src": "α : Type u,	b : ultrafilter α	⊢ comap pure (nhds b) ≤ ↑b", "decl_nm": "ultrafilter_comap_pure_nhds"
{"src": "α : Type u,	b : ultrafilter α	⊢ comap pure	      (⨅ (s : set (ultrafilter α)) (H : s ∈ {s : set (ultrafilter α) | b ∈ s ∧ s ∈ ultrafilter_basis α}),	         principal s) ≤	    ↑b", "decl_nm": "ultrafilter_comap_pure_nhds"
{"src": "α : Type u,	b : ultrafilter α	⊢ (⨅ (i : set (ultrafilter α)) (x : i ∈ {s : set (ultrafilter α) | b ∈ s ∧ s ∈ ultrafilter_basis α}),	       principal (pure ⁻¹' i)) ≤	    ↑b", "decl_nm": "ultrafilter_comap_pure_nhds"
{"src": "α : Type u,	b : ultrafilter α,	s : set α,	hs : s ∈ ↑b	⊢ s ∈	    ⨅ (i : set (ultrafilter α)) (x : i ∈ {s : set (ultrafilter α) | b ∈ s ∧ s ∈ ultrafilter_basis α}),	      principal (pure ⁻¹' i)", "decl_nm": "ultrafilter_comap_pure_nhds"
{"src": "α : Type u,	b : ultrafilter α,	s : set α,	hs : s ∈ ↑b	⊢ (⨅ (i : set (ultrafilter α)) (x : i ∈ {s : set (ultrafilter α) | b ∈ s ∧ s ∈ ultrafilter_basis α}),	       principal (pure ⁻¹' i)) ≤	    principal s", "decl_nm": "ultrafilter_comap_pure_nhds"
{"src": "α : Type u,	b : ultrafilter α,	s : set α,	hs : s ∈ ↑b	⊢ (⨅ (x : {u : ultrafilter α | s ∈ u} ∈ {s : set (ultrafilter α) | b ∈ s ∧ s ∈ ultrafilter_basis α}),	       principal (pure ⁻¹' {u : ultrafilter α | s ∈ u})) ≤	    principal s", "decl_nm": "ultrafilter_comap_pure_nhds"
{"src": "α : Type u,	b : ultrafilter α,	s : set α,	hs : s ∈ ↑b	⊢ principal (pure ⁻¹' {u : ultrafilter α | s ∈ u}) ≤ principal s", "decl_nm": "ultrafilter_comap_pure_nhds"
{"src": "⊢ ∀ {α : Type u}, induced pure ultrafilter.topological_space = ⊥", "decl_nm": "induced_topology_pure"
{"src": "α : Type u	⊢ induced pure ultrafilter.topological_space = ⊥", "decl_nm": "induced_topology_pure"
{"src": "α : Type u	⊢ ∀ (x : α), (induced pure ultrafilter.topological_space).is_open {x}", "decl_nm": "induced_topology_pure"
{"src": "α : Type u,	x : α	⊢ (induced pure ultrafilter.topological_space).is_open {x}", "decl_nm": "induced_topology_pure"
{"src": "α : Type u,	x : α	⊢ pure ⁻¹' {u : ultrafilter α | {x} ∈ u} = {x}", "decl_nm": "induced_topology_pure"
{"src": "⊢ ∀ {α : Type u} [_inst_1 : topological_space α] {s t : set α},	    is_compact s → is_compact t → is_compact (s ∪ t)", "decl_nm": "is_compact.union"
{"src": "α : Type u,	_inst_1 : topological_space α,	s t : set α,	hs : is_compact s,	ht : is_compact t	⊢ is_compact (s ∪ t)", "decl_nm": "is_compact.union"
{"src": "α : Type u,	_inst_1 : topological_space α,	s t : set α,	hs : is_compact s,	ht : is_compact t	⊢ is_compact (⋃ (b : bool), cond b s t)", "decl_nm": "is_compact.union"
{"src": "⊢ ∀ {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space α] [_inst_2 : topological_space β] {f : β → α}	  {b : β} {s : set β},	    continuous_within_at f s b ↔ tendsto (λ (x : β), (f b, f x)) (nhds_within b s) (uniformity α)", "decl_nm": "uniform.continuous_within_at_iff'_right"
{"src": "α : Type u_1,	β : Type u_2,	_inst_1 : uniform_space α,	_inst_2 : topological_space β,	f : β → α,	b : β,	s : set β	⊢ continuous_within_at f s b ↔ tendsto (λ (x : β), (f b, f x)) (nhds_within b s) (uniformity α)", "decl_nm": "uniform.continuous_within_at_iff'_right"
{"src": "⊢ ∀ {α : Type u_1} {U V : set (α × α)}, symmetric_rel U → symmetric_rel V → symmetric_rel (U ∩ V)", "decl_nm": "symmetric_rel_inter"
{"src": "α : Type u_1,	U V : set (α × α),	hU : symmetric_rel U,	hV : symmetric_rel V	⊢ symmetric_rel (U ∩ V)", "decl_nm": "symmetric_rel_inter"
{"src": "α : Type u_1,	U V : set (α × α),	hU : prod.swap ⁻¹' U = U,	hV : prod.swap ⁻¹' V = V	⊢ prod.swap ⁻¹' (U ∩ V) = U ∩ V", "decl_nm": "symmetric_rel_inter"
{"src": "⊢ ∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {ι : Type u_4} [_inst_1 : uniform_space β]	  {F : ι → α → β} {f : α → β} {s : set α} {p : filter ι},	    tendsto_uniformly_on F f p s →	    ∀ (g : γ → α), tendsto_uniformly_on (λ (n : ι), F n ∘ g) (f ∘ g) p (g ⁻¹' s)", "decl_nm": "tendsto_uniformly_on.comp"
{"src": "α : Type u_1,	β : Type u_2,	γ : Type u_3,	ι : Type u_4,	_inst_1 : uniform_space β,	F : ι → α → β,	f : α → β,	s : set α,	p : filter ι,	h : tendsto_uniformly_on F f p s,	g : γ → α	⊢ tendsto_uniformly_on (λ (n : ι), F n ∘ g) (f ∘ g) p (g ⁻¹' s)", "decl_nm": "tendsto_uniformly_on.comp"
{"src": "α : Type u_1,	β : Type u_2,	γ : Type u_3,	ι : Type u_4,	_inst_1 : uniform_space β,	F : ι → α → β,	f : α → β,	s : set α,	p : filter ι,	h : tendsto_uniformly_on F f p s,	g : γ → α,	u : set (β × β),	hu : u ∈ uniformity β	⊢ ∀ᶠ (n : ι) in p, ∀ (x : γ), x ∈ g ⁻¹' s → ((f ∘ g) x, (λ (n : ι), F n ∘ g) n x) ∈ u", "decl_nm": "tendsto_uniformly_on.comp"
{"src": "α : Type u_1,	β : Type u_2,	γ : Type u_3,	ι : Type u_4,	_inst_1 : uniform_space β,	F : ι → α → β,	f : α → β,	s : set α,	p : filter ι,	h : tendsto_uniformly_on F f p s,	g : γ → α,	u : set (β × β),	hu : u ∈ uniformity β,	n : ι,	hn : ∀ (x : α), x ∈ s → (f x, F n x) ∈ u	⊢ ∀ (x : γ), x ∈ g ⁻¹' s → ((f ∘ g) x, (λ (n : ι), F n ∘ g) n x) ∈ u", "decl_nm": "tendsto_uniformly_on.comp"
{"src": "⊢ ∀ {X : Type u_1} [_inst_1 : topological_space X] [_inst_2 : normal_space X] {s t : set X},	    is_closed s →	    is_closed t →	    disjoint s t → (∃ (f : C(X, ℝ)), eq_on ⇑f 0 s ∧ eq_on ⇑f 1 t ∧ ∀ (x : X), ⇑f x ∈ Icc 0 1)", "decl_nm": "exists_continuous_zero_one_of_closed"
{"src": "X : Type u_1,	_inst_1 : topological_space X,	_inst_2 : normal_space X,	s t : set X,	hs : is_closed s,	ht : is_closed t,	hd : disjoint s t	⊢ ∃ (f : C(X, ℝ)), eq_on ⇑f 0 s ∧ eq_on ⇑f 1 t ∧ ∀ (x : X), ⇑f x ∈ Icc 0 1", "decl_nm": "exists_continuous_zero_one_of_closed"
{"src": "X : Type u_1,	_inst_1 : topological_space X,	_inst_2 : normal_space X,	s t : set X,	hs : is_closed s,	ht : is_closed t,	hd : disjoint s t,	c : urysohns.CU X := {C := s, U := tᶜ, closed_C := hs, open_U := _, subset := _}	⊢ ∃ (f : C(X, ℝ)), eq_on ⇑f 0 s ∧ eq_on ⇑f 1 t ∧ ∀ (x : X), ⇑f x ∈ Icc 0 1", "decl_nm": "exists_continuous_zero_one_of_closed"
