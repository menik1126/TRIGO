intros
rw [← stream.eta (iterate f a)]
rw tail_iterate
refl
intros
cases v
reflexivity
intros
cases b
simp
simp
intros
cases b
simp
simp
intros
cases b
simp
simp
intros
have h := int.neg_lt_neg h
rwa int.neg_neg at h
intros
have h := int.add_le_add_right h (-b)
rwa [int.add_comm b c, int.add_neg_cancel_right] at h
intros
rw int.add_comm at h
exact int.le_add_of_sub_right_le h
intros
have h := int.add_lt_add_right h b
rwa [int.sub_add_cancel, int.add_comm] at h
intros
simp [min_le_left]
intros
induction n
simp [*]
simp [*]
intros
unfold bitwise
apply bit_cases_on m
intros
rw [binary_rec_eq, binary_rec_zero]
exact bitwise_bit_aux h
intros
simp [gcd]
intros
rw mod_def
have h : ¬ (0 < 0 ∧ 0 ≤ a)
simp [lt_irrefl]
simp [if_neg, h]
intros
rw mod_def
have h : ¬(0 < b ∧ b ≤ 0)
intro hn
cases hn with l r
exact absurd (lt_of_lt_of_le l r) (lt_irrefl 0)
simp [if_neg, h]
intros
ext
refl
intros
ext
refl
intros
ext
simp
intros
ext
simp only [lmul_left_apply, linear_map.comp_apply, mul_assoc]
intros
conv_lhs {rw ← span_eq M}
change span _ _ * span _ _ = _
rw [span_mul_span]
apply le_antisymm
rw span_le
rintros _ ⟨b, m, hb, hm, rfl⟩
rw [set_like.mem_coe, mem_map, set.mem_singleton_iff.mp hb]
exact ⟨m, hm, rfl⟩
rintros _ ⟨m, hm, rfl⟩
exact subset_span ⟨a, m, set.mem_singleton a, hm, rfl⟩
intros
ext x
simp only [mem_map, mem_div_iff_forall_mul_mem]
split
rintro ⟨x, hx, rfl⟩ _ ⟨y, hy, rfl⟩
exact ⟨x * y, hx _ hy, h.map_mul x y⟩
rintro hx
refine ⟨h.symm x, λ z hz, _, h.apply_symm_apply x⟩
obtain ⟨xz, xz_mem, hxz⟩ := hx (h z) ⟨z, hz, rfl⟩
convert xz_mem
apply h.injective
erw [h.map_mul, h.apply_symm_apply, hxz]
intros
apply le_antisymm
rw submodule.mul_le
intros y hy z hz
exact mul_mem S hy hz
intros x hx1
rw ← mul_one x
exact submodule.mul_mem_mul hx1 (one_mem S)
intros
simp [set.ext_iff, algebra.mem_bot]
intros
haveI := classical.dec
refine or_iff_not_imp_right.2 (λ H, _)
simp [h, irreducible_iff] at H ⊢
refine λ a b h, classical.by_contradiction $ λ o, _
simp [not_or_distrib] at o
exact H _ o.1 _ o.2 h.symm
intros
rw [g.map_finprod]
simp only [g.map_finprod_Prop]
simpa only [finprod_eq_mul_indicator_apply, mul_support_mul_indicator]
intros
ext1
apply w
intros
ext
refl
intros
simp
intros
rw mul_comm
exact h.mul_right _
intros
split
rintro rfl
exact hnd (dvd_zero _)
rcases hd with ⟨c, rfl⟩
refine ⟨c, _, rfl⟩
rintro ⟨u, rfl⟩
simpa using hnd
intros
unfold xgcd_aux
exact if_pos rfl
intros
rw neg_inv
intros
classical
apply s.induction_on
simp
intros b t hbt h
rw [gcd_insert, gcd_insert, h, ← gcd_mul_right]
apply ((normalize_associated a).mul_left _).gcd_eq_right
intros
rw [h.eq, mul_inv_cancel_right]
intros
cases m₁ with mul₁ _ one₁ one_mul₁ mul_one₁ npow₁ npow_zero₁ npow_succ₁
cases m₂ with mul₂ _ one₂ one_mul₂ mul_one₂ npow₂ npow_zero₂ npow_succ₂
change mul₁ = mul₂ at h_mul
subst h_mul
have h_one : one₁ = one₂
rw ←one_mul₂ one₁
exact mul_one₁ one₂
subst h_one
have h_npow : npow₁ = npow₂
ext n
induction n with d hd
rw [npow_zero₁, npow_zero₂]
rw [npow_succ₁, npow_succ₂, hd]
subst h_npow
intros
ext
simp only [function.comp_app, inv_apply, coe_comp]
intros
ext a
exact add_monoid_hom.congr_fun h a
intros
rwa [← add_eq_zero_iff_eq_neg, ← sub_eq_zero, or_comm, ← mul_eq_zero, ← sq_sub_sq a b, sub_eq_zero]
intros
ring
intros
rw [nsmul_eq_mul', nsmul_eq_mul', mul_assoc]
intros
simp [h]
intros
simp
intros
rw [← divp_mk0 _ hc, ← divp_mk0 _ hc, divp_left_inj]
intros
split
intro h
rw [pos_iff_ne_zero]
rintro rfl
simpa using h
intro h
exact zero_pow' n h.ne.symm
intros
rw [←cancel_epi (image_to_kernel (0 : A ⟶ B) g exact.w), ←cancel_epi (factor_thru_image_subobject (0 : A ⟶ B))]
simp
intros
change ite (2 = 1 + 1) (d₁ ≫ 𝟙 X₂) 0 = d₁
rw [if_pos rfl, category.comp_id]
intros
dunfold cycles_map
simp [subobject.factor_thru_right]
intros
simp [homology.π, homology.desc]
intros
simp only [indicator]
split_ifs
refl
rw [mul_zero]
intros
by_cases hx : x ∈ ⋃ i, s i
rw [mul_indicator_of_mem hx]
rw [mem_Union] at hx
refine le_antisymm _ (supr_le $ λ i, mul_indicator_le_self' (λ x hx, h1 ▸ bot_le) x)
rcases hx with ⟨i, hi⟩
exact le_supr_of_le i (ge_of_eq $ mul_indicator_of_mem hi _)
rw [mul_indicator_of_not_mem hx]
simp only [mem_Union, not_exists] at hx
simp [hx, ← h1]
intros
simp [mul_assoc]
intros
conv_rhs { congr, skip, rw ← I.incl_ideal_range, }
rw comap_bracket_eq
simp only [ker_incl, sup_bot_eq]
exact I.incl_is_ideal_morphism
intros
split
introsI h
exact e.symm.injective.lie_algebra_is_nilpotent
introsI h
exact e.injective.lie_algebra_is_nilpotent
intros
ext a b
simp [lie_ring.of_associative_ring_bracket]
intros
rw [nsmul_eq_mul, mul_one]
intros
ext m
exact linear_map.congr_fun h m
intros
simp only [lift_apply', algebra.smul_def]
intros
ext
refl
intros
unfold cmp cmp_using
by_cases a < b
by_cases h₂ : b < a
simp [h, h₂, gt, ordering.swap]
exact lt_asymm h h₂
simp [h, h₂, gt, ordering.swap]
by_cases h₂ : b < a
simp [h, h₂, gt, ordering.swap]
simp [h, h₂, gt, ordering.swap]
intros
rw cmp_eq_eq_iff
intros
rw [mul_comm, inv_mul_lt_iff' h]
intros
rw [div_lt_iff_of_neg hb, one_mul]
intros
simpa using inv_le ha hb
intros
rw [mul_comm c, mul_inv_lt_inv_mul_iff, mul_comm]
intros
rw [← mul_lt_mul_iff_right b, one_mul, div_eq_mul_inv, inv_mul_cancel_right]
intros
haveI := @linear_order.decidable_le α _
exact ⟨lt_imp_lt_of_le_imp_le $ λ h', decidable.mul_le_mul_of_nonneg_left h' h.le, λ h', mul_lt_mul_of_pos_left h' h⟩
intros
rw [←right_inv x y, ←self_distrib]
intros
rw [add_comm, self_add_conj]
intros
rw [←i_mul_j, mul_assoc, j_mul_j, mul_smul_comm, mul_one]
intros
rw [nontrivial_iff, not_iff_comm, is_left_regular_zero_iff_subsingleton, subsingleton_iff]
push_neg
exact iff.rfl
intros
rw [← ring_hom.comp_apply, comp_eq₂]
simp
intros
simp [vanishing_ideal]
intros
split
contrapose!
intro h
apply set.ne_empty_iff_nonempty.mpr
rcases ideal.exists_le_maximal I h with ⟨M, hM, hIM⟩
exact ⟨⟨M, hM.is_prime⟩, hIM⟩
rintro rfl
apply zero_locus_empty_of_one_mem
trivial
intros
simp only [zero_locus_Union]
intros
dsimp [δ, σ]
simp only [←X.map_comp, simplex_category.δ_comp_σ_of_gt H]
intros
obtain ⟨a, ha : a ∈ Ioo (0 : ℝ) 1, C, hC : 0 < C, hp⟩ := p.norm_mul_pow_le_mul_pow_of_lt_radius h
exact summable_of_nonneg_of_le (λ n, mul_nonneg (norm_nonneg _) (pow_nonneg r.coe_nonneg _)) hp ((summable_geometric_of_lt_1 ha.1.le ha.2).mul_left _)
intros
rw is_open_iff_mem_nhds
rintro x ⟨p, r, hr⟩
exact mem_of_superset (emetric.ball_mem_nhds _ hr.r_pos) (λ y hy, hr.analytic_at_of_mem hy)
intros
rw is_O
exact ⟨c, h⟩
intros
unfold is_O
exact exists_congr (λ C, e.is_O_with_congr hb)
intros
unfold is_O
exact exists_congr (λ C, e.is_O_with_congr)
intros
simp only [is_O_with, norm_neg]
intros
simpa only [sub_eq_add_neg] using h₁.add h₂.neg_left
intros
rw is_O_with
intros
have := (has_fderiv_within_at.mul' hc hd).has_deriv_within_at
rwa [continuous_linear_map.add_apply, continuous_linear_map.smul_apply, continuous_linear_map.smul_right_apply, continuous_linear_map.smul_right_apply, continuous_linear_map.smul_right_apply, continuous_linear_map.one_apply, one_smul, one_smul, add_comm] at this
intros
simp only [div_eq_mul_inv, deriv_mul_const_field]
intros
rw differentiable_at.deriv_within p.differentiable_at hxs
exact p.deriv
intros
rw [← Ici_diff_left, has_deriv_within_at_diff_singleton]
intros
simp only [has_deriv_within_at, nhds_within_union]
exact hs.join ht
intros
simp [deriv]
intros
simpa using (hc.smul hf).has_strict_deriv_at
intros
simpa using h.neg.has_deriv_at_filter
intros
simpa only [sub_eq_add_neg] using hf.add hg.neg
intros
refine ⟨λ H, _, λ H, iso.has_strict_fderiv_at.comp x H⟩
convert iso.symm.has_strict_fderiv_at.comp x H
ext z
apply (iso.symm_apply_apply _).symm
ext z
apply (iso.symm_apply_apply _).symm
intros
refine le_of_forall_pos_le_add (λ ε ε0, op_norm_le_of_nhds_zero _ _)
exact add_nonneg C.coe_nonneg ε0.le
have hs' := hs
rw [← map_add_left_nhds_zero x₀, mem_map] at hs'
filter_upwards [is_o_iff.1 (has_fderiv_at_iff_is_o_nhds_zero.1 hf) ε0, hs']
intros y hy hys
have := hlip.norm_sub_le hys (mem_of_mem_nhds hs)
rw add_sub_cancel' at this
calc ∥f' y∥ ≤ ∥f (x₀ + y) - f x₀∥ + ∥f (x₀ + y) - f x₀ - f' y∥ : norm_le_insert _ _ ... ≤ C * ∥y∥ + ε * ∥y∥ : add_le_add this hy ... = (C + ε) * ∥y∥ : (add_mul _ _ _).symm
intros
simp [has_fderiv_within_at, nhds_within_restrict' s h]
intros
ext x
refl
intros
ext y
apply (h.on univ).has_fderiv_within_at_eq_zero hf.has_fderiv_within_at
rw pos_tangent_cone_at_univ
apply mem_univ
rw pos_tangent_cone_at_univ
apply mem_univ
intros
ext x
suffices : f x ≠ 0 ↔ dist x c < f.R
simpa [mem_support]
cases lt_or_le (dist x c) f.R with hx hx
simp [hx, (f.pos_of_mem_ball hx).ne']
simp [hx.not_lt, f.zero_of_le_dist hx]
intros
rw [f.support_eq, euclidean.closure_ball _ f.R_pos]
intros
rintros _ ⟨v, ⟨c, d, hd, hc, hy⟩, rfl⟩
have : ∀n, ∃d', y + d' ∈ t ∧ ∥c n • d'∥ < ((1:ℝ)/2)^n
assume n
rcases mem_closure_iff_nhds.1 ht _ (eventually_nhds_norm_smul_sub_lt (c n) y (pow_pos one_half_pos n)) with ⟨z, hz, hzt⟩
exact ⟨z - y, by simpa using hzt, by simpa using hz⟩
choose d' hd' using this
refine ⟨c, λn, (d n, d' n), _, hc, _⟩
filter_upwards [hd]
assume n hn
simp [hn, (hd' n).1]
apply tendsto.prod_mk_nhds hy _
refine squeeze_zero_norm (λn, (hd' n).2.le) _
exact tendsto_pow_at_top_nhds_0_of_lt_1 one_half_pos.le one_half_lt_one
intros
rintros _ ⟨w, ⟨c, d, hd, hc, hy⟩, rfl⟩
have : ∀n, ∃d', x + d' ∈ s ∧ ∥c n • d'∥ < ((1:ℝ)/2)^n
assume n
rcases mem_closure_iff_nhds.1 hs _ (eventually_nhds_norm_smul_sub_lt (c n) x (pow_pos one_half_pos n)) with ⟨z, hz, hzs⟩
exact ⟨z - x, by simpa using hzs, by simpa using hz⟩
choose d' hd' using this
refine ⟨c, λn, (d' n, d n), _, hc, _⟩
filter_upwards [hd]
assume n hn
simp [hn, (hd' n).1]
apply tendsto.prod_mk_nhds _ hy
refine squeeze_zero_norm (λn, (hd' n).2.le) _
exact tendsto_pow_at_top_nhds_0_of_lt_1 one_half_pos.le one_half_lt_one
intros
classical
rw [← set.univ_pi_piecewise]
refine unique_diff_within_at.univ_pi _ _ _ _ (λ i, _)
by_cases hi : i ∈ I
simp [*, unique_diff_within_at_univ]
simp [*, unique_diff_within_at_univ]
intros
simp [has_ftaylor_series_up_to_on_succ_iff_right, has_ftaylor_series_up_to_on_univ_iff.symm, -add_comm, -with_zero.coe_add]
intros
simpa [nhds_within_univ] using h.eventually
intros
split
assume H
use ftaylor_series_within 𝕜 f univ
rw ← has_ftaylor_series_up_to_on_univ_iff
exact H.ftaylor_series_within unique_diff_on_univ
rintros ⟨p, hp⟩ x hx m hm
exact ⟨univ, filter.univ_sets _, p, (hp.has_ftaylor_series_up_to_on univ).of_le hm⟩
intros
ext m
rw iterated_fderiv_succ_apply_right
refl
intros
simp [times_cont_diff_on_univ.symm, differentiable_on_univ.symm, fderiv_within_univ.symm, - fderiv_within_univ, times_cont_diff_on_succ_iff_fderiv_within unique_diff_on_univ, -with_zero.coe_add, -add_comm]
intros
rw [subsingleton.elim f (λ _, 0)]
exact times_cont_diff_at_const
intros
rw [subsingleton.elim f (λ _, 0)]
exact times_cont_diff_on_const
intros
simpa only [div_eq_mul_inv] using hf.mul times_cont_diff_within_at_const
intros
rw times_cont_diff_at at *
convert hf.prod_map hg
simp only [univ_prod_univ]
intros
rw coe_inv_circle_eq_conj
apply eq_inv_of_mul_right_eq_one
rw [mul_comm, ← complex.norm_sq_eq_conj_mul_self]
simp
intros
have h₁ := f.norm_map z
simp only [complex.abs, norm_eq_abs] at h₁
rwa [real.sqrt_inj (norm_sq_nonneg _) (norm_sq_nonneg _), norm_sq_apply (f z), norm_sq_apply z, h₂, add_left_cancel_iff, mul_self_eq_mul_self_iff] at h₁
intros
intros x y hx hy a b ha hb hab
have h := hs hx hy ha hb hab
rwa [smul_add, smul_add, add_add_add_comm, ←add_smul, hab, one_smul] at h
intros
simpa only [add_comm] using hs.translate_preimage_right z
intros
obtain ⟨a, b, ha, hb, hab, rfl⟩ := hz
exact hf.le_left_of_right_le' hx hy ha hb.le hab hyz
intros x y hxy
refine ⟨_, ⟨fourier 1, _, rfl⟩, _⟩
exact subset_adjoin ⟨1, rfl⟩
simp [hxy]
intros
rw [← zero_smul 𝕜 (0:E), inner_smul_left, ring_hom.map_zero, zero_mul]
intros
rw ← smul_orthogonal_projection_singleton 𝕜 w
simp [hv]
intros
convert inner_le_Lp_mul_Lq s f g hpq using 3
apply sum_congr rfl
intros i hi
simp only [abs_of_nonneg, hf i hi, hg i hi]
apply sum_congr rfl
intros i hi
simp only [abs_of_nonneg, hf i hi, hg i hi]
intros
apply (is_colimit_cokernel_cocone f).uniq (cofork.of_π g (by simp [w]))
rintro (_|_)
convert w.symm
simp
exact he
intros
simp [homothety_def, norm_smul, ← dist_eq_norm_vsub, dist_comm]
intros
rw [summable_iff_cauchy_seq_finset, cauchy_seq_finset_iff_vanishing_norm]
intros
simp only [← nnreal.coe_le_coe, ← nnreal.has_sum_coe, coe_nnnorm] at *
exact tsum_of_norm_bounded hg h
intros
simp [dist_eq_norm]
refine funext (λ x, _)
rw [real.exp, complex.exp_eq_exp_ℂ_ℂ, ← exp_ℝ_ℂ_eq_exp_ℂ_ℂ, exp_eq_tsum, exp_eq_tsum_field, ← re_to_complex, ← re_clm_apply, re_clm.map_tsum (exp_series_summable' (x : ℂ))]
refine tsum_congr (λ n, _)
rw [re_clm.map_smul, ← complex.of_real_pow, re_clm_apply, re_to_complex, complex.of_real_re, smul_eq_mul, one_div, mul_comm, div_eq_mul_inv]
intros
set e := continuous_linear_equiv.of_finrank_eq (@finrank_fin_fun 𝕜 _ (finrank 𝕜 E)).symm
exact e.symm.antilipschitz.proper_space e.symm.continuous e.symm.surjective
intros
have : x = 0 := subsingleton.elim _ _
subst this
refine le_antisymm (by simpa using f.le_op_norm 0) _
have : ∥continuous_multilinear_map.curry0 𝕜 G (f.uncurry0)∥ ≤ ∥f.uncurry0∥ := continuous_multilinear_map.op_norm_le_bound _ (norm_nonneg _) (λm, by simp [-continuous_multilinear_map.apply_zero_curry0])
simpa
intros
rw [comp_assoc, hf, ← comp_assoc, hf', comp_assoc]
intros
refine le_antisymm _ _
apply op_norm_le_bound _ (mul_nonneg (norm_nonneg _) (norm_nonneg _)) (λx, _)
calc ∥(c x) • f∥ = ∥c x∥ * ∥f∥ : norm_smul _ _ ... ≤ (∥c∥ * ∥x∥) * ∥f∥ : mul_le_mul_of_nonneg_right (le_op_norm _ _) (norm_nonneg _) ... = ∥c∥ * ∥f∥ * ∥x∥ : by ring
by_cases h : f = 0
simp [h]
have : 0 < ∥f∥ := norm_pos_iff.2 h
rw ← le_div_iff this
apply op_norm_le_bound _ (div_nonneg (norm_nonneg _) (norm_nonneg f)) (λx, _)
rw [div_mul_eq_mul_div, le_div_iff this]
calc ∥c x∥ * ∥f∥ = ∥c x • f∥ : (norm_smul _ _).symm ... = ∥smul_right c f x∥ : rfl ... ≤ ∥smul_right c f∥ * ∥x∥ : le_op_norm _ _
intros
haveI := normed_algebra.nontrivial 𝕜 𝕜'
exact (lmulₗᵢ 𝕜 𝕜').norm_to_continuous_linear_map
intros
rw mul_comm
exact norm_smul _ _
intros
obtain ⟨x, hx⟩ : ∃ (x : E), x ≠ 0 := exists_ne 0
rw ← norm_pos_iff at hx
have ha : 0 ≤ a
simpa only [hf, hx, zero_le_mul_right] using norm_nonneg (f x)
apply le_antisymm (f.op_norm_le_bound ha (λ y, le_of_eq (hf y)))
simpa only [hf, hx, mul_le_mul_right] using f.le_op_norm x
simp [arg, zero_le_one]
intros
by_cases h : 0 ≤ P.leading_coeff/Q.leading_coeff
exact tendsto_abs_at_top_at_top.comp (P.div_tendsto_at_top_of_degree_gt Q hdeg hQ h)
push_neg at h
exact tendsto_abs_at_bot_at_top.comp (P.div_tendsto_at_bot_of_degree_gt Q hdeg hQ h.le)
intros
rw [←real.log_lt_log_iff hx (real.rpow_pos_of_pos hy z), real.log_rpow hy]
intros
simpa only [(∘), div_eq_inv_mul, mul_one] using (has_deriv_at_sqrt hx).comp_has_deriv_within_at x hf
intros
simpa only [pow_zero, div_eq_mul_inv, ennreal.inv_one, mul_one] using edist_le_of_edist_le_geometric_two_of_tendsto C hu ha 0
intros
simp [dist_eq_norm, sum_range_succ]
intros
refine summable_of_nonneg_of_le (λ a, one_div_nonneg.mpr (pow_nonneg (zero_le_one.trans hm.le) _)) (λ a, _) (summable_geometric_of_lt_1 (one_div_nonneg.mpr (zero_le_one.trans hm.le)) ((one_div_lt (zero_lt_one.trans hm) zero_lt_one).mpr (one_div_one.le.trans_lt hm)))
rw [div_pow, one_pow]
refine (one_div_le_one_div _ _).mpr (pow_le_pow hm.le (fi a))
exact pow_pos (zero_lt_one.trans hm) _
exact pow_pos (zero_lt_one.trans hm) _
intros
rw [add_def, comp_sub, neg_def, comp_sub, comp_zero, add_def, neg_def]
intros
cases h
cases h
refl
intros
rw [uncurry_eq, prod_map_pre_app_comp_ev]
intros
rw [pre, pre, pre, transfer_nat_trans_self_comp, prod.functor.map_comp]
intros
rw ← frobenius_morphism_mate F h
apply_instance
intros
cases F with F_obj _ _ _
cases G with G_obj _ _ _
have : F_obj = G_obj
ext X
apply h_obj
subst this
congr
funext X Y f
exact eq_of_heq (h_map X Y f)
intros
cases p
simp
intros
simp only [cancel_mono]
intros
classical
let O := (finset.univ.image F.obj)
let H : finset (Σ' (X Y : C) (mX : X ∈ O) (mY : Y ∈ O), X ⟶ Y) := finset.univ.bUnion (λ X : J, finset.univ.bUnion (λ Y : J, finset.univ.image (λ f : X ⟶ Y, ⟨F.obj X, F.obj Y, by simp, by simp, F.map f⟩)))
obtain ⟨Z, f, w⟩ := sup_exists O H
refine ⟨⟨Z, ⟨λ X, f (by simp), _⟩⟩⟩
intros j j' g
dsimp
simp only [category.comp_id]
apply w
simp only [finset.mem_univ, finset.mem_bUnion, exists_and_distrib_left, exists_prop_of_true, finset.mem_image]
exact ⟨j, rfl, j', g, (by simp)⟩
intros
subst h
dsimp
simp
intros
have z : ∀ (j : J), r (classical.arbitrary J) j := induct_on_objects (λ k, r (classical.arbitrary J) k) (hr.1 (classical.arbitrary J)) (λ _ _ f, ⟨λ t, hr.2.2 t (h f), λ t, hr.2.2 t (hr.2.1 (h f))⟩)
apply hr.2.2 (hr.2.1 (z _)) (z _)
intros
dsimp [limit_uncurry_iso_limit_comp_lim, is_limit.cone_point_unique_up_to_iso, is_limit.unique_up_to_iso]
simp
intros
erw is_limit.fac
refl
intros
constructor
intro F
apply has_limit_of_equivalence_comp e
apply_instance
intros
dsimp [colimit.iso_colimit_cocone, is_colimit.cocone_point_unique_up_to_iso]
tidy
intros
ext
simp [← G.map_comp]
intros
simp
intros
ext
simp
simp
intros
simp
intros
ext
simp
intros
rw [t.app_zero_left, t.app_zero_right]
intros
ext
simp [← G.map_comp]
intros
ext
simp [image.comp_iso]
intros
rw [←fork.app_zero_left, kernel_fork.condition]
intros
apply colimit.w (wide_pushout_shape.wide_span _ _ _) (wide_pushout_shape.hom.init j)
intros
simp
refl
intros
rw [←w]
simp
intros
equiv_rw (is_limit_equiv_sections t).symm at x
simp
intros
rw [←triangle_assoc_comp_left, iso.inv_hom_id_assoc]
intros
rw [iso.inv_comp_eq, F.left_unitality, category.assoc, category.assoc, ←F.to_functor.map_comp, iso.hom_inv_id, F.to_functor.map_id, comp_id]
intros
dsimp [tensor_hom]
simp
intros
simp only [left_adjoint_mate, monoidal_category.tensor_id, category.id_comp, evaluation_coevaluation_assoc, category.comp_id, iso.inv_hom_id]
intros
tidy
intros
ext
simp
simp
simp
simp
intros
rw ← generate_of_singleton_split_epi (𝟙 X)
rw ← is_sheaf_for_iff_generate
apply is_sheaf_for_singleton_iso
intros
apply quotient.induction_on' x
intro t
apply quotient.sound
refine ⟨(mono_over.map_comp _ _).app t⟩
intros
rw ←image_subobject_arrow
simp
intros
simp [equalizer_subobject_iso]
intros
change F.repr_f.app X f = (F.repr_f.app (op F.repr_X) ≫ F.map f.op) (𝟙 F.repr_X)
rw ←F.repr_f.naturality
dsimp
simp
intros
rw [le_iff_le_iff_lt_iff_lt, sdiff_lt_sdiff_iff_lt]
intros
have hh := card_image_of_injective univ (G.dart_of_neighbor_set_injective v)
rw [finset.card_univ, card_neighbor_set_eq_degree] at hh
rwa dart_fst_fiber
intros
ext a
split
rintro ( ⟨ _, _, h ⟩ | ⟨ _, _, _, h, _ ⟩ )
exact h
cases h
intro h
apply ε_NFA.ε_closure.base
exact h
intros
letI : ∀ a, decidable (a ∈ set.range (encode : α → ℕ)) := decidable_range_encode _
exact subtype_mk primrec.encode
intros
letI : primcodable β := primcodable.of_equiv α e
exact encode_iff.1 primrec.encode
intros
induction c with generalizing k v
simp only [cont.then, step_normal, cfg.then, *] {constructor_eq := ff}
simp only [cont.then, step_normal, cfg.then, *] {constructor_eq := ff}
simp only [cont.then, step_normal, cfg.then, *] {constructor_eq := ff}
simp only [cont.then, step_normal, cfg.then, *] {constructor_eq := ff}
case turing.to_partrec.code.cons : c c' ih ih' { rw [← ih, cont.then] }
simp only [cont.then, step_normal, cfg.then, *] {constructor_eq := ff}
case turing.to_partrec.code.comp : c c' ih ih' { rw [← ih', cont.then] }
simp only [cont.then, step_normal, cfg.then, *] {constructor_eq := ff}
cases v.head
simp only [nat.elim]
simp only [nat.elim]
simp only [cont.then, step_normal, cfg.then, *] {constructor_eq := ff}
case turing.to_partrec.code.fix : c ih { rw [← ih, cont.then] }
intros
cases T
simp [tape.move]
intros
rcases trans_gen.head'_iff.1 h₁ with ⟨b', hab, hbc⟩
cases option.mem_unique hab h₂
exact hbc
intros
ext
simp only [(∘), mfoldr.of_free_monoid, mfoldr.mk, flip, fold_mfoldr_cons]
intros
simp [add_lsb,two_mul]
intros
cases b
convert array.read_push_back_left _
simp
intros
cases b
convert array.read_push_back_right
intros
contrapose! h
constructor
intros cb n hn
cases hp : p cb n
exact absurd hn (h _ _ _ _ hp).not_le
simp [hp]
intros
cases hp : p cb n
simp [hp, ←bind_eq_bind, parser.bind, and_assoc]
simp [hp, ←bind_eq_bind, parser.bind, and_assoc]
intros
simp [mmap, and.comm, and.assoc, and.left_comm, pure_eq_done]
intros
by_cases hn : n < cb.size
by_cases hp : p (cb.read ⟨n, hn⟩)
simp only [sat, hn, hp, dif_pos, if_true, exists_prop_of_true]
split
rintro ⟨rfl, rfl⟩
simp [hp]
rintro ⟨-, rfl, rfl⟩
simp
simp only [sat, hn, hp, dif_pos, false_iff, not_and, exists_prop_of_true, if_false]
rintro H - rfl
exact hp H
simp [sat, hn]
intros
simp [str_eq_char_buf, char_buf_eq_done]
intros
simp only [sub_conj, of_real_mul, of_real_one, of_real_bit0, mul_right_comm, mul_div_cancel_left _ (mul_ne_zero two_ne_zero' I_ne_zero : 2 * I ≠ 0)]
intros
rw ← of_real_inj
simp [sinh_add]
intros
rw ← of_real_inj
simp [cosh_two_mul]
intros
rw [two_mul, sinh_add]
ring
intros
simp [sub_eq_add_neg, sin_add, sin_neg, cos_neg]
intros
rw [← of_real_sin_of_real_re, of_real_im]
intros
rw [cos_two_mul', eq_sub_iff_add_eq.2 (sin_sq_add_cos_sq x), ← sub_add, sub_add_eq_add_sub, two_mul]
intros
have h1 : x + 2 * x = 3 * x
ring
rw [← h1, cos_add x (2 * x)]
simp only [cos_two_mul, sin_two_mul, mul_add, mul_sub, mul_one, sq]
have h2 : 4 * cos x ^ 3 = 2 * cos x * cos x * cos x + 2 * cos x * cos x ^ 2
ring
rw [h2, cos_sq']
ring
intros
rw [← of_real_inj, of_real_tan, tan_eq_sin_div_cos, of_real_div, of_real_sin, of_real_cos]
intros
simp [bit0]
intros
simp [bit1]
intros
simp [bit0, ext_iff]
intros
simp_rw conj_eq_re_sub_im
simp only [smul_re, smul_im, of_real_mul]
rw smul_sub
simp_rw of_real_alg
simp
intros
by_cases h : (I : K) = 0
simp [h]
field_simp [mul_assoc, I_mul_I_of_nonzero h]
intros
simp only [←sqrt_norm_sq_eq_norm, norm_sq_conj]
intros
rw [← of_real_rat_cast, of_real_re]
intros
simp
intros
ext j
by_cases h : i = j
subst h
simp [hb]
simp [ne.symm h, h]
intros
contrapose! h
exact prod_extend_right_apply_ne _ h _
intros
ext ⟨b, a, has, rfl⟩
have : ∀(h : ∃a', a' ∈ s ∧ a' = a), classical.some h = a := λ h, (classical.some_spec h).2
simp [equiv.set.image, equiv.set.image_of_inj_on, hf.eq_iff, this]
intros
ext
simp
intros
rw [← equiv.trans_apply, equiv.swap_swap, equiv.refl_apply]
intros
dsimp [fin_rotate]
rw fin_add_flip_apply_mk_right
simp
intros
ext ⟨i, h⟩
by_cases h' : i < n
rw [fin_rotate_of_lt h', fin.snoc, fin.cons, dif_pos h']
refl
have h'' : n = i
simp only [not_lt] at h'
exact (nat.eq_of_le_of_lt_succ h' h).symm
subst h''
rw [fin_rotate_last', fin.snoc, fin.cons, dif_neg (lt_irrefl _)]
refl
intros
split
rw [trans_source'', trans_source'', ← he.target_eq, ← hf.1]
exact (he.symm'.eq_on.mono $ inter_subset_left _ _).image_eq
assume x hx
rw trans_source at hx
simp [(he.2 hx.1).symm, hf.2 hx.2]
intros
rw [he.eq_on.inter_preimage_eq, he.source_eq]
intros
ext x
simp [ext_iff]
simp [ext_iff]
simp [ext_iff]
simp [ext_iff]
tauto
intros
ext
simp
intros
simp [snoc]
intros
ext j
by_cases h : j = i
rw h
simp [init]
simp [init, h]
intros
simp [eq_iff_veq]
intros
cases j
refl
intros
ext
rw [multiset.mem_to_finset, ←mem_def]
intros
intro s
rcases to_finset_surj_on (set.mem_univ s) with ⟨l, -, hls⟩
exact ⟨l, hls⟩
intros
rw ← not_iff_not
push_neg
exact card_le_one
intros
ext
simp only [finset.mem_bUnion, exists_prop]
simp_rw [←exists_and_distrib_right, ←exists_and_distrib_left, and_assoc]
rw exists_comm
intros
rw [insert_val, ndinsert_of_not_mem h]
intros
classical
induction s using finset.induction_on with x s hx IH generalizing n
simpa using h
cases n
simp
rw [card_insert_of_not_mem hx, nat.succ_lt_succ_iff] at h
rw powerset_len_succ_insert hx
refine nonempty.mono _ ((IH h).image (insert x))
convert (subset_union_right _ _)
intros
simp only [finsupp.support_eq_empty, finset.nonempty_iff_ne_empty, ne.def]
intros
rw [← card_to_multiset, ← card_to_multiset]
apply multiset.card_lt_of_lt
exact to_multiset_strict_mono h
intros
dsimp [finsupp.prod]
rw f.support.prod_ite_eq
intros
ext
rw dfinsupp.mem_support_to_fun
exact (finsupp.mem_split_support_iff_nonzero _ _).symm
intros
rw [list.of_fn_eq_map, fin.prod_univ_def]
intros
rw [← (equiv.sigma_preimage_equiv f).prod_comp, ← univ_sigma_univ, prod_sigma]
refl
intros
change sub_nat_nat _ _ = _
have h' : n.succ - m = (n - m).succ
apply succ_sub
apply le_of_lt_succ h
simp [*, sub_nat_nat]
intros
cases n
refl
refl
intros
have := int.add_mul_div_right 0 a H
rwa [zero_add, int.zero_div, zero_add] at this
intros
have := add_mul_mod_self_left a b 1
rwa mul_one at this
intros
rw [mul_comm, mul_div_cancel_of_mod_eq_zero H]
intros
rw int.lcm
apply nat.lcm_self
intros
induction m with d hd
refl
rw [pow_succ, pow_succ]
exact h.mul hd
intros
induction xs
refl
simp [lazy_list.append, xs_ih]
ext
congr
intros
cases l₂
exact if_pos h
exact if_pos h
intros
induction l with hd tl ih generalizing a
refl
unfold foldl
rw [ih (λ a b bin, H a b $ mem_cons_of_mem _ bin), H a hd (mem_cons_self _ _)]
intros
induction L with a L ihL
simp
rw [prod_cons, mul_eq_zero, ihL, mem_cons_iff, eq_comm]
intros
induction L generalizing i
simp
cases i
simp
simp [drop_append, L_ih]
intros
rw erase_eq_erasep
exact length_erasep_of_mem h rfl
intros
have := h
rw [← take_append_drop (length s₁) l] at this ⊢
rw map_append at this
refine ⟨_, _, rfl, append_inj this _⟩
rw [length_map, length_take, min_eq_left]
rw [← length_map f l, h, length_append]
apply nat.le_add_right
intros
induction l
refl
simp only [*, map]
split
intros
rw [next, next, next_or_cons_of_ne _ _ _ _ hy, next_or_eq_next_or_of_mem_of_ne]
rwa last_cons at hx
simpa [hy] using h
intros
simp_rw [nodup_iff_sublist, duplicate_iff_sublist]
intros
simp [duplicate_iff_sublist, le_count_iff_repeat_sublist]
intros
simp only [mmap_with_index, mmap_with_index_aux_spec, mmap_with_index_aux_eq_mmap_with_index_aux_spec, enum ]
intros
induction l with hd tl hl generalizing f n
simp [map_with_index, map_with_index_core]
rw [map_with_index]
simp [map_with_index_core, hl, add_left_comm, add_assoc, add_comm]
intros
simp only [pairwise_cons, mem_singleton, forall_prop_of_false (not_mem_nil _), forall_true_iff, pairwise.nil, and_true]
intros
induction s with y s IH generalizing n
simp only [length, permutations'_aux, nat.lt_one_iff] at hn
simp [hn]
cases n
simp
simpa using IH _ _
intros
induction hl
refl
case list.perm.cons : a l l' h ih { exact f_congr h ih }
case list.perm.swap : a a' l { exact f_swap }
case list.perm.trans : l₁ l₂ l₃ h₁ h₂ ih₁ ih₂ { exact heq.trans ih₁ ih₂ }
intros
let F := λ a b, ∀ (c ∈ f a) (d ∈ f b), a = b ∧ c = d
change pairwise F l₁ at H
induction p with a l₁ l₂ p IH a b l l₁ l₂ l₃ p₁ p₂ IH₁ IH₂
simp
cases h : f a
simp [h]
exact IH (pairwise_cons.1 H).2
simp [lookmap_cons_some _ _ h, p]
cases h₁ : f a with c
cases h₂ : f b with d
simp [h₁, h₂]
apply swap
simp [h₁, lookmap_cons_some _ _ h₂]
apply swap
cases h₂ : f b with d
simp [lookmap_cons_some _ _ h₁, h₂]
apply swap
simp [lookmap_cons_some _ _ h₁, lookmap_cons_some _ _ h₂]
rcases (pairwise_cons.1 H).1 _ (or.inl rfl) _ h₂ _ h₁ with ⟨rfl, rfl⟩
refl
refine (IH₁ H).trans (IH₂ ((p₁.pairwise_iff _).1 H))
exact λ a b h c h₁ d h₂, (h d h₂ c h₁).imp eq.symm eq.symm
intros
simp only [range_eq_range', pairwise_lt_range']
intros
simp only [range_eq_range', range'_sublist_right]
intros
cases l.length.zero_le.eq_or_lt with hl hl
simp [eq_nil_of_length_eq_zero hl.symm ]
rw [←rotate_eq_drop_append_take (n.mod_lt hl).le, rotate_mod]
intros
rw [is_rotated_comm, is_rotated_nil_iff, eq_comm]
intros
split
intro h
obtain ⟨k, hk, rfl⟩ := nth_le_of_mem h
simp
intro h
obtain ⟨k, rfl⟩ := h.symm
rw mem_iff_nth_le
simp only [exists_prop, nth_le_cyclic_permutations]
cases l' with x l
simp
refine ⟨k % length (x :: l), _, rotate_mod _ _⟩
simpa using nat.mod_lt _ (zero_lt_succ _)
intros
simp [h]
intros
induction l generalizing f r
refl
simp only [*, sublists'_aux]
intros
induction l with hd tl hl generalizing l'
simp
cases l'
simp
simp [comm, hl]
intros
rw [← unzip_left, unzip_revzip]
intros
induction l with hd tl hl generalizing f n l'
simp
cases l' with hd' tl'
simp
simp [hl, mul_add]
intros
ext i j
apply dot_product_add
intros
ext
apply dot_product_neg
intros
ext
simp only [block_diagonal_apply, pi.smul_apply]
split_ifs
simp
simp
intros
ext
simp only [block_diagonal'_apply, pi.add_apply]
split_ifs
simp
simp
intros
ext
by_cases h : i = j
simp [h]
simp [h]
intros
ext ⟨i, i'⟩ ⟨j, j'⟩
simp only [kronecker_map_bilinear_apply_apply, mul_apply, ← finset.univ_product_univ, finset.sum_product, kronecker_map]
simp_rw [f.map_sum, linear_map.sum_apply, linear_map.map_sum, h_comm]
intros
ext i j
rw [mul_matrix_apply, equiv.to_pequiv_apply]
intros
by_contra h
cases lt_iff_cons_le.1 (lt_of_le_of_ne (le_inter (add_le_add_right (inter_le_left s t) u) (add_le_add_right (inter_le_right s t) u)) h) with a hl
rw ← cons_add at hl
exact not_le_of_lt (lt_cons_self (s ∩ t) a) (le_inter (le_of_add_le_add_right (le_trans hl (inter_le_left _ _))) (le_of_add_le_add_right (le_trans hl (inter_le_right _ _))))
intros
refine ⟨mem_of_mem_nsmul, λ h, _⟩
obtain ⟨n, rfl⟩ := exists_eq_succ_of_ne_zero h0
rw [succ_nsmul, mem_add]
exact or.inl h
intros
induction k
simp
simpa
intros
rw [← multiset.card_eq_zero, multiset.card_map, multiset.card_eq_zero]
intros
simp
intros
apply m.induction_on
simp
intros a s h
simp [h]
intros
refine λ p, ⟨p.to_fun 0, finsupp.ext (λ a, _)⟩
simpa [(finsupp.ext is_empty_elim : a = 0), C_apply, monomial]
intros
apply @finsupp.induction σ ℕ _ _ s
simp only [C_apply, prod_zero_index]
exact (mul_one _).symm
assume n e s hns he ih
rw [monomial_single_add, ih, prod_add_index, prod_single_index, mul_left_comm]
simp only [pow_zero]
intro a
simp only [pow_zero]
intros
rw pow_add
intros
simp
intros
simp only [eval₂_eq, ← finsupp.prod_pow]
refl
intros
ext i
simp
intros
ext : 2
simp
simp
intros
split
intros h i
simpa using @h (X i)
exact supported_mono
intros
rw [supported, set.image_eq_range, adjoin_range_eq_range_aeval, rename]
intros
apply le_antisymm
apply degrees_add
apply multiset.union_le
apply le_degrees_add h
rw add_comm
apply le_degrees_add h.symm
intros
rw [add_comm, mod_add_mod, add_comm]
intros
rw [←nat.div_mul_cancel w, h, zero_mul]
intros
split
intro
cases b
simp * at *
cases b
right
refl
left
have : a / (b + 2) ≤ a / 2 := div_le_div_left (by simp) dec_trivial
refine eq_zero_of_le_half _
simp * at *
rintros (rfl|rfl)
simp
simp
intros
refine le_trans _ h
simp
intros
rw [add_comm, add_one, pred_succ]
intros
induction n using nat.binary_rec with b n hn' generalizing i m
contrapose! hm
rw le_zero_iff at hm
simp [hm]
induction m using nat.binary_rec with b' m hm' generalizing i
exact false.elim (bool.ff_ne_tt ((zero_test_bit i).symm.trans hm))
by_cases hi : i = 0
subst hi
simp only [test_bit_zero] at hn hm
have : n = m
exact eq_of_test_bit_eq (λ i, by convert hnm (i + 1) dec_trivial using 1; rw test_bit_succ)
rw [hn, hm, this, bit_ff, bit_tt, bit0_val, bit1_val]
exact lt_add_one _
obtain ⟨i', rfl⟩ := exists_eq_succ_of_ne_zero hi
simp only [test_bit_succ] at hn hm
have := hn' _ hn hm (λ j hj, by convert hnm j.succ (succ_lt_succ hj) using 1; rw test_bit_succ)
cases b
cases b'
simp only [bit_ff, bit_tt, bit0_val n, bit1_val n, bit0_val m, bit1_val m]
linarith
simp only [bit_ff, bit_tt, bit0_val n, bit1_val n, bit0_val m, bit1_val m]
linarith
cases b'
simp only [bit_ff, bit_tt, bit0_val n, bit1_val n, bit0_val m, bit1_val m]
linarith
simp only [bit_ff, bit_tt, bit0_val n, bit1_val n, bit0_val m, bit1_val m]
linarith
intros
induction l1 with hd tl IH
simp [of_digits]
rw [of_digits, list.cons_append, of_digits, IH, list.length_cons, pow_succ']
ring
intros
cases b with b
cases n with n
refl
change of_digits 0 [n+1] = n+1
dsimp [of_digits]
simp
cases b with b
induction n with n ih
refl
simp only [ih, add_comm 1, of_digits_one_cons, nat.cast_id, digits_one_succ]
apply nat.strong_induction_on n _
clear n
intros n h
cases n
rw digits_zero
refl
simp only [nat.succ_eq_add_one, digits_add_two_add_one]
dsimp [of_digits]
rw h _ (nat.div_lt_self' n b)
rw [nat.cast_id, nat.mod_add_div]
intros
split
intro h
have : of_digits b (digits b n) = of_digits b []
rw h
convert this
rw of_digits_digits
rintro rfl
simp
intros
rw ←int.coe_nat_dvd
exact dvd_iff_dvd_of_dvd_sub (zmodeq_of_digits_digits b b' c (int.modeq_iff_dvd.2 h).symm _).symm.dvd
intros
rw [dist.def, dist.def, right_distrib, nat.mul_sub_right_distrib, nat.mul_sub_right_distrib]
intros
simpa only [← some_eq_coe] using part.some_inj
intros
simp [coprime]
intros
rw [← enat.coe_le_coe, ← hp.multiplicity_factorial hbn, ← pow_dvd_iff_le_multiplicity]
intros
conv { to_rhs, rw [←nat.sub_add_cancel h, even_add] }
by_cases h : even n
simp [h]
simp [h]
intros
rw [odd_iff_not_even, even_sub h, not_iff, not_iff_comm, odd_iff_not_even]
intros
cases mod_two_eq_zero_or_one n with h h
simp [h]
simp [h]
intros
split
intro h
rcases n with (_ | _ | n)
exact or.inl rfl
exact or.inr rfl
rw factors at h
injection h
intro h
rcases h with (rfl | rfl)
exact factors_zero
exact factors_one
intros
obtain ⟨l, ⟨h, rfl⟩⟩ := (dvd_prime_pow pp).1 h₂
congr
exact le_antisymm h (not_le.1 ((not_congr (pow_dvd_pow_iff_le_right (prime.one_lt pp))).1 h₁))
intros
rw sqrt_aux
simp only [h, h₂.symm, int.coe_nat_add, if_false]
rw [add_comm _ (n':ℤ), add_sub_cancel, sqrt_aux._match_1]
intros
cases x
refl
refl
intros
cases x
simp
simp only [pbind]
split
intro h
use x
simpa only [mem_def, exists_prop_of_true] using h
rintro ⟨z, H, hz⟩
simp only [mem_def] at H
simpa only [H] using hz
intros
linarith
intros
cases l with ls ll lx lr
exact ⟨hr, (zero_add _).symm⟩
cases r with rs rl rx rr
exact ⟨hl, rfl⟩
dsimp [glue]
split_ifs
rw [split_max_eq, glue]
cases valid'.erase_max_aux hl with v e
suffices H
refine ⟨valid'.balance_r v (hr.of_gt _ _) H, _⟩
refine find_max'_all lx lr hl.1.2.to_nil (sep.2.2.imp _)
exact λ x h, hr.1.2.to_nil.mono_left (le_of_lt h.2.1)
exact @find_max'_all _ (λ a, all (> a) (node rs rl rx rr)) lx lr sep.2.1 sep.2.2
rw [size_balance_r v.3 hr.3 v.2 hr.2 H, add_right_comm, ← e, hl.2.1]
refl
refine or.inl ⟨_, or.inr e, _⟩
rwa hl.2.eq_node' at bal
rw [split_min_eq, glue]
cases valid'.erase_min_aux hr with v e
suffices H
refine ⟨valid'.balance_l (hl.of_lt _ _) v H, _⟩
refine @find_min'_all _ (λ a, bounded nil o₁ ↑a) rl rx (sep.2.1.1.imp _) hr.1.1.to_nil
exact λ y h, hl.1.1.to_nil.mono_right (le_of_lt h)
exact @find_min'_all _ (λ a, all (< a) (node ls ll lx lr)) rl rx (all_iff_forall.2 $ λ x hx, sep.imp $ λ y hy, all_iff_forall.1 hy.1 _ hx) (sep.imp $ λ y hy, hy.2.1)
rw [size_balance_l hl.3 v.3 hl.2 v.2 H, add_assoc, ← e, hr.2.1]
refl
refine or.inr ⟨_, or.inr e, _⟩
rwa hr.2.eq_node' at bal
intros
linarith
intros
cases r
simp [rotate_l, all_node']
simp [rotate_l, all_node']
split_ifs
simp [all_node3_l, all_node4_l, all]
simp [all_node3_l, all_node4_l, all]
intros
rw [balance_l_eq_balance' hl hr sl sr H, size_balance' sl sr]
intros
ext
rw mem_core_res
by_cases h : x ∈ s
simp [h]
simp [h]
intros
change (coe_pnat_monoid_hom (u + v)).prod = _
rw coe_pnat_monoid_hom.map_add
exact multiset.prod_add _ _
intros
let u := factor_multiset n
let v := factor_multiset m
have : n = u.prod := (prod_factor_multiset n).symm
rw[this]
have : m = v.prod := (prod_factor_multiset m).symm
rw[this]
rw[← prime_multiset.prod_add]
rw[prime_multiset.factor_multiset_prod]
rw[prime_multiset.factor_multiset_prod]
rw[prime_multiset.factor_multiset_prod]
intros
apply factor_multiset_equiv.symm.injective
change (p : ℕ+).factor_multiset.prod = (prime_multiset.of_prime p).prod
rw[(p : ℕ+).prod_factor_multiset, prime_multiset.prod_of_prime]
intros
rw [aeval_def, eval₂]
exact (linear_map.applyₗ v).map_sum
intros
ext
rw [coeff_C_mul, coeff_smul, smul_eq_mul]
intros
simp [coeff_X_pow]
intros
rw [add_comm _ X, coeff_X_add_one_pow]
intros
simp [bit1, add_mul, coeff_bit0_mul]
intros
simp
intros
rw [C_mul_X_pow_eq_monomial]
exact support_monomial _ _ h
intros
cases le_max_iff.1 (degree_add_le p q)
simp [nat_degree_le_nat_degree h]
simp [nat_degree_le_nat_degree h]
intros
nontriviality R
exact hp.ne_zero
intros
rw [C_mul_X_pow_eq_monomial, trailing_degree_monomial ha]
intros
rw [next_coeff_up, if_neg]
contrapose! hp
simpa
intros
rw [← C_0, comp_C]
intros
rw [← C_1, comp_C]
intros
induction n with n ih
exfalso
exact nat.not_lt_zero 1 h
simp only [iterated_deriv_succ]
by_cases H : n = 1
rw H
simp only [iterated_deriv_X_one, derivative_one]
replace h : 1 < n := array.push_back_idx h (ne.symm H)
rw ih h
simp only [derivative_zero]
intros
by_cases hq : q = 0
simp [h.mul_left_ne_zero, hq]
simp [h.mul_left_ne_zero, hq]
intros
refine le_antisymm _ _
rw degree_le_iff_coeff_zero
intros m hm
rw degree_lt_iff_coeff_zero at hm
simp [hm m le_rfl]
rw degree_le_iff_coeff_zero
intros m hm
rw degree_lt_iff_coeff_zero at hm
refine h _
simpa using hm m le_rfl
intros
obtain ⟨r, hr⟩ := hdiv
have rzero : r ≠ 0
intro h
simpa [h, monic.ne_zero hq] using hr
rw [hr, nat_degree_mul (monic.ne_zero hp) rzero] at hdeg
have hdegeq : p.nat_degree + r.nat_degree = p.nat_degree
suffices hdegle : p.nat_degree ≤ p.nat_degree + r.nat_degree
exact le_antisymm hdeg hdegle
exact nat.le.intro rfl
replace hdegeq := eq_C_of_nat_degree_eq_zero (((@add_right_inj _ _ p.nat_degree) _ 0).1 hdegeq)
suffices hlead : 1 = r.leading_coeff
have hcoeff := leading_coeff_C (r.coeff 0)
rw [← hdegeq, ← hlead] at hcoeff
rw [← hcoeff, C_1] at hdegeq
rwa [hdegeq, mul_one] at hr
have hprod : q.leading_coeff = p.leading_coeff * r.leading_coeff
simp only [hr, leading_coeff_mul]
rwa [monic.leading_coeff hp, monic.leading_coeff hq, one_mul] at hprod
intros
rw [← supp_preservation_iff_liftp_preservation, supp_preservation_iff_uniform]
intros
split
intros h α a a' f f' h'
rw [← pfunctor.supp_eq,← pfunctor.supp_eq,← h,h',h]
rintros h α ⟨a,f⟩
rwa [supp_eq_of_is_uniform,pfunctor.supp_eq]
intros
rcases h with ⟨c, rfl⟩
simp only [mul_comm b, nat.mul_div_assoc c (dvd_refl b), nat.cast_mul, mul_div_assoc, coe_nat_div_self]
intros
simp only [lt_iff_le_not_le]
apply and_congr
simp [div_num_denom, (rat.le_def b_pos d_pos)]
apply not_iff_not_of_iff
simp [div_num_denom, (rat.le_def d_pos b_pos)]
intros
rw le_iff_lt_or_eq
exact or_congr const_lt const_equiv
intros
have KK := mul_pos K0 K0
have εK := mul_pos ε0 KK
refine ⟨_, εK, λ a b ha hb h, _⟩
have a0 := lt_of_lt_of_le K0 ha
have b0 := lt_of_lt_of_le K0 hb
rw [inv_sub_inv ((abv_pos abv).1 a0) ((abv_pos abv).1 b0), abv_div abv, abv_mul abv, mul_comm, abv_sub abv, ← mul_div_cancel ε (ne_of_gt KK)]
exact div_lt_div h (mul_le_mul hb ha (le_of_lt K0) (abv_nonneg abv _)) (le_of_lt $ mul_pos ε0 KK) KK
intros
simp_rw [ennreal.of_real, ←coe_finset_prod, coe_eq_coe]
exact real.to_nnreal_prod_of_nonneg hf
intros
have : ↑a.to_nnreal = a := ennreal.coe_to_nnreal (lt_of_le_of_lt h coe_lt_top).ne
rw ← this at h
exact_mod_cast h
intros
rwa [← pos_iff_ne_zero, ← add_lt_add_iff_left ha, add_zero] at hb
intros
simp [add_eq_top]
intros
rw [←ereal.neg_neg a, h, ereal.neg_neg b]
rw [neg_lt, ← inv_gold]
exact inv_lt_one one_lt_gold
intros
rw iff_eq_eq
refl
intros
rw [←nnreal.coe_eq, nnreal.coe_prod, real.coe_to_nnreal _ (finset.prod_nonneg hf)]
exact finset.prod_congr rfl (λ x hxs, by rw real.coe_to_nnreal _ (hf x hxs))
intros
rw [mul_self_le_mul_self_iff hx (sqrt_nonneg _), sq, mul_self_sqrt hy]
intros
split
simpa only [abs_le] using abs_le_sqrt
rw [← abs_le, ← sq_abs]
exact (le_sqrt (abs_nonneg x) h).mp
intros
rw [sqrt_eq_iff_sq_eq, mul_mul_mul_comm, mul_self_sqrt, mul_self_sqrt]
intros
apply mem_rec_on h
intros
simp [*]
intros
rw add_comm
symmetry
apply dropn_add
intros
subst hT'
cases set.mem_Union.1 x.prop with i hi
rw [Union_lift_of_mem x hi, ← h i]
have : x = (set.inclusion (set.subset_Union S i) ⟨x, hi⟩)
cases x
refl
have hx' : (set.inclusion (set.subset_Union S i) (ui i ⟨x, hi⟩) : α) ∈ S i
from (ui i ⟨x, hi⟩).prop
conv_lhs { rw [this, hui, Union_lift_inclusion] }
intros
simp
intros
refine (iff.symm $ iff.intro (image_subset f) $ assume h, _)
rw [← preimage_image_eq s hf, ← preimage_image_eq t hf]
exact preimage_mono h
intros
split
rintro ⟨s, hs⟩
refine ⟨coe '' s, _, hs⟩
convert image_subset_range _ _
rw [range_coe]
rintro ⟨s, hs₁, hs₂⟩
refine ⟨coe ⁻¹' s, _⟩
rw [image_preimage_eq_of_subset]
exact hs₂
rw [range_coe]
exact hs₁
intros
rw [inter_comm, ← image_preimage_coe, nonempty_image_iff]
intros
ext
simp
intros
ext ⟨x, y⟩
simp [and_comm]
intros
ext
split
rintro ⟨_, b, ⟨a, ha, rfl⟩, hb, rfl⟩
refine ⟨a, b, ha, hb, rfl⟩
rintro ⟨a, b, ha, hb, rfl⟩
refine ⟨_, b, ⟨a, ha, rfl⟩, hb, rfl⟩
intros
rw bUnion_eq_Union
haveI := hs.to_encodable
exact countable_Union (by simpa using ht)
intros
refine ⟨_, h.right_inv_on_inv_fun_on⟩
rintros _ ⟨y, hy, rfl⟩
rw [h.right_inv_on_inv_fun_on hy]
intros
rw ← image_univ at *
exact h.inj_on_image (ha.inj_on univ) hf
intros
rw [Ioc_union_Ioc, min_self]
exact (min_le_left _ _).trans (le_max_left _ _)
exact (min_le_left _ _).trans (le_max_left _ _)
intros
simp [← Ici_inter_Iio]
intros
rw [e.image_eq_preimage, e.symm.preimage_Ioo, e.symm_symm]
intros
rw [insert_eq, ← diff_diff, Icc_diff_left, Ioc_diff_right]
intros
rw [← Icc_diff_left, diff_diff_cancel_left (singleton_subset_iff.2 $ left_mem_Icc.2 h)]
intros
rw [diff_eq, compl_Ici, Ioi_inter_Iio]
intros
simp [← Ioi_inter_Iio]
intros
simp [add_comm]
intros
cases eq_or_lt_of_le hc
subst c
simp [(nonempty_Icc.2 hab).image_const]
exact image_mul_right_Icc' a b ‹0 < c›
intros
classical
apply subset.antisymm
simp [Inter_subset]
intros y y_in
simp only [mem_image, mem_Inter, mem_preimage]
rcases hv with ⟨z, hz⟩
refine ⟨function.update z i y, _, update_same i y z⟩
rw @forall_update_iff ι α _ z i y (λ i t, t ∈ v i)
exact ⟨y_in, λ j hj, by simpa using hz j⟩
intros
simp only [Union_or, Union_union_distrib, Union_Union_eq_left]
intros
rw [Union_nonempty_index, bUnion_self]
intros
simpa [pairwise, function.on_fun] using @hr a b
intros
ext ⟨x⟩
erw [quotient.lift_mk f H, Hg]
refl
intros
rw [←as_string_inv_to_list s, list.as_string_inj, as_string_inv_to_list s]
intros
casesI n
apply int.cast_mul
simp only [coe_coe]
symmetry
erw [fin.coe_mul, ← nat.cast_mul, ← sub_eq_zero, ← nat.cast_sub (nat.mod_le _ _), @char_p.cast_eq_zero_iff R _ _ m]
exact h.trans (nat.dvd_sub_mod _)
intros
refine {..}
refl
refl
intros
refl
intros
refl
intros
simpa only [nsmul_eq_mul, add_right_iterate] using (f.commute_add_int m).iterate_pos_eq_iff_map_eq f.monotone (strict_mono_id.add_const m) hn
intros
simpa only [not_le] using not_congr (f.iterate_pos_le_iff hn)
intros
simp [transnum_aux_seq]
intros
rw [← translation_number_conj_eq' (translate $ multiplicative.of_add x)]
convert tendsto_translation_number₀ _
ext n
simp [sub_eq_neg_add, units.conj_pow']
intros
have A : ∀ m, measurable_set (f^[m] ⁻¹' s) := λ m, (hf.iterate m).measurable hs
have B : ∀ m, μ (f^[m] ⁻¹' s) = μ s
from λ m, (hf.iterate m).measure_preimage hs
have : μ (univ : set α) < (finset.range n).sum (λ m, μ (f^[m] ⁻¹' s))
simpa only [B, nsmul_eq_mul, finset.sum_const, finset.card_range]
rcases exists_nonempty_inter_of_measure_univ_lt_sum_measure μ (λ m hm, A m) this with ⟨i, hi, j, hj, hij, x, hxi, hxj⟩
wlog hlt : i < j := hij.lt_or_lt using [i j, j i] tactic.skip
simp only [set.mem_preimage, finset.mem_range] at hi hj hxi hxj
refine ⟨f^[i] x, hxi, j - i, ⟨nat.sub_pos_of_lt hlt, lt_of_le_of_lt (j.sub_le i) hj⟩, _⟩
rwa [← iterate_add_apply, nat.sub_add_cancel hlt.le]
exact λ hi hj hij hxi hxj, this hj hi hij.symm hxj hxi
intros
simp only [mul_comm n, hm.mul_const n]
intros
ext
rw iff_true_right intermediate_field.mem_top
exact dim_adjoin_simple_eq_one_iff.mp (h x)
intros
ext
rw [mem_to_subalgebra, algebra.mem_bot, mem_bot]
intros
rw [← card_units p, pow_card_eq_one]
intros
let b := basis.of_vector_space K V
rw [← b.mk_eq_dim'', lt_omega_iff_finite]
split
introI
exact finite_of_linear_independent (basis.of_vector_space_index.linear_independent K V)
assume hbfinite
refine @is_noetherian_of_linear_equiv K (⊤ : submodule K V) V _ _ _ _ _ (linear_equiv.of_top _ rfl) (id _)
refine is_noetherian_of_fg_of_noetherian _ ⟨set.finite.to_finset hbfinite, _⟩
rw [set.finite.coe_to_finset, ← b.span_eq, basis.coe_of_vector_space, subtype.range_coe]
intros
rw [mul_comm, coeff_expand_mul hp]
intros
obtain ⟨p, rfl⟩ := hq
apply is_coprime_self.mp
have : is_coprime (q * (q * p)) (q * (q.derivative * p + q.derivative * p + q * p.derivative))
simp only [← mul_assoc, mul_add]
convert hp
rw [derivative_mul, derivative_mul]
ring
exact is_coprime.of_mul_right_left (is_coprime.of_mul_left_left this)
intros
simpa only [field_range_eq_map] using (⊤ : subfield K).map_map g f
intros
rw [angle, ← real_inner_div_norm_mul_norm_eq_one_iff, real.arccos_eq_zero, has_le.le.le_iff_eq, eq_comm]
exact (abs_le.mp (abs_real_inner_div_norm_mul_norm_le_one x y)).2
intros
symmetry
rw [←h₂, t₂.affine_span_insert_singleton_eq_altitude_iff]
rw [h₂]
use t₁.independent.injective.ne hi₁₂
have he : affine_span ℝ (set.range t₂.points) = affine_span ℝ (set.range t₁.points)
refine ext_of_direction_eq _ ⟨t₁.points i₃, mem_affine_span ℝ ⟨j₃, h₃⟩, mem_affine_span ℝ (set.mem_range_self _)⟩
refine eq_of_le_of_finrank_eq (direction_le (span_points_subset_coe_of_subset_coe _)) _
have hu : (finset.univ : finset (fin 3)) = {j₁, j₂, j₃}
clear h₁ h₂ h₃
dec_trivial!
rw [←set.image_univ, ←finset.coe_univ, hu, finset.coe_insert, finset.coe_insert, finset.coe_singleton, set.image_insert_eq, set.image_insert_eq, set.image_singleton, h₁, h₂, h₃, set.insert_subset, set.insert_subset, set.singleton_subset_iff]
exact ⟨t₁.orthocenter_mem_affine_span, mem_affine_span ℝ (set.mem_range_self _), mem_affine_span ℝ (set.mem_range_self _)⟩
rw [direction_affine_span, direction_affine_span, t₁.independent.finrank_vector_span (fintype.card_fin _), t₂.independent.finrank_vector_span (fintype.card_fin _)]
rw he
use mem_affine_span ℝ (set.mem_range_self _)
have hu : finset.univ.erase j₂ = {j₁, j₃}
clear h₁ h₂ h₃
dec_trivial!
rw [hu, finset.coe_insert, finset.coe_singleton, set.image_insert_eq, set.image_singleton, h₁, h₃]
have hle : (t₁.altitude i₃).directionᗮ ≤ (affine_span ℝ ({t₁.orthocenter, t₁.points i₃} : set P)).directionᗮ := submodule.orthogonal_le (direction_le (affine_span_orthocenter_point_le_altitude _ _))
refine hle ((t₁.vector_span_le_altitude_direction_orthogonal i₃) _)
have hui : finset.univ.erase i₃ = {i₁, i₂}
clear hle h₂ h₃
dec_trivial!
rw [hui, finset.coe_insert, finset.coe_singleton, set.image_insert_eq, set.image_singleton]
refine vsub_mem_vector_span ℝ (set.mem_insert _ _) (set.mem_insert_of_mem _ (set.mem_singleton _))
intros
refine times_cont_mdiff_of_support (λ x hx, _)
have : x ∈ (chart_at H c).source := f.closure_support_subset_chart_at_source hx
refine times_cont_mdiff_at.congr_of_eventually_eq _ (f.eq_on_source.eventually_eq_of_mem $ is_open.mem_nhds (chart_at _ _).open_source this)
exact f.to_times_cont_diff_bump.times_cont_diff_at.times_cont_mdiff_at.comp _ (times_cont_mdiff_at_ext_chart_at' this)
intros
obtain ⟨s, hsc, hsU⟩ : ∃ s, countable s ∧ (⋃ x (hx : x ∈ s), (chart_at H x).source) = univ := countable_cover_nhds_of_sigma_compact (λ x : M, is_open.mem_nhds (chart_at H x).open_source (mem_chart_source H x))
exact charted_space.second_countable_of_countable_cover H hsU hsc
intros
have E : e.target ∩ e.symm ⁻¹' e.source = e.target := subset.antisymm (inter_subset_left _ _) (λx hx, ⟨hx, local_equiv.target_subset_preimage_source _ hx⟩)
simpa [local_equiv.trans_source, E] using c.open_source e e he he
intros
rw [range_comp, image_eq_preimage]
intros
simp
intros
refine ⟨h.1.congr h₁ hx, _⟩
have A : s ∩ g' ⁻¹' (chart_at H' (g' x)).source = s ∩ g ⁻¹' (chart_at H' (g' x)).source
ext y
split
assume hy
simp only with mfld_simps at hy
simp only [hy, ← h₁ _ hy.1] with mfld_simps
assume hy
simp only with mfld_simps at hy
simp only [hy, h₁ _ hy.1] with mfld_simps
have := h.2
rw [← hx, ← A] at this
convert hG.congr _ _ this using 2
assume y hy
simp only with mfld_simps at hy
have : (chart_at H x).symm y ∈ s
simp only [hy]
simp only [hy, h₁ _ this] with mfld_simps
simp only [hx] with mfld_simps
intros
split
intros s x u f hu hux
split
rintros h hx
rcases h hx.1 with ⟨e, heG, hef, hex⟩
have : s ∩ u ∩ e.source ⊆ s ∩ e.source := by mfld_set_tac
exact ⟨e, heG, hef.mono this, hex⟩
rintros h hx
rcases h ⟨hx, hux⟩ with ⟨e, heG, hef, hex⟩
refine ⟨e.restr (interior u), _, _, _⟩
exact closed_under_restriction' heG (is_open_interior)
have : s ∩ u ∩ e.source = s ∩ (e.source ∩ u) := by mfld_set_tac
simpa only [this, interior_interior, hu.interior_eq] with mfld_simps using hef
simp only [*, interior_interior, hu.interior_eq] with mfld_simps
intros s x f e' he'G he'x h hx
have hxs : x ∈ s := by simpa only [e'.left_inv he'x] with mfld_simps using hx.2
rcases h hxs with ⟨e, heG, hef, hex⟩
refine ⟨e'.symm.trans e, G.trans (G.symm he'G) heG, _, _⟩
intros y hy
simp only with mfld_simps at hy
simp only [hef ⟨hy.1.2, hy.2.2⟩] with mfld_simps
simp only [hex, he'x] with mfld_simps
intros s x f g hfgs hfg' h hx
rcases h hx with ⟨e, heG, hef, hex⟩
refine ⟨e, heG, _, hex⟩
intros y hy
rw [← hef hy, hfgs y hy.1]
intros s x f e' he'G he' hfx h hx
rcases h hx with ⟨e, heG, hef, hex⟩
refine ⟨e.trans e', G.trans heG he'G, _, _⟩
intros y hy
simp only with mfld_simps at hy
simp only [hef ⟨hy.1, hy.2.1⟩] with mfld_simps
simpa only [hex, hef ⟨hx, hex⟩] with mfld_simps using hfx
intros
simp only [tangent_map_within, id.def]
rw mfderiv_within_id
rcases p
refl
exact hs
intros
rw [← times_cont_diff_on_univ, ← times_cont_mdiff_on_univ, times_cont_mdiff_on_iff_times_cont_diff_on]
intros
assume x
rw [times_cont_mdiff_at, times_cont_mdiff_within_at_iff]
refine ⟨Z.to_topological_fiber_bundle_core.continuous_proj.continuous_at.continuous_within_at, _⟩
simp only [(∘), chart_at, chart] with mfld_simps
apply times_cont_diff_within_at_fst.congr
rintros ⟨a, b⟩ hab
simp only with mfld_simps at hab
simp only [hab] with mfld_simps
simp only with mfld_simps
intros
set L := ((continuous_linear_map.fst ℝ E ℝ).comp (@continuous_linear_map.proj ℝ _ ι (λ _, E × ℝ) _ _ (λ _, infer_instance) (f.ind x hx)))
have := L.has_mfderiv_at.comp x f.embedding_pi_tangent.mdifferentiable_at.has_mfderiv_at
convert has_mfderiv_at_unique this _
refine (has_mfderiv_at_ext_chart_at I (f.mem_chart_at_ind_source x hx)).congr_of_eventually_eq _
refine (f.eventually_eq_one x hx).mono (λ y hy, _)
simp only [embedding_pi_tangent_coe, continuous_linear_map.coe_comp', (∘), continuous_linear_map.coe_fst', continuous_linear_map.proj_apply]
rw [hy, pi.one_apply, one_smul]
intros
rw [left_transversals, set.mem_set_of_eq, is_complement_iff_exists_unique]
refine ⟨λ h g, _, λ h g, _⟩
obtain ⟨x, h1, h2⟩ := h g
exact ⟨x.1, (congr_arg (∈ T) (eq_inv_mul_of_mul_eq h1)).mp x.2.2, λ y hy, (prod.ext_iff.mp (h2 ⟨y, y⁻¹ * g, hy⟩ (mul_inv_cancel_left y g))).1⟩
obtain ⟨x, h1, h2⟩ := h g
refine ⟨⟨x, x⁻¹ * g, h1⟩, mul_inv_cancel_left x g, λ y hy, _⟩
have := h2 y.1 ((congr_arg (∈ T) (eq_inv_mul_of_mul_eq hy)).mp y.2.2)
exact prod.ext this (subtype.ext (eq_inv_mul_of_mul_eq ((congr_arg _ this).mp hy)))
intros
convert (submonoid.fg_iff_add_fg P.to_submonoid).symm
exact set_like.ext' rfl
intros
let S : submonoid (free_product M) := ⟨set_of C, h_one, h_mul⟩
convert subtype.prop (lift (λ i, of.cod_mrestrict S (h_of i)) m)
change monoid_hom.id _ m = S.subtype.comp _ m
congr
ext
simp [monoid_hom.cod_mrestrict]
intros
rw eq_bot_iff
exact general_commutator_le_left ⊥ H
intros
rw [← fintype.card_prod, ← fintype.card_sigma, fintype.card_congr (sigma_fixed_by_equiv_orbits_prod_group α β)]
intros
exact {smul_comm := λ n, @smul_comm _ _ _ _ _ _ (g n) }
intros
rw [←one_smul R x, ←smul_assoc]
exact p.smul_mem _ h
intros
rw r_eq_r' S
refl
intros
intro g
obtain ⟨j, hj⟩ := (hH.to_quotient ((H ⊓ K).comap H.subtype)).of_equiv (quotient_group.quotient_inf_equiv_prod_normal_quotient H K) g
obtain ⟨k, hk⟩ := hK ⟨g ^ (p ^ j), (congr_arg (∈ K) ((H ⊔ K).coe_pow g (p ^ j))).mp ((quotient_group.eq_one_iff (g ^ (p ^ j))).mp ((quotient_group.coe_pow (K.comap (H ⊔ K).subtype) g (p ^ j)).trans hj))⟩
rw [subtype.ext_iff, K.coe_pow, subtype.coe_mk, ←pow_mul, ←pow_add] at hk
refine ⟨j + k, by rwa [subtype.ext_iff, (H ⊔ K).coe_pow]⟩
intros
induction s using quot.induction_on
simpa using list.form_perm_eq_self_of_not_mem _ _ hx
intros
refine is_conj_iff.2 ⟨equiv.extend_subtype f, _⟩
rw mul_inv_eq_iff_eq_mul
ext
simp only [perm.mul_apply]
by_cases hx : x ∈ σ.support
rw [equiv.extend_subtype_apply_of_mem, equiv.extend_subtype_apply_of_mem]
exact hf x (finset.mem_coe.2 hx)
rwa [not_not.1 ((not_congr mem_support).1 (equiv.extend_subtype_not_mem f _ _)), not_not.1 ((not_congr mem_support).mp hx)]
intros
classical
obtain ⟨_|i, hi, rfl⟩ := h.nat'
refine ⟨order_of f, order_of_pos f, le_rfl, _⟩
rw [pow_order_of_eq_one, pow_zero]
exact ⟨i.succ, i.zero_lt_succ, hi.le, rfl⟩
intros
by_cases hx : f x = x
rw (cycle_of_eq_one_iff _).mpr hx
simp [hx]
rw [mem_support, cycle_of_apply]
split_ifs with hy
simp only [hx, hy, iff_true, ne.def, not_false_iff, and_self, mem_support]
rcases hy with ⟨k, rfl⟩
rw ←not_mem_support
simpa using hx
simpa [hx] using hy
intros
obtain ⟨m, rfl⟩ := exists_add_of_le h
rw [add_comm, cycle_type_fin_rotate]
intros
cases lt_or_ge j.cast_succ i with h h
rw [fin.succ_above_below _ _ h, fin.cycle_range_of_lt h, fin.coe_succ_eq_succ]
rw [fin.succ_above_above _ _ h, fin.cycle_range_of_gt (fin.le_cast_succ_iff.mp h)]
intros
induction n with n ih
simp
rw fin_rotate_succ
simp [ih, pow_succ]
intros
simp [disjoint_iff_eq_or_eq, disjoint_iff, finset.ext_iff, not_and_distrib]
intros
rw is_solvable_def at *
cases h with n hn
use n
rw ← map_eq_bot_iff_of_injective _ hf
rw eq_bot_iff at *
calc map f (derived_series G n) ≤ derived_series G' n : map_derived_series_le_derived_series f n ... ≤ ⊥ : hn
intros
rw set_like.ext'_iff
simp only [coe_bot, set.eq_singleton_iff_unique_mem, set_like.mem_coe, H.one_mem, true_and]
intros
revert a
refine add_submonoid.closure_induction hb _ _ _
clear hb b
exact λ r hr b hb, S.mul_right_mem_add_closure hb hr
clear hb b
exact λ b hb, by simp only [mul_zero, (add_submonoid.closure (S : set R)).zero_mem]
clear hb b
simp_rw mul_add
exact λ r s hr hs b hb, (add_submonoid.closure (S : set R)).add_mem (hr hb) (hs hb)
intros
lift m to multiset S using hm
rw ← coe_multiset_prod
exact m.prod.coe_prop
intros
simp only [homothety_def, add_smul, vadd_vadd]
intros
rw ← set.ne_empty_iff_nonempty
rintros rfl
rw affine_subspace.span_empty at h
exact bot_ne_top k V P h
intros
by_contradiction h
rw set.not_nonempty_iff_eq_empty at h
have hlt := sup_direction_lt_of_nonempty_of_inter_empty h1 h2 h
rw hd at hlt
exact not_top_lt hlt
intros
cases inter_nonempty_of_nonempty_of_sup_direction_eq_top h1 h2 hd.sup_eq_top with p hp
use p
ext q
rw set.mem_singleton_iff
split
rintros ⟨hq1, hq2⟩
have hqp : q -ᵥ p ∈ s1.direction ⊓ s2.direction := ⟨vsub_mem_direction hq1 hp.1, vsub_mem_direction hq2 hp.2⟩
rwa [hd.inf_eq_bot, submodule.mem_bot, vsub_eq_zero_iff_eq] at hqp
exact λ h, h.symm ▸ hp
intros
simp [vector_span_eq_span_vsub_set_right_ne _ (finset.mem_coe.mpr hp)]
intros
simp [ha]
intros
rw [← @vsub_eq_zero_iff_eq V, midpoint_vsub_midpoint, midpoint_eq_iff, point_reflection_apply, vsub_eq_sub, zero_sub, vadd_eq_add, add_zero, neg_eq_iff_neg_eq, neg_vsub_eq_vsub_rev, eq_comm]
intros
haveI : nonempty s := hs.to_subtype
simp only [Sup_eq_supr', mem_supr_of_directed _ hdir.directed_coe, set_coe.exists, subtype.coe_mk]
intros
rwa [submodule.map_comap_eq, inf_eq_right]
intros
rw [of_le, ker_cod_restrict, ker_subtype]
intros
rw submodule.mem_map
split
rintros ⟨y, hy, hx⟩
simp [←hx, hy]
intros hx
refine ⟨e.symm x, hx, by simp⟩
intros
cases B
cases D
congr
funext
exact H _ _
intros
simp only [pair_self_adjoint_matrices_submodule, linear_equiv.coe_coe, linear_map.to_matrix'_apply, submodule.mem_map, bilin_form.mem_is_pair_self_adjoint_submodule]
split
rintros ⟨f, hf, hA⟩
have hf' : f = A.to_lin' := by rw [←hA, matrix.to_lin'_to_matrix']
rw hf' at hf
rw ← is_adjoint_pair_to_bilin'
exact hf
intros h
refine ⟨A.to_lin', _, linear_map.to_matrix'_to_lin' _⟩
exact (is_adjoint_pair_to_bilin' _ _ _ _).mpr h
intros
ext A x y
simp
intros
rw [B.to_matrix_comp_right b, to_matrix_to_lin]
intros
simpa using lift_dim_map_le f p
intros
rw ←dim_range_of_surjective f h
apply dim_range_le
intros
convert b.to_dual_apply i j using 2
rw @eq_comm _ j i
intros
exact dim_top F E
intros
apply finsupp.induction_linear l
simp { contextual := tt, }
simp { contextual := tt, }
simp { contextual := tt, }
intros
simp only [total_apply]
apply induction_linear f
simp only [sum_zero_index]
intros f₁ f₂ h₁ h₂
simp [sum_add_index, h₁, h₂, add_smul]
simp [sum_single_index, sum_smul_index, smul_sum, mul_smul]
intros
let a : R := generator (ϕ.submodule_image N)
let d : R := is_principal.generator (submodule.span R {a, ψ ⟨y, hNO yN⟩})
have d_dvd_left : d ∣ a := (mem_iff_generator_dvd _).mp (subset_span (mem_insert _ _))
have d_dvd_right : d ∣ ψ ⟨y, hNO yN⟩ := (mem_iff_generator_dvd _).mp (subset_span (mem_insert_of_mem _ (mem_singleton _)))
refine dvd_trans _ d_dvd_right
rw [dvd_generator_iff, ideal.span, ← span_singleton_generator (submodule.span R {a, ψ ⟨y, hNO yN⟩})]
obtain ⟨r₁, r₂, d_eq⟩ : ∃ r₁ r₂ : R, d = r₁ * a + r₂ * ψ ⟨y, hNO yN⟩
obtain ⟨r₁, r₂', hr₂', hr₁⟩ := mem_span_insert.mp (is_principal.generator_mem (submodule.span R {a, ψ ⟨y, hNO yN⟩}))
obtain ⟨r₂, rfl⟩ := mem_span_singleton.mp hr₂'
exact ⟨r₁, r₂, hr₁⟩
let ψ' : O →ₗ[R] R := r₁ • ϕ + r₂ • ψ
have : span R {d} ≤ ψ'.submodule_image N
rw [span_le, singleton_subset_iff, set_like.mem_coe, linear_map.mem_submodule_image_of_le hNO]
refine ⟨y, yN, _⟩
change r₁ * ϕ ⟨y, hNO yN⟩ + r₂ * ψ ⟨y, hNO yN⟩ = d
rw [d_eq, ϕy_eq]
refine le_antisymm (this.trans (le_of_eq _)) (ideal.span_singleton_le_span_singleton.mpr d_dvd_left)
rw span_singleton_generator
refine hϕ ψ' (le_trans _ this)
rw [← span_singleton_generator (ϕ.submodule_image N)]
exact ideal.span_singleton_le_span_singleton.mpr d_dvd_left
exact subset_span (mem_insert _ _)
intros
let P := linear_equiv.fun_congr_left R R (fintype.equiv_fin α)
let Q := linear_equiv.fun_congr_left R R (fintype.equiv_fin β)
exact le_of_fin_surjective R ((Q.symm.to_linear_map.comp f).comp P.to_linear_map) (((linear_equiv.symm Q).surjective.comp i).comp (linear_equiv.surjective P))
intros
rw [basis, ← coe_eval_ring_hom, (eval_ring_hom x).map_prod, coe_eval_ring_hom, finset.prod_eq_one]
intros y hy
simp_rw [eval_mul, eval_sub, eval_C, eval_X]
exact inv_mul_cancel (sub_ne_zero_of_ne (finset.ne_of_mem_erase hy).symm)
intros
have : ↑((linear_independent.total_equiv hv : (ι →₀ R) →ₗ[R] span R (range v)) l) = finsupp.total ι M R v l := rfl
have : (linear_independent.total_equiv hv : (ι →₀ R) →ₗ[R] span R (range v)) l = x
rw eq at this
exact subtype.ext_iff.2 this
rw ←linear_equiv.symm_apply_apply hv.total_equiv l
rw ←this
refl
intros
rw basis.to_matrix
ext i j
simp [basis.equiv_fun, matrix.one_apply, finsupp.single, eq_comm]
intros
ext i j
simp [pi.single_apply, one_apply, sub_eq_zero]
intros
rintros ⟨a, b⟩ ⟨c, d⟩ h
simp only [prod.mk.inj_iff, ne.def, not_and_distrib] at h
cases h with hac hbd
simp [hA hac]
simp [hB hbd]
intros
simp_rw [linear_map.to_matrix, linear_equiv.trans_apply, linear_equiv.arrow_congr_comp _ v₂.equiv_fun, linear_map.to_matrix'_comp]
intros
induction L with t L IH
simp
simp only [to_matrix_reindex_equiv, IH, function.comp_app, list.prod_cons, mul_eq_mul, reindex_alg_equiv_apply, list.map]
exact (reindex_alg_equiv_mul _ _ _ _).symm
intros
induction hn : fintype.card n with r IH generalizing n M
refine ⟨list.nil, list.nil, λ _, 1, _⟩
ext i j
rw fintype.card_eq_zero_iff at hn
exact hn.elim' i
have e : n ≃ fin r ⊕ unit
refine fintype.equiv_of_card_eq _
rw hn
convert (@fintype.card_sum (fin r) unit _ _).symm
simp
apply reindex_exists_list_transvec_mul_mul_list_transvec_eq_diagonal M e
apply exists_list_transvec_mul_mul_list_transvec_eq_diagonal_induction (λ N, IH (fin r) N (by simp))
intros
simp [pi_ring, linear_map.lsum]
intros
ext
simp
intros
apply le_antisymm _ (ker_prod_ker_le_ker_coprod f g)
rintros ⟨y, z⟩ h
simp only [mem_ker, mem_prod, coprod_apply] at h ⊢
have : f y ∈ f.range ⊓ g.range
simp only [true_and, mem_range, mem_inf, exists_apply_eq_apply]
use -z
rwa [eq_comm, map_neg, ← sub_eq_zero, sub_neg_eq_add]
rw [hd.eq_bot, mem_bot] at this
rw [this] at h
simpa [this] using h
intros
ext x
have : x ∈ p ⊔ f.ker
simp only [(is_compl_of_proj hf).sup_eq_top, mem_top]
rcases mem_sup'.1 this with ⟨x, y, rfl⟩
simp [hf]
intros
simp only [discr, to_matrix'_smul, matrix.det_smul]
intros
simp [decidable.imp_iff_not_or, or.comm, or.left_comm]
intros
simp [@eq_comm _ a']
intros
subst hα
have : ∀a, f a == f' a
intro a
exact h a a (heq.refl a)
have : β = β'
funext a
exact type_eq_of_heq (this a)
subst this
apply heq_of_eq
funext a
exact eq_of_heq (this a)
intros
rcases exists_pair_ne α with ⟨y, y', h⟩
by_cases hx : x = y
rw ← hx at h
exact ⟨y', h.symm⟩
exact ⟨y, ne.symm hx⟩
intros
intros x y h
induction h with z w a b c
refl
apply relation.refl_trans_gen.head (h b) c
intros
induction h generalizing P
exact refl
case refl_trans_gen.tail : b c hab hbc ih { apply ih, show P b _, from head hbc _ refl, show ∀ a a', r a a' → refl_trans_gen r a' b → P a' _ → P a _, from λ a a' hab hbc, head hab _ }
intros
refine (top_le_iff.1 $ λ s hs, bUnion_of_singleton s ▸ _)
apply measurable_set.bUnion s.countable_encodable
intros x hx
apply measurable_set.of_compl
apply generate_measurable.basic
exact is_closed_singleton.is_open_compl
intros
simp_rw [hu.to_has_basis.liminf_eq_supr_infi]
refine measurable_bsupr _ hu.countable _
exact λ i, measurable_binfi _ (hs i) hf
intros
rw [← funext hC, generate_from_pi_eq h2C]
intros
rw ← pi_univ_Icc
exact pi_Ico_ae_eq_pi_Icc
intros
simp [total_variation, to_jordan_decomposition_zero]
intros
haveI : have_lebesgue_decomposition μ ν := ⟨⟨⟨s, f⟩, hf, hs, hadd⟩⟩
obtain ⟨hmeas, hsing, hadd'⟩ := have_lebesgue_decomposition_spec μ ν
obtain ⟨⟨S, hS₁, hS₂, hS₃⟩, ⟨T, hT₁, hT₂, hT₃⟩⟩ := ⟨hs, hsing⟩
rw hadd' at hadd
have hνinter : ν (S ∩ T)ᶜ = 0
rw set.compl_inter
refine nonpos_iff_eq_zero.1 (le_trans (measure_union_le _ _) _)
rw [hT₃, hS₃, add_zero]
exact le_refl _
have heq : s.restrict (S ∩ T)ᶜ = (μ.singular_part ν).restrict (S ∩ T)ᶜ
ext1 A hA
have hf : ν.with_density f (A ∩ (S ∩ T)ᶜ) = 0
refine with_density_absolutely_continuous ν _ _
rw ← nonpos_iff_eq_zero
exact hνinter ▸ measure_mono (set.inter_subset_right _ _)
have hrn : ν.with_density (μ.rn_deriv ν) (A ∩ (S ∩ T)ᶜ) = 0
refine with_density_absolutely_continuous ν _ _
rw ← nonpos_iff_eq_zero
exact hνinter ▸ measure_mono (set.inter_subset_right _ _)
rw [restrict_apply hA, restrict_apply hA, ← add_zero (s (A ∩ (S ∩ T)ᶜ)), ← hf, ← add_apply, ← hadd, add_apply, hrn, add_zero]
have heq' : ∀ A : set α, measurable_set A → s A = s.restrict (S ∩ T)ᶜ A
intros A hA
have hsinter : s (A ∩ (S ∩ T)) = 0
rw ← nonpos_iff_eq_zero
exact hS₂ ▸ measure_mono (set.subset.trans (set.inter_subset_right _ _) (set.inter_subset_left _ _))
rw [restrict_apply hA, ← add_zero (s (A ∩ (S ∩ T)ᶜ)), ← hsinter, ← measure_union, ← set.inter_union_distrib_left, set.compl_union_self, set.inter_univ]
exact disjoint.inter_left' _ ( disjoint.inter_right' _ disjoint_compl_left)
measurability
ext1 A hA
have hμinter : μ.singular_part ν (A ∩ (S ∩ T)) = 0
rw ← nonpos_iff_eq_zero
exact hT₂ ▸ measure_mono (set.subset.trans (set.inter_subset_right _ _) (set.inter_subset_right _ _))
rw [heq' A hA, heq, ← add_zero ((μ.singular_part ν).restrict (S ∩ T)ᶜ A), ← hμinter, restrict_apply hA, ← measure_union, ← set.inter_union_distrib_left, set.compl_union_self, set.inter_univ]
exact disjoint.inter_left' _ ( disjoint.inter_right' _ disjoint_compl_left)
measurability
intros
convert supr_mem_measurable_le f hf n
ext
simp
intros
rw pair_eq_mk
apply coe_fn_mk
intros
ext1
refine (mem_ℒp.coe_fn_to_Lp _).trans _
refine eventually_eq.trans _ (Lp.coe_fn_add _ _).symm
refine eventually_eq.trans _ (eventually_eq.add (mem_ℒp.coe_fn_to_Lp _).symm (mem_ℒp.coe_fn_to_Lp _).symm)
rw condexp_ind_smul_add
refine (Lp.coe_fn_add _ _).trans (eventually_of_forall (λ a, _))
refl
intros
rw Lp.simple_func.coe_indicator_const
exact condexp_L1_clm_indicator_const_Lp hs hμs x
intros
rw set_integral_congr_ae (hm s hs) ((condexp_ae_eq_condexp_L1 f).mono (λ x hx _, hx))
exact set_integral_condexp_L1 hf hs
intros
suffices h_nnnorm_eq_zero : ∫⁻ x in s, ∥condexp_L2 ℝ hm f x∥₊ ∂μ = 0
rw lintegral_eq_zero_iff at h_nnnorm_eq_zero
refine h_nnnorm_eq_zero.mono (λ x hx, _)
dsimp only at hx
rw pi.zero_apply at hx ⊢
rwa [ennreal.coe_eq_zero, nnnorm_eq_zero] at hx
refine measurable.coe_nnreal_ennreal (measurable.nnnorm _)
rw Lp_meas_coe
exact Lp.measurable _
refine le_antisymm _ (zero_le _)
refine (lintegral_nnnorm_condexp_L2_le hs hμs f).trans (le_of_eq _)
rw lintegral_eq_zero_iff
refine hf.mono (λ x hx, _)
dsimp only
rw hx
simp
exact (Lp.measurable _).nnnorm.coe_nnreal_ennreal
intros
rw [norm_def, norm_def, ennreal.to_real_le_to_real (snorm_ne_top _) (snorm_ne_top _)]
exact snorm_mono_ae h
intros
rw [snorm', ←ennreal.rpow_mul, one_div, inv_mul_cancel, ennreal.rpow_one]
exact (ne_of_lt hq0_lt).symm
intros
rw [snorm', div_zero, ennreal.rpow_zero]
intros
cases le_or_lt 0 q with hq0 hq_neg
exact snorm'_zero (lt_of_le_of_ne hq0 hq0_ne.symm)
simp [snorm', ennreal.rpow_eq_zero_iff, hμ, hq_neg]
intros
refine Lp.mem_Lp_of_ae_bound (∥f∥) _
filter_upwards [f.to_continuous_map.coe_fn_to_ae_eq_fun μ]
intros x hx
convert f.norm_coe_le_norm x
intros
simp [eventually_eq, snorm_ess_sup]
intros
simp_rw ess_sup
exact limsup_trim hm hf
intros
let fs := simple_func.approx_on f hf_meas set.univ 0 (set.mem_univ _)
refine ⟨fs, _, _⟩
have h_fs_Lp : ∀ n, mem_ℒp (fs n) p μ
from simple_func.mem_ℒp_approx_on_univ hf_meas hf
exact λ n, (fs n).measure_support_lt_top_of_mem_ℒp (h_fs_Lp n) hp_ne_zero hp_ne_top
exact λ x, simple_func.tendsto_approx_on hf_meas (set.mem_univ 0) (by simp)
intros
rw L1.norm_eq_integral_norm
refine integral_congr_ae _
apply hf.coe_fn_to_L1.mono
intros a ha
simp [ha]
intros
simp [integral_congr_ae hf, integral_zero]
intros
rw [← indicator_eq_self.2 (@subset_closure _ _ (support f)), integrable_indicator_iff is_closed_closure.measurable_set]
exact hf.integrable_on_compact hfc
apply_instance
intros
simpa [mul_comm] using hf.mul_continuous_on_of_subset hg hs ht hst
intros
rw show (λ x, ∫ t in Icc a x, f t ∂μ) = λ x, ∫ t in Ioc a x, f t ∂μ, by { ext x, exact integral_Icc_eq_integral_Ioc }
exact continuous_on_primitive h_int
intros
simpa [mul_comm] using hf.mul_continuous_on hg
intros
simpa only [sub_eq_add_neg] using integral_comp_add_right f (-d)
intros
convert (monotone_lintegral μ).map_infi2_le f
ext1 a
simp only [infi_apply]
intros
by_cases h : r = 0
simp [h]
apply le_antisymm _ (lintegral_const_mul_le r f)
have rinv : r * r⁻¹ = 1 := ennreal.mul_inv_cancel h hr
have rinv' : r ⁻¹ * r = 1
rw mul_comm
exact rinv
have := lintegral_const_mul_le (r⁻¹) (λx, r * f x)
simp [(mul_assoc _ _ _).symm, rinv'] at this
simpa [(mul_assoc _ _ _).symm, rinv] using mul_le_mul_left' this r
intros
simp [lintegral_const_mul'' _ hg, lintegral_mul_const'' _ hf]
intros
simp [hs, indicator_preimage_of_not_mem _ _ ht, inter_comm]
intros
haveI := function.is_empty f
exact measurable_of_empty f
intros
apply div_pos
norm_cast
apply index_pos ⟨K, h1K, h2K⟩ hU
norm_cast
exact index_pos K₀ hU
intros
let eval : (compacts G → ℝ) → ℝ := λ f, f (K.map _ $ continuous_mul_left g) - f K
have : continuous eval := (continuous_apply (K.map _ _)).sub (continuous_apply K)
rw [← sub_eq_zero]
show chaar K₀ ∈ eval ⁻¹' {(0 : ℝ)}
apply mem_of_subset_of_mem _ (chaar_mem_cl_prehaar K₀ ⟨set.univ, is_open_univ, mem_univ _⟩)
unfold cl_prehaar
rw is_closed.closure_subset_iff
rintro _ ⟨U, ⟨h1U, h2U, h3U⟩, rfl⟩
simp only [mem_singleton_iff, mem_preimage, eval, sub_eq_zero]
apply is_left_invariant_prehaar
rw h2U.interior_eq
exact ⟨1, h3U⟩
apply continuous_iff_is_closed.mp this
exact is_closed_singleton
intros
rw [← hf.hausdorff_measure_image hd, image_preimage_eq_inter_range]
intros
ext t
simp only [mem_inf_principal, mem_ae_iff, restrict_apply_eq_zero' hs, compl_set_of, not_imp, and_comm (_ ∈ s)]
refl
intros
simp only [ae_restrict_eq hs, exists_prop, mem_principal, mem_inf_iff]
exact ⟨_, univ_mem, s, subset.rfl, (univ_inter s).symm⟩
intros
haveI : is_finite_measure ν := begin constructor, rw ← h_univ, apply is_finite_measure.measure_univ_lt_top, end
refine induction_on_inter hA hC (by simp) hμν _ _ hs
intros t h1t h2t
have h1t_ : @measurable_set α m₀ t
from h _ h1t
rw [@measure_compl α m₀ μ t h1t_ (@measure_ne_top α m₀ μ _ t), @measure_compl α m₀ ν t h1t_ (@measure_ne_top α m₀ ν _ t), h_univ, h2t]
intros f h1f h2f h3f
have h2f_ : ∀ (i : ℕ), @measurable_set α m₀ (f i)
from (λ i, h _ (h2f i))
have h_Union : @measurable_set α m₀ (⋃ (i : ℕ), f i)
from @measurable_set.Union α ℕ m₀ _ f h2f_
simp [measure_Union, h_Union, h1f, h3f, h2f_]
intros
refine ⟨_, λ h, h.filter_mono inf_le_left⟩
rintros ⟨s, ⟨t, ht, u, hu, rfl⟩, hμ⟩
suffices : μ t ≤ μ (t ∩ u)
from ⟨t, ht, this.trans_lt hμ⟩
exact measure_mono_ae (mem_of_superset hu (λ x hu ht, ⟨ht, hu⟩))
intros
rw [measure_eq_induced_outer_measure, induced_outer_measure_eq_extend _ _ hs]
exact μ.m_Union
intros
simp [eventually_le_antisymm_iff, ae_le_set, union_diff_right, diff_eq_empty.2 (set.subset_union_right _ _)]
intros
rcases eq_or_lt_of_le h with rfl|hxy
exact le_rfl
exact (f.left_lim_le le_rfl).trans (f.le_left_lim hxy)
intros
intros s hs
rw [neg_apply, neg_eq_zero] at hs
exact h hs
intros
rw [ppow, dif_pos rfl]
intros
rw [mul_comm, coe_moebius_mul_coe_zeta]
ext
simp [nat.mul_eq_one_iff, prod.ext_iff]
intros
simp only [l_series, add_apply]
rw ← tsum_add hf hg
apply congr rfl (funext (λ n, _))
apply _root_.add_div
intros
by_cases h0 : m = 0
subst h0
have hf : f = 0 := arithmetic_function.ext (λ n, complex.abs_eq_zero.1 (le_antisymm (h n) (complex.abs_nonneg _)))
simp [hf]
refine summable_of_norm_bounded (λ (n : ℕ), m / (n ^ z)) _ _
simp_rw [div_eq_mul_inv]
exact (summable_mul_left_iff h0).1 (real.summable_nat_rpow_inv.2 hz)
intro n
have hm : 0 ≤ m := le_trans (complex.abs_nonneg _) (h 0)
cases n
simp [hm, real.zero_rpow (ne_of_gt (lt_trans real.zero_lt_one hz))]
simp only [complex.abs_div, complex.norm_eq_abs]
apply div_le_div hm (h _) (real.rpow_pos_of_pos (nat.cast_pos.2 n.succ_pos) _) (le_of_eq _)
rw [complex.abs_cpow_real, complex.abs_cast_nat]
intros
obtain ⟨k, hk⟩ := @exists_pow_neg_lt p _ ε (by exact_mod_cast hε)
use k
rw (show (p : ℝ) = (p : ℚ), by simp) at hk
exact_mod_cast hk
intros
unfold padic_val_rat
split_ifs
simp *
intros
injection (pell_zd_sub _ h) with h _
repeat {rw ← neg_mul_eq_mul_neg at h}
exact h
intros
by_cases h0 : int.gcd x y = 0
have hx : x = 0
apply int.nat_abs_eq_zero.mp
apply nat.eq_zero_of_gcd_eq_zero_left h0
have hy : y = 0
apply int.nat_abs_eq_zero.mp
apply nat.eq_zero_of_gcd_eq_zero_right h0
use [0, 1, 0]
norm_num [hx, hy]
apply h.is_classified_of_normalize_is_primitive_classified
apply h.normalize.is_primitive_classified_of_coprime
apply int.gcd_div_gcd_div_gcd (nat.pos_of_ne_zero h0)
intros
simp [ext]
intros
simp [bit1]
intros
rw disjoint_iff at w
rw [←w, right_eq_inf]
rwa sup_eq_left at h
intros
exact is_least_singleton.union hs
intros
ext
refl
intros
simp only [disjoint_iff, supr_inf_eq, supr_eq_bot]
intros
simpa only [range_comp, subtype.range_coe, supr_subtype'] using @is_lub_supr α s _ (f ∘ coe)
intros
simp
intros
simp
intros
apply tendsto_at_top.2 (λb, _)
obtain ⟨n : ℕ, hn : 1 ≤ n • r⟩ := archimedean.arch 1 hr
have hn' : 1 ≤ (n : R) * r
rwa nsmul_eq_mul at hn
filter_upwards [tendsto_at_top.1 hf (max b 0 * n)]
assume x hx
calc b ≤ max b 0 * 1 : by { rw [mul_one], exact le_max_left _ _ } ... ≤ max b 0 * (n * r) : mul_le_mul_of_nonneg_left hn' (le_max_right _ _) ... = (max b 0 * n) * r : by rw [mul_assoc] ... ≤ f x * r : mul_le_mul_of_nonneg_right hx (le_of_lt hr)
intros
apply le_antisymm
intros U U_in
rcases B.mem_filter_iff.mp U_in with ⟨V, V_in, h⟩
exact generate_sets.superset (generate_sets.basic V_in) h
rw sets_iff_generate
apply mem_filter_of_mem
intros
rw inf_comm
exact inf_ne_bot_iff_frequently_left
intros
simp only [tendsto, le_pure_iff, mem_map', mem_singleton_iff, filter.eventually]
intros
rw [filter.prod, comap_infi, inf_infi]
simp only [filter.prod, eq_self_iff_true]
intros
simp [upper_bounds, gc _ _]
intros
rw [sup_eq_right, ←inf_eq_left]
intros
dsimp [continuous] at *
intro
rw [hfc,hgc,chain.map_comp]
intros
induction n with n ih
simp
dsimp [partial_sups] at ih ⊢
simp_rw @finset.range_succ n.succ
rw [ih, finset.sup'_insert, sup_comm]
intros
ext
refl
intros
simp only [(Δ), sdiff_eq]
intros
rw [sdiff_symm_diff, sdiff_sup, sup_comm]
intros
classical
revert hf
apply f.induction_on
intro h
simp [set.is_pwo_empty.is_wf]
intros s f sf hf hsf
rw finset.sup_insert
exact (hsf s (finset.mem_insert_self _ _)).union (hf (λ s' s'f, hsf _ (finset.mem_insert_of_mem s'f)))
intros
rw [← algebra_map_eq, ← aeval_def, aeval_eq, mk_self]
intros
rw [is_artinian_iff_well_founded]
exact (well_founded.monotone_chain_condition (order_dual (submodule R M))).symm
intros
refine ⟨λ h, _, algebra.finite_type.of_finite_presentation⟩
obtain ⟨n, f, hf⟩ := algebra.finite_type.iff_quotient_mv_polynomial''.1 h
refine ⟨n, f, hf, _⟩
have hnoet : is_noetherian_ring (mv_polynomial (fin n) R) := by apply_instance
replace hnoet := (is_noetherian_ring_iff.1 hnoet).noetherian
exact hnoet f.to_ring_hom.ker
intros
letI := f.to_algebra
exact module.finite.of_surjective (algebra.of_id A B).to_linear_map hf
intros
intros x hx
convert submodule.zero_mem _
simpa using hx
intros
rw [← add_zero a, single_mul_coeff_add, add_zero]
intros
contrapose! h
rw ← C_zero at h
exact C_injective h
intros
by_cases h : r = 0
rw [h, C_zero, order_zero]
exact order_single h
intros
rw [radical_eq_Inf, radical_eq_Inf]
have : ∀ J ∈ {J : ideal R | I ≤ J ∧ J.is_prime}, f.ker ≤ J := λ J hJ, le_trans h hJ.left
convert map_Inf hf this
refine funext (λ j, propext ⟨_, _⟩)
rintros ⟨hj, hj'⟩
haveI : j.is_prime := hj'
exact ⟨comap f j, ⟨⟨map_le_iff_le_comap.1 hj, comap_is_prime f j⟩, map_comap_of_surjective f hf j⟩⟩
rintro ⟨J, ⟨hJ, hJ'⟩⟩
haveI : J.is_prime := hJ.right
refine ⟨hJ' ▸ map_mono hJ.left, hJ' ▸ map_is_prime_of_surjective hf (le_trans h hJ.left)⟩
intros
induction n with n ih
simp [set.singleton_one]
simp only [pow_succ, ih, span_singleton_mul_span_singleton]
intros
apply unique_factorization_monoid.induction_on_prime
exact h₀
intros n h
rw nat.is_unit_iff.1 h
exact h₁
intros a p _ hp ha
exact h p a (nat.prime_iff.2 hp) ha
intros
haveI : decidable_eq R := classical.dec_eq _
refine le_trans _ (nth_roots n (f g₀)).to_finset_card_le
apply card_le_card_of_inj_on f
intros g hg
rw [sep_def, mem_filter] at hg
rw [multiset.mem_to_finset, mem_nth_roots hn, ← f.map_pow, hg.2]
intros
apply hf
assumption
intros
letI : is_fraction_ring (integral_closure R L) L := is_fraction_ring_of_finite_extension K L
exact (integral_closure_eq_bot_iff L).mp integral_closure_idem
intros
rw [is_noetherian_ring_iff, is_noetherian_iff_well_founded] at h ⊢
exact order_embedding.well_founded ((is_localization.order_embedding M S).dual) h
intros
rw [enat.get_eq_iff_eq_coe, eq_coe_iff, pow_zero]
simpa [is_unit_iff_dvd_one.symm] using not_unit_of_finite ha
intros
rcases lt_trichotomy (multiplicity p a) (multiplicity p b) with hab|hab|hab
rw [add_comm, multiplicity_add_of_gt hab, min_eq_left]
exact le_of_lt hab
contradiction
rw [multiplicity_add_of_gt hab, min_eq_right]
exact le_of_lt hab
intros
refine le_antisymm _ (submodule.smul_le.2 (λ _ _ _, submodule.smul_mem _ _))
intros n hn
cases submodule.exists_sub_one_mem_and_smul_eq_zero_of_fg_of_le_smul I N hN hIN with r hr
cases exists_mul_sub_mem_of_sub_one_mem_jacobson r (hIjac hr.1) with s hs
have : n = (-(r * s - 1) • n)
rw [neg_sub, sub_smul, mul_comm, mul_smul, hr.2 n hn, one_smul, smul_zero, sub_zero]
rw this
exact submodule.smul_mem_smul (submodule.neg_mem _ hs) hn
intros
obtain ⟨n, hn⟩ := h
use n
rw [neg_pow, hn, mul_zero]
intros
intros v hv
rcases submodule.mem_sup.1 hv with ⟨x, hx, y, hy, hxy⟩
have h_eval_x : aeval f (p * q) x = 0
rw [mul_comm, aeval_mul, linear_map.mul_apply, linear_map.mem_ker.1 hx, linear_map.map_zero]
have h_eval_y : aeval f (p * q) y = 0
rw [aeval_mul, linear_map.mul_apply, linear_map.mem_ker.1 hy, linear_map.map_zero]
rw [linear_map.mem_ker, ←hxy, linear_map.map_add, h_eval_x, h_eval_y, add_zero]
intros
simp only [function.comp_app, ring_hom.coe_comp, ideal.quotient.eq_zero_iff_mem]
exact ideal.mem_map_of_mem _ hi
intros
rw [bernstein_polynomial.iterate_derivative_at_1 _ _ _ h, ne.def, neg_one_pow_mul_eq_zero_iff, ←nat.cast_succ, ←pochhammer_eval_cast, ←nat.cast_zero, nat.cast_inj]
exact (pochhammer_pos _ _ (nat.succ_pos ν)).ne'
intros
rw [← one_mul p.prim_part, ← C_1, ← hp.content_eq_one, ← p.eq_C_content_mul_prim_part]
intros
rw content
by_cases h0 : r = 0
simp [h0]
have h : (C r).support = {0} := support_monomial _ _ h0
simp [h]
intros
simp only [cyclotomic', finset.prod_singleton, ring_hom.map_one, is_primitive_root.primitive_roots_one]
intros
rw [polynomial.aeval_def, polynomial.aeval_def, polynomial.eval₂_map, algebra_map_eq R S A]
intros
conv_rhs { rw ← span_singleton_generator S }
exact subset_span (mem_singleton _)
intros
apply is_unit_of_mul_eq_one ζ (ζ ^ (k - 1))
rw [← pow_succ, nat.sub_add_cancel h0, h.pow_eq_one]
intros
apply finset.eq_singleton_iff_unique_mem.2
split
simp only [is_primitive_root.one_right_iff, mem_primitive_roots zero_lt_one]
intros x hx
rw [mem_primitive_roots zero_lt_one, is_primitive_root.one_right_iff] at hx
exact hx
intros
obtain ⟨q, hq, hpq⟩ := exists_mem_factors_of_dvd ha0 hp hd
apply multiset.mem_pmap.mpr
use q
use hq
exact subtype.eq (eq.symm (mk_eq_mk_iff_associated.mpr hpq))
intros
rw factors_mk _ ha0
exact mem_factor_set_some.mpr (mem_factors'_of_dvd ha0 hp hd)
intros
ext ⟨⟩
{ rw zero_coeff, refl }
rw zero_coeff
refl
intros
ext ⟨-, -⟩
exact f.map_zero
refl
intros
split
rintro ⟨f⟩
refine ⟨f $ sum.inl ⟨⟩, f $ sum.inr ⟨⟩, _⟩
intro h
cases f.2 h
rintro ⟨x, y, h⟩
by_contra h'
rw [not_le, ←nat.cast_two, nat_succ, lt_succ, nat.cast_one, le_one_iff_subsingleton] at h'
apply h
exactI subsingleton.elim _ _
intros
rw [← not_le, succ_le, not_lt]
intros
refine quot.induction_on c (λ α, _) (lt_succ_self c)
refine quot.induction_on (succ (quot.mk setoid.r α)) (λ β h, _)
cases h.left with f
have : ¬ surjective f := λ hn, ne_of_lt h (quotient.sound ⟨equiv.of_bijective f ⟨f.injective, hn⟩⟩)
cases not_forall.1 this with b nex
refine ⟨⟨sum.rec (by exact f) _, _⟩⟩
exact λ _, b
intros a b h
rcases a with a|⟨⟨⟨⟩⟩⟩
rcases b with b|⟨⟨⟨⟩⟩⟩
rw f.injective h
exact nex.elim ⟨_, h⟩
rcases b with b|⟨⟨⟨⟩⟩⟩
exact nex.elim ⟨_, h.symm⟩
refl
intros
dsimp [sup]
cases min_eq _ _ with c hc
rw hc
exact c.2 i
intros
simp [bit0, add_lt_omega_iff]
intros
cases x
cases y
refl
intros
split
intro hi
unfold1 impartial_aux at hi
exact hi
intro hi
unfold1 impartial_aux
exact hi
intros
rw subsingleton.elim f (principal_seg.equiv_lt e g)
refl
intros
cases x with xl xr xL xR
exact o.2.2 j
intros
simp [prl, prr, prt]
intros
cases x
cases y
refl
intros
cases x
cases y
refl
intros
simp *
intros
rw normalize_fin
norm_num
intros
simpa [normalize_fin_lt, ← e] using h
intros
rwa [← h₁, ← mul_assoc, div_mul_cancel _ h₀]
intros
rw [prl, prr, prt]
intros
rw [← H, ← h₂, ← h₁, ← h₃, ← h₄]
simp [horner, mul_add, mul_comm, mul_left_comm, mul_assoc]
intros
simp [horner, mul_comm]
intros
induction xs
apply h
unfold_wf
simp only [list.sizeof, add_lt_add_iff_left]
exact xs_ih
intros
rcases hs with ⟨S, Sopen, Scount, rfl⟩
rcases ht with ⟨T, Topen, Tcount, rfl⟩
rw [sInter_union_sInter]
apply is_Gδ_bInter_of_open (Scount.prod Tcount)
rintros ⟨a, b⟩ hab
exact is_open.union (Sopen a hab.1) (Topen b hab.2)
intros
rw [dense_range, ← compl_infty]
exact dense_compl_singleton _
intros
simpa [(hf'.has_sum.sigma hf).unique ha] using hf'.has_sum
intros
by_cases hP : P
simp [hP]
simp [hP]
intros
convert hf.update b 0 using 1
ext n
rw function.update_apply
rw [sub_add_eq_add_sub, zero_add]
intros
rw [←has_sum_zero_iff, hf.has_sum_iff]
intros
ext
simp
intros
simp only [ext_iff, pi_apply, function.funext_iff]
exact forall_swap
intros
refine tendsto_at_top_mono' _ _ (hf.at_top_mul_const (half_pos hC))
filter_upwards [hg.eventually (lt_mem_nhds (half_lt_self hC)), hf.eventually (eventually_ge_at_top 0)]
exact λ x hg hf, mul_le_mul_of_nonneg_left hg.le hf
intros
simpa only [mul_comm] using hg.at_bot_mul hC hf
intros
rw [← map_coe_Iio_at_top, tendsto_map'_iff]
intros
rw image_preimage_eq_inter_range
exact hf.open_subset_closure_inter hs
intros
rw [← is_open_compl_iff, compl_univ]
exact is_open_empty
intros
rw subset.antisymm subset_closure h
exact is_closed_closure
intros
rw [frontier, hs.interior_eq]
intros
simp [closure_eq_cluster_pts, cluster_pt, ← exists_ultrafilter_iff, and.comm]
intros
rw [nhds_within, principal_singleton, inf_eq_right.2 (pure_le_nhds a)]
intros
rw [di.nhds_eq_comap a, ((nhds_basis_opens _).comap _).mem_iff] at hs
rcases hs with ⟨U, ⟨haU, hUo⟩, sub : i ⁻¹' U ⊆ s⟩
refine mem_of_superset (hUo.mem_nhds haU) _
calc U ⊆ closure (i '' (i ⁻¹' U)) : di.dense.subset_closure_image_preimage_of_is_open hUo ... ⊆ closure (i '' s) : closure_mono (image_subset i sub)
intros
ext
refl
intros
convert ←hf.closed_iff_image_closed.symm
rwa [image_preimage_eq_inter_range, inter_eq_self_of_subset_left]
intros
rw [diam, ediam_of_unbounded h, ennreal.top_to_real]
intros
rw [← not_nonempty_iff_eq_empty, nonempty_ball, not_lt]
intros
convert metric.emetric_ball
simp
intros
refine or_iff_not_imp_right.2 (λ h, edist_le_zero.1 _)
simpa only [hx.eq, edist_self, add_zero, ennreal.zero_div] using hf.edist_le_of_fixed_point h hy
intros
refine ⟨λ H ε hε, H _ (edist_mem_uniformity hε), λ H u hu x hx, _⟩
rcases mem_uniformity_edist.1 hu with ⟨ε, εpos, hε⟩
rcases H ε εpos x hx with ⟨t, ht, Ht⟩
exact ⟨t, ht, Ht.mono (λ n hs x hx, hε (hs x hx))⟩
intros
rw ← image_univ
refine dimH_image_le_of_locally_lipschitz_on (λ x _, _)
simpa only [exists_prop, nhds_within_univ] using hf x
intros
rw [← e.dimH_preimage univ, preimage_univ]
intros
simp only [Hausdorff_edist, sup_le_iff, supr_le_iff]
exact ⟨H1, H2⟩
intros
simp [inf_dist, inf_edist_image hΦ]
intros
intros x hx y hy
rw [ennreal.coe_mul, mul_comm rg, nnreal.coe_mul, ennreal.rpow_mul, mul_assoc, ← ennreal.coe_rpow_of_nonneg _ rg.coe_nonneg, ← ennreal.mul_rpow_of_nonneg _ _ rg.coe_nonneg]
exact hg.edist_le_of_le (hst hx) (hst hy) (hf.edist_le hx hy)
intros
assume x y
rw [ennreal.coe_mono.map_max, prod.edist_eq, ennreal.max_mul]
exact max_le_max (hf x y) (hg x y)
intros
rcases ⟨h, h'⟩ with ⟨⟨r, r0, hr⟩, ⟨r', r0', hr'⟩⟩
refine ⟨min r r', _, λ x hx y hy, hx.elim _ _⟩
rw [← pos_iff_ne_zero] at r0 r0' ⊢
exact lt_min r0 r0'
exact λ hx, (min_le_left _ _).trans (hr _ hx _ hy)
exact λ hx, (min_le_right _ _).trans (hr' _ hx _ hy)
intros
rw induced_generate_from_eq
apply le_generate_from
simp only [mem_image, and_imp, forall_apply_eq_imp_iff₂, exists_imp_distrib]
exact h
intros
simp only [mem_nhds_iff, is_open_induced_iff, exists_prop, set.mem_set_of_eq]
split
rintros ⟨u, usub, ⟨v, openv, ueq⟩, au⟩
exact ⟨v, ⟨v, set.subset.refl v, openv, by rwa ←ueq at au⟩, by rw ueq; exact usub⟩
rintros ⟨u, ⟨v, vsubu, openv, amem⟩, finvsub⟩
exact ⟨f ⁻¹' v, set.subset.trans (set.preimage_mono vsubu) finvsub, ⟨⟨v, openv, rfl⟩, amem⟩⟩
intros
simp only [← lower_semicontinuous_within_at_univ_iff] at hf ⊢
exact hg.comp_lower_semicontinuous_within_at hf gmon
intros
simp [upper_semicontinuous_on, upper_semicontinuous, upper_semicontinuous_within_at_univ_iff]
intros
rw is_open_iff_ultrafilter
refine ⟨λ h F hF, h F.Lim hF F F.le_nhds_Lim, _⟩
intros cond x hx f h
rw [← (ultrafilter.Lim_eq_iff_le_nhds.2 h)] at hx
exact cond _ hx
intros
wlog hle : v₁ ≤ v₂ := hc.total_of_refl h₁ h₂ using [v₁ v₂, v₂ v₁]
exact hle.2 _ hi₁
intros
rw uniform_space.mem_nhds_iff
split
rintros ⟨V, V_in, V_sub⟩
use [symmetrize_rel V, symmetrize_mem_uniformity V_in, symmetric_symmetrize_rel V]
exact subset.trans (ball_mono (symmetrize_rel_subset_self V) x) V_sub
rintros ⟨V, V_in, V_symm, V_sub⟩
exact ⟨V, V_in, V_sub⟩
intros
simp_rw [mem_closure_iff_nhds, uniform_space.mem_nhds_iff]
split
intros h V V_in
exact h (ball x V) ⟨V, V_in, subset.refl _⟩
rintros h t ⟨V, V_in, Vt⟩
exact nonempty.mono (inter_subset_inter_left s Vt) (h V_in)
intros
simp [tendsto_uniformly_on, tendsto_uniformly]
intros
rw topological_fiber_bundle.trivialization.mem_source
apply mem_base_set_trivialization_at
