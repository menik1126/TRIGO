intros
rw [‚Üê stream.eta (iterate f a)]
rw tail_iterate
refl
intros
cases v
reflexivity
intros
cases b
simp
simp
intros
cases b
simp
simp
intros
cases b
simp
simp
intros
have h := int.neg_lt_neg h
rwa int.neg_neg at h
intros
have h := int.add_le_add_right h (-b)
rwa [int.add_comm b c, int.add_neg_cancel_right] at h
intros
rw int.add_comm at h
exact int.le_add_of_sub_right_le h
intros
have h := int.add_lt_add_right h b
rwa [int.sub_add_cancel, int.add_comm] at h
intros
simp [min_le_left]
intros
induction n
simp [*]
simp [*]
intros
unfold bitwise
apply bit_cases_on m
intros
rw [binary_rec_eq, binary_rec_zero]
exact bitwise_bit_aux h
intros
simp [gcd]
intros
rw mod_def
have h : ¬¨ (0 < 0 ‚àß 0 ‚â§ a)
simp [lt_irrefl]
simp [if_neg, h]
intros
rw mod_def
have h : ¬¨(0 < b ‚àß b ‚â§ 0)
intro hn
cases hn with l r
exact absurd (lt_of_lt_of_le l r) (lt_irrefl 0)
simp [if_neg, h]
intros
ext
refl
intros
ext
refl
intros
ext
simp
intros
ext
simp only [lmul_left_apply, linear_map.comp_apply, mul_assoc]
intros
conv_lhs {rw ‚Üê span_eq M}
change span _ _ * span _ _ = _
rw [span_mul_span]
apply le_antisymm
rw span_le
rintros _ ‚ü®b, m, hb, hm, rfl‚ü©
rw [set_like.mem_coe, mem_map, set.mem_singleton_iff.mp hb]
exact ‚ü®m, hm, rfl‚ü©
rintros _ ‚ü®m, hm, rfl‚ü©
exact subset_span ‚ü®a, m, set.mem_singleton a, hm, rfl‚ü©
intros
ext x
simp only [mem_map, mem_div_iff_forall_mul_mem]
split
rintro ‚ü®x, hx, rfl‚ü© _ ‚ü®y, hy, rfl‚ü©
exact ‚ü®x * y, hx _ hy, h.map_mul x y‚ü©
rintro hx
refine ‚ü®h.symm x, Œª z hz, _, h.apply_symm_apply x‚ü©
obtain ‚ü®xz, xz_mem, hxz‚ü© := hx (h z) ‚ü®z, hz, rfl‚ü©
convert xz_mem
apply h.injective
erw [h.map_mul, h.apply_symm_apply, hxz]
intros
apply le_antisymm
rw submodule.mul_le
intros y hy z hz
exact mul_mem S hy hz
intros x hx1
rw ‚Üê mul_one x
exact submodule.mul_mem_mul hx1 (one_mem S)
intros
simp [set.ext_iff, algebra.mem_bot]
intros
haveI := classical.dec
refine or_iff_not_imp_right.2 (Œª H, _)
simp [h, irreducible_iff] at H ‚ä¢
refine Œª a b h, classical.by_contradiction $ Œª o, _
simp [not_or_distrib] at o
exact H _ o.1 _ o.2 h.symm
intros
rw [g.map_finprod]
simp only [g.map_finprod_Prop]
simpa only [finprod_eq_mul_indicator_apply, mul_support_mul_indicator]
intros
ext1
apply w
intros
ext
refl
intros
simp
intros
rw mul_comm
exact h.mul_right _
intros
split
rintro rfl
exact hnd (dvd_zero _)
rcases hd with ‚ü®c, rfl‚ü©
refine ‚ü®c, _, rfl‚ü©
rintro ‚ü®u, rfl‚ü©
simpa using hnd
intros
unfold xgcd_aux
exact if_pos rfl
intros
rw neg_inv
intros
classical
apply s.induction_on
simp
intros b t hbt h
rw [gcd_insert, gcd_insert, h, ‚Üê gcd_mul_right]
apply ((normalize_associated a).mul_left _).gcd_eq_right
intros
rw [h.eq, mul_inv_cancel_right]
intros
cases m‚ÇÅ with mul‚ÇÅ _ one‚ÇÅ one_mul‚ÇÅ mul_one‚ÇÅ npow‚ÇÅ npow_zero‚ÇÅ npow_succ‚ÇÅ
cases m‚ÇÇ with mul‚ÇÇ _ one‚ÇÇ one_mul‚ÇÇ mul_one‚ÇÇ npow‚ÇÇ npow_zero‚ÇÇ npow_succ‚ÇÇ
change mul‚ÇÅ = mul‚ÇÇ at h_mul
subst h_mul
have h_one : one‚ÇÅ = one‚ÇÇ
rw ‚Üêone_mul‚ÇÇ one‚ÇÅ
exact mul_one‚ÇÅ one‚ÇÇ
subst h_one
have h_npow : npow‚ÇÅ = npow‚ÇÇ
ext n
induction n with d hd
rw [npow_zero‚ÇÅ, npow_zero‚ÇÇ]
rw [npow_succ‚ÇÅ, npow_succ‚ÇÇ, hd]
subst h_npow
intros
ext
simp only [function.comp_app, inv_apply, coe_comp]
intros
ext a
exact add_monoid_hom.congr_fun h a
intros
rwa [‚Üê add_eq_zero_iff_eq_neg, ‚Üê sub_eq_zero, or_comm, ‚Üê mul_eq_zero, ‚Üê sq_sub_sq a b, sub_eq_zero]
intros
ring
intros
rw [nsmul_eq_mul', nsmul_eq_mul', mul_assoc]
intros
simp [h]
intros
simp
intros
rw [‚Üê divp_mk0 _ hc, ‚Üê divp_mk0 _ hc, divp_left_inj]
intros
split
intro h
rw [pos_iff_ne_zero]
rintro rfl
simpa using h
intro h
exact zero_pow' n h.ne.symm
intros
rw [‚Üêcancel_epi (image_to_kernel (0 : A ‚ü∂ B) g exact.w), ‚Üêcancel_epi (factor_thru_image_subobject (0 : A ‚ü∂ B))]
simp
intros
change ite (2 = 1 + 1) (d‚ÇÅ ‚â´ ùüô X‚ÇÇ) 0 = d‚ÇÅ
rw [if_pos rfl, category.comp_id]
intros
dunfold cycles_map
simp [subobject.factor_thru_right]
intros
simp [homology.œÄ, homology.desc]
intros
simp only [indicator]
split_ifs
refl
rw [mul_zero]
intros
by_cases hx : x ‚àà ‚ãÉ i, s i
rw [mul_indicator_of_mem hx]
rw [mem_Union] at hx
refine le_antisymm _ (supr_le $ Œª i, mul_indicator_le_self' (Œª x hx, h1 ‚ñ∏ bot_le) x)
rcases hx with ‚ü®i, hi‚ü©
exact le_supr_of_le i (ge_of_eq $ mul_indicator_of_mem hi _)
rw [mul_indicator_of_not_mem hx]
simp only [mem_Union, not_exists] at hx
simp [hx, ‚Üê h1]
intros
simp [mul_assoc]
intros
conv_rhs { congr, skip, rw ‚Üê I.incl_ideal_range, }
rw comap_bracket_eq
simp only [ker_incl, sup_bot_eq]
exact I.incl_is_ideal_morphism
intros
split
introsI h
exact e.symm.injective.lie_algebra_is_nilpotent
introsI h
exact e.injective.lie_algebra_is_nilpotent
intros
ext a b
simp [lie_ring.of_associative_ring_bracket]
intros
rw [nsmul_eq_mul, mul_one]
intros
ext m
exact linear_map.congr_fun h m
intros
simp only [lift_apply', algebra.smul_def]
intros
ext
refl
intros
unfold cmp cmp_using
by_cases a < b
by_cases h‚ÇÇ : b < a
simp [h, h‚ÇÇ, gt, ordering.swap]
exact lt_asymm h h‚ÇÇ
simp [h, h‚ÇÇ, gt, ordering.swap]
by_cases h‚ÇÇ : b < a
simp [h, h‚ÇÇ, gt, ordering.swap]
simp [h, h‚ÇÇ, gt, ordering.swap]
intros
rw cmp_eq_eq_iff
intros
rw [mul_comm, inv_mul_lt_iff' h]
intros
rw [div_lt_iff_of_neg hb, one_mul]
intros
simpa using inv_le ha hb
intros
rw [mul_comm c, mul_inv_lt_inv_mul_iff, mul_comm]
intros
rw [‚Üê mul_lt_mul_iff_right b, one_mul, div_eq_mul_inv, inv_mul_cancel_right]
intros
haveI := @linear_order.decidable_le Œ± _
exact ‚ü®lt_imp_lt_of_le_imp_le $ Œª h', decidable.mul_le_mul_of_nonneg_left h' h.le, Œª h', mul_lt_mul_of_pos_left h' h‚ü©
intros
rw [‚Üêright_inv x y, ‚Üêself_distrib]
intros
rw [add_comm, self_add_conj]
intros
rw [‚Üêi_mul_j, mul_assoc, j_mul_j, mul_smul_comm, mul_one]
intros
rw [nontrivial_iff, not_iff_comm, is_left_regular_zero_iff_subsingleton, subsingleton_iff]
push_neg
exact iff.rfl
intros
rw [‚Üê ring_hom.comp_apply, comp_eq‚ÇÇ]
simp
intros
simp [vanishing_ideal]
intros
split
contrapose!
intro h
apply set.ne_empty_iff_nonempty.mpr
rcases ideal.exists_le_maximal I h with ‚ü®M, hM, hIM‚ü©
exact ‚ü®‚ü®M, hM.is_prime‚ü©, hIM‚ü©
rintro rfl
apply zero_locus_empty_of_one_mem
trivial
intros
simp only [zero_locus_Union]
intros
dsimp [Œ¥, œÉ]
simp only [‚ÜêX.map_comp, simplex_category.Œ¥_comp_œÉ_of_gt H]
intros
obtain ‚ü®a, ha : a ‚àà Ioo (0 : ‚Ñù) 1, C, hC : 0 < C, hp‚ü© := p.norm_mul_pow_le_mul_pow_of_lt_radius h
exact summable_of_nonneg_of_le (Œª n, mul_nonneg (norm_nonneg _) (pow_nonneg r.coe_nonneg _)) hp ((summable_geometric_of_lt_1 ha.1.le ha.2).mul_left _)
intros
rw is_open_iff_mem_nhds
rintro x ‚ü®p, r, hr‚ü©
exact mem_of_superset (emetric.ball_mem_nhds _ hr.r_pos) (Œª y hy, hr.analytic_at_of_mem hy)
intros
rw is_O
exact ‚ü®c, h‚ü©
intros
unfold is_O
exact exists_congr (Œª C, e.is_O_with_congr hb)
intros
unfold is_O
exact exists_congr (Œª C, e.is_O_with_congr)
intros
simp only [is_O_with, norm_neg]
intros
simpa only [sub_eq_add_neg] using h‚ÇÅ.add h‚ÇÇ.neg_left
intros
rw is_O_with
intros
have := (has_fderiv_within_at.mul' hc hd).has_deriv_within_at
rwa [continuous_linear_map.add_apply, continuous_linear_map.smul_apply, continuous_linear_map.smul_right_apply, continuous_linear_map.smul_right_apply, continuous_linear_map.smul_right_apply, continuous_linear_map.one_apply, one_smul, one_smul, add_comm] at this
intros
simp only [div_eq_mul_inv, deriv_mul_const_field]
intros
rw differentiable_at.deriv_within p.differentiable_at hxs
exact p.deriv
intros
rw [‚Üê Ici_diff_left, has_deriv_within_at_diff_singleton]
intros
simp only [has_deriv_within_at, nhds_within_union]
exact hs.join ht
intros
simp [deriv]
intros
simpa using (hc.smul hf).has_strict_deriv_at
intros
simpa using h.neg.has_deriv_at_filter
intros
simpa only [sub_eq_add_neg] using hf.add hg.neg
intros
refine ‚ü®Œª H, _, Œª H, iso.has_strict_fderiv_at.comp x H‚ü©
convert iso.symm.has_strict_fderiv_at.comp x H
ext z
apply (iso.symm_apply_apply _).symm
ext z
apply (iso.symm_apply_apply _).symm
intros
refine le_of_forall_pos_le_add (Œª Œµ Œµ0, op_norm_le_of_nhds_zero _ _)
exact add_nonneg C.coe_nonneg Œµ0.le
have hs' := hs
rw [‚Üê map_add_left_nhds_zero x‚ÇÄ, mem_map] at hs'
filter_upwards [is_o_iff.1 (has_fderiv_at_iff_is_o_nhds_zero.1 hf) Œµ0, hs']
intros y hy hys
have := hlip.norm_sub_le hys (mem_of_mem_nhds hs)
rw add_sub_cancel' at this
calc ‚à•f' y‚à• ‚â§ ‚à•f (x‚ÇÄ + y) - f x‚ÇÄ‚à• + ‚à•f (x‚ÇÄ + y) - f x‚ÇÄ - f' y‚à• : norm_le_insert _ _ ... ‚â§ C * ‚à•y‚à• + Œµ * ‚à•y‚à• : add_le_add this hy ... = (C + Œµ) * ‚à•y‚à• : (add_mul _ _ _).symm
intros
simp [has_fderiv_within_at, nhds_within_restrict' s h]
intros
ext x
refl
intros
ext y
apply (h.on univ).has_fderiv_within_at_eq_zero hf.has_fderiv_within_at
rw pos_tangent_cone_at_univ
apply mem_univ
rw pos_tangent_cone_at_univ
apply mem_univ
intros
ext x
suffices : f x ‚â† 0 ‚Üî dist x c < f.R
simpa [mem_support]
cases lt_or_le (dist x c) f.R with hx hx
simp [hx, (f.pos_of_mem_ball hx).ne']
simp [hx.not_lt, f.zero_of_le_dist hx]
intros
rw [f.support_eq, euclidean.closure_ball _ f.R_pos]
intros
rintros _ ‚ü®v, ‚ü®c, d, hd, hc, hy‚ü©, rfl‚ü©
have : ‚àÄn, ‚àÉd', y + d' ‚àà t ‚àß ‚à•c n ‚Ä¢ d'‚à• < ((1:‚Ñù)/2)^n
assume n
rcases mem_closure_iff_nhds.1 ht _ (eventually_nhds_norm_smul_sub_lt (c n) y (pow_pos one_half_pos n)) with ‚ü®z, hz, hzt‚ü©
exact ‚ü®z - y, by simpa using hzt, by simpa using hz‚ü©
choose d' hd' using this
refine ‚ü®c, Œªn, (d n, d' n), _, hc, _‚ü©
filter_upwards [hd]
assume n hn
simp [hn, (hd' n).1]
apply tendsto.prod_mk_nhds hy _
refine squeeze_zero_norm (Œªn, (hd' n).2.le) _
exact tendsto_pow_at_top_nhds_0_of_lt_1 one_half_pos.le one_half_lt_one
intros
rintros _ ‚ü®w, ‚ü®c, d, hd, hc, hy‚ü©, rfl‚ü©
have : ‚àÄn, ‚àÉd', x + d' ‚àà s ‚àß ‚à•c n ‚Ä¢ d'‚à• < ((1:‚Ñù)/2)^n
assume n
rcases mem_closure_iff_nhds.1 hs _ (eventually_nhds_norm_smul_sub_lt (c n) x (pow_pos one_half_pos n)) with ‚ü®z, hz, hzs‚ü©
exact ‚ü®z - x, by simpa using hzs, by simpa using hz‚ü©
choose d' hd' using this
refine ‚ü®c, Œªn, (d' n, d n), _, hc, _‚ü©
filter_upwards [hd]
assume n hn
simp [hn, (hd' n).1]
apply tendsto.prod_mk_nhds _ hy
refine squeeze_zero_norm (Œªn, (hd' n).2.le) _
exact tendsto_pow_at_top_nhds_0_of_lt_1 one_half_pos.le one_half_lt_one
intros
classical
rw [‚Üê set.univ_pi_piecewise]
refine unique_diff_within_at.univ_pi _ _ _ _ (Œª i, _)
by_cases hi : i ‚àà I
simp [*, unique_diff_within_at_univ]
simp [*, unique_diff_within_at_univ]
intros
simp [has_ftaylor_series_up_to_on_succ_iff_right, has_ftaylor_series_up_to_on_univ_iff.symm, -add_comm, -with_zero.coe_add]
intros
simpa [nhds_within_univ] using h.eventually
intros
split
assume H
use ftaylor_series_within ùïú f univ
rw ‚Üê has_ftaylor_series_up_to_on_univ_iff
exact H.ftaylor_series_within unique_diff_on_univ
rintros ‚ü®p, hp‚ü© x hx m hm
exact ‚ü®univ, filter.univ_sets _, p, (hp.has_ftaylor_series_up_to_on univ).of_le hm‚ü©
intros
ext m
rw iterated_fderiv_succ_apply_right
refl
intros
simp [times_cont_diff_on_univ.symm, differentiable_on_univ.symm, fderiv_within_univ.symm, - fderiv_within_univ, times_cont_diff_on_succ_iff_fderiv_within unique_diff_on_univ, -with_zero.coe_add, -add_comm]
intros
rw [subsingleton.elim f (Œª _, 0)]
exact times_cont_diff_at_const
intros
rw [subsingleton.elim f (Œª _, 0)]
exact times_cont_diff_on_const
intros
simpa only [div_eq_mul_inv] using hf.mul times_cont_diff_within_at_const
intros
rw times_cont_diff_at at *
convert hf.prod_map hg
simp only [univ_prod_univ]
intros
rw coe_inv_circle_eq_conj
apply eq_inv_of_mul_right_eq_one
rw [mul_comm, ‚Üê complex.norm_sq_eq_conj_mul_self]
simp
intros
have h‚ÇÅ := f.norm_map z
simp only [complex.abs, norm_eq_abs] at h‚ÇÅ
rwa [real.sqrt_inj (norm_sq_nonneg _) (norm_sq_nonneg _), norm_sq_apply (f z), norm_sq_apply z, h‚ÇÇ, add_left_cancel_iff, mul_self_eq_mul_self_iff] at h‚ÇÅ
intros
intros x y hx hy a b ha hb hab
have h := hs hx hy ha hb hab
rwa [smul_add, smul_add, add_add_add_comm, ‚Üêadd_smul, hab, one_smul] at h
intros
simpa only [add_comm] using hs.translate_preimage_right z
intros
obtain ‚ü®a, b, ha, hb, hab, rfl‚ü© := hz
exact hf.le_left_of_right_le' hx hy ha hb.le hab hyz
intros x y hxy
refine ‚ü®_, ‚ü®fourier 1, _, rfl‚ü©, _‚ü©
exact subset_adjoin ‚ü®1, rfl‚ü©
simp [hxy]
intros
rw [‚Üê zero_smul ùïú (0:E), inner_smul_left, ring_hom.map_zero, zero_mul]
intros
rw ‚Üê smul_orthogonal_projection_singleton ùïú w
simp [hv]
intros
convert inner_le_Lp_mul_Lq s f g hpq using 3
apply sum_congr rfl
intros i hi
simp only [abs_of_nonneg, hf i hi, hg i hi]
apply sum_congr rfl
intros i hi
simp only [abs_of_nonneg, hf i hi, hg i hi]
intros
apply (is_colimit_cokernel_cocone f).uniq (cofork.of_œÄ g (by simp [w]))
rintro (_|_)
convert w.symm
simp
exact he
intros
simp [homothety_def, norm_smul, ‚Üê dist_eq_norm_vsub, dist_comm]
intros
rw [summable_iff_cauchy_seq_finset, cauchy_seq_finset_iff_vanishing_norm]
intros
simp only [‚Üê nnreal.coe_le_coe, ‚Üê nnreal.has_sum_coe, coe_nnnorm] at *
exact tsum_of_norm_bounded hg h
intros
simp [dist_eq_norm]
refine funext (Œª x, _)
rw [real.exp, complex.exp_eq_exp_‚ÑÇ_‚ÑÇ, ‚Üê exp_‚Ñù_‚ÑÇ_eq_exp_‚ÑÇ_‚ÑÇ, exp_eq_tsum, exp_eq_tsum_field, ‚Üê re_to_complex, ‚Üê re_clm_apply, re_clm.map_tsum (exp_series_summable' (x : ‚ÑÇ))]
refine tsum_congr (Œª n, _)
rw [re_clm.map_smul, ‚Üê complex.of_real_pow, re_clm_apply, re_to_complex, complex.of_real_re, smul_eq_mul, one_div, mul_comm, div_eq_mul_inv]
intros
set e := continuous_linear_equiv.of_finrank_eq (@finrank_fin_fun ùïú _ (finrank ùïú E)).symm
exact e.symm.antilipschitz.proper_space e.symm.continuous e.symm.surjective
intros
have : x = 0 := subsingleton.elim _ _
subst this
refine le_antisymm (by simpa using f.le_op_norm 0) _
have : ‚à•continuous_multilinear_map.curry0 ùïú G (f.uncurry0)‚à• ‚â§ ‚à•f.uncurry0‚à• := continuous_multilinear_map.op_norm_le_bound _ (norm_nonneg _) (Œªm, by simp [-continuous_multilinear_map.apply_zero_curry0])
simpa
intros
rw [comp_assoc, hf, ‚Üê comp_assoc, hf', comp_assoc]
intros
refine le_antisymm _ _
apply op_norm_le_bound _ (mul_nonneg (norm_nonneg _) (norm_nonneg _)) (Œªx, _)
calc ‚à•(c x) ‚Ä¢ f‚à• = ‚à•c x‚à• * ‚à•f‚à• : norm_smul _ _ ... ‚â§ (‚à•c‚à• * ‚à•x‚à•) * ‚à•f‚à• : mul_le_mul_of_nonneg_right (le_op_norm _ _) (norm_nonneg _) ... = ‚à•c‚à• * ‚à•f‚à• * ‚à•x‚à• : by ring
by_cases h : f = 0
simp [h]
have : 0 < ‚à•f‚à• := norm_pos_iff.2 h
rw ‚Üê le_div_iff this
apply op_norm_le_bound _ (div_nonneg (norm_nonneg _) (norm_nonneg f)) (Œªx, _)
rw [div_mul_eq_mul_div, le_div_iff this]
calc ‚à•c x‚à• * ‚à•f‚à• = ‚à•c x ‚Ä¢ f‚à• : (norm_smul _ _).symm ... = ‚à•smul_right c f x‚à• : rfl ... ‚â§ ‚à•smul_right c f‚à• * ‚à•x‚à• : le_op_norm _ _
intros
haveI := normed_algebra.nontrivial ùïú ùïú'
exact (lmul‚Çó·µ¢ ùïú ùïú').norm_to_continuous_linear_map
intros
rw mul_comm
exact norm_smul _ _
intros
obtain ‚ü®x, hx‚ü© : ‚àÉ (x : E), x ‚â† 0 := exists_ne 0
rw ‚Üê norm_pos_iff at hx
have ha : 0 ‚â§ a
simpa only [hf, hx, zero_le_mul_right] using norm_nonneg (f x)
apply le_antisymm (f.op_norm_le_bound ha (Œª y, le_of_eq (hf y)))
simpa only [hf, hx, mul_le_mul_right] using f.le_op_norm x
simp [arg, zero_le_one]
intros
by_cases h : 0 ‚â§ P.leading_coeff/Q.leading_coeff
exact tendsto_abs_at_top_at_top.comp (P.div_tendsto_at_top_of_degree_gt Q hdeg hQ h)
push_neg at h
exact tendsto_abs_at_bot_at_top.comp (P.div_tendsto_at_bot_of_degree_gt Q hdeg hQ h.le)
intros
rw [‚Üêreal.log_lt_log_iff hx (real.rpow_pos_of_pos hy z), real.log_rpow hy]
intros
simpa only [(‚àò), div_eq_inv_mul, mul_one] using (has_deriv_at_sqrt hx).comp_has_deriv_within_at x hf
intros
simpa only [pow_zero, div_eq_mul_inv, ennreal.inv_one, mul_one] using edist_le_of_edist_le_geometric_two_of_tendsto C hu ha 0
intros
simp [dist_eq_norm, sum_range_succ]
intros
refine summable_of_nonneg_of_le (Œª a, one_div_nonneg.mpr (pow_nonneg (zero_le_one.trans hm.le) _)) (Œª a, _) (summable_geometric_of_lt_1 (one_div_nonneg.mpr (zero_le_one.trans hm.le)) ((one_div_lt (zero_lt_one.trans hm) zero_lt_one).mpr (one_div_one.le.trans_lt hm)))
rw [div_pow, one_pow]
refine (one_div_le_one_div _ _).mpr (pow_le_pow hm.le (fi a))
exact pow_pos (zero_lt_one.trans hm) _
exact pow_pos (zero_lt_one.trans hm) _
intros
rw [add_def, comp_sub, neg_def, comp_sub, comp_zero, add_def, neg_def]
intros
cases h
cases h
refl
intros
rw [uncurry_eq, prod_map_pre_app_comp_ev]
intros
rw [pre, pre, pre, transfer_nat_trans_self_comp, prod.functor.map_comp]
intros
rw ‚Üê frobenius_morphism_mate F h
apply_instance
intros
cases F with F_obj _ _ _
cases G with G_obj _ _ _
have : F_obj = G_obj
ext X
apply h_obj
subst this
congr
funext X Y f
exact eq_of_heq (h_map X Y f)
intros
cases p
simp
intros
simp only [cancel_mono]
intros
classical
let O := (finset.univ.image F.obj)
let H : finset (Œ£' (X Y : C) (mX : X ‚àà O) (mY : Y ‚àà O), X ‚ü∂ Y) := finset.univ.bUnion (Œª X : J, finset.univ.bUnion (Œª Y : J, finset.univ.image (Œª f : X ‚ü∂ Y, ‚ü®F.obj X, F.obj Y, by simp, by simp, F.map f‚ü©)))
obtain ‚ü®Z, f, w‚ü© := sup_exists O H
refine ‚ü®‚ü®Z, ‚ü®Œª X, f (by simp), _‚ü©‚ü©‚ü©
intros j j' g
dsimp
simp only [category.comp_id]
apply w
simp only [finset.mem_univ, finset.mem_bUnion, exists_and_distrib_left, exists_prop_of_true, finset.mem_image]
exact ‚ü®j, rfl, j', g, (by simp)‚ü©
intros
subst h
dsimp
simp
intros
have z : ‚àÄ (j : J), r (classical.arbitrary J) j := induct_on_objects (Œª k, r (classical.arbitrary J) k) (hr.1 (classical.arbitrary J)) (Œª _ _ f, ‚ü®Œª t, hr.2.2 t (h f), Œª t, hr.2.2 t (hr.2.1 (h f))‚ü©)
apply hr.2.2 (hr.2.1 (z _)) (z _)
intros
dsimp [limit_uncurry_iso_limit_comp_lim, is_limit.cone_point_unique_up_to_iso, is_limit.unique_up_to_iso]
simp
intros
erw is_limit.fac
refl
intros
constructor
intro F
apply has_limit_of_equivalence_comp e
apply_instance
intros
dsimp [colimit.iso_colimit_cocone, is_colimit.cocone_point_unique_up_to_iso]
tidy
intros
ext
simp [‚Üê G.map_comp]
intros
simp
intros
ext
simp
simp
intros
simp
intros
ext
simp
intros
rw [t.app_zero_left, t.app_zero_right]
intros
ext
simp [‚Üê G.map_comp]
intros
ext
simp [image.comp_iso]
intros
rw [‚Üêfork.app_zero_left, kernel_fork.condition]
intros
apply colimit.w (wide_pushout_shape.wide_span _ _ _) (wide_pushout_shape.hom.init j)
intros
simp
refl
intros
rw [‚Üêw]
simp
intros
equiv_rw (is_limit_equiv_sections t).symm at x
simp
intros
rw [‚Üêtriangle_assoc_comp_left, iso.inv_hom_id_assoc]
intros
rw [iso.inv_comp_eq, F.left_unitality, category.assoc, category.assoc, ‚ÜêF.to_functor.map_comp, iso.hom_inv_id, F.to_functor.map_id, comp_id]
intros
dsimp [tensor_hom]
simp
intros
simp only [left_adjoint_mate, monoidal_category.tensor_id, category.id_comp, evaluation_coevaluation_assoc, category.comp_id, iso.inv_hom_id]
intros
tidy
intros
ext
simp
simp
simp
simp
intros
rw ‚Üê generate_of_singleton_split_epi (ùüô X)
rw ‚Üê is_sheaf_for_iff_generate
apply is_sheaf_for_singleton_iso
intros
apply quotient.induction_on' x
intro t
apply quotient.sound
refine ‚ü®(mono_over.map_comp _ _).app t‚ü©
intros
rw ‚Üêimage_subobject_arrow
simp
intros
simp [equalizer_subobject_iso]
intros
change F.repr_f.app X f = (F.repr_f.app (op F.repr_X) ‚â´ F.map f.op) (ùüô F.repr_X)
rw ‚ÜêF.repr_f.naturality
dsimp
simp
intros
rw [le_iff_le_iff_lt_iff_lt, sdiff_lt_sdiff_iff_lt]
intros
have hh := card_image_of_injective univ (G.dart_of_neighbor_set_injective v)
rw [finset.card_univ, card_neighbor_set_eq_degree] at hh
rwa dart_fst_fiber
intros
ext a
split
rintro ( ‚ü® _, _, h ‚ü© | ‚ü® _, _, _, h, _ ‚ü© )
exact h
cases h
intro h
apply Œµ_NFA.Œµ_closure.base
exact h
intros
letI : ‚àÄ a, decidable (a ‚àà set.range (encode : Œ± ‚Üí ‚Ñï)) := decidable_range_encode _
exact subtype_mk primrec.encode
intros
letI : primcodable Œ≤ := primcodable.of_equiv Œ± e
exact encode_iff.1 primrec.encode
intros
induction c with generalizing k v
simp only [cont.then, step_normal, cfg.then, *] {constructor_eq := ff}
simp only [cont.then, step_normal, cfg.then, *] {constructor_eq := ff}
simp only [cont.then, step_normal, cfg.then, *] {constructor_eq := ff}
simp only [cont.then, step_normal, cfg.then, *] {constructor_eq := ff}
case turing.to_partrec.code.cons : c c' ih ih' { rw [‚Üê ih, cont.then] }
simp only [cont.then, step_normal, cfg.then, *] {constructor_eq := ff}
case turing.to_partrec.code.comp : c c' ih ih' { rw [‚Üê ih', cont.then] }
simp only [cont.then, step_normal, cfg.then, *] {constructor_eq := ff}
cases v.head
simp only [nat.elim]
simp only [nat.elim]
simp only [cont.then, step_normal, cfg.then, *] {constructor_eq := ff}
case turing.to_partrec.code.fix : c ih { rw [‚Üê ih, cont.then] }
intros
cases T
simp [tape.move]
intros
rcases trans_gen.head'_iff.1 h‚ÇÅ with ‚ü®b', hab, hbc‚ü©
cases option.mem_unique hab h‚ÇÇ
exact hbc
intros
ext
simp only [(‚àò), mfoldr.of_free_monoid, mfoldr.mk, flip, fold_mfoldr_cons]
intros
simp [add_lsb,two_mul]
intros
cases b
convert array.read_push_back_left _
simp
intros
cases b
convert array.read_push_back_right
intros
contrapose! h
constructor
intros cb n hn
cases hp : p cb n
exact absurd hn (h _ _ _ _ hp).not_le
simp [hp]
intros
cases hp : p cb n
simp [hp, ‚Üêbind_eq_bind, parser.bind, and_assoc]
simp [hp, ‚Üêbind_eq_bind, parser.bind, and_assoc]
intros
simp [mmap, and.comm, and.assoc, and.left_comm, pure_eq_done]
intros
by_cases hn : n < cb.size
by_cases hp : p (cb.read ‚ü®n, hn‚ü©)
simp only [sat, hn, hp, dif_pos, if_true, exists_prop_of_true]
split
rintro ‚ü®rfl, rfl‚ü©
simp [hp]
rintro ‚ü®-, rfl, rfl‚ü©
simp
simp only [sat, hn, hp, dif_pos, false_iff, not_and, exists_prop_of_true, if_false]
rintro H - rfl
exact hp H
simp [sat, hn]
intros
simp [str_eq_char_buf, char_buf_eq_done]
intros
simp only [sub_conj, of_real_mul, of_real_one, of_real_bit0, mul_right_comm, mul_div_cancel_left _ (mul_ne_zero two_ne_zero' I_ne_zero : 2 * I ‚â† 0)]
intros
rw ‚Üê of_real_inj
simp [sinh_add]
intros
rw ‚Üê of_real_inj
simp [cosh_two_mul]
intros
rw [two_mul, sinh_add]
ring
intros
simp [sub_eq_add_neg, sin_add, sin_neg, cos_neg]
intros
rw [‚Üê of_real_sin_of_real_re, of_real_im]
intros
rw [cos_two_mul', eq_sub_iff_add_eq.2 (sin_sq_add_cos_sq x), ‚Üê sub_add, sub_add_eq_add_sub, two_mul]
intros
have h1 : x + 2 * x = 3 * x
ring
rw [‚Üê h1, cos_add x (2 * x)]
simp only [cos_two_mul, sin_two_mul, mul_add, mul_sub, mul_one, sq]
have h2 : 4 * cos x ^ 3 = 2 * cos x * cos x * cos x + 2 * cos x * cos x ^ 2
ring
rw [h2, cos_sq']
ring
intros
rw [‚Üê of_real_inj, of_real_tan, tan_eq_sin_div_cos, of_real_div, of_real_sin, of_real_cos]
intros
simp [bit0]
intros
simp [bit1]
intros
simp [bit0, ext_iff]
intros
simp_rw conj_eq_re_sub_im
simp only [smul_re, smul_im, of_real_mul]
rw smul_sub
simp_rw of_real_alg
simp
intros
by_cases h : (I : K) = 0
simp [h]
field_simp [mul_assoc, I_mul_I_of_nonzero h]
intros
simp only [‚Üêsqrt_norm_sq_eq_norm, norm_sq_conj]
intros
rw [‚Üê of_real_rat_cast, of_real_re]
intros
simp
intros
ext j
by_cases h : i = j
subst h
simp [hb]
simp [ne.symm h, h]
intros
contrapose! h
exact prod_extend_right_apply_ne _ h _
intros
ext ‚ü®b, a, has, rfl‚ü©
have : ‚àÄ(h : ‚àÉa', a' ‚àà s ‚àß a' = a), classical.some h = a := Œª h, (classical.some_spec h).2
simp [equiv.set.image, equiv.set.image_of_inj_on, hf.eq_iff, this]
intros
ext
simp
intros
rw [‚Üê equiv.trans_apply, equiv.swap_swap, equiv.refl_apply]
intros
dsimp [fin_rotate]
rw fin_add_flip_apply_mk_right
simp
intros
ext ‚ü®i, h‚ü©
by_cases h' : i < n
rw [fin_rotate_of_lt h', fin.snoc, fin.cons, dif_pos h']
refl
have h'' : n = i
simp only [not_lt] at h'
exact (nat.eq_of_le_of_lt_succ h' h).symm
subst h''
rw [fin_rotate_last', fin.snoc, fin.cons, dif_neg (lt_irrefl _)]
refl
intros
split
rw [trans_source'', trans_source'', ‚Üê he.target_eq, ‚Üê hf.1]
exact (he.symm'.eq_on.mono $ inter_subset_left _ _).image_eq
assume x hx
rw trans_source at hx
simp [(he.2 hx.1).symm, hf.2 hx.2]
intros
rw [he.eq_on.inter_preimage_eq, he.source_eq]
intros
ext x
simp [ext_iff]
simp [ext_iff]
simp [ext_iff]
simp [ext_iff]
tauto
intros
ext
simp
intros
simp [snoc]
intros
ext j
by_cases h : j = i
rw h
simp [init]
simp [init, h]
intros
simp [eq_iff_veq]
intros
cases j
refl
intros
ext
rw [multiset.mem_to_finset, ‚Üêmem_def]
intros
intro s
rcases to_finset_surj_on (set.mem_univ s) with ‚ü®l, -, hls‚ü©
exact ‚ü®l, hls‚ü©
intros
rw ‚Üê not_iff_not
push_neg
exact card_le_one
intros
ext
simp only [finset.mem_bUnion, exists_prop]
simp_rw [‚Üêexists_and_distrib_right, ‚Üêexists_and_distrib_left, and_assoc]
rw exists_comm
intros
rw [insert_val, ndinsert_of_not_mem h]
intros
classical
induction s using finset.induction_on with x s hx IH generalizing n
simpa using h
cases n
simp
rw [card_insert_of_not_mem hx, nat.succ_lt_succ_iff] at h
rw powerset_len_succ_insert hx
refine nonempty.mono _ ((IH h).image (insert x))
convert (subset_union_right _ _)
intros
simp only [finsupp.support_eq_empty, finset.nonempty_iff_ne_empty, ne.def]
intros
rw [‚Üê card_to_multiset, ‚Üê card_to_multiset]
apply multiset.card_lt_of_lt
exact to_multiset_strict_mono h
intros
dsimp [finsupp.prod]
rw f.support.prod_ite_eq
intros
ext
rw dfinsupp.mem_support_to_fun
exact (finsupp.mem_split_support_iff_nonzero _ _).symm
intros
rw [list.of_fn_eq_map, fin.prod_univ_def]
intros
rw [‚Üê (equiv.sigma_preimage_equiv f).prod_comp, ‚Üê univ_sigma_univ, prod_sigma]
refl
intros
change sub_nat_nat _ _ = _
have h' : n.succ - m = (n - m).succ
apply succ_sub
apply le_of_lt_succ h
simp [*, sub_nat_nat]
intros
cases n
refl
refl
intros
have := int.add_mul_div_right 0 a H
rwa [zero_add, int.zero_div, zero_add] at this
intros
have := add_mul_mod_self_left a b 1
rwa mul_one at this
intros
rw [mul_comm, mul_div_cancel_of_mod_eq_zero H]
intros
rw int.lcm
apply nat.lcm_self
intros
induction m with d hd
refl
rw [pow_succ, pow_succ]
exact h.mul hd
intros
induction xs
refl
simp [lazy_list.append, xs_ih]
ext
congr
intros
cases l‚ÇÇ
exact if_pos h
exact if_pos h
intros
induction l with hd tl ih generalizing a
refl
unfold foldl
rw [ih (Œª a b bin, H a b $ mem_cons_of_mem _ bin), H a hd (mem_cons_self _ _)]
intros
induction L with a L ihL
simp
rw [prod_cons, mul_eq_zero, ihL, mem_cons_iff, eq_comm]
intros
induction L generalizing i
simp
cases i
simp
simp [drop_append, L_ih]
intros
rw erase_eq_erasep
exact length_erasep_of_mem h rfl
intros
have := h
rw [‚Üê take_append_drop (length s‚ÇÅ) l] at this ‚ä¢
rw map_append at this
refine ‚ü®_, _, rfl, append_inj this _‚ü©
rw [length_map, length_take, min_eq_left]
rw [‚Üê length_map f l, h, length_append]
apply nat.le_add_right
intros
induction l
refl
simp only [*, map]
split
intros
rw [next, next, next_or_cons_of_ne _ _ _ _ hy, next_or_eq_next_or_of_mem_of_ne]
rwa last_cons at hx
simpa [hy] using h
intros
simp_rw [nodup_iff_sublist, duplicate_iff_sublist]
intros
simp [duplicate_iff_sublist, le_count_iff_repeat_sublist]
intros
simp only [mmap_with_index, mmap_with_index_aux_spec, mmap_with_index_aux_eq_mmap_with_index_aux_spec, enum ]
intros
induction l with hd tl hl generalizing f n
simp [map_with_index, map_with_index_core]
rw [map_with_index]
simp [map_with_index_core, hl, add_left_comm, add_assoc, add_comm]
intros
simp only [pairwise_cons, mem_singleton, forall_prop_of_false (not_mem_nil _), forall_true_iff, pairwise.nil, and_true]
intros
induction s with y s IH generalizing n
simp only [length, permutations'_aux, nat.lt_one_iff] at hn
simp [hn]
cases n
simp
simpa using IH _ _
intros
induction hl
refl
case list.perm.cons : a l l' h ih { exact f_congr h ih }
case list.perm.swap : a a' l { exact f_swap }
case list.perm.trans : l‚ÇÅ l‚ÇÇ l‚ÇÉ h‚ÇÅ h‚ÇÇ ih‚ÇÅ ih‚ÇÇ { exact heq.trans ih‚ÇÅ ih‚ÇÇ }
intros
let F := Œª a b, ‚àÄ (c ‚àà f a) (d ‚àà f b), a = b ‚àß c = d
change pairwise F l‚ÇÅ at H
induction p with a l‚ÇÅ l‚ÇÇ p IH a b l l‚ÇÅ l‚ÇÇ l‚ÇÉ p‚ÇÅ p‚ÇÇ IH‚ÇÅ IH‚ÇÇ
simp
cases h : f a
simp [h]
exact IH (pairwise_cons.1 H).2
simp [lookmap_cons_some _ _ h, p]
cases h‚ÇÅ : f a with c
cases h‚ÇÇ : f b with d
simp [h‚ÇÅ, h‚ÇÇ]
apply swap
simp [h‚ÇÅ, lookmap_cons_some _ _ h‚ÇÇ]
apply swap
cases h‚ÇÇ : f b with d
simp [lookmap_cons_some _ _ h‚ÇÅ, h‚ÇÇ]
apply swap
simp [lookmap_cons_some _ _ h‚ÇÅ, lookmap_cons_some _ _ h‚ÇÇ]
rcases (pairwise_cons.1 H).1 _ (or.inl rfl) _ h‚ÇÇ _ h‚ÇÅ with ‚ü®rfl, rfl‚ü©
refl
refine (IH‚ÇÅ H).trans (IH‚ÇÇ ((p‚ÇÅ.pairwise_iff _).1 H))
exact Œª a b h c h‚ÇÅ d h‚ÇÇ, (h d h‚ÇÇ c h‚ÇÅ).imp eq.symm eq.symm
intros
simp only [range_eq_range', pairwise_lt_range']
intros
simp only [range_eq_range', range'_sublist_right]
intros
cases l.length.zero_le.eq_or_lt with hl hl
simp [eq_nil_of_length_eq_zero hl.symm ]
rw [‚Üêrotate_eq_drop_append_take (n.mod_lt hl).le, rotate_mod]
intros
rw [is_rotated_comm, is_rotated_nil_iff, eq_comm]
intros
split
intro h
obtain ‚ü®k, hk, rfl‚ü© := nth_le_of_mem h
simp
intro h
obtain ‚ü®k, rfl‚ü© := h.symm
rw mem_iff_nth_le
simp only [exists_prop, nth_le_cyclic_permutations]
cases l' with x l
simp
refine ‚ü®k % length (x :: l), _, rotate_mod _ _‚ü©
simpa using nat.mod_lt _ (zero_lt_succ _)
intros
simp [h]
intros
induction l generalizing f r
refl
simp only [*, sublists'_aux]
intros
induction l with hd tl hl generalizing l'
simp
cases l'
simp
simp [comm, hl]
intros
rw [‚Üê unzip_left, unzip_revzip]
intros
induction l with hd tl hl generalizing f n l'
simp
cases l' with hd' tl'
simp
simp [hl, mul_add]
intros
ext i j
apply dot_product_add
intros
ext
apply dot_product_neg
intros
ext
simp only [block_diagonal_apply, pi.smul_apply]
split_ifs
simp
simp
intros
ext
simp only [block_diagonal'_apply, pi.add_apply]
split_ifs
simp
simp
intros
ext
by_cases h : i = j
simp [h]
simp [h]
intros
ext ‚ü®i, i'‚ü© ‚ü®j, j'‚ü©
simp only [kronecker_map_bilinear_apply_apply, mul_apply, ‚Üê finset.univ_product_univ, finset.sum_product, kronecker_map]
simp_rw [f.map_sum, linear_map.sum_apply, linear_map.map_sum, h_comm]
intros
ext i j
rw [mul_matrix_apply, equiv.to_pequiv_apply]
intros
by_contra h
cases lt_iff_cons_le.1 (lt_of_le_of_ne (le_inter (add_le_add_right (inter_le_left s t) u) (add_le_add_right (inter_le_right s t) u)) h) with a hl
rw ‚Üê cons_add at hl
exact not_le_of_lt (lt_cons_self (s ‚à© t) a) (le_inter (le_of_add_le_add_right (le_trans hl (inter_le_left _ _))) (le_of_add_le_add_right (le_trans hl (inter_le_right _ _))))
intros
refine ‚ü®mem_of_mem_nsmul, Œª h, _‚ü©
obtain ‚ü®n, rfl‚ü© := exists_eq_succ_of_ne_zero h0
rw [succ_nsmul, mem_add]
exact or.inl h
intros
induction k
simp
simpa
intros
rw [‚Üê multiset.card_eq_zero, multiset.card_map, multiset.card_eq_zero]
intros
simp
intros
apply m.induction_on
simp
intros a s h
simp [h]
intros
refine Œª p, ‚ü®p.to_fun 0, finsupp.ext (Œª a, _)‚ü©
simpa [(finsupp.ext is_empty_elim : a = 0), C_apply, monomial]
intros
apply @finsupp.induction œÉ ‚Ñï _ _ s
simp only [C_apply, prod_zero_index]
exact (mul_one _).symm
assume n e s hns he ih
rw [monomial_single_add, ih, prod_add_index, prod_single_index, mul_left_comm]
simp only [pow_zero]
intro a
simp only [pow_zero]
intros
rw pow_add
intros
simp
intros
simp only [eval‚ÇÇ_eq, ‚Üê finsupp.prod_pow]
refl
intros
ext i
simp
intros
ext : 2
simp
simp
intros
split
intros h i
simpa using @h (X i)
exact supported_mono
intros
rw [supported, set.image_eq_range, adjoin_range_eq_range_aeval, rename]
intros
apply le_antisymm
apply degrees_add
apply multiset.union_le
apply le_degrees_add h
rw add_comm
apply le_degrees_add h.symm
intros
rw [add_comm, mod_add_mod, add_comm]
intros
rw [‚Üênat.div_mul_cancel w, h, zero_mul]
intros
split
intro
cases b
simp * at *
cases b
right
refl
left
have : a / (b + 2) ‚â§ a / 2 := div_le_div_left (by simp) dec_trivial
refine eq_zero_of_le_half _
simp * at *
rintros (rfl|rfl)
simp
simp
intros
refine le_trans _ h
simp
intros
rw [add_comm, add_one, pred_succ]
intros
induction n using nat.binary_rec with b n hn' generalizing i m
contrapose! hm
rw le_zero_iff at hm
simp [hm]
induction m using nat.binary_rec with b' m hm' generalizing i
exact false.elim (bool.ff_ne_tt ((zero_test_bit i).symm.trans hm))
by_cases hi : i = 0
subst hi
simp only [test_bit_zero] at hn hm
have : n = m
exact eq_of_test_bit_eq (Œª i, by convert hnm (i + 1) dec_trivial using 1; rw test_bit_succ)
rw [hn, hm, this, bit_ff, bit_tt, bit0_val, bit1_val]
exact lt_add_one _
obtain ‚ü®i', rfl‚ü© := exists_eq_succ_of_ne_zero hi
simp only [test_bit_succ] at hn hm
have := hn' _ hn hm (Œª j hj, by convert hnm j.succ (succ_lt_succ hj) using 1; rw test_bit_succ)
cases b
cases b'
simp only [bit_ff, bit_tt, bit0_val n, bit1_val n, bit0_val m, bit1_val m]
linarith
simp only [bit_ff, bit_tt, bit0_val n, bit1_val n, bit0_val m, bit1_val m]
linarith
cases b'
simp only [bit_ff, bit_tt, bit0_val n, bit1_val n, bit0_val m, bit1_val m]
linarith
simp only [bit_ff, bit_tt, bit0_val n, bit1_val n, bit0_val m, bit1_val m]
linarith
intros
induction l1 with hd tl IH
simp [of_digits]
rw [of_digits, list.cons_append, of_digits, IH, list.length_cons, pow_succ']
ring
intros
cases b with b
cases n with n
refl
change of_digits 0 [n+1] = n+1
dsimp [of_digits]
simp
cases b with b
induction n with n ih
refl
simp only [ih, add_comm 1, of_digits_one_cons, nat.cast_id, digits_one_succ]
apply nat.strong_induction_on n _
clear n
intros n h
cases n
rw digits_zero
refl
simp only [nat.succ_eq_add_one, digits_add_two_add_one]
dsimp [of_digits]
rw h _ (nat.div_lt_self' n b)
rw [nat.cast_id, nat.mod_add_div]
intros
split
intro h
have : of_digits b (digits b n) = of_digits b []
rw h
convert this
rw of_digits_digits
rintro rfl
simp
intros
rw ‚Üêint.coe_nat_dvd
exact dvd_iff_dvd_of_dvd_sub (zmodeq_of_digits_digits b b' c (int.modeq_iff_dvd.2 h).symm _).symm.dvd
intros
rw [dist.def, dist.def, right_distrib, nat.mul_sub_right_distrib, nat.mul_sub_right_distrib]
intros
simpa only [‚Üê some_eq_coe] using part.some_inj
intros
simp [coprime]
intros
rw [‚Üê enat.coe_le_coe, ‚Üê hp.multiplicity_factorial hbn, ‚Üê pow_dvd_iff_le_multiplicity]
intros
conv { to_rhs, rw [‚Üênat.sub_add_cancel h, even_add] }
by_cases h : even n
simp [h]
simp [h]
intros
rw [odd_iff_not_even, even_sub h, not_iff, not_iff_comm, odd_iff_not_even]
intros
cases mod_two_eq_zero_or_one n with h h
simp [h]
simp [h]
intros
split
intro h
rcases n with (_ | _ | n)
exact or.inl rfl
exact or.inr rfl
rw factors at h
injection h
intro h
rcases h with (rfl | rfl)
exact factors_zero
exact factors_one
intros
obtain ‚ü®l, ‚ü®h, rfl‚ü©‚ü© := (dvd_prime_pow pp).1 h‚ÇÇ
congr
exact le_antisymm h (not_le.1 ((not_congr (pow_dvd_pow_iff_le_right (prime.one_lt pp))).1 h‚ÇÅ))
intros
rw sqrt_aux
simp only [h, h‚ÇÇ.symm, int.coe_nat_add, if_false]
rw [add_comm _ (n':‚Ñ§), add_sub_cancel, sqrt_aux._match_1]
intros
cases x
refl
refl
intros
cases x
simp
simp only [pbind]
split
intro h
use x
simpa only [mem_def, exists_prop_of_true] using h
rintro ‚ü®z, H, hz‚ü©
simp only [mem_def] at H
simpa only [H] using hz
intros
linarith
intros
cases l with ls ll lx lr
exact ‚ü®hr, (zero_add _).symm‚ü©
cases r with rs rl rx rr
exact ‚ü®hl, rfl‚ü©
dsimp [glue]
split_ifs
rw [split_max_eq, glue]
cases valid'.erase_max_aux hl with v e
suffices H
refine ‚ü®valid'.balance_r v (hr.of_gt _ _) H, _‚ü©
refine find_max'_all lx lr hl.1.2.to_nil (sep.2.2.imp _)
exact Œª x h, hr.1.2.to_nil.mono_left (le_of_lt h.2.1)
exact @find_max'_all _ (Œª a, all (> a) (node rs rl rx rr)) lx lr sep.2.1 sep.2.2
rw [size_balance_r v.3 hr.3 v.2 hr.2 H, add_right_comm, ‚Üê e, hl.2.1]
refl
refine or.inl ‚ü®_, or.inr e, _‚ü©
rwa hl.2.eq_node' at bal
rw [split_min_eq, glue]
cases valid'.erase_min_aux hr with v e
suffices H
refine ‚ü®valid'.balance_l (hl.of_lt _ _) v H, _‚ü©
refine @find_min'_all _ (Œª a, bounded nil o‚ÇÅ ‚Üëa) rl rx (sep.2.1.1.imp _) hr.1.1.to_nil
exact Œª y h, hl.1.1.to_nil.mono_right (le_of_lt h)
exact @find_min'_all _ (Œª a, all (< a) (node ls ll lx lr)) rl rx (all_iff_forall.2 $ Œª x hx, sep.imp $ Œª y hy, all_iff_forall.1 hy.1 _ hx) (sep.imp $ Œª y hy, hy.2.1)
rw [size_balance_l hl.3 v.3 hl.2 v.2 H, add_assoc, ‚Üê e, hr.2.1]
refl
refine or.inr ‚ü®_, or.inr e, _‚ü©
rwa hr.2.eq_node' at bal
intros
linarith
intros
cases r
simp [rotate_l, all_node']
simp [rotate_l, all_node']
split_ifs
simp [all_node3_l, all_node4_l, all]
simp [all_node3_l, all_node4_l, all]
intros
rw [balance_l_eq_balance' hl hr sl sr H, size_balance' sl sr]
intros
ext
rw mem_core_res
by_cases h : x ‚àà s
simp [h]
simp [h]
intros
change (coe_pnat_monoid_hom (u + v)).prod = _
rw coe_pnat_monoid_hom.map_add
exact multiset.prod_add _ _
intros
let u := factor_multiset n
let v := factor_multiset m
have : n = u.prod := (prod_factor_multiset n).symm
rw[this]
have : m = v.prod := (prod_factor_multiset m).symm
rw[this]
rw[‚Üê prime_multiset.prod_add]
rw[prime_multiset.factor_multiset_prod]
rw[prime_multiset.factor_multiset_prod]
rw[prime_multiset.factor_multiset_prod]
intros
apply factor_multiset_equiv.symm.injective
change (p : ‚Ñï+).factor_multiset.prod = (prime_multiset.of_prime p).prod
rw[(p : ‚Ñï+).prod_factor_multiset, prime_multiset.prod_of_prime]
intros
rw [aeval_def, eval‚ÇÇ]
exact (linear_map.apply‚Çó v).map_sum
intros
ext
rw [coeff_C_mul, coeff_smul, smul_eq_mul]
intros
simp [coeff_X_pow]
intros
rw [add_comm _ X, coeff_X_add_one_pow]
intros
simp [bit1, add_mul, coeff_bit0_mul]
intros
simp
intros
rw [C_mul_X_pow_eq_monomial]
exact support_monomial _ _ h
intros
cases le_max_iff.1 (degree_add_le p q)
simp [nat_degree_le_nat_degree h]
simp [nat_degree_le_nat_degree h]
intros
nontriviality R
exact hp.ne_zero
intros
rw [C_mul_X_pow_eq_monomial, trailing_degree_monomial ha]
intros
rw [next_coeff_up, if_neg]
contrapose! hp
simpa
intros
rw [‚Üê C_0, comp_C]
intros
rw [‚Üê C_1, comp_C]
intros
induction n with n ih
exfalso
exact nat.not_lt_zero 1 h
simp only [iterated_deriv_succ]
by_cases H : n = 1
rw H
simp only [iterated_deriv_X_one, derivative_one]
replace h : 1 < n := array.push_back_idx h (ne.symm H)
rw ih h
simp only [derivative_zero]
intros
by_cases hq : q = 0
simp [h.mul_left_ne_zero, hq]
simp [h.mul_left_ne_zero, hq]
intros
refine le_antisymm _ _
rw degree_le_iff_coeff_zero
intros m hm
rw degree_lt_iff_coeff_zero at hm
simp [hm m le_rfl]
rw degree_le_iff_coeff_zero
intros m hm
rw degree_lt_iff_coeff_zero at hm
refine h _
simpa using hm m le_rfl
intros
obtain ‚ü®r, hr‚ü© := hdiv
have rzero : r ‚â† 0
intro h
simpa [h, monic.ne_zero hq] using hr
rw [hr, nat_degree_mul (monic.ne_zero hp) rzero] at hdeg
have hdegeq : p.nat_degree + r.nat_degree = p.nat_degree
suffices hdegle : p.nat_degree ‚â§ p.nat_degree + r.nat_degree
exact le_antisymm hdeg hdegle
exact nat.le.intro rfl
replace hdegeq := eq_C_of_nat_degree_eq_zero (((@add_right_inj _ _ p.nat_degree) _ 0).1 hdegeq)
suffices hlead : 1 = r.leading_coeff
have hcoeff := leading_coeff_C (r.coeff 0)
rw [‚Üê hdegeq, ‚Üê hlead] at hcoeff
rw [‚Üê hcoeff, C_1] at hdegeq
rwa [hdegeq, mul_one] at hr
have hprod : q.leading_coeff = p.leading_coeff * r.leading_coeff
simp only [hr, leading_coeff_mul]
rwa [monic.leading_coeff hp, monic.leading_coeff hq, one_mul] at hprod
intros
rw [‚Üê supp_preservation_iff_liftp_preservation, supp_preservation_iff_uniform]
intros
split
intros h Œ± a a' f f' h'
rw [‚Üê pfunctor.supp_eq,‚Üê pfunctor.supp_eq,‚Üê h,h',h]
rintros h Œ± ‚ü®a,f‚ü©
rwa [supp_eq_of_is_uniform,pfunctor.supp_eq]
intros
rcases h with ‚ü®c, rfl‚ü©
simp only [mul_comm b, nat.mul_div_assoc c (dvd_refl b), nat.cast_mul, mul_div_assoc, coe_nat_div_self]
intros
simp only [lt_iff_le_not_le]
apply and_congr
simp [div_num_denom, (rat.le_def b_pos d_pos)]
apply not_iff_not_of_iff
simp [div_num_denom, (rat.le_def d_pos b_pos)]
intros
rw le_iff_lt_or_eq
exact or_congr const_lt const_equiv
intros
have KK := mul_pos K0 K0
have ŒµK := mul_pos Œµ0 KK
refine ‚ü®_, ŒµK, Œª a b ha hb h, _‚ü©
have a0 := lt_of_lt_of_le K0 ha
have b0 := lt_of_lt_of_le K0 hb
rw [inv_sub_inv ((abv_pos abv).1 a0) ((abv_pos abv).1 b0), abv_div abv, abv_mul abv, mul_comm, abv_sub abv, ‚Üê mul_div_cancel Œµ (ne_of_gt KK)]
exact div_lt_div h (mul_le_mul hb ha (le_of_lt K0) (abv_nonneg abv _)) (le_of_lt $ mul_pos Œµ0 KK) KK
intros
simp_rw [ennreal.of_real, ‚Üêcoe_finset_prod, coe_eq_coe]
exact real.to_nnreal_prod_of_nonneg hf
intros
have : ‚Üëa.to_nnreal = a := ennreal.coe_to_nnreal (lt_of_le_of_lt h coe_lt_top).ne
rw ‚Üê this at h
exact_mod_cast h
intros
rwa [‚Üê pos_iff_ne_zero, ‚Üê add_lt_add_iff_left ha, add_zero] at hb
intros
simp [add_eq_top]
intros
rw [‚Üêereal.neg_neg a, h, ereal.neg_neg b]
rw [neg_lt, ‚Üê inv_gold]
exact inv_lt_one one_lt_gold
intros
rw iff_eq_eq
refl
intros
rw [‚Üênnreal.coe_eq, nnreal.coe_prod, real.coe_to_nnreal _ (finset.prod_nonneg hf)]
exact finset.prod_congr rfl (Œª x hxs, by rw real.coe_to_nnreal _ (hf x hxs))
intros
rw [mul_self_le_mul_self_iff hx (sqrt_nonneg _), sq, mul_self_sqrt hy]
intros
split
simpa only [abs_le] using abs_le_sqrt
rw [‚Üê abs_le, ‚Üê sq_abs]
exact (le_sqrt (abs_nonneg x) h).mp
intros
rw [sqrt_eq_iff_sq_eq, mul_mul_mul_comm, mul_self_sqrt, mul_self_sqrt]
intros
apply mem_rec_on h
intros
simp [*]
intros
rw add_comm
symmetry
apply dropn_add
intros
subst hT'
cases set.mem_Union.1 x.prop with i hi
rw [Union_lift_of_mem x hi, ‚Üê h i]
have : x = (set.inclusion (set.subset_Union S i) ‚ü®x, hi‚ü©)
cases x
refl
have hx' : (set.inclusion (set.subset_Union S i) (ui i ‚ü®x, hi‚ü©) : Œ±) ‚àà S i
from (ui i ‚ü®x, hi‚ü©).prop
conv_lhs { rw [this, hui, Union_lift_inclusion] }
intros
simp
intros
refine (iff.symm $ iff.intro (image_subset f) $ assume h, _)
rw [‚Üê preimage_image_eq s hf, ‚Üê preimage_image_eq t hf]
exact preimage_mono h
intros
split
rintro ‚ü®s, hs‚ü©
refine ‚ü®coe '' s, _, hs‚ü©
convert image_subset_range _ _
rw [range_coe]
rintro ‚ü®s, hs‚ÇÅ, hs‚ÇÇ‚ü©
refine ‚ü®coe ‚Åª¬π' s, _‚ü©
rw [image_preimage_eq_of_subset]
exact hs‚ÇÇ
rw [range_coe]
exact hs‚ÇÅ
intros
rw [inter_comm, ‚Üê image_preimage_coe, nonempty_image_iff]
intros
ext
simp
intros
ext ‚ü®x, y‚ü©
simp [and_comm]
intros
ext
split
rintro ‚ü®_, b, ‚ü®a, ha, rfl‚ü©, hb, rfl‚ü©
refine ‚ü®a, b, ha, hb, rfl‚ü©
rintro ‚ü®a, b, ha, hb, rfl‚ü©
refine ‚ü®_, b, ‚ü®a, ha, rfl‚ü©, hb, rfl‚ü©
intros
rw bUnion_eq_Union
haveI := hs.to_encodable
exact countable_Union (by simpa using ht)
intros
refine ‚ü®_, h.right_inv_on_inv_fun_on‚ü©
rintros _ ‚ü®y, hy, rfl‚ü©
rw [h.right_inv_on_inv_fun_on hy]
intros
rw ‚Üê image_univ at *
exact h.inj_on_image (ha.inj_on univ) hf
intros
rw [Ioc_union_Ioc, min_self]
exact (min_le_left _ _).trans (le_max_left _ _)
exact (min_le_left _ _).trans (le_max_left _ _)
intros
simp [‚Üê Ici_inter_Iio]
intros
rw [e.image_eq_preimage, e.symm.preimage_Ioo, e.symm_symm]
intros
rw [insert_eq, ‚Üê diff_diff, Icc_diff_left, Ioc_diff_right]
intros
rw [‚Üê Icc_diff_left, diff_diff_cancel_left (singleton_subset_iff.2 $ left_mem_Icc.2 h)]
intros
rw [diff_eq, compl_Ici, Ioi_inter_Iio]
intros
simp [‚Üê Ioi_inter_Iio]
intros
simp [add_comm]
intros
cases eq_or_lt_of_le hc
subst c
simp [(nonempty_Icc.2 hab).image_const]
exact image_mul_right_Icc' a b ‚Äπ0 < c‚Ä∫
intros
classical
apply subset.antisymm
simp [Inter_subset]
intros y y_in
simp only [mem_image, mem_Inter, mem_preimage]
rcases hv with ‚ü®z, hz‚ü©
refine ‚ü®function.update z i y, _, update_same i y z‚ü©
rw @forall_update_iff Œπ Œ± _ z i y (Œª i t, t ‚àà v i)
exact ‚ü®y_in, Œª j hj, by simpa using hz j‚ü©
intros
simp only [Union_or, Union_union_distrib, Union_Union_eq_left]
intros
rw [Union_nonempty_index, bUnion_self]
intros
simpa [pairwise, function.on_fun] using @hr a b
intros
ext ‚ü®x‚ü©
erw [quotient.lift_mk f H, Hg]
refl
intros
rw [‚Üêas_string_inv_to_list s, list.as_string_inj, as_string_inv_to_list s]
intros
casesI n
apply int.cast_mul
simp only [coe_coe]
symmetry
erw [fin.coe_mul, ‚Üê nat.cast_mul, ‚Üê sub_eq_zero, ‚Üê nat.cast_sub (nat.mod_le _ _), @char_p.cast_eq_zero_iff R _ _ m]
exact h.trans (nat.dvd_sub_mod _)
intros
refine {..}
refl
refl
intros
refl
intros
refl
intros
simpa only [nsmul_eq_mul, add_right_iterate] using (f.commute_add_int m).iterate_pos_eq_iff_map_eq f.monotone (strict_mono_id.add_const m) hn
intros
simpa only [not_le] using not_congr (f.iterate_pos_le_iff hn)
intros
simp [transnum_aux_seq]
intros
rw [‚Üê translation_number_conj_eq' (translate $ multiplicative.of_add x)]
convert tendsto_translation_number‚ÇÄ _
ext n
simp [sub_eq_neg_add, units.conj_pow']
intros
have A : ‚àÄ m, measurable_set (f^[m] ‚Åª¬π' s) := Œª m, (hf.iterate m).measurable hs
have B : ‚àÄ m, Œº (f^[m] ‚Åª¬π' s) = Œº s
from Œª m, (hf.iterate m).measure_preimage hs
have : Œº (univ : set Œ±) < (finset.range n).sum (Œª m, Œº (f^[m] ‚Åª¬π' s))
simpa only [B, nsmul_eq_mul, finset.sum_const, finset.card_range]
rcases exists_nonempty_inter_of_measure_univ_lt_sum_measure Œº (Œª m hm, A m) this with ‚ü®i, hi, j, hj, hij, x, hxi, hxj‚ü©
wlog hlt : i < j := hij.lt_or_lt using [i j, j i] tactic.skip
simp only [set.mem_preimage, finset.mem_range] at hi hj hxi hxj
refine ‚ü®f^[i] x, hxi, j - i, ‚ü®nat.sub_pos_of_lt hlt, lt_of_le_of_lt (j.sub_le i) hj‚ü©, _‚ü©
rwa [‚Üê iterate_add_apply, nat.sub_add_cancel hlt.le]
exact Œª hi hj hij hxi hxj, this hj hi hij.symm hxj hxi
intros
simp only [mul_comm n, hm.mul_const n]
intros
ext
rw iff_true_right intermediate_field.mem_top
exact dim_adjoin_simple_eq_one_iff.mp (h x)
intros
ext
rw [mem_to_subalgebra, algebra.mem_bot, mem_bot]
intros
rw [‚Üê card_units p, pow_card_eq_one]
intros
let b := basis.of_vector_space K V
rw [‚Üê b.mk_eq_dim'', lt_omega_iff_finite]
split
introI
exact finite_of_linear_independent (basis.of_vector_space_index.linear_independent K V)
assume hbfinite
refine @is_noetherian_of_linear_equiv K (‚ä§ : submodule K V) V _ _ _ _ _ (linear_equiv.of_top _ rfl) (id _)
refine is_noetherian_of_fg_of_noetherian _ ‚ü®set.finite.to_finset hbfinite, _‚ü©
rw [set.finite.coe_to_finset, ‚Üê b.span_eq, basis.coe_of_vector_space, subtype.range_coe]
intros
rw [mul_comm, coeff_expand_mul hp]
intros
obtain ‚ü®p, rfl‚ü© := hq
apply is_coprime_self.mp
have : is_coprime (q * (q * p)) (q * (q.derivative * p + q.derivative * p + q * p.derivative))
simp only [‚Üê mul_assoc, mul_add]
convert hp
rw [derivative_mul, derivative_mul]
ring
exact is_coprime.of_mul_right_left (is_coprime.of_mul_left_left this)
intros
simpa only [field_range_eq_map] using (‚ä§ : subfield K).map_map g f
intros
rw [angle, ‚Üê real_inner_div_norm_mul_norm_eq_one_iff, real.arccos_eq_zero, has_le.le.le_iff_eq, eq_comm]
exact (abs_le.mp (abs_real_inner_div_norm_mul_norm_le_one x y)).2
intros
symmetry
rw [‚Üêh‚ÇÇ, t‚ÇÇ.affine_span_insert_singleton_eq_altitude_iff]
rw [h‚ÇÇ]
use t‚ÇÅ.independent.injective.ne hi‚ÇÅ‚ÇÇ
have he : affine_span ‚Ñù (set.range t‚ÇÇ.points) = affine_span ‚Ñù (set.range t‚ÇÅ.points)
refine ext_of_direction_eq _ ‚ü®t‚ÇÅ.points i‚ÇÉ, mem_affine_span ‚Ñù ‚ü®j‚ÇÉ, h‚ÇÉ‚ü©, mem_affine_span ‚Ñù (set.mem_range_self _)‚ü©
refine eq_of_le_of_finrank_eq (direction_le (span_points_subset_coe_of_subset_coe _)) _
have hu : (finset.univ : finset (fin 3)) = {j‚ÇÅ, j‚ÇÇ, j‚ÇÉ}
clear h‚ÇÅ h‚ÇÇ h‚ÇÉ
dec_trivial!
rw [‚Üêset.image_univ, ‚Üêfinset.coe_univ, hu, finset.coe_insert, finset.coe_insert, finset.coe_singleton, set.image_insert_eq, set.image_insert_eq, set.image_singleton, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ, set.insert_subset, set.insert_subset, set.singleton_subset_iff]
exact ‚ü®t‚ÇÅ.orthocenter_mem_affine_span, mem_affine_span ‚Ñù (set.mem_range_self _), mem_affine_span ‚Ñù (set.mem_range_self _)‚ü©
rw [direction_affine_span, direction_affine_span, t‚ÇÅ.independent.finrank_vector_span (fintype.card_fin _), t‚ÇÇ.independent.finrank_vector_span (fintype.card_fin _)]
rw he
use mem_affine_span ‚Ñù (set.mem_range_self _)
have hu : finset.univ.erase j‚ÇÇ = {j‚ÇÅ, j‚ÇÉ}
clear h‚ÇÅ h‚ÇÇ h‚ÇÉ
dec_trivial!
rw [hu, finset.coe_insert, finset.coe_singleton, set.image_insert_eq, set.image_singleton, h‚ÇÅ, h‚ÇÉ]
have hle : (t‚ÇÅ.altitude i‚ÇÉ).direction·óÆ ‚â§ (affine_span ‚Ñù ({t‚ÇÅ.orthocenter, t‚ÇÅ.points i‚ÇÉ} : set P)).direction·óÆ := submodule.orthogonal_le (direction_le (affine_span_orthocenter_point_le_altitude _ _))
refine hle ((t‚ÇÅ.vector_span_le_altitude_direction_orthogonal i‚ÇÉ) _)
have hui : finset.univ.erase i‚ÇÉ = {i‚ÇÅ, i‚ÇÇ}
clear hle h‚ÇÇ h‚ÇÉ
dec_trivial!
rw [hui, finset.coe_insert, finset.coe_singleton, set.image_insert_eq, set.image_singleton]
refine vsub_mem_vector_span ‚Ñù (set.mem_insert _ _) (set.mem_insert_of_mem _ (set.mem_singleton _))
intros
refine times_cont_mdiff_of_support (Œª x hx, _)
have : x ‚àà (chart_at H c).source := f.closure_support_subset_chart_at_source hx
refine times_cont_mdiff_at.congr_of_eventually_eq _ (f.eq_on_source.eventually_eq_of_mem $ is_open.mem_nhds (chart_at _ _).open_source this)
exact f.to_times_cont_diff_bump.times_cont_diff_at.times_cont_mdiff_at.comp _ (times_cont_mdiff_at_ext_chart_at' this)
intros
obtain ‚ü®s, hsc, hsU‚ü© : ‚àÉ s, countable s ‚àß (‚ãÉ x (hx : x ‚àà s), (chart_at H x).source) = univ := countable_cover_nhds_of_sigma_compact (Œª x : M, is_open.mem_nhds (chart_at H x).open_source (mem_chart_source H x))
exact charted_space.second_countable_of_countable_cover H hsU hsc
intros
have E : e.target ‚à© e.symm ‚Åª¬π' e.source = e.target := subset.antisymm (inter_subset_left _ _) (Œªx hx, ‚ü®hx, local_equiv.target_subset_preimage_source _ hx‚ü©)
simpa [local_equiv.trans_source, E] using c.open_source e e he he
intros
rw [range_comp, image_eq_preimage]
intros
simp
intros
refine ‚ü®h.1.congr h‚ÇÅ hx, _‚ü©
have A : s ‚à© g' ‚Åª¬π' (chart_at H' (g' x)).source = s ‚à© g ‚Åª¬π' (chart_at H' (g' x)).source
ext y
split
assume hy
simp only with mfld_simps at hy
simp only [hy, ‚Üê h‚ÇÅ _ hy.1] with mfld_simps
assume hy
simp only with mfld_simps at hy
simp only [hy, h‚ÇÅ _ hy.1] with mfld_simps
have := h.2
rw [‚Üê hx, ‚Üê A] at this
convert hG.congr _ _ this using 2
assume y hy
simp only with mfld_simps at hy
have : (chart_at H x).symm y ‚àà s
simp only [hy]
simp only [hy, h‚ÇÅ _ this] with mfld_simps
simp only [hx] with mfld_simps
intros
split
intros s x u f hu hux
split
rintros h hx
rcases h hx.1 with ‚ü®e, heG, hef, hex‚ü©
have : s ‚à© u ‚à© e.source ‚äÜ s ‚à© e.source := by mfld_set_tac
exact ‚ü®e, heG, hef.mono this, hex‚ü©
rintros h hx
rcases h ‚ü®hx, hux‚ü© with ‚ü®e, heG, hef, hex‚ü©
refine ‚ü®e.restr (interior u), _, _, _‚ü©
exact closed_under_restriction' heG (is_open_interior)
have : s ‚à© u ‚à© e.source = s ‚à© (e.source ‚à© u) := by mfld_set_tac
simpa only [this, interior_interior, hu.interior_eq] with mfld_simps using hef
simp only [*, interior_interior, hu.interior_eq] with mfld_simps
intros s x f e' he'G he'x h hx
have hxs : x ‚àà s := by simpa only [e'.left_inv he'x] with mfld_simps using hx.2
rcases h hxs with ‚ü®e, heG, hef, hex‚ü©
refine ‚ü®e'.symm.trans e, G.trans (G.symm he'G) heG, _, _‚ü©
intros y hy
simp only with mfld_simps at hy
simp only [hef ‚ü®hy.1.2, hy.2.2‚ü©] with mfld_simps
simp only [hex, he'x] with mfld_simps
intros s x f g hfgs hfg' h hx
rcases h hx with ‚ü®e, heG, hef, hex‚ü©
refine ‚ü®e, heG, _, hex‚ü©
intros y hy
rw [‚Üê hef hy, hfgs y hy.1]
intros s x f e' he'G he' hfx h hx
rcases h hx with ‚ü®e, heG, hef, hex‚ü©
refine ‚ü®e.trans e', G.trans heG he'G, _, _‚ü©
intros y hy
simp only with mfld_simps at hy
simp only [hef ‚ü®hy.1, hy.2.1‚ü©] with mfld_simps
simpa only [hex, hef ‚ü®hx, hex‚ü©] with mfld_simps using hfx
intros
simp only [tangent_map_within, id.def]
rw mfderiv_within_id
rcases p
refl
exact hs
intros
rw [‚Üê times_cont_diff_on_univ, ‚Üê times_cont_mdiff_on_univ, times_cont_mdiff_on_iff_times_cont_diff_on]
intros
assume x
rw [times_cont_mdiff_at, times_cont_mdiff_within_at_iff]
refine ‚ü®Z.to_topological_fiber_bundle_core.continuous_proj.continuous_at.continuous_within_at, _‚ü©
simp only [(‚àò), chart_at, chart] with mfld_simps
apply times_cont_diff_within_at_fst.congr
rintros ‚ü®a, b‚ü© hab
simp only with mfld_simps at hab
simp only [hab] with mfld_simps
simp only with mfld_simps
intros
set L := ((continuous_linear_map.fst ‚Ñù E ‚Ñù).comp (@continuous_linear_map.proj ‚Ñù _ Œπ (Œª _, E √ó ‚Ñù) _ _ (Œª _, infer_instance) (f.ind x hx)))
have := L.has_mfderiv_at.comp x f.embedding_pi_tangent.mdifferentiable_at.has_mfderiv_at
convert has_mfderiv_at_unique this _
refine (has_mfderiv_at_ext_chart_at I (f.mem_chart_at_ind_source x hx)).congr_of_eventually_eq _
refine (f.eventually_eq_one x hx).mono (Œª y hy, _)
simp only [embedding_pi_tangent_coe, continuous_linear_map.coe_comp', (‚àò), continuous_linear_map.coe_fst', continuous_linear_map.proj_apply]
rw [hy, pi.one_apply, one_smul]
intros
rw [left_transversals, set.mem_set_of_eq, is_complement_iff_exists_unique]
refine ‚ü®Œª h g, _, Œª h g, _‚ü©
obtain ‚ü®x, h1, h2‚ü© := h g
exact ‚ü®x.1, (congr_arg (‚àà T) (eq_inv_mul_of_mul_eq h1)).mp x.2.2, Œª y hy, (prod.ext_iff.mp (h2 ‚ü®y, y‚Åª¬π * g, hy‚ü© (mul_inv_cancel_left y g))).1‚ü©
obtain ‚ü®x, h1, h2‚ü© := h g
refine ‚ü®‚ü®x, x‚Åª¬π * g, h1‚ü©, mul_inv_cancel_left x g, Œª y hy, _‚ü©
have := h2 y.1 ((congr_arg (‚àà T) (eq_inv_mul_of_mul_eq hy)).mp y.2.2)
exact prod.ext this (subtype.ext (eq_inv_mul_of_mul_eq ((congr_arg _ this).mp hy)))
intros
convert (submonoid.fg_iff_add_fg P.to_submonoid).symm
exact set_like.ext' rfl
intros
let S : submonoid (free_product M) := ‚ü®set_of C, h_one, h_mul‚ü©
convert subtype.prop (lift (Œª i, of.cod_mrestrict S (h_of i)) m)
change monoid_hom.id _ m = S.subtype.comp _ m
congr
ext
simp [monoid_hom.cod_mrestrict]
intros
rw eq_bot_iff
exact general_commutator_le_left ‚ä• H
intros
rw [‚Üê fintype.card_prod, ‚Üê fintype.card_sigma, fintype.card_congr (sigma_fixed_by_equiv_orbits_prod_group Œ± Œ≤)]
intros
exact {smul_comm := Œª n, @smul_comm _ _ _ _ _ _ (g n) }
intros
rw [‚Üêone_smul R x, ‚Üêsmul_assoc]
exact p.smul_mem _ h
intros
rw r_eq_r' S
refl
intros
intro g
obtain ‚ü®j, hj‚ü© := (hH.to_quotient ((H ‚äì K).comap H.subtype)).of_equiv (quotient_group.quotient_inf_equiv_prod_normal_quotient H K) g
obtain ‚ü®k, hk‚ü© := hK ‚ü®g ^ (p ^ j), (congr_arg (‚àà K) ((H ‚äî K).coe_pow g (p ^ j))).mp ((quotient_group.eq_one_iff (g ^ (p ^ j))).mp ((quotient_group.coe_pow (K.comap (H ‚äî K).subtype) g (p ^ j)).trans hj))‚ü©
rw [subtype.ext_iff, K.coe_pow, subtype.coe_mk, ‚Üêpow_mul, ‚Üêpow_add] at hk
refine ‚ü®j + k, by rwa [subtype.ext_iff, (H ‚äî K).coe_pow]‚ü©
intros
induction s using quot.induction_on
simpa using list.form_perm_eq_self_of_not_mem _ _ hx
intros
refine is_conj_iff.2 ‚ü®equiv.extend_subtype f, _‚ü©
rw mul_inv_eq_iff_eq_mul
ext
simp only [perm.mul_apply]
by_cases hx : x ‚àà œÉ.support
rw [equiv.extend_subtype_apply_of_mem, equiv.extend_subtype_apply_of_mem]
exact hf x (finset.mem_coe.2 hx)
rwa [not_not.1 ((not_congr mem_support).1 (equiv.extend_subtype_not_mem f _ _)), not_not.1 ((not_congr mem_support).mp hx)]
intros
classical
obtain ‚ü®_|i, hi, rfl‚ü© := h.nat'
refine ‚ü®order_of f, order_of_pos f, le_rfl, _‚ü©
rw [pow_order_of_eq_one, pow_zero]
exact ‚ü®i.succ, i.zero_lt_succ, hi.le, rfl‚ü©
intros
by_cases hx : f x = x
rw (cycle_of_eq_one_iff _).mpr hx
simp [hx]
rw [mem_support, cycle_of_apply]
split_ifs with hy
simp only [hx, hy, iff_true, ne.def, not_false_iff, and_self, mem_support]
rcases hy with ‚ü®k, rfl‚ü©
rw ‚Üênot_mem_support
simpa using hx
simpa [hx] using hy
intros
obtain ‚ü®m, rfl‚ü© := exists_add_of_le h
rw [add_comm, cycle_type_fin_rotate]
intros
cases lt_or_ge j.cast_succ i with h h
rw [fin.succ_above_below _ _ h, fin.cycle_range_of_lt h, fin.coe_succ_eq_succ]
rw [fin.succ_above_above _ _ h, fin.cycle_range_of_gt (fin.le_cast_succ_iff.mp h)]
intros
induction n with n ih
simp
rw fin_rotate_succ
simp [ih, pow_succ]
intros
simp [disjoint_iff_eq_or_eq, disjoint_iff, finset.ext_iff, not_and_distrib]
intros
rw is_solvable_def at *
cases h with n hn
use n
rw ‚Üê map_eq_bot_iff_of_injective _ hf
rw eq_bot_iff at *
calc map f (derived_series G n) ‚â§ derived_series G' n : map_derived_series_le_derived_series f n ... ‚â§ ‚ä• : hn
intros
rw set_like.ext'_iff
simp only [coe_bot, set.eq_singleton_iff_unique_mem, set_like.mem_coe, H.one_mem, true_and]
intros
revert a
refine add_submonoid.closure_induction hb _ _ _
clear hb b
exact Œª r hr b hb, S.mul_right_mem_add_closure hb hr
clear hb b
exact Œª b hb, by simp only [mul_zero, (add_submonoid.closure (S : set R)).zero_mem]
clear hb b
simp_rw mul_add
exact Œª r s hr hs b hb, (add_submonoid.closure (S : set R)).add_mem (hr hb) (hs hb)
intros
lift m to multiset S using hm
rw ‚Üê coe_multiset_prod
exact m.prod.coe_prop
intros
simp only [homothety_def, add_smul, vadd_vadd]
intros
rw ‚Üê set.ne_empty_iff_nonempty
rintros rfl
rw affine_subspace.span_empty at h
exact bot_ne_top k V P h
intros
by_contradiction h
rw set.not_nonempty_iff_eq_empty at h
have hlt := sup_direction_lt_of_nonempty_of_inter_empty h1 h2 h
rw hd at hlt
exact not_top_lt hlt
intros
cases inter_nonempty_of_nonempty_of_sup_direction_eq_top h1 h2 hd.sup_eq_top with p hp
use p
ext q
rw set.mem_singleton_iff
split
rintros ‚ü®hq1, hq2‚ü©
have hqp : q -·µ• p ‚àà s1.direction ‚äì s2.direction := ‚ü®vsub_mem_direction hq1 hp.1, vsub_mem_direction hq2 hp.2‚ü©
rwa [hd.inf_eq_bot, submodule.mem_bot, vsub_eq_zero_iff_eq] at hqp
exact Œª h, h.symm ‚ñ∏ hp
intros
simp [vector_span_eq_span_vsub_set_right_ne _ (finset.mem_coe.mpr hp)]
intros
simp [ha]
intros
rw [‚Üê @vsub_eq_zero_iff_eq V, midpoint_vsub_midpoint, midpoint_eq_iff, point_reflection_apply, vsub_eq_sub, zero_sub, vadd_eq_add, add_zero, neg_eq_iff_neg_eq, neg_vsub_eq_vsub_rev, eq_comm]
intros
haveI : nonempty s := hs.to_subtype
simp only [Sup_eq_supr', mem_supr_of_directed _ hdir.directed_coe, set_coe.exists, subtype.coe_mk]
intros
rwa [submodule.map_comap_eq, inf_eq_right]
intros
rw [of_le, ker_cod_restrict, ker_subtype]
intros
rw submodule.mem_map
split
rintros ‚ü®y, hy, hx‚ü©
simp [‚Üêhx, hy]
intros hx
refine ‚ü®e.symm x, hx, by simp‚ü©
intros
cases B
cases D
congr
funext
exact H _ _
intros
simp only [pair_self_adjoint_matrices_submodule, linear_equiv.coe_coe, linear_map.to_matrix'_apply, submodule.mem_map, bilin_form.mem_is_pair_self_adjoint_submodule]
split
rintros ‚ü®f, hf, hA‚ü©
have hf' : f = A.to_lin' := by rw [‚ÜêhA, matrix.to_lin'_to_matrix']
rw hf' at hf
rw ‚Üê is_adjoint_pair_to_bilin'
exact hf
intros h
refine ‚ü®A.to_lin', _, linear_map.to_matrix'_to_lin' _‚ü©
exact (is_adjoint_pair_to_bilin' _ _ _ _).mpr h
intros
ext A x y
simp
intros
rw [B.to_matrix_comp_right b, to_matrix_to_lin]
intros
simpa using lift_dim_map_le f p
intros
rw ‚Üêdim_range_of_surjective f h
apply dim_range_le
intros
convert b.to_dual_apply i j using 2
rw @eq_comm _ j i
intros
exact dim_top F E
intros
apply finsupp.induction_linear l
simp { contextual := tt, }
simp { contextual := tt, }
simp { contextual := tt, }
intros
simp only [total_apply]
apply induction_linear f
simp only [sum_zero_index]
intros f‚ÇÅ f‚ÇÇ h‚ÇÅ h‚ÇÇ
simp [sum_add_index, h‚ÇÅ, h‚ÇÇ, add_smul]
simp [sum_single_index, sum_smul_index, smul_sum, mul_smul]
intros
let a : R := generator (œï.submodule_image N)
let d : R := is_principal.generator (submodule.span R {a, œà ‚ü®y, hNO yN‚ü©})
have d_dvd_left : d ‚à£ a := (mem_iff_generator_dvd _).mp (subset_span (mem_insert _ _))
have d_dvd_right : d ‚à£ œà ‚ü®y, hNO yN‚ü© := (mem_iff_generator_dvd _).mp (subset_span (mem_insert_of_mem _ (mem_singleton _)))
refine dvd_trans _ d_dvd_right
rw [dvd_generator_iff, ideal.span, ‚Üê span_singleton_generator (submodule.span R {a, œà ‚ü®y, hNO yN‚ü©})]
obtain ‚ü®r‚ÇÅ, r‚ÇÇ, d_eq‚ü© : ‚àÉ r‚ÇÅ r‚ÇÇ : R, d = r‚ÇÅ * a + r‚ÇÇ * œà ‚ü®y, hNO yN‚ü©
obtain ‚ü®r‚ÇÅ, r‚ÇÇ', hr‚ÇÇ', hr‚ÇÅ‚ü© := mem_span_insert.mp (is_principal.generator_mem (submodule.span R {a, œà ‚ü®y, hNO yN‚ü©}))
obtain ‚ü®r‚ÇÇ, rfl‚ü© := mem_span_singleton.mp hr‚ÇÇ'
exact ‚ü®r‚ÇÅ, r‚ÇÇ, hr‚ÇÅ‚ü©
let œà' : O ‚Üí‚Çó[R] R := r‚ÇÅ ‚Ä¢ œï + r‚ÇÇ ‚Ä¢ œà
have : span R {d} ‚â§ œà'.submodule_image N
rw [span_le, singleton_subset_iff, set_like.mem_coe, linear_map.mem_submodule_image_of_le hNO]
refine ‚ü®y, yN, _‚ü©
change r‚ÇÅ * œï ‚ü®y, hNO yN‚ü© + r‚ÇÇ * œà ‚ü®y, hNO yN‚ü© = d
rw [d_eq, œïy_eq]
refine le_antisymm (this.trans (le_of_eq _)) (ideal.span_singleton_le_span_singleton.mpr d_dvd_left)
rw span_singleton_generator
refine hœï œà' (le_trans _ this)
rw [‚Üê span_singleton_generator (œï.submodule_image N)]
exact ideal.span_singleton_le_span_singleton.mpr d_dvd_left
exact subset_span (mem_insert _ _)
intros
let P := linear_equiv.fun_congr_left R R (fintype.equiv_fin Œ±)
let Q := linear_equiv.fun_congr_left R R (fintype.equiv_fin Œ≤)
exact le_of_fin_surjective R ((Q.symm.to_linear_map.comp f).comp P.to_linear_map) (((linear_equiv.symm Q).surjective.comp i).comp (linear_equiv.surjective P))
intros
rw [basis, ‚Üê coe_eval_ring_hom, (eval_ring_hom x).map_prod, coe_eval_ring_hom, finset.prod_eq_one]
intros y hy
simp_rw [eval_mul, eval_sub, eval_C, eval_X]
exact inv_mul_cancel (sub_ne_zero_of_ne (finset.ne_of_mem_erase hy).symm)
intros
have : ‚Üë((linear_independent.total_equiv hv : (Œπ ‚Üí‚ÇÄ R) ‚Üí‚Çó[R] span R (range v)) l) = finsupp.total Œπ M R v l := rfl
have : (linear_independent.total_equiv hv : (Œπ ‚Üí‚ÇÄ R) ‚Üí‚Çó[R] span R (range v)) l = x
rw eq at this
exact subtype.ext_iff.2 this
rw ‚Üêlinear_equiv.symm_apply_apply hv.total_equiv l
rw ‚Üêthis
refl
intros
rw basis.to_matrix
ext i j
simp [basis.equiv_fun, matrix.one_apply, finsupp.single, eq_comm]
intros
ext i j
simp [pi.single_apply, one_apply, sub_eq_zero]
intros
rintros ‚ü®a, b‚ü© ‚ü®c, d‚ü© h
simp only [prod.mk.inj_iff, ne.def, not_and_distrib] at h
cases h with hac hbd
simp [hA hac]
simp [hB hbd]
intros
simp_rw [linear_map.to_matrix, linear_equiv.trans_apply, linear_equiv.arrow_congr_comp _ v‚ÇÇ.equiv_fun, linear_map.to_matrix'_comp]
intros
induction L with t L IH
simp
simp only [to_matrix_reindex_equiv, IH, function.comp_app, list.prod_cons, mul_eq_mul, reindex_alg_equiv_apply, list.map]
exact (reindex_alg_equiv_mul _ _ _ _).symm
intros
induction hn : fintype.card n with r IH generalizing n M
refine ‚ü®list.nil, list.nil, Œª _, 1, _‚ü©
ext i j
rw fintype.card_eq_zero_iff at hn
exact hn.elim' i
have e : n ‚âÉ fin r ‚äï unit
refine fintype.equiv_of_card_eq _
rw hn
convert (@fintype.card_sum (fin r) unit _ _).symm
simp
apply reindex_exists_list_transvec_mul_mul_list_transvec_eq_diagonal M e
apply exists_list_transvec_mul_mul_list_transvec_eq_diagonal_induction (Œª N, IH (fin r) N (by simp))
intros
simp [pi_ring, linear_map.lsum]
intros
ext
simp
intros
apply le_antisymm _ (ker_prod_ker_le_ker_coprod f g)
rintros ‚ü®y, z‚ü© h
simp only [mem_ker, mem_prod, coprod_apply] at h ‚ä¢
have : f y ‚àà f.range ‚äì g.range
simp only [true_and, mem_range, mem_inf, exists_apply_eq_apply]
use -z
rwa [eq_comm, map_neg, ‚Üê sub_eq_zero, sub_neg_eq_add]
rw [hd.eq_bot, mem_bot] at this
rw [this] at h
simpa [this] using h
intros
ext x
have : x ‚àà p ‚äî f.ker
simp only [(is_compl_of_proj hf).sup_eq_top, mem_top]
rcases mem_sup'.1 this with ‚ü®x, y, rfl‚ü©
simp [hf]
intros
simp only [discr, to_matrix'_smul, matrix.det_smul]
intros
simp [decidable.imp_iff_not_or, or.comm, or.left_comm]
intros
simp [@eq_comm _ a']
intros
subst hŒ±
have : ‚àÄa, f a == f' a
intro a
exact h a a (heq.refl a)
have : Œ≤ = Œ≤'
funext a
exact type_eq_of_heq (this a)
subst this
apply heq_of_eq
funext a
exact eq_of_heq (this a)
intros
rcases exists_pair_ne Œ± with ‚ü®y, y', h‚ü©
by_cases hx : x = y
rw ‚Üê hx at h
exact ‚ü®y', h.symm‚ü©
exact ‚ü®y, ne.symm hx‚ü©
intros
intros x y h
induction h with z w a b c
refl
apply relation.refl_trans_gen.head (h b) c
intros
induction h generalizing P
exact refl
case refl_trans_gen.tail : b c hab hbc ih { apply ih, show P b _, from head hbc _ refl, show ‚àÄ a a', r a a' ‚Üí refl_trans_gen r a' b ‚Üí P a' _ ‚Üí P a _, from Œª a a' hab hbc, head hab _ }
intros
refine (top_le_iff.1 $ Œª s hs, bUnion_of_singleton s ‚ñ∏ _)
apply measurable_set.bUnion s.countable_encodable
intros x hx
apply measurable_set.of_compl
apply generate_measurable.basic
exact is_closed_singleton.is_open_compl
intros
simp_rw [hu.to_has_basis.liminf_eq_supr_infi]
refine measurable_bsupr _ hu.countable _
exact Œª i, measurable_binfi _ (hs i) hf
intros
rw [‚Üê funext hC, generate_from_pi_eq h2C]
intros
rw ‚Üê pi_univ_Icc
exact pi_Ico_ae_eq_pi_Icc
intros
simp [total_variation, to_jordan_decomposition_zero]
intros
haveI : have_lebesgue_decomposition Œº ŒΩ := ‚ü®‚ü®‚ü®s, f‚ü©, hf, hs, hadd‚ü©‚ü©
obtain ‚ü®hmeas, hsing, hadd'‚ü© := have_lebesgue_decomposition_spec Œº ŒΩ
obtain ‚ü®‚ü®S, hS‚ÇÅ, hS‚ÇÇ, hS‚ÇÉ‚ü©, ‚ü®T, hT‚ÇÅ, hT‚ÇÇ, hT‚ÇÉ‚ü©‚ü© := ‚ü®hs, hsing‚ü©
rw hadd' at hadd
have hŒΩinter : ŒΩ (S ‚à© T)·∂ú = 0
rw set.compl_inter
refine nonpos_iff_eq_zero.1 (le_trans (measure_union_le _ _) _)
rw [hT‚ÇÉ, hS‚ÇÉ, add_zero]
exact le_refl _
have heq : s.restrict (S ‚à© T)·∂ú = (Œº.singular_part ŒΩ).restrict (S ‚à© T)·∂ú
ext1 A hA
have hf : ŒΩ.with_density f (A ‚à© (S ‚à© T)·∂ú) = 0
refine with_density_absolutely_continuous ŒΩ _ _
rw ‚Üê nonpos_iff_eq_zero
exact hŒΩinter ‚ñ∏ measure_mono (set.inter_subset_right _ _)
have hrn : ŒΩ.with_density (Œº.rn_deriv ŒΩ) (A ‚à© (S ‚à© T)·∂ú) = 0
refine with_density_absolutely_continuous ŒΩ _ _
rw ‚Üê nonpos_iff_eq_zero
exact hŒΩinter ‚ñ∏ measure_mono (set.inter_subset_right _ _)
rw [restrict_apply hA, restrict_apply hA, ‚Üê add_zero (s (A ‚à© (S ‚à© T)·∂ú)), ‚Üê hf, ‚Üê add_apply, ‚Üê hadd, add_apply, hrn, add_zero]
have heq' : ‚àÄ A : set Œ±, measurable_set A ‚Üí s A = s.restrict (S ‚à© T)·∂ú A
intros A hA
have hsinter : s (A ‚à© (S ‚à© T)) = 0
rw ‚Üê nonpos_iff_eq_zero
exact hS‚ÇÇ ‚ñ∏ measure_mono (set.subset.trans (set.inter_subset_right _ _) (set.inter_subset_left _ _))
rw [restrict_apply hA, ‚Üê add_zero (s (A ‚à© (S ‚à© T)·∂ú)), ‚Üê hsinter, ‚Üê measure_union, ‚Üê set.inter_union_distrib_left, set.compl_union_self, set.inter_univ]
exact disjoint.inter_left' _ ( disjoint.inter_right' _ disjoint_compl_left)
measurability
ext1 A hA
have hŒºinter : Œº.singular_part ŒΩ (A ‚à© (S ‚à© T)) = 0
rw ‚Üê nonpos_iff_eq_zero
exact hT‚ÇÇ ‚ñ∏ measure_mono (set.subset.trans (set.inter_subset_right _ _) (set.inter_subset_right _ _))
rw [heq' A hA, heq, ‚Üê add_zero ((Œº.singular_part ŒΩ).restrict (S ‚à© T)·∂ú A), ‚Üê hŒºinter, restrict_apply hA, ‚Üê measure_union, ‚Üê set.inter_union_distrib_left, set.compl_union_self, set.inter_univ]
exact disjoint.inter_left' _ ( disjoint.inter_right' _ disjoint_compl_left)
measurability
intros
convert supr_mem_measurable_le f hf n
ext
simp
intros
rw pair_eq_mk
apply coe_fn_mk
intros
ext1
refine (mem_‚Ñíp.coe_fn_to_Lp _).trans _
refine eventually_eq.trans _ (Lp.coe_fn_add _ _).symm
refine eventually_eq.trans _ (eventually_eq.add (mem_‚Ñíp.coe_fn_to_Lp _).symm (mem_‚Ñíp.coe_fn_to_Lp _).symm)
rw condexp_ind_smul_add
refine (Lp.coe_fn_add _ _).trans (eventually_of_forall (Œª a, _))
refl
intros
rw Lp.simple_func.coe_indicator_const
exact condexp_L1_clm_indicator_const_Lp hs hŒºs x
intros
rw set_integral_congr_ae (hm s hs) ((condexp_ae_eq_condexp_L1 f).mono (Œª x hx _, hx))
exact set_integral_condexp_L1 hf hs
intros
suffices h_nnnorm_eq_zero : ‚à´‚Åª x in s, ‚à•condexp_L2 ‚Ñù hm f x‚à•‚Çä ‚àÇŒº = 0
rw lintegral_eq_zero_iff at h_nnnorm_eq_zero
refine h_nnnorm_eq_zero.mono (Œª x hx, _)
dsimp only at hx
rw pi.zero_apply at hx ‚ä¢
rwa [ennreal.coe_eq_zero, nnnorm_eq_zero] at hx
refine measurable.coe_nnreal_ennreal (measurable.nnnorm _)
rw Lp_meas_coe
exact Lp.measurable _
refine le_antisymm _ (zero_le _)
refine (lintegral_nnnorm_condexp_L2_le hs hŒºs f).trans (le_of_eq _)
rw lintegral_eq_zero_iff
refine hf.mono (Œª x hx, _)
dsimp only
rw hx
simp
exact (Lp.measurable _).nnnorm.coe_nnreal_ennreal
intros
rw [norm_def, norm_def, ennreal.to_real_le_to_real (snorm_ne_top _) (snorm_ne_top _)]
exact snorm_mono_ae h
intros
rw [snorm', ‚Üêennreal.rpow_mul, one_div, inv_mul_cancel, ennreal.rpow_one]
exact (ne_of_lt hq0_lt).symm
intros
rw [snorm', div_zero, ennreal.rpow_zero]
intros
cases le_or_lt 0 q with hq0 hq_neg
exact snorm'_zero (lt_of_le_of_ne hq0 hq0_ne.symm)
simp [snorm', ennreal.rpow_eq_zero_iff, hŒº, hq_neg]
intros
refine Lp.mem_Lp_of_ae_bound (‚à•f‚à•) _
filter_upwards [f.to_continuous_map.coe_fn_to_ae_eq_fun Œº]
intros x hx
convert f.norm_coe_le_norm x
intros
simp [eventually_eq, snorm_ess_sup]
intros
simp_rw ess_sup
exact limsup_trim hm hf
intros
let fs := simple_func.approx_on f hf_meas set.univ 0 (set.mem_univ _)
refine ‚ü®fs, _, _‚ü©
have h_fs_Lp : ‚àÄ n, mem_‚Ñíp (fs n) p Œº
from simple_func.mem_‚Ñíp_approx_on_univ hf_meas hf
exact Œª n, (fs n).measure_support_lt_top_of_mem_‚Ñíp (h_fs_Lp n) hp_ne_zero hp_ne_top
exact Œª x, simple_func.tendsto_approx_on hf_meas (set.mem_univ 0) (by simp)
intros
rw L1.norm_eq_integral_norm
refine integral_congr_ae _
apply hf.coe_fn_to_L1.mono
intros a ha
simp [ha]
intros
simp [integral_congr_ae hf, integral_zero]
intros
rw [‚Üê indicator_eq_self.2 (@subset_closure _ _ (support f)), integrable_indicator_iff is_closed_closure.measurable_set]
exact hf.integrable_on_compact hfc
apply_instance
intros
simpa [mul_comm] using hf.mul_continuous_on_of_subset hg hs ht hst
intros
rw show (Œª x, ‚à´ t in Icc a x, f t ‚àÇŒº) = Œª x, ‚à´ t in Ioc a x, f t ‚àÇŒº, by { ext x, exact integral_Icc_eq_integral_Ioc }
exact continuous_on_primitive h_int
intros
simpa [mul_comm] using hf.mul_continuous_on hg
intros
simpa only [sub_eq_add_neg] using integral_comp_add_right f (-d)
intros
convert (monotone_lintegral Œº).map_infi2_le f
ext1 a
simp only [infi_apply]
intros
by_cases h : r = 0
simp [h]
apply le_antisymm _ (lintegral_const_mul_le r f)
have rinv : r * r‚Åª¬π = 1 := ennreal.mul_inv_cancel h hr
have rinv' : r ‚Åª¬π * r = 1
rw mul_comm
exact rinv
have := lintegral_const_mul_le (r‚Åª¬π) (Œªx, r * f x)
simp [(mul_assoc _ _ _).symm, rinv'] at this
simpa [(mul_assoc _ _ _).symm, rinv] using mul_le_mul_left' this r
intros
simp [lintegral_const_mul'' _ hg, lintegral_mul_const'' _ hf]
intros
simp [hs, indicator_preimage_of_not_mem _ _ ht, inter_comm]
intros
haveI := function.is_empty f
exact measurable_of_empty f
intros
apply div_pos
norm_cast
apply index_pos ‚ü®K, h1K, h2K‚ü© hU
norm_cast
exact index_pos K‚ÇÄ hU
intros
let eval : (compacts G ‚Üí ‚Ñù) ‚Üí ‚Ñù := Œª f, f (K.map _ $ continuous_mul_left g) - f K
have : continuous eval := (continuous_apply (K.map _ _)).sub (continuous_apply K)
rw [‚Üê sub_eq_zero]
show chaar K‚ÇÄ ‚àà eval ‚Åª¬π' {(0 : ‚Ñù)}
apply mem_of_subset_of_mem _ (chaar_mem_cl_prehaar K‚ÇÄ ‚ü®set.univ, is_open_univ, mem_univ _‚ü©)
unfold cl_prehaar
rw is_closed.closure_subset_iff
rintro _ ‚ü®U, ‚ü®h1U, h2U, h3U‚ü©, rfl‚ü©
simp only [mem_singleton_iff, mem_preimage, eval, sub_eq_zero]
apply is_left_invariant_prehaar
rw h2U.interior_eq
exact ‚ü®1, h3U‚ü©
apply continuous_iff_is_closed.mp this
exact is_closed_singleton
intros
rw [‚Üê hf.hausdorff_measure_image hd, image_preimage_eq_inter_range]
intros
ext t
simp only [mem_inf_principal, mem_ae_iff, restrict_apply_eq_zero' hs, compl_set_of, not_imp, and_comm (_ ‚àà s)]
refl
intros
simp only [ae_restrict_eq hs, exists_prop, mem_principal, mem_inf_iff]
exact ‚ü®_, univ_mem, s, subset.rfl, (univ_inter s).symm‚ü©
intros
haveI : is_finite_measure ŒΩ := begin constructor, rw ‚Üê h_univ, apply is_finite_measure.measure_univ_lt_top, end
refine induction_on_inter hA hC (by simp) hŒºŒΩ _ _ hs
intros t h1t h2t
have h1t_ : @measurable_set Œ± m‚ÇÄ t
from h _ h1t
rw [@measure_compl Œ± m‚ÇÄ Œº t h1t_ (@measure_ne_top Œ± m‚ÇÄ Œº _ t), @measure_compl Œ± m‚ÇÄ ŒΩ t h1t_ (@measure_ne_top Œ± m‚ÇÄ ŒΩ _ t), h_univ, h2t]
intros f h1f h2f h3f
have h2f_ : ‚àÄ (i : ‚Ñï), @measurable_set Œ± m‚ÇÄ (f i)
from (Œª i, h _ (h2f i))
have h_Union : @measurable_set Œ± m‚ÇÄ (‚ãÉ (i : ‚Ñï), f i)
from @measurable_set.Union Œ± ‚Ñï m‚ÇÄ _ f h2f_
simp [measure_Union, h_Union, h1f, h3f, h2f_]
intros
refine ‚ü®_, Œª h, h.filter_mono inf_le_left‚ü©
rintros ‚ü®s, ‚ü®t, ht, u, hu, rfl‚ü©, hŒº‚ü©
suffices : Œº t ‚â§ Œº (t ‚à© u)
from ‚ü®t, ht, this.trans_lt hŒº‚ü©
exact measure_mono_ae (mem_of_superset hu (Œª x hu ht, ‚ü®ht, hu‚ü©))
intros
rw [measure_eq_induced_outer_measure, induced_outer_measure_eq_extend _ _ hs]
exact Œº.m_Union
intros
simp [eventually_le_antisymm_iff, ae_le_set, union_diff_right, diff_eq_empty.2 (set.subset_union_right _ _)]
intros
rcases eq_or_lt_of_le h with rfl|hxy
exact le_rfl
exact (f.left_lim_le le_rfl).trans (f.le_left_lim hxy)
intros
intros s hs
rw [neg_apply, neg_eq_zero] at hs
exact h hs
intros
rw [ppow, dif_pos rfl]
intros
rw [mul_comm, coe_moebius_mul_coe_zeta]
ext
simp [nat.mul_eq_one_iff, prod.ext_iff]
intros
simp only [l_series, add_apply]
rw ‚Üê tsum_add hf hg
apply congr rfl (funext (Œª n, _))
apply _root_.add_div
intros
by_cases h0 : m = 0
subst h0
have hf : f = 0 := arithmetic_function.ext (Œª n, complex.abs_eq_zero.1 (le_antisymm (h n) (complex.abs_nonneg _)))
simp [hf]
refine summable_of_norm_bounded (Œª (n : ‚Ñï), m / (n ^ z)) _ _
simp_rw [div_eq_mul_inv]
exact (summable_mul_left_iff h0).1 (real.summable_nat_rpow_inv.2 hz)
intro n
have hm : 0 ‚â§ m := le_trans (complex.abs_nonneg _) (h 0)
cases n
simp [hm, real.zero_rpow (ne_of_gt (lt_trans real.zero_lt_one hz))]
simp only [complex.abs_div, complex.norm_eq_abs]
apply div_le_div hm (h _) (real.rpow_pos_of_pos (nat.cast_pos.2 n.succ_pos) _) (le_of_eq _)
rw [complex.abs_cpow_real, complex.abs_cast_nat]
intros
obtain ‚ü®k, hk‚ü© := @exists_pow_neg_lt p _ Œµ (by exact_mod_cast hŒµ)
use k
rw (show (p : ‚Ñù) = (p : ‚Ñö), by simp) at hk
exact_mod_cast hk
intros
unfold padic_val_rat
split_ifs
simp *
intros
injection (pell_zd_sub _ h) with h _
repeat {rw ‚Üê neg_mul_eq_mul_neg at h}
exact h
intros
by_cases h0 : int.gcd x y = 0
have hx : x = 0
apply int.nat_abs_eq_zero.mp
apply nat.eq_zero_of_gcd_eq_zero_left h0
have hy : y = 0
apply int.nat_abs_eq_zero.mp
apply nat.eq_zero_of_gcd_eq_zero_right h0
use [0, 1, 0]
norm_num [hx, hy]
apply h.is_classified_of_normalize_is_primitive_classified
apply h.normalize.is_primitive_classified_of_coprime
apply int.gcd_div_gcd_div_gcd (nat.pos_of_ne_zero h0)
intros
simp [ext]
intros
simp [bit1]
intros
rw disjoint_iff at w
rw [‚Üêw, right_eq_inf]
rwa sup_eq_left at h
intros
exact is_least_singleton.union hs
intros
ext
refl
intros
simp only [disjoint_iff, supr_inf_eq, supr_eq_bot]
intros
simpa only [range_comp, subtype.range_coe, supr_subtype'] using @is_lub_supr Œ± s _ (f ‚àò coe)
intros
simp
intros
simp
intros
apply tendsto_at_top.2 (Œªb, _)
obtain ‚ü®n : ‚Ñï, hn : 1 ‚â§ n ‚Ä¢ r‚ü© := archimedean.arch 1 hr
have hn' : 1 ‚â§ (n : R) * r
rwa nsmul_eq_mul at hn
filter_upwards [tendsto_at_top.1 hf (max b 0 * n)]
assume x hx
calc b ‚â§ max b 0 * 1 : by { rw [mul_one], exact le_max_left _ _ } ... ‚â§ max b 0 * (n * r) : mul_le_mul_of_nonneg_left hn' (le_max_right _ _) ... = (max b 0 * n) * r : by rw [mul_assoc] ... ‚â§ f x * r : mul_le_mul_of_nonneg_right hx (le_of_lt hr)
intros
apply le_antisymm
intros U U_in
rcases B.mem_filter_iff.mp U_in with ‚ü®V, V_in, h‚ü©
exact generate_sets.superset (generate_sets.basic V_in) h
rw sets_iff_generate
apply mem_filter_of_mem
intros
rw inf_comm
exact inf_ne_bot_iff_frequently_left
intros
simp only [tendsto, le_pure_iff, mem_map', mem_singleton_iff, filter.eventually]
intros
rw [filter.prod, comap_infi, inf_infi]
simp only [filter.prod, eq_self_iff_true]
intros
simp [upper_bounds, gc _ _]
intros
rw [sup_eq_right, ‚Üêinf_eq_left]
intros
dsimp [continuous] at *
intro
rw [hfc,hgc,chain.map_comp]
intros
induction n with n ih
simp
dsimp [partial_sups] at ih ‚ä¢
simp_rw @finset.range_succ n.succ
rw [ih, finset.sup'_insert, sup_comm]
intros
ext
refl
intros
simp only [(Œî), sdiff_eq]
intros
rw [sdiff_symm_diff, sdiff_sup, sup_comm]
intros
classical
revert hf
apply f.induction_on
intro h
simp [set.is_pwo_empty.is_wf]
intros s f sf hf hsf
rw finset.sup_insert
exact (hsf s (finset.mem_insert_self _ _)).union (hf (Œª s' s'f, hsf _ (finset.mem_insert_of_mem s'f)))
intros
rw [‚Üê algebra_map_eq, ‚Üê aeval_def, aeval_eq, mk_self]
intros
rw [is_artinian_iff_well_founded]
exact (well_founded.monotone_chain_condition (order_dual (submodule R M))).symm
intros
refine ‚ü®Œª h, _, algebra.finite_type.of_finite_presentation‚ü©
obtain ‚ü®n, f, hf‚ü© := algebra.finite_type.iff_quotient_mv_polynomial''.1 h
refine ‚ü®n, f, hf, _‚ü©
have hnoet : is_noetherian_ring (mv_polynomial (fin n) R) := by apply_instance
replace hnoet := (is_noetherian_ring_iff.1 hnoet).noetherian
exact hnoet f.to_ring_hom.ker
intros
letI := f.to_algebra
exact module.finite.of_surjective (algebra.of_id A B).to_linear_map hf
intros
intros x hx
convert submodule.zero_mem _
simpa using hx
intros
rw [‚Üê add_zero a, single_mul_coeff_add, add_zero]
intros
contrapose! h
rw ‚Üê C_zero at h
exact C_injective h
intros
by_cases h : r = 0
rw [h, C_zero, order_zero]
exact order_single h
intros
rw [radical_eq_Inf, radical_eq_Inf]
have : ‚àÄ J ‚àà {J : ideal R | I ‚â§ J ‚àß J.is_prime}, f.ker ‚â§ J := Œª J hJ, le_trans h hJ.left
convert map_Inf hf this
refine funext (Œª j, propext ‚ü®_, _‚ü©)
rintros ‚ü®hj, hj'‚ü©
haveI : j.is_prime := hj'
exact ‚ü®comap f j, ‚ü®‚ü®map_le_iff_le_comap.1 hj, comap_is_prime f j‚ü©, map_comap_of_surjective f hf j‚ü©‚ü©
rintro ‚ü®J, ‚ü®hJ, hJ'‚ü©‚ü©
haveI : J.is_prime := hJ.right
refine ‚ü®hJ' ‚ñ∏ map_mono hJ.left, hJ' ‚ñ∏ map_is_prime_of_surjective hf (le_trans h hJ.left)‚ü©
intros
induction n with n ih
simp [set.singleton_one]
simp only [pow_succ, ih, span_singleton_mul_span_singleton]
intros
apply unique_factorization_monoid.induction_on_prime
exact h‚ÇÄ
intros n h
rw nat.is_unit_iff.1 h
exact h‚ÇÅ
intros a p _ hp ha
exact h p a (nat.prime_iff.2 hp) ha
intros
haveI : decidable_eq R := classical.dec_eq _
refine le_trans _ (nth_roots n (f g‚ÇÄ)).to_finset_card_le
apply card_le_card_of_inj_on f
intros g hg
rw [sep_def, mem_filter] at hg
rw [multiset.mem_to_finset, mem_nth_roots hn, ‚Üê f.map_pow, hg.2]
intros
apply hf
assumption
intros
letI : is_fraction_ring (integral_closure R L) L := is_fraction_ring_of_finite_extension K L
exact (integral_closure_eq_bot_iff L).mp integral_closure_idem
intros
rw [is_noetherian_ring_iff, is_noetherian_iff_well_founded] at h ‚ä¢
exact order_embedding.well_founded ((is_localization.order_embedding M S).dual) h
intros
rw [enat.get_eq_iff_eq_coe, eq_coe_iff, pow_zero]
simpa [is_unit_iff_dvd_one.symm] using not_unit_of_finite ha
intros
rcases lt_trichotomy (multiplicity p a) (multiplicity p b) with hab|hab|hab
rw [add_comm, multiplicity_add_of_gt hab, min_eq_left]
exact le_of_lt hab
contradiction
rw [multiplicity_add_of_gt hab, min_eq_right]
exact le_of_lt hab
intros
refine le_antisymm _ (submodule.smul_le.2 (Œª _ _ _, submodule.smul_mem _ _))
intros n hn
cases submodule.exists_sub_one_mem_and_smul_eq_zero_of_fg_of_le_smul I N hN hIN with r hr
cases exists_mul_sub_mem_of_sub_one_mem_jacobson r (hIjac hr.1) with s hs
have : n = (-(r * s - 1) ‚Ä¢ n)
rw [neg_sub, sub_smul, mul_comm, mul_smul, hr.2 n hn, one_smul, smul_zero, sub_zero]
rw this
exact submodule.smul_mem_smul (submodule.neg_mem _ hs) hn
intros
obtain ‚ü®n, hn‚ü© := h
use n
rw [neg_pow, hn, mul_zero]
intros
intros v hv
rcases submodule.mem_sup.1 hv with ‚ü®x, hx, y, hy, hxy‚ü©
have h_eval_x : aeval f (p * q) x = 0
rw [mul_comm, aeval_mul, linear_map.mul_apply, linear_map.mem_ker.1 hx, linear_map.map_zero]
have h_eval_y : aeval f (p * q) y = 0
rw [aeval_mul, linear_map.mul_apply, linear_map.mem_ker.1 hy, linear_map.map_zero]
rw [linear_map.mem_ker, ‚Üêhxy, linear_map.map_add, h_eval_x, h_eval_y, add_zero]
intros
simp only [function.comp_app, ring_hom.coe_comp, ideal.quotient.eq_zero_iff_mem]
exact ideal.mem_map_of_mem _ hi
intros
rw [bernstein_polynomial.iterate_derivative_at_1 _ _ _ h, ne.def, neg_one_pow_mul_eq_zero_iff, ‚Üênat.cast_succ, ‚Üêpochhammer_eval_cast, ‚Üênat.cast_zero, nat.cast_inj]
exact (pochhammer_pos _ _ (nat.succ_pos ŒΩ)).ne'
intros
rw [‚Üê one_mul p.prim_part, ‚Üê C_1, ‚Üê hp.content_eq_one, ‚Üê p.eq_C_content_mul_prim_part]
intros
rw content
by_cases h0 : r = 0
simp [h0]
have h : (C r).support = {0} := support_monomial _ _ h0
simp [h]
intros
simp only [cyclotomic', finset.prod_singleton, ring_hom.map_one, is_primitive_root.primitive_roots_one]
intros
rw [polynomial.aeval_def, polynomial.aeval_def, polynomial.eval‚ÇÇ_map, algebra_map_eq R S A]
intros
conv_rhs { rw ‚Üê span_singleton_generator S }
exact subset_span (mem_singleton _)
intros
apply is_unit_of_mul_eq_one Œ∂ (Œ∂ ^ (k - 1))
rw [‚Üê pow_succ, nat.sub_add_cancel h0, h.pow_eq_one]
intros
apply finset.eq_singleton_iff_unique_mem.2
split
simp only [is_primitive_root.one_right_iff, mem_primitive_roots zero_lt_one]
intros x hx
rw [mem_primitive_roots zero_lt_one, is_primitive_root.one_right_iff] at hx
exact hx
intros
obtain ‚ü®q, hq, hpq‚ü© := exists_mem_factors_of_dvd ha0 hp hd
apply multiset.mem_pmap.mpr
use q
use hq
exact subtype.eq (eq.symm (mk_eq_mk_iff_associated.mpr hpq))
intros
rw factors_mk _ ha0
exact mem_factor_set_some.mpr (mem_factors'_of_dvd ha0 hp hd)
intros
ext ‚ü®‚ü©
{ rw zero_coeff, refl }
rw zero_coeff
refl
intros
ext ‚ü®-, -‚ü©
exact f.map_zero
refl
intros
split
rintro ‚ü®f‚ü©
refine ‚ü®f $ sum.inl ‚ü®‚ü©, f $ sum.inr ‚ü®‚ü©, _‚ü©
intro h
cases f.2 h
rintro ‚ü®x, y, h‚ü©
by_contra h'
rw [not_le, ‚Üênat.cast_two, nat_succ, lt_succ, nat.cast_one, le_one_iff_subsingleton] at h'
apply h
exactI subsingleton.elim _ _
intros
rw [‚Üê not_le, succ_le, not_lt]
intros
refine quot.induction_on c (Œª Œ±, _) (lt_succ_self c)
refine quot.induction_on (succ (quot.mk setoid.r Œ±)) (Œª Œ≤ h, _)
cases h.left with f
have : ¬¨ surjective f := Œª hn, ne_of_lt h (quotient.sound ‚ü®equiv.of_bijective f ‚ü®f.injective, hn‚ü©‚ü©)
cases not_forall.1 this with b nex
refine ‚ü®‚ü®sum.rec (by exact f) _, _‚ü©‚ü©
exact Œª _, b
intros a b h
rcases a with a|‚ü®‚ü®‚ü®‚ü©‚ü©‚ü©
rcases b with b|‚ü®‚ü®‚ü®‚ü©‚ü©‚ü©
rw f.injective h
exact nex.elim ‚ü®_, h‚ü©
rcases b with b|‚ü®‚ü®‚ü®‚ü©‚ü©‚ü©
exact nex.elim ‚ü®_, h.symm‚ü©
refl
intros
dsimp [sup]
cases min_eq _ _ with c hc
rw hc
exact c.2 i
intros
simp [bit0, add_lt_omega_iff]
intros
cases x
cases y
refl
intros
split
intro hi
unfold1 impartial_aux at hi
exact hi
intro hi
unfold1 impartial_aux
exact hi
intros
rw subsingleton.elim f (principal_seg.equiv_lt e g)
refl
intros
cases x with xl xr xL xR
exact o.2.2 j
intros
simp [prl, prr, prt]
intros
cases x
cases y
refl
intros
cases x
cases y
refl
intros
simp *
intros
rw normalize_fin
norm_num
intros
simpa [normalize_fin_lt, ‚Üê e] using h
intros
rwa [‚Üê h‚ÇÅ, ‚Üê mul_assoc, div_mul_cancel _ h‚ÇÄ]
intros
rw [prl, prr, prt]
intros
rw [‚Üê H, ‚Üê h‚ÇÇ, ‚Üê h‚ÇÅ, ‚Üê h‚ÇÉ, ‚Üê h‚ÇÑ]
simp [horner, mul_add, mul_comm, mul_left_comm, mul_assoc]
intros
simp [horner, mul_comm]
intros
induction xs
apply h
unfold_wf
simp only [list.sizeof, add_lt_add_iff_left]
exact xs_ih
intros
rcases hs with ‚ü®S, Sopen, Scount, rfl‚ü©
rcases ht with ‚ü®T, Topen, Tcount, rfl‚ü©
rw [sInter_union_sInter]
apply is_GŒ¥_bInter_of_open (Scount.prod Tcount)
rintros ‚ü®a, b‚ü© hab
exact is_open.union (Sopen a hab.1) (Topen b hab.2)
intros
rw [dense_range, ‚Üê compl_infty]
exact dense_compl_singleton _
intros
simpa [(hf'.has_sum.sigma hf).unique ha] using hf'.has_sum
intros
by_cases hP : P
simp [hP]
simp [hP]
intros
convert hf.update b 0 using 1
ext n
rw function.update_apply
rw [sub_add_eq_add_sub, zero_add]
intros
rw [‚Üêhas_sum_zero_iff, hf.has_sum_iff]
intros
ext
simp
intros
simp only [ext_iff, pi_apply, function.funext_iff]
exact forall_swap
intros
refine tendsto_at_top_mono' _ _ (hf.at_top_mul_const (half_pos hC))
filter_upwards [hg.eventually (lt_mem_nhds (half_lt_self hC)), hf.eventually (eventually_ge_at_top 0)]
exact Œª x hg hf, mul_le_mul_of_nonneg_left hg.le hf
intros
simpa only [mul_comm] using hg.at_bot_mul hC hf
intros
rw [‚Üê map_coe_Iio_at_top, tendsto_map'_iff]
intros
rw image_preimage_eq_inter_range
exact hf.open_subset_closure_inter hs
intros
rw [‚Üê is_open_compl_iff, compl_univ]
exact is_open_empty
intros
rw subset.antisymm subset_closure h
exact is_closed_closure
intros
rw [frontier, hs.interior_eq]
intros
simp [closure_eq_cluster_pts, cluster_pt, ‚Üê exists_ultrafilter_iff, and.comm]
intros
rw [nhds_within, principal_singleton, inf_eq_right.2 (pure_le_nhds a)]
intros
rw [di.nhds_eq_comap a, ((nhds_basis_opens _).comap _).mem_iff] at hs
rcases hs with ‚ü®U, ‚ü®haU, hUo‚ü©, sub : i ‚Åª¬π' U ‚äÜ s‚ü©
refine mem_of_superset (hUo.mem_nhds haU) _
calc U ‚äÜ closure (i '' (i ‚Åª¬π' U)) : di.dense.subset_closure_image_preimage_of_is_open hUo ... ‚äÜ closure (i '' s) : closure_mono (image_subset i sub)
intros
ext
refl
intros
convert ‚Üêhf.closed_iff_image_closed.symm
rwa [image_preimage_eq_inter_range, inter_eq_self_of_subset_left]
intros
rw [diam, ediam_of_unbounded h, ennreal.top_to_real]
intros
rw [‚Üê not_nonempty_iff_eq_empty, nonempty_ball, not_lt]
intros
convert metric.emetric_ball
simp
intros
refine or_iff_not_imp_right.2 (Œª h, edist_le_zero.1 _)
simpa only [hx.eq, edist_self, add_zero, ennreal.zero_div] using hf.edist_le_of_fixed_point h hy
intros
refine ‚ü®Œª H Œµ hŒµ, H _ (edist_mem_uniformity hŒµ), Œª H u hu x hx, _‚ü©
rcases mem_uniformity_edist.1 hu with ‚ü®Œµ, Œµpos, hŒµ‚ü©
rcases H Œµ Œµpos x hx with ‚ü®t, ht, Ht‚ü©
exact ‚ü®t, ht, Ht.mono (Œª n hs x hx, hŒµ (hs x hx))‚ü©
intros
rw ‚Üê image_univ
refine dimH_image_le_of_locally_lipschitz_on (Œª x _, _)
simpa only [exists_prop, nhds_within_univ] using hf x
intros
rw [‚Üê e.dimH_preimage univ, preimage_univ]
intros
simp only [Hausdorff_edist, sup_le_iff, supr_le_iff]
exact ‚ü®H1, H2‚ü©
intros
simp [inf_dist, inf_edist_image hŒ¶]
intros
intros x hx y hy
rw [ennreal.coe_mul, mul_comm rg, nnreal.coe_mul, ennreal.rpow_mul, mul_assoc, ‚Üê ennreal.coe_rpow_of_nonneg _ rg.coe_nonneg, ‚Üê ennreal.mul_rpow_of_nonneg _ _ rg.coe_nonneg]
exact hg.edist_le_of_le (hst hx) (hst hy) (hf.edist_le hx hy)
intros
assume x y
rw [ennreal.coe_mono.map_max, prod.edist_eq, ennreal.max_mul]
exact max_le_max (hf x y) (hg x y)
intros
rcases ‚ü®h, h'‚ü© with ‚ü®‚ü®r, r0, hr‚ü©, ‚ü®r', r0', hr'‚ü©‚ü©
refine ‚ü®min r r', _, Œª x hx y hy, hx.elim _ _‚ü©
rw [‚Üê pos_iff_ne_zero] at r0 r0' ‚ä¢
exact lt_min r0 r0'
exact Œª hx, (min_le_left _ _).trans (hr _ hx _ hy)
exact Œª hx, (min_le_right _ _).trans (hr' _ hx _ hy)
intros
rw induced_generate_from_eq
apply le_generate_from
simp only [mem_image, and_imp, forall_apply_eq_imp_iff‚ÇÇ, exists_imp_distrib]
exact h
intros
simp only [mem_nhds_iff, is_open_induced_iff, exists_prop, set.mem_set_of_eq]
split
rintros ‚ü®u, usub, ‚ü®v, openv, ueq‚ü©, au‚ü©
exact ‚ü®v, ‚ü®v, set.subset.refl v, openv, by rwa ‚Üêueq at au‚ü©, by rw ueq; exact usub‚ü©
rintros ‚ü®u, ‚ü®v, vsubu, openv, amem‚ü©, finvsub‚ü©
exact ‚ü®f ‚Åª¬π' v, set.subset.trans (set.preimage_mono vsubu) finvsub, ‚ü®‚ü®v, openv, rfl‚ü©, amem‚ü©‚ü©
intros
simp only [‚Üê lower_semicontinuous_within_at_univ_iff] at hf ‚ä¢
exact hg.comp_lower_semicontinuous_within_at hf gmon
intros
simp [upper_semicontinuous_on, upper_semicontinuous, upper_semicontinuous_within_at_univ_iff]
intros
rw is_open_iff_ultrafilter
refine ‚ü®Œª h F hF, h F.Lim hF F F.le_nhds_Lim, _‚ü©
intros cond x hx f h
rw [‚Üê (ultrafilter.Lim_eq_iff_le_nhds.2 h)] at hx
exact cond _ hx
intros
wlog hle : v‚ÇÅ ‚â§ v‚ÇÇ := hc.total_of_refl h‚ÇÅ h‚ÇÇ using [v‚ÇÅ v‚ÇÇ, v‚ÇÇ v‚ÇÅ]
exact hle.2 _ hi‚ÇÅ
intros
rw uniform_space.mem_nhds_iff
split
rintros ‚ü®V, V_in, V_sub‚ü©
use [symmetrize_rel V, symmetrize_mem_uniformity V_in, symmetric_symmetrize_rel V]
exact subset.trans (ball_mono (symmetrize_rel_subset_self V) x) V_sub
rintros ‚ü®V, V_in, V_symm, V_sub‚ü©
exact ‚ü®V, V_in, V_sub‚ü©
intros
simp_rw [mem_closure_iff_nhds, uniform_space.mem_nhds_iff]
split
intros h V V_in
exact h (ball x V) ‚ü®V, V_in, subset.refl _‚ü©
rintros h t ‚ü®V, V_in, Vt‚ü©
exact nonempty.mono (inter_subset_inter_left s Vt) (h V_in)
intros
simp [tendsto_uniformly_on, tendsto_uniformly]
intros
rw topological_fiber_bundle.trivialization.mem_source
apply mem_base_set_trivialization_at
