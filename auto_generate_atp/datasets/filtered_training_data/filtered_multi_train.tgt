intros
cases b; unfold write write'; simp [array.write_eq_write']
cases b; unfold write write'
cases b
unfold write write'
simp [array.write_eq_write']
intros
cases v
cases w
reflexivity
intros
cases x; cases x'; simp * at *
cases x; cases x'
cases x
cases x'
simp * at *
intros
rw [int.add_comm, int.add_left_neg]
intros
have h := int.add_le_add_right h b
rwa int.sub_add_cancel at h
intros
refine nat.eq_of_mul_eq_mul_left dec_trivial (nat.add_left_cancel (eq.trans _ (nat.mod_add_div n 2).symm))
rw [mod_two_of_bodd, bodd_add_div2]
intros
rw [nat.mul_comm, add_mul_div_left _ _ H]
intros
tactic.mk_inj_eq
intros
{ ext, rw associated_iff_eq }
ext
rw associated_iff_eq
intros
refine (finset.prod_image' f (λ x hx, _)).symm
refl
intros
apply ext'
intro b
rw count_sum'
have h : count b s = count b (count b s • {b})
{ rw [count_nsmul, count_singleton_self, mul_one] }
rw [count_nsmul, count_singleton_self, mul_one]
rw h
clear h
apply finset.sum_eq_single b
intros c h hcb
{ intros c h hcb, rw count_nsmul, convert mul_zero (count c s), apply count_eq_zero.mpr, exact finset.not_mem_singleton.mpr (ne.symm hcb) }
rw count_nsmul
convert mul_zero (count c s)
apply count_eq_zero.mpr
exact finset.not_mem_singleton.mpr (ne.symm hcb)
intro hb
{ intro hb, rw [count_eq_zero_of_not_mem (mt mem_to_finset.2 hb), count_nsmul, zero_mul]}
rw [count_eq_zero_of_not_mem (mt mem_to_finset.2 hb), count_nsmul, zero_mul]
intros
simp [prod_apply_ite _ _ (λ x, x)]
intros
induction n with n ih
{ rw [prod_range_one, prod_range_one] }
rw [prod_range_one, prod_range_one]
rw [prod_range_succ', prod_range_succ _ (nat.succ n)]
{ rw [prod_range_succ', prod_range_succ _ (nat.succ n)], simp [← ih] }
simp [← ih]
intros
contrapose! Hle with Hlt
exact prod_lt_prod_of_nonempty' hs Hlt
intros
{ ext, refl, }
ext
refl
intros
induction n
simp
{ simp, }
rw [pow_succ', pow_mul, pow_mul, pow_mul, n_ih]
apply add_pow_char_of_commute
apply commute.pow_pow h
intros
simpa [linear_ordered_add_comm_group.tendsto_nhds, abs_sub_comm] using (of_convergence_epsilon v)
intros
cases decidable.em (g.terminated_at n) with terminated_at_n not_terminated_at_n
have : squash_gcf g n = g
{ have : squash_gcf g n = g, from squash_gcf_eq_self_of_terminated terminated_at_n, simp only [this, (convergents_stable_of_terminated n.le_succ terminated_at_n)] }
from squash_gcf_eq_self_of_terminated terminated_at_n
simp only [this, (convergents_stable_of_terminated n.le_succ terminated_at_n)]
obtain ⟨⟨a, b⟩, s_nth_eq⟩ : ∃ gp_n, g.s.nth n = some gp_n
{ obtain ⟨⟨a, b⟩, s_nth_eq⟩ : ∃ gp_n, g.s.nth n = some gp_n, from option.ne_none_iff_exists'.mp not_terminated_at_n, have b_ne_zero : b ≠ 0, from nth_part_denom_ne_zero (part_denom_eq_s_b s_nth_eq), cases n with n', case nat.zero { suffices : (b * g.h + a) / b = g.h + a / b, by simpa [squash_gcf, s_nth_eq, convergent_eq_conts_a_div_conts_b, (continuants_recurrence_aux s_nth_eq zeroth_continuant_aux_eq_one_zero first_continuant_aux_eq_h_one)], calc (b * g.h + a) / b = b * g.h / b + a / b : by ring ... = g.h + a / b : by rw (mul_div_cancel_left _ b_ne_zero) }, case nat.succ { obtain ⟨⟨pa, pb⟩, s_n'th_eq⟩ : ∃ gp_n', g.s.nth n' = some gp_n' := g.s.ge_stable n'.le_succ s_nth_eq, let g' := squash_gcf g (n' + 1), set pred_conts := g.continuants_aux (n' + 1) with succ_n'th_conts_aux_eq, set ppred_conts := g.continuants_aux n' with n'th_conts_aux_eq, let pA := pred_conts.a, let pB := pred_conts.b, let ppA := ppred_conts.a, let ppB := ppred_conts.b, set pred_conts' := g'.continuants_aux (n' + 1) with succ_n'th_conts_aux_eq', set ppred_conts' := g'.continuants_aux n' with n'th_conts_aux_eq', let pA' := pred_conts'.a, let pB' := pred_conts'.b, let ppA' := ppred_conts'.a, let ppB' := ppred_conts'.b, have : g'.convergents (n' + 1) = ((pb + a / b) * pA' + pa * ppA') / ((pb + a / b) * pB' + pa * ppB'), { have : g'.s.nth n' = some ⟨pa, pb + a / b⟩ := squash_seq_nth_of_not_terminated s_n'th_eq s_nth_eq, rw [convergent_eq_conts_a_div_conts_b, continuants_recurrence_aux this n'th_conts_aux_eq'.symm succ_n'th_conts_aux_eq'.symm], }, rw this, have : g.convergents (n' + 2) = (b * (pb * pA + pa * ppA) + a * pA) / (b * (pb * pB + pa * ppB) + a * pB), { have : g.continuants_aux (n' + 2) = ⟨pb * pA + pa * ppA, pb * pB + pa * ppB⟩ := continuants_aux_recurrence s_n'th_eq n'th_conts_aux_eq.symm succ_n'th_conts_aux_eq.symm, rw [convergent_eq_conts_a_div_conts_b, continuants_recurrence_aux s_nth_eq succ_n'th_conts_aux_eq.symm this] }, rw this, suffices : ((pb + a / b) * pA + pa * ppA) / ((pb + a / b) * pB + pa * ppB) = (b * (pb * pA + pa * ppA) + a * pA) / (b * (pb * pB + pa * ppB) + a * pB), { obtain ⟨eq1, eq2, eq3, eq4⟩ : pA' = pA ∧ pB' = pB ∧ ppA' = ppA ∧ ppB' = ppB, { simp [*, (continuants_aux_eq_continuants_aux_squash_gcf_of_le $ le_refl $ n' + 1).symm, (continuants_aux_eq_continuants_aux_squash_gcf_of_le n'.le_succ).symm] }, symmetry, simpa only [eq1, eq2, eq3, eq4, mul_div_cancel _ b_ne_zero] }, field_simp, congr' 1; ring } }
from option.ne_none_iff_exists'.mp not_terminated_at_n
have b_ne_zero : b ≠ 0
from nth_part_denom_ne_zero (part_denom_eq_s_b s_nth_eq)
cases n with n'
case nat.zero { suffices : (b * g.h + a) / b = g.h + a / b, by simpa [squash_gcf, s_nth_eq, convergent_eq_conts_a_div_conts_b, (continuants_recurrence_aux s_nth_eq zeroth_continuant_aux_eq_one_zero first_continuant_aux_eq_h_one)], calc (b * g.h + a) / b = b * g.h / b + a / b : by ring ... = g.h + a / b : by rw (mul_div_cancel_left _ b_ne_zero) }
suffices : (b * g.h + a) / b = g.h + a / b
simpa [squash_gcf, s_nth_eq, convergent_eq_conts_a_div_conts_b, (continuants_recurrence_aux s_nth_eq zeroth_continuant_aux_eq_one_zero first_continuant_aux_eq_h_one)]
simpa [squash_gcf, s_nth_eq, convergent_eq_conts_a_div_conts_b, (continuants_recurrence_aux s_nth_eq zeroth_continuant_aux_eq_one_zero first_continuant_aux_eq_h_one)]
calc (b * g.h + a) / b = b * g.h / b + a / b : by ring ... = g.h + a / b : by rw (mul_div_cancel_left _ b_ne_zero)
case nat.succ { obtain ⟨⟨pa, pb⟩, s_n'th_eq⟩ : ∃ gp_n', g.s.nth n' = some gp_n' := g.s.ge_stable n'.le_succ s_nth_eq, let g' := squash_gcf g (n' + 1), set pred_conts := g.continuants_aux (n' + 1) with succ_n'th_conts_aux_eq, set ppred_conts := g.continuants_aux n' with n'th_conts_aux_eq, let pA := pred_conts.a, let pB := pred_conts.b, let ppA := ppred_conts.a, let ppB := ppred_conts.b, set pred_conts' := g'.continuants_aux (n' + 1) with succ_n'th_conts_aux_eq', set ppred_conts' := g'.continuants_aux n' with n'th_conts_aux_eq', let pA' := pred_conts'.a, let pB' := pred_conts'.b, let ppA' := ppred_conts'.a, let ppB' := ppred_conts'.b, have : g'.convergents (n' + 1) = ((pb + a / b) * pA' + pa * ppA') / ((pb + a / b) * pB' + pa * ppB'), { have : g'.s.nth n' = some ⟨pa, pb + a / b⟩ := squash_seq_nth_of_not_terminated s_n'th_eq s_nth_eq, rw [convergent_eq_conts_a_div_conts_b, continuants_recurrence_aux this n'th_conts_aux_eq'.symm succ_n'th_conts_aux_eq'.symm], }, rw this, have : g.convergents (n' + 2) = (b * (pb * pA + pa * ppA) + a * pA) / (b * (pb * pB + pa * ppB) + a * pB), { have : g.continuants_aux (n' + 2) = ⟨pb * pA + pa * ppA, pb * pB + pa * ppB⟩ := continuants_aux_recurrence s_n'th_eq n'th_conts_aux_eq.symm succ_n'th_conts_aux_eq.symm, rw [convergent_eq_conts_a_div_conts_b, continuants_recurrence_aux s_nth_eq succ_n'th_conts_aux_eq.symm this] }, rw this, suffices : ((pb + a / b) * pA + pa * ppA) / ((pb + a / b) * pB + pa * ppB) = (b * (pb * pA + pa * ppA) + a * pA) / (b * (pb * pB + pa * ppB) + a * pB), { obtain ⟨eq1, eq2, eq3, eq4⟩ : pA' = pA ∧ pB' = pB ∧ ppA' = ppA ∧ ppB' = ppB, { simp [*, (continuants_aux_eq_continuants_aux_squash_gcf_of_le $ le_refl $ n' + 1).symm, (continuants_aux_eq_continuants_aux_squash_gcf_of_le n'.le_succ).symm] }, symmetry, simpa only [eq1, eq2, eq3, eq4, mul_div_cancel _ b_ne_zero] }, field_simp, congr' 1; ring }
obtain ⟨⟨pa, pb⟩, s_n'th_eq⟩ : ∃ gp_n', g.s.nth n' = some gp_n' := g.s.ge_stable n'.le_succ s_nth_eq
let g' := squash_gcf g (n' + 1)
set pred_conts := g.continuants_aux (n' + 1) with succ_n'th_conts_aux_eq
set ppred_conts := g.continuants_aux n' with n'th_conts_aux_eq
let pA := pred_conts.a
let pB := pred_conts.b
let ppA := ppred_conts.a
let ppB := ppred_conts.b
set pred_conts' := g'.continuants_aux (n' + 1) with succ_n'th_conts_aux_eq'
set ppred_conts' := g'.continuants_aux n' with n'th_conts_aux_eq'
let pA' := pred_conts'.a
let pB' := pred_conts'.b
let ppA' := ppred_conts'.a
let ppB' := ppred_conts'.b
have : g'.convergents (n' + 1) = ((pb + a / b) * pA' + pa * ppA') / ((pb + a / b) * pB' + pa * ppB')
have : g'.s.nth n' = some ⟨pa, pb + a / b⟩ := squash_seq_nth_of_not_terminated s_n'th_eq s_nth_eq
{ have : g'.s.nth n' = some ⟨pa, pb + a / b⟩ := squash_seq_nth_of_not_terminated s_n'th_eq s_nth_eq, rw [convergent_eq_conts_a_div_conts_b, continuants_recurrence_aux this n'th_conts_aux_eq'.symm succ_n'th_conts_aux_eq'.symm], }
rw [convergent_eq_conts_a_div_conts_b, continuants_recurrence_aux this n'th_conts_aux_eq'.symm succ_n'th_conts_aux_eq'.symm]
rw this
have : g.convergents (n' + 2) = (b * (pb * pA + pa * ppA) + a * pA) / (b * (pb * pB + pa * ppB) + a * pB)
have : g.continuants_aux (n' + 2) = ⟨pb * pA + pa * ppA, pb * pB + pa * ppB⟩ := continuants_aux_recurrence s_n'th_eq n'th_conts_aux_eq.symm succ_n'th_conts_aux_eq.symm
{ have : g.continuants_aux (n' + 2) = ⟨pb * pA + pa * ppA, pb * pB + pa * ppB⟩ := continuants_aux_recurrence s_n'th_eq n'th_conts_aux_eq.symm succ_n'th_conts_aux_eq.symm, rw [convergent_eq_conts_a_div_conts_b, continuants_recurrence_aux s_nth_eq succ_n'th_conts_aux_eq.symm this] }
rw [convergent_eq_conts_a_div_conts_b, continuants_recurrence_aux s_nth_eq succ_n'th_conts_aux_eq.symm this]
rw this
suffices : ((pb + a / b) * pA + pa * ppA) / ((pb + a / b) * pB + pa * ppB) = (b * (pb * pA + pa * ppA) + a * pA) / (b * (pb * pB + pa * ppB) + a * pB)
obtain ⟨eq1, eq2, eq3, eq4⟩ : pA' = pA ∧ pB' = pB ∧ ppA' = ppA ∧ ppB' = ppB
{ obtain ⟨eq1, eq2, eq3, eq4⟩ : pA' = pA ∧ pB' = pB ∧ ppA' = ppA ∧ ppB' = ppB, { simp [*, (continuants_aux_eq_continuants_aux_squash_gcf_of_le $ le_refl $ n' + 1).symm, (continuants_aux_eq_continuants_aux_squash_gcf_of_le n'.le_succ).symm] }, symmetry, simpa only [eq1, eq2, eq3, eq4, mul_div_cancel _ b_ne_zero] }
simp [*, (continuants_aux_eq_continuants_aux_squash_gcf_of_le $ le_refl $ n' + 1).symm, (continuants_aux_eq_continuants_aux_squash_gcf_of_le n'.le_succ).symm]
{ simp [*, (continuants_aux_eq_continuants_aux_squash_gcf_of_le $ le_refl $ n' + 1).symm, (continuants_aux_eq_continuants_aux_squash_gcf_of_le n'.le_succ).symm] }
symmetry
simpa only [eq1, eq2, eq3, eq4, mul_div_cancel _ b_ne_zero]
field_simp
congr' 1; ring
congr' 1
ring
ring
intros
rw is_symm_op.flip_eq
intros
{ rcases hu with ⟨u, rfl⟩, apply units.mul_left_dvd, }
rcases hu with ⟨u, rfl⟩
apply units.mul_left_dvd
intros
simp [lcm_def]
intros
rw [sum_Ico_eq_sub _ hmn, ← geom_sum_def, ← geom_sum_def, sub_mul, geom_sum_mul_neg, geom_sum_mul_neg, sub_sub_sub_cancel_left]
intros
simp [h]
intros
rw [add_left_comm, sub_add_cancel, add_comm]
intros
by_cases h : a = 0
{ rw [h, inv_zero, mul_zero] }
rw [h, inv_zero, mul_zero]
{ rw [mul_assoc, mul_inv_cancel h, mul_one] }
rw [mul_assoc, mul_inv_cancel h, mul_one]
intros
simp [h]
intros
rw [← div_div_eq_div_mul, ← div_eq_mul_one_div]
intros
rw [←kernel.lift_ι _ _ hι, ←cokernel.π_desc _ _ hπ, category.assoc, kernel_comp_cokernel_assoc, zero_comp, comp_zero]
intros
simp [h]
intros
{ dunfold cycles_map, simp, }
dunfold cycles_map
simp
intros
{ ext, simp, }
ext
simp
intros
rw [derived_series_def, derived_series_of_ideal_succ, derived_series_of_ideal_zero, ← lie_submodule.mem_coe_submodule, lie_submodule.lie_ideal_oper_eq_linear_span] at h
apply submodule.span_induction h
rintros y ⟨⟨z, hz⟩, ⟨⟨w, hw⟩, rfl⟩⟩
{ rintros y ⟨⟨z, hz⟩, ⟨⟨w, hw⟩, rfl⟩⟩, apply lie_character_apply_lie, }
apply lie_character_apply_lie
{ exact χ.map_zero, }
exact χ.map_zero
intros y z hy hz
{ intros y z hy hz, rw [lie_hom.map_add, hy, hz, add_zero], }
rw [lie_hom.map_add, hy, hz, add_zero]
{ intros t y hy, rw [lie_hom.map_smul, hy, smul_zero], }
intros t y hy
rw [lie_hom.map_smul, hy, smul_zero]
intros
rw [← function.comp_app (lift R f) (of R) x, of_comp_lift]
intros
rw mem_skew_adjoint_submodule at *
have hfg : is_adjoint_pair B B (f * g) (g * f)
rw ←neg_mul_neg g f
{ rw ←neg_mul_neg g f, exact hf.mul hg, }
exact hf.mul hg
have hgf : is_adjoint_pair B B (g * f) (f * g)
rw ←neg_mul_neg f g
{ rw ←neg_mul_neg f g, exact hg.mul hf, }
exact hg.mul hf
change bilin_form.is_adjoint_pair B B (f * g - g * f) (-(f * g - g * f))
rw neg_sub
exact hfg.sub hgf
intros
rw [set_like.ext'_iff, lie_submodule.coe_to_submodule, h, submodule.map_coe]
{ rw [set_like.ext'_iff, lie_submodule.coe_to_submodule, h, submodule.map_coe], refl, }
refl
intros
{ ext, simp [lie_submodule.mem_map], }
ext
simp [lie_submodule.mem_map]
intros
refine le_antisymm _ (lie_subalgebra.le_normalizer _)
intros x hx
rw lie_subalgebra.mem_normalizer_iff at hx
rw mem_zero_root_subalgebra
rintros ⟨y, hy⟩
specialize hx y (le_zero_root_subalgebra R L H hy)
rw mem_zero_root_subalgebra at hx
obtain ⟨k, hk⟩ := hx ⟨y, hy⟩
rw [← lie_skew, linear_map.map_neg, neg_eq_zero] at hk
use k + 1
rw [linear_map.iterate_succ, linear_map.coe_comp, function.comp_app, to_endomorphism_apply_apply, lie_subalgebra.coe_bracket_of_module, submodule.coe_mk, hk]
intros
rw [←neg_neg c, ←neg_neg b, neg_smul_neg, inv_neg, neg_smul _ a, neg_lt_neg_iff]
exact lt_smul_iff_of_pos (neg_pos_of_neg hc)
intros
rw [←not_lt, ←not_lt]
{ rw [←not_lt, ←not_lt], apply not_congr, apply lt_iff_lt_of_cmp_eq_cmp, rwa cmp_eq_cmp_symm }
apply not_congr
apply lt_iff_lt_of_cmp_eq_cmp
rwa cmp_eq_cmp_symm
intros
rwa [inv_le ((@zero_lt_one α _ _).trans_le ha) zero_lt_one, inv_one]
intros
simpa [one_div] using inv_le_inv_of_neg ha hb
intros
cases le_total a b; simp *
cases le_total a b
simp *
simp *
intros
rw [← inv_lt_inv_iff, inv_inv]
intros
rw [div_eq_mul_inv b, mul_comm]
exact div_le_inv_mul_iff
intros
simp_rw [lt_iff_le_and_ne, and_comm, le_iff_exists_mul, ← exists_and_distrib_left, exists_prop]
apply exists_congr
intro c
rw [and.congr_left_iff, gt_iff_lt]
rintro rfl
split
rw [one_lt_iff_ne_one]
{ rw [one_lt_iff_ne_one], apply mt, rintro rfl, rw [mul_one] }
apply mt
rintro rfl
rw [mul_one]
rw [← (self_le_mul_right a c).lt_iff_ne]
{ rw [← (self_le_mul_right a c).lt_iff_ne], apply lt_mul_of_one_lt_right' }
apply lt_mul_of_one_lt_right'
intros
ext x
simp only [mem_smul_set, algebra.id.smul_eq_mul, mem_Ico]
split
rintro ⟨a, ⟨a_h_left_left, a_h_left_right⟩, rfl⟩
{ rintro ⟨a, ⟨a_h_left_left, a_h_left_right⟩, rfl⟩, split, exact (mul_le_mul_left hr).mpr a_h_left_left, exact (mul_lt_mul_left hr).mpr a_h_left_right, }
split
exact (mul_le_mul_left hr).mpr a_h_left_left
exact (mul_lt_mul_left hr).mpr a_h_left_right
rintro ⟨a_left, a_right⟩
{ rintro ⟨a_left, a_right⟩, use x / r, refine ⟨⟨(le_div_iff' hr).mpr a_left, (div_lt_iff' hr).mpr a_right⟩, _⟩, rw mul_div_cancel' _ (ne_of_gt hr), }
use x / r
refine ⟨⟨(le_div_iff' hr).mpr a_left, (div_lt_iff' hr).mpr a_right⟩, _⟩
rw mul_div_cancel' _ (ne_of_gt hr)
intros
cases abs_choice a with h h; simp only [h, neg_dvd]
{ cases abs_choice a with h h; simp only [h, neg_dvd] }
cases abs_choice a with h h
simp only [h, neg_dvd]
simp only [h, neg_dvd]
intros
haveI := @linear_order.decidable_le α _; exact λ x y h, decidable.mul_le_mul (hf h) (hg h) (hg0 x) (hf0 y)
haveI := @linear_order.decidable_le α _
exact λ x y h, decidable.mul_le_mul (hf h) (hg h) (hg0 x) (hf0 y)
intros
simp [*, ← add_assoc] at *
intros
simp [*, ← add_assoc] at *
intros
{ rw mem_finset_prod, simp }
rw mem_finset_prod
simp
intros
{ intro b, dsimp [dihedral_act], ring }
intro b
dsimp [dihedral_act]
ring
intros
refine ⟨_, pow n⟩
rw [← nat.succ_pred_eq_of_pos n0, pow_succ', ← smul_eq_mul]
exact of_smul _
intros
{ ext x, simp [odd, eq_comm] }
ext x
simp [odd, eq_comm]
intros
rw add_comm; exact dvd_add_iff_left h
rw add_comm
exact dvd_add_iff_left h
intros
erw [not_forall]
exact ⟨0, (by simp)⟩
intros
rw [stalk_map, stalk_functor_map_germ_assoc, stalk_pushforward_germ]
intros
refine tsum_of_nnnorm_bounded _ (λ l, p.nnnorm_change_origin_series_apply_le_tsum k l x)
have := p.change_origin_series_summable_aux₂ h k
refine has_sum.sigma this.has_sum (λ l, _)
exact ((nnreal.summable_sigma.1 this).1 l).has_sum
intros
rcases i with ⟨n, c⟩
refine ⟨⟨c.length, c.blocks_fun⟩, _, _⟩
simp only [comp_partial_sum_target_set, set.mem_set_of_eq] at hi
{ simp only [comp_partial_sum_target_set, set.mem_set_of_eq] at hi, simp only [mem_comp_partial_sum_source_iff, hi.left, hi.right, true_and, and_true], exact λ a, c.one_le_blocks' _ }
simp only [mem_comp_partial_sum_source_iff, hi.left, hi.right, true_and, and_true]
exact λ a, c.one_le_blocks' _
dsimp [comp_change_of_variables]
{ dsimp [comp_change_of_variables], rw composition.sigma_eq_iff_blocks_eq, simp only [composition.blocks_fun, composition.blocks, subtype.coe_eta, nth_le_map'], conv_lhs { rw ← of_fn_nth_le c.blocks } }
rw composition.sigma_eq_iff_blocks_eq
simp only [composition.blocks_fun, composition.blocks, subtype.coe_eta, nth_le_map']
conv_lhs { rw ← of_fn_nth_le c.blocks }
intros
by_cases h : c = 0
rw [h, ← is_o_one_iff ℝ] at *
{ rw [h, ← is_o_one_iff ℝ] at *, convert (huv.symm.is_o.trans hu).add hu, simp }
convert (huv.symm.is_o.trans hu).add hu
simp
rw ← is_equivalent_const_iff_tendsto h at hu ⊢
{ rw ← is_equivalent_const_iff_tendsto h at hu ⊢, exact huv.symm.trans hu }
exact huv.symm.trans hu
intros
split
intro h
{ intro h, use (λ x, u x / v x), refine ⟨eventually.mono h.bound (λ y hy, _), h.eventually_mul_div_cancel.symm⟩, simpa using div_le_of_nonneg_of_le_mul (norm_nonneg _) hc hy }
use (λ x, u x / v x)
refine ⟨eventually.mono h.bound (λ y hy, _), h.eventually_mul_div_cancel.symm⟩
simpa using div_le_of_nonneg_of_le_mul (norm_nonneg _) hc hy
rintros ⟨φ, hφ, h⟩
{ rintros ⟨φ, hφ, h⟩, exact is_O_with_of_eq_mul φ hφ h }
exact is_O_with_of_eq_mul φ hφ h
intros
unfold is_o
{ unfold is_o, exact forall_congr (λ _, forall_congr $ λ _, is_O_with_norm_right) }
exact forall_congr (λ _, forall_congr $ λ _, is_O_with_norm_right)
intros
rw is_O
intros
have := has_fderiv_within_at.iterate hf hx hs n
rwa [continuous_linear_map.smul_right_one_pow] at this
intros
have := (hc.has_fderiv_within_at.clm_apply hu.has_fderiv_within_at).has_deriv_within_at
rwa [add_apply, comp_apply, flip_apply, smul_right_apply, smul_right_apply, one_apply, one_smul, one_smul, add_comm] at this
intros
{ unfold deriv_within, rw fderiv_within_congr hs hL hx }
unfold deriv_within
rw fderiv_within_congr hs hL hx
intros
{ convert hc.mul' hd, ext z, apply mul_comm }
convert hc.mul' hd
ext z
apply mul_comm
intros
rw ← has_fderiv_within_at_univ at h₀ h₁
exact unique_diff_within_at_univ.eq h₀ h₁
intros
rw differentiable_at.fderiv_within (differentiable_at_const _) hxs
exact fderiv_const_apply _
intros
apply implicit_to_local_homeomorph_of_complemented_apply_ker
intros
{ ext x, refl }
ext x
refl
intros
rw ← has_ftaylor_series_up_to_on_univ_iff at h
rw continuous_iff_continuous_on_univ
exact h.continuous_on
intros
let A : Π m : ℕ, (E [×m]→L[𝕜] F) → (G [×m]→L[𝕜] F) := λ m h, h.comp_continuous_linear_map (λ _, g)
have hA : ∀ m, is_bounded_linear_map 𝕜 (A m) := λ m, is_bounded_linear_map_continuous_multilinear_map_comp_linear g
split
assume x hx
{ assume x hx, simp only [(hf.zero_eq (g x) hx).symm, function.comp_app], change p (g x) 0 (λ (i : fin 0), g 0) = p (g x) 0 0, rw continuous_linear_map.map_zero, refl }
simp only [(hf.zero_eq (g x) hx).symm, function.comp_app]
change p (g x) 0 (λ (i : fin 0), g 0) = p (g x) 0 0
rw continuous_linear_map.map_zero
refl
assume m hm x hx
{ assume m hm x hx, convert ((hA m).has_fderiv_at).comp_has_fderiv_within_at x ((hf.fderiv_within m hm (g x) hx).comp x (g.has_fderiv_within_at) (subset.refl _)), ext y v, change p (g x) (nat.succ m) (g ∘ (cons y v)) = p (g x) m.succ (cons (g y) (g ∘ v)), rw comp_cons }
convert ((hA m).has_fderiv_at).comp_has_fderiv_within_at x ((hf.fderiv_within m hm (g x) hx).comp x (g.has_fderiv_within_at) (subset.refl _))
ext y v
change p (g x) (nat.succ m) (g ∘ (cons y v)) = p (g x) m.succ (cons (g y) (g ∘ v))
rw comp_cons
assume m hm
{ assume m hm, exact (hA m).continuous.comp_continuous_on ((hf.cont m hm).comp g.continuous.continuous_on (subset.refl _)) }
exact (hA m).continuous.comp_continuous_on ((hf.cont m hm).comp g.continuous.continuous_on (subset.refl _))
intros
simpa only [div_eq_mul_inv] using hf.mul times_cont_diff_const
intros
{ rw complex.norm_sq_pos, exact z.ne_zero }
rw complex.norm_sq_pos
exact z.ne_zero
intros
split
rintro h x y hx hy z ⟨a, b, ha, hb, hab, rfl⟩
{ rintro h x y hx hy z ⟨a, b, ha, hb, hab, rfl⟩, exact h hx hy ha hb hab }
exact h hx hy ha hb hab
rintro h x y hx hy a b ha hb hab
{ rintro h x y hx hy a b ha hb hab, exact h hx hy ⟨a, b, ha, hb, hab, rfl⟩ }
exact h hx hy ⟨a, b, ha, hb, hab, rfl⟩
intros
simp_rw [convex_iff_segment_subset, segment_eq_interval, ord_connected_iff_interval_subset]
exact forall_congr (λ x, forall_swap)
intros
obtain ⟨l, a, rfl⟩ := hAB.eq_inter_halfspace
exact hA.is_closed_le continuous_on_const l.continuous.continuous_on
intros
let f := λ z, x + t • (z - x)
have : is_open_map f := (is_open_map_add_left _).comp ((is_open_map_smul (units.mk0 _ ht.1.ne')).comp (is_open_map_sub_right _))
apply mem_interior.2 ⟨f '' (interior s), _, this _ is_open_interior, mem_image_of_mem _ hy⟩
refine image_subset_iff.2 (λ z hz, _)
exact hs.add_smul_sub_mem hx (interior_subset hz) ⟨ht.1.le, ht.2⟩
intros
rw [←inner_conj_sym, inner_smul_left]; simp only [conj_conj, inner_conj_sym, ring_hom.map_mul]
rw [←inner_conj_sym, inner_smul_left]
simp only [conj_conj, inner_conj_sym, ring_hom.map_mul]
intros
{ have h := @inner_self_nonpos ℝ F _ _ x, simpa using h }
have h := @inner_self_nonpos ℝ F _ _ x
simpa using h
intros
simpa using (hf.has_fderiv_within_at.inner hg.has_fderiv_within_at).has_deriv_within_at
intros
apply normed_group_hom.isometry_of_norm
intro v
apply le_antisymm (i.hom.2 v)
calc ∥v∥ = ∥i.inv (i.hom v)∥ : by rw [coe_hom_inv_id] ... ≤ ∥i.hom v∥ : i.inv.2 _
intros
rw [dist_comm, dist_vadd_left]
intros
simp only [sub_eq_add_neg, dist_add_left, dist_neg_neg]
intros
rw [mem_ball', dist_eq_norm]
intros
simp only [nnreal.eq_iff.symm, nnreal.coe_zero, coe_nnnorm, norm_eq_zero]
intros
apply le_antisymm
exact continuous_multilinear_map.op_norm_le_bound _ (norm_nonneg _) (λm, by simp)
{ exact continuous_multilinear_map.op_norm_le_bound _ (norm_nonneg _) (λm, by simp) }
simpa using (continuous_multilinear_map.curry0 𝕜 G x).le_op_norm 0
{ simpa using (continuous_multilinear_map.curry0 𝕜 G x).le_op_norm 0 }
intros
{ ext x, exact normed_group_hom.completion_def f x }
ext x
exact normed_group_hom.completion_def f x
intros
simpa only [dist_zero_right, f.map_zero] using h.le_mul_dist x 0
intros
rintro b hb _ ⟨_, ⟨x, hx, rfl⟩, rfl⟩
exact ⟨b • x, hA _ hb ⟨_, hx, rfl⟩, smul_comm _ _ _⟩
intros
simp only [log_im, arg_le_pi]
intros
simpa using integral_sin_pow_odd_mul_cos_pow 0 2
intros
rw [← nnreal.coe_eq, coe_rpow, ← nnreal.coe_eq_zero]
exact real.rpow_eq_zero_iff_of_nonneg x.2
intros
simp [*, mul_rpow_eq_ite]
intros
convert ennreal.tendsto.const_mul (ennreal.continuous_rpow_const.tendsto 0) _
{ simp [hy] }
simp [hy]
{ exact or.inr hc }
exact or.inr hc
intros
rw cpow_def; split_ifs; simp [one_ne_zero, *] at *
rw cpow_def; split_ifs
rw cpow_def
split_ifs
simp [one_ne_zero, *] at *
simp [one_ne_zero, *] at *
simp [one_ne_zero, *] at *
intros
rw [one_div, ← inv_one_add_tan_sq (cos_arctan_pos x).ne', tan_arctan]
intros
simp [sub_eq_add_neg, sin_add]
{ convert continuous_sin.continuous_within_at, simp }
convert continuous_sin.continuous_within_at
simp
rw [real.pi, mul_div_cancel_left _ (@two_ne_zero' ℝ _ _ _)]
rw [real.pi, mul_div_cancel_left _ (@two_ne_zero' ℝ _ _ _)]; exact (classical.some_spec exists_cos_eq_zero).1.2
exact (classical.some_spec exists_cos_eq_zero).1.2
intros
rw [← arcsin_sin' hy, strict_mono_on_arcsin.le_iff_le hx (sin_mem_Icc _), arcsin_sin' hy]
intros
refine ⟨λ h, _, summable_geometric_of_norm_lt_1⟩
obtain ⟨k : ℕ, hk : dist (ξ ^ k) 0 < 1⟩ := (h.tendsto_cofinite_zero.eventually (ball_mem_nhds _ zero_lt_one)).exists
simp only [normed_field.norm_pow, dist_zero_right] at hk
rw [← one_pow k] at hk
exact lt_of_pow_lt_pow _ zero_le_one hk
intros
ext
dsimp
erw [← adj.hom_equiv_counit, equiv.symm_apply_eq, adj.hom_equiv_unit]
simp
intros
simp [nat_trans.left_derived]
intros
{ cases h, refl, }
cases h
refl
intros
apply is_connected.of_induct
intros p hp hjp j
have: ∀ (j₁ j₂ : J), zigzag j₁ j₂ → (j₁ ∈ p ↔ j₂ ∈ p)
introv k
{ introv k, induction k with _ _ rt_zag zag, { refl }, { rw k_ih, rcases zag with ⟨⟨_⟩⟩ | ⟨⟨_⟩⟩, apply hjp zag, apply (hjp zag).symm } }
induction k with _ _ rt_zag zag
{ refl }
refl
rw k_ih
{ rw k_ih, rcases zag with ⟨⟨_⟩⟩ | ⟨⟨_⟩⟩, apply hjp zag, apply (hjp zag).symm }
rcases zag with ⟨⟨_⟩⟩ | ⟨⟨_⟩⟩
apply hjp zag
apply (hjp zag).symm
rwa this j (classical.arbitrary J) (h _ _)
intros
simp only [cancel_mono]
intros
dsimp [colimit_obj_iso_colimit_comp_evaluation]
rw ←iso.eq_comp_inv
simp
intros
ext
ext; rw [←assoc, colimit.ι_pre]; simp
ext; rw [←assoc, colimit.ι_pre]
rw [←assoc, colimit.ι_pre]
simp
intros
simp
intros
simp
intros
ext
ext; simp [add_comp]
simp [add_comp]
simp [add_comp]
intros
simp
intros
{ ext, simp [h₂], }
ext
simp [h₂]
intros
{ ext, simp [← G.map_comp] }
ext
simp [← G.map_comp]
intros
rw [left_unitor_naturality, ←category.assoc, iso.inv_hom_id, category.id_comp]
intros
tidy
intros
have := f.w; tidy
have := f.w
tidy
intros
{ ext, rw [comp_as_mul, inv_mul_self, id_as_one] }
ext
rw [comp_as_mul, inv_mul_self, id_as_one]
intros
rw presieve.compatible_iff_sieve_compatible
split
intro t
{ intro t, ext ⟨Y, Z, g, f, hf⟩, simpa [first_map, second_map] using t _ g hf }
ext ⟨Y, Z, g, f, hf⟩
simpa [first_map, second_map] using t _ g hf
intros t Y Z f g hf
{ intros t Y Z f g hf, rw types.limit_ext_iff at t, simpa [first_map, second_map] using t ⟨Y, Z, g, f, hf⟩ }
rw types.limit_ext_iff at t
simpa [first_map, second_map] using t ⟨Y, Z, g, f, hf⟩
intros
have := f.w; tidy
{ have := f.w; tidy }
have := f.w
tidy
intros
rw [colex.lt_def, colex.lt_def]
apply exists_congr
intro k
simp only [mem_sdiff, not_and, not_not]
split
rintro ⟨z, kAB, kB, kA⟩
{ rintro ⟨z, kAB, kB, kA⟩, refine ⟨_, kA, kB⟩, { intros x hx, specialize z hx, tauto } }
refine ⟨_, kA, kB⟩
intros x hx
{ intros x hx, specialize z hx, tauto }
specialize z hx
tauto
rintro ⟨z, kA, kB⟩
{ rintro ⟨z, kA, kB⟩, refine ⟨_, λ _, kB, kB, kA⟩, intros x hx, rw z hx }
refine ⟨_, λ _, kB, kB, kA⟩
intros x hx
rw z hx
intros
symmetry
rw ← mem_range_embedding_iff'
apply set.mem_range_self
intros
split
assume hj
{ assume hj, rcases (c.boundaries.order_iso_of_fin rfl).surjective ⟨j, hj⟩ with ⟨i, hi⟩, rw [subtype.ext_iff, subtype.coe_mk] at hi, refine ⟨i.1, i.2, _⟩, rw [← hi, c.blocks_partial_sum i.2], refl }
rcases (c.boundaries.order_iso_of_fin rfl).surjective ⟨j, hj⟩ with ⟨i, hi⟩
rw [subtype.ext_iff, subtype.coe_mk] at hi
refine ⟨i.1, i.2, _⟩
rw [← hi, c.blocks_partial_sum i.2]
refl
rintros ⟨i, hi, H⟩
{ rintros ⟨i, hi, H⟩, convert (c.boundaries.order_iso_of_fin rfl ⟨i, hi⟩).2, have : c.boundary ⟨i, hi⟩ = j, by rwa [fin.ext_iff, ← c.blocks_partial_sum hi], exact this.symm }
convert (c.boundaries.order_iso_of_fin rfl ⟨i, hi⟩).2
have : c.boundary ⟨i, hi⟩ = j
rwa [fin.ext_iff, ← c.blocks_partial_sum hi]
rwa [fin.ext_iff, ← c.blocks_partial_sum hi]
exact this.symm
intros
haveI : nonempty ι := fintype.card_pos_iff.mp (hn.symm ▸ nat.succ_pos _)
haveI := classical.dec_eq ι
let x := classical.arbitrary ι
have tx_ne : (t x).nonempty
rw ←finset.card_pos
{ rw ←finset.card_pos, apply nat.lt_of_lt_of_le nat.one_pos, convert ht {x}, rw finset.singleton_bUnion, }
apply nat.lt_of_lt_of_le nat.one_pos
convert ht {x}
rw finset.singleton_bUnion
rcases classical.indefinite_description _ tx_ne with ⟨y, hy⟩
let ι' := {x' : ι | x' ≠ x}
let t' : ι' → finset α := λ x', (t x').erase y
have card_ι' : fintype.card ι' = n
convert congr_arg (λ m, m - 1) hn
{ convert congr_arg (λ m, m - 1) hn, convert set.card_ne_eq _, }
convert set.card_ne_eq _
rcases ih t' card_ι'.le (hall_cond_of_erase y ha) with ⟨f', hfinj, hfr⟩
refine ⟨λ z, if h : z = x then y else f' ⟨z, h⟩, _, _⟩
rintro z₁ z₂
{ rintro z₁ z₂, have key : ∀ {x}, y ≠ f' x, { intros x h, specialize hfr x, rw ←h at hfr, simpa using hfr, }, by_cases h₁ : z₁ = x; by_cases h₂ : z₂ = x; simp [h₁, h₂, hfinj.eq_iff, key, key.symm], }
have key : ∀ {x}, y ≠ f' x
intros x h
{ intros x h, specialize hfr x, rw ←h at hfr, simpa using hfr, }
specialize hfr x
rw ←h at hfr
simpa using hfr
by_cases h₁ : z₁ = x; by_cases h₂ : z₂ = x; simp [h₁, h₂, hfinj.eq_iff, key, key.symm]
by_cases h₁ : z₁ = x; by_cases h₂ : z₂ = x
by_cases h₁ : z₁ = x
by_cases h₂ : z₂ = x
simp [h₁, h₂, hfinj.eq_iff, key, key.symm]
simp [h₁, h₂, hfinj.eq_iff, key, key.symm]
by_cases h₂ : z₂ = x
simp [h₁, h₂, hfinj.eq_iff, key, key.symm]
simp [h₁, h₂, hfinj.eq_iff, key, key.symm]
intro z
{ intro z, split_ifs with hz, { rwa hz }, { specialize hfr ⟨z, hz⟩, rw mem_erase at hfr, exact hfr.2, }, }
split_ifs with hz
{ rwa hz }
rwa hz
specialize hfr ⟨z, hz⟩
{ specialize hfr ⟨z, hz⟩, rw mem_erase at hfr, exact hfr.2, }
rw mem_erase at hfr
exact hfr.2
intros
simp [neighbor_finset_eq_filter, dot_product, sum_filter]
intros
have : traverse pure x = pure (traverse id.mk x) := (naturality (pure_transformation F) id.mk x).symm
have : traverse pure x = pure (traverse id.mk x) := (naturality (pure_transformation F) id.mk x).symm; rwa id_traverse at this
rwa id_traverse at this
intros
cases hp : p cb n with np resp np errp
{ simp [hp, ←orelse_eq_orelse, parser.orelse] }
simp [hp, ←orelse_eq_orelse, parser.orelse]
by_cases h : np = n
{ by_cases h : np = n, { cases hq : q cb n with nq resq nq errq, { simp [hp, h, hn, hq, ne_of_gt hn, ←orelse_eq_orelse, parser.orelse] }, { rcases lt_trichotomy nq n with H|H|H, { simp [hp, hq, h, H, ne_of_gt hn, not_lt_of_lt H, ←orelse_eq_orelse, parser.orelse] }, { simp [hp, hq, h, H, ne_of_gt hn, lt_irrefl, ←orelse_eq_orelse, parser.orelse] }, { simp [hp, hq, h, H, ne_of_gt (hn.trans H), ←orelse_eq_orelse, parser.orelse] } } }, { simp [hp, h, ←orelse_eq_orelse, parser.orelse] } }
cases hq : q cb n with nq resq nq errq
{ cases hq : q cb n with nq resq nq errq, { simp [hp, h, hn, hq, ne_of_gt hn, ←orelse_eq_orelse, parser.orelse] }, { rcases lt_trichotomy nq n with H|H|H, { simp [hp, hq, h, H, ne_of_gt hn, not_lt_of_lt H, ←orelse_eq_orelse, parser.orelse] }, { simp [hp, hq, h, H, ne_of_gt hn, lt_irrefl, ←orelse_eq_orelse, parser.orelse] }, { simp [hp, hq, h, H, ne_of_gt (hn.trans H), ←orelse_eq_orelse, parser.orelse] } } }
{ simp [hp, h, hn, hq, ne_of_gt hn, ←orelse_eq_orelse, parser.orelse] }
simp [hp, h, hn, hq, ne_of_gt hn, ←orelse_eq_orelse, parser.orelse]
rcases lt_trichotomy nq n with H|H|H
{ rcases lt_trichotomy nq n with H|H|H, { simp [hp, hq, h, H, ne_of_gt hn, not_lt_of_lt H, ←orelse_eq_orelse, parser.orelse] }, { simp [hp, hq, h, H, ne_of_gt hn, lt_irrefl, ←orelse_eq_orelse, parser.orelse] }, { simp [hp, hq, h, H, ne_of_gt (hn.trans H), ←orelse_eq_orelse, parser.orelse] } }
simp [hp, hq, h, H, ne_of_gt hn, not_lt_of_lt H, ←orelse_eq_orelse, parser.orelse]
{ simp [hp, hq, h, H, ne_of_gt hn, not_lt_of_lt H, ←orelse_eq_orelse, parser.orelse] }
simp [hp, hq, h, H, ne_of_gt hn, lt_irrefl, ←orelse_eq_orelse, parser.orelse]
{ simp [hp, hq, h, H, ne_of_gt hn, lt_irrefl, ←orelse_eq_orelse, parser.orelse] }
simp [hp, hq, h, H, ne_of_gt (hn.trans H), ←orelse_eq_orelse, parser.orelse]
{ simp [hp, hq, h, H, ne_of_gt (hn.trans H), ←orelse_eq_orelse, parser.orelse] }
{ simp [hp, h, ←orelse_eq_orelse, parser.orelse] }
simp [hp, h, ←orelse_eq_orelse, parser.orelse]
intros
simp [ch, eps_eq_done, sat_eq_done, and.comm, @eq_comm _ n']
intros
simp [sep_by1, seq_eq_done]
intros
rw [pow_bit1', I_mul_I]
intros
simp [exp_near]
{ simp [exp_near], convert exp_bound h _ using 1, field_simp [mul_comm], linarith }
convert exp_bound h _ using 1
field_simp [mul_comm]
linarith
intros
rw [← mul_right_inj' (@two_ne_zero' ℂ _ _ _), two_sinh, ← mul_assoc, two_sin, mul_assoc, I_mul_I, mul_neg_one, neg_sub, neg_mul_eq_neg_mul]
intros
simp [bit0, ext_iff]
intros
rw [← of_real_nat_cast, of_real_im]
intros
simp [is_R_or_C.norm_sq]
intros
{ ext, simp only [map_range_apply] }
ext
simp only [map_range_apply]
intros
{ ext ⟨a, b⟩ : 1, simp }
ext ⟨a, b⟩ : 1
simp
intros
rw [apply_eq_iff_eq_symm_apply, symm_swap]
intros
simp [perm_congr_def]
intros
ext x
by_cases h : p x
have : p (ep ⟨x, h⟩) := subtype.property _
{ have : p (ep ⟨x, h⟩) := subtype.property _, simp [perm.subtype_congr.apply, h, this] }
simp [perm.subtype_congr.apply, h, this]
have : ¬ p (en ⟨x, h⟩) := subtype.property (en _)
{ have : ¬ p (en ⟨x, h⟩) := subtype.property (en _), simp [perm.subtype_congr.apply, h, symm_apply_eq, this] }
simp [perm.subtype_congr.apply, h, symm_apply_eq, this]
intros
simp
simp; cases decode α n.unpair.1; simp; cases decode β n.unpair.2; refl
simp; cases decode α n.unpair.1; simp; cases decode β n.unpair.2
simp; cases decode α n.unpair.1; simp
simp; cases decode α n.unpair.1
cases decode α n.unpair.1
simp
simp
cases decode β n.unpair.2
refl
refl
intros
rw [← fin.succ_above_below _ _ h, fin_succ_equiv'_succ_above]
intros
apply local_equiv.ext (λx, _) (λx, _) h.1
apply h.2
{ apply h.2, rw s, exact mem_univ _ }
rw s
exact mem_univ _
apply h.symm'.2
{ apply h.symm'.2, rw [symm_source, t], exact mem_univ _ }
rw [symm_source, t]
exact mem_univ _
intros
refine ⟨_, exists_succ_above_eq⟩
rintro ⟨y, rfl⟩
exact succ_above_ne _ _
intros
ext j
by_cases h : j.val < n
simp only [snoc, h, dif_pos]
{ simp only [snoc, h, dif_pos], by_cases h' : j = cast_succ i, { have C1 : α i.cast_succ = α j, by rw h', have E1 : update (snoc p x) i.cast_succ y j = _root_.cast C1 y, { have : update (snoc p x) j (_root_.cast C1 y) j = _root_.cast C1 y, by simp, convert this, { exact h'.symm }, { exact heq_of_cast_eq (congr_arg α (eq.symm h')) rfl } }, have C2 : α i.cast_succ = α (cast_succ (cast_lt j h)), by rw [cast_succ_cast_lt, h'], have E2 : update p i y (cast_lt j h) = _root_.cast C2 y, { have : update p (cast_lt j h) (_root_.cast C2 y) (cast_lt j h) = _root_.cast C2 y, by simp, convert this, { simp [h, h'] }, { exact heq_of_cast_eq C2 rfl } }, rw [E1, E2], exact eq_rec_compose _ _ _ }, { have : ¬(cast_lt j h = i), by { assume E, apply h', rw [← E, cast_succ_cast_lt] }, simp [h', this, snoc, h] } }
by_cases h' : j = cast_succ i
have C1 : α i.cast_succ = α j
{ have C1 : α i.cast_succ = α j, by rw h', have E1 : update (snoc p x) i.cast_succ y j = _root_.cast C1 y, { have : update (snoc p x) j (_root_.cast C1 y) j = _root_.cast C1 y, by simp, convert this, { exact h'.symm }, { exact heq_of_cast_eq (congr_arg α (eq.symm h')) rfl } }, have C2 : α i.cast_succ = α (cast_succ (cast_lt j h)), by rw [cast_succ_cast_lt, h'], have E2 : update p i y (cast_lt j h) = _root_.cast C2 y, { have : update p (cast_lt j h) (_root_.cast C2 y) (cast_lt j h) = _root_.cast C2 y, by simp, convert this, { simp [h, h'] }, { exact heq_of_cast_eq C2 rfl } }, rw [E1, E2], exact eq_rec_compose _ _ _ }
rw h'
rw h'
have E1 : update (snoc p x) i.cast_succ y j = _root_.cast C1 y
have : update (snoc p x) j (_root_.cast C1 y) j = _root_.cast C1 y
{ have : update (snoc p x) j (_root_.cast C1 y) j = _root_.cast C1 y, by simp, convert this, { exact h'.symm }, { exact heq_of_cast_eq (congr_arg α (eq.symm h')) rfl } }
simp
simp
convert this
exact h'.symm
{ exact h'.symm }
exact heq_of_cast_eq (congr_arg α (eq.symm h')) rfl
{ exact heq_of_cast_eq (congr_arg α (eq.symm h')) rfl }
have C2 : α i.cast_succ = α (cast_succ (cast_lt j h))
rw [cast_succ_cast_lt, h']
rw [cast_succ_cast_lt, h']
have E2 : update p i y (cast_lt j h) = _root_.cast C2 y
have : update p (cast_lt j h) (_root_.cast C2 y) (cast_lt j h) = _root_.cast C2 y
{ have : update p (cast_lt j h) (_root_.cast C2 y) (cast_lt j h) = _root_.cast C2 y, by simp, convert this, { simp [h, h'] }, { exact heq_of_cast_eq C2 rfl } }
simp
simp
convert this
simp [h, h']
{ simp [h, h'] }
exact heq_of_cast_eq C2 rfl
{ exact heq_of_cast_eq C2 rfl }
rw [E1, E2]
exact eq_rec_compose _ _ _
have : ¬(cast_lt j h = i)
{ have : ¬(cast_lt j h = i), by { assume E, apply h', rw [← E, cast_succ_cast_lt] }, simp [h', this, snoc, h] }
assume E
assume E
{ assume E, apply h', rw [← E, cast_succ_cast_lt] }
{ assume E, apply h', rw [← E, cast_succ_cast_lt] }
apply h'
apply h'
rw [← E, cast_succ_cast_lt]
rw [← E, cast_succ_cast_lt]
simp [h', this, snoc, h]
rw eq_last_of_not_lt h
{ rw eq_last_of_not_lt h, simp [ne.symm (ne_of_lt (cast_succ_lt_last i))] }
simp [ne.symm (ne_of_lt (cast_succ_lt_last i))]
intros
{ subst h, simp }
subst h
simp
intros
induction l with hd tl hl
{ simp }
simp
{ simp [hl] }
simp [hl]
intros
simp only [eq_singleton_iff_unique_mem, exists_unique]
intros
rw [← union_eq_right_iff_subset, eq_comm]
intros
simp [@supr_comm _ α, supr_and]
intros
induction s using quotient.induction_on
simp
intros
simp only [← coe_subset, coe_pimage, coe_inter, pfun.image_inter]
intros
substs k l
exact (s.order_emb_of_fin rfl).eq_iff_eq.trans (fin.ext_iff _ _)
intros
rw [← not_nonempty_iff, ← univ_nonempty_iff, not_nonempty_iff_eq_empty]
intros
rw [eq_comm, eq_univ_iff_forall]
simp only [mem_union, mem_map, exists_prop, mem_univ, true_and]
rintro (x|y)
exacts [or.inl ⟨x, rfl⟩, or.inr ⟨y, rfl⟩]
intros
simp only [← fintype.prod_sum_elim, sum.elim_comp_inl_inr]
intros
simp [mul, has_scalar.smul, holor_index.take, holor_index.drop]
intros
split
split; intro h
intro h
cases int.nat_abs_eq a with h₁ h₁; cases int.nat_abs_eq b with h₂ h₂; rw [h₁, h₂]; simp [h]
cases int.nat_abs_eq a with h₁ h₁; cases int.nat_abs_eq b with h₂ h₂; rw [h₁, h₂]
cases int.nat_abs_eq a with h₁ h₁; cases int.nat_abs_eq b with h₂ h₂
cases int.nat_abs_eq a with h₁ h₁
{ cases int.nat_abs_eq a with h₁ h₁; cases int.nat_abs_eq b with h₂ h₂; rw [h₁, h₂]; simp [h], }
cases int.nat_abs_eq b with h₂ h₂
rw [h₁, h₂]
simp [h]
rw [h₁, h₂]
simp [h]
cases int.nat_abs_eq b with h₂ h₂
rw [h₁, h₂]
simp [h]
rw [h₁, h₂]
simp [h]
intro h
cases h; rw h
{ cases h; rw h, rw int.nat_abs_neg, }
cases h
rw h
rw h
rw int.nat_abs_neg
intros
rw [add_comm, add_mod_eq_add_mod_right _ H, add_comm]
intros
rw [←nat_abs_dvd, ←dvd_nat_abs, coe_nat_dvd] at w
rw ←nat_abs_eq_zero
exact eq_zero_of_dvd_of_lt w h
intros
rw [int.gcd, int.lcm, nat.gcd_mul_lcm, nat_abs_mul]
intros
rw int.lcm at h ⊢; rwa int.nat_abs_neg
rw int.lcm at h ⊢
rwa int.nat_abs_neg
intros
convert dif_pos _ using 1
convert coe_greatest_of_bdd_eq _ (classical.some_spec (⟨b, Hb⟩ : bdd_above s)) _
{ convert coe_greatest_of_bdd_eq _ (classical.some_spec (⟨b, Hb⟩ : bdd_above s)) _ }
{ exact ⟨Hinh, b, Hb⟩, }
exact ⟨Hinh, b, Hb⟩
intros
rcases even_or_odd n with ⟨k, rfl⟩ | ⟨k, rfl⟩
rcases even_or_odd n with ⟨k, rfl⟩ | ⟨k, rfl⟩; use k
use k
simpa only [xor, true_and, eq_self_iff_true, not_true, or_false, and_false] using (succ_ne_self (2*k)).symm
{ simpa only [xor, true_and, eq_self_iff_true, not_true, or_false, and_false] using (succ_ne_self (2*k)).symm }
use k
simp only [xor, add_right_eq_self, false_or, eq_self_iff_true, not_true, not_false_iff, one_ne_zero, and_self]
{ simp only [xor, add_right_eq_self, false_or, eq_self_iff_true, not_true, not_false_iff, one_ne_zero, and_self] }
intros
{ simp at hi, rw nth_le_take L _ hi.1 }
simp at hi
rw nth_le_take L _ hi.1
intros
split
intro h
{ intro h, refine ⟨λ x y, _⟩, suffices : [x] = [y], { simpa using this }, apply h, refl }
refine ⟨λ x y, _⟩
suffices : [x] = [y]
simpa using this
{ simpa using this }
apply h
refl
intros hα l1 l2 hl
{ intros hα l1 l2 hl, induction l1 generalizing l2; cases l2, { refl }, { cases hl }, { cases hl }, congr, exactI subsingleton.elim _ _, apply l1_ih, simpa using hl }
induction l1 generalizing l2
induction l1 generalizing l2; cases l2
cases l2
{ refl }
refl
cases hl
{ cases hl }
cases l2
cases hl
{ cases hl }
congr
apply l1_ih
simpa using hl
intros
simp only [all_iff_forall, bool.of_to_bool_iff]
intros
rw [← filter_map_eq_filter, filter_map_filter_map]
rw [← filter_map_eq_filter, filter_map_filter_map]; refl
refl
intros
induction l with x l ih; [refl, by_cases (p x)]; [simp only [filter_cons_of_pos _ h, countp, ih, if_pos h], simp only [countp_cons_of_neg _ _ h, ih, filter_cons_of_neg _ h]]; refl
induction l with x l ih; [refl, by_cases (p x)]; [simp only [filter_cons_of_pos _ h, countp, ih, if_pos h], simp only [countp_cons_of_neg _ _ h, ih, filter_cons_of_neg _ h]]
induction l with x l ih; [refl, by_cases (p x)]
induction l with x l ih
refl
by_cases (p x)
simp only [filter_cons_of_pos _ h, countp, ih, if_pos h]
refl
simp only [countp_cons_of_neg _ _ h, ih, filter_cons_of_neg _ h]
intros
induction ts with a ts ih
refl
{refl}
simp [permutations'_aux, permutations_aux2_snd_cons, ih]
simp only [← permutations_aux2_append] {single_pass := tt}
simp [map_permutations_aux2]
intros
induction l₁ with x l₁ IH; [refl, simp only [map, sigma_cons, length_append, length_map, IH, sum_cons]]
induction l₁ with x l₁ IH
refl
simp only [map, sigma_cons, length_append, length_map, IH, sum_cons]
intros
cases bs; refl
cases bs
refl
refl
intros
induction l; [refl, simp only [*, map, reverse_cons, map_append]]
induction l
refl
simp only [*, map, reverse_cons, map_append]
intros
induction l with b l ih
cases h
{cases h}
rcases h with rfl | h
{ exact ⟨[], l, rfl⟩ }
exact ⟨[], l, rfl⟩
rcases ih h with ⟨s, t, rfl⟩
{ rcases ih h with ⟨s, t, rfl⟩, exact ⟨b::s, t, rfl⟩ }
exact ⟨b::s, t, rfl⟩
intros
cases l
{ simpa [hy, hz] using h }
simpa [hy, hz] using h
{ rw [prev, dif_neg hy, if_neg hz] }
rw [prev, dif_neg hy, if_neg hz]
intros
apply mmap_with_index'_aux_eq_mmap_with_index_aux
intros
classical; exact decidable.list.lex.ne_iff H
classical
exact decidable.list.lex.ne_iff H
intros
rw nodup_erase_eq_filter b d; simp only [mem_filter, and_comm]
rw nodup_erase_eq_filter b d
simp only [mem_filter, and_comm]
intros
simp only [pairwise_cons, mem_singleton, forall_eq, forall_prop_of_false (not_mem_nil _), forall_true_iff, pairwise.nil, and_true]
intros
induction l with a l IH; simp; exact (h a).append IH
induction l with a l IH; simp
induction l with a l IH
simp
simp
exact (h a).append IH
intros
simp only [fin_range, nth_le_range, nth_le_pmap, fin.mk_eq_subtype_mk]
intros
have : (l.rotate k).cyclic_permutations.length = length (l.cyclic_permutations.rotate k)
cases l
{ cases l, { simp }, { rw length_cyclic_permutations_of_ne_nil; simp } }
{ simp }
simp
rw length_cyclic_permutations_of_ne_nil; simp
rw length_cyclic_permutations_of_ne_nil
{ rw length_cyclic_permutations_of_ne_nil; simp }
simp
simp
refine ext_le this (λ n hn hn', _)
rw [nth_le_cyclic_permutations, nth_le_rotate, nth_le_cyclic_permutations, rotate_rotate, ←rotate_mod, add_comm]
cases l; simp
cases l
simp
simp
intros
induction l with _ _ ih; [refl, { simp [not_or_distrib] at h, simp [h.1, ih h.2] }]
induction l with _ _ ih
refl
simp [not_or_distrib] at h
simp [h.1, ih h.2]
intros
rw [← zip_swap, unzip_swap]; exact unzip_zip_left h
rw [← zip_swap, unzip_swap]
exact unzip_zip_left h
intros
ext i
{ ext i, simp only [mul_vec, dot_product, finset.smul_sum, pi.smul_apply, mul_smul_comm] }
simp only [mul_vec, dot_product, finset.smul_sum, pi.smul_apply, mul_smul_comm]
intros
{ ext, simp [diagonal] }
ext
simp [diagonal]
intros
{ ext i j, apply zero_dot_product }
ext i j
apply zero_dot_product
intros
simp [hi]
intros
simp [sub_eq_add_neg]
intros
{ rw [← fin.succ_zero_eq_one, cons_val_succ], refl }
rw [← fin.succ_zero_eq_one, cons_val_succ]
refl
intros
simp [h]
intros
rw [← sup_erase_dup, erase_dup_ext.2, sup_erase_dup, sup_cons]
rw [← sup_erase_dup, erase_dup_ext.2, sup_erase_dup, sup_cons]; simp
simp
intros
apply mv_polynomial.induction_on p; simp [eval₂_add, eval₂_mul] {contextual := tt}
apply mv_polynomial.induction_on p
simp [eval₂_add, eval₂_mul] {contextual := tt}
simp [eval₂_add, eval₂_mul] {contextual := tt}
simp [eval₂_add, eval₂_mul] {contextual := tt}
intros
apply mv_polynomial.induction_on p; { intros, simp [*] }
apply mv_polynomial.induction_on p
{ intros, simp [*] }
{ intros, simp [*] }
intros
{ intros, simp [*] }
simp [*]
intros
rw [vars, degrees_C, multiset.to_finset_zero]
intros
split
rintro rfl
{ rintro rfl, exact ⟨nat.find_spec h, λ _, nat.find_min h⟩ }
exact ⟨nat.find_spec h, λ _, nat.find_min h⟩
rintro ⟨hm, hlt⟩
{ rintro ⟨hm, hlt⟩, exact le_antisymm (nat.find_min' h hm) (not_lt.1 $ imp_not_comm.1 (hlt _) $ nat.find_spec h) }
exact le_antisymm (nat.find_min' h hm) (not_lt.1 $ imp_not_comm.1 (hlt _) $ nat.find_spec h)
intros
simp [test_bit]
intros
cases b
cases n; simp
{ cases n; simp }
cases n
simp
simp
cases b
{ cases b, { simp }, { apply nat.strong_induction_on n, clear n, intros n IH, cases n, { simp }, { rw [digits_add_two_add_one, digits_add_two_add_one], by_cases hdvd : (b.succ.succ) ∣ (n.succ+1), { rw [nat.succ_div_of_dvd hdvd, list.length_cons, list.length_cons, nat.succ_le_succ_iff], apply IH, exact nat.div_lt_self (by linarith) (by linarith) }, { rw nat.succ_div_of_not_dvd hdvd, refl } } } }
{ simp }
simp
apply nat.strong_induction_on n
{ apply nat.strong_induction_on n, clear n, intros n IH, cases n, { simp }, { rw [digits_add_two_add_one, digits_add_two_add_one], by_cases hdvd : (b.succ.succ) ∣ (n.succ+1), { rw [nat.succ_div_of_dvd hdvd, list.length_cons, list.length_cons, nat.succ_le_succ_iff], apply IH, exact nat.div_lt_self (by linarith) (by linarith) }, { rw nat.succ_div_of_not_dvd hdvd, refl } } }
clear n
intros n IH
cases n
{ simp }
simp
rw [digits_add_two_add_one, digits_add_two_add_one]
{ rw [digits_add_two_add_one, digits_add_two_add_one], by_cases hdvd : (b.succ.succ) ∣ (n.succ+1), { rw [nat.succ_div_of_dvd hdvd, list.length_cons, list.length_cons, nat.succ_le_succ_iff], apply IH, exact nat.div_lt_self (by linarith) (by linarith) }, { rw nat.succ_div_of_not_dvd hdvd, refl } }
by_cases hdvd : (b.succ.succ) ∣ (n.succ+1)
rw [nat.succ_div_of_dvd hdvd, list.length_cons, list.length_cons, nat.succ_le_succ_iff]
{ rw [nat.succ_div_of_dvd hdvd, list.length_cons, list.length_cons, nat.succ_le_succ_iff], apply IH, exact nat.div_lt_self (by linarith) (by linarith) }
apply IH
exact nat.div_lt_self (by linarith) (by linarith)
rw nat.succ_div_of_not_dvd hdvd
{ rw nat.succ_div_of_not_dvd hdvd, refl }
refl
intros
rw [add_comm a, add_comm a, enat.add_right_cancel_iff ha]
intros
obtain ⟨n, rfl⟩ := exists_eq_succ_of_ne_zero hn.ne'
rw [pow_succ, nat.coprime_mul_iff_left]
exact ⟨and.left, λ hab, ⟨hab, hab.pow_left _⟩⟩
intros
rw [clog_of_two_le (hn.trans h) hn, clog_of_right_le_one]
have n_pos : 0 < n := zero_lt_two.trans_le hn
rw [←lt_succ_iff, nat.div_lt_iff_lt_mul _ _ (n_pos.trans_le h), ←succ_le_iff, ←pred_eq_sub_one, succ_pred_eq_of_pos (add_pos n_pos (n_pos.trans_le h)), succ_mul, one_mul]
exact add_le_add_right h _
intros
rwa [add_comm, nat.add_div_of_dvd_right, add_comm]
intros
rw [even_iff, mod_two_ne_zero]
intros
refine ⟨_, λ h, by rw [h.1, h.2, pow_one]⟩
rintro rfl
rw [hp.eq_one_of_pow, eq_self_iff_true, and_true, pow_one]
intros
rw [psub']; split_ifs; [exact (psub_eq_sub h).symm, exact (psub_eq_none.2 (not_le.1 h)).symm]
rw [psub']; split_ifs
rw [psub']
split_ifs
exact (psub_eq_sub h).symm
exact (psub_eq_none.2 (not_le.1 h)).symm
intros
cases x; simp
{ cases x; simp }
cases x
simp
simp
intros
rw h.1; apply nat.le_add_left
rw h.1
apply nat.le_add_left
intros
rw [← dual_dual (balance_l _ _ _), dual_balance_l, dual_dual, dual_dual]
intros
cases o; refl
cases o
refl
refl
intros
generalize_hyp ef : @split_fun n _ (append1 α (M P α)) f' f₁' = ff at e₁
cases e₁' : pfunctor.M.dest a₁ with a₁' g₁'
rw M.dest_eq_dest' _ e₁' at e₁
cases e₁
exact ⟨_, e₁', split_fun_inj ef⟩
intros
cases x
cases x; refl
{ cases x; refl }
refl
intros
split
split; intro h
intro h
rcases h with ⟨_, rfl⟩
apply dvd_mul_right
intro h
rcases h with ⟨a, h⟩
cases a
contrapose h
{ contrapose h, apply ne_zero, }
apply ne_zero
use a.succ
apply nat.succ_pos
rw [← coe_inj, h, mul_coe, mk_coe]
intros
let n := u.prod
let m := v.prod
change (u ⊓ v).prod = pnat.gcd n m
have : u = n.factor_multiset := u.factor_multiset_prod.symm
rw [this]
have : v = m.factor_multiset := v.factor_multiset_prod.symm
rw [this]
rw [← pnat.factor_multiset_gcd n m, pnat.prod_factor_multiset]
intros
simp [aeval_def]
intros
convert support_monomial n 1 H
exact X_pow_eq_monomial n
intros
split_ifs
rw [←@nat.sub_add_cancel d n h, coeff_mul_X_pow, nat.add_sub_cancel]
{ rw [←@nat.sub_add_cancel d n h, coeff_mul_X_pow, nat.add_sub_cancel] }
refine (coeff_mul _ _ _).trans (finset.sum_eq_zero (λ x hx, _))
{ refine (coeff_mul _ _ _).trans (finset.sum_eq_zero (λ x hx, _)), rw [coeff_X_pow, if_neg, mul_zero], exact ne_of_lt (lt_of_le_of_lt (nat.le_of_add_le_right (le_of_eq (finset.nat.mem_antidiagonal.mp hx))) (not_le.mp h)) }
rw [coeff_X_pow, if_neg, mul_zero]
exact ne_of_lt (lt_of_le_of_lt (nat.le_of_add_le_right (le_of_eq (finset.nat.mem_antidiagonal.mp hx))) (not_le.mp h))
intros
rw [degree, support_monomial _ _ ha]; refl
rw [degree, support_monomial _ _ ha]
refl
intros
apply (degree_le_iff_coeff_zero _ _).2 (λ m hm, _)
rw degree_lt_iff_coeff_zero at hm
simp [hm m (le_refl _)]
intros
simp_rw [nat_degree_le_iff_degree_le, degree_le_iff_coeff_zero, with_bot.coe_lt_coe]
intros
simp [bit1]
intros
rw [C_mul_X_pow_eq_monomial, erase_lead_monomial]
intros
convert eval₂_at_apply f 1
simp
intros
apply polynomial.induction_on' p
{ intros p q hp hq, simp [hp, hq], }
intros p q hp hq
simp [hp, hq]
{ intros n r, simp, }
intros n r
simp
intros
refine bInter_subset_of_mem _
rintros _ ⟨i, rfl⟩
exact set_like.mem_coe.mpr (cf i)
intros
simp only [iterated_deriv, derivative_X, function.iterate_one]
intros
by_cases hp : p = 0
{ rw [hp, mirror_zero] }
rw [hp, mirror_zero]
by_cases hR : nontrivial R
haveI := hR
{ haveI := hR, rw [mirror, nat_degree_mul', reverse_nat_degree, nat_degree_X_pow, nat.sub_add_cancel p.nat_trailing_degree_le_nat_degree], rwa [leading_coeff_X_pow, mul_one, reverse_leading_coeff, ne, trailing_coeff_eq_zero] }
rw [mirror, nat_degree_mul', reverse_nat_degree, nat_degree_X_pow, nat.sub_add_cancel p.nat_trailing_degree_le_nat_degree]
rwa [leading_coeff_X_pow, mul_one, reverse_leading_coeff, ne, trailing_coeff_eq_zero]
haveI := not_nontrivial_iff_subsingleton.mp hR
{ haveI := not_nontrivial_iff_subsingleton.mp hR, exact congr_arg nat_degree (subsingleton.elim p.mirror p) }
exact congr_arg nat_degree (subsingleton.elim p.mirror p)
intros
rw [trailing_coeff, reverse_nat_trailing_degree, coeff_zero_reverse]
intros
rw [← sub_eq_zero]
apply eq_zero_of_infinite_is_root
simpa only [is_root, eval_sub, sub_eq_zero]
intros
rcases h1 with ⟨q, rfl⟩
rw mul_ne_zero_iff at h2
rw [nat_degree_mul h2.1 h2.2]
exact nat.le_add_right _ _
intros
rw [← int.cast_coe_nat, coe_int_eq_mk]
intros
rw ← neg_one_mul; exact mul_lim_zero_right _ hf
rw ← neg_one_mul
exact mul_lim_zero_right _ hf
intros
rw [div_eq_mul_inv, inv_top, mul_zero]
intros
split_ifs
simp [h]
{ simp [h] }
exact with_top.mul_top h
{ exact with_top.mul_top h }
rw [coe_inv (ne_of_gt _root_.zero_lt_two), coe_two]
rw [golden_ratio, ←sub_eq_zero]
ring_exp
rw real.sq_sqrt; norm_num
rw real.sq_sqrt
norm_num
norm_num
rw ←inv_epsilon_eq_omega
rw ←inv_epsilon_eq_omega; exact inv_pos.2 epsilon_pos
exact inv_pos.2 epsilon_pos
intros
rw [← mul_lt_mul_left (pos_iff_ne_zero.2 h), mul_inv_cancel h, mul_comm]
intros
refine le_trans _ hz
rw sqrt_two_add_series_succ
apply sqrt_two_add_series_monotone_left
have hb' : 0 < (b:ℝ) := nat.cast_pos.2 hb
have hd' : 0 < (d:ℝ) := nat.cast_pos.2 hd
rw [sqrt_le_left (div_nonneg c.cast_nonneg d.cast_nonneg), div_pow, add_div_eq_mul_add_div _ _ (ne_of_gt hb'), div_le_div_iff hb' (pow_pos hd' _)]
exact_mod_cast h
intros
rw ← sqrt_sq_eq_abs; exact sqrt_le_sqrt h
rw ← sqrt_sq_eq_abs
exact sqrt_le_sqrt h
intros
ext x y
{ ext x y, reflexivity }
reflexivity
intros
have := results_thinkN n (results_ret a); rwa nat.zero_add at this
have := results_thinkN n (results_ret a)
rwa nat.zero_add at this
intros
cases s' with st'
have : st' n = none
from s'_nth_eq_none
cases s with st
cases st_nth_eq : st n; simp only [zip_with, seq.nth, *]
cases st_nth_eq : st n
simp only [zip_with, seq.nth, *]
simp only [zip_with, seq.nth, *]
intros
rw [lift_rel_destruct_iff, lift_rel_destruct_iff]
rw [lift_rel_destruct_iff, lift_rel_destruct_iff]; simp
simp
intros
ext
{ ext, simp [and_iff_left_of_imp (λ hx : x ∈ s, show x ≠ a, from λ hxa, h $ hxa ▸ hx)] }
simp [and_iff_left_of_imp (λ hx : x ∈ s, show x ≠ a, from λ hxa, h $ hxa ▸ hx)]
intros
simp
intros
refine ⟨λ h y, _, surjective.image_surjective⟩
cases h {y} with s hs
have := mem_singleton y
rw [← hs] at this
rcases this with ⟨x, h1x, h2x⟩
exact ⟨x, h2x⟩
intros
rw [inter_comm, singleton_inter_nonempty]
intros
ext
ext; simp
simp
intros
simp [piecewise]
ext i
by_cases h : i = j
{ rw h, simp }
rw h
simp
by_cases h' : i ∈ s; simp [h, h']
{ by_cases h' : i ∈ s; simp [h, h'] }
by_cases h' : i ∈ s
simp [h, h']
simp [h, h']
intros
{ ext x, simp [Ici] }
ext x
simp [Ici]
intros
rw [diff_eq, compl_Ioi, Ioi_inter_Iic]
intros
ext1 x
simp_rw [mem_union, mem_Ico, min_le_iff, lt_max_iff]
by_cases hc : c ≤ x; by_cases hd : x < d
by_cases hc : c ≤ x
by_cases hd : x < d
{ tauto }
tauto
have hax : a ≤ x := h₂.trans (le_of_not_gt hd)
{ have hax : a ≤ x := h₂.trans (le_of_not_gt hd), tauto }
tauto
by_cases hd : x < d
have hxb : x < b := (lt_of_not_ge hc).trans_le h₁
{ have hxb : x < b := (lt_of_not_ge hc).trans_le h₁, tauto }
tauto
{ tauto }
tauto
intros
simp [add_comm]
intros
simp [sub_eq_neg_add]
intros
refine ⟨λ _ h, ⟨add_lt_add_right h.1 _, add_le_add_right h.2 _⟩, λ _ _ _ _ h, add_right_cancel h, λ _ h, _⟩
obtain ⟨c, rfl⟩ := exists_add_of_le h.1.le
rw [mem_Ioc, add_right_comm, add_lt_add_iff_right, add_le_add_iff_right] at h
exact ⟨a + c, h, by rw add_right_comm⟩
intros
simp only [Inter, infi_subtype']
haveI : nonempty {i // p i} := nonempty_subtype.2 hp
apply inj_on.image_Inter_eq
simpa only [Union, supr_subtype'] using h
intros
rw [← prod_eq_seq, ← image_swap_prod, prod_eq_seq, image_seq, ← image_comp, prod.swap]
intros
simp only [Inter_or, Inter_inter_distrib, Inter_Inter_eq_left]
intros
simp
intros
rw ← update_inr_comp_inr
intros
apply elim_of_ne
{ apply elim_of_ne, rintro rfl, exact not_mem_of_nodup_cons hl hj }
rintro rfl
exact not_mem_of_nodup_cons hl hj
intros
{ ext i : 2, induction i; simp [drop_fun,*]; refl }
ext i : 2
induction i
induction i; simp [drop_fun,*]; refl
induction i; simp [drop_fun,*]
simp [drop_fun,*]
refl
intros
rw [← nat.cast_one, val_nat_cast]
intros
have : (a.val : ℤ) - n ≤ 0
erw [sub_nonpos, int.coe_nat_le]
erw [sub_nonpos, int.coe_nat_le]
{ erw [sub_nonpos, int.coe_nat_le], exact a.val_le, }
{ erw [sub_nonpos, int.coe_nat_le], exact a.val_le, }
exact a.val_le
exact a.val_le
rw [zmod.val_min_abs_def_pos]
split_ifs
{ rw [int.nat_abs_of_nat, nat_cast_zmod_val] }
rw [int.nat_abs_of_nat, nat_cast_zmod_val]
rw [← int.cast_coe_nat, int.of_nat_nat_abs_of_nonpos this, int.cast_neg, int.cast_sub]
{ rw [← int.cast_coe_nat, int.of_nat_nat_abs_of_nonpos this, int.cast_neg, int.cast_sub], rw [int.cast_coe_nat, int.cast_coe_nat, nat_cast_self, sub_zero, nat_cast_zmod_val], }
rw [int.cast_coe_nat, int.cast_coe_nat, nat_cast_self, sub_zero, nat_cast_zmod_val]
intros
simpa only [sub_eq_add_neg] using (f.commute_add_nat n).inverses_right (equiv.add_right _).right_inv (equiv.add_right _).left_inv
intros
refine ⟨λ h, h ▸ f.exists_eq_add_translation_number hf, _⟩
rintros ⟨x, hx⟩
exact f.translation_number_of_eq_add_int hx
intros
{ rw omega_limit_eq_bInter_inter _ _ _ hv, apply bInter_eq_Inter }
rw omega_limit_eq_bInter_inter _ _ _ hv
apply bInter_eq_Inter
intros
ext
rw iff_true_right intermediate_field.mem_top
exact finrank_adjoin_simple_eq_one_iff.mp (h x)
intros
rw [← cardinal.lift_inj, ← (basis_monomials σ K).mk_eq_dim]
intros
rcases x with ⟨m, x⟩
induction m with m ih
refl
{refl}
rw [iterate_succ_apply', ← ih]; refl
rw [iterate_succ_apply', ← ih]
refl
intros
simp_rw [root_set_def, finset.coe_sort_coe, fintype.card_coe]
rw [multiset.to_finset_card_of_nodup, ←nat_degree_eq_card_roots hsplit]
exact nodup_roots hsep.map
intros
simpa using eq_prod_roots_of_splits hsplit
intros
cases h : degree f with n
rw [degree_eq_bot.1 h]; exact splits_zero i
{ rw [degree_eq_bot.1 h]; exact splits_zero i }
rw [degree_eq_bot.1 h]
exact splits_zero i
cases n with n
{ cases n with n, { rw [eq_C_of_degree_le_zero (trans_rel_right (≤) h (le_refl _))]; exact splits_C _ _ }, { have hn : n = 0, { rw h at hf, cases n, { refl }, { exact absurd hf dec_trivial } }, exact splits_of_degree_eq_one _ (by rw [h, hn]; refl) } }
rw [eq_C_of_degree_le_zero (trans_rel_right (≤) h (le_refl _))]; exact splits_C _ _
rw [eq_C_of_degree_le_zero (trans_rel_right (≤) h (le_refl _))]
{ rw [eq_C_of_degree_le_zero (trans_rel_right (≤) h (le_refl _))]; exact splits_C _ _ }
exact splits_C _ _
have hn : n = 0
{ have hn : n = 0, { rw h at hf, cases n, { refl }, { exact absurd hf dec_trivial } }, exact splits_of_degree_eq_one _ (by rw [h, hn]; refl) }
rw h at hf
{ rw h at hf, cases n, { refl }, { exact absurd hf dec_trivial } }
cases n
refl
{ refl }
exact absurd hf dec_trivial
{ exact absurd hf dec_trivial }
exact splits_of_degree_eq_one _ (by rw [h, hn]; refl)
intros
use add_torsor.nonempty.some
simp
intros
ext
{ ext, simp only [times_cont_mdiff_map.comp_apply, R_apply, mul_assoc] }
simp only [times_cont_mdiff_map.comp_apply, R_apply, mul_assoc]
intros
simp [atlas, charted_space.atlas]
intros
rw ← lift_prop_within_at_univ at h
exact lift_prop_within_at_mono mono h (subset_univ _)
intros
rw [has_mfderiv_within_at, has_mfderiv_within_at, ext_chart_preimage_inter_eq, has_fderiv_within_at_inter, continuous_within_at_inter h]
exact ext_chart_preimage_mem_nhds I x h
intros
apply has_mfderiv_at.mfderiv
exact has_mfderiv_at.comp x hg.has_mfderiv_at hf.has_mfderiv_at
intros
rw [times_cont_diff_groupoid, mem_groupoid_of_pregroupoid]
suffices h : times_cont_diff_on 𝕜 n (I ∘ I.symm) (I.symm ⁻¹' s ∩ range I)
simp [h]
simp [h]
have : times_cont_diff_on 𝕜 n id (univ : set E) := times_cont_diff_id.times_cont_diff_on
exact this.congr_mono (λ x hx, by simp [hx.2]) (subset_univ _)
intros
apply h.mono (λ y hy, _)
simp only with mfld_simps at hy
simp only [hy, hts _] with mfld_simps
intros
simp only [pi.one_def, times_cont_mdiff_const]
intros
ext x y
simp only [add_monoid_hom.id_comp]
rw [add_monoid_hom.comp_assoc, finsupp.to_free_abelian_group_comp_single_add_hom]
simp only [to_finsupp, add_monoid_hom.coe_comp, finsupp.single_add_hom_apply, function.comp_app, one_smul, lift.of, add_monoid_hom.flip_apply, smul_add_hom_apply, add_monoid_hom.id_apply]
intros
rcases x with ⟨L⟩; simp
rcases x with ⟨L⟩
simp
intros
ext z
show j.to_map _ * _ = j.to_map (l _) * _
rw [mul_inv_left, ←mul_assoc, mul_inv_right]
{ rw [mul_inv_left, ←mul_assoc, mul_inv_right], show j.to_map _ * j.to_map (l (g _)) = j.to_map (l _) * _, rw [←j.to_map.map_mul, ←j.to_map.map_mul, ←l.map_mul, ←l.map_mul], exact k.comp_eq_of_eq hl j (by rw [k.to_map.map_mul, k.to_map.map_mul, sec_spec', mul_assoc, map_mul_right]) }
show j.to_map _ * j.to_map (l (g _)) = j.to_map (l _) * _
rw [←j.to_map.map_mul, ←j.to_map.map_mul, ←l.map_mul, ←l.map_mul]
exact k.comp_eq_of_eq hl j (by rw [k.to_map.map_mul, k.to_map.map_mul, sec_spec', mul_assoc, map_mul_right])
intros
rw [order_of, one_mul_eq_id, minimal_period_id]
intros
rw [is_periodic_pt, is_fixed_pt, add_left_iterate, add_zero]
intros
convert function.commute.minimal_period_of_comp_dvd_lcm h.function_commute_mul_left
rw [order_of, comp_mul_left]
intros
induction s using quot.induction_on
exact list.is_cycle_form_perm h (length_nontrivial hn)
intros
simp_rw [set.eq_singleton_iff_unique_mem, mem_iff, vector.to_list_singleton, list.prod_singleton, vector.head_cons]
exact ⟨rfl, λ v hv, v.cons_head_tail.symm.trans (congr_arg2 vector.cons hv v.tail.eq_nil)⟩
intros
classical
have : is_of_fin_order f := exists_pow_eq_one f
rw is_of_fin_order_iff_pow_eq_one at this
obtain ⟨x, hx, hx'⟩ := hf
obtain ⟨_ | _ | k, hk, hk'⟩ := this
{ exact absurd hk (lt_asymm hk) }
exact absurd hk (lt_asymm hk)
rw pow_one at hk'
{ rw pow_one at hk', simpa [hk'] using hx }
simpa [hk'] using hx
{ exact ⟨k + 2, by simp, hk'⟩ }
exact ⟨k + 2, by simp, hk'⟩
intros
rw order_of_dvd_iff_pow_eq_one
split
intros h H
{ intros h H, refine hf.ne_one _, rw [←support_eq_empty_iff, ←h, H, support_one] }
refine hf.ne_one _
rw [←support_eq_empty_iff, ←h, H, support_one]
intro H
{ intro H, apply le_antisymm (support_pow_le _ n) _, intros x hx, contrapose! H, ext z, by_cases hz : f z = z, { rw [pow_apply_eq_self_of_apply_eq_self hz, one_apply] }, { obtain ⟨k, rfl⟩ := hf.exists_pow_eq hz (mem_support.mp hx), apply (f ^ k).injective, rw [←mul_apply, (commute.pow_pow_self _ _ _).eq, mul_apply], simpa using H } }
apply le_antisymm (support_pow_le _ n) _
intros x hx
contrapose! H
ext z
by_cases hz : f z = z
{ rw [pow_apply_eq_self_of_apply_eq_self hz, one_apply] }
rw [pow_apply_eq_self_of_apply_eq_self hz, one_apply]
obtain ⟨k, rfl⟩ := hf.exists_pow_eq hz (mem_support.mp hx)
{ obtain ⟨k, rfl⟩ := hf.exists_pow_eq hz (mem_support.mp hx), apply (f ^ k).injective, rw [←mul_apply, (commute.pow_pow_self _ _ _).eq, mul_apply], simpa using H }
apply (f ^ k).injective
rw [←mul_apply, (commute.pow_pow_self _ _ _).eq, mul_apply]
simpa using H
intros
have : f.cycle_factors_finset = f.cycle_factors_finset := rfl
obtain ⟨-, hd, -⟩ := cycle_factors_finset_eq_finset.mp this
exact hd p hp q hq h
intros
rw [← fin.succ_zero_eq_one, equiv.perm.decompose_fin_symm_apply_succ e p 0]
intros
induction xs using list.reverse_rec_on with xs y IH generalizing x
induction xs using list.reverse_rec_on with xs y IH generalizing x; simp
simp
simp
intros
rw [monoid_hom.map_inv sign f, int.units_inv_eq_self]
intros
rw [support, mem_filter, and_iff_right (mem_univ x)]
intros
intro x
rw [inv_eq_iff_eq, eq_comm]
exact h x
intros
induction k with k IH
{ refl }
refl
rw [pow_succ, IH, r_mul_r]
{ rw [pow_succ, IH, r_mul_r], congr' 1, norm_cast, rw nat.one_add }
congr' 1
norm_cast
rw nat.one_add
intros
rintros a hc
{ rintros a hc, obtain ⟨c, rfl⟩ := is_conj_iff.1 hc, exact tn.conj_mem a h c }
obtain ⟨c, rfl⟩ := is_conj_iff.1 hc
exact tn.conj_mem a h c
intros
rwa [map_comap_eq, inf_eq_right]
intros
refine map_injective_of_ker_le B.subtype (ker_le_comap _ _) (le_trans (ker_le_comap B.subtype _) le_sup_left) _
simp only [subgroup_of, map_comap_eq, map_sup, subtype_range]
{ simp only [subgroup_of, map_comap_eq, map_sup, subtype_range], rw [inf_of_le_right (sup_le hA hA'), inf_of_le_right hA', inf_of_le_right hA] }
rw [inf_of_le_right (sup_le hA hA'), inf_of_le_right hA', inf_of_le_right hA]
intros
simpa only [mrange_eq_map] using (⊤ : submonoid M).map_map g f
intros
ext x
rw [mem_coe, ←vsub_right_mem_direction_iff_mem (mem_affine_span k (set.mem_singleton p)) _, direction_affine_span]
simp
intros
rw [attach_affine_combination_of_injective s w (coe : s → P) subtype.coe_injective, univ_eq_attach, attach_image_coe]
intros
split
exact λ h w hw hs i, h finset.univ w hw hs i (finset.mem_univ _)
{ exact λ h w hw hs i, h finset.univ w hw hs i (finset.mem_univ _) }
intros h s w hw hs i hi
{ intros h s w hw hs i hi, rw finset.weighted_vsub_indicator_subset _ _ (finset.subset_univ s) at hs, rw set.sum_indicator_subset _ (finset.subset_univ s) at hw, replace h := h ((↑s : set ι).indicator w) hw hs i, simpa [hi] using h }
rw finset.weighted_vsub_indicator_subset _ _ (finset.subset_univ s) at hs
rw set.sum_indicator_subset _ (finset.subset_univ s) at hw
replace h := h ((↑s : set ι).indicator w) hw hs i
simpa [hi] using h
intros
rw [span_int_eq_add_subgroup_closure, s.closure_eq]
intros
ext b
ext b; simp only [submodule.mem_comap, p.smul_mem_iff h, linear_map.smul_apply]
simp only [submodule.mem_comap, p.smul_mem_iff h, linear_map.smul_apply]
intros
rw [submodule.comap_map_eq, sup_of_le_left h]
intros
{ ext m, apply pow_apply, }
ext m
apply pow_apply
intros
convert (of_vector_space K V).linear_independent
{ convert (of_vector_space K V).linear_independent, ext x, rw of_vector_space_apply_self }
ext x
rw of_vector_space_apply_self
intros
ext ⟨bi, hbi⟩
rw [reindex_finset_range, reindex_repr, reindex_range_repr_self]
convert finsupp.single_apply_left ((equiv.refl M).subtype_equiv _).symm.injective _ _ _
refl
intros
conv_rhs { rw [← b.total_repr x, ← b.total_repr y] }
simp_rw [finsupp.total_apply, finsupp.sum, sum_left, sum_right, smul_left, smul_right, smul_eq_mul]
intros
rw [det_mul, det_mul, mul_comm]
intros
{ classical, exact (basis.of_vector_space K V).eval_range }
classical
exact (basis.of_vector_space K V).eval_range
intros
simp only [maximal_generalized_eigenspace, ← mem_generalized_eigenspace, submodule.mem_supr_of_chain]
intros
haveI := finite_dimensional_of_dim_eq_zero h
apply eq_top_of_finrank_eq
rw [finrank_bot, finrank_eq_zero_of_dim_eq_zero h]
intros
rw finsupp.mem_supported
intros
simp [lcongr]
intros
ext
{ ext, rw [basis.to_matrix_apply, linear_map.to_matrix_apply, basis.constr_basis] }
rw [basis.to_matrix_apply, linear_map.to_matrix_apply, basis.constr_basis]
intros
apply minpoly.unique
{ apply matrix.charpoly_monic }
apply matrix.charpoly_monic
apply (left_mul_matrix _).injective_iff.mp (left_mul_matrix_injective h.basis)
{ apply (left_mul_matrix _).injective_iff.mp (left_mul_matrix_injective h.basis), rw [← polynomial.aeval_alg_hom_apply, aeval_self_charpoly] }
rw [← polynomial.aeval_alg_hom_apply, aeval_self_charpoly]
intros q q_monic root_q
{ intros q q_monic root_q, rw [matrix.charpoly_degree_eq_dim, fintype.card_fin, degree_eq_nat_degree q_monic.ne_zero], apply with_bot.some_le_some.mpr, exact h.dim_le_nat_degree_of_root q_monic.ne_zero root_q }
rw [matrix.charpoly_degree_eq_dim, fintype.card_fin, degree_eq_nat_degree q_monic.ne_zero]
apply with_bot.some_le_some.mpr
exact h.dim_le_nat_degree_of_root q_monic.ne_zero root_q
intros
{ rw ← det_transpose, exact det_eq_zero_of_row_eq_zero j h, }
rw ← det_transpose
exact det_eq_zero_of_row_eq_zero j h
intros
rw [dot_product_std_basis_eq_mul, mul_one]
intros
rw [linear_map.to_matrix, linear_equiv.trans_apply, linear_map.to_matrix'_apply, linear_equiv.arrow_congr_apply, basis.equiv_fun_symm_apply, finset.sum_eq_single j, if_pos rfl, one_smul, basis.equiv_fun_apply]
intros j' _ hj'
{ intros j' _ hj', rw [if_neg hj', zero_smul] }
rw [if_neg hj', zero_smul]
intro hj
{ intro hj, have := finset.mem_univ j, contradiction }
have := finset.mem_univ j
contradiction
intros
cases t
ext a b
simp only [reindex_equiv, transvection, mul_boole, algebra.id.smul_eq_mul, to_matrix_mk, minor_apply, reindex_apply, dmatrix.add_apply, pi.smul_apply, reindex_alg_equiv_apply]
by_cases ha : e t_i = a; by_cases hb : e t_j = b; by_cases hab : a = b; simp [ha, hb, hab, ← e.apply_eq_iff_eq_symm_apply, std_basis_matrix]
by_cases ha : e t_i = a; by_cases hb : e t_j = b; by_cases hab : a = b
by_cases ha : e t_i = a; by_cases hb : e t_j = b
by_cases ha : e t_i = a
by_cases hb : e t_j = b
by_cases hab : a = b
simp [ha, hb, hab, ← e.apply_eq_iff_eq_symm_apply, std_basis_matrix]
simp [ha, hb, hab, ← e.apply_eq_iff_eq_symm_apply, std_basis_matrix]
by_cases hab : a = b
simp [ha, hb, hab, ← e.apply_eq_iff_eq_symm_apply, std_basis_matrix]
simp [ha, hb, hab, ← e.apply_eq_iff_eq_symm_apply, std_basis_matrix]
by_cases hb : e t_j = b
by_cases hab : a = b
simp [ha, hb, hab, ← e.apply_eq_iff_eq_symm_apply, std_basis_matrix]
simp [ha, hb, hab, ← e.apply_eq_iff_eq_symm_apply, std_basis_matrix]
by_cases hab : a = b
simp [ha, hb, hab, ← e.apply_eq_iff_eq_symm_apply, std_basis_matrix]
simp [ha, hb, hab, ← e.apply_eq_iff_eq_symm_apply, std_basis_matrix]
intros
ext m x
simp only [snoc_last, multilinear_map.curry_right_apply, multilinear_map.uncurry_right_apply]
rw init_snoc
intros
rw [←is_scalar_tower.algebra_map_smul R a y, polar_smul_right, algebra.smul_def]
intros
refine le_antisymm (supr_range_std_basis_le_infi_ker_proj _ _ _ _ hd) _
have : set.univ ⊆ ↑hI.to_finset ∪ J
rwa [hI.coe_to_finset]
{ rwa [hI.coe_to_finset] }
refine le_trans (infi_ker_proj_le_supr_range_std_basis R φ this) (supr_le_supr $ assume i, _)
rw [set.finite.mem_to_finset]
exact le_refl _
intros
rw [or_assoc, or_assoc, or_comm b]
intros
{ ext, simp, }
ext
simp
intros
intros g₁ g₂ hg
refine funext (λ x, _)
have H := congr_fun hg (f x)
simp only [hf, extend_apply] at H
exact H
intros
apply measurable_of_is_closed
intros s hs
cases eq_empty_or_nonempty s with h1 h1
simp [h1]
{ simp [h1] }
by_cases h2 : s = univ
simp [h2]
{ simp [h2] }
exact hf s hs h1 h2
intros
simp [measure.prod]
intros
set i := some s.exists_compl_positive_negative
obtain ⟨hi₁, hi₂, hi₃⟩ := some_spec s.exists_compl_positive_negative
exact ⟨i, hi₁, hi₂, hi₃, rfl, rfl⟩
intros
rw [← mk_to_germ, mk_coe_fn]
intros
have h_eq : (λ n, f n x) = λ n, ae_seq hf p n x
from funext (λ n, (ae_seq_eq_fun_of_mem_ae_seq_set hf hx n).symm)
rw h_eq
exact prop_of_mem_ae_seq_set hf hx
intros
simp_rw ess_sup
{ simp_rw ess_sup, exact ennreal.limsup_liminf_le_liminf_limsup (λ a b, f b a), }
exact ennreal.limsup_liminf_le_liminf_limsup (λ a b, f b a)
intros
simpa only [sub_eq_add_neg] using hf.add hg.neg
intros
{ simp [to_L1, snorm, snorm'], simp [edist_eq_coe_nnnorm] }
simp [to_L1, snorm, snorm']
simp [edist_eq_coe_nnnorm]
intros
{ rw neg_part, exact pos_part_map_norm _ }
rw neg_part
exact pos_part_map_norm _
intros
rw [← integral_sub hf.real_to_nnreal]
{ simp }
simp
{ exact hf.neg.real_to_nnreal }
exact hf.neg.real_to_nnreal
intros
simp only [interval_integral, set_integral_const, sub_smul]
intros
cases le_total a b with hab hab; simpa [hab, integral_of_le, integral_of_ge] using set_integral_congr measurable_set_Ioc (h.mono Ioc_subset_Icc_self)
cases le_total a b with hab hab
simpa [hab, integral_of_le, integral_of_ge] using set_integral_congr measurable_set_Ioc (h.mono Ioc_subset_Icc_self)
simpa [hab, integral_of_le, integral_of_ge] using set_integral_congr measurable_set_Ioc (h.mono Ioc_subset_Icc_self)
intros
refine measure.ext (λ s hs, _)
rw [with_density_apply _ hs, measure.coe_smul, pi.smul_apply, with_density_apply _ hs, smul_eq_mul, ← lintegral_const_mul' r f hr]
refl
intros
rw [approx_apply _ hf, approx_apply _ (hf.comp hg)]
intros
by_cases hfi : integrable f μ
have hgi : integrable g μ := hfi.congr h
{ have hgi : integrable g μ := hfi.congr h, rw [set_to_fun_eq hT hfi, set_to_fun_eq hT hgi, (integrable.to_L1_eq_to_L1_iff f g hfi hgi).2 h] }
rw [set_to_fun_eq hT hfi, set_to_fun_eq hT hgi, (integrable.to_L1_eq_to_L1_iff f g hfi hgi).2 h]
have hgi : ¬ integrable g μ
{ have hgi : ¬ integrable g μ, { rw integrable_congr h at hfi, exact hfi }, rw [set_to_fun_undef hT hfi, set_to_fun_undef hT hgi] }
rw integrable_congr h at hfi
{ rw integrable_congr h at hfi, exact hfi }
exact hfi
rw [set_to_fun_undef hT hfi, set_to_fun_undef hT hgi]
intros
{ rw sInter_eq_bInter, exact measurable_set.bInter hs h }
rw sInter_eq_bInter
exact measurable_set.bInter hs h
intros
convert μ.inner_content_pos_of_is_mul_left_invariant h3 K hK ⟨U, h1U⟩ h2U
{ convert μ.inner_content_pos_of_is_mul_left_invariant h3 K hK ⟨U, h1U⟩ h2U, exact μ.outer_measure_opens ⟨U, h1U⟩ }
exact μ.outer_measure_opens ⟨U, h1U⟩
intros
simp [volume_val]
intros
simp [measure.trim, hs]
intros
simp only [mem_ae_iff, compl_compl]
intros
simp_rw [to_measure_of_zero_le, measure.of_measurable_apply _ hj₁, to_measure_of_zero_le', s.restrict_apply hi₁ hj₁, set.inter_comm]
intros
{ ext, simp [mul_comm] }
ext
simp [mul_comm]
intros
simp only [finset_approx, finset.mem_erase, finset.mem_image]
split
rintros ⟨hx, ⟨i, j⟩, _, rfl⟩
{ rintros ⟨hx, ⟨i, j⟩, _, rfl⟩, refine ⟨i, j, _, rfl⟩, rintro rfl, simpa using hx }
refine ⟨i, j, _, rfl⟩
rintro rfl
simpa using hx
rintros ⟨i, j, hij, rfl⟩
{ rintros ⟨i, j, hij, rfl⟩, refine ⟨_, ⟨i, j⟩, finset.mem_product.mpr ⟨finset.mem_univ _, finset.mem_univ _⟩, rfl⟩, rw [ne.def, sub_eq_zero], exact λ h, hij ((distinct_elems bS adm).injective h) }
refine ⟨_, ⟨i, j⟩, finset.mem_product.mpr ⟨finset.mem_univ _, finset.mem_univ _⟩, rfl⟩
rw [ne.def, sub_eq_zero]
exact λ h, hij ((distinct_elems bS adm).injective h)
intros
rintros ⟨f : polynomial ℤ, f0, ef0⟩
replace ef0 : (f.map (algebra_map ℤ ℝ)).eval x = 0
rwa [aeval_def, ← eval_map] at ef0
{ rwa [aeval_def, ← eval_map] at ef0 }
obtain ⟨A, hA, h⟩ : ∃ (A : ℝ), 0 < A ∧ ∀ (a : ℤ) (b : ℕ), (1 : ℝ) ≤ (b.succ) ^ f.nat_degree * (abs (x - a / (b.succ)) * A) := exists_pos_real_of_irrational_root lx.irrational f0 ef0
rcases pow_unbounded_of_one_lt A (lt_add_one 1) with ⟨r, hn⟩
obtain ⟨a, b, b1, -, a1⟩ : ∃ (a b : ℤ), 1 < b ∧ x ≠ a / b ∧ abs (x - a / b) < 1 / b ^ (r + f.nat_degree) := lx (r + f.nat_degree)
have b0 : (0 : ℝ) < b := zero_lt_one.trans (by { rw ← int.cast_one, exact int.cast_lt.mpr b1 })
refine lt_irrefl ((b : ℝ) ^ f.nat_degree * abs (x - ↑a / ↑b)) _
rw [lt_div_iff' (pow_pos b0 _), pow_add, mul_assoc] at a1
refine ((_ : (b : ℝ) ^ f.nat_degree * abs (x - a / b) < 1 / A).trans_le _)
refine (lt_div_iff' hA).mpr _
{ refine (lt_div_iff' hA).mpr _, refine lt_of_le_of_lt _ a1, refine mul_le_mul_of_nonneg_right _ (mul_nonneg (pow_nonneg b0.le _) (abs_nonneg _)), refine hn.le.trans _, refine pow_le_pow_of_le_left zero_le_two _ _, exact int.cast_two.symm.le.trans (int.cast_le.mpr (int.add_one_le_iff.mpr b1)) }
refine lt_of_le_of_lt _ a1
refine mul_le_mul_of_nonneg_right _ (mul_nonneg (pow_nonneg b0.le _) (abs_nonneg _))
refine hn.le.trans _
refine pow_le_pow_of_le_left zero_le_two _ _
exact int.cast_two.symm.le.trans (int.cast_le.mpr (int.add_one_le_iff.mpr b1))
lift b to ℕ using zero_le_one.trans b1.le
{ lift b to ℕ using zero_le_one.trans b1.le, specialize h a b.pred, rwa [nat.succ_pred_eq_of_pos (zero_lt_one.trans _), ← mul_assoc, ← (div_le_iff hA)] at h, exact int.coe_nat_lt.mp b1 }
specialize h a b.pred
rwa [nat.succ_pred_eq_of_pos (zero_lt_one.trans _), ← mul_assoc, ← (div_le_iff hA)] at h
exact int.coe_nat_lt.mp b1
intros
ext
ext; simp [mersenne, q, zmod.nat_coe_zmod_eq_zero_iff_dvd, -pow_pos]
simp [mersenne, q, zmod.nat_coe_zmod_eq_zero_iff_dvd, -pow_pos]
apply nat.min_fac_dvd
simp [mersenne, q, zmod.nat_coe_zmod_eq_zero_iff_dvd, -pow_pos]
intros
unfold padic_val_nat
rw int.to_nat_of_nonneg (zero_le_padic_val_rat_of_nat p n)
intros
cases nat.prime.eq_two_or_odd (fact.out p.prime) with hp2 hp_odd
{ substI p, revert a ha, exact dec_trivial }
substI p
revert a ha
exact dec_trivial
rw [← mul_self_eq_one_iff, ← pow_add, ← two_mul, two_mul_odd_div_two hp_odd]
exact pow_card_sub_one_eq_one ha
intros
simpa using congr_arg re h
intros
rw [inf_comm, inf_sdiff_right]
intros
rw [sup_comm, inf_sdiff_sup_left]
intros
simp only [is_glb, lower_bounds_empty, is_greatest_univ]
intros
rw [inf_comm, infi_inf]; simp [inf_comm]
rw [inf_comm, infi_inf]
simp [inf_comm]
intros
simpa only [(∘), neg_mul_eq_mul_neg, neg_neg] using tendsto_neg_at_top_at_bot.comp ((tendsto_neg_at_bot_at_top.comp hf).const_mul_at_top hr)
intros
simp
intros
rw [sInter_eq_bInter, bInter_mem hfin]
intros
simp only [tendsto_principal, eventually_principal]
intros
simp [filter.Coprod]
intros
rw [infi_subtype', infi_sup_left, infi_subtype']
intros
simp only [Sup_eq_supr, gc.l_supr]
intros
rw [inf_comm, @inf_comm _ _ a, inf_assoc]
intros
rw limsup_eq
congr' with b
exact eventually_congr (h.mono $ λ x hx, by simp [hx])
intros
rw [symm_diff_eq, compl_symm_diff, symm_diff_eq]
rw [inf_sup_left, inf_sup_right, ←sup_assoc, ←inf_assoc, ←inf_assoc]
congr' 1
congr' 1
{ congr' 1, rw [inf_comm, inf_assoc], }
rw [inf_comm, inf_assoc]
apply inf_left_right_swap
{ apply inf_left_right_swap }
intros
refine le_antisymm (le_min (is_wf.min_le_min_of_subset (subset_union_left _ _)) (is_wf.min_le_min_of_subset (subset_union_right _ _))) _
rw min_le_iff
exact ((mem_union _ _ _).1 ((hs.union ht).min_mem (union_nonempty.2 (or.intro_left _ hsn)))).imp (hs.min_le _) (ht.min_le _)
intros
intros t1 t2 ht1 ht2
{ intros t1 t2 ht1 ht2, rw [set.inter_comm, mul_comm], exact h t2 t1 ht2 ht1, }
rw [set.inter_comm, mul_comm]
exact h t2 t1 ht2 ht1
intros
convert inv_eq_of_aeval_div_X_ne_zero (mt (λ h, (algebra_map K L).injective _) coeff_zero_ne)
{ rw [aeval_eq, zero_sub, div_neg] }
rw [aeval_eq, zero_sub, div_neg]
rw ring_hom.map_zero
convert aeval_eq
conv_rhs { rw ← div_X_mul_X_add p }
rw [alg_hom.map_add, alg_hom.map_mul, h, zero_mul, zero_add, aeval_C]
intros
refine ⟨_, λ x y hxy, _⟩
rintro rfl
unfreezingI { rintro rfl }
{ unfreezingI { rintro rfl }, rw ← ideal.one_eq_top at h, exact h.not_unit is_unit_one }
rw ← ideal.one_eq_top at h
exact h.not_unit is_unit_one
simp only [← ideal.dvd_span_singleton, ← ideal.span_singleton_mul_span_singleton] at ⊢ hxy
{ simp only [← ideal.dvd_span_singleton, ← ideal.span_singleton_mul_span_singleton] at ⊢ hxy, exact h.dvd_or_dvd hxy }
exact h.dvd_or_dvd hxy
intros
obtain ⟨n, f, hf⟩ := hfp
use [n, alg_hom.comp ↑e f]
split
{ exact function.surjective.comp e.surjective hf.1 }
exact function.surjective.comp e.surjective hf.1
suffices hker : (alg_hom.comp ↑e f).to_ring_hom.ker = f.to_ring_hom.ker
{ rw hker, exact hf.2 }
rw hker
exact hf.2
have hco : (alg_hom.comp ↑e f).to_ring_hom = ring_hom.comp ↑e.to_ring_equiv f.to_ring_hom
{ have hco : (alg_hom.comp ↑e f).to_ring_hom = ring_hom.comp ↑e.to_ring_equiv f.to_ring_hom, { have h : (alg_hom.comp ↑e f).to_ring_hom = e.to_alg_hom.to_ring_hom.comp f.to_ring_hom := rfl, have h1 : ↑(e.to_ring_equiv) = (e.to_alg_hom).to_ring_hom := rfl, rw [h, h1] }, rw [ring_hom.ker_eq_comap_bot, hco, ← ideal.comap_comap, ← ring_hom.ker_eq_comap_bot, ring_hom.ker_coe_equiv (alg_equiv.to_ring_equiv e), ring_hom.ker_eq_comap_bot] }
have h : (alg_hom.comp ↑e f).to_ring_hom = e.to_alg_hom.to_ring_hom.comp f.to_ring_hom := rfl
{ have h : (alg_hom.comp ↑e f).to_ring_hom = e.to_alg_hom.to_ring_hom.comp f.to_ring_hom := rfl, have h1 : ↑(e.to_ring_equiv) = (e.to_alg_hom).to_ring_hom := rfl, rw [h, h1] }
have h1 : ↑(e.to_ring_equiv) = (e.to_alg_hom).to_ring_hom := rfl
rw [h, h1]
rw [ring_hom.ker_eq_comap_bot, hco, ← ideal.comap_comap, ← ring_hom.ker_eq_comap_bot, ring_hom.ker_coe_equiv (alg_equiv.to_ring_equiv e), ring_hom.ker_eq_comap_bot]
intros
ext g
simp only [hsum_coeff, coe_of_finsupp, finsupp.sum, ne.def]
simp_rw [← coeff.add_monoid_hom_apply, id.def]
rw [add_monoid_hom.map_sum, finsum_eq_sum_of_support_subset]
intros x h
simp only [coeff.add_monoid_hom_apply, mem_coe, finsupp.mem_support_iff, ne.def]
contrapose! h
simp [h]
intros
induction n with n ih
rw pow_zero at H
{ rw pow_zero at H, exact (mt (eq_top_iff_one _).2 hI.1).elim H }
exact (mt (eq_top_iff_one _).2 hI.1).elim H
rw pow_succ at H
{ rw pow_succ at H, exact or.cases_on (hI.mem_or_mem H) id ih }
exact or.cases_on (hI.mem_or_mem H) id ih
intros
{ rw [mem_ker, f.map_one], exact one_ne_zero }
rw [mem_ker, f.map_one]
exact one_ne_zero
intros
rw [ring_hom.ker_eq_comap_bot, quot_quot_mk, ← comap_comap, ← ring_hom.ker, mk_ker, comap_map_of_surjective (ideal.quotient.mk I) (quotient.mk_surjective), ← ring_hom.ker, mk_ker, sup_comm]
intros
by_cases 0 ≤ z
{ simp [nat_abs_of_nonneg h, normalize_of_nonneg h] }
simp [nat_abs_of_nonneg h, normalize_of_nonneg h]
simp [of_nat_nat_abs_of_nonpos (le_of_not_ge h), normalize_of_neg (lt_of_not_ge h)]
{ simp [of_nat_nat_abs_of_nonpos (le_of_not_ge h), normalize_of_neg (lt_of_not_ge h)] }
intros
split
split; unfreezingI { rintros ⟨⟨x, hx⟩⟩ }
unfreezingI { rintros ⟨⟨x, hx⟩⟩ }
have x_mem : x ∈ coe_submodule S I := hx.symm ▸ submodule.mem_span_singleton_self x
{ have x_mem : x ∈ coe_submodule S I := hx.symm ▸ submodule.mem_span_singleton_self x, obtain ⟨x, x_mem, rfl⟩ := (mem_coe_submodule _ _).mp x_mem, refine ⟨⟨x, coe_submodule_injective S h _⟩⟩, rw [ideal.submodule_span_eq, hx, coe_submodule_span_singleton] }
obtain ⟨x, x_mem, rfl⟩ := (mem_coe_submodule _ _).mp x_mem
refine ⟨⟨x, coe_submodule_injective S h _⟩⟩
rw [ideal.submodule_span_eq, hx, coe_submodule_span_singleton]
unfreezingI { rintros ⟨⟨x, hx⟩⟩ }
rintros ⟨⟨x, hx⟩⟩
refine ⟨⟨algebra_map R S x, _⟩⟩
{ refine ⟨⟨algebra_map R S x, _⟩⟩, rw [hx, ideal.submodule_span_eq, coe_submodule_span_singleton] }
rw [hx, ideal.submodule_span_eq, coe_submodule_span_singleton]
intros
rw [←mk'_mul, mul_comm]; exact mk'_self _ _
rw [←mk'_mul, mul_comm]
exact mk'_self _ _
intros
rw [norm_apply, ← linear_map.det_to_matrix b, to_matrix_lmul_eq]
intros
dsimp [bernstein_polynomial]
split_ifs
{ subst h, simp, }
subst h
simp
obtain w | w := (n - ν).eq_zero_or_pos
{ obtain w | w := (n - ν).eq_zero_or_pos, { simp [nat.choose_eq_zero_of_lt ((nat.le_of_sub_eq_zero w).lt_of_ne (ne.symm h))] }, { simp [zero_pow w] } }
simp [nat.choose_eq_zero_of_lt ((nat.le_of_sub_eq_zero w).lt_of_ne (ne.symm h))]
{ simp [nat.choose_eq_zero_of_lt ((nat.le_of_sub_eq_zero w).lt_of_ne (ne.symm h))] }
{ simp [zero_pow w] }
simp [zero_pow w]
intros
rw [gcd_comm (content _) _, gcd_comm (content _) _]
apply gcd_content_eq_of_dvd_sub
rw [← self_sub_C_mul_X_pow, ← self_sub_C_mul_X_pow, sub_mul, sub_sub, add_comm, sub_add, sub_sub_cancel, leading_coeff_mul, ring_hom.map_mul, mul_assoc, mul_assoc]
apply dvd_sub (dvd.intro _ rfl) (dvd.intro _ rfl)
intros
rw ←map_cyclotomic_int
apply monic_map
exact (int_cyclotomic_spec n).2.2
intros
induction n with n ih
{ simp, }
simp
{ simp [ih, pochhammer_succ_left, map_comp], }
simp [ih, pochhammer_succ_left, map_comp]
intros
rw [polynomial.aeval_def, polynomial.aeval_def, polynomial.hom_eval₂, ←is_scalar_tower.algebra_map_eq]
intros
rw [← coeff_zero_eq_constant_coeff_apply, coeff_inv_of_unit, if_pos rfl]
intros
rw [← pow_one (X s : mv_power_series σ R), X_pow_dvd_iff]
split
split; intros h m hm
intros h m hm
{ exact h m (hm.symm ▸ zero_lt_one) }
exact h m (hm.symm ▸ zero_lt_one)
intros h m hm
exact h m (nat.eq_zero_of_le_zero $ nat.le_of_succ_le_succ hm)
{ exact h m (nat.eq_zero_of_le_zero $ nat.le_of_succ_le_succ hm) }
intros
{ rw [coeff, finsupp.single_zero], refl }
rw [coeff, finsupp.single_zero]
refl
intros
by_cases h : f = 0
right
{ right, exact h }
exact h
exact or.intro_left _ ⟨injective_of_ne_zero h, surjective_of_ne_zero h⟩
intros
ext
refine ⟨λ hx, _, λ hx, (subsemiring.mem_closure.mp hx) M.subsemiring_closure (λ s sM, _)⟩
refine ⟨λ hx, _, λ hx, (subsemiring.mem_closure.mp hx) M.subsemiring_closure (λ s sM, _)⟩; rintros - ⟨H1, rfl⟩; rintros - ⟨H2, rfl⟩
refine ⟨λ hx, _, λ hx, (subsemiring.mem_closure.mp hx) M.subsemiring_closure (λ s sM, _)⟩; rintros - ⟨H1, rfl⟩
rintros - ⟨H1, rfl⟩
rintros - ⟨H2, rfl⟩
exact add_submonoid.mem_closure.mp hx H1.to_add_submonoid H2
{ exact add_submonoid.mem_closure.mp hx H1.to_add_submonoid H2 }
rintros - ⟨H1, rfl⟩
rintros - ⟨H2, rfl⟩
{ exact H2 sM }
exact H2 sM
intros
refl
intros
simp only [witt_vector.truncate_fun, coeff_out, mk_coeff]
intros
rw [le_mk_iff_exists_set, ←subtype.exists_set_subtype]
apply exists_congr
intro t
rw [mk_image_eq]
apply subtype.val_injective
intros
cases h with _ _ _ h₁ h₂; [refl, exact equiv.antisymm h₂ h₁]
cases h with _ _ _ h₁ h₂
refl
exact equiv.antisymm h₂ h₁
intros
simpa [e0, NF_below_zero] using h.snd'
intros
simp only [pow_half_move_right, eq_self_iff_true]
intros
simp [h.symm, term, add_assoc]
intros
by_cases h : c; simp [h]
by_cases h : c
simp [h]
simp [h]
intros
rwa sub_neg_eq_add
intros
rw [← h₂, ← h₁]; simp [horner, mul_add, mul_comm, mul_left_comm, mul_assoc]
rw [← h₂, ← h₁]
simp [horner, mul_add, mul_comm, mul_left_comm, mul_assoc]
intros
simp
intros
simp [nhds_infty_eq, comap_sup, comap_map coe_injective]
intros
{ rw ← sum_attach, exact has_sum_fintype _ }
rw ← sum_attach
exact has_sum_fintype _
intros
{ ext x, exact apply_symm_apply e x }
ext x
exact apply_symm_apply e x
intros
rcases eq_empty_or_nonempty (Iio x) with h|h
simp [h]
{ simp [h] }
refine tendsto_order.2 ⟨λ l hl, _, λ m hm, _⟩
obtain ⟨z, zx, lz⟩ : ∃ (a : α), a < x ∧ l < f a
{ obtain ⟨z, zx, lz⟩ : ∃ (a : α), a < x ∧ l < f a, by simpa only [mem_image, exists_prop, exists_exists_and_eq_and] using exists_lt_of_lt_cSup (nonempty_image_iff.2 h) hl, exact (mem_nhds_within_Iio_iff_exists_Ioo_subset' zx).2 ⟨z, zx, λ y hy, lz.trans_le (Mf (hy.1.le))⟩ }
simpa only [mem_image, exists_prop, exists_exists_and_eq_and] using exists_lt_of_lt_cSup (nonempty_image_iff.2 h) hl
simpa only [mem_image, exists_prop, exists_exists_and_eq_and] using exists_lt_of_lt_cSup (nonempty_image_iff.2 h) hl
exact (mem_nhds_within_Iio_iff_exists_Ioo_subset' zx).2 ⟨z, zx, λ y hy, lz.trans_le (Mf (hy.1.le))⟩
filter_upwards [self_mem_nhds_within]
{ filter_upwards [self_mem_nhds_within], assume y hy, apply lt_of_le_of_lt _ hm, exact le_cSup (Mf.map_bdd_above bdd_above_Iio) (mem_image_of_mem _ hy) }
assume y hy
apply lt_of_le_of_lt _ hm
exact le_cSup (Mf.map_bdd_above bdd_above_Iio) (mem_image_of_mem _ hy)
intros
simpa only [inv_inv] using @tendsto_inv_nhds_within_Iic _ _ _ _ (a⁻¹)
intros
refine continuous_if (λ a ha, hfg _ (frontier_le_subset_eq hf hg ha)) _ (hg'.mono _)
{ rwa [(is_closed_le hf hg).closure_eq] }
rwa [(is_closed_le hf hg).closure_eq]
{ simp only [not_le], exact closure_lt_subset_le hg hf }
simp only [not_le]
exact closure_lt_subset_le hg hf
intros
simp only [continuous_at, tendsto_congr' h, h.eq_of_nhds]
intros
rw [diff_subset_iff, union_eq_self_of_subset_left subset_closure]
intros
let E := equiv.of_bijective _ bij
have hE : continuous E.symm
rw continuous_iff_is_closed
{ rw continuous_iff_is_closed, intros S hS, rw ← E.image_eq_preimage, exact is_closed_map f S hS }
intros S hS
rw ← E.image_eq_preimage
exact is_closed_map f S hS
refine ⟨⟨⟨E.symm, hE⟩, _, _⟩⟩
ext x
{ ext x, apply E.symm_apply_apply }
apply E.symm_apply_apply
ext x
{ ext x, apply E.apply_symm_apply }
apply E.apply_symm_apply
intros
simp
intros
{ ext, simp, }
ext
simp
intros
rw ← nhds_within_univ
{ rw ← nhds_within_univ, apply nhds_within_le_of_mem, exact univ_mem }
apply nhds_within_le_of_mem
exact univ_mem
intros
simp only [continuous_on, continuous_within_at, tendsto_nhds, mem_nhds_within]
intros
simp only [continuous_on_iff_continuous_restrict, restrict_eq]
conv_rhs { rw [function.comp.assoc, ← (inducing.continuous_iff hg)] }
intros
rcases c
{ rcases c, refl }
refl
intros
rw [coord_change, e₁.mk_coord_change _ h₁ h₂, ← e₂.coe_coe, e₂.to_local_homeomorph.left_inv, coord_change]
rwa [e₂.mem_source, e₁.proj_symm_apply' h₁]
intros
rw [← preimage_symm, preimage_closure]
intros
rw ← tendsto_coe
convert tendsto_sum_nat_add (λ i, (f i : ℝ))
norm_cast
intros
simp only [local_homeomorph_subtype_coe, subtype.range_coe_subtype] with mfld_simps
{ simp only [local_homeomorph_subtype_coe, subtype.range_coe_subtype] with mfld_simps, refl }
refl
intros
intros x y
have := hf (g x) (g y)
rwa [hg x, hg y] at this
intros
rw [cauchy_seq_iff_tendsto, metric.uniformity_eq_comap_nhds_zero, tendsto_comap_iff, prod.map_def]
intros
simp only [← nnreal.eq_iff, ← dist_nndist, imp_self, nnreal.coe_zero, zero_eq_dist]
intros
simpa only [hy.eq, dist_self, add_zero] using hf.dist_inequality x y
intros
rw [dimH_ball_pi x hr, fintype.card_fin]
intros
simp [inf_edist_zero_of_mem h, inf_dist]
intros
convert γ.truncate_self 1; exact γ.extend_one.symm
convert γ.truncate_self 1
exact γ.extend_one.symm
exact γ.extend_one.symm
exact γ.extend_one.symm
exact γ.extend_one.symm
exact γ.extend_one.symm
exact γ.extend_one.symm
exact γ.extend_one.symm
exact γ.extend_one.symm
exact γ.extend_one.symm
intros
simp [pushforward_eq]
intros
rw uniform_continuous_on_iff_restrict at h
rw continuous_on_iff_continuous_restrict
exact h.continuous
intros
rw [cauchy, map_ne_bot_iff, prod_map_map_eq, tendsto]
intros
simp [h]
intros
cases v
reflexivity
intros
rw ← bind_pure_comp_eq_map _ x.run
change x.run >>= except_t.bind_cont (pure ∘ f) = _
apply bind_ext_congr
intro a; cases a; simp [except_t.bind_cont, except.map]
intro a; cases a
intro a
cases a
simp [except_t.bind_cont, except.map]
simp [except_t.bind_cont, except.map]
intros
cases b
cases b; exact dec_trivial
exact dec_trivial
exact dec_trivial
intros
have h := int.add_le_add_right h (-b)
rwa int.add_neg_cancel_right at h
intros
induction t; simp [*]
induction t
simp [*]
simp [*]
intros
rw [nat.mul_comm, nat.mul_div_cancel _ H]
intros
rw nat.add_comm; exact nat.lt_add_of_pos_right h
rw nat.add_comm
exact nat.lt_add_of_pos_right h
intros
induction x using nat.case_strong_induction_on with x ih
{ rw zero_mod, assumption }
rw zero_mod
assumption
by_cases h₁ : succ x < y
{ by_cases h₁ : succ x < y, { rwa [mod_eq_of_lt h₁] }, { have h₁ : succ x % y = (succ x - y) % y := mod_eq_sub_mod (not_lt.1 h₁), have : succ x - y ≤ x := le_of_lt_succ (nat.sub_lt (succ_pos x) h), have h₂ : (succ x - y) % y < y := ih _ this, rwa [← h₁] at h₂ } }
{ rwa [mod_eq_of_lt h₁] }
rwa [mod_eq_of_lt h₁]
have h₁ : succ x % y = (succ x - y) % y := mod_eq_sub_mod (not_lt.1 h₁)
{ have h₁ : succ x % y = (succ x - y) % y := mod_eq_sub_mod (not_lt.1 h₁), have : succ x - y ≤ x := le_of_lt_succ (nat.sub_lt (succ_pos x) h), have h₂ : (succ x - y) % y < y := ih _ this, rwa [← h₁] at h₂ }
have : succ x - y ≤ x := le_of_lt_succ (nat.sub_lt (succ_pos x) h)
have h₂ : (succ x - y) % y < y := ih _ this
rwa [← h₁] at h₂
intros
tactic.mk_inj_eq
intros
rw [←vadd_vsub g1, h, vadd_vsub]
intros
split
intro h
{ intro h, rw [← not_lt], intro hmn, apply h1, have : x ^ m * x ∣ x ^ m * 1, { rw [← pow_succ', mul_one], exact (pow_dvd_pow _ (nat.succ_le_of_lt hmn)).trans h }, rwa [mul_dvd_mul_iff_left, ← is_unit_iff_dvd_one] at this, apply pow_ne_zero m h0 }
rw [← not_lt]
intro hmn
apply h1
have : x ^ m * x ∣ x ^ m * 1
rw [← pow_succ', mul_one]
{ rw [← pow_succ', mul_one], exact (pow_dvd_pow _ (nat.succ_le_of_lt hmn)).trans h }
exact (pow_dvd_pow _ (nat.succ_le_of_lt hmn)).trans h
rwa [mul_dvd_mul_iff_left, ← is_unit_iff_dvd_one] at this
apply pow_ne_zero m h0
{ apply pow_dvd_pow }
apply pow_dvd_pow
intros
rw prod_ite
{ rw prod_ite, simp [filter_false_of_mem h, filter_true_of_mem h] }
simp [filter_false_of_mem h, filter_true_of_mem h]
intros
rw [← mul_support_mul_indicator] at hf hg
simp only [finprod_mem_def, mul_indicator_mul, finprod_mul_distrib hf hg]
intros
simp_rw [← finprod_eq_dif]
rw [finprod_dmem, finprod_mem_range hf, finprod_congr (λ a, _)]
rw [dif_pos (set.mem_range_self a), hf (classical.some_spec (set.mem_range_self a))]
intros
rw [eq_sub_iff_add_eq, ← add_pow_char_of_commute _ _ _ (commute.sub_left h rfl)]
simp
apply_instance
repeat {apply_instance}
apply_instance
intros
induction n with n IH generalizing g
simp
case nat.zero { simp }
case nat.succ { let g' := squash_gcf g n, suffices : g.convergents (n + 1) = g'.convergents' n, by rwa [succ_nth_convergent'_eq_squash_gcf_nth_convergent'], cases decidable.em (terminated_at g n) with terminated_at_n not_terminated_at_n, { have g'_eq_g : g' = g, from squash_gcf_eq_self_of_terminated terminated_at_n, rw [(convergents_stable_of_terminated n.le_succ terminated_at_n), g'_eq_g, (IH _)], assume _ _ m_lt_n s_mth_eq, exact (s_pos (nat.lt.step m_lt_n) s_mth_eq) }, { suffices : g.convergents (n + 1) = g'.convergents n, by { rwa ← IH, assume gp' m m_lt_n s_mth_eq', cases m_lt_n with n succ_m_lt_n, { obtain ⟨gp_succ_m, s_succ_mth_eq⟩ : ∃ gp_succ_m, g.s.nth (m + 1) = some gp_succ_m, from option.ne_none_iff_exists'.mp not_terminated_at_n, obtain ⟨gp_m, mth_s_eq⟩ : ∃ gp_m, g.s.nth m = some gp_m, from g.s.ge_stable m.le_succ s_succ_mth_eq, suffices : 0 < gp_m.a ∧ 0 < gp_m.b + gp_succ_m.a / gp_succ_m.b, by { have ot : g'.s.nth m = some ⟨gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b⟩, from squash_seq_nth_of_not_terminated mth_s_eq s_succ_mth_eq, have : gp' = ⟨gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b⟩, by cc, rwa this }, refine ⟨(s_pos (nat.lt.step m_lt_n) mth_s_eq).left, _⟩, refine add_pos (s_pos (nat.lt.step m_lt_n) mth_s_eq).right _, have : 0 < gp_succ_m.a ∧ 0 < gp_succ_m.b := s_pos (lt_add_one $ m + 1) s_succ_mth_eq, exact (div_pos this.left this.right) }, { refine s_pos (nat.lt.step $ nat.lt.step succ_m_lt_n) _, exact eq.trans (squash_gcf_nth_of_lt succ_m_lt_n).symm s_mth_eq' } }, have : ∀ ⦃b⦄, g.partial_denominators.nth n = some b → b ≠ 0, by { assume b nth_part_denom_eq, obtain ⟨gp, s_nth_eq, ⟨refl⟩⟩ : ∃ gp, g.s.nth n = some gp ∧ gp.b = b, from exists_s_b_of_part_denom nth_part_denom_eq, exact (ne_of_lt (s_pos (lt_add_one n) s_nth_eq).right).symm }, exact succ_nth_convergent_eq_squash_gcf_nth_convergent this } }
let g' := squash_gcf g n
suffices : g.convergents (n + 1) = g'.convergents' n
rwa [succ_nth_convergent'_eq_squash_gcf_nth_convergent']
rwa [succ_nth_convergent'_eq_squash_gcf_nth_convergent']
cases decidable.em (terminated_at g n) with terminated_at_n not_terminated_at_n
have g'_eq_g : g' = g
{ have g'_eq_g : g' = g, from squash_gcf_eq_self_of_terminated terminated_at_n, rw [(convergents_stable_of_terminated n.le_succ terminated_at_n), g'_eq_g, (IH _)], assume _ _ m_lt_n s_mth_eq, exact (s_pos (nat.lt.step m_lt_n) s_mth_eq) }
from squash_gcf_eq_self_of_terminated terminated_at_n
rw [(convergents_stable_of_terminated n.le_succ terminated_at_n), g'_eq_g, (IH _)]
assume _ _ m_lt_n s_mth_eq
exact (s_pos (nat.lt.step m_lt_n) s_mth_eq)
suffices : g.convergents (n + 1) = g'.convergents n
{ suffices : g.convergents (n + 1) = g'.convergents n, by { rwa ← IH, assume gp' m m_lt_n s_mth_eq', cases m_lt_n with n succ_m_lt_n, { obtain ⟨gp_succ_m, s_succ_mth_eq⟩ : ∃ gp_succ_m, g.s.nth (m + 1) = some gp_succ_m, from option.ne_none_iff_exists'.mp not_terminated_at_n, obtain ⟨gp_m, mth_s_eq⟩ : ∃ gp_m, g.s.nth m = some gp_m, from g.s.ge_stable m.le_succ s_succ_mth_eq, suffices : 0 < gp_m.a ∧ 0 < gp_m.b + gp_succ_m.a / gp_succ_m.b, by { have ot : g'.s.nth m = some ⟨gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b⟩, from squash_seq_nth_of_not_terminated mth_s_eq s_succ_mth_eq, have : gp' = ⟨gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b⟩, by cc, rwa this }, refine ⟨(s_pos (nat.lt.step m_lt_n) mth_s_eq).left, _⟩, refine add_pos (s_pos (nat.lt.step m_lt_n) mth_s_eq).right _, have : 0 < gp_succ_m.a ∧ 0 < gp_succ_m.b := s_pos (lt_add_one $ m + 1) s_succ_mth_eq, exact (div_pos this.left this.right) }, { refine s_pos (nat.lt.step $ nat.lt.step succ_m_lt_n) _, exact eq.trans (squash_gcf_nth_of_lt succ_m_lt_n).symm s_mth_eq' } }, have : ∀ ⦃b⦄, g.partial_denominators.nth n = some b → b ≠ 0, by { assume b nth_part_denom_eq, obtain ⟨gp, s_nth_eq, ⟨refl⟩⟩ : ∃ gp, g.s.nth n = some gp ∧ gp.b = b, from exists_s_b_of_part_denom nth_part_denom_eq, exact (ne_of_lt (s_pos (lt_add_one n) s_nth_eq).right).symm }, exact succ_nth_convergent_eq_squash_gcf_nth_convergent this }
rwa ← IH
rwa ← IH
{ rwa ← IH, assume gp' m m_lt_n s_mth_eq', cases m_lt_n with n succ_m_lt_n, { obtain ⟨gp_succ_m, s_succ_mth_eq⟩ : ∃ gp_succ_m, g.s.nth (m + 1) = some gp_succ_m, from option.ne_none_iff_exists'.mp not_terminated_at_n, obtain ⟨gp_m, mth_s_eq⟩ : ∃ gp_m, g.s.nth m = some gp_m, from g.s.ge_stable m.le_succ s_succ_mth_eq, suffices : 0 < gp_m.a ∧ 0 < gp_m.b + gp_succ_m.a / gp_succ_m.b, by { have ot : g'.s.nth m = some ⟨gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b⟩, from squash_seq_nth_of_not_terminated mth_s_eq s_succ_mth_eq, have : gp' = ⟨gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b⟩, by cc, rwa this }, refine ⟨(s_pos (nat.lt.step m_lt_n) mth_s_eq).left, _⟩, refine add_pos (s_pos (nat.lt.step m_lt_n) mth_s_eq).right _, have : 0 < gp_succ_m.a ∧ 0 < gp_succ_m.b := s_pos (lt_add_one $ m + 1) s_succ_mth_eq, exact (div_pos this.left this.right) }, { refine s_pos (nat.lt.step $ nat.lt.step succ_m_lt_n) _, exact eq.trans (squash_gcf_nth_of_lt succ_m_lt_n).symm s_mth_eq' } }
{ rwa ← IH, assume gp' m m_lt_n s_mth_eq', cases m_lt_n with n succ_m_lt_n, { obtain ⟨gp_succ_m, s_succ_mth_eq⟩ : ∃ gp_succ_m, g.s.nth (m + 1) = some gp_succ_m, from option.ne_none_iff_exists'.mp not_terminated_at_n, obtain ⟨gp_m, mth_s_eq⟩ : ∃ gp_m, g.s.nth m = some gp_m, from g.s.ge_stable m.le_succ s_succ_mth_eq, suffices : 0 < gp_m.a ∧ 0 < gp_m.b + gp_succ_m.a / gp_succ_m.b, by { have ot : g'.s.nth m = some ⟨gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b⟩, from squash_seq_nth_of_not_terminated mth_s_eq s_succ_mth_eq, have : gp' = ⟨gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b⟩, by cc, rwa this }, refine ⟨(s_pos (nat.lt.step m_lt_n) mth_s_eq).left, _⟩, refine add_pos (s_pos (nat.lt.step m_lt_n) mth_s_eq).right _, have : 0 < gp_succ_m.a ∧ 0 < gp_succ_m.b := s_pos (lt_add_one $ m + 1) s_succ_mth_eq, exact (div_pos this.left this.right) }, { refine s_pos (nat.lt.step $ nat.lt.step succ_m_lt_n) _, exact eq.trans (squash_gcf_nth_of_lt succ_m_lt_n).symm s_mth_eq' } }
assume gp' m m_lt_n s_mth_eq'
assume gp' m m_lt_n s_mth_eq'
cases m_lt_n with n succ_m_lt_n
cases m_lt_n with n succ_m_lt_n
obtain ⟨gp_succ_m, s_succ_mth_eq⟩ : ∃ gp_succ_m, g.s.nth (m + 1) = some gp_succ_m
obtain ⟨gp_succ_m, s_succ_mth_eq⟩ : ∃ gp_succ_m, g.s.nth (m + 1) = some gp_succ_m
{ obtain ⟨gp_succ_m, s_succ_mth_eq⟩ : ∃ gp_succ_m, g.s.nth (m + 1) = some gp_succ_m, from option.ne_none_iff_exists'.mp not_terminated_at_n, obtain ⟨gp_m, mth_s_eq⟩ : ∃ gp_m, g.s.nth m = some gp_m, from g.s.ge_stable m.le_succ s_succ_mth_eq, suffices : 0 < gp_m.a ∧ 0 < gp_m.b + gp_succ_m.a / gp_succ_m.b, by { have ot : g'.s.nth m = some ⟨gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b⟩, from squash_seq_nth_of_not_terminated mth_s_eq s_succ_mth_eq, have : gp' = ⟨gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b⟩, by cc, rwa this }, refine ⟨(s_pos (nat.lt.step m_lt_n) mth_s_eq).left, _⟩, refine add_pos (s_pos (nat.lt.step m_lt_n) mth_s_eq).right _, have : 0 < gp_succ_m.a ∧ 0 < gp_succ_m.b := s_pos (lt_add_one $ m + 1) s_succ_mth_eq, exact (div_pos this.left this.right) }
{ obtain ⟨gp_succ_m, s_succ_mth_eq⟩ : ∃ gp_succ_m, g.s.nth (m + 1) = some gp_succ_m, from option.ne_none_iff_exists'.mp not_terminated_at_n, obtain ⟨gp_m, mth_s_eq⟩ : ∃ gp_m, g.s.nth m = some gp_m, from g.s.ge_stable m.le_succ s_succ_mth_eq, suffices : 0 < gp_m.a ∧ 0 < gp_m.b + gp_succ_m.a / gp_succ_m.b, by { have ot : g'.s.nth m = some ⟨gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b⟩, from squash_seq_nth_of_not_terminated mth_s_eq s_succ_mth_eq, have : gp' = ⟨gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b⟩, by cc, rwa this }, refine ⟨(s_pos (nat.lt.step m_lt_n) mth_s_eq).left, _⟩, refine add_pos (s_pos (nat.lt.step m_lt_n) mth_s_eq).right _, have : 0 < gp_succ_m.a ∧ 0 < gp_succ_m.b := s_pos (lt_add_one $ m + 1) s_succ_mth_eq, exact (div_pos this.left this.right) }
from option.ne_none_iff_exists'.mp not_terminated_at_n
from option.ne_none_iff_exists'.mp not_terminated_at_n
obtain ⟨gp_m, mth_s_eq⟩ : ∃ gp_m, g.s.nth m = some gp_m
obtain ⟨gp_m, mth_s_eq⟩ : ∃ gp_m, g.s.nth m = some gp_m
from g.s.ge_stable m.le_succ s_succ_mth_eq
from g.s.ge_stable m.le_succ s_succ_mth_eq
suffices : 0 < gp_m.a ∧ 0 < gp_m.b + gp_succ_m.a / gp_succ_m.b
suffices : 0 < gp_m.a ∧ 0 < gp_m.b + gp_succ_m.a / gp_succ_m.b
have ot : g'.s.nth m = some ⟨gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b⟩
have ot : g'.s.nth m = some ⟨gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b⟩
have ot : g'.s.nth m = some ⟨gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b⟩
{ have ot : g'.s.nth m = some ⟨gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b⟩, from squash_seq_nth_of_not_terminated mth_s_eq s_succ_mth_eq, have : gp' = ⟨gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b⟩, by cc, rwa this }
{ have ot : g'.s.nth m = some ⟨gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b⟩, from squash_seq_nth_of_not_terminated mth_s_eq s_succ_mth_eq, have : gp' = ⟨gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b⟩, by cc, rwa this }
{ have ot : g'.s.nth m = some ⟨gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b⟩, from squash_seq_nth_of_not_terminated mth_s_eq s_succ_mth_eq, have : gp' = ⟨gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b⟩, by cc, rwa this }
from squash_seq_nth_of_not_terminated mth_s_eq s_succ_mth_eq
from squash_seq_nth_of_not_terminated mth_s_eq s_succ_mth_eq
from squash_seq_nth_of_not_terminated mth_s_eq s_succ_mth_eq
have : gp' = ⟨gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b⟩
have : gp' = ⟨gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b⟩
have : gp' = ⟨gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b⟩
cc
cc
cc
cc
rwa this
rwa this
rwa this
refine ⟨(s_pos (nat.lt.step m_lt_n) mth_s_eq).left, _⟩
refine ⟨(s_pos (nat.lt.step m_lt_n) mth_s_eq).left, _⟩
refine add_pos (s_pos (nat.lt.step m_lt_n) mth_s_eq).right _
refine add_pos (s_pos (nat.lt.step m_lt_n) mth_s_eq).right _
have : 0 < gp_succ_m.a ∧ 0 < gp_succ_m.b := s_pos (lt_add_one $ m + 1) s_succ_mth_eq
have : 0 < gp_succ_m.a ∧ 0 < gp_succ_m.b := s_pos (lt_add_one $ m + 1) s_succ_mth_eq
exact (div_pos this.left this.right)
exact (div_pos this.left this.right)
refine s_pos (nat.lt.step $ nat.lt.step succ_m_lt_n) _
refine s_pos (nat.lt.step $ nat.lt.step succ_m_lt_n) _
{ refine s_pos (nat.lt.step $ nat.lt.step succ_m_lt_n) _, exact eq.trans (squash_gcf_nth_of_lt succ_m_lt_n).symm s_mth_eq' }
{ refine s_pos (nat.lt.step $ nat.lt.step succ_m_lt_n) _, exact eq.trans (squash_gcf_nth_of_lt succ_m_lt_n).symm s_mth_eq' }
exact eq.trans (squash_gcf_nth_of_lt succ_m_lt_n).symm s_mth_eq'
exact eq.trans (squash_gcf_nth_of_lt succ_m_lt_n).symm s_mth_eq'
have : ∀ ⦃b⦄, g.partial_denominators.nth n = some b → b ≠ 0
assume b nth_part_denom_eq
assume b nth_part_denom_eq
{ assume b nth_part_denom_eq, obtain ⟨gp, s_nth_eq, ⟨refl⟩⟩ : ∃ gp, g.s.nth n = some gp ∧ gp.b = b, from exists_s_b_of_part_denom nth_part_denom_eq, exact (ne_of_lt (s_pos (lt_add_one n) s_nth_eq).right).symm }
{ assume b nth_part_denom_eq, obtain ⟨gp, s_nth_eq, ⟨refl⟩⟩ : ∃ gp, g.s.nth n = some gp ∧ gp.b = b, from exists_s_b_of_part_denom nth_part_denom_eq, exact (ne_of_lt (s_pos (lt_add_one n) s_nth_eq).right).symm }
obtain ⟨gp, s_nth_eq, ⟨refl⟩⟩ : ∃ gp, g.s.nth n = some gp ∧ gp.b = b
obtain ⟨gp, s_nth_eq, ⟨refl⟩⟩ : ∃ gp, g.s.nth n = some gp ∧ gp.b = b
from exists_s_b_of_part_denom nth_part_denom_eq
from exists_s_b_of_part_denom nth_part_denom_eq
exact (ne_of_lt (s_pos (lt_add_one n) s_nth_eq).right).symm
exact (ne_of_lt (s_pos (lt_add_one n) s_nth_eq).right).symm
exact succ_nth_convergent_eq_squash_gcf_nth_convergent this
intros
rw is_symm_op.flip_eq
intros
letI : Π m : M, decidable (m ≠ 0) := classical.dec_pred _
exact (dfinsupp.to_finsupp_single i m)
intros
simp only [mul_comm, gcd_mul_left]
intros
rw [← @inv_inj _ _ a 1, one_inv]
intros
rw add_comm; apply sub_add_sub_cancel
rw add_comm
apply sub_add_sub_cancel
intros
rw [← mul_assoc, inv_mul, one_mul]
intros
ext
ext; refl
refl
intros
split_ifs; refl
split_ifs
refl
refl
intros
rcases neg_one_pow_eq_or R n; simp [h]
rcases neg_one_pow_eq_or R n
simp [h]
simp [h]
intros
simp only [le_antisymm_iff, pow_le_one_iff hn, one_le_pow_iff hn]
intros
by_cases h : a = 0
{ rw [h, inv_zero, mul_zero] }
rw [h, inv_zero, mul_zero]
{ rw [mul_inv_cancel h, one_mul] }
rw [mul_inv_cancel h, one_mul]
intros
simpa only [one_div] using inv_ne_zero h
intros
rw div_div_eq_mul_div
exact mul_self_div_self a
intros
simp [C.d_from_eq r]
intros
{ ext, simp, }
ext
simp
intros
refine (mul_indicator_congr $ λ x hx, _).trans mul_indicator_mul_support
have : g x = 1
from nmem_mul_support.1 (disjoint_left.1 h hx)
rw [pi.mul_apply, this, mul_one]
intros
induction n with d hd
{ simpa }
simpa
{ simp [← pow_succ, hd] }
simp [← pow_succ, hd]
intros
split
rintros ⟨h⟩
{ rintros ⟨h⟩, ext, simp only [mem_max_triv_submodule, h, forall_const, true_iff, eq_self_iff_true], }
ext
simp only [mem_max_triv_submodule, h, forall_const, true_iff, eq_self_iff_true]
intros h
{ intros h, constructor, intros x m, revert x, rw [← mem_max_triv_submodule R L M, h], exact lie_submodule.mem_top m, }
constructor
intros x m
revert x
rw [← mem_max_triv_submodule R L M, h]
exact lie_submodule.mem_top m
intros
rw lie_algebra.ad_eq_lmul_left_sub_lmul_right
have hl : is_nilpotent (algebra.lmul_left R a)
rwa algebra.is_nilpotent_lmul_left_iff
{ rwa algebra.is_nilpotent_lmul_left_iff, }
have hr : is_nilpotent (algebra.lmul_right R a)
rwa algebra.is_nilpotent_lmul_right_iff
{ rwa algebra.is_nilpotent_lmul_right_iff, }
exact (algebra.commute_lmul_left_right R a a).is_nilpotent_sub hl hr
intros
simp [skew_adjoint_lie_subalgebra_equiv]
intros
{ apply lie_submodule.subset_lie_span, use x, exact ⟨hx, rfl⟩, }
apply lie_submodule.subset_lie_span
use x
exact ⟨hx, rfl⟩
intros
{ cases p, refl, }
cases p
refl
intros
simp only [f.map_nsmul]
intros
rintro y ⟨x, hx, rfl⟩
exact smul_of_tower_mem _ a hx
intros
simp only [lift_apply', algebra.smul_def]
intros
rwa [le_inv (@zero_lt_one α _ _) h₁, inv_one]
intros
rwa [lt_one_div (@zero_lt_one α _ _) h1, one_div_one]
intros
split
intro h
{ intro h, refine or.imp (λ h', _) (λ h', _) (le_total a b); exact ⟨by simpa [h'] using h, h'⟩ }
refine or.imp (λ h', _) (λ h', _) (le_total a b); exact ⟨by simpa [h'] using h, h'⟩
refine or.imp (λ h', _) (λ h', _) (le_total a b)
exact ⟨by simpa [h'] using h, h'⟩
exact ⟨by simpa [h'] using h, h'⟩
rintro (⟨rfl, h⟩|⟨rfl, h⟩); simp [h]
rintro (⟨rfl, h⟩|⟨rfl, h⟩)
{ rintro (⟨rfl, h⟩|⟨rfl, h⟩); simp [h] }
simp [h]
simp [h]
intros
rw [← mul_lt_mul_iff_left d, ← mul_lt_mul_iff_right b, mul_inv_cancel_left, mul_assoc, inv_mul_cancel_right]
intros
rcases le_total a 1 with h|h; simp [h]
{ rcases le_total a 1 with h|h; simp [h] }
rcases le_total a 1 with h|h
simp [h]
simp [h]
intros
ext x
simp only [mem_smul_set, algebra.id.smul_eq_mul, mem_Ioc]
split
rintro ⟨a, ⟨a_h_left_left, a_h_left_right⟩, rfl⟩
{ rintro ⟨a, ⟨a_h_left_left, a_h_left_right⟩, rfl⟩, split, exact (mul_lt_mul_left hr).mpr a_h_left_left, exact (mul_le_mul_left hr).mpr a_h_left_right, }
split
exact (mul_lt_mul_left hr).mpr a_h_left_left
exact (mul_le_mul_left hr).mpr a_h_left_right
rintro ⟨a_left, a_right⟩
{ rintro ⟨a_left, a_right⟩, use x / r, refine ⟨⟨(lt_div_iff' hr).mpr a_left, (div_le_iff' hr).mpr a_right⟩, _⟩, rw mul_div_cancel' _ (ne_of_gt hr), }
use x / r
refine ⟨⟨(lt_div_iff' hr).mpr a_left, (div_le_iff' hr).mpr a_right⟩, _⟩
rw mul_div_cancel' _ (ne_of_gt hr)
intros
cases abs_choice a with h h; simp only [h, odd_neg]
{ cases abs_choice a with h h; simp only [h, odd_neg] }
cases abs_choice a with h h
simp only [h, odd_neg]
simp only [h, odd_neg]
intros
haveI := @linear_order.decidable_le α _; exact λ x y h, decidable.mul_lt_mul (hf h) (hg h.le) (hg0 x) (hf0 y)
haveI := @linear_order.decidable_le α _
exact λ x y h, decidable.mul_lt_mul (hf h) (hg h.le) (hg0 x) (hf0 y)
intros
simpa only [sub_add_cancel] using (h (x - c)).symm
intros
{ rw mem_finset_prod, exact ⟨g, hg, rfl⟩ }
rw mem_finset_prod
exact ⟨g, hg, rfl⟩
intros
rw image_eq_preimage_of_inverse; intro c; simp
rw image_eq_preimage_of_inverse; intro c
{ rw image_eq_preimage_of_inverse; intro c; simp }
rw image_eq_preimage_of_inverse
intro c
simp
intro c
simp
intros
rw [← smul_eval_smul, smul_inv_smul]
intros
{ rw norm_sq_def', apply_rules [sq_nonneg, add_nonneg] }
rw norm_sq_def'
apply_rules [sq_nonneg, add_nonneg]
intros
rintros y ⟨z, hz⟩
rw mul_assoc at hz
rcases h.is_unit_or_is_unit hz with hu | hu
{ exact hu }
exact hu
{ apply is_unit_of_mul_is_unit_left hu }
apply is_unit_of_mul_is_unit_left hu
intros
rw mul_support_subset_iff'
simp only [mem_Union, not_exists, nmem_mul_support]
intros x hx
simp only [hx, csupr_const]
intros
simp [comp_partial_sum_target, comp_partial_sum_target_set]
intros
split
rintros h
{ rintros h, rcases h.exists_nonneg with ⟨c, hnnc, hc⟩, rcases hc.exists_eq_mul hnnc with ⟨φ, hφ, huvφ⟩, exact ⟨φ, ⟨c, hφ⟩, huvφ⟩ }
rcases h.exists_nonneg with ⟨c, hnnc, hc⟩
rcases hc.exists_eq_mul hnnc with ⟨φ, hφ, huvφ⟩
exact ⟨φ, ⟨c, hφ⟩, huvφ⟩
rintros ⟨φ, ⟨c, hφ⟩, huvφ⟩
{ rintros ⟨φ, ⟨c, hφ⟩, huvφ⟩, exact is_O_iff_is_O_with.2 ⟨c, is_O_with_of_eq_mul φ hφ huvφ⟩ }
exact is_O_iff_is_O_with.2 ⟨c, is_O_with_of_eq_mul φ hφ huvφ⟩
intros
simp only [is_O_with, norm_norm]
intros
simp [is_O, is_O_with]
intros
simpa only [one_apply, one_smul, smul_right_apply, coe_comp', (∘)] using (hl.comp x hf.has_fderiv_within_at hst).has_deriv_within_at
intros
have := (hc.has_fderiv_at.clm_apply hu.has_fderiv_at).has_deriv_at
rwa [add_apply, comp_apply, flip_apply, smul_right_apply, smul_right_apply, one_apply, one_smul, one_smul, add_comm] at this
intros
{ unfold deriv, rwa filter.eventually_eq.fderiv_eq }
unfold deriv
rwa filter.eventually_eq.fderiv_eq
intros
rcases hf with ⟨f', hf'⟩
rcases hg with ⟨g', hg'⟩
exact ⟨continuous_linear_map.comp g' f', hg'.comp x hf' h⟩
intros
{ convert hc.mul' hd, ext z, apply mul_comm }
convert hc.mul' hd
ext z
apply mul_comm
intros
simp [has_fderiv_within_at, nhds_within_restrict'' s h]
intros
rw subsingleton_iff at h
have key : function.const X (f 0) = f := by ext x'; rw h x' 0
exact key ▸ (has_fderiv_at_const (f 0) _)
intros
apply implicit_to_local_homeomorph_of_complemented_self
intros
apply lhopital_zero_nhds'; apply eventually_nhds_within_of_eventually_nhds <|> apply tendsto_nhds_within_of_tendsto_nhds; assumption
apply lhopital_zero_nhds'; apply eventually_nhds_within_of_eventually_nhds <|> apply tendsto_nhds_within_of_tendsto_nhds
apply lhopital_zero_nhds'
apply eventually_nhds_within_of_eventually_nhds
assumption
apply eventually_nhds_within_of_eventually_nhds
assumption
apply eventually_nhds_within_of_eventually_nhds
apply tendsto_nhds_within_of_tendsto_nhds
assumption
apply eventually_nhds_within_of_eventually_nhds
apply tendsto_nhds_within_of_tendsto_nhds
assumption
apply eventually_nhds_within_of_eventually_nhds
apply tendsto_nhds_within_of_tendsto_nhds
assumption
intros
rw [smooth_transition, zero_of_nonpos h, zero_div]
intros
simp [has_ftaylor_series_up_to_on_univ_iff.symm, continuous_iff_continuous_on_univ, has_ftaylor_series_up_to_on_zero_iff]
intros
simp [norm_sq_eq_abs]
intros
contrapose! h
have : cd 0 = 0
apply_fun complex.im at h
{ apply_fun complex.im at h, simpa only [z.im_ne_zero, complex.add_im, add_zero, coe_im, zero_mul, or_false, complex.of_real_im, complex.zero_im, complex.mul_im, mul_eq_zero] using h, }
simpa only [z.im_ne_zero, complex.add_im, add_zero, coe_im, zero_mul, or_false, complex.of_real_im, complex.zero_im, complex.mul_im, mul_eq_zero] using h
simp only [this, zero_mul, complex.of_real_zero, zero_add, complex.of_real_eq_zero] at h
ext i
fin_cases i; assumption
fin_cases i
assumption
assumption
intros
rw convex_iff_segment_subset
exact forall₂_congr (λ x y, forall₂_congr $ λ hx hy, (open_segment_subset_iff_segment_subset hx hy).symm)
intros
{ convert hs.add_smul_sub_mem_interior hx hy ht, abel }
convert hs.add_smul_sub_mem_interior hx hy ht
abel
intros
rw [←zero_smul 𝕜 (0 : F), inner_smul_left]; simp only [zero_mul, ring_hom.map_zero]
rw [←zero_smul 𝕜 (0 : F), inner_smul_left]
simp only [zero_mul, ring_hom.map_zero]
intros
rw set.sUnion_eq_Union; exact orthonormal_Union_of_directed hs.directed_coe (by simpa using h)
rw set.sUnion_eq_Union
exact orthonormal_Union_of_directed hs.directed_coe (by simpa using h)
intros
rw [dist_eq_norm, vsub_sub_vsub_cancel_left, dist_comm, dist_eq_norm_vsub V]
intros
rw [real.norm_eq_abs, x.abs_eq]
intros
rw [mem_ball, dist_zero_right]
intros
simpa only [sub_eq_add_neg] using hf.add hg.neg
intros
have := x.norm_def
{ have := x.norm_def, simp only [← coe_nnnorm] at this, exact_mod_cast this }
simp only [← coe_nnnorm] at this
exact_mod_cast this
intros
rw exp_series_radius_eq_top
exact with_top.zero_lt_top
intros
simp
intros
{ ext, exact f.map_zero }
ext
exact f.map_zero
intros
convert inverse_add_norm_diff_nth_order x 1; simp
{ convert inverse_add_norm_diff_nth_order x 1; simp }
convert inverse_add_norm_diff_nth_order x 1
simp
simp
intros
simp [absorbs, absorbent]
intros
refine (continuous_const.div _ (λ x, _)).interval_integrable a b
{ continuity }
continuity
{ nlinarith }
nlinarith
intros
simpa using integral_sin_pow_odd_mul_cos_pow 1 0
intros
simp [*, mul_rpow_eq_ite]
intros
convert (@has_strict_fderiv_at_cpow ((λ x, (f x, g x)) x) h0).comp x (hf.prod hg)
intros
simp only [sub_eq_add_neg, rpow_add hx, rpow_neg (le_of_lt hx), div_eq_mul_inv]
intros
rw [rpow_def_of_pos hx, one_lt_exp_iff, mul_pos_iff, log_pos_iff hx, log_neg_iff hx]
intros
rw [← tan_div_sqrt_one_add_tan_sq (cos_arctan_pos x), tan_arctan]
intros
simp [sub_eq_add_neg, sin_add]
intros
rw [sin_sq, cos_pi_over_two_pow]
intros
cases le_total x (-1) with hx₁ hx₁
simp [arcsin_of_le_neg_one hx₁, hy.1, hx₁.trans (neg_one_le_sin _)]
{ simp [arcsin_of_le_neg_one hx₁, hy.1, hx₁.trans (neg_one_le_sin _)] }
cases lt_or_le 1 x with hx₂ hx₂
simp [arcsin_of_one_le hx₂.le, hy.2.not_le, (sin_le_one y).trans_lt hx₂]
{ simp [arcsin_of_one_le hx₂.le, hy.2.not_le, (sin_le_one y).trans_lt hx₂] }
exact arcsin_le_iff_le_sin ⟨hx₁, hx₂⟩ (mem_Icc_of_Ico hy)
intros
subst y
exact inj_on_sin (arcsin_mem_Icc _) h₂ (sin_arcsin' (sin_mem_Icc x))
intros
rcases exists_between hr with ⟨r', hrr', h⟩
exact summable_of_is_O_nat (summable_geometric_of_lt_1 ((norm_nonneg _).trans hrr'.le) h) (is_o_pow_const_mul_const_pow_const_pow_of_norm_lt _ hrr').is_O.norm_left
intros
convert finset.card_fin n
apply fintype.of_equiv_card
intros
dsimp [transfer_nat_trans_self]
rw [id_comp, comp_id]
have := transfer_nat_trans_counit adj₁ adj₂ (L₂.left_unitor.hom ≫ f ≫ L₁.right_unitor.inv) X
dsimp at this
rw this
simp
intros
erw [iso.inv_eq_inv (e.functor.map_iso (e.unit_iso.app X) ≪≫ e.counit_iso.app (e.functor.obj X)) (iso.refl _)]
exact e.functor_unit_comp X
intros
apply zigzag_is_connected
intros j₁ j₂
rcases h j₁ j₂ with ⟨l, hl₁, hl₂⟩
apply list.relation_refl_trans_gen_of_exists_chain l hl₁ hl₂
intros
simp only [cancel_mono]
intros
apply (cancel_epi (colimit_obj_iso_colimit_comp_evaluation H k).inv).1
ext
simpa using w j
intros
ext j
rw [←assoc, colimit.ι_pre, colimit.ι_pre]
letI : has_colimit ((D ⋙ E) ⋙ F) := show has_colimit (D ⋙ E ⋙ F), by apply_instance
exact (colimit.ι_pre F (D ⋙ E) j).symm
intros
simp
intros
ext
ext; simp [add_comp]
simp [add_comp]
simp [add_comp]
intros
ext j j'
simp [comp_sum, sum_comp, biproduct.ι_π, comp_dite, dite_comp]
intros
simp
intros
{ ext, simp [← G.map_comp] }
ext
simp [← G.map_comp]
intros
ext
intros
rw [←cancel_mono (λ_ Y).hom, left_unitor_naturality, left_unitor_naturality]
{ rw [←cancel_mono (λ_ Y).hom, left_unitor_naturality, left_unitor_naturality], simp }
simp
intros
{ simp [tensor_left_tensor], }
simp [tensor_left_tensor]
intros
simp only [right_adjoint_mate, monoidal_category.tensor_id, category.id_comp, coevaluation_evaluation_assoc, category.comp_id, iso.inv_hom_id]
intros
fsplit
introsI E X f e e_epi
obtain ⟨f', hf'⟩ := projective.factors (i.hom ≫ f) e
exact ⟨i.inv ≫ f', by simp [hf']⟩
intros
rw [←functor.map_comp,prod_comp,category.comp_id]
intros
intros s hs
let y : Π ⦃Y⦄ ⦃f : Y ⟶ X⦄ (hf : U f), presieve.family_of_elements P (B hf) := λ Y f hf Z g hg, s _ (presieve.bind_comp _ _ hg)
have hy : ∀ ⦃Y⦄ ⦃f : Y ⟶ X⦄ (hf : U f), (y hf).compatible
intros Y f H Y₁ Y₂ Z g₁ g₂ f₁ f₂ hf₁ hf₂ comm
{ intros Y f H Y₁ Y₂ Z g₁ g₂ f₁ f₂ hf₁ hf₂ comm, apply hs, apply reassoc_of comm }
apply hs
apply reassoc_of comm
let t : presieve.family_of_elements P U := λ Y f hf, (hB hf).amalgamate (y hf) (hy hf)
have ht : ∀ ⦃Y⦄ ⦃f : Y ⟶ X⦄ (hf : U f), (y hf).is_amalgamation (t f hf) := λ Y f hf, (hB hf).is_amalgamation _
have hT : t.compatible
rw presieve.compatible_iff_sieve_compatible
{ rw presieve.compatible_iff_sieve_compatible, intros Z W f h hf, apply (hB (U.downward_closed hf h)).is_separated_for.ext, intros Y l hl, apply (hB' hf (l ≫ h)).ext, intros M m hm, have : bind U B (m ≫ l ≫ h ≫ f), { have : bind U B _ := presieve.bind_comp f hf hm, simpa using this }, transitivity s (m ≫ l ≫ h ≫ f) this, { have := ht (U.downward_closed hf h) _ ((B _).downward_closed hl m), rw [op_comp, functor_to_types.map_comp_apply] at this, rw this, change s _ _ = s _ _, simp }, { have : s _ _ = _ := (ht hf _ hm).symm, simp only [assoc] at this, rw this, simp } }
intros Z W f h hf
apply (hB (U.downward_closed hf h)).is_separated_for.ext
intros Y l hl
apply (hB' hf (l ≫ h)).ext
intros M m hm
have : bind U B (m ≫ l ≫ h ≫ f)
have : bind U B _ := presieve.bind_comp f hf hm
{ have : bind U B _ := presieve.bind_comp f hf hm, simpa using this }
simpa using this
transitivity s (m ≫ l ≫ h ≫ f) this
have := ht (U.downward_closed hf h) _ ((B _).downward_closed hl m)
{ have := ht (U.downward_closed hf h) _ ((B _).downward_closed hl m), rw [op_comp, functor_to_types.map_comp_apply] at this, rw this, change s _ _ = s _ _, simp }
rw [op_comp, functor_to_types.map_comp_apply] at this
rw this
change s _ _ = s _ _
simp
have : s _ _ = _ := (ht hf _ hm).symm
{ have : s _ _ = _ := (ht hf _ hm).symm, simp only [assoc] at this, rw this, simp }
simp only [assoc] at this
rw this
simp
refine ⟨hU.amalgamate t hT, _, _⟩
rintro Z _ ⟨Y, f, g, hg, hf, rfl⟩
{ rintro Z _ ⟨Y, f, g, hg, hf, rfl⟩, rw [op_comp, functor_to_types.map_comp_apply, presieve.is_sheaf_for.valid_glue _ _ _ hg], apply ht hg _ hf }
rw [op_comp, functor_to_types.map_comp_apply, presieve.is_sheaf_for.valid_glue _ _ _ hg]
apply ht hg _ hf
intros y hy
{ intros y hy, apply hU.is_separated_for.ext, intros Y f hf, apply (hB hf).is_separated_for.ext, intros Z g hg, rw [←functor_to_types.map_comp_apply, ←op_comp, hy _ (presieve.bind_comp _ _ hg), hU.valid_glue _ _ hf, ht hf _ hg] }
apply hU.is_separated_for.ext
intros Y f hf
apply (hB hf).is_separated_for.ext
intros Z g hg
rw [←functor_to_types.map_comp_apply, ←op_comp, hy _ (presieve.bind_comp _ _ hg), hU.valid_glue _ _ hf, ht hf _ hg]
intros
{ ext, simp, }
ext
simp
intros
simp [image_subobject_iso]
intros
rw [colex.lt_def]
refine ⟨max' _ hA, _, by simp, max'_mem _ _⟩
simp only [false_iff, not_mem_empty]
intros x hx t
apply not_le_of_lt hx (le_max' _ _ t)
intros
simp_rw [coe_inv_embedding, index_embedding, coe_embedding, nat.add_sub_cancel_left]
intros
have : c.blocks.take c.length = c.blocks := take_all_of_le (by simp [blocks])
rw [← this, c.blocks_partial_sum c.length_lt_card_boundaries, c.boundary_length]
refl
intros
haveI := classical.dec_eq ι
convert ht (s'.image coe) using 1
{ rw card_image_of_injective _ subtype.coe_injective, }
rw card_image_of_injective _ subtype.coe_injective
apply congr_arg
{ apply congr_arg, ext y, simp, }
ext y
simp
intros
simp [neighbor_finset_eq_filter, dot_product, sum_filter, finset.sum_apply]
intros
induction hf
exact zero
case nat.primrec.zero { exact zero }
exact succ
case nat.primrec.succ { exact succ }
exact left
case nat.primrec.left { exact left }
exact right
case nat.primrec.right { exact right }
case nat.primrec.pair : f g hf hg pf pg { refine (pf.pair pg).of_eq_tot (λ n, _), simp [has_seq.seq] }
case nat.primrec.comp : f g hf hg pf pg { refine (pf.comp pg).of_eq_tot (λ n, _), simp }
case nat.primrec.prec : f g hf hg pf pg { refine (pf.prec pg).of_eq_tot (λ n, _), simp, induction n.unpair.2 with m IH, {simp}, simp, exact ⟨_, IH, rfl⟩ }
intros
rw [← proj_map_nth, hL, ← list.map_reverse, list_blank.nth_mk, list.inth, list.nth_map]
cases S.reverse.nth n; refl
cases S.reverse.nth n
refl
refl
intros
rw [← bind_pure_comp_eq_map,bind_assoc]; simp [bind_pure_comp_eq_map]
rw [← bind_pure_comp_eq_map,bind_assoc]
simp [bind_pure_comp_eq_map]
intros
simp [sequence, traverse_map, id_traverse]; refl
simp [sequence, traverse_map, id_traverse]
refl
intros
simp [nth_le_to_list]
intros
{ introI, exact hne (of_fail h) }
introI
exact hne (of_fail h)
intros
cases hp : p cb n with np resp np errp
{ simp [hp, ←orelse_eq_orelse, parser.orelse] }
simp [hp, ←orelse_eq_orelse, parser.orelse]
by_cases h : np = n
{ by_cases h : np = n, { cases hq : q cb n with nq resq nq errq, { simp [hp, h, hn, hq, hn, ←orelse_eq_orelse, parser.orelse] }, { have : n ≤ nq := mono.of_fail hq, rcases eq_or_lt_of_le this with rfl|H, { simp [hp, hq, h, hn, lt_irrefl, ←orelse_eq_orelse, parser.orelse] }, { simp [hp, hq, h, hn, H, ←orelse_eq_orelse, parser.orelse] } } }, { simp [hp, h, ←orelse_eq_orelse, parser.orelse] } }
cases hq : q cb n with nq resq nq errq
{ cases hq : q cb n with nq resq nq errq, { simp [hp, h, hn, hq, hn, ←orelse_eq_orelse, parser.orelse] }, { have : n ≤ nq := mono.of_fail hq, rcases eq_or_lt_of_le this with rfl|H, { simp [hp, hq, h, hn, lt_irrefl, ←orelse_eq_orelse, parser.orelse] }, { simp [hp, hq, h, hn, H, ←orelse_eq_orelse, parser.orelse] } } }
{ simp [hp, h, hn, hq, hn, ←orelse_eq_orelse, parser.orelse] }
simp [hp, h, hn, hq, hn, ←orelse_eq_orelse, parser.orelse]
have : n ≤ nq := mono.of_fail hq
{ have : n ≤ nq := mono.of_fail hq, rcases eq_or_lt_of_le this with rfl|H, { simp [hp, hq, h, hn, lt_irrefl, ←orelse_eq_orelse, parser.orelse] }, { simp [hp, hq, h, hn, H, ←orelse_eq_orelse, parser.orelse] } }
rcases eq_or_lt_of_le this with rfl|H
simp [hp, hq, h, hn, lt_irrefl, ←orelse_eq_orelse, parser.orelse]
{ simp [hp, hq, h, hn, lt_irrefl, ←orelse_eq_orelse, parser.orelse] }
simp [hp, hq, h, hn, H, ←orelse_eq_orelse, parser.orelse]
{ simp [hp, hq, h, hn, H, ←orelse_eq_orelse, parser.orelse] }
{ simp [hp, h, ←orelse_eq_orelse, parser.orelse] }
simp [hp, h, ←orelse_eq_orelse, parser.orelse]
intros
simp only [char_buf, decorate_error_eq_done, ne.def, ←buffer.length_to_list]
induction cb'.to_list with hd tl hl generalizing cb n n'
simp [pure_eq_done, mmap'_eq_done, -buffer.length_to_list, list.nil_prefix]
{ simp [pure_eq_done, mmap'_eq_done, -buffer.length_to_list, list.nil_prefix] }
simp only [ch_eq_done, and.comm, and.assoc, and.left_comm, hl, mmap', and_then_eq_bind, bind_eq_done, list.length, exists_and_distrib_left, exists_const]
{ simp only [ch_eq_done, and.comm, and.assoc, and.left_comm, hl, mmap', and_then_eq_bind, bind_eq_done, list.length, exists_and_distrib_left, exists_const], split, { rintro ⟨np, h, rfl, rfl, hn, rfl⟩, simp only [add_comm, add_left_comm, h, true_and, eq_self_iff_true, and_true], have : n < cb.to_list.length := by simpa using hn, rwa [←buffer.nth_le_to_list _ this, ←list.cons_nth_le_drop_succ this, list.prefix_cons_inj] }, { rintro ⟨h, rfl⟩, by_cases hn : n < cb.size, { have : n < cb.to_list.length := by simpa using hn, rw [←list.cons_nth_le_drop_succ this, list.cons_prefix_iff] at h, use [n + 1, h.right], simpa [buffer.nth_le_to_list, add_comm, add_left_comm, add_assoc, hn] using h.left.symm }, { have : cb.to_list.length ≤ n := by simpa using hn, rw list.drop_eq_nil_of_le this at h, simpa using h } } }
split
rintro ⟨np, h, rfl, rfl, hn, rfl⟩
{ rintro ⟨np, h, rfl, rfl, hn, rfl⟩, simp only [add_comm, add_left_comm, h, true_and, eq_self_iff_true, and_true], have : n < cb.to_list.length := by simpa using hn, rwa [←buffer.nth_le_to_list _ this, ←list.cons_nth_le_drop_succ this, list.prefix_cons_inj] }
simp only [add_comm, add_left_comm, h, true_and, eq_self_iff_true, and_true]
have : n < cb.to_list.length := by simpa using hn
rwa [←buffer.nth_le_to_list _ this, ←list.cons_nth_le_drop_succ this, list.prefix_cons_inj]
rintro ⟨h, rfl⟩
{ rintro ⟨h, rfl⟩, by_cases hn : n < cb.size, { have : n < cb.to_list.length := by simpa using hn, rw [←list.cons_nth_le_drop_succ this, list.cons_prefix_iff] at h, use [n + 1, h.right], simpa [buffer.nth_le_to_list, add_comm, add_left_comm, add_assoc, hn] using h.left.symm }, { have : cb.to_list.length ≤ n := by simpa using hn, rw list.drop_eq_nil_of_le this at h, simpa using h } }
by_cases hn : n < cb.size
have : n < cb.to_list.length := by simpa using hn
{ have : n < cb.to_list.length := by simpa using hn, rw [←list.cons_nth_le_drop_succ this, list.cons_prefix_iff] at h, use [n + 1, h.right], simpa [buffer.nth_le_to_list, add_comm, add_left_comm, add_assoc, hn] using h.left.symm }
rw [←list.cons_nth_le_drop_succ this, list.cons_prefix_iff] at h
use [n + 1, h.right]
simpa [buffer.nth_le_to_list, add_comm, add_left_comm, add_assoc, hn] using h.left.symm
have : cb.to_list.length ≤ n := by simpa using hn
{ have : cb.to_list.length ≤ n := by simpa using hn, rw list.drop_eq_nil_of_le this at h, simpa using h }
rw list.drop_eq_nil_of_le this at h
simpa using h
intros
simp [sep_by1, seq_eq_done]
simp [inv_eq_one_div]
intros
subst er; exact exp_approx_succ _ e₁ _ _ (by simpa using e) (exp_approx_end _ _ _ e₁ h)
subst er
exact exp_approx_succ _ e₁ _ _ (by simpa using e) (exp_approx_end _ _ _ e₁ h)
intros
rw [← mul_right_inj' (@two_ne_zero' ℂ _ _ _), two_cosh, two_cos, neg_mul_eq_neg_mul]
intros
rw [add_comm, sin_sq_add_cos_sq]
intros
simp [ext_iff]
intros
rw [← of_real_int_cast, of_real_re]
intros
{ ext, simp only [map_range_apply, coe_zero, pi.zero_apply, hf] }
ext
simp only [map_range_apply, coe_zero, pi.zero_apply, hf]
intros
classical
exact quotient.induction_on f (λ x, x.2.to_finset.finite_to_set.subset (λ i H, multiset.mem_to_finset.2 ((x.3 i).resolve_right H)))
intros
{ ext ⟨a, b⟩ : 1, simp }
ext ⟨a, b⟩ : 1
simp
intros
ext x
cases x
{ simp [sum.map, swap_apply_of_ne_of_ne] }
simp [sum.map, swap_apply_of_ne_of_ne]
simp [sum.map, swap_apply_def]
{ simp [sum.map, swap_apply_def], split_ifs; refl}
split_ifs; refl
split_ifs
refl
refl
refl
intros
{ ext, simp }
ext
simp
intros
rw [← fin.succ_above_above _ _ h, fin_succ_equiv'_succ_above]
intros
{ substs f g s t, cases e, refl }
substs f g s t
cases e
refl
intros
ext j
by_cases h : j.val < n
have : j ≠ last n := ne_of_lt h
{ have : j ≠ last n := ne_of_lt h, simp [h, update_noteq, this, snoc] }
simp [h, update_noteq, this, snoc]
rw eq_last_of_not_lt h
{ rw eq_last_of_not_lt h, simp }
simp
intros
{ subst h, ext, simp }
subst h
ext
simp
intros
classical
{ classical, ext x, simp, split_ifs with h; by_cases h' : x = a; simp [h, h'] }
ext x
simp
split_ifs with h
split_ifs with h; by_cases h' : x = a; simp [h, h']
split_ifs with h; by_cases h' : x = a
by_cases h' : x = a
simp [h, h']
simp [h, h']
by_cases h' : x = a
simp [h, h']
simp [h, h']
intros
rw [coe_singleton, set.singleton_subset_iff]
intros
rw [comp_sup_eq_sup_comp coe]; intros; refl
rw [comp_sup_eq_sup_comp coe]; intros
{ rw [comp_sup_eq_sup_comp coe]; intros; refl }
rw [comp_sup_eq_sup_comp coe]
intros
refl
intros
refl
intros
simp [min']
intros
rw [noncomm_prod]
simp only [noncomm_fold_coe]
induction l with hd tl hl
{ simp }
simp
rw [list.prod_cons, list.foldr, hl]
{ rw [list.prod_cons, list.foldr, hl], intros x hx y hy, exact comm x (list.mem_cons_of_mem _ hx) y (list.mem_cons_of_mem _ hy) }
intros x hx y hy
exact comm x (list.mem_cons_of_mem _ hx) y (list.mem_cons_of_mem _ hy)
intros
{ ext x, simp }
ext x
simp
intros
simp [to_finset]
intros
classical
rw [←finset.card_univ, univ_sum_type, finset.card_union_eq]
{ simp [finset.card_univ] }
simp [finset.card_univ]
intros x hx
{ intros x hx, suffices : (∃ (a : α), sum.inl a = x) ∧ ∃ (b : β), sum.inr b = x, { obtain ⟨⟨a, rfl⟩, ⟨b, hb⟩⟩ := this, simpa using hb }, simpa using hx }
suffices : (∃ (a : α), sum.inl a = x) ∧ ∃ (b : β), sum.inr b = x
obtain ⟨⟨a, rfl⟩, ⟨b, hb⟩⟩ := this
{ obtain ⟨⟨a, rfl⟩, ⟨b, hb⟩⟩ := this, simpa using hb }
simpa using hb
simpa using hx
intros
simp
intros
{ simp only [not_le, iff_false], exact int.neg_succ_lt_zero n, }
simp only [not_le, iff_false]
exact int.neg_succ_lt_zero n
intros
rw [←int.nat_abs_eq_nat_abs_iff, int.nat_abs_of_nat]
intros
simp [sub_eq_add_neg]
intros
simp [gcd]
intros
{ unfold gcd_a, rw [xgcd, xgcd_zero_left] }
unfold gcd_a
rw [xgcd, xgcd_zero_left]
intros
simp [p₁₂.kunion s₃.nodupkeys p₃₄]
intros
rw last_eq_nth_le
congr
simp [h]
intros
induction l with hd tl IH
{ simp }
simp
{ simpa using IH }
simpa using IH
intros
rw [← filter_map_eq_filter, filter_map_filter_map]
congr
funext x
show (option.guard p x).bind f = ite (p x) (f x) none
by_cases h : p x
{ simp only [option.guard, if_pos h, option.some_bind'] }
simp only [option.guard, if_pos h, option.some_bind']
{ simp only [option.guard, if_neg h, option.none_bind'] }
simp only [option.guard, if_neg h, option.none_bind']
intros
simp only [countp_eq_length_filter, filter_append, length_append]
intros
simp only [erase_cons, if_pos rfl]
intros
simp only [disjoint_left, imp_not_comm, forall_eq']
intros
simp only [reverse_core_eq, map_append, map_reverse]
intros
cases l with hd tl
{ simpa using h }
simpa using h
induction tl with hd' tl hl generalizing hd
{ simp }
simp
by_cases hx : x = hd
{ by_cases hx : x = hd, { simp only [hx, prev_cons_cons_eq], exact mem_cons_of_mem _ (last_mem _) }, { rw [prev, dif_neg hx], split_ifs with hm, { exact mem_cons_self _ _ }, { exact mem_cons_of_mem _ (hl _ _) } } }
simp only [hx, prev_cons_cons_eq]
{ simp only [hx, prev_cons_cons_eq], exact mem_cons_of_mem _ (last_mem _) }
exact mem_cons_of_mem _ (last_mem _)
rw [prev, dif_neg hx]
{ rw [prev, dif_neg hx], split_ifs with hm, { exact mem_cons_self _ _ }, { exact mem_cons_of_mem _ (hl _ _) } }
split_ifs with hm
{ exact mem_cons_self _ _ }
exact mem_cons_self _ _
{ exact mem_cons_of_mem _ (hl _ _) }
exact mem_cons_of_mem _ (hl _ _)
intros
induction l with hd tl hl generalizing f
simp [map_with_index, map_with_index_core, list.enum_eq_zip_range]
{ simp [map_with_index, map_with_index_core, list.enum_eq_zip_range] }
rw [map_with_index, map_with_index_core, map_with_index_core_eq, hl]
{ rw [map_with_index, map_with_index_core, map_with_index_core_eq, hl], simp [enum_eq_zip_range, range_succ_eq_map, zip_with_map_left, map_uncurry_zip_eq_zip_with] }
simp [enum_eq_zip_range, range_succ_eq_map, zip_with_map_left, map_uncurry_zip_eq_zip_with]
intros
simp only [nodup, pairwise_join, disjoint_left.symm, forall_mem_ne]
intros
induction l₁ with x l₁ IH; [simp only [list.pairwise.nil, forall_prop_of_false (not_mem_nil _), forall_true_iff, and_true, true_and, nil_append], simp only [cons_append, pairwise_cons, forall_mem_append, IH, forall_mem_cons, forall_and_distrib, and_assoc, and.left_comm]]
induction l₁ with x l₁ IH
simp only [list.pairwise.nil, forall_prop_of_false (not_mem_nil _), forall_true_iff, and_true, true_and, nil_append]
simp only [cons_append, pairwise_cons, forall_mem_append, IH, forall_mem_cons, forall_and_distrib, and_assoc, and.left_comm]
intros
induction l with a l IH; simp
induction l with a l IH
simp
simp
refine (perm.trans _ (IH.append_left _)).append_left _
rw [← append_assoc, ← append_assoc]
exact perm_append_comm.append_right _
intros
rw [pmap_eq_map_attach]; from ext_le (by simp) (λ i hi1 hi2, by { simp at hi1, simp [nth_le_of_fn f ⟨i, hi1⟩, -subtype.val_eq_coe] })
rw [pmap_eq_map_attach]
from ext_le (by simp) (λ i hi1 hi2, by { simp at hi1, simp [nth_le_of_fn f ⟨i, hi1⟩, -subtype.val_eq_coe] })
intros
simp [rotate]
intros
obtain ⟨k, rfl⟩ := h
exact ⟨k, by simp⟩
intros
induction l
cases h
case list.nil { cases h }
case list.cons : hd tl ih { by_cases e : a = hd.1, { subst e, exact ⟨hd.2, [], tl, by simp, by cases hd; refl, by simp⟩ }, { simp at h, cases h, case or.inl : h { exact absurd h e }, case or.inr : h { rcases ih h with ⟨b, tl₁, tl₂, h₁, h₂, h₃⟩, exact ⟨b, hd :: tl₁, tl₂, not_mem_cons_of_ne_of_not_mem e h₁, by rw h₂; refl, by simp [e, h₃]⟩ } } }
intros
rw [← @prod.mk.eta _ _ (unzip (zip l₁ l₂)), unzip_zip_left (le_of_eq h), unzip_zip_right (ge_of_eq h)]
intros
{ ext, apply dot_product_assoc }
ext
apply dot_product_assoc
intros
ext
{ ext, refl }
refl
intros
ext i j
by_cases h : i = j
{ simp [h, transpose] }
simp [h, transpose]
{ simp [h, transpose, diagonal_apply_ne' h] }
simp [h, transpose, diagonal_apply_ne' h]
intros
ext i j
{ ext i j, apply add_dot_product }
apply add_dot_product
intros
simp [hj]
intros
ext ⟨i, k⟩ ⟨j, k'⟩
simp only [block_diagonal_apply, mul_apply, ← finset.univ_product_univ, finset.sum_product]
split_ifs with h; simp [h]
split_ifs with h
simp [h]
simp [h]
intros
{ ext i, refine fin.cases _ _ i; simp }
ext i
refine fin.cases _ _ i
refine fin.cases _ _ i; simp
simp
simp
intros
rw [multiset.sigma, list.sigma, ← coe_bind]; simp
rw [multiset.sigma, list.sigma, ← coe_bind]
simp
intros
induction hst
exact rel.zero
case rel.zero { exact rel.zero }
case rel.cons : a b s t hab hst ih { apply rel.cons (h a (mem_cons_self _ _) b (mem_cons_self _ _) hab), exact ih (λ a' ha' b' hb' h', h a' (mem_cons_of_mem ha') b' (mem_cons_of_mem hb') h') }
intros
by_cases h : a ∈ s
{ rwa [card_erase_of_mem h, if_pos] }
rwa [card_erase_of_mem h, if_pos]
{ rwa [erase_of_not_mem h, if_neg] }
rwa [erase_of_not_mem h, if_neg]
intros
by_cases a ∈ s; simp [h]
by_cases a ∈ s
simp [h]
simp [h]
intros
apply finset.sum_congr rfl
intros c hc
dsimp
congr' 1
apply finset.prod_congr rfl
intros i hi
dsimp
congr' 1
apply h hi
rwa finsupp.mem_support_iff at hc
intros
{ ext1, apply bind₁_bind₁ }
ext1
apply bind₁_bind₁
intros
apply mv_polynomial.induction_on p; { intros, simp [*] }
apply mv_polynomial.induction_on p
{ intros, simp [*] }
{ intros, simp [*] }
intros
{ intros, simp [*] }
simp [*]
intros
rw [X, vars_monomial (@one_ne_zero R _ _), finsupp.support_single_ne_zero (one_ne_zero : 1 ≠ 0)]
intros
intros i hi
simp only [vars, exists_prop, multiset.mem_to_finset, finset.mem_image] at hi ⊢
simpa only [multiset.mem_map] using degrees_rename _ _ hi
intros
simp only [exists_prop, ← lt_succ_iff, find_lt_iff]
intros
induction n using nat.binary_rec with b n hn generalizing m
simp only [zero_test_bit] at h
{ simp only [zero_test_bit] at h, exact (zero_of_test_bit_eq_ff (λ i, (h i).symm)).symm }
exact (zero_of_test_bit_eq_ff (λ i, (h i).symm)).symm
induction m using nat.binary_rec with b' m hm
simp only [zero_test_bit] at h
{ simp only [zero_test_bit] at h, exact zero_of_test_bit_eq_ff h }
exact zero_of_test_bit_eq_ff h
suffices h' : n = m
{ rw [h', show b = b', by simpa using h 0] }
rw [h', show b = b', by simpa using h 0]
exact hn (λ i, by convert h (i + 1) using 1; rw test_bit_succ)
intros
rw digits_aux
intros
convert to_with_top_top
intros
rw [desc_factorial_succ, nat.zero_sub, zero_mul]
intros
rw [nat.coprime_comm, coprime_pow_left_iff hn, nat.coprime_comm]
intros
rw [add_div hc0, if_pos hc]
intros
simpa [H] using mkpair_unpair n
intros
rw [odd_iff, mod_two_ne_one]
intros
{ rw ←one_pow n, exact nat.pow_le_pow_of_le_left h n }
rw ←one_pow n
exact nat.pow_le_pow_of_le_left h n
intros
rw [← with_bot.coe_zero, with_bot.coe_le_coe]; exact nat.zero_le _
rw [← with_bot.coe_zero, with_bot.coe_le_coe]
exact nat.zero_le _
intros
rw [← dvd_to_int, int.dvd_iff_mod_eq_zero, ← to_int_inj, mod_to_int]
rw [← dvd_to_int, int.dvd_iff_mod_eq_zero, ← to_int_inj, mod_to_int]; refl
refl
intros
cases x; simp only [pbind, map_none']
{ cases x; simp only [pbind, map_none'] }
cases x
simp only [pbind, map_none']
simp only [pbind, map_none']
intros
rw [valid'.dual_iff, dual_balance_r]
have := hr.dual.balance_l_aux hl.dual
rw [size_dual, size_dual] at this
exact this H₁ H₂ H₃
intros
cases m; [exact (hl.node' hm).node' hr, exact (hl.node' hm.2.1).node' (hm.2.2.node' hr)]
cases m
exact (hl.node' hm).node' hr
exact (hl.node' hm.2.1).node' (hm.2.2.node' hr)
intros
cases t
cases t; refl
refl
refl
intros
cases x with a₁ f₁
cases y with a₂ f₂
dsimp [Mp] at *
have : a₁ = a₂
refine pfunctor.M.bisim (λ a₁ a₂, ∃ x y, R x y ∧ x.1 = a₁ ∧ y.1 = a₂) _ _ _ ⟨⟨a₁, f₁⟩, ⟨a₂, f₂⟩, r, rfl, rfl⟩
{ refine pfunctor.M.bisim (λ a₁ a₂, ∃ x y, R x y ∧ x.1 = a₁ ∧ y.1 = a₂) _ _ _ ⟨⟨a₁, f₁⟩, ⟨a₂, f₂⟩, r, rfl, rfl⟩, rintro _ _ ⟨⟨a₁, f₁⟩, ⟨a₂, f₂⟩, r, rfl, rfl⟩, rcases h _ _ r with ⟨a', f', f₁', f₂', e₁, e₂, h'⟩, rcases M.bisim_lemma P e₁ with ⟨g₁', e₁', rfl, rfl⟩, rcases M.bisim_lemma P e₂ with ⟨g₂', e₂', _, rfl⟩, rw [e₁', e₂'], exact ⟨_, _, _, rfl, rfl, λ b, ⟨_, _, h' b, rfl, rfl⟩⟩ }
rintro _ _ ⟨⟨a₁, f₁⟩, ⟨a₂, f₂⟩, r, rfl, rfl⟩
rcases h _ _ r with ⟨a', f', f₁', f₂', e₁, e₂, h'⟩
rcases M.bisim_lemma P e₁ with ⟨g₁', e₁', rfl, rfl⟩
rcases M.bisim_lemma P e₂ with ⟨g₂', e₂', _, rfl⟩
rw [e₁', e₂']
exact ⟨_, _, _, rfl, rfl, λ b, ⟨_, _, h' b, rfl, rfl⟩⟩
subst this
congr' with i p
induction p with x a f h' i c x a f h' i c p IH generalizing f₁ f₂
induction p with x a f h' i c x a f h' i c p IH generalizing f₁ f₂; try { rcases h _ _ r with ⟨a', f', f₁', f₂', e₁, e₂, h''⟩, rcases M.bisim_lemma P e₁ with ⟨g₁', e₁', rfl, rfl⟩, rcases M.bisim_lemma P e₂ with ⟨g₂', e₂', e₃, rfl⟩, cases h'.symm.trans e₁', cases h'.symm.trans e₂' }
try { rcases h _ _ r with ⟨a', f', f₁', f₂', e₁, e₂, h''⟩, rcases M.bisim_lemma P e₁ with ⟨g₁', e₁', rfl, rfl⟩, rcases M.bisim_lemma P e₂ with ⟨g₂', e₂', e₃, rfl⟩, cases h'.symm.trans e₁', cases h'.symm.trans e₂' }
{ exact (congr_fun (congr_fun e₃ i) c : _) }
exact (congr_fun (congr_fun e₃ i) c : _)
try { rcases h _ _ r with ⟨a', f', f₁', f₂', e₁, e₂, h''⟩, rcases M.bisim_lemma P e₁ with ⟨g₁', e₁', rfl, rfl⟩, rcases M.bisim_lemma P e₂ with ⟨g₂', e₂', e₃, rfl⟩, cases h'.symm.trans e₁', cases h'.symm.trans e₂' }
rcases h _ _ r with ⟨a', f', f₁', f₂', e₁, e₂, h''⟩
rcases M.bisim_lemma P e₁ with ⟨g₁', e₁', rfl, rfl⟩
rcases M.bisim_lemma P e₂ with ⟨g₂', e₂', e₃, rfl⟩
cases h'.symm.trans e₁'
cases h'.symm.trans e₂'
{ exact IH _ _ (h'' _) }
exact IH _ _ (h'' _)
intros
{ cases x, cases y, congr' with n, apply H }
cases x
cases y
congr' with n
apply H
intros
simp only [obj.iget, fst_map, *, dif_pos, eq_self_iff_true]
{ simp only [obj.iget, fst_map, *, dif_pos, eq_self_iff_true], cases x, refl }
cases x
refl
intros
let n := u.prod
let m := v.prod
change (u ⊔ v).prod = pnat.lcm n m
have : u = n.factor_multiset := u.factor_multiset_prod.symm
rw [this]
have : v = m.factor_multiset := v.factor_multiset_prod.symm
rw [this]
rw[← pnat.factor_multiset_lcm n m, pnat.prod_factor_multiset]
intros
simp_rw algebra.smul_def
{ simp_rw algebra.smul_def, exact eval₂_eq_sum_range (algebra_map R S) x }
exact eval₂_eq_sum_range (algebra_map R S) x
intros
simpa only [pow_one] using coeff_mul_X_pow p 1 n
intros
rw [← monomial_eq_C_mul_X, degree_monomial n ha]
intros
haveI := nontrivial.of_polynomial_ne hp; exact have leading_coeff p * leading_coeff X ≠ 0, by simpa, by erw [degree_mul' this, degree_eq_nat_degree hp, degree_X, ← with_bot.coe_one, ← with_bot.coe_add, with_bot.coe_lt_coe]; exact nat.lt_succ_self _
haveI := nontrivial.of_polynomial_ne hp
exact have leading_coeff p * leading_coeff X ≠ 0, by simpa, by erw [degree_mul' this, degree_eq_nat_degree hp, degree_X, ← with_bot.coe_one, ← with_bot.coe_add, with_bot.coe_lt_coe]; exact nat.lt_succ_self _
intros
rw degree_le_iff_coeff_zero
intros i hi
rw erase_lead_coeff
split_ifs with h
refl
{ refl }
apply coeff_eq_zero_of_degree_lt hi
intros
convert eval₂_at_apply f n
simp
intros
simp [eval₂_eq_sum]
intros
let p := span (polynomial R) {g : polynomial R | ∃ i : ℕ, g = (C (coeff f i))}
nth_rewrite 0 (sum_C_mul_X_eq f).symm
refine submodule.sum_mem _ (λ n hn, _)
dsimp
have : C (coeff f n) ∈ p
apply subset_span
apply subset_span
{ apply subset_span, simp }
{ apply subset_span, simp }
simp
simp
have : (monomial n (1 : R)) • C (coeff f n) ∈ p := p.smul_mem _ this
convert this using 1
simp only [monomial_mul_C, one_mul, smul_eq_mul]
rw monomial_eq_C_mul_X
intros
simp only [iterated_deriv_zero_right]
intros
by_cases hp : p = 0
{ rw [hp, mirror_zero] }
rw [hp, mirror_zero]
rw [mirror, nat_trailing_degree_mul_X_pow ((mt reverse_eq_zero.mp) hp), reverse_nat_trailing_degree, zero_add]
{ rw [mirror, nat_trailing_degree_mul_X_pow ((mt reverse_eq_zero.mp) hp), reverse_nat_trailing_degree, zero_add] }
intros
by_cases hp : p = 0
{ simp [hp] }
simp [hp]
rw [←with_bot.coe_eq_coe, ←degree_eq_nat_degree hp, ←degree_eq_nat_degree, degree_smul_of_smul_regular p h]
contrapose! hp
rw ←smul_zero k at hp
exact h.polynomial hp
intros
unfold reverse
rw [nat_degree_mul' fg, reflect_mul f g rfl.le rfl.le]
intros
rw [supp]
dsimp
split
intros h a f haf
{ intros h a f haf, have : liftp (λ u, u ∈ f '' univ) x, { rw liftp_iff, refine ⟨a, f, haf.symm, λ i, mem_image_of_mem _ (mem_univ _)⟩ }, exact h this }
have : liftp (λ u, u ∈ f '' univ) x
rw liftp_iff
{ rw liftp_iff, refine ⟨a, f, haf.symm, λ i, mem_image_of_mem _ (mem_univ _)⟩ }
refine ⟨a, f, haf.symm, λ i, mem_image_of_mem _ (mem_univ _)⟩
exact h this
intros h p
rw liftp_iff
rintros ⟨a, f, xeq, h'⟩
rcases h a f xeq.symm with ⟨i, _, hi⟩
rw ←hi
apply h'
intros
rw [← int.cast_coe_nat, coe_int_num]
intros
by_cases b ≤ a; simp [h, max_def]
by_cases b ≤ a
simp [h, max_def]
simp [h, max_def]
intros
rw [←(@num_denom q), ←(@num_denom p)]
conv_rhs { simp only [num_denom] }
exact rat.le_def (by exact_mod_cast p.pos) (by exact_mod_cast q.pos)
intros
simpa only [sub_eq_add_neg] using add_lim_zero hf (neg_lim_zero hg)
intros
simp [div_eq_mul_inv, top_mul]
intros
rw [div_eq_mul_inv, to_nnreal_mul, to_nnreal_inv, div_eq_mul_inv]
intros
split_ifs
simp [h]
{ simp [h] }
exact with_top.top_mul h
{ exact with_top.top_mul h }
intros
rw [add_comm, add_comm c, add_right_inj h]
rw [golden_conj, ←sub_eq_zero]
ring_exp
rw real.sq_sqrt; norm_num
rw real.sq_sqrt
norm_num
norm_num
intros
simp [le_antisymm_iff, hx, hy]
intros
{ unfold comp, ext y, simp }
unfold comp
ext y
simp
intros
revert s
induction n with n IH; intro s; apply cases_on s (λ a', _) (λ s, _); intro h
induction n with n IH; intro s; apply cases_on s (λ a', _) (λ s, _)
induction n with n IH; intro s
induction n with n IH
intro s
apply cases_on s (λ a', _) (λ s, _)
intro h
{ rw ←eq_of_ret_mem h.mem, refl }
rw ←eq_of_ret_mem h.mem
refl
intro h
cases of_results_think h with n h
{ cases of_results_think h with n h, cases h, contradiction }
cases h
contradiction
intro s
apply cases_on s (λ a', _) (λ s, _)
intro h
{ have := h.len_unique (results_ret _), contradiction }
have := h.len_unique (results_ret _)
contradiction
intro h
{ rw IH (results_think_iff.1 h), refl }
rw IH (results_think_iff.1 h)
refl
intros
rw [←lift_rel.swap R, ←lift_rel.swap R]; apply lift_rel_think_left
rw [←lift_rel.swap R, ←lift_rel.swap R]
apply lift_rel_think_left
intros
simp [set.insert_inter, h]
intros
rw [← image_comp, compl_comp_compl, image_id]
intros
split
{ intros h x hx, rcases hs hx with ⟨y, rfl⟩, exact h hx }
intros h x hx
rcases hs hx with ⟨y, rfl⟩
exact h hx
intros h x
apply h
intros
{ rw ← set.image_univ, simp [-set.image_univ, coe_image] }
rw ← set.image_univ
simp [-set.image_univ, coe_image]
intros
simp only [not_nonempty_iff_eq_empty.symm, prod_nonempty_iff, not_and_distrib]
intros
refine ⟨λ h x x' hx, _, injective.image_injective⟩
rw [← singleton_eq_singleton_iff]
apply h
rw [image_singleton, image_singleton, hx]
intros
rw [inter_comm, singleton_inter_eq_empty]
intros
ext
ext; simp
simp
intros
{ ext y, by_cases hy : y = x, { subst y, simp }, { simp [hy] } }
ext y
by_cases hy : y = x
subst y
{ subst y, simp }
simp
simp [hy]
{ simp [hy] }
intros
{ ext x, simp [Ioi] }
ext x
simp [Ioi]
intros
rw [←not_nonempty_iff_eq_empty, not_iff_not, nonempty_Icc]
intros
rw [diff_eq, compl_Iic, inter_comm, Ioi_inter_Iic]
intros
simp [lt_irrefl]
intros
simp [add_comm]
intros
simp [sub_eq_neg_add]
intros
refine ⟨λ _ h, ⟨add_le_add_right h.1 _, add_lt_add_right h.2 _⟩, λ _ _ _ _ h, add_right_cancel h, λ _ h, _⟩
obtain ⟨c, rfl⟩ := exists_add_of_le h.1
rw [mem_Ico, add_right_comm, add_le_add_iff_right, add_lt_add_iff_right] at h
exact ⟨a + c, h, by rw add_right_comm⟩
intros
rw [bdd_below_bdd_above_iff_subset_Icc]
split
rintro ⟨a, b, h⟩
{ rintro ⟨a, b, h⟩, exact ⟨a, b, λ x hx, Icc_subset_interval (h hx)⟩ }
exact ⟨a, b, λ x hx, Icc_subset_interval (h hx)⟩
{ rintro ⟨a, b, h⟩, exact ⟨min a b, max a b, h⟩ }
rintro ⟨a, b, h⟩
exact ⟨min a b, max a b, h⟩
intros
intros x hx y hy hxy
rcases mem_Union.1 hx with ⟨i, hx⟩
rcases mem_Union.1 hy with ⟨j, hy⟩
rcases hs i j with ⟨k, hi, hj⟩
exact hf k (hi hx) (hj hy) hxy
intros
{ ext, simp }
ext
simp
intros
{ ext i : 2, induction i; simp [drop_fun,*]; refl }
ext i : 2
induction i
induction i; simp [drop_fun,*]; refl
induction i; simp [drop_fun,*]
simp [drop_fun,*]
refl
simp [drop_fun,*]
refl
intros
{ rw val_one_eq_one_mod, exact nat.mod_eq_of_lt (fact.out _) }
rw val_one_eq_one_mod
exact nat.mod_eq_of_lt (fact.out _)
intros
rw ← set.image_univ
{ rw ← set.image_univ, apply image.is_subfield _ univ.is_subfield }
apply image.is_subfield _ univ.is_subfield
intros
{ rw coe_pow, exact hf.iterate n }
rw coe_pow
exact hf.iterate n
intros
rw omega_limit_eq_Inter
intros _ hx
rw mem_Inter at hx
exact hx ⟨u, hu⟩
intros
apply bot_eq_top_of_finrank_adjoin_eq_one
exact λ x, by linarith [h x, show 0 < finrank F F⟮x⟯, from finrank_pos]
intros
classical
obtain ⟨s, h⟩ := exists_multiset_of_splits i sp
use s.to_finset
rw [h, finset.prod_eq_multiset_prod, ←multiset.to_finset_eq]
apply nodup_of_separable_prod
apply separable.of_mul_right
rw ←h
exact sep.map
intros
convert eq_prod_roots_of_splits_id hsplit
simp [m]
intros
{ rw div_eq_mul_inv, exact s.mul_mem hx (s.inv_mem hy) }
rw div_eq_mul_inv
exact s.mul_mem hx (s.inv_mem hy)
intros
unfold angle
rw [inner_neg_neg, norm_neg, norm_neg]
intros
rw monge_point_vsub_face_centroid_weights_with_circumcenter_eq_sub h
simp_rw [pi.sub_apply, sum_sub_distrib, sum_monge_point_weights_with_circumcenter]
rw [sum_centroid_weights_with_circumcenter, sub_self]
simp [←card_pos, card_compl, h]
intros
rw [coe_def, support_indicator, (∘), support_comp_eq_preimage, ← ext_chart_at_source I, ← (ext_chart_at I c).symm_image_target_inter_eq', ← (ext_chart_at I c).symm_image_target_inter_eq', f.to_times_cont_diff_bump.support_eq]
intros
simpa using chart_mem_atlas H x
intros
rw ← lift_prop_on_univ at h
exact lift_prop_on_mono mono h (subset_univ _)
intros
split
{ exact continuous_within_at.union hs.1 ht.1 }
exact continuous_within_at.union hs.1 ht.1
convert has_fderiv_within_at.union hs.2 ht.2
{ convert has_fderiv_within_at.union hs.2 ht.2, simp only [union_inter_distrib_right, preimage_union] }
simp only [union_inter_distrib_right, preimage_union]
intros
simp only [tangent_map_within] with mfld_simps
rw mfderiv_within_comp p.1 hg hf h hps
refl
intros
have : e.symm.trans e ≈ local_homeomorph.of_set e.target e.open_target := local_homeomorph.trans_symm_self _
exact structure_groupoid.eq_on_source _ (of_set_mem_times_cont_diff_groupoid n I e.open_target) this
intros
rw ← times_cont_mdiff_on_univ at hf ⊢
convert hf.times_cont_mdiff_on_tangent_map_within hmn unique_mdiff_on_univ
rw tangent_map_within_univ
intros
simp only [pi.one_def, smooth_const]
intros
ext
rw [to_free_abelian_group, to_finsupp, add_monoid_hom.comp_apply, lift.of, lift_add_hom_apply_single, add_monoid_hom.flip_apply, smul_add_hom_apply, one_smul, add_monoid_hom.id_apply]
intros
{ rw eq_bot_iff, exact general_commutator_le_right H ⊥ }
rw eq_bot_iff
exact general_commutator_le_right H ⊥
intros
rw [mk', monoid_hom.map_one]; exact mul_one _
rw [mk', monoid_hom.map_one]
exact mul_one _
intros
rw ←f.map_comp_map hy j hl; refl
rw ←f.map_comp_map hy j hl
refl
intros
obtain ⟨n, hn⟩ := iff_card.mp (hG.to_quotient H.normal_core)
obtain ⟨k, hk1, hk2⟩ := (nat.dvd_prime_pow hp.out).mp ((congr_arg _ (H.normal_core.index_eq_card.trans hn)).mp (subgroup.index_dvd_of_le H.normal_core_le))
exact ⟨k, hk2⟩
intros
induction s using quot.induction_on
refine support_form_perm_of_nodup s h _
rintro _ rfl
simpa [nat.succ_le_succ_iff] using length_nontrivial hn
intros
classical
split
intro h
{ intro h, have hr : support (f ^ n) = support f, { rw hf.support_pow_eq_iff, rintro ⟨k, rfl⟩, refine h.ne_one _, simp [pow_mul, pow_order_of_eq_one] }, have : order_of (f ^ n) = order_of f, { rw [order_of_is_cycle h, hr, order_of_is_cycle hf] }, rw [order_of_pow, nat.div_eq_self] at this, cases this, { exact absurd this (order_of_pos _).ne' }, { rwa [nat.coprime_iff_gcd_eq_one, nat.gcd_comm] } }
have hr : support (f ^ n) = support f
rw hf.support_pow_eq_iff
{ rw hf.support_pow_eq_iff, rintro ⟨k, rfl⟩, refine h.ne_one _, simp [pow_mul, pow_order_of_eq_one] }
rintro ⟨k, rfl⟩
refine h.ne_one _
simp [pow_mul, pow_order_of_eq_one]
have : order_of (f ^ n) = order_of f
{ rw [order_of_is_cycle h, hr, order_of_is_cycle hf] }
rw [order_of_is_cycle h, hr, order_of_is_cycle hf]
rw [order_of_pow, nat.div_eq_self] at this
cases this
{ exact absurd this (order_of_pos _).ne' }
exact absurd this (order_of_pos _).ne'
{ rwa [nat.coprime_iff_gcd_eq_one, nat.gcd_comm] }
rwa [nat.coprime_iff_gcd_eq_one, nat.gcd_comm]
intro h
{ intro h, obtain ⟨m, hm⟩ := exists_pow_eq_self_of_coprime h, have hf' : is_cycle ((f ^ n) ^ m) := by rwa hm, refine is_cycle_of_is_cycle_pow hf' _, intros x hx, rw [hm], exact support_pow_le _ n hx }
obtain ⟨m, hm⟩ := exists_pow_eq_self_of_coprime h
have hf' : is_cycle ((f ^ n) ^ m) := by rwa hm
refine is_cycle_of_is_cycle_pow hf' _
intros x hx
rw [hm]
exact support_pow_le _ n hx
intros
by_cases h : p = q
{ exact h ▸ commute.refl _ }
exact h ▸ commute.refl _
exact (cycle_factors_finset_pairwise_disjoint _ _ hp _ hq h).commute
{ exact (cycle_factors_finset_pairwise_disjoint _ _ hp _ hq h).commute }
intros
refine fin.cases _ _ p; simp [equiv.perm.decompose_fin, fin.succ_ne_zero]
refine fin.cases _ _ p
{ refine fin.cases _ _ p; simp [equiv.perm.decompose_fin, fin.succ_ne_zero] }
simp [equiv.perm.decompose_fin, fin.succ_ne_zero]
simp [equiv.perm.decompose_fin, fin.succ_ne_zero]
intros
simp [equiv_functor.map]
intros
simp
intros
refine ⟨λ h, _, disjoint.inv_left⟩
convert h.inv_left
exact (inv_inv _).symm
intros
ext
ext; simp
simp
intros
obtain ⟨c, g', rfl, hd, hc, h3⟩ := mem_cycle_type_iff.1 h
simp only [mul_assoc]
rw [hd.commute.eq, ← mul_assoc g']
suffices hg' : order_of g' ∣ 2
rw [← pow_two, order_of_dvd_iff_pow_eq_one.1 hg', one_mul]
{ rw [← pow_two, order_of_dvd_iff_pow_eq_one.1 hg', one_mul], exact (card_support_eq_three_iff.1 h3).is_three_cycle_sq }
exact (card_support_eq_three_iff.1 h3).is_three_cycle_sq
rw [← lcm_cycle_type, multiset.lcm_dvd]
intros n hn
rw le_antisymm (two_le_of_mem_cycle_type hn) (le_trans (le_card_support_of_mem_cycle_type hn) _)
apply le_of_add_le_add_left
rw [← hd.card_support_mul, h3]
exact (c * g').support.card_le_univ
intros
cases n
{ rw pow_zero }
rw pow_zero
rw [r_one_pow, one_def]
{ rw [r_one_pow, one_def], congr' 1, exact zmod.nat_cast_self _, }
congr' 1
exact zmod.nat_cast_self _
intros
have := (normal_subgroup_of_iff hK).mp hN (a * b) b h hb
rwa [mul_assoc, mul_assoc, mul_right_inv, mul_one] at this
intros
ext x
calc f x = f.linear x +ᵥ f 0 : by simp [← f.map_vadd] ... = (f.linear.to_fun + λ (z : V1), f 0) x : by simp
intros
simp [←mem_coe]
intros
simp [s.affine_combination_eq_weighted_vsub_of_point_vadd_of_sum_eq_one w p hw 0]
intros
simp only [←span_Union, set.bUnion_of_singleton s]
intros
rw [map_le_iff_le_comap, submodule.comap_map_eq]
intros
simp
intros
rw [pow_succ', mul_eq_comp]
intros
let B := basis.of_vector_space_index K V
let hB := basis.of_vector_space K V
have hB₀ : _ := hB.linear_independent.to_subtype_range
have : linear_independent K (λ x, x : f '' B → V')
have h₁ : linear_independent K (λ (x : ↥(⇑f '' range (basis.of_vector_space _ _))), ↑x) := @linear_independent.image_subtype _ _ _ _ _ _ _ _ _ f hB₀ (show disjoint _ _, by simp [hf_inj])
{ have h₁ : linear_independent K (λ (x : ↥(⇑f '' range (basis.of_vector_space _ _))), ↑x) := @linear_independent.image_subtype _ _ _ _ _ _ _ _ _ f hB₀ (show disjoint _ _, by simp [hf_inj]), rwa [basis.range_of_vector_space K V] at h₁ }
rwa [basis.range_of_vector_space K V] at h₁
let C := this.extend (subset_univ _)
have BC := this.subset_extend (subset_univ _)
let hC := basis.extend this
haveI : inhabited V := ⟨0⟩
refine ⟨hC.constr K (C.restrict (inv_fun f)), hB.ext (λ b, _)⟩
rw image_subset_iff at BC
have fb_eq : f b = hC ⟨f b, BC b.2⟩
change f b = basis.extend this _
{ change f b = basis.extend this _, rw [basis.extend_apply_self, subtype.coe_mk] }
rw [basis.extend_apply_self, subtype.coe_mk]
dsimp [hB]
rw [basis.of_vector_space_apply_self, fb_eq, hC.constr_basis]
exact left_inverse_inv_fun (linear_map.ker_eq_bot.1 hf_inj) _
intros
simp [reindex_finset_range]
intros
induction c using clifford_algebra.induction
case h_grade0 : r { simp only [reverse.commutes, alg_hom.commutes, quaternion_algebra.coe_algebra_map, quaternion_algebra.conj_coe], }
case h_grade1 : x { rw [reverse_ι, involute_ι, to_quaternion_ι, alg_hom.map_neg, to_quaternion_ι, quaternion_algebra.neg_mk, conj_mk, neg_zero], }
case h_mul : x₁ x₂ hx₁ hx₂ { simp only [reverse.map_mul, alg_hom.map_mul, hx₁, hx₂, quaternion_algebra.conj_mul] }
case h_add : x₁ x₂ hx₁ hx₂ { simp only [reverse.map_add, alg_hom.map_add, hx₁, hx₂, quaternion_algebra.conj_add] }
intros
apply le_bot_iff.mp
apply cardinal.sup_le.mpr
rintro ⟨s, li⟩
apply le_bot_iff.mpr
apply cardinal.mk_emptyc_iff.mpr
simp only [subtype.coe_mk]
by_contradiction h
have ne : s.nonempty := ne_empty_iff_nonempty.mp h
simpa using linear_independent.ne_zero (⟨_, ne.some_mem⟩ : s) li
intros
rw is_noetherian_iff_well_founded at h
exact (well_founded.supr_eq_monotonic_sequence_limit h (f.generalized_eigenspace μ) : _)
intros
refine (span_eq_of_le _ _ (set_like.le_def.2 $ λ l hl, _)).symm
rintro _ ⟨_, hp, rfl ⟩
{ rintro _ ⟨_, hp, rfl ⟩ , exact single_mem_supported R 1 hp }
exact single_mem_supported R 1 hp
rw ← l.sum_single
{ rw ← l.sum_single, refine sum_mem _ (λ i il, _), convert @smul_mem R (α →₀ R) _ _ _ _ (single i 1) (l i) _, { simp }, apply subset_span, apply set.mem_image_of_mem _ (hl il) }
refine sum_mem _ (λ i il, _)
convert @smul_mem R (α →₀ R) _ _ _ _ (single i 1) (l i) _
{ simp }
simp
apply subset_span
apply set.mem_image_of_mem _ (hl il)
intros
apply_fun lcongr e₁ e₂ using (lcongr e₁ e₂).injective
simp
intros
obtain ⟨a, ha⟩ := submodule.nonzero_mem_of_bot_lt (bot_lt_iff_ne_bot.mpr hI)
have : linear_independent R (λ i, b i • a)
have hb := b.linear_independent
{ have hb := b.linear_independent, rw fintype.linear_independent_iff at ⊢ hb, intros g hg, apply hb g, simp only [← smul_assoc, ← finset.sum_smul, smul_eq_zero] at hg, exact hg.resolve_right ha }
rw fintype.linear_independent_iff at ⊢ hb
intros g hg
apply hb g
simp only [← smul_assoc, ← finset.sum_smul, smul_eq_zero] at hg
exact hg.resolve_right ha
exact le_antisymm (b.card_le_card_of_linear_independent (c.linear_independent.map' (submodule.subtype I) (linear_map.ker_eq_bot.mpr subtype.coe_injective))) (c.card_le_card_of_linear_independent this)
intros
have := eq_of_linear_independent_of_span_subtype (hl.mono (set.union_subset hsu htu)) (set.subset_union_right _ _) (set.union_subset (set.subset.trans subset_span hst) subset_span)
rw ← this
apply set.subset_union_left
intros
simp only [linear_independent_iff, (∘), finsupp.mem_supported, finsupp.total_apply, set.subset_def, finset.mem_coe]
split
intros h l hl₁ hl₂
{ intros h l hl₁ hl₂, have := h (l.subtype_domain s) ((finsupp.sum_subtype_domain_index hl₁).trans hl₂), exact (finsupp.subtype_domain_eq_zero_iff hl₁).1 this }
have := h (l.subtype_domain s) ((finsupp.sum_subtype_domain_index hl₁).trans hl₂)
exact (finsupp.subtype_domain_eq_zero_iff hl₁).1 this
intros h l hl
{ intros h l hl, refine finsupp.emb_domain_eq_zero.1 (h (l.emb_domain $ function.embedding.subtype s) _ _), { suffices : ∀ i hi, ¬l ⟨i, hi⟩ = 0 → i ∈ s, by simpa, intros, assumption }, { rwa [finsupp.emb_domain_eq_map_domain, finsupp.sum_map_domain_index], exacts [λ _, zero_smul _ _, λ _ _ _, add_smul _ _ _] } }
refine finsupp.emb_domain_eq_zero.1 (h (l.emb_domain $ function.embedding.subtype s) _ _)
suffices : ∀ i hi, ¬l ⟨i, hi⟩ = 0 → i ∈ s
{ suffices : ∀ i hi, ¬l ⟨i, hi⟩ = 0 → i ∈ s, by simpa, intros, assumption }
simpa
simpa
intros
assumption
rwa [finsupp.emb_domain_eq_map_domain, finsupp.sum_map_domain_index]
{ rwa [finsupp.emb_domain_eq_map_domain, finsupp.sum_map_domain_index], exacts [λ _, zero_smul _ _, λ _ _ _, add_smul _ _ _] }
exacts [λ _, zero_smul _ _, λ _ _ _, add_smul _ _ _]
intros
intros i
let repr : (span R (range (v ∘ f)) : Type*) → ι' →₀ R := (hv.comp f f.injective).repr
let l := (repr ⟨v i, hss (mem_range_self i)⟩).map_domain f
have h_total_l : finsupp.total ι M R v l = v i
dsimp only [l]
{ dsimp only [l], rw finsupp.total_map_domain, rw (hv.comp f f.injective).total_repr, { refl }, { exact f.injective } }
rw finsupp.total_map_domain
rw (hv.comp f f.injective).total_repr
{ refl }
refl
{ exact f.injective }
exact f.injective
have h_total_eq : (finsupp.total ι M R v) l = (finsupp.total ι M R v) (finsupp.single i 1)
rw [h_total_l, finsupp.total_single, one_smul]
rw [h_total_l, finsupp.total_single, one_smul]
have l_eq : l = _ := linear_map.ker_eq_bot.1 hv h_total_eq
dsimp only [l] at l_eq
rw ←finsupp.emb_domain_eq_map_domain at l_eq
rcases finsupp.single_of_emb_domain_single (repr ⟨v i, _⟩) f i (1 : R) zero_ne_one.symm l_eq with ⟨i', hi'⟩
use i'
exact hi'.2
intros
ext i' k
rw [basis.to_matrix, matrix.update_column_apply, e.to_matrix_apply]
split_ifs
{ rw [h, update_same j x v] }
rw [h, update_same j x v]
{ rw update_noteq h }
rw update_noteq h
intros
by_cases i = j; simp [h, ← degree_eq_iff_nat_degree_eq_of_pos (nat.succ_pos 0)]
by_cases i = j
{ by_cases i = j; simp [h, ← degree_eq_iff_nat_degree_eq_of_pos (nat.succ_pos 0)], }
simp [h, ← degree_eq_iff_nat_degree_eq_of_pos (nat.succ_pos 0)]
simp [h, ← degree_eq_iff_nat_degree_eq_of_pos (nat.succ_pos 0)]
intros
rw [← det_transpose, det_zero_of_row_eq i_ne_j]
{ rw [← det_transpose, det_zero_of_row_eq i_ne_j], exact funext hij }
exact funext hij
intros
funext x
classical
rw [← dot_product_std_basis_one v x, ← dot_product_std_basis_one w x, h]
intros
induction k with k IH
{ simp }
simp
rw [pow_succ', mul_eq_mul, adjugate_mul_distrib, IH, ←mul_eq_mul, pow_succ]
{ rw [pow_succ', mul_eq_mul, adjugate_mul_distrib, IH, ←mul_eq_mul, pow_succ] }
intros
apply nat.decreasing_induction' _ hk
simp only [list_transvec_col, list.length_of_fn, matrix.one_mul, list.drop_eq_nil_of_le, list.prod_nil]
{ simp only [list_transvec_col, list.length_of_fn, matrix.one_mul, list.drop_eq_nil_of_le, list.prod_nil], }
assume n hn hk IH
{ assume n hn hk IH, have hn' : n < (list_transvec_col M).length, by simpa [list_transvec_col] using hn, rw ← list.cons_nth_le_drop_succ hn', simpa [list_transvec_col, matrix.mul_assoc] }
have hn' : n < (list_transvec_col M).length
simpa [list_transvec_col] using hn
simpa [list_transvec_col] using hn
rw ← list.cons_nth_le_drop_succ hn'
simpa [list_transvec_col, matrix.mul_assoc]
intros
{ ext m, simp }
ext m
simp
intros
ext ⟨x, y⟩
{ ext ⟨x, y⟩, simp only [and.left_comm, eq_comm, mem_map, prod.mk.inj_iff, inl_apply, mem_bot, exists_eq_left', mem_prod] }
simp only [and.left_comm, eq_comm, mem_map, prod.mk.inj_iff, inl_apply, mem_bot, exists_eq_left', mem_prod]
intros
{ simp only [polar, pi.neg_apply, sub_eq_add_neg, neg_add] }
simp only [polar, pi.neg_apply, sub_eq_add_neg, neg_add]
intros
simp only [ltensor, rtensor, ← map_comp, id_comp, comp_id]
intros
simp
intros
rw [or_comm, or_iff_left_iff_imp]
intros
{ ext, simp, }
ext
simp
intros
rw [apply_ite f, h, ite_not]
intros
simp [hs]
intros
rw [← hC, ← hD, generate_from_prod_eq h2C h2D]
intros
obtain ⟨i, hi₁, hi₂, hi₃, hμ, hν⟩ := s.to_jordan_decomposition_spec
simp only [jordan_decomposition.to_signed_measure, hμ, hν]
ext k hk
rw [to_signed_measure_sub_apply hk, to_measure_of_zero_le_apply _ hi₂ hi₁ hk, to_measure_of_le_zero_apply _ hi₃ hi₁.compl hk]
simp only [ennreal.coe_to_real, subtype.coe_mk, ennreal.some_eq_coe, sub_neg_eq_add]
rw [← of_union _ (measurable_set.inter hi₁ hk) (measurable_set.inter hi₁.compl hk), set.inter_comm i, set.inter_comm iᶜ, set.inter_union_compl _ _]
{ apply_instance }
apply_instance
rintro x ⟨⟨hx₁, _⟩, hx₂, _⟩
{ rintro x ⟨⟨hx₁, _⟩, hx₂, _⟩, exact false.elim (hx₂ hx₁) }
exact false.elim (hx₂ hx₁)
intros
set f' := hfi.1.mk f
have hadd' : s = t + μ.with_densityᵥ f'
convert hadd using 2
{ convert hadd using 2, exact with_densityᵥ_eq.congr_ae hfi.1.ae_eq_mk.symm }
exact with_densityᵥ_eq.congr_ae hfi.1.ae_eq_mk.symm
haveI := have_lebesgue_decomposition_mk μ hfi.1.measurable_mk htμ hadd'
refine (integrable.ae_eq_of_with_densityᵥ_eq (integrable_rn_deriv _ _) hfi _).symm
rw [← add_right_inj t, ← hadd, eq_singular_part _ f htμ hadd, singular_part_add_with_density_rn_deriv_eq]
intros
refine integrable.sub _ _; { split, measurability, exact has_finite_integral_to_real_of_lintegral_ne_top (lintegral_rn_deriv_lt_top _ μ).ne }
refine integrable.sub _ _
{ split, measurability, exact has_finite_integral_to_real_of_lintegral_ne_top (lintegral_rn_deriv_lt_top _ μ).ne }
split
{ split, measurability, exact has_finite_integral_to_real_of_lintegral_ne_top (lintegral_rn_deriv_lt_top _ μ).ne }
measurability
exact has_finite_integral_to_real_of_lintegral_ne_top (lintegral_rn_deriv_lt_top _ μ).ne
intros
rw ← complete_space_coe_iff_is_complete
haveI : fact (m ≤ m0) := ⟨hm⟩
change complete_space (Lp_meas_subgroup F m p μ)
apply_instance
intros
simp_rw [integrable, and_iff_right hf, and_iff_right hf.norm, has_finite_integral_norm_iff]
intros
{ rw [norm_to_L1, lintegral_norm_eq_lintegral_edist] }
rw [norm_to_L1, lintegral_norm_eq_lintegral_edist]
intros
simp [mem_Lp_iff_snorm_lt_top, mem_ℒp, f.measurable.ae_measurable]
intros
simp [mem_ℒp, ae_measurable_indicator_iff hs, snorm_indicator_eq_snorm_restrict hs]
intros
simp [mem_ℒp, snorm_exponent_zero]
intros
rw support_eq
refine (measure_bUnion_finset_le _ _).trans_lt (ennreal.sum_lt_top_iff.mpr (λ y hy, _))
rw finset.mem_filter at hy
exact hf y hy.2
intros
by_cases hfm : ae_measurable f μ
rw integral_eq_lintegral_of_nonneg_ae hf hfm
{ rw integral_eq_lintegral_of_nonneg_ae hf hfm, exact to_real_nonneg }
exact to_real_nonneg
{ rw integral_non_ae_measurable hfm }
rw integral_non_ae_measurable hfm
intros
simp only [integral_const', real.volume_Ioc, ennreal.to_real_of_real', ← neg_sub b, max_zero_sub_eq_self]
intros
have hac := hab.trans hbc
simp only [interval_integral, ← add_sub_comm, sub_eq_zero]
rw ← integral_union
iterate 4 { rw ← integral_union }
rw ← integral_union
rw ← integral_union
rw ← integral_union
suffices : Ioc a b ∪ Ioc b c ∪ Ioc c a = Ioc b a ∪ Ioc c b ∪ Ioc a c
{ suffices : Ioc a b ∪ Ioc b c ∪ Ioc c a = Ioc b a ∪ Ioc c b ∪ Ioc a c, by rw this, rw [Ioc_union_Ioc_union_Ioc_cycle, union_right_comm, Ioc_union_Ioc_union_Ioc_cycle, min_left_comm, max_left_comm] }
rw this
rw this
rw [Ioc_union_Ioc_union_Ioc_cycle, union_right_comm, Ioc_union_Ioc_union_Ioc_cycle, min_left_comm, max_left_comm]
simp [*, measurable_set.union, measurable_set_Ioc, Ioc_disjoint_Ioc_same, Ioc_disjoint_Ioc_same.symm, hab.1, hab.2, hbc.1, hbc.2, hac.1, hac.2]
all_goals { simp [*, measurable_set.union, measurable_set_Ioc, Ioc_disjoint_Ioc_same, Ioc_disjoint_Ioc_same.symm, hab.1, hab.2, hbc.1, hbc.2, hac.1, hac.2] }
simp [*, measurable_set.union, measurable_set_Ioc, Ioc_disjoint_Ioc_same, Ioc_disjoint_Ioc_same.symm, hab.1, hab.2, hbc.1, hbc.2, hac.1, hac.2]
simp [*, measurable_set.union, measurable_set_Ioc, Ioc_disjoint_Ioc_same, Ioc_disjoint_Ioc_same.symm, hab.1, hab.2, hbc.1, hbc.2, hac.1, hac.2]
simp [*, measurable_set.union, measurable_set_Ioc, Ioc_disjoint_Ioc_same, Ioc_disjoint_Ioc_same.symm, hab.1, hab.2, hbc.1, hbc.2, hac.1, hac.2]
simp [*, measurable_set.union, measurable_set_Ioc, Ioc_disjoint_Ioc_same, Ioc_disjoint_Ioc_same.symm, hab.1, hab.2, hbc.1, hbc.2, hac.1, hac.2]
simp [*, measurable_set.union, measurable_set_Ioc, Ioc_disjoint_Ioc_same, Ioc_disjoint_Ioc_same.symm, hab.1, hab.2, hbc.1, hbc.2, hac.1, hac.2]
simp [*, measurable_set.union, measurable_set_Ioc, Ioc_disjoint_Ioc_same, Ioc_disjoint_Ioc_same.symm, hab.1, hab.2, hbc.1, hbc.2, hac.1, hac.2]
simp [*, measurable_set.union, measurable_set_Ioc, Ioc_disjoint_Ioc_same, Ioc_disjoint_Ioc_same.symm, hab.1, hab.2, hbc.1, hbc.2, hac.1, hac.2]
simp [*, measurable_set.union, measurable_set_Ioc, Ioc_disjoint_Ioc_same, Ioc_disjoint_Ioc_same.symm, hab.1, hab.2, hbc.1, hbc.2, hac.1, hac.2]
simp [*, measurable_set.union, measurable_set_Ioc, Ioc_disjoint_Ioc_same, Ioc_disjoint_Ioc_same.symm, hab.1, hab.2, hbc.1, hbc.2, hac.1, hac.2]
simp [*, measurable_set.union, measurable_set_Ioc, Ioc_disjoint_Ioc_same, Ioc_disjoint_Ioc_same.symm, hab.1, hab.2, hbc.1, hbc.2, hac.1, hac.2]
simp [*, measurable_set.union, measurable_set_Ioc, Ioc_disjoint_Ioc_same, Ioc_disjoint_Ioc_same.symm, hab.1, hab.2, hbc.1, hbc.2, hac.1, hac.2]
simp [*, measurable_set.union, measurable_set_Ioc, Ioc_disjoint_Ioc_same, Ioc_disjoint_Ioc_same.symm, hab.1, hab.2, hbc.1, hbc.2, hac.1, hac.2]
simp [*, measurable_set.union, measurable_set_Ioc, Ioc_disjoint_Ioc_same, Ioc_disjoint_Ioc_same.symm, hab.1, hab.2, hbc.1, hbc.2, hac.1, hac.2]
simp [*, measurable_set.union, measurable_set_Ioc, Ioc_disjoint_Ioc_same, Ioc_disjoint_Ioc_same.symm, hab.1, hab.2, hbc.1, hbc.2, hac.1, hac.2]
simp [*, measurable_set.union, measurable_set_Ioc, Ioc_disjoint_Ioc_same, Ioc_disjoint_Ioc_same.symm, hab.1, hab.2, hbc.1, hbc.2, hac.1, hac.2]
intros
refine absolutely_continuous.mk (λ s hs₁ hs₂, _)
rw with_density_apply _ hs₁
exact set_lintegral_measure_zero _ _ hs₂
intros
refine lintegral_mono _
intro a
rw ennreal.coe_le_coe
exact h a
intros
rw [measure.restrict_map hg hs, integral_map hg (hf.mono_measure _)]
exact measure.map_mono g measure.restrict_le_self
intros
simp [set_to_simple_func]
intros
rw set_to_fun_congr_ae hT (@indicator_const_Lp_coe_fn _ _ _ 1 _ _ _ _ hs hμs x _ _).symm
rw L1.set_to_fun_eq_set_to_L1 hT
exact L1.set_to_L1_indicator_const_Lp hT hs hμs x
intros
simp_rw [measurable_iff_comap_le, measurable_space.pi, measurable_space.comap_supr, measurable_space.comap_comp, function.comp, supr_le_iff]
intros
by_cases p; simp [h, hf, measurable_set.univ]
{ by_cases p; simp [h, hf, measurable_set.univ] }
by_cases p
simp [h, hf, measurable_set.univ]
simp [h, hf, measurable_set.univ]
intros
unfold index
rw [nat.Inf_def, nat.find_pos, mem_image]
rintro ⟨t, h1t, h2t⟩
{ rintro ⟨t, h1t, h2t⟩, rw [finset.card_eq_zero] at h2t, subst h2t, cases K.2.2 with g hg, show g ∈ (∅ : set G), convert h1t (interior_subset hg), symmetry, apply bUnion_empty }
rw [finset.card_eq_zero] at h2t
subst h2t
cases K.2.2 with g hg
show g ∈ (∅ : set G)
convert h1t (interior_subset hg)
symmetry
apply bUnion_empty
{ exact index_defined K.2.1 hV }
exact index_defined K.2.1 hV
intros
refine le_antisymm (le_pre.2 $ λ s hs, _) (le_trim _)
rw trim_eq_infi
refine (infi_le_of_le (closure s) $ infi_le_of_le subset_closure $ infi_le_of_le measurable_set_closure ((pre_le _).trans_eq (hcl _)))
rwa diam_closure
intros
rw [← pi_univ_Icc, volume_pi_pi]
{ simp only [real.volume_Icc] }
simp only [real.volume_Icc]
intros
simp [volume_val]
intros
by_cases hs : s.finite
{ simp [set.infinite, hs, count_apply_finite] }
simp [set.infinite, hs, count_apply_finite]
change s.infinite at hs
{ change s.infinite at hs, simp [hs, count_apply_infinite] }
simp [hs, count_apply_infinite]
intros
simp_rw [measure.trim]
{ simp_rw [measure.trim], exact (@le_to_measure_apply _ m _ _ _), }
exact (@le_to_measure_apply _ m _ _ _)
intros
rw [← μ₂.trimmed, outer_measure.le_trim_iff]; refl
rw [← μ₂.trimmed, outer_measure.le_trim_iff]
refl
intros
rw [add_comm, restrict_add_restrict_compl hs]
intros
{ convert m.union _ _, rw inter_union_diff t s }
convert m.union _ _
rw inter_union_diff t s
intros
rcases t.eq_empty_or_nonempty with rfl|ht
rcases h with ⟨μ, hμ⟩
{ rcases h with ⟨μ, hμ⟩, rw [eq_false_intro empty_not_nonempty, supr_false, eq_comm], simp_rw [empty'], apply bot_unique, refine infi_le_of_le μ (infi_le _ hμ) }
rw [eq_false_intro empty_not_nonempty, supr_false, eq_comm]
simp_rw [empty']
apply bot_unique
refine infi_le_of_le μ (infi_le _ hμ)
{ simp [ht, Inf_gen_def] }
simp [ht, Inf_gen_def]
intros
erw [to_measure_of_zero_le_apply]
{ simp }
simp
{ assumption }
assumption
intros
have hfi := integrable_to_real_of_lintegral_ne_top hfm hf
ext i hi
rw [with_densityᵥ_apply hfi hi, to_signed_measure_apply_measurable hi, with_density_apply _ hi, integral_to_real hfm.restrict]
refine ae_lt_top' hfm.restrict (ne_top_of_le_ne_top hf _)
conv_rhs { rw ← set_lintegral_univ }
exact lintegral_mono_set (set.subset_univ _)
intros
simp only [pmf.bind_pure, pmf.bind_on_support_eq_bind]
intros
ext x
cases x; simp [nat.succ_ne_zero]
cases x
simp [nat.succ_ne_zero]
simp [nat.succ_ne_zero]
intros
simp [h.proper_divisors]
intros
rintros ⟨⟨a, b, bN0, cop⟩, rfl⟩
change (liouville (a / b)) at h
rcases h (b + 1) with ⟨p, q, q1, a0, a1⟩
have qR0 : (0 : ℝ) < q := int.cast_pos.mpr (zero_lt_one.trans q1)
have b0 : (b : ℝ) ≠ 0 := ne_of_gt (nat.cast_pos.mpr bN0)
have bq0 : (0 : ℝ) < b * q := mul_pos (nat.cast_pos.mpr bN0) qR0
replace a1 : abs (a * q - b * p) * q ^ (b + 1) < b * q
rwa [div_sub_div _ _ b0 (ne_of_gt qR0), abs_div, div_lt_div_iff (abs_pos.mpr (ne_of_gt bq0)) (pow_pos qR0 _), abs_of_pos bq0, one_mul, ← int.cast_pow, ← int.cast_mul, ← int.cast_coe_nat, ← int.cast_mul, ← int.cast_mul, ← int.cast_sub, ← int.cast_abs, ← int.cast_mul, int.cast_lt] at a1
rwa [div_sub_div _ _ b0 (ne_of_gt qR0), abs_div, div_lt_div_iff (abs_pos.mpr (ne_of_gt bq0)) (pow_pos qR0 _), abs_of_pos bq0, one_mul, ← int.cast_pow, ← int.cast_mul, ← int.cast_coe_nat, ← int.cast_mul, ← int.cast_mul, ← int.cast_sub, ← int.cast_abs, ← int.cast_mul, int.cast_lt] at a1
replace a0 : ¬a * q - ↑b * p = 0
rwa [ne.def, div_eq_div_iff b0 (ne_of_gt qR0), mul_comm ↑p, ← sub_eq_zero, ← int.cast_coe_nat, ← int.cast_mul, ← int.cast_mul, ← int.cast_sub, int.cast_eq_zero] at a0
rwa [ne.def, div_eq_div_iff b0 (ne_of_gt qR0), mul_comm ↑p, ← sub_eq_zero, ← int.cast_coe_nat, ← int.cast_mul, ← int.cast_mul, ← int.cast_sub, int.cast_eq_zero] at a0
lift q to ℕ using (zero_lt_one.trans q1).le
have ap : 0 < abs (a * ↑q - ↑b * p) := abs_pos.mpr a0
lift (abs (a * ↑q - ↑b * p)) to ℕ using (abs_nonneg (a * ↑q - ↑b * p))
rw [← int.coe_nat_mul, ← int.coe_nat_pow, ← int.coe_nat_mul, int.coe_nat_lt] at a1
exact not_le.mpr a1 (nat.mul_lt_mul_pow_succ (int.coe_nat_pos.mp ap) (int.coe_nat_lt.mp q1)).le
intros
cases ω_pow_formula p' h with k w
rw [mersenne_coe_X] at w
simpa using w
intros
convert padic.norm_eq_pow_val _
contrapose! hx
exact subtype.val_injective hx
intros
have n_nonzero : (n : ℚ) ≠ 0
simpa only [cast_eq_zero, ne.def]
simpa only [cast_eq_zero, ne.def]
simpa only [ int.coe_nat_multiplicity p n, rat.coe_nat_denom n, (padic_val_rat_of_nat p n).symm, int.coe_nat_zero, int.coe_nat_inj', sub_zero, get_one_right, int.coe_nat_succ, zero_add, rat.coe_nat_num ] using padic_val_rat_def p n_nonzero
intros
by_cases hz : 0 < z
exact h.is_primitive_classified_of_coprime_of_pos hc hz
{ exact h.is_primitive_classified_of_coprime_of_pos hc hz }
have h' : pythagorean_triple x y (-z)
{ simpa [pythagorean_triple, neg_mul_neg] using h.eq, }
simpa [pythagorean_triple, neg_mul_neg] using h.eq
apply h'.is_primitive_classified_of_coprime_of_pos hc
apply lt_of_le_of_ne _ (h'.ne_zero_of_coprime hc).symm
exact le_neg.mp (not_lt.mp hz)
intros
split
rintro ⟨x, rfl⟩
{ rintro ⟨x, rfl⟩, simp only [add_zero, coe_int_re, zero_mul, mul_im, dvd_mul_right, and_self, mul_re, mul_zero, coe_int_im] }
simp only [add_zero, coe_int_re, zero_mul, mul_im, dvd_mul_right, and_self, mul_re, mul_zero, coe_int_im]
rintro ⟨⟨r, hr⟩, ⟨i, hi⟩⟩
{ rintro ⟨⟨r, hr⟩, ⟨i, hi⟩⟩, use ⟨r, i⟩, rw [smul_val, ext], exact ⟨hr, hi⟩ }
use ⟨r, i⟩
rw [smul_val, ext]
exact ⟨hr, hi⟩
intros
rw [←inf_inf_sdiff, inf_idem, inf_of_le_right (@sdiff_le _ x x _)]
intros
rw [disjoint_iff, h.eq_bot_of_le (inf_le_left.trans hle)]
intros
casesI is_empty_or_nonempty ι
{ rw [supr_of_empty', supr_of_empty'] }
rw [supr_of_empty', supr_of_empty']
{ exact csupr_le (λ x, le_csupr_of_le B x (H x)) }
exact csupr_le (λ x, le_csupr_of_le B x (H x))
intros
apply h.tendsto_at_top_at_top
intro b
rcases not_bdd_above_iff.1 H b with ⟨_, ⟨N, rfl⟩, hN⟩
exact ⟨N, le_of_lt hN⟩
intros
simpa only [mul_comm] using hf.const_mul_at_bot hr
intros
{ ext U, simp [h.mem_iff, is_basis.mem_filter_iff] }
ext U
simp [h.mem_iff, is_basis.mem_filter_iff]
intros
simp
intros
rw [filter.map_map, H, ← filter.map_map]
intros
simp only [filter.Coprod, supr_ne_bot, ← exists_and_distrib_left, ← comap_eval_ne_bot_iff']
intros
simp only [filter.lift', filter.lift, (∘), ← inf_principal, infi_subtype', ← infi_inf]
intros
intros a b; rw [gc2, gc1]
intros a b
rw [gc2, gc1]
intros
refine ⟨x ⊓ i, I.mem_of_le inf_le_right hi, x ⊓ j, J.mem_of_le inf_le_right hj, _⟩
calc x = x ⊓ (i ⊔ j) : left_eq_inf.mpr hx ... = (x ⊓ i) ⊔ (x ⊓ j) : inf_sup_left
intros
simpa only [limsup_eq, eventually_const] using cInf_Ici
intros
simp only [supr, hf.map_Sup', ← range_comp]
intros
simp only [(Δ), sup_comm]
intros
rw ← image_mul_prod
exact (is_pwo.prod hs ht).image_of_monotone (λ _ _ h, mul_le_mul' h.1 h.2)
intros
intros t1 t2 ht1 ht2
cases (set.mem_union _ _ _).mp ht1 with ht1₁ ht1₂
{ exact h₁ t1 t2 ht1₁ ht2, }
exact h₁ t1 t2 ht1₁ ht2
{ exact h₂ t1 t2 ht1₂ ht2, }
exact h₂ t1 t2 ht1₂ ht2
intros
have : (x⁻¹ : L) = aeval x (div_X p) / (aeval x p - algebra_map _ _ (p.coeff 0))
rw [aeval_eq, subalgebra.coe_zero, zero_sub, div_neg]
{ rw [aeval_eq, subalgebra.coe_zero, zero_sub, div_neg], convert inv_eq_of_root_of_coeff_zero_ne_zero _ coeff_zero_ne, { rw subalgebra.aeval_coe }, { simpa using aeval_eq } }
convert inv_eq_of_root_of_coeff_zero_ne_zero _ coeff_zero_ne
{ rw subalgebra.aeval_coe }
rw subalgebra.aeval_coe
{ simpa using aeval_eq }
simpa using aeval_eq
rw [this, div_eq_mul_inv, aeval_eq, subalgebra.coe_zero, zero_sub, ← ring_hom.map_neg, ← ring_hom.map_inv]
exact A.mul_mem (aeval x p.div_X).2 (A.algebra_map_mem _)
intros
{ rw mul_comm at H, exact H.of_mul_left_left }
rw mul_comm at H
exact H.of_mul_left_left
intros
refine ⟨hP, mt ideal.is_unit_iff.mp h.ne_top, λ I J hIJ, _⟩
simpa only [ideal.dvd_iff_le] using (h.mul_le.mp (ideal.le_of_dvd hIJ))
intros
obtain ⟨equiv⟩ := @fintype.trunc_equiv_fin ι (classical.dec_eq ι) _
replace equiv := mv_polynomial.rename_equiv R equiv
refine ⟨_, alg_equiv.to_alg_hom equiv.symm, _⟩
split
{ exact (alg_equiv.symm equiv).surjective }
exact (alg_equiv.symm equiv).surjective
suffices hinj : function.injective equiv.symm.to_alg_hom.to_ring_hom
rw [(ring_hom.injective_iff_ker_eq_bot _).1 hinj]
{ rw [(ring_hom.injective_iff_ker_eq_bot _).1 hinj], exact submodule.fg_bot }
exact submodule.fg_bot
exact (alg_equiv.symm equiv).injective
intros
convert mul_left_mono I hI
exact (mul_one I).symm
intros
simpa only [←injective_iff_ker_eq_bot] using f.injective
intros
cases (nat_abs_eq a) with h
{ use [1, is_unit_one], rw [← h, one_mul], }
use [1, is_unit_one]
rw [← h, one_mul]
use [-1, is_unit_one.neg]
{ use [-1, is_unit_one.neg], rw [ ← neg_eq_iff_neg_eq.mp (eq.symm h)], simp only [neg_mul_eq_neg_mul_symm, one_mul] }
rw [ ← neg_eq_iff_neg_eq.mp (eq.symm h)]
simp only [neg_mul_eq_neg_mul_symm, one_mul]
intros
{ rw [pow_dvd_iff_le_multiplicity, not_le] }
rw [pow_dvd_iff_le_multiplicity, not_le]
intros
split
split; assume h
unfreezingI { split; assume h }
assume h
exact is_noetherian_of_linear_equiv (linear_equiv.of_top (⊤ : submodule R M) rfl)
{ exact is_noetherian_of_linear_equiv (linear_equiv.of_top (⊤ : submodule R M) rfl) }
assume h
exact is_noetherian_of_linear_equiv (linear_equiv.of_top (⊤ : submodule R M) rfl).symm
{ exact is_noetherian_of_linear_equiv (linear_equiv.of_top (⊤ : submodule R M) rfl).symm }
intros
{ simp only [U], ring, }
simp only [U]
ring
intros
classical
suffices h : ∀ (n : ℕ) (p q : polynomial R), ((p * q).degree < n) → (p * q).content = p.content * q.content
apply h
{ apply h, apply (lt_of_le_of_lt degree_le_nat_degree (with_bot.coe_lt_coe.2 (nat.lt_succ_self _))) }
apply (lt_of_le_of_lt degree_le_nat_degree (with_bot.coe_lt_coe.2 (nat.lt_succ_self _)))
intro n
induction n with n ih
intros p q hpq
{ intros p q hpq, rw [with_bot.coe_zero, nat.with_bot.lt_zero_iff, degree_eq_bot, mul_eq_zero] at hpq, rcases hpq with rfl | rfl; simp }
rw [with_bot.coe_zero, nat.with_bot.lt_zero_iff, degree_eq_bot, mul_eq_zero] at hpq
rcases hpq with rfl | rfl; simp
rcases hpq with rfl | rfl
simp
simp
intros p q hpq
by_cases p0 : p = 0
simp [p0]
{ simp [p0] }
by_cases q0 : q = 0
simp [q0]
{ simp [q0] }
rw [degree_eq_nat_degree (mul_ne_zero p0 q0), with_bot.coe_lt_coe, nat.lt_succ_iff_lt_or_eq, ← with_bot.coe_lt_coe, ← degree_eq_nat_degree (mul_ne_zero p0 q0), nat_degree_mul p0 q0] at hpq
rcases hpq with hlt | heq
apply ih _ _ hlt
{ apply ih _ _ hlt }
rw [← p.nat_degree_prim_part, ← q.nat_degree_prim_part, ← with_bot.coe_eq_coe, with_bot.coe_add, ← degree_eq_nat_degree p.prim_part_ne_zero, ← degree_eq_nat_degree q.prim_part_ne_zero] at heq
rw [p.eq_C_content_mul_prim_part, q.eq_C_content_mul_prim_part]
suffices h : (q.prim_part * p.prim_part).content = 1
rw [mul_assoc, content_C_mul, content_C_mul, mul_comm p.prim_part, mul_assoc, content_C_mul, content_C_mul, h, mul_one, content_prim_part, content_prim_part, mul_one, mul_one]
{ rw [mul_assoc, content_C_mul, content_C_mul, mul_comm p.prim_part, mul_assoc, content_C_mul, content_C_mul, h, mul_one, content_prim_part, content_prim_part, mul_one, mul_one] }
rw [← normalize_content, normalize_eq_one, is_unit_iff_dvd_one, content_eq_gcd_leading_coeff_content_erase_lead, leading_coeff_mul, gcd_comm]
apply (gcd_mul_dvd_mul_gcd _ _ _).trans
rw [content_mul_aux, ih, content_prim_part, mul_one, gcd_comm, ← content_eq_gcd_leading_coeff_content_erase_lead, content_prim_part, one_mul, mul_comm q.prim_part, content_mul_aux, ih, content_prim_part, mul_one, gcd_comm, ← content_eq_gcd_leading_coeff_content_erase_lead, content_prim_part]
rw [← heq, degree_mul, with_bot.add_lt_add_iff_right]
{ rw [← heq, degree_mul, with_bot.add_lt_add_iff_right], { apply degree_erase_lt p.prim_part_ne_zero }, { rw [ne.def, degree_eq_bot], apply q.prim_part_ne_zero } }
{ apply degree_erase_lt p.prim_part_ne_zero }
apply degree_erase_lt p.prim_part_ne_zero
rw [ne.def, degree_eq_bot]
{ rw [ne.def, degree_eq_bot], apply q.prim_part_ne_zero }
apply q.prim_part_ne_zero
rw [mul_comm, ← heq, degree_mul, with_bot.add_lt_add_iff_left]
{ rw [mul_comm, ← heq, degree_mul, with_bot.add_lt_add_iff_left], { apply degree_erase_lt q.prim_part_ne_zero }, { rw [ne.def, degree_eq_bot], apply p.prim_part_ne_zero } }
{ apply degree_erase_lt q.prim_part_ne_zero }
apply degree_erase_lt q.prim_part_ne_zero
rw [ne.def, degree_eq_bot]
{ rw [ne.def, degree_eq_bot], apply p.prim_part_ne_zero }
apply p.prim_part_ne_zero
intros
rw ←map_cyclotomic_int
rw degree_map_eq_of_leading_coeff_ne_zero (int.cast_ring_hom R) _
cases n with k
{ cases n with k, { simp only [cyclotomic, degree_one, dif_pos, nat.totient_zero, with_top.coe_zero]}, rw [←degree_cyclotomic' (complex.is_primitive_root_exp k.succ (nat.succ_ne_zero k))], exact (int_cyclotomic_spec k.succ).2.1 }
simp only [cyclotomic, degree_one, dif_pos, nat.totient_zero, with_top.coe_zero]
{ simp only [cyclotomic, degree_one, dif_pos, nat.totient_zero, with_top.coe_zero]}
rw [←degree_cyclotomic' (complex.is_primitive_root_exp k.succ (nat.succ_ne_zero k))]
exact (int_cyclotomic_spec k.succ).2.1
simp only [(int_cyclotomic_spec n).right.right, ring_hom.eq_int_cast, monic.leading_coeff, int.cast_one, ne.def, not_false_iff, one_ne_zero]
intros
rw [← algebra_map_aeval, ← (algebra_map A B).map_zero] at hp
exact h hp
intros
convert pb.constr_pow_aeval hy X; rw aeval_X
{ convert pb.constr_pow_aeval hy X; rw aeval_X }
convert pb.constr_pow_aeval hy X
rw aeval_X
rw aeval_X
intros
convert rfl
intros
rw [coeff_zero_eq_constant_coeff]; refl
rw [coeff_zero_eq_constant_coeff]
intros
rw [← finset.val_eq_zero, ← multiset.subset_zero, ← nth_roots_zero (1 : R), primitive_roots]
simp only [finset.not_mem_empty, forall_const, forall_prop_of_false, multiset.to_finset_zero, finset.filter_true_of_mem, finset.empty_val, not_false_iff, multiset.zero_subset, nth_roots_zero]
intros
simp [← submonoid.subsemiring_closure_to_add_submonoid, submonoid.subsemiring_closure_eq_closure]
intros
haveI : finite_dimensional L F := finite_dimensional.right K L F
haveI : is_separable L F := is_separable_tower_top_of_is_separable K L F
letI : fintype (L →ₐ[K] E) := power_basis.alg_hom.fintype pb
letI : ∀ (f : L →ₐ[K] E), fintype (@@alg_hom L F E _ _ _ _ f.to_ring_hom.to_algebra) := _
rw [fintype.sum_equiv alg_hom_equiv_sigma (λ (σ : F →ₐ[K] E), _) (λ σ, σ.1 pb.gen), ← finset.univ_sigma_univ, finset.sum_sigma, ← finset.sum_nsmul]
refine finset.sum_congr rfl (λ σ _, _)
letI : algebra L E := σ.to_ring_hom.to_algebra
{ letI : algebra L E := σ.to_ring_hom.to_algebra, simp only [finset.sum_const, finset.card_univ], rw alg_hom.card L F E }
simp only [finset.sum_const, finset.card_univ]
rw alg_hom.card L F E
intros σ
{ intros σ, simp only [alg_hom_equiv_sigma, equiv.coe_fn_mk, alg_hom.restrict_domain, alg_hom.comp_apply, is_scalar_tower.coe_to_alg_hom'] }
simp only [alg_hom_equiv_sigma, equiv.coe_fn_mk, alg_hom.restrict_domain, alg_hom.comp_apply, is_scalar_tower.coe_to_alg_hom']
intros
haveI := classical.dec_eq α
refine multiset.induction_on f (λ h, (ha.not_unit (associated_one_iff_is_unit.1 (associated.symm h))).elim) _ pfa.2 pfa.1
rintros p s _ ⟨u, hu⟩ hs
use p
have hs0 : s = 0
by_contra hs0
{ by_contra hs0, obtain ⟨q, hq⟩ := multiset.exists_mem_of_ne_zero hs0, apply (hs q (by simp [hq])).2.1, refine (ha.is_unit_or_is_unit (_ : _ = ((p * ↑u) * (s.erase q).prod) * _)).resolve_left _, { rw [mul_right_comm _ _ q, mul_assoc, ← multiset.prod_cons, multiset.cons_erase hq, ← hu, mul_comm, mul_comm p _, mul_assoc], simp, }, apply mt is_unit_of_mul_is_unit_left (mt is_unit_of_mul_is_unit_left _), apply (hs p (multiset.mem_cons_self _ _)).2.1 }
obtain ⟨q, hq⟩ := multiset.exists_mem_of_ne_zero hs0
apply (hs q (by simp [hq])).2.1
refine (ha.is_unit_or_is_unit (_ : _ = ((p * ↑u) * (s.erase q).prod) * _)).resolve_left _
rw [mul_right_comm _ _ q, mul_assoc, ← multiset.prod_cons, multiset.cons_erase hq, ← hu, mul_comm, mul_comm p _, mul_assoc]
{ rw [mul_right_comm _ _ q, mul_assoc, ← multiset.prod_cons, multiset.cons_erase hq, ← hu, mul_comm, mul_comm p _, mul_assoc], simp, }
simp
apply mt is_unit_of_mul_is_unit_left (mt is_unit_of_mul_is_unit_left _)
apply (hs p (multiset.mem_cons_self _ _)).2.1
simp only [mul_one, multiset.prod_cons, multiset.prod_zero, hs0] at *
exact ⟨associated.symm ⟨u, hu⟩, rfl⟩
intros
simp [factors', multiset.map_pmap, multiset.pmap_eq_map]
intros
{ rw [comap_supp, ← ideal.map_le_iff_le_comap], simp }
rw [comap_supp, ← ideal.map_le_iff_le_comap]
simp
intros
apply mv_polynomial.map_injective (int.cast_ring_hom ℚ) int.cast_injective
simp only [witt_zero, witt_structure_rat, bind₁, aeval_zero', constant_coeff_X_in_terms_of_W, ring_hom.map_zero, alg_hom.map_zero, map_witt_structure_int]
intros
delta frobenius_poly_rat
rw [← bind₁_bind₁, bind₁_X_in_terms_of_W_witt_polynomial, bind₁_X_right]
intros
obtain ⟨φ, hf⟩ := hf
unfreezingI {obtain ⟨φ, hf⟩ := hf}
ext n
simp only [map_coeff, hf, map_aeval]
apply eval₂_hom_congr (ring_hom.ext_int _ _) _ rfl
simp only [map_coeff]
intros
show coeff i (truncate_fun _ 0 : truncated_witt_vector p n R) = 0
rw [coeff_truncate_fun, witt_vector.zero_coeff]
intros
rw [← map_witt_polynomial p (int.cast_ring_hom R), ← witt_polynomial_vars p ℤ]
apply vars_map
intros
rw [← typein_lt_typein r, typein_enum, typein_enum]
intros
induction h with _ e n a eb b h₁ h₂ h₃ _ IH
induction h with _ e n a eb b h₁ h₂ h₃ _ IH; constructor
constructor
constructor
exacts [h₁, h₂, lt_of_lt_of_le h₃ bb]
intros
induction n with n hn
{ exact numeric_one }
exact numeric_one
split
{ split, { rintro ⟨ ⟩ ⟨ ⟩, dsimp only [pi.zero_apply], rw ← pow_half_move_left' n, apply hn.move_left_lt }, { exact ⟨λ _, numeric_zero, λ _, hn⟩ } }
rintro ⟨ ⟩ ⟨ ⟩
{ rintro ⟨ ⟩ ⟨ ⟩, dsimp only [pi.zero_apply], rw ← pow_half_move_left' n, apply hn.move_left_lt }
dsimp only [pi.zero_apply]
rw ← pow_half_move_left' n
apply hn.move_left_lt
{ exact ⟨λ _, numeric_zero, λ _, hn⟩ }
exact ⟨λ _, numeric_zero, λ _, hn⟩
intros
simp [h.symm, termg, add_assoc]
intros
by_cases h : c; simp [h]
by_cases h : c
simp [h]
simp [h]
intros
rw [mul_symdiv_eq, sub_sub_cancel]
intros
simp [h₁.symm, h₂.symm, horner, mul_pow, pow_mul]
intros
simp
intros
simp only [has_basis_nhds_infty.ge_iff, and_imp]
intros
ext x
apply completion.induction_on x
apply is_closed_eq ((0 : α →+ β).continuous_completion continuous_const)
{ apply is_closed_eq ((0 : α →+ β).continuous_completion continuous_const), simp [continuous_const] }
simp [continuous_const]
intro a
{ intro a, simp [(0 : α →+ β).completion_coe continuous_const, coe_zero] }
simp [(0 : α →+ β).completion_coe continuous_const, coe_zero]
intros
simp_rw ← nat.sum_antidiagonal_eq_sum_range_succ (λ k l, f k * g l)
exact summable_sum_mul_antidiagonal_of_summable_mul h
intros
rw [e.symm.image_eq_preimage, e.symm_symm]
intros
induction n with n ihn
{ ext, simp }
ext
simp
rw [pow_succ, ihn, mul_def, smul_right_comp, smul_eq_mul, pow_succ']
{ rw [pow_succ, ihn, mul_def, smul_right_comp, smul_eq_mul, pow_succ'] }
intros
{ conv in (_ + _) { rw add_comm }, exact hg.add_at_top hf }
conv in (_ + _) { rw add_comm }
exact hg.add_at_top hf
intros
apply subset.antisymm
exact closure_minimal Ioc_subset_Icc_self is_closed_Icc
{ exact closure_minimal Ioc_subset_Icc_self is_closed_Icc }
apply subset.trans _ (closure_mono Ioo_subset_Ioc_self)
{ apply subset.trans _ (closure_mono Ioo_subset_Ioc_self), rw closure_Ioo hab }
rw closure_Ioo hab
intros
simp [lt_iff_not_ge, -not_le]; exact (is_closed_le hg hf).is_open_compl
simp [lt_iff_not_ge, -not_le]
exact (is_closed_le hg hf).is_open_compl
intros
rw [← nhds_within_union, Iic_union_Ici, nhds_within_univ]
intros
{ simp only [min_def], exact hf.if_le hg hf hg (λ x, id) }
simp only [min_def]
exact hf.if_le hg hf hg (λ x, id)
intros
{ ext, rw h }
ext
rw h
intros
simp only [← ne_empty_iff_nonempty, ne.def, closure_empty_iff]
intros
simp only [cluster_pt_principal_iff, frequently_iff, set.nonempty, exists_prop, mem_inter_iff]
intros
simpa only [dense_range, prod_range_range_eq] using hf.prod hg
intros
{ rw ←set.image_univ, exact is_open_map_sigma_mk _ is_open_univ }
rw ←set.image_univ
exact is_open_map_sigma_mk _ is_open_univ
intros
rw [nhds_within_restrict' t hs, nhds_within_restrict' u hs, h₂]
intros
rw [continuous_on, continuous_iff_continuous_at]
split
rintros h ⟨x, xs⟩
{ rintros h ⟨x, xs⟩, exact (continuous_within_at_iff_continuous_at_restrict f xs).mp (h x xs) }
exact (continuous_within_at_iff_continuous_at_restrict f xs).mp (h x xs)
intros h x xs
exact (continuous_within_at_iff_continuous_at_restrict f xs).mpr (h ⟨x, xs⟩)
intros
rw [nhds_within, map_inf hf.inj, hf.map_nhds_eq, map_principal, ← nhds_within_inter', inter_eq_self_of_subset_right (image_subset_range _ _)]
intros
refine continuous_snd.comp (e₂.to_local_homeomorph.continuous_on.comp_continuous (e₁.to_local_homeomorph.continuous_on_symm.comp_continuous _ _) _)
{ exact continuous_const.prod_mk continuous_id }
exact continuous_const.prod_mk continuous_id
{ exact λ x, e₁.mem_target.2 h₁ }
exact λ x, e₁.mem_target.2 h₁
intro x
{ intro x, rwa [e₂.mem_source, e₁.proj_symm_apply' h₁] }
rwa [e₂.mem_source, e₁.proj_symm_apply' h₁]
intros
rw [tendsto_nhds_top_iff_nnreal, at_top_basis_Ioi.tendsto_right_iff]
rw [tendsto_nhds_top_iff_nnreal, at_top_basis_Ioi.tendsto_right_iff]; [simp, apply_instance, apply_instance]
simp
apply_instance
apply_instance
intros
have A : ∀ (a : α), (f a : ℝ) ≤ g a := λ a, nnreal.coe_le_coe.2 (h a)
have : (sf : ℝ) < sg := has_sum_lt A (nnreal.coe_lt_coe.2 hi) (has_sum_coe.2 hf) (has_sum_coe.2 hg)
exact nnreal.coe_lt_coe.1 this
intros
simpa only [continuous_at, e.left_inv hx] using e.continuous_at_symm (e.map_source hx)
intros
rw [continuous_iff_coinduced_le, continuous_iff_coinduced_le, hf.right, coinduced_compose]
intros
refine ((uniformity_basis_edist.comap _).le_basis_iff uniformity_basis_edist).2 (λ ε h₀, _)
refine ⟨K⁻¹ * ε, ennreal.mul_pos (ennreal.inv_ne_zero.2 ennreal.coe_ne_top) h₀.ne', _⟩
refine λ x hx, (hf x.1 x.2).trans_lt _
rw [mul_comm, ← div_eq_mul_inv] at hx
rw mul_comm
exact ennreal.mul_lt_of_lt_div hx
intros
simp [real.dist_eq]
intros
simp only [← metric.Union_ball_nat_succ (0 : ι → ℝ), dimH_Union, dimH_ball_pi _ (nat.cast_add_one_pos _), supr_const]
intros
simp [inf_dist, inf_edist, dist_edist]
intros
simpa only [real.to_nnreal_coe] using lipschitz_with.of_le_add_mul' K h
intros
ext x
rw cast_coe
have : ↑x ∈ (Icc 0 1 : set ℝ) := x.2
rw [truncate, coe_mk, max_eq_left this.1, min_eq_left this.2, extend_extends']
intros
simp_rw [← lower_semicontinuous_within_at_univ_iff] at *
{ simp_rw [← lower_semicontinuous_within_at_univ_iff] at *, exact hf.add' hg hcont }
exact hf.add' hg hcont
intros
apply singletons_open_iff_discrete.mp
intros x
rw [← is_closed_compl_iff]
exact finite.is_closed (finite.of_fintype _)
intros
dsimp [pushforward_eq]
simp
intros
rw [uniformity_eq_uniformity_interior]; exact mem_lift' hs
rw [uniformity_eq_uniformity_interior]
exact mem_lift' hs
intros
assume p hp
refine (set_seq_aux hf U_mem N).2.snd ⟨_, _⟩
refine (set_seq_aux hf U_mem N).2.snd ⟨_, _⟩; apply set_seq_sub_aux
apply set_seq_sub_aux
exact set_seq_mono hf U_mem hm hp.1
apply set_seq_sub_aux
exact set_seq_mono hf U_mem hn hp.2
intros
assume u hu x hx
rcases h u hu x (h' hx) with ⟨t, ht, H⟩
exact ⟨t, nhds_within_mono x h' ht, H.mono (λ n, id)⟩
intros
rw [local_triv_at, mem_local_triv_source]
{ rw [local_triv_at, mem_local_triv_source], exact Z.mem_base_set_at b }
exact Z.mem_base_set_at b
intros
unfold even
rw corec_eq
refl
intros
cases v
reflexivity
intros
have h := int.add_le_add_left h b
rwa int.add_neg_cancel_left at h
intros
by_cases hba : b ≤ a
simp [le_antisymm hba h₁]
{ simp [le_antisymm hba h₁] }
by_cases hc0 : c ≤ 0
simp [le_antisymm hc0 h₂, int.zero_mul]
{ simp [le_antisymm hc0 h₂, int.zero_mul] }
exact (le_not_le_of_lt (int.mul_lt_mul_of_pos_left (lt_of_le_not_le h₁ hba) (lt_of_le_not_le h₂ hc0))).left
intros
induction s; simp [*]
induction s
simp [*]
simp [*]
intros
{ cases b, apply bit0_val, apply bit1_val }
cases b
apply bit0_val
apply bit1_val
intros
rw [H2, nat.mul_div_cancel _ H1]
intros
rw [mod_eq_sub_mod (le_refl _), nat.sub_self, zero_mod]
intros
tactic.mk_inj_eq
intros
{ ext, refl }
ext
refl
intros
{ intros φ₁ φ₂ H, cases φ₁, cases φ₂, congr, exact H }
intros φ₁ φ₂ H
cases φ₁
cases φ₂
congr
exact H
intros
apply prod_congr rfl (λ j hj, _)
have : j ≠ i
assume eq
assume eq
{ assume eq, rw eq at hj, exact h hj }
{ assume eq, rw eq at hj, exact h hj }
rw eq at hj
rw eq at hj
exact h hj
exact h hj
simp [this]
intros
{ simp_rw ←(ite_not (p _)), apply prod_ite_of_false, simpa }
simp_rw ←(ite_not (p _))
apply prod_ite_of_false
simpa
intros
rw [univ_filter_zero_lt, finset.prod_map, rel_embedding.coe_fn_to_embedding, coe_succ_embedding]
intros
simp
intros
ext x
change (F'.e ≫ F'.m) _ = _
rw [F'.fac, (classical.indefinite_description _ x.2).2]
refl
intros
induction n
simp
{ simp, }
rw [pow_succ', pow_mul, pow_mul, pow_mul, n_ih]
apply sub_pow_char_of_commute
apply commute.pow_pow h
intros
obtain ⟨ifp_n', stream_nth_eq', ifp_n_fract_ne_zero, int_fract_pair.of_eq_ifp_succ_n⟩ : ∃ ifp_n', int_fract_pair.stream q n = some ifp_n' ∧ ifp_n'.fr ≠ 0 ∧ int_fract_pair.of ifp_n'.fr⁻¹ = ifp_succ_n
from succ_nth_stream_eq_some_iff.elim_left stream_succ_nth_eq
have : ifp_n = ifp_n'
injection (eq.trans stream_nth_eq.symm stream_nth_eq')
injection (eq.trans stream_nth_eq.symm stream_nth_eq')
cases this
rw [←int_fract_pair.of_eq_ifp_succ_n]
cases (nth_stream_fr_nonneg_lt_one stream_nth_eq) with zero_le_ifp_n_fract ifp_n_fract_lt_one
have : 0 < ifp_n.fr
from (lt_of_le_of_ne zero_le_ifp_n_fract $ ifp_n_fract_ne_zero.symm)
exact (of_inv_fr_num_lt_num_of_pos this)
intros
{ rw mul_comm, exact mod_add_div _ _ }
rw mul_comm
exact mod_add_div _ _
intros
simpa only [gcd_comm a b] using gcd_eq_left_iff b a h
intros
{ subst hs, exact finset.fold_congr hfg }
subst hs
exact finset.fold_congr hfg
intros
simp only [sum_Ico_eq_sub _ hmn, (geom_sum_def _ _).symm, geom_sum_eq hx, div_sub_div_same, sub_sub_sub_cancel_right]
intros
rw [eq_comm, inv_eq_one]
intros
rw [sub_eq_add_neg, add_right_eq_self, neg_eq_zero]
intros
rw [← sub_add, add_sub_cancel']
intros
split_ifs; refl
split_ifs
refl
refl
intros
rcases neg_one_pow_eq_or R n; simp [h]
rcases neg_one_pow_eq_or R n
simp [h]
simp [h]
intros
haveI := invertible_of_pow_eq_one x n hx hn
exact is_unit_of_invertible x
intros
by_cases h : a = 0
{ rw [h, inv_zero, mul_zero] }
rw [h, inv_zero, mul_zero]
{ rw [inv_mul_cancel h, one_mul] }
rw [inv_mul_cancel h, one_mul]
intros
simpa only [one_div] using eq_inv_of_mul_right_eq_one h
intros
{ dsimp [augment], rcases i with _|i, refl, refl, }
dsimp [augment]
rcases i with _|i
refl
refl
intros
simp [h]
intros
dsimp [d_next, from_next]
rcases c.next i with ⟨⟩|⟨⟨i', w⟩⟩; { dsimp [d_next, from_next], simp }
rcases c.next i with ⟨⟩|⟨⟨i', w⟩⟩
{ dsimp [d_next, from_next], simp }
{ dsimp [d_next, from_next], simp }
dsimp [d_next, from_next]
simp
intros
refine (mul_indicator_congr $ λ x hx, _).trans mul_indicator_mul_support
have : f x = 1
from nmem_mul_support.1 (disjoint_right.1 h hx)
rw [pi.mul_apply, this, one_mul]
intros
simp [mul_right_iterate]
intros
ext x y
rcases x
rcases x; rcases y
rcases y
by_cases h : x = y; simp [Pso, indefinite_diagonal, h]
by_cases h : x = y
{ by_cases h : x = y; simp [Pso, indefinite_diagonal, h], }
simp [Pso, indefinite_diagonal, h]
simp [Pso, indefinite_diagonal, h]
{ simp [Pso, indefinite_diagonal], }
simp [Pso, indefinite_diagonal]
rcases y
{ simp [Pso, indefinite_diagonal], }
simp [Pso, indefinite_diagonal]
by_cases h : x = y; simp [Pso, indefinite_diagonal, h, hi]
by_cases h : x = y
{ by_cases h : x = y; simp [Pso, indefinite_diagonal, h, hi], }
simp [Pso, indefinite_diagonal, h, hi]
simp [Pso, indefinite_diagonal, h, hi]
intros
obtain ⟨n, hn⟩ := h
use n
exact linear_map.submodule_pow_eq_zero_of_pow_eq_zero (K.ad_comp_incl_eq x) hn
intros
simp [skew_adjoint_lie_subalgebra_equiv]
intros
rw [←neg_neg a, smul_neg, neg_neg_iff_pos, neg_neg_iff_pos]
exact smul_pos_iff_of_pos hc
intros
cases le_or_lt a 0 with ha ha
{ simp [ha, (inv_nonpos.2 ha).trans_lt zero_lt_one] }
simp [ha, (inv_nonpos.2 ha).trans_lt zero_lt_one]
simp only [ha.not_le, false_or, inv_lt_one_iff_of_pos ha]
{ simp only [ha.not_le, false_or, inv_lt_one_iff_of_pos ha] }
intros
rwa [le_one_div (@zero_lt_one α _ _) h1, one_div_one]
intros
rw [← mul_le_mul_iff_left b, mul_one, mul_inv_cancel_left]
intros
simp [div_eq_mul_inv]
intros
ext x
simp only [mem_smul_set, algebra.id.smul_eq_mul, mem_Ioi]
split
rintro ⟨a_w, a_h_left, rfl⟩
{ rintro ⟨a_w, a_h_left, rfl⟩, exact (mul_lt_mul_left hr).mpr a_h_left, }
exact (mul_lt_mul_left hr).mpr a_h_left
rintro h
{ rintro h, use x / r, split, exact (lt_div_iff' hr).mpr h, exact mul_div_cancel' _ (ne_of_gt hr), }
use x / r
split
exact (lt_div_iff' hr).mpr h
exact mul_div_cancel' _ (ne_of_gt hr)
intros
haveI := @linear_order.decidable_le α _
rcases lt_trichotomy 0 a with (ha|rfl|ha)
refine or.inl ⟨ha, lt_imp_lt_of_le_imp_le (λ hb, _) hab⟩
{ refine or.inl ⟨ha, lt_imp_lt_of_le_imp_le (λ hb, _) hab⟩, exact decidable.mul_nonpos_of_nonneg_of_nonpos ha.le hb }
exact decidable.mul_nonpos_of_nonneg_of_nonpos ha.le hb
{ rw [zero_mul] at hab, exact hab.false.elim }
rw [zero_mul] at hab
exact hab.false.elim
refine or.inr ⟨ha, lt_imp_lt_of_le_imp_le (λ hb, _) hab⟩
{ refine or.inr ⟨ha, lt_imp_lt_of_le_imp_le (λ hb, _) hab⟩, exact decidable.mul_nonpos_of_nonpos_of_nonneg ha.le hb }
exact decidable.mul_nonpos_of_nonpos_of_nonneg ha.le hb
intros
haveI := @linear_order.decidable_le α _; exact λ x y h, decidable.mul_lt_mul' (hf h.le) (hg h) (hg0 x) (hf0 y)
haveI := @linear_order.decidable_le α _
exact λ x y h, decidable.mul_lt_mul' (hf h.le) (hg h) (hg0 x) (hf0 y)
intros
simpa only [sub_eq_neg_add] using h (-x)
intros
simp [*, ← add_assoc] at *
intros
intro a
rw [mem_finset_prod, mem_finset_prod]
rintro ⟨g, hg, rfl⟩
exact ⟨g, λ i hi, hf hi $ hg hi, rfl⟩
intros
induction l with hd tl IH
{ simp }
simp
{ have hl' : ∀ (p ∈ tl), nat_degree p ≤ n := λ p hp, hl p (list.mem_cons_of_mem _ hp), simp only [list.prod_cons, list.map, list.length], rw [add_mul, one_mul, add_comm, ←IH hl', mul_comm tl.length], have h : nat_degree tl.prod ≤ n * tl.length, { refine (nat_degree_list_prod_le _).trans _, rw [←tl.length_map nat_degree, mul_comm], refine list.sum_le_of_forall_le _ _ _, simpa using hl' }, have hdn : nat_degree hd ≤ n := hl _ (list.mem_cons_self _ _), rcases hdn.eq_or_lt with rfl|hdn', { cases h.eq_or_lt with h' h', { rw [←h', coeff_mul_degree_add_degree, leading_coeff, leading_coeff] }, { rw [coeff_eq_zero_of_nat_degree_lt, coeff_eq_zero_of_nat_degree_lt h', mul_zero], exact nat_degree_mul_le.trans_lt (add_lt_add_left h' _) } }, { rw [coeff_eq_zero_of_nat_degree_lt hdn', coeff_eq_zero_of_nat_degree_lt, zero_mul], exact nat_degree_mul_le.trans_lt (add_lt_add_of_lt_of_le hdn' h) } }
have hl' : ∀ (p ∈ tl), nat_degree p ≤ n := λ p hp, hl p (list.mem_cons_of_mem _ hp)
simp only [list.prod_cons, list.map, list.length]
rw [add_mul, one_mul, add_comm, ←IH hl', mul_comm tl.length]
have h : nat_degree tl.prod ≤ n * tl.length
refine (nat_degree_list_prod_le _).trans _
{ refine (nat_degree_list_prod_le _).trans _, rw [←tl.length_map nat_degree, mul_comm], refine list.sum_le_of_forall_le _ _ _, simpa using hl' }
rw [←tl.length_map nat_degree, mul_comm]
refine list.sum_le_of_forall_le _ _ _
simpa using hl'
have hdn : nat_degree hd ≤ n := hl _ (list.mem_cons_self _ _)
rcases hdn.eq_or_lt with rfl|hdn'
cases h.eq_or_lt with h' h'
{ cases h.eq_or_lt with h' h', { rw [←h', coeff_mul_degree_add_degree, leading_coeff, leading_coeff] }, { rw [coeff_eq_zero_of_nat_degree_lt, coeff_eq_zero_of_nat_degree_lt h', mul_zero], exact nat_degree_mul_le.trans_lt (add_lt_add_left h' _) } }
{ rw [←h', coeff_mul_degree_add_degree, leading_coeff, leading_coeff] }
rw [←h', coeff_mul_degree_add_degree, leading_coeff, leading_coeff]
rw [coeff_eq_zero_of_nat_degree_lt, coeff_eq_zero_of_nat_degree_lt h', mul_zero]
{ rw [coeff_eq_zero_of_nat_degree_lt, coeff_eq_zero_of_nat_degree_lt h', mul_zero], exact nat_degree_mul_le.trans_lt (add_lt_add_left h' _) }
exact nat_degree_mul_le.trans_lt (add_lt_add_left h' _)
rw [coeff_eq_zero_of_nat_degree_lt hdn', coeff_eq_zero_of_nat_degree_lt, zero_mul]
{ rw [coeff_eq_zero_of_nat_degree_lt hdn', coeff_eq_zero_of_nat_degree_lt, zero_mul], exact nat_degree_mul_le.trans_lt (add_lt_add_of_lt_of_le hdn' h) }
exact nat_degree_mul_le.trans_lt (add_lt_add_of_lt_of_le hdn' h)
intros
rw [← smul_eval_smul, smul_inv_smul]
intros
rw [nontrivial_iff, not_iff_comm, zero_iff_subsingleton, subsingleton_iff]
push_neg
exact iff.rfl
intros
cases f; cases g; cases h; refl
cases f; cases g; cases h
cases f; cases g
cases f
cases g
cases h
refl
intros
split
intro h'
{ intro h', convert dvd_sub h' h, exact eq.symm (sub_sub_self b c) }
convert dvd_sub h' h
exact eq.symm (sub_sub_self b c)
intro h'
{ intro h', convert dvd_add h h', exact eq_add_of_sub_eq rfl }
convert dvd_add h h'
exact eq_add_of_sub_eq rfl
intros
induction h
{ exact rel.of (hr _ _ h_h) }
exact rel.of (hr _ _ h_h)
{ rw [star_add, star_add], exact rel.add_left h_ih, }
rw [star_add, star_add]
exact rel.add_left h_ih
{ rw [star_mul, star_mul], exact rel.mul_right h_ih, }
rw [star_mul, star_mul]
exact rel.mul_right h_ih
{ rw [star_mul, star_mul], exact rel.mul_left h_ih, }
rw [star_mul, star_mul]
exact rel.mul_left h_ih
intros
erw [comap_id_eq_map U V (eq_to_hom hUV.symm), eq_to_hom_op, eq_to_hom_map]
intros
simp [radius]
intros
{ unfold is_O, exact exists_congr (λ _, is_O_with_norm_left) }
unfold is_O
exact exists_congr (λ _, is_O_with_norm_left)
intros
unfold is_O_with at *
filter_upwards [h₁, h₂]
intros x hx₁ hx₂
apply le_trans (norm_mul_le _ _)
convert mul_le_mul hx₁ hx₂ (norm_nonneg _) (le_trans (norm_nonneg _) hx₁) using 1
rw normed_field.norm_mul
ac_refl
intros
simpa only [one_apply, one_smul, smul_right_apply, coe_comp', (∘)] using (hl.comp x hf.has_strict_fderiv_at).has_strict_deriv_at
intros
simpa using (hf.add hg).has_deriv_at_filter
intros
simp only [← fderiv_within_univ, fderiv_within_neg unique_diff_within_at_univ]
intros
{ convert hc.mul_const' d, ext z, apply mul_comm }
convert hc.mul_const' d
ext z
apply mul_comm
intros
simp only [has_fderiv_within_at, nhds_within_union]
exact hs.join ht
intros
apply mem_implicit_to_local_homeomorph_of_complemented_target
intros
rw [iterated_deriv_eq_iterated_fderiv, ← continuous_multilinear_map.map_smul_univ]
{ rw [iterated_deriv_eq_iterated_fderiv, ← continuous_multilinear_map.map_smul_univ], simp }
simp
intros
have hdg : ∀ᶠ x in at_top, differentiable_at ℝ g x
from hg'.mp (eventually_of_forall $ λ _ hg', classical.by_contradiction (λ h, hg' (deriv_zero_of_not_differentiable_at h)))
have hdf' : ∀ᶠ x in at_top, has_deriv_at f (deriv f x) x
from hdf.mp (eventually_of_forall $ λ _, differentiable_at.has_deriv_at)
have hdg' : ∀ᶠ x in at_top, has_deriv_at g (deriv g x) x
from hdg.mp (eventually_of_forall $ λ _, differentiable_at.has_deriv_at)
exact has_deriv_at.lhopital_zero_at_top hdf' hdg' hg' hftop hgtop hdiv
intros
rcases em (x = c) with rfl|hx
refine times_cont_diff_at.congr_of_eventually_eq _ f.eventually_eq_one
{ refine times_cont_diff_at.congr_of_eventually_eq _ f.eventually_eq_one, rw pi.one_def, exact times_cont_diff_at_const }
rw pi.one_def
exact times_cont_diff_at_const
exact real.smooth_transition.times_cont_diff_at.comp x (times_cont_diff_at.div_const $ times_cont_diff_at_const.sub $ times_cont_diff_at_id.dist times_cont_diff_at_const hx)
{ exact real.smooth_transition.times_cont_diff_at.comp x (times_cont_diff_at.div_const $ times_cont_diff_at_const.sub $ times_cont_diff_at_id.dist times_cont_diff_at_const hx) }
intros
rw [← has_fderiv_within_at_univ]
exact (has_ftaylor_series_up_to_on_univ_iff.2 h).has_fderiv_within_at hn (mem_univ _)
intros
split
assume H
{ assume H, have A : f = (f ∘ e) ∘ e.symm, by { ext y, simp only [function.comp_app], rw e.apply_symm_apply y }, have B : e.symm ⁻¹' (e ⁻¹' s) = s, by { rw [← preimage_comp, e.self_comp_symm], refl }, rw [A, ← B], exact H.comp_continuous_linear_map _}
have A : f = (f ∘ e) ∘ e.symm
ext y
ext y
{ ext y, simp only [function.comp_app], rw e.apply_symm_apply y }
{ ext y, simp only [function.comp_app], rw e.apply_symm_apply y }
simp only [function.comp_app]
simp only [function.comp_app]
rw e.apply_symm_apply y
rw e.apply_symm_apply y
have B : e.symm ⁻¹' (e ⁻¹' s) = s
rw [← preimage_comp, e.self_comp_symm]
rw [← preimage_comp, e.self_comp_symm]
{ rw [← preimage_comp, e.self_comp_symm], refl }
{ rw [← preimage_comp, e.self_comp_symm], refl }
refl
refl
rw [A, ← B]
exact H.comp_continuous_linear_map _
assume H
{ assume H, have : x = e (e.symm x), by simp, rw this at H, exact H.comp_continuous_linear_map _ }
have : x = e (e.symm x)
simp
simp
rw this at H
exact H.comp_continuous_linear_map _
intros
rw [← times_cont_diff_within_at_univ] at *; exact hf.smul hg
rw [← times_cont_diff_within_at_univ] at *
exact hf.smul hg
intros
refine ⟨λ H n, H n, _⟩
rintro H (_|n)
exacts [times_cont_diff_on_top.2 H, H n]
intros
obtain ⟨a, b, ha, hb, hab, hz⟩ := hz
by_cases ha' : a = 0
{ rw [ha', zero_add] at hab, rw [ha', hab, zero_smul, one_smul, zero_add] at hz, exact (hy hz).elim }
rw [ha', zero_add] at hab
rw [ha', hab, zero_smul, one_smul, zero_add] at hz
exact (hy hz).elim
by_cases hb' : b = 0
rw [hb', add_zero] at hab
{ rw [hb', add_zero] at hab, rw [hb', hab, zero_smul, one_smul, add_zero] at hz, exact (hx hz).elim }
rw [hb', hab, zero_smul, one_smul, add_zero] at hz
exact (hx hz).elim
exact ⟨a, b, ha.lt_of_ne (ne.symm ha'), hb.lt_of_ne (ne.symm hb'), hab, hz⟩
intros
split
intro h
{ intro h, rw [←set.subset_empty_iff, ←h], exact subset_convex_hull 𝕜 _ }
rw [←set.subset_empty_iff, ←h]
exact subset_convex_hull 𝕜 _
rintro rfl
{ rintro rfl, exact convex_hull_empty }
exact convex_hull_empty
intros
intros y hy
let I := { z | ∃ (u : ℝ), u ∈ Ioc (0 : ℝ) 1 ∧ z = y + u • (x - y) }
have hI : I ⊆ interior s
rintros z ⟨u, hu, rfl⟩
{ rintros z ⟨u, hu, rfl⟩, exact hs.add_smul_sub_mem_interior hy hx hu, }
exact hs.add_smul_sub_mem_interior hy hx hu
let z := homothety x t⁻¹ y
have hz₁ : z ∈ interior s
suffices : z ∈ I
{ suffices : z ∈ I, { exact hI this, }, use 1 - t⁻¹, split, { simp only [mem_Ioc, sub_le_self_iff, inv_nonneg, sub_pos, inv_lt_one ht, true_and], linarith, }, { simp only [z, homothety_apply, sub_smul, smul_sub, vsub_eq_sub, vadd_eq_add, one_smul], abel, }, }
exact hI this
{ exact hI this, }
use 1 - t⁻¹
split
simp only [mem_Ioc, sub_le_self_iff, inv_nonneg, sub_pos, inv_lt_one ht, true_and]
{ simp only [mem_Ioc, sub_le_self_iff, inv_nonneg, sub_pos, inv_lt_one ht, true_and], linarith, }
linarith
simp only [z, homothety_apply, sub_smul, smul_sub, vsub_eq_sub, vadd_eq_add, one_smul]
{ simp only [z, homothety_apply, sub_smul, smul_sub, vsub_eq_sub, vadd_eq_add, one_smul], abel, }
abel
have ht' : t ≠ 0
linarith
{ linarith, }
have hz₂ : y = homothety x t z
simp [z, ht', homothety_apply, smul_smul]
{ simp [z, ht', homothety_apply, smul_smul], }
rw hz₂
rw mem_interior at hz₁ ⊢
obtain ⟨U, hU₁, hU₂, hU₃⟩ := hz₁
exact ⟨image (homothety x t) U, image_subset ⇑(homothety x t) hU₁, homothety_is_open_map x t ht' U hU₂, mem_image_of_mem ⇑(homothety x t) hU₃⟩
intros
have := @abs_inner_div_norm_mul_norm_eq_one_iff ℝ F _ _ x y
simpa [coe_real_eq_id] using this
intros
rcases zorn.zorn_subset_nonempty {b | orthonormal 𝕜 (coe : b → E)} _ _ hs with ⟨b, bi, sb, h⟩
refine ⟨b, sb, bi, _⟩
{ refine ⟨b, sb, bi, _⟩, exact λ u hus hu, h u hu hus }
exact λ u hus hu, h u hu hus
refine λ c hc cc c0, ⟨⋃₀ c, _, _⟩
{ refine λ c hc cc c0, ⟨⋃₀ c, _, _⟩, { exact orthonormal_sUnion_of_directed cc.directed_on (λ x xc, hc xc) }, { exact λ _, set.subset_sUnion_of_mem } }
{ exact orthonormal_sUnion_of_directed cc.directed_on (λ x xc, hc xc) }
exact orthonormal_sUnion_of_directed cc.directed_on (λ x xc, hc xc)
{ exact λ _, set.subset_sUnion_of_mem }
exact λ _, set.subset_sUnion_of_mem
intros
change orthogonal_projection_fn K u = orthogonal_projection_fn K' u
congr
exact h
intros
rw [dist_eq_norm, vsub_sub_vsub_cancel_right, dist_eq_norm_vsub V]
intros
rw [dist_comm, dist_eq_norm]
intros
simpa only [sub_eq_add_neg] using dist_add_right _ _ _
intros
rw [mem_closed_ball, dist_eq_norm]
intros
refine (linear_map.fst 𝕜 E F).is_linear.with_bound 1 (λ x, _)
rw one_mul
exact le_max_left _ _
intros
rw [continuous_iff_continuous_on_univ, ← metric.eball_top_eq_univ (0 : 𝔸), ← exp_series_radius_eq_top 𝕂 𝔸]
exact continuous_on_exp
intros
{ ext, refl }
ext
refl
intros
simpa only [one_div] using interval_integrable_one_div_one_add_sq
intros
field_simp [pow_mul, sin_sq, cos_sq, ← sub_sub, (by ring : (2:ℝ) - 1 = 1)]
intros
simp [hz.not_lt, mul_rpow_eq_ite]
intros
convert (@complex.has_fderiv_at_cpow ((λ x, (f x, g x)) x) h0).comp x (hf.prod hg)
intros
simp only [sub_eq_add_neg] at h ⊢
{ simp only [sub_eq_add_neg] at h ⊢, simp only [rpow_add' hx h, rpow_neg hx, div_eq_mul_inv] }
simp only [rpow_add' hx h, rpow_neg hx, div_eq_mul_inv]
intros
rcases hx.eq_or_lt with (rfl|hx)
rcases em (y = 0) with (rfl|hy); simp [*, lt_irrefl, (@zero_lt_one ℝ _ _).not_lt]
rcases em (y = 0) with (rfl|hy)
{ rcases em (y = 0) with (rfl|hy); simp [*, lt_irrefl, (@zero_lt_one ℝ _ _).not_lt] }
simp [*, lt_irrefl, (@zero_lt_one ℝ _ _).not_lt]
simp [*, lt_irrefl, (@zero_lt_one ℝ _ _).not_lt]
{ simp [one_lt_rpow_iff_of_pos hx, hx] }
simp [one_lt_rpow_iff_of_pos hx, hx]
intros
rw [one_div, ← inv_sqrt_one_add_tan_sq (cos_arctan_pos x), tan_arctan]
intros
simp [cos_add]
intros
rw [sin_sq_pi_over_two_pow, sqrt_two_add_series, div_pow, sq_sqrt, add_div, ←sub_sub]
congr
norm_num
norm_num
apply add_nonneg
norm_num
apply sqrt_two_add_series_zero_nonneg
convert tendsto_cos_pi_div_two.inv_tendsto_zero.at_top_mul zero_lt_one tendsto_sin_pi_div_two
simp only [pi.inv_apply, ← div_eq_inv_mul, ← tan_eq_sin_div_cos]
intros
rw [← neg_le_neg_iff, ← arcsin_neg, arcsin_le_iff_le_sin ⟨neg_le_neg hy.2, neg_le.2 hy.1⟩ ⟨neg_le_neg hx.2, neg_le.2 hx.1⟩, sin_neg, neg_le_neg_iff]
intros
rw [← arcsin_proj_Icc, proj_Icc_of_right_le _ hx, subtype.coe_mk, arcsin_one]
intros
simpa using tendsto_const_nhds.mul nnreal.tendsto_inverse_at_top_nhds_0_nat
intros
dsimp [transfer_nat_trans_self]
rw [id_comp, comp_id]
have := unit_transfer_nat_trans adj₁ adj₂ (L₂.left_unitor.hom ≫ f ≫ L₁.right_unitor.inv) X
dsimp at this
rw this
simp
intros
symmetry
{ symmetry, erw [←iso.comp_hom_eq_id (e.counit_iso.app _), functor_unit_comp], refl }
erw [←iso.comp_hom_eq_id (e.counit_iso.app _), functor_unit_comp]
refl
intros
simp only [←category.assoc, cancel_mono]
intros
tidy
intros
simp
intros
simp [biprod.lift_eq, biprod.desc_eq]
intros
ext j
simp [sum_comp, biproduct.ι_π, comp_dite]
intros
simp
intros
{ ext, simp [cokernel_zero_iso_target], }
ext
simp [cokernel_zero_iso_target]
intros
rw [←cancel_mono (ρ_ Y).hom, right_unitor_naturality, right_unitor_naturality]
{ rw [←cancel_mono (ρ_ Y).hom, right_unitor_naturality, right_unitor_naturality], simp }
simp
intros
dunfold right_adjoint_mate
rw [category.assoc, category.assoc, associator_inv_naturality_assoc, associator_inv_naturality_assoc, ←tensor_id_comp_id_tensor g, category.assoc, category.assoc, category.assoc, category.assoc, id_tensor_comp_tensor_id_assoc, ←left_unitor_naturality, tensor_id_comp_id_tensor_assoc]
intros
{ ext, rw [← op_comp, is_iso.inv_hom_id, op_id] }
ext
rw [← op_comp, is_iso.inv_hom_id, op_id]
intros
rw [←functor.map_comp,prod_comp,category.comp_id]
intros
apply limit.hom_ext
rintro ⟨⟨Y, f, hf⟩, ⟨Z, g, hg⟩⟩
simp only [first_map, second_map, fork_map]
simp only [limit.lift_π, limit.lift_π_assoc, assoc, fan.mk_π_app, subtype.coe_mk, subtype.val_eq_coe]
rw [← P.map_comp, ← op_comp, pullback.condition]
simp
intros
apply le_antisymm
rintro X S ⟨R, hR, RS⟩ x hx
{ rintro X S ⟨R, hR, RS⟩ x hx, rcases hR x hx with ⟨U, f, hf, hU⟩, exact ⟨_, f, RS _ hf, hU⟩ }
rcases hR x hx with ⟨U, f, hf, hU⟩
exact ⟨_, f, RS _ hf, hU⟩
intros X S hS
{ intros X S hS, exact ⟨S, hS, le_refl _⟩ }
exact ⟨S, hS, le_refl _⟩
intros
{ rw eq_mk f, simp, }
rw eq_mk f
simp
intros
{ ext, simp, }
ext
simp
intros
classical
apply finset.induction_on s
{ simp [top_factors] }
simp [top_factors]
{ intros i s nm ih, simp [ih] }
intros i s nm ih
simp [ih]
intros
simp [image_subobject_iso]
intros
rw [←sdiff_lt_sdiff_iff_lt, sdiff_eq_empty_iff_subset.2 h.1]
exact empty_to_colex_lt (by simpa [finset.nonempty] using exists_of_ssubset h)
intros
rw [mul_vec, adj_matrix_dot_product]
intros
simp only [degree, card_pos, finset.nonempty, mem_neighbor_finset]
intros
letI : ∀ a, decidable (a ∈ set.range (encode : α → ℕ)) := decidable_range_encode _
letI : ∀ a, decidable (a ∈ set.range (encode : α → ℕ)) := decidable_range_encode _; exact option_get (primrec.decode₂.comp subtype_val)
exact option_get (primrec.decode₂.comp subtype_val)
intros
simp only [add_bottom, list_blank.map_cons]
simp only [add_bottom, list_blank.map_cons]; convert list_blank.cons_head_tail _
convert list_blank.cons_head_tail _
generalize : list_blank.tail L = L'
refine L'.induction_on _
intro l
simp
intros
rw [← bind_pure_comp_eq_map, bind_assoc]; simp [pure_bind]
rw [← bind_pure_comp_eq_map, bind_assoc]
simp [pure_bind]
intros
rw [fix_eq_ωSup f,hc]
apply le_antisymm
apply ωSup_le_ωSup_of_le _
{ apply ωSup_le_ωSup_of_le _, intros i, existsi [i], intro x, apply le_f_of_mem_approx _ ⟨i, rfl⟩, }
intros i
existsi [i]
intro x
apply le_f_of_mem_approx _ ⟨i, rfl⟩
apply ωSup_le_ωSup_of_le _
{ apply ωSup_le_ωSup_of_le _, intros i, existsi i.succ, refl', }
intros i
existsi i.succ
refl'
intros
simp [equiv.traverse,comp_traverse] with functor_norm
simp [equiv.traverse,comp_traverse] with functor_norm; congr; ext; simp
simp [equiv.traverse,comp_traverse] with functor_norm; congr; ext
simp [equiv.traverse,comp_traverse] with functor_norm; congr
congr
ext
simp
intros
simp [sequence, traverse_map]; rw ← comp_traverse; simp [map_id]
simp [sequence, traverse_map]; rw ← comp_traverse
simp [sequence, traverse_map]
rw ← comp_traverse
simp [map_id]
intros
dsimp [of_fin]; rw [to_fin_val, of_nat_to_nat]
dsimp [of_fin]
rw [to_fin_val, of_nat_to_nat]
intros
simp
intros
simp
intros
simp [one_of, sat_eq_done]
intros
simp [sep_by, pure_eq_done]
intros
rw [← of_real_nat_cast, of_real_re]
intros
subst er
refine exp_approx_succ _ en _ _ _ h
field_simp [show (m : ℝ) ≠ 0, by norm_cast; linarith]
intros
rw [two_mul, cos_add, ← sq, ← sq]
intros
rw [← of_real_int_cast, of_real_im]
intros
intros x y H
ext i
have h1 : (mk s x : Π i, β i) i = (mk s y : Π i, β i) i
rw H
{rw H}
cases i with i hi
change i ∈ s at hi
dsimp only [mk_apply, subtype.coe_mk] at h1
simpa only [dif_pos hi] using h1
intros
{ ext ⟨a, b⟩ : 1, simp }
ext ⟨a, b⟩ : 1
simp
intros
cases x with x hx; exact set.sum_compl_symm_apply_of_mem hx
cases x with x hx
exact set.sum_compl_symm_apply_of_mem hx
intros
{ dsimp [set_value], simp [swap_apply_left] }
dsimp [set_value]
simp [swap_apply_left]
intros
rw [set.image_subset_iff, e.image_eq_preimage]
intros
cases a; refl
cases a
refl
intros
dunfold extend_subtype
{ dunfold extend_subtype, simp only [subtype_congr, equiv.trans_apply, equiv.sum_congr_apply], rw [sum_compl_apply_symm_of_pos _ _ hx, sum.map_inl, sum_compl_apply_inl] }
simp only [subtype_congr, equiv.trans_apply, equiv.sum_congr_apply]
rw [sum_compl_apply_symm_of_pos _ _ hx, sum.map_inl, sum_compl_apply_inl]
intros
cases e
{ cases e, refl }
refl
intros
ext x
ext x; simp [prod_coe_symm]
simp [prod_coe_symm]
simp [prod_coe_symm]
simp [prod_coe_symm]
simp [prod_coe_symm]
intros
{ induction h, simp [heq_iff_eq, function.funext_iff] }
induction h
simp [heq_iff_eq, function.funext_iff]
intros
induction s using quotient.induction_on
simp
intros
simp [ext_iff]
intros
suffices : (bkts.to_list.map (list.map sigma.fst)).pairwise list.disjoint
suffices : ∀ l, array.mem l bkts → (l.map sigma.fst).nodup
{ suffices : ∀ l, array.mem l bkts → (l.map sigma.fst).nodup, by simpa [bucket_array.as_list, list.nodup_join, *], rintros l ⟨i, rfl⟩, apply v.nodup }
simpa [bucket_array.as_list, list.nodup_join, *]
simpa [bucket_array.as_list, list.nodup_join, *]
rintros l ⟨i, rfl⟩
apply v.nodup
rw [← list.enum_map_snd bkts.to_list, list.pairwise_map, list.pairwise_map]
have : (bkts.to_list.enum.map prod.fst).nodup := by simp [list.nodup_range]
refine list.pairwise.imp_of_mem _ ((list.pairwise_map _).1 this)
rw prod.forall
intros i l₁
rw prod.forall
intros j l₂ me₁ me₂ ij
simp [list.disjoint]
intros a b ml₁ b' ml₂
apply ij
rwa [← v.idx_enum_1 _ me₁ ml₁, ← v.idx_enum_1 _ me₂ ml₂]
intros
rw [← abs_eq_iff_mul_self_eq, abs_eq_nat_abs, abs_eq_nat_abs]
exact int.coe_nat_inj'.symm
intros
simp [gcd]
intros
{ unfold gcd_b, rw [xgcd, xgcd_zero_left] }
unfold gcd_b
rw [xgcd, xgcd_zero_left]
intros
ext
ext; simp
simp
intros
cases le_or_lt n l.length with hn hn
{ rw length_insert_nth _ _ hn }
rw length_insert_nth _ _ hn
rw insert_nth_of_length_lt _ _ _ hn
{ rw insert_nth_of_length_lt _ _ _ hn, exact (nat.lt_succ_self _).le }
exact (nat.lt_succ_self _).le
intros
simp [any_iff_exists]
intros
rw filter_map_eq_map; apply map_id
rw filter_map_eq_map
apply map_id
intros
simp only [countp_eq_length_filter, length_pos_iff_exists_mem, mem_filter, exists_prop]
intros
induction ys generalizing f; simp *
induction ys generalizing f
simp *
simp *
intros
simp only [erase_cons, if_neg h]; split; refl
simp only [erase_cons, if_neg h]; split
simp only [erase_cons, if_neg h]
split
refl
refl
intros
simp only [zip_right, zip_right', map₂_right_eq_map₂_right']
intros
induction l; [refl, simp only [*, reverse_cons, mem_append, mem_singleton, mem_cons_iff, not_mem_nil, false_or, or_false, or_comm]]
induction l
refl
simp only [*, reverse_cons, mem_append, mem_singleton, mem_cons_iff, not_mem_nil, false_or, or_false, or_comm]
intros
induction h with _ _ _ _ ih _ _ a _ ih
refl
{refl}
rw reverse_cons
{ rw reverse_cons, exact sublist_append_of_sublist_left ih }
exact sublist_append_of_sublist_left ih
rw [reverse_cons, reverse_cons]
{ rw [reverse_cons, reverse_cons], exact ih.append_right [a] }
exact ih.append_right [a]
intros
cases l with x l
{ simpa using hn }
simpa using hn
induction l with y l hl generalizing x n
{ simp }
simp
cases n
{ cases n, { simp }, { have hn' : n.succ ≤ l.length.succ, { refine nat.succ_le_of_lt _, simpa [nat.succ_lt_succ_iff] using hn }, have hx': (x :: y :: l).nth_le n.succ hn ≠ x, { intro H, suffices : n.succ = 0, { simpa }, rw nodup_iff_nth_le_inj at h, refine h _ _ hn nat.succ_pos' _, simpa using H }, rcases hn'.eq_or_lt with hn''|hn'', { rw [next_last_cons], { simp [hn''] }, { exact hx' }, { simp [last_eq_nth_le, hn''] }, { exact nodup_of_nodup_cons h } }, { have : n < l.length := by simpa [nat.succ_lt_succ_iff] using hn'' , rw [next_ne_head_ne_last _ _ _ _ hx'], { simp [nat.mod_eq_of_lt (nat.succ_lt_succ (nat.succ_lt_succ this)), hl _ _ (nodup_of_nodup_cons h), nat.mod_eq_of_lt (nat.succ_lt_succ this)] }, { rw last_eq_nth_le, intro H, suffices : n.succ = l.length.succ, { exact absurd hn'' this.ge.not_lt }, rw nodup_iff_nth_le_inj at h, refine h _ _ hn _ _, { simp }, { simpa using H } } } } }
{ simp }
simp
have hn' : n.succ ≤ l.length.succ
{ have hn' : n.succ ≤ l.length.succ, { refine nat.succ_le_of_lt _, simpa [nat.succ_lt_succ_iff] using hn }, have hx': (x :: y :: l).nth_le n.succ hn ≠ x, { intro H, suffices : n.succ = 0, { simpa }, rw nodup_iff_nth_le_inj at h, refine h _ _ hn nat.succ_pos' _, simpa using H }, rcases hn'.eq_or_lt with hn''|hn'', { rw [next_last_cons], { simp [hn''] }, { exact hx' }, { simp [last_eq_nth_le, hn''] }, { exact nodup_of_nodup_cons h } }, { have : n < l.length := by simpa [nat.succ_lt_succ_iff] using hn'' , rw [next_ne_head_ne_last _ _ _ _ hx'], { simp [nat.mod_eq_of_lt (nat.succ_lt_succ (nat.succ_lt_succ this)), hl _ _ (nodup_of_nodup_cons h), nat.mod_eq_of_lt (nat.succ_lt_succ this)] }, { rw last_eq_nth_le, intro H, suffices : n.succ = l.length.succ, { exact absurd hn'' this.ge.not_lt }, rw nodup_iff_nth_le_inj at h, refine h _ _ hn _ _, { simp }, { simpa using H } } } }
refine nat.succ_le_of_lt _
{ refine nat.succ_le_of_lt _, simpa [nat.succ_lt_succ_iff] using hn }
simpa [nat.succ_lt_succ_iff] using hn
have hx': (x :: y :: l).nth_le n.succ hn ≠ x
intro H
{ intro H, suffices : n.succ = 0, { simpa }, rw nodup_iff_nth_le_inj at h, refine h _ _ hn nat.succ_pos' _, simpa using H }
suffices : n.succ = 0
simpa
{ simpa }
rw nodup_iff_nth_le_inj at h
refine h _ _ hn nat.succ_pos' _
simpa using H
rcases hn'.eq_or_lt with hn''|hn''
rw [next_last_cons]
{ rw [next_last_cons], { simp [hn''] }, { exact hx' }, { simp [last_eq_nth_le, hn''] }, { exact nodup_of_nodup_cons h } }
simp [hn'']
{ simp [hn''] }
exact hx'
{ exact hx' }
simp [last_eq_nth_le, hn'']
{ simp [last_eq_nth_le, hn''] }
exact nodup_of_nodup_cons h
{ exact nodup_of_nodup_cons h }
have : n < l.length := by simpa [nat.succ_lt_succ_iff] using hn''
{ have : n < l.length := by simpa [nat.succ_lt_succ_iff] using hn'' , rw [next_ne_head_ne_last _ _ _ _ hx'], { simp [nat.mod_eq_of_lt (nat.succ_lt_succ (nat.succ_lt_succ this)), hl _ _ (nodup_of_nodup_cons h), nat.mod_eq_of_lt (nat.succ_lt_succ this)] }, { rw last_eq_nth_le, intro H, suffices : n.succ = l.length.succ, { exact absurd hn'' this.ge.not_lt }, rw nodup_iff_nth_le_inj at h, refine h _ _ hn _ _, { simp }, { simpa using H } } }
rw [next_ne_head_ne_last _ _ _ _ hx']
simp [nat.mod_eq_of_lt (nat.succ_lt_succ (nat.succ_lt_succ this)), hl _ _ (nodup_of_nodup_cons h), nat.mod_eq_of_lt (nat.succ_lt_succ this)]
{ simp [nat.mod_eq_of_lt (nat.succ_lt_succ (nat.succ_lt_succ this)), hl _ _ (nodup_of_nodup_cons h), nat.mod_eq_of_lt (nat.succ_lt_succ this)] }
rw last_eq_nth_le
{ rw last_eq_nth_le, intro H, suffices : n.succ = l.length.succ, { exact absurd hn'' this.ge.not_lt }, rw nodup_iff_nth_le_inj at h, refine h _ _ hn _ _, { simp }, { simpa using H } }
intro H
suffices : n.succ = l.length.succ
exact absurd hn'' this.ge.not_lt
{ exact absurd hn'' this.ge.not_lt }
rw nodup_iff_nth_le_inj at h
refine h _ _ hn _ _
simp
{ simp }
simpa using H
{ simpa using H }
intros
induction as generalizing start
{ refl }
refl
simp only [foldr_with_index_aux, foldr_with_index_aux_spec_cons, *]
{ simp only [foldr_with_index_aux, foldr_with_index_aux_spec_cons, *] }
intros
simp only [list.bind, nodup_join, pairwise_map, and_comm, and.left_comm, mem_map, exists_imp_distrib, and_imp]
simp only [list.bind, nodup_join, pairwise_map, and_comm, and.left_comm, mem_map, exists_imp_distrib, and_imp]; rw [show (∀ (l : list β) (x : α), f x = l → x ∈ l₁ → nodup l) ↔ (∀ (x : α), x ∈ l₁ → nodup (f x)), from forall_swap.trans $ forall_congr $ λ_, forall_eq']
rw [show (∀ (l : list β) (x : α), f x = l → x ∈ l₁ → nodup l) ↔ (∀ (x : α), x ∈ l₁ → nodup (f x)), from forall_swap.trans $ forall_congr $ λ_, forall_eq']
intros
simp only [sublists, sublists_aux_cons_cons, cons_append, perm_cons]
refine (perm.cons _ _).trans perm_middle.symm
induction sublists_aux l cons with b l IH
induction sublists_aux l cons with b l IH; simp
simp
simp
exact (IH.cons _).trans perm_middle.symm
intros
rw [← of_fn_id, map_of_fn, function.right_id]
intros
have hi : i % l.length < l.length := mod_lt _ (length_pos_of_ne_nil hn)
have hj : j % l.length < l.length := mod_lt _ (length_pos_of_ne_nil hn)
refine (nodup_iff_nth_le_inj.mp hl) _ _ hi hj _
rw [←nth_le_rotate' l i, ←nth_le_rotate' l j]
simp [nat.sub_add_cancel, hi.le, hj.le, h]
intros
by_cases hl : l = []
{ simp [hl, eq_comm] }
simp [hl, eq_comm]
have hl' : l.cyclic_permutations.length = l.length := length_cyclic_permutations_of_ne_nil _ hl
refine ⟨λ h, _, is_rotated.cyclic_permutations⟩
obtain ⟨k, hk⟩ := h
refine ⟨k % l.length, _⟩
have hk' : k % l.length < l.length := mod_lt _ (length_pos_of_ne_nil hl)
rw [←nth_le_cyclic_permutations _ _ (hk'.trans_le hl'.ge), ←nth_le_rotate' _ k]
simp [hk, hl', nat.sub_add_cancel hk'.le]
intros
rw [split, h]; refl
rw [split, h]
refl
intros
induction n with n IHn generalizing l₁ l₂
simp
{simp}
induction h with l₁ l₂ a s IH l₁ l₂ a s IH
refl
{refl}
refine IH.trans _
{ refine IH.trans _, rw sublists_len_succ_cons, apply sublist_append_left }
rw sublists_len_succ_cons
apply sublist_append_left
simp [sublists_len_succ_cons]
{ simp [sublists_len_succ_cons], exact IH.append ((IHn s).map _) }
exact IH.append ((IHn s).map _)
intros
rw [←hl, ←hr, ←zip_unzip lp, ←unzip_left, ←unzip_right, zip_unzip, zip_unzip]
intros
{ ext, symmetry, apply dot_product_assoc }
ext
symmetry
apply dot_product_assoc
intros
{ ext, refl }
ext
refl
intros
ext i j; by_cases h : i = j; simp [h]
ext i j; by_cases h : i = j
ext i j
by_cases h : i = j
simp [h]
simp [h]
intros
simp [h]
intros
{ cases ik, cases jk, refl }
cases ik
cases jk
refl
intros
{ ext, simp [fin.append] }
ext
simp [fin.append]
intros
{ ext i j, refine fin.cases _ _ i; simp [minor] }
ext i j
refine fin.cases _ _ i
refine fin.cases _ _ i; simp [minor]
simp [minor]
simp [minor]
intros
simp [multiset.sigma]
intros
simp [(∪), union]
intros
induction hst
simpa using huv
case rel.zero { simpa using huv }
case rel.cons : a b s t hab hst ih { simpa using ih.cons hab }
intros
convert add_monoid_algebra.support_mul p q; ext; convert iff.rfl
convert add_monoid_algebra.support_mul p q; ext
convert add_monoid_algebra.support_mul p q
ext
convert iff.rfl
intros
show _ = eval₂_hom f g (eval₂ C q p)
rw eval₂_comp_left (eval₂_hom f g)
congr' with a
simp
intros
ext : 2; simp
{ ext : 2; simp }
ext : 2
simp
simp
intros
apply mv_polynomial.induction_on p; { intros, simp [*] }
apply mv_polynomial.induction_on p
{ intros, simp [*] }
{ intros, simp [*] }
intros
{ intros, simp [*] }
simp [*]
intros
simpa only [exists_prop, finset.mem_image] using vars_rename f φ h
intros
simp_rw [← not_lt, find_lt_iff, not_exists]
intros
rw [mul_comm, nat.mul_right_eq_self_iff hb]
intros
rw [← H2, nat.mul_div_cancel' H1]
intros
rw nat.bin_cast
apply binary_rec _ _ n
{ rw [binary_rec_zero, cast_zero] }
rw [binary_rec_zero, cast_zero]
{ intros b k h, rw [binary_rec_eq, h], { cases b; simp [bit, bit0, bit1] }, { simp } }
intros b k h
rw [binary_rec_eq, h]
cases b; simp [bit, bit0, bit1]
{ cases b; simp [bit, bit0, bit1] }
cases b
simp [bit, bit0, bit1]
simp [bit, bit0, bit1]
{ simp }
simp
intros
rw [← choose_mul_factorial_mul_factorial hk, mul_assoc]
exact (mul_div_left _ (mul_pos (factorial_pos _) (factorial_pos _))).symm
intros
rw [←list.init_append_last hl]
simp only [list.length_append, list.length, zero_add, list.length_init, of_digits_append, list.length_init, of_digits_singleton, add_comm (l.length - 1), pow_add, pow_one]
apply nat.mul_le_mul_left
refine le_trans _ (nat.le_add_left _ _)
have : 0 < l.last hl
rwa [pos_iff_ne_zero]
{ rwa [pos_iff_ne_zero] }
convert nat.mul_le_mul_left _ this
rw [mul_one]
intros
convert to_with_top_zero
intros
rw [desc_factorial_succ, desc_factorial_zero, mul_one, nat.sub_zero]
intros
rw [gcd_comm, gcd_eq_left H]
intros
rw [← H.gcd_eq_one, gcd_eq_left d]
intros
rw [not_odd_iff, even_iff]
intros
{ rw ←one_pow n, exact pow_lt_pow_of_lt_left h₁ h₀ }
rw ←one_pow n
exact pow_lt_pow_of_lt_left h₁ h₀
intros
{ rw mem_def at ha ⊢, subst ha, refl }
rw mem_def at ha ⊢
subst ha
refl
intros
rw [valid'.dual_iff, dual_balance_r]; exact hr.dual.balance_l hl.dual (balance_sz_dual H)
rw [valid'.dual_iff, dual_balance_r]
exact hr.dual.balance_l hl.dual (balance_sz_dual H)
intros
dsimp [node3_l, node', size]; rw add_right_comm _ 1
dsimp [node3_l, node', size]
rw add_right_comm _ 1
intros
split
rintros ⟨y, hy⟩
{ rintros ⟨y, hy⟩, cases h : y with a f, refine ⟨a, λ i, (f i).val, _, λ i, (f i).property⟩, rw [←hy, h, pfunctor.map_eq] }
cases h : y with a f
refine ⟨a, λ i, (f i).val, _, λ i, (f i).property⟩
rw [←hy, h, pfunctor.map_eq]
rintros ⟨a, f, xeq, pf⟩
use ⟨a, λ i, ⟨f i, pf i⟩⟩
rw [xeq]
reflexivity
intros
simp_rw algebra.smul_def
{ simp_rw algebra.smul_def, exact eval₂_eq_sum_range' (algebra_map R S) hn x }
exact eval₂_eq_sum_range' (algebra_map R S) hn x
intros
simp
intros
rw [← pow_one X, support_X_pow H 1]
intros
ext1
{ ext1, rw [monomial_eq_smul_X, coeff_smul, coeff_C_mul, smul_eq_mul] }
rw [monomial_eq_smul_X, coeff_smul, coeff_C_mul, smul_eq_mul]
intros
rw [add_comm, degree_add_eq_left_of_degree_lt h]
intros
rw [subsingleton.elim p 0, degree_zero]
intros
refine ⟨r * a ^ n * b ^ (N - n), bi, bu, _⟩
rw [C_mul_X_pow_eq_monomial, map_monomial, ← C_mul_X_pow_eq_monomial, eval_mul, eval_pow, eval_C]
rw [ring_hom.map_mul, ring_hom.map_mul, ring_hom.map_pow, ring_hom.map_pow, eval_X, mul_comm]
rw [← nat.sub_add_cancel nN] {occs := occurrences.pos [2]}
rw [pow_add, mul_assoc, mul_comm (i b ^ n), mul_pow, mul_assoc, mul_assoc (i a ^ n), ← mul_pow]
rw [bu, one_pow, mul_one]
intros
by_cases h : f.support.card ≤ 1
right
{ right, rw ← C_mul_X_pow_eq_self h, simp }
rw ← C_mul_X_pow_eq_self h
simp
left
{ left, apply erase_lead_nat_degree_lt (lt_of_not_ge h) }
apply erase_lead_nat_degree_lt (lt_of_not_ge h)
intros
simp only [←C_eq_nat_cast, eval_C]
intros
simp only [monomial_eq_C_mul_X, sum_C_mul_X_eq]
intros
induction n with n ih
{ exfalso, exact nat.lt_asymm h h }
exfalso
exact nat.lt_asymm h h
by_cases H : n = 0
{ by_cases H : n = 0, { rw [iterated_deriv_succ, H], simp only [iterated_deriv_C_zero, derivative_C] }, { replace h : 0 < n := nat.pos_of_ne_zero H, rw [iterated_deriv_succ, ih h], simp only [derivative_zero] } }
rw [iterated_deriv_succ, H]
{ rw [iterated_deriv_succ, H], simp only [iterated_deriv_C_zero, derivative_C] }
simp only [iterated_deriv_C_zero, derivative_C]
replace h : 0 < n := nat.pos_of_ne_zero H
{ replace h : 0 < n := nat.pos_of_ne_zero H, rw [iterated_deriv_succ, ih h], simp only [derivative_zero] }
rw [iterated_deriv_succ, ih h]
simp only [derivative_zero]
intros
rw [leading_coeff, leading_coeff, coeff_smul, nat_degree_smul_of_smul_regular p h]
intros
by_cases f0 : f=0
{ simp only [f0, zero_mul, reverse_zero], }
simp only [f0, zero_mul, reverse_zero]
by_cases g0 : g=0
{ rw [g0, mul_zero, reverse_zero, mul_zero], }
rw [g0, mul_zero, reverse_zero, mul_zero]
simp [reverse_mul, *]
intros
simp only [taylor_apply, X_comp]
intros
ext
ext; apply mem_supp
apply mem_supp
intros
rw [← int.cast_coe_nat, coe_int_denom]
intros
simp [abs_eq_max_neg]
intros
rw [lt_iff_le_and_ne, rat.le_def']
suffices : p ≠ q ↔ p.num * q.denom ≠ q.num * p.denom
split; intro h
split; intro h
split
split
{ split; intro h, { exact lt_iff_le_and_ne.elim_right ⟨h.left, (this.elim_left h.right)⟩ }, { have tmp := lt_iff_le_and_ne.elim_left h, exact ⟨tmp.left, this.elim_right tmp.right⟩ }}
{ split; intro h, { exact lt_iff_le_and_ne.elim_right ⟨h.left, (this.elim_left h.right)⟩ }, { have tmp := lt_iff_le_and_ne.elim_left h, exact ⟨tmp.left, this.elim_right tmp.right⟩ }}
intro h
intro h
{ exact lt_iff_le_and_ne.elim_right ⟨h.left, (this.elim_left h.right)⟩ }
{ exact lt_iff_le_and_ne.elim_right ⟨h.left, (this.elim_left h.right)⟩ }
exact lt_iff_le_and_ne.elim_right ⟨h.left, (this.elim_left h.right)⟩
exact lt_iff_le_and_ne.elim_right ⟨h.left, (this.elim_left h.right)⟩
intro h
intro h
have tmp := lt_iff_le_and_ne.elim_left h
have tmp := lt_iff_le_and_ne.elim_left h
{ have tmp := lt_iff_le_and_ne.elim_left h, exact ⟨tmp.left, this.elim_right tmp.right⟩ }
{ have tmp := lt_iff_le_and_ne.elim_left h, exact ⟨tmp.left, this.elim_right tmp.right⟩ }
exact ⟨tmp.left, this.elim_right tmp.right⟩
exact ⟨tmp.left, this.elim_right tmp.right⟩
exact (not_iff_not.elim_right eq_iff_mul_eq_mul)
rw ← zero_cauchy
rw ← zero_cauchy; refl
refl
intros
simpa using neg_lim_zero hfg
intros
{ simp_rw ennreal.to_real, norm_cast, exact to_nnreal_inv a, }
simp_rw ennreal.to_real
norm_cast
exact to_nnreal_inv a
intros
simp [div_eq_mul_inv, h]
refine lt_of_mul_lt_mul_left _ (le_of_lt gold_pos)
simp [← sq, gold_pos, zero_lt_one]
intros
rw not_infinite_iff_exist_lt_gt
rw not_infinite_iff_exist_lt_gt; exact ⟨ r - 1, r + 1, coe_lt_coe.2 $ sub_one_lt r, coe_lt_coe.2 $ lt_add_one r⟩
exact ⟨ r - 1, r + 1, coe_lt_coe.2 $ sub_one_lt r, coe_lt_coe.2 $ lt_add_one r⟩
intros
simpa using sqrt_inj h (le_refl _)
intros
{ unfold comp, ext x, simp }
unfold comp
ext x
simp
intros
rw [←bind_ret, ←bind_ret]; apply lift_rel_bind _ _ h1; simp; exact @h2
rw [←bind_ret, ←bind_ret]; apply lift_rel_bind _ _ h1; simp
rw [←bind_ret, ←bind_ret]; apply lift_rel_bind _ _ h1
rw [←bind_ret, ←bind_ret]
apply lift_rel_bind _ _ h1
simp
exact @h2
intros
ext x
simp only [mem_inter_iff, mem_insert_iff, mem_inter_eq, and.congr_left_iff, or_iff_right_iff_imp]
cc
intros
ext
{ ext, simp [and_or_distrib_left, exists_or_distrib, eq_comm, or_comm, and_comm] }
simp [and_or_distrib_left, exists_or_distrib, eq_comm, or_comm, and_comm]
intros
split
intro h
{ intro h, apply subset.antisymm, rw [←preimage_subset_preimage_iff hs, h], rw [←preimage_subset_preimage_iff ht, h] }
apply subset.antisymm
rw [←preimage_subset_preimage_iff hs, h]
rw [←preimage_subset_preimage_iff ht, h]
rintro rfl
refl
intros
rw [← preimage_range (coe : s → α), range_coe]
intros
simp [subset_def]
intros
rw [← image_eq_image hf.1, hf.2.image_preimage]
intros
{ ext, simp }
ext
simp
intros
ext
ext; simp
simp
intros
rw [← Ioi_inter_Iic, inter_assoc, inter_comm, inter_assoc, Ioi_inter_Ioi, inter_comm, Ioi_inter_Iic, sup_comm]
intros
rw [←not_nonempty_iff_eq_empty, not_iff_not, nonempty_Ico]
intros
rw [diff_eq, compl_Iic, inter_comm, Ioi_inter_Iio]
intros
simp [add_comm]
intros
refine ⟨λ x h, add_le_add_right (mem_Iic.mp h) _, λ _ _ _ _ h, add_right_cancel h, λ _ h, _⟩
simpa [add_comm a] using h
intros
refine ⟨λ x h, add_le_add_right (mem_Ici.mp h) _, λ _ _ _ _ h, add_right_cancel h, λ _ h, _⟩
obtain ⟨c, rfl⟩ := exists_add_of_le (mem_Ici.mp h)
rw [mem_Ici, add_right_comm, add_le_add_iff_right] at h
exact ⟨a + c, h, by rw add_right_comm⟩
intros
simp [interval_oc, h]
intros
intros y hy
rw [Hinj.image_Inter_eq, mem_Inter]
exact λ i, H i hy
intros
rw [← sUnion_image, image_id']
intros
{ ext x, simp [hs.exists_mem x] }
ext x
simp [hs.exists_mem x]
intros
{ ext i : 2, induction i; simp [drop_fun,*]; refl }
ext i : 2
induction i
induction i; simp [drop_fun,*]; refl
induction i; simp [drop_fun,*]
simp [drop_fun,*]
refl
intros
casesI n
{ exfalso, exact nat.not_lt_zero 0 (fact.out _) }
exfalso
exact nat.not_lt_zero 0 (fact.out _)
{ apply fin.val_add }
apply fin.val_add
intros
rw [zmod.val_min_abs_def_pos]
{ rw [zmod.val_min_abs_def_pos], split_ifs; simp only [add_zero, sub_add_cancel] }
split_ifs
split_ifs; simp only [add_zero, sub_add_cancel]
simp only [add_zero, sub_add_cancel]
simp only [add_zero, sub_add_cancel]
intros
simpa only [add_comm _ (n:ℝ)] using f.commute_add_int n
intros
revert α
suffices : ∀ (α : E), is_solvable_by_rad F α → (∃ β : solvable_by_rad F E, ↑β = α ∧ P β)
intro α
{ intro α, obtain ⟨α₀, hα₀, Pα⟩ := this α (subtype.mem α), convert Pα, exact subtype.ext hα₀.symm }
obtain ⟨α₀, hα₀, Pα⟩ := this α (subtype.mem α)
convert Pα
exact subtype.ext hα₀.symm
apply is_solvable_by_rad.rec
exact λ α, ⟨algebra_map F (solvable_by_rad F E) α, rfl, base α⟩
{ exact λ α, ⟨algebra_map F (solvable_by_rad F E) α, rfl, base α⟩ }
intros α β hα hβ Pα Pβ
{ intros α β hα hβ Pα Pβ, obtain ⟨⟨α₀, hα₀, Pα⟩, β₀, hβ₀, Pβ⟩ := ⟨Pα, Pβ⟩, exact ⟨α₀ + β₀, by {rw [←hα₀, ←hβ₀], refl }, add α₀ β₀ Pα Pβ⟩ }
obtain ⟨⟨α₀, hα₀, Pα⟩, β₀, hβ₀, Pβ⟩ := ⟨Pα, Pβ⟩
exact ⟨α₀ + β₀, by {rw [←hα₀, ←hβ₀], refl }, add α₀ β₀ Pα Pβ⟩
intros α hα Pα
{ intros α hα Pα, obtain ⟨α₀, hα₀, Pα⟩ := Pα, exact ⟨-α₀, by {rw ←hα₀, refl }, neg α₀ Pα⟩ }
obtain ⟨α₀, hα₀, Pα⟩ := Pα
exact ⟨-α₀, by {rw ←hα₀, refl }, neg α₀ Pα⟩
intros α β hα hβ Pα Pβ
{ intros α β hα hβ Pα Pβ, obtain ⟨⟨α₀, hα₀, Pα⟩, β₀, hβ₀, Pβ⟩ := ⟨Pα, Pβ⟩, exact ⟨α₀ * β₀, by {rw [←hα₀, ←hβ₀], refl }, mul α₀ β₀ Pα Pβ⟩ }
obtain ⟨⟨α₀, hα₀, Pα⟩, β₀, hβ₀, Pβ⟩ := ⟨Pα, Pβ⟩
exact ⟨α₀ * β₀, by {rw [←hα₀, ←hβ₀], refl }, mul α₀ β₀ Pα Pβ⟩
intros α hα Pα
{ intros α hα Pα, obtain ⟨α₀, hα₀, Pα⟩ := Pα, exact ⟨α₀⁻¹, by {rw ←hα₀, refl }, inv α₀ Pα⟩ }
obtain ⟨α₀, hα₀, Pα⟩ := Pα
exact ⟨α₀⁻¹, by {rw ←hα₀, refl }, inv α₀ Pα⟩
intros α n hn hα Pα
{ intros α n hn hα Pα, obtain ⟨α₀, hα₀, Pα⟩ := Pα, refine ⟨⟨α, is_solvable_by_rad.rad α n hn hα⟩, rfl, rad _ n hn _⟩, convert Pα, exact subtype.ext (eq.trans ((solvable_by_rad F E).coe_pow _ n) hα₀.symm) }
obtain ⟨α₀, hα₀, Pα⟩ := Pα
refine ⟨⟨α, is_solvable_by_rad.rad α n hn hα⟩, rfl, rad _ n hn _⟩
convert Pα
exact subtype.ext (eq.trans ((solvable_by_rad F E).coe_pow _ n) hα₀.symm)
intros
rw ← adjoin_simple.algebra_map_gen F α at h
have inj := (algebra_map F⟮α⟯ E).injective
exact minpoly.eq_of_algebra_map_eq inj ((is_integral_algebra_map_iff inj).mp h) (adjoin_simple.algebra_map_gen _ _).symm
intros
rw [coe_expand, derivative_eval₂_C, derivative_pow, derivative_X, mul_one]
intros
rw [separable_iff_derivative_ne_zero hf, ne, ← degree_eq_bot, degree_derivative_eq]
rintro ⟨⟩
rw [pos_iff_ne_zero, ne, nat_degree_eq_zero_iff_degree_le_zero, degree_le_zero_iff]
refine λ hf1, hf.not_unit _
rw [hf1, is_unit_C, is_unit_iff_ne_zero]
intro hf2
rw [hf2, C_0] at hf1
exact absurd hf1 hf.ne_zero
intros
apply polynomial.map_injective _ i.injective
rw [eq_prod_roots_of_splits h_splits, h_roots]
simp
intros
use p
simp
intros
simp_rw [monge_point_eq_affine_combination_of_points_with_circumcenter, centroid_eq_affine_combination_of_points_with_circumcenter, affine_combination_vsub, monge_point_vsub_face_centroid_weights_with_circumcenter_eq_sub h]
intros
{ simp only [← finset.prod_apply], exact smooth_finset_prod' h }
simp only [← finset.prod_apply]
exact smooth_finset_prod' h
intros
rw support_eq_inter_preimage
{ rw support_eq_inter_preimage, exact ext_chart_preimage_open_of_open I c is_open_ball }
exact ext_chart_preimage_open_of_open I c is_open_ball
intros
suffices h : Q (e ∘ e.symm) e.target (e x)
rw [lift_prop_at, hG.lift_prop_within_at_indep_chart he hx G.id_mem_maximal_atlas (mem_univ _)]
{ rw [lift_prop_at, hG.lift_prop_within_at_indep_chart he hx G.id_mem_maximal_atlas (mem_univ _)], refine ⟨(e.continuous_at hx).continuous_within_at, _⟩, simpa only with mfld_simps }
refine ⟨(e.continuous_at hx).continuous_within_at, _⟩
simpa only with mfld_simps
have A : Q id e.target (e x)
have : e x ∈ e.target
{ have : e x ∈ e.target, by simp only [hx] with mfld_simps, simpa only with mfld_simps using (hG.is_local e.open_target this).1 (hQ (e x)) }
simp only [hx] with mfld_simps
simp only [hx] with mfld_simps
simpa only with mfld_simps using (hG.is_local e.open_target this).1 (hQ (e x))
apply hG.congr _ _ A; simp only [hx] with mfld_simps {contextual := tt}
apply hG.congr _ _ A
simp only [hx] with mfld_simps {contextual := tt}
simp only [hx] with mfld_simps {contextual := tt}
intros
rwa [← univ_inter s, has_mfderiv_within_at_inter hs, has_mfderiv_within_at_univ] at h
intros
simp only [tangent_map] with mfld_simps
rw mfderiv_comp p.1 hg hf
refl
intros
cases he with he he_symm
cases he' with he' he'_symm
simp only at he he_symm he' he'_symm
split
split; simp only [local_equiv.prod_source, local_homeomorph.prod_to_local_equiv]
simp only [local_equiv.prod_source, local_homeomorph.prod_to_local_equiv]
have h3 := times_cont_diff_on.prod_map he he'
{ have h3 := times_cont_diff_on.prod_map he he', rw [← I.image_eq, ← I'.image_eq, set.prod_image_image_eq] at h3, rw ← (I.prod I').image_eq, exact h3, }
rw [← I.image_eq, ← I'.image_eq, set.prod_image_image_eq] at h3
rw ← (I.prod I').image_eq
exact h3
simp only [local_equiv.prod_source, local_homeomorph.prod_to_local_equiv]
have h3 := times_cont_diff_on.prod_map he_symm he'_symm
{ have h3 := times_cont_diff_on.prod_map he_symm he'_symm, rw [← I.image_eq, ← I'.image_eq, set.prod_image_image_eq] at h3, rw ← (I.prod I').image_eq, exact h3, }
rw [← I.image_eq, ← I'.image_eq, set.prod_image_image_eq] at h3
rw ← (I.prod I').image_eq
exact h3
intros
rw ← times_cont_mdiff_on_univ at hf
rw continuous_iff_continuous_on_univ
convert hf.continuous_on_tangent_map_within hmn unique_mdiff_on_univ
rw tangent_map_within_univ
intros
intro x
by_cases hx : x ∈ closure (support f)
{ exact hf x hx }
exact hf x hx
refine times_cont_mdiff_at.congr_of_eventually_eq _ (eventually_eq_zero_nhds.2 hx)
{ refine times_cont_mdiff_at.congr_of_eventually_eq _ (eventually_eq_zero_nhds.2 hx), exact times_cont_mdiff_at_const }
exact times_cont_mdiff_at_const
intros
{ ext, simp only [Inf_image, infi_apply, infi_Prop_eq], refl }
ext
simp only [Inf_image, infi_apply, infi_Prop_eq]
refl
intros
rw [←set_like.mem_coe, ←ha]; exact mem_own_left_coset s a
rw [←set_like.mem_coe, ←ha]
exact mem_own_left_coset s a
intros
rw [← add_monoid_hom.comp_apply, finsupp.to_free_abelian_group_comp_to_finsupp, add_monoid_hom.id_apply]
intros
simp only [general_commutator_le_left, general_commutator_le_right, le_inf_iff, and_self]
intros
rw [order_of, is_fixed_point_iff_minimal_period_eq_one, is_fixed_pt, mul_one]
intros
let ϕ := orbit_equiv_quotient_stabilizer G a
haveI := fintype.of_equiv (orbit G a) ϕ
rw [card_congr ϕ, ←subgroup.index_eq_card]
exact hG.index (stabilizer G a)
intros
induction s using quot.induction_on
simpa using list.form_perm_apply_mem_eq_next h _ _
intros
classical
exact top_le_iff.mp (le_trans (ge_of_eq closure_is_swap) (closure_mono (λ _, is_swap.is_cycle)))
intros
split
intro h
{ intro h, obtain ⟨x, hx, -⟩ := id hf, exact ⟨x, mem_support.mpr hx, by simp [h]⟩ }
obtain ⟨x, hx, -⟩ := id hf
exact ⟨x, mem_support.mpr hx, by simp [h]⟩
rintro ⟨x, hx, hx'⟩
{ rintro ⟨x, hx, hx'⟩, by_cases h : support (f ^ n) = support f, { rw [←h, mem_support] at hx, contradiction }, { rw [hf.support_pow_eq_iff, not_not] at h, obtain ⟨k, rfl⟩ := h, rw [pow_mul, pow_order_of_eq_one, one_pow] } }
by_cases h : support (f ^ n) = support f
rw [←h, mem_support] at hx
{ rw [←h, mem_support] at hx, contradiction }
contradiction
rw [hf.support_pow_eq_iff, not_not] at h
{ rw [hf.support_pow_eq_iff, not_not] at h, obtain ⟨k, rfl⟩ := h, rw [pow_mul, pow_order_of_eq_one, one_pow] }
obtain ⟨k, rfl⟩ := h
rw [pow_mul, pow_order_of_eq_one, one_pow]
intros
have : f.cycle_factors_finset = f.cycle_factors_finset := rfl
obtain ⟨-, hd, hp⟩ := cycle_factors_finset_eq_finset.mp this
exact hp
intros
ext i
cases n
simp
{ simp }
refine fin.cases _ (λ i, _) i
{ simp }
simp
rw [coe_fin_rotate, decompose_fin_symm_apply_succ, if_congr (i.succ_eq_last_succ) rfl rfl]
split_ifs with h
{ simp [h] }
simp [h]
rw [fin.coe_succ, function.injective.map_swap fin.coe_injective, fin.coe_succ, coe_fin_rotate, if_neg h, fin.coe_zero, fin.coe_one, swap_apply_of_ne_of_ne (nat.succ_ne_zero _) (nat.succ_succ_ne_one _)]
{ rw [fin.coe_succ, function.injective.map_swap fin.coe_injective, fin.coe_succ, coe_fin_rotate, if_neg h, fin.coe_zero, fin.coe_one, swap_apply_of_ne_of_ne (nat.succ_ne_zero _) (nat.succ_succ_ne_one _)] }
intros
ext
{ext, simp [equiv_functor.map_equiv, equiv_functor.map] }
simp [equiv_functor.map_equiv, equiv_functor.map]
intros
{ ext, simp }
ext
simp
intros
rw [disjoint_comm, disjoint_inv_left_iff, disjoint_comm]
intros
haveI := fintype.one_lt_card_iff_nontrivial.1 (lt_trans dec_trivial h3)
rw ← fintype.one_lt_card_iff_nontrivial
refine lt_of_mul_lt_mul_left _ (le_of_lt nat.prime_two.pos)
rw [two_mul_card_alternating_group, card_perm, ← nat.succ_le_iff]
exact le_trans h3 (card α).self_le_factorial
intros
rw [sr_mul_sr, sub_self, one_def]
intros
rwa [comap_map_eq, sup_eq_left]
intros
rw [← mem_to_submonoid, closure_to_submonoid k] at h
refine submonoid.closure_induction h (λ x hx, _) H1 (λ x y hx hy, Hmul x y hx hy)
rw [mem_union, mem_inv] at hx
{ rw [mem_union, mem_inv] at hx, cases hx with mem invmem, { exact Hk x mem }, { rw [← inv_inv x], exact Hk_inv _ invmem } }
cases hx with mem invmem
{ exact Hk x mem }
exact Hk x mem
rw [← inv_inv x]
{ rw [← inv_inv x], exact Hk_inv _ invmem }
exact Hk_inv _ invmem
intros
haveI : nonempty S := Sne.to_subtype
simp only [Sup_eq_supr', mem_supr_of_directed hS.directed_coe, set_coe.exists, subtype.coe_mk]
intros
ext
change (⟨f x, _⟩ : mrange f) = ⟨1, _⟩ ↔ f x = 1
simp only []
intros
rw decomp ; simp only [linear_map.map_zero, pi.add_apply, add_sub_cancel, zero_add]
rw decomp
simp only [linear_map.map_zero, pi.add_apply, add_sub_cancel, zero_add]
intros
refine subset.antisymm _ (Union_subset $ le_supr S)
suffices : (span R (⋃ i, (S i : set M)) : set M) ⊆ ⋃ (i : ι), ↑(S i)
simpa only [span_Union, span_eq] using this
simpa only [span_Union, span_eq] using this
refine (λ x hx, span_induction hx (λ _, id) _ _ _)
refine (λ x hx, span_induction hx (λ _, id) _ _ _); simp only [mem_Union, exists_imp_distrib]
simp only [mem_Union, exists_imp_distrib]
{ exact hι.elim (λ i, ⟨i, (S i).zero_mem⟩) }
exact hι.elim (λ i, ⟨i, (S i).zero_mem⟩)
simp only [mem_Union, exists_imp_distrib]
intros x y i hi j hj
{ intros x y i hi j hj, rcases H i j with ⟨k, ik, jk⟩, exact ⟨k, add_mem _ (ik hi) (jk hj)⟩ }
rcases H i j with ⟨k, ik, jk⟩
exact ⟨k, add_mem _ (ik hi) (jk hj)⟩
simp only [mem_Union, exists_imp_distrib]
{ exact λ a x i hi, ⟨i, smul_mem _ a hi⟩ }
exact λ a x i hi, ⟨i, smul_mem _ a hi⟩
intros
classical; by_cases a = 0; simp [h, comap_smul]
classical; by_cases a = 0
classical
by_cases a = 0
simp [h, comap_smul]
simp [h, comap_smul]
intros
rw [map_le_map_iff, hf, sup_bot_eq]
intros
let C := basis.of_vector_space_index K V'
let hC := basis.of_vector_space K V'
haveI : inhabited V := ⟨0⟩
use hC.constr K (C.restrict (inv_fun f))
refine hC.ext (λ c, _)
rw [linear_map.comp_apply, hC.constr_basis]
simp [right_inverse_inv_fun (linear_map.range_eq_top.1 hf_surj) c]
intros
rw eq_top_iff
intros j hj
rw ← hv at hj
rw submodule.mem_span at hj ⊢
refine λ p hp, hj p (λ u hu, _)
obtain ⟨i, rfl⟩ := hu
have : ((w i)⁻¹ • 1 : R) • w i • v i ∈ p := p.smul_mem ((w i)⁻¹ • 1 : R) (hp ⟨i, rfl⟩)
rwa [smul_one_smul, inv_smul_smul] at this
intros
ext x
split
split; rw [mem_orthogonal_iff]; intro hx
split; rw [mem_orthogonal_iff]
rw [mem_orthogonal_iff]
intro hx
intros y hy
{ intros y hy, rw submodule.mem_dual_annihilator_comap_iff at hx, refine hx (B.to_lin.dom_restrict W ⟨y, hy⟩) ⟨⟨y, hy⟩, rfl⟩ }
rw submodule.mem_dual_annihilator_comap_iff at hx
refine hx (B.to_lin.dom_restrict W ⟨y, hy⟩) ⟨⟨y, hy⟩, rfl⟩
rw [mem_orthogonal_iff]
intro hx
rw submodule.mem_dual_annihilator_comap_iff
{ rw submodule.mem_dual_annihilator_comap_iff, rintro _ ⟨⟨w, hw⟩, rfl⟩, exact hx w hw }
rintro _ ⟨⟨w, hw⟩, rfl⟩
exact hx w hw
intros
rw [matrix.to_bilin'_aux, coe_fn_mk, sum_eq_single i, sum_eq_single j]
simp only [std_basis_same, std_basis_same, one_mul, mul_one]
{ simp only [std_basis_same, std_basis_same, one_mul, mul_one] }
rintros j' - hj'
{ rintros j' - hj', apply mul_eq_zero_of_right, exact std_basis_ne R₂ (λ _, R₂) _ _ hj' 1 }
apply mul_eq_zero_of_right
exact std_basis_ne R₂ (λ _, R₂) _ _ hj' 1
intros
{ intros, have := finset.mem_univ j, contradiction }
have := finset.mem_univ j
contradiction
rintros i' - hi'
{ rintros i' - hi', refine finset.sum_eq_zero (λ j _, _), apply mul_eq_zero_of_left, apply mul_eq_zero_of_left, exact std_basis_ne R₂ (λ _, R₂) _ _ hi' 1 }
refine finset.sum_eq_zero (λ j _, _)
apply mul_eq_zero_of_left
apply mul_eq_zero_of_left
exact std_basis_ne R₂ (λ _, R₂) _ _ hi' 1
intros
{ intros, have := finset.mem_univ i, contradiction }
have := finset.mem_univ i
contradiction
intros
ext : 1
dsimp
ext
all_goals { dsimp, rw to_quaternion_ι, dsimp, simp only [to_quaternion_ι, zero_smul, one_smul, zero_add, add_zero, ring_hom.map_zero], }
dsimp
rw to_quaternion_ι
dsimp
simp only [to_quaternion_ι, zero_smul, one_smul, zero_add, add_zero, ring_hom.map_zero]
dsimp
rw to_quaternion_ι
dsimp
simp only [to_quaternion_ι, zero_smul, one_smul, zero_add, add_zero, ring_hom.map_zero]
intros
rw [← det_comm' hM'M hMM', ← matrix.mul_assoc, hM'M, matrix.one_mul]
intros
have : (⊥ : submodule R M) ≃ₗ[R] punit := bot_equiv_punit
rw [this.dim_eq, dim_punit]
intros
rw [dim_fun_eq_lift_mul, dim_self, cardinal.lift_one, mul_one, cardinal.nat_cast_inj]
intros
unfold has_generalized_eigenvalue at *
contrapose! hk
rw [←le_bot_iff, ←hk]
exact (f.generalized_eigenspace μ).monotone hm
intros
haveI : finite_dimensional K V := of_fintype_basis h
have := dim_eq_card_basis h
rw ← finrank_eq_dim at this
exact_mod_cast this
intros
rw [← dim_eq_zero, ← finrank_eq_dim, ← @nat.cast_zero cardinal, cardinal.nat_cast_inj]
intros
ext l a
by_cases a ∈ s; simp [h]
by_cases a ∈ s
simp [h]
simp [h]
exact ((mem_supported' R l.1).1 l.2 a h).symm
intros
simp [linear_independent_comp_subtype]
intros
split_ifs; simp [h, nat_degree_X_sub_C_le]
split_ifs
simp [h, nat_degree_X_sub_C_le]
simp [h, nat_degree_X_sub_C_le]
intros
rw [← det_transpose, ← update_row_transpose, det_update_row_add]
simp [update_row_transpose, det_transpose]
intros
ext i j
simp only [linear_map.to_matrix_apply, module.dual.transpose_apply, B₁.dual_basis_repr, B₂.dual_basis_apply, matrix.transpose_apply, linear_map.comp_apply]
intros
rw [matrix.to_lin_apply, finset.sum_congr rfl (λ j hj, _)]
rw [basis.repr_self, matrix.mul_vec, dot_product, finset.sum_eq_single i, finsupp.single_eq_same, mul_one]
intros i' _ i'_ne
{ intros i' _ i'_ne, rw [finsupp.single_eq_of_ne i'_ne.symm, mul_zero] }
rw [finsupp.single_eq_of_ne i'_ne.symm, mul_zero]
intros
{ intros, have := finset.mem_univ i, contradiction }
have := finset.mem_univ i
contradiction
intros
simpa using list_transvec_col_mul_last_row_drop M i (zero_le _)
intros
rw [← update_cons_zero x m (x+y), f.map_add, update_cons_zero, update_cons_zero]
intros
{ ext, simp, }
ext
simp
intros
ext ⟨x, y⟩; simp [and.left_comm, eq_comm]
ext ⟨x, y⟩
simp [and.left_comm, eq_comm]
intros
{ simp only [polar, pi.smul_apply, smul_sub] }
simp only [polar, pi.smul_apply, smul_sub]
intros
refine disjoint.mono (supr_range_std_basis_le_infi_ker_proj _ _ _ _ $ disjoint_compl_right) (supr_range_std_basis_le_infi_ker_proj _ _ _ _ $ disjoint_compl_right) _
simp only [disjoint, set_like.le_def, mem_infi, mem_inf, mem_ker, mem_bot, proj_apply, funext_iff]
rintros b ⟨hI, hJ⟩ i
classical
by_cases hiI : i ∈ I
by_cases hiJ : i ∈ J
{ by_cases hiJ : i ∈ J, { exact (h ⟨hiI, hiJ⟩).elim }, { exact hJ i hiJ } }
{ exact (h ⟨hiI, hiJ⟩).elim }
exact (h ⟨hiI, hiJ⟩).elim
{ exact hJ i hiJ }
exact hJ i hiJ
{ exact hI i hiI }
exact hI i hiI
intros
simp only [ltensor, rtensor, ← map_comp, id_comp, comp_id]
intros
simp [set_value]
intros
rwa sometimes_eq
intros
haveI := hs.principal_is_measurably_generated; exact filter.inf_is_measurably_generated _ _
haveI := hs.principal_is_measurably_generated
exact filter.inf_is_measurably_generated _ _
intros
{ rw ← prod_swap at hf, exact hf.comp_measurable measurable_swap }
rw ← prod_swap at hf
exact hf.comp_measurable measurable_swap
intros
refine integrable.ae_eq_of_with_densityᵥ_eq (integrable_rn_deriv _ _) (integrable_rn_deriv _ _).neg _
rw [with_densityᵥ_neg, ← add_right_inj ((-s).singular_part μ), singular_part_add_with_density_rn_deriv_eq, singular_part_neg, ← neg_add, singular_part_add_with_density_rn_deriv_eq]
intros
have h : ae_measurable' m (condexp_L2 ℝ hm (indicator_const_Lp 2 hs hμs (1 : ℝ))) μ
from ae_measurable'_condexp_L2 _ _
rw condexp_ind_smul
suffices : ae_measurable' m ((to_span_singleton ℝ x) ∘ (condexp_L2 ℝ hm (indicator_const_Lp 2 hs hμs (1 : ℝ)))) μ
refine ae_measurable'.congr this _
{ refine ae_measurable'.congr this _, refine eventually_eq.trans _ (coe_fn_comp_LpL _ _).symm, rw Lp_meas_coe, }
refine eventually_eq.trans _ (coe_fn_comp_LpL _ _).symm
rw Lp_meas_coe
exact ae_measurable'.measurable_comp (to_span_singleton ℝ x).measurable h
intros
ext1
change Lp_trim_to_Lp_meas F ℝ 1 μ hm (indicator_const_Lp 1 hs hμs c) =ᵐ[μ] (indicator_const_Lp 1 _ _ c : α → F)
refine (Lp_trim_to_Lp_meas_ae_eq hm _).trans _
exact (ae_eq_of_ae_eq_trim indicator_const_Lp_coe_fn).trans indicator_const_Lp_coe_fn.symm
intros
obtain ⟨g, hg_sm, hfg⟩ := Lp_meas.ae_fin_strongly_measurable' hm f hp_ne_zero hp_ne_top
refine hfg.trans _
refine ae_eq_zero_of_forall_set_integral_eq_of_fin_strongly_measurable_trim hm _ _ hg_sm
intros s hs hμs
{ intros s hs hμs, have hfg_restrict : f =ᵐ[μ.restrict s] g, from ae_restrict_of_ae hfg, rw [integrable_on, integrable_congr hfg_restrict.symm], exact hf_int_finite s hs hμs, }
have hfg_restrict : f =ᵐ[μ.restrict s] g
from ae_restrict_of_ae hfg
from ae_restrict_of_ae hfg
rw [integrable_on, integrable_congr hfg_restrict.symm]
exact hf_int_finite s hs hμs
intros s hs hμs
{ intros s hs hμs, have hfg_restrict : f =ᵐ[μ.restrict s] g, from ae_restrict_of_ae hfg, rw integral_congr_ae hfg_restrict.symm, exact hf_zero s hs hμs, }
have hfg_restrict : f =ᵐ[μ.restrict s] g
from ae_restrict_of_ae hfg
from ae_restrict_of_ae hfg
rw integral_congr_ae hfg_restrict.symm
exact hf_zero s hs hμs
intros
haveI hμ_ne_bot : μ.ae.ne_bot
rwa [ne_bot_iff, ne.def, ae_eq_bot]
{ rwa [ne_bot_iff, ne.def, ae_eq_bot] }
exact limsup_const c
intros
have : ∀ᵐ a ∂μ, ∥f₁ a∥ ≤ ∥f₀ a∥ + g a
apply h.mono
{ apply h.mono, intros a ha, calc ∥f₁ a∥ ≤ ∥f₀ a∥ + ∥f₀ a - f₁ a∥ : norm_le_insert _ _ ... ≤ ∥f₀ a∥ + g a : add_le_add_left ha _ }
intros a ha
calc ∥f₁ a∥ ≤ ∥f₀ a∥ + ∥f₀ a - f₁ a∥ : norm_le_insert _ _ ... ≤ ∥f₀ a∥ + g a : add_le_add_left ha _
exact integrable.mono' (hf₀_i.norm.add hg_i) hf₁_m this
intros
simp [integrable.to_L1, snorm, snorm']
{ simp [integrable.to_L1, snorm, snorm'], simp [edist_eq_coe_nnnorm_sub] }
simp [edist_eq_coe_nnnorm_sub]
intros
{ cases f, simp [mem_ℒp.to_Lp] }
cases f
simp [mem_ℒp.to_Lp]
intros
rw tendsto_iff_dist_tendsto_zero
simp_rw dist_def
rw [← ennreal.zero_to_real, ennreal.tendsto_to_real_iff (λ n, _) ennreal.zero_ne_top]
rw snorm_congr_ae (Lp.coe_fn_sub _ _).symm
exact Lp.snorm_ne_top _
intros
suffices h_set_eq : {x : α | f x = g x} = {x | (f-g) x = (0 : E)}
rw h_set_eq
{ rw h_set_eq, exact (hf.sub hg) measurable_set_eq, }
exact (hf.sub hg) measurable_set_eq
ext
simp_rw [set.mem_set_of_eq, pi.sub_apply, sub_eq_zero]
intros
rw [← f.integral_eq_integral hfi, simple_func.integral, ← simple_func.integral_eq]
{ rw [← f.integral_eq_integral hfi, simple_func.integral, ← simple_func.integral_eq], refl, }
refl
intros
simp [integral, set_to_simple_func, weighted_smul_apply]
intros
rw [integrable_on, measure.restrict_restrict hs]
{ rw [integrable_on, measure.restrict_restrict hs], exact h.mono_set (inter_subset_left _ _) }
exact h.mono_set (inter_subset_left _ _)
intros
cases le_total a b with hab hab
simp only [interval_of_le, min_eq_left, max_eq_right, hab] at hcont hderiv hint
{ simp only [interval_of_le, min_eq_left, max_eq_right, hab] at hcont hderiv hint, apply integral_eq_sub_of_has_deriv_right_of_le hab hcont hderiv hint }
apply integral_eq_sub_of_has_deriv_right_of_le hab hcont hderiv hint
simp only [interval_of_ge, min_eq_right, max_eq_left, hab] at hcont hderiv
{ simp only [interval_of_ge, min_eq_right, max_eq_left, hab] at hcont hderiv, rw [integral_symm, integral_eq_sub_of_has_deriv_right_of_le hab hcont hderiv hint.symm, neg_sub] }
rw [integral_symm, integral_eq_sub_of_has_deriv_right_of_le hab hcont hderiv hint.symm, neg_sub]
intros
simp only [interval_integral, measure.restrict_smul, integral_smul_measure, smul_sub]
intros
rw [← add_neg_eq_zero, ← integral_symm, integral_add_adjacent_intervals_cancel hab hbc]
intros
simp
intros
rw [ne.def, ← measure.measure_univ_eq_zero] at hμ
refine lintegral_strict_mono_of_ae_le_of_ae_lt_on hf hg hfi (ae_le_of_ae_lt h) hμ _
simpa using h
intros
ext1 s hs
simp [with_density_apply _ hs]
intros
rw [ennreal_rat_embed, encodable.encodek]; refl
rw [ennreal_rat_embed, encodable.encodek]
refl
intros
let npf := (∫⁻ (c : α), (f c) ^ p ∂μ) ^ (1/p)
let nqg := (∫⁻ (c : α), (g c) ^ q ∂μ) ^ (1/q)
calc ∫⁻ (a : α), (f * g) a ∂μ = ∫⁻ (a : α), ((fun_mul_inv_snorm f p μ * fun_mul_inv_snorm g q μ) a) * (npf * nqg) ∂μ : begin refine lintegral_congr (λ a, _), rw [pi.mul_apply, fun_eq_fun_mul_inv_snorm_mul_snorm f hf_nonzero hf_nontop, fun_eq_fun_mul_inv_snorm_mul_snorm g hg_nonzero hg_nontop, pi.mul_apply], ring, end ... ≤ npf * nqg : begin rw lintegral_mul_const' (npf * nqg) _ (by simp [hf_nontop, hg_nontop, hf_nonzero, hg_nonzero]), nth_rewrite 1 ←one_mul (npf * nqg), refine mul_le_mul _ (le_refl (npf * nqg)), have hf1 := lintegral_rpow_fun_mul_inv_snorm_eq_one hpq.pos hf hf_nonzero hf_nontop, have hg1 := lintegral_rpow_fun_mul_inv_snorm_eq_one hpq.symm.pos hg hg_nonzero hg_nontop, exact lintegral_mul_le_one_of_lintegral_rpow_eq_one hpq (hf.mul_const _) (hg.mul_const _) hf1 hg1, end
intros
casesI is_empty_or_nonempty α; simp [set_to_simple_func]
casesI is_empty_or_nonempty α
simp [set_to_simple_func]
simp [set_to_simple_func]
intros
rw union_eq_Union
{ rw union_eq_Union, exact measurable_set.Union (bool.forall_bool.2 ⟨h₂, h₁⟩) }
exact measurable_set.Union (bool.forall_bool.2 ⟨h₂, h₁⟩)
intros
rcases index_elim hK' hV with ⟨s, h1s, h2s⟩
apply nat.Inf_le
rw [mem_image]
refine ⟨s, subset.trans h h1s, h2s⟩
intros
rintros s t ⟨r, r0, hr⟩
refine tendsto_nhds_unique_of_eventually_eq (mk_metric'.tendsto_pre _ _) ((mk_metric'.tendsto_pre _ _).add (mk_metric'.tendsto_pre _ _)) _
rw [← pos_iff_ne_zero] at r0
filter_upwards [Ioo_mem_nhds_within_Ioi ⟨le_rfl, r0⟩]
rintro ε ⟨ε0, εr⟩
refine bounded_by_union_of_top_of_nonempty_inter _
rintro u ⟨x, hxs, hxu⟩ ⟨y, hyt, hyu⟩
have : ε < diam u
from εr.trans_le ((hr x hxs y hyt).trans $ edist_le_diam_of_mem hxu hyu)
exact infi_eq_top.2 (λ h, (this.not_le h).elim)
intros
simp only [volume_Icc_pi, ennreal.to_real_prod, ennreal.to_real_of_real (sub_nonneg.2 (h _))]
intros
intros s hs
rcases exists_measurable_superset_of_null hs with ⟨t, h1t, h2t, h3t⟩
exact measure_mono_null h1t (h h2t h3t)
intros
ext1 t ht
rw [@measure.restrict_apply α m _ _ _ ht, trim_measurable_set_eq hm ht, measure.restrict_apply (hm t ht), trim_measurable_set_eq hm (@measurable_set.inter α m t s ht hs)]
intros
intros t ht
suffices : μ (t ∩ s ∪ t ∩ s') ≤ μ (t ∩ s) + μ (t ∩ s')
simpa [ht, inter_union_distrib_left]
simpa [ht, inter_union_distrib_left]
apply measure_union_le
intros
rw [filter.eventually_le, ae_iff]
rw ae_iff at h
refine measure_mono_null (λ x hx, _) h
exact not_lt.2 (le_of_lt (not_le.1 hx))
intros
simp_rw [Inf_eq_bounded_by_Inf_gen, bounded_by_apply, supr_Inf_gen_nonempty h]
intros
ext i hi
rw [with_densityᵥ_apply hfi hi, integral_eq_lintegral_pos_part_sub_lintegral_neg_part hfi.integrable_on, vector_measure.sub_apply, to_signed_measure_apply_measurable hi, to_signed_measure_apply_measurable hi, with_density_apply _ hi, with_density_apply _ hi]
intros
ext x
cases x; simp [nat.succ_ne_zero]
cases x
simp [nat.succ_ne_zero]
simp [nat.succ_ne_zero]
{ rw bernoulli'_def, norm_num [sum_range_succ] }
rw bernoulli'_def
norm_num [sum_range_succ]
intros
have inj : function.injective (algebra_map R L)
rw is_scalar_tower.algebra_map_eq R S L
{ rw is_scalar_tower.algebra_map_eq R S L, exact (is_integral_closure.algebra_map_injective S R L).comp bS.algebra_map_injective }
exact (is_integral_closure.algebra_map_injective S R L).comp bS.algebra_map_injective
obtain ⟨a', b', hb', h⟩ := is_integral_closure.exists_smul_eq_mul h inj a hb
obtain ⟨q, r, hr, hqr⟩ := exists_mem_finset_approx bS adm a' hb'
refine ⟨q, r, hr, _⟩
refine lt_of_mul_lt_mul_left _ (show 0 ≤ abv (algebra.norm R (algebra_map R S b')), from abv.nonneg _)
refine lt_of_le_of_lt (le_of_eq _) (mul_lt_mul hqr (le_refl _) (abv.pos ((algebra.norm_ne_zero_iff_of_basis bS).mpr hb)) (abv.nonneg _))
rw [← abv.map_mul, ← monoid_hom.map_mul, ← abv.map_mul, ← monoid_hom.map_mul, ← algebra.smul_def, smul_sub b', sub_mul, smul_comm, h, mul_comm b a', algebra.smul_mul_assoc r a' b, algebra.smul_mul_assoc b' q b]
intros
rw [divisors_eq_proper_divisors_insert_self_of_pos h.pos, sum_insert proper_divisors.not_self_mem, h.sum_proper_divisors]
intros
rw @padic_val_nat_def _ prime _ nonzero
let one_le_mul : _ ≤ multiplicity p n := @multiplicity.le_multiplicity_of_pow_dvd _ _ _ p n 1 (begin norm_num, exact div end)
simp only [nat.cast_one] at one_le_mul
rcases one_le_mul with ⟨_, q⟩
dsimp at q
solve_by_elim
intros
{ delta pythagorean_triple, rw add_comm }
delta pythagorean_triple
rw add_comm
intros
simpa using zsqrtd.add_le_add_left _ _ h (-c)
intros
rw [disjoint_iff, h.eq_bot_of_le (inf_le_right.trans hle)]
intros
simp only [insert_eq, bdd_above_union, bdd_above_singleton, true_and]
intros
simpa only [inf_comm] using binfi_inf h
intros
rw [supr, range_const, cSup_singleton]
intros
rintros ⟨M, hM⟩
cases mem_at_top_sets.mp (h $ Ioi_mem_at_top M) with a ha
apply lt_irrefl M
calc M < f a : ha a (le_refl _) ... ≤ M : hM (set.mem_range_self a)
intros
simpa only [div_eq_mul_inv] using hf.at_bot_mul_const (inv_pos.2 hr)
intros
rw [← h.is_basis.filter_eq_generate, h.filter_eq]
intros
simp only [imp_iff_not_or, eventually_or_distrib_right, not_frequently]
intros
rw [filter.comap_comap, H, ← filter.comap_comap]
intros
apply le_antisymm
calc map f (F ⊓ comap f G) ≤ map f F ⊓ (map f $ comap f G) : map_inf_le ... ≤ map f F ⊓ G : inf_le_inf_left (map f F) map_comap_le
{ calc map f (F ⊓ comap f G) ≤ map f F ⊓ (map f $ comap f G) : map_inf_le ... ≤ map f F ⊓ G : inf_le_inf_left (map f F) map_comap_le }
rintro U ⟨V, V_in, W, ⟨Z, Z_in, hZ⟩, h⟩
{ rintro U ⟨V, V_in, W, ⟨Z, Z_in, hZ⟩, h⟩, apply mem_inf_of_inter (image_mem_map V_in) Z_in, calc f '' V ∩ Z = f '' (V ∩ f ⁻¹' Z) : by rw image_inter_preimage ... ⊆ f '' (V ∩ W) : image_subset _ (inter_subset_inter_right _ ‹_›) ... = f '' (f ⁻¹' U) : by rw h ... ⊆ U : image_preimage_subset f U }
apply mem_inf_of_inter (image_mem_map V_in) Z_in
calc f '' V ∩ Z = f '' (V ∩ f ⁻¹' Z) : by rw image_inter_preimage ... ⊆ f '' (V ∩ W) : image_subset _ (inter_subset_inter_right _ ‹_›) ... = f '' (f ⁻¹' U) : by rw h ... ⊆ U : image_preimage_subset f U
intros
simp [Coprod_ne_bot_iff', *]
intros
rw [← e.bdd_above_image, e.image_preimage]
intros
have := partial_order.ext H
have ss := funext (λ x, funext $ semilattice_inf.ext_inf H x)
casesI A
casesI B
injection this; congr'
injection this
congr'
intros
intro
intro; rw c.map_id; refl
intro; rw c.map_id
rw c.map_id
refl
intros
simp only [supr, hf.map_cSup (range_nonempty _) hg, ← range_comp]
intros
rw [(Δ), sup_idem, sdiff_self]
intros
refine le_antisymm (is_wf.min_le _ _ (mem_mul.2 ⟨_, _, hs.min_mem _, ht.min_mem _, rfl⟩)) _
rw is_wf.le_min_iff
rintros _ ⟨x, y, hx, hy, rfl⟩
exact mul_le_mul' (hs.min_le _ hx) (ht.min_le _ hy)
intros
intros t1 t2 ht1 ht2
rw set.mem_Union at ht1
cases ht1 with n ht1
exact hyp n t1 t2 ht1 ht2
intros
obtain ⟨p, ne_zero, aeval_eq⟩ := hx
rw [subalgebra.aeval_coe, subalgebra.coe_eq_zero] at aeval_eq
revert ne_zero aeval_eq
refine p.rec_on_horner _ _ _
intro h
{ intro h, contradiction }
contradiction
intros p a hp ha ih ne_zero aeval_eq
{ intros p a hp ha ih ne_zero aeval_eq, refine A.inv_mem_of_root_of_coeff_zero_ne_zero aeval_eq _, rwa [coeff_add, hp, zero_add, coeff_C, if_pos rfl] }
refine A.inv_mem_of_root_of_coeff_zero_ne_zero aeval_eq _
rwa [coeff_add, hp, zero_add, coeff_C, if_pos rfl]
intros p hp ih ne_zero aeval_eq
{ intros p hp ih ne_zero aeval_eq, rw [alg_hom.map_mul, aeval_X, mul_eq_zero] at aeval_eq, cases aeval_eq with aeval_eq x_eq, { exact ih hp aeval_eq }, { rw [x_eq, subalgebra.coe_zero, inv_zero], exact A.zero_mem } }
rw [alg_hom.map_mul, aeval_X, mul_eq_zero] at aeval_eq
cases aeval_eq with aeval_eq x_eq
{ exact ih hp aeval_eq }
exact ih hp aeval_eq
rw [x_eq, subalgebra.coe_zero, inv_zero]
{ rw [x_eq, subalgebra.coe_zero, inv_zero], exact A.zero_mem }
exact A.zero_mem
intros
{ rw is_coprime_comm at H ⊢, exact H.of_mul_left_left }
rw is_coprime_comm at H ⊢
exact H.of_mul_left_left
intros
have : wf_dvd_monoid R := is_noetherian_ring.wf_dvd_monoid
cases wf_dvd_monoid.exists_factors x hx with fx hfx
use fx.card
unfreezingI { use fx.card }
have H := hfx.2
rw ← associates.mk_eq_mk_iff_associated at H ⊢
rw [← H, ← associates.prod_mk, associates.mk_pow, ← multiset.prod_repeat]
congr' 1
rw multiset.eq_repeat
simp only [true_and, and_imp, multiset.card_map, eq_self_iff_true, multiset.mem_map, exists_imp_distrib]
rintros _ _ _ rfl
rw associates.mk_eq_mk_iff_associated
refine associated_of_irreducible _ _ hirr
apply hfx.1
assumption
intros
convert mul_left_mono I hI
exact (mul_one I).symm
intros
rw [emb_domain_apply, dif_pos (set.mem_range_self a)]
exact congr rfl (f.injective (classical.some_spec (set.mem_range_self a)))
intros
split
intro hg
{ intro hg, obtain ⟨ua, hua, ha⟩ := exists_unit_of_abs a, obtain ⟨ub, hub, hb⟩ := exists_unit_of_abs b, use [(nat.gcd_a (int.nat_abs a) (int.nat_abs b)) * ua, (nat.gcd_b (int.nat_abs a) (int.nat_abs b)) * ub], rw [mul_assoc, ← ha, mul_assoc, ← hb, mul_comm, mul_comm _ (int.nat_abs b : ℤ), ← nat.gcd_eq_gcd_ab, ←gcd_eq_nat_abs, hg, int.coe_nat_one] }
obtain ⟨ua, hua, ha⟩ := exists_unit_of_abs a
obtain ⟨ub, hub, hb⟩ := exists_unit_of_abs b
use [(nat.gcd_a (int.nat_abs a) (int.nat_abs b)) * ua, (nat.gcd_b (int.nat_abs a) (int.nat_abs b)) * ub]
rw [mul_assoc, ← ha, mul_assoc, ← hb, mul_comm, mul_comm _ (int.nat_abs b : ℤ), ← nat.gcd_eq_gcd_ab, ←gcd_eq_nat_abs, hg, int.coe_nat_one]
rintro ⟨r, s, h⟩
{ rintro ⟨r, s, h⟩, by_contradiction hg, obtain ⟨p, ⟨hp, ha, hb⟩⟩ := nat.prime.not_coprime_iff_dvd.mp hg, apply nat.prime.not_dvd_one hp, rw [←coe_nat_dvd, int.coe_nat_one, ← h], exact dvd_add ((coe_nat_dvd_left.mpr ha).mul_left _) ((coe_nat_dvd_left.mpr hb).mul_left _) }
by_contradiction hg
obtain ⟨p, ⟨hp, ha, hb⟩⟩ := nat.prime.not_coprime_iff_dvd.mp hg
apply nat.prime.not_dvd_one hp
rw [←coe_nat_dvd, int.coe_nat_one, ← h]
exact dvd_add ((coe_nat_dvd_left.mpr ha).mul_left _) ((coe_nat_dvd_left.mpr hb).mul_left _)
intros
rw ←map_comp_map hy hl; refl
rw ←map_comp_map hy hl
refl
intros
by_cases H : ∃ (s : finset L), nonempty (basis s K L)
rw [norm_algebra_map_of_basis H.some_spec.some, finrank_eq_card_basis H.some_spec.some]
{ rw [norm_algebra_map_of_basis H.some_spec.some, finrank_eq_card_basis H.some_spec.some] }
rw [norm_eq_one_of_not_exists_basis K H, finrank_eq_zero_of_not_exists_basis, pow_zero]
{ rw [norm_eq_one_of_not_exists_basis K H, finrank_eq_zero_of_not_exists_basis, pow_zero], rintros ⟨s, ⟨b⟩⟩, exact H ⟨s, ⟨b⟩⟩ }
rintros ⟨s, ⟨b⟩⟩
exact H ⟨s, ⟨b⟩⟩
intros
rw U
intros
rw [is_primitive_iff_content_eq_one, content_mul, hp.content_eq_one, hq.content_eq_one, mul_one]
intros
have hdeg := degree_cyclotomic n R
rw degree_eq_nat_degree (cyclotomic_ne_zero n R) at hdeg
exact_mod_cast hdeg
intros
cases n
{ simp, }
simp
{ simp [X_mul, nat.succ_ne_zero, pochhammer_succ_left], }
simp [X_mul, nat.succ_ne_zero, pochhammer_succ_left]
intros
convert pb.constr_pow_aeval hy (C x); rw aeval_C
{ convert pb.constr_pow_aeval hy (C x); rw aeval_C }
convert pb.constr_pow_aeval hy (C x)
rw aeval_C
rw aeval_C
intros
ext
simp only [linear_map.map_neg, coeff_rescale, coeff_X]
split_ifs with h; simp [h]
split_ifs with h
simp [h]
simp [h]
intros
rw [monomial, finsupp.single_zero, mv_power_series.monomial_zero_eq_C, C]
intros
rcases ((factors_spec a ha).2) with ⟨c, hc⟩
rw [← hc]
exact submonoid.mul_mem _ (submonoid.multiset_prod_mem _ _ hfac) (hunit _)
intros
ext x
refine ⟨λ hx, _, λ hx, closure_mono add_submonoid.subset_closure hx⟩
rintros - ⟨H, rfl⟩
rintros - ⟨J, rfl⟩
refine (add_submonoid.mem_closure.mp (mem_closure_iff.mp hx)) H.to_add_submonoid (λ y hy, _)
refine (submonoid.mem_closure.mp hy) H.to_submonoid (λ z hz, _)
exact (add_submonoid.mem_closure.mp hz) H.to_add_submonoid (λ w hw, J hw)
intros
apply mv_polynomial.map_injective (int.cast_ring_hom ℚ) int.cast_injective
simp only [witt_one, witt_structure_rat, X_in_terms_of_W_zero, alg_hom.map_one, ring_hom.map_one, bind₁_X_right, map_witt_structure_int]
intros
{ ghost_calc x, ghost_simp [mul_comm] }
ghost_calc x
ghost_simp [mul_comm]
intros
witt_truncate_fun_tac
intros
{ rw [X_in_terms_of_W, ← fin.sum_univ_eq_sum_range] }
rw [X_in_terms_of_W, ← fin.sum_univ_eq_sum_range]
intros
{ rcases powerlt_aux h with ⟨s, rfl⟩, apply le_sup _ s }
rcases powerlt_aux h with ⟨s, rfl⟩
apply le_sup _ s
intros
rw [add_comm, ← card_ord c, ← card_one, ← card_add, one_add_of_omega_le]
rw [add_comm, ← card_ord c, ← card_one, ← card_add, one_add_of_omega_le]; rwa [← ord_omega, ord_le_ord]
rwa [← ord_omega, ord_le_ord]
intros
cases n; rw lt_def_le; use ⟨punit.star, pgame.le_refl 0⟩
cases n; rw lt_def_le
cases n
rw lt_def_le
use ⟨punit.star, pgame.le_refl 0⟩
rw lt_def_le
use ⟨punit.star, pgame.le_refl 0⟩
intros
simp [h₁.symm, h₂.symm, term, add_nsmul]; ac_refl
simp [h₁.symm, h₂.symm, term, add_nsmul]
ac_refl
intros
simpa [normalize_fin_lt, ← e, ← hm] using h
intros
constructor; intro h1
constructor
intro h1
cases h1 with v h1
{ cases h1 with v h1, cases h1 with h1 h1; [left,right]; refine ⟨v,_⟩; assumption }
cases h1 with h1 h1
cases h1 with h1 h1; [left,right]; refine ⟨v,_⟩; assumption
cases h1 with h1 h1; [left,right]; refine ⟨v,_⟩
cases h1 with h1 h1; [left,right]
left
refine ⟨v,_⟩
assumption
assumption
right
refine ⟨v,_⟩
assumption
assumption
intro h1
cases h1 with h1 h1; cases h1 with v h1; refine ⟨v,_⟩; [left,right]; assumption
cases h1 with h1 h1; cases h1 with v h1; refine ⟨v,_⟩; [left,right]
cases h1 with h1 h1; cases h1 with v h1; refine ⟨v,_⟩
cases h1 with h1 h1; cases h1 with v h1
cases h1 with h1 h1
{ cases h1 with h1 h1; cases h1 with v h1; refine ⟨v,_⟩; [left,right]; assumption }
cases h1 with v h1
refine ⟨v,_⟩
left
assumption
assumption
cases h1 with v h1
refine ⟨v,_⟩
right
assumption
assumption
intros
rw [← h₂, ← h₁, pow_succ']
intros
simp only [list.apply_id, list.lookup, eq_rec_constant, prod.to_sigma, list.map]
simp only [list.apply_id, list.lookup, eq_rec_constant, prod.to_sigma, list.map]; split_ifs; refl
simp only [list.apply_id, list.lookup, eq_rec_constant, prod.to_sigma, list.map]; split_ifs
split_ifs
refl
refl
intros
simp only [le_nhds_infty, ← compl_image_coe, ultrafilter.mem_coe, ultrafilter.compl_mem_iff_not_mem]
intros
convert is_closed_closure
intros
have hfg := hf.add hg
ext x
apply completion.induction_on x
exact is_closed_eq ((f+g).continuous_completion hfg) ((f.continuous_completion hf).add (g.continuous_completion hg))
{ exact is_closed_eq ((f+g).continuous_completion hfg) ((f.continuous_completion hf).add (g.continuous_completion hg)) }
intro a
{ intro a, simp [(f+g).completion_coe hfg, coe_add, f.completion_coe hf, g.completion_coe hg] }
simp [(f+g).completion_coe hfg, coe_add, f.completion_coe hf, g.completion_coe hg]
intros
simp_rw ← nat.sum_antidiagonal_eq_sum_range_succ (λ k l, f k * g l)
exact tsum_mul_tsum_eq_tsum_sum_antidiagonal hf hg hfg
intros
rw (has_sum_ite_eq_extract hf.has_sum b).tsum_eq
exact (add_sub_cancel'_right _ _).symm
intros
{ conv in (_ + _) { rw add_comm }, exact hg.add_at_bot hf }
conv in (_ + _) { rw add_comm }
exact hg.add_at_bot hf
intros
apply subset.antisymm
exact closure_minimal Ico_subset_Icc_self is_closed_Icc
{ exact closure_minimal Ico_subset_Icc_self is_closed_Icc }
apply subset.trans _ (closure_mono Ioo_subset_Ico_self)
{ apply subset.trans _ (closure_mono Ioo_subset_Ico_self), rw closure_Ioo hab }
rw closure_Ioo hab
intros
have sne : s.nonempty := @nonempty_of_not_bdd_above α _ s ⟨Inf ∅⟩ ha
intros x hx
obtain ⟨y, ys, hy⟩ : ∃ y ∈ s, y < x := (is_glb_lt_iff (is_glb_cInf sne hb)).1 hx
obtain ⟨z, zs, hz⟩ : ∃ z ∈ s, x < z := not_bdd_above_iff.1 ha x
exact hs.Icc_subset ys zs ⟨le_of_lt hy, le_of_lt hz⟩
intros
rw [← nhds_within_union, Iio_union_Ici, nhds_within_univ]
intros
rw [← mem_compl_eq, ← interior_compl, mem_interior_iff_mem_nhds, function.compl_support]
rw [← mem_compl_eq, ← interior_compl, mem_interior_iff_mem_nhds, function.compl_support]; refl
refl
intros
rw [interior, closure, compl_sUnion, compl_image_set_of]
simp only [compl_subset_compl, is_open_compl_iff]
intros
rwa [cluster_pt, inf_eq_right.mpr H]
intros
{ ext, refl }
ext
refl
intros
intros s hs
rw is_closed_sigma_iff
intro j
classical
by_cases h : i = j
subst j
{ subst j, convert hs, exact set.preimage_image_eq _ sigma_mk_injective }
convert hs
exact set.preimage_image_eq _ sigma_mk_injective
convert is_closed_empty
{ convert is_closed_empty, apply set.eq_empty_of_subset_empty, rintro x ⟨y, _, hy⟩, have : i = j, by cc, contradiction }
apply set.eq_empty_of_subset_empty
rintro x ⟨y, _, hy⟩
have : i = j
cc
cc
contradiction
intros
apply polynomial.induction_on' g
{ intros p q hp hq, simp [hp, hq], }
intros p q hp hq
simp [hp, hq]
{ intros n a, simp [pi.pow_apply f x n], }
intros n a
simp [pi.pow_apply f x n]
intros
rw [nhds_within_restrict t h₀ h₁, nhds_within_restrict u h₀ h₁, h₂]
intros
refine ⟨λ h, _, λ h, (eventually_nhds_nhds_within.2 h).filter_mono inf_le_left⟩
simp only [eventually_nhds_within_iff] at h ⊢
exact h.mono (λ x hx hxs, (hx hxs).self_of_nhds hxs)
intros
induction a
erw [fiber_eq, fiber_eq]
tidy
intros
rw [h.symm.map_nhds_eq, h.symm_apply_apply]
intros
{ rw ← tsum_zero, exact tsum_lt_tsum (λ a, zero_le _) hi hg }
rw ← tsum_zero
exact tsum_lt_tsum (λ a, zero_le _) hi hg
intros
cases lt_or_gt_of_ne hc with hneg hpos
exacts [hp.neg.compact_of_continuous' (neg_pos.mpr hneg) hf, hp.compact_of_continuous' hpos hf]
intros
rcases metric.cauchy_seq_iff'.1 hu 1 zero_lt_one with ⟨N, hN⟩
suffices : ∃ R > 0, ∀ n, dist (u n) (u N) < R
rcases this with ⟨R, R0, H⟩
{ rcases this with ⟨R, R0, H⟩, exact ⟨_, add_pos R0 R0, λ m n, lt_of_le_of_lt (dist_triangle_right _ _ _) (add_lt_add (H m) (H n))⟩ }
exact ⟨_, add_pos R0 R0, λ m n, lt_of_le_of_lt (dist_triangle_right _ _ _) (add_lt_add (H m) (H n))⟩
let R := finset.sup (finset.range N) (λ n, nndist (u n) (u N))
refine ⟨↑R + 1, add_pos_of_nonneg_of_pos R.2 zero_lt_one, λ n, _⟩
cases le_or_lt N n
exact lt_of_lt_of_le (hN _ h) (le_add_of_nonneg_left R.2)
{ exact lt_of_lt_of_le (hN _ h) (le_add_of_nonneg_left R.2) }
have : _ ≤ R := finset.le_sup (finset.mem_range.2 h)
{ have : _ ≤ R := finset.le_sup (finset.mem_range.2 h), exact lt_of_le_of_lt this (lt_add_of_pos_right _ zero_lt_one) }
exact lt_of_le_of_lt this (lt_add_of_pos_right _ zero_lt_one)
intros
rw sUnion_eq_Union at hc₂; simpa using lebesgue_number_lemma_of_metric hs (by simpa) hc₂
rw sUnion_eq_Union at hc₂
simpa using lebesgue_number_lemma_of_metric hs (by simpa) hc₂
intros
simpa only [dist_comm x] using abs_sub_left_of_mem_interval h
intros
{ rw [iterate_succ'], apply hf.dist_fixed_point_le }
rw [iterate_succ']
apply hf.dist_fixed_point_le
intros
rw [dimH_univ_pi, fintype.card_fin]
intros
rw [← ennreal.coe_le_coe, ← edist_nndist, ennreal.coe_mul, ← ennreal.coe_rpow_of_nonneg _ r.coe_nonneg]
apply hf.edist_le_of_le
rwa [edist_nndist, ennreal.coe_le_coe]
intros
refl
intros
rcases h with ⟨γ, γ_in⟩
have : γ 0 ∈ F ∧ γ 1 ∈ F
split
split
split; apply γ_in
split; apply γ_in
{ split; apply γ_in }
{ split; apply γ_in }
apply γ_in
apply γ_in
apply γ_in
apply γ_in
simpa using this
intros
rw is_open_iff_ball_subset
split
split; intros h x hx
intros h x hx
obtain ⟨V, hV, hV'⟩ := h x hx
{ obtain ⟨V, hV, hV'⟩ := h x hx, exact ⟨interior V, interior_mem_uniformity hV, is_open_interior, (ball_mono interior_subset x).trans hV'⟩, }
exact ⟨interior V, interior_mem_uniformity hV, is_open_interior, (ball_mono interior_subset x).trans hV'⟩
intros h x hx
obtain ⟨V, hV, -, hV'⟩ := h x hx
{ obtain ⟨V, hV, -, hV'⟩ := h x hx, exact ⟨V, hV, hV'⟩, }
exact ⟨V, hV, hV'⟩
intros
simp [separated_space_iff, id_rel_subset.2 separated_equiv.1, subset.antisymm_iff]
simp [separated_space_iff, id_rel_subset.2 separated_equiv.1, subset.antisymm_iff]; simp [subset_def, separation_rel]
simp [subset_def, separation_rel]
intros
simp [tendsto_locally_uniformly_on, tendsto_locally_uniformly, nhds_within_univ]
intros
rw [mem_Icc, mem_Icc]
split
split ; intro ; split ; linarith
split ; intro ; split
split ; intro
intro
split
linarith
linarith
intro
split
linarith
linarith
intros
cases x; cases x'; simp [show x = x', from funext h]
cases x; cases x'
cases x
cases x'
simp [show x = x', from funext h]
intros
cases a; cases b; exact dec_trivial
cases a; cases b
cases a
cases b
exact dec_trivial
exact dec_trivial
cases b
exact dec_trivial
exact dec_trivial
intros
rw int.mul_comm
simp [of_nat_mul_neg_of_nat, nat.mul_comm]
intros
have h := int.add_le_add_left h (-b)
rwa int.neg_add_cancel_left at h
intros
by_cases hba : b ≤ a
simp [le_antisymm hba h₁]
{ simp [le_antisymm hba h₁] }
by_cases hc0 : c ≤ 0
simp [le_antisymm hc0 h₂, int.mul_zero]
{ simp [le_antisymm hc0 h₂, int.mul_zero] }
exact (le_not_le_of_lt (int.mul_lt_mul_of_pos_right (lt_of_le_not_le h₁ hba) (lt_of_le_not_le h₂ hc0))).left
intros
induction s
{ show length t = 0 + length t, by rw nat.zero_add }
show length t = 0 + length t
rw nat.zero_add
rw nat.zero_add
{ simp [*, nat.add_comm, nat.add_left_comm] }
simp [*, nat.add_comm, nat.add_left_comm]
intros
rw [H2, nat.mul_div_cancel_left _ H1]
intros
{ rw [update_eq_piecewise, prod_piecewise], simp [h] }
rw [update_eq_piecewise, prod_piecewise]
simp [h]
intros
by_cases hm : a ∈ s
{ simp_rw insert_eq_of_mem hm }
simp_rw insert_eq_of_mem hm
{ rw [prod_insert hm, h hm, one_mul] }
rw [prod_insert hm, h hm, one_mul]
intros
{ simp_rw apply_ite k, exact prod_ite_of_false _ _ h }
simp_rw apply_ite k
exact prod_ite_of_false _ _ h
intros
rw [univ_filter_succ_lt, finset.sum_map, rel_embedding.coe_fn_to_embedding, coe_succ_embedding]
intros
{ rw ← finprod_mem_one s, exact finprod_mem_congr rfl hf }
rw ← finprod_mem_one s
exact finprod_mem_congr rfl hf
intros
simp only [finsupp.sum, finset.sum_mul]
intros
convert ← prod_le_prod h0 h1
exact finset.prod_const_one
intros
{ rw ←cocone_naturality F f, refl }
rw ←cocone_naturality F f
refl
intros
rw [eq_comm, ←sub_eq_zero, ←int.cast_sub, char_p.int_cast_eq_zero_iff R p, int.modeq_iff_dvd]
intros
simp only [convergents', (convergents'_aux_stable_of_terminated n_le_m terminated_at_n)]
intros
rw [submodule.supr_eq_range_dfinsupp_lsum, linear_map.range_eq_top]
exact function.bijective.surjective h
intros
{ rw mul_comm, exact div_add_mod _ _ }
rw mul_comm
exact div_add_mod _ _
intros
split
intro hxy
{ intro hxy, rw [lcm, mul_div_assoc _ (gcd_dvd_right _ _), mul_eq_zero] at hxy, apply or_of_or_of_imp_right hxy, intro hy, by_cases hgxy : gcd x y = 0, { rw euclidean_domain.gcd_eq_zero_iff at hgxy, exact hgxy.2 }, { rcases gcd_dvd x y with ⟨⟨r, hr⟩, ⟨s, hs⟩⟩, generalize_hyp : gcd x y = g at hr hs hy hgxy ⊢, subst hs, rw [mul_div_cancel_left _ hgxy] at hy, rw [hy, mul_zero] } }
rw [lcm, mul_div_assoc _ (gcd_dvd_right _ _), mul_eq_zero] at hxy
apply or_of_or_of_imp_right hxy
intro hy
by_cases hgxy : gcd x y = 0
{ rw euclidean_domain.gcd_eq_zero_iff at hgxy, exact hgxy.2 }
rw euclidean_domain.gcd_eq_zero_iff at hgxy
exact hgxy.2
rcases gcd_dvd x y with ⟨⟨r, hr⟩, ⟨s, hs⟩⟩
{ rcases gcd_dvd x y with ⟨⟨r, hr⟩, ⟨s, hs⟩⟩, generalize_hyp : gcd x y = g at hr hs hy hgxy ⊢, subst hs, rw [mul_div_cancel_left _ hgxy] at hy, rw [hy, mul_zero] }
generalize_hyp : gcd x y = g at hr hs hy hgxy ⊢
subst hs
rw [mul_div_cancel_left _ hgxy] at hy
rw [hy, mul_zero]
rintro (hx | hy)
{ rw [hx, lcm_zero_left] }
rw [hx, lcm_zero_left]
{ rw [hy, lcm_zero_right] }
rw [hy, lcm_zero_right]
intros
{ rw mul_comm at H ⊢, exact dvd_gcd_mul_of_dvd_mul H }
rw mul_comm at H ⊢
exact dvd_gcd_mul_of_dvd_mul H
intros
rw [sub_eq_add_neg, eq_add_neg_iff_add_eq]
intros
rw [← neg_sub b c, sub_neg_eq_add, add_comm, sub_add_sub_cancel]
intros
rintros ⟨⟩ ⟨⟩ h
replace h := div_inv_monoid.mk.inj h
dsimp at h
rcases h with ⟨rfl, rfl, rfl, rfl, rfl, rfl⟩
refl
intros
rw [mul_assoc, inv_mul, mul_one]
intros
rw [units.mul_inv_eq_iff_eq_mul, one_mul, coe_lift_right]
intros
simp
intros
rw [← mul_one (m : R)]
{ rw [← mul_one (m : R)], exact (one_right a).cast_int_mul_right m }
exact (one_right a).cast_int_mul_right m
intros
rw [div_eq_mul_inv, mul_self_mul_inv a]
intros
simpa only [one_div] using eq_inv_of_mul_left_eq_one h
intros
rw [div_mul_eq_mul_div, one_mul, div_mul_right _ h]
intros
rcases h₁ : c.next j with _ | ⟨k,w₁⟩
{ rw [d_from_eq_zero _ h₁], simp }
rw [d_from_eq_zero _ h₁]
simp
rw [d_from_eq _ w₁]
{ rw [d_from_eq _ w₁], rcases h₂ : c.prev j with _ | ⟨i,w₂⟩, { rw [d_to_eq_zero _ h₂], simp }, { rw [d_to_eq _ w₂], simp } }
rcases h₂ : c.prev j with _ | ⟨i,w₂⟩
{ rw [d_to_eq_zero _ h₂], simp }
rw [d_to_eq_zero _ h₂]
simp
{ rw [d_to_eq _ w₂], simp }
rw [d_to_eq _ w₂]
simp
intros
dsimp [d_next]
rw c.next_eq_some w
refl
intros
{ dunfold indicator, split_ifs, exacts [rfl, (smul_zero r).symm] }
dunfold indicator
split_ifs
exacts [rfl, (smul_zero r).symm]
intros
split
split; intros h
intros h
erw [eq_bot_iff, lie_submodule.lie_span_le]
{ erw [eq_bot_iff, lie_submodule.lie_span_le], rintros m ⟨x, n, hn⟩, rw [← hn, h.trivial], simp,}
rintros m ⟨x, n, hn⟩
rw [← hn, h.trivial]
simp
intros h
rw lie_submodule.eq_bot_iff at h
{ rw lie_submodule.eq_bot_iff at h, apply is_trivial.mk, intros x m, apply h, apply lie_submodule.subset_lie_span, use [x, m], refl, }
apply is_trivial.mk
intros x m
apply h
apply lie_submodule.subset_lie_span
use [x, m]
refl
intros
{ rw map_le, exact set.image_subset_iff, }
rw map_le
exact set.image_subset_iff
intros
{ cases N, cases N', simp only [], ext m, exact h m, }
cases N
cases N'
simp only []
ext m
exact h m
intros
simp [pre_weight_space, -linear_map.pow_apply]
intros
simp only [←nsmul_eq_smul_cast, f.map_nsmul]
intros
rw [←neg_neg c, neg_smul, neg_smul (-c), neg_le_neg_iff]
exact smul_le_smul_of_nonneg h (neg_nonneg_of_nonpos hc)
intros
rw [lift_def, lift_nc_single, algebra.smul_def, ring_hom.coe_add_monoid_hom]
intros
rw [mul_comm, div_le_iff hb]
intros
rw [inv_mul_le_iff_le_mul, mul_comm]
intros
simpa only [div_eq_mul_inv] using min_mul_mul_right a b (c⁻¹)
intros
cases le_total a b with hb hb
{ simp [hb, le_mul_right] }
simp [hb, le_mul_right]
cases le_total a c with hc hc
{ cases le_total a c with hc hc, { simp [hc, le_mul_left] }, { simp [hb, hc] } }
{ simp [hc, le_mul_left] }
simp [hc, le_mul_left]
{ simp [hb, hc] }
simp [hb, hc]
intros
haveI := @linear_order.decidable_le α _
refine decidable.or_iff_not_and_not.2 _
simp only [not_and, not_le]
intros ab nab
apply not_lt_of_le hab _
rcases lt_trichotomy 0 a with (ha|rfl|ha)
exacts [mul_neg_of_pos_of_neg ha (ab ha.le), ((ab le_rfl).asymm (nab le_rfl)).elim, mul_neg_of_neg_of_pos ha (nab ha.le)]
intros
haveI := @linear_order.decidable_le α _; exact λ x y h, decidable.mul_lt_mul'' (hf h) (hg h) (hf0 x) (hg0 x)
haveI := @linear_order.decidable_le α _
exact λ x y h, decidable.mul_lt_mul'' (hf h) (hg h) (hf0 x) (hg0 x)
intros
simpa only [sub_eq_add_neg, periodic] using h.sub_eq
intros
simp only [mem_inv, inv_inv]
intros
simp [bit1]
intros
simp [bit0]
intros
intros r
rw [submodule.mem_sup, mem_vanishing_ideal]
rintro ⟨f, hf, g, hg, rfl⟩ x ⟨hxt, hxt'⟩
rw mem_vanishing_ideal at hf hg
apply submodule.add_mem; solve_by_elim
apply submodule.add_mem
solve_by_elim
solve_by_elim
intros
rcases hf with ⟨r, s, h⟩
refine ⟨r, s, λ x, ⟨(h x).1, (is_localization.mk'_eq_iff_eq_mul.mpr _).symm⟩⟩
exact (h x).2.symm
intros
{ rw comap_id U U rfl, refl }
rw comap_id U U rfl
refl
intros
continuity
intros
obtain ⟨c, hc⟩ := is_O_iff.mp h
refine ⟨max c 0, eventually_map.2 (filter.mem_of_superset hc (λ x hx, _))⟩
simp only [mem_set_of_eq, normed_field.norm_div] at ⊢ hx
by_cases hgx : g x = 0
rw [hgx, norm_zero, div_zero, le_max_iff]
{ rw [hgx, norm_zero, div_zero, le_max_iff], exact or.inr le_rfl }
exact or.inr le_rfl
exact le_max_iff.2 (or.inl ((div_le_iff (norm_pos_iff.2 hgx)).2 hx))
{ exact le_max_iff.2 (or.inl ((div_le_iff (norm_pos_iff.2 hgx)).2 hx)) }
intros
unfold is_o
{ unfold is_o, exact forall_congr (λ _, forall_congr $ λ _, is_O_with_norm_left) }
exact forall_congr (λ _, forall_congr $ λ _, is_O_with_norm_left)
intros
unfold is_o at *
intros c cpos
rcases h₁.exists_pos with ⟨c', c'pos, hc'⟩
exact (hc'.mul (h₂ (div_pos cpos c'pos))).congr_const (mul_div_cancel' _ (ne_of_gt c'pos))
intros
rw [← has_deriv_within_at_univ] at *
exact hc.mul hd
intros
intro hg
have := (hf.comp a hg.has_deriv_within_at hst).congr_of_eventually_eq_of_mem hfg.symm ha
simpa using hsu.eq_deriv _ this (has_deriv_within_at_id _ _)
intros
simpa using (hf.add hg).has_strict_deriv_at
intros
apply has_fderiv_within_at.fderiv_within _ hxs
exact has_fderiv_within_at.comp x (hg.has_fderiv_within_at) (hf.has_fderiv_within_at) h
intros
simpa only [sub_eq_add_neg] using hf.add hg.neg
intros
{ convert hc.mul_const' d, ext z, apply mul_comm }
convert hc.mul_const' d
ext z
apply mul_comm
intros
rwa [← univ_inter s, has_fderiv_within_at_inter hs, has_fderiv_within_at_univ] at h
intros
refine ((hf.implicit_to_local_homeomorph f f' hf').tendsto_symm (hf.mem_implicit_to_local_homeomorph_source hf')).comp _
rw [implicit_to_local_homeomorph_self]
exact h₁.prod_mk_nhds h₂
intros
{ ext x, simp [iterated_deriv] }
ext x
simp [iterated_deriv]
intros
have hdg : ∀ᶠ x in at_bot, differentiable_at ℝ g x
from hg'.mp (eventually_of_forall $ λ _ hg', classical.by_contradiction (λ h, hg' (deriv_zero_of_not_differentiable_at h)))
have hdf' : ∀ᶠ x in at_bot, has_deriv_at f (deriv f x) x
from hdf.mp (eventually_of_forall $ λ _, differentiable_at.has_deriv_at)
have hdg' : ∀ᶠ x in at_bot, has_deriv_at g (deriv g x) x
from hdg.mp (eventually_of_forall $ λ _, differentiable_at.has_deriv_at)
exact has_deriv_at.lhopital_zero_at_bot hdf' hdg' hg' hfbot hgbot hdiv
intros
rw [euclidean.ball_eq_preimage, ← f.to_times_cont_diff_bump_of_inner.support_eq, ← support_comp_eq_preimage, coe_eq_comp]
intros
simp [← times_cont_diff_within_at_univ, times_cont_diff_within_at_top]
intros
refine ⟨λ H, _, λ H, H.comp_continuous_linear_map _⟩
have A : f = (f ∘ e) ∘ e.symm
ext y
ext y
{ ext y, simp only [function.comp_app], rw e.apply_symm_apply y }
{ ext y, simp only [function.comp_app], rw e.apply_symm_apply y }
simp only [function.comp_app]
simp only [function.comp_app]
rw e.apply_symm_apply y
rw e.apply_symm_apply y
have B : e.symm ⁻¹' (e ⁻¹' s) = s
rw [← preimage_comp, e.self_comp_symm]
rw [← preimage_comp, e.self_comp_symm]
{ rw [← preimage_comp, e.self_comp_symm], refl }
{ rw [← preimage_comp, e.self_comp_symm], refl }
refl
refl
rw [A, ← B]
exact H.comp_continuous_linear_map _
intros
rcases p
exact times_cont_diff_at.prod_map hf hg
intros
assume x xs
rcases h x xs with ⟨u, u_open, xu, hu⟩
apply (times_cont_diff_within_at_inter _).1 (hu x ⟨xs, xu⟩)
exact is_open.mem_nhds u_open xu
intros
apply set.subset.antisymm
rw set.image_subset_iff
{ rw set.image_subset_iff, refine convex_hull_min _ ((convex_convex_hull 𝕜 (⇑f '' s)).affine_preimage f), rw ← set.image_subset_iff, exact subset_convex_hull 𝕜 (f '' s) }
refine convex_hull_min _ ((convex_convex_hull 𝕜 (⇑f '' s)).affine_preimage f)
rw ← set.image_subset_iff
exact subset_convex_hull 𝕜 (f '' s)
exact convex_hull_min (set.image_subset _ (subset_convex_hull 𝕜 s)) ((convex_convex_hull 𝕜 s).affine_image f)
{ exact convex_hull_min (set.image_subset _ (subset_convex_hull 𝕜 s)) ((convex_convex_hull 𝕜 s).affine_image f) }
intros
finish
intros
rw [←ne_empty_iff_nonempty, ←ne_empty_iff_nonempty, ne.def, ne.def]
exact not_congr convex_hull_empty_iff
intros
rintro x hx
obtain ⟨_, rfl⟩ := hAB ⟨x, hx⟩
exact hx.1
intros
refine λ i j hij, hc {j} i _
rw [hij, set.image_singleton, convex_hull_singleton]
exact set.mem_singleton _
intros
conv_rhs { rw [←inner_self_re_to_K] }
symmetry
exact is_R_or_C.abs_of_nonneg inner_self_nonneg
intros
have : ∥v i∥ ≠ 0
rw hv.1 i
{ rw hv.1 i, norm_num }
norm_num
simpa using this
intros
ext
{ ext, apply eq_orthogonal_projection_of_mem_of_inner_eq_zero; simp }
apply eq_orthogonal_projection_of_mem_of_inner_eq_zero
apply eq_orthogonal_projection_of_mem_of_inner_eq_zero; simp
simp
simp
intros
obtain ⟨u, hus, hu, hu_max⟩ := exists_maximal_orthonormal hv
obtain ⟨b, hb⟩ := (maximal_orthonormal_iff_basis_of_finite_dimensional hu).mp hu_max
exact ⟨u, hus, b, by rwa hb, hb⟩
intros
rw [dist_eq_norm_vsub V₂, dist_eq_norm_vsub V, ← map_vsub, f.linear_isometry.norm_map]
intros
rcases s with ⟨⟨l⟩, hl⟩
have : l.map f ≠ []
simpa using hs
simpa using hs
simpa using list.norm_prod_le' this
intros
simpa [real.nnnorm_of_nonneg (norm_nonneg a)]
intros
rw [mem_closed_ball_iff_norm, add_sub_cancel']
intros
simpa only [pi.sub_apply, add_sub_cancel'_right] using hf.add_lipschitz_with hg hK
intros
refine (linear_map.snd 𝕜 E F).is_linear.with_bound 1 (λ x, _)
rw one_mul
exact le_max_right _ _
intros
rw subsingleton_iff at h
have minor : (f' : M → N) = function.const M 0 := by ext x'; rw h x' 0; exact f'.map_zero
have key : ∀ (x' : M), ∥(0 : M →ₗ[R] N) x'∥ = ∥x'∥ := λ x', by { rw [linear_map.zero_apply, h x' 0], repeat { rw norm_zero }, }
exact ⟨(1 : R), one_ne_zero, ⟨0, key⟩, by { rw pi.smul_def, ext p, rw [one_smul, minor], refl, }⟩
intros
rcases exists_extension_of_le_sublinear ⟨p, f⟩ (λ x, ∥f∥ * ∥x∥) (λ c hc x, by simp only [norm_smul c x, real.norm_eq_abs, abs_of_pos hc, mul_left_comm]) (λ x y, _) (λ x, le_trans (le_abs_self _) (f.le_op_norm _)) with ⟨g, g_eq, g_le⟩
set g' := g.mk_continuous (∥f∥) (λ x, abs_le.2 ⟨neg_le.1 $ g.map_neg x ▸ norm_neg x ▸ g_le (-x), g_le x⟩)
refine ⟨g', g_eq, _⟩
{ refine ⟨g', g_eq, _⟩, { apply le_antisymm (g.mk_continuous_norm_le (norm_nonneg f) _), refine f.op_norm_le_bound (norm_nonneg _) (λ x, _), dsimp at g_eq, rw ← g_eq, apply g'.le_op_norm } }
apply le_antisymm (g.mk_continuous_norm_le (norm_nonneg f) _)
{ apply le_antisymm (g.mk_continuous_norm_le (norm_nonneg f) _), refine f.op_norm_le_bound (norm_nonneg _) (λ x, _), dsimp at g_eq, rw ← g_eq, apply g'.le_op_norm }
refine f.op_norm_le_bound (norm_nonneg _) (λ x, _)
dsimp at g_eq
rw ← g_eq
apply g'.le_op_norm
simp only [← mul_add]
{ simp only [← mul_add], exact mul_le_mul_of_nonneg_left (norm_add_le x y) (norm_nonneg f) }
exact mul_le_mul_of_nonneg_left (norm_add_le x y) (norm_nonneg f)
intros
{ ext, refl }
ext
refl
intros
use 0
rintro _ ⟨x, hx, rfl⟩
apply norm_nonneg
intros
simp only [mul_comm, integral_const_mul]
intros
convert h.smul c
intros
refine nnreal.eq _
push_cast
exact real.sqrt_eq_rpow x.1
intros
convert (@complex.has_fderiv_at_cpow ((λ x, (f x, g x)) x) h0).comp_has_fderiv_within_at x (hf.prod hg)
intros
rw [←real.log_le_log hx (real.rpow_pos_of_pos hy z), real.log_rpow hy]
intros
rw [arctan_eq_arcsin, div_pow, sq_sqrt, one_add_div, div_div_eq_div_mul, ← sqrt_mul, mul_div_cancel', sub_add_cancel, sqrt_one, div_one]
rw [arctan_eq_arcsin, div_pow, sq_sqrt, one_add_div, div_div_eq_div_mul, ← sqrt_mul, mul_div_cancel', sub_add_cancel, sqrt_one, div_one]; nlinarith [h.1, h.2]
nlinarith [h.1, h.2]
nlinarith [h.1, h.2]
nlinarith [h.1, h.2]
nlinarith [h.1, h.2]
nlinarith [h.1, h.2]
nlinarith [h.1, h.2]
nlinarith [h.1, h.2]
nlinarith [h.1, h.2]
intros
simp [sub_eq_add_neg, cos_add]
{ convert continuous_sin.continuous_within_at, simp }
convert continuous_sin.continuous_within_at
simp
linarith [pi_pos]
intros
rw [← neg_le_neg_iff, ← arcsin_neg, arcsin_le_iff_le_sin' ⟨neg_le_neg hx.2, neg_lt.2 hx.1⟩, sin_neg, neg_le_neg_iff]
intros
have A : summable (λ n, n * r ^ n : ℕ → 𝕜)
simpa using summable_pow_mul_geometric_of_norm_lt_1 1 hr
simpa using summable_pow_mul_geometric_of_norm_lt_1 1 hr
have B : has_sum (pow r : ℕ → 𝕜) (1 - r)⁻¹
from has_sum_geometric_of_norm_lt_1 hr
refine A.has_sum_iff.2 _
have hr' : r ≠ 1
rintro rfl
rintro rfl
{ rintro rfl, simpa [lt_irrefl] using hr }
{ rintro rfl, simpa [lt_irrefl] using hr }
simpa [lt_irrefl] using hr
simpa [lt_irrefl] using hr
set s : 𝕜 := ∑' n : ℕ, n * r ^ n
calc s = (1 - r) * s / (1 - r) : (mul_div_cancel_left _ (sub_ne_zero.2 hr'.symm)).symm ... = (s - r * s) / (1 - r) : by rw [sub_mul, one_mul] ... = ((0 : ℕ) * r ^ 0 + (∑' n : ℕ, (n + 1) * r ^ (n + 1)) - r * s) / (1 - r) : by { congr, exact tsum_eq_zero_add A } ... = (r * (∑' n : ℕ, (n + 1) * r ^ n) - r * s) / (1 - r) : by simp [pow_succ, mul_left_comm _ r, tsum_mul_left] ... = r / (1 - r) ^ 2 : by simp [add_mul, tsum_add A B.summable, mul_add, B.tsum_eq, ← div_eq_mul_inv, sq, div_div_eq_div_mul]
intros
{ rw exact_iff, tidy }
rw exact_iff
tidy
intros
{ ext, dsimp [transfer_nat_trans_self, transfer_nat_trans], simp }
ext
dsimp [transfer_nat_trans_self, transfer_nat_trans]
simp
intros
erw [←iso.hom_comp_eq_id (e.functor.map_iso (e.unit_iso.app X)), functor_unit_comp]
{ erw [←iso.hom_comp_eq_id (e.functor.map_iso (e.unit_iso.app X)), functor_unit_comp], refl }
refl
intros
simp [essentially_small_iff, category_theory.locally_small_of_thin]
intros
tidy
intros
simp only [←category.assoc, cancel_mono]
intros
have := pullback_cone.is_limit_mk_id_id (F.map f)
simp_rw [←F.map_id] at this
apply pullback_cone.mono_of_is_limit_mk_id_id _ (is_limit_of_is_limit_pullback_cone_map F _ this)
intros
{ erw is_colimit.fac, refl, }
erw is_colimit.fac
refl
intros
rw ←cocone_of_hom_of_cocone h s
conv_lhs { simp only [hom_of_cocone_of_hom] }
apply (cocone_of_hom_fac _ _).symm
intros
simp
intros
apply biprod.hom_ext; apply biprod.hom_ext'; simp
apply biprod.hom_ext; apply biprod.hom_ext'
apply biprod.hom_ext
apply biprod.hom_ext'
simp
simp
apply biprod.hom_ext'
simp
simp
intros
ext j
simp [comp_sum, biproduct.ι_π_assoc, dite_comp]
intros
apply limit.w (wide_pullback_shape.wide_cospan _ _ _) (wide_pullback_shape.hom.term j)
intros
ext x
change (F'.e ≫ F'.m) _ = _
rw [F'.fac, (classical.indefinite_description _ x.2).2]
refl
intros
simp
intros
rw [←tensor_left_iff, id_tensor_comp, ←cancel_epi (α_ (𝟙_ C) (𝟙_ C ⊗ X) Y).hom, ←cancel_epi ((α_ (𝟙_ C) (𝟙_ C) X).hom ⊗ 𝟙 Y), pentagon_assoc, triangle, ←associator_naturality, ←comp_tensor_id_assoc, triangle, associator_naturality, tensor_id]
intros
dunfold left_adjoint_mate
rw [category.assoc, category.assoc, associator_naturality_assoc, associator_naturality_assoc, ←id_tensor_comp_tensor_id _ g, category.assoc, category.assoc, category.assoc, category.assoc, tensor_id_comp_id_tensor_assoc, ←right_unitor_naturality, id_tensor_comp_tensor_id_assoc]
intros
apply zero_of_target_iso_zero
dsimp
refl
intros
rw [←functor.map_comp, prod_comp, category.id_comp, category.comp_id]
intros
split
intros hP
{ intros hP, refine presieve.is_sheaf_iso J _ (hP punit), exact iso_whisker_left _ coyoneda.punit_iso ≪≫ P.right_unitor }
refine presieve.is_sheaf_iso J _ (hP punit)
exact iso_whisker_left _ coyoneda.punit_iso ≪≫ P.right_unitor
{ intros hP X Y S hS z hz, refine ⟨λ x, (hP S hS).amalgamate (λ Z f hf, z f hf x) _, _, _⟩, { intros Y₁ Y₂ Z g₁ g₂ f₁ f₂ hf₁ hf₂ h, exact congr_fun (hz g₁ g₂ hf₁ hf₂ h) x }, { intros Z f hf, ext x, apply presieve.is_sheaf_for.valid_glue }, { intros y hy, ext x, apply (hP S hS).is_separated_for.ext, intros Y' f hf, rw [presieve.is_sheaf_for.valid_glue _ _ _ hf, ← hy _ hf], refl } }
intros hP X Y S hS z hz
refine ⟨λ x, (hP S hS).amalgamate (λ Z f hf, z f hf x) _, _, _⟩
intros Y₁ Y₂ Z g₁ g₂ f₁ f₂ hf₁ hf₂ h
{ intros Y₁ Y₂ Z g₁ g₂ f₁ f₂ hf₁ hf₂ h, exact congr_fun (hz g₁ g₂ hf₁ hf₂ h) x }
exact congr_fun (hz g₁ g₂ hf₁ hf₂ h) x
intros Z f hf
{ intros Z f hf, ext x, apply presieve.is_sheaf_for.valid_glue }
ext x
apply presieve.is_sheaf_for.valid_glue
{ intros y hy, ext x, apply (hP S hS).is_separated_for.ext, intros Y' f hf, rw [presieve.is_sheaf_for.valid_glue _ _ _ hf, ← hy _ hf], refl }
intros y hy
ext x
apply (hP S hS).is_separated_for.ext
intros Y' f hf
rw [presieve.is_sheaf_for.valid_glue _ _ _ hf, ← hy _ hf]
refl
intros
rw presieve.pullback_compatible_iff
split
intro t
{ intro t, ext ⟨⟨Y, f, hf⟩, Z, g, hg⟩, simpa [first_map, second_map] using t hf hg }
ext ⟨⟨Y, f, hf⟩, Z, g, hg⟩
simpa [first_map, second_map] using t hf hg
intros t Y Z f g hf hg
{ intros t Y Z f g hf hg, rw types.limit_ext_iff at t, simpa [first_map, second_map] using t ⟨⟨Y, f, hf⟩, Z, g, hg⟩ }
rw types.limit_ext_iff at t
simpa [first_map, second_map] using t ⟨⟨Y, f, hf⟩, Z, g, hg⟩
intros
simp_rw [eval, ← functor_to_types.map_comp_apply, ← op_comp]
{ simp_rw [eval, ← functor_to_types.map_comp_apply, ← op_comp], refl }
refl
intros
{ rw eq_mk h, simp, }
rw eq_mk h
simp
intros
fsplit
intro w
{ intro w, replace w := w =≫ P.arrow, simpa using w, }
replace w := w =≫ P.arrow
simpa using w
rintro rfl
{ rintro rfl, ext, simp, }
ext
simp
intros
rcases A.eq_empty_or_nonempty with rfl | hA
{ simp }
simp
{ apply (empty_to_colex_lt hA).le }
apply (empty_to_colex_lt hA).le
intros
cases hn
{ cases hn, rw ← composition.ext_iff at hc, cases hc, congr, rwa fin.ext_iff }
rw ← composition.ext_iff at hc
cases hc
congr
rwa fin.ext_iff
intros
simp [composition.to_composition_as_set, composition_as_set.length, c.card_boundaries_eq_succ_length]
intros
rw [← dot_product_adj_matrix, vec_mul]
refine congr rfl _
ext
rw [← transpose_apply (adj_matrix α G) x v, transpose_adj_matrix]
intros
rw fintype.card_congr (G.incidence_set_equiv_neighbor_set v)
{ rw fintype.card_congr (G.incidence_set_equiv_neighbor_set v), simp }
simp
intros
induction pf
case nat.partrec'.prim : n f hf { exact hf.to_prim.to_comp }
case nat.partrec'.comp : m n f g _ _ hf hg { exact (vector_m_of_fn (λ i, hg i)).bind (hf.comp snd) }
case nat.partrec'.rfind : n f _ hf { have := ((primrec.eq.comp primrec.id (primrec.const 0)).to_comp.comp (hf.comp (vector_cons.comp snd fst))).to₂.partrec₂, exact this.rfind }
intros
let : primcodable {a//id a<n}
swap
exactI (iff.trans (by refl) subtype_val_iff).trans (of_equiv_iff _)
intros
rcases h₁ with ⟨f, c, hf⟩
rw [show p = λ a, q (f a), from set.ext hf]
rcases computable_iff.1 h₂ with ⟨g, hg, rfl⟩
exact ⟨by apply_instance, by simpa using hg.comp c⟩
intros
cases n; simp only [add_bottom, list_blank.head_cons, list_blank.modify_nth, list_blank.tail_cons]
cases n
simp only [add_bottom, list_blank.head_cons, list_blank.modify_nth, list_blank.tail_cons]
simp only [add_bottom, list_blank.head_cons, list_blank.modify_nth, list_blank.tail_cons]
congr
symmetry
apply list_blank.map_modify_nth
intro
refl
intros
cases T; simp [tape.move]
cases T
simp [tape.move]
intros
simp only [equiv.traverse] with functor_norm
intros
simp [sequence, naturality, traverse_map]
intros
cases F
cases F; refl
refl
intros
simp [seq_eq_bind_map]
intros
simp only [one_of', one_of_eq_done, eps_eq_done, and.comm, and_then_eq_bind, bind_eq_done, exists_eq_left, exists_and_distrib_left]
split
rintro ⟨c, hc, rfl, hn, rfl⟩
{ rintro ⟨c, hc, rfl, hn, rfl⟩, exact ⟨rfl, hn, hc⟩ }
exact ⟨rfl, hn, hc⟩
rintro ⟨rfl, hn, hc⟩
{ rintro ⟨rfl, hn, hc⟩, exact ⟨cb.read ⟨n, hn⟩, hc, rfl, hn, rfl⟩ }
exact ⟨cb.read ⟨n, hn⟩, hc, rfl, hn, rfl⟩
intros
simp [fix_core]
intros
rw [← of_real_nat_cast, of_real_im]
intros
rw [lim_eq_lim_im_add_lim_re]; simp
rw [lim_eq_lim_im_add_lim_re]
simp
intros
simpa using h
intros
rw ← cosh_mul_I; ring_nf; simp
rw ← cosh_mul_I; ring_nf
rw ← cosh_mul_I
ring_nf
simp
intros
rw [two_mul, sin_add, two_mul, add_mul, mul_comm]
intros
rw [← of_real_rat_cast, of_real_im]
intros
classical
rw dfinsupp.sum_add_hom_apply
convert S.dfinsupp_sum_mem _ _ _
exact h
intros
dsimp only [single]
by_cases h : i = i'
have h1 : i' ∈ ({i} : finset ι) := finset.mem_singleton.2 h.symm
{ have h1 : i' ∈ ({i} : finset ι) := finset.mem_singleton.2 h.symm, simp only [mk_apply, dif_pos h, dif_pos h1], refl }
simp only [mk_apply, dif_pos h, dif_pos h1]
refl
have h1 : i' ∉ ({i} : finset ι) := finset.not_mem_singleton.2 (ne.symm h)
{ have h1 : i' ∉ ({i} : finset ι) := finset.not_mem_singleton.2 (ne.symm h), simp only [mk_apply, dif_neg h, dif_neg h1] }
simp only [mk_apply, dif_neg h, dif_neg h1]
intros
{ ext ⟨a, b⟩ : 1, simp }
ext ⟨a, b⟩ : 1
simp
intros
cases x with x hx; exact set.sum_compl_symm_apply_of_not_mem hx
cases x with x hx
exact set.sum_compl_symm_apply_of_not_mem hx
intros
conv_rhs { rw equiv.swap_apply_def }
split_ifs with h₁ h₂
{ rw [hf h₁, equiv.swap_apply_left] }
rw [hf h₁, equiv.swap_apply_left]
{ rw [hf h₂, equiv.swap_apply_right] }
rw [hf h₂, equiv.swap_apply_right]
rw [equiv.swap_apply_of_ne_of_ne (mt (congr_arg f) h₁) (mt (congr_arg f) h₂)]
{ rw [equiv.swap_apply_of_ne_of_ne (mt (congr_arg f) h₁) (mt (congr_arg f) h₂)] }
intros
{ ext1 x, cases x, refl }
ext1 x
cases x
refl
intros
convert (e ⟨x, hx⟩).2
{ convert (e ⟨x, hx⟩).2, rw [e.extend_subtype_apply_of_mem _ hx, subtype.val_eq_coe] }
rw [e.extend_subtype_apply_of_mem _ hx, subtype.val_eq_coe]
intros
cases a; refl
cases a
refl
intros
simpa [lt_iff_coe_lt_coe, le_iff_coe_le_coe] using nat.succ_le_succ_iff.symm
intros
rw [←coe_ssubset, coe_singleton, set.ssubset_singleton_iff, coe_eq_empty]
intros
simp [max']
intros
induction s using quotient.induction_on with s
simp only [quot_mk_to_coe, cons_coe, noncomm_prod_coe, list.prod_cons]
induction s with hd tl IH
{ simp }
simp
rw [list.prod_cons, mul_assoc, ←IH, ←mul_assoc, ←mul_assoc]
{ rw [list.prod_cons, mul_assoc, ←IH, ←mul_assoc, ←mul_assoc], { congr' 1, apply comm; simp }, { intros x hx y hy, simp only [quot_mk_to_coe, list.mem_cons_iff, mem_coe, cons_coe] at hx hy, apply comm, { cases hx; simp [hx] }, { cases hy; simp [hy] } } }
congr' 1
{ congr' 1, apply comm; simp }
apply comm; simp
apply comm
simp
simp
intros x hx y hy
{ intros x hx y hy, simp only [quot_mk_to_coe, list.mem_cons_iff, mem_coe, cons_coe] at hx hy, apply comm, { cases hx; simp [hx] }, { cases hy; simp [hy] } }
simp only [quot_mk_to_coe, list.mem_cons_iff, mem_coe, cons_coe] at hx hy
apply comm
cases hx; simp [hx]
cases hx
{ cases hx; simp [hx] }
simp [hx]
simp [hx]
cases hy; simp [hy]
cases hy
{ cases hy; simp [hy] }
simp [hy]
simp [hy]
intros
have : i ∈ (single i b).support := by simpa using h
intro H
simpa [H]
intros
simp [finset.subset_iff, set.subset_def]
intros
convert prod_take_of_fn f n
{ rw [take_all_of_le (le_of_eq (length_of_fn f))] }
rw [take_all_of_le (le_of_eq (length_of_fn f))]
have : ∀ (j : fin n), (j : ℕ) < n := λ j, j.is_lt
{ have : ∀ (j : fin n), (j : ℕ) < n := λ j, j.is_lt, simp [this] }
simp [this]
intros
rw [← abs_lt_iff_mul_self_lt, abs_eq_nat_abs, abs_eq_nat_abs]
exact int.coe_nat_lt.symm
intros
rw [add_comm, add_comm i, mod_add_cancel_right]
intros
unfold bit0
{unfold bit0, simp}
simp
intros
simp [gcd]
intros
unfold gcd_a xgcd
induction s
{ exact absurd rfl h, }
exact absurd rfl h
{ simp [xgcd_aux], }
simp [xgcd_aux]
intros
convert dif_pos _ using 1
convert coe_least_of_bdd_eq _ (classical.some_spec (⟨b, Hb⟩ : bdd_below s)) _
{ convert coe_least_of_bdd_eq _ (classical.some_spec (⟨b, Hb⟩ : bdd_below s)) _ }
{ exact ⟨Hinh, b, Hb⟩, }
exact ⟨Hinh, b, Hb⟩
rw even_iff; norm_num
rw even_iff
norm_num
intros
induction n with n IH generalizing k l
{ simpa using hn }
simpa using hn
cases l with hd tl
{ cases l with hd tl, { simp }, { cases k, { simp }, { rw nat.succ_lt_succ_iff at hn, simpa using IH _ _ hn _ } } }
{ simp }
simp
cases k
{ cases k, { simp }, { rw nat.succ_lt_succ_iff at hn, simpa using IH _ _ hn _ } }
{ simp }
simp
rw nat.succ_lt_succ_iff at hn
{ rw nat.succ_lt_succ_iff at hn, simpa using IH _ _ hn _ }
simpa using IH _ _ hn _
intros
induction l with hd tl hl generalizing n
{ simp only [option.to_list, nth, take_nil, append_nil]}
simp only [option.to_list, nth, take_nil, append_nil]
cases n
{ cases n, { simp only [option.to_list, nth, eq_self_iff_true, and_self, take, nil_append] }, { simp only [hl, cons_append, nth, eq_self_iff_true, and_self, take] } }
simp only [option.to_list, nth, eq_self_iff_true, and_self, take, nil_append]
{ simp only [option.to_list, nth, eq_self_iff_true, and_self, take, nil_append] }
{ simp only [hl, cons_append, nth, eq_self_iff_true, and_self, take] }
simp only [hl, cons_append, nth, eq_self_iff_true, and_self, take]
intros
induction l; [refl, simp only [*, reverse_cons, foldl_append, foldl_cons, foldl_nil, foldr]]
induction l
refl
simp only [*, reverse_cons, foldl_append, foldl_cons, foldl_nil, foldr]
intros
induction n; [refl, simp only [*, repeat_succ, sum_cons, nat.mul_succ, add_comm]]
induction n
refl
simp only [*, repeat_succ, sum_cons, nat.mul_succ, add_comm]
intros
induction l with h t ih; cases hx
induction l with h t ih
cases hx
cases hx
rw hx
{ rw hx, exact lt_add_of_lt_of_nonneg (lt_one_add _) (nat.zero_le _) }
exact lt_add_of_lt_of_nonneg (lt_one_add _) (nat.zero_le _)
exact lt_add_of_pos_of_le (zero_lt_one_add _) (le_of_lt (ih hx))
{ exact lt_add_of_pos_of_le (zero_lt_one_add _) (le_of_lt (ih hx)) }
intros
simp only [map_filter_map, H, filter_map_some]
intros
simp only [prefix_iff_eq_take, length_take]
induction m with m IH generalizing L n
simp only [min_eq_left, eq_self_iff_true, nat.zero_le, take]
{ simp only [min_eq_left, eq_self_iff_true, nat.zero_le, take] }
cases n
{ cases n, { simp only [nat.nat_zero_eq_zero, nonpos_iff_eq_zero, take, take_nil], split, { cases L, { exact absurd hm (not_lt_of_le m.succ.zero_le) }, { simp only [forall_prop_of_false, not_false_iff, take] } }, { intro h, contradiction } }, { cases L with l ls, { exact absurd hm (not_lt_of_le m.succ.zero_le) }, { simp only [length] at hm, specialize @IH ls n (nat.lt_of_succ_lt_succ hm), simp only [le_of_lt (nat.lt_of_succ_lt_succ hm), min_eq_left] at IH, simp only [le_of_lt hm, IH, true_and, min_eq_left, eq_self_iff_true, length, take], exact ⟨nat.succ_le_succ, nat.le_of_succ_le_succ⟩ } } }
simp only [nat.nat_zero_eq_zero, nonpos_iff_eq_zero, take, take_nil]
{ simp only [nat.nat_zero_eq_zero, nonpos_iff_eq_zero, take, take_nil], split, { cases L, { exact absurd hm (not_lt_of_le m.succ.zero_le) }, { simp only [forall_prop_of_false, not_false_iff, take] } }, { intro h, contradiction } }
split
cases L
{ cases L, { exact absurd hm (not_lt_of_le m.succ.zero_le) }, { simp only [forall_prop_of_false, not_false_iff, take] } }
exact absurd hm (not_lt_of_le m.succ.zero_le)
{ exact absurd hm (not_lt_of_le m.succ.zero_le) }
simp only [forall_prop_of_false, not_false_iff, take]
{ simp only [forall_prop_of_false, not_false_iff, take] }
intro h
{ intro h, contradiction }
contradiction
cases L with l ls
{ cases L with l ls, { exact absurd hm (not_lt_of_le m.succ.zero_le) }, { simp only [length] at hm, specialize @IH ls n (nat.lt_of_succ_lt_succ hm), simp only [le_of_lt (nat.lt_of_succ_lt_succ hm), min_eq_left] at IH, simp only [le_of_lt hm, IH, true_and, min_eq_left, eq_self_iff_true, length, take], exact ⟨nat.succ_le_succ, nat.le_of_succ_le_succ⟩ } }
{ exact absurd hm (not_lt_of_le m.succ.zero_le) }
exact absurd hm (not_lt_of_le m.succ.zero_le)
simp only [length] at hm
{ simp only [length] at hm, specialize @IH ls n (nat.lt_of_succ_lt_succ hm), simp only [le_of_lt (nat.lt_of_succ_lt_succ hm), min_eq_left] at IH, simp only [le_of_lt hm, IH, true_and, min_eq_left, eq_self_iff_true, length, take], exact ⟨nat.succ_le_succ, nat.le_of_succ_le_succ⟩ }
specialize @IH ls n (nat.lt_of_succ_lt_succ hm)
simp only [le_of_lt (nat.lt_of_succ_lt_succ hm), min_eq_left] at IH
simp only [le_of_lt hm, IH, true_and, min_eq_left, eq_self_iff_true, length, take]
exact ⟨nat.succ_le_succ, nat.le_of_succ_le_succ⟩
intros
induction L with l L ih; [refl, {simp [ih], rw ← permutations_aux2_append}]
induction L with l L ih
refl
simp [ih]
rw ← permutations_aux2_append
intros
induction l with b l
{ induction l with b l, {refl}, by_cases a = b; [simp [h], simp [h, ne.symm h, *]] }
refl
{refl}
by_cases a = b; [simp [h], simp [h, ne.symm h, *]]
by_cases a = b
simp [h]
simp [h, ne.symm h, *]
intros
rw disjoint_comm; exact disjoint_nil_left _
rw disjoint_comm
exact disjoint_nil_left _
intros
cases n
cases n; refl
refl
refl
intros
cases l with x l
{ simpa using hn }
simpa using hn
induction l with y l hl generalizing n x
{ simp }
simp
rcases n with _|_|n
{ rcases n with _|_|n, { simpa [last_eq_nth_le, nat.mod_eq_of_lt (nat.succ_lt_succ l.length.lt_succ_self)] }, { simp only [mem_cons_iff, nodup_cons] at h, push_neg at h, simp [add_comm, prev_cons_cons_of_ne, h.left.left.symm] }, { rw [prev_ne_cons_cons], { convert hl _ _ (nodup_of_nodup_cons h) _ using 1, have : ∀ k hk, (y :: l).nth_le k hk = (x :: y :: l).nth_le (k + 1) (nat.succ_lt_succ hk), { intros, simpa }, rw [this], congr, simp only [nat.add_succ_sub_one, add_zero, length], simp only [length, nat.succ_lt_succ_iff] at hn, set k := l.length, rw [nat.succ_add, ←nat.add_succ, nat.add_mod_right, nat.succ_add, ←nat.add_succ _ k, nat.add_mod_right, nat.mod_eq_of_lt, nat.mod_eq_of_lt], { exact nat.lt_succ_of_lt hn }, { exact nat.succ_lt_succ (nat.lt_succ_of_lt hn) } }, { intro H, suffices : n.succ.succ = 0, { simpa }, rw nodup_iff_nth_le_inj at h, refine h _ _ hn nat.succ_pos' _, simpa using H }, { intro H, suffices : n.succ.succ = 1, { simpa }, rw nodup_iff_nth_le_inj at h, refine h _ _ hn (nat.succ_lt_succ nat.succ_pos') _, simpa using H } } }
simpa [last_eq_nth_le, nat.mod_eq_of_lt (nat.succ_lt_succ l.length.lt_succ_self)]
{ simpa [last_eq_nth_le, nat.mod_eq_of_lt (nat.succ_lt_succ l.length.lt_succ_self)] }
simp only [mem_cons_iff, nodup_cons] at h
{ simp only [mem_cons_iff, nodup_cons] at h, push_neg at h, simp [add_comm, prev_cons_cons_of_ne, h.left.left.symm] }
push_neg at h
simp [add_comm, prev_cons_cons_of_ne, h.left.left.symm]
rw [prev_ne_cons_cons]
{ rw [prev_ne_cons_cons], { convert hl _ _ (nodup_of_nodup_cons h) _ using 1, have : ∀ k hk, (y :: l).nth_le k hk = (x :: y :: l).nth_le (k + 1) (nat.succ_lt_succ hk), { intros, simpa }, rw [this], congr, simp only [nat.add_succ_sub_one, add_zero, length], simp only [length, nat.succ_lt_succ_iff] at hn, set k := l.length, rw [nat.succ_add, ←nat.add_succ, nat.add_mod_right, nat.succ_add, ←nat.add_succ _ k, nat.add_mod_right, nat.mod_eq_of_lt, nat.mod_eq_of_lt], { exact nat.lt_succ_of_lt hn }, { exact nat.succ_lt_succ (nat.lt_succ_of_lt hn) } }, { intro H, suffices : n.succ.succ = 0, { simpa }, rw nodup_iff_nth_le_inj at h, refine h _ _ hn nat.succ_pos' _, simpa using H }, { intro H, suffices : n.succ.succ = 1, { simpa }, rw nodup_iff_nth_le_inj at h, refine h _ _ hn (nat.succ_lt_succ nat.succ_pos') _, simpa using H } }
convert hl _ _ (nodup_of_nodup_cons h) _ using 1
{ convert hl _ _ (nodup_of_nodup_cons h) _ using 1, have : ∀ k hk, (y :: l).nth_le k hk = (x :: y :: l).nth_le (k + 1) (nat.succ_lt_succ hk), { intros, simpa }, rw [this], congr, simp only [nat.add_succ_sub_one, add_zero, length], simp only [length, nat.succ_lt_succ_iff] at hn, set k := l.length, rw [nat.succ_add, ←nat.add_succ, nat.add_mod_right, nat.succ_add, ←nat.add_succ _ k, nat.add_mod_right, nat.mod_eq_of_lt, nat.mod_eq_of_lt], { exact nat.lt_succ_of_lt hn }, { exact nat.succ_lt_succ (nat.lt_succ_of_lt hn) } }
have : ∀ k hk, (y :: l).nth_le k hk = (x :: y :: l).nth_le (k + 1) (nat.succ_lt_succ hk)
intros
{ intros, simpa }
simpa
rw [this]
congr
simp only [nat.add_succ_sub_one, add_zero, length]
simp only [length, nat.succ_lt_succ_iff] at hn
set k := l.length
rw [nat.succ_add, ←nat.add_succ, nat.add_mod_right, nat.succ_add, ←nat.add_succ _ k, nat.add_mod_right, nat.mod_eq_of_lt, nat.mod_eq_of_lt]
exact nat.lt_succ_of_lt hn
{ exact nat.lt_succ_of_lt hn }
exact nat.succ_lt_succ (nat.lt_succ_of_lt hn)
{ exact nat.succ_lt_succ (nat.lt_succ_of_lt hn) }
intro H
{ intro H, suffices : n.succ.succ = 0, { simpa }, rw nodup_iff_nth_le_inj at h, refine h _ _ hn nat.succ_pos' _, simpa using H }
suffices : n.succ.succ = 0
simpa
{ simpa }
rw nodup_iff_nth_le_inj at h
refine h _ _ hn nat.succ_pos' _
simpa using H
intro H
{ intro H, suffices : n.succ.succ = 1, { simpa }, rw nodup_iff_nth_le_inj at h, refine h _ _ hn (nat.succ_lt_succ nat.succ_pos') _, simpa using H }
suffices : n.succ.succ = 1
simpa
{ simpa }
rw nodup_iff_nth_le_inj at h
refine h _ _ hn (nat.succ_lt_succ nat.succ_pos') _
simpa using H
intros
simp only [foldr_with_index, foldr_with_index_aux_spec, foldr_with_index_aux_eq_foldr_with_index_aux_spec, enum]
intros
simp
intros
rcases s with ⟨l, p, s⟩
induction s generalizing l₁
cases h₂
case list.sublist.slnil { cases h₂ }
case list.sublist.cons : r₁ r₂ b s' ih { simp at h₂, cases h₂ with e m, { subst b, exact ⟨a::r₁, p.cons a, s'.cons2 _ _ _⟩ }, { rcases ih m d₁ h₁ p with ⟨t, p', s'⟩, exact ⟨t, p', s'.cons _ _ _⟩ } }
case list.sublist.cons2 : r₁ r₂ b s' ih { have bm : b ∈ l₁ := (p.subset $ mem_cons_self _ _), have am : a ∈ r₂ := h₂.resolve_left (λ e, h₁ $ e.symm ▸ bm), rcases mem_split bm with ⟨t₁, t₂, rfl⟩, have st : t₁ ++ t₂ <+ t₁ ++ b :: t₂ := by simp, rcases ih am (nodup_of_sublist st d₁) (mt (λ x, st.subset x) h₁) (perm.cons_inv $ p.trans perm_middle) with ⟨t, p', s'⟩, exact ⟨b::t, (p'.cons b).trans $ (swap _ _ _).trans (perm_middle.symm.cons a), s'.cons2 _ _ _⟩ }
intros
rw of_fn_eq_pmap; from nodup_pmap (λ _ _ _ _ H, fin.veq_of_eq $ hf H) (nodup_range n)
rw of_fn_eq_pmap
from nodup_pmap (λ _ _ _ _ H, fin.veq_of_eq $ hf H) (nodup_range n)
intros
cases n
cases n; simp [rotate]
simp [rotate]
simp [rotate]
intros
by_cases a = a'
{ subst a' }
subst a'
induction l with x xs
refl
{ refl }
by_cases a' = x.1
{ by_cases a' = x.1, { subst a', simp [kerase_cons_ne h,kerase_cons_eq rfl] }, by_cases h' : a = x.1, { subst a, simp [kerase_cons_eq rfl,kerase_cons_ne (ne.symm h)] }, { simp [kerase_cons_ne,*] } }
{ subst a', simp [kerase_cons_ne h,kerase_cons_eq rfl] }
subst a'
simp [kerase_cons_ne h,kerase_cons_eq rfl]
by_cases h' : a = x.1
{ subst a, simp [kerase_cons_eq rfl,kerase_cons_ne (ne.symm h)] }
subst a
simp [kerase_cons_eq rfl,kerase_cons_ne (ne.symm h)]
{ simp [kerase_cons_ne,*] }
simp [kerase_cons_ne,*]
intros
cases e : split l with l₁' l₂'
injection (split_cons_of_eq _ (split_cons_of_eq _ e)).symm.trans h
substs l₁ l₂
cases length_split_le e with h₁ h₂
exact ⟨nat.succ_le_succ (nat.succ_le_succ h₁), nat.succ_le_succ (nat.succ_le_succ h₂)⟩
intros
{ rw ←zip_map', congr, exact map_id _ }
rw ←zip_map'
congr
exact map_id _
intros
{ ext, rw [←diagonal_one, mul_vec_diagonal, one_mul] }
ext
rw [←diagonal_one, mul_vec_diagonal, one_mul]
intros
ext
{ ext, refl }
refl
intros
ext i j; by_cases h : i = j; simp [h]
ext i j; by_cases h : i = j
ext i j
by_cases h : i = j
simp [h]
simp [h]
intros
{ rw ← diagonal_transpose, apply dot_product_diagonal }
rw ← diagonal_transpose
apply dot_product_diagonal
intros
simp [mul_apply, std_basis_matrix]
intros
ext
simp only [map_apply, block_diagonal'_apply, eq_comm]
rw [apply_dite f, hf]
intros
ext i
simp_rw [fin.append]
split_ifs with h
rcases i with ⟨⟨⟩ | i, hi⟩
{ rcases i with ⟨⟨⟩ | i, hi⟩, { simp }, { simp only [nat.succ_eq_add_one, add_lt_add_iff_right, fin.coe_mk] at h, simp [h] } }
{ simp }
simp
simp only [nat.succ_eq_add_one, add_lt_add_iff_right, fin.coe_mk] at h
{ simp only [nat.succ_eq_add_one, add_lt_add_iff_right, fin.coe_mk] at h, simp [h] }
simp [h]
rcases i with ⟨⟨⟩ | i, hi⟩
{ rcases i with ⟨⟨⟩ | i, hi⟩, { simpa using h }, { rw [not_lt, fin.coe_mk, nat.succ_eq_add_one, add_le_add_iff_right] at h, simp [h] } }
{ simpa using h }
simpa using h
rw [not_lt, fin.coe_mk, nat.succ_eq_add_one, add_le_add_iff_right] at h
{ rw [not_lt, fin.coe_mk, nat.succ_eq_add_one, add_le_add_iff_right] at h, simp [h] }
simp [h]
intros
simp [multiset.sigma]
intros
rw [antidiagonal, mem_coe, list.nat.mem_antidiagonal]
intros
simp [powerset_aux, sublists]; rw [← show @sublists_aux₁ α (multiset α) l (λ x, [↑x]) = sublists_aux l (λ x, list.cons ↑x), from sublists_aux₁_eq_sublists_aux _ _, sublists_aux_cons_eq_sublists_aux₁, ← bind_ret_eq_map, sublists_aux₁_bind]; refl
simp [powerset_aux, sublists]; rw [← show @sublists_aux₁ α (multiset α) l (λ x, [↑x]) = sublists_aux l (λ x, list.cons ↑x), from sublists_aux₁_eq_sublists_aux _ _, sublists_aux_cons_eq_sublists_aux₁, ← bind_ret_eq_map, sublists_aux₁_bind]
simp [powerset_aux, sublists]
rw [← show @sublists_aux₁ α (multiset α) l (λ x, [↑x]) = sublists_aux l (λ x, list.cons ↑x), from sublists_aux₁_eq_sublists_aux _ _, sublists_aux_cons_eq_sublists_aux₁, ← bind_ret_eq_map, sublists_aux₁_bind]
refl
intros
simpa only [sub_eq_add_neg] using le_trans (degrees_add p (-q)) (by rw degrees_neg)
intros
{ ext1 i, simp }
ext1 i
simp
intros
apply mv_polynomial.induction_on p; { intros, simp [*] }
apply mv_polynomial.induction_on p
{ intros, simp [*] }
{ intros, simp [*] }
intros
{ intros, simp [*] }
simp [*]
intros
simp only [← succ_le_iff, le_find_iff, succ_le_succ_iff]
intros
cases n; unfold le_rec_on or.by_cases; rw [dif_neg n.not_succ_le_self, dif_pos rfl]
cases n; unfold le_rec_on or.by_cases
cases n
unfold le_rec_on or.by_cases
unfold le_rec_on or.by_cases
rw [dif_neg n.not_succ_le_self, dif_pos rfl]
intros
rw mul_comm; exact nat.div_eq_iff_eq_mul_right H H'
rw mul_comm
exact nat.div_eq_iff_eq_mul_right H H'
intros
rw [bit1, cast_add_one, cast_bit0]; refl
rw [bit1, cast_add_one, cast_bit0]
refl
intros
rw [choose_eq_factorial_div_factorial (nat.le_add_left j i), nat.add_sub_cancel, mul_comm]
intros
cases n
simp
{ simp }
have h := add_pow (-1 : ℤ) 1 n.succ
simp only [one_pow, mul_one, add_left_neg, int.nat_cast_eq_coe_nat] at h
rw [← h, zero_pow (nat.succ_pos n), if_neg (nat.succ_ne_zero n)]
intros
have : digits (b + 2) m ≠ []
from digits_ne_nil_iff_ne_zero.mpr hm
convert pow_length_le_mul_of_digits this (last_digit_ne_zero _ hm)
rwa of_digits_digits
intros
rw [← some_eq_coe]
{ rw [← some_eq_coe], exact part.ext' (iff_of_true trivial h) (λ _ _, rfl) }
exact part.ext' (iff_of_true trivial h) (λ _ _, rfl)
intros
{ simp only [← some_eq_coe, ← to_with_top_some], congr }
simp only [← some_eq_coe, ← to_with_top_some]
intros
rw [gcd_comm, gcd_mul_left_left]
intros
simp [coprime]
intros
rw [←not_le, le_pow_iff_clog_le hb, not_le]
exact pred_lt (clog_pos hb hx).ne'
intros
rw [not_even_iff, odd_iff]
intros
cases n
cases k; simp [zero_pow_eq]
{ cases k; simp [zero_pow_eq] }
cases k
simp [zero_pow_eq]
simp [zero_pow_eq]
cases n
{ rw one_pow }
rw one_pow
refine ⟨λ _, one_lt_succ_succ n, λ _, _⟩
induction k with k hk
{ exact absurd rfl h }
exact absurd rfl h
cases k
{ simp }
simp
exact one_lt_mul (one_lt_succ_succ _).le (hk (succ_ne_zero k).symm)
intros
rw [pp.dvd_iff_not_coprime]; apply em
rw [pp.dvd_iff_not_coprime]
apply em
intros
refine ⟨λ h, lt_of_lt_of_le (with_bot.coe_lt_coe.mpr zero_lt_one) h, λ h, _⟩
induction x using with_bot.rec_bot_coe
{ exact (not_lt_bot h).elim }
exact (not_lt_bot h).elim
exact with_bot.coe_le_coe.mpr (nat.succ_le_iff.mpr (with_bot.coe_lt_coe.mp h))
{ exact with_bot.coe_le_coe.mpr (nat.succ_le_iff.mpr (with_bot.coe_lt_coe.mp h)) }
intros
rw ← not_lt; exact not_congr lt_to_nat
rw ← not_lt
exact not_congr lt_to_nat
intros
cases x; simp only [map_none', map_some', pmap]
{ cases x; simp only [map_none', map_some', pmap] }
cases x
simp only [map_none', map_some', pmap]
simp only [map_none', map_some', pmap]
intros
have := H.2.eq_node'
rw this at H
clear this
induction r with rs rl rx rr IHrl IHrr generalizing l x o₁
{ exact ⟨H.left, rfl⟩ }
exact ⟨H.left, rfl⟩
have := H.2.2.2.eq_node'
rw this at H ⊢
rcases IHrr H.right with ⟨h, e⟩
refine ⟨valid'.balance_l H.left h (or.inr ⟨_, or.inr e, H.3.1⟩), _⟩
rw [erase_max, size_balance_l H.3.2.1 h.3 H.2.2.1 h.2 (or.inr ⟨_, or.inr e, H.3.1⟩)]
rw [size, e]
refl
intros
dsimp [node3_r, node', size]; rw [← add_assoc, ← add_assoc]
dsimp [node3_r, node', size]
rw [← add_assoc, ← add_assoc]
intros
simp only [liftp_iff, sigma.mk.inj_iff]
simp only [liftp_iff, sigma.mk.inj_iff]; split; intro
simp only [liftp_iff, sigma.mk.inj_iff]; split
split
intro
{ casesm* [Exists _, _ ∧ _], subst_vars, assumption }
casesm* [Exists _, _ ∧ _]
subst_vars
assumption
intro
constructor
repeat { constructor <|> assumption }
constructor
constructor
constructor
constructor
constructor
constructor
assumption
intros
simp [bit1, C_bit0]
intros
simp [monomial, monomial_fun, finsupp.single_left_inj ha]
intros
rw [C_mul_X_pow_eq_monomial, support_monomial n c H]
intros
{ rw C_mul_X_pow_eq_monomial, apply degree_monomial_le }
rw C_mul_X_pow_eq_monomial
apply degree_monomial_le
intros
rw ← degree_nonneg_iff_ne_zero; exact trans (by exact_mod_cast n.zero_le) hdeg
rw ← degree_nonneg_iff_ne_zero
exact trans (by exact_mod_cast n.zero_le) hdeg
intros
obtain ⟨ev, bi, bu, hF⟩ := @denoms_clearable_nat_degree _ _ _ _ b _ (algebra_map ℤ K) f a (by { rw [eq_int_cast, one_div_mul_cancel], rw [int.cast_ne_zero], exact (b0.ne.symm) })
obtain Fa := congr_arg abs hF
rw [eq_one_div_of_mul_eq_one_left bu, eq_int_cast, eq_int_cast, abs_mul] at Fa
rw [abs_of_pos (pow_pos (int.cast_pos.mpr b0) _ : 0 < (b : K) ^ _), one_div, eq_int_cast] at Fa
rw [div_eq_mul_inv, ← Fa, ← int.cast_abs, ← int.cast_one, int.cast_le]
refine int.le_of_lt_add_one ((lt_add_iff_pos_left 1).mpr (abs_pos.mpr (λ F0, fab _)))
rw [eq_one_div_of_mul_eq_one_left bu, F0, one_div, eq_int_cast, int.cast_zero, zero_eq_mul] at hF
cases hF with hF hF
exact (not_le.mpr b0 (le_of_eq (int.cast_eq_zero.mp (pow_eq_zero hF)))).elim
{ exact (not_le.mpr b0 (le_of_eq (int.cast_eq_zero.mp (pow_eq_zero hF)))).elim }
{ rwa div_eq_mul_inv }
rwa div_eq_mul_inv
intros
apply polynomial.induction_on' p
intros p q ph qh
{ intros p q ph qh, simp only [mul_add, eval_add, ph, qh], }
simp only [mul_add, eval_add, ph, qh]
intros n b
{ intros n b, simp only [mul_assoc, C_mul_monomial, eval_monomial], }
simp only [mul_assoc, C_mul_monomial, eval_monomial]
intros
refine or.resolve_left (dvd_or_coprime (X - C a) (f /ₘ (X - C a)) (irreducible_of_degree_eq_one (polynomial.degree_X_sub_C a))) _
contrapose! hf' with h
have key : (X - C a) * (f /ₘ (X - C a)) = f - (f %ₘ (X - C a))
rw [eq_sub_iff_add_eq, ← eq_sub_iff_add_eq', mod_by_monic_eq_sub_mul_div]
{ rw [eq_sub_iff_add_eq, ← eq_sub_iff_add_eq', mod_by_monic_eq_sub_mul_div], exact monic_X_sub_C a }
exact monic_X_sub_C a
replace key := congr_arg derivative key
simp only [derivative_X, derivative_mul, one_mul, sub_zero, derivative_sub, mod_by_monic_X_sub_C_eq_C_eval, derivative_C] at key
have : (X - C a) ∣ derivative f := key ▸ (dvd_add h (dvd_mul_right _ _))
rw [← dvd_iff_mod_by_monic_eq_zero (monic_X_sub_C _), mod_by_monic_X_sub_C_eq_C_eval] at this
rw [← C_inj, this, C_0]
intros
have A : ∀{n:ℕ} {a}, M (C a * X^n)
assume n a
{ assume n a, induction n with n ih, { simp only [pow_zero, mul_one, h_C] }, { exact h_monomial _ _ ih } }
induction n with n ih
{ simp only [pow_zero, mul_one, h_C] }
simp only [pow_zero, mul_one, h_C]
{ exact h_monomial _ _ ih }
exact h_monomial _ _ ih
have B : ∀ (s : finset ℕ), M (s.sum (λ (n : ℕ), C (p.coeff n) * X ^ n))
apply finset.induction
{ apply finset.induction, { convert h_C 0, exact C_0.symm }, { assume n s ns ih, rw sum_insert ns, exact h_add _ _ A ih, } }
{ convert h_C 0, exact C_0.symm }
convert h_C 0
exact C_0.symm
{ assume n s ns ih, rw sum_insert ns, exact h_add _ _ A ih, }
assume n s ns ih
rw sum_insert ns
exact h_add _ _ A ih
rw [← sum_C_mul_X_eq p, polynomial.sum]
exact B _
intros
simp only [iterated_deriv_zero_right]
intros
rwa [monic, add_comm, leading_coeff_add_of_degree_lt hpq]
intros
rw [monic.def, leading_coeff_smul_of_smul_regular _ (is_smul_regular_of_group _), units.smul_def]
obtain ⟨k, hk⟩ := h
simp only [←hk, smul_eq_mul, ←units.coe_mul, units.coe_eq_one, inv_mul_eq_iff_eq_mul]
simp [units.ext_iff, is_unit.unit_spec]
intros
rw [←reverse_leading_coeff, reverse_mul_of_domain, leading_coeff_mul, reverse_leading_coeff, reverse_leading_coeff]
intros
simp only [taylor_apply, C_comp]
intros
split
intro h
{ intro h, have : liftp (supp x) x, by rw h; intro u; exact id, rw liftp_iff at this, rcases this with ⟨a, f, xeq, h'⟩, refine ⟨a, f, xeq.symm, _⟩, intros a' f' h'', rintros u ⟨i, _, hfi⟩, have : u ∈ supp x, by rw ←hfi; apply h', exact (mem_supp x u).mp this _ _ h'' }
have : liftp (supp x) x
rw h
rw h
rw h; intro u; exact id
rw h; intro u; exact id
rw h; intro u
rw h; intro u
intro u
intro u
exact id
exact id
rw liftp_iff at this
rcases this with ⟨a, f, xeq, h'⟩
refine ⟨a, f, xeq.symm, _⟩
intros a' f' h''
rintros u ⟨i, _, hfi⟩
have : u ∈ supp x
rw ←hfi
rw ←hfi
rw ←hfi; apply h'
rw ←hfi; apply h'
apply h'
apply h'
exact (mem_supp x u).mp this _ _ h''
rintros ⟨a, f, xeq, h⟩ p
rw liftp_iff
split
rintros ⟨a', f', xeq', h'⟩ u usuppx
{ rintros ⟨a', f', xeq', h'⟩ u usuppx, rcases (mem_supp x u).mp usuppx a' f' xeq'.symm with ⟨i, _, f'ieq⟩, rw ←f'ieq, apply h' }
rcases (mem_supp x u).mp usuppx a' f' xeq'.symm with ⟨i, _, f'ieq⟩
rw ←f'ieq
apply h'
intro h'
refine ⟨a, f, xeq.symm, _⟩
intro i
apply h'
rw mem_supp
intros a' f' xeq'
apply h a' f' xeq'
apply mem_image_of_mem _ (mem_univ _)
rw ← one_cauchy
rw ← one_cauchy; refl
refl
intros
rw [div_eq_mul_inv, to_real_mul, to_real_inv, div_eq_mul_inv]
simpa only [coe_inv one_ne_zero, coe_one] using coe_eq_coe.2 inv_one
linarith [one_sub_gold_conj, one_lt_gold]
intros
{ refine le_trans _ h, simp }
refine le_trans _ h
simp
intros
refine (lt_div_iff $ λ hr, false.elim _).1 h
subst r
simpa using h
intros
rw [sqrt, nnreal.coe_eq_zero, nnreal.sqrt_eq_zero, real.to_nnreal_eq_zero]
intros
{ ext x y, split; apply eq.symm }
ext x y
split
split; apply eq.symm
apply eq.symm
apply eq.symm
intros
rw [←lift_eq_iff_equiv]; exact lift_rel_map eq _ ((lift_eq_iff_equiv _ _).2 h1) (λ a b, congr_arg _)
rw [←lift_eq_iff_equiv]
exact lift_rel_map eq _ ((lift_eq_iff_equiv _ _).2 h1) (λ a b, congr_arg _)
intros
simp [singleton_inter_eq_empty.2 h]
intros
simp only [image_insert_eq, image_singleton]
intros
rw [inter_comm, preimage_inter_range]
intros
{ ext x, by_cases h₁ : x.1 ∈ s₁; by_cases h₂ : x.2 ∈ t₁; simp * }
ext x
by_cases h₁ : x.1 ∈ s₁
by_cases h₁ : x.1 ∈ s₁; by_cases h₂ : x.2 ∈ t₁; simp *
by_cases h₁ : x.1 ∈ s₁; by_cases h₂ : x.2 ∈ t₁
by_cases h₂ : x.2 ∈ t₁
simp *
simp *
by_cases h₂ : x.2 ∈ t₁
simp *
simp *
intros
rw [← image_eq_image hf.1, hf.2.image_preimage]
intros
{ ext, simp }
ext
simp
intros
ext
ext; simp
simp
intros
apply piecewise_le; intros; simp *
apply piecewise_le; intros
apply piecewise_le
intros
simp *
intros
simp *
intros
simp only [Ici_inter_Iic.symm, Ici_inter_Ici.symm, Iic_inter_Iic.symm]
simp only [Ici_inter_Iic.symm, Ici_inter_Ici.symm, Iic_inter_Iic.symm]; ac_refl
ac_refl
intros
rw [←not_nonempty_iff_eq_empty, not_iff_not, nonempty_Ioc]
intros
rw [diff_eq, compl_Iio, inter_comm, Ici_inter_Iic]
intros
simp [lt_irrefl]
intros
simp
intros
refine ⟨λ x h, add_lt_add_right (mem_Iio.mp h) _, λ _ _ _ _ h, add_right_cancel h, λ _ h, _⟩
simpa [add_comm a] using h
intros
refine ⟨λ x h, add_lt_add_right (mem_Ioi.mp h) _, λ _ _ _ _ h, add_right_cancel h, λ _ h, _⟩
obtain ⟨c, rfl⟩ := exists_add_of_le (mem_Ioi.mp h).le
rw [mem_Ioi, add_right_comm, add_lt_add_iff_right] at h
exact ⟨a + c, h, by rw add_right_comm⟩
intros
simp [interval_oc, le_of_lt h]
intros
ext1 x
simp [image, ← exists_and_distrib_right, @exists_swap α]
intros
{ ext, simp }
ext
simp
intros
rw [← sInter_image, image_id']
intros
{ ext i : 2, induction i; simp [drop_fun,*]; refl }
ext i : 2
induction i
induction i; simp [drop_fun,*]; refl
induction i; simp [drop_fun,*]
simp [drop_fun,*]
refl
simp [drop_fun,*]
refl
intros
cases n
{ rw nat.mod_zero, apply int.nat_abs_mul }
rw nat.mod_zero
apply int.nat_abs_mul
{ apply fin.val_mul }
apply fin.val_mul
intros
rwa [← nat.cast_zero, ne.def, eq_iff_modeq_nat, nat.modeq_zero_iff_dvd, ← hp.1.coprime_iff_not_dvd, nat.coprime_primes hp.1 hq.1]
intros
simpa only [sub_eq_add_neg] using (f.commute_add_int n).inverses_right (equiv.add_right _).right_inv (equiv.add_right _).left_inv
intros
rcases eventually_closure_subset_of_is_compact_absorbing_of_is_open_of_omega_limit_subset f ϕ s hc₁ hc₂ hn₁ hn₂ with ⟨u, hu_mem, hu⟩
refine mem_of_superset hu_mem (λ t ht x hx, _)
exact hu (subset_closure $ mem_image2_of_mem ht hx)
intros
ext
convert minpoly.aeval F α
conv in (aeval α) { rw [← adjoin_simple.algebra_map_gen F α] }
exact is_scalar_tower.algebra_map_aeval F F⟮α⟯ E _ _
intros
conv { to_rhs, rw [←fixed_field_fixing_subgroup K, intermediate_field.finrank_fixed_field_eq_card] }
intros
rw [separable_def, derivative_add, derivative_X, derivative_C, add_zero]
{ rw [separable_def, derivative_add, derivative_X, derivative_C, add_zero], exact is_coprime_one_right }
exact is_coprime_one_right
intros
use [(2⁻¹ : ℝ) • (p₂ -ᵥ p₁) +ᵥ p₁, (2⁻¹ : ℝ) * (dist p₂ p₁)]
intro p
rw [set.mem_insert_iff, set.mem_singleton_iff]
rintro ⟨_|_⟩
rw [dist_eq_norm_vsub V p₁, vsub_vadd_eq_vsub_sub, vsub_self, zero_sub, norm_neg, norm_smul, dist_eq_norm_vsub V p₂]
{ rw [dist_eq_norm_vsub V p₁, vsub_vadd_eq_vsub_sub, vsub_self, zero_sub, norm_neg, norm_smul, dist_eq_norm_vsub V p₂], simp }
simp
rw [H, dist_eq_norm_vsub V p₂, vsub_vadd_eq_vsub_sub, dist_eq_norm_vsub V p₂]
{ rw [H, dist_eq_norm_vsub V p₂, vsub_vadd_eq_vsub_sub, dist_eq_norm_vsub V p₂], conv_lhs { congr, congr, rw ←one_smul ℝ (p₂ -ᵥ p₁ : V) }, rw [←sub_smul, norm_smul], norm_num }
conv_lhs { congr, congr, rw ←one_smul ℝ (p₂ -ᵥ p₁ : V) }
rw [←sub_smul, norm_smul]
norm_num
intros
have h := s.circumcenter_circumradius_unique_dist_eq.2 (p, r)
simp only [hp, hr, forall_const, eq_self_iff_true, and_self, prod.ext_iff] at h
exact h.1
intros
rw [add_assoc, real.cos_add, cos_angle_sub_add_angle_sub_rev_eq_neg_cos_angle hx hy, sin_angle_sub_add_angle_sub_rev_eq_sin_angle hx hy, ←neg_mul_eq_mul_neg, ←neg_add', add_comm, ←sq, ←sq, real.sin_sq_add_cos_sq]
intros
rw [f.support_eq_inter_preimage, ← ext_chart_at_source I, ← (ext_chart_at I c).symm_image_target_inter_eq', inter_comm]
congr' 1 with y
exact and.congr_right_iff.2 (λ hy, ⟨λ h, ext_chart_at_target_subset_range _ _ h, λ h, f.ball_subset ⟨hy, h⟩⟩)
intros
haveI : ∀ x : M, second_countable_topology (chart_at H x).source := λ x, (chart_at H x).second_countable_topology_source
haveI := hsc.to_encodable
rw bUnion_eq_Union at hs
exact second_countable_topology_of_countable_cover (λ x : s, (chart_at H (x : M)).open_source) hs
intros
assume x hx
apply hG.lift_prop_within_at_of_lift_prop_at_of_mem_nhds (hG.lift_prop_at_of_mem_maximal_atlas hQ he hx)
apply is_open.mem_nhds e.open_source hx
intros
refine ⟨h.1, _⟩
simp only [mfderiv_within, h, dif_pos] with mfld_simps
exact differentiable_within_at.has_fderiv_within_at h.2
intros
{ ext p : 1, exact tangent_map_comp_at _ (hg _) (hf _) }
ext p : 1
exact tangent_map_comp_at _ (hg _) (hf _)
intros
cases f; cases g; cases h; refl
cases f; cases g; cases h
cases f; cases g
cases f
cases g
cases h
refl
intros
rw [←set_like.mem_coe, ←ha]; exact mem_own_right_coset s a
rw [←set_like.mem_coe, ←ha]
exact mem_own_right_coset s a
intros
rw [subgroup.fg_iff_submonoid_fg, add_subgroup.fg_iff_add_submonoid.fg]
exact (subgroup.to_submonoid P).fg_iff_add_fg
intros
simp only [to_finsupp, lift.of]
intros
exact {smul_comm := λ _ n, @smul_comm _ _ _ _ _ _ _ (g n) }
intros
rw [mul_comm, mk'_spec]
intros
rw [is_periodic_pt, is_fixed_pt, mul_left_iterate, mul_one]
intros
induction s using quot.induction_on
simpa using form_perm_reverse _ h
intros
let H := closure ({σ, swap x (σ x)} : set (perm α))
have h3 : σ ∈ H := subset_closure (set.mem_insert σ _)
have h4 : swap x (σ x) ∈ H := subset_closure (set.mem_insert_of_mem _ (set.mem_singleton _))
have step1 : ∀ (n : ℕ), swap ((σ ^ n) x) ((σ^(n+1)) x) ∈ H
intro n
{ intro n, induction n with n ih, { exact subset_closure (set.mem_insert_of_mem _ (set.mem_singleton _)) }, { convert H.mul_mem (H.mul_mem h3 ih) (H.inv_mem h3), rw [mul_swap_eq_swap_mul, mul_inv_cancel_right], refl } }
induction n with n ih
{ exact subset_closure (set.mem_insert_of_mem _ (set.mem_singleton _)) }
exact subset_closure (set.mem_insert_of_mem _ (set.mem_singleton _))
convert H.mul_mem (H.mul_mem h3 ih) (H.inv_mem h3)
{ convert H.mul_mem (H.mul_mem h3 ih) (H.inv_mem h3), rw [mul_swap_eq_swap_mul, mul_inv_cancel_right], refl }
rw [mul_swap_eq_swap_mul, mul_inv_cancel_right]
refl
have step2 : ∀ (n : ℕ), swap x ((σ ^ n) x) ∈ H
intro n
{ intro n, induction n with n ih, { convert H.one_mem, exact swap_self x }, { by_cases h5 : x = (σ ^ n) x, { rw [pow_succ, mul_apply, ←h5], exact h4 }, by_cases h6 : x = (σ^(n+1)) x, { rw [←h6, swap_self], exact H.one_mem }, rw [swap_comm, ←swap_mul_swap_mul_swap h5 h6], exact H.mul_mem (H.mul_mem (step1 n) ih) (step1 n) } }
induction n with n ih
convert H.one_mem
{ convert H.one_mem, exact swap_self x }
exact swap_self x
by_cases h5 : x = (σ ^ n) x
{ by_cases h5 : x = (σ ^ n) x, { rw [pow_succ, mul_apply, ←h5], exact h4 }, by_cases h6 : x = (σ^(n+1)) x, { rw [←h6, swap_self], exact H.one_mem }, rw [swap_comm, ←swap_mul_swap_mul_swap h5 h6], exact H.mul_mem (H.mul_mem (step1 n) ih) (step1 n) }
{ rw [pow_succ, mul_apply, ←h5], exact h4 }
rw [pow_succ, mul_apply, ←h5]
exact h4
by_cases h6 : x = (σ^(n+1)) x
{ rw [←h6, swap_self], exact H.one_mem }
rw [←h6, swap_self]
exact H.one_mem
rw [swap_comm, ←swap_mul_swap_mul_swap h5 h6]
exact H.mul_mem (H.mul_mem (step1 n) ih) (step1 n)
have step3 : ∀ (y : α), swap x y ∈ H
intro y
{ intro y, have hx : x ∈ (⊤ : finset α) := finset.mem_univ x, rw [←h2, mem_support] at hx, have hy : y ∈ (⊤ : finset α) := finset.mem_univ y, rw [←h2, mem_support] at hy, cases is_cycle.exists_pow_eq h1 hx hy with n hn, rw ← hn, exact step2 n }
have hx : x ∈ (⊤ : finset α) := finset.mem_univ x
rw [←h2, mem_support] at hx
have hy : y ∈ (⊤ : finset α) := finset.mem_univ y
rw [←h2, mem_support] at hy
cases is_cycle.exists_pow_eq h1 hx hy with n hn
rw ← hn
exact step2 n
have step4 : ∀ (y z : α), swap y z ∈ H
intros y z
{ intros y z, by_cases h5 : z = x, { rw [h5, swap_comm], exact step3 y }, by_cases h6 : z = y, { rw [h6, swap_self], exact H.one_mem }, rw [←swap_mul_swap_mul_swap h5 h6, swap_comm z x], exact H.mul_mem (H.mul_mem (step3 y) (step3 z)) (step3 y) }
by_cases h5 : z = x
{ rw [h5, swap_comm], exact step3 y }
rw [h5, swap_comm]
exact step3 y
by_cases h6 : z = y
{ rw [h6, swap_self], exact H.one_mem }
rw [h6, swap_self]
exact H.one_mem
rw [←swap_mul_swap_mul_swap h5 h6, swap_comm z x]
exact H.mul_mem (H.mul_mem (step3 y) (step3 z)) (step3 y)
rw [eq_top_iff, ←closure_is_swap, closure_le]
rintros τ ⟨y, z, h5, h6⟩
rw h6
exact step4 y z
intros
have : ¬ order_of f ∣ n := nat.not_dvd_of_pos_of_lt npos hn
rw ←hf.support_pow_eq_iff at this
rw this
intros
obtain ⟨l, hl, hl'⟩ := f.cycle_factors_finset.exists_list_nodup_eq
rw ←hl'
rw [eq_comm, cycle_factors_finset_eq_list_to_finset hl] at hl'
simpa [list.mem_to_finset, ne.def, ←hl'.right.right] using mem_list_cycles_iff hl'.left hl'.right.left
intros
rw [nth_le_cons_length, form_perm_apply_last]
intros
have h0 : ∀ y ∈ s, ∃ x (hx : x ∈ s), y = (λ i (hi : i ∈ s), f i) x hx := finset.surj_on_of_inj_on_of_card_le (λ x hx, (λ i hi, f i) x hx) (λ a ha, h a ha) (λ a₁ a₂ ha₁ ha₂ heq, (equiv.apply_eq_iff_eq f).mp heq) rfl.ge
obtain ⟨y2, hy2, heq⟩ := h0 y hy
convert hy2
rw heq
simp only [inv_apply_self]
intros
simp_rw [finset.ext_iff, mem_support, finset.not_mem_empty, iff_false, not_not, equiv.perm.ext_iff, one_apply]
intros
{ rw [lift_unique f, lift_unique g], simp only * }
rw [lift_unique f, lift_unique g]
simp only *
intros
rw order_of_eq_prime _ _
{ exact ⟨nat.prime_two⟩ }
exact ⟨nat.prime_two⟩
rw [sq, sr_mul_self]
dec_trivial
intros
assume a w
refine closure_induction w (λ x hx, _) _ (λ x y ihx ihy, _) (λ x ihx, _)
{ exact (conjugates_of_set_subset h hx) }
exact (conjugates_of_set_subset h hx)
{ exact subgroup.one_mem _ }
exact subgroup.one_mem _
{ exact subgroup.mul_mem _ ihx ihy }
exact subgroup.mul_mem _ ihx ihy
{ exact subgroup.inv_mem _ ihx }
exact subgroup.inv_mem _ ihx
intros
{ ext, simp [mem_mker] }
ext
simp [mem_mker]
intros
have : ⇑f = (λ x, x + f 0) ∘ λ x, x * (f 1 - f 0)
ext x
{ ext x, change f x = x • (f 1 -ᵥ f 0) +ᵥ f 0, rw [← f.linear_map_vsub, ← f.linear.map_smul, ← f.map_vadd], simp only [vsub_eq_sub, add_zero, mul_one, vadd_eq_add, sub_zero, smul_eq_mul] }
change f x = x • (f 1 -ᵥ f 0) +ᵥ f 0
rw [← f.linear_map_vsub, ← f.linear.map_smul, ← f.map_vadd]
simp only [vsub_eq_sub, add_zero, mul_one, vadd_eq_add, sub_zero, smul_eq_mul]
rw [this, set.image_comp]
simp only [set.image_add_const_interval, set.image_mul_const_interval]
intros
rw [direction_eq_vector_span, bot_coe, vector_span_def, vsub_empty, submodule.span_empty]
intros
rw [affine_combination_apply, affine_combination_apply, weighted_vsub_of_point_indicator_subset _ _ _ h]
intros
rw [affine_independent_iff_le_finrank_vector_span k p hc, ←nat.lt_iff_add_one_le, lt_iff_not_ge]
intros
rw [midpoint_eq_iff, point_reflection_apply, vsub_eq_sub, vadd_eq_add, sub_add_eq_add_sub, ← two_smul R, smul_smul, mul_inv_of_self, one_smul, add_sub_cancel']
intros
ext a
change (equiv_fun_on_fintype.symm (pi.single x m)) a = _
convert congr_fun (equiv_fun_on_fintype_symm_single x m) a
intros
classical; by_cases a = 0; simp [h, map_smul]
classical; by_cases a = 0
classical
by_cases a = 0
simp [h, map_smul]
simp [h, map_smul]
intros
simp_rw [← top_le_iff, ← hf, range_eq_map, map_le_map_iff]
intros
rcases set_like.exists_of_lt hp with ⟨v, -, hpv⟩
clear hp
rcases (linear_pmap.sup_span_singleton ⟨p, 0⟩ v (1 : K) hpv).to_fun.exists_extend with ⟨f, hf⟩
refine ⟨f, _, _⟩
rintro rfl
{ rintro rfl, rw [linear_map.zero_comp] at hf, have := linear_pmap.sup_span_singleton_apply_mk ⟨p, 0⟩ v (1 : K) hpv 0 p.zero_mem 1, simpa using (linear_map.congr_fun hf _).trans this }
rw [linear_map.zero_comp] at hf
have := linear_pmap.sup_span_singleton_apply_mk ⟨p, 0⟩ v (1 : K) hpv 0 p.zero_mem 1
simpa using (linear_map.congr_fun hf _).trans this
refine λ x hx, mem_ker.2 _
{ refine λ x hx, mem_ker.2 _, have := linear_pmap.sup_span_singleton_apply_mk ⟨p, 0⟩ v (1 : K) hpv x hx 0, simpa using (linear_map.congr_fun hf _).trans this }
have := linear_pmap.sup_span_singleton_apply_mk ⟨p, 0⟩ v (1 : K) hpv x hx 0
simpa using (linear_map.congr_fun hf _).trans this
intros
rw [← b.total_repr x, finsupp.total_apply, finsupp.sum]
{ rw [← b.total_repr x, finsupp.total_apply, finsupp.sum], exact submodule.sum_mem _ (λ i hi, submodule.smul_mem _ _ (submodule.subset_span ⟨i, rfl⟩)) }
exact submodule.sum_mem _ (λ i hi, submodule.smul_mem _ _ (submodule.subset_span ⟨i, rfl⟩))
intros
rw [← to_lin_restrict_ker_eq_inf_orthogonal _ _ b₁, ← to_lin_restrict_range_dual_annihilator_comap_eq_orthogonal _ _, finrank_map_subtype_eq]
conv_rhs { rw [← @subspace.finrank_add_finrank_dual_annihilator_comap_eq K V _ _ _ _ (B.to_lin.dom_restrict W).range, add_comm, ← add_assoc, add_comm (finrank K ↥((B.to_lin.dom_restrict W).ker)), linear_map.finrank_range_add_finrank_ker] }
intros
refine ext_basis (pi.basis_fun R₃ n) (λ i j, _)
rw [bilin_form.to_matrix_aux, linear_map.coe_mk, pi.basis_fun_apply, pi.basis_fun_apply, matrix.to_bilin'_aux_std_basis]
intros
ext
simp only [map_range_apply f, coe_smul, pi.smul_apply, hf']
intros
simp [dim_fun']
intros
refine eq_of_sub_eq_zero (h.total _)
intros i
simp [-sub_eq_add_neg, linear_map.map_sub, h.dual_lc, sub_eq_zero]
intros
convert finrank_span_set_eq_card ↑s hs
ext
simp
intros
haveI := classical.dec_eq M
refine N.induction_on_rank b _ _
intros N ih
let b' := (b.reindex (fintype.equiv_fin ι)).map (linear_equiv.of_top _ rfl).symm
by_cases N_bot : N = ⊥
{ subst N_bot, exact ⟨0, ⟨basis.empty _⟩⟩ }
subst N_bot
exact ⟨0, ⟨basis.empty _⟩⟩
obtain ⟨y, -, a, hay, M', -, N', N'_le_N, -, -, ay_ortho, h'⟩ := submodule.basis_of_pid_aux ⊤ N b' N_bot le_top
obtain ⟨n', ⟨bN'⟩⟩ := ih N' N'_le_N _ hay ay_ortho
obtain ⟨bN, hbN⟩ := h' n' bN'
exact ⟨n' + 1, ⟨bN⟩⟩
intros
apply @linear_independent_comp_subtype _ _ _ id
intros
rw [← @subtype.range_coe _ s] at hf_inj
refine (hs.map hf_inj).to_subtype_range' _
simp [set.range_comp f]
intros
apply eq_of_sub_eq_zero
rw ← coeff_sub
apply polynomial.coeff_eq_zero_of_degree_lt
apply lt_of_lt_of_le (charpoly_sub_diagonal_degree_lt M) _
rw with_bot.coe_le_coe
apply h
intros
rw [← det_transpose, ← update_row_transpose, det_update_row_smul]
simp [update_row_transpose, det_transpose]
intros
apply (linear_map.to_matrix B₁.dual_basis B₂.dual_basis).injective
rw [linear_map.to_matrix_to_lin, linear_map.to_matrix_transpose, linear_map.to_matrix_to_lin]
intros
rw [cramer_eq_adjugate_mul_vec, mul_vec_mul_vec, mul_adjugate, smul_mul_vec_assoc, one_mul_vec]
intros
ext i j
simp [linear_map.to_matrix_apply, matrix.one_apply, finsupp.single, eq_comm]
intros
rw [← update_cons_zero x m (c • x), f.map_smul, update_cons_zero]
intros
apply linear_equiv.to_linear_map_injective
ext f
simp only [linear_equiv.trans_apply, linear_equiv.coe_coe, reindex_tprod, linear_map.coe_comp_multilinear_map, function.comp_app, multilinear_map.dom_dom_congr_apply, reindex_comp_tprod]
congr
intros
ext ⟨x, y⟩; simp
ext ⟨x, y⟩
simp
intros
conv_rhs { rw [← (prod_equiv_of_is_compl p q h).apply_symm_apply x] }
rw [coe_prod_equiv_of_is_compl', submodule.add_mem_iff_left _ (submodule.coe_mem _), mem_right_iff_eq_zero_of_disjoint h.disjoint]
intros
ext i j
rw [std_basis_apply, finsupp.single_apply]
split_ifs
{ rw [h, function.update_same] }
rw [h, function.update_same]
{ rw [function.update_noteq (ne.symm h)], refl }
rw [function.update_noteq (ne.symm h)]
refl
intros
simp only [ltensor, rtensor, ← map_comp, id_comp, comp_id]
intros
by_cases b; simp [h, or_iff_right_of_imp ((∘) false.elim)]
by_cases b
simp [h, or_iff_right_of_imp ((∘) false.elim)]
simp [h, or_iff_right_of_imp ((∘) false.elim)]
intros
simp [pi_premeasure_pi']
intros
have : ∀ x, measurable_set (prod.mk x ⁻¹' s) := λ x, measurable_prod_mk_left hs
simp only [← @supr_restrict_spanning_sets _ _ ν, this]
apply measurable_supr
intro i
haveI := fact.mk (measure_spanning_sets_lt_top ν i)
exact measurable_measure_prod_mk_left_finite hs
intros
rw [← s.neg_le_neg_iff _ hu, neg_zero] at hsu
have := subset_positive_null_set hu hv hw hsu
simp only [pi.neg_apply, neg_eq_zero, coe_neg] at this
exact this hw₁ hw₂ hwt
intros
simp_rw [condexp_ind_smul]
{ simp_rw [condexp_ind_smul], rw [to_span_singleton_add, add_comp_LpL, add_apply], }
rw [to_span_singleton_add, add_comp_LpL, add_apply]
intros
refine (condexp_L1_eq (integrable_zero _ _ _)).trans _
change (condexp_L1_clm hm μ) (integrable.to_L1 0 _) = 0
rw [integrable.to_L1_zero, continuous_linear_map.map_zero]
intros
refine (ess_sup_mono_ae hf).trans _
by_cases hμ : μ = 0
{ simp [hμ], }
simp [hμ]
{ rwa ess_sup_const, }
rwa ess_sup_const
intros
simp [← mem_ℒp_one_iff_integrable, hg.mem_ℒp_comp_iff_of_antilipschitz hg' g0]
intros
simp [integrable.to_L1, snorm, snorm']
{ simp [integrable.to_L1, snorm, snorm'], simp [edist_eq_coe_nnnorm] }
simp [edist_eq_coe_nnnorm]
intros
rw [norm_def, snorm_congr_ae (mem_ℒp.coe_fn_to_Lp hf)]
intros
rw [Lp.norm_def, snorm_congr_ae indicator_const_Lp_coe_fn, snorm_indicator_const hs hp_ne_zero hp_ne_top, ennreal.to_real_mul, ennreal.to_real_rpow, ennreal.coe_to_real, coe_nnnorm]
intros
rw tendsto_Lp_iff_tendsto_ℒp'
suffices h_eq : (λ n, snorm (f n - mem_ℒp.to_Lp f_lim f_lim_ℒp) p μ) = (λ n, snorm (f n - f_lim) p μ)
rw h_eq
rw h_eq
exact funext (λ n, snorm_congr_ae (eventually_eq.rfl.sub (mem_ℒp.coe_fn_to_Lp f_lim_ℒp)))
intros
refine ⟨measurable_const.ae_measurable, _⟩
by_cases h0 : p = 0
{ simp [h0], }
simp [h0]
by_cases hμ : μ = 0
{ simp [hμ], }
simp [hμ]
rw snorm_const c h0 hμ
refine ennreal.mul_lt_top ennreal.coe_ne_top _
refine (ennreal.rpow_lt_top_of_nonneg _ (measure_ne_top μ set.univ)).ne
simp
intros
simp_rw snorm'
congr' 1
refine lintegral_trim hm _
refine @measurable.pow_const _ _ _ _ _ _ _ m _ (@measurable.coe_nnreal_ennreal _ m _ _) _
exact @measurable.nnnorm E _ _ _ _ m _ hf
intros
rwa [filter.eventually_eq, ae_iff, trim_measurable_set_eq hm _]
exact (@measurable_set.compl α _ m (@measurable_set_eq_fun α m E _ _ _ _ _ _ hf hg))
intros
rw [integral_def, set_to_simple_func_eq_sum_filter]
{ rw [integral_def, set_to_simple_func_eq_sum_filter], simp_rw weighted_smul_apply, }
simp_rw weighted_smul_apply
intros
have : f =ᵐ[μ.restrict {x}] (λ y, f x)
filter_upwards [ae_restrict_mem (measurable_set_singleton x)]
{ filter_upwards [ae_restrict_mem (measurable_set_singleton x)], assume a ha, simp only [mem_singleton_iff.1 ha] }
assume a ha
simp only [mem_singleton_iff.1 ha]
rw [integrable_on, integrable_congr this, integrable_const_iff]
simp
intros
set F : ℝ → E := update (update f a fa) b fb
have Fderiv : ∀ x ∈ Ioo a b, has_deriv_at F (f' x) x
refine λ x hx, (hderiv x hx).congr_of_eventually_eq _
{ refine λ x hx, (hderiv x hx).congr_of_eventually_eq _, filter_upwards [Ioo_mem_nhds hx.1 hx.2], intros y hy, simp only [F], rw [update_noteq hy.2.ne, update_noteq hy.1.ne'] }
filter_upwards [Ioo_mem_nhds hx.1 hx.2]
intros y hy
simp only [F]
rw [update_noteq hy.2.ne, update_noteq hy.1.ne']
have hcont : continuous_on F (Icc a b)
rw [continuous_on_update_iff, continuous_on_update_iff, Icc_diff_right, Ico_diff_left]
{ rw [continuous_on_update_iff, continuous_on_update_iff, Icc_diff_right, Ico_diff_left], refine ⟨⟨λ z hz, (hderiv z hz).continuous_at.continuous_within_at, _⟩, _⟩, { exact λ _, ha.mono_left (nhds_within_mono _ Ioo_subset_Ioi_self) }, { rintro -, refine (hb.congr' _).mono_left (nhds_within_mono _ Ico_subset_Iio_self), filter_upwards [Ioo_mem_nhds_within_Iio (right_mem_Ioc.2 hab)], exact λ z hz, (update_noteq hz.1.ne' _ _).symm } }
refine ⟨⟨λ z hz, (hderiv z hz).continuous_at.continuous_within_at, _⟩, _⟩
{ exact λ _, ha.mono_left (nhds_within_mono _ Ioo_subset_Ioi_self) }
exact λ _, ha.mono_left (nhds_within_mono _ Ioo_subset_Ioi_self)
rintro -
{ rintro -, refine (hb.congr' _).mono_left (nhds_within_mono _ Ico_subset_Iio_self), filter_upwards [Ioo_mem_nhds_within_Iio (right_mem_Ioc.2 hab)], exact λ z hz, (update_noteq hz.1.ne' _ _).symm }
refine (hb.congr' _).mono_left (nhds_within_mono _ Ico_subset_Iio_self)
filter_upwards [Ioo_mem_nhds_within_Iio (right_mem_Ioc.2 hab)]
exact λ z hz, (update_noteq hz.1.ne' _ _).symm
simpa [F, hab.ne, hab.ne'] using integral_eq_sub_of_has_deriv_at_of_le hab.le hcont Fderiv hint
intros
rw [interval_integral, interval_integral, L.integral_comp_comm, L.integral_comp_comm, L.map_sub]
exacts [hf.2, hf.1]
intros
induction n with n hn
{ simp }
simp
rw [finset.sum_range_succ, hn (λ k hk, hint k (hk.trans n.lt_succ_self))]
{ rw [finset.sum_range_succ, hn (λ k hk, hint k (hk.trans n.lt_succ_self))], exact integral_add_adjacent_intervals (interval_integrable.trans_iterate $ λ k hk, hint k (hk.trans n.lt_succ_self)) (hint n n.lt_succ_self) }
exact integral_add_adjacent_intervals (interval_integrable.trans_iterate $ λ k hk, hint k (hk.trans n.lt_succ_self)) (hint n n.lt_succ_self)
intros
simp
intros
ext1 s hs
simp_rw [sum_apply _ hs, with_density_apply _ hs]
change ∫⁻ x in s, (∑' n, f n) x ∂μ = ∑' (i : ℕ), ∫⁻ x, f i x ∂(μ.restrict s)
rw ← lintegral_tsum h
refine lintegral_congr (λ x, tsum_apply (pi.summable.2 (λ _, ennreal.summable)))
intros
rw lintegral_eq_zero_iff' (hf.pow_const p) at hf_zero
refine filter.eventually.mp hf_zero (filter.eventually_of_forall (λ x, _))
dsimp only
rw [pi.zero_apply, rpow_eq_zero_iff]
intro hx
cases hx
{ exact hx.left, }
exact hx.left
exfalso
{ exfalso, linarith, }
linarith
intros
rw [e.restrict_map, integral_map_equiv]
intros
rw [pi_def]
{ rw [pi_def], exact measurable_set.bInter hs (λ i hi, measurable_pi_apply _ (ht i hi)) }
exact measurable_set.bInter hs (λ i hi, measurable_pi_apply _ (ht i hi))
intros
rw inter_eq_compl_compl_union_compl
{ rw inter_eq_compl_compl_union_compl, exact (h₁.compl.union h₂.compl).compl }
exact (h₁.compl.union h₂.compl).compl
intros
simp only [volume_pi_Ioo, ennreal.to_real_prod, ennreal.to_real_of_real (sub_nonneg.2 (h _))]
intros
rw ← measure_bUnion_finset H h
{ rw ← measure_bUnion_finset H h, exact measure_mono (subset_univ _) }
exact measure_mono (subset_univ _)
intros
simpa [h₁, h₂] using m.union s₁ s₂
intros
refine le_antisymm (le_of_function.2 $ λ s, _) (λ s, _)
{ rw comap_apply, apply of_function_le }
rw comap_apply
apply of_function_le
rw [comap_apply, of_function_apply, of_function_apply]
{ rw [comap_apply, of_function_apply, of_function_apply], refine infi_le_infi2 (λ t, ⟨λ k, f ⁻¹' (t k), _⟩), refine infi_le_infi2 (λ ht, _), rw [set.image_subset_iff, preimage_Union] at ht, refine ⟨ht, ennreal.tsum_le_tsum $ λ n, _⟩, cases h, exacts [h (image_preimage_subset _ _), (congr_arg m (h.image_preimage (t n))).le] }
refine infi_le_infi2 (λ t, ⟨λ k, f ⁻¹' (t k), _⟩)
refine infi_le_infi2 (λ ht, _)
rw [set.image_subset_iff, preimage_Union] at ht
refine ⟨ht, ennreal.tsum_le_tsum $ λ n, _⟩
cases h
exacts [h (image_preimage_subset _ _), (congr_arg m (h.image_preimage (t n))).le]
intros
rw [restrict_apply v hi hj, inter_eq_left_iff_subset.2 hij]
intros
apply pmf.ext
rintro c
simp only [ennreal.coe_eq_coe.symm, coe_bind_on_support_apply, ← tsum_dite_right, ennreal.tsum_mul_left.symm, ennreal.tsum_mul_right.symm]
refine trans (ennreal.tsum_comm) (tsum_congr (λ b, tsum_congr (λ a, _)))
split_ifs with h1 h2 h2; ring
split_ifs with h1 h2 h2
ring
ring
ring
ring
{ rw bernoulli'_def, norm_num [sum_range_succ] }
rw bernoulli'_def
norm_num [sum_range_succ]
intros
refine mt ((ring_hom.injective_iff _).mp bS.algebra_map_injective _) _
simp only [finset.prod_eq_zero_iff, not_exists]
rintros x hx rfl
exact finset_approx.zero_not_mem bS adm hx
intros
simpa
intros
ext x
rw ring_hom.mem_ker
split
intro h
{ intro h, suffices : x.appr n = 0, { convert appr_spec n x, simp only [this, sub_zero, cast_zero], }, dsimp [to_zmod_pow, to_zmod_hom] at h, rw zmod.nat_coe_zmod_eq_zero_iff_dvd at h, apply eq_zero_of_dvd_of_lt h (appr_lt _ _), }
suffices : x.appr n = 0
{ convert appr_spec n x, simp only [this, sub_zero, cast_zero], }
convert appr_spec n x
simp only [this, sub_zero, cast_zero]
dsimp [to_zmod_pow, to_zmod_hom] at h
rw zmod.nat_coe_zmod_eq_zero_iff_dvd at h
apply eq_zero_of_dvd_of_lt h (appr_lt _ _)
intro h
{ intro h, rw ← sub_zero x at h, dsimp [to_zmod_pow, to_zmod_hom], rw [zmod_congr_of_sub_mem_span n x _ 0 _ h, cast_zero], apply appr_spec, }
rw ← sub_zero x at h
dsimp [to_zmod_pow, to_zmod_hom]
rw [zmod_congr_of_sub_mem_span n x _ 0 _ h, cast_zero]
apply appr_spec
intros
rw [sup_comm, sup_sdiff_self_right, sup_comm]
intros
rw [sdiff_sdiff_right, inf_idem, sdiff_self, bot_sup_eq]
intros
simp [disjoint_iff]
intros
simp only [insert_eq, bdd_below_union, bdd_below_singleton, true_and]
intros
tfae_have : 1 → 2
exact well_founded.is_Sup_finite_compact α
exact well_founded.is_Sup_finite_compact α
{ exact well_founded.is_Sup_finite_compact α, }
{ exact well_founded.is_Sup_finite_compact α, }
tfae_have : 2 → 3
exact is_Sup_finite_compact.is_sup_closed_compact α
exact is_Sup_finite_compact.is_sup_closed_compact α
{ exact is_Sup_finite_compact.is_sup_closed_compact α, }
{ exact is_Sup_finite_compact.is_sup_closed_compact α, }
tfae_have : 3 → 1
exact is_sup_closed_compact.well_founded α
exact is_sup_closed_compact.well_founded α
{ exact is_sup_closed_compact.well_founded α, }
{ exact is_sup_closed_compact.well_founded α, }
tfae_have : 2 ↔ 4
exact is_Sup_finite_compact_iff_all_elements_compact α
exact is_Sup_finite_compact_iff_all_elements_compact α
{ exact is_Sup_finite_compact_iff_all_elements_compact α }
{ exact is_Sup_finite_compact_iff_all_elements_compact α }
tfae_finish
intros
apply le_antisymm; simp only [supr_le_iff]
apply le_antisymm
simp only [supr_le_iff]
exact λ i hi, le_Sup ⟨i - n, by { dsimp only, rw nat.sub_add_cancel hi }⟩
{ exact λ i hi, le_Sup ⟨i - n, by { dsimp only, rw nat.sub_add_cancel hi }⟩ }
simp only [supr_le_iff]
exact λ i, le_Sup ⟨i + n, supr_pos (nat.le_add_left _ _)⟩
{ exact λ i, le_Sup ⟨i + n, supr_pos (nat.le_add_left _ _)⟩ }
intros
{ symmetry, exact infi_and }
symmetry
exact infi_and
intros
simpa only [(∘), neg_mul_eq_neg_mul, neg_neg] using tendsto_neg_at_bot_at_top.comp (hf.const_mul_at_bot (neg_pos.2 hr))
intros
erw [(filter_basis.of_sets s).generate, ← (has_basis_generate s).filter_eq]
erw [(filter_basis.of_sets s).generate, ← (has_basis_generate s).filter_eq] ; refl
refl
intros
ext x
suffices : (∀ t ∈ l, x ∈ t) ↔ ∀ i, p i → x ∈ s i
simpa only [mem_Inter, mem_set_of_eq, mem_sInter]
simpa only [mem_Inter, mem_set_of_eq, mem_sInter]
simp_rw h.mem_iff
split
intros h i hi
{ intros h i hi, exact h (s i) ⟨i, hi, subset.refl _⟩ }
exact h (s i) ⟨i, hi, subset.refl _⟩
rintros h _ ⟨i, hi, sub⟩
{ rintros h _ ⟨i, hi, sub⟩, exact sub (h i hi) }
exact sub (h i hi)
intros
simp
intros
rw [← principal_singleton, comap_principal]
intros
simp only [filter.push_pull, inf_comm]
intros
simp only [tendsto_def, mem_inf_principal] at *
intros s hs
filter_upwards [h₀ s hs, h₁ s hs]
simp only [mem_preimage]
intros x hp₀ hp₁
split_ifs
exacts [hp₀ h, hp₁ h]
intros
rw [← e.bdd_below_image, e.image_preimage]
intros
refine le_antisymm _ (hy _)
{ refine le_antisymm _ (hy _), rw [← f.apply_symm_apply y, f.map_rel_iff], apply hx }
rw [← f.apply_symm_apply y, f.map_rel_iff]
apply hx
intros
rw [(Δ), sdiff_bot, bot_sdiff, sup_bot_eq]
intros
rw [set.partially_well_ordered_on]
apply forall_congr (λ f, _)
simp [is_bad_seq]
intros
intros t1 t2 ht1 ht2
{intros t1 t2 ht1 ht2, cases h with n h, exact h t1 t2 (set.mem_Inter.mp ht1 n) ht2 }
cases h with n h
exact h t1 t2 (set.mem_Inter.mp ht1 n) ht2
intros
delta algebra.is_algebraic subalgebra.is_algebraic
rw [subtype.forall']
apply forall_congr
rintro ⟨x, hx⟩
apply exists_congr
intro p
apply and_congr iff.rfl
have h : function.injective (S.val) := subtype.val_injective
conv_rhs { rw [← h.eq_iff, alg_hom.map_zero], }
rw [← aeval_alg_hom_apply, S.val_apply]
intros
{ rw mul_comm at H, exact H.of_mul_right_left }
rw mul_comm at H
exact H.of_mul_right_left
intros
obtain ⟨n, hn⟩ := associated_pow_irreducible hx hirr
obtain ⟨u, rfl⟩ := hn.symm
use [n, u]
apply mul_comm
intros
{ ext, simp [submodule.mem_span_singleton, eq_comm] }
ext
simp [submodule.mem_span_singleton, eq_comm]
intros
split
intro hJ
{ intro hJ, refine ⟨⟨{x : R | algebra_map R P x ∈ J}, _, _, _⟩, _⟩, { rw [mem_set_of_eq, ring_hom.map_zero], exact J.val.zero_mem }, { intros a b ha hb, rw [mem_set_of_eq, ring_hom.map_add], exact J.val.add_mem ha hb }, { intros c x hx, rw [smul_eq_mul, mem_set_of_eq, ring_hom.map_mul, ← algebra.smul_def], exact J.val.smul_mem c hx }, { ext x, split, { rintros ⟨y, hy, eq_y⟩, rwa ← eq_y }, { intro hx, obtain ⟨y, eq_x⟩ := (fractional_ideal.mem_one_iff S).mp (hJ hx), rw ← eq_x at *, exact ⟨y, hx, rfl⟩ } } }
refine ⟨⟨{x : R | algebra_map R P x ∈ J}, _, _, _⟩, _⟩
rw [mem_set_of_eq, ring_hom.map_zero]
{ rw [mem_set_of_eq, ring_hom.map_zero], exact J.val.zero_mem }
exact J.val.zero_mem
intros a b ha hb
{ intros a b ha hb, rw [mem_set_of_eq, ring_hom.map_add], exact J.val.add_mem ha hb }
rw [mem_set_of_eq, ring_hom.map_add]
exact J.val.add_mem ha hb
intros c x hx
{ intros c x hx, rw [smul_eq_mul, mem_set_of_eq, ring_hom.map_mul, ← algebra.smul_def], exact J.val.smul_mem c hx }
rw [smul_eq_mul, mem_set_of_eq, ring_hom.map_mul, ← algebra.smul_def]
exact J.val.smul_mem c hx
ext x
{ ext x, split, { rintros ⟨y, hy, eq_y⟩, rwa ← eq_y }, { intro hx, obtain ⟨y, eq_x⟩ := (fractional_ideal.mem_one_iff S).mp (hJ hx), rw ← eq_x at *, exact ⟨y, hx, rfl⟩ } }
split
rintros ⟨y, hy, eq_y⟩
{ rintros ⟨y, hy, eq_y⟩, rwa ← eq_y }
rwa ← eq_y
intro hx
{ intro hx, obtain ⟨y, eq_x⟩ := (fractional_ideal.mem_one_iff S).mp (hJ hx), rw ← eq_x at *, exact ⟨y, hx, rfl⟩ }
obtain ⟨y, eq_x⟩ := (fractional_ideal.mem_one_iff S).mp (hJ hx)
rw ← eq_x at *
exact ⟨y, hx, rfl⟩
rintro ⟨I, hI⟩
{ rintro ⟨I, hI⟩, rw ← hI, apply coe_ideal_le_one }
rw ← hI
apply coe_ideal_le_one
intros
ext g
by_cases hg : g ∈ set.range f
obtain ⟨a, rfl⟩ := hg
{ obtain ⟨a, rfl⟩ := hg, simp }
simp
{ simp [emb_domain_notin_range, hg] }
simp [emb_domain_notin_range, hg]
intros
rw [←gcd_eq_one_iff_coprime, nat.coprime_iff_gcd_eq_one, gcd_eq_nat_abs]
intros
letI : algebra R S := f.to_algebra
have := fg_mul _ _ (fg_adjoin_singleton_of_integral x hx) (fg_adjoin_singleton_of_integral y hy)
rw [← algebra.adjoin_union_coe_submodule, set.singleton_union] at this
exact is_integral_of_mem_of_fg (algebra.adjoin R {x, y}) this z (algebra.mem_adjoin_iff.2 $ subring.closure_mono (set.subset_union_right _ _) hz)
intros
rw [← enat.coe_inj, enat.coe_get, unique hk hsucc]
intros
simp [frange, eq_comm]
intros
obtain ⟨n, rfl⟩ := nat.exists_eq_add_of_le h
rw add_comm
exact U_add_two R n
intros
rw degree_cyclotomic n R
{ rw degree_cyclotomic n R, exact_mod_cast (nat.totient_pos hpos) }
exact_mod_cast (nat.totient_pos hpos)
intros
simp
intros
obtain ⟨f, rfl⟩ := pb.exists_eq_aeval' x
obtain ⟨g, rfl⟩ := pb.exists_eq_aeval' x'
simp only [← aeval_mul, pb.constr_pow_aeval hy]
intros
simp
intros
by_cases hp0 : p = 0
{ simp [hp0] }
simp [hp0]
refine ⟨λ h, _, prime.irreducible⟩
obtain ⟨f, hf⟩ := pf p hp0
obtain ⟨q, hq, rfl⟩ := prime_factors_irreducible h hf
rw hq.prime_iff
exact hf.1 q (multiset.mem_singleton_self _)
intros
apply le_antisymm
rintro ⟨x⟩ hx
{ rintro ⟨x⟩ hx, apply ideal.subset_span, exact ⟨x, hx, rfl⟩ }
apply ideal.subset_span
exact ⟨x, hx, rfl⟩
rw ideal.map_le_iff_le_comap
{ rw ideal.map_le_iff_le_comap, intros x hx, exact hx }
intros x hx
exact hx
intros
rw [← frobenius_verschiebung, frobenius_zmodp]
intros
witt_truncate_fun_tac
intros
apply nat.strong_induction_on n; clear n
apply nat.strong_induction_on n
clear n
intros n IH
rw [X_in_terms_of_W_eq, mul_comm, ring_hom.map_mul, ring_hom.map_sub, ring_hom.map_sum, constant_coeff_C, sum_eq_zero]
{ simp only [constant_coeff_X, sub_zero, mul_zero] }
simp only [constant_coeff_X, sub_zero, mul_zero]
intros m H
{ intros m H, rw mem_range at H, simp only [ring_hom.map_mul, ring_hom.map_pow, constant_coeff_C, IH m H], rw [zero_pow, mul_zero], apply pow_pos hp.1.pos, }
rw mem_range at H
simp only [ring_hom.map_mul, ring_hom.map_pow, constant_coeff_C, IH m H]
rw [zero_pow, mul_zero]
apply pow_pos hp.1.pos
intros
{unfold_sizeof, apply sizeof_pos}
unfold_sizeof
apply sizeof_pos
intros
simp only [le_antisymm_iff, succ_le_succ]
intros
simp
intros
simpa [normalize_fin_lt, ← e, ← hn] using h
intro h1
rcases h1 with ⟨c,h1,h2⟩
cases h1
intros
constructor; intro h1
constructor
intro h1
{ cases h1, apply le_antisymm; assumption }
cases h1
apply le_antisymm
apply le_antisymm; assumption
assumption
assumption
intro h1
constructor; apply le_of_eq; rw h1
constructor; apply le_of_eq
{ constructor; apply le_of_eq; rw h1 }
constructor
apply le_of_eq
rw h1
apply le_of_eq
rw h1
intros
simp [horner]
intros
induction xs generalizing ys i
case list.nil : ys i h₁ h₂ { cases h₂ }
cases h₂
case list.cons : x' xs xs_ih ys i h₁ h₂ { cases i, { injection h₂ with h₀ h₁, subst h₀, cases ys, { cases h₁ }, { simp only [list.apply_id, to_sigma, option.get_or_else_some, nth, lookup_cons_eq, zip_cons_cons, list.map], } }, { cases ys, { cases h₁ }, { cases h₀ with _ _ h₀ h₁, simp only [nth, zip_cons_cons, list.apply_id_cons] at h₂ ⊢, rw if_neg, { apply xs_ih; solve_by_elim [succ.inj] }, { apply h₀, apply nth_mem h₂ } } } }
intros
simp [nhds_infty_eq, and_comm]
intros
rw set_like.ext'_iff at hs ⊢
simp only [subgroup.topological_closure_coe, subgroup.coe_top, ← dense_iff_closure_eq] at hs ⊢
exact hf'.dense_image hf hs
intros
convert hs.to_finset.summable f; simp only [hs.coe_to_finset]
convert hs.to_finset.summable f
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
simp only [hs.coe_to_finset]
intros
refine iff.trans _ ((range k).has_sum_compl_iff)
rw [← (not_mem_range_equiv k).symm.has_sum_iff]
refl
intros
have hx : 0 < 2 * (1 + abs x) := (mul_pos (zero_lt_two) $ lt_of_lt_of_le zero_lt_one $ le_add_of_le_of_nonneg le_rfl (abs_nonneg x))
rw ((nhds_basis_zero_abs_sub_lt α).prod $ nhds_basis_abs_sub_lt x).tendsto_iff (nhds_basis_zero_abs_sub_lt α)
refine λ ε ε_pos, ⟨(ε/(2 * (1 + abs x)), 1), ⟨div_pos ε_pos hx, zero_lt_one⟩, _⟩
suffices : ∀ (a b : α), abs a < ε / (2 * (1 + abs x)) → abs (b - x) < 1 → (abs a) * (abs b) < ε
simpa only [and_imp, prod.forall, mem_prod, ← abs_mul]
simpa only [and_imp, prod.forall, mem_prod, ← abs_mul]
intros a b h h'
refine lt_of_le_of_lt (mul_le_mul_of_nonneg_left _ (abs_nonneg a)) ((lt_div_iff hx).1 h)
calc abs b = abs ((b - x) + x) : by rw sub_add_cancel b x ... ≤ abs (b - x) + abs x : abs_add (b - x) x ... ≤ 1 + abs x : add_le_add_right (le_of_lt h') (abs x) ... ≤ 2 * (1 + abs x) : by linarith
intros
rw [← compl_Iio, interior_compl, closure_Iio, compl_Iic]
intros
rw [← nhds_within_union, Iic_union_Ioi, nhds_within_univ]
intros
rw union_eq_Union; exact is_open_Union (bool.forall_bool.2 ⟨h₂, h₁⟩)
rw union_eq_Union
exact is_open_Union (bool.forall_bool.2 ⟨h₂, h₁⟩)
intros
simp [closure_eq_compl_interior_compl]
intros
simp only [cluster_pt, inf_eq_left.mpr H, nhds_ne_bot]
intros
simp
intros
rw ←set.image_univ
{ rw ←set.image_univ, exact is_closed_map_sigma_mk _ is_closed_univ }
exact is_closed_map_sigma_mk _ is_closed_univ
intros
simp only [norm_eq, coe_norm_comp, norm_norm]
intros
intros x hx
by_cases hx' : x ∈ frontier t
exact (hpf x ⟨hx, hx'⟩).piecewise_nhds_within (hpg x ⟨hx, hx'⟩)
{ exact (hpf x ⟨hx, hx'⟩).piecewise_nhds_within (hpg x ⟨hx, hx'⟩) }
rw [← inter_univ s, ← union_compl_self t, inter_union_distrib_left] at hx ⊢
{ rw [← inter_univ s, ← union_compl_self t, inter_union_distrib_left] at hx ⊢, cases hx, { apply continuous_within_at.union, { exact (hf x hx).congr (λ y hy, piecewise_eq_of_mem _ _ _ hy.2) (piecewise_eq_of_mem _ _ _ hx.2) }, { have : x ∉ closure tᶜ, from λ h, hx' ⟨subset_closure hx.2, by rwa closure_compl at h⟩, exact continuous_within_at_of_not_mem_closure (λ h, this (closure_inter_subset_inter_closure _ _ h).2) } }, { apply continuous_within_at.union, { have : x ∉ closure t, from (λ h, hx' ⟨h, (λ (h' : x ∈ interior t), hx.2 (interior_subset h'))⟩), exact continuous_within_at_of_not_mem_closure (λ h, this (closure_inter_subset_inter_closure _ _ h).2) }, { exact (hg x hx).congr (λ y hy, piecewise_eq_of_not_mem _ _ _ hy.2) (piecewise_eq_of_not_mem _ _ _ hx.2) } } }
cases hx
apply continuous_within_at.union
{ apply continuous_within_at.union, { exact (hf x hx).congr (λ y hy, piecewise_eq_of_mem _ _ _ hy.2) (piecewise_eq_of_mem _ _ _ hx.2) }, { have : x ∉ closure tᶜ, from λ h, hx' ⟨subset_closure hx.2, by rwa closure_compl at h⟩, exact continuous_within_at_of_not_mem_closure (λ h, this (closure_inter_subset_inter_closure _ _ h).2) } }
exact (hf x hx).congr (λ y hy, piecewise_eq_of_mem _ _ _ hy.2) (piecewise_eq_of_mem _ _ _ hx.2)
{ exact (hf x hx).congr (λ y hy, piecewise_eq_of_mem _ _ _ hy.2) (piecewise_eq_of_mem _ _ _ hx.2) }
have : x ∉ closure tᶜ
{ have : x ∉ closure tᶜ, from λ h, hx' ⟨subset_closure hx.2, by rwa closure_compl at h⟩, exact continuous_within_at_of_not_mem_closure (λ h, this (closure_inter_subset_inter_closure _ _ h).2) }
from λ h, hx' ⟨subset_closure hx.2, by rwa closure_compl at h⟩
exact continuous_within_at_of_not_mem_closure (λ h, this (closure_inter_subset_inter_closure _ _ h).2)
apply continuous_within_at.union
{ apply continuous_within_at.union, { have : x ∉ closure t, from (λ h, hx' ⟨h, (λ (h' : x ∈ interior t), hx.2 (interior_subset h'))⟩), exact continuous_within_at_of_not_mem_closure (λ h, this (closure_inter_subset_inter_closure _ _ h).2) }, { exact (hg x hx).congr (λ y hy, piecewise_eq_of_not_mem _ _ _ hy.2) (piecewise_eq_of_not_mem _ _ _ hx.2) } }
have : x ∉ closure t
{ have : x ∉ closure t, from (λ h, hx' ⟨h, (λ (h' : x ∈ interior t), hx.2 (interior_subset h'))⟩), exact continuous_within_at_of_not_mem_closure (λ h, this (closure_inter_subset_inter_closure _ _ h).2) }
from (λ h, hx' ⟨h, (λ (h' : x ∈ interior t), hx.2 (interior_subset h'))⟩)
exact continuous_within_at_of_not_mem_closure (λ h, this (closure_inter_subset_inter_closure _ _ h).2)
exact (hg x hx).congr (λ y hy, piecewise_eq_of_not_mem _ _ _ hy.2) (piecewise_eq_of_not_mem _ _ _ hx.2)
{ exact (hg x hx).congr (λ y hy, piecewise_eq_of_not_mem _ _ _ hy.2) (piecewise_eq_of_not_mem _ _ _ hx.2) }
intros
obtain ⟨x,hx⟩ := is_compact.nonempty_Inter_of_directed_nonempty_compact_closed (λ (Q : discrete_quotient X), Q.proj ⁻¹' {Qs _}) (λ A B, _) (λ i, _) (λ i, (fiber_closed _ _).is_compact) (λ i, fiber_closed _ _)
refine ⟨x, λ Q, _⟩
{ refine ⟨x, λ Q, _⟩, specialize hx _ ⟨Q,rfl⟩, dsimp at hx, rcases proj_surjective _ (Qs Q) with ⟨y,hy⟩, rw ← hy at *, rw fiber_eq at hx, exact quotient.sound' (Q.symm y x hx) }
specialize hx _ ⟨Q,rfl⟩
dsimp at hx
rcases proj_surjective _ (Qs Q) with ⟨y,hy⟩
rw ← hy at *
rw fiber_eq at hx
exact quotient.sound' (Q.symm y x hx)
refine ⟨A ⊓ B, λ a ha, _, λ a ha, _⟩
{ refine ⟨A ⊓ B, λ a ha, _, λ a ha, _⟩, { dsimp only, erw ← compat (A ⊓ B) A inf_le_left, exact fiber_le_of_le _ _ ha }, { dsimp only, erw ← compat (A ⊓ B) B inf_le_right, exact fiber_le_of_le _ _ ha } }
dsimp only
{ dsimp only, erw ← compat (A ⊓ B) A inf_le_left, exact fiber_le_of_le _ _ ha }
erw ← compat (A ⊓ B) A inf_le_left
exact fiber_le_of_le _ _ ha
dsimp only
{ dsimp only, erw ← compat (A ⊓ B) B inf_le_right, exact fiber_le_of_le _ _ ha }
erw ← compat (A ⊓ B) B inf_le_right
exact fiber_le_of_le _ _ ha
obtain ⟨x,hx⟩ := i.proj_surjective (Qs i)
{ obtain ⟨x,hx⟩ := i.proj_surjective (Qs i), refine ⟨x,_⟩, dsimp only, rw [← hx, fiber_eq], apply i.refl }
refine ⟨x,_⟩
dsimp only
rw [← hx, fiber_eq]
apply i.refl
intros
rw [h.nhds_eq_comap, h.apply_symm_apply]
intros
rw _root_.mem_nhds_iff
by_cases x0 : x = 0
use Iio (x + ε)
{ use Iio (x + ε), have : Iio (x + ε) ⊆ Icc (x - ε) (x + ε), assume a, rw x0, simpa using le_of_lt, use this, exact ⟨is_open_Iio, mem_Iio_self_add xt ε0⟩ }
have : Iio (x + ε) ⊆ Icc (x - ε) (x + ε)
assume a
rw x0
simpa using le_of_lt
use this
exact ⟨is_open_Iio, mem_Iio_self_add xt ε0⟩
use Ioo (x - ε) (x + ε)
{ use Ioo (x - ε) (x + ε), use Ioo_subset_Icc_self, exact ⟨is_open_Ioo, mem_Ioo_self_sub_add xt x0 ε0 ε0 ⟩ }
use Ioo_subset_Icc_self
exact ⟨is_open_Ioo, mem_Ioo_self_sub_add xt x0 ε0 ε0 ⟩
intros
rw [iff_symm_preimage_eq, ← image_source_inter_eq, ← image_source_inter_eq']
intros
intros s hs; rw [image_comp]; exact hg _ (hf _ hs)
intros s hs; rw [image_comp]
intros s hs
rw [image_comp]
exact hg _ (hf _ hs)
intros
apply proper_space_of_compact_closed_ball_of_le 0 (λx₀ r hr, _)
let K := f ⁻¹' (closed_ball x₀ r)
have A : is_closed K := is_closed_ball.preimage f_cont
have B : bounded K := hK.bounded_preimage bounded_closed_ball
have : is_compact K := compact_iff_closed_bounded.2 ⟨A, B⟩
convert this.image f_cont
exact (hf.image_preimage _).symm
intros
rw ← pseudo_metric_space.uniformity_dist.symm
refine has_basis_binfi_principal _ nonempty_Ioi
exact λ r (hr : 0 < r) p (hp : 0 < p), ⟨min r p, lt_min hr hp, λ x (hx : dist _ _ < _), lt_of_lt_of_le hx (min_le_left r p), λ x (hx : dist _ _ < _), lt_of_lt_of_le hx (min_le_right r p)⟩
intros
simpa only [dist_comm _ z] using abs_sub_right_of_mem_interval h
intros
convert tendsto_iterate_efixed_point hf (edist_ne_top x _)
refine (fixed_point_unique _ _).symm
apply efixed_point_is_fixed_pt
intros
funext
simp only [comp, to_inductive_limit, quotient.eq]
show inductive_limit_dist f ⟨n.succ, f n x⟩ ⟨n, x⟩ = 0
rw [inductive_limit_dist_eq_dist I ⟨n.succ, f n x⟩ ⟨n, x⟩ n.succ, le_rec_on_self, le_rec_on_succ, le_rec_on_self, dist_self]
{ rw [inductive_limit_dist_eq_dist I ⟨n.succ, f n x⟩ ⟨n, x⟩ n.succ, le_rec_on_self, le_rec_on_succ, le_rec_on_self, dist_self], exact le_refl _, exact le_refl _, exact le_succ _ }
exact le_refl _
exact le_refl _
exact le_succ _
intros
apply metric.diam_le_of_forall_dist_le (mul_nonneg K.coe_nonneg metric.diam_nonneg)
rintros _ ⟨x, hx, rfl⟩ _ ⟨y, hy, rfl⟩
calc dist (f x) (f y) ≤ ↑K * dist x y : hf.dist_le_mul x y ... ≤ ↑K * metric.diam s : mul_le_mul_of_nonneg_left (metric.dist_le_diam_of_mem hs hx hy) K.2
intros
have : ∀ (s t : set X), is_closed s → is_closed t → (∀ x ∈ s, ∃ u v, is_open u ∧ is_open v ∧ x ∈ u ∧ t ⊆ v ∧ disjoint u v) → ∃ u v, is_open u ∧ is_open v ∧ s ⊆ u ∧ t ⊆ v ∧ disjoint u v
intros s t hs ht H
{ intros s t hs ht H, choose u v hu hv hxu htv huv using set_coe.forall'.1 H, rcases precise_refinement_set hs u hu (λ x hx, mem_Union.2 ⟨⟨x, hx⟩, hxu _⟩) with ⟨u', hu'o, hcov', hu'fin, hsub⟩, refine ⟨⋃ i, u' i, (closure (⋃ i, u' i))ᶜ, is_open_Union hu'o, is_closed_closure.is_open_compl, hcov', _, disjoint_compl_right.mono le_rfl (compl_le_compl subset_closure)⟩, rw [hu'fin.closure_Union, compl_Union, subset_Inter_iff], refine λ i x hxt hxu, absurd (htv i hxt) (closure_minimal _ (is_closed_compl_iff.2 $ hv _) hxu), exact λ y hyu hyv, huv i ⟨hsub _ hyu, hyv⟩ }
choose u v hu hv hxu htv huv using set_coe.forall'.1 H
rcases precise_refinement_set hs u hu (λ x hx, mem_Union.2 ⟨⟨x, hx⟩, hxu _⟩) with ⟨u', hu'o, hcov', hu'fin, hsub⟩
refine ⟨⋃ i, u' i, (closure (⋃ i, u' i))ᶜ, is_open_Union hu'o, is_closed_closure.is_open_compl, hcov', _, disjoint_compl_right.mono le_rfl (compl_le_compl subset_closure)⟩
rw [hu'fin.closure_Union, compl_Union, subset_Inter_iff]
refine λ i x hxt hxu, absurd (htv i hxt) (closure_minimal _ (is_closed_compl_iff.2 $ hv _) hxu)
exact λ y hyu hyv, huv i ⟨hsub _ hyu, hyv⟩
refine ⟨λ s t hs ht hst, this s t hs ht (λ x hx, _)⟩
rcases this t {x} ht is_closed_singleton (λ y hyt, _) with ⟨v, u, hv, hu, htv, hxu, huv⟩
exact ⟨u, v, hu, hv, singleton_subset_iff.1 hxu, htv, huv.symm⟩
{ exact ⟨u, v, hu, hv, singleton_subset_iff.1 hxu, htv, huv.symm⟩ }
have : x ≠ y
{ have : x ≠ y, by { rintro rfl, exact hst ⟨hx, hyt⟩ }, rcases t2_separation this with ⟨v, u, hv, hu, hxv, hyu, hd⟩, exact ⟨u, v, hu, hv, hyu, singleton_subset_iff.2 hxv, disjoint.symm hd.le⟩ }
rintro rfl
rintro rfl
{ rintro rfl, exact hst ⟨hx, hyt⟩ }
{ rintro rfl, exact hst ⟨hx, hyt⟩ }
exact hst ⟨hx, hyt⟩
exact hst ⟨hx, hyt⟩
rcases t2_separation this with ⟨v, u, hv, hu, hxv, hyu, hd⟩
exact ⟨u, v, hu, hv, hyu, singleton_subset_iff.2 hxv, disjoint.symm hd.le⟩
intros
simp_rw [← lower_semicontinuous_within_at_univ_iff] at *
exact lower_semicontinuous_within_at_sum ha
intros
rcases (nhds_within_has_basis hb s).mem_iff.1 (singleton_mem_nhds_within_of_mem_discrete hx) with ⟨i, hi, hix⟩
exact ⟨i, hi, subset.antisymm hix $ singleton_subset_iff.2 ⟨mem_of_mem_nhds $ hb.mem_of_mem hi, hx⟩⟩
intros
rw [uniform_continuous, uniformity_prod_eq_prod, tendsto_map'_iff, (∘)] at hf
rcases mem_map_iff_exists_image'.1 (hf hs) with ⟨t, ht, hts⟩
clear hf
rcases mem_prod_iff.1 ht with ⟨u, hu, v, hv, huvt⟩
clear ht
refine ⟨u, hu, assume a b c hab, hts $ (mem_image _ _ _).2 ⟨⟨⟨a, b⟩, ⟨c, c⟩⟩, huvt ⟨_, _⟩, _⟩⟩
exact hab
exact refl_mem_uniformity hv
refl
intros
rw ← bind_pure_comp_eq_map _ (x.run r); refl
rw ← bind_pure_comp_eq_map _ (x.run r)
refl
intros
cases a; cases b; exact dec_trivial
cases a; cases b
cases a
cases b
exact dec_trivial
exact dec_trivial
cases b
exact dec_trivial
exact dec_trivial
intros
rw [int.sub_eq_add_neg, int.add_assoc, ←int.sub_eq_add_neg]
intros
have h := int.add_le_add_right h b
rwa [int.sub_add_cancel, int.add_comm] at h
intros
cases l; refl
cases l
refl
refl
intros
simp [gcd]
intros
by_cases c; simp [*]
by_cases c
simp [*]
simp [*]
intros
{ ext, refl }
ext
refl
intros
rw [prod_insert (not_mem_singleton.2 h), prod_singleton]
intros
{ simp_rw apply_ite k, exact prod_ite_of_true _ _ h }
simp_rw apply_ite k
exact prod_ite_of_true _ _ h
intros
rw [univ_filter_succ_lt, finset.prod_map, rel_embedding.coe_fn_to_embedding, coe_succ_embedding]
intros
by_contra h'
push_neg at h'
exact h (finprod_mem_of_eq_on_one h')
intros
simp only [finsupp.sum, finset.mul_sum]
intros
refine le_trans (multiset.le_prod_nonempty_of_submultiplicative_on_pred f p h_mul hp_mul _ _ _) _
{ simp [hs_nonempty.ne_empty], }
simp [hs_nonempty.ne_empty]
{ exact multiset.forall_mem_map_iff.mpr hs, }
exact multiset.forall_mem_map_iff.mpr hs
rw multiset.map_map
refl
intros
suffices : (2 : R) ≠ 0
symmetry
{ symmetry, rw [ne.def, ← sub_eq_zero, sub_neg_eq_add], exact this }
rw [ne.def, ← sub_eq_zero, sub_neg_eq_add]
exact this
assume h
rw [show (2 : R) = (2 : ℕ), by norm_cast] at h
have := (char_p.cast_eq_zero_iff R p 2).mp h
have := nat.le_of_dvd dec_trivial this
rw fact_iff at *
linarith
intros
rw [terminated_at_iff_s_none] at terminated_at_n
{ rw [terminated_at_iff_s_none] at terminated_at_n, simp only [terminated_at_n, continuants_aux] }
simp only [terminated_at_n, continuants_aux]
intros
rw lcm
by_cases h : gcd x y = 0
rw [h, zero_mul]
{ rw [h, zero_mul], rw euclidean_domain.gcd_eq_zero_iff at h, rw [h.1, zero_mul] }
rw euclidean_domain.gcd_eq_zero_iff at h
rw [h.1, zero_mul]
rcases gcd_dvd x y with ⟨⟨r, hr⟩, ⟨s, hs⟩⟩
generalize_hyp : gcd x y = g at h hr ⊢
subst hr
rw [mul_assoc, mul_div_cancel_left _ h]
intros
simp [geom_sum_def, f.map_sum]
intros
{ ext z, rw [function.comp_apply, @is_associative.assoc _ f] }
ext z
rw [function.comp_apply, @is_associative.assoc _ f]
intros
rw [sub_eq_add_neg, add_neg_eq_iff_eq_add]
intros
rw [sub_eq_iff_eq_add, sub_add_eq_add_sub, eq_comm, sub_eq_iff_eq_add']
simp only [add_comm, eq_comm]
intros
rw [units.inv_mul_eq_iff_eq_mul, mul_one, coe_lift_right]
intros
induction n with n ih; [exact pow_zero _, rw [pow_succ, ih, one_mul]]
induction n with n ih
exact pow_zero _
rw [pow_succ, ih, one_mul]
intros
induction b with b ih
{ erw [pow_zero, to_add_one, mul_zero] }
erw [pow_zero, to_add_one, mul_zero]
{ simp [*, pow_succ, add_comm, nat.mul_succ] }
simp [*, pow_succ, add_comm, nat.mul_succ]
intros
rw [div_eq_mul_inv, mul_inv_mul_self a]
intros
rw [div_eq_mul_inv, mul_comm]
intros
cases i; refl
{ cases i; refl, }
cases i
refl
refl
intros
rw C.d_from_eq r
apply kernel_subobject_comp_mono
intros
{ dsimp [cycles], simp, }
dsimp [cycles]
simp
intros
dsimp [d_next]
rcases c.next i with _|⟨i',w⟩
{ exact comp_zero.symm, }
exact comp_zero.symm
dsimp [d_next]
{ dsimp [d_next], simp, }
simp
intros
{ rw [d_to_eq ((single₀ V).obj X) rfl], simp, }
rw [d_to_eq ((single₀ V).obj X) rfl]
simp
intros
rw [sub_eq_add_neg, indicator_compl']
intros
ext
{ ext, simp only [coe_max_triv_equiv_apply, lie_module_equiv.refl_apply], }
simp only [coe_max_triv_equiv_apply, lie_module_equiv.refl_apply]
intros
ext x y
rcases x
rcases x; rcases y
rcases y
by_cases h : x = y; simp [Pso, indefinite_diagonal, h]
by_cases h : x = y
{ by_cases h : x = y; simp [Pso, indefinite_diagonal, h], }
simp [Pso, indefinite_diagonal, h]
simp [Pso, indefinite_diagonal, h]
{ simp [Pso, indefinite_diagonal], }
simp [Pso, indefinite_diagonal]
rcases y
{ simp [Pso, indefinite_diagonal], }
simp [Pso, indefinite_diagonal]
by_cases h : x = y; simp [Pso, indefinite_diagonal, h, hi]
by_cases h : x = y
{ by_cases h : x = y; simp [Pso, indefinite_diagonal, h, hi], }
simp [Pso, indefinite_diagonal, h, hi]
simp [Pso, indefinite_diagonal, h, hi]
intros
induction k with k ih
{ simp only [function.iterate_zero], }
simp only [function.iterate_zero]
simp only [lower_central_series_succ, function.comp_app, function.iterate_succ', to_endomorphism_apply_apply]
{ simp only [lower_central_series_succ, function.comp_app, function.iterate_succ', to_endomorphism_apply_apply], exact lie_submodule.lie_mem_lie _ _ (lie_submodule.mem_top x) ih, }
exact lie_submodule.lie_mem_lie _ _ (lie_submodule.mem_top x) ih
intros
{ rw [←lie_skew, ←neg_lie], apply lie_mem_right, assumption, }
rw [←lie_skew, ←neg_lie]
apply lie_mem_right
assumption
intros
{ rw map_le_iff_le_comap, apply le_refl _, }
rw map_le_iff_le_comap
apply le_refl _
intros
split
split; intros h
intros h
{ ext, rw [← mem_coe_submodule, h], simp, }
ext
rw [← mem_coe_submodule, h]
simp
intros h
{ rw h, }
rw h
intros
rw [←neg_neg c, neg_smul, neg_smul (-c), neg_inj] at hab
exact eq_of_smul_eq_smul_of_pos_of_le hab (neg_pos_of_neg hc) h
intros
rw [mul_comm, lt_div_iff hc]
intros
rw [div_eq_mul_inv, div_eq_mul_inv]
exact mul_le_mul_of_nonneg_left ((inv_le_inv (hc.trans_le h) hc).mpr h) ha
intros
simp [lt_max_iff, max_lt_iff, *]
intros
rw [← mul_lt_mul_iff_left a, mul_inv_self, mul_one]
intros
rw [← inv_mul_le_iff_le_mul, mul_comm]
intros
simpa only [div_eq_mul_inv] using max_mul_mul_right a b (c⁻¹)
intros
simpa [min_comm _ c] using min_mul_distrib c a b
intros
have : 0 < a * ⅟a
simp only [mul_inv_of_self, zero_lt_one]
simp only [mul_inv_of_self, zero_lt_one]
exact ⟨λ h, pos_of_mul_pos_right this h.le, λ h, pos_of_mul_pos_left this h.le⟩
intros
by_cases ha : a ≤ 0
simp [le_antisymm ha h₁]
{ simp [le_antisymm ha h₁] }
by_cases hb : b ≤ 0
simp [le_antisymm hb h₂]
{ simp [le_antisymm hb h₂] }
exact (le_not_le_of_lt (ordered_ring.mul_pos a b (h₁.lt_of_not_le ha) (h₂.lt_of_not_le hb))).1
intros
simp * at *
intros
simp only [← inv_preimage]
{ simp only [← inv_preimage], rw [image_eq_preimage_of_inverse]; intro; simp only [inv_inv] }
rw [image_eq_preimage_of_inverse]
rw [image_eq_preimage_of_inverse]; intro; simp only [inv_inv]
rw [image_eq_preimage_of_inverse]; intro
intro
simp only [inv_inv]
simp only [inv_inv]
intro
simp only [inv_inv]
simp only [inv_inv]
intros
simpa using nat_degree_multiset_prod_le (s.1.map f)
intros
rw [map_one, eq_comm]
intros
rw [add_mul, mul_sub, mul_sub, mul_comm a b, sub_add_sub_cancel]
intros
simp [bit1]
intros
rw [set.mem_compl_eq, mem_zero_locus, set.singleton_subset_iff]
rw [set.mem_compl_eq, mem_zero_locus, set.singleton_subset_iff]; refl
refl
intros
rw is_equivalent_iff_exists_eq_mul
refine ⟨u/v, huv, hz.mono $ λ x hz', (div_mul_cancel_of_imp hz').symm⟩
intros
refine ⟨div_is_bounded_under_of_is_O, λ h, _⟩
obtain ⟨c, hc⟩ := h
rw filter.eventually_iff at hgf hc
simp only [mem_set_of_eq, mem_map, normed_field.norm_div] at hc
refine is_O_iff.2 ⟨c, filter.eventually_of_mem (inter_mem hgf hc) (λ x hx, _)⟩
by_cases hgx : g x = 0
{ simp [hx.1 hgx, hgx] }
simp [hx.1 hgx, hgx]
{ refine (div_le_iff (norm_pos_iff.2 hgx)).mp hx.2 }
refine (div_le_iff (norm_pos_iff.2 hgx)).mp hx.2
intros
simp only [is_O_with, norm_neg]
intros
unfold is_o at *
intros c cpos
rcases h₂.exists_pos with ⟨c', c'pos, hc'⟩
exact ((h₁ (div_pos cpos c'pos)).mul hc').congr_const (div_mul_cancel _ (ne_of_gt c'pos))
intros
have := (has_strict_fderiv_at.mul' hc hd).has_strict_deriv_at
rwa [continuous_linear_map.add_apply, continuous_linear_map.smul_apply, continuous_linear_map.smul_right_apply, continuous_linear_map.smul_right_apply, continuous_linear_map.smul_right_apply, continuous_linear_map.one_apply, one_smul, one_smul, add_comm] at this
intros
intro hg
have := (hf.comp a hg.has_deriv_at).congr_of_eventually_eq hfg.symm
simpa using this.unique (has_deriv_at_id a)
intros
simp only [deriv_within, fderiv_within_add_const hxs]
intros
apply has_fderiv_at.fderiv
exact has_fderiv_at.comp x hg.has_fderiv_at hf.has_fderiv_at
intros
simpa only [sub_eq_add_neg] using hf.add hg.neg
intros
{ convert hc.mul_const' d, ext z, apply mul_comm }
convert hc.mul_const' d
ext z
apply mul_comm
intros
rw differentiable_at.fderiv_within e.differentiable_at hxs
exact e.fderiv
intros
apply map_implicit_function_of_complemented_eq
intros
{ ext x, simp [iterated_deriv], refl }
ext x
simp [iterated_deriv]
refl
intros
letI : normed_space ℝ G := restrict_scalars.normed_space ℝ 𝕜 G
letI : is_scalar_tower ℝ 𝕜 G := restrict_scalars.is_scalar_tower _ _ _
have C0 : 0 ≤ C := le_trans (norm_nonneg _) (bound x xs)
set g : ℝ → E := λ t, x + t • (y - x)
have Dg : ∀ t, has_deriv_at g (y-x) t
assume t
{ assume t, simpa only [one_smul] using ((has_deriv_at_id t).smul_const (y - x)).const_add x }
simpa only [one_smul] using ((has_deriv_at_id t).smul_const (y - x)).const_add x
have segm : Icc 0 1 ⊆ g ⁻¹' s
rw [← image_subset_iff, ← segment_eq_image']
{ rw [← image_subset_iff, ← segment_eq_image'], apply hs.segment_subset xs ys }
apply hs.segment_subset xs ys
have : f x = f (g 0)
simp only [g]
simp only [g]
{ simp only [g], rw [zero_smul, add_zero] }
{ simp only [g], rw [zero_smul, add_zero] }
rw [zero_smul, add_zero]
rw [zero_smul, add_zero]
rw this
have : f y = f (g 1)
simp only [g]
simp only [g]
{ simp only [g], rw [one_smul, add_sub_cancel'_right] }
{ simp only [g], rw [one_smul, add_sub_cancel'_right] }
rw [one_smul, add_sub_cancel'_right]
rw [one_smul, add_sub_cancel'_right]
rw this
have D2: ∀ t ∈ Icc (0:ℝ) 1, has_deriv_within_at (f ∘ g) (f' (g t) (y - x)) (Icc 0 1) t
intros t ht
{ intros t ht, have : has_fderiv_within_at f ((f' (g t)).restrict_scalars ℝ) s (g t), from hf (g t) (segm ht), exact this.comp_has_deriv_within_at _ (Dg t).has_deriv_within_at segm }
have : has_fderiv_within_at f ((f' (g t)).restrict_scalars ℝ) s (g t)
from hf (g t) (segm ht)
exact this.comp_has_deriv_within_at _ (Dg t).has_deriv_within_at segm
apply norm_image_sub_le_of_norm_deriv_le_segment_01' D2
refine λ t ht, le_of_op_norm_le _ _ _
exact bound (g t) (segm $ Ico_subset_Icc_self ht)
intros
rw f.closure_support_eq
{ rw f.closure_support_eq, exact euclidean.is_compact_closed_ball }
exact euclidean.is_compact_closed_ball
intros
rwa [times_cont_diff_at, ← times_cont_diff_within_at_inter hx, univ_inter]
intros
set L := λ m, continuous_multilinear_map.prodL 𝕜 (λ i : fin m, E) F G
split
assume x hx
{ assume x hx, rw [← hf.zero_eq x hx, ← hg.zero_eq x hx], refl }
rw [← hf.zero_eq x hx, ← hg.zero_eq x hx]
refl
assume m hm x hx
{ assume m hm x hx, convert (L m).has_fderiv_at.comp_has_fderiv_within_at x ((hf.fderiv_within m hm x hx).prod (hg.fderiv_within m hm x hx)) }
convert (L m).has_fderiv_at.comp_has_fderiv_within_at x ((hf.fderiv_within m hm x hx).prod (hg.fderiv_within m hm x hx))
assume m hm
{ assume m hm, exact (L m).continuous.comp_continuous_on ((hf.cont m hm).prod (hg.cont m hm)) }
exact (L m).continuous.comp_continuous_on ((hf.cont m hm).prod (hg.cont m hm))
intros
split
assume h x hx
{ assume h x hx, rcases (h x hx) n.succ (le_refl _) with ⟨u, hu, p, Hp⟩, refine ⟨u, hu, λ y, (continuous_multilinear_curry_fin1 𝕜 E F) (p y 1), λ y hy, Hp.has_fderiv_within_at (with_top.coe_le_coe.2 (nat.le_add_left 1 n)) hy, _⟩, rw has_ftaylor_series_up_to_on_succ_iff_right at Hp, assume z hz m hm, refine ⟨u, _, λ (x : E), (p x).shift, Hp.2.2.of_le hm⟩, convert self_mem_nhds_within, exact insert_eq_of_mem hz, }
rcases (h x hx) n.succ (le_refl _) with ⟨u, hu, p, Hp⟩
refine ⟨u, hu, λ y, (continuous_multilinear_curry_fin1 𝕜 E F) (p y 1), λ y hy, Hp.has_fderiv_within_at (with_top.coe_le_coe.2 (nat.le_add_left 1 n)) hy, _⟩
rw has_ftaylor_series_up_to_on_succ_iff_right at Hp
assume z hz m hm
refine ⟨u, _, λ (x : E), (p x).shift, Hp.2.2.of_le hm⟩
convert self_mem_nhds_within
exact insert_eq_of_mem hz
assume h x hx
{ assume h x hx, rw times_cont_diff_within_at_succ_iff_has_fderiv_within_at, rcases h x hx with ⟨u, u_nhbd, f', hu, hf'⟩, have : x ∈ u := mem_of_mem_nhds_within (mem_insert _ _) u_nhbd, exact ⟨u, u_nhbd, f', hu, hf' x this⟩ }
rw times_cont_diff_within_at_succ_iff_has_fderiv_within_at
rcases h x hx with ⟨u, u_nhbd, f', hu, hf'⟩
have : x ∈ u := mem_of_mem_nhds_within (mem_insert _ _) u_nhbd
exact ⟨u, u_nhbd, f', hu, hf' x this⟩
intros
intros x y hx hy a b ha hb hab
rw [set.eq_of_mem_singleton hx, set.eq_of_mem_singleton hy, ←add_smul, hab, one_smul]
exact mem_singleton c
intros
intros s x hx
rw ←f.injective.mem_set_image
exact hc _ _ (by rwa set.image_image)
intros
simpa only [metric.ball, sep_univ] using (convex_on_dist a _ convex_univ).convex_lt r
intros
rw [←inner_conj_sym, abs_conj]
intros
{ rw[←inner_self_re_abs], exact inner_self_re_to_K }
rw[←inner_self_re_abs]
exact inner_self_re_to_K
intros
refine ⟨λ h, _, λ h, eq_orthogonal_projection_of_mem_of_inner_eq_zero h _⟩
rw ← h
{ rw ← h, simp }
simp
{ simp }
simp
intros
by_cases A : ∃ i ∈ s, z i = 0 ∧ w i ≠ 0
rcases A with ⟨i, his, hzi, hwi⟩
{ rcases A with ⟨i, his, hzi, hwi⟩, rw [prod_eq_zero his], { exact sum_nonneg (λ j hj, mul_nonneg (hw j hj) (hz j hj)) }, { rw hzi, exact zero_rpow hwi } }
rw [prod_eq_zero his]
{ exact sum_nonneg (λ j hj, mul_nonneg (hw j hj) (hz j hj)) }
exact sum_nonneg (λ j hj, mul_nonneg (hw j hj) (hz j hj))
{ rw hzi, exact zero_rpow hwi }
rw hzi
exact zero_rpow hwi
simp only [not_exists, not_and, ne.def, not_not] at A
{ simp only [not_exists, not_and, ne.def, not_not] at A, have := convex_on_exp.map_sum_le hw hw' (λ i _, set.mem_univ $ log (z i)), simp only [exp_sum, (∘), smul_eq_mul, mul_comm (w _) (log _)] at this, convert this using 1; [apply prod_congr rfl, apply sum_congr rfl]; intros i hi, { cases eq_or_lt_of_le (hz i hi) with hz hz, { simp [A i hi hz.symm] }, { exact rpow_def_of_pos hz _ } }, { cases eq_or_lt_of_le (hz i hi) with hz hz, { simp [A i hi hz.symm] }, { rw [exp_log hz] } } }
have := convex_on_exp.map_sum_le hw hw' (λ i _, set.mem_univ $ log (z i))
simp only [exp_sum, (∘), smul_eq_mul, mul_comm (w _) (log _)] at this
convert this using 1; [apply prod_congr rfl, apply sum_congr rfl]; intros i hi
convert this using 1; [apply prod_congr rfl, apply sum_congr rfl]
convert this using 1
apply prod_congr rfl
intros i hi
cases eq_or_lt_of_le (hz i hi) with hz hz
{ cases eq_or_lt_of_le (hz i hi) with hz hz, { simp [A i hi hz.symm] }, { exact rpow_def_of_pos hz _ } }
{ simp [A i hi hz.symm] }
simp [A i hi hz.symm]
{ exact rpow_def_of_pos hz _ }
exact rpow_def_of_pos hz _
apply sum_congr rfl
intros i hi
cases eq_or_lt_of_le (hz i hi) with hz hz
{ cases eq_or_lt_of_le (hz i hi) with hz hz, { simp [A i hi hz.symm] }, { rw [exp_log hz] } }
{ simp [A i hi hz.symm] }
simp [A i hi hz.symm]
{ rw [exp_log hz] }
rw [exp_log hz]
intros
simp [nndist_dist]
intros
rcases s with ⟨⟨l⟩, hl⟩
simpa using (l.map f).norm_prod_le
intros
simpa only [dist_add_left, dist_add_right, dist_comm h₂] using abs_dist_sub_le (g₁ + g₂) (h₁ + h₂) (h₁ + g₂)
intros
rw [mem_closed_ball', dist_eq_norm]
intros
rw show (λ e, -f e) = (λ e, (-1 : 𝕜) • f e), { funext, simp }
exact smul (-1) hf
intros
rcases hf' with ⟨cf, hcf, lif, hlif⟩
rcases hg' with ⟨cg, hcg, lig, hlig⟩
refine ⟨cg * cf, mul_ne_zero hcg hcf, lig.comp lif, funext (λ x, _)⟩
simp only [coe_comp', linear_isometry.coe_comp, hlif, hlig, pi.smul_apply, function.comp_app, linear_isometry.map_smul, smul_smul]
intros
simp only [norm_indicator_eq_indicator_norm]
exact indicator_le_indicator_of_subset ‹_› (λ _, norm_nonneg _) _
intros
{ erw f.to_add_monoid_hom.mem_ker, refl }
erw f.to_add_monoid_hom.mem_ker
refl
intros
rw ←singleton_subset_iff at h
rw [←union_eq_self_of_subset_left h]
exact balanced_zero_union_interior hA
intros
have hderiv : deriv (λ x : ℝ, x ^ (n + 1) / (n + 1)) = λ x, x ^ n
ext
{ ext, have hne : (n + 1 : ℝ) ≠ 0 := by exact_mod_cast succ_ne_zero n, simp [mul_div_assoc, mul_div_cancel' _ hne] }
have hne : (n + 1 : ℝ) ≠ 0 := by exact_mod_cast succ_ne_zero n
simp [mul_div_assoc, mul_div_cancel' _ hne]
rw integral_deriv_eq_sub' _ hderiv; norm_num [div_sub_div_same, continuous_on_pow]
rw integral_deriv_eq_sub' _ hderiv
norm_num [div_sub_div_same, continuous_on_pow]
norm_num [div_sub_div_same, continuous_on_pow]
norm_num [div_sub_div_same, continuous_on_pow]
intros
simp only [mul_comm, interval_integrable.const_mul c h]
intros
rw [← nnreal.coe_eq, coe_rpow, nnreal.coe_pow]
{ rw [← nnreal.coe_eq, coe_rpow, nnreal.coe_pow], exact real.pow_nat_rpow_nat_inv x.2 hn }
exact real.pow_nat_rpow_nat_inv x.2 hn
intros
simpa using rpow_add_int hx y (-n)
intros
obtain hx | rfl := hx.lt_or_eq
{ exact (le_rpow_iff_log_le hx hy).2 h }
exact (le_rpow_iff_log_le hx hy).2 h
exact (real.rpow_pos_of_pos hy z).le
simp [arctan_eq_arcsin]
intros
rw [← cos_neg, neg_sub, cos_sub_pi_div_two]
exact_mod_cast real.pi_pos
intros
simp only [le_antisymm_iff, arcsin_le_iff_le_sin' (mem_Ico_of_Ioo hy), le_arcsin_iff_sin_le' (mem_Ioc_of_Ioo hy)]
intros
rw [← arcsin_proj_Icc, proj_Icc_of_le_left _ hx, subtype.coe_mk, arcsin_neg_one]
intros
ext
dsimp [transfer_nat_trans_self, transfer_nat_trans]
simp only [id_comp, comp_id]
rw [←adj₃.unit_naturality_assoc, ←R₃.map_comp, g.naturality_assoc, L₂.map_comp, assoc, adj₂.counit_naturality, adj₂.left_triangle_components_assoc, assoc]
intros
rw [←id_comp (e.inverse.map _), ←map_id e.inverse, ←counit_inv_functor_comp, map_comp, ←iso.hom_inv_id_assoc (e.unit_iso.app _) (e.inverse.map (e.functor.map _)), app_hom, app_inv]
slice_lhs 2 3 { erw [e.unit.naturality] }
slice_lhs 1 2 { erw [e.unit.naturality] }
slice_lhs 4 4 { rw [←iso.hom_inv_id_assoc (e.inverse.map_iso (e.counit_iso.app _)) (e.unit_inv.app _)] }
slice_lhs 3 4 { erw [←map_comp e.inverse, e.counit.naturality], erw [(e.counit_iso.app _).hom_inv_id, map_id] }
erw [id_comp]
slice_lhs 2 3 { erw [←map_comp e.inverse, e.counit_iso.inv.naturality, map_comp] }
slice_lhs 3 4 { erw [e.unit_inv.naturality] }
slice_lhs 4 5 { erw [←map_comp (e.functor ⋙ e.inverse), (e.unit_iso.app _).hom_inv_id, map_id] }
erw [id_comp]
slice_lhs 3 4 { erw [←e.unit_inv.naturality] }
slice_lhs 2 3 { erw [←map_comp e.inverse, ←e.counit_iso.inv.naturality, (e.counit_iso.app _).hom_inv_id, map_id] }
erw [id_comp, (e.unit_iso.app _).hom_inv_id]
refl
intros
convert pullback.condition =≫ limits.prod.fst; simp
convert pullback.condition =≫ limits.prod.fst
simp
simp
intros
ext
{ ext, rw [←assoc, colimit.ι_post, ←G.map_comp, colimit.ι_desc, colimit.ι_desc], refl }
rw [←assoc, colimit.ι_post, ←G.map_comp, colimit.ι_desc, colimit.ι_desc]
refl
intros
{ ext, simp [← G.map_comp] }
ext
simp [← G.map_comp]
intros
ext _ X p
apply (assoc _ _ _).symm
intros
simp
intros
ext
simp [biproduct.ι_π, biproduct.ι_π_assoc, comp_sum, sum_comp, comp_dite, dite_comp]
intros
{ ext, simp [equalizer.iso_source_of_self], }
ext
simp [equalizer.iso_source_of_self]
intros
simp [image_mono_iso_source]
intros
{ ext, simp, }
ext
simp
intros
{ ext, simp [cokernel_iso_of_eq], }
ext
simp [cokernel_iso_of_eq]
intros
rw [←s.w (line j), parallel_family_map_left]
intros
{ simp, refl }
simp
refl
intros
{ rw [←left_unitor_tensor'], simp }
rw [←left_unitor_tensor']
simp
intros
rw [iso.inv_comp_eq, F.right_unitality, category.assoc, category.assoc, ←F.to_functor.map_comp, iso.hom_inv_id, F.to_functor.map_id, comp_id]
intros
rw [←functor.map_comp, prod_comp, category.id_comp, category.comp_id]
intros
{ induction h, simp, }
induction h
simp
intros
apply (cancel_mono P.arrow).mp
simp
intros
apply quotient.induction_on' f₂
intro f₂
refl
intros
simp [factor_thru_image_subobject, image_subobject_arrow]
intros
erw [category.id_comp, category.comp_id]
refl
intros
rw [←sdiff_le_sdiff_iff_le, sdiff_eq_empty_iff_subset.2 h]
apply empty_to_colex_le
intros
refine ⟨λ H, by rw H, λ H, _⟩
rcases c with ⟨n, c⟩
rcases c' with ⟨n', c'⟩
have : n = n'
rw [← c.blocks_sum, ← c'.blocks_sum, H]
rw [← c.blocks_sum, ← c'.blocks_sum, H]
{ rw [← c.blocks_sum, ← c'.blocks_sum, H] }
{ rw [← c.blocks_sum, ← c'.blocks_sum, H] }
induction this
simp only [true_and, eq_self_iff_true, heq_iff_eq]
ext1
exact H
intros
simp [composition_as_set.to_composition, composition.length, composition.blocks]
intros
simp [mul_apply, neighbor_finset_eq_filter, sum_filter]
intros
induction b with x b IH generalizing a d s
{ refine trans_gen.single _, simp, refl }
refine trans_gen.single _
simp
refl
refine trans_gen.head rfl _
simp
exact IH _ _ _
intros
conv {to_rhs, rw [← add_bottom_map L, list_blank.nth_map]}
conv {to_rhs, rw [← add_bottom_map L, list_blank.nth_map]}; refl
refl
intros
cases T; simp only [tape.right₀, tape.mk', list_blank.head_cons, list_blank.tail_cons, eq_self_iff_true, and_self]
cases T
simp only [tape.right₀, tape.mk', list_blank.head_cons, list_blank.tail_cons, eq_self_iff_true, and_self]
intros
simp only [free.mk, list.ret, list.mfoldl, bind_pure]
intros
ext
ext; simp [id_traverse]; refl
ext; simp [id_traverse]
simp [id_traverse]
refl
intros
simp [bits_to_nat_to_list]
unfold bits_to_nat add_lsb list.foldl cond
simp [cond_to_bool_mod_two]
intros
simpa [h] using mono.le p cb n
intros
simp [seq_eq_bind_map]
intros
ext cb n
rw [str, char_buf]
congr
{ simp [buffer.to_string, string.as_string_inv_to_list] }
simp [buffer.to_string, string.as_string_inv_to_list]
{ simp }
simp
intros
simp [fix_core]
intros
simp [bit0]
intros
rw [← of_real_int_cast, of_real_re]
intros
rw [lim_eq_lim_im_add_lim_re]; simp
rw [lim_eq_lim_im_add_lim_re]
simp
intros
simp [cos_two_mul, div_add_div_same, mul_div_cancel_left, two_ne_zero', -one_div]
intros
haveI : char_zero K := char_zero_R_or_C
rw [add_conj, mul_div_cancel_left ((re z):K) two_ne_zero']
intros
apply le_antisymm
apply supr_le _
{ apply supr_le _, intros i y hy, exact ⟨dfinsupp.single i ⟨y, hy⟩, dfinsupp.sum_add_hom_single _ _ _⟩, }
intros i y hy
exact ⟨dfinsupp.single i ⟨y, hy⟩, dfinsupp.sum_add_hom_single _ _ _⟩
rintros x ⟨v, rfl⟩
{ rintros x ⟨v, rfl⟩, exact add_submonoid.dfinsupp_sum_add_hom_mem _ v _ (λ i _, (le_supr S i : S i ≤ _) (v i).prop) }
exact add_submonoid.dfinsupp_sum_add_hom_mem _ v _ (λ i _, (le_supr S i : S i ≤ _) (v i).prop)
intros
rw [perm.subsingleton_eq_refl e, coe_refl]
intros
{ ext, simp only [comp, arrow_congr_apply, eb.symm_apply_apply] }
ext
simp only [comp, arrow_congr_apply, eb.symm_apply_apply]
intros
{ ext1 x, cases x, refl }
ext1 x
cases x
refl
intros
dunfold extend_subtype
{ dunfold extend_subtype, simp only [subtype_congr, equiv.trans_apply, equiv.sum_congr_apply], rw [sum_compl_apply_symm_of_neg _ _ hx, sum.map_inr, sum_compl_apply_inr] }
simp only [subtype_congr, equiv.trans_apply, equiv.sum_congr_apply]
rw [sum_compl_apply_symm_of_neg _ _ hx, sum.map_inr, sum_compl_apply_inr]
intros
simp only [is_image, set.ext_iff, mem_inter_eq, and.congr_right_iff, mem_preimage]
intros
cases h : e (some x) with a
rw remove_none_none _ h
{ rw remove_none_none _ h, simpa using (congr_arg e.symm h).symm }
simpa using (congr_arg e.symm h).symm
rw remove_none_some _ ⟨a, h⟩
{ rw remove_none_some _ ⟨a, h⟩, have := (congr_arg e.symm h), rw [symm_apply_apply] at this, simp only [false_iff, apply_eq_iff_eq], simp [this] }
have := (congr_arg e.symm h)
rw [symm_apply_apply] at this
simp only [false_iff, apply_eq_iff_eq]
simp [this]
intros
{ ext j, simp [init, ne_of_lt, cast_succ_lt_last] }
ext j
simp [init, ne_of_lt, cast_succ_lt_last]
intros
split
{ rintros h rfl, exact lt_irrefl _ h, }
rintros h rfl
exact lt_irrefl _ h
rintros h
{ rintros h, apply (@pos_iff_ne_zero _ _ (a : ℕ)).mpr, cases a, rintro w, apply h, simp at w, subst w, refl, }
apply (@pos_iff_ne_zero _ _ (a : ℕ)).mpr
cases a
rintro w
apply h
simp at w
subst w
refl
intros
refine ⟨λ h, _, congr_arg _⟩
rw eq_of_mem_of_not_mem_erase hx
rw ←h
simp
intros
rw [subtype_map, filter_true_of_mem h]
intros
rcases s with ⟨⟨s⟩⟩; apply list.mem_cons_iff
rcases s with ⟨⟨s⟩⟩
apply list.mem_cons_iff
intros
by_cases (a ∈ s)
rw [← insert_erase h]
{ rw [← insert_erase h], simp [← ha.assoc, hi.idempotent] }
simp [← ha.assoc, hi.idempotent]
{ apply fold_insert h }
apply fold_insert h
intros
rw [of_dual, to_dual, equiv.coe_fn_mk, equiv.coe_fn_symm_mk, id.def]
simp_rw (@image_id (order_dual α) (s : finset (order_dual α)))
refl
intros
induction s using quotient.induction_on
simp
intros
let l := s.sort (≤)
apply le_antisymm
have : s.min' H ∈ l := (finset.mem_sort (≤)).mpr (s.min'_mem H)
{ have : s.min' H ∈ l := (finset.mem_sort (≤)).mpr (s.min'_mem H), obtain ⟨i, i_lt, hi⟩ : ∃ i (hi : i < l.length), l.nth_le i hi = s.min' H := list.mem_iff_nth_le.1 this, rw ← hi, exact (s.sort_sorted (≤)).rel_nth_le_of_le _ _ (nat.zero_le i) }
obtain ⟨i, i_lt, hi⟩ : ∃ i (hi : i < l.length), l.nth_le i hi = s.min' H := list.mem_iff_nth_le.1 this
rw ← hi
exact (s.sort_sorted (≤)).rel_nth_le_of_le _ _ (nat.zero_le i)
have : l.nth_le 0 h ∈ s := (finset.mem_sort (≤)).1 (list.nth_le_mem l 0 h)
{ have : l.nth_le 0 h ∈ s := (finset.mem_sort (≤)).1 (list.nth_le_mem l 0 h), exact s.min'_le _ this }
exact s.min'_le _ this
intros
simpa [support_single_ne_zero, hb, hb'] using ne_comm
intros
simp [eq_univ_iff_forall, finset.nonempty]
intros
rw [←lt_eq_ssubset, ←finset.lt_iff_ssubset, lt_iff_le_and_ne, lt_iff_le_and_ne]
simp
intros
rw [← abs_le_iff_mul_self_le, abs_eq_nat_abs, abs_eq_nat_abs]
exact int.coe_nat_le.symm
intros
rw [int.gcd, int.gcd, nat_abs_mul, nat_abs_mul]
{ rw [int.gcd, int.gcd, nat_abs_mul, nat_abs_mul], apply nat.gcd_mul_left }
apply nat.gcd_mul_left
intros
unfold gcd_b xgcd
induction s
{ exact absurd rfl h, }
exact absurd rfl h
{ simp [xgcd_aux], }
simp [xgcd_aux]
intros
induction l with hd tl IH generalizing n
simp only [length, nonpos_iff_eq_zero] at hn
{ simp only [length, nonpos_iff_eq_zero] at hn, simp [hn] }
simp [hn]
cases n
{ cases n, { simp }, { simp only [nat.succ_le_succ_iff, length] at hn, simpa using IH _ hn } }
{ simp }
simp
simp only [nat.succ_le_succ_iff, length] at hn
{ simp only [nat.succ_le_succ_iff, length] at hn, simpa using IH _ hn }
simpa using IH _ hn
intros
cases l; cases k; simp [nat.succ_ne_zero]
cases l; cases k
{ cases l; cases k; simp [nat.succ_ne_zero] }
cases l
cases k
simp [nat.succ_ne_zero]
simp [nat.succ_ne_zero]
cases k
simp [nat.succ_ne_zero]
simp [nat.succ_ne_zero]
intros
induction l with x l ih
{ exact dvd_zero _ }
exact dvd_zero _
rw [list.sum_cons]
{ rw [list.sum_cons], exact dvd_add (h _ (mem_cons_self _ _)) (ih (λ x hx, h x (mem_cons_of_mem _ hx))) }
exact dvd_add (h _ (mem_cons_self _ _)) (ih (λ x hx, h x (mem_cons_of_mem _ hx)))
intros
induction l; [refl, simp only [*, pmap, map]]; split; refl
induction l; [refl, simp only [*, pmap, map]]; split
induction l; [refl, simp only [*, pmap, map]]
induction l
refl
simp only [*, pmap, map]
split
refl
refl
intros
simp only [countp_eq_length_filter, filter_filter]
intros
induction a generalizing c
rw nil_append
case nil { rw nil_append, split, { rintro rfl, left, exact ⟨_, rfl, rfl⟩ }, { rintro (⟨a', rfl, rfl⟩ | ⟨a', H, rfl⟩), {refl}, {rw [← append_assoc, ← H], refl} } }
split
{ rintro rfl, left, exact ⟨_, rfl, rfl⟩ }
rintro rfl
left
exact ⟨_, rfl, rfl⟩
rintro (⟨a', rfl, rfl⟩ | ⟨a', H, rfl⟩)
{ rintro (⟨a', rfl, rfl⟩ | ⟨a', H, rfl⟩), {refl}, {rw [← append_assoc, ← H], refl} }
refl
{refl}
rw [← append_assoc, ← H]
{rw [← append_assoc, ← H], refl}
refl
case cons : a as ih { cases c, { simp only [cons_append, nil_append, false_and, exists_false, false_or, exists_eq_left'], exact eq_comm }, { simp only [cons_append, @eq_comm _ a, ih, and_assoc, and_or_distrib_left, exists_and_distrib_left] } }
intros
rw [erase_eq_erasep, erasep_of_forall_not]; rintro b h' rfl; exact h h'
rw [erase_eq_erasep, erasep_of_forall_not]; rintro b h' rfl
rw [erase_eq_erasep, erasep_of_forall_not]
rintro b h' rfl
exact h h'
intros
apply list.ext_le
{ simp }
simp
intros
{ intros, rw [nth_le_pmap, nth_le_rotate, next_nth_le _ h] }
rw [nth_le_pmap, nth_le_rotate, next_nth_le _ h]
intros
induction l with y l IH
{ simp }
simp
by_cases hx : x = y
{ by_cases hx : x = y, { simp [hx, cons_sublist_cons_iff, singleton_sublist] }, { rw [duplicate_cons_iff_of_ne hx, IH], refine ⟨sublist_cons_of_sublist y, λ h, _⟩, cases h, { assumption }, { contradiction } } }
{ simp [hx, cons_sublist_cons_iff, singleton_sublist] }
simp [hx, cons_sublist_cons_iff, singleton_sublist]
rw [duplicate_cons_iff_of_ne hx, IH]
{ rw [duplicate_cons_iff_of_ne hx, IH], refine ⟨sublist_cons_of_sublist y, λ h, _⟩, cases h, { assumption }, { contradiction } }
refine ⟨sublist_cons_of_sublist y, λ h, _⟩
cases h
{ assumption }
assumption
{ contradiction }
contradiction
intros
simp [indexes_values, foldr_with_index_eq_foldr_enum, uncurry, filter_eq_foldr]
intros
simp [argmax]
intros
rw [← length_eq_zero, length_range']
intros
induction h with l₁ l₂ a s IH l₁ l₂ a s IH
{ exact or.inl rfl }
exact or.inl rfl
cases l₁ with b l₁
{ cases l₁ with b l₁, { exact or.inl rfl }, { rw [length, sublists_len_succ_cons], exact mem_append_left _ IH } }
{ exact or.inl rfl }
exact or.inl rfl
rw [length, sublists_len_succ_cons]
{ rw [length, sublists_len_succ_cons], exact mem_append_left _ IH }
exact mem_append_left _ IH
rw [length, sublists_len_succ_cons]
{ rw [length, sublists_len_succ_cons], exact mem_append_right _ (mem_map.2 ⟨_, IH, rfl⟩) }
exact mem_append_right _ (mem_map.2 ⟨_, IH, rfl⟩)
intros
{ rw ←zip_map', congr, exact map_id _ }
rw ←zip_map'
congr
exact map_id _
intros
{ ext, rw [←diagonal_one, vec_mul_diagonal, mul_one] }
ext
rw [←diagonal_one, vec_mul_diagonal, mul_one]
intros
{ ext, refl }
ext
refl
intros
rw [conj_transpose, diagonal_transpose, diagonal_map (star_zero _)]
refl
intros
ext i j; by_cases i = j; simp [h]
ext i j; by_cases i = j
ext i j
by_cases i = j
simp [h]
simp [h]
intros
simp [mul_apply, std_basis_matrix, mul_comm]
intros
ext ⟨ii, ix⟩ ⟨ji, jx⟩
simp only [transpose_apply, block_diagonal'_apply, eq_comm]
split_ifs with h₁ h₂ h₂
{ subst h₁, refl, }
subst h₁
refl
{ refl }
refl
intros
rw [rel_iff]; simp
rw [rel_iff]
simp
intros
rw [antidiagonal, coe_card, list.nat.length_antidiagonal]
intros
simp [vars, degrees_neg]
intros
simp only [bind₂, eval₂_comp_right, coe_eval₂_hom, eval₂_map]
congr' 1 with : 1
simp only [function.comp_app, map_X]
intros
intros x hx
simp only [vars, finset.mem_union, multiset.mem_to_finset] at hx ⊢
simpa using multiset.mem_of_le (degrees_add _ _) hx
intros
simp [find_eq_iff]
intros
rw [nat.succ_eq_add_one, nat.add_comm]
intros
conv { to_lhs, rw [le_rec_on, or.by_cases, dif_pos h1] }
intros
rw [mul_comm, nat.eq_mul_of_div_eq_right H1 H2]
intros
rw [← choose_mul_factorial_mul_factorial (nat.le_add_left _ _), nat.add_sub_cancel, mul_right_comm]
intros
rw [int.alternating_sum_range_choose, if_neg h0]
intros
{ simp only [← some_eq_coe] at h ⊢, refl }
simp only [← some_eq_coe] at h ⊢
refl
intros
convert to_with_top_coe n
intros
rw [mul_comm, gcd_mul_left_left]
simp
intros
cases le_or_lt b 1 with hb hb
{ rw clog_of_left_le_one hb, exact zero_le _ }
rw clog_of_left_le_one hb
exact zero_le _
obtain rfl | hn := n.eq_zero_or_pos
{ obtain rfl | hn := n.eq_zero_or_pos, { rw [clog_zero_right], exact zero_le _ }, { rw ←le_pow_iff_clog_le hb, exact h.trans (le_pow_clog hb _) } }
{ rw [clog_zero_right], exact zero_le _ }
rw [clog_zero_right]
exact zero_le _
rw ←le_pow_iff_clog_le hb
{ rw ←le_pow_iff_clog_le hb, exact h.trans (le_pow_clog hb _) }
exact h.trans (le_pow_clog hb _)
{ rw unpair, simp }
rw unpair
simp
simp [← set.compl_set_of, is_compl_compl]
intros
rw [pow_succ', ← mul_assoc, mul_lt_mul_right (zero_lt_one.trans q1)]
exact lt_mul_of_one_le_of_lt (nat.succ_le_iff.mpr a0) (nat.lt_pow_self q1 n)
intros
induction m with m IH generalizing i
simp [pow_succ, le_zero_iff] at *
{simp [pow_succ, le_zero_iff] at *}
by_cases p ∣ i
cases h with a e
{ cases h with a e, subst e, rw [pow_succ, nat.mul_dvd_mul_iff_left pp.pos, IH], split; intro h; rcases h with ⟨k, h, e⟩, { exact ⟨succ k, succ_le_succ h, by rw [e, pow_succ]; refl⟩ }, cases k with k, { apply pp.not_dvd_one.elim, simp at e, rw ← e, apply dvd_mul_right }, { refine ⟨k, le_of_succ_le_succ h, _⟩, rwa [mul_comm, pow_succ', nat.mul_left_inj pp.pos] at e } }
subst e
rw [pow_succ, nat.mul_dvd_mul_iff_left pp.pos, IH]
split; intro h; rcases h with ⟨k, h, e⟩
split; intro h
split
intro h
rcases h with ⟨k, h, e⟩
{ exact ⟨succ k, succ_le_succ h, by rw [e, pow_succ]; refl⟩ }
exact ⟨succ k, succ_le_succ h, by rw [e, pow_succ]; refl⟩
intro h
rcases h with ⟨k, h, e⟩
cases k with k
apply pp.not_dvd_one.elim
{ apply pp.not_dvd_one.elim, simp at e, rw ← e, apply dvd_mul_right }
simp at e
rw ← e
apply dvd_mul_right
refine ⟨k, le_of_succ_le_succ h, _⟩
{ refine ⟨k, le_of_succ_le_succ h, _⟩, rwa [mul_comm, pow_succ', nat.mul_left_inj pp.pos] at e }
rwa [mul_comm, pow_succ', nat.mul_left_inj pp.pos] at e
split; intro d
split
{ split; intro d, { rw (pp.coprime_pow_of_not_dvd h).eq_one_of_dvd d, exact ⟨0, zero_le _, rfl⟩ }, { rcases d with ⟨k, l, e⟩, rw e, exact pow_dvd_pow _ l } }
intro d
rw (pp.coprime_pow_of_not_dvd h).eq_one_of_dvd d
{ rw (pp.coprime_pow_of_not_dvd h).eq_one_of_dvd d, exact ⟨0, zero_le _, rfl⟩ }
exact ⟨0, zero_le _, rfl⟩
intro d
rcases d with ⟨k, l, e⟩
{ rcases d with ⟨k, l, e⟩, rw e, exact pow_dvd_pow _ l }
rw e
exact pow_dvd_pow _ l
intros
rw ← succ_mul; exact le_of_lt_succ (lt_succ_sqrt n)
rw ← succ_mul
exact le_of_lt_succ (lt_succ_sqrt n)
intros
cases n
cases n; refl
refl
refl
intros
cases x; simp only [map_none', map_some', pmap]
{ cases x; simp only [map_none', map_some', pmap] }
cases x
simp only [map_none', map_some', pmap]
simp only [map_none', map_some', pmap]
intros
simp
intros
have := H.dual.erase_max_aux; rwa [← dual_node', size_dual, ← dual_erase_min, size_dual, ← valid'.dual_iff, find_max'_dual] at this
have := H.dual.erase_max_aux
rwa [← dual_node', size_dual, ← dual_erase_min, size_dual, ← valid'.dual_iff, find_max'_dual] at this
intros
cases r with rs rl rx rr
{ refl }
refl
cases l with ls ll lx lr
{ cases l with ls ll lx lr, { have : size rl = 0 ∧ size rr = 0, { have := H1 rfl, rwa [size, sr.1, nat.succ_le_succ_iff, nat.le_zero_iff, add_eq_zero_iff] at this }, cases sr.2.1.size_eq_zero.1 this.1, cases sr.2.2.size_eq_zero.1 this.2, rw sr.eq_node', refl }, { replace H2 : ¬ rs > delta * ls := not_lt_of_le (H2 sl.pos sr.pos), simp [balance_l, balance, H2]; split_ifs; simp [add_comm] } }
have : size rl = 0 ∧ size rr = 0
{ have : size rl = 0 ∧ size rr = 0, { have := H1 rfl, rwa [size, sr.1, nat.succ_le_succ_iff, nat.le_zero_iff, add_eq_zero_iff] at this }, cases sr.2.1.size_eq_zero.1 this.1, cases sr.2.2.size_eq_zero.1 this.2, rw sr.eq_node', refl }
have := H1 rfl
{ have := H1 rfl, rwa [size, sr.1, nat.succ_le_succ_iff, nat.le_zero_iff, add_eq_zero_iff] at this }
rwa [size, sr.1, nat.succ_le_succ_iff, nat.le_zero_iff, add_eq_zero_iff] at this
cases sr.2.1.size_eq_zero.1 this.1
cases sr.2.2.size_eq_zero.1 this.2
rw sr.eq_node'
refl
replace H2 : ¬ rs > delta * ls := not_lt_of_le (H2 sl.pos sr.pos)
{ replace H2 : ¬ rs > delta * ls := not_lt_of_le (H2 sl.pos sr.pos), simp [balance_l, balance, H2]; split_ifs; simp [add_comm] }
simp [balance_l, balance, H2]; split_ifs; simp [add_comm]
simp [balance_l, balance, H2]; split_ifs
simp [balance_l, balance, H2]
split_ifs
simp [add_comm]
simp [add_comm]
intros
rcases part.eq_none_or_eq_some x with h | ⟨b, h₀⟩
{ rw h, left, apply order_bot.bot_le _ }
rw h
left
apply order_bot.bot_le _
right
intros b' h₁
rw part.eq_some_iff at h₀
replace hx := hx _ h₀
replace hy := hy _ h₁
replace hx := part.mem_unique hx hy
subst hx
exact h₀
intros
ext
ext; dsimp [pequiv.trans]; simp
ext; dsimp [pequiv.trans]
dsimp [pequiv.trans]
simp
intros
cases x with a f
rw map_eq
conv { to_rhs, rw [M.dest, M.dest', map_eq, append_fun_comp_split_fun] }
reflexivity
intros
split
rintros ⟨u, xeq, yeq⟩
{ rintros ⟨u, xeq, yeq⟩, cases h : u with a f, use [a, λ i, (f i).val.fst, λ i, (f i).val.snd], split, { rw [←xeq, h], refl }, split, { rw [←yeq, h], refl }, intro i, exact (f i).property }
cases h : u with a f
use [a, λ i, (f i).val.fst, λ i, (f i).val.snd]
split
rw [←xeq, h]
{ rw [←xeq, h], refl }
refl
split
rw [←yeq, h]
{ rw [←yeq, h], refl }
refl
intro i
exact (f i).property
rintros ⟨a, f₀, f₁, xeq, yeq, h⟩
use ⟨a, λ i, ⟨(f₀ i, f₁ i), h i⟩⟩
split
{ rw [xeq], refl }
rw [xeq]
refl
rw [yeq]
refl
intros
apply pos_iff_ne_zero.2
intro hzero
rw hzero at h
exact pnat.ne_zero n (eq_zero_of_zero_dvd h)
intros
rcases multiset.mem_map.mp h with ⟨⟨p', hp'⟩, ⟨h_mem, h_eq⟩⟩
{ rcases multiset.mem_map.mp h with ⟨⟨p', hp'⟩, ⟨h_mem, h_eq⟩⟩, exact h_eq ▸ hp' }
exact h_eq ▸ hp'
intros
{ dsimp [v], ext, { simp only, ring }, { simp only, ring } }
dsimp [v]
ext
simp only
{ simp only, ring }
ring
simp only
{ simp only, ring }
ring
intros
{ ext, simp only [eval_X, aeval_tower_X, coe_aeval_eq_eval], }
ext
simp only [eval_X, aeval_tower_X, coe_aeval_eq_eval]
intros
simp only [←monomial_zero_left, monomial_mul_monomial, zero_add]
intros
{ rw [C_mul_X_pow_eq_monomial], exact support_monomial' n c }
rw [C_mul_X_pow_eq_monomial]
exact support_monomial' n c
intros
simpa only [pow_one] using degree_C_mul_X_pow_le 1 a
intros
rw [X_pow_eq_monomial, degree_monomial _ (@one_ne_zero R _ _)]
intros
by_cases hp : p = 0
rw [hp, trailing_degree_zero]
{ rw [hp, trailing_degree_zero], exact le_top }
exact le_top
rw [trailing_degree_eq_nat_trailing_degree hp]
exact le_refl _
intros
induction k with k ih generalizing f g
{ simp [nat.iterate], }
simp [nat.iterate]
{ simp [nat.iterate, ih], }
simp [nat.iterate, ih]
intros
simp only [erase_lead, support_erase]
intros
rw [←C_eq_nat_cast, eval_C_mul]
intros
apply (degree_le_iff_coeff_zero _ _).2 (λ m hm, _)
rw degree_lt_iff_coeff_zero at hm
simp [hm m (le_refl _)]
intros
rwa [monic, leading_coeff_add_of_degree_lt hpq]
intros
intro h
rw [h, monic.def, leading_coeff_zero] at hq
rw [← mul_one p, ← C_1, ← hq, C_0, mul_zero] at hp
exact hp rfl
intros
rw [coeff_reverse, next_coeff]
split_ifs with hf
have : coeff f 1 = 0 := coeff_eq_zero_of_nat_degree_lt (by simp only [hf, zero_lt_one])
{ have : coeff f 1 = 0 := coeff_eq_zero_of_nat_degree_lt (by simp only [hf, zero_lt_one]), simp [*, rev_at] }
simp [*, rev_at]
rw rev_at_le
{ rw rev_at_le, exact nat.succ_le_iff.2 (pos_iff_ne_zero.2 hf) }
exact nat.succ_le_iff.2 (pos_iff_ne_zero.2 hf)
intros
rw [← C_1, taylor_C]
intros
rw [recF, mvpfunctor.W_rec_eq]; refl
rw [recF, mvpfunctor.W_rec_eq]
refl
intros
ext u
rw [mem_supp]
split
{ intro h', apply h' _ _ rfl }
intro h'
apply h' _ _ rfl
intros h' a' f' e
rw [←h _ _ _ _ e.symm]
apply h'
intros
{ conv_lhs { rw ←(@num_denom q) }, cases q, simp [div_num_denom] }
conv_lhs { rw ←(@num_denom q) }
cases q
simp [div_num_denom]
intros
ext r
refine rat.num_denom_cases_on' r _
intros a b b0
let φ : ℤ →+* R := f.comp (int.cast_ring_hom ℚ)
let ψ : ℤ →+* R := g.comp (int.cast_ring_hom ℚ)
rw [rat.mk_eq_div, int.cast_coe_nat]
have b0' : (b:ℚ) ≠ 0 := nat.cast_ne_zero.2 b0
have : ∀ n : ℤ, f n = g n := λ n, show φ n = ψ n, by rw [φ.ext_int ψ]
calc f (a * b⁻¹) = f a * f b⁻¹ * (g (b:ℤ) * g b⁻¹) : by rw [int.cast_coe_nat, ← g.map_mul, mul_inv_cancel b0', g.map_one, mul_one, f.map_mul] ... = g a * f b⁻¹ * (f (b:ℤ) * g b⁻¹) : by rw [this a, ← this b] ... = g (a * b⁻¹) : by rw [int.cast_coe_nat, mul_assoc, ← mul_assoc (f b⁻¹), ← f.map_mul, inv_mul_cancel b0', f.map_one, one_mul, g.map_mul]
intros
unfold has_le.le rat.le; rw add_sub_add_left_eq_sub
unfold has_le.le rat.le
rw add_sub_add_left_eq_sub
intros
simp [div_eq_mul_inv, ennreal.mul_eq_top]
intros
{ refine le_trans _ h, simp }
refine le_trans _ h
simp
intros
by_cases a0 : a = 0
{ rw [a0, zero_div, zero_div] }
rw [a0, zero_div, zero_div]
cases a with a ha
{ cases a with a ha, replace a0 : 0 < a := lt_of_le_of_ne ha (ne_of_lt (zero_lt_iff.mpr a0)), exact (div_le_div_left a0 b0 c0).mpr cb }
replace a0 : 0 < a := lt_of_le_of_ne ha (ne_of_lt (zero_lt_iff.mpr a0))
exact (div_le_div_left a0 b0 c0).mpr cb
intros
obtain hn | rfl | hp := lt_trichotomy r (0 : ℝ)
rw sign_of_neg hn
{ rw sign_of_neg hn, exact mul_nonneg_of_nonpos_of_nonpos (by norm_num) hn.le }
exact mul_nonneg_of_nonpos_of_nonpos (by norm_num) hn.le
{ rw mul_zero, }
rw mul_zero
{ rw [sign_of_pos hp, one_mul], exact hp.le }
rw [sign_of_pos hp, one_mul]
exact hp.le
intros
rw [not_iff_not, sqrt_eq_zero h]
intros
{ ext x z, simp [comp, inv, flip, and.comm] }
ext x z
simp [comp, inv, flip, and.comm]
intros
cases a with a ca; cases b with b cb; simp only [lift_rel_aux]
cases a with a ca; cases b with b cb
cases a with a ca
cases b with b cb
simp only [lift_rel_aux]
simp only [lift_rel_aux]
cases b with b cb
simp only [lift_rel_aux]
simp only [lift_rel_aux]
intros
simp [insert_eq, union_diff_self, -union_singleton, -singleton_union]
intros
rw image_eq_preimage_of_inverse h₁ h₂; refl
rw image_eq_preimage_of_inverse h₁ h₂
refl
intros
rw [image_preimage_eq_inter_range, preimage_inter_range]
intros
rw [←image_preimage_coe, ←image_preimage_coe]
split
intro h
{ intro h, rw h }
rw h
intro h
exact coe_injective.image_injective h
intros
obtain (rfl | hs) := s.eq_empty_or_nonempty
use ⟨λ _, or.inl rfl, λ _, empty_subset _⟩
simp [eq_singleton_iff_nonempty_unique_mem, hs, ne_empty_iff_nonempty.2 hs]
intros
haveI := classical.dec_eq α
rw [←to_finset_card, to_finset_ne_eq_erase, finset.card_erase_of_mem (finset.mem_univ _), finset.card_univ, nat.pred_eq_sub_one]
intros
simp [piecewise, h]
intros
rw [Icc_inter_Icc, sup_of_le_right hab, inf_of_le_left hbc, Icc_self]
intros
rw [←not_nonempty_iff_eq_empty, not_iff_not, nonempty_Ioo]
intros
rw [diff_eq, compl_Iio, inter_comm, Ici_inter_Iio]
intros
simp [le_refl]
intros
simp
intros
simp [← Ioi_inter_Iio, h]
intros
rintro (f : finite (Ioo a b))
obtain ⟨m, hm₁, hm₂⟩ : ∃ m ∈ Ioo a b, ∀ x ∈ Ioo a b, ¬x < m
{ simpa [h] using finset.exists_minimal f.to_finset }
simpa [h] using finset.exists_minimal f.to_finset
obtain ⟨z, hz₁, hz₂⟩ : ∃ z, a < z ∧ z < m := exists_between hm₁.1
exact hm₂ z ⟨hz₁, lt_trans hz₂ hm₁.2⟩ hz₂
intros
simp only [pi_def, Inter_true, mem_univ]
intros
simp only [←sUnion_range, subtype.range_coe]
intros
induction aca with a H IH
constructor
intros y h
cases h with a' _ h'
exact IH _ h'
intros
replace h₀ := congr_fun h₀; ext1 (ieq | ⟨j, ieq⟩); apply_assumption
replace h₀ := congr_fun h₀; ext1 (ieq | ⟨j, ieq⟩)
replace h₀ := congr_fun h₀
ext1 (ieq | ⟨j, ieq⟩)
apply_assumption
apply_assumption
intros
{ ext i : 1, induction i; simp [last_fun,*]; refl }
ext i : 1
induction i
induction i; simp [last_fun,*]; refl
induction i; simp [last_fun,*]
simp [last_fun,*]
refl
intros
rw [← f.map_add_int, zero_add]
intros
rcases eventually_closure_subset_of_is_open_of_omega_limit_subset f ϕ s hv₁ hv₂ with ⟨u, hu_mem, hu⟩
refine mem_of_superset hu_mem (λ t ht x hx, _)
exact hu (subset_closure $ mem_image2_of_mem ht hx)
intros
have hp : 0 < fintype.card K := lt_trans zero_lt_one fintype.one_lt_card
by_cases h : a = 0
rw h
{ rw h, apply zero_pow hp }
apply zero_pow hp
rw [← nat.succ_pred_eq_of_pos hp, pow_succ, nat.pred_eq_sub_one, pow_card_sub_one_eq_one a h, mul_one]
intros
rw [coeff_expand hp, if_pos (dvd_mul_left _ _), nat.mul_div_cancel _ hp]
intros
rw [degree_eq_nat_degree p_ne_zero, nat_degree_eq_card_roots hsplit]
intros
{ ext, simp }
ext
simp
intros
refine lt_of_le_of_ne s.circumradius_nonneg _
intro h
have hr := s.dist_circumcenter_eq_circumradius
simp_rw [←h, dist_eq_zero] at hr
have h01 := s.independent.injective.ne (dec_trivial : (0 : fin (n + 2)) ≠ 1)
simpa [hr] using h01
intros
simp_rw monge_plane_def
congr' 3
congr' 1
{ congr' 1, exact insert_singleton_comm _ _ }
exact insert_singleton_comm _ _
ext
{ ext, simp_rw submodule.mem_span_singleton, split, all_goals { rintros ⟨r, rfl⟩, use -r, rw [neg_smul, ←smul_neg, neg_vsub_eq_vsub_rev] } }
simp_rw submodule.mem_span_singleton
split
rintros ⟨r, rfl⟩
all_goals { rintros ⟨r, rfl⟩, use -r, rw [neg_smul, ←smul_neg, neg_vsub_eq_vsub_rev] }
use -r
rw [neg_smul, ←smul_neg, neg_vsub_eq_vsub_rev]
rintros ⟨r, rfl⟩
use -r
rw [neg_smul, ←smul_neg, neg_vsub_eq_vsub_rev]
intros
rw [add_assoc, real.sin_add, cos_angle_sub_add_angle_sub_rev_eq_neg_cos_angle hx hy, sin_angle_sub_add_angle_sub_rev_eq_sin_angle hx hy]
ring
intros
simp only [← finprod_subtype_eq_finprod_cond]
exact smooth_finprod (λ i, hc i i.2) (hf.comp_injective subtype.coe_injective)
intros
rw [f.support_eq_inter_preimage, ← ext_chart_at_source I]
{ rw [f.support_eq_inter_preimage, ← ext_chart_at_source I], exact inter_subset_left _ _ }
exact inter_subset_left _ _
intros
suffices h : Q (e ∘ e.symm) e.target x
have A : e.symm ⁻¹' e.source ∩ e.target = e.target
{ have A : e.symm ⁻¹' e.source ∩ e.target = e.target, by mfld_set_tac, have : e.symm x ∈ e.source, by simp only [hx] with mfld_simps, rw [lift_prop_at, hG.lift_prop_within_at_indep_chart G.id_mem_maximal_atlas (mem_univ _) he this], refine ⟨(e.symm.continuous_at hx).continuous_within_at, _⟩, simp only with mfld_simps, rwa [hG.is_local e.open_target hx, A] }
mfld_set_tac
mfld_set_tac
have : e.symm x ∈ e.source
simp only [hx] with mfld_simps
simp only [hx] with mfld_simps
rw [lift_prop_at, hG.lift_prop_within_at_indep_chart G.id_mem_maximal_atlas (mem_univ _) he this]
refine ⟨(e.symm.continuous_at hx).continuous_within_at, _⟩
simp only with mfld_simps
rwa [hG.is_local e.open_target hx, A]
have A : Q id e.target x
simpa only with mfld_simps using (hG.is_local e.open_target hx).1 (hQ x)
simpa only with mfld_simps using (hG.is_local e.open_target hx).1 (hQ x)
apply hG.congr _ _ A; simp only [hx] with mfld_simps {contextual := tt}
apply hG.congr _ _ A
simp only [hx] with mfld_simps {contextual := tt}
simp only [hx] with mfld_simps {contextual := tt}
intros
simp only [mfderiv_within, h, dif_pos]
intros
simp only [unique_mdiff_within_at] with mfld_simps
intros
assume x
rw [times_cont_mdiff_at, times_cont_mdiff_within_at_iff]
split
apply continuous.continuous_within_at
{ apply continuous.continuous_within_at, apply topological_fiber_bundle_core.continuous_const_section, assume i j y hy, exact h _ _ _ hy }
apply topological_fiber_bundle_core.continuous_const_section
assume i j y hy
exact h _ _ _ hy
have : times_cont_diff 𝕜 ⊤ (λ (y : E), (y, v)) := times_cont_diff_id.prod times_cont_diff_const
{ have : times_cont_diff 𝕜 ⊤ (λ (y : E), (y, v)) := times_cont_diff_id.prod times_cont_diff_const, apply this.times_cont_diff_within_at.congr, { assume y hy, simp only with mfld_simps at hy, simp only [chart, hy, chart_at, prod.mk.inj_iff, to_topological_fiber_bundle_core] with mfld_simps, apply h, simp only [hy] with mfld_simps }, { simp only [chart, chart_at, prod.mk.inj_iff, to_topological_fiber_bundle_core] with mfld_simps, apply h, simp only with mfld_simps } }
apply this.times_cont_diff_within_at.congr
assume y hy
{ assume y hy, simp only with mfld_simps at hy, simp only [chart, hy, chart_at, prod.mk.inj_iff, to_topological_fiber_bundle_core] with mfld_simps, apply h, simp only [hy] with mfld_simps }
simp only with mfld_simps at hy
simp only [chart, hy, chart_at, prod.mk.inj_iff, to_topological_fiber_bundle_core] with mfld_simps
apply h
simp only [hy] with mfld_simps
simp only [chart, chart_at, prod.mk.inj_iff, to_topological_fiber_bundle_core] with mfld_simps
{ simp only [chart, chart_at, prod.mk.inj_iff, to_topological_fiber_bundle_core] with mfld_simps, apply h, simp only with mfld_simps }
apply h
simp only with mfld_simps
intros
cases f; cases g; congr'; exact funext h
cases f; cases g; congr'
cases f; cases g
cases f
cases g
congr'
exact funext h
intros
rw con_gen_eq; exact Inf_le h
rw con_gen_eq
exact Inf_le h
intros
rw [add_subgroup.fg_iff_add_submonoid.fg, subgroup.fg_iff_submonoid_fg]
exact add_submonoid.fg_iff_mul_fg (add_subgroup.to_add_submonoid P)
intros
rw [← add_monoid_hom.comp_apply, to_finsupp_comp_to_free_abelian_group, add_monoid_hom.id_apply]
intros
apply closure_mono
rintros x ⟨p, hp, q, hq, rfl⟩
exact ⟨p, h₁ hp, q, h₂ hq, rfl⟩
intros
split_ifs; refl
split_ifs
refl
refl
intros
rw [cycle.length_subsingleton_iff, cycle.length_subsingleton_iff]
revert s s'
intros s s'
apply quotient.induction_on₂' s s'
intros l l'
simpa using form_perm_eq_form_perm_iff
intros
rw [←finset.card_univ, ←h2, ←order_of_is_cycle h1] at h0
cases exists_pow_eq_self_of_coprime h0 with m hm
have h2' : (σ ^ n).support = ⊤ := eq.trans (support_pow_coprime h0) h2
have h1' : is_cycle ((σ ^ n) ^ (m : ℤ)) := by rwa ← hm at h1
replace h1' : is_cycle (σ ^ n) := is_cycle_of_is_cycle_pow h1' (le_trans (support_pow_le σ n) (ge_of_eq (congr_arg support hm)))
rw [eq_top_iff, ←closure_cycle_adjacent_swap h1' h2' x, closure_le, set.insert_subset]
exact ⟨subgroup.pow_mem (closure _) (subset_closure (set.mem_insert σ _)) n, set.singleton_subset_iff.mpr (subset_closure (set.mem_insert_of_mem _ (set.mem_singleton _)))⟩
intros
classical
have : n.coprime (order_of f)
refine nat.coprime.symm _
{ refine nat.coprime.symm _, rw nat.prime.coprime_iff_not_dvd hf', exact nat.not_dvd_of_pos_of_lt hn hn' }
rw nat.prime.coprime_iff_not_dvd hf'
exact nat.not_dvd_of_pos_of_lt hn hn'
obtain ⟨m, hm⟩ := exists_pow_eq_self_of_coprime this
have hf'' := hf
rw ←hm at hf''
refine is_cycle_of_is_cycle_pow hf'' _
rw [hm]
exact support_pow_le f n
intros
rw mem_cycle_factors_finset_iff
split
rintro ⟨hc, h⟩
{ rintro ⟨hc, h⟩, contrapose! hc, rw [not_mem_support, ←cycle_of_eq_one_iff] at hc, simp [hc] }
contrapose! hc
rw [not_mem_support, ←cycle_of_eq_one_iff] at hc
simp [hc]
intros hx
{ intros hx, refine ⟨is_cycle_cycle_of _ (mem_support.mp hx), _⟩, intros y hy, rw mem_support at hy, rw cycle_of_apply, split_ifs with H, { refl }, { rw cycle_of_apply_of_not_same_cycle H at hy, contradiction } }
refine ⟨is_cycle_cycle_of _ (mem_support.mp hx), _⟩
intros y hy
rw mem_support at hy
rw cycle_of_apply
split_ifs with H
{ refl }
refl
rw cycle_of_apply_of_not_same_cycle H at hy
{ rw cycle_of_apply_of_not_same_cycle H at hy, contradiction }
contradiction
intros
simp [form_perm_apply_of_not_mem _ _ (not_mem_of_nodup_cons h)]
intros
apply perm.swap_induction_on e
{ simp [perm.one_def] }
simp [perm.one_def]
intros f x y hne h
{ intros f x y hne h, simp [h, hne, perm.mul_def, ←equiv_functor.map_equiv_trans] }
simp [h, hne, perm.mul_def, ←equiv_functor.map_equiv_trans]
intros
rw support_eq_empty_iff
intros
{ rw disjoint_comm, exact H1.symm.mul_left H2.symm }
rw disjoint_comm
exact H1.symm.mul_left H2.symm
intros
by_cases hnpos : 0 < n
haveI : fact (0 < n) := ⟨hnpos⟩
{ haveI : fact (0 < n) := ⟨hnpos⟩, cases lt_or_eq_of_le (nat.le_of_dvd hnpos (order_of_dvd_of_pow_eq_one (@r_one_pow_n n))) with h h, { have h1 : (r 1 : dihedral_group n)^(order_of (r 1)) = 1, { exact pow_order_of_eq_one _ }, rw r_one_pow at h1, injection h1 with h2, rw [← zmod.val_eq_zero, zmod.val_nat_cast, nat.mod_eq_of_lt h] at h2, apply absurd h2.symm, apply ne_of_lt, exact absurd h2.symm (ne_of_lt (order_of_pos _)) }, { exact h } }
cases lt_or_eq_of_le (nat.le_of_dvd hnpos (order_of_dvd_of_pow_eq_one (@r_one_pow_n n))) with h h
have h1 : (r 1 : dihedral_group n)^(order_of (r 1)) = 1
{ have h1 : (r 1 : dihedral_group n)^(order_of (r 1)) = 1, { exact pow_order_of_eq_one _ }, rw r_one_pow at h1, injection h1 with h2, rw [← zmod.val_eq_zero, zmod.val_nat_cast, nat.mod_eq_of_lt h] at h2, apply absurd h2.symm, apply ne_of_lt, exact absurd h2.symm (ne_of_lt (order_of_pos _)) }
{ exact pow_order_of_eq_one _ }
exact pow_order_of_eq_one _
rw r_one_pow at h1
injection h1 with h2
rw [← zmod.val_eq_zero, zmod.val_nat_cast, nat.mod_eq_of_lt h] at h2
apply absurd h2.symm
apply ne_of_lt
exact absurd h2.symm (ne_of_lt (order_of_pos _))
{ exact h }
exact h
simp only [not_lt, nonpos_iff_eq_zero] at hnpos
{ simp only [not_lt, nonpos_iff_eq_zero] at hnpos, rw hnpos, apply order_of_eq_zero, rw is_of_fin_order_iff_pow_eq_one, push_neg, intros m hm, rw [r_one_pow, one_def], by_contradiction, rw not_not at h, have h' : (m : zmod 0) = 0, { exact r.inj h, }, have h'' : m = 0, { simp only [int.coe_nat_eq_zero, int.nat_cast_eq_coe_nat] at h', exact h', }, rw h'' at hm, apply nat.lt_irrefl, exact hm }
rw hnpos
apply order_of_eq_zero
rw is_of_fin_order_iff_pow_eq_one
push_neg
intros m hm
rw [r_one_pow, one_def]
by_contradiction
have h' : (m : zmod 0) = 0
{ exact r.inj h, }
exact r.inj h
have h'' : m = 0
simp only [int.coe_nat_eq_zero, int.nat_cast_eq_coe_nat] at h'
{ simp only [int.coe_nat_eq_zero, int.nat_cast_eq_coe_nat] at h', exact h', }
exact h'
rw h'' at hm
apply nat.lt_irrefl
exact hm
intros
simpa only [div_eq_mul_inv] using H.mul_mem' hx (H.inv_mem' hy)
intros
rw [closure_singleton_eq, mem_mrange]; refl
rw [closure_singleton_eq, mem_mrange]
refl
intros
rw [←comap_bot', ←comap_bot', ←comap_bot', ←prod_map_comap_prod', bot_prod_bot]
intros
split
intro hd
{ intro hd, rw ←direction_top k V P at hd, refine ext_of_direction_eq hd _, simp [h] }
rw ←direction_top k V P at hd
refine ext_of_direction_eq hd _
simp [h]
rintro rfl
{ rintro rfl, simp }
simp
intros
simp_rw [affine_combination_apply, weighted_vsub_of_point_map]
intros
have h := collinear_iff_dim_le_one k s
rw ←finrank_eq_dim at h
exact_mod_cast h
intros
rw [one_div, line_map_inv_two]
intros
rw [← set_like.mem_coe, coe_supr_of_directed S H, mem_Union]
{ rw [← set_like.mem_coe, coe_supr_of_directed S H, mem_Union], refl }
refl
intros
apply span_induction h H; simp {contextual := tt}
apply span_induction h H
simp {contextual := tt}
simp {contextual := tt}
simp {contextual := tt}
intros
rw [mem_ker, map_sub, sub_eq_zero]
intros
ext
{ ext, simp only [symm_apply_apply, arrow_congr_apply, linear_map.comp_apply], }
simp only [symm_apply_apply, arrow_congr_apply, linear_map.comp_apply]
intros
obtain ⟨x, y, ne⟩ : ∃ (x y : M), x ≠ y := nontrivial.exists_pair_ne
obtain ⟨i, _⟩ := not_forall.mp (mt b.ext_elem ne)
exact ⟨i⟩
intros
induction x using clifford_algebra.induction
case h_grade0 : r { exact reverse.commutes _}
rw [ι_eq_zero, linear_map.zero_apply, reverse.map_zero]
case h_grade1 : x { rw [ι_eq_zero, linear_map.zero_apply, reverse.map_zero] }
case h_mul : x₁ x₂ hx₁ hx₂ { rw [reverse.map_mul, mul_comm, hx₁, hx₂] }
case h_add : x₁ x₂ hx₁ hx₂ { rw [reverse.map_add, hx₁, hx₂] }
intros
apply le_antisymm
apply supr_le _
{ apply supr_le _, intros i y hy, exact ⟨dfinsupp.single i ⟨y, hy⟩, dfinsupp.sum_add_hom_single _ _ _⟩, }
intros i y hy
exact ⟨dfinsupp.single i ⟨y, hy⟩, dfinsupp.sum_add_hom_single _ _ _⟩
rintros x ⟨v, rfl⟩
{ rintros x ⟨v, rfl⟩, exact dfinsupp_sum_add_hom_mem _ v _ (λ i _, (le_supr p i : p i ≤ _) (v i).prop) }
exact dfinsupp_sum_add_hom_mem _ v _ (λ i _, (le_supr p i : p i ≤ _) (v i).prop)
intros
intros contra
apply hμ
erw linear_map.ker_eq_bot at ⊢ contra
rw linear_map.coe_pow
exact function.injective.iterate contra k
intros
apply le_antisymm
{ exact finrank_span_le_card ({v} : set V) }
exact finrank_span_le_card ({v} : set V)
rw [nat.succ_le_iff, finrank_pos_iff]
{ rw [nat.succ_le_iff, finrank_pos_iff], use [⟨v, mem_span_singleton_self v⟩, 0], simp [hv] }
use [⟨v, mem_span_singleton_self v⟩, 0]
simp [hv]
intros
rw [finrank_eq_card_basis h, fintype.card_coe]
intros
refine le_antisymm _ (supr_le $ λ i, supported_mono $ set.subset_Union _ _)
haveI := classical.dec_pred (λ x, x ∈ (⋃ i, s i))
suffices : ((submodule.subtype _).comp (restrict_dom M R (⋃ i, s i))).range ≤ ⨆ i, supported M R (s i)
rwa [linear_map.range_comp, range_restrict_dom, map_top, range_subtype] at this
{ rwa [linear_map.range_comp, range_restrict_dom, map_top, range_subtype] at this }
rw [range_le_iff_comap, eq_top_iff]
rintro l ⟨⟩
apply finsupp.induction l
exact zero_mem _
{exact zero_mem _}
refine λ x a l hl a0, add_mem _ _
by_cases (∃ i, x ∈ s i); simp [h]
by_cases (∃ i, x ∈ s i)
simp [h]
cases h with i hi
{ cases h with i hi, exact le_supr (λ i, supported M R (s i)) i (single_mem_supported R _ hi) }
exact le_supr (λ i, supported M R (s i)) i (single_mem_supported R _ hi)
simp [h]
intros
rw [linear_independent_comp_subtype, linear_map.disjoint_ker]
intros
intros k1 k2 hk12
have h01 : ∀ (k : m ⊕ n), sum.elim (λ i, 0) (λ j, 1) k = 0 ∨ sum.elim (λ i, 0) (λ j, 1) k = 1
{ simp }
simp
have h0 : ∀ (k : m ⊕ n), sum.elim (λ i, 0) (λ j, 1) k = 0 → ∃ i, k = sum.inl i
simp
{ simp }
have h1 : ∀ (k : m ⊕ n), sum.elim (λ i, 0) (λ j, 1) k = 1 → ∃ j, k = sum.inr j
simp
{ simp }
cases (h01 k1) with hk1 hk1; cases (h01 k2) with hk2 hk2; rw [hk1, hk2] at hk12
cases (h01 k1) with hk1 hk1; cases (h01 k2) with hk2 hk2
cases (h01 k1) with hk1 hk1
cases (h01 k2) with hk2 hk2
rw [hk1, hk2] at hk12
{ exact absurd hk12 (nat.not_lt_zero 0) }
exact absurd hk12 (nat.not_lt_zero 0)
rw [hk1, hk2] at hk12
{ exact absurd hk12 (nat.not_lt_zero 1) }
exact absurd hk12 (nat.not_lt_zero 1)
cases (h01 k2) with hk2 hk2
rw [hk1, hk2] at hk12
obtain ⟨i, hi⟩ := h1 k1 hk1
{ obtain ⟨i, hi⟩ := h1 k1 hk1, obtain ⟨j, hj⟩ := h0 k2 hk2, rw [hi, hj], simp }
obtain ⟨j, hj⟩ := h0 k2 hk2
rw [hi, hj]
simp
rw [hk1, hk2] at hk12
{ exact absurd hk12 (irrefl 1) }
exact absurd hk12 (irrefl 1)
intros
rw fintype.card_eq_zero_iff at h
{ rw fintype.card_eq_zero_iff at h, suffices : M = 1, { simp [this] }, ext i, exact h.elim i }
suffices : M = 1
simp [this]
{ simp [this] }
ext i
exact h.elim i
intros
rw [@linear_equiv.finrank_eq R (matrix m n R) _ _ _ _ _ _ (linear_equiv.curry R m n).symm, finite_dimensional.finrank_fintype_fun_eq_card, fintype.card_prod]
intros
ext i j
by_cases g : i = j
rw g
{ rw g }
simp [h g, h (ne.symm g)]
intros
intros v hv
ext i
specialize hv (M.cramer (pi.single i 1))
refine (mul_eq_zero.mp _).resolve_right hM
convert hv
simp only [mul_vec_cramer M (pi.single i 1), dot_product, pi.smul_apply, smul_eq_mul]
rw [finset.sum_eq_single i, pi.single_eq_same, mul_one]
{ intros j _ hj, simp [hj] }
intros j _ hj
simp [hj]
{ intros, have := finset.mem_univ i, contradiction }
intros
have := finset.mem_univ i
contradiction
intros
rw [← linear_map.to_matrix_id v₁, matrix.to_lin_to_matrix]
intros
have : (∃ (v ≠ 0), mul_vec ((algebra_map A K).map_matrix M) v = 0) ↔ _ := exists_mul_vec_eq_zero_iff_aux
rw [← ring_hom.map_det, is_fraction_ring.to_map_eq_zero_iff] at this
refine iff.trans _ this
split
split; rintro ⟨v, hv, mul_eq⟩
rintro ⟨v, hv, mul_eq⟩
refine ⟨λ i, algebra_map _ _ (v i), mt (λ h, funext $ λ i, _) hv, _⟩
{ refine ⟨λ i, algebra_map _ _ (v i), mt (λ h, funext $ λ i, _) hv, _⟩, { exact is_fraction_ring.to_map_eq_zero_iff.mp (congr_fun h i) }, { ext i, refine (ring_hom.map_mul_vec _ _ _ i).symm.trans _, rw [mul_eq, pi.zero_apply, ring_hom.map_zero, pi.zero_apply] } }
{ exact is_fraction_ring.to_map_eq_zero_iff.mp (congr_fun h i) }
exact is_fraction_ring.to_map_eq_zero_iff.mp (congr_fun h i)
ext i
{ ext i, refine (ring_hom.map_mul_vec _ _ _ i).symm.trans _, rw [mul_eq, pi.zero_apply, ring_hom.map_zero, pi.zero_apply] }
refine (ring_hom.map_mul_vec _ _ _ i).symm.trans _
rw [mul_eq, pi.zero_apply, ring_hom.map_zero, pi.zero_apply]
rintro ⟨v, hv, mul_eq⟩
letI := classical.dec_eq K
{ letI := classical.dec_eq K, obtain ⟨⟨b, hb⟩, ba_eq⟩ := is_localization.exist_integer_multiples_of_finset (non_zero_divisors A) (finset.univ.image v), choose f hf using ba_eq, refine ⟨λ i, f _ (finset.mem_image.mpr ⟨i, finset.mem_univ i, rfl⟩), mt (λ h, funext $ λ i, _) hv, _⟩, { have := congr_arg (algebra_map A K) (congr_fun h i), rw [hf, subtype.coe_mk, pi.zero_apply, ring_hom.map_zero, algebra.smul_def, mul_eq_zero, is_fraction_ring.to_map_eq_zero_iff] at this, exact this.resolve_left (mem_non_zero_divisors_iff_ne_zero.mp hb), }, { ext i, refine is_fraction_ring.injective A K _, calc algebra_map A K (M.mul_vec (λ (i : n), f (v i) _) i) = ((algebra_map A K).map_matrix M).mul_vec (algebra_map _ K b • v) i : _ ... = 0 : _ ... = algebra_map A K 0 : (ring_hom.map_zero _).symm, { simp_rw [ring_hom.map_mul_vec, mul_vec, dot_product, function.comp_app, hf, subtype.coe_mk, ring_hom.map_matrix_apply, pi.smul_apply, smul_eq_mul, algebra.smul_def] }, { rw [mul_vec_smul, mul_eq, pi.smul_apply, pi.zero_apply, smul_zero] } } }
obtain ⟨⟨b, hb⟩, ba_eq⟩ := is_localization.exist_integer_multiples_of_finset (non_zero_divisors A) (finset.univ.image v)
choose f hf using ba_eq
refine ⟨λ i, f _ (finset.mem_image.mpr ⟨i, finset.mem_univ i, rfl⟩), mt (λ h, funext $ λ i, _) hv, _⟩
have := congr_arg (algebra_map A K) (congr_fun h i)
{ have := congr_arg (algebra_map A K) (congr_fun h i), rw [hf, subtype.coe_mk, pi.zero_apply, ring_hom.map_zero, algebra.smul_def, mul_eq_zero, is_fraction_ring.to_map_eq_zero_iff] at this, exact this.resolve_left (mem_non_zero_divisors_iff_ne_zero.mp hb), }
rw [hf, subtype.coe_mk, pi.zero_apply, ring_hom.map_zero, algebra.smul_def, mul_eq_zero, is_fraction_ring.to_map_eq_zero_iff] at this
exact this.resolve_left (mem_non_zero_divisors_iff_ne_zero.mp hb)
ext i
{ ext i, refine is_fraction_ring.injective A K _, calc algebra_map A K (M.mul_vec (λ (i : n), f (v i) _) i) = ((algebra_map A K).map_matrix M).mul_vec (algebra_map _ K b • v) i : _ ... = 0 : _ ... = algebra_map A K 0 : (ring_hom.map_zero _).symm, { simp_rw [ring_hom.map_mul_vec, mul_vec, dot_product, function.comp_app, hf, subtype.coe_mk, ring_hom.map_matrix_apply, pi.smul_apply, smul_eq_mul, algebra.smul_def] }, { rw [mul_vec_smul, mul_eq, pi.smul_apply, pi.zero_apply, smul_zero] } }
refine is_fraction_ring.injective A K _
calc algebra_map A K (M.mul_vec (λ (i : n), f (v i) _) i) = ((algebra_map A K).map_matrix M).mul_vec (algebra_map _ K b • v) i : _ ... = 0 : _ ... = algebra_map A K 0 : (ring_hom.map_zero _).symm
simp_rw [ring_hom.map_mul_vec, mul_vec, dot_product, function.comp_app, hf, subtype.coe_mk, ring_hom.map_matrix_apply, pi.smul_apply, smul_eq_mul, algebra.smul_def]
{ simp_rw [ring_hom.map_mul_vec, mul_vec, dot_product, function.comp_app, hf, subtype.coe_mk, ring_hom.map_matrix_apply, pi.smul_apply, smul_eq_mul, algebra.smul_def] }
{ rw [mul_vec_smul, mul_eq, pi.smul_apply, pi.zero_apply, smul_zero] }
rw [mul_vec_smul, mul_eq, pi.smul_apply, pi.zero_apply, smul_zero]
intros
induction k with k IH
simp only [matrix.mul_one, list.take_zero, list.prod_nil]
{ simp only [matrix.mul_one, list.take_zero, list.prod_nil], }
have hkr : k < r := hk
{ have hkr : k < r := hk, let k' : fin r := ⟨k, hkr⟩, have : (list_transvec_row M).nth k = ↑(transvection (inr unit.star) (inl k') (-M (inr unit.star) (inl k') / M (inr unit.star) (inr unit.star))), { simp only [list_transvec_row, list.of_fn_nth_val, hkr, dif_pos, list.nth_of_fn], refl }, simp only [list.take_succ, ← matrix.mul_assoc, this, list.prod_append, matrix.mul_one, matrix.mul_eq_mul, list.prod_cons, list.prod_nil, option.to_list_some], rw [mul_transvection_apply_of_ne, IH hkr.le], simp only [ne.def, not_false_iff], }
let k' : fin r := ⟨k, hkr⟩
have : (list_transvec_row M).nth k = ↑(transvection (inr unit.star) (inl k') (-M (inr unit.star) (inl k') / M (inr unit.star) (inr unit.star)))
simp only [list_transvec_row, list.of_fn_nth_val, hkr, dif_pos, list.nth_of_fn]
{ simp only [list_transvec_row, list.of_fn_nth_val, hkr, dif_pos, list.nth_of_fn], refl }
refl
simp only [list.take_succ, ← matrix.mul_assoc, this, list.prod_append, matrix.mul_one, matrix.mul_eq_mul, list.prod_cons, list.prod_nil, option.to_list_some]
rw [mul_transvection_apply_of_ne, IH hkr.le]
simp only [ne.def, not_false_iff]
intros
rw [← update_snoc_last x m (x+y), f.map_add, update_snoc_last, update_snoc_last]
intros
apply linear_equiv.to_linear_map_injective
ext1
rw [reindex_comp_tprod, linear_equiv.refl_to_linear_map, equiv.refl_symm]
refl
intros
ext
ext; simp
simp
intros
conv_rhs { rw [← (prod_equiv_of_is_compl p q h).apply_symm_apply x] }
rw [coe_prod_equiv_of_is_compl', submodule.add_mem_iff_right _ (submodule.coe_mem _), mem_left_iff_eq_zero_of_disjoint h.disjoint]
intros
rw [polar, polar, add_comm, sub_sub, sub_sub, add_comm (f x) (f y)]
intros
have hs' : ∀j : η, linear_independent R (λ i : ιs j, std_basis R Ms j (v j i))
intro j
{ intro j, exact (hs j).map' _ (ker_std_basis _ _ _) }
exact (hs j).map' _ (ker_std_basis _ _ _)
apply linear_independent_Union_finite hs'
assume j J _ hiJ
{ assume j J _ hiJ, simp [(set.Union.equations._eqn_1 _).symm, submodule.span_image, submodule.span_Union], have h₀ : ∀ j, span R (range (λ (i : ιs j), std_basis R Ms j (v j i))) ≤ range (std_basis R Ms j), { intro j, rw [span_le, linear_map.range_coe], apply range_comp_subset_range }, have h₁ : span R (range (λ (i : ιs j), std_basis R Ms j (v j i))) ≤ ⨆ i ∈ {j}, range (std_basis R Ms i), { rw @supr_singleton _ _ _ (λ i, linear_map.range (std_basis R (λ (j : η), Ms j) i)), apply h₀ }, have h₂ : (⨆ j ∈ J, span R (range (λ (i : ιs j), std_basis R Ms j (v j i)))) ≤ ⨆ j ∈ J, range (std_basis R (λ (j : η), Ms j) j) := supr_le_supr (λ i, supr_le_supr (λ H, h₀ i)), have h₃ : disjoint (λ (i : η), i ∈ {j}) J, { convert set.disjoint_singleton_left.2 hiJ using 0 }, exact (disjoint_std_basis_std_basis _ _ _ _ h₃).mono h₁ h₂ }
simp [(set.Union.equations._eqn_1 _).symm, submodule.span_image, submodule.span_Union]
have h₀ : ∀ j, span R (range (λ (i : ιs j), std_basis R Ms j (v j i))) ≤ range (std_basis R Ms j)
intro j
{ intro j, rw [span_le, linear_map.range_coe], apply range_comp_subset_range }
rw [span_le, linear_map.range_coe]
apply range_comp_subset_range
have h₁ : span R (range (λ (i : ιs j), std_basis R Ms j (v j i))) ≤ ⨆ i ∈ {j}, range (std_basis R Ms i)
rw @supr_singleton _ _ _ (λ i, linear_map.range (std_basis R (λ (j : η), Ms j) i))
{ rw @supr_singleton _ _ _ (λ i, linear_map.range (std_basis R (λ (j : η), Ms j) i)), apply h₀ }
apply h₀
have h₂ : (⨆ j ∈ J, span R (range (λ (i : ιs j), std_basis R Ms j (v j i)))) ≤ ⨆ j ∈ J, range (std_basis R (λ (j : η), Ms j) j) := supr_le_supr (λ i, supr_le_supr (λ H, h₀ i))
have h₃ : disjoint (λ (i : η), i ∈ {j}) J
{ convert set.disjoint_singleton_left.2 hiJ using 0 }
convert set.disjoint_singleton_left.2 hiJ using 0
exact (disjoint_std_basis_std_basis _ _ _ _ h₃).mono h₁ h₂
intros
simp only [ltensor, rtensor, ← map_comp, id_comp, comp_id]
intros
simp only [exists_unique_iff_exists] at h
exact h.unique ⟨hpy₁, hqy₁⟩ ⟨hpy₂, hqy₂⟩
intros
rw [@iff_def (¬ a), @iff_def' a]; exact and_congr decidable.not_imp_not decidable.not_imp_not
rw [@iff_def (¬ a), @iff_def' a]
exact and_congr decidable.not_imp_not decidable.not_imp_not
intros
cases (pi univ s).eq_empty_or_nonempty with h h
{ cases (pi univ s).eq_empty_or_nonempty with h h, simp [h], exact (bounded_by_le _).trans_eq (pi_premeasure_pi h) }
simp [h]
exact (bounded_by_le _).trans_eq (pi_premeasure_pi h)
intros
apply measurable_of_measurable_coe
intros s hs
simp_rw [map_apply measurable_prod_mk_left hs]
exact measurable_measure_prod_mk_left hs
intros
filter_upwards [ae_ae_of_ae_prod hf.ae_eq_mk]
intros x hx
exact ⟨λ y, hf.mk f (x, y), hf.measurable_mk.comp measurable_prod_mk_left, hx⟩
intros
rw [← s.neg_le_neg_iff _ hu, neg_zero] at hsu
rw [← s.neg_le_neg_iff _ hv, neg_zero] at hsv
have := of_diff_eq_zero_of_symm_diff_eq_zero_positive hu hv hsu hsv
simp only [pi.neg_apply, neg_eq_zero, coe_neg] at this
exact this hs
intros
rw [← lift_rel_mk_mk, mk_coe_fn, mk_coe_fn]
intros
simp_rw [condexp_ind_smul]
{ simp_rw [condexp_ind_smul], rw [to_span_singleton_smul, smul_comp_LpL, smul_apply], }
rw [to_span_singleton_smul, smul_comp_LpL, smul_apply]
intros
simp only [has_finite_integral, of_real_norm_eq_coe_nnnorm]
intros
refine ⟨hf.ae_measurable.real_to_nnreal.coe_nnreal_real, _⟩
rw has_finite_integral_iff_norm
refine lt_of_le_of_lt _ ((has_finite_integral_iff_norm _).1 hf.has_finite_integral)
apply lintegral_mono
assume x
simp [real.norm_eq_abs, ennreal.of_real_le_of_real, abs_le, abs_nonneg, le_abs_self]
intros
apply (integrable_zero _ _ _).congr
change (0 : measure α) {x | 0 ≠ f x} = 0
refl
intros
simp_rw [dist, norm_def]
congr' 1
apply snorm_congr_ae (coe_fn_sub _ _)
intros
rw [Lp.norm_def, snorm_congr_ae indicator_const_Lp_coe_fn, snorm_indicator_const' hs hμs_ne_zero ennreal.top_ne_zero, ennreal.top_to_real, div_zero, ennreal.rpow_zero, mul_one, ennreal.coe_to_real, coe_nnnorm]
intros
convert Lp.tendsto_Lp_iff_tendsto_ℒp' _ _
ext1 n
apply snorm_congr_ae
filter_upwards [((f_ℒp n).sub f_lim_ℒp).coe_fn_to_Lp, Lp.coe_fn_sub ((f_ℒp n).to_Lp (f n)) (f_lim_ℒp.to_Lp f_lim)]
intros x hx₁ hx₂
rw ← hx₂
exact hx₁.symm
intros
rw ← snorm_const_lt_top_iff hp_ne_zero hp_ne_top
exact ⟨λ h, h.2, λ h, ⟨ae_measurable_const, h⟩⟩
intros
apply hs.induction_on
{ simp }
simp
intros a s ha hs hf
{ intros a s ha hs hf, simp [hf, or_imp_distrib, forall_and_distrib] }
simp [hf, or_imp_distrib, forall_and_distrib]
intros
rw [← integral_add_adjacent_intervals hac hcd, add_assoc, add_left_comm, integral_add_adjacent_intervals hac (hac.symm.trans hab), add_comm]
intros
refine le_trans le_top (le_of_eq _)
have hp0_inv_lt : 0 < 1/p
simp [hp0_lt]
simp [hp0_lt]
rw [hf_top, ennreal.top_rpow_of_pos hp0_inv_lt]
simp [hq0, hg_nonzero]
intros
rw ← measure.restrict_apply_univ at *
haveI : is_finite_measure (μ.restrict s) := ⟨‹_›⟩
exact norm_integral_le_of_norm_le_const hC
intros
{ cases i, exacts [h₂, h₁] }
cases i
exacts [h₂, h₁]
intros
simp [apply_eq_coe_to_fun, μ.mono' _ _ h]
intros
simp only [index, nat.Inf_eq_zero]
left
use ∅
simp only [finset.card_empty, empty_subset, mem_set_of_eq, eq_self_iff_true, and_self]
intros
convert mk_metric_mono_smul ennreal.one_ne_top ennreal.zero_lt_one.ne' _
convert mk_metric_mono_smul ennreal.one_ne_top ennreal.zero_lt_one.ne' _; simp *
{ convert mk_metric_mono_smul ennreal.one_ne_top ennreal.zero_lt_one.ne' _; simp * }
simp *
simp *
intros
simp only [volume_pi_Ioc, ennreal.to_real_prod, ennreal.to_real_of_real (sub_nonneg.2 (h _))]
intros
rw [infi, Inf_apply (range_nonempty m)]
{ rw [infi, Inf_apply (range_nonempty m)], simp only [infi_range] }
simp only [infi_range]
intros
ext1 s hs
{ ext1 s hs, erw [with_densityᵥ_apply (integrable_zero α E μ) hs], simp, }
erw [with_densityᵥ_apply (integrable_zero α E μ) hs]
simp
intros
simp [map]
intros
{ rw [ppow, dif_neg (ne_of_gt kpos)], refl }
rw [ppow, dif_neg (ne_of_gt kpos)]
refl
intros
apply nat.eq_prime_pow_of_dvd_least_prime_pow
{ norm_num, }
norm_num
intro o
{ intro o, have ω_pow := order_of_dvd_iff_pow_eq_one.1 o, replace ω_pow := congr_arg (units.coe_hom (X (q (p'+2))) : units (X (q (p'+2))) → X (q (p'+2))) ω_pow, simp at ω_pow, have h : (1 : zmod (q (p'+2))) = -1 := congr_arg (prod.fst) ((ω_pow.symm).trans (ω_pow_eq_neg_one p' h)), haveI : fact (2 < (q (p'+2) : ℕ)) := ⟨two_lt_q _⟩, apply zmod.neg_one_ne_one h.symm, }
have ω_pow := order_of_dvd_iff_pow_eq_one.1 o
replace ω_pow := congr_arg (units.coe_hom (X (q (p'+2))) : units (X (q (p'+2))) → X (q (p'+2))) ω_pow
simp at ω_pow
have h : (1 : zmod (q (p'+2))) = -1 := congr_arg (prod.fst) ((ω_pow.symm).trans (ω_pow_eq_neg_one p' h))
haveI : fact (2 < (q (p'+2) : ℕ)) := ⟨two_lt_q _⟩
apply zmod.neg_one_ne_one h.symm
apply order_of_dvd_iff_pow_eq_one.2
{ apply order_of_dvd_iff_pow_eq_one.2, apply units.ext, push_cast, exact ω_pow_eq_one p' h, }
apply units.ext
push_cast
exact ω_pow_eq_one p' h
intros
rw [mul_comm, mul_inv hz]
intros
simp [padic_val_nat]
intros
apply zmod.ring_hom_eq_of_ker_eq
ext x
rw [ring_hom.mem_ker, ring_hom.mem_ker]
simp only [function.comp_app, zmod.cast_hom_apply, ring_hom.coe_comp]
simp only [to_zmod_pow, to_zmod_hom, ring_hom.coe_mk]
rw [zmod.cast_nat_cast (pow_dvd_pow p h), zmod_congr_of_sub_mem_span m (x.appr n) (x.appr n) (x.appr m)]
{ rw [sub_self], apply ideal.zero_mem _, }
rw [sub_self]
apply ideal.zero_mem _
rw ideal.mem_span_singleton
{ rw ideal.mem_span_singleton, rcases dvd_appr_sub_appr x m n h with ⟨c, hc⟩, use c, rw [← nat.cast_sub (appr_mono _ h), hc, nat.cast_mul, nat.cast_pow], }
rcases dvd_appr_sub_appr x m n h with ⟨c, hc⟩
use c
rw [← nat.cast_sub (appr_mono _ h), hc, nat.cast_mul, nat.cast_pow]
{ apply_instance }
apply_instance
simp only [pythagorean_triple, zero_mul, zero_add]
intros
simp [to_complex_def]
intros
rw [←is_atomic_dual_iff_is_coatomic, ←is_atomic_dual_iff_is_coatomic]
{ rw [←is_atomic_dual_iff_is_coatomic, ←is_atomic_dual_iff_is_coatomic], exact f.dual.is_atomic_iff }
exact f.dual.is_atomic_iff
intros
rw [sup_sdiff_self_right, sup_sdiff_self_right, sup_comm]
intros
rw [sdiff_sdiff_right_self, inf_of_le_right h]
intros
simp [disjoint_iff]
intros
exact is_lub_singleton.union hs
intros
rcases is_compactly_generated.exists_Sup_eq b with ⟨s, hs, rfl⟩
exact le_antisymm (Sup_le (λ c hc, hc.2)) (Sup_le_Sup (λ c cs, ⟨hs c cs, le_Sup cs⟩))
intros
have hf : monotone (λ n, ⨅ i ≥ n, f i)
from λ n m hnm, le_infi (λ i, (infi_le _ i).trans (le_infi (λ h, infi_le _ (hnm.trans h))))
rw ←monotone.supr_nat_add hf k
{ simp_rw [infi_ge_eq_infi_nat_add, ←nat.add_assoc], }
simp_rw [infi_ge_eq_infi_nat_add, ←nat.add_assoc]
intros
{ symmetry, exact supr_and }
symmetry
exact supr_and
intros
{ convert supr_unique, apply_instance }
convert supr_unique
apply_instance
intros
simp [directed, directed_on]; refine ball_congr (λ x hx, by simp; refl)
simp [directed, directed_on]
intros
simpa only [mul_comm] using hf.neg_const_mul_at_bot hr
intros
rw [← (filter_basis.of_sets s).generate, generate_eq_generate_inter s]
rw [← (filter_basis.of_sets s).generate, generate_eq_generate_inter s] ; refl
refl
intros
simpa only [tendsto, hlb.ge_iff, mem_map, filter.eventually]
intros
simp [filter.frequently]
intros
simpa using bInter_mem finite_univ
intros
simp only [mem_seq_def, seq_subset, exists_prop, iff_self]
intros
cases ha with i ha
replace ha := ha.symm
cases hb with j hb
replace hb := hb.symm
wlog h : i ≤ j := le_total i j using [a b i j, b a j i]
rw [eq_some_iff] at ha hb
have := c.monotone h _ ha
apply mem_unique this hb
intros
refine (f.to_order_embedding.map_inf_le x y).antisymm _
simpa [← f.symm.le_iff_le] using f.symm.to_order_embedding.map_inf_le (f x) (f y)
intros
rw [symm_diff_comm, symm_diff_bot]
intros
change indep_sets ((λ x, (m x).measurable_set') i) ((λ x, (m x).measurable_set') j) μ
exact Indep_sets.indep_sets h_indep hij
intros
rw [is_root, eval_map, eval₂_root]
intros
delta algebra.is_algebraic subalgebra.is_algebraic
simp only [algebra.mem_top, forall_prop_of_true, iff_self]
intros
rw [is_coprime_comm, is_coprime.mul_left_iff, is_coprime_comm, @is_coprime_comm _ _ z]
intros
refine le_trans _ (is_integral_closure.range_le_span_dual_basis (integral_closure A L) b hb_int)
intros x hx
exact ⟨⟨x, hx⟩, rfl⟩
intros
have gen_ne_zero : generator s ≠ 0
rw [ne.def, ← eq_bot_iff_generator_eq_zero]
{ rw [ne.def, ← eq_bot_iff_generator_eq_zero], assumption }
assumption
rcases associated_pow_irreducible gen_ne_zero hirr with ⟨n, u, hnu⟩
use n
have : span _ = _ := span_singleton_generator s
rw [← this, ← hnu, span_singleton_eq_span_singleton]
use u
intros
cases subsingleton_or_nontrivial R with h h
cases subsingleton_or_nontrivial R with h h; haveI := h
haveI := h
rw [subsingleton.elim (1 : hahn_series Γ R) 0, order_zero]
{ rw [subsingleton.elim (1 : hahn_series Γ R) 0, order_zero] }
haveI := h
{ exact order_single one_ne_zero }
exact order_single one_ne_zero
intros
rw pi_eq_sum_univ x
simp only [finset.sum_apply, smul_eq_mul, linear_map.map_sum, pi.smul_apply, linear_map.map_smul]
exact I.sum_mem (λ j hj, I.mul_mem_right _ (hi j))
intros
rw [mul_comm, annihilator_mul]
intros
refine eq_bot_iff.2 (λ x hx, _)
by_cases hx0 : x = 0
{ exact hx0.symm ▸ ideal.zero_mem ⊥ }
exact hx0.symm ▸ ideal.zero_mem ⊥
exact absurd hI (comap_ne_bot_of_integral_mem hx0 hx (hRS x))
{ exact absurd hI (comap_ne_bot_of_integral_mem hx0 hx (hRS x)) }
intros
simpa only [sub_eq_add_neg] using f.is_integral_add hx (f.is_integral_neg hy)
intros
refine eq_bot_iff.2 (le_trans jacobson_bot_polynomial_le_Inf_map_maximal _)
refine (λ f hf, ((submodule.mem_bot _).2 (polynomial.ext (λ n, trans _ (coeff_zero n).symm))))
suffices : f.coeff n ∈ ideal.jacobson ⊥
rwa [h, submodule.mem_bot] at this
rwa [h, submodule.mem_bot] at this
exact mem_Inf.2 (λ j hj, (mem_map_C_iff.1 ((mem_Inf.1 hf) ⟨j, ⟨hj.2, rfl⟩⟩)) n)
intros
rw [is_noetherian_iff_well_founded, well_founded.well_founded_iff_has_max']
intros
simp [frange, finset.image_subset_iff]
simp only [← C_1, coeff_C]
assume n hn
simp only [exists_prop, ite_eq_right_iff, not_forall] at hn
simp [hn]
intros
rcases hdvd with ⟨r, rfl⟩
rw [is_primitive_iff_content_eq_one, ← normalize_content, normalize_eq_one, is_unit_iff_dvd_one]
apply dvd.intro r.content
rwa [is_primitive_iff_content_eq_one, content_mul] at hp
intros
simp [pochhammer_eval_zero, h]
intros
rw [coeff, monomial_def, linear_map.proj_apply, linear_map.std_basis_apply, function.update_apply, pi.zero_apply]
intros
rw [← monomial_zero_eq_C_apply, coeff_monomial]
intros
simp_rw is_simple_module_iff_is_atom
exact Sup_atoms_eq_top
intros
{ classical, apply dif_neg, apply (mt mk_eq_zero.1 h) }
classical
apply dif_neg
apply (mt mk_eq_zero.1 h)
intros
{ rw supp_quot, exact ideal.map_quotient_self _ }
rw supp_quot
exact ideal.map_quotient_self _
intros
apply mv_polynomial.map_injective (int.cast_ring_hom ℚ) int.cast_injective
simp only [witt_add, witt_structure_rat, alg_hom.map_add, ring_hom.map_add, rename_X, X_in_terms_of_W_zero, map_X, witt_polynomial_zero, bind₁_X_right, map_witt_structure_int]
intros
induction i with i h
{ simp only [one_coeff_zero, ne.def, pow_zero] }
simp only [one_coeff_zero, ne.def, pow_zero]
rw [pow_succ', ← frobenius_verschiebung, coeff_frobenius_char_p, verschiebung_coeff_succ, h, one_pow]
{ rw [pow_succ', ← frobenius_verschiebung, coeff_frobenius_char_p, verschiebung_coeff_succ, h, one_pow], }
intros
witt_truncate_fun_tac
intros
rw [X_in_terms_of_W_eq, range_zero, sum_empty, pow_zero, C_1, mul_one, sub_zero]
intros
simp [le_antisymm_iff]
intros
split
intro h
{ intro h, by_cases ha : a = 0, { left, exact ha }, right, by_cases hb : b = 0, { left, exact hb }, right, rw [← ne, ← one_le_iff_ne_zero] at ha hb, split, { rw [← mul_one a], refine lt_of_le_of_lt (mul_le_mul' (le_refl a) hb) h }, { rw [← _root_.one_mul b], refine lt_of_le_of_lt (mul_le_mul' ha (le_refl b)) h }}
by_cases ha : a = 0
left
{ left, exact ha }
exact ha
right
by_cases hb : b = 0
left
{ left, exact hb }
exact hb
right
rw [← ne, ← one_le_iff_ne_zero] at ha hb
split
rw [← mul_one a]
{ rw [← mul_one a], refine lt_of_le_of_lt (mul_le_mul' (le_refl a) hb) h }
refine lt_of_le_of_lt (mul_le_mul' (le_refl a) hb) h
rw [← _root_.one_mul b]
{ rw [← _root_.one_mul b], refine lt_of_le_of_lt (mul_le_mul' ha (le_refl b)) h }
refine lt_of_le_of_lt (mul_le_mul' ha (le_refl b)) h
rintro (rfl|rfl|⟨ha,hb⟩); simp only [*, mul_lt_omega, omega_pos, _root_.zero_mul, mul_zero]
rintro (rfl|rfl|⟨ha,hb⟩)
simp only [*, mul_lt_omega, omega_pos, _root_.zero_mul, mul_zero]
simp only [*, mul_lt_omega, omega_pos, _root_.zero_mul, mul_zero]
simp only [*, mul_lt_omega, omega_pos, _root_.zero_mul, mul_zero]
intros
simp only [quotient.eq] at hl hr
apply quotient.sound
apply equiv_of_mk_equiv L R hl hr
intros
rw subsingleton.elim f g
intros
rw [← cardinal.ord_omega, cardinal.lt_ord, lt_omega]
rw [← cardinal.ord_omega, cardinal.lt_ord, lt_omega]; simp only [card_eq_nat]
simp only [card_eq_nat]
intros
cases n; simp
cases n
simp
simp
intros
simp
intros
simp [term, zero_nsmul, one_nsmul]
intros
have ha' := normalize_fin_lt.mk rfl ha (h.trans hb.lt)
have ha' := normalize_fin_lt.mk rfl ha (h.trans hb.lt); rwa [← hb.coe, ← ha'.coe] at h
rwa [← hb.coe, ← ha'.coe] at h
intros
rw [prl, prr, prt]
intros
cc
intros
simp [ha, tsum]; exact some_spec ha
simp [ha, tsum]
exact some_spec ha
intros
apply_instance
intros
rw [← compl_Ioi, interior_compl, closure_Ioi, compl_Ici]
intros
simp only [continuous_within_at, continuous_at, ← tendsto_sup, nhds_left_sup_nhds_right]
intros
rw continuous_iff_coinduced_le
refine le_Inf _
rintros _ ⟨t', ht', rfl⟩
exact ht'
intros
refine ⟨λ t₁ ht₁ t₂ ht₂ x hx, h_nhds _ _ hx (is_open.inter (h_open _ ht₁) (h_open _ ht₂)), _, _⟩
{ refine sUnion_eq_univ_iff.2 (λ a, _), rcases h_nhds a univ trivial is_open_univ with ⟨u, h₁, h₂, -⟩, exact ⟨u, h₁, h₂⟩ }
refine sUnion_eq_univ_iff.2 (λ a, _)
rcases h_nhds a univ trivial is_open_univ with ⟨u, h₁, h₂, -⟩
exact ⟨u, h₁, h₂⟩
refine (le_generate_from h_open).antisymm (λ u hu, _)
{ refine (le_generate_from h_open).antisymm (λ u hu, _), refine (@is_open_iff_nhds α (generate_from s) u).mpr (λ a ha, _), rcases h_nhds a u ha hu with ⟨v, hvs, hav, hvu⟩, rw nhds_generate_from, exact binfi_le_of_le v ⟨hav, hvs⟩ (le_principal_iff.2 hvu) }
refine (@is_open_iff_nhds α (generate_from s) u).mpr (λ a ha, _)
rcases h_nhds a u ha hu with ⟨v, hvs, hav, hvu⟩
rw nhds_generate_from
exact binfi_le_of_le v ⟨hav, hvs⟩ (le_principal_iff.2 hvu)
intros
simp [closure_eq_compl_interior_compl]
intros
simp_rw [map_cluster_pt, cluster_pt, inf_ne_bot_iff_frequently_left, frequently_map]
{ simp_rw [map_cluster_pt, cluster_pt, inf_ne_bot_iff_frequently_left, frequently_map], refl }
refl
intros
change (X.a ≫ f.f) _ = _
rw ←f.h
refl
intros
split
intro h
{ intro h, haveI : limits.preserves_limits Profinite_to_CompHaus := infer_instance, haveI : mono (Profinite_to_CompHaus.map f) := infer_instance, rwa ← CompHaus.mono_iff_injective }
haveI : limits.preserves_limits Profinite_to_CompHaus := infer_instance
haveI : mono (Profinite_to_CompHaus.map f) := infer_instance
rwa ← CompHaus.mono_iff_injective
rw ← category_theory.mono_iff_injective
{ rw ← category_theory.mono_iff_injective, apply faithful_reflects_mono (forget Profinite) }
apply faithful_reflects_mono (forget Profinite)
intros
simp
intros
apply is_preconnected_of_forall x
rintros y ⟨s, sc, ys⟩
exact ⟨s, subset_sUnion_of_mem sc, H1 s sc, ys, H2 s sc⟩
intros
rw [is_open_map_iff_nhds_le]
rintros ⟨a, b⟩
rw [nhds_prod_eq, nhds_prod_eq, ← filter.prod_map_map_eq]
exact filter.prod_mono (is_open_map_iff_nhds_le.1 hf a) (is_open_map_iff_nhds_le.1 hg b)
intros
rw [nhds_within, principal_empty, inf_bot_eq]
intros
apply continuous_on.if'
rintros a ha
{ rintros a ha, simp only [← hp a ha, if_t_t], apply tendsto_nhds_within_mono_left (inter_subset_inter_right s subset_closure), exact hf a ⟨ha.1, ha.2.1⟩ }
simp only [← hp a ha, if_t_t]
apply tendsto_nhds_within_mono_left (inter_subset_inter_right s subset_closure)
exact hf a ⟨ha.1, ha.2.1⟩
rintros a ha
{ rintros a ha, simp only [hp a ha, if_t_t], apply tendsto_nhds_within_mono_left (inter_subset_inter_right s subset_closure), rcases ha with ⟨has, ⟨_, ha⟩⟩, rw [← mem_compl_iff, ← closure_compl] at ha, apply hg a ⟨has, ha⟩ }
simp only [hp a ha, if_t_t]
apply tendsto_nhds_within_mono_left (inter_subset_inter_right s subset_closure)
rcases ha with ⟨has, ⟨_, ha⟩⟩
rw [← mem_compl_iff, ← closure_compl] at ha
apply hg a ⟨has, ha⟩
exact hf.mono (inter_subset_inter_right s subset_closure)
{ exact hf.mono (inter_subset_inter_right s subset_closure) }
exact hg.mono (inter_subset_inter_right s subset_closure)
{ exact hg.mono (inter_subset_inter_right s subset_closure) }
intros
simp only [has_sum, coe_sum.symm, tendsto_coe]
intros
rw [e.map_nhds_within_eq hx, h.image_eq, e.nhds_within_target_inter (e.map_source hx)]
intros
{ rw ← image_univ, exact hf _ is_open_univ }
rw ← image_univ
exact hf _ is_open_univ
intros
simp [hf.1]
intros
have : (⨅ q, dist (Φ p) (Φ q) + dist (Ψ p) (Ψ q)) = 0
have A : ∀ q, 0 ≤ dist (Φ p) (Φ q) + dist (Ψ p) (Ψ q) := λq, by rw ← add_zero (0 : ℝ); exact add_le_add dist_nonneg dist_nonneg
{ have A : ∀ q, 0 ≤ dist (Φ p) (Φ q) + dist (Ψ p) (Ψ q) := λq, by rw ← add_zero (0 : ℝ); exact add_le_add dist_nonneg dist_nonneg, refine le_antisymm _ (le_cinfi A), have : 0 = dist (Φ p) (Φ p) + dist (Ψ p) (Ψ p), by simp, rw this, exact cinfi_le ⟨0, forall_range_iff.2 A⟩ p }
refine le_antisymm _ (le_cinfi A)
have : 0 = dist (Φ p) (Φ p) + dist (Ψ p) (Ψ p)
simp
simp
rw this
exact cinfi_le ⟨0, forall_range_iff.2 A⟩ p
rw [glue_dist, this, zero_add]
rw [dimH_univ_eq_finrank ℝ, finite_dimensional.finrank_self, nat.cast_one]
intros
rintro a (rfl : a = x) b (rfl : b = a)
{ rintro a (rfl : a = x) b (rfl : b = a), rw edist_self, exact zero_le _ }
rw edist_self
exact zero_le _
intros
have := paracompact_space.locally_finite_refinement (range u) coe (set_coe.forall.2 $ forall_range_iff.2 uo) (by rwa [← sUnion_range, subtype.range_coe])
simp only [set_coe.exists, subtype.coe_mk, exists_range_iff', Union_eq_univ_iff, exists_prop] at this
choose α t hto hXt htf ind hind
choose t_inv ht_inv using hXt
choose U hxU hU using htf
refine ⟨λ i, ⋃ (a : α) (ha : ind a = i), t a, _, _, _, _⟩
exact λ a, is_open_Union (λ a, is_open_Union $ λ ha, hto a)
{ exact λ a, is_open_Union (λ a, is_open_Union $ λ ha, hto a) }
simp only [eq_univ_iff_forall, mem_Union]
{ simp only [eq_univ_iff_forall, mem_Union], exact λ x, ⟨ind (t_inv x), _, rfl, ht_inv _⟩ }
exact λ x, ⟨ind (t_inv x), _, rfl, ht_inv _⟩
refine λ x, ⟨U x, hxU x, ((hU x).image ind).subset _⟩
{ refine λ x, ⟨U x, hxU x, ((hU x).image ind).subset _⟩, simp only [subset_def, mem_Union, mem_set_of_eq, set.nonempty, mem_inter_eq], rintro i ⟨y, ⟨a, rfl, hya⟩, hyU⟩, exact mem_image_of_mem _ ⟨y, hya, hyU⟩ }
simp only [subset_def, mem_Union, mem_set_of_eq, set.nonempty, mem_inter_eq]
rintro i ⟨y, ⟨a, rfl, hya⟩, hyU⟩
exact mem_image_of_mem _ ⟨y, hya, hyU⟩
simp only [subset_def, mem_Union]
{ simp only [subset_def, mem_Union], rintro i x ⟨a, rfl, hxa⟩, exact hind _ hxa }
rintro i x ⟨a, rfl, hxa⟩
exact hind _ hxa
intros
assume y hy
rcases lt_supr_iff.1 hy with ⟨i, hi⟩
filter_upwards [h i y hi]
assume x' hx'
exact lt_supr_iff.2 ⟨i, hx'⟩
intros
apply stalk_to_fiber_injective
intros
rcases hU ⟨x, U.2⟩ with ⟨U', mU, iU, gU, wU⟩
rcases hV ⟨x, V.2⟩ with ⟨V', mV, iV, gV, wV⟩
have wUx := wU ⟨x, mU⟩
dsimp at wUx
erw wUx at e
clear wUx
have wVx := wV ⟨x, mV⟩
dsimp at wVx
erw wVx at e
clear wVx
rcases F.germ_eq x mU mV gU gV e with ⟨W, mW, iU', iV', e'⟩
dsimp at e'
use ⟨W ⊓ (U' ⊓ V'), ⟨mW, mU, mV⟩⟩
refine ⟨_, _, _⟩
change W ⊓ (U' ⊓ V') ⟶ U.val
{ change W ⊓ (U' ⊓ V') ⟶ U.val, exact (opens.inf_le_right _ _) ≫ (opens.inf_le_left _ _) ≫ iU, }
exact (opens.inf_le_right _ _) ≫ (opens.inf_le_left _ _) ≫ iU
change W ⊓ (U' ⊓ V') ⟶ V.val
{ change W ⊓ (U' ⊓ V') ⟶ V.val, exact (opens.inf_le_right _ _) ≫ (opens.inf_le_right _ _) ≫ iV, }
exact (opens.inf_le_right _ _) ≫ (opens.inf_le_right _ _) ≫ iV
intro w
{ intro w, dsimp, specialize wU ⟨w.1, w.2.2.1⟩, dsimp at wU, specialize wV ⟨w.1, w.2.2.2⟩, dsimp at wV, erw [wU, ←F.germ_res iU' ⟨w, w.2.1⟩, wV, ←F.germ_res iV' ⟨w, w.2.1⟩, category_theory.types_comp_apply, category_theory.types_comp_apply, e'] }
dsimp
specialize wU ⟨w.1, w.2.2.1⟩
dsimp at wU
specialize wV ⟨w.1, w.2.2.2⟩
dsimp at wV
erw [wU, ←F.germ_res iU' ⟨w, w.2.1⟩, wV, ←F.germ_res iV' ⟨w, w.2.1⟩, category_theory.types_comp_apply, category_theory.types_comp_apply, e']
intros
rw [uniformity_prod]; exact inter_mem_inf (preimage_mem_comap ha) (preimage_mem_comap hb)
rw [uniformity_prod]
exact inter_mem_inf (preimage_mem_comap ha) (preimage_mem_comap hb)
intros
rw ← tendsto_locally_uniformly_on_univ at h ⊢
rw continuous_iff_continuous_on_univ at cg
exact h.comp _ (maps_to_univ _ _) cg
intros
cases a; cases b; exact dec_trivial
cases a; cases b
cases a
cases b
exact dec_trivial
exact dec_trivial
cases b
exact dec_trivial
exact dec_trivial
intros
rw int.mul_comm
simp [neg_succ_of_nat_mul_neg_of_nat, nat.mul_comm]
intros
have h := int.add_le_add_right h c
rwa int.sub_add_cancel at h
intros
simp [gcd]
intros
have npos : 0 < n := n.eq_zero_or_pos.resolve_left (λ n0, by rw [n0, nat.zero_mul] at h₁; exact nat.not_lt_zero _ h₁)
apply nat.div_eq_of_lt_le
rw [nat.mul_sub_right_distrib, nat.mul_comm]
{ rw [nat.mul_sub_right_distrib, nat.mul_comm], apply nat.sub_le_sub_left, exact (div_lt_iff_lt_mul _ _ npos).1 (lt_succ_self _) }
apply nat.sub_le_sub_left
exact (div_lt_iff_lt_mul _ _ npos).1 (lt_succ_self _)
change succ (pred (n * p - x)) ≤ (succ (pred (p - x / n))) * n
{ change succ (pred (n * p - x)) ≤ (succ (pred (p - x / n))) * n, rw [succ_pred_eq_of_pos (nat.sub_pos_of_lt h₁), succ_pred_eq_of_pos (nat.sub_pos_of_lt _)], { rw [nat.mul_sub_right_distrib, nat.mul_comm], apply nat.sub_le_sub_left, apply div_mul_le_self }, { apply (div_lt_iff_lt_mul _ _ npos).2, rwa nat.mul_comm } }
rw [succ_pred_eq_of_pos (nat.sub_pos_of_lt h₁), succ_pred_eq_of_pos (nat.sub_pos_of_lt _)]
rw [nat.mul_sub_right_distrib, nat.mul_comm]
{ rw [nat.mul_sub_right_distrib, nat.mul_comm], apply nat.sub_le_sub_left, apply div_mul_le_self }
apply nat.sub_le_sub_left
apply div_mul_le_self
{ apply (div_lt_iff_lt_mul _ _ npos).2, rwa nat.mul_comm }
apply (div_lt_iff_lt_mul _ _ npos).2
rwa nat.mul_comm
intros
apply nat.strong_induction_on m
clear m
intros m IH
cases decidable.em (0 < k ∧ k ≤ m) with h h'
have h' : m - k < m
{ have h' : m - k < m, { apply nat.sub_lt _ h.left, apply lt_of_lt_of_le h.left h.right }, rw [div_def, mod_def, if_pos h, if_pos h], simp [nat.left_distrib, IH _ h', nat.add_comm, nat.add_left_comm], rw [nat.add_comm, ← nat.add_sub_assoc h.right, nat.mul_one, nat.add_sub_cancel_left] }
apply nat.sub_lt _ h.left
{ apply nat.sub_lt _ h.left, apply lt_of_lt_of_le h.left h.right }
apply lt_of_lt_of_le h.left h.right
rw [div_def, mod_def, if_pos h, if_pos h]
simp [nat.left_distrib, IH _ h', nat.add_comm, nat.add_left_comm]
rw [nat.add_comm, ← nat.add_sub_assoc h.right, nat.mul_one, nat.add_sub_cancel_left]
rw [div_def, mod_def, if_neg h', if_neg h', nat.mul_zero, nat.add_zero]
{ rw [div_def, mod_def, if_neg h', if_neg h', nat.mul_zero, nat.add_zero] }
intros
by_cases c; simp [*]
by_cases c
simp [*]
simp [*]
intros
{ rintros _ ⟨i, j, hi, hj, rfl⟩, exact mul_mem_mul hi hj }
rintros _ ⟨i, j, hi, hj, rfl⟩
exact mul_mem_mul hi hj
intros
rw [← multiset.rel_eq, multiset.rel_map]
{ rw [← multiset.rel_eq, multiset.rel_map], simp only [mk_eq_mk_iff_associated] }
simp only [mk_eq_mk_iff_associated]
intros
rw [← prod_insert (not_mem_erase a s), insert_erase h]
intros
simp only [finset.prod, multiset.map_const, multiset.prod_repeat, one_pow]
intros
split_ifs with h
rw [finset.prod_eq_single a, dif_pos rfl]
{ rw [finset.prod_eq_single a, dif_pos rfl], { intros, rw dif_neg, cc }, { cc } }
{ intros, rw dif_neg, cc }
intros
rw dif_neg
cc
{ cc }
cc
rw finset.prod_eq_one
{ rw finset.prod_eq_one, intros, rw dif_neg, intro, cc }
intros
rw dif_neg
intro
cc
intros
rw [finprod, dif_pos]
refine finset.prod_subset hs (λ x hx hxf, _)
rwa [hf.mem_to_finset, nmem_mul_support] at hxf
intros
simp
intros
rw eq_neg_iff_add_eq_zero
nth_rewrite 1 ← one_pow p
rw [← add_pow_char, add_left_neg, zero_pow (fact.out (nat.prime p)).pos]
intros
induction succ_n_le_m with m succ_n_le_m IH
{ refl }
refl
have : g.continuants_aux (m + 1) = g.continuants_aux m
{ have : g.continuants_aux (m + 1) = g.continuants_aux m, by { have : n ≤ m - 1, from nat.le_pred_of_lt succ_n_le_m, have : g.terminated_at (m - 1), from terminated_stable this terminated_at_n, have stable_step : g.continuants_aux (m - 1 + 2) = g.continuants_aux (m - 1 + 1), from continuants_aux_stable_step_of_terminated this, have one_le_m : 1 ≤ m, from nat.one_le_of_lt succ_n_le_m, have : m - 1 + 2 = m + 2 - 1, from (nat.sub_add_comm one_le_m).symm, have : m - 1 + 1 = m + 1 - 1, from (nat.sub_add_comm one_le_m).symm, simpa [*] using stable_step }, exact (eq.trans this IH) }
have : n ≤ m - 1
have : n ≤ m - 1
{ have : n ≤ m - 1, from nat.le_pred_of_lt succ_n_le_m, have : g.terminated_at (m - 1), from terminated_stable this terminated_at_n, have stable_step : g.continuants_aux (m - 1 + 2) = g.continuants_aux (m - 1 + 1), from continuants_aux_stable_step_of_terminated this, have one_le_m : 1 ≤ m, from nat.one_le_of_lt succ_n_le_m, have : m - 1 + 2 = m + 2 - 1, from (nat.sub_add_comm one_le_m).symm, have : m - 1 + 1 = m + 1 - 1, from (nat.sub_add_comm one_le_m).symm, simpa [*] using stable_step }
{ have : n ≤ m - 1, from nat.le_pred_of_lt succ_n_le_m, have : g.terminated_at (m - 1), from terminated_stable this terminated_at_n, have stable_step : g.continuants_aux (m - 1 + 2) = g.continuants_aux (m - 1 + 1), from continuants_aux_stable_step_of_terminated this, have one_le_m : 1 ≤ m, from nat.one_le_of_lt succ_n_le_m, have : m - 1 + 2 = m + 2 - 1, from (nat.sub_add_comm one_le_m).symm, have : m - 1 + 1 = m + 1 - 1, from (nat.sub_add_comm one_le_m).symm, simpa [*] using stable_step }
from nat.le_pred_of_lt succ_n_le_m
from nat.le_pred_of_lt succ_n_le_m
have : g.terminated_at (m - 1)
have : g.terminated_at (m - 1)
from terminated_stable this terminated_at_n
from terminated_stable this terminated_at_n
have stable_step : g.continuants_aux (m - 1 + 2) = g.continuants_aux (m - 1 + 1)
have stable_step : g.continuants_aux (m - 1 + 2) = g.continuants_aux (m - 1 + 1)
from continuants_aux_stable_step_of_terminated this
from continuants_aux_stable_step_of_terminated this
have one_le_m : 1 ≤ m
have one_le_m : 1 ≤ m
from nat.one_le_of_lt succ_n_le_m
from nat.one_le_of_lt succ_n_le_m
have : m - 1 + 2 = m + 2 - 1
have : m - 1 + 2 = m + 2 - 1
from (nat.sub_add_comm one_le_m).symm
from (nat.sub_add_comm one_le_m).symm
have : m - 1 + 1 = m + 1 - 1
have : m - 1 + 1 = m + 1 - 1
from (nat.sub_add_comm one_le_m).symm
from (nat.sub_add_comm one_le_m).symm
simpa [*] using stable_step
simpa [*] using stable_step
exact (eq.trans this IH)
intros
{ rw mul_comm, exact mul_left_not_lt b h }
rw mul_comm
exact mul_left_not_lt b h
intros
ext
{ext, refl}
refl
intros
obtain ⟨m', hm', n', hn', h⟩ := (exists_dvd_and_dvd_of_dvd_mul $ gcd_dvd_right k (m * n))
replace h : gcd k (m * n) = m' * n' := h
rw h
have hm'n' : m' * n' ∣ k := h ▸ gcd_dvd_left _ _
apply mul_dvd_mul
have hm'k : m' ∣ k := (dvd_mul_right m' n').trans hm'n'
{ have hm'k : m' ∣ k := (dvd_mul_right m' n').trans hm'n', exact dvd_gcd hm'k hm' }
exact dvd_gcd hm'k hm'
have hn'k : n' ∣ k := (dvd_mul_left n' m').trans hm'n'
{ have hn'k : n' ∣ k := (dvd_mul_left n' m').trans hm'n', exact dvd_gcd hn'k hn' }
exact dvd_gcd hn'k hn'
intros
simp [geom_sum₂_def, f.map_sum]
intros
rw [mul_eq_one_iff_eq_inv, eq_inv_iff_eq_inv, eq_comm]
intros
rw [← sub_eq_zero, H, sub_eq_zero]
intros
by_cases h : P; simp [h]
{ by_cases h : P; simp [h], }
by_cases h : P
simp [h]
simp [h]
intros
rintros ⟨⟩ ⟨⟩ h
replace h := group.mk.inj h
dsimp at h
rcases h with ⟨rfl, rfl, rfl, rfl, rfl, rfl⟩
refl
intros
induction n with n ih
{ rw [nat.mul_zero, pow_zero, pow_zero] }
rw [nat.mul_zero, pow_zero, pow_zero]
{ rw [nat.mul_succ, pow_add, pow_succ', ih] }
rw [nat.mul_succ, pow_add, pow_succ', ih]
intros
rw [sq, sq, mul_self_sub_mul_self]
intros
have : 0 ≤ C
simpa only [pow_zero, mul_one] using h 0
simpa only [pow_zero, mul_one] using h 0
refine this.eq_or_lt.elim (λ h, or.inl h.symm) (λ hC, or.inr ⟨hC, _⟩)
refine nonneg_of_mul_nonneg_left _ hC
simpa only [pow_one] using h 1
intros
induction b; simp [*, mul_add, pow_succ, add_comm]
induction b
simp [*, mul_add, pow_succ, add_comm]
simp [*, mul_add, pow_succ, add_comm]
intros
rw [← one_div_one_div a, h, one_div_one_div]
intros
rw [← mul_div_assoc, mul_div_right_comm]
intros
rw C.shape
{ rw C.shape, simp only [complex_shape.up_rel, zero_add], exact (nat.one_lt_succ_succ _).ne }
simp only [complex_shape.up_rel, zero_add]
exact (nat.one_lt_succ_succ _).ne
intros
rw C.d_to_eq r
apply image_subobject_iso_comp
intros
rw eq_top_iff
apply le_kernel_subobject
rw [C.d_from_eq_zero h, comp_zero]
intros
dsimp [d_next]
rcases c.next i with _|⟨i',w⟩
{ exact zero_comp.symm, }
exact zero_comp.symm
dsimp [d_next]
{ dsimp [d_next], simp, }
simp
intros
cases i
{ rw [d_from_eq_zero], simp, }
rw [d_from_eq_zero]
simp
{ rw [d_from_eq ((single₀ V).obj X) rfl], simp, }
rw [d_from_eq ((single₀ V).obj X) rfl]
simp
intros
induction n with d hd
{ simp [zero_nsmul, id_def] }
simp [zero_nsmul, id_def]
{ simp [hd, add_assoc, succ_nsmul] }
simp [hd, add_assoc, succ_nsmul]
intros
{ ext, refl, }
ext
refl
intros
suffices : ⁅(⊥ : lie_ideal R L), N⁆ ≤ ⊥
exact le_bot_iff.mp this
{ exact le_bot_iff.mp this, }
rw [lie_ideal_oper_eq_span, lie_span_le]
rintros m ⟨⟨x, hx⟩, n, hn⟩
rw ← hn
change x ∈ (⊥ : lie_ideal R L) at hx
rw mem_bot at hx
simp [hx]
intros
induction k with k h
rw [derived_series_def, derived_series_of_ideal_zero, lower_central_series_zero]
{ rw [derived_series_def, derived_series_of_ideal_zero, lower_central_series_zero], exact le_refl _, }
exact le_refl _
have h' : derived_series R L k ≤ ⊤
{ have h' : derived_series R L k ≤ ⊤, { by simp only [le_top], }, rw [derived_series_def, derived_series_of_ideal_succ, lower_central_series_succ], exact lie_submodule.mono_lie _ _ _ _ h' h, }
simp only [le_top]
simp only [le_top]
{ by simp only [le_top], }
rw [derived_series_def, derived_series_of_ideal_succ, lower_central_series_succ]
exact lie_submodule.mono_lie _ _ _ _ h' h
intros
{ rw eq_bot_iff, exact derived_series_of_ideal_le_self ⊥ k, }
rw eq_bot_iff
exact derived_series_of_ideal_le_self ⊥ k
intros
{ rw ← map_le_iff_le_comap, apply le_refl _, }
rw ← map_le_iff_le_comap
apply le_refl _
intros
simp only [ne.def, smul_eq_zero, not_or_distrib]
intros
rw [←neg_neg c, neg_smul, neg_smul (-c), neg_lt_neg_iff] at h
exact lt_of_smul_lt_smul_of_nonneg h (neg_nonneg_of_nonpos hc)
intros
simp [one_def]
intros
rw [mul_comm, div_lt_iff hc]
intros
rw [div_eq_mul_one_div a c, div_eq_mul_one_div b c]
exact mul_le_mul_of_nonpos_right h (one_div_nonpos.2 hc)
intros
rw [div_add_div_same, ← two_mul, mul_div_cancel_left a two_ne_zero]
intros
rw [abs_eq_max_neg, max_comm, neg_neg, abs_eq_max_neg]
intros
rw [← mul_lt_mul_iff_left a, mul_inv_self, mul_one]
intros
rw [mul_comm c, mul_inv_le_inv_mul_iff, mul_comm]
intros
simp only [div_eq_mul_inv, min_mul_mul_left, min_inv_inv']
intros
rw [abs_mul, abs_mul_abs_self]
intros
simp only [← not_lt, inv_of_pos]
intros
induction n; simp [nat.succ_eq_add_one, add_nsmul, ← add_assoc, zero_nsmul, *] at *
induction n
simp [nat.succ_eq_add_one, add_nsmul, ← add_assoc, zero_nsmul, *] at *
simp [nat.succ_eq_add_one, add_nsmul, ← add_assoc, zero_nsmul, *] at *
intros
simp [*, neg_div_neg_eq] at *
intros
simp only [← inv_preimage, preimage_preimage, inv_inv, preimage_id']
{ simp only [← inv_preimage, preimage_preimage, inv_inv, preimage_id'] }
intros
rw ← mul_and_mul_iff
exact ⟨λ ab, ⟨ab, by rwa mul_comm⟩, λ rab, rab.1⟩
intros
rw [← mul_self_sub_mul_self, mul_one]
intros
simp [mk_alg_hom, mk_ring_hom, quot.sound (rel.of w)]
intros
dsimp [δ]
{ dsimp [δ], simp only [←X.map_comp, ←op_comp, simplex_category.δ_comp_δ H] }
simp only [←X.map_comp, ←op_comp, simplex_category.δ_comp_δ H]
intros
rcases (hf.eventually.and hg.eventually).exists with ⟨r, hr⟩
exact ⟨r, hr.1.add hr.2⟩
intros
rcases hab.exists_eq_mul with ⟨φ, hφ, habφ⟩
have : (λ (x : α), a x • u x) - (λ (x : α), b x • v x) =ᶠ[l] λ x, b x • ((φ x • u x) - v x)
convert (habφ.comp₂ (•) $ eventually_eq.refl _ u).sub (eventually_eq.refl _ (λ x, b x • v x))
{ convert (habφ.comp₂ (•) $ eventually_eq.refl _ u).sub (eventually_eq.refl _ (λ x, b x • v x)), ext, rw [pi.mul_apply, mul_comm, mul_smul, ← smul_sub] }
ext
rw [pi.mul_apply, mul_comm, mul_smul, ← smul_sub]
refine (is_o_congr this.symm $ eventually_eq.rfl).mp ((is_O_refl b l).smul_is_o _)
rcases huv.is_O.exists_pos with ⟨C, hC, hCuv⟩
rw is_equivalent at *
rw is_o_iff at *
rw is_O_with at hCuv
simp only [metric.tendsto_nhds, dist_eq_norm] at hφ
intros c hc
specialize hφ ((c/2)/C) (div_pos (by linarith) hC)
specialize huv (show 0 < c/2, by linarith)
refine hφ.mp (huv.mp $ hCuv.mono $ λ x hCuvx huvx hφx, _)
have key := calc ∥φ x - 1∥ * ∥u x∥ ≤ (c/2) / C * ∥u x∥ : mul_le_mul_of_nonneg_right hφx.le (norm_nonneg $ u x) ... ≤ (c/2) / C * (C*∥v x∥) : mul_le_mul_of_nonneg_left hCuvx (div_pos (by linarith) hC).le ... = c/2 * ∥v x∥ : by {field_simp [hC.ne.symm], ring}
calc ∥((λ (x : α), φ x • u x) - v) x∥ = ∥(φ x - 1) • u x + (u x - v x)∥ : by simp [sub_smul, sub_add] ... ≤ ∥(φ x - 1) • u x∥ + ∥u x - v x∥ : norm_add_le _ _ ... = ∥φ x - 1∥ * ∥u x∥ + ∥u x - v x∥ : by rw norm_smul ... ≤ c / 2 * ∥v x∥ + ∥u x - v x∥ : add_le_add_right key _ ... ≤ c / 2 * ∥v x∥ + c / 2 * ∥v x∥ : add_le_add_left huvx _ ... = c * ∥v x∥ : by ring
intros
suffices h : is_o u (λ x, (1 : 𝕜)) l
{ rwa is_o_one_iff at h }
rwa is_o_one_iff at h
exact huv.trans_is_O (is_O_one_of_tendsto 𝕜 hv)
intros
{ unfold is_O, exact exists_congr (λ _, is_O_with_neg_right) }
unfold is_O
exact exists_congr (λ _, is_O_with_neg_right)
intros
convert hc.mul (has_deriv_within_at_const x s d)
rw [mul_zero, add_zero]
intros
apply p.induction_on
{ simp [has_strict_deriv_at_const] }
simp [has_strict_deriv_at_const]
assume p q hp hq
{ assume p q hp hq, convert hp.add hq; simp }
convert hp.add hq; simp
convert hp.add hq
simp
simp
assume n a h
{ assume n a h, convert h.mul (has_strict_deriv_at_id x), { ext y, simp [pow_add, mul_assoc] }, { simp [pow_add], ring } }
convert h.mul (has_strict_deriv_at_id x)
{ ext y, simp [pow_add, mul_assoc] }
ext y
simp [pow_add, mul_assoc]
{ simp [pow_add], ring }
simp [pow_add]
ring
intros
simp only [deriv, fderiv_add_const]
intros
apply has_fderiv_within_at.fderiv_within _ hxs
exact has_fderiv_at.comp_has_fderiv_within_at x (hg.has_fderiv_at) (hf.has_fderiv_within_at)
intros
simpa only [sub_eq_add_neg] using hf.add_const (-c)
intros
rw differentiable_at.fderiv_within h.differentiable_at hxs
exact h.fderiv
intros
apply implicit_function_of_complemented_apply_image
intros
rw lipschitz_on_with_iff_norm_sub_le
intros x x_in y y_in
exact hs.norm_image_sub_le_of_norm_has_fderiv_within_le hf bound y_in x_in
intros
assume m hm
rcases hf m hm with ⟨u, hu, p, hp⟩
rcases hg m hm with ⟨v, hv, q, hq⟩
exact ⟨u ∩ v, filter.inter_mem hu hv, _, (hp.mono (inter_subset_left u v)).prod (hq.mono (inter_subset_right u v))⟩
intros
split
{ assume H n, exact H.of_le le_top }
assume H n
exact H.of_le le_top
assume H
{ assume H, split, { exact (H 0).zero_eq }, { assume m hm, apply (H m.succ).fderiv_within m (with_top.coe_lt_coe.2 (lt_add_one m)) }, { assume m hm, apply (H m).cont m (le_refl _) } }
split
{ exact (H 0).zero_eq }
exact (H 0).zero_eq
assume m hm
{ assume m hm, apply (H m.succ).fderiv_within m (with_top.coe_lt_coe.2 (lt_add_one m)) }
apply (H m.succ).fderiv_within m (with_top.coe_lt_coe.2 (lt_add_one m))
assume m hm
{ assume m hm, apply (H m).cont m (le_refl _) }
apply (H m).cont m (le_refl _)
intros
refine λ f g hf hg a b ha hb hab, ⟨λ x, _, _⟩
{ apply_rules [add_nonneg, mul_nonneg, hf.1, hg.1] }
apply_rules [add_nonneg, mul_nonneg, hf.1, hg.1]
erw [finset.sum_add_distrib, ← finset.smul_sum, ← finset.smul_sum, hf.2, hg.2, smul_eq_mul, smul_eq_mul, mul_one, mul_one]
{ erw [finset.sum_add_distrib, ← finset.smul_sum, ← finset.smul_sum, hf.2, hg.2, smul_eq_mul, smul_eq_mul, mul_one, mul_one], exact hab }
exact hab
intros
intros x y hx hy a b ha hb hab
apply mem_prod.2
exact ⟨hs (mem_prod.1 hx).1 (mem_prod.1 hy).1 ha hb hab, ht (mem_prod.1 hx).2 (mem_prod.1 hy).2 ha hb hab⟩
intros
apply set.subset.antisymm
rw set.image_subset_iff
{ rw set.image_subset_iff, exact convex_hull_min (set.image_subset_iff.1 $ subset_convex_hull 𝕜 $ f '' s) ((convex_convex_hull 𝕜 (f '' s)).is_linear_preimage hf) }
exact convex_hull_min (set.image_subset_iff.1 $ subset_convex_hull 𝕜 $ f '' s) ((convex_convex_hull 𝕜 (f '' s)).is_linear_preimage hf)
exact convex_hull_min (set.image_subset _ $ subset_convex_hull 𝕜 s) ((convex_convex_hull 𝕜 s).is_linear_image hf)
{ exact convex_hull_min (set.image_subset _ $ subset_convex_hull 𝕜 s) ((convex_convex_hull 𝕜 s).is_linear_image hf) }
intros
split
rintros h₁ ⟨x, xs, H₁, H₂⟩
{ rintros h₁ ⟨x, xs, H₁, H₂⟩, exact h₁ x xs H₁ H₂ }
exact h₁ x xs H₁ H₂
intro h
{ intro h, unfold flat at h, push_neg at h, exact h }
unfold flat at h
push_neg at h
exact h
intros
rintro ⟨w, hw⟩
obtain ⟨l, rfl⟩ := hC ⟨w, hw⟩
exact ⟨l, subset.antisymm (λ x hx, ⟨hCB hx, λ y hy, hx.2 y (hBA hy)⟩) (λ x hx, ⟨hBA hx.1, λ y hy, (hw.2 y hy).trans (hx.2 w (hCB hw))⟩)⟩
intros
let f : set.range p → ι := λ x, x.property.some
have hf : ∀ x, p (f x) = x := λ x, x.property.some_spec
let fe : set.range p ↪ ι := ⟨f, λ x₁ x₂ he, subtype.ext (hf x₁ ▸ hf x₂ ▸ he ▸ rfl)⟩
convert hc.comp_embedding fe
ext
rw [embedding.coe_fn_mk, comp_app, hf]
intros
simpa only [metric.closed_ball, sep_univ] using (convex_on_dist a _ convex_univ).convex_le r
intros
{ rw [← neg_one_smul 𝕜 x, inner_smul_left], simp }
rw [← neg_one_smul 𝕜 x, inner_smul_left]
simp
intros
{ have h := @inner_self_abs_to_K ℝ F _ _ x, simpa using h }
have h := @inner_self_abs_to_K ℝ F _ _ x
simpa using h
intros
{ have h := @norm_eq_sqrt_inner ℝ F _ _ x, simpa using h }
have h := @norm_eq_sqrt_inner ℝ F _ _ x
simpa using h
intros
have : 0 < p := lt_of_lt_of_le zero_lt_one hp
rw [← rpow_le_rpow_iff _ _ this, ← rpow_mul, one_div_mul_cancel (ne_of_gt this), rpow_one]
exact rpow_arith_mean_le_arith_mean_rpow s w z hw hw' hz hp
apply_rules [sum_nonneg, rpow_nonneg_of_nonneg]
all_goals { apply_rules [sum_nonneg, rpow_nonneg_of_nonneg], intros i hi, apply_rules [mul_nonneg, rpow_nonneg_of_nonneg, hw i hi, hz i hi] }
intros i hi
intros i hi
apply_rules [mul_nonneg, rpow_nonneg_of_nonneg, hw i hi, hz i hi]
apply_rules [mul_nonneg, rpow_nonneg_of_nonneg, hw i hi, hz i hi]
apply_rules [sum_nonneg, rpow_nonneg_of_nonneg]
intros i hi
apply_rules [mul_nonneg, rpow_nonneg_of_nonneg, hw i hi, hz i hi]
apply_rules [sum_nonneg, rpow_nonneg_of_nonneg]
intros i hi
intros i hi
apply_rules [mul_nonneg, rpow_nonneg_of_nonneg, hw i hi, hz i hi]
apply_rules [mul_nonneg, rpow_nonneg_of_nonneg, hw i hi, hz i hi]
intros
convert (cokernel_cocone f).w walking_parallel_pair_hom.left
simp
intros
simp [edist_dist]
intros
rcases lt_trichotomy r 0 with hr|rfl|hr
simp [closed_ball_eq_empty.2 hr, ball_eq_empty.2 hr.le]
{ simp [closed_ball_eq_empty.2 hr, ball_eq_empty.2 hr.le] }
{ rw [closed_ball_zero, ball_zero, interior_singleton] }
rw [closed_ball_zero, ball_zero, interior_singleton]
{ exact interior_closed_ball x hr }
exact interior_closed_ball x hr
refine funext (λ x, _)
rw [complex.exp, exp_eq_tsum_field]
exact tendsto_nhds_unique x.exp'.tendsto_limit (exp_series_field_summable x).has_sum.tendsto_sum_nat
intros
rw norm_indicator_eq_indicator_norm
{ rw norm_indicator_eq_indicator_norm, apply indicator_norm_le_norm_self }
apply indicator_norm_le_norm_self
intros
rw [show x - y = -(y - x), by abel, quotient_norm_neg]
intros
refine le_antisymm (le_of_forall_pos_le_add (λ ε hε, _)) (norm_nonneg (f x))
rcases normed_group.tendsto_nhds_nhds.1 (hf.tendsto 0) ε hε with ⟨δ, δ_pos, hδ⟩
replace hδ := hδ x
rw [sub_zero, hx] at hδ
replace hδ := le_of_lt (hδ δ_pos)
rw [linear_map.map_zero, sub_zero] at hδ
rwa [zero_add]
intros
refine op_norm_eq_of_bounds (norm_nonneg _) (λ x, _) (λ N hN_nonneg h, _)
{ rw [to_span_singleton_apply, norm_smul, mul_comm], }
rw [to_span_singleton_apply, norm_smul, mul_comm]
specialize h 1
{ specialize h 1, rw [to_span_singleton_apply, norm_smul, mul_comm] at h, exact (mul_le_mul_right (by simp)).mp h, }
rw [to_span_singleton_apply, norm_smul, mul_comm] at h
exact (mul_le_mul_right (by simp)).mp h
intros
simpa using integral_pow 1
intros
simpa only [one_div] using interval_integrable_one_div h hf
intros
rw [← nnreal.coe_eq, nnreal.coe_pow, coe_rpow]
{ rw [← nnreal.coe_eq, nnreal.coe_pow, coe_rpow], exact real.rpow_nat_inv_pow_nat x.2 hn }
exact real.rpow_nat_inv_pow_nat x.2 hn
intros
simp [cpow_def]
intros
obtain hx | rfl := hx.lt_or_eq
{ exact (lt_rpow_iff_log_lt hx hy).2 h }
exact (lt_rpow_iff_log_lt hx hy).2 h
exact real.rpow_pos_of_pos hy z
convert tendsto_cos_neg_pi_div_two.inv_tendsto_zero.at_top_mul_neg (by norm_num) tendsto_sin_neg_pi_div_two
simp only [pi.inv_apply, ← div_eq_inv_mul, ← tan_eq_sin_div_cos]
intros
convert edist_le_tsum_of_edist_le_of_tendsto _ hu ha _
simp only [pow_add, ennreal.tsum_mul_left, ennreal.tsum_geometric, div_eq_mul_inv, mul_assoc]
intros
tfae_have : 3 → 2
{ introsI, exact kernel_ι_eq_zero_of_exact_zero_left Z }
introsI
exact kernel_ι_eq_zero_of_exact_zero_left Z
tfae_have : 1 → 3
{ introsI, exact exact_zero_left_of_mono Z }
introsI
exact exact_zero_left_of_mono Z
tfae_have : 2 → 1
{ exact mono_of_kernel_ι_eq_zero _ }
exact mono_of_kernel_ι_eq_zero _
tfae_finish
intros
rw [equiv.eq_symm_apply, ← transfer_nat_trans_self_comp _ adj₂]
{ rw [equiv.eq_symm_apply, ← transfer_nat_trans_self_comp _ adj₂], simp }
simp
intros
erw [iso.inv_eq_inv (e.unit_iso.app (e.inverse.obj Y) ≪≫ e.inverse.map_iso (e.counit_iso.app Y)) (iso.refl _)]
exact e.unit_inverse_comp Y
intros
ext
ext; simp only [trans_hom, category.assoc]
simp only [trans_hom, category.assoc]
intros
ext
ext; apply functor.map_comp
apply functor.map_comp
intros
apply induction F (λ X k, G.map k ≫ s.ι.app X = (s.ι.app j : _))
intros j₁ j₂ k₁ k₂ f w h
{ intros j₁ j₂ k₁ k₂ f w h, rw ←w, rw ← s.w f at h, simpa using h, }
rw ←w
rw ← s.w f at h
simpa using h
intros j₁ j₂ k₁ k₂ f w h
{ intros j₁ j₂ k₁ k₂ f w h, rw ←w at h, rw ← s.w f, simpa using h, }
rw ←w at h
rw ← s.w f
simpa using h
{ exact s.w (𝟙 _), }
exact s.w (𝟙 _)
intros
simp
intros
ext
rw [←assoc, colimit.ι_post, ←H.map_comp, colimit.ι_post]
exact (colimit.ι_post F (G ⋙ H) j).symm
intros
{ ext, simp, }
ext
simp
intros
let q := equalizer.ι g h
let e' := equalizer.lift _ w
let F' : mono_factorisation f := { I := equalizer g h, m := q ≫ image.ι f, m_mono := by apply mono_comp, e := e' }
let v := image.lift F'
have t₀ : v ≫ q ≫ image.ι f = image.ι f := image.lift_fac F'
have t : v ≫ q = 𝟙 (image f) := (cancel_mono_id (image.ι f)).1 (by { convert t₀ using 1, rw category.assoc })
calc g = 𝟙 (image f) ≫ g : by rw [category.id_comp] ... = v ≫ q ≫ g : by rw [←t, category.assoc] ... = v ≫ q ≫ h : by rw [equalizer.condition g h] ... = 𝟙 (image f) ≫ h : by rw [←category.assoc, t] ... = h : by rw [category.id_comp]
intros
induction w₁
unfreezingI { induction w₁, induction w₂, }
{ unfreezingI { induction w₁, induction w₂, }, ext, simp [cokernel_iso_of_eq], }
induction w₂
ext
simp [cokernel_iso_of_eq]
intros
haveI := hI.is_iso_to f
haveI := hI.is_iso_to g
exact eq_of_inv_eq_inv (hI.hom_ext (inv f) (inv g))
intros
rw [←s.w (line j), parallel_family_map_left]
intros
{ simp, refl }
simp
refl
intros
simp [tensor_right_tensor]
intros
rw [iso.eq_inv_comp, ←F.associativity_assoc, ←F.to_functor.map_comp, iso.hom_inv_id, F.to_functor.map_id, comp_id]
intros
tidy
intros
rintro X S hS _ ⟨⟨_, _, ⟨P, hP, rfl⟩, rfl⟩, rfl⟩
intros Y f
exact hJ P hP (S.pullback f) (J.pullback_stable f hS)
intros
apply limit.hom_ext
rintro ⟨⟨Y, f, hf⟩, ⟨Z, g, hg⟩⟩
simp only [first_map, second_map, fork_map, limit.lift_π, limit.lift_π_assoc, assoc, fan.mk_π_app, subtype.coe_mk, subtype.val_eq_coe]
rw [← P.map_comp, ← op_comp, pullback.condition]
simp
intros
ext Y g
split
rintro ⟨_⟩
{ rintro ⟨_⟩, apply singleton.mk }
apply singleton.mk
rintro ⟨_⟩
{ rintro ⟨_⟩, exact of_arrows.mk punit.star }
exact of_arrows.mk punit.star
intros
simp
intros
revert f₁
apply quotient.ind'
intro f₁
erw [inf_def, inf_def, inf_eq_map_pullback', inf_eq_map_pullback', ← pullback_comp, ← map_pullback pullback.condition (pullback_is_pullback f₁.arrow g), ← pullback_comp, pullback.condition]
refl
intros
simp [mul_apply, neighbor_finset_eq_filter, sum_filter, adj_comm]
intros
{ ext, simp }
ext
simp
intros
rw [list_blank.nth_succ, add_bottom, list_blank.tail_cons, list_blank.nth_map]
rw [list_blank.nth_succ, add_bottom, list_blank.tail_cons, list_blank.nth_map]; refl
refl
intros
simp only [tape.move, tape.mk', list_blank.head_cons, eq_self_iff_true, list_blank.cons_head_tail, and_self, list_blank.tail_cons]
intros
simp only [free.mk, list.ret, list.mfoldr, pure_bind]
intros
simp [equiv.map, id_map]
intros
ext
ext; simp [comp_traverse]
simp [comp_traverse]
intros
have := to_topsp_is_topological_basis F.F; rwa F.eq at this
have := to_topsp_is_topological_basis F.F
rwa F.eq at this
intros
rcases b with ⟨_|n, ⟨a⟩⟩
simp only [size, nil, mk_buffer, true_and, true_iff, eq_self_iff_true, heq_iff_eq, sigma.mk.inj_iff]
{ simp only [size, nil, mk_buffer, true_and, true_iff, eq_self_iff_true, heq_iff_eq, sigma.mk.inj_iff], ext i, exact fin.elim0 i }
ext i
exact fin.elim0 i
{ simp [size, nil, mk_buffer, nat.succ_ne_zero] }
simp [size, nil, mk_buffer, nat.succ_ne_zero]
intros
split
introI
{ introI, constructor, intros cb n n' a h, have : (@parser.decorate_errors α msgs p) cb n = done n' a := by simpa using h, exact of_done this }
constructor
intros cb n n' a h
have : (@parser.decorate_errors α msgs p) cb n = done n' a := by simpa using h
exact of_done this
introI
{ introI, constructor, intros _ _ _ _ h, rw decorate_errors_eq_done at h, exact of_done h }
constructor
intros _ _ _ _ h
rw decorate_errors_eq_done at h
exact of_done h
intros
simp [remaining]
intros
have c9 : '9'.to_nat - '0'.to_nat = 9 := rfl
have l09 : '0'.to_nat ≤ '9'.to_nat := dec_trivial
have le_iff_le : ∀ {c c' : char}, c ≤ c' ↔ c.to_nat ≤ c'.to_nat := λ _ _, iff.rfl
split
simp only [digit, sat_eq_done, pure_eq_done, decorate_error_eq_done, bind_eq_done, ←c9]
{ simp only [digit, sat_eq_done, pure_eq_done, decorate_error_eq_done, bind_eq_done, ←c9], rintro ⟨np, c, ⟨hn, ⟨ge0, le9⟩, rfl, rfl⟩, rfl, rfl⟩, simpa [hn, ge0, le9, true_and, and_true, eq_self_iff_true, exists_prop_of_true, nat.sub_le_sub_right_iff, l09] using (le_iff_le.mp le9) }
rintro ⟨np, c, ⟨hn, ⟨ge0, le9⟩, rfl, rfl⟩, rfl, rfl⟩
simpa [hn, ge0, le9, true_and, and_true, eq_self_iff_true, exists_prop_of_true, nat.sub_le_sub_right_iff, l09] using (le_iff_le.mp le9)
simp only [digit, sat_eq_done, pure_eq_done, decorate_error_eq_done, bind_eq_done, ←c9, le_iff_le]
{ simp only [digit, sat_eq_done, pure_eq_done, decorate_error_eq_done, bind_eq_done, ←c9, le_iff_le], rintro ⟨hn, rfl, -, rfl, ge0, le9⟩, use [n + 1, cb.read ⟨n, hn⟩], simp [hn, ge0, le9] }
rintro ⟨hn, rfl, -, rfl, ge0, le9⟩
use [n + 1, cb.read ⟨n, hn⟩]
simp [hn, ge0, le9]
simp
intros
rw [← of_real_int_cast, of_real_im]
intros
rw [← mul_left_inj' I_ne_zero, ← sinh_mul_I, add_mul, add_mul, mul_right_comm, ← sinh_mul_I, mul_assoc, ← sinh_mul_I, ← cosh_mul_I, ← cosh_mul_I, sinh_add]
intros
rw [←sin_sq_add_cos_sq x, add_sub_cancel']
intros
rw [← neg_inj, ← of_real_neg, ← I_mul_re, re_eq_add_conj]
simp [mul_add, sub_eq_add_neg, neg_div']
intros
apply le_antisymm
apply bsupr_le _
{ apply bsupr_le _, intros i hi y hy, refine ⟨dfinsupp.single i ⟨y, hy⟩, _⟩, rw [add_monoid_hom.comp_apply, filter_add_monoid_hom_apply, filter_single_pos _ _ hi], exact sum_add_hom_single _ _ _, }
intros i hi y hy
refine ⟨dfinsupp.single i ⟨y, hy⟩, _⟩
rw [add_monoid_hom.comp_apply, filter_add_monoid_hom_apply, filter_single_pos _ _ hi]
exact sum_add_hom_single _ _ _
rintros x ⟨v, rfl⟩
{ rintros x ⟨v, rfl⟩, refine add_submonoid.dfinsupp_sum_add_hom_mem _ _ _ (λ i hi, _), refine add_submonoid.mem_supr_of_mem i _, by_cases hp : p i, { simp [hp], }, { simp [hp] }, }
refine add_submonoid.dfinsupp_sum_add_hom_mem _ _ _ (λ i hi, _)
refine add_submonoid.mem_supr_of_mem i _
by_cases hp : p i
{ simp [hp], }
simp [hp]
{ simp [hp] }
simp [hp]
intros
simp only [single_apply, dif_pos rfl]
intros
apply (equiv.set.sum_diff_subset h).injective
simp only [apply_symm_apply, sum_diff_subset_apply_inl]
exact subtype.eq rfl
intros
split
rintro ⟨a, ha₁, ha₂⟩
{ rintro ⟨a, ha₁, ha₂⟩, exact ⟨f a, h.1 ha₁, λ b hb, f.symm_apply_eq.1 (ha₂ (f.symm b) (h.2 (by simpa using hb)))⟩ }
exact ⟨f a, h.1 ha₁, λ b hb, f.symm_apply_eq.1 (ha₂ (f.symm b) (h.2 (by simpa using hb)))⟩
rintro ⟨b, hb₁, hb₂⟩
{ rintro ⟨b, hb₁, hb₂⟩, exact ⟨f.symm b, h.2 (by simpa using hb₁), λ y hy, (eq_symm_apply f).2 (hb₂ _ (h.1 hy))⟩ }
exact ⟨f.symm b, h.2 (by simpa using hb₁), λ y hy, (eq_symm_apply f).2 (hb₂ _ (h.1 hy))⟩
intros
apply arrow_congr_comp
intros
simp only [directed.sequence, encodek]
exact (classical.some_spec (hf _ a)).2
intros
convert (e.to_compl ⟨x, hx⟩).2
{ convert (e.to_compl ⟨x, hx⟩).2, rw [e.extend_subtype_apply_of_not_mem _ hx, subtype.val_eq_coe] }
rw [e.extend_subtype_apply_of_not_mem _ hx, subtype.val_eq_coe]
intros
rintro x (⟨he, hs⟩|⟨he, hs : x ∉ s⟩)
rw [piecewise_eq_of_mem _ _ _ hs, piecewise_eq_of_mem _ _ _ ((h he).2 hs), e.left_inv he]
{ rw [piecewise_eq_of_mem _ _ _ hs, piecewise_eq_of_mem _ _ _ ((h he).2 hs), e.left_inv he], }
rw [piecewise_eq_of_not_mem _ _ _ hs, piecewise_eq_of_not_mem _ _ _ ((h'.compl he).2 hs), e'.left_inv he]
{ rw [piecewise_eq_of_not_mem _ _ _ hs, piecewise_eq_of_not_mem _ _ _ ((h'.compl he).2 hs), e'.left_inv he] }
intros
{ ext i, simp [tail, init, cast_succ_fin_succ] }
ext i
simp [tail, init, cast_succ_fin_succ]
intros
rcases i with ⟨_|j, h⟩
{ left, refl, }
left
refl
{ right, exact ⟨⟨j, nat.lt_of_succ_lt_succ h⟩, rfl⟩, }
right
exact ⟨⟨j, nat.lt_of_succ_lt_succ h⟩, rfl⟩
intros
cases a; refl
cases a
refl
intros
{ subst h, simp }
subst h
simp
intros
induction s using finset.cons_induction with x xs hx ih
{ rw [fold_empty, image_empty, fold_empty] }
rw [fold_empty, image_empty, fold_empty]
haveI := classical.dec_eq γ
{ haveI := classical.dec_eq γ, rw [fold_cons, cons_eq_insert, image_insert, fold_insert_idem, ih], }
rw [fold_cons, cons_eq_insert, image_insert, fold_insert_idem, ih]
intros
classical
rw [←finset.coe_image, ←sup_id_eq_Sup, sup_image, function.comp.left_id]
intros
rw [of_dual, to_dual, equiv.coe_fn_mk, equiv.coe_fn_symm_mk, id.def]
simp_rw (@image_id (order_dual α) (s : finset (order_dual α)))
refl
intros
refine ((sum_sum_index _ _).trans _).symm
{ intros, exact single_zero }
intros
exact single_zero
{ intros, exact single_add }
intros
exact single_add
refine sum_congr rfl (λ _ _, sum_single_index _)
{ exact single_zero }
exact single_zero
intros
{ ext, refl, }
ext
refl
intros
haveI := classical.dec_eq α
obtain ⟨p⟩ := trunc_rec_empty_option @of_equiv h_empty (λ _ _ _, by exactI h_option) α
exact p
intros
simp [contains_aux, option.is_some_iff_exists, v.find_aux_iff hash_fn]
intros
simpa only [units.ext_iff, units_nat_abs] using nat_abs_eq u
intros
rw [← int.coe_nat_zero, coe_nat_inj']
intros
{ rw [sq, sq], exact nat_abs_eq_iff_mul_self_eq }
rw [sq, sq]
exact nat_abs_eq_iff_mul_self_eq
intros
simp
intros
rw int.gcd
split
intro h
{ intro h, exact ⟨nat_abs_eq_zero.mp (nat.eq_zero_of_gcd_eq_zero_left h), nat_abs_eq_zero.mp (nat.eq_zero_of_gcd_eq_zero_right h)⟩ }
exact ⟨nat_abs_eq_zero.mp (nat.eq_zero_of_gcd_eq_zero_left h), nat_abs_eq_zero.mp (nat.eq_zero_of_gcd_eq_zero_right h)⟩
intro h
{ intro h, rw [nat_abs_eq_zero.mpr h.left, nat_abs_eq_zero.mpr h.right], apply nat.gcd_zero_left }
rw [nat_abs_eq_zero.mpr h.left, nat_abs_eq_zero.mpr h.right]
apply nat.gcd_zero_left
intros
cases mod_two_eq_zero_or_one m with h₁ h₁; cases mod_two_eq_zero_or_one n with h₂ h₂; simp [even_iff, h₁, h₂, int.add_mod]; norm_num
cases mod_two_eq_zero_or_one m with h₁ h₁; cases mod_two_eq_zero_or_one n with h₂ h₂; simp [even_iff, h₁, h₂, int.add_mod]
cases mod_two_eq_zero_or_one m with h₁ h₁; cases mod_two_eq_zero_or_one n with h₂ h₂
cases mod_two_eq_zero_or_one m with h₁ h₁
cases mod_two_eq_zero_or_one n with h₂ h₂
simp [even_iff, h₁, h₂, int.add_mod]
simp [even_iff, h₁, h₂, int.add_mod]
norm_num
cases mod_two_eq_zero_or_one n with h₂ h₂
simp [even_iff, h₁, h₂, int.add_mod]
norm_num
simp [even_iff, h₁, h₂, int.add_mod]
norm_num
intros
rw [nth_le_nth, index_of_nth_le (index_of_lt_length.2 h)]
intros
induction l with hd tl IH generalizing n k
{ simpa using hk' }
simpa using hk'
cases n
{ cases n, { simpa }, { simpa [succ_add] using IH _ _ _ } }
{ simpa }
simpa
{ simpa [succ_add] using IH _ _ _ }
simpa [succ_add] using IH _ _ _
intros
cases l with x l
{ simp [init] }
simp [init]
induction l with hd tl hl generalizing x
{ induction l with hd tl hl generalizing x, { simp [init], }, { simp [init, hl] } }
{ simp [init], }
simp [init]
{ simp [init, hl] }
simp [init, hl]
intros
induction n with n ih
{ rw pow_zero, refl }
rw pow_zero
refl
{ rw [list.repeat_succ, list.prod_cons, ih, pow_succ] }
rw [list.repeat_succ, list.prod_cons, ih, pow_succ]
intros
induction L; [refl, simp only [*, join, map, sum_cons, length_append]]
induction L
refl
simp only [*, join, map, sum_cons, length_append]
intros
induction l with _ _ ih; [refl, rw [pmap, pmap, h, ih]]
induction l with _ _ ih
refl
rw [pmap, pmap, h, ih]
intros
split
intro h
{ intro h, simp only [subset_def] at *, split; intros; simp* }
simp only [subset_def] at *
split
split; intros; simp*
split; intros
intros
simp*
intros
simp*
rintro ⟨h1, h2⟩
{ rintro ⟨h1, h2⟩, apply append_subset_of_subset_of_subset h1 h2 }
apply append_subset_of_subset_of_subset h1 h2
intros
rw count_cons
split_ifs
split_ifs; refl
refl
refl
intros
split
rintro ⟨L, hL⟩
{ rintro ⟨L, hL⟩, simp only [cons_append] at hL, exact ⟨hL.left, ⟨L, hL.right⟩⟩ }
simp only [cons_append] at hL
exact ⟨hL.left, ⟨L, hL.right⟩⟩
rintro ⟨rfl, h⟩
{ rintro ⟨rfl, h⟩, rwa [prefix_cons_inj] }
rwa [prefix_cons_inj]
intros
simp [foldr_permutations_aux2, (∘), length_permutations_aux2]
intros
rcases exists_of_erasep h rfl with ⟨_, l₁, l₂, h₁, rfl, h₂, h₃⟩
rcases exists_of_erasep h rfl with ⟨_, l₁, l₂, h₁, rfl, h₂, h₃⟩; rw erase_eq_erasep; exact ⟨l₁, l₂, λ h, h₁ _ h rfl, h₂, h₃⟩
rcases exists_of_erasep h rfl with ⟨_, l₁, l₂, h₁, rfl, h₂, h₃⟩; rw erase_eq_erasep
rw erase_eq_erasep
exact ⟨l₁, l₂, λ h, h₁ _ h rfl, h₂, h₃⟩
intros
rw disjoint_comm; simp only [singleton_disjoint]
rw disjoint_comm
simp only [singleton_disjoint]
intros
apply list.ext_le
{ simp }
simp
intros n hn hn'
{ intros n hn hn', rw [nth_le_rotate, nth_le_pmap, prev_nth_le _ h] }
rw [nth_le_rotate, nth_le_pmap, prev_nth_le _ h]
intros
simp [nodup_iff_forall_not_duplicate]
intros
simp only [indexes_values_eq_filter_enum, map_filter_eq_foldr, find_indexes, foldr_with_index_eq_foldr_enum, uncurry]
intros
rw [argmax, argmax]; simp [argmax₂]
rw [argmax, argmax]
simp [argmax₂]
intros
rw concat_eq_append; exact nodup_append_of_nodup h' (nodup_singleton _) (disjoint_singleton.2 h)
rw concat_eq_append
exact nodup_append_of_nodup h' (nodup_singleton _) (disjoint_singleton.2 h)
intros
rw [← filter_map_eq_filter, pairwise_filter_map]
apply pairwise.iff
intros
simp only [option.mem_def, option.guard_eq_some, and_imp, forall_eq']
intros
induction d with a l₁' h d IH
{ exact ⟨nil, perm.nil, nil_sublist _⟩ }
exact ⟨nil, perm.nil, nil_sublist _⟩
cases forall_mem_cons.1 H with H₁ H₂
{ cases forall_mem_cons.1 H with H₁ H₂, simp at h, exact cons_subperm_of_mem d h H₁ (IH H₂) }
simp at h
exact cons_subperm_of_mem d h H₁ (IH H₂)
intros
let F := λ a b, f a → f b → false
change pairwise F l₁ at H
induction p with a l₁ l₂ p IH a b l l₁ l₂ l₃ p₁ p₂ IH₁ IH₂
simp
{simp}
by_cases h : f a
{ by_cases h : f a, { simp [h, p] }, { simp [h], exact IH (pairwise_cons.1 H).2 } }
{ simp [h, p] }
simp [h, p]
{ simp [h], exact IH (pairwise_cons.1 H).2 }
simp [h]
exact IH (pairwise_cons.1 H).2
by_cases h₁ : f a; by_cases h₂ : f b; simp [h₁, h₂]
by_cases h₁ : f a; by_cases h₂ : f b
by_cases h₁ : f a
{ by_cases h₁ : f a; by_cases h₂ : f b; simp [h₁, h₂], { cases (pairwise_cons.1 H).1 _ (or.inl rfl) h₂ h₁ }, { apply swap } }
by_cases h₂ : f b
simp [h₁, h₂]
{ cases (pairwise_cons.1 H).1 _ (or.inl rfl) h₂ h₁ }
cases (pairwise_cons.1 H).1 _ (or.inl rfl) h₂ h₁
simp [h₁, h₂]
by_cases h₂ : f b
simp [h₁, h₂]
simp [h₁, h₂]
{ apply swap }
apply swap
refine (IH₁ H).trans (IH₂ ((p₁.pairwise_iff _).1 H))
{ refine (IH₁ H).trans (IH₂ ((p₁.pairwise_iff _).1 H)), exact λ a b h h₁ h₂, h h₂ h₁ }
exact λ a b h h₁ h₂, h h₂ h₁
intros
induction l
simp
case list.nil { simp }
case list.cons : hd tl ih { simp at nd, by_cases h : a = hd.1, { subst h, simp [nd.1] }, { simp [h, ih nd.2] } }
intros
induction l generalizing f r; [refl, simp only [*, sublists'_aux]]
induction l generalizing f r
refl
simp only [*, sublists'_aux]
intros
simp only [revzip, length_zip, length_reverse, min_self]
intros
{ ext, apply neg_dot_product }
ext
apply neg_dot_product
intros
ext
{ ext, refl }
refl
intros
ext
{ ext, simp only [one_apply, map_apply], split_ifs; simp [h₀, h₁], }
simp only [one_apply, map_apply]
split_ifs
split_ifs; simp [h₀, h₁]
simp [h₀, h₁]
simp [h₀, h₁]
intros
ext i j; rw [← diagonal_one, diagonal_mul, one_mul]
ext i j
rw [← diagonal_one, diagonal_mul, one_mul]
intros
simp [mul_apply, h.symm]
intros
simp only [conj_transpose, block_diagonal'_transpose]
exact block_diagonal'_map _ star (star_zero α)
intros
rw [rel_iff]; simp
rw [rel_iff]
simp
intros
rw nodup_erase_eq_filter b d; simp [and_comm]
rw nodup_erase_eq_filter b d
simp [and_comm]
intros
rw powerset_aux_eq_map_coe; exact (sublists_perm_sublists' _).map _
rw powerset_aux_eq_map_coe
exact (sublists_perm_sublists' _).map _
intros
simp [monomial_eq]
intros
apply mv_polynomial.induction_on p
{ intro r, rw [eval₂_C, map_C, eval₂_C] }
intro r
rw [eval₂_C, map_C, eval₂_C]
intros p q hp hq
{ intros p q hp hq, rw [eval₂_add, k.map_add, (map f).map_add, eval₂_add, hp, hq] }
rw [eval₂_add, k.map_add, (map f).map_add, eval₂_add, hp, hq]
intros p s hp
{ intros p s hp, rw [eval₂_mul, k.map_mul, (map f).map_mul, eval₂_mul, map_X, hp, eval₂_X, eval₂_X] }
rw [eval₂_mul, k.map_mul, (map f).map_mul, eval₂_mul, map_X, hp, eval₂_X, eval₂_X]
intros
convert vars_add_subset p (-q) using 2; simp [sub_eq_add_neg]
convert vars_add_subset p (-q) using 2
simp [sub_eq_add_neg]
simp [sub_eq_add_neg]
intros
{ ext1 i, simp }
ext1 i
simp
intros
obtain ⟨s, q, rfl⟩ := exists_finset_rename p
let n := fintype.card {x // x ∈ s}
let e := fintype.equiv_fin {x // x ∈ s}
refine ⟨n, coe ∘ e.symm, subtype.val_injective.comp e.symm.injective, rename e q, _⟩
rw [← rename_rename, rename_rename e]
simp only [function.comp, equiv.symm_apply_apply, rename_rename]
intros
apply finset.subset.antisymm (vars_add_subset p q)
intros x hx
simp only [vars, multiset.disjoint_to_finset] at h hx ⊢
rw [degrees_add_of_disjoint h, multiset.to_finset_union]
exact hx
intros
cases le_total n m with H H
{ exact dvd_sub H h₁ h₂ }
exact dvd_sub H h₁ h₂
rw nat.sub_eq_zero_of_le H
{ rw nat.sub_eq_zero_of_le H, exact dvd_zero k }
exact dvd_zero k
intros
rw [pos_iff_ne_zero, ne, nat.find_eq_zero]
intros
simp [add_comm]
intros
rw [le_rec_on_succ (le_refl n), le_rec_on_self]
intros
rw [mul_comm,nat.div_mul_cancel Hd]
intros
rw [←choose_mul_factorial_mul_factorial hk, mul_assoc]
rw [←choose_mul_factorial_mul_factorial hk, mul_assoc]; exact dvd_mul_left _ _
exact dvd_mul_left _ _
intros
induction L with d L ih
{ change k ∣ 0 - 0, simp, }
change k ∣ 0 - 0
simp
simp only [of_digits, add_sub_add_left_eq_sub]
{ simp only [of_digits, add_sub_add_left_eq_sub], exact dvd_mul_sub_mul h ih, }
exact dvd_mul_sub_mul h ih
intros
rw [gcd_comm, gcd_mul_right_left]
intros
simp [coprime]
intros
obtain hb | hb := le_or_lt b 1
rw log_of_left_le_one hb
{ rw log_of_left_le_one hb, exact zero_le _}
exact zero_le _
cases n
rw log_zero_right
{ rw log_zero_right, exact zero_le _}
exact zero_le _
exact (pow_right_strict_mono hb).le_iff_le.1 ((pow_log_le_self hb $ succ_pos _).trans $ le_pow_clog hb _)
intros
simpa only [exists_or_distrib, ← odd, ← even] using even_or_odd n
intros
simpa only [pow_two] using le_sqrt
intros
cases n
cases n; refl
refl
refl
intros
cases x; simp only [map_none', map_some', pmap]
{ cases x; simp only [map_none', map_some', pmap] }
cases x
simp only [map_none', map_some', pmap]
simp only [map_none', map_some', pmap]
intros
split
rintro (rfl | rfl)
{ exact ⟨le_refl _, nat.le_succ _⟩ }
exact ⟨le_refl _, nat.le_succ _⟩
{ exact ⟨nat.le_succ _, le_refl _⟩ }
exact ⟨nat.le_succ _, le_refl _⟩
rintro ⟨h₁, h₂⟩
{ rintro ⟨h₁, h₂⟩, rcases eq_or_lt_of_le h₁ with rfl | h₁, { exact or.inl rfl }, { exact or.inr (le_antisymm h₂ h₁) } }
rcases eq_or_lt_of_le h₁ with rfl | h₁
{ exact or.inl rfl }
exact or.inl rfl
{ exact or.inr (le_antisymm h₂ h₁) }
exact or.inr (le_antisymm h₂ h₁)
intros
ext
ext; dsimp [pequiv.trans]; simp
ext; dsimp [pequiv.trans]
dsimp [pequiv.trans]
simp
intros
rw M.dest_map
congr
apply eq_of_drop_last_eq; simp
apply eq_of_drop_last_eq
simp
simp
ext1
apply h
intros
ext
simp only [supp, image_univ, mem_range, mem_set_of_eq]
split
split; intro h
intro h
apply @h (λ x, ∃ (y : P.B a), f y = x)
{ apply @h (λ x, ∃ (y : P.B a), f y = x), rw liftp_iff', intro, refine ⟨_,rfl⟩ }
rw liftp_iff'
intro
refine ⟨_,rfl⟩
intro h
simp only [liftp_iff']
{ simp only [liftp_iff'], cases h, subst x, tauto }
cases h
subst x
tauto
intros
by_cases hq : u.q = 0
let h := u.rq_eq
{ let h := u.rq_eq, rw [hr, hq, mul_zero, add_zero] at h, cases h }
rw [hr, hq, mul_zero, add_zero] at h
cases h
exact (nat.succ_pred_eq_of_pos (nat.pos_of_ne_zero hq)).symm
{ exact (nat.succ_pred_eq_of_pos (nat.pos_of_ne_zero hq)).symm }
intros
{ ext, simp only [aeval_X, aeval_tower_X], }
ext
simp only [aeval_X, aeval_tower_X]
intros
simp only [←monomial_zero_left, monomial_mul_monomial, add_zero]
intros
rw [(commute_X (1 : polynomial R)).add_pow, ← lcoeff_apply, linear_map.map_sum]
simp only [one_pow, mul_one, lcoeff_apply, ← C_eq_nat_cast, coeff_mul_C, nat.cast_id]
rw [finset.sum_eq_single k, coeff_X_pow_self, one_mul]
intros _ _
{ intros _ _, simp only [coeff_X_pow, boole_mul, ite_eq_right_iff, ne.def] {contextual := tt}, rintro h rfl, contradiction }
simp only [coeff_X_pow, boole_mul, ite_eq_right_iff, ne.def] {contextual := tt}
rintro h rfl
contradiction
simp only [coeff_X_pow_self, one_mul, not_lt, finset.mem_range]
{ simp only [coeff_X_pow_self, one_mul, not_lt, finset.mem_range], intro h, rw [nat.choose_eq_zero_of_lt h, nat.cast_zero], }
intro h
rw [nat.choose_eq_zero_of_lt h, nat.cast_zero]
intros
simpa only [pow_one] using nat_degree_C_mul_X_pow 1 a ha
intros
unfold nat_trailing_degree; rw h
unfold nat_trailing_degree
rw h
intros
induction k with k ih generalizing p
{ simp, }
simp
{ simp [ih], }
simp [ih]
intros
simp only [erase_lead, coeff_erase]
intros
induction k with k ih
{ simp, }
simp
{ simp [pow_succ', ←mul_assoc, ih], }
simp [pow_succ', ←mul_assoc, ih]
intros
rw [monomial_eq_C_mul_X, ←X_pow_mul, ←mul_assoc, coeff_mul_C, coeff_mul_X_pow]
intros
obtain ⟨r, rfl⟩ := set.mem_range.1 h
use monomial n r
simp only [coe_map_ring_hom, set.mem_univ, map_monomial, subsemiring.coe_top, eq_self_iff_true, and_self]
intros
split
intro hp
{ intro hp, rw ←smul_eq_zero_iff_eq (h.unit)⁻¹ at hp, have : (h.unit)⁻¹ • (p * q) = ((h.unit)⁻¹ • p) * q, { ext, simp only [units.smul_def, coeff_smul, coeff_mul, smul_eq_mul, mul_sum], refine sum_congr rfl (λ x hx, _), rw ←mul_assoc }, rwa [this, monic.mul_right_eq_zero_iff] at hp, exact monic_of_is_unit_leading_coeff_inv_smul _ }
rw ←smul_eq_zero_iff_eq (h.unit)⁻¹ at hp
have : (h.unit)⁻¹ • (p * q) = ((h.unit)⁻¹ • p) * q
ext
{ ext, simp only [units.smul_def, coeff_smul, coeff_mul, smul_eq_mul, mul_sum], refine sum_congr rfl (λ x hx, _), rw ←mul_assoc }
simp only [units.smul_def, coeff_smul, coeff_mul, smul_eq_mul, mul_sum]
refine sum_congr rfl (λ x hx, _)
rw ←mul_assoc
rwa [this, monic.mul_right_eq_zero_iff] at hp
exact monic_of_is_unit_leading_coeff_inv_smul _
rintro rfl
{ rintro rfl, simp }
simp
intros
rw [neg_eq_neg_one_mul, ←C_1, ←C_neg, reflect_C_mul, C_neg, C_1, ←neg_eq_neg_one_mul]
intros
apply q.P.W_cases _ x
intros a f' f
rw [recF_eq, q.P.W_dest'_W_mk, mvpfunctor.map_eq, append_fun_comp_split_fun, typevec.id_comp]
intros
rw [liftp_iff, ←abs_repr x]
cases repr x with a f
split
rintros ⟨a', f', abseq, hf⟩ u
{ rintros ⟨a', f', abseq, hf⟩ u, rw [supp_eq_of_is_uniform h, h _ _ _ _ abseq], rintros ⟨i, _, hi⟩, rw ←hi, apply hf }
rw [supp_eq_of_is_uniform h, h _ _ _ _ abseq]
rintros ⟨i, _, hi⟩
rw ←hi
apply hf
intro h'
refine ⟨a, f, rfl, λ i, h' _ _⟩
rw supp_eq_of_is_uniform h
exact ⟨i, mem_univ i, rfl⟩
intros
simp [b0, d0, sub_eq_add_neg]
intros
suffices : mk (q.num) ↑(q.denom) * mk ↑(q.denom) 1 = mk (q.num) 1
conv { for q [1] { rw ←(@num_denom q) }}
conv { for q [1] { rw ←(@num_denom q) }}
{ conv { for q [1] { rw ←(@num_denom q) }}, rwa [coe_int_eq_mk, coe_nat_eq_mk] }
{ conv { for q [1] { rw ←(@num_denom q) }}, rwa [coe_int_eq_mk, coe_nat_eq_mk] }
rwa [coe_int_eq_mk, coe_nat_eq_mk]
rwa [coe_int_eq_mk, coe_nat_eq_mk]
have : (q.denom : ℤ) ≠ 0
from ne_of_gt (by exact_mod_cast q.pos)
rw [(rat.mul_def this one_ne_zero), (mul_comm (q.denom : ℤ) 1), (div_mk_div_cancel_left this)]
intros
rw ← nonneg_iff_zero_le at ha hb ⊢; exact rat.nonneg_mul ha hb
rw ← nonneg_iff_zero_le at ha hb ⊢
exact rat.nonneg_mul ha hb
intros
change lim_zero ((f1 + g1) - _)
convert add_lim_zero hf hg using 1
simp only [sub_eq_add_neg, add_assoc]
rw add_comm (-f2)
simp only [add_assoc]
congr' 2
simp
intros
rw [← lim_mul_lim, lim_const]
simp [ennreal.of_real]; refl
simp [ennreal.of_real]
intros
split
intro h
{ intro h, rw [← or_assoc, or_iff_not_imp_right, or_iff_not_imp_right], intros hb ha, exact ⟨lt_top_of_mul_ne_top_left h.ne hb, lt_top_of_mul_ne_top_right h.ne ha⟩ }
rw [← or_assoc, or_iff_not_imp_right, or_iff_not_imp_right]
intros hb ha
exact ⟨lt_top_of_mul_ne_top_left h.ne hb, lt_top_of_mul_ne_top_right h.ne ha⟩
rintro (⟨ha, hb⟩|rfl|rfl); [exact mul_lt_top ha.ne hb.ne, simp, simp]
rintro (⟨ha, hb⟩|rfl|rfl)
{ rintro (⟨ha, hb⟩|rfl|rfl); [exact mul_lt_top ha.ne hb.ne, simp, simp] }
exact mul_lt_top ha.ne hb.ne
simp
simp
intros
rwa [←ereal.neg_neg b, ereal.neg_le, ereal.neg_neg]
intros
rw [nnreal.div_le_iff b0.ne.symm, div_mul_eq_mul_div, nnreal.le_div_iff_mul_le c0.ne.symm, mul_le_mul_left a0]
intros
obtain (hn | hz | hp) := sign_apply_eq r
{ rw hn, norm_num }
rw hn
norm_num
{ rw hz, exact inv_zero }
rw hz
exact inv_zero
{ rw hp, exact inv_one }
rw hp
exact inv_one
intros
rw [← not_le, not_iff_not, sqrt_eq_zero']
intros
apply s.cases_on; intro; simp
apply s.cases_on; intro
apply s.cases_on
intro
simp
intro
simp
intros
rw [←lift_rel_aux.swap, lift_rel_aux.ret_left]
intros
simp [ret]
intros
rw [set.ite, union_inter_distrib_right, diff_inter_self, inter_assoc, inter_self, union_empty]
intros
simp [range_subset_iff, funext_iff, mem_singleton]
intros
simp only [← not_nonempty_iff_eq_empty, preimage_coe_nonempty]
intros
refl
intros
rintro _ ⟨a, b, ha, hb, rfl⟩
{ rintro _ ⟨a, b, ha, hb, rfl⟩, exact mem_image2_of_mem (hs ha) (ht hb) }
exact mem_image2_of_mem (hs ha) (ht hb)
intros
{ ext, simp, }
ext
simp
intros
simp only [Ici_inter_Iio.symm, Ici_inter_Ici.symm, Iio_inter_Iio.symm]
simp only [Ici_inter_Iio.symm, Ici_inter_Ici.symm, Iio_inter_Iio.symm]; ac_refl
ac_refl
intros
convert @Ico_subset_Ico_iff (order_dual α) _ b₁ b₂ a₁ a₂ h₁; exact (@dual_Ico α _ _ _).symm
convert @Ico_subset_Ico_iff (order_dual α) _ b₁ b₂ a₁ a₂ h₁
{ convert @Ico_subset_Ico_iff (order_dual α) _ b₁ b₂ a₁ a₂ h₁; exact (@dual_Ico α _ _ _).symm }
exact (@dual_Ico α _ _ _).symm
exact (@dual_Ico α _ _ _).symm
intros
simp [le_refl]
intros
simp
intros
refine ⟨λ _ h, ⟨add_le_add_right h.1 _, add_le_add_right h.2 _⟩, λ _ _ _ _ h, add_right_cancel h, λ _ h, _⟩
obtain ⟨c, rfl⟩ := exists_add_of_le h.1
rw [mem_Icc, add_right_comm, add_le_add_iff_right, add_le_add_iff_right] at h
exact ⟨a + c, h, by rw add_right_comm⟩
intros
simp only [interval, preimage_const_add_Icc, min_sub_sub_right, max_sub_sub_right]
intros
refine diff_subset_comm.2 (λ x hx a ha, _)
simp only [mem_diff, mem_pi, mem_Union, not_exists, mem_preimage, not_and, not_not, eval_apply] at hx
exact hx.2 _ ha (hx.1 _ ha)
intros
simp
intros
simp only [←sInter_range, subtype.range_coe]
intros
induction acb with b H IH
constructor
intros y h
cases h with _ _ _ b' _ h' a
{ exact IH _ h' }
exact IH _ h'
{ exact aca _ }
exact aca _
intros
rw [← drop_fun_split_fun f g, H, ← last_fun_split_fun f g, H]
rw [← drop_fun_split_fun f g, H, ← last_fun_split_fun f g, H]; simp
simp
intros
ext i : 2
{ ext i : 2, induction i; simp only [typevec.prod.map,*,drop_fun_id], cases x, refl, refl }
induction i
induction i; simp only [typevec.prod.map,*,drop_fun_id]
simp only [typevec.prod.map,*,drop_fun_id]
cases x
refl
simp only [typevec.prod.map,*,drop_fun_id]
refl
intros
ext a
obtain ⟨k, rfl⟩ := zmod.int_cast_surjective a
let φ : ℤ →+* R := f.comp (int.cast_ring_hom (zmod n))
let ψ : ℤ →+* R := g.comp (int.cast_ring_hom (zmod n))
show φ k = ψ k
rw φ.ext_int ψ
intros
rcases ⟨h₁, h₂⟩ with ⟨⟨f₁, rfl⟩, ⟨f₂, rfl⟩⟩
{ rcases ⟨h₁, h₂⟩ with ⟨⟨f₁, rfl⟩, ⟨f₂, rfl⟩⟩, exact units_semiconj_of_translation_number_eq h }
exact units_semiconj_of_translation_number_eq h
intros
rcases hc₂ with ⟨v, hv₁, hv₂⟩
rw omega_limit_eq_Inter_inter _ _ _ hv₁
apply is_compact.nonempty_Inter_of_directed_nonempty_compact_closed
rintro ⟨u₁, hu₁⟩ ⟨u₂, hu₂⟩
{ rintro ⟨u₁, hu₁⟩ ⟨u₂, hu₂⟩, use ⟨u₁ ∩ u₂, inter_mem hu₁ hu₂⟩, split, all_goals { exact closure_mono (image2_subset (inter_subset_inter_left _ (by simp)) subset.rfl) }}
use ⟨u₁ ∩ u₂, inter_mem hu₁ hu₂⟩
split
exact closure_mono (image2_subset (inter_subset_inter_left _ (by simp)) subset.rfl)
all_goals { exact closure_mono (image2_subset (inter_subset_inter_left _ (by simp)) subset.rfl) }
exact closure_mono (image2_subset (inter_subset_inter_left _ (by simp)) subset.rfl)
intro u
{ intro u, have hn : (image2 ϕ (u ∩ v) s).nonempty, from nonempty.image2 (nonempty_of_mem (inter_mem u.prop hv₁)) hs, exact hn.mono subset_closure }
have hn : (image2 ϕ (u ∩ v) s).nonempty
from nonempty.image2 (nonempty_of_mem (inter_mem u.prop hv₁)) hs
exact hn.mono subset_closure
intro _
{ intro _, apply compact_of_is_closed_subset hc₁ is_closed_closure, calc _ ⊆ closure (image2 ϕ v s) : closure_mono (image2_subset (inter_subset_right _ _) subset.rfl) ... ⊆ c : hv₂ }
apply compact_of_is_closed_subset hc₁ is_closed_closure
calc _ ⊆ closure (image2 ϕ v s) : closure_mono (image2_subset (inter_subset_right _ _) subset.rfl) ... ⊆ c : hv₂
{ exact λ _, is_closed_closure }
exact λ _, is_closed_closure
intros
induction n with n ih
{ simp, }
simp
{ simp [pow_succ, pow_mul, ih, pow_card], }
simp [pow_succ, pow_mul, ih, pow_card]
intros
unfold angle
rw [←real.arccos_neg, norm_neg, inner_neg_right, neg_div]
intros
rw [dist_eq_norm_vsub V, dist_eq_norm_vsub V, dist_eq_norm_vsub V, ← vsub_sub_vsub_cancel_right]
exact norm_sub_eq_add_norm_of_angle_eq_pi h
intros
rw [support_eq_inter_preimage, subset_inter_iff, ← ext_chart_at_source I, ← image_subset_iff] at hs
cases hs with hse hsf
apply subset.antisymm
refine subset_inter (subset_inter (subset.trans hsf ball_subset_closed_ball) _) _
{ refine subset_inter (subset_inter (subset.trans hsf ball_subset_closed_ball) _) _, { rintro _ ⟨x, -, rfl⟩, exact mem_range_self _ }, { rw [(ext_chart_at I c).image_eq_target_inter_inv_preimage hse], exact inter_subset_right _ _ } }
{ rintro _ ⟨x, -, rfl⟩, exact mem_range_self _ }
rintro _ ⟨x, -, rfl⟩
exact mem_range_self _
rw [(ext_chart_at I c).image_eq_target_inter_inv_preimage hse]
{ rw [(ext_chart_at I c).image_eq_target_inter_inv_preimage hse], exact inter_subset_right _ _ }
exact inter_subset_right _ _
refine subset.trans (inter_subset_inter_left _ f.closed_ball_subset) _
{ refine subset.trans (inter_subset_inter_left _ f.closed_ball_subset) _, rw [(ext_chart_at I c).image_eq_target_inter_inv_preimage hse] }
rw [(ext_chart_at I c).image_eq_target_inter_inv_preimage hse]
intros
apply topological_space.generate_open.basic
simp only [exists_prop, mem_Union, mem_singleton_iff]
refine ⟨e, he, univ, is_open_univ, _⟩
simp only [set.univ_inter, set.preimage_univ]
intros
assume x hx
apply hG.lift_prop_within_at_of_lift_prop_at_of_mem_nhds (hG.lift_prop_at_symm_of_mem_maximal_atlas hQ he hx)
apply is_open.mem_nhds e.open_target hx
intros
refine ⟨h.1, _⟩
simp only [mfderiv, h, dif_pos] with mfld_simps
exact differentiable_within_at.has_fderiv_within_at h.2
intros
simp [unique_mdiff_on, unique_diff_on, unique_mdiff_within_at_iff_unique_diff_within_at]
intros
apply basic_smooth_bundle_core.smooth_const_section (tangent_bundle_core I M) 0
assume i j x hx
simp only [tangent_bundle_core, continuous_linear_map.map_zero] with mfld_simps
intros
rw [← normal_closure_eq_self ⁅H₁, H₂⁆, general_commutator_def, normal_closure_closure_eq_normal_closure]
intros
rw [←free_group.lift.symm_symm, ←(@lift' (free_group A) H _ _ _).symm_symm]
congr' 1
ext
refl
intros
rw [eq_comm, eq_mk'_iff_mul_eq, eq_comm]
intros
apply multiplicative.of_add.injective
rw [← order_of_of_add_eq_add_order_of, of_add_nsmul, of_add_nsmul, pow_eq_mod_order_of]
intros
rw [disjoint_iff_eq_or_eq, list.disjoint]
split
rintro h x hx hx'
{ rintro h x hx hx', specialize h x, rw [form_perm_apply_mem_eq_self_iff _ hl _ hx, form_perm_apply_mem_eq_self_iff _ hl' _ hx'] at h, rcases h with hl | hl'; linarith }
specialize h x
rw [form_perm_apply_mem_eq_self_iff _ hl _ hx, form_perm_apply_mem_eq_self_iff _ hl' _ hx'] at h
rcases h with hl | hl'; linarith
rcases h with hl | hl'
linarith
linarith
intros h x
{ intros h x, by_cases hx : x ∈ l; by_cases hx' : x ∈ l', { exact (h hx hx').elim }, all_goals { have := form_perm_eq_self_of_not_mem _ _ ‹_›, tauto } }
by_cases hx : x ∈ l; by_cases hx' : x ∈ l'
by_cases hx : x ∈ l
by_cases hx' : x ∈ l'
{ exact (h hx hx').elim }
exact (h hx hx').elim
have := form_perm_eq_self_of_not_mem _ _ ‹_›
all_goals { have := form_perm_eq_self_of_not_mem _ _ ‹_›, tauto }
tauto
by_cases hx' : x ∈ l'
have := form_perm_eq_self_of_not_mem _ _ ‹_›
tauto
have := form_perm_eq_self_of_not_mem _ _ ‹_›
tauto
intros
haveI : fact (fintype.card α).prime := ⟨h0⟩
obtain ⟨σ, hσ⟩ := exists_prime_order_of_dvd_card (fintype.card α) h1
have hσ1 : order_of (σ : perm α) = fintype.card α := (order_of_subgroup σ).trans hσ
have hσ2 : is_cycle ↑σ := is_cycle_of_prime_order'' h0 hσ1
have hσ3 : (σ : perm α).support = ⊤ := finset.eq_univ_of_card (σ : perm α).support ((order_of_is_cycle hσ2).symm.trans hσ1)
have hσ4 : subgroup.closure {↑σ, τ} = ⊤ := closure_prime_cycle_swap h0 hσ2 hσ3 h3
rw [eq_top_iff, ←hσ4, subgroup.closure_le, set.insert_subset, set.singleton_subset_iff]
exact ⟨subtype.mem σ, h2⟩
intros
obtain ⟨x, y, h4, h5⟩ := h3
obtain ⟨i, hi⟩ := h1.exists_pow_eq (mem_support.mp ((finset.ext_iff.mp h2 x).mpr (finset.mem_univ x))) (mem_support.mp ((finset.ext_iff.mp h2 y).mpr (finset.mem_univ y)))
rw [h5, ←hi]
refine closure_cycle_coprime_swap (nat.coprime.symm (h0.coprime_iff_not_dvd.mpr (λ h, h4 _))) h1 h2 x
cases h with m hm
rwa [hm, pow_mul, ←finset.card_univ, ←h2, ←order_of_is_cycle h1, pow_order_of_eq_one, one_pow, one_apply] at hi
intros
rw mem_cycle_factors_finset_iff at h
intros x hx
rwa [mem_support, ←h.right x hx, ←mem_support]
intros
rcases l with (_|⟨x, _|⟨y, tl⟩⟩)
{ simp }
simp
{ simp }
simp
{ simpa using form_perm_apply_head _ _ _ h }
simpa using form_perm_apply_head _ _ _ h
intros
ext1 x
have : option.map ⇑(remove_none σ) x = (swap none (σ none)) (σ x)
cases x
{ cases x, { simp }, { cases h : σ (some x), { simp [remove_none_none _ h], }, { have hn : σ (some x) ≠ none := by simp [h], have hσn : σ (some x) ≠ σ none := σ.injective.ne (by simp), simp [remove_none_some _ ⟨_, h⟩, ←h, swap_apply_of_ne_of_ne hn hσn] } } }
{ simp }
simp
cases h : σ (some x)
{ cases h : σ (some x), { simp [remove_none_none _ h], }, { have hn : σ (some x) ≠ none := by simp [h], have hσn : σ (some x) ≠ σ none := σ.injective.ne (by simp), simp [remove_none_some _ ⟨_, h⟩, ←h, swap_apply_of_ne_of_ne hn hσn] } }
{ simp [remove_none_none _ h], }
simp [remove_none_none _ h]
have hn : σ (some x) ≠ none := by simp [h]
{ have hn : σ (some x) ≠ none := by simp [h], have hσn : σ (some x) ≠ σ none := σ.injective.ne (by simp), simp [remove_none_some _ ⟨_, h⟩, ←h, swap_apply_of_ne_of_ne hn hσn] }
have hσn : σ (some x) ≠ σ none := σ.injective.ne (by simp)
simp [remove_none_some _ ⟨_, h⟩, ←h, swap_apply_of_ne_of_ne hn hσn]
simpa using this
intros
ext x
by_cases hx : x ∈ g.support
{ exact h' x hx }
exact h' x hx
rw [not_mem_support.mp hx, ←not_mem_support]
{ rw [not_mem_support.mp hx, ←not_mem_support], exact λ H, hx (h H) }
exact λ H, hx (h H)
intros
refine quotient_group.eq.trans _
rw [mul_one, subgroup.inv_mem_iff]
intros
simp [map]
let g1 := (⟨swap 0 2 * swap 0 1, mem_alternating_group.2 dec_trivial⟩ : alternating_group (fin 5))
let g2 := (⟨swap 0 4 * swap 1 3, mem_alternating_group.2 dec_trivial⟩ : alternating_group (fin 5))
have h5 : g1 * g2 * g1⁻¹ * g2⁻¹ = ⟨fin_rotate 5, fin_rotate_bit1_mem_alternating_group⟩
rw subtype.ext_iff
{ rw subtype.ext_iff, simp only [fin.coe_mk, subgroup.coe_mul, subgroup.coe_inv, fin.coe_mk], dec_trivial }
simp only [fin.coe_mk, subgroup.coe_mul, subgroup.coe_inv, fin.coe_mk]
dec_trivial
rw [eq_top_iff, ← normal_closure_fin_rotate_five]
refine normal_closure_le_normal _
rw [set.singleton_subset_iff, set_like.mem_coe, ← h5]
have h : g2 ∈ normal_closure {g2} := set_like.mem_coe.1 (subset_normal_closure (set.mem_singleton _))
exact mul_mem _ (subgroup.normal_closure_normal.conj_mem _ h g1) (inv_mem _ h)
intros
conv_lhs { rw ←zmod.nat_cast_zmod_val i }
rw [←r_one_pow, order_of_pow, order_of_r_one]
intros
simp only [subset_normal_closure, closure_le]
intros
apply_fun comap f at hf
rwa [comap_map_eq, comap_map_eq, sup_of_le_left hH, sup_of_le_left hK] at hf
intros
intros n g hg
simpa only [f.mem_ker, nsmul_eq_smul, f.map_nsmul, smul_eq_zero] using hg
intros
haveI : nonempty K := Kne.to_subtype
simp only [Sup_eq_supr', mem_supr_of_directed hK.directed_coe, set_coe.exists, subtype.coe_mk]
intros
simp [eq_bot_iff_forall, mem_closure_singleton]
intros
simpa only [mrange_eq_map] using map_inl ⊤
intros
rintros ⟨e, el, h⟩ ⟨e', el', h'⟩ H
simp only [to_affine_map_mk, equiv.coe_inj, linear_equiv.to_linear_map_inj] at H
congr
exacts [H.1, H.2]
intros
{ ext p, simp [homothety_apply] }
ext p
simp [homothety_apply]
intros
rw [collinear_iff_dim_le_one, vector_span_empty]
simp
intros
rw [one_div, homothety_inv_two]
intros
{ ext f x, refl, }
ext f x
refl
intros
rw [← nat.succ_pred_eq_of_pos (pos_iff_ne_zero.mpr hn), nat.succ_eq_add_one, add_comm, pow_add] at h
exact surjective.of_comp h
intros
rw [repr_self, finsupp.single_apply]
intros
simp_rw [matrix.to_bilin'_apply, matrix.dot_product, matrix.mul_vec, matrix.dot_product]
refine finset.sum_congr rfl (λ _ _, _)
rw finset.mul_sum
refine finset.sum_congr rfl (λ _ _, _)
rw ← mul_assoc
intros
apply le_antisymm
apply bsupr_le _
{ apply bsupr_le _, intros i hi y hy, refine ⟨dfinsupp.single i ⟨y, hy⟩, _⟩, rw [linear_map.comp_apply, filter_linear_map_apply, filter_single_pos _ _ hi], exact dfinsupp.sum_add_hom_single _ _ _, }
intros i hi y hy
refine ⟨dfinsupp.single i ⟨y, hy⟩, _⟩
rw [linear_map.comp_apply, filter_linear_map_apply, filter_single_pos _ _ hi]
exact dfinsupp.sum_add_hom_single _ _ _
rintros x ⟨v, rfl⟩
{ rintros x ⟨v, rfl⟩, refine dfinsupp_sum_add_hom_mem _ _ _ (λ i hi, _), refine mem_supr_of_mem i _, by_cases hp : p i, { simp [hp], }, { simp [hp] }, }
refine dfinsupp_sum_add_hom_mem _ _ _ (λ i hi, _)
refine mem_supr_of_mem i _
by_cases hp : p i
{ simp [hp], }
simp [hp]
{ simp [hp] }
simp [hp]
intros
ext i
{ ext i, rw basis.apply_eq_iff, ext j, rw [h.basis_repr_apply, coeffs_apply, h.eval, finsupp.single_apply], convert if_congr eq_comm rfl rfl }
rw basis.apply_eq_iff
ext j
rw [h.basis_repr_apply, coeffs_apply, h.eval, finsupp.single_apply]
convert if_congr eq_comm rfl rfl
intros
have := dim_quotient_add_dim s
rw [← finrank_eq_dim, ← finrank_eq_dim, ← finrank_eq_dim] at this
exact_mod_cast this
intros
erw [set.union_eq_Union, supported_Union, supr_bool_eq]
erw [set.union_eq_Union, supported_Union, supr_bool_eq]; refl
refl
intros
rw [finsupp_prod_lequiv, linear_equiv.coe_mk, finsupp_prod_equiv, finsupp.curry_apply]
intros
apply @linear_independent_comp_subtype_disjoint _ _ _ id
intros
rintros (i | i) (j | j) hij
{ exact ha (ne_of_apply_ne _ hij) }
exact ha (ne_of_apply_ne _ hij)
{ refl }
refl
{ refl }
refl
{ exact hd (ne_of_apply_ne _ hij) }
exact hd (ne_of_apply_ne _ hij)
intros
by_cases h : is_unit A.det
exact or.inl ⟨nonsing_inv_mul _ h, mul_nonsing_inv _ h⟩
{ exact or.inl ⟨nonsing_inv_mul _ h, mul_nonsing_inv _ h⟩ }
{ exact or.inr (nonsing_inv_apply_not_is_unit _ h) }
exact or.inr (nonsing_inv_apply_not_is_unit _ h)
intros
simp_rw [linear_map.to_matrix_apply, basis.reindex_range_self, basis.reindex_range_repr]
intros
simpa only [← M.det_transpose, ← mul_vec_transpose] using exists_mul_vec_eq_zero_iff
intros
have A : (list_transvec_row M).length = r
simp [list_transvec_row]
simp [list_transvec_row]
rw [← list.take_length (list_transvec_row M), A]
simpa using mul_list_transvec_row_last_col_take M i le_rfl
intros
rw [← update_snoc_last x m (c • x), f.map_smul, update_snoc_last]
intros
refine pi_ext (λ i x, _)
convert linear_map.congr_fun (h i) x
intros
ext
ext; simp
simp
intros
simp [linear_proj_of_is_compl]
intros
simp [sub_eq_add_neg]
intros
{ rw ← v.equiv_fun_symm_apply, refl }
rw ← v.equiv_fun_symm_apply
refl
intros
split_ifs; simp
{ split_ifs; simp }
split_ifs
simp
simp
intros
simp only [ltensor, rtensor, ← map_comp, id_comp, comp_id]
intros
rw [@iff_def (¬ a), @iff_def (¬ b)]; exact and_congr decidable.not_imp_comm imp_not_comm
rw [@iff_def (¬ a), @iff_def (¬ b)]
exact and_congr decidable.not_imp_comm imp_not_comm
intros
induction hbc
assumption
case refl_trans_gen.refl { assumption }
case refl_trans_gen.tail : c d hbc hcd hac { exact hac.tail hcd }
intros
rw [outer_measure.pi, le_bounded_by']
split
intros h s hs
{ intros h s hs, refine (h _ hs).trans_eq (pi_premeasure_pi hs) }
refine (h _ hs).trans_eq (pi_premeasure_pi hs)
intros h s hs
{ intros h s hs, refine le_trans (n.mono $ subset_pi_eval_image univ s) (h _ _), simp [univ_pi_nonempty_iff, hs] }
refine le_trans (n.mono $ subset_pi_eval_image univ s) (h _ _)
simp [univ_pi_nonempty_iff, hs]
intros
apply measurable_of_measurable_coe
intros s hs
simp_rw [map_apply measurable_prod_mk_right hs]
exact measurable_measure_prod_mk_right hs
intros
rw ← prod_swap at hf
{ rw ← prod_swap at hf, rw [← lintegral_map' hf measurable_swap, prod_swap] }
rw [← lintegral_map' hf measurable_swap, prod_swap]
intros
have hwuv : s ((w ∩ u) Δ (w ∩ v)) = 0
refine subset_positive_null_set (hu.union hv) ((hw.inter hu).symm_diff (hw.inter hv)) (hu.symm_diff hv) (restrict_le_restrict_union _ _ hu hsu hv hsv) hs _ _
{ refine subset_positive_null_set (hu.union hv) ((hw.inter hu).symm_diff (hw.inter hv)) (hu.symm_diff hv) (restrict_le_restrict_union _ _ hu hsu hv hsv) hs _ _, { exact symm_diff_le_sup u v }, { rintro x (⟨⟨hxw, hxu⟩, hx⟩ | ⟨⟨hxw, hxv⟩, hx⟩); rw [set.mem_inter_eq, not_and] at hx, { exact or.inl ⟨hxu, hx hxw⟩ }, { exact or.inr ⟨hxv, hx hxw⟩ } } }
{ exact symm_diff_le_sup u v }
exact symm_diff_le_sup u v
rintro x (⟨⟨hxw, hxu⟩, hx⟩ | ⟨⟨hxw, hxv⟩, hx⟩); rw [set.mem_inter_eq, not_and] at hx
rintro x (⟨⟨hxw, hxu⟩, hx⟩ | ⟨⟨hxw, hxv⟩, hx⟩)
{ rintro x (⟨⟨hxw, hxu⟩, hx⟩ | ⟨⟨hxw, hxv⟩, hx⟩); rw [set.mem_inter_eq, not_and] at hx, { exact or.inl ⟨hxu, hx hxw⟩ }, { exact or.inr ⟨hxv, hx hxw⟩ } }
rw [set.mem_inter_eq, not_and] at hx
{ exact or.inl ⟨hxu, hx hxw⟩ }
exact or.inl ⟨hxu, hx hxw⟩
rw [set.mem_inter_eq, not_and] at hx
{ exact or.inr ⟨hxv, hx hxw⟩ }
exact or.inr ⟨hxv, hx hxw⟩
obtain ⟨huv, hvu⟩ := of_diff_eq_zero_of_symm_diff_eq_zero_positive (hw.inter hu) (hw.inter hv) (restrict_le_restrict_subset _ _ hu hsu (w.inter_subset_right u)) (restrict_le_restrict_subset _ _ hv hsv (w.inter_subset_right v)) hwuv
rw [← of_diff_of_diff_eq_zero (hw.inter hu) (hw.inter hv) hvu, huv, zero_add]
intros
rw [← lintegral_mk, mk_coe_fn]
intros
rw [condexp_ind_smul, condexp_ind_smul, to_span_singleton_smul', (to_span_singleton ℝ x).smul_comp_LpL_apply c ↑(condexp_L2 ℝ hm (indicator_const_Lp 2 hs hμs (1 : ℝ)))]
intros
simp_rw condexp_L1_eq hf
rw set_integral_condexp_L1_clm (hf.to_L1 f) hs
exact set_integral_congr_ae (hm s hs) ((hf.coe_fn_to_L1).mono (λ x hx hxs, hx))
intros
simp only [has_finite_integral_iff_norm, edist_dist, dist_zero_right]
intros
simp_rw [mem_Lp_iff_snorm_lt_top, snorm_ae_eq_fun]
{ simp_rw [mem_Lp_iff_snorm_lt_top, snorm_ae_eq_fun], exact snorm_inner_lt_top f g, }
exact snorm_inner_lt_top f g
intros
simp_rw [edist, dist, norm_def, ennreal.of_real_to_real (snorm_ne_top _)]
exact snorm_congr_ae (coe_fn_sub _ _)
intros
simp [snorm', hp0_lt]
intros
rw [snorm']
refine ennreal.rpow_le_rpow _ (one_div_nonneg.2 hq)
refine lintegral_mono_ae (h.mono $ λ x hx, _)
exact ennreal.rpow_le_rpow (ennreal.coe_le_coe.2 hx) hq
intros
rw [snorm_congr_ae hf.ae_eq_mk, snorm_congr_ae (ae_eq_of_ae_eq_trim hf.ae_eq_mk)]
exact snorm_trim hm hf.measurable_mk
intros
simpa using @integrable_on_finset_Union _ _ _ _ _ _ f μ finset.univ t
intros
rw [← hderiv, integral_deriv_eq_sub hdiff]
rw hderiv
exact hcont.interval_integrable
intros
by_cases hc : c = 0; simp [hc]
by_cases hc : c = 0
simp [hc]
simp [hc]
intros
simp only [sub_eq_add_neg, ← integral_symm, integral_interval_add_interval_comm hab hcd.symm (hac.trans hcd)]
intros
ext1 t ht
rw [restrict_apply ht, with_density_apply _ ht, with_density_apply _ (ht.inter hs), restrict_restrict ht]
intros
simp_rw [ennreal.tsum_eq_supr_nat' (tendsto_add_at_top_nat 1), sum_eapprox_diff, supr_eapprox_apply f hf a]
intros
by_cases hf_zero : ∫⁻ a, (f a) ^ p ∂μ = 0
refine le_trans (le_of_eq _) (zero_le _)
{ refine le_trans (le_of_eq _) (zero_le _), exact lintegral_mul_eq_zero_of_lintegral_rpow_eq_zero hpq.pos hf hf_zero, }
exact lintegral_mul_eq_zero_of_lintegral_rpow_eq_zero hpq.pos hf hf_zero
by_cases hg_zero : ∫⁻ a, (g a) ^ q ∂μ = 0
refine le_trans (le_of_eq _) (zero_le _)
{ refine le_trans (le_of_eq _) (zero_le _), rw mul_comm, exact lintegral_mul_eq_zero_of_lintegral_rpow_eq_zero hpq.symm.pos hg hg_zero, }
rw mul_comm
exact lintegral_mul_eq_zero_of_lintegral_rpow_eq_zero hpq.symm.pos hg hg_zero
by_cases hf_top : ∫⁻ a, (f a) ^ p ∂μ = ⊤
exact lintegral_mul_le_Lp_mul_Lq_of_ne_zero_of_eq_top hpq.pos hpq.symm.nonneg hf_top hg_zero
{ exact lintegral_mul_le_Lp_mul_Lq_of_ne_zero_of_eq_top hpq.pos hpq.symm.nonneg hf_top hg_zero, }
by_cases hg_top : ∫⁻ a, (g a) ^ q ∂μ = ⊤
rw [mul_comm, mul_comm ((∫⁻ (a : α), (f a) ^ p ∂μ) ^ (1 / p))]
{ rw [mul_comm, mul_comm ((∫⁻ (a : α), (f a) ^ p ∂μ) ^ (1 / p))], exact lintegral_mul_le_Lp_mul_Lq_of_ne_zero_of_eq_top hpq.symm.pos hpq.nonneg hg_top hf_zero, }
exact lintegral_mul_le_Lp_mul_Lq_of_ne_zero_of_eq_top hpq.symm.pos hpq.nonneg hg_top hf_zero
exact ennreal.lintegral_mul_le_Lp_mul_Lq_of_ne_zero_of_ne_top hpq hf hg hf_top hg_top hf_zero hg_zero
intros
apply norm_set_integral_le_of_norm_le_const_ae hs
have A : ∀ᵐ (x : α) ∂μ, x ∈ s → ∥ae_measurable.mk f hfm x∥ ≤ C
filter_upwards [hC, hfm.ae_mem_imp_eq_mk]
{ filter_upwards [hC, hfm.ae_mem_imp_eq_mk], assume a h1 h2 h3, rw [← h2 h3], exact h1 h3 }
assume a h1 h2 h3
rw [← h2 h3]
exact h1 h3
have B : measurable_set {x | ∥(hfm.mk f) x∥ ≤ C} := hfm.measurable_mk.norm measurable_set_Iic
filter_upwards [hfm.ae_eq_mk, (ae_restrict_iff B).2 A]
assume a h1 h2
rwa h1
intros
cases (pi s t).eq_empty_or_nonempty with h h
{ simp [h] }
simp [h]
simp [measurable_set_pi_of_nonempty hs, h, ← not_nonempty_iff_eq_empty]
{ simp [measurable_set_pi_of_nonempty hs, h, ← not_nonempty_iff_eq_empty] }
intros
by_cases p; simp [h, measurable_set.empty]; apply measurable_set.univ
by_cases p; simp [h, measurable_set.empty]
by_cases p
{ by_cases p; simp [h, measurable_set.empty]; apply measurable_set.univ }
simp [h, measurable_set.empty]
simp [h, measurable_set.empty]
intros
simp [apply_eq_coe_to_fun, μ.sup_disjoint' _ _ h]
intros
rcases index_elim hK hV with ⟨s, h1s, h2s⟩
rw [← h2s]
apply nat.Inf_le
rw [mem_image]
refine ⟨s.map (equiv.mul_right g⁻¹).to_embedding, _, finset.card_map _⟩
simp only [mem_set_of_eq]
{ simp only [mem_set_of_eq], refine subset.trans (image_subset _ h1s) _, rintro _ ⟨g₁, ⟨_, ⟨g₂, rfl⟩, ⟨_, ⟨hg₂, rfl⟩, hg₁⟩⟩, rfl⟩, simp only [mem_preimage] at hg₁, simp only [exists_prop, mem_Union, finset.mem_map, equiv.coe_mul_right, exists_exists_and_eq_and, mem_preimage, equiv.to_embedding_apply], refine ⟨_, hg₂, _⟩, simp only [mul_assoc, hg₁, inv_mul_cancel_left] }
refine subset.trans (image_subset _ h1s) _
rintro _ ⟨g₁, ⟨_, ⟨g₂, rfl⟩, ⟨_, ⟨hg₂, rfl⟩, hg₁⟩⟩, rfl⟩
simp only [mem_preimage] at hg₁
simp only [exists_prop, mem_Union, finset.mem_map, equiv.coe_mul_right, exists_exists_and_eq_and, mem_preimage, equiv.to_embedding_apply]
refine ⟨_, hg₂, _⟩
simp only [mul_assoc, hg₁, inv_mul_cancel_left]
intros
simp only [volume_pi_Ico, ennreal.to_real_prod, ennreal.to_real_of_real (sub_nonneg.2 (h _))]
intros
rw [← measure_theory.measure.measure_univ_eq_zero, ← coe_measure_univ_nnreal]
norm_cast
intros
simp [eventually_le_antisymm_iff, ae_le_set, diff_diff_right, diff_diff, diff_eq_empty.2 (set.subset_union_right _ _)]
intros
refine (map_of_function_le _).antisymm (λ s, _)
simp only [of_function_apply, map_apply, le_infi_iff]
intros t ht
refine infi_le_of_le (λ n, (range f)ᶜ ∪ f '' (t n)) (infi_le_of_le _ _)
rw [← union_Union, ← inter_subset, ← image_preimage_eq_inter_range, ← image_Union]
{ rw [← union_Union, ← inter_subset, ← image_preimage_eq_inter_range, ← image_Union], exact image_subset _ ht }
exact image_subset _ ht
refine ennreal.tsum_le_tsum (λ n, le_of_eq _)
{ refine ennreal.tsum_le_tsum (λ n, le_of_eq _), simp [hf.preimage_image] }
simp [hf.preimage_image]
intros
{ rw [infi, Inf_apply' hs], simp only [infi_range] }
rw [infi, Inf_apply' hs]
simp only [infi_range]
intros
refine le_antisymm (infi_le_of_le a $ binfi_le b (subset.refl _)) (le_infi $ λ a', le_infi $ λ b', le_infi $ λ h, ennreal.coe_le_coe.2 _)
cases le_or_lt b a with ab ab
rw real.to_nnreal_of_nonpos (sub_nonpos.2 (f.mono ab))
{ rw real.to_nnreal_of_nonpos (sub_nonpos.2 (f.mono ab)), apply zero_le, }
apply zero_le
cases (Ioc_subset_Ioc_iff ab).1 h with h₁ h₂
exact real.to_nnreal_le_to_nnreal (sub_le_sub (f.mono h₁) (f.mono h₂))
intros
ext1 i hi
rw [with_densityᵥ_apply (hf.add hg) hi, vector_measure.add_apply, with_densityᵥ_apply hf hi, with_densityᵥ_apply hg hi]
simp_rw [pi.add_apply]
rw integral_add; rw ← integrable_on_univ
rw integral_add
rw ← integrable_on_univ
{ exact hf.integrable_on.restrict measurable_set.univ }
exact hf.integrable_on.restrict measurable_set.univ
rw ← integrable_on_univ
{ exact hg.integrable_on.restrict measurable_set.univ }
exact hg.integrable_on.restrict measurable_set.univ
intros
simp [map]
intros
ext x
rw [ppow_apply (nat.succ_pos k), pow_succ]
induction k; simp
induction k
simp
simp
intros
intro I'
obtain ⟨⟨I, hI⟩, rfl⟩ := class_group.mk0_surjective I'
obtain ⟨J, mk0_eq_mk0, J_dvd⟩ := exists_mk0_eq_mk0 L bS adm h ⟨I, hI⟩
exact ⟨⟨J, J_dvd⟩, mk0_eq_mk0.symm⟩
intros
simp [h, divisors_prime_pow]
intros
simp [finite_int_iff, ne.symm (ne_of_lt (p_prime.1.one_lt))]
intros
{ rw ← zmod_cast_comp_to_zmod_pow _ _ h, refl }
rw ← zmod_cast_comp_to_zmod_pow _ _ h
refl
intros
obtain ⟨m, n, ht1, ht2, ht3, ht4⟩ := pythagorean_triple.coprime_classification.mp (and.intro h h_coprime)
cases le_or_lt 0 m with hm hm
use [m, n]
{ use [m, n], cases ht1 with h_odd h_even, { apply and.intro h_odd.1, apply and.intro h_odd.2, cases ht2 with h_pos h_neg, { apply and.intro h_pos (and.intro ht3 (and.intro ht4 hm)) }, { exfalso, revert h_pos, rw h_neg, exact imp_false.mpr (not_lt.mpr (neg_nonpos.mpr (add_nonneg (sq_nonneg m) (sq_nonneg n)))) } }, exfalso, rcases h_even with ⟨rfl, -⟩, rw [mul_assoc, int.mul_mod_right] at h_parity, exact zero_ne_one h_parity }
cases ht1 with h_odd h_even
apply and.intro h_odd.1
{ apply and.intro h_odd.1, apply and.intro h_odd.2, cases ht2 with h_pos h_neg, { apply and.intro h_pos (and.intro ht3 (and.intro ht4 hm)) }, { exfalso, revert h_pos, rw h_neg, exact imp_false.mpr (not_lt.mpr (neg_nonpos.mpr (add_nonneg (sq_nonneg m) (sq_nonneg n)))) } }
apply and.intro h_odd.2
cases ht2 with h_pos h_neg
{ apply and.intro h_pos (and.intro ht3 (and.intro ht4 hm)) }
apply and.intro h_pos (and.intro ht3 (and.intro ht4 hm))
exfalso
{ exfalso, revert h_pos, rw h_neg, exact imp_false.mpr (not_lt.mpr (neg_nonpos.mpr (add_nonneg (sq_nonneg m) (sq_nonneg n)))) }
revert h_pos
rw h_neg
exact imp_false.mpr (not_lt.mpr (neg_nonpos.mpr (add_nonneg (sq_nonneg m) (sq_nonneg n))))
exfalso
rcases h_even with ⟨rfl, -⟩
rw [mul_assoc, int.mul_mod_right] at h_parity
exact zero_ne_one h_parity
use [-m, -n]
{ use [-m, -n], cases ht1 with h_odd h_even, { rw [neg_sq m], rw [neg_sq n], apply and.intro h_odd.1, split, { rw h_odd.2, ring }, cases ht2 with h_pos h_neg, { apply and.intro h_pos, split, { delta int.gcd, rw [int.nat_abs_neg, int.nat_abs_neg], exact ht3 }, { rw [int.neg_mod_two, int.neg_mod_two], apply and.intro ht4, linarith } }, { exfalso, revert h_pos, rw h_neg, exact imp_false.mpr (not_lt.mpr (neg_nonpos.mpr (add_nonneg (sq_nonneg m) (sq_nonneg n)))) } }, exfalso, rcases h_even with ⟨rfl, -⟩, rw [mul_assoc, int.mul_mod_right] at h_parity, exact zero_ne_one h_parity }
cases ht1 with h_odd h_even
rw [neg_sq m]
{ rw [neg_sq m], rw [neg_sq n], apply and.intro h_odd.1, split, { rw h_odd.2, ring }, cases ht2 with h_pos h_neg, { apply and.intro h_pos, split, { delta int.gcd, rw [int.nat_abs_neg, int.nat_abs_neg], exact ht3 }, { rw [int.neg_mod_two, int.neg_mod_two], apply and.intro ht4, linarith } }, { exfalso, revert h_pos, rw h_neg, exact imp_false.mpr (not_lt.mpr (neg_nonpos.mpr (add_nonneg (sq_nonneg m) (sq_nonneg n)))) } }
rw [neg_sq n]
apply and.intro h_odd.1
split
rw h_odd.2
{ rw h_odd.2, ring }
ring
cases ht2 with h_pos h_neg
apply and.intro h_pos
{ apply and.intro h_pos, split, { delta int.gcd, rw [int.nat_abs_neg, int.nat_abs_neg], exact ht3 }, { rw [int.neg_mod_two, int.neg_mod_two], apply and.intro ht4, linarith } }
split
delta int.gcd
{ delta int.gcd, rw [int.nat_abs_neg, int.nat_abs_neg], exact ht3 }
rw [int.nat_abs_neg, int.nat_abs_neg]
exact ht3
rw [int.neg_mod_two, int.neg_mod_two]
{ rw [int.neg_mod_two, int.neg_mod_two], apply and.intro ht4, linarith }
apply and.intro ht4
linarith
exfalso
{ exfalso, revert h_pos, rw h_neg, exact imp_false.mpr (not_lt.mpr (neg_nonpos.mpr (add_nonneg (sq_nonneg m) (sq_nonneg n)))) }
revert h_pos
rw h_neg
exact imp_false.mpr (not_lt.mpr (neg_nonpos.mpr (add_nonneg (sq_nonneg m) (sq_nonneg n))))
exfalso
rcases h_even with ⟨rfl, -⟩
rw [mul_assoc, int.mul_mod_right] at h_parity
exact zero_ne_one h_parity
intros
simp [to_complex_def]
intros
rw sdiff_sup
apply sdiff_unique
rw [←inf_sup_left, sup_sdiff_self_right, inf_sdiff_sup_right]
{ rw [←inf_sup_left, sup_sdiff_self_right, inf_sdiff_sup_right] }
rw [inf_assoc, @inf_comm _ _ z, inf_assoc, inf_sdiff_self_left, inf_bot_eq, inf_bot_eq]
{ rw [inf_assoc, @inf_comm _ _ z, inf_assoc, inf_sdiff_self_left, inf_bot_eq, inf_bot_eq] }
intros
simp only [disjoint_iff, inf_sup_right, sup_eq_bot_iff]
intros
{ cases x, simpa using h, refl, }
cases x
simpa using h
refl
intros
exact is_glb_singleton.union hs
intros
refine eq.trans (congr rfl (set.ext (λ x, _))) (Sup_compact_le_eq ⊤)
exact (and_iff_left le_top).symm
intros
refine eq_of_forall_ge_iff (λ c, _)
simp only [sup_le_iff, supr_le_iff]
refine ⟨λ h, _, λ h, ⟨h _, λ i, h _⟩⟩
rintro (_|i)
exacts [h.1, h.2 i]
intros
rw ←supr_sup_eq
congr' 1 with i
split_ifs with h; simp [h]
split_ifs with h
simp [h]
simp [h]
intros
haveI := unique_prop hp; exact supr_unique
haveI := unique_prop hp
exact supr_unique
intros
simp only [directed_on, set.ball_image_iff, set.bex_image_iff, order.preimage]
intros
simp [hlb.tendsto_right_iff, hla.eventually_iff]
intros
simp [filter.frequently, not_forall]
intros
{ rw [comap_top], exact le_top }
rw [comap_top]
exact le_top
intros
refine le_antisymm (le_map $ λ s hs, _) (le_seq $ λ s hs t ht, _)
rw ← singleton_seq
{ rw ← singleton_seq, apply seq_mem_seq _ hs, exact singleton_mem_pure }
apply seq_mem_seq _ hs
exact singleton_mem_pure
refine sets_of_superset (map g f) (image_mem_map ht) _
{ refine sets_of_superset (map g f) (image_mem_map ht) _, rintro b ⟨a, ha, rfl⟩, exact ⟨g, hs, a, ha, rfl⟩ }
rintro b ⟨a, ha, rfl⟩
exact ⟨g, hs, a, ha, rfl⟩
intros
erw [comap_inf, filter.comap_comap, filter.comap_comap]
intros
simp [part.ωSup] at h
split_ifs at h
have h' := classical.some_spec h_1
{ have h' := classical.some_spec h_1, rw ← eq_some_iff at h, rw ← h, exact h' }
rw ← eq_some_iff at h
rw ← h
exact h'
{ rcases h with ⟨ ⟨ ⟩ ⟩ }
rcases h with ⟨ ⟨ ⟩ ⟩
intros
simp [sup_sdiff, sdiff_inf, sup_comm, (Δ)]
intros
refine (λ S f hfs, h_indep S (λ x hxS, _))
simp_rw hms x
exact measurable_set_generate_from (hfs x hxS)
intros
rw [root, lift_mk, eval₂_X]
intros
simp only [is_algebraic, alg_hom.injective_iff, not_forall, and.comm, exists_prop]
intros
simpa only [is_coprime_comm] using is_coprime.prod_left_iff
intros
{ rw is_coprime_comm at H1 H2 ⊢, exact H1.mul_left H2 }
rw is_coprime_comm at H1 H2 ⊢
exact H1.mul_left H2
intros
have key : associated (multiset.repeat p m).prod (multiset.repeat q n).prod
rw [multiset.prod_repeat, multiset.prod_repeat, associated]
{ rw [multiset.prod_repeat, multiset.prod_repeat, associated], refine ⟨u * v⁻¹, _⟩, simp only [units.coe_mul], rw [mul_left_comm, ← mul_assoc, h, mul_right_comm, units.mul_inv, one_mul], }
refine ⟨u * v⁻¹, _⟩
simp only [units.coe_mul]
rw [mul_left_comm, ← mul_assoc, h, mul_right_comm, units.mul_inv, one_mul]
have := multiset.card_eq_card_of_rel (unique_factorization_monoid.factors_unique _ _ key)
{ simpa only [multiset.card_repeat] }
simpa only [multiset.card_repeat]
all_goals { intros x hx, replace hx := multiset.eq_of_mem_repeat hx, unfreezingI { subst hx, assumption } }
intros x hx
replace hx := multiset.eq_of_mem_repeat hx
unfreezingI { subst hx, assumption }
intros x hx
replace hx := multiset.eq_of_mem_repeat hx
subst hx
unfreezingI { subst hx, assumption }
assumption
intros
apply coe_to_submodule_injective
simp only [coe_mul, coe_span_singleton, span_mul_span, singleton_mul_singleton]
intros
rcases I with ⟨I, a, a_nonzero, hI⟩
use [a, a_nonzero]
intros b hb
obtain ⟨b', b'_mem, hb'⟩ := submodule.mem_map.mp hb
obtain ⟨x, hx⟩ := hI b' b'_mem
use x
erw [←g.commutes, hx, g.map_smul, hb']
intros
have : ¬ _ := λ h, hf ⟨exists_pair_ne R, mul_comm, h⟩
simp_rw is_unit_iff_exists_inv
push_neg at ⊢ this
obtain ⟨x, hx, not_unit⟩ := this
exact ⟨x, hx, not_unit⟩
intros
erw [submodule.one_eq_range, linear_map.range_id]
intros
refine quotient.maximal_of_is_field _ _
haveI : is_prime (I.comap (algebra_map R S)) := comap_is_prime _ _
exact is_field_of_is_integral_of_is_field (is_integral_quotient_of_is_integral hRS) algebra_map_quotient_injective (by rwa ← quotient.maximal_ideal_iff_is_field_quotient)
intros
apply nat.dvd_antisymm; rw ← int.coe_nat_dvd
apply nat.dvd_antisymm
rw ← int.coe_nat_dvd
rw int.nat_abs_dvd
{ rw int.nat_abs_dvd, exact int.dvd_gcd (euclidean_domain.gcd_dvd_left _ _) (euclidean_domain.gcd_dvd_right _ _) }
exact int.dvd_gcd (euclidean_domain.gcd_dvd_left _ _) (euclidean_domain.gcd_dvd_right _ _)
rw ← int.coe_nat_dvd
rw int.dvd_nat_abs
{ rw int.dvd_nat_abs, exact euclidean_domain.dvd_gcd (int.gcd_dvd_left _ _) (int.gcd_dvd_right _ _) }
exact euclidean_domain.dvd_gcd (int.gcd_dvd_left _ _) (int.gcd_dvd_right _ _)
intros
ext y
rw subalgebra.mem_map
split
rintros ⟨x, hx, rfl⟩
{ rintros ⟨x, hx, rfl⟩, exact is_integral_alg_hom f hx }
exact is_integral_alg_hom f hx
intro hy
{ intro hy, use [f.symm y, is_integral_alg_hom (f.symm : B →ₐ[R] A) hy], simp }
use [f.symm y, is_integral_alg_hom (f.symm : B →ₐ[R] A) hy]
simp
intros
refine ⟨λ h, set.disjoint_left.1 h (mem_powers _), λ h, (disjoint_iff).mpr (eq_bot_iff.mpr _)⟩
rintros x ⟨⟨n, rfl⟩, hx'⟩
rw [← hI] at hx'
exact absurd (hI ▸ mem_radical_of_pow_mem hx' : y ∈ I.carrier) h
intros
convert congr_arg (ideal.map _) at_prime.comap_maximal_ideal.symm
rw map_comap I.prime_compl
intros
{ rw [← nat.cast_zero, eq_coe_iff], simpa }
rw [← nat.cast_zero, eq_coe_iff]
simpa
intros
rw [is_noetherian_iff_well_founded, well_founded.monotone_chain_condition]
intros
simp only [frange, exists_prop, mem_support_iff, finset.mem_image, ne.def]
exact ⟨n, h, rfl⟩
intros
rw [U_eq_X_mul_U_add_T, add_comm (X * U R n), add_sub_cancel]
intros
refine ⟨λ h, h.trans (dvd.intro_left _ q.eq_C_content_mul_prim_part.symm), λ h, _⟩
rcases h with ⟨r, rfl⟩
apply dvd.intro _
rw [prim_part_mul hq, hp.prim_part_eq]
intros
suffices : ideal.span ({X} : set (power_series R)) = (constant_coeff R).ker
{ rw this, exact ring_hom.ker_is_prime _ }
rw this
exact ring_hom.ker_is_prime _
apply ideal.ext
intro φ
rw [ring_hom.mem_ker, ideal.mem_span_singleton, X_dvd_iff]
intros
rw [← monomial_zero_eq_C_apply, coeff_monomial_same 0 a]
intros
{ ghost_calc x y, rintro ⟨⟩; ghost_simp [mul_assoc] }
ghost_calc x y
rintro ⟨⟩
rintro ⟨⟩; ghost_simp [mul_assoc]
ghost_simp [mul_assoc]
ghost_simp [mul_assoc]
intros
obtain ⟨φ, hf⟩ := hf
unfreezingI {obtain ⟨φ, hf⟩ := hf}
ext n
simp only [map_coeff, hf, map_aeval, peval, uncurry]
apply eval₂_hom_congr (ring_hom.ext_int _ _) _ rfl
try { ext ⟨i, k⟩, fin_cases i }
ext ⟨i, k⟩
fin_cases i
all_goals { simp only [map_coeff, matrix.cons_val_zero, matrix.head_cons, matrix.cons_val_one] }
simp only [map_coeff, matrix.cons_val_zero, matrix.head_cons, matrix.cons_val_one]
simp only [map_coeff, matrix.cons_val_zero, matrix.head_cons, matrix.cons_val_one]
intros
witt_truncate_fun_tac
intros
apply le_antisymm
rw powerlt_le
{ rw powerlt_le, intros c₃ h2, apply power_le_power_left h, rwa [←lt_succ] }
intros c₃ h2
apply power_le_power_left h
rwa [←lt_succ]
{ apply le_powerlt, apply lt_succ_self }
apply le_powerlt
apply lt_succ_self
intros
simp [lt_iff_le_not_le, -not_le]
intros
simp [mul_lt_omega_iff, ha, hb]
intros
rcases zero_or_succ_or_limit o with rfl|⟨o,rfl⟩|l
{ simp [not_zero_is_limit, cardinal.omega_ne_zero] }
simp [not_zero_is_limit, cardinal.omega_ne_zero]
{ simp [not_succ_is_limit, cardinal.one_lt_omega] }
simp [not_succ_is_limit, cardinal.one_lt_omega]
simp [l]
{ simp [l], refine le_of_not_lt (λ h, _), cases cardinal.lt_omega.1 h with n e, have := cof_cof o, rw [e, ord_nat] at this, cases n, { simp at e, simpa [e, not_zero_is_limit] using l }, { rw [← nat_cast_succ, cof_succ] at this, rw [← this, cof_eq_one_iff_is_succ] at e, rcases e with ⟨a, rfl⟩, exact not_succ_is_limit _ l } }
refine le_of_not_lt (λ h, _)
cases cardinal.lt_omega.1 h with n e
have := cof_cof o
rw [e, ord_nat] at this
cases n
{ simp at e, simpa [e, not_zero_is_limit] using l }
simp at e
simpa [e, not_zero_is_limit] using l
rw [← nat_cast_succ, cof_succ] at this
{ rw [← nat_cast_succ, cof_succ] at this, rw [← this, cof_eq_one_iff_is_succ] at e, rcases e with ⟨a, rfl⟩, exact not_succ_is_limit _ l }
rw [← this, cof_eq_one_iff_is_succ] at e
rcases e with ⟨a, rfl⟩
exact not_succ_is_limit _ l
simpa using repr_of_nat 1
intros
simp [termg]
intros
have ha' := normalize_fin_lt.mk rfl ha (h.trans_lt hb.lt)
have ha' := normalize_fin_lt.mk rfl ha (h.trans_lt hb.lt); rwa [← hb.coe, ← ha'.coe] at h
rwa [← hb.coe, ← ha'.coe] at h
intros
intros v h1
apply implies_neg_elim_core
apply (nnf_equiv v).elim_right h1
intros
rw [div_eq_mul_inv, h]
intros
rwa sub_eq_add_neg
intros
convert has_sum_single b _
{ exact (if_pos rfl).symm }
exact (if_pos rfl).symm
assume b' hb'
exact if_neg hb'
intros
simp [has_sum_nat_add_iff]
intros
split
assume h
{ assume h, rcases exists_Ico_subset_of_mem_nhds h hu with ⟨u, au, hu⟩, rcases exists_Ioc_subset_of_mem_nhds h hl with ⟨l, la, hl⟩, refine ⟨l, u, ⟨la, au⟩, λx hx, _⟩, cases le_total a x with hax hax, { exact hu ⟨hax, hx.2⟩ }, { exact hl ⟨hx.1, hax⟩ } }
rcases exists_Ico_subset_of_mem_nhds h hu with ⟨u, au, hu⟩
rcases exists_Ioc_subset_of_mem_nhds h hl with ⟨l, la, hl⟩
refine ⟨l, u, ⟨la, au⟩, λx hx, _⟩
cases le_total a x with hax hax
{ exact hu ⟨hax, hx.2⟩ }
exact hu ⟨hax, hx.2⟩
{ exact hl ⟨hx.1, hax⟩ }
exact hl ⟨hx.1, hax⟩
rintros ⟨l, u, ha, h⟩
{ rintros ⟨l, u, ha, h⟩, apply mem_of_superset (is_open.mem_nhds is_open_Ioo ha) h }
apply mem_of_superset (is_open.mem_nhds is_open_Ioo ha) h
intros
rw [← Ici_inter_Iic, interior_inter, interior_Ici, interior_Iic, Ioi_inter_Iio]
intros
let S := s ∩ Icc a b
replace ha : a ∈ S
from ⟨ha, left_mem_Icc.2 hab⟩
have Sbd : bdd_above S
from ⟨b, λ z hz, hz.2.2⟩
let c := Sup (s ∩ Icc a b)
have c_mem : c ∈ S
from hs.cSup_mem ⟨_, ha⟩ Sbd
have c_le : c ≤ b
from cSup_le ⟨_, ha⟩ (λ x hx, hx.2.2)
cases eq_or_lt_of_le c_le with hc hc
from hc ▸ c_mem.1
exfalso
rcases hgt c ⟨c_mem.1, c_mem.2.1, hc⟩ with ⟨x, xs, cx, xb⟩
exact not_lt_of_le (le_cSup Sbd ⟨xs, le_trans (le_cSup Sbd ha) (le_of_lt cx), xb⟩) cx
intros
simp only [← Ici_diff_left, continuous_within_at_diff_self]
intros
rw [@is_open_iff_generate_intervals α _ _ t]; exact generate_open.basic _ ⟨a, or.inl rfl⟩
rw [@is_open_iff_generate_intervals α _ _ t]
exact generate_open.basic _ ⟨a, or.inl rfl⟩
intros
rw [dense_iff_closure_eq, closure_compl, compl_univ_iff]
intros
{ ext, refl }
ext
refl
intros
intros s hs
rw is_open_sigma_iff at hs
have : s = ⋃ i, sigma.mk i '' (sigma.mk i ⁻¹' s)
{ rw Union_image_preimage_sigma_mk_eq_self }
rw Union_image_preimage_sigma_mk_eq_self
rw this
rw [image_Union]
apply is_open_Union
intro i
rw [image_image]
exact h i _ (hs i)
intros
{ ext, simp [sup'_apply], }
ext
simp [sup'_apply]
intros
simp [continuous_iff_continuous_at, continuous_on, continuous_at, continuous_within_at, nhds_within_univ]
intros
rw continuous_iff_continuous_on_univ
apply continuous_on.if'; simp *; assumption
apply continuous_on.if'; simp *
apply continuous_on.if'
simp *
assumption
simp *
assumption
simp *
simp *
intros
simp only [nhds_of_ne_top ha, tendsto_infi, tendsto_principal, mem_Icc]
intros
cases add_subgroup.bot_or_exists_ne_zero G with H H
right
{ right, use 0, rw [H, add_subgroup.closure_singleton_zero] }
use 0
rw [H, add_subgroup.closure_singleton_zero]
let G_pos := {g : ℝ | g ∈ G ∧ 0 < g}
{ let G_pos := {g : ℝ | g ∈ G ∧ 0 < g}, by_cases H' : ∃ a, is_least G_pos a, { right, rcases H' with ⟨a, ha⟩, exact ⟨a, add_subgroup.cyclic_of_min ha⟩ }, { left, rcases H with ⟨g₀, g₀_in, g₀_ne⟩, exact real.subgroup_dense_of_no_min g₀_in g₀_ne H' } }
by_cases H' : ∃ a, is_least G_pos a
right
{ right, rcases H' with ⟨a, ha⟩, exact ⟨a, add_subgroup.cyclic_of_min ha⟩ }
rcases H' with ⟨a, ha⟩
exact ⟨a, add_subgroup.cyclic_of_min ha⟩
left
{ left, rcases H with ⟨g₀, g₀_in, g₀_ne⟩, exact real.subgroup_dense_of_no_min g₀_in g₀_ne H' }
rcases H with ⟨g₀, g₀_in, g₀_ne⟩
exact real.subgroup_dense_of_no_min g₀_in g₀_ne H'
intros
assume s hs
rw [image_eq_preimage_of_inverse r_inv l_inv]
exact hs.preimage h
intros
{ simp only [antilipschitz_with, edist_nndist], norm_cast }
simp only [antilipschitz_with, edist_nndist]
norm_cast
intros
simpa only [real.dist_eq, abs_of_nonpos (sub_nonpos.2 $ hx.1.trans hx.2), neg_sub] using real.dist_le_of_mem_interval (Icc_subset_interval hx) (Icc_subset_interval hy)
intros
{ norm_cast, exact ennreal.coe_ne_top }
norm_cast
exact ennreal.coe_ne_top
intros
simp only [diam, supr_le_iff]
intros
simp only [to_GH_space, quotient.eq]
split
assume h
{ assume h, rcases setoid.symm h with ⟨e⟩, have f := (Kuratowski_embedding.isometry X).isometric_on_range.trans e, use λ x, f x, split, { apply isometry_subtype_coe.comp f.isometry }, { rw [range_comp, f.range_eq_univ, set.image_univ, subtype.range_coe] } }
rcases setoid.symm h with ⟨e⟩
have f := (Kuratowski_embedding.isometry X).isometric_on_range.trans e
use λ x, f x
split
{ apply isometry_subtype_coe.comp f.isometry }
apply isometry_subtype_coe.comp f.isometry
{ rw [range_comp, f.range_eq_univ, set.image_univ, subtype.range_coe] }
rw [range_comp, f.range_eq_univ, set.image_univ, subtype.range_coe]
rintros ⟨Ψ, ⟨isomΨ, rangeΨ⟩⟩
{ rintros ⟨Ψ, ⟨isomΨ, rangeΨ⟩⟩, have f := ((Kuratowski_embedding.isometry X).isometric_on_range.symm.trans isomΨ.isometric_on_range).symm, have E : (range Ψ ≃ᵢ (nonempty_compacts.Kuratowski_embedding X).val) = (p.val ≃ᵢ range (Kuratowski_embedding X)), by { dunfold nonempty_compacts.Kuratowski_embedding, rw [rangeΨ]; refl }, have g := cast E f, exact ⟨g⟩ }
have f := ((Kuratowski_embedding.isometry X).isometric_on_range.symm.trans isomΨ.isometric_on_range).symm
have E : (range Ψ ≃ᵢ (nonempty_compacts.Kuratowski_embedding X).val) = (p.val ≃ᵢ range (Kuratowski_embedding X))
dunfold nonempty_compacts.Kuratowski_embedding
dunfold nonempty_compacts.Kuratowski_embedding
{ dunfold nonempty_compacts.Kuratowski_embedding, rw [rangeΨ]; refl }
{ dunfold nonempty_compacts.Kuratowski_embedding, rw [rangeΨ]; refl }
rw [rangeΨ]
rw [rangeΨ]
rw [rangeΨ]; refl
rw [rangeΨ]; refl
have g := cast E f
exact ⟨g⟩
intros
refine λ x, mem_closure_iff_nhds.2 (λ t ht, ne_empty_iff_nonempty.1 $ λ he, hs.not_le _)
rw [← diff_eq, diff_eq_empty] at he
rw [← real.dimH_of_mem_nhds ht]
exact dimH_mono he
intros
simp [inf_dist, inf_edist_closure]
intros
simp only [holder_on_with, holder_with, mem_univ, true_implies_iff]
intros
rw [iterate_succ, mul_comm]
simpa only [nnreal.coe_pow] using (hf.iterate n).dist_le_mul x (f x)
intros
rcases exists_subset_Union_closure_subset hs ho (λ x _, hf.point_finite x) hU with ⟨V, hsV, hVo, hVU⟩
have hVU' : ∀ i, V i ⊆ U i
from λ i, subset.trans subset_closure (hVU i)
rcases exists_subset_Union_closure_subset hs hVo (λ x _, (hf.subset hVU').point_finite x) hsV with ⟨W, hsW, hWo, hWV⟩
choose f hfp hf0 hf1 hf01 using λ i, h01 _ _ (is_closed_compl_iff.2 $ hVo i) is_closed_closure (disjoint_right.2 $ λ x hx, not_not.2 (hWV i hx))
have hsupp : ∀ i, support (f i) ⊆ V i
from λ i, support_subset_iff'.2 (hf0 i)
refine ⟨⟨f, hf.subset (λ i, subset.trans (hsupp i) (hVU' i)), λ i x, (hf01 i x).1, λ i x, (hf01 i x).2, λ x hx, _⟩, hfp, λ i, subset.trans (closure_mono (hsupp i)) (hVU i)⟩
rcases mem_Union.1 (hsW hx) with ⟨i, hi⟩
exact ⟨i, ((hf1 i).mono subset_closure).eventually_eq_of_mem ((hWo i).mem_nhds hi)⟩
intros
simp [joined_in, joined, exists_true_iff_nonempty]
intros
simp_rw [← lower_semicontinuous_within_at_univ_iff] at *
exact lower_semicontinuous_within_at_supr h
intros
rw ← bUnion_univ; exact finite_univ.compact_bUnion (λ i _, h i)
rw ← bUnion_univ
exact finite_univ.compact_bUnion (λ i _, h i)
intros
rw [uniform_continuous, uniformity_prod]; exact tendsto_inf.2 ⟨tendsto_comap_iff.2 h₁, tendsto_comap_iff.2 h₂⟩
rw [uniform_continuous, uniformity_prod]
exact tendsto_inf.2 ⟨tendsto_comap_iff.2 h₁, tendsto_comap_iff.2 h₂⟩
intros
simp only [← and_assoc]
refine uniformity_has_basis_open.restrict (λ s hs, ⟨symmetrize_rel s, _⟩)
exact ⟨⟨symmetrize_mem_uniformity hs.1, is_open.inter hs.2 (hs.2.preimage continuous_swap)⟩, symmetric_symmetrize_rel s, symmetrize_rel_subset_self s⟩
intros
cases x; cases x'; simp * at *
cases x; cases x'
cases x
cases x'
simp * at *
intros
by_cases c; simp [*]
by_cases c
simp [*]
simp [*]
intros
have h := int.add_le_add_right h (-c)
rwa int.add_neg_cancel_right at h
intros
induction l; simp [*]
induction l
simp [*]
simp [*]
intros
cases x; simp [gcd, succ_ne_zero]
cases x
simp [gcd, succ_ne_zero]
simp [gcd, succ_ne_zero]
intros
by_cases c; simp [*]
by_cases c
simp [*]
simp [*]
intros
simp [infi]
intros
simp only [finset.prod_eq_multiset_prod, g.map_multiset_prod, multiset.map_map]
intros
split_ifs with h; refl
{ split_ifs with h; refl }
split_ifs with h
refl
refl
intros
rw [← finprod_mem_inter_mul_support f s, ← finprod_mem_inter_mul_support f t, ← finprod_mem_union_inter hs ht, ← union_inter_distrib_right, finprod_mem_inter_mul_support, ← finprod_mem_inter_mul_support f (s ∩ t)]
congr' 2
rw [inter_left_comm, inter_assoc, inter_assoc, inter_self, inter_left_comm]
intros
rw eq_neg_iff_add_eq_zero
nth_rewrite 1 ← one_pow (p ^ n)
rw [← add_pow_char_pow, add_left_neg, zero_pow (pow_pos (fact.out (nat.prime p)).pos _)]
intros
{ rw [nth_cont_eq_succ_nth_cont_aux], exact (exists_gcf_pair_rat_eq_of_nth_conts_aux v $ n + 1) }
rw [nth_cont_eq_succ_nth_cont_aux]
exact (exists_gcf_pair_rat_eq_of_nth_conts_aux v $ n + 1)
intros
change s.nth n = none at terminated_at_n
induction n with n IH generalizing s
case nat.zero { simp only [convergents'_aux, terminated_at_n, seq.head] }
simp only [convergents'_aux, terminated_at_n, seq.head]
case nat.succ { cases s_head_eq : s.head with gp_head, case option.none { simp only [convergents'_aux, s_head_eq] }, case option.some { have : s.tail.terminated_at n, by simp only [seq.terminated_at, s.nth_tail, terminated_at_n], simp only [convergents'_aux, s_head_eq, (IH this)] } }
cases s_head_eq : s.head with gp_head
simp only [convergents'_aux, s_head_eq]
case option.none { simp only [convergents'_aux, s_head_eq] }
case option.some { have : s.tail.terminated_at n, by simp only [seq.terminated_at, s.nth_tail, terminated_at_n], simp only [convergents'_aux, s_head_eq, (IH this)] }
have : s.tail.terminated_at n
simp only [seq.terminated_at, s.nth_tail, terminated_at_n]
simp only [seq.terminated_at, s.nth_tail, terminated_at_n]
simp only [convergents'_aux, s_head_eq, (IH this)]
intros
split
intros h x hx
{ intros h x hx, apply eq_zero_of_zero_dvd, rw ← h, apply gcd_dvd hx }
apply eq_zero_of_zero_dvd
rw ← h
apply gcd_dvd hx
apply s.induction_on
{ apply s.induction_on, { simp }, intros a s sgcd h, simp [h a (mem_cons_self a s), sgcd (λ x hx, h x (mem_cons_of_mem hx))] }
{ simp }
simp
intros a s sgcd h
simp [h a (mem_cons_self a s), sgcd (λ x hx, h x (mem_cons_of_mem hx))]
intros
rw [mul_inv_rev, mul_comm]
intros
split
split; { rintro rfl, simpa using h }
{ rintro rfl, simpa using h }
rintro rfl
{ rintro rfl, simpa using h }
simpa using h
intros
cases f; cases g; cases h; refl
cases f; cases g; cases h
cases f; cases g
cases f
cases g
cases h
refl
intros
rcases h with ⟨y, rfl⟩; exact (units.map f y).is_unit
rcases h with ⟨y, rfl⟩
exact (units.map f y).is_unit
intros
rw [nat.mul_comm, pow_mul]
intros
induction n with n ih
rw pow_zero at H
{ rw pow_zero at H, rw [← mul_one x, H, mul_zero] }
rw [← mul_one x, H, mul_zero]
rw pow_succ at H
{ rw pow_succ at H, exact or.cases_on (mul_eq_zero.1 H) id ih }
exact or.cases_on (mul_eq_zero.1 H) id ih
intros
rw [inv_eq_iff, inv_zero, eq_comm]
intros
rw [div_mul_eq_mul_div, mul_comm, mul_div_right_comm]
intros
rw eq_bot_iff
refine image_subobject_le _ 0 _
rw [C.d_to_eq_zero h, zero_comp]
intros
rw [indicator_diff' h, sub_eq_add_neg]
intros
simp [add_right_iterate]
intros
{ ext, refl, }
ext
refl
intros
erw [lie_equiv.trans_apply, lie_equiv.of_eq_apply, skew_adjoint_matrices_lie_subalgebra_equiv_apply]
intros
intros m h
rw [lie_ideal_oper_eq_span, mem_lie_span] at h
rw [lie_ideal_oper_eq_span, mem_lie_span]
intros N hN
apply h
rintros m' ⟨⟨x, hx⟩, ⟨n, hn⟩, hm⟩
rw ← hm
apply hN
use [⟨x, h₁ hx⟩, ⟨n, h₂ hn⟩]
refl
intros
rw [derived_series_of_ideal_succ, derived_series_of_ideal_zero, lie_submodule.lie_abelian_iff_lie_self_eq_bot]
intros
split
{ rintros ⟨N, rfl⟩, exact N.lie_mem, }
rintros ⟨N, rfl⟩
exact N.lie_mem
intros h
{ intros h, use { lie_mem := h, ..p }, exact lie_submodule.coe_to_submodule_mk p _, }
use { lie_mem := h, ..p }
exact lie_submodule.coe_to_submodule_mk p _
intros
rw [←neg_neg c, neg_smul, neg_neg_iff_pos]
exact smul_pos_iff_of_pos (neg_pos_of_neg hc)
intros
rw [inv_eq_one_div, mul_comm, ← div_eq_mul_one_div]
exact div_le_iff' h
intros
rw [div_eq_mul_one_div a c, div_eq_mul_one_div b c]
exact mul_lt_mul_of_pos_right h (one_div_pos.2 hc)
intros
simpa only [← h, eq_comm, eq_neg_iff_eq_neg] using abs_choice a
intros
{ rw [← mul_lt_mul_iff_left a], simp }
rw [← mul_lt_mul_iff_left a]
simp
intros
rw [inv_mul_lt_iff_lt_mul, mul_comm]
intros
simp only [div_eq_mul_inv, max_mul_mul_left, max_inv_inv']
intros
cases le_total n m with h h; simp [h, mul_comm]
{ cases le_total n m with h h; simp [h, mul_comm] }
cases le_total n m with h h
simp [h, mul_comm]
simp [h, mul_comm]
intros
rw [← neg_pos, neg_mul_eq_mul_neg, mul_pos_iff, neg_pos, neg_lt_zero]
intros
simp only [pos_iff_ne_zero, ne.def, mul_eq_zero, not_or_distrib]
intros
have : 0 < a * ⅟a
simp only [mul_inv_of_self, zero_lt_one]
simp only [mul_inv_of_self, zero_lt_one]
exact ⟨λ h, (pos_of_mul_pos_right this h).le, λ h, (pos_of_mul_pos_left this h).le⟩
intros
rw [← sub_nonneg, ← mul_sub]
exact decidable.ordered_ring.mul_nonneg h₂ (sub_nonneg.2 h₁)
intros
simpa only [nsmul_eq_mul] using h.nsmul n
intros
simp * at *
intros
{ rw [← inv_subset_inv, set.inv_inv] }
rw [← inv_subset_inv, set.inv_inv]
intros
intros x y h
convert congr_arg ((•) g⁻¹) h using 1
convert congr_arg ((•) g⁻¹) h using 1; simp [←smul_assoc]
simp [←smul_assoc]
simp [←smul_assoc]
intros
have : c = -(x * x - b * x) := (neg_eq_of_add_eq_zero h).symm
have : c = x * (b - x)
subst this
subst this
subst this; simp [mul_sub, mul_comm]
subst this; simp [mul_sub, mul_comm]
simp [mul_sub, mul_comm]
simp [mul_sub, mul_comm]
refine ⟨b - x, _, by simp, by rw this⟩
rw [this, sub_add, ← sub_mul, sub_self]
intros
{ dsimp [mk_alg_hom], rintro ⟨⟨a⟩⟩, use a, refl, }
dsimp [mk_alg_hom]
rintro ⟨⟨a⟩⟩
use a
refl
intros
simp only [@eq_comm _ Uᶜ]; refl
simp only [@eq_comm _ Uᶜ]
refl
intros
cases n; dsimp
cases n
dsimp
simp only [subobject.factor_thru_arrow_assoc]
{ simp only [subobject.factor_thru_arrow_assoc], slice_lhs 2 3 { erw ←X.δ_comp_δ (fin.zero_le 0), }, rw ←factor_thru_arrow _ _ (finset_inf_arrow_factors finset.univ _ (0 : fin 2) (by simp)), slice_lhs 2 3 { rw [kernel_subobject_arrow_comp], }, simp, }
slice_lhs 2 3 { erw ←X.δ_comp_δ (fin.zero_le 0), }
rw ←factor_thru_arrow _ _ (finset_inf_arrow_factors finset.univ _ (0 : fin 2) (by simp))
slice_lhs 2 3 { rw [kernel_subobject_arrow_comp], }
simp
dsimp
{ simp [factor_thru_right], slice_lhs 2 3 { erw ←X.δ_comp_δ (fin.zero_le 0), }, rw ←factor_thru_arrow _ _ (finset_inf_arrow_factors finset.univ _ (0 : fin (n+3)) (by simp)), slice_lhs 2 3 { rw [kernel_subobject_arrow_comp], }, simp, }
simp [factor_thru_right]
slice_lhs 2 3 { erw ←X.δ_comp_δ (fin.zero_le 0), }
rw ←factor_thru_arrow _ _ (finset_inf_arrow_factors finset.univ _ (0 : fin (n+3)) (by simp))
slice_lhs 2 3 { rw [kernel_subobject_arrow_comp], }
simp
intros
dsimp [δ]
{ dsimp [δ], simp only [←X.map_comp, ←op_comp, simplex_category.δ_comp_δ_self] }
simp only [←X.map_comp, ←op_comp, simplex_category.δ_comp_δ_self]
intros
induction j with j IHj
{ show sum (take ((b.blocks.take i).sum) a.blocks) = sum (take i (map sum (split_wrt_composition a.blocks b))), induction i with i IH, { refl }, { have A : i < b.length := nat.lt_of_succ_lt hi, have B : i < list.length (map list.sum (split_wrt_composition a.blocks b)), by simp [A], have C : 0 < blocks_fun b ⟨i, A⟩ := composition.blocks_pos' _ _ _, rw [sum_take_succ _ _ B, ← IH A C], have : take (sum (take i b.blocks)) a.blocks = take (sum (take i b.blocks)) (take (sum (take (i+1) b.blocks)) a.blocks), { rw [take_take, min_eq_left], apply monotone_sum_take _ (nat.le_succ _) }, rw [this, nth_le_map', nth_le_split_wrt_composition, ← take_append_drop (sum (take i b.blocks)) ((take (sum (take (nat.succ i) b.blocks)) a.blocks)), sum_append], congr, rw [take_append_drop] } }
show sum (take ((b.blocks.take i).sum) a.blocks) = sum (take i (map sum (split_wrt_composition a.blocks b)))
induction i with i IH
{ refl }
refl
{ have A : i < b.length := nat.lt_of_succ_lt hi, have B : i < list.length (map list.sum (split_wrt_composition a.blocks b)), by simp [A], have C : 0 < blocks_fun b ⟨i, A⟩ := composition.blocks_pos' _ _ _, rw [sum_take_succ _ _ B, ← IH A C], have : take (sum (take i b.blocks)) a.blocks = take (sum (take i b.blocks)) (take (sum (take (i+1) b.blocks)) a.blocks), { rw [take_take, min_eq_left], apply monotone_sum_take _ (nat.le_succ _) }, rw [this, nth_le_map', nth_le_split_wrt_composition, ← take_append_drop (sum (take i b.blocks)) ((take (sum (take (nat.succ i) b.blocks)) a.blocks)), sum_append], congr, rw [take_append_drop] }
have A : i < b.length := nat.lt_of_succ_lt hi
have B : i < list.length (map list.sum (split_wrt_composition a.blocks b))
simp [A]
simp [A]
have C : 0 < blocks_fun b ⟨i, A⟩ := composition.blocks_pos' _ _ _
rw [sum_take_succ _ _ B, ← IH A C]
have : take (sum (take i b.blocks)) a.blocks = take (sum (take i b.blocks)) (take (sum (take (i+1) b.blocks)) a.blocks)
rw [take_take, min_eq_left]
{ rw [take_take, min_eq_left], apply monotone_sum_take _ (nat.le_succ _) }
apply monotone_sum_take _ (nat.le_succ _)
rw [this, nth_le_map', nth_le_split_wrt_composition, ← take_append_drop (sum (take i b.blocks)) ((take (sum (take (nat.succ i) b.blocks)) a.blocks)), sum_append]
congr
rw [take_append_drop]
have A : j < blocks_fun b ⟨i, hi⟩ := lt_trans (lt_add_one j) hj
{ have A : j < blocks_fun b ⟨i, hi⟩ := lt_trans (lt_add_one j) hj, have B : j < length (sigma_composition_aux a b ⟨i, (length_gather a b).symm ▸ hi⟩), by { convert A, rw [← length_sigma_composition_aux], refl }, have C : size_up_to b i + j < size_up_to b (i + 1), { simp only [size_up_to_succ b hi, add_lt_add_iff_left], exact A }, have D : size_up_to b i + j < length a := lt_of_lt_of_le C (b.size_up_to_le _), have : size_up_to b i + nat.succ j = (size_up_to b i + j).succ := rfl, rw [this, size_up_to_succ _ D, IHj A, size_up_to_succ _ B], simp only [sigma_composition_aux, add_assoc, add_left_inj, fin.coe_mk], rw [nth_le_of_eq (nth_le_split_wrt_composition _ _ _), nth_le_drop', nth_le_take _ _ C] }
have B : j < length (sigma_composition_aux a b ⟨i, (length_gather a b).symm ▸ hi⟩)
convert A
convert A
{ convert A, rw [← length_sigma_composition_aux], refl }
{ convert A, rw [← length_sigma_composition_aux], refl }
rw [← length_sigma_composition_aux]
rw [← length_sigma_composition_aux]
refl
refl
have C : size_up_to b i + j < size_up_to b (i + 1)
simp only [size_up_to_succ b hi, add_lt_add_iff_left]
{ simp only [size_up_to_succ b hi, add_lt_add_iff_left], exact A }
exact A
have D : size_up_to b i + j < length a := lt_of_lt_of_le C (b.size_up_to_le _)
have : size_up_to b i + nat.succ j = (size_up_to b i + j).succ := rfl
rw [this, size_up_to_succ _ D, IHj A, size_up_to_succ _ B]
simp only [sigma_composition_aux, add_assoc, add_left_inj, fin.coe_mk]
rw [nth_le_of_eq (nth_le_split_wrt_composition _ _ _), nth_le_drop', nth_le_take _ _ C]
intros
refine ⟨by rintro rfl; exact ⟨rfl, rfl⟩, _⟩
rcases i with ⟨a, b⟩
rcases j with ⟨a', b'⟩
rintros ⟨h, h'⟩
have H : a = a'
ext1
ext1
{ ext1, exact h }
{ ext1, exact h }
exact h
exact h
induction H
congr
ext1
exact h'
intros
unfold is_o
{ unfold is_o, exact forall_congr (λ _, (forall_congr (λ _, is_O_with_neg_right))) }
exact forall_congr (λ _, (forall_congr (λ _, is_O_with_neg_right)))
intros
rw [← has_deriv_within_at_univ] at *
exact hc.mul_const d
intros
convert (polynomial.C (1 : 𝕜) * (polynomial.X)^n).has_strict_deriv_at x
{ simp }
simp
{ rw [polynomial.derivative_C_mul_X_pow], simp }
rw [polynomial.derivative_C_mul_X_pow]
simp
intros
simp only [deriv_within, fderiv_within_const_add hxs]
intros
simpa only [sub_eq_add_neg] using hf.add_const (-c)
intros
refine ⟨λ H, _, λ H, iso.differentiable.differentiable_at.comp_differentiable_within_at x H⟩
have : differentiable_within_at 𝕜 (iso.symm ∘ (iso ∘ f)) s x := iso.symm.differentiable.differentiable_at.comp_differentiable_within_at x H
rwa [← function.comp.assoc iso.symm iso f, iso.symm_comp_self] at this
intros
{ ext, rw h.unique h.differentiable_at.has_fderiv_at }
ext
rw h.unique h.differentiable_at.has_fderiv_at
intros
apply eq_implicit_function_of_complemented
intros
ext x
rw [← iterated_deriv_within_univ, ← iterated_deriv_within_univ, ← deriv_within_univ]
exact iterated_deriv_within_succ unique_diff_within_at_univ
intros
simpa only [add_sub_cancel'] using mem_pos_tangent_cone_at_of_segment_subset h
intros
obtain ⟨ε, ε0, hε⟩ : ∃ ε > 0, ball x ε ∩ s ⊆ {y | has_fderiv_within_at f (f' y) s y ∧ ∥f' y∥₊ < K}
from mem_nhds_within_iff.1 (hder.and $ hcont.nnnorm.eventually (gt_mem_nhds hK))
rw inter_comm at hε
refine ⟨s ∩ ball x ε, inter_mem_nhds_within _ (ball_mem_nhds _ ε0), _⟩
exact (hs.inter (convex_ball _ _)).lipschitz_on_with_of_nnnorm_has_fderiv_within_le (λ y hy, (hε hy).1.mono (inter_subset_left _ _)) (λ y hy, (hε hy).2.le)
intros
rcases euclidean.exists_pos_lt_subset_ball hR hs hsR with ⟨r, hr, hsr⟩
exact ⟨⟨⟨r, R, hr.1, hr.2⟩⟩, rfl, hsr⟩
intros
simpa [continuous_within_at_univ] using h.continuous_within_at
intros
induction n using with_top.nat_induction with n IH Itop
intros m hm
{ intros m hm, refine ⟨{y : R | is_unit y}, _, _⟩, { simp [nhds_within_univ], exact x.nhds }, { use (ftaylor_series_within 𝕜 inverse univ), rw [le_antisymm hm bot_le, has_ftaylor_series_up_to_on_zero_iff], split, { rintros _ ⟨x', rfl⟩, exact (inverse_continuous_at x').continuous_within_at }, { simp [ftaylor_series_within] } } }
refine ⟨{y : R | is_unit y}, _, _⟩
simp [nhds_within_univ]
{ simp [nhds_within_univ], exact x.nhds }
exact x.nhds
use (ftaylor_series_within 𝕜 inverse univ)
{ use (ftaylor_series_within 𝕜 inverse univ), rw [le_antisymm hm bot_le, has_ftaylor_series_up_to_on_zero_iff], split, { rintros _ ⟨x', rfl⟩, exact (inverse_continuous_at x').continuous_within_at }, { simp [ftaylor_series_within] } }
rw [le_antisymm hm bot_le, has_ftaylor_series_up_to_on_zero_iff]
split
rintros _ ⟨x', rfl⟩
{ rintros _ ⟨x', rfl⟩, exact (inverse_continuous_at x').continuous_within_at }
exact (inverse_continuous_at x').continuous_within_at
{ simp [ftaylor_series_within] }
simp [ftaylor_series_within]
apply times_cont_diff_at_succ_iff_has_fderiv_at.mpr
{ apply times_cont_diff_at_succ_iff_has_fderiv_at.mpr, refine ⟨λ (x : R), - lmul_left_right 𝕜 R (inverse x) (inverse x), _, _⟩, { refine ⟨{y : R | is_unit y}, x.nhds, _⟩, rintros _ ⟨y, rfl⟩, rw [inverse_unit], exact has_fderiv_at_ring_inverse y }, { convert (lmul_left_right_is_bounded_bilinear 𝕜 R).times_cont_diff.neg.comp_times_cont_diff_at (x : R) (IH.prod IH) } }
refine ⟨λ (x : R), - lmul_left_right 𝕜 R (inverse x) (inverse x), _, _⟩
refine ⟨{y : R | is_unit y}, x.nhds, _⟩
{ refine ⟨{y : R | is_unit y}, x.nhds, _⟩, rintros _ ⟨y, rfl⟩, rw [inverse_unit], exact has_fderiv_at_ring_inverse y }
rintros _ ⟨y, rfl⟩
rw [inverse_unit]
exact has_fderiv_at_ring_inverse y
convert (lmul_left_right_is_bounded_bilinear 𝕜 R).times_cont_diff.neg.comp_times_cont_diff_at (x : R) (IH.prod IH)
{ convert (lmul_left_right_is_bounded_bilinear 𝕜 R).times_cont_diff.neg.comp_times_cont_diff_at (x : R) (IH.prod IH) }
{ exact times_cont_diff_at_top.mpr Itop }
exact times_cont_diff_at_top.mpr Itop
intros
{ ext m, rw iterated_fderiv_within_succ_apply_right hs hx, refl }
ext m
rw iterated_fderiv_within_succ_apply_right hs hx
refl
intros
rintro x y hx hy a b ha hb hab
rw mem_Union at ⊢ hx hy
obtain ⟨i, hx⟩ := hx
obtain ⟨j, hy⟩ := hy
obtain ⟨k, hik, hjk⟩ := hdir i j
exact ⟨k, hc (hik hx) (hjk hy) ha hb hab⟩
intros
refine ⟨λ hc i s h, _, λ h s i hi, _⟩
rw hc.mem_convex_hull_iff at h
{ rw hc.mem_convex_hull_iff at h, exact h.2 (set.mem_singleton _) }
exact h.2 (set.mem_singleton _)
by_contra H
{ by_contra H, refine h i s _, rw set.diff_singleton_eq_self H, exact hi }
refine h i s _
rw set.diff_singleton_eq_self H
exact hi
intros
rcases convex_hull_exists_dist_ge hx y with ⟨x', hx', Hx'⟩
rcases convex_hull_exists_dist_ge hy x' with ⟨y', hy', Hy'⟩
use [x', hx', y', hy']
exact le_trans Hx' (dist_comm y x' ▸ dist_comm y' x' ▸ Hy')
intros
rw [←inner_conj_sym, inner_neg_left]; simp only [ring_hom.map_neg, inner_conj_sym]
rw [←inner_conj_sym, inner_neg_left]
simp only [ring_hom.map_neg, inner_conj_sym]
intros
rw [←inner_conj_sym, abs_conj]
intros
ext
intros
exact_mod_cast real.geom_mean_le_arith_mean_weighted _ _ _ (λ i _, (w i).coe_nonneg) (by assumption_mod_cast) (λ i _, (z i).coe_nonneg)
intros
let g : Y ⟶ Z := explicit_cokernel_π f ≫ e₂
have w : f ≫ g = 0
simp
simp
have : e₂ = explicit_cokernel_desc w
{ apply explicit_cokernel_desc_unique, refl }
apply explicit_cokernel_desc_unique
refl
rw this
apply explicit_cokernel_desc_unique
exact h
intros
{ ext, refl }
ext
refl
intros
simpa [sub_eq_add_neg] using add hf (neg hg)
intros
rw inclusion_in_double_dual_norm_eq
{ rw inclusion_in_double_dual_norm_eq, exact continuous_linear_map.norm_id_le }
exact continuous_linear_map.norm_id_le
intros
simp [exp_series]
intros
obtain (rfl|rfl) := int.units_eq_one_or e
obtain (rfl|rfl) := int.units_eq_one_or e; simp only [units.coe_neg_one, units.coe_one, nnnorm_neg, nnnorm_one]
simp only [units.coe_neg_one, units.coe_one, nnnorm_neg, nnnorm_one]
simp only [units.coe_neg_one, units.coe_one, nnnorm_neg, nnnorm_one]
intros
refine (curry_fin_finset_symm_apply_piecewise_const hk hl _ _ _).symm.trans _
rw linear_isometry_equiv.symm_apply_apply
intros
dunfold mk_continuous_linear
exact linear_map.mk_continuous_norm_le _ (le_max_right _ _) _
intros
{ ext, refl }
ext
refl
intros
apply cInf_le
use 0
rintros _ ⟨n, h, rfl⟩
{ rintros _ ⟨n, h, rfl⟩, apply norm_nonneg }
apply norm_nonneg
apply set.mem_image_of_mem
{ apply set.mem_image_of_mem, rw set.mem_set_of_eq }
rw set.mem_set_of_eq
intros
simpa only using hf.map φ.to_linear_map.to_add_monoid_hom φ.continuous
intros
simpa only [arg_eq_pi_iff.2 ⟨hre, him⟩] using (continuous_within_at_arg_of_re_neg_of_im_zero hre him).tendsto
intros
simp [log_re]
intros
refine ⟨λ h, _, λ h, ⟨abs (P.coeff 0), eventually_map.mpr (eventually_of_forall (forall_imp (λ _, le_of_eq) (λ x, congr_arg abs $ trans (congr_arg (eval x) (eq_C_of_degree_le_zero h)) (eval_C))))⟩⟩
contrapose! h
exact not_is_bounded_under_of_tendsto_at_top (abs_tendsto_at_top P (nat.with_bot.one_le_iff_zero_lt.2 h))
intros
simpa only [mul_zero, add_zero, mul_one] using (has_strict_deriv_at_id x).cpow (has_strict_deriv_at_const x c) h
intros
simpa using rpow_add_nat hx y 1
intros
simp [cpow_def]; split_ifs; simp [*, exp_add, mul_add] at *
simp [cpow_def]; split_ifs
simp [cpow_def]
split_ifs
simp [*, exp_add, mul_add] at *
simp [*, exp_add, mul_add] at *
simp [*, exp_add, mul_add] at *
simp [*, exp_add, mul_add] at *
simp [*, exp_add, mul_add] at *
simp [*, exp_add, mul_add] at *
intros
induction n with d hd
simp only [U_zero, nat.cast_zero, eval_one, mul_one, zero_add, one_mul]
{ simp only [U_zero, nat.cast_zero, eval_one, mul_one, zero_add, one_mul] }
rw U_eq_X_mul_U_add_T
{ rw U_eq_X_mul_U_add_T, simp only [eval_add, eval_mul, eval_X, T_complex_cos, add_mul, mul_assoc, hd, one_mul], conv_rhs { rw [sin_add, mul_comm] }, push_cast, simp only [add_mul, one_mul] }
simp only [eval_add, eval_mul, eval_X, T_complex_cos, add_mul, mul_assoc, hd, one_mul]
conv_rhs { rw [sin_add, mul_comm] }
push_cast
simp only [add_mul, one_mul]
intros
simp [le_antisymm_iff]
intros
simpa only [pow_zero, mul_one] using edist_le_of_edist_le_geometric_of_tendsto r C hu ha 0
intros
apply epi_of_zero_cokernel _ (cokernel f)
simp_rw ←h
exact is_colimit.of_iso_colimit (colimit.is_colimit (parallel_pair f 0)) (iso_of_π _)
intros
tfae_have : 3 → 2
rw exact_iff
{ rw exact_iff, rintro ⟨-, h⟩, exact zero_of_epi_comp _ h }
rintro ⟨-, h⟩
exact zero_of_epi_comp _ h
tfae_have : 1 → 3
rw exact_iff
{ rw exact_iff, introI, exact ⟨by simp, by simp [cokernel.π_of_epi]⟩ }
introI
exact ⟨by simp, by simp [cokernel.π_of_epi]⟩
tfae_have : 2 → 1
{ exact epi_of_cokernel_π_eq_zero _ }
exact epi_of_cokernel_π_eq_zero _
tfae_finish
intros
rw [neg_def, neg_def]
conv_lhs { rw ←sub_self (0 : X ⟶ Y) }
rw [sub_sub_sub, add_def, neg_def]
intros
rw [transfer_nat_trans_self_comp, gf, transfer_nat_trans_self_id]
intros
apply faithful.map_injective (forget C)
ext
exact w x
intros
erw [←iso.comp_hom_eq_id (e.inverse.map_iso (e.counit_iso.app Y)), unit_inverse_comp]
{ erw [←iso.comp_hom_eq_id (e.inverse.map_iso (e.counit_iso.app Y)), unit_inverse_comp], refl }
refl
intros
fsplit
rintro ⟨L⟩
{ rintro ⟨L⟩, fsplit, intros X Y, specialize L (e.inverse.obj X) (e.inverse.obj Y), refine (small_congr _).mpr L, exact equiv_of_fully_faithful e.inverse, }
fsplit
intros X Y
specialize L (e.inverse.obj X) (e.inverse.obj Y)
refine (small_congr _).mpr L
exact equiv_of_fully_faithful e.inverse
rintro ⟨L⟩
{ rintro ⟨L⟩, fsplit, intros X Y, specialize L (e.functor.obj X) (e.functor.obj Y), refine (small_congr _).mpr L, exact equiv_of_fully_faithful e.functor, }
fsplit
intros X Y
specialize L (e.functor.obj X) (e.functor.obj Y)
refine (small_congr _).mpr L
exact equiv_of_fully_faithful e.functor
intros
split_ifs; refl
{ split_ifs; refl, }
split_ifs
refl
refl
intros
ext
ext; apply category.id_comp
apply category.id_comp
intros
{ ext, simp [←F.map_comp], }
ext
simp [←F.map_comp]
intros
dsimp [limit.iso_limit_cone, is_limit.cone_point_unique_up_to_iso]
{ dsimp [limit.iso_limit_cone, is_limit.cone_point_unique_up_to_iso], tidy, }
tidy
intros
ext
rw [←assoc, colimit.ι_post, ←G.map_comp, colimit.ι_pre, ←assoc]
letI : has_colimit (E ⋙ F ⋙ G) := show has_colimit ((E ⋙ F) ⋙ G), by apply_instance
erw [colimit.ι_pre (F ⋙ G) E j, colimit.ι_post]
intros
simp
intros
simp [biproduct.ι_π]
intros
{ ext, simp, }
ext
simp
intros
{ ext, simp [coequalizer.iso_target_of_self], }
ext
simp [coequalizer.iso_target_of_self]
intros
{ rw [←left_unitor_tensor_inv'], simp }
rw [←left_unitor_tensor_inv']
simp
intros
simp
intros
tidy
intros
simpa using quot.sound (comp_closure.intro (𝟙 a) f₁ f₂ (𝟙 b) h)
intros
ext Y f
split
rintro ⟨_, _, _, ⟨i⟩, ⟨i'⟩, rfl⟩
{ rintro ⟨_, _, _, ⟨i⟩, ⟨i'⟩, rfl⟩, exact of_arrows.mk (sigma.mk _ _) }
exact of_arrows.mk (sigma.mk _ _)
rintro ⟨i⟩
{ rintro ⟨i⟩, exact bind_comp _ (of_arrows.mk _) (of_arrows.mk _) }
exact bind_comp _ (of_arrows.mk _) (of_arrows.mk _)
intros
convert mk_le_mk_of_comm _ w; simp
convert mk_le_mk_of_comm _ w
simp
simp
intros
{ ext, simp, }
ext
simp
intros
revert f₁
apply quotient.ind'
intro f₁
erw [inf_def, inf_def, inf_eq_map_pullback', inf_eq_map_pullback', ← map_comp]
dsimp
rw [pullback_comp, pullback_map_self]
intros
{ ext, simp, }
ext
simp
intros
simp [size_up_to, ones_blocks, take_repeat]
intros
ext j
simp [c.mem_boundaries_iff_exists_blocks_sum_take_eq, c.card_boundaries_eq_succ_length, composition.boundary, fin.ext_iff, composition.size_up_to, exists_prop, finset.mem_univ, take, exists_prop_of_true, finset.mem_image, composition_as_set.to_composition_blocks, composition.boundaries]
split
rintros ⟨i, hi⟩
{ rintros ⟨i, hi⟩, refine ⟨i.1, _, hi⟩, convert i.2, simp }
refine ⟨i.1, _, hi⟩
convert i.2
simp
rintros ⟨i, i_lt, hi⟩
{ rintros ⟨i, i_lt, hi⟩, have : i < c.to_composition.length + 1, by simpa using i_lt, exact ⟨⟨i, this⟩, hi⟩ }
have : i < c.to_composition.length + 1
simpa using i_lt
simpa using i_lt
exact ⟨⟨i, this⟩, hi⟩
intros
let r' := λ a, (rel.image r {a}).to_finset
have h : ∀ (A : finset α), fintype.card (rel.image r A) = (A.bUnion r').card
intro A
{ intro A, rw ←set.to_finset_card, apply congr_arg, ext b, simp [rel.image], }
rw ←set.to_finset_card
apply congr_arg
ext b
simp [rel.image]
have h' : ∀ (f : α → β) x, r x (f x) ↔ f x ∈ r' x
{ simp [rel.image], }
simp [rel.image]
simp only [h, h']
apply finset.all_card_le_bUnion_card_iff_exists_injective
intros
simp
intros
simp [(part.bind_some_eq_map _ _).symm]; exact hf.bind hg
simp [(part.bind_some_eq_map _ _).symm]
exact hf.bind hg
intros
simp [many_one_equiv]
intros
let o : option Γ' := list.cases_on L none (λ _ _, some Γ'.cons)
refine (move_ok dec_trivial (split_at_pred_eq _ _ (tr_nat L.head) o (tr_list L.tail) (tr_nat_nat_end _) _)).trans (trans_gen.head rfl (trans_gen.head rfl _))
cases L; exact ⟨rfl, rfl⟩
{ cases L; exact ⟨rfl, rfl⟩ }
cases L
exact ⟨rfl, rfl⟩
exact ⟨rfl, rfl⟩
simp [show o ≠ some Γ'.Cons, by cases L; rintro ⟨⟩]
refine (clear_ok (split_at_pred_eq _ _ _ none [] _ ⟨rfl, rfl⟩)).trans _
{ exact λ x h, (to_bool_ff (tr_list_ne_Cons _ _ h)) }
exact λ x h, (to_bool_ff (tr_list_ne_Cons _ _ h))
convert unrev_ok
simp [list.reverse_core_eq]
intros
rw [add_bottom, list_blank.head_cons]; refl
rw [add_bottom, list_blank.head_cons]
intros
simp only [tape.move, tape.mk', list_blank.head_cons, eq_self_iff_true, list_blank.cons_head_tail, and_self, list_blank.tail_cons]
intros
simp [fst,bimap_bimap]
intros
ext
ext; simp only [(∘), mfoldl.of_free_monoid, mfoldl.mk, flip, fold_mfoldl_cons]; refl
ext; simp only [(∘), mfoldl.of_free_monoid, mfoldl.mk, flip, fold_mfoldl_cons]
simp only [(∘), mfoldl.of_free_monoid, mfoldl.mk, flip, fold_mfoldl_cons]
refl
intros
simp [equiv.map]; apply comp_map
simp [equiv.map]
apply comp_map
intros
have := mem_nhds_to_topsp F.F; rwa F.eq at this
have := mem_nhds_to_topsp F.F
rwa F.eq at this
intros
rw size_eq_zero_iff
intros
simp [seq_left_eq, seq_eq_fail]
intros
simp [remaining]
intros
simp [digit, sat_eq_fail]
intros
simp
intros
rw [← of_real_rat_cast, of_real_re]
intros
rw [←sin_sq_add_cos_sq x, add_sub_cancel]
intros
rw add_submonoid.mem_supr_iff_exists_dfinsupp
simp_rw sum_add_hom_apply
congr'
intros
simp only [single_apply, dif_neg h]
intros
refine quotient.induction_on f (λ x, _)
dsimp only [support, quotient.lift_on_mk]
rw [finset.mem_filter, multiset.mem_to_finset]
exact and_iff_right_of_imp (x.3 i).resolve_right
intros
rw [prod_extend_right, coe_fn_mk]
split_ifs with h
{ rw h }
rw h
{ refl }
refl
intros
rw [← h.image_eq, ← h'.image_eq, ← hs, Heq.image_eq]
intros
haveI := e.symm.to_equiv.nontrivial
refine @local_of_surjective A B _ _ _ _ e e.to_equiv.surjective
intros
dsimp [pred_above]
rw dif_pos
exact (pos_iff_ne_zero _).mpr hi
intros
{ induction h, simp [ext_iff] }
induction h
simp [ext_iff]
intros
simp [lt_iff_coe_lt_coe]
intros
simpa [lt_iff_coe_lt_coe] using h
intros
ext x
{ ext x, simp, split_ifs with h; by_cases h' : x = a; simp [h, h'] }
simp
split_ifs with h
split_ifs with h; by_cases h' : x = a; simp [h, h']
split_ifs with h; by_cases h' : x = a
by_cases h' : x = a
simp [h, h']
simp [h, h']
by_cases h' : x = a
simp [h, h']
simp [h, h']
intros
rcases s with ⟨⟨s⟩⟩; rcases t with ⟨⟨t⟩⟩; apply list.mem_append
rcases s with ⟨⟨s⟩⟩; rcases t with ⟨⟨t⟩⟩
rcases s with ⟨⟨s⟩⟩
rcases t with ⟨⟨t⟩⟩
apply list.mem_append
intros
subst hs; exact finset.fold_congr hfg
subst hs
exact finset.fold_congr hfg
intros
rw ←list.erase_dup_eq_self at hl
simp [noncomm_prod, hl]
intros
conv_lhs { rw ←f.apply_symm_apply a }
exact map_domain_apply f.injective _ _
intros
{ classical, exact (trunc_of_card_le h).nonempty }
classical
exact (trunc_of_card_le h).nonempty
intros
classical
haveI : nonempty α
rcases h ∅ (by simp) with ⟨y, hy⟩
{ rcases h ∅ (by simp) with ⟨y, hy⟩, exact ⟨y⟩ }
exact ⟨y⟩
choose! F hF using h
have h' : ∀ (s : finset α), ∃ y, (∀ x ∈ s, P x) → (P y ∧ (∀ x ∈ s, r x y)) := λ s, ⟨F s, hF s⟩
set f := seq_of_forall_finset_exists_aux P r h' with hf
have A : ∀ (n : ℕ), P (f n)
assume n
{ assume n, induction n using nat.strong_induction_on with n IH, have IH' : ∀ (x : fin n), P (f x) := λ n, IH n.1 n.2, rw [hf, seq_of_forall_finset_exists_aux], exact (classical.some_spec (h' (finset.image (λ (i : fin n), f i) (finset.univ : finset (fin n)))) (by simp [IH'])).1 }
induction n using nat.strong_induction_on with n IH
have IH' : ∀ (x : fin n), P (f x) := λ n, IH n.1 n.2
rw [hf, seq_of_forall_finset_exists_aux]
exact (classical.some_spec (h' (finset.image (λ (i : fin n), f i) (finset.univ : finset (fin n)))) (by simp [IH'])).1
refine ⟨f, A, λ m n hmn, _⟩
nth_rewrite 1 hf
rw seq_of_forall_finset_exists_aux
apply (classical.some_spec (h' (finset.image (λ (i : fin n), f i) (finset.univ : finset (fin n)))) (by simp [A])).2
exact finset.mem_image.2 ⟨⟨m, hmn⟩, finset.mem_univ _, rfl⟩
intros
ext
ext; simp
simp
intros
rw [← prod_filter, filter_mem_eq_inter, univ_inter]
intros
simp only [not_lt, iff_false]
intros
{ rw [sq, sq], exact nat_abs_lt_iff_mul_self_lt }
rw [sq, sq]
exact nat_abs_lt_iff_mul_self_lt
intros
rw [mul_comm, int.div_mul_cancel H]
intros
rw [xgcd, ← xgcd_aux_fst x y 1 0 0 1]; cases xgcd_aux x 1 0 y 0 1; refl
rw [xgcd, ← xgcd_aux_fst x y 1 0 0 1]; cases xgcd_aux x 1 0 y 0 1
rw [xgcd, ← xgcd_aux_fst x y 1 0 0 1]
cases xgcd_aux x 1 0 y 0 1
refl
intros
induction n with n IH
have : insert_nth 0 x = cons x := funext (λ _, rfl)
{ have : insert_nth 0 x = cons x := funext (λ _, rfl), simp [this] }
simp [this]
rintros (_|⟨a, as⟩) (_|⟨b, bs⟩) h; simpa [IH.eq_iff] using h <|> refl
rintros (_|⟨a, as⟩) (_|⟨b, bs⟩) h
{ rintros (_|⟨a, as⟩) (_|⟨b, bs⟩) h; simpa [IH.eq_iff] using h <|> refl }
refl
simpa [IH.eq_iff] using h
simpa [IH.eq_iff] using h
simpa [IH.eq_iff] using h
simpa [IH.eq_iff] using h
intros
simp [init_eq_take, min_eq_left_of_lt h, take_take, pred_le]
intros
rw ←foldr_reverse; simp
rw ←foldr_reverse
simp
intros
rw [list.bind, length_join, map_map]
intros
induction l; [refl, simp only [*, pmap, map]]; split; refl
induction l; [refl, simp only [*, pmap, map]]; split
induction l; [refl, simp only [*, pmap, map]]
induction l
refl
simp only [*, pmap, map]
split
refl
refl
intros
simp only [reduce_option, filter_map, id.def, eq_self_iff_true, and_self]
intros
rw [length_foldr_permutations_aux2, (_ : sum (map length L) = n * length L)]
induction L with l L ih
simp
{simp}
have sum_map : sum (map length L) = n * length L := ih (λ l m, H l (mem_cons_of_mem _ m))
have length_l : length l = n := H _ (mem_cons_self _ _)
simp [sum_map, length_l, mul_add, add_comm]
intros
simp [erase_eq_erasep]; exact erasep_append_left (by refl) l₂ h
simp [erase_eq_erasep]
exact erasep_append_left (by refl) l₂ h
intros
induction l; intros
{induction l; intros, contradiction, reflexivity}
induction l
contradiction
reflexivity
intros
induction l with lh lt l_ih generalizing a
{ simp }
simp
simp [H _ _ _ _ (rel_of_chain_cons hl₂), l_ih _ _ (chain_of_chain_cons hl₂)]
{ simp [H _ _ _ _ (rel_of_chain_cons hl₂), l_ih _ _ (chain_of_chain_cons hl₂)] }
intros
obtain ⟨n, hn, rfl⟩ := nth_le_of_mem hx
simp only [next_nth_le, prev_nth_le, h, nat.mod_add_mod]
cases l with hd tl
simp
have : n < 1 + tl.length := by simpa [add_comm] using hn
{ have : n < 1 + tl.length := by simpa [add_comm] using hn, simp [add_left_comm, add_comm, add_assoc, nat.mod_eq_of_lt this] }
simp [add_left_comm, add_comm, add_assoc, nat.mod_eq_of_lt this]
intros
apply eq_nil_iff_forall_not_mem.2
intro a
simp only [and_imp, not_and, not_lt, list.mem_inter, list.Ico.mem]
intros h₁ h₂ h₃
exfalso
exact not_lt_of_ge h₃ h₂
intros
induction l with a l ihl
simp
{ simp }
obtain ⟨ha, hl⟩ : p a ∧ ∀ b, b ∈ l → p b
simpa using h
simpa using h
simp only [ihl hl, pairwise_cons, bex_imp_distrib, pmap, and.congr_left_iff, mem_pmap]
refine λ _, ⟨λ H b hb hpa hpb, H _ _ hb rfl, _⟩
rintro H _ b hb rfl
exact H b hb _ _
intros
simp [rotate]
intros
induction l
refl
case list.nil { refl }
case list.cons : hd tl ih { cases hd with ah bh, by_cases h₁ : a = ah; by_cases h₂ : a' = ah, { substs h₁ h₂, cases ne.irrefl h }, { subst h₁, simp [h₂] }, { subst h₂, simp [h] }, { simp [h₁, h₂, ih] } }
intros
suffices : ∀ (L : list α) h1, @@and.rec (λ a a (_ : length l₁ < length l + 1 + 1 ∧ length l₂ < length l + 1 + 1), L) h1 h1 = L
{ simp [merge_sort, h], apply this }
simp [merge_sort, h]
apply this
intros
cases h1
refl
intros
rw [sublists', map_sublists'_aux, ← sublists'_aux_append]
rw [sublists', map_sublists'_aux, ← sublists'_aux_append]; refl
refl
intros
rw [← unzip_right, unzip_revzip]
intros
{ ext, apply dot_product_neg }
ext
apply dot_product_neg
intros
ext
{ ext, refl }
refl
intros
simp only [one_apply, pi.single_apply, eq_comm]
simp only [one_apply, pi.single_apply, eq_comm]; congr
intros
ext i j; rw [← diagonal_one, mul_diagonal, mul_one]
ext i j
rw [← diagonal_one, mul_diagonal, mul_one]
intros
simp [mul_apply, hbj.symm]
intros
{ ext, simp [block_diagonal'_apply] }
ext
simp [block_diagonal'_apply]
intros
simp [vec_head, vec_alt1]
intros
rw [← to_matrix_trans, single_trans_single]
intros
rw [←multiset.mem_coe, multiset.coe_to_list]
intros
rw mem_erase_iff_of_nodup h; simp
rw mem_erase_iff_of_nodup h
simp
intros
simp [powerset_aux']; refl
simp [powerset_aux']
refl
intros
have := coeff_monomial m (finsupp.single i k) (1:R)
rwa [@monomial_eq _ _ (1:R) (finsupp.single i k) _, C_1, one_mul, finsupp.prod_single_index] at this
exact pow_zero _
intros
apply mv_polynomial.induction_on p
{ intro r, rw [eval₂_C, map_C, map_C, eval₂_C] }
intro r
rw [eval₂_C, map_C, map_C, eval₂_C]
intros p q hp hq
{ intros p q hp hq, rw [eval₂_add, (map f).map_add, hp, hq, (map f).map_add, eval₂_add] }
rw [eval₂_add, (map f).map_add, hp, hq, (map f).map_add, eval₂_add]
intros p s hp
{ intros p s hp, rw [eval₂_mul, (map f).map_mul, hp, (map f).map_mul, map_X, eval₂_mul, eval₂_X, eval₂_X] }
rw [eval₂_mul, (map f).map_mul, hp, (map f).map_mul, map_X, eval₂_mul, eval₂_X, eval₂_X]
intros
refine (find_eq_iff _).2 ⟨nat.find_spec h₂, λ n hn, _⟩
cases n with n
exacts [h0, @nat.find_min (λ n, p (n + 1)) _ h₂ _ (succ_lt_succ_iff.1 hn)]
intros
by_cases h1 : m ≤ n
rw [max_eq_right h1, max_eq_right (succ_le_succ h1)]
rw not_le at h1
{ rw not_le at h1, have h2 := le_of_lt h1, rw [max_eq_left h2, max_eq_left (succ_le_succ h2)] }
have h2 := le_of_lt h1
rw [max_eq_left h2, max_eq_left (succ_le_succ h2)]
intros
induction hmk with k hmk ih
rw le_rec_on_self
{ rw le_rec_on_self }
rw [le_rec_on_succ (le_trans hnm hmk), ih, le_rec_on_succ]
intros
rw [mul_comm, mul_comm b, a.mul_div_mul_left b hc]
intros
convert factorial_mul_factorial_dvd_factorial (le.intro rfl)
rw nat.add_sub_cancel_left
intros
rw sum_powerset_apply_card
simp only [nsmul_eq_mul', ← card_eq_zero]
convert int.alternating_sum_range_choose
ext
simp
intros
cases n
{ cases w, }
cases w
{ rw [digits_aux], }
rw [digits_aux]
intros
{ rw [← some_eq_coe] at h, exact dom_of_le_some h }
rw [← some_eq_coe] at h
exact dom_of_le_some h
intros
rw [gcd_comm n m, gcd_gcd_self_right_left]
intros
simp [coprime]
intros
rw [or_iff_not_and_not, not_lt, not_le] at hnb
rw [log, ←ite_not, if_pos hnb]
intros
simpa using unpair_left_le (mkpair a b)
intros
cases even_or_odd n with h
{ exact or.inl ⟨h, even_iff_not_odd.mp h⟩ }
exact or.inl ⟨h, even_iff_not_odd.mp h⟩
{ exact or.inr ⟨h, odd_iff_not_even.mp h⟩ }
exact or.inr ⟨h, odd_iff_not_even.mp h⟩
rw [sqrt, size_zero, sqrt._match_1]
intros
cases x; simp only [pmap, none_bind, some_bind]
{ cases x; simp only [pmap, none_bind, some_bind] }
cases x
simp only [pmap, none_bind, some_bind]
simp only [pmap, none_bind, some_bind]
intros
rw [valid.dual_iff, dual_erase_max]; exact erase_min.valid h.dual
rw [valid.dual_iff, dual_erase_max]
exact erase_min.valid h.dual
intros
cases r
exact hl.node' hr
{exact hl.node' hr}
rw rotate_l
split_ifs
{ exact hl.node3_l hr.2.1 hr.2.2 }
exact hl.node3_l hr.2.1 hr.2.2
{ exact hl.node4_l hr.2.1 hr.2.2 }
exact hl.node4_l hr.2.1 hr.2.2
intros
cases p; reflexivity
cases p
reflexivity
intros
{ dsimp [start, is_special], refl }
dsimp [start, is_special]
refl
intros
induction n with n ih
{ simp [monomial_zero_one], }
simp [monomial_zero_one]
rw [pow_succ, ←ih, ←monomial_one_one_eq_X, monomial_mul_monomial, add_comm, one_mul]
{ rw [pow_succ, ←ih, ←monomial_one_one_eq_X, monomial_mul_monomial, add_comm, one_mul], }
intros
simp [monic_X.degree_mul]
intros
rw [← with_top.coe_le_coe, ← trailing_degree_eq_nat_trailing_degree]
{ exact le_trailing_degree_of_ne_zero h, }
exact le_trailing_degree_of_ne_zero h
{ assume h, subst h, exact h rfl }
assume h
subst h
exact h rfl
intros
convert derivative_smul a p; apply C_mul'
convert derivative_smul a p
apply C_mul'
apply C_mul'
intros
simp [erase_lead_coeff]
intros
simp [eval₂_eq_sum]
intros
rw [monomial_eq_C_mul_X, mul_assoc, coeff_C_mul, X_pow_mul, coeff_mul_X_pow]
intros
rw [lifts_iff_ring_hom_srange, mem_map_srange] at h ⊢
intros k
by_cases hk : k = n
use 0
{ use 0, simp only [hk, ring_hom.map_zero, erase_same] }
simp only [hk, ring_hom.map_zero, erase_same]
obtain ⟨i, hi⟩ := h k
use i
simp only [hi, hk, erase_ne, ne.def, not_false_iff]
intros
rw [←hp.nat_degree_eq_zero_iff_eq_one, nat_degree_eq_zero_iff_degree_le_zero]
intros
split
intro hp
{ intro hp, replace hp := congr_arg (* C ↑(h.unit)⁻¹) hp, simp only [zero_mul] at hp, rwa [mul_assoc, monic.mul_left_eq_zero_iff] at hp, nontriviality, refine monic_mul_C_of_leading_coeff_mul_eq_one _, simp [units.mul_inv_eq_iff_eq_mul, is_unit.unit_spec] }
replace hp := congr_arg (* C ↑(h.unit)⁻¹) hp
simp only [zero_mul] at hp
rwa [mul_assoc, monic.mul_left_eq_zero_iff] at hp
nontriviality
refine monic_mul_C_of_leading_coeff_mul_eq_one _
simp [units.mul_inv_eq_iff_eq_mul, is_unit.unit_spec]
rintro rfl
{ rintro rfl, rw zero_mul }
rw zero_mul
intros
rw [sub_eq_add_neg, sub_eq_add_neg, reflect_add, reflect_neg]
intros
rw [taylor_coeff, hasse_deriv_zero, linear_map.id_apply]
intros
rw ←abs_repr x
cases repr x with a f
rw [←abs_map, pfunctor.map_eq]
rw [supp_eq_of_is_uniform h, supp_eq_of_is_uniform h, image_comp]
intros
replace hn : (n:ℚ) ≠ 0
rwa [ne.def, ← int.cast_zero, coe_int_inj]
rwa [ne.def, ← int.cast_zero, coe_int_inj]
split
intro h
{ intro h, lift ((m : ℚ) / n) to ℤ using h with k hk, use k, rwa [eq_div_iff_mul_eq hn, ← int.cast_mul, mul_comm, eq_comm, coe_int_inj] at hk }
lift ((m : ℚ) / n) to ℤ using h with k hk
use k
rwa [eq_div_iff_mul_eq hn, ← int.cast_mul, mul_comm, eq_comm, coe_int_inj] at hk
rintros ⟨d, rfl⟩
{ rintros ⟨d, rfl⟩, rw [int.cast_mul, mul_comm, mul_div_cancel _ hn, rat.coe_int_denom] }
rw [int.cast_mul, mul_comm, mul_div_cancel _ hn, rat.coe_int_denom]
intros
have hf : lim_zero _ := neg_lim_zero hf
show lim_zero (-f - -g)
convert hf using 1
simp
intros
suffices : a * b⁻¹ ≤ c ↔ a ≤ c / b⁻¹
simpa [div_eq_mul_inv]
simpa [div_eq_mul_inv]
refine (le_div_iff_mul_le _ _).symm; simpa
refine (le_div_iff_mul_le _ _).symm
simpa
simpa
intros
simp [bit1, bit1, to_nnreal_add (by rwa [ne.def, bit0_eq_top_iff]) ennreal.one_ne_top]
intros
rw [ennreal.mul_lt_top_iff, and_self, or_self, or_iff_left_iff_imp]
{ rw [ennreal.mul_lt_top_iff, and_self, or_self, or_iff_left_iff_imp], rintro rfl, norm_num }
rintro rfl
norm_num
intros
conv_lhs { rw [ereal.neg_le, ereal.neg_neg] }
intros
cases le_total b c with h h
simp [sup_eq_max, max_eq_right h, max_eq_right (mul_le_mul_of_nonneg_left h (zero_le a))]
{ simp [sup_eq_max, max_eq_right h, max_eq_right (mul_le_mul_of_nonneg_left h (zero_le a))] }
simp [sup_eq_max, max_eq_left h, max_eq_left (mul_le_mul_of_nonneg_left h (zero_le a))]
{ simp [sup_eq_max, max_eq_left h, max_eq_left (mul_le_mul_of_nonneg_left h (zero_le a))] }
intros
obtain hn | rfl | hp := lt_trichotomy r (0 : ℝ)
{ rw [sign_of_neg hn, sign_of_neg (inv_lt_zero.mpr hn)] }
rw [sign_of_neg hn, sign_of_neg (inv_lt_zero.mpr hn)]
{ rw [sign_zero, inv_zero, sign_zero] }
rw [sign_zero, inv_zero, sign_zero]
{ rw [sign_of_pos hp, sign_of_pos (inv_pos.mpr hp)] }
rw [sign_of_pos hp, sign_of_pos (inv_pos.mpr hp)]
intros
revert cb
refine mem_rec_on ha _ (λ ca' IH, _)
refine mem_rec_on ha _ (λ ca' IH, _); intros cb Hc; have h := H Hc
refine mem_rec_on ha _ (λ ca' IH, _); intros cb Hc
intros cb Hc
have h := H Hc
{ simp at h, simp [h] }
simp at h
simp [h]
intros cb Hc
have h := H Hc
have h := H Hc
{ have h := H Hc, simp, revert h, apply cb.cases_on (λ b, _) (λ cb', _); intro h; simp at h; simp [h], exact IH _ h }
simp
revert h
apply cb.cases_on (λ b, _) (λ cb', _)
apply cb.cases_on (λ b, _) (λ cb', _); intro h; simp at h; simp [h]
apply cb.cases_on (λ b, _) (λ cb', _); intro h; simp at h
apply cb.cases_on (λ b, _) (λ cb', _); intro h
intro h
simp at h
simp [h]
intro h
simp at h
simp [h]
exact IH _ h
intros
rw [set.ite, set.ite, diff_compl, union_comm, diff_eq]
intros
rw [compl_eq_univ_diff, image_diff_preimage, image_univ]
intros
simp [and_assoc]
intros
simp
intros
ext c
split
rintros ⟨a, b, h1a|h2a, hb, rfl⟩;[left, right]; exact ⟨_, _, ‹_›, ‹_›, rfl⟩
rintros ⟨a, b, h1a|h2a, hb, rfl⟩;[left, right]
rintros ⟨a, b, h1a|h2a, hb, rfl⟩
{ rintros ⟨a, b, h1a|h2a, hb, rfl⟩;[left, right]; exact ⟨_, _, ‹_›, ‹_›, rfl⟩ }
left
exact ⟨_, _, ‹_›, ‹_›, rfl⟩
right
exact ⟨_, _, ‹_›, ‹_›, rfl⟩
rintro (⟨_, _, _, _, rfl⟩|⟨_, _, _, _, rfl⟩); refine ⟨_, _, _, ‹_›, rfl⟩; simp [mem_union, *]
rintro (⟨_, _, _, _, rfl⟩|⟨_, _, _, _, rfl⟩); refine ⟨_, _, _, ‹_›, rfl⟩
rintro (⟨_, _, _, _, rfl⟩|⟨_, _, _, _, rfl⟩)
{ rintro (⟨_, _, _, _, rfl⟩|⟨_, _, _, _, rfl⟩); refine ⟨_, _, _, ‹_›, rfl⟩; simp [mem_union, *] }
refine ⟨_, _, _, ‹_›, rfl⟩
simp [mem_union, *]
refine ⟨_, _, _, ‹_›, rfl⟩
simp [mem_union, *]
intros
rw [union_comm, union_compl_self]
intros
simp only [injective, subtype.ext_iff, coe_cod_restrict_apply]
intros
simp only [Ioi_inter_Iic.symm, Ioi_inter_Ioi.symm, Iic_inter_Iic.symm]
simp only [Ioi_inter_Iic.symm, Ioi_inter_Ioi.symm, Iic_inter_Iic.symm]; ac_refl
ac_refl
intros
simp
intros
simp
intros
simp [← Ioi_inter_Iic, h]
intros
apply @Iio.infinite (order_dual α)
intros
simpa only [add_comm] using preimage_const_add_interval a b c
intros
{ ext, simp [classical.skolem] }
ext
simp [classical.skolem]
intros
rw [bInter_insert, bInter_singleton]
intros
simp [@Union_comm _ ι]
intros
cases x; refl
cases x
refl
refl
intros
ext i
{ clear_except, ext i, induction i; [refl, apply i_ih], }
clear_except
induction i
induction i; [refl, apply i_ih]
refl
apply i_ih
intros
cases v; cases i; simp [vector.update_nth, vector.nth_eq_nth_le]
cases v; cases i
cases v
cases i
simp [vector.update_nth, vector.nth_eq_nth_le]
intros
by_contradiction H
have : measurable_set (s ∩ {x | ∀ m ≥ n, f^[m] x ∉ s})
simp only [set_of_forall, ← compl_set_of]
{ simp only [set_of_forall, ← compl_set_of], exact hs.inter (measurable_set.bInter (countable_encodable _) (λ m _, hf.measurable.iterate m hs.compl)) }
exact hs.inter (measurable_set.bInter (countable_encodable _) (λ m _, hf.measurable.iterate m hs.compl))
rcases (hf.exists_gt_measure_inter_ne_zero this H) n with ⟨m, hmn, hm⟩
rcases nonempty_of_measure_ne_zero hm with ⟨x, ⟨hxs, hxn⟩, hxm, -⟩
exact hxn m hmn.lt.le hxm
intros
revert α
apply solvable_by_rad.induction
exact λ α, by { rw minpoly.eq_X_sub_C, exact gal_X_sub_C_is_solvable α }
{ exact λ α, by { rw minpoly.eq_X_sub_C, exact gal_X_sub_C_is_solvable α } }
exact λ α β, induction2 (add_mem _ (subset_adjoin F _ (set.mem_insert α _)) (subset_adjoin F _ (set.mem_insert_of_mem α (set.mem_singleton β))))
{ exact λ α β, induction2 (add_mem _ (subset_adjoin F _ (set.mem_insert α _)) (subset_adjoin F _ (set.mem_insert_of_mem α (set.mem_singleton β)))) }
exact λ α, induction1 (neg_mem _ (mem_adjoin_simple_self F α))
{ exact λ α, induction1 (neg_mem _ (mem_adjoin_simple_self F α)) }
exact λ α β, induction2 (mul_mem _ (subset_adjoin F _ (set.mem_insert α _)) (subset_adjoin F _ (set.mem_insert_of_mem α (set.mem_singleton β))))
{ exact λ α β, induction2 (mul_mem _ (subset_adjoin F _ (set.mem_insert α _)) (subset_adjoin F _ (set.mem_insert_of_mem α (set.mem_singleton β)))) }
exact λ α, induction1 (inv_mem _ (mem_adjoin_simple_self F α))
{ exact λ α, induction1 (inv_mem _ (mem_adjoin_simple_self F α)) }
{ exact λ α n, induction3 }
exact λ α n, induction3
intros
haveI hp : fact p.prime := ⟨char_p.char_is_prime K p⟩
letI : module (zmod p) K := { .. (zmod.cast_hom dvd_rfl K).to_module }
obtain ⟨n, h⟩ := vector_space.card_fintype (zmod p) K
rw zmod.card at h
refine ⟨⟨n, _⟩, hp.1, h⟩
apply or.resolve_left (nat.eq_zero_or_pos n)
rintro rfl
rw pow_zero at h
have : (0 : K) = 1
apply fintype.card_le_one_iff.mp (le_of_eq h)
{ apply fintype.card_le_one_iff.mp (le_of_eq h) }
exact absurd this zero_ne_one
intros
rw [evalᵢ, linear_map.range_comp, range_subtype]
exact map_restrict_dom_evalₗ
intros
rw [← (expand R p).map_zero, expand_inj hp, alg_hom.map_zero]
intros
{ rw [separable_def, derivative_X], exact is_coprime_one_right }
rw [separable_def, derivative_X]
exact is_coprime_one_right
intros
rw [←angle_neg_neg, neg_neg, angle_neg_right]
intros
rw [dist_eq_norm_vsub V, dist_eq_norm_vsub V, dist_eq_norm_vsub V, ← vsub_sub_vsub_cancel_right]
exact norm_sub_eq_add_norm_iff_angle_eq_pi ((λ he, hp1p2 (vsub_eq_zero_iff_eq.1 he))) (λ he, hp3p2 (vsub_eq_zero_iff_eq.1 he))
intros
erw [pseudo_metric_space.dist_comm p3 p2, dist_eq_norm_vsub V p1 p3, dist_eq_norm_vsub V p1 p2, dist_eq_norm_vsub V p2 p3, ←norm_sub_sq_eq_norm_sq_add_norm_sq_iff_angle_eq_pi_div_two, vsub_sub_vsub_cancel_right p1, ←neg_vsub_eq_vsub_rev p2 p3, norm_neg]
intros
simp
intros
simp only [mfderiv, h, dif_pos]
intros
simpa only [has_mfderiv_within_at, and_iff_right_iff_imp] with mfld_simps using has_fderiv_within_at.continuous_within_at
intros
rcases smooth_bump_covering.exists_is_subordinate I is_closed_univ (λ (x : M) _, univ_mem) with ⟨ι, f, -⟩
haveI := f.fintype
rcases f.exists_immersion_euclidean with ⟨n, e, hsmooth, hinj, hinj_mfderiv⟩
exact ⟨n, e, hsmooth, hsmooth.continuous.closed_embedding hinj, hinj_mfderiv⟩
intros
rw [general_commutator, closure_le]
split
intros h p hp q hq
{ intros h p hp q hq, exact h ⟨p, hp, q, hq, rfl⟩, }
exact h ⟨p, hp, q, hq, rfl⟩
rintros h x ⟨p, hp, q, hq, rfl⟩
{ rintros h x ⟨p, hp, q, hq, rfl⟩, exact h p hp q hq, }
exact h p hp q hq
intros
rw [equiv.symm_apply_eq, fin_equiv_powers_apply, subtype.mk_eq_mk, pow_eq_mod_order_of, fin.coe_mk]
intros
rw [←H.subtype_range, monoid_hom.map_range]
exact hH.of_surjective (ϕ.restrict H).range_restrict (ϕ.restrict H).range_restrict_surjective
intros
simpa [cycle_factors_finset_eq_finset] using eq_comm
intros
contrapose! hx
simp_rw [mem_support, not_not] at hx ⊢
induction l with f l ih generalizing hx
{ refl }
refl
rw [list.prod_cons, mul_apply, ih (λ g hg, hx g (or.inr hg)), hx f (or.inl rfl)]
{ rw [list.prod_cons, mul_apply, ih (λ g hg, hx g (or.inr hg)), hx f (or.inl rfl)] }
intros
refine eq_comm.trans (quotient_group.eq.trans _)
rw [nN.mem_comm_iff, div_eq_mul_inv]
intros
simp [map]
intros
rw [← H.inv_mem_iff, div_eq_mul_inv, div_eq_mul_inv, mul_inv_rev, inv_inv]
intros
rw [mrange_eq_map, ← free_monoid.closure_range_of, map_mclosure, ← set.range_comp, free_monoid.lift_comp_of, subtype.range_coe]
intros
simpa only [mrange_eq_map] using map_inr ⊤
intros
{ ext p, simp [homothety_apply, mul_smul] }
ext p
simp [homothety_apply, mul_smul]
intros
ext v
rw [submodule.mem_inf, ←vadd_mem_iff_mem_direction v h₁, ←vadd_mem_iff_mem_direction v h₂, ←vadd_mem_iff_mem_direction v ((mem_inf_iff p s₁ s₂).2 ⟨h₁, h₂⟩), mem_inf_iff]
intros
simp_rw [affine_combination_apply, eq_vadd_iff_vsub_eq]
exact eq_weighted_vsub_of_point_subset_iff_eq_weighted_vsub_of_point_subtype
intros
rw [collinear_iff_dim_le_one, vector_span_singleton]
simp
intros
rw equiv.comp_swap_eq_update
convert f.map_update_update v hij (v i + v j)
simp [f.map_update_self _ hij, f.map_update_self _ hij.symm, function.update_comm hij (v i + v j) (v _) v, function.update_comm hij.symm (v i) (v i) v]
intros
simpa [disjoint] using @disjoint_ker' _ _ _ _ _ _ _ _ _ _ _ f ⊤
intros
{ ext, simp [conj_apply], }
ext
simp [conj_apply]
intros
conv_lhs { rw [pi_eq_sum_univ x, f.map_sum] }
apply finset.sum_congr rfl (λl hl, _)
rw f.map_smul
intros
simp only [constr_def, linear_map.comp_apply, finsupp.lmap_domain_apply, finsupp.total_apply]
{ simp only [constr_def, linear_map.comp_apply, finsupp.lmap_domain_apply, finsupp.total_apply], rw finsupp.sum_map_domain_index; simp [add_smul] }
rw finsupp.sum_map_domain_index; simp [add_smul]
rw finsupp.sum_map_domain_index
simp [add_smul]
simp [add_smul]
simp [add_smul]
intros
rw [←@zero_smul _ _ _ _ _ (0 : M), smul_right, zero_mul]
intros
rw [dual_basis, basis.map_repr, linear_equiv.symm_symm, linear_equiv.trans_apply, basis.dual_basis_repr, to_dual_def]
intros
simp only [coevaluation, id]
rw [(basis.singleton unit K).constr_apply_fintype K]
simp only [fintype.univ_punit, finset.sum_const, one_smul, basis.singleton_repr, basis.equiv_fun_apply,basis.coe_of_vector_space, one_nsmul, finset.card_singleton]
intros
rw mem_supr_iff_exists_dfinsupp
simp_rw [dfinsupp.lsum_apply_apply, dfinsupp.sum_add_hom_apply]
congr'
intros
rw [← dim_range_add_dim_ker f, ← dim_range_of_surjective f h]
intros
{ rw ← s.finrank_quotient_add_finrank, exact nat.le_add_left _ _ }
rw ← s.finrank_quotient_add_finrank
exact nat.le_add_left _ _
intros
rw [set.inter_eq_Inter, supported_Inter, infi_bool_eq]
rw [set.inter_eq_Inter, supported_Inter, infi_bool_eq]; refl
refl
intros
conv_rhs { rw [← (finsupp_prod_lequiv R).apply_symm_apply f, finsupp_prod_lequiv_apply, prod.mk.eta] }
intros
revert N
refine induction_on_rank b _ _ O
intros M ih N N_le_M
obtain ⟨m, b'M⟩ := M.basis_of_pid b
by_cases N_bot : N = ⊥
subst N_bot
{ subst N_bot, exact ⟨0, m, nat.zero_le _, b'M, basis.empty _, fin_zero_elim, fin_zero_elim⟩ }
exact ⟨0, m, nat.zero_le _, b'M, basis.empty _, fin_zero_elim, fin_zero_elim⟩
obtain ⟨y, hy, a, hay, M', M'_le_M, N', N'_le_N, N'_le_M', y_ortho, ay_ortho, h⟩ := submodule.basis_of_pid_aux M N b'M N_bot N_le_M
obtain ⟨n', m', hn'm', bM', bN', as', has'⟩ := ih M' M'_le_M y hy y_ortho N' N'_le_M'
obtain ⟨bN, h'⟩ := h n' bN'
obtain ⟨hmn, bM, h''⟩ := h' m' hn'm' bM'
obtain ⟨as, has⟩ := h'' as' has'
exact ⟨_, _, hmn, bM, bN, as, has⟩
intros
rw [finsupp.total_on, linear_map.ker, linear_map.comap_cod_restrict, map_bot, comap_bot, linear_map.ker_comp, linear_independent_subtype_disjoint, disjoint, ← map_comap_subtype, map_le_iff_le_comap, comap_bot, ker_subtype, le_bot_iff]
intros
let n : ℕ := (Sup (finset.image b finset.univ : set ℕ)).succ
have hn : ∀ i, b i < n
have hbi : ∀ i, b i ∈ finset.image b finset.univ
{ have hbi : ∀ i, b i ∈ finset.image b finset.univ, { simp }, intro i, dsimp only [n], apply nat.lt_succ_iff.mpr, exact le_cSup (finset.bdd_above _) (hbi i) }
simp
{ simp }
intro i
dsimp only [n]
apply nat.lt_succ_iff.mpr
exact le_cSup (finset.bdd_above _) (hbi i)
rw det_of_block_triangular_matrix M b h n hn
refine (finset.prod_subset _ _).symm
intros a ha
{ intros a ha, apply finset.mem_range.mpr, obtain ⟨i, ⟨hi, hbi⟩⟩ := finset.mem_image.mp ha, rw ←hbi, exact hn i }
apply finset.mem_range.mpr
obtain ⟨i, ⟨hi, hbi⟩⟩ := finset.mem_image.mp ha
rw ←hbi
exact hn i
intros k hk hbk
{ intros k hk hbk, apply det_eq_one_of_card_eq_zero, apply fintype.card_eq_zero_iff.mpr, constructor, simp only [subtype.forall], intros a hba, apply hbk, apply finset.mem_image.mpr, use a, exact ⟨finset.mem_univ a, hba⟩ }
apply det_eq_one_of_card_eq_zero
apply fintype.card_eq_zero_iff.mpr
constructor
simp only [subtype.forall]
intros a hba
apply hbk
apply finset.mem_image.mpr
use a
exact ⟨finset.mem_univ a, hba⟩
intros
ext i j
simp only [mul_apply, mul_vec, circulant, dot_product]
refine fintype.sum_equiv (equiv.sub_right j) _ _ _
intro x
simp only [equiv.sub_right_apply, sub_sub_sub_cancel_right]
intros
simp [det_update_row_add, det_zero_of_row_eq hij ((update_row_self).trans (update_row_ne hij.symm).symm)]
intros
split
intros h
{ intros h, refine ⟨λ i j hij, _, ext $ λ i j, _, ext $ λ i j, _, λ i j hij, _⟩, { exact h (sum.inl_injective.ne hij), }, { exact h sum.inl_ne_inr, }, { exact h sum.inr_ne_inl, }, { exact h (sum.inr_injective.ne hij), }, }
refine ⟨λ i j hij, _, ext $ λ i j, _, ext $ λ i j, _, λ i j hij, _⟩
{ exact h (sum.inl_injective.ne hij), }
exact h (sum.inl_injective.ne hij)
{ exact h sum.inl_ne_inr, }
exact h sum.inl_ne_inr
{ exact h sum.inr_ne_inl, }
exact h sum.inr_ne_inl
{ exact h (sum.inr_injective.ne hij), }
exact h (sum.inr_injective.ne hij)
rintros ⟨ha, hb, hc, hd⟩
{ rintros ⟨ha, hb, hc, hd⟩, convert is_diag.from_blocks ha hd }
convert is_diag.from_blocks ha hd
intros
rw [show (@has_mul.mul (M₁ →ₗ[R] M₁) _) = linear_map.comp, from rfl, linear_map.to_matrix_comp v₁ v₁ v₁ f g]
{ rw [show (@has_mul.mul (M₁ →ₗ[R] M₁) _) = linear_map.comp, from rfl, linear_map.to_matrix_comp v₁ v₁ v₁ f g] }
intros
refine iff.trans _ (not_iff_not.mpr exists_vec_mul_eq_zero_iff)
simp only [not_exists]
split
intros hM v hv hMv
{ intros hM v hv hMv, obtain ⟨w, hwMv⟩ := hM.exists_not_ortho_of_ne_zero hv, simpa only [dot_product_mul_vec, hMv, zero_dot_product] using hwMv }
obtain ⟨w, hwMv⟩ := hM.exists_not_ortho_of_ne_zero hv
simpa only [dot_product_mul_vec, hMv, zero_dot_product] using hwMv
intros h v hv
{ intros h v hv, refine not_imp_not.mp (h v) (funext $ λ i, _), simpa only [dot_product_mul_vec, dot_product_single, mul_one] using hv (pi.single i 1) }
refine not_imp_not.mp (h v) (funext $ λ i, _)
simpa only [dot_product_mul_vec, dot_product_single, mul_one] using hv (pi.single i 1)
intros
ext x
ext x; simp [(⟨0, zero_mem _⟩ : ∃ x, x ∈ q)]
simp [(⟨0, zero_mem _⟩ : ∃ x, x ∈ q)]
intros
simp [linear_proj_of_is_compl]
intros
simp [sub_eq_add_neg]
intros
ext ⟨j', i'⟩
by_cases hj : j = j'
subst hj
{ subst hj, simp only [pi.basis, linear_equiv.trans_apply, basis.repr_self, std_basis_same, linear_equiv.Pi_congr_right_apply, finsupp.sigma_finsupp_lequiv_pi_finsupp_symm_apply], symmetry, exact basis.finsupp.single_apply_left (λ i i' (h : (⟨j, i⟩ : Σ j, ιs j) = ⟨j, i'⟩), eq_of_heq (sigma.mk.inj h).2) _ _ _ }
simp only [pi.basis, linear_equiv.trans_apply, basis.repr_self, std_basis_same, linear_equiv.Pi_congr_right_apply, finsupp.sigma_finsupp_lequiv_pi_finsupp_symm_apply]
symmetry
exact basis.finsupp.single_apply_left (λ i i' (h : (⟨j, i⟩ : Σ j, ιs j) = ⟨j, i'⟩), eq_of_heq (sigma.mk.inj h).2) _ _ _
simp only [pi.basis, linear_equiv.trans_apply, finsupp.sigma_finsupp_lequiv_pi_finsupp_symm_apply, linear_equiv.Pi_congr_right_apply]
dsimp
rw [std_basis_ne _ _ _ _ (ne.symm hj), linear_equiv.map_zero, finsupp.zero_apply, finsupp.single_eq_of_ne]
rintros ⟨⟩
contradiction
intros
split_ifs; simp
{ split_ifs; simp }
split_ifs
simp
simp
intros
simp only [ltensor, rtensor, ← map_comp, id_comp, comp_id]
intros
rw [← s.neg_le_neg_iff _ hu, neg_zero] at hsu
rw [← s.neg_le_neg_iff _ hv, neg_zero] at hsv
have := of_inter_eq_of_symm_diff_eq_zero_positive hu hv hw hsu hsv
simp only [pi.neg_apply, neg_inj, neg_eq_zero, coe_neg] at this
exact this hs
intros
rw sub_eq_add_neg at hst
rw [sub_eq_add_neg, sub_eq_add_neg]
exactI ae_eq_trans (rn_deriv_add _ _ _) (filter.eventually_eq.add (ae_eq_refl _) (rn_deriv_neg _ _))
intros
rw [← of_real_integral_norm_eq_lintegral_nnnorm hfi, ← of_real_integral_norm_eq_lintegral_nnnorm hgi, ennreal.of_real_le_of_real_iff]
exact integral_norm_le_of_forall_fin_meas_integral_eq hm hf hfi hg hgi hgf hs hμs
{ exact integral_norm_le_of_forall_fin_meas_integral_eq hm hf hfi hg hgi hgf hs hμs, }
{ exact integral_nonneg (λ x, norm_nonneg _), }
exact integral_nonneg (λ x, norm_nonneg _)
intros
rw edist_def
{ rw edist_def, exact snorm_congr_ae (hf.coe_fn_to_Lp.sub hg.coe_fn_to_Lp) }
exact snorm_congr_ae (hf.coe_fn_to_Lp.sub hg.coe_fn_to_Lp)
intros
rw Lp.eq_zero_iff_ae_eq_zero
convert indicator_const_Lp_coe_fn
simp [set.indicator_empty']
intros
simp_rw [cauchy_seq_iff_tendsto_dist_at_top_0, dist_def]
rw [← ennreal.zero_to_real, ennreal.tendsto_to_real_iff (λ n, _) ennreal.zero_ne_top]
rw snorm_congr_ae (Lp.coe_fn_sub _ _).symm
exact snorm_ne_top _
intros
simp [snorm']
intros
delta integrable_on
{ delta integrable_on, rw measure.restrict_add, exact hμ.integrable.add_measure hν }
rw measure.restrict_add
exact hμ.integrable.add_measure hν
intros
by_cases hc : c = 0; simp [hc]
by_cases hc : c = 0
simp [hc]
simp [hc]
intros
rw [integral_interval_sub_interval_comm hab hcd hac, integral_symm b d, integral_symm a c, sub_neg_eq_add, sub_eq_neg_add]
{ rw [integral_interval_sub_interval_comm hab hcd hac, integral_symm b d, integral_symm a c, sub_neg_eq_add, sub_eq_neg_add], }
intros
simpa [tsum_fintype] using lintegral_sum_measure f (λ b, cond b μ ν)
intros
convert h_supr (λ n, (eapprox f n).measurable) (monotone_eapprox f) _
{ ext1 x, rw [supr_eapprox_apply f hf] }
ext1 x
rw [supr_eapprox_apply f hf]
exact λ n, simple_func.induction (λ c s hs, h_ind c hs) (λ f g hfg hf hg, h_add hfg f.measurable g.measurable hf hg) (eapprox f n)
{ exact λ n, simple_func.induction (λ c s hs, h_ind c hs) (λ f g hfg hf hg, h_add hfg f.measurable g.measurable hf hg) (eapprox f n) }
intros
cases f; cases g; congr; exact H
cases f; cases g; congr
cases f; cases g
cases f
cases g
congr
exact H
intros
apply measurable_pi_iff.2 (λ j, _)
by_cases hj : p j
simp only [hj, dif_pos, equiv.pi_equiv_pi_subtype_prod_symm_apply]
{ simp only [hj, dif_pos, equiv.pi_equiv_pi_subtype_prod_symm_apply], have : measurable (λ (f : (Π (i : {x // p x}), π ↑i)), f ⟨j, hj⟩) := measurable_pi_apply ⟨j, hj⟩, exact measurable.comp this measurable_fst }
have : measurable (λ (f : (Π (i : {x // p x}), π ↑i)), f ⟨j, hj⟩) := measurable_pi_apply ⟨j, hj⟩
exact measurable.comp this measurable_fst
simp only [hj, equiv.pi_equiv_pi_subtype_prod_symm_apply, dif_neg, not_false_iff]
{ simp only [hj, equiv.pi_equiv_pi_subtype_prod_symm_apply, dif_neg, not_false_iff], have : measurable (λ (f : (Π (i : {x // ¬ p x}), π ↑i)), f ⟨j, hj⟩) := measurable_pi_apply ⟨j, hj⟩, exact measurable.comp this measurable_snd }
have : measurable (λ (f : (Π (i : {x // ¬ p x}), π ↑i)), f ⟨j, hj⟩) := measurable_pi_apply ⟨j, hj⟩
exact measurable.comp this measurable_snd
intros
simp only [apply_eq_coe_to_fun]
{ simp only [apply_eq_coe_to_fun], norm_cast, exact μ.sup_le' _ _ }
norm_cast
exact μ.sup_le' _ _
intros
refine le_antisymm (mul_left_index_le hK hV g) _
convert mul_left_index_le (hK.image $ continuous_mul_left g) hV g⁻¹
rw [image_image]
symmetry
convert image_id' _
ext h
apply inv_mul_cancel_left
intros
let ι := fin (finrank ℝ E)
haveI : finite_dimensional ℝ (ι → ℝ) := by apply_instance
have : finrank ℝ E = finrank ℝ (ι → ℝ)
simp
simp
have e : E ≃ₗ[ℝ] ι → ℝ := linear_equiv.of_finrank_eq E (ι → ℝ) this
obtain ⟨g, hg⟩ : ∃ g, g = (e : E →ₗ[ℝ] (ι → ℝ)).comp (f.comp (e.symm : (ι → ℝ) →ₗ[ℝ] E)) := ⟨_, rfl⟩
have gdet : g.det = f.det
rw [hg]
rw [hg]
{ rw [hg], exact linear_map.det_conj f e }
{ rw [hg], exact linear_map.det_conj f e }
exact linear_map.det_conj f e
exact linear_map.det_conj f e
rw ← gdet at hf ⊢
have fg : f = (e.symm : (ι → ℝ) →ₗ[ℝ] E).comp (g.comp (e : E →ₗ[ℝ] (ι → ℝ)))
ext x
{ ext x, simp only [linear_equiv.coe_coe, function.comp_app, linear_map.coe_comp, linear_equiv.symm_apply_apply, hg] }
simp only [linear_equiv.coe_coe, function.comp_app, linear_map.coe_comp, linear_equiv.symm_apply_apply, hg]
simp only [fg, linear_equiv.coe_coe, linear_map.coe_comp]
have Ce : continuous e := (e : E →ₗ[ℝ] (ι → ℝ)).continuous_of_finite_dimensional
have Cg : continuous g := linear_map.continuous_of_finite_dimensional g
have Cesymm : continuous e.symm := (e.symm : (ι → ℝ) →ₗ[ℝ] E).continuous_of_finite_dimensional
rw [← map_map Cesymm.measurable (Cg.comp Ce).measurable, ← map_map Cg.measurable Ce.measurable]
haveI : is_add_haar_measure (map e μ) := is_add_haar_measure_map μ e.to_add_equiv Ce Cesymm
have ecomp : (e.symm) ∘ e = id
ext x
ext x
{ ext x, simp only [id.def, function.comp_app, linear_equiv.symm_apply_apply] }
{ ext x, simp only [id.def, function.comp_app, linear_equiv.symm_apply_apply] }
simp only [id.def, function.comp_app, linear_equiv.symm_apply_apply]
simp only [id.def, function.comp_app, linear_equiv.symm_apply_apply]
rw [map_linear_map_add_haar_pi_eq_smul_add_haar hf (map e μ), linear_map.map_smul, map_map Cesymm.measurable Ce.measurable, ecomp, measure.map_id]
intros
simp only [volume_pi_closed_ball a hr, volume_closed_ball, finset.prod_const]
exact (ennreal.of_real_pow (mul_nonneg zero_le_two hr) _).symm
intros
haveI := hs.to_encodable
rw bUnion_eq_Union
exact measure_Union (hd.on_injective subtype.coe_injective $ λ x, x.2) (λ x, h x x.2)
intros
contrapose! hμ
simpa [measure_univ_nnreal_eq_zero, le_zero_iff] using hμ
intros
rw [ennreal.tsum_eq_supr_sum]
exact supr_le (λ s, sum_measure_le_measure_univ (λ i hi, hs i) (λ i hi j hj hij, H i j hij))
intros
simp [eventually_le_antisymm_iff, ae_le_set]
intros
set g := λ i : ℕ, ⋃ (b : β) (H : b ∈ encodable.decode₂ β i), f b with hg
have hg₁ : ∀ i, measurable_set (g i)
exact λ _, measurable_set.Union (λ b, measurable_set.Union_Prop $ λ _, hf₁ b)
{ exact λ _, measurable_set.Union (λ b, measurable_set.Union_Prop $ λ _, hf₁ b) }
have hg₂ : pairwise (disjoint on g)
{ exact encodable.Union_decode₂_disjoint_on hf₂ }
exact encodable.Union_decode₂_disjoint_on hf₂
have := v.of_disjoint_Union_nat hg₁ hg₂
rw [hg, encodable.Union_decode₂] at this
have hg₃ : (λ (i : β), v (f i)) = (λ i, v (g (encodable.encode i)))
ext
{ ext, rw hg, simp only, congr, ext y, simp only [exists_prop, mem_Union, option.mem_def], split, { intro hy, refine ⟨x, (encodable.decode₂_is_partial_inv _ _).2 rfl, hy⟩ }, { rintro ⟨b, hb₁, hb₂⟩, rw (encodable.decode₂_is_partial_inv _ _) at hb₁, rwa ← encodable.encode_injective hb₁ } }
rw hg
simp only
congr
ext y
simp only [exists_prop, mem_Union, option.mem_def]
split
intro hy
{ intro hy, refine ⟨x, (encodable.decode₂_is_partial_inv _ _).2 rfl, hy⟩ }
refine ⟨x, (encodable.decode₂_is_partial_inv _ _).2 rfl, hy⟩
rintro ⟨b, hb₁, hb₂⟩
{ rintro ⟨b, hb₁, hb₂⟩, rw (encodable.decode₂_is_partial_inv _ _) at hb₁, rwa ← encodable.encode_injective hb₁ }
rw (encodable.decode₂_is_partial_inv _ _) at hb₁
rwa ← encodable.encode_injective hb₁
rw [summable.has_sum_iff, this, ← tsum_Union_decode₂]
{ exact v.empty }
exact v.empty
rw hg₃
{ rw hg₃, change summable ((λ i, v (g i)) ∘ encodable.encode), rw function.injective.summable_iff encodable.encode_injective, { exact (v.m_Union hg₁ hg₂).summable }, { intros x hx, convert v.empty, simp only [Union_eq_empty, option.mem_def, not_exists, mem_range] at ⊢ hx, intros i hi, exact false.elim ((hx i) ((encodable.decode₂_is_partial_inv _ _).1 hi)) } }
change summable ((λ i, v (g i)) ∘ encodable.encode)
rw function.injective.summable_iff encodable.encode_injective
{ exact (v.m_Union hg₁ hg₂).summable }
exact (v.m_Union hg₁ hg₂).summable
intros x hx
{ intros x hx, convert v.empty, simp only [Union_eq_empty, option.mem_def, not_exists, mem_range] at ⊢ hx, intros i hi, exact false.elim ((hx i) ((encodable.decode₂_is_partial_inv _ _).1 hi)) }
convert v.empty
simp only [Union_eq_empty, option.mem_def, not_exists, mem_range] at ⊢ hx
intros i hi
exact false.elim ((hx i) ((encodable.decode₂_is_partial_inv _ _).1 hi))
intros
rw [sub_eq_add_neg, sub_eq_add_neg, with_densityᵥ_add hf hg.neg, with_densityᵥ_neg]
intros
simp [map]
intros
ext x
rw [ppow_apply (nat.succ_pos k), pow_succ']
induction k; simp
induction k
simp
simp
intros
simp [bernoulli, ← mul_assoc, ← sq, ← pow_mul, mul_comm n 2, pow_mul]
intros
apply finset.ext
simp only [h, mem_filter, and_true, and_iff_right_iff_imp, cast_id, mem_range, ne.def, not_false_iff, mem_divisors]
intros a ha
exact nat.lt_succ_of_le (nat.divisor_le (nat.mem_divisors.2 ⟨ha, h⟩))
intros
cases i; simp [s_mod]
cases i
simp [s_mod]
simp [s_mod]
intros
{ dsimp [s_mod, mersenne], rw [h1, h2, sq, h3] }
dsimp [s_mod, mersenne]
rw [h1, h2, sq, h3]
intros
simp [has_norm.norm, padic_norm_e.mul']
intros
injection (pell_zd_add _ m n) with h _; repeat {rw ← int.coe_nat_add at h <|> rw ← int.coe_nat_mul at h}; exact int.coe_nat_inj h
injection (pell_zd_add _ m n) with h _; repeat {rw ← int.coe_nat_add at h <|> rw ← int.coe_nat_mul at h}
injection (pell_zd_add _ m n) with h _
repeat {rw ← int.coe_nat_add at h <|> rw ← int.coe_nat_mul at h}
rw ← int.coe_nat_add at h
rw ← int.coe_nat_mul at h
exact int.coe_nat_inj h
intros
split
intro h
{ intro h, obtain ⟨k, m, n, H⟩ := h.classified, use [k, m, n], rcases H with ⟨rfl, rfl⟩ | ⟨rfl, rfl⟩, { refine ⟨or.inl ⟨rfl, rfl⟩, _⟩, have : z ^ 2 = (k * (m ^ 2 + n ^ 2)) ^ 2, { rw [sq, ← h.eq], ring }, simpa using eq_or_eq_neg_of_sq_eq_sq _ _ this }, { refine ⟨or.inr ⟨rfl, rfl⟩, _⟩, have : z ^ 2 = (k * (m ^ 2 + n ^ 2)) ^ 2, { rw [sq, ← h.eq], ring }, simpa using eq_or_eq_neg_of_sq_eq_sq _ _ this } }
obtain ⟨k, m, n, H⟩ := h.classified
use [k, m, n]
rcases H with ⟨rfl, rfl⟩ | ⟨rfl, rfl⟩
refine ⟨or.inl ⟨rfl, rfl⟩, _⟩
{ refine ⟨or.inl ⟨rfl, rfl⟩, _⟩, have : z ^ 2 = (k * (m ^ 2 + n ^ 2)) ^ 2, { rw [sq, ← h.eq], ring }, simpa using eq_or_eq_neg_of_sq_eq_sq _ _ this }
have : z ^ 2 = (k * (m ^ 2 + n ^ 2)) ^ 2
{ rw [sq, ← h.eq], ring }
rw [sq, ← h.eq]
ring
simpa using eq_or_eq_neg_of_sq_eq_sq _ _ this
refine ⟨or.inr ⟨rfl, rfl⟩, _⟩
{ refine ⟨or.inr ⟨rfl, rfl⟩, _⟩, have : z ^ 2 = (k * (m ^ 2 + n ^ 2)) ^ 2, { rw [sq, ← h.eq], ring }, simpa using eq_or_eq_neg_of_sq_eq_sq _ _ this }
have : z ^ 2 = (k * (m ^ 2 + n ^ 2)) ^ 2
{ rw [sq, ← h.eq], ring }
rw [sq, ← h.eq]
ring
simpa using eq_or_eq_neg_of_sq_eq_sq _ _ this
rintro ⟨k, m, n, ⟨rfl, rfl⟩ | ⟨rfl, rfl⟩, rfl | rfl⟩; delta pythagorean_triple; ring
rintro ⟨k, m, n, ⟨rfl, rfl⟩ | ⟨rfl, rfl⟩, rfl | rfl⟩; delta pythagorean_triple
rintro ⟨k, m, n, ⟨rfl, rfl⟩ | ⟨rfl, rfl⟩, rfl | rfl⟩
{ rintro ⟨k, m, n, ⟨rfl, rfl⟩ | ⟨rfl, rfl⟩, rfl | rfl⟩; delta pythagorean_triple; ring }
delta pythagorean_triple
ring
delta pythagorean_triple
ring
delta pythagorean_triple
ring
delta pythagorean_triple
ring
intros
apply sq_add_sq_of_nat_prime_of_not_irreducible p
rw [principal_ideal_ring.irreducible_iff_prime, prime_iff_mod_four_eq_three_of_nat_prime p, hp1]
norm_num
intros
refine ⟨_, _, _, _⟩; { intros xy zw, have := int.mul_nonneg (sub_nonneg_of_le (int.coe_nat_le_coe_nat_of_le xy)) (sub_nonneg_of_le (int.coe_nat_le_coe_nat_of_le zw)), refine int.le_of_coe_nat_le_coe_nat (le_of_sub_nonneg _), convert this, simp only [one_mul, int.coe_nat_add, int.coe_nat_mul], ring }
refine ⟨_, _, _, _⟩
{ intros xy zw, have := int.mul_nonneg (sub_nonneg_of_le (int.coe_nat_le_coe_nat_of_le xy)) (sub_nonneg_of_le (int.coe_nat_le_coe_nat_of_le zw)), refine int.le_of_coe_nat_le_coe_nat (le_of_sub_nonneg _), convert this, simp only [one_mul, int.coe_nat_add, int.coe_nat_mul], ring }
{ intros xy zw, have := int.mul_nonneg (sub_nonneg_of_le (int.coe_nat_le_coe_nat_of_le xy)) (sub_nonneg_of_le (int.coe_nat_le_coe_nat_of_le zw)), refine int.le_of_coe_nat_le_coe_nat (le_of_sub_nonneg _), convert this, simp only [one_mul, int.coe_nat_add, int.coe_nat_mul], ring }
{ intros xy zw, have := int.mul_nonneg (sub_nonneg_of_le (int.coe_nat_le_coe_nat_of_le xy)) (sub_nonneg_of_le (int.coe_nat_le_coe_nat_of_le zw)), refine int.le_of_coe_nat_le_coe_nat (le_of_sub_nonneg _), convert this, simp only [one_mul, int.coe_nat_add, int.coe_nat_mul], ring }
intros xy zw
{ intros xy zw, have := int.mul_nonneg (sub_nonneg_of_le (int.coe_nat_le_coe_nat_of_le xy)) (sub_nonneg_of_le (int.coe_nat_le_coe_nat_of_le zw)), refine int.le_of_coe_nat_le_coe_nat (le_of_sub_nonneg _), convert this, simp only [one_mul, int.coe_nat_add, int.coe_nat_mul], ring }
have := int.mul_nonneg (sub_nonneg_of_le (int.coe_nat_le_coe_nat_of_le xy)) (sub_nonneg_of_le (int.coe_nat_le_coe_nat_of_le zw))
refine int.le_of_coe_nat_le_coe_nat (le_of_sub_nonneg _)
convert this
simp only [one_mul, int.coe_nat_add, int.coe_nat_mul]
ring
intros
simp [to_complex_def]
intros
{ ext x y, exact H x y }
ext x y
exact H x y
intros
rw sup_eq_left
{ rw sup_eq_left, exact sdiff_le }
exact sdiff_le
intros
rw [sdiff_sdiff_left, sdiff_sup]
intros
simp [(≤)]
intros
exact is_greatest_singleton.union hs
intros
simp only [← Sup_range, Sup_eq_top, set.exists_range_iff]
intros
rw [supr, supr, ← image_eq_range, ← range_comp]
intros
ext n
induction n with k ih
rw [partial_sups_zero, partial_sups_zero, disjointed_zero]
{ rw [partial_sups_zero, partial_sups_zero, disjointed_zero] }
rw [partial_sups_succ, partial_sups_succ, disjointed_succ, ih, sup_sdiff_self_right]
{ rw [partial_sups_succ, partial_sups_succ, disjointed_succ, ih, sup_sdiff_self_right] }
intros
simp [at_top, ← e.surjective.infi_comp]
intros
simp only [tendsto_def, mem_at_top_sets]; refl
simp only [tendsto_def, mem_at_top_sets]
refl
intros
simpa using hl.mem_iff
intros
simp only [filter.frequently, eventually_sup, not_and_distrib]
intros
refine le_antisymm (le_map $ λ s hs, _) (le_seq $ λ s hs t ht, _)
rw ← seq_singleton
{ rw ← seq_singleton, exact seq_mem_seq hs singleton_mem_pure }
exact seq_mem_seq hs singleton_mem_pure
refine sets_of_superset (map (λg:α→β, g a) f) (image_mem_map hs) _
{ refine sets_of_superset (map (λg:α→β, g a) f) (image_mem_map hs) _, rintro b ⟨g, hg, rfl⟩, exact ⟨g, hg, a, ht, rfl⟩ }
rintro b ⟨g, hg, rfl⟩
exact ⟨g, hg, a, ht, rfl⟩
intros
rw [filter.prod, comap_sup, inf_sup_left, ← filter.prod, ← filter.prod]
intros
rw [mem_top_iff_forall, eq_univ_iff_forall]
intros
simp only [bUnion_eq_Union]
haveI := hS.to_encodable
exact eventually_le.countable_Union (λ i, h i i.2)
intros
simp
intros
rw [limsup_eq, eq_bot_iff]
exact Inf_le (eventually_of_forall (λ x, le_refl _))
intros
rw [symm_diff_eq_sup_sdiff_inf]
exact disjoint_sdiff_self_left
intros
rw [iff_forall_not_is_bad_seq, ← not_exists, not_congr]
split
{ apply exists_min_bad_of_exists_bad }
apply exists_min_bad_of_exists_bad
rintro ⟨f, hf1, hf2⟩
exact ⟨f, hf1⟩
intros
rw [← mk_C x, lift_mk, eval₂_C]
intros
{ rcases h with ⟨p, hp, hpx⟩, exact ⟨p, hp.ne_zero, hpx⟩ }
rcases h with ⟨p, hp, hpx⟩
exact ⟨p, hp.ne_zero, hpx⟩
intros
rw [← finset.card_range m, ← finset.prod_const]
{ rw [← finset.card_range m, ← finset.prod_const], exact is_coprime.prod_left (λ _ _, H) }
exact is_coprime.prod_left (λ _ _, H)
intros
obtain rfl : m = n := unit_mul_pow_congr_pow hirr hirr u v m n h
rw ← sub_eq_zero at h
rw [← sub_mul, mul_eq_zero] at h
cases h
{ rw sub_eq_zero at h, exact_mod_cast h }
rw sub_eq_zero at h
exact_mod_cast h
{ apply (hirr.ne_zero (pow_eq_zero h)).elim, }
apply (hirr.ne_zero (pow_eq_zero h)).elim
intros
ext y
refine (mem_coe_ideal S).trans (iff.trans _ (mem_span_singleton S).symm)
split
rintros ⟨y', hy', rfl⟩
{ rintros ⟨y', hy', rfl⟩, obtain ⟨x', rfl⟩ := submodule.mem_span_singleton.mp hy', use x', rw [smul_eq_mul, ring_hom.map_mul, algebra.smul_def] }
obtain ⟨x', rfl⟩ := submodule.mem_span_singleton.mp hy'
use x'
rw [smul_eq_mul, ring_hom.map_mul, algebra.smul_def]
rintros ⟨y', rfl⟩
{ rintros ⟨y', rfl⟩, refine ⟨y' * x, submodule.mem_span_singleton.mpr ⟨y', rfl⟩, _⟩, rw [ring_hom.map_mul, algebra.smul_def] }
refine ⟨y' * x, submodule.mem_span_singleton.mpr ⟨y', rfl⟩, _⟩
rw [ring_hom.map_mul, algebra.smul_def]
intros
ext x
simp only [mem_coe_ideal]
split
rintro ⟨_, ⟨y, hy, rfl⟩, rfl⟩
{ rintro ⟨_, ⟨y, hy, rfl⟩, rfl⟩, exact ⟨y, hy, (g.commutes y).symm⟩ }
exact ⟨y, hy, (g.commutes y).symm⟩
rintro ⟨y, hy, rfl⟩
{ rintro ⟨y, hy, rfl⟩, exact ⟨_, ⟨y, hy, rfl⟩, g.commutes y⟩ }
exact ⟨_, ⟨y, hy, rfl⟩, g.commutes y⟩
intros
by_contradiction hnonmax
rcases exists_le_maximal J hnonmax with ⟨M, hM1, hM2⟩
exact hmax M (lt_of_lt_of_le hPJ hM2) hM1
intros
split
intro h
{ intro h, obtain ⟨x, nz, nu⟩ := exists_not_is_unit_of_not_is_field h, use ideal.span {x}, rw [bot_lt_iff_ne_bot, lt_top_iff_ne_top], exact ⟨mt ideal.span_singleton_eq_bot.mp nz, mt ideal.span_singleton_eq_top.mp nu⟩ }
obtain ⟨x, nz, nu⟩ := exists_not_is_unit_of_not_is_field h
use ideal.span {x}
rw [bot_lt_iff_ne_bot, lt_top_iff_ne_top]
exact ⟨mt ideal.span_singleton_eq_bot.mp nz, mt ideal.span_singleton_eq_top.mp nu⟩
rintros ⟨I, bot_lt, lt_top⟩ hf
{ rintros ⟨I, bot_lt, lt_top⟩ hf, obtain ⟨x, mem, ne_zero⟩ := set_like.exists_of_lt bot_lt, rw submodule.mem_bot at ne_zero, obtain ⟨y, hy⟩ := hf.mul_inv_cancel ne_zero, rw [lt_top_iff_ne_top, ne.def, ideal.eq_top_iff_one, ← hy] at lt_top, exact lt_top (I.mul_mem_right _ mem), }
obtain ⟨x, mem, ne_zero⟩ := set_like.exists_of_lt bot_lt
rw submodule.mem_bot at ne_zero
obtain ⟨y, hy⟩ := hf.mul_inv_cancel ne_zero
rw [lt_top_iff_ne_top, ne.def, ideal.eq_top_iff_one, ← hy] at lt_top
exact lt_top (I.mul_mem_right _ mem)
intros
refine ideal.is_maximal_iff.mpr ⟨λ h1, @one_ne_zero K _ _ $ f.map_one ▸ f.mem_ker.mp h1, λ J x hJ hxf hxJ, _⟩
obtain ⟨y, hy⟩ := hf (f x)⁻¹
have H : 1 = y * x - (y * x - 1) := (sub_sub_cancel _ _).symm
rw H
refine J.sub_mem (J.mul_mem_left _ hxJ) (hJ _)
rw f.mem_ker
simp only [hy, ring_hom.map_sub, ring_hom.map_one, ring_hom.map_mul, inv_mul_cancel (mt f.mem_ker.mpr hxf), sub_self]
intros
induction n with n ih
simp only [pow_zero, ideal.one_eq_top]
{ simp only [pow_zero, ideal.one_eq_top], }
simpa only [pow_succ] using mul_mem_mul hx ih
intros
rw [ne.def, eq_top_iff_not_finite, not_not]
intros
intros v hv
rcases hpq with ⟨p', q', hpq'⟩
simpa [linear_map.mem_ker.1 (submodule.mem_inf.1 hv).1, linear_map.mem_ker.1 (submodule.mem_inf.1 hv).2] using congr_arg (λ p : polynomial R, aeval f p v) hpq'.symm
intros
classical
have h : ∃ (n : ℕ) (r : polynomial R), r.nat_degree = n ∧ r.is_primitive ∧ p ∣ r ∧ q ∣ r := ⟨(p * q).nat_degree, p * q, rfl, hp.mul hq, dvd_mul_right _ _, dvd_mul_left _ _⟩
rcases nat.find_spec h with ⟨r, rdeg, rprim, pr, qr⟩
refine ⟨r, rprim, λ s, ⟨_, λ rs, ⟨pr.trans rs, qr.trans rs⟩⟩⟩
suffices hs : ∀ (n : ℕ) (s : polynomial R), s.nat_degree = n → (p ∣ s ∧ q ∣ s → r ∣ s)
{ apply hs s.nat_degree s rfl }
apply hs s.nat_degree s rfl
clear s
by_contra con
push_neg at con
rcases nat.find_spec con with ⟨s, sdeg, ⟨ps, qs⟩, rs⟩
have s0 : s ≠ 0
{ contrapose! rs, simp [rs] }
contrapose! rs
simp [rs]
have hs := nat.find_min' h ⟨_, s.nat_degree_prim_part, s.is_primitive_prim_part, (hp.dvd_prim_part_iff_dvd s0).2 ps, (hq.dvd_prim_part_iff_dvd s0).2 qs⟩
rw ← rdeg at hs
by_cases sC : s.nat_degree ≤ 0
rw [eq_C_of_nat_degree_le_zero (le_trans hs sC), is_primitive_iff_content_eq_one, content_C, normalize_eq_one] at rprim
{ rw [eq_C_of_nat_degree_le_zero (le_trans hs sC), is_primitive_iff_content_eq_one, content_C, normalize_eq_one] at rprim, rw [eq_C_of_nat_degree_le_zero (le_trans hs sC), ← dvd_content_iff_C_dvd] at rs, apply rs rprim.dvd }
rw [eq_C_of_nat_degree_le_zero (le_trans hs sC), ← dvd_content_iff_C_dvd] at rs
apply rs rprim.dvd
have hcancel := nat_degree_cancel_leads_lt_of_nat_degree_le_nat_degree hs (lt_of_not_ge sC)
rw sdeg at hcancel
apply nat.find_min con hcancel
refine ⟨_, rfl, ⟨dvd_cancel_leads_of_dvd_of_dvd pr ps, dvd_cancel_leads_of_dvd_of_dvd qr qs⟩, λ rcs, rs _⟩
rw ← rprim.dvd_prim_part_iff_dvd s0
rw [cancel_leads, nat.sub_eq_zero_of_le hs, pow_zero, mul_one] at rcs
have h := dvd_add rcs (dvd.intro_left _ rfl)
have hC0 := rprim.ne_zero
rw [ne.def, ← leading_coeff_eq_zero, ← C_eq_zero] at hC0
rw [sub_add_cancel, ← rprim.dvd_prim_part_iff_dvd (mul_ne_zero hC0 s0)] at h
rcases is_unit_prim_part_C r.leading_coeff with ⟨u, hu⟩
apply h.trans (associated.symm ⟨u, _⟩).dvd
rw [prim_part_mul (mul_ne_zero hC0 s0), hu, mul_comm]
intros
rw submodule.mul_le
intros φ hφ ψ hψ c hc
rw [coeff_mul] at hc
obtain ⟨⟨d, e⟩, hde, H⟩ := finset.exists_ne_zero_of_sum_ne_zero hc
have aux : coeff d φ ≠ 0 ∧ coeff e ψ ≠ 0
contrapose! H
{ contrapose! H, by_cases h : coeff d φ = 0; simp only [*, ne.def, not_false_iff, zero_mul, mul_zero] at * }
by_cases h : coeff d φ = 0; simp only [*, ne.def, not_false_iff, zero_mul, mul_zero] at *
by_cases h : coeff d φ = 0
simp only [*, ne.def, not_false_iff, zero_mul, mul_zero] at *
simp only [*, ne.def, not_false_iff, zero_mul, mul_zero] at *
specialize hφ aux.1
specialize hψ aux.2
rw finsupp.mem_antidiagonal at hde
classical
have hd' : d.support ⊆ d.support ∪ e.support := finset.subset_union_left _ _
have he' : e.support ⊆ d.support ∪ e.support := finset.subset_union_right _ _
rw [← hde, ← hφ, ← hψ, finset.sum_subset (finsupp.support_add), finset.sum_subset hd', finset.sum_subset he', ← finset.sum_add_distrib]
{ congr }
congr
intros i hi
all_goals { intros i hi, apply finsupp.not_mem_support_iff.mp }
apply finsupp.not_mem_support_iff.mp
intros i hi
apply finsupp.not_mem_support_iff.mp
intros i hi
apply finsupp.not_mem_support_iff.mp
intros
rw [mul_add, add_comp, mul_X_comp, ←nat.cast_comm, nat_cast_mul_comp, nat.cast_comm, mul_add]
intros
rw ← ideal.span_singleton_prime
{ exact span_X_is_prime }
exact span_X_is_prime
{ intro h, simpa using congr_arg (coeff R 1) h }
intro h
simpa using congr_arg (coeff R 1) h
intros
rw [X_eq, coeff_monomial]
intros
apply mv_polynomial.map_injective (int.cast_ring_hom ℚ) int.cast_injective
simp only [witt_mul, witt_structure_rat, rename_X, X_in_terms_of_W_zero, map_X, witt_polynomial_zero, ring_hom.map_mul, bind₁_X_right, alg_hom.map_mul, map_witt_structure_int]
intros
dsimp [select, select_poly]
split_ifs with hi
{ rw aeval_X }
rw aeval_X
{ rw alg_hom.map_zero }
rw alg_hom.map_zero
intros
induction n with n ih generalizing k
simp only [nat.nat_zero_eq_zero, nat.cast_zero, mul_zero, zero_coeff, witt_mul_n, alg_hom.map_zero, pi.zero_apply]
{ simp only [nat.nat_zero_eq_zero, nat.cast_zero, mul_zero, zero_coeff, witt_mul_n, alg_hom.map_zero, pi.zero_apply], }
rw [witt_mul_n, nat.succ_eq_add_one, nat.cast_add, nat.cast_one, mul_add, mul_one, aeval_bind₁, add_coeff]
{ rw [witt_mul_n, nat.succ_eq_add_one, nat.cast_add, nat.cast_one, mul_add, mul_one, aeval_bind₁, add_coeff], apply eval₂_hom_congr (ring_hom.ext_int _ _) _ rfl, ext1 ⟨b, i⟩, fin_cases b, { simp only [function.uncurry, matrix.cons_val_zero, ih] }, { simp only [function.uncurry, matrix.cons_val_one, matrix.head_cons, aeval_X] } }
apply eval₂_hom_congr (ring_hom.ext_int _ _) _ rfl
ext1 ⟨b, i⟩
fin_cases b
{ simp only [function.uncurry, matrix.cons_val_zero, ih] }
simp only [function.uncurry, matrix.cons_val_zero, ih]
simp only [function.uncurry, matrix.cons_val_one, matrix.head_cons, aeval_X]
{ simp only [function.uncurry, matrix.cons_val_one, matrix.head_cons, aeval_X] }
intros
simp only [ring_hom.mem_ker, truncate, truncate_fun, ring_hom.coe_mk, truncated_witt_vector.ext_iff, truncated_witt_vector.coeff_mk, coeff_zero]
exact subtype.forall
intros
rw [X_in_terms_of_W_eq, mul_assoc, ← C_mul, ← mul_pow, inv_of_mul_self, one_pow, C_1, mul_one]
intros
simp [bit0]
intros
simp [bit1]
intros
cases a; simp [cons]
cases a
simp [cons]
intros
simp only [le_antisymm_iff, ordinal.zero_le, and_true]
rw lt_def; exact or.inr ⟨⟨0, zero_lt_one⟩, (by split; rintros ⟨⟩)⟩
rw lt_def
exact or.inr ⟨⟨0, zero_lt_one⟩, (by split; rintros ⟨⟩)⟩
intros
rw lt_def_le
left
use i
intros
simp [h₂.symm, h₁.symm, termg]; ac_refl
simp [h₂.symm, h₁.symm, termg]
ac_refl
intros
apply val_between_set
apply zero_le
apply lt_of_lt_of_le (lt_add_one _)
simp only [length_set, zero_add, le_max_right]
apply_instance
intros
simp [mul_assoc]
intros
rwa div_eq_mul_inv
intros
simp
intros
simpa only [add_comm] using ((has_sum_nat_add_iff k).1 ((summable_nat_add_iff k).2 h).has_sum).unique h.has_sum
intros
have hx₀' : 0 < abs x₀ := abs_pos.2 hx₀
refine filter.ext (λ t, _)
simp only [exists_prop, set_of_subset_set_of, (nhds_basis_abs_sub_lt x₀).mem_iff, (nhds_basis_abs_sub_lt (1 : α)).mem_iff, filter.mem_map']
refine ⟨λ h, _, λ h, _⟩
obtain ⟨i, hi, hit⟩ := h
{ obtain ⟨i, hi, hit⟩ := h, refine ⟨i / (abs x₀), div_pos hi (abs_pos.2 hx₀), λ x hx, hit _⟩, calc abs (x₀ * x - x₀) = abs (x₀ * (x - 1)) : congr_arg abs (by ring_nf) ... = abs x₀ * abs (x - 1) : abs_mul x₀ (x - 1) ... < abs x₀ * (i / abs x₀) : mul_lt_mul' le_rfl hx (abs_nonneg (x - 1)) (abs_pos.2 hx₀) ... = abs x₀ * i / abs x₀ : by ring ... = i : mul_div_cancel_left i (λ h, hx₀ (abs_eq_zero.1 h)) }
refine ⟨i / (abs x₀), div_pos hi (abs_pos.2 hx₀), λ x hx, hit _⟩
calc abs (x₀ * x - x₀) = abs (x₀ * (x - 1)) : congr_arg abs (by ring_nf) ... = abs x₀ * abs (x - 1) : abs_mul x₀ (x - 1) ... < abs x₀ * (i / abs x₀) : mul_lt_mul' le_rfl hx (abs_nonneg (x - 1)) (abs_pos.2 hx₀) ... = abs x₀ * i / abs x₀ : by ring ... = i : mul_div_cancel_left i (λ h, hx₀ (abs_eq_zero.1 h))
obtain ⟨i, hi, hit⟩ := h
{ obtain ⟨i, hi, hit⟩ := h, refine ⟨i * (abs x₀), mul_pos hi (abs_pos.2 hx₀), λ x hx, _⟩, have : abs (x / x₀ - 1) < i, calc abs (x / x₀ - 1) = abs (x / x₀ - x₀ / x₀) : (by rw div_self hx₀) ... = abs ((x - x₀) / x₀) : congr_arg abs (sub_div x x₀ x₀).symm ... = abs (x - x₀) / abs x₀ : abs_div (x - x₀) x₀ ... < i * abs x₀ / abs x₀ : div_lt_div hx le_rfl (mul_nonneg (le_of_lt hi) (abs_nonneg x₀)) (abs_pos.2 hx₀) ... = i : by rw [← mul_div_assoc', div_self (ne_of_lt $ abs_pos.2 hx₀).symm, mul_one], specialize hit (x / x₀) this, rwa [mul_div_assoc', mul_div_cancel_left x hx₀] at hit }
refine ⟨i * (abs x₀), mul_pos hi (abs_pos.2 hx₀), λ x hx, _⟩
have : abs (x / x₀ - 1) < i
calc abs (x / x₀ - 1) = abs (x / x₀ - x₀ / x₀) : (by rw div_self hx₀) ... = abs ((x - x₀) / x₀) : congr_arg abs (sub_div x x₀ x₀).symm ... = abs (x - x₀) / abs x₀ : abs_div (x - x₀) x₀ ... < i * abs x₀ / abs x₀ : div_lt_div hx le_rfl (mul_nonneg (le_of_lt hi) (abs_nonneg x₀)) (abs_pos.2 hx₀) ... = i : by rw [← mul_div_assoc', div_self (ne_of_lt $ abs_pos.2 hx₀).symm, mul_one]
specialize hit (x / x₀) this
rwa [mul_div_assoc', mul_div_cancel_left x hx₀] at hit
intros
rw [← Ici_inter_Iio, interior_inter, interior_Ici, interior_Iio, Ioi_inter_Iio]
intros
assume y hy
have : is_closed (s ∩ Icc a y)
suffices : s ∩ Icc a y = s ∩ Icc a b ∩ Icc a y
{ suffices : s ∩ Icc a y = s ∩ Icc a b ∩ Icc a y, { rw this, exact is_closed.inter hs is_closed_Icc }, rw [inter_assoc], congr, exact (inter_eq_self_of_subset_right $ Icc_subset_Icc_right hy.2).symm }
{ rw this, exact is_closed.inter hs is_closed_Icc }
rw this
exact is_closed.inter hs is_closed_Icc
rw [inter_assoc]
congr
exact (inter_eq_self_of_subset_right $ Icc_subset_Icc_right hy.2).symm
exact is_closed.mem_of_ge_of_forall_exists_gt this ha hy.1 (λ x hx, hgt x ⟨hx.1, Ico_subset_Ico_right hy.2 hx.2⟩ y hx.2.2)
intros
rw [@is_open_iff_generate_intervals α _ _ t]; exact generate_open.basic _ ⟨a, or.inr rfl⟩
rw [@is_open_iff_generate_intervals α _ _ t]
exact generate_open.basic _ ⟨a, or.inr rfl⟩
intros
rw ← sUnion_empty; exact is_open_sUnion (assume a, false.elim)
rw ← sUnion_empty
exact is_open_sUnion (assume a, false.elim)
intros
rw [dense, dense, closure_closure]
intros
rw ← is_open_compl_iff
split
intros cond F h
{ intros cond F h, by_contradiction c, specialize cond F c, rw compl_mem_iff_not_mem at cond, contradiction }
by_contradiction c
specialize cond F c
rw compl_mem_iff_not_mem at cond
contradiction
intros h1 F h2
{ intros h1 F h2, specialize h1 F, cases F.mem_or_compl_mem S; finish }
specialize h1 F
cases F.mem_or_compl_mem S; finish
cases F.mem_or_compl_mem S
finish
finish
intros
simp
intros
rcases H with ⟨x, hx⟩
refine ⟨⟨x, mem_union_left t (mem_of_mem_inter_left hx)⟩, _⟩
exact is_preconnected.union x (mem_of_mem_inter_left hx) (mem_of_mem_inter_right hx) Hs.is_preconnected Ht.is_preconnected
intros
rw [filter.prod, prod.topological_space, nhds_inf, nhds_induced, nhds_induced]
intros
intros u hu
rw is_open_sum_iff at hu
cases hu with hu₁ hu₂
have : u = inl '' (inl ⁻¹' u) ∪ inr '' (inr ⁻¹' u)
ext (_|_); simp
{ ext (_|_); simp }
ext (_|_)
simp
simp
rw [this, set.image_union, set.image_image, set.image_image]
exact is_open.union (h₁ _ hu₁) (h₂ _ hu₂)
intros
refine ⟨⟨_⟩, function.injective_id.sigma_map (λ i, (hf i).inj)⟩
refine le_antisymm (continuous_iff_le_induced.mp (continuous_sigma_map (λ i, (hf i).continuous))) _
intros s hs
replace hs := is_open_sigma_iff.mp hs
have : ∀ i, ∃ t, is_open t ∧ f i ⁻¹' t = sigma.mk i ⁻¹' s
intro i
{ intro i, apply is_open_induced_iff.mp, convert hs i, exact (hf i).induced.symm }
apply is_open_induced_iff.mp
convert hs i
exact (hf i).induced.symm
choose t ht using this
apply is_open_induced_iff.mpr
refine ⟨⋃ i, sigma.mk i '' t i, is_open_Union (λ i, is_open_map_sigma_mk _ (ht i).1), _⟩
ext ⟨i, x⟩
change (sigma.mk i (f i x) ∈ ⋃ (i : ι), sigma.mk i '' t i) ↔ x ∈ sigma.mk i ⁻¹' s
rw [←(ht i).2, mem_Union]
split
rintro ⟨j, hj⟩
{ rintro ⟨j, hj⟩, rw mem_image at hj, rcases hj with ⟨y, hy₁, hy₂⟩, rcases sigma.mk.inj_iff.mp hy₂ with ⟨rfl, hy⟩, replace hy := eq_of_heq hy, subst y, exact hy₁ }
rw mem_image at hj
rcases hj with ⟨y, hy₁, hy₂⟩
rcases sigma.mk.inj_iff.mp hy₂ with ⟨rfl, hy⟩
replace hy := eq_of_heq hy
subst y
exact hy₁
intro hx
{ intro hx, use i, rw mem_image, exact ⟨f i x, hx, rfl⟩ }
use i
rw mem_image
exact ⟨f i x, hx, rfl⟩
intros
simp [continuous_within_at, nhds_within_restrict'' s h]
intros
rw continuous_iff_continuous_on_univ
apply continuous_on.if; simp; assumption
apply continuous_on.if; simp
apply continuous_on.if
simp
assumption
simp
assumption
simp
assumption
intros
haveI := mem_closure_iff_nhds_within_ne_bot.mp hx
exact tendsto_nhds_unique (tendsto_nhds_lim ⟨y, hf⟩) hf
intros
rw [← (e.is_image_preimage_prod s).frontier.preimage_eq, frontier_prod_univ_eq, (e.is_image_preimage_prod _).preimage_eq, e.source_eq, preimage_inter]
intros
simp only [ennreal.tendsto_nhds ha, mem_at_top_sets, mem_set_of_eq, filter.eventually]
intros
simpa only [closure_compl, compl_compl] using h.compl.closure.compl
intros
simp only [antilipschitz_with_iff_le_mul_nndist, dist_nndist]
{ simp only [antilipschitz_with_iff_le_mul_nndist, dist_nndist], norm_cast }
norm_cast
intros
simp only [diam_le_iff, ball_image_iff]
intros
simp [mem_closure_iff_inf_edist_zero, inf_dist, ennreal.to_real_eq_zero_iff, inf_edist_ne_top h]
intros
simp only [holder_on_with, lipschitz_on_with, nnreal.coe_one, ennreal.rpow_one]
intros
refine (nhds_basis_ball.tendsto_iff nhds_basis_closed_ball).2 (λε εpos, ⟨min r (ε / max K 1), _, λ y hy, _⟩)
{ simp [hr, div_pos εpos, zero_lt_one] }
simp [hr, div_pos εpos, zero_lt_one]
have A : max K 1 ≠ 0 := ne_of_gt (lt_max_iff.2 (or.inr zero_lt_one))
have A : max K 1 ≠ 0 := ne_of_gt (lt_max_iff.2 (or.inr zero_lt_one))
have A : max K 1 ≠ 0 := ne_of_gt (lt_max_iff.2 (or.inr zero_lt_one))
have A : max K 1 ≠ 0 := ne_of_gt (lt_max_iff.2 (or.inr zero_lt_one))
have A : max K 1 ≠ 0 := ne_of_gt (lt_max_iff.2 (or.inr zero_lt_one))
have A : max K 1 ≠ 0 := ne_of_gt (lt_max_iff.2 (or.inr zero_lt_one))
have A : max K 1 ≠ 0 := ne_of_gt (lt_max_iff.2 (or.inr zero_lt_one))
have A : max K 1 ≠ 0 := ne_of_gt (lt_max_iff.2 (or.inr zero_lt_one))
have A : max K 1 ≠ 0 := ne_of_gt (lt_max_iff.2 (or.inr zero_lt_one))
have A : max K 1 ≠ 0 := ne_of_gt (lt_max_iff.2 (or.inr zero_lt_one))
have A : max K 1 ≠ 0 := ne_of_gt (lt_max_iff.2 (or.inr zero_lt_one))
have A : max K 1 ≠ 0 := ne_of_gt (lt_max_iff.2 (or.inr zero_lt_one))
have A : max K 1 ≠ 0 := ne_of_gt (lt_max_iff.2 (or.inr zero_lt_one))
have A : max K 1 ≠ 0 := ne_of_gt (lt_max_iff.2 (or.inr zero_lt_one))
have A : max K 1 ≠ 0 := ne_of_gt (lt_max_iff.2 (or.inr zero_lt_one))
have A : max K 1 ≠ 0 := ne_of_gt (lt_max_iff.2 (or.inr zero_lt_one))
have A : max K 1 ≠ 0 := ne_of_gt (lt_max_iff.2 (or.inr zero_lt_one))
calc dist (f y) (f x) ≤ K * dist y x : h y (lt_of_lt_of_le hy (min_le_left _ _)) ... ≤ max K 1 * dist y x : mul_le_mul_of_nonneg_right (le_max_left K 1) dist_nonneg ... ≤ max K 1 * (ε / max K 1) : mul_le_mul_of_nonneg_left (le_of_lt (lt_of_lt_of_le hy (min_le_right _ _))) (le_trans zero_le_one (le_max_right K 1)) ... = ε : mul_div_cancel' _ A
intros
rcases precise_refinement_set hs _ ho hU with ⟨V, hVo, hsV, hVf, hVU⟩
rcases exists_is_subordinate_of_locally_finite_of_prop p h01 hs V hVo hVf hsV with ⟨f, hfp, hf⟩
exact ⟨f, hfp, hf.mono hVU⟩
intros
cases h.mem with hx hy
simp [joined_in_iff_joined, *] at *
exact h.symm
intros
simp_rw ennreal.tsum_eq_supr_sum
apply lower_semicontinuous_within_at_supr (λ b, _)
exact lower_semicontinuous_within_at_sum (λ i hi, h i)
intros
change tX.induced ((coe : s → X) ∘ (set.inclusion ts)) = topological_space.induced (set.inclusion ts) (tX.induced _)
rw ← induced_compose
intros
apply stalk_to_fiber_surjective
intro t
obtain ⟨U, m, s, rfl⟩ := F.germ_exist _ t
use ⟨U, m⟩
{ use ⟨U, m⟩, fsplit, { exact λ y, F.germ y s, }, { exact ⟨prelocal_predicate.sheafify_of ⟨s, (λ _, rfl)⟩, rfl⟩, }, }
fsplit
{ exact λ y, F.germ y s, }
exact λ y, F.germ y s
{ exact ⟨prelocal_predicate.sheafify_of ⟨s, (λ _, rfl)⟩, rfl⟩, }
exact ⟨prelocal_predicate.sheafify_of ⟨s, (λ _, rfl)⟩, rfl⟩
intros
rcases locally_compact_space.local_compact_nhds x U (hU.mem_nhds hx) with ⟨K, h1K, h2K, h3K⟩
exact ⟨K, h3K, mem_interior_iff_mem_nhds.2 h1K, h2K⟩
intros
rw [uniform_continuous₂, uncurry_curry]
intros
tauto
intros
rw [uniform_continuous_on, uniform_continuous, univ_prod_univ, principal_univ, inf_top_eq]
intros
assume s hs
rcases comp_mem_uniformity_sets (mem_nhds_uniformity_iff_right.1 hs) with ⟨U, U_mem, hU⟩
rcases adhs U U_mem with ⟨t, t_mem, ht, y, hxy, hy⟩
apply mem_of_superset t_mem
exact (λ z hz, hU (prod_mk_mem_comp_rel hxy (ht $ mk_mem_prod hy hz)) rfl)
intros
rw [odd_eq, nth_even]
refl
intros
by_cases c; simp [*]
by_cases c
simp [*]
simp [*]
intros
apply ne_of_vne
rw [val_of_nat_eq_of_is_valid h₂, val_of_nat_eq_of_is_valid h₃]
assumption
intros
rw int.add_comm at h
exact int.le_add_of_sub_left_le h
intros
induction l; simp [*]
induction l
simp [*]
simp [*]
intros
cases n; simp [gcd, mod_self]
cases n
simp [gcd, mod_self]
simp [gcd, mod_self]
intros
cases k.eq_zero_or_pos with k0 kpos
rw [k0, nat.mul_zero, nat.div_zero, nat.div_zero]
{rw [k0, nat.mul_zero, nat.div_zero, nat.div_zero]}
cases n.eq_zero_or_pos with n0 npos
rw [n0, nat.zero_mul, nat.div_zero, nat.zero_div]
{rw [n0, nat.zero_mul, nat.div_zero, nat.zero_div]}
apply le_antisymm
apply (le_div_iff_mul_le _ _ (nat.mul_pos npos kpos)).2
{ apply (le_div_iff_mul_le _ _ (nat.mul_pos npos kpos)).2, rw [nat.mul_comm n k, ← nat.mul_assoc], apply (le_div_iff_mul_le _ _ npos).1, apply (le_div_iff_mul_le _ _ kpos).1, refl }
rw [nat.mul_comm n k, ← nat.mul_assoc]
apply (le_div_iff_mul_le _ _ npos).1
apply (le_div_iff_mul_le _ _ kpos).1
refl
apply (le_div_iff_mul_le _ _ kpos).2
{ apply (le_div_iff_mul_le _ _ kpos).2, apply (le_div_iff_mul_le _ _ npos).2, rw [nat.mul_assoc, nat.mul_comm n k], apply (le_div_iff_mul_le _ _ (nat.mul_pos kpos npos)).1, refl }
apply (le_div_iff_mul_le _ _ npos).2
rw [nat.mul_assoc, nat.mul_comm n k]
apply (le_div_iff_mul_le _ _ (nat.mul_pos kpos npos)).1
refl
intros
rw [div_def]
simp [lt_irrefl]
intros
{ ext, refl }
ext
refl
intros
simp only [infi, mem_Inf, set.forall_range_iff]
intros
nontriviality α
exact (exists_nat_gt x).imp (λ n, le_of_lt)
intros
refine prod_bij i hi h _ _
intros a1 a2 h1 h2 eq
{intros a1 a2 h1 h2 eq, rw [←left_inv a1 h1, ←left_inv a2 h2], cc,}
rw [←left_inv a1 h1, ←left_inv a2 h2]
cc
intros b hb
{intros b hb, use j b hb, use hj b hb, exact (right_inv b hb).symm,}
use j b hb
use hj b hb
exact (right_inv b hb).symm
intros
have : mul_support (λ x : plift α, (λ _, 1 : α → M) x.down) ⊆ (∅ : finset (plift α))
from λ x h, h rfl
rw [finprod_eq_prod_plift_of_mul_support_subset this, finset.prod_empty]
intros
rw [← finprod_mem_union_inter' hs ht, disjoint_iff_inter_eq_empty.1 hst, finprod_mem_empty, mul_one]
intros
classical
simp_rw [prod_eq_mul_prod_diff_singleton hi]
refine le_trans _ (mul_le_mul_right' h2i _)
rw [right_distrib]
apply add_le_add; apply mul_le_mul_left'; apply prod_le_prod'; simp only [and_imp, mem_sdiff, mem_singleton]; intros; apply_assumption; assumption
apply add_le_add; apply mul_le_mul_left'; apply prod_le_prod'; simp only [and_imp, mem_sdiff, mem_singleton]; intros; apply_assumption
apply add_le_add; apply mul_le_mul_left'; apply prod_le_prod'; simp only [and_imp, mem_sdiff, mem_singleton]; intros
apply add_le_add; apply mul_le_mul_left'; apply prod_le_prod'; simp only [and_imp, mem_sdiff, mem_singleton]
apply add_le_add; apply mul_le_mul_left'; apply prod_le_prod'
apply add_le_add; apply mul_le_mul_left'
apply add_le_add
apply mul_le_mul_left'
apply prod_le_prod'
simp only [and_imp, mem_sdiff, mem_singleton]
intros
apply_assumption
assumption
assumption
assumption
assumption
apply mul_le_mul_left'
apply prod_le_prod'
simp only [and_imp, mem_sdiff, mem_singleton]
intros
apply_assumption
assumption
assumption
assumption
assumption
intros
simp only [(two_mul a).symm, mul_eq_zero, two_ne_zero', false_or]
intros
split
{ assume stream_succ_nth_eq, have : int_fract_pair.stream v (n + 1) ≠ none, by simp [stream_succ_nth_eq], have : ¬int_fract_pair.stream v n = none ∧ ¬(∃ ifp, int_fract_pair.stream v n = some ifp ∧ ifp.fr = 0), by { have not_none_not_fract_zero, from (not_iff_not_of_iff succ_nth_stream_eq_none_iff).elim_left this, exact (not_or_distrib.elim_left not_none_not_fract_zero) }, cases this with stream_nth_ne_none nth_fr_ne_zero, replace nth_fr_ne_zero : ∀ ifp, int_fract_pair.stream v n = some ifp → ifp.fr ≠ 0, by simpa using nth_fr_ne_zero, obtain ⟨ifp_n, stream_nth_eq⟩ : ∃ ifp_n, int_fract_pair.stream v n = some ifp_n, from option.ne_none_iff_exists'.mp stream_nth_ne_none, existsi ifp_n, have ifp_n_fr_ne_zero : ifp_n.fr ≠ 0, from nth_fr_ne_zero ifp_n stream_nth_eq, cases ifp_n with _ ifp_n_fr, suffices : int_fract_pair.of ifp_n_fr⁻¹ = ifp_succ_n, by simpa [stream_nth_eq, ifp_n_fr_ne_zero], simp only [int_fract_pair.stream, stream_nth_eq, ifp_n_fr_ne_zero, option.some_bind, if_false] at stream_succ_nth_eq, injection stream_succ_nth_eq }
assume stream_succ_nth_eq
have : int_fract_pair.stream v (n + 1) ≠ none
simp [stream_succ_nth_eq]
simp [stream_succ_nth_eq]
have : ¬int_fract_pair.stream v n = none ∧ ¬(∃ ifp, int_fract_pair.stream v n = some ifp ∧ ifp.fr = 0)
have not_none_not_fract_zero
have not_none_not_fract_zero
{ have not_none_not_fract_zero, from (not_iff_not_of_iff succ_nth_stream_eq_none_iff).elim_left this, exact (not_or_distrib.elim_left not_none_not_fract_zero) }
{ have not_none_not_fract_zero, from (not_iff_not_of_iff succ_nth_stream_eq_none_iff).elim_left this, exact (not_or_distrib.elim_left not_none_not_fract_zero) }
from (not_iff_not_of_iff succ_nth_stream_eq_none_iff).elim_left this
from (not_iff_not_of_iff succ_nth_stream_eq_none_iff).elim_left this
exact (not_or_distrib.elim_left not_none_not_fract_zero)
exact (not_or_distrib.elim_left not_none_not_fract_zero)
cases this with stream_nth_ne_none nth_fr_ne_zero
replace nth_fr_ne_zero : ∀ ifp, int_fract_pair.stream v n = some ifp → ifp.fr ≠ 0
simpa using nth_fr_ne_zero
simpa using nth_fr_ne_zero
obtain ⟨ifp_n, stream_nth_eq⟩ : ∃ ifp_n, int_fract_pair.stream v n = some ifp_n
from option.ne_none_iff_exists'.mp stream_nth_ne_none
existsi ifp_n
have ifp_n_fr_ne_zero : ifp_n.fr ≠ 0
from nth_fr_ne_zero ifp_n stream_nth_eq
cases ifp_n with _ ifp_n_fr
suffices : int_fract_pair.of ifp_n_fr⁻¹ = ifp_succ_n
simpa [stream_nth_eq, ifp_n_fr_ne_zero]
simpa [stream_nth_eq, ifp_n_fr_ne_zero]
simp only [int_fract_pair.stream, stream_nth_eq, ifp_n_fr_ne_zero, option.some_bind, if_false] at stream_succ_nth_eq
injection stream_succ_nth_eq
rintro ⟨⟨_⟩, ifp_n_props⟩
{ rintro ⟨⟨_⟩, ifp_n_props⟩, finish [int_fract_pair.stream, ifp_n_props] }
finish [int_fract_pair.stream, ifp_n_props]
intros
induction n_le_m with m n_le_m IH generalizing s
{ refl }
refl
cases s_head_eq : s.head with gp_head
{ cases s_head_eq : s.head with gp_head, case option.none { cases n; simp only [convergents'_aux, s_head_eq] }, case option.some { have : convergents'_aux s (n + 1) = convergents'_aux s n, from convergents'_aux_stable_step_of_terminated terminated_at_n, rw [←this], have : s.tail.terminated_at n, by simpa only [seq.terminated_at, seq.nth_tail] using (s.le_stable n.le_succ terminated_at_n), have : convergents'_aux s.tail m = convergents'_aux s.tail n, from IH this, simp only [convergents'_aux, s_head_eq, this] } }
cases n
cases n; simp only [convergents'_aux, s_head_eq]
case option.none { cases n; simp only [convergents'_aux, s_head_eq] }
simp only [convergents'_aux, s_head_eq]
simp only [convergents'_aux, s_head_eq]
case option.some { have : convergents'_aux s (n + 1) = convergents'_aux s n, from convergents'_aux_stable_step_of_terminated terminated_at_n, rw [←this], have : s.tail.terminated_at n, by simpa only [seq.terminated_at, seq.nth_tail] using (s.le_stable n.le_succ terminated_at_n), have : convergents'_aux s.tail m = convergents'_aux s.tail n, from IH this, simp only [convergents'_aux, s_head_eq, this] }
have : convergents'_aux s (n + 1) = convergents'_aux s n
from convergents'_aux_stable_step_of_terminated terminated_at_n
rw [←this]
have : s.tail.terminated_at n
simpa only [seq.terminated_at, seq.nth_tail] using (s.le_stable n.le_succ terminated_at_n)
simpa only [seq.terminated_at, seq.nth_tail] using (s.le_stable n.le_succ terminated_at_n)
have : convergents'_aux s.tail m = convergents'_aux s.tail n
from IH this
simp only [convergents'_aux, s_head_eq, this]
intros
{ rw mul_comm, exact mul_div_cancel_left a b0 }
rw mul_comm
exact mul_div_cancel_left a b0
intros
rw [neg_eq_neg_one_mul, mul_div_assoc, ← neg_eq_neg_one_mul]
intros
rw [h, div_eq_mul_inv, mul_comm, inv_mul_cancel_left]
intros
rw [h.inv_left.eq, inv_mul_cancel_right]
intros
cases f; cases g; cases h; refl
cases f; cases g; cases h
cases f; cases g
cases f
cases g
cases h
refl
intros
rw [←pow_add, nat.add_comm, nat.sub_add_cancel h]
intros
refine ⟨pow_eq_zero, _⟩
rintros rfl
exact zero_pow hn
intros
induction p with p IH
{ simp }
simp
rw [pow_succ', IH, smul_mul_smul, ←pow_succ', ←pow_succ']
{ rw [pow_succ', IH, smul_mul_smul, ←pow_succ', ←pow_succ'] }
intros
rw [← units.coe_map, ← units.coe_map, ← units.coe_inv', monoid_hom.map_inv]
intros
rw [div_div_eq_div_mul, div_div_eq_div_mul, mul_comm]
intros
rw [←image_subobject_arrow_comp f, category.assoc]
convert comp_zero
rw p
simp
intros
{ ext, simp, }
ext
simp
intros
rw ← finset.prod_subset h _
apply finset.prod_congr rfl
{ apply finset.prod_congr rfl, intros i hi, congr, symmetry, exact mul_indicator_of_mem hi _ }
intros i hi
congr
symmetry
exact mul_indicator_of_mem hi _
refine λ i hi hn, _
{ refine λ i hi hn, _, convert hg i, exact mul_indicator_of_not_mem hn _ }
convert hg i
exact mul_indicator_of_not_mem hn _
intros
{ ext, refl, }
ext
refl
intros
rw [← matrix.diagonal_one, matrix.diagonal_neg, matrix.from_blocks_diagonal]
refl
intros
have h : ⁅I, N⁆ ⊔ ⁅I, N'⁆ ≤ ⁅I, N ⊔ N'⁆
rw sup_le_iff
{ rw sup_le_iff, split; apply mono_lie_right; [exact le_sup_left, exact le_sup_right], }
split
split; apply mono_lie_right; [exact le_sup_left, exact le_sup_right]
split; apply mono_lie_right
apply mono_lie_right
exact le_sup_left
apply mono_lie_right
exact le_sup_right
suffices : ⁅I, N ⊔ N'⁆ ≤ ⁅I, N⁆ ⊔ ⁅I, N'⁆
exact le_antisymm this h
{ exact le_antisymm this h, }
clear h
rw [lie_ideal_oper_eq_span, lie_span_le]
rintros m ⟨x, ⟨n, hn⟩, h⟩
erw lie_submodule.mem_sup
erw lie_submodule.mem_sup at hn
rcases hn with ⟨n₁, hn₁, n₂, hn₂, hn'⟩
use ⁅(x : L), (⟨n₁, hn₁⟩ : N)⁆
split
apply lie_coe_mem_lie
{ apply lie_coe_mem_lie, }
use ⁅(x : L), (⟨n₂, hn₂⟩ : N')⁆
split
apply lie_coe_mem_lie
{ apply lie_coe_mem_lie, }
simp [← h, ← hn']
intros
obtain ⟨k, hM⟩ := hM
unfreezingI { obtain ⟨k, hM⟩ := hM, }
use k
intros x
ext m
rw [linear_map.pow_apply, linear_map.zero_apply, ← @lie_submodule.mem_bot R L M, ← hM]
exact iterate_to_endomorphism_mem_lower_central_series R L M x m k
intros
rw [add_comm, derived_series_of_ideal_add I 1 k, abelian_iff_derived_one_eq_bot]
intros
rintros ⟨y, hy⟩
erw mem_range at hy
obtain ⟨x, rfl⟩ := hy
use x
simp only [subtype.mk_eq_mk, range_restrict_apply]
intros
simp only [← coe_to_submodule_eq_iff, lie_ideal.coe_to_lie_subalgebra_to_submodule, submodule.exists_lie_submodule_coe_eq_iff L]
exact iff.rfl
intros
refine iff.intro (λ h x hx, h ▸ rfl) _
intro h
set u' : ↥(E.sol_space) := ⟨u, hu⟩
set v' : ↥(E.sol_space) := ⟨v, hv⟩
change u'.val = v'.val
suffices h' : u' = v'
from h' ▸ rfl
rw [← E.to_init.to_equiv.apply_eq_iff_eq, linear_equiv.coe_to_equiv]
ext x
exact_mod_cast h (mem_range.mpr x.2)
intros
rw [←neg_neg c, neg_smul, neg_pos]
exact smul_neg_iff_of_pos (neg_pos_of_neg hc)
intros
rw [← neg_sub, abv.map_neg]
intros
rw [inv_mul_le_iff h, mul_comm]
intros
rw [div_eq_mul_one_div a c, div_eq_mul_one_div b c]
exact mul_lt_mul_of_neg_right h (one_div_neg.2 hc)
intros
rw [← mul_two, mul_div_cancel a two_ne_zero]
intros
rw [← mul_lt_mul_iff_left b, mul_inv_cancel_left]
intros
rw [← inv_mul_lt_iff_lt_mul, mul_comm]
intros
obtain ⟨y, hy⟩ := decidable.exists_ne (1 : α)
cases hy.lt_or_lt
{ exact ⟨y⁻¹, one_lt_inv'.mpr h⟩ }
exact ⟨y⁻¹, one_lt_inv'.mpr h⟩
{ exact ⟨y, h⟩ }
exact ⟨y, h⟩
intros
rw mul_nonneg_iff
iterate 3 { rw mul_nonneg_iff }; have := le_total 0 a; have := le_total 0 b; have := le_total 0 c; itauto
iterate 3 { rw mul_nonneg_iff }; have := le_total 0 a; have := le_total 0 b; have := le_total 0 c
iterate 3 { rw mul_nonneg_iff }; have := le_total 0 a; have := le_total 0 b
iterate 3 { rw mul_nonneg_iff }; have := le_total 0 a
iterate 3 { rw mul_nonneg_iff }
rw mul_nonneg_iff
rw mul_nonneg_iff
have := le_total 0 a
have := le_total 0 b
have := le_total 0 c
itauto
intros
simp only [← not_le, inv_of_nonneg]
intros
simpa only [sub_eq_add_neg] using h.neg_nsmul n x
intros
ext1 y
{ ext1 y, rw [mem_inv, mem_singleton_iff, mem_singleton_iff, inv_eq_iff_inv_eq, eq_comm], }
rw [mem_inv, mem_singleton_iff, mem_singleton_iff, inv_eq_iff_inv_eq, eq_comm]
intros
simpa using nat_degree_multiset_prod' (s.1.map f) (by simpa using h)
intros
rw [← coe_commutes, coe_mul_eq_smul]
intros
rcases ua with ⟨a, rfl⟩
exact a.is_smul_regular M
intros
convert dvd_add (hxy.mul_left a) (hab.mul_right y)
rw [mul_sub_left_distrib, mul_sub_right_distrib]
simp only [sub_eq_add_neg, add_assoc, neg_add_cancel_left]
intros
ext
rcases mk_alg_hom_surjective S s x with ⟨x, rfl⟩
exact (alg_hom.congr_fun w x : _)
intros
{ subst h, dsimp, simp, }
subst h
dsimp
simp
intros
rw [← is_open_compl_iff, is_open_iff, compl_compl]
intros
dsimp [δ, σ]
simp only [←X.map_comp, ←op_comp, simplex_category.δ_comp_σ_succ, op_id, X.map_id]
intros
dsimp [δ, σ]
{ dsimp [δ, σ], simp only [←X.map_comp, ←op_comp, simplex_category.δ_comp_σ_of_le H] }
simp only [←X.map_comp, ←op_comp, simplex_category.δ_comp_σ_of_le H]
intros
simpa only [sub_eq_add_neg] using hf.add hg.neg
intros
funext v i
apply p.congr (composition.ones_blocks_fun _ _)
intros j hjn hj1
obtain rfl : j = 0
linarith
{ linarith }
refine congr_arg v _
rw [fin.ext_iff, fin.coe_cast_le, composition.ones_embedding, fin.coe_mk]
intros
refine ⟨λ H, by rw H, λ H, _⟩
rcases u with ⟨a, b⟩
rcases v with ⟨a', b'⟩
dsimp at H
have h : a = a'
ext1
{ ext1, have : map list.sum (of_fn (λ (i : fin (composition.length a)), (b i).blocks)) = map list.sum (of_fn (λ (i : fin (composition.length a')), (b' i).blocks)), by rw H, simp only [map_of_fn] at this, change of_fn (λ (i : fin (composition.length a)), (b i).blocks.sum) = of_fn (λ (i : fin (composition.length a')), (b' i).blocks.sum) at this, simpa [composition.blocks_sum, composition.of_fn_blocks_fun] using this }
have : map list.sum (of_fn (λ (i : fin (composition.length a)), (b i).blocks)) = map list.sum (of_fn (λ (i : fin (composition.length a')), (b' i).blocks))
rw H
rw H
simp only [map_of_fn] at this
change of_fn (λ (i : fin (composition.length a)), (b i).blocks.sum) = of_fn (λ (i : fin (composition.length a')), (b' i).blocks.sum) at this
simpa [composition.blocks_sum, composition.of_fn_blocks_fun] using this
induction h
simp only [true_and, eq_self_iff_true, heq_iff_eq]
ext i : 2
have : nth_le (of_fn (λ (i : fin (composition.length a)), (b i).blocks)) i (by simp [i.is_lt]) = nth_le (of_fn (λ (i : fin (composition.length a)), (b' i).blocks)) i (by simp [i.is_lt]) := nth_le_of_eq H _
rwa [nth_le_of_fn, nth_le_of_fn] at this
intros
simpa only [div_eq_mul_inv] using htu.mul hvw.inv
intros
{ convert is_o_pow_pow h, simp only [pow_one] }
convert is_o_pow_pow h
simp only [pow_one]
intros
{ unfold is_O, exact exists_congr (λ _, is_O_with_neg_left) }
unfold is_O
exact exists_congr (λ _, is_O_with_neg_left)
intros
convert hc.mul (has_strict_deriv_at_const x d)
rw [mul_zero, add_zero]
intros
{ rw ← has_deriv_within_at_univ at *, exact hc.pow }
rw ← has_deriv_within_at_univ at *
exact hc.pow
intros
simp only [deriv, fderiv_const_add]
intros
simp only [sub_eq_add_neg, differentiable_within_at_add_const_iff]
intros
rw [← differentiable_within_at_univ, ← differentiable_within_at_univ, iso.comp_differentiable_within_at_iff]
intros
simp only [mem_closure_iff_nhds_within_ne_bot, ne_bot_iff, ne.def, not_not] at h
simp [has_fderiv_within_at, has_fderiv_at_filter, h, is_o, is_O_with]
intros
refine h.is_O_image_sub_norm_mul_norm_sub.trans_is_o (is_o.of_norm_right _)
refine is_o_iff_exists_eq_mul.2 ⟨λ y, ∥y - (x, x)∥, _, eventually_eq.rfl⟩
refine (continuous_id.sub continuous_const).norm.tendsto' _ _ _
rw [_root_.id, sub_self, norm_zero]
intros
apply to_implicit_function_of_complemented
intros
ext x
rw [← iterated_deriv_within_univ]
convert iterated_deriv_within_eq_iterate unique_diff_on_univ (mem_univ x)
simp [deriv_within_univ]
ext x
by_cases h : x ≤ 0
{ simp [exp_neg_inv_glue, f_aux, h] }
simp [exp_neg_inv_glue, f_aux, h]
simp [h, exp_neg_inv_glue, f_aux, ne_of_gt (not_le.1 h), P_aux]
{ simp [h, exp_neg_inv_glue, f_aux, ne_of_gt (not_le.1 h), P_aux] }
intros
simpa [hn, differentiable_within_at_univ] using h.differentiable_within_at
intros
{ convert has_ftaylor_series_up_to_on_pi, ext, refl }
convert has_ftaylor_series_up_to_on_pi
ext
refl
intros
rw [iterated_fderiv_within_succ_apply_right hs hx, iterated_fderiv_within_zero_apply]
{ rw [iterated_fderiv_within_succ_apply_right hs hx, iterated_fderiv_within_zero_apply], refl }
refl
intros
rcases h with ⟨c, hc, li, hg⟩
rcases linear_isometry_complex (li.to_linear_isometry_equiv rfl) with ⟨a, ha⟩
let rot := c • (a : ℂ) • continuous_linear_map.id ℂ ℂ
cases ha
refine or.intro_left _ ⟨rot, _⟩
{ refine or.intro_left _ ⟨rot, _⟩, ext1, simp only [coe_restrict_scalars', hg, ← li.coe_to_linear_isometry_equiv, ha, pi.smul_apply, continuous_linear_map.smul_apply, rotation_apply, continuous_linear_map.id_apply, smul_eq_mul], }
ext1
simp only [coe_restrict_scalars', hg, ← li.coe_to_linear_isometry_equiv, ha, pi.smul_apply, continuous_linear_map.smul_apply, rotation_apply, continuous_linear_map.id_apply, smul_eq_mul]
refine or.intro_right _ ⟨rot, _⟩
{ refine or.intro_right _ ⟨rot, _⟩, ext1, rw [continuous_linear_map.coe_comp', hg, ← li.coe_to_linear_isometry_equiv, ha], simp only [coe_restrict_scalars', function.comp_app, pi.smul_apply, linear_isometry_equiv.coe_trans, conj_lie_apply, rotation_apply, continuous_linear_equiv.coe_apply, conj_cle_apply], simp only [continuous_linear_map.smul_apply, continuous_linear_map.id_apply, smul_eq_mul, conj_conj], }
ext1
rw [continuous_linear_map.coe_comp', hg, ← li.coe_to_linear_isometry_equiv, ha]
simp only [coe_restrict_scalars', function.comp_app, pi.smul_apply, linear_isometry_equiv.coe_trans, conj_lie_apply, rotation_apply, continuous_linear_equiv.coe_apply, conj_cle_apply]
simp only [continuous_linear_map.smul_apply, continuous_linear_map.id_apply, smul_eq_mul, conj_conj]
intros
refine ⟨λ h z hz, _, (open_segment_subset_segment 𝕜 x y).trans⟩
obtain rfl | hxz := eq_or_ne x z
{ exact hx }
exact hx
obtain rfl | hyz := eq_or_ne y z
{ exact hy }
exact hy
exact h (mem_open_segment_of_ne_left_right 𝕜 hxz hyz hz)
intros
rw sUnion_eq_Union
exact (directed_on_iff_directed.1 hdir).convex_Union (λ A, hc A.2)
intros
let k := (min_card_finset_of_mem_convex_hull hx).card - 1
have hk : (min_card_finset_of_mem_convex_hull hx).card = k + 1
exact (nat.succ_pred_eq_of_pos (finset.card_pos.mpr (min_card_finset_of_mem_convex_hull_nonempty hx))).symm
{ exact (nat.succ_pred_eq_of_pos (finset.card_pos.mpr (min_card_finset_of_mem_convex_hull_nonempty hx))).symm }
classical
by_contra
obtain ⟨p, hp⟩ := mem_convex_hull_erase h (mem_min_card_finset_of_mem_convex_hull hx)
have contra := min_card_finset_of_mem_convex_hull_card_le_card hx (set.subset.trans (finset.erase_subset ↑p (min_card_finset_of_mem_convex_hull hx)) (min_card_finset_of_mem_convex_hull_subseteq hx)) hp
rw [← not_lt] at contra
apply contra
erw [card_erase_of_mem p.2, hk]
exact lt_add_one _
intros
split
rintro hc t h x ⟨hxs, hxt⟩
{ rintro hc t h x ⟨hxs, hxt⟩, refine hc {x | ↑x ∈ t} ⟨x, hxs⟩ _, rw subtype.coe_image_of_subset h, exact hxt }
refine hc {x | ↑x ∈ t} ⟨x, hxs⟩ _
rw subtype.coe_image_of_subset h
exact hxt
intros hc t x h
{ intros hc t x h, rw ←subtype.coe_injective.mem_set_image, exact hc (t.image coe) (subtype.coe_image_subset s t) ⟨x.prop, h⟩ }
rw ←subtype.coe_injective.mem_set_image
exact hc (t.image coe) (subtype.coe_image_subset s t) ⟨x.prop, h⟩
intros
refine (emetric.diam_le $ λ x hx y hy, _).antisymm (emetric.diam_mono $ subset_convex_hull ℝ s)
rcases convex_hull_exists_dist_ge2 hx hy with ⟨x', hx', y', hy', H⟩
rw edist_dist
apply le_trans (ennreal.of_real_le_of_real H)
rw ← edist_dist
exact emetric.edist_le_diam_of_mem hx' hy'
intros
convert inner_eq_norm_mul_iff using 2; simp [hx, hy]
{ convert inner_eq_norm_mul_iff using 2; simp [hx, hy] }
convert inner_eq_norm_mul_iff using 2
simp [hx, hy]
simp [hx, hy]
simp [hx, hy]
intros
{ simp [sub_eq_add_neg, inner_add_left, inner_neg_left] }
simp [sub_eq_add_neg, inner_add_left, inner_neg_left]
intros
{ rw [← neg_one_smul 𝕜 x, inner_smul_left], simp }
rw [← neg_one_smul 𝕜 x, inner_smul_left]
simp
intros
{ have h := @inner_self_eq_norm_sq ℝ F _ _ x, simpa using h }
have h := @inner_self_eq_norm_sq ℝ F _ _ x
simpa using h
intros
rw [to_euclidean.to_homeomorph.nhds_eq_comap]
exact metric.nhds_basis_ball.comap _
intros
simp [explicit_cokernel_π, explicit_cokernel_iso]
intros
ext
{ ext, refl }
refl
intros
rw [dist_eq_norm, sub_zero]
intros
rw [← dist_zero_right, dist_self]
intros
rw [div_eq_inv_mul, ←smul_eq_mul, inv_eq_one_div]
exact exp_series_apply_eq x n
intros
rw [← coe_nnnorm, int.nnnorm_coe_units, nnreal.coe_one]
intros
{ ext, simp [mem_ker] }
ext
simp [mem_ker]
intros
have hx : 0 < ∥x∥ := (norm_pos_iff.mpr h)
haveI : nontrivial (𝕜 ∙ x) := submodule.nontrivial_span_singleton h
exact continuous_linear_map.homothety_norm _ (λ y, homothety_inverse _ hx _ (to_span_nonzero_singleton_homothety 𝕜 x h) _)
intros
rw [← inverse_unit (units.one_sub t h), units.coe_one_sub]
simp [log]
intros
rw [← exp_le_exp, exp_log h, exp_log h₁]
intros
refine ⟨λ h, _, λ h, _⟩
have := P.is_equivalent_at_top_lead.tendsto_nhds h
{ have := P.is_equivalent_at_top_lead.tendsto_nhds h, by_cases hP : P.leading_coeff = 0, { simp only [hP, zero_mul, tendsto_const_nhds_iff] at this, refine ⟨trans hP this, by simp [leading_coeff_eq_zero.1 hP]⟩ }, { rw [tendsto_const_mul_pow_nhds_iff hP, nat_degree_eq_zero_iff_degree_le_zero] at this, exact this.symm } }
by_cases hP : P.leading_coeff = 0
simp only [hP, zero_mul, tendsto_const_nhds_iff] at this
{ simp only [hP, zero_mul, tendsto_const_nhds_iff] at this, refine ⟨trans hP this, by simp [leading_coeff_eq_zero.1 hP]⟩ }
refine ⟨trans hP this, by simp [leading_coeff_eq_zero.1 hP]⟩
rw [tendsto_const_mul_pow_nhds_iff hP, nat_degree_eq_zero_iff_degree_le_zero] at this
{ rw [tendsto_const_mul_pow_nhds_iff hP, nat_degree_eq_zero_iff_degree_le_zero] at this, exact this.symm }
exact this.symm
refine P.is_equivalent_at_top_lead.symm.tendsto_nhds _
{ refine P.is_equivalent_at_top_lead.symm.tendsto_nhds _, have : P.nat_degree = 0 := nat_degree_eq_zero_iff_degree_le_zero.2 h.2, simp only [h.1, this, pow_zero, mul_one], exact tendsto_const_nhds }
have : P.nat_degree = 0 := nat_degree_eq_zero_iff_degree_le_zero.2 h.2
simp only [h.1, this, pow_zero, mul_one]
exact tendsto_const_nhds
intros
nth_rewrite 0 ← real.coe_to_nnreal x hx
rw [←nnreal.coe_rpow, real.to_nnreal_coe]
intros
simpa using rpow_sub_nat hx y 1
intros
rw [rpow_def_of_pos hx, exp_le_one_iff, mul_nonpos_iff, log_nonneg_iff hx, log_nonpos_iff hx]
intros
simp [arctan_eq_arcsin, neg_div]
intros
simp only [div_eq_mul_inv, ennreal.inv_pow] at hu
refine cauchy_seq_of_edist_le_geometric 2⁻¹ C _ hC hu
simp [ennreal.one_lt_two]
intros
rw [add_def, neg_sub', add_neg]
intros
rw [transfer_nat_trans_self_symm_comp, gf, transfer_nat_trans_self_symm_id]
intros
symmetry
{ symmetry, erw [←iso.hom_comp_eq_id (e.unit_iso.app _), unit_inverse_comp], refl }
erw [←iso.hom_comp_eq_id (e.unit_iso.app _), unit_inverse_comp]
refl
intros
classical
apply finset.induction_on O
{ exact ⟨is_filtered.nonempty.some, (by rintros - ⟨⟩)⟩, }
exact ⟨is_filtered.nonempty.some, (by rintros - ⟨⟩)⟩
rintros X O' nm ⟨S', w'⟩
{ rintros X O' nm ⟨S', w'⟩, use max X S', rintros Y mY, by_cases h : X = Y, { subst h, exact ⟨left_to_max _ _⟩, }, { exact ⟨(w' (by finish)).some ≫ right_to_max _ _⟩, }, }
use max X S'
rintros Y mY
by_cases h : X = Y
{ subst h, exact ⟨left_to_max _ _⟩, }
subst h
exact ⟨left_to_max _ _⟩
{ exact ⟨(w' (by finish)).some ≫ right_to_max _ _⟩, }
exact ⟨(w' (by finish)).some ≫ right_to_max _ _⟩
intros
cases F
cases F; refl
refl
intros
ext
ext; apply category.comp_id
apply category.comp_id
intros
simp
intros
dsimp [is_colimit_whisker_equiv]
apply P.hom_ext
intro j
simp
dsimp
dsimp
simp
intros
dsimp [limit.iso_limit_cone, is_limit.cone_point_unique_up_to_iso]
{ dsimp [limit.iso_limit_cone, is_limit.cone_point_unique_up_to_iso], tidy, }
tidy
intros
haveI : has_colimit (e.inverse ⋙ e.functor ⋙ F) := limits.has_colimit_equivalence_comp e.symm
apply has_colimit_of_iso (e.inv_fun_id_assoc F).symm
intros
simp
intros
simp [biproduct.ι_π, h]
intros
{ ext, simp, }
ext
simp
intros
{ rw [←image.fac f], apply epi_comp, }
rw [←image.fac f]
apply epi_comp
intros
{ ext, simp [h₁], }
ext
simp [h₁]
intros
apply eq_lift_of_comp_eq
tidy
intros
{ dsimp [limit.mk], simp, }
dsimp [limit.mk]
simp
intros
rw [←tensor_right_iff, comp_tensor_id, ←cancel_mono (α_ X Y (𝟙_ C)).hom, assoc, associator_naturality, ←triangle_assoc, ←triangle, id_tensor_comp, pentagon_assoc, ←associator_naturality, tensor_id]
intros
simp only [lax_monoidal_functor.left_unitality]
slice_rhs 2 3 { rw ←comp_tensor_id, simp, }
simp
intros
ext
{ ext, simp only [right_dual_iso, iso.refl_hom, right_adjoint_mate_id] }
simp only [right_dual_iso, iso.refl_hom, right_adjoint_mate_id]
intros
have := f.w; tidy
have := f.w
tidy
intros
dsimp [lift_f_zero, lift_f_one]
simp
intros
split
intro h
{ intro h, apply le_antisymm, { intros Y f hf, rw ← J₁.covers_iff_mem_of_closed h, apply hf }, { apply J₁.le_close } }
apply le_antisymm
intros Y f hf
{ intros Y f hf, rw ← J₁.covers_iff_mem_of_closed h, apply hf }
rw ← J₁.covers_iff_mem_of_closed h
apply hf
{ apply J₁.le_close }
apply J₁.le_close
intro e
{ intro e, rw ← e, apply J₁.close_is_closed }
rw ← e
apply J₁.close_is_closed
intros
{ ext, simp, }
ext
simp
intros
{ ext, simpa using i.2.le }
ext
simpa using i.2.le
intros
haveI := classical.dec_eq β
let r' := λ a, univ.filter (λ b, r a b)
have h : ∀ (A : finset α), (univ.filter (λ (b : β), ∃ a ∈ A, r a b)) = (A.bUnion r')
intro A
{ intro A, ext b, simp, }
ext b
simp
have h' : ∀ (f : α → β) x, r x (f x) ↔ f x ∈ r' x
{ simp, }
simp
simp_rw [h, h']
apply finset.all_card_le_bUnion_card_iff_exists_injective
intros
simp [degree]
intros
obtain ⟨t, ht⟩ := finset.min_of_mem (mem_image_of_mem (λ v, G.degree v) (mem_univ v))
have := finset.min_le_of_mem (mem_image_of_mem _ (mem_univ v)) ht
rw option.mem_def at ht
rwa [min_degree, ht, option.get_or_else_some]
intros
rw ←card_neighbor_set_eq_degree
exact set.card_le_of_subset (G'.neighbor_set_subset v)
intros
let G₁ : (α × list σ) × ℕ × ℕ → option σ := λ p, let a := p.1.1, IH := p.1.2, n := p.2.1, m := p.2.2 in (IH.nth m).bind $ λ s, (IH.nth m.unpair.1).bind $ λ s₁, (IH.nth m.unpair.2).map $ λ s₂, cond n.bodd (cond n.div2.bodd (rf a (of_nat code m) s) (pc a (of_nat code m.unpair.1) (of_nat code m.unpair.2) s₁ s₂)) (cond n.div2.bodd (co a (of_nat code m.unpair.1) (of_nat code m.unpair.2) s₁ s₂) (pr a (of_nat code m.unpair.1) (of_nat code m.unpair.2) s₁ s₂))
have : primrec G₁
refine option_bind (list_nth.comp (snd.comp fst) (snd.comp snd)) _
{ refine option_bind (list_nth.comp (snd.comp fst) (snd.comp snd)) _, refine option_bind ((list_nth.comp (snd.comp fst) (fst.comp $ primrec.unpair.comp (snd.comp snd))).comp fst) _, refine option_map ((list_nth.comp (snd.comp fst) (snd.comp $ primrec.unpair.comp (snd.comp snd))).comp $ fst.comp fst) _, have a := fst.comp (fst.comp $ fst.comp $ fst.comp fst), have n := fst.comp (snd.comp $ fst.comp $ fst.comp fst), have m := snd.comp (snd.comp $ fst.comp $ fst.comp fst), have m₁ := fst.comp (primrec.unpair.comp m), have m₂ := snd.comp (primrec.unpair.comp m), have s := snd.comp (fst.comp fst), have s₁ := snd.comp fst, have s₂ := snd, exact (nat_bodd.comp n).cond ((nat_bodd.comp $ nat_div2.comp n).cond (hrf.comp $ a.pair (((primrec.of_nat code).comp m).pair s)) (hpc.comp $ a.pair (((primrec.of_nat code).comp m₁).pair $ ((primrec.of_nat code).comp m₂).pair $ s₁.pair s₂))) (primrec.cond (nat_bodd.comp $ nat_div2.comp n) (hco.comp $ a.pair (((primrec.of_nat code).comp m₁).pair $ ((primrec.of_nat code).comp m₂).pair $ s₁.pair s₂)) (hpr.comp $ a.pair (((primrec.of_nat code).comp m₁).pair $ ((primrec.of_nat code).comp m₂).pair $ s₁.pair s₂))) }
refine option_bind ((list_nth.comp (snd.comp fst) (fst.comp $ primrec.unpair.comp (snd.comp snd))).comp fst) _
refine option_map ((list_nth.comp (snd.comp fst) (snd.comp $ primrec.unpair.comp (snd.comp snd))).comp $ fst.comp fst) _
have a := fst.comp (fst.comp $ fst.comp $ fst.comp fst)
have n := fst.comp (snd.comp $ fst.comp $ fst.comp fst)
have m := snd.comp (snd.comp $ fst.comp $ fst.comp fst)
have m₁ := fst.comp (primrec.unpair.comp m)
have m₂ := snd.comp (primrec.unpair.comp m)
have s := snd.comp (fst.comp fst)
have s₁ := snd.comp fst
have s₂ := snd
exact (nat_bodd.comp n).cond ((nat_bodd.comp $ nat_div2.comp n).cond (hrf.comp $ a.pair (((primrec.of_nat code).comp m).pair s)) (hpc.comp $ a.pair (((primrec.of_nat code).comp m₁).pair $ ((primrec.of_nat code).comp m₂).pair $ s₁.pair s₂))) (primrec.cond (nat_bodd.comp $ nat_div2.comp n) (hco.comp $ a.pair (((primrec.of_nat code).comp m₁).pair $ ((primrec.of_nat code).comp m₂).pair $ s₁.pair s₂)) (hpr.comp $ a.pair (((primrec.of_nat code).comp m₁).pair $ ((primrec.of_nat code).comp m₂).pair $ s₁.pair s₂)))
let G : α → list σ → option σ := λ a IH, IH.length.cases (some (z a)) $ λ n, n.cases (some (s a)) $ λ n, n.cases (some (l a)) $ λ n, n.cases (some (r a)) $ λ n, G₁ ((a, IH), n, n.div2.div2)
have : primrec₂ G := (nat_cases (list_length.comp snd) (option_some_iff.2 (hz.comp fst)) $ nat_cases snd (option_some_iff.2 (hs.comp (fst.comp fst))) $ nat_cases snd (option_some_iff.2 (hl.comp (fst.comp $ fst.comp fst))) $ nat_cases snd (option_some_iff.2 (hr.comp (fst.comp $ fst.comp $ fst.comp fst))) (this.comp $ ((fst.pair snd).comp $ fst.comp $ fst.comp $ fst.comp $ fst).pair $ snd.pair $ nat_div2.comp $ nat_div2.comp snd))
refine ((nat_strong_rec (λ a n, F a (of_nat code n)) this.to₂ $ λ a n, _).comp primrec.id $ encode_iff.2 hc).of_eq (λ a, by simp)
simp
cases n with n
iterate 4 {cases n with n, {simp [of_nat_code_eq, of_nat_code]; refl}}
{simp [of_nat_code_eq, of_nat_code]; refl}
cases n with n
{simp [of_nat_code_eq, of_nat_code]; refl}
cases n with n
{simp [of_nat_code_eq, of_nat_code]; refl}
cases n with n
simp [of_nat_code_eq, of_nat_code]
simp [of_nat_code_eq, of_nat_code]; refl
{simp [of_nat_code_eq, of_nat_code]; refl}
refl
simp [G]
rw [list.length_map, list.length_range]
let m := n.div2.div2
show G₁ ((a, (list.range (n+4)).map (λ n, F a (of_nat code n))), n, m) = some (F a (of_nat code (n+4)))
have hm : m < n + 4
simp [nat.div2_val, m]
simp [nat.div2_val, m]
simp [nat.div2_val, m]; from lt_of_le_of_lt (le_trans (nat.div_le_self _ _) (nat.div_le_self _ _)) (nat.succ_le_succ (nat.le_add_right _ _))
simp [nat.div2_val, m]; from lt_of_le_of_lt (le_trans (nat.div_le_self _ _) (nat.div_le_self _ _)) (nat.succ_le_succ (nat.le_add_right _ _))
from lt_of_le_of_lt (le_trans (nat.div_le_self _ _) (nat.div_le_self _ _)) (nat.succ_le_succ (nat.le_add_right _ _))
from lt_of_le_of_lt (le_trans (nat.div_le_self _ _) (nat.div_le_self _ _)) (nat.succ_le_succ (nat.le_add_right _ _))
have m1 : m.unpair.1 < n + 4
from lt_of_le_of_lt m.unpair_left_le hm
have m2 : m.unpair.2 < n + 4
from lt_of_le_of_lt m.unpair_right_le hm
simp [G₁]
simp [list.nth_map, list.nth_range, hm, m1, m2]
change of_nat code (n+4) with of_nat_code (n+4)
simp [of_nat_code]
cases n.bodd; cases n.div2.bodd; refl
cases n.bodd; cases n.div2.bodd
cases n.bodd
cases n.div2.bodd
refl
refl
cases n.div2.bodd
refl
refl
intros
simp [many_one_equiv]
intros
cases L₂ with a L₂
refine trans_gen.trans (move_ok dec_trivial (split_at_pred_eq _ _ [] (some Γ'.Cons) L₃ (by rintro _ ⟨⟩) ⟨rfl, rfl⟩)) (trans_gen.head rfl (trans_gen.head rfl _))
{ refine trans_gen.trans (move_ok dec_trivial (split_at_pred_eq _ _ [] (some Γ'.Cons) L₃ (by rintro _ ⟨⟩) ⟨rfl, rfl⟩)) (trans_gen.head rfl (trans_gen.head rfl _)), convert unrev_ok, simp, refl }
convert unrev_ok
simp
refl
refine trans_gen.trans (move_ok dec_trivial (split_at_pred_eq _ _ (tr_nat a) (some Γ'.cons) (tr_list L₂ ++ Γ'.Cons :: L₃) (tr_nat_nat_end _) ⟨rfl, by simp⟩)) (trans_gen.head rfl (trans_gen.head rfl _))
{ refine trans_gen.trans (move_ok dec_trivial (split_at_pred_eq _ _ (tr_nat a) (some Γ'.cons) (tr_list L₂ ++ Γ'.Cons :: L₃) (tr_nat_nat_end _) ⟨rfl, by simp⟩)) (trans_gen.head rfl (trans_gen.head rfl _)), simp, refine trans_gen.trans (clear_ok (split_at_pred_eq _ _ (tr_list L₂) (some Γ'.Cons) L₃ (λ x h, (to_bool_ff (tr_list_ne_Cons _ _ h))) ⟨rfl, by simp⟩)) _, convert unrev_ok, simp [list.reverse_core_eq] }
simp
refine trans_gen.trans (clear_ok (split_at_pred_eq _ _ (tr_list L₂) (some Γ'.Cons) L₃ (λ x h, (to_bool_ff (tr_list_ne_Cons _ _ h))) ⟨rfl, by simp⟩)) _
convert unrev_ok
simp [list.reverse_core_eq]
intros
cases n; simp only [tape.nth, tape.right₀, int.coe_nat_zero, list_blank.nth_zero, list_blank.nth_succ, list_blank.head_cons, list_blank.tail_cons]
cases n
simp only [tape.nth, tape.right₀, int.coe_nat_zero, list_blank.nth_zero, list_blank.nth_succ, list_blank.head_cons, list_blank.tail_cons]
simp only [tape.nth, tape.right₀, int.coe_nat_zero, list_blank.nth_zero, list_blank.nth_succ, list_blank.head_cons, list_blank.tail_cons]
intros
simp [fst,bimap_bimap]
intros
simp only [fold_map,traverse_map]
intros
induction xs generalizing b; simp! [*]; cases b; simp! [to_list,to_array]
induction xs generalizing b; simp! [*]; cases b
induction xs generalizing b; simp! [*]
induction xs generalizing b
simp! [*]
simp! [*]
cases b
simp! [to_list,to_array]
intros
simpa [h] using mono.le p cb n
intros
simp [seq_right_eq, seq_eq_done, map_eq_done, and.comm, and.assoc]
intros
simp [eof, guard_eq_done, remaining_eq_done, nat.sub_eq_zero_iff_le, and_comm, and_assoc]
intros
{ introI, exact hne (of_done h) }
introI
exact hne (of_done h)
intros
rw [← of_real_rat_cast, of_real_im]
intros
simp [bit0]
intros
refine quotient.induction_on₂ f₁ f₂ (λ x₁ x₂, _)
simp only [sum_add_hom, add_monoid_hom.finset_sum_apply, quotient.lift_on_mk, add_monoid_hom.coe_mk, add_monoid_hom.flip_apply]
exact finset.sum_comm
intros
split
split; intros h₂ x
intros h₂ x
{ rw [←f.right_inv x], apply h.mp, apply h₂ }
rw [←f.right_inv x]
apply h.mp
apply h₂
intros h₂ x
apply h.mpr
apply h₂
intros
simp [equiv.symm_apply_eq]
intros
rw [← h.image_eq]
rintros y ⟨x, hx, rfl⟩
have hx' := hx
rw hs at hx'
rw [e.left_inv hx.1, Heq hx, e'.left_inv hx'.1]
intros
{ cases e, refl }
cases e
refl
intros
{ ext, simp }
ext
simp
intros
ext i
by_cases h : i = 0
{ rw h, refl }
rw h
refl
set j := pred i h with ji
have : i = j.succ
rw [ji, succ_pred]
rw [ji, succ_pred]
rw [this, cons_succ]
by_cases h' : j.val < n
set k := cast_lt j h' with jk
{ set k := cast_lt j h' with jk, have : j = k.cast_succ, by rw [jk, cast_succ_cast_lt], rw [this, ← cast_succ_fin_succ], simp }
have : j = k.cast_succ
rw [jk, cast_succ_cast_lt]
rw [jk, cast_succ_cast_lt]
rw [this, ← cast_succ_fin_succ]
simp
rw [eq_last_of_not_lt h', succ_last]
simp
intros
rcases i with ⟨i, hi⟩
rw [subtype.coe_mk]
induction i using nat.strong_induction_on with i h
refine le_antisymm (forall_lt_iff_le.1 $ λ j hj, _) (forall_lt_iff_le.1 $ λ j hj, _)
have := e.symm.lt_iff_lt.2 (mk_lt_of_lt_coe hj)
{ have := e.symm.lt_iff_lt.2 (mk_lt_of_lt_coe hj), rw e.symm_apply_apply at this, convert this, simpa using h _ this (e.symm _).is_lt }
rw e.symm_apply_apply at this
convert this
simpa using h _ this (e.symm _).is_lt
rwa [← h j hj (hj.trans hi), ← lt_iff_coe_lt_coe, e.lt_iff_lt]
{ rwa [← h j hj (hj.trans hi), ← lt_iff_coe_lt_coe, e.lt_iff_lt] }
intros
simp only [mem_sdiff, h, not_true, not_false_iff, and_false]
intros
rw [sdiff_eq_self, subset_empty, disjoint_iff_inter_eq_empty]
intros
rw [sup', ←with_bot.some_eq_coe, option.some_get]
intros
simp [insert_val_of_not_mem ha, noncomm_prod]
intros
let l := s.sort (≤)
apply le_antisymm
have : l.nth_le ((s.sort (≤)).length - 1) h ∈ s := (finset.mem_sort (≤)).1 (list.nth_le_mem l _ h)
{ have : l.nth_le ((s.sort (≤)).length - 1) h ∈ s := (finset.mem_sort (≤)).1 (list.nth_le_mem l _ h), exact s.le_max' _ this }
exact s.le_max' _ this
have : s.max' H ∈ l := (finset.mem_sort (≤)).mpr (s.max'_mem H)
{ have : s.max' H ∈ l := (finset.mem_sort (≤)).mpr (s.max'_mem H), obtain ⟨i, i_lt, hi⟩ : ∃ i (hi : i < l.length), l.nth_le i hi = s.max' H := list.mem_iff_nth_le.1 this, rw ← hi, have : i ≤ l.length - 1 := nat.le_pred_of_lt i_lt, exact (s.sort_sorted (≤)).rel_nth_le_of_le _ _ (nat.le_pred_of_lt i_lt) }
obtain ⟨i, i_lt, hi⟩ : ∃ i (hi : i < l.length), l.nth_le i hi = s.max' H := list.mem_iff_nth_le.1 this
rw ← hi
have : i ≤ l.length - 1 := nat.le_pred_of_lt i_lt
exact (s.sort_sorted (≤)).rel_nth_le_of_le _ _ (nat.le_pred_of_lt i_lt)
intros
ext s
by_cases hs : s = a
rw [hs, add_apply, erase_same, erase_same, erase_same, add_zero]
{ rw [hs, add_apply, erase_same, erase_same, erase_same, add_zero] }
rw [add_apply, erase_ne hs, erase_ne hs, erase_ne hs, add_apply]
intros
rw ← fintype.card_coe at h
rcases nonempty_of_card_le h with ⟨f⟩
exact ⟨f.trans (embedding.subtype _), by simp [set.range_subset_iff]⟩
intros
rcases exists_seq_of_forall_finset_exists P r h with ⟨f, hf, hf'⟩
refine ⟨f, hf, λ m n hmn, _⟩
rcases lt_trichotomy m n with h|rfl|h
{ exact hf' m n h }
exact hf' m n h
{ exact (hmn rfl).elim }
exact (hmn rfl).elim
apply symm
{ apply symm, exact hf' n m h }
exact hf' n m h
intros
classical
rw ←not_iff_not
push_neg
rw [not_nontrivial_iff_subsingleton, card_le_one_iff_subsingleton]
intros
apply finset.prod_eq_mul a b h₁ (λ x _ hx, h₂ x hx)
apply finset.prod_eq_mul a b h₁ (λ x _ hx, h₂ x hx); exact λ hc, (hc (finset.mem_univ _)).elim
exact λ hc, (hc (finset.mem_univ _)).elim
exact λ hc, (hc (finset.mem_univ _)).elim
intros
refine ⟨λ h, is_unit_eq_one_or h, λ h, _⟩
rcases h with rfl | rfl
{ exact is_unit_one }
exact is_unit_one
{ exact is_unit_one.neg }
exact is_unit_one.neg
intros
{ rw [sq, sq], exact nat_abs_le_iff_mul_self_le }
rw [sq, sq]
exact nat_abs_le_iff_mul_self_le
intros
rw [mul_comm, int.mul_div_assoc _ h, mul_comm]
intros
rw [gcd_div (gcd_dvd_left i j) (gcd_dvd_right i j)]
rw [nat_abs_of_nat, nat.div_self H]
intros
rw [even_add, even_iff_not_odd, even_iff_not_odd, not_iff_not]
intros
cases l; refl
cases l
refl
refl
intros
induction l; simp *
induction l
simp *
simp *
intros
simpa [←length_eq_zero] using nat.sub_eq_zero_of_le h
intros
revert a; induction l; intros; [refl, simp only [*, map, foldl]]
revert a; induction l; intros
revert a; induction l
revert a
induction l
intros
refl
intros
simp only [*, map, foldl]
intros
induction l; [refl, simp only [*, list.join, map, prod_append, prod_cons]]
induction l
refl
simp only [*, list.join, map, prod_append, prod_cons]
intros
induction l with x l
{ exfalso, exact lt_irrefl _ h }
exfalso
exact lt_irrefl _ h
by_cases h' : f x < g x
{ by_cases h' : f x < g x, exact ⟨x, mem_cons_self _ _, h'⟩, rcases l_ih _ with ⟨y, h1y, h2y⟩, refine ⟨y, mem_cons_of_mem x h1y, h2y⟩, simp at h, exact lt_of_add_lt_add_left (lt_of_lt_of_le h $ add_le_add_right (le_of_not_gt h') _) }
exact ⟨x, mem_cons_self _ _, h'⟩
rcases l_ih _ with ⟨y, h1y, h2y⟩
refine ⟨y, mem_cons_of_mem x h1y, h2y⟩
simp at h
exact lt_of_add_lt_add_left (lt_of_lt_of_le h $ add_le_add_right (le_of_not_gt h') _)
intros
induction l; [refl, simp only [*, pmap, map]]; split; refl
induction l; [refl, simp only [*, pmap, map]]; split
induction l; [refl, simp only [*, pmap, map]]
induction l
refl
simp only [*, pmap, map]
split
refl
refl
intros
simp only [reduce_option, filter_map, id.def]
intros
simp [-add_comm]
intros
rw [permutations_aux, permutations_aux.rec]
intros
rw [erase_eq_erasep, erase_eq_erasep, erasep_append_right]
rw [erase_eq_erasep, erase_eq_erasep, erasep_append_right]; rintro b h' rfl; exact h h'
rw [erase_eq_erasep, erase_eq_erasep, erasep_append_right]; rintro b h' rfl
rintro b h' rfl
exact h h'
intros
simp only [concat_eq_append, last_append]
intros
cases pairwise_cons.1 p with r p'
clear p
induction p' with b l r' p IH generalizing a
exact chain.nil
{exact chain.nil}
simp only [chain_cons, forall_mem_cons] at r
exact chain_cons.2 ⟨r.1, IH r'⟩
intros
obtain ⟨n, hn, rfl⟩ := nth_le_of_mem hx
simp only [next_nth_le, prev_nth_le, h, nat.mod_add_mod]
cases l with hd tl
{ simp }
simp
have : n < 1 + tl.length := by simpa [add_comm] using hn
{ have : n < 1 + tl.length := by simpa [add_comm] using hn, simp [add_left_comm, add_comm, add_assoc, nat.mod_eq_of_lt this] }
simp [add_left_comm, add_comm, add_assoc, nat.mod_eq_of_lt this]
intros
induction h with l' h y l' h hm
{ exact mem_cons_self _ _ }
exact mem_cons_self _ _
{ exact mem_cons_of_mem _ hm }
exact mem_cons_of_mem _ hm
intros
dsimp [Ico]; simp [nat.add_sub_cancel_left]
dsimp [Ico]
simp [nat.add_sub_cancel_left]
intros
induction l₁ with a l₁ ih generalizing l₂
{ exact h }
exact h
apply nodup_insert
exact ih h
intros
refine (pairwise_pmap h).2 (pairwise.imp_of_mem _ hl)
intros
apply hS
assumption
intros
obtain ⟨n, rfl⟩ := h
obtain ⟨m, rfl⟩ := h'
rw rotate_rotate
use (n + m)
intros
rw [rotate_eq_rotate', rotate_eq_rotate', rotate'_cons_succ]
intros
rw [sublists', sublists'_aux]; simp only [sublists'_aux_eq_sublists', map_id, append_nil]; refl
rw [sublists', sublists'_aux]; simp only [sublists'_aux_eq_sublists', map_id, append_nil]
rw [sublists', sublists'_aux]
simp only [sublists'_aux_eq_sublists', map_id, append_nil]
refl
intros
{ ext, apply neg_dot_product }
ext
apply neg_dot_product
intros
ext
{ ext, refl }
refl
intros
dsimp [bit1]; by_cases h : i = j; simp [h]
dsimp [bit1]; by_cases h : i = j
dsimp [bit1]
by_cases h : i = j
simp [h]
simp [h]
intros
{ ext, simp [mul_apply, ring_hom.map_sum], }
ext
simp [mul_apply, ring_hom.map_sum]
intros
ext a b
simp only [mul_apply, std_basis_matrix, boole_mul]
by_cases h₁ : i = a; by_cases h₂ : k = b; simp [h₁, h₂]
by_cases h₁ : i = a; by_cases h₂ : k = b
by_cases h₁ : i = a
by_cases h₂ : k = b
simp [h₁, h₂]
simp [h₁, h₂]
by_cases h₂ : k = b
simp [h₁, h₂]
simp [h₁, h₂]
intros
ext ⟨i, k⟩ ⟨j, k'⟩
simp only [block_diagonal'_apply, diagonal]
split_ifs; finish
split_ifs
finish
finish
finish
finish
finish
finish
intros
rw vec_alt0_append
intros
rw [← to_matrix_trans, single_trans_single_of_ne hb, to_matrix_bot]
intros
induction s with l a b
{ induction s with l a b, exact list.sizeof_lt_sizeof_of_mem hx, refl }
exact list.sizeof_lt_sizeof_of_mem hx
refl
intros
split_ifs with h; simp only [h, multiset.countp_cons_of_pos, add_zero, multiset.countp_cons_of_neg, not_false_iff]
split_ifs with h
simp only [h, multiset.countp_cons_of_pos, add_zero, multiset.countp_cons_of_neg, not_false_iff]
simp only [h, multiset.countp_cons_of_pos, add_zero, multiset.countp_cons_of_neg, not_false_iff]
intros
rw [← rel_flip, rel_cons_left]
apply exists_congr
assume a
apply exists_congr
assume as'
rw [rel_flip, flip]
intros
simp [hc.comm]
intros
rw [← coeff_X_pow, pow_one]
intros
{ ext1, apply map_C }
ext1
apply map_C
intros
rw succ_le_iff
intros
rw [subsingleton.elim h1 (le_trans (le_succ n) h2), le_rec_on_trans (le_succ n) h2, le_rec_on_succ']
intros
{ rw mul_comm, exact mod_add_div _ _ }
rw mul_comm
exact mod_add_div _ _
intros
rcases n_dvd with ⟨k, rfl⟩
have : n ≠ 0
rintro rfl
{rintro rfl, simpa using n_nonzero}
simpa using n_nonzero
rw nat.mul_div_cancel_left _ (pos_iff_ne_zero.2 this)
rw [nat.cast_mul, mul_div_cancel_left _ n_nonzero]
intros
rw [choose_eq_factorial_div_factorial hk, choose_eq_factorial_div_factorial (nat.sub_le _ _), nat.sub_sub_self hk, mul_comm]
intros
classical
rw [sum_powerset_neg_one_pow_card, if_neg]
rw [← ne.def, ← nonempty_iff_ne_empty]
apply h0
intros
induction L with d L ih
{ refl, }
refl
dsimp [of_digits]
{ dsimp [of_digits], dsimp [nat.modeq] at *, conv_lhs { rw [nat.add_mod, nat.mul_mod, h, ih], }, conv_rhs { rw [nat.add_mod, nat.mul_mod], }, }
dsimp [nat.modeq] at *
conv_lhs { rw [nat.add_mod, nat.mul_mod, h, ih], }
conv_rhs { rw [nat.add_mod, nat.mul_mod], }
intros
rw [gcd_comm, gcd_gcd_self_right_right]
intros
simp [coprime]
intros
rw [log, if_neg (λ h : b ≤ n ∧ 1 < b, h.1.not_lt hnb)]
intros
by_cases h : a < b; simp [mkpair, h]
by_cases h : a < b
simp [mkpair, h]
exact le_trans (le_mul_self _) (nat.le_add_right _ _)
simp [mkpair, h]
intros
rcases even_or_odd n with ⟨k, rfl⟩ | ⟨k, rfl⟩
rcases even_or_odd n with ⟨k, rfl⟩ | ⟨k, rfl⟩; use k
use k
simpa only [xor, true_and, eq_self_iff_true, not_true, or_false, and_false] using (succ_ne_self (2*k)).symm
{ simpa only [xor, true_and, eq_self_iff_true, not_true, or_false, and_false] using (succ_ne_self (2*k)).symm }
use k
simp only [xor, add_right_eq_self, false_or, eq_self_iff_true, not_true, not_false_iff, one_ne_zero, and_self]
{ simp only [xor, add_right_eq_self, false_or, eq_self_iff_true, not_true, not_false_iff, one_ne_zero, and_self] }
intros
{ rw ← h, exact not_prime_mul h₁ h₂ }
rw ← h
exact not_prime_mul h₁ h₂
intros
cases x; simp only [pmap, none_bind, some_bind, pbind]
{ cases x; simp only [pmap, none_bind, some_bind, pbind] }
cases x
simp only [pmap, none_bind, some_bind, pbind]
simp only [pmap, none_bind, some_bind, pbind]
intros
cases o; simp [to_list, eq_comm]
cases o
simp [to_list, eq_comm]
simp [to_list, eq_comm]
intros
cases t; refl
cases t
refl
refl
intros
rw nat.dist_comm; exact H.dist_le
rw nat.dist_comm
exact H.dist_le
intros
rw [← dest_mk x,h,dest_mk]
intros
cases p; reflexivity
cases p
reflexivity
intros
dsimp [start, v, xgcd_type.a, xgcd_type.b, w, z]
rw [one_mul, one_mul, zero_mul, zero_mul, zero_add, add_zero]
rw [← nat.pred_eq_sub_one, ← nat.pred_eq_sub_one]
rw [nat.succ_pred_eq_of_pos a.pos, nat.succ_pred_eq_of_pos b.pos]
intros
simp [bit0, add_mul]
intros
apply coeff_eq_zero_of_degree_lt
by_cases hp : p = 0
{ subst hp, exact with_bot.bot_lt_coe n }
subst hp
exact with_bot.bot_lt_coe n
{ rwa [degree_eq_nat_degree hp, with_bot.coe_lt_coe] }
rwa [degree_eq_nat_degree hp, with_bot.coe_lt_coe]
intros
simp [(monic_X_pow n).degree_mul]
intros
by_cases hp : p = 0
{ rw hp, exact le_top }
rw hp
exact le_top
rw trailing_degree_eq_nat_trailing_degree hp
{ rw trailing_degree_eq_nat_trailing_degree hp, exact le_trailing_degree_of_ne_zero h }
exact le_trailing_degree_of_ne_zero h
intros
convert iterate_derivative_smul a p k; apply C_mul'
convert iterate_derivative_smul a p k
apply C_mul'
apply C_mul'
intros
simp [erase_lead_coeff, hi]
intros
nontriviality R
apply nat_degree_mul'
simp [hp.leading_coeff, hq.leading_coeff]
intros
rw [reverse, reverse, reflect_neg, nat_degree_neg]
intros
rw [taylor_coeff, hasse_deriv_one]
intros
lift b to ℕ using le_of_lt hb0
norm_cast at hb0 h
rw [← rat.mk_eq_div, ← rat.mk_pnat_eq a b hb0, rat.mk_pnat_num, pnat.mk_coe, h.gcd_eq_one, int.coe_nat_one, int.div_one]
intros
rw [← mk_zero, mk_lt]; exact iff_of_eq (congr_arg pos (sub_zero f))
rw [← mk_zero, mk_lt]
exact iff_of_eq (congr_arg pos (sub_zero f))
intros
simp [ennreal.to_real]
intros
induction n with n ihn
simp
{ simp }
rw [pow_succ, mul_eq_top, ihn]
fsplit
rintro (⟨-,rfl,h0⟩|⟨rfl,h0⟩); exact ⟨rfl, n.succ_ne_zero⟩
rintro (⟨-,rfl,h0⟩|⟨rfl,h0⟩)
{ rintro (⟨-,rfl,h0⟩|⟨rfl,h0⟩); exact ⟨rfl, n.succ_ne_zero⟩ }
exact ⟨rfl, n.succ_ne_zero⟩
exact ⟨rfl, n.succ_ne_zero⟩
rintro ⟨rfl, -⟩
{ rintro ⟨rfl, -⟩, exact or.inr ⟨rfl, pow_ne_zero n top_ne_zero⟩ }
exact or.inr ⟨rfl, pow_ne_zero n top_ne_zero⟩
intros
apply lt_of_le_of_ne (ereal.neg_le_of_neg_le h.le)
assume H
rw [← H, ereal.neg_neg] at h
exact lt_irrefl _ h
intros
simpa only [sub_eq_add_neg, cast_neg] using h.add_rat (-q)
intros
rw [← nnreal.coe_lt_coe, nnreal.coe_div]; exact half_lt_self (bot_lt_iff_ne_bot.2 h)
rw [← nnreal.coe_lt_coe, nnreal.coe_div]
exact half_lt_self (bot_lt_iff_ne_bot.2 h)
intros
rw [sign, if_pos hr]
intros
simp_rw [sqrt, ← nnreal.coe_mul, nnreal.coe_eq, real.to_nnreal_mul hx, nnreal.sqrt_mul]
intros
induction n; simp [*, tail_congr]
induction n
simp [*, tail_congr]
simp [*, tail_congr]
intros
rw [← ite_compl, ite_inter_self]
intros
rw [diff_subset_iff, ← image_union, union_diff_self]
exact image_subset f (subset_union_right t s)
intros
apply subset.antisymm
{ rintros _ ⟨b, rfl⟩, simp }
rintros _ ⟨b, rfl⟩
simp
rintros ⟨x, y⟩ (rfl|_)
{ rintros ⟨x, y⟩ (rfl|_), exact mem_range_self y }
exact mem_range_self y
intros
{ ext, simp }
ext
simp
intros
ext
{ ext, simp [pi] }
simp [pi]
intros
ext c
split
rintros ⟨a, b, ha, h1b|h2b, rfl⟩;[left, right]; exact ⟨_, _, ‹_›, ‹_›, rfl⟩
rintros ⟨a, b, ha, h1b|h2b, rfl⟩;[left, right]
rintros ⟨a, b, ha, h1b|h2b, rfl⟩
{ rintros ⟨a, b, ha, h1b|h2b, rfl⟩;[left, right]; exact ⟨_, _, ‹_›, ‹_›, rfl⟩ }
left
exact ⟨_, _, ‹_›, ‹_›, rfl⟩
right
exact ⟨_, _, ‹_›, ‹_›, rfl⟩
rintro (⟨_, _, _, _, rfl⟩|⟨_, _, _, _, rfl⟩); refine ⟨_, _, ‹_›, _, rfl⟩; simp [mem_union, *]
rintro (⟨_, _, _, _, rfl⟩|⟨_, _, _, _, rfl⟩); refine ⟨_, _, ‹_›, _, rfl⟩
rintro (⟨_, _, _, _, rfl⟩|⟨_, _, _, _, rfl⟩)
{ rintro (⟨_, _, _, _, rfl⟩|⟨_, _, _, _, rfl⟩); refine ⟨_, _, ‹_›, _, rfl⟩; simp [mem_union, *] }
refine ⟨_, _, ‹_›, _, rfl⟩
simp [mem_union, *]
refine ⟨_, _, ‹_›, _, rfl⟩
simp [mem_union, *]
intros
{ rw ← image_prod, exact (hs.prod ht).image _ }
rw ← image_prod
exact (hs.prod ht).image _
intros
classical
rw [fintype.card_of_subtype (set.to_finset pᶜ), set.to_finset_compl p, finset.card_compl, fintype.card_of_subtype (set.to_finset p)]
rw [fintype.card_of_subtype (set.to_finset pᶜ), set.to_finset_compl p, finset.card_compl, fintype.card_of_subtype (set.to_finset p)]; intros; simp; refl
rw [fintype.card_of_subtype (set.to_finset pᶜ), set.to_finset_compl p, finset.card_compl, fintype.card_of_subtype (set.to_finset p)]; intros; simp
rw [fintype.card_of_subtype (set.to_finset pᶜ), set.to_finset_compl p, finset.card_compl, fintype.card_of_subtype (set.to_finset p)]; intros
intros
simp
refl
intros
simp
refl
intros
refine (h₁.congr _).union_union (h₂.congr _)
exacts [(piecewise_eq_on s f₁ f₂).symm.mono (inter_subset_right _ _), (piecewise_eq_on_compl s f₁ f₂).symm.mono (inter_subset_right _ _)]
intros
simp only [Ioi_inter_Iio.symm, Ioi_inter_Ioi.symm, Iio_inter_Iio.symm]
simp only [Ioi_inter_Iio.symm, Ioi_inter_Ioi.symm, Iio_inter_Iio.symm]; ac_refl
ac_refl
intros
simp_rw [set.disjoint_iff_inter_eq_empty, Ico_inter_Ico, Ico_eq_empty_iff, inf_eq_min, sup_eq_max, not_lt]
intros
simp
intros
simp [← Ici_inter_Iio, h]
intros
{ rw ← Icc_self, exact ord_connected_Icc }
rw ← Icc_self
exact ord_connected_Icc
intros
simp only [interval, preimage_neg_Icc, min_neg_neg, max_neg_neg]
intros
simp [set.not_disjoint_iff, set.nonempty_def]
intros
haveI : nonempty s := hs.to_subtype
simp [bInter_eq_Inter, ← Inter_inter]
intros
cases x; refl
cases x
refl
intros
cases s
change a ∈ b ::ₘ s_val ↔ a = b ∨ a ∈ s_val
simp
intros
cases v; cases i; cases j; simp [vector.update_nth, vector.nth_eq_nth_le, list.nth_le_update_nth_of_ne (fin.vne_of_ne h)]
cases v; cases i; cases j
cases v; cases i
cases v
cases i
cases j
simp [vector.update_nth, vector.nth_eq_nth_le, list.nth_le_update_nth_of_ne (fin.vne_of_ne h)]
intros
simp [val]
intros
cases n
calc a * a⁻¹ = a * int.sign a : rfl ... = a.nat_abs : by rw [int.mul_sign, int.nat_cast_eq_coe_nat] ... = a.val.gcd 0 : by rw nat.gcd_zero_right; refl
{ calc a * a⁻¹ = a * int.sign a : rfl ... = a.nat_abs : by rw [int.mul_sign, int.nat_cast_eq_coe_nat] ... = a.val.gcd 0 : by rw nat.gcd_zero_right; refl }
set k := n.succ
{ set k := n.succ, calc a * a⁻¹ = a * a⁻¹ + k * nat.gcd_b (val a) k : by rw [nat_cast_self, zero_mul, add_zero] ... = ↑(↑a.val * nat.gcd_a (val a) k + k * nat.gcd_b (val a) k) : by { push_cast, rw nat_cast_zmod_val, refl } ... = nat.gcd a.val k : (congr_arg coe (nat.gcd_eq_gcd_ab a.val k)).symm, }
calc a * a⁻¹ = a * a⁻¹ + k * nat.gcd_b (val a) k : by rw [nat_cast_self, zero_mul, add_zero] ... = ↑(↑a.val * nat.gcd_a (val a) k + k * nat.gcd_b (val a) k) : by { push_cast, rw nat_cast_zmod_val, refl } ... = nat.gcd a.val k : (congr_arg coe (nat.gcd_eq_gcd_ab a.val k)).symm
intros
cases n; simp
{ cases n; simp }
cases n
simp
simp
intros
split
split; simp
simp
simp
intros
refine ae_all_iff.2 (λ k, _)
refine (hf.ae_mem_imp_frequently_image_mem (hf.measurable.iterate k hs)).mono (λ x hx hk, _)
rw [← map_add_at_top_eq_nat k, frequently_map]
refine (hx hk).mono (λ n hn, _)
rwa [add_comm, iterate_add_apply]
intros
apply_instance
intros
rw power_basis.finrank (adjoin.power_basis hx : _)
refl
intros
{ convert is_alg_closed.splits (p.map f), simp [splits_map_iff] }
convert is_alg_closed.splits (p.map f)
simp [splits_map_iff]
intros
let ψ := alg_equiv.of_injective_field (is_scalar_tower.to_alg_hom F p.splitting_field E)
change ↑(ψ (ψ.symm _)) = ϕ x
rw alg_equiv.apply_symm_apply ψ
change ϕ (roots_equiv_roots p E ((roots_equiv_roots p E).symm x)) = ϕ x
rw equiv.apply_symm_apply (roots_equiv_roots p E)
intros
rw [← expand_C, expand_inj hp, expand_C]
intros
change i with ((ring_hom.id _).comp i) at h
rw [← splits_map_iff]
rw [← splits_map_iff i] at h
exact splits_of_splits_id _ h
intros
unfold angle
rw [inner_zero_left, zero_div, real.arccos_zero]
intros
rw [dist_eq_norm_vsub V, dist_eq_norm_vsub V, dist_eq_norm_vsub V, ← vsub_sub_vsub_cancel_right]
exact norm_sub_eq_abs_sub_norm_of_angle_eq_zero h
intros
change ∃ r : ℝ, ∀ i, (λ x, dist x p = r) (s.points i) at hr
conv at hr { congr, funext, rw ←set.forall_range_iff }
rw exists_dist_eq_iff_exists_dist_orthogonal_projection_eq (subset_affine_span ℝ _) p at hr
cases hr with r hr
exact s.eq_circumcenter_of_dist_eq (orthogonal_projection_mem p) (λ i, hr _ (set.mem_range_self i))
intros
filter_upwards [is_open.mem_nhds (ext_chart_preimage_open_of_open I c is_open_ball) ⟨hs, hd⟩]
rintro z ⟨hzs, hzd : _ < _⟩
exact f.one_of_dist_le hzs hzd.le
intros
ext
{ ext, rw hxs.eq h h.mdifferentiable_within_at.has_mfderiv_within_at }
rw hxs.eq h h.mdifferentiable_within_at.has_mfderiv_within_at
intros
rw [← has_mfderiv_within_at_univ, has_mfderiv_within_at_iff_has_fderiv_within_at, has_fderiv_within_at_univ]
intros
rw [ext_chart_at, local_equiv.trans_source, I.source_eq, preimage_univ, inter_univ]
intros
rw times_cont_mdiff_within_at_iff'' at *
exact ⟨hf.1.prod hg.1, hf.2.prod hg.2⟩
intros
intros x hx y hy h
simp only [embedding_pi_tangent_coe, funext_iff] at h
obtain ⟨h₁, h₂⟩ := prod.mk.inj_iff.1 (h (f.ind x hx))
rw [f.apply_ind x hx] at h₂
rw [← h₂, f.apply_ind x hx, one_smul, one_smul] at h₁
have := f.mem_ext_chart_at_source_of_eq_one h₂.symm
exact (ext_chart_at I (f.c _)).inj_on (f.mem_ext_chart_at_ind_source x hx) this h₁
intros
rw sup_eq_con_gen; refl
rw sup_eq_con_gen
refl
intros
convert @abelianization.lift.of (free_group α) _ (multiplicative β) _ _ _
convert free_group.lift.of.symm
intros
induction L with hd1 tl1 ih
case list.nil { constructor }
constructor
case list.cons { dsimp, revert ih, generalize htl : reduce tl1 = TL, intro ih, cases TL with hd2 tl2, case list.nil { exact red.cons_cons ih }, case list.cons { dsimp, by_cases h : hd1.fst = hd2.fst ∧ hd1.snd = bnot (hd2.snd), { rw [if_pos h], transitivity, { exact red.cons_cons ih }, { cases hd1, cases hd2, cases h, dsimp at *, subst_vars, exact red.step.cons_bnot_rev.to_red } }, { rw [if_neg h], exact red.cons_cons ih } } }
dsimp
revert ih
generalize htl : reduce tl1 = TL
intro ih
cases TL with hd2 tl2
case list.nil { exact red.cons_cons ih }
exact red.cons_cons ih
case list.cons { dsimp, by_cases h : hd1.fst = hd2.fst ∧ hd1.snd = bnot (hd2.snd), { rw [if_pos h], transitivity, { exact red.cons_cons ih }, { cases hd1, cases hd2, cases h, dsimp at *, subst_vars, exact red.step.cons_bnot_rev.to_red } }, { rw [if_neg h], exact red.cons_cons ih } }
dsimp
by_cases h : hd1.fst = hd2.fst ∧ hd1.snd = bnot (hd2.snd)
rw [if_pos h]
{ rw [if_pos h], transitivity, { exact red.cons_cons ih }, { cases hd1, cases hd2, cases h, dsimp at *, subst_vars, exact red.step.cons_bnot_rev.to_red } }
transitivity
exact red.cons_cons ih
{ exact red.cons_cons ih }
cases hd1
{ cases hd1, cases hd2, cases h, dsimp at *, subst_vars, exact red.step.cons_bnot_rev.to_red }
cases hd2
cases h
dsimp at *
subst_vars
exact red.step.cons_bnot_rev.to_red
rw [if_neg h]
{ rw [if_neg h], exact red.cons_cons ih }
exact red.cons_cons ih
intros
suffices : ∀ H₁ H₂ : subgroup G, ⁅H₁, H₂⁆ ≤ ⁅H₂, H₁⁆
exact le_antisymm (this _ _) (this _ _)
{ exact le_antisymm (this _ _) (this _ _) }
intros H₁ H₂
rw general_commutator_le
intros p hp q hq
have h : (p * q * p⁻¹ * q⁻¹)⁻¹ ∈ ⁅H₂, H₁⁆ := subset_closure ⟨q, hq, p, hp, by group⟩
convert inv_mem ⁅H₂, H₁⁆ h
group
intros
rw [smul_mul_assoc, mul_smul_comm, ← smul_assoc, smul_eq_mul]
intros
rw mul_equiv_of_localizations_left_inv
intros
rw [f.eq, localization.r_iff_exists]
intros
rw [powers_equiv_powers, equiv.trans_apply, equiv.trans_apply, fin_equiv_powers_symm_apply, ← equiv.eq_symm_apply, fin_equiv_powers_symm_apply]
simp [h]
intros
rw [parts_partition, filter_add, multiset.filter_eq_self.2 (λ _, two_le_of_mem_cycle_type), multiset.filter_eq_nil.2 (λ a h, _), add_zero]
rw multiset.eq_of_mem_repeat h
dec_trivial
intros
simp [cycle_factors_finset_eq_empty_iff]
intros
simp only [set.sup_eq_union, set.le_eq_subset]
induction l with y l hl generalizing l'
{ simp }
simp
cases l' with z l'
{ cases l' with z l', { simp }, { intro x, simp only [set.union_subset_iff, mem_cons_iff, zip_with_cons_cons, foldr, prod_cons, mul_apply], intro hx, by_cases h : x ∈ {x | (zip_with swap l l').prod x ≠ x}, { specialize hl l' h, refine set.mem_union.elim hl (λ hm, _) (λ hm, _); { simp only [finset.coe_insert, set.mem_insert_iff, finset.mem_coe, to_finset_cons, mem_to_finset] at hm ⊢, simp [hm] } }, { simp only [not_not, set.mem_set_of_eq] at h, simp only [h, set.mem_set_of_eq] at hx, rw swap_apply_ne_self_iff at hx, rcases hx with ⟨hyz, rfl|rfl⟩; simp } } }
{ simp }
simp
intro x
{ intro x, simp only [set.union_subset_iff, mem_cons_iff, zip_with_cons_cons, foldr, prod_cons, mul_apply], intro hx, by_cases h : x ∈ {x | (zip_with swap l l').prod x ≠ x}, { specialize hl l' h, refine set.mem_union.elim hl (λ hm, _) (λ hm, _); { simp only [finset.coe_insert, set.mem_insert_iff, finset.mem_coe, to_finset_cons, mem_to_finset] at hm ⊢, simp [hm] } }, { simp only [not_not, set.mem_set_of_eq] at h, simp only [h, set.mem_set_of_eq] at hx, rw swap_apply_ne_self_iff at hx, rcases hx with ⟨hyz, rfl|rfl⟩; simp } }
simp only [set.union_subset_iff, mem_cons_iff, zip_with_cons_cons, foldr, prod_cons, mul_apply]
intro hx
by_cases h : x ∈ {x | (zip_with swap l l').prod x ≠ x}
specialize hl l' h
{ specialize hl l' h, refine set.mem_union.elim hl (λ hm, _) (λ hm, _); { simp only [finset.coe_insert, set.mem_insert_iff, finset.mem_coe, to_finset_cons, mem_to_finset] at hm ⊢, simp [hm] } }
refine set.mem_union.elim hl (λ hm, _) (λ hm, _); { simp only [finset.coe_insert, set.mem_insert_iff, finset.mem_coe, to_finset_cons, mem_to_finset] at hm ⊢, simp [hm] }
refine set.mem_union.elim hl (λ hm, _) (λ hm, _)
{ simp only [finset.coe_insert, set.mem_insert_iff, finset.mem_coe, to_finset_cons, mem_to_finset] at hm ⊢, simp [hm] }
simp only [finset.coe_insert, set.mem_insert_iff, finset.mem_coe, to_finset_cons, mem_to_finset] at hm ⊢
{ simp only [finset.coe_insert, set.mem_insert_iff, finset.mem_coe, to_finset_cons, mem_to_finset] at hm ⊢, simp [hm] }
simp [hm]
simp only [not_not, set.mem_set_of_eq] at h
{ simp only [not_not, set.mem_set_of_eq] at h, simp only [h, set.mem_set_of_eq] at hx, rw swap_apply_ne_self_iff at hx, rcases hx with ⟨hyz, rfl|rfl⟩; simp }
simp only [h, set.mem_set_of_eq] at hx
rw swap_apply_ne_self_iff at hx
rcases hx with ⟨hyz, rfl|rfl⟩; simp
rcases hx with ⟨hyz, rfl|rfl⟩
simp
simp
intros
simp [equiv_functor.map]
intros
simp_rw [finset.ext_iff, mem_support, not_iff_not, (inv_eq_iff_eq).trans eq_comm, iff_self, imp_true_iff]
intros
ext
ext; simp [map]
simp [map]
simp [map]
intros
rw [mem_alternating_group, sign_prod_list_swap hl, ← units.coe_eq_one, units.coe_pow, units.coe_neg_one, nat.neg_one_pow_eq_one_iff_even]
dec_trivial
intros
{ ext, simp, }
ext
simp
intros
simp only [mrange_inl, mrange_inr, prod_bot_sup_bot_prod, top_prod_top]
intros
{ ext p, simp [homothety_apply] }
ext p
simp [homothety_apply]
intros
rw [direction_eq_vector_span, vector_span_def]
repeat { rw [direction_eq_vector_span, vector_span_def] }
rw [direction_eq_vector_span, vector_span_def]
rw [direction_eq_vector_span, vector_span_def]
exact vector_span_mono k h
intros
simp [h]
intros
simp_rw [collinear_iff_dim_le_one, dim_submodule_le_one_iff', submodule.le_span_singleton_iff]
split
rintro ⟨v₀, hv⟩
{ rintro ⟨v₀, hv⟩, use v₀, intros p hp, obtain ⟨r, hr⟩ := hv (p -ᵥ p₀) (vsub_mem_vector_span k hp h), use r, rw eq_vadd_iff_vsub_eq, exact hr.symm }
use v₀
intros p hp
obtain ⟨r, hr⟩ := hv (p -ᵥ p₀) (vsub_mem_vector_span k hp h)
use r
rw eq_vadd_iff_vsub_eq
exact hr.symm
rintro ⟨v, hp₀v⟩
{ rintro ⟨v, hp₀v⟩, use v, intros w hw, have hs : vector_span k s ≤ k ∙ v, { rw [vector_span_eq_span_vsub_set_right k h, submodule.span_le, set.subset_def], intros x hx, rw [set_like.mem_coe, submodule.mem_span_singleton], rw set.mem_image at hx, rcases hx with ⟨p, hp, rfl⟩, rcases hp₀v p hp with ⟨r, rfl⟩, use r, simp }, have hw' := set_like.le_def.1 hs hw, rwa submodule.mem_span_singleton at hw' }
use v
intros w hw
have hs : vector_span k s ≤ k ∙ v
rw [vector_span_eq_span_vsub_set_right k h, submodule.span_le, set.subset_def]
{ rw [vector_span_eq_span_vsub_set_right k h, submodule.span_le, set.subset_def], intros x hx, rw [set_like.mem_coe, submodule.mem_span_singleton], rw set.mem_image at hx, rcases hx with ⟨p, hp, rfl⟩, rcases hp₀v p hp with ⟨r, rfl⟩, use r, simp }
intros x hx
rw [set_like.mem_coe, submodule.mem_span_singleton]
rw set.mem_image at hx
rcases hx with ⟨p, hp, rfl⟩
rcases hp₀v p hp with ⟨r, rfl⟩
use r
simp
have hw' := set_like.le_def.1 hs hw
rwa submodule.mem_span_singleton at hw'
intros
rw [midpoint, point_reflection_apply, line_map_apply, vadd_vsub, vadd_vadd, ← add_smul, ← two_mul, mul_inv_of_self, one_smul, vsub_vadd]
intros
{ rw add_comm, exact f.map_swap_add v hij }
rw add_comm
exact f.map_swap_add v hij
intros
use [0, x, submodule.mem_span_singleton_self x]
intros H
rw [eq_comm, submodule.mk_eq_zero] at H
exact h H
intros
{ ext, simp }
ext
simp
intros
split
intros h
{ intros h, use 0, rw [← set_like.mem_coe, f.range_coe], exact ⟨⟨0, map_zero f⟩, h⟩, }
use 0
rw [← set_like.mem_coe, f.range_coe]
exact ⟨⟨0, map_zero f⟩, h⟩
rintros ⟨y, h₁, h₂⟩
{ rintros ⟨y, h₁, h₂⟩, rw set_like.le_def, intros z hz, simp only [mem_ker, set_like.mem_coe] at hz, rw [← set_like.mem_coe, f.range_coe, set.mem_range] at h₁, obtain ⟨x, hx⟩ := h₁, have hx' : x ∈ p, { exact h₂ hx, }, have hxz : z + x ∈ p, { apply h₂, simp [hx, hz], }, suffices : z + x - x ∈ p, { simpa only [this, add_sub_cancel], }, exact p.sub_mem hxz hx', }
rw set_like.le_def
intros z hz
simp only [mem_ker, set_like.mem_coe] at hz
rw [← set_like.mem_coe, f.range_coe, set.mem_range] at h₁
obtain ⟨x, hx⟩ := h₁
have hx' : x ∈ p
exact h₂ hx
{ exact h₂ hx, }
have hxz : z + x ∈ p
apply h₂
{ apply h₂, simp [hx, hz], }
simp [hx, hz]
suffices : z + x - x ∈ p
simpa only [this, add_sub_cancel]
{ simpa only [this, add_sub_cancel], }
exact p.sub_mem hxz hx'
intros
{ rw ← b.coe_repr_symm, exact b.repr.apply_symm_apply v }
rw ← b.coe_repr_symm
exact b.repr.apply_symm_apply v
intros
simp [basis.constr_apply, b.repr_self]
intros
rw [dual_basis, basis.map_apply, basis.coe_dual_basis, ← to_dual_def hB, linear_equiv.apply_symm_apply, basis.coord_apply, basis.repr_self, finsupp.single_apply]
intros
simp only [bilin_form.comp_left, bilin_form.to_matrix'_comp, to_matrix'_id, matrix.mul_one]
intros
letI := classical.dec_eq (basis.of_vector_space_index K V)
apply tensor_product.ext
apply (basis.of_vector_space K V).dual_basis.ext
intro j
apply linear_map.ext_ring
rw [linear_map.compr₂_apply, linear_map.compr₂_apply, tensor_product.mk_apply]
simp only [linear_map.coe_comp, function.comp_app, linear_equiv.coe_to_linear_map]
rw [rid_tmul, one_smul, lid_symm_apply]
simp only [linear_equiv.coe_to_linear_map, linear_map.ltensor_tmul, coevaluation_apply_one]
rw [tensor_product.tmul_sum, linear_equiv.map_sum]
simp only [assoc_symm_tmul]
rw [linear_map.map_sum]
simp only [linear_map.rtensor_tmul, contract_left_apply]
simp only [basis.coe_dual_basis, basis.coord_apply, basis.repr_self_apply, tensor_product.ite_tmul]
rw [finset.sum_ite_eq']
simp only [finset.mem_univ, if_true]
intros
fapply card_le_of_surjective' R
{ exact b.repr.to_linear_map.comp (finsupp.total w M R coe), }
exact b.repr.to_linear_map.comp (finsupp.total w M R coe)
apply surjective.comp
{ apply surjective.comp, apply linear_equiv.surjective, rw [←linear_map.range_eq_top, finsupp.range_total], simpa using s, }
apply linear_equiv.surjective
rw [←linear_map.range_eq_top, finsupp.range_total]
simpa using s
intros
rw ←fintype.card_coe
exact fintype_card_le_finrank_of_linear_independent h
intros
rw [← s.finrank_quotient_add_finrank, add_comm]
exact nat.lt_add_of_zero_lt_left _ _ (finrank_pos_iff.mpr (quotient.nontrivial_of_lt_top _ h))
intros
simp only [finsupp.total_apply, finsupp.total_apply, finsupp.sum, f.map_sum, f.map_smul]
intros
simp [linear_independent_subtype_disjoint]
intros
simp [linear_independent, linear_map.ker_eq_bot']
intros
let b2 : m → ℕ := λ i, ↑(b i)
simp_rw to_square_block_det''
rw fin.prod_univ_eq_prod_range (λ (k : ℕ), (M.to_square_block' b2 k).det) n
apply det_of_block_triangular_matrix
{ intros i j hij, exact h i j (fin.coe_fin_lt.mp hij) }
intros i j hij
exact h i j (fin.coe_fin_lt.mp hij)
{ intro i, exact fin.is_lt (b i) }
intro i
exact fin.is_lt (b i)
intros
ext i j
simp only [mul_apply, circulant, mul_comm]
refine fintype.sum_equiv ((equiv.sub_left i).trans (equiv.add_right j)) _ _ _
intro x
congr' 2
{ simp }
simp
simp only [equiv.coe_add_right, function.comp_app, equiv.coe_trans, equiv.sub_left_apply]
{ simp only [equiv.coe_add_right, function.comp_app, equiv.coe_trans, equiv.sub_left_apply], abel }
abel
intros
simp [det_update_row_add, det_update_row_smul, det_zero_of_row_eq hij ((update_row_self).trans (update_row_ne hij.symm).symm)]
intros
rw ←(is_symm_from_blocks_iff.1 h).2.1
exact ha.from_blocks hd
intros
split
split; intros; ext i
split; intros
intros
ext i
{ apply (cramer_map_is_linear A i).1 }
apply (cramer_map_is_linear A i).1
intros
ext i
{ apply (cramer_map_is_linear A i).2 }
apply (cramer_map_is_linear A i).2
intros
simp [module.algebra_map_End_eq_smul_id, linear_map.to_matrix_id]
intros
revert m'
refine finset.induction_on t (by simp) _
assume i t hit Hrec m'
have A : (insert i t).piecewise (m + m') m' = update (t.piecewise (m + m') m') i (m i + m' i) := t.piecewise_insert _ _ _
have B : update (t.piecewise (m + m') m') i (m' i) = t.piecewise (m + m') m'
ext j
{ ext j, by_cases h : j = i, { rw h, simp [hit] }, { simp [h] } }
by_cases h : j = i
{ rw h, simp [hit] }
rw h
simp [hit]
{ simp [h] }
simp [h]
let m'' := update m' i (m i)
have C : update (t.piecewise (m + m') m') i (m i) = t.piecewise (m + m'') m''
ext j
{ ext j, by_cases h : j = i, { rw h, simp [m'', hit] }, { by_cases h' : j ∈ t; simp [h, hit, m'', h'] } }
by_cases h : j = i
{ rw h, simp [m'', hit] }
rw h
simp [m'', hit]
by_cases h' : j ∈ t; simp [h, hit, m'', h']
{ by_cases h' : j ∈ t; simp [h, hit, m'', h'] }
by_cases h' : j ∈ t
simp [h, hit, m'', h']
simp [h, hit, m'', h']
rw [A, f.map_add, B, C, finset.sum_powerset_insert hit, Hrec, Hrec, add_comm]
congr' 1
apply finset.sum_congr rfl (λs hs, _)
have : (insert i s).piecewise m m' = s.piecewise m m''
ext j
{ ext j, by_cases h : j = i, { rw h, simp [m'', finset.not_mem_of_mem_powerset_of_not_mem hs hit] }, { by_cases h' : j ∈ s; simp [h, m'', h'] } }
by_cases h : j = i
{ rw h, simp [m'', finset.not_mem_of_mem_powerset_of_not_mem hs hit] }
rw h
simp [m'', finset.not_mem_of_mem_powerset_of_not_mem hs hit]
by_cases h' : j ∈ s; simp [h, m'', h']
{ by_cases h' : j ∈ s; simp [h, m'', h'] }
by_cases h' : j ∈ s
simp [h, m'', h']
simp [h, m'', h']
rw this
intros
by_cases j = i
{ rw [h, update_same, update_same] }
rw [h, update_same, update_same]
{ rw [update_noteq h, update_noteq h] }
rw [update_noteq h, update_noteq h]
intros
ext x
ext x; simp [(⟨0, zero_mem _⟩ : ∃ x, x ∈ p)]
simp [(⟨0, zero_mem _⟩ : ∃ x, x ∈ p)]
intros
simp [of_is_compl]
intros
classical
induction s using finset.induction with a s has ih h
{ simp, }
simp
{ simp [finset.sum_insert has, add_tmul, ih], }
simp [finset.sum_insert has, add_tmul, ih]
intros
rw [@iff_def a, @iff_def b]; exact and_congr imp_not_comm decidable.not_imp_comm
rw [@iff_def a, @iff_def b]
exact and_congr imp_not_comm decidable.not_imp_comm
intros
{ext, refl}
ext
refl
intros
induction h
exact ih₁ a
case refl_trans_gen.refl { exact ih₁ a }
case refl_trans_gen.tail : b c hab hbc ih { exact ih₃ hab (single hbc) ih (ih₂ hbc) }
intros
simpa only [max_def] using hf.piecewise (measurable_set_le hg hf) hg
intros
simp_rw [integrable, hf.of_uncurry_left.ae_measurable, true_and]
exact measurable_set_lt (measurable.lintegral_prod_right hf.ennnorm) measurable_const
intros
have A : ∫⁻ z, f z ∂(μ.prod ν) = ∫⁻ z, hf.mk f z ∂(μ.prod ν) := lintegral_congr_ae hf.ae_eq_mk
have B : ∫⁻ x, ∫⁻ y, f (x, y) ∂ν ∂μ = ∫⁻ x, ∫⁻ y, hf.mk f (x, y) ∂ν ∂μ
apply lintegral_congr_ae
{ apply lintegral_congr_ae, filter_upwards [ae_ae_of_ae_prod hf.ae_eq_mk], assume a ha, exact lintegral_congr_ae ha }
filter_upwards [ae_ae_of_ae_prod hf.ae_eq_mk]
assume a ha
exact lintegral_congr_ae ha
rw [A, B, lintegral_prod_of_measurable _ hf.measurable_mk]
apply_instance
intros
refine lintegral_le_of_forall_fin_meas_le' hm (μ s * ∥x∥₊) _ (λ t ht hμt, _)
{ exact (Lp.ae_measurable _).nnnorm.coe_nnreal_ennreal, }
exact (Lp.ae_measurable _).nnnorm.coe_nnreal_ennreal
refine (set_lintegral_nnnorm_condexp_ind_smul_le hm hs hμs x ht hμt).trans _
refine ennreal.mul_le_mul _ le_rfl
exact measure_mono (set.inter_subset_left _ _)
intros
simp [has_finite_integral_iff_norm]
intros
rw [mem_ℒp, snorm_one_eq_lintegral_nnnorm]
exact ⟨ae_measurable.ennreal_to_real hfm, has_finite_integral_to_real_of_lintegral_ne_top hfi⟩
intros
{ convert edist_to_Lp_to_Lp f 0 hf zero_mem_ℒp, simp }
convert edist_to_Lp_to_Lp f 0 hf zero_mem_ℒp
simp
intros
refine ⟨λ hfg, ⟨_, _⟩, λ h, h.1.add h.2⟩
rw ← indicator_add_eq_left h
{ rw ← indicator_add_eq_left h, exact hfg.indicator (measurable_set_support hf) }
exact hfg.indicator (measurable_set_support hf)
rw ← indicator_add_eq_right h
{ rw ← indicator_add_eq_right h, exact hfg.indicator (measurable_set_support hg) }
exact hfg.indicator (measurable_set_support hg)
intros
simp only [snorm]
split_ifs
{ exact le_rfl }
exact le_rfl
refine ess_sup_mono_ae (h.mono $ λ x hx, _)
{ refine ess_sup_mono_ae (h.mono $ λ x hx, _), exact_mod_cast hx }
exact_mod_cast hx
{ exact snorm'_mono_ae ennreal.to_real_nonneg h }
exact snorm'_mono_ae ennreal.to_real_nonneg h
intros
{ simp only [sub_eq_add_neg, ← to_Lp_neg, ← to_Lp_add], refl }
simp only [sub_eq_add_neg, ← to_Lp_neg, ← to_Lp_add]
refl
intros
have hf' : f.fin_meas_supp μ := integrable_iff_fin_meas_supp.1 hf
simp only [← map_apply g f, lintegral_eq_lintegral]
rw [map_integral f _ hf, map_lintegral, ennreal.to_real_sum]
refine finset.sum_congr rfl (λb hb, _)
{ refine finset.sum_congr rfl (λb hb, _), rw [smul_eq_mul, to_real_mul, mul_comm] }
rw [smul_eq_mul, to_real_mul, mul_comm]
assume a ha
{ assume a ha, by_cases a0 : a = 0, { rw [a0, hg0, zero_mul], exact with_top.zero_ne_top }, { apply mul_ne_top (ht a) (hf'.meas_preimage_singleton_ne_zero a0).ne } }
by_cases a0 : a = 0
{ rw [a0, hg0, zero_mul], exact with_top.zero_ne_top }
rw [a0, hg0, zero_mul]
exact with_top.zero_ne_top
{ apply mul_ne_top (ht a) (hf'.meas_preimage_singleton_ne_zero a0).ne }
apply mul_ne_top (ht a) (hf'.meas_preimage_singleton_ne_zero a0).ne
{ simp [hg0] }
simp [hg0]
intros
simp only [integrable_on, e.restrict_map, integrable_map_equiv e]
intros
rw [integral_of_le hab, integral_eq_zero_iff_of_nonneg_ae hf hfi.1]
intros
refine set_to_simple_func_congr' T h_add hf ((integrable_congr h).mp hf) _
refine λ x y hxy, h_zero _ ((measurable_set_fiber f x).inter (measurable_set_fiber g y)) _
rw [eventually_eq, ae_iff] at h
refine measure_mono_null (λ z, _) h
simp_rw [set.mem_inter_iff, set.mem_set_of_eq, set.mem_preimage, set.mem_singleton_iff]
intro h
rwa [h.1, h.2]
intros
refine measurable_prod.2 _
split
split; { apply measurable_pi_iff.2 (λ j, _), simp only [pi_equiv_pi_subtype_prod_apply, measurable_pi_apply] }
{ apply measurable_pi_iff.2 (λ j, _), simp only [pi_equiv_pi_subtype_prod_apply, measurable_pi_apply] }
apply measurable_pi_iff.2 (λ j, _)
{ apply measurable_pi_iff.2 (λ j, _), simp only [pi_equiv_pi_subtype_prod_apply, measurable_pi_apply] }
simp only [pi_equiv_pi_subtype_prod_apply, measurable_pi_apply]
intros
funext
{ funext, refl, }
refl
intros
unfold prehaar
rw [div_le_iff]
rw [div_le_iff]; norm_cast
norm_cast
{ apply le_index_mul K₀ K hU }
apply le_index_mul K₀ K hU
norm_cast
{ exact index_pos K₀ hU }
exact index_pos K₀ hU
intros
rw [interval, volume_Icc, max_sub_min_eq_abs]
intros
apply ennreal.summable_to_real
rw ← measure_theory.measure_Union hf₂ hf₁
exact ne_of_lt (measure_lt_top _ _)
intros
ext1 s
haveI : nonempty {t : ℕ → set α // s ⊆ ⋃ i, t i} := ⟨⟨λ _, s, subset_Union (λ _, s) 0⟩⟩
simp only [smul_apply, of_function_apply, ennreal.tsum_mul_left, pi.smul_apply, smul_eq_mul, infi_subtype', ennreal.infi_mul_left (λ h, (hc h).elim)]
intros
{ simp only [← infi_subtype'', infi_apply' _ hs] }
simp only [← infi_subtype'', infi_apply' _ hs]
intros
rw [union_eq_Union, of_disjoint_Union, tsum_fintype, fintype.sum_bool, cond, cond]
exacts [λ b, bool.cases_on b hB hA, pairwise_disjoint_on_bool.2 h]
intros
induction h_in_pi with s h_s s u h_gen_s h_gen_u h_nonempty h_s h_u
{ apply h_meas_S _ h_s, }
apply h_meas_S _ h_s
{ apply measurable_set.inter h_s h_u, }
apply measurable_set.inter h_s h_u
simp [bernoulli]
intros
rw proper_divisors
simp
intros
rw ←s_mod_mod
convert int.mod_lt _ _
refine (abs_of_nonneg _).symm
{ refine (abs_of_nonneg _).symm, simp only [sub_nonneg, ge_iff_le], exact_mod_cast nat.one_le_two_pow p, }
simp only [sub_nonneg, ge_iff_le]
exact_mod_cast nat.one_le_two_pow p
{ exact mersenne_int_ne_zero p w, }
exact mersenne_int_ne_zero p w
intros
dsimp [mersenne]
calc 0 < 2^1 - 1 : by norm_num ... ≤ 2^p - 1 : nat.pred_le_pred (nat.pow_le_pow_of_le_right (nat.succ_pos 1) h)
intros
rw lt_iff_le_and_ne; simp [norm_le_one z, nonunits, is_unit_iff]
rw lt_iff_le_and_ne
simp [norm_le_one z, nonunits, is_unit_iff]
intros
rw [sub_eq_add_neg, ←padic_norm.neg p r]; apply padic_norm.nonarchimedean
rw [sub_eq_add_neg, ←padic_norm.neg p r]
apply padic_norm.nonarchimedean
intros
unfold has_norm.norm
apply_mod_cast add_eq_max_of_ne'
intro h'
apply h
unfold has_norm.norm
exact_mod_cast h'
intros
intro x
apply dense_range_nat_cast.induction_on x
{ exact is_closed_closure, }
exact is_closed_closure
intro a
{ intro a, change (a.cast : ℤ_[p]) with (a : ℤ).cast, apply subset_closure, exact set.mem_range_self _ }
change (a.cast : ℤ_[p]) with (a : ℤ).cast
apply subset_closure
exact set.mem_range_self _
intros
injection (pell_zd_add _ m n) with _ h; repeat {rw ← int.coe_nat_add at h <|> rw ← int.coe_nat_mul at h}; exact int.coe_nat_inj h
injection (pell_zd_add _ m n) with _ h; repeat {rw ← int.coe_nat_add at h <|> rw ← int.coe_nat_mul at h}
injection (pell_zd_add _ m n) with _ h
repeat {rw ← int.coe_nat_add at h <|> rw ← int.coe_nat_mul at h}
rw ← int.coe_nat_add at h
rw ← int.coe_nat_mul at h
exact int.coe_nat_inj h
intros
rwa [pythagorean_triple_comm]
intros
induction x; induction y; refl
induction x; induction y
induction x
induction y
refl
refl
induction y
refl
refl
intros
simp [to_complex_def]
intros
{ ext x y, exact H x y }
ext x y
exact H x y
intros
rw [sup_comm, sup_sdiff_left]
intros
rw [sdiff_sdiff_left, sup_comm, sdiff_sdiff_left]
intros
{ rw disjoint_iff, exact h.inf_left_eq_bot_iff }
rw disjoint_iff
exact h.inf_left_eq_bot_iff
intros
simp [(≤)]
intros
rw [insert_eq, upper_bounds_union, upper_bounds_singleton]
intros
simp only [← Inf_range, Inf_eq_bot, set.exists_range_iff]
intros
rw [← infi_subtype'', infi_range']
intros
rw [← e.comap_at_top, map_comap_of_surjective e.surjective]
intros
rw [tendsto_iff_comap, comap_principal, le_principal_iff, mem_at_top_sets]
rw [tendsto_iff_comap, comap_principal, le_principal_iff, mem_at_top_sets]; refl
refl
intros
simp [filter.frequently, hl.eventually_iff]
intros
simp [filter.frequently, -not_eventually, not_forall]
intros
simpa only [set.prod_subset_iff] using @mem_prod_iff α β p f g
intros
simp only [bInter_eq_Inter]
haveI := hS.to_encodable
exact eventually_le.countable_Inter (λ i, h i i.2)
intros
casesI is_empty_or_nonempty ι
rw [infi_of_empty f, infi_of_empty, lift'_top, powerset_univ, principal_univ]
{ rw [infi_of_empty f, infi_of_empty, lift'_top, powerset_univ, principal_univ] }
{ exact (lift'_infi $ λ _ _, (powerset_inter _ _).symm) }
exact (lift'_infi $ λ _ _, (powerset_inter _ _).symm)
intros
refine hf.seq_le_seq n _ (λ k hk, _) (λ k hk, _)
refine hf.seq_le_seq n _ (λ k hk, _) (λ k hk, _); simp [iterate_succ' f, h.iterate_right _ _, hg.iterate _ hx]
simp [iterate_succ' f, h.iterate_right _ _, hg.iterate _ hx]
simp [iterate_succ' f, h.iterate_right _ _, hg.iterate _ hx]
simp [iterate_succ' f, h.iterate_right _ _, hg.iterate _ hx]
intros
simp
intros
rw symm_diff_eq_sup_sdiff_inf
{ rw symm_diff_eq_sup_sdiff_inf, exact sdiff_le }
exact sdiff_le
intros
have h : ϕ.to_ring_hom.comp (of f) = algebra_map R S := ring_hom.ext_iff.mpr (ϕ.commutes)
rw [aeval_def, ←h, ←ring_hom.map_zero ϕ.to_ring_hom, ←eval₂_root f, hom_eval₂]
refl
intros
rw [← finset.card_range n, ← finset.prod_const]
{ rw [← finset.card_range n, ← finset.prod_const], exact is_coprime.prod_right (λ _ _, H) }
exact is_coprime.prod_right (λ _ _, H)
intros
rw [← hsum_smul, sub_smul, one_smul, hsum_sub, ← hsum_emb_domain (x • powers x hx) ⟨nat.succ, nat.succ_injective⟩, emb_domain_succ_smul_powers]
simp
intros
simp [mem_span_insert, mem_span_singleton', @eq_comm _ _ z]
intros
refine ⟨λ h, _, λ h, I.mul_mem_left y h⟩
obtain ⟨y', hy'⟩ := hy.exists_left_inv
have := I.mul_mem_left y' h
rwa [← mul_assoc, hy', one_mul] at this
intros
rw [ring_hom.ker, eq_bot_iff, map_le_iff_le_comap]
intros
{ unfold span, rw submodule.span_mul_span, }
unfold span
rw submodule.span_mul_span
intros
obtain ⟨p, ⟨p_monic, hp⟩⟩ := hx
refine ⟨scale_roots p r, ⟨(monic_scale_roots_iff r).2 p_monic, _⟩⟩
convert scale_roots_eval₂_eq_zero f hp
rw [mul_comm x y, ← mul_assoc, hr, one_mul]
intros
rw [is_maximal_iff_is_maximal_disjoint S y, comap_map_of_is_prime_disjoint (powers y) S I (is_maximal.is_prime hI) ((disjoint_powers_iff_not_mem y (is_maximal.is_prime hI).radical).2 hy)]
exact ⟨hI, hy⟩
intros
{ unfold has_add.add localization.add, apply lift_on₂_mk }
unfold has_add.add localization.add
apply lift_on₂_mk
intros
rw [lt_top_iff_ne_top, ne_top_iff_finite]
intros
rw [total_degree, finset.sup_le_iff]
refl
intros
obtain ⟨n, w⟩ := monotone_stabilizes_iff_noetherian.mpr I (f.iterate_ker.comp ⟨λ n, n+1, λ n m w, by linarith⟩)
specialize w (2 * n + 1) (by linarith)
dsimp at w
refine ⟨n+1, nat.succ_ne_zero _, _⟩
rw eq_bot_iff
rintros - ⟨h, ⟨y, rfl⟩⟩
rw [mem_bot, ←linear_map.mem_ker, w]
erw linear_map.mem_ker at h ⊢
change ((f ^ (n + 1)) * (f ^ (n + 1))) y = 0 at h
rw ←pow_add at h
convert h using 3
linarith
intros
rw I.radical_eq_jacobson
refine le_antisymm (le_Inf _) (λ p hp x hx, _)
rintros J ⟨hJI, hJ⟩
{ rintros J ⟨hJI, hJ⟩, obtain ⟨x, hx⟩ := (is_maximal_iff_eq_vanishing_ideal_singleton J).1 hJ, refine hx.symm ▸ vanishing_ideal_anti_mono (λ y hy p hp, _), rw [← mem_vanishing_ideal_singleton_iff, set.mem_singleton_iff.1 hy, ← hx], refine hJI hp }
obtain ⟨x, hx⟩ := (is_maximal_iff_eq_vanishing_ideal_singleton J).1 hJ
refine hx.symm ▸ vanishing_ideal_anti_mono (λ y hy p hp, _)
rw [← mem_vanishing_ideal_singleton_iff, set.mem_singleton_iff.1 hy, ← hx]
refine hJI hp
rw ← mem_vanishing_ideal_singleton_iff x p
{ rw ← mem_vanishing_ideal_singleton_iff x p, refine (mem_Inf.mp hp) ⟨le_trans (le_vanishing_ideal_zero_locus I) (vanishing_ideal_anti_mono (λ y hy, hy.symm ▸ hx)), mv_polynomial.vanishing_ideal_singleton_is_maximal⟩ }
refine (mem_Inf.mp hp) ⟨le_trans (le_vanishing_ideal_zero_locus I) (vanishing_ideal_anti_mono (λ y hy, hy.symm ▸ hx)), mv_polynomial.vanishing_ideal_singleton_is_maximal⟩
intros
rw eq_top_iff
intros v hv
rw submodule.mem_sup
rcases hpq with ⟨p', q', hpq'⟩
use aeval f (p * p') v
use linear_map.mem_range.2 ⟨aeval f p' v, by simp only [linear_map.mul_apply, aeval_mul]⟩
use aeval f (q * q') v
use linear_map.mem_range.2 ⟨aeval f q' v, by simp only [linear_map.mul_apply, aeval_mul]⟩
simpa only [mul_comm p p', mul_comm q q', aeval_one, aeval_add] using congr_arg (λ p : polynomial R, aeval f p v) hpq'
intros
rw [T_eq_X_mul_T_sub_pol_U, ←sub_add, sub_self, zero_add]
intros
split
split; intro h
intro h
rcases h with ⟨r, rfl⟩
{ rcases h with ⟨r, rfl⟩, rw [content_mul, p.is_primitive_prim_part.dvd_prim_part_iff_dvd hq], exact ⟨dvd.intro _ rfl, p.prim_part_dvd.trans (dvd.intro _ rfl)⟩ }
rw [content_mul, p.is_primitive_prim_part.dvd_prim_part_iff_dvd hq]
exact ⟨dvd.intro _ rfl, p.prim_part_dvd.trans (dvd.intro _ rfl)⟩
intro h
rw [p.eq_C_content_mul_prim_part, q.eq_C_content_mul_prim_part]
{ rw [p.eq_C_content_mul_prim_part, q.eq_C_content_mul_prim_part], exact mul_dvd_mul (ring_hom.map_dvd C h.1) h.2 }
exact mul_dvd_mul (ring_hom.map_dvd C h.1) h.2
intros
intros c hc
classical
rw coeff_monomial at hc
split_ifs at hc with h
{ subst c, exact hn }
subst c
exact hn
{ contradiction }
contradiction
intros
rw [to_fun_linear_tmul_apply, to_fun_bilinear_apply_apply, polynomial.aeval_one, algebra_map_smul, algebra.algebra_map_eq_smul_one]
intros
intros p q h
rw power_series.ext_iff at *
intros n
specialize h n
rw [coeff_rescale, coeff_rescale, mul_eq_mul_left_iff] at h
apply h.resolve_right
intro h'
exact ha (pow_eq_zero h')
intros
rw [coeff, finsupp.single_zero, X, mv_power_series.coeff_zero_X]
intros
simp_rw [@eq_comm _ x, ← mem_span_singleton, span_singleton_generator]
intros
apply mv_polynomial.map_injective (int.cast_ring_hom ℚ) int.cast_injective
simp only [witt_neg, witt_structure_rat, rename_X, X_in_terms_of_W_zero, map_X, witt_polynomial_zero, ring_hom.map_neg, alg_hom.map_neg, bind₁_X_right, map_witt_structure_int]
intros
use (select_poly P)
rintro R _Rcr x
funext i
apply coeff_select
intros
rw [witt_polynomial_eq_sum_C_mul_X_pow, alg_hom.map_sum]
simp only [alg_hom.map_pow, C_pow, alg_hom.map_mul, alg_hom_C]
rw [sum_range_succ_comm, nat.sub_self, pow_zero, pow_one, bind₁_X_right, mul_comm, ← C_pow, X_in_terms_of_W_aux]
simp only [C_pow, bind₁_X_right, sub_add_cancel]
intros
cases le_total c₂ c₃; simp only [max_eq_left, max_eq_right, h, powerlt_le_powerlt_left]
cases le_total c₂ c₃
{ cases le_total c₂ c₃; simp only [max_eq_left, max_eq_right, h, powerlt_le_powerlt_left] }
simp only [max_eq_left, max_eq_right, h, powerlt_le_powerlt_left]
simp only [max_eq_left, max_eq_right, h, powerlt_le_powerlt_left]
intros
{ rw ←not_iff_not, simp [bit0], }
rw ←not_iff_not
simp [bit0]
intros
{cases x, cases y, refl}
cases x
cases y
refl
intros
split
intro heq
{ intro heq, exact first_loses_of_equiv (add_congr (equiv_refl _) heq) (add_self G) }
exact first_loses_of_equiv (add_congr (equiv_refl _) heq) (add_self G)
intro hGHp
{ intro hGHp, split, { rw le_iff_sub_nonneg, exact le_trans hGHp.2 (le_trans add_comm_le $ le_of_le_of_equiv (pgame.le_refl _) $ add_congr (equiv_refl _) (neg_equiv_self G)) }, { rw le_iff_sub_nonneg, exact le_trans hGHp.2 (le_of_le_of_equiv (pgame.le_refl _) $ add_congr (equiv_refl _) (neg_equiv_self H)) } }
split
rw le_iff_sub_nonneg
{ rw le_iff_sub_nonneg, exact le_trans hGHp.2 (le_trans add_comm_le $ le_of_le_of_equiv (pgame.le_refl _) $ add_congr (equiv_refl _) (neg_equiv_self G)) }
exact le_trans hGHp.2 (le_trans add_comm_le $ le_of_le_of_equiv (pgame.le_refl _) $ add_congr (equiv_refl _) (neg_equiv_self G))
rw le_iff_sub_nonneg
{ rw le_iff_sub_nonneg, exact le_trans hGHp.2 (le_of_le_of_equiv (pgame.le_refl _) $ add_congr (equiv_refl _) (neg_equiv_self H)) }
exact le_trans hGHp.2 (le_of_le_of_equiv (pgame.le_refl _) $ add_congr (equiv_refl _) (neg_equiv_self H))
intros
induction l; simp *
induction l
simp *
simp *
intros
simp only [lt_iff_le_and_ne, ordinal.zero_le, true_and, ne.def, eq_comm]
intros
simpa only [not_ball, not_le] using not_congr (@mul_le_of_limit b c a h)
rw lt_def; exact or.inl ⟨⟨0, zero_lt_one⟩, (by split; rintros ⟨⟩)⟩
rw lt_def
exact or.inl ⟨⟨0, zero_lt_one⟩, (by split; rintros ⟨⟩)⟩
dsimp [has_zero.zero, has_neg.neg, neg]
congr
congr; funext i; cases i
congr; funext i
intros
rw lt_def_le
right
use j
intros
simp [smul, nsmul_zero]
intros
simp
intros
rw ← h.coe; exact a.2
rw ← h.coe
exact a.2
intros
simp [pow_add]
intros
cc
intros
simpa only [sum_range_one] using (sum_add_tsum_nat_add 1 hf).symm
intros
{ simp only [← coe_inj, linear_map.prod_ext_iff], refl }
simp only [← coe_inj, linear_map.prod_ext_iff]
refl
intros
refine mem_of_superset (set_pi_mem_nhds (finite.of_fintype _) (λ i _, _)) (pi_univ_Iio_subset a)
exact Iio_mem_nhds (ha i)
intros
simp_rw [mul_comm _ x₀, nhds_eq_map_mul_left_nhds_one hx₀]
intros
rw [← Ioi_inter_Iic, interior_inter, interior_Ioi, interior_Iic, Ioi_inter_Iio]
intros
rw [continuous_within_at_Ioi_iff_Ici, continuous_within_at_Iio_iff_Iic, continuous_at_iff_continuous_left_right]
intros
simp only [continuous_iff_continuous_at, continuous_at_iff_ultrafilter]
intros
split
split ; intro h
intro h
rintros U U_op ⟨x, x_in⟩
{ rintros U U_op ⟨x, x_in⟩, exact mem_closure_iff.1 (by simp only [h.closure_eq]) U U_op x_in }
exact mem_closure_iff.1 (by simp only [h.closure_eq]) U U_op x_in
intro h
intro x
{ intro x, rw mem_closure_iff, intros U U_op x_in, exact h U U_op ⟨_, x_in⟩ }
rw mem_closure_iff
intros U U_op x_in
exact h U U_op ⟨_, x_in⟩
intros
rw [interior_eq_nhds', mem_set_of_eq]
intros
{ ext, refl }
ext
refl
intros
rw [nhds_prod_eq, mem_prod_iff]
intros
convert inf_mem_subalgebra_closure A f g
apply set_like.ext'
symmetry
erw closure_eq_iff_is_closed
exact h
intros
simp [continuous_within_at, nhds_within_restrict' s h]
intros
haveI := di.comap_nhds_ne_bot; exact hf.lim_eq
haveI := di.comap_nhds_ne_bot
exact hf.lim_eq
intros
rw [ennreal.tsum_eq_supr_nat, filter.liminf_eq_supr_infi_of_nat]
congr
refine funext (λ n, le_antisymm _ _)
refine le_binfi (λ i hi, finset.sum_le_sum_of_subset_of_nonneg _ (λ _ _ _, zero_le _))
{ refine le_binfi (λ i hi, finset.sum_le_sum_of_subset_of_nonneg _ (λ _ _ _, zero_le _)), simpa only [finset.range_subset, add_le_add_iff_right] using hi, }
simpa only [finset.range_subset, add_le_add_iff_right] using hi
refine le_trans (infi_le _ n) _
{ refine le_trans (infi_le _ n) _, simp [le_refl n, le_refl ((finset.range n).sum f)], }
simp [le_refl n, le_refl ((finset.range n).sum f)]
intros
simp_rw [ennreal.of_real, ennreal.tsum_coe_eq (nnreal.has_sum_of_real_of_nonneg hf_nonneg hf)]
intros
have : e '' s = e.target ∩ e.symm ⁻¹' s := e.to_local_equiv.image_eq_target_inter_inv_preimage h
rw this
exact e.continuous_on_symm.preimage_open_of_open e.open_target hs
intros
{ intros s hs, rw image_comp, exact hg _ (hf _ hs) }
intros s hs
rw image_comp
exact hg _ (hf _ hs)
intros
simpa only [div_eq_inv_mul] using nnreal.div_le_of_le_mul' (hf.le_mul_nndist x y)
intros
simpa only [hy.eq, edist_self, add_zero] using hf.edist_inequality h
intros
cases o; simp
cases o
simp
simp
intros
{ rw ← image_univ, exact hf.ediam_image univ }
rw ← image_univ
exact hf.ediam_image univ
intros
simp only [lipschitz_with, edist_nndist, dist_nndist]
{ simp only [lipschitz_with, edist_nndist, dist_nndist], norm_cast }
norm_cast
intros
rcases precise_refinement_set hs _ ho hU with ⟨V, hVo, hsV, hVf, hVU⟩
rcases exists_is_subordinate_of_locally_finite hs V hVo hVf hsV with ⟨f, hf⟩
exact ⟨f, hf.mono hVU⟩
intros
cases hxy.mem with hx hy
cases hyz.mem with hx hy
simp [joined_in_iff_joined, *] at *
exact hxy.trans hyz
intros
simp_rw [← lower_semicontinuous_within_at_univ_iff] at *
exact lower_semicontinuous_within_at_tsum h
intros
split
introI hX
{ introI hX, exact nhds_discrete X }
exact nhds_discrete X
intro h
{ intro h, constructor, apply eq_of_nhds_eq_nhds, simp [h, nhds_bot] }
constructor
apply eq_of_nhds_eq_nhds
simp [h, nhds_bot]
intros
rw ← sequential_space.sequential_closure_eq_closure
{ rw ← sequential_space.sequential_closure_eq_closure, exact iff.rfl }
exact iff.rfl
intros
rw ← is_open_compl_iff
convert ultrafilter_is_open_basic sᶜ
ext u
exact ultrafilter.compl_mem_iff_not_mem.symm
intros
set Y := ⋂ i, V i
obtain ⟨W, hsubW, W_op, hWU⟩ : ∃ W, Y ⊆ W ∧ is_open W ∧ W ⊆ U
from exists_open_set_nhds hU
suffices : ∃ i, V i ⊆ W
rcases this with ⟨i, hi⟩
{ rcases this with ⟨i, hi⟩, refine ⟨i, set.subset.trans hi hWU⟩ }
refine ⟨i, set.subset.trans hi hWU⟩
by_contradiction H
push_neg at H
replace H : ∀ i, (V i ∩ Wᶜ).nonempty := λ i, set.inter_compl_nonempty_iff.mpr (H i)
have : (⋂ i, V i ∩ Wᶜ).nonempty
apply is_compact.nonempty_Inter_of_directed_nonempty_compact_closed _ _ H
{ apply is_compact.nonempty_Inter_of_directed_nonempty_compact_closed _ _ H, { intro i, exact (hV_cpct i).inter_right W_op.is_closed_compl }, { intro i, apply (hV_closed i).inter W_op.is_closed_compl }, { intros i j, rcases hV i j with ⟨k, hki, hkj⟩, use k, split ; intro x ; simp only [and_imp, mem_inter_eq, mem_compl_eq] ; tauto } }
intro i
{ intro i, exact (hV_cpct i).inter_right W_op.is_closed_compl }
exact (hV_cpct i).inter_right W_op.is_closed_compl
intro i
{ intro i, apply (hV_closed i).inter W_op.is_closed_compl }
apply (hV_closed i).inter W_op.is_closed_compl
intros i j
{ intros i j, rcases hV i j with ⟨k, hki, hkj⟩, use k, split ; intro x ; simp only [and_imp, mem_inter_eq, mem_compl_eq] ; tauto }
rcases hV i j with ⟨k, hki, hkj⟩
use k
split ; intro x ; simp only [and_imp, mem_inter_eq, mem_compl_eq] ; tauto
split ; intro x ; simp only [and_imp, mem_inter_eq, mem_compl_eq]
split ; intro x
split
intro x
simp only [and_imp, mem_inter_eq, mem_compl_eq]
tauto
intro x
simp only [and_imp, mem_inter_eq, mem_compl_eq]
tauto
have : ¬ (⋂ (i : ι), V i) ⊆ W
simpa [← Inter_inter, inter_compl_nonempty_iff]
simpa [← Inter_inter, inter_compl_nonempty_iff]
contradiction
intros
{ unfold separation_rel, rw h.sInter_sets }
unfold separation_rel
rw h.sInter_sets
intros
cases b; simp
cases b
simp
simp
intros
rw int.add_comm
exact int.sub_left_le_of_le_add h
intros
induction l; simp [*]
induction l
simp [*]
simp [*]
intros
cases n; simp [gcd]
cases n
simp [gcd]
simp [gcd]
intros
rw [← nat.div_div_eq_div_mul, nat.mul_div_cancel_left _ H]
intros
rw [algebra.smul_def, mul_one, ring_hom.eq_rat_cast]
intros
rw [← span_mul_span, span_eq, span_eq]
intros
simp
intros
{ rw ← finprod_one, congr }
rw ← finprod_one
congr
intros
rw [← finprod_mem_inter_mul_support f s, ← finprod_mem_inter_mul_support f t, ← finprod_mem_union hst hs ht, ← union_inter_distrib_right, finprod_mem_inter_mul_support]
intros
cases x with j₁ x
cases y with j₂ y
cases x' with j₃ x'
obtain ⟨l, f, g, hfg⟩ := hxx'
simp at hfg
obtain ⟨s, α, β, γ, h₁, h₂, h₃⟩ := tulip (left_to_max j₁ j₂) (right_to_max j₁ j₂) (right_to_max j₃ j₂) (left_to_max j₃ j₂) f g
apply M.mk_eq
use [s, α, γ]
dsimp
simp_rw [monoid_hom.map_mul, ← comp_apply, ← F.map_comp, h₁, h₂, h₃, F.map_comp, comp_apply, hfg]
intros
induction n
simp
{simp}
rw [function.iterate_succ', pow_succ', pow_mul, function.comp_apply, frobenius_def, n_ih]
intros
{ rw [eq_comm], exact bit0_eq_zero }
rw [eq_comm]
exact bit0_eq_zero
intros
simp only [nth_cont_eq_succ_nth_cont_aux, (continuants_aux_stable_of_terminated (nat.pred_le_iff.elim_left n_le_m) terminated_at_n)]
intros
simpa only [zero_mul, zero_add] using div_add_mod a 0
intros
simp [neg_div]
intros
rw [← gcd_erase_dup, erase_dup_ext.2, gcd_erase_dup, gcd_add]
{ rw [← gcd_erase_dup, erase_dup_ext.2, gcd_erase_dup, gcd_add], simp }
simp
intros
rw [div_eq_mul_inv, div_eq_mul_inv, div_eq_mul_inv, mul_inv_rev, mul_assoc, mul_assoc, mul_left_cancel_iff, mul_comm, mul_assoc]
intros
rw [← mul_assoc, h.inv_mul_cancel]
intros
cases f; cases g; cases h; refl
cases f; cases g; cases h
cases f; cases g
cases f
cases g
cases h
refl
intros
unfold semiconj_by; rw [mul_assoc, inv_mul_self, mul_one]
unfold semiconj_by
rw [mul_assoc, inv_mul_self, mul_one]
intros
{ ext, cases x; refl }
ext
cases x
cases x; refl
refl
refl
intros
rw [←pow_add, nat.sub_add_cancel h]
intros
rwa [not_iff_not, pow_eq_zero_iff]
intros
simp only [le_iff_lt_or_eq, pow_bit1_neg_iff, pow_eq_zero_iff (bit1_pos (zero_le n))]
intros
rw [eq_comm, inv_eq_iff, eq_comm]
intros
simpa only [div_eq_mul_inv] using congr_arg ((*) a) u.coe_inv'
intros
rw le_antisymm_iff
split
rw le_inf_iff
{ rw le_inf_iff, split, { rw inv_le_inv_iff, apply le_sup_left, }, { rw inv_le_inv_iff, apply le_sup_right, } }
split
{ rw inv_le_inv_iff, apply le_sup_left, }
rw inv_le_inv_iff
apply le_sup_left
{ rw inv_le_inv_iff, apply le_sup_right, }
rw inv_le_inv_iff
apply le_sup_right
rw ← inv_le_inv_iff
{ rw ← inv_le_inv_iff, simp, split, { rw ← inv_le_inv_iff, simp, }, { rw ← inv_le_inv_iff, simp, } }
simp
split
{ rw ← inv_le_inv_iff, simp, }
rw ← inv_le_inv_iff
simp
{ rw ← inv_le_inv_iff, simp, }
rw ← inv_le_inv_iff
simp
intros
ext y
simp only [lie_module.mem_max_triv_submodule, lie_module.mem_ker, ← lie_skew _ y, neg_eq_zero]
intros
{ ext, refl, }
ext
refl
intros
have h : ⁅I, N⁆ ⊔ ⁅J, N⁆ ≤ ⁅I ⊔ J, N⁆
rw sup_le_iff
{ rw sup_le_iff, split; apply mono_lie_left; [exact le_sup_left, exact le_sup_right], }
split
split; apply mono_lie_left; [exact le_sup_left, exact le_sup_right]
split; apply mono_lie_left
apply mono_lie_left
exact le_sup_left
apply mono_lie_left
exact le_sup_right
suffices : ⁅I ⊔ J, N⁆ ≤ ⁅I, N⁆ ⊔ ⁅J, N⁆
exact le_antisymm this h
{ exact le_antisymm this h, }
clear h
rw [lie_ideal_oper_eq_span, lie_span_le]
rintros m ⟨⟨x, hx⟩, n, h⟩
erw lie_submodule.mem_sup
erw lie_submodule.mem_sup at hx
rcases hx with ⟨x₁, hx₁, x₂, hx₂, hx'⟩
use ⁅((⟨x₁, hx₁⟩ : I) : L), (n : N)⁆
split
apply lie_coe_mem_lie
{ apply lie_coe_mem_lie, }
use ⁅((⟨x₂, hx₂⟩ : J) : L), (n : N)⁆
split
apply lie_coe_mem_lie
{ apply lie_coe_mem_lie, }
simp [← h, ← hx']
intros
{ ext a, exact lie_hom.congr_fun h a, }
ext a
exact lie_hom.congr_fun h a
intros
induction k with k ih
simp only [derived_series_def, comap_incl_self, derived_series_of_ideal_zero]
{ simp only [derived_series_def, comap_incl_self, derived_series_of_ideal_zero], }
simp only [derived_series_def, derived_series_of_ideal_succ] at ⊢ ih
{ simp only [derived_series_def, derived_series_of_ideal_succ] at ⊢ ih, rw ih, exact comap_bracket_incl_of_le I (derived_series_of_ideal_le_self I k) (derived_series_of_ideal_le_self I k), }
rw ih
exact comap_bracket_incl_of_le I (derived_series_of_ideal_le_self I k) (derived_series_of_ideal_le_self I k)
intros
split
{ rintros ⟨K, rfl⟩, exact K.lie_mem', }
rintros ⟨K, rfl⟩
exact K.lie_mem'
intros h
{ intros h, use { lie_mem' := h, ..p }, exact lie_subalgebra.coe_to_submodule_mk p _, }
use { lie_mem' := h, ..p }
exact lie_subalgebra.coe_to_submodule_mk p _
intros
simp only [exists_lie_ideal_coe_eq_iff, coe_bracket, mem_of_le]
split
{ intros h' x y hx hy, exact h' ⟨x, hx⟩ ⟨y, h hy⟩ hy, }
intros h' x y hx hy
exact h' ⟨x, hx⟩ ⟨y, h hy⟩ hy
{ rintros h' ⟨x, hx⟩ ⟨y, hy⟩ hy', exact h' x y hx hy', }
rintros h' ⟨x, hx⟩ ⟨y, hy⟩ hy'
exact h' x y hx hy'
intros
rw [mul_comm, inv_mul_le_iff h]
intros
simp only [div_eq_mul_inv, mul_lt_mul_left ha, inv_lt_inv hb hc]
intros
rcases lt_trichotomy a 0 with (ha|rfl|ha)
{ simp [abs_of_neg ha, neg_pos, ha.ne, ha] }
simp [abs_of_neg ha, neg_pos, ha.ne, ha]
{ simp }
simp
{ simp [abs_of_pos ha, ha, ha.ne.symm] }
simp [abs_of_pos ha, ha, ha.ne.symm]
intros
rw [← mul_lt_mul_iff_left b, mul_one, mul_inv_cancel_left]
intros
simpa only [div_eq_mul_inv] using mul_le_mul_iff_right _
intros
simp only [← add_comm a, add_lt_add_iff_left ha]
intros
rw [← neg_nonneg, neg_mul_eq_mul_neg, mul_nonneg_iff, neg_nonneg, neg_nonpos]
intros
haveI := @linear_order.decidable_le α _; exact mul_inv_of_self a ▸ decidable.le_mul_of_one_le_left (inv_of_nonneg.2 $ zero_le_one.trans h) h
haveI := @linear_order.decidable_le α _
exact mul_inv_of_self a ▸ decidable.le_mul_of_one_le_left (inv_of_nonneg.2 $ zero_le_one.trans h) h
intros
rw [← sub_nonneg, ← sub_mul]
exact decidable.ordered_ring.mul_nonneg (sub_nonneg.2 h₁) h₂
intros
simpa only [nsmul_eq_mul] using h.sub_nsmul_eq n
intros
simp * at *
intros
simp only [← image_smul, image_union]
intros
apply nat_degree_multiset_prod'
suffices : (t.map (λ f, leading_coeff f)).prod = 1
rw this
{ rw this, simp }
simp
convert prod_repeat (1 : R) t.card
simp only [eq_repeat, multiset.card_map, eq_self_iff_true, true_and]
{ simp only [eq_repeat, multiset.card_map, eq_self_iff_true, true_and], rintros i hi, obtain ⟨i, hi, rfl⟩ := multiset.mem_map.mp hi, apply h, assumption }
rintros i hi
obtain ⟨i, hi, rfl⟩ := multiset.mem_map.mp hi
apply h
assumption
{ simp }
simp
intros
rcases h with ⟨s, hs⟩
use (-b + s) / (2 * a)
rw quadratic_eq_zero_iff ha hs
simp
intros
rw [coe_mul, coe_mul_eq_smul]
intros
{ rw [is_closed_iff_zero_locus], exact ⟨s, rfl⟩ }
rw [is_closed_iff_zero_locus]
exact ⟨s, rfl⟩
intros
dsimp [δ, σ]
{ dsimp [δ, σ], simp only [←X.map_comp, ←op_comp, simplex_category.δ_comp_σ_of_gt H] }
simp only [←X.map_comp, ←op_comp, simplex_category.δ_comp_σ_of_gt H]
intros
dsimp [δ, σ]
simp only [←X.map_comp, ←op_comp, simplex_category.δ_comp_σ_self, op_id, X.map_id]
intros
simpa only [sub_eq_add_neg] using hf.add hg.neg
intros
convert tendsto_neg_at_top_at_bot.comp (huv.neg.tendsto_at_top $ tendsto_neg_at_bot_at_top.comp hu)
ext
simp
intros
simpa only [pow_one, is_o_norm_right] using @is_o_norm_pow_norm_pow E' _ _ _ h
intros
simpa [is_O, is_O_with] using is_O_fst_prod
intros
simpa [continuous_linear_map.sum_apply] using (has_fderiv_at_filter.sum h).has_deriv_at_filter
intros
simp only [sub_eq_add_neg, differentiable_at_add_const_iff]
intros
rw [differentiable_on, differentiable_on]
simp only [iso.comp_differentiable_within_at_iff]
intros
rcases h with ⟨f', hf'⟩
exact ⟨f', hf'.mono st⟩
intros
rw [iterated_deriv_eq_iterate, iterated_deriv_eq_iterate]
{ rw [iterated_deriv_eq_iterate, iterated_deriv_eq_iterate], refl }
refl
intros
rw [← times_cont_diff_within_at_univ, times_cont_diff_within_at_succ_iff_has_fderiv_within_at]
simp only [nhds_within_univ, exists_prop, mem_univ, insert_eq_of_mem]
split
rintros ⟨u, H, f', h_fderiv, h_times_cont_diff⟩
{ rintros ⟨u, H, f', h_fderiv, h_times_cont_diff⟩, rcases mem_nhds_iff.mp H with ⟨t, htu, ht, hxt⟩, refine ⟨f', ⟨t, _⟩, h_times_cont_diff.times_cont_diff_at H⟩, refine ⟨mem_nhds_iff.mpr ⟨t, subset.rfl, ht, hxt⟩, _⟩, intros y hyt, refine (h_fderiv y (htu hyt)).has_fderiv_at _, exact mem_nhds_iff.mpr ⟨t, htu, ht, hyt⟩ }
rcases mem_nhds_iff.mp H with ⟨t, htu, ht, hxt⟩
refine ⟨f', ⟨t, _⟩, h_times_cont_diff.times_cont_diff_at H⟩
refine ⟨mem_nhds_iff.mpr ⟨t, subset.rfl, ht, hxt⟩, _⟩
intros y hyt
refine (h_fderiv y (htu hyt)).has_fderiv_at _
exact mem_nhds_iff.mpr ⟨t, htu, ht, hyt⟩
rintros ⟨f', ⟨u, H, h_fderiv⟩, h_times_cont_diff⟩
{ rintros ⟨f', ⟨u, H, h_fderiv⟩, h_times_cont_diff⟩, refine ⟨u, H, f', _, h_times_cont_diff.times_cont_diff_within_at⟩, intros x hxu, exact (h_fderiv x hxu).has_fderiv_within_at }
refine ⟨u, H, f', _, h_times_cont_diff.times_cont_diff_within_at⟩
intros x hxu
exact (h_fderiv x hxu).has_fderiv_within_at
intros
set pr := @continuous_linear_map.proj 𝕜 _ ι F' _ _ _
refine ⟨λ h i, h.continuous_linear_map_comp (pr i), λ h m hm, _⟩
choose u hux p hp using λ i, h i m hm
exact ⟨⋂ i, u i, filter.Inter_mem.2 hux, _, has_ftaylor_series_up_to_on_pi.2 (λ i, (hp i).mono $ Inter_subset _ _)⟩
intros
simpa only [div_eq_mul_inv] using hf.mul (hg.inv hx)
intros
induction n with n IH generalizing x
{ ext m, simp [hL x hx] }
ext m
simp [hL x hx]
have : fderiv_within 𝕜 (λ y, iterated_fderiv_within 𝕜 n f₁ s y) s x = fderiv_within 𝕜 (λ y, iterated_fderiv_within 𝕜 n f s y) s x := fderiv_within_congr (hs x hx) (λ y hy, IH hy) (IH hx)
{ have : fderiv_within 𝕜 (λ y, iterated_fderiv_within 𝕜 n f₁ s y) s x = fderiv_within 𝕜 (λ y, iterated_fderiv_within 𝕜 n f s y) s x := fderiv_within_congr (hs x hx) (λ y hy, IH hy) (IH hx), ext m, rw [iterated_fderiv_within_succ_apply_left, iterated_fderiv_within_succ_apply_left, this] }
ext m
rw [iterated_fderiv_within_succ_apply_left, iterated_fderiv_within_succ_apply_left, this]
intros
rw [←add_smul, h, one_smul]
intros
intros x y hx hy a b ha hb hab
obtain ⟨x', hx', rfl⟩ := mem_image_iff_bex.1 hx
obtain ⟨y', hy', rfl⟩ := mem_image_iff_bex.1 hy
exact ⟨a • x' + b • y', hs hx' hy' ha hb hab, by rw [f.map_add, f.map_smul, f.map_smul]⟩
intros
apply set.subset.antisymm
intros x hx
{ intros x hx, simp only [exists_prop, set.mem_Union], exact ⟨caratheodory.min_card_finset_of_mem_convex_hull hx, caratheodory.min_card_finset_of_mem_convex_hull_subseteq hx, caratheodory.affine_independent_min_card_finset_of_mem_convex_hull hx, caratheodory.mem_min_card_finset_of_mem_convex_hull hx⟩ }
simp only [exists_prop, set.mem_Union]
exact ⟨caratheodory.min_card_finset_of_mem_convex_hull hx, caratheodory.min_card_finset_of_mem_convex_hull_subseteq hx, caratheodory.affine_independent_min_card_finset_of_mem_convex_hull hx, caratheodory.mem_min_card_finset_of_mem_convex_hull hx⟩
convert set.Union_subset _
iterate 3 { convert set.Union_subset _, intro }
{ iterate 3 { convert set.Union_subset _, intro }, exact convex_hull_mono ‹_› }
intro
convert set.Union_subset _
intro
convert set.Union_subset _
intro
exact convex_hull_mono ‹_›
intros
obtain i := classical.arbitrary ι
use Inter_subset_of_subset i (hAF i).1
rintro x₁ x₂ hx₁A hx₂A x hxF hx
simp_rw mem_Inter at ⊢ hxF
have h := λ i, (hAF i).2 x₁ x₂ hx₁A hx₂A x (hxF i) hx
exact ⟨λ i, (h i).1, λ i, (h i).2⟩
intros
rw convex_independent_set_iff_inter_convex_hull_subset
split
rintro hs x hxs hx
{ rintro hs x hxs hx, exact (hs _ (set.diff_subset _ _) ⟨hxs, hx⟩).2 (set.mem_singleton _) }
exact (hs _ (set.diff_subset _ _) ⟨hxs, hx⟩).2 (set.mem_singleton _)
rintro hs t ht x ⟨hxs, hxt⟩
{ rintro hs t ht x ⟨hxs, hxt⟩, by_contra h, exact hs _ hxs (convex_hull_mono (set.subset_diff_singleton ht h) hxt) }
by_contra h
exact hs _ hxs (convex_hull_mono (set.subset_diff_singleton ht h) hxt)
intros
simp only [metric.diam, convex_hull_ediam]
intros
convert inner_lt_norm_mul_iff_real; simp [hx, hy]
{ convert inner_lt_norm_mul_iff_real; simp [hx, hy] }
convert inner_lt_norm_mul_iff_real
simp [hx, hy]
simp [hx, hy]
simp [hx, hy]
intros
{ simp [sub_eq_add_neg, inner_add_right, inner_neg_right] }
simp [sub_eq_add_neg, inner_add_right, inner_neg_right]
intros
rw [←inner_conj_sym, inner_neg_left]; simp only [ring_hom.map_neg, inner_conj_sym]
rw [←inner_conj_sym, inner_neg_left]
simp only [ring_hom.map_neg, inner_conj_sym]
intros
simp only [euclidean.dist]
apply @times_cont_diff.dist ℝ
exacts [(@to_euclidean E _ _ _).times_cont_diff.comp hf, (@to_euclidean E _ _ _).times_cont_diff.comp hg, λ x, to_euclidean.injective.ne (h x)]
intros
simp [explicit_cokernel_π, explicit_cokernel_iso]
intros
{ rw ← coe_to_isometric, exact isometric.range_eq_univ _, }
rw ← coe_to_isometric
exact isometric.range_eq_univ _
intros
rw mul_comm
{rw mul_comm, convert norm_mul_le y x}
convert norm_mul_le y x
intros
rw [subsingleton.elim x 0, norm_zero]
intros
rw [← nat.cast_add, to_nat_add_to_nat_neg_eq_nat_abs, nnreal.coe_nat_abs]
intros
dunfold mk_continuous_multilinear
exact mk_continuous_norm_le _ (le_max_right _ _) _
intros
{ rw [range, add_monoid_hom.mem_range], refl }
rw [range, add_monoid_hom.mem_range]
refl
intros
apply le_cInf (image_norm_nonempty _)
rintros _ ⟨n, h, rfl⟩
apply norm_nonneg
intros
rcases normed_group.tendsto_nhds_nhds.1 (hf.tendsto 0) 1 zero_lt_one with ⟨ε, ε_pos, hε⟩
simp only [sub_zero, f.map_zero] at hε
rcases normed_field.exists_one_lt_norm 𝕜 with ⟨c, hc⟩
have : 0 < ∥c∥ / ε
from div_pos (zero_lt_one.trans hc) ε_pos
refine ⟨∥c∥ / ε, this, λ x, _⟩
by_cases hx : ∥x∥ = 0
rw [hx, mul_zero]
{ rw [hx, mul_zero], exact le_of_eq (norm_image_of_norm_zero hf hx) }
exact le_of_eq (norm_image_of_norm_zero hf hx)
refine f.bound_of_shell_semi_normed ε_pos hc (λ x hle hlt, _) hx
refine (hε _ hlt).le.trans _
rwa [← div_le_iff' this, one_div_div]
intros
by_cases hf : summable f
exact ⟨λ h, (e.has_sum.mp ((e.summable.mpr hf).has_sum_iff.mpr h)).tsum_eq, λ h, (e.has_sum.mpr (hf.has_sum_iff.mpr h)).tsum_eq⟩
{ exact ⟨λ h, (e.has_sum.mp ((e.summable.mpr hf).has_sum_iff.mpr h)).tsum_eq, λ h, (e.has_sum.mpr (hf.has_sum_iff.mpr h)).tsum_eq⟩ }
have hf' : ¬summable (λ z, e (f z)) := λ h, hf (e.summable.mp h)
{ have hf' : ¬summable (λ z, e (f z)) := λ h, hf (e.summable.mp h), rw [tsum_eq_zero_of_not_summable hf, tsum_eq_zero_of_not_summable hf'], exact ⟨by { rintro rfl, simp }, λ H, by simpa using (congr_arg (λ z, e z) H)⟩ }
rw [tsum_eq_zero_of_not_summable hf, tsum_eq_zero_of_not_summable hf']
exact ⟨by { rintro rfl, simp }, λ H, by simpa using (congr_arg (λ z, e z) H)⟩
intros
apply weak_dual.continuous_of_continuous_eval
intros z
exact (inclusion_in_double_dual 𝕜 E z).continuous
simp [log]
intros
simp only [one_div, integral_inv h]
intros
simp only [div_eq_mul_inv, ennreal.inv_pow] at *
rw [mul_assoc, mul_comm]
convert edist_le_of_edist_le_geometric_of_tendsto 2⁻¹ C hu ha n
rw [ennreal.one_sub_inv_two, ennreal.inv_inv]
intros
simp [pre]
intros
dsimp [adjointify_η]
simp
have := ε.hom.naturality (F.map (η.inv.app X))
dsimp at this
rw [this]
clear this
rw [←assoc _ _ (F.map _)]
have := ε.hom.naturality (ε.inv.app $ F.obj X)
dsimp at this
rw [this]
clear this
have := (ε.app $ F.obj X).hom_inv_id
dsimp at this
rw [this]
clear this
rw [id_comp]
have := (F.map_iso $ η.app X).hom_inv_id
dsimp at this
rw [this]
intros
ext
ext; simp
simp
intros
rw [← trans_assoc, symm_self_id, refl_trans]
intros
simp
intros
ext
{ ext, rw [assoc, lim_map_π, limit.lift_π_assoc, limit.lift_π], refl }
rw [assoc, lim_map_π, limit.lift_π_assoc, limit.lift_π]
refl
intros
simp
intros
ext j j'
simp only [discrete.nat_trans_app, limits.is_colimit.ι_map, limits.is_limit.map_π, category.assoc, ←bicone.to_cone_π_app, ←biproduct.bicone_π, ←bicone.to_cocone_ι_app, ←biproduct.bicone_ι]
simp only [biproduct.bicone_ι, biproduct.bicone_π, bicone.to_cocone_ι_app, bicone.to_cone_π_app]
rw [biproduct.ι_π_assoc, biproduct.ι_π]
split_ifs
subst h
{ subst h, rw [eq_to_hom_refl, category.id_comp], erw category.comp_id, }
rw [eq_to_hom_refl, category.id_comp]
erw category.comp_id
{ simp, }
simp
intros
{ ext, simp [← G.map_comp] }
ext
simp [← G.map_comp]
intros
rw [t.app_zero, t.app_zero]
intros
simp only [lax_monoidal_functor.right_unitality]
slice_rhs 2 3 { rw ←id_tensor_comp, simp, }
simp
intros
ext
{ ext, simp only [left_dual_iso, iso.refl_hom, left_adjoint_mate_id] }
simp only [left_dual_iso, iso.refl_hom, left_adjoint_mate_id]
intros
apply le_antisymm
refine J₁.le_close_of_is_closed (sieve.pullback_monotone _ (J₁.le_close S)) _
{ refine J₁.le_close_of_is_closed (sieve.pullback_monotone _ (J₁.le_close S)) _, apply J₁.is_closed_pullback _ _ (J₁.close_is_closed _) }
apply J₁.is_closed_pullback _ _ (J₁.close_is_closed _)
intros Z g hg
{ intros Z g hg, change _ ∈ J₁ _, rw ← sieve.pullback_comp, apply hg }
change _ ∈ J₁ _
rw ← sieve.pullback_comp
apply hg
intros
{ ext, simp, }
ext
simp
intros
erw [category.id_comp, category.comp_id]
refl
intros
split
rintro rfl
{ rintro rfl, exact λ i, eq_of_mem_repeat }
exact λ i, eq_of_mem_repeat
assume H
{ assume H, ext1, have A : c.blocks = repeat 1 c.blocks.length := eq_repeat_of_mem H, have : c.blocks.length = n, by { conv_rhs { rw [← c.blocks_sum, A] }, simp }, rw [A, this, ones_blocks] }
ext1
have A : c.blocks = repeat 1 c.blocks.length := eq_repeat_of_mem H
have : c.blocks.length = n
conv_rhs { rw [← c.blocks_sum, A] }
conv_rhs { rw [← c.blocks_sum, A] }
{ conv_rhs { rw [← c.blocks_sum, A] }, simp }
{ conv_rhs { rw [← c.blocks_sum, A] }, simp }
simp
simp
rw [A, this, ones_blocks]
intros
rw ← composition_as_set_card n
exact fintype.card_congr (composition_equiv n)
intros
rw fintype.card_eq_zero_iff at hn
exactI ⟨is_empty_elim, is_empty_elim, is_empty_elim⟩
intros
simp [degree]
intros
rcases G.exists_minimal_degree_vertex with ⟨v, hv⟩
rw hv
apply h
intros
rw ←card_neighbor_set_eq_degree
exact fintype.card_congr (coe_neighbor_set_equiv v)
intros
haveI := classical.dec s.dom; exact decidable.partrec.const' s
haveI := classical.dec s.dom
exact decidable.partrec.const' s
intros
letI := primcodable.of_equiv α e; exact encode_iff.1 (show primrec (λ a, encode (e (e.symm a))), by simp [primrec.encode])
letI := primcodable.of_equiv α e
exact encode_iff.1 (show primrec (λ a, encode (e (e.symm a))), by simp [primrec.encode])
intros
rw [← tape.right₀_nth, tape.mk'_right₀]
intros
simp [snd,bimap_bimap]
intros
induction j
cases hij
refine @le_refl _ _ _
cases hij
apply @le_refl _ _ _
apply @le_trans _ _ _ (approx f j_n) _ (j_ih ‹_›)
apply approx_mono' f
intros
simp! [equiv.traverse,id_bind,id_traverse,functor.map] with functor_norm
intros
{ cases t, apply nat.succ_pos }
cases t
apply nat.succ_pos
intros
rw [←rev_list_reverse, list.foldl_reverse, rev_list_foldr]
intros
simp [H]
introI
have : remaining buffer.nil 0 = done 0 0 := by simp [remaining_eq_done]
exact absurd (bounded.of_done this) (lt_irrefl _)
intros
simp [str_eq_char_buf, char_buf_iff, ←string.to_list_inj, buffer.ext_iff]
intros
simp [seq_right_eq, seq_eq_fail]
intros
simp [foldr_core]
intros
simp [bit1]
intros
rw ← of_real_inj; simp [cosh_add_sinh]
rw ← of_real_inj
simp [cosh_add_sinh]
intros
simp [sub_eq_add_neg, sinh_add, sinh_neg, cosh_neg]
intros
simp only [← tan_mul_cos hx, mul_pow, ← inv_one_add_tan_sq hx, div_eq_mul_inv, one_mul]
intros
rw norm_sq_eq_def
{ rw norm_sq_eq_def, refl }
refl
intros
rw [← of_real_nat_cast]
{ rw [← of_real_nat_cast], exact abs_of_nonneg (nat.cast_nonneg n) }
exact abs_of_nonneg (nat.cast_nonneg n)
intros
split
intro h
{ intro h, by_cases hij : i = j, { subst hij, exact or.inl ⟨rfl, heq_of_eq (dfinsupp.single_injective h)⟩, }, { have h_coe : ⇑(dfinsupp.single i xi) = dfinsupp.single j xj := congr_arg coe_fn h, have hci := congr_fun h_coe i, have hcj := congr_fun h_coe j, rw dfinsupp.single_eq_same at hci hcj, rw dfinsupp.single_eq_of_ne (ne.symm hij) at hci, rw dfinsupp.single_eq_of_ne (hij) at hcj, exact or.inr ⟨hci, hcj.symm⟩, }, }
by_cases hij : i = j
subst hij
{ subst hij, exact or.inl ⟨rfl, heq_of_eq (dfinsupp.single_injective h)⟩, }
exact or.inl ⟨rfl, heq_of_eq (dfinsupp.single_injective h)⟩
have h_coe : ⇑(dfinsupp.single i xi) = dfinsupp.single j xj := congr_arg coe_fn h
{ have h_coe : ⇑(dfinsupp.single i xi) = dfinsupp.single j xj := congr_arg coe_fn h, have hci := congr_fun h_coe i, have hcj := congr_fun h_coe j, rw dfinsupp.single_eq_same at hci hcj, rw dfinsupp.single_eq_of_ne (ne.symm hij) at hci, rw dfinsupp.single_eq_of_ne (hij) at hcj, exact or.inr ⟨hci, hcj.symm⟩, }
have hci := congr_fun h_coe i
have hcj := congr_fun h_coe j
rw dfinsupp.single_eq_same at hci hcj
rw dfinsupp.single_eq_of_ne (ne.symm hij) at hci
rw dfinsupp.single_eq_of_ne (hij) at hcj
exact or.inr ⟨hci, hcj.symm⟩
rintros (⟨hi, hxi⟩ | ⟨hi, hj⟩)
{ rintros (⟨hi, hxi⟩ | ⟨hi, hj⟩), { subst hi, rw eq_of_heq hxi, }, { rw [hi, hj, dfinsupp.single_zero, dfinsupp.single_zero], }, }
subst hi
{ subst hi, rw eq_of_heq hxi, }
rw eq_of_heq hxi
{ rw [hi, hj, dfinsupp.single_zero, dfinsupp.single_zero], }
rw [hi, hj, dfinsupp.single_zero, dfinsupp.single_zero]
intros
apply equiv.forall_congr
intros
apply equiv.forall_congr
intros
apply h
intros
simp
simp; refl
intros
{ ext, simp }
ext
simp
intros
have h₁ : f.to_equiv = g.to_equiv := equiv.ext h
cases f
cases g
congr
{ exact (funext h) }
exact (funext h)
{ exact congr_arg equiv.inv_fun h₁ }
exact congr_arg equiv.inv_fun h₁
intros
refl
intros
ext j
by_cases h : j.val < n
have : j ≠ last n := ne_of_lt h
{ have : j ≠ last n := ne_of_lt h, simp [h, this, snoc, cast_succ_cast_lt] }
simp [h, this, snoc, cast_succ_cast_lt]
rw eq_last_of_not_lt h
{ rw eq_last_of_not_lt h, simp }
simp
intros
simp [fin.ext_iff]
intros
simp [pi.enum]; refine ⟨λ a h, f a, mem_pi _ _, rfl⟩
simp [pi.enum]
refine ⟨λ a h, f a, mem_pi _ _, rfl⟩
intros
{ ext x, simp [and_assoc] }
ext x
simp [and_assoc]
intros
cases s; simp only [multiset.card_eq_one, finset.card, ← val_inj, singleton_val]
cases s
simp only [multiset.card_eq_one, finset.card, ← val_inj, singleton_val]
intros
{ classical, ext, simp }
classical
ext
simp
intros
refine le_antisymm (max'_le _ _ _ (λ y hy, _)) (le_max' _ _ (mem_image.mpr ⟨_, max'_mem _ _, rfl⟩))
obtain ⟨x, hx, rfl⟩ := mem_image.mp hy
exact hf (le_max' _ _ hx)
intros
simp [noncomm_prod, insert_val_of_not_mem ha, multiset.noncomm_prod_cons']
intros
exact_mod_cast @function.support_eq_empty_iff _ _ _ f
intros
rw [unique_ext_iff, unique.eq_default a, unique.eq_default a', single_eq_same, single_eq_same]
intros
rw [←e.equiv_of_fintype_self_embedding_to_embedding, univ_map_equiv_to_embedding]
intros
rw [finset.card_univ, fintype.card_fin]
intros
haveI : nontrivial α := one_lt_card_iff_nontrivial.1 h
{ haveI : nontrivial α := one_lt_card_iff_nontrivial.1 h, exact exists_ne a }
exact exists_ne a
intros
simp [nat_abs_eq_iff, is_unit_iff]
intros
apply int.mod_eq_mod_iff_mod_sub_eq_zero.mpr
convert int.mul_mod_right 2 (-i)
simp only [two_mul, sub_eq_add_neg]
intros
simp [bit1] with parity_simps
intros
cases l; refl
cases l
refl
refl
intros
refine ⟨λ h, _, drop_eq_nil_of_le⟩
induction k with k hk generalizing l
simp only [drop] at h
{ simp only [drop] at h, simp [h] }
simp [h]
cases l
{ cases l, { simp }, { simp only [drop] at h, simpa [nat.succ_le_succ_iff] using hk h } }
{ simp }
simp
simp only [drop] at h
{ simp only [drop] at h, simpa [nat.succ_le_succ_iff] using hk h }
simpa [nat.succ_le_succ_iff] using hk h
intros
revert a; induction l; intros; [refl, simp only [*, map, foldr]]
revert a; induction l; intros
revert a; induction l
revert a
induction l
intros
refl
intros
simp only [*, map, foldr]
intros
induction L with a L ihL
{ exact absurd h (not_mem_nil _) }
exact absurd h (not_mem_nil _)
rw prod_cons
{ rw prod_cons, cases (mem_cons_iff _ _ _).1 h with ha hL, exacts [mul_eq_zero_of_left ha.symm _, mul_eq_zero_of_right _ (ihL hL)] }
cases (mem_cons_iff _ _ _).1 h with ha hL
exacts [mul_eq_zero_of_left ha.symm _, mul_eq_zero_of_right _ (ihL hL)]
intros
cases l with x l
{ contradiction }
contradiction
by_cases h' : f x ≤ g x
{ by_cases h' : f x ≤ g x, exact ⟨x, mem_cons_self _ _, h'⟩, rcases exists_lt_of_sum_lt f g _ with ⟨y, h1y, h2y⟩, exact ⟨y, mem_cons_of_mem x h1y, le_of_lt h2y⟩, simp at h, exact lt_of_add_lt_add_left (lt_of_le_of_lt h $ add_lt_add_right (lt_of_not_ge h') _) }
exact ⟨x, mem_cons_self _ _, h'⟩
rcases exists_lt_of_sum_lt f g _ with ⟨y, h1y, h2y⟩
exact ⟨y, mem_cons_of_mem x h1y, le_of_lt h2y⟩
simp at h
exact lt_of_add_lt_add_left (lt_of_le_of_lt h $ add_lt_add_right (lt_of_not_ge h') _)
intros
rw [attach, map_pmap]; exact pmap_congr l (λ a h₁ h₂, rfl)
rw [attach, map_pmap]
exact pmap_congr l (λ a h₁ h₂, rfl)
intros
induction l with hd tl hl
{ simp only [reduce_option_nil, map_nil] }
simp only [reduce_option_nil, map_nil]
cases hd; simpa only [true_and, option.map_some', map, eq_self_iff_true, reduce_option_cons_of_some] using hl
cases hd
{ cases hd; simpa only [true_and, option.map_some', map, eq_self_iff_true, reduce_option_cons_of_some] using hl }
simpa only [true_and, option.map_some', map, eq_self_iff_true, reduce_option_cons_of_some] using hl
simpa only [true_and, option.map_some', map, eq_self_iff_true, reduce_option_cons_of_some] using hl
intros
simp only [count, countp_pos, exists_prop, exists_eq_right']
intros
obtain ⟨xs, rfl⟩ := h
rw filter_append
exact prefix_append _ _
intros
rw [permutations_aux, permutations_aux.rec]; refl
rw [permutations_aux, permutations_aux.rec]
refl
intros
rw erase_eq_erasep; apply erasep_sublist
rw erase_eq_erasep
apply erasep_sublist
intros
rwa [← succ_singleton, append_consecutive]; exact nat.le_succ _
rwa [← succ_singleton, append_consecutive]
exact nat.le_succ _
intros
rw [sublists'_eq_sublists, nodup_map_iff reverse_injective, nodup_sublists, nodup_reverse]
intros
induction L with l L IH
simp only [join, pairwise.nil, forall_prop_of_false (not_mem_nil _), forall_const, and_self]
{simp only [join, pairwise.nil, forall_prop_of_false (not_mem_nil _), forall_const, and_self]}
have : (∀ (x : α), x ∈ l → ∀ (y : α) (x_1 : list α), x_1 ∈ L → y ∈ x_1 → R x y) ↔ ∀ (a' : list α), a' ∈ L → ∀ (x : α), x ∈ l → ∀ (y : α), y ∈ a' → R x y := ⟨λ h a b c d e, h c d e a b, λ h c d e a b, h a b c d e⟩
simp only [join, pairwise_append, IH, mem_join, exists_imp_distrib, and_imp, this, forall_mem_cons, pairwise_cons]
simp only [and_assoc, and_comm, and.left_comm]
intros
induction s with y s IH
{ simp }
simp
{ simpa using IH }
simpa using IH
intros
by_cases h : a ∈ l
{ exact (perm_cons_erase h).subperm }
exact (perm_cons_erase h).subperm
rw [erase_of_not_mem h]
{ rw [erase_of_not_mem h], exact (sublist_cons _ _).subperm }
exact (sublist_cons _ _).subperm
intros
rw [range_eq_range', range_eq_range', range', add_comm, ← map_add_range']
rw [range_eq_range', range_eq_range', range', add_comm, ← map_add_range']; congr; exact funext one_add
rw [range_eq_range', range_eq_range', range', add_comm, ← map_add_range']; congr
congr
exact funext one_add
intros
cases n
cases n; refl
refl
refl
intros
simp [revzip]
intros
{ ext, apply dot_product_neg }
ext
apply dot_product_neg
intros
ext
{ ext, refl }
refl
intros
simp [bit1_apply]
intros
{ ext, apply neg_dot_product }
ext
apply neg_dot_product
intros
rw vec_alt1_append
intros
rw [← matrix.mul_assoc, single_mul_single]
intros
rw [list.bind, ← coe_join, list.map_map]; refl
rw [list.bind, ← coe_join, list.map_map]
refl
intros
simp [countp_eq_card_filter]
intros
rw [fold_eq_foldl, foldl_cons, ← fold_eq_foldl]
intros
rw [bind₁, map_aeval, algebra_map_eq]
intros
simp [nat.find_greatest, h]
intros
simp only [add_comm, lt_succ_iff]
intros
induction hnm with m hnm ih
intros x y H
{ intros x y H, rwa [le_rec_on_self, le_rec_on_self] at H }
rwa [le_rec_on_self, le_rec_on_self] at H
intros x y H
rw [le_rec_on_succ hnm, le_rec_on_succ hnm] at H
exact ih (Hnext _ H)
intros
{ rw mul_comm, exact div_add_mod _ _ }
rw mul_comm
exact div_add_mod _ _
intros
convert nat.choose_symm (nat.le_add_left _ _)
{ convert nat.choose_symm (nat.le_add_left _ _), rw nat.add_sub_cancel}
rw nat.add_sub_cancel
intros
induction L with d L ih
{ refl, }
refl
dsimp [of_digits]
{ dsimp [of_digits], dsimp [int.modeq] at *, conv_lhs { rw [int.add_mod, int.mul_mod, h, ih], }, conv_rhs { rw [int.add_mod, int.mul_mod], }, }
dsimp [int.modeq] at *
conv_lhs { rw [int.add_mod, int.mul_mod, h, ih], }
conv_rhs { rw [int.add_mod, int.mul_mod], }
intros
rw [lt_iff_le_not_le, le_def, le_def, not_exists]
split
rintro ⟨⟨hyx, H⟩, h⟩
{ rintro ⟨⟨hyx, H⟩, h⟩, by_cases hx : x.dom, { use hx, intro hy, specialize H hy, specialize h (λ _, hy), rw not_forall at h, cases h with hx' h, rw not_le at h, exact h }, { specialize h (λ hx', (hx hx').elim), rw not_forall at h, cases h with hx' h, exact (hx hx').elim } }
by_cases hx : x.dom
use hx
{ use hx, intro hy, specialize H hy, specialize h (λ _, hy), rw not_forall at h, cases h with hx' h, rw not_le at h, exact h }
intro hy
specialize H hy
specialize h (λ _, hy)
rw not_forall at h
cases h with hx' h
rw not_le at h
exact h
specialize h (λ hx', (hx hx').elim)
{ specialize h (λ hx', (hx hx').elim), rw not_forall at h, cases h with hx' h, exact (hx hx').elim }
rw not_forall at h
cases h with hx' h
exact (hx hx').elim
rintro ⟨hx, H⟩
{ rintro ⟨hx, H⟩, exact ⟨⟨λ _, hx, λ hy, (H hy).le⟩, λ hxy h, not_lt_of_le (h _) (H _)⟩ }
exact ⟨⟨λ _, hx, λ hy, (H hy).le⟩, λ hxy h, not_lt_of_le (h _) (H _)⟩
simpa only [nat.cast_zero] using with_top_equiv_coe 0
intros
rw [gcd_comm m n, gcd_gcd_self_left_right]
intros
rw [log, if_neg (λ h : b ≤ n ∧ 1 < b, h.2.not_le hb)]
intros
simpa using right_le_mkpair n.unpair.1 n.unpair.2
intros
{ obtain ⟨k, rfl⟩ := h, exact succ_pos' }
obtain ⟨k, rfl⟩ := h
exact succ_pos'
intros
obtain ⟨a, rfl⟩ := h
exact factors_subset_right (right_ne_zero_of_mul h')
intros
rw ← not_lt; exact not_congr cast_lt
rw ← not_lt
exact not_congr cast_lt
intros
cases x
{ simp }
simp
simp only [pbind, iff_false]
{ simp only [pbind, iff_false], intro h, cases h' x rfl h }
intro h
cases h' x rfl h
intros
rw hl.2.1 at e
rw [hl.2.1, hr.2.1, delta] at h
rcases hr.3.1 with H|⟨hr₁, hr₂⟩
linarith
{linarith}
suffices H₂
suffices H₁
refine ⟨valid'.balance_l_aux v hr.right H₁ H₂ _, _⟩
{ rw e, exact or.inl (valid'.merge_lemma h hr₁) }
rw e
exact or.inl (valid'.merge_lemma h hr₁)
rw [balance_l_eq_balance v.2 hr.2.2.2 H₁ H₂, balance_eq_balance' v.3 hr.3.2.2 v.2 hr.2.2.2, size_balance' v.2 hr.2.2.2, e, hl.2.1, hr.2.1]
{ rw [balance_l_eq_balance v.2 hr.2.2.2 H₁ H₂, balance_eq_balance' v.3 hr.3.2.2 v.2 hr.2.2.2, size_balance' v.2 hr.2.2.2, e, hl.2.1, hr.2.1], simp [add_comm, add_left_comm] }
simp [add_comm, add_left_comm]
{ rw [e, add_right_comm], rintro ⟨⟩ }
rw [e, add_right_comm]
rintro ⟨⟩
{ intros _ h₁, rw e, unfold delta at hr₂ ⊢, linarith }
intros _ h₁
rw e
unfold delta at hr₂ ⊢
linarith
intros
rcases H with rfl | rfl
{ exact or.inl rfl }
exact or.inl rfl
{ exact or.inr rfl }
exact or.inr rfl
intros
dsimp [single]; split_ifs; simp [*, eq_comm]
dsimp [single]; split_ifs
dsimp [single]
split_ifs
simp [*, eq_comm]
simp [*, eq_comm]
intros
ext i x; cases x; reflexivity
ext i x; cases x
ext i x
cases x
reflexivity
reflexivity
intros
{ dsimp [is_reduced], refl }
dsimp [is_reduced]
refl
intros
induction n with n ih
{ simp, }
simp
conv_lhs { rw pow_succ', }
{ conv_lhs { rw pow_succ', }, rw [mul_assoc, X_mul, ←mul_assoc, ih, mul_assoc, ←pow_succ'], }
rw [mul_assoc, X_mul, ←mul_assoc, ih, mul_assoc, ←pow_succ']
intros
split_ifs
{ refl }
refl
exact (coeff_eq_zero_of_nat_degree_lt (not_le.1 (λ w, h (nat.lt_one_add_iff.2 w)))).symm
{ exact (coeff_eq_zero_of_nat_degree_lt (not_le.1 (λ w, h (nat.lt_one_add_iff.2 w)))).symm, }
intros
rw [subsingleton.elim p 0, nat_degree_zero]
intros
simp only [derivative_apply, eval_sum, eval_pow, eval_C, eval_X, eval_nat_cast, eval_mul]
intros
simp only [erase_lead, erase_zero]
intros
rwa coeff_zero_eq_eval_zero at hp
intros
simp [eval₂_eq_sum]
intros
simp [norm_unit]
intros
by_cases h : q = 0
{ simp [h] }
simp [h]
rw [degree_mul', hp.degree_mul]
{ exact add_comm _ _ }
exact add_comm _ _
rwa [hp.leading_coeff, one_mul, leading_coeff_ne_zero]
{ rwa [hp.leading_coeff, one_mul, leading_coeff_ne_zero] }
intros
rw [monic, leading_coeff_mul' _]; simp [leading_coeff_C b, hp]
rw [monic, leading_coeff_mul' _]
simp [leading_coeff_C b, hp]
simp [leading_coeff_C b, hp]
intros
unfold rev_at_fun
split_ifs with h j
{ exact nat.sub_sub_self h, }
exact nat.sub_sub_self h
exfalso
{ exfalso, apply j, exact nat.sub_le N i, }
apply j
exact nat.sub_le N i
{ refl, }
refl
intros
simp only [taylor_apply, eval_comp, eval_C, eval_X, eval_add]
intros
rw [← supp_preservation_iff_liftp_preservation, supp_preservation_iff_uniform]
intros
conv_lhs { rw [←(@num_denom p), ←(@num_denom q)] }
apply rat.mk_eq
{ exact_mod_cast p.denom_ne_zero }
exact_mod_cast p.denom_ne_zero
{ exact_mod_cast q.denom_ne_zero }
exact_mod_cast q.denom_ne_zero
intros
lift b to ℕ using le_of_lt hb0
norm_cast at hb0 h
rw [← rat.mk_eq_div, ← rat.mk_pnat_eq a b hb0, rat.mk_pnat_denom, pnat.mk_coe, h.gcd_eq_one, nat.div_one]
intros
rw [coe_int_eq_of_int, cast_of_int]
apply le_antisymm
rw real.equiv_Cauchy.cardinal_eq
{ rw real.equiv_Cauchy.cardinal_eq, apply mk_quotient_le.trans, apply (mk_subtype_le _).trans_eq, rw [← power_def, mk_nat, mk_rat, omega_power_omega] }
apply mk_quotient_le.trans
apply (mk_subtype_le _).trans_eq
rw [← power_def, mk_nat, mk_rat, omega_power_omega]
convert mk_le_of_injective (cantor_function_injective _ _)
{ convert mk_le_of_injective (cantor_function_injective _ _), rw [←power_def, mk_bool, mk_nat, two_power_omega], exact 1 / 3, norm_num, norm_num }
rw [←power_def, mk_bool, mk_nat, two_power_omega]
exact 1 / 3
norm_num
norm_num
intros
have : mk f = 0 ↔ lim_zero (f - 0) := quotient.eq
have : mk f = 0 ↔ lim_zero (f - 0) := quotient.eq; rwa sub_zero at this
rwa sub_zero at this
intros
simp [ennreal.to_real, hx_top]
intros
change x + (-0) = x
{ change x + (-0) = x, simp }
simp
intros
unfold st
split_ifs
exact is_st_unique (classical.some_spec h) (is_st_Sup (not_infinite_of_exists_st h))
{ exact is_st_unique (classical.some_spec h) (is_st_Sup (not_infinite_of_exists_st h)) }
cases not_imp_comm.mp exists_st_of_not_infinite h with H H
{ cases not_imp_comm.mp exists_st_of_not_infinite h with H H, { rw (set.ext (λ i, ⟨λ hi, set.mem_univ i, λ hi, H i⟩) : {y : ℝ | (y : ℝ*) < x} = set.univ), exact real.Sup_univ.symm }, { rw (set.ext (λ i, ⟨λ hi, false.elim (not_lt_of_lt (H i) hi), λ hi, false.elim (set.not_mem_empty i hi)⟩) : {y : ℝ | (y : ℝ*) < x} = ∅), exact real.Sup_empty.symm } }
rw (set.ext (λ i, ⟨λ hi, set.mem_univ i, λ hi, H i⟩) : {y : ℝ | (y : ℝ*) < x} = set.univ)
{ rw (set.ext (λ i, ⟨λ hi, set.mem_univ i, λ hi, H i⟩) : {y : ℝ | (y : ℝ*) < x} = set.univ), exact real.Sup_univ.symm }
exact real.Sup_univ.symm
rw (set.ext (λ i, ⟨λ hi, false.elim (not_lt_of_lt (H i) hi), λ hi, false.elim (set.not_mem_empty i hi)⟩) : {y : ℝ | (y : ℝ*) < x} = ∅)
{ rw (set.ext (λ i, ⟨λ hi, false.elim (not_lt_of_lt (H i) hi), λ hi, false.elim (set.not_mem_empty i hi)⟩) : {y : ℝ | (y : ℝ*) < x} = ∅), exact real.Sup_empty.symm }
exact real.Sup_empty.symm
intros
simp only [div_eq_inv_mul, mul_finset_sup]
simpa using half_lt_self zero_ne_one.symm
intros
rw [sign, if_pos hr, if_neg hr.not_lt]
intros
rw [mul_comm, sqrt_mul hy, mul_comm]
intros
induction n
induction n; simp [*, drop]
simp [*, drop]
simp [*, drop]
intros
simp only [productive_iff]; exact forall_congr (λ n, terminates_congr $ nth_congr h _)
simp only [productive_iff]
exact forall_congr (λ n, terminates_congr $ nth_congr h _)
intros
simp [set.ite]
intros
ext
{ ext, split, rintro ⟨x, h1, h2⟩, exact ⟨⟨x, h1⟩, h2⟩, rintro ⟨⟨x, h1⟩, h2⟩, exact ⟨x, h1, h2⟩ }
split
rintro ⟨x, h1, h2⟩
exact ⟨⟨x, h1⟩, h2⟩
rintro ⟨⟨x, h1⟩, h2⟩
exact ⟨x, h1, h2⟩
intros
{ ext ⟨x, y⟩, simp }
ext ⟨x, y⟩
simp
intros
rintro _ ⟨a, b, ⟨h1a, h2a⟩, hb, rfl⟩
{ rintro _ ⟨a, b, ⟨h1a, h2a⟩, hb, rfl⟩, split; exact ⟨_, _, ‹_›, ‹_›, rfl⟩ }
split
split; exact ⟨_, _, ‹_›, ‹_›, rfl⟩
exact ⟨_, _, ‹_›, ‹_›, rfl⟩
exact ⟨_, _, ‹_›, ‹_›, rfl⟩
intros
rw [diff_eq, inter_comm]
intros
haveI := classical.prop_decidable; exact calc fintype.card (f '' s) = (s.to_finset.image f).card : fintype.card_of_finset' _ (by simp) ... = s.to_finset.card : finset.card_image_of_inj_on (λ x hx y hy hxy, H x (mem_to_finset.1 hx) y (mem_to_finset.1 hy) hxy) ... = fintype.card s : (fintype.card_of_finset' _ (λ a, mem_to_finset)).symm
haveI := classical.prop_decidable
exact calc fintype.card (f '' s) = (s.to_finset.image f).card : fintype.card_of_finset' _ (by simp) ... = s.to_finset.card : finset.card_image_of_inj_on (λ x hx y hy hxy, H x (mem_to_finset.1 hx) y (mem_to_finset.1 hy) hxy) ... = fintype.card s : (fintype.card_of_finset' _ (λ a, mem_to_finset)).symm
intros
simp only [card_subtype_compl, h]
intros
simp only [eq_on, ← forall_and_distrib]
refine forall_congr (λ a, _)
by_cases a ∈ s
by_cases a ∈ s; simp *
simp *
simp *
intros
simp
intros
refine ⟨λ h, _, λ h, Ioi_subset_Ioi h⟩
by_contradiction ba
exact lt_irrefl _ (h (not_le.mp ba))
intros
simp
intros
simp [← Ici_inter_Iic, h]
intros
cases le_total x y; simp only [interval_of_le, interval_of_ge, *]; apply hs.out; assumption
cases le_total x y; simp only [interval_of_le, interval_of_ge, *]; apply hs.out
cases le_total x y; simp only [interval_of_le, interval_of_ge, *]
cases le_total x y
simp only [interval_of_le, interval_of_ge, *]
apply hs.out
assumption
assumption
simp only [interval_of_le, interval_of_ge, *]
apply hs.out
assumption
assumption
intros
simp [sub_eq_add_neg]
intros
simpa using bUnion_range
intros
rw [disjoint.comm, disjoint_left]
intros
rw [inter_comm, ← bInter_inter hs]
simp [inter_comm]
intros
cases x; refl
cases x
refl
intros
simp [val, int.nat_abs_mul]
intros
conv {to_rhs, rw ← nat.mod_add_div a n}; simp
conv {to_rhs, rw ← nat.mod_add_div a n}
simp
intros
casesI n
{ exfalso, exact nat.not_lt_zero 0 (fact.out _) }
exfalso
exact nat.not_lt_zero 0 (fact.out _)
{ exact fintype.card_fin (n+1) }
exact fintype.card_fin (n+1)
intros
have : ∀ s ∈ countable_basis α, ∀ᵐ x ∂μ, x ∈ s → ∃ᶠ n in at_top, (f^[n] x) ∈ s
from λ s hs, h.ae_mem_imp_frequently_image_mem (is_open_of_mem_countable_basis hs).measurable_set
refine ((ae_ball_iff $ countable_countable_basis α).2 this).mono (λ x hx s hs, _)
rcases (is_basis_countable_basis α).mem_nhds_iff.1 hs with ⟨o, hoS, hxo, hos⟩
exact (hx o hoS hxo).mono (λ n hn, hos hn)
intros
cases p.eq_zero_or_pos with hp hp
rw [hp, coe_expand, pow_zero, mul_zero, ← C_1, eval₂_hom, nat_degree_C]
{ rw [hp, coe_expand, pow_zero, mul_zero, ← C_1, eval₂_hom, nat_degree_C] }
by_cases hf : f = 0
{ rw [hf, alg_hom.map_zero, nat_degree_zero, zero_mul] }
rw [hf, alg_hom.map_zero, nat_degree_zero, zero_mul]
have hf1 : expand R p f ≠ 0 := mt (expand_eq_zero hp).1 hf
rw [← with_bot.coe_eq_coe, ← degree_eq_nat_degree hf1]
refine le_antisymm ((degree_le_iff_coeff_zero _ _).2 $ λ n hn, _) _
rw coeff_expand hp
{ rw coeff_expand hp, split_ifs with hpn, { rw coeff_eq_zero_of_nat_degree_lt, contrapose! hn, rw [with_bot.coe_le_coe, ← nat.div_mul_cancel hpn], exact nat.mul_le_mul_right p hn }, { refl } }
split_ifs with hpn
rw coeff_eq_zero_of_nat_degree_lt
{ rw coeff_eq_zero_of_nat_degree_lt, contrapose! hn, rw [with_bot.coe_le_coe, ← nat.div_mul_cancel hpn], exact nat.mul_le_mul_right p hn }
contrapose! hn
rw [with_bot.coe_le_coe, ← nat.div_mul_cancel hpn]
exact nat.mul_le_mul_right p hn
{ refl }
refl
refine le_degree_of_ne_zero _
{ refine le_degree_of_ne_zero _, rw [coeff_expand_mul hp, ← leading_coeff], exact mt leading_coeff_eq_zero.1 hf }
rw [coeff_expand_mul hp, ← leading_coeff]
exact mt leading_coeff_eq_zero.1 hf
intros
rw [separable_def, derivative_C, is_coprime_zero_right, is_unit_C]
intros
refine is_glb.of_image (λ s t, show (s : set K) ≤ t ↔ s ≤ t, from set_like.coe_subset_coe) _
convert is_glb_binfi
exact coe_Inf _
intros
unfold angle
rw [inner_zero_right, zero_div, real.arccos_zero]
intros
rw [dist_eq_norm_vsub V, dist_eq_norm_vsub V, dist_eq_norm_vsub V, ← vsub_sub_vsub_cancel_right]
exact norm_sub_eq_abs_sub_norm_iff_angle_eq_zero ((λ he, hp1p2 (vsub_eq_zero_iff_eq.1 he))) (λ he, hp3p2 (vsub_eq_zero_iff_eq.1 he))
intros
have hr : ∃ r, ∀ i, dist ((s.face h).points i) s.circumcenter = r
use s.circumradius
{ use s.circumradius, simp [face_points] }
simp [face_points]
exact orthogonal_projection_eq_circumcenter_of_exists_dist_eq _ hr
intros
rw [altitude_def, direction_inf_of_mem (self_mem_mk' (s.points i) _) (mem_affine_span ℝ (set.mem_range_self _)), direction_mk', direction_affine_span, direction_affine_span]
intros
have h₁ : 0 ≤ ∥w∥ ^ 2 + 4 := by nlinarith
suffices : ∥(4:ℝ) • w + (∥w∥ ^ 2 - 4) • v∥ = ∥w∥ ^ 2 + 4
have h₂ : ∥w∥ ^ 2 + 4 ≠ 0 := by nlinarith
{ have h₂ : ∥w∥ ^ 2 + 4 ≠ 0 := by nlinarith, simp only [mem_sphere_zero_iff_norm, norm_smul, real.norm_eq_abs, abs_inv, this, abs_of_nonneg h₁, stereo_inv_fun_aux_apply], field_simp }
simp only [mem_sphere_zero_iff_norm, norm_smul, real.norm_eq_abs, abs_inv, this, abs_of_nonneg h₁, stereo_inv_fun_aux_apply]
field_simp
suffices : ∥(4:ℝ) • w + (∥w∥ ^ 2 - 4) • v∥ ^ 2 = (∥w∥ ^ 2 + 4) ^ 2
have h₃ : 0 ≤ ∥stereo_inv_fun_aux v w∥ := norm_nonneg _
{ have h₃ : 0 ≤ ∥stereo_inv_fun_aux v w∥ := norm_nonneg _, simpa [h₁, h₃, -one_pow] using this }
simpa [h₁, h₃, -one_pow] using this
simp [norm_add_sq_real, norm_smul, inner_smul_left, inner_smul_right, inner_left_of_mem_orthogonal_singleton _ hw, mul_pow, real.norm_eq_abs, hv]
ring
intros
rw mdifferentiable.mfderiv_within (mdifferentiable_at_id I) hxs
exact mfderiv_id I
intros
apply has_mfderiv_within_at.mfderiv_within _ hxs
exact h.has_mfderiv_at.has_mfderiv_within_at
intros
simp only [mdifferentiable_within_at] with mfld_simps
exact ⟨λH, H.2, λH, ⟨H.continuous_within_at, H⟩⟩
intros
{ rw ext_chart_at_source, exact (chart_at H x).open_source }
rw ext_chart_at_source
exact (chart_at H x).open_source
intros
rw times_cont_mdiff_within_at_iff'' at *
exact ⟨hf.1.prod hg.1, hf.2.prod hg.2⟩
intros
apply bot_unique
rw [← (mdifferentiable_chart I (f.c (f.ind x hx))).ker_mfderiv_eq_bot (f.mem_chart_at_ind_source x hx), ← comp_embedding_pi_tangent_mfderiv]
exact linear_map.ker_le_ker_comp _ _
intros
rw set.ext_iff
simp_rw [mem_left_coset_iff, set_like.mem_coe]
split
intro h
{ intro h, apply (h y).mpr, rw mul_left_inv, exact s.one_mem }
apply (h y).mpr
rw mul_left_inv
exact s.one_mem
intros h z
{ intros h z, rw ←mul_inv_cancel_right x⁻¹ y, rw mul_assoc, exact s.mul_mem_cancel_left h }
rw ←mul_inv_cancel_right x⁻¹ y
rw mul_assoc
exact s.mul_mem_cancel_left h
intros
rw general_commutator_le
intros p hp q hq
exact mul_mem H₂ (h.conj_mem q hq p) (inv_mem H₂ hq)
intros
ext
ext; refl
refl
intros
by_cases h0 : order_of x = 0
rw [h0, coprime_zero_right] at h
{ rw [h0, coprime_zero_right] at h, exact ⟨1, by rw [h, pow_one, pow_one]⟩ }
exact ⟨1, by rw [h, pow_one, pow_one]⟩
by_cases h1 : order_of x = 1
exact ⟨0, by rw [order_of_eq_one_iff.mp h1, one_pow, one_pow]⟩
{ exact ⟨0, by rw [order_of_eq_one_iff.mp h1, one_pow, one_pow]⟩ }
obtain ⟨m, hm⟩ := exists_mul_mod_eq_one_of_coprime h (one_lt_iff_ne_zero_and_ne_one.mpr ⟨h0, h1⟩)
exact ⟨m, by rw [←pow_mul, pow_eq_mod_order_of, hm, pow_one]⟩
intros
rw ←length_attach at hn
rw ←nodup_attach at hl
rw cycle_type_eq [l.attach.form_perm]
simp only [map, function.comp_app]
{ simp only [map, function.comp_app], rw [support_form_perm_of_nodup _ hl, card_to_finset, erase_dup_eq_self.mpr hl], { simpa }, { intros x h, simpa [h, nat.succ_le_succ_iff] using hn } }
rw [support_form_perm_of_nodup _ hl, card_to_finset, erase_dup_eq_self.mpr hl]
{ simpa }
simpa
intros x h
{ intros x h, simpa [h, nat.succ_le_succ_iff] using hn }
simpa [h, nat.succ_le_succ_iff] using hn
{ simp }
simp
{ simpa using is_cycle_form_perm hl hn }
simpa using is_cycle_form_perm hl hn
{ simp }
simp
intros
rw [←sum_cycle_type, h.cycle_type, multiset.sum_singleton]
intros
suffices : f = g → (g.is_cycle ↔ f.is_cycle)
{ simpa [cycle_factors_finset_eq_finset, eq_comm] }
simpa [cycle_factors_finset_eq_finset, eq_comm]
rintro rfl
exact iff.rfl
intros
intros x hx
have hx' : x ∈ {x | (zip_with swap l l').prod x ≠ x} := by simpa using hx
simpa using zip_with_swap_prod_support' _ _ hx'
intros
simp
intros
rw [mem_support, mem_support, ne.def, ne.def, not_iff_not, apply_eq_iff_eq]
intros
rw [mem_alternating_group, bit1, sign_fin_rotate, pow_bit0', int.units_mul_self, one_pow]
intros
split
split; { rintros ⟨x, x_in, hx⟩, exact ⟨x⁻¹, inv_mem K x_in, by simp [hx]⟩ }
{ rintros ⟨x, x_in, hx⟩, exact ⟨x⁻¹, inv_mem K x_in, by simp [hx]⟩ }
rintros ⟨x, x_in, hx⟩
{ rintros ⟨x, x_in, hx⟩, exact ⟨x⁻¹, inv_mem K x_in, by simp [hx]⟩ }
exact ⟨x⁻¹, inv_mem K x_in, by simp [hx]⟩
intros
rw ← set_like.coe_set_eq
simp [set.image_inter hf]
intros
split
intros h x x_in
{ intros h x x_in, rwa [h, mem_bot] at x_in }
rwa [h, mem_bot] at x_in
intros h
{ intros h, ext x, rw mem_bot, exact ⟨h x, by { rintros rfl, exact S.one_mem }⟩ }
ext x
rw mem_bot
exact ⟨h x, by { rintros rfl, exact S.one_mem }⟩
intros
convert ext_of_direction_eq _ ⟨p, mem_affine_span k (set.mem_union_left _ (set.mem_singleton _)), mem_top k V p⟩
rw [direction_affine_span, direction_top, vector_span_eq_span_vsub_set_right k ((set.mem_union_left _ (set.mem_singleton _)) : p ∈ _), eq_top_iff, ←h]
apply submodule.span_mono
rintros v ⟨v', rfl⟩
use (v' : V) +ᵥ p
simp
intros
cases hn with p hp
rw lt_iff_le_and_exists at h
rcases h with ⟨hle, p2, hp2, hp2s1⟩
rw set_like.lt_iff_le_and_exists
use [direction_le hle, p2 -ᵥ p, vsub_mem_direction hp2 (hle hp)]
intro hm
rw vsub_right_mem_direction_iff_mem hp p2 at hm
exact hp2s1 hm
intros
simp [h]
intros
rcases set.eq_empty_or_nonempty s with rfl | ⟨⟨p₁, hp₁⟩⟩
{ simp [collinear_empty] }
simp [collinear_empty]
rw collinear_iff_of_mem k hp₁
{ rw collinear_iff_of_mem k hp₁, split, { exact λ h, ⟨p₁, h⟩ }, { rintros ⟨p, v, hv⟩, use v, intros p₂ hp₂, rcases hv p₂ hp₂ with ⟨r, rfl⟩, rcases hv p₁ hp₁ with ⟨r₁, rfl⟩, use r - r₁, simp [vadd_vadd, ←add_smul] } }
split
{ exact λ h, ⟨p₁, h⟩ }
exact λ h, ⟨p₁, h⟩
rintros ⟨p, v, hv⟩
{ rintros ⟨p, v, hv⟩, use v, intros p₂ hp₂, rcases hv p₂ hp₂ with ⟨r, rfl⟩, rcases hv p₁ hp₁ with ⟨r₁, rfl⟩, use r - r₁, simp [vadd_vadd, ←add_smul] }
use v
intros p₂ hp₂
rcases hv p₂ hp₂ with ⟨r, rfl⟩
rcases hv p₁ hp₁ with ⟨r₁, rfl⟩
use r - r₁
simp [vadd_vadd, ←add_smul]
intros
rw [midpoint, ← line_map_apply_one_sub, one_sub_inv_of_two, midpoint]
intros
apply equiv.perm.swap_induction_on' σ
{ simp }
simp
intros s x y hxy hI
{ intros s x y hxy hI, simpa [g.map_swap (v ∘ s) hxy, equiv.perm.sign_swap hxy] using hI, }
simpa [g.map_swap (v ∘ s) hxy, equiv.perm.sign_swap hxy] using hI
intros
{ ext, simp [linear_equiv_fun_on_fintype], }
ext
simp [linear_equiv_fun_on_fintype]
intros
rw [set_like.ext'_iff, range_coe, top_coe, set.range_iff_surjective]
intros
simpa only [range_eq_map] using submodule.map_smul f _ a h
intros
apply set_like.coe_eq_coe.mp
have : ↑(to_span_nonzero_singleton K M x h 1) = to_span_singleton K M x 1 := rfl
rw [this, to_span_singleton_one, submodule.coe_mk]
intros
ext
{ ext, simp }
simp
intros
{ rw ← b.coe_repr_symm, exact b.repr.symm_apply_apply x }
rw ← b.coe_repr_symm
exact b.repr.symm_apply_apply x
intros
rw [b.constr_def S f, linear_map.range_comp, linear_map.range_comp, linear_equiv.range, ← finsupp.supported_univ, finsupp.lmap_domain_supported, ←set.image_univ, ← finsupp.span_image_eq_map_total, set.image_id]
intros
rw [sym, apply_dual_basis_left]
intros
simp only [bilin_form.comp_right, bilin_form.to_matrix'_comp, to_matrix'_id, transpose_one, matrix.one_mul]
intros
{ ext m, exact map_apply_ι _ _ _ _ m }
ext m
exact map_apply_ι _ _ _ _ m
intros
letI := classical.dec_eq (basis.of_vector_space_index K V)
apply tensor_product.ext
apply linear_map.ext_ring
apply (basis.of_vector_space K V).ext
intro j
rw [linear_map.compr₂_apply, linear_map.compr₂_apply, tensor_product.mk_apply]
simp only [linear_map.coe_comp, function.comp_app, linear_equiv.coe_to_linear_map]
rw [lid_tmul, one_smul, rid_symm_apply]
simp only [linear_equiv.coe_to_linear_map, linear_map.rtensor_tmul, coevaluation_apply_one]
rw [tensor_product.sum_tmul, linear_equiv.map_sum]
simp only [assoc_tmul]
rw [linear_map.map_sum]
simp only [linear_map.ltensor_tmul, contract_left_apply]
simp only [basis.coord_apply, basis.repr_self_apply, tensor_product.tmul_ite]
rw [finset.sum_ite_eq]
simp only [finset.mem_univ, if_true]
intros
{ rw [← dim_sup_add_dim_inf_eq], exact self_le_add_right _ _ }
rw [← dim_sup_add_dim_inf_eq]
exact self_le_add_right _ _
intros
simp [finsupp_tensor_finsupp]
intros
refine linear_map.mem_ker.trans _
simp_rw [linear_map.ext_iff, dual_restrict_apply]
exact ⟨λ h w hw, h ⟨w, hw⟩, λ h w, h w.1 w.2⟩
intros
rw [has_eigenvalue, submodule.ne_bot_iff]
use x
exact h
intros
haveI := hs.fintype; exact of_fintype_basis h
haveI := hs.fintype
exact of_fintype_basis h
intros
rw ← s.finrank_quotient_add_finrank
{ rw ← s.finrank_quotient_add_finrank, exact nat.le_add_right _ _ }
exact nat.le_add_right _ _
intros
simp only [← linear_independent_option', option.cases_on'_none_coe]
intros
dsimp [mk_span_singleton']
rw [← sub_eq_zero, ← sub_smul]
apply H
simp only [sub_smul, one_smul, sub_eq_zero]
apply classical.some_spec (mem_span_singleton.1 h)
intros
ext
ext; simp
simp
intros
refine ⟨λ i, A i i, ext $ λ i j, _⟩
obtain rfl | hij := decidable.eq_or_ne i j
{ rw diagonal_apply_eq }
rw diagonal_apply_eq
{ rw [diagonal_apply_ne hij, h hij] }
rw [diagonal_apply_ne hij, h hij]
intros
refine ⟨λ h, _, is_unit_nonsing_inv_det _⟩
nontriviality α
casesI is_empty_or_nonempty n
{ simp }
simp
contrapose! h
rw [nonsing_inv_apply_not_is_unit _ h, det_zero]
{ simp }
simp
{ apply_instance }
apply_instance
intros
casesI (subsingleton_or_nontrivial α)
{ simp }
simp
rw [←@det_one n, ←coeff_det_X_add_C_card _ A, leading_coeff]
simp only [matrix.map_one, C_eq_zero, ring_hom.map_one]
cases (nat_degree_det_X_add_C_le 1 A).eq_or_lt with h h
simp only [ring_hom.map_one, matrix.map_one, C_eq_zero] at h
{ simp only [ring_hom.map_one, matrix.map_one, C_eq_zero] at h, rw h }
rw h
have H := coeff_eq_zero_of_nat_degree_lt h
{ have H := coeff_eq_zero_of_nat_degree_lt h, rw coeff_det_X_add_C_card at H, simpa using H }
rw coeff_det_X_add_C_card at H
simpa using H
intros
ext i
{ ext i, rw [← matrix.to_lin'_apply, linear_map.to_matrix, linear_equiv.trans_apply, matrix.to_lin'_to_matrix', linear_equiv.arrow_congr_apply, v₂.equiv_fun_apply], congr, exact v₁.equiv_fun.symm_apply_apply x }
rw [← matrix.to_lin'_apply, linear_map.to_matrix, linear_equiv.trans_apply, matrix.to_lin'_to_matrix', linear_equiv.arrow_congr_apply, v₂.equiv_fun_apply]
congr
exact v₁.equiv_fun.symm_apply_apply x
intros
simpa using f.map_piecewise_add m m' finset.univ
intros
{ ext x, simp }
ext x
simp
intros
rw [ker, ← prod_bot, prod_comap_inl]
intros
simp [of_is_compl]
intros
simp only [basis_fun, basis.coe_of_equiv_fun, linear_equiv.refl_symm, linear_equiv.refl_apply, std_basis_apply]
{ simp only [basis_fun, basis.coe_of_equiv_fun, linear_equiv.refl_symm, linear_equiv.refl_apply, std_basis_apply], congr }
congr
intros
classical
induction s using finset.induction with a s has ih h
{ simp, }
simp
{ simp [finset.sum_insert has, tmul_add, ih], }
simp [finset.sum_insert has, tmul_add, ih]
intros
split; intro h
split
{ split; intro h, { rw h; by_cases b; [left,right]; split; assumption }, { cases h with h h; cases h; split; intro; { contradiction <|> assumption } } }
intro h
rw h; by_cases b; [left,right]; split; assumption
rw h; by_cases b; [left,right]; split
rw h; by_cases b; [left,right]
rw h; by_cases b
{ rw h; by_cases b; [left,right]; split; assumption }
rw h
by_cases b
left
split
assumption
assumption
assumption
assumption
right
split
assumption
assumption
assumption
assumption
intro h
cases h with h h; cases h; split; intro; { contradiction <|> assumption }
cases h with h h; cases h; split; intro
cases h with h h; cases h; split
cases h with h h; cases h
{ cases h with h h; cases h; split; intro; { contradiction <|> assumption } }
cases h with h h
cases h
split
intro
{ contradiction <|> assumption }
intro
assumption
{ contradiction <|> assumption }
cases h
split
intro
{ contradiction <|> assumption }
intro
contradiction
{ contradiction <|> assumption }
intros
{ext, simp}
ext
simp
intros
induction h using relation.refl_trans_gen.head_induction_on
{ left, refl }
left
refl
{ right, existsi _, split; assumption }
right
existsi _
split
split; assumption
assumption
assumption
intros
simpa only [min_def] using hf.piecewise (measurable_set_le hf hg) hg
intros
refine integrable_of_forall_fin_meas_le' hm (μ s * ∥x∥₊) (ennreal.mul_lt_top hμs ennreal.coe_ne_top) _ _
{ exact Lp.ae_measurable _, }
exact Lp.ae_measurable _
refine λ t ht hμt, (set_lintegral_nnnorm_condexp_ind_smul_le hm hs hμs x ht hμt).trans _
{ refine λ t ht hμt, (set_lintegral_nnnorm_condexp_ind_smul_le hm hs hμs x ht hμt).trans _, exact ennreal.mul_le_mul (measure_mono (set.inter_subset_left _ _)) le_rfl, }
exact ennreal.mul_le_mul (measure_mono (set.inter_subset_left _ _)) le_rfl
intros
haveI : fact (m ≤ m0) := ⟨hm⟩
{ haveI : fact (m ≤ m0) := ⟨hm⟩, exact orthogonal_projection_norm_le _, }
exact orthogonal_projection_norm_le _
intros
simp [has_finite_integral, lintegral_const, lt_top_iff_ne_top, or_iff_not_imp_left]
intros
simp only [edist_eq_coe_nnnorm]
intros
simp [snorm, hp_ne_zero, hp_ne_top]
intros
ext1
refine indicator_const_Lp_coe_fn.trans (eventually_eq.trans _ (Lp.coe_fn_add _ _).symm)
refine eventually_eq.trans _ (eventually_eq.add indicator_const_Lp_coe_fn.symm indicator_const_Lp_coe_fn.symm)
rw set.indicator_union_of_disjoint (set.disjoint_iff_inter_eq_empty.mpr hst) _
intros
simp_rw [snorm_ess_sup, ← of_real_norm_eq_coe_nnnorm]
refine ess_sup_le_of_ae_le (ennreal.of_real C) (hfC.mono (λ x hx, _))
exact ennreal.of_real_le_of_real hx
intros
have : f =ᵐ[μ] f.map (ennreal.to_real ∘ ennreal.of_real) := h_pos.mono (λ a h, (ennreal.to_real_of_real h).symm)
rw [← integral_eq_lintegral' hf]
exacts [integral_congr hf this, ennreal.of_real_zero, λ b, ennreal.of_real_ne_top]
intros
simp [integrable_on, integrable, has_finite_integral, nnnorm_indicator_eq_indicator_nnnorm, ennreal.coe_indicator, lintegral_indicator _ hs, ae_measurable_indicator_iff hs]
intros
cases le_total a b with hab hab; simp only [Ioc_eq_empty hab.not_lt, empty_union, union_empty] at hf ⊢
cases le_total a b with hab hab
simp only [Ioc_eq_empty hab.not_lt, empty_union, union_empty] at hf ⊢
exact integral_eq_zero_iff_of_le_of_nonneg_ae hab hf hfi
{ exact integral_eq_zero_iff_of_le_of_nonneg_ae hab hf hfi }
simp only [Ioc_eq_empty hab.not_lt, empty_union, union_empty] at hf ⊢
rw [integral_symm, neg_eq_zero, integral_eq_zero_iff_of_le_of_nonneg_ae hab hf hfi.symm]
{ rw [integral_symm, neg_eq_zero, integral_eq_zero_iff_of_le_of_nonneg_ae hab hf hfi.symm] }
intros
by_cases hc : c = 0; simp [hc]
by_cases hc : c = 0
simp [hc]
simp [hc]
intros
simp only [sub_smul, ← set_integral_const]
refine (integral_Iic_sub_Iic _ _).symm
refine (integral_Iic_sub_Iic _ _).symm; simp only [integrable_on_const, measure_lt_top, or_true]
simp only [integrable_on_const, measure_lt_top, or_true]
simp only [integrable_on_const, measure_lt_top, or_true]
intros
rw [measure.restrict_empty, lintegral_zero_measure]
intros
have : ∀ n, ∫⁻ a, F n a ∂μ = ∫⁻ a, (hF_meas n).mk (F n) a ∂μ := λ n, lintegral_congr_ae (hF_meas n).ae_eq_mk
simp_rw this
apply tendsto_lintegral_of_dominated_convergence bound (λ n, (hF_meas n).measurable_mk) _ h_fin
have : ∀ n, ∀ᵐ a ∂μ, (hF_meas n).mk (F n) a = F n a := λ n, (hF_meas n).ae_eq_mk.symm
{ have : ∀ n, ∀ᵐ a ∂μ, (hF_meas n).mk (F n) a = F n a := λ n, (hF_meas n).ae_eq_mk.symm, have : ∀ᵐ a ∂μ, ∀ n, (hF_meas n).mk (F n) a = F n a := ae_all_iff.mpr this, filter_upwards [this, h_lim], assume a H H', simp_rw H, exact H' }
have : ∀ᵐ a ∂μ, ∀ n, (hF_meas n).mk (F n) a = F n a := ae_all_iff.mpr this
filter_upwards [this, h_lim]
assume a H H'
simp_rw H
exact H'
assume n
{ assume n, filter_upwards [h_bound n, (hF_meas n).ae_eq_mk], assume a H H', rwa H' at H }
filter_upwards [h_bound n, (hF_meas n).ae_eq_mk]
assume a H H'
rwa H' at H
intros
rw [restrict_with_density hs, lintegral_with_density_eq_lintegral_mul _ hf hg]
intros
refine le_trans (ennreal.lintegral_mul_le_Lp_mul_Lq μ hpq hf (hg.pow_const _)) _
by_cases hf_zero_rpow : (∫⁻ (a : α), (f a) ^ p ∂μ) ^ (1 / p) = 0
rw [hf_zero_rpow, zero_mul]
{ rw [hf_zero_rpow, zero_mul], exact zero_le _, }
exact zero_le _
have hf_top_rpow : (∫⁻ (a : α), (f a) ^ p ∂μ) ^ (1 / p) ≠ ⊤
by_contra h
{ by_contra h, push_neg at h, refine hf_top _, have hp_not_neg : ¬ p < 0, by simp [hpq.nonneg], simpa [hpq.pos, hp_not_neg] using h, }
refine hf_top _
have hp_not_neg : ¬ p < 0
simp [hpq.nonneg]
simp [hpq.nonneg]
simpa [hpq.pos, hp_not_neg] using h
refine (ennreal.mul_le_mul_left hf_zero_rpow hf_top_rpow).mpr (le_of_eq _)
congr
ext1 a
rw [←ennreal.rpow_mul, hpq.sub_one_mul_conj]
intros
rwa [integral_trim hm hf_meas, restrict_trim hm μ]
intros
simp_rw [set_to_simple_func, pi.add_apply]
push_cast
simp_rw [pi.add_apply, sum_add_distrib]
intros
induction l with i l ih
{ exact measurable_const }
exact measurable_const
{ exact (measurable_pi_apply i).prod_mk ih }
exact (measurable_pi_apply i).prod_mk ih
intros
{ funext, simp [← ennreal.coe_eq_coe], }
funext
simp [← ennreal.coe_eq_coe]
intros
simp only [prehaar]
rw [div_le_div_right]
exact_mod_cast index_mono K₂.2 h hU
exact_mod_cast index_pos K₀ hU
intros
let f : E →ₗ[ℝ] E := r • 1
change measure.map f μ = _
have hf : f.det ≠ 0
simp only [mul_one, linear_map.det_smul, ne.def, monoid_hom.map_one]
{ simp only [mul_one, linear_map.det_smul, ne.def, monoid_hom.map_one], assume h, exact hr (pow_eq_zero h) }
assume h
exact hr (pow_eq_zero h)
simp only [map_linear_map_add_haar_eq_smul_add_haar μ hf, mul_one, linear_map.det_smul, monoid_hom.map_one]
intros
simpa [h] using m.Union s
intros
rw [← of_union disjoint_diff hA (hB.diff hA), union_diff_cancel h]
apply_instance
intros
by_cases hi : measurable_set i
ext j hj
{ ext j hj, simp [restrict_apply _ hi hj] }
simp [restrict_apply _ hi hj]
{ simp [restrict_not_measurable _ hi] }
simp [restrict_not_measurable _ hi]
intros
apply le_antisymm; apply generate_from_le
apply le_antisymm
apply generate_from_le
exact λ t h_t, generate_from_measurable_set_of_generate_pi_system t h_t
{ exact λ t h_t, generate_from_measurable_set_of_generate_pi_system t h_t, }
apply generate_from_le
exact λ t h_t, measurable_set_generate_from (generate_pi_system.base h_t)
{ exact λ t h_t, measurable_set_generate_from (generate_pi_system.base h_t), }
intros
simp only [sum_inv, coe_coe, add_zero, insert_eq_cons, add_assoc, map_cons, sum_cons, map_singleton, sum_singleton]
intros
by_cases h0 : n = 0
simp [h0]
{ simp [h0] }
rw [bernoulli, neg_one_pow_eq_pow_mod_two]
cases mod_two_eq_zero_or_one n
simp [h]
{ simp [h] }
simp [bernoulli'_odd_eq_zero (odd_iff.mpr h) (one_lt_iff_ne_zero_and_ne_one.mpr ⟨h0, hn⟩)]
intros
refine iff.trans _ mul_eq_zero.symm
refine iff.trans _ (or_congr sub_eq_zero add_eq_zero_iff_eq_neg).symm
exact ⟨λe, by rw ← e; apply nat_abs_eq, λo, by cases o; subst x; simp [nat_abs_of_nat]⟩
intros
induction i with i ih
{ dsimp [s, s_zmod], norm_num, }
dsimp [s, s_zmod]
norm_num
{ push_cast [s, s_zmod, ih] }
push_cast [s, s_zmod, ih]
intros
conv in k { rw ← nat.div_add_mod k (2^n) }
refine nat.modeq.add_right _ _
conv { congr, skip, skip, rw ← one_mul (k/2^n) }
exact (nat.modeq_sub $ pow_pos (by norm_num : 0 < 2) _).mul_right _
intros
induction k; simp [*, padic_val_rat.mul _ hq (pow_ne_zero _ hq), pow_succ, add_mul, add_comm]
induction k
simp [*, padic_val_rat.mul _ hq (pow_ne_zero _ hq), pow_succ, add_mul, add_comm]
simp [*, padic_val_rat.mul _ hq (pow_ne_zero _ hq), pow_succ, add_mul, add_comm]
intros
wlog hle := le_total (padic_norm p r) (padic_norm p q) using [q r]
have hlt : padic_norm p r < padic_norm p q
from lt_of_le_of_ne hle hne.symm
have : padic_norm p q ≤ max (padic_norm p (q + r)) (padic_norm p r)
from calc padic_norm p q = padic_norm p (q + r - r) : by congr; ring ... ≤ max (padic_norm p (q + r)) (padic_norm p (-r)) : padic_norm.nonarchimedean p ... = max (padic_norm p (q + r)) (padic_norm p r) : by simp
have hnge : padic_norm p r ≤ padic_norm p (q + r)
apply le_of_not_gt
{ apply le_of_not_gt, intro hgt, rw max_eq_right_of_lt hgt at this, apply not_lt_of_ge this, assumption }
intro hgt
rw max_eq_right_of_lt hgt at this
apply not_lt_of_ge this
assumption
have : padic_norm p q ≤ padic_norm p (q + r)
rwa [max_eq_left hnge] at this
rwa [max_eq_left hnge] at this
apply _root_.le_antisymm
{ apply padic_norm.nonarchimedean p }
apply padic_norm.nonarchimedean p
rw max_eq_left_of_lt hlt
{ rw max_eq_left_of_lt hlt, assumption }
assumption
intros
unfold has_norm.norm
rw [← padic_norm_e.eq_padic_norm', ← padic.cast_eq_of_rat]
intros
simp [nth_hom]; refl
simp [nth_hom]
refl
intros
by_cases hk : k = 0
simp only [pythagorean_triple, hk, zero_mul, zero_add]
{ simp only [pythagorean_triple, hk, zero_mul, zero_add], }
calc (k * x) * (k * x) + (k * y) * (k * y) = k ^ 2 * (x * x + y * y) : by ring ... = k ^ 2 * (z * z) : by rw h.eq ... = (k * z) * (k * z) : by ring
{ calc (k * x) * (k * x) + (k * y) * (k * y) = k ^ 2 * (x * x + y * y) : by ring ... = k ^ 2 * (z * z) : by rw h.eq ... = (k * z) * (k * z) : by ring }
intros
simp [to_complex_def]
intros
{ ext x y, exact H x y }
ext x y
exact H x y
intros
rw [sdiff_sdiff_left, sup_idem]
intros
simp [(<)]; existsi a; refl
simp [(<)]; existsi a
simp [(<)]
intros
rw [insert_eq, lower_bounds_union, lower_bounds_singleton]
intros
rw [infi, Inf_apply, infi, infi, ← image_eq_range (λ f : Π i, β i, f a) (range f), ← range_comp]
intros
rw [infi, image_eq_range]
intros
rw [hs.sup'_eq_cSup_image, image_id]
intros
cases n
rw [disjointed_zero, eq_comm, inf_eq_left]
{ rw [disjointed_zero, eq_comm, inf_eq_left], simp_rw le_infi_iff, exact λ i hi, (i.not_lt_zero hi).elim }
simp_rw le_infi_iff
exact λ i hi, (i.not_lt_zero hi).elim
simp_rw [disjointed_succ, partial_sups_eq_bsupr, sdiff_eq, compl_supr]
congr
ext i
rw nat.lt_succ_iff
intros
rw [← e.comap_at_top, tendsto_comap_iff]
intros
refine ⟨_, (tendsto_at_top_at_top_of_monotone (λ b₁ b₂, (hm b₁ b₂).2) hu).comp⟩
rw [tendsto_at_top, tendsto_at_top]
exact λ hc b, (hc (e b)).mono (λ a, (hm b (f a)).1)
intros
rw countable_iff_exists_surjective_to_subtype Bne at Bcbl
rcases Bcbl with ⟨g, gsurj⟩
rw infi_subtype'
use (λ n, g n)
apply le_antisymm
apply le_antisymm; rw le_infi_iff
rw le_infi_iff
{ intro i, apply infi_le_of_le (g i) _, apply le_refl _ }
intro i
apply infi_le_of_le (g i) _
apply le_refl _
rw le_infi_iff
{ intros a, rcases gsurj a with ⟨i, rfl⟩, apply infi_le }
intros a
rcases gsurj a with ⟨i, rfl⟩
apply infi_le
intros
simp [filter.frequently, -not_eventually, not_forall]
intros
simp only [Sup_eq_supr, comap_supr, eq_self_iff_true]
intros
refine le_antisymm (le_seq $ λ s hs t ht, _) (le_seq $ λ s hs t ht, _)
rcases mem_map_iff_exists_image.1 hs with ⟨u, hu, hs⟩
{ rcases mem_map_iff_exists_image.1 hs with ⟨u, hu, hs⟩, refine mem_of_superset _ (set.seq_mono hs subset.rfl), rw ← set.prod_image_seq_comm, exact seq_mem_seq (image_mem_map ht) hu }
refine mem_of_superset _ (set.seq_mono hs subset.rfl)
rw ← set.prod_image_seq_comm
exact seq_mem_seq (image_mem_map ht) hu
rcases mem_map_iff_exists_image.1 hs with ⟨u, hu, hs⟩
{ rcases mem_map_iff_exists_image.1 hs with ⟨u, hu, hs⟩, refine mem_of_superset _ (set.seq_mono hs subset.rfl), rw set.prod_image_seq_comm, exact seq_mem_seq (image_mem_map ht) hu }
refine mem_of_superset _ (set.seq_mono hs subset.rfl)
rw set.prod_image_seq_comm
exact seq_mem_seq (image_mem_map ht) hu
intros
rcases eventually_prod_iff.1 h with ⟨pa, ha, pb, hb, h⟩
exact ha.mono (λ a ha, hb.mono $ λ b hb, h ha hb)
intros
simp [ne_bot_iff, not_and_distrib]
intros
have h1 : ∀ᶠ a in f, ∀ b, u a b ≤ f.limsup (λ a', u a' b)
rw eventually_countable_forall
rw eventually_countable_forall
{ rw eventually_countable_forall, exact λ b, ennreal.eventually_le_limsup (λ a, u a b), }
{ rw eventually_countable_forall, exact λ b, ennreal.eventually_le_limsup (λ a, u a b), }
exact λ b, ennreal.eventually_le_limsup (λ a, u a b)
exact λ b, ennreal.eventually_le_limsup (λ a, u a b)
refine Inf_le (h1.mono (λ x hx, filter.liminf_le_liminf (filter.eventually_of_forall hx) _))
filter.is_bounded_default
intros
simp only [filter.lift', filter.lift, (∘), tendsto_infi, tendsto_principal] at ht ⊢
exact λ u hu, (ht u hu).mp (hst.mono $ λ a hst ht, subset.trans hst ht)
intros
simp only [imp_iff_not_or, eventually_or, eventually_not]
intros
refl
intros
refine hf.seq_pos_lt_seq_of_le_of_lt hn _ (λ k hk, _) (λ k hk, _)
refine hf.seq_pos_lt_seq_of_le_of_lt hn _ (λ k hk, _) (λ k hk, _); simp [iterate_succ' f, h.iterate_right _ _, hg.iterate _ hx]
simp [iterate_succ' f, h.iterate_right _ _, hg.iterate _ hx]
simp [iterate_succ' f, h.iterate_right _ _, hg.iterate _ hx]
simp [iterate_succ' f, h.iterate_right _ _, hg.iterate _ hx]
intros
have SS : @lattice.to_semilattice_sup α A = @lattice.to_semilattice_sup α B := semilattice_sup.ext H
have II := semilattice_inf.ext H
casesI A
casesI B
injection SS; injection II; congr'
injection SS; injection II
injection SS
injection II
congr'
intros
simp only [← sup_eq_right, ← hf.map_sup, h.eq_iff]
intros
simp only [(Δ), sdiff_sdiff_sup_sdiff']
intros
have hl : ((submonoid.closure s) : set α) ⊆ list.prod '' { l : list α | ∀ x, x ∈ l → x ∈ s }
intros x hx
{ intros x hx, rw set_like.mem_coe at hx, refine submonoid.closure_induction hx (λ x hx, ⟨_, λ y hy, _, list.prod_singleton⟩) ⟨_, λ y hy, (list.not_mem_nil _ hy).elim, list.prod_nil⟩ _, { rwa list.mem_singleton.1 hy }, rintros _ _ ⟨l, hl, rfl⟩ ⟨l', hl', rfl⟩, refine ⟨_, λ y hy, _, list.prod_append⟩, cases list.mem_append.1 hy with hy hy, { exact hl _ hy }, { exact hl' _ hy } }
rw set_like.mem_coe at hx
refine submonoid.closure_induction hx (λ x hx, ⟨_, λ y hy, _, list.prod_singleton⟩) ⟨_, λ y hy, (list.not_mem_nil _ hy).elim, list.prod_nil⟩ _
{ rwa list.mem_singleton.1 hy }
rwa list.mem_singleton.1 hy
rintros _ _ ⟨l, hl, rfl⟩ ⟨l', hl', rfl⟩
refine ⟨_, λ y hy, _, list.prod_append⟩
cases list.mem_append.1 hy with hy hy
{ exact hl _ hy }
exact hl _ hy
{ exact hl' _ hy }
exact hl' _ hy
apply ((h.partially_well_ordered_on_sublist_forall₂ (≤)).image_of_monotone_on _).mono hl
intros l1 l2 hl1 hl2 h12
obtain ⟨l, hll1, hll2⟩ := list.sublist_forall₂_iff.1 h12
refine le_trans (list.rel_prod (le_refl 1) (λ a b ab c d cd, mul_le_mul' ab cd) hll1) _
obtain ⟨l', hl'⟩ := hll2.exists_perm_append
rw [hl'.prod_eq, list.prod_append, ← mul_one l.prod, mul_assoc, one_mul]
apply mul_le_mul_left'
have hl's := λ x hx, hl2 x (list.subset.trans (l.subset_append_right _) hl'.symm.subset hx)
clear hl'
induction l' with x1 x2 x3 x4 x5
{ refl }
refl
rw [list.prod_cons, ← one_mul (1 : α)]
exact mul_le_mul' (hpos x1 (hl's x1 (list.mem_cons_self x1 x2))) (x3 (λ x hx, hl's x (list.mem_cons_of_mem _ hx)))
intros
suffices : ϕ.equalizer (lift_hom f (ϕ (root f)) (aeval_alg_hom_eq_zero f ϕ)) = ⊤
exact (alg_hom.ext (λ x, (set_like.ext_iff.mp (this) x).mpr algebra.mem_top)).symm
{ exact (alg_hom.ext (λ x, (set_like.ext_iff.mp (this) x).mpr algebra.mem_top)).symm }
rw [eq_top_iff, ←adjoin_root_eq_top, algebra.adjoin_le_iff, set.singleton_subset_iff]
exact (@lift_root _ _ _ _ _ _ _ (aeval_alg_hom_eq_zero f ϕ)).symm
intros
refine ⟨_, is_integral.is_algebraic K⟩
rintro ⟨p, hp, hpx⟩
refine ⟨_, monic_mul_leading_coeff_inv hp, _⟩
rw [← aeval_def, alg_hom.map_mul, hpx, zero_mul]
intros
refine ⟨λ h, _, is_coprime.pow_left⟩
rw [← finset.card_range m, ← finset.prod_const] at h
exact h.of_prod_left 0 (finset.mem_range.mpr hm)
intros
haveI : is_fraction_ring C L := is_integral_closure.is_fraction_ring_of_finite_extension A K L C
exact ⟨is_integral_closure.is_noetherian_ring A K L C, h.dimension_le_one.is_integral_closure _ L _, (is_integrally_closed_iff L).mpr (λ x hx, ⟨is_integral_closure.mk' C x (is_integral_trans (is_integral_closure.is_integral_algebra A L) _ hx), is_integral_closure.algebra_map_mk' _ _ _⟩)⟩
intros
simpa only [one_mul, eq_self_iff_true, units.coe_one, pow_one, forall_true_left, nat.cast_one] using add_val_def ϖ 1 hϖ 1
intros
split
intro h
{ intro h, apply fractional_ideal.mul_induction_on h, { intros x' hx' y' hy', obtain ⟨a, ha⟩ := (mem_span_singleton S).mp hx', use [a • y', submodule.smul_mem I a hy'], rw [←ha, algebra.mul_smul_comm, algebra.smul_mul_assoc] }, { exact ⟨0, submodule.zero_mem I, (mul_zero x).symm⟩ }, { rintros _ _ ⟨y, hy, rfl⟩ ⟨y', hy', rfl⟩, exact ⟨y + y', submodule.add_mem I hy hy', (mul_add _ _ _).symm⟩ }, { rintros r _ ⟨y', hy', rfl⟩, exact ⟨r • y', submodule.smul_mem I r hy', (algebra.mul_smul_comm _ _ _).symm ⟩ } }
apply fractional_ideal.mul_induction_on h
intros x' hx' y' hy'
{ intros x' hx' y' hy', obtain ⟨a, ha⟩ := (mem_span_singleton S).mp hx', use [a • y', submodule.smul_mem I a hy'], rw [←ha, algebra.mul_smul_comm, algebra.smul_mul_assoc] }
obtain ⟨a, ha⟩ := (mem_span_singleton S).mp hx'
use [a • y', submodule.smul_mem I a hy']
rw [←ha, algebra.mul_smul_comm, algebra.smul_mul_assoc]
rintros _ _ ⟨y, hy, rfl⟩ ⟨y', hy', rfl⟩
{ rintros _ _ ⟨y, hy, rfl⟩ ⟨y', hy', rfl⟩, exact ⟨y + y', submodule.add_mem I hy hy', (mul_add _ _ _).symm⟩ }
exact ⟨y + y', submodule.add_mem I hy hy', (mul_add _ _ _).symm⟩
rintros ⟨y', hy', rfl⟩
{ rintros ⟨y', hy', rfl⟩, exact mul_mem_mul ((mem_span_singleton S).mpr ⟨1, one_smul _ _⟩) hy' }
exact mul_mem_mul ((mem_span_singleton S).mpr ⟨1, one_smul _ _⟩) hy'
intros
refine subring.in_closure.rec_on hxs _ _ _ _
{ rw ring_hom.map_one, refl }
rw ring_hom.map_one
refl
rw [ring_hom.map_neg, ring_hom.map_neg, ring_hom.map_one]
{ rw [ring_hom.map_neg, ring_hom.map_neg, ring_hom.map_one], refl }
refl
rintros _ ⟨p, hps, rfl⟩ n ih
{ rintros _ ⟨p, hps, rfl⟩ n ih, rw [ring_hom.map_mul, restriction_of, dif_pos hps, ring_hom.map_mul, map_of, ih] }
rw [ring_hom.map_mul, restriction_of, dif_pos hps, ring_hom.map_mul, map_of, ih]
intros x y ihx ihy
{ intros x y ihx ihy, rw [ring_hom.map_add, ring_hom.map_add, ihx, ihy] }
rw [ring_hom.map_add, ring_hom.map_add, ihx, ihy]
intros
cases is_maximal_iff.1 hI with H₁ H₂
rcases mem_span_insert.1 (H₂ (span (insert x I)) x (set.subset.trans (subset_insert _ _) subset_span) hx (subset_span (mem_insert _ _))) with ⟨y, z, hz, hy⟩
refine ⟨y, z, _, hy.symm⟩
rwa ← span_eq I
intros
rintros h
rw h at max
rcases max with ⟨⟨h1, h2⟩⟩
obtain ⟨I, hIbot, hItop⟩ := not_is_field_iff_exists_ideal_bot_lt_and_lt_top.mp not_field
exact ne_of_lt hItop (h2 I hIbot)
intros
unfold span
{ unfold span, rw [submodule.span_mul_span, set.singleton_mul_singleton], }
rw [submodule.span_mul_span, set.singleton_mul_singleton]
intros
obtain ⟨Q, ⟨Q_prime, hQ⟩⟩ := exists_ideal_over_prime_of_is_integral' H P hP
haveI : Q.is_prime := Q_prime
exact ⟨Q, is_maximal_of_is_integral_of_is_maximal_comap H _ (hQ.symm ▸ P_max), hQ⟩
intros
rw [add_mk, mk_eq_mk_iff, r_eq_r']
refine (r' M).symm ⟨1, _⟩
simp only [submonoid.coe_one, submonoid.coe_mul]
ring
intros
rw [restrict_degree, finsupp.mem_supported]
refl
intros
obtain ⟨n, ne, w⟩ := is_noetherian.exists_endomorphism_iterate_ker_inf_range_eq_bot f
rw [linear_map.range_eq_top.mpr (linear_map.iterate_surjective s n), inf_top_eq, linear_map.ker_eq_bot] at w
exact linear_map.injective_of_iterate_injective ne w
intros
simp [degree]
intros
rw ←cyclotomic'
induction n using nat.strong_induction_on with k hk generalizing ζ hz
obtain hzero | hpos := k.eq_zero_or_pos
{ simp only [hzero, cyclotomic'_zero, cyclotomic_zero] }
simp only [hzero, cyclotomic'_zero, cyclotomic_zero]
have h : ∀ i ∈ k.proper_divisors, cyclotomic i K = cyclotomic' i K
intros i hi
{ intros i hi, obtain ⟨d, hd⟩ := (nat.mem_proper_divisors.1 hi).1, rw mul_comm at hd, exact hk i (nat.mem_proper_divisors.1 hi).2 (is_primitive_root.pow hpos hz hd) }
obtain ⟨d, hd⟩ := (nat.mem_proper_divisors.1 hi).1
rw mul_comm at hd
exact hk i (nat.mem_proper_divisors.1 hi).2 (is_primitive_root.pow hpos hz hd)
rw [@cyclotomic_eq_X_pow_sub_one_div _ _ _ hpos, cyclotomic'_eq_X_pow_sub_one_div hpos hz, finset.prod_congr (refl k.proper_divisors) h]
intros
apply is_homogeneous_monomial
simp only [finsupp.zero_apply, finset.sum_const_zero]
intros
convert scale_roots_eval₂_eq_zero (algebra_map A S) hr
rw [aeval_def, mk'_spec' _ r s]
intros
dsimp [to_fun_alg_hom]
rw [to_fun_linear_tmul_apply, to_fun_bilinear_apply_eq_sum]
intros
rw [inv_eq_inv_aux, coeff_inv_aux n (constant_coeff k φ)⁻¹ φ]
intros
rw ← inv_of_unit_eq φ (h.symm ▸ u.ne_zero)
congr' 1
rw [units.ext_iff]
exact h.symm
intros
rw [coeff_X, if_pos rfl]
intros
rw [← @span_singleton_eq_bot R M, span_singleton_generator]
intros
obtain ⟨ζ, rfl⟩ := h.is_unit h0
obtain ⟨ξ, rfl⟩ := is_unit_of_pow_eq_one ξ k hξ h0
obtain ⟨k, rfl⟩ : ∃ k' : ℕ+, k = k' := ⟨⟨k, h0⟩, rfl⟩
simp only [← units.coe_pow, ← units.ext_iff]
rw coe_units_iff at h
apply h.eq_pow_of_mem_roots_of_unity
rw [mem_roots_of_unity, units.ext_iff, units.coe_pow, hξ, units.coe_one]
intros
haveI : nonempty S := Sne.to_subtype
simp only [Sup_eq_supr', mem_supr_of_directed hS.directed_coe, set_coe.exists, subtype.coe_mk]
intros
split
{ rw ← mk_dvd_mk, apply dvd_of_mem_factors', apply ha0 }
rw ← mk_dvd_mk
apply dvd_of_mem_factors'
apply ha0
{ apply mem_factors'_of_dvd ha0 }
apply mem_factors'_of_dvd ha0
intros
apply constant_coeff_witt_structure_int p _ _ n
simp only [add_zero, ring_hom.map_add, constant_coeff_X]
intros
apply le_antisymm
{ rw [powerlt_le], intros c hc, apply zero_power_le }
rw [powerlt_le]
intros c hc
apply zero_power_le
convert le_powerlt (pos_iff_ne_zero.2 h)
rw [power_zero]
intros
rw [←not_lt, lt_omega_iff_fintype, not_nonempty_iff, is_empty_fintype]
intros
{ rw [mul_eq_max_of_omega_le_left ha hb', max_eq_left hb] }
rw [mul_eq_max_of_omega_le_left ha hb', max_eq_left hb]
intros
{cases x, cases y, refl}
cases x
cases y
refl
intros
rw [le_zero_iff_zero_le_neg, le_congr (equiv_refl 0) (neg_equiv_self G)]
intros
rw [CNF_rec, dif_pos rfl]; refl
rw [CNF_rec, dif_pos rfl]
refl
intros
induction n with n ih; [rw [nat.cast_zero, add_zero, add_zero], rw [← nat_cast_succ, add_succ, add_succ, succ_le_succ, ih]]
induction n with n ih
rw [nat.cast_zero, add_zero, add_zero]
rw [← nat_cast_succ, add_succ, add_succ, succ_le_succ, ih]
intros
simpa only [not_ball, not_le] using not_congr (@limit_le _ h a)
rw lt_def
left
use ⟨punit.star, by split; rintro ⟨ ⟩⟩
intros
rw lt_def_le at *
rcases hwx with ⟨ix, hix⟩|⟨jw, hjw⟩; rcases hyz with ⟨iz, hiz⟩|⟨jy, hjy⟩
rcases hwx with ⟨ix, hix⟩|⟨jw, hjw⟩
rcases hyz with ⟨iz, hiz⟩|⟨jy, hjy⟩
left
{ left, use (left_moves_add x z).symm (sum.inl ix), simp only [add_move_left_inl], calc w + y ≤ move_left x ix + y : add_le_add_right hix ... ≤ move_left x ix + move_left z iz : add_le_add_left hiz ... ≤ move_left x ix + z : add_le_add_left (oz.move_left_le iz) }
use (left_moves_add x z).symm (sum.inl ix)
simp only [add_move_left_inl]
calc w + y ≤ move_left x ix + y : add_le_add_right hix ... ≤ move_left x ix + move_left z iz : add_le_add_left hiz ... ≤ move_left x ix + z : add_le_add_left (oz.move_left_le iz)
left
{ left, use (left_moves_add x z).symm (sum.inl ix), simp only [add_move_left_inl], calc w + y ≤ move_left x ix + y : add_le_add_right hix ... ≤ move_left x ix + move_right y jy : add_le_add_left (oy.le_move_right jy) ... ≤ move_left x ix + z : add_le_add_left hjy }
use (left_moves_add x z).symm (sum.inl ix)
simp only [add_move_left_inl]
calc w + y ≤ move_left x ix + y : add_le_add_right hix ... ≤ move_left x ix + move_right y jy : add_le_add_left (oy.le_move_right jy) ... ≤ move_left x ix + z : add_le_add_left hjy
rcases hyz with ⟨iz, hiz⟩|⟨jy, hjy⟩
right
{ right, use (right_moves_add w y).symm (sum.inl jw), simp only [add_move_right_inl], calc move_right w jw + y ≤ x + y : add_le_add_right hjw ... ≤ x + move_left z iz : add_le_add_left hiz ... ≤ x + z : add_le_add_left (oz.move_left_le iz), }
use (right_moves_add w y).symm (sum.inl jw)
simp only [add_move_right_inl]
calc move_right w jw + y ≤ x + y : add_le_add_right hjw ... ≤ x + move_left z iz : add_le_add_left hiz ... ≤ x + z : add_le_add_left (oz.move_left_le iz)
right
{ right, use (right_moves_add w y).symm (sum.inl jw), simp only [add_move_right_inl], calc move_right w jw + y ≤ x + y : add_le_add_right hjw ... ≤ x + move_right y jy : add_le_add_left (oy.le_move_right jy) ... ≤ x + z : add_le_add_left hjy, }
use (right_moves_add w y).symm (sum.inl jw)
simp only [add_move_right_inl]
calc move_right w jw + y ≤ x + y : add_le_add_right hjw ... ≤ x + move_right y jy : add_le_add_left (oy.le_move_right jy) ... ≤ x + z : add_le_add_left hjy
intros
simp [smulg]
intros
simp
intros
simp only [normalize_fin, ← h] at *; rw [nat.mul_mod, ← ha, ← hb, fin.mul_def]
simp only [normalize_fin, ← h] at *
rw [nat.mul_mod, ← ha, ← hb, fin.mul_def]
intros
simpa only [val, length_neg] using val_between_neg
intros
simp [pow_add, mul_assoc]
intros
cc
intros
refine ⟨λ h, h.tendsto_sum_nat, λ h, _⟩
rw tendsto_nhds_unique h hf.has_sum.tendsto_sum_nat
exact hf.has_sum
intros
refine mem_of_superset (set_pi_mem_nhds (finite.of_fintype _) (λ i _, _)) (pi_univ_Ioc_subset a b)
exact Ioc_mem_nhds (ha i) (hb i)
intros
simp [frontier]
intros
rw continuous_on_iff_continuous_restrict at hf hg
obtain ⟨b, h⟩ := @intermediate_value_univ₂_eventually₂ _ _ _ _ _ _ (subtype.preconnected_space hs) _ _ (comap_coe_ne_bot_of_le_principal hl₁) (comap_coe_ne_bot_of_le_principal hl₂) _ _ hf hg (eventually_comap' he₁) (eventually_comap' he₂)
exact ⟨b, b.prop, h⟩
intros
simp [nhds_eq_order a, tendsto_inf, tendsto_infi, tendsto_principal]
intros
rw ← (is_closed_closure.preimage hf).closure_eq
exact closure_mono (preimage_mono subset_closure)
intros
fsplit
intros hd ho
{ intros hd ho, exact (hd.inter_open_nonempty _ ho (singleton_nonempty _)).ne_empty (inter_compl_self _) }
exact (hd.inter_open_nonempty _ ho (singleton_nonempty _)).ne_empty (inter_compl_self _)
refine λ ho, dense_iff_inter_open.2 (λ U hU hne, inter_compl_nonempty_iff.2 $ λ hUx, _)
{ refine λ ho, dense_iff_inter_open.2 (λ U hU hne, inter_compl_nonempty_iff.2 $ λ hUx, _), obtain rfl : U = {x}, from eq_singleton_iff_nonempty_unique_mem.2 ⟨hne, hUx⟩, exact ho hU }
obtain rfl : U = {x}
from eq_singleton_iff_nonempty_unique_mem.2 ⟨hne, hUx⟩
exact ho hU
intros
simp only [← interior_set_of_eq, is_open_interior]
intros
{ ext, refl }
ext
refl
intros
rw mem_nhds_prod_iff
split
rintros ⟨u, Hu, v, Hv, h⟩
{ rintros ⟨u, Hu, v, Hv, h⟩, rcases mem_nhds_iff.1 Hu with ⟨u', u'u, u'_open, Hu'⟩, rcases mem_nhds_iff.1 Hv with ⟨v', v'v, v'_open, Hv'⟩, exact ⟨u', v', u'_open, Hu', v'_open, Hv', (set.prod_mono u'u v'v).trans h⟩ }
rcases mem_nhds_iff.1 Hu with ⟨u', u'u, u'_open, Hu'⟩
rcases mem_nhds_iff.1 Hv with ⟨v', v'v, v'_open, Hv'⟩
exact ⟨u', v', u'_open, Hu', v'_open, Hv', (set.prod_mono u'u v'v).trans h⟩
rintros ⟨u, v, u_open, au, v_open, bv, huv⟩
{ rintros ⟨u, v, u_open, au, v_open, bv, huv⟩, exact ⟨u, u_open.mem_nhds au, v, v_open.mem_nhds bv, huv⟩ }
exact ⟨u, u_open.mem_nhds au, v, v_open.mem_nhds bv, huv⟩
intros
cases f; cases g; congr'; exact funext H
cases f; cases g; congr'
cases f; cases g
cases f
cases g
congr'
exact funext H
intros
rw [nhds_within_inter, inf_eq_right]
{ rw [nhds_within_inter, inf_eq_right], exact nhds_within_le_of_mem h }
exact nhds_within_le_of_mem h
intros
simp only [continuous_within_at, nhds_within_union, tendsto_sup]
intros
rw continuous_iff_continuous_on_univ
exact continuous_on_extend_from (λ x _, hA x) (by simpa using hf)
intros
intros s hs
cases eq_empty_or_nonempty s with h2s h2s
{ simp_rw [h2s, image_empty, is_closed_empty] }
simp_rw [h2s, image_empty, is_closed_empty]
{ exact h s hs h2s }
exact h s hs h2s
intros
exact_mod_cast hf.mul_le_nndist x y
intros
rw dist_comm z; apply dist_triangle
rw dist_comm z
apply dist_triangle
intros
cases cauchy_iff.1 hf with hf1 hf2
intros ε hε
rcases hf2 {x | dist x.1 x.2 < ε} (dist_mem_uniformity hε) with ⟨t, ⟨ht, htsub⟩⟩
simp at ht
cases ht with N hN
existsi N
intros j hj
rw ←dist_eq_norm
apply @htsub (f j, f N)
apply set.mk_mem_prod; solve_by_elim [le_refl]
apply set.mk_mem_prod
solve_by_elim [le_refl]
solve_by_elim [le_refl]
intros
simp only [inf_edist, le_infi_iff]
intros
rw [metric.diam, metric.diam, hf.ediam_image]
intros
simp only [lipschitz_on_with, edist_nndist, dist_nndist]
{ simp only [lipschitz_on_with, edist_nndist, dist_nndist], norm_cast }
norm_cast
intros
rw [to_pou_fun, h, zero_mul]
intros
ext z
split
intro h'
{ intro h', rw path_component_symm, exact (h.trans h').symm }
rw path_component_symm
exact (h.trans h').symm
intro h'
{ intro h', rw path_component_symm at h' ⊢, exact h'.trans h }
rw path_component_symm at h' ⊢
exact h'.trans h
intros
simp [upper_semicontinuous_within_at, upper_semicontinuous_at, nhds_within_univ]
intros
simp only [filter.coclosed_compact, infi_and']
refine has_basis_binfi_principal' _ ⟨∅, is_closed_empty, is_compact_empty⟩
rintro s ⟨hs₁, hs₂⟩ t ⟨ht₁, ht₂⟩
exact ⟨s ∪ t, ⟨⟨hs₁.union ht₁, hs₂.union ht₂⟩, compl_subset_compl.2 (subset_union_left _ _), compl_subset_compl.2 (subset_union_right _ _)⟩⟩
intros
simp [subset_def]; exact forall_congr (λ a, by simp)
simp [subset_def]
exact forall_congr (λ a, by simp)
intros
{ ext y, rw mem_ball_symmetry hV, exact iff.rfl }
ext y
rw mem_ball_symmetry hV
exact iff.rfl
intros
simp [uniform_continuous]; exact tendsto_id
simp [uniform_continuous]
exact tendsto_id
intros
simp [uniformity_has_basis_closure.separation_rel]
continuity!
intros
cases b; simp
cases b
simp
simp
intros
rw [int.mul_comm, int.distrib_left]
simp [int.mul_comm]
intros
simp [int.lt_iff_le_and_ne]
split
split; intro h
intro h
cases h with hab hn
{ cases h with hab hn, split, { assumption }, { intro hba, simp [int.le_antisymm hab hba] at *, contradiction } }
split
{ assumption }
assumption
intro hba
{ intro hba, simp [int.le_antisymm hab hba] at *, contradiction }
simp [int.le_antisymm hab hba] at *
contradiction
intro h
cases h with hab hn
{ cases h with hab hn, split, { assumption }, { intro h, simp [*] at * } }
split
{ assumption }
assumption
{ intro h, simp [*] at * }
intro h
simp [*] at *
intros
rw int.add_comm at h
exact int.neg_add_le_left_of_le_add h
intros
simp [join, list.bind]
intros
cases m; simp [gcd]
cases m
simp [gcd]
simp [gcd]
intros
have h₁ : f.to_equiv = g.to_equiv := equiv.ext h
cases f
cases g
congr
{ exact (funext h) }
exact (funext h)
{ exact congr_arg equiv.inv_fun h₁ }
exact congr_arg equiv.inv_fun h₁
intros
suffices : (⨆ i, span R (s i : set A)) * span R t = (⨆ i, span R (s i) * span R t)
{ simpa only [span_eq] using this }
simpa only [span_eq] using this
simp_rw [span_mul_span, ← span_Union, span_mul_span, set.Union_mul]
intros
simp [irreducible_iff]
intros
simp
intros
haveI := classical.dec_eq α
rw [← prod_union (filter_inter_filter_neg_eq p s).le, filter_union_filter_neg_eq]
intros
have : mul_support (f ∘ plift.down) ⊆ ({plift.up a} : finset (plift α))
intro x
{ intro x, contrapose, simpa [plift.eq_up_iff_down_eq] using ha x.down }
contrapose
simpa [plift.eq_up_iff_down_eq] using ha x.down
rw [finprod_eq_prod_plift_of_mul_support_subset this, finset.prod_singleton]
intros
rw [← finset.coe_singleton, finprod_mem_coe_finset, finset.prod_singleton]
intros
rcases eq_empty_or_nonempty s with rfl|hs_nonempty
{ simp [h_one] }
simp [h_one]
exact le_prod_nonempty_of_submultiplicative_on_pred f p h_mul hp_mul g s hs_nonempty hs
{ exact le_prod_nonempty_of_submultiplicative_on_pred f p h_mul hp_mul g s hs_nonempty hs, }
intros
{ ext1, apply w }
ext1
apply w
intros
cases y with j₁ y
cases x with j₂ x
cases y' with j₃ y'
obtain ⟨l, f, g, hfg⟩ := hyy'
simp at hfg
obtain ⟨s, α, β, γ, h₁, h₂, h₃⟩ := tulip (right_to_max j₂ j₁) (left_to_max j₂ j₁) (left_to_max j₂ j₃) (right_to_max j₂ j₃) f g
apply M.mk_eq
use [s, α, γ]
dsimp
simp_rw [monoid_hom.map_mul, ← comp_apply, ← F.map_comp, h₁, h₂, h₃, F.map_comp, comp_apply, hfg]
intros
rw [← nsmul_one, card_nsmul_eq_zero]
intros
rw [←sub_eq_zero, ←mul_sub, mul_eq_zero, sub_eq_zero] at h
exact_mod_cast h
intros
rw [denom_eq_conts_b, nth_cont_eq_succ_nth_cont_aux]
{ rw [denom_eq_conts_b, nth_cont_eq_succ_nth_cont_aux], exact zero_le_of_continuants_aux_b }
exact zero_le_of_continuants_aux_b
intros
simp only [num_eq_conts_a, (continuants_stable_of_terminated n_le_m terminated_at_n)]
intros
rw [div_neg_eq_neg_div, neg_div, neg_neg]
intros
{ ext, simp [floor_lt, lt_ceil] }
ext
simp [floor_lt, lt_ceil]
intros
rw [← gcd_erase_dup, erase_dup_ext.2, gcd_erase_dup, gcd_add]
{ rw [← gcd_erase_dup, erase_dup_ext.2, gcd_erase_dup, gcd_add], simp }
simp
intros
{ rw [geom_sum_def, sum_range_one, pow_zero] }
rw [geom_sum_def, sum_range_one, pow_zero]
intros
rw [← mul_assoc, h.mul_inv_cancel]
intros
rw [← f.map_mul, h, f.map_one]
intros
{ ext, cases x; refl }
ext
cases x
cases x; refl
refl
refl
intros
rw [bit1, pow_succ', pow_bit0]
intros
by_cases a0 : 0 ≤ a; by_cases b0 : 0 ≤ b
by_cases a0 : 0 ≤ a
by_cases b0 : 0 ≤ b
{ simp [a0, b0, abs_of_nonneg, add_nonneg a0 b0] }
simp [a0, b0, abs_of_nonneg, add_nonneg a0 b0]
exact (lt_irrefl (0 : α) (a0.trans_lt (hle.trans_lt (not_le.mp b0)))).elim
{ exact (lt_irrefl (0 : α) (a0.trans_lt (hle.trans_lt (not_le.mp b0)))).elim }
by_cases b0 : 0 ≤ b
any_goals { simp [(not_le.mp a0).le, (not_le.mp b0).le, abs_of_nonpos, add_nonpos, add_comm] }
obtain F := (not_le.mp a0)
have : (abs (a + b) = -a + b ↔ b ≤ 0) ↔ (abs (a + b) = abs a + abs b ↔ 0 ≤ a ∧ 0 ≤ b ∨ a ≤ 0 ∧ b ≤ 0)
{ simp [a0, b0, abs_of_neg, abs_of_nonneg, F, F.le] }
simp [a0, b0, abs_of_neg, abs_of_nonneg, F, F.le]
refine this.mp ⟨λ h, _, λ h, by simp only [le_antisymm h b0, abs_of_neg F, add_zero]⟩
by_cases ba : a + b ≤ 0
refine le_of_eq (eq_zero_of_neg_eq _)
{ refine le_of_eq (eq_zero_of_neg_eq _), rwa [abs_of_nonpos ba, neg_add_rev, add_comm, add_right_inj] at h }
rwa [abs_of_nonpos ba, neg_add_rev, add_comm, add_right_inj] at h
refine (lt_irrefl (0 : α) _).elim
{ refine (lt_irrefl (0 : α) _).elim, rw [abs_of_pos (not_le.mp ba), add_left_inj] at h, rwa eq_zero_of_neg_eq h.symm at F }
rw [abs_of_pos (not_le.mp ba), add_left_inj] at h
rwa eq_zero_of_neg_eq h.symm at F
simp [(not_le.mp a0).le, (not_le.mp b0).le, abs_of_nonpos, add_nonpos, add_comm]
intros
rw [eq_comm, mul_eq_zero]
intros
rw [div_div_eq_mul_div, div_mul_cancel _ hc]
intros
dsimp [prev_d, to_prev]
rcases c.prev j with ⟨⟩|⟨⟨j', w⟩⟩; { dsimp [prev_d, to_prev], simp }
rcases c.prev j with ⟨⟩|⟨⟨j', w⟩⟩
{ dsimp [prev_d, to_prev], simp }
{ dsimp [prev_d, to_prev], simp }
dsimp [prev_d, to_prev]
simp
intros
tidy
intros
rw [← inv_inv (a⁻¹ ⊔ b⁻¹), inv_sup_eq_inv_inf_inv a⁻¹ b⁻¹, inv_inv, inv_inv]
intros
haveI : lie_module.is_trivial L I := (lie_module.trivial_iff_le_maximal_trivial R L L I).mpr h
exact lie_ideal.is_lie_abelian_of_trivial R L I
intros
{ ext, refl, }
ext
refl
intros
have h : ⅟(2 : R) • (1 : matrix l l R) + ⅟(2 : R) • 1 = 1 := by rw [← smul_add, ← (two_smul R _), smul_smul, inv_of_mul_self, one_smul]
erw [matrix.from_blocks_transpose, matrix.from_blocks_smul, matrix.mul_eq_mul, matrix.from_blocks_multiply]
simp [h]
intros
rw le_inf_iff
{ rw le_inf_iff, split; apply mono_lie_right; [exact inf_le_left, exact inf_le_right], }
split
split; apply mono_lie_right; [exact inf_le_left, exact inf_le_right]
split; apply mono_lie_right
apply mono_lie_right
exact inf_le_left
apply mono_lie_right
exact inf_le_right
intros
rw [derived_series_eq_derived_series_of_ideal_comap, map_comap_incl, inf_eq_right]
{ rw [derived_series_eq_derived_series_of_ideal_comap, map_comap_incl, inf_eq_right], apply derived_series_of_ideal_le_self, }
apply derived_series_of_ideal_le_self
intros
rw ← coe_to_submodule_eq_iff
{ rw ← coe_to_submodule_eq_iff, exact (K : submodule R L).range_subtype, }
exact (K : submodule R L).range_subtype
intros
apply subsingleton_of_bot_eq_top
ext ⟨x, hx⟩
change x ∈ ⊥ at hx
rw submodule.mem_bot at hx
subst hx
simp only [true_iff, eq_self_iff_true, submodule.mk_eq_zero, lie_submodule.mem_bot]
intros
rw [char_poly, polynomial.is_root.def, polynomial.eval]
simp only [polynomial.eval₂_finset_sum, one_mul, ring_hom.id_apply, polynomial.eval₂_monomial, polynomial.eval₂_sub]
split
intro h
{ intro h, simpa [sub_eq_zero] using h 0 }
simpa [sub_eq_zero] using h 0
intros h n
{ intros h n, simp only [pow_add, sub_eq_zero.mp h, mul_sum], exact sum_congr rfl (λ _ _, by ring) }
simp only [pow_add, sub_eq_zero.mp h, mul_sum]
exact sum_congr rfl (λ _ _, by ring)
intros
rw [bit0, add_smul, one_smul]
intros
rw [of, monoid_hom.coe_mk, ← finsupp.supported_eq_span_single, finsupp.mem_supported]
intros
rw [lt_iff_le_and_ne, ne, eq_comm]; simp [abv_eq_zero abv, abv_nonneg abv]
rw [lt_iff_le_and_ne, ne, eq_comm]
simp [abv_eq_zero abv, abv_nonneg abv]
intros
rw [mul_comm, inv_mul_le_iff' h]
intros
rw [lt_div_iff d0, div_mul_eq_mul_div, div_lt_iff b0]
intros
rw [div_lt_iff (@zero_lt_two α _ _)]
{ rw [div_lt_iff (@zero_lt_two α _ _)], exact lt_mul_of_one_lt_right h one_lt_two }
exact lt_mul_of_one_lt_right h one_lt_two
intros
cases le_total 0 a with h h
calc -abs a = - a : congr_arg (has_neg.neg) (abs_of_nonneg h) ... ≤ 0 : neg_nonpos.mpr h ... ≤ a : h
{ calc -abs a = - a : congr_arg (has_neg.neg) (abs_of_nonneg h) ... ≤ 0 : neg_nonpos.mpr h ... ≤ a : h }
calc -abs a = - - a : congr_arg (has_neg.neg) (abs_of_nonpos h) ... ≤ a : (neg_neg a).le
{ calc -abs a = - - a : congr_arg (has_neg.neg) (abs_of_nonpos h) ... ≤ a : (neg_neg a).le }
intros
rw [← mul_le_mul_iff_right b, one_mul, div_eq_mul_inv, inv_mul_cancel_right]
intros
simp [neg_le_iff_add_nonneg, ← two_mul, mul_nonneg_iff, zero_le_one, (@zero_lt_two α _ _).not_le]
intros
cases a; simp [mul_def, h]; refl
cases a; simp [mul_def, h]
cases a
simp [mul_def, h]
refl
simp [mul_def, h]
refl
intros
haveI := @linear_order.decidable_le α _; exact lt_of_not_ge (assume h2 : b ≥ 0, (decidable.mul_nonneg h1 h2).not_lt h)
haveI := @linear_order.decidable_le α _
exact lt_of_not_ge (assume h2 : b ≥ 0, (decidable.mul_nonneg h1 h2).not_lt h)
intros
simpa only [sub_eq_neg_add] using h.nsmul n (-x)
intros
simp * at *
intros
rw [← image_smul, image_empty]
intros
simpa using nat_degree_multiset_prod_of_monic (s.1.map f) (by simpa using h)
intros
have : discrim a b c = 0 * 0
rw [h, mul_zero]
rw [h, mul_zero]
rw [quadratic_eq_zero_iff ha this, add_zero, sub_zero, or_self]
intros
{ ext, simp [h], }
ext
simp [h]
intros
apply set.subset.antisymm
rintro x hx t' ⟨ht', ht⟩
{ rintro x hx t' ⟨ht', ht⟩, obtain ⟨fs, rfl⟩ : ∃ s, t' = zero_locus s, by rwa [is_closed_iff_zero_locus] at ht', rw [subset_zero_locus_iff_subset_vanishing_ideal] at ht, exact set.subset.trans ht hx }
obtain ⟨fs, rfl⟩ : ∃ s, t' = zero_locus s
rwa [is_closed_iff_zero_locus] at ht'
rwa [is_closed_iff_zero_locus] at ht'
rw [subset_zero_locus_iff_subset_vanishing_ideal] at ht
exact set.subset.trans ht hx
rw (is_closed_zero_locus _).closure_subset_iff
{ rw (is_closed_zero_locus _).closure_subset_iff, exact subset_zero_locus_vanishing_ideal t }
exact subset_zero_locus_vanishing_ideal t
intros
dsimp [δ, σ]
{ dsimp [δ, σ], simp only [←X.map_comp, ←op_comp, simplex_category.σ_comp_σ H] }
simp only [←X.map_comp, ←op_comp, simplex_category.σ_comp_σ H]
intros
simpa only [sub_eq_add_neg] using hf.add hg.neg
intros
ext j
refine p.congr (by simp) (λ i hi1 hi2, _)
dsimp
congr' 1
convert composition.single_embedding hn ⟨i, hi2⟩
cases j
have : j_val = 0 := le_bot_iff.1 (nat.lt_succ_iff.1 j_property)
unfold_coes
congr
congr; try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
try { assumption <|> simp }
assumption
simp
intros
convert h.is_o.right_is_O_add
ext
simp
intros
simpa [is_O, is_O_with] using is_O_snd_prod
intros
refine (is_o_iff_tendsto' _).mpr (tendsto_pow_div_pow_at_top_zero hpq)
exact (eventually_gt_at_top 0).mono (λ x hx hxq, (pow_ne_zero q hx.ne' hxq).elim)
intros
convert (has_deriv_within_at_const x s c).mul hd
rw [zero_mul, zero_add]
intros
simp [has_strict_deriv_at, has_strict_fderiv_at]
intros
simpa [continuous_linear_map.sum_apply] using (has_strict_fderiv_at.sum h).has_strict_deriv_at
intros
refine hf.iterate _ hx n
convert hf.continuous_at
exact hx.symm
intros
simp only [sub_eq_add_neg, differentiable_on_add_const_iff]
intros
rw [← differentiable_on_univ, ← differentiable_on_univ]
exact iso.comp_differentiable_on_iff
intros
simp only [differentiable_within_at, has_fderiv_within_at_univ, differentiable_at]
intros
simp [B, is_open_Union, is_open.inter, is_open_A]
intros
simpa only [restrict_apply, add_sub_cancel'_right] using (f'.lipschitz.restrict s).add hf.lipschitz_sub
intros
ext x
{ ext x, rw [iterated_deriv_within, iterated_deriv, iterated_fderiv_within_univ] }
rw [iterated_deriv_within, iterated_deriv, iterated_fderiv_within_univ]
intros
simp [← times_cont_diff_on_univ, times_cont_diff_on, times_cont_diff_at]
intros
simp only [← times_cont_diff_on_univ, times_cont_diff_on_pi]
intros
simp only [times_cont_diff_iff_times_cont_diff_at] at *
exact λ x, (hf x).div (hg x) (h0 x)
intros
induction n with n IH generalizing x
{ ext m, simp }
ext m
simp
have A : fderiv_within 𝕜 (λ y, iterated_fderiv_within 𝕜 n f (s ∩ u) y) (s ∩ u) x = fderiv_within 𝕜 (λ y, iterated_fderiv_within 𝕜 n f s y) (s ∩ u) x := fderiv_within_congr (hs x hx) (λ y hy, IH hy) (IH hx)
{ have A : fderiv_within 𝕜 (λ y, iterated_fderiv_within 𝕜 n f (s ∩ u) y) (s ∩ u) x = fderiv_within 𝕜 (λ y, iterated_fderiv_within 𝕜 n f s y) (s ∩ u) x := fderiv_within_congr (hs x hx) (λ y hy, IH hy) (IH hx), have B : fderiv_within 𝕜 (λ y, iterated_fderiv_within 𝕜 n f s y) (s ∩ u) x = fderiv_within 𝕜 (λ y, iterated_fderiv_within 𝕜 n f s y) s x := fderiv_within_inter (is_open.mem_nhds hu hx.2) ((unique_diff_within_at_inter (is_open.mem_nhds hu hx.2)).1 (hs x hx)), ext m, rw [iterated_fderiv_within_succ_apply_left, iterated_fderiv_within_succ_apply_left, A, B] }
have B : fderiv_within 𝕜 (λ y, iterated_fderiv_within 𝕜 n f s y) (s ∩ u) x = fderiv_within 𝕜 (λ y, iterated_fderiv_within 𝕜 n f s y) s x := fderiv_within_inter (is_open.mem_nhds hu hx.2) ((unique_diff_within_at_inter (is_open.mem_nhds hu hx.2)).1 (hs x hx))
ext m
rw [iterated_fderiv_within_succ_apply_left, iterated_fderiv_within_succ_apply_left, A, B]
intros
apply linear_isometry.re_apply_eq_re_of_add_conj_eq
intro z
apply linear_isometry.im_apply_eq_im h
intros
intros x y hx hy a b ha hb hab
rw [mem_preimage, f.map_add, f.map_smul, f.map_smul]
exact hs hx hy ha hb hab
intros
simp only [metric.bounded_iff_ediam_ne_top, convex_hull_ediam]
intros
simp_rw [sum_inner, inner_sum, real_inner_smul_left, real_inner_smul_right, real_inner_eq_norm_mul_self_add_norm_mul_self_sub_norm_sub_mul_self_div_two, ←div_sub_div_same, ←div_add_div_same, mul_sub_left_distrib, left_distrib, finset.sum_sub_distrib, finset.sum_add_distrib, ←finset.mul_sum, ←finset.sum_mul, h₁, h₂, zero_mul, mul_zero, finset.sum_const_zero, zero_add, zero_sub, finset.mul_sum, neg_div, finset.sum_div, mul_div_assoc, mul_assoc]
intros
simp
intros
{ have h := @norm_add_sq ℝ F _ _, simpa using h }
have h := @norm_add_sq ℝ F _ _
simpa using h
intros
rw [to_euclidean.image_symm_eq_preimage, closed_ball_eq_preimage]
intros
ext1
simp [explicit_cokernel_desc, explicit_cokernel_π, explicit_cokernel_iso]
intros
{ ext, refl }
ext
refl
intros
simpa only [nnreal.coe_nat_cast, nnreal.coe_add] using congr_arg (coe : _ → ℝ) (to_nat_add_to_nat_neg_eq_nnnorm n)
intros
{ erw add_monoid_hom.map_range, refl }
erw add_monoid_hom.map_range
refl
intros
have : 0 ≤ ∥mk' S m∥ := norm_mk_nonneg S m
rw [← this.le_iff_eq, quotient_norm_mk_eq, real.Inf_le_iff]
simp_rw [zero_add]
calc (∀ ε > (0 : ℝ), ∃ r ∈ (λ x, ∥m + x∥) '' (S : set M), r < ε) ↔ (∀ ε > 0, (∃ x ∈ S, ∥m + x∥ < ε)) : by simp [set.bex_image_iff] ... ↔ ∀ ε > 0, (∃ x ∈ S, ∥m + -x∥ < ε) : _ ... ↔ ∀ ε > 0, (∃ x ∈ S, x ∈ metric.ball m ε) : by simp [dist_eq_norm, ← sub_eq_add_neg, norm_sub_rev] ... ↔ m ∈ closure ↑S : by simp [metric.mem_closure_iff, dist_comm]
{ calc (∀ ε > (0 : ℝ), ∃ r ∈ (λ x, ∥m + x∥) '' (S : set M), r < ε) ↔ (∀ ε > 0, (∃ x ∈ S, ∥m + x∥ < ε)) : by simp [set.bex_image_iff] ... ↔ ∀ ε > 0, (∃ x ∈ S, ∥m + -x∥ < ε) : _ ... ↔ ∀ ε > 0, (∃ x ∈ S, x ∈ metric.ball m ε) : by simp [dist_eq_norm, ← sub_eq_add_neg, norm_sub_rev] ... ↔ m ∈ closure ↑S : by simp [metric.mem_closure_iff, dist_comm], apply forall_congr, intro ε, apply forall_congr, intro ε_pos, rw [← S.exists_neg_mem_iff_exists_mem], simp }
apply forall_congr
intro ε
apply forall_congr
intro ε_pos
rw [← S.exists_neg_mem_iff_exists_mem]
simp
use 0
{ use 0, rintro _ ⟨x, x_in, rfl⟩, apply norm_nonneg }
rintro _ ⟨x, x_in, rfl⟩
apply norm_nonneg
rw set.nonempty_image_iff
use [0, S.zero_mem]
intros
simp [to_span_singleton, of_homothety, linear_map.to_span_singleton]
intros
{ refine symm (e.tsum_eq_iff.mpr _), rw e.symm_apply_apply _ }
refine symm (e.tsum_eq_iff.mpr _)
rw e.symm_apply_apply _
intros
refine continuous.le_induced _
apply continuous_pi_iff.mpr
intros z
exact (inclusion_in_double_dual 𝕜 E z).continuous
intros
rw [←neg_sub, p.neg]
simp [log]
intros
{ rw ← log_one, exact log_lt_log_iff h zero_lt_one }
rw ← log_one
exact log_lt_log_iff h zero_lt_one
intros
simp only [one_div, integral_inv_of_pos ha hb]
intros
rw filter.tendsto_at_top_at_top
intros b
obtain ⟨c, hc⟩ := tendsto_at_top_at_top.mp (tendsto_rpow_at_top hy) b
use c.to_nnreal
intros a ha
exact_mod_cast hc a (real.to_nnreal_le_iff_le_coe.mp ha)
intros
rw [rpow_def_of_nonneg (le_of_lt hx), if_neg (ne_of_gt hx)]
intros
rw [← abs_sin_eq_sqrt_one_sub_cos_sq, abs_of_nonneg (sin_nonneg_of_nonneg_of_le_pi hl hu)]
rw [← of_real_sin, real.sin_pi]; simp
rw [← of_real_sin, real.sin_pi]
simp
intros
rw [tan_add h, tan_mul_I, mul_assoc]
intros
refine (is_o.of_norm_left _).of_norm_right
exact (is_o_pow_pow_of_lt_left (abs_nonneg r₁) h).congr (pow_abs r₁) (pow_abs r₂)
intros
rcases sign_cases_of_C_mul_pow_nonneg (λ n, dist_nonneg.trans (hu n)) with rfl | ⟨C₀, r₀⟩
{ simp [has_sum_zero] }
simp [has_sum_zero]
refine has_sum.mul_left C _
{ refine has_sum.mul_left C _, simpa using has_sum_geometric_of_lt_1 r₀ hr }
simpa using has_sum_geometric_of_lt_1 r₀ hr
intros
ext
ext; refl
refl
intros
rw w
intros
rw [← trans_assoc, self_symm_id, refl_trans]
intros
cases α; refl
cases α
refl
intros
obviously
intros
apply is_colimit.fac
intros
rw ←cone_of_hom_of_cone h s
conv_lhs { simp only [hom_of_cone_of_hom] }
apply (cone_of_hom_fac _ _).symm
intros
rw [iso.inv_comp_eq, ← category.assoc, iso.eq_comp_inv, prod.left_unitor_hom_naturality]
intros
rw biproduct.map_eq_map'
convert limits.is_colimit.ι_map _ _ _ _
convert limits.is_colimit.ι_map _ _ _ _; refl
refl
refl
refl
refl
refl
refl
refl
refl
refl
refl
intros
{ ext, simp [image.eq_to_iso, image.eq_to_hom], }
ext
simp [image.eq_to_iso, image.eq_to_hom]
intros
{ ext, simp [kernel_zero_iso_source], }
ext
simp [kernel_zero_iso_source]
intros
haveI := t.split_epi_to f; apply_instance
haveI := t.split_epi_to f
apply_instance
intros
rw [t.app_one, t.app_one]
intros
simp only [right_unitor_tensor_inv, category.comp_id, iso.inv_hom_id, category.assoc]
intros
induction g with Y' Z' g e ih
{ simp, }
simp
{ simp [ih], }
simp [ih]
intros
{ rw ←(nat_iso.naturality_1 (lift.is_lift r F H)), dsimp, simp, }
rw ←(nat_iso.naturality_1 (lift.is_lift r F H))
dsimp
simp
intros
split
intro h
{ intro h, apply J₁.transitive (J₁.top_mem X), intros Y f hf, change J₁.close S f, rwa h }
apply J₁.transitive (J₁.top_mem X)
intros Y f hf
change J₁.close S f
rwa h
intro hS
{ intro hS, rw eq_top_iff, intros Y f hf, apply J₁.pullback_stable _ hS }
rw eq_top_iff
intros Y f hf
apply J₁.pullback_stable _ hS
intros
split
intros t Y₁ Y₂ f₁ f₂ hf₁ hf₂
{ intros t Y₁ Y₂ f₁ f₂ hf₁ hf₂, apply t, apply pullback.condition }
apply t
apply pullback.condition
intros t Y₁ Y₂ Z g₁ g₂ f₁ f₂ hf₁ hf₂ comm
{ intros t Y₁ Y₂ Z g₁ g₂ f₁ f₂ hf₁ hf₂ comm, rw [←pullback.lift_fst _ _ comm, op_comp, functor_to_types.map_comp_apply, t hf₁ hf₂, ←functor_to_types.map_comp_apply, ←op_comp, pullback.lift_snd] }
rw [←pullback.lift_fst _ _ comm, op_comp, functor_to_types.map_comp_apply, t hf₁ hf₂, ←functor_to_types.map_comp_apply, ←op_comp, pullback.lift_snd]
intros
refine (not_congr eq_ones_iff).trans _
have : ∀ j ∈ c.blocks, j = 1 ↔ j ≤ 1 := λ j hj, by simp [le_antisymm_iff, c.one_le_blocks hj]
simp [this] {contextual := tt}
intros
simp [remove_none.fiber, derangements]
intros
haveI := classical.dec_eq ι
specialize ha (s'.image coe)
rw [nonempty.image_iff, finset.card_image_of_injective s' subtype.coe_injective] at ha
by_cases he : s'.nonempty
have ha' : s'.card < (s'.bUnion (λ x, t x)).card
{ have ha' : s'.card < (s'.bUnion (λ x, t x)).card, { specialize ha he (λ h, by { have h' := mem_univ x, rw ←h at h', simpa using h' }), convert ha using 2, ext x, simp only [mem_image, mem_bUnion, exists_prop, set_coe.exists, exists_and_distrib_right, exists_eq_right, subtype.coe_mk], }, rw ←erase_bUnion, by_cases hb : a ∈ s'.bUnion (λ x, t x), { rw card_erase_of_mem hb, exact nat.le_pred_of_lt ha' }, { rw erase_eq_of_not_mem hb, exact nat.le_of_lt ha' }, }
specialize ha he (λ h, by { have h' := mem_univ x, rw ←h at h', simpa using h' })
{ specialize ha he (λ h, by { have h' := mem_univ x, rw ←h at h', simpa using h' }), convert ha using 2, ext x, simp only [mem_image, mem_bUnion, exists_prop, set_coe.exists, exists_and_distrib_right, exists_eq_right, subtype.coe_mk], }
convert ha using 2
ext x
simp only [mem_image, mem_bUnion, exists_prop, set_coe.exists, exists_and_distrib_right, exists_eq_right, subtype.coe_mk]
rw ←erase_bUnion
by_cases hb : a ∈ s'.bUnion (λ x, t x)
rw card_erase_of_mem hb
{ rw card_erase_of_mem hb, exact nat.le_pred_of_lt ha' }
exact nat.le_pred_of_lt ha'
rw erase_eq_of_not_mem hb
{ rw erase_eq_of_not_mem hb, exact nat.le_of_lt ha' }
exact nat.le_of_lt ha'
rw [nonempty_iff_ne_empty, not_not] at he
{ rw [nonempty_iff_ne_empty, not_not] at he, subst s', simp }
subst s'
simp
intros
simp [hd v]
intros
obtain ⟨t, ht⟩ := max_of_nonempty (univ_nonempty.image (λ v, G.degree v))
have ht₂ := mem_of_max ht
simp only [mem_image, mem_univ, exists_prop_of_true] at ht₂
rcases ht₂ with ⟨v, rfl⟩
rw option.mem_def at ht
refine ⟨v, _⟩
rw [max_degree, ht]
refl
intros
obtain ⟨_, a, b, c, hx, hlen, hnil, rfl, hb, hc⟩ := M.eval_from_split hlen rfl
use [a, b, c, hx, hlen, hnil]
intros y hy
rw language.mem_mul at hy
rcases hy with ⟨ ab, c', hab, hc', rfl ⟩
rw language.mem_mul at hab
rcases hab with ⟨ a', b', ha', hb', rfl ⟩
rw set.mem_singleton_iff at ha' hc'
substs ha' hc'
have h := M.eval_from_of_pow hb hb'
rwa [mem_accepts, eval_from_of_append, eval_from_of_append, h, hc]
intros
simp [of, quotient.eq']
intros
rcases v with _|⟨_|n, v⟩
{ refine ⟨none, trans_gen.single _⟩, simp, refl }
refine ⟨none, trans_gen.single _⟩
simp
refl
{ refine ⟨some Γ'.cons, trans_gen.single _⟩, simp, refl }
refine ⟨some Γ'.cons, trans_gen.single _⟩
simp
refl
refine ⟨none, _⟩
simp [tr_nat, num.add_one, num.succ, tr_num]
cases (n:num) with a
simp [tr_pos_num, tr_num, show num.zero.succ' = pos_num.one, from rfl]
{ simp [tr_pos_num, tr_num, show num.zero.succ' = pos_num.one, from rfl], refine trans_gen.head rfl _, convert unrev_ok, simp, refl }
refine trans_gen.head rfl _
convert unrev_ok
simp
refl
simp [tr_num, num.succ']
suffices : ∀ l₁, ∃ l₁' l₂' s', list.reverse_core l₁ (tr_pos_num a) = list.reverse_core l₁' l₂' ∧ reaches₁ (TM2.step tr) ⟨some (q₁.pred q₂), s, K'.elim (tr_pos_num a.succ ++ Γ'.cons :: tr_list v) l₁ c d⟩ ⟨some (unrev q₂), s', K'.elim (l₂' ++ Γ'.cons :: tr_list v) l₁' c d⟩
obtain ⟨l₁', l₂', s', e, h⟩ := this []
{ obtain ⟨l₁', l₂', s', e, h⟩ := this [], simp [list.reverse_core] at e, refine h.trans _, convert unrev_ok using 2, simp [e, list.reverse_core_eq] }
simp [list.reverse_core] at e
refine h.trans _
convert unrev_ok using 2
simp [e, list.reverse_core_eq]
induction a with m IH m IH generalizing s
induction a with m IH m IH generalizing s; intro l₁
intro l₁
refine ⟨Γ'.bit1 :: l₁, [], some Γ'.cons, rfl, trans_gen.head rfl (trans_gen.single _)⟩
{ refine ⟨Γ'.bit1 :: l₁, [], some Γ'.cons, rfl, trans_gen.head rfl (trans_gen.single _)⟩, simp [tr_pos_num, show pos_num.one.succ = pos_num.one.bit0, from rfl], refl }
simp [tr_pos_num, show pos_num.one.succ = pos_num.one.bit0, from rfl]
refl
intro l₁
obtain ⟨l₁', l₂', s', e, h⟩ := IH (some Γ'.bit0) (Γ'.bit1 :: l₁)
{ obtain ⟨l₁', l₂', s', e, h⟩ := IH (some Γ'.bit0) (Γ'.bit1 :: l₁), refine ⟨l₁', l₂', s', e, trans_gen.head _ h⟩, simp, refl }
refine ⟨l₁', l₂', s', e, trans_gen.head _ h⟩
simp
refl
intro l₁
obtain ⟨a, l, e, h⟩ : ∃ a l, tr_pos_num m = a :: l ∧ nat_end a = ff
{ obtain ⟨a, l, e, h⟩ : ∃ a l, tr_pos_num m = a :: l ∧ nat_end a = ff, { cases m; refine ⟨_, _, rfl, rfl⟩ }, refine ⟨Γ'.bit0 :: l₁, _, some a, rfl, trans_gen.single _⟩, simp [tr_pos_num, pos_num.succ, e, h, nat_end, show some Γ'.bit1 ≠ some Γ'.bit0, from dec_trivial] }
cases m; refine ⟨_, _, rfl, rfl⟩
{ cases m; refine ⟨_, _, rfl, rfl⟩ }
cases m
refine ⟨_, _, rfl, rfl⟩
refine ⟨_, _, rfl, rfl⟩
refine ⟨_, _, rfl, rfl⟩
refine ⟨Γ'.bit0 :: l₁, _, some a, rfl, trans_gen.single _⟩
simp [tr_pos_num, pos_num.succ, e, h, nat_end, show some Γ'.bit1 ≠ some Γ'.bit0, from dec_trivial]
intros
simp [snd,bimap_bimap]
intros
simp [equiv.traverse, traverse_eq_map_id] with functor_norm
simp [equiv.traverse, traverse_eq_map_id] with functor_norm; refl
refl
intros
induction i; simp [*, d_array.iterate_aux]
induction i
simp [*, d_array.iterate_aux]
simp [*, d_array.iterate_aux]
intros
cases b
rw [to_list, to_array, list.to_buffer, append_list_mk_buffer]
congr
{ simpa }
simpa
{ apply array.to_list_to_array }
apply array.to_list_to_array
introI
have : eof buffer.nil 0 = done 0 () := by simp [eof_eq_done]
exact absurd (bounded.of_done this) (lt_irrefl _)
intros
obtain ⟨np, a, hp⟩ := p.exists_done_in_bounds hn
simpa [hp] using h
introI h
have : remaining buffer.nil 0 = done 0 0 := by simp [remaining_eq_done]
replace this : 0 < 0 := prog.of_done this
exact (lt_irrefl _) this
intros
simp [mmap']
intros
simp [foldr_core, and.comm, and.assoc, pure_eq_done]
intros
simp only [add_conj, of_real_mul, of_real_one, of_real_bit0, mul_div_cancel_left (z.re:ℂ) two_ne_zero']
intros
rw ← of_real_inj; simp [sinh_add_cosh]
rw ← of_real_inj
simp [sinh_add_cosh]
intros
simp [sub_eq_add_neg, cosh_add, sinh_neg, cosh_neg]
intros
rw [← cosh_mul_I, add_mul, cosh_add, cosh_mul_I, cosh_mul_I, sinh_mul_I, sinh_mul_I, mul_mul_mul_comm, I_mul_I, mul_neg_one, sub_eq_add_neg]
intros
have h1 : x + 2 * x = 3 * x
ring
ring
rw [← h1, sin_add x (2 * x)]
simp only [cos_two_mul, sin_two_mul, cos_sq']
have h2 : cos x * (2 * sin x * cos x) = 2 * sin x * cos x ^ 2
ring
ring
rw [h2, cos_sq']
ring
intros
{ simp_rw ext_iff, cc }
simp_rw ext_iff
cc
intros
{ rw [norm_sq_eq_def'], simp [sq] }
rw [norm_sq_eq_def']
simp [sq]
intros
simp
intros
rw [←single_zero i, single_eq_single_iff]
simp
intros
simp [set.subset_def]; exact forall_congr (assume i, not_imp_comm)
simp [set.subset_def]
exact forall_congr (assume i, not_imp_comm)
intros
apply equiv.forall₂_congr
intros
apply equiv.forall_congr
intros
apply h
funext; simp
funext
simp
intros
rw equiv.perm.via_fintype_embedding
convert equiv.perm.extend_domain_apply_image e _ _
intros
simp [map]
intros
rw pred_above_last
intros
{ ext j, simp [init] }
ext j
simp [init]
intros
split
assume H i hi
{ assume H i hi, apply H, exact nat.lt_succ_self _ }
apply H
exact nat.lt_succ_self _
assume H
{ assume H, have A : ∀ i j (h : i < j) (h' : j < n), f ⟨i, lt_trans h h'⟩ < f ⟨j, h'⟩, { assume i j h h', induction h with k h IH, { exact H _ _ }, { exact lt_trans (IH (nat.lt_of_succ_lt h')) (H _ _) } }, assume i j hij, convert A (i : ℕ) (j : ℕ) hij j.2; ext; simp only [subtype.coe_eta] }
have A : ∀ i j (h : i < j) (h' : j < n), f ⟨i, lt_trans h h'⟩ < f ⟨j, h'⟩
assume i j h h'
{ assume i j h h', induction h with k h IH, { exact H _ _ }, { exact lt_trans (IH (nat.lt_of_succ_lt h')) (H _ _) } }
induction h with k h IH
{ exact H _ _ }
exact H _ _
{ exact lt_trans (IH (nat.lt_of_succ_lt h')) (H _ _) }
exact lt_trans (IH (nat.lt_of_succ_lt h')) (H _ _)
assume i j hij
convert A (i : ℕ) (j : ℕ) hij j.2; ext; simp only [subtype.coe_eta]
convert A (i : ℕ) (j : ℕ) hij j.2; ext
convert A (i : ℕ) (j : ℕ) hij j.2
ext
simp only [subtype.coe_eta]
ext
simp only [subtype.coe_eta]
intros
rw [← coe_inj, coe_insert, coe_sdiff, coe_sdiff, coe_insert]
exact set.insert_diff_of_not_mem s h
intros
{ rw card_le_one, tauto }
rw card_le_one
tauto
intros
{ ext, simp }
ext
simp
intros
rw ←with_bot.coe_eq_coe
{ rw ←with_bot.coe_eq_coe, simp only [coe_sup', sup_insert, with_bot.coe_sup], }
simp only [coe_sup', sup_insert, with_bot.coe_sup]
intros
refine le_antisymm (min'_le _ _ (mem_image.mpr ⟨_, min'_mem _ _, rfl⟩)) (le_min' _ _ _ (λ y hy, _))
obtain ⟨x, hx, rfl⟩ := mem_image.mp hy
exact hf (min'_le _ _ hx)
intros
simp [noncomm_prod, multiset.singleton_eq_cons]
intros
ext a
by_cases a ∈ set.range f
rcases h with ⟨a, rfl⟩
{ rcases h with ⟨a, rfl⟩, rw [map_domain_apply f.injective, emb_domain_apply] }
rw [map_domain_apply f.injective, emb_domain_apply]
rw [map_domain_notin_range, emb_domain_notin_range]; assumption
rw [map_domain_notin_range, emb_domain_notin_range]
{ rw [map_domain_notin_range, emb_domain_notin_range]; assumption }
assumption
assumption
assumption
assumption
intros
change map_domain f (map_range _ _ _) = map_range _ _ _
apply finsupp.induction v
simp only [map_domain_zero, map_range_zero]
{ simp only [map_domain_zero, map_range_zero] }
intros a b v' hv₁ hv₂ IH
rw [map_range_add, map_domain_add, IH, map_domain_add, map_range_add, map_range_single, map_domain_single, map_domain_single, map_range_single]
rw [map_range_add, map_domain_add, IH, map_domain_add, map_range_add, map_range_single, map_domain_single, map_domain_single, map_range_single]; apply smul_add
apply smul_add
apply smul_add
apply smul_add
apply smul_add
intros
simp only [card_eq_one, support_eq_singleton]
intros
haveI : nontrivial α := one_lt_card_iff_nontrivial.1 h
{ haveI : nontrivial α := one_lt_card_iff_nontrivial.1 h, exact exists_pair_ne α }
exact exists_pair_ne α
intros
have nd := v.nodup (mk_idx n (hash_fn a))
rcases hash_map.valid.replace_aux a b (array.read bkts (mk_idx n (hash_fn a))) ((contains_aux_iff nd).1 Hc) with ⟨u, w, b', hl, hfl⟩
simp [hl, list.nodup_append] at nd
refine (v.modify hash_fn u [⟨a, b'⟩] [⟨a, b⟩] w hl hfl (list.nodup_singleton _) (λa' e, by simp at e; rw e) (λa' e1 e2, _) (λa' e1 e2, _)).2
refine (v.modify hash_fn u [⟨a, b'⟩] [⟨a, b⟩] w hl hfl (list.nodup_singleton _) (λa' e, by simp at e; rw e) (λa' e1 e2, _) (λa' e1 e2, _)).2; { revert e1, simp [-sigma.exists] at e2, subst a', simp [nd] }
{ revert e1, simp [-sigma.exists] at e2, subst a', simp [nd] }
revert e1
{ revert e1, simp [-sigma.exists] at e2, subst a', simp [nd] }
simp [-sigma.exists] at e2
subst a'
simp [nd]
intros
rw [←units.coe_mul, units_mul_self, units.coe_one]
intros
have := mul_mod_left 1 a; rwa one_mul at this
have := mul_mod_left 1 a
rwa one_mul at this
intros
rw [← H2, int.mul_div_cancel' H1]
intros
rw [gcd_comm, gcd_eq_left H]
intros
rcases least_of_bdd b Hb Hinh with ⟨n, hn, h2n⟩
rcases least_of_bdd b' Hb' Hinh with ⟨n', hn', h2n'⟩
exact le_antisymm (h2n _ hn') (h2n' _ hn)
intros
convert not_even_bit1 n; exact two_mul n
convert not_even_bit1 n
exact two_mul n
intros
rw [sqrt, ← nat_abs_mul_self, to_nat_coe_nat, nat.sqrt_eq]
intros
cases l₂
simp only [bag_inter_nil]
{simp only [bag_inter_nil]}
simp only [erase_of_not_mem h, list.bag_inter, if_neg h]
intros
refine ⟨_, map_congr⟩
intros h x hx
rw [mem_iff_nth_le] at hx
rcases hx with ⟨n, hn, rfl⟩
rw [nth_le_map_rev f, nth_le_map_rev g]
congr
exact h
intros
induction l with hd tl hl generalizing n
{ simp }
simp
cases n
{ cases n, { simp }, { simp [hl] } }
{ simp }
simp
{ simp [hl] }
simp [hl]
intros
induction l generalizing a
{ simp }
simp
simp [l_ih, h]
{ simp [l_ih, h] }
intros
induction l with y l IH
{ simp }
simp
specialize IH (λ x hx, h x (mem_cons_of_mem _ hx))
{ specialize IH (λ x hx, h x (mem_cons_of_mem _ hx)), have hy : y ≤ n := h y (mem_cons_self _ _), simpa [pow_succ] using mul_le_mul' hy IH }
have hy : y ≤ n := h y (mem_cons_self _ _)
simpa [pow_succ] using mul_le_mul' hy IH
intros
rw [attach, map_pmap]; exact (pmap_eq_map _ _ _ _).trans (map_id l)
rw [attach, map_pmap]
exact (pmap_eq_map _ _ _ _).trans (map_id l)
intros
induction l with hd tl hl
{ simp only [reduce_option_nil, length] }
simp only [reduce_option_nil, length]
cases hd
{ cases hd, { exact nat.le_succ_of_le hl }, { simpa only [length, add_le_add_iff_right, reduce_option_cons_of_some] using hl} }
{ exact nat.le_succ_of_le hl }
exact nat.le_succ_of_le hl
simpa only [length, add_le_add_iff_right, reduce_option_cons_of_some] using hl
{ simpa only [length, add_le_add_iff_right, reduce_option_cons_of_some] using hl}
intros
rw [count, countp_eq_length_filter, filter_eq_self.2, length_repeat]
rw [count, countp_eq_length_filter, filter_eq_self.2, length_repeat]; exact λ b m, (eq_of_mem_repeat m).symm
exact λ b m, (eq_of_mem_repeat m).symm
intros
obtain ⟨xs, rfl⟩ := h
rw filter_append
exact suffix_append _ _
intros
rw [permutations, permutations_aux_nil]
intros
simp [erase_eq_erasep]; exact sublist.erasep h
simp [erase_eq_erasep]
exact sublist.erasep h
intros
cases l; [trivial, exact p.imp H]
cases l
trivial
exact p.imp H
intros
convert (prev_reverse_eq_next l.reverse (nodup_reverse.mpr h) x (mem_reverse.mpr hx)).symm
exact (reverse_reverse l).symm
intros
induction h with l' h z l' h hm
{ simp [ne_nil_of_mem h] }
simp [ne_nil_of_mem h]
{ simp [ne_nil_of_mem h.mem] }
simp [ne_nil_of_mem h.mem]
intros
rw [← append_consecutive (nat.le_succ n) h, succ_singleton]
rw [← append_consecutive (nat.le_succ n) h, succ_singleton]; refl
refl
intros
induction t generalizing l₁ l₂ h; simp [*, perm.erase]
induction t generalizing l₁ l₂ h
simp [*, perm.erase]
simp [*, perm.erase]
intros
rw [range_eq_range', map_add_range']; refl
rw [range_eq_range', map_add_range']
refl
intros
refine ⟨λ h, _, λ h, _⟩
induction L generalizing f
{ induction L generalizing f, {cases mem_singleton.1 h, exact forall₂.nil}, simp only [sections, bind_eq_bind, mem_bind, mem_map] at h, rcases h with ⟨_, _, _, _, rfl⟩, simp only [*, forall₂_cons, true_and] }
cases mem_singleton.1 h
{cases mem_singleton.1 h, exact forall₂.nil}
exact forall₂.nil
simp only [sections, bind_eq_bind, mem_bind, mem_map] at h
rcases h with ⟨_, _, _, _, rfl⟩
simp only [*, forall₂_cons, true_and]
induction h with a l f L al fL fs
{ induction h with a l f L al fL fs, {exact or.inl rfl}, simp only [sections, bind_eq_bind, mem_bind, mem_map], exact ⟨_, fs, _, al, rfl, rfl⟩ }
exact or.inl rfl
{exact or.inl rfl}
simp only [sections, bind_eq_bind, mem_bind, mem_map]
exact ⟨_, fs, _, al, rfl, rfl⟩
intros
induction l₁ generalizing l₂ i
{ simp [zip_with, (<*>)] }
simp [zip_with, (<*>)]
cases l₂; simp only [zip_with, has_seq.seq, functor.map, nth, option.map_none']
cases l₂
{ cases l₂; simp only [zip_with, has_seq.seq, functor.map, nth, option.map_none'], { cases ((l₁_hd :: l₁_tl).nth i); refl }, { cases i; simp only [option.map_some', nth, option.some_bind', *] } }
simp only [zip_with, has_seq.seq, functor.map, nth, option.map_none']
cases ((l₁_hd :: l₁_tl).nth i); refl
{ cases ((l₁_hd :: l₁_tl).nth i); refl }
cases ((l₁_hd :: l₁_tl).nth i)
refl
refl
simp only [zip_with, has_seq.seq, functor.map, nth, option.map_none']
cases i; simp only [option.map_some', nth, option.some_bind', *]
{ cases i; simp only [option.map_some', nth, option.some_bind', *] }
cases i
simp only [option.map_some', nth, option.some_bind', *]
simp only [option.map_some', nth, option.some_bind', *]
intros
{ ext, apply dot_product_smul }
ext
apply dot_product_smul
intros
ext
{ext, refl}
refl
intros
simp [bit1_apply, h]
intros
{ unfold std_basis_matrix, ext, simp }
unfold std_basis_matrix
ext
simp
intros
ext
simp only [block_diagonal'_apply, pi.neg_apply]
split_ifs; simp
split_ifs
simp
simp
intros
ext i
simp_rw [vec_alt0]
rcases i with ⟨⟨⟩ | i, hi⟩
{ refl }
refl
{ simp [vec_alt0, nat.add_succ, nat.succ_add] }
simp [vec_alt0, nat.add_succ, nat.succ_add]
intros
dsimp [to_matrix, matrix.mul_apply]
cases h : f i with fi
{ simp [h] }
simp [h]
rw finset.sum_eq_single fi; simp [h, eq_comm] {contextual := tt}
rw finset.sum_eq_single fi
{ rw finset.sum_eq_single fi; simp [h, eq_comm] {contextual := tt} }
simp [h, eq_comm] {contextual := tt}
simp [h, eq_comm] {contextual := tt}
simp [h, eq_comm] {contextual := tt}
intros
haveI : decidable_eq α := classical.dec_eq α
split
assume eq
{ assume eq, by_cases a = b, { subst h, simp * at * }, { have : a ∈ b ::ₘ bs, from eq ▸ mem_cons_self _ _, have : a ∈ bs, by simpa [h], rcases exists_cons_of_mem this with ⟨cs, hcs⟩, simp [h, hcs], have : a ::ₘ as = b ::ₘ a ::ₘ cs, by simp [eq, hcs], have : a ::ₘ as = a ::ₘ b ::ₘ cs, by rwa [cons_swap], simpa using this } }
by_cases a = b
{ subst h, simp * at * }
subst h
simp * at *
have : a ∈ b ::ₘ bs
{ have : a ∈ b ::ₘ bs, from eq ▸ mem_cons_self _ _, have : a ∈ bs, by simpa [h], rcases exists_cons_of_mem this with ⟨cs, hcs⟩, simp [h, hcs], have : a ::ₘ as = b ::ₘ a ::ₘ cs, by simp [eq, hcs], have : a ::ₘ as = a ::ₘ b ::ₘ cs, by rwa [cons_swap], simpa using this }
from eq ▸ mem_cons_self _ _
have : a ∈ bs
simpa [h]
simpa [h]
rcases exists_cons_of_mem this with ⟨cs, hcs⟩
simp [h, hcs]
have : a ::ₘ as = b ::ₘ a ::ₘ cs
simp [eq, hcs]
simp [eq, hcs]
have : a ::ₘ as = a ::ₘ b ::ₘ cs
rwa [cons_swap]
rwa [cons_swap]
simpa using this
assume h
{ assume h, rcases h with ⟨eq₁, eq₂⟩ | ⟨h, cs, eq₁, eq₂⟩, { simp * }, { simp [*, cons_swap a b] } }
rcases h with ⟨eq₁, eq₂⟩ | ⟨h, cs, eq₁, eq₂⟩
{ simp * }
simp *
{ simp [*, cons_swap a b] }
simp [*, cons_swap a b]
intros
rw [← rel_flip, rel_add_left]; simp [rel_flip]
rw [← rel_flip, rel_add_left]
simp [rel_flip]
intros
refine ⟨_, λ h, le_trans h $ le_cons_self _ _⟩
suffices : ∀ {t'} (_ : s ≤ t') (_ : a ∈ t'), a ::ₘ s ≤ t'
exact λ h, (cons_le_cons_iff a).1 (this h (mem_cons_self _ _))
{ exact λ h, (cons_le_cons_iff a).1 (this h (mem_cons_self _ _)) }
introv h
revert m
refine le_induction_on h _
introv s m₁ m₂
rcases mem_split m₂ with ⟨r₁, r₂, rfl⟩
exact perm_middle.subperm_left.2 ((subperm_cons _).2 $ ((sublist_or_mem_of_sublist s).resolve_right m₁).subperm)
intros
rw foldl_swap
exact foldr_induction' (λ x y, f y x) (λ x y z, (H _ _ _).symm) x q p s hpqf px q_s
intros
rw [fold_cons'_right, hc.comm]
intros
apply mv_polynomial.induction_on p; { simp { contextual := tt } }
apply mv_polynomial.induction_on p
{ apply mv_polynomial.induction_on p; { simp { contextual := tt } } }
{ simp { contextual := tt } }
{ simp { contextual := tt } }
simp { contextual := tt }
{ simp { contextual := tt } }
intros
{ rw [hom_bind₁, map_comp_C, ← eval₂_hom_map_hom], refl }
rw [hom_bind₁, map_comp_C, ← eval₂_hom_map_hom]
refl
intros
{ contrapose! h, apply coeff_rename_eq_zero _ _ _ h }
contrapose! h
apply coeff_rename_eq_zero _ _ _ h
intros
rw [succ_div, if_pos hba]
intros
simp only [add_comm, add_one_le_iff]
intros
induction hnm with m hnm ih
intros x
{ intros x, use x, rw le_rec_on_self }
use x
rw le_rec_on_self
intros x
rcases Hnext _ x with ⟨w, rfl⟩
rcases ih w with ⟨x, rfl⟩
use x
rw le_rec_on_succ
intros
rw [← cast_zero, cast_lt]
intros
apply choose_symm_of_eq_add
{ apply choose_symm_of_eq_add, rw [add_comm m 1, add_assoc 1 m m, add_comm (2 * m) 1, two_mul m] }
rw [add_comm m 1, add_assoc 1 m m, add_comm (2 * m) 1, two_mul m]
intros
simp_rw [finset.nat.sum_antidiagonal_eq_sum_range_succ (λ m p, choose n m • (x^m * y^p)), _root_.nsmul_eq_mul, cast_comm, h.add_pow]
intros
rw ← with_top_equiv_le; simp
rw ← with_top_equiv_le
simp
intros
rcases (prod_dvd_and_dvd_of_dvd_prod $ gcd_dvd_right k (m * n)) with ⟨⟨⟨m', hm'⟩, ⟨n', hn'⟩⟩, h⟩
replace h : gcd k (m * n) = m' * n' := h
rw h
have hm'n' : m' * n' ∣ k := h ▸ gcd_dvd_left _ _
apply mul_dvd_mul
have hm'k : m' ∣ k := (dvd_mul_right m' n').trans hm'n'
{ have hm'k : m' ∣ k := (dvd_mul_right m' n').trans hm'n', exact dvd_gcd hm'k hm' }
exact dvd_gcd hm'k hm'
have hn'k : n' ∣ k := (dvd_mul_left n' m').trans hm'n'
{ have hn'k : n' ∣ k := (dvd_mul_left n' m').trans hm'n', exact dvd_gcd hn'k hn' }
exact dvd_gcd hn'k hn'
intros
{ rw log, cases b; refl }
rw log
cases b
cases b; refl
refl
refl
intros
rw [even_add, even_iff_not_odd, even_iff_not_odd, not_iff_not]
intros
cases n
cases n; refl
refl
refl
refl
intros
induction fuel with fuel ih generalizing k
induction fuel with fuel ih generalizing k; rw [min_fac_aux, nat.min_fac_aux]
rw [min_fac_aux, nat.min_fac_aux]
{ rw if_pos, rwa [zero_add, nat.sqrt_lt] at h }
rw if_pos
rwa [zero_add, nat.sqrt_lt] at h
rw [min_fac_aux, nat.min_fac_aux]
rw [← mul_to_nat]
simp only [cast_lt, dvd_to_nat, ite_cast]
congr' 2
rw ih
rw ih; [congr, convert nat.lt_succ_of_lt h using 1]; simp only [_root_.bit1, _root_.bit0, cast_bit1, cast_succ, nat.succ_eq_add_one, add_assoc, add_left_comm]
rw ih; [congr, convert nat.lt_succ_of_lt h using 1]
congr
simp only [_root_.bit1, _root_.bit0, cast_bit1, cast_succ, nat.succ_eq_add_one, add_assoc, add_left_comm]
convert nat.lt_succ_of_lt h using 1
simp only [_root_.bit1, _root_.bit0, cast_bit1, cast_succ, nat.succ_eq_add_one, add_assoc, add_left_comm]
intros
cases x; simp
{ cases x; simp }
cases x
simp
simp
intros
induction l with ls ll lx lr IHll IHlr generalizing o₁ o₂ r
{ exact ⟨hr, (zero_add _).symm⟩ }
exact ⟨hr, (zero_add _).symm⟩
induction r with rs rl rx rr IHrl IHrr generalizing o₁ o₂
{ exact ⟨hl, rfl⟩ }
exact ⟨hl, rfl⟩
rw [merge_node]
split_ifs
cases IHrl (sep.imp $ λ x h, h.1) (hl.of_lt hr.1.1.to_nil $ sep.imp $ λ x h, h.2.1) hr.left with v e
{ cases IHrl (sep.imp $ λ x h, h.1) (hl.of_lt hr.1.1.to_nil $ sep.imp $ λ x h, h.2.1) hr.left with v e, exact valid'.merge_aux₁ hl hr h v e }
exact valid'.merge_aux₁ hl hr h v e
cases IHlr hl.right (hr.of_gt hl.1.2.to_nil sep.2.1) sep.2.2 with v e
{ cases IHlr hl.right (hr.of_gt hl.1.2.to_nil sep.2.1) sep.2.2 with v e, have := valid'.merge_aux₁ hr.dual hl.dual h_1 v.dual, rw [size_dual, add_comm, size_dual, ← dual_balance_r, ← valid'.dual_iff, size_dual, add_comm rs] at this, exact this e }
have := valid'.merge_aux₁ hr.dual hl.dual h_1 v.dual
rw [size_dual, add_comm, size_dual, ← dual_balance_r, ← valid'.dual_iff, size_dual, add_comm rs] at this
exact this e
refine valid'.glue_aux hl hr sep (or.inr ⟨not_lt.1 h_1, not_lt.1 h⟩)
{ refine valid'.glue_aux hl hr sep (or.inr ⟨not_lt.1 h_1, not_lt.1 h⟩) }
intros
rw [← size_dual, dual_rotate_r, hl.dual.rotate_l_size, size_dual, size_dual, add_comm (size l)]
intros
rw [add_comm, add_comm m]; exact H.add_left _
rw [add_comm, add_comm m]
exact H.add_left _
intros
ext
dsimp [single, pequiv.trans]
split_ifs; simp * at *
split_ifs
simp * at *
simp * at *
intros
ext i x; cases x; reflexivity
ext i x; cases x
ext i x
cases x
reflexivity
reflexivity
intros
rcases multiset.mem_map.mp h with ⟨⟨p', hp'⟩, ⟨h_mem, h_eq⟩⟩
{ rcases multiset.mem_map.mp h with ⟨⟨p', hp'⟩, ⟨h_mem, h_eq⟩⟩, exact h_eq ▸ hp' }
exact h_eq ▸ hp'
intros
dsimp [is_special, finish] at hs ⊢
rw [add_mul _ _ u.y, add_comm _ (u.x * u.y), ← hs]
ring
intros
rw [mul_assoc, X_pow_mul, ←mul_assoc]
intros
simp [sum_def, finset.sum_add_distrib]
intros
induction n with n ih
{ simp, }
simp
{ simp [ih], }
simp [ih]
intros
rw [C_mul_X_pow_eq_monomial, leading_coeff_monomial]
intros
simpa only [sub_eq_add_neg, degree_neg q] using degree_add_le p (-q)
intros
rw trailing_degree_eq_nat_trailing_degree hp at H
exact with_top.coe_le_coe.mp H
intros
ext i
simp only [erase_lead_coeff, coeff_monomial, coeff_add, @eq_comm _ _ i]
split_ifs with h
{ subst i, simp only [leading_coeff, zero_add] }
subst i
simp only [leading_coeff, zero_add]
{ exact add_zero _ }
exact add_zero _
intros
simp only [comp, eval₂, ← monomial_eq_C_mul_X]
exact sum_monomial_eq _
intros
simp
intros
simp only [lifts, lifts_ring, ring_hom.mem_range, ring_hom.mem_srange]
intros
rw [nat_degree_mul', add_comm]
simpa [hp.leading_coeff, leading_coeff_ne_zero]
intros
rw [monic, leading_coeff_mul' _]; simp [leading_coeff_C b, hp]
rw [monic, leading_coeff_mul' _]
simp [leading_coeff_C b, hp]
simp [leading_coeff_C b, hp]
intros
intros a b hab
rw [← @rev_at_fun_invol N a, hab, rev_at_fun_invol]
intros
rw [nth_roots, mem_roots (X_pow_sub_C_ne_zero hn a), is_root.def, eval_sub, eval_C, eval_pow, eval_X, sub_eq_zero]
intros
rw [taylor_eval, sub_add_cancel]
intros
rw [← cofix.mk_dest x,h,cofix.mk_dest]
intros
rw ←abs_repr x
{ rw ←abs_repr x, cases repr x with a f, rw [←abs_map], reflexivity }
cases repr x with a f
rw [←abs_map]
reflexivity
intros
apply and.intro
rw [← (num_div_eq_of_coprime hb0 h1), h, num_div_eq_of_coprime hd0 h2]
{ rw [← (num_div_eq_of_coprime hb0 h1), h, num_div_eq_of_coprime hd0 h2] }
rw [← (denom_div_eq_of_coprime hb0 h1), h, denom_div_eq_of_coprime hd0 h2]
{ rw [← (denom_div_eq_of_coprime hb0 h1), h, denom_div_eq_of_coprime hd0 h2] }
rw [mk_univ, mk_real]
intros
haveI := classical.prop_decidable
by_contra nk
refine hf (λ ε ε0, _)
simp [not_forall] at nk
cases f.cauchy₃ (half_pos ε0) with i hi
rcases nk _ (half_pos ε0) i with ⟨j, ij, hj⟩
refine ⟨j, λ k jk, _⟩
have := lt_of_le_of_lt (abv_add abv _ _) (add_lt_add (hi j ij k jk) hj)
rwa [sub_add_cancel, add_halves] at this
intros
{ contrapose! h, exact ennreal.div_le_of_le_mul h }
contrapose! h
exact ennreal.div_le_of_le_mul h
intros
simp [ennreal.of_real, real.to_nnreal_le_to_nnreal h]
intros
simp [ennreal.of_real]
intros
lift x to ℝ
lift y to ℝ
{ simpa using h }
simpa using h
{ simp [hy, ((bot_lt_iff_ne_bot.2 hx).trans_le h).ne'] }
simp [hy, ((bot_lt_iff_ne_bot.2 hx).trans_le h).ne']
{ simp [hx, (h.trans_lt (lt_top_iff_ne_top.2 hy)).ne], }
simp [hx, (h.trans_lt (lt_top_iff_ne_top.2 hy)).ne]
intros
change 0 + (-x) = - x
{ change 0 + (-x) = - x, simp }
simp
intros
unfold st
split_ifs
exact false.elim ((infinite_iff_not_exists_st.mp hi) h)
{ exact false.elim ((infinite_iff_not_exists_st.mp hi) h) }
{ refl }
refl
simp [real.to_nnreal]; refl
simp [real.to_nnreal]
rw [sign, if_neg (lt_irrefl _), if_neg (lt_irrefl _)]
intros
rw [sqrt, real.to_nnreal_inv, nnreal.sqrt_inv, nnreal.coe_inv, sqrt]
intros
apply eq_of_bisim (λ c1 c2, ∃ s, c1 = destruct (map f s) ∧ c2 = computation.map (option.map (prod.map f (map f))) (destruct s))
intros c1 c2 h
{ intros c1 c2 h, cases h with s h, rw [h.left, h.right], apply s.cases_on _ (λ a s, _) (λ s, _); simp, exact ⟨s, rfl, rfl⟩ }
cases h with s h
rw [h.left, h.right]
apply s.cases_on _ (λ a s, _) (λ s, _); simp
apply s.cases_on _ (λ a s, _) (λ s, _)
simp
simp
simp
exact ⟨s, rfl, rfl⟩
{ exact ⟨s, rfl, rfl⟩ }
exact ⟨s, rfl, rfl⟩
intros
induction n
induction n; simp [*, drop]
simp [*, drop]
simp [*, drop]
intros
simp [set.ite]
intros
apply subset.antisymm
calc f '' (s ∩ f ⁻¹' t) ⊆ f '' s ∩ (f '' (f⁻¹' t)) : image_inter_subset _ _ _ ... ⊆ f '' s ∩ t : inter_subset_inter_right _ (image_preimage_subset f t)
{ calc f '' (s ∩ f ⁻¹' t) ⊆ f '' s ∩ (f '' (f⁻¹' t)) : image_inter_subset _ _ _ ... ⊆ f '' s ∩ t : inter_subset_inter_right _ (image_preimage_subset f t) }
rintros _ ⟨⟨x, h', rfl⟩, h⟩
{ rintros _ ⟨⟨x, h', rfl⟩, h⟩, exact ⟨x, ⟨h', h⟩, rfl⟩ }
exact ⟨x, ⟨h', h⟩, rfl⟩
intros
simp [set.ext_iff, mem_range]
intros
simp [prod_eq]
intros
ext f
{ ext f, simp only [mem_empty_eq, not_forall, iff_false, mem_pi, not_imp], exact ⟨i, hs, by simp [ht]⟩ }
simp only [mem_empty_eq, not_forall, iff_false, mem_pi, not_imp]
exact ⟨i, hs, by simp [ht]⟩
intros
rintro _ ⟨a, b, ha, ⟨h1b, h2b⟩, rfl⟩
{ rintro _ ⟨a, b, ha, ⟨h1b, h2b⟩, rfl⟩, split; exact ⟨_, _, ‹_›, ‹_›, rfl⟩ }
split
split; exact ⟨_, _, ‹_›, ‹_›, rfl⟩
exact ⟨_, _, ‹_›, ‹_›, rfl⟩
exact ⟨_, _, ‹_›, ‹_›, rfl⟩
intros
{ rw union_comm, exact sup_inf_sdiff _ _ }
rw union_comm
exact sup_inf_sdiff _ _
intros
{ rw seq_def, exact hf.bUnion (λ f _, hs.image _) }
rw seq_def
exact hf.bUnion (λ f _, hs.image _)
intros
by_contra hinf
change s.infinite at hinf
rcases hinf.exists_subset_card_eq 3 with ⟨t, hts, ht⟩
let f := t.order_iso_of_fin ht
let x := f 0
let y := f 1
let z := f 2
have := h x (hts x.2) y (hts y.2) z (hts z.2) (f.monotone $ by dec_trivial) (f.monotone $ by dec_trivial)
have key₁ : (0 : fin 3) ≠ 1 := by dec_trivial
have key₂ : (1 : fin 3) ≠ 2 := by dec_trivial
cases this
dsimp only [x, y] at this
{ dsimp only [x, y] at this, exact key₁ (f.injective $ subtype.coe_injective this) }
exact key₁ (f.injective $ subtype.coe_injective this)
dsimp only [y, z] at this
{ dsimp only [y, z] at this, exact key₂ (f.injective $ subtype.coe_injective this) }
exact key₂ (f.injective $ subtype.coe_injective this)
intros
simp [eq_on_piecewise, *]
intros
refine ⟨λ h, _, λ h, Ioi_subset_Ici h⟩
by_contradiction ba
obtain ⟨c, bc, ca⟩ : ∃c, b < c ∧ c < a := exists_between (not_le.mp ba)
exact lt_irrefl _ (ca.trans_le (h bc))
intros
simp [← Ici_inter_Iic]
intros
simp
intros
simp [← Ioi_inter_Iio, h, inter_comm]
intros
simpa using bInter_range
intros
simp [set.disjoint_iff, subset_def]; exact iff.rfl
simp [set.disjoint_iff, subset_def]
exact iff.rfl
intros
ext x
split
rintro ⟨s, ⟨y, rfl⟩, ⟨s, hs⟩, rfl⟩
{ rintro ⟨s, ⟨y, rfl⟩, ⟨s, hs⟩, rfl⟩, refine ⟨_, hs, _⟩, exact (f ⟨s, hs⟩ y).2 }
refine ⟨_, hs, _⟩
exact (f ⟨s, hs⟩ y).2
rintro ⟨s, hs, hx⟩
{ rintro ⟨s, hs, hx⟩, cases hf ⟨s, hs⟩ ⟨x, hx⟩ with y hy, refine ⟨_, ⟨y, rfl⟩, ⟨s, hs⟩, _⟩, exact congr_arg subtype.val hy }
cases hf ⟨s, hs⟩ ⟨x, hx⟩ with y hy
refine ⟨_, ⟨y, rfl⟩, ⟨s, hs⟩, _⟩
exact congr_arg subtype.val hy
intros
{ cases x₀, cases x₁, cases h₀, cases h₁, refl }
cases x₀
cases x₁
cases h₀
cases h₁
refl
intros
casesI n
rw [nat.mod_zero, int.nat_cast_eq_coe_nat]
{ rw [nat.mod_zero, int.nat_cast_eq_coe_nat], exact int.nat_abs_of_nat a, }
exact int.nat_abs_of_nat a
rw ← fin.of_nat_eq_coe
refl
intros
cases n
simp only [nat.modeq, int.coe_nat_inj', nat.mod_zero, int.nat_cast_eq_coe_nat]
{ simp only [nat.modeq, int.coe_nat_inj', nat.mod_zero, int.nat_cast_eq_coe_nat], }
rw [fin.ext_iff, nat.modeq, ← val_nat_cast, ← val_nat_cast]
{ rw [fin.ext_iff, nat.modeq, ← val_nat_cast, ← val_nat_cast], exact iff.rfl, }
exact iff.rfl
intros
have := f.lift_of_right_inverse_comp _ (zmod.ring_hom_right_inverse f) ⟨g, le_of_eq h⟩
rw subtype.coe_mk at this
rw [←this, ring_hom.ext_zmod (f.lift_of_right_inverse _ _ _) (ring_hom.id _), ring_hom.id_comp]
intros
cases n
exact conservative.id μ
{ exact conservative.id μ }
refine ⟨hf.1.iterate _, λ s hs hs0, _⟩
rcases (hf.frequently_ae_mem_and_frequently_image_mem hs hs0).exists with ⟨x, hxs, hx⟩
rw nat.frequently_at_top_iff_infinite at hx
rcases nat.exists_lt_modeq_of_infinite hx n.succ_pos with ⟨k, hk, l, hl, hkl, hn⟩
set m := (l - k) / (n + 1)
have : (n + 1) * m = l - k
apply nat.mul_div_cancel'
{ apply nat.mul_div_cancel', exact (nat.modeq_iff_dvd' hkl.le).1 hn }
exact (nat.modeq_iff_dvd' hkl.le).1 hn
refine ⟨f^[k] x, hk, m, _, _⟩
intro hm
{ intro hm, rw [hm, mul_zero, eq_comm, nat.sub_eq_zero_iff_le] at this, exact this.not_lt hkl }
rw [hm, mul_zero, eq_comm, nat.sub_eq_zero_iff_le] at this
exact this.not_lt hkl
rwa [← iterate_mul, this, ← iterate_add_apply, nat.sub_add_cancel]
{ rwa [← iterate_mul, this, ← iterate_add_apply, nat.sub_add_cancel], exact hkl.le }
exact hkl.le
intros
simp only [omega_limit_def, mem_Inter, maps_to]
intros y hy u hu
refine map_mem_closure hgc (hy _ (inter_mem hu hg)) (forall_image2_iff.2 $ λ t ht x hx, _)
calc gb (ϕ t x) = ϕ' t (ga x) : ht.2 hx ... ∈ image2 ϕ' u s' : mem_image2_of_mem ht.1 (hs hx)
intros
apply_instance
intros
rw alg_hom.card_of_power_basis; simp only [adjoin.power_basis_dim, adjoin.power_basis_gen, minpoly_gen h, h_sep, h_splits]
rw alg_hom.card_of_power_basis
simp only [adjoin.power_basis_dim, adjoin.power_basis_gen, minpoly_gen h, h_sep, h_splits]
simp only [adjoin.power_basis_dim, adjoin.power_basis_gen, minpoly_gen h, h_sep, h_splits]
simp only [adjoin.power_basis_dim, adjoin.power_basis_gen, minpoly_gen h, h_sep, h_splits]
intros
apply induction_on f
intro a
{ intro a, rw [expand_C, frobenius_def, ← C_pow, zmod.pow_card], }
rw [expand_C, frobenius_def, ← C_pow, zmod.pow_card]
simp only [alg_hom.map_add, ring_hom.map_add]
{ simp only [alg_hom.map_add, ring_hom.map_add], intros _ _ hf hg, rw [hf, hg] }
intros _ _ hf hg
rw [hf, hg]
simp only [expand_X, ring_hom.map_mul, alg_hom.map_mul]
{ simp only [expand_X, ring_hom.map_mul, alg_hom.map_mul], intros _ _ hf, rw [hf, frobenius_def], }
intros _ _ hf
rw [hf, frobenius_def]
intros
tfae_have : 1 → 2
exact λ h, order_iso.map_bot (@intermediate_field_equiv_subgroup F _ E _ _ _ h).symm
{ exact λ h, order_iso.map_bot (@intermediate_field_equiv_subgroup F _ E _ _ _ h).symm }
tfae_have : 1 → 3
{ introI _, exact card_aut_eq_finrank F E }
introI _
exact card_aut_eq_finrank F E
tfae_have : 1 → 4
{ introI _, exact is_separable_splitting_field F E }
introI _
exact is_separable_splitting_field F E
tfae_have : 2 → 1
{ exact of_fixed_field_eq_bot F E }
exact of_fixed_field_eq_bot F E
tfae_have : 3 → 1
{ exact of_card_aut_eq_finrank F E }
exact of_card_aut_eq_finrank F E
tfae_have : 4 → 1
rintros ⟨h, hp1, _⟩
{ rintros ⟨h, hp1, _⟩, exactI of_separable_splitting_field hp1 }
exactI of_separable_splitting_field hp1
tfae_finish
intros
let f : (E ≃ₐ[K] E) →* (E ≃ₐ[F] E) := { to_fun := λ ϕ, alg_equiv.of_alg_hom (ϕ.to_alg_hom.restrict_scalars F) (ϕ.symm.to_alg_hom.restrict_scalars F) (alg_hom.ext (λ x, ϕ.apply_symm_apply x)) (alg_hom.ext (λ x, ϕ.symm_apply_apply x)), map_one' := alg_equiv.ext (λ _, rfl), map_mul' := λ _ _, alg_equiv.ext (λ _, rfl) }
refine solvable_of_ker_le_range f (alg_equiv.restrict_normal_hom K) (λ ϕ hϕ, ⟨{commutes' := λ x, _, .. ϕ}, alg_equiv.ext (λ _, rfl)⟩)
exact (eq.trans (ϕ.restrict_normal_commutes K x).symm (congr_arg _ (alg_equiv.ext_iff.mp hϕ x)))
intros
rw monoid_hom.injective_iff
intros ϕ hϕ
ext x hx
have key := equiv.perm.ext_iff.mp hϕ (roots_equiv_roots p E ⟨x, hx⟩)
change roots_equiv_roots p E (ϕ • (roots_equiv_roots p E).symm (roots_equiv_roots p E ⟨x, hx⟩)) = roots_equiv_roots p E ⟨x, hx⟩ at key
rw equiv.symm_apply_apply at key
exact subtype.ext_iff.mp (equiv.injective (roots_equiv_roots p E) key)
intros
have := h.of_mul_left_left
rw derivative_mul at this
exact is_coprime.of_mul_right_left (is_coprime.of_add_mul_left_right this)
intros
rw [dist_left_midpoint p1 p2, dist_right_midpoint p1 p2]
intros
have hs : s₁.circumcenter ∈ affine_span ℝ (set.range s₂.points) := h ▸ s₁.circumcenter_mem_affine_span
have hr : ∀ i, dist (s₂.points i) s₁.circumcenter = s₁.circumradius
intro i
{ intro i, have hi : s₂.points i ∈ set.range s₂.points := set.mem_range_self _, rw [←h, set.mem_range] at hi, rcases hi with ⟨j, hj⟩, rw [←hj, s₁.dist_circumcenter_eq_circumradius j] }
have hi : s₂.points i ∈ set.range s₂.points := set.mem_range_self _
rw [←h, set.mem_range] at hi
rcases hi with ⟨j, hj⟩
rw [←hj, s₁.dist_circumcenter_eq_circumradius j]
exact s₂.eq_circumcenter_of_dist_eq hs hr
intros
rw direction_altitude
exact le_trans (vector_span ℝ (s.points '' ↑(finset.univ.erase i))).le_orthogonal_orthogonal (submodule.orthogonal_le inf_le_left)
intros
have h₀ : times_cont_diff ℝ ⊤ (λ w : E, ∥w∥ ^ 2) := times_cont_diff_norm_sq
have h₁ : times_cont_diff ℝ ⊤ (λ w : E, (∥w∥ ^ 2 + 4)⁻¹)
refine (h₀.add times_cont_diff_const).inv _
{ refine (h₀.add times_cont_diff_const).inv _, intros x, nlinarith }
intros x
nlinarith
have h₂ : times_cont_diff ℝ ⊤ (λ w, (4:ℝ) • w + (∥w∥ ^ 2 - 4) • v)
refine (times_cont_diff_const.smul times_cont_diff_id).add _
{ refine (times_cont_diff_const.smul times_cont_diff_id).add _, refine (h₀.sub times_cont_diff_const).smul times_cont_diff_const }
refine (h₀.sub times_cont_diff_const).smul times_cont_diff_const
exact h₁.smul h₂
intros
{ ext1 ⟨x, v⟩, simp [tangent_map] }
ext1 ⟨x, v⟩
simp [tangent_map]
intros
simp only [mdifferentiable_within_at, mdifferentiable_at, continuous_within_at_univ] with mfld_simps
intros
simp only [mdifferentiable_at, differentiable_within_at_univ] with mfld_simps
exact ⟨λH, H.2, λH, ⟨H.continuous_at, H⟩⟩
intros
simp only [ext_chart_at_source, mem_chart_source]
intros
rw times_cont_mdiff_within_at_iff
refine ⟨continuous_within_at_fst, _⟩
refine times_cont_diff_within_at_fst.congr (λ y hy, _) _
simp only with mfld_simps at hy
{ simp only with mfld_simps at hy, simp only [hy] with mfld_simps }
simp only [hy] with mfld_simps
{ simp only with mfld_simps }
simp only with mfld_simps
intros
rw [Sup_eq_con_gen, Sup_image]
congr' with x y
simp only [Sup_image, supr_apply, supr_Prop_eq, exists_prop, rel_eq_coe]
intros
rw set.ext_iff
simp_rw [mem_right_coset_iff, set_like.mem_coe]
split
intro h
{ intro h, apply (h y).mpr, rw mul_right_inv, exact s.one_mem }
apply (h y).mpr
rw mul_right_inv
exact s.one_mem
intros h z
{ intros h z, rw ←inv_mul_cancel_left y x⁻¹, rw ←mul_assoc, exact s.mul_mem_cancel_right h }
rw ←inv_mul_cancel_left y x⁻¹
rw ←mul_assoc
exact s.mul_mem_cancel_right h
intros
cases b; from step.bnot
cases b
from step.bnot
from step.bnot
intros
rw general_commutator_comm
exact general_commutator_le_right H₂ H₁
intros
ext
ext; refl
refl
intros
convert mk'_self' _ _; refl
convert mk'_self' _ _
refl
intros
rw card_eq_one
simp_rw [cycle_type_def, multiset.map_eq_singleton, ←finset.singleton_val, finset.val_inj, cycle_factors_finset_eq_singleton_iff]
split
rintro ⟨_, _, ⟨h, -⟩, -⟩
{ rintro ⟨_, _, ⟨h, -⟩, -⟩, exact h }
exact h
intro h
{ intro h, use [σ.support.card, σ], simp [h] }
use [σ.support.card, σ]
simp [h]
intros
refine ⟨λ h, _, is_three_cycle.card_support⟩
by_cases h0 : σ.cycle_type = 0
rw [←sum_cycle_type, h0, sum_zero] at h
{ rw [←sum_cycle_type, h0, sum_zero] at h, exact (ne_of_lt zero_lt_three h).elim }
exact (ne_of_lt zero_lt_three h).elim
obtain ⟨n, hn⟩ := exists_mem_of_ne_zero h0
by_cases h1 : σ.cycle_type.erase n = 0
rw [←sum_cycle_type, ←cons_erase hn, h1, ←singleton_eq_cons, multiset.sum_singleton] at h
{ rw [←sum_cycle_type, ←cons_erase hn, h1, ←singleton_eq_cons, multiset.sum_singleton] at h, rw [is_three_cycle, ←cons_erase hn, h1, h, singleton_eq_cons] }
rw [is_three_cycle, ←cons_erase hn, h1, h, singleton_eq_cons]
obtain ⟨m, hm⟩ := exists_mem_of_ne_zero h1
rw [←sum_cycle_type, ←cons_erase hn, ←cons_erase hm, multiset.sum_cons, multiset.sum_cons] at h
linarith [two_le_of_mem_cycle_type hn, two_le_of_mem_cycle_type (mem_of_mem_erase hm)]
intros
simp
intros
ext z
rw cycle_of_apply
split_ifs with hz hz
{ exact (h.symm.trans hz).cycle_of_apply.symm }
exact (h.symm.trans hz).cycle_of_apply.symm
exact (cycle_of_apply_of_not_same_cycle (mt h.trans hz)).symm
{ exact (cycle_of_apply_of_not_same_cycle (mt h.trans hz)).symm }
intros
{ ext, simp }
ext
simp
intros
refine (zip_with_swap_prod_support' l l.tail).trans _
simpa [finset.subset_iff] using tail_subset l
intros
split
split; id { intros h, classical, rw ←perm_inv_maps_to_iff_maps_to at h, intro x, cases hx : σ x with l r, }
id { intros h, classical, rw ←perm_inv_maps_to_iff_maps_to at h, intro x, cases hx : σ x with l r, }
rintros ⟨a, rfl⟩
{ rintros ⟨a, rfl⟩, obtain ⟨y, hy⟩ := h ⟨l, rfl⟩, rw [←hx, σ.inv_apply_self] at hy, exact absurd hy sum.inl_ne_inr}
obtain ⟨y, hy⟩ := h ⟨l, rfl⟩
rw [←hx, σ.inv_apply_self] at hy
exact absurd hy sum.inl_ne_inr
{ rintros ⟨a, ha⟩, exact ⟨r, rfl⟩, }
rintros ⟨a, ha⟩
exact ⟨r, rfl⟩
id { intros h, classical, rw ←perm_inv_maps_to_iff_maps_to at h, intro x, cases hx : σ x with l r, }
intros h
classical
rw ←perm_inv_maps_to_iff_maps_to at h
intro x
cases hx : σ x with l r
{ rintros ⟨a, ha⟩, exact ⟨l, rfl⟩, }
rintros ⟨a, ha⟩
exact ⟨l, rfl⟩
rintros ⟨a, rfl⟩
{ rintros ⟨a, rfl⟩, obtain ⟨y, hy⟩ := h ⟨r, rfl⟩, rw [←hx, σ.inv_apply_self] at hy, exact absurd hy sum.inr_ne_inl}
obtain ⟨y, hy⟩ := h ⟨r, rfl⟩
rw [←hx, σ.inv_apply_self] at hy
exact absurd hy sum.inr_ne_inl
intros
refine le_antisymm (support_mul_le _ _) (λ a, _)
rw [mem_union, mem_support, mem_support, mem_support, mul_apply, ←not_and_distrib, not_imp_not]
exact (h a).elim (λ hf h, ⟨hf, f.apply_eq_iff_eq.mp (h.trans hf.symm)⟩) (λ hg h, ⟨(congr_arg f hg).symm.trans h, hg⟩)
intros
ext x
simp only [mem_normalizer_iff, mem_map_equiv]
rw [f.to_equiv.forall_congr]
simp
intros
{ ext, exact mem_closure_singleton.symm }
ext
exact mem_closure_singleton.symm
intros
split
introI h
{ introI h, rcases exists_ne (1 : S) with ⟨⟨h, h_in⟩, h_ne⟩, use [h, h_in], intro hyp, apply h_ne, simpa [hyp] }
rcases exists_ne (1 : S) with ⟨⟨h, h_in⟩, h_ne⟩
use [h, h_in]
intro hyp
apply h_ne
simpa [hyp]
rintros ⟨x, x_in, hx⟩
{ rintros ⟨x, x_in, hx⟩, apply nontrivial_of_ne (⟨x, x_in⟩ : S) 1, intro hyp, apply hx, simpa [has_one.one] using hyp }
apply nontrivial_of_ne (⟨x, x_in⟩ : S) 1
intro hyp
apply hx
simpa [has_one.one] using hyp
intros
rw [set.insert_eq, set.insert_eq, span_union, span_union, affine_span_coe]
intros
rw [centroid, centroid, ← s.attach_affine_combination_coe]
{ rw [centroid, centroid, ← s.attach_affine_combination_coe], congr, ext, simp, }
congr
ext
simp
intros
rw collinear_iff_exists_forall_eq_smul_vadd
use [p₁, p₂ -ᵥ p₁]
intros p hp
rw [set.mem_insert_iff, set.mem_singleton_iff] at hp
cases hp
use 0
{ use 0, simp [hp] }
simp [hp]
use 1
{ use 1, simp [hp] }
simp [hp]
intros
rw [midpoint_comm, affine_equiv.point_reflection_midpoint_left]
intros
{ rw [g.map_perm, smul_smul], simp }
rw [g.map_perm, smul_smul]
simp
intros
simp_rw [set_like.le_def, mem_span_singleton]
intros
rw [range_eq_map, map_le_iff_le_comap, eq_top_iff]
intros
simpa only [range_eq_map] using submodule.map_smul' f _ a
intros
rw [← to_span_nonzero_singleton_one K M x h, symm_apply_apply]
intros
rw [linear_equiv.range, finsupp.supported_univ]
intros
simp only [B.to_matrix'_comp, transpose_transpose, to_matrix'_to_lin']
intros
ext m
dsimp only [linear_map.comp_apply, alg_hom.comp_apply, alg_hom.to_linear_map_apply, alg_hom.id_apply]
rw [map_apply_ι, map_apply_ι, map_apply_ι, linear_map.comp_apply]
intros
apply uncurry_apply
intros
apply finsupp.induction_linear f
{ simp, }
simp
{ intros f₁ f₂ hf₁ hf₂, simp [add_tmul, hf₁, hf₂], }
intros f₁ f₂ hf₁ hf₂
simp [add_tmul, hf₁, hf₂]
intros i' m
{ intros i' m, apply finsupp.induction_linear g, { simp, }, { intros g₁ g₂ hg₁ hg₂, simp [tmul_add, hg₁, hg₂], }, { intros k' n, simp only [finsupp_tensor_finsupp_single], simp only [finsupp.single, finsupp.coe_mk], split_ifs; finish, } }
apply finsupp.induction_linear g
{ simp, }
simp
{ intros g₁ g₂ hg₁ hg₂, simp [tmul_add, hg₁, hg₂], }
intros g₁ g₂ hg₁ hg₂
simp [tmul_add, hg₁, hg₂]
intros k' n
{ intros k' n, simp only [finsupp_tensor_finsupp_single], simp only [finsupp.single, finsupp.coe_mk], split_ifs; finish, }
simp only [finsupp_tensor_finsupp_single]
simp only [finsupp.single, finsupp.coe_mk]
split_ifs; finish
split_ifs
finish
finish
finish
finish
finish
finish
finish
finish
intros
ext φ
rw [mem_inf, mem_dual_annihilator, mem_dual_annihilator, mem_dual_annihilator]
split
split; intro h
intro h
refine ⟨_, _⟩; intros x hx
refine ⟨_, _⟩
{ refine ⟨_, _⟩; intros x hx, exact h x (mem_sup.2 ⟨x, hx, 0, zero_mem _, add_zero _⟩), exact h x (mem_sup.2 ⟨0, zero_mem _, x, hx, zero_add _⟩) }
intros x hx
exact h x (mem_sup.2 ⟨x, hx, 0, zero_mem _, add_zero _⟩)
intros x hx
exact h x (mem_sup.2 ⟨0, zero_mem _, x, hx, zero_add _⟩)
intro h
simp_rw mem_sup
{ simp_rw mem_sup, rintro _ ⟨x, hx, y, hy, rfl⟩, rw [linear_map.map_add, h.1 _ hx, h.2 _ hy, add_zero] }
rintro _ ⟨x, hx, y, hy, rfl⟩
rw [linear_map.map_add, h.1 _ hx, h.2 _ hy, add_zero]
intros
rw [eigenspace, linear_map.mem_ker, linear_map.sub_apply, algebra_map_End_apply, sub_eq_zero]
intros
have key : module.rank K ↥(s ⊔ t) + module.rank K ↥(s ⊓ t) = module.rank K s + module.rank K t := dim_sup_add_dim_inf_eq s t
rw ←finrank_eq_dim at key
repeat { rw ←finrank_eq_dim at key }
rw ←finrank_eq_dim at key
rw ←finrank_eq_dim at key
rw ←finrank_eq_dim at key
rw ←finrank_eq_dim at key
norm_cast at key
exact key
intros
conv_lhs { rw ←set.image_id s }
simp_rw ←exists_prop
exact finsupp.mem_span_image_iff_total R
intros
rcases f with ⟨f_dom, f⟩
rcases g with ⟨g_dom, g⟩
change f_dom = g_dom at heq
subst g_dom
have : f = g
from linear_map.ext (λ x, hle.2 rfl)
subst g
intros
rw ← det_transpose
exact det_of_upper_triangular _ (λ (i j : fin n) (hji : j < i), h j i hji)
intros
{ ext i j, simp [one_apply, pi.single_apply, sub_eq_zero] }
ext i j
simp [one_apply, pi.single_apply, sub_eq_zero]
intros
{ intros i j h, simp [ha h, hf] }
intros i j h
simp [ha h, hf]
intros
apply (linear_map.to_matrix v₁ v₃).injective
haveI : decidable_eq l := λ _ _, classical.prop_decidable _
rw linear_map.to_matrix_comp v₁ v₂ v₃
rw linear_map.to_matrix_to_lin
repeat { rw linear_map.to_matrix_to_lin }
rw linear_map.to_matrix_to_lin
rw linear_map.to_matrix_to_lin
intros
split
ext i j
{ ext i j, have : j = star, by simp only [eq_iff_true_of_subsingleton], simp [to_blocks₁₂, this, list_transvec_col_mul_mul_list_transvec_row_last_row M hM] }
have : j = star
simp only [eq_iff_true_of_subsingleton]
simp only [eq_iff_true_of_subsingleton]
simp [to_blocks₁₂, this, list_transvec_col_mul_mul_list_transvec_row_last_row M hM]
ext i j
{ ext i j, have : i = star, by simp only [eq_iff_true_of_subsingleton], simp [to_blocks₂₁, this, list_transvec_col_mul_mul_list_transvec_row_last_col M hM] }
have : i = star
simp only [eq_iff_true_of_subsingleton]
simp only [eq_iff_true_of_subsingleton]
simp [to_blocks₂₁, this, list_transvec_col_mul_mul_list_transvec_row_last_col M hM]
intros
{ ext x, simp }
ext x
simp
intros
rw [ker, ← prod_bot, prod_comap_inr]
intros
ext x
obtain ⟨_, _, rfl, _⟩ := exists_unique_add_of_is_compl h x
simp [of_is_compl, hφ, hψ]
intros
simp [basis_fun]
intros
ext t
simp only [submodule.mem_top, iff_true]
apply t.induction_on
{ exact submodule.zero_mem _, }
exact submodule.zero_mem _
{ intros m n, apply submodule.subset_span, use [m, n], }
intros m n
apply submodule.subset_span
use [m, n]
intros t₁ t₂ ht₁ ht₂
{ intros t₁ t₂ ht₁ ht₂, exact submodule.add_mem _ ht₁ ht₂, }
exact submodule.add_mem _ ht₁ ht₂
intros
simp only [exists_prop, exists_eq_left]
intros
rw [iff_iff_implies_and_implies a b]
simp only [decidable.imp_iff_not_or, or.comm]
intros
use cases_head
rintro (rfl | ⟨c, hac, hcb⟩)
{ refl }
refl
{ exact head hac hcb }
exact head hac hcb
intros
{ rw [← uncurry_curry f] at hf, exact hf.integral_prod_right }
rw [← uncurry_curry f] at hf
exact hf.integral_prod_right
intros
simp [lintegral_prod _ (hf.fst.mul hg.snd), lintegral_lintegral_mul hf hg]
intros
rw [condexp_ind_smul, indicator_const_empty]
simp only [coe_fn_coe_base, submodule.coe_zero, continuous_linear_map.map_zero]
intros
by_cases hf : integrable f μ
calc condexp_L1 hm μ (c • f) = condexp_L1_clm hm μ ((hf.smul c).to_L1 (c • f)) : condexp_L1_eq (hf.smul c) ... = condexp_L1_clm hm μ (c • hf.to_L1 f) : by rw integrable.to_L1_smul' _ hf c ... = c • condexp_L1_clm hm μ (hf.to_L1 f) : condexp_L1_clm_smul c (hf.to_L1 f) ... = c • condexp_L1 hm μ f : by rw condexp_L1_eq hf
{ calc condexp_L1 hm μ (c • f) = condexp_L1_clm hm μ ((hf.smul c).to_L1 (c • f)) : condexp_L1_eq (hf.smul c) ... = condexp_L1_clm hm μ (c • hf.to_L1 f) : by rw integrable.to_L1_smul' _ hf c ... = c • condexp_L1_clm hm μ (hf.to_L1 f) : condexp_L1_clm_smul c (hf.to_L1 f) ... = c • condexp_L1 hm μ f : by rw condexp_L1_eq hf, }
by_cases hc : c = 0
{ by_cases hc : c = 0, { rw [hc, zero_smul, zero_smul, condexp_L1_zero], }, rw [condexp_L1_undef hf, condexp_L1_undef (mt (integrable_smul_iff hc f).mp hf), smul_zero], }
{ rw [hc, zero_smul, zero_smul, condexp_L1_zero], }
rw [hc, zero_smul, zero_smul, condexp_L1_zero]
rw [condexp_L1_undef hf, condexp_L1_undef (mt (integrable_smul_iff hc f).mp hf), smul_zero]
intros
rw [Lp_meas_coe, ← ennreal.to_real_le_to_real (Lp.snorm_ne_top _) (Lp.snorm_ne_top _), ← Lp.norm_def, ← Lp.norm_def, submodule.norm_coe]
exact norm_condexp_L2_le hm f
intros
simp only [has_finite_integral, lintegral_add_measure] at *
exact add_lt_top.2 ⟨hμ, hν⟩
intros
simp_rw [mul_comm, h.const_mul _]
intros
rw [← integral_inner (integrable_on_Lp_of_measure_ne_top f fact_one_le_two_ennreal.elim hμs), L2.inner_indicator_const_Lp_eq_set_integral_inner]
intros
refine ⟨λ hf, _, λ hf, by simp [hf]⟩
rw [norm_def, ennreal.to_real_eq_zero_iff] at hf
cases hf
rw snorm_eq_zero_iff (Lp.ae_measurable f) hp.ne.symm at hf
{ rw snorm_eq_zero_iff (Lp.ae_measurable f) hp.ne.symm at hf, exact subtype.eq (ae_eq_fun.ext (hf.trans ae_eq_fun.coe_fn_zero.symm)), }
exact subtype.eq (ae_eq_fun.ext (hf.trans ae_eq_fun.coe_fn_zero.symm))
{ exact absurd hf (snorm_ne_top f), }
exact absurd hf (snorm_ne_top f)
intros
rw lintegral_rpow_nnnorm_eq_rpow_snorm' hq0_lt
exact ennreal.rpow_lt_top_of_nonneg (le_of_lt hq0_lt) (ne_of_lt hfq)
intros
by_cases hμ : μ = 0
{ simp [hμ] }
simp [hμ]
haveI : μ.ae.ne_bot := ae_ne_bot.mpr hμ
by_cases hp : p = 0
{ simp [hp] }
simp [hp]
have hC : 0 ≤ C
from le_trans (norm_nonneg _) hfC.exists.some_spec
have hC' : ∥C∥ = C := by rw [real.norm_eq_abs, abs_eq_self.mpr hC]
have : ∀ᵐ x ∂μ, ∥f x∥ ≤ ∥(λ _, C) x∥
from hfC.mono (λ x hx, hx.trans (le_of_eq hC'.symm))
convert snorm_mono_ae this
rw [snorm_const _ hp hμ, mul_comm, ← of_real_norm_eq_coe_nnnorm, hC', one_div]
intros
rw [integrable_congr indicator_const_Lp_coe_fn, integrable_indicator_iff hs, integrable_on, integrable_const_iff, lt_top_iff_ne_top]
right
simpa only [set.univ_inter, measurable_set.univ, measure.restrict_apply] using hμs
intros
cases le_total a b with hab hab
rw [integral_of_le hab, ← integral_indicator measurable_set_Ioc, indicator_eq_self.2 h]
rw [integral_of_le hab, ← integral_indicator measurable_set_Ioc, indicator_eq_self.2 h]; apply_instance
{ rw [integral_of_le hab, ← integral_indicator measurable_set_Ioc, indicator_eq_self.2 h]; apply_instance }
apply_instance
apply_instance
apply_instance
rw [Ioc_eq_empty hab.not_lt, subset_empty_iff, support_eq_empty_iff] at h
{ rw [Ioc_eq_empty hab.not_lt, subset_empty_iff, support_eq_empty_iff] at h, simp [h] }
simp [h]
intros
rw measure.restrict_univ
intros
calc ∫⁻ a, ((f+g) a) ^ p ∂μ ≤ ∫⁻ a, ((f + g) a) * ((f + g) a) ^ (p - 1) ∂μ : begin refine lintegral_mono (λ a, _), dsimp only, by_cases h_zero : (f + g) a = 0, { rw [h_zero, ennreal.zero_rpow_of_pos hpq.pos], exact zero_le _, }, by_cases h_top : (f + g) a = ⊤, { rw [h_top, ennreal.top_rpow_of_pos hpq.sub_one_pos, ennreal.top_mul_top], exact le_top, }, refine le_of_eq _, nth_rewrite 1 ←ennreal.rpow_one ((f + g) a), rw [←ennreal.rpow_add _ _ h_zero h_top, add_sub_cancel'_right], end ... = ∫⁻ (a : α), f a * (f + g) a ^ (p - 1) ∂μ + ∫⁻ (a : α), g a * (f + g) a ^ (p - 1) ∂μ : begin have h_add_m : ae_measurable (λ (a : α), ((f + g) a) ^ (p-1)) μ, from (hf.add hg).pow_const _, have h_add_apply : ∫⁻ (a : α), (f + g) a * (f + g) a ^ (p - 1) ∂μ = ∫⁻ (a : α), (f a + g a) * (f + g) a ^ (p - 1) ∂μ, from rfl, simp_rw [h_add_apply, add_mul], rw lintegral_add' (hf.mul h_add_m) (hg.mul h_add_m), end ... ≤ ((∫⁻ a, (f a)^p ∂μ) ^ (1/p) + (∫⁻ a, (g a)^p ∂μ) ^ (1/p)) * (∫⁻ a, (f a + g a)^p ∂μ) ^ (1/q) : begin rw add_mul, exact add_le_add (lintegral_mul_rpow_le_lintegral_rpow_mul_lintegral_rpow hpq hf (hf.add hg) hf_top) (lintegral_mul_rpow_le_lintegral_rpow_mul_lintegral_rpow hpq hg (hf.add hg) hg_top), end
intros
rw [← bUnion_of_singleton s]
exact measurable_set.bUnion hs (λ b hb, measurable_set_singleton b)
intros
simp only [prehaar]
{ simp only [prehaar], rw [div_self], apply ne_of_gt, exact_mod_cast index_pos K₀ hU }
rw [div_self]
apply ne_of_gt
exact_mod_cast index_pos K₀ hU
intros
simp [map_map e.symm.measurable e.measurable]
intros
refine ⟨λ h, h.comp_measurable e.measurable, λ h, _⟩
rw [← (e.map_symm_map : _ = μ)] at h
convert h.comp_measurable e.symm.measurable
simp [(∘)]
intros
rw [← trimmed, outer_measure.trim_eq_trim_iff]
intros s hs
rw [coe_to_outer_measure, map_apply hf hs, outer_measure.map_apply, coe_to_outer_measure]
intros
by_cases h : ∀i, P (s i)
rw [extend_eq _ (PU h), congr_arg tsum _]
{ rw [extend_eq _ (PU h), congr_arg tsum _], { apply msU h }, funext i, apply extend_eq _ (h i) }
{ apply msU h }
apply msU h
funext i
apply extend_eq _ (h i)
cases not_forall.1 h with i hi
{ cases not_forall.1 h with i hi, exact le_trans (le_infi $ λ h, hi.elim h) (ennreal.le_tsum i) }
exact le_trans (le_infi $ λ h, hi.elim h) (ennreal.le_tsum i)
intros
have := supr_apply (λ b, cond b m₁ m₂) s; rwa [supr_bool_eq, supr_bool_eq] at this
have := supr_apply (λ b, cond b m₁ m₂) s
rwa [supr_bool_eq, supr_bool_eq] at this
intros
have : (λ s : set α, ⨆ (h : s.nonempty), m s) = m
ext1 t
{ ext1 t, cases t.eq_empty_or_nonempty with h h; simp [h, empty_not_nonempty, m_empty] }
cases t.eq_empty_or_nonempty with h h
cases t.eq_empty_or_nonempty with h h; simp [h, empty_not_nonempty, m_empty]
simp [h, empty_not_nonempty, m_empty]
simp [h, empty_not_nonempty, m_empty]
simp [bounded_by, this]
intros
refine ext_nonempty (λ s hs, _)
refine ((comap_mono f).map_infi_le s).antisymm _
simp only [comap_apply, infi_apply' _ hs, infi_apply' _ (hs.image _), le_infi_iff, set.image_subset_iff, preimage_Union]
refine λ t ht, infi_le_of_le _ (infi_le_of_le ht $ ennreal.tsum_le_tsum $ λ k, _)
exact infi_le_infi (λ i, (m i).mono (image_preimage_subset _ _))
intros
rw [← of_add_of_diff hA hB h, add_sub_cancel']
apply_instance
intros
have h3 : (0:ℚ) < 3
norm_num
norm_num
contrapose! H
rw sum_inv_pqr
have h3q := H.trans hpq
have h3r := h3q.trans hqr
calc (p⁻¹ + q⁻¹ + r⁻¹ : ℚ) ≤ 3⁻¹ + 3⁻¹ + 3⁻¹ : add_le_add (add_le_add _ _) _ ... = 1 : by norm_num
rw inv_le_inv _ h3; [assumption_mod_cast, norm_num]
all_goals { rw inv_le_inv _ h3; [assumption_mod_cast, norm_num] }
rw inv_le_inv _ h3; [assumption_mod_cast, norm_num]
rw inv_le_inv _ h3
rw inv_le_inv _ h3; [assumption_mod_cast, norm_num]
assumption_mod_cast
norm_num
intros
conv_lhs { rw ← bS.sum_repr a }
rw [algebra.norm_apply, ← linear_map.det_to_matrix bS]
simp only [algebra.norm_apply, alg_hom.map_sum, alg_hom.map_smul, linear_equiv.map_sum, linear_equiv.map_smul, algebra.to_matrix_lmul_eq, norm_bound, smul_mul_assoc, ← mul_pow]
convert matrix.det_sum_smul_le finset.univ _ hy using 3
{ rw [finset.card_univ, smul_mul_assoc, mul_comm] }
rw [finset.card_univ, smul_mul_assoc, mul_comm]
intros i j k
{ intros i j k, apply finset.le_max', exact finset.mem_image.mpr ⟨⟨i, j, k⟩, finset.mem_univ _, rfl⟩ }
apply finset.le_max'
exact finset.mem_image.mpr ⟨⟨i, j, k⟩, finset.mem_univ _, rfl⟩
intros
have : 1 ≤ b^p := nat.one_le_pow p b w
push_cast [this]
intros
rw [mersenne, nat.sub_add_cancel]
exact one_le_pow_of_one_le (by norm_num) k
intros
rw [eq_neg_iff_add_eq_zero, ← padic_val_rat.mul p (inv_ne_zero hq) hq, inv_mul_cancel hq, padic_val_rat.one]
intros
specialize f_compat i j h
rw [← int.coe_nat_pow, ← zmod.int_coe_zmod_eq_zero_iff_dvd, int.cast_sub]
dsimp [nth_hom]
rw [← f_compat, ring_hom.comp_apply]
have : fact (p ^ i > 0) := ⟨pow_pos hp_prime.1.pos _⟩
have : fact (p ^ j > 0) := ⟨pow_pos hp_prime.1.pos _⟩
simp only [zmod.cast_id, zmod.cast_hom_apply, sub_self, zmod.nat_cast_val]
unfreezingI { simp only [zmod.cast_id, zmod.cast_hom_apply, sub_self, zmod.nat_cast_val], }
intros
simp
intros
refine ⟨_, λ h, h.mul k⟩
simp only [pythagorean_triple]
intro h
rw ← mul_left_inj' (mul_ne_zero hk hk)
convert h using 1; ring
convert h using 1
ring
ring
intros
rw nonnegg_comm; exact nonnegg_neg_pos
rw nonnegg_comm
exact nonnegg_neg_pos
intros
cases x; cases y; simp [to_complex_def₂]
cases x; cases y
cases x
cases y
simp [to_complex_def₂]
intros
{ rw [sup_sdiff_self_right], exact le_sup_right }
rw [sup_sdiff_self_right]
exact le_sup_right
intros
rw [sdiff_sdiff_comm, sdiff_self, bot_sdiff]
intros
simp [bdd_above, upper_bounds, set.nonempty]
intros
{ change (∃ _, _) ↔ _, simp [-eq_iff_iff] }
change (∃ _, _) ↔ _
simp [-eq_iff_iff]
intros
rw [← infi_subtype'', Inf_image']
intros
{ ext x, simp [nat.find_eq_iff, disjointed_eq_inter_compl] }
ext x
simp [nat.find_eq_iff, disjointed_eq_inter_compl]
intros
refine top_unique (λ s hs x, _)
letI : unique α := ⟨⟨x⟩, λ y, subsingleton.elim y x⟩
rw [at_top, infi_unique, unique.default_eq x, mem_principal] at hs
exact hs left_mem_Ici
intros
refine le_antisymm (le_infi (λ i, le_principal_iff.2 $ mem_at_top {i})) _
refine le_infi (λ s, le_principal_iff.2 $ mem_infi_of_Inter s.finite_to_set (λ i, mem_principal_self _) _)
simp only [subset_def, mem_Inter, set_coe.forall, mem_Ici, finset.le_iff_subset, finset.mem_singleton, finset.subset_iff, forall_eq]
dsimp
exact λ t, id
intros
cases B.eq_empty_or_nonempty with hB Bnonempty
rw [hB, infi_emptyset]
{ rw [hB, infi_emptyset], use λ n, i₀, simp [h] }
use λ n, i₀
simp [h]
{ exact countable_binfi_eq_infi_seq Bcbl Bnonempty f }
exact countable_binfi_eq_infi_seq Bcbl Bnonempty f
intros
simp only [filter_eq_iff, ext_iff, filter.mem_sets]
intros
rw [sup_eq_supr, comap_supr, supr_bool_eq, bool.cond_tt, bool.cond_ff]
intros
refine le_trans (λ s hs, _) (join_mono $ map_mono hf)
simp only [mem_join, mem_bind', mem_map] at hs ⊢
filter_upwards [hg, hs]
exact λ x hx hs, hx hs
intros
rw [filter.prod, comap_infi, infi_inf]
{ rw [filter.prod, comap_infi, infi_inf], simp only [filter.prod, eq_self_iff_true] }
simp only [filter.prod, eq_self_iff_true]
intros
simp only [← filter.mem_sets, supr_sets_eq, iff_self, mem_Inter]
intros
simp only [← le_principal_iff, (is_compl_principal s).le_left_iff, disjoint, inf_assoc, inf_principal, imp_iff_not_or]
rw [← disjoint, ← (is_compl_principal (t ∩ sᶜ)).le_right_iff, compl_inter, compl_compl]
refl
intros
rcases lt_trichotomy (f x) (g x) with H|H|H
{ simp only [*, iterate_pos_lt_of_map_lt] }
simp only [*, iterate_pos_lt_of_map_lt]
{ simp only [*, h.iterate_eq_of_map_eq, lt_irrefl] }
simp only [*, h.iterate_eq_of_map_eq, lt_irrefl]
simp only [lt_asymm H, lt_asymm (h.symm.iterate_pos_lt_of_map_lt' hg hf H hn)]
{ simp only [lt_asymm H, lt_asymm (h.symm.iterate_pos_lt_of_map_lt' hg hf H hn)] }
intros
simp only [sup_inf_left, λy:α, @sup_comm α _ y x, eq_self_iff_true]
intros
simp only [limsup_eq_infi_supr_of_nat, supr_ge_eq_supr_nat_add]
intros
simp only [lt_iff_le_not_le, hf.le_iff h]
intros
intros x y hxy
rcases trichotomous_of r x y with h | h | h
have := hf h
rw hxy at this
exfalso
exact irrefl_of s (f y) this
exact h
have := hf h
rw hxy at this
exfalso
exact irrefl_of s (f y) this
intros
refine λ y, (H _).unique _
have := (f₁ g).left_ord_continuous (H y)
rw [← range_comp, ← (equiv.mul_right g).surjective.range_comp _] at this
simpa [(∘)] using this
intros
rw [symm_diff_def, sup_sdiff, sdiff_sdiff_left, sdiff_sdiff_left]
intros
revert g
have h_measM_f : measurable f
from h_meas_f.mono hMf le_rfl
apply measurable.ennreal_induction
intros c s h_s
{ intros c s h_s, apply lintegral_mul_indicator_eq_lintegral_mul_lintegral_indicator hMf _ (hMg _ h_s) _ h_meas_f, apply indep_sets_of_indep_sets_of_le_right h_ind, rwa singleton_subset_iff, }
apply lintegral_mul_indicator_eq_lintegral_mul_lintegral_indicator hMf _ (hMg _ h_s) _ h_meas_f
apply indep_sets_of_indep_sets_of_le_right h_ind
rwa singleton_subset_iff
{ intros f' g h_univ h_measMg_f' h_measMg_g h_ind_f' h_ind_g', have h_measM_f' : measurable f', from h_measMg_f'.mono hMg le_rfl, have h_measM_g : measurable g, from h_measMg_g.mono hMg le_rfl, simp_rw [pi.add_apply, left_distrib], rw [lintegral_add h_measM_f' h_measM_g, lintegral_add (h_measM_f.mul h_measM_f') (h_measM_f.mul h_measM_g), left_distrib, h_ind_f', h_ind_g'] }
intros f' g h_univ h_measMg_f' h_measMg_g h_ind_f' h_ind_g'
have h_measM_f' : measurable f'
from h_measMg_f'.mono hMg le_rfl
have h_measM_g : measurable g
from h_measMg_g.mono hMg le_rfl
simp_rw [pi.add_apply, left_distrib]
rw [lintegral_add h_measM_f' h_measM_g, lintegral_add (h_measM_f.mul h_measM_f') (h_measM_f.mul h_measM_g), left_distrib, h_ind_f', h_ind_g']
intros f' h_meas_f' h_mono_f' h_ind_f'
{ intros f' h_meas_f' h_mono_f' h_ind_f', have h_measM_f' : ∀ n, measurable (f' n), from λ n, (h_meas_f' n).mono hMg le_rfl, simp_rw [ennreal.mul_supr], rw [lintegral_supr, lintegral_supr h_measM_f' h_mono_f', ennreal.mul_supr], { simp_rw [← h_ind_f'], }, { exact λ n, h_measM_f.mul (h_measM_f' n), }, { exact λ n m (h_le : n ≤ m) a, ennreal.mul_le_mul le_rfl (h_mono_f' h_le a), }, }
have h_measM_f' : ∀ n, measurable (f' n)
from λ n, (h_meas_f' n).mono hMg le_rfl
simp_rw [ennreal.mul_supr]
rw [lintegral_supr, lintegral_supr h_measM_f' h_mono_f', ennreal.mul_supr]
{ simp_rw [← h_ind_f'], }
simp_rw [← h_ind_f']
{ exact λ n, h_measM_f.mul (h_measM_f' n), }
exact λ n, h_measM_f.mul (h_measM_f' n)
exact λ n m (h_le : n ≤ m) a, ennreal.mul_le_mul le_rfl (h_mono_f' h_le a)
{ exact λ n m (h_le : n ≤ m) a, ennreal.mul_le_mul le_rfl (h_mono_f' h_le a), }
intros
obtain ⟨d, rfl⟩ := hdvd
exact is_coprime.of_mul_left_left h
intros
rw [add_val_pow, add_val_uniformizer h, nsmul_one]
intros
have h10 : (1 : R) ≠ 0 := one_ne_zero
have x0 : x ≠ 0 := ne_zero_of_coeff_ne_zero (right_ne_zero_of_mul_eq_one hr)
refine lt_of_le_of_ne ((add_val Γ R).map_le_sub (ge_of_eq (add_val Γ R).map_one) _) _
simp only [add_valuation.map_mul]
{ simp only [add_valuation.map_mul], rw [add_val_apply_of_ne x0, add_val_apply_of_ne (single_ne_zero h10), add_val_apply_of_ne _, order_C, order_single h10, with_top.coe_zero, zero_add, ← with_top.coe_add, neg_add_self, with_top.coe_zero], { exact le_refl 0 }, { exact C_ne_zero (left_ne_zero_of_mul_eq_one hr) } }
rw [add_val_apply_of_ne x0, add_val_apply_of_ne (single_ne_zero h10), add_val_apply_of_ne _, order_C, order_single h10, with_top.coe_zero, zero_add, ← with_top.coe_add, neg_add_self, with_top.coe_zero]
{ exact le_refl 0 }
exact le_refl 0
{ exact C_ne_zero (left_ne_zero_of_mul_eq_one hr) }
exact C_ne_zero (left_ne_zero_of_mul_eq_one hr)
rw [add_val_apply, ← with_top.coe_zero]
{ rw [add_val_apply, ← with_top.coe_zero], split_ifs, { apply with_top.coe_ne_top }, rw [ne.def, with_top.coe_eq_coe], intro con, apply coeff_order_ne_zero h, rw [← con, mul_assoc, sub_coeff, one_coeff, if_pos rfl, C_mul_eq_smul, smul_coeff, smul_eq_mul, ← add_neg_self x.order, single_mul_coeff_add, one_mul, hr, sub_self] }
split_ifs
{ apply with_top.coe_ne_top }
apply with_top.coe_ne_top
rw [ne.def, with_top.coe_eq_coe]
intro con
apply coeff_order_ne_zero h
rw [← con, mul_assoc, sub_coeff, one_coeff, if_pos rfl, C_mul_eq_smul, smul_coeff, smul_eq_mul, ← add_neg_self x.order, single_mul_coeff_add, one_mul, hr, sub_self]
intros
rcases (ring.not_is_field_iff_exists_ideal_bot_lt_and_lt_top.1 non_field) with ⟨I, Ibot, Itop⟩
split
finish
intro mle
apply @irrefl _ (<) _ (⊤ : ideal R)
have : M = ⊥ := eq_bot_iff.mpr mle
rw this at *
rwa hm.1.2 I Ibot at Itop
intros
refine ⟨λ h, H.ne_top (eq_top_iff.2 _), λ x y, _⟩
replace h := congr_arg (comap f) h
{ replace h := congr_arg (comap f) h, rw [comap_map_of_surjective _ hf, comap_top] at h, exact h ▸ sup_le (le_of_eq rfl) hk }
rw [comap_map_of_surjective _ hf, comap_top] at h
exact h ▸ sup_le (le_of_eq rfl) hk
refine λ hxy, (hf x).rec_on (λ a ha, (hf y).rec_on (λ b hb, _))
{ refine λ hxy, (hf x).rec_on (λ a ha, (hf y).rec_on (λ b hb, _)), rw [← ha, ← hb, ← ring_hom.map_mul, mem_map_iff_of_surjective _ hf] at hxy, rcases hxy with ⟨c, hc, hc'⟩, rw [← sub_eq_zero, ← ring_hom.map_sub] at hc', have : a * b ∈ I, { convert I.sub_mem hc (hk (hc' : c - a * b ∈ f.ker)), abel }, exact (H.mem_or_mem this).imp (λ h, ha ▸ mem_map_of_mem f h) (λ h, hb ▸ mem_map_of_mem f h) }
rw [← ha, ← hb, ← ring_hom.map_mul, mem_map_iff_of_surjective _ hf] at hxy
rcases hxy with ⟨c, hc, hc'⟩
rw [← sub_eq_zero, ← ring_hom.map_sub] at hc'
have : a * b ∈ I
convert I.sub_mem hc (hk (hc' : c - a * b ∈ f.ker))
{ convert I.sub_mem hc (hk (hc' : c - a * b ∈ f.ker)), abel }
abel
exact (H.mem_or_mem this).imp (λ h, ha ▸ mem_map_of_mem f h) (λ h, hb ▸ mem_map_of_mem f h)
intros
simp only [mul_comm, mem_mul_span_singleton]
intros
apply (nat.prime.dvd_mul hp).mp
rw ← int.nat_abs_mul
exact int.coe_nat_dvd_left.mp h
intros
refine ⟨is_localization.injective _ (le_non_zero_divisors_of_no_zero_divisors hM), λ x, _⟩
obtain ⟨r, ⟨m, hm⟩, rfl⟩ := mk'_surjective M x
obtain ⟨n, hn⟩ := hR.mul_inv_cancel (λ hm0, hM (hm0 ▸ hm) : m ≠ 0)
exact ⟨r * n, by erw [eq_mk'_iff_mul_eq, ← ring_hom.map_mul, mul_assoc, mul_comm n, hn, mul_one]⟩
intros
rw ← pow_one a
apply pow_dvd_of_le_multiplicity
simpa only [nat.cast_one, enat.pos_iff_one_le] using h
intros
rw [← sup_eq_left, smul_sup_eq_smul_sup_of_le_smul_of_le_jacobson hN' hIJ hNN, bot_smul, sup_bot_eq]
intros
suffices t : ∃ n : ℕ, ∀ m, n ≤ m → f (m+1) = ⊥
obtain ⟨n, w⟩ := t
{ obtain ⟨n, w⟩ := t, use n+1, rintros (_|m) p, { cases p, }, { apply w, exact nat.succ_le_succ_iff.mp p }, }
use n+1
rintros (_|m) p
{ cases p, }
cases p
apply w
{ apply w, exact nat.succ_le_succ_iff.mp p }
exact nat.succ_le_succ_iff.mp p
obtain ⟨n, w⟩ := monotone_stabilizes_iff_noetherian.mpr I (partial_sups f)
exact ⟨n, (λ m p, eq_bot_of_disjoint_absorbs (h m) ((eq.symm (w (m + 1) (le_add_right p))).trans (w m p)))⟩
intros
{ rw ring_hom.map_pow, exact f.2 n }
rw ring_hom.map_pow
exact f.2 n
intros
simp [nat_degree]
intros
simp_rw [degree_lt, submodule.mem_infi, linear_map.mem_ker, degree, finset.sup_lt_iff (with_bot.bot_lt_coe n), mem_support_iff, with_bot.some_eq_coe, with_bot.coe_lt_coe, lt_iff_not_ge', ne, not_imp_not]
{ simp_rw [degree_lt, submodule.mem_infi, linear_map.mem_ker, degree, finset.sup_lt_iff (with_bot.bot_lt_coe n), mem_support_iff, with_bot.some_eq_coe, with_bot.coe_lt_coe, lt_iff_not_ge', ne, not_imp_not], refl }
refl
intros
rintros r ⟨q, h⟩
exact is_unit_of_mul_eq_one r (q.coeff p.nat_degree) (by rwa [←coeff_C_mul, ←h])
intros
{ have aux := mt (@hφ d) hd, classical, rwa not_not at aux }
have aux := mt (@hφ d) hd
classical
rwa not_not at aux
intros
apply is_root_of_eval₂_map_eq_zero (is_fraction_ring.injective A K)
refine scale_roots_aeval_eq_zero_of_aeval_mk'_eq_zero _
rw mk'_num_denom
exact hr
intros
simp only [inv_fun, eval₂_add]
intros
rw linear_independent_iff
intros p hp
set f : polynomial K := p.sum (λ i, monomial i) with hf0
have f_def : ∀ (i : fin _), f.coeff i = p i
intro i
{ intro i, simp only [f, finsupp.sum, coeff_monomial, finset_sum_coeff], rw [finset.sum_eq_single, if_pos rfl], { intros b _ hb, rw if_neg (mt (λ h, _) hb), exact fin.coe_injective h }, { intro hi, split_ifs; { exact finsupp.not_mem_support_iff.mp hi } } }
simp only [f, finsupp.sum, coeff_monomial, finset_sum_coeff]
rw [finset.sum_eq_single, if_pos rfl]
intros b _ hb
{ intros b _ hb, rw if_neg (mt (λ h, _) hb), exact fin.coe_injective h }
rw if_neg (mt (λ h, _) hb)
exact fin.coe_injective h
intro hi
{ intro hi, split_ifs; { exact finsupp.not_mem_support_iff.mp hi } }
split_ifs; { exact finsupp.not_mem_support_iff.mp hi }
split_ifs
{ exact finsupp.not_mem_support_iff.mp hi }
exact finsupp.not_mem_support_iff.mp hi
{ exact finsupp.not_mem_support_iff.mp hi }
have f_def' : ∀ i, f.coeff i = if hi : i < _ then p ⟨i, hi⟩ else 0
intro i
{ intro i, split_ifs with hi, { exact f_def ⟨i, hi⟩ }, simp only [f, finsupp.sum, coeff_monomial, finset_sum_coeff], apply finset.sum_eq_zero, rintro ⟨j, hj⟩ -, apply if_neg (mt _ hi), rintro rfl, exact hj }
split_ifs with hi
{ exact f_def ⟨i, hi⟩ }
exact f_def ⟨i, hi⟩
simp only [f, finsupp.sum, coeff_monomial, finset_sum_coeff]
apply finset.sum_eq_zero
rintro ⟨j, hj⟩ -
apply if_neg (mt _ hi)
rintro rfl
exact hj
suffices : f = 0
ext i
{ ext i, rw [← f_def, this, coeff_zero, finsupp.zero_apply] }
rw [← f_def, this, coeff_zero, finsupp.zero_apply]
contrapose hp with hf
intro h
have : (minpoly K x).degree ≤ f.degree
apply minpoly.degree_le_of_ne_zero K x hf
{ apply minpoly.degree_le_of_ne_zero K x hf, convert h, simp_rw [finsupp.total_apply, aeval_def, hf0, finsupp.sum, eval₂_finset_sum], apply finset.sum_congr rfl, rintro i -, simp only [algebra.smul_def, eval₂_monomial] }
convert h
simp_rw [finsupp.total_apply, aeval_def, hf0, finsupp.sum, eval₂_finset_sum]
apply finset.sum_congr rfl
rintro i -
simp only [algebra.smul_def, eval₂_monomial]
have : ¬ (minpoly K x).degree ≤ f.degree
apply not_le_of_lt
{ apply not_le_of_lt, rw [degree_eq_nat_degree (minpoly.ne_zero hx), degree_lt_iff_coeff_zero], intros i hi, rw [f_def' i, dif_neg], exact hi.not_lt }
rw [degree_eq_nat_degree (minpoly.ne_zero hx), degree_lt_iff_coeff_zero]
intros i hi
rw [f_def' i, dif_neg]
exact hi.not_lt
contradiction
intros
ext1 n
simp only [coeff_mul, finset.sum_mul, finset.mul_sum, finset.sum_sigma']
refine finset.sum_bij (λ p _, ⟨(p.2.1, p.2.2 + p.1.2), (p.2.2, p.1.2)⟩) _ _ _ _
refine finset.sum_bij (λ p _, ⟨(p.2.1, p.2.2 + p.1.2), (p.2.2, p.1.2)⟩) _ _ _ _; simp only [mem_antidiagonal, finset.mem_sigma, heq_iff_eq, prod.mk.inj_iff, and_imp, exists_prop]
simp only [mem_antidiagonal, finset.mem_sigma, heq_iff_eq, prod.mk.inj_iff, and_imp, exists_prop]
rintros ⟨⟨i,j⟩, ⟨k,l⟩⟩
{ rintros ⟨⟨i,j⟩, ⟨k,l⟩⟩, dsimp only, rintro rfl rfl, simp [add_assoc] }
dsimp only
rintro rfl rfl
simp [add_assoc]
simp only [mem_antidiagonal, finset.mem_sigma, heq_iff_eq, prod.mk.inj_iff, and_imp, exists_prop]
rintros ⟨⟨a, b⟩, ⟨c, d⟩⟩
{ rintros ⟨⟨a, b⟩, ⟨c, d⟩⟩, dsimp only, rintro rfl rfl, apply mul_assoc }
dsimp only
rintro rfl rfl
apply mul_assoc
simp only [mem_antidiagonal, finset.mem_sigma, heq_iff_eq, prod.mk.inj_iff, and_imp, exists_prop]
rintros ⟨⟨a, b⟩, ⟨c, d⟩⟩ ⟨⟨i, j⟩, ⟨k, l⟩⟩
{ rintros ⟨⟨a, b⟩, ⟨c, d⟩⟩ ⟨⟨i, j⟩, ⟨k, l⟩⟩, dsimp only, rintro rfl rfl - rfl rfl - rfl rfl, refl }
dsimp only
rintro rfl rfl - rfl rfl - rfl rfl
refl
simp only [mem_antidiagonal, finset.mem_sigma, heq_iff_eq, prod.mk.inj_iff, and_imp, exists_prop]
rintro ⟨⟨i, j⟩, ⟨k, l⟩⟩
{ rintro ⟨⟨i, j⟩, ⟨k, l⟩⟩, dsimp only, rintro rfl rfl, refine ⟨⟨(i + k, l), (i, k)⟩, _, _⟩; simp [add_assoc] }
dsimp only
rintro rfl rfl
refine ⟨⟨(i + k, l), (i, k)⟩, _, _⟩; simp [add_assoc]
refine ⟨⟨(i + k, l), (i, k)⟩, _, _⟩
simp [add_assoc]
intros
rw [X_pow_eq, coeff_monomial]
intros
split
intro hξ
{ intro hξ, obtain ⟨i, hik, rfl⟩ := h.eq_pow_of_mem_roots_of_unity hξ.pow_eq_one, rw h.pow_iff_coprime k.pos at hξ, exact ⟨i, hik, hξ, rfl⟩ }
obtain ⟨i, hik, rfl⟩ := h.eq_pow_of_mem_roots_of_unity hξ.pow_eq_one
rw h.pow_iff_coprime k.pos at hξ
exact ⟨i, hik, hξ, rfl⟩
{ rintro ⟨i, -, hi, rfl⟩, exact h.pow_of_coprime i hi }
rintro ⟨i, -, hi, rfl⟩
exact h.pow_of_coprime i hi
intros
{ rw sub_eq_add_neg, exact s.add_mem hx (s.neg_mem hy) }
rw sub_eq_add_neg
exact s.add_mem hx (s.neg_mem hy)
intros
map_fun_tac
intros
apply constant_coeff_witt_structure_int p _ _ n
simp only [sub_zero, ring_hom.map_sub, constant_coeff_X]
intros
let P : ℕ → Prop := λ n, y.coeff n = 0
haveI : decidable_pred P := classical.dec_pred P
set z := mk p (λ n, if P n then x.coeff n else y.coeff n) with hz
have hx : select P z = x
ext1 n
{ ext1 n, rw [select, coeff_mk, coeff_mk], split_ifs with hn, { refl }, { rw (h n).resolve_right hn } }
rw [select, coeff_mk, coeff_mk]
split_ifs with hn
refl
{ refl }
rw (h n).resolve_right hn
{ rw (h n).resolve_right hn }
have hy : select (λ i, ¬ P i) z = y
ext1 n
{ ext1 n, rw [select, coeff_mk, coeff_mk], split_ifs with hn, { exact hn.symm }, { refl } }
rw [select, coeff_mk, coeff_mk]
split_ifs with hn
exact hn.symm
{ exact hn.symm }
refl
{ refl }
calc (x + y).coeff n = z.coeff n : by rw [← hx, ← hy, select_add_select_not P z] ... = x.coeff n + y.coeff n : _
dsimp [z]
split_ifs with hn
{ dsimp [P] at hn, rw [hn, add_zero] }
dsimp [P] at hn
rw [hn, add_zero]
{ rw [(h n).resolve_right hn, zero_add] }
rw [(h n).resolve_right hn, zero_add]
intros
obtain ⟨x, rfl⟩ := witt_vector.truncate_surjective p n₃ R x
simp only [truncate_witt_vector_truncate]
intros
apply sum_congr rfl
rintro i -
rw [monomial_eq, finsupp.prod_single_index]
rw pow_zero
intros
convert sup_eq_zero
exact subtype.is_empty_of_false (λ x, (zero_le _).not_lt)
intros
{ rw [mul_comm, mul_eq_left hb ha ha'] }
rw [mul_comm, mul_eq_left hb ha ha']
intros
{cases x, cases y, refl}
cases x
cases y
refl
intros
have := f.lt_top f.top
rw [show f f.top = f.top, from initial_seg.eq ↑f (initial_seg.refl r) f.top] at this
exact irrefl _ this
intros
simp only [le_antisymm_iff, add_le_add_iff_left]
rw lt_def
left
use punit.star
split
split; rintro ⟨ ⟩
rintro ⟨ ⟩
rintro ⟨ ⟩
intros
simp [h₂.symm, h₁.symm, term, smul, nsmul_add, mul_nsmul]
intros
simp
intros
simpa [normalize_fin_lt] using h
intros
cc
intros
cases f with xs hperm hnodup
generalize h₀ : map sigma.fst xs = xs₀
generalize h₁ : xs.map (@id ((Σ _ : α, α) → α) $ @sigma.snd α (λ _ : α, α)) = xs₁
dsimp [id] at h₁
have hxs : xs = total_function.list.to_finmap' (xs₀.zip xs₁)
rw [← h₀, ← h₁, list.to_finmap']
{ rw [← h₀, ← h₁, list.to_finmap'], clear h₀ h₁ xs₀ xs₁ hperm hnodup, induction xs, case list.nil { simp only [zip_nil_right, map_nil] }, case list.cons : xs_hd xs_tl xs_ih { simp only [true_and, to_sigma, eq_self_iff_true, sigma.eta, zip_cons_cons, list.map], exact xs_ih }, }
clear h₀ h₁ xs₀ xs₁ hperm hnodup
induction xs
case list.nil { simp only [zip_nil_right, map_nil] }
simp only [zip_nil_right, map_nil]
case list.cons : xs_hd xs_tl xs_ih { simp only [true_and, to_sigma, eq_self_iff_true, sigma.eta, zip_cons_cons, list.map], exact xs_ih }
simp only [true_and, to_sigma, eq_self_iff_true, sigma.eta, zip_cons_cons, list.map]
exact xs_ih
revert hperm hnodup
rw hxs
intros
apply apply_id_injective
{ rwa [← h₀, hxs, hperm.nodup_iff], }
rwa [← h₀, hxs, hperm.nodup_iff]
{ rwa [← hxs, h₀, h₁] at hperm, }
rwa [← hxs, h₀, h₁] at hperm
intros
rw [coe_injective.compl_image_eq, compl_range_coe]
intros
simpa only using h.map (add_monoid_hom.mul_left a₂) (continuous_const.mul continuous_id)
intros
suffices : ring.inverse ((((continuous_linear_equiv.units_equiv _ _).symm e) : M →L[R] M)) = inverse ↑e
{ convert this }
convert this
simp
refl
intros
refine mem_of_superset (set_pi_mem_nhds (finite.of_fintype _) (λ i _, _)) (pi_univ_Ico_subset a b)
exact Ico_mem_nhds (ha i) (hb i)
intros
simpa only [mul_comm] using hg.at_top_mul hC hf
intros
simp [frontier]
intros
refine subset.antisymm set_of_is_preconnected_subset_of_ordered _
simp only [subset_def, -mem_range, forall_range_iff, uncurry, or_imp_distrib, forall_and_distrib, mem_union, mem_set_of_eq, insert_eq, mem_singleton_iff, forall_eq, forall_true_iff, and_true, is_preconnected_Icc, is_preconnected_Ico, is_preconnected_Ioc, is_preconnected_Ioo, is_preconnected_Ioi, is_preconnected_Iio, is_preconnected_Ici, is_preconnected_Iic, is_preconnected_univ, is_preconnected_empty]
intros
have ha : a ∈ Ici a := left_mem_Ici
have has : a ∈ s := mem_of_mem_nhds_within ha hs
refine tendsto_order.2 ⟨λ b hb, _, λ b hb, _⟩
filter_upwards [hs, self_mem_nhds_within]
{ filter_upwards [hs, self_mem_nhds_within], intros x hxs hxa, exact hb.trans_le ((h_mono.le_iff_le has hxs).2 hxa) }
intros x hxs hxa
exact hb.trans_le ((h_mono.le_iff_le has hxs).2 hxa)
rcases hfs b hb with ⟨c, hcs, hac, hcb⟩
{ rcases hfs b hb with ⟨c, hcs, hac, hcb⟩, rw [h_mono.lt_iff_lt has hcs] at hac, filter_upwards [hs, Ico_mem_nhds_within_Ici (left_mem_Ico.2 hac)], rintros x hx ⟨hax, hxc⟩, exact ((h_mono.lt_iff_lt hx hcs).2 hxc).trans_le hcb }
rw [h_mono.lt_iff_lt has hcs] at hac
filter_upwards [hs, Ico_mem_nhds_within_Ici (left_mem_Ico.2 hac)]
rintros x hx ⟨hax, hxc⟩
exact ((h_mono.lt_iff_lt hx hcs).2 hxc).trans_le hcb
intros
rw [←pfun.preimage_univ]; exact h _ is_open_univ
rw [←pfun.preimage_univ]
exact h _ is_open_univ
intros
rw [closure_compl, frontier, diff_eq]
intros
suffices : epi f ↔ epi ((forget Top).map f)
{ rw [this, category_theory.epi_iff_surjective], refl }
rw [this, category_theory.epi_iff_surjective]
refl
split
{ apply left_adjoint_preserves_epi adj₂ }
apply left_adjoint_preserves_epi adj₂
{ apply faithful_reflects_epi }
apply faithful_reflects_epi
intros
split
rintros ⟨h, ⟨x⟩⟩
{ rintros ⟨h, ⟨x⟩⟩, exactI ⟨x, eq_univ_of_univ_subset $ is_preconnected_univ.subset_connected_component (mem_univ x)⟩ }
exactI ⟨x, eq_univ_of_univ_subset $ is_preconnected_univ.subset_connected_component (mem_univ x)⟩
rintros ⟨x, h⟩
{ rintros ⟨x, h⟩, haveI : preconnected_space α := ⟨by { rw ← h, exact is_preconnected_connected_component }⟩, exact ⟨⟨x⟩⟩ }
haveI : preconnected_space α := ⟨by { rw ← h, exact is_preconnected_connected_component }⟩
exact ⟨⟨x⟩⟩
intros
{ rw nhds_prod_eq, exact ha.prod hb }
rw nhds_prod_eq
exact ha.prod hb
intros
cases f; cases g; cases h; refl
cases f; cases g; cases h
cases f; cases g
cases f
cases g
cases h
refl
intros
convert sup_mem_subalgebra_closure A f g
apply set_like.ext'
symmetry
erw closure_eq_iff_is_closed
exact h
intros
rw [← singleton_union, nhds_within_union, nhds_within_singleton]
intros
haveI := (mem_closure_iff_nhds_within_ne_bot.1 hx)
haveI := (mem_closure_iff_nhds_within_ne_bot.1 hx); exact (mem_closure_of_tendsto h $ mem_of_superset self_mem_nhds_within (subset_preimage_image f s))
exact (mem_closure_of_tendsto h $ mem_of_superset self_mem_nhds_within (subset_preimage_image f s))
intros
rw [local_triv_at, local_triv_apply, coord_change_self]
{ rw [local_triv_at, local_triv_apply, coord_change_self], exact Z.mem_base_set_at b }
exact Z.mem_base_set_at b
intros
ext x
cases x
simp
intros
rw [← not_iff_not, not_not, not_summable_iff_tendsto_nat_at_top_of_nonneg hf]
intros
rw [e.restr_source, hs.interior_eq]
intros
convert ←hf.open_iff_image_open.symm
rwa [image_preimage_eq_inter_range, inter_eq_self_of_subset_left]
intros
refine ⟨λ H ε hε, H _ (dist_mem_uniformity hε), λ H u hu x hx, _⟩
rcases mem_uniformity_dist.1 hu with ⟨ε, εpos, hε⟩
rcases H ε εpos x hx with ⟨t, ht, Ht⟩
exact ⟨t, ht, Ht.mono (λ n hs x hx, hε (hs x hx))⟩
intros
rw edist_comm z; apply edist_triangle
rw edist_comm z
apply edist_triangle
intros
simp [Hausdorff_dist]
intros
{ rw ← image_univ, exact hf.diam_image univ }
rw ← image_univ
exact hf.diam_image univ
intros
simp [lipschitz_on_with, lipschitz_with]
intros
refine congr_arg _ (finprod_cond_eq_prod_of_cond_iff _ (λ j hj, _))
rw [ne.def, sub_eq_self] at hj
rw [finset.mem_filter, iff.comm, and_iff_right_iff_imp]
exact flip (ht j) hj
intros
simp_rw [← upper_semicontinuous_within_at_univ_iff] at *
{ simp_rw [← upper_semicontinuous_within_at_univ_iff] at *, exact hf.add' hg hcont }
exact hf.add' hg hcont
intros
constructor
rw discrete_topology.eq_bot Y
exact induced_bot hf
intros
rw [stalk_pushforward, germ, colimit.ι_map_assoc, colimit.ι_pre, whisker_right_app]
erw [category_theory.functor.map_id, category.id_comp]
refl
intros
simp [has_basis_coclosed_compact.mem_iff, and_assoc]
intros
rcases compact_univ.ultrafilter_le_nhds F (by simp) with ⟨x, -, h⟩
exact le_nhds_Lim ⟨x,h⟩
intros
cases x
refine mem_of_superset (union_mem_uniformity_sum (mem_nhds_uniformity_iff_right.1 (is_open.mem_nhds hs.1 xs)) univ_mem) (union_subset _ _)
refine mem_of_superset (union_mem_uniformity_sum (mem_nhds_uniformity_iff_right.1 (is_open.mem_nhds hs.1 xs)) univ_mem) (union_subset _ _); rintro _ ⟨⟨_, b⟩, h, ⟨⟩⟩ ⟨⟩
{ refine mem_of_superset (union_mem_uniformity_sum (mem_nhds_uniformity_iff_right.1 (is_open.mem_nhds hs.1 xs)) univ_mem) (union_subset _ _); rintro _ ⟨⟨_, b⟩, h, ⟨⟩⟩ ⟨⟩, exact h rfl }
rintro _ ⟨⟨_, b⟩, h, ⟨⟩⟩ ⟨⟩
exact h rfl
rintro _ ⟨⟨_, b⟩, h, ⟨⟩⟩ ⟨⟩
refine mem_of_superset (union_mem_uniformity_sum univ_mem (mem_nhds_uniformity_iff_right.1 (is_open.mem_nhds hs.2 xs))) (union_subset _ _)
refine mem_of_superset (union_mem_uniformity_sum univ_mem (mem_nhds_uniformity_iff_right.1 (is_open.mem_nhds hs.2 xs))) (union_subset _ _); rintro _ ⟨⟨a, _⟩, h, ⟨⟩⟩ ⟨⟩
{ refine mem_of_superset (union_mem_uniformity_sum univ_mem (mem_nhds_uniformity_iff_right.1 (is_open.mem_nhds hs.2 xs))) (union_subset _ _); rintro _ ⟨⟨a, _⟩, h, ⟨⟩⟩ ⟨⟩, exact h rfl }
rintro _ ⟨⟨a, _⟩, h, ⟨⟩⟩ ⟨⟩
rintro _ ⟨⟨a, _⟩, h, ⟨⟩⟩ ⟨⟩
exact h rfl
intros
rw mem_ball_symmetry hV at hx
exact ⟨z, hx, hy⟩
intros
rw separation_rel_eq_inter_closure
apply is_closed_sInter
rintros _ ⟨t, t_in, rfl⟩
exact is_closed_closure
intros
simpa using x.2.2
intros
simp [pure_seq_eq_map]
intros
cases b; simp
cases b
simp
simp
intros
have h := int.le_neg_add_of_add_le (int.sub_left_le_of_le_add h)
rwa int.add_comm at h
intros
simp [join, list.bind]
intros
rw [div_def a, if_pos]
split
split ; assumption
assumption
assumption
intros
rw [←zero_add (p -ᵥ p), ←vadd_vsub_assoc, vadd_vsub]
intros
intros f g w
ext
exact congr_fun w a
intros
suffices : span R (t : set A) * (⨆ i, span R (s i)) = (⨆ i, span R t * span R (s i))
{ simpa only [span_eq] using this }
simpa only [span_eq] using this
simp_rw [span_mul_span, ← span_Union, span_mul_span, set.mul_Union]
intros
ext x
{ ext x, simp [mem_bot, -set.singleton_one, submodule.mem_span_singleton, algebra.smul_def] }
simp [mem_bot, -set.singleton_one, submodule.mem_span_singleton, algebra.smul_def]
intros
rw [algebra_map_eq R S A, ring_hom.comp_apply]
intros
classical
{ classical, simp_rw [prod_eq_mul_prod_diff_singleton hi, ← h1, right_distrib], congr' 2; apply prod_congr rfl; simpa }
simp_rw [prod_eq_mul_prod_diff_singleton hi, ← h1, right_distrib]
congr' 2; apply prod_congr rfl; simpa
congr' 2; apply prod_congr rfl
congr' 2
apply prod_congr rfl
simpa
apply prod_congr rfl
simpa
intros
split_ifs
haveI : unique p := ⟨⟨h⟩, λ _, rfl⟩
{ haveI : unique p := ⟨⟨h⟩, λ _, rfl⟩, exact finprod_unique f }
exact finprod_unique f
haveI : is_empty p := ⟨h⟩
{ haveI : is_empty p := ⟨h⟩, exact finprod_of_is_empty f }
exact finprod_of_is_empty f
intros
simp [@eq_comm _ a]
intros
rw [← sum_range_id_mul_two n, nat.mul_div_cancel]
rw [← sum_range_id_mul_two n, nat.mul_div_cancel]; exact dec_trivial
exact dec_trivial
intros
refine le_trans (multiset.le_prod_of_submultiplicative f h_one h_mul _) _
rw multiset.map_map
refl
intros
simpa [w] using nat_mul_inj h
intros
simp [of_h_eq_int_fract_pair_seq1_fst_b, int_fract_pair.of]
intros
simp only [denom_eq_conts_b, (continuants_stable_of_terminated n_le_m terminated_at_n)]
intros
rw of_mul_of
dsimp [has_mul.mul, direct_sum.of, dfinsupp.single_add_hom_apply]
congr' 1
rw zero_add
apply eq_rec_heq
intros
rw [dvd_add_iff_right (h.mul_right _), div_add_mod]
intros
simpa only [div_eq_mul_inv] using (right_distrib a b (c⁻¹)).symm
intros
{ ext, simp [ceil_le, lt_ceil] }
ext
simp [ceil_le, lt_ceil]
intros
let s : subalgebra R (free_algebra R X) := { carrier := C, mul_mem' := h_mul, add_mem' := h_add, algebra_map_mem' := h_grade0, }
let of : X → s := subtype.coind (ι R) h_grade1
have of_id : alg_hom.id R (free_algebra R X) = s.val.comp (lift R of)
ext
{ ext, simp [of, subtype.coind], }
simp [of, subtype.coind]
convert subtype.prop (lift R of a)
simp [alg_hom.ext_iff] at of_id
exact of_id a
intros
rw [← gcd_erase_dup, erase_dup_ext.2, gcd_erase_dup, gcd_cons]
{ rw [← gcd_erase_dup, erase_dup_ext.2, gcd_erase_dup, gcd_cons], simp }
simp
intros
simp [geom_sum_def]
intros
rw [mul_eq_one_iff_eq_inv, inv_inv]
intros
simp only [mul_assoc, h.eq]
intros
unfold semiconj_by; rw [units.inv_mul_cancel_right]
unfold semiconj_by
rw [units.inv_mul_cancel_right]
intros
simp only [sq, add_mul_self_eq]
intros
by_cases ab : a ≤ b
{ exact abs_add_eq_add_abs_le ab }
exact abs_add_eq_add_abs_le ab
rw [add_comm a, add_comm (abs _), abs_add_eq_add_abs_le ((not_le.mp ab).le), and.comm, @and.comm (b ≤ 0 ) _]
{ rw [add_comm a, add_comm (abs _), abs_add_eq_add_abs_le ((not_le.mp ab).le), and.comm, @and.comm (b ≤ 0 ) _] }
intros
simp
intros
{ rw div_eq_mul_inv, exact mul_ne_zero ha (inv_ne_zero hb) }
rw div_eq_mul_inv
exact mul_ne_zero ha (inv_ne_zero hb)
intros
rw [← mul_div_assoc, div_mul_cancel _ hc]
intros
{ dsimp [augment], rcases i with _|i, refl, refl, }
dsimp [augment]
rcases i with _|i
refl
refl
intros
rcases h : c.next i with _ | ⟨j,w⟩
{ simp [h] }
simp [h]
{ simp [d_from_eq _ w, next_eq _ w] }
simp [d_from_eq _ w, next_eq _ w]
intros
dsimp [prev_d]
rw c.prev_eq_some w
refl
intros
tidy
intros
{ simp only [indicator], split_ifs, { refl }, rw [zero_mul] }
simp only [indicator]
split_ifs
refl
{ refl }
rw [zero_mul]
intros
suffices : ⁅I, N⁆ ≤ ⊥
from le_bot_iff.mp this
rw [lie_ideal_oper_eq_span, lie_submodule.lie_span_le]
rintros m ⟨x, n, h⟩
rw trivial_lie_zero at h
simp [← h]
intros
rw le_inf_iff
{ rw le_inf_iff, split; apply mono_lie_left; [exact inf_le_left, exact inf_le_right], }
split
split; apply mono_lie_left; [exact inf_le_left, exact inf_le_right]
split; apply mono_lie_left
apply mono_lie_left
exact inf_le_left
apply mono_lie_left
exact inf_le_right
intros
ext y
simp only [ad_apply, lie_hom.coe_to_linear_map, lie_subalgebra.coe_incl, linear_map.coe_comp, lie_subalgebra.coe_bracket, function.comp_app]
intros
rw [← derived_series_eq_derived_series_of_ideal_map, map_eq_bot_iff, ker_incl, eq_bot_iff]
intros
{ ext, simp only [ideal_range, range_eq_map], refl }
ext
simp only [ideal_range, range_eq_map]
refl
intros
rw [inv_eq_one_div, mul_comm, ← div_eq_mul_one_div]
exact div_lt_iff' h
intros
rw [le_div_iff d0, div_mul_eq_mul_div, div_le_iff b0]
intros
by_cases h0 : a = 0
{ simp [h0], }
simp [h0]
rw ← ne.def at h0
{ rw ← ne.def at h0, exact (half_lt_self (lt_of_le_of_ne ha_nonneg h0.symm)).le, }
exact (half_lt_self (lt_of_le_of_ne ha_nonneg h0.symm)).le
intros
{ rw [← mul_le_mul_iff_right a], simp }
rw [← mul_le_mul_iff_right a]
simp
intros
rw [← mul_le_mul_iff_right b, one_mul, div_eq_mul_inv, inv_mul_cancel_right]
intros
simp [neg_lt_iff_pos_add, ← two_mul, mul_pos_iff, zero_lt_one, (@zero_lt_two α _ _).not_lt]
intros
cases a; simp [mul_def, h]; refl
cases a; simp [mul_def, h]
cases a
simp [mul_def, h]
refl
simp [mul_def, h]
refl
intros
haveI := @linear_order.decidable_le α _; exact lt_of_not_ge (assume h2 : a ≥ 0, (decidable.mul_nonneg h2 h1).not_lt h)
haveI := @linear_order.decidable_le α _
exact lt_of_not_ge (assume h2 : a ≥ 0, (decidable.mul_nonneg h2 h1).not_lt h)
intros
rw [← sub_pos, ← mul_sub]
exact ordered_ring.mul_pos _ _ h₂ (sub_pos.2 h₁)
intros
simpa only [sub_eq_neg_add] using h.nat_mul n (-x)
intros
{ simp only [← image_smul, image_subset, h] }
simp only [← image_smul, image_subset, h]
intros
induction t using quotient.induction_on
simpa using coeff_list_prod_of_nat_degree_le _ _ hl
intros
rw [discrim, sq]
obtain ha|rfl|ha : a < 0 ∨ a = 0 ∨ 0 < a := lt_trichotomy a 0
have : tendsto (λ x, (a * x + b) * x + c) at_top at_bot := tendsto_at_bot_add_const_right _ c ((tendsto_at_bot_add_const_right _ b (tendsto_id.neg_const_mul_at_top ha)).at_bot_mul_at_top tendsto_id)
{ have : tendsto (λ x, (a * x + b) * x + c) at_top at_bot := tendsto_at_bot_add_const_right _ c ((tendsto_at_bot_add_const_right _ b (tendsto_id.neg_const_mul_at_top ha)).at_bot_mul_at_top tendsto_id), rcases (this.eventually (eventually_lt_at_bot 0)).exists with ⟨x, hx⟩, exact false.elim ((h x).not_lt $ by rwa ← add_mul) }
rcases (this.eventually (eventually_lt_at_bot 0)).exists with ⟨x, hx⟩
exact false.elim ((h x).not_lt $ by rwa ← add_mul)
rcases em (b = 0) with (rfl|hb)
{ rcases em (b = 0) with (rfl|hb), { simp }, { have := h ((-c - 1) / b), rw [mul_div_cancel' _ hb] at this, linarith } }
{ simp }
simp
{ have := h ((-c - 1) / b), rw [mul_div_cancel' _ hb] at this, linarith }
have := h ((-c - 1) / b)
rw [mul_div_cancel' _ hb] at this
linarith
have := calc 4 * a * (a * (-(b / a) * (1 / 2)) * (-(b / a) * (1 / 2)) + b * (-(b / a) * (1 / 2)) + c) = (a * (b / a)) * (a * (b / a)) - 2 * (a * (b / a)) * b + 4 * a * c : by ring ... = -(b * b - 4 * a * c) : by { simp only [mul_div_cancel' b (ne_of_gt ha)], ring }
{ have := calc 4 * a * (a * (-(b / a) * (1 / 2)) * (-(b / a) * (1 / 2)) + b * (-(b / a) * (1 / 2)) + c) = (a * (b / a)) * (a * (b / a)) - 2 * (a * (b / a)) * b + 4 * a * c : by ring ... = -(b * b - 4 * a * c) : by { simp only [mul_div_cancel' b (ne_of_gt ha)], ring }, have ha' : 0 ≤ 4 * a, by linarith, have h := (mul_nonneg ha' (h (-(b / a) * (1 / 2)))), rw this at h, rwa ← neg_nonneg }
have ha' : 0 ≤ 4 * a
linarith
linarith
have h := (mul_nonneg ha' (h (-(b / a) * (1 / 2))))
rw this at h
rwa ← neg_nonneg
intros
cases q₁
cases q₂
congr'
rw [←q₁_i_mul_j, ←q₂_i_mul_j]
congr'
intros
{ rw ← smul_eq_mul at ab, exact ab.of_smul _ }
rw ← smul_eq_mul at ab
exact ab.of_smul _
intros
intros x y h'
rw ←sub_eq_zero
refine h _ _
rw [mul_sub, sub_eq_zero, h']
intros
ext x
simp only [mem_zero_locus, set.mem_preimage, comap_as_ideal, set.image_subset_iff]
refl
intros
substs hf hg
intros
have v_eq : v = (λ i, 0) := subsingleton.elim _ _
have zero_mem : (0 : E) ∈ emetric.ball (0 : E) r
simp [hf.r_pos]
simp [hf.r_pos]
have : ∀ i ≠ 0, pf i (λ j, 0) = 0
assume i hi
{ assume i hi, have : 0 < i := pos_iff_ne_zero.2 hi, exact continuous_multilinear_map.map_coord_zero _ (⟨0, this⟩ : fin i) rfl }
have : 0 < i := pos_iff_ne_zero.2 hi
exact continuous_multilinear_map.map_coord_zero _ (⟨0, this⟩ : fin i) rfl
have A := (hf.has_sum zero_mem).unique (has_sum_single _ this)
simpa [v_eq] using A.symm
intros
rcases huv.exists_pos with ⟨c, hc, hcuv⟩
rw is_O_with at hcuv
convert tendsto.at_top_div_const hc (tendsto_at_top_mono' l hcuv hu)
ext x
rw mul_div_cancel_left _ hc.ne.symm
intros
rw [← has_deriv_within_at_univ] at *
exact hd.const_mul c
intros
simpa using (has_fderiv_within_at.smul hc hf).has_deriv_within_at
intros
refine hf.iterate _ hx n
convert tendsto_inf.2 ⟨hf.continuous_within_at, _⟩
exacts [hx.symm, (tendsto_principal_principal.2 hs).mono_left inf_le_right]
intros
simp only [sub_eq_add_neg, differentiable_add_const_iff]
intros
refine ⟨λ H, _, λ H, iso.has_fderiv_at.comp_has_fderiv_within_at x H⟩
have A : f = iso.symm ∘ (iso ∘ f)
rw [← function.comp.assoc, iso.symm_comp_self]
rw [← function.comp.assoc, iso.symm_comp_self]
{ rw [← function.comp.assoc, iso.symm_comp_self], refl }
{ rw [← function.comp.assoc, iso.symm_comp_self], refl }
refl
refl
have B : f' = (iso.symm : F →L[𝕜] E).comp ((iso : E →L[𝕜] F).comp f')
rw [← continuous_linear_map.comp_assoc, iso.coe_symm_comp_coe, continuous_linear_map.id_comp]
rw [← continuous_linear_map.comp_assoc, iso.coe_symm_comp_coe, continuous_linear_map.id_comp]
rw [A, B]
exact iso.symm.has_fderiv_at.comp_has_fderiv_within_at x H
intros
simp only [differentiable_within_at, has_fderiv_within_at, has_fderiv_at_filter, nhds_within_restrict' s ht]
intros
simpa using h.neg.has_fderiv_within_at_nonpos hf.neg hy
intros
simp [times_cont_diff_on_univ.symm, times_cont_diff_on_top]
intros
rw ← h.zero_eq x hx
{ rw ← h.zero_eq x hx, symmetry, exact continuous_multilinear_map.uncurry0_curry0 _ }
symmetry
exact continuous_multilinear_map.uncurry0_curry0 _
intros
rw ← add_image_prod
{ rw ← add_image_prod, exact (hs.prod ht).is_linear_image is_linear_map.is_linear_map_add }
exact (hs.prod ht).is_linear_image is_linear_map.is_linear_map_add
intros
obtain ⟨B, hB⟩ := hF
refine ⟨(sInter_subset_of_mem hB).trans (hAF B hB).1, λ x₁ x₂ hx₁A hx₂A x hxF hx, _⟩
simp_rw mem_sInter at ⊢ hxF
have h := λ B hB, (hAF B hB).2 x₁ x₂ hx₁A hx₂A x (hxF B hB) hx
exact ⟨λ B hB, (h B hB).1, λ B hB, (h B hB).2⟩
intros
simpa [measure_univ] using hs.smul_integral_mem hsc (is_probability_measure.ne_zero μ) hf hfi
intros
simp only [inner_add_left, inner_add_right]; ring
simp only [inner_add_left, inner_add_right]
ring
intros
rw [is_R_or_C.ext_iff]; exact ⟨by rw [conj_re], by rw [conj_im, inner_self_im_zero, neg_zero]⟩
rw [is_R_or_C.ext_iff]
exact ⟨by rw [conj_re], by rw [conj_im, inner_self_im_zero, neg_zero]⟩
intros
rw closed_ball_eq_image
exact (proper_space.is_compact_closed_ball _ _).image to_euclidean.symm.continuous
intros
exact_mod_cast real.rpow_arith_mean_le_arith_mean_rpow s _ _ (λ i _, (w i).coe_nonneg) (by exact_mod_cast hw') (λ i _, (z i).coe_nonneg) hp
intros
convert (vadd_const 𝕜 (f p)).symm.isometry.comp (hf.comp (vadd_const 𝕜 p).isometry)
exact funext hg
intros
simpa [dist_eq_norm] using dist_triangle g 0 (-h)
intros
simp [dist_eq_norm]
intros
rw [← sub_eq_zero, eq_zero_iff_forall_dual_eq_zero 𝕜 (x - y)]
simp [sub_eq_zero]
intros
obtain ⟨_, ⟨m : M, H : mk' S m = x, rfl⟩, hnorm : ∥m∥ < ∥x∥ + ε⟩ := real.lt_Inf_add_pos (image_norm_nonempty x) hε
subst H
exact ⟨m, rfl, hnorm⟩
intros
{ ext1, simp [to_span_singleton_apply], }
ext1
simp [to_span_singleton_apply]
intros
rw [ennreal.tsum_eq_supr_nat' (nat.tendsto_pow_at_top_at_top_of_one_lt _root_.one_lt_two)]
refine supr_le (λ n, (finset.le_sum_condensed hf n).trans (add_le_add_left _ _))
simp only [nsmul_eq_mul, nat.cast_pow, nat.cast_two]
apply ennreal.sum_le_tsum
intros
rw [mem_ball, sub_zero]
simp [log]
intros
rw [← not_lt, log_neg_iff hx, not_lt]
intros
simp only [one_div, integral_inv_of_neg ha hb]
intros
rw [← abs_cos_eq_sqrt_one_sub_sin_sq, abs_of_nonneg (cos_nonneg_of_mem_Icc ⟨hl, hu⟩)]
rw [← of_real_cos, real.cos_pi]; simp
rw [← of_real_cos, real.cos_pi]
simp
intros
convert tan_add_mul_I h; exact (re_add_im z).symm
convert tan_add_mul_I h
exact (re_add_im z).symm
intros
have := aux_has_sum_of_le_geometric hr hu
convert dist_le_tsum_of_dist_le_of_tendsto _ hu ⟨_, this⟩ ha n
simp only [pow_add, mul_left_comm C, mul_div_right_comm]
rw [mul_comm]
exact (this.mul_left _).tsum_eq.symm
intros
intros A
refine ⟨punit, λ _, (left_adjoint G).obj A, λ _, (adjunction.of_right_adjoint G).unit.app A, _⟩
intros B h
refine ⟨punit.star, ((adjunction.of_right_adjoint G).hom_equiv _ _).symm h, _⟩
rw [←adjunction.hom_equiv_unit, equiv.apply_symm_apply]
intros
suffices : is_iso ((transfer_nat_trans_self adj₁ adj₂).symm (transfer_nat_trans_self adj₁ adj₂ f))
{ simpa using this }
simpa using this
apply_instance
intros
rw w
intros
{ dsimp [fun_inv_id_assoc], tidy }
dsimp [fun_inv_id_assoc]
tidy
intros
dsimp [coeq₃_hom]
slice_lhs 1 2 { rw coeq_condition f g }
simp only [category.assoc]
intros
rw h
intros
ext
ext; rw [←assoc, colimit.ι_map, assoc, colimit.ι_desc, colimit.ι_desc]; refl
ext; rw [←assoc, colimit.ι_map, assoc, colimit.ι_desc, colimit.ι_desc]
rw [←assoc, colimit.ι_map, assoc, colimit.ι_desc, colimit.ι_desc]
refl
intros
rw [iso.inv_comp_eq, ← category.assoc, iso.eq_comp_inv, prod.right_unitor_hom_naturality]
intros
{ ext, simp, }
ext
simp
intros
simp [image.pre_comp]
intros
{ simp, refl }
simp
refl
intros
simp only [left_unitor_tensor_inv, assoc, comp_id, hom_inv_id]
intros
intros X S hS
rw ← presieve.is_separated_for_and_exists_is_amalgamation_iff_sheaf_for
refine ⟨_, _⟩
rintro x ⟨M, hM⟩ ⟨N, hN⟩ hM₂ hN₂
{ rintro x ⟨M, hM⟩ ⟨N, hN⟩ hM₂ hN₂, ext, dsimp only [subtype.coe_mk], rw [← J₁.covers_iff_mem_of_closed hM, ← J₁.covers_iff_mem_of_closed hN], have q : ∀ ⦃Z : C⦄ (g : Z ⟶ X) (hg : S g), M.pullback g = N.pullback g, { intros Z g hg, apply congr_arg subtype.val ((hM₂ g hg).trans (hN₂ g hg).symm) }, have MSNS : M ⊓ S = N ⊓ S, { ext Z g, rw [sieve.inter_apply, sieve.inter_apply, and_comm (N g), and_comm], apply and_congr_right, intro hg, rw [sieve.pullback_eq_top_iff_mem, sieve.pullback_eq_top_iff_mem, q g hg] }, split, { intro hf, rw J₁.covers_iff, apply J₁.superset_covering (sieve.pullback_monotone f inf_le_left), rw ← MSNS, apply J₁.arrow_intersect f M S hf (J₁.pullback_stable _ hS) }, { intro hf, rw J₁.covers_iff, apply J₁.superset_covering (sieve.pullback_monotone f inf_le_left), rw MSNS, apply J₁.arrow_intersect f N S hf (J₁.pullback_stable _ hS) } }
ext
dsimp only [subtype.coe_mk]
rw [← J₁.covers_iff_mem_of_closed hM, ← J₁.covers_iff_mem_of_closed hN]
have q : ∀ ⦃Z : C⦄ (g : Z ⟶ X) (hg : S g), M.pullback g = N.pullback g
intros Z g hg
{ intros Z g hg, apply congr_arg subtype.val ((hM₂ g hg).trans (hN₂ g hg).symm) }
apply congr_arg subtype.val ((hM₂ g hg).trans (hN₂ g hg).symm)
have MSNS : M ⊓ S = N ⊓ S
ext Z g
{ ext Z g, rw [sieve.inter_apply, sieve.inter_apply, and_comm (N g), and_comm], apply and_congr_right, intro hg, rw [sieve.pullback_eq_top_iff_mem, sieve.pullback_eq_top_iff_mem, q g hg] }
rw [sieve.inter_apply, sieve.inter_apply, and_comm (N g), and_comm]
apply and_congr_right
intro hg
rw [sieve.pullback_eq_top_iff_mem, sieve.pullback_eq_top_iff_mem, q g hg]
split
intro hf
{ intro hf, rw J₁.covers_iff, apply J₁.superset_covering (sieve.pullback_monotone f inf_le_left), rw ← MSNS, apply J₁.arrow_intersect f M S hf (J₁.pullback_stable _ hS) }
rw J₁.covers_iff
apply J₁.superset_covering (sieve.pullback_monotone f inf_le_left)
rw ← MSNS
apply J₁.arrow_intersect f M S hf (J₁.pullback_stable _ hS)
intro hf
{ intro hf, rw J₁.covers_iff, apply J₁.superset_covering (sieve.pullback_monotone f inf_le_left), rw MSNS, apply J₁.arrow_intersect f N S hf (J₁.pullback_stable _ hS) }
rw J₁.covers_iff
apply J₁.superset_covering (sieve.pullback_monotone f inf_le_left)
rw MSNS
apply J₁.arrow_intersect f N S hf (J₁.pullback_stable _ hS)
intros x hx
{ intros x hx, rw presieve.compatible_iff_sieve_compatible at hx, let M := sieve.bind S (λ Y f hf, (x f hf).1), have : ∀ ⦃Y⦄ (f : Y ⟶ X) (hf : S f), M.pullback f = (x f hf).1, { intros Y f hf, apply le_antisymm, { rintro Z u ⟨W, g, f', hf', (hg : (x f' hf').1 _), c⟩, rw [sieve.pullback_eq_top_iff_mem, ←(show (x (u ≫ f) _).1 = (x f hf).1.pullback u, from congr_arg subtype.val (hx f u hf))], simp_rw ← c, rw (show (x (g ≫ f') _).1 = _, from congr_arg subtype.val (hx f' g hf')), apply sieve.pullback_eq_top_of_mem _ hg }, { apply sieve.le_pullback_bind S (λ Y f hf, (x f hf).1) } }, refine ⟨⟨_, J₁.close_is_closed M⟩, _⟩, { intros Y f hf, ext1, dsimp, rw [← J₁.pullback_close, this _ hf], apply le_antisymm (J₁.le_close_of_is_closed (le_refl _) (x f hf).2) (J₁.le_close _) } }
rw presieve.compatible_iff_sieve_compatible at hx
let M := sieve.bind S (λ Y f hf, (x f hf).1)
have : ∀ ⦃Y⦄ (f : Y ⟶ X) (hf : S f), M.pullback f = (x f hf).1
intros Y f hf
{ intros Y f hf, apply le_antisymm, { rintro Z u ⟨W, g, f', hf', (hg : (x f' hf').1 _), c⟩, rw [sieve.pullback_eq_top_iff_mem, ←(show (x (u ≫ f) _).1 = (x f hf).1.pullback u, from congr_arg subtype.val (hx f u hf))], simp_rw ← c, rw (show (x (g ≫ f') _).1 = _, from congr_arg subtype.val (hx f' g hf')), apply sieve.pullback_eq_top_of_mem _ hg }, { apply sieve.le_pullback_bind S (λ Y f hf, (x f hf).1) } }
apply le_antisymm
rintro Z u ⟨W, g, f', hf', (hg : (x f' hf').1 _), c⟩
{ rintro Z u ⟨W, g, f', hf', (hg : (x f' hf').1 _), c⟩, rw [sieve.pullback_eq_top_iff_mem, ←(show (x (u ≫ f) _).1 = (x f hf).1.pullback u, from congr_arg subtype.val (hx f u hf))], simp_rw ← c, rw (show (x (g ≫ f') _).1 = _, from congr_arg subtype.val (hx f' g hf')), apply sieve.pullback_eq_top_of_mem _ hg }
rw [sieve.pullback_eq_top_iff_mem, ←(show (x (u ≫ f) _).1 = (x f hf).1.pullback u, from congr_arg subtype.val (hx f u hf))]
simp_rw ← c
rw (show (x (g ≫ f') _).1 = _, from congr_arg subtype.val (hx f' g hf'))
apply sieve.pullback_eq_top_of_mem _ hg
{ apply sieve.le_pullback_bind S (λ Y f hf, (x f hf).1) }
apply sieve.le_pullback_bind S (λ Y f hf, (x f hf).1)
refine ⟨⟨_, J₁.close_is_closed M⟩, _⟩
intros Y f hf
{ intros Y f hf, ext1, dsimp, rw [← J₁.pullback_close, this _ hf], apply le_antisymm (J₁.le_close_of_is_closed (le_refl _) (x f hf).2) (J₁.le_close _) }
ext1
dsimp
rw [← J₁.pullback_close, this _ hf]
apply le_antisymm (J₁.le_close_of_is_closed (le_refl _) (x f hf).2) (J₁.le_close _)
intros
intros Y₁ Y₂ Z g₁ g₂ f₁ f₂ h₁ h₂ comm
rw [←(some_spec (some_spec (some_spec h₁))).2, ←(some_spec (some_spec (some_spec h₂))).2, ←assoc, ←assoc] at comm
dsimp [family_of_elements.sieve_extend]
rw [← functor_to_types.map_comp_apply, ← functor_to_types.map_comp_apply]
apply hx _ _ _ _ comm
intros
{ ext, simp, }
ext
simp
intros
rw [le_iff_le_iff_lt_iff_lt, sum_two_pow_lt_iff_lt]
intros
rw set.eq_empty_iff_forall_not_mem
intros f hyp
rw remove_none.mem_fiber at hyp
rcases hyp with ⟨F, F_derangement, F_none, _⟩
exact F_derangement none F_none
intros
ext i j
obtain (h'|h') := h.zero_or_one i j; simp [h']
obtain (h'|h') := h.zero_or_one i j
simp [h']
simp [h']
intros
obtain ⟨t, ht : _ = _⟩ := finset.max_of_mem (mem_image_of_mem (λ v, G.degree v) (mem_univ v))
have := finset.le_max_of_mem (mem_image_of_mem _ (mem_univ v)) ht
rwa [max_degree, ht, option.get_or_else_some]
intros
refl
intros
simpa using hf.comp' (partrec'.cons hg partrec'.nil)
intros
simpa [bind_some_eq_map] using @@partrec.bind _ _ _ (λ a b, part.some (g a b)) hf hg
intros
simp! [(<*>)]
intros
simp [nil]
intros
rcases s with _|_|_; refl
rcases s with _|_|_
refl
refl
refl
intros
conv {to_rhs, rw ← T.move_right_left}; rw [tape.move_left_nth, add_sub_cancel]
conv {to_rhs, rw ← T.move_right_left}
rw [tape.move_left_nth, add_sub_cancel]
intros
simp only [to_list_spec,free.map_eq_map,fold_map_hom (free.map.is_monoid_hom f), fold_map_map]
simp only [to_list_spec,free.map_eq_map,fold_map_hom (free.map.is_monoid_hom f), fold_map_map]; refl
{ simp only [to_list_spec,free.map_eq_map,fold_map_hom (free.map.is_monoid_hom f), fold_map_map]; refl }
refl
intros
rw[←rev_list_reverse, list.length_reverse, rev_list_length]
intros
simp [of_nat]; cases nat.decidable_eq n 0; cases nat.decidable_eq m 0; simp only [to_bool]
simp [of_nat]; cases nat.decidable_eq n 0; cases nat.decidable_eq m 0
simp [of_nat]; cases nat.decidable_eq n 0
simp [of_nat]
cases nat.decidable_eq n 0
cases nat.decidable_eq m 0
simp only [to_bool]
simp only [to_bool]
subst m
{ subst m, have h := le_antisymm h (nat.zero_le _), contradiction }
have h := le_antisymm h (nat.zero_le _)
contradiction
cases nat.decidable_eq m 0
simp only [to_bool]
{ left, refl }
left
refl
simp only [to_bool]
intros
cases l
{ refl }
refl
rw [list.to_buffer, to_list_append_list]
{ rw [list.to_buffer, to_list_append_list], refl }
refl
intros
cases reps
{ exact bounded.foldr_core_zero }
exact bounded.foldr_core_zero
constructor
intros cb n hn
obtain ⟨np, errp, hp⟩ := bounded.exists p hn
simpa [foldr_core_succ_eq_fail, hp] using he cb n np errp
intros
simp [pure_eq_done]
intros
by_cases hp : p; simp [guard, hp, pure_eq_done]
{ by_cases hp : p; simp [guard, hp, pure_eq_done] }
by_cases hp : p
simp [guard, hp, pure_eq_done]
simp [guard, hp, pure_eq_done]
intros
simp [foldr_core, eq_comm]
intros
rw ← of_real_inj; simp [cosh_sq_sub_sinh_sq]
rw ← of_real_inj
simp [cosh_sq_sub_sinh_sq]
intros
simp [sub_eq_add_neg, cos_add, sin_neg, cos_neg]
intros
rw [exp_add, exp_mul_I]
intros
rw [of_real_alg, zero_smul]
intros
rw [lt_iff_le_and_ne, ne, eq_comm]; simp [norm_sq_nonneg]
rw [lt_iff_le_and_ne, ne, eq_comm]
simp [norm_sq_nonneg]
rw [finrank_eq_card_basis basis_one_I, fintype.card_fin]
intros
rw [filter_single, if_pos h]
intros
ext i
by_cases h : g i ≠ 0; simp at h; simp [h, hf]
by_cases h : g i ≠ 0; simp at h
by_cases h : g i ≠ 0
simp at h
simp [h, hf]
simp at h
simp [h, hf]
intros
{ rw [supr_comm], simp [mem_decode₂] }
rw [supr_comm]
simp [mem_decode₂]
intros
simpa [equiv.perm.via_fintype_embedding, equiv.perm.extend_domain_apply_subtype, h]
intros
rw [inter_comm, e.left_inv_on.image_inter', image_source_eq_target, inter_comm]
intros
have h₁ : f.to_equiv = g.to_equiv := equiv.ext h
cases f
cases g
congr
{ exact (funext h) }
exact (funext h)
{ exact congr_arg equiv.inv_fun h₁ }
exact congr_arg equiv.inv_fun h₁
intros
simp [pred_above, h]
intros
simp [insert_nth, succ_above_cases]
intros
rw [← coe_inj, coe_sdiff, coe_sdiff, coe_insert]
exact set.insert_diff_of_mem s h
intros
simp only [filter_not, union_sdiff_of_subset (filter_subset p s)]
intros
simp only [mem_def, bUnion_val, mem_erase_dup, mem_bind, exists_prop]
intros
simpa only [disjoint.comm] using disjoint_bUnion_left t f s
intros
simp
intros
rw [←with_bot.coe_le_coe, coe_sup']
{ rw [←with_bot.coe_le_coe, coe_sup'], exact sup_le (λ b h, with_bot.coe_le_coe.2 $ hs b h), }
exact sup_le (λ b h, with_bot.coe_le_coe.2 $ hs b h)
intros
induction s using finset.strong_induction_on with s ihs
rcases s.eq_empty_or_nonempty with rfl|hne
{ exact h0 }
exact h0
have H : s.max' hne ∈ s
{ have H : s.max' hne ∈ s, from max'_mem s hne, rw ← insert_erase H, exact step _ _ (λ x, s.lt_max'_of_mem_erase_max' hne) (ihs _ $ erase_ssubset H) }
from max'_mem s hne
rw ← insert_erase H
exact step _ _ (λ x, s.lt_max'_of_mem_erase_max' hne) (ihs _ $ erase_ssubset H)
intros
classical
induction s using finset.induction_on with a s ha IH
{ simp }
simp
{ simp [ha, IH] }
simp [ha, IH]
intros
simp only [mem_antidiagonal, add_comm, prod.swap]
intros
rw [←function.embedding.coe_fn_mk f hf, ←emb_domain_eq_map_domain, prod_emb_domain]
intros
{ ext, simp [equiv_fun_on_fintype], }
ext
simp [equiv_fun_on_fintype]
intros
erw ←map_range_comp
have : (f ∘ (•) c) = ((•) c ∘ f) := funext hsmul
simp_rw this
apply map_range_comp
rw [function.comp_apply, smul_zero, hf]
intros
simp only [card_eq_one, support_eq_singleton']
intros
split
simp only [pi_finset, mem_map, and_imp, forall_prop_of_true, exists_prop, mem_univ, exists_imp_distrib, mem_pi]
{ simp only [pi_finset, mem_map, and_imp, forall_prop_of_true, exists_prop, mem_univ, exists_imp_distrib, mem_pi], rintro g hg hgf a, rw ← hgf, exact hg a }
rintro g hg hgf a
rw ← hgf
exact hg a
simp only [pi_finset, mem_map, forall_prop_of_true, exists_prop, mem_univ, mem_pi]
{ simp only [pi_finset, mem_map, forall_prop_of_true, exists_prop, mem_univ, mem_pi], exact λ hf, ⟨λ a ha, f a, hf, rfl⟩ }
exact λ hf, ⟨λ a ha, f a, hf, rfl⟩
intros
symmetry
apply eq_of_subset_of_card_le (subset_univ ({x}))
apply le_of_eq
simp [h, finset.card_univ]
intros
simpa only [fintype.card_fin] using s.card_le_univ
intros
haveI := classical.prop_decidable; exact have ∀ {f : α → α}, injective f → surjective f, from λ f hinj x, have h₁ : image f univ = univ := eq_of_subset_of_card_le (subset_univ _) ((card_image_of_injective univ hinj).symm ▸ le_refl _), have h₂ : x ∈ image f univ := h₁.symm ▸ mem_univ _, exists_of_bex (mem_image.1 h₂), ⟨this, λ hsurj, has_left_inverse.injective ⟨surj_inv hsurj, left_inverse_of_surjective_of_right_inverse (this (injective_surj_inv _)) (right_inverse_surj_inv _)⟩⟩
haveI := classical.prop_decidable
exact have ∀ {f : α → α}, injective f → surjective f, from λ f hinj x, have h₁ : image f univ = univ := eq_of_subset_of_card_le (subset_univ _) ((card_image_of_injective univ hinj).symm ▸ le_refl _), have h₂ : x ∈ image f univ := h₁.symm ▸ mem_univ _, exists_of_bex (mem_image.1 h₂), ⟨this, λ hsurj, has_left_inverse.injective ⟨surj_inv hsurj, left_inverse_of_surjective_of_right_inverse (this (injective_surj_inv _)) (right_inverse_surj_inv _)⟩⟩
intros
have nd := v.nodup (mk_idx n (hash_fn a))
refine (v.modify hash_fn [] [] [⟨a, b⟩] (bkts.read hash_fn a) rfl rfl (list.nodup_singleton _) (λa' e, by simp at e; rw e) (λa', false.elim) (λa' e1 e2, _)).2
simp [-sigma.exists] at e2
subst a'
exact Hnc ((contains_aux_iff nd).2 e1)
intros
apply sub_nat_nat_elim m n (λ m n i, bodd i = bxor m.bodd n.bodd)
apply sub_nat_nat_elim m n (λ m n i, bodd i = bxor m.bodd n.bodd); intros; simp; cases i.bodd; simp
apply sub_nat_nat_elim m n (λ m n i, bodd i = bxor m.bodd n.bodd); intros; simp; cases i.bodd
apply sub_nat_nat_elim m n (λ m n i, bodd i = bxor m.bodd n.bodd); intros; simp
apply sub_nat_nat_elim m n (λ m n i, bodd i = bxor m.bodd n.bodd); intros
intros
simp
cases i.bodd
simp
simp
intros
simp
cases i.bodd
simp
simp
intros
rw [H2, int.mul_div_cancel_left _ H1]
intros
contrapose! hc
rw [hc.left, hc.right, gcd_zero_right, nat_abs_zero]
intros
simp [sub_eq_add_neg] with parity_simps
intros
rw eq_comm
convert nth_le_reverse l.reverse _ _ _ using 1
{ simp }
simp
{ simpa }
simpa
intros
induction l; [refl, simp only [*, concat_eq_append, cons_append, map, map_append]]; split; refl
induction l; [refl, simp only [*, concat_eq_append, cons_append, map, map_append]]; split
induction l; [refl, simp only [*, concat_eq_append, cons_append, map, map_append]]
induction l
refl
simp only [*, concat_eq_append, cons_append, map, map_append]
split
refl
refl
intros
induction l with hd tl hl generalizing n
exact absurd n.zero_le (not_le_of_lt (by simpa using hn))
{ exact absurd n.zero_le (not_le_of_lt (by simpa using hn)) }
cases n
{ cases n, { simp }, { simp only [nat.succ_lt_succ_iff, list.length] at hn, simpa [list.nth_le, list.drop] using hl hn } }
{ simp }
simp
simp only [nat.succ_lt_succ_iff, list.length] at hn
{ simp only [nat.succ_lt_succ_iff, list.length] at hn, simpa [list.nth_le, list.drop] using hl hn }
simpa [list.nth_le, list.drop] using hl hn
intros
induction l generalizing a
{ simp }
simp
simp [l_ih, h]
{ simp [l_ih, h] }
intros
induction l with hd tl hl
simp only [forall_const, reduce_option_nil, not_mem_nil, forall_prop_of_false, eq_self_iff_true, length, not_false_iff]
{ simp only [forall_const, reduce_option_nil, not_mem_nil, forall_prop_of_false, eq_self_iff_true, length, not_false_iff] }
cases hd
{ cases hd, { simp only [mem_cons_iff, forall_eq_or_imp, bool.coe_sort_ff, false_and, reduce_option_cons_of_none, length, option.is_some_none, iff_false], intro H, have := reduce_option_length_le tl, rw H at this, exact absurd (nat.lt_succ_self _) (not_lt_of_le this) }, { simp only [hl, true_and, mem_cons_iff, forall_eq_or_imp, add_left_inj, bool.coe_sort_tt, length, option.is_some_some, reduce_option_cons_of_some] } }
simp only [mem_cons_iff, forall_eq_or_imp, bool.coe_sort_ff, false_and, reduce_option_cons_of_none, length, option.is_some_none, iff_false]
{ simp only [mem_cons_iff, forall_eq_or_imp, bool.coe_sort_ff, false_and, reduce_option_cons_of_none, length, option.is_some_none, iff_false], intro H, have := reduce_option_length_le tl, rw H at this, exact absurd (nat.lt_succ_self _) (not_lt_of_le this) }
intro H
have := reduce_option_length_le tl
rw H at this
exact absurd (nat.lt_succ_self _) (not_lt_of_le this)
simp only [hl, true_and, mem_cons_iff, forall_eq_or_imp, add_left_inj, bool.coe_sort_tt, length, option.is_some_some, reduce_option_cons_of_some]
{ simp only [hl, true_and, mem_cons_iff, forall_eq_or_imp, add_left_inj, bool.coe_sort_tt, length, option.is_some_some, reduce_option_cons_of_some] }
intros
obtain ⟨xs, ys, rfl⟩ := h
rw [filter_append, filter_append]
exact infix_append _ _ _
intros
rw erase_eq_erasep; exact mem_erasep_of_neg ab.symm
rw erase_eq_erasep
exact mem_erasep_of_neg ab.symm
intros
induction l generalizing m n
case list.nil : m n { simp }
simp
case list.cons : x xs xs_ih m n { cases m; cases n; simp only [disjoint_cons_left, mem_cons_iff, disjoint_cons_right, drop, true_or, eq_self_iff_true, not_true, false_and, disjoint_nil_left, take], { cases h }, cases hl with _ _ h₀ h₁, split, { intro h, exact h₀ _ (mem_of_mem_drop h) rfl, }, solve_by_elim [le_of_succ_le_succ] { max_depth := 4 } }
intros
subst l₁
intros
cases l; [refl, exact chain_map _]
cases l
refl
exact chain_map _
intros
obtain ⟨k, hk, rfl⟩ := nth_le_of_mem hx
obtain ⟨n, rfl⟩ := id h
rw [next_nth_le _ hn]
simp_rw ←nth_le_rotate' _ n k
rw [next_nth_le _ (h.nodup_iff.mp hn), ←nth_le_rotate' _ n]
simp [add_assoc]
intros
refine ⟨λ h, _, λ h, _⟩
cases h with _ hm _ _ hm
{ cases h with _ hm _ _ hm, { exact or.inl ⟨rfl, hm⟩ }, { exact or.inr hm } }
{ exact or.inl ⟨rfl, hm⟩ }
exact or.inl ⟨rfl, hm⟩
{ exact or.inr hm }
exact or.inr hm
rcases h with ⟨rfl|h⟩|h
{ rcases h with ⟨rfl|h⟩|h, { simpa }, { exact h.cons_duplicate } }
{ simpa }
simpa
{ exact h.cons_duplicate }
exact h.cons_duplicate
intros
dsimp [Ico]; rw nat.sub_sub_self h; simp
dsimp [Ico]; rw nat.sub_sub_self h
dsimp [Ico]
rw nat.sub_sub_self h
simp
intros
rw [diff_eq_filter_of_nodup hl₁, mem_filter]
intros
intros s t h
apply insert_nth_injective s.length x
have hl : s.length = t.length := by simpa using congr_arg length h
rw [←nth_le_permutations'_aux s x s.length (by simp), ←nth_le_permutations'_aux t x s.length (by simp [hl])]
simp [h, hl]
intros
induction h generalizing l; simp [*, perm.erase, erase_comm] <|> exact (ih_1 _).trans (ih_2 _)
induction h generalizing l
simp [*, perm.erase, erase_comm]
simp [*, perm.erase, erase_comm]
simp [*, perm.erase, erase_comm]
simp [*, perm.erase, erase_comm]
intros
simp only [range_eq_range', length_range']
intros
rw [nodupkeys_iff_pairwise, pairwise_join, pairwise_map]
refine and_congr (ball_congr $ λ l h, by simp [nodupkeys_iff_pairwise]) _
apply iff_of_eq
congr' with l₁ l₂
simp [keys, disjoint_iff_ne]
intros
unfold_wf
induction xs with y ys
{ simp }
simp
by_cases x = y.1; simp [*, list.sizeof]
{ by_cases x = y.1; simp [*, list.sizeof] }
by_cases x = y.1
simp [*, list.sizeof]
simp [*, list.sizeof]
intros
induction l₁ generalizing l₂ i
{ simp [zip_with] }
simp [zip_with]
cases l₂; simp only [zip_with, nth, exists_false, and_false, false_and]
cases l₂
{ cases l₂; simp only [zip_with, nth, exists_false, and_false, false_and], cases i; simp *, }
simp only [zip_with, nth, exists_false, and_false, false_and]
simp only [zip_with, nth, exists_false, and_false, false_and]
cases i; simp *
cases i
simp *
simp *
intros
{ ext, apply dot_product_comm }
ext
apply dot_product_comm
intros
ext
{ext, refl}
refl
intros
simpa [dot_product, finset.mul_sum, finset.sum_mul, mul_assoc] using finset.sum_comm
intros
unfold std_basis_matrix
ext
split_ifs with h; simp [h]
split_ifs with h
simp [h]
simp [h]
intros
simp [sub_eq_add_neg]
intros
simp
intros
ext
ext; simp only [transpose, mem_iff_mem f, to_matrix]; congr
ext; simp only [transpose, mem_iff_mem f, to_matrix]
simp only [transpose, mem_iff_mem f, to_matrix]
intros
simpa [countp_eq_card_filter] using card_le_of_le (filter_le_filter p h)
intros
simp only [singleton_eq_cons, mem_cons, iff_self, or_false, not_mem_zero]
intros
{ rw [← eval_map, ← eval_map, map_map], }
rw [← eval_map, ← eval_map, map_map]
intros
{ ext1 r, exact eval₂_C f g r }
ext1 r
exact eval₂_C f g r
intros
apply φ.induction_on
{ intro a, simp only [constant_coeff_C, rename_C]}
intro a
simp only [constant_coeff_C, rename_C]
intros p q hp hq
{ intros p q hp hq, simp only [hp, hq, ring_hom.map_add, alg_hom.map_add] }
simp only [hp, hq, ring_hom.map_add, alg_hom.map_add]
intros p n hp
{ intros p n hp, simp only [hp, rename_X, constant_coeff_X, ring_hom.map_mul, alg_hom.map_mul] }
simp only [hp, rename_X, constant_coeff_X, ring_hom.map_mul, alg_hom.map_mul]
intros
rw [succ_div, if_neg hba, add_zero]
intros
simp [find_greatest_eq_iff]
intros
rw [← lt_succ_iff, div_lt_iff_lt_mul _ _ n0, succ_mul, mul_comm]
cases n
cases n0
{cases n0}
exact lt_succ_iff
intros
{ simp only [strong_rec_on'], rw nat.strong_rec' }
simp only [strong_rec_on']
rw nat.strong_rec'
intros
conv {to_rhs, rw [← nat.mod_add_div n 2, hn, nat.add_sub_cancel_left]}
intros
rw [← cast_one, cast_lt]
intros
simpa using (add_pow 1 1 n).symm
intros
rw [lt_iff_le_not_le, lt_iff_le_not_le, coe_le_coe, coe_le_coe]
intros
rw ← with_top_equiv_lt; simp
rw ← with_top_equiv_lt
simp
intros
split
intro h
{ intro h, exact ⟨eq_zero_of_gcd_eq_zero_left h, eq_zero_of_gcd_eq_zero_right h⟩, }
exact ⟨eq_zero_of_gcd_eq_zero_left h, eq_zero_of_gcd_eq_zero_right h⟩
intro h
{ intro h, rw [h.1, h.2], exact nat.gcd_zero_right _ }
rw [h.1, h.2]
exact nat.gcd_zero_right _
intros
refine ⟨λ h, _, λ h, pow_dvd_pow_of_dvd h _⟩
cases nat.eq_zero_or_pos (gcd a b) with g0 g0
{ simp [eq_zero_of_gcd_eq_zero_right g0] }
simp [eq_zero_of_gcd_eq_zero_right g0]
rcases exists_coprime' g0 with ⟨g, a', b', g0', co, rfl, rfl⟩
rw [mul_pow, mul_pow] at h
replace h := dvd_of_mul_dvd_mul_right (pow_pos g0' _) h
have := pow_dvd_pow a' n0
rw [pow_one, (co.pow n n).eq_one_of_dvd h] at this
simp [eq_one_of_dvd_one this]
intros
induction y using nat.strong_induction_on with y ih generalizing x
cases x
{ exact iff_of_true hy (zero_le _) }
exact iff_of_true hy (zero_le _)
rw log
split_ifs
have b_pos : 0 < b := zero_le_one.trans_lt hb
{ have b_pos : 0 < b := zero_le_one.trans_lt hb, rw [succ_eq_add_one, add_le_add_iff_right, ←ih (y / b) (div_lt_self hy hb) (nat.div_pos h.1 b_pos), le_div_iff_mul_le _ _ b_pos, pow_succ'] }
rw [succ_eq_add_one, add_le_add_iff_right, ←ih (y / b) (div_lt_self hy hb) (nat.div_pos h.1 b_pos), le_div_iff_mul_le _ _ b_pos, pow_succ']
refine iff_of_false (λ hby, h ⟨le_trans _ hby, hb⟩) (not_succ_le_zero _)
{ refine iff_of_false (λ hby, h ⟨le_trans _ hby, hb⟩) (not_succ_le_zero _), convert pow_mono hb.le (zero_lt_succ x), exact (pow_one b).symm }
convert pow_mono hb.le (zero_lt_succ x)
exact (pow_one b).symm
intros
rw [modeq, zero_mod, dvd_iff_mod_eq_zero]
intros
simp [bit1] with parity_simps
intros
cases b; cases n; refl
cases b; cases n
cases b
cases n
refl
refl
cases n
refl
refl
intros
cases n
cases n; refl
refl
refl
refl
intros
cases x
simp only [not_mem_none, exists_false, pmap, not_false_iff, exists_prop_of_false]
{ simp only [not_mem_none, exists_false, pmap, not_false_iff, exists_prop_of_false] }
split
{ split, { intro h, simp only [pmap] at h, exact ⟨x, rfl, h⟩ }, { rintro ⟨a, H, rfl⟩, simp only [mem_def] at H, simp only [H, pmap] } }
intro h
{ intro h, simp only [pmap] at h, exact ⟨x, rfl, h⟩ }
simp only [pmap] at h
exact ⟨x, rfl, h⟩
rintro ⟨a, H, rfl⟩
{ rintro ⟨a, H, rfl⟩, simp only [mem_def] at H, simp only [H, pmap] }
simp only [mem_def] at H
simp only [H, pmap]
intros
unfold balance'
split_ifs
{ exact hl.node' hr }
exact hl.node' hr
{ exact hl.rotate_l hr }
exact hl.rotate_l hr
{ exact hl.rotate_r hr }
exact hl.rotate_r hr
{ exact hl.node' hr }
exact hl.node' hr
intros
dsimp [node', size]
generalize_hyp : size r₂ = m at H ⊢
rcases H with rfl | rfl
{ exact or.inl rfl }
exact or.inl rfl
{ exact or.inr rfl }
exact or.inr rfl
intros
rw [eq_some_iff.2 h, bind_some]
intros
ext i j
dsimp [single]
rw [if_pos (subsingleton.elim i a), subsingleton.elim i j, subsingleton.elim b j]
intros
change (v.map (coe : nat.primes → ℕ+)).map subtype.val = v.map subtype.val
{ change (v.map (coe : nat.primes → ℕ+)).map subtype.val = v.map subtype.val, rw [multiset.map_map], congr }
rw [multiset.map_map]
congr
intros
{ rw dvd_iff, rw nat.gcd_eq_left_iff_dvd, rw ← coe_inj, simp }
rw dvd_iff
rw nat.gcd_eq_left_iff_dvd
rw ← coe_inj
simp
intros
let ha : u.r + u.b * u.q = u.a := u.rq_eq
rw [hr, zero_add] at ha
ext
change (u.wp + 1) * u.b + ((u.wp + 1) * u.qp + u.x) * u.b = u.w * u.a + u.x * u.b
{ change (u.wp + 1) * u.b + ((u.wp + 1) * u.qp + u.x) * u.b = u.w * u.a + u.x * u.b, have : u.wp + 1 = u.w := rfl, rw [this, ← ha, u.qp_eq hr], ring }
have : u.wp + 1 = u.w := rfl
rw [this, ← ha, u.qp_eq hr]
ring
change u.y * u.b + (u.y * u.qp + u.z) * u.b = u.y * u.a + u.z * u.b
{ change u.y * u.b + (u.y * u.qp + u.z) * u.b = u.y * u.a + u.z * u.b, rw [← ha, u.qp_eq hr], ring }
rw [← ha, u.qp_eq hr]
ring
intros
erw [monomial_mul_monomial, mul_one]
intros
fsplit
intro h
{ intro h, apply_fun (λ p, p.coeff 0) at h, simpa using h, }
apply_fun (λ p, p.coeff 0) at h
simpa using h
{ rintro rfl, refl, }
rintro rfl
refl
intros
simpa only [C_1, one_mul] using leading_coeff_C_mul_X_pow (1 : R) n
intros
by_cases hp : p = 0
rw [hp, nat_trailing_degree_zero]
{ rw [hp, nat_trailing_degree_zero], exact zero_le _ }
exact zero_le _
rwa [trailing_degree_eq_nat_trailing_degree hp, trailing_degree_eq_nat_trailing_degree hq, with_top.coe_le_coe] at hpq
intros
rw [C_mul_X_pow_eq_monomial, erase_lead_add_monomial_nat_degree_leading_coeff]
intros
simp [comp, (C : R →+* _).map_sum]
intros
have A : nat_degree (p.map f) < p.nat_degree.succ := (nat_degree_map_le _ _).trans_lt (nat.lt_succ_self _)
conv_lhs { rw [eval₂_eq_sum], }
rw [sum_over_range' _ _ _ A]
simp only [coeff_map, eval₂_eq_sum, sum_over_range, forall_const, zero_mul, ring_hom.map_zero, function.comp_app, ring_hom.coe_comp]
{ simp only [coeff_map, eval₂_eq_sum, sum_over_range, forall_const, zero_mul, ring_hom.map_zero, function.comp_app, ring_hom.coe_comp] }
{ simp only [forall_const, zero_mul, ring_hom.map_zero] }
simp only [forall_const, zero_mul, ring_hom.map_zero]
intros
simp only [map_alg, aeval_def, eval₂, map, algebra_map_apply, ring_hom.coe_comp]
intros
by_cases h : q = 0
{ simp [h] }
simp [h]
rw [hp.nat_degree_mul' h, polynomial.nat_degree_mul', add_comm]
simpa [hp.leading_coeff, leading_coeff_ne_zero]
intros
simp only [empty_eq_zero, pow_zero, nth_roots, ← C_1, ← C_sub, roots_C]
intros
intros f g h
apply_fun taylor (-r) at h
simpa only [taylor_apply, comp_assoc, add_comp, X_comp, C_comp, C_neg, neg_add_cancel_right, comp_X] using h
intros
rw [← cofix.dest_mk x,h,cofix.dest_mk]
intros
rw ←abs_repr x
{ rw ←abs_repr x, cases repr x with a f, rw [←abs_map, ←abs_map, ←abs_map], reflexivity }
cases repr x with a f
rw [←abs_map, ←abs_map, ←abs_map]
reflexivity
intros
by_cases hn : n = 0
subst hn
{ subst hn, simp only [int.cast_zero, euclidean_domain.zero_div] }
simp only [int.cast_zero, euclidean_domain.zero_div]
have : (n : ℚ) ≠ 0
{ have : (n : ℚ) ≠ 0, { rwa ← coe_int_inj at hn }, simp only [int.div_self hn, int.cast_one, ne.def, not_false_iff, div_self this] }
rwa ← coe_int_inj at hn
{ rwa ← coe_int_inj at hn }
simp only [int.div_self hn, int.cast_one, ne.def, not_false_iff, div_self this]
intros
cases x with x
induction x using quot.induction_on with x
exact h x
intros
rw [Inf_def, ← is_lub_neg', neg_neg]
exact real.is_lub_Sup _ h₁.neg h₂.neg
intros
rw [ennreal.of_real, ennreal.of_real, coe_le_coe, real.to_nnreal_le_to_nnreal_iff h]
simp [ennreal.of_real]
intros
conv_lhs { rw [← ennreal.coe_nat n, ennreal.to_nnreal_coe] }
intros
induction x using ereal.rec
{ simpa using h'x }
simpa using h'x
{ refl }
refl
{ simpa using hx }
simpa using hx
intros
unfold st
split_ifs
{ exact is_st_unique (classical.some_spec h) hxr }
exact is_st_unique (classical.some_spec h) hxr
{ exact false.elim (h ⟨r, hxr⟩) }
exact false.elim (h ⟨r, hxr⟩)
simp [real.to_nnreal, max_eq_left (zero_le_one : (0 :ℝ) ≤ 1)]
simp [real.to_nnreal, max_eq_left (zero_le_one : (0 :ℝ) ≤ 1)]; refl
intros
rw ← nnreal.eq_iff
simp only [nnreal.coe_add, nnreal.coe_div, nnreal.coe_mul]
exact div_add_div _ _ (coe_ne_zero.2 hb) (coe_ne_zero.2 hd)
intros
obtain hn | rfl | hp := lt_trichotomy r (0 : ℝ)
{ exact (or.inl $ sign_of_neg hn) }
exact (or.inl $ sign_of_neg hn)
{ exact (or.inr $ or.inl $ sign_zero) }
exact (or.inr $ or.inl $ sign_zero)
{ exact (or.inr $ or.inr $ sign_of_pos hp) }
exact (or.inr $ or.inr $ sign_of_pos hp)
intros
rw [division_def, sqrt_mul hx, sqrt_inv, division_def]
intros
unfold blur; congr; exact set.union_eq_self_of_subset_right h
unfold blur; congr
unfold blur
congr
exact set.union_eq_self_of_subset_right h
intros
induction n
induction n; simp [*, drop]
simp [*, drop]
simp [*, drop]
intros
simp [set.ite]
intros
simp only [inter_comm, image_inter_preimage]
intros
by_cases h : p
rw if_pos h
{rw if_pos h, exact subset_union_left _ _}
exact subset_union_left _ _
{rw if_neg h, exact subset_union_right _ _}
rw if_neg h
exact subset_union_right _ _
intros
simp [prod_eq]
intros
simp [classical.skolem, set.nonempty]
intros
apply diff_subset_iff
intros
classical; exact ⟨set_fintype s⟩
classical
exact ⟨set_fintype s⟩
intros
refine ⟨λ h, _, λ h, Iio_subset_Iio h⟩
by_contradiction ab
exact lt_irrefl _ (h (not_le.mp ab))
intros
simp [← Ici_inter_Iio]
intros
simp
intros
simp [← Ioi_inter_Iic, ← Ici_inter_Iio, h, inter_comm]
intros
rw ord_connected_iff
intros x hx y hy hxy
rcases eq_or_lt_of_le hxy with rfl|hxy'
simpa
{ simpa }
have := hs x hx y hy hxy'
rw [← union_diff_cancel Ioo_subset_Icc_self]
simp [*, insert_subset]
intros
simp [add_comm]
intros
rw [disjoint.comm]; exact disjoint_singleton_left
rw [disjoint.comm]
exact disjoint_singleton_left
intros
simp
intros
ext x
rw [mem_Union, mem_Union]
split
{ rintro ⟨y, i, rfl⟩, exact ⟨i, (f i y).2⟩ }
rintro ⟨y, i, rfl⟩
exact ⟨i, (f i y).2⟩
rintro ⟨i, hx⟩
{ rintro ⟨i, hx⟩, cases hf i ⟨x, hx⟩ with y hy, exact ⟨y, i, congr_arg subtype.val hy⟩ }
cases hf i ⟨x, hx⟩ with y hy
exact ⟨y, i, congr_arg subtype.val hy⟩
intros
{ cases x₀, cases x₁, exact psigma.mk.inj_iff }
cases x₀
cases x₁
exact psigma.mk.inj_iff
intros
ext i : 1; cases i; refl
ext i : 1; cases i
ext i : 1
cases i
refl
refl
intros
ext
ext; apply drop_append1
apply drop_append1
intros
rw [nat.coprime, nat.gcd_comm, nat.gcd_rec] at h
rw [mul_inv_eq_gcd, val_nat_cast, h, nat.cast_one]
intros
simp only [set.ext_iff, is_subgroup.mem_trivial]
simp only [set.ext_iff, is_subgroup.mem_trivial]; exact ⟨λ h x, (h x).1, λ h x, ⟨h x, λ hx, hx.symm ▸ hs.to_is_submonoid.one_mem⟩⟩
exact ⟨λ h x, (h x).1, λ h x, ⟨h x, λ hx, hx.symm ▸ hs.to_is_submonoid.one_mem⟩⟩
intros
{ rw ← set.image_univ, exact univ.is_submonoid.image hf }
rw ← set.image_univ
exact univ.is_submonoid.image hf
intros
simpa only [nsmul_eq_mul, add_right_iterate] using (f.commute_add_int m).iterate_le_of_map_le f.monotone (monotone_id.add_const m) h n
intros
simp only [is_periodic_pt, iterate_mul, hm.is_fixed_pt.iterate n]
intros
apply_instance
intros
letI : fintype (F⟮α⟯ →ₐ[F] F⟮α⟯) := intermediate_field.fintype_of_alg_hom_adjoin_integral F hα
rw intermediate_field.adjoin.finrank hα
rw ← intermediate_field.card_alg_hom_adjoin_integral F hα h_sep h_splits
exact fintype.card_congr (alg_equiv_equiv_alg_hom F F⟮α⟯)
intros
rw pos_iff_ne_zero
intro ndeg_eq_zero
have eq_one : minpoly A x = 1
rw eq_C_of_nat_degree_eq_zero ndeg_eq_zero
{ rw eq_C_of_nat_degree_eq_zero ndeg_eq_zero, convert C_1, simpa only [ndeg_eq_zero.symm] using (monic hx).leading_coeff }
convert C_1
simpa only [ndeg_eq_zero.symm] using (monic hx).leading_coeff
simpa only [eq_one, alg_hom.map_one, one_ne_zero] using aeval A x
intros
simpa only [sub_eq_add_neg, C_neg] using separable_X_add_C (-x)
intros
{ rw mul_comm at h, exact h.of_mul_left }
rw mul_comm at h
exact h.of_mul_left
intros
split
{ intro H, rw [nat_degree_eq_card_roots H, map_id] }
intro H
rw [nat_degree_eq_card_roots H, map_id]
intro hroots
{ intro hroots, apply (splits_iff_exists_multiset (ring_hom.id K)).2, use p.roots, simp only [ring_hom.id_apply, map_id], exact (C_leading_coeff_mul_prod_multiset_X_sub_C hroots).symm }
apply (splits_iff_exists_multiset (ring_hom.id K)).2
use p.roots
simp only [ring_hom.id_apply, map_id]
exact (C_leading_coeff_mul_prod_multiset_X_sub_C hroots).symm
intros
rw [angle_neg_right, angle_self hx, sub_zero]
intros
ext
ext; simp only [times_cont_mdiff_map.comp_apply, coe_mul, pi.mul_apply]
simp only [times_cont_mdiff_map.comp_apply, coe_mul, pi.mul_apply]
intros
refine ((nhds_within_has_basis euclidean.nhds_basis_closed_ball _).restrict_subset (ext_chart_at_target_mem_nhds_within _ _)).to_has_basis' _ _
rintro R ⟨hR0, hsub⟩
{ rintro R ⟨hR0, hsub⟩, exact ⟨⟨⟨⟨R / 2, R, half_pos hR0, half_lt_self hR0⟩⟩, hsub⟩, trivial, subset.rfl⟩ }
exact ⟨⟨⟨⟨R / 2, R, half_pos hR0, half_lt_self hR0⟩⟩, hsub⟩, trivial, subset.rfl⟩
exact λ f _, inter_mem (mem_nhds_within_of_mem_nhds $ closed_ball_mem_nhds f.R_pos) self_mem_nhds_within
{ exact λ f _, inter_mem (mem_nhds_within_of_mem_nhds $ closed_ball_mem_nhds f.R_pos) self_mem_nhds_within }
intros
refine ⟨continuous_const.continuous_at, _⟩
simp only [written_in_ext_chart_at, (∘), has_fderiv_within_at_const]
intros
rw [mdifferentiable_within_at, mdifferentiable_within_at, ext_chart_preimage_inter_eq, differentiable_within_at_inter, continuous_within_at_inter ht]
exact ext_chart_preimage_mem_nhds I x ht
intros
simp only [mdifferentiable_on, differentiable_on, mdifferentiable_within_at_iff_differentiable_within_at]
intros
refine I.continuous.comp_continuous_on _
rw ext_chart_at_source
exact (chart_at H x).continuous_on
intros
rw times_cont_mdiff_within_at_iff
refine ⟨continuous_within_at_snd, _⟩
refine times_cont_diff_within_at_snd.congr (λ y hy, _) _
simp only with mfld_simps at hy
{ simp only with mfld_simps at hy, simp only [hy] with mfld_simps }
simp only [hy] with mfld_simps
{ simp only with mfld_simps }
simp only with mfld_simps
intros
apply subgroup.normal_closure_le_normal
rintros x ⟨p, q, rfl⟩
simp [monoid_hom.mem_ker, mul_right_comm (f p) (f q)]
intros
{ ext, exact (left_coset_eq_iff s).symm }
ext
exact (left_coset_eq_iff s).symm
intros
induction H with L1 L' L2 H1 H2 ih
{ refl }
refl
cases H1 with L4 L5 x b
{ cases H1 with L4 L5 x b, exact reduce.not H2 }
exact reduce.not H2
intros
rw [smul_assoc, one_smul]
intros
rw [←mk'_one, ←mk'_mul, one_mul]
intros
simp_rw ← add_order_of_dvd_iff_nsmul_eq_zero
exact ⟨λ h n, by rw h, λ h, nat.dvd_antisymm ((h _).mpr dvd_rfl) ((h _).mp dvd_rfl)⟩
intros
simp_rw [is_p_group, ←hϕ.eq_iff, ϕ.map_pow, ϕ.map_one]
exact λ h, hG (ϕ h)
intros
rw [←card_cycle_type_eq_one, h.cycle_type, card_singleton]
intros
obtain ⟨m, rfl⟩ := exists_add_of_le h
rw [add_comm, support_fin_rotate]
intros
intros x hx
have hx' : x ∈ {x | form_perm l x ≠ x} := by simpa using hx
simpa using support_form_perm_le' _ hx'
intros
induction l with hd tl hl
{ simp }
simp
rw [list.pairwise_cons] at h
{ rw [list.pairwise_cons] at h, have : disjoint hd tl.prod := disjoint_prod_right _ h.left, simp [this.support_mul, hl h.right] }
have : disjoint hd tl.prod := disjoint_prod_right _ h.left
simp [this.support_mul, hl h.right]
intros
rw [mrange_eq_map, ← mrange_inl_sup_mrange_inr, map_sup, map_mrange, coprod_comp_inl, map_mrange, coprod_comp_inr, range_subtype, range_subtype]
intros
classical
by_cases h : ∀ x ∈ S, x = (1 : M)
left
{ left, exact S.eq_bot_iff_forall.mpr h }
exact S.eq_bot_iff_forall.mpr h
right
{ right, push_neg at h, simpa [nontrivial_iff_exists_ne_one] using h }
push_neg at h
simpa [nontrivial_iff_exists_ne_one] using h
intros
{ ext, simp, }
ext
simp
intros
refine le_antisymm _ _
change (affine_span k ((s1 : set P) ∪ s2)).direction ≤ _
{ change (affine_span k ((s1 : set P) ∪ s2)).direction ≤ _, rw ←mem_coe at hp1, rw [direction_affine_span, vector_span_eq_span_vsub_set_right k (set.mem_union_left _ hp1), submodule.span_le], rintros v ⟨p3, hp3, rfl⟩, cases hp3, { rw [sup_assoc, sup_comm, set_like.mem_coe, submodule.mem_sup], use [0, submodule.zero_mem _, p3 -ᵥ p1, vsub_mem_direction hp3 hp1], rw zero_add }, { rw [sup_assoc, set_like.mem_coe, submodule.mem_sup], use [0, submodule.zero_mem _, p3 -ᵥ p1], rw [and_comm, zero_add], use rfl, rw [←vsub_add_vsub_cancel p3 p2 p1, submodule.mem_sup], use [p3 -ᵥ p2, vsub_mem_direction hp3 hp2, p2 -ᵥ p1, submodule.mem_span_singleton_self _] } }
rw ←mem_coe at hp1
rw [direction_affine_span, vector_span_eq_span_vsub_set_right k (set.mem_union_left _ hp1), submodule.span_le]
rintros v ⟨p3, hp3, rfl⟩
cases hp3
rw [sup_assoc, sup_comm, set_like.mem_coe, submodule.mem_sup]
{ rw [sup_assoc, sup_comm, set_like.mem_coe, submodule.mem_sup], use [0, submodule.zero_mem _, p3 -ᵥ p1, vsub_mem_direction hp3 hp1], rw zero_add }
use [0, submodule.zero_mem _, p3 -ᵥ p1, vsub_mem_direction hp3 hp1]
rw zero_add
rw [sup_assoc, set_like.mem_coe, submodule.mem_sup]
{ rw [sup_assoc, set_like.mem_coe, submodule.mem_sup], use [0, submodule.zero_mem _, p3 -ᵥ p1], rw [and_comm, zero_add], use rfl, rw [←vsub_add_vsub_cancel p3 p2 p1, submodule.mem_sup], use [p3 -ᵥ p2, vsub_mem_direction hp3 hp2, p2 -ᵥ p1, submodule.mem_span_singleton_self _] }
use [0, submodule.zero_mem _, p3 -ᵥ p1]
rw [and_comm, zero_add]
use rfl
rw [←vsub_add_vsub_cancel p3 p2 p1, submodule.mem_sup]
use [p3 -ᵥ p2, vsub_mem_direction hp3 hp2, p2 -ᵥ p1, submodule.mem_span_singleton_self _]
refine sup_le (sup_direction_le _ _) _
{ refine sup_le (sup_direction_le _ _) _, rw [direction_eq_vector_span, vector_span_def], exact Inf_le_Inf (λ p hp, set.subset.trans (set.singleton_subset_iff.2 (vsub_mem_vsub (mem_span_points k p2 _ (set.mem_union_right _ hp2)) (mem_span_points k p1 _ (set.mem_union_left _ hp1)))) hp) }
rw [direction_eq_vector_span, vector_span_def]
exact Inf_le_Inf (λ p hp, set.subset.trans (set.singleton_subset_iff.2 (vsub_mem_vsub (mem_span_points k p2 _ (set.mem_union_right _ hp2)) (mem_span_points k p1 _ (set.mem_union_left _ hp1)))) hp)
intros
cases h1 with p1 hp1
cases h2 with p2 hp2
rw set_like.lt_iff_le_and_exists
use [sup_direction_le s1 s2, p2 -ᵥ p1, vsub_mem_direction ((le_sup_right : s2 ≤ s1 ⊔ s2) hp2) ((le_sup_left : s1 ≤ s1 ⊔ s2) hp1)]
intro h
rw submodule.mem_sup at h
rcases h with ⟨v1, hv1, v2, hv2, hv1v2⟩
rw [←sub_eq_zero, sub_eq_add_neg, neg_vsub_eq_vsub_rev, add_comm v1, add_assoc, ←vadd_vsub_assoc, ←neg_neg v2, add_comm, ←sub_eq_add_neg, ←vsub_vadd_eq_vsub_sub, vsub_eq_zero_iff_eq] at hv1v2
refine set.nonempty.ne_empty _ he
use [v1 +ᵥ p1, vadd_mem_of_mem_direction hv1 hp1]
rw hv1v2
exact vadd_mem_of_mem_direction (submodule.neg_mem _ hv2) hp2
intros
simp [centroid_def, affine_combination_apply]
intros
rw [collinear_iff_finrank_le_one, finrank_vector_span_le_iff_not_affine_independent k p (fintype.card_fin 3)]
intros
rw [midpoint_comm, midpoint_vsub_left]
intros
rw [eq_top_iff, le_span_singleton_iff]
finish
intros
simp [basis.equiv]
intros
rw [←@neg_one_smul R₁ _ _, smul_left, neg_one_mul]
intros
erw [symm_comp_of_nondegenerate, linear_equiv.apply_symm_apply (B₂.to_dual b₂) _]
intros
simp only [B.to_matrix'_comp_left, transpose_transpose, to_matrix'_to_lin']
intros
apply uncurry_apply
intros
fapply card_le_of_injective' R
apply finsupp.total
{ apply finsupp.total, exact λ i, span.repr R w ⟨v i, s (mem_range_self i)⟩, }
exact λ i, span.repr R w ⟨v i, s (mem_range_self i)⟩
intros f g h
{ intros f g h, apply_fun finsupp.total w M R coe at h, simp only [finsupp.total_total, submodule.coe_mk, span.finsupp_total_repr] at h, rw [←sub_eq_zero, ←linear_map.map_sub] at h, exact sub_eq_zero.mp (linear_independent_iff.mp i _ h), }
apply_fun finsupp.total w M R coe at h
simp only [finsupp.total_total, submodule.coe_mk, span.finsupp_total_repr] at h
rw [←sub_eq_zero, ←linear_map.map_sub] at h
exact sub_eq_zero.mp (linear_independent_iff.mp i _ h)
intros
simp [finsupp_tensor_finsupp']
intros
simp_rw [dual_annihilator_comap, mem_comap, mem_dual_annihilator, module.dual.eval_apply]
intros
by_cases n : v = 0
subst n
{ subst n, convert zero_le_one, haveI := subsingleton_of_forall_eq (0 : V) (λ w, by { obtain ⟨c, rfl⟩ := h w, simp, }), exact finrank_zero_of_subsingleton, }
convert zero_le_one
haveI := subsingleton_of_forall_eq (0 : V) (λ w, by { obtain ⟨c, rfl⟩ := h w, simp, })
exact finrank_zero_of_subsingleton
{ exact (finrank_eq_one v n h).le, }
exact (finrank_eq_one v n h).le
intros
have h_finrank_inf : finrank K ↥(s ⊓ t) = 0
rw [disjoint, le_bot_iff] at hdisjoint
{ rw [disjoint, le_bot_iff] at hdisjoint, rw [hdisjoint, finrank_bot] }
rw [hdisjoint, finrank_bot]
apply eq_top_of_finrank_eq
rw ←hdim
convert s.dim_sup_add_dim_inf_eq t
rw h_finrank_inf
refl
intros
rw [← linear_independent_equiv (fin_succ_equiv n).symm, linear_independent_option]
convert iff.rfl
ext
{ ext, rw [comp_app, comp_app, fin_succ_equiv_symm_coe, fin.cons_succ] }
ext
{ ext, rw [comp_app, comp_app, fin_succ_equiv_symm_coe, fin.cons_succ] }
rw [comp_app, comp_app, fin_succ_equiv_symm_coe, fin.cons_succ]
rw [comp_app, comp_app, fin_succ_equiv_symm_coe, fin.cons_succ]
ext
{ ext, rw [comp_app, comp_app, fin_succ_equiv_symm_coe, fin.cons_succ] }
ext
{ ext, rw [comp_app, comp_app, fin_succ_equiv_symm_coe, fin.cons_succ] }
rw [comp_app, comp_app, fin_succ_equiv_symm_coe, fin.cons_succ]
rw [comp_app, comp_app, fin_succ_equiv_symm_coe, fin.cons_succ]
intros
rw sUnion_eq_Union; exact linear_independent_Union_of_directed hs.directed_coe (by simpa using h)
rw sUnion_eq_Union
exact linear_independent_Union_of_directed hs.directed_coe (by simpa using h)
intros
{ intros i j h, simp [ha h] }
intros i j h
simp [ha h]
intros
rw [matrix.to_lin_mul v₁ v₂, linear_map.comp_apply]
intros
dunfold diag
{ dunfold diag, ext, simp [one_apply_eq] }
ext
simp [one_apply_eq]
intros
refine (supr_le $ λ i, _).antisymm _
rintro _ ⟨x, hx : x ∈ p i, rfl⟩ j -
{ rintro _ ⟨x, hx : x ∈ p i, rfl⟩ j -, rcases em (j = i) with rfl|hj; simp * }
rcases em (j = i) with rfl|hj; simp *
rcases em (j = i) with rfl|hj
simp *
simp *
intros x hx
{ intros x hx, rw [← finset.univ_sum_single x], exact sum_mem_supr (λ i, mem_map_of_mem (hx i trivial)) }
rw [← finset.univ_sum_single x]
exact sum_mem_supr (λ i, mem_map_of_mem (hx i trivial))
intros
ext x
simp only [mem_ker, mem_range]
split
{ rintros ⟨y, rfl⟩, refl }
rintros ⟨y, rfl⟩
refl
{ intro h, exact ⟨x.fst, prod.ext rfl h.symm⟩ }
intro h
exact ⟨x.fst, prod.ext rfl h.symm⟩
intros
rw [range_eq_map, ← prod_top, prod_map_fst]
intros
rw [std_basis_apply, update_same]
intros
simp
intros
cc
intros
induction ab with b d ab bd IH
{ exact or.inl ac }
exact or.inl ac
rcases IH with IH | IH
{ rcases IH with IH | IH, { rcases cases_head IH with rfl | ⟨e, be, ec⟩, { exact or.inr (single bd) }, { cases U bd be, exact or.inl ec } }, { exact or.inr (IH.tail bd) } }
rcases cases_head IH with rfl | ⟨e, be, ec⟩
{ rcases cases_head IH with rfl | ⟨e, be, ec⟩, { exact or.inr (single bd) }, { cases U bd be, exact or.inl ec } }
{ exact or.inr (single bd) }
exact or.inr (single bd)
{ cases U bd be, exact or.inl ec }
cases U bd be
exact or.inl ec
{ exact or.inr (IH.tail bd) }
exact or.inr (IH.tail bd)
intros
simp_rw [measure.prod, bind_apply hs measurable.map_prod_mk_left, map_apply measurable_prod_mk_left hs]
intros
rcases hf.1 with ⟨f', hf'_meas, hf_ae⟩
have hf'_integrable : integrable f' μ
from integrable.congr hf hf_ae
have hf'_zero : ∀ s, measurable_set s → 0 ≤ ∫ x in s, f' x ∂μ
intros s hs
{ intros s hs, rw set_integral_congr_ae hs (hf_ae.mono (λ x hx hxs, hx.symm)), exact hf_zero s hs, }
rw set_integral_congr_ae hs (hf_ae.mono (λ x hx hxs, hx.symm))
exact hf_zero s hs
exact (ae_nonneg_of_forall_set_integral_nonneg_of_finite_measure_of_measurable hf'_meas hf'_integrable hf'_zero).trans hf_ae.symm.le
intros
rcases hfm with ⟨f', hf'_meas, hf_ae⟩
refine ⟨-f', @measurable.neg _ _ _ _ _ m _ hf'_meas, hf_ae.mono (λ x hx, _)⟩
simp_rw pi.neg_apply
rw hx
intros
rw [sub_eq_add_neg, sub_eq_add_neg, condexp_L1_add hf hg.neg, condexp_L1_neg g]
intros
rw [Lp.norm_def, Lp.norm_def, ← Lp_meas_coe]
refine (ennreal.to_real_le_to_real _ (Lp.snorm_ne_top _)).mpr (snorm_condexp_L2_le hm f)
exact Lp.snorm_ne_top _
intros
simp only [has_finite_integral, lintegral_smul_measure] at *
exact mul_lt_top hc h.ne
intros
rw L2.inner_indicator_const_Lp_eq_inner_set_integral 𝕜 hs hμs (1 : 𝕜) f
{ rw L2.inner_indicator_const_Lp_eq_inner_set_integral 𝕜 hs hμs (1 : 𝕜) f, simp, }
simp
intros
split
assume h
{ assume h, rw h, exact ae_eq_fun.coe_fn_const _ _ }
rw h
exact ae_eq_fun.coe_fn_const _ _
assume h
{ assume h, ext1, filter_upwards [h, ae_eq_fun.coe_fn_const α (0 : E)], assume a ha h'a, rw ha, exact h'a.symm }
ext1
filter_upwards [h, ae_eq_fun.coe_fn_const α (0 : E)]
assume a ha h'a
rw ha
exact h'a.symm
intros
simp_rw snorm'
rw [← ennreal.rpow_mul, ←one_div_mul_one_div]
simp_rw one_div
rw [mul_assoc, inv_mul_cancel hq_pos.ne.symm, mul_one]
congr
ext1 x
simp_rw ← of_real_norm_eq_coe_nnnorm
rw [real.norm_eq_abs, abs_eq_self.mpr (real.rpow_nonneg_of_nonneg (norm_nonneg _) _), mul_comm, ← ennreal.of_real_rpow_of_nonneg (norm_nonneg _) hq_pos.le, ennreal.rpow_mul]
intros
filter_upwards [to_simple_func_eq_to_fun (0 : Lp.simple_func E p μ), Lp.coe_fn_zero E 1 μ]
assume a h₁ h₂
rwa h₁
intros
simpa [mul_comm] using integral_comp_smul_deriv'' hf hff' hf' hg
intros
simpa only [add_comm] using integral_comp_add_right f d
intros
simp only [interval_integral, set_integral_congr_ae (measurable_set_Ioc) h, set_integral_congr_ae (measurable_set_Ioc) h']
intros
convert lintegral_zero_measure _
exact measure.restrict_eq_zero.2 hs'
intros
refine @measurable.ennreal_induction α m (λ f, ∫⁻ a, f a ∂(μ.trim hm) = ∫⁻ a, f a ∂μ) _ _ _ f hf
intros c s hs
{ intros c s hs, rw [lintegral_indicator _ hs, lintegral_indicator _ (hm s hs), set_lintegral_const, set_lintegral_const], suffices h_trim_s : μ.trim hm s = μ s, by rw h_trim_s, exact trim_measurable_set_eq hm hs, }
rw [lintegral_indicator _ hs, lintegral_indicator _ (hm s hs), set_lintegral_const, set_lintegral_const]
suffices h_trim_s : μ.trim hm s = μ s
rw h_trim_s
rw h_trim_s
exact trim_measurable_set_eq hm hs
intros f g hfg hf hg hf_prop hg_prop
{ intros f g hfg hf hg hf_prop hg_prop, have h_m := lintegral_add hf hg, have h_m0 := lintegral_add (measurable.mono hf hm le_rfl) (measurable.mono hg hm le_rfl), rwa [hf_prop, hg_prop, ← h_m0] at h_m, }
have h_m := lintegral_add hf hg
have h_m0 := lintegral_add (measurable.mono hf hm le_rfl) (measurable.mono hg hm le_rfl)
rwa [hf_prop, hg_prop, ← h_m0] at h_m
intros f hf hf_mono hf_prop
{ intros f hf hf_mono hf_prop, rw lintegral_supr hf hf_mono, rw lintegral_supr (λ n, measurable.mono (hf n) hm le_rfl) hf_mono, congr, exact funext (λ n, hf_prop n), }
rw lintegral_supr hf hf_mono
rw lintegral_supr (λ n, measurable.mono (hf n) hm le_rfl) hf_mono
congr
exact funext (λ n, hf_prop n)
intros
refine set_integral_mono_ae_restrict hf hg _
{ refine set_integral_mono_ae_restrict hf hg _, rwa [eventually_le, ae_restrict_iff' hs], }
rwa [eventually_le, ae_restrict_iff' hs]
intros
induction l with i l ih
{ induction l with i l ih, exact measurable_set.univ, exact (hs i).prod ih }
exact measurable_set.univ
exact (hs i).prod ih
intros
rw [← coe_fn_comp_to_finite_measure_eq_coe_fn, finite_measure.ennreal_coe_fn_eq_coe_fn_to_measure]
{ rw [← coe_fn_comp_to_finite_measure_eq_coe_fn, finite_measure.ennreal_coe_fn_eq_coe_fn_to_measure], refl, }
refl
intros
simp only [prehaar]
rw [div_add_div_same, div_le_div_right]
exact_mod_cast index_union_le K₁ K₂ hU
exact_mod_cast index_pos K₀ hU
intros
rw [← measure.mk_metric_to_outer_measure, coe_to_outer_measure]
intros
simp only [measure_singleton, measure.restrict_eq_zero]
intros
simp [map_map e.measurable e.symm.measurable]
intros
refine le_infi _
{ refine le_infi _, intro h₂, rw [extend_eq m h₁], exact m_mono h₁ h₂ hs }
intro h₂
rw [extend_eq m h₁]
exact m_mono h₁ h₂ hs
intros
simp [bounded_by, of_function_apply]
intros
by_cases hi : measurable_set i
ext j hj
{ ext j hj, simp [restrict_apply _ hi hj] }
simp [restrict_apply _ hi hj]
simp only [restrict_not_measurable _ hi]
{ simp only [restrict_not_measurable _ hi], ext j hj, simp }
ext j hj
simp
intros
rw [filter_apply, set.indicator_apply_eq_zero.mpr (λ ha', absurd ha' ha), zero_mul]
intros
have h4 : (0:ℚ) < 4
norm_num
norm_num
contrapose! H
rw sum_inv_pqr
have h4r := H.trans hqr
simp only [pnat.coe_bit0, nat.cast_bit0, pnat.one_coe, nat.cast_one, coe_coe]
calc (2⁻¹ + q⁻¹ + r⁻¹ : ℚ) ≤ 2⁻¹ + 4⁻¹ + 4⁻¹ : add_le_add (add_le_add le_rfl _) _ ... = 1 : by norm_num
rw inv_le_inv _ h4; [assumption_mod_cast, norm_num]
all_goals { rw inv_le_inv _ h4; [assumption_mod_cast, norm_num] }
rw inv_le_inv _ h4
rw inv_le_inv _ h4; [assumption_mod_cast, norm_num]
assumption_mod_cast
norm_num
intros
induction i; push_cast [←int.coe_nat_two_pow_pred p, s_mod, s_zmod, *]
induction i
push_cast [←int.coe_nat_two_pow_pred p, s_mod, s_zmod, *]
push_cast [←int.coe_nat_two_pow_pred p, s_mod, s_zmod, *]
intros
apply ne_of_gt
simp only [gt_iff_lt, sub_pos]
exact_mod_cast nat.one_lt_two_pow p w
intros
rw [div_eq_mul_inv, padic_val_rat.mul p hq (inv_ne_zero hr), padic_val_rat.inv p hr, sub_eq_add_neg]
intros
intros ε hε
obtain ⟨k, hk⟩ : ∃ k : ℕ, (p ^ - (↑(k : ℕ) : ℤ) : ℚ) < ε := exists_pow_neg_lt_rat p hε
use k
intros j hj
refine lt_of_le_of_lt _ hk
norm_cast
rw ← padic_norm.dvd_iff_norm_le
exact_mod_cast pow_dvd_nth_hom_sub f_compat r k j hj
intros
simp
intros
simp [norm]
intros
rw [← to_complex_zero, to_complex_inj]
intros
{ rw [← not_le], intro h', apply not_le_of_lt h, exact hf h' }
rw [← not_le]
intro h'
apply not_le_of_lt h
exact hf h'
intros
{ rw [sup_comm], exact le_sup_sdiff }
rw [sup_comm]
exact le_sup_sdiff
intros
haveI := classical.dec_eq α
haveI : decidable (a ≤ ⊥) := decidable_of_iff' _ le_bot_iff
simp only [lt_iff_le_not_le, not_iff_not.mpr le_bot_iff, true_and, bot_le]
intros
simp only [← not_le, is_lub_le_iff h, mem_upper_bounds, not_forall]
intros
{ change (∃ _, _) ↔ _, simp [-eq_iff_iff] }
change (∃ _, _) ↔ _
simp [-eq_iff_iff]
intros
simp
intros
rintro f n
cases n
{ refl }
refl
{ exact sdiff_le }
exact sdiff_le
intros
simp [at_top_basis.frequently_iff]
intros
simp only [at_top_finset_eq_infi, tendsto_infi, tendsto_principal]
intro a
rcases h' a with ⟨b, hb⟩
exact eventually.mono (mem_at_top b) (λ b' hb', le_trans (finset.singleton_subset_iff.2 hb) (h hb'))
intros
refine le_antisymm (le_inf map_comap_le $ le_principal_iff.2 range_mem_map) _
rintro t' ⟨t, ht, sub⟩
refine mem_inf_principal.2 (mem_of_superset ht _)
rintro _ hxt ⟨x, rfl⟩
exact sub hxt
intros
simp only [filter.prod, comap_comap, eq_self_iff_true, comap_inf]
intros
simp [ne_bot_iff]
intros
{ ext, simp only [mem_supr, mem_inf_principal] }
ext
simp only [mem_supr, mem_inf_principal]
intros
split
split; intro h
intro h
have hu_zero := eventually_le.trans (eventually_le_limsup u) (eventually_of_forall (λ _, le_of_eq h))
{ have hu_zero := eventually_le.trans (eventually_le_limsup u) (eventually_of_forall (λ _, le_of_eq h)), exact hu_zero.mono (λ x hx, le_antisymm hx (zero_le _)), }
exact hu_zero.mono (λ x hx, le_antisymm hx (zero_le _))
intro h
rw limsup_congr h
{ rw limsup_congr h, simp_rw [pi.zero_apply, ←ennreal.bot_eq_zero, limsup_const_bot] }
simp_rw [pi.zero_apply, ←ennreal.bot_eq_zero, limsup_const_bot]
intros
simp only [← sUnion_image, finite_sUnion_mem_iff (his.image s), bex_image_iff]
intros
simpa only [not_lt] using not_congr (h.symm.iterate_pos_lt_iff_map_lt' hg hf hn)
intros
rw [symm_diff_def, sup_sdiff, sdiff_idem, sdiff_sdiff_self, bot_sup_eq]
intros
apply eq_of_fst_eq_fst
cases eq_or_lt_of_le h1 with heq hlt
{ exact heq }
exact heq
exfalso
exact ne_of_lt (mul_lt_mul_of_lt_of_le hlt h2) ((mem_mul_antidiagonal.1 x.2).1.trans (mem_mul_antidiagonal.1 y.2).1.symm)
intros
revert f
have h_mul_indicator : ∀ g, measurable g → measurable (λ a, g a * T.indicator (λ x, c) a)
from λ g h_mg, h_mg.mul (measurable_const.indicator h_meas_T)
apply measurable.ennreal_induction
intros c' s' h_meas_s'
{ intros c' s' h_meas_s', simp_rw [← inter_indicator_mul], rw [lintegral_indicator _ (measurable_set.inter (hMf _ h_meas_s') (h_meas_T)), lintegral_indicator _ (hMf _ h_meas_s'), lintegral_indicator _ h_meas_T], simp only [measurable_const, lintegral_const, univ_inter, lintegral_const_mul, measurable_set.univ, measure.restrict_apply], ring_nf, congr, rw [mul_comm, h_ind s' T h_meas_s' (set.mem_singleton _)], }
simp_rw [← inter_indicator_mul]
rw [lintegral_indicator _ (measurable_set.inter (hMf _ h_meas_s') (h_meas_T)), lintegral_indicator _ (hMf _ h_meas_s'), lintegral_indicator _ h_meas_T]
simp only [measurable_const, lintegral_const, univ_inter, lintegral_const_mul, measurable_set.univ, measure.restrict_apply]
ring_nf
congr
rw [mul_comm, h_ind s' T h_meas_s' (set.mem_singleton _)]
intros f' g h_univ h_meas_f' h_meas_g h_ind_f' h_ind_g
{ intros f' g h_univ h_meas_f' h_meas_g h_ind_f' h_ind_g, have h_measM_f' : measurable f', from h_meas_f'.mono hMf le_rfl, have h_measM_g : measurable g, from h_meas_g.mono hMf le_rfl, simp_rw [pi.add_apply, right_distrib], rw [lintegral_add (h_mul_indicator _ h_measM_f') (h_mul_indicator _ h_measM_g), lintegral_add h_measM_f' h_measM_g, right_distrib, h_ind_f', h_ind_g] }
have h_measM_f' : measurable f'
from h_meas_f'.mono hMf le_rfl
have h_measM_g : measurable g
from h_meas_g.mono hMf le_rfl
simp_rw [pi.add_apply, right_distrib]
rw [lintegral_add (h_mul_indicator _ h_measM_f') (h_mul_indicator _ h_measM_g), lintegral_add h_measM_f' h_measM_g, right_distrib, h_ind_f', h_ind_g]
intros f h_meas_f h_mono_f h_ind_f
{ intros f h_meas_f h_mono_f h_ind_f, have h_measM_f : ∀ n, measurable (f n), from λ n, (h_meas_f n).mono hMf le_rfl, simp_rw [ennreal.supr_mul], rw [lintegral_supr h_measM_f h_mono_f, lintegral_supr, ennreal.supr_mul], { simp_rw [← h_ind_f] }, { exact λ n, h_mul_indicator _ (h_measM_f n) }, { exact λ m n h_le a, ennreal.mul_le_mul (h_mono_f h_le a) le_rfl, }, }
have h_measM_f : ∀ n, measurable (f n)
from λ n, (h_meas_f n).mono hMf le_rfl
simp_rw [ennreal.supr_mul]
rw [lintegral_supr h_measM_f h_mono_f, lintegral_supr, ennreal.supr_mul]
{ simp_rw [← h_ind_f] }
simp_rw [← h_ind_f]
{ exact λ n, h_mul_indicator _ (h_measM_f n) }
exact λ n, h_mul_indicator _ (h_measM_f n)
{ exact λ m n h_le a, ennreal.mul_le_mul (h_mono_f h_le a) le_rfl, }
exact λ m n h_le a, ennreal.mul_le_mul (h_mono_f h_le a) le_rfl
intros
rw [power_basis_gen, minpoly_root hf]
intros
have hi := (classical.some_spec (exists_prime R)).irreducible
split
contrapose
{ contrapose, intro h, obtain ⟨n, ha⟩ := associated_pow_irreducible h hi, obtain ⟨u, rfl⟩ := ha.symm, rw [mul_comm, add_val_def' u hi n], exact enat.coe_ne_top _ }
intro h
obtain ⟨n, ha⟩ := associated_pow_irreducible h hi
obtain ⟨u, rfl⟩ := ha.symm
rw [mul_comm, add_val_def' u hi n]
exact enat.coe_ne_top _
rintro rfl
{ rintro rfl, exact add_val_zero }
exact add_val_zero
intros
rw [← add_zero a, mul_single_coeff_add, add_zero]
intros
rw [←dvd_dvd_iff_associated, le_antisymm_iff, and_comm]
apply and_congr; rw span_singleton_le_span_singleton
apply and_congr
rw span_singleton_le_span_singleton
rw span_singleton_le_span_singleton
intros
have : ideal.span ({a} : set α) ≠ ⊤
intro H
{ intro H, rw ideal.span_singleton_eq_top at H, contradiction }
rw ideal.span_singleton_eq_top at H
contradiction
rcases ideal.exists_le_maximal _ this with ⟨I, Imax, H⟩
use [I, Imax]
apply H
apply ideal.subset_span
exact set.mem_singleton a
intros
rw [int.coe_nat_dvd_left, int.coe_nat_dvd_left]
exact int.prime.dvd_mul hp h
intros
rw [← int.nat_cast_eq_coe_nat, coe_power_series, of_power_series_apply_coeff]
intros
{ unfold has_neg.neg localization.neg, apply lift_on_mk }
unfold has_neg.neg localization.neg
apply lift_on_mk
intros
rw [eq_smul_of_le_smul_of_le_jacobson hN hIN hIjac, submodule.bot_smul]
intros
apply coeff_pow_p f n
intros
simp only [monic, leading_coeff, nat_degree_restriction]
rw [←@coeff_restriction _ _ p]
exact ⟨λ H, by { rw H, refl }, λ H, subtype.coe_injective H⟩
intros
rintro rfl
exact (hp 0 (dvd_zero (C 0))).ne_zero rfl
intros
obtain ⟨d, hd⟩ : ∃ d, coeff d φ ≠ 0 := exists_coeff_ne_zero hφ
rw [← hm hd, ← hn hd]
intros
suffices : num A r ∣ (scale_roots p (denom A r)).coeff 0
simp only [coeff_scale_roots, nat.sub_zero] at this
{ simp only [coeff_scale_roots, nat.sub_zero] at this, haveI := classical.prop_decidable, by_cases hr : num A r = 0, { obtain ⟨u, hu⟩ := (is_unit_denom_of_num_eq_zero hr).pow p.nat_degree, rw ←hu at this, exact units.dvd_mul_right.mp this }, { refine dvd_of_dvd_mul_left_of_no_prime_factors hr _ this, intros q dvd_num dvd_denom_pow hq, apply hq.not_unit, exact num_denom_reduced A r dvd_num (hq.dvd_of_dvd_pow dvd_denom_pow) } }
haveI := classical.prop_decidable
by_cases hr : num A r = 0
obtain ⟨u, hu⟩ := (is_unit_denom_of_num_eq_zero hr).pow p.nat_degree
{ obtain ⟨u, hu⟩ := (is_unit_denom_of_num_eq_zero hr).pow p.nat_degree, rw ←hu at this, exact units.dvd_mul_right.mp this }
rw ←hu at this
exact units.dvd_mul_right.mp this
refine dvd_of_dvd_mul_left_of_no_prime_factors hr _ this
{ refine dvd_of_dvd_mul_left_of_no_prime_factors hr _ this, intros q dvd_num dvd_denom_pow hq, apply hq.not_unit, exact num_denom_reduced A r dvd_num (hq.dvd_of_dvd_pow dvd_denom_pow) }
intros q dvd_num dvd_denom_pow hq
apply hq.not_unit
exact num_denom_reduced A r dvd_num (hq.dvd_of_dvd_pow dvd_denom_pow)
convert dvd_term_of_is_root_of_dvd_terms 0 (num_is_root_scale_roots_of_aeval_eq_zero hr) _
{ rw [pow_zero, mul_one] }
rw [pow_zero, mul_one]
intros j hj
apply dvd_mul_of_dvd_right
convert pow_dvd_pow (num A r) (nat.succ_le_of_lt (bot_lt_iff_ne_bot.mpr hj))
exact (pow_one _).symm
intros
rw [coeff_X_pow, if_pos rfl]
intros
simp only [mem_roots_of_unity, mem_nth_roots k.pos, units.ext_iff, units.coe_one, units.coe_pow]
intros
split
intro hξ
{ intro hξ, obtain ⟨i, hik, rfl⟩ := h.eq_pow_of_pow_eq_one hξ.pow_eq_one h0, rw h.pow_iff_coprime h0 at hξ, exact ⟨i, hik, hξ, rfl⟩ }
obtain ⟨i, hik, rfl⟩ := h.eq_pow_of_pow_eq_one hξ.pow_eq_one h0
rw h.pow_iff_coprime h0 at hξ
exact ⟨i, hik, hξ, rfl⟩
{ rintro ⟨i, -, hi, rfl⟩, exact h.pow_of_coprime i hi }
rintro ⟨i, -, hi, rfl⟩
exact h.pow_of_coprime i hi
intros
rcases i with ⟨_ | _ | _ | _ | i_val, ⟨⟩⟩
intros
apply constant_coeff_witt_structure_int p _ _ n
simp only [mul_zero, ring_hom.map_mul, constant_coeff_X]
intros
simp only [init, tail, ← not_lt, select_add_select_not]
intros
calc witt_structure_rat p Φ n = C (1 / p ^ n : ℚ) * (witt_structure_rat p Φ n * C (p ^ n : ℚ)) : _ ... = _ : by rw witt_structure_rat_rec_aux
rw [mul_left_comm, ← C_mul, div_mul_cancel, C_1, mul_one]
exact pow_ne_zero _ (nat.cast_ne_zero.2 hp.1.ne_zero)
intros
ext1 x
simp only [truncate_truncate, function.comp_app, ring_hom.coe_comp]
intros
split
intro hbad
{ intro hbad, rw [first_loses_symm G, le_def_lt], split, { intro i, specialize hbad i, exact hbad.2 }, { intro j, exact pempty.elim j } }
rw [first_loses_symm G, le_def_lt]
split
intro i
{ intro i, specialize hbad i, exact hbad.2 }
specialize hbad i
exact hbad.2
intro j
{ intro j, exact pempty.elim j }
exact pempty.elim j
intros hp i
{ intros hp i, rw first_wins_symm, exact (le_def_lt.1 $ (first_loses_symm G).1 hp).1 i }
rw first_wins_symm
exact (le_def_lt.1 $ (first_loses_symm G).1 hp).1 i
intros
rcases zero_or_succ_or_limit b with rfl|⟨b,rfl⟩|lb
{ exact (lt_irrefl _).elim b0 }
exact (lt_irrefl _).elim b0
{ rw mul_succ, exact add_is_limit _ l }
rw mul_succ
exact add_is_limit _ l
{ exact mul_is_limit l.pos lb }
exact mul_is_limit l.pos lb
rw lt_def
right
use punit.star
split
split; rintro ⟨ ⟩
rintro ⟨ ⟩
exact zero_lt_one
rintro ⟨ ⟩
intros
simp
intros
simpa [normalize_fin_lt] using h
intros
induction x using alexandroff.rec; simp
induction x using alexandroff.rec
simp
simp
intros
simpa only [div_eq_mul_inv] using hf.mul tendsto_const_nhds
intros
simp only [has_sum, sum_add_distrib]; exact hf.add hg
simp only [has_sum, sum_add_distrib]
exact hf.add hg
intros
simpa only using hf.map (add_monoid_hom.mul_right a₂) (continuous_id.mul continuous_const)
intros
apply has_continuous_mul.of_nhds_one hmul hleft
intros x₀
simp_rw [mul_comm, hleft x₀]
intros
refine mem_of_superset (set_pi_mem_nhds (finite.of_fintype _) (λ i _, _)) (pi_univ_Ioo_subset a b)
exact Ioo_mem_nhds (ha i) (hb i)
intros
simpa only [(∘), neg_mul_eq_mul_neg, neg_neg] using tendsto_neg_at_top_at_bot.comp (hf.at_top_mul (neg_pos.2 hC) hg.neg)
intros
simp [frontier]
intros
haveI := inhabited_of_nonempty hs.to_subtype; exact (surj_on_iff_surjective.2 $ (continuous_on_iff_continuous_restrict.1 hf).surjective htop hbot)
haveI := inhabited_of_nonempty hs.to_subtype
exact (surj_on_iff_surjective.2 $ (continuous_on_iff_continuous_restrict.1 hf).surjective htop hbot)
intros
simp only [frontier_eq_closure_inter_closure, compl_compl, inter_comm]
intros
suffices : mono f ↔ mono ((forget Top).map f)
{ rw [this, category_theory.mono_iff_injective], refl }
rw [this, category_theory.mono_iff_injective]
refl
split
{ apply right_adjoint_preserves_mono adj₁ }
apply right_adjoint_preserves_mono adj₁
{ apply faithful_reflects_mono }
apply faithful_reflects_mono
intros
apply subtype.eq
{ apply subtype.eq, funext x, exact congr_fun (completion.extension_comp_coe f.property) x }
funext x
exact congr_fun (completion.extension_comp_coe f.property) x
intros
{ cases ab, exact ha.prod_nhds hb }
cases ab
exact ha.prod_nhds hb
intros
simp
intros
simp
intros
rintros _ ⟨x, hx, rfl⟩
exact (hf x hx).mem_closure_image hx
intros
{ rw [local_triv_at, ←base_set_at], exact Z.mem_base_set_at b, }
rw [local_triv_at, ←base_set_at]
exact Z.mem_base_set_at b
intros
simp [mul_comm, ennreal.tsum_mul_left]
intros
rw [← summable_coe, ← summable_coe]
exact @summable_nat_add_iff ℝ _ _ _ (λ i, (f i : ℝ)) k
intros
rw [e.restr_to_local_equiv, hs.interior_eq]
intros
let U := f ⁻¹' {f y}
suffices : x ∉ Uᶜ
from not_not.1 this
intro hxV
specialize hs U Uᶜ (hf {f y}) (hf {f y}ᶜ) _ ⟨y, ⟨hy, rfl⟩⟩ ⟨x, ⟨hx, hxV⟩⟩
{ simp only [union_compl_self, subset_univ] }
simp only [union_compl_self, subset_univ]
simpa only [inter_empty, not_nonempty_empty, inter_compl_self] using hs
{ simpa only [inter_empty, not_nonempty_empty, inter_compl_self] using hs }
intros
refine open_embedding_of_embedding_open ⟨⟨_⟩, h₂⟩ h₃
apply le_antisymm (continuous_iff_le_induced.mp h₁) _
intro s
change is_open _ → is_open _
rw is_open_induced_iff
refine λ hs, ⟨f '' s, h₃ s hs, _⟩
rw preimage_image_eq _ h₂
intros
rw [mul_comm, ← div_eq_mul_inv]
exact ennreal.div_le_of_le_mul' (hf x y)
intros
rcases eq_empty_or_nonempty s with (rfl|⟨x, hx⟩)
unfreezingI { rcases eq_empty_or_nonempty s with (rfl|⟨x, hx⟩) }
{ exact is_compact_empty }
exact is_compact_empty
rcases hb.subset_ball x with ⟨r, hr⟩
{ rcases hb.subset_ball x with ⟨r, hr⟩, exact compact_of_is_closed_subset (proper_space.is_compact_closed_ball x r) hc hr }
exact compact_of_is_closed_subset (proper_space.is_compact_closed_ball x r) hc hr
intros
refine ⟨λ H ε hε, H _ (dist_mem_uniformity hε), λ H u hu, _⟩
rcases mem_uniformity_dist.1 hu with ⟨ε, εpos, hε⟩
exact (H ε εpos).mono (λ n hs x hx, hε (hs x hx))
intros
rw edist_comm y; apply edist_triangle
rw edist_comm y
apply edist_triangle
intros
change to_GH_space (quot.out p).val = p
rw ← eq_to_GH_space
exact quot.out_eq p
intros
obtain rfl : ‹measurable_space X› = borel X := borel_space.measurable_eq
unfreezingI { obtain rfl : ‹measurable_space X› = borel X := borel_space.measurable_eq }
rw dimH
intros
convert ← mem_closure_iff_inf_edist_zero
exact h.closure_eq
intros
simp only [lipschitz_on_with, lipschitz_with, set_coe.forall', restrict, subtype.edist_eq]
intros
letI := topological_space.coinduced π ‹_›
rcases mem_nhds_iff.mp hs with ⟨V, hVs, V_op, mem_V⟩
exact mem_nhds_iff.mpr ⟨π ⁻¹' V, set.preimage_mono hVs, V_op, mem_V⟩
intros
simp [path_component_in, path_component, joined_in, joined, exists_true_iff_nonempty]
intros
simp_rw [← upper_semicontinuous_within_at_univ_iff] at *
exact upper_semicontinuous_within_at_sum ha
intros
dsimp [stalk_pushforward, stalk_functor]
ext1
tactic.op_induction'
cases j
cases j_val
rw [colimit.ι_map_assoc, colimit.ι_map, colimit.ι_pre, whisker_left_app, whisker_right_app, pushforward.id_hom_app, eq_to_hom_map, eq_to_hom_refl]
dsimp
erw [category_theory.functor.map_id]
intros
simp only [mem_coclosed_compact, compl_subset_comm]
intros
let opens := {U : set α | Sᶜ ⊆ U ∧ is_open U ∧ Uᶜ.nonempty}
obtain ⟨U, ⟨Uc, Uo, Ucne⟩, h⟩ := zorn.zorn_subset opens (λ c hc hz, begin by_cases hcne : c.nonempty, { obtain ⟨U₀, hU₀⟩ := hcne, haveI : nonempty {U // U ∈ c} := ⟨⟨U₀, hU₀⟩⟩, obtain ⟨U₀compl, U₀opn, U₀ne⟩ := hc hU₀, use ⋃₀ c, refine ⟨⟨_, _, _⟩, λ U hU a ha, ⟨U, hU, ha⟩⟩, { exact λ a ha, ⟨U₀, hU₀, U₀compl ha⟩ }, { exact is_open_sUnion (λ _ h, (hc h).2.1) }, { convert_to (⋂(U : {U // U ∈ c}), U.1ᶜ).nonempty, { ext, simp only [not_exists, exists_prop, not_and, set.mem_Inter, subtype.forall, set.mem_set_of_eq, set.mem_compl_eq, subtype.val_eq_coe], refl, }, apply is_compact.nonempty_Inter_of_directed_nonempty_compact_closed, { rintros ⟨U, hU⟩ ⟨U', hU'⟩, obtain ⟨V, hVc, hVU, hVU'⟩ := zorn.chain.directed_on hz U hU U' hU', exact ⟨⟨V, hVc⟩, set.compl_subset_compl.mpr hVU, set.compl_subset_compl.mpr hVU'⟩, }, { exact λ U, (hc U.2).2.2, }, { exact λ U, (is_closed_compl_iff.mpr (hc U.2).2.1).is_compact, }, { exact λ U, (is_closed_compl_iff.mpr (hc U.2).2.1), } } }, { use Sᶜ, refine ⟨⟨set.subset.refl _, is_open_compl_iff.mpr hS, _⟩, λ U Uc, (hcne ⟨U, Uc⟩).elim⟩, rw compl_compl, exact hne, } end)
refine ⟨Uᶜ, set.compl_subset_comm.mp Uc, Ucne, is_closed_compl_iff.mpr Uo, _⟩
intros V' V'sub V'ne V'cls
have : V'ᶜ = U
refine h V'ᶜ ⟨_, is_open_compl_iff.mpr V'cls, _⟩ (set.subset_compl_comm.mp V'sub)
{ refine h V'ᶜ ⟨_, is_open_compl_iff.mpr V'cls, _⟩ (set.subset_compl_comm.mp V'sub), exact set.subset.trans Uc (set.subset_compl_comm.mp V'sub), simp only [compl_compl, V'ne], }
exact set.subset.trans Uc (set.subset_compl_comm.mp V'sub)
simp only [compl_compl, V'ne]
rw [←this, compl_compl]
intros
split
refine (@is_open_iff_mem_nhds α _ _).2 (λ a ha, mem_nhds_uniformity_iff_right.2 _)
{ refine (@is_open_iff_mem_nhds α _ _).2 (λ a ha, mem_nhds_uniformity_iff_right.2 _), rcases mem_map_iff_exists_image.1 (hs _ ha).1 with ⟨t, ht, st⟩, refine mem_of_superset ht _, rintro p pt rfl, exact st ⟨_, pt, rfl⟩ rfl }
rcases mem_map_iff_exists_image.1 (hs _ ha).1 with ⟨t, ht, st⟩
refine mem_of_superset ht _
rintro p pt rfl
exact st ⟨_, pt, rfl⟩ rfl
refine (@is_open_iff_mem_nhds β _ _).2 (λ b hb, mem_nhds_uniformity_iff_right.2 _)
{ refine (@is_open_iff_mem_nhds β _ _).2 (λ b hb, mem_nhds_uniformity_iff_right.2 _), rcases mem_map_iff_exists_image.1 (hs _ hb).2 with ⟨t, ht, st⟩, refine mem_of_superset ht _, rintro p pt rfl, exact st ⟨_, pt, rfl⟩ rfl }
rcases mem_map_iff_exists_image.1 (hs _ hb).2 with ⟨t, ht, st⟩
refine mem_of_superset ht _
rintro p pt rfl
exact st ⟨_, pt, rfl⟩ rfl
intros
simpa using x.2.1
intros
cases b; simp
cases b
simp
simp
intros
cases a; cases b; refl
cases a; cases b
cases a
cases b
refl
intros
rw [← int.add_assoc, int.add_comm a, int.add_assoc]
intros
induction xs; [refl, simp [*, cons_bind]]
induction xs
refl
simp [*, cons_bind]
intros
rw [div_def a, if_neg]
intro h₁
apply not_le_of_gt h₀ h₁.right
intros
rw [←vsub_vadd p1 p2, h, zero_vadd]
intros
{ rw [update_eq_piecewise, sum_piecewise], simp [h] }
rw [update_eq_piecewise, sum_piecewise]
simp [h]
intros
rw [←prod_union sdiff_disjoint, sdiff_union_of_subset h]
intros
classical
rw ← prod_filter_ne_one at h
rcases nonempty_of_prod_ne_one h with ⟨x, hx⟩
exact ⟨x, (mem_filter.1 hx).1, (mem_filter.1 hx).2⟩
intros
{ subst q, exact finprod_congr hfg }
subst q
exact finprod_congr hfg
intros
rw [insert_eq, finprod_mem_union' _ _ hs, finprod_mem_singleton]
{ rwa disjoint_singleton_left }
rwa disjoint_singleton_left
{ exact (finite_singleton a).inter_of_left _ }
exact (finite_singleton a).inter_of_left _
intros
cases x with j₁ x
cases y with j₂ y
obtain ⟨s, α, β, h₁, h₂⟩ := bowtie (left_to_max j₁ j₂) f (right_to_max j₁ j₂) g
apply M.mk_eq
use [s, α, β]
dsimp
simp_rw [monoid_hom.map_mul, ← comp_apply, ← F.map_comp, h₁, h₂]
intros
rw [denom_eq_conts_b, nth_cont_eq_succ_nth_cont_aux]
exact (le_of_succ_succ_nth_continuants_aux_b nth_part_denom_eq)
intros
simp only [convergents, (denominators_stable_of_terminated n_le_m terminated_at_n), (numerators_stable_of_terminated n_le_m terminated_at_n)]
intros
simpa only [← @div_self _ _ b h] using (div_add_div_same b a b).symm
intros
{ ext, simp [floor_lt, le_floor] }
ext
simp [floor_lt, le_floor]
intros
have : 1 - 1 - 0 = 0 := rfl
{ have : 1 - 1 - 0 = 0 := rfl, rw [geom_sum₂_def, sum_range_one, this, pow_zero, pow_zero, mul_one] }
rw [geom_sum₂_def, sum_range_one, this, pow_zero, pow_zero, mul_one]
intros
rw [mul_eq_one_iff_eq_inv, inv_inj]
intros
simp only [← mul_assoc, h.eq]
intros
unfold semiconj_by; assoc_rw [h.eq, h'.eq]
unfold semiconj_by
assoc_rw [h.eq, h'.eq]
intros
rw [pow_bit0, (commute.refl a).mul_pow]
intros
simp [sq]
intros
refine ⟨λ h, _, nsmul_le_nsmul $ le_of_lt ha⟩
by_contra H
exact lt_irrefl _ (lt_of_lt_of_le (nsmul_lt_nsmul ha (not_le.mp H)) h)
intros
simp
intros
simp [div_eq_mul_inv]
intros
rcases h : c.prev j with _ | ⟨j,w⟩
{ simp [h] }
simp [h]
{ simp [d_to_eq _ w, prev_eq _ w] }
simp [d_to_eq _ w, prev_eq _ w]
intros
dsimp [prev_d]
rcases c.prev j with _|⟨j',w⟩
{ exact comp_zero.symm, }
exact comp_zero.symm
dsimp [prev_d, hom.prev]
{ dsimp [prev_d, hom.prev], simp, }
simp
intros
{ rw [d_from_eq ((single₀ V).obj X) rfl], simp, }
rw [d_from_eq ((single₀ V).obj X) rfl]
simp
intros
{ rw [← set.indicator_indicator], simp [indicator] }
rw [← set.indicator_indicator]
simp [indicator]
intros
simp only [_root_.eq_bot_iff, lie_ideal_oper_eq_span, lie_submodule.lie_span_le, lie_submodule.bot_coe, set.subset_singleton_iff, set.mem_set_of_eq, exists_imp_distrib]
refine ⟨λ h z x y hz, hz.symm.trans ((lie_subalgebra.coe_bracket _ _ _).symm.trans ((coe_zero_iff_zero _ _).mpr (by apply h.trivial))), λ h, ⟨λ x y, (coe_zero_iff_zero _ _).mp (h _ x y rfl)⟩⟩
intros
suffices : ⁅map f I₁, map f I₂⁆ ≤ map f ⁅I₁, I₂⁆
exact le_antisymm (map_bracket_le f) this
{ exact le_antisymm (map_bracket_le f) this, }
rw [← lie_submodule.coe_submodule_le_coe_submodule, coe_map_of_surjective h, lie_submodule.lie_ideal_oper_eq_linear_span, lie_submodule.lie_ideal_oper_eq_linear_span, linear_map.map_span]
apply submodule.span_mono
rintros x ⟨⟨z₁, h₁⟩, ⟨z₂, h₂⟩, rfl⟩
obtain ⟨y₁, rfl⟩ := mem_map_of_surjective h h₁
obtain ⟨y₂, rfl⟩ := mem_map_of_surjective h h₂
use [⁅(y₁ : L), (y₂ : L)⁆, y₁, y₂]
apply f.map_lie
intros
rw lie_ideal.derived_series_eq_bot_iff at hI hJ ⊢
rw ← le_bot_iff
let D := derived_series_of_ideal R L
change D k I = ⊥ at hI
change D l J = ⊥ at hJ
calc D (k + l) (I + J) ≤ (D k I) + (D l J) : derived_series_of_ideal_add_le_add I J k l ... ≤ ⊥ : by { rw [hI, hJ], simp, }
intros
rw [← lie_submodule.coe_to_submodule, Inf_coe_to_submodule, submodule.Inf_coe]
ext m
simpa only [mem_Inter, mem_set_of_eq, forall_apply_eq_imp_iff₂, exists_imp_distrib]
intros
simp
intros
rw [← mul_self_inj_of_nonneg (abv_nonneg abv _) (abv_nonneg abv _), ← abv_mul abv, ← abv_mul abv]
rw [← mul_self_inj_of_nonneg (abv_nonneg abv _) (abv_nonneg abv _), ← abv_mul abv, ← abv_mul abv]; simp
simp
intros
rw [inv_mul_lt_iff h, mul_comm]
intros
rw div_le_div_iff (hd.trans_le hbd) hd
{ rw div_le_div_iff (hd.trans_le hbd) hd, exact mul_le_mul hac hbd hd.le hc }
exact mul_le_mul hac hbd hd.le hc
intros
rwa [← div_sub_div_same, sub_eq_add_neg, add_comm (b/2), ← add_assoc, ← sub_eq_add_neg, ← lt_sub_iff_add_lt, sub_self_div_two, sub_self_div_two, div_lt_div_right (@zero_lt_two α _ _)]
intros
{ rw [← mul_le_mul_iff_right a], simp }
rw [← mul_le_mul_iff_right a]
simp
intros
rw [← mul_le_mul_iff_right b, div_eq_mul_inv, inv_mul_cancel_right]
intros
by_cases b ≤ a; simp [max_def, h]
by_cases b ≤ a
simp [max_def, h]
simp [max_def, h]
intros
haveI := @linear_order.decidable_le α _; exact ⟨λ h', le_of_mul_le_mul_left h' h, λ h', decidable.mul_le_mul_of_nonneg_left h' h.le⟩
haveI := @linear_order.decidable_le α _
exact ⟨λ h', le_of_mul_le_mul_left h' h, λ h', decidable.mul_le_mul_of_nonneg_left h' h.le⟩
intros
rw [← sub_pos, ← sub_mul]
exact ordered_ring.mul_pos _ _ (sub_pos.2 h₁) h₂
intros
cases s with l hl
convert coeff_multiset_prod_of_nat_degree_le (l.map f) _ _
{ simp }
simp
{ simp }
simp
{ simpa using h }
simpa using h
intros
have : ∀ x : K, 0 ≤ a*x*x + b*x + c := assume x, le_of_lt (h x)
refine lt_of_le_of_ne (discrim_le_zero this) _
assume h'
have := h (-b / (2 * a))
have : a * (-b / (2 * a)) * (-b / (2 * a)) + b * (-b / (2 * a)) + c = 0
rw [quadratic_eq_zero_iff_of_discrim_eq_zero ha h' (-b / (2 * a))]
{ rw [quadratic_eq_zero_iff_of_discrim_eq_zero ha h' (-b / (2 * a))] }
linarith
intros
ext
ext; simp [two_mul]
simp [two_mul]
simp [two_mul]
simp [two_mul]
simp [two_mul]
intros
rw [← sub_eq_zero, mul_self_sub_mul_self, mul_eq_zero, or_comm, sub_eq_zero, add_eq_zero_iff_eq_neg]
intros
simp only [two_mul, add_mul, mul_add, add_assoc, mul_comm b]
intros
intros x y h'
simp only at h'
rw ←sub_eq_zero
refine h _ _
rw [sub_mul, sub_eq_zero, h']
intros
{ rw [add_comm a b, add_comm a c], exact rel.add_left h }
rw [add_comm a b, add_comm a c]
exact rel.add_left h
intros
rw add_eq_iff
split
rintro (⟨rfl, h⟩|⟨rfl, h⟩)
{ rintro (⟨rfl, h⟩|⟨rfl, h⟩), { exact ⟨rfl, le_antisymm (le_zero _) h⟩ }, { exact ⟨le_antisymm (le_zero _) h, rfl⟩ } }
{ exact ⟨rfl, le_antisymm (le_zero _) h⟩ }
exact ⟨rfl, le_antisymm (le_zero _) h⟩
{ exact ⟨le_antisymm (le_zero _) h, rfl⟩ }
exact ⟨le_antisymm (le_zero _) h, rfl⟩
rintro ⟨rfl, rfl⟩
{ rintro ⟨rfl, rfl⟩, simp }
simp
intros
rw [const_mul, const_congr R rfl (mul_comm g f), const_self]
intros
ext v i
simp [apply_composition, zero_lt_one.trans_le (c.one_le_blocks_fun i), remove_zero_of_pos]
intros
rcases h.exists_pos with ⟨C, C₀, hC⟩
rw [is_O_with, eventually_cofinite] at hC
rcases (hC.to_finset.image (λ x, ∥f x∥ / ∥g' x∥)).exists_le with ⟨C', hC'⟩
have : ∀ x, C * ∥g' x∥ < ∥f x∥ → ∥f x∥ / ∥g' x∥ ≤ C'
simpa using hC'
simpa using hC'
refine ⟨max C C', lt_max_iff.2 (or.inl C₀), λ x h₀, _⟩
rw [max_mul_of_nonneg _ _ (norm_nonneg _), le_max_iff, or_iff_not_imp_left, not_le]
exact λ hx, (div_le_iff (norm_pos_iff.2 h₀)).1 (this _ hx)
intros
rw [conformal_at_iff_is_conformal_map_fderiv, is_conformal_map_iff]
intros
convert (has_strict_deriv_at_const _ _).mul hd
rw [zero_mul, zero_add]
intros
rw [← has_deriv_within_at_univ] at *
exact hc.smul hf
intros
induction n with n ihn
{ exact has_strict_fderiv_at_id x }
exact has_strict_fderiv_at_id x
change has_strict_fderiv_at (f^[n] ∘ f) (f'^(n+1)) x
{ change has_strict_fderiv_at (f^[n] ∘ f) (f'^(n+1)) x, rw [pow_succ'], refine has_strict_fderiv_at.comp x _ hf, rwa hx }
rw [pow_succ']
refine has_strict_fderiv_at.comp x _ hf
rwa hx
intros
simp only [sub_eq_add_neg, fderiv_within_add_const hxs]
intros
rw [← has_fderiv_within_at_univ, ← has_fderiv_within_at_univ, iso.comp_has_fderiv_within_at_iff]
intros
simp only [differentiable_within_at, has_fderiv_within_at, has_fderiv_at_filter, nhds_within_restrict'' s ht]
intros
rw [iterated_deriv_within_eq_iterated_fderiv_within, ← continuous_multilinear_map.map_smul_univ]
simp
intros
rcases exists_ratio_has_deriv_at_eq_ratio_slope f f' hab hfc hff' id 1 continuous_id.continuous_on (λ x hx, has_deriv_at_id x) with ⟨c, cmem, hc⟩
use [c, cmem]
simp only [_root_.id, pi.one_apply, mul_one] at hc
rw [← hc, mul_div_cancel_left]
exact ne_of_gt (sub_pos.2 hab)
intros
let c := λn:ℕ, (2:ℝ)^n
let d := λn:ℕ, (c n)⁻¹ • (y-x)
refine ⟨c, d, filter.univ_mem' (λn, h _), _, _⟩
show x + d n ∈ segment ℝ x y
rw segment_eq_image
{ rw segment_eq_image, refine ⟨(c n)⁻¹, ⟨_, _⟩, _⟩, { rw inv_nonneg, apply pow_nonneg, norm_num }, { apply inv_le_one, apply one_le_pow_of_one_le, norm_num }, { simp only [d, sub_smul, smul_sub, one_smul], abel } }
refine ⟨(c n)⁻¹, ⟨_, _⟩, _⟩
{ rw inv_nonneg, apply pow_nonneg, norm_num }
rw inv_nonneg
apply pow_nonneg
norm_num
norm_num
{ apply inv_le_one, apply one_le_pow_of_one_le, norm_num }
apply inv_le_one
apply one_le_pow_of_one_le
norm_num
{ simp only [d, sub_smul, smul_sub, one_smul], abel }
simp only [d, sub_smul, smul_sub, one_smul]
abel
show filter.tendsto (λ (n : ℕ), ∥c n∥) filter.at_top filter.at_top
have : (λ (n : ℕ), ∥c n∥) = c
{ have : (λ (n : ℕ), ∥c n∥) = c, by { ext n, exact abs_of_nonneg (pow_nonneg (by norm_num) _) }, rw this, exact tendsto_pow_at_top_at_top_of_one_lt (by norm_num) }
ext n
ext n
{ ext n, exact abs_of_nonneg (pow_nonneg (by norm_num) _) }
{ ext n, exact abs_of_nonneg (pow_nonneg (by norm_num) _) }
exact abs_of_nonneg (pow_nonneg (by norm_num) _)
exact abs_of_nonneg (pow_nonneg (by norm_num) _)
rw this
exact tendsto_pow_at_top_at_top_of_one_lt (by norm_num)
show filter.tendsto (λ (n : ℕ), c n • d n) filter.at_top (𝓝 (y - x))
have : (λ (n : ℕ), c n • d n) = (λn, y - x)
{ have : (λ (n : ℕ), c n • d n) = (λn, y - x), { ext n, simp only [d, smul_smul], rw [mul_inv_cancel, one_smul], exact pow_ne_zero _ (by norm_num) }, rw this, apply tendsto_const_nhds }
ext n
{ ext n, simp only [d, smul_smul], rw [mul_inv_cancel, one_smul], exact pow_ne_zero _ (by norm_num) }
simp only [d, smul_smul]
rw [mul_inv_cancel, one_smul]
exact pow_ne_zero _ (by norm_num)
rw this
apply tendsto_const_nhds
intros
simp only [← times_cont_diff_on_univ, times_cont_diff_on_all_iff_nat]
intros
refine ⟨λ H, H.continuous_on, λ H, _⟩
assume x hx m hm
have : (m : with_top ℕ) = 0 := le_antisymm hm bot_le
rw this
refine ⟨insert x s, self_mem_nhds_within, ftaylor_series_within 𝕜 f s, _⟩
rw has_ftaylor_series_up_to_on_zero_iff
exact ⟨by rwa insert_eq_of_mem hx, λ x hx, by simp [ftaylor_series_within]⟩
intros
simp only [segment, image, prod.exists, mem_set_of_eq, exists_prop, and_assoc]
intros
intros x y hx hy a b ha hb hab
obtain ⟨x', hx', rfl⟩ := mem_image_iff_bex.1 hx
obtain ⟨y', hy', rfl⟩ := mem_image_iff_bex.1 hy
refine ⟨a • x' + b • y', hs hx' hy' ha hb hab, _⟩
rw [smul_add, smul_add, add_add_add_comm, ←add_smul, hab, one_smul]
intros
refine ⟨_, λ hx, ⟨singleton_subset_iff.1 hx.1, λ x₁ x₂ hx₁ hx₂, hx.2 x₁ x₂ hx₁ hx₂ x rfl⟩⟩
rintro ⟨hxA, hAx⟩
use singleton_subset_iff.2 hxA
rintro x₁ x₂ hx₁A hx₂A y (rfl : y = x)
exact hAx x₁ x₂ hx₁A hx₂A
intros
set t := {p : E × ℝ | p.1 ∈ s ∧ g p.1 ≤ p.2}
have ht_conv : convex ℝ t := hg.convex_epigraph
have ht_closed : is_closed t := (hsc.preimage continuous_fst).is_closed_le (hgc.comp continuous_on_fst (subset.refl _)) continuous_on_snd
have ht_mem : ∀ᵐ x ∂μ, (f x, g (f x)) ∈ t := hfs.mono (λ x hx, ⟨hx, le_rfl⟩)
simpa [integral_pair hfi hgi] using (ht_conv.smul_integral_mem ht_closed hμ ht_mem (hfi.prod_mk hgi)).2
intros
simp only [inner_sub_left, inner_sub_right]; ring
simp only [inner_sub_left, inner_sub_right]
ring
intros
{ simp [sub_eq_add_neg, inner_add_left] }
simp [sub_eq_add_neg, inner_add_left]
intros
{ have h := @norm_add_mul_self ℝ F _ _, simpa using h }
have h := @norm_add_mul_self ℝ F _ _
simpa using h
intros
rw [ball_eq_preimage, ← to_euclidean.preimage_closure, closure_ball (to_euclidean x) h, closed_ball_eq_preimage]
intros
exact_mod_cast real.arith_mean_le_rpow_mean s _ _ (λ i _, (w i).coe_nonneg) (by exact_mod_cast hw') (λ i _, (z i).coe_nonneg) hp
intros
rw [point_reflection_apply, dist_eq_norm_vsub V, vadd_vsub_assoc, bit0]
intros
ext z
simp only [set.mem_preimage, mem_sphere_iff_norm]
abel
intros
{ convert tendsto_iff_dist_tendsto_zero, simp [dist_eq_norm] }
convert tendsto_iff_dist_tendsto_zero
simp [dist_eq_norm]
intros
simpa [comp_range, incl_range, ← add_monoid_hom.range_eq_map]
intros
obtain ⟨n : M, hn : mk' S n = mk' S m, hn' : ∥n∥ < ∥mk' S m∥ + ε⟩ := norm_mk_lt (quotient_add_group.mk' S m) hε
erw [eq_comm, quotient_add_group.eq] at hn
use [- m + n, hn]
rwa [add_neg_cancel_left]
intros
ext1
{ ext1, rw [to_span_singleton_apply, smul_apply, to_span_singleton_apply, smul_comm], }
rw [to_span_singleton_apply, smul_apply, to_span_singleton_apply, smul_comm]
intros
rw [ennreal.tsum_eq_supr_nat' (tendsto_at_top_mono nat.le_succ tendsto_id), two_mul, ← two_nsmul]
refine supr_le (λ n, le_trans _ (add_le_add_left (nsmul_le_nsmul_of_le_right (ennreal.sum_le_tsum $ finset.Ico 2 (2^n + 1)) _) _))
simpa using finset.sum_condensed_le hf n
simp [arg, le_refl]
simp [log]
intros
rw [← not_lt, log_pos_iff hx, not_lt]
intros
refine (is_equivalent_at_top_div P Q).symm.tendsto_nhds _
rw show (P.nat_degree : ℤ) = Q.nat_degree, by simp [hdeg, nat_degree]
simp [tendsto_const_nhds]
intros
simp [top_rpow_def, h]
intros
{ simp only [cpow_def], split_ifs; simp [*, exp_ne_zero] }
simp only [cpow_def]
split_ifs
split_ifs; simp [*, exp_ne_zero]
simp [*, exp_ne_zero]
simp [*, exp_ne_zero]
simp [*, exp_ne_zero]
intros
simpa only [← complex.of_real_inj, complex.of_real_sub, complex.of_real_div, complex.of_real_pow, complex.of_real_mul, complex.of_real_tan, complex.of_real_bit0, complex.of_real_one] using complex.tan_two_mul
intros
convert (has_strict_deriv_at_sin x).div (has_strict_deriv_at_cos x) h
rw ← sin_sq_add_cos_sq x
ring
intros
refine (monotone_mul_left_of_nonneg hc).seq_pos_lt_seq_of_le_of_lt hn _ _ h
{ simp }
simp
{ simp [pow_succ, mul_assoc, le_refl] }
simp [pow_succ, mul_assoc, le_refl]
intros
rw [sub_def, ←category.assoc, prod.comp_lift, sub_def]
intros
suffices : is_iso ((transfer_nat_trans_self adj₁ adj₂) ((transfer_nat_trans_self adj₁ adj₂).symm f))
{ simpa using this }
simpa using this
apply_instance
intros
{ convert w (𝟙 Y), tidy }
convert w (𝟙 Y)
tidy
intros
{ dsimp [fun_inv_id_assoc], tidy }
dsimp [fun_inv_id_assoc]
tidy
intros
dsimp [coeq₃_hom]
slice_lhs 2 4 { rw [← category.assoc, coeq_condition _ _] }
slice_rhs 2 4 { rw [← category.assoc, coeq_condition _ _] }
slice_lhs 1 3 { rw [← category.assoc, coeq_condition _ _] }
simp only [category.assoc]
intros
simp only [has_limit.iso_of_equivalence, is_limit.cone_points_iso_of_equivalence_hom]
dsimp
simp
intros
ext
ext; rw [←assoc, colimit.ι_pre, colimit.ι_map, ←assoc, colimit.ι_map, assoc, colimit.ι_pre]; refl
ext; rw [←assoc, colimit.ι_pre, colimit.ι_map, ←assoc, colimit.ι_map, assoc, colimit.ι_pre]
rw [←assoc, colimit.ι_pre, colimit.ι_map, ←assoc, colimit.ι_map, assoc, colimit.ι_pre]
refl
intros
tidy
intros
{ ext, simp, }
ext
simp
intros
rw [←s.w left, parallel_pair_map_left]
intros
simp [image.pre_comp]
intros
{ ext, simp [kernel_iso_of_eq], }
ext
simp [kernel_iso_of_eq]
intros
rw [←id_tensor_comp_tensor_id, category.assoc, M.one_mul, left_unitor_naturality]
intros
{ rw [comp_inv_eq, assoc, associator_naturality], simp }
rw [comp_inv_eq, assoc, associator_naturality]
simp
intros
letI : is_iso (biprod.map g f) := by { rw [←biprod.braiding_map_braiding], apply_instance, }
exact is_iso_left_of_is_iso_biprod_map g f
intros
have h : (generate R) f := ⟨_, _, _, hf, id_comp _⟩
change P.map (some (some_spec h)).op (x _ _) = x f hf
rw t (some (some_spec h)) (𝟙 _) _ hf _
{ simp }
simp
simp_rw [id_comp]
apply (some_spec (some_spec (some_spec h))).2
intros
simp [image_subobject_comp_iso]
intros
apply lt_of_le_of_lt (sum_le_sum_of_subset (λ t, mem_range.2 ∘ h₁))
have z := geom_sum_mul_add 1 k
rw [geom_sum, mul_one, one_add_one_eq_two] at z
rw ← z
apply nat.lt_succ_self
intros
simp [eq_ones_iff_length, le_antisymm_iff, c.length_le]
intros
simp [h.apply_diag i]
intros
by_cases hV : (univ : finset V).nonempty
haveI : nonempty V := univ_nonempty_iff.mp hV
{ haveI : nonempty V := univ_nonempty_iff.mp hV, obtain ⟨v, hv⟩ := G.exists_maximal_degree_vertex, rw hv, apply h }
obtain ⟨v, hv⟩ := G.exists_maximal_degree_vertex
rw hv
apply h
rw not_nonempty_iff_eq_empty at hV
{ rw not_nonempty_iff_eq_empty at hV, rw [max_degree, hV, image_empty], exact zero_le k }
rw [max_degree, hV, image_empty]
exact zero_le k
intros
simp! [(<*>)]
intros
induction c generalizing k v s
refine ⟨_, ⟨s, rfl⟩, trans_gen.single _⟩
case zero' : { refine ⟨_, ⟨s, rfl⟩, trans_gen.single _⟩, simp }
simp
refine ⟨_, ⟨none, rfl⟩, head_main_ok.trans succ_ok⟩
case succ : { refine ⟨_, ⟨none, rfl⟩, head_main_ok.trans succ_ok⟩ }
case tail : { let o : option Γ' := list.cases_on v none (λ _ _, some Γ'.cons), refine ⟨_, ⟨o, rfl⟩, _⟩, convert clear_ok _, simp, swap, refine split_at_pred_eq _ _ (tr_nat v.head) _ _ (tr_nat_nat_end _) _, cases v; exact ⟨rfl, rfl⟩ }
let o : option Γ' := list.cases_on v none (λ _ _, some Γ'.cons)
refine ⟨_, ⟨o, rfl⟩, _⟩
convert clear_ok _
simp
swap
refine split_at_pred_eq _ _ (tr_nat v.head) _ _ (tr_nat_nat_end _) _
cases v; exact ⟨rfl, rfl⟩
cases v
exact ⟨rfl, rfl⟩
exact ⟨rfl, rfl⟩
case cons : f fs IHf IHfs { obtain ⟨c, h₁, h₂⟩ := IHf (cont.cons₁ fs v k) v none, refine ⟨c, h₁, trans_gen.head rfl $ (move_ok dec_trivial (split_at_pred_ff _)).trans _⟩, simp [step_normal], refine (copy_ok _ none [] (tr_list v).reverse _ _).trans _, convert h₂ using 2, simp [list.reverse_core_eq, tr_cont_stack] }
case comp : f g IHf IHg { exact IHg (cont.comp f k) v s }
case case : f g IHf IHg { rw step_normal, obtain ⟨s', h⟩ := pred_ok _ _ s v _ _, cases v.head with n, { obtain ⟨c, h₁, h₂⟩ := IHf k _ s', exact ⟨_, h₁, h.trans h₂⟩ }, { obtain ⟨c, h₁, h₂⟩ := IHg k _ s', exact ⟨_, h₁, h.trans h₂⟩ } }
case fix : f IH { apply IH }
intros
rcases s with _|_|_; unfold tr_stmts₁ st_run
rcases s with _|_|_
unfold tr_stmts₁ st_run
unfold tr_stmts₁ st_run
unfold tr_stmts₁ st_run
intros
induction i generalizing T; [refl, simp only [*, tape.move_right_nth, int.coe_nat_succ, iterate_succ]]
induction i generalizing T
refl
simp only [*, tape.move_right_nth, int.coe_nat_succ, iterate_succ]
intros
cases x; simp [sum.traverse, id_map] with functor_norm; refl
cases x; simp [sum.traverse, id_map] with functor_norm
cases x
simp [sum.traverse, id_map] with functor_norm
refl
simp [sum.traverse, id_map] with functor_norm
refl
intros
cases h; subst h; [cases b₁, cases b₀]; simp [to_nat,nat.zero_le]
cases h; subst h; [cases b₁, cases b₀]
cases h; subst h
cases h
subst h
cases b₁
simp [to_nat,nat.zero_le]
simp [to_nat,nat.zero_le]
simp [to_nat,nat.zero_le]
subst h
cases b₀
simp [to_nat,nat.zero_le]
simp [to_nat,nat.zero_le]
simp [to_nat,nat.zero_le]
intros
{ cases b, simp [to_list] }
cases b
simp [to_list]
intros
contrapose! h
obtain ⟨np, err, hp⟩ := bounded.exists p h
simp [hp]
introI h
have : eof buffer.nil 0 = done 0 () := by simpa [remaining_eq_done]
replace this : 0 < 0 := prog.of_done this
exact (lt_irrefl _) this
intros
by_cases hp : p; simp [guard, hp, eq_comm, pure_eq_done]
{ by_cases hp : p; simp [guard, hp, eq_comm, pure_eq_done] }
by_cases hp : p
simp [guard, hp, eq_comm, pure_eq_done]
simp [guard, hp, eq_comm, pure_eq_done]
intros
simp [foldr_core, and_comm]
intros
rw ← of_real_inj; simp [cosh_sq]
rw ← of_real_inj
simp [cosh_sq]
intros
rw [sin_add, cos_mul_I, sin_mul_I, mul_assoc]
intros
rw [← exp_add_mul_I, re_add_im]
intros
rw [of_real_alg, one_smul]
intros
simp [norm_sq_eq_def']
simp [← finrank_eq_dim, finrank_real_complex]
intros
have := (lift_add_hom (λ a, add_monoid_hom.of_map_sub (h a) (h_sub a))).map_sub f g
rw [lift_add_hom_apply, sum_add_hom_apply, sum_add_hom_apply, sum_add_hom_apply] at this
exact this
intros
rw [filter_single, if_neg h]
intros
simpa [equiv.image_eq_preimage] using (equiv.set.congr e).forall_congr_left'
intros
rwa [equiv.perm.via_fintype_embedding, equiv.perm.extend_domain_apply_not_subtype]
intros
rw [inter_comm, e.left_inv_on.image_inter, image_source_eq_target, inter_comm]
intros
rw [←mul_one (h 1), ←h.apply_symm_apply 1, ←h.map_mul, one_mul]
intros
dsimp [pred_above, succ_above]
rcases p with ⟨p, _⟩
rcases i with ⟨i, _⟩
split_ifs
rw dif_neg
{ rw dif_neg, { refl }, { simp_rw [if_pos h], simp only [subtype.mk_lt_mk, not_lt], exact le_of_lt h, }, }
{ refl }
refl
simp_rw [if_pos h]
{ simp_rw [if_pos h], simp only [subtype.mk_lt_mk, not_lt], exact le_of_lt h, }
simp only [subtype.mk_lt_mk, not_lt]
exact le_of_lt h
rw dif_pos
{ rw dif_pos, { refl, }, { simp_rw [if_neg h], exact lt_succ_iff.mpr (not_lt.mp h), }, }
{ refl, }
refl
simp_rw [if_neg h]
{ simp_rw [if_neg h], exact lt_succ_iff.mpr (not_lt.mp h), }
exact lt_succ_iff.mpr (not_lt.mp h)
intros
simp only [insert_nth, succ_above_cases, dif_neg (succ_above_ne _ _)]
by_cases hlt : j.cast_succ < i
rw [dif_pos ((succ_above_lt_iff _ _).2 hlt)]
{ rw [dif_pos ((succ_above_lt_iff _ _).2 hlt)], apply eq_of_heq ((eq_rec_heq _ _).trans _), rw [cast_lt_succ_above hlt] }
apply eq_of_heq ((eq_rec_heq _ _).trans _)
rw [cast_lt_succ_above hlt]
rw [dif_neg (mt (succ_above_lt_iff _ _).1 hlt)]
{ rw [dif_neg (mt (succ_above_lt_iff _ _).1 hlt)], apply eq_of_heq ((eq_rec_heq _ _).trans _), rw [pred_succ_above (le_of_not_lt hlt)] }
apply eq_of_heq ((eq_rec_heq _ _).trans _)
rw [pred_succ_above (le_of_not_lt hlt)]
intros
classical
refine ⟨s.filter (∈ t₁), s.filter (∉ t₁), _, _ , _⟩
{ simp [filter_union_right, em] }
simp [filter_union_right, em]
{ intro x, simp }
intro x
simp
intro x
{ intro x, simp, intros hx hx₂, refine ⟨or.resolve_left (h hx) hx₂, hx₂⟩ }
simp
intros hx hx₂
refine ⟨or.resolve_left (h hx) hx₂, hx₂⟩
intros
obtain ⟨x, hx, y, hy, hxy⟩ := finset.one_lt_card.mp hs
by_cases ha : y = a
{ exact ⟨x, hx, ne_of_ne_of_eq hxy ha⟩ }
exact ⟨x, hx, ne_of_ne_of_eq hxy ha⟩
{ exact ⟨y, hy, ha⟩ }
exact ⟨y, hy, ha⟩
intros
rw [← card_union_add_card_inter, disjoint_iff_inter_eq_empty.1 h, card_empty, add_zero]
intros
cases max_of_nonempty (h.image f) with y hy
rcases mem_image.mp (mem_of_max hy) with ⟨x, hx, rfl⟩
exact ⟨x, hx, λ x' hx', le_max_of_mem (mem_image_of_mem f hx') hy⟩
intros
obtain ⟨sl, sl', rfl⟩ := exists_list_nodup_eq s
obtain ⟨tl, tl', rfl⟩ := exists_list_nodup_eq t
rw list.disjoint_to_finset_iff_disjoint at h
simp [sl', tl', noncomm_prod_to_finset, ←list.prod_append, ←list.to_finset_append, list.nodup_append_of_nodup sl' tl' h]
intros
{ ext, simp }
ext
simp
intros
rw [smul_single, smul_eq_mul, mul_one]
intros
ext
{ ext, simp [finsupp.single_eq_pi_single, finsupp.equiv_fun_on_fintype], }
simp [finsupp.single_eq_pi_single, finsupp.equiv_fun_on_fintype]
intros
rw [inter_comm, univ_inter]
intros
rw [← coe_nonempty, coe_univ, set.nonempty_iff_univ_nonempty]
intros
cases n; simp; refl
cases n; simp
cases n
simp
refl
simp
refl
intros
rw mul_comm; exact int.div_eq_iff_eq_mul_right H H'
rw mul_comm
exact int.div_eq_iff_eq_mul_right H H'
intros
rw [even_sub, even_iff_not_odd, even_iff_not_odd, not_iff_not]
intros
refine ext_le (by convert h) (λ n h₁ h₂, _)
simp only [nth_le_singleton]
congr
exact eq_bot_iff.mpr (nat.lt_succ_iff.mp h₂)
intros
induction l; [refl, simp only [*, map]]; split; refl
induction l; [refl, simp only [*, map]]; split
induction l; [refl, simp only [*, map]]
induction l
refl
simp only [*, map]
split
refl
refl
intros
induction l generalizing n
case list.nil : n h { simpa using h }
simpa using h
case list.cons : l_hd l_tl l_ih n h { cases n; simp only [mem_cons_iff, drop] at h ⊢, { exact h }, right, apply l_ih h }
cases n; simp only [mem_cons_iff, drop] at h ⊢
cases n
simp only [mem_cons_iff, drop] at h ⊢
{ exact h }
exact h
simp only [mem_cons_iff, drop] at h ⊢
right
apply l_ih h
intros
{ cases L, { simp, refl, }, { simp, }, }
cases L
simp
{ simp, refl, }
refl
simp
{ simp, }
intros
simp only [pmap_eq_map_attach, mem_map, mem_attach, true_and, subtype.exists]
intros
rw [(reduce_option_length_le l).lt_iff_ne, ne, reduce_option_length_eq_iff]
induction l; simp *
induction l
simp *
simp *
rw [eq_comm, ← option.not_is_some_iff_eq_none, decidable.imp_iff_not_or]
intros
induction s; intros; contradiction
induction s; intros
induction s
contradiction
contradiction
intros
rw [permutations, permutations, map, map_permutations_aux, map]
intros
induction l₁; simp only [nil_union, not_mem_nil, false_or, cons_union, mem_insert_iff, mem_cons_iff, or_assoc, *]
induction l₁
simp only [nil_union, not_mem_nil, false_or, cons_union, mem_insert_iff, mem_cons_iff, or_assoc, *]
simp only [nil_union, not_mem_nil, false_or, cons_union, mem_insert_iff, mem_cons_iff, or_assoc, *]
intros
induction xs with x xs
{ simp only [not_mem_nil, map_nil] }
simp only [not_mem_nil, map_nil]
cases x with a b
{ cases x with a b, simp only [mem_cons_iff, prod.mk.inj_iff, map, prod.swap_prod_mk, prod.exists, xs_ih, and_comm] }
simp only [mem_cons_iff, prod.mk.inj_iff, map, prod.swap_prod_mk, prod.exists, xs_ih, and_comm]
intros
{ rw ← cons_head'_tail hy at h, exact h.rel_head }
rw ← cons_head'_tail hy at h
exact h.rel_head
intros
rw [←next_reverse_eq_prev _ hn, ←next_reverse_eq_prev _ (h.nodup_iff.mp hn)]
exact is_rotated_next_eq h.reverse (nodup_reverse.mpr hn) _
intros
simp [duplicate_cons_iff, hne.symm]
intros
by_cases n < m
{ rw [eq_cons h], exact chain_succ_range' _ _ }
rw [eq_cons h]
exact chain_succ_range' _ _
{ rw [eq_nil_of_le (le_of_not_gt h)], trivial }
rw [eq_nil_of_le (le_of_not_gt h)]
trivial
intros
simp only [nodup, pairwise_cons, forall_mem_ne]
intros
induction l with hd tl IH
{ simp }
simp
rw list.pairwise_cons
{ rw list.pairwise_cons, split, { intros x hx, by_cases H : hd = x, { rw H, refine hr _ _, simpa [count_cons, H, nat.succ_lt_succ_iff, count_pos] using hx }, { exact h hd (mem_cons_self _ _) x (mem_cons_of_mem _ hx) H } }, { refine IH _ _, { intros x hx, refine hr _ _, rw count_cons, split_ifs, { exact hx.trans (nat.lt_succ_self _) }, { exact hx } }, { intros x hx y hy, exact h x (mem_cons_of_mem _ hx) y (mem_cons_of_mem _ hy) } } }
split
intros x hx
{ intros x hx, by_cases H : hd = x, { rw H, refine hr _ _, simpa [count_cons, H, nat.succ_lt_succ_iff, count_pos] using hx }, { exact h hd (mem_cons_self _ _) x (mem_cons_of_mem _ hx) H } }
by_cases H : hd = x
rw H
{ rw H, refine hr _ _, simpa [count_cons, H, nat.succ_lt_succ_iff, count_pos] using hx }
refine hr _ _
simpa [count_cons, H, nat.succ_lt_succ_iff, count_pos] using hx
{ exact h hd (mem_cons_self _ _) x (mem_cons_of_mem _ hx) H }
exact h hd (mem_cons_self _ _) x (mem_cons_of_mem _ hx) H
refine IH _ _
{ refine IH _ _, { intros x hx, refine hr _ _, rw count_cons, split_ifs, { exact hx.trans (nat.lt_succ_self _) }, { exact hx } }, { intros x hx y hy, exact h x (mem_cons_of_mem _ hx) y (mem_cons_of_mem _ hy) } }
intros x hx
{ intros x hx, refine hr _ _, rw count_cons, split_ifs, { exact hx.trans (nat.lt_succ_self _) }, { exact hx } }
refine hr _ _
rw count_cons
split_ifs
exact hx.trans (nat.lt_succ_self _)
{ exact hx.trans (nat.lt_succ_self _) }
exact hx
{ exact hx }
intros x hx y hy
{ intros x hx y hy, exact h x (mem_cons_of_mem _ hx) y (mem_cons_of_mem _ hy) }
exact h x (mem_cons_of_mem _ hx) y (mem_cons_of_mem _ hy)
intros
induction s with y s IH
{ simp }
simp
simp only [not_or_distrib, mem_cons_iff] at hx
{ simp only [not_or_distrib, mem_cons_iff] at hx, simp only [not_and, exists_eq_right_right, mem_map, permutations'_aux, nodup_cons], refine ⟨λ _, ne.symm hx.left, _⟩, rw nodup_map_iff, { exact IH hx.right }, { simp } }
simp only [not_and, exists_eq_right_right, mem_map, permutations'_aux, nodup_cons]
refine ⟨λ _, ne.symm hx.left, _⟩
rw nodup_map_iff
{ exact IH hx.right }
exact IH hx.right
{ simp }
simp
intros
induction t generalizing l₁ l₂ h; simp [*, subperm.erase]
induction t generalizing l₁ l₂ h
simp [*, subperm.erase]
simp [*, subperm.erase]
intros
rw [← length_eq_zero, length_range]
intros
rw add_comm n 1; exact (range'_append s n 1).symm
rw add_comm n 1
exact (range'_append s n 1).symm
intros
rw [is_rotated_comm, is_rotated_singleton_iff, eq_comm]
intros
simp [list.nodup_range]
intros
by_cases h : a = a'; simp [h]
by_cases h : a = a'
simp [h]
simp [h]
intros
induction s₁ with a l₁ h₁ s₁ IH generalizing l₂
{ exact p.nil_eq }
exact p.nil_eq
have : a ∈ l₂ := p.subset (mem_cons_self _ _)
{ have : a ∈ l₂ := p.subset (mem_cons_self _ _), rcases mem_split this with ⟨u₂, v₂, rfl⟩, have p' := (perm_cons a).1 (p.trans perm_middle), have := IH p' (pairwise_of_sublist (by simp) s₂), subst l₁, change a::u₂ ++ v₂ = u₂ ++ ([a] ++ v₂), rw ← append_assoc, congr, have : ∀ (x : α) (h : x ∈ u₂), x = a := λ x m, antisymm ((pairwise_append.1 s₂).2.2 _ m a (mem_cons_self _ _)) (h₁ _ (by simp [m])), rw [(@eq_repeat _ a (length u₂ + 1) (a::u₂)).2, (@eq_repeat _ a (length u₂ + 1) (u₂++[a])).2]; split; simp [iff_true_intro this, or_comm] }
rcases mem_split this with ⟨u₂, v₂, rfl⟩
have p' := (perm_cons a).1 (p.trans perm_middle)
have := IH p' (pairwise_of_sublist (by simp) s₂)
subst l₁
change a::u₂ ++ v₂ = u₂ ++ ([a] ++ v₂)
rw ← append_assoc
congr
have : ∀ (x : α) (h : x ∈ u₂), x = a := λ x m, antisymm ((pairwise_append.1 s₂).2.2 _ m a (mem_cons_self _ _)) (h₁ _ (by simp [m]))
rw [(@eq_repeat _ a (length u₂ + 1) (a::u₂)).2, (@eq_repeat _ a (length u₂ + 1) (u₂++[a])).2]
rw [(@eq_repeat _ a (length u₂ + 1) (a::u₂)).2, (@eq_repeat _ a (length u₂ + 1) (u₂++[a])).2]; split; simp [iff_true_intro this, or_comm]
rw [(@eq_repeat _ a (length u₂ + 1) (a::u₂)).2, (@eq_repeat _ a (length u₂ + 1) (u₂++[a])).2]; split
split
simp [iff_true_intro this, or_comm]
simp [iff_true_intro this, or_comm]
split
simp [iff_true_intro this, or_comm]
simp [iff_true_intro this, or_comm]
intros
rw [sublists_aux₁_eq_sublists_aux]; refl
rw [sublists_aux₁_eq_sublists_aux]
refl
intros
cases z
rw [zip, nth_zip_with_eq_some]
split
{ rintro ⟨x, y, h₀, h₁, h₂⟩, cc }
rintro ⟨x, y, h₀, h₁, h₂⟩
cc
{ rintro ⟨h₀, h₁⟩, exact ⟨_,_,h₀,h₁,rfl⟩ }
rintro ⟨h₀, h₁⟩
exact ⟨_,_,h₀,h₁,rfl⟩
intros
{ ext, apply dot_product_comm }
ext
apply dot_product_comm
intros
ext
{ext, refl}
refl
intros
simp_rw [dot_product, mul_comm]
intros
{ ext, simp }
ext
simp
intros
ext ⟨k, i⟩ ⟨k', j⟩
simp only [block_diagonal'_apply, mul_apply, ← finset.univ_sigma_univ, finset.sum_sigma]
rw fintype.sum_eq_single k
split_ifs; simp
{ split_ifs; simp }
split_ifs
simp
simp
intros j' hj'
{ intros j' hj', exact finset.sum_eq_zero (λ _ _, by rw [dif_neg hj'.symm, zero_mul]) }
exact finset.sum_eq_zero (λ _ _, by rw [dif_neg hj'.symm, zero_mul])
intros
ext i
simp_rw [vec_alt1]
rcases i with ⟨⟨⟩ | i, hi⟩
{ refl }
refl
{ simp [vec_alt1, nat.add_succ, nat.succ_add] }
simp [vec_alt1, nat.add_succ, nat.succ_add]
intros
ext
ext; simp [to_matrix, one_apply]; congr
ext; simp [to_matrix, one_apply]
simp [to_matrix, one_apply]
intros
simp [countp_eq_card_filter]
intros
rw [← rel_flip, rel_map_left, ← rel_flip]; refl
rw [← rel_flip, rel_map_left, ← rel_flip]
refl
intros
{ rw ← fin_succ_equiv_eq, refl }
rw ← fin_succ_equiv_eq
refl
intros
rw [hom_bind₁, eval₂_hom_comp_C]
intros
rw [rename, aeval_monomial, monomial_eq, finsupp.prod_map_domain_index]
{ refl }
refl
{ exact assume n, pow_zero _ }
exact assume n, pow_zero _
{ exact assume n i₁ i₂, pow_add _ _ _ }
exact assume n i₁ i₂, pow_add _ _ _
intros
simp [vars, degrees_map]
intros
conv { to_rhs, rw ←mod_add_div n k }
rcases h with ⟨t, rfl⟩
rw [mul_assoc, add_mul_mod_self_left]
intros
by_cases h : nat.find_greatest P b = 0
cases m
{ cases m, { rwa h }, exact ((find_greatest_eq_zero_iff.1 h) m.zero_lt_succ hmb hm).elim }
rwa h
{ rwa h }
exact ((find_greatest_eq_zero_iff.1 h) m.zero_lt_succ hmb hm).elim
{ exact (find_greatest_eq_iff.1 rfl).2.1 h }
exact (find_greatest_eq_iff.1 rfl).2.1 h
intros
rw [← cast_one, cast_le]
intros
conv { congr, skip, rw ←(of_digits_digits b' n) }
rw coe_int_of_digits
apply of_digits_zmodeq' _ _ _ h
intros
conv { to_lhs, rw [← coe_le_coe, coe_get, coe_get]}
intros
delta lcm; rw [mul_comm, gcd_comm]
delta lcm
rw [mul_comm, gcd_comm]
intros
apply dvd_antisymm
apply nat.coprime.dvd_of_dvd_mul_right (nat.coprime.mul (cop.gcd_left _) (cop.gcd_left _))
{ apply nat.coprime.dvd_of_dvd_mul_right (nat.coprime.mul (cop.gcd_left _) (cop.gcd_left _)), rw ← h, apply mul_dvd_mul (gcd_dvd _ _).1 (gcd_dvd _ _).1 }
rw ← h
apply mul_dvd_mul (gcd_dvd _ _).1 (gcd_dvd _ _).1
rw [gcd_comm a _, gcd_comm b _]
{ rw [gcd_comm a _, gcd_comm b _], transitivity c.gcd (a * b), rw [h, gcd_mul_right_right d c], apply gcd_mul_dvd_mul_gcd }
transitivity c.gcd (a * b)
rw [h, gcd_mul_right_right d c]
apply gcd_mul_dvd_mul_gcd
intros
rw [modeq, eq_comm, ← int.coe_nat_inj', int.coe_nat_mod, int.coe_nat_mod, int.mod_eq_mod_iff_mod_sub_eq_zero, int.dvd_iff_mod_eq_zero]
intros
convert not_even_bit1 n; exact two_mul n
convert not_even_bit1 n
exact two_mul n
intros
cases n
cases n; refl
refl
refl
refl
intros
cases x; simp
cases x
simp
simp
intros
rcases x with _ | _ | x; simp
{ rcases x with _ | _ | x; simp }
rcases x with _ | _ | x
simp
simp
simp
intros
unfold balance'
split_ifs
{ refl }
refl
{ exact hr.rotate_l_size }
exact hr.rotate_l_size
{ exact hl.rotate_r_size }
exact hl.rotate_r_size
{ refl }
refl
intros
rw [← balance_eq_balance' hl hr sl sr, balance_l_eq_balance sl sr]
intro l0
{ intro l0, rw l0 at H, rcases H with ⟨_, ⟨⟨⟩⟩|⟨⟨⟩⟩, H⟩ | ⟨r', e, H⟩, { exact balanced_sz_zero.1 H.symm }, exact le_trans (raised_iff.1 e).1 (balanced_sz_zero.1 H.symm) }
rw l0 at H
rcases H with ⟨_, ⟨⟨⟩⟩|⟨⟨⟩⟩, H⟩ | ⟨r', e, H⟩
{ exact balanced_sz_zero.1 H.symm }
exact balanced_sz_zero.1 H.symm
exact le_trans (raised_iff.1 e).1 (balanced_sz_zero.1 H.symm)
intros l1 r1
{ intros l1 r1, rcases H with ⟨l', e, H | ⟨H₁, H₂⟩⟩ | ⟨r', e, H | ⟨H₁, H₂⟩⟩, { exact le_trans (le_trans (nat.le_add_left _ _) H) (mul_pos dec_trivial l1 : (0:ℕ)<_) }, { exact le_trans H₂ (nat.mul_le_mul_left _ (raised_iff.1 e).1) }, { cases raised_iff.1 e, unfold delta, linarith }, { exact le_trans (raised_iff.1 e).1 H₂ } }
rcases H with ⟨l', e, H | ⟨H₁, H₂⟩⟩ | ⟨r', e, H | ⟨H₁, H₂⟩⟩
exact le_trans (le_trans (nat.le_add_left _ _) H) (mul_pos dec_trivial l1 : (0:ℕ)<_)
{ exact le_trans (le_trans (nat.le_add_left _ _) H) (mul_pos dec_trivial l1 : (0:ℕ)<_) }
{ exact le_trans H₂ (nat.mul_le_mul_left _ (raised_iff.1 e).1) }
exact le_trans H₂ (nat.mul_le_mul_left _ (raised_iff.1 e).1)
{ cases raised_iff.1 e, unfold delta, linarith }
cases raised_iff.1 e
unfold delta
linarith
{ exact le_trans (raised_iff.1 e).1 H₂ }
exact le_trans (raised_iff.1 e).1 H₂
intros
ext
simp only [eq_none_iff_forall_not_mem, option.mem_def, f.eq_some_iff] at h
dsimp [pequiv.trans, single]
simp
intros
split_ifs; simp * at *
split_ifs
simp * at *
simp * at *
intros
rw [W_mk, W_rec]
dsimp
rw [Wp_rec_eq]
dsimp only [W_path_dest_left_W_path_cases_on, W_path_dest_right_W_path_cases_on]
congr
congr; ext1 i; cases (f i); refl
congr; ext1 i; cases (f i)
congr; ext1 i
ext1 i
cases (f i)
refl
ext1 i
cases (f i)
refl
intros
let h : (v.prod : ℕ) = ((v.map coe).map coe).prod := (pnat.coe_monoid_hom.map_multiset_prod v.to_pnat_multiset)
rw [multiset.map_map] at h
have : (coe : ℕ+ → ℕ) ∘ (coe : nat.primes → ℕ+) = coe := funext (λ p, rfl)
rw[this] at h
exact h
intros
change u.r - 1 < u.bp
have h₀ : (u.r - 1) + 1 = u.r := nat.succ_pred_eq_of_pos (nat.pos_of_ne_zero hr)
have h₁ : u.r < u.bp + 1 := nat.mod_lt (u.ap + 1) u.bp.succ_pos
rw[← h₀] at h₁
exact lt_of_succ_lt_succ h₁
intros
induction k with k ih
{ simp, }
simp
{ simp [ih, pow_succ', ←mul_assoc, add_assoc], }
simp [ih, pow_succ', ←mul_assoc, add_assoc]
intros
cases i; simp
cases i
simp
simp
intros
simpa only [pow_one] using @leading_coeff_X_pow R _ 1
intros
rw ← degree_neg q at h
{ rw ← degree_neg q at h, rw [sub_eq_add_neg, degree_add_eq_left_of_degree_lt h] }
rw [sub_eq_add_neg, degree_add_eq_left_of_degree_lt h]
intros
rw [trailing_degree, support_monomial _ _ ha, inf_singleton, with_top.some_eq_coe]
intros
rw [C_mul_X_pow_eq_monomial, self_sub_monomial_nat_degree_leading_coeff]
intros
rw [←C_eq_nat_cast, C_comp]
intros
rw X_pow_eq_monomial
convert eval₂_monomial f x
simp
intros
simp only [← coeff_nat_degree, coeff_map f, nat_degree_map]
intros
simp [div_X, coeff_C]
intros
simp only [coe_map_ring_hom, lifts, map_alg_eq_map, alg_hom.mem_range, ring_hom.mem_srange]
intros
nontriviality
simp only [← coeff_one_reverse]
rw reverse_mul; simp [coeff_mul, nat.antidiagonal, hp.leading_coeff, hq.leading_coeff, add_comm]
rw reverse_mul
simp [coeff_mul, nat.antidiagonal, hp.leading_coeff, hq.leading_coeff, add_comm]
simp [coeff_mul, nat.antidiagonal, hp.leading_coeff, hq.leading_coeff, add_comm]
intros
apply taylor_injective r
rw linear_map.map_zero
ext k
simp only [taylor_coeff, h, coeff_zero]
intros
rcases h with ⟨c, rfl⟩
simp only [mul_comm b, int.mul_div_assoc c (dvd_refl b), int.cast_mul, mul_div_assoc, coe_int_div_self]
intros
refine le_antisymm (mk_real ▸ mk_set_le _) _
rw [← not_lt]
intro h
refine ne_of_lt _ mk_univ_real
have hu : Iio a ∪ {a} ∪ Ioi a = set.univ
{ convert Iic_union_Ioi, exact Iio_union_right }
convert Iic_union_Ioi
exact Iio_union_right
rw ← hu
refine lt_of_le_of_lt (mk_union_le _ _) _
refine lt_of_le_of_lt (add_le_add_right (mk_union_le _ _) _) _
have h2 : (λ x, a + a - x) '' Ioi a = Iio a
{ convert image_const_sub_Ioi _ _, simp }
convert image_const_sub_Ioi _ _
simp
rw ← h2
refine add_lt_of_lt (cantor _).le _ h
refine add_lt_of_lt (cantor _).le (mk_image_le.trans_lt h) _
rw mk_singleton
exact one_lt_omega.trans (cantor _)
intros
rw [ennreal.of_real, ennreal.of_real, coe_lt_coe, real.to_nnreal_lt_to_nnreal_iff h]
intros
conv_lhs { rw [← ennreal.of_real_coe_nat n, ennreal.to_real_of_real (nat.cast_nonneg _)] }
intros
by_cases h' : x = ⊥
{ simp only [h', bot_le] }
simp only [h', bot_le]
{ simp only [le_refl, coe_to_real h h'] }
simp only [le_refl, coe_to_real h h']
intros
rwa [st_of_is_st hxr]
intros
simpa only [add_zero] using is_st_add hx hy
intros
simp [real.to_nnreal, nnreal.coe_lt_coe.symm, lt_irrefl]
intros
simpa using div_add_div b a one_ne_zero hc
intros
obtain hn | rfl | hp := lt_trichotomy r (0 : ℝ)
{ exact (or.inl $ sign_of_neg hn) }
exact (or.inl $ sign_of_neg hn)
{ exact (h rfl).elim }
exact (h rfl).elim
{ exact (or.inr $ sign_of_pos hp) }
exact (or.inr $ sign_of_pos hp)
intros
cases le_or_lt x 0
{ rw [sqrt_eq_zero'.mpr h, div_zero] }
rw [sqrt_eq_zero'.mpr h, div_zero]
rw [div_eq_iff (sqrt_ne_zero'.mpr h), mul_self_sqrt h.le]
{ rw [div_eq_iff (sqrt_ne_zero'.mpr h), mul_self_sqrt h.le] }
intros
revert h; rw eq_mk_of_mem aq; intro; refl
revert h; rw eq_mk_of_mem aq; intro
revert h; rw eq_mk_of_mem aq
revert h
rw eq_mk_of_mem aq
intro
refl
intros
rw bind_ret; change (λ x : α, x) with @id α; rw map_id
rw bind_ret; change (λ x : α, x) with @id α
rw bind_ret
change (λ x : α, x) with @id α
rw map_id
intros
simp [set.ite]
intros
rw [←image_inter_preimage, nonempty_image_iff]
intros
rw range_subset_iff
intro x
by_cases h : p x
simp [if_pos h, mem_union, mem_range_self]
simp [if_neg h, mem_union, mem_range_self]
intros
{ ext ⟨x, y⟩, simp [and.left_comm, eq_comm] }
ext ⟨x, y⟩
simp [and.left_comm, eq_comm]
intros
simp [classical.skolem, set.nonempty]
intros
simp
intros
rw [← image_univ, univ_eq, image_pair]
intros
simp [finset.ext_iff, mem_insert_iff]
intros
by_cases hx : x ∈ s; simp [hx]
by_cases hx : x ∈ s
simp [hx]
simp [hx]
intros
rw [inter_comm, Ioc_inter_Ioo_of_right_le h, max_comm]
intros
rw [←diff_eq_empty, Iio_diff_Iic, Ioo_eq_empty_iff, not_lt]
intros
simp [← Ioi_inter_Iic]
intros
simp
intros
simp [← Ici_inter_Iio, ← Ioi_inter_Iic, h, inter_comm]
intros
simp_rw [pi_univ_Ioc_update_left hm.1, pi_univ_Ioc_update_right hm.2, ← union_inter_distrib_right, ← set_of_or, le_or_lt, set_of_true, univ_inter]
intros
simp
intros
rintro a ⟨⟨b, hb, eq⟩, c, hc, rfl⟩; exact h b hb c hc eq
rintro a ⟨⟨b, hb, eq⟩, c, hc, rfl⟩
exact h b hb c hc eq
intros
simp
intros
simp
intros
tidy
intros
ext x
ext x; cases x
cases x
intros
simp only [←cons_head_tail, eq_iff_true_of_subsingleton]
intros
rw [← nat.cast_add_one, nat_cast_self (n + 1)]
intros
rw [← @nat.cast_one (zmod 2), zmod.eq_iff_modeq_nat, nat.odd_iff, nat.modeq]
{ rw [← @nat.cast_one (zmod 2), zmod.eq_iff_modeq_nat, nat.odd_iff, nat.modeq], norm_num }
norm_num
intros
refine {..}; simp
refine {..}
simp
simp
simp
simp
intros
simpa only [nsmul_eq_mul, add_right_iterate] using (f.commute_add_int m).symm.iterate_le_of_map_le (monotone_id.add_const m) f.monotone h n
intros
rcases ennreal.exists_nat_mul_gt hs' (measure_ne_top μ (univ : set α)) with ⟨N, hN⟩
rcases hf.exists_mem_image_mem_of_volume_lt_mul_volume hs hN with ⟨x, hx, m, hm, hmx⟩
exact ⟨x, hx, m, hm.1.ne', hmx⟩
intros
rw [is_periodic_pt, ← iterate_mul, mul_comm, iterate_mul]
exact hf.is_fixed_pt.iterate m
intros
apply_instance
intros
cases h with t ht
exact ⟨t, (eq_adjoin_of_eq_algebra_adjoin _ _ _ ht.symm).symm⟩
intros
have h1 : (X : polynomial K').degree < (X ^ p : polynomial K').degree
rw [degree_X_pow, degree_X]
{ rw [degree_X_pow, degree_X], exact_mod_cast hp }
exact_mod_cast hp
rw [nat_degree_eq_of_degree_eq (degree_sub_eq_left_of_degree_lt h1), nat_degree_X_pow]
intros
have hdegle : (minpoly A (algebra_map A B a)).nat_degree ≤ 1
apply with_bot.coe_le_coe.1
{ apply with_bot.coe_le_coe.1, rw [←degree_eq_nat_degree (ne_zero (@is_integral_algebra_map A B _ _ _ a)), with_top.coe_one, ←degree_X_sub_C a], refine min A (algebra_map A B a) (monic_X_sub_C a) _, simp only [aeval_C, aeval_X, alg_hom.map_sub, sub_self] }
rw [←degree_eq_nat_degree (ne_zero (@is_integral_algebra_map A B _ _ _ a)), with_top.coe_one, ←degree_X_sub_C a]
refine min A (algebra_map A B a) (monic_X_sub_C a) _
simp only [aeval_C, aeval_X, alg_hom.map_sub, sub_self]
have hdeg : (minpoly A (algebra_map A B a)).degree = 1
apply (degree_eq_iff_nat_degree_eq (ne_zero (@is_integral_algebra_map A B _ _ _ a))).2
{ apply (degree_eq_iff_nat_degree_eq (ne_zero (@is_integral_algebra_map A B _ _ _ a))).2, apply le_antisymm hdegle (nat_degree_pos (@is_integral_algebra_map A B _ _ _ a)) }
apply le_antisymm hdegle (nat_degree_pos (@is_integral_algebra_map A B _ _ _ a))
have hrw := eq_X_add_C_of_degree_eq_one hdeg
simp only [monic (@is_integral_algebra_map A B _ _ _ a), one_mul, monic.leading_coeff, ring_hom.map_one] at hrw
have h0 : (minpoly A (algebra_map A B a)).coeff 0 = -a
have hroot := aeval A (algebra_map A B a)
{ have hroot := aeval A (algebra_map A B a), rw [hrw, add_comm] at hroot, simp only [aeval_C, aeval_X, aeval_add] at hroot, replace hroot := eq_neg_of_add_eq_zero hroot, rw [←ring_hom.map_neg _ a] at hroot, exact (hf hroot) }
rw [hrw, add_comm] at hroot
simp only [aeval_C, aeval_X, aeval_add] at hroot
replace hroot := eq_neg_of_add_eq_zero hroot
rw [←ring_hom.map_neg _ a] at hroot
exact (hf hroot)
rw hrw
simp only [h0, ring_hom.map_neg, sub_eq_add_neg]
intros
rw [separable_def, derivative_mul]
{ rw [separable_def, derivative_mul], exact ((hf.mul_right h).add_mul_left_right _).mul_left ((h.symm.mul_right hg).mul_add_right_right _) }
exact ((hf.mul_right h).add_mul_left_right _).mul_left ((h.symm.mul_right hg).mul_add_right_right _)
intros
{ rcases hfg with ⟨f', rfl⟩, exact separable.of_mul_left hf }
rcases hfg with ⟨f', rfl⟩
exact separable.of_mul_left hf
intros
rw [angle_comm, angle_self_neg_of_nonzero hx]
intros
let m : P := midpoint ℝ p1 p2
have h1 : p3 -ᵥ p1 = (p3 -ᵥ m) - (p1 -ᵥ m) := (vsub_sub_vsub_cancel_right p3 p1 m).symm
have h2 : p3 -ᵥ p2 = (p3 -ᵥ m) + (p1 -ᵥ m)
rw [left_vsub_midpoint, ← midpoint_vsub_right, vsub_add_vsub_cancel]
{ rw [left_vsub_midpoint, ← midpoint_vsub_right, vsub_add_vsub_cancel] }
rw [dist_eq_norm_vsub V p3 p1, dist_eq_norm_vsub V p3 p2, h1, h2] at h
exact (norm_add_eq_norm_sub_iff_angle_eq_pi_div_two (p3 -ᵥ m) (p1 -ᵥ m)).mp h.symm
intros
rw f.image_eq_inter_preimage_of_subset_support hs
refine continuous_on.preimage_closed_of_closed ((ext_chart_continuous_on_symm _ _).mono f.closed_ball_subset) _ hsc
exact is_closed.inter is_closed_closed_ball I.closed_range
intros
rw [mdifferentiable_within_at, mdifferentiable_within_at, ext_chart_preimage_inter_eq, differentiable_within_at_inter', continuous_within_at_inter' ht]
exact ext_chart_preimage_mem_nhds_within I x ht
intros
simp only [mdifferentiable, differentiable, mdifferentiable_at_iff_differentiable_at]
intros
apply continuous_on.comp (chart_at H x).continuous_on_symm I.continuous_symm.continuous_on
simp [ext_chart_at, local_equiv.trans_target]
intros
split
{ intro h, exact ⟨smooth_fst.comp h, smooth_snd.comp h⟩ }
intro h
exact ⟨smooth_fst.comp h, smooth_snd.comp h⟩
rintro ⟨h_fst, h_snd⟩
{ rintro ⟨h_fst, h_snd⟩, simpa only [prod.mk.eta] using h_fst.prod_mk h_snd, }
simpa only [prod.mk.eta] using h_fst.prod_mk h_snd
intros
rw ←con_gen_of_con (c.map_of_surjective f H h hf)
rw ←con_gen_of_con (c.map_of_surjective f H h hf); refl
refl
intros
ext
ext; refl
refl
intros
rw [mul_comm, mul_mk'_eq_mk'_of_mul]
intros
simp_rw [← is_periodic_pt_mul_iff_pow_eq_one, ← minimal_period_eq_minimal_period_iff, order_of]
intros
refine λ h, exists.elim (hϕ h) (λ g hg, exists_imp_exists (λ k hk, _) (hG g))
rw [←hg, ←ϕ.map_pow, hk, ϕ.map_one]
intros
revert τ
apply cycle_induction_on _ σ
intro
{ intro, simp }
simp
intros σ hσ τ
{ intros σ hσ τ, rw [hσ.cycle_type, hσ.is_cycle_conj.cycle_type, card_support_conj] }
rw [hσ.cycle_type, hσ.is_cycle_conj.cycle_type, card_support_conj]
intros σ τ hd hc hσ hτ π
{ intros σ τ hd hc hσ hτ π, rw [← conj_mul, hd.cycle_type, disjoint.cycle_type, hσ, hτ], intro a, apply (hd (π⁻¹ a)).imp _ _; { intro h, rw [perm.mul_apply, perm.mul_apply, h, apply_inv_self] } }
rw [← conj_mul, hd.cycle_type, disjoint.cycle_type, hσ, hτ]
intro a
apply (hd (π⁻¹ a)).imp _ _; { intro h, rw [perm.mul_apply, perm.mul_apply, h, apply_inv_self] }
apply (hd (π⁻¹ a)).imp _ _
{ intro h, rw [perm.mul_apply, perm.mul_apply, h, apply_inv_self] }
{ intro h, rw [perm.mul_apply, perm.mul_apply, h, apply_inv_self] }
intro h
rw [perm.mul_apply, perm.mul_apply, h, apply_inv_self]
intros
rw [sign_of_cycle_type, h.cycle_type]
refl
intros
induction n with n IH generalizing xs
{ simpa using form_perm_apply_nth_le_zero _ h _ }
simpa using form_perm_apply_nth_le_zero _ h _
rcases xs with (_|⟨x, _|⟨y, l⟩⟩)
{ rcases xs with (_|⟨x, _|⟨y, l⟩⟩), { simp }, { simp }, { specialize IH (y :: l) (nodup_of_nodup_cons h) _, { simpa [nat.succ_lt_succ_iff] using hn }, simp only [swap_apply_eq_iff, coe_mul, form_perm_cons_cons, nth_le], generalize_proofs at IH, rw [IH, swap_apply_of_ne_of_ne, nth_le]; { rintro rfl, simpa [nth_le_mem _ _ _] using h } } }
{ simp }
simp
{ simp }
simp
specialize IH (y :: l) (nodup_of_nodup_cons h) _
{ specialize IH (y :: l) (nodup_of_nodup_cons h) _, { simpa [nat.succ_lt_succ_iff] using hn }, simp only [swap_apply_eq_iff, coe_mul, form_perm_cons_cons, nth_le], generalize_proofs at IH, rw [IH, swap_apply_of_ne_of_ne, nth_le]; { rintro rfl, simpa [nth_le_mem _ _ _] using h } }
{ simpa [nat.succ_lt_succ_iff] using hn }
simpa [nat.succ_lt_succ_iff] using hn
simp only [swap_apply_eq_iff, coe_mul, form_perm_cons_cons, nth_le]
generalize_proofs at IH
rw [IH, swap_apply_of_ne_of_ne, nth_le]; { rintro rfl, simpa [nth_le_mem _ _ _] using h }
rw [IH, swap_apply_of_ne_of_ne, nth_le]
{ rintro rfl, simpa [nth_le_mem _ _ _] using h }
rintro rfl
{ rintro rfl, simpa [nth_le_mem _ _ _] using h }
simpa [nth_le_mem _ _ _] using h
intros
have h : ∀ n : ℕ, (σ * τ) ^ n = 1 ↔ σ ^ n = 1 ∧ τ ^ n = 1 := λ n, by rw [hστ.commute.mul_pow, disjoint.mul_eq_one_iff (hστ.pow_disjoint_pow n n)]
exact nat.dvd_antisymm hστ.commute.order_of_mul_dvd_lcm (nat.lcm_dvd (order_of_dvd_of_pow_eq_one ((h (order_of (σ * τ))).mp (pow_order_of_eq_one (σ * τ))).1) (order_of_dvd_of_pow_eq_one ((h (order_of (σ * τ))).mp (pow_order_of_eq_one (σ * τ))).2))
intros
ext ⟨a, b⟩ : 1
suffices : (a ∈ l ∧ (l.map (λ a, prod_extend_right a (σ a))).prod (a, b) = (a, σ a b)) ∨ (a ∉ l ∧ (l.map (λ a, prod_extend_right a (σ a))).prod (a, b) = (a, b))
obtain ⟨_, prod_eq⟩ := or.resolve_right this (not_and.mpr (λ h _, h (mem_l a)))
{ obtain ⟨_, prod_eq⟩ := or.resolve_right this (not_and.mpr (λ h _, h (mem_l a))), rw [prod_eq, prod_congr_right_apply] }
rw [prod_eq, prod_congr_right_apply]
clear mem_l
induction l with a' l ih
refine or.inr ⟨list.not_mem_nil _, _⟩
{ refine or.inr ⟨list.not_mem_nil _, _⟩, rw [list.map_nil, list.prod_nil, one_apply] }
rw [list.map_nil, list.prod_nil, one_apply]
rw [list.map_cons, list.prod_cons, mul_apply]
rcases ih (list.nodup_cons.mp hl).2 with ⟨mem_l, prod_eq⟩ | ⟨not_mem_l, prod_eq⟩
rcases ih (list.nodup_cons.mp hl).2 with ⟨mem_l, prod_eq⟩ | ⟨not_mem_l, prod_eq⟩; rw prod_eq
rw prod_eq
refine or.inl ⟨list.mem_cons_of_mem _ mem_l, _⟩
{ refine or.inl ⟨list.mem_cons_of_mem _ mem_l, _⟩, rw prod_extend_right_apply_ne _ (λ (h : a = a'), (list.nodup_cons.mp hl).1 (h ▸ mem_l)) }
rw prod_extend_right_apply_ne _ (λ (h : a = a'), (list.nodup_cons.mp hl).1 (h ▸ mem_l))
rw prod_eq
by_cases ha' : a = a'
rw ← ha' at *
{ rw ← ha' at *, refine or.inl ⟨l.mem_cons_self a, _⟩, rw prod_extend_right_apply_eq }
refine or.inl ⟨l.mem_cons_self a, _⟩
rw prod_extend_right_apply_eq
refine or.inr ⟨λ h, not_or ha' not_mem_l ((list.mem_cons_iff _ _ _).mp h), _⟩
{ refine or.inr ⟨λ h, not_or ha' not_mem_l ((list.mem_cons_iff _ _ _).mp h), _⟩, rw prod_extend_right_apply_ne _ ha' }
rw prod_extend_right_apply_ne _ ha'
intros
induction l with hd tl hl
{ simp }
simp
rw [list.prod_cons, list.map_cons, list.foldr_cons]
{ rw [list.prod_cons, list.map_cons, list.foldr_cons], refine (support_mul_le hd tl.prod).trans _, exact sup_le_sup (le_refl _) hl }
refine (support_mul_le hd tl.prod).trans _
exact sup_le_sup (le_refl _) hl
intros
induction k with k IH
{ refl }
refl
rw [pow_succ, IH, a_mul_a]
{ rw [pow_succ, IH, a_mul_a], congr' 1, norm_cast, rw nat.one_add }
congr' 1
norm_cast
rw nat.one_add
intros
simp [eq_bot_iff_forall, mem_closure_singleton]
intros
dsimp [lift_of_right_inverse_aux]
rw [← mul_inv_eq_one, ← g.map_inv, ← g.map_mul, ← g.mem_ker]
apply hg
rw [f.mem_ker, f.map_mul, f.map_inv, mul_inv_eq_one]
simp only [hf _]
intros
convert S.bot_or_nontrivial
rw nontrivial_iff_exists_ne_one
intros
rw [sup_comm, ←set.union_singleton, ←coe_affine_span_singleton k V p2]
change (s ⊔ affine_span k {p2}).direction = _
rw [direction_sup hp1 (mem_affine_span k (set.mem_singleton _)), direction_affine_span]
simp
intros
rw [vector_span_def, vsub_empty, submodule.span_empty]
intros
rw [midpoint_comm, left_vsub_midpoint]
intros
{ ext, simp [mem_span_singleton, eq_comm] }
ext
simp [mem_span_singleton, eq_comm]
intros
apply is_linear_map.mk
intros x y
{ intros x y, simp, cc }
simp
cc
intros x y
{ intros x y, simp [smul_add] }
simp [smul_add]
intros
{ cases x, refl }
cases x
refl
intros
conv_lhs { rw [← bilin_form.to_lin_apply, comp_symm_comp_of_nondegenerate_apply] }
refl
intros
simp only [B.to_matrix'_comp_right, to_matrix'_to_lin']
intros
{ ext x, exact alg_hom.congr_fun (map_id Q₁) x }
ext x
exact alg_hom.congr_fun (map_id Q₁) x
intros
{ dunfold dual_tensor_hom, rw uncurry_apply, refl, }
dunfold dual_tensor_hom
rw uncurry_apply
refl
intros
{ rw [← dim_range_add_dim_ker f], exact self_le_add_right _ _ }
rw [← dim_range_add_dim_ker f]
exact self_le_add_right _ _
intros
{ ext ⟨a', b'⟩, simp [finsupp.single], split_ifs; finish }
ext ⟨a', b'⟩
simp [finsupp.single]
split_ifs
split_ifs; finish
finish
finish
finish
finish
finish
finish
intros
{ erw of_is_compl_left_apply _ w, refl }
erw of_is_compl_left_apply _ w
refl
intros
haveI : finite_dimensional K V := finite_dimensional_of_finrank h
rwa finrank_pos_iff at h
intros
haveI : finite_dimensional K V₂ := f.finite_dimensional
simpa [← finrank_eq_dim] using f.lift_dim_eq
intros
ext x y
dsimp [splitting_of_finsupp_surjective]
congr
rw [sum_single_index, one_smul]
{ exact (s (finsupp.single x 1)).some_spec, }
exact (s (finsupp.single x 1)).some_spec
{ rw zero_smul, }
rw zero_smul
intros
rw [fin.snoc_eq_cons_rotate, linear_independent_equiv, linear_independent_fin_cons]
intros
rw bUnion_eq_Union; exact linear_independent_Union_of_directed (directed_comp.2 $ hs.directed_coe) (by simpa using h)
rw bUnion_eq_Union
exact linear_independent_Union_of_directed (directed_comp.2 $ hs.directed_coe) (by simpa using h)
intros
simp
intros
{ intros i j h, simp [ha h, hb h] }
intros i j h
simp [ha h, hb h]
intros
rw [← matrix.to_lin_alg_equiv_symm, alg_equiv.apply_symm_apply]
intros
ext x
simp only [mem_ker, mem_range]
split
{ rintros ⟨y, rfl⟩, refl }
rintros ⟨y, rfl⟩
refl
{ intro h, exact ⟨x.snd, prod.ext h.symm rfl⟩ }
intro h
exact ⟨x.snd, prod.ext h.symm rfl⟩
intros
rw [range_eq_map, ← prod_top, prod_map_snd]
intros
{ rintros ⟨x⟩, exact ⟨x, rfl⟩ }
rintros ⟨x⟩
exact ⟨x, rfl⟩
intros
rw [std_basis_apply, update_noteq h]; refl
rw [std_basis_apply, update_noteq h]
refl
intros
simp only [exists_prop]; exact iff.trans (exists_congr $ λ x, or_and_distrib_right) exists_or_distrib
simp only [exists_prop]
exact iff.trans (exists_congr $ λ x, or_and_distrib_right) exists_or_distrib
intros
rw [← not_or_distrib, decidable.not_not]
intros
induction h with b h b c _ bc ab
exact refl_trans_gen.single h
exact refl_trans_gen.tail ab bc
intros
simp only [has_finite_integral, lintegral_prod_of_measurable _ h1f.ennnorm]
have : ∀ x, ∀ᵐ y ∂ν, 0 ≤ ∥f (x, y)∥ := λ x, eventually_of_forall (λ y, norm_nonneg _)
simp_rw [integral_eq_lintegral_of_nonneg_ae (this _) (h1f.norm.comp measurable_prod_mk_left).ae_measurable, ennnorm_eq_of_real to_real_nonneg, of_real_norm_eq_coe_nnnorm]
have : ∀ {p q r : Prop} (h1 : r → p), (r ↔ p ∧ q) ↔ (p → (r ↔ q)) := λ p q r h1, by rw [← and.congr_right_iff, and_iff_right_of_imp h1]
rw [this]
intro h2f
{ intro h2f, rw lintegral_congr_ae, refine h2f.mp _, apply eventually_of_forall, intros x hx, dsimp only, rw [of_real_to_real], rw [← lt_top_iff_ne_top], exact hx }
rw lintegral_congr_ae
refine h2f.mp _
apply eventually_of_forall
intros x hx
dsimp only
rw [of_real_to_real]
rw [← lt_top_iff_ne_top]
exact hx
intro h2f
{ intro h2f, refine ae_lt_top _ h2f.ne, exact h1f.ennnorm.lintegral_prod_right' }
refine ae_lt_top _ h2f.ne
exact h1f.ennnorm.lintegral_prod_right'
intros
apply to_signed_measure_injective
simp [to_signed_measure_neg]
intros
rw condexp_L1_eq hfi
refine eventually_eq.trans _ (integrable.coe_fn_to_L1 hfi)
rw condexp_L1_clm_of_ae_measurable'
exact ae_measurable'.congr hfm (integrable.coe_fn_to_L1 hfi).symm
intros
haveI : fact (m ≤ m0) := ⟨hm⟩
{ haveI : fact (m ≤ m0) := ⟨hm⟩, exact inner_orthogonal_projection_left_eq_right _ f g, }
exact inner_orthogonal_projection_left_eq_right _ f g
intros
simp only [has_finite_integral, lintegral_zero_measure, with_top.zero_lt_top]
intros
{ rw ← mem_ℒp_one_iff_integrable at hf ⊢, exact hf.re, }
rw ← mem_ℒp_one_iff_integrable at hf ⊢
exact hf.re
intros
rw [norm_def, norm_def, snorm_congr_ae (coe_fn_neg _), snorm_neg]
intros
simp_rw [snorm_ess_sup, pi.zero_apply, nnnorm_zero, ennreal.coe_zero, ←ennreal.bot_eq_zero]
exact ess_sup_const_bot
intros
refine (eventually_lift'_powerset' $ λ s t hst ht, _).2 h
{ refine (eventually_lift'_powerset' $ λ s t hst ht, _).2 h, exact ht.mono_set hst }
exact ht.mono_set hst
intros
simpa only [integral_of_le hab] using set_integral_mono_ae hf.1 hg.1 h
intros
simpa [mul_comm] using integral_comp_smul_deriv' h h' hg
intros
rw [← integral_comp_add_right, ← integral_comp_mul_left _ hc]
intros
have : {x | x ≤ a₂} ∩ Ioc a₁ a₃ = Ioc a₁ a₂
from Iic_inter_Ioc_of_le h.2
rw [integral_of_le h.1, integral_of_le (h.1.trans h.2), integral_indicator, measure.restrict_restrict, this]
exact measurable_set_Iic
apply measurable_set_Iic
all_goals { apply measurable_set_Iic }
exact measurable_set_Iic
apply measurable_set_Iic
all_goals { apply measurable_set_Iic }
intros
rw [lintegral_congr_ae (ae_eq_of_ae_eq_trim hf.ae_eq_mk), lintegral_congr_ae hf.ae_eq_mk, lintegral_trim hm hf.measurable_mk]
intros
simp only [lintegral, measure.sum_apply, f.measurable_set_preimage, ← finset.tsum_subtype, ← ennreal.tsum_mul_left]
apply ennreal.tsum_comm
intros
{ ext1 s hs, simp [hs] }
ext1 s hs
simp [hs]
intros
simp only [prehaar]
{ simp only [prehaar], rw [div_add_div_same], congr', exact_mod_cast index_union_eq K₁ K₂ hU h }
rw [div_add_div_same]
congr'
exact_mod_cast index_union_eq K₁ K₂ hU h
intros
intros s hs
rw [← outer_measure.coe_mk_metric, coe_smul, ← outer_measure.coe_mk_metric]
exact outer_measure.mk_metric_mono_smul hc h0 hle s
intros
contrapose! H
apply sum_measure_le_measure_univ h
exact λ i hi j hj hij x hx, H i hi j hj hij ⟨x, hx⟩
intros
rw [← encodable.Union_decode₂, ← tsum_Union_decode₂]
exact extend_Union_nat PU (λ n, encodable.Union_decode₂_cases P0 hm) (mU _ (encodable.Union_decode₂_disjoint_on hd))
{ exact extend_Union_nat PU (λ n, encodable.Union_decode₂_cases P0 hm) (mU _ (encodable.Union_decode₂_disjoint_on hd)) }
{ exact extend_empty P0 m0 }
exact extend_empty P0 m0
intros
rw [bounded_by_eq_of_function m_empty, of_function_eq s m_mono m_subadd]
intros
rw of_union h hA₁ hB₁ at hAB
linarith
apply_instance
intros
refine ⟨λ h i, _, λ h i hi, h i⟩
by_cases hi : measurable_set i
{ exact h i hi }
exact h i hi
{ rw [v.not_measurable hi, w.not_measurable hi] }
rw [v.not_measurable hi, w.not_measurable hi]
intros
have h6 : (0:ℚ) < 6
norm_num
norm_num
contrapose! H
rw sum_inv_pqr
simp only [pnat.coe_bit0, nat.cast_bit0, pnat.one_coe, nat.cast_bit1, nat.cast_one, pnat.coe_bit1, coe_coe]
calc (2⁻¹ + 3⁻¹ + r⁻¹ : ℚ) ≤ 2⁻¹ + 3⁻¹ + 6⁻¹ : add_le_add (add_le_add le_rfl le_rfl) _ ... = 1 : by norm_num
rw inv_le_inv _ h6; [assumption_mod_cast, norm_num]
rw inv_le_inv _ h6
assumption_mod_cast
norm_num
intros
induction l; simp *
induction l
simp *
simp *
intros
cases m
{ apply dvd_zero }
apply dvd_zero
{ simp [mem_divisors.1 h], }
simp [mem_divisors.1 h]
intros
dsimp [lucas_lehmer_residue]
rw s_zmod_eq_s_mod p
split
intro h
{ intro h, simp [zmod.int_coe_zmod_eq_zero_iff_dvd] at h, apply int.eq_zero_of_dvd_of_nonneg_of_lt _ _ h; clear h, apply s_mod_nonneg _ (nat.lt_of_succ_lt w), convert s_mod_lt _ (nat.lt_of_succ_lt w) (p-2), push_cast [nat.one_le_two_pow p], refl, }
simp [zmod.int_coe_zmod_eq_zero_iff_dvd] at h
apply int.eq_zero_of_dvd_of_nonneg_of_lt _ _ h; clear h
apply int.eq_zero_of_dvd_of_nonneg_of_lt _ _ h
clear h
apply s_mod_nonneg _ (nat.lt_of_succ_lt w)
clear h
convert s_mod_lt _ (nat.lt_of_succ_lt w) (p-2)
push_cast [nat.one_le_two_pow p]
refl
{ intro h, rw h, simp, }
intro h
rw h
simp
intros
cases i; dsimp [s_mod]
cases i
dsimp [s_mod]
{ exact sup_eq_left.mp rfl }
exact sup_eq_left.mp rfl
dsimp [s_mod]
{ apply int.mod_nonneg, exact mersenne_int_ne_zero p w }
apply int.mod_nonneg
exact mersenne_int_ne_zero p w
intros
rw [norm_p, inv_eq_one_div, div_lt_iff, one_mul]
{ exact_mod_cast hp.1.one_lt }
exact_mod_cast hp.1.one_lt
{ exact_mod_cast hp.1.pos }
exact_mod_cast hp.1.pos
intros
intros ε hε
change _ < _ at hε
use 1
intros j hj
haveI : fact (1 < p^j) := ⟨nat.one_lt_pow _ _ (by linarith) hp_prime.1.one_lt⟩
simp [nth_hom_seq, nth_hom, zmod.val_one, hε]
intros
simp [norm]
intros
rw [norm, norm_sq]; simp
rw [norm, norm_sq]
simp
intros
rintro rfl
{ rintro rfl, apply (hf.reflect_lt h1).not_le, exact nat.le_of_lt_succ (hf.reflect_lt h2) }
apply (hf.reflect_lt h1).not_le
exact nat.le_of_lt_succ (hf.reflect_lt h2)
intros
simp only [not_bdd_above_iff', not_le]
intros
rw set.sUnion_eq_Union; exact complete_lattice.set_independent_Union_of_directed hs.directed_coe (by simpa using h)
rw set.sUnion_eq_Union
exact complete_lattice.set_independent_Union_of_directed hs.directed_coe (by simpa using h)
intros
simp
intros
{ lift s to finset α using hs, exact finset.nonempty.cSup_mem h }
lift s to finset α using hs
exact finset.nonempty.cSup_mem h
intros
refine (symmetric.pairwise_on disjoint.symm _).2 (λ m n h, _)
cases n
{ exact (nat.not_lt_zero _ h).elim }
exact (nat.not_lt_zero _ h).elim
exact disjoint_sdiff_self_right.mono_left ((disjointed_le f m).trans (le_partial_sups_of_le f (nat.lt_add_one_iff.1 h)))
intros
simp [at_top_basis_Ioi.frequently_iff]
intros
casesI (is_empty_or_nonempty β₁).symm
casesI (is_empty_or_nonempty β₂).symm
simp [at_top, prod_infi_left, prod_infi_right, infi_prod]
{ simp [at_top, prod_infi_left, prod_infi_right, infi_prod], exact infi_comm, }
exact infi_comm
simp only [at_top.filter_eq_bot_of_is_empty, prod_bot]
{ simp only [at_top.filter_eq_bot_of_is_empty, prod_bot] }
simp only [at_top.filter_eq_bot_of_is_empty, bot_prod]
{ simp only [at_top.filter_eq_bot_of_is_empty, bot_prod] }
intros
simpa only [and_assoc] using h.restrict_subset hV
intros
simpa only [div_eq_mul_inv] using h.mul h'.inv
intros
rw [map_comap, inf_eq_left.2 (le_principal_iff.2 hf)]
intros
simp only [filter.prod, comap_comap, (∘), inf_comm, prod.fst_swap, eq_self_iff_true, prod.snd_swap, comap_inf]
intros
haveI := I_fin.fintype
refine mem_of_superset (Inter_mem.2 $ λ i, _) hU
exact mem_infi_of_mem i (hV _)
intros
{ rw [← empty_mem_iff_bot, mem_inf_principal], refl }
rw [← empty_mem_iff_bot, mem_inf_principal]
refl
intros
rw [prod_def]; from lift_lift'_same_eq_lift' (assume s, set.monotone_prod monotone_const monotone_id) (assume t, set.monotone_prod monotone_id monotone_const)
rw [prod_def]
from lift_lift'_same_eq_lift' (assume s, set.monotone_prod monotone_const monotone_id) (assume t, set.monotone_prod monotone_id monotone_const)
intros
change ∃ (a : P), ∀ (I : ideal P), a ∈ (I : set P)
rw ← set.nonempty_Inter
exact Inter_nonempty
intros
simpa only [not_lt] using not_congr (h.symm.iterate_pos_lt_iff_map_lt hg hf hn)
intros
simp only [inf_sup_left, λy:α, @inf_comm α _ y x, eq_self_iff_true]
intros
rw liminf_eq
refine Sup_le (λ b hb, _)
have hbx : ∃ᶠ a in f, b ≤ x
revert h
{ revert h, rw [←not_imp_not, not_frequently, not_frequently], exact λ h, hb.mp (h.mono (λ a hbx hba hax, hbx (hba.trans hax))), }
rw [←not_imp_not, not_frequently, not_frequently]
exact λ h, hb.mp (h.mono (λ a hbx hba hax, hbx (hba.trans hax)))
exact hbx.exists.some_spec
intros
intro c
apply eq_of_forall_ge_iff
intro z
suffices : (∀ (f ∈ s) n, (f : _) (c n) ≤ z) ↔ (∀ n (f ∈ s), (f : _) (c n) ≤ z)
simpa [ωSup_le_iff, hs _ _ _] { contextual := tt }
simpa [ωSup_le_iff, hs _ _ _] { contextual := tt }
exact ⟨λ H n f hf, H f hf n, λ H f hf n, H n f hf⟩
intros
ext x
rw [set.mem_range, nat.order_embedding_of_set]
split
split; intro h
intro h
obtain ⟨y, rfl⟩ := h
{ obtain ⟨y, rfl⟩ := h, simp }
simp
intro h
refine ⟨(nat.subtype.order_iso_of_nat s).symm ⟨x, h⟩, _⟩
{ refine ⟨(nat.subtype.order_iso_of_nat s).symm ⟨x, h⟩, _⟩, simp only [rel_embedding.coe_trans, rel_embedding.order_embedding_of_lt_embedding_apply, rel_embedding.nat_lt_apply, function.comp_app, order_embedding.subtype_apply], rw [← subtype.order_iso_of_nat_apply, order_iso.apply_symm_apply, subtype.coe_mk] }
simp only [rel_embedding.coe_trans, rel_embedding.order_embedding_of_lt_embedding_apply, rel_embedding.nat_lt_apply, function.comp_app, order_embedding.subtype_apply]
rw [← subtype.order_iso_of_nat_apply, order_iso.apply_symm_apply, subtype.coe_mk]
intros
intro y
change is_lub (e ⁻¹' {x | f x ≤ y}) (e.symm (g y))
rw [e.is_lub_preimage, e.apply_symm_apply]
exact h y
intros
simp [sdiff_symm_diff]
intros
rw [minpoly_power_basis_gen hf', hf.leading_coeff, inv_one, C.map_one, mul_one]
intros
letI := f.to_algebra
letI := g.to_algebra
letI := (g.comp f).to_algebra
letI : is_scalar_tower A B C := restrict_scalars.is_scalar_tower A B C
letI : algebra.finite_type A C := h
exact algebra.finite_type.of_restrict_scalars_finite_type A B C
intros
{ ext, exact single_zero_mul_coeff }
ext
exact single_zero_mul_coeff
intros
apply le_antisymm
{ rw span_singleton_le_span_singleton, use a}
rw span_singleton_le_span_singleton
use a
rw span_singleton_le_span_singleton
{ rw span_singleton_le_span_singleton, rw is_unit.mul_right_dvd h2}
rw is_unit.mul_right_dvd h2
intros
rcases ideal.exists_le_maximal J hJ with ⟨M, hM1, hM2⟩
rwa ←eq_maximal_ideal hM1
intros
ext
ext; rw [ring_hom.ker, mem_comap, submodule.mem_bot, quotient.eq_zero_iff_mem]
rw [ring_hom.ker, mem_comap, submodule.mem_bot, quotient.eq_zero_iff_mem]
intros
simp only [mul_le, mem_span_singleton_mul, mem_span_singleton]
split
intros h zI hzI
{ intros h zI hzI, exact h x (dvd_refl x) zI hzI }
exact h x (dvd_refl x) zI hzI
rintros h _ ⟨z, rfl⟩ zI hzI
{ rintros h _ ⟨z, rfl⟩ zI hzI, rw [mul_comm x z, mul_assoc], exact J.mul_mem_left _ (h zI hzI) }
rw [mul_comm x z, mul_assoc]
exact J.mul_mem_left _ (h zI hzI)
intros
apply @nat.prime.dvd_of_dvd_pow _ _ k hp
rw ← int.nat_abs_pow
exact int.coe_nat_dvd_left.mp h
intros
{ ext, simp }
ext
simp
intros
rw [← not_iff_not, not_finite_iff_forall, not_and_distrib, ne.def, not_not, not_lt, nat.le_zero_iff]
exact ⟨λ h, or_iff_not_imp_right.2 (λ hb, have ha : a ≠ 0, from λ ha, by simpa [ha] using h 1, by_contradiction (λ ha1 : a ≠ 1, have ha_gt_one : 1 < a, from lt_of_not_ge (λ ha', by { clear h, revert ha ha1, dec_trivial! }), not_lt_of_ge (le_of_dvd (nat.pos_of_ne_zero hb) (h b)) (lt_pow_self ha_gt_one b))), λ h, by cases h; simp *⟩
intros
have h : derivative (T R (n + 2)) = (U R (n + 1) - X * U R n) + X * derivative (T R (n + 1)) + 2 * X * U R n - (1 - X ^ 2) * derivative (U R n)
conv_lhs { rw T_eq_X_mul_T_sub_pol_U }
{ conv_lhs { rw T_eq_X_mul_T_sub_pol_U }, simp only [derivative_sub, derivative_mul, derivative_X, derivative_one, derivative_X_pow, one_mul, T_derivative_eq_U], rw [T_eq_U_sub_X_mul_U, nat.cast_bit0, nat.cast_one], ring }
simp only [derivative_sub, derivative_mul, derivative_X, derivative_one, derivative_X_pow, one_mul, T_derivative_eq_U]
rw [T_eq_U_sub_X_mul_U, nat.cast_bit0, nat.cast_one]
ring
calc ((n : polynomial R) + 1) * T R (n + 1) = ((n : polynomial R) + 1 + 1) * (X * U R n + T R (n + 1)) - X * ((n + 1) * U R n) - (X * U R n + T R (n + 1)) : by ring ... = derivative (T R (n + 2)) - X * derivative (T R (n + 1)) - U R (n + 1) : by rw [←U_eq_X_mul_U_add_T, ←T_derivative_eq_U, ←nat.cast_one, ←nat.cast_add, nat.cast_one, ←T_derivative_eq_U (n + 1)] ... = (U R (n + 1) - X * U R n) + X * derivative (T R (n + 1)) + 2 * X * U R n - (1 - X ^ 2) * derivative (U R n) - X * derivative (T R (n + 1)) - U R (n + 1) : by rw h ... = X * U R n - (1 - X ^ 2) * derivative (U R n) : by ring
intros
by_cases h : n ∈ p.support
{ apply finset.gcd_dvd h }
apply finset.gcd_dvd h
rw [mem_support_iff, not_not] at h
rw h
apply dvd_zero
intros
refine ((eq_cyclotomic_iff hp.pos _).mpr _).symm
simp only [nat.prime.proper_divisors hp, geom_sum_mul, finset.prod_singleton, cyclotomic_one]
intros
symmetry
apply finset.sum_bij (λ (p : ℕ × ℕ) h, (single () p.1, single () p.2))
rintros ⟨i,j⟩ hij
{ rintros ⟨i,j⟩ hij, rw finset.nat.mem_antidiagonal at hij, rw [finsupp.mem_antidiagonal, ← finsupp.single_add, hij], }
rw finset.nat.mem_antidiagonal at hij
rw [finsupp.mem_antidiagonal, ← finsupp.single_add, hij]
{ rintros ⟨i,j⟩ hij, refl }
rintros ⟨i,j⟩ hij
refl
rintros ⟨i,j⟩ ⟨k,l⟩ hij hkl
{ rintros ⟨i,j⟩ ⟨k,l⟩ hij hkl, simpa only [prod.mk.inj_iff, finsupp.unique_single_eq_iff] using id }
simpa only [prod.mk.inj_iff, finsupp.unique_single_eq_iff] using id
rintros ⟨f,g⟩ hfg
{ rintros ⟨f,g⟩ hfg, refine ⟨(f (), g ()), _, _⟩, { rw finsupp.mem_antidiagonal at hfg, rw [finset.nat.mem_antidiagonal, ← finsupp.add_apply, hfg, finsupp.single_eq_same] }, { rw prod.mk.inj_iff, dsimp, exact ⟨finsupp.unique_single f, finsupp.unique_single g⟩ } }
refine ⟨(f (), g ()), _, _⟩
rw finsupp.mem_antidiagonal at hfg
{ rw finsupp.mem_antidiagonal at hfg, rw [finset.nat.mem_antidiagonal, ← finsupp.add_apply, hfg, finsupp.single_eq_same] }
rw [finset.nat.mem_antidiagonal, ← finsupp.add_apply, hfg, finsupp.single_eq_same]
rw prod.mk.inj_iff
{ rw prod.mk.inj_iff, dsimp, exact ⟨finsupp.unique_single f, finsupp.unique_single g⟩ }
dsimp
exact ⟨finsupp.unique_single f, finsupp.unique_single g⟩
intros
{ ext, simp }
ext
simp
intros
apply constant_coeff_witt_structure_int p _ _ n
simp only [neg_zero, ring_hom.map_neg, constant_coeff_X]
intros
apply mv_polynomial.map_injective (int.cast_ring_hom ℚ) int.cast_injective
simp only [map_bind₁, map_rename, map_expand, rename_expand, map_witt_polynomial]
have key := (witt_structure_rat_prop p (map (int.cast_ring_hom ℚ) Φ) n).symm
apply_fun expand p at key
simp only [expand_bind₁] at key
rw key
clear key
apply eval₂_hom_congr' rfl _ rfl
rintro i hi -
rw [witt_polynomial_vars, finset.mem_range] at hi
simp only [IH i hi]
intros
intro x
obtain ⟨x, rfl⟩ := witt_vector.truncate_surjective p _ R x
exact ⟨witt_vector.truncate _ x, truncate_witt_vector_truncate _ _⟩
intros
rw [← not_iff_not, not_nontrivial_iff_subsingleton, ← le_one_iff_subsingleton]
{ rw [← not_iff_not, not_nontrivial_iff_subsingleton, ← le_one_iff_subsingleton], simp }
simp
intros
rw [to_nat_apply_of_lt_omega h, ← classical.some_spec (lt_omega.1 h)]
intros
{ rw [mul_comm], exact le_mul_left h }
rw [mul_comm]
exact le_mul_left h
intros
rw [first_loses_of_equiv_iff (neg_equiv_self G), ←no_good_left_moves_iff_first_loses]
refine ⟨λ h i, _, λ h i, _⟩
simpa [first_wins_of_equiv_iff (neg_equiv_self ((-G).move_left i))] using h (left_moves_neg _ i)
{ simpa [first_wins_of_equiv_iff (neg_equiv_self ((-G).move_left i))] using h (left_moves_neg _ i) }
simpa [first_wins_of_equiv_iff (neg_equiv_self (G.move_right i))] using h ((left_moves_neg _).symm i)
{ simpa [first_wins_of_equiv_iff (neg_equiv_self (G.move_right i))] using h ((left_moves_neg _).symm i) }
intros
rw [←not_lt, typein_lt_typein]
intros
{ cases x, refl }
cases x
refl
split
rintros ⟨ ⟩ ⟨ ⟩
{ rintros ⟨ ⟩ ⟨ ⟩, exact zero_lt_one }
exact zero_lt_one
split
split; rintro ⟨ ⟩
rintro ⟨ ⟩
{ exact numeric_zero }
exact numeric_zero
rintro ⟨ ⟩
{ exact numeric_one }
exact numeric_one
intros
simp [term]
intros
simp
intros
simpa [normalize_fin_lt] using h
intros
split
intro hc
{ intro hc, rw decomp' f, have := hc.sub continuous_const, exact this, }
rw decomp' f
have := hc.sub continuous_const
exact this
intro hc
{ intro hc, rw decomp f, have := hc.add continuous_const, exact this }
rw decomp f
have := hc.add continuous_const
exact this
intros
simp [has_sum, tendsto_const_nhds]
intros
ext
simp [to_ring_inverse (continuous_linear_equiv.refl R M)]
intros
simpa only [mul_comm] using hg.at_top_mul_neg hC hf
intros
simp [frontier, le_of_lt h, Icc_diff_Ioo_same]
intros
refine continuous_at_right_of_monotone_on_of_exists_between h_mono hs (λ b hb, _)
rcases (mem_nhds_within_Ici_iff_exists_mem_Ioc_Ico_subset hb).1 hfs with ⟨b', ⟨hab', hbb'⟩, hb'⟩
rcases exists_between hab' with ⟨c', hc'⟩
rcases mem_closure_iff.1 (hb' ⟨hc'.1.le, hc'.2⟩) (Ioo (f a) b') is_open_Ioo hc' with ⟨_, hc, ⟨c, hcs, rfl⟩⟩
exact ⟨c, hcs, hc.1, hc.2.trans_le hbb'⟩
intros
rw [nhds_eq_comap_uniformity, filter.comap_comap]
refine le_antisymm (filter.map_le_iff_le_comap.1 _) _
assume s hs
{ assume s hs, rcases mem_uniformity_of_uniform_continuous_invariant uniform_continuous_sub hs with ⟨t, ht, hts⟩, refine mem_map.2 (mem_of_superset ht _), rintros ⟨a, b⟩, simpa [subset_def] using hts a b a }
rcases mem_uniformity_of_uniform_continuous_invariant uniform_continuous_sub hs with ⟨t, ht, hts⟩
refine mem_map.2 (mem_of_superset ht _)
rintros ⟨a, b⟩
simpa [subset_def] using hts a b a
assume s hs
{ assume s hs, rcases mem_uniformity_of_uniform_continuous_invariant uniform_continuous_add hs with ⟨t, ht, hts⟩, refine ⟨_, ht, _⟩, rintros ⟨a, b⟩, simpa [subset_def] using hts 0 (b - a) a }
rcases mem_uniformity_of_uniform_continuous_invariant uniform_continuous_add hs with ⟨t, ht, hts⟩
refine ⟨_, ht, _⟩
rintros ⟨a, b⟩
simpa [subset_def] using hts 0 (b - a) a
intros
simp [frontier]
intros
simp_rw [is_open_iff_mem_nhds, ← mem_iff_ultrafilter]
intros
simp [mem_of_superset h]
intros
simp only [continuous_within_at, nhds_within_singleton, tendsto_pure_nhds]
intros
simpa only [mul_comm] using ennreal.tendsto.const_mul hm ha
intros
apply (summable_iff_not_tendsto_nat_at_top_of_nonneg hf).2 (λ H, _)
rcases exists_lt_of_tendsto_at_top H 0 c with ⟨n, -, hn⟩
exact lt_irrefl _ (hn.trans_le (h n))
intros
simp [← has_sum_coe, coe_sum, nnreal.coe_add, ← has_sum_nat_add_iff k]
intros
apply eq_of_local_equiv_eq
rw restr_to_local_equiv
apply local_equiv.restr_eq_of_source_subset
exact interior_maximal h e.open_source
intros
simp only [@nhds_eq_comap_uniformity α, metric.uniformity_eq_comap_nhds_zero, comap_comap, (∘), dist_comm]
intros
rw dist_comm y; apply dist_triangle
rw dist_comm y
apply dist_triangle
intros
simp only [← tendsto_locally_uniformly_on_univ, tendsto_locally_uniformly_on_iff, nhds_within_univ, mem_univ, forall_const, exists_prop]
intros
have A : ∀a ∈ s, ∀b ∈ t, edist a b ≤ diam s + edist x y + diam t := λa ha b hb, calc edist a b ≤ edist a x + edist x y + edist y b : edist_triangle4 _ _ _ _ ... ≤ diam s + edist x y + diam t : add_le_add (add_le_add (edist_le_diam_of_mem ha xs) (le_refl _)) (edist_le_diam_of_mem yt hb)
refine diam_le (λa ha b hb, _)
cases (mem_union _ _ _).1 ha with h'a h'a
cases (mem_union _ _ _).1 ha with h'a h'a; cases (mem_union _ _ _).1 hb with h'b h'b
cases (mem_union _ _ _).1 hb with h'b h'b
calc edist a b ≤ diam s : edist_le_diam_of_mem h'a h'b ... ≤ diam s + (edist x y + diam t) : le_self_add ... = diam s + edist x y + diam t : (add_assoc _ _ _).symm
{ calc edist a b ≤ diam s : edist_le_diam_of_mem h'a h'b ... ≤ diam s + (edist x y + diam t) : le_self_add ... = diam s + edist x y + diam t : (add_assoc _ _ _).symm }
{ exact A a h'a b h'b }
exact A a h'a b h'b
cases (mem_union _ _ _).1 hb with h'b h'b
{ have Z := A b h'b a h'a, rwa [edist_comm] at Z }
have Z := A b h'b a h'a
rwa [edist_comm] at Z
calc edist a b ≤ diam t : edist_le_diam_of_mem h'a h'b ... ≤ (diam s + edist x y) + diam t : le_add_self
{ calc edist a b ≤ diam t : edist_le_diam_of_mem h'a h'b ... ≤ (diam s + edist x y) + diam t : le_add_self }
intros
simp only [inf_edist, infi_image, hΦ.edist_eq]
intros
simp [Hausdorff_dist]
intros
rw [← h.range_eq_univ, h.isometry.ediam_range]
intros
rcases f.locally_finite x with ⟨U, hU, hf⟩
use hf.to_finset
filter_upwards [hU]
intros y hyU
simp only [pi.mul_apply, finset.prod_apply]
apply to_pou_fun_eq_mul_prod
intros j hji hj
exact hf.mem_to_finset.2 ⟨y, ⟨hj, hyU⟩⟩
intros
split
split ; rintros ⟨x, x_in, h⟩ ; use [x, x_in]
split ; rintros ⟨x, x_in, h⟩
rintros ⟨x, x_in, h⟩
use [x, x_in]
ext y
{ ext y, exact ⟨λ hy, hy.mem.2, h⟩ }
exact ⟨λ hy, hy.mem.2, h⟩
rintros ⟨x, x_in, h⟩
use [x, x_in]
intros y y_in
{ intros y y_in, rwa ← h at y_in }
rwa ← h at y_in
intros
refine ⟨λ h, ⟨h.lower_semicontinuous_within_at, h.upper_semicontinuous_within_at⟩, _⟩
rintros ⟨h₁, h₂⟩
assume v hv
simp only [filter.mem_map]
by_cases Hl : ∃ l, l < f x
rcases exists_Ioc_subset_of_mem_nhds hv Hl with ⟨l, lfx, hl⟩
{ rcases exists_Ioc_subset_of_mem_nhds hv Hl with ⟨l, lfx, hl⟩, by_cases Hu : ∃ u, f x < u, { rcases exists_Ico_subset_of_mem_nhds hv Hu with ⟨u, fxu, hu⟩, filter_upwards [h₁ l lfx, h₂ u fxu], assume a lfa fau, cases le_or_gt (f a) (f x) with h h, { exact hl ⟨lfa, h⟩ }, { exact hu ⟨le_of_lt h, fau⟩ } }, { simp only [not_exists, not_lt] at Hu, filter_upwards [h₁ l lfx], assume a lfa, exact hl ⟨lfa, Hu (f a)⟩ } }
by_cases Hu : ∃ u, f x < u
rcases exists_Ico_subset_of_mem_nhds hv Hu with ⟨u, fxu, hu⟩
{ rcases exists_Ico_subset_of_mem_nhds hv Hu with ⟨u, fxu, hu⟩, filter_upwards [h₁ l lfx, h₂ u fxu], assume a lfa fau, cases le_or_gt (f a) (f x) with h h, { exact hl ⟨lfa, h⟩ }, { exact hu ⟨le_of_lt h, fau⟩ } }
filter_upwards [h₁ l lfx, h₂ u fxu]
assume a lfa fau
cases le_or_gt (f a) (f x) with h h
{ exact hl ⟨lfa, h⟩ }
exact hl ⟨lfa, h⟩
{ exact hu ⟨le_of_lt h, fau⟩ }
exact hu ⟨le_of_lt h, fau⟩
simp only [not_exists, not_lt] at Hu
{ simp only [not_exists, not_lt] at Hu, filter_upwards [h₁ l lfx], assume a lfa, exact hl ⟨lfa, Hu (f a)⟩ }
filter_upwards [h₁ l lfx]
assume a lfa
exact hl ⟨lfa, Hu (f a)⟩
simp only [not_exists, not_lt] at Hl
{ simp only [not_exists, not_lt] at Hl, by_cases Hu : ∃ u, f x < u, { rcases exists_Ico_subset_of_mem_nhds hv Hu with ⟨u, fxu, hu⟩, filter_upwards [h₂ u fxu], assume a lfa, apply hu, exact ⟨Hl (f a), lfa⟩ }, { simp only [not_exists, not_lt] at Hu, apply filter.eventually_of_forall, assume a, have : f a = f x := le_antisymm (Hu _) (Hl _), rw this, exact mem_of_mem_nhds hv } }
by_cases Hu : ∃ u, f x < u
rcases exists_Ico_subset_of_mem_nhds hv Hu with ⟨u, fxu, hu⟩
{ rcases exists_Ico_subset_of_mem_nhds hv Hu with ⟨u, fxu, hu⟩, filter_upwards [h₂ u fxu], assume a lfa, apply hu, exact ⟨Hl (f a), lfa⟩ }
filter_upwards [h₂ u fxu]
assume a lfa
apply hu
exact ⟨Hl (f a), lfa⟩
simp only [not_exists, not_lt] at Hu
{ simp only [not_exists, not_lt] at Hu, apply filter.eventually_of_forall, assume a, have : f a = f x := le_antisymm (Hu _) (Hl _), rw this, exact mem_of_mem_nhds hv }
apply filter.eventually_of_forall
assume a
have : f a = f x := le_antisymm (Hu _) (Hl _)
rw this
exact mem_of_mem_nhds hv
intros
rw [compact_covering, Union_accumulate]
exact (classical.some_spec sigma_compact_space.exists_compact_covering).2
intros
split
split; rintros ⟨h₁, h₂⟩; split
split; rintros ⟨h₁, h₂⟩
rintros ⟨h₁, h₂⟩
split
{ exact nonneg_of_mul_nonneg_left h₁ ha }
exact nonneg_of_mul_nonneg_left h₁ ha
{ rwa [le_div_iff ha, mul_comm] }
rwa [le_div_iff ha, mul_comm]
rintros ⟨h₁, h₂⟩
split
{ exact mul_nonneg ha.le h₁ }
exact mul_nonneg ha.le h₁
{ rwa [le_div_iff ha, mul_comm] at h₂ }
rwa [le_div_iff ha, mul_comm] at h₂
intros
rw tail_eq_drop
refl
intros
rw [cons_append_stream, nil_append_stream, stream.eta]
intros
cases b; simp
cases b
simp
simp
intros
have h := int.add_lt_add_left h a
rwa int.add_neg_cancel_left at h
intros
rw [← nat_abs_neg, nat_abs_of_nonneg (int.neg_nonneg_of_nonpos H)]
intros
rw nat.add_comm; exact nat.dvd_add_iff_right h
rw nat.add_comm
exact nat.dvd_add_iff_right h
intros
rw [nat.add_comm k n, nat.add_comm k m, nat.add_sub_add_right]
intros
induction s; refl
induction s
refl
intros
{ ext, refl, }
ext
refl
intros
rw [mul_comm]; exact le_mul_right
rw [mul_comm]
exact le_mul_right
intros
simp
intros
rw [range_succ, prod_insert not_mem_range_self]
intros
rw finprod
split_ifs
exacts [finset.prod_induction _ _ hp₁ hp₀ (λ i hi, hp₂ _), hp₀]
intros
refine finprod_mem_inter_mul_support_eq' _ _ _ (λ x hx, ⟨_, or.inr⟩)
rintro (rfl|hxs)
exacts [not_imp_comm.1 h hx, hxs]
intros
{ ext a, simp }
ext a
simp
intros
rw [show (1 : R) = bit1 0, by simp, bit1_eq_bit1]
intros
rw [of_terminated_at_iff_int_fract_pair_seq1_terminated_at, seq.terminated_at, int_fract_pair.nth_seq1_eq_succ_nth_stream]
intros
simp [convergent_eq_num_div_denom, num_eq_conts_a, denom_eq_conts_b, div_one]
intros
simpa only [← @div_self _ _ b h] using (div_add_div_same a b b).symm
intros
{ ext, simp [ceil_le, le_floor] }
ext
simp [ceil_le, le_floor]
intros
simp [star, has_star.star]
intros
simpa only [div_eq_mul_inv] using λ a a' h, mul_left_injective (b⁻¹) h
intros
unfold semiconj_by; assoc_rw [hb.eq, ha.eq, mul_assoc]
unfold semiconj_by
assoc_rw [hb.eq, ha.eq, mul_assoc]
intros
rw [bit1, pow_succ', pow_bit0']
intros
refine ⟨λ h, _, nsmul_lt_nsmul ha⟩
by_contra H
exact lt_irrefl _ (lt_of_le_of_lt (nsmul_le_nsmul (le_of_lt ha) $ not_lt.mp H) h)
intros
rw [← mul_one a, ← h, mul_zero]
intros
rw [div_eq_mul_inv, inv_div, mul_div_cancel' _ ha]
intros
rcases h : c.next i with _ | ⟨j,w⟩
ext
{ ext, { refl }, { dsimp, simp only [next, h], symmetry, apply zero_of_target_iso_zero, exact X_next_iso_zero _ h } }
{ refl }
refl
dsimp
{ dsimp, simp only [next, h], symmetry, apply zero_of_target_iso_zero, exact X_next_iso_zero _ h }
simp only [next, h]
symmetry
apply zero_of_target_iso_zero
exact X_next_iso_zero _ h
{ ext, refl, dsimp, simp [next, h] }
ext
refl
dsimp
simp [next, h]
intros
cases i
dsimp [d_next]
{ dsimp [d_next], rcases (complex_shape.down ℕ).next 0 with _|⟨j,hj⟩; dsimp [d_next], { rw [C.shape, zero_comp], dsimp, dec_trivial }, { dsimp at hj, exact (nat.succ_ne_zero _ hj).elim } }
rcases (complex_shape.down ℕ).next 0 with _|⟨j,hj⟩; dsimp [d_next]
rcases (complex_shape.down ℕ).next 0 with _|⟨j,hj⟩
dsimp [d_next]
{ rw [C.shape, zero_comp], dsimp, dec_trivial }
rw [C.shape, zero_comp]
dsimp
dec_trivial
dsimp [d_next]
{ dsimp at hj, exact (nat.succ_ne_zero _ hj).elim }
dsimp at hj
exact (nat.succ_ne_zero _ hj).elim
rw d_next_eq
dsimp
refl
intros
conv_rhs { erw [←quotient_map_out f, ←quotient_map_out g, ←(quotient V c).map_comp], }
intros
cases i
{ rw [d_to_eq_zero], simp, }
rw [d_to_eq_zero]
simp
{ rw [d_to_eq ((single₀ V).obj X) rfl], simp, }
rw [d_to_eq ((single₀ V).obj X) rfl]
simp
intros
simp [neg_eq_pos_inv]
intros
rw ← map_le_iff_le_comap
exact le_trans (map_bracket_le f) (lie_submodule.mono_lie _ _ _ _ map_comap_le map_comap_le)
intros
induction k with k ih
simp only [derived_series_def, derived_series_of_ideal_zero, le_top]
{ simp only [derived_series_def, derived_series_of_ideal_zero, le_top], }
simp only [derived_series_def, derived_series_of_ideal_succ] at ih ⊢
{ simp only [derived_series_def, derived_series_of_ideal_succ] at ih ⊢, exact le_trans (map_bracket_le f) (lie_submodule.mono_lie _ _ _ _ ih ih), }
exact le_trans (map_bracket_le f) (lie_submodule.mono_lie _ _ _ _ ih ih)
intros
{ ext, simp }
ext
simp
intros
have h : ∀ (N N' : lie_submodule R L M), (N : set M) ≤ N' ↔ N ≤ N'
intros
{ intros, refl }
refl
apply is_glb.of_image h
simp only [Inf_coe]
exact is_glb_binfi
intros
rw f.ideal_range_eq_map
exact lie_ideal.map_mono le_top
intros
rw mk_sol
{ rw mk_sol, simp only [n.is_lt, dif_pos, fin.mk_coe, fin.eta] }
simp only [n.is_lt, dif_pos, fin.mk_coe, fin.eta]
intros
simp
intros
simpa [sub_eq_add_neg, add_assoc] using abv_add abv (a - b) (b - c)
intros
rw [mul_comm, inv_mul_lt_iff h]
intros
rw [le_div_iff hb, one_mul]
intros
{ rw abs_sub_comm, exact max_sub_min_eq_abs' _ _ }
rw abs_sub_comm
exact max_sub_min_eq_abs' _ _
intros
rw [← mul_le_mul_iff_right c, div_eq_mul_inv, inv_mul_cancel_right]
intros
by_cases a ≤ b; simp [min_def, h]
by_cases a ≤ b
simp [min_def, h]
simp [min_def, h]
intros
haveI := @linear_order.decidable_le α _; exact ⟨λ h', le_of_mul_le_mul_right h' h, λ h', decidable.mul_le_mul_of_nonneg_right h' h.le⟩
haveI := @linear_order.decidable_le α _
exact ⟨λ h', le_of_mul_le_mul_right h' h, λ h', decidable.mul_le_mul_of_nonneg_right h' h.le⟩
intros
simpa only [inv_inv] using h.const_smul a⁻¹
intros
simp only [self_add_conj', two_mul, coe_add]
intros
rw [←i_mul_j, ←mul_assoc, i_mul_i, smul_mul_assoc, one_mul]
intros
rw [← mul_self_eq_mul_self_iff, one_mul]
intros
simp only [neg_eq_neg_one_mul a, neg_eq_neg_one_mul b, rel.mul_right h]
intros
cases α
cases β
dsimp [presheaf.pushforward_obj] at *
tidy
intros
{ rw [const_mul, const_ext], rw mul_assoc }
rw [const_mul, const_ext]
rw mul_assoc
intros
obtain ⟨a, ha, C, hC, hp⟩ : ∃ (a ∈ Ioo (0 : ℝ) 1) (C > 0), (∀ y ∈ metric.ball (0 : E) r', ∀ n, ∥f (x + y) - p.partial_sum n y∥ ≤ C * (a * (∥y∥ / r')) ^ n)
from hf.uniform_geometric_approx' h
refine ⟨a, ha, C, hC, λ y hy n, (hp y hy n).trans _⟩
have yr' : ∥y∥ < r'
rwa ball_zero_eq at hy
rwa ball_zero_eq at hy
refine mul_le_mul_of_nonneg_left (pow_le_pow_of_le_left _ _ _) hC.lt.le
exacts [mul_nonneg ha.1.le (div_nonneg (norm_nonneg y) r'.coe_nonneg), mul_le_of_le_one_right ha.1.le (div_le_one_of_le yr'.le r'.coe_nonneg)]
intros
ext k
by_cases h : k = c.index j
rw h
{ rw h, let r : fin (c.blocks_fun (c.index j)) → fin n := c.embedding (c.index j), simp only [function.update_same], change p (c.blocks_fun (c.index j)) ((function.update v j z) ∘ r) = _, let j' := c.inv_embedding j, suffices B : (function.update v j z) ∘ r = function.update (v ∘ r) j' z, by rw B, suffices C : (function.update v (r j') z) ∘ r = function.update (v ∘ r) j' z, by { convert C, exact (c.embedding_comp_inv j).symm }, exact function.update_comp_eq_of_injective _ (c.embedding _).injective _ _ }
let r : fin (c.blocks_fun (c.index j)) → fin n := c.embedding (c.index j)
simp only [function.update_same]
change p (c.blocks_fun (c.index j)) ((function.update v j z) ∘ r) = _
let j' := c.inv_embedding j
suffices B : (function.update v j z) ∘ r = function.update (v ∘ r) j' z
rw B
rw B
suffices C : (function.update v (r j') z) ∘ r = function.update (v ∘ r) j' z
convert C
convert C
{ convert C, exact (c.embedding_comp_inv j).symm }
{ convert C, exact (c.embedding_comp_inv j).symm }
exact (c.embedding_comp_inv j).symm
exact (c.embedding_comp_inv j).symm
exact function.update_comp_eq_of_injective _ (c.embedding _).injective _ _
simp only [h, function.update_eq_self, function.update_noteq, ne.def, not_false_iff]
{ simp only [h, function.update_eq_self, function.update_noteq, ne.def, not_false_iff], let r : fin (c.blocks_fun k) → fin n := c.embedding k, change p (c.blocks_fun k) ((function.update v j z) ∘ r) = p (c.blocks_fun k) (v ∘ r), suffices B : (function.update v j z) ∘ r = v ∘ r, by rw B, apply function.update_comp_eq_of_not_mem_range, rwa c.mem_range_embedding_iff' }
let r : fin (c.blocks_fun k) → fin n := c.embedding k
change p (c.blocks_fun k) ((function.update v j z) ∘ r) = p (c.blocks_fun k) (v ∘ r)
suffices B : (function.update v j z) ∘ r = v ∘ r
rw B
rw B
apply function.update_comp_eq_of_not_mem_range
rwa c.mem_range_embedding_iff'
intros
simp only [conformal_at_iff', h.fderiv]
intros
simp only [mul_comm u, deriv_mul_const_field]
intros
rw [← has_deriv_within_at_univ] at *
exact hc.smul_const f
intros
apply has_fderiv_within_at.fderiv_within _ hxs
exact has_fderiv_within_at.prod hf₁.has_fderiv_within_at hf₂.has_fderiv_within_at
intros
simp only [sub_eq_add_neg, fderiv_add_const]
intros
rw [← iso.comp_has_fderiv_within_at_iff, ← continuous_linear_map.comp_assoc, iso.coe_comp_coe_symm, continuous_linear_map.id_comp]
intros
apply has_fderiv_within_at.fderiv_within _ hxs
exact h.has_fderiv_at.has_fderiv_within_at
intros
obtain ⟨t, hts, ht, xt⟩ : ∃ t ⊆ s, is_open t ∧ x ∈ t := _root_.mem_nhds_iff.1 hs
have := is_open.mem_nhds ((hf.mono_set hts).open_image f'symm ht hc) (mem_image_of_mem _ xt)
exact mem_of_superset this (image_subset _ hts)
intros
rw [fintype.linear_independent_iff]
push_neg
rcases hextr.exists_multipliers_of_has_strict_fderiv_at hf' hφ' with ⟨Λ, Λ₀, hΛ, hΛf⟩
refine ⟨λ i, option.elim i Λ₀ Λ, _, _⟩
{ simpa [add_comm] using hΛf }
simpa [add_comm] using hΛf
simpa [function.funext_iff, not_and_distrib, or_comm, option.exists] using hΛ
{ simpa [function.funext_iff, not_and_distrib, or_comm, option.exists] using hΛ }
intros
simpa using h.neg.has_fderiv_within_at_eq_zero hf.neg hy hy'
intros
{ rw [unique_diff_within_at_iff, tangent_cone_univ], simp }
rw [unique_diff_within_at_iff, tangent_cone_univ]
simp
intros
rw [← times_cont_diff_on_univ, continuous_iff_continuous_on_univ]
exact times_cont_diff_on_zero
intros
split
intros h
{ intros h, obtain ⟨u, H, p, hp⟩ := h 0 (by norm_num), refine ⟨u, _, _⟩, { simpa [hx] using H }, { simp only [with_top.coe_zero, has_ftaylor_series_up_to_on_zero_iff] at hp, exact hp.1.mono (inter_subset_right s u) } }
obtain ⟨u, H, p, hp⟩ := h 0 (by norm_num)
refine ⟨u, _, _⟩
{ simpa [hx] using H }
simpa [hx] using H
simp only [with_top.coe_zero, has_ftaylor_series_up_to_on_zero_iff] at hp
{ simp only [with_top.coe_zero, has_ftaylor_series_up_to_on_zero_iff] at hp, exact hp.1.mono (inter_subset_right s u) }
exact hp.1.mono (inter_subset_right s u)
rintros ⟨u, H, hu⟩
{ rintros ⟨u, H, hu⟩, rw ← times_cont_diff_within_at_inter' H, have h' : x ∈ s ∩ u := ⟨hx, mem_of_mem_nhds_within hx H⟩, exact (times_cont_diff_on_zero.mpr hu).times_cont_diff_within_at h' }
rw ← times_cont_diff_within_at_inter' H
have h' : x ∈ s ∩ u := ⟨hx, mem_of_mem_nhds_within hx H⟩
exact (times_cont_diff_on_zero.mpr hu).times_cont_diff_within_at h'
intros
simpa [measure_univ] using hg.map_smul_integral_le hgc hsc (is_probability_measure.ne_zero μ) hfs hfi hgi
intros
{ simp [sub_eq_add_neg, inner_add_right] }
simp [sub_eq_add_neg, inner_add_right]
intros
rw [ball_eq_preimage, ← image_subset_iff] at h
rcases exists_pos_lt_subset_ball hR (to_euclidean.is_closed_image.2 hs) h with ⟨r, hr, hsr⟩
exact ⟨r, hr, image_subset_iff.1 hsr⟩
intros
rw [dist_point_reflection_self', ← two_smul' 𝕜 (x -ᵥ y), norm_smul, ← dist_eq_norm_vsub V]
intros
rw [← rat.norm_cast_real, ← int.norm_cast_real]
rw [← rat.norm_cast_real, ← int.norm_cast_real]; congr' 1; norm_cast
rw [← rat.norm_cast_real, ← int.norm_cast_real]; congr' 1
congr' 1
norm_cast
intros
{ rw [tendsto_iff_norm_tendsto_zero], simp only [sub_zero] }
rw [tendsto_iff_norm_tendsto_zero]
simp only [sub_zero]
intros
refine ⟨λ h, _, λ h, λ v, _⟩
refine op_norm_le_bound _ (zero_le_one) (λ v, _)
{ refine op_norm_le_bound _ (zero_le_one) (λ v, _), simpa [one_mul] using h v }
simpa [one_mul] using h v
{ simpa using le_of_op_norm_le f h v }
simpa using le_of_op_norm_le f h v
intros
refine le_of_forall_pos_le_add (λ ε hε, _)
replace hε := half_pos hε
obtain ⟨m, rfl, hm : ∥m∥ < ∥mk' S m∥ + ε / 2⟩ := norm_mk_lt x hε
obtain ⟨n, rfl, hn : ∥n∥ < ∥mk' S n∥ + ε / 2⟩ := norm_mk_lt y hε
calc ∥mk' S m + mk' S n∥ = ∥mk' S (m + n)∥ : by rw (mk' S).map_add ... ≤ ∥m + n∥ : quotient_norm_mk_le S (m + n) ... ≤ ∥m∥ + ∥n∥ : norm_add_le _ _ ... ≤ ∥mk' S m∥ + ∥mk' S n∥ + ε : by linarith
intros
simp only [map_add, add_apply, coe_deriv₂, add_assoc]
intros
rintro a ha x ⟨y, hy, hx⟩
rw [mem_ball_zero, ←hx, p.smul]
calc _ ≤ p y : mul_le_of_le_one_left (p.nonneg _) ha ... < r : by rwa mem_ball_zero at hy
simp [arg, le_refl, not_le.2 (@zero_lt_one ℝ _ _)]
intros
rcases hx.eq_or_lt with (rfl|hx)
{ simp [le_refl, zero_le_one] }
simp [le_refl, zero_le_one]
exact log_nonpos_iff hx
intros
rw integral_deriv_eq_sub' (λ x, -cos x); norm_num [continuous_on_sin]
rw integral_deriv_eq_sub' (λ x, -cos x)
norm_num [continuous_on_sin]
norm_num [continuous_on_sin]
norm_num [continuous_on_sin]
norm_num [continuous_on_sin]
intros
simp [top_rpow_def, asymm h, ne_of_lt h]
intros
nth_rewrite 1 ←ennreal.rpow_one x
exact ennreal.rpow_le_rpow_of_exponent_ge hx h_one_le
intros
simp only [← rpow_neg_one, ← rpow_mul hx, mul_comm]
intros
simp only [cpow_def]
split_ifs; simp [*, exp_ne_zero, log_exp h₁ h₂, mul_assoc] at *
split_ifs
simp [*, exp_ne_zero, log_exp h₁ h₂, mul_assoc] at *
simp [*, exp_ne_zero, log_exp h₁ h₂, mul_assoc] at *
simp [*, exp_ne_zero, log_exp h₁ h₂, mul_assoc] at *
simp [*, exp_ne_zero, log_exp h₁ h₂, mul_assoc] at *
simp [*, exp_ne_zero, log_exp h₁ h₂, mul_assoc] at *
simp [*, exp_ne_zero, log_exp h₁ h₂, mul_assoc] at *
simp [*, exp_ne_zero, log_exp h₁ h₂, mul_assoc] at *
simp [*, exp_ne_zero, log_exp h₁ h₂, mul_assoc] at *
simp [*, exp_ne_zero, log_exp h₁ h₂, mul_assoc] at *
simp [*, exp_ne_zero, log_exp h₁ h₂, mul_assoc] at *
intros
rw [← complex.of_real_ne_zero, complex.of_real_tan, complex.tan_ne_zero_iff]
rw [← complex.of_real_ne_zero, complex.of_real_tan, complex.tan_ne_zero_iff]; norm_cast
norm_cast
rw [← cos_pi_div_two_sub, ← cos_pi_div_three]
congr
ring
intros
refine (monotone_mul_left_of_nonneg hc).seq_le_seq n _ _ h
refine (monotone_mul_left_of_nonneg hc).seq_le_seq n _ _ h; simp [pow_succ, mul_assoc, le_refl]
simp [pow_succ, mul_assoc, le_refl]
simp [pow_succ, mul_assoc, le_refl]
intros
rw [sum_range_succ, dist_eq_norm, ← norm_neg, neg_sub, add_sub_cancel']
exact hf n
intros
rw [sub_def, category.assoc, σ_comp, ←category.assoc, prod.lift_map, sub_def]
intros
ext
dsimp
erw [← adj.hom_equiv_unit, ← equiv.eq_symm_apply, adj.hom_equiv_counit]
simp
intros
{ convert w (𝟙 Y), tidy }
convert w (𝟙 Y)
tidy
intros
haveI : mono (limits.prod.lift (𝟙 A) f ≫ (zero_mul t).hom) := mono_comp _ _
rw [zero_mul_hom, prod.lift_snd] at _inst
haveI: split_epi f := ⟨t.to _, t.hom_ext _ _⟩
apply is_iso_of_mono_of_split_epi
intros
cases f; cases α; ext; refl
cases f; cases α; ext
cases f; cases α
cases f
cases α
ext
refl
intros
tidy
intros
{ dsimp [inv_fun_id_assoc], tidy }
dsimp [inv_fun_id_assoc]
tidy
intros
let sa := max k₁ k₂
let sb := coeq (f₁ ≫ left_to_max _ _) (g₁ ≫ right_to_max _ _)
let sc := coeq (f₂ ≫ left_to_max _ _) (g₂ ≫ right_to_max _ _)
let sd := max sb sc
let s := coeq ((coeq_hom _ _ : sa ⟶ sb) ≫ left_to_max _ _) ((coeq_hom _ _ : sa ⟶ sc) ≫ right_to_max _ _)
use s
fsplit
exact left_to_max k₁ k₂ ≫ coeq_hom _ _ ≫ left_to_max sb sc ≫ coeq_hom _ _
fsplit
exact right_to_max k₁ k₂ ≫ coeq_hom _ _ ≫ right_to_max sb sc ≫ coeq_hom _ _
fsplit
slice_lhs 1 3 { rw [←category.assoc, coeq_condition], }
{ slice_lhs 1 3 { rw [←category.assoc, coeq_condition], }, slice_lhs 3 5 { rw [←category.assoc, coeq_condition], }, simp only [category.assoc], }
slice_lhs 3 5 { rw [←category.assoc, coeq_condition], }
simp only [category.assoc]
slice_lhs 3 5 { rw [←category.assoc, coeq_condition], }
{ slice_lhs 3 5 { rw [←category.assoc, coeq_condition], }, slice_lhs 1 3 { rw [←category.assoc, coeq_condition], }, simp only [category.assoc], }
slice_lhs 1 3 { rw [←category.assoc, coeq_condition], }
simp only [category.assoc]
intros
simp only [has_limit.iso_of_equivalence, is_limit.cone_points_iso_of_equivalence_hom]
dsimp
simp
intros
ext1
ext1; simp [← category.assoc]
simp [← category.assoc]
intros
{ ext, simp [biproduct.matrix], }
ext
simp [biproduct.matrix]
intros
rw [←s.w left, parallel_pair_map_left]
intros
induction w₁
unfreezingI { induction w₁, induction w₂, }
{ unfreezingI { induction w₁, induction w₂, }, ext, simp [kernel_iso_of_eq], }
induction w₂
ext
simp [kernel_iso_of_eq]
intros
tidy
intros
apply eq_desc_of_comp_eq
tidy
intros
rw zero_of_source_iso_zero f i
exact (is_iso_zero_equiv_iso_zero _ _).inv_fun ⟨i, j⟩
intros
rw [←tensor_id_comp_id_tensor, category.assoc, M.mul_one, right_unitor_naturality]
intros
{ rw [←tensor_id, associator_naturality], }
rw [←tensor_id, associator_naturality]
intros
ext Y f hf
exact extend_agrees t hf
intros
{ ext, simp, }
ext
simp
intros
simp [image_subobject_comp_iso]
intros
conv_rhs { rw [← c.blocks_sum, ← of_fn_blocks_fun, sum_of_fn] }
intros
obtain (h|h) := h.zero_or_one i j; simp [h]
{ obtain (h|h) := h.zero_or_one i j; simp [h] }
obtain (h|h) := h.zero_or_one i j
simp [h]
simp [h]
intros
classical
apply finset.card_lt_card
rw finset.ssubset_iff
exact ⟨v, by simp, finset.subset_univ _⟩
intros
change list.foldl M.to_NFA.step_set {start} s = {list.foldl M.step start s}
induction s with a s ih generalizing start
{ tauto }
tauto
rw [list.foldl, list.foldl]
{ rw [list.foldl, list.foldl], have h : M.to_NFA.step_set {start} a = {M.step start a}, { rw NFA.step_set, finish }, rw h, tauto }
have h : M.to_NFA.step_set {start} a = {M.step start a}
rw NFA.step_set
{ rw NFA.step_set, finish }
finish
rw h
tauto
intros
simp [flip] with functor_norm
intros
cases x
cases x; refl
refl
intros
cases x; refl
cases x
refl
refl
intros
cases i; apply to_list_nth_le
cases i
apply to_list_nth_le
intros
cases b; simp only [of_nat,to_nat]; exact dec_trivial
cases b; simp only [of_nat,to_nat]
cases b
simp only [of_nat,to_nat]
exact dec_trivial
simp only [of_nat,to_nat]
exact dec_trivial
intros
induction l with hd tl hl
{ simp }
simp
apply ext
{ apply ext, simp [hl] }
simp [hl]
intros
constructor
intros cb n hn
haveI : (parser.foldr_core f p b (cb.size - n + 1)).bounded := foldr_core he
obtain ⟨np, errp, hp⟩ := bounded.exists (parser.foldr_core f p b (cb.size - n + 1)) hn
simp [foldr, hp]
intros
simp [decorate_errors, h]
intros
simp [foldr, foldr_core_eq_done]
intros
simp [norm_sq]
intros
rw ← of_real_inj; simp [sinh_sq]
rw ← of_real_inj
simp [sinh_sq]
intros
rw [← of_real_exp]; exact abs_of_nonneg (le_of_lt (real.exp_pos _))
rw [← of_real_exp]
exact abs_of_nonneg (le_of_lt (real.exp_pos _))
intros
rw [← of_real_sinh_of_real_re, of_real_im]
intros
convert sin_add_mul_I z.re z.im; exact (re_add_im z).symm
convert sin_add_mul_I z.re z.im
exact (re_add_im z).symm
intros
rw [exp_eq_exp_re_mul_sin_add_cos]
{ rw [exp_eq_exp_re_mul_sin_add_cos], simp [exp_of_real_re, cos_of_real_re] }
simp [exp_of_real_re, cos_of_real_re]
intros
rw [←of_real_one, of_real_re]
simp [← finrank_eq_dim, finrank_real_complex, bit0]
intros
classical
exact finset.induction_on s (by simp [prod_zero_index]) (by simp [prod_add_index, h_zero, h_add] {contextual := tt})
intros
{ cases h, refl }
cases h
refl
intros
simp [map_range_def]
intros
{ ext x, simp [(equiv.set.congr f).symm.exists_congr_left] }
ext x
simp [(equiv.set.congr f).symm.exists_congr_left]
intros
rintro i j ij x ⟨h₁, h₂⟩
revert h₁ h₂
simp
intros b₁ e₁ h₁ b₂ e₂ h₂
refine hd _ _ _ ⟨h₁, h₂⟩
cases encodable.mem_decode₂.1 e₁
cases encodable.mem_decode₂.1 e₂
exact mt (congr_arg _) ij
intros
simp [equiv.perm.via_fintype_embedding]
intros
rw [← e.image_source_inter_eq', inter_eq_self_of_subset_right h]
intros
refl
intros
simpa using congr_arg mk h
intros
{ cases a, refl }
cases a
refl
intros
simp [funext_iff, forall_iff_succ_above i, eq_comm]
intros
rw [fin.coe_add, nat.add_mod_eq_ite, nat.mod_eq_of_lt (show ↑a < n, from a.2), nat.mod_eq_of_lt (show ↑b < n, from b.2)]
intros
congr
intros
rw one_lt_card
{ rw one_lt_card, simp only [exists_prop, exists_and_distrib_left] }
simp only [exists_prop, exists_and_distrib_left]
intros
classical
rw [← insert_emptyc_eq, bUnion_insert, bUnion_empty, union_empty]
intros
apply le_antisymm
{ apply sup'_le, intros, apply le_refl, }
apply sup'_le
intros
apply le_refl
{ apply le_sup' (λ b, a) H.some_spec, }
apply le_sup' (λ b, a) H.some_spec
intros
simp only [noncomm_foldr, coe_foldr, coe_attach, list.attach]
rw ←list.foldr_map
simp [list.map_pmap, list.pmap_eq_map]
intros
simp [← finsupp.support_eq_empty, finset.eq_empty_iff_forall_not_mem]
intros
ext
{ ext, simp [finsupp.single_eq_pi_single, finsupp.equiv_fun_on_fintype], }
simp [finsupp.single_eq_pi_single, finsupp.equiv_fun_on_fintype]
intros
{ ext m, simp }
ext m
simp
intros
simp [bijective, injective_iff_surjective]
intros
have nd := v.nodup (mk_idx n (hash_fn a))
rcases hash_map.valid.erase_aux a (array.read bkts (mk_idx n (hash_fn a))) ((contains_aux_iff nd).1 Hc) with ⟨u, w, b, hl, hfl⟩
refine (v.modify hash_fn u [⟨a, b⟩] [] w hl hfl list.nodup_nil _ _ _).2
refine (v.modify hash_fn u [⟨a, b⟩] [] w hl hfl list.nodup_nil _ _ _).2; simp
simp
simp
simp
intros
letI := classical.dec_pred (λ (n : ℕ), cprank_max n x); exact nat.find_min' ⟨ds.prod, show (λ n, cprank_max n x) ds.prod, from cprank_max_upper_bound x⟩ (cprank_max_upper_bound x)
letI := classical.dec_pred (λ (n : ℕ), cprank_max n x)
exact nat.find_min' ⟨ds.prod, show (λ n, cprank_max n x) ds.prod, from cprank_max_upper_bound x⟩ (cprank_max_upper_bound x)
intros
rw [← shiftl_neg, neg_neg]
intros
rw [mul_comm, int.eq_mul_of_div_eq_right H1 H2]
intros
simp [abs_eq_max_neg]
intros
rw [int.lcm, int.lcm, int.lcm, int.lcm, nat_abs_of_nat, nat_abs_of_nat]
{ rw [int.lcm, int.lcm, int.lcm, int.lcm, nat_abs_of_nat, nat_abs_of_nat], apply nat.lcm_assoc }
apply nat.lcm_assoc
intros
rcases greatest_of_bdd b Hb Hinh with ⟨n, hn, h2n⟩
rcases greatest_of_bdd b' Hb' Hinh with ⟨n', hn', h2n'⟩
exact le_antisymm (h2n' _ hn) (h2n _ hn')
intros
simp [even_add]
intros
rw [modify_nth_tail_modify_nth_tail_le n n l (le_refl n), nat.sub_self]
rw [modify_nth_tail_modify_nth_tail_le n n l (le_refl n), nat.sub_self]; refl
refl
intros
rw ← h; apply drop_left
rw ← h
apply drop_left
intros
{ revert a, induction l; intros; [refl, simp only [*, foldr]] }
revert a
induction l
induction l; intros; [refl, simp only [*, foldr]]
induction l; intros
intros
refl
intros
simp only [*, foldr]
intros
rw [← head_add_tail_sum L, add_comm, nat.add_sub_cancel]
intros
induction l; [refl, simp only [*, pmap, length]]
induction l
refl
simp only [*, pmap, length]
intros
cases x; refl
cases x
refl
refl
intros
simp only [count, countp_filter]; congr; exact set.ext (λ b, and_iff_left_of_imp (λ e, e ▸ h))
simp only [count, countp_filter]; congr
simp only [count, countp_filter]
congr
exact set.ext (λ b, and_iff_left_of_imp (λ e, e ▸ h))
intros
rw [erase_eq_erasep, erase_eq_erasep, erasep_map]
rw [erase_eq_erasep, erase_eq_erasep, erasep_map]; congr; ext b; simp [finj.eq_iff]
rw [erase_eq_erasep, erase_eq_erasep, erasep_map]; congr; ext b
rw [erase_eq_erasep, erase_eq_erasep, erasep_map]; congr
congr
ext b
simp [finj.eq_iff]
intros
induction n generalizing xs
{ simp [slice] }
simp [slice]
cases xs; simp [slice, *, nat.succ_add]
{ cases xs; simp [slice, *, nat.succ_add], }
cases xs
simp [slice, *, nat.succ_add]
simp [slice, *, nat.succ_add]
intros
induction m with k IH
{ simp }
simp
{ simpa only [repeat_succ, last] }
simpa only [repeat_succ, last]
intros
cases xs with z zs
{ refl }
refl
{ exact if_neg h }
exact if_neg h
intros
simp
simp; intros; refl
simp; intros
intros
induction l with hd tl ihl
simp
{ simp }
rw [nodup_cons] at hl
simp only [mem_cons_iff, map, ihl hl.2]
by_cases H : hd = x
subst hd
{ subst hd, simp [update_nth, hl.1] }
simp [update_nth, hl.1]
simp [ne.symm H, H, update_nth, ← apply_ite (cons (f hd))]
{ simp [ne.symm H, H, update_nth, ← apply_ite (cons (f hd))] }
intros
classical
refine pairwise_of_reflexive_on_dupl_of_forall_ne _ h
exact λ _ _, hr _
intros
refine ⟨λ h, _, nodup_permutations'_aux_of_not_mem _ _⟩
intro H
obtain ⟨k, hk, hk'⟩ := nth_le_of_mem H
rw nodup_iff_nth_le_inj at h
suffices : k = k + 1
{ simpa using this }
simpa using this
refine h k (k + 1) _ _ _
{ simpa [nat.lt_succ_iff] using hk.le }
simpa [nat.lt_succ_iff] using hk.le
{ simpa using hk }
simpa using hk
rw [nth_le_permutations'_aux, nth_le_permutations'_aux]
have hl : length (insert_nth k x s) = length (insert_nth (k + 1) x s)
rw [length_insert_nth _ _ hk.le, length_insert_nth _ _ (nat.succ_le_of_lt hk)]
{ rw [length_insert_nth _ _ hk.le, length_insert_nth _ _ (nat.succ_le_of_lt hk)] }
refine ext_le hl (λ n hn hn', _)
rcases lt_trichotomy n k with H|rfl|H
rw [nth_le_insert_nth_of_lt _ _ _ _ H (H.trans hk), nth_le_insert_nth_of_lt _ _ _ _ (H.trans (nat.lt_succ_self _))]
{ rw [nth_le_insert_nth_of_lt _ _ _ _ H (H.trans hk), nth_le_insert_nth_of_lt _ _ _ _ (H.trans (nat.lt_succ_self _))] }
rw [nth_le_insert_nth_self _ _ _ hk.le, nth_le_insert_nth_of_lt _ _ _ _ (nat.lt_succ_self _) hk, hk']
{ rw [nth_le_insert_nth_self _ _ _ hk.le, nth_le_insert_nth_of_lt _ _ _ _ (nat.lt_succ_self _) hk, hk'] }
rcases (nat.succ_le_of_lt H).eq_or_lt with rfl|H'
{ rcases (nat.succ_le_of_lt H).eq_or_lt with rfl|H', { rw [nth_le_insert_nth_self _ _ _ (nat.succ_le_of_lt hk)], convert hk' using 1, convert nth_le_insert_nth_add_succ _ _ _ 0 _, simpa using hk }, { obtain ⟨m, rfl⟩ := nat.exists_eq_add_of_lt H', rw [length_insert_nth _ _ hk.le, nat.succ_lt_succ_iff, nat.succ_add] at hn, rw nth_le_insert_nth_add_succ, convert nth_le_insert_nth_add_succ s x k m.succ _ using 2, { simp [nat.add_succ, nat.succ_add] }, { simp [add_left_comm, add_comm] }, { simpa [nat.add_succ] using hn }, { simpa [nat.succ_add] using hn } } }
rw [nth_le_insert_nth_self _ _ _ (nat.succ_le_of_lt hk)]
{ rw [nth_le_insert_nth_self _ _ _ (nat.succ_le_of_lt hk)], convert hk' using 1, convert nth_le_insert_nth_add_succ _ _ _ 0 _, simpa using hk }
convert hk' using 1
convert nth_le_insert_nth_add_succ _ _ _ 0 _
simpa using hk
obtain ⟨m, rfl⟩ := nat.exists_eq_add_of_lt H'
{ obtain ⟨m, rfl⟩ := nat.exists_eq_add_of_lt H', rw [length_insert_nth _ _ hk.le, nat.succ_lt_succ_iff, nat.succ_add] at hn, rw nth_le_insert_nth_add_succ, convert nth_le_insert_nth_add_succ s x k m.succ _ using 2, { simp [nat.add_succ, nat.succ_add] }, { simp [add_left_comm, add_comm] }, { simpa [nat.add_succ] using hn }, { simpa [nat.succ_add] using hn } }
rw [length_insert_nth _ _ hk.le, nat.succ_lt_succ_iff, nat.succ_add] at hn
rw nth_le_insert_nth_add_succ
convert nth_le_insert_nth_add_succ s x k m.succ _ using 2
{ simp [nat.add_succ, nat.succ_add] }
simp [nat.add_succ, nat.succ_add]
{ simp [add_left_comm, add_comm] }
simp [add_left_comm, add_comm]
{ simpa [nat.add_succ] using hn }
simpa [nat.add_succ] using hn
{ simpa [nat.succ_add] using hn }
simpa [nat.succ_add] using hn
intros
by_cases h : a = b
subst b
{ subst b, rw [erase_cons_head], apply subperm_cons_erase }
rw [erase_cons_head]
apply subperm_cons_erase
{ rw [erase_cons_tail _ h] }
rw [erase_cons_tail _ h]
intros
simp only [range_eq_range', nodup_range']
intros
rw [rotate_eq_rotate', length_rotate']
intros
cases l
cases l; refl
refl
refl
intros
simp only [kinsert, lookup_cons_eq]
intros
cases eq_or_lt_of_le hab with H H
{ subst H, exact refl _ }
subst H
exact refl _
{ exact h.rel_nth_le_of_lt _ _ H }
exact h.rel_nth_le_of_lt _ _ H
intros
rw [←option.some_inj, ←nth_le_nth, nth_zip_with_eq_some]
refine ⟨l.nth_le i (lt_length_left_of_zip_with h), l'.nth_le i (lt_length_right_of_zip_with h), nth_le_nth _, _⟩
simp only [←nth_le_nth, eq_self_iff_true, and_self]
intros
ext
ext; refl
refl
intros
ext
{ext, refl}
refl
intros
simp [dot_product]
intros
{ ext, apply smul_dot_product }
ext
apply smul_dot_product
intros
ext
norm_num [std_basis_matrix, vec_mul_vec]
split_ifs; tauto
split_ifs
tauto
tauto
tauto
tauto
tauto
tauto
intros
ext
{ ext, simp only [block_diagonal'_apply, pi.smul_apply], split_ifs; simp }
simp only [block_diagonal'_apply, pi.smul_apply]
split_ifs
split_ifs; simp
simp
simp
intros
simp
intros
dsimp [to_matrix, matrix.mul_apply]
cases h : f.symm j with fj
{ simp [h, ← f.eq_some_iff] }
simp [h, ← f.eq_some_iff]
rw finset.sum_eq_single fj
{ rw finset.sum_eq_single fj, { simp [h, ← f.eq_some_iff], }, { intros b H n, simp [h, ← f.eq_some_iff, n.symm], }, { simp, } }
{ simp [h, ← f.eq_some_iff], }
simp [h, ← f.eq_some_iff]
{ intros b H n, simp [h, ← f.eq_some_iff, n.symm], }
intros b H n
simp [h, ← f.eq_some_iff, n.symm]
{ simp, }
simp
intros
induction h
simp
case rel.zero { simp }
case rel.cons : a b s t hab hst ih { simpa using hab.add ih }
intros
{ simp_rw [singleton_eq_cons], exact cons_inj_left _ }
simp_rw [singleton_eq_cons]
exact cons_inj_left _
intros
refine ring_hom.ext (λ x, _)
rw ring_hom.comp_apply
refine (mv_polynomial.fin_succ_equiv R n).injective (trans ((mv_polynomial.fin_succ_equiv R n).apply_symm_apply _) _)
simp only [mv_polynomial.fin_succ_equiv_apply, mv_polynomial.eval₂_hom_C]
intros
{ ext1, apply aeval_bind₁ }
ext1
apply aeval_bind₁
intros
ext1
simp [supported_equiv_mv_polynomial, mv_polynomial.algebra_map_eq]
intros
simp [vars, degrees_map_of_injective _ hf]
intros
rcases nat.eq_zero_or_pos b with rfl|hb
simp
{ simp }
rcases nat.eq_zero_or_pos c with rfl|hc
simp
{ simp }
conv_rhs { rw ← mod_add_div a (b * c) }
rw [mul_assoc, nat.add_mul_div_left _ _ hb, add_mul_mod_self_left, mod_eq_of_lt (nat.div_lt_of_lt_mul (mod_lt _ (mul_pos hb hc)))]
intros
rw [← cast_one, cast_lt, lt_succ_iff, le_zero_iff]
intros
cases b
{ cases w₂ }
cases w₂
cases b
{ cases b, { interval_cases x, }, { cases x, { cases w₁, }, { rw [digits_add_two_add_one, nat.div_eq_of_lt w₂, digits_zero, nat.mod_eq_of_lt w₂] } } }
{ interval_cases x, }
interval_cases x
cases x
{ cases x, { cases w₁, }, { rw [digits_add_two_add_one, nat.div_eq_of_lt w₂, digits_zero, nat.mod_eq_of_lt w₂] } }
{ cases w₁, }
cases w₁
{ rw [digits_add_two_add_one, nat.div_eq_of_lt w₂, digits_zero, nat.mod_eq_of_lt w₂] }
rw [digits_add_two_add_one, nat.div_eq_of_lt w₂, digits_zero, nat.mod_eq_of_lt w₂]
intros
rw [← some_eq_coe]
show (∃ (h : true → x.dom), _) ↔ ∃ h : x.dom, x.get h ≤ n
simp only [forall_prop_of_true, some_eq_coe, dom_coe, get_coe']
intros
delta lcm; rw [zero_mul, nat.zero_div]
delta lcm
rw [zero_mul, nat.zero_div]
intros
rwa [←succ_le_iff, ←pow_le_iff_le_log hb (hb.le.trans hn), pow_one]
{ rwa [←succ_le_iff, ←pow_le_iff_le_log hb (hb.le.trans hn), pow_one] }
intros
rw [modeq_iff_dvd, ←int.coe_nat_dvd, int.coe_nat_sub h]
intros
cases mod_two_eq_zero_or_one m with h₁ h₁; cases mod_two_eq_zero_or_one n with h₂ h₂; simp [even_iff, h₁, h₂, nat.add_mod]; norm_num
cases mod_two_eq_zero_or_one m with h₁ h₁; cases mod_two_eq_zero_or_one n with h₂ h₂; simp [even_iff, h₁, h₂, nat.add_mod]
cases mod_two_eq_zero_or_one m with h₁ h₁; cases mod_two_eq_zero_or_one n with h₂ h₂
cases mod_two_eq_zero_or_one m with h₁ h₁
cases mod_two_eq_zero_or_one n with h₂ h₂
simp [even_iff, h₁, h₂, nat.add_mod]
simp [even_iff, h₁, h₂, nat.add_mod]
cases mod_two_eq_zero_or_one n with h₂ h₂
simp [even_iff, h₁, h₂, nat.add_mod]
simp [even_iff, h₁, h₂, nat.add_mod]
norm_num
intros
cases n
cases n; refl
refl
refl
refl
intros
cases x; simp
cases x
simp
simp
intros
cases x; refl
cases x
refl
refl
intros
rw insert_eq_insert_with; exact insert_with.valid _ _ (λ _ _, ⟨le_refl _, le_refl _⟩) h
rw insert_eq_insert_with
exact insert_with.valid _ _ (λ _ _, ⟨le_refl _, le_refl _⟩) h
intros
rw [size_dual, size_dual]
exact H.symm.imp (Exists.imp $ λ _, and.imp_right balanced_sz.symm) (Exists.imp $ λ _, and.imp_right balanced_sz.symm)
intros
cases x with a f
apply @Wp_ind n P α (λ a f, C ⟨a, f⟩)
dsimp
intros a f f' ih'
dsimp [W_mk] at ih
let ih'' := ih a (P.W_path_dest_left f') (λ i, ⟨f i, P.W_path_dest_right f' i⟩)
dsimp at ih''
rw W_path_cases_on_eta at ih''
apply ih''
apply ih'
intros
revert h
generalize h : (M.mk ⟨a,f⟩) = x
intros h'
cases h'
subst x
cases mk_inj ‹_›
refl
intros
unfold_coes
dsimp [of_nat_multiset, to_nat_multiset]
have : (λ (p : ℕ) (h : p.prime), ((⟨p, h⟩ : nat.primes) : ℕ)) = (λ p h, id p) := by {funext p h, refl}
rw [multiset.map_pmap, this, multiset.pmap_eq_map, multiset.map_id]
intros
dsimp [is_special, step] at hs ⊢
rw [mul_add, mul_comm u.y u.x, ← hs]
ring
intros
rw [X_mul, monomial_mul_X]
intros
fsplit
intro h
{ intro h, apply_fun (λ p, p.coeff 0) at h, simpa using h, }
apply_fun (λ p, p.coeff 0) at h
simpa using h
{ rintro rfl, refl, }
rintro rfl
refl
intros
{ haveI := nontrivial.of_polynomial_ne hne, exact hp.ne_zero }
haveI := nontrivial.of_polynomial_ne hne
exact hp.ne_zero
intros
rw ← degree_neg q at h
{ rw ← degree_neg q at h, rw [sub_eq_add_neg, degree_add_eq_right_of_degree_lt h, degree_neg] }
rw [sub_eq_add_neg, degree_add_eq_right_of_degree_lt h, degree_neg]
intros
rw [nat_trailing_degree, trailing_degree_monomial ha]
rw [nat_trailing_degree, trailing_degree_monomial ha]; refl
refl
intros
apply polynomial.induction_on' p
{ intros p₁ p₂ h₁ h₂, simp [h₁, h₂, mul_add], }
intros p₁ p₂ h₁ h₂
simp [h₁, h₂, mul_add]
intros n r
{ intros n r, simp only [derivative_pow, derivative_mul, monomial_comp, derivative_monomial, derivative_C, zero_mul, C_eq_nat_cast, zero_add, ring_hom.map_mul], rw [mul_comm (derivative q)], simp only [mul_assoc], }
simp only [derivative_pow, derivative_mul, monomial_comp, derivative_monomial, derivative_C, zero_mul, C_eq_nat_cast, zero_add, ring_hom.map_mul]
rw [mul_comm (derivative q)]
simp only [mul_assoc]
intros
rw [ne.def, ← card_support_eq_zero, erase_lead_support]
exact (zero_lt_one.trans_le $ (nat.sub_le_sub_right f0 1).trans finset.pred_card_le_card_erase).ne.symm
intros
rw [← C_0, C_comp]
intros
rw [monic, leading_coeff_map, ← f.map_one, function.injective.eq_iff f.injective, monic]
intros
rw [monic, leading_coeff_mul, leading_coeff_C, mul_inv_cancel (show leading_coeff p ≠ 0, from mt leading_coeff_eq_zero.1 h)]
intros
rw mem_lifts_iff_mem_alg at hp ⊢
{ rw mem_lifts_iff_mem_alg at hp ⊢, exact subalgebra.smul_mem (map_alg R S).range hp r }
exact subalgebra.smul_mem (map_alg R S).range hp r
intros
revert ht
refine t.induction_on _ _
simp
{ simp }
intros a t ih ht
rw [multiset.map_cons, multiset.prod_cons]
exact monic_mul (ht _ (multiset.mem_cons_self _ _)) (ih (λ _ hi, ht _ (multiset.mem_cons_of_mem hi)))
intros
rw [nth_roots_finset, mem_to_finset, mem_nth_roots h]
intros
cases x; reflexivity
cases x
reflexivity
intros
refine iff.trans _ quotient.eq
rw quotient.out_eq y
intros
rw [rat.inv_def', rat.coe_int_num, rat.coe_int_denom, nat.cast_one, ←int.cast_one]
apply num_div_eq_of_coprime ha0
rw int.nat_abs_one
exact nat.coprime_one_left _
intros
rw le_iff_forall_pos_lt_add
refine ⟨λ H ε ε_neg, _, λ H ε ε_pos, _⟩
exact exists_lt_of_lt_cSup h' (lt_sub_iff_add_lt.mp (H _ (neg_pos.mpr ε_neg)))
{ exact exists_lt_of_lt_cSup h' (lt_sub_iff_add_lt.mp (H _ (neg_pos.mpr ε_neg))) }
rcases H _ (neg_lt_zero.mpr ε_pos) with ⟨x, x_in, hx⟩
{ rcases H _ (neg_lt_zero.mpr ε_pos) with ⟨x, x_in, hx⟩, exact sub_lt_iff_lt_add.mp (lt_cSup_of_lt h x_in hx) }
exact sub_lt_iff_lt_add.mp (lt_cSup_of_lt h x_in hx)
intros
refine le_antisymm (mk_real ▸ mk_set_le _) _
have h2 : (λ x, a + a - x) '' Iio a = Ioi a
{ convert image_const_sub_Iio _ _, simp }
convert image_const_sub_Iio _ _
simp
exact mk_Ioi_real a ▸ h2 ▸ mk_image_le
intros
rw [ennreal.of_real, ennreal.of_real, coe_lt_coe, real.to_nnreal_lt_to_nnreal_iff_of_nonneg hp]
intros
simp [Inf_eq_infi, infi_add]
intros
by_cases h' : x = ⊤
{ simp only [h', le_top] }
simp only [h', le_top]
{ simp only [le_refl, coe_to_real h' h] }
simp only [le_refl, coe_to_real h' h]
intros
rw [ereal.sub_eq_add_neg, to_real_add hx h'x, to_real_neg]
{ refl }
refl
{ simpa using hy }
simpa using hy
{ simpa using h'y }
simpa using h'y
intros
simpa only [neg_zero] using is_st_neg hx
intros
simpa [-to_nnreal_pos] using (not_iff_not.2 (@to_nnreal_pos r))
intros
refine ⟨λ h, _, λ h, h.symm ▸ sign_zero⟩
obtain hn | rfl | hp := lt_trichotomy r (0 : ℝ)
rw [sign_of_neg hn, neg_eq_zero] at h
{ rw [sign_of_neg hn, neg_eq_zero] at h, exact (one_ne_zero h).elim }
exact (one_ne_zero h).elim
{ refl }
refl
{ rw sign_of_pos hp at h, exact (one_ne_zero h).elim }
rw sign_of_pos hp at h
exact (one_ne_zero h).elim
intros
rw [mul_self_lt_mul_self_iff hx (sqrt_nonneg y), sq, mul_self_sqrt hy]
intros
haveI := terminates_of_mem ac; haveI := terminates_parallel cs; exact mem_of_promises _ (parallel_promises H)
haveI := terminates_of_mem ac; haveI := terminates_parallel cs
haveI := terminates_of_mem ac
haveI := terminates_parallel cs
exact mem_of_promises _ (parallel_promises H)
intros
simp [set.ite]
intros
simp_rw [diff_eq, ← preimage_compl, image_inter_preimage]
intros
{ ext ⟨x, y⟩, simp [and.left_comm, eq_comm] }
ext ⟨x, y⟩
simp [and.left_comm, eq_comm]
intros
ext
{ ext, split; rintro ⟨a, b, ha, hb, rfl⟩; refine ⟨a, b, ha, hb, by rw h a ha b hb⟩ }
split
split; rintro ⟨a, b, ha, hb, rfl⟩; refine ⟨a, b, ha, hb, by rw h a ha b hb⟩
split; rintro ⟨a, b, ha, hb, rfl⟩
rintro ⟨a, b, ha, hb, rfl⟩
refine ⟨a, b, ha, hb, by rw h a ha b hb⟩
rintro ⟨a, b, ha, hb, rfl⟩
refine ⟨a, b, ha, hb, by rw h a ha b hb⟩
intros
by_cases hx : x ∈ s; simp [hx]
by_cases hx : x ∈ s
simp [hx]
simp [hx]
intros
rw [inter_comm, Ioc_inter_Ioo_of_left_lt h, max_comm]
intros
rw [← Ico_diff_left, diff_diff_cancel_left (singleton_subset_iff.2 $ left_mem_Ico.2 h)]
intros
ext1 x
simp_rw [mem_union, mem_Ioo, mem_Ioi, min_lt_iff]
by_cases hc : c < x
{ tauto }
tauto
have hxb : x < b := (le_of_not_gt hc).trans_lt h₁
{ have hxb : x < b := (le_of_not_gt hc).trans_lt h₁, tauto }
tauto
intros
simp [← Ioi_inter_Iio]
intros
simp
intros
simp [← Ici_inter_Iic, h, inter_comm]
intros
rintros a ⟨⟨hxa, hay⟩, ha'⟩
simpa [le_update_iff, update_le_iff, hxa, hay, hxa _, hay _, ← exists_or_distrib, not_and_distrib] using ha'
intros
simp [sub_eq_add_neg, image_comp (λ x, a + x) (λ x, -x)]
intros
simpa using h.preimage f
intros
{ cases x₀, cases x₁, cases h₀, cases h₁, refl }
cases x₀
cases x₁
cases h₀
cases h₁
refl
intros
ext x
ext x; cases x
cases x
intros
cases n; refl
{ cases n; refl }
cases n
refl
refl
intros
cases n
rcases int.units_eq_one_or u with rfl|rfl; simp
{ rcases int.units_eq_one_or u with rfl|rfl; simp }
rcases int.units_eq_one_or u with rfl|rfl
simp
simp
apply nat.coprime_of_mul_modeq_one ((u⁻¹ : units (zmod (n+1))) : zmod (n+1)).val
have := units.ext_iff.1 (mul_right_inv u)
rw [units.coe_one] at this
rw [← eq_iff_modeq_nat, nat.cast_one, ← this]
clear this
rw [← nat_cast_zmod_val ((u * u⁻¹ : units (zmod (n+1))) : zmod (n+1))]
rw [units.coe_mul, val_mul, nat_cast_mod]
intros
split
split; { contrapose, simp [eq_zero_iff_even], }
{ contrapose, simp [eq_zero_iff_even], }
contrapose
{ contrapose, simp [eq_zero_iff_even], }
simp [eq_zero_iff_even]
intros
simpa only [nsmul_eq_mul, add_right_iterate] using (f.commute_add_int m).iterate_eq_of_map_eq n h
intros
rw [← nat.mod_add_div m n] at hm
exact hm.left_of_add (hn.mul_const _)
intros
apply_instance
intros
{ ext, refl }
ext
refl
intros
apply splits_mul
rw ← (splitting_field.lift q₁ (splits_of_splits_of_dvd _ (mul_ne_zero hq₁ hq₂) (splitting_field.splits _) (dvd_mul_right q₁ q₂))).comp_algebra_map
{ rw ← (splitting_field.lift q₁ (splits_of_splits_of_dvd _ (mul_ne_zero hq₁ hq₂) (splitting_field.splits _) (dvd_mul_right q₁ q₂))).comp_algebra_map, exact splits_comp_of_splits _ _ h₁, }
exact splits_comp_of_splits _ _ h₁
rw ← (splitting_field.lift q₂ (splits_of_splits_of_dvd _ (mul_ne_zero hq₁ hq₂) (splitting_field.splits _) (dvd_mul_left q₂ q₁))).comp_algebra_map
{ rw ← (splitting_field.lift q₂ (splits_of_splits_of_dvd _ (mul_ne_zero hq₁ hq₂) (splitting_field.splits _) (dvd_mul_left q₂ q₁))).comp_algebra_map, exact splits_comp_of_splits _ _ h₂, }
exact splits_comp_of_splits _ _ h₂
intros
have := h.of_mul_left_left
rw derivative_mul at this
exact is_coprime.of_mul_right_right (is_coprime.of_add_mul_left_right this)
intros
haveI : nonempty S := Sne.to_subtype
simp only [Sup_eq_supr', mem_supr_of_directed hS.directed_coe, set_coe.exists, subtype.coe_mk]
intros
unfold angle
rw [inner_smul_right, norm_smul, real.norm_eq_abs, abs_of_nonneg (le_of_lt hr), ←mul_assoc, mul_comm _ r, mul_assoc, mul_div_mul_left _ _ (ne_of_gt hr)]
intros
rw [midpoint_comm p1 p2, angle_left_midpoint_eq_pi_div_two_of_dist_eq h.symm]
intros
set e := ext_chart_at I c
have : is_closed (e '' s) := f.closed_image_of_closed hsc hs
rw [support_eq_inter_preimage, subset_inter_iff, ← image_subset_iff] at hs
rcases euclidean.exists_pos_lt_subset_ball f.R_pos this hs.2 with ⟨r, hrR, hr⟩
exact ⟨r, hrR, subset_inter hs.1 (image_subset_iff.1 hr)⟩
intros
have : s = univ ∩ s
rw univ_inter
rw univ_inter
rwa [this, mdifferentiable_within_at_inter hs, mdifferentiable_within_at_univ] at h
intros
rw [ext_chart_at_coe, (∘), ← I.map_nhds_eq, ← (chart_at H x).map_nhds_eq, map_map]
rwa ext_chart_at_source at hy
intros
rw ← times_cont_mdiff_within_at_univ at *
convert hf.prod_map hg
exact univ_prod_univ.symm
intros
cases add_subgroup.bot_or_exists_ne_zero H with h h
use 0
{ use 0, rw h, exact add_subgroup.closure_singleton_zero.symm }
rw h
exact add_subgroup.closure_singleton_zero.symm
let s := {g : ℤ | g ∈ H ∧ 0 < g}
have h_bdd : ∀ g ∈ s, (0 : ℤ) ≤ g := λ _ h, le_of_lt h.2
obtain ⟨g₀, g₀_in, g₀_ne⟩ := h
obtain ⟨g₁, g₁_in, g₁_pos⟩ : ∃ g₁ : ℤ, g₁ ∈ H ∧ 0 < g₁
cases lt_or_gt_of_ne g₀_ne with Hg₀ Hg₀
{ cases lt_or_gt_of_ne g₀_ne with Hg₀ Hg₀, { exact ⟨-g₀, H.neg_mem g₀_in, neg_pos.mpr Hg₀⟩ }, { exact ⟨g₀, g₀_in, Hg₀⟩ } }
{ exact ⟨-g₀, H.neg_mem g₀_in, neg_pos.mpr Hg₀⟩ }
exact ⟨-g₀, H.neg_mem g₀_in, neg_pos.mpr Hg₀⟩
{ exact ⟨g₀, g₀_in, Hg₀⟩ }
exact ⟨g₀, g₀_in, Hg₀⟩
obtain ⟨a, ha, ha'⟩ := int.exists_least_of_bdd ⟨(0 : ℤ), h_bdd⟩ ⟨g₁, g₁_in, g₁_pos⟩
exact ⟨a, add_subgroup.cyclic_of_min ⟨ha, ha'⟩⟩
intros
{ ext, exact (right_coset_eq_iff s).symm }
ext
exact (right_coset_eq_iff s).symm
intros
simp
intros
rw [mul_mk'_eq_mk'_of_mul, mul_one]
intros
simp_rw [add_order_of_eq_add_order_of_iff, ←f.map_nsmul, ←f.map_zero, hf.eq_iff, iff_self, forall_const]
intros
rintros ⟨⟩ ⟨⟩ h
rw prod.mk.inj_iff
split
split; ext i
ext i
{ simpa using equiv.congr_fun h (sum.inl i), }
simpa using equiv.congr_fun h (sum.inl i)
ext i
{ simpa using equiv.congr_fun h (sum.inr i), }
simpa using equiv.congr_fun h (sum.inr i)
intros
rwa [is_three_cycle, cycle_type_inv]
intros
convert cycle_of_apply_apply_pow_self f x 1 using 1
intros
obtain ⟨m, rfl⟩ := exists_add_of_le h
rw [add_comm]
exact is_cycle_fin_rotate
intros
cases xs with x xs
{ simp }
simp
have : n ≤ xs.length
{ have : n ≤ xs.length, { refine nat.le_of_lt_succ _, simpa using hn }, rcases this.eq_or_lt with rfl|hn', { simp }, { simp [form_perm_apply_lt, h, nat.mod_eq_of_lt, nat.succ_lt_succ hn'] } }
refine nat.le_of_lt_succ _
{ refine nat.le_of_lt_succ _, simpa using hn }
simpa using hn
rcases this.eq_or_lt with rfl|hn'
{ simp }
simp
{ simp [form_perm_apply_lt, h, nat.mod_eq_of_lt, nat.succ_lt_succ hn'] }
simp [form_perm_apply_lt, h, nat.mod_eq_of_lt, nat.succ_lt_succ hn']
intros
intro b
by_cases pb : p b
refine (h (f.symm ⟨b, pb⟩)).imp _ _; { intro h, rw [extend_domain_apply_subtype _ _ pb, h, apply_symm_apply, subtype.coe_mk] }
refine (h (f.symm ⟨b, pb⟩)).imp _ _
{ refine (h (f.symm ⟨b, pb⟩)).imp _ _; { intro h, rw [extend_domain_apply_subtype _ _ pb, h, apply_symm_apply, subtype.coe_mk] } }
{ intro h, rw [extend_domain_apply_subtype _ _ pb, h, apply_symm_apply, subtype.coe_mk] }
intro h
{ intro h, rw [extend_domain_apply_subtype _ _ pb, h, apply_symm_apply, subtype.coe_mk] }
rw [extend_domain_apply_subtype _ _ pb, h, apply_symm_apply, subtype.coe_mk]
left
{ left, rw [extend_domain_apply_not_subtype _ _ pb] }
rw [extend_domain_apply_not_subtype _ _ pb]
intros
rintro ⟨_, g, rfl⟩
use mk g
refl
intros
cases n
{ simp_rw [mul_zero, pow_zero] }
simp_rw [mul_zero, pow_zero]
rw [a_one_pow, one_def]
{ rw [a_one_pow, one_def], congr' 1, exact zmod.nat_cast_self _ }
congr' 1
exact zmod.nat_cast_self _
intros
simp [homothety_apply, point_reflection_apply]
intros
rw ←mem_coe at hp1
rw [←vsub_right_mem_direction_iff_mem (mem_affine_span k (set.mem_insert_of_mem _ hp1)), direction_affine_span_insert hp1, submodule.mem_sup]
split
rintros ⟨v1, hv1, v2, hv2, hp⟩
{ rintros ⟨v1, hv1, v2, hv2, hp⟩, rw submodule.mem_span_singleton at hv1, rcases hv1 with ⟨r, rfl⟩, use [r, v2 +ᵥ p1, vadd_mem_of_mem_direction hv2 hp1], symmetry' at hp, rw [←sub_eq_zero, ←vsub_vadd_eq_vsub_sub, vsub_eq_zero_iff_eq] at hp, rw [hp, vadd_vadd] }
rw submodule.mem_span_singleton at hv1
rcases hv1 with ⟨r, rfl⟩
use [r, v2 +ᵥ p1, vadd_mem_of_mem_direction hv2 hp1]
symmetry' at hp
rw [←sub_eq_zero, ←vsub_vadd_eq_vsub_sub, vsub_eq_zero_iff_eq] at hp
rw [hp, vadd_vadd]
rintros ⟨r, p3, hp3, rfl⟩
{ rintros ⟨r, p3, hp3, rfl⟩, use [r • (p2 -ᵥ p1), submodule.mem_span_singleton.2 ⟨r, rfl⟩, p3 -ᵥ p1, vsub_mem_direction hp3 hp1], rw [vadd_vsub_assoc, add_comm] }
use [r • (p2 -ᵥ p1), submodule.mem_span_singleton.2 ⟨r, rfl⟩, p3 -ᵥ p1, vsub_mem_direction hp3 hp1]
rw [vadd_vsub_assoc, add_comm]
intros
refine le_antisymm _ (subset_span_points _ _)
rintros p ⟨p1, hp1, v, hv, rfl⟩
exact vadd_mem_of_mem_direction hv hp1
intros
rw univ_fin2
convert centroid_insert_singleton k p 0 1
intros
obtain (rfl|hab) : a = b ∨ a ≠ b := classical.em _
simp
{ simp }
rw [slope_comm _ a, slope_comm _ a, slope_comm _ _ b]
convert line_map_slope_slope_sub_div_sub f b (line_map a b r) a hab.symm using 2
rw [line_map_apply_ring, eq_div_iff (sub_ne_zero.2 hab), sub_mul, one_mul, mul_sub, ← sub_sub, sub_sub_cancel]
intros
rw [span_le, set.singleton_subset_iff, set_like.mem_coe]
exact smul_mem _ _ (mem_span_singleton_self _)
intros
apply is_linear_map.mk
intros x y
{ intros x y, simp [add_comm, add_left_comm, sub_eq_add_neg] }
simp [add_comm, add_left_comm, sub_eq_add_neg]
intros x y
{ intros x y, simp [smul_sub] }
simp [smul_sub]
intros
simp [to_clifford]
intros
rw [← linear_map_to_matrix_mul_basis_to_matrix c b c, ← basis_to_matrix_mul_linear_map_to_matrix b c b, matrix.det_conj]
rw [← linear_map_to_matrix_mul_basis_to_matrix c b c, ← basis_to_matrix_mul_linear_map_to_matrix b c b, matrix.det_conj]; rw [basis.to_matrix_mul_to_matrix, basis.to_matrix_self]
rw [basis.to_matrix_mul_to_matrix, basis.to_matrix_self]
rw [basis.to_matrix_mul_to_matrix, basis.to_matrix_self]
intros
rw [rank, linear_map.range_zero, dim_bot]
intros
{ ext φ x, simp }
ext φ x
simp
intros
rw finrank_eq_one_iff_of_nonzero v nz
apply span_singleton_eq_top_iff
intros
rw submodule.eq_bot_iff
intros x hx
refine b.ext_elem (λ i, _)
rw (eq_bot_iff_generator_eq_zero _).mpr hgen at hϕ
rw [linear_equiv.map_zero, finsupp.zero_apply]
exact (submodule.eq_bot_iff _).mp (hϕ ((finsupp.lapply i) ∘ₗ ↑b.repr) bot_le) _ ⟨x, hx, rfl⟩
intros
rw [← linear_independent_fin_cons, fin.cons_self_tail]
intros
intros i j hij
let l : ι →₀ R := finsupp.single i (1 : R) - finsupp.single j 1
have h_total : finsupp.total ι M R v l = 0
simp_rw [linear_map.map_sub, finsupp.total_apply]
{ simp_rw [linear_map.map_sub, finsupp.total_apply], simp [hij] }
simp [hij]
have h_single_eq : finsupp.single i (1 : R) = finsupp.single j 1
rw linear_independent_iff at hv
{ rw linear_independent_iff at hv, simp [eq_add_of_sub_eq' (hv l h_total)] }
simp [eq_add_of_sub_eq' (hv l h_total)]
simpa [finsupp.single_eq_single_iff] using h_single_eq
intros
simp
intros
{ intros i j h, simp [ha h, hb h] }
intros i j h
simp [ha h, hb h]
intros
rw [← matrix.to_lin_alg_equiv_symm, alg_equiv.symm_apply_apply]
intros
simp [polar, add_left, add_right, sub_eq_add_neg _ (B y y), add_comm (B y x) _, add_assoc]
intros
obtain ⟨x, _, not_mem_s⟩ := set_like.exists_of_lt h
refine ⟨⟨mk x, 0, _⟩⟩
simpa using not_mem_s
intros
ext x j
convert (update_apply 0 x i j _).symm
refl
intros
rw [← decidable.not_and_distrib, decidable.not_not]
intros
induction n with n ihn
refl
{ refl }
funext x
simp only [ihn, (h.iterate_right n).eq, iterate_succ, comp_app]
intros
induction hbc
assumption
case refl_trans_gen.refl : { assumption }
case refl_trans_gen.tail : c d hbc hcd hac { exact hac.tail hcd }
intros
rw [has_finite_integral_congr h1f.ae_eq_mk, has_finite_integral_prod_iff h1f.measurable_mk]
apply and_congr
apply eventually_congr
{ apply eventually_congr, filter_upwards [ae_ae_of_ae_prod h1f.ae_eq_mk.symm], assume x hx, exact has_finite_integral_congr hx }
filter_upwards [ae_ae_of_ae_prod h1f.ae_eq_mk.symm]
assume x hx
exact has_finite_integral_congr hx
apply has_finite_integral_congr
{ apply has_finite_integral_congr, filter_upwards [ae_ae_of_ae_prod h1f.ae_eq_mk.symm], assume x hx, exact integral_congr_ae (eventually_eq.fun_comp hx _) }
filter_upwards [ae_ae_of_ae_prod h1f.ae_eq_mk.symm]
assume x hx
exact integral_congr_ae (eventually_eq.fun_comp hx _)
{ apply_instance }
apply_instance
intros
ext1
refine (mem_ℒp.coe_fn_to_Lp _).trans _
refine eventually_eq.trans _ (Lp.coe_fn_smul _ _).symm
rw condexp_ind_smul_smul hs hμs c x
refine (Lp.coe_fn_smul _ _).trans _
refine (condexp_ind_L1_fin_ae_eq_condexp_ind_smul hm hs hμs x).mono (λ y hy, _)
rw [pi.smul_apply, pi.smul_apply, hy]
intros
simp [has_finite_integral]
intros
{ rw ← mem_ℒp_one_iff_integrable at hf ⊢, exact hf.im, }
rw ← mem_ℒp_one_iff_integrable at hf ⊢
exact hf.im
intros
by_cases pzero : p = 0
{ simp [pzero, norm_def] }
simp [pzero, norm_def]
cases le_or_lt 0 c with hc hc
have := snorm_le_mul_snorm_aux_of_nonneg h hc p
{ have := snorm_le_mul_snorm_aux_of_nonneg h hc p, rw [← ennreal.to_real_le_to_real, ennreal.to_real_mul, ennreal.to_real_of_real hc] at this, { exact this }, { exact (Lp.mem_ℒp _).snorm_ne_top }, { simp [(Lp.mem_ℒp _).snorm_ne_top] } }
rw [← ennreal.to_real_le_to_real, ennreal.to_real_mul, ennreal.to_real_of_real hc] at this
{ exact this }
exact this
{ exact (Lp.mem_ℒp _).snorm_ne_top }
exact (Lp.mem_ℒp _).snorm_ne_top
{ simp [(Lp.mem_ℒp _).snorm_ne_top] }
simp [(Lp.mem_ℒp _).snorm_ne_top]
have := snorm_le_mul_snorm_aux_of_neg h hc p
{ have := snorm_le_mul_snorm_aux_of_neg h hc p, simp only [snorm_eq_zero_iff (Lp.ae_measurable _) pzero, ← eq_zero_iff_ae_eq_zero] at this, simp [this] }
simp only [snorm_eq_zero_iff (Lp.ae_measurable _) pzero, ← eq_zero_iff_ae_eq_zero] at this
simp [this]
intros
rw Lp.eq_zero_iff_ae_eq_zero
apply (coe_fn_comp_Lp _ _ _).trans
filter_upwards [Lp.coe_fn_zero E p μ]
assume a ha
simp [ha, g0]
intros
simp only [mem_ℒp, snorm_congr_ae hfg, ae_measurable_congr hfg]
intros
by_cases hfm : ae_measurable f (measure.map e μ)
{ exact integral_map e.measurable hfm }
exact integral_map e.measurable hfm
rw [integral_non_ae_measurable hfm, integral_non_ae_measurable]
{ rw [integral_non_ae_measurable hfm, integral_non_ae_measurable], rwa ← ae_measurable_map_equiv_iff }
rwa ← ae_measurable_map_equiv_iff
intros
rw [norm_eq_sum_mul f, (to_simple_func f).map_integral norm (simple_func.integrable f) norm_zero]
simp_rw smul_eq_mul
intros
simpa [mul_comm] using integral_deriv_comp_smul_deriv' hf hff' hf' hg hgg' hg'
intros
by_cases hc : c = 0; simp [hc]
by_cases hc : c = 0
simp [hc]
simp [hc]
intros
casesI is_empty_or_nonempty β
simp [supr_of_empty]
{ simp [supr_of_empty] }
inhabit β
have : ∀a, (⨆ b, f b a) = (⨆ n, f (h_directed.sequence f n) a)
assume a
{ assume a, refine le_antisymm (supr_le $ assume b, _) (supr_le $ assume n, le_supr (λn, f n a) _), exact le_supr_of_le (encode b + 1) (h_directed.le_sequence b a) }
refine le_antisymm (supr_le $ assume b, _) (supr_le $ assume n, le_supr (λn, f n a) _)
exact le_supr_of_le (encode b + 1) (h_directed.le_sequence b a)
calc ∫⁻ a, ⨆ b, f b a ∂μ = ∫⁻ a, ⨆ n, f (h_directed.sequence f n) a ∂μ : by simp only [this] ... = ⨆ n, ∫⁻ a, f (h_directed.sequence f n) a ∂μ : lintegral_supr (assume n, hf _) h_directed.sequence_mono ... = ⨆ b, ∫⁻ a, f b a ∂μ : begin refine le_antisymm (supr_le $ assume n, _) (supr_le $ assume b, _), { exact le_supr (λb, ∫⁻ a, f b a ∂μ) _ }, { exact le_supr_of_le (encode b + 1) (lintegral_mono $ h_directed.le_sequence b) } end
intros
simp_rw [pi.mul_apply, ennreal.coe_mul]
exact ennreal.lintegral_mul_le_Lp_mul_Lq μ hpq hf.coe_nnreal_ennreal hg.coe_nnreal_ennreal
intros
{ rw [← image_univ], exact measurable_set.univ.inl_image }
rw [← image_univ]
exact measurable_set.univ.inl_image
intros
simp only [prehaar, compacts.map_val, is_left_invariant_index K.2 _ hU]
intros
convert mk_metric_mono_smul ennreal.one_ne_top ennreal.zero_lt_one.ne' _
convert mk_metric_mono_smul ennreal.one_ne_top ennreal.zero_lt_one.ne' _; simp *
{ convert mk_metric_mono_smul ennreal.one_ne_top ennreal.zero_lt_one.ne' _; simp * }
simp *
simp *
intros
conv_rhs { rw [← real.smul_map_volume_mul_left h, smul_smul, ← ennreal.of_real_mul (abs_nonneg _), ← abs_mul, inv_mul_cancel h, abs_one, ennreal.of_real_one, one_smul] }
intros
refine ext_of_generate_from_of_cover_subset hA hC _ (countable_range B) h1B _ h_eq
{ rintro _ ⟨i, rfl⟩, apply h2B }
rintro _ ⟨i, rfl⟩
apply h2B
{ rintro _ ⟨i, rfl⟩, apply hμB }
rintro _ ⟨i, rfl⟩
apply hμB
intros
rw [sUnion_eq_bUnion, measure_bUnion hs hd h]
intros
rw [union_eq_Union, extend_Union P0 m0 PU mU (pairwise_disjoint_on_bool.2 hd) (bool.forall_bool.2 ⟨h₂, h₁⟩), tsum_fintype]
simp
intros
rw [bounded_by, le_of_function, forall_congr]
intro s
cases s.eq_empty_or_nonempty with h h
cases s.eq_empty_or_nonempty with h h; simp [h, empty_not_nonempty]
simp [h, empty_not_nonempty]
simp [h, empty_not_nonempty]
intros
haveI := hI.to_subtype
{ haveI := hI.to_subtype, rw [← infi_subtype'', ← infi_subtype''], exact map_infi_comap _ }
rw [← infi_subtype'', ← infi_subtype'']
exact map_infi_comap _
intros
rw of_union h hA₁ hB₁ at hAB
linarith
apply_instance
intros
by_cases hj₁ : measurable_set j
{ exact (restrict_le_restrict_iff _ _ hi).1 hi₂ hj₁ hj }
exact (restrict_le_restrict_iff _ _ hi).1 hi₂ hj₁ hj
{ rw [v.not_measurable hj₁, w.not_measurable hj₁] }
rw [v.not_measurable hj₁, w.not_measurable hj₁]
intros
simpa using d.has_compl d.has_empty
intros
have hp3 : p < 3 := lt_three hpq hqr H
interval_cases p
{ exact admissible_A' q r }
exact admissible_A' q r
have hq4 : q < 4 := lt_four hqr H
interval_cases q
{ exact admissible_D' r }
exact admissible_D' r
have hr6 : r < 6 := lt_six H
interval_cases r
{ exact admissible_E6 }
exact admissible_E6
{ exact admissible_E7 }
exact admissible_E7
{ exact admissible_E8 }
exact admissible_E8
intros
apply int.gcd_eq_one_iff_coprime.mp
by_contradiction hab
obtain ⟨p, hp, hpa, hpb⟩ := nat.prime.not_coprime_iff_dvd.mp hab
obtain ⟨a1, rfl⟩ := (int.coe_nat_dvd_left.mpr hpa)
obtain ⟨b1, rfl⟩ := (int.coe_nat_dvd_left.mpr hpb)
have hpc : (p : ℤ) ^ 2 ∣ c
apply (int.pow_dvd_pow_iff (dec_trivial : 0 < 2)).mp
{ apply (int.pow_dvd_pow_iff (dec_trivial : 0 < 2)).mp, rw ← h.1.2.2, apply dvd.intro (a1 ^ 4 + b1 ^ 4), ring }
rw ← h.1.2.2
apply dvd.intro (a1 ^ 4 + b1 ^ 4)
ring
obtain ⟨c1, rfl⟩ := hpc
have hf : fermat_42 a1 b1 c1
exact (fermat_42.mul (int.coe_nat_ne_zero.mpr (nat.prime.ne_zero hp))).mpr h.1
apply nat.le_lt_antisymm (h.2 _ _ _ hf)
rw [int.nat_abs_mul, lt_mul_iff_one_lt_left, int.nat_abs_pow, int.nat_abs_of_nat]
exact nat.one_lt_pow _ _ (show 0 < 2, from dec_trivial) (nat.prime.one_lt hp)
{ exact nat.one_lt_pow _ _ (show 0 < 2, from dec_trivial) (nat.prime.one_lt hp) }
exact (nat.pos_of_ne_zero (int.nat_abs_ne_zero_of_ne_zero (ne_zero hf)))
{ exact (nat.pos_of_ne_zero (int.nat_abs_ne_zero_of_ne_zero (ne_zero hf))) }
intros
cases x
cases y
congr
congr; assumption
assumption
assumption
intros
rw [ideal.mem_span_singleton]
split
rintro ⟨c, rfl⟩
{ rintro ⟨c, rfl⟩, suffices : c ≠ 0, { rw [valuation_p_pow_mul _ _ this, le_add_iff_nonneg_right], apply valuation_nonneg, }, contrapose! hx, rw [hx, mul_zero], }
suffices : c ≠ 0
rw [valuation_p_pow_mul _ _ this, le_add_iff_nonneg_right]
{ rw [valuation_p_pow_mul _ _ this, le_add_iff_nonneg_right], apply valuation_nonneg, }
apply valuation_nonneg
contrapose! hx
rw [hx, mul_zero]
rw [unit_coeff_spec hx] { occs := occurrences.pos [2] }
{ rw [unit_coeff_spec hx] { occs := occurrences.pos [2] }, lift x.valuation to ℕ using x.valuation_nonneg with k hk, simp only [int.nat_abs_of_nat, units.is_unit, is_unit.dvd_mul_left, int.coe_nat_le], intro H, obtain ⟨k, rfl⟩ := nat.exists_eq_add_of_le H, simp only [pow_add, dvd_mul_right], }
lift x.valuation to ℕ using x.valuation_nonneg with k hk
simp only [int.nat_abs_of_nat, units.is_unit, is_unit.dvd_mul_left, int.coe_nat_le]
intro H
obtain ⟨k, rfl⟩ := nat.exists_eq_add_of_le H
simp only [pow_add, dvd_mul_right]
intros
unfold padic_val_rat
split_ifs
simp [-add_comm]; refl
{ simp [-add_comm]; refl }
simp [-add_comm]
refl
{ exfalso, simp * at * }
exfalso
simp * at *
{ exfalso, simp * at * }
exfalso
simp * at *
intros
induction n with n ih
{ refl }
refl
{ simpa using ih }
simpa using ih
intros
refine frequently_at_top.2 (λ n, _)
obtain ⟨p, hp⟩ := exists_prime_ge_modeq_one k n hpos
exact ⟨p, ⟨hp.2.1, hp.1, hp.2.2⟩⟩
intros
simp [norm]
intros
cases x; rw [norm, norm_sq]; simp
cases x; rw [norm, norm_sq]
cases x
rw [norm, norm_sq]
simp
intros
rintro rfl
{ rintro rfl, apply (hf.reflect_lt h1).not_le, exact int.le_of_lt_add_one (hf.reflect_lt h2) }
apply (hf.reflect_lt h1).not_le
exact int.le_of_lt_add_one (hf.reflect_lt h2)
intros
rw [inf_comm, inf_sdiff_self_right]
intros
classical
refine ⟨λ H a, ⟨(function.monotone_eval a).mem_upper_bounds_image H.1, λ b hb, _⟩, λ H, ⟨_, _⟩⟩
suffices : function.update f a b ∈ upper_bounds s
{ suffices : function.update f a b ∈ upper_bounds s, from function.update_same a b f ▸ H.2 this a, refine λ g hg, le_update_iff.2 ⟨hb $ mem_image_of_mem _ hg, λ i hi, H.1 hg i⟩ }
from function.update_same a b f ▸ H.2 this a
refine λ g hg, le_update_iff.2 ⟨hb $ mem_image_of_mem _ hg, λ i hi, H.1 hg i⟩
{ exact λ g hg a, (H a).1 (mem_image_of_mem _ hg) }
exact λ g hg a, (H a).1 (mem_image_of_mem _ hg)
exact λ g hg a, (H a).2 ((function.monotone_eval a).mem_upper_bounds_image hg)
{ exact λ g hg a, (H a).2 ((function.monotone_eval a).mem_upper_bounds_image hg) }
intros
rw [well_founded_iff_is_Sup_finite_compact, is_Sup_finite_compact_iff_all_elements_compact] at h
exact ⟨λ x, ⟨{x}, ⟨λ x _, h x, Sup_singleton⟩⟩⟩
intros
have := (hs.mono $ insert_subset.mpr ⟨hx, hy⟩) (mem_insert x _)
rw [insert_diff_of_mem _ (mem_singleton _), diff_singleton_eq_self hxy] at this
exact this
intros
simp only [← infi_inf_eq, infi_or]
intros
classical
contrapose! hb
exact cSup_le hs hb
intros
rw [disjointed_succ, hf.partial_sups_eq]
intros
simp_rw [inf_ne_bot_iff_frequently_left, frequently_map, frequently_at_top]
simp_rw [inf_ne_bot_iff_frequently_left, frequently_map, frequently_at_top]; refl
refl
intros
rw [prod_map_map_eq, prod_at_top_at_top_eq, prod.map_def]
intros
simp only [le_def, hl.mem_iff]
intros
simpa only [div_eq_mul_inv] using h.mul h'.inv
intros
{ rw [prod_comm', ← map_swap_eq_comap_swap], refl }
rw [prod_comm', ← map_swap_eq_comap_swap]
refl
intros
split
rw [infi_eq_generate, mem_generate_iff]
{ rw [infi_eq_generate, mem_generate_iff], rintro ⟨t, tsub, tfin, tinter⟩, rcases eq_finite_Union_of_finite_subset_Union tfin tsub with ⟨I, Ifin, σ, σfin, σsub, rfl⟩, rw sInter_Union at tinter, set V := λ i, U ∪ ⋂₀ σ i with hV, have V_in : ∀ i, V i ∈ s i, { rintro i, have : (⋂₀ σ i) ∈ s i, { rw sInter_mem (σfin _), apply σsub }, exact mem_of_superset this (subset_union_right _ _) }, refine ⟨I, Ifin, V, V_in, _⟩, rwa [hV, ← union_Inter, union_eq_self_of_subset_right] }
rintro ⟨t, tsub, tfin, tinter⟩
rcases eq_finite_Union_of_finite_subset_Union tfin tsub with ⟨I, Ifin, σ, σfin, σsub, rfl⟩
rw sInter_Union at tinter
set V := λ i, U ∪ ⋂₀ σ i with hV
have V_in : ∀ i, V i ∈ s i
rintro i
{ rintro i, have : (⋂₀ σ i) ∈ s i, { rw sInter_mem (σfin _), apply σsub }, exact mem_of_superset this (subset_union_right _ _) }
have : (⋂₀ σ i) ∈ s i
rw sInter_mem (σfin _)
{ rw sInter_mem (σfin _), apply σsub }
apply σsub
exact mem_of_superset this (subset_union_right _ _)
refine ⟨I, Ifin, V, V_in, _⟩
rwa [hV, ← union_Inter, union_eq_self_of_subset_right]
rintro ⟨I, Ifin, V, V_in, rfl⟩
{ rintro ⟨I, Ifin, V, V_in, rfl⟩, exact mem_infi_of_Inter Ifin V_in subset.rfl }
exact mem_infi_of_Inter Ifin V_in subset.rfl
intros
rwa [inf_principal_eq_bot, compl_compl] at h
intros
by_cases h : ∃i, a ∈ s i
rcases h with ⟨i, hi⟩
{ rcases h with ⟨i, hi⟩, refine tendsto_pure.2 ((eventually_ge_at_top i).mono $ assume n hn, _), rw [indicator_of_mem (hs hn hi) _, indicator_of_mem ((subset_Union _ _) hi) _] }
refine tendsto_pure.2 ((eventually_ge_at_top i).mono $ assume n hn, _)
rw [indicator_of_mem (hs hn hi) _, indicator_of_mem ((subset_Union _ _) hi) _]
rw [not_exists] at h
{ rw [not_exists] at h, simp only [indicator_of_not_mem (h _)], convert tendsto_const_pure, apply indicator_of_not_mem, simpa only [not_exists, mem_Union] }
simp only [indicator_of_not_mem (h _)]
convert tendsto_const_pure
apply indicator_of_not_mem
simpa only [not_exists, mem_Union]
intros
rw [prod_same_eq, mem_lift'_sets]; exact set.monotone_prod monotone_id monotone_id
rw [prod_same_eq, mem_lift'_sets]
exact set.monotone_prod monotone_id monotone_id
intros
simp only [le_antisymm_iff, h.iterate_pos_le_iff_map_le hf hg hn, h.symm.iterate_pos_le_iff_map_le' hg hf hn]
intros
obtain ⟨c, hc, hbc⟩ : ∃ (c : β) (hc : c ∈ {c : β | ∀ᶠ (n : α) in f, c ≤ u n}), b < c := exists_lt_of_lt_cSup hu h
exact hc.mono (λ x hx, lt_of_lt_of_le hbc hx)
intros
classical
let bad : set ℕ := { m | ∀ n, m < n → ¬ r (f m) (f n) }
by_cases hbad : infinite bad
haveI := hbad
{ haveI := hbad, refine ⟨nat.order_embedding_of_set bad, or.intro_right _ (λ m n mn, _)⟩, have h := set.mem_range_self m, rw nat.order_embedding_of_set_range bad at h, exact h _ ((order_embedding.lt_iff_lt _).2 mn) }
refine ⟨nat.order_embedding_of_set bad, or.intro_right _ (λ m n mn, _)⟩
have h := set.mem_range_self m
rw nat.order_embedding_of_set_range bad at h
exact h _ ((order_embedding.lt_iff_lt _).2 mn)
rw [set.infinite_coe_iff, set.infinite, not_not] at hbad
{ rw [set.infinite_coe_iff, set.infinite, not_not] at hbad, obtain ⟨m, hm⟩ : ∃ m, ∀ n, m ≤ n → ¬ n ∈ bad, { by_cases he : hbad.to_finset.nonempty, { refine ⟨(hbad.to_finset.max' he).succ, λ n hn nbad, nat.not_succ_le_self _ (hn.trans (hbad.to_finset.le_max' n (hbad.mem_to_finset.2 nbad)))⟩ }, { exact ⟨0, λ n hn nbad, he ⟨n, hbad.mem_to_finset.2 nbad⟩⟩ } }, have h : ∀ (n : ℕ), ∃ (n' : ℕ), n < n' ∧ r (f (n + m)) (f (n' + m)), { intro n, have h := hm _ (le_add_of_nonneg_left n.zero_le), simp only [exists_prop, not_not, set.mem_set_of_eq, not_forall] at h, obtain ⟨n', hn1, hn2⟩ := h, obtain ⟨x, hpos, rfl⟩ := exists_pos_add_of_lt hn1, refine ⟨n + x, add_lt_add_left hpos n, _⟩, rw [add_assoc, add_comm x m, ← add_assoc], exact hn2 }, let g' : ℕ → ℕ := @nat.rec (λ _, ℕ) m (λ n gn, nat.find (h gn)), exact ⟨(rel_embedding.nat_lt (λ n, g' n + m) (λ n, nat.add_lt_add_right (nat.find_spec (h (g' n))).1 m)).order_embedding_of_lt_embedding, or.intro_left _ (λ n, (nat.find_spec (h (g' n))).2)⟩ }
obtain ⟨m, hm⟩ : ∃ m, ∀ n, m ≤ n → ¬ n ∈ bad
by_cases he : hbad.to_finset.nonempty
{ by_cases he : hbad.to_finset.nonempty, { refine ⟨(hbad.to_finset.max' he).succ, λ n hn nbad, nat.not_succ_le_self _ (hn.trans (hbad.to_finset.le_max' n (hbad.mem_to_finset.2 nbad)))⟩ }, { exact ⟨0, λ n hn nbad, he ⟨n, hbad.mem_to_finset.2 nbad⟩⟩ } }
refine ⟨(hbad.to_finset.max' he).succ, λ n hn nbad, nat.not_succ_le_self _ (hn.trans (hbad.to_finset.le_max' n (hbad.mem_to_finset.2 nbad)))⟩
{ refine ⟨(hbad.to_finset.max' he).succ, λ n hn nbad, nat.not_succ_le_self _ (hn.trans (hbad.to_finset.le_max' n (hbad.mem_to_finset.2 nbad)))⟩ }
{ exact ⟨0, λ n hn nbad, he ⟨n, hbad.mem_to_finset.2 nbad⟩⟩ }
exact ⟨0, λ n hn nbad, he ⟨n, hbad.mem_to_finset.2 nbad⟩⟩
have h : ∀ (n : ℕ), ∃ (n' : ℕ), n < n' ∧ r (f (n + m)) (f (n' + m))
intro n
{ intro n, have h := hm _ (le_add_of_nonneg_left n.zero_le), simp only [exists_prop, not_not, set.mem_set_of_eq, not_forall] at h, obtain ⟨n', hn1, hn2⟩ := h, obtain ⟨x, hpos, rfl⟩ := exists_pos_add_of_lt hn1, refine ⟨n + x, add_lt_add_left hpos n, _⟩, rw [add_assoc, add_comm x m, ← add_assoc], exact hn2 }
have h := hm _ (le_add_of_nonneg_left n.zero_le)
simp only [exists_prop, not_not, set.mem_set_of_eq, not_forall] at h
obtain ⟨n', hn1, hn2⟩ := h
obtain ⟨x, hpos, rfl⟩ := exists_pos_add_of_lt hn1
refine ⟨n + x, add_lt_add_left hpos n, _⟩
rw [add_assoc, add_comm x m, ← add_assoc]
exact hn2
let g' : ℕ → ℕ := @nat.rec (λ _, ℕ) m (λ n gn, nat.find (h gn))
exact ⟨(rel_embedding.nat_lt (λ n, g' n + m) (λ n, nat.add_lt_add_right (nat.find_spec (h (g' n))).1 m)).order_embedding_of_lt_embedding, or.intro_left _ (λ n, (nat.find_spec (h (g' n))).2)⟩
intros
rw is_prime_iff
use ‹_›
apply is_pfilter.of_def
{ exact set.nonempty_compl.2 (I.is_proper_iff.1 ‹_›) }
exact set.nonempty_compl.2 (I.is_proper_iff.1 ‹_›)
intros x _ y _
{ intros x _ y _, refine ⟨x ⊓ y, _, inf_le_left, inf_le_right⟩, have := mt hI, tauto! }
refine ⟨x ⊓ y, _, inf_le_left, inf_le_right⟩
have := mt hI
tauto!
{ exact @mem_compl_of_ge _ _ _ }
exact @mem_compl_of_ge _ _ _
intros
refine λ y, (hg' _).unique _
rw [← fa.surjective.image_preimage {x | g x ≤ fb y}, preimage_set_of_eq]
simp only [h.eq, fb.le_iff_le, fa.left_ord_continuous (hg' _)]
intros
split
intro h'
{ intro h', have : ¬r x y, { intro hy, rw [well_founded.succ, dif_pos] at h', exact wo.wf.not_lt_min _ h hy h' }, rcases trichotomous_of r x y with hy | hy | hy, exfalso, exact this hy, right, exact hy.symm, left, exact hy }
have : ¬r x y
intro hy
{ intro hy, rw [well_founded.succ, dif_pos] at h', exact wo.wf.not_lt_min _ h hy h' }
rw [well_founded.succ, dif_pos] at h'
exact wo.wf.not_lt_min _ h hy h'
rcases trichotomous_of r x y with hy | hy | hy
exfalso
exact this hy
right
exact hy.symm
left
exact hy
rintro (hy | rfl)
exact trans hy (wo.wf.lt_succ h)
exact wo.wf.lt_succ h
intros
let Q : s → Prop := λ y, P y
change Q ⟨x, hx⟩
refine well_founded.induction hs ⟨x, hx⟩ _
rintros ⟨y, ys⟩ ih
exact hP _ ys (λ z zs zy, ih ⟨z, zs⟩ zy)
intros
rw [equivariant_projection, smul_apply, sum_of_conjugates_equivariant, equivariant_of_linear_of_comm_apply, sum_of_conjugates]
rw [linear_map.sum_apply]
simp only [conjugate_i π i h]
rw [finset.sum_const, finset.card_univ, nsmul_eq_smul_cast k, ←mul_smul, invertible.inv_of_mul_self, one_smul]
intros
rw [is_artinian_iff_well_founded, well_founded.well_founded_iff_has_min']
intros
{ rw mul_comm at h, exact h.of_add_mul_left_left }
rw mul_comm at h
exact h.of_add_mul_left_left
intros
rcases hI with ⟨I, rfl⟩
rcases exist_integer_multiples_of_finset S I with ⟨⟨s, hs1⟩, hs⟩
rw is_fractional_span_iff
exact ⟨s, hs1, hs⟩
intros
apply set.subset.trans (λ x hx, _) support_add_antidiagonal_subset_add
{ exact x.is_pwo_support }
exact x.is_pwo_support
{ exact y.is_pwo_support }
exact y.is_pwo_support
contrapose! hx
simp only [not_nonempty_iff_eq_empty, ne.def, set.mem_set_of_eq] at hx
simp [hx]
intros
rw [mul_comm, span_singleton_mul_right_unit h2]
intros
{ rw [map_eq_bot_iff_le_ker, mk_ker], exact h }
rw [map_eq_bot_iff_le_ker, mk_ker]
exact h
intros
simp only [span_singleton_mul_le_iff, mem_span_singleton_mul, eq_comm]
intros
rw int.coe_nat_dvd_left
exact int.prime.dvd_pow hp h
intros
split
contrapose!
{ contrapose!, intro h, rw [power_series.ext_iff, not_forall], refine ⟨0, _⟩, simp [coeff_order_ne_zero h] }
intro h
rw [power_series.ext_iff, not_forall]
refine ⟨0, _⟩
simp [coeff_order_ne_zero h]
rintro rfl
{ rintro rfl, simp }
simp
intros
split
split; rintros ⟨n, hn⟩; use n; simp only [lmul_left_eq_zero_iff, pow_lmul_left] at ⊢ hn; exact hn
split; rintros ⟨n, hn⟩; use n; simp only [lmul_left_eq_zero_iff, pow_lmul_left] at ⊢ hn
split; rintros ⟨n, hn⟩; use n
split; rintros ⟨n, hn⟩
rintros ⟨n, hn⟩
use n
simp only [lmul_left_eq_zero_iff, pow_lmul_left] at ⊢ hn
exact hn
exact hn
rintros ⟨n, hn⟩
use n
simp only [lmul_left_eq_zero_iff, pow_lmul_left] at ⊢ hn
exact hn
exact hn
intros
haveI := subsingleton_of_zero_eq_one h01; haveI := fintype.of_subsingleton (0:R); exact is_noetherian_ring_iff.2 (ring.is_noetherian_of_fintype R R)
haveI := subsingleton_of_zero_eq_one h01; haveI := fintype.of_subsingleton (0:R)
haveI := subsingleton_of_zero_eq_one h01
haveI := fintype.of_subsingleton (0:R)
exact is_noetherian_ring_iff.2 (ring.is_noetherian_of_fintype R R)
intros
rw [← C_0, content_C, normalize_zero]
intros
rw total_degree
apply le_antisymm
apply finset.sup_le
{ apply finset.sup_le, intros d hd, rw mem_support_iff at hd, rw [finsupp.sum, hφ hd], }
intros d hd
rw mem_support_iff at hd
rw [finsupp.sum, hφ hd]
obtain ⟨d, hd⟩ : ∃ d, coeff d φ ≠ 0 := exists_coeff_ne_zero h
{ obtain ⟨d, hd⟩ : ∃ d, coeff d φ ≠ 0 := exists_coeff_ne_zero h, simp only [← hφ hd, finsupp.sum], replace hd := finsupp.mem_support_iff.mpr hd, exact finset.le_sup hd, }
simp only [← hφ hd, finsupp.sum]
replace hd := finsupp.mem_support_iff.mpr hd
exact finset.le_sup hd
intros
dsimp only [minpoly_gen, map_dim]
{ dsimp only [minpoly_gen, map_dim], simp only [linear_equiv.trans_apply, map_basis, basis.map_repr, map_gen, alg_equiv.to_linear_equiv_apply, e.to_linear_equiv_symm, alg_equiv.map_pow, alg_equiv.symm_apply_apply, sub_right_inj] }
simp only [linear_equiv.trans_apply, map_basis, basis.map_repr, map_gen, alg_equiv.to_linear_equiv_apply, e.to_linear_equiv_symm, alg_equiv.map_pow, alg_equiv.symm_apply_apply, sub_right_inj]
intros
simp only [coeff_X, single_left_inj one_ne_zero]
{ simp only [coeff_X, single_left_inj one_ne_zero], split_ifs; refl }
intros
rw [← mv_power_series.eq_mul_inv_iff_mul_eq h, one_mul]
intros
simp only [coeff, finsupp.single_add]
convert φ.coeff_add_mul_monomial (single () n) (single () 1) _
rw mul_one
intros
change ↑(↑(ζ ^ m) : units R) = ↑(ζ : units R) ^ m
rw [subgroup.coe_pow, units.coe_pow]
intros
obtain ⟨ζ, hζ⟩ := h.is_unit n.pos
rw [← hζ, is_primitive_root.coe_units_iff] at h
exact h.card_roots_of_unity'
intros
simpa only [range_eq_map] using (⊤ : subring R).map_map g f
intros
cases n
simp only [is_unit_one, int.coe_nat_zero, int.coe_nat_succ, zero_add, pow_zero, C_1, is_unit.dvd]
{ simp only [is_unit_one, int.coe_nat_zero, int.coe_nat_succ, zero_add, pow_zero, C_1, is_unit.dvd] }
have key := bind₁_rename_expand_witt_polynomial Φ n IH
apply_fun (map (int.cast_ring_hom (zmod (p ^ (n + 1))))) at key
conv_lhs at key { simp only [map_bind₁, map_rename, map_expand, map_witt_polynomial] }
rw [nat.succ_eq_add_one, C_dvd_iff_zmod, ring_hom.map_sub, sub_eq_zero, map_bind₁]
simp only [map_rename, map_witt_polynomial, witt_polynomial_zmod_self]
rw key
clear key IH
rw [bind₁, aeval_witt_polynomial, ring_hom.map_sum, ring_hom.map_sum, finset.sum_congr rfl]
intros k hk
rw [finset.mem_range, nat.lt_succ_iff] at hk
simp only [← sub_eq_zero, ← ring_hom.map_sub, ← C_dvd_iff_zmod, C_eq_coe_nat, ← mul_sub, ← int.nat_cast_eq_coe_nat, ← nat.cast_pow]
rw show p ^ (n + 1) = p ^ k * p ^ (n - k + 1), { rw [← pow_add, ←add_assoc], congr' 2, rw [add_comm, ←nat.sub_eq_iff_eq_add hk] }
rw [nat.cast_mul, nat.cast_pow, nat.cast_pow]
apply mul_dvd_mul_left
rw show p ^ (n + 1 - k) = p * p ^ (n - k), { rw [← pow_succ, nat.sub_add_comm hk] }
rw [pow_mul]
apply dvd_sub_pow_of_dvd_sub
rw [← C_eq_coe_nat, int.nat_cast_eq_coe_nat, C_dvd_iff_zmod, ring_hom.map_sub, sub_eq_zero, map_expand, ring_hom.map_pow, mv_polynomial.expand_zmod]
intros
obtain ⟨y, rfl⟩ := witt_vector.truncate_surjective p _ _ x
simp only [truncate_witt_vector_truncate, witt_vector.coeff_truncate, fin.coe_cast_le]
intros
rw [to_nat_apply_of_omega_le h, nat.cast_zero]
intros
intro h
have t := state.left_bound m
rw h at t
exact nat.not_succ_le_zero _ t
intros
rw [←@not_lt _ _ o' o, enum_lt ho']
intros
rw div_def a h; exact omin_mem {o | a < b * succ o} _
rw div_def a h
exact omin_mem {o | a < b * succ o} _
intros
simp [termg]
intros
simp
intros
convert ← normalize_fin_lt.cast h
intros
suffices : ⇑(homothety x t) = λ y, t • (y - x) + x
rw this
{ rw this, continuity, }
continuity
ext y
simp [homothety_apply]
intros
simpa only [div_eq_mul_inv] using hf.mul continuous_on_const
intros
rw has_sum_subtype_iff_indicator at *
rw set.indicator_union_of_disjoint hs
exact ha.add hb
intros
simp only [div_eq_mul_inv, h.mul_right b⁻¹]
intros
convert is_closed_closure
intros
simpa [(∘)] using tendsto_neg_at_top_at_bot.comp ((tendsto_neg_at_bot_at_top.comp hf).at_top_mul hC hg)
intros
obtain ⟨x, h, hfg, hgf⟩ : (univ ∩ {x | f x ≤ g x ∧ g x ≤ f x}).nonempty
from is_preconnected_closed_iff.1 preconnected_space.is_preconnected_univ _ _ (is_closed_le hf hg) (is_closed_le hg hf) (λ x hx, le_total _ _) ⟨a, trivial, ha⟩ ⟨b, trivial, hb⟩
exact ⟨x, le_antisymm hfg hgf⟩
intros
rw [nhds_order_unbounded hu hl]; from (tendsto_infi.2 $ assume l, tendsto_infi.2 $ assume hl, tendsto_infi.2 $ assume u, tendsto_infi.2 $ assume hu, tendsto_principal.2 $ h l u hl hu)
rw [nhds_order_unbounded hu hl]
from (tendsto_infi.2 $ assume l, tendsto_infi.2 $ assume hl, tendsto_infi.2 $ assume u, tendsto_infi.2 $ assume hu, tendsto_principal.2 $ h l u hl hu)
intros
refine is_topological_basis_of_open_of_nhds _ _
rintros _ ⟨V, hV, rfl⟩
{ rintros _ ⟨V, hV, rfl⟩, rwa hf.is_open_iff, refine ⟨V, h.is_open hV, rfl⟩ }
rwa hf.is_open_iff
refine ⟨V, h.is_open hV, rfl⟩
intros a U ha hU
{ intros a U ha hU, rw hf.is_open_iff at hU, obtain ⟨V, hV, rfl⟩ := hU, obtain ⟨S, hS, rfl⟩ := h.open_eq_sUnion hV, obtain ⟨W, hW, ha⟩ := ha, refine ⟨f ⁻¹' W, ⟨_, hS hW, rfl⟩, ha, set.preimage_mono $ set.subset_sUnion_of_mem hW⟩ }
rw hf.is_open_iff at hU
obtain ⟨V, hV, rfl⟩ := hU
obtain ⟨S, hS, rfl⟩ := h.open_eq_sUnion hV
obtain ⟨W, hW, ha⟩ := ha
refine ⟨f ⁻¹' W, ⟨_, hS hW, rfl⟩, ha, set.preimage_mono $ set.subset_sUnion_of_mem hW⟩
intros
simp only [maps_to, mem_closure_iff_cluster_pt]
exact λ x hx, hx.map hc.continuous_at (tendsto_principal_principal.2 h)
intros
simp [frontier]
intros
rw [filter.frequently, filter.eventually, ← mem_interior_iff_mem_nhds, closure_eq_compl_interior_compl]
rw [filter.frequently, filter.eventually, ← mem_interior_iff_mem_nhds, closure_eq_compl_interior_compl]; refl
refl
intros
{ rw is_clopen_iff at h', finish [h.ne_empty] }
rw is_clopen_iff at h'
finish [h.ne_empty]
intros
rw [nhds_prod_eq, prod_mem_prod_iff]
intros
{ simp only [div_eq_mul_inv], refl, }
simp only [div_eq_mul_inv]
refl
intros
have c : continuous (λ x, dist (f x) (g x))
continuity
{ continuity, }
obtain ⟨x, -, le⟩ := is_compact.exists_forall_ge compact_univ set.univ_nonempty (continuous.continuous_on c)
exact lt_of_le_of_lt (dist_le_iff_of_nonempty.mpr (λ y, le y trivial)) (w x)
intros
{ rw algebra.algebra_map_eq_smul_one, refl, }
rw algebra.algebra_map_eq_smul_one
refl
intros
rw subalgebra_topological_closure_eq_top_of_separates_points A w
simp
intros
rw [← nhds_within_singleton, ← nhds_within_union, compl_union_self, nhds_within_univ]
intros
simp only [← singleton_union, continuous_within_at_union, continuous_within_at_singleton, true_and]
intros
refine id (λ z H, id (λ U h, preimage_nhds_within_coinduced' H (a.pretrivialization_at x).open_target (le_def.1 (nhds_mono _) U h)))
exact le_supr _ x
intros
cases F
cases G
congr' 1
ext x
exact h x
intros
refine ⟨has_sum.tendsto_sum_nat, assume h, _⟩
rw [← supr_eq_of_tendsto _ h, ← ennreal.tsum_eq_supr_nat]
{ exact ennreal.summable.has_sum }
exact ennreal.summable.has_sum
exact assume s t hst, finset.sum_le_sum_of_subset (finset.range_subset.2 hst)
{ exact assume s t hst, finset.sum_le_sum_of_subset (finset.range_subset.2 hst) }
intros
rw [←nnreal.coe_eq, coe_tsum, nnreal.coe_add, coe_sum, coe_tsum, sum_add_tsum_nat_add k (nnreal.summable_coe.2 hf)]
intros
refine local_homeomorph.ext _ _ (λx, rfl) (λx, rfl) _
simp [e.open_source.interior_eq, ← inter_assoc]
intros
rw (is_locally_constant.tfae f).out 0 3
intros a
have : f ⁻¹' {a} = (g ∘ f) ⁻¹' { g a }
ext x
{ ext x, simp only [mem_singleton_iff, function.comp_app, mem_preimage], exact ⟨λ h, by rw h, λ h, inj h⟩ }
simp only [mem_singleton_iff, function.comp_app, mem_preimage]
exact ⟨λ h, by rw h, λ h, inj h⟩
rw this
apply h
intros
rw [← nhds_comap_dist a, tendsto_comap_iff]
intros
simp only [diam, emetric.diam_subsingleton hs, ennreal.zero_to_real]
intros
funext x y; exact dist_comm _ _
funext x y
exact dist_comm _ _
intros
rw [← tendsto_uniformly_on_univ, tendsto_uniformly_on_iff]
{ rw [← tendsto_uniformly_on_univ, tendsto_uniformly_on_iff], simp }
simp
intros
rw [GH_dist, p.to_GH_space_rep, q.to_GH_space_rep]
intros
{ rw dimH_def, exact le_bsupr d h }
rw dimH_def
exact le_bsupr d h
intros
simp [Hausdorff_dist, Hausdorff_edist_comm]
intros
rw [← image_symm, ediam_image]
intros
refine finite.induction_on hI (by simp) (λ i I hi _ hI, _)
rw [bUnion_insert, ball_insert_iff, union_left_iff, hI]
intros
{ rw continuous_def, assume s h, exact ⟨_, h, rfl⟩ }
rw continuous_def
assume s h
exact ⟨_, h, rfl⟩
intros
refine ((f i).continuous.mul $ continuous_finprod_cond (λ j _, continuous_const.sub (f j).continuous) _)
simp only [mul_support_one_sub]
exact f.locally_finite
intros
rcases hF with ⟨x, x_in, hx⟩
use [f x, mem_image_of_mem f x_in]
rintros _ ⟨y, y_in, rfl⟩
exact ⟨(hx y_in).some_path.map hf, λ t, ⟨_, (hx y_in).some_path_mem t, rfl⟩⟩
intros
simp_rw [← continuous_within_at_univ, ← lower_semicontinuous_within_at_univ_iff, ← upper_semicontinuous_within_at_univ_iff, continuous_within_at_iff_lower_upper_semicontinuous_within_at]
intros
rw [res, limit.lift_π, fan.mk_π_app]
intros
erw [← F.germ_res iWU ⟨x, hxW⟩, ← F.germ_res iWV ⟨x, hxW⟩, comp_apply, comp_apply, ih]
intros
introsI f hnf hstf
obtain ⟨a, hsa, ha⟩ : ∃ a ∈ s, cluster_pt a f := hs (le_trans hstf (le_principal_iff.2 (inter_subset_left _ _)))
have : a ∈ t := (ht.mem_of_nhds_within_ne_bot $ ha.mono $ le_trans hstf (le_principal_iff.2 (inter_subset_right _ _)))
exact ⟨a, ⟨hsa, this⟩, ha⟩
intros
rw sUnion_eq_Union at hc₂; simpa using lebesgue_number_lemma hs (by simpa) hc₂
rw sUnion_eq_Union at hc₂
simpa using lebesgue_number_lemma hs (by simpa) hc₂
intros
{ rw [uniformity_eq_symm, mem_nhds_uniformity_iff_right], refl }
rw [uniformity_eq_symm, mem_nhds_uniformity_iff_right]
refl
intros
rw ← continuous_within_at_univ at h
rw ← nhds_within_univ at hunif hg
exact tendsto_comp_of_locally_uniform_limit_within h hg hunif
intros
split
split; rintros ⟨h₁, h₂⟩; split; linarith
split; rintros ⟨h₁, h₂⟩; split
split; rintros ⟨h₁, h₂⟩
rintros ⟨h₁, h₂⟩
split
linarith
linarith
rintros ⟨h₁, h₂⟩
split
linarith
linarith
intros
rw [← stream.eta (map f s), tail_map, head_map]
intros
cases b; simp
cases b
simp
simp
intros
rw [h, int.neg_neg]
intros
have h := int.add_lt_add_left h (-a)
rwa int.neg_add_cancel_left at h
intros
rw [qsort, well_founded.fix_eq, qsort.F]
intros
rw [mod_eq_sub_mod (nat.le_add_left _ _), nat.add_sub_cancel]
intros
revert x
apply nat.strong_induction_on y _
clear y
intros y IH x
cases lt_or_le y k with h h
rw [div_eq_of_lt h]
{ rw [div_eq_of_lt h], cases x with x, { simp [nat.zero_mul, y.zero_le] }, { simp [succ_mul, not_succ_le_zero, nat.add_comm], apply lt_of_lt_of_le h, apply nat.le_add_right } }
cases x with x
{ simp [nat.zero_mul, y.zero_le] }
simp [nat.zero_mul, y.zero_le]
simp [succ_mul, not_succ_le_zero, nat.add_comm]
{ simp [succ_mul, not_succ_le_zero, nat.add_comm], apply lt_of_lt_of_le h, apply nat.le_add_right }
apply lt_of_lt_of_le h
apply nat.le_add_right
rw [div_eq_sub_div Hk h]
{ rw [div_eq_sub_div Hk h], cases x with x, { simp [nat.zero_mul, nat.zero_le] }, { have Hlt : y - k < y, { apply nat.sub_lt_of_pos_le ; assumption }, rw [ ← add_one , nat.add_le_add_iff_le_right , IH (y - k) Hlt x , add_one , succ_mul, nat.add_le_to_le_sub _ h ] } }
cases x with x
{ simp [nat.zero_mul, nat.zero_le] }
simp [nat.zero_mul, nat.zero_le]
have Hlt : y - k < y
{ have Hlt : y - k < y, { apply nat.sub_lt_of_pos_le ; assumption }, rw [ ← add_one , nat.add_le_add_iff_le_right , IH (y - k) Hlt x , add_one , succ_mul, nat.add_le_to_le_sub _ h ] }
apply nat.sub_lt_of_pos_le ; assumption
{ apply nat.sub_lt_of_pos_le ; assumption }
apply nat.sub_lt_of_pos_le
assumption
assumption
rw [ ← add_one , nat.add_le_add_iff_le_right , IH (y - k) Hlt x , add_one , succ_mul, nat.add_le_to_le_sub _ h ]
intros
cases it; cases it_snd; simp [iterator.next, iterator.next_to_string, string.length, nat.add_sub_cancel_left]
cases it; cases it_snd
cases it
cases it_snd
simp [iterator.next, iterator.next_to_string, string.length, nat.add_sub_cancel_left]
simp [iterator.next, iterator.next_to_string, string.length, nat.add_sub_cancel_left]
intros
refine neg_eq_of_add_eq_zero (vadd_right_cancel p1 _)
rw [vsub_add_vsub_cancel, vsub_self]
intros
rw [← nat.nsmul_eq_mul, ← sum_const]
apply sum_congr rfl h₁
intros
simp only [mul_comm, prod_range_succ_comm]
intros
rw [finprod_eq_prod_plift_of_mul_support_subset h.coe_to_finset.ge, finprod_eq_prod_plift_of_mul_support_subset, f.map_prod]
rw [h.coe_to_finset]
exact mul_support_comp_subset f.map_one (g ∘ plift.down)
intros
rw [finprod_mem_insert, finprod_mem_singleton]
{ rw [finprod_mem_insert, finprod_mem_singleton], exacts [h, finite_singleton b] }
exacts [h, finite_singleton b]
intros
simpa only [sub_eq_add_neg] using sum_Ico_eq_add_neg f h
intros
ext k
rw [← finset.univ_sum_single k, g.map_sum, h.map_sum]
simp only [w]
intros
ext
simp [kernel_iso_ker]
intros
{ rw ←cocone_naturality F f, refl }
rw ←cocone_naturality F f
refl
intros
{ rw [eq_comm], exact bit1_eq_one }
rw [eq_comm]
exact bit1_eq_one
intros
simp [zeroth_s_eq, continuants_aux, next_continuants, next_denominator, next_numerator]
intros
rw [sub_eq_add_neg, ← neg_div, div_add_div_same, sub_eq_add_neg]
intros
{ ext, simp [floor_lt] }
ext
simp [floor_lt]
intros
simp [star, has_star.star]
intros
simp only [mul_comm, lcm_mul_left]
intros
simpa only [div_eq_mul_inv] using λ a a' h, inv_injective (mul_right_injective b h)
intros
rw [semiconj_by, mul_one, one_mul]
intros
simp only [divp, mul_inv_rev, units.coe_mul, mul_assoc]
intros
rw [pow_bit0', neg_mul_neg, pow_bit0']
intros
rcases nat.exists_eq_succ_of_ne_zero hn with ⟨k, rfl⟩
induction k with k ih
simp only [pow_one]
{ simp only [pow_one] }
let n := k.succ
have h1 := add_nonneg (mul_nonneg hx (pow_nonneg hy n)) (mul_nonneg hy (pow_nonneg hx n))
have h2 := add_nonneg hx hy
calc x^n.succ + y^n.succ ≤ x*x^n + y*y^n + (x*y^n + y*x^n) : by { rw [pow_succ _ n, pow_succ _ n], exact le_add_of_nonneg_right h1 } ... = (x+y) * (x^n + y^n) : by rw [add_mul, mul_add, mul_add, add_comm (y*x^n), ← add_assoc, ← add_assoc, add_assoc (x*x^n) (x*y^n), add_comm (x*y^n) (y*y^n), ← add_assoc] ... ≤ (x+y)^n.succ : by { rw [pow_succ _ n], exact mul_le_mul_of_nonneg_left (ih (nat.succ_ne_zero k)) h2 }
intros
assume h
rcases exists_pair_ne M₀ with ⟨x, y, hx⟩
apply hx
calc x = 1 * x : by rw [one_mul] ... = 0 : by rw [← h, zero_mul] ... = 1 * y : by rw [← h, zero_mul] ... = y : by rw [one_mul]
intros
simp only [semiconj_by, mul_zero, zero_mul]
intros
{ ext, simp, }
ext
simp
intros
cases i
dsimp [prev_d]
{ dsimp [prev_d], rcases (complex_shape.up ℕ).prev 0 with _|⟨j,hj⟩; dsimp [prev_d], { rw [D.shape, comp_zero], dsimp, dec_trivial }, { dsimp at hj, exact (nat.succ_ne_zero _ hj).elim } }
rcases (complex_shape.up ℕ).prev 0 with _|⟨j,hj⟩; dsimp [prev_d]
rcases (complex_shape.up ℕ).prev 0 with _|⟨j,hj⟩
dsimp [prev_d]
{ rw [D.shape, comp_zero], dsimp, dec_trivial }
rw [D.shape, comp_zero]
dsimp
dec_trivial
dsimp [prev_d]
{ dsimp at hj, exact (nat.succ_ne_zero _ hj).elim }
dsimp at hj
exact (nat.succ_ne_zero _ hj).elim
rw prev_d_eq
dsimp
refl
intros
{ ext, simp, }
ext
simp
intros
intro x
simp_rw indicator_apply
split_ifs
{ exact le_rfl, }
exact le_rfl
{ exact (not_le.mp h_1).le, }
exact (not_le.mp h_1).le
{ exact h_1, }
exact h_1
{ exact le_rfl, }
exact le_rfl
intros
rw le_antisymm_iff
split
{ simp, }
simp
rw [← mul_le_mul_iff_left c⁻¹, ← mul_assoc, inv_mul_self, one_mul, le_inf_iff]
{ rw [← mul_le_mul_iff_left c⁻¹, ← mul_assoc, inv_mul_self, one_mul, le_inf_iff], simp, }
simp
intros
simp only [sub_add_cancel, map_lie, lie_hom.lie_apply]
intros
simp [PB, JB, JD_transform, matrix.from_blocks_transpose, matrix.from_blocks_multiply, matrix.from_blocks_smul]
intros
conv_rhs { rw ← I₁.incl_ideal_range, }
{ conv_rhs { rw ← I₁.incl_ideal_range, }, rw ← map_comap_eq, exact I₁.incl_is_ideal_morphism, }
rw ← map_comap_eq
exact I₁.incl_is_ideal_morphism
intros
induction k with k ih
change (⊤ : lie_ideal R L').map f = ⊤
{ change (⊤ : lie_ideal R L').map f = ⊤, rw ←f.ideal_range_eq_map, exact f.ideal_range_eq_top_of_surjective h, }
rw ←f.ideal_range_eq_map
exact f.ideal_range_eq_top_of_surjective h
simp only [derived_series_def, map_bracket_eq f h, ih, derived_series_of_ideal_succ]
{ simp only [derived_series_def, map_bracket_eq f h, ih, derived_series_of_ideal_succ], }
intros
let φ : (P →₀ R) →ₗ[R] M := finsupp.total _ _ _ (λ p, function.surj_inv hf (g p))
cases h.out with s hs
use φ.comp s
ext p
conv_rhs {rw ← hs p}
simp [φ, finsupp.total_apply, function.surj_inv_eq hf]
intros
simpa using abv_add abv (a - b) b
intros
{ rw [inv_eq_one_div], exact div_le_iff ha }
rw [inv_eq_one_div]
exact div_le_iff ha
intros
rw [div_le_iff hb, one_mul]
intros
simp only [le_iff_eq_or_lt, inv_pos, zero_eq_inv]
intros
rw [abs_le', and.comm, neg_le]
intros
{ ext x, refl }
ext x
refl
intros
simp [abs_eq_max_neg]
intros
haveI := @linear_order.decidable_le α _; exact ⟨lt_imp_lt_of_le_imp_le $ λ h', decidable.mul_le_mul_of_nonneg_right h' h.le, λ h', mul_lt_mul_of_pos_right h' h⟩
haveI := @linear_order.decidable_le α _
exact ⟨lt_imp_lt_of_le_imp_le $ λ h', decidable.mul_le_mul_of_nonneg_right h' h.le, λ h', mul_lt_mul_of_pos_right h' h⟩
intros
simpa using coeff_zero_multiset_prod (s.1.map f)
intros
assume h'
rw [quadratic_eq_zero_iff_discrim_eq_sq h2 ha, sq] at h'
exact h _ h'
intros
rw [add_comm, self_add_conj']
intros
rw inv_eq_iff_mul_eq_one
{ rw inv_eq_iff_mul_eq_one, simp only [units.ext_iff], push_cast, exact mul_self_eq_one_iff }
simp only [units.ext_iff]
push_cast
exact mul_self_eq_one_iff
intros
simp only [sub_eq_add_neg, h.add_left]
intros
simp only [← mul_support_prod_mk, prod.mk.eta]
intros
simp [trop_eq_iff_eq_untrop]
intros
rw [mul_comm, const_mul_cancel]
intros
rcases hf with ⟨r, hf⟩
rcases ennreal.lt_iff_exists_nnreal_btwn.1 hf.r_pos with ⟨r', r'0, h⟩
obtain ⟨a, ha, C, hC, hp⟩ : ∃ (a ∈ Ioo (0 : ℝ) 1) (C > 0), (∀ y ∈ metric.ball (0 : E) r', ∀ n, ∥f (x + y) - p.partial_sum n y∥ ≤ C * (a * (∥y∥ / r')) ^ n)
from hf.uniform_geometric_approx' h
refine is_O_iff.2 ⟨C * (a / r') ^ n, _⟩
replace r'0 : 0 < (r' : ℝ)
exact_mod_cast r'0
exact_mod_cast r'0
filter_upwards [metric.ball_mem_nhds (0 : E) r'0]
intros y hy
simpa [mul_pow, mul_div_assoc, mul_assoc, div_mul_eq_mul_div] using hp y hy n
intros
simp [apply_composition]
intros
cases n
exact hn.false.elim
clear hn
induction n with n ihn
simpa only [pow_one]
{ simpa only [pow_one] }
convert h.mul ihn; simp [pow_succ]
convert h.mul ihn
simp [pow_succ]
simp [pow_succ]
intros
rw [← nat.cofinite_eq_at_top, is_O_cofinite_iff h]
intros
refine (h₁.trans_le $ λ x, _).add (h₂.trans_le _)
refine (h₁.trans_le $ λ x, _).add (h₂.trans_le _); simp [real.norm_eq_abs, abs_of_nonneg, add_nonneg]
simp [real.norm_eq_abs, abs_of_nonneg, add_nonneg]
simp [real.norm_eq_abs, abs_of_nonneg, add_nonneg]
intros
rcases hf with ⟨f', hf₁, cf⟩
rcases hg with ⟨g', hg₁, cg⟩
exact ⟨g'.comp f', hg₁.comp x hf₁, cg.comp cf⟩
intros
simpa only [sub_eq_add_neg] using hf.neg.const_add c
intros
rw [← has_fderiv_within_at_univ, ← has_fderiv_within_at_univ, iso.comp_has_fderiv_within_at_iff']
intros
{ simp [differentiable_on, differentiable_within_at_univ], refl }
simp [differentiable_on, differentiable_within_at_univ]
refl
intros
assume x hx
rw [D, mem_Inter]
assume e
have : (0 : ℝ) < (1/2) ^ e := pow_pos (by norm_num) _
rcases mem_A_of_differentiable this hx.1 with ⟨R, R_pos, hR⟩
obtain ⟨n, hn⟩ : ∃ (n : ℕ), (1/2) ^ n < R := exists_pow_lt_of_lt_one R_pos (by norm_num : (1 : ℝ)/2 < 1)
simp only [mem_Union, mem_Inter, B, mem_inter_eq]
refine ⟨n, λ p hp q hq, ⟨fderiv 𝕜 f x, hx.2, ⟨_, _⟩⟩⟩
refine ⟨n, λ p hp q hq, ⟨fderiv 𝕜 f x, hx.2, ⟨_, _⟩⟩⟩; { refine hR _ ⟨pow_pos (by norm_num) _, lt_of_le_of_lt _ hn⟩, exact pow_le_pow_of_le_one (by norm_num) (by norm_num) (by assumption) }
{ refine hR _ ⟨pow_pos (by norm_num) _, lt_of_le_of_lt _ hn⟩, exact pow_le_pow_of_le_one (by norm_num) (by norm_num) (by assumption) }
refine hR _ ⟨pow_pos (by norm_num) _, lt_of_le_of_lt _ hn⟩
{ refine hR _ ⟨pow_pos (by norm_num) _, lt_of_le_of_lt _ hn⟩, exact pow_le_pow_of_le_one (by norm_num) (by norm_num) (by assumption) }
exact pow_le_pow_of_le_one (by norm_num) (by norm_num) (by assumption)
intros
simp only [unique_diff_within_at_iff] at *
rw [mem_closure_iff_nhds_within_ne_bot] at h ⊢
exact ⟨h.1.mono $ submodule.span_mono $ tangent_cone_mono_nhds st, h.2.mono st⟩
intros
rw ← times_cont_diff_within_at_univ
{ rw ← times_cont_diff_within_at_univ, simp [times_cont_diff_within_at_zero, nhds_within_univ] }
simp [times_cont_diff_within_at_zero, nhds_within_univ]
intros
refine ⟨λ x hx, _, h.fderiv_within, h.cont⟩
rw h₁ x hx
exact h.zero_eq x hx
intros
rcases hf 1 hn with ⟨u, H, p, hp⟩
simp only [nhds_within_univ, mem_univ, insert_eq_of_mem] at H
have := hp.has_strict_fderiv_at le_rfl H
rwa hf'.unique this.has_fderiv_at
intros
induction m with m IH generalizing x
rw [h.zero_eq' hx, iterated_fderiv_within_zero_eq_comp]
{ rw [h.zero_eq' hx, iterated_fderiv_within_zero_eq_comp] }
have A : (m : with_top ℕ) < n := lt_of_lt_of_le (with_top.coe_lt_coe.2 (lt_add_one m)) hmn
{ have A : (m : with_top ℕ) < n := lt_of_lt_of_le (with_top.coe_lt_coe.2 (lt_add_one m)) hmn, have : has_fderiv_within_at (λ (y : E), iterated_fderiv_within 𝕜 m f s y) (continuous_multilinear_map.curry_left (p x (nat.succ m))) s x := (h.fderiv_within m A x hx).congr (λ y hy, (IH (le_of_lt A) hy).symm) (IH (le_of_lt A) hx).symm, rw [iterated_fderiv_within_succ_eq_comp_left, function.comp_apply, this.fderiv_within (hs x hx)], exact (continuous_multilinear_map.uncurry_curry_left _).symm }
have : has_fderiv_within_at (λ (y : E), iterated_fderiv_within 𝕜 m f s y) (continuous_multilinear_map.curry_left (p x (nat.succ m))) s x := (h.fderiv_within m A x hx).congr (λ y hy, (IH (le_of_lt A) hy).symm) (IH (le_of_lt A) hx).symm
rw [iterated_fderiv_within_succ_eq_comp_left, function.comp_apply, this.fderiv_within (hs x hx)]
exact (continuous_multilinear_map.uncurry_curry_left _).symm
intros
simp only [open_segment, image, prod.exists, mem_set_of_eq, exists_prop, and_assoc]
intros
rw [center_mass, sum_subset ht h, smul_sum, center_mass, smul_sum]
apply sum_subset ht
assume i hit' hit
rw [h i hit' hit, zero_smul, smul_zero]
intros
simp only [to_cone, convex_cone.mem_mk, mem_Union, mem_smul_set, eq_comm, exists_prop]
intros
refine tsum_le_of_sum_le' _ (λ s, hv.sum_inner_products_le x)
simp only [norm_nonneg, pow_nonneg]
intros
rw[←inner_conj_sym, mul_comm]
{ rw[←inner_conj_sym, mul_comm], exact re_eq_abs_of_mul_conj (inner y x), }
exact re_eq_abs_of_mul_conj (inner y x)
intros
rw [to_euclidean.to_homeomorph.nhds_eq_comap]
exact metric.nhds_basis_closed_ball.comap _
intros
ext
ext; simp [reflection_apply]
simp [reflection_apply]
intros
have h := rpow_arith_mean_le_arith_mean_rpow (univ : finset (fin 2)) (fin.cons w₁ $ fin.cons w₂ fin_zero_elim) (fin.cons z₁ $ fin.cons z₂ $ fin_zero_elim) _ hp
simpa [fin.sum_univ_succ, fin.sum_univ_zero, fin.cons_succ, fin.cons_zero] using h
{ simpa [fin.sum_univ_succ, fin.sum_univ_zero, fin.cons_succ, fin.cons_zero] using h, }
simp [hw', fin.sum_univ_succ, fin.sum_univ_zero, fin.cons_succ, fin.cons_zero]
{ simp [hw', fin.sum_univ_succ, fin.sum_univ_zero, fin.cons_succ, fin.cons_zero], }
intros
simpa using dist_triangle (v +ᵥ p) (v' +ᵥ p) (v' +ᵥ p')
intros
{ rw [dist_point_reflection_self, real.norm_two] }
rw [dist_point_reflection_self, real.norm_two]
intros
induction n with n ih
simp only [norm_zero, nat.cast_zero, zero_mul, zero_smul]
{ simp only [norm_zero, nat.cast_zero, zero_mul, zero_smul] }
simp only [nat.succ_eq_add_one, add_smul, add_mul, one_mul, nat.cast_add, nat.cast_one, one_nsmul]
exact norm_add_le_of_le ih le_rfl
intros
intros k k_in
rcases h k k_in with ⟨g, rfl, hg⟩
use [g, rfl]
by_cases Hg : ∥f g∥ = 0
{ simpa [Hg] using hg }
simpa [Hg] using hg
exact hg.trans ((mul_le_mul_right $ (ne.symm Hg).le_iff_lt.mp (norm_nonneg _)).mpr H)
{ exact hg.trans ((mul_le_mul_right $ (ne.symm Hg).le_iff_lt.mp (norm_nonneg _)).mpr H) }
intros
ext
{ ext, rw [comp_apply, comp_apply, ← sub_eq_zero, ← normed_group_hom.sub_apply], exact x.2 }
rw [comp_apply, comp_apply, ← sub_eq_zero, ← normed_group_hom.sub_apply]
exact x.2
intros
erw quotient_norm_eq_zero_iff
exact subset_closure S.zero_mem
simp [arg, le_refl]
intros
rw integral_deriv_eq_sub'; norm_num [continuous_on_cos]
rw integral_deriv_eq_sub'
norm_num [continuous_on_cos]
norm_num [continuous_on_cos]
norm_num [continuous_on_cos]
intros
nth_rewrite 0 ←ennreal.rpow_one x
exact ennreal.rpow_le_rpow_of_exponent_le hx h_one_le
intros
split_ifs; simp [rpow_def, *]; exact rpow_def_of_neg (lt_of_le_of_ne hx h) _
split_ifs; simp [rpow_def, *]
split_ifs
simp [rpow_def, *]
simp [rpow_def, *]
simp [rpow_def, *]
exact rpow_def_of_neg (lt_of_le_of_ne hx h) _
intros
simp only [div_eq_mul_inv, mul_rpow hx (inv_nonneg.2 hy), inv_rpow hy]
intros
cases hp.lt_or_lt with hneg hpos
exacts [(((times_cont_diff_at_fst.log hneg.ne).mul times_cont_diff_at_snd).exp.mul (times_cont_diff_at_snd.mul times_cont_diff_at_const).cos).congr_of_eventually_eq ((continuous_at_fst.eventually (gt_mem_nhds hneg)).mono (λ p hp, rpow_def_of_neg hp _)), ((times_cont_diff_at_fst.log hpos.ne').mul times_cont_diff_at_snd).exp.congr_of_eventually_eq ((continuous_at_fst.eventually (lt_mem_nhds hpos)).mono (λ p hp, rpow_def_of_pos hp _))]
intros
rw [← not_iff_not, not_exists, ← ne, tan_ne_zero_iff]
intros
rw [← not_exists, not_iff_not, sin_eq_zero_iff]
rw [← cos_pi_div_two_sub, ← sq_cos_pi_div_six]
congr
ring
intros
refine ⟨λ hc h₀, _, λ h, (has_deriv_at_tan h).continuous_at⟩
exact not_tendsto_nhds_of_tendsto_at_top (tendsto_abs_tan_of_cos_eq_zero h₀) _ (hc.norm.tendsto.mono_left inf_le_left)
intros
refine ⟨λ h, _, λ h, (has_deriv_within_at_arcsin_Iic h).differentiable_within_at⟩
rw [← neg_neg x, ← image_neg_Ici] at h
have := (h.comp (-x) differentiable_within_at_id.neg (maps_to_image _ _)).neg
simpa [(∘), differentiable_within_at_arcsin_Ici] using this
intros
refine (monotone_mul_left_of_nonneg hc).seq_pos_lt_seq_of_lt_of_le hn _ h _
{ simp }
simp
{ simp [pow_succ, mul_assoc, le_refl] }
simp [pow_succ, mul_assoc, le_refl]
intros
rw [limits.is_image.iso_ext_hom, ←images.image_strong_epi_mono_factorisation_to_mono_factorisation_m, is_image.lift_fac, coimages.coimage_strong_epi_mono_factorisation_to_mono_factorisation_m, coimages.coimage.fac]
intros
rw [add_def, sub_comp, neg_def, sub_comp, zero_comp, add_def, neg_def]
intros
simp only [conj_Aut_apply, iso.trans_symm, iso.trans_assoc]
intros
constructor
intros Z g h H
replace H := congr_arg (adj.hom_equiv X Z) H
rwa [adj.hom_equiv_naturality_left, adj.hom_equiv_naturality_left, cancel_epi, equiv.apply_eq_iff_eq] at H
intros
{ dsimp [inv_fun_id_assoc], tidy }
dsimp [inv_fun_id_assoc]
tidy
intros
let sa := max₃ k₁ l k₂
let sb := coeq (f₁ ≫ first_to_max₃ k₁ l k₂) (g₁ ≫ second_to_max₃ k₁ l k₂)
let sc := coeq (f₂ ≫ first_to_max₃ k₁ l k₂) (f₃ ≫ third_to_max₃ k₁ l k₂)
let sd := coeq (f₄ ≫ third_to_max₃ k₁ l k₂) (g₂ ≫ second_to_max₃ k₁ l k₂)
let se := max₃ sb sc sd
let sf := coeq₃ (coeq_hom _ _ ≫ first_to_max₃ sb sc sd) (coeq_hom _ _ ≫ second_to_max₃ sb sc sd) (coeq_hom _ _ ≫ third_to_max₃ sb sc sd)
use sf
use first_to_max₃ k₁ l k₂ ≫ coeq_hom _ _ ≫ first_to_max₃ sb sc sd ≫ coeq₃_hom _ _ _
use second_to_max₃ k₁ l k₂ ≫ coeq_hom _ _ ≫ second_to_max₃ sb sc sd ≫ coeq₃_hom _ _ _
use third_to_max₃ k₁ l k₂ ≫ coeq_hom _ _ ≫ third_to_max₃ sb sc sd ≫ coeq₃_hom _ _ _
fsplit
slice_lhs 1 3 { rw [← category.assoc, coeq_condition] }
slice_lhs 3 6 { rw [← category.assoc, coeq₃_condition₁] }
simp only [category.assoc]
fsplit
slice_lhs 3 6 { rw [← category.assoc, coeq₃_condition₁] }
slice_lhs 1 3 { rw [← category.assoc, coeq_condition] }
slice_rhs 3 6 { rw [← category.assoc, ← coeq₃_condition₂] }
simp only [category.assoc]
slice_rhs 3 6 { rw [← category.assoc, coeq₃_condition₂] }
slice_rhs 1 3 { rw [← category.assoc, ← coeq_condition] }
simp only [category.assoc]
intros
{dsimp, simp}
dsimp
simp
intros
rw [←eq_inv_comp, comp_id]
intros
{ dsimp [colimit_limit_to_limit_colimit], simp, }
dsimp [colimit_limit_to_limit_colimit]
simp
intros
apply induction F (λ X k, s.π.app X ≫ G.map k = (s.π.app j : _))
intros j₁ j₂ k₁ k₂ f w h
{ intros j₁ j₂ k₁ k₂ f w h, rw ←s.w f, rw ←w at h, simpa using h, }
rw ←s.w f
rw ←w at h
simpa using h
intros j₁ j₂ k₁ k₂ f w h
{ intros j₁ j₂ k₁ k₂ f w h, rw ←s.w f at h, rw ←w, simpa using h, }
rw ←s.w f at h
rw ←w
simpa using h
{ exact s.w (𝟙 _), }
exact s.w (𝟙 _)
intros
ext
ext; simp
simp
intros
tidy
intros
simp
intros
{ ext, simp [biproduct.matrix], }
ext
simp [biproduct.matrix]
intros
rw [←s.w right, parallel_pair_map_right]
intros
apply (cancel_mono (image.ι h)).1
simp [image.pre_comp, image.eq_to_hom]
intros
tidy
intros
simp
intros
{ rw [←tensor_id, associator_inv_naturality] }
rw [←tensor_id, associator_inv_naturality]
intros
ext X S
apply grothendieck_topology.close_eq_top_iff_mem
intros
split
intros h Y Z f g hf
{ intros h Y Z f g hf, simpa using h (𝟙 _) g (S.downward_closed hf g) hf (id_comp _) }
simpa using h (𝟙 _) g (S.downward_closed hf g) hf (id_comp _)
intros h Y₁ Y₂ Z g₁ g₂ f₁ f₂ h₁ h₂ k
{ intros h Y₁ Y₂ Z g₁ g₂ f₁ f₂ h₁ h₂ k, simp_rw [← h f₁ g₁ h₁, k, h f₂ g₂ h₂] }
simp_rw [← h f₁ g₁ h₁, k, h f₂ g₂ h₂]
intros
{ ext, simp [w], }
ext
simp [w]
intros
change F.corepr_f.app X f = (F.corepr_f.app F.corepr_X ≫ F.map f) (𝟙 F.corepr_X)
rw ←F.corepr_f.naturality
dsimp
simp
intros
conv_rhs { rw ← c.blocks_sum }
exact length_le_sum_of_one_le _ (λ i hi, c.one_le_blocks hi)
intros
simp [blocks_fun, single, blocks, i.2]
intros
rw [←apply_ne_one_iff h, not_not]
intros
cases G.exists_maximal_degree_vertex with v hv
rw hv
apply G.degree_lt_card_verts v
intros
ext x
change (∃ S H, S ∈ M.to_NFA.eval_from {M.start} x) ↔ _
rw to_NFA_eval_from_match
split
rintro ⟨ S, hS₁, hS₂ ⟩
{ rintro ⟨ S, hS₁, hS₂ ⟩, rw set.mem_singleton_iff at hS₂, rw hS₂ at hS₁, assumption }
rw set.mem_singleton_iff at hS₂
rw hS₂ at hS₁
assumption
intro h
{ intro h, use M.eval x, finish }
use M.eval x
finish
intros
simp [partrec, map_id']
intros
induction k generalizing v s
exact ⟨_, rfl, trans_gen.single rfl⟩
case halt : { exact ⟨_, rfl, trans_gen.single rfl⟩ }
case cons₁ : fs as k IH { obtain ⟨s', h₁, h₂⟩ := tr_normal_respects fs (cont.cons₂ v k) as none, refine ⟨s', h₁, trans_gen.head rfl _⟩, simp, refine (move₂_ok dec_trivial _ (split_at_pred_ff _)).trans _, {refl}, simp, refine (move₂_ok dec_trivial _ _).trans _, swap 4, {refl}, swap 4, {exact (split_at_pred_eq _ _ _ (some Γ'.Cons) _ (λ x h, to_bool_ff (tr_list_ne_Cons _ _ h)) ⟨rfl, rfl⟩)}, refine (move₂_ok dec_trivial _ (split_at_pred_ff _)).trans _, {refl}, simp, exact h₂ }
case cons₂ : ns k IH { obtain ⟨c, h₁, h₂⟩ := IH (ns.head :: v) none, exact ⟨c, h₁, trans_gen.head rfl $ head_stack_ok.trans h₂⟩ }
case comp : f k IH { obtain ⟨s', h₁, h₂⟩ := tr_normal_respects f k v s, exact ⟨_, h₁, trans_gen.head rfl h₂⟩ }
case fix : f k IH { rw [step_ret], have : if v.head = 0 then nat_end (tr_list v).head'.iget = tt ∧ (tr_list v).tail = tr_list v.tail else nat_end (tr_list v).head'.iget = ff ∧ (tr_list v).tail = (tr_nat v.head).tail ++ Γ'.cons :: tr_list v.tail, { cases v with n, {exact ⟨rfl, rfl⟩}, cases n, {exact ⟨rfl, rfl⟩}, rw [tr_list, list.head, tr_nat, nat.cast_succ, num.add_one, num.succ, list.tail], cases (n:num).succ'; exact ⟨rfl, rfl⟩ }, by_cases v.head = 0; simp [h] at this ⊢, { obtain ⟨c, h₁, h₂⟩ := IH v.tail (tr_list v).head', refine ⟨c, h₁, trans_gen.head rfl _⟩, simp [tr_cont, tr_cont_stack, this], exact h₂ }, { obtain ⟨s', h₁, h₂⟩ := tr_normal_respects f (cont.fix f k) v.tail (some Γ'.cons), refine ⟨_, h₁, trans_gen.head rfl $ trans_gen.trans _ h₂⟩, swap 3, simp [tr_cont, this.1], convert clear_ok (split_at_pred_eq _ _ (tr_nat v.head).tail (some Γ'.cons) _ _ _) using 2, { simp }, { exact λ x h, tr_nat_nat_end _ _ (list.tail_subset _ h) }, { exact ⟨rfl, this.2⟩ } } }
intros
simp only [tape.write, tape.mk', list_blank.head_cons, list_blank.tail_cons, eq_self_iff_true, and_self]
intros
ext
ext; simp with functor_norm
simp with functor_norm
intros
simp only [to_list_spec, fold_map, traverse]
induction xs
refl
case list.nil { refl }
case list.cons : _ _ ih { unfold list.traverse list.ret, rw ih, refl }
intros
rw list.nth_eq_some
have ll := to_list_length a
split
split; intro h; cases h with h e; subst v
split; intro h; cases h with h e
split; intro h
intro h
cases h with h e
subst v
{ exact ⟨ll ▸ h, (to_list_nth_le _ _ _).symm⟩ }
exact ⟨ll ▸ h, (to_list_nth_le _ _ _).symm⟩
intro h
cases h with h e
subst v
{ exact ⟨ll.symm ▸ h, to_list_nth_le _ _ _⟩ }
exact ⟨ll.symm ▸ h, to_list_nth_le _ _ _⟩
intros
{ cases b, simp [size, push_back] }
cases b
simp [size, push_back]
intros
cases reps
{ exact bounded.foldl_core_zero }
exact bounded.foldl_core_zero
constructor
intros cb n hn
obtain ⟨np, errp, hp⟩ := bounded.exists p hn
simpa [foldl_core_succ_eq_fail, hp] using he cb n np errp
intros
introI
rcases h with ⟨cb, n, n', a, h⟩
have hs := static.of_done h
simpa [←hs] using of_done h
intros
have : cb.size - n = 0 := nat.sub_eq_zero_of_le hc
simp only [foldr, foldr_core_succ_eq_fail, this, and.left_comm, foldr_core_zero_eq_fail, ne_iff_lt_iff_le, exists_and_distrib_right, exists_eq_left, and.congr_left_iff, exists_and_distrib_left]
rintro (h | ⟨⟨a, h⟩, rfl⟩)
{ exact mono.of_fail h }
exact mono.of_fail h
{ exact mono.of_done h }
exact mono.of_done h
intros
{ ext; simp [norm_sq, mul_comm], }
ext
ext; simp [norm_sq, mul_comm]
simp [norm_sq, mul_comm]
simp [norm_sq, mul_comm]
intros
rw ← of_real_inj; simp [sinh_two_mul]
rw ← of_real_inj
simp [sinh_two_mul]
intros
rw [cos_add, cos_mul_I, sin_mul_I, mul_assoc]
intros
rw [exp_eq_exp_re_mul_sin_add_cos]
{ rw [exp_eq_exp_re_mul_sin_add_cos], simp [exp_of_real_re, sin_of_real_re] }
simp [exp_of_real_re, sin_of_real_re]
intros
rw [←of_real_one, of_real_im]
intros
have := add_monoid_hom.congr_fun lift_add_hom_single_add_hom f
rw [lift_add_hom_apply, sum_add_hom_apply] at this
exact this
intros
ext i
by_cases h1 : g₁ i ≠ 0; by_cases h2 : g₂ i ≠ 0; simp only [not_not, ne.def] at h1 h2; simp [h1, h2, hf]
by_cases h1 : g₁ i ≠ 0; by_cases h2 : g₂ i ≠ 0; simp only [not_not, ne.def] at h1 h2
by_cases h1 : g₁ i ≠ 0; by_cases h2 : g₂ i ≠ 0
by_cases h1 : g₁ i ≠ 0
by_cases h2 : g₂ i ≠ 0
simp only [not_not, ne.def] at h1 h2
simp [h1, h2, hf]
simp only [not_not, ne.def] at h1 h2
simp [h1, h2, hf]
by_cases h2 : g₂ i ≠ 0
simp only [not_not, ne.def] at h1 h2
simp [h1, h2, hf]
simp only [not_not, ne.def] at h1 h2
simp [h1, h2, hf]
intros
delta bind bind._proof_1; cases f a.out; refl
delta bind bind._proof_1; cases f a.out
delta bind bind._proof_1
cases f a.out
refl
intros
refine insert_nth_eq_iff.2 ⟨by simp, _⟩
ext j
convert (cons_succ _ _ _).symm
intros
{ cases k, refl }
cases k
refl
intros
{ ext, apply zero_add }
ext
apply zero_add
intros
rw [← card_disjoint_union sdiff_disjoint, sdiff_union_self_eq_union]
intros
ext
simp [or.comm]
{ ext i, simp }
ext i
simp
intros
rw [←with_bot.coe_lt_coe, coe_sup', sup_lt_iff (with_bot.bot_lt_coe a)]
exact ball_congr (λ b hb, with_bot.coe_lt_coe)
intros
induction s using quotient.induction_on
simp
intros
rw [to_multiset_apply, sum_single_index]; apply zero_nsmul
rw [to_multiset_apply, sum_single_index]
apply zero_nsmul
intros
{ ext, simp [finset.mem_powerset_len] }
ext
simp [finset.mem_powerset_len]
intros
rw [subtype.ext_iff, fintype.choose_spec (λ (y : {a : α // p a}), (y : α) = x) _]
intros
rw [← fin.succ_above_zero, fin.image_succ_above_univ]
intros
simp [bijective, injective_iff_surjective]
intros
subst eq; refl
subst eq
refl
intros
cases m with m m; cases n with n n; unfold has_add.add; simp [int.add, -of_nat_eq_coe, bool.bxor_comm]
cases m with m m; cases n with n n; unfold has_add.add
cases m with m m; cases n with n n
cases m with m m
cases n with n n
unfold has_add.add
simp [int.add, -of_nat_eq_coe, bool.bxor_comm]
unfold has_add.add
simp [int.add, -of_nat_eq_coe, bool.bxor_comm]
cases n with n n
unfold has_add.add
simp [int.add, -of_nat_eq_coe, bool.bxor_comm]
unfold has_add.add
simp [int.add, -of_nat_eq_coe, bool.bxor_comm]
intros
cases n
cases n; refl
refl
refl
intros
{ rw [int.lcm], apply nat.lcm_zero_left }
rw [int.lcm]
apply nat.lcm_zero_left
intros
cases mod_two_eq_zero_or_one m with h₁ h₁; cases mod_two_eq_zero_or_one n with h₂ h₂; simp [even_iff, h₁, h₂, int.mul_mod]; norm_num
cases mod_two_eq_zero_or_one m with h₁ h₁; cases mod_two_eq_zero_or_one n with h₂ h₂; simp [even_iff, h₁, h₂, int.mul_mod]
cases mod_two_eq_zero_or_one m with h₁ h₁; cases mod_two_eq_zero_or_one n with h₂ h₂
cases mod_two_eq_zero_or_one m with h₁ h₁
cases mod_two_eq_zero_or_one n with h₂ h₂
simp [even_iff, h₁, h₂, int.mul_mod]
simp [even_iff, h₁, h₂, int.mul_mod]
cases mod_two_eq_zero_or_one n with h₂ h₂
simp [even_iff, h₁, h₂, int.mul_mod]
simp [even_iff, h₁, h₂, int.mul_mod]
norm_num
intros
induction L; [refl, simp only [*, join, map, map_append]]
induction L
refl
simp only [*, join, map, map_append]
intros
simp
intros
induction l generalizing f
{ exact hf }
exact hf
apply l_ih (λ _ h, hl _ (list.mem_cons_of_mem _ h))
{ apply l_ih (λ _ h, hl _ (list.mem_cons_of_mem _ h)), apply function.injective.comp hf, apply hl _ (list.mem_cons_self _ _) }
apply function.injective.comp hf
apply hl _ (list.mem_cons_self _ _)
intros
simp only [mem_singleton, forall_eq]
intros
rw [← length_eq_zero, length_pmap, length_eq_zero]
intros
induction l with hd tl hl generalizing x
cases x; simp [option.to_list]
cases x
{ cases x; simp [option.to_list] }
simp [option.to_list]
simp [option.to_list]
simp only [concat_eq_append, reduce_option_append] at hl
{ simp only [concat_eq_append, reduce_option_append] at hl, cases hd; simp [hl, reduce_option_append] }
cases hd; simp [hl, reduce_option_append]
cases hd
simp [hl, reduce_option_append]
simp [hl, reduce_option_append]
intros
induction l with hd tl IH
{ simp }
simp
{ simpa }
simpa
intros
simp
intros
induction is with t is ih generalizing is'
simp
{simp}
simp [foldr_permutations_aux2, ih, bind_map]
congr' 2
funext ys
rw [map_permutations_aux2]
simp only [← permutations_aux2_comp_append] {single_pass := tt}
simp only [id, append_assoc]
intros
induction l₂ generalizing l₁; [refl, simp only [foldl_cons, map_erase finj, *]]
induction l₂ generalizing l₁
refl
simp only [foldl_cons, map_erase finj, *]
intros
simp only [chain'_singleton, chain'_cons, and_true]
intros
simp only [neg, length_map]
intros
cases le_total n l with hnl hln
rw [← append_consecutive hnl hlm, filter_append, filter_lt_of_top_le (le_refl l), filter_lt_of_le_bot (le_refl l), append_nil]
{ rw [← append_consecutive hnl hlm, filter_append, filter_lt_of_top_le (le_refl l), filter_lt_of_le_bot (le_refl l), append_nil] }
{ rw [eq_nil_of_le hln, filter_lt_of_le_bot hln] }
rw [eq_nil_of_le hln, filter_lt_of_le_bot hln]
intros
induction l with y l IH
{ simp }
simp
specialize IH (λ x hx, h x (mem_cons_of_mem _ hx))
{ specialize IH (λ x hx, h x (mem_cons_of_mem _ hx)), have hy : y ≤ n := h y (mem_cons_self _ _), simpa [hy] using IH }
have hy : y ≤ n := h y (mem_cons_self _ _)
simpa [hy] using IH
intros
classical
refine pairwise_of_reflexive_on_dupl_of_forall_ne _ h
intros x hx
rw nodup_iff_count_le_one at hl
exact absurd (hl x) hx.not_le
intros
simp only [range_eq_range', range'_subset_right]
intros
obtain ⟨iy, hiy, rfl⟩ := nth_le_of_mem hy
obtain ⟨ix, hix, rfl⟩ := nth_le_of_mem hx
rw [nth_le_take', nth_le_drop']
rw length_take at hix
exact h.rel_nth_le_of_lt _ _ (ix.lt_add_right _ _ (lt_min_iff.mp hix).left)
intros
induction l generalizing init tail; simp_rw [tails, inits, zip_cons_cons]
induction l generalizing init tail
simp_rw [tails, inits, zip_cons_cons]
{ simp }
simp
simp_rw [tails, inits, zip_cons_cons]
split; rw [mem_cons_iff, zip_map_left, mem_map, prod.exists]
split
{ split; rw [mem_cons_iff, zip_map_left, mem_map, prod.exists], { rintros (⟨rfl, rfl⟩ | ⟨_, _, h, rfl, rfl⟩), { simp }, { simp [l_ih.mp h], }, }, { cases init, { simp }, { intro h, right, use [init_tl, tail], simp * at *, }, }, }
rw [mem_cons_iff, zip_map_left, mem_map, prod.exists]
rintros (⟨rfl, rfl⟩ | ⟨_, _, h, rfl, rfl⟩)
{ rintros (⟨rfl, rfl⟩ | ⟨_, _, h, rfl, rfl⟩), { simp }, { simp [l_ih.mp h], }, }
{ simp }
simp
{ simp [l_ih.mp h], }
simp [l_ih.mp h]
rw [mem_cons_iff, zip_map_left, mem_map, prod.exists]
cases init
{ cases init, { simp }, { intro h, right, use [init_tl, tail], simp * at *, }, }
{ simp }
simp
intro h
{ intro h, right, use [init_tl, tail], simp * at *, }
right
use [init_tl, tail]
simp * at *
intros
ext i j; refl
ext i j
refl
intros
by_cases i' = i
{ rw [h, update_row_self, if_pos rfl] }
rw [h, update_row_self, if_pos rfl]
{ rwa [update_row_ne h, if_neg h] }
rwa [update_row_ne h, if_neg h]
intros
simp [dot_product]
intros
{ ext, apply dot_product_smul }
ext
apply dot_product_smul
intros
rw [matrix_eq_sum_std_basis M, ← finset.sum_product']
apply finset.sum_induction _ _ h_add h_zero
{ intros, apply h_std_basis, }
intros
apply h_std_basis
intros
ext i j
rcases i
rcases i; rcases j; refl
rcases i; rcases j
rcases j
refl
refl
rcases j
refl
refl
intros
simp [dot_product, fin.sum_univ_succ, vec_head, vec_tail]
intros
simp [countp_eq_card_filter, card_pos_iff_exists_mem]
intros
conv_rhs { rw ←coe_to_list s, }
rw coe_prod
intros
rw [← fold_add op, union_add_inter, fold_add op]
intros
simp [nodup_add, d₁, d₂]
intros
{ rw [ne.def, eq_zero_iff], push_neg, }
rw [ne.def, eq_zero_iff]
push_neg
intros
rw [C_dvd_iff_dvd_coeff, mv_polynomial.ext_iff]
simp only [coeff_map, coeff_zero, hr]
intros
simp only [monomial_eq, alg_hom.map_mul, bind₁_C_right, finsupp.prod, alg_hom.map_prod, alg_hom.map_pow, bind₁_X_right]
intros
simp [supported_equiv_mv_polynomial]
intros
rw [vars_monomial hr, finsupp.support_single_ne_zero he]
intros
rw [←nat.mod_add_div a c, ←nat.mod_add_div b c, ←h, ←nat.sub_sub, nat.add_sub_cancel_left, ←nat.mul_sub_left_distrib, nat.mul_mod_right]
intros
rw add_comm
exact add_pos_left h m
intros
rw [mul_comm c, mod_mul_right_div_self]
intros
rw [← cast_one, cast_le]
intros
cases b
{ cases h, }
cases h
cases b
{ cases b, { norm_num at h, }, { cases y, { norm_num at w', simp [w, w'], }, dsimp [digits], rw digits_aux_def, { congr, { simp [nat.add_mod, nat.mod_eq_of_lt w], }, { simp [mul_comm (b+2), nat.add_mul_div_right, nat.div_eq_of_lt w], } }, { apply nat.succ_pos, }, }, }
{ norm_num at h, }
norm_num at h
cases y
{ cases y, { norm_num at w', simp [w, w'], }, dsimp [digits], rw digits_aux_def, { congr, { simp [nat.add_mod, nat.mod_eq_of_lt w], }, { simp [mul_comm (b+2), nat.add_mul_div_right, nat.div_eq_of_lt w], } }, { apply nat.succ_pos, }, }
norm_num at w'
{ norm_num at w', simp [w, w'], }
simp [w, w']
dsimp [digits]
rw digits_aux_def
congr
{ congr, { simp [nat.add_mod, nat.mod_eq_of_lt w], }, { simp [mul_comm (b+2), nat.add_mul_div_right, nat.div_eq_of_lt w], } }
simp [nat.add_mod, nat.mod_eq_of_lt w]
{ simp [nat.add_mod, nat.mod_eq_of_lt w], }
simp [mul_comm (b+2), nat.add_mul_div_right, nat.div_eq_of_lt w]
{ simp [mul_comm (b+2), nat.add_mul_div_right, nat.div_eq_of_lt w], }
{ apply nat.succ_pos, }
apply nat.succ_pos
intros
have t := zmodeq_of_digits_digits 11 10 (-1 : ℤ) (by unfold int.modeq; norm_num) n
rwa of_digits_neg_one at t
intros
simp only [lt_def, forall_prop_of_true, get_coe', dom_coe]
intros
rw coe_lt_iff
intro h'
rw find_get
have := @nat.find_spec P _ h'
contrapose! this
exact h _ this
intros
delta lcm; rw [one_mul, gcd_one_left, nat.div_one]
delta lcm
rw [one_mul, gcd_one_left, nat.div_one]
intros
rw gcd_comm; apply gcd_eq_left_iff_dvd
rw gcd_comm
apply gcd_eq_left_iff_dvd
intros
rw [←not_le, pow_le_iff_le_log hb hx, not_le]
exact lt_succ_self _
intros
unfold modeq at *; rw [mul_mod_mul_left, mul_mod_mul_left, h]
unfold modeq at *
rw [mul_mod_mul_left, mul_mod_mul_left, h]
intros
rw [even_sub h, even_iff_not_odd, even_iff_not_odd, not_iff_not]
intros
{ rw [sq, sq], exact nat.mul_self_sub_mul_self_eq a b }
rw [sq, sq]
exact nat.mul_self_sub_mul_self_eq a b
intros
by_cases n1 : n = 1; [exact n1.symm ▸ dec_trivial, exact (min_fac_prime n1).pos]
by_cases n1 : n = 1
exact n1.symm ▸ dec_trivial
exact (min_fac_prime n1).pos
intros
simp [nat.min_fac_eq, show 2 ∣ bit0 n, by simp [bit0_eq_two_mul n]]
intros
simpa only [pow_two] using exists_mul_self x
intros
rw [← zneg_zneg (succ (-n)), zneg_succ, zneg_zneg]
intros
simp only [eq_none_iff_forall_not_mem, not_exists, not_and, mem_def, bind_eq_some']
intros
cases x; refl
cases x
refl
refl
intros
rw [balance_l_eq_balance' hl hr sl sr H, all_balance']
intros
revert h
generalize h : (M.mk ⟨a,f⟩) = x
intros h'
cases h'
subst x
have := mk_inj ‹_›
cases this
cases this
assumption
intros
simp only [single_apply, eq_comm]; congr
simp only [single_apply, eq_comm]
intros
rw[coe_prod, to_of_nat_multiset]
intros
let ha : u.r + u.b * u.q = u.a := u.rq_eq
let hr : (u.r - 1) + 1 = u.r := (add_comm _ 1).trans (nat.add_sub_of_le (nat.pos_of_ne_zero hr))
ext
change ((u.y * u.q + u.z) * u.b + u.y * (u.r - 1 + 1) : ℕ) = u.y * u.a + u.z * u.b
{ change ((u.y * u.q + u.z) * u.b + u.y * (u.r - 1 + 1) : ℕ) = u.y * u.a + u.z * u.b, rw [← ha, hr], ring }
rw [← ha, hr]
ring
change ((u.w * u.q + u.x) * u.b + u.w * (u.r - 1 + 1) : ℕ) = u.w * u.a + u.x * u.b
{ change ((u.w * u.q + u.x) * u.b + u.w * (u.r - 1 + 1) : ℕ) = u.w * u.a + u.x * u.b, rw [← ha, hr], ring }
rw [← ha, hr]
ring
intros
rw [X_pow_mul, monomial_mul_X_pow]
intros
{ rcases p, rcases q, simp [coeff, add_to_finsupp] }
rcases p
rcases q
simp [coeff, add_to_finsupp]
intros
induction k with k ih generalizing p
{ simp, }
simp
{ simp [ih], }
simp [ih]
intros
simp [not_mem_support_iff]
intros
rw [← C_1, C_comp]
intros
simp [←coeff_zero_eq_eval_zero]
intros
simp_rw [is_unit_iff_degree_eq_zero, degree_map]
intros
simp only [coe_map_ring_hom, lifts, ring_hom.mem_srange]
intros
rw [is_unit_iff_dvd_one, is_unit_iff_dvd_one]
split
rintros ⟨g, hg⟩
{ rintros ⟨g, hg⟩, replace hg := congr_arg (eval 0) hg, rw [eval_one, eval_mul, eval_C] at hg, exact ⟨g.eval 0, hg⟩ }
replace hg := congr_arg (eval 0) hg
rw [eval_one, eval_mul, eval_C] at hg
exact ⟨g.eval 0, hg⟩
rintros ⟨y, hy⟩
{ rintros ⟨y, hy⟩, exact ⟨C y, by rw [← C_mul, ← hy, C_1]⟩ }
exact ⟨C y, by rw [← C_mul, ← hy, C_1]⟩
intros
have := liftr_map_last R x f id hh
rwa [append_fun_id_id,mvfunctor.id_map] at this
intros
refine iff.trans _ quotient.eq
rw quotient.out_eq x
intros
rw [mk_lt] {md := tactic.transparency.semireducible}
exact const_lt
intros
rw [← @ennreal.mul_le_mul_left _ a _ hr₀ hr₁, ← mul_assoc, mul_inv_cancel hr₀ hr₁, one_mul]
intros
{ rw [coe_nnreal_eq], refl }
rw [coe_nnreal_eq]
refl
intros
rw [add_comm, infi_add]; simp [add_comm]
rw [add_comm, infi_add]
simp [add_comm]
intros
simp only [nonpos_iff_eq_zero.symm, max_le_iff]
intros
split
{ rintro rfl, exact ereal.coe_lt_top }
rintro rfl
exact ereal.coe_lt_top
contrapose!
{ contrapose!, intro h, exact ⟨x.to_real, le_coe_to_real h⟩, }
intro h
exact ⟨x.to_real, le_coe_to_real h⟩
intros
rw [is_st_real_iff_eq, is_st_real_iff_eq, eq_comm]
intros
simpa only [mul_zero] using is_st_mul hx hy
intros
simp [nnreal.coe_le_coe.symm, real.to_nnreal, hp]
intros
by_cases hx : 0 ≤ x
nth_rewrite 0 ← real.coe_to_nnreal x hx
{ nth_rewrite 0 ← real.coe_to_nnreal x hx, rw [←nnreal.coe_inv, real.to_nnreal_coe], }
rw [←nnreal.coe_inv, real.to_nnreal_coe]
have hx' := le_of_not_ge hx
{ have hx' := le_of_not_ge hx, rw [to_nnreal_eq_zero.mpr hx', inv_zero, to_nnreal_eq_zero.mpr (inv_nonpos.mpr hx')], }
rw [to_nnreal_eq_zero.mpr hx', inv_zero, to_nnreal_eq_zero.mpr (inv_nonpos.mpr hx')]
intros
obtain hn | rfl | hp := lt_trichotomy z (0 : ℤ)
rw [sign_of_neg (int.cast_lt_zero.mpr hn), int.sign_eq_neg_one_of_neg hn, int.cast_neg, int.cast_one]
{ rw [sign_of_neg (int.cast_lt_zero.mpr hn), int.sign_eq_neg_one_of_neg hn, int.cast_neg, int.cast_one], }
rw [int.cast_zero, sign_zero, int.sign_zero, int.cast_zero]
{ rw [int.cast_zero, sign_zero, int.sign_zero, int.cast_zero], }
rw [sign_of_pos (int.cast_pos.mpr hp), int.sign_eq_one_of_pos hp, int.cast_one]
{ rw [sign_of_pos (int.cast_pos.mpr hp), int.sign_eq_one_of_pos hp, int.cast_one] }
intros
split
simpa only [← sqrt_lt_sqrt_iff (sq_nonneg x), sqrt_sq_eq_abs] using abs_lt.mp
{ simpa only [← sqrt_lt_sqrt_iff (sq_nonneg x), sqrt_sq_eq_abs] using abs_lt.mp }
rw [← abs_lt, ← sq_abs]
{ rw [← abs_lt, ← sq_abs], exact λ h, (lt_sqrt (abs_nonneg x) (sqrt_pos.mp (lt_of_le_of_lt (abs_nonneg x) h)).le).mp h }
exact λ h, (lt_sqrt (abs_nonneg x) (sqrt_pos.mp (lt_of_le_of_lt (abs_nonneg x) h)).le).mp h
intros
cases s with f al; apply subtype.eq; dsimp [tail, think]; rw [stream.tail_cons]
cases s with f al; apply subtype.eq; dsimp [tail, think]
cases s with f al; apply subtype.eq
cases s with f al
apply subtype.eq
dsimp [tail, think]
rw [stream.tail_cons]
intros
have := h1.mem
revert m
apply mem_rec_on this _ (λ s IH, _); intros m h1
apply mem_rec_on this _ (λ s IH, _)
intros m h1
rw [ret_bind]
{ rw [ret_bind], rw h1.len_unique (results_ret _), exact h2 }
rw h1.len_unique (results_ret _)
exact h2
intros m h1
rw [think_bind]
{ rw [think_bind], cases of_results_think h1 with m' h, cases h with h1 e, rw e, exact results_think (IH h1) }
cases of_results_think h1 with m' h
cases h with h1 e
rw e
exact results_think (IH h1)
intros
simp [set.ite]
intros
ext
{ ext, simp only [function.comp_app], apply apply_range_splitting, }
simp only [function.comp_app]
apply apply_range_splitting
intros
simp
intros
simp [← not_nonempty_iff_eq_empty, univ_pi_nonempty_iff]
intros
ext x
{ ext x, split; rintro ⟨a, b, c, ha, hb, hc, rfl⟩; exact ⟨a, b, c, ha, hb, hc, by rw h a ha b hb c hc⟩ }
split; rintro ⟨a, b, c, ha, hb, hc, rfl⟩; exact ⟨a, b, c, ha, hb, hc, by rw h a ha b hb c hc⟩
split; rintro ⟨a, b, c, ha, hb, hc, rfl⟩
split
rintro ⟨a, b, c, ha, hb, hc, rfl⟩
exact ⟨a, b, c, ha, hb, hc, by rw h a ha b hb c hc⟩
rintro ⟨a, b, c, ha, hb, hc, rfl⟩
exact ⟨a, b, c, ha, hb, hc, by rw h a ha b hb c hc⟩
intros
split
{ intro h, exact ⟨fintype_of_univ_finite h⟩ }
intro h
exact ⟨fintype_of_univ_finite h⟩
{ rintro ⟨_i⟩, exactI finite_univ }
rintro ⟨_i⟩
exactI finite_univ
intros
funext x
rw [subtype.ext_iff, maps_to.coe_restrict_apply]
induction n with n ihn generalizing x
{ refl }
refl
{ simp [nat.iterate, ihn] }
simp [nat.iterate, ihn]
intros
{ ext x, by_cases hx : x ∈ s; simp [hx] }
ext x
by_cases hx : x ∈ s
by_cases hx : x ∈ s; simp [hx]
simp [hx]
simp [hx]
intros
rw [← Ioc_diff_right, diff_diff_cancel_left (singleton_subset_iff.2 $ right_mem_Ioc.2 h)]
intros
ext1 x
simp_rw [mem_union, mem_Ico, mem_Ici, min_le_iff]
by_cases hc : c ≤ x
{ tauto }
tauto
have hxb : x < b := (lt_of_not_ge hc).trans_le h₁
{ have hxb : x < b := (lt_of_not_ge hc).trans_le h₁, tauto }
tauto
intros
simp [← Ici_inter_Iic]
intros
simp
intros
simp [← Ioi_inter_Iio, h]
intros
rintros a ⟨⟨hax, haz⟩, hay⟩
simpa [not_and_distrib, hax, le_update_iff, haz _] using hay
intros
simp [sub_eq_add_neg, add_comm]
intros
ext
ext; simp
simp
intros
{ cases x₀, cases x₁, exact sigma.mk.inj_iff }
cases x₀
cases x₁
exact sigma.mk.inj_iff
intros
ext i : 1; cases i; refl
ext i : 1; cases i
ext i : 1
cases i
intros
rw ←v.cons_head_tail
simp only [to_list_cons, to_list_nil, cons_head, eq_self_iff_true, and_self, singleton_tail]
intros
cases n; simp
cases n
simp
simp
intros
have := congr_arg (coe : ℕ → zmod n) (val_coe_unit_coprime u)
rw [← mul_inv_eq_gcd, nat.cast_one] at this
let u' : units (zmod n) := ⟨u, (u : zmod n)⁻¹, this, by rwa mul_comm⟩
have h : u = u'
apply units.ext
{ apply units.ext, refl }
refl
rw h
refl
intros
simpa only [nsmul_eq_mul, add_right_iterate] using (f.commute_add_int m).iterate_pos_le_iff_map_le f.monotone (strict_mono_id.add_const m) hn
intros
rw [← hf.map_eq, map_apply hf.1 hs]
intros
revert hm hn
refine nat.gcd.induction m n (λ n h0 hn, _) (λ m n hm ih hm hn, _)
{ rwa [nat.gcd_zero_left], }
rwa [nat.gcd_zero_left]
rw [nat.gcd_rec]
{ rw [nat.gcd_rec], exact ih (hn.mod hm) hm }
exact ih (hn.mod hm) hm
intros
obtain ⟨S, rfl⟩ := hK
exact induction_on_adjoin_finset S P base (λ K x _ hK, ih K x hK)
intros
split
introI h
{ introI h, exact ⟨⟨finset_basis_index K V, by { convert (finset_basis K V).span_eq, simp }⟩⟩ }
exact ⟨⟨finset_basis_index K V, by { convert (finset_basis K V).span_eq, simp }⟩⟩
rintros ⟨s, hs⟩
{ rintros ⟨s, hs⟩, rw [is_noetherian.iff_dim_lt_omega, ← dim_top, ← hs], exact lt_of_le_of_lt (dim_span_le _) (lt_omega_iff_finite.2 (set.finite_mem_finset s)) }
rw [is_noetherian.iff_dim_lt_omega, ← dim_top, ← hs]
exact lt_of_le_of_lt (dim_span_le _) (lt_omega_iff_finite.2 (set.finite_mem_finset s))
intros
{ ext, refl }
ext
refl
intros
intro ha
refine not_lt_of_ge (minpoly.min A x hamonic ha) _
obtain ⟨hzeroa, b, hb_nunit, prod⟩ := hdvd
have hbmonic : b.monic
rw monic.def
{ rw monic.def, have := monic hx, rwa [monic.def, prod, leading_coeff_mul, monic.def.mp hamonic, one_mul] at this }
have := monic hx
rwa [monic.def, prod, leading_coeff_mul, monic.def.mp hamonic, one_mul] at this
have hzerob : b ≠ 0 := hbmonic.ne_zero
have degbzero : 0 < b.nat_degree
apply nat.pos_of_ne_zero
{ apply nat.pos_of_ne_zero, intro h, have h₁ := eq_C_of_nat_degree_eq_zero h, rw [←h, ←leading_coeff, monic.def.1 hbmonic, C_1] at h₁, rw h₁ at hb_nunit, have := is_unit_one, contradiction }
intro h
have h₁ := eq_C_of_nat_degree_eq_zero h
rw [←h, ←leading_coeff, monic.def.1 hbmonic, C_1] at h₁
rw h₁ at hb_nunit
have := is_unit_one
contradiction
rw [prod, degree_mul, degree_eq_nat_degree hzeroa, degree_eq_nat_degree hzerob]
exact_mod_cast lt_add_of_pos_right _ degbzero
intros
let P : polynomial F → Prop := λ r, r.splits (algebra_map F (r.comp q).splitting_field)
have key1 : ∀ {r : polynomial F}, irreducible r → P r
intros r hr
{ intros r hr, by_cases hr' : nat_degree r = 0, { exact splits_of_nat_degree_le_one _ (le_trans (le_of_eq hr') zero_le_one) }, obtain ⟨x, hx⟩ := exists_root_of_splits _ (splitting_field.splits (r.comp q)) (λ h, hr' ((mul_eq_zero.mp (nat_degree_comp.symm.trans (nat_degree_eq_of_degree_eq_some h))).resolve_right hq)), rw [←aeval_def, aeval_comp] at hx, have h_normal : normal F (r.comp q).splitting_field := splitting_field.normal (r.comp q), have qx_int := normal.is_integral h_normal (aeval x q), exact splits_of_splits_of_dvd _ (minpoly.ne_zero qx_int) (normal.splits h_normal _) ((minpoly.irreducible qx_int).dvd_symm hr (minpoly.dvd F _ hx)) }
by_cases hr' : nat_degree r = 0
exact splits_of_nat_degree_le_one _ (le_trans (le_of_eq hr') zero_le_one)
{ exact splits_of_nat_degree_le_one _ (le_trans (le_of_eq hr') zero_le_one) }
obtain ⟨x, hx⟩ := exists_root_of_splits _ (splitting_field.splits (r.comp q)) (λ h, hr' ((mul_eq_zero.mp (nat_degree_comp.symm.trans (nat_degree_eq_of_degree_eq_some h))).resolve_right hq))
rw [←aeval_def, aeval_comp] at hx
have h_normal : normal F (r.comp q).splitting_field := splitting_field.normal (r.comp q)
have qx_int := normal.is_integral h_normal (aeval x q)
exact splits_of_splits_of_dvd _ (minpoly.ne_zero qx_int) (normal.splits h_normal _) ((minpoly.irreducible qx_int).dvd_symm hr (minpoly.dvd F _ hx))
have key2 : ∀ {p₁ p₂ : polynomial F}, P p₁ → P p₂ → P (p₁ * p₂)
intros p₁ p₂ hp₁ hp₂
{ intros p₁ p₂ hp₁ hp₂, by_cases h₁ : p₁.comp q = 0, { cases comp_eq_zero_iff.mp h₁ with h h, { rw [h, zero_mul], exact splits_zero _ }, { exact false.rec _ (hq (by rw [h.2, nat_degree_C])) } }, by_cases h₂ : p₂.comp q = 0, { cases comp_eq_zero_iff.mp h₂ with h h, { rw [h, mul_zero], exact splits_zero _ }, { exact false.rec _ (hq (by rw [h.2, nat_degree_C])) } }, have key := mul_splits_in_splitting_field_of_mul h₁ h₂ hp₁ hp₂, rwa ← mul_comp at key }
by_cases h₁ : p₁.comp q = 0
cases comp_eq_zero_iff.mp h₁ with h h
{ cases comp_eq_zero_iff.mp h₁ with h h, { rw [h, zero_mul], exact splits_zero _ }, { exact false.rec _ (hq (by rw [h.2, nat_degree_C])) } }
rw [h, zero_mul]
{ rw [h, zero_mul], exact splits_zero _ }
exact splits_zero _
{ exact false.rec _ (hq (by rw [h.2, nat_degree_C])) }
exact false.rec _ (hq (by rw [h.2, nat_degree_C]))
by_cases h₂ : p₂.comp q = 0
cases comp_eq_zero_iff.mp h₂ with h h
{ cases comp_eq_zero_iff.mp h₂ with h h, { rw [h, mul_zero], exact splits_zero _ }, { exact false.rec _ (hq (by rw [h.2, nat_degree_C])) } }
rw [h, mul_zero]
{ rw [h, mul_zero], exact splits_zero _ }
exact splits_zero _
{ exact false.rec _ (hq (by rw [h.2, nat_degree_C])) }
exact false.rec _ (hq (by rw [h.2, nat_degree_C]))
have key := mul_splits_in_splitting_field_of_mul h₁ h₂ hp₁ hp₂
rwa ← mul_comp at key
exact wf_dvd_monoid.induction_on_irreducible p (splits_zero _) (λ _, splits_of_is_unit _) (λ _ _ _ h, key2 (key1 h))
intros
rw [angle_comm, angle_smul_right_of_pos y x hr, angle_comm]
intros
rw [finset.weighted_vsub_apply, finset.weighted_vsub_apply, inner_sum_smul_sum_smul_of_sum_eq_zero _ h₁ _ h₂]
simp_rw [vsub_sub_vsub_cancel_right]
rcongr i₁ i₂; rw dist_eq_norm_vsub V (p₁ i₁) (p₂ i₂)
rcongr i₁ i₂
rw dist_eq_norm_vsub V (p₁ i₁) (p₂ i₂)
rw dist_eq_norm_vsub V (p₁ i₁) (p₂ i₂)
rw dist_eq_norm_vsub V (p₁ i₁) (p₂ i₂)
rw dist_eq_norm_vsub V (p₁ i₁) (p₂ i₂)
intros
rw [orthocenter_eq_monge_point, monge_point_eq_smul_vsub_vadd_circumcenter]
norm_num
intros
rw norm_add_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero
exact inner_eq_zero_iff_angle_eq_pi_div_two x y
intros
simp only [support_eq_inter_preimage, update_r_R]
intros
simp [stereographic']
intros
dsimp [tangent_map]
rw mdifferentiable_at.mfderiv
{ refl }
refl
exact mdifferentiable_at_atlas _ (chart_mem_atlas _ _) h
{ exact mdifferentiable_at_atlas _ (chart_mem_atlas _ _) h }
intros
simp only [mdifferentiable_on, mdifferentiable_within_at_univ] with mfld_simps
{ simp only [mdifferentiable_on, mdifferentiable_within_at_univ] with mfld_simps, refl }
refl
intros
rw [← mfderiv_within_univ, ← fderiv_within_univ]
exact mfderiv_within_eq_fderiv_within
intros
rw [← local_equiv.image_source_eq_target, ← ext_chart_at_map_nhds' I hy]
exact image_mem_map (ext_chart_at_source_mem_nhds' _ _ hy)
intros
rcases p
exact hf.prod_map hg
intros
rw [right_transversals, set.mem_set_of_eq, is_complement_iff_exists_unique]
refine ⟨λ h g, _, λ h g, _⟩
obtain ⟨x, h1, h2⟩ := h g
{ obtain ⟨x, h1, h2⟩ := h g, exact ⟨x.2, (congr_arg (∈ T) (eq_mul_inv_of_mul_eq h1)).mp x.1.2, λ y hy, (prod.ext_iff.mp (h2 ⟨⟨g * y⁻¹, hy⟩, y⟩ (inv_mul_cancel_right g y))).2⟩ }
exact ⟨x.2, (congr_arg (∈ T) (eq_mul_inv_of_mul_eq h1)).mp x.1.2, λ y hy, (prod.ext_iff.mp (h2 ⟨⟨g * y⁻¹, hy⟩, y⟩ (inv_mul_cancel_right g y))).2⟩
obtain ⟨x, h1, h2⟩ := h g
{ obtain ⟨x, h1, h2⟩ := h g, refine ⟨⟨⟨g * x⁻¹, h1⟩, x⟩, inv_mul_cancel_right g x, λ y hy, _⟩, have := h2 y.2 ((congr_arg (∈ T) (eq_mul_inv_of_mul_eq hy)).mp y.1.2), exact prod.ext (subtype.ext (eq_mul_inv_of_mul_eq ((congr_arg _ this).mp hy))) this }
refine ⟨⟨⟨g * x⁻¹, h1⟩, x⟩, inv_mul_cancel_right g x, λ y hy, _⟩
have := h2 y.2 ((congr_arg (∈ T) (eq_mul_inv_of_mul_eq hy)).mp y.1.2)
exact prod.ext (subtype.ext (eq_mul_inv_of_mul_eq ((congr_arg _ this).mp hy))) this
intros
apply free_abelian_group.induction_on x
{ exact add_monoid_hom.map_zero _ }
exact add_monoid_hom.map_zero _
{ intro y, refl }
intro y
refl
{ intros x h, simp only [h, add_monoid_hom.map_neg] }
intros x h
simp only [h, add_monoid_hom.map_neg]
intros x y h₁ h₂
{ intros x y h₁ h₂, simp only [h₁, h₂, add_monoid_hom.map_add] }
simp only [h₁, h₂, add_monoid_hom.map_add]
intros
simp [mul_smul]
intros
rw [sub_eq_add_neg, sub_eq_add_neg, smul_add, smul_neg]
intros
rw [←mul_mk'_one_eq_mk', f.to_map.map_mul, mul_assoc, mul_mk'_one_eq_mk', mk'_self', mul_one]
intros
simp_rw [order_of_eq_order_of_iff, ←f.map_pow, ←f.map_one, hf.eq_iff, iff_self, forall_const]
intros
intros x y h
ext a b
simpa using equiv.congr_fun h ⟨a, b⟩
intros
rw cycle_type_def
congr
rw cycle_factors_finset_eq_finset
exact ⟨h1, h2, h0⟩
intros
rw [is_cycle_fin_rotate.cycle_type, support_fin_rotate, ← fintype.card, fintype.card_fin]
refl
intros
apply le_antisymm
{ exact support_form_perm_le' l }
exact support_form_perm_le' l
intros x hx
{ intros x hx, simp only [finset.mem_coe, mem_to_finset] at hx, obtain ⟨n, hn, rfl⟩ := nth_le_of_mem hx, rw [set.mem_set_of_eq, form_perm_apply_nth_le _ h], intro H, rw nodup_iff_nth_le_inj at h, specialize h _ _ _ _ H, cases (nat.succ_le_of_lt hn).eq_or_lt with hn' hn', { simp only [←hn', nat.mod_self] at h, refine not_exists.mpr h' _, simpa [←h, eq_comm, length_eq_one] using hn' }, { simpa [nat.mod_eq_of_lt hn'] using h } }
simp only [finset.mem_coe, mem_to_finset] at hx
obtain ⟨n, hn, rfl⟩ := nth_le_of_mem hx
rw [set.mem_set_of_eq, form_perm_apply_nth_le _ h]
intro H
rw nodup_iff_nth_le_inj at h
specialize h _ _ _ _ H
cases (nat.succ_le_of_lt hn).eq_or_lt with hn' hn'
simp only [←hn', nat.mod_self] at h
{ simp only [←hn', nat.mod_self] at h, refine not_exists.mpr h' _, simpa [←h, eq_comm, length_eq_one] using hn' }
refine not_exists.mpr h' _
simpa [←h, eq_comm, length_eq_one] using hn'
{ simpa [nat.mod_eq_of_lt hn'] using h }
simpa [nat.mod_eq_of_lt hn'] using h
intros
obtain ⟨m, hm⟩ := exists_pow_eq_self_of_coprime h
exact le_antisymm (support_pow_le σ n) (le_trans (ge_of_eq (congr_arg support hm)) (support_pow_le (σ ^ n) m))
intros
obtain ⟨l, hl, mem_l⟩ := fintype.exists_univ_list α
have l_to_finset : l.to_finset = finset.univ
apply eq_top_iff.mpr
{ apply eq_top_iff.mpr, intros b _, exact list.mem_to_finset.mpr (mem_l b) }
intros b _
exact list.mem_to_finset.mpr (mem_l b)
rw [← prod_prod_extend_right σ hl mem_l, sign.map_list_prod, list.map_map, ← l_to_finset, list.prod_to_finset _ hl]
simp_rw ← λ a, sign_prod_extend_right a (σ a)
intros
refine ⟨λ h H, _, support_swap⟩
subst H
simp only [swap_self, support_refl, insert_singleton_self_eq] at h
have : x ∈ ∅
rw h
{ rw h, exact mem_singleton.mpr rfl }
exact mem_singleton.mpr rfl
simpa
intros
simp [sq]
intros
ext
ext; simp
simp
intros
simp_rw ←hh
exact ((f.lift_of_right_inverse f_inv hf).apply_symm_apply _).symm
intros
{ cases a, simp only [inclusion, coe_mk, monoid_hom.mk'_apply] }
cases a
simp only [inclusion, coe_mk, monoid_hom.mk'_apply]
intros
conv_rhs { rw [←vsub_vadd p1 p2, map_vadd, vadd_vsub] }
intros
split
contrapose
{ contrapose, rw [set.not_nonempty_iff_eq_empty, set.not_nonempty_iff_eq_empty], intro h, simp [h, span_points] }
rw [set.not_nonempty_iff_eq_empty, set.not_nonempty_iff_eq_empty]
intro h
simp [h, span_points]
{ exact λ h, h.mono (subset_span_points _ _) }
exact λ h, h.mono (subset_span_points _ _)
intros
rw vector_span_def
refine le_antisymm _ (submodule.span_mono _)
rw submodule.span_le
{ rw submodule.span_le, rintros v ⟨p1, p2, hp1, hp2, hv⟩, rw ←vsub_sub_vsub_cancel_right p1 p2 p at hv, rw [←hv, set_like.mem_coe, submodule.mem_span], exact λ m hm, submodule.sub_mem _ (hm ⟨p1, hp1, rfl⟩) (hm ⟨p2, hp2, rfl⟩) }
rintros v ⟨p1, p2, hp1, hp2, hv⟩
rw ←vsub_sub_vsub_cancel_right p1 p2 p at hv
rw [←hv, set_like.mem_coe, submodule.mem_span]
exact λ m hm, submodule.sub_mem _ (hm ⟨p1, hp1, rfl⟩) (hm ⟨p2, hp2, rfl⟩)
rintros v ⟨p2, hp2, hv⟩
{ rintros v ⟨p2, hp2, hv⟩, exact ⟨p2, p, hp2, hp, hv⟩ }
exact ⟨p2, p, hp2, hp, hv⟩
intros
simp [centroid_def, affine_combination_map, centroid_weights]
intros
simp only [line_map_apply_module]
exact add_le_add_right (smul_le_smul_of_nonneg ha (sub_nonneg.2 hr)) _
intros
simp only [alternatization_def, smul_apply, sum_apply]
intros
simpa using map_comap_subtype p ⊤
intros
rw [b.equiv_fun_symm_apply, finset.sum_eq_single i]
{ rw [std_basis_same, one_smul] }
rw [std_basis_same, one_smul]
rintros j - hj
{ rintros j - hj, rw [std_basis_ne _ _ _ _ hj, zero_smul] }
rw [std_basis_ne _ _ _ _ hj, zero_smul]
intro
{ intro, have := mem_univ i, contradiction }
have := mem_univ i
contradiction
intros
erw [←alg_hom.map_mul, ring_quot.mk_alg_hom_rel R (rel.of m), alg_hom.commutes]
refl
intros
apply trunc.induction_on tb
{ apply trunc.induction_on tb, intro b, rw [det_aux_def, det_to_matrix_eq_det_to_matrix b b'] }
intro b
rw [det_aux_def, det_to_matrix_eq_det_to_matrix b b']
intros
refine dim_le_of_submodule _ _ _
rw [linear_map.range_comp]
exact linear_map.map_le_range
intros
apply linear_independent_le_span' v i w
rw s
exact le_top
intros
fsplit
intro h
{ intro h, haveI := finite_dimensional_of_finrank (_root_.zero_lt_one.trans_le h.symm.le), exact ⟨basis_unique ι h⟩ }
haveI := finite_dimensional_of_finrank (_root_.zero_lt_one.trans_le h.symm.le)
exact ⟨basis_unique ι h⟩
rintro ⟨b⟩
{ rintro ⟨b⟩, simpa using finrank_eq_card_basis b }
simpa using finrank_eq_card_basis b
intros
rw ←linear_equiv.finrank_eq (submodule.comap_subtype_equiv_of_le hle) at hd
exact le_antisymm hle (submodule.comap_subtype_eq_top.1 (eq_top_of_finrank_eq (le_antisymm (comap (submodule.subtype S₂) S₁).finrank_le hd)))
intros
let P := linear_equiv.fun_congr_left R R (fintype.equiv_fin α)
let Q := linear_equiv.fun_congr_left R R (fintype.equiv_fin β)
exact le_of_fin_injective R ((Q.symm.to_linear_map.comp f).comp P.to_linear_map) (((linear_equiv.symm Q).injective.comp i).comp (linear_equiv.injective P))
intros
rw [← linear_independent_fin_snoc, fin.snoc_init_self]
intros
nontriviality R
exact (linear_independent_subtype_range hf.injective).2 hf
intros
refine ⟨le_sup_left, λ z₁ z₂ hz, _⟩
rw [← add_zero (f _), ← g.map_zero]
refine (sup_apply h _ _ _ _).symm
simpa
intros
rw det_to_block M p
convert upper_two_block_triangular_det (to_block M p p) (to_block M p (λ j, ¬p j)) (to_block M (λ j, ¬p j) (λ j, ¬p j))
ext
exact h ↑i i.2 ↑j j.2
intros
intros v w h
ext k
rw [← circulant_col_zero_eq v, ← circulant_col_zero_eq w, h]
intros
{ intros i j h, simp [ha h] }
intros i j h
simp [ha h]
intros
{ ext, refl }
ext
refl
intros
{ ext, refl }
ext
refl
intros
rw [←trace_transpose, ←trace_transpose_mul, transpose_mul]
intros
{ ext, simp }
ext
simp
intros
tidy
intros
simp only [← coe_ltensor_hom, map_sub]
intros
rw [iterate_succ, (commute.self_iterate f n).comp_eq]
intros
induction hbc
case trans_gen.single : c hbc { exact tail' hab hbc }
case trans_gen.tail : c d hbc hcd hac { exact hac.tail hcd }
intros
simp_rw [prod_apply hs] at h2s
{ simp_rw [prod_apply hs] at h2s, refine ae_lt_top (measurable_measure_prod_mk_left hs) h2s }
refine ae_lt_top (measurable_measure_prod_mk_left hs) h2s
intros
ext1
refine (mem_ℒp.coe_fn_to_Lp _).trans _
refine eventually_eq.trans _ (Lp.coe_fn_smul _ _).symm
rw condexp_ind_smul_smul' hs hμs c x
refine (Lp.coe_fn_smul _ _).trans _
refine (condexp_ind_L1_fin_ae_eq_condexp_ind_smul hm hs hμs x).mono (λ y hy, _)
rw [pi.smul_apply, pi.smul_apply, hy]
intros
symmetry
rw [← sub_eq_zero, ← inner_sub_left, condexp_L2]
simp only [mem_Lp_meas_iff_ae_measurable'.mpr hg, orthogonal_projection_inner_eq_zero]
intros
simpa [has_finite_integral] using hfi
intros
simp only [of_real_norm_eq_coe_nnnorm, edist_eq_coe_nnnorm]
intros
have h_two : ennreal.of_real (2 : ℝ) = 2
simp [zero_le_one]
simp [zero_le_one]
rw [snorm_norm_rpow f zero_lt_two, one_mul, h_two]
exact ennreal.rpow_lt_top_of_nonneg zero_le_two (Lp.snorm_ne_top f)
intros
rw [snorm_eq_snorm' hp_ne_zero hp_ne_top, snorm']
intros
induction l with f l ihl
exact measurable_one
{ exact measurable_one }
rw [list.forall_mem_cons] at hl
rw [list.prod_cons]
exact hl.1.mul (ihl hl.2)
intros
obtain ⟨C, hC⟩ : ∃ C, ∀ᶠ s in (l.lift' powerset), ∀ x ∈ s, ∥f x∥ ≤ C
from hf.imp (λ C hC, eventually_lift'_powerset.2 ⟨_, hC, λ t, id⟩)
rcases (hfm.eventually.and (hμ.eventually.and hC)).exists_measurable_mem_of_lift' with ⟨s, hsl, hsm, hfm, hμ, hC⟩
refine ⟨s, hsl, ⟨hfm, has_finite_integral_restrict_of_bounded hμ _⟩⟩
exact C
rw [ae_restrict_eq hsm, eventually_inf_principal]
exact eventually_of_forall hC
intros
simpa [mul_comm] using integral_deriv_comp_smul_deriv hf hg hf' hg'
intros
rw [← integral_comp_add_left, ← integral_comp_mul_left _ hc]
intros
have A : ∫⁻ a, f a ∂μ = ∫⁻ a, hf.mk f a ∂μ := lintegral_congr_ae hf.ae_eq_mk
have B : ∫⁻ a, r * f a ∂μ = ∫⁻ a, r * hf.mk f a ∂μ := lintegral_congr_ae (eventually_eq.fun_comp hf.ae_eq_mk _)
rw [A, B, lintegral_const_mul _ hf.measurable_mk]
intros
simp only [lintegral, measure.restrict_apply, f.measurable_set_preimage]
intros
calc ∫⁻ (a : α), ((f * g) a) ∂μ ≤ ∫⁻ (a : α), ((f a)^p / ennreal.of_real p + (g a)^q / ennreal.of_real q) ∂μ : lintegral_mono (λ a, young_inequality (f a) (g a) hpq) ... = 1 : begin simp only [div_eq_mul_inv], rw lintegral_add', { rw [lintegral_mul_const'' _ (hf.pow_const p), lintegral_mul_const'' _ (hg.pow_const q), hf_norm, hg_norm, ← div_eq_mul_inv, ← div_eq_mul_inv, hpq.inv_add_inv_conj_ennreal], }, { exact (hf.pow_const _).mul_const _, }, { exact (hg.pow_const _).mul_const _, }, end
intros
rw [← integral_indicator hs, ← integral_indicator (measurable_set_le measurable_const hf)]
exact integral_mono (hfi.indicator hs) (hfi.indicator (measurable_set_le measurable_const hf)) (indicator_le_indicator_nonneg s f)
intros
refine ⟨_, λ hs, ⟨λ t ht, ⟨s, mem_principal_self s, hs, ht⟩⟩⟩
rintros ⟨hs⟩
rcases hs (mem_principal_self s) with ⟨t, ht, htm, hts⟩
have : t = s := subset.antisymm hts ht
rwa ← this
intros
rw [infi, measurable_set_Inf, forall_range_iff]
intros
rintro ⟨K, hK⟩ h2K
{ rintro ⟨K, hK⟩ h2K, rw [mem_Icc], exact ⟨prehaar_nonneg K₀ _, prehaar_le_index K₀ _ hU⟩ }
rw [mem_Icc]
exact ⟨prehaar_nonneg K₀ _, prehaar_le_index K₀ _ hU⟩
intros
rw [← empty_mem_iff_bot, mem_ae_iff, compl_empty, measure_univ_eq_zero]
intros
simp only [← Iic_diff_right, diff_ae_eq_self, measure_mono_null (set.inter_subset_right _ _) (measure_singleton a)]
intros
rw [measure_eq_infi' (map f μ)]
refine le_infi _
rintro ⟨t, hst, ht⟩
convert measure_mono (preimage_mono hst)
exact map_apply hf ht
intros
rw [le_bounded_by, forall_congr]
{ rw [le_bounded_by, forall_congr], intro s, cases s.eq_empty_or_nonempty with h h; simp [h] }
intro s
cases s.eq_empty_or_nonempty with h h
cases s.eq_empty_or_nonempty with h h; simp [h]
simp [h]
simp [h]
intros
by_cases hi : measurable_set i
{ exact (restrict_le_restrict_iff _ _ hi).2 h }
exact (restrict_le_restrict_iff _ _ hi).2 h
rw [restrict_not_measurable v hi, restrict_not_measurable w hi]
{ rw [restrict_not_measurable v hi, restrict_not_measurable w hi], exact le_refl _ }
exact le_refl _
intros
rw ← encodable.Union_decode₂
{ rw ← encodable.Union_decode₂, exact d.has_Union_nat (encodable.Union_decode₂_disjoint_on hd) (λ n, encodable.Union_decode₂_cases d.has_empty h) }
exact d.has_Union_nat (encodable.Union_decode₂_disjoint_on hd) (λ n, encodable.Union_decode₂_cases d.has_empty h)
intros
simp
intros
rw [sum_range_succ_comm, bernoulli'_def n, nat.sub_self]
conv in (n.choose (_ - _)) { rw choose_symm (mem_range.1 H).le }
simp only [one_mul, cast_one, sub_self, sub_add_cancel, choose_zero_right, zero_add, div_one]
intros
dsimp [bit1]
{ dsimp [bit1], simp, }
simp
intros
induction n; simp [cast_eq_of_rat_of_nat]
induction n
simp [cast_eq_of_rat_of_nat]
simp [cast_eq_of_rat_of_nat]
intros
{ simp only [norm, mul_im, mul_re], ring }
simp only [norm, mul_im, mul_re]
ring
intros
{ cases o, exacts [iff.rfl, eq_comm, iff.rfl] }
cases o
exacts [iff.rfl, eq_comm, iff.rfl]
intros
rw [sup_sdiff, sdiff_self, sup_bot_eq]
intros
refine ⟨λ H, ⟨⟨monotone_fst.mem_upper_bounds_image H.1, λ a ha, _⟩, ⟨monotone_snd.mem_upper_bounds_image H.1, λ a ha, _⟩⟩, λ H, ⟨_, _⟩⟩
suffices : (a, p.2) ∈ upper_bounds s
{ suffices : (a, p.2) ∈ upper_bounds s, from (H.2 this).1, exact λ q hq, ⟨ha $ mem_image_of_mem _ hq, (H.1 hq).2⟩ }
from (H.2 this).1
exact λ q hq, ⟨ha $ mem_image_of_mem _ hq, (H.1 hq).2⟩
suffices : (p.1, a) ∈ upper_bounds s
{ suffices : (p.1, a) ∈ upper_bounds s, from (H.2 this).2, exact λ q hq, ⟨(H.1 hq).1, ha $ mem_image_of_mem _ hq⟩ }
from (H.2 this).2
exact λ q hq, ⟨(H.1 hq).1, ha $ mem_image_of_mem _ hq⟩
exact λ q hq, ⟨H.1.1 $ mem_image_of_mem _ hq, H.2.1 $ mem_image_of_mem _ hq⟩
{ exact λ q hq, ⟨H.1.1 $ mem_image_of_mem _ hq, H.2.1 $ mem_image_of_mem _ hq⟩ }
exact λ q hq, ⟨H.1.2 $ monotone_fst.mem_upper_bounds_image hq, H.2.2 $ monotone_snd.mem_upper_bounds_image hq⟩
{ exact λ q hq, ⟨H.1.2 $ monotone_fst.mem_upper_bounds_image hq, H.2.2 $ monotone_snd.mem_upper_bounds_image hq⟩ }
intros
simp_rw [independent, set_independent, set_coe.forall, Sup_eq_supr]
apply forall_congr
intro a
apply forall_congr
intro ha
congr' 2
convert supr_subtype.symm
simp [supr_and]
intros
simpa [classical.em] using @infi_union _ _ _ f {i | p i} {i | ¬ p i}
intros
rw Inf_eq_argmin_on hs
{ rw Inf_eq_argmin_on hs, exact ⟨argmin_on_mem _ _ _ _, λ a ha, argmin_on_le id _ _ ha⟩ }
exact ⟨argmin_on_mem _ _ _ _, λ a ha, argmin_on_le id _ _ ha⟩
intros
choose u hu using h
cases forall_and_distrib.mp hu with hu hu'
exact ⟨u ∘ (nat.rec 0 (λ n v, u v)), strict_mono_nat_of_lt_succ (λ n, hu _), λ n, hu' _⟩
intros
rw ← prod_at_bot_at_bot_eq
{ rw ← prod_at_bot_at_bot_eq, exact tendsto_id.prod_mk tendsto_id }
exact tendsto_id.prod_mk tendsto_id
intros
simp only [hl'.ge_iff, hl.mem_iff]
intros
simpa only [sub_eq_add_neg] using h.add h'.neg
intros
rw [map_comap, subtype.range_coe]
intros
rw mem_inf_principal
filter_upwards [hs]
intros a has hat
exact ⟨has, hat⟩
intros
simpa only [sub_eq_add_neg] using hf.add hg.neg
intros
by_cases h : ∃i, a ∉ s i
rcases h with ⟨i, hi⟩
{ rcases h with ⟨i, hi⟩, refine tendsto_pure.2 ((eventually_ge_at_top i).mono $ assume n hn, _), rw [indicator_of_not_mem _ _, indicator_of_not_mem _ _], { simp only [mem_Inter, not_forall], exact ⟨i, hi⟩ }, { assume h, have := hs hn h, contradiction } }
refine tendsto_pure.2 ((eventually_ge_at_top i).mono $ assume n hn, _)
rw [indicator_of_not_mem _ _, indicator_of_not_mem _ _]
{ simp only [mem_Inter, not_forall], exact ⟨i, hi⟩ }
simp only [mem_Inter, not_forall]
exact ⟨i, hi⟩
{ assume h, have := hs hn h, contradiction }
assume h
have := hs hn h
contradiction
push_neg at h
{ push_neg at h, simp only [indicator_of_mem, h, (mem_Inter.2 h), tendsto_const_pure] }
simp only [indicator_of_mem, h, (mem_Inter.2 h), tendsto_const_pure]
intros
simp only [tendsto_def, mem_prod_same_iff, prod_sub_preimage_iff, exists_prop, iff_self]
intros
revert hu_le
rw [←not_imp_not, not_frequently]
simp_rw ←lt_iff_not_ge
exact λ h, eventually_lt_of_limsup_lt h hu
intros
obtain ⟨g, hr | hnr⟩ := exists_increasing_or_nonincreasing_subseq' r f
refine ⟨g, or.intro_left _ (λ m n mn, _)⟩
{ refine ⟨g, or.intro_left _ (λ m n mn, _)⟩, obtain ⟨x, rfl⟩ := le_iff_exists_add.1 (nat.succ_le_iff.2 mn), induction x with x ih, { apply hr }, { apply is_trans.trans _ _ _ _ (hr _), exact ih (lt_of_lt_of_le m.lt_succ_self (nat.le_add_right _ _)) } }
obtain ⟨x, rfl⟩ := le_iff_exists_add.1 (nat.succ_le_iff.2 mn)
induction x with x ih
{ apply hr }
apply hr
apply is_trans.trans _ _ _ _ (hr _)
{ apply is_trans.trans _ _ _ _ (hr _), exact ih (lt_of_lt_of_le m.lt_succ_self (nat.le_add_right _ _)) }
exact ih (lt_of_lt_of_le m.lt_succ_self (nat.le_add_right _ _))
{ exact ⟨g, or.intro_right _ hnr⟩ }
exact ⟨g, or.intro_right _ hnr⟩
intros
{ ext a b, exact f.map_rel_iff.symm }
ext a b
exact f.map_rel_iff.symm
intros
classical
split
{ exact has_min, }
exact has_min
set counterexamples := { x : α | ¬ acc r x}
{ set counterexamples := { x : α | ¬ acc r x}, intro exists_max, fconstructor, intro x, by_contra hx, obtain ⟨m, m_mem, hm⟩ := exists_max counterexamples ⟨x, hx⟩, refine m_mem (acc.intro _ ( λ y y_gt_m, _)), by_contra hy, exact hm y hy y_gt_m, }
intro exists_max
fconstructor
intro x
by_contra hx
obtain ⟨m, m_mem, hm⟩ := exists_max counterexamples ⟨x, hx⟩
refine m_mem (acc.intro _ ( λ y y_gt_m, _))
by_contra hy
exact hm y hy y_gt_m
intros
simp [mul_antidiagonal]
intros
obtain ⟨n, w⟩ := monotone_stabilizes_iff_artinian.mpr I (f.iterate_range.comp ⟨λ n, n+1, λ n m w, by linarith⟩)
specialize w ((n + 1) + n) (by linarith)
dsimp at w
refine ⟨n + 1, nat.succ_ne_zero _, _⟩
simp_rw [eq_top_iff', mem_sup]
intro x
have : (f^(n + 1)) x ∈ (f ^ ((n + 1) + n + 1)).range
{ rw ← w, exact mem_range_self _ }
rw ← w
exact mem_range_self _
rcases this with ⟨y, hy⟩
use x - (f ^ (n+1)) y
split
rw [linear_map.mem_ker, linear_map.map_sub, ← hy, sub_eq_zero, pow_add]
{ rw [linear_map.mem_ker, linear_map.map_sub, ← hy, sub_eq_zero, pow_add], simp [iterate_add_apply], }
simp [iterate_add_apply]
use (f^ (n+1)) y
{ use (f^ (n+1)) y, simp }
simp
intros
{ rw is_coprime_comm at h ⊢, exact h.of_add_mul_left_left }
rw is_coprime_comm at h ⊢
exact h.of_add_mul_left_left
intros
rw order_of_ne hx
exact x.is_wf_support.min_mem (support_nonempty_iff.2 hx)
intros
rw [is_unit_iff_dvd_one, ← span_singleton_le_span_singleton, span_singleton_one, eq_top_iff]
intros
ext x
split
intro hx
{ intro hx, obtain ⟨y, hy⟩ := quotient.mk_surjective x, rw [ring_hom.mem_ker, ← hy, ideal.quotient.lift_mk, ← ring_hom.mem_ker] at hx, rw [← hy, mem_map_iff_of_surjective I^.quotient.mk quotient.mk_surjective], exact ⟨y, hx, rfl⟩ }
obtain ⟨y, hy⟩ := quotient.mk_surjective x
rw [ring_hom.mem_ker, ← hy, ideal.quotient.lift_mk, ← ring_hom.mem_ker] at hx
rw [← hy, mem_map_iff_of_surjective I^.quotient.mk quotient.mk_surjective]
exact ⟨y, hx, rfl⟩
intro hx
{ intro hx, rw mem_map_iff_of_surjective I^.quotient.mk quotient.mk_surjective at hx, obtain ⟨y, hy⟩ := hx, rw [ring_hom.mem_ker, ← hy.right, ideal.quotient.lift_mk, ← (ring_hom.mem_ker f)], exact hy.left }
rw mem_map_iff_of_surjective I^.quotient.mk quotient.mk_surjective at hx
obtain ⟨y, hy⟩ := hx
rw [ring_hom.mem_ker, ← hy.right, ideal.quotient.lift_mk, ← (ring_hom.mem_ker f)]
exact hy.left
intros
simp only [le_antisymm_iff, le_span_singleton_mul_iff, span_singleton_mul_le_iff]
intros
apply @is_prime_of_is_prime_prod_top _ R
rw ←map_prod_comm_prod
exact map_is_prime_of_equiv _
intros
cases int.prime.dvd_mul hp h with hp2 hpp
apply or.intro_left
{ apply or.intro_left, exact le_antisymm (nat.le_of_dvd zero_lt_two hp2) (nat.prime.two_le hp) }
exact le_antisymm (nat.le_of_dvd zero_lt_two hp2) (nat.prime.two_le hp)
apply or.intro_right
{ apply or.intro_right, rw [sq, int.nat_abs_mul] at hpp, exact (or_self _).mp ((nat.prime.dvd_mul hp).mp hpp)}
rw [sq, int.nat_abs_mul] at hpp
exact (or_self _).mp ((nat.prime.dvd_mul hp).mp hpp)
intros
refine ⟨_, is_jacobson_polynomial_of_is_jacobson⟩
introI H
exact is_jacobson_of_surjective ⟨eval₂_ring_hom (ring_hom.id _) 1, λ x, ⟨C x, by simp only [coe_eval₂_ring_hom, ring_hom.id_apply, eval₂_C]⟩⟩
intros
refine eq.trans _ (congr rfl x.single_order_mul_power_series_part)
rw [← mul_assoc, single_mul_single, neg_add_self, mul_one, ← C_apply, C_one, one_mul, coe_power_series]
intros
rcases hb with ⟨b', hb⟩
use a * b'
rw [←hb, (algebra_map R S).map_mul, algebra.smul_def]
intros
{ unfold has_scalar.smul localization.smul, apply lift_on_mk }
unfold has_scalar.smul localization.smul
apply lift_on_mk
intros
apply multiplicity.multiplicity_eq_zero_of_not_dvd
rwa zero_dvd_iff
intros
split
split; rintros ⟨n, hn⟩; use n; simp only [lmul_right_eq_zero_iff, pow_lmul_right] at ⊢ hn; exact hn
split; rintros ⟨n, hn⟩; use n; simp only [lmul_right_eq_zero_iff, pow_lmul_right] at ⊢ hn
split; rintros ⟨n, hn⟩; use n
split; rintros ⟨n, hn⟩
rintros ⟨n, hn⟩
use n
simp only [lmul_right_eq_zero_iff, pow_lmul_right] at ⊢ hn
exact hn
exact hn
rintros ⟨n, hn⟩
use n
simp only [lmul_right_eq_zero_iff, pow_lmul_right] at ⊢ hn
exact hn
exact hn
intros
rw is_noetherian_iff_well_founded at h ⊢
exact order_embedding.well_founded (submodule.map_subtype.order_embedding N).dual h
intros
rw [← C_1, content_C, normalize_one]
intros
simp [scale_roots, coeff_monomial] {contextual := tt}
intros
apply polynomial.induction_on' p
intros p q hp hq
{ intros p q hp hq, ext, simp [hp, hq, coeff_add, add_apply, std_basis_matrix_add], }
ext
simp [hp, hq, coeff_add, add_apply, std_basis_matrix_add]
intros k x
{ intros k x, simp only [mat_poly_equiv_coeff_apply_aux_1, coeff_monomial], split_ifs; { funext, simp, }, }
simp only [mat_poly_equiv_coeff_apply_aux_1, coeff_monomial]
split_ifs; { funext, simp, }
split_ifs
{ funext, simp, }
funext
{ funext, simp, }
simp
intros
split
intro h
{ intro h, ext n, rw [(coeff R n).map_zero, coeff_of_lt_order], simp [h] }
ext n
rw [(coeff R n).map_zero, coeff_of_lt_order]
simp [h]
{ rintros rfl, exact order_zero }
rintros rfl
exact order_zero
intros
rw [eq_comm, mv_power_series.eq_inv_iff_mul_eq_one h]
intros
simp only [coeff, finsupp.single_add, add_comm n 1]
convert φ.coeff_add_monomial_mul (single () 1) (single () n) _
rw one_mul
intros
obtain ⟨a, nz, rfl⟩ := associates.exists_non_zero_rep h₁
rw [factors_mk _ nz, ← with_top.some_eq_coe, count_some, multiset.le_count_iff_repeat_le, ← factors_le, factors_prime_pow h₂, factors_mk _ nz]
exact with_top.coe_le_coe
intros
by_cases ha0 : a = 0
rw ha0
{ rw ha0, exact dvd_zero p }
exact dvd_zero p
obtain ⟨a0, nza, ha'⟩ := exists_non_zero_rep ha0
rw [← associates.factors_prod a]
rw [← ha', factors_mk a0 nza] at hm ⊢
erw prod_coe
apply multiset.dvd_prod
apply multiset.mem_map.mpr
exact ⟨⟨p, hp⟩, mem_factor_set_some.mp hm, rfl⟩
intros
simp only [truncated_witt_vector, fintype.card_fin, fintype.card_fun]
intros
rw [to_nat_apply_of_lt_omega (nat_lt_omega n), ← nat_cast_inj]
exact (classical.some_spec (lt_omega.1 (nat_lt_omega n))).symm
intros
rw [←ord_lt_ord, ←sup_ord]
{ rw [←ord_lt_ord, ←sup_ord], apply sup_lt_ord _ H1, intro i, rw ord_lt_ord, apply H2 }
apply sup_lt_ord _ H1
intro i
rw ord_lt_ord
apply H2
intros
rw [quot_mul_comm, quot_neg_mul, quot_mul_comm]
intros
intro h
have t := state.right_bound m
rw h at t
exact nat.not_succ_le_zero _ t
intros
rw [subsingleton.elim h (f.trans g)]
{ rw [subsingleton.elim h (f.trans g)], apply principal_seg.lt_top }
apply principal_seg.lt_top
intros
simpa only [mul_succ] using lt_mul_succ_div a h
intros
{ cases x, cases y, rw mk_le_mk, refl }
cases x
cases y
rw mk_le_mk
refl
intros
{ cases x, refl }
cases x
refl
intros
rw [sub_eq_add_neg, h]
intros
simp
intros
simpa [normalize_fin_lt] using h
intros
apply val_except_eq_val_except update_eq_of_ne (get_set_eq_of_ne _)
intros
simp only [val]
by_cases h1 : m = 1
rw [if_pos h1, h1, one_mul]
rw [if_neg h1, mul_comm]
intros
simp [add_const]
cases k; simp! *
cases k
simp! *
simp! *
simp [show znum.pos k ≠ 0, from dec_trivial]
induction e with n a x n b A B; simp *
induction e with n a x n b A B
simp *
rcases cs with ⟨n, rfl⟩
{ rcases cs with ⟨n, rfl⟩, refine ⟨⟨n + num.pos k, by simp [add_comm]; refl⟩, _⟩, cases n; simp! }
refine ⟨⟨n + num.pos k, by simp [add_comm]; refl⟩, _⟩
cases n; simp!
cases n
simp!
simp!
simp *
rcases B cs.2 with ⟨csb, h⟩
{ rcases B cs.2 with ⟨csb, h⟩, simp! [*, cs.1], rw [← tactic.ring.horner_add_const, add_comm], rw add_comm }
simp! [*, cs.1]
rw [← tactic.ring.horner_add_const, add_comm]
rw add_comm
intros
simp
intros
rw [bInter_eq_Inter]
haveI := hs.to_encodable
exact is_Gδ_Inter (λ x, ht x x.2)
intros
apply is_open_map.of_inverse (homothety_continuous x t⁻¹)
apply is_open_map.of_inverse (homothety_continuous x t⁻¹); intros e; simp [← affine_map.comp_apply, ← homothety_mul, ht]
apply is_open_map.of_inverse (homothety_continuous x t⁻¹); intros e
intros e
simp [← affine_map.comp_apply, ← homothety_mul, ht]
intros e
simp [← affine_map.comp_apply, ← homothety_mul, ht]
intros
simpa [← hs.compl_eq] using (has_sum_subtype_iff_indicator.1 ha).add (has_sum_subtype_iff_indicator.1 hb)
intros
convert has_sum_zero
intros
rcases h with ⟨f, hf⟩
have : ker (id R M - (subtype_val p).comp f) = p := linear_map.ker_id_sub_eq_of_proj hf
exact this ▸ (is_closed_ker _)
intros
convert is_closed_closure
intros
rw mem_nhds_within_Ioi_iff_exists_Ioo_subset
split
rintros ⟨u, au, as⟩
{ rintros ⟨u, au, as⟩, rcases exists_between au with ⟨v, hv⟩, exact ⟨v, hv.1, λx hx, as ⟨hx.1, lt_of_le_of_lt hx.2 hv.2⟩⟩ }
rcases exists_between au with ⟨v, hv⟩
exact ⟨v, hv.1, λx hx, as ⟨hx.1, lt_of_le_of_lt hx.2 hv.2⟩⟩
rintros ⟨u, au, as⟩
{ rintros ⟨u, au, as⟩, exact ⟨u, au, subset.trans Ioo_subset_Ioc_self as⟩ }
exact ⟨u, au, subset.trans Ioo_subset_Ioc_self as⟩
intros
simpa [(∘)] using tendsto_neg_at_bot_at_top.comp ((tendsto_neg_at_bot_at_top.comp hf).at_top_mul_neg hC hg)
intros
have : ((λx:β×β, x.2 - x.1) ∘ (λx:α×α, (f x.1, f x.2))) = (λx:α×α, f (x.2 - x.1))
{ simp only [f.map_sub] }
simp only [f.map_sub]
rw [uniform_continuous, uniformity_eq_comap_nhds_zero α, uniformity_eq_comap_nhds_zero β, tendsto_comap_iff, this]
exact tendsto.comp h tendsto_comap
intros
refine is_topological_basis_of_open_of_nhds (λ u hu, _) _
simp only [mem_Union, mem_image] at hu
{ simp only [mem_Union, mem_image] at hu, rcases hu with ⟨i, s, sb, rfl⟩, exact (Uo i).is_open_map_subtype_coe _ ((hb i).is_open sb) }
rcases hu with ⟨i, s, sb, rfl⟩
exact (Uo i).is_open_map_subtype_coe _ ((hb i).is_open sb)
intros a u ha uo
{ intros a u ha uo, rcases Union_eq_univ_iff.1 Uc a with ⟨i, hi⟩, lift a to ↥(U i) using hi, rcases (hb i).exists_subset_of_mem_open (by exact ha) (uo.preimage continuous_subtype_coe) with ⟨v, hvb, hav, hvu⟩, exact ⟨coe '' v, mem_Union.2 ⟨i, mem_image_of_mem _ hvb⟩, mem_image_of_mem _ hav, image_subset_iff.2 hvu⟩ }
rcases Union_eq_univ_iff.1 Uc a with ⟨i, hi⟩
lift a to ↥(U i) using hi
rcases (hb i).exists_subset_of_mem_open (by exact ha) (uo.preimage continuous_subtype_coe) with ⟨v, hvb, hav, hvu⟩
exact ⟨coe '' v, mem_Union.2 ⟨i, mem_image_of_mem _ hvb⟩, mem_image_of_mem _ hav, image_subset_iff.2 hvu⟩
intros
simp only [frontier_eq_closure_inter_closure, compl_inter, closure_union]
convert inter_subset_inter_left _ (closure_inter_subset_inter_closure s t)
simp only [inter_distrib_left, inter_distrib_right, inter_assoc]
congr' 2
apply inter_comm
intros
rw [nhds_prod_eq, filter.prod_comm, nhds_prod_eq]
rw [nhds_prod_eq, filter.prod_comm, nhds_prod_eq]; refl
refl
intros
{ ext, simp, }
ext
simp
intros
have w := mem_closure_iff_frequently.mp (continuous_map_mem_subalgebra_closure_of_separates_points A w f)
rw metric.nhds_basis_ball.frequently_iff at w
obtain ⟨g, H, m⟩ := w ε pos
rw [metric.mem_ball, dist_eq_norm] at H
exact ⟨⟨g, m⟩, H⟩
intros
rw [nhds_within, principal_univ, inf_top_eq]
intros
letI := a.total_space_topology
refine is_open_supr_iff.mpr (λ y, is_open_coinduced.mpr (is_open_induced_iff.mpr ⟨(a.pretrivialization_at x).target, (a.pretrivialization_at x).open_target, _⟩))
rw [pretrivialization.set_symm, restrict, (a.pretrivialization_at x).target_eq, (a.pretrivialization_at x).source_eq, preimage_comp, subtype.preimage_coe_eq_preimage_coe_iff, (a.pretrivialization_at y).target_eq, prod_inter_prod, inter_univ, pretrivialization.preimage_symm_proj_inter]
intros
{ rw ← has_sum_iff_tendsto_nat, exact ennreal.summable.has_sum }
rw ← has_sum_iff_tendsto_nat
exact ennreal.summable.has_sum
intros
have h_f_coe : f = λ n, real.to_nnreal (f n : ℝ)
from funext (λ n, real.to_nnreal_coe.symm)
rw [h_f_coe, ← @real.to_nnreal_coe 0]
exact tendsto_of_real ((summable_coe.mpr hf).tendsto_cofinite_zero)
intros
ext
ext; simp
simp
simp
simp
intros
cases S.eq_empty_or_nonempty with h h
{ simp [h] }
simp [h]
rcases hS.exists_surjective h with ⟨f, hf⟩
{ rcases hS.exists_surjective h with ⟨f, hf⟩, have F : ∀n, f n ∈ S := λn, by rw hf; exact mem_range_self _, rw [hf, sInter_range], exact dense_Inter_of_open_nat (λn, ho _ (F n)) (λn, hd _ (F n)) }
have F : ∀n, f n ∈ S := λn, by rw hf; exact mem_range_self _
rw [hf, sInter_range]
exact dense_Inter_of_open_nat (λn, ho _ (F n)) (λn, hd _ (F n))
intros
simp only [diam, emetric.diam_pair, dist_edist]
intros
apply diam_le (λ x hx y hy, edist_pi_le_iff.mpr _)
rw [mem_univ_pi] at hx hy
exact λ b, diam_le_iff.1 (h b) (x b) (hx b) (y b) (hy b)
intros
rw Hausdorff_edist
intros
cases s.eq_empty_or_nonempty with h h
{ simp [h] }
simp [h]
{ simp [Hausdorff_dist, Hausdorff_edist_empty h] }
simp [Hausdorff_dist, Hausdorff_edist_empty h]
intros
rw [← image_symm, diam_image]
intros
rw continuous_def
rintros s ⟨t, ht, s_eq⟩
simpa [← s_eq] using continuous_def.1 h t ht
intros
simp only [continuous_on, continuous_within_at_iff_lower_upper_semicontinuous_within_at]
exact ⟨λ H, ⟨λ x hx, (H x hx).1, λ x hx, (H x hx).2⟩, λ H x hx, ⟨H.1 x hx, H.2 x hx⟩⟩
intros
dsimp [res, left_res, right_res]
ext
simp only [limit.lift_π, limit.lift_π_assoc, fan.mk_π_app, category.assoc]
rw [←F.map_comp]
rw [←F.map_comp]
congr
intros
induction n with n ihn generalizing c
{ exact indicator_of_not_mem (λ hU, hU $ c.subset hx) _ }
exact indicator_of_not_mem (λ hU, hU $ c.subset hx) _
simp only [approx]
{ simp only [approx], rw [ihn, ihn, midpoint_self], exacts [c.subset_right_C hx, hx] }
rw [ihn, ihn, midpoint_self]
exacts [c.subset_right_C hx, hx]
intros
rw [← stream.eta (map f (a :: s)), map_eq]
refl
intros
cases b; simp
cases b
simp
simp
intros
rw [int.sub_eq_add_neg, ← int.neg_add]; refl
rw [int.sub_eq_add_neg, ← int.neg_add]
refl
intros
rw [← int.add_assoc, int.add_left_neg, int.zero_add]
intros
have h := int.add_lt_add_left h a
rwa [← int.add_sub_assoc, int.add_comm a c, int.add_sub_cancel] at h
intros
rw [qsort, well_founded.fix_eq, qsort.F]
induction e : partition (λ x, lt h x = tt) t with large small
simp [e]
rw [e]
intros
rw [nat.add_comm, add_mod_right]
intros
simp [← not_le]
apply not_iff_not_of_iff
apply le_div_iff_mul_le _ _ Hk
intros
rw [←add_right_inj (p2 -ᵥ p1 : G), vsub_add_vsub_cancel, ←neg_vsub_eq_vsub_rev, vadd_vsub, ←add_sub_assoc, ←neg_vsub_eq_vsub_rev, neg_add_self, zero_sub]
intros
rw [←(one_smul A m), ←smul_assoc, algebra.smul_def, mul_one, one_smul]
intros
{ ext, simp }
ext
simp
intros
simp [sum_ite]
intros
by_cases hg : (mul_support $ g ∘ plift.down).finite
exact f.map_finprod_plift g hg
{ exact f.map_finprod_plift g hg }
rw [finprod, dif_neg, f.map_one, finprod, dif_neg]
exacts [infinite.mono (λ x hx, mt (hf (g x.down)) hx) hg, hg]
intros
rcases lt_trichotomy a 0 with h|rfl|h
rw [← neg_eq_zero, ← int.cast_neg, ← dvd_neg]
{ rw [← neg_eq_zero, ← int.cast_neg, ← dvd_neg], lift -a to ℕ using neg_nonneg.mpr (le_of_lt h) with b, rw [int.cast_coe_nat, char_p.cast_eq_zero_iff R p, int.coe_nat_dvd] }
lift -a to ℕ using neg_nonneg.mpr (le_of_lt h) with b
rw [int.cast_coe_nat, char_p.cast_eq_zero_iff R p, int.coe_nat_dvd]
{ simp only [int.cast_zero, eq_self_iff_true, dvd_zero] }
simp only [int.cast_zero, eq_self_iff_true, dvd_zero]
lift a to ℕ using (le_of_lt h) with b
{ lift a to ℕ using (le_of_lt h) with b, rw [int.cast_coe_nat, char_p.cast_eq_zero_iff R p, int.coe_nat_dvd] }
rw [int.cast_coe_nat, char_p.cast_eq_zero_iff R p, int.coe_nat_dvd]
intros
rw [← mul_two, mul_div_cancel a two_ne_zero']
intros
simp [nth_cont_eq_succ_nth_cont_aux, (second_continuant_aux_eq zeroth_s_eq)]
intros
simpa only [one_mul] using mul_div_cancel 1 a0
intros
simpa only [← @div_self _ _ b h] using (div_sub_div_same b a b).symm
intros
{ ext, simp [ceil_le] }
ext
simp [ceil_le]
intros
simpa only [lcm_comm b a] using lcm_eq_left_iff b a h
intros
rw [← lcm_erase_dup, erase_dup_ext.2, lcm_erase_dup, lcm_add]
{ rw [← lcm_erase_dup, erase_dup_ext.2, lcm_erase_dup, lcm_add], simp }
simp
intros
simp only [mul_left_comm, mul_assoc]
intros
rw [sub_eq_add_neg, add_right_neg a]
intros
revert b
rw forall_is_conj
intro b
rw [carrier, eq_comm, mk_eq_mk_iff_is_conj, ← quotient_mk_eq_mk, quotient.lift_mk]
refl
intros
simp only [bit1, pow_succ, neg_pow_bit0, neg_mul_eq_neg_mul]
intros
induction n with n ih; [rw [zero_nsmul, nat.cast_zero, mul_zero], rw [succ_nsmul', ih, nat.cast_succ, mul_add, mul_one]]
induction n with n ih
rw [zero_nsmul, nat.cast_zero, mul_zero]
rw [succ_nsmul', ih, nat.cast_succ, mul_add, mul_one]
intros
cases lt_or_eq_of_le Hxpos
rw ←nat.sub_add_cancel Hnpos
{ rw ←nat.sub_add_cancel Hnpos, induction (n - 1), { simpa only [pow_one] }, rw [pow_add, pow_add, nat.succ_eq_add_one, pow_one, pow_one], apply mul_lt_mul ih (le_of_lt Hxy) h (le_of_lt (pow_pos (lt_trans h Hxy) _)) }
induction (n - 1)
simpa only [pow_one]
{ simpa only [pow_one] }
rw [pow_add, pow_add, nat.succ_eq_add_one, pow_one, pow_one]
apply mul_lt_mul ih (le_of_lt Hxy) h (le_of_lt (pow_pos (lt_trans h Hxy) _))
rw [←h, zero_pow Hnpos]
{ rw [←h, zero_pow Hnpos], apply pow_pos (by rwa ←h at Hxy : 0 < y),}
apply pow_pos (by rwa ←h at Hxy : 0 < y)
intros
rw [eq_comm, div_eq_iff_mul_eq hc]
intros
simp only [semiconj_by, mul_zero, zero_mul]
intros
{ dsimp [of], rw [if_pos rfl, category.id_comp] }
dsimp [of]
rw [if_pos rfl, category.id_comp]
intros
rw [← lie_submodule.coe_to_submodule_eq_iff, comap_coe_submodule, lie_submodule.sup_coe_to_submodule, f.ker_coe_submodule, ← submodule.comap_map_eq, lie_submodule.lie_ideal_oper_eq_linear_span, lie_submodule.lie_ideal_oper_eq_linear_span, linear_map.map_span]
congr
simp only [lie_hom.coe_to_linear_map, set.mem_set_of_eq]
ext y
split
rintros ⟨⟨x₁, hx₁⟩, ⟨x₂, hx₂⟩, hy⟩
{ rintros ⟨⟨x₁, hx₁⟩, ⟨x₂, hx₂⟩, hy⟩, rw ← hy, erw [lie_submodule.mem_inf, f.mem_ideal_range_iff h] at hx₁ hx₂, obtain ⟨⟨z₁, hz₁⟩, hz₁'⟩ := hx₁, rw ← hz₁ at hz₁', obtain ⟨⟨z₂, hz₂⟩, hz₂'⟩ := hx₂, rw ← hz₂ at hz₂', use [⁅z₁, z₂⁆, ⟨z₁, hz₁'⟩, ⟨z₂, hz₂'⟩, rfl], simp only [hz₁, hz₂, submodule.coe_mk, lie_hom.map_lie], }
rw ← hy
erw [lie_submodule.mem_inf, f.mem_ideal_range_iff h] at hx₁ hx₂
obtain ⟨⟨z₁, hz₁⟩, hz₁'⟩ := hx₁
rw ← hz₁ at hz₁'
obtain ⟨⟨z₂, hz₂⟩, hz₂'⟩ := hx₂
rw ← hz₂ at hz₂'
use [⁅z₁, z₂⁆, ⟨z₁, hz₁'⟩, ⟨z₂, hz₂'⟩, rfl]
simp only [hz₁, hz₂, submodule.coe_mk, lie_hom.map_lie]
rintros ⟨x, ⟨⟨z₁, hz₁⟩, ⟨z₂, hz₂⟩, hx⟩, hy⟩
{ rintros ⟨x, ⟨⟨z₁, hz₁⟩, ⟨z₂, hz₂⟩, hx⟩, hy⟩, rw [← hy, ← hx], have hz₁' : f z₁ ∈ f.ideal_range ⊓ J₁, { rw lie_submodule.mem_inf, exact ⟨f.mem_ideal_range, hz₁⟩, }, have hz₂' : f z₂ ∈ f.ideal_range ⊓ J₂, { rw lie_submodule.mem_inf, exact ⟨f.mem_ideal_range, hz₂⟩, }, use [⟨f z₁, hz₁'⟩, ⟨f z₂, hz₂'⟩], simp only [submodule.coe_mk, lie_hom.map_lie], }
rw [← hy, ← hx]
have hz₁' : f z₁ ∈ f.ideal_range ⊓ J₁
{ rw lie_submodule.mem_inf, exact ⟨f.mem_ideal_range, hz₁⟩, }
rw lie_submodule.mem_inf
exact ⟨f.mem_ideal_range, hz₁⟩
have hz₂' : f z₂ ∈ f.ideal_range ⊓ J₂
{ rw lie_submodule.mem_inf, exact ⟨f.mem_ideal_range, hz₂⟩, }
rw lie_submodule.mem_inf
exact ⟨f.mem_ideal_range, hz₂⟩
use [⟨f z₁, hz₁'⟩, ⟨f z₂, hz₂'⟩]
simp only [submodule.coe_mk, lie_hom.map_lie]
intros
have h : ∀ (K K' : lie_subalgebra R L), (K : set L) ≤ K' ↔ K ≤ K'
intros
{ intros, exact iff.rfl, }
exact iff.rfl
apply is_glb.of_image h
simp only [Inf_coe]
exact is_glb_binfi
intros
have aux : ∀ (x : L) m, m ∈ (N ⊔ N' : submodule R M) → ⁅x,m⁆ ∈ (N ⊔ N' : submodule R M)
simp only [submodule.mem_sup]
{ simp only [submodule.mem_sup], rintro x m ⟨y, hy, z, hz, rfl⟩, refine ⟨⁅x, y⁆, N.lie_mem hy, ⁅x, z⁆, N'.lie_mem hz, (lie_add _ _ _).symm⟩ }
rintro x m ⟨y, hy, z, hz, rfl⟩
refine ⟨⁅x, y⁆, N.lie_mem hy, ⁅x, z⁆, N'.lie_mem hz, (lie_add _ _ _).symm⟩
refine le_antisymm (Inf_le ⟨{ lie_mem := aux, ..(N ⊔ N' : submodule R M) }, _⟩) _
simp only [exists_prop, and_true, mem_set_of_eq, eq_self_iff_true, coe_to_submodule_mk, ← coe_submodule_le_coe_submodule, and_self, le_sup_left, le_sup_right]
{ simp only [exists_prop, and_true, mem_set_of_eq, eq_self_iff_true, coe_to_submodule_mk, ← coe_submodule_le_coe_submodule, and_self, le_sup_left, le_sup_right] }
{ simp, }
simp
intros
rw ideal_range_eq_map
exact lie_ideal.mem_map (lie_submodule.mem_top x)
intros
{ ext x, refl }
ext x
refl
intros
{ rw [inv_eq_one_div], exact div_le_iff' ha }
rw [inv_eq_one_div]
exact div_le_iff' ha
intros
rw [lt_div_iff hb, one_mul]
intros
rw [mul_comm b c, ← div_sub_div _ _ hc hd, sub_lt_zero]
intros
{ rw [← mul_le_mul_iff_left a], simp }
rw [← mul_le_mul_iff_left a]
simp
intros
{ ext x, refl }
ext x
refl
intros
simp [abs_eq_max_neg]
intros
lift a to α using ha
lift b to α using hb
simp only [← coe_mul, coe_lt_top]
intros
{ convert mul_le_mul_left h, simp }
convert mul_le_mul_left h
simp
intros
simpa only [sub_eq_neg_add] using h.int_mul n (-x)
intros
rw image_eq_preimage_of_inverse; intro c; simp
rw image_eq_preimage_of_inverse; intro c
{ rw image_eq_preimage_of_inverse; intro c; simp }
rw image_eq_preimage_of_inverse
intro c
simp
intro c
simp
intros
rw next_coeff_multiset_prod
simp only [next_coeff_X_sub_C]
{ simp only [next_coeff_X_sub_C], refine t.sum_hom ⟨has_neg.neg, _, _⟩; simp [add_comm] }
refine t.sum_hom ⟨has_neg.neg, _, _⟩; simp [add_comm]
refine t.sum_hom ⟨has_neg.neg, _, _⟩
simp [add_comm]
simp [add_comm]
{ intros, apply monic_X_sub_C }
intros
apply monic_X_sub_C
intros
have h2 : (2 : K) ≠ 0 := nonzero_of_invertible 2
rw [quadratic_eq_zero_iff_discrim_eq_sq h2 ha, h, sq, mul_self_eq_mul_self_iff]
have ne : 2 * a ≠ 0 := mul_ne_zero h2 ha
have : x = 2 * a * x / (2 * a) := (mul_div_cancel_left x ne).symm
have h₁ : 2 * a * ((-b + s) / (2 * a)) = -b + s := mul_div_cancel' _ ne
have h₂ : 2 * a * ((-b - s) / (2 * a)) = -b - s := mul_div_cancel' _ ne
split
intro h'
{ intro h', rcases h', { left, rw h', simpa [add_comm] }, { right, rw h', simpa [add_comm, sub_eq_add_neg] } }
rcases h'
{ left, rw h', simpa [add_comm] }
left
rw h'
simpa [add_comm]
{ right, rw h', simpa [add_comm, sub_eq_add_neg] }
right
rw h'
simpa [add_comm, sub_eq_add_neg]
intro h'
{ intro h', rcases h', { left, rw [h', h₁], ring }, { right, rw [h', h₂], ring } }
rcases h'
left
{ left, rw [h', h₁], ring }
rw [h', h₁]
ring
right
{ right, rw [h', h₂], ring }
rw [h', h₂]
ring
intros
rw [a.conj_eq_two_re_sub]
exact (coe_commute (2 * a.re) a).sub_left (commute.refl a)
intros
simp only [sub_eq_add_neg, h.neg.add_right]
intros
tidy
intros
induction n with n IH
{ simp }
simp
{ rw [add_nsmul, IH, one_nsmul, add_self] }
rw [add_nsmul, IH, one_nsmul, add_self]
intros
rw [topological_space.opens.le_def, basic_open_eq_zero_locus_compl, basic_open_eq_zero_locus_compl, set.le_eq_subset, set.compl_subset_compl, zero_locus_subset_zero_locus_singleton_iff]
intros
rw right_inv
intros
simpa only [sub_eq_add_neg] using h₁.add h₂.neg_left
intros
contrapose! hf'
rcases hf' with ⟨⟨b, hb, hmb⟩, ⟨a, ha, hma⟩⟩
exact (convex_image_has_deriv_at hs hf).ord_connected.out (mem_image_of_mem f' ha) (mem_image_of_mem f' hb) ⟨hma, hmb⟩
intros
rcases eq_or_ne x 0 with rfl|hne
simp [deriv_zero_of_not_differentiable_at (mt differentiable_at_inv.1 (not_not.2 rfl))]
{ simp [deriv_zero_of_not_differentiable_at (mt differentiable_at_inv.1 (not_not.2 rfl))] }
{ exact (has_deriv_at_inv hne).deriv }
exact (has_deriv_at_inv hne).deriv
intros
rw [← has_deriv_within_at_univ] at *
exact hf.const_smul c
intros
simpa only [sub_eq_add_neg] using hf.neg.const_add c
intros
by_cases h : differentiable_within_at 𝕜 f s x
rw [fderiv.comp_fderiv_within x iso.differentiable_at h hxs, iso.fderiv]
{ rw [fderiv.comp_fderiv_within x iso.differentiable_at h hxs, iso.fderiv] }
have : ¬differentiable_within_at 𝕜 (iso ∘ f) s x
{ have : ¬differentiable_within_at 𝕜 (iso ∘ f) s x, from mt iso.comp_differentiable_within_at_iff.1 h, rw [fderiv_within_zero_of_not_differentiable_within_at h, fderiv_within_zero_of_not_differentiable_within_at this, continuous_linear_map.comp_zero] }
from mt iso.comp_differentiable_within_at_iff.1 h
rw [fderiv_within_zero_of_not_differentiable_within_at h, fderiv_within_zero_of_not_differentiable_within_at this, continuous_linear_map.comp_zero]
intros
assume x xs
rcases h x xs with ⟨t, t_open, xt, ht⟩
exact (differentiable_within_at_inter (is_open.mem_nhds t_open xt)).1 (ht x ⟨xs, xt⟩)
intros
cases hc with hE hc
haveI : subsingleton s := ⟨λ x y, subtype.eq $ @subsingleton.elim _ hE _ _⟩
{ haveI : subsingleton s := ⟨λ x y, subtype.eq $ @subsingleton.elim _ hE _ _⟩, exact antilipschitz_with.of_subsingleton }
exact antilipschitz_with.of_subsingleton
convert (f'.antilipschitz.restrict s).add_lipschitz_with hf.lipschitz_sub hc
simp [restrict]
intros
rcases submodule.exists_le_ker_of_lt_top _ (lt_top_iff_ne_top.2 $ hextr.range_ne_top_of_has_strict_fderiv_at hf' hφ') with ⟨Λ', h0, hΛ'⟩
set e : ((F →ₗ[ℝ] ℝ) × ℝ) ≃ₗ[ℝ] (F × ℝ →ₗ[ℝ] ℝ) := ((linear_equiv.refl ℝ (F →ₗ[ℝ] ℝ)).prod (linear_map.ring_lmap_equiv_self ℝ ℝ ℝ).symm).trans (linear_map.coprod_equiv ℝ)
rcases e.surjective Λ' with ⟨⟨Λ, Λ₀⟩, rfl⟩
refine ⟨Λ, Λ₀, e.map_ne_zero_iff.1 h0, λ x, _⟩
convert linear_map.congr_fun (linear_map.range_le_ker_iff.1 hΛ') x using 1
simp only [linear_map.coprod_equiv_apply, linear_equiv.refl_apply, linear_map.ring_lmap_equiv_self_symm_apply, linear_map.comp_apply, continuous_linear_map.coe_coe, continuous_linear_map.prod_apply, linear_equiv.trans_apply, linear_equiv.prod_apply, linear_map.coprod_apply, linear_map.smul_right_apply, linear_map.one_apply, smul_eq_mul, mul_comm]
intros
simpa using continuous_linear_map.ext_iff.1 (h.has_fderiv_at_eq_zero (has_deriv_at_iff_has_fderiv_at.1 hf)) 1
intros
simpa only [univ_inter] using unique_diff_within_at_univ.inter h
intros
induction n with n IH
{ ext x, simp }
ext x
simp
ext x m
{ ext x m, rw [iterated_fderiv_succ_apply_left, iterated_fderiv_within_succ_apply_left, IH, fderiv_within_univ] }
rw [iterated_fderiv_succ_apply_left, iterated_fderiv_within_succ_apply_left, IH, fderiv_within_univ]
intros
set f' := λ y, continuous_multilinear_curry_fin1 ℝ E F (p y 1)
have hder : ∀ y ∈ s, has_fderiv_within_at f (f' y) s y
from λ y hy, (hf.has_fderiv_within_at le_rfl (subset_insert x s hy)).mono (subset_insert x s)
have hcont : continuous_within_at f' s x
from (continuous_multilinear_curry_fin1 ℝ E F).continuous_at.comp_continuous_within_at ((hf.cont _ le_rfl _ (mem_insert _ _)).mono (subset_insert x s))
replace hK : ∥f' x∥₊ < K
simpa only [linear_isometry_equiv.nnnorm_map]
simpa only [linear_isometry_equiv.nnnorm_map]
exact hs.exists_nhds_within_lipschitz_on_with_of_has_fderiv_within_at_of_nnnorm_lt (eventually_nhds_within_iff.2 $ eventually_of_forall hder) hcont K hK
intros
refine hs.mem_to_cone.trans ⟨_, _⟩
rintros ⟨c, hc, y, hy, rfl⟩
{ rintros ⟨c, hc, y, hy, rfl⟩, exact ⟨c⁻¹, inv_pos.2 hc, by rwa [smul_smul, inv_mul_cancel (ne_of_gt hc), one_smul]⟩ }
exact ⟨c⁻¹, inv_pos.2 hc, by rwa [smul_smul, inv_mul_cancel (ne_of_gt hc), one_smul]⟩
rintros ⟨c, hc, hcx⟩
{ rintros ⟨c, hc, hcx⟩, exact ⟨c⁻¹, inv_pos.2 hc, _, hcx, by rw [smul_smul, inv_mul_cancel (ne_of_gt hc), one_smul]⟩ }
exact ⟨c⁻¹, inv_pos.2 hc, _, hcx, by rw [smul_smul, inv_mul_cancel (ne_of_gt hc), one_smul]⟩
intros
rw [hA.mem_extreme_points_iff_convex_diff, hA.convex_remove_iff_not_mem_convex_hull_remove, mem_diff]
apply adjoin_eq_span_of_subset
refine subset.trans _ submodule.subset_span
intros x hx
apply submonoid.closure_induction hx (λ _, id) ⟨0, rfl⟩
rintros _ _ ⟨m, rfl⟩ ⟨n, rfl⟩
refine ⟨m + n, _⟩
ext1 z
exact fourier_add
intros
simp only [inner_add_left, inner_add_right]; ring
simp only [inner_add_left, inner_add_right]
ring
intros
{ have h := @norm_sub_mul_self ℝ F _ _, simpa using h }
have h := @norm_sub_mul_self ℝ F _ _
simpa using h
intros
simpa only [dist_eq_norm] using dist_comm g h
intros
simp only [le_rank_iff_exists_linear_independent_finset, set_of_exists, ← exists_prop]
refine is_open_bUnion (λ t ht, _)
have : continuous (λ f : E →L[𝕜] F, (λ x : (t : set E), f x))
from continuous_pi (λ x, (continuous_linear_map.apply 𝕜 F (x : E)).continuous)
exact is_open_set_of_linear_independent.preimage this
intros
{ ext, refl }
ext
refl
intros
refine ⟨abs C + 1, _, _⟩
{ linarith [abs_nonneg C] }
linarith [abs_nonneg C]
apply h.mono
{ apply h.mono, linarith [le_abs_self C] }
linarith [le_abs_self C]
intros
rwa [quotient_norm_eq_zero_iff, hS.closure_eq] at h
intros
refine f.op_norm_le_bound hC (λ x, _)
by_cases hx : ∥x∥ = 0
rw [hx, mul_zero]
{ rw [hx, mul_zero], exact le_of_eq (norm_image_of_norm_zero f.2 hx) }
exact le_of_eq (norm_image_of_norm_zero f.2 hx)
exact linear_map.bound_of_shell_semi_normed f ε_pos hc hf hx
intros
by_cases hx : x = 0
simp [hx]
{ simp [hx] }
exact linear_map.bound_of_shell_semi_normed f ε_pos hc hf (ne_of_lt (norm_pos_iff.2 hx)).symm
simp [arg, le_refl]
norm_num [real.pi_ne_zero, I_ne_zero]
intros
simpa only [sq, sub_eq_add_neg, neg_mul_eq_mul_neg] using integral_deriv_mul_eq_sub (λ x hx, has_deriv_at_sin x) (λ x hx, has_deriv_at_cos x) continuous_on_cos.interval_integrable continuous_on_sin.neg.interval_integrable
intros
by_cases hp : P = 0
simpa [hp] using is_O_zero (λ x, eval x Q) filter.at_top
{ simpa [hp] using is_O_zero (λ x, eval x Q) filter.at_top }
have hq : Q ≠ 0 := ne_zero_of_degree_ge_degree h hp
{ have hq : Q ≠ 0 := ne_zero_of_degree_ge_degree h hp, have hPQ : ∀ᶠ (x : 𝕜) in at_top, eval x Q = 0 → eval x P = 0 := filter.mem_of_superset (polynomial.eventually_no_roots Q hq) (λ x h h', absurd h' h), cases le_iff_lt_or_eq.mp h with h h, { exact is_O_of_div_tendsto_nhds hPQ 0 (div_tendsto_zero_of_degree_lt P Q h) }, { exact is_O_of_div_tendsto_nhds hPQ _ (div_tendsto_leading_coeff_div_of_degree_eq P Q h) } }
have hPQ : ∀ᶠ (x : 𝕜) in at_top, eval x Q = 0 → eval x P = 0 := filter.mem_of_superset (polynomial.eventually_no_roots Q hq) (λ x h h', absurd h' h)
cases le_iff_lt_or_eq.mp h with h h
exact is_O_of_div_tendsto_nhds hPQ 0 (div_tendsto_zero_of_degree_lt P Q h)
{ exact is_O_of_div_tendsto_nhds hPQ 0 (div_tendsto_zero_of_degree_lt P Q h) }
exact is_O_of_div_tendsto_nhds hPQ _ (div_tendsto_leading_coeff_div_of_degree_eq P Q h)
{ exact is_O_of_div_tendsto_nhds hPQ _ (div_tendsto_leading_coeff_div_of_degree_eq P Q h) }
intros
by_cases hp_zero : p = 0
{ simp [hp_zero, ennreal.zero_lt_one], }
simp [hp_zero, ennreal.zero_lt_one]
rw ←ne.def at hp_zero
{ rw ←ne.def at hp_zero, have hp_pos := lt_of_le_of_ne hp_nonneg hp_zero.symm, rw ←zero_rpow_of_pos hp_pos, exact rpow_lt_rpow hx_pos hp_pos, }
have hp_pos := lt_of_le_of_ne hp_nonneg hp_zero.symm
rw ←zero_rpow_of_pos hp_pos
exact rpow_lt_rpow hx_pos hp_pos
intros
rw rpow_def_of_pos hx; apply exp_pos
rw rpow_def_of_pos hx
apply exp_pos
intros
apply exp_injective
rw [exp_log (rpow_pos_of_pos hx y), ← exp_log hx, mul_comm, rpow_def_of_pos (exp_pos (log x)) y]
intros
convert (has_strict_fderiv_at_rpow_of_pos ((λ x, (f x, g x)) x) h).comp_has_strict_deriv_at _ (hf.prod hg) using 1
simp [mul_assoc, mul_comm, mul_left_comm]
intros
rw [← mul_self_eq_one_iff, ← sin_sq_add_cos_sq x, sq, sq, ← sub_eq_iff_eq_add, sub_self]
rw [← mul_self_eq_one_iff, ← sin_sq_add_cos_sq x, sq, sq, ← sub_eq_iff_eq_add, sub_self]; exact ⟨λ h, by rw [h, mul_zero], eq_zero_of_mul_self_eq_zero ∘ eq.symm⟩
exact ⟨λ h, by rw [h, mul_zero], eq_zero_of_mul_self_eq_zero ∘ eq.symm⟩
intros
simp only [sinh, div_eq_mul_inv]
convert ((has_strict_deriv_at_exp x).add (has_strict_deriv_at_id x).neg.cexp).mul_const (2:ℂ)⁻¹
rw [id, mul_neg_one, sub_eq_add_neg]
funext x
by_cases h : x ≠ -1 ∧ x ≠ 1
{ exact (has_deriv_at_arcsin h.1 h.2).deriv }
exact (has_deriv_at_arcsin h.1 h.2).deriv
rw [deriv_zero_of_not_differentiable_at (mt differentiable_at_arcsin.1 h)]
{ rw [deriv_zero_of_not_differentiable_at (mt differentiable_at_arcsin.1 h)], simp only [not_and_distrib, ne.def, not_not] at h, rcases h with (rfl|rfl); simp }
simp only [not_and_distrib, ne.def, not_not] at h
rcases h with (rfl|rfl); simp
rcases h with (rfl|rfl)
simp
simp
intros
refine (monotone_mul_left_of_nonneg hc).seq_le_seq n _ h _
refine (monotone_mul_left_of_nonneg hc).seq_le_seq n _ h _; simp [pow_succ, mul_assoc, le_refl]
simp [pow_succ, mul_assoc, le_refl]
simp [pow_succ, mul_assoc, le_refl]
intros
simp [dist_eq_norm', sum_range_succ]
intros
simp [unit_comp_partial_bijective_aux]
intros
simp
intros
constructor
intros Z g h H
replace H := congr_arg (adj.hom_equiv Z Y).symm H
rwa [adj.hom_equiv_naturality_right_symm, adj.hom_equiv_naturality_right_symm, cancel_mono, equiv.apply_eq_iff_eq] at H
intros
simp
intros
rw [←eq_comp_inv, id_comp]
intros
{ dsimp [colimit_limit_to_limit_colimit], simp, }
dsimp [colimit_limit_to_limit_colimit]
simp
intros
ext j
ext j; erw [assoc, limit.pre_π, limit.pre_π, limit.pre_π]; refl
ext j; erw [assoc, limit.pre_π, limit.pre_π, limit.pre_π]
erw [assoc, limit.pre_π, limit.pre_π, limit.pre_π]
refl
intros
ext
rw [←assoc, colimit.ι_post, ←H.map_comp, colimit.ι_map, H.map_comp]
rw [←assoc, colimit.ι_map, assoc, colimit.ι_post]
refl
intros
tidy
intros
simp [biproduct.components]
intros
rw hI.hom_ext f (hI.to X)
apply initial_mono_class.is_initial_mono_from
intros
{ ext, refl }
ext
refl
intros
rw [associator_inv_naturality, hom_inv_id_assoc]
intros
simp
intros
ext
change c _ (sieve.pullback f S) = ⊤ ↔ c _ S f
rw [pb, sieve.pullback_eq_top_iff_mem]
intros
rw ← id_mem_iff_eq_top
exact ⟨_, section_ f, f, hf, by simp⟩
intros
simp [of_le_mk]
intros
apply length_pos_of_sum_pos
convert h
exact c.blocks_sum
intros
{ ext, simp }
ext
simp
intros
rw [←card_neighbor_set_eq_degree]
exact set.card_le_of_subset (set.inter_subset_left _ _)
intros
simp only [step_set, set.mem_Union, set.bind_def]
intros
induction d₁ using many_one_degree.ind_on
induction d₂ using many_one_degree.ind_on
induction d₃ using many_one_degree.ind_on
simpa only [← add_of, of_le_of] using disjoin_le
intros
obtain ⟨i, h₁, h₂⟩ := tr_init c v
refine part.ext (λ x, _)
rw [reaches_eval h₂.to_refl]
simp
refine ⟨λ h, _, _⟩
obtain ⟨c, hc₁, hc₂⟩ := tr_eval_rev tr_respects h₁ h
{ obtain ⟨c, hc₁, hc₂⟩ := tr_eval_rev tr_respects h₁ h, simp [step_normal_eval] at hc₂, obtain ⟨v', hv, rfl⟩ := hc₂, exact ⟨_, hv, hc₁.symm⟩ }
simp [step_normal_eval] at hc₂
obtain ⟨v', hv, rfl⟩ := hc₂
exact ⟨_, hv, hc₁.symm⟩
rintro ⟨v', hv, rfl⟩
{ rintro ⟨v', hv, rfl⟩, have := tr_eval tr_respects h₁, simp [step_normal_eval] at this, obtain ⟨_, ⟨⟩, h⟩ := this _ hv rfl, exact h }
have := tr_eval tr_respects h₁
simp [step_normal_eval] at this
obtain ⟨_, ⟨⟩, h⟩ := this _ hv rfl
exact h
intros
cases x
cases x; refl
refl
intros
induction x; simp! * with functor_norm; refl
induction x; simp! * with functor_norm
induction x
simp! * with functor_norm
refl
simp! * with functor_norm
refl
intros
simp [list.mem_iff_nth, to_list_nth, and.comm, and.assoc, and.left_comm]
intros
by_cases p; simp *
by_cases p
simp *
simp *
intros
rw ←buffer.size_eq_zero_iff
have : char_buf cb' cb' 0 = done cb'.size () := by simp [char_buf_eq_done]
cases hc : cb'.size with n
{ simp only [eq_self_iff_true, iff_true], exact ⟨λ _ _ _ _ h, by simpa [hc] using (char_buf_eq_done.mp h).left⟩ }
simp only [eq_self_iff_true, iff_true]
exact ⟨λ _ _ _ _ h, by simpa [hc] using (char_buf_eq_done.mp h).left⟩
rw hc at this
{ rw hc at this, simpa [nat.succ_ne_zero] using not_of_ne this (nat.succ_ne_zero n).symm }
simpa [nat.succ_ne_zero] using not_of_ne this (nat.succ_ne_zero n).symm
intros
constructor
intros cb n hn
haveI : (parser.foldl_core f b p (cb.size - n + 1)).bounded := foldl_core he
obtain ⟨np, errp, hp⟩ := bounded.exists (parser.foldl_core f b p (cb.size - n + 1)) hn
simp [foldl, hp]
intros
apply not_step_of_static_done
simp [pure_eq_done]
intros
simp [foldr, foldr_core_succ_eq_fail]
simp [norm_sq]
intros
rw ← of_real_inj; simp [cosh_three_mul]
rw ← of_real_inj
simp [cosh_three_mul]
intros
convert cos_add_mul_I z.re z.im; exact (re_add_im z).symm
convert cos_add_mul_I z.re z.im
exact (re_add_im z).symm
intros
rw [← exp_mul_I, ← exp_mul_I]
induction n with n ih
rw [pow_zero, nat.cast_zero, zero_mul, zero_mul, exp_zero]
{ rw [pow_zero, nat.cast_zero, zero_mul, zero_mul, exp_zero] }
rw [pow_succ', ih, nat.cast_succ, add_mul, add_mul, one_mul, exp_add]
{ rw [pow_succ', ih, nat.cast_succ, add_mul, add_mul, one_mul, exp_add] }
intros
rw [← finite_dimensional.finrank_mul_finrank ℝ ℂ E, complex.finrank_real_complex]
intros
simp
intros
simp [zip_with_def]
intros
{ ext, refl }
ext
refl
intros
{ ext, simp }
ext
simp
intros
by_cases hx : z = x
simp [hx]
simp [hx]
by_cases hy : z = y
simp [hy]
simp [hy]
rw [equiv.swap_apply_of_ne_of_ne hx hy, equiv.swap_apply_of_ne_of_ne (hf.ne hx) (hf.ne hy)]
intros
simp [fin_succ_equiv_last]
intros
ext x
simp only [map_equiv_apply, refl_apply]
exact is_lawful_functor.id_map x
intros
have A : (e : α → β) = e'
ext x
ext x
{ ext x, exact h x }
{ ext x, exact h x }
exact h x
exact h x
have B : (e.symm : β → α) = e'.symm
ext x
ext x
{ ext x, exact hsymm x }
{ ext x, exact hsymm x }
exact hsymm x
exact hsymm x
have I : e '' e.source = e.target := e.image_source_eq_target
have I' : e' '' e'.source = e'.target := e'.image_source_eq_target
rw [A, hs, I'] at I
cases e; cases e'
cases e
cases e'
simp * at *
intros
cases i with i hi
rw [add_cases, dif_pos (cast_add_lt _ _)]
refl
intros
refine insert_nth_eq_iff.2 ⟨by simp, _⟩
ext j
apply eq_of_heq
transitivity snoc (λ j, _root_.cast (congr_arg α (succ_above_last_apply j)) (p j)) x j.cast_succ
{ rw [snoc_cast_succ], exact (cast_heq _ _).symm }
rw [snoc_cast_succ]
exact (cast_heq _ _).symm
apply congr_arg_heq
{ apply congr_arg_heq, rw [succ_above_last] }
rw [succ_above_last]
intros
cases n
cases k with k h
{ cases k with k h, cases k, {show _ % _ = _, simp}, cases h with _ h, cases h }
cases k
show _ % _ = _
{show _ % _ = _, simp}
simp
cases h with _ h
cases h
simp [bit1, fin.coe_bit0, fin.coe_add, fin.coe_one]
intros
simp [finset.nonempty]
intros
ext (⟨⟩ | ⟨n⟩); simp [nat.succ_eq_add_one, nat.zero_lt_succ n]
ext (⟨⟩ | ⟨n⟩)
simp [nat.succ_eq_add_one, nat.zero_lt_succ n]
simp [nat.succ_eq_add_one, nat.zero_lt_succ n]
intros
rw insert_eq_of_mem h
intros
rw [←with_bot.coe_le_coe, coe_sup', le_sup_iff (with_bot.bot_lt_coe a)]
exact bex_congr (λ b hb, with_bot.coe_le_coe)
intros
induction s using quotient.induction_on
simp
intros
classical
{ classical, rw [prod_preimage', prod_filter_of_ne], exact λ x hx, not.imp_symm (hg x hx) }
rw [prod_preimage', prod_filter_of_ne]
exact λ x hx, not.imp_symm (hg x hx)
intros
simp
intros
rcases em (a = x) with (rfl|hx); [simp, simp [single_eq_of_ne hx]]
rcases em (a = x) with (rfl|hx)
simp
simp [single_eq_of_ne hx]
intros
simp [fintype.subtype_card, finset.card_univ]
intros
simpa using exists_max_image univ f univ_nonempty
intros
rw [← fin.succ_above_last, fin.image_succ_above_univ]
intros
dsimp [keys]; rw entries_empty; refl
dsimp [keys]; rw entries_empty
dsimp [keys]
rw entries_empty
refl
intros
cases m with m m; cases n with n n; simp [← int.mul_def, int.mul, -of_nat_eq_coe, bool.bxor_comm]
cases m with m m; cases n with n n
cases m with m m
cases n with n n
simp [← int.mul_def, int.mul, -of_nat_eq_coe, bool.bxor_comm]
simp [← int.mul_def, int.mul, -of_nat_eq_coe, bool.bxor_comm]
cases n with n n
simp [← int.mul_def, int.mul, -of_nat_eq_coe, bool.bxor_comm]
simp [← int.mul_def, int.mul, -of_nat_eq_coe, bool.bxor_comm]
intros
cases n
cases n; refl
refl
refl
intros
rw [mul_comm, int.add_mul_div_right _ _ H]
intros
rw [← int.mul_div_cancel' h, H, mul_zero]
intros
induction n; simp *
induction n
simp *
simp *
intros
{ rw [int.lcm], apply nat.lcm_zero_right }
rw [int.lcm]
apply nat.lcm_zero_right
intros
{ rw [sub_eq_add_neg, sub_eq_add_neg], exact h₁.add h₂.neg }
rw [sub_eq_add_neg, sub_eq_add_neg]
exact h₁.add h₂.neg
intros
simp [not_or_distrib] with parity_simps
intros
induction l with b l ih
{ exact iff_of_true rfl (not_mem_nil _) }
exact iff_of_true rfl (not_mem_nil _)
simp only [length, mem_cons_iff, index_of_cons]
split_ifs
{ exact iff_of_false (by rintro ⟨⟩) (λ H, H $ or.inl h) }
exact iff_of_false (by rintro ⟨⟩) (λ H, H $ or.inl h)
{ simp only [h, false_or], rw ← ih, exact succ_inj' }
simp only [h, false_or]
rw ← ih
exact succ_inj'
intros
unfold list.bind; induction l; simp only [map, join, list.ret, cons_append, nil_append, *]; split; refl
unfold list.bind; induction l; simp only [map, join, list.ret, cons_append, nil_append, *]; split
unfold list.bind; induction l; simp only [map, join, list.ret, cons_append, nil_append, *]
unfold list.bind; induction l
unfold list.bind
induction l
simp only [map, join, list.ret, cons_append, nil_append, *]
simp only [map, join, list.ret, cons_append, nil_append, *]
split
intros
induction l₁ generalizing n
simp
{ simp }
cases n
simp
{ simp }
simp *
intros
rw [sub_eq_add_neg, alternating_sum]
intros
induction l with l_hd l_tl l_ih
{ apply (hl₂ rfl).elim }
apply (hl₂ rfl).elim
cases l_tl
{ cases l_tl, { simp }, { apply l_ih } }
{ simp }
simp
{ apply l_ih }
apply l_ih
intros
simp only [reduce_option_nil, concat_eq_append, reduce_option_append, reduce_option_cons_of_some]
intros
simp [permutations, permutations_aux_append]
intros
simp only [mem_union, or_imp_distrib, forall_and_distrib]
intros
induction xs generalizing i j
case list.nil : i j h { cases hi }
case list.cons : x xs xs_ih i j h { cases i; simp only [-slice_eq, list.slice], { cases j, cases h, dsimp only [drop], unfold_wf, apply @lt_of_le_of_lt _ _ _ xs.sizeof, { clear_except, induction xs generalizing j; unfold_wf, case list.nil : j { refl }, case list.cons : xs_hd xs_tl xs_ih j { cases j; unfold_wf, refl, transitivity, apply xs_ih, simp }, }, unfold_wf, apply zero_lt_one_add, }, { unfold_wf, apply xs_ih _ _ h, apply lt_of_succ_lt_succ hi, } }
intros
simp [length_subsingleton_iff]
intros
simpa only [erase_dup, forall_mem_ne, not_not] using not_congr (@forall_mem_pw_filter α (≠) _ (λ x y z xz, not_and_distrib.1 $ mt (and.rec eq.trans) xz) a l)
intros
cases le_total m l with hml hlm
{ rw [min_eq_left hml, filter_lt_of_top_le hml] }
rw [min_eq_left hml, filter_lt_of_top_le hml]
{ rw [min_eq_right hlm, filter_lt_of_ge hlm] }
rw [min_eq_right hlm, filter_lt_of_ge hlm]
intros
have := pairwise_sublists' (pairwise_reverse.2 H)
have := pairwise_sublists' (pairwise_reverse.2 H); rwa [sublists'_reverse, pairwise_map] at this
rwa [sublists'_reverse, pairwise_map] at this
intros
induction h with x _ _ _ _ x y _ _ _ _ _ _ ih_1 ih_2 generalizing t
simp
{simp}
by_cases x ∈ t; simp [*, perm.cons]
{ by_cases x ∈ t; simp [*, perm.cons] }
by_cases x ∈ t
simp [*, perm.cons]
simp [*, perm.cons]
by_cases x = y
{ by_cases x = y, {simp [h]}, by_cases xt : x ∈ t; by_cases yt : y ∈ t, { simp [xt, yt, mem_erase_of_ne h, mem_erase_of_ne (ne.symm h), erase_comm, swap] }, { simp [xt, yt, mt mem_of_mem_erase, perm.cons] }, { simp [xt, yt, mt mem_of_mem_erase, perm.cons] }, { simp [xt, yt] } }
simp [h]
{simp [h]}
by_cases xt : x ∈ t; by_cases yt : y ∈ t
by_cases xt : x ∈ t
by_cases yt : y ∈ t
simp [xt, yt, mem_erase_of_ne h, mem_erase_of_ne (ne.symm h), erase_comm, swap]
{ simp [xt, yt, mem_erase_of_ne h, mem_erase_of_ne (ne.symm h), erase_comm, swap] }
{ simp [xt, yt, mt mem_of_mem_erase, perm.cons] }
simp [xt, yt, mt mem_of_mem_erase, perm.cons]
by_cases yt : y ∈ t
{ simp [xt, yt, mt mem_of_mem_erase, perm.cons] }
simp [xt, yt, mt mem_of_mem_erase, perm.cons]
{ simp [xt, yt] }
simp [xt, yt]
{ exact (ih_1 _).trans (ih_2 _) }
exact (ih_1 _).trans (ih_2 _)
intros
simp only [range_eq_range', mem_range', nat.zero_le, true_and, zero_add]
intros
rw rotate_eq_rotate'
induction l generalizing l'
{ simp, }
simp
{ simp [rotate', l_ih] }
simp [rotate', l_ih]
intros
simp [← lookup_is_some, option.is_none_iff_eq_none]
intros
dsimp [erase_dupkeys]
generalize hl : nil = l'
have : nodupkeys l'
rw ← hl
{ rw ← hl, apply nodup_nil }
apply nodup_nil
clear hl
induction l with x xs
{ apply this }
apply this
cases x
{ cases x, simp [erase_dupkeys], split, { simp [keys_kerase], apply mem_erase_of_nodup l_ih }, apply kerase_nodupkeys _ l_ih, }
simp [erase_dupkeys]
split
{ simp [keys_kerase], apply mem_erase_of_nodup l_ih }
simp [keys_kerase]
apply mem_erase_of_nodup l_ih
apply kerase_nodupkeys _ l_ih
intros
rw [← sublists_aux_eq_foldr]; refl
rw [← sublists_aux_eq_foldr]
refl
intros
simp [tfae, -eq_iff_iff]
intros
induction l with hd tl hl generalizing l'
{ simp }
simp
cases l' with hd' tl'
{ cases l' with hd' tl', { simp }, { simp [hl] } }
{ simp }
simp
{ simp [hl] }
simp [hl]
intros
ext i j
unfold has_one.one transpose
by_cases i = j
{ simp only [h, diagonal_apply_eq] }
simp only [h, diagonal_apply_eq]
simp only [diagonal_apply_ne h, diagonal_apply_ne (λ p, h (symm p))]
{ simp only [diagonal_apply_ne h, diagonal_apply_ne (λ p, h (symm p))] }
intros
by_cases j' = j
{ rw [h, update_column_self, if_pos rfl] }
rw [h, update_column_self, if_pos rfl]
{ rwa [update_column_ne h, if_neg h] }
rwa [update_column_ne h, if_neg h]
intros
simp [dot_product]
intros
simp [dot_product, fin.sum_univ_succ, vec_head, vec_tail]
intros
by_cases h : a = b; simp [h]
by_cases h : a = b
simp [h]
simp [h]
intros
induction h; simp [*]
induction h
simp [*]
simp [*]
intros
simpa using add_le_add_right (zero_le t) s
intros
rw mv_polynomial.ext_iff
apply forall_congr
intro m
rw [coeff_map]
apply eq_iff_eq_cancel_right.mpr
refl
intros
simp only [monomial_eq, ring_hom.map_mul, bind₂_C_right, finsupp.prod, ring_hom.map_prod, ring_hom.map_pow, bind₂_X_right, C_1, one_mul]
intros
rw [supported_eq_range_rename, alg_hom.mem_range]
split
rintros ⟨p, rfl⟩
{ rintros ⟨p, rfl⟩, refine trans (finset.coe_subset.2 (vars_rename _ _)) _, simp }
refine trans (finset.coe_subset.2 (vars_rename _ _)) _
simp
intros hs
{ intros hs, exact exists_rename_eq_of_vars_subset_range p (coe : s → σ) subtype.val_injective (by simpa) }
exact exists_rename_eq_of_vars_subset_range p (coe : s → σ) subtype.val_injective (by simpa)
intros
{ ext i, rw [mem_vars, finset.mem_bUnion] }
ext i
rw [mem_vars, finset.mem_bUnion]
intros
have := (add_mul_mod_self_left (m % n + k) n (m / n)).symm
have := (add_mul_mod_self_left (m % n + k) n (m / n)).symm; rwa [add_right_comm, mod_add_div] at this
rwa [add_right_comm, mod_add_div] at this
intros
{ dunfold decreasing_induction, rw [le_rec_on_self] }
dunfold decreasing_induction
rw [le_rec_on_self]
intros
rw [test_bit, shiftr_eq_div_pow, nat.div_self (pow_pos zero_lt_two n), bodd_one]
intros
{ rw one_div, exact inv_pos_of_nat }
rw one_div
exact inv_pos_of_nat
intros
induction L with d L ih
{ refl, }
refl
{ dsimp [of_digits], rw ih, }
dsimp [of_digits]
rw ih
intros
rw ←of_digits_one
conv_lhs { rw ←(of_digits_digits b' n) }
rw [nat.dvd_iff_mod_eq_zero, nat.dvd_iff_mod_eq_zero, of_digits_mod, h]
intros
rw [← some_eq_coe]
simp only [le_def, exists_prop_of_true, dom_some, forall_true_iff]
refl
intros
refine ⟨_, lt_find P n⟩
intros h m hm
by_cases H : (find P).dom
apply nat.find_min H
{ apply nat.find_min H, rw coe_lt_iff at h, specialize h H, exact lt_of_le_of_lt hm h }
rw coe_lt_iff at h
specialize h H
exact lt_of_le_of_lt hm h
{ exact not_exists.mp H m }
exact not_exists.mp H m
intros
simp only [modeq_iff_dvd, int.coe_nat_add] at *
rw add_sub_comm at h₂
convert _root_.dvd_sub h₂ h₁ using 1
rw add_sub_cancel'
intros
rw [mul_comm a, mul_comm b, mul_comm n]; exact h.mul_left' c
rw [mul_comm a, mul_comm b, mul_comm n]
exact h.mul_left' c
intros
rintro ⟨t, rfl⟩
have h1 : m < t
from nat.mul_self_lt_mul_self_iff.mpr hl
have h2 : t < m + 1
from nat.mul_self_lt_mul_self_iff.mpr hr
exact (not_lt_of_ge $ le_of_lt_succ h2) h1
intros
rw ← not_lt; exact not_congr lt_to_int
rw ← not_lt
exact not_congr lt_to_int
intros
rw ← not_lt; exact not_congr lt_to_nat
rw ← not_lt
exact not_congr lt_to_nat
intros
cases a; cases b; refl
cases a; cases b
cases a
cases b
refl
refl
cases b
refl
refl
intros
cases a; simp
cases a
simp
simp
intros
rw insert'_eq_insert_with; exact insert_with.valid _ _ (λ _, id) h
rw insert'_eq_insert_with
exact insert_with.valid _ _ (λ _, id) h
intros
rw [← dual_dual (balance_r l x r), dual_balance_r, balance_l_eq_balance' hr.dual hl.dual sr.dual sl.dual (balance_sz_dual H), ← dual_balance', dual_dual]
intros
rw [obj_append1, obj_append1, map_eq, append_fun, ← split_fun_comp]
rw [obj_append1, obj_append1, map_eq, append_fun, ← split_fun_comp]; refl
refl
intros
simpa only [pi.zero_apply, hf', single] using function.apply_update f' 0 i x j
intros
unfold_coes
dsimp[of_pnat_multiset, to_pnat_multiset]
have : (λ (p : ℕ+) (h : p.prime), ((coe : nat.primes → ℕ+) ⟨p, h⟩)) = (λ p h, id p) := by {funext p h, apply subtype.eq, refl}
rw[multiset.map_pmap, this, multiset.pmap_eq_map, multiset.map_id]
intros
simp only [monomial, monomial_fun, coeff, linear_map.coe_mk]
{ simp only [monomial, monomial_fun, coeff, linear_map.coe_mk], rw finsupp.single_apply }
rw finsupp.single_apply
intros
{ rcases p, simp [coeff, smul_to_finsupp] }
rcases p
simp [coeff, smul_to_finsupp]
intros
simpa only [C_1, one_mul] using degree_C_mul_X_pow_le n (1:R)
intros
{ rintro rfl, exact nat_degree_not_mem_erase_lead_support h }
rintro rfl
exact nat_degree_not_mem_erase_lead_support h
intros
apply polynomial.induction_on' p
intros p q hp hq
{ intros p q hp hq, simp only [hp, hq, add_mul, add_comp] }
simp only [hp, hq, add_mul, add_comp]
intros n b
{ intros n b, simp only [pow_succ', mul_assoc, monomial_mul_X, monomial_comp] }
simp only [pow_succ', mul_assoc, monomial_mul_X, monomial_comp]
intros
simp only [coe_map_ring_hom, lifts, set.mem_range, ring_hom.mem_srange]
intros
simp [monomial, monomial_fun, finsupp.single_eq_single_iff]
intros
{ cases x, cases y, apply Wequiv.abs, apply h }
cases x
cases y
apply Wequiv.abs
apply h
intros
cases d; refl
cases d
refl
intros
rw [rat.inv_def', rat.coe_int_num, rat.coe_int_denom, nat.cast_one, ←int.cast_one]
apply denom_div_eq_of_coprime ha0
rw int.nat_abs_one
exact nat.coprime_one_left _
intros
have q_num_pos : 0 < q.num
from rat.num_pos_iff_pos.elim_right q_pos
have q_num_abs_eq_q_num : (q.num.nat_abs : ℤ) = q.num
from (int.nat_abs_of_nonneg $ le_of_lt q_num_pos)
set q_inv := (q.denom : ℚ) / q.num with q_inv_def
have q_inv_eq : q⁻¹ = q_inv
from rat.inv_def'
suffices : (q_inv - ⌊q_inv⌋).num < q.num
rwa q_inv_eq
rwa q_inv_eq
suffices : ((q.denom - q.num * ⌊q_inv⌋ : ℚ) / q.num).num < q.num
field_simp [this, (ne_of_gt q_num_pos)]
field_simp [this, (ne_of_gt q_num_pos)]
suffices : (q.denom : ℤ) - q.num * ⌊q_inv⌋ < q.num
have : ((q.denom - q.num * ⌊q_inv⌋ : ℚ) / q.num).num = q.denom - q.num * ⌊q_inv⌋
have : ((q.denom - q.num * ⌊q_inv⌋ : ℚ) / q.num).num = q.denom - q.num * ⌊q_inv⌋
{ have : ((q.denom - q.num * ⌊q_inv⌋ : ℚ) / q.num).num = q.denom - q.num * ⌊q_inv⌋, by { suffices : ((q.denom : ℤ) - q.num * ⌊q_inv⌋).nat_abs.coprime q.num.nat_abs, by exact_mod_cast (rat.num_div_eq_of_coprime q_num_pos this), have : (q.num.nat_abs : ℚ) = (q.num : ℚ), by exact_mod_cast q_num_abs_eq_q_num, have tmp := nat.coprime_sub_mul_floor_rat_div_of_coprime q.cop.symm, simpa only [this, q_num_abs_eq_q_num] using tmp }, rwa this }
{ have : ((q.denom - q.num * ⌊q_inv⌋ : ℚ) / q.num).num = q.denom - q.num * ⌊q_inv⌋, by { suffices : ((q.denom : ℤ) - q.num * ⌊q_inv⌋).nat_abs.coprime q.num.nat_abs, by exact_mod_cast (rat.num_div_eq_of_coprime q_num_pos this), have : (q.num.nat_abs : ℚ) = (q.num : ℚ), by exact_mod_cast q_num_abs_eq_q_num, have tmp := nat.coprime_sub_mul_floor_rat_div_of_coprime q.cop.symm, simpa only [this, q_num_abs_eq_q_num] using tmp }, rwa this }
suffices : ((q.denom : ℤ) - q.num * ⌊q_inv⌋).nat_abs.coprime q.num.nat_abs
suffices : ((q.denom : ℤ) - q.num * ⌊q_inv⌋).nat_abs.coprime q.num.nat_abs
suffices : ((q.denom : ℤ) - q.num * ⌊q_inv⌋).nat_abs.coprime q.num.nat_abs
{ suffices : ((q.denom : ℤ) - q.num * ⌊q_inv⌋).nat_abs.coprime q.num.nat_abs, by exact_mod_cast (rat.num_div_eq_of_coprime q_num_pos this), have : (q.num.nat_abs : ℚ) = (q.num : ℚ), by exact_mod_cast q_num_abs_eq_q_num, have tmp := nat.coprime_sub_mul_floor_rat_div_of_coprime q.cop.symm, simpa only [this, q_num_abs_eq_q_num] using tmp }
{ suffices : ((q.denom : ℤ) - q.num * ⌊q_inv⌋).nat_abs.coprime q.num.nat_abs, by exact_mod_cast (rat.num_div_eq_of_coprime q_num_pos this), have : (q.num.nat_abs : ℚ) = (q.num : ℚ), by exact_mod_cast q_num_abs_eq_q_num, have tmp := nat.coprime_sub_mul_floor_rat_div_of_coprime q.cop.symm, simpa only [this, q_num_abs_eq_q_num] using tmp }
{ suffices : ((q.denom : ℤ) - q.num * ⌊q_inv⌋).nat_abs.coprime q.num.nat_abs, by exact_mod_cast (rat.num_div_eq_of_coprime q_num_pos this), have : (q.num.nat_abs : ℚ) = (q.num : ℚ), by exact_mod_cast q_num_abs_eq_q_num, have tmp := nat.coprime_sub_mul_floor_rat_div_of_coprime q.cop.symm, simpa only [this, q_num_abs_eq_q_num] using tmp }
exact_mod_cast (rat.num_div_eq_of_coprime q_num_pos this)
exact_mod_cast (rat.num_div_eq_of_coprime q_num_pos this)
exact_mod_cast (rat.num_div_eq_of_coprime q_num_pos this)
exact_mod_cast (rat.num_div_eq_of_coprime q_num_pos this)
have : (q.num.nat_abs : ℚ) = (q.num : ℚ)
have : (q.num.nat_abs : ℚ) = (q.num : ℚ)
have : (q.num.nat_abs : ℚ) = (q.num : ℚ)
exact_mod_cast q_num_abs_eq_q_num
exact_mod_cast q_num_abs_eq_q_num
exact_mod_cast q_num_abs_eq_q_num
exact_mod_cast q_num_abs_eq_q_num
have tmp := nat.coprime_sub_mul_floor_rat_div_of_coprime q.cop.symm
have tmp := nat.coprime_sub_mul_floor_rat_div_of_coprime q.cop.symm
have tmp := nat.coprime_sub_mul_floor_rat_div_of_coprime q.cop.symm
simpa only [this, q_num_abs_eq_q_num] using tmp
simpa only [this, q_num_abs_eq_q_num] using tmp
simpa only [this, q_num_abs_eq_q_num] using tmp
rwa this
rwa this
have q_inv_num_denom_ineq : q⁻¹.num - ⌊q⁻¹⌋ * q⁻¹.denom < q⁻¹.denom
have : q⁻¹.num < (⌊q⁻¹⌋ + 1) * q⁻¹.denom
have : q⁻¹.num < (⌊q⁻¹⌋ + 1) * q⁻¹.denom
{ have : q⁻¹.num < (⌊q⁻¹⌋ + 1) * q⁻¹.denom, from rat.num_lt_succ_floor_mul_denom q⁻¹, have : q⁻¹.num < ⌊q⁻¹⌋ * q⁻¹.denom + q⁻¹.denom, by rwa [right_distrib, one_mul] at this, rwa [←sub_lt_iff_lt_add'] at this }
{ have : q⁻¹.num < (⌊q⁻¹⌋ + 1) * q⁻¹.denom, from rat.num_lt_succ_floor_mul_denom q⁻¹, have : q⁻¹.num < ⌊q⁻¹⌋ * q⁻¹.denom + q⁻¹.denom, by rwa [right_distrib, one_mul] at this, rwa [←sub_lt_iff_lt_add'] at this }
from rat.num_lt_succ_floor_mul_denom q⁻¹
from rat.num_lt_succ_floor_mul_denom q⁻¹
have : q⁻¹.num < ⌊q⁻¹⌋ * q⁻¹.denom + q⁻¹.denom
have : q⁻¹.num < ⌊q⁻¹⌋ * q⁻¹.denom + q⁻¹.denom
rwa [right_distrib, one_mul] at this
rwa [right_distrib, one_mul] at this
rwa [right_distrib, one_mul] at this
rwa [←sub_lt_iff_lt_add'] at this
rwa [←sub_lt_iff_lt_add'] at this
have : q_inv.num = q.denom ∧ q_inv.denom = q.num.nat_abs
have coprime_q_denom_q_num : q.denom.coprime q.num.nat_abs
have coprime_q_denom_q_num : q.denom.coprime q.num.nat_abs
{ have coprime_q_denom_q_num : q.denom.coprime q.num.nat_abs, from q.cop.symm, have : int.nat_abs q.denom = q.denom, by simp, rw ←this at coprime_q_denom_q_num, rw q_inv_def, split, { exact_mod_cast (rat.num_div_eq_of_coprime q_num_pos coprime_q_denom_q_num) }, { suffices : (((q.denom : ℚ) / q.num).denom : ℤ) = q.num.nat_abs, by exact_mod_cast this, rw q_num_abs_eq_q_num, exact_mod_cast (rat.denom_div_eq_of_coprime q_num_pos coprime_q_denom_q_num) } }
{ have coprime_q_denom_q_num : q.denom.coprime q.num.nat_abs, from q.cop.symm, have : int.nat_abs q.denom = q.denom, by simp, rw ←this at coprime_q_denom_q_num, rw q_inv_def, split, { exact_mod_cast (rat.num_div_eq_of_coprime q_num_pos coprime_q_denom_q_num) }, { suffices : (((q.denom : ℚ) / q.num).denom : ℤ) = q.num.nat_abs, by exact_mod_cast this, rw q_num_abs_eq_q_num, exact_mod_cast (rat.denom_div_eq_of_coprime q_num_pos coprime_q_denom_q_num) } }
from q.cop.symm
from q.cop.symm
have : int.nat_abs q.denom = q.denom
have : int.nat_abs q.denom = q.denom
simp
simp
simp
rw ←this at coprime_q_denom_q_num
rw ←this at coprime_q_denom_q_num
rw q_inv_def
rw q_inv_def
split
split
exact_mod_cast (rat.num_div_eq_of_coprime q_num_pos coprime_q_denom_q_num)
exact_mod_cast (rat.num_div_eq_of_coprime q_num_pos coprime_q_denom_q_num)
{ exact_mod_cast (rat.num_div_eq_of_coprime q_num_pos coprime_q_denom_q_num) }
{ exact_mod_cast (rat.num_div_eq_of_coprime q_num_pos coprime_q_denom_q_num) }
suffices : (((q.denom : ℚ) / q.num).denom : ℤ) = q.num.nat_abs
suffices : (((q.denom : ℚ) / q.num).denom : ℤ) = q.num.nat_abs
{ suffices : (((q.denom : ℚ) / q.num).denom : ℤ) = q.num.nat_abs, by exact_mod_cast this, rw q_num_abs_eq_q_num, exact_mod_cast (rat.denom_div_eq_of_coprime q_num_pos coprime_q_denom_q_num) }
{ suffices : (((q.denom : ℚ) / q.num).denom : ℤ) = q.num.nat_abs, by exact_mod_cast this, rw q_num_abs_eq_q_num, exact_mod_cast (rat.denom_div_eq_of_coprime q_num_pos coprime_q_denom_q_num) }
exact_mod_cast this
exact_mod_cast this
exact_mod_cast this
rw q_num_abs_eq_q_num
rw q_num_abs_eq_q_num
exact_mod_cast (rat.denom_div_eq_of_coprime q_num_pos coprime_q_denom_q_num)
exact_mod_cast (rat.denom_div_eq_of_coprime q_num_pos coprime_q_denom_q_num)
rwa [q_inv_eq, this.left, this.right, q_num_abs_eq_q_num, mul_comm] at q_inv_num_denom_ineq
convert of_rat_lt.2 zero_lt_one; simp
convert of_rat_lt.2 zero_lt_one
simp
simp
intros
simp [cantor_function_aux, h]
intros
simp [ennreal.of_real]
intros
split
{ rintro rfl, exact bot_lt_coe }
rintro rfl
exact bot_lt_coe
contrapose!
{ contrapose!, intro h, exact ⟨x.to_real, coe_to_real_le h⟩, }
intro h
exact ⟨x.to_real, coe_to_real_le h⟩
intros
{ unfold_coes, simp [real.to_ereal] }
unfold_coes
simp [real.to_ereal]
intros
simp [real.to_nnreal, hr, hp, add_nonneg]
intros
rw [div_eq_mul_inv, div_eq_mul_inv, ← real.to_nnreal_inv, ← real.to_nnreal_mul hx]
intros
obtain hn | rfl | hp := lt_trichotomy r (0 : ℝ)
rw [sign_of_neg hn, sign_of_pos (neg_pos.mpr hn), neg_neg]
{ rw [sign_of_neg hn, sign_of_pos (neg_pos.mpr hn), neg_neg] }
{ rw [sign_zero, neg_zero, sign_zero] }
rw [sign_zero, neg_zero, sign_zero]
{ rw [sign_of_pos hp, sign_of_neg (neg_lt_zero.mpr hp)] }
rw [sign_of_pos hp, sign_of_neg (neg_lt_zero.mpr hp)]
intros
unfold to_list
unfold to_list; simp; rw to_list'_map; simp; refl
unfold to_list; simp; rw to_list'_map; simp
unfold to_list; simp; rw to_list'_map
unfold to_list; simp
simp
rw to_list'_map
simp
refl
intros
{ ext x, finish [set.ite, iff_def] }
ext x
finish [set.ite, iff_def]
intros
rcases hs.eq_empty_or_singleton with rfl|⟨x, rfl⟩
{ rcases hs.eq_empty_or_singleton with rfl|⟨x, rfl⟩, exacts [he, h₁ _] }
exacts [he, h₁ _]
intros
{ ext ⟨x, y⟩, simp [or_and_distrib_right] }
ext ⟨x, y⟩
simp [or_and_distrib_right]
intros
apply subset.antisymm
rintro _ ⟨x, rfl⟩ i -
{ rintro _ ⟨x, rfl⟩ i -, exact ⟨x i, rfl⟩ }
exact ⟨x i, rfl⟩
intros x hx
{ intros x hx, choose y hy using hx, exact ⟨λ i, y i trivial, funext $ λ i, hy i trivial⟩ }
choose y hy using hx
exact ⟨λ i, y i trivial, funext $ λ i, hy i trivial⟩
intros
ext
split
rintro ⟨_, c, ⟨a, b, ha, hb, rfl⟩, hc, rfl⟩
{ rintro ⟨_, c, ⟨a, b, ha, hb, rfl⟩, hc, rfl⟩, refine ⟨a, b, c, ha, hb, hc, rfl⟩ }
refine ⟨a, b, c, ha, hb, hc, rfl⟩
rintro ⟨a, b, c, ha, hb, hc, rfl⟩
{ rintro ⟨a, b, c, ha, hb, hc, rfl⟩, refine ⟨_, c, ⟨a, b, ha, hb, rfl⟩, hc, rfl⟩ }
refine ⟨_, c, ⟨a, b, ha, hb, rfl⟩, hc, rfl⟩
intros
simp [set.ext_iff]
intros
rw maps_to'
intros
ext y
split
rintro ⟨x, rfl⟩
{ rintro ⟨x, rfl⟩, by_cases h : x ∈ s;[left, right]; use x; simp [h] }
by_cases h : x ∈ s
by_cases h : x ∈ s;[left, right]; use x; simp [h]
by_cases h : x ∈ s;[left, right]; use x
by_cases h : x ∈ s;[left, right]
left
use x
simp [h]
right
use x
simp [h]
rintro (⟨x, hx, rfl⟩|⟨x, hx, rfl⟩); use x; simp * at *
rintro (⟨x, hx, rfl⟩|⟨x, hx, rfl⟩); use x
rintro (⟨x, hx, rfl⟩|⟨x, hx, rfl⟩)
{ rintro (⟨x, hx, rfl⟩|⟨x, hx, rfl⟩); use x; simp * at * }
use x
simp * at *
use x
simp * at *
intros
rw [← Icc_diff_right, diff_diff_cancel_left (singleton_subset_iff.2 $ right_mem_Icc.2 h)]
intros
simp [← Ici_inter_Iio]
intros
simp
intros
simp [← Ioi_inter_Iic, h]
intros
simp
intros
ext x
simp only [mem_Union, mem_Inter, mem_sInter, exists_imp_distrib]
split
split; tauto
tauto
tauto
intros
induction n; refl
induction n
refl
refl
intros
cases n; simp
cases n
simp
simp
intros
rcases h with ⟨u, rfl⟩
rw [inv_coe_unit, u.mul_inv]
intros
simpa only [nsmul_eq_mul, add_right_iterate] using (f.commute_add_int m).iterate_pos_lt_iff_map_lt f.monotone (strict_mono_id.add_const m) hn
intros
rw [← hx.eq, ← hy.eq, ← iterate_pred_comp_of_pos f hn, comp_app, h]
intros
haveI : is_solvable (q.splitting_field ≃ₐ[F] q.splitting_field) := hq
exact solvable_of_surjective (alg_equiv.restrict_normal_hom_surjective q.splitting_field)
intros
cases (zorn.chain_insert hc (λ _ _ _, or.inl bot_le)).total_of_refl hx hy with hxy hyx
{ exact ⟨y, hy, hxy, le_refl y⟩ }
exact ⟨y, hy, hxy, le_refl y⟩
{ exact ⟨x, hx, le_refl x, hyx⟩ }
exact ⟨x, hx, le_refl x, hyx⟩
intros
ext
conv_rhs { rw [ring_hom.one_def, ring_hom.id_apply, ← pow_card x, hcard], }
clear hcard
induction n
simp
{simp}
rw [pow_succ, pow_succ', pow_mul, ring_hom.mul_def, ring_hom.comp_apply, frobenius_def, n_ih]
intros
induction n with n ih
{ simp }
simp
{ simp [pow_succ, ih] }
simp [pow_succ, ih]
intros
cases irreducible_or_factor (minpoly A x) (not_is_unit A x) with hirr hred
{ exact hirr }
exact hirr
exfalso
obtain ⟨a, b, ha_nunit, hb_nunit, hab_eq⟩ := hred
have coeff_prod : a.leading_coeff * b.leading_coeff = 1
rw [←monic.def.1 (monic hx), ←hab_eq]
{ rw [←monic.def.1 (monic hx), ←hab_eq], simp only [leading_coeff_mul] }
simp only [leading_coeff_mul]
have hamonic : (a * C b.leading_coeff).monic
rw monic.def
{ rw monic.def, simp only [coeff_prod, leading_coeff_mul, leading_coeff_C] }
simp only [coeff_prod, leading_coeff_mul, leading_coeff_C]
have hbmonic : (b * C a.leading_coeff).monic
rw [monic.def, mul_comm]
{ rw [monic.def, mul_comm], simp only [coeff_prod, leading_coeff_mul, leading_coeff_C] }
simp only [coeff_prod, leading_coeff_mul, leading_coeff_C]
have prod : minpoly A x = (a * C b.leading_coeff) * (b * C a.leading_coeff)
symmetry
{ symmetry, calc a * C b.leading_coeff * (b * C a.leading_coeff) = a * b * (C a.leading_coeff * C b.leading_coeff) : by ring ... = a * b * (C (a.leading_coeff * b.leading_coeff)) : by simp only [ring_hom.map_mul] ... = a * b : by rw [coeff_prod, C_1, mul_one] ... = minpoly A x : hab_eq }
calc a * C b.leading_coeff * (b * C a.leading_coeff) = a * b * (C a.leading_coeff * C b.leading_coeff) : by ring ... = a * b * (C (a.leading_coeff * b.leading_coeff)) : by simp only [ring_hom.map_mul] ... = a * b : by rw [coeff_prod, C_1, mul_one] ... = minpoly A x : hab_eq
have hzero := aeval A x
rw [prod, aeval_mul, mul_eq_zero] at hzero
cases hzero
refine aeval_ne_zero_of_dvd_not_unit_minpoly hx hamonic _ hzero
{ refine aeval_ne_zero_of_dvd_not_unit_minpoly hx hamonic _ hzero, exact ⟨hamonic.ne_zero, _, mt is_unit_of_mul_is_unit_left hb_nunit, prod⟩ }
exact ⟨hamonic.ne_zero, _, mt is_unit_of_mul_is_unit_left hb_nunit, prod⟩
refine aeval_ne_zero_of_dvd_not_unit_minpoly hx hbmonic _ hzero
{ refine aeval_ne_zero_of_dvd_not_unit_minpoly hx hbmonic _ hzero, rw mul_comm at prod, exact ⟨hbmonic.ne_zero, _, mt is_unit_of_mul_is_unit_left ha_nunit, prod⟩ }
rw mul_comm at prod
exact ⟨hbmonic.ne_zero, _, mt is_unit_of_mul_is_unit_left ha_nunit, prod⟩
intros
simp only [restrict_comp, restrict_surjective]
intros
refine ⟨λ f hf1, _⟩
rw ← coe_fn_coe_base at hf1
have hf2 := eq_C_of_degree_eq_zero (degree_eq_zero_of_is_unit hf1)
rw [coeff_expand hp, if_pos (dvd_zero _), p.zero_div] at hf2
rw [hf2, is_unit_C] at hf1
rw expand_eq_C hp at hf2
rwa [hf2, is_unit_C]
intros
rw [←neg_neg r, neg_smul, angle_neg_right, angle_smul_right_of_pos x y (neg_pos_of_neg hr), angle_neg_right]
intros
rw [←mul_self_inj_of_nonneg dist_nonneg dist_nonneg, ←mul_self_inj_of_nonneg dist_nonneg dist_nonneg, dist_sq_eq_dist_orthogonal_projection_sq_add_dist_orthogonal_projection_sq p3 hp1, dist_sq_eq_dist_orthogonal_projection_sq_add_dist_orthogonal_projection_sq p3 hp2]
simp
intros
have hs : ({i₂, i₃}ᶜ : finset (fin 3)) = {i₁}
dec_trivial!
dec_trivial!
have he : univ.erase i₁ = {i₂, i₃}
dec_trivial!
dec_trivial!
rw [monge_plane_def, altitude_def, direction_affine_span, hs, he, centroid_singleton, coe_insert, coe_singleton, vector_span_image_eq_span_vsub_set_left_ne ℝ _ (set.mem_insert i₂ _)]
simp [h₂₃, submodule.span_insert_eq_span]
intros
rw norm_sub_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero
exact inner_eq_zero_iff_angle_eq_pi_div_two x y
intros
rw support_eq_symm_image
exact closure_minimal (image_subset _ $ inter_subset_inter_left _ ball_subset_closed_ball) f.closed_symm_image_closed_ball
intros
simp [stereographic']
intros
assume x xs
rcases h x xs with ⟨t, t_open, xt, ht⟩
exact (mdifferentiable_within_at_inter (is_open.mem_nhds t_open xt)).1 (ht x ⟨xs, xt⟩)
intros
simp only with mfld_simps
intros
assume p
exact (hf p.1).prod_map' (hg p.2)
intros
have key : ∀ g h, quotient.mk' g = quotient.mk' h ↔ g⁻¹ * h ∈ H := @quotient.eq' G (quotient_group.left_rel H)
simp_rw [mem_left_transversals_iff_exists_unique_inv_mul_mem, set_like.mem_coe, ←key]
exact ⟨λ h q, quotient.induction_on' q h, λ h g, h (quotient.mk' g)⟩
intros
rwa [eq', mul_inv_rev, inv_mul_cancel_right, s.inv_mem_iff]
intros
rw map_id
{rw map_id, refl }
refl
intros
rw [← mk_eq_monoid_of_mk', lift_on_mk]
intros
rw [mul_comm, mk'_mul_cancel_right]
intros
convert minimal_period_iterate_eq_div_gcd h
simp only [order_of, mul_left_iterate]
intros
convert iff.rfl
{ convert iff.rfl, simp only [exists_prop, is_periodic_pt_add_iff_nsmul_eq_zero] }
simp only [exists_prop, is_periodic_pt_add_iff_nsmul_eq_zero]
intros
rintros ⟨⟩ ⟨⟩ h
rw prod.mk.inj_iff
split
split; ext i; simpa using equiv.congr_fun h i
split; ext i
ext i
simpa using equiv.congr_fun h i
ext i
simpa using equiv.congr_fun h i
intros
rw ←finset.coe_inj
convert support_form_perm_of_nodup' _ h h'
simp [set.ext_iff]
intros
refine (sign_eq_sign_of_equiv _ _ (prod_comm β α) _).trans (sign_prod_congr_right σ)
rintro ⟨b, α⟩
refl
intros
simp only [list.not_mem_nil, and_true, list.mem_cons_iff, not_false_iff, list.nodup_cons, list.mem_singleton, and_self, list.nodup_nil] at h
push_neg at h
apply le_antisymm
convert support_mul_le _ _
{ convert support_mul_le _ _, rw [support_swap h.left.left, support_swap h.right], ext, simp [or.comm, or.left_comm] }
rw [support_swap h.left.left, support_swap h.right]
ext
simp [or.comm, or.left_comm]
intro
{ intro, simp only [mem_insert, mem_singleton], rintro (rfl | rfl | rfl | _); simp [swap_apply_of_ne_of_ne, h.left.left, h.left.left.symm, h.left.right, h.left.right.symm, h.right.symm] }
simp only [mem_insert, mem_singleton]
rintro (rfl | rfl | rfl | _); simp [swap_apply_of_ne_of_ne, h.left.left, h.left.left.symm, h.left.right, h.left.right.symm, h.right.symm]
rintro (rfl | rfl | rfl | _)
simp [swap_apply_of_ne_of_ne, h.left.left, h.left.left.symm, h.left.right, h.left.right.symm, h.right.symm]
simp [swap_apply_of_ne_of_ne, h.left.left, h.left.left.symm, h.left.right, h.left.right.symm, h.right.symm]
simp [swap_apply_of_ne_of_ne, h.left.left, h.left.left.symm, h.left.right, h.left.right.symm, h.right.symm]
intros
induction n with n ih
{ simp only [derived_series_zero, le_top], }
simp only [derived_series_zero, le_top]
{ simp only [derived_series_succ, map_commutator_eq_commutator_map, general_commutator_mono, *], }
simp only [derived_series_succ, map_commutator_eq_commutator_map, general_commutator_mono, *]
intros
simp only [pow_succ, sq, xa_mul_xa, xa_mul_a, add_sub_cancel, add_sub_assoc, add_sub_cancel', sub_self, add_zero]
norm_cast
rw ← two_mul
simp [one_def]
intros
{ ext, simp }
ext
simp
intros
simp only [infi, mem_Inf, set.forall_range_iff]
intros
rcases f with ⟨f, f_linear, f_add⟩
rcases g with ⟨g, g_linear, g_add⟩
have : f = g := funext h
subst g
congr' with v
cases (add_torsor.nonempty : nonempty P1) with p
apply vadd_right_cancel (f p)
erw [← f_add, ← g_add]
intros
rcases hp with ⟨p2, ⟨hp2, ⟨v2, ⟨hv2, hv2p⟩⟩⟩⟩
rw [hv2p, vadd_vadd]
use [p2, hp2, v + v2, (vector_span k s).add_mem hv hv2, rfl]
intros
simp [vector_span_def]
intros
rw sum_centroid_weights_indicator
exact s.sum_centroid_weights_eq_one_of_card_ne_zero k h
intros
simp only [line_map_apply_module]
exact add_lt_add_right (smul_lt_smul_of_pos ha (sub_pos.2 hr)) _
intros
refine disjoint_def.trans ⟨λ H hx, H x hx $ subset_span $ mem_singleton x, _⟩
assume H y hy hyx
obtain ⟨c, hc⟩ := mem_span_singleton.1 hyx
subst y
classical
by_cases hc : c = 0
simp only [hc, zero_smul]
simp only [hc, zero_smul]
rw [s.smul_mem_iff hc] at hy
rw [H hy, smul_zero]
intros
rw ker_comp; exact comap_mono bot_le
rw ker_comp
exact comap_mono bot_le
intros
simpa using (map_le_range : map p.subtype p' ≤ p.subtype.range)
intros
rw set_like.le_def
intros m h
change c • (fₗ m) ∈ qₗ
change fₗ m ∈ qₗ at h
apply qₗ.smul_mem _ h
intros
rw [← b.total_repr x, ← b.total_repr y]
{ rw [← b.total_repr x, ← b.total_repr y], congr' 1, ext i, exact h i }
congr' 1
ext i
exact h i
intros
{ ext i, simp }
ext i
simp
intros
rw [←@neg_one_smul R₁ _ _, smul_right, neg_one_mul]
intros
rw [bilin_form.to_matrix, linear_equiv.trans_apply, bilin_form.to_matrix'_apply, congr_apply, b.equiv_fun_symm_std_basis, b.equiv_fun_symm_std_basis]
intros
rw [←alg_hom.map_mul, ι_sq_scalar, alg_hom.commutes]
intros
ext
{ ext, unfold linear_map.det, split_ifs, { congr }, refl }
unfold linear_map.det
split_ifs
{ congr }
congr
refl
intros
rw [rank, rank, linear_map.range_comp]; exact dim_map_le _ _
rw [rank, rank, linear_map.range_comp]
exact dim_map_le _ _
intros
{ erw [constr_basis b, constr_basis b], ac_refl }
erw [constr_basis b, constr_basis b]
ac_refl
intros
simp [total_apply, sum_single_index]
intros
haveI := classical.dec_eq V
haveI := classical.dec_eq V'
let m := basis.of_vector_space K V
let m' := basis.of_vector_space K V'
rw [←cardinal.lift_inj.1 m.mk_eq_dim, ←cardinal.lift_inj.1 m'.mk_eq_dim] at h
rcases quotient.exact h with ⟨e⟩
let e := (equiv.ulift.symm.trans e).trans equiv.ulift
exact ⟨(m.repr ≪≫ₗ (finsupp.dom_lcongr e)) ≪≫ₗ m'.repr.symm⟩
intros
let P := (finsupp.linear_equiv_fun_on_fintype R R β)
let Q := (finsupp.linear_equiv_fun_on_fintype R R α).symm
exact card_le_of_injective R ((P.to_linear_map.comp f).comp Q.to_linear_map) ((P.injective.comp i).comp Q.injective)
intros
nontriviality R
have : inj_on f s
from inj_on_iff_injective.2 hs.injective.of_comp
exact (linear_independent_equiv' (equiv.set.image_of_inj_on f s this) rfl).1 hs
intros
refine ⟨le_sup_right, λ z₁ z₂ hz, _⟩
rw [← zero_add (g _), ← f.map_zero]
refine (sup_apply h _ _ _ _).symm
simpa
intros
convert matrix.det_reindex_self (equiv.subtype_equiv_right e) (to_square_block_prop M q)
intros
ext
ext; simp
simp
intros
ext j
rw [cramer_apply, pi.single_apply]
split_ifs with h
{ subst h, simp only [update_column_transpose, det_transpose, update_row, function.update_eq_self] }
subst h
simp only [update_column_transpose, det_transpose, update_row, function.update_eq_self]
rw [update_column_transpose, det_transpose]
{ rw [update_column_transpose, det_transpose], apply det_zero_of_row_eq h, rw [update_row_self, update_row_ne (ne.symm h)] }
apply det_zero_of_row_eq h
rw [update_row_self, update_row_ne (ne.symm h)]
intros
split
split; rintros ⟨x, hx⟩; refine @is_unit_of_invertible _ _ _ (id _)
split; rintros ⟨x, hx⟩
rintros ⟨x, hx⟩
refine @is_unit_of_invertible _ _ _ (id _)
haveI : invertible A := hx.rec x.invertible
{ haveI : invertible A := hx.rec x.invertible, apply det_invertible_of_invertible, }
apply det_invertible_of_invertible
rintros ⟨x, hx⟩
refine @is_unit_of_invertible _ _ _ (id _)
haveI : invertible A.det := hx.rec x.invertible
{ haveI : invertible A.det := hx.rec x.invertible, apply invertible_of_det_invertible, }
apply invertible_of_det_invertible
intros
{ rw [← reindex_linear_equiv_trans], refl }
rw [← reindex_linear_equiv_trans]
refl
intros
ext a b
by_cases ha : i = a; by_cases hb : j = b
by_cases ha : i = a
by_cases hb : j = b
simp only [update_row, transvection, ha, hb, function.update_same, std_basis_matrix.apply_same, pi.add_apply, one_apply_eq, pi.smul_apply, mul_one, algebra.id.smul_eq_mul]
{ simp only [update_row, transvection, ha, hb, function.update_same, std_basis_matrix.apply_same, pi.add_apply, one_apply_eq, pi.smul_apply, mul_one, algebra.id.smul_eq_mul], }
simp only [update_row, transvection, ha, hb, std_basis_matrix.apply_of_ne, function.update_same, pi.add_apply, ne.def, not_false_iff, pi.smul_apply, and_false, one_apply_ne, algebra.id.smul_eq_mul, mul_zero]
{ simp only [update_row, transvection, ha, hb, std_basis_matrix.apply_of_ne, function.update_same, pi.add_apply, ne.def, not_false_iff, pi.smul_apply, and_false, one_apply_ne, algebra.id.smul_eq_mul, mul_zero] }
by_cases hb : j = b
{ simp only [update_row, transvection, ha, ne.symm ha, std_basis_matrix.apply_of_ne, add_zero, algebra.id.smul_eq_mul, function.update_noteq, ne.def, not_false_iff, dmatrix.add_apply, pi.smul_apply, mul_zero, false_and] }
simp only [update_row, transvection, ha, ne.symm ha, std_basis_matrix.apply_of_ne, add_zero, algebra.id.smul_eq_mul, function.update_noteq, ne.def, not_false_iff, dmatrix.add_apply, pi.smul_apply, mul_zero, false_and]
simp only [update_row, transvection, ha, hb, ne.symm ha, std_basis_matrix.apply_of_ne, add_zero, algebra.id.smul_eq_mul, function.update_noteq, ne.def, not_false_iff, and_self, dmatrix.add_apply, pi.smul_apply, mul_zero]
{ simp only [update_row, transvection, ha, hb, ne.symm ha, std_basis_matrix.apply_of_ne, add_zero, algebra.id.smul_eq_mul, function.update_noteq, ne.def, not_false_iff, and_self, dmatrix.add_apply, pi.smul_apply, mul_zero] }
intros
have e : n ≃ fin (fintype.card n) := fintype.equiv_of_card_eq (by simp)
apply reindex_exists_list_transvec_mul_mul_list_transvec_eq_diagonal M e
apply exists_list_transvec_mul_mul_list_transvec_eq_diagonal_aux
intros
ext c
ext c; simp [funext_iff]; refl
ext c; simp [funext_iff]
simp [funext_iff]
intros
ext
ext; simp only [map_zero, add_zero, coprod_apply, inl_apply, comp_apply]
simp only [map_zero, add_zero, coprod_apply, inl_apply, comp_apply]
intros
{ tidy, exact 0, }
tidy
exact 0
intros
rw [std_basis_eq_pi_diag, proj_pi]
intros
simp only [← coe_rtensor_hom, map_sub]
intros
by_cases h : P; simp [h]
{ by_cases h : P; simp [h] }
by_cases h : P
simp [h]
simp [h]
intros
{ cases h, refl, }
cases h
refl
intros
{ ext, simp }
ext
simp
intros
rw [iterate_succ']
intros
simp_rw [ennreal.tsum_eq_supr_sum]
{ simp_rw [ennreal.tsum_eq_supr_sum], apply measurable_supr, exact λ s, s.measurable_sum (λ i _, h i) }
apply measurable_supr
exact λ s, s.measurable_sum (λ i _, h i)
intros
rw [ball_pi _ hr, pi_pi]
intros
refine ⟨(measurable_measure_prod_mk_left hs).ennreal_to_real.ae_measurable, _⟩
simp_rw [has_finite_integral, ennnorm_eq_of_real to_real_nonneg]
convert h2s.lt_top using 1
simp_rw [prod_apply hs]
apply lintegral_congr_ae
refine (ae_measure_lt_top hs h2s).mp _
apply eventually_of_forall
intros x hx
rw [lt_top_iff_ne_top] at hx
simp [of_real_to_real, hx]
intros
simp [integrable, h1f, has_finite_integral_prod_iff', h1f.norm.integral_prod_right', h1f.prod_mk_left]
intros
refine ae_nonneg_restrict_of_forall_set_integral_nonneg_inter hμt (hf_int_finite t ht (lt_top_iff_ne_top.mpr hμt)) (λ s hs, _)
refine (hf_zero (s ∩ t) (hs.inter ht) _)
exact (measure_mono (set.inter_subset_right s t)).trans_lt (lt_top_iff_ne_top.mpr hμt)
intros
refine (condexp_ae_eq_condexp_L1 f).trans (eventually_of_forall (λ x, _))
rw condexp_L1_eq hf
intros
rw ← L2.inner_indicator_const_Lp_one (hm s hs) hμs
have h_eq_inner : ∫ x in s, condexp_L2 𝕜 hm f x ∂μ = inner (indicator_const_Lp 2 (hm s hs) hμs (1 : 𝕜)) (condexp_L2 𝕜 hm f)
rw L2.inner_indicator_const_Lp_one (hm s hs) hμs
{ rw L2.inner_indicator_const_Lp_one (hm s hs) hμs, congr, }
congr
rw [h_eq_inner, ← inner_condexp_L2_left_eq_right, condexp_L2_indicator_of_measurable hm hs hμs]
intros
rw ← mem_ℒp_one_iff_integrable at hf ⊢
{ rw ← mem_ℒp_one_iff_integrable at hf ⊢, exact hf.const_inner c, }
exact hf.const_inner c
intros
simp_rw [snorm_eq_lintegral_rpow_nnnorm one_ne_zero ennreal.coe_ne_top, ennreal.one_to_real, one_div_one, ennreal.rpow_one]
intros
apply Lp.norm_le_mul_norm_of_ae_le_mul
filter_upwards [hg.coe_fn_comp_Lp g0 f, hg.coe_fn_comp_Lp g0 f', Lp.coe_fn_sub (hg.comp_Lp g0 f) (hg.comp_Lp g0 f'), Lp.coe_fn_sub f f']
assume a ha1 ha2 ha3 ha4
simp [ha1, ha2, ha3, ha4, ← dist_eq_norm]
exact hg.dist_le_mul (f a) (f' a)
intros
{ rw sub_eq_add_neg, exact hf.add hg.neg }
rw sub_eq_add_neg
exact hf.add hg.neg
intros
induction l with f l ihl
exact ae_measurable_one
{ exact ae_measurable_one }
rw [list.forall_mem_cons] at hl
rw [list.prod_cons]
exact hl.1.mul (ihl hl.2)
intros
rw [integral, simple_func.integral_eq_lintegral (simple_func.integrable f) h_pos]
intros
refine ⟨λ hfg, ⟨_, _⟩, λ h, h.1.add h.2⟩
rw ← indicator_add_eq_left h
{ rw ← indicator_add_eq_left h, exact hfg.indicator (measurable_set_support hf) }
exact hfg.indicator (measurable_set_support hf)
rw ← indicator_add_eq_right h
{ rw ← indicator_add_eq_right h, exact hfg.indicator (measurable_set_support hg) }
exact hfg.indicator (measurable_set_support hg)
intros
split
split; simp
simp
simp
simp
simp
intros
by_cases hc : c = 0; simp [hc]
by_cases hc : c = 0
simp [hc]
simp [hc]
intros
rw [← simple_func.const_lintegral, ← simple_func.lintegral_eq_lintegral, simple_func.coe_const]
intros
simp_rw [mul_comm, lintegral_const_mul r hf]
intros
simp only [measure.restrict_Union hd hm, lintegral_sum_measure]
intros
rw [f.restrict_lintegral hs, lintegral_restrict]
intros
rw [← image_univ]
{ rw [← image_univ], exact measurable_set_inr_image measurable_set.univ }
exact measurable_set_inr_image measurable_set.univ
intros
change @measurable_set' _ (generate_from $ ⋃₀ _) _ ↔ _
simp [generate_from, ← set_of_exists]
intros
have : is_compact (haar_product K₀.1)
apply is_compact_univ_pi
{ apply is_compact_univ_pi, intro K, apply is_compact_Icc }
intro K
apply is_compact_Icc
refine this.inter_Inter_nonempty (cl_prehaar K₀.1) (λ s, is_closed_closure) (λ t, _)
let V₀ := ⋂ (V ∈ t), (V : open_nhds_of 1).1
have h1V₀ : is_open V₀
apply is_open_bInter
{ apply is_open_bInter, apply finite_mem_finset, rintro ⟨V, hV⟩ h2V, exact hV.1 }
apply finite_mem_finset
rintro ⟨V, hV⟩ h2V
exact hV.1
have h2V₀ : (1 : G) ∈ V₀
simp only [mem_Inter]
{ simp only [mem_Inter], rintro ⟨V, hV⟩ h2V, exact hV.2 }
rintro ⟨V, hV⟩ h2V
exact hV.2
refine ⟨prehaar K₀.1 V₀, _⟩
split
apply prehaar_mem_haar_product K₀
{ apply prehaar_mem_haar_product K₀, use 1, rwa h1V₀.interior_eq }
use 1
rwa h1V₀.interior_eq
simp only [mem_Inter]
{ simp only [mem_Inter], rintro ⟨V, hV⟩ h2V, apply subset_closure, apply mem_image_of_mem, rw [mem_set_of_eq], exact ⟨subset.trans (Inter_subset _ ⟨V, hV⟩) (Inter_subset _ h2V), h1V₀, h2V₀⟩ }
rintro ⟨V, hV⟩ h2V
apply subset_closure
apply mem_image_of_mem
rw [mem_set_of_eq]
exact ⟨subset.trans (Inter_subset _ ⟨V, hV⟩) (Inter_subset _ h2V), h1V₀, h2V₀⟩
intros
rcases has_le.le.eq_or_lt hr with h|h
{ simp [← h, zero_pow finrank_pos] }
simp [← h, zero_pow finrank_pos]
{ exact add_haar_ball_of_pos μ x h }
exact add_haar_ball_of_pos μ x h
intros
simpa only [mul_comm] using real.smul_map_volume_mul_left h
intros
simp only [mem_ae_iff, map_apply hf hs.compl, preimage_compl]
intros
ext1 s hs
simp_rw [Inf_apply hs, restrict_apply hs, Inf_apply (measurable_set.inter hs ht), set.image_image, restrict_to_outer_measure_eq_to_outer_measure_restrict ht, ← set.image_image _ to_outer_measure, ← outer_measure.restrict_Inf_eq_Inf_restrict _ (hm.image _), outer_measure.restrict_apply]
intros
simp only [bounded_by, smul_of_function hc]
congr' 1 with s : 1
rcases s.eq_empty_or_nonempty with rfl|hs
rcases s.eq_empty_or_nonempty with rfl|hs; simp *
simp *
simp *
intros
haveI := hI.to_subtype
{ haveI := hI.to_subtype, rw [← infi_subtype'', ← infi_subtype''], exact restrict_infi _ _ }
rw [← infi_subtype'', ← infi_subtype'']
exact restrict_infi _ _
intros
{ rw left_lim, exact f.mono.tendsto_nhds_within_Iio x }
rw left_lim
exact f.mono.tendsto_nhds_within_Iio x
intros
rw union_eq_Union
{ rw union_eq_Union, exact d.has_Union (pairwise_disjoint_on_bool.2 h) (bool.forall_bool.2 ⟨h₂, h₁⟩) }
exact d.has_Union (pairwise_disjoint_on_bool.2 h) (bool.forall_bool.2 ⟨h₂, h₁⟩)
intros
simp
intros
simp only [admissible]
let S := sort ((≤) : ℕ+ → ℕ+ → Prop) {p,q,r}
have hS : S.sorted (≤) := sort_sorted _ _
have hpqr : ({p,q,r} : multiset ℕ+) = S := (sort_eq has_le.le {p, q, r}).symm
simp only [hpqr] at *
apply admissible_of_one_lt_sum_inv_aux hS _ H
simp only [S, length_sort]
dec_trivial
ext
{ ext, simp }
simp
intros
obtain ⟨a0, b0, c0, hf⟩ := exists_minimal h
cases int.mod_two_eq_zero_or_one a0 with hap hap
cases int.mod_two_eq_zero_or_one b0 with hbp hbp
{ cases int.mod_two_eq_zero_or_one b0 with hbp hbp, { exfalso, have h1 : 2 ∣ (int.gcd a0 b0 : ℤ), { exact int.dvd_gcd (int.dvd_of_mod_eq_zero hap) (int.dvd_of_mod_eq_zero hbp) }, rw int.gcd_eq_one_iff_coprime.mpr (coprime_of_minimal hf) at h1, revert h1, norm_num }, { exact ⟨b0, ⟨a0, ⟨c0, minimal_comm hf, hbp⟩⟩⟩ }}
exfalso
{ exfalso, have h1 : 2 ∣ (int.gcd a0 b0 : ℤ), { exact int.dvd_gcd (int.dvd_of_mod_eq_zero hap) (int.dvd_of_mod_eq_zero hbp) }, rw int.gcd_eq_one_iff_coprime.mpr (coprime_of_minimal hf) at h1, revert h1, norm_num }
have h1 : 2 ∣ (int.gcd a0 b0 : ℤ)
{ exact int.dvd_gcd (int.dvd_of_mod_eq_zero hap) (int.dvd_of_mod_eq_zero hbp) }
exact int.dvd_gcd (int.dvd_of_mod_eq_zero hap) (int.dvd_of_mod_eq_zero hbp)
rw int.gcd_eq_one_iff_coprime.mpr (coprime_of_minimal hf) at h1
revert h1
norm_num
{ exact ⟨b0, ⟨a0, ⟨c0, minimal_comm hf, hbp⟩⟩⟩ }
exact ⟨b0, ⟨a0, ⟨c0, minimal_comm hf, hbp⟩⟩⟩
exact ⟨a0, ⟨b0, ⟨c0 , hf, hap⟩⟩⟩
intros
rw [← stream.eta (zip f s₁ s₂)]
refl
intros
unfold tail drop
simp [nat.add_comm, nat.add_left_comm]
intros
cases b; simp
cases b
simp
simp
intros
rw [← int.add_assoc, int.add_right_neg, int.zero_add]
intros
have h := int.add_lt_add_right h (-a)
rwa [int.add_comm a b, int.add_neg_cancel_right] at h
intros
{rw [binary_rec], refl}
rw [binary_rec]
refl
intros
{induction z with z ih, rw [nat.mul_zero, nat.add_zero], rw [mul_succ, ← nat.add_assoc, add_mod_right, ih]}
induction z with z ih
rw [nat.mul_zero, nat.add_zero]
rw [mul_succ, ← nat.add_assoc, add_mod_right, ih]
intros
rw [←vsub_vadd_eq_vsub_sub, vsub_vadd]
intros
obtain ⟨m, rfl : n = N + m⟩ := le_iff_exists_add.mp hn
clear hn
induction m with m hm
{ simp }
simp
erw [prod_range_succ, hm]
simp [hu]
intros
rcases eq_or_ne c 0 with rfl|hc
simp
{ simp }
exact (smul_add_hom R M c).map_finsum_of_injective (smul_right_injective M hc) _
intros
rw [← image_univ, finprod_mem_image', finprod_mem_univ]
rwa univ_inter
intros
intros h
{ intros h, apply @zero_ne_one R, symmetry, rw [←nat.cast_one, ring_char.spec, h], }
apply @zero_ne_one R
symmetry
rw [←nat.cast_one, ring_char.spec, h]
intros
rw [← add_div, half_add_self]
intros
simp[num_eq_conts_a, (first_continuant_eq zeroth_s_eq)]
intros
rw [← h, mul_div_cancel _ hb]
intros
simpa only [← @div_self _ _ b h] using (div_sub_div_same a b b).symm
intros
{ ext, simp [lt_ceil] }
ext
simp [lt_ceil]
intros
{ ext, simp }
ext
simp
intros
rw [← lcm_erase_dup, erase_dup_ext.2, lcm_erase_dup, lcm_add]
{ rw [← lcm_erase_dup, erase_dup_ext.2, lcm_erase_dup, lcm_add], simp }
simp
intros
rw [bit1, bit0_zero, zero_add]
intros
rw [sub_eq_add_neg, neg_add_cancel_right a b]
intros
ring
intros
rw [nsmul_eq_mul', (n.cast_commute a).eq]
intros
by_cases hb : b = 0
rw [hb, div_zero] at h
{ rw [hb, div_zero] at h, exact eq_of_zero_eq_one h a b }
exact eq_of_zero_eq_one h a b
{ rwa [div_eq_iff_mul_eq hb, one_mul, eq_comm] at h }
rwa [div_eq_iff_mul_eq hb, one_mul, eq_comm] at h
intros
by_cases hij : c.rel i j
{ exact f.comm' i j hij }
exact f.comm' i j hij
rw [A.shape i j hij, B.shape i j hij, comp_zero, zero_comp]
intros
{ dsimp [of], rw [dif_neg h], }
dsimp [of]
rw [dif_neg h]
intros
simp only [funext_iff, subset_def, mem_mul_support, mul_indicator_apply_eq_self, not_imp_comm]
intros
rw [← map_sup_ker_eq_map, ← comap_bracket_eq h, map_comap_eq h, inf_eq_right]
{ rw [← map_sup_ker_eq_map, ← comap_bracket_eq h, map_comap_eq h, inf_eq_right], exact le_trans (lie_submodule.lie_le_left _ _) inf_le_left, }
exact le_trans (lie_submodule.lie_le_left _ _) inf_le_left
intros
obtain ⟨k, hk⟩ := h₁
tactic.unfreeze_local_instances
use k
apply lie_ideal.bot_of_map_eq_bot h₂
rw [eq_bot_iff, ← hk]
apply lie_ideal.derived_series_map_le
intros
rw [← mem_coe_submodule, ← mem_coe_submodule, ← mem_coe_submodule, inf_coe_to_submodule, submodule.mem_inf]
intros
rw f.is_ideal_morphism_def at h
rw [← lie_submodule.mem_coe, ← lie_ideal.coe_to_subalgebra, h, f.range_coe, set.mem_range]
intros
rw [←one_smul R x, ←zero_eq_one, zero_smul]
intros
rintro ⟨f, _⟩ ⟨g, _⟩ ⟨h⟩; congr
rintro ⟨f, _⟩ ⟨g, _⟩ ⟨h⟩
congr
intros
ext y
simp only [mem_support_iff, mem_map, exists_prop, mul_right_embedding_apply]
by_cases H : ∃ a, a * x = y
rcases H with ⟨a, rfl⟩
{ rcases H with ⟨a, rfl⟩, rw [mul_single_apply_aux f (λ _, mul_left_inj x)], simp [hr] }
rw [mul_single_apply_aux f (λ _, mul_left_inj x)]
simp [hr]
push_neg at H
{ push_neg at H, simp [mul_apply, H] }
simp [mul_apply, H]
intros
simpa [sub_eq_add_neg, add_assoc] using abv.add_le (a - b) (b - c)
intros
{ rw [inv_eq_one_div], exact div_lt_iff ha }
rw [inv_eq_one_div]
exact div_lt_iff ha
intros
rw [div_lt_iff hb, one_mul]
intros
simp only [← not_le, inv_nonneg]
intros
{ rw [sub_eq_add_neg, ←abs_neg b], exact abs_add a _ }
rw [sub_eq_add_neg, ←abs_neg b]
exact abs_add a _
intros
rw [div_eq_mul_inv, div_eq_mul_inv, ← mul_le_mul_iff_left a⁻¹, inv_mul_cancel_left, inv_mul_cancel_left, inv_le_inv_iff]
intros
by_cases 0 ≤ a
left
{ left, exact ⟨abs_eq_self.mpr h, h⟩ }
exact ⟨abs_eq_self.mpr h, h⟩
right
{ right, push_neg at h, exact ⟨abs_eq_neg_self.mpr (le_of_lt h), h⟩ }
push_neg at h
exact ⟨abs_eq_neg_self.mpr (le_of_lt h), h⟩
intros
{ convert mul_le_mul_right h, simp }
convert mul_le_mul_right h
simp
intros
simpa only [zero_add] using h 0
intros
simp
intros
simpa using multiset_prod_X_sub_C_next_coeff (s.1.map f)
intros
{ split, apply (act x).injective, rintro rfl, refl }
split
apply (act x).injective
rintro rfl
refl
intros
ext
{ext, simp}
simp
intros
simp
intros
simp only [algebra.smul_def, rel.mul_right h]
intros
simp [←untrop_inj_iff, with_top.add_eq_top]
intros
rw [← to_open_res R ⊤ U (hom_of_le le_top : U ⟶ ⊤), category.assoc, presheaf.germ_res]
{ rw [← to_open_res R ⊤ U (hom_of_le le_top : U ⟶ ⊤), category.assoc, presheaf.germ_res], refl }
refl
intros
ext1 n
induction n using nat.strong_rec' with n IH
cases n
simp
{ simp }
cases n
simp
{ simp }
simp only [right_inv, neg_inj]
unfold_coes
congr' 1
rw remove_zero_comp_of_pos _ _ (show 0 < n+2, by dec_trivial)
congr' 1
ext k
by_cases hk : k < n+2; simp [hk, IH]
by_cases hk : k < n+2
simp [hk, IH]
simp [hk, IH]
intros
refine ((h.norm_left.const_mul_left (∥c∥)).congr_left _).of_norm_left
exact λ x, (norm_smul _ _).symm
intros
simpa only [sub_eq_add_neg] using h₁.add_is_o h₂.neg_left hc
intros
rw differentiable_at.deriv_within (differentiable_at_inv.2 x_ne_zero) hxs
exact deriv_inv
intros
apply (hf.limsup_norm_slope_le hr).mono
assume z hz
refine lt_of_le_of_lt (mul_le_mul_of_nonneg_left (norm_sub_norm_le _ _) _) hz
exact inv_nonneg.2 (norm_nonneg _)
intros
simpa using h.neg.has_strict_deriv_at
intros
ext x : 1
by_cases h : differentiable_at 𝕜 f x
apply has_fderiv_within_at.fderiv_within _ unique_diff_within_at_univ
{ apply has_fderiv_within_at.fderiv_within _ unique_diff_within_at_univ, rw has_fderiv_within_at_univ, apply h.has_fderiv_at }
rw has_fderiv_within_at_univ
apply h.has_fderiv_at
have : ¬ differentiable_within_at 𝕜 f univ x
{ have : ¬ differentiable_within_at 𝕜 f univ x, by contrapose! h; rwa ← differentiable_within_at_univ, rw [fderiv_zero_of_not_differentiable_at h, fderiv_within_zero_of_not_differentiable_within_at this] }
contrapose! h
contrapose! h
contrapose! h; rwa ← differentiable_within_at_univ
contrapose! h; rwa ← differentiable_within_at_univ
rwa ← differentiable_within_at_univ
rwa ← differentiable_within_at_univ
rw [fderiv_zero_of_not_differentiable_at h, fderiv_within_zero_of_not_differentiable_within_at this]
intros
simp [differentiable_set_eq_D K hK, D, is_open_B.measurable_set, measurable_set.Inter_Prop, measurable_set.Inter, measurable_set.Union]
intros
apply continuous_on_iff_continuous_restrict.2
refine ((hf.antilipschitz hc).to_right_inv_on' _ (hf.to_local_equiv hc).right_inv').continuous
exact (λ x hx, (hf.to_local_equiv hc).map_target hx)
intros
ext1 x
ext1 n
change iterated_fderiv_within 𝕜 n f univ x = iterated_fderiv 𝕜 n f x
rw iterated_fderiv_within_univ
intros
have : times_cont_diff_within_at 𝕜 n g univ (f x) := h.times_cont_diff_at.times_cont_diff_within_at
exact this.comp x hf (subset_univ _)
intros
rcases hf 1 le_rfl with ⟨t, hst, p, hp⟩
rcases metric.mem_nhds_within_iff.mp hst with ⟨ε, ε0, hε⟩
replace hp : has_ftaylor_series_up_to_on 1 f p (metric.ball x ε ∩ insert x s) := hp.mono hε
clear hst hε t
rw [← insert_eq_of_mem (metric.mem_ball_self ε0), ← insert_inter] at hp
rcases hp.exists_lipschitz_on_with ((convex_ball _ _).inter hs) with ⟨K, t, hst, hft⟩
rw [inter_comm, ← nhds_within_restrict' _ (metric.ball_mem_nhds _ ε0)] at hst
exact ⟨K, t, hst, hft⟩
intros
assume x hx m hm
rw insert_eq_of_mem hx
refine ⟨s, self_mem_nhds_within, ftaylor_series_within 𝕜 f s, _⟩
split
assume y hy
{ assume y hy, simp only [ftaylor_series_within, continuous_multilinear_map.uncurry0_apply, iterated_fderiv_within_zero_apply] }
simp only [ftaylor_series_within, continuous_multilinear_map.uncurry0_apply, iterated_fderiv_within_zero_apply]
assume k hk y hy
{ assume k hk y hy, convert (Hdiff k (lt_of_lt_of_le hk hm) y hy).has_fderiv_within_at, simp only [ftaylor_series_within, iterated_fderiv_within_succ_eq_comp_left, continuous_linear_equiv.coe_apply, function.comp_app, coe_fn_coe_base], exact continuous_linear_map.curry_uncurry_left _ }
convert (Hdiff k (lt_of_lt_of_le hk hm) y hy).has_fderiv_within_at
simp only [ftaylor_series_within, iterated_fderiv_within_succ_eq_comp_left, continuous_linear_equiv.coe_apply, function.comp_app, coe_fn_coe_base]
exact continuous_linear_map.curry_uncurry_left _
assume k hk
{ assume k hk, exact Hcont k (le_trans hk hm) }
exact Hcont k (le_trans hk hm)
intros
rintro x hx
rw (convex_convex_hull 𝕜 _).mem_extreme_points_iff_convex_diff at hx
by_contra
exact (convex_hull_min (subset_diff.2 ⟨subset_convex_hull 𝕜 _, disjoint_singleton_right.2 h⟩) hx.2 hx.1).2 rfl
intros
have : ⟪y, x⟫_ℝ = ⟪x, y⟫_ℝ := by rw [←inner_conj_sym]; refl
simp [inner_add_add_self, this]
ring
intros
simp only [← nnreal.coe_le_coe, nnreal.coe_add, ← dist_nndist, dist_vadd_vadd_le]
intros
{ ext, refl }
ext
refl
intros
simpa only [←nnreal.coe_le_coe, nnreal.coe_mul, nnreal.coe_nat_cast] using norm_nsmul_le n a
intros
simp only [dist_eq_norm, ← finset.sum_sub_distrib] at *
exact norm_sum_le_of_le s h
intros
rw norm_def
{ rw norm_def, apply congr_arg, ext, simp }
apply congr_arg
ext
simp
intros
{ ext, refl }
ext
refl
intros
rcases normed_field.exists_one_lt_norm 𝕜 with ⟨c, hc⟩
refine op_norm_le_of_shell ε_pos hC hc (λ x _ hx, hf x _)
rwa ball_zero_eq
intros
simp
intros
unfold arg; split_ifs; simp [sub_eq_add_neg, arg, real.sin_arcsin (abs_le.1 (abs_im_div_abs_le_one x)).1 (abs_le.1 (abs_im_div_abs_le_one x)).2, real.sin_add, neg_div, real.arcsin_neg, real.sin_neg]
unfold arg; split_ifs
unfold arg
split_ifs
simp [sub_eq_add_neg, arg, real.sin_arcsin (abs_le.1 (abs_im_div_abs_le_one x)).1 (abs_le.1 (abs_im_div_abs_le_one x)).2, real.sin_add, neg_div, real.arcsin_neg, real.sin_neg]
simp [sub_eq_add_neg, arg, real.sin_arcsin (abs_le.1 (abs_im_div_abs_le_one x)).1 (abs_le.1 (abs_im_div_abs_le_one x)).2, real.sin_add, neg_div, real.arcsin_neg, real.sin_neg]
simp [sub_eq_add_neg, arg, real.sin_arcsin (abs_le.1 (abs_im_div_abs_le_one x)).1 (abs_le.1 (abs_im_div_abs_le_one x)).2, real.sin_add, neg_div, real.arcsin_neg, real.sin_neg]
intros
simp only [← one_div]
refine integral_deriv_eq_sub' _ _ _ (continuous_const.div _ (λ x, _)).continuous_on
{ norm_num }
norm_num
{ norm_num }
norm_num
{ continuity }
continuity
{ nlinarith }
nlinarith
intros
obtain ⟨x₀, hx₀⟩ := exists_max_root P hP
refine filter.eventually_at_top.mpr (⟨x₀ + 1, λ x hx h, _⟩)
exact absurd (hx₀ x h) (not_le.mpr (lt_of_lt_of_le (lt_add_one x₀) hx))
intros
rcases lt_trichotomy 0 y with H|rfl|H
{ simp [H, ne_of_gt, zero_rpow_of_pos, lt_irrefl] }
simp [H, ne_of_gt, zero_rpow_of_pos, lt_irrefl]
{ simp [lt_irrefl] }
simp [lt_irrefl]
{ simp [H, asymm H, ne_of_lt, zero_rpow_of_neg] }
simp [H, asymm H, ne_of_lt, zero_rpow_of_neg]
intros
simp [rpow_def]
intros
rw le_iff_eq_or_lt at hx
cases hx
rw [← hx, zero_rpow (ne_of_gt hz)]
{ rw [← hx, zero_rpow (ne_of_gt hz)], exact rpow_pos_of_pos (by rwa ← hx at hxy) _ }
exact rpow_pos_of_pos (by rwa ← hx at hxy) _
rw [rpow_def_of_pos hx, rpow_def_of_pos (lt_trans hx hxy), exp_lt_exp]
exact mul_lt_mul_of_pos_right (log_lt_log hx hxy) hz
intros
cases hx.lt_or_lt with hx hx
have := (has_strict_fderiv_at_rpow_of_neg (x, p) hx).comp_has_strict_deriv_at x ((has_strict_deriv_at_id x).prod (has_strict_deriv_at_const _ _))
{ have := (has_strict_fderiv_at_rpow_of_neg (x, p) hx).comp_has_strict_deriv_at x ((has_strict_deriv_at_id x).prod (has_strict_deriv_at_const _ _)), convert this, simp }
convert this
simp
simpa using (has_strict_deriv_at_id x).rpow (has_strict_deriv_at_const x p) hx
{ simpa using (has_strict_deriv_at_id x).rpow (has_strict_deriv_at_const x p) hx }
intros
exact_mod_cast (complex.has_strict_deriv_at_tan (by exact_mod_cast h)).real_of_complex
rw [← cos_pi_div_two_sub, ← cos_pi_div_six]
congr
ring
intros
rw ← sub_eq_zero
field_simp [cos, exp_neg, exp_ne_zero]
refine eq.congr _ rfl
ring
{ rw [arcsin, range_comp coe], simp [Icc] }
rw [arcsin, range_comp coe]
simp [Icc]
intros
rw [← equiv.eq_symm_apply]; simp
rw [← equiv.eq_symm_apply]
simp
intros
simp
intros
{ convert w (𝟙 X), tidy }
convert w (𝟙 X)
tidy
intros
convert unit_transfer_nat_trans _ _ (prod_comparison_nat_iso F A).inv B
ext
dsimp
simp
intros
ext
ext; simp only [map_iso_hom, iso.conj_Aut_hom, F.map_conj]
simp only [map_iso_hom, iso.conj_Aut_hom, F.map_conj]
intros
have h : f = 𝟙 j
cases f
{ cases f, cases f, ext, }
cases f
ext
rw h
simp
intros
classical
apply finset.induction_on O
exact ⟨is_cofiltered.nonempty.some, (by rintros - ⟨⟩)⟩
{ exact ⟨is_cofiltered.nonempty.some, (by rintros - ⟨⟩)⟩, }
rintros X O' nm ⟨S', w'⟩
{ rintros X O' nm ⟨S', w'⟩, use min X S', rintros Y mY, by_cases h : X = Y, { subst h, exact ⟨min_to_left _ _⟩, }, { exact ⟨min_to_right _ _ ≫ (w' (by finish)).some⟩, }, }
use min X S'
rintros Y mY
by_cases h : X = Y
{ subst h, exact ⟨min_to_left _ _⟩, }
subst h
exact ⟨min_to_left _ _⟩
{ exact ⟨min_to_right _ _ ≫ (w' (by finish)).some⟩, }
exact ⟨min_to_right _ _ ≫ (w' (by finish)).some⟩
intros
{ erw [inv_eq_inv α.symm β, eq_comm], refl }
erw [inv_eq_inv α.symm β, eq_comm]
refl
intros
dsimp [is_limit_whisker_equiv]
apply P.hom_ext
intro j
simp
intros
tidy
intros
{ ext; simp }
ext
ext; simp
simp
simp
intros
{ ext, simp [biproduct.components], }
ext
simp [biproduct.components]
intros
rw [←tensor_right_iff, comp_tensor_id, braiding_left_unitor_aux₂]
intros
rw [associator_naturality, inv_hom_id_assoc]
intros
{ ext, rw [←associator_hom_f, ←comp_f, iso.hom_inv_id], refl, }
ext
rw [←associator_hom_f, ←comp_f, iso.hom_inv_id]
refl
intros
simp [of_components]
intros
simp [of_mk_le]
intros
revert P
refine quotient.ind' _
intro P
rintro ⟨g, rfl⟩
exact ⟨f ≫ g, by simp⟩
intros
have h := contractible_distinguished T.obj₁
have f := complete_distinguished_triangle_morphism
specialize f (contractible_triangle C T.obj₁) T h H (𝟙 T.obj₁) T.mor₁
have t : (contractible_triangle C T.obj₁).mor₁ ≫ T.mor₁ = 𝟙 T.obj₁ ≫ T.mor₁
refl
refl
specialize f t
cases f with c f
rw ← f.left
simp only [limits.zero_comp, contractible_triangle_mor₂]
intros
change (f.app (op X) ≫ F.map g.op) (𝟙 X) = f.app (op Y) (𝟙 Y ≫ g)
rw ←f.naturality
dsimp
simp
intros
simp [size_up_to]
intros
split
assume H
{ assume H, rw H, exact single_length h }
rw H
exact single_length h
assume H
{ assume H, ext1, have A : c.blocks.length = 1 := H ▸ c.blocks_length, have B : c.blocks.sum = n := c.blocks_sum, rw eq_cons_of_length_one A at B ⊢, simpa [single_blocks] using B }
ext1
have A : c.blocks.length = 1 := H ▸ c.blocks_length
have B : c.blocks.sum = n := c.blocks_sum
rw eq_cons_of_length_one A at B ⊢
simpa [single_blocks] using B
intros
ext x
rw [accepts, DFA.accepts, eval, DFA.eval]
change list.foldl _ _ _ ∈ {S | _} ↔ _
finish
intros
simp [zero]
intros
induction n with n IH
refl
{refl}
apply (IH (le_of_lt H)).tail
rw iterate_succ_apply'
simp only [TM1.step, TM1.step_aux, tr, tape.mk'_nth_nat, tape.move_right_n_head, add_bottom_nth_snd, option.mem_def]
rw [stk_nth_val _ hL, list.nth_le_nth]
refl
rwa list.length_reverse
intros
cases x; simp [sum.traverse, id_map] with functor_norm; congr; refl
cases x; simp [sum.traverse, id_map] with functor_norm; congr
cases x; simp [sum.traverse, id_map] with functor_norm
cases x
simp [sum.traverse, id_map] with functor_norm
congr
simp [sum.traverse, id_map] with functor_norm
congr
intros
by_cases p; by_cases q; simp *
by_cases p; by_cases q
by_cases p
by_cases q
simp *
simp *
by_cases q
simp *
simp *
intros
cases cs with hd tl
{ simp [one_of, static.decorate_errors] }
simp [one_of, static.decorate_errors]
have : one_of (hd :: tl) (hd :: tl).to_buffer 0 = done 1 hd
{ have : one_of (hd :: tl) (hd :: tl).to_buffer 0 = done 1 hd, { simp [one_of_eq_done] }, simpa using not_of_ne this zero_ne_one }
{ simp [one_of_eq_done] }
simp [one_of_eq_done]
simpa using not_of_ne this zero_ne_one
intros
{ convert bounded.map, exact many he }
convert bounded.map
exact many he
intros
simp [decorate_errors, h]
intros
induction l with hd tl hl generalizing n
convert h
{ convert h, rw many_eq_done_nil at h, exact h.left.symm }
rw many_eq_done_nil at h
exact h.left.symm
rw [←many1_eq_done_iff_many_eq_done, many1_eq_done] at h
{ rw [←many1_eq_done_iff_many_eq_done, many1_eq_done] at h, obtain ⟨_, -, h⟩ := h, exact hl h }
obtain ⟨_, -, h⟩ := h
exact hl h
intros
simp [foldl_core]
intros
simp [norm_sq]
intros
rw ← of_real_inj; simp [cos_two_mul]
rw ← of_real_inj
simp [cos_two_mul]
intros
rw ← of_real_inj; simp [sinh_three_mul]
rw ← of_real_inj
simp [sinh_three_mul]
intros
rw [← of_real_cosh_of_real_re, of_real_im]
intros
have s1 := sin_add ((x + y) / 2) ((x - y) / 2)
have s2 := sin_sub ((x + y) / 2) ((x - y) / 2)
rw [div_add_div_same, add_sub, add_right_comm, add_sub_cancel, half_add_self] at s1
rw [div_sub_div_same, ←sub_add, add_sub_cancel', half_add_self] at s2
rw [s1, s2]
ring
simp [real.exp]
intros
simp only [bit1, add_monoid_hom.map_add, bit0_re, add_right_inj, one_re]
intros
ext
simp only [map_range_apply f, coe_add, pi.add_apply, hf']
intros
simp [h]
intros
ext j
{ ext j, by_cases h1 : j = i; by_cases h2 : f j ≠ 0; simp at h2; simp [h1, h2] }
by_cases h1 : j = i
by_cases h1 : j = i; by_cases h2 : f j ≠ 0; simp at h2; simp [h1, h2]
by_cases h1 : j = i; by_cases h2 : f j ≠ 0; simp at h2
by_cases h1 : j = i; by_cases h2 : f j ≠ 0
by_cases h2 : f j ≠ 0
simp at h2
simp [h1, h2]
simp at h2
simp [h1, h2]
by_cases h2 : f j ≠ 0
simp at h2
simp [h1, h2]
simp at h2
simp [h1, h2]
intros
simp [perm.extend_domain]
intros
{ ext i, cases i; refl }
ext i
cases i
cases i; refl
refl
refl
intros
simp [insert_nth_last]
intros
cases n
{ cases h }
cases h
rw [fin.coe_add, fin.coe_one, nat.mod_eq_of_lt (nat.succ_lt_succ _)]
exact h
intros
{ cases i, refl }
cases i
refl
intros
simpa [eq_empty_iff_forall_not_mem]
intros
rw [← not_nonempty_iff_eq_empty, nonempty_range_iff, not_not]
intros
simp only [mem_def, image_val, mem_erase_dup, multiset.mem_map, exists_prop]
intros
by_cases a ∈ s; [{rw [insert_eq_of_mem h], apply nat.le_add_right}, rw [card_insert_of_not_mem h]]
by_cases a ∈ s
rw [insert_eq_of_mem h]
apply nat.le_add_right
rw [card_insert_of_not_mem h]
intros
haveI := classical.dec_eq α; exact finset.induction_on s rfl (λ a s has ih, by simp only [bUnion_insert, image_union, ih])
haveI := classical.dec_eq α
exact finset.induction_on s rfl (λ a s has ih, by simp only [bUnion_insert, image_union, ih])
intros
classical
{ classical, simp [← card_union_eq, filter_union_filter_neg_eq, disjoint_filter], }
simp [← card_union_eq, filter_union_filter_neg_eq, disjoint_filter]
intros
{ contrapose! h, simp [h] }
contrapose! h
simp [h]
intros
change _ ↔ ∃ v ∈ s, x ∈ (f v).val
rw [←multiset.mem_sup, ←multiset.mem_to_finset, sup_to_finset]
simp_rw [val_to_finset]
intros
simp_rw [to_multiset_sum, finsupp.to_multiset_single, sum_nsmul, sum_multiset_singleton]
intros
ext
simp only [inf_apply, mem_support_iff, ne.def, finset.mem_union, finset.mem_filter, finset.mem_inter]
simp only [inf_eq_min, ← nonpos_iff_eq_zero, min_le_iff, not_or_distrib]
intros
{ ext, simp only [set.mem_univ, mem_univ, set.mem_to_finset] }
ext
simp only [set.mem_univ, mem_univ, set.mem_to_finset]
intros
{ ext i, simp [piecewise] }
ext i
simp [piecewise]
intros
simpa using exists_min_image univ f univ_nonempty
intros
simp
intros
simp [fin.univ_def, finset.fin_range]
intros
induction n; simp *
induction n
simp *
simp *
intros
{ rw int.lcm, apply nat.lcm_one_left }
rw int.lcm
apply nat.lcm_one_left
intros
induction n with n ih; simp [*, even_mul, pow_succ]
{ induction n with n ih; simp [*, even_mul, pow_succ], tauto }
induction n with n ih
simp [*, even_mul, pow_succ]
simp [*, even_mul, pow_succ]
tauto
intros
simp only [has_mem.mem, lazy_list.mem, or_imp_distrib, forall_and_distrib, forall_eq]
intros
induction l with b l ih
refl
{refl}
simp only [length, index_of_cons]
by_cases h : a = b
rw if_pos h
{rw if_pos h, exact nat.zero_le _}
exact nat.zero_le _
rw if_neg h
exact succ_le_succ ih
intros
cases l; refl
cases l
refl
refl
intros
refl
intros
induction l with hd tl hl generalizing n
{ simp }
simp
cases n; simp [hl]
{ cases n; simp [hl] }
cases n
simp [hl]
simp [hl]
intros
simp only [reduce_option, id.def, mem_filter_map, exists_eq_right]
intros
simp only [eq_nil_iff_forall_not_mem, mem_inter, not_and]
simp only [eq_nil_iff_forall_not_mem, mem_inter, not_and]; refl
refl
intros
{ induction l with c l', contradiction, use [c,l'], }
induction l with c l'
contradiction
use [c,l']
intros
induction l₁ with a l₁ IH
refl
{refl}
rw [cons_union, ← IH]
show erase_dup (a :: (l₁ ++ l₂)) = insert a (erase_dup (l₁ ++ l₂))
by_cases a ∈ erase_dup (l₁ ++ l₂); [ rw [erase_dup_cons_of_mem' h, insert_of_mem h], rw [erase_dup_cons_of_not_mem' h, insert_of_not_mem h]]
by_cases a ∈ erase_dup (l₁ ++ l₂)
rw [erase_dup_cons_of_mem' h, insert_of_mem h]
rw [erase_dup_cons_of_not_mem' h, insert_of_not_mem h]
intros
cases le_total l m with hlm hml
rw [← append_consecutive hnl hlm, filter_append, filter_le_of_top_le (le_refl l), filter_le_of_le_bot (le_refl l), nil_append]
{ rw [← append_consecutive hnl hlm, filter_append, filter_le_of_top_le (le_refl l), filter_le_of_le_bot (le_refl l), nil_append] }
{ rw [eq_nil_of_le hml, filter_le_of_top_le hml] }
rw [eq_nil_of_le hml, filter_le_of_top_le hml]
intros
induction l with a l IH generalizing t₁ t₂ p
simp
{simp}
by_cases a ∈ t₁
{ simp [h, p.subset h, IH (p.erase _)] }
simp [h, p.subset h, IH (p.erase _)]
{ simp [h, mt p.mem_iff.2 h, IH p] }
simp [h, mt p.mem_iff.2 h, IH p]
intros
simp only [succ_pos', lt_add_iff_pos_right, mem_range]
intros
rw [rotate_eq_rotate', rotate'_length]
intros
obtain ⟨n, rfl⟩ := h
exact ⟨_, (reverse_rotate _ _).symm⟩
intros
induction l
refl
cases l_hd with a' b
by_cases a = a'
subst a'
{ subst a', rw [erase_dupkeys_cons,lookup_kinsert,lookup_cons_eq] }
rw [erase_dupkeys_cons,lookup_kinsert,lookup_cons_eq]
rw [erase_dupkeys_cons,lookup_kinsert_ne h,l_ih,lookup_cons_ne]
{ rw [erase_dupkeys_cons,lookup_kinsert_ne h,l_ih,lookup_cons_ne], exact h }
exact h
intros
induction l with hd tl hl generalizing l' n
{ simp }
simp
cases l'
{ cases l', { simp }, { cases n, { simp }, { simp [hl] } } }
{ simp }
simp
cases n
{ cases n, { simp }, { simp [hl] } }
{ simp }
simp
{ simp [hl] }
simp [hl]
intros
{ ext i j, simp }
ext i j
simp
intros
ext x y
simp [update_column_apply, subsingleton.elim i y]
intros
simp [dot_product, add_mul, finset.sum_add_distrib]
intros
simp only [h, coe_scalar, one_apply_ne, ne.def, not_false_iff, pi.smul_apply, smul_zero]
intros
ext i j
rcases i
rcases i; rcases j; simp [from_blocks]
rcases i; rcases j
rcases j
simp [from_blocks]
simp [from_blocks]
rcases j
simp [from_blocks]
simp [from_blocks]
intros
{ ext, simp, }
ext
simp
intros
{ ext i j, refine fin.cases _ _ i; simp [vec_head, vec_tail] }
ext i j
refine fin.cases _ _ i
refine fin.cases _ _ i; simp [vec_head, vec_tail]
simp [vec_head, vec_tail]
simp [vec_head, vec_tail]
intros
rw [← singleton_add, ← singleton_add, add_assoc]
intros
induction l using quotient.induction_on
simpa using list.max_le_of_forall_le _ _ h
intros
{ ext i, simp }
ext i
simp
intros
simp only [expand, bind₁_X_left, alg_hom.id_apply, ring_hom.to_fun_eq_coe, eval₂_hom_C_left, alg_hom.coe_to_ring_hom, pow_one, alg_hom.coe_mk]
intros
rw [bind₂_monomial, f.map_one, one_mul]
intros
rw [mem_supported]
intros
rw [total_degree]
congr
funext m
exact (finsupp.card_to_multiset _).symm
intros
rw [add_mod_mod, mod_add_mod]
intros
cases b; [exact nat.bit0_ne_zero h, exact nat.bit1_ne_zero _]
cases b
exact nat.bit0_ne_zero h
exact nat.bit1_ne_zero _
intros
{ dunfold decreasing_induction, rw [le_rec_on_succ] }
dunfold decreasing_induction
rw [le_rec_on_succ]
intros
rw [test_bit, shiftr_eq_div_pow]
cases hm.lt_or_lt with hm hm
rw [nat.div_eq_zero, bodd_zero]
{ rw [nat.div_eq_zero, bodd_zero], exact nat.pow_lt_pow_of_lt_right one_lt_two hm }
exact nat.pow_lt_pow_of_lt_right one_lt_two hm
rw [pow_div hm.le zero_lt_two, ←nat.sub_add_cancel (nat.sub_pos_of_lt hm), pow_succ]
{ rw [pow_div hm.le zero_lt_two, ←nat.sub_add_cancel (nat.sub_pos_of_lt hm), pow_succ], simp }
simp
intros
refine one_div_le_one_div_of_le _ _
{ refine one_div_le_one_div_of_le _ _, exact nat.cast_add_one_pos _, simpa }
exact nat.cast_add_one_pos _
simpa
intros
suffices : (list.range l.length).zip_with (((λ (i a : ℕ), a * b ^ i) ∘ succ)) l = (list.range l.length).zip_with (λ i a, b * (a * b ^ i)) l
{ simp [this] }
simp [this]
congr
ext
simp [pow_succ]
ring
intros
have t := dvd_iff_dvd_of_digits 11 10 (-1 : ℤ) (by norm_num) n
rw of_digits_neg_one at t
exact t
intros
rw [← some_eq_coe]
simp only [lt_def, exists_prop_of_true, dom_some, forall_true_iff]
refl
intros
{ rw le_coe_iff, refine ⟨⟨_, h⟩, @nat.find_min' P _ _ _ h⟩ }
rw le_coe_iff
refine ⟨⟨_, h⟩, @nat.find_min' P _ _ _ h⟩
intros
induction n with n IH; simp
induction n with n IH
simp
{ have := nat.eq_zero_of_le_zero h, subst m, simp }
have := nat.eq_zero_of_le_zero h
subst m
simp
obtain he | hl := h.eq_or_lt
{ subst m, simp }
subst m
exact (IH (le_of_lt_succ hl)).mul_left _
intros
delta lcm; rw [nat.mul_div_cancel' ((gcd_dvd_left m n).trans (dvd_mul_right m n))]
delta lcm
rw [nat.mul_div_cancel' ((gcd_dvd_left m n).trans (dvd_mul_right m n))]
intros
rw [mul_comm m n, mul_comm k n, mul_comm (gcd m k) n, gcd_mul_left]
intros
{ rw [add_comm a, add_comm b] at h₂, exact h₁.add_left_cancel h₂ }
rw [add_comm a, add_comm b] at h₂
exact h₁.add_left_cancel h₂
intros
rw [mul_comm a, mul_comm b]; exact h.mul_left c
rw [mul_comm a, mul_comm b]
exact h.mul_left c
intros
rw [succ_eq_add_one, even_add]; simp [not_even_one]
rw [succ_eq_add_one, even_add]
simp [not_even_one]
intros
simpa only [pow_two] using not_exists_sq (by simpa only [pow_two] using hl) (by simpa only [pow_two] using hr)
intros
rw [← cast_to_int m, ← cast_to_int n, int.cast_lt, lt_to_int]
simp [num.of_nat']
intros
simp
intros
cases o; simp
cases o
simp
simp
intros
linarith
intros
simp [node3_l, all_node', and_assoc]
intros
rw [balance_r_eq_balance' hl hr sl sr H, size_balance' sl sr]
intros
rw [← bind_some_eq_map, bind_map, bind_some_eq_map]
intros
rw [W_dest', W_rec_eq]
intros
by_cases h : j = i
{ subst h, simp only [single_eq_same] }
subst h
simp only [single_eq_same]
{ simp only [single_eq_of_ne h, hf'] }
simp only [single_eq_of_ne h, hf']
intros
{ rw [← monomial_zero_one, coeff_monomial], simp }
rw [← monomial_zero_one, coeff_monomial]
simp
intros
simp [coeff_erase]
intros
rw [C_mul_X_pow_eq_monomial]
exact support_monomial' _ _
intros
rw [← C_1]; exact le_trailing_degree_C
rw [← C_1]
exact le_trailing_degree_C
intros
rw erase_lead_support
exact card_lt_card (erase_ssubset $ nat_degree_mem_support_of_nonzero h)
intros
induction k with k ih
{ simp, }
simp
{ simp [pow_succ', mul_X_comp, ih], }
simp [pow_succ', mul_X_comp, ih]
intros
rw [← C_1, hasse_deriv_C k _ hk]
intros
{ rw [lifts_iff_ring_hom_srange, mem_map_srange f], refl }
rw [lifts_iff_ring_hom_srange, mem_map_srange f]
refl
intros
revert h
refine multiset.induction_on t _ (λ a t ih ht, _)
simp only [multiset.not_mem_zero, forall_prop_of_true, forall_prop_of_false, multiset.map_zero, multiset.prod_zero, multiset.sum_zero, not_false_iff, forall_true_iff]
{ simp only [multiset.not_mem_zero, forall_prop_of_true, forall_prop_of_false, multiset.map_zero, multiset.prod_zero, multiset.sum_zero, not_false_iff, forall_true_iff], rw ← C_1, rw next_coeff_C_eq_zero }
rw ← C_1
rw next_coeff_C_eq_zero
rw [multiset.map_cons, multiset.prod_cons, multiset.map_cons, multiset.sum_cons, monic.next_coeff_mul, ih]
{ rw [multiset.map_cons, multiset.prod_cons, multiset.map_cons, multiset.sum_cons, monic.next_coeff_mul, ih], exacts [λ i hi, ht i (multiset.mem_cons_of_mem hi), ht a (multiset.mem_cons_self _ _), monic_multiset_prod_of_monic _ _ (λ b bs, ht _ (multiset.mem_cons_of_mem bs))] }
exacts [λ i hi, ht i (multiset.mem_cons_of_mem hi), ht a (multiset.mem_cons_self _ _), monic_multiset_prod_of_monic _ _ (λ b bs, ht _ (multiset.mem_cons_of_mem bs))]
intros
{ convert (prime_X_sub_C (0 : R)), simp }
convert (prime_X_sub_C (0 : R))
simp
intros
rw [← coeff_comp_degree_mul_degree hq, ← nat_degree_comp]
rw [← coeff_comp_degree_mul_degree hq, ← nat_degree_comp]; refl
refl
intros
mv_bisim x₀
rw [Ha,Hb,cofix.dest_corec,cofix.dest_corec]
rw [mvfunctor.map_map,← append_fun_comp_id]
refine liftr_map_last _ _ _ _ _
intros a
refine ⟨a,rfl,rfl⟩
intros
cases x with a f; exact Wequiv.abs a f a f rfl
cases x with a f
exact Wequiv.abs a f a f rfl
intros
rw [rat.mul_comm, rat.add_mul, rat.mul_comm, rat.mul_comm c a]
intros
cases d; refl
cases d
refl
intros
exact_mod_cast inv_coe_int_denom (by exact_mod_cast ha0 : 0 < (a : ℤ))
intros
cases q
{ cases q, refl }
refl
intros
simp [cantor_function_aux, h]
intros
rw mul_comm; apply mul_equiv_zero _ hf
rw mul_comm
apply mul_equiv_zero _ hf
intros
have := h.inv_add_inv_conj
rw [← eq_sub_iff_add_eq', one_div, inv_eq_iff] at this
field_simp [← this, h.ne_zero]
intros
rw [div_eq_mul_inv, mul_assoc, inv_mul_cancel h0 hI, mul_one]
intros
simp [ennreal.of_real]
intros
simp
intros
{ unfold_coes, simp [real.to_ereal, option.some_inj] }
unfold_coes
simp [real.to_ereal, option.some_inj]
intros
simp only [abs_sub_lt_iff, sub_lt_iff_lt_add, is_st, and_comm, add_comm]
intros
rw [← nnreal.coe_le_coe, real.coe_to_nnreal p hp]
intros
rw [div_eq_inv_mul, div_eq_inv_mul, real.to_nnreal_mul (inv_nonneg.2 hy), real.to_nnreal_inv]
intros
induction l with a l IH; simp [ret_mem]; exact think_mem (mem_map _ IH)
induction l with a l IH; simp [ret_mem]
induction l with a l IH
simp [ret_mem]
simp [ret_mem]
exact think_mem (mem_map _ IH)
intros
rw [ite_inter_inter, ite_same]
intros
split
refine λ h, (λ a ha b hb, _)
{ refine λ h, (λ a ha b hb, _), exact set_coe.ext_iff.2 (@subsingleton.elim s h ⟨a, ha⟩ ⟨b, hb⟩) }
exact set_coe.ext_iff.2 (@subsingleton.elim s h ⟨a, ha⟩ ⟨b, hb⟩)
exact λ h, subsingleton.intro (λ a b, set_coe.ext (h a.property b.property))
{ exact λ h, subsingleton.intro (λ a b, set_coe.ext (h a.property b.property)) }
intros
{ ext ⟨x, y⟩, simp [and_or_distrib_left] }
ext ⟨x, y⟩
simp [and_or_distrib_left]
intros
{ ext, simp [pi, or_imp_distrib, forall_and_distrib] }
ext
simp [pi, or_imp_distrib, forall_and_distrib]
intros
ext
split
rintro ⟨a, _, ha, ⟨b, c, hb, hc, rfl⟩, rfl⟩
{ rintro ⟨a, _, ha, ⟨b, c, hb, hc, rfl⟩, rfl⟩, refine ⟨a, b, c, ha, hb, hc, rfl⟩ }
refine ⟨a, b, c, ha, hb, hc, rfl⟩
rintro ⟨a, b, c, ha, hb, hc, rfl⟩
{ rintro ⟨a, b, c, ha, hb, hc, rfl⟩, refine ⟨a, _, ha, ⟨b, c, hb, hc, rfl⟩, rfl⟩ }
refine ⟨a, _, ha, ⟨b, c, hb, hc, rfl⟩, rfl⟩
intros
rw ← image_univ; exact (countable_encodable _).image _
rw ← image_univ
exact (countable_encodable _).image _
intros
{ ext, rw [set.finite.mem_to_finset, mem_coe] }
ext
rw [set.finite.mem_to_finset, mem_coe]
intros
rw [←image_univ, maps_image_to]
intros
{ intros i ht, by_cases hs : i ∈ s; simp [hf i ht, hg i ht, hs] }
intros i ht
by_cases hs : i ∈ s
by_cases hs : i ∈ s; simp [hf i ht, hg i ht, hs]
simp [hf i ht, hg i ht, hs]
simp [hf i ht, hg i ht, hs]
intros
rw [← Icc_diff_both, diff_diff_cancel_left]
{ rw [← Icc_diff_both, diff_diff_cancel_left], simp [insert_subset, h] }
simp [insert_subset, h]
intros
ext1 x
simp_rw [mem_union, mem_Ioc, mem_Ioi, min_lt_iff]
by_cases hc : c < x
{ tauto }
tauto
have hxb : x ≤ b := (le_of_not_gt hc).trans h₁
{ have hxb : x ≤ b := (le_of_not_gt hc).trans h₁, tauto }
tauto
intros
simp [← Ioi_inter_Iic]
intros
simp
intros
simp [← Ici_inter_Iio, h]
intros
simp only [eq_univ_iff_forall, mem_Union]
intros
rw [lt_iff_le_not_le, not_le_iff_exists]
intros
intros y
cases y with j y
cases h₁ j with i hi
subst j
cases h₂ i y with x hx
subst y
exact ⟨⟨i, x⟩, rfl⟩
intros
ext i : 1; cases i; refl
ext i : 1; cases i
ext i : 1
cases i
intros
casesI n
{ exfalso, exact nat.not_lt_zero 0 (fact.out _) }
exfalso
exact nat.not_lt_zero 0 (fact.out _)
{ apply fin.coe_coe_eq_self }
apply fin.coe_coe_eq_self
intros
rw [mul_comm, mul_inv_of_unit a h]
intros
rw [hf.map_mul, hf.map_inv] at h
rw [←inv_inv (f b), eq_inv_of_mul_eq_one h]
intros
simpa only [not_lt] using not_congr (f.iterate_pos_lt_iff hn)
intros
simpa only [h.comp_eq] using inv_on_fixed_pts_comp f g
intros
let K := p.splitting_field
let L := q.splitting_field
haveI : fact (p.splits (algebra_map F L)) := ⟨hpq⟩
let ϕ : (L ≃ₐ[K] L) ≃* (q.map (algebra_map F K)).gal := (is_splitting_field.alg_equiv L (q.map (algebra_map F K))).aut_congr
have ϕ_inj : function.injective ϕ.to_monoid_hom := ϕ.injective
haveI : is_solvable (K ≃ₐ[F] K) := hp
haveI : is_solvable (L ≃ₐ[K] L) := solvable_of_solvable_injective ϕ_inj
exact is_solvable_of_is_scalar_tower F p.splitting_field q.splitting_field
intros
obtain ⟨v, hv, hxv, hyv⟩ := lifts.exists_max_two hc hx hy
obtain ⟨w, hw, hzw, hvw⟩ := lifts.exists_max_two hc hz hv
exact ⟨w, hw, le_trans hxv hvw, le_trans hyv hvw, hzw⟩
intros
cases char_p.exists K with p hp
letI := hp
rcases finite_field.card K p with ⟨⟨n, npos⟩, ⟨hp, hn⟩⟩
haveI : fact p.prime := ⟨hp⟩
dsimp at hn
rw hn at *
rw ← map_expand_pow_char
rw [frobenius_pow hn, ring_hom.one_def, map_id]
intros
rw [finset_basis, basis.range_reindex, basis.range_of_vector_space]
intros
haveI : is_galois F p.splitting_field := is_galois.of_separable_splitting_field hp
exact is_galois.card_aut_eq_finrank F p.splitting_field
intros
simp_rw [separable_def, derivative_map, is_coprime_map]
intros
by_cases h : m = m'
rw h at h_expand
{ rw h at h_expand, have expand_deg : ((expand F (q ^ m')) g).nat_degree = (expand F (q ^ m') g').nat_degree, by rw h_expand, rw [nat_degree_expand (q^m') g, nat_degree_expand (q^m') g'] at expand_deg, apply nat.eq_of_mul_eq_mul_left (pow_pos hq.1.pos m'), rw [mul_comm] at expand_deg, rw expand_deg, rw [mul_comm] }
have expand_deg : ((expand F (q ^ m')) g).nat_degree = (expand F (q ^ m') g').nat_degree
rw h_expand
rw h_expand
rw [nat_degree_expand (q^m') g, nat_degree_expand (q^m') g'] at expand_deg
apply nat.eq_of_mul_eq_mul_left (pow_pos hq.1.pos m')
rw [mul_comm] at expand_deg
rw expand_deg
rw [mul_comm]
cases ne.lt_or_lt h
{ cases ne.lt_or_lt h, { exact contraction_degree_eq_aux q g g' m m' h_expand h_1 hg }, { exact (contraction_degree_eq_aux q g' g m' m h_expand.symm h_1 hg').symm, } }
{ exact contraction_degree_eq_aux q g g' m m' h_expand h_1 hg }
exact contraction_degree_eq_aux q g g' m m' h_expand h_1 hg
exact (contraction_degree_eq_aux q g' g m' m h_expand.symm h_1 hg').symm
{ exact (contraction_degree_eq_aux q g' g m' m h_expand.symm h_1 hg').symm, }
intros
rw [remove_factor, nat_degree_div_by_monic _ (monic_X_sub_C _), nat_degree_map, nat_degree_X_sub_C]
intros
rw [angle_comm, angle_smul_right_of_neg y x hr, angle_comm]
intros
simp_rw [sum_points_with_circumcenter, centroid_weights_with_circumcenter, add_zero, ←fs.sum_centroid_weights_eq_one_of_nonempty ℝ h, set.sum_indicator_subset _ fs.subset_univ]
rcongr
intros
simpa only [ext_chart_at_source] using f.closure_support_subset_ext_chart_at_source
intros
ext x : 1
simp only [mfderiv_within, mfderiv] with mfld_simps
rw mdifferentiable_within_at_univ
intros
haveI : locally_compact_space H := I.locally_compact
haveI : locally_compact_space M := charted_space.locally_compact H
haveI : normal_space M := normal_of_paracompact_t2
have hB := λ x hx, smooth_bump_function.nhds_basis_support I (hU x hx)
rcases refinement_of_locally_compact_sigma_compact_of_nhds_basis_set hs hB with ⟨ι, c, f, hf, hsub', hfin⟩
choose hcs hfU using hf
rcases exists_subset_Union_closed_subset hs (λ i, (f i).open_support) (λ x hx, hfin.point_finite x) hsub' with ⟨V, hsV, hVc, hVf⟩
choose r hrR hr using λ i, (f i).exists_r_pos_lt_subset_ball (hVc i) (hVf i)
refine ⟨ι, ⟨c, λ i, (f i).update_r (r i) (hrR i), hcs, _, λ x hx, _⟩, λ i, _⟩
{ simpa only [smooth_bump_function.support_update_r] }
simpa only [smooth_bump_function.support_update_r]
refine (mem_Union.1 $ hsV hx).imp (λ i hi, _)
{ refine (mem_Union.1 $ hsV hx).imp (λ i hi, _), exact ((f i).update_r _ _).eventually_eq_one_of_dist_lt ((f i).support_subset_source $ hVf _ hi) (hr i hi).2 }
exact ((f i).update_r _ _).eventually_eq_one_of_dist_lt ((f i).support_subset_source $ hVf _ hi) (hr i hi).2
simpa only [coe_mk, smooth_bump_function.support_update_r] using hfU i
{ simpa only [coe_mk, smooth_bump_function.support_update_r] using hfU i }
intros
rw ← ext_chart_at_source I
{ rw ← ext_chart_at_source I, exact ext_chart_preimage_open_of_open' I x hs }
exact ext_chart_preimage_open_of_open' I x hs
intros
simp only [times_cont_mdiff_within_at_iff'', continuous_within_at_pi, times_cont_diff_within_at_pi, forall_and_distrib, written_in_ext_chart_at, ext_chart_model_space_eq_id, (∘), local_equiv.refl_coe, id]
intros
have key : ∀ g h, quotient.mk' g = quotient.mk' h ↔ h * g⁻¹ ∈ H := @quotient.eq' G (quotient_group.right_rel H)
simp_rw [mem_right_transversals_iff_exists_unique_mul_inv_mem, set_like.mem_coe, ←key]
exact ⟨λ h q, quotient.induction_on' q h, λ h g, h (quotient.mk' g)⟩
intros
rw map_comp
{ rw map_comp, refl }
refl
intros
have : red ((x1, b1) :: L₁) ([(x2, b2)] ++ L₂)
from H2
rcases to_append_iff.1 this with ⟨_ | ⟨p, L₃⟩, L₄, eq, h₁, h₂⟩
{ simp [nil_iff] at h₁, contradiction }
simp [nil_iff] at h₁
contradiction
cases eq
{ cases eq, show red (L₃ ++ L₄) ([(x1, bnot b1), (x2, b2)] ++ L₂), apply append_append _ h₂, have h₁ : red ((x1, bnot b1) :: (x1, b1) :: L₃) [(x1, bnot b1), (x2, b2)], { exact cons_cons h₁ }, have h₂ : red ((x1, bnot b1) :: (x1, b1) :: L₃) L₃, { exact step.cons_bnot_rev.to_red }, rcases church_rosser h₁ h₂ with ⟨L', h₁, h₂⟩, rw [red_iff_irreducible H1] at h₁, rwa [h₁] at h₂ }
show red (L₃ ++ L₄) ([(x1, bnot b1), (x2, b2)] ++ L₂)
apply append_append _ h₂
have h₁ : red ((x1, bnot b1) :: (x1, b1) :: L₃) [(x1, bnot b1), (x2, b2)]
{ exact cons_cons h₁ }
exact cons_cons h₁
have h₂ : red ((x1, bnot b1) :: (x1, b1) :: L₃) L₃
{ exact step.cons_bnot_rev.to_red }
exact step.cons_bnot_rev.to_red
rcases church_rosser h₁ h₂ with ⟨L', h₁, h₂⟩
rw [red_iff_irreducible H1] at h₁
rwa [h₁] at h₂
intros
rw [← mk_eq_monoid_of_mk', lift_on₂_mk]
intros
obtain ⟨c, hc⟩ := f.eq_iff_exists.1 h
rw [←mul_one (g x), ←is_unit.mul_lift_right_inv (g.mrestrict S) hg c]
show _ * (g c * _) = _
rw [←mul_assoc, ←g.map_mul, hc, mul_inv_left hg, g.map_mul, mul_comm]
intros
simpa [← order_of_of_add_eq_add_order_of, of_add_nsmul] using order_of_pow' _ h
intros
rw ← lcm_cycle_type
exact dvd_lcm h
intros
rw [←lcm_cycle_type, ht.cycle_type, multiset.lcm_singleton, normalize_eq]
intros
by_cases hx : f x = x
{ rwa [if_pos hx, cycle_of_eq_one_iff] }
rwa [if_pos hx, cycle_of_eq_one_iff]
{ rwa [if_neg hx, hf.cycle_of_eq] }
rwa [if_neg hx, hf.cycle_of_eq]
intros
rw [cycle_range, of_left_inverse'_eq_of_injective, ←function.embedding.to_equiv_range_eq_of_injective, ←via_fintype_embedding, via_fintype_embedding_apply_not_mem_range]
simpa
intros
have h' : nodup (l.rotate 1)
{ simpa using h }
simpa using h
by_cases hl : ∀ (x : α), l ≠ [x]
have hl' : ∀ (x : α), l.rotate 1 ≠ [x]
{ have hl' : ∀ (x : α), l.rotate 1 ≠ [x], { intro, rw [ne.def, rotate_eq_iff], simpa using hl _ }, ext x, by_cases hx : x ∈ l.rotate 1, { obtain ⟨k, hk, rfl⟩ := nth_le_of_mem hx, rw [form_perm_apply_nth_le _ h', nth_le_rotate l, nth_le_rotate l, form_perm_apply_nth_le _ h], simp }, { rw [form_perm_apply_of_not_mem _ _ hx, form_perm_apply_of_not_mem], simpa using hx } }
intro
{ intro, rw [ne.def, rotate_eq_iff], simpa using hl _ }
rw [ne.def, rotate_eq_iff]
simpa using hl _
ext x
by_cases hx : x ∈ l.rotate 1
obtain ⟨k, hk, rfl⟩ := nth_le_of_mem hx
{ obtain ⟨k, hk, rfl⟩ := nth_le_of_mem hx, rw [form_perm_apply_nth_le _ h', nth_le_rotate l, nth_le_rotate l, form_perm_apply_nth_le _ h], simp }
rw [form_perm_apply_nth_le _ h', nth_le_rotate l, nth_le_rotate l, form_perm_apply_nth_le _ h]
simp
rw [form_perm_apply_of_not_mem _ _ hx, form_perm_apply_of_not_mem]
{ rw [form_perm_apply_of_not_mem _ _ hx, form_perm_apply_of_not_mem], simpa using hx }
simpa using hx
push_neg at hl
{ push_neg at hl, obtain ⟨x, rfl⟩ := hl, simp }
obtain ⟨x, rfl⟩ := hl
simp
intros
intro
simp only [and_imp, perm.coe_mul, function.comp_app, ne.def, mem_support, mem_insert, mem_sdiff, mem_singleton]
push_neg
rintro ha ⟨hx, hy⟩ H
rw [swap_apply_eq_iff, swap_apply_of_ne_of_ne hx hy] at H
exact ha H
intros
induction n with n ih
rwa [derived_series_zero, derived_series_zero, top_le_iff, ← monoid_hom.range_eq_map, ← monoid_hom.range_top_iff_surjective.mpr]
{ rwa [derived_series_zero, derived_series_zero, top_le_iff, ← monoid_hom.range_eq_map, ← monoid_hom.range_top_iff_surjective.mpr], }
simp only [*, derived_series_succ, commutator_le_map_commutator]
{ simp only [*, derived_series_succ, commutator_le_map_commutator], }
intros
simp_rw [←set_like.mem_coe] at ha
simp only [image_range_order_of, set.eq_univ_iff_forall.mpr ha]
convert set.to_finset_univ
intros
change _ = 2^2
haveI : fact(nat.prime 2) := fact.mk (nat.prime_two)
apply order_of_eq_prime_pow
intro h
{ intro h, simp only [pow_one, xa_sq] at h, injection h with h', apply_fun zmod.val at h', apply_fun ( / n) at h', simp only [zmod.val_nat_cast, zmod.val_zero, nat.zero_div, nat.mod_mul_left_div_self, nat.div_self hpos.1] at h', norm_num at h' }
simp only [pow_one, xa_sq] at h
injection h with h'
apply_fun zmod.val at h'
apply_fun ( / n) at h'
simp only [zmod.val_nat_cast, zmod.val_zero, nat.zero_div, nat.mod_mul_left_div_self, nat.div_self hpos.1] at h'
norm_num at h'
{ norm_num }
norm_num
intros
rw [range_eq_map, range_eq_map]; exact (⊤ : subgroup G).map_map g f
rw [range_eq_map, range_eq_map]
exact (⊤ : subgroup G).map_map g f
intros
simp only [infi, coe_Inf, set.bInter_range]
intros
simp_rw [set_like.le_def, ←sylow.smul_eq_iff_mem_normalizer]
simp_rw [set_like.le_def, ←sylow.smul_eq_iff_mem_normalizer]; exact subtype.forall
exact subtype.forall
intros
conv_lhs { rw [vector_span_eq_span_vsub_set_left k hp, ←set.insert_eq_of_mem hp, ←set.insert_diff_singleton, set.image_insert_eq] }
simp [submodule.span_insert_eq_span]
{ ext x, fin_cases x; simp }
ext x
fin_cases x
fin_cases x; simp
simp
simp
intros
simp only [line_map_apply_module]
exact add_le_add_left (smul_le_smul_of_nonneg hb hr) _
intros
simp only [← union_singleton, span_union, mem_sup, mem_span_singleton, exists_prop, exists_exists_eq_and]
rw [exists_comm]
simp only [eq_comm, add_comm, exists_and_distrib_left]
intros
simp [disjoint_def]
intros
simp
intros
rw set_like.le_def
intros m h
change f₁ m + f₂ m ∈ q
change f₁ m ∈ q ∧ f₂ m ∈ q at h
apply q.add_mem h.1 h.2
intros
let f_i : M →ₗ[R] R := { to_fun := λ x, f x i, map_add' := λ _ _, by rw [hadd, pi.add_apply], map_smul' := λ _ _, by { simp [hsmul, pi.smul_apply] } }
have : (finsupp.lapply i) ∘ₗ ↑b.repr = f_i
refine b.ext (λ j, _)
{ refine b.ext (λ j, _), show b.repr (b j) i = f (b j) i, rw [b.repr_self, f_eq] }
show b.repr (b j) i = f (b j) i
rw [b.repr_self, f_eq]
calc b.repr x i = f_i x : by { rw ← this, refl } ... = f x i : rfl
intros
refl
intros
rw [matrix.to_bilin, bilin_form.to_matrix, linear_equiv.symm_trans_apply, ← matrix.to_bilin']
simp only [congr_symm, congr_apply, linear_equiv.symm_symm, matrix.to_bilin'_apply, basis.equiv_fun_apply]
intros
ext
simp only [linear_map.comp_apply, alg_hom.to_linear_map_apply]
induction x using clifford_algebra.induction
simp
case h_grade0 : { simp }
simp
case h_grade1 : { simp }
case h_mul : a b ha hb { simp only [ha, hb, reverse.map_mul, alg_hom.map_mul], }
case h_add : a b ha hb { simp only [ha, hb, reverse.map_add, alg_hom.map_add], }
intros
haveI := classical.dec_eq M
{ haveI := classical.dec_eq M, rw [det_eq_det_to_matrix_of_finset b.reindex_finset_range, det_to_matrix_eq_det_to_matrix b] }
rw [det_eq_det_to_matrix_of_finset b.reindex_finset_range, det_to_matrix_eq_det_to_matrix b]
intros
rw [finsupp.total_apply, finsupp.sum, linear_map.map_sum, linear_map.sum_apply]
simp_rw [linear_map.map_smul, linear_map.smul_apply, to_dual_apply, smul_eq_mul, mul_boole, finset.sum_ite_eq']
split_ifs with h
{ refl }
refl
{ rw finsupp.not_mem_support_iff.mp h }
rw finsupp.not_mem_support_iff.mp h
intros
fsplit
intro h
{ intro h, by_cases h' : finrank K V = 0, { use 0, intro w, use 0, haveI := finrank_zero_iff.mp h', apply subsingleton.elim, }, { replace h' := zero_lt_iff.mpr h', have : finrank K V = 1, { linarith }, obtain ⟨v, -, p⟩ := finrank_eq_one_iff'.mp this, use ⟨v, p⟩, }, }
by_cases h' : finrank K V = 0
use 0
{ use 0, intro w, use 0, haveI := finrank_zero_iff.mp h', apply subsingleton.elim, }
intro w
use 0
haveI := finrank_zero_iff.mp h'
apply subsingleton.elim
replace h' := zero_lt_iff.mpr h'
{ replace h' := zero_lt_iff.mpr h', have : finrank K V = 1, { linarith }, obtain ⟨v, -, p⟩ := finrank_eq_one_iff'.mp this, use ⟨v, p⟩, }
have : finrank K V = 1
linarith
{ linarith }
obtain ⟨v, -, p⟩ := finrank_eq_one_iff'.mp this
use ⟨v, p⟩
rintro ⟨v, p⟩
{ rintro ⟨v, p⟩, exact finrank_le_one v p, }
exact finrank_le_one v p
intros
have := dim_self K
rw [←finrank_eq_dim] at this
exact_mod_cast this
intros
rw [← total_single, ← unique_single l]
intros
let P := (finsupp.linear_equiv_fun_on_fintype R R β)
let Q := (finsupp.linear_equiv_fun_on_fintype R R α).symm
exact card_le_of_surjective R ((P.to_linear_map.comp f).comp Q.to_linear_map) ((P.surjective.comp i).comp Q.surjective)
intros
convert linear_independent.image_of_comp s f id hs
intros
rw [disjoint_def] at h
have hy : y = 0
from subtype.eq (h y (hxy ▸ x.2) y.2)
have hx : x = 0
from subtype.eq (hxy.trans $ congr_arg _ hy)
simp [*]
intros
rw [to_square_block_def', to_square_block_def]
apply equiv_block_det
intro x
apply (fin.ext_iff _ _).symm
intros
simp [det_apply, univ_unique]
intros
simp_rw [linear_map.to_matrix_alg_equiv, alg_equiv.of_linear_equiv_apply, linear_map.to_matrix_id]
intros
simp [transvection, matrix.add_mul, matrix.mul_add, h, h.symm, add_smul, add_assoc, std_basis_matrix_add]
intros
simpa using map_piecewise_smul f c m finset.univ
intros
simp only [linear_map.ext_iff, pi_apply, funext_iff]
simp only [linear_map.ext_iff, pi_apply, funext_iff]; exact ⟨λh a b, h b a, λh a b, h b a⟩
exact ⟨λh a b, h b a, λh a b, h b a⟩
intros
ext
ext; simp only [map_zero, coprod_apply, inr_apply, zero_add, comp_apply]
simp only [map_zero, coprod_apply, inr_apply, zero_add, comp_apply]
intros
ext
ext; refl
refl
intros
ext b
ext b; simp
simp
intros
rw [lift_compr₂ f, lift_mk, linear_map.comp_id]
intros
simp only [← coe_ltensor_hom, map_neg]
intros
by_cases h : P; simp [h]
{ by_cases h : P; simp [h] }
by_cases h : P
simp [h]
simp [h]
intros
rw [← iterate_succ, nat.succ_pred_eq_of_pos hn]
intros
convert measurable.ennreal_tsum h
ext1 x
exact tsum_apply (pi.summable.2 (λ _, ennreal.summable))
intros
rw [closed_ball_pi _ hr, pi_pi]
intros
simp_rw [prod_apply hs, lintegral_eq_zero_iff (measurable_measure_prod_mk_left hs)]
intros
convert integrable_prod_iff (h1f.prod_swap) using 1
{ convert integrable_prod_iff (h1f.prod_swap) using 1, rw [integrable_swap_iff] }
rw [integrable_swap_iff]
intros
rw [h, to_jordan_decomposition_to_signed_measure]
intros
suffices h_and : f ≤ᵐ[μ.restrict t] 0 ∧ 0 ≤ᵐ[μ.restrict t] f
from h_and.1.mp (h_and.2.mono (λ x hx1 hx2, le_antisymm hx2 hx1))
refine ⟨_, ae_nonneg_restrict_of_forall_set_integral_nonneg hf_int_finite (λ s hs hμs, (hf_zero s hs hμs).symm.le) ht hμt⟩
suffices h_neg : 0 ≤ᵐ[μ.restrict t] -f
refine h_neg.mono (λ x hx, _)
{ refine h_neg.mono (λ x hx, _), rw pi.neg_apply at hx, simpa using hx, }
rw pi.neg_apply at hx
simpa using hx
refine ae_nonneg_restrict_of_forall_set_integral_nonneg (λ s hs hμs, (hf_int_finite s hs hμs).neg) (λ s hs hμs, _) ht hμt
simp_rw pi.neg_apply
rw [integral_neg, neg_nonneg]
exact (hf_zero s hs hμs).le
intros
rcases hfm with ⟨f', hf'_meas, hf_ae⟩
rcases hgm with ⟨g', hg'_meas, hg_ae⟩
refine ⟨f'-g', @measurable.sub _ _ _ _ m _ _ _ hf'_meas hg'_meas, hf_ae.mp (hg_ae.mono (λ x hx1 hx2, _))⟩
simp_rw pi.sub_apply
rw [hx1, hx2]
intros
rw ← mem_ℒp_one_iff_integrable at hf ⊢
{ rw ← mem_ℒp_one_iff_integrable at hf ⊢, exact hf.inner_const c, }
exact hf.inner_const c
intros
simpa using hg.norm_comp_Lp_sub_le g0 f 0
intros
rw ennreal.tendsto_at_top_zero
intros ε hε
have h_B : ∃ (N : ℕ), B N ≤ ε
suffices h_tendsto_zero : ∃ (N : ℕ), ∀ n : ℕ, N ≤ n → B n ≤ ε
{ suffices h_tendsto_zero : ∃ (N : ℕ), ∀ n : ℕ, N ≤ n → B n ≤ ε, from ⟨h_tendsto_zero.some, h_tendsto_zero.some_spec _ (le_refl _)⟩, exact (ennreal.tendsto_at_top_zero.mp (ennreal.tendsto_at_top_zero_of_tsum_ne_top hB)) ε hε, }
from ⟨h_tendsto_zero.some, h_tendsto_zero.some_spec _ (le_refl _)⟩
exact (ennreal.tendsto_at_top_zero.mp (ennreal.tendsto_at_top_zero_of_tsum_ne_top hB)) ε hε
cases h_B with N h_B
refine ⟨N, λ n hn, _⟩
have h_sub : snorm (f n - f_lim) p μ ≤ at_top.liminf (λ m, snorm (f n - f m) p μ)
refine snorm_lim_le_liminf_snorm (λ m, (hf n).sub (hf m)) (f n - f_lim) _
{ refine snorm_lim_le_liminf_snorm (λ m, (hf n).sub (hf m)) (f n - f_lim) _, refine h_lim.mono (λ x hx, _), simp_rw sub_eq_add_neg, exact tendsto.add tendsto_const_nhds (tendsto.neg hx), }
refine h_lim.mono (λ x hx, _)
simp_rw sub_eq_add_neg
exact tendsto.add tendsto_const_nhds (tendsto.neg hx)
refine h_sub.trans _
refine liminf_le_of_frequently_le' (frequently_at_top.mpr _)
refine λ N1, ⟨max N N1, le_max_right _ _, _⟩
exact (h_cau N n (max N N1) hn (le_max_left _ _)).le.trans h_B
intros
{ simp_rw snorm_ess_sup, exact ess_sup_mono_measure hμν, }
simp_rw snorm_ess_sup
exact ess_sup_mono_measure hμν
intros
simpa only [← pi.list_prod_apply] using l.measurable_prod' hl
intros
rw [integral, norm_eq_integral]
exact (to_simple_func f).norm_integral_le_integral_norm (simple_func.integrable f)
intros
have A := hf.integral_sub_linear_is_o_ae hfm hl (hu.Ioc hv)
have B := hf.integral_sub_linear_is_o_ae hfm hl (hv.Ioc hu)
simp only [integral_const']
convert (A.trans_le _).sub (B.trans_le _)
ext t
{ ext t, simp_rw [interval_integral, sub_smul], abel }
simp_rw [interval_integral, sub_smul]
abel
intro t
all_goals { intro t, cases le_total (u t) (v t) with huv huv; simp [huv] }
cases le_total (u t) (v t) with huv huv; simp [huv]
intro t
cases le_total (u t) (v t) with huv huv
cases le_total (u t) (v t) with huv huv; simp [huv]
simp [huv]
simp [huv]
intros
induction n with n hn
{ simp }
simp
exact (hn (λ k hk, hint k (hk.trans n.lt_succ_self))).trans (hint n n.lt_succ_self)
{ exact (hn (λ k hk, hint k (hk.trans n.lt_succ_self))).trans (hint n n.lt_succ_self) }
intros
rw [lintegral_const, one_mul]
intros
simp_rw [mul_comm, lintegral_const_mul'' r hf]
intros
rw [← lintegral_sum_measure]
exact lintegral_mono' restrict_Union_le (le_refl _)
intros
rw [lintegral]
casesI is_empty_or_nonempty α
{ simp [μ.eq_zero_of_is_empty] }
simp [μ.eq_zero_of_is_empty]
{ simp [preimage_const_of_mem] }
simp [preimage_const_of_mem]
intros
rw [fun_mul_inv_snorm, mul_rpow_of_nonneg _ _ (le_of_lt hp0)]
suffices h_inv_rpow : ((∫⁻ (c : α), f c ^ p ∂μ) ^ (1 / p))⁻¹ ^ p = (∫⁻ (c : α), f c ^ p ∂μ)⁻¹
rw h_inv_rpow
rw h_inv_rpow
rw [inv_rpow, ← rpow_mul, one_div_mul_cancel hp0.ne', rpow_one]
intros
rw [← integral_indicator hs, ← integral_indicator (measurable_set_le hf measurable_const)]
exact integral_mono (hfi.indicator (measurable_set_le hf measurable_const)) (hfi.indicator hs) (indicator_nonpos_le_indicator s f)
intros
intros t ht
rw piecewise_preimage
exact hs.ite (hf ht) (hg ht)
intros
{ rintro ⟨e₁, _, _⟩ ⟨e₂, _, _⟩ (rfl : e₁ = e₂), refl }
rintro ⟨e₁, _, _⟩ ⟨e₂, _, _⟩ (rfl : e₁ = e₂)
refl
intros
simp only [supr, measurable_set_Sup, exists_range_iff]
intros
have := (classical.some_spec (nonempty_Inter_cl_prehaar K₀)).2
{ have := (classical.some_spec (nonempty_Inter_cl_prehaar K₀)).2, rw [mem_Inter] at this, exact this V }
rw [mem_Inter] at this
exact this V
intros
simpa only [mul_comm] using real.map_volume_mul_left h
intros
by_cases h : a ∈ s
rw [dirac_apply_of_mem h, indicator_of_mem h, pi.one_apply]
rw [dirac_apply_of_mem h, indicator_of_mem h, pi.one_apply]
rw [indicator_of_not_mem h, ← nonpos_iff_eq_zero]
calc dirac a s ≤ dirac a {a}ᶜ : measure_mono (subset_compl_comm.1 $ singleton_subset_iff.2 h) ... = 0 : by simp [dirac_apply' _ (measurable_set_singleton _).compl]
intros
apply le_antisymm _ bot_le
calc μ (f ⁻¹' sᶜ) ≤ (map f μ) sᶜ : le_map_apply hf sᶜ ... = 0 : hs
intros
{ filter_upwards [hs_zero], intros, split_ifs, refl }
filter_upwards [hs_zero]
intros
split_ifs
refl
intros
filter_upwards [hst]
intros x hx
replace hx : x ∈ s ↔ x ∈ t := iff_of_eq hx
by_cases h : x ∈ s; have h' := h; rw hx at h'; simp [h, h']
by_cases h : x ∈ s; have h' := h; rw hx at h'
by_cases h : x ∈ s; have h' := h
by_cases h : x ∈ s
have h' := h
rw hx at h'
simp [h, h']
have h' := h
rw hx at h'
simp [h, h']
intros
rw [← coe_to_outer_measure, measure.restrict_to_outer_measure_eq_to_outer_measure_restrict hs, outer_measure.restrict_apply s t _, coe_to_outer_measure]
intros
simp only [induced_outer_measure_eq_infi _ msU m_mono]
symmetry
refine infi_congr (preimage f) f.injective.preimage_surjective _
intro s
refine infi_congr_Prop (Pm s) _
intro hs
refine infi_congr_Prop f.surjective.preimage_subset_preimage_iff _
intro h2s
exact mm s hs
intros
refine (comap_of_function _ _).trans _
refine h.imp (λ H s t hst, supr_le $ λ hs, _) id
{ refine h.imp (λ H s t hst, supr_le $ λ hs, _) id, have ht : t.nonempty := hs.mono hst, exact (@H ⟨s, hs⟩ ⟨t, ht⟩ hst).trans (le_supr (λ h : t.nonempty, m t) ht) }
have ht : t.nonempty := hs.mono hst
exact (@H ⟨s, hs⟩ ⟨t, ht⟩ hst).trans (le_supr (λ h : t.nonempty, m t) ht)
dunfold bounded_by
{ dunfold bounded_by, congr' with s : 1, rw nonempty_image_iff }
congr' with s : 1
rw nonempty_image_iff
intros
simp only [Inf_eq_infi, restrict_binfi, hm, infi_image]
intros
apply le_of_tendsto (f.tendsto_left_lim x)
filter_upwards [self_mem_nhds_within]
assume z hz
exact (f.mono (le_of_lt hz)).trans (f.mono h)
intros
split
intros h s hs
{ intros h s hs, have := h s hs, rwa [restrict_apply _ measurable_set.univ hs, inter_univ, restrict_apply _ measurable_set.univ hs, inter_univ] at this }
have := h s hs
rwa [restrict_apply _ measurable_set.univ hs, inter_univ, restrict_apply _ measurable_set.univ hs, inter_univ] at this
intros h s hs
{ intros h s hs, rw [restrict_apply _ measurable_set.univ hs, inter_univ, restrict_apply _ measurable_set.univ hs, inter_univ], exact h s hs }
rw [restrict_apply _ measurable_set.univ hs, inter_univ, restrict_apply _ measurable_set.univ hs, inter_univ]
exact h s hs
intros
induction k with k hi
{ exact is_multiplicative_zeta.nat_cast }
exact is_multiplicative_zeta.nat_cast
rw ppow_succ
{ rw ppow_succ, apply hf.pmul hi }
apply hf.pmul hi
{ rw bernoulli'_def, norm_num }
rw bernoulli'_def
norm_num
intros
cases f with f pf
induction pf with i n f g pf pg ihf ihg f g pf pg ihf ihg
apply H1
apply H2
apply H3 _ _ ihf ihg
apply H4 _ _ ihf ihg
ext
{ ext, simp }
simp
intros
obtain ⟨a0, b0, c0, hf, hc⟩ := exists_odd_minimal h
rcases lt_trichotomy 0 c0 with (h1 | rfl | h1)
{ use [a0, b0, c0], tauto }
use [a0, b0, c0]
tauto
{ exfalso, exact ne_zero hf.1 rfl}
exfalso
exact ne_zero hf.1 rfl
use [a0, b0, -c0, neg_of_minimal hf, hc]
{ use [a0, b0, -c0, neg_of_minimal hf, hc], exact neg_pos.mpr h1 }
exact neg_pos.mpr h1
intros
{ ext; { dsimp, ring }, }
ext
ext; { dsimp, ring }
{ dsimp, ring }
dsimp
{ dsimp, ring }
ring
intros
norm_cast
intros
apply int.coe_nat_inj
simp only [padic_val_rat_of_nat, nat.cast_mul]
rw padic_val_rat.mul
norm_cast
exact cast_ne_zero.mpr hq
exact cast_ne_zero.mpr hr
intros
simp [cast_eq_of_rat]
intros
simp [lim_nth_hom]; refl
simp [lim_nth_hom]
refl
intros
intros x y h
by_cases hy : p y
have hx : p x := hp h hy
{ have hx : p x := hp h hy, simpa [hx, hy] using hf h }
simpa [hx, hy] using hf h
by_cases hx : p x
{ by_cases hx : p x, { simpa [hx, hy] using hfg hx hy h }, { simpa [hx, hy] using hg h} }
{ simpa [hx, hy] using hfg hx hy h }
simpa [hx, hy] using hfg hx hy h
{ simpa [hx, hy] using hg h}
simpa [hx, hy] using hg h
intros
rw [eq_top_iff, le_inf_iff]; simp
rw [eq_top_iff, le_inf_iff]
simp
intros
rw [← f.symm_symm, ← image_eq_preimage, is_lub_image]
intros
split
split; introsI
introsI
{ exact is_atomistic_of_is_complemented }
exact is_atomistic_of_is_complemented
introsI
{ exact is_complemented_of_is_atomistic }
exact is_complemented_of_is_atomistic
intros
{rw independent_def', tidy}
rw independent_def'
tidy
intros
rw [(union_eq_self_of_subset_left h).symm, infi_union]
rw [(union_eq_self_of_subset_left h).symm, infi_union]; exact inf_le_left
exact inf_le_left
intros
rcases eq_empty_or_nonempty s with (rfl|hne)
{ simp only [cSup_empty, is_lub_empty] }
simp only [cSup_empty, is_lub_empty]
{ exact is_lub_cSup hne hs }
exact is_lub_cSup hne hs
intros
{ rw ← prod_at_bot_at_bot_eq, exact hf.prod_map hg, }
rw ← prod_at_bot_at_bot_eq
exact hf.prod_map hg
intros
simp only [eventually_eq_set, mem_inter_eq, and_iff_left_iff_imp]
intros
rw ← map_comap_of_mem h
exact image_mem_map W_in
intros
simpa only [sub_eq_add_neg] using hf.add hg.neg
intros
refine (mem_binfi_of_directed _ ⟨univ, univ_sets _⟩).trans _
intros t₁ ht₁ t₂ ht₂
{ intros t₁ ht₁ t₂ ht₂, exact ⟨t₁ ∩ t₂, inter_mem ht₁ ht₂, gm $ inter_subset_left _ _, gm $ inter_subset_right _ _⟩ }
exact ⟨t₁ ∩ t₂, inter_mem ht₁ ht₂, gm $ inter_subset_left _ _, gm $ inter_subset_right _ _⟩
simp only [← (hg _).mem_iff]
{ simp only [← (hg _).mem_iff], exact hf.exists_iff (λ t₁ t₂ ht H, gm ht H) }
exact hf.exists_iff (λ t₁ t₂ ht H, gm ht H)
intros
refine ⟨λ hf g hg, hg hf, λ H, by_contra $ λ hf, _⟩
set g : filter ↥sᶜ := comap coe f
haveI : ne_bot g := comap_ne_bot_iff_compl_range.2 (by simpa [compl_set_of])
simpa using H ((of g).map coe) (map_le_iff_le_comap.mpr (of_le g))
intros
induction n with n ihn
exact hn.false.elim
{ exact hn.false.elim }
suffices : x n ≤ y n
from (hx n n.lt_succ_self).trans_le ((hf this).trans $ hy n n.lt_succ_self)
cases n
exact h₀
{ exact h₀ }
refine (ihn n.zero_lt_succ (λ k hk, hx _ _) (λ k hk, hy _ _)).le
refine (ihn n.zero_lt_succ (λ k hk, hx _ _) (λ k hk, hy _ _)).le; exact hk.trans n.succ.lt_succ_self
exact hk.trans n.succ.lt_succ_self
exact hk.trans n.succ.lt_succ_self
exact hk.trans n.succ.lt_succ_self
exact hk.trans n.succ.lt_succ_self
intros
refine le_Limsup_of_le hlv (λ c hc, _)
rw filter.eventually_map at hc
simp_rw (gc _ _) at hc ⊢
exact Limsup_le_of_le hv_co hc
intros
exactI {..f.is_preorder, ..f.is_antisymm}
intros
split
split; intro h
intro h
rw [symm_diff_eq_sup_sdiff_inf, sdiff_eq_self_iff_disjoint] at h
{ rw [symm_diff_eq_sup_sdiff_inf, sdiff_eq_self_iff_disjoint] at h, exact h.of_disjoint_inf_of_le le_sup_left, }
exact h.of_disjoint_inf_of_le le_sup_left
intro h
{ exact h.symm_diff_eq_sup, }
exact h.symm_diff_eq_sup
intros
simp only [eq_iff_not_lt_of_le, well_founded_iff_has_min]
intros
apply le_antisymm
intros r hr
{ intros r hr, rcases subsemiring.mem_closure_iff_exists_list.1 hr with ⟨L, HL, rfl⟩, clear hr, induction L with hd tl ih, { exact zero_mem _ }, rw list.forall_mem_cons at HL, rw [list.map_cons, list.sum_cons], refine submodule.add_mem _ _ (ih HL.2), replace HL := HL.1, clear ih tl, suffices : ∃ z r (hr : r ∈ submonoid.closure s), has_scalar.smul z r = list.prod hd, { rcases this with ⟨z, r, hr, hzr⟩, rw ← hzr, exact smul_mem _ _ (subset_span hr) }, induction hd with hd tl ih, { exact ⟨1, 1, (submonoid.closure s).one_mem', one_smul _ _⟩ }, rw list.forall_mem_cons at HL, rcases (ih HL.2) with ⟨z, r, hr, hzr⟩, rw [list.prod_cons, ← hzr], rcases HL.1 with ⟨hd, rfl⟩ | hs, { refine ⟨hd * z, r, hr, _⟩, rw [algebra.smul_def, algebra.smul_def, (algebra_map _ _).map_mul, _root_.mul_assoc] }, { exact ⟨z, hd * r, submonoid.mul_mem _ (submonoid.subset_closure hs) hr, (mul_smul_comm _ _ _).symm⟩ } }
rcases subsemiring.mem_closure_iff_exists_list.1 hr with ⟨L, HL, rfl⟩
clear hr
induction L with hd tl ih
exact zero_mem _
{ exact zero_mem _ }
rw list.forall_mem_cons at HL
rw [list.map_cons, list.sum_cons]
refine submodule.add_mem _ _ (ih HL.2)
replace HL := HL.1
clear ih tl
suffices : ∃ z r (hr : r ∈ submonoid.closure s), has_scalar.smul z r = list.prod hd
rcases this with ⟨z, r, hr, hzr⟩
{ rcases this with ⟨z, r, hr, hzr⟩, rw ← hzr, exact smul_mem _ _ (subset_span hr) }
rw ← hzr
exact smul_mem _ _ (subset_span hr)
induction hd with hd tl ih
exact ⟨1, 1, (submonoid.closure s).one_mem', one_smul _ _⟩
{ exact ⟨1, 1, (submonoid.closure s).one_mem', one_smul _ _⟩ }
rw list.forall_mem_cons at HL
rcases (ih HL.2) with ⟨z, r, hr, hzr⟩
rw [list.prod_cons, ← hzr]
rcases HL.1 with ⟨hd, rfl⟩ | hs
refine ⟨hd * z, r, hr, _⟩
{ refine ⟨hd * z, r, hr, _⟩, rw [algebra.smul_def, algebra.smul_def, (algebra_map _ _).map_mul, _root_.mul_assoc] }
rw [algebra.smul_def, algebra.smul_def, (algebra_map _ _).map_mul, _root_.mul_assoc]
exact ⟨z, hd * r, submonoid.mul_mem _ (submonoid.subset_closure hs) hr, (mul_smul_comm _ _ _).symm⟩
{ exact ⟨z, hd * r, submonoid.mul_mem _ (submonoid.subset_closure hs) hr, (mul_smul_comm _ _ _).symm⟩ }
refine span_le.2 _
change submonoid.closure s ≤ (adjoin R s).to_subsemiring.to_submonoid
exact submonoid.closure_le.2 subset_adjoin
intros
suffices t : ∃ n : ℕ, ∀ m, n ≤ m → order_dual.to_dual f (m+1) = ⊤
obtain ⟨n, w⟩ := t
{ obtain ⟨n, w⟩ := t, use n+1, rintros (_|m) p, { cases p, }, { apply w, exact nat.succ_le_succ_iff.mp p }, }
use n+1
rintros (_|m) p
{ cases p, }
cases p
apply w
{ apply w, exact nat.succ_le_succ_iff.mp p }
exact nat.succ_le_succ_iff.mp p
obtain ⟨n, w⟩ := monotone_stabilizes_iff_artinian.mpr I (partial_sups (order_dual.to_dual ∘ f))
exact ⟨n, (λ m p, eq_bot_of_disjoint_absorbs (h m) ((eq.symm (w (m + 1) (le_add_right p))).trans (w m p)))⟩
intros
{ rw add_comm at h, exact h.of_add_mul_left_left }
rw add_comm at h
exact h.of_add_mul_left_left
intros
simp only [le_antisymm_iff, fractional_ideal.le_span_singleton_mul_iff, fractional_ideal.span_singleton_mul_le_iff]
intros
{ rcases h with ⟨I, rfl⟩, exact fg_unit I }
rcases h with ⟨I, rfl⟩
exact fg_unit I
intros
split
rintro ⟨a, ha⟩ rfl
{ rintro ⟨a, ha⟩ rfl, apply ha zero_coeff }
apply ha zero_coeff
contrapose!
{ contrapose!, rw set.not_nonempty_iff_eq_empty, intro h, ext a, have ha := set.not_mem_empty a, rw [← h, mem_support, not_not] at ha, rw [ha, zero_coeff] }
rw set.not_nonempty_iff_eq_empty
intro h
ext a
have ha := set.not_mem_empty a
rw [← h, mem_support, not_not] at ha
rw [ha, zero_coeff]
intros
classical
refine s.induction_on _ _
{ rw [multiset.inf_zero], exact le_top }
rw [multiset.inf_zero]
exact le_top
intros a s ih
rw [multiset.prod_cons, multiset.inf_cons]
exact le_trans mul_le_inf (inf_le_inf (le_refl _) ih)
intros
rw ←map_prod_comm_prod
apply map_is_prime_of_equiv _
exact is_prime_ideal_prod_top
intros
rw [is_prime_iff_is_prime_disjoint M S, comap_map_of_is_prime_disjoint M S I hp hd]
exact ⟨hp, hd⟩
intros
simp only [multiplicity, enat.find, dvd_neg]
intros
obtain ⟨n, hn⟩ := hx
obtain ⟨m, hm⟩ := hy
use n + m - 1
rw h_comm.add_pow'
apply finset.sum_eq_zero
rintros ⟨i, j⟩ hij
suffices : x^i * y^j = 0
simp only [this, nsmul_eq_mul, mul_zero]
{ simp only [this, nsmul_eq_mul, mul_zero], }
cases nat.le_or_le_of_add_eq_add_pred (finset.nat.mem_antidiagonal.mp hij) with hi hj
{ rw [pow_eq_zero_of_le hi hn, zero_mul], }
rw [pow_eq_zero_of_le hi hn, zero_mul]
{ rw [pow_eq_zero_of_le hj hm, mul_zero], }
rw [pow_eq_zero_of_le hj hm, mul_zero]
intros
rw is_noetherian_iff_well_founded at h ⊢
refine (submodule.restrict_scalars_embedding R S M).dual.well_founded h
intros
simp [degree]
intros
rw T
intros
simp only [degree_eq_nat_degree (cyclotomic'_ne_zero n R), nat_degree_cyclotomic' h]
intros
ext
{ ext, simp }
simp
intros
have t : p = mat_poly_equiv (mat_poly_equiv.symm p) := by simp
conv_rhs { rw t, }
simp only [mat_poly_equiv_coeff_apply]
intros
rw [X_pow_eq s n, coeff_monomial]
intros
convert exp_mul_exp_eq_exp_add (1 : A) (-1); simp
convert exp_mul_exp_eq_exp_add (1 : A) (-1)
simp
simp
intros
obtain ⟨a0, nza, ha'⟩ := exists_non_zero_rep ha
obtain ⟨b0, nzb, hb'⟩ := exists_non_zero_rep hb
rw [factors_mul, ← ha', ← hb', factors_mk a0 nza, factors_mk b0 nzb, ← factor_set.coe_add, ← with_top.some_eq_coe, ← with_top.some_eq_coe, ← with_top.some_eq_coe, count_some hp, multiset.count_add, count_some hp, count_some hp]
intros
fin_cases i; simp
fin_cases i
simp
simp
intros
funext k
apply mv_polynomial.map_injective (int.cast_ring_hom ℚ) int.cast_injective
rw map_witt_structure_int
refine congr_fun _ k
apply unique_of_exists_unique (witt_structure_rat_exists_unique p (map (int.cast_ring_hom ℚ) Φ))
intro n
{ intro n, specialize h n, apply_fun map (int.cast_ring_hom ℚ) at h, simpa only [map_bind₁, ← eval₂_hom_map_hom, eval₂_hom_C_left, map_rename, map_witt_polynomial, alg_hom.coe_to_ring_hom] using h, }
specialize h n
apply_fun map (int.cast_ring_hom ℚ) at h
simpa only [map_bind₁, ← eval₂_hom_map_hom, eval₂_hom_C_left, map_rename, map_witt_polynomial, alg_hom.coe_to_ring_hom] using h
{ intro n, apply witt_structure_rat_prop }
intro n
apply witt_structure_rat_prop
intros
{ ext1, rw [ring_hom.comp_apply, truncate_lift] }
ext1
rw [ring_hom.comp_apply, truncate_lift]
intros
rw [_root_.mul_comm b c]; from (quotient.induction_on₃ a b c $ assume α β γ, quotient.sound ⟨equiv.curry γ β α⟩)
rw [_root_.mul_comm b c]
from (quotient.induction_on₃ a b c $ assume α β γ, quotient.sound ⟨equiv.curry γ β α⟩)
intros
induction n; simp *
induction n
simp *
simp *
rw [← to_nat_cast 1, nat.cast_one]
intros
{ rw [add_eq_max ha, max_eq_left hb] }
rw [add_eq_max ha, max_eq_left hb]
intros
change ⟦x * (y + -z)⟧ = ⟦x * y⟧ + -⟦x * z⟧
{ change ⟦x * (y + -z)⟧ = ⟦x * y⟧ + -⟦x * z⟧, rw [quot_left_distrib, quot_mul_neg] }
rw [quot_left_distrib, quot_mul_neg]
intros
rw [← not_le, div_le c0, not_lt]
intros
cases o
cases o; refl
refl
refl
intros
{ cases x, cases y, rw mk_lt_mk, refl }
cases x
cases y
rw mk_lt_mk
refl
intros
rw [←h3, mul_comm n1, mul_assoc n2, ←mul_assoc n1, h1, ←mul_assoc n2, mul_comm n2, mul_assoc, h2]
intros
simpa [eq.symm h1, eq.symm h2, int.coe_nat_eq_coe_nat_iff]
intros
rw [← h₃, ← h₂]; simp [pow_bit1, h]
rw [← h₃, ← h₂]
simp [pow_bit1, h]
intros
rw [prl, prr, prt]
intros
unfold val_except
unfold val
by_cases h1 : n + 1 ≤ as.length
have h4 := @val_between_add_val_between v as 0 (n+1) (as.length - (n+1))
{ have h4 := @val_between_add_val_between v as 0 (n+1) (as.length - (n+1)), have h5 : n + 1 + (as.length - (n + 1)) = as.length, { rw [add_comm, nat.sub_add_cancel h1] }, rw h5 at h4, apply eq.trans _ h4, simp only [val_between, zero_add], ring }
have h5 : n + 1 + (as.length - (n + 1)) = as.length
{ rw [add_comm, nat.sub_add_cancel h1] }
rw [add_comm, nat.sub_add_cancel h1]
rw h5 at h4
apply eq.trans _ h4
simp only [val_between, zero_add]
ring
have h2 : (list.length as - (n + 1)) = 0
apply nat.sub_eq_zero_of_le (le_trans (not_lt.1 h1) (nat.le_add_right _ _))
{ apply nat.sub_eq_zero_of_le (le_trans (not_lt.1 h1) (nat.le_add_right _ _)) }
have h3 : val_between v as 0 (list.length as) = val_between v as 0 (n + 1)
simpa only [val] using @val_eq_of_le v as (n+1) (le_trans (not_lt.1 h1) (nat.le_add_right _ _))
{ simpa only [val] using @val_eq_of_le v as (n+1) (le_trans (not_lt.1 h1) (nat.le_add_right _ _)) }
simp only [add_zero, val_between, zero_add, h2, h3]
intros
constructor; intro h1
constructor
intro h1
cases h1 with v h1
{ cases h1 with v h1, cases h1 with h1 h1; [left,right]; refine ⟨v,_⟩; assumption }
cases h1 with h1 h1
cases h1 with h1 h1; [left,right]; refine ⟨v,_⟩; assumption
cases h1 with h1 h1; [left,right]; refine ⟨v,_⟩
cases h1 with h1 h1; [left,right]
left
refine ⟨v,_⟩
assumption
assumption
right
refine ⟨v,_⟩
assumption
assumption
intro h1
cases h1 with h1 h1; cases h1 with v h1; refine ⟨v,_⟩; [left,right]; assumption
cases h1 with h1 h1; cases h1 with v h1; refine ⟨v,_⟩; [left,right]
cases h1 with h1 h1; cases h1 with v h1; refine ⟨v,_⟩
cases h1 with h1 h1; cases h1 with v h1
cases h1 with h1 h1
{ cases h1 with h1 h1; cases h1 with v h1; refine ⟨v,_⟩; [left,right]; assumption }
cases h1 with v h1
refine ⟨v,_⟩
left
assumption
assumption
cases h1 with v h1
refine ⟨v,_⟩
right
assumption
assumption
intros
rw [← mem_compl_iff, compl_range_coe, mem_singleton_iff]
intros
convert is_closed_closure
intros
rcases exists_nhds_one_split hu with ⟨W, W1, h⟩
rcases exists_nhds_one_split W1 with ⟨V, V1, h'⟩
use [V, V1]
intros v w s t v_in w_in s_in t_in
simpa only [mul_assoc] using h _ (h' v v_in w w_in) _ (h' s s_in t t_in)
intros
refine (at_top_basis' 1).tendsto_right_iff.2 (λ b hb, _)
have hb' : 0 < b := zero_lt_one.trans_le hb
filter_upwards [Ioc_mem_nhds_within_Ioi ⟨le_rfl, inv_pos.2 hb'⟩]
exact λ x hx, (le_inv hx.1 hb').1 hx.2
intros
nontriviality
haveI : nonempty s := nontrivial_iff_nonempty.1 ‹_›
rcases hs (nonempty_subtype.1 ‹_›) with ⟨a, h, hs⟩
ext u
split
rintros ⟨t, ht, hts⟩
{ rintros ⟨t, ht, hts⟩, obtain ⟨x, ⟨hxa : a ≤ x, hxb : x < b⟩, hxt : Ioo x b ⊆ t⟩ := (mem_nhds_within_Iio_iff_exists_mem_Ico_Ioo_subset h).mp ht, obtain ⟨y, hxy, hyb⟩ := exists_between hxb, refine mem_of_superset (mem_at_top ⟨y, hs ⟨hxa.trans_lt hxy, hyb⟩⟩) _, rintros ⟨z, hzs⟩ (hyz : y ≤ z), refine hts (hxt ⟨hxy.trans_le _, hb _⟩); assumption }
obtain ⟨x, ⟨hxa : a ≤ x, hxb : x < b⟩, hxt : Ioo x b ⊆ t⟩ := (mem_nhds_within_Iio_iff_exists_mem_Ico_Ioo_subset h).mp ht
obtain ⟨y, hxy, hyb⟩ := exists_between hxb
refine mem_of_superset (mem_at_top ⟨y, hs ⟨hxa.trans_lt hxy, hyb⟩⟩) _
rintros ⟨z, hzs⟩ (hyz : y ≤ z)
refine hts (hxt ⟨hxy.trans_le _, hb _⟩); assumption
refine hts (hxt ⟨hxy.trans_le _, hb _⟩)
assumption
assumption
intros hu
{ intros hu, obtain ⟨x : s, hx : ∀ z, x ≤ z → z ∈ u⟩ := mem_at_top_sets.1 hu, exact ⟨Ioo x b, Ioo_mem_nhds_within_Iio (right_mem_Ioc.2 $ hb x.2), λ z hz, hx _ hz.1.le⟩ }
obtain ⟨x : s, hx : ∀ z, x ≤ z → z ∈ u⟩ := mem_at_top_sets.1 hu
exact ⟨Ioo x b, Ioo_mem_nhds_within_Iio (right_mem_Ioc.2 $ hb x.2), λ z hz, hx _ hz.1.le⟩
intros
refine eq_univ_of_forall (λ x, _)
obtain ⟨y, ys, hy⟩ : ∃ y ∈ s, y < x := not_bdd_below_iff.1 hb x
obtain ⟨z, zs, hz⟩ : ∃ z ∈ s, x < z := not_bdd_above_iff.1 ha x
exact hs.Icc_subset ys zs ⟨le_of_lt hy, le_of_lt hz⟩
intros
obtain ⟨s : set α, hs, s_dense⟩ := exists_countable_dense α
cases countable_iff_exists_surjective.mp hs with u hu
exact ⟨u, s_dense.mono hu⟩
intros
rw [frontier, hs.closure_eq]
intros
simp only [mem_closure_iff_nhds, set.nonempty_inter_iff_exists_right]
intros
rw [ultrafilter.Lim_eq_iff_le_nhds, le_nhds_iff]
tauto
intros
classical
use λ (j : J), if hj : j ∈ G then F.map (is_cofiltered.inf_to G H hj) (h (is_cofiltered.inf G H)).some else (h _).some
rintros ⟨X, Y, hX, hY, f⟩ hf
dsimp only
rwa [dif_pos hX, dif_pos hY, ←comp_app, ←F.map_comp, @is_cofiltered.inf_to_commutes _ _ _ G H]
intros
simp only [induced_generate_from_eq, continuous_map.compact_open]
apply generate_from_mono
rintros b ⟨a, ⟨c, hc, u, hu, rfl⟩, rfl⟩
refine ⟨coe '' c, hc.image continuous_subtype_coe, u, hu, _⟩
ext f
simp only [compact_open.gen, mem_set_of_eq, mem_preimage, continuous_map.coe_restrict]
rw image_comp f (coe : s → α)
intros
split
split; intro h
intro h
intros u v hu hv hs huv
{ intros u v hu hv hs huv, specialize h u v hu hv hs, contrapose! huv, rw ne_empty_iff_nonempty, simp [not_subset] at huv, rcases huv with ⟨⟨x, hxs, hxu⟩, ⟨y, hys, hyv⟩⟩, have hxv : x ∈ v := or_iff_not_imp_left.mp (hs hxs) hxu, have hyu : y ∈ u := or_iff_not_imp_right.mp (hs hys) hyv, exact h ⟨y, hys, hyu⟩ ⟨x, hxs, hxv⟩ }
specialize h u v hu hv hs
contrapose! huv
rw ne_empty_iff_nonempty
simp [not_subset] at huv
rcases huv with ⟨⟨x, hxs, hxu⟩, ⟨y, hys, hyv⟩⟩
have hxv : x ∈ v := or_iff_not_imp_left.mp (hs hxs) hxu
have hyu : y ∈ u := or_iff_not_imp_right.mp (hs hys) hyv
exact h ⟨y, hys, hyu⟩ ⟨x, hxs, hxv⟩
intro h
intros u v hu hv hs hsu hsv
{ intros u v hu hv hs hsu hsv, rw ← ne_empty_iff_nonempty, intro H, specialize h u v hu hv hs H, contrapose H, apply ne_empty_iff_nonempty.mpr, cases h, { rcases hsv with ⟨x, hxs, hxv⟩, exact ⟨x, hxs, ⟨h hxs, hxv⟩⟩ }, { rcases hsu with ⟨x, hxs, hxu⟩, exact ⟨x, hxs, ⟨hxu, h hxs⟩⟩ } }
rw ← ne_empty_iff_nonempty
intro H
specialize h u v hu hv hs H
contrapose H
apply ne_empty_iff_nonempty.mpr
cases h
{ rcases hsv with ⟨x, hxs, hxv⟩, exact ⟨x, hxs, ⟨h hxs, hxv⟩⟩ }
rcases hsv with ⟨x, hxs, hxv⟩
exact ⟨x, hxs, ⟨h hxs, hxv⟩⟩
{ rcases hsu with ⟨x, hxs, hxu⟩, exact ⟨x, hxs, ⟨hxu, h hxs⟩⟩ }
rcases hsu with ⟨x, hxs, hxu⟩
exact ⟨x, hxs, ⟨hxu, h hxs⟩⟩
intros
{ rw [nhds_prod_eq] at h, exact h.curry }
rw [nhds_prod_eq] at h
exact h.curry
intros
intros x₁ x₂ hx
obtain ⟨_, ⟨f, hfA, rfl⟩, hf⟩ := hA hx
let F : C(X, ℂ) := f - const (f x₂)
have hFA : F ∈ A
refine A.sub_mem hfA _
{ refine A.sub_mem hfA _, convert A.smul_mem A.one_mem (f x₂), ext1, simp }
convert A.smul_mem A.one_mem (f x₂)
ext1
simp
refine ⟨_, ⟨(⟨complex.norm_sq, continuous_norm_sq⟩ : C(ℂ, ℝ)).comp F, _, rfl⟩, _⟩
rw [set_like.mem_coe, subalgebra.mem_comap]
{ rw [set_like.mem_coe, subalgebra.mem_comap], convert (A.restrict_scalars ℝ).mul_mem (mem_conj_invariant_subalgebra hA' hFA) hFA, ext1, exact complex.norm_sq_eq_conj_mul_self }
convert (A.restrict_scalars ℝ).mul_mem (mem_conj_invariant_subalgebra hA' hFA) hFA
ext1
exact complex.norm_sq_eq_conj_mul_self
have : f x₁ - f x₂ ≠ 0 := sub_ne_zero.mpr hf
{ have : f x₁ - f x₂ ≠ 0 := sub_ne_zero.mpr hf, simpa using this }
simpa using this
intros
refine continuous_on_iff'.2 (λ t ht, ⟨f '' (t ∩ s), _, _⟩)
rw ← image_restrict
{ rw ← image_restrict, exact h _ (ht.preimage continuous_subtype_coe) }
exact h _ (ht.preimage continuous_subtype_coe)
rw [inter_eq_self_of_subset_left (image_subset f (inter_subset_right t s)), hleft.image_inter']
{ rw [inter_eq_self_of_subset_left (image_subset f (inter_subset_right t s)), hleft.image_inter'] }
intros
rw (is_locally_constant.tfae S.proj).out 0 3
intros x
rcases S.proj_surjective x with ⟨x,rfl⟩
simp [fiber_eq, (S.clopen x).1]
intros
letI := a.total_space_topology
{ letI := a.total_space_topology, exact a.is_topological_fiber_bundle.continuous_proj, }
exact a.is_topological_fiber_bundle.continuous_proj
intros
simpa only [mul_comm a] using infi_mul_left' h h0
intros
lift a to ℝ using and.intro ha h'a
rw [nhds_coe, tendsto_map'_iff]
exact tendsto_id
intros
induction l with x l ih
simp [nhds_nil, mem_of_mem_nhds, tendsto_pure_left] {contextual := tt}
{ simp [nhds_nil, mem_of_mem_nhds, tendsto_pure_left] {contextual := tt} }
simp_rw [tendsto_cons_iff, prod_cons]
have := continuous_iff_continuous_at.mp continuous_mul (x, l.prod)
rw [continuous_at, nhds_prod_eq] at this
exact this.comp (tendsto_id.prod_map ih)
intros
ext
simp only [of_clopen, nat.one_ne_zero, mem_singleton_iff, coe_mk, fin.zero_eq_one_iff, mem_preimage, ite_eq_right_iff, mem_compl_eq]
tauto
intros
refine closed_embedding_of_embedding_closed ⟨⟨_⟩, h₂⟩ h₃
apply le_antisymm (continuous_iff_le_induced.mp h₁) _
intro s'
change is_open _ ≤ is_open _
rw [←is_closed_compl_iff, ←is_closed_compl_iff]
generalize : s'ᶜ = s
rw is_closed_induced_iff
refine λ hs, ⟨f '' s, h₃ s hs, _⟩
rw preimage_image_eq _ h₂
intros
rw ← sInter_range
apply dense_sInter_of_open
{ rwa forall_range_iff }
rwa forall_range_iff
{ exact countable_range _ }
exact countable_range _
{ rwa forall_range_iff }
rwa forall_range_iff
intros
rw [add_left_comm, dist_comm x₁, ← add_assoc]
{ rw [add_left_comm, dist_comm x₁, ← add_assoc], apply dist_triangle4 }
apply dist_triangle4
intros
rw [edist_nndist, ennreal.coe_lt_coe]
intros
rw ← ne_bot_iff; exact uniformity_basis_edist.cauchy_iff
rw ← ne_bot_iff
exact uniformity_basis_edist.cauchy_iff
intros
let F := Kuratowski_embedding (optimal_GH_coupling X Y)
let Φ := F ∘ optimal_GH_injl X Y
let Ψ := F ∘ optimal_GH_injr X Y
refine ⟨Φ, Ψ, _, _, _⟩
exact (Kuratowski_embedding.isometry _).comp (isometry_optimal_GH_injl X Y)
{ exact (Kuratowski_embedding.isometry _).comp (isometry_optimal_GH_injl X Y) }
exact (Kuratowski_embedding.isometry _).comp (isometry_optimal_GH_injr X Y)
{ exact (Kuratowski_embedding.isometry _).comp (isometry_optimal_GH_injr X Y) }
rw [← image_univ, ← image_univ, image_comp F, image_univ, image_comp F (optimal_GH_injr X Y), image_univ, ← Hausdorff_dist_optimal]
{ rw [← image_univ, ← image_univ, image_comp F, image_univ, image_comp F (optimal_GH_injr X Y), image_univ, ← Hausdorff_dist_optimal], exact (Hausdorff_dist_image (Kuratowski_embedding.isometry _)).symm }
exact (Hausdorff_dist_image (Kuratowski_embedding.isometry _)).symm
intros
unfold Hausdorff_edist; apply sup_comm
unfold Hausdorff_edist
apply sup_comm
intros
rw continuous_def at h ⊢
assume s hs
exact h _ hs
intros
simp only [← nhds_within_univ] at hf
rcases countable_cover_nhds_within_of_sigma_compact is_closed_univ (λ x _, hf x) with ⟨s, -, hsc, hsU⟩
exact ⟨s, hsc, univ_subset_iff.1 hsU⟩
intros
obtain ⟨t, -, s⟩ := is_compact.elim_nhds_subcover compact_univ U (λ x m, hU x)
exact ⟨t, by { rw eq_top_iff, exact s }⟩
intros
simp_rw [is_open_iff_mem_nhds, nhds_eq_comap_uniformity]
exact iff.rfl
intros
rw cauchy_seq_iff_tendsto at hu
exact ((hu.comp $ hf.prod_at_top hg).comp tendsto_at_top_diagonal).subseq_mem hV
intros
rw [is_separated, separated_space.out]
tauto
intros
induction n with n ihn generalizing c
{ exact indicator_nonneg (λ _ _, zero_le_one) _ }
exact indicator_nonneg (λ _ _, zero_le_one) _
simp only [approx, midpoint_eq_smul_add, inv_of_eq_inv]
{ simp only [approx, midpoint_eq_smul_add, inv_of_eq_inv], refine mul_nonneg (inv_nonneg.2 zero_le_two) (add_nonneg _ _); apply ihn }
refine mul_nonneg (inv_nonneg.2 zero_le_two) (add_nonneg _ _)
refine mul_nonneg (inv_nonneg.2 zero_le_two) (add_nonneg _ _); apply ihn
apply ihn
apply ihn
intros
cases x; cases x'; simp [show x = x', from funext h]
cases x; cases x'
cases x
cases x'
simp [show x = x', from funext h]
intros
cases b; simp
cases b
simp
simp
intros
rw [← int.sub_nat_nat_eq_coe]; exact sub_nat_nat_elim m n (λm n i, to_nat i = m - n) (λi n, by rw [nat.add_sub_cancel_left]; refl) (λi n, by rw [nat.add_assoc, nat.sub_eq_zero_of_le (nat.le_add_right _ _)]; refl)
rw [← int.sub_nat_nat_eq_coe]
exact sub_nat_nat_elim m n (λm n i, to_nat i = m - n) (λi n, by rw [nat.add_sub_cancel_left]; refl) (λi n, by rw [nat.add_assoc, nat.sub_eq_zero_of_le (nat.le_add_right _ _)]; refl)
intros
rw [int.add_assoc, int.add_right_neg, int.add_zero]
intros
have h := int.neg_le_neg h
rwa int.neg_neg at h
intros
have h := int.add_lt_add_right h b
rwa int.sub_add_cancel at h
intros
rw [nat.mul_comm, add_mul_mod_self_left]
intros
revert k m
induction n with n ; intros k m h₀ h₁
induction n with n
intros k m h₀ h₁
{ exact m.zero_le }
exact m.zero_le
intros k m h₀ h₁
cases k with k
{ cases k with k, { apply h₁ }, cases m with m, { cases not_succ_le_zero _ h₀ }, { simp [succ_sub_succ] at h₁, apply succ_le_succ, apply n_ih _ h₁, apply le_of_succ_le_succ h₀ }, }
{ apply h₁ }
apply h₁
cases m with m
{ cases not_succ_le_zero _ h₀ }
cases not_succ_le_zero _ h₀
simp [succ_sub_succ] at h₁
{ simp [succ_sub_succ] at h₁, apply succ_le_succ, apply n_ih _ h₁, apply le_of_succ_le_succ h₀ }
apply succ_le_succ
apply n_ih _ h₁
apply le_of_succ_le_succ h₀
intros
simp [succ_add, add_succ]
intros
by_cases p; simp [h]
by_cases p
simp [h]
simp [h]
intros
rw [eq_vadd_iff_vsub_eq, vadd_vsub_assoc, ← add_right_inj (-v₁), neg_add_cancel_left, eq_comm]
intros
ext
{ ext, simp only [arrow_congr, equiv.coe_fn_mk, alg_hom.comp_apply], congr, exact (e₂.symm_apply_apply _).symm }
simp only [arrow_congr, equiv.coe_fn_mk, alg_hom.comp_apply]
congr
exact (e₂.symm_apply_apply _).symm
intros
haveI : subsingleton (A →ₐ[R] B) := alg_hom.subsingleton
exact ⟨λ f g, alg_equiv.ext (λ x, alg_hom.ext_iff.mp (subsingleton.elim f.to_alg_hom g.to_alg_hom) x)⟩
intros
conv_lhs { rw [finset.eq_sum_range_sub f] }
simp [finset.sum_range_succ', add_comm]
intros
induction m with m hm
{ simp }
simp
rw [nat.add_succ, prod_range_succ, hm, prod_range_succ, mul_assoc]
{ rw [nat.add_succ, prod_range_succ, hm, prod_range_succ, mul_assoc], }
intros
convert finprod_eq_if
intros
rw [← set.bij_on.image_eq he₀, finprod_mem_image he₀.2.1]
exact finprod_mem_congr rfl he₁
intros
simp only [sub_eq_add_neg]
convert prod_add_ordered s f (λ i, -g i)
simp
intros
apply tensor_product.ext_threefold
intros x y z
change R at y
dsimp [tensor_hom, associator]
erw [tensor_product.lid_tmul, tensor_product.rid_tmul]
exact (tensor_product.smul_tmul _ _ _).symm
intros
rw [sub_eq_iff_eq_add, add_halves']
intros
cases ifp_n with _ fr
change fr = 0 at nth_fr_eq_zero
simp [int_fract_pair.stream, stream_nth_eq, nth_fr_eq_zero]
intros
simp[denom_eq_conts_b, (first_continuant_eq zeroth_s_eq)]
intros
rw [← h, mul_div_cancel_left _ ha]
intros
rw [inv_eq_one_div, inv_eq_one_div, div_neg_eq_neg_div]
intros
{ ext, simp [le_floor] }
ext
simp [le_floor]
intros
apply dvd_antisymm_of_normalize_eq (normalize_gcd _ _) (normalize_gcd _ _)
apply dvd_antisymm_of_normalize_eq (normalize_gcd _ _) (normalize_gcd _ _); rw dvd_gcd_iff; refine ⟨gcd_dvd_left _ _, _⟩
apply dvd_antisymm_of_normalize_eq (normalize_gcd _ _) (normalize_gcd _ _); rw dvd_gcd_iff
rw dvd_gcd_iff
refine ⟨gcd_dvd_left _ _, _⟩
rcases h with ⟨d, hd⟩
{ rcases h with ⟨d, hd⟩, rcases gcd_dvd_right a b with ⟨e, he⟩, rcases gcd_dvd_left a b with ⟨f, hf⟩, use e - f * d, rw [mul_sub, ← he, ← mul_assoc, ← hf, ← hd, sub_sub_cancel] }
rcases gcd_dvd_right a b with ⟨e, he⟩
rcases gcd_dvd_left a b with ⟨f, hf⟩
use e - f * d
rw [mul_sub, ← he, ← mul_assoc, ← hf, ← hd, sub_sub_cancel]
rw dvd_gcd_iff
refine ⟨gcd_dvd_left _ _, _⟩
rcases h with ⟨d, hd⟩
{ rcases h with ⟨d, hd⟩, rcases gcd_dvd_right a c with ⟨e, he⟩, rcases gcd_dvd_left a c with ⟨f, hf⟩, use e + f * d, rw [mul_add, ← he, ← mul_assoc, ← hf, ← hd, ← add_sub_assoc, add_comm c b, add_sub_cancel] }
rcases gcd_dvd_right a c with ⟨e, he⟩
rcases gcd_dvd_left a c with ⟨f, hf⟩
use e + f * d
rw [mul_add, ← he, ← mul_assoc, ← hf, ← hd, ← add_sub_assoc, add_comm c b, add_sub_cancel]
intros
rw [← lcm_erase_dup, erase_dup_ext.2, lcm_erase_dup, lcm_cons]
{ rw [← lcm_erase_dup, erase_dup_ext.2, lcm_erase_dup, lcm_cons], simp }
simp
intros
rw [sub_eq_add_neg, add_neg_cancel_right a b]
intros
rw [divp_eq_iff_mul_eq, mul_comm, ← divp_assoc, divp_eq_iff_mul_eq, mul_comm y ux]
intros
{ ext a, exact mul_action_hom.congr_fun h a, }
ext a
exact mul_action_hom.congr_fun h a
intros
ring
intros
intros a b hab
cases le_total a 0 with ha ha
cases le_or_lt b 0 with hb hb
{ cases le_or_lt b 0 with hb hb, { rw [← neg_lt_neg_iff, ← neg_pow_bit1, ← neg_pow_bit1], exact pow_lt_pow_of_lt_left (neg_lt_neg hab) (neg_nonneg.2 hb) (bit1_pos (zero_le n)) }, { exact (pow_bit1_nonpos_iff.2 ha).trans_lt (pow_bit1_pos_iff.2 hb) } }
rw [← neg_lt_neg_iff, ← neg_pow_bit1, ← neg_pow_bit1]
{ rw [← neg_lt_neg_iff, ← neg_pow_bit1, ← neg_pow_bit1], exact pow_lt_pow_of_lt_left (neg_lt_neg hab) (neg_nonneg.2 hb) (bit1_pos (zero_le n)) }
exact pow_lt_pow_of_lt_left (neg_lt_neg hab) (neg_nonneg.2 hb) (bit1_pos (zero_le n))
{ exact (pow_bit1_nonpos_iff.2 ha).trans_lt (pow_bit1_pos_iff.2 hb) }
exact (pow_bit1_nonpos_iff.2 ha).trans_lt (pow_bit1_pos_iff.2 hb)
exact pow_lt_pow_of_lt_left hab ha (bit1_pos (zero_le n))
{ exact pow_lt_pow_of_lt_left hab ha (bit1_pos (zero_le n)) }
intros
tidy
intros
{ ext, exact p, }
ext
exact p
intros
simp only [funext_iff, mul_indicator_apply_eq_one, set.disjoint_left, mem_mul_support, not_imp_not]
intros
simp only [lie_module.ker, lie_hom.mem_ker, linear_map.ext_iff, linear_map.zero_apply, to_endomorphism_apply_apply]
intros
rw comap_bracket_incl
{ rw comap_bracket_incl, rw ← inf_eq_right at h₁ h₂, rw [h₁, h₂], }
rw ← inf_eq_right at h₁ h₂
rw [h₁, h₂]
intros
obtain ⟨k, hk⟩ := h₁
tactic.unfreeze_local_instances
use k
rw [← lie_ideal.derived_series_map_eq k h₂, hk]
simp only [lie_ideal.map_eq_bot_iff, bot_le]
intros
rw [← mem_coe_submodule, ← mem_coe_submodule, ← mem_coe_submodule, inf_coe_to_submodule, submodule.mem_inf]
intros
rw [← mem_coe_submodule, sup_coe_to_submodule, submodule.mem_sup]
{ rw [← mem_coe_submodule, sup_coe_to_submodule, submodule.mem_sup], exact iff.rfl, }
exact iff.rfl
intros
rw [← lie_submodule.coe_to_submodule_eq_iff, ker_coe_submodule, lie_submodule.bot_coe_submodule, linear_map.ker_eq_bot, coe_to_linear_map]
intros
simpa using abv.add_le (a - b) b
intros
{ rw [inv_eq_one_div], exact div_lt_iff' ha }
rw [inv_eq_one_div]
exact div_lt_iff' ha
intros
rw [le_div_iff_of_neg hb, one_mul]
intros
rw [mul_comm b c, ← div_sub_div _ _ hc hd, sub_nonpos]
intros
rw [abs_le, neg_le_sub_iff_le_add, sub_le_iff_le_add', and_comm, sub_le_iff_le_add']
intros
simpa only [div_eq_mul_inv] using mul_inv_le_mul_inv_iff'
intros
{ convert mul_lt_mul_left h, simp }
convert mul_lt_mul_left h
simp
intros
simp
intros
ext
ext; simp
simp
simp
simp
simp
intros
refine ⟨_, _⟩
rintros ⟨ab, ba⟩
{ rintros ⟨ab, ba⟩, exact ⟨⟨is_left_regular.of_mul ba.left, is_right_regular.of_mul ab.right⟩, ⟨is_left_regular.of_mul ab.left, is_right_regular.of_mul ba.right⟩⟩ }
exact ⟨⟨is_left_regular.of_mul ba.left, is_right_regular.of_mul ab.right⟩, ⟨is_left_regular.of_mul ab.left, is_right_regular.of_mul ba.right⟩⟩
rintros ⟨ha, hb⟩
{ rintros ⟨ha, hb⟩, exact ⟨⟨(mul_is_left_regular_iff _ ha.left).mpr hb.left, (mul_is_right_regular_iff _ hb.right).mpr ha.right⟩, ⟨(mul_is_left_regular_iff _ hb.left).mpr ha.left, (mul_is_right_regular_iff _ ha.right).mpr hb.right⟩⟩ }
exact ⟨⟨(mul_is_left_regular_iff _ ha.left).mpr hb.left, (mul_is_right_regular_iff _ hb.right).mpr ha.right⟩, ⟨(mul_is_left_regular_iff _ hb.left).mpr ha.left, (mul_is_right_regular_iff _ ha.right).mpr hb.right⟩⟩
intros
simp
intros
dsimp [desc_c_app]
ext
simp only [limit.lift_π, nat_trans.naturality, limit.lift_π_assoc, eq_to_hom_map, assoc, pushforward_obj_map, nat_trans.naturality_assoc, op_map, limit_obj_iso_limit_comp_evaluation_inv_π_app_assoc, limit_obj_iso_limit_comp_evaluation_inv_π_app]
dsimp
have w := functor.congr_hom (congr_arg opens.map (colimit.ι_desc ((PresheafedSpace.forget C).map_cocone s) (unop j))) (i.unop)
simp only [opens.map_comp_map] at w
replace w := congr_arg quiver.hom.op w
rw w
dsimp
simp
intros
{ rw basic_open_mul f g, exact inf_le_left }
rw basic_open_mul f g
exact inf_le_left
intros
{ rw ← to_open_germ, refl }
rw ← to_open_germ
refl
intros
by_cases hK : K = 0
subst K
{ subst K, simp only [gronwall_bound_K0, zero_mul, zero_add], convert ((has_deriv_at_id x).const_mul ε).const_add δ, rw [mul_one] }
simp only [gronwall_bound_K0, zero_mul, zero_add]
convert ((has_deriv_at_id x).const_mul ε).const_add δ
rw [mul_one]
simp only [gronwall_bound_of_K_ne_0 hK]
{ simp only [gronwall_bound_of_K_ne_0 hK], convert (((has_deriv_at_id x).const_mul K).exp.const_mul δ).add ((((has_deriv_at_id x).const_mul K).exp.sub_const 1).const_mul (ε / K)) using 1, simp only [id, mul_add, (mul_assoc _ _ _).symm, mul_comm _ K, mul_div_cancel' _ hK], ring }
convert (((has_deriv_at_id x).const_mul K).exp.const_mul δ).add ((((has_deriv_at_id x).const_mul K).exp.sub_const 1).const_mul (ε / K)) using 1
simp only [id, mul_add, (mul_assoc _ _ _).symm, mul_comm _ K, mul_div_cancel' _ hK]
ring
intros
rcases hf with ⟨r, hf⟩
rcases ennreal.lt_iff_exists_nnreal_btwn.1 hf.r_pos with ⟨r', r'0, h⟩
refine (hf.is_O_image_sub_image_sub_deriv_principal h).mono _
exact le_principal_iff.2 (emetric.ball_mem_nhds _ r'0)
intros
have cne0 : ∥c∥ ≠ 0
from mt norm_eq_zero.mp hc
rw [←is_o_norm_left]
simp only [norm_smul]
rw [is_o_const_mul_left_iff cne0, is_o_norm_left]
intros
simp only [is_O_iff_eventually_is_O_with, ← eventually_all]
exact eventually_congr (eventually_at_top.2 ⟨0, λ c, is_O_with_pi⟩)
intros
simpa only [sub_eq_add_neg] using h₁.add h₂.neg_left
intros
refine ord_connected.convex ⟨_⟩
rintros _ ⟨a, ha, rfl⟩ _ ⟨b, hb, rfl⟩ m ⟨hma, hmb⟩
cases eq_or_lt_of_le hma with hma hma
exact hma ▸ mem_image_of_mem f' ha
exact hma ▸ mem_image_of_mem f' ha
cases eq_or_lt_of_le hmb with hmb hmb
exact hmb.symm ▸ mem_image_of_mem f' hb
exact hmb.symm ▸ mem_image_of_mem f' hb
cases le_total a b with hab hab
have : Icc a b ⊆ s
{ have : Icc a b ⊆ s, from hs.ord_connected.out ha hb, rcases exists_has_deriv_within_at_eq_of_gt_of_lt hab (λ x hx, (hf x $ this hx).has_deriv_within_at) hma hmb with ⟨c, cmem, hc⟩, exact ⟨c, this cmem, hc⟩ }
from hs.ord_connected.out ha hb
rcases exists_has_deriv_within_at_eq_of_gt_of_lt hab (λ x hx, (hf x $ this hx).has_deriv_within_at) hma hmb with ⟨c, cmem, hc⟩
exact ⟨c, this cmem, hc⟩
have : Icc b a ⊆ s
{ have : Icc b a ⊆ s, from hs.ord_connected.out hb ha, rcases exists_has_deriv_within_at_eq_of_lt_of_gt hab (λ x hx, (hf x $ this hx).has_deriv_within_at) hmb hma with ⟨c, cmem, hc⟩, exact ⟨c, this cmem, hc⟩ }
from hs.ord_connected.out hb ha
rcases exists_has_deriv_within_at_eq_of_lt_of_gt hab (λ x hx, (hf x $ this hx).has_deriv_within_at) hmb hma with ⟨c, cmem, hc⟩
exact ⟨c, this cmem, hc⟩
intros
rw [← deriv_fderiv, deriv_inv]
intros
have := (hf.Ioi_of_Ici.limsup_slope_norm_le hr).frequently
refine this.mp (eventually.mono self_mem_nhds_within _)
assume z hxz hz
rwa [real.norm_eq_abs, abs_of_pos (sub_pos_of_lt hxz)] at hz
intros
simp only [deriv_within, fderiv_within_neg hxs, continuous_linear_map.neg_apply]
intros
simp [sub_eq_add_neg]
intros
by_cases h : differentiable_within_at 𝕜 f (s ∩ t) x
apply fderiv_within_subset (inter_subset_left _ _) _ ((differentiable_within_at_inter ht).1 h)
{ apply fderiv_within_subset (inter_subset_left _ _) _ ((differentiable_within_at_inter ht).1 h), apply hs.inter ht }
apply hs.inter ht
have : ¬ differentiable_within_at 𝕜 f s x
{ have : ¬ differentiable_within_at 𝕜 f s x, by contrapose! h; rw differentiable_within_at_inter; assumption, rw [fderiv_within_zero_of_not_differentiable_within_at h, fderiv_within_zero_of_not_differentiable_within_at this] }
contrapose! h
contrapose! h
contrapose! h; rw differentiable_within_at_inter; assumption
contrapose! h; rw differentiable_within_at_inter; assumption
contrapose! h; rw differentiable_within_at_inter
contrapose! h; rw differentiable_within_at_inter
rw differentiable_within_at_inter
rw differentiable_within_at_inter
assumption
assumption
assumption
assumption
rw [fderiv_within_zero_of_not_differentiable_within_at h, fderiv_within_zero_of_not_differentiable_within_at this]
intros
have : is_complete (univ : set (E →L[𝕜] F)) := complete_univ
convert measurable_set_of_differentiable_at_of_is_complete 𝕜 f this
simp
intros
refine lhopital_zero_left_on_Ioo hab hff' hgg' hg' _ _ hdiv
rw [← hfb, ← nhds_within_Ioo_eq_nhds_within_Iio hab]
{ rw [← hfb, ← nhds_within_Ioo_eq_nhds_within_Iio hab], exact ((hcf b $ right_mem_Ioc.mpr hab).mono Ioo_subset_Ioc_self).tendsto }
exact ((hcf b $ right_mem_Ioc.mpr hab).mono Ioo_subset_Ioc_self).tendsto
rw [← hgb, ← nhds_within_Ioo_eq_nhds_within_Iio hab]
{ rw [← hgb, ← nhds_within_Ioo_eq_nhds_within_Iio hab], exact ((hcg b $ right_mem_Ioc.mpr hab).mono Ioo_subset_Ioc_self).tendsto }
exact ((hcg b $ right_mem_Ioc.mpr hab).mono Ioo_subset_Ioc_self).tendsto
intros
classical
simp only [unique_diff_within_at_iff, closure_pi_set] at h ⊢
refine ⟨(dense_pi univ (λ i _, (h i).1)).mono _, λ i _, (h i).2⟩
norm_cast
simp only [← submodule.supr_map_single, supr_le_iff, linear_map.map_span, submodule.span_le, ← maps_to']
exact λ i, (maps_to_tangent_cone_pi $ λ j hj, (h j).2).mono subset.rfl submodule.subset_span
intros
rw [← iterated_fderiv_within_univ, ← iterated_fderiv_within_univ, ← fderiv_within_univ]
exact iterated_fderiv_within_succ_apply_right unique_diff_on_univ (mem_univ _) _
intros
split
assume h
{ assume h, split, { assume m hm, exact h.continuous_on_iterated_fderiv_within hm hs }, { assume m hm, exact h.differentiable_on_iterated_fderiv_within hm hs } }
split
{ assume m hm, exact h.continuous_on_iterated_fderiv_within hm hs }
assume m hm
exact h.continuous_on_iterated_fderiv_within hm hs
{ assume m hm, exact h.differentiable_on_iterated_fderiv_within hm hs }
assume m hm
exact h.differentiable_on_iterated_fderiv_within hm hs
assume h
{ assume h, exact times_cont_diff_on_of_continuous_on_differentiable_on h.1 h.2 }
exact times_cont_diff_on_of_continuous_on_differentiable_on h.1 h.2
intros
convert segment_eq_image 𝕜 x y
{ convert segment_eq_image 𝕜 x y, ext θ, simp only [smul_sub, sub_smul, one_smul], abel }
ext θ
simp only [smul_sub, sub_smul, one_smul]
abel
intros
simpa only [h₁, center_mass, inv_one, one_smul] using hs.center_mass_mem h₀ (h₁.symm ▸ zero_lt_one) hz
intros
refine ⟨hs.subset_to_cone, λ t ht x hx, _⟩
rcases hs.mem_to_cone.1 hx with ⟨c, hc, y, hy, rfl⟩
exact t.smul_mem hc (ht hy)
intros
have hmem' : ∀ i ∈ t, (p i, (f ∘ p) i) ∈ {p : E × β | p.1 ∈ s ∧ f p.1 ≤ p.2}
from λ i hi, ⟨hmem i hi, le_rfl⟩
convert (hf.convex_epigraph.center_mass_mem h₀ h₁ hmem').2
convert (hf.convex_epigraph.center_mass_mem h₀ h₁ hmem').2; simp only [center_mass, function.comp, prod.smul_fst, prod.fst_sum, prod.smul_snd, prod.snd_sum]
simp only [center_mass, function.comp, prod.smul_fst, prod.fst_sum, prod.smul_snd, prod.snd_sum]
simp only [center_mass, function.comp, prod.smul_fst, prod.fst_sum, prod.smul_snd, prod.snd_sum]
rw ← fourier_subalgebra_coe
exact congr_arg subalgebra.to_submodule fourier_subalgebra_closure_eq_top
intros
simp [real_inner_eq_re_inner, inner_smul_right]
intros
simp only [inner_sub_left, inner_sub_right]; ring
simp only [inner_sub_left, inner_sub_right]
ring
intros
{ have h := @abs_inner_le_norm ℝ F _ _ x y, simpa using h }
have h := @abs_inner_le_norm ℝ F _ _ x y
simpa using h
intros
have h_mem : v ∈ K ⊔ Kᗮ := by simp [submodule.sup_orthogonal_of_complete_space]
obtain ⟨y, hy, z, hz, hyz⟩ := submodule.mem_sup.mp h_mem
exact ⟨y, hy, z, hz, hyz.symm⟩
intros
simpa [← rpow_mul, ha, hb, hpq.ne_zero, hpq.symm.ne_zero, div_eq_inv_mul] using geom_mean_le_arith_mean2_weighted hpq.one_div_nonneg hpq.symm.one_div_nonneg (rpow_nonneg_of_nonneg ha p) (rpow_nonneg_of_nonneg hb q) hpq.inv_add_inv_conj
intros
simp only [← nnreal.coe_le_coe, nnreal.coe_add, ← dist_nndist, dist_vsub_vsub_le]
intros
{ ext, refl }
ext
refl
intros
simpa using norm_sub_rev 0 g
intros
rw [cauchy_seq_finset_iff_vanishing, nhds_basis_ball.forall_iff]
{ simp only [ball_zero_eq, set.mem_set_of_eq] }
simp only [ball_zero_eq, set.mem_set_of_eq]
rintros s t hst ⟨s', hs'⟩
{ rintros s t hst ⟨s', hs'⟩, exact ⟨s', λ t' ht', hst $ hs' _ ht'⟩ }
exact ⟨s', λ t' ht', hst $ hs' _ ht'⟩
intros
simp_rw ← smul_eq_mul; exact is_bounded_bilinear_map_smul
simp_rw ← smul_eq_mul
exact is_bounded_bilinear_map_smul
intros
set e : PE ≃ᵢ PE := ((f.trans $ (point_reflection ℝ $ midpoint ℝ (f x) (f y)).to_isometric).trans f.symm).trans (point_reflection ℝ $ midpoint ℝ x y).to_isometric
have hx : e x = x
simp
simp
have hy : e y = y
simp
simp
have hm := e.midpoint_fixed hx hy
simp only [e, trans_apply] at hm
rwa [← eq_symm_apply, to_isometric_symm, point_reflection_symm, coe_to_isometric, coe_to_isometric, point_reflection_self, symm_apply_eq, point_reflection_fixed_iff] at hm
intros
simpa only [prod_const] using f.le_op_norm_mul_prod_of_le m hm
intros
refine norm_id_of_nontrivial_seminorm _
obtain ⟨x, hx⟩ := exists_ne (0 : E)
exact ⟨x, ne_of_gt (norm_pos_iff.2 hx)⟩
intros
simp only [← rpow_nat_cast, real.summable_nat_rpow_inv, nat.one_lt_cast]
intros
rintro a ha _ ⟨_, ⟨x, y, hx, hy, rfl⟩, rfl⟩
rw smul_add
exact ⟨_, _, hA₁ _ ha ⟨_, hx, rfl⟩, hA₂ _ ha ⟨_, hy, rfl⟩, rfl⟩
have A : tendsto (λx:ℝ, x + 1) at_top at_top := tendsto_at_top_add_const_right at_top 1 tendsto_id
have B : ∀ᶠ x in at_top, x + 1 ≤ exp x := eventually_at_top.2 ⟨0, λx hx, add_one_le_exp_of_nonneg hx⟩
exact tendsto_at_top_mono' at_top B A
rw [continuous_on_iff_continuous_restrict, restrict]
conv in (log _) { rw [log_of_ne_zero (show (x : ℝ) ≠ 0, from x.2)] }
exact exp_order_iso.symm.continuous.comp (continuous_subtype_mk _ continuous_subtype_coe.norm)
intros
simp only [one_div, integral_inv_one_add_sq]
intros
by_cases h : P = 0
{ simp [h] }
simp [h]
conv_lhs { funext, rw [polynomial.eval_eq_finset_sum, sum_range_succ] }
{ conv_lhs { funext, rw [polynomial.eval_eq_finset_sum, sum_range_succ] }, exact is_equivalent.refl.add_is_o (is_o.sum $ λ i hi, is_o.const_mul_left (is_o.const_mul_right (λ hz, h $ leading_coeff_eq_zero.mp hz) $ is_o_pow_pow_at_top_of_lt (mem_range.mp hi)) _) }
exact is_equivalent.refl.add_is_o (is_o.sum $ λ i hi, is_o.const_mul_left (is_o.const_mul_right (λ hz, h $ leading_coeff_eq_zero.mp hz) $ is_o_pow_pow_at_top_of_lt (mem_range.mp hi)) _)
intros
rcases em (x = 0) with rfl|hx
replace h := h.neg_resolve_left rfl
{ replace h := h.neg_resolve_left rfl, rw [log_zero, mul_zero], refine (has_strict_deriv_at_const _ 0).congr_of_eventually_eq _, exact (is_open_ne.eventually_mem h).mono (λ y hy, (zero_cpow hy).symm) }
rw [log_zero, mul_zero]
refine (has_strict_deriv_at_const _ 0).congr_of_eventually_eq _
exact (is_open_ne.eventually_mem h).mono (λ y hy, (zero_cpow hy).symm)
simpa only [cpow_def_of_ne_zero hx, mul_one] using ((has_strict_deriv_at_id y).const_mul (log x)).cexp
{ simpa only [cpow_def_of_ne_zero hx, mul_one] using ((has_strict_deriv_at_id y).const_mul (log x)).cexp }
intros
simp [rpow_def, *]
intros
rcases eq_or_lt_of_le h₁ with rfl|h₁'
refl
{ refl }
rcases eq_or_lt_of_le h₂ with rfl|h₂'
simp
{ simp }
exact le_of_lt (rpow_lt_rpow h h₁' h₂')
intros
simpa using (has_strict_deriv_at_const _ _).rpow (has_strict_deriv_at_id x) ha
intros
exact_mod_cast (complex.has_deriv_at_tan (by exact_mod_cast h)).real_of_complex
intros
rw [sub_eq_add_neg, sub_eq_add_neg, coe_add, coe_neg]
intros
simp [arccos]
intros
simpa only [pow_one] using is_o_pow_const_const_pow_of_one_lt 1 hr
intros
by_cases hC : C = 0
subst hC
{ subst hC, simp at h, exact cauchy_seq_of_le_geometric 0 0 zero_lt_one (by simp [h]) }
simp at h
exact cauchy_seq_of_le_geometric 0 0 zero_lt_one (by simp [h])
have : 0 ≤ C
{ simpa using (norm_nonneg _).trans (h 0) }
simpa using (norm_nonneg _).trans (h 0)
replace hC : 0 < C
from (ne.symm hC).le_iff_lt.mp this
have : 0 ≤ r
have := (norm_nonneg _).trans (h 1)
{ have := (norm_nonneg _).trans (h 1), rw pow_one at this, exact (zero_le_mul_left hC).mp this }
rw pow_one at this
exact (zero_le_mul_left hC).mp this
simp_rw finset.sum_range_succ_comm
have : cauchy_seq u
apply tendsto.cauchy_seq
{ apply tendsto.cauchy_seq, apply squeeze_zero_norm h, rw show 0 = C*0, by simp, exact tendsto_const_nhds.mul (tendsto_pow_at_top_nhds_0_of_lt_1 this hr) }
apply squeeze_zero_norm h
rw show 0 = C*0, by simp
exact tendsto_const_nhds.mul (tendsto_pow_at_top_nhds_0_of_lt_1 this hr)
exact this.add (cauchy_series_of_le_geometric hr h)
intros
rw [equiv.symm_apply_eq]; simp
rw [equiv.symm_apply_eq]
simp
intros
rw [←equiv.eq_symm_apply, unit_comp_partial_bijective_symm_natural A h, equiv.symm_apply_apply]
intros
{ convert w (𝟙 X), tidy }
convert w (𝟙 X)
tidy
intros
rw [uncurry_eq, exp_comparison_ev]
intros
simp only [cancel_mono]
intros
{ erw is_limit.fac, refl }
erw is_limit.fac
refl
intros
constructor
{ constructor, intro F, apply has_colimit_of_equivalence_comp e, apply_instance }
intro F
apply has_colimit_of_equivalence_comp e
apply_instance
intros
{ ext; simp }
ext
ext; simp
simp
simp
intros
rw [t.left_app_one, t.right_app_one]
intros
{ ext, simp [image.comp_iso] }
ext
simp [image.comp_iso]
intros
{ ext, refl }
ext
refl
intros
{ rw [←right_unitor_tensor, right_unitor_naturality], simp, }
rw [←right_unitor_tensor, right_unitor_naturality]
simp
intros
{ ext, rw [←left_unitor_hom_f, ←comp_f, iso.hom_inv_id], refl, }
ext
rw [←left_unitor_hom_f, ←comp_f, iso.hom_inv_id]
refl
intros
ext
ext; refl
refl
intros
apply J.transitive sjx R (λ Y f hf, _)
apply covering_of_eq_top
rw [← top_le_iff, ← S.pullback_eq_top_of_mem hf]
apply sieve.pullback_monotone _ Hss
intros
cases h with t ht
intros Y₁ Y₂ Z g₁ g₂ f₁ f₂ h₁ h₂ comm
rw [←ht _ h₁, ←ht _ h₂, ←functor_to_types.map_comp_apply, ←op_comp, comm]
simp
intros
simp [sieve.ext_iff]
intros
simp [of_mk_le_mk]
intros
simp only [image_subobject_map, category.assoc, image_subobject_arrow']
erw [image.map_ι, ←category.assoc, image_subobject_arrow]
intros
dsimp [size_up_to]
convert c.blocks_sum
exact take_all_of_le h
intros
rw ←to_DFA_correct at hx ⊢
exact M.to_DFA.pumping_lemma hx hlen
intros
simp [pred]; cases v.head; simp
simp [pred]; cases v.head
simp [pred]
cases v.head
simp
simp
intros
simp only [tr_tape, tape.mk'_left, tape.mk'_right₀]
intros
induction n with n IH
refl
{refl}
refine reaches₀.head _ IH
rw [option.mem_def, TM1.step, tr, TM1.step_aux, tape.move_right_n_head, tape.mk'_nth_nat, add_bottom_nth_succ_fst, TM1.step_aux, iterate_succ', tape.move_right_left]
refl
intros
induction n with n IH generalizing L R
simp only [list_blank.nth_zero, list_blank.modify_nth, iterate_zero_apply]
{ simp only [list_blank.nth_zero, list_blank.modify_nth, iterate_zero_apply], rw [← tape.write_mk', list_blank.cons_head_tail] }
rw [← tape.write_mk', list_blank.cons_head_tail]
simp only [list_blank.head_cons, list_blank.nth_succ, list_blank.modify_nth, tape.move_right_mk', list_blank.tail_cons, iterate_succ_apply, IH]
intros
cases x
cases x; refl
refl
intros
cases x; simp! [sum.traverse] with functor_norm
cases x
simp! [sum.traverse] with functor_norm
simp! [sum.traverse] with functor_norm
intros
by_cases p; by_cases q; simp *
by_cases p; by_cases q
by_cases p
by_cases q
simp *
simp *
by_cases q
simp *
simp *
intros
{ convert bounded.and_then, exact many he }
convert bounded.and_then
exact many he
intros
cases l
rw many_eq_done_nil at h
{ rw many_eq_done_nil at h, exact ⟨h.left.symm, rfl⟩ }
exact ⟨h.left.symm, rfl⟩
rw many_eq_done at h
{ rw many_eq_done at h, obtain ⟨np, hp, -⟩ := h, exact absurd (bounded.of_done hp) hn.not_lt }
obtain ⟨np, hp, -⟩ := h
exact absurd (bounded.of_done hp) hn.not_lt
intros
simp [foldl_core, and.assoc, pure_eq_done]
intros
dsimp [norm_sq]; ring
dsimp [norm_sq]
ring
intros
rw ← of_real_inj; simp [cos_two_mul']
rw ← of_real_inj
simp [cos_two_mul']
intros
have s1 := cos_add ((x + y) / 2) ((x - y) / 2)
have s2 := cos_sub ((x + y) / 2) ((x - y) / 2)
rw [div_add_div_same, add_sub, add_right_comm, add_sub_cancel, half_add_self] at s1
rw [div_sub_div_same, ←sub_add, add_sub_cancel', half_add_self] at s2
rw [s1, s2]
ring
intros
simp [bit0]
intros
rw [is_R_or_C.norm_eq_abs, real.norm_eq_abs]
{ rw [is_R_or_C.norm_eq_abs, real.norm_eq_abs], exact is_R_or_C.abs_re_le_abs _, }
exact is_R_or_C.abs_re_le_abs _
intros
ext1 j
simp only [dfinsupp.filter_apply, dfinsupp.erase_apply, ite_not]
intros
ext j
{ ext j, by_cases h1 : j = i; by_cases h2 : f j ≠ 0; simp at h2; simp [h1, h2] }
by_cases h1 : j = i
by_cases h1 : j = i; by_cases h2 : f j ≠ 0; simp at h2; simp [h1, h2]
by_cases h1 : j = i; by_cases h2 : f j ≠ 0; simp at h2
by_cases h1 : j = i; by_cases h2 : f j ≠ 0
by_cases h2 : f j ≠ 0
simp at h2
simp [h1, h2]
simp at h2
simp [h1, h2]
by_cases h2 : f j ≠ 0
simp at h2
simp [h1, h2]
simp at h2
simp [h1, h2]
intros
{ cases a, cases a_val, refl }
cases a
cases a_val
refl
intros
simp [perm.extend_domain, h]
intros
{ ext i, cases i; refl }
ext i
cases i
cases i; refl
refl
refl
intros
simp [fin_add_flip]
intros
ext x
simp [id_bimap]
intros
simp
intros
cases a; cases b; refl
cases a; cases b
cases a
cases b
refl
intros
rcases i.le_last.eq_or_lt with rfl|H
{ simp }
simp
simp only [ne_of_lt H]
{ simp only [ne_of_lt H], rw ←cast_succ_cast_pred H, simp }
rw ←cast_succ_cast_pred H
simp
intros
simp [piecewise]
intros
simp only [not_mem_empty, false_and, exists_false]
intros
simp [noncomm_fold]
intros
simp [to_multiset_apply, add_monoid_hom.map_finsupp_sum, function.id_def]
intros
ext
simp only [finset.mem_union, mem_support_iff, sup_apply, ne.def, ← bot_eq_zero]
rw sup_eq_bot_iff
tauto
intros
simp [ext_iff, set.ext_iff]
intros
simp
intros
apply bool_iff_false.2; dsimp [contains]; rw [find_empty]; refl
apply bool_iff_false.2; dsimp [contains]; rw [find_empty]
apply bool_iff_false.2; dsimp [contains]
apply bool_iff_false.2
dsimp [contains]
rw [find_empty]
refl
intros
rw [add_comm, int.add_div_of_dvd_right H, add_comm]
intros
rw [mul_comm, mul_comm c, mul_div_mul_of_pos _ _ H]
intros
rw [eq_sub_iff_add_eq, ← int.add_div_of_dvd_left hcab, sub_add_cancel]
intros
{ rw int.lcm, apply nat.lcm_one_right }
rw int.lcm
apply nat.lcm_one_right
intros
{ rw [mul_comm a, mul_comm b], exact h.mul_left c }
rw [mul_comm a, mul_comm b]
exact h.mul_left c
intros
rw [add_comm, odd_add]
intros
split
split; intros h x y hxy
intros h x y hxy
suffices : [x] = [y]
{ suffices : [x] = [y], { simpa using this }, apply h, simp [hxy] }
simpa using this
{ simpa using this }
apply h
simp [hxy]
intros h x y hxy
induction y generalizing x
{ induction y generalizing x, simpa using hxy, cases x, simpa using hxy, simp at hxy, simp [y_ih hxy.2, h hxy.1] }
simpa using hxy
cases x
simpa using hxy
simp at hxy
simp [y_ih hxy.2, h hxy.1]
intros
simp [drop_append_eq_append_drop, take_all_of_le le_self_add]
intros
simp only [scanl, eq_self_iff_true, singleton_append, and_self]
intros
induction l with hd tl hl generalizing n
simp only [length, pmap] at hn
{ simp only [length, pmap] at hn, exact absurd hn (not_lt_of_le n.zero_le) }
exact absurd hn (not_lt_of_le n.zero_le)
cases n
{ cases n, { simp }, { simpa [hl] } }
{ simp }
simp
{ simpa [hl] }
simpa [hl]
intros
induction l; simp [*, filter]
induction l
simp [*, filter]
simp [*, filter]
intros
rw ← list.append_assoc; apply infix_append
rw ← list.append_assoc
apply infix_append
intros
simp only [insert.def, if_pos h]
intros
simp only [list.inter, mem_reverse]; congr
simp only [list.inter, mem_reverse]
intros
simp! [pure,list.ret]
intros
apply relation.refl_trans_gen.head_induction_on h
{ exact ⟨[], chain.nil, rfl⟩ }
exact ⟨[], chain.nil, rfl⟩
intros c d e t ih
{ intros c d e t ih, obtain ⟨l, hl₁, hl₂⟩ := ih, refine ⟨d :: l, chain.cons e hl₁, _⟩, rwa last_cons_cons }
obtain ⟨l, hl₁, hl₂⟩ := ih
refine ⟨d :: l, chain.cons e hl₁, _⟩
rwa last_cons_cons
intros
cases le_total n l with hnl hln
{ rw [max_eq_right hnl, filter_le_of_le hnl] }
rw [max_eq_right hnl, filter_le_of_le hnl]
{ rw [max_eq_left hln, filter_le_of_le_bot hln] }
rw [max_eq_left hln, filter_le_of_le_bot hln]
intros
simp
intros
simp only [range_eq_range', nth_range' _ h, zero_add]
intros
rw [rotate_eq_rotate', rotate'_length_mul]
intros
split
split; { intro h, simpa using h.reverse }
{ intro h, simpa using h.reverse }
intro h
{ intro h, simpa using h.reverse }
simpa using h.reverse
intros
cases option.is_some_iff_exists.mp (lookup_is_some.mpr (mem_keys_of_mem h)) with b' h'
cases nd.eq_of_mk_mem h (of_mem_lookup h')
exact h'
intros
unfold_wf
induction xs with x xs
{ simp [list.erase_dupkeys] }
simp [list.erase_dupkeys]
simp only [erase_dupkeys_cons, list.sizeof, kinsert_def, add_le_add_iff_left, sigma.eta]
{ simp only [erase_dupkeys_cons, list.sizeof, kinsert_def, add_le_add_iff_left, sigma.eta], transitivity, apply sizeof_kerase, assumption }
transitivity
apply sizeof_kerase
assumption
intros
simp only [sublists_aux₁_append, sublists_aux₁, append_assoc, append_nil]
intros
induction l with hd tl hl generalizing l' n
{ simp }
simp
cases l'
{ cases l', { simp }, { cases n, { simp }, { simp [hl] } } }
{ simp }
simp
cases n
{ cases n, { simp }, { simp [hl] } }
{ simp }
simp
{ simp [hl] }
simp [hl]
intros
{ ext i j, simp }
ext i j
simp
intros
ext x y
simp [update_column_apply, subsingleton.elim i x]
intros
simp [dot_product, mul_add, finset.sum_add_distrib]
intros
split
intro h
{ intro h, inhabit n, rw [← scalar_apply_eq r (arbitrary n), ← scalar_apply_eq s (arbitrary n), h] }
inhabit n
rw [← scalar_apply_eq r (arbitrary n), ← scalar_apply_eq s (arbitrary n), h]
{ rintro rfl, refl }
rintro rfl
refl
intros
ext i j
rcases i
rcases i; rcases j; simp [from_blocks]
rcases i; rcases j
rcases j
simp [from_blocks]
simp [from_blocks]
rcases j
simp [from_blocks]
simp [from_blocks]
intros
{ ext, refl }
ext
refl
intros
revert m1
apply m2.induction_on
intros m h hc
{ intros m h hc, rw [rel_zero_right, ← card_eq_zero, hc, card_zero] }
rw [rel_zero_right, ← card_eq_zero, hc, card_zero]
intros a t ih m h hc
{ intros a t ih m h hc, rw card_cons at hc, obtain ⟨b, hb⟩ := card_pos_iff_exists_mem.1 (show 0 < card m, from hc.symm ▸ (nat.succ_pos _)), obtain ⟨m', rfl⟩ := exists_cons_of_mem hb, refine rel_cons_right.mpr ⟨b, m', h _ _ hb (mem_cons_self _ _), ih _ _, rfl⟩, { exact λ _ _ ha hb, h _ _ (mem_cons_of_mem ha) (mem_cons_of_mem hb) }, { simpa using hc } }
rw card_cons at hc
obtain ⟨b, hb⟩ := card_pos_iff_exists_mem.1 (show 0 < card m, from hc.symm ▸ (nat.succ_pos _))
obtain ⟨m', rfl⟩ := exists_cons_of_mem hb
refine rel_cons_right.mpr ⟨b, m', h _ _ hb (mem_cons_self _ _), ih _ _, rfl⟩
{ exact λ _ _ ha hb, h _ _ (mem_cons_of_mem ha) (mem_cons_of_mem hb) }
exact λ _ _ ha hb, h _ _ (mem_cons_of_mem ha) (mem_cons_of_mem hb)
{ simpa using hc }
simpa using hc
intros
rw [add_comm, cons_add, add_comm]
intros
apply hfunext
refl
{ refl }
intros a'' _ h
subst h
apply hfunext
rw [cons_swap]
{ rw [cons_swap] }
intros ha₁ ha₂ h
by_cases h₁ : a'' = a; by_cases h₂ : a'' = a'; simp [*, pi.cons_same, pi.cons_ne] at *
by_cases h₁ : a'' = a; by_cases h₂ : a'' = a'
by_cases h₁ : a'' = a
by_cases h₂ : a'' = a'
simp [*, pi.cons_same, pi.cons_ne] at *
simp [*, pi.cons_same, pi.cons_ne] at *
{ subst h₁, rw [pi.cons_same, pi.cons_same] }
subst h₁
rw [pi.cons_same, pi.cons_same]
by_cases h₂ : a'' = a'
simp [*, pi.cons_same, pi.cons_ne] at *
{ subst h₂, rw [pi.cons_same, pi.cons_same] }
subst h₂
rw [pi.cons_same, pi.cons_same]
simp [*, pi.cons_same, pi.cons_ne] at *
intros
simp [constant_coeff_eq]
intros
{ rw ← comp_eval₂_hom, refl }
rw ← comp_eval₂_hom
refl
intros
{ ext1 f, rw [expand_one_apply, alg_hom.id_apply] }
ext1 f
rw [expand_one_apply, alg_hom.id_apply]
intros
simp [algebra.eq_top_iff, mem_supported]
intros
rw [← mod_add_mod, ← mod_add_mod k, H]
intros
rw add_assoc
exact add_lt_add_of_lt_of_le hab (nat.succ_le_iff.2 hcd)
intros
by_cases n = m
cases h
{ cases h, simp }
simp
rw test_bit_two_pow_of_ne h
{ rw test_bit_two_pow_of_ne h, simp [h] }
simp [h]
intros
refine one_div_lt_one_div_of_lt _ _
{ refine one_div_lt_one_div_of_lt _ _, exact nat.cast_add_one_pos _, simpa }
exact nat.cast_add_one_pos _
simpa
intros
rw [list.map_with_index_eq_enum_map, list.enum_eq_zip_range, list.map_uncurry_zip_eq_zip_with, of_digits_eq_foldr]
induction L with hd tl hl
{ simp }
simp
simpa [list.range_succ_eq_map, list.zip_with_map_left, of_digits_eq_sum_map_with_index_aux] using or.inl hl
{ simpa [list.range_succ_eq_map, list.zip_with_map_left, of_digits_eq_sum_map_with_index_aux] using or.inl hl }
intros
rcases h with ⟨h, b2, m0⟩
have b0 : 0 < b := by linarith
have n0 : 0 < n := by linarith [mul_pos b0 m0]
refine ⟨_, b2, n0⟩
obtain ⟨rfl, rfl⟩ := (nat.div_mod_unique b0).2 ⟨e, hr⟩
subst h
exact nat.digits_def' b2 n0
intros
induction n with n ih
refl
{ refl }
apply part.ext'
show true ↔ ((n : enat).dom ∧ true)
{ show true ↔ ((n : enat).dom ∧ true), rw [← ih, and_true], exact iff.rfl }
rw [← ih, and_true]
exact iff.rfl
intros h H
{ intros h H, show n.succ = (n : enat).get H.1 + 1, rw [nat.cast_succ] at H, revert H, simp only [← ih], intro, refl }
show n.succ = (n : enat).get H.1 + 1
rw [nat.cast_succ] at H
revert H
simp only [← ih]
intro
refl
intros
rw gcd_comm at H; exact eq_zero_of_gcd_eq_zero_left H
rw gcd_comm at H
exact eq_zero_of_gcd_eq_zero_left H
intros
rw [modeq_iff_dvd] at *
{ rw [modeq_iff_dvd] at *, exact (dvd_mul_left (n : ℤ) (m : ℤ)).trans h }
exact (dvd_mul_left (n : ℤ) (m : ℤ)).trans h
intros
induction m with d hd
refl
{refl}
rw [pow_succ, pow_succ]
exact h.mul hd
intros
cases mod_two_eq_zero_or_one m with h₁ h₁; cases mod_two_eq_zero_or_one n with h₂ h₂; simp [even_iff, h₁, h₂, nat.mul_mod]; norm_num
cases mod_two_eq_zero_or_one m with h₁ h₁; cases mod_two_eq_zero_or_one n with h₂ h₂; simp [even_iff, h₁, h₂, nat.mul_mod]
cases mod_two_eq_zero_or_one m with h₁ h₁; cases mod_two_eq_zero_or_one n with h₂ h₂
cases mod_two_eq_zero_or_one m with h₁ h₁
cases mod_two_eq_zero_or_one n with h₂ h₂
simp [even_iff, h₁, h₂, nat.mul_mod]
simp [even_iff, h₁, h₂, nat.mul_mod]
cases mod_two_eq_zero_or_one n with h₂ h₂
simp [even_iff, h₁, h₂, nat.mul_mod]
simp [even_iff, h₁, h₂, nat.mul_mod]
intros
rw [pow_dvd_pow_iff_pow_le_pow (lt_of_succ_lt w), pow_le_iff_le_right w]
intros
split
intro h
{ intro h, by_contradiction hn, have := min_fac_prime hn, rw h at this, exact not_prime_one this, }
by_contradiction hn
have := min_fac_prime hn
rw h at this
exact not_prime_one this
{ rintro rfl, refl, }
rintro rfl
refl
intros
refine ⟨zero_lt_one, lt_of_le_of_ne _ min_fac_ne_bit0.symm⟩
refine @lt_of_le_of_ne ℕ _ _ _ (nat.min_fac_pos _) _
intro e
have := nat.min_fac_prime _
{ rw ← e at this, exact nat.not_prime_one this }
rw ← e at this
exact nat.not_prime_one this
{ exact ne_of_gt (nat.bit1_lt h) }
exact ne_of_gt (nat.bit1_lt h)
intros
simp only [shiftr_eq_div_pow]
apply (nat.div_lt_iff_lt_mul' (dec_trivial : 0 < 4)).2
have := nat.mul_lt_mul_of_pos_left (dec_trivial : 1 < 4) (nat.pos_of_ne_zero h)
rwa mul_one at this
intros
rw ← not_lt; exact not_congr cast_lt
rw ← not_lt
exact not_congr cast_lt
intros
simp
intros
cases o; simp
cases o
simp
simp
intros
linarith
intros
induction t generalizing a₁ a₂
{ simp [erase, raised], exact h }
simp [erase, raised]
exact h
simp [erase]
{ simp [erase], have t_ih_l' := t_ih_l h.left, have t_ih_r' := t_ih_r h.right, clear t_ih_l t_ih_r, cases t_ih_l' with t_l_valid t_l_size, cases t_ih_r' with t_r_valid t_r_size, cases (cmp_le x t_x); simp [erase._match_1]; rw h.sz.1, { suffices h_balanceable, split, { exact valid'.balance_r t_l_valid h.right h_balanceable }, { rw size_balance_r t_l_valid.bal h.right.bal t_l_valid.sz h.right.sz h_balanceable, repeat { apply raised.add_right }, exact t_l_size }, { left, existsi t_l.size, exact (and.intro t_l_size h.bal.1) } }, { have h_glue := valid'.glue h.left h.right h.bal.1, cases h_glue with h_glue_valid h_glue_sized, split, { exact h_glue_valid }, { right, rw h_glue_sized } }, { suffices h_balanceable, split, { exact valid'.balance_l h.left t_r_valid h_balanceable }, { rw size_balance_l h.left.bal t_r_valid.bal h.left.sz t_r_valid.sz h_balanceable, apply raised.add_right, apply raised.add_left, exact t_r_size }, { right, existsi t_r.size, exact (and.intro t_r_size h.bal.1) } } }
have t_ih_l' := t_ih_l h.left
have t_ih_r' := t_ih_r h.right
clear t_ih_l t_ih_r
cases t_ih_l' with t_l_valid t_l_size
cases t_ih_r' with t_r_valid t_r_size
cases (cmp_le x t_x); simp [erase._match_1]; rw h.sz.1
cases (cmp_le x t_x); simp [erase._match_1]
cases (cmp_le x t_x)
simp [erase._match_1]
rw h.sz.1
suffices h_balanceable
{ suffices h_balanceable, split, { exact valid'.balance_r t_l_valid h.right h_balanceable }, { rw size_balance_r t_l_valid.bal h.right.bal t_l_valid.sz h.right.sz h_balanceable, repeat { apply raised.add_right }, exact t_l_size }, { left, existsi t_l.size, exact (and.intro t_l_size h.bal.1) } }
split
{ exact valid'.balance_r t_l_valid h.right h_balanceable }
exact valid'.balance_r t_l_valid h.right h_balanceable
rw size_balance_r t_l_valid.bal h.right.bal t_l_valid.sz h.right.sz h_balanceable
{ rw size_balance_r t_l_valid.bal h.right.bal t_l_valid.sz h.right.sz h_balanceable, repeat { apply raised.add_right }, exact t_l_size }
apply raised.add_right
repeat { apply raised.add_right }
apply raised.add_right
apply raised.add_right
exact t_l_size
{ left, existsi t_l.size, exact (and.intro t_l_size h.bal.1) }
left
existsi t_l.size
exact (and.intro t_l_size h.bal.1)
simp [erase._match_1]
rw h.sz.1
have h_glue := valid'.glue h.left h.right h.bal.1
{ have h_glue := valid'.glue h.left h.right h.bal.1, cases h_glue with h_glue_valid h_glue_sized, split, { exact h_glue_valid }, { right, rw h_glue_sized } }
cases h_glue with h_glue_valid h_glue_sized
split
{ exact h_glue_valid }
exact h_glue_valid
{ right, rw h_glue_sized }
right
rw h_glue_sized
simp [erase._match_1]
rw h.sz.1
suffices h_balanceable
{ suffices h_balanceable, split, { exact valid'.balance_l h.left t_r_valid h_balanceable }, { rw size_balance_l h.left.bal t_r_valid.bal h.left.sz t_r_valid.sz h_balanceable, apply raised.add_right, apply raised.add_left, exact t_r_size }, { right, existsi t_r.size, exact (and.intro t_r_size h.bal.1) } }
split
{ exact valid'.balance_l h.left t_r_valid h_balanceable }
exact valid'.balance_l h.left t_r_valid h_balanceable
rw size_balance_l h.left.bal t_r_valid.bal h.left.sz t_r_valid.sz h_balanceable
{ rw size_balance_l h.left.bal t_r_valid.bal h.left.sz t_r_valid.sz h_balanceable, apply raised.add_right, apply raised.add_left, exact t_r_size }
apply raised.add_right
apply raised.add_left
exact t_r_size
{ right, existsi t_r.size, exact (and.intro t_r_size h.bal.1) }
right
existsi t_r.size
exact (and.intro t_r_size h.bal.1)
intros
cases m; simp [node4_l, all_node', all, all_node3_l, and_assoc]
cases m
simp [node4_l, all_node', all, all_node3_l, and_assoc]
simp [node4_l, all_node', all, all_node3_l, and_assoc]
intros
simp [res, @eq_comm _ b]
intros
cases x with a f; rw [W_mk', W_dest'_W_mk, split_drop_fun_last_fun]
cases x with a f
rw [W_mk', W_dest'_W_mk, split_drop_fun_last_fun]
intros
split
split; intro h; try { apply pnat.eq}; rw h; simp
split; intro h; try { apply pnat.eq}; rw h
split; intro h; try { apply pnat.eq}
split; intro h
{ split; intro h; try { apply pnat.eq}; rw h; simp }
intro h
try { apply pnat.eq}
rw h
simp
intro h
try { apply pnat.eq}
apply pnat.eq
rw h
simp
intros
have := prod_of_nat_multiset (l : multiset ℕ) h
{ have := prod_of_nat_multiset (l : multiset ℕ) h, rw [multiset.coe_prod] at this, exact this }
rw [multiset.coe_prod] at this
exact this
intros
simp [coeff_monomial]
intros
simp [coeff_erase, h]
intros
rw ← card_singleton n
apply card_le_of_subset (support_C_mul_X_pow c n)
intros
{ rw C_mul_X_pow_eq_monomial, exact le_trailing_degree_monomial }
rw C_mul_X_pow_eq_monomial
exact le_trailing_degree_monomial
intros
conv_rhs { rw [← mod_by_monic_add_div p monic_one] }
conv_rhs { rw [← mod_by_monic_add_div p monic_one] }; simp
simp
intros
induction n with n ih
{ simp only [eval₂_zero, nat.cast_zero] }
simp only [eval₂_zero, nat.cast_zero]
rw [n.cast_succ, eval₂_add, ih, eval₂_one, n.cast_succ]
{ rw [n.cast_succ, eval₂_add, ih, eval₂_one, n.cast_succ] }
intros
induction k with k ih
{ simp, }
simp
{ simp [ih, pow_succ', ←mul_assoc, mul_X_comp], }
simp [ih, pow_succ', ←mul_assoc, mul_X_comp]
intros
rw [← monomial_one_one_eq_X, hasse_deriv_monomial, nat.choose_eq_zero_of_lt hk, nat.cast_zero, zero_mul, monomial_zero_right]
intros
simp [integral_normalization]
intros
simpa only [sub_eq_add_neg, C_neg] using monic_X_add_C (-x)
intros
split
assume H
{ assume H, rw finset.card_le_one_iff_subset_singleton at H, rcases H with ⟨n, hn⟩, refine ⟨n, f.coeff n, _⟩, ext i, by_cases hi : i = n, { simp [hi, coeff_monomial] }, { have : f.coeff i = 0, { rw ← not_mem_support_iff, exact λ hi', hi (finset.mem_singleton.1 (hn hi')) }, simp [this, ne.symm hi, coeff_monomial] } }
rw finset.card_le_one_iff_subset_singleton at H
rcases H with ⟨n, hn⟩
refine ⟨n, f.coeff n, _⟩
ext i
by_cases hi : i = n
{ simp [hi, coeff_monomial] }
simp [hi, coeff_monomial]
have : f.coeff i = 0
{ have : f.coeff i = 0, { rw ← not_mem_support_iff, exact λ hi', hi (finset.mem_singleton.1 (hn hi')) }, simp [this, ne.symm hi, coeff_monomial] }
rw ← not_mem_support_iff
{ rw ← not_mem_support_iff, exact λ hi', hi (finset.mem_singleton.1 (hn hi')) }
exact λ hi', hi (finset.mem_singleton.1 (hn hi'))
simp [this, ne.symm hi, coeff_monomial]
rintros ⟨n, a, rfl⟩
{ rintros ⟨n, a, rfl⟩, rw ← finset.card_singleton n, apply finset.card_le_of_subset, exact support_monomial' _ _ }
rw ← finset.card_singleton n
apply finset.card_le_of_subset
exact support_monomial' _ _
intros
rw [←polynomial.C_mul', ←polynomial.eq_C_of_degree_eq_zero (degree_coe_units c)]
intros
rw [cofix.corec',cofix.dest_corec]
dsimp
congr' with (i|i); rw corec_roll; dsimp [cofix.corec']
congr' with (i|i); rw corec_roll
congr' with (i|i)
rw corec_roll
dsimp [cofix.corec']
mv_bisim i
{ mv_bisim i, rw [Ha,Hb,cofix.dest_corec], dsimp [(∘)], repeat { rw [mvfunctor.map_map,← append_fun_comp_id] }, apply liftr_map_last', dsimp [(∘),R], intros, exact ⟨_,rfl,rfl⟩ }
rw [Ha,Hb,cofix.dest_corec]
dsimp [(∘)]
rw [mvfunctor.map_map,← append_fun_comp_id]
repeat { rw [mvfunctor.map_map,← append_fun_comp_id] }
rw [mvfunctor.map_map,← append_fun_comp_id]
rw [mvfunctor.map_map,← append_fun_comp_id]
apply liftr_map_last'
dsimp [(∘),R]
intros
exact ⟨_,rfl,rfl⟩
rw corec_roll
dsimp [cofix.corec']
congr' with y
{ congr' with y, erw [append_fun_id_id], simp [mvfunctor.id_map] }
erw [append_fun_id_id]
simp [mvfunctor.id_map]
intros
rw mk_pnat_denom
apply nat.div_dvd_of_dvd
apply nat.gcd_dvd_right
intros
rw [rat.floor_def]
cases decidable.em (d = 0) with d_eq_zero d_ne_zero
{ simp [d_eq_zero] }
simp [d_eq_zero]
cases decidable.em (n = 0) with n_eq_zero n_ne_zero
{ cases decidable.em (n = 0) with n_eq_zero n_ne_zero, { simp [n_eq_zero] }, { set q := (n : ℚ) / d with q_eq, obtain ⟨c, n_eq_c_mul_num, d_eq_c_mul_denom⟩ : ∃ c, n = c * q.num ∧ (d : ℤ) = c * q.denom, by { rw q_eq, exact_mod_cast (@rat.exists_eq_mul_div_num_and_eq_mul_div_denom n d n_ne_zero (by exact_mod_cast d_ne_zero)) }, suffices : q.num / q.denom = c * q.num / (c * q.denom), by rwa [n_eq_c_mul_num, d_eq_c_mul_denom], suffices : c > 0, by solve_by_elim [int.mul_div_mul_of_pos], have q_denom_mul_c_pos : (0 : ℤ) < q.denom * c, by { have : (d : ℤ) > 0, by exact_mod_cast (pos_iff_ne_zero.elim_right d_ne_zero), rwa [d_eq_c_mul_denom, mul_comm] at this }, suffices : (0 : ℤ) ≤ q.denom, from pos_of_mul_pos_left q_denom_mul_c_pos this, exact_mod_cast (le_of_lt q.pos) } }
{ simp [n_eq_zero] }
simp [n_eq_zero]
set q := (n : ℚ) / d with q_eq
{ set q := (n : ℚ) / d with q_eq, obtain ⟨c, n_eq_c_mul_num, d_eq_c_mul_denom⟩ : ∃ c, n = c * q.num ∧ (d : ℤ) = c * q.denom, by { rw q_eq, exact_mod_cast (@rat.exists_eq_mul_div_num_and_eq_mul_div_denom n d n_ne_zero (by exact_mod_cast d_ne_zero)) }, suffices : q.num / q.denom = c * q.num / (c * q.denom), by rwa [n_eq_c_mul_num, d_eq_c_mul_denom], suffices : c > 0, by solve_by_elim [int.mul_div_mul_of_pos], have q_denom_mul_c_pos : (0 : ℤ) < q.denom * c, by { have : (d : ℤ) > 0, by exact_mod_cast (pos_iff_ne_zero.elim_right d_ne_zero), rwa [d_eq_c_mul_denom, mul_comm] at this }, suffices : (0 : ℤ) ≤ q.denom, from pos_of_mul_pos_left q_denom_mul_c_pos this, exact_mod_cast (le_of_lt q.pos) }
obtain ⟨c, n_eq_c_mul_num, d_eq_c_mul_denom⟩ : ∃ c, n = c * q.num ∧ (d : ℤ) = c * q.denom
rw q_eq
rw q_eq
{ rw q_eq, exact_mod_cast (@rat.exists_eq_mul_div_num_and_eq_mul_div_denom n d n_ne_zero (by exact_mod_cast d_ne_zero)) }
{ rw q_eq, exact_mod_cast (@rat.exists_eq_mul_div_num_and_eq_mul_div_denom n d n_ne_zero (by exact_mod_cast d_ne_zero)) }
exact_mod_cast (@rat.exists_eq_mul_div_num_and_eq_mul_div_denom n d n_ne_zero (by exact_mod_cast d_ne_zero))
exact_mod_cast (@rat.exists_eq_mul_div_num_and_eq_mul_div_denom n d n_ne_zero (by exact_mod_cast d_ne_zero))
suffices : q.num / q.denom = c * q.num / (c * q.denom)
rwa [n_eq_c_mul_num, d_eq_c_mul_denom]
rwa [n_eq_c_mul_num, d_eq_c_mul_denom]
suffices : c > 0
solve_by_elim [int.mul_div_mul_of_pos]
solve_by_elim [int.mul_div_mul_of_pos]
have q_denom_mul_c_pos : (0 : ℤ) < q.denom * c
have : (d : ℤ) > 0
have : (d : ℤ) > 0
{ have : (d : ℤ) > 0, by exact_mod_cast (pos_iff_ne_zero.elim_right d_ne_zero), rwa [d_eq_c_mul_denom, mul_comm] at this }
{ have : (d : ℤ) > 0, by exact_mod_cast (pos_iff_ne_zero.elim_right d_ne_zero), rwa [d_eq_c_mul_denom, mul_comm] at this }
exact_mod_cast (pos_iff_ne_zero.elim_right d_ne_zero)
exact_mod_cast (pos_iff_ne_zero.elim_right d_ne_zero)
exact_mod_cast (pos_iff_ne_zero.elim_right d_ne_zero)
rwa [d_eq_c_mul_denom, mul_comm] at this
rwa [d_eq_c_mul_denom, mul_comm] at this
suffices : (0 : ℤ) ≤ q.denom
from pos_of_mul_pos_left q_denom_mul_c_pos this
exact_mod_cast (le_of_lt q.pos)
intros
cases decidable.em (0 < q) with q_pos q_nonpos
{ simp [rat.lt_def] }
simp [rat.lt_def]
replace q_nonpos : q ≤ 0
{ replace q_nonpos : q ≤ 0, from not_lt.elim_left q_nonpos, have : q.num < q.denom, by { have : ¬0 < q.num ↔ ¬0 < q, from not_iff_not.elim_right num_pos_iff_pos, simp only [not_lt] at this, exact lt_of_le_of_lt (this.elim_right q_nonpos) (by exact_mod_cast q.pos) }, simp only [this, (lt_of_le_of_lt q_nonpos zero_lt_one)] }
from not_lt.elim_left q_nonpos
have : q.num < q.denom
have : ¬0 < q.num ↔ ¬0 < q
have : ¬0 < q.num ↔ ¬0 < q
{ have : ¬0 < q.num ↔ ¬0 < q, from not_iff_not.elim_right num_pos_iff_pos, simp only [not_lt] at this, exact lt_of_le_of_lt (this.elim_right q_nonpos) (by exact_mod_cast q.pos) }
{ have : ¬0 < q.num ↔ ¬0 < q, from not_iff_not.elim_right num_pos_iff_pos, simp only [not_lt] at this, exact lt_of_le_of_lt (this.elim_right q_nonpos) (by exact_mod_cast q.pos) }
from not_iff_not.elim_right num_pos_iff_pos
from not_iff_not.elim_right num_pos_iff_pos
simp only [not_lt] at this
simp only [not_lt] at this
exact lt_of_le_of_lt (this.elim_right q_nonpos) (by exact_mod_cast q.pos)
exact lt_of_le_of_lt (this.elim_right q_nonpos) (by exact_mod_cast q.pos)
simp only [this, (lt_of_le_of_lt q_nonpos zero_lt_one)]
intros
cases h' : f n; simp [h']
{ cases h' : f n; simp [h'], apply pow_nonneg h }
cases h' : f n
simp [h']
simp [h']
apply pow_nonneg h
intros
simpa only [sub_mul, sub_eq_iff_eq_add, one_mul] using h.sub_one_mul_conj
intros
by_cases h0 : x = 0
{ simp only [h0, mul_zero, infi_const] }
simp only [h0, mul_zero, infi_const]
{ exact infi_mul_of_ne h0 h }
exact infi_mul_of_ne h0 h
have := nat.prime.irrational_sqrt (show nat.prime 5, by norm_num)
have := this.rat_add 1
have := this.rat_mul (show (0.5 : ℚ) ≠ 0, by norm_num)
convert this
field_simp
intros
by_contra rid
rcases exists_eq_X_add_C_of_nat_degree_le_one (not_lt.1 rid) with ⟨a, b, rfl⟩
clear rid
have : (a : ℝ) * x = -b
simpa [eq_neg_iff_add_eq_zero] using x_is_root
simpa [eq_neg_iff_add_eq_zero] using x_is_root
rcases em (a = 0) with (rfl|ha)
obtain rfl : b = 0
{ obtain rfl : b = 0, by simpa, simpa using p_nonzero }
simpa
simpa
simpa using p_nonzero
rw [mul_comm, ← eq_div_iff_mul_eq, eq_comm] at this
{ rw [mul_comm, ← eq_div_iff_mul_eq, eq_comm] at this, refine hx ⟨-b / a, _⟩, assumption_mod_cast, assumption_mod_cast }
refine hx ⟨-b / a, _⟩
assumption_mod_cast
assumption_mod_cast
intros
rw [real.sqrt, real.to_nnreal_coe]
intros
rw [sq, mul_self_sqrt x]
intros
dsimp [corec, destruct]
change stream.corec' (corec.F f) (sum.inr b) 0 with corec.F._match_1 (f b)
induction h : f b with a b'
refl
{ refl }
dsimp [corec.F, destruct]
apply congr_arg
apply subtype.eq
dsimp [corec, tail]
rw [stream.corec'_eq, stream.tail_cons]
dsimp [corec.F]
rw h
intros
rw ←bind_ret; apply mem_bind m; apply ret_mem
rw ←bind_ret; apply mem_bind m
rw ←bind_ret
apply mem_bind m
apply ret_mem
intros
rw [← ite_inter, ← h, ite_same]
intros
{ ext ⟨x, y⟩, simp [and_assoc, and.left_comm] }
ext ⟨x, y⟩
simp [and_assoc, and.left_comm]
intros
{ ext, simp [pi] }
ext
simp [pi]
intros
simp only [image2_image2_left, image2_image2_right, h_assoc]
intros
classical
convert (fintype.pi_finset (λ d, (ht d).to_finset)).finite_to_set
ext
simp
intros
ext x
simp only [mem_pi, mem_inter_eq, ← forall_and_distrib]
refine forall_congr (λ i, _)
by_cases hi : i ∈ s'; simp *
by_cases hi : i ∈ s'
simp *
simp *
intros
rw max_comm
{ rw max_comm, apply Ioc_union_Ioc; rw max_comm; exact min_le_max }
apply Ioc_union_Ioc
apply Ioc_union_Ioc; rw max_comm; exact min_le_max
apply Ioc_union_Ioc; rw max_comm
rw max_comm
exact min_le_max
rw max_comm
exact min_le_max
intros
rw [← Ici_diff_left, diff_diff_cancel_left (singleton_subset_iff.2 left_mem_Ici)]
intros
simp [← Ici_inter_Iic, inter_comm]
intros
simp
intros
simp [← Ici_inter_Iic, h]
intros
rw [bUnion_preimage_singleton, preimage_range]
intros
have p : x ∈ ⊤ := set.mem_univ x
simpa only [←w, set.mem_Union] using p
intros
{ ext, simp only [Inf_image, infi_apply, infi_Prop_eq], refl }
ext
simp only [Inf_image, infi_apply, infi_Prop_eq]
refl
intros
induction i; [refl, erw [typevec.const,@i_ih (drop α) x]]
induction i
refl
erw [typevec.const,@i_ih (drop α) x]
intros
cases v with l hl
subst hl
simp only [list.nodup_iff_nth_le_inj]
split
intros h i j hij
{ intros h i j hij, cases i, cases j, ext, apply h, simpa }
cases i
cases j
ext
apply h
simpa
intros h i j hi hj hij
{ intros h i j hi hj hij, have := @h ⟨i, hi⟩ ⟨j, hj⟩, simp [nth_eq_nth_le] at *, tauto }
have := @h ⟨i, hi⟩ ⟨j, hj⟩
simp [nth_eq_nth_le] at *
tauto
intros
cases n
{ rw [int.cast_id a, int.cast_id a], }
rw [int.cast_id a, int.cast_id a]
rw [coe_coe, int.nat_cast_eq_coe_nat, int.cast_coe_nat, fin.coe_coe_eq_self]
{ rw [coe_coe, int.nat_cast_eq_coe_nat, int.cast_coe_nat, fin.coe_coe_eq_self] }
intros
rw [hf.map_mul, hf.map_inv] at h
apply inv_injective
rw eq_inv_of_mul_eq_one h
intros
simpa only [h.comp_eq] using bij_on_fixed_pts_comp g f
intros
{ ext, rw [← mem_to_subalgebra, ← mem_to_subalgebra, h] }
ext
rw [← mem_to_subalgebra, ← mem_to_subalgebra, h]
intros
casesI hF
rcases hg with ⟨g, m, hm⟩
{ rcases hg with ⟨g, m, hm⟩, rw [one_pow, expand_one] at hm, rw hf.eq_degree, rw hm, }
rw [one_pow, expand_one] at hm
rw hf.eq_degree
rw hm
rcases hg with ⟨hg, m, hm⟩
{ rcases hg with ⟨hg, m, hm⟩, let g' := classical.some hf, cases (classical.some_spec hf).2 with m' hm', haveI : fact q.prime := fact_iff.2 hF_hprime, apply contraction_degree_eq_or_insep q g g' m m', rw [hm, hm'], exact hg, exact (classical.some_spec hf).1 }
let g' := classical.some hf
cases (classical.some_spec hf).2 with m' hm'
haveI : fact q.prime := fact_iff.2 hF_hprime
apply contraction_degree_eq_or_insep q g g' m m'
rw [hm, hm']
exact hg
exact (classical.some_spec hf).1
intros
rw [nat_degree_remove_factor, hfn, n.add_sub_cancel]
intros
rw [cos_angle, div_mul_cancel_of_imp]
simp [or_imp_distrib] { contextual := tt }
intros
simp_rw [centroid_def, affine_combination_apply, weighted_vsub_of_point_apply, sum_points_with_circumcenter, centroid_weights_with_circumcenter, points_with_circumcenter_point, zero_smul, add_zero, centroid_weights, set.sum_indicator_subset_of_eq_zero (function.const (fin (n + 1)) ((card fs : ℝ)⁻¹)) (λ i wi, wi • (s.points i -ᵥ classical.choice add_torsor.nonempty)) fs.subset_univ (λ i, zero_smul ℝ _), set.indicator_apply]
congr
funext
congr' 2
intros
obtain ⟨i₃, h₂₃, h₁₃⟩ : ∃ i₃, i₂ ≠ i₃ ∧ i₁ ≠ i₃
clear h₁ h₂
{ clear h₁ h₂, dec_trivial! }
dec_trivial!
rw t.altitude_eq_monge_plane h₁₃ h₁₂ h₂₃.symm at h₁
rw t.altitude_eq_monge_plane h₂₃ h₁₂.symm h₁₃.symm at h₂
rw orthocenter_eq_monge_point
have ha : ∀ i, i₃ ≠ i → p ∈ t.monge_plane i₃ i
intros i hi
{ intros i hi, have hi₁₂ : i₁ = i ∨ i₂ = i, { clear h₁ h₂, dec_trivial! }, cases hi₁₂, { exact hi₁₂ ▸ h₂ }, { exact hi₁₂ ▸ h₁ } }
have hi₁₂ : i₁ = i ∨ i₂ = i
clear h₁ h₂
{ clear h₁ h₂, dec_trivial! }
dec_trivial!
cases hi₁₂
{ exact hi₁₂ ▸ h₂ }
exact hi₁₂ ▸ h₂
{ exact hi₁₂ ▸ h₁ }
exact hi₁₂ ▸ h₁
exact eq_monge_point_of_forall_mem_monge_plane ha
intros
refine real.inj_on_cos ⟨angle_nonneg _ _, angle_le_pi _ _⟩ ⟨angle_nonneg _ _, angle_le_pi _ _⟩ _
rw [cos_angle, cos_angle, h, ←neg_sub, norm_neg, neg_sub, inner_sub_right, inner_sub_right, real_inner_self_eq_norm_sq, real_inner_self_eq_norm_sq, h, real_inner_comm x y]
intros
rw [mfderiv_within, mfderiv_within, ext_chart_preimage_inter_eq, mdifferentiable_within_at_inter ht, fderiv_within_inter (ext_chart_preimage_mem_nhds I x ht) hs]
intros
simp only [times_cont_mdiff_on, times_cont_mdiff, times_cont_mdiff_within_at_univ, forall_prop_of_true, mem_univ]
intros
ext h
rw [mem_stabilizer_iff, ← smul_left_cancel_iff g⁻¹, smul_smul, smul_smul, smul_smul, mul_left_inv, one_smul, ← mem_stabilizer_iff, subgroup.mem_map_equiv, mul_aut.conj_symm_apply]
intros
rw mk_eq_monoid_of_mk'_apply; exact mul_equiv_of_quotient_mk' _ _
rw mk_eq_monoid_of_mk'_apply
exact mul_equiv_of_quotient_mk' _ _
intros
refine monotone_nat_of_le_succ _
intros n x hx y
rw [mul_assoc, mul_assoc, ← mul_assoc y x⁻¹ y⁻¹]
exact mul_mem (upper_central_series G n) hx (normal.conj_mem (upper_central_series.subgroup.normal G n) x⁻¹ (inv_mem _ hx) y)
intros
convert minimal_period_iterate_eq_div_gcd' h
simp only [order_of, mul_left_iterate]
intros
by_cases hx : f x = x
rw ←cycle_of_eq_one_iff at hx
{ rw ←cycle_of_eq_one_iff at hx, simp [hx] }
simp [hx]
refine dvd_of_mem_cycle_type _
{ refine dvd_of_mem_cycle_type _, rw [cycle_type, multiset.mem_map], refine ⟨f.cycle_of x, _, _⟩, { rwa [←finset.mem_def, cycle_of_mem_cycle_factors_finset_iff, mem_support] }, { simp [order_of_is_cycle (is_cycle_cycle_of _ hx)] } }
rw [cycle_type, multiset.mem_map]
refine ⟨f.cycle_of x, _, _⟩
rwa [←finset.mem_def, cycle_of_mem_cycle_factors_finset_iff, mem_support]
{ rwa [←finset.mem_def, cycle_of_mem_cycle_factors_finset_iff, mem_support] }
{ simp [order_of_is_cycle (is_cycle_cycle_of _ hx)] }
simp [order_of_is_cycle (is_cycle_cycle_of _ hx)]
intros
rw [←pow_two, ←card_support_eq_three_iff, support_pow_coprime, ht.card_support]
rw [ht.order_of, nat.coprime_iff_gcd_eq_one]
norm_num
intros
rw [cycle_range_of_le h]
{ rw [cycle_range_of_le h], split_ifs with h', { refl }, exact coe_add_one_of_lt (calc (j : ℕ) < i : fin.lt_iff_coe_lt_coe.mp (lt_of_le_of_ne h h') ... ≤ n : nat.lt_succ_iff.mp i.2) }
split_ifs with h'
refl
{ refl }
exact coe_add_one_of_lt (calc (j : ℕ) < i : fin.lt_iff_coe_lt_coe.mp (lt_of_le_of_ne h h') ... ≤ n : nat.lt_succ_iff.mp i.2)
intros
induction n with n hn
{ simp }
simp
rw [nat.succ_eq_add_one, ←rotate_rotate, form_perm_rotate_one, hn]
{ rw [nat.succ_eq_add_one, ←rotate_rotate, form_perm_rotate_one, hn], rwa is_rotated.nodup_iff, exact is_rotated.forall l n }
rwa is_rotated.nodup_iff
exact is_rotated.forall l n
intros
refine eq_top_iff.mpr (λ x hx, _)
obtain ⟨h1, h2⟩ := subtype.mem (trunc_swap_factors x).out
rw ← h1
exact subgroup.list_prod_mem _ (λ y hy, subgroup.subset_closure (h2 y hy))
intros
by_cases hx : f x = x
simp [hx, sdiff_singleton_eq_erase, not_mem_support.mpr hx, erase_eq_of_not_mem]
{ simp [hx, sdiff_singleton_eq_erase, not_mem_support.mpr hx, erase_eq_of_not_mem] }
ext z
by_cases hzx : z = x
{ simp [hzx] }
simp [hzx]
by_cases hzf : z = f x
{ simp [hzf, hx, h, swap_apply_of_ne_of_ne], }
simp [hzf, hx, h, swap_apply_of_ne_of_ne]
by_cases hzfx : f z = x
{ simp [ne.symm hzx, hzx, ne.symm hzf, hzfx] }
simp [ne.symm hzx, hzx, ne.symm hzf, hzfx]
simp [ne.symm hzx, hzx, ne.symm hzf, hzfx, f.injective.ne hzx, swap_apply_of_ne_of_ne]
{ simp [ne.symm hzx, hzx, ne.symm hzf, hzfx, f.injective.ne hzx, swap_apply_of_ne_of_ne] }
apply is_cyclic_of_order_of_eq_card
rw [card, mul_one]
exact order_of_xa 0
intros
rw subgroup.eq_bot_iff_forall
intros y hy
rw [← subgroup.coe_mk H y hy, subsingleton.elim (⟨y, hy⟩ : H) 1, subgroup.coe_one]
intros
revert b
refine add_submonoid.closure_induction ha _ _ _
refine add_submonoid.closure_induction ha _ _ _; clear ha a
clear ha a
exact λ r hr b hb, add_submonoid.mem_closure.mpr (λ y hy, hy (S.mul_mem hr hb))
{ exact λ r hr b hb, add_submonoid.mem_closure.mpr (λ y hy, hy (S.mul_mem hr hb)) }
clear ha a
exact λ b hb, by simp only [zero_mul, (add_submonoid.closure (S : set R)).zero_mem]
{ exact λ b hb, by simp only [zero_mul, (add_submonoid.closure (S : set R)).zero_mem] }
clear ha a
simp_rw add_mul
{ simp_rw add_mul, exact λ r s hr hs b hb, (add_submonoid.closure (S : set R)).add_mem (hr hb) (hs hb) }
exact λ r s hr hs b hb, (add_submonoid.closure (S : set R)).add_mem (hr hb) (hs hb)
intros
rw [P.sylow_mem_fixed_points_iff, ←inf_eq_left, hP.inf_normalizer_sylow, inf_eq_left]
intros
conv_lhs { rw [vector_span_eq_span_vsub_set_right k hp, ←set.insert_eq_of_mem hp, ←set.insert_diff_singleton, set.image_insert_eq] }
simp [submodule.span_insert_eq_span]
intros
rw sum_centroid_weights_indicator
exact s.sum_centroid_weights_eq_one_of_nonempty k h
intros
let f : set.range p → ι := λ x, x.property.some
have hf : ∀ x, p (f x) = x := λ x, x.property.some_spec
let fe : set.range p ↪ ι := ⟨f, λ x₁ x₂ he, subtype.ext (hf x₁ ▸ hf x₂ ▸ he ▸ rfl)⟩
convert ha.comp_embedding fe
ext
simp [hf]
intros
simp only [line_map_apply_module]
exact add_lt_add_left (smul_lt_smul_of_pos hb hr) _
intros
simpa [disjoint] using @disjoint_ker _ _ _ _ _ _ _ _ _ _ _ f ⊤
intros
{ ext ⟨b, hb⟩, refl }
ext ⟨b, hb⟩
refl
intros
{ ext A x y, simp [flip_hom_aux] }
ext A x y
simp [flip_hom_aux]
intros
simp [← to_matrix_eq_to_matrix']
intros
split
intro h
{ intro h, let t := basis.of_vector_space K V, rw [← t.mk_eq_dim'', cardinal.le_mk_iff_exists_subset] at h, rcases h with ⟨s, hst, hsc⟩, exact ⟨s, hsc, (of_vector_space_index.linear_independent K V).mono hst⟩ }
let t := basis.of_vector_space K V
rw [← t.mk_eq_dim'', cardinal.le_mk_iff_exists_subset] at h
rcases h with ⟨s, hst, hsc⟩
exact ⟨s, hsc, (of_vector_space_index.linear_independent K V).mono hst⟩
rintro ⟨s, rfl, si⟩
{ rintro ⟨s, rfl, si⟩, exact cardinal_le_dim_of_linear_independent si }
exact cardinal_le_dim_of_linear_independent si
intros
apply le_antisymm
{ exact linear_independent_le_basis b v i, }
exact linear_independent_le_basis b v i
haveI : nontrivial R := nontrivial_of_invariant_basis_number R
{ haveI : nontrivial R := nontrivial_of_invariant_basis_number R, exact infinite_basis_le_maximal_linear_independent b v i m, }
exact infinite_basis_le_maximal_linear_independent b v i m
intros
rw [finsupp.total_apply, finsupp.sum, linear_map.map_sum]
simp_rw [linear_map.map_smul, to_dual_apply, smul_eq_mul, mul_boole, finset.sum_ite_eq]
split_ifs with h
{ refl }
refl
{ rw finsupp.not_mem_support_iff.mp h }
rw finsupp.not_mem_support_iff.mp h
intros
rw [submodule.dual_annihilator_comap, ← module.eval_equiv_to_linear_map]
exact linear_equiv.finrank_eq (linear_equiv.of_submodule' _ _)
intros
rw [← S.to_submodule_equiv.dim_eq, h, (linear_equiv.of_eq (⊥ : subalgebra F E).to_submodule _ algebra.to_submodule_bot).dim_eq, dim_span_set]
exacts [mk_singleton _, linear_independent_singleton one_ne_zero]
intros
have h := dim_eq_of_injective _ hinj
rw [← finrank_eq_dim, ← finrank_eq_dim, nat_cast_inj] at h
exact range_eq_top.1 (eq_top_of_finrank_eq h.symm)
intros
intro x
obtain ⟨y, hy⟩ := h x
exact ⟨finsupp.single y 1, by simp [hy]⟩
intros
by_contra h
refine zero_ne_one (eq_of_fin_equiv R _)
haveI := not_nontrivial_iff_subsingleton.1 h
haveI : subsingleton (fin 1 → R) := ⟨λ a b, funext $ λ x, subsingleton.elim _ _⟩
refine { .. }; { intros, exact 0 } <|> tidy
refine { .. }
{ intros, exact 0 }
{ intros, exact 0 }
tidy
intros
rw linear_independent_iff'' at hv ⊢
intros s g hgs hsum i
refine (smul_eq_zero_iff_eq (w i)).1 _
refine hv s (λ i, w i • g i) (λ i hi, _) _ i
dsimp only
{ dsimp only, exact (hgs i hi).symm ▸ smul_zero _ }
exact (hgs i hi).symm ▸ smul_zero _
rw [← hsum, finset.sum_congr rfl _]
{ rw [← hsum, finset.sum_congr rfl _], intros, erw [pi.smul_apply, smul_assoc, smul_comm] }
intros
erw [pi.smul_apply, smul_assoc, smul_comm]
intros
have h : M.charpoly • (1 : matrix n n (polynomial R)) = adjugate (charmatrix M) * (charmatrix M) := (adjugate_mul _).symm
apply_fun mat_poly_equiv at h
simp only [mat_poly_equiv.map_mul, mat_poly_equiv_charmatrix] at h
apply_fun (λ p, p.eval M) at h
rw eval_mul_X_sub_C at h
rw [mat_poly_equiv_smul_one, eval_map] at h
exact h
intros
convert det_unique _
exact unique_of_subsingleton k
intros
ext i j
convert congr_fun (cramer_row_self (1 : matrix n n α) (pi.single i 1) i _) j
{ simp }
simp
intros j
{ intros j, rw [matrix.one_eq_pi_single, pi.single_comm] }
rw [matrix.one_eq_pi_single, pi.single_comm]
intros
simp only [linear_map.to_matrix', linear_equiv.coe_mk]
congr
ext j'
split_ifs with h
{ rw [h, std_basis_same] }
rw [h, std_basis_same]
apply std_basis_ne _ _ _ _ h
intros
rw [← linear_map.to_matrix_alg_equiv_id v₁, matrix.to_lin_alg_equiv_to_matrix_alg_equiv]
intros
simp [transvection, matrix.add_mul]
intros
let Q : matrix n n 𝕜 → Prop := λ N, det N ≠ 0 ∧ P N
have : Q M
apply diagonal_transvection_induction Q M
{ apply diagonal_transvection_induction Q M, { assume D hD, have detD : det (diagonal D) ≠ 0, by { rw hD, exact hMdet }, exact ⟨detD, hdiag _ detD⟩ }, { assume t, exact ⟨by simp, htransvec t⟩ }, { assume A B QA QB, exact ⟨by simp [QA.1, QB.1], hmul A B QA.1 QB.1 QA.2 QB.2⟩ } }
assume D hD
{ assume D hD, have detD : det (diagonal D) ≠ 0, by { rw hD, exact hMdet }, exact ⟨detD, hdiag _ detD⟩ }
have detD : det (diagonal D) ≠ 0
rw hD
rw hD
{ rw hD, exact hMdet }
{ rw hD, exact hMdet }
exact hMdet
exact hMdet
exact ⟨detD, hdiag _ detD⟩
assume t
{ assume t, exact ⟨by simp, htransvec t⟩ }
exact ⟨by simp, htransvec t⟩
assume A B QA QB
{ assume A B QA QB, exact ⟨by simp [QA.1, QB.1], hmul A B QA.1 QB.1 QA.2 QB.2⟩ }
exact ⟨by simp [QA.1, QB.1], hmul A B QA.1 QB.1 QA.2 QB.2⟩
exact this.2
intros
ext
ext; refl
refl
intros
ext
ext; simp only [prod.mk_add_mk, add_zero, id_apply, coprod_apply, inl_apply, inr_apply, zero_add]
simp only [prod.mk_add_mk, add_zero, id_apply, coprod_apply, inl_apply, inr_apply, zero_add]
simp only [prod.mk_add_mk, add_zero, id_apply, coprod_apply, inl_apply, inr_apply, zero_add]
intros
tidy
intros
ext x
simp only [comp_apply, mem_ker, subtype_apply, sub_apply, id_apply, sub_eq_zero]
exact ⟨λ h, h.symm ▸ submodule.coe_mem _, λ hx, by erw [hf ⟨x, hx⟩, subtype.coe_mk]⟩
intros
ext b
ext b; simp [std_basis_ne R φ _ _ h]
simp [std_basis_ne R φ _ _ h]
intros
rw [← lift_mk_compr₂ g, H, lift_mk_compr₂]
intros
simp only [← coe_rtensor_hom, map_neg]
intros
by_cases h : P; simp [h]
{ by_cases h : P; simp [h] }
by_cases h : P
simp [h]
simp [h]
intros
subst eq; exact h
subst eq
exact h
intros
rw [← iterate_succ', nat.succ_pred_eq_of_pos hn]
intros
simp_rw [nnreal.tsum_eq_to_nnreal_tsum]
exact (measurable.ennreal_tsum (λ i, (h i).coe_nnreal_ennreal)).ennreal_to_nnreal
intros
apply measurable_of_Ioi
simp_rw [← compl_Iic, preimage_compl, measurable_set.compl_iff]
assumption
intros
obtain ⟨t, hst, mt, ht⟩ := exists_measurable_superset_of_null h
simp_rw [measure_prod_null mt] at ht
rw [eventually_le_antisymm_iff]
exact ⟨eventually_le.trans_eq (eventually_of_forall $ λ x, (measure_mono (preimage_mono hst) : _)) ht, eventually_of_forall $ λ x, zero_le _⟩
intros
rw ← prod_swap at hf
rw [← integral_map measurable_swap hf, prod_swap]
intros
simp [total_variation, to_jordan_decomposition_neg, add_comm]
intros
refine ae_eq_zero_of_forall_dual ℝ (λ c, _)
refine ae_eq_zero_restrict_of_forall_set_integral_eq_zero_real _ _ ht hμt
assume s hs hμs
{ assume s hs hμs, exact continuous_linear_map.integrable_comp c (hf_int_finite s hs hμs) }
exact continuous_linear_map.integrable_comp c (hf_int_finite s hs hμs)
assume s hs hμs
{ assume s hs hμs, rw [continuous_linear_map.integral_comp_comm c (hf_int_finite s hs hμs), hf_zero s hs hμs], exact continuous_linear_map.map_zero _ }
rw [continuous_linear_map.integral_comp_comm c (hf_int_finite s hs hμs), hf_zero s hs hμs]
exact continuous_linear_map.map_zero _
intros
ext1
have hμst := ((measure_union_le s t).trans_lt (lt_top_iff_ne_top.mpr (ennreal.add_ne_top.mpr ⟨hμs, hμt⟩))).ne
refine (condexp_ind_L1_fin_ae_eq_condexp_ind_smul hm (hs.union ht) hμst x).trans _
refine eventually_eq.trans _ (Lp.coe_fn_add _ _).symm
have hs_eq := condexp_ind_L1_fin_ae_eq_condexp_ind_smul hm hs hμs x
have ht_eq := condexp_ind_L1_fin_ae_eq_condexp_ind_smul hm ht hμt x
refine eventually_eq.trans _ (eventually_eq.add hs_eq.symm ht_eq.symm)
rw condexp_ind_smul
rw indicator_const_Lp_disjoint_union hs ht hμs hμt hst (1 : ℝ)
rw (condexp_L2 ℝ hm).map_add
push_cast
rw ((to_span_singleton ℝ x).comp_LpL 2 μ).map_add
refine (Lp.coe_fn_add _ _).trans _
refine eventually_of_forall (λ y, _)
refl
intros
refine is_finite_measure_with_density ((lintegral_mono $ λ x, _).trans_lt hfi).ne
exact real.of_real_le_ennnorm (f x)
intros
refine ⟨measurable.ae_measurable hf, _⟩
rw [has_finite_integral, lintegral_trim hm _]
{ exact hf_int.2, }
exact hf_int.2
exact @measurable.coe_nnreal_ennreal α m _ (@measurable.nnnorm _ α _ _ _ m _ hf)
{ exact @measurable.coe_nnreal_ennreal α m _ (@measurable.nnnorm _ α _ _ _ m _ hf), }
intros
simp [snorm]
intros
refine (at_top_basis.tendsto_iff nhds_basis_eball).2 (λ ε hε, _)
rcases emetric.mem_closure_iff.1 hx ε hε with ⟨_, ⟨N, rfl⟩, hN⟩
rw [edist_comm] at hN
exact ⟨N, trivial, λ n hn, (edist_nearest_pt_le e x hn).trans_lt hN⟩
intros
simpa only [← pi.list_prod_apply] using l.ae_measurable_prod' hl
intros
by_cases hc : c = 0; simp [hc]
by_cases hc : c = 0
simp [hc]
simp [hc]
intros
rw [set_lintegral_const, one_mul]
intros
simp_rw [mul_comm, lintegral_const_mul_le r f]
intros
rw [set.union_eq_Union, lintegral_Union, tsum_bool, add_comm]
simp only [to_bool_false_eq_ff, to_bool_true_eq_tt, cond]
{ simp only [to_bool_false_eq_ff, to_bool_true_eq_tt, cond] }
{ intros i, exact measurable_set.cond hA hB }
intros i
exact measurable_set.cond hA hB
{ rwa pairwise_disjoint_on_bool }
rwa pairwise_disjoint_on_bool
intros
rw [const_lintegral, measure.restrict_apply measurable_set.univ, univ_inter]
intros
simp_rw fun_mul_inv_snorm_rpow hp0_lt
rw [lintegral_mul_const'' _ (hf.pow_const p), mul_inv_cancel hf_nonzero hf_top]
intros
assume s hs
convert measurable_set.empty
exact eq_empty_of_is_empty _
intros
rwa ← h
intros
have := chaar_mem_haar_product K₀ K (mem_univ _)
{ have := chaar_mem_haar_product K₀ K (mem_univ _), rw mem_Icc at this, exact this.1 }
rw mem_Icc at this
exact this.1
intros
haveI : ∀ n, encodable (ι n)
from λ n, fintype.encodable _
simpa only [tsum_fintype] using mk_metric_le_liminf_tsum s r hr t ht hst m
intros
rw [measure_eq_extend (measurable_set.Union h), extend_Union measurable_set.empty _ measurable_set.Union _ hn h]
{ simp [measure_eq_extend, h] }
simp [measure_eq_extend, h]
{ exact μ.empty }
exact μ.empty
{ exact μ.m_Union }
exact μ.m_Union
intros
by_cases h : measurable f
change range f ∈ (map f μ).ae
{ change range f ∈ (map f μ).ae, rw mem_ae_map_iff h hf, apply eventually_of_forall, exact mem_range_self }
rw mem_ae_map_iff h hf
apply eventually_of_forall
exact mem_range_self
{ simp [map_of_not_measurable h] }
simp [map_of_not_measurable h]
intros
have := ennreal.lt_add_right hs hε
conv at this {to_lhs, rw induced_outer_measure_eq_infi _ msU m_mono }
simp only [infi_lt_iff] at this
rcases this with ⟨t, h1t, h2t, h3t⟩
exact ⟨t, h1t, h2t, le_trans (le_of_eq $ induced_outer_measure_eq' _ msU m_mono h1t) (le_of_lt h3t)⟩
intros
simp only [smul_apply, dirac_apply, ← indicator_mul_right _ (λ _, a), mul_one]
intros
simp [is_caratheodory, m.empty, diff_empty]
intros
apply ge_of_tendsto (f.tendsto_left_lim y)
apply mem_nhds_within_Iio_iff_exists_Ioo_subset.2 ⟨x, h, _⟩
assume z hz
exact f.mono hz.1.le
intros
intros j hj₁
rw [restrict_apply _ hi hj₁, restrict_apply _ hi hj₁, neg_apply, neg_apply]
refine neg_le_neg _
rw [← restrict_apply _ hi hj₁, ← restrict_apply _ hi hj₁]
exact h j hj₁
intros
refine ⟨_, generate_has.compl⟩
{ refine ⟨_, generate_has.compl⟩, intro h, convert generate_has.compl h, simp }
intro h
convert generate_has.compl h
simp
intros
refine nnreal.summable_of_le (assume a, _) p.summable_coe
suffices : p a * f a b ≤ p a * 1
simpa
{ simpa }
exact mul_le_mul_of_nonneg_left ((f a).coe_le_one _) (p a).2
intros
cases n
{ simp }
simp
rw [divisors_eq_proper_divisors_insert_self_of_pos (nat.succ_pos _)]
apply subset_insert
intros
rw [sq, sq]
exact (is_coprime.mul_left h2 h2).mul_add_left_left r
intros
{ ext; { dsimp, ring }, }
ext
ext; { dsimp, ring }
{ dsimp, ring }
dsimp
{ dsimp, ring }
ring
intros
by_cases b_split : (b = 0)
{ simp [b_split], }
simp [b_split]
have split_frac : padic_val_rat p (b / p) = padic_val_rat p b - padic_val_rat p p := padic_val_rat.div p (nat.cast_ne_zero.mpr b_split) (nat.cast_ne_zero.mpr (nat.prime.ne_zero p_prime.1))
{ have split_frac : padic_val_rat p (b / p) = padic_val_rat p b - padic_val_rat p p := padic_val_rat.div p (nat.cast_ne_zero.mpr b_split) (nat.cast_ne_zero.mpr (nat.prime.ne_zero p_prime.1)), rw padic_val_rat.padic_val_rat_self (nat.prime.one_lt p_prime.1) at split_frac, have r : 1 ≤ padic_val_nat p b := one_le_padic_val_nat_of_dvd b_split dvd, exact_mod_cast split_frac, }
rw padic_val_rat.padic_val_rat_self (nat.prime.one_lt p_prime.1) at split_frac
have r : 1 ≤ padic_val_nat p b := one_le_padic_val_nat_of_dvd b_split dvd
exact_mod_cast split_frac
intros
simp [cast_eq_of_rat]
intros
obtain ⟨l, m, n, ⟨⟨rfl, rfl⟩ | ⟨rfl, rfl⟩, co⟩⟩ := hc
use [k * l, m, n]
{ use [k * l, m, n], apply and.intro _ co, left, split; ring }
apply and.intro _ co
left
split
split; ring
ring
ring
use [k * l, m, n]
{ use [k * l, m, n], apply and.intro _ co, right, split; ring }
apply and.intro _ co
right
split
split; ring
ring
ring
intros
refine ⟨λ ha, ext.mpr _, λ h, by rw [h, norm_zero]⟩
delta norm at ha
rw sub_eq_zero at ha
by_cases h : 0 ≤ d
obtain ⟨d', rfl⟩ := int.eq_coe_of_zero_le h
{ obtain ⟨d', rfl⟩ := int.eq_coe_of_zero_le h, haveI : nonsquare d' := ⟨λ n h, h_nonsquare n $ by exact_mod_cast h⟩, exact divides_sq_eq_zero_z ha, }
haveI : nonsquare d' := ⟨λ n h, h_nonsquare n $ by exact_mod_cast h⟩
exact divides_sq_eq_zero_z ha
push_neg at h
{ push_neg at h, suffices : a.re * a.re = 0, { rw eq_zero_of_mul_self_eq_zero this at ha ⊢, simpa only [true_and, or_self_right, zero_re, zero_im, eq_self_iff_true, zero_eq_mul, mul_zero, mul_eq_zero, h.ne, false_or, or_self] using ha }, apply _root_.le_antisymm _ (mul_self_nonneg _), rw [ha, mul_assoc], exact mul_nonpos_of_nonpos_of_nonneg h.le (mul_self_nonneg _) }
suffices : a.re * a.re = 0
rw eq_zero_of_mul_self_eq_zero this at ha ⊢
{ rw eq_zero_of_mul_self_eq_zero this at ha ⊢, simpa only [true_and, or_self_right, zero_re, zero_im, eq_self_iff_true, zero_eq_mul, mul_zero, mul_eq_zero, h.ne, false_or, or_self] using ha }
simpa only [true_and, or_self_right, zero_re, zero_im, eq_self_iff_true, zero_eq_mul, mul_zero, mul_eq_zero, h.ne, false_or, or_self] using ha
apply _root_.le_antisymm _ (mul_self_nonneg _)
rw [ha, mul_assoc]
exact mul_nonpos_of_nonpos_of_nonneg h.le (mul_self_nonneg _)
intros
rw [is_lub_preimage, f.apply_symm_apply]
intros
simpa only [disjoint.comm] using @supr_disjoint_iff _ _ _ a f
intros
simp
intros
{ contrapose! h, exact cSup_le' h }
contrapose! h
exact cSup_le' h
intros
have : ∀ᶠ x in at_top, a ≤ x ∧ b ≤ u x := (eventually_ge_at_top a).and (h.eventually $ eventually_ge_at_top b)
haveI : nonempty α := ⟨a⟩
rcases this.exists with ⟨a', ha, hb⟩
exact ⟨a', ha, hb⟩
intros
{ rw ← prod_at_top_at_top_eq, exact hf.prod_map hg, }
rw ← prod_at_top_at_top_eq
exact hf.prod_map hg
intros
rw [inter_comm, inter_eventually_eq_left]
intros
simp only [filter_eq_bot_of_is_empty la, tendsto_bot]
intros
simp only [le_principal_iff, iff_self, mem_principal]
intros
simpa using infi_principal_finset finset.univ f
intros
simpa only [sub_eq_add_neg] using hf.add hg.neg
intros
rw [prod_def, lift_lift'_assoc]
apply congr_arg
funext x
rw [lift'_lift'_assoc]
exact hg₂
exact set.monotone_prod monotone_const monotone_id
exact hg₁
exact (monotone_lift' monotone_const $ monotone_lam $ assume x, set.monotone_prod monotone_id monotone_const)
intros
cases n
{ cases n, exacts [h₀, hf.seq_pos_lt_seq_of_lt_of_le n.zero_lt_succ h₀.le hx hy] }
exacts [h₀, hf.seq_pos_lt_seq_of_lt_of_le n.zero_lt_succ h₀.le hx hy]
intros
refine le_antisymm (g.to_galois_connection.l_limsup_le hgu hu_co) _
rw [←(g.symm.symm_apply_apply (f.limsup (λ (x : α), g (u x)))), g.symm_symm]
refine g.monotone _
have hf : u = λ i, g.symm (g (u i))
from funext (λ i, (g.symm_apply_apply (u i)).symm)
nth_rewrite 0 hf
refine g.symm.to_galois_connection.l_limsup_le _ hgu_co
simp_rw g.symm_apply_apply
exact hu
intros
exactI {..f.is_partial_order, ..f.is_total}
intros
rw [well_founded_on_iff, rel_embedding.well_founded_iff_no_descending_seq]
refine ⟨λ h f con, begin refine h.elim' ⟨⟨f, f.injective⟩, λ a b, _⟩, simp only [con (mem_range_self a), con (mem_range_self b), and_true, gt_iff_lt, function.embedding.coe_fn_mk, f.map_rel_iff] end, λ h, ⟨λ con, _⟩⟩
rcases con with ⟨f, hf⟩
have hfs' : ∀ n : ℕ, f n ∈ s := λ n, (hf.2 n.lt_succ_self).2.2
refine h ⟨f, λ a b, _⟩ (λ n hn, _)
rw ← hf
{ rw ← hf, exact ⟨λ h, ⟨h, hfs' _, hfs' _⟩, λ h, h.1⟩ }
exact ⟨λ h, ⟨h, hfs' _, hfs' _⟩, λ h, h.1⟩
rcases set.mem_range.1 hn with ⟨m, hm⟩
{ rcases set.mem_range.1 hn with ⟨m, hm⟩, rw ← hm, apply hfs' }
rw ← hm
apply hfs'
intros
rw [adjoin_eq_span, span_le]
intros
haveI := subsingleton_of_zero_eq_one h01; haveI := fintype.of_subsingleton (0:R); split; apply_instance
haveI := subsingleton_of_zero_eq_one h01; haveI := fintype.of_subsingleton (0:R); split
haveI := subsingleton_of_zero_eq_one h01; haveI := fintype.of_subsingleton (0:R)
haveI := subsingleton_of_zero_eq_one h01
haveI := fintype.of_subsingleton (0:R)
split
intros
{ rw add_comm at h, exact h.of_add_mul_right_left }
rw add_comm at h
exact h.of_add_mul_right_left
intros
suffices : of' R M '' (⋃ f ∈ S, (f.support : set M)) = ⋃ f ∈ S, (of' R M '' (f.support : set M))
rw this
{ rw this, exact support_gen_of_gen hS }
exact support_gen_of_gen hS
simp only [set.image_Union]
intros
intros g hg
contrapose! hg
rw [mem_support, emb_domain_notin_image_support hg, not_not]
intros
rw [lt_iff_le_not_le, span_singleton_le_span_singleton, span_singleton_le_span_singleton, dvd_and_not_dvd_iff]
intros
cases nat.exists_eq_add_of_le h with k hk
rw [hk, pow_add]
exact le_trans (mul_le_inf) (inf_le_left)
intros
split
rw ideal_prod_eq I
{ rw ideal_prod_eq I, introsI hI, rcases ideal_prod_prime_aux hI with (h|h), { right, rw h at hI ⊢, exact ⟨_, ⟨is_prime_of_is_prime_prod_top' hI, rfl⟩⟩ }, { left, rw h at hI ⊢, exact ⟨_, ⟨is_prime_of_is_prime_prod_top hI, rfl⟩⟩ } }
introsI hI
rcases ideal_prod_prime_aux hI with (h|h)
right
{ right, rw h at hI ⊢, exact ⟨_, ⟨is_prime_of_is_prime_prod_top' hI, rfl⟩⟩ }
rw h at hI ⊢
exact ⟨_, ⟨is_prime_of_is_prime_prod_top' hI, rfl⟩⟩
left
{ left, rw h at hI ⊢, exact ⟨_, ⟨is_prime_of_is_prime_prod_top hI, rfl⟩⟩ }
rw h at hI ⊢
exact ⟨_, ⟨is_prime_of_is_prime_prod_top hI, rfl⟩⟩
rintro (⟨p, ⟨h, rfl⟩⟩|⟨p, ⟨h, rfl⟩⟩)
{ rintro (⟨p, ⟨h, rfl⟩⟩|⟨p, ⟨h, rfl⟩⟩), { exactI is_prime_ideal_prod_top }, { exactI is_prime_ideal_prod_top' } }
{ exactI is_prime_ideal_prod_top }
exactI is_prime_ideal_prod_top
{ exactI is_prime_ideal_prod_top' }
exactI is_prime_ideal_prod_top'
intros
generalize hS : (↑(p.map $ algebra_map A B).frange : set B) = S
have coeffs_mem : ∀ i, (p.map $ algebra_map A B).coeff i ∈ adjoin R S
intro i
{ intro i, by_cases hi : (p.map $ algebra_map A B).coeff i = 0, { rw hi, exact subalgebra.zero_mem _ }, rw ← hS, exact subset_adjoin (coeff_mem_frange _ _ hi) }
by_cases hi : (p.map $ algebra_map A B).coeff i = 0
{ rw hi, exact subalgebra.zero_mem _ }
rw hi
exact subalgebra.zero_mem _
rw ← hS
exact subset_adjoin (coeff_mem_frange _ _ hi)
obtain ⟨q, hq⟩ : ∃ q : polynomial (adjoin R S), q.map (algebra_map (adjoin R S) B) = (p.map $ algebra_map A B)
rw ← set.mem_range
{ rw ← set.mem_range, exact (polynomial.mem_map_range _).2 (λ i, ⟨⟨_, coeffs_mem i⟩, rfl⟩) }
exact (polynomial.mem_map_range _).2 (λ i, ⟨⟨_, coeffs_mem i⟩, rfl⟩)
use q
split
suffices h : (q.map (algebra_map (adjoin R S) B)).monic
{ suffices h : (q.map (algebra_map (adjoin R S) B)).monic, { refine monic_of_injective _ h, exact subtype.val_injective }, { rw hq, exact monic_map _ pmonic } }
refine monic_of_injective _ h
{ refine monic_of_injective _ h, exact subtype.val_injective }
exact subtype.val_injective
{ rw hq, exact monic_map _ pmonic }
rw hq
exact monic_map _ pmonic
convert hp using 1
{ convert hp using 1, replace hq := congr_arg (eval x) hq, convert hq using 1; symmetry; apply eval_map }
replace hq := congr_arg (eval x) hq
convert hq using 1; symmetry; apply eval_map
convert hq using 1; symmetry
convert hq using 1
symmetry
apply eval_map
symmetry
apply eval_map
intros
apply le_antisymm
apply enat.le_of_lt_add_one
{ apply enat.le_of_lt_add_one, cases enat.ne_top_iff.mp (enat.ne_top_of_lt h) with k hk, rw [hk], rw_mod_cast [multiplicity_lt_iff_neg_dvd], intro h_dvd, rw [← dvd_add_iff_right] at h_dvd, apply multiplicity.is_greatest _ h_dvd, rw [hk], apply_mod_cast nat.lt_succ_self, rw [pow_dvd_iff_le_multiplicity, nat.cast_add, ← hk, nat.cast_one], exact enat.add_one_le_of_lt h }
cases enat.ne_top_iff.mp (enat.ne_top_of_lt h) with k hk
rw [hk]
rw_mod_cast [multiplicity_lt_iff_neg_dvd]
intro h_dvd
rw [← dvd_add_iff_right] at h_dvd
apply multiplicity.is_greatest _ h_dvd
rw [hk]
apply_mod_cast nat.lt_succ_self
rw [pow_dvd_iff_le_multiplicity, nat.cast_add, ← hk, nat.cast_one]
exact enat.add_one_le_of_lt h
convert min_le_multiplicity_add
{ convert min_le_multiplicity_add, rw [min_eq_right (le_of_lt h)] }
rw [min_eq_right (le_of_lt h)]
intros
obtain ⟨n, hn⟩ := h
use n
rw [h_comm.mul_pow, hn, zero_mul]
intros
simp [nat_degree]
intros
obtain ⟨n, rfl⟩ := nat.exists_eq_add_of_le h
rw add_comm
exact T_add_two R n
intros
{ rw cyclotomic', exact roots_prod_X_sub_C (primitive_roots n R) }
rw cyclotomic'
exact roots_prod_X_sub_C (primitive_roots n R)
intros
rw [homogeneous_component_apply, sum_eq_zero]
intros d hd
rw mem_filter at hd
exfalso
exact h _ hd.1 hd.2
intros
intro h
have : p.coeff p.nat_degree ≠ 0 := mt leading_coeff_eq_zero.mp hp
have : (scale_roots p s).coeff p.nat_degree = 0 := congr_fun (congr_arg (coeff : polynomial R → ℕ → R) h) p.nat_degree
rw [coeff_scale_roots_nat_degree] at this
contradiction
intros
ext m i j
simp only [coeff_map, one_apply, algebra_map_matrix_apply, mul_boole, pi.smul_apply, mat_poly_equiv_coeff_apply]
split_ifs; simp
split_ifs
simp
simp
intros
simp
intros
simpa using coeff_add_mul_monomial n 0 φ a
intros
induction k with k h
simp only [rescale_zero, constant_coeff_exp, function.comp_app, map_one, cast_zero, pow_zero, coe_comp]
{ simp only [rescale_zero, constant_coeff_exp, function.comp_app, map_one, cast_zero, pow_zero, coe_comp], }
simpa only [succ_eq_add_one, cast_add, ←exp_mul_exp_eq_exp_add (k : A), ←h, cast_one, id_apply, rescale_one] using pow_succ' (exp A) k
intros
rw [primitive_roots, mem_filter, multiset.mem_to_finset, mem_nth_roots h0, and_iff_right_iff_imp]
exact is_primitive_root.pow_eq_one
intros
ext1 n
apply mv_polynomial.map_injective (int.cast_ring_hom ℚ) int.cast_injective
rw ← function.funext_iff at h
replace h := congr_arg (λ fam, bind₁ (mv_polynomial.map (int.cast_ring_hom ℚ) ∘ fam) (X_in_terms_of_W p ℚ n)) h
simpa only [function.comp, map_bind₁, map_witt_polynomial, ← bind₁_bind₁, bind₁_witt_polynomial_X_in_terms_of_W, bind₁_X_right] using h
intros
{ rw [add_comm, add_eq_left hb ha] }
rw [add_comm, add_eq_left hb ha]
intros
simp only [quot_mul_comm, quot_left_distrib]
intros
simp only [Inf, conditionally_complete_lattice.Inf, omin, conditionally_complete_linear_order.Inf, conditionally_complete_linear_order_bot.Inf, hs, dif_pos]
congr
rw subtype.range_val
intros
induction n; [refl, simp only [card_add, card_one, nat.cast_succ, *]]
induction n
refl
simp only [card_add, card_one, nat.cast_succ, *]
intros
rw [lift_card, ←type_subrel_lt, card_type]
intros
cases o
cases o; refl
refl
refl
intros
rw [le_def_lt]
conv { to_lhs, simp only [lt_def_le] }
intros
rw [←h3, mul_assoc, mul_div_comm, h2, ←mul_assoc, h1, mul_comm, one_mul]
intros
simpa [eq.symm h1, eq.symm h2, int.coe_nat_le]
intros
rwa h₁
intros
{ ext, simp }
ext
simp
intros
simpa only [set.indicator_range_comp] using (hi.summable_iff _).2 (hf.indicator (set.range i))
exact λ x hx, set.indicator_of_not_mem hx _
intros
rw [tsum_fintype, finset.sum_eq_add]; simp
{ rw [tsum_fintype, finset.sum_eq_add]; simp }
rw [tsum_fintype, finset.sum_eq_add]
simp
simp
simp
simp
intros
{ intros f g H, cases f, cases g, congr' }
intros f g H
cases f
cases g
congr'
intros
rcases exists_open_nhds_one_split hU with ⟨V, Vo, V1, hV⟩
use [V, Vo, V1]
rintros _ ⟨x, y, hx, hy, rfl⟩
exact hV _ hx _ hy
intros
simp only [div_eq_mul_inv]
{ simp only [div_eq_mul_inv], exact mul_zero a ▸ h.mul (tendsto_inv_at_top_zero.comp hg) }
exact mul_zero a ▸ h.mul (tendsto_inv_at_top_zero.comp hg)
intros
simp [nhds_eq_order (⊤:α)]
intros
{ rw [dense_range, range_comp], exact hg.dense_image cg hf }
rw [dense_range, range_comp]
exact hg.dense_image cg hf
intros
rw [hs.frontier_eq, inter_diff_self]
intros
simp_rw [mem_closure_iff_nhds, comap_ne_bot_iff, set.nonempty_inter_iff_exists_right]
intros
ext
rw mem_closure_iff_ultrafilter
split
rintro ⟨F, h1, h2⟩
{ rintro ⟨F, h1, h2⟩, exact ⟨F, h1, le_nhds_of_str_eq _ _ h2⟩ }
exact ⟨F, h1, le_nhds_of_str_eq _ _ h2⟩
rintro ⟨F, h1, h2⟩
{ rintro ⟨F, h1, h2⟩, exact ⟨F, h1, str_eq_of_le_nhds _ _ h2⟩ }
exact ⟨F, h1, str_eq_of_le_nhds _ _ h2⟩
intros
simp
intros
rw algebra.eq_top_iff
let I : C(X, ℝ) →ₗ[ℝ] C(X, ℂ) := of_real_clm.comp_left_continuous ℝ X
have key : I.range ≤ (A.to_submodule.restrict_scalars ℝ).topological_closure
let A₀ : submodule ℝ C(X, ℝ) := (A.to_submodule.restrict_scalars ℝ).comap I
{ let A₀ : submodule ℝ C(X, ℝ) := (A.to_submodule.restrict_scalars ℝ).comap I, have SW : A₀.topological_closure = ⊤, { have := subalgebra_topological_closure_eq_top_of_separates_points _ (hA.complex_to_real hA'), exact congr_arg subalgebra.to_submodule this }, rw [← submodule.map_top, ← SW], have h₁ := A₀.topological_closure_map (of_real_clm.comp_left_continuous_compact X), have h₂ := (A.to_submodule.restrict_scalars ℝ).map_comap_le I, exact h₁.trans (submodule.topological_closure_mono h₂) }
have SW : A₀.topological_closure = ⊤
have := subalgebra_topological_closure_eq_top_of_separates_points _ (hA.complex_to_real hA')
{ have := subalgebra_topological_closure_eq_top_of_separates_points _ (hA.complex_to_real hA'), exact congr_arg subalgebra.to_submodule this }
exact congr_arg subalgebra.to_submodule this
rw [← submodule.map_top, ← SW]
have h₁ := A₀.topological_closure_map (of_real_clm.comp_left_continuous_compact X)
have h₂ := (A.to_submodule.restrict_scalars ℝ).map_comap_le I
exact h₁.trans (submodule.topological_closure_mono h₂)
intros f
let f_re : C(X, ℝ) := (⟨complex.re, complex.re_clm.continuous⟩ : C(ℂ, ℝ)).comp f
let f_im : C(X, ℝ) := (⟨complex.im, complex.im_clm.continuous⟩ : C(ℂ, ℝ)).comp f
have h_f_re : I f_re ∈ A.topological_closure := key ⟨f_re, rfl⟩
have h_f_im : I f_im ∈ A.topological_closure := key ⟨f_im, rfl⟩
convert A.topological_closure.add_mem h_f_re (A.topological_closure.smul_mem h_f_im complex.I)
ext
ext; simp [I]
simp [I]
simp [I]
intros
simpa [nhds_within] using nhds_within_pi_eq finite_univ s x
intros
rw [← image_univ]
exact (hf.restrict is_open_univ).continuous_on_image_of_left_inv_on (λ x _, hleft x)
intros
rw [e.source_eq, mem_preimage]
intros
{ erw [mem_prod], simp only [and_true, mem_univ] }
erw [mem_prod]
simp only [and_true, mem_univ]
intros
rw ←nat.cofinite_eq_at_top
{ rw ←nat.cofinite_eq_at_top, exact tendsto_cofinite_zero_of_tsum_ne_top hf }
exact tendsto_cofinite_zero_of_tsum_ne_top hf
intros
cases e; cases e'; refl
cases e; cases e'
cases e
cases e'
refl
intros
simp only [set.ext_iff, mem_singleton_iff, mem_preimage] at h
ext1 x
have := h x
set a := f x
set b := g x
fin_cases a; fin_cases b; finish
fin_cases a; fin_cases b
fin_cases a
fin_cases b
finish
finish
fin_cases b
finish
finish
intros
rw [edist_nndist, ennreal.coe_le_coe]
intros
rw [← nhds_within_univ b, tendsto_nhds_within_nhds_within]
{ rw [← nhds_within_univ b, tendsto_nhds_within_nhds_within], simp only [mem_univ, true_and] }
simp only [mem_univ, true_and]
intros
refine continuous_of_le_add_edist 2 (by simp) _
rintros ⟨x, s⟩ ⟨y, t⟩
calc inf_edist x (s.val) ≤ inf_edist x (t.val) + Hausdorff_edist (t.val) (s.val) : inf_edist_le_inf_edist_add_Hausdorff_edist ... ≤ (inf_edist y (t.val) + edist x y) + Hausdorff_edist (t.val) (s.val) : add_le_add_right inf_edist_le_inf_edist_add_edist _ ... = inf_edist y (t.val) + (edist x y + Hausdorff_edist (s.val) (t.val)) : by simp [add_comm, add_left_comm, Hausdorff_edist_comm, -subtype.val_eq_coe] ... ≤ inf_edist y (t.val) + (edist (x, s) (y, t) + edist (x, s) (y, t)) : add_le_add_left (add_le_add (le_max_left _ _) (le_max_right _ _)) _ ... = inf_edist y (t.val) + 2 * edist (x, s) (y, t) : by rw [← mul_two, mul_comm]
intros
refine ⟨λ H ε hε, H _ (edist_mem_uniformity hε), λ H u hu, _⟩
rcases mem_uniformity_edist.1 hu with ⟨ε, εpos, hε⟩
exact (H ε εpos).mono (λ n hs x hx, hε (hs x hx))
intros
refine Hausdorff_edist_le_of_inf_edist _ _
assume x xs
{ assume x xs, rcases H1 x xs with ⟨y, yt, hy⟩, exact le_trans (inf_edist_le_edist_of_mem yt) hy }
rcases H1 x xs with ⟨y, yt, hy⟩
exact le_trans (inf_edist_le_edist_of_mem yt) hy
assume x xt
{ assume x xt, rcases H2 x xt with ⟨y, ys, hy⟩, exact le_trans (inf_edist_le_edist_of_mem ys) hy }
rcases H2 x xt with ⟨y, ys, hy⟩
exact le_trans (inf_edist_le_edist_of_mem ys) hy
intros
apply Hausdorff_dist_le_of_inf_dist hr
assume x xs
{ assume x xs, rcases H1 x xs with ⟨y, yt, hy⟩, exact le_trans (inf_dist_le_dist_of_mem yt) hy }
rcases H1 x xs with ⟨y, yt, hy⟩
exact le_trans (inf_dist_le_dist_of_mem yt) hy
assume x xt
{ assume x xt, rcases H2 x xt with ⟨y, ys, hy⟩, exact le_trans (inf_dist_le_dist_of_mem ys) hy }
rcases H2 x xt with ⟨y, ys, hy⟩
exact le_trans (inf_dist_le_dist_of_mem ys) hy
intros
rw continuous_def at h₂ ⊢
assume s h
exact h₁ _ (h₂ s h)
intros
{ ext, refl }
ext
refl
intros
rcases h.exists_path_through_family p hp with ⟨γ, hγ⟩
rcases hγ with ⟨h₁, h₂⟩
simp only [range, mem_set_of_eq] at h₂
rw range_subset_iff at h₁
choose! t ht using h₂
exact ⟨γ, t, h₁, ht⟩
intros
refine ⟨assume s t hs ht st, _⟩
simp only [disjoint_iff]
exact compact_compact_separated hs.is_compact ht.is_compact st.eq_bot
intros
{ rw [nhds_eq_comap_uniformity], exact h.comap (prod.mk x) }
rw [nhds_eq_comap_uniformity]
exact h.comap (prod.mk x)
intros
simpa only [cauchy_seq_iff_tendsto]
intros
split
split ; rintro ⟨c⟩
rintro ⟨c⟩
have := eq_univ_iff_forall.1 dense_embedding_pure_cauchy.to_dense_inducing.closure_range c
{ have := eq_univ_iff_forall.1 dense_embedding_pure_cauchy.to_dense_inducing.closure_range c, obtain ⟨_, ⟨_, a, _⟩⟩ := mem_closure_iff.1 this _ is_open_univ trivial, exact ⟨a⟩ }
obtain ⟨_, ⟨_, a, _⟩⟩ := mem_closure_iff.1 this _ is_open_univ trivial
exact ⟨a⟩
rintro ⟨c⟩
{ exact ⟨pure_cauchy c⟩ }
exact ⟨pure_cauchy c⟩
intros
induction n with n ihn generalizing c
exact indicator_apply_le' (λ _, le_rfl) (λ _, zero_le_one)
{ exact indicator_apply_le' (λ _, le_rfl) (λ _, zero_le_one) }
simp only [approx, midpoint_eq_smul_add, inv_of_eq_inv, smul_eq_mul, ← div_eq_inv_mul]
{ simp only [approx, midpoint_eq_smul_add, inv_of_eq_inv, smul_eq_mul, ← div_eq_inv_mul], refine iff.mpr (div_le_one zero_lt_two) (add_le_add _ _); apply ihn }
refine iff.mpr (div_le_one zero_lt_two) (add_le_add _ _)
refine iff.mpr (div_le_one zero_lt_two) (add_le_add _ _); apply ihn
apply ihn
apply ihn
intros
cases b; simp
cases b
simp
simp
intros
rw [← int.neg_neg a, ← int.neg_neg b, h]
intros
rw [int.add_assoc, int.add_left_neg, int.add_zero]
intros
have h := int.neg_le_neg h
rwa int.neg_neg at h
intros
have h := int.add_lt_add_right h (-b)
rwa int.add_neg_cancel_right at h
intros
rw [nat.mul_comm, mul_mod_right]
intros
by_cases p; simp [h]
by_cases p
simp [h]
simp [h]
intros
simp
intros
{ ext, refl }
ext
refl
intros
haveI : subsingleton (B ≃ₐ[R] A) := alg_equiv.subsingleton_left
exact ⟨λ f g, eq.trans (alg_equiv.symm_symm _).symm (by rw [subsingleton.elim f.symm g.symm, alg_equiv.symm_symm])⟩
intros
rw [prime, _root_.prime, forall_associated]
transitivity
apply and_congr
{ apply and_congr, refl, apply and_congr, refl, apply forall_congr, assume a, exact forall_associated }
refl
apply and_congr
refl
apply forall_congr
assume a
exact forall_associated
apply and_congr
{ rw [(≠), mk_eq_zero] }
rw [(≠), mk_eq_zero]
apply and_congr
{ rw [is_unit_mk], }
rw [is_unit_mk]
apply forall_congr
assume a
apply forall_congr
assume b
rw [mk_mul_mk, mk_dvd_mk, mk_dvd_mk, mk_dvd_mk]
intros
rw [range_zero, prod_empty]
intros
rw [← mem_mul_support, finprod_eq_mul_indicator_apply, mul_indicator_mul_support]
intros
rw [← finprod_mem_range, subtype.range_coe]
exact subtype.coe_injective
intros
{ rw prod_sub_ordered, simp }
rw prod_sub_ordered
simp
intros
rw [← neg_sub, sub_half]
intros
cases stream_nth_eq : (int_fract_pair.stream v n) with ifp
simp [stream_nth_eq, int_fract_pair.stream]
case option.none : { simp [stream_nth_eq, int_fract_pair.stream] }
case option.some : { cases ifp with _ fr, cases decidable.em (fr = 0); finish [int_fract_pair.stream] }
cases ifp with _ fr
cases decidable.em (fr = 0); finish [int_fract_pair.stream]
cases decidable.em (fr = 0)
finish [int_fract_pair.stream]
finish [int_fract_pair.stream]
intros
simp [convergents']
intros
rw [← div_neg_eq_neg_div]
intros
rw [gcd_comm _ a, gcd_comm _ a, gcd_eq_of_dvd_sub_right h]
intros
rw [div_eq_mul_inv, one_mul]
intros
rw [sub_eq_add_neg, add_assoc, ←sub_eq_add_neg]
intros
induction i with i hi
{ simp }
simp
{ simp [pow_succ, hi] }
simp [pow_succ, hi]
intros
rw [← divp_divp_eq_divp_mul, divp_assoc, mul_comm x, divp_assoc, mul_comm]
intros
ring
intros
induction m with m ih
{ rw [pow_zero, pow_zero], exact nat.cast_one }
rw [pow_zero, pow_zero]
exact nat.cast_one
{ rw [pow_succ', pow_succ', nat.cast_mul, ih] }
rw [pow_succ', pow_succ', nat.cast_mul, ih]
intros
{ ext, refl }
ext
refl
intros
refine ⟨⟨subobject.of_le _ _ p.ge, _⟩⟩
dsimp [image_to_kernel]
simp only [subobject.of_le_comp_of_le, subobject.of_le_refl]
simp
intros
change ite (2 = 1 + 1) (𝟙 X₂ ≫ d₁) 0 = d₁
{ change ite (2 = 1 + 1) (𝟙 X₂ ≫ d₁) 0 = d₁, rw [if_pos rfl, category.id_comp] }
rw [if_pos rfl, category.id_comp]
intros
{ ext, simp [p], }
ext
simp [p]
intros
apply le_antisymm
let s := {m : M | ∃ (x : ↥I) (n : ↥N), ⁅(x : L), (n : M)⁆ = m}
{ let s := {m : M | ∃ (x : ↥I) (n : ↥N), ⁅(x : L), (n : M)⁆ = m}, have aux : ∀ (y : L) (m' ∈ submodule.span R s), ⁅y, m'⁆ ∈ submodule.span R s, { intros y m' hm', apply submodule.span_induction hm', { rintros m'' ⟨x, n, hm''⟩, rw [← hm'', leibniz_lie], refine submodule.add_mem _ _ _; apply submodule.subset_span, { use [⟨⁅y, ↑x⁆, I.lie_mem x.property⟩, n], refl, }, { use [x, ⟨⁅y, ↑n⁆, N.lie_mem n.property⟩], refl, }, }, { simp only [lie_zero, submodule.zero_mem], }, { intros m₁ m₂ hm₁ hm₂, rw lie_add, exact submodule.add_mem _ hm₁ hm₂, }, { intros t m'' hm'', rw lie_smul, exact submodule.smul_mem _ t hm'', }, }, change _ ≤ ↑({ lie_mem := aux, ..submodule.span R s } : lie_submodule R L M), rw [coe_submodule_le_coe_submodule, lie_ideal_oper_eq_span, lie_span_le], exact submodule.subset_span, }
have aux : ∀ (y : L) (m' ∈ submodule.span R s), ⁅y, m'⁆ ∈ submodule.span R s
intros y m' hm'
{ intros y m' hm', apply submodule.span_induction hm', { rintros m'' ⟨x, n, hm''⟩, rw [← hm'', leibniz_lie], refine submodule.add_mem _ _ _; apply submodule.subset_span, { use [⟨⁅y, ↑x⁆, I.lie_mem x.property⟩, n], refl, }, { use [x, ⟨⁅y, ↑n⁆, N.lie_mem n.property⟩], refl, }, }, { simp only [lie_zero, submodule.zero_mem], }, { intros m₁ m₂ hm₁ hm₂, rw lie_add, exact submodule.add_mem _ hm₁ hm₂, }, { intros t m'' hm'', rw lie_smul, exact submodule.smul_mem _ t hm'', }, }
apply submodule.span_induction hm'
rintros m'' ⟨x, n, hm''⟩
{ rintros m'' ⟨x, n, hm''⟩, rw [← hm'', leibniz_lie], refine submodule.add_mem _ _ _; apply submodule.subset_span, { use [⟨⁅y, ↑x⁆, I.lie_mem x.property⟩, n], refl, }, { use [x, ⟨⁅y, ↑n⁆, N.lie_mem n.property⟩], refl, }, }
rw [← hm'', leibniz_lie]
refine submodule.add_mem _ _ _; apply submodule.subset_span
refine submodule.add_mem _ _ _
apply submodule.subset_span
use [⟨⁅y, ↑x⁆, I.lie_mem x.property⟩, n]
{ use [⟨⁅y, ↑x⁆, I.lie_mem x.property⟩, n], refl, }
refl
apply submodule.subset_span
use [x, ⟨⁅y, ↑n⁆, N.lie_mem n.property⟩]
{ use [x, ⟨⁅y, ↑n⁆, N.lie_mem n.property⟩], refl, }
refl
{ simp only [lie_zero, submodule.zero_mem], }
simp only [lie_zero, submodule.zero_mem]
{ intros m₁ m₂ hm₁ hm₂, rw lie_add, exact submodule.add_mem _ hm₁ hm₂, }
intros m₁ m₂ hm₁ hm₂
rw lie_add
exact submodule.add_mem _ hm₁ hm₂
{ intros t m'' hm'', rw lie_smul, exact submodule.smul_mem _ t hm'', }
intros t m'' hm''
rw lie_smul
exact submodule.smul_mem _ t hm''
change _ ≤ ↑({ lie_mem := aux, ..submodule.span R s } : lie_submodule R L M)
rw [coe_submodule_le_coe_submodule, lie_ideal_oper_eq_span, lie_span_le]
exact submodule.subset_span
rw lie_ideal_oper_eq_span
{ rw lie_ideal_oper_eq_span, apply submodule_span_le_lie_span, }
apply submodule_span_le_lie_span
intros
split
split; introsI h
introsI h
{ exact e.symm.injective.lie_algebra_is_solvable, }
exact e.symm.injective.lie_algebra_is_solvable
introsI h
{ exact e.injective.lie_algebra_is_solvable, }
exact e.injective.lie_algebra_is_solvable
intros
{ rw eq_bot_iff, exact iff.rfl, }
rw eq_bot_iff
exact iff.rfl
intros
{ rw eq_bot_iff, exact iff.rfl, }
rw eq_bot_iff
exact iff.rfl
intros
rw [← lie_subalgebra.coe_to_submodule_eq_iff, range_coe_submodule, lie_subalgebra.top_coe_submodule]
exact linear_map.range_eq_top
intros
simp
intros
rw [mul_comm, div_le_iff_of_neg hc]
intros
rw [div_le_iff_of_neg hb, one_mul]
intros
rw [← mul_div_assoc] at h
rwa [mul_comm b, ← div_le_iff hc]
intros
rw [abs_lt, neg_lt_sub_iff_lt_add', sub_lt_iff_lt_add', and_comm, sub_lt_iff_lt_add']
intros
rw [← mul_le_mul_iff_right b, one_mul, inv_mul_cancel_right]
intros
rw [le_div_iff_mul_le, mul_comm]
intros
simp [lt_top_iff_ne_top, add_eq_top, not_or_distrib]
intros
haveI := @linear_order.decidable_le α _; exact have h' : a * c ≤ b * c, from calc a * c ≤ b : h ... = b * 1 : by rewrite mul_one ... ≤ b * c : decidable.mul_le_mul_of_nonneg_left hc hb, le_of_mul_le_mul_right h' (zero_lt_one.trans_le hc)
haveI := @linear_order.decidable_le α _
exact have h' : a * c ≤ b * c, from calc a * c ≤ b : h ... = b * 1 : by rewrite mul_one ... ≤ b * c : decidable.mul_le_mul_of_nonneg_left hc hb, le_of_mul_le_mul_right h' (zero_lt_one.trans_le hc)
intros
{ convert mul_lt_mul_right h, simp }
convert mul_lt_mul_right h
simp
intros
simp [two_mul, ← add_assoc, h _]
intros
rw [← image_mul_left', image_singleton]
intros
simp only [← image2_mul, image_image2, image2_image_left, image2_image_right, m.map_mul]
{ simp only [← image2_mul, image_image2, image2_image_left, image2_image_right, m.map_mul] }
intros
simpa using multiset_prod_X_sub_C_coeff_card_pred (s.1.map f) (by simpa using hs)
intros
apply @mul_right_cancel _ _ _ (act x)
ext z
simp only [inv_mul_cancel_right]
apply self_distrib.symm
intros
rw [h, coe_re]
intros
refine ⟨λ h, h.subsingleton, _⟩
intros H a b h
exact @subsingleton.elim _ H a b
intros
simp only [semiconj_by, left_distrib, right_distrib, h.eq, h'.eq]
intros
simp
intros
convert units.is_unit E.disc_unit
exact E.disc_unit_eq.symm
intros
{ rw basic_open_mul f g, exact inf_le_right }
rw basic_open_mul f g
exact inf_le_right
intros
convert (has_deriv_at_gronwall_bound δ K ε _).comp x ((has_deriv_at_id x).sub_const a)
rw [id, mul_one]
intros
let c : composition 0 := composition.ones 0
dsimp [formal_multilinear_series.comp]
have : {c} = (finset.univ : finset (composition 0))
apply finset.eq_of_subset_of_card_le; simp [finset.card_univ, composition_card 0]
apply finset.eq_of_subset_of_card_le
{ apply finset.eq_of_subset_of_card_le; simp [finset.card_univ, composition_card 0] }
simp [finset.card_univ, composition_card 0]
simp [finset.card_univ, composition_card 0]
rw [← this, finset.sum_singleton, comp_along_composition_apply]
symmetry
congr'
intros
have N : 0 < n + 2
dec_trivial
dec_trivial
refine sum_congr rfl (λ c hc, p.congr rfl (λ j hj1 hj2, _))
have : ∀ k, c.blocks_fun k < n + 2
simp only [set.mem_to_finset, set.mem_set_of_eq] at hc
{ simp only [set.mem_to_finset, set.mem_set_of_eq] at hc, simp [← composition.ne_single_iff N, composition.eq_single_iff_length, ne_of_gt hc] }
simp [← composition.ne_single_iff N, composition.eq_single_iff_length, ne_of_gt hc]
simp [apply_composition, this]
intros
have cne0 : ∥c∥ ≠ 0
from mt norm_eq_zero.mp hc
rw [←is_O_norm_right]
simp only [norm_smul]
rw [is_O_const_mul_right_iff cne0, is_O_norm_right]
intros
simpa only [neg_sub] using h.neg_left
intros
rw differentiable_at.fderiv_within (differentiable_at_inv.2 x_ne_zero) hxs
exact fderiv_inv
intros
unfold deriv_within
{ unfold deriv_within, rw fderiv_within_zero_of_not_differentiable_within_at, simp, assumption }
rw fderiv_within_zero_of_not_differentiable_within_at
simp
assumption
intros
simp only [deriv, fderiv_neg, continuous_linear_map.neg_apply]
intros
simp [sub_eq_add_neg]
intros
have : s = univ ∩ s
simp only [univ_inter]
simp only [univ_inter]
rw [this, ← fderiv_within_univ]
exact fderiv_within_inter h (unique_diff_on_univ _ (mem_univ _))
intros
refine measurable_of_is_closed (λ s hs, _)
have : fderiv 𝕜 f ⁻¹' s = {x | differentiable_at 𝕜 f x ∧ fderiv 𝕜 f x ∈ s} ∪ {x | (0 : E →L[𝕜] F) ∈ s} ∩ {x | ¬differentiable_at 𝕜 f x} := set.ext (λ x, mem_preimage.trans fderiv_mem_iff)
rw this
exact (measurable_set_of_differentiable_at_of_is_complete _ _ hs.is_complete).union ((measurable_set.const _).inter (measurable_set_of_differentiable_at _ _).compl)
intros
cases hc with hE hc
refine ⟨univ, is_open.mem_nhds is_open_univ trivial, λ x hx y hy, _⟩
{ refine ⟨univ, is_open.mem_nhds is_open_univ trivial, λ x hx y hy, _⟩, simp [@subsingleton.elim E hE x y] }
simp [@subsingleton.elim E hE x y]
have := hf.def hc
rw [nhds_prod_eq, filter.eventually, mem_prod_same_iff] at this
rcases this with ⟨s, has, hs⟩
exact ⟨s, has, λ x hx y hy, hs (mk_mem_prod hx hy)⟩
intros
simpa only [zero_mul, sub_nonneg] using hD.mul_sub_le_image_sub_of_le_deriv hf hf' hf'_nonneg
intros
assume x xs
rcases hs with ⟨y, hy⟩
suffices : y - x ∈ interior (tangent_cone_at ℝ s x)
refine ⟨dense.of_closure _, subset_closure xs⟩
{ refine ⟨dense.of_closure _, subset_closure xs⟩, simp [(submodule.span ℝ (tangent_cone_at ℝ s x)).eq_top_of_nonempty_interior' ⟨y - x, interior_mono submodule.subset_span this⟩] }
simp [(submodule.span ℝ (tangent_cone_at ℝ s x)).eq_top_of_nonempty_interior' ⟨y - x, interior_mono submodule.subset_span this⟩]
rw [mem_interior_iff_mem_nhds] at hy ⊢
apply mem_of_superset ((is_open_map_sub_right x).image_mem_nhds hy)
rintros _ ⟨z, zs, rfl⟩
exact mem_tangent_cone_of_segment_subset (conv.segment_subset xs zs)
intros
rw [iterated_fderiv_succ_apply_right, iterated_fderiv_zero_apply]
{ rw [iterated_fderiv_succ_apply_right, iterated_fderiv_zero_apply], refl }
refl
intros
rw ← times_cont_diff_on_univ at ⊢ hf
rw [← fderiv_within_univ, ← univ_prod_univ]
exact times_cont_diff_on_fderiv_within_apply hf unique_diff_on_univ hmn
intros
rw times_cont_diff_on_succ_iff_deriv_within hs.unique_diff_on
congr' 2
rw ← iff_iff_eq
apply times_cont_diff_on_congr
assume x hx
exact deriv_within_of_open hs hx
intros
simpa [ext_iff, add_re, add_im, conj_re, conj_im, ←two_mul, (show (2 : ℝ) ≠ 0, by simp [two_ne_zero'])] using (h₃ z).symm
intros
convert open_segment_eq_image 𝕜 x y
{ convert open_segment_eq_image 𝕜 x y, ext θ, simp only [smul_sub, sub_smul, one_smul], abel }
ext θ
simp only [smul_sub, sub_smul, one_smul]
abel
intros
rintro p q ⟨ap, bp, hap, hbp, habp, rfl⟩ ⟨aq, bq, haq, hbq, habq, rfl⟩ a b ha hb hab
refine ⟨a * ap + b * aq, a * bp + b * bq, add_nonneg (mul_nonneg ha hap) (mul_nonneg hb haq), add_nonneg (mul_nonneg ha hbp) (mul_nonneg hb hbq), _, _⟩
rw [add_add_add_comm, ←mul_add, ←mul_add, habp, habq, mul_one, mul_one, hab]
{ rw [add_add_add_comm, ←mul_add, ←mul_add, habp, habq, mul_one, mul_one, hab] }
simp_rw [add_smul, mul_smul, smul_add]
{ simp_rw [add_smul, mul_smul, smul_add], exact add_add_add_comm _ _ _ _ }
exact add_add_add_comm _ _ _ _
intros
simpa only [center_mass, h₁, inv_one, one_smul] using hf.map_center_mass_le h₀ (h₁.symm ▸ zero_lt_one) hmem
intros
letI : inner_product_space ℝ E := inner_product_space.is_R_or_C_to_real 𝕜 E
letI : is_scalar_tower ℝ 𝕜 E := restrict_scalars.is_scalar_tower _ _ _
exact is_bounded_bilinear_map_inner.continuous
intros
have : ⟪y, x⟫_ℝ = ⟪x, y⟫_ℝ := by rw [←inner_conj_sym]; refl
simp [inner_sub_sub_self, this]
ring
intros
simp
intros
nth_rewrite 0 ← real.coe_to_nnreal p hpq.nonneg
nth_rewrite 0 ← real.coe_to_nnreal q hpq.symm.nonneg
exact young_inequality a b hpq.one_lt_nnreal hpq.inv_add_inv_conj_nnreal
intros
simpa only [dist_add_left, dist_add_right] using dist_triangle (g₁ + g₂) (h₁ + g₂) (h₁ + h₂)
intros
rw summable_iff_cauchy_seq_finset
{ rw summable_iff_cauchy_seq_finset, exact cauchy_seq_finset_of_norm_bounded g hg h }
exact cauchy_seq_finset_of_norm_bounded g hg h
intros
simp_rw [metric.tendsto_nhds_nhds, dist_eq_norm]
intros
{ rw [← zero_smul 𝕜 (0:V), e.map_smul], norm_num }
rw [← zero_smul 𝕜 (0:V), e.map_smul]
norm_num
intros
simpa only [fintype.card_fin] using f.le_op_norm_mul_pow_card_of_le m (λ i, (norm_le_pi_norm m i).trans hm)
intros
simp
intros
refine ⟨_, continuous_at_log⟩
rintros h rfl
exact not_tendsto_nhds_of_tendsto_at_bot tendsto_log_nhds_within_zero _ (h.tendsto.mono_left inf_le_left)
intros
refine ⟨λ h, _, λ h, tendsto_at_top_of_leading_coeff_nonneg P h.1 h.2⟩
have : tendsto (λ x, P.leading_coeff * x ^ P.nat_degree) at_top at_top := is_equivalent.tendsto_at_top (is_equivalent_at_top_lead P) h
rw tendsto_const_mul_pow_at_top_iff P.leading_coeff P.nat_degree at this
rw [degree_eq_nat_degree (leading_coeff_ne_zero.mp (ne_of_lt this.2).symm), ← nat.cast_one]
refine ⟨with_bot.coe_le_coe.mpr this.1, le_of_lt this.2⟩
intros
rw zero_rpow_def
{ rw zero_rpow_def, split_ifs, exacts [zero_mul _, one_mul _, top_mul_top] }
split_ifs
exacts [zero_mul _, one_mul _, top_mul_top]
intros
simp [rpow_def]
intros
simp [cpow_def, *]
intros
simpa using (has_strict_fderiv_at_rpow_of_neg (a, x) ha).comp_has_strict_deriv_at x ((has_strict_deriv_at_const _ _).prod (has_strict_deriv_at_id _))
intros
simp only [cosh, div_eq_mul_inv]
convert ((has_strict_deriv_at_exp x).sub (has_strict_deriv_at_id x).neg.cexp).mul_const (2:ℂ)⁻¹
rw [id, mul_neg_one, sub_eq_add_neg, neg_neg]
intros
simpa using add_monoid_hom.map_nsmul ⟨coe, coe_zero, coe_add⟩ _ _
intros
unfold arccos; linarith [neg_pi_div_two_le_arcsin x]
unfold arccos
linarith [neg_pi_div_two_le_arcsin x]
intros
by_cases h0 : r₁ = 0
refine (is_o_zero _ _).congr' (mem_at_top_sets.2 $ ⟨1, λ n hn, _⟩) eventually_eq.rfl
{ refine (is_o_zero _ _).congr' (mem_at_top_sets.2 $ ⟨1, λ n hn, _⟩) eventually_eq.rfl, simp [zero_pow (zero_lt_one.trans_le hn), h0] }
simp [zero_pow (zero_lt_one.trans_le hn), h0]
rw [← ne.def, ← norm_pos_iff] at h0
have A : is_o (λ n, n ^ k : ℕ → R) (λ n, (r₂ / ∥r₁∥) ^ n) at_top
from is_o_pow_const_const_pow_of_one_lt k ((one_lt_div h0).2 h)
suffices : is_O (λ n, r₁ ^ n) (λ n, ∥r₁∥ ^ n) at_top
simpa [div_mul_cancel _ (pow_pos h0 _).ne'] using A.mul_is_O this
simpa [div_mul_cancel _ (pow_pos h0 _).ne'] using A.mul_is_O this
exact is_O.of_bound 1 (by simpa using eventually_norm_pow_le r₁)
intros
set v : ℕ → α := λ n, if n < N then 0 else u n
have hC : 0 ≤ C
from (zero_le_mul_right $ pow_pos hr₀ N).mp ((norm_nonneg _).trans $ h N $ le_refl N)
have : ∀ n ≥ N, u n = v n
intros n hn
{ intros n hn, simp [v, hn, if_neg (not_lt.mpr hn)] }
simp [v, hn, if_neg (not_lt.mpr hn)]
refine cauchy_seq_sum_of_eventually_eq this (normed_group.cauchy_series_of_le_geometric' hr₁ _)
{ exact C }
exact C
intro n
dsimp [v]
split_ifs with H H
rw norm_zero
{ rw norm_zero, exact mul_nonneg hC (pow_nonneg hr₀.le _) }
exact mul_nonneg hC (pow_nonneg hr₀.le _)
push_neg at H
{ push_neg at H, exact h _ H }
exact h _ H
intros
rw [←cancel_mono (i.map ((of_right_adjoint i).counit.app ((left_adjoint i).obj X))), ←i.map_comp]
simp
intros
split_ifs; refl
{ split_ifs; refl }
split_ifs
refl
refl
intros
simp
intros
{ ext, simp, }
ext
simp
intros
simp only [cancel_mono]
intros
classical
let O := (finset.univ.image F.obj)
let H : finset (Σ' (X Y : C) (mX : X ∈ O) (mY : Y ∈ O), X ⟶ Y) := finset.univ.bUnion (λ X : J, finset.univ.bUnion (λ Y : J, finset.univ.image (λ f : X ⟶ Y, ⟨F.obj X, F.obj Y, by simp, by simp, F.map f⟩)))
obtain ⟨Z, f, w⟩ := inf_exists O H
refine ⟨⟨Z, ⟨λ X, f (by simp), _⟩⟩⟩
intros j j' g
dsimp
simp only [category.id_comp]
symmetry
apply w
simp only [finset.mem_univ, finset.mem_bUnion, exists_and_distrib_left, exists_prop_of_true, finset.mem_image]
exact ⟨j, rfl, j', g, (by simp)⟩
intros
ext
ext; erw [assoc, limit.post_π, ←H.map_comp, limit.post_π, limit.post_π]; refl
ext; erw [assoc, limit.post_π, ←H.map_comp, limit.post_π, limit.post_π]
erw [assoc, limit.post_π, ←H.map_comp, limit.post_π, limit.post_π]
refl
intros
{ ext; simp }
ext
ext; simp
simp
simp
intros
tidy
intros
rw ←image.lift_fac (mono_factorisation_zero X Y)
simp
intros
rw ←((iso.eq_comp_inv _).mp (pentagon_inv W X Y Z))
slice_rhs 1 2 { rw [←id_tensor_comp, iso.hom_inv_id] }
simp only [tensor_id, assoc, id_comp]
intros
{ ext, rw [←right_unitor_hom_f, ←comp_f, iso.hom_inv_id], refl, }
ext
rw [←right_unitor_hom_f, ←comp_f, iso.hom_inv_id]
refl
intros
ext
ext; refl
refl
intros
apply J.transitive rj _ (λ Y f Hf, _)
rw [sieve.pullback_inter, R.pullback_eq_top_of_mem Hf]
simp [sj]
intros
intros Y f hf
dsimp [family_of_elements.sieve_extend]
rw [←ht _, ←functor_to_types.map_comp_apply, ←op_comp, (some_spec (some_spec (some_spec hf))).2]
intros
simp [sieve.ext_iff]
intros
simp [of_le, ←functor.map_comp underlying]
intros
simp [equalizer_subobject_iso]
intros
{ dsimp, simp }
dsimp
simp
intros
conv_rhs { rw [← c.blocks_sum, ← sum_take_add_sum_drop _ i] }
exact nat.le_add_right _ _
intros
simp [split_wrt_composition_aux]
intros
have h1 : ∀ a : fin (n+1), card ({a}ᶜ : set (fin (n+1))) = card (fin n)
intro a
{ intro a, simp only [fintype.card_fin, finset.card_fin, fintype.card_of_finset, finset.filter_ne' _ a, set.mem_compl_singleton_iff, finset.card_erase_of_mem (finset.mem_univ a), nat.pred_succ] }
simp only [fintype.card_fin, finset.card_fin, fintype.card_of_finset, finset.filter_ne' _ a, set.mem_compl_singleton_iff, finset.card_erase_of_mem (finset.mem_univ a), nat.pred_succ]
have h2 : card (fin (n+2)) = card (option (fin (n+1)))
{ simp only [card_fin, card_option] }
simp only [card_fin, card_option]
simp only [card_derangements_invariant h2, card_congr (@derangements_recursion_equiv (fin (n+1)) _), card_sigma, card_sum, card_derangements_invariant (h1 _), finset.sum_const, nsmul_eq_mul, finset.card_fin, mul_add, nat.cast_id]
intros
cases n; unfold encode_num decode_num
cases n
unfold encode_num decode_num
{ refl }
refl
unfold encode_num decode_num
rw decode_encode_pos_num n
rw pos_num.cast_to_num
exact if_neg (encode_pos_num_nonempty n)
intros
simpa using hf.comp' (hg.cons $ hh.cons primrec'.nil)
simp [primrec₂, primrec]; constructor
simp [primrec₂, primrec]
constructor
intros
suffices : ∃ c : code, ∀ v : vector ℕ m, c.eval v.1 = subtype.val <$> vector.m_of_fn (λ i, g i v)
obtain ⟨cf, hf⟩ := hf
{ obtain ⟨cf, hf⟩ := hf, obtain ⟨cg, hg⟩ := this, exact ⟨cf.comp cg, λ v, by { simp [hg, hf, map_bind, seq_bind_eq, (∘), -subtype.val_eq_coe], refl }⟩ }
obtain ⟨cg, hg⟩ := this
exact ⟨cf.comp cg, λ v, by { simp [hg, hf, map_bind, seq_bind_eq, (∘), -subtype.val_eq_coe], refl }⟩
clear hf f
induction n with n IH
{ exact ⟨nil, λ v, by simp [vector.m_of_fn]; refl⟩ }
exact ⟨nil, λ v, by simp [vector.m_of_fn]; refl⟩
obtain ⟨cg, hg₁⟩ := hg 0
{ obtain ⟨cg, hg₁⟩ := hg 0, obtain ⟨cl, hl⟩ := IH (λ i, hg i.succ), exact ⟨cons cg cl, λ v, by { simp [vector.m_of_fn, hg₁, map_bind, seq_bind_eq, bind_assoc, (∘), hl, -subtype.val_eq_coe], refl }⟩ }
obtain ⟨cl, hl⟩ := IH (λ i, hg i.succ)
exact ⟨cons cg cl, λ v, by { simp [vector.m_of_fn, hg₁, map_bind, seq_bind_eq, bind_assoc, (∘), hl, -subtype.val_eq_coe], refl }⟩
intros
simp only [tr_normal_run, step_run]
have hgo := tr_respects_aux₁ M o q v (hT k) _ (le_refl _)
obtain ⟨T', hT', hrun⟩ := tr_respects_aux₂ hT o
have hret := tr_respects_aux₃ M _
have := hgo.tail' rfl
rw [tr, TM1.step_aux, tape.move_right_n_head, tape.mk'_nth_nat, add_bottom_nth_snd, stk_nth_val _ (hT k), list.nth_len_le (le_of_eq (list.length_reverse _)), option.is_none, cond, hrun, TM1.step_aux] at this
obtain ⟨c, gc, rc⟩ := IH hT'
refine ⟨c, gc, (this.to₀.trans hret c (trans_gen.head' rfl _)).to_refl⟩
rw [tr, TM1.step_aux, tape.mk'_head, add_bottom_head_fst]
exact rc
intros
cases T; cases d; simp only [tape.move, tape.map, list_blank.head_map, eq_self_iff_true, list_blank.map_cons, and_self, list_blank.tail_map]
cases T; cases d
cases T
cases d
simp only [tape.move, tape.map, list_blank.head_map, eq_self_iff_true, list_blank.map_cons, and_self, list_blank.tail_map]
simp only [tape.move, tape.map, list_blank.head_map, eq_self_iff_true, list_blank.map_cons, and_self, list_blank.tail_map]
intros
cases x
cases x; refl
refl
intros
cases x; refl
cases x
refl
refl
intros
rw [←rev_list_reverse, ←rev_list_reverse, push_back_rev_list, list.reverse_cons]
intros
cases cs with hd tl
{ simp [one_of', static.bind], }
simp [one_of', static.bind]
have : one_of' (hd :: tl) (hd :: tl).to_buffer 0 = done 1 ()
{ have : one_of' (hd :: tl) (hd :: tl).to_buffer 0 = done 1 (), { simp [one_of'_eq_done] }, simpa using not_of_ne this zero_ne_one }
{ simp [one_of'_eq_done] }
simp [one_of'_eq_done]
simpa using not_of_ne this zero_ne_one
intros
constructor
intros cb n hn
haveI : (parser.fix_core F (cb.size - n + 1)).bounded := fix_core hF _
obtain ⟨np, errp, hp⟩ := bounded.exists (parser.fix_core F (cb.size - n + 1)) hn
simp [fix, hp]
intros
induction l with hd tl hl generalizing n n'
{ simpa using h }
simpa using h
obtain ⟨k, hk⟩ : ∃ k, n' = n + k + 1 := nat.exists_eq_add_of_lt (prog.of_done h)
{ obtain ⟨k, hk⟩ : ∃ k, n' = n + k + 1 := nat.exists_eq_add_of_lt (prog.of_done h), subst hk, simp only [many1_eq_done] at h, obtain ⟨_, hp, h⟩ := h, have := step.of_done hp, subst this, cases tl, { simp only [many_eq_done_nil, add_left_inj, exists_and_distrib_right, self_eq_add_right] at h, rcases h with ⟨rfl, -⟩, simp }, rw ←many1_eq_done_iff_many_eq_done at h, specialize hl h, simp [hl, add_comm, add_assoc, nat.sub_succ] }
subst hk
simp only [many1_eq_done] at h
obtain ⟨_, hp, h⟩ := h
have := step.of_done hp
subst this
cases tl
simp only [many_eq_done_nil, add_left_inj, exists_and_distrib_right, self_eq_add_right] at h
{ simp only [many_eq_done_nil, add_left_inj, exists_and_distrib_right, self_eq_add_right] at h, rcases h with ⟨rfl, -⟩, simp }
rcases h with ⟨rfl, -⟩
simp
rw ←many1_eq_done_iff_many_eq_done at h
specialize hl h
simp [hl, add_comm, add_assoc, nat.sub_succ]
intros
simp [foldl_core, eq_comm]
intros
rw ← of_real_inj; simp [sin_two_mul]
rw ← of_real_inj
simp [sin_two_mul]
intros
linarith [add_one_le_exp_of_nonneg hx]
intros
have h2 : (2:ℂ) ≠ 0 := by norm_num
calc cos x + cos y = cos ((x + y) / 2 + (x - y) / 2) + cos ((x + y) / 2 - (x - y) / 2) : _ ... = (cos ((x + y) / 2) * cos ((x - y) / 2) - sin ((x + y) / 2) * sin ((x - y) / 2)) + (cos ((x + y) / 2) * cos ((x - y) / 2) + sin ((x + y) / 2) * sin ((x - y) / 2)) : _ ... = 2 * cos ((x + y) / 2) * cos ((x - y) / 2) : _
congr; field_simp [h2]; ring
congr; field_simp [h2]
{ congr; field_simp [h2]; ring }
congr
field_simp [h2]
field_simp [h2]
ring
{ rw [cos_add, cos_sub] }
rw [cos_add, cos_sub]
ring
intros
simp only [bit1, add_right_eq_self, add_monoid_hom.map_add, bit0_im, one_im]
intros
induction n; simp [*, of_real_mul, pow_succ]
induction n
simp [*, of_real_mul, pow_succ]
simp [*, of_real_mul, pow_succ]
intros
rw [is_R_or_C.norm_eq_abs, real.norm_eq_abs]
{ rw [is_R_or_C.norm_eq_abs, real.norm_eq_abs], exact is_R_or_C.abs_im_le_abs _, }
exact is_R_or_C.abs_im_le_abs _
intros
simp
intros
rw ←filter_ne_eq_erase f i
congr' with j
exact ne_comm
intros
ext j
rcases eq_or_ne i j with rfl|hi
{ simp [h] }
simp [h]
{ simp [hi.symm] }
simp [hi.symm]
intros
{ cases a, cases a_val, refl }
cases a
cases a_val
refl
intros
simp [perm.extend_domain, h]
intros
rw [← update_comp_eq_of_injective _ g.injective, g.apply_symm_apply]
intros
simp [fin_add_flip]
intros
{ change univ ∩ id⁻¹' s = s, simp }
change univ ∩ id⁻¹' s = s
simp
intros
{ rw [succ_above], exact if_pos h }
rw [succ_above]
exact if_pos h
intros
rcases i.le_last.eq_or_lt with rfl|H
{ simp }
simp
simp only [H]
{ simp only [H], rw ←cast_succ_cast_pred H, simp }
rw ←cast_succ_cast_pred H
simp
intros
rcases (le_last i).eq_or_lt with rfl|h
{ simp }
simp
{ simpa [h.ne] using coe_add_one_of_lt h }
simpa [h.ne] using coe_add_one_of_lt h
intros
{ ext i, simp [piecewise] }
ext i
simp [piecewise]
intros
simp only [mem_insert, or_and_distrib_right, exists_or_distrib, exists_eq_left]
intros
refine ⟨λ h, _, finset.mem_image_of_mem f⟩
obtain ⟨y, hy, heq⟩ := mem_image.1 h
exact hf heq ▸ hy
intros
exact_mod_cast @set.ssubset_iff_insert α s t
intros
intros a a_in
rw finset.mem_inter at a_in ⊢
exact ⟨h a_in.1, h' a_in.2⟩
intros
classical
exact le_antisymm (supr_le $ assume b, le_supr_of_le {b} $ le_supr_of_le b $ le_supr_of_le (by simp) $ le_refl _) (supr_le $ assume t, supr_le $ assume b, supr_le $ assume hb, le_supr _ _)
intros
induction s using quotient.induction_on
simp
intros
{ ext, simp, }
ext
simp
intros
refine f.induction _ _
rw [to_multiset_zero, multiset.map_zero, map_domain_zero, to_multiset_zero]
{ rw [to_multiset_zero, multiset.map_zero, map_domain_zero, to_multiset_zero] }
assume a n f _ _ ih
{ assume a n f _ _ ih, rw [to_multiset_add, multiset.map_add, ih, map_domain_add, map_domain_single, to_multiset_single, to_multiset_add, to_multiset_single, ← multiset.coe_map_add_monoid_hom, (multiset.map_add_monoid_hom g).map_nsmul], refl }
rw [to_multiset_add, multiset.map_add, ih, map_domain_add, map_domain_single, to_multiset_single, to_multiset_add, to_multiset_single, ← multiset.coe_map_add_monoid_hom, (multiset.map_add_monoid_hom g).map_nsmul]
refl
intros
dunfold split
rw comap_domain_apply
intros
simp [ext_iff]
intros
simp
intros
rw [fintype.prod_eq_mul_prod_compl x, ← fin.image_succ_above_univ, prod_image]
exact λ _ _ _ _ h, x.succ_above.injective h
intros
suffices : ∀ (l : list Σ a, β a) (t : bucket_array α β n') sz, valid hash_fn t sz → ((l ++ t.as_list).map sigma.fst).nodup → valid hash_fn (l.foldl (λr (a : Σ a, β a), reinsert_aux hash_fn r a.1 a.2) t) (sz + l.length)
have p := this bkts.as_list _ _ (mk_valid _ _)
{ have p := this bkts.as_list _ _ (mk_valid _ _), rw [mk_as_list, list.append_nil, zero_add, v.len] at p, rw bucket_array.foldl_eq, exact p (v.as_list_nodup _) }
rw [mk_as_list, list.append_nil, zero_add, v.len] at p
rw bucket_array.foldl_eq
exact p (v.as_list_nodup _)
intro l
induction l with c l IH
induction l with c l IH; intros t sz v nd
intros t sz v nd
exact v
{exact v}
intros t sz v nd
rw show sz + (c :: l).length = sz + 1 + l.length, by simp [add_comm, add_assoc]
rcases (show (l.map sigma.fst).nodup ∧ ((bucket_array.as_list t).map sigma.fst).nodup ∧ c.fst ∉ l.map sigma.fst ∧ c.fst ∉ (bucket_array.as_list t).map sigma.fst ∧ (l.map sigma.fst).disjoint ((bucket_array.as_list t).map sigma.fst), by simpa [list.nodup_append, not_or_distrib, and_comm, and.left_comm] using nd) with ⟨nd1, nd2, nm1, nm2, dj⟩
have v' := v.insert _ _ c.2 (λHc, nm2 $ (v.contains_aux_iff _ c.1).1 Hc)
apply IH _ _ v'
suffices : ∀ ⦃a : α⦄ (b : β a), sigma.mk a b ∈ l → ∀ (b' : β a), sigma.mk a b' ∈ (reinsert_aux hash_fn t c.1 c.2).as_list → false
simpa [list.nodup_append, nd1, v'.as_list_nodup _, list.disjoint]
{ simpa [list.nodup_append, nd1, v'.as_list_nodup _, list.disjoint] }
intros a b m1 b' m2
rcases (reinsert_aux hash_fn t c.1 c.2).mem_as_list.1 m2 with ⟨i, im⟩
have : sigma.mk a b' ∉ array.read t i
intro m3
{ intro m3, have : a ∈ list.map sigma.fst t.as_list := list.mem_map_of_mem sigma.fst (t.mem_as_list.2 ⟨_, m3⟩), exact dj (list.mem_map_of_mem sigma.fst m1) this }
have : a ∈ list.map sigma.fst t.as_list := list.mem_map_of_mem sigma.fst (t.mem_as_list.2 ⟨_, m3⟩)
exact dj (list.mem_map_of_mem sigma.fst m1) this
by_cases h : mk_idx n' (hash_fn c.1) = i
subst h
{ subst h, have e : sigma.mk a b' = ⟨c.1, c.2⟩, { simpa [reinsert_aux, bucket_array.modify, array.read_write, this] using im }, injection e with e, subst a, exact nm1.elim (@list.mem_map_of_mem _ _ sigma.fst _ _ m1) }
have e : sigma.mk a b' = ⟨c.1, c.2⟩
simpa [reinsert_aux, bucket_array.modify, array.read_write, this] using im
{ simpa [reinsert_aux, bucket_array.modify, array.read_write, this] using im }
injection e with e
subst a
exact nm1.elim (@list.mem_map_of_mem _ _ sigma.fst _ _ m1)
apply this
{ apply this, simpa [reinsert_aux, bucket_array.modify, array.read_write_of_ne _ _ h] using im }
simpa [reinsert_aux, bucket_array.modify, array.read_write_of_ne _ _ h] using im
intros
rw [neg_succ, succ_pred]
intros
rw [mul_comm, int.mul_div_cancel _ H]
intros
ext (x | x)
{ exact (monoid_hom.congr_fun h_nat x : _), }
exact (monoid_hom.congr_fun h_nat x : _)
rw [int.neg_succ_of_nat_eq, ← neg_one_mul, f.map_mul, g.map_mul]
{ rw [int.neg_succ_of_nat_eq, ← neg_one_mul, f.map_mul, g.map_mul], congr' 1, exact_mod_cast (monoid_hom.congr_fun h_nat (x + 1) : _), }
congr' 1
exact_mod_cast (monoid_hom.congr_fun h_nat (x + 1) : _)
intros
rw int.lcm
{ rw int.lcm, apply coe_nat_dvd_right.mpr, apply nat.dvd_lcm_left }
apply coe_nat_dvd_right.mpr
apply nat.dvd_lcm_left
intros
rw [modeq_iff_dvd] at *; exact (dvd_mul_left n m).trans h
rw [modeq_iff_dvd] at *
exact (dvd_mul_left n m).trans h
intros
split
intro h
{ intro h, by_contradiction h', have h₂ : ∃ h, l.nth_le n h = l.nth_le n (lt_of_not_ge h') := ⟨lt_of_not_ge h', rfl⟩, rw [← nth_eq_some, h] at h₂, cases h₂ }
by_contradiction h'
have h₂ : ∃ h, l.nth_le n h = l.nth_le n (lt_of_not_ge h') := ⟨lt_of_not_ge h', rfl⟩
rw [← nth_eq_some, h] at h₂
cases h₂
{ solve_by_elim [nth_len_le] }
solve_by_elim [nth_len_le]
intros
have A : length (take i L) = i
simp [le_of_lt (lt_of_le_of_lt (nat.le.intro rfl) h)]
simp [le_of_lt (lt_of_le_of_lt (nat.le.intro rfl) h)]
rw [nth_le_of_eq (take_append_drop i L).symm h, nth_le_append_right]
rw [nth_le_of_eq (take_append_drop i L).symm h, nth_le_append_right]; simp [A]
simp [A]
simp [A]
intros
cases l
{ simp only [nth, scanl_nil] }
simp only [nth, scanl_nil]
{ simp only [nth, scanl_cons, singleton_append] }
simp only [nth, scanl_cons, singleton_append]
intros
{ cases L, { simp at h, cases h, }, { simp, }, }
cases L
simp at h
{ simp at h, cases h, }
cases h
simp
{ simp, }
intros
simp only [mem_append, or_imp_distrib, forall_and_distrib]
intros
induction l with a l IH
{ exact iff_of_true rfl (forall_mem_nil _) }
exact iff_of_true rfl (forall_mem_nil _)
rw forall_mem_cons
by_cases h : p a
simp only [find_cons_of_pos _ h, h, not_true, false_and]
{ simp only [find_cons_of_pos _ h, h, not_true, false_and] }
rwa [find_cons_of_neg _ h, iff_true_intro h, true_and]
{ rwa [find_cons_of_neg _ h, iff_true_intro h, true_and] }
intros
simp
intros
{ rw tails_eq_inits l, simp [reverse_involutive.comp_self], }
rw tails_eq_inits l
simp [reverse_involutive.comp_self]
intros
induction l₂ with b l₂ ih generalizing l₁ a
{ simp_rw [diff_cons, diff_nil] }
simp_rw [diff_cons, diff_nil]
rw [diff_cons, diff_cons, erase_comm, ← diff_cons, ih, ← diff_cons]
{ rw [diff_cons, diff_cons, erase_comm, ← diff_cons, ih, ← diff_cons] }
intros
cases as; refl
cases as
refl
refl
intros
{ transitivity, rw [← bind_singleton' l, bind_map], refl }
transitivity
rw [← bind_singleton' l, bind_map]
refl
intros
have r : min m (n + 1) = n + 1 := (@inf_eq_right _ _ m (n + 1)).mpr hnm
simp [filter_lt n m (n + 1), r]
intros
induction l with hd tl hl
{ simp }
simp
specialize hl (nodup_of_nodup_cons h)
{ specialize hl (nodup_of_nodup_cons h), by_cases hx : tl = [x], { simpa [hx, and.comm, and_or_distrib_left] using h }, { rw [←ne.def, hl] at hx, rcases hx with rfl | ⟨y, hy, hx⟩, { simp }, { have : tl ≠ [] := ne_nil_of_mem hy, suffices : ∃ (y : α) (H : y ∈ hd :: tl), y ≠ x, { simpa [ne_nil_of_mem hy] }, exact ⟨y, mem_cons_of_mem _ hy, hx⟩ } } }
by_cases hx : tl = [x]
{ simpa [hx, and.comm, and_or_distrib_left] using h }
simpa [hx, and.comm, and_or_distrib_left] using h
rw [←ne.def, hl] at hx
{ rw [←ne.def, hl] at hx, rcases hx with rfl | ⟨y, hy, hx⟩, { simp }, { have : tl ≠ [] := ne_nil_of_mem hy, suffices : ∃ (y : α) (H : y ∈ hd :: tl), y ≠ x, { simpa [ne_nil_of_mem hy] }, exact ⟨y, mem_cons_of_mem _ hy, hx⟩ } }
rcases hx with rfl | ⟨y, hy, hx⟩
{ simp }
simp
have : tl ≠ [] := ne_nil_of_mem hy
{ have : tl ≠ [] := ne_nil_of_mem hy, suffices : ∃ (y : α) (H : y ∈ hd :: tl), y ≠ x, { simpa [ne_nil_of_mem hy] }, exact ⟨y, mem_cons_of_mem _ hy, hx⟩ }
suffices : ∃ (y : α) (H : y ∈ hd :: tl), y ≠ x
simpa [ne_nil_of_mem hy]
{ simpa [ne_nil_of_mem hy] }
exact ⟨y, mem_cons_of_mem _ hy, hx⟩
intros
simp only [range_eq_range', range'_concat, zero_add]
intros
simp [is_rotated_reverse_comm_iff]
intros
ext b
ext b; simp [mem_lookup_iff, nd₁, nd₂]; exact p.mem_iff
ext b; simp [mem_lookup_iff, nd₁, nd₂]
simp [mem_lookup_iff, nd₁, nd₂]
exact p.mem_iff
intros
rw [← zip_map, map_id]
intros
simp_rw [←drop_one, zip_with_distrib_drop]
intros
ext i j
apply dot_product_comm
intros
ext i' j'
rw [update_row_apply, map_apply, map_apply, update_row_apply]
exact apply_ite f _ _ _
intros
{ ext, simp [mul_comm] }
ext
simp [mul_comm]
intros
simp only [conj_transpose, from_blocks_transpose, from_blocks_map]
intros
{ ext, refl }
ext
refl
intros
have := card_powerset s; rwa [← antidiagonal_map_fst, card_map] at this
have := card_powerset s
rwa [← antidiagonal_map_fst, card_map] at this
intros
rw ← eq_union_left h₂; exact union_le_union_right h₁ t
rw ← eq_union_left h₂
exact union_le_union_right h₁ t
intros
induction n; simp [*, succ_nsmul', succ_mul, zero_nsmul]
induction n
simp [*, succ_nsmul', succ_mul, zero_nsmul]
simp [*, succ_nsmul', succ_mul, zero_nsmul]
intros
induction n with n ih
rw zero_nsmul at h
{ rw zero_nsmul at h, exact absurd h (not_mem_zero _) }
exact absurd h (not_mem_zero _)
rw [succ_nsmul, mem_add] at h
{ rw [succ_nsmul, mem_add] at h, exact h.elim id ih }
exact h.elim id ih
intros
rw [← mem_coe, sort_eq]
intros
simp [constant_coeff_eq]
intros
suffices : eval₂_hom f (0 : σ → S₂) = f.comp constant_coeff
from ring_hom.congr_fun this p
ext
ext; simp
simp
simp
intros
apply alg_hom_ext
{ apply alg_hom_ext, intro i, simp only [alg_hom.comp_apply, bind₁_X_right], }
intro i
simp only [alg_hom.comp_apply, bind₁_X_right]
intros
simp [supported_eq_adjoin_X]
intros
rw [← C_0]; exact total_degree_C (0 : R)
rw [← C_0]
exact total_degree_C (0 : R)
intros
rw [add_comm, add_mod_eq_add_mod_right _ H, add_comm]
intros
{ refine le_trans _ h, simp }
refine le_trans _ h
simp
intros
{ dunfold decreasing_induction, rw [le_rec_on_succ'] }
dunfold decreasing_induction
rw [le_rec_on_succ']
intros
induction n; simp *
induction n
simp *
simp *
intros
simp [of_digits]
intros
have b2 : 2 ≤ b := by linarith
refine ⟨_, b2, n0⟩
rw [nat.digits_def' b2 n0, nat.mod_eq_of_lt nb, (nat.div_eq_zero_iff (by linarith : 0 < b)).2 nb, nat.digits_zero]
intros
rw [← some_eq_coe]
rw [← some_eq_coe]; trivial
trivial
intros
rw [modeq_iff_dvd, int.coe_nat_add, int.coe_nat_add, add_sub_comm]
exact dvd_add h₁.dvd h₂.dvd
intros
simp [not_or_distrib] with parity_simps
intros
split
intro h
{ intro h, convert min_fac_dvd _, rw h, }
convert min_fac_dvd _
rw h
intro h
{ intro h, have ub := min_fac_le_of_dvd (le_refl 2) h, have lb := min_fac_pos n, cases h : n.min_fac with m, { rw h at lb, cases lb, }, { cases m with m, { simp at h, subst h, cases h with n h, cases n; cases h, }, { cases m with m, { refl, }, { rw h at ub, cases ub with _ ub, cases ub with _ ub, cases ub, } } } }
have ub := min_fac_le_of_dvd (le_refl 2) h
have lb := min_fac_pos n
cases h : n.min_fac with m
{ rw h at lb, cases lb, }
rw h at lb
cases lb
cases m with m
{ cases m with m, { simp at h, subst h, cases h with n h, cases n; cases h, }, { cases m with m, { refl, }, { rw h at ub, cases ub with _ ub, cases ub with _ ub, cases ub, } } }
{ simp at h, subst h, cases h with n h, cases n; cases h, }
simp at h
subst h
cases h with n h
cases n
cases n; cases h
cases h
cases h
cases m with m
{ cases m with m, { refl, }, { rw h at ub, cases ub with _ ub, cases ub with _ ub, cases ub, } }
refl
{ refl, }
rw h at ub
{ rw h at ub, cases ub with _ ub, cases ub with _ ub, cases ub, }
cases ub with _ ub
cases ub with _ ub
cases ub
intros
rw ← e
refine ⟨nat.succ_pos _, (lt_of_le_of_ne (lt_of_le_of_ne _ _ : k+1+k < _) min_fac_ne_bit0.symm : bit0 (k+1) < _)⟩
{ rw add_right_comm, exact h.2 }
rw add_right_comm
exact h.2
{ rw add_right_comm, exact np.symm }
rw add_right_comm
exact np.symm
intros
rw sqrt_aux; simp
rw sqrt_aux
simp
intros
rw [← cast_to_int m, ← cast_to_int n, int.cast_inj, to_int_inj]
intros
simp
intros
cases o; simp
cases o
simp
simp
intros
induction t generalizing a₁ a₂ h h_mem
{ contradiction }
contradiction
have t_ih_l' := t_ih_l h.left
{ have t_ih_l' := t_ih_l h.left, have t_ih_r' := t_ih_r h.right, clear t_ih_l t_ih_r, unfold has_mem.mem mem at h_mem, unfold erase, cases (cmp_le x t_x); simp [mem._match_1] at h_mem; simp [erase._match_1], { have t_ih_l := t_ih_l' h_mem, clear t_ih_l' t_ih_r', have t_l_h := valid'.erase_aux x h.left, cases t_l_h with t_l_valid t_l_size, rw size_balance_r t_l_valid.bal h.right.bal t_l_valid.sz h.right.sz (or.inl (exists.intro t_l.size (and.intro t_l_size h.bal.1))), rw [t_ih_l, h.sz.1], have h_pos_t_l_size := pos_size_of_mem h.left.sz h_mem, cases t_l.size with t_l_size, { cases h_pos_t_l_size }, simp [nat.succ_add] }, { rw [(valid'.glue h.left h.right h.bal.1).2, h.sz.1], refl }, { have t_ih_r := t_ih_r' h_mem, clear t_ih_l' t_ih_r', have t_r_h := valid'.erase_aux x h.right, cases t_r_h with t_r_valid t_r_size, rw size_balance_l h.left.bal t_r_valid.bal h.left.sz t_r_valid.sz (or.inr (exists.intro t_r.size (and.intro t_r_size h.bal.1))), rw [t_ih_r, h.sz.1], have h_pos_t_r_size := pos_size_of_mem h.right.sz h_mem, cases t_r.size with t_r_size, { cases h_pos_t_r_size }, simp [nat.succ_add, nat.add_succ] } }
have t_ih_r' := t_ih_r h.right
clear t_ih_l t_ih_r
unfold has_mem.mem mem at h_mem
unfold erase
cases (cmp_le x t_x); simp [mem._match_1] at h_mem; simp [erase._match_1]
cases (cmp_le x t_x); simp [mem._match_1] at h_mem
cases (cmp_le x t_x)
simp [mem._match_1] at h_mem
simp [erase._match_1]
have t_ih_l := t_ih_l' h_mem
{ have t_ih_l := t_ih_l' h_mem, clear t_ih_l' t_ih_r', have t_l_h := valid'.erase_aux x h.left, cases t_l_h with t_l_valid t_l_size, rw size_balance_r t_l_valid.bal h.right.bal t_l_valid.sz h.right.sz (or.inl (exists.intro t_l.size (and.intro t_l_size h.bal.1))), rw [t_ih_l, h.sz.1], have h_pos_t_l_size := pos_size_of_mem h.left.sz h_mem, cases t_l.size with t_l_size, { cases h_pos_t_l_size }, simp [nat.succ_add] }
clear t_ih_l' t_ih_r'
have t_l_h := valid'.erase_aux x h.left
cases t_l_h with t_l_valid t_l_size
rw size_balance_r t_l_valid.bal h.right.bal t_l_valid.sz h.right.sz (or.inl (exists.intro t_l.size (and.intro t_l_size h.bal.1)))
rw [t_ih_l, h.sz.1]
have h_pos_t_l_size := pos_size_of_mem h.left.sz h_mem
cases t_l.size with t_l_size
cases h_pos_t_l_size
{ cases h_pos_t_l_size }
simp [nat.succ_add]
simp [mem._match_1] at h_mem
simp [erase._match_1]
{ rw [(valid'.glue h.left h.right h.bal.1).2, h.sz.1], refl }
rw [(valid'.glue h.left h.right h.bal.1).2, h.sz.1]
refl
simp [mem._match_1] at h_mem
simp [erase._match_1]
have t_ih_r := t_ih_r' h_mem
{ have t_ih_r := t_ih_r' h_mem, clear t_ih_l' t_ih_r', have t_r_h := valid'.erase_aux x h.right, cases t_r_h with t_r_valid t_r_size, rw size_balance_l h.left.bal t_r_valid.bal h.left.sz t_r_valid.sz (or.inr (exists.intro t_r.size (and.intro t_r_size h.bal.1))), rw [t_ih_r, h.sz.1], have h_pos_t_r_size := pos_size_of_mem h.right.sz h_mem, cases t_r.size with t_r_size, { cases h_pos_t_r_size }, simp [nat.succ_add, nat.add_succ] }
clear t_ih_l' t_ih_r'
have t_r_h := valid'.erase_aux x h.right
cases t_r_h with t_r_valid t_r_size
rw size_balance_l h.left.bal t_r_valid.bal h.left.sz t_r_valid.sz (or.inr (exists.intro t_r.size (and.intro t_r_size h.bal.1)))
rw [t_ih_r, h.sz.1]
have h_pos_t_r_size := pos_size_of_mem h.right.sz h_mem
cases t_r.size with t_r_size
cases h_pos_t_r_size
{ cases h_pos_t_r_size }
simp [nat.succ_add, nat.add_succ]
intros
cases m; simp [node4_r, all_node', all, all_node3_r, and_assoc]
cases m
simp [node4_r, all_node', all, all_node3_r, and_assoc]
simp [node4_r, all_node', all, all_node3_r, and_assoc]
intros
rw [show f = id, from funext H]; exact id_map o
rw [show f = id, from funext H]
exact id_map o
intros
apply ext'; intro n; refl
apply ext'; intro n
apply ext'
intro n
refl
intros
induction n with n ih; [refl, rw [pow_succ', pow_succ, mul_coe, mul_comm, ih]]
induction n with n ih
refl
rw [pow_succ', pow_succ, mul_coe, mul_comm, ih]
intros
have := prod_of_pnat_multiset (l : multiset ℕ+) h
{ have := prod_of_pnat_multiset (l : multiset ℕ+) h, rw [multiset.coe_prod] at this, exact this }
rw [multiset.coe_prod] at this
exact this
intros
rw [coeff_X, if_neg hn.symm]
intros
rw ← finset.card_range (p.nat_degree + 1)
exact finset.card_le_of_subset supp_subset_range_nat_degree_succ
intros
by_cases hn : n = 0
rw [hn, pow_zero, ←C_1, ←ring_hom.map_sub, nat_degree_C]
{ rw [hn, pow_zero, ←C_1, ←ring_hom.map_sub, nat_degree_C] }
exact nat_degree_eq_of_degree_eq_some (degree_X_pow_sub_C (pos_iff_ne_zero.mpr hn) r)
{ exact nat_degree_eq_of_degree_eq_some (degree_X_pow_sub_C (pos_iff_ne_zero.mpr hn) r) }
intros
apply coeff_eq_zero_of_trailing_degree_lt
by_cases hp : p = 0
rw [hp, trailing_degree_zero]
{ rw [hp, trailing_degree_zero], exact with_top.coe_lt_top n, }
exact with_top.coe_lt_top n
rwa [trailing_degree_eq_nat_trailing_degree hp, with_top.coe_lt_coe]
{ rwa [trailing_degree_eq_nat_trailing_degree hp, with_top.coe_lt_coe] }
intros
induction k with k ih generalizing f
{ simp [nat.iterate], }
simp [nat.iterate]
{ simp [nat.iterate, ih], }
simp [nat.iterate, ih]
intros
intro
{ intro, simp [integral_normalization, coeff_monomial, mem_support_iff] {contextual := tt} }
simp [integral_normalization, coeff_monomial, mem_support_iff] {contextual := tt}
intros
obtain ⟨r, rfl⟩ := set.mem_range.1 h
use C r
simp only [coe_map_ring_hom, map_C, set.mem_univ, subsemiring.coe_top, eq_self_iff_true, and_self]
intros
simpa [sub_eq_add_neg] using monic_X_pow_add (show degree (-p) ≤ n, by rwa ←degree_neg p at H)
intros
set f' := f.comp (to_finsupp_iso R).symm.to_ring_hom with hf'
set g' := g.comp (to_finsupp_iso R).symm.to_ring_hom with hg'
have A : f' = g'
ext
{ ext, { simp [h₁, ring_equiv.to_ring_hom_eq_coe] }, { simpa [ring_equiv.to_ring_hom_eq_coe] using h₂, } }
{ simp [h₁, ring_equiv.to_ring_hom_eq_coe] }
simp [h₁, ring_equiv.to_ring_hom_eq_coe]
{ simpa [ring_equiv.to_ring_hom_eq_coe] using h₂, }
simpa [ring_equiv.to_ring_hom_eq_coe] using h₂
have B : f = f'.comp (to_finsupp_iso R)
rw [hf', ring_hom.comp_assoc]
rw [hf', ring_hom.comp_assoc]
{ rw [hf', ring_hom.comp_assoc], ext x, simp only [ring_equiv.to_ring_hom_eq_coe, ring_equiv.symm_apply_apply, function.comp_app, ring_hom.coe_comp, ring_equiv.coe_to_ring_hom] }
{ rw [hf', ring_hom.comp_assoc], ext x, simp only [ring_equiv.to_ring_hom_eq_coe, ring_equiv.symm_apply_apply, function.comp_app, ring_hom.coe_comp, ring_equiv.coe_to_ring_hom] }
ext x
ext x
simp only [ring_equiv.to_ring_hom_eq_coe, ring_equiv.symm_apply_apply, function.comp_app, ring_hom.coe_comp, ring_equiv.coe_to_ring_hom]
simp only [ring_equiv.to_ring_hom_eq_coe, ring_equiv.symm_apply_apply, function.comp_app, ring_hom.coe_comp, ring_equiv.coe_to_ring_hom]
have C : g = g'.comp (to_finsupp_iso R)
rw [hg', ring_hom.comp_assoc]
rw [hg', ring_hom.comp_assoc]
{ rw [hg', ring_hom.comp_assoc], ext x, simp only [ring_equiv.to_ring_hom_eq_coe, ring_equiv.symm_apply_apply, function.comp_app, ring_hom.coe_comp, ring_equiv.coe_to_ring_hom] }
{ rw [hg', ring_hom.comp_assoc], ext x, simp only [ring_equiv.to_ring_hom_eq_coe, ring_equiv.symm_apply_apply, function.comp_app, ring_hom.coe_comp, ring_equiv.coe_to_ring_hom] }
ext x
ext x
simp only [ring_equiv.to_ring_hom_eq_coe, ring_equiv.symm_apply_apply, function.comp_app, ring_hom.coe_comp, ring_equiv.coe_to_ring_hom]
simp only [ring_equiv.to_ring_hom_eq_coe, ring_equiv.symm_apply_apply, function.comp_app, ring_hom.coe_comp, ring_equiv.coe_to_ring_hom]
rw [B, C, A]
intros
rw root_multiplicity_eq_multiplicity
split_ifs
refl
{ refl }
rw [← enat.coe_inj, enat.coe_get, multiplicity.multiplicity_eq_zero_of_not_dvd, nat.cast_zero]
intro hdvd
exact h (dvd_iff_is_root.mp hdvd)
intros
split
intro h
{ intro h, have key : p.nat_degree = 0 ∨ q.nat_degree = 0, { rw [←mul_eq_zero, ←nat_degree_comp, h, nat_degree_zero] }, replace key := or.imp eq_C_of_nat_degree_eq_zero eq_C_of_nat_degree_eq_zero key, cases key, { rw [key, C_comp] at h, exact or.inl (key.trans h) }, { rw [key, comp_C, C_eq_zero] at h, exact or.inr ⟨h, key⟩ }, }
have key : p.nat_degree = 0 ∨ q.nat_degree = 0
{ rw [←mul_eq_zero, ←nat_degree_comp, h, nat_degree_zero] }
rw [←mul_eq_zero, ←nat_degree_comp, h, nat_degree_zero]
replace key := or.imp eq_C_of_nat_degree_eq_zero eq_C_of_nat_degree_eq_zero key
cases key
rw [key, C_comp] at h
{ rw [key, C_comp] at h, exact or.inl (key.trans h) }
exact or.inl (key.trans h)
rw [key, comp_C, C_eq_zero] at h
{ rw [key, comp_C, C_eq_zero] at h, exact or.inr ⟨h, key⟩ }
exact or.inr ⟨h, key⟩
exact λ h, or.rec (λ h, by rw [h, zero_comp]) (λ h, by rw [h.2, comp_C, h.1, C_0]) h
{ exact λ h, or.rec (λ h, by rw [h, zero_comp]) (λ h, by rw [h.2, comp_C, h.1, C_0]) h }
intros
rw [cofix.corec₁,cofix.dest_corec',← h]; refl
rw [cofix.corec₁,cofix.dest_corec',← h]
refl
intros
{ cases q₁, cases q₂, apply mk_pnat_denom_dvd }
cases q₁
cases q₂
apply mk_pnat_denom_dvd
intros
rw [(eq_sub_of_add_eq $ int.mod_add_div n d), rat.floor_int_div_nat_eq_div]
intros
simp [cantor_function_aux, h]
intros
simpa only [mul_comm] using infi_mul h
intros
{ simp only [mul_comm a], exact sub_mul h }
simp only [mul_comm a]
exact sub_mul h
have := nat.prime.irrational_sqrt (show nat.prime 5, by norm_num)
have := this.rat_sub 1
have := this.rat_mul (show (0.5 : ℚ) ≠ 0, by norm_num)
convert this
field_simp
intros
simp only [irrational, rat.forall, cast_mk, not_exists, set.mem_range, cast_coe_int, cast_div, eq_comm]
intros
rw [← nnreal.coe_lt_coe, real.coe_to_nnreal r ha]
intros
simp [nnabs]
intros
simp [sqrt, real.to_nnreal_eq_zero.2 h]
intros
rw [sq, sqrt_mul_self x]
intros
induction l; simp [*]
induction l
simp [*]
simp [*]
intros
simp only [subset_def, ← forall_and_distrib]
refine forall_congr (λ x, _)
by_cases hx : x ∈ t; simp [*, set.ite]
by_cases hx : x ∈ t
simp [*, set.ite]
simp [*, set.ite]
intros
simp
intros
ext ⟨x, y⟩
{ ext ⟨x, y⟩, simp [image, iff_def, or_imp_distrib, imp.swap] {contextual := tt} }
simp [image, iff_def, or_imp_distrib, imp.swap] {contextual := tt}
intros
simp [pi, or_imp_distrib, forall_and_distrib, set_of_and]
intros
ext
split
rintro ⟨_, ⟨a, b, ha, hb, rfl⟩, rfl⟩
{ rintro ⟨_, ⟨a, b, ha, hb, rfl⟩, rfl⟩, refine ⟨a, b, ha, hb, rfl⟩ }
refine ⟨a, b, ha, hb, rfl⟩
rintro ⟨a, b, ha, hb, rfl⟩
{ rintro ⟨a, b, ha, hb, rfl⟩, refine ⟨_, ⟨a, b, ha, hb, rfl⟩, rfl⟩ }
refine ⟨_, ⟨a, b, ha, hb, rfl⟩, rfl⟩
intros
haveI := (λ a, (ht a).to_encodable); rw Union_eq_range_sigma; apply countable_range
haveI := (λ a, (ht a).to_encodable); rw Union_eq_range_sigma
haveI := (λ a, (ht a).to_encodable)
rw Union_eq_range_sigma
apply countable_range
intros
rw ← bUnion_range
exact h.bUnion (λ y hy, y.finite_to_set)
intros
rwa [surj_on, ← H.image_eq]
intros
simp
intros
rw [← Iic_diff_right, diff_diff_cancel_left (singleton_subset_iff.2 right_mem_Iic)]
intros
ext1 x
simp_rw [mem_union, mem_Icc, mem_Ici, min_le_iff]
by_cases hc : c ≤ x
{ tauto }
tauto
have hxb : x ≤ b := (le_of_not_ge hc).trans h₁
{ have hxb : x ≤ b := (le_of_not_ge hc).trans h₁, tauto }
tauto
intros
simp [← Ioi_inter_Iio, inter_comm]
intros
simp
intros
simpa only [mul_comm] using preimage_mul_const_Iio_of_neg a h
intros
have : Ioc m (y i₀) = Ioi m ∩ Ioc (x i₀) (y i₀)
rw [← Ioi_inter_Iic, ← Ioi_inter_Iic, ← inter_assoc, inter_eq_self_of_subset_left (Ioi_subset_Ioi hm)]
rw [← Ioi_inter_Iic, ← Ioi_inter_Iic, ← inter_assoc, inter_eq_self_of_subset_left (Ioi_subset_Ioi hm)]
simp_rw [univ_pi_update i₀ _ _ (λ i z, Ioc z (y i)), ← pi_inter_compl ({i₀} : set ι), singleton_pi', ← inter_assoc, this]
refl
intros
simp only [← preimage_mul_const_interval ha, mul_comm]
intros
{ ext, simp }
ext
simp
intros
obtain ⟨x, m, -⟩ := exists_set_mem_of_union_eq_top t s w H.some
exact ⟨x, m⟩
intros
simp only [eq_univ_iff_forall, mem_sUnion]
intros
rw sup_eq_eqv_gen; refl
rw sup_eq_eqv_gen
refl
intros
classical
rw other_eq_other' at hb ⊢
convert other_invol' ha hb
rw other_eq_other'
intros
rw [nth_eq_nth_le]; exact list.nth_le_mem _ _ _
rw [nth_eq_nth_le]
exact list.nth_le_mem _ _ _
intros
cases v
cases v; refl
refl
intros
casesI n
{ exfalso, exact nat.not_lt_zero 0 (fact.out _) }
exfalso
exact nat.not_lt_zero 0 (fact.out _)
refl
intros
induction h
case in_closure.basic : a ha { existsi ([a]), simp [ha] }
existsi ([])
case in_closure.one { existsi ([]), simp }
simp
case in_closure.mul : a b _ _ ha hb { rcases ha with ⟨la, ha, eqa⟩, rcases hb with ⟨lb, hb, eqb⟩, existsi (la ++ lb), simp [eqa.symm, eqb.symm, or_imp_distrib], exact assume a, ⟨ha a, hb a⟩ }
intros
simpa only [h.comp_eq] using bij_on_fixed_pts_comp f g
intros
haveI := char_is_prime_of_pos R p
obtain ⟨a, b, hab⟩ := zmod.sq_add_sq p x
refine ⟨a.val, b.val, _⟩
simpa using congr_arg (zmod.cast_hom dvd_rfl R) hab
intros
obtain ⟨m, rfl⟩ := hf.2
use m
rw nat_degree_expand
intros
convert dim_mul_dim' F K A; rw lift_id
convert dim_mul_dim' F K A
rw lift_id
rw lift_id
rw lift_id
intros
{ convert dist_orthocenter_reflection_circumcenter _ h, simp }
convert dist_orthocenter_reflection_circumcenter _ h
simp
intros
{ simp only [chart, mem_prod], mfld_set_tac }
simp only [chart, mem_prod]
mfld_set_tac
intros
apply times_cont_mdiff_of_support (λ x hx, _)
have : x ∈ (chart_at H c).source
calc x ∈ closure (support (λ x, f x • g x)) : hx ... ⊆ closure (support f) : closure_mono (support_smul_subset_left _ _) ... ⊆ (chart_at _ c).source : f.closure_support_subset_chart_at_source
exact f.smooth_at.smul ((hg _ this).times_cont_mdiff_at $ is_open.mem_nhds (chart_at _ _).open_source this)
intros
split
assume x hx
{ assume x hx, simp only with mfld_simps at hx, exact ((he'.mdifferentiable_at hx.2).comp _ (he.mdifferentiable_at hx.1)).mdifferentiable_within_at }
simp only with mfld_simps at hx
exact ((he'.mdifferentiable_at hx.2).comp _ (he.mdifferentiable_at hx.1)).mdifferentiable_within_at
assume x hx
{ assume x hx, simp only with mfld_simps at hx, exact ((he.symm.mdifferentiable_at hx.2).comp _ (he'.symm.mdifferentiable_at hx.1)).mdifferentiable_within_at }
simp only with mfld_simps at hx
exact ((he.symm.mdifferentiable_at hx.2).comp _ (he'.symm.mdifferentiable_at hx.1)).mdifferentiable_within_at
intros
simp only [tangent_map_within] with mfld_simps
rw mfderiv_within_subset st hs h
intros
rw ext_chart_at_source
{ rw ext_chart_at_source, exact fs.mem_chart_at_source_of_eq_one h }
exact fs.mem_chart_at_source_of_eq_one h
intros
rw [ext_chart_at_map_nhds_within_eq_image' I x hy, nhds_within_inter, ← nhds_within_ext_chart_target_eq' _ _ hy, ← nhds_within_inter, (ext_chart_at I x).image_source_inter_eq', inter_comm]
intros
rw [times_cont_mdiff_within_at, lift_prop_within_at, times_cont_diff_within_at_prop]
congr' 3
mfld_set_tac
intros
ext
ext; refl
refl
intros
rw mk_eq_monoid_of_mk'_apply; exact mul_equiv_of_quotient_symm_mk' _ _
rw mk_eq_monoid_of_mk'_apply
exact mul_equiv_of_quotient_symm_mk' _ _
intros
rw mul_comm
show _ * (_ * _) = _ ↔ _
rw [←mul_assoc, mul_inv_left hg, mul_comm]
intros
simp [← order_of_of_add_eq_add_order_of, of_add_nsmul, order_of_pow'' _ n (is_of_fin_order_of_add_iff.mpr h)]
intros
{ convert iff.rfl, simp [is_periodic_pt_mul_iff_pow_eq_one] }
convert iff.rfl
simp [is_periodic_pt_mul_iff_pow_eq_one]
intros
suffices h : support (swap a b * swap a c) = {a, b, c}
rw [←card_support_eq_three_iff, h]
{ rw [←card_support_eq_three_iff, h], simp [ab, ac, bc] }
simp [ab, ac, bc]
apply le_antisymm ((support_mul_le _ _).trans (λ x, _)) (λ x hx, _)
{ simp [ab, ac, bc] }
simp [ab, ac, bc]
simp only [finset.mem_insert, finset.mem_singleton] at hx
{ simp only [finset.mem_insert, finset.mem_singleton] at hx, rw mem_support, simp only [perm.coe_mul, function.comp_app, ne.def], obtain rfl | rfl | rfl := hx, { rw [swap_apply_left, swap_apply_of_ne_of_ne ac.symm bc.symm], exact ac.symm }, { rw [swap_apply_of_ne_of_ne ab.symm bc, swap_apply_right], exact ab }, { rw [swap_apply_right, swap_apply_left], exact bc } }
rw mem_support
simp only [perm.coe_mul, function.comp_app, ne.def]
obtain rfl | rfl | rfl := hx
rw [swap_apply_left, swap_apply_of_ne_of_ne ac.symm bc.symm]
{ rw [swap_apply_left, swap_apply_of_ne_of_ne ac.symm bc.symm], exact ac.symm }
exact ac.symm
rw [swap_apply_of_ne_of_ne ab.symm bc, swap_apply_right]
{ rw [swap_apply_of_ne_of_ne ab.symm bc, swap_apply_right], exact ab }
exact ab
rw [swap_apply_right, swap_apply_left]
{ rw [swap_apply_right, swap_apply_left], exact bc }
exact bc
intros
refine ⟨λ h, _, λ h, by simpa using (is_cycle_cycle_of _ h).two_le_card_support⟩
contrapose! h
rw ←cycle_of_eq_one_iff at h
simp [h]
intros
rw [cycle_range_of_le h.le, if_neg h.ne]
intros
obtain ⟨n, rfl⟩ := h
exact (form_perm_rotate l hd n).symm
intros
simp [equiv.perm.extend_domain]
intros
rw [range_eq_map, ← set_like.coe_set_eq, coe_map, subgroup.coe_subtype]
{ rw [range_eq_map, ← set_like.coe_set_eq, coe_map, subgroup.coe_subtype], ext, simp }
ext
simp
intros
rw mem_direction_iff_eq_vsub ⟨p, hp⟩ at hv
rcases hv with ⟨p1, hp1, p2, hp2, hv⟩
rw hv
convert s.smul_vsub_vadd_mem 1 hp1 hp2 hp
rw one_smul
intros
conv_lhs { rw [vector_span_eq_span_vsub_set_right k (set.mem_image_of_mem p hi), ←set.insert_eq_of_mem hi, ←set.insert_diff_singleton, set.image_insert_eq, set.image_insert_eq] }
simp [submodule.span_insert_eq_span]
intros
rw sum_centroid_weights_indicator
exact s.sum_centroid_weights_eq_one_of_card_eq_add_one k h
intros
cases is_empty_or_nonempty ι with h h
haveI := h
{ haveI := h, apply affine_independent_of_subsingleton, }
apply affine_independent_of_subsingleton
obtain ⟨i⟩ := h
rw affine_independent_iff_linear_independent_vsub k p i
simp_rw [affine_independent_iff_linear_independent_vsub k (f ∘ p) i, function.comp_app, ← f.linear_map_vsub] at hai
exact linear_independent.of_comp f.linear hai
intros
rcases h₀.eq_or_lt with (rfl|h₀)
simpa
{ simpa }
exact (line_map_mono_left ha.le h₁).trans_lt (line_map_strict_mono_right hb h₀)
intros
apply σ.induction_on' (λ σ, _)
dsimp only [quotient.lift_on'_mk', quotient.map'_mk', mul_action.quotient.smul_mk, dom_coprod.summand]
rw [perm.sign_mul, perm.sign_swap hij]
simp only [one_mul, units.neg_mul, function.comp_app, units.neg_smul, perm.coe_mul, units.coe_neg, multilinear_map.smul_apply, multilinear_map.neg_apply, multilinear_map.dom_dom_congr_apply, multilinear_map.dom_coprod_apply]
convert add_right_neg _; { ext k, rw equiv.apply_swap_eq_self hv }
convert add_right_neg _
{ ext k, rw equiv.apply_swap_eq_self hv }
{ ext k, rw equiv.apply_swap_eq_self hv }
ext k
rw equiv.apply_swap_eq_self hv
intros
rw [←singleton_zero, span_singleton_eq_bot]
intros
rw [← map_top, of_le, linear_map.map_cod_restrict, map_top, range_subtype]
intros
obtain ⟨g, hg⟩ := hf.has_right_inverse
suffices : left_inverse (fun_left R M g) (fun_left R M f)
{ exact this.injective }
exact this.injective
intro x
rw [←linear_map.comp_apply, ← fun_left_comp, hg.id, fun_left_id]
intros
ext M
{ ext M, simp only [matrix.to_bilin_apply, matrix.to_bilin'_apply, pi.basis_fun_repr] }
simp only [matrix.to_bilin_apply, matrix.to_bilin'_apply, pi.basis_fun_repr]
intros
unfold linear_map.det
split_ifs with h
convert hb _ h.some_spec.some
{ convert hb _ h.some_spec.some, apply det_aux_def' }
apply det_aux_def'
{ exact h1 }
exact h1
intros
simp only [le_dim_iff_exists_linear_independent, cardinal.mk_eq_nat_iff_finset]
split
rintro ⟨s, ⟨t, rfl, rfl⟩, si⟩
{ rintro ⟨s, ⟨t, rfl, rfl⟩, si⟩, exact ⟨t, rfl, si⟩ }
exact ⟨t, rfl, si⟩
rintro ⟨s, rfl, si⟩
{ rintro ⟨s, rfl, si⟩, exact ⟨s, ⟨s, rfl, rfl⟩, si⟩ }
exact ⟨s, ⟨s, rfl, rfl⟩, si⟩
intros
rw [← b.to_dual_total_left, b.total_repr]
intros
rw [finrank_dual_annihilator_comap_eq, W.quot_equiv_annihilator.finrank_eq.symm, add_comm, submodule.finrank_quotient_add_finrank, subspace.dual_finrank_eq]
intros
{ rw ← algebra.top_to_submodule, refl }
rw ← algebra.top_to_submodule
refl
intros
have : module.rank K (ι → K) = fintype.card ι := dim_fun'
rwa [← finrank_eq_dim, nat_cast_inj] at this
intros
rw [range_eq_top, ker_eq_bot, injective_iff_surjective]
intros
ext l
ext l; simp [total_apply, finsupp.sum_map_domain_index, add_smul, h]
simp [total_apply, finsupp.sum_map_domain_index, add_smul, h]
intros
rw linear_independent_iff'' at hv ⊢
intros s g hgs hsum i
rw ← (w i).mul_left_eq_zero
refine hv s (λ i, g i • w i) (λ i hi, _) _ i
dsimp only
{ dsimp only, exact (hgs i hi).symm ▸ zero_smul _ _ }
exact (hgs i hi).symm ▸ zero_smul _ _
rw [← hsum, finset.sum_congr rfl _]
{ rw [← hsum, finset.sum_congr rfl _], intros, erw [pi.smul_apply, smul_assoc], refl }
intros
erw [pi.smul_apply, smul_assoc]
refl
intros
erw [sup_apply _ ⟨x', hx'⟩ ⟨c • x, _⟩, mk_span_singleton_apply]
refl
exact mem_span_singleton.2 ⟨c, rfl⟩
intros
simp only [charmatrix, sub_left_inj, pi.sub_apply, scalar_apply_eq, ring_hom.map_matrix_apply, map_apply, dmatrix.sub_apply]
intros
haveI : subsingleton n := fintype.card_le_one_iff_subsingleton.mp h.le
exact det_eq_elem_of_subsingleton _ _
intros
rw [← det_transpose, det_succ_row _ j]
{ rw [← det_transpose, det_succ_row _ j], refine finset.sum_congr rfl (λ i _, _), rw [add_comm, ← det_transpose, transpose_apply, transpose_minor, transpose_transpose] }
refine finset.sum_congr rfl (λ i _, _)
rw [add_comm, ← det_transpose, transpose_apply, transpose_minor, transpose_transpose]
intros
rw [cramer_apply, det_eq_elem_of_subsingleton _ i, update_column_self]
intros
{ ext, simp [linear_map.one_apply, std_basis_apply] }
ext
simp [linear_map.one_apply, std_basis_apply]
intros
simp_rw [linear_map.to_matrix_alg_equiv_apply, basis.reindex_range_self, basis.reindex_range_repr]
intros
simp [transvection, matrix.mul_add, mul_comm]
intros
simp [transvection]
intros
ext
ext; simp
simp
intros
rw eq_top_iff
rintro ⟨m, n⟩ -
rw [show (m, n) = (m, 0) + (0, n), by simp]
apply submodule.add_mem (submodule.fst R M M₂ ⊔ submodule.snd R M M₂)
exact submodule.mem_sup_left (submodule.mem_comap.mpr (by simp))
{ exact submodule.mem_sup_left (submodule.mem_comap.mpr (by simp)), }
exact submodule.mem_sup_right (submodule.mem_comap.mpr (by simp))
{ exact submodule.mem_sup_right (submodule.mem_comap.mpr (by simp)), }
intros
split
rintros x ⟨hpx, hfx⟩
{ rintros x ⟨hpx, hfx⟩, erw [set_like.mem_coe, mem_ker, hf ⟨x, hpx⟩, mk_eq_zero] at hfx, simp only [hfx, set_like.mem_coe, zero_mem] }
erw [set_like.mem_coe, mem_ker, hf ⟨x, hpx⟩, mk_eq_zero] at hfx
simp only [hfx, set_like.mem_coe, zero_mem]
intros x hx
{ intros x hx, rw [mem_sup'], refine ⟨f x, ⟨x - f x, _⟩, add_sub_cancel'_right _ _⟩, rw [mem_ker, linear_map.map_sub, hf, sub_self] }
rw [mem_sup']
refine ⟨f x, ⟨x - f x, _⟩, add_sub_cancel'_right _ _⟩
rw [mem_ker, linear_map.map_sub, hf, sub_self]
intros
simp [associated_apply, ←polar_to_quadratic_form, polar]
intros
ext
ext; simp
simp
intros
rw [uncurry, linear_map.flip_apply, lift.tmul]
rw [uncurry, linear_map.flip_apply, lift.tmul]; refl
refl
intros
by_cases h : P; simp [h]
{ by_cases h : P; simp [h] }
by_cases h : P
simp [h]
simp [h]
intros
{ subst h₁, subst h₂ }
subst h₁
subst h₂
intros
simp_rw [ennreal.tsum_eq_supr_sum]
{ simp_rw [ennreal.tsum_eq_supr_sum], apply ae_measurable_supr, exact λ s, finset.ae_measurable_sum s (λ i _, h i) }
apply ae_measurable_supr
exact λ s, finset.ae_measurable_sum s (λ i _, h i)
intros
apply measurable_of_Iio
simp_rw [← compl_Ici, preimage_compl, measurable_set.compl_iff]
assumption
intros
refine integral_congr_ae _
filter_upwards [hf.prod_right_ae, hg.prod_right_ae]
intros x h2f h2g
simp [integral_add h2f h2g]
intros
rw [← lintegral_indicator _ hA, ← lintegral_indicator f, ← lintegral_indicator g, ← lintegral_add]
refine lintegral_mono (λ a, _)
{ refine lintegral_mono (λ a, _), by_cases haA : a ∈ A, { by_cases f a ≤ g a, { simp only, rw [set.indicator_of_mem haA, set.indicator_of_mem, set.indicator_of_not_mem, add_zero], simp only [le_refl, max_le_iff, and_true, h], { rintro ⟨_, hc⟩, exact false.elim ((not_lt.2 h) hc) }, { exact ⟨haA, h⟩ } }, { simp only, rw [set.indicator_of_mem haA, set.indicator_of_mem _ f, set.indicator_of_not_mem, zero_add], simp only [true_and, le_refl, max_le_iff, le_of_lt (not_le.1 h)], { rintro ⟨_, hc⟩, exact false.elim (h hc) }, { exact ⟨haA, not_le.1 h⟩ } } }, { simp [set.indicator_of_not_mem haA] } }
by_cases haA : a ∈ A
by_cases f a ≤ g a
{ by_cases f a ≤ g a, { simp only, rw [set.indicator_of_mem haA, set.indicator_of_mem, set.indicator_of_not_mem, add_zero], simp only [le_refl, max_le_iff, and_true, h], { rintro ⟨_, hc⟩, exact false.elim ((not_lt.2 h) hc) }, { exact ⟨haA, h⟩ } }, { simp only, rw [set.indicator_of_mem haA, set.indicator_of_mem _ f, set.indicator_of_not_mem, zero_add], simp only [true_and, le_refl, max_le_iff, le_of_lt (not_le.1 h)], { rintro ⟨_, hc⟩, exact false.elim (h hc) }, { exact ⟨haA, not_le.1 h⟩ } } }
simp only
{ simp only, rw [set.indicator_of_mem haA, set.indicator_of_mem, set.indicator_of_not_mem, add_zero], simp only [le_refl, max_le_iff, and_true, h], { rintro ⟨_, hc⟩, exact false.elim ((not_lt.2 h) hc) }, { exact ⟨haA, h⟩ } }
rw [set.indicator_of_mem haA, set.indicator_of_mem, set.indicator_of_not_mem, add_zero]
simp only [le_refl, max_le_iff, and_true, h]
rintro ⟨_, hc⟩
{ rintro ⟨_, hc⟩, exact false.elim ((not_lt.2 h) hc) }
exact false.elim ((not_lt.2 h) hc)
exact ⟨haA, h⟩
{ exact ⟨haA, h⟩ }
simp only
{ simp only, rw [set.indicator_of_mem haA, set.indicator_of_mem _ f, set.indicator_of_not_mem, zero_add], simp only [true_and, le_refl, max_le_iff, le_of_lt (not_le.1 h)], { rintro ⟨_, hc⟩, exact false.elim (h hc) }, { exact ⟨haA, not_le.1 h⟩ } }
rw [set.indicator_of_mem haA, set.indicator_of_mem _ f, set.indicator_of_not_mem, zero_add]
simp only [true_and, le_refl, max_le_iff, le_of_lt (not_le.1 h)]
rintro ⟨_, hc⟩
{ rintro ⟨_, hc⟩, exact false.elim (h hc) }
exact false.elim (h hc)
exact ⟨haA, not_le.1 h⟩
{ exact ⟨haA, not_le.1 h⟩ }
{ simp [set.indicator_of_not_mem haA] }
simp [set.indicator_of_not_mem haA]
exact measurable.indicator hg.1 (hA.inter (measurable_set_le hf.1 hg.1))
{ exact measurable.indicator hg.1 (hA.inter (measurable_set_le hf.1 hg.1)) }
exact measurable.indicator hf.1 (hA.inter (measurable_set_lt hg.1 hf.1))
{ exact measurable.indicator hf.1 (hA.inter (measurable_set_lt hg.1 hf.1)) }
{ exact hA.inter (measurable_set_le hf.1 hg.1) }
exact hA.inter (measurable_set_le hf.1 hg.1)
{ exact hA.inter (measurable_set_lt hg.1 hf.1) }
exact hA.inter (measurable_set_lt hg.1 hf.1)
intros
simp only [condexp_ind_L1, and.intro hs hμs, dif_pos, ne.def, not_false_iff, and_self]
intros
have F_le_bound := all_ae_of_real_F_le_bound h_bound
rw ← ae_all_iff at F_le_bound
apply F_le_bound.mp ((all_ae_tendsto_of_real_norm h_lim).mono _)
assume a tendsto_norm F_le_bound
exact le_of_tendsto' tendsto_norm (F_le_bound)
intros
obtain ⟨hf_meas_ae, hf⟩ := hf_int
refine ⟨ae_measurable_of_ae_measurable_trim hm hf_meas_ae, _⟩
rw has_finite_integral at hf ⊢
rwa lintegral_trim_ae hm _ at hf
exact @ae_measurable.coe_nnreal_ennreal α m _ _ (@ae_measurable.nnnorm H α _ _ _ m _ _ hf_meas_ae)
intros
ext1
refine (coe_fn_comp_Lp' (L + L') f).trans _
refine eventually_eq.trans _ (Lp.coe_fn_add _ _).symm
refine eventually_eq.trans _ (eventually_eq.add (L.coe_fn_comp_Lp' f).symm (L'.coe_fn_comp_Lp' f).symm)
refine eventually_of_forall (λ x, _)
refl
intros
convert snorm_zero
intros
rw [snorm', lintegral_smul_measure, ennreal.mul_rpow_of_nonneg, snorm']
{ rw [snorm', lintegral_smul_measure, ennreal.mul_rpow_of_nonneg, snorm'], simp [hp], }
simp [hp]
intros
apply simple_func.uniform_embedding.dense_embedding
assume f
rw mem_closure_iff_seq_limit
have hfi' : mem_ℒp f p μ := Lp.mem_ℒp f
refine ⟨λ n, ↑(to_Lp (simple_func.approx_on f (Lp.measurable f) univ 0 trivial n) (simple_func.mem_ℒp_approx_on_univ (Lp.measurable f) hfi' n)), λ n, mem_range_self _, _⟩
convert simple_func.tendsto_approx_on_univ_Lp hp_ne_top (Lp.measurable f) hfi'
rw to_Lp_coe_fn f (Lp.mem_ℒp f)
intros
rcases l with ⟨l⟩
{ rcases l with ⟨l⟩, simpa using l.measurable_prod' (by simpa using hl) }
simpa using l.measurable_prod' (by simpa using hl)
intros
simp_rw [mul_comm, lintegral_const_mul' r f hr]
intros
rw [← lintegral_add_measure, measure.restrict_add_restrict_compl hA]
intros
rw [restrict_lintegral_eq_lintegral_restrict _ hs, const_lintegral_restrict]
intros
ext1
refine (ae_restrict_of_ae (Lp.coe_fn_add f g)).mp _
refine (Lp.coe_fn_add (mem_ℒp.to_Lp f ((Lp.mem_ℒp f).restrict s)) (mem_ℒp.to_Lp g ((Lp.mem_ℒp g).restrict s))).mp _
refine (mem_ℒp.coe_fn_to_Lp ((Lp.mem_ℒp f).restrict s)).mp _
refine (mem_ℒp.coe_fn_to_Lp ((Lp.mem_ℒp g).restrict s)).mp _
refine (mem_ℒp.coe_fn_to_Lp ((Lp.mem_ℒp (f+g)).restrict s)).mono (λ x hx1 hx2 hx3 hx4 hx5, _)
rw [hx4, hx1, pi.add_apply, hx2, hx3, hx5, pi.add_apply]
intros
casesI is_empty_or_nonempty β
{ exact measurable_of_empty f }
exact measurable_of_empty f
convert measurable_const
{ convert measurable_const, exact funext (λ x, hf x h.some) }
exact funext (λ x, hf x h.some)
intros
have := μ.sup_disjoint' ⊥ ⊥
simpa [apply_eq_coe_to_fun] using this
intros
let eval : (compacts G → ℝ) → ℝ := λ f, f ⊥
have : continuous eval := continuous_apply ⊥
show chaar K₀ ∈ eval ⁻¹' {(0 : ℝ)}
apply mem_of_subset_of_mem _ (chaar_mem_cl_prehaar K₀ ⟨set.univ, is_open_univ, mem_univ _⟩)
unfold cl_prehaar
rw is_closed.closure_subset_iff
rintro _ ⟨U, ⟨h1U, h2U, h3U⟩, rfl⟩
{ rintro _ ⟨U, ⟨h1U, h2U, h3U⟩, rfl⟩, apply prehaar_empty }
apply prehaar_empty
apply continuous_iff_is_closed.mp this
{ apply continuous_iff_is_closed.mp this, exact is_closed_singleton }
exact is_closed_singleton
intros
rw [add_haar_closed_ball' μ x hr, add_haar_closed_unit_ball_eq_add_haar_unit_ball]
intros
simp only [ae_iff, ← compl_set_of, restrict_apply hp.compl]
congr' with x
simp [and_comm]
intros
simp [← restrictₗ_apply, restrictₗ, ht]
intros
rw is_caratheodory_iff_le
split
{ intros h t ht, exact h t }
intros h t ht
exact h t
intros h u
{ intros h u, conv_rhs { rw induced_outer_measure_eq_infi _ msU m_mono }, refine le_infi _, intro t, refine le_infi _, intro ht, refine le_infi _, intro h2t, refine le_trans _ (le_trans (h t ht) $ le_of_eq $ induced_outer_measure_eq' _ msU m_mono ht), refine add_le_add (mono' _ $ set.inter_subset_inter_left _ h2t) (mono' _ $ diff_subset_diff_left h2t) }
conv_rhs { rw induced_outer_measure_eq_infi _ msU m_mono }
refine le_infi _
intro t
refine le_infi _
intro ht
refine le_infi _
intro h2t
refine le_trans _ (le_trans (h t ht) $ le_of_eq $ induced_outer_measure_eq' _ msU m_mono ht)
refine add_le_add (mono' _ $ set.inter_subset_inter_left _ h2t) (mono' _ $ diff_subset_diff_left h2t)
intros
refine restrict_le_restrict_of_subset_le v w (λ a ha₁ ha₂, _)
have ha₃ : (⋃ n, a ∩ disjointed f n) = a
rwa [← inter_Union, Union_disjointed, inter_eq_left_iff_subset]
{ rwa [← inter_Union, Union_disjointed, inter_eq_left_iff_subset] }
have ha₄ : pairwise (disjoint on (λ n, a ∩ disjointed f n))
exact (disjoint_disjointed _).mono (λ i j, disjoint.mono inf_le_right inf_le_right)
{ exact (disjoint_disjointed _).mono (λ i j, disjoint.mono inf_le_right inf_le_right) }
rw [← ha₃, v.of_disjoint_Union_nat _ ha₄, w.of_disjoint_Union_nat _ ha₄]
refine tsum_le_tsum (λ n, (restrict_le_restrict_iff v w (hf₁ n)).1 (hf₂ n) _ _) _ _
{ exact (ha₁.inter (measurable_set.disjointed hf₁ n)) }
exact (ha₁.inter (measurable_set.disjointed hf₁ n))
{ exact ha₁.inter (measurable_set.disjointed hf₁ n) }
exact ha₁.inter (measurable_set.disjointed hf₁ n)
{ exact ha₁.inter (measurable_set.disjointed hf₁ n) }
exact ha₁.inter (measurable_set.disjointed hf₁ n)
exact set.subset.trans (set.inter_subset_right _ _) (disjointed_subset _ _)
{ exact set.subset.trans (set.inter_subset_right _ _) (disjointed_subset _ _) }
refine (v.m_Union (λ n, _) _).summable
{ refine (v.m_Union (λ n, _) _).summable, { exact ha₁.inter (measurable_set.disjointed hf₁ n) }, { exact (disjoint_disjointed _).mono (λ i j, disjoint.mono inf_le_right inf_le_right) } }
{ exact (ha₁.inter (measurable_set.disjointed hf₁ n)) }
exact (ha₁.inter (measurable_set.disjointed hf₁ n))
{ exact ha₁.inter (measurable_set.disjointed hf₁ n) }
exact ha₁.inter (measurable_set.disjointed hf₁ n)
{ exact ha₁.inter (measurable_set.disjointed hf₁ n) }
exact ha₁.inter (measurable_set.disjointed hf₁ n)
exact (disjoint_disjointed _).mono (λ i j, disjoint.mono inf_le_right inf_le_right)
{ exact (disjoint_disjointed _).mono (λ i j, disjoint.mono inf_le_right inf_le_right) }
exact (disjoint_disjointed _).mono (λ i j, disjoint.mono inf_le_right inf_le_right)
{ exact (disjoint_disjointed _).mono (λ i j, disjoint.mono inf_le_right inf_le_right) }
refine (w.m_Union (λ n, _) _).summable
{ refine (w.m_Union (λ n, _) _).summable, { exact ha₁.inter (measurable_set.disjointed hf₁ n) }, { exact (disjoint_disjointed _).mono (λ i j, disjoint.mono inf_le_right inf_le_right) } }
{ exact (ha₁.inter (measurable_set.disjointed hf₁ n)) }
exact (ha₁.inter (measurable_set.disjointed hf₁ n))
{ exact ha₁.inter (measurable_set.disjointed hf₁ n) }
exact ha₁.inter (measurable_set.disjointed hf₁ n)
{ exact ha₁.inter (measurable_set.disjointed hf₁ n) }
exact ha₁.inter (measurable_set.disjointed hf₁ n)
exact (disjoint_disjointed _).mono (λ i j, disjoint.mono inf_le_right inf_le_right)
{ exact (disjoint_disjointed _).mono (λ i j, disjoint.mono inf_le_right inf_le_right) }
exact (disjoint_disjointed _).mono (λ i j, disjoint.mono inf_le_right inf_le_right)
{ exact (disjoint_disjointed _).mono (λ i j, disjoint.mono inf_le_right inf_le_right) }
intro n
{ intro n, exact (ha₁.inter (measurable_set.disjointed hf₁ n)) }
exact λ n, ha₁.inter (measurable_set.disjointed hf₁ n)
{ exact λ n, ha₁.inter (measurable_set.disjointed hf₁ n) }
exact (ha₁.inter (measurable_set.disjointed hf₁ n))
intro n
{ intro n, exact (ha₁.inter (measurable_set.disjointed hf₁ n)) }
exact λ n, ha₁.inter (measurable_set.disjointed hf₁ n)
{ exact λ n, ha₁.inter (measurable_set.disjointed hf₁ n) }
exact (ha₁.inter (measurable_set.disjointed hf₁ n))
intros
{ ext, simp, }
ext
simp
simp [card_factors]
ext
{ ext, simp }
simp
intros
apply is_coprime.mul_right (int.coprime_of_sq_sum (is_coprime_comm.mp h))
rw add_comm
apply int.coprime_of_sq_sum h
intros
rw [← norm_int_le_pow_iff_dvd, norm_le_pow_iff_mem_span_pow, ideal.mem_span_singleton]
intros
apply @nat.cast_injective ℤ
push_cast
exact padic_val_rat.pow _ (cast_ne_zero.mpr hq)
intros
simp [cast_eq_of_rat]
intros
cases int.mod_two_eq_zero_or_one x with hx hx
cases int.mod_two_eq_zero_or_one x with hx hx; cases int.mod_two_eq_zero_or_one y with hy hy
cases int.mod_two_eq_zero_or_one y with hy hy
exfalso
{ exfalso, apply nat.not_coprime_of_dvd_of_dvd (dec_trivial : 1 < 2) _ _ hc, { apply int.dvd_nat_abs_of_of_nat_dvd, apply int.dvd_of_mod_eq_zero hx }, { apply int.dvd_nat_abs_of_of_nat_dvd, apply int.dvd_of_mod_eq_zero hy } }
apply nat.not_coprime_of_dvd_of_dvd (dec_trivial : 1 < 2) _ _ hc
{ apply int.dvd_nat_abs_of_of_nat_dvd, apply int.dvd_of_mod_eq_zero hx }
apply int.dvd_nat_abs_of_of_nat_dvd
apply int.dvd_of_mod_eq_zero hx
{ apply int.dvd_nat_abs_of_of_nat_dvd, apply int.dvd_of_mod_eq_zero hy }
apply int.dvd_nat_abs_of_of_nat_dvd
apply int.dvd_of_mod_eq_zero hy
{ left, exact ⟨hx, hy⟩ }
left
exact ⟨hx, hy⟩
cases int.mod_two_eq_zero_or_one y with hy hy
{ right, exact ⟨hx, hy⟩ }
right
exact ⟨hx, hy⟩
exfalso
{ exfalso, obtain ⟨x0, y0, rfl, rfl⟩ : ∃ x0 y0, x = x0* 2 + 1 ∧ y = y0 * 2 + 1, { cases exists_eq_mul_left_of_dvd (int.dvd_sub_of_mod_eq hx) with x0 hx2, cases exists_eq_mul_left_of_dvd (int.dvd_sub_of_mod_eq hy) with y0 hy2, rw sub_eq_iff_eq_add at hx2 hy2, exact ⟨x0, y0, hx2, hy2⟩ }, apply int.sq_ne_two_mod_four z, rw show z * z = 4 * (x0 * x0 + x0 + y0 * y0 + y0) + 2, by { rw ← h.eq, ring }, norm_num [int.add_mod] }
obtain ⟨x0, y0, rfl, rfl⟩ : ∃ x0 y0, x = x0* 2 + 1 ∧ y = y0 * 2 + 1
cases exists_eq_mul_left_of_dvd (int.dvd_sub_of_mod_eq hx) with x0 hx2
{ cases exists_eq_mul_left_of_dvd (int.dvd_sub_of_mod_eq hx) with x0 hx2, cases exists_eq_mul_left_of_dvd (int.dvd_sub_of_mod_eq hy) with y0 hy2, rw sub_eq_iff_eq_add at hx2 hy2, exact ⟨x0, y0, hx2, hy2⟩ }
cases exists_eq_mul_left_of_dvd (int.dvd_sub_of_mod_eq hy) with y0 hy2
rw sub_eq_iff_eq_add at hx2 hy2
exact ⟨x0, y0, hx2, hy2⟩
apply int.sq_ne_two_mod_four z
rw show z * z = 4 * (x0 * x0 + x0 + y0 * y0 + y0) + 2, by { rw ← h.eq, ring }
norm_num [int.add_mod]
intros
ext ⟨x_re, x_im⟩
simp [decompose, h]
intros
rw [infi_insert, infi_singleton]
intros
{ contrapose! h, exact csupr_le' h }
contrapose! h
exact csupr_le' h
intros
{ rw ← prod_at_bot_at_bot_eq, exact hf.prod_map_prod_at_bot hg, }
rw ← prod_at_bot_at_bot_eq
exact hf.prod_map_prod_at_bot hg
intros
simp only [← principal_singleton, has_basis_principal]
intros
simpa using (eventually_eq.sub (eventually_eq.refl l f) h).symm
intros
rw [← image_mem_map_iff inj, map_comap_of_mem large]
intros
rw [tendsto, tendsto, map_congr hl]
intros
simp only [filter.prod, comap_inf, inf_comm, inf_assoc, inf_left_comm]
intros
simp only [le_antisymm_iff, le_principal_iff, mem_principal]
simp only [le_antisymm_iff, le_principal_iff, mem_principal]; refl
refl
intros
lift s to finset ι using hs
exact_mod_cast infi_principal_finset s f
intros
refine hle.mp (h.mono $ λ x hf hgf, _)
rw ← hfga
exact le_trans hgf hf
intros
refine ⟨λ t, (hf.mem_lift_iff hg gm).trans _⟩
simp [sigma.exists, and_assoc, exists_and_distrib_left]
intros
simpa only [tendsto_iff_comap] using le_iff_ultrafilter
intros
simp [is_bounded, exists_true_iff_nonempty]
intros
simp only [seq_eq_bind_map]; apply bind_continuous' _ _ hf; apply pi.omega_complete_partial_order.flip₂_continuous'; intro; apply map_continuous' _ _ hg
simp only [seq_eq_bind_map]; apply bind_continuous' _ _ hf; apply pi.omega_complete_partial_order.flip₂_continuous'; intro
simp only [seq_eq_bind_map]; apply bind_continuous' _ _ hf; apply pi.omega_complete_partial_order.flip₂_continuous'
simp only [seq_eq_bind_map]; apply bind_continuous' _ _ hf
simp only [seq_eq_bind_map]
apply bind_continuous' _ _ hf
apply pi.omega_complete_partial_order.flip₂_continuous'
intro
apply map_continuous' _ _ hg
intros
exactI {..f.is_irrefl, ..f.is_trans}
intros
simp [is_wf, well_founded_on_iff]
intros
ext ⟨a1, a2⟩
rw [mem_mul_antidiagonal, finset.mem_singleton, prod.ext_iff]
split
rintro ⟨hast, has, hat⟩
{ rintro ⟨hast, has, hat⟩, cases eq_or_lt_of_le (hs.min_le hns has) with heq hlt, { refine ⟨heq.symm, _⟩, rw heq at hast, exact mul_left_cancel hast }, { contrapose hast, exact ne_of_gt (mul_lt_mul_of_lt_of_le hlt (ht.min_le hnt hat)) } }
cases eq_or_lt_of_le (hs.min_le hns has) with heq hlt
refine ⟨heq.symm, _⟩
{ refine ⟨heq.symm, _⟩, rw heq at hast, exact mul_left_cancel hast }
rw heq at hast
exact mul_left_cancel hast
contrapose hast
{ contrapose hast, exact ne_of_gt (mul_lt_mul_of_lt_of_le hlt (ht.min_le hnt hat)) }
exact ne_of_gt (mul_lt_mul_of_lt_of_le hlt (ht.min_le hnt hat))
rintro ⟨ha1, ha2⟩
{ rintro ⟨ha1, ha2⟩, rw [ha1, ha2], exact ⟨rfl, hs.min_mem _, ht.min_mem _⟩ }
rw [ha1, ha2]
exact ⟨rfl, hs.min_mem _, ht.min_mem _⟩
intros
apply_instance
intros
{ rw add_comm at h, exact h.of_add_mul_left_right }
rw add_comm at h
exact h.of_add_mul_left_right
intros
rw [← coeff_zero_eq_eval_zero, ← eq_zero_iff_mem, ← coeff_map, coeff_zero_eq_eval_zero, hq, eval_mul, eval_pow, eval_X, zero_pow hn0, mul_zero]
intros
obtain ⟨S, hS⟩ := h
unfreezingI { obtain ⟨S, hS⟩ := h }
letI : decidable_eq M := classical.dec_eq M
use finset.bUnion S (λ f, f.support)
have : (finset.bUnion S (λ f, f.support) : set M) = ⋃ f ∈ S, (f.support : set M)
{ simp only [finset.set_bUnion_coe, finset.coe_bUnion] }
simp only [finset.set_bUnion_coe, finset.coe_bUnion]
rw [this]
exact support_gen_of_gen' hS
intros
rw [add_val_apply_of_ne (ne_zero_of_coeff_ne_zero h), with_top.coe_le_coe]
exact order_le_of_coeff_ne_zero h
intros
{ ext, simp [emb_domain_notin_image_support] }
ext
simp [emb_domain_notin_image_support]
intros
rintros ⟨u, hu⟩
apply hy
suffices : is_unit ((↑u⁻¹ : R) * y)
rcases this with ⟨s, hs⟩
{ rcases this with ⟨s, hs⟩, use u * s, convert congr_arg (λ z, (u : R) * z) hs, rw ← mul_assoc, simp }
use u * s
convert congr_arg (λ z, (u : R) * z) hs
rw ← mul_assoc
simp
rw show (↑u⁻¹ * y) = (1 - ↑u⁻¹ * x), { rw eq_sub_iff_add_eq, replace hu := congr_arg (λ z, (↑u⁻¹ : R) * z) hu.symm, simpa [mul_add, add_comm] using hu }
apply is_unit_one_sub_self_of_mem_nonunits
exact mul_mem_nonunits_right hx
intros
rw [finite_int_iff_nat_abs_finite, finite_nat_iff, pos_iff_ne_zero, int.nat_abs_ne_zero]
intros
rcases hx with ⟨p, pmonic, hp⟩
let S : set B := ↑(p.map $ algebra_map A B).frange
refine is_integral_of_mem_of_fg (adjoin R (S ∪ {x})) _ _ (subset_adjoin $ or.inr rfl)
refine fg_trans (fg_adjoin_of_finite (finset.finite_to_set _) (λ x hx, _)) _
rw [finset.mem_coe, frange, finset.mem_image] at hx
{ rw [finset.mem_coe, frange, finset.mem_image] at hx, rcases hx with ⟨i, _, rfl⟩, rw coeff_map, exact is_integral_alg_hom (is_scalar_tower.to_alg_hom R A B) (A_int _) }
rcases hx with ⟨i, _, rfl⟩
rw coeff_map
exact is_integral_alg_hom (is_scalar_tower.to_alg_hom R A B) (A_int _)
apply fg_adjoin_singleton_of_integral
{ apply fg_adjoin_singleton_of_integral, exact is_integral_trans_aux _ pmonic hp }
exact is_integral_trans_aux _ pmonic hp
intros
rw [sub_eq_add_neg, multiplicity_add_of_gt]; rwa [multiplicity.neg]
rw [sub_eq_add_neg, multiplicity_add_of_gt]
{ rw [sub_eq_add_neg, multiplicity_add_of_gt]; rwa [multiplicity.neg] }
rwa [multiplicity.neg]
rwa [multiplicity.neg]
intros
{ rw h_comm.eq, exact h_comm.symm.is_nilpotent_mul_left h, }
rw h_comm.eq
exact h_comm.symm.is_nilpotent_mul_left h
intros
simp_rw [monic, leading_coeff, nat_degree_to_subring, ← coeff_to_subring p T hp]
exact ⟨λ H, by { rw H, refl }, λ H, subtype.coe_injective H⟩
intros
cases n
{ simp [bernstein_polynomial], }
simp [bernstein_polynomial]
{ apply derivative_succ_aux, }
apply derivative_succ_aux
intros
apply homogeneous_component_eq_zero'
rw [total_degree, finset.sup_lt_iff] at h
{ intros d hd, exact ne_of_lt (h d hd), }
intros d hd
exact ne_of_lt (h d hd)
{ exact lt_of_le_of_lt (nat.zero_le _) h, }
exact lt_of_le_of_lt (nat.zero_le _) h
intros
{ intro, simpa using left_ne_zero_of_mul }
intro
simpa using left_ne_zero_of_mul
intros
assume k
contrapose
simp only [not_mem_support_iff]
assume hk
rw [← mat_poly_equiv_coeff_apply, hk]
refl
intros
simp
intros
induction n using enat.cases_on
rw order_eq_top
{ rw order_eq_top, split, { rintro rfl, split; intros, { exfalso, exact enat.coe_ne_top ‹_› ‹_› }, { exact (coeff _ _).map_zero } }, { rintro ⟨h₁, h₂⟩, ext i, exact h₂ i (enat.coe_lt_top i) } }
split
rintro rfl
{ rintro rfl, split; intros, { exfalso, exact enat.coe_ne_top ‹_› ‹_› }, { exact (coeff _ _).map_zero } }
split
split; intros
intros
{ exfalso, exact enat.coe_ne_top ‹_› ‹_› }
exfalso
exact enat.coe_ne_top ‹_› ‹_›
intros
{ exact (coeff _ _).map_zero }
exact (coeff _ _).map_zero
{ rintro ⟨h₁, h₂⟩, ext i, exact h₂ i (enat.coe_lt_top i) }
rintro ⟨h₁, h₂⟩
ext i
exact h₂ i (enat.coe_lt_top i)
{ simpa [enat.coe_inj] using order_eq_nat }
simpa [enat.coe_inj] using order_eq_nat
intros
have : ¬single s 1 ≤ 0
from λ h, by simpa using h s
simp only [X, coeff_mul_monomial, if_neg this]
intros
simp only [exp_pow_eq_rescale_exp, rescale]
ext
simp only [one_div, coeff_mk, coe_mk, coeff_exp, factorial, linear_map.map_sum]
intros
{ ext, simp [base_change_eq_ltensor], }
ext
simp [base_change_eq_ltensor]
intros
simp
intros
map_fun_tac
intros
ext1 n
apply mv_polynomial.map_injective (int.cast_ring_hom ℚ) int.cast_injective
rw ← function.funext_iff at h
replace h := congr_arg (λ fam, bind₁ (mv_polynomial.map (int.cast_ring_hom ℚ) ∘ fam) (X_in_terms_of_W p ℚ n)) h
simpa only [function.comp, map_bind₁, map_witt_polynomial, ← bind₁_bind₁, bind₁_witt_polynomial_X_in_terms_of_W, bind₁_X_right] using h
intros
apply mv_polynomial.map_injective (int.cast_ring_hom ℚ) int.cast_injective
simp only [map_rename, map_witt_structure_int, witt_structure_rat, rename_bind₁, rename_rename, bind₁_rename]
refl
intros
rcases le_mk_iff_exists_set.1 hθ with ⟨s, rfl⟩
cases infinite_pigeonhole (f ∘ subtype.val : s → α) h₁ h₂ with a ha
use a
rw [←ha, @preimage_comp _ _ _ subtype.val f]
apply mk_preimage_of_injective _ _ subtype.val_injective
intros
change ⟦(y + -z) * x⟧ = ⟦y * x⟧ + -⟦z * x⟧
{ change ⟦(y + -z) * x⟧ = ⟦y * x⟧ + -⟦z * x⟧, rw [quot_right_distrib, quot_neg_mul] }
rw [quot_right_distrib, quot_neg_mul]
intros
unfold collapse_F
rw well_founded.fix_eq
exact well_founded.not_lt_min _ _ _ (show b ∈ {b | ∀ a' (h : r a' a), s (collapse_F f a').1 b}, from h)
intros
rw [lt_def_le]
conv { to_lhs, simp only [le_def_lt] }
intros
cases x with xl xr xL xR
exact o.2.1 i
intros
have ae := ext_iff.2 H
simp [pair] at ae
have : x = x'
cases (ae {x}).1 (by simp) with h h
{ cases (ae {x}).1 (by simp) with h h, { exact singleton_inj h }, { have m : x' ∈ ({x} : Set), { rw h, simp }, simp at m, simp [*] } }
{ exact singleton_inj h }
exact singleton_inj h
have m : x' ∈ ({x} : Set)
{ have m : x' ∈ ({x} : Set), { rw h, simp }, simp at m, simp [*] }
{ rw h, simp }
rw h
simp
simp at m
simp [*]
subst x'
have he : y = x → y = y'
intro yx
{ intro yx, subst y, cases (ae {x, y'}).2 (by simp only [eq_self_iff_true, or_true]) with xy'x xy'xx, { rw [eq_comm, ←mem_singleton, ←xy'x, mem_pair], exact or.inr rfl }, { have yxx := (ext_iff.2 xy'xx y').1 (by simp), simp at yxx, subst y' } }
subst y
cases (ae {x, y'}).2 (by simp only [eq_self_iff_true, or_true]) with xy'x xy'xx
rw [eq_comm, ←mem_singleton, ←xy'x, mem_pair]
{ rw [eq_comm, ←mem_singleton, ←xy'x, mem_pair], exact or.inr rfl }
exact or.inr rfl
have yxx := (ext_iff.2 xy'xx y').1 (by simp)
{ have yxx := (ext_iff.2 xy'xx y').1 (by simp), simp at yxx, subst y' }
simp at yxx
subst y'
have xyxy' := (ae {x, y}).1 (by simp)
cases xyxy' with xyx xyy'
have yx := (ext_iff.2 xyx y).1 (by simp)
{ have yx := (ext_iff.2 xyx y).1 (by simp), simp at yx, simp [he yx] }
simp at yx
simp [he yx]
have yxy' := (ext_iff.2 xyy' y).1 (by simp)
{ have yxy' := (ext_iff.2 xyy' y).1 (by simp), simp at yxy', cases yxy' with yx yy', { simp [he yx] }, { simp [yy'] } }
simp at yxy'
cases yxy' with yx yy'
{ simp [he yx] }
simp [he yx]
{ simp [yy'] }
simp [yy']
intros
simp *
intros
rw [← h, ← hm, nat.add_mul_div_right _ _ (lt_of_le_of_lt (nat.zero_le _) h₂), nat.div_eq_of_lt h₂, zero_add]
intros
suffices : tendsto (range_factorization f) at_top at_top
from (Sup_convergence_class.tendsto_coe_at_top_is_lub _ _ ha).comp this
exact h_mono.range_factorization.tendsto_at_top_at_top (λ b, b.2.imp $ λ a ha, ha.ge)
intros
simp only [continuous_within_at, nhds_within_Ioc_eq_nhds_within_Ioi h]
intros
simp [nhds_eq_order (⊥:α)]
intros
convert (is_topological_basis_pi cond).inducing (inducing_infi_to_pi _)
ext V
split
rintros ⟨U, F, h1, h2⟩
{ rintros ⟨U, F, h1, h2⟩, have : (F : set ι).pi U = (⋂ (i : ι) (hi : i ∈ F), (λ (z : Π j, X j), z i) ⁻¹' (U i)), by { ext, simp }, refine ⟨(F : set ι).pi U, ⟨U, F, h1, rfl⟩, _⟩, rw [this, h2, set.preimage_Inter], congr' 1, ext1, rw set.preimage_Inter, refl }
have : (F : set ι).pi U = (⋂ (i : ι) (hi : i ∈ F), (λ (z : Π j, X j), z i) ⁻¹' (U i))
ext
ext
{ ext, simp }
{ ext, simp }
simp
simp
refine ⟨(F : set ι).pi U, ⟨U, F, h1, rfl⟩, _⟩
rw [this, h2, set.preimage_Inter]
congr' 1
ext1
rw set.preimage_Inter
refl
rintros ⟨U, ⟨U, F, h1, rfl⟩, h⟩
{ rintros ⟨U, ⟨U, F, h1, rfl⟩, h⟩, refine ⟨U, F, h1, _⟩, have : (F : set ι).pi U = (⋂ (i : ι) (hi : i ∈ F), (λ (z : Π j, X j), z i) ⁻¹' (U i)), by { ext, simp }, rw [← h, this, set.preimage_Inter], congr' 1, ext1, rw set.preimage_Inter, refl }
refine ⟨U, F, h1, _⟩
have : (F : set ι).pi U = (⋂ (i : ι) (hi : i ∈ F), (λ (z : Π j, X j), z i) ⁻¹' (U i))
ext
ext
{ ext, simp }
{ ext, simp }
simp
simp
rw [← h, this, set.preimage_Inter]
congr' 1
ext1
rw set.preimage_Inter
refl
intros
rw frontier_eq_closure_inter_closure; exact is_closed.inter is_closed_closure is_closed_closure
rw frontier_eq_closure_inter_closure
exact is_closed.inter is_closed_closure is_closed_closure
intros
rw continuous_iff_ultrafilter
intros x _ h
rw [tendsto, ← coe_map]
apply le_nhds_of_str_eq
rw [← str_hom_commute, str_eq_of_le_nhds _ x h]
intros
{ rw continuous_iff_le_induced, exact compact_open_le_induced s }
rw continuous_iff_le_induced
exact compact_open_le_induced s
intros
{ ext, simp, }
ext
simp
intros
ext
simp only [continuous_map.comp_coe, function.comp_app, continuous_map.attach_bound_apply_coe, polynomial.to_continuous_map_on_to_fun, polynomial.aeval_subalgebra_coe, polynomial.aeval_continuous_map_apply, polynomial.to_continuous_map_to_fun]
intros
assume x hx
unfold continuous_within_at
have A := (h x (h₁ hx)).mono h₁
unfold continuous_within_at at A
rw ← h' hx at A
exact A.congr' h'.eventually_eq_nhds_within.symm
intros
ext
{ ext, refl }
refl
intros
rw [e.target_eq, prod_univ, mem_preimage]
intros
split
ext x
{ ext x, simp only [mem_local_triv_as_local_equiv_target] with mfld_simps, refl, }
simp only [mem_local_triv_as_local_equiv_target] with mfld_simps
refl
rintros ⟨x, v⟩ hx
{ rintros ⟨x, v⟩ hx, simp only [triv_change, local_triv_as_local_equiv, local_equiv.symm, true_and, prod.mk.inj_iff, prod_mk_mem_set_prod_eq, local_equiv.trans_source, mem_inter_eq, and_true, mem_preimage, proj, mem_univ, local_equiv.coe_mk, eq_self_iff_true, local_equiv.coe_trans, bundle.proj] at hx ⊢, simp only [Z.coord_change_comp, hx, mem_inter_eq, and_self, mem_base_set_at], }
simp only [triv_change, local_triv_as_local_equiv, local_equiv.symm, true_and, prod.mk.inj_iff, prod_mk_mem_set_prod_eq, local_equiv.trans_source, mem_inter_eq, and_true, mem_preimage, proj, mem_univ, local_equiv.coe_mk, eq_self_iff_true, local_equiv.coe_trans, bundle.proj] at hx ⊢
simp only [Z.coord_change_comp, hx, mem_inter_eq, and_self, mem_base_set_at]
intros
simp [tendsto_subtype_rng, ←subtype.val_eq_coe, cons_val]
{ simp [tendsto_subtype_rng, ←subtype.val_eq_coe, cons_val], exact tendsto_fst.cons (tendsto.comp continuous_at_subtype_coe tendsto_snd) }
exact tendsto_fst.cons (tendsto.comp continuous_at_subtype_coe tendsto_snd)
intros
rcases classical.em (nonempty X) with ⟨⟨x⟩⟩|hX
{ exact ⟨f x, f.eq_const x⟩ }
exact ⟨f x, f.eq_const x⟩
exact ⟨classical.arbitrary Y, ext $ λ x, (hX ⟨x⟩).elim⟩
{ exact ⟨classical.arbitrary Y, ext $ λ x, (hX ⟨x⟩).elim⟩ }
intros
rw ← sInter_range
exact dense_sInter_of_Gδ (forall_range_iff.2 ‹_›) (countable_range _) (forall_range_iff.2 ‹_›)
intros
rwa [bounded_iff_ediam_ne_top, not_not] at h
intros
rw [dist_nndist, real.to_nnreal_coe]
intros
rw [continuous_at, tendsto_nhds_nhds]
intros
simp only [← tendsto_locally_uniformly_on_univ, tendsto_locally_uniformly_on_iff, mem_univ, forall_const, exists_prop, nhds_within_univ]
intros
have ha : isometry (coe : p.val → X) := isometry_subtype_coe
have hb : isometry (coe : q.val → X) := isometry_subtype_coe
have A : dist p q = Hausdorff_dist p.val q.val := rfl
have I : p.val = range (coe : p.val → X)
simp
simp
have J : q.val = range (coe : q.val → X)
simp
simp
rw [I, J] at A
rw A
exact GH_dist_le_Hausdorff_dist ha hb
intros
rw Hausdorff_edist_def
refine le_trans _ le_sup_left
exact le_bsupr x h
intros
rcases hs with ⟨x, xs⟩
rcases ht with ⟨y, yt⟩
refine Hausdorff_dist_le_of_mem_dist diam_nonneg _ _
exact λz hz, ⟨y, yt, dist_le_diam_of_mem (bounded_union.2 ⟨bs, bt⟩) (subset_union_left _ _ hz) (subset_union_right _ _ yt)⟩
{ exact λz hz, ⟨y, yt, dist_le_diam_of_mem (bounded_union.2 ⟨bs, bt⟩) (subset_union_left _ _ hz) (subset_union_right _ _ yt)⟩ }
exact λz hz, ⟨x, xs, dist_le_diam_of_mem (bounded_union.2 ⟨bs, bt⟩) (subset_union_right _ _ hz) (subset_union_left _ _ xs)⟩
{ exact λz hz, ⟨x, xs, dist_le_diam_of_mem (bounded_union.2 ⟨bs, bt⟩) (subset_union_right _ _ hz) (subset_union_left _ _ xs)⟩ }
intros
split
{ apply le_ωSup, }
apply le_ωSup
{ apply ωSup_le, }
apply ωSup_le
intros
rw continuous_def at h₂ ⊢
assume s h
exact h₂ s (h₁ s h)
intros
ext x
simp only [mem_range, path.symm, has_coe_to_fun.coe, coe_fn, unit_interval.symm, set_coe.exists, comp_app, subtype.coe_mk, subtype.val_eq_coe]
split
split; rintros ⟨y, hy, hxy⟩; refine ⟨1-y, mem_iff_one_sub_mem.mp hy, _⟩; convert hxy
split; rintros ⟨y, hy, hxy⟩; refine ⟨1-y, mem_iff_one_sub_mem.mp hy, _⟩
split; rintros ⟨y, hy, hxy⟩
rintros ⟨y, hy, hxy⟩
refine ⟨1-y, mem_iff_one_sub_mem.mp hy, _⟩
convert hxy
rintros ⟨y, hy, hxy⟩
refine ⟨1-y, mem_iff_one_sub_mem.mp hy, _⟩
convert hxy
simp
intros
rw [continuous_at, tendsto_nhds_right]
intros
replace h := h.comap prod.swap
rw [← map_swap_eq_comap_swap, ← uniformity_eq_symm] at h
exact nhds_basis_uniformity' h
intros
simp [cauchy_seq_iff', filter.eventually_at_top_prod_self', prod_map]
intros
refine ⟨is_complete_of_complete_image hm, λ c, _⟩
haveI : complete_space s := c.complete_space_coe
set m' : s → β := m ∘ coe
suffices : is_complete (range m')
rwa [range_comp, subtype.range_coe] at this
rwa [range_comp, subtype.range_coe] at this
have hm' : uniform_inducing m' := hm.comp uniform_embedding_subtype_coe.to_uniform_inducing
intros f hf hfm
rw filter.le_principal_iff at hfm
have cf' : cauchy (comap m' f) := hf.comap' hm'.comap_uniformity.le (ne_bot.comap_of_range_mem hf.1 hfm)
rcases complete_space.complete cf' with ⟨x, hx⟩
rw [hm'.inducing.nhds_eq_comap, comap_le_comap_iff hfm] at hx
use [m' x, mem_range_self _, hx]
intros
by_cases hx : x ∈ c₁.U
calc approx n₂ c₂ x = 0 : approx_of_mem_C _ _ (h hx) ... ≤ approx n₁ c₁ x : approx_nonneg _ _ _
{ calc approx n₂ c₂ x = 0 : approx_of_mem_C _ _ (h hx) ... ≤ approx n₁ c₁ x : approx_nonneg _ _ _ }
calc approx n₂ c₂ x ≤ 1 : approx_le_one _ _ _ ... = approx n₁ c₁ x : (approx_of_nmem_U _ _ hx).symm
{ calc approx n₂ c₂ x ≤ 1 : approx_le_one _ _ _ ... = approx n₁ c₁ x : (approx_of_nmem_U _ _ hx).symm }
intros
rw [congr_fun linear_order.min_def a, min_default]
intros
cases b; simp
cases b
simp
simp
intros
rw [int.mul_comm, int.one_mul]
intros
rw [int.sub_eq_add_neg, int.add_right_neg]
intros
have h := int.neg_lt_neg h
rwa int.neg_neg at h
intros
have h := int.add_lt_add_left h b
rwa int.add_neg_cancel_left at h
intros
rw [← nat.add_sub_cancel x k, nat.sub_le_sub_right_iff _ _ _ h, nat.add_sub_cancel]
intros
by_cases p; simp [h]
by_cases p
simp [h]
simp [h]
intros
rw [mul_assoc, commutes, ←mul_assoc]
intros
{ ext, refl }
ext
refl
intros
{ delta finset.prod, apply multiset.prod_hom_rel; assumption }
delta finset.prod
apply multiset.prod_hom_rel
apply multiset.prod_hom_rel; assumption
assumption
assumption
intros
apply @prod_singleton β ℕ 0 f
intros
have A : mul_support (f ∘ plift.down) = equiv.plift.symm '' mul_support f
rw mul_support_comp_eq_preimage
{ rw mul_support_comp_eq_preimage, exact (equiv.plift.symm.image_eq_preimage _).symm }
exact (equiv.plift.symm.image_eq_preimage _).symm
have : mul_support (f ∘ plift.down) ⊆ s.map equiv.plift.symm.to_embedding
{ rw [A, finset.coe_map], exact image_subset _ h }
rw [A, finset.coe_map]
exact image_subset _ h
rw [finprod_eq_prod_plift_of_mul_support_subset this]
simp
intros
rw [← finprod_mem_union', inter_union_diff]
exacts [λ x hx, hx.2.2 hx.1.2, h.subset (λ x hx, ⟨hx.1.1, hx.2⟩), h.subset (λ x hx, ⟨hx.1.1, hx.2⟩)]
intros
apply tensor_product.ext'
intros x y
refl
intros
{ assume _ hyp, simp [int_fract_pair.stream, hyp] }
assume _ hyp
simp [int_fract_pair.stream, hyp]
intros
simp [*, continuants_aux, next_continuants, next_denominator, next_numerator]
intros
refl
intros
{ rw gcd, exact if_pos rfl }
rw gcd
exact if_pos rfl
intros
rw [(left_distrib (1 / a)), (one_div_mul_cancel ha), right_distrib, one_mul, mul_assoc, (mul_one_div_cancel hb), mul_one, add_comm]
intros
have := (commute.one_right x).geom_sum₂_mul_add n
rw [one_pow, geom_sum₂_with_one] at this
exact this
intros
rw [div_eq_mul_inv, one_mul, div_eq_mul_inv]
intros
{ ext z, rw [function.comp_apply, @is_associative.assoc _ f] }
ext z
rw [function.comp_apply, @is_associative.assoc _ f]
intros
ext
{ ext, simp only [mul_apply, function.comp_app, map_mul, coe_comp] }
simp only [mul_apply, function.comp_app, map_mul, coe_comp]
intros
{ rcases h with ⟨⟨a, b, hab, _⟩, rfl⟩, exact ⟨b, hab⟩ }
rcases h with ⟨⟨a, b, hab, _⟩, rfl⟩
exact ⟨b, hab⟩
intros
ring
intros
induction m with m ih; [exact int.coe_nat_one, rw [pow_succ', pow_succ', int.coe_nat_mul, ih]]
induction m with m ih
exact int.coe_nat_one
rw [pow_succ', pow_succ', int.coe_nat_mul, ih]
intros
conv {to_lhs, rw ← nat.mod_add_div n 2}; rw [pow_add, pow_mul, units_sq, one_pow, mul_one]
conv {to_lhs, rw ← nat.mod_add_div n 2}
rw [pow_add, pow_mul, units_sq, one_pow, mul_one]
intros
simp [hb]
intros
tidy
intros
change ite (1 = 0 + 1) (𝟙 X₁ ≫ d₀) 0 = d₀
{ change ite (1 = 0 + 1) (𝟙 X₁ ≫ d₀) 0 = d₀, rw [if_pos rfl, category.id_comp] }
rw [if_pos rfl, category.id_comp]
intros
{ simp, refl, }
simp
refl
intros
{ apply inv_of_eq_right_inv, rw [h, mul_inv_of_self], }
apply inv_of_eq_right_inv
rw [h, mul_inv_of_self]
intros
{ ext, refl, }
ext
refl
intros
have : of L j y = of L i (hij.rec_on y)
exact eq.drec (eq.refl _) hij
{ exact eq.drec (eq.refl _) hij, }
rw [this, ← lie_algebra_of_apply R ι L i ⁅x, hij.rec_on y⁆, lie_hom.map_lie, lie_algebra_of_apply, lie_algebra_of_apply]
intros
{ rw lie_ideal_oper_eq_span, apply subset_lie_span, use [x, m], }
rw lie_ideal_oper_eq_span
apply subset_lie_span
use [x, m]
intros
apply subsingleton_of_bot_eq_top
ext ⟨x, hx⟩
change x ∈ ⊥ at hx
rw submodule.mem_bot at hx
subst hx
simp only [true_iff, eq_self_iff_true, submodule.mk_eq_zero, mem_bot]
intros
apply subsingleton_of_bot_eq_top
ext ⟨x, hx⟩
change x ∈ ⊥ at hx
rw submodule.mem_bot at hx
subst hx
simp only [true_iff, eq_self_iff_true, submodule.mk_eq_zero, lie_submodule.mem_bot]
intros
rw ← f.range_eq_top at h
rw [ideal_range_eq_lie_span_range, h, ← lie_subalgebra.coe_to_submodule, ← lie_submodule.coe_to_submodule_eq_iff, lie_submodule.top_coe_submodule, lie_subalgebra.top_coe_submodule, lie_submodule.coe_lie_span_submodule_eq_iff]
use ⊤
exact lie_submodule.top_coe_submodule
intros
apply lie_module.weight_vector_multiplication L L M M (to_module_hom R L M) χ₁ χ₂
simp only [lie_module_hom.coe_to_linear_map, function.comp_app, linear_map.coe_comp, tensor_product.map_incl, linear_map.mem_range]
use [⟨x, hx⟩ ⊗ₜ ⟨m, hm⟩]
simp only [submodule.subtype_apply, to_module_hom_apply, tensor_product.map_tmul]
refl
intros
{ rw [←zero_smul R (0 : M), map_smulₛₗ], simp }
rw [←zero_smul R (0 : M), map_smulₛₗ]
simp
intros
refine finsupp.induction_linear f _ (λ f g hf hg, hadd f g hf hg) (λ g r, _)
simpa using hsmul 0 (of k G (multiplicative.of_add 0)) (hM 0)
{ simpa using hsmul 0 (of k G (multiplicative.of_add 0)) (hM 0) }
convert hsmul r (of k G (multiplicative.of_add g)) (hM g)
{ convert hsmul r (of k G (multiplicative.of_add g)) (hM g), simp only [mul_one, to_add_of_add, smul_single', of_apply] }
simp only [mul_one, to_add_of_add, smul_single', of_apply]
intros
suffices : (lift_nc ↑f g).comp (smul_add_hom k (monoid_algebra k G) c) = (add_monoid_hom.mul_left (f c)).comp (lift_nc ↑f g)
from add_monoid_hom.congr_fun this φ
ext a b
simp [mul_assoc]
intros
apply_fun add_monoid_algebra.to_direct_sum
{ simp }
simp
apply function.left_inverse.injective
{ apply function.left_inverse.injective, apply add_monoid_algebra.to_direct_sum_to_add_monoid_algebra }
apply add_monoid_algebra.to_direct_sum_to_add_monoid_algebra
intros
haveI := classical.dec; exact decidable.eq_iff_le_not_lt
haveI := classical.dec
exact decidable.eq_iff_le_not_lt
intros
rw [lt_div_iff_of_neg hb, one_mul]
intros
rw [div_mul_eq_div_mul_one_div, div_mul_eq_div_mul_one_div]
exact mul_le_mul_of_nonneg_right h (one_div_nonneg.2 he)
intros
rw [inv_le_div_iff_le_mul, mul_comm]
intros
haveI := @linear_order.decidable_le α _; exact le_of_not_gt (λhab, (decidable.mul_self_lt_mul_self hb hab).not_le h)
haveI := @linear_order.decidable_le α _
exact le_of_not_gt (λhab, (decidable.mul_self_lt_mul_self hb hab).not_le h)
intros
by_cases ba : b ≤ a
simp [ba.antisymm h₁]
{ simp [ba.antisymm h₁] }
by_cases c0 : c ≤ 0
simp [c0.antisymm h₂]
{ simp [c0.antisymm h₂] }
exact (mul_lt_mul_of_pos_left (h₁.lt_of_not_le ba) (h₂.lt_of_not_le c0)).le
intros
rw [bit0, bit0, ← two_mul, ← two_mul, mul_le_mul_left (zero_lt_two : 0 < (2:α))]
intros
simpa only [zero_add] using h 0
intros
rw [← image_mul_right', image_singleton]
intros
rintros _ ⟨_, _, _, _, rfl⟩
{ rintros _ ⟨_, _, _, _, rfl⟩, exact ⟨_, _, ‹_›, ‹_›, (m.map_mul _ _).symm ⟩ }
exact ⟨_, _, ‹_›, ‹_›, (m.map_mul _ _).symm ⟩
intros
apply nat_degree_prod'
rw prod_ne_zero_iff
intros x hx
simp [h x hx]
intros
simp [ext_iff, neg_eq_iff_add_eq_zero, add_self_eq_zero]
intros
refine ⟨λ h, h.subsingleton, _⟩
intros H a b h
exact @subsingleton.elim _ H a b
intros
simpa only [sub_eq_add_neg, neg_mul_eq_mul_neg] using mul_add a b (-c)
intros
erw ← germ_to_open R (basic_open (f : R)) ⟨x, f.2⟩ (f : R)
{ erw ← germ_to_open R (basic_open (f : R)) ⟨x, f.2⟩ (f : R), exact ring_hom.is_unit_map _ (is_unit_to_basic_open_self R f) }
exact ring_hom.is_unit_map _ (is_unit_to_basic_open_self R f)
intros
by_cases hK : K = 0
simp only [gronwall_bound, if_pos hK, mul_zero, add_zero]
{ simp only [gronwall_bound, if_pos hK, mul_zero, add_zero] }
simp only [gronwall_bound, if_neg hK, mul_zero, exp_zero, sub_self, mul_one, add_zero]
{ simp only [gronwall_bound, if_neg hK, mul_zero, exp_zero, sub_self, mul_one, add_zero] }
intros
{ ext v, exact q.comp_coeff_zero p _ _ }
ext v
exact q.comp_coeff_zero p _ _
intros
have cne0 : ∥c∥ ≠ 0
from mt norm_eq_zero.mp hc
rw [←is_o_norm_right]
simp only [norm_smul]
rw [is_o_const_mul_right_iff cne0, is_o_norm_right]
intros
unfold is_o
{ unfold is_o, exact (forall_congr $ λ c, forall_congr $ λ hc, e.is_O_with_congr hb) }
exact (forall_congr $ λ c, forall_congr $ λ hc, e.is_O_with_congr hb)
intros
convert (has_deriv_at_inv hx).comp_has_deriv_within_at x hc
field_simp
intros
unfold deriv
{ unfold deriv, rw fderiv_zero_of_not_differentiable_at, simp, assumption }
rw fderiv_zero_of_not_differentiable_at
simp
assumption
intros
simpa only [sub_eq_add_neg] using hf.add hg.neg
intros
simp [sub_eq_add_neg]
intros
simpa only [compl_eq_univ_diff] using (has_fderiv_within_at_univ.2 h).eventually_ne hf'
intros
rw ← fderiv_within_univ
exact fderiv_within_subset (subset_univ _) hs h.differentiable_within_at
intros
simpa only [fderiv_deriv] using measurable_fderiv_apply_const 𝕜 f 1
intros
split
rw [← times_cont_diff_on_univ, ← has_ftaylor_series_up_to_on_univ_iff, ← ftaylor_series_within_univ]
{ rw [← times_cont_diff_on_univ, ← has_ftaylor_series_up_to_on_univ_iff, ← ftaylor_series_within_univ], exact λ h, times_cont_diff_on.ftaylor_series_within h unique_diff_on_univ }
exact λ h, times_cont_diff_on.ftaylor_series_within h unique_diff_on_univ
{ assume h, exact ⟨ftaylor_series 𝕜 f, h⟩ }
assume h
exact ⟨ftaylor_series 𝕜 f, h⟩
intros
rw [← times_cont_diff_within_at_univ] at *; exact hf.add hg
rw [← times_cont_diff_within_at_univ] at *
exact hf.add hg
intros
rw [segment_eq_image', segment_eq_image']
refine exists_congr (λ θ, and_congr iff.rfl _)
simp only [add_sub_add_left_eq_sub, add_assoc, add_right_inj]
intros
rw convex_iff_open_segment_subset
rintro p q ⟨ap, bp, hap, hbp, habp, rfl⟩ ⟨aq, bq, haq, hbq, habq, rfl⟩ z ⟨a, b, ha, hb, hab, rfl⟩
refine ⟨a * ap + b * aq, a * bp + b * bq, add_pos (mul_pos ha hap) (mul_pos hb haq), add_pos (mul_pos ha hbp) (mul_pos hb hbq), _, _⟩
rw [add_add_add_comm, ←mul_add, ←mul_add, habp, habq, mul_one, mul_one, hab]
{ rw [add_add_add_comm, ←mul_add, ←mul_add, habp, habq, mul_one, mul_one, hab] }
simp_rw [add_smul, mul_smul, smul_add]
{ simp_rw [add_smul, mul_smul, smul_add], exact add_add_add_comm _ _ _ _ }
exact add_add_add_comm _ _ _ _
intros
rw [affine_combination_eq_weighted_vsub_of_point_vadd_of_sum_eq_one _ w _ hw₂ (0 : E), finset.weighted_vsub_of_point_apply, vadd_eq_add, add_zero, t.center_mass_eq_of_sum_1 _ hw₂]
simp_rw [vsub_eq_sub, sub_zero]
intros
rw [← @of_real_inj 𝕜, im_eq_conj_sub]; simp
rw [← @of_real_inj 𝕜, im_eq_conj_sub]
simp
intros
simp [inner_add_add_self, inner_sub_sub_self, two_mul, sub_eq_add_neg, add_comm, add_left_comm]
intros
have h := @parallelogram_law_with_norm ℝ F _ _ x y
{ have h := @parallelogram_law_with_norm ℝ F _ _ x y, simpa using h }
simpa using h
intros
refine le_antisymm _ _
convert submodule.orthogonal_orthogonal_monotone K.submodule_topological_closure
{ convert submodule.orthogonal_orthogonal_monotone K.submodule_topological_closure, haveI : complete_space K.topological_closure := K.is_closed_topological_closure.complete_space_coe, rw K.topological_closure.orthogonal_orthogonal }
haveI : complete_space K.topological_closure := K.is_closed_topological_closure.complete_space_coe
rw K.topological_closure.orthogonal_orthogonal
exact K.topological_closure_minimal K.le_orthogonal_orthogonal Kᗮ.is_closed_orthogonal
{ exact K.topological_closure_minimal K.le_orthogonal_orthogonal Kᗮ.is_closed_orthogonal }
intros
simp [metric.cauchy_seq_iff, dist_eq_norm]
intros
have : ∀ᶠ y in l, 1 + ∥x∥ ≤ ∥f y∥ := h (mem_at_top (1 + ∥x∥))
refine this.mono (λ y hy hxy, _)
subst x
exact not_le_of_lt zero_lt_one (add_le_iff_nonpos_left.1 hy)
intros
{ ext, refl }
ext
refl
intros
rw [exp_sub, div_eq_one_iff_eq (exp_ne_zero _)]
intros
have : (n : ℝ) + 2 ≠ 0 := by exact_mod_cast succ_ne_zero n.succ
field_simp
convert eq_sub_iff_add_eq.mp (integral_sin_pow_aux n)
ring
intros
refine ⟨λ h, _, λ h, tendsto_at_bot_of_leading_coeff_nonpos P h.1 h.2⟩
have : tendsto (λ x, P.leading_coeff * x ^ P.nat_degree) at_top at_bot := (is_equivalent.tendsto_at_bot (is_equivalent_at_top_lead P) h)
rw tendsto_neg_const_mul_pow_at_top_iff P.leading_coeff P.nat_degree at this
rw [degree_eq_nat_degree (leading_coeff_ne_zero.mp (ne_of_lt this.2)), ← nat.cast_one]
refine ⟨with_bot.coe_le_coe.mpr this.1, le_of_lt this.2⟩
intros
simp [rpow_def]
intros
rw [rpow_def_of_pos (lt_trans zero_lt_one hx)]
repeat {rw [rpow_def_of_pos (lt_trans zero_lt_one hx)]}
rw [rpow_def_of_pos (lt_trans zero_lt_one hx)]
rw [rpow_def_of_pos (lt_trans zero_lt_one hx)]
rw exp_lt_exp
exact mul_lt_mul_of_pos_left hyz (log_pos hx)
intros
refine ⟨λ hc h₀, _, λ h, (has_deriv_at_tan h).continuous_at⟩
exact not_tendsto_nhds_of_tendsto_at_top (tendsto_abs_tan_of_cos_eq_zero h₀) _ (hc.norm.tendsto.mono_left inf_le_left)
intros
rw [← sub_lt_zero, cos_sub_cos]
have : 0 < sin ((y + x) / 2)
refine sin_pos_of_pos_of_lt_pi _ _; linarith
{ refine sin_pos_of_pos_of_lt_pi _ _; linarith }
refine sin_pos_of_pos_of_lt_pi _ _
linarith
linarith
have : 0 < sin ((y - x) / 2)
refine sin_pos_of_pos_of_lt_pi _ _; linarith
{ refine sin_pos_of_pos_of_lt_pi _ _; linarith }
refine sin_pos_of_pos_of_lt_pi _ _
linarith
linarith
nlinarith
intros
unfold arccos; linarith [arcsin_le_pi_div_two x]
unfold arccos
linarith [arcsin_le_pi_div_two x]
intros
by_cases h0 : r = 0
exact tendsto_const_nhds.congr' (mem_at_top_sets.2 ⟨1, λ n hn, by simp [zero_lt_one.trans_le hn, h0]⟩)
{ exact tendsto_const_nhds.congr' (mem_at_top_sets.2 ⟨1, λ n hn, by simp [zero_lt_one.trans_le hn, h0]⟩) }
have hr' : 1 < (abs r)⁻¹
from one_lt_inv (abs_pos.2 h0) hr
rw tendsto_zero_iff_norm_tendsto_zero
simpa [div_eq_mul_inv] using tendsto_pow_const_div_const_pow_of_one_lt k hr'
intros
have h1 : summable (λ (n:ℕ), ∥x∥ ^ n) := summable_geometric_of_lt_1 (norm_nonneg _) h
refine summable_of_norm_bounded_eventually _ h1 _
rw nat.cofinite_eq_at_top
exact eventually_norm_pow_le x
intros
split_ifs; refl
{ split_ifs; refl }
split_ifs
refl
refl
intros
simp
intros
cases F with F_obj _ _ _
cases G with G_obj _ _ _
have : F_obj = G_obj
ext X
ext X
ext X; apply h_obj
ext X; apply h_obj
apply h_obj
apply h_obj
subst this
congr
funext X Y f
simpa using h_map X Y f
intros
simp only [←category.assoc, cancel_mono]
intros
tidy
intros
apply (cancel_epi f).mp
simp [hom_inv_id]
intros
obtain ⟨a, rfl⟩ := concrete.from_union_surjective_of_is_colimit F hD x
exact ⟨a.1, a.2, rfl⟩
intros
ext
ext; erw [assoc, limit.post_π, ←G.map_comp, limit.pre_π, assoc, limit.pre_π, limit.post_π]; refl
ext; erw [assoc, limit.post_π, ←G.map_comp, limit.pre_π, assoc, limit.pre_π, limit.post_π]
erw [assoc, limit.post_π, ←G.map_comp, limit.pre_π, assoc, limit.pre_π, limit.post_π]
intros
{ ext; simp }
ext
ext; simp
simp
simp
intros
erw [fork.condition, has_zero_morphisms.comp_zero]
intros
tidy
intros
{ rw image.eq_fac h, simp }
rw image.eq_fac h
simp
intros
rw [←tensor_left_iff, id_tensor_comp, braiding_right_unitor_aux₂]
intros
apply (cancel_mono (𝟙 X ⊗ (λ_ Y).hom)).1
simp only [assoc, triangle_assoc_comp_left]
rw [←comp_tensor_id, iso.inv_hom_id, ←id_tensor_comp, iso.inv_hom_id]
intros
apply is_limit.hom_ext (ℬ _ _).is_limit
rintro ⟨⟩
rintro ⟨⟩; { dsimp [tensor_hom], simp, }
{ dsimp [tensor_hom], simp, }
{ dsimp [tensor_hom], simp, }
dsimp [tensor_hom]
simp
intros
rw [covers, (sieve.pullback_eq_top_iff_mem f).1 hf]
apply J.top_mem
intros
split
intros h x t₁ t₂ ht₁ ht₂
{ intros h x t₁ t₂ ht₁ ht₂, apply h (x.restrict (le_generate R)) t₁ t₂ _ _, { exact is_amalgamation_restrict _ x t₁ ht₁ }, { exact is_amalgamation_restrict _ x t₂ ht₂ } }
apply h (x.restrict (le_generate R)) t₁ t₂ _ _
{ exact is_amalgamation_restrict _ x t₁ ht₁ }
exact is_amalgamation_restrict _ x t₁ ht₁
{ exact is_amalgamation_restrict _ x t₂ ht₂ }
exact is_amalgamation_restrict _ x t₂ ht₂
intros h x t₁ t₂ ht₁ ht₂
{ intros h x t₁ t₂ ht₁ ht₂, apply h (x.sieve_extend), { exact is_amalgamation_sieve_extend x t₁ ht₁ }, { exact is_amalgamation_sieve_extend x t₂ ht₂ } }
apply h (x.sieve_extend)
{ exact is_amalgamation_sieve_extend x t₁ ht₁ }
exact is_amalgamation_sieve_extend x t₁ ht₁
{ exact is_amalgamation_sieve_extend x t₂ ht₂ }
exact is_amalgamation_sieve_extend x t₂ ht₂
intros
simp [sieve.ext_iff]
intros
tidy
intros
simp [of_mk_le, of_le_mk, of_le, ←functor.map_comp_assoc underlying]
intros
rw [←equalizer_subobject_arrow, category.assoc, category.assoc, equalizer.condition]
intros
{ simp only [size_up_to], rw sum_take_succ _ _ h }
simp only [size_up_to]
rw sum_take_succ _ _ h
intros
induction n with n hn
{ refl }
refl
simp only [num_derangements_add_two, hn, pow_succ, int.coe_nat_mul, int.coe_nat_add, int.coe_nat_succ]
{ simp only [num_derangements_add_two, hn, pow_succ, int.coe_nat_mul, int.coe_nat_add, int.coe_nat_succ], ring }
ring
intros
conv_rhs {rw ← num.to_of_nat n}
exact congr_arg coe (decode_encode_num ↑n)
intros
induction n with n ihn generalizing x
simp only [mem_one, pow_zero, list.length_eq_zero]
{ simp only [mem_one, pow_zero, list.length_eq_zero], split, { rintro rfl, exact ⟨[], rfl, rfl, λ y h, h.elim⟩ }, { rintro ⟨_, rfl, rfl, _⟩, refl } }
split
{ rintro rfl, exact ⟨[], rfl, rfl, λ y h, h.elim⟩ }
rintro rfl
exact ⟨[], rfl, rfl, λ y h, h.elim⟩
{ rintro ⟨_, rfl, rfl, _⟩, refl }
rintro ⟨_, rfl, rfl, _⟩
refl
simp only [pow_succ, mem_mul, ihn]
{ simp only [pow_succ, mem_mul, ihn], split, { rintro ⟨a, b, ha, ⟨S, rfl, rfl, hS⟩, rfl⟩, exact ⟨a :: S, rfl, rfl, list.forall_mem_cons.2 ⟨ha, hS⟩⟩ }, { rintro ⟨_|⟨a, S⟩, rfl, hn, hS⟩; cases hn, rw list.forall_mem_cons at hS, exact ⟨a, _, hS.1, ⟨S, rfl, rfl, hS.2⟩, rfl⟩ } }
split
rintro ⟨a, b, ha, ⟨S, rfl, rfl, hS⟩, rfl⟩
{ rintro ⟨a, b, ha, ⟨S, rfl, rfl, hS⟩, rfl⟩, exact ⟨a :: S, rfl, rfl, list.forall_mem_cons.2 ⟨ha, hS⟩⟩ }
exact ⟨a :: S, rfl, rfl, list.forall_mem_cons.2 ⟨ha, hS⟩⟩
rintro ⟨_|⟨a, S⟩, rfl, hn, hS⟩; cases hn
rintro ⟨_|⟨a, S⟩, rfl, hn, hS⟩
{ rintro ⟨_|⟨a, S⟩, rfl, hn, hS⟩; cases hn, rw list.forall_mem_cons at hS, exact ⟨a, _, hS.1, ⟨S, rfl, rfl, hS.2⟩, rfl⟩ }
cases hn
cases hn
rw list.forall_mem_cons at hS
exact ⟨a, _, hS.1, ⟨S, rfl, rfl, hS.2⟩, rfl⟩
intros
simpa using comp' (prec hg hh) (hf.cons idv)
intros
obtain ⟨a, L, rfl⟩ := L.exists_cons
simp only [tr_tape', list_blank.cons_bind, list_blank.head_cons, list_blank.tail_cons]
suffices : ∀ {L' R' l₁ l₂} (e : vector.to_list (enc a) = list.reverse_core l₁ l₂), tape.move dir.left^[l₁.length] (tape.mk' (list_blank.append l₁ L') (list_blank.append l₂ R')) = tape.mk' L' (list_blank.append (vector.to_list (enc a)) R')
simpa only [list.length_reverse, vector.to_list_length] using this (list.reverse_reverse _).symm
{ simpa only [list.length_reverse, vector.to_list_length] using this (list.reverse_reverse _).symm }
intros
induction l₁ with b l₁ IH generalizing l₂
{ cases e, refl }
cases e
refl
simp only [list.length, list.cons_append, iterate_succ_apply]
convert IH e
simp only [list_blank.tail_cons, list_blank.append, tape.move_left_mk', list_blank.head_cons]
intros
simp only [tape.mk', tape.map, list_blank.head_map, eq_self_iff_true, and_self, list_blank.tail_map]
intros
cases x; simp! with functor_norm; refl
cases x; simp! with functor_norm
cases x
simp! with functor_norm
refl
simp! with functor_norm
refl
simp
intros
simp [str_eq_char_buf, char_buf_iff, ←string.to_list_inj, buffer.ext_iff]
intros
induction l with hd tl hl generalizing n n'
{ simpa using h }
simpa using h
simp only [many1_eq_done] at h
{ simp only [many1_eq_done] at h, obtain ⟨np, hp, h⟩ := h, have := step.of_done hp, subst this, cases tl, { simp only [many_eq_done_nil, exists_and_distrib_right] at h, simpa [←h.left] using bounded.of_done hp }, { rw ←many1_eq_done_iff_many_eq_done at h, exact hl h } }
obtain ⟨np, hp, h⟩ := h
have := step.of_done hp
subst this
cases tl
simp only [many_eq_done_nil, exists_and_distrib_right] at h
{ simp only [many_eq_done_nil, exists_and_distrib_right] at h, simpa [←h.left] using bounded.of_done hp }
simpa [←h.left] using bounded.of_done hp
rw ←many1_eq_done_iff_many_eq_done at h
{ rw ←many1_eq_done_iff_many_eq_done at h, exact hl h }
exact hl h
intros
simp [foldl_core, and_comm]
intros
rw [←of_real_zero]; exact of_real_inj
rw [←of_real_zero]
exact of_real_inj
intros
rw ← zero_eq_mul_self
have : re a * re a = re a * re a + im a * im a
convert is_R_or_C.mul_self_abs a; linarith [re_le_abs a]
convert is_R_or_C.mul_self_abs a
{ convert is_R_or_C.mul_self_abs a; linarith [re_le_abs a] }
linarith [re_le_abs a]
linarith [re_le_abs a]
linarith [re_le_abs a]
linarith [re_le_abs a]
linarith
intros
rw [←filter_ne_eq_erase, filter_single, ite_not]
intros
{ cases a, cases a_val, refl }
cases a
cases a_val
refl
intros
simp [perm.extend_domain]
intros
ext i
by_cases h : i ∈ s
rw [dif_pos h, function.update_apply_equiv_apply, equiv.symm_symm, function.comp, function.update_apply, function.update_apply, dif_pos h]
{ rw [dif_pos h, function.update_apply_equiv_apply, equiv.symm_symm, function.comp, function.update_apply, function.update_apply, dif_pos h], have h_coe : (⟨i, h⟩ : s) = e j ↔ i = e j := subtype.ext_iff.trans (by rw subtype.coe_mk), simp_rw h_coe, congr, }
have h_coe : (⟨i, h⟩ : s) = e j ↔ i = e j := subtype.ext_iff.trans (by rw subtype.coe_mk)
simp_rw h_coe
have : i ≠ e j
{ have : i ≠ e j, by { contrapose! h, have : (e j : α) ∈ s := (e j).2, rwa ← h at this }, simp [h, this] }
contrapose! h
contrapose! h
{ contrapose! h, have : (e j : α) ∈ s := (e j).2, rwa ← h at this }
{ contrapose! h, have : (e j : α) ∈ s := (e j).2, rwa ← h at this }
have : (e j : α) ∈ s := (e j).2
have : (e j : α) ∈ s := (e j).2
rwa ← h at this
rwa ← h at this
simp [h, this]
intros
apply of_nat_of_decode; show option.map _ _ = _; simp
apply of_nat_of_decode; show option.map _ _ = _
apply of_nat_of_decode
show option.map _ _ = _
simp
intros
convert fin_add_flip_apply_cast_add ⟨k, h⟩ n
intros
rw fin.succ_above_below
{ refl }
refl
{ exact bot_lt_iff_ne_bot.mpr ha }
exact bot_lt_iff_ne_bot.mpr ha
intros
simp [tail, cons]
intros
simp_rw [← insert_nth_sub, ← insert_nth_zero_right, pi.sub_def, sub_self, pi.zero_def]
intros
ext
simp only [bit1, bit0] at h
simp only [bit1, bit0, coe_add, coe_one', coe_mk, ←nat.add_mod, nat.mod_eq_of_lt h]
intros
{ ext, congr }
ext
congr
intros
simp only [mem_insert, or_imp_distrib, forall_and_distrib, forall_eq]
intros
simp [finset.nonempty]
intros
simpa only [card_map] using (s.1.map f).to_finset_card_le
intros
intro x
simp only [and_imp, mem_bUnion, exists_prop]
exact Exists.imp (λ a ha, ⟨h ha.1, ha.2⟩)
intros
{ ext, simp, }
ext
simp
intros
refine f.induction _ _
rw [to_multiset_zero, multiset.prod_zero, finsupp.prod_zero_index]
{ rw [to_multiset_zero, multiset.prod_zero, finsupp.prod_zero_index] }
assume a n f _ _ ih
{ assume a n f _ _ ih, rw [to_multiset_add, multiset.prod_add, ih, to_multiset_single, finsupp.prod_add_index, finsupp.prod_single_index, multiset.prod_nsmul, multiset.prod_singleton], { exact pow_zero a }, { exact pow_zero }, { exact pow_add } }
rw [to_multiset_add, multiset.prod_add, ih, to_multiset_single, finsupp.prod_add_index, finsupp.prod_single_index, multiset.prod_nsmul, multiset.prod_singleton]
{ exact pow_zero a }
exact pow_zero a
{ exact pow_zero }
exact pow_zero
{ exact pow_add }
exact pow_add
intros
{ ext i, simp [piecewise] }
ext i
simp [piecewise]
intros
simpa [mul_comm] using fin.prod_univ_succ_above f (fin.last n)
intros
rw [eq_neg_of_eq_neg (neg_succ (-a)).symm, neg_neg]
intros
have := int.mul_div_cancel 1 H; rwa one_mul at this
have := int.mul_div_cancel 1 H
rwa one_mul at this
intros
{ ext, rw pi.int_apply }
ext
rw pi.int_apply
intros
rw int.lcm
{ rw int.lcm, apply coe_nat_dvd_right.mpr, apply nat.dvd_lcm_right }
apply coe_nat_dvd_right.mpr
apply nat.dvd_lcm_right
intros
rw [← add_zero ((a : ℤ) * _), nat.gcd_eq_gcd_ab]
{ rw [← add_zero ((a : ℤ) * _), nat.gcd_eq_gcd_ab], exact (dvd_mul_right _ _).zero_modeq_int.add_left _ }
exact (dvd_mul_right _ _).zero_modeq_int.add_left _
intros
rw [odd_iff_not_even, even_sub, not_iff, odd_iff_not_even]
intros
induction l with b l' ih
{cases h}
cases h
rcases h with rfl | h
{rcases h with rfl | h, {exact or.inl rfl}, {exact or.inr (ih h)}}
{exact or.inl rfl}
exact or.inl rfl
{exact or.inr (ih h)}
exact or.inr (ih h)
intros
split
assume H j hj
{ assume H j hj, exact H (f j) (mem_map_of_mem f hj) }
exact H (f j) (mem_map_of_mem f hj)
assume H i hi
{ assume H i hi, rcases mem_map.1 hi with ⟨j, hj, ji⟩, rw ← ji, exact H j hj }
rcases mem_map.1 hi with ⟨j, hj, ji⟩
rw ← ji
exact H j hj
intros
{ induction as, { refl }, { simp! [*, apply_ite (map f)] } }
induction as
refl
{ refl }
simp! [*, apply_ite (map f)]
{ simp! [*, apply_ite (map f)] }
intros
cases l
{ simp only [nth_le, scanl_nil] }
simp only [nth_le, scanl_nil]
{ simp only [nth_le, scanl_cons, singleton_append] }
simp only [nth_le, scanl_cons, singleton_append]
intros
simp [join_filter_empty_eq_ff, ← empty_iff_eq_nil]
intros
induction l with b l IH
contradiction
{contradiction}
by_cases h : p b
{ rw find_cons_of_pos _ h at H, cases H, exact h }
rw find_cons_of_pos _ h at H
cases H
exact h
{ rw find_cons_of_neg _ h at H, exact IH H }
rw find_cons_of_neg _ h at H
exact IH H
intros
{ rw inits_eq_tails l, simp [reverse_involutive.comp_self], }
rw inits_eq_tails l
simp [reverse_involutive.comp_self]
intros
rw insert_of_mem h
intros
rw [← diff_cons_right, diff_cons]
intros
induction l; simp *
induction l
simp *
simp *
intros
induction p with _ a c l r p IH generalizing b
induction p with _ a c l r p IH generalizing b; constructor; [exact Hab r, exact IH (@HRS _)]
induction p with _ a c l r p IH generalizing b; constructor
constructor
constructor
exact Hab r
exact IH (@HRS _)
intros
obtain ⟨x, y, hxy, hx, hy⟩ := h
induction s using quot.induction_on with l
rcases l with (_ | ⟨hd, _ | ⟨hd', tl⟩⟩)
{ simpa using hx }
simpa using hx
simp only [mem_coe_iff, mk_eq_coe, mem_singleton] at hx hy
{ simp only [mem_coe_iff, mk_eq_coe, mem_singleton] at hx hy, simpa [hx, hy] using hxy }
simpa [hx, hy] using hxy
{ simp [bit0] }
simp [bit0]
intros
rw [antidiagonal, mem_map]
split
rintros ⟨i, hi, rfl⟩
{ rintros ⟨i, hi, rfl⟩, rw [mem_range, lt_succ_iff] at hi, exact nat.add_sub_of_le hi }
rw [mem_range, lt_succ_iff] at hi
exact nat.add_sub_of_le hi
rintro rfl
{ rintro rfl, refine ⟨x.fst, _, _⟩, { rw [mem_range, add_assoc, lt_add_iff_pos_right], exact zero_lt_succ _ }, { exact prod.ext rfl (nat.add_sub_cancel_left _ _) } }
refine ⟨x.fst, _, _⟩
{ rw [mem_range, add_assoc, lt_add_iff_pos_right], exact zero_lt_succ _ }
rw [mem_range, add_assoc, lt_add_iff_pos_right]
exact zero_lt_succ _
{ exact prod.ext rfl (nat.add_sub_cancel_left _ _) }
exact prod.ext rfl (nat.add_sub_cancel_left _ _)
intros
split
intro H
{ intro H, induction H with xs ys y H IH xs ys x H IH, { simp }, { obtain ⟨f, hf⟩ := IH, refine ⟨f.trans (order_embedding.of_strict_mono (+ 1) (λ _, by simp)), _⟩, simpa using hf }, { obtain ⟨f, hf⟩ := IH, refine ⟨order_embedding.of_map_le_iff (λ (ix : ℕ), if ix = 0 then 0 else (f ix.pred).succ) _, _⟩, { rintro ⟨_|a⟩ ⟨_|b⟩; simp [nat.succ_le_succ_iff] }, { rintro ⟨_|i⟩, { simp }, { simpa using hf _ } } } }
induction H with xs ys y H IH xs ys x H IH
{ simp }
simp
obtain ⟨f, hf⟩ := IH
{ obtain ⟨f, hf⟩ := IH, refine ⟨f.trans (order_embedding.of_strict_mono (+ 1) (λ _, by simp)), _⟩, simpa using hf }
refine ⟨f.trans (order_embedding.of_strict_mono (+ 1) (λ _, by simp)), _⟩
simpa using hf
obtain ⟨f, hf⟩ := IH
{ obtain ⟨f, hf⟩ := IH, refine ⟨order_embedding.of_map_le_iff (λ (ix : ℕ), if ix = 0 then 0 else (f ix.pred).succ) _, _⟩, { rintro ⟨_|a⟩ ⟨_|b⟩; simp [nat.succ_le_succ_iff] }, { rintro ⟨_|i⟩, { simp }, { simpa using hf _ } } }
refine ⟨order_embedding.of_map_le_iff (λ (ix : ℕ), if ix = 0 then 0 else (f ix.pred).succ) _, _⟩
rintro ⟨_|a⟩ ⟨_|b⟩; simp [nat.succ_le_succ_iff]
rintro ⟨_|a⟩ ⟨_|b⟩
{ rintro ⟨_|a⟩ ⟨_|b⟩; simp [nat.succ_le_succ_iff] }
simp [nat.succ_le_succ_iff]
simp [nat.succ_le_succ_iff]
simp [nat.succ_le_succ_iff]
simp [nat.succ_le_succ_iff]
rintro ⟨_|i⟩
{ rintro ⟨_|i⟩, { simp }, { simpa using hf _ } }
simp
{ simp }
simpa using hf _
{ simpa using hf _ }
rintro ⟨f, hf⟩
{ rintro ⟨f, hf⟩, exact sublist_of_order_embedding_nth_eq f hf }
exact sublist_of_order_embedding_nth_eq f hf
intros
induction l₁ with hd tl IH generalizing l₂
{ simp }
simp
have : hd ∈ l₂
{ have : hd ∈ l₂, { rw ←count_pos, exact lt_of_lt_of_le (count_pos.mpr (mem_cons_self _ _)) (h hd (mem_cons_self _ _)) }, replace this : l₂ ~ hd :: l₂.erase hd := perm_cons_erase this, refine perm.trans _ this.symm, rw [cons_append, diff_cons, perm_cons], refine IH (λ x hx, _), specialize h x (mem_cons_of_mem _ hx), rw (perm_iff_count.mp this) at h, by_cases hx : x = hd, { subst hd, simpa [nat.succ_le_succ_iff] using h }, { simpa [hx] using h } }
rw ←count_pos
{ rw ←count_pos, exact lt_of_lt_of_le (count_pos.mpr (mem_cons_self _ _)) (h hd (mem_cons_self _ _)) }
exact lt_of_lt_of_le (count_pos.mpr (mem_cons_self _ _)) (h hd (mem_cons_self _ _))
replace this : l₂ ~ hd :: l₂.erase hd := perm_cons_erase this
refine perm.trans _ this.symm
rw [cons_append, diff_cons, perm_cons]
refine IH (λ x hx, _)
specialize h x (mem_cons_of_mem _ hx)
rw (perm_iff_count.mp this) at h
by_cases hx : x = hd
subst hd
{ subst hd, simpa [nat.succ_le_succ_iff] using h }
simpa [nat.succ_le_succ_iff] using h
{ simpa [hx] using h }
simpa [hx] using h
intros
rw rotate_eq_rotate'
induction n with n hn generalizing l
{ simp }
simp
cases l with hd tl
{ cases l with hd tl, { simp }, { rw rotate'_cons_succ, exact (hn _).trans (perm_append_singleton _ _) } }
{ simp }
simp
rw rotate'_cons_succ
{ rw rotate'_cons_succ, exact (hn _).trans (perm_append_singleton _ _) }
exact (hn _).trans (perm_append_singleton _ _)
intros
simp only [sublists, sublists_aux_cons_eq_sublists_aux₁, sublists_aux₁_append, bind_eq_bind, sublists_aux₁_bind]
congr
funext x
apply congr_arg _
rw [← bind_ret_eq_map, sublists_aux₁_bind]
exact (append_nil _).symm
intros
induction as generalizing bs
{ simp }
simp
cases bs; simp *
{ cases bs; simp * }
cases bs
simp *
simp *
intros
induction l with hd tl hl generalizing l'
have : l' = [] := eq_nil_of_length_eq_zero (by simpa using h.symm)
{ have : l' = [] := eq_nil_of_length_eq_zero (by simpa using h.symm), simp [this], }
simp [this]
cases l'
{ cases l', { simpa using h }, { simp only [add_left_inj, length] at h, simp [hl _ h] } }
{ simpa using h }
simpa using h
simp only [add_left_inj, length] at h
{ simp only [add_left_inj, length] at h, simp [hl _ h] }
simp [hl _ h]
intros
{ ext i j, refl }
ext i j
refl
intros
ext i' j'
rw [update_column_apply, map_apply, map_apply, update_column_apply]
exact apply_ite f _ _ _
intros
ext i j
rcases i
rcases i; rcases j; simp [from_blocks]
rcases i; rcases j
rcases j
simp [from_blocks]
simp [from_blocks]
rcases j
simp [from_blocks]
simp [from_blocks]
intros
{ ext i j, refine fin.cases _ _ j; simp }
ext i j
refine fin.cases _ _ j
refine fin.cases _ _ j; simp
simp
simp
intros
{ rw [← rel_flip], exact rel_repeat_left }
rw [← rel_flip]
exact rel_repeat_left
intros
rw [←singleton_add, nsmul_add]
intros
{ ext, simp only [aeval_tower_X, aeval_X] }
ext
simp only [aeval_tower_X, aeval_X]
intros
rw [constant_coeff_eq, coeff_monomial]
intros
rw [← alg_hom.comp_apply, expand_comp_bind₁]
intros
simp [mem_supported]
intros
rw [total_degree, support_X]
simp only [finset.sup, sum_single_index, finset.fold_singleton, sup_bot_eq]
intros
{ convert bit1_le_bit0_iff, refl, }
convert bit1_le_bit0_iff
refl
intros
rw [add_succ, succ_sub_one]
intros
induction nk with k nk ih
{ induction nk with k nk ih, rw [decreasing_induction_self], rw [decreasing_induction_succ h (le_trans mn nk), ih, decreasing_induction_succ] }
rw [decreasing_induction_self]
rw [decreasing_induction_succ h (le_trans mn nk), ih, decreasing_induction_succ]
intros
simp [lxor]
intros
induction n; simp *
induction n
simp *
simp *
intros
simp [of_digits]
intros
rcases b with _|⟨_|⟨_⟩⟩; simp [digits, digits_aux_0, digits_aux_1]
rcases b with _|⟨_|⟨_⟩⟩
simp [digits, digits_aux_0, digits_aux_1]
simp [digits, digits_aux_0, digits_aux_1]
simp [digits, digits_aux_0, digits_aux_1]
intros
simpa only [← some_eq_coe] using part.ne_none_iff
intros
{ intro h, simpa [h, hm, hn] using gcd_mul_lcm m n, }
intro h
simpa [h, hm, hn] using gcd_mul_lcm m n
intros
rw [nat.modeq, nat.mod_zero, nat.mod_zero]
intros
induction n with n ih; simp [*, pow_succ', even_mul]
{ induction n with n ih; simp [*, pow_succ', even_mul], tauto }
induction n with n ih
simp [*, pow_succ', even_mul]
simp [*, pow_succ', even_mul]
tauto
intros
rw ←pow_one p; exact pow_dvd_of_le_of_pow_dvd hk hpk
rw ←pow_one p
exact pow_dvd_of_le_of_pow_dvd hk hpk
intros
cases nat.eq_zero_or_pos (gcd m n) with g0 g1
rw [eq_zero_of_gcd_eq_zero_left g0, eq_zero_of_gcd_eq_zero_right g0] at H
{ rw [eq_zero_of_gcd_eq_zero_left g0, eq_zero_of_gcd_eq_zero_right g0] at H, exfalso, exact H 2 prime_two (dvd_zero _) (dvd_zero _) }
exfalso
exact H 2 prime_two (dvd_zero _) (dvd_zero _)
apply eq.symm
change 1 ≤ _ at g1
apply (lt_or_eq_of_le g1).resolve_left
intro g2
obtain ⟨p, hp, hpdvd⟩ := exists_prime_and_dvd g2
apply H p hp; apply dvd_trans hpdvd
apply H p hp
apply dvd_trans hpdvd
{ exact gcd_dvd_left _ _ }
exact gcd_dvd_left _ _
apply dvd_trans hpdvd
{ exact gcd_dvd_right _ _ }
exact gcd_dvd_right _ _
intros
refine min_fac_helper_1 e _ h
intro e₁
rw ← e₁ at np
exact np (nat.min_fac_prime $ ne_of_gt $ nat.bit1_lt h.n_pos)
intros
rw sqrt_aux; simp only [h, h₂, if_false]
rw sqrt_aux
simp only [h, h₂, if_false]
cases int.eq_neg_succ_of_lt_zero (sub_lt_zero.2 (int.coe_nat_lt_coe_nat_of_lt h₂)) with k e
rw [e, sqrt_aux._match_1]
intros
cases n
cases n; refl
refl
refl
intros
rcases o with _|_|_; simp
rcases o with _|_|_
simp
simp
simp
intros
cases o; simp
{cases o; simp}
cases o
simp
simp
intros
rw h.1; refl
rw h.1
intros
rw [← all_dual, dual_rotate_r, all_rotate_l]; simp [all_dual, and_comm, and.left_comm]
rw [← all_dual, dual_rotate_r, all_rotate_l]
simp [all_dual, and_comm, and.left_comm]
intros
rw [bind_some_eq_map]; simp [map_id']
rw [bind_some_eq_map]
simp [map_id']
intros
{ cases x, refl }
cases x
refl
intros
dsimp only [ichildren,pfunctor.obj.iget]
{ dsimp only [ichildren,pfunctor.obj.iget], congr' with h, apply ext', dsimp only [children',M.mk,approx.s_mk], intros, refl }
congr' with h
apply ext'
dsimp only [children',M.mk,approx.s_mk]
intros
refl
intros
rcases p
{ rcases p, rcases q, simp [coeff, sub_eq_add_neg, add_to_finsupp, neg_to_finsupp] }
rcases q
simp [coeff, sub_eq_add_neg, add_to_finsupp, neg_to_finsupp]
intros
rcases p
rcases q
simp only [coeff, mul_to_finsupp]
exact add_monoid_algebra.mul_apply_antidiagonal p q n _ (λ x, nat.mem_antidiagonal)
intros
rw [degree_eq_nat_degree hp, with_bot.coe_eq_coe]
intros
simpa only [C_1, one_mul] using le_trailing_degree_C_mul_X_pow n (1:R)
intros
simp [derivative_comp]
intros
classical
induction s using finset.induction with p hp s hs
simp
rw [sum_insert, eval₂_add, hs, sum_insert]
rw [sum_insert, eval₂_add, hs, sum_insert]; assumption
assumption
assumption
assumption
assumption
intros
apply polynomial.induction_on' p
{ intros p q hp hq, simp [hp, hq, mul_add], }
intros p q hp hq
simp [hp, hq, mul_add]
{ intros n b, simp [mul_assoc], }
intros n b
simp [mul_assoc]
intros
apply sum_add_index; simp [add_mul]
{ apply sum_add_index; simp [add_mul] }
apply sum_add_index
simp [add_mul]
simp [add_mul]
intros
rw [integral_normalization_coeff, if_pos hi]
intros
obtain ⟨k, hk⟩ := nat.exists_eq_succ_of_ne_zero h
convert monic_X_pow_sub _
exact le_trans degree_C_le nat.with_bot.coe_nonneg
intros
classical; by_contradiction hp; exact fintype.false ⟨p.roots.to_finset, λ x, multiset.mem_to_finset.mpr ((mem_roots hp).mpr (h _))⟩
classical; by_contradiction hp
classical
by_contradiction hp
exact fintype.false ⟨p.roots.to_finset, λ x, multiset.mem_to_finset.mpr ((mem_roots hp).mpr (h _))⟩
intros
intros b₁ b₂ h
{ intros b₁ b₂ h, simpa only [true_and, prod.mk.inj_iff, eq_self_iff_true] using h }
simpa only [true_and, prod.mk.inj_iff, eq_self_iff_true] using h
intros
rw [corecF, M.dest_corec]
intros
cases n; simp [mk_pnat]; change int.nat_abs 0 with 0; simp *; refl
cases n; simp [mk_pnat]; change int.nat_abs 0 with 0; simp *
cases n; simp [mk_pnat]; change int.nat_abs 0 with 0
cases n; simp [mk_pnat]
cases n
simp [mk_pnat]
change int.nat_abs 0 with 0
simp *
refl
intros
{ cases q₁, cases q₂, apply mk_pnat_denom_dvd }
cases q₁
cases q₂
apply mk_pnat_denom_dvd
intros
have : (n : ℤ) % d = n - d * ⌊(n : ℚ)/ d⌋
from int.mod_nat_eq_sub_mul_floor_rat_div
rw ←this
have : d.coprime n
from n_coprime_d.symm
rwa [nat.coprime, nat.gcd_rec] at this
intros
{ ext n, cases h : f (n + 1); simp [h, pow_succ] }
ext n
cases h : f (n + 1)
cases h : f (n + 1); simp [h, pow_succ]
simp [h, pow_succ]
simp [h, pow_succ]
intros
rw [←real.to_nnreal_one, real.to_nnreal_lt_to_nnreal_iff h.pos]
exact h.one_lt
intros
rw [div_eq_mul_inv, ← mul_add, inv_two_add_inv_two, mul_one]
intros
simpa only [mul_comm] using infi_mul_of_ne h0 h
intros
rw [fib_rec, linear_recurrence.char_poly]
simp [finset.sum_fin_eq_sum_range, finset.sum_range_succ', monomial_eq_smul_X]
intros
cases (lt_or_gt_of_ne h0) with hn hp
exact or.inr (infinite_neg_iff_infinitesimal_inv_neg.mpr ⟨hi, inv_lt_zero.mpr hn⟩)
{ exact or.inr (infinite_neg_iff_infinitesimal_inv_neg.mpr ⟨hi, inv_lt_zero.mpr hn⟩) }
exact or.inl (infinite_pos_iff_infinitesimal_inv_pos.mpr ⟨hi, inv_pos.mpr hp⟩)
{ exact or.inl (infinite_pos_iff_infinitesimal_inv_pos.mpr ⟨hi, inv_pos.mpr hp⟩) }
intros
{ rintro ⟨a, rfl⟩, exact tr (is_algebraic_algebra_map a) }
rintro ⟨a, rfl⟩
exact tr (is_algebraic_algebra_map a)
intros
cases le_total 0 p
{ rw [← nnreal.coe_lt_coe, real.coe_to_nnreal p h] }
rw [← nnreal.coe_lt_coe, real.coe_to_nnreal p h]
rw [to_nnreal_eq_zero.2 h]
{ rw [to_nnreal_eq_zero.2 h], split, { intro, have := not_lt_of_le (zero_le r), contradiction }, { intro rp, have : ¬(p ≤ 0) := not_le_of_lt (lt_of_le_of_lt (nnreal.coe_nonneg _) rp), contradiction } }
split
{ intro, have := not_lt_of_le (zero_le r), contradiction }
intro
have := not_lt_of_le (zero_le r)
contradiction
intro rp
{ intro rp, have : ¬(p ≤ 0) := not_le_of_lt (lt_of_le_of_lt (nnreal.coe_nonneg _) rp), contradiction }
have : ¬(p ≤ 0) := not_le_of_lt (lt_of_le_of_lt (nnreal.coe_nonneg _) rp)
contradiction
intros
{ ext, simp [coe_to_nnreal x h, abs_of_nonneg h] }
ext
simp [coe_to_nnreal x h, abs_of_nonneg h]
intros
rw [sqrt, ← nnreal.coe_mul, nnreal.mul_self_sqrt, real.coe_to_nnreal _ h]
intros
{ ext x, simp [mem_image] }
ext x
simp [mem_image]
intros
induction l; simp [*, stream.nil_append_stream, stream.cons_append_stream]
induction l
simp [*, stream.nil_append_stream, stream.cons_append_stream]
simp [*, stream.nil_append_stream, stream.cons_append_stream]
intros
{ congr' with x, apply_assumption }
congr' with x
apply_assumption
intros
ext ⟨x, y⟩
{ ext ⟨x, y⟩, simp [image, iff_def, or_imp_distrib, imp.swap] {contextual := tt} }
simp [image, iff_def, or_imp_distrib, imp.swap] {contextual := tt}
intros
rw [← union_pi, union_compl_self]
intros
ext
split
rintro ⟨a, _, ha, ⟨b, hb, rfl⟩, rfl⟩
{ rintro ⟨a, _, ha, ⟨b, hb, rfl⟩, rfl⟩, refine ⟨a, b, ha, hb, rfl⟩ }
refine ⟨a, b, ha, hb, rfl⟩
rintro ⟨a, b, ha, hb, rfl⟩
{ rintro ⟨a, b, ha, hb, rfl⟩, refine ⟨a, _, ha, ⟨b, hb, rfl⟩, rfl⟩ }
refine ⟨a, _, ha, ⟨b, hb, rfl⟩, rfl⟩
intros
rw sUnion_eq_bUnion; exact hs.bUnion h
rw sUnion_eq_bUnion
exact hs.bUnion h
intros
casesI hs
choose f hf using show ∀ x : s, ∃ i, x.1 ∈ t i, {simpa [subset_def] using h}
refine ⟨range f, finite_range f, λ x hx, _⟩
rw [bUnion_range, mem_Union]
exact ⟨⟨x, hx⟩, hf _⟩
intros
intros y hy
rcases h₁ hy.1 with ⟨x₁, hx₁, rfl⟩
rcases h₂ hy.2 with ⟨x₂, hx₂, heq⟩
have : x₁ = x₂
from h (or.inl hx₁) (or.inr hx₂) heq.symm
subst x₂
exact mem_image_of_mem f ⟨hx₁, hx₂⟩
intros
rintros y ⟨x, hxt, rfl⟩
rcases ha hxt with ⟨x, hxs, rfl⟩
rw [h x]
exact mem_image_of_mem _ (mem_image_of_mem _ hxs)
intros
cases lt_or_le x y with h' h'
{ use x, simp [*, not_le.2 h'] }
use x
simp [*, not_le.2 h']
{ use max x (x + dy), simp [*, le_refl] }
use max x (x + dy)
simp [*, le_refl]
intros
simp [sub_eq_add_neg]
intros
simp [sub_eq_add_neg, image_comp (λ x, a + x) (λ x, -x)]
intros
simpa only [mul_comm] using preimage_mul_const_Ioi_of_neg a h
intros
have : Ioc (x i₀) m = Iic m ∩ Ioc (x i₀) (y i₀)
rw [← Ioi_inter_Iic, ← Ioi_inter_Iic, inter_left_comm, inter_eq_self_of_subset_left (Iic_subset_Iic.2 hm)]
rw [← Ioi_inter_Iic, ← Ioi_inter_Iic, inter_left_comm, inter_eq_self_of_subset_left (Iic_subset_Iic.2 hm)]
simp_rw [univ_pi_update i₀ y m (λ i z, Ioc (x i) z), ← pi_inter_compl ({i₀} : set ι), singleton_pi', ← inter_assoc, this]
refl
intros
{ ext, simp }
ext
simp
intros
simp [set.eq_empty_iff_forall_not_mem]
intros
cases n
{ exact congr_arg ((∘) int.cast) zmod.cast_id', }
exact congr_arg ((∘) int.cast) zmod.cast_id'
{ ext, simp }
ext
simp
intros
simpa only [sub_eq_add_neg] using hf.add hg.neg
intros
have h0 : C 0 := add_neg_self (1:R) ▸ ha h1 hneg1
rcases exists_list_of_mem_closure hx with ⟨L, HL, rfl⟩
clear hx
induction L with hd tl ih
exact h0
{ exact h0 }
rw list.forall_mem_cons at HL
suffices : C (list.prod hd)
rw [list.map_cons, list.sum_cons]
{ rw [list.map_cons, list.sum_cons], exact ha this (ih HL.2) }
exact ha this (ih HL.2)
replace HL := HL.1
clear ih tl
suffices : ∃ L : list R, (∀ x ∈ L, x ∈ s) ∧ (list.prod hd = list.prod L ∨ list.prod hd = -list.prod L)
rcases this with ⟨L, HL', HP | HP⟩
{ rcases this with ⟨L, HL', HP | HP⟩, { rw HP, clear HP HL hd, induction L with hd tl ih, { exact h1 }, rw list.forall_mem_cons at HL', rw list.prod_cons, exact hs _ HL'.1 _ (ih HL'.2) }, rw HP, clear HP HL hd, induction L with hd tl ih, { exact hneg1 }, rw [list.prod_cons, neg_mul_eq_mul_neg], rw list.forall_mem_cons at HL', exact hs _ HL'.1 _ (ih HL'.2) }
rw HP
{ rw HP, clear HP HL hd, induction L with hd tl ih, { exact h1 }, rw list.forall_mem_cons at HL', rw list.prod_cons, exact hs _ HL'.1 _ (ih HL'.2) }
clear HP HL hd
induction L with hd tl ih
exact h1
{ exact h1 }
rw list.forall_mem_cons at HL'
rw list.prod_cons
exact hs _ HL'.1 _ (ih HL'.2)
rw HP
clear HP HL hd
induction L with hd tl ih
exact hneg1
{ exact hneg1 }
rw [list.prod_cons, neg_mul_eq_mul_neg]
rw list.forall_mem_cons at HL'
exact hs _ HL'.1 _ (ih HL'.2)
induction hd with hd tl ih
{ exact ⟨[], list.forall_mem_nil _, or.inl rfl⟩ }
exact ⟨[], list.forall_mem_nil _, or.inl rfl⟩
rw list.forall_mem_cons at HL
rcases ih HL.2 with ⟨L, HL', HP | HP⟩
rcases ih HL.2 with ⟨L, HL', HP | HP⟩; cases HL.1 with hhd hhd
cases HL.1 with hhd hhd
exact ⟨hd :: L, list.forall_mem_cons.2 ⟨hhd, HL'⟩, or.inl $ by rw [list.prod_cons, list.prod_cons, HP]⟩
{ exact ⟨hd :: L, list.forall_mem_cons.2 ⟨hhd, HL'⟩, or.inl $ by rw [list.prod_cons, list.prod_cons, HP]⟩ }
exact ⟨L, HL', or.inr $ by rw [list.prod_cons, hhd, neg_one_mul, HP]⟩
{ exact ⟨L, HL', or.inr $ by rw [list.prod_cons, hhd, neg_one_mul, HP]⟩ }
cases HL.1 with hhd hhd
exact ⟨hd :: L, list.forall_mem_cons.2 ⟨hhd, HL'⟩, or.inr $ by rw [list.prod_cons, list.prod_cons, HP, neg_mul_eq_mul_neg]⟩
{ exact ⟨hd :: L, list.forall_mem_cons.2 ⟨hhd, HL'⟩, or.inr $ by rw [list.prod_cons, list.prod_cons, HP, neg_mul_eq_mul_neg]⟩ }
exact ⟨L, HL', or.inl $ by rw [list.prod_cons, hhd, HP, neg_one_mul, neg_neg]⟩
{ exact ⟨L, HL', or.inl $ by rw [list.prod_cons, hhd, HP, neg_one_mul, neg_neg]⟩ }
intros
refine f.tendsto_translation_number_aux.congr_dist (squeeze_zero (λ _, dist_nonneg) _ _)
{ exact λ n, C / 2^n }
exact λ n, C / 2^n
intro n
{ intro n, have : 0 < (2^n:ℝ) := pow_pos zero_lt_two _, convert (div_le_div_right this).2 (H (2^n)), rw [transnum_aux_seq, real.dist_eq, ← sub_div, abs_div, abs_of_pos this, real.dist_eq] }
have : 0 < (2^n:ℝ) := pow_pos zero_lt_two _
convert (div_le_div_right this).2 (H (2^n))
rw [transnum_aux_seq, real.dist_eq, ← sub_div, abs_div, abs_of_pos this, real.dist_eq]
exact mul_zero C ▸ tendsto_const_nhds.mul (tendsto_inv_at_top_zero.comp $ tendsto_pow_at_top_at_top_of_one_lt one_lt_two)
{ exact mul_zero C ▸ tendsto_const_nhds.mul (tendsto_inv_at_top_zero.comp $ tendsto_pow_at_top_at_top_of_one_lt one_lt_two) }
intros
convert hx
intros
conv_lhs { rw ← nat.mod_add_div n (minimal_period f x) }
rw [iterate_add, mul_comm, iterate_mul, comp_app]
congr
exact is_periodic_pt.iterate (is_periodic_pt_minimal_period _ _) _
intros
ext
{ ext, rw [mem_lift2, mem_bot], exact set.ext_iff.mp subtype.range_coe x }
rw [mem_lift2, mem_bot]
exact set.ext_iff.mp subtype.range_coe x
intros
rw [← card_units_eq_totient, pow_card_eq_one]
intros
rw is_scalar_tower.aeval_apply R K
{ rw is_scalar_tower.aeval_apply R K, exact eval₂_eq_zero_of_dvd_of_eval₂_eq_zero (algebra_map K U) y (minpoly.dvd_map_of_is_scalar_tower R K x) hy }
exact eval₂_eq_zero_of_dvd_of_eval₂_eq_zero (algebra_map K U) y (minpoly.dvd_map_of_is_scalar_tower R K x) hy
intros
rw [angle, ← real_inner_div_norm_mul_norm_eq_neg_one_iff, real.arccos_eq_pi, has_le.le.le_iff_eq]
exact (abs_le.mp (abs_real_inner_div_norm_mul_norm_le_one x y)).1
intros
have hd' : finrank ℝ (⊤ : affine_subspace ℝ P).direction = 2
rw [direction_top, finrank_top]
{ rw [direction_top, finrank_top], exact hd }
exact hd
exact eq_of_dist_eq_of_dist_eq_of_mem_of_finrank_eq_two hd' (mem_top ℝ V _) (mem_top ℝ V _) (mem_top ℝ V _) (mem_top ℝ V _) (mem_top ℝ V _) hc hp hp₁c₁ hp₂c₁ hpc₁ hp₁c₂ hp₂c₂ hpc₂
intros
refine span_points_subset_coe_of_subset_coe _
rw [set.insert_subset, set.singleton_subset_iff]
exact ⟨t.orthocenter_mem_altitude, t.mem_altitude i⟩
intros
{ simp only [chart], mfld_set_tac }
simp only [chart]
mfld_set_tac
intros
simp only [f.eq_on_source hs, (∘), f.to_times_cont_diff_bump.one_of_mem_closed_ball hd]
intros
ext p : 1
{ ext p : 1, simp only [tangent_map_within, tangent_map] with mfld_simps }
simp only [tangent_map_within, tangent_map] with mfld_simps
intros
simp [fs.apply_ind x hx]
intros
rw [← ext_chart_at_map_nhds_within' I x hy, map_map, map_congr, map_id]
exact (ext_chart_at I x).left_inv_on.eq_on.eventually_eq_of_mem (ext_chart_at_source_mem_nhds_within' _ _ hy)
intros
rw [times_cont_mdiff_within_at_iff, and.congr_right_iff]
set e := ext_chart_at I x
set e' := ext_chart_at I' (f x)
refine λ hc, times_cont_diff_within_at_congr_nhds _
rw [← e.image_source_inter_eq', ← ext_chart_at_map_nhds_within_eq_image, ← ext_chart_at_map_nhds_within, inter_comm, nhds_within_inter_of_mem]
exact hc (ext_chart_at_source_mem_nhds _ _)
intros
ext
ext; rcases x; refl
ext; rcases x
rcases x
refl
intros
induction h with L₂ L₃ h₁₂ h₂₃ ih
{ exact ⟨0, rfl⟩ }
exact ⟨0, rfl⟩
rcases ih with ⟨n, eq⟩
{ rcases ih with ⟨n, eq⟩, existsi (1 + n), simp [mul_add, eq, (step.length h₂₃).symm, add_assoc] }
existsi (1 + n)
simp [mul_add, eq, (step.length h₂₃).symm, add_assoc]
intros
ext h
rw [mem_stabilizer_iff, ← vadd_left_cancel_iff (-g) , vadd_vadd, vadd_vadd, vadd_vadd, add_left_neg, zero_vadd, ← mem_stabilizer_iff, add_subgroup.mem_map_equiv, add_aut.conj_symm_apply]
intros
rw [smul_smul, mul_left_inv, one_smul]
intros
rw f.lift_mk' hg; exact mul_inv_left hg _ _ _
rw f.lift_mk' hg
exact mul_inv_left hg _ _ _
intros
by_cases bc : b = c
subst bc
{ subst bc, simp [one_mem] }
simp [one_mem]
exact subset_closure (is_three_cycle_swap_mul_swap_same ab ac bc)
intros
rw [←two_le_card_support_cycle_of_iff, ←nat.succ_le_iff]
exact ⟨λ h, or.resolve_left h.eq_or_lt (card_support_ne_one _).symm, zero_lt_two.trans_le⟩
intros
rw [coe_cycle_range_of_le h.le, if_neg h.ne]
intros
simp only [fin_pairs_lt, fin.lt_iff_coe_lt_coe, true_and, mem_attach_fin, mem_range, mem_univ, mem_sigma]
intros
letI : fintype ↥(show set α, from p) := ‹fintype {x // p x}›
exact perm_inv_maps_to_of_maps_to f h hx
intros
rw disjoint_iff_disjoint_support at h ⊢
intros a ha
exact h (mem_inter_of_mem (hf (mem_of_mem_inter_left ha)) (hg (mem_of_mem_inter_right ha)))
intros
ext k
refine exists_congr _
simp [subtype.ext_iff]
intros
haveI : fintype (H : set G) := ‹fintype H›
rw [set_like.ext'_iff, coe_top, ← finset.coe_univ, ← (H : set G).coe_to_finset, finset.coe_inj, ← finset.card_eq_iff_eq_univ, ← h, set.to_finset_card]
congr
intros
rw [vector_span_eq_span_vsub_set_left k (set.mem_range_self i0), ←set.range_comp]
intros
cases is_empty_or_nonempty ι with h h
haveI := h
{ haveI := h, apply affine_independent_of_subsingleton, }
apply affine_independent_of_subsingleton
obtain ⟨i⟩ := h
rw affine_independent_iff_linear_independent_vsub k p i at hai
simp_rw [affine_independent_iff_linear_independent_vsub k (f ∘ p) i, function.comp_app, ← f.linear_map_vsub]
have hf' : f.linear.ker = ⊥
rwa [linear_map.ker_eq_bot, f.injective_iff_linear_injective]
{ rwa [linear_map.ker_eq_bot, f.injective_iff_linear_injective], }
exact linear_independent.map' hai f.linear hf'
intros
simp only [line_map_apply_module]
rw [← lt_sub_iff_add_lt, add_sub_assoc, ← sub_lt_iff_lt_add', ← sub_smul, ← sub_smul, sub_sub_sub_cancel_left, smul_lt_smul_iff_of_pos (sub_pos.2 h)]
apply_instance
intros
rw submodule.span_image
exact submodule.mem_map_of_mem h
intros
rw [ker, eq_bot_iff, map_le_iff_le_comap]
intros
ext
ext; cases i; simp only [prod_apply_inl_fst, sum.elim_inl, linear_map.inl_apply, prod_apply_inr_fst, sum.elim_inr, linear_map.inr_apply, prod_apply_inl_snd, prod_apply_inr_snd, comp_app]
ext; cases i
{ ext; cases i; simp only [prod_apply_inl_fst, sum.elim_inl, linear_map.inl_apply, prod_apply_inr_fst, sum.elim_inr, linear_map.inr_apply, prod_apply_inl_snd, prod_apply_inr_snd, comp_app] }
cases i
simp only [prod_apply_inl_fst, sum.elim_inl, linear_map.inl_apply, prod_apply_inr_fst, sum.elim_inr, linear_map.inr_apply, prod_apply_inl_snd, prod_apply_inr_snd, comp_app]
simp only [prod_apply_inl_fst, sum.elim_inl, linear_map.inl_apply, prod_apply_inr_fst, sum.elim_inr, linear_map.inr_apply, prod_apply_inl_snd, prod_apply_inr_snd, comp_app]
cases i
simp only [prod_apply_inl_fst, sum.elim_inl, linear_map.inl_apply, prod_apply_inr_fst, sum.elim_inr, linear_map.inr_apply, prod_apply_inl_snd, prod_apply_inr_snd, comp_app]
simp only [prod_apply_inl_fst, sum.elim_inl, linear_map.inl_apply, prod_apply_inr_fst, sum.elim_inr, linear_map.inr_apply, prod_apply_inl_snd, prod_apply_inr_snd, comp_app]
intros
rw [sub_eq_add_neg, sub_eq_add_neg, add_left, neg_left]
intros
ext B
{ ext B, rw [bilin_form.to_matrix_apply, bilin_form.to_matrix'_apply, pi.basis_fun_apply, pi.basis_fun_apply] }
rw [bilin_form.to_matrix_apply, bilin_form.to_matrix'_apply, pi.basis_fun_apply, pi.basis_fun_apply]
intros
by_cases H : ∃ (s : finset M), nonempty (basis s 𝕜 M)
haveI : finite_dimensional 𝕜 M
{ haveI : finite_dimensional 𝕜 M, { rcases H with ⟨s, ⟨hs⟩⟩, exact finite_dimensional.of_finset_basis hs }, simp only [← det_to_matrix (finite_dimensional.fin_basis 𝕜 M), linear_equiv.map_smul, fintype.card_fin, det_smul] }
{ rcases H with ⟨s, ⟨hs⟩⟩, exact finite_dimensional.of_finset_basis hs }
rcases H with ⟨s, ⟨hs⟩⟩
exact finite_dimensional.of_finset_basis hs
simp only [← det_to_matrix (finite_dimensional.fin_basis 𝕜 M), linear_equiv.map_smul, fintype.card_fin, det_smul]
classical
{ classical, have : finite_dimensional.finrank 𝕜 M = 0 := finrank_eq_zero_of_not_exists_basis H, simp [coe_det, H, this] }
have : finite_dimensional.finrank 𝕜 M = 0 := finrank_eq_zero_of_not_exists_basis H
simp [coe_det, H, this]
intros
rcases f.range_restrict.exists_right_inverse_of_surjective f.range_range_restrict with ⟨g, hg⟩
have fg : left_inverse f.range_restrict g
from linear_map.congr_fun hg
refine ⟨λ h, _, _⟩
rcases le_dim_iff_exists_linear_independent.1 h with ⟨s, rfl, si⟩
{ rcases le_dim_iff_exists_linear_independent.1 h with ⟨s, rfl, si⟩, refine ⟨g '' s, cardinal.mk_image_eq_lift _ _ fg.injective, _⟩, replace fg : ∀ x, f (g x) = x, by { intro x, convert congr_arg subtype.val (fg x) }, replace si : linear_independent K (λ x : s, f (g x)), by simpa only [fg] using si.map' _ (ker_subtype _), exact si.image_of_comp s g f }
refine ⟨g '' s, cardinal.mk_image_eq_lift _ _ fg.injective, _⟩
replace fg : ∀ x, f (g x) = x
intro x
intro x
{ intro x, convert congr_arg subtype.val (fg x) }
{ intro x, convert congr_arg subtype.val (fg x) }
convert congr_arg subtype.val (fg x)
convert congr_arg subtype.val (fg x)
replace si : linear_independent K (λ x : s, f (g x))
simpa only [fg] using si.map' _ (ker_subtype _)
simpa only [fg] using si.map' _ (ker_subtype _)
exact si.image_of_comp s g f
rintro ⟨s, hsc, si⟩
{ rintro ⟨s, hsc, si⟩, have : linear_independent K (λ x : s, f.range_restrict x), from linear_independent.of_comp (f.range.subtype) (by convert si), convert cardinal_le_dim_of_linear_independent this.image, rw [← cardinal.lift_inj, ← hsc, cardinal.mk_image_eq_of_inj_on_lift], exact inj_on_iff_injective.2 this.injective }
have : linear_independent K (λ x : s, f.range_restrict x)
from linear_independent.of_comp (f.range.subtype) (by convert si)
convert cardinal_le_dim_of_linear_independent this.image
rw [← cardinal.lift_inj, ← hsc, cardinal.mk_image_eq_of_inj_on_lift]
exact inj_on_iff_injective.2 this.injective
intros
rw [← b.to_dual_total_right, b.total_repr]
intros
{ ext, refl }
ext
refl
intros
{ rw ← algebra.top_to_submodule, refl }
rw ← algebra.top_to_submodule
refl
intros
simp
intros
simp [total_apply, finsupp.sum, support_emb_domain, emb_domain_apply]
intros
fsplit
rintros p κ w i' j rfl
{ rintros p κ w i' j rfl, specialize p (range w) i'.coe_range (range_comp_subset_range _ _), rw [range_comp, ←@image_univ _ _ w] at p, exact range_iff_surjective.mp (image_injective.mpr i'.injective p), }
specialize p (range w) i'.coe_range (range_comp_subset_range _ _)
rw [range_comp, ←@image_univ _ _ w] at p
exact range_iff_surjective.mp (image_injective.mpr i'.injective p)
intros p w i' h
{ intros p w i' h, specialize p w (coe : w → M) i' (λ i, ⟨v i, range_subset_iff.mp h i⟩) (by { ext, simp, }), have q := congr_arg (λ s, (coe : w → M) '' s) p.range_eq, dsimp at q, rw [←image_univ, image_image] at q, simpa using q, }
specialize p w (coe : w → M) i' (λ i, ⟨v i, range_subset_iff.mp h i⟩) (by { ext, simp, })
have q := congr_arg (λ s, (coe : w → M) '' s) p.range_eq
dsimp at q
rw [←image_univ, image_image] at q
simpa using q
intros
simp only [charmatrix, pi.sub_apply, scalar_apply_ne _ _ _ h, zero_sub, ring_hom.map_matrix_apply, map_apply, dmatrix.sub_apply]
intros
simp [matrix.det_succ_row_zero, fin.sum_univ_succ]
ring
intros
ext i j
obtain ⟨j', hj'⟩ : ∃ j', j' ≠ j := exists_ne j
apply det_eq_zero_of_column_eq_zero j'
intro j''
simp [update_column_ne hj']
intros
rw [←(inv_eq_left_inv h), ←(inv_eq_left_inv g)]
intros
ext
{ ext, rw [matrix.one_apply, linear_map.to_matrix'_apply, id_apply] }
rw [matrix.one_apply, linear_map.to_matrix'_apply, id_apply]
intros
simp [transvection, matrix.add_mul, ha]
intros
tidy
intros
simpa using (comap_mono bot_le : p.mkq.ker ≤ comap p.mkq p')
intros
rw [h]
intros
refine integral_congr_ae _
filter_upwards [hf.prod_right_ae, hg.prod_right_ae]
intros x h2f h2g
simp [integral_sub h2f h2g]
intros
split
split; intro h
intro h
refine measure.absolutely_continuous.mk (λ S hS₁ hS₂, _)
{ refine measure.absolutely_continuous.mk (λ S hS₁ hS₂, _), obtain ⟨i, hi₁, hi₂, hi₃, hpos, hneg⟩ := s.to_jordan_decomposition_spec, rw [total_variation, measure.add_apply, hpos, hneg, to_measure_of_zero_le_apply _ _ _ hS₁, to_measure_of_le_zero_apply _ _ _ hS₁], rw ← vector_measure.absolutely_continuous.ennreal_to_measure at h, simp [h (measure_mono_null (i.inter_subset_right S) hS₂), h (measure_mono_null (iᶜ.inter_subset_right S) hS₂)], refl }
obtain ⟨i, hi₁, hi₂, hi₃, hpos, hneg⟩ := s.to_jordan_decomposition_spec
rw [total_variation, measure.add_apply, hpos, hneg, to_measure_of_zero_le_apply _ _ _ hS₁, to_measure_of_le_zero_apply _ _ _ hS₁]
rw ← vector_measure.absolutely_continuous.ennreal_to_measure at h
simp [h (measure_mono_null (i.inter_subset_right S) hS₂), h (measure_mono_null (iᶜ.inter_subset_right S) hS₂)]
intro h
refine vector_measure.absolutely_continuous.mk (λ S hS₁ hS₂, _)
{ refine vector_measure.absolutely_continuous.mk (λ S hS₁ hS₂, _), rw ← vector_measure.ennreal_to_measure_apply hS₁ at hS₂, exact null_of_total_variation_zero s (h hS₂) }
rw ← vector_measure.ennreal_to_measure_apply hS₁ at hS₂
exact null_of_total_variation_zero s (h hS₂)
intros
simp only [condexp_ind_L1, hμs, eq_self_iff_true, not_true, ne.def, dif_neg, not_false_iff, and_false]
intros
ext1
refine (coe_fn_comp_Lp' (c • L) f).trans _
refine eventually_eq.trans _ (Lp.coe_fn_smul _ _).symm
refine (L.coe_fn_comp_Lp' f).mono (λ x hx, _)
rw [pi.smul_apply, hx]
refl
intros
{ simp_rw [snorm_ess_sup], exact ess_sup_smul_measure hc, }
simp_rw [snorm_ess_sup]
exact ess_sup_smul_measure hc
intros
haveI : nonempty s := ⟨⟨y₀, h₀⟩⟩
suffices : ∀ n, (nat.cases_on n y₀ (coe ∘ dense_seq s) : α) ∈ s
apply this
{ apply this }
rintro (_|n)
exacts [h₀, subtype.mem _]
intros
rcases l with ⟨l⟩
{ rcases l with ⟨l⟩, simpa using l.ae_measurable_prod' (by simpa using hl) }
simpa using l.ae_measurable_prod' (by simpa using hl)
intros
simp [interval_integral]
intros
by_cases hc : c = 0; simp [hc]
by_cases hc : c = 0
simp [hc]
simp [hc]
intros
ext1
refine (ae_restrict_of_ae (Lp.coe_fn_smul c f)).mp _
refine (mem_ℒp.coe_fn_to_Lp ((Lp.mem_ℒp f).restrict s)).mp _
refine (mem_ℒp.coe_fn_to_Lp ((Lp.mem_ℒp (c • f)).restrict s)).mp _
refine (Lp.coe_fn_smul c (mem_ℒp.to_Lp f ((Lp.mem_ℒp f).restrict s))).mono (λ x hx1 hx2 hx3 hx4, _)
rw [hx2, hx1, pi.smul_apply, hx3, hx4, pi.smul_apply]
intros
assume t ht
have : g ⁻¹' t = (g ⁻¹' t ∩ {x | f x = g x}ᶜ) ∪ (g ⁻¹' t ∩ {x | f x = g x})
simp [← inter_union_distrib_left]
simp [← inter_union_distrib_left]
rw this
apply measurable_set.union (h.mono (inter_subset_right _ _)).measurable_set
have : g ⁻¹' t ∩ {x : α | f x = g x} = f ⁻¹' t ∩ {x : α | f x = g x}
ext x
ext x
{ ext x, simp {contextual := tt} }
{ ext x, simp {contextual := tt} }
simp {contextual := tt}
simp {contextual := tt}
rw this
exact (hf ht).inter h.measurable_set.of_compl
intros
refine le_antisymm _ (zero_le _)
rw ←μ.empty
refine bsupr_le (λ K hK, _)
have : K = ⊥
ext1
{ ext1, rw [subset_empty_iff.mp hK, compacts.bot_val] }
rw [subset_empty_iff.mp hK, compacts.bot_val]
rw this
refl'
intros
let eval : (compacts G → ℝ) → ℝ := λ f, f ⟨K₀.1, K₀.2.1⟩
have : continuous eval := continuous_apply _
show chaar K₀ ∈ eval ⁻¹' {(1 : ℝ)}
apply mem_of_subset_of_mem _ (chaar_mem_cl_prehaar K₀ ⟨set.univ, is_open_univ, mem_univ _⟩)
unfold cl_prehaar
rw is_closed.closure_subset_iff
rintro _ ⟨U, ⟨h1U, h2U, h3U⟩, rfl⟩
{ rintro _ ⟨U, ⟨h1U, h2U, h3U⟩, rfl⟩, apply prehaar_self, rw h2U.interior_eq, exact ⟨1, h3U⟩ }
apply prehaar_self
rw h2U.interior_eq
exact ⟨1, h3U⟩
apply continuous_iff_is_closed.mp this
{ apply continuous_iff_is_closed.mp this, exact is_closed_singleton }
exact is_closed_singleton
intros
rcases h.eq_or_lt with rfl|h
exact le_rfl
{ exact le_rfl }
cases hausdorff_measure_zero_or_top h s with hs hs
{ rw hs, exact zero_le _ }
rw hs
exact zero_le _
{ rw hs, exact le_top }
rw hs
exact le_top
intros
simp only [ae_iff] at h ⊢
simpa [set_of_and, inter_comm] using measure_inter_eq_zero_of_restrict h
intros
intro t
by_cases ht : (0 : β) ∈ t
rw mem_map_indicator_ae_iff_mem_map_restrict_ae_of_zero_mem ht hs
{ rw mem_map_indicator_ae_iff_mem_map_restrict_ae_of_zero_mem ht hs, exact id, }
exact id
rw [mem_map_indicator_ae_iff_of_zero_nmem ht, mem_map_restrict_ae_iff hs]
exact λ h, measure_mono_null ((set.inter_subset_left _ _).trans (set.subset_union_left _ _)) h
intros
refine le_infi _
intro h₂
have := extend_union measurable_set.empty m0 measurable_set.Union mU disjoint_diff h₁ (h₂.diff h₁)
rw union_diff_cancel hs at this
rw ← extend_eq m
exact le_iff_exists_add.2 ⟨_, this⟩
intros
by_cases hf : measurable f
refine mk (λ s hs hws, _)
{ refine mk (λ s hs hws, _), rw map_apply _ hf hs at hws ⊢, exact h hws }
rw map_apply _ hf hs at hws ⊢
exact h hws
intros s hs
{ intros s hs, rw [map_not_measurable v hf, zero_apply] }
rw [map_not_measurable v hf, zero_apply]
intros
{ congr, exact h }
congr
exact h
ext
simp only [finset.not_mem_empty, nat.dvd_one, not_and, not_lt, mem_proper_divisors, iff_false]
apply ge_of_eq
intros
by_cases hn : n = 0
{ subst hn, simp at not_dvd, trivial, }
subst hn
simp at not_dvd
trivial
rw padic_val_nat_def hn
{ rw padic_val_nat_def hn, exact (@multiplicity.unique' _ _ _ p n 0 (by simp) (by simpa using not_dvd)).symm, assumption, }
exact (@multiplicity.unique' _ _ _ p n 0 (by simp) (by simpa using not_dvd)).symm
assumption
intros
simp [cast_eq_of_rat]
intros
have : (p : ℝ) ^ (-n : ℤ) = ↑((p ^ (-n : ℤ) : ℚ))
simp
{simp}
rw [show (k : ℚ_[p]) = ((k : ℚ) : ℚ_[p]), by norm_cast, eq_padic_norm, this]
norm_cast
rw padic_norm.dvd_iff_norm_le
intros
ext1 r
apply eq_of_forall_dist_le
intros ε hε
obtain ⟨n, hn⟩ := exists_pow_neg_lt p hε
apply le_trans _ (le_of_lt hn)
rw [dist_eq_norm, norm_le_pow_iff_mem_span_pow, ← ker_to_zmod_pow, ring_hom.mem_ker, ring_hom.map_sub, ← ring_hom.comp_apply, ← ring_hom.comp_apply, lift_spec, hg, sub_self]
intros
have := pell_zd_succ_succ a1 n
unfold pell_zd at this
rw [← int.cast_coe_nat, zsqrtd.smul_val] at this
injection this with h₁ h₂
split
split; apply int.coe_nat_inj; [simpa using h₁, simpa using h₂]
split; apply int.coe_nat_inj
apply int.coe_nat_inj
simpa using h₁
apply int.coe_nat_inj
simpa using h₂
intros
by_cases h0 : int.gcd x y = 0
have hx : x = 0
{ have hx : x = 0, { apply int.nat_abs_eq_zero.mp, apply nat.eq_zero_of_gcd_eq_zero_left h0 }, have hy : y = 0, { apply int.nat_abs_eq_zero.mp, apply nat.eq_zero_of_gcd_eq_zero_right h0 }, have hz : z = 0, { simpa only [pythagorean_triple, hx, hy, add_zero, zero_eq_mul, mul_zero, or_self] using h }, simp only [hz, dvd_zero], }
apply int.nat_abs_eq_zero.mp
{ apply int.nat_abs_eq_zero.mp, apply nat.eq_zero_of_gcd_eq_zero_left h0 }
apply nat.eq_zero_of_gcd_eq_zero_left h0
have hy : y = 0
apply int.nat_abs_eq_zero.mp
{ apply int.nat_abs_eq_zero.mp, apply nat.eq_zero_of_gcd_eq_zero_right h0 }
apply nat.eq_zero_of_gcd_eq_zero_right h0
have hz : z = 0
simpa only [pythagorean_triple, hx, hy, add_zero, zero_eq_mul, mul_zero, or_self] using h
{ simpa only [pythagorean_triple, hx, hy, add_zero, zero_eq_mul, mul_zero, or_self] using h }
simp only [hz, dvd_zero]
obtain ⟨k, x0, y0, k0, h2, rfl, rfl⟩ : ∃ (k : ℕ) x0 y0, 0 < k ∧ int.gcd x0 y0 = 1 ∧ x = x0 * k ∧ y = y0 * k := int.exists_gcd_one' (nat.pos_of_ne_zero h0)
rw [int.gcd_mul_right, h2, int.nat_abs_of_nat, one_mul]
rw [← int.pow_dvd_pow_iff (dec_trivial : 0 < 2), sq z, ← h.eq]
rw (by ring : x0 * k * (x0 * k) + y0 * k * (y0 * k) = k ^ 2 * (x0 * x0 + y0 * y0))
exact dvd_mul_right _ _
intros
intros x y k
contrapose k
rw [←ne.def, ne_iff_lt_or_gt] at k
cases k
{ apply h _ _ k }
apply h _ _ k
rw eq_comm
{ rw eq_comm, apply h _ _ k }
apply h _ _ k
intros
rw [sdiff_inf, sdiff_self, sup_bot_eq]
intros
rw [supr_insert, supr_singleton]
intros
obtain ⟨k : ℕ, hkn : k ≤ N, hku : ∀ l ≤ N, u l ≤ u k⟩ : ∃ k ≤ N, ∀ l ≤ N, u l ≤ u k
from exists_max_image _ u (finite_le_nat N) ⟨N, le_refl N⟩
have ex : ∃ n ≥ N, u k < u n
from exists_lt_of_tendsto_at_top hu _ _
obtain ⟨n : ℕ, hnN : n ≥ N, hnk : u k < u n, hn_min : ∀ m, m < n → N ≤ m → u m ≤ u k⟩ : ∃ n ≥ N, u k < u n ∧ ∀ m, m < n → N ≤ m → u m ≤ u k
rcases nat.find_x ex with ⟨n, ⟨hnN, hnk⟩, hn_min⟩
{ rcases nat.find_x ex with ⟨n, ⟨hnN, hnk⟩, hn_min⟩, push_neg at hn_min, exact ⟨n, hnN, hnk, hn_min⟩ }
push_neg at hn_min
exact ⟨n, hnN, hnk, hn_min⟩
use [n, hnN]
rintros (l : ℕ) (hl : l < n)
have hlk : u l ≤ u k
cases (le_total l N : l ≤ N ∨ N ≤ l) with H H
{ cases (le_total l N : l ≤ N ∨ N ≤ l) with H H, { exact hku l H }, { exact hn_min l hl H } }
{ exact hku l H }
exact hku l H
{ exact hn_min l hl H }
exact hn_min l hl H
calc u l ≤ u k : hlk ... < u n : hnk
intros
{ rw ← prod_at_top_at_top_eq, exact hf.prod_map_prod_at_top hg, }
rw ← prod_at_top_at_top_eq
exact hf.prod_map_prod_at_top hg
intros
simp [filter.prod]
intros
rw is_extr_filter at *
rwa [← heq.is_max_filter_iff hfga, ← heq.is_min_filter_iff hfga]
intros
refine iff.trans ⟨λ h, h.1, λ h, ⟨h⟩⟩ _
simp [lift'_principal monotone_powerset, -mem_prod, -prod.forall, forall_prod_set]
intros
simp only [filter.lift, tendsto_infi]
intros
refine ⟨λ H f hf, H f f.ne_bot hf, _⟩
introsI H f hf hfg
exact hp (of_le f) (H _ ((of_le f).trans hfg))
intros
simp [is_bounded, eq_univ_iff_forall]
intros
{ simp [subtype.order_iso_of_nat] }
simp [subtype.order_iso_of_nat]
intros
cases IF.F.nonempty
apply is_proper_of_not_mem (_ : w ∉ IF.I)
rwa ← IF.compl_I_eq_F at h
intros
exactI {..f.is_trichotomous, ..f.is_strict_order}
intros
rw [symm_diff_symm_diff_left, symm_diff_symm_diff_right]
intros
rw [is_wf, well_founded_on_iff] at *
refine subrelation.wf (λ x y xy, _) h
exact ⟨xy.1, st xy.2.1, st xy.2.2⟩
intros
intros a _ b _ hab
obtain h | h | h := @trichotomous _ r _ a b
{ exact or.inl h }
exact or.inl h
{ exact (hab h).elim }
exact (hab h).elim
{ exact or.inr h }
exact or.inr h
intros
rw is_artinian_iff_well_founded at h ⊢
refine (submodule.restrict_scalars_embedding R S M).well_founded h
intros
{ rw add_comm at h, exact h.of_add_mul_right_right }
rw add_comm at h
exact h.of_add_mul_right_right
intros
rw [eq_C_of_degree_le_zero (nat_degree_eq_zero_iff_degree_le_zero.1 hpm), is_unit_C]
refine hu _ _
rw [← eq_C_of_degree_le_zero (nat_degree_eq_zero_iff_degree_le_zero.1 hpm)]
exact dvd_mul_right _ _
intros
refine ⟨λ h, _, λ h, submodule.subset_span $ set.mem_image_of_mem (of R M) h⟩
rw [of', ← finsupp.supported_eq_span_single, finsupp.mem_supported, finsupp.support_single_ne_zero (@one_ne_zero R _ (by apply_instance))] at h
simpa using h
intros
apply (x.is_wf_support.is_pwo.add_submonoid_closure (λ g hg, _)).mono _
exact with_top.coe_le_coe.1 (le_trans (le_of_lt hx) (add_val_le_of_coeff_ne_zero hg))
{ exact with_top.coe_le_coe.1 (le_trans (le_of_lt hx) (add_val_le_of_coeff_ne_zero hg)) }
refine set.Union_subset (λ n, _)
induction n with n ih; intros g hn
induction n with n ih
intros g hn
simp only [exists_prop, and_true, set.mem_singleton_iff, set.set_of_eq_eq_singleton, mem_support, ite_eq_right_iff, ne.def, not_false_iff, one_ne_zero, pow_zero, not_forall, one_coeff] at hn
{ simp only [exists_prop, and_true, set.mem_singleton_iff, set.set_of_eq_eq_singleton, mem_support, ite_eq_right_iff, ne.def, not_false_iff, one_ne_zero, pow_zero, not_forall, one_coeff] at hn, rw [hn, set_like.mem_coe], exact add_submonoid.zero_mem _ }
rw [hn, set_like.mem_coe]
exact add_submonoid.zero_mem _
intros g hn
obtain ⟨i, j, hi, hj, rfl⟩ := support_mul_subset_add_support hn
{ obtain ⟨i, j, hi, hj, rfl⟩ := support_mul_subset_add_support hn, exact set_like.mem_coe.2 (add_submonoid.add_mem _ (add_submonoid.subset_closure hi) (ih hj)) }
exact set_like.mem_coe.2 (add_submonoid.add_mem _ (add_submonoid.subset_closure hi) (ih hj))
intros
ext g'
by_cases h : g' = f g
{ simp [h] }
simp [h]
rw [emb_domain_notin_image_support, single_coeff_of_ne h]
by_cases hr : r = 0
{ simp [hr] }
simp [hr]
rwa [support_single_of_ne hr, set.image_singleton, set.mem_singleton_iff]
intros
rcases h with ⟨p, ⟨hp, hp'⟩⟩
refine ⟨p, ⟨hp, _⟩⟩
rw [is_scalar_tower.algebra_map_eq R A B, ← eval₂_map, eval₂_hom, ← ring_hom.map_zero (algebra_map A B)] at hp'
rw [eval₂_eq_eval_map]
exact H hp'
intros
rw [coe_submodule, submodule.map_bot]
intros
rw ← neg_right_iff at h_comm
rw ← is_nilpotent_neg_iff at hy
rw sub_eq_add_neg
exact h_comm.is_nilpotent_add hx hy
intros
rw [is_noetherian_ring_iff, is_noetherian_iff_well_founded] at H ⊢
exact order_embedding.well_founded (ideal.order_embedding_of_surjective f hf).dual H
intros
{ ext i, simp }
ext i
simp
intros
dsimp [bernstein_polynomial]
simp [polynomial.derivative_pow]
intros
rw [content, content, finset.gcd_def, finset.gcd_def]
refine congr rfl _
have h : (X * p).support = p.support.map ⟨nat.succ, nat.succ_injective⟩
{ ext a, simp only [exists_prop, finset.mem_map, function.embedding.coe_fn_mk, ne.def, mem_support_iff], cases a, { simp [coeff_X_mul_zero, nat.succ_ne_zero] }, rw [mul_comm, coeff_mul_X], split, { intro h, use a, simp [h] }, { rintros ⟨b, ⟨h1, h2⟩⟩, rw ← nat.succ_injective h2, apply h1 } }
ext a
simp only [exists_prop, finset.mem_map, function.embedding.coe_fn_mk, ne.def, mem_support_iff]
cases a
{ simp [coeff_X_mul_zero, nat.succ_ne_zero] }
simp [coeff_X_mul_zero, nat.succ_ne_zero]
rw [mul_comm, coeff_mul_X]
split
intro h
{ intro h, use a, simp [h] }
use a
simp [h]
rintros ⟨b, ⟨h1, h2⟩⟩
{ rintros ⟨b, ⟨h1, h2⟩⟩, rw ← nat.succ_injective h2, apply h1 }
rw ← nat.succ_injective h2
apply h1
rw h
simp only [finset.map_val, function.comp_app, function.embedding.coe_fn_mk, multiset.map_map]
refine congr (congr rfl _) rfl
ext a
rw mul_comm
simp [coeff_mul_X]
intros
apply splits_prod (ring_hom.id K)
intros z hz
simp only [splits_X_sub_C (ring_hom.id K)]
intros
rw [cyclotomic_eq_minpoly (is_primitive_root_exp n hpos.ne') hpos]
apply minpoly.irreducible
exact (is_primitive_root_exp n hpos.ne').is_integral hpos
intros
ext1 d
suffices : φ.total_degree < d.support.sum d → 0 = coeff d φ
simpa [coeff_sum, coeff_homogeneous_component]
simpa [coeff_sum, coeff_homogeneous_component]
exact λ h, (coeff_eq_zero_of_total_degree_lt h).symm
intros
ext (_ | n)
simp only [ring_hom.map_add, constant_coeff_C, constant_coeff_X, coeff_zero_eq_constant_coeff, zero_add, mul_zero, ring_hom.map_mul]
{ simp only [ring_hom.map_add, constant_coeff_C, constant_coeff_X, coeff_zero_eq_constant_coeff, zero_add, mul_zero, ring_hom.map_mul], }
simp only [coeff_succ_mul_X, coeff_mk, linear_map.map_add, coeff_C, n.succ_ne_zero, sub_zero, if_false, add_zero]
{ simp only [coeff_succ_mul_X, coeff_mk, linear_map.map_add, coeff_C, n.succ_ne_zero, sub_zero, if_false, add_zero], }
intros
have : ¬single s 1 ≤ 0
from λ h, by simpa using h s
simp only [X, coeff_monomial_mul, if_neg this]
intros
rw [← coeff_zero_eq_constant_coeff_apply, coeff_inv_units_sub, zero_add, pow_one]
intros
{ ext, simp [base_change_eq_ltensor], }
ext
simp [base_change_eq_ltensor]
intros
map_fun_tac
intros
simp only [witt_structure_rat, bind₁, map_aeval, X_in_terms_of_W_zero, constant_coeff_rename, constant_coeff_witt_polynomial, aeval_X, constant_coeff_comp_algebra_map, eval₂_hom_zero', ring_hom.id_apply]
intros
{ ext i, rw [coeff_mk] }
ext i
rw [coeff_mk]
intros
simp
intros
rw [to_enat_apply_of_lt_omega (nat_lt_omega n), to_nat_cast]
intros
{ rw [add_comm, add_eq_left_iff] }
rw [add_comm, add_eq_left_iff]
intros
cases infinite_pigeonhole_card f θ hθ h₁ h₂ with a ha
refine ⟨a, {x | ∃(h : x ∈ s), f ⟨x, h⟩ = a}, _, _, _⟩
{ rintro x ⟨hx, hx'⟩, exact hx }
rintro x ⟨hx, hx'⟩
exact hx
refine le_trans ha _
{ refine le_trans ha _, apply ge_of_eq, apply quotient.sound, constructor, refine equiv.trans _ (equiv.subtype_subtype_equiv_subtype_exists _ _).symm, simp only [set_coe_eq_subtype, mem_singleton_iff, mem_preimage, mem_set_of_eq] }
apply ge_of_eq
apply quotient.sound
constructor
refine equiv.trans _ (equiv.subtype_subtype_equiv_subtype_exists _ _).symm
simp only [set_coe_eq_subtype, mem_singleton_iff, mem_preimage, mem_set_of_eq]
rintro x ⟨hx, hx'⟩
exact hx'
intros
refl
intros
rw [list.sorted, list.pairwise_map]; exact CNF_pairwise b o
rw [list.sorted, list.pairwise_map]
exact CNF_pairwise b o
intros
simp only [le_antisymm_iff, H.le_iff]
intros
rw le_def
dsimp
simp [forall_pempty, exists_pempty]
intros
simp [left_distrib, *]
intros
simp *
intros
rw [← h, ← hm, int.add_mul_div_right _ _ (ne_of_gt (lt_of_le_of_lt h₁ h₂)), int.div_eq_zero_of_lt h₁ h₂, zero_add]
intros
simp [pra, prt]
intros
cases t with b as
simp only [val, neg_add, neg, val, coeffs.val_neg]
intros
cc
intros
simp [is_open_def, h]
intros
simp only [has_sum, tendsto, hg.map_at_top_finset_sum_eq hf]
intros
erw [← tsum_prod' h h₁, ← tsum_prod' h.prod_symm h₂, ← (equiv.prod_comm β γ).tsum_eq]
refl
assumption
intros
rw [← coe_id, coe_inj]
intros
rw mem_nhds_within_Ici_iff_exists_Ico_subset
split
rintros ⟨u, au, as⟩
{ rintros ⟨u, au, as⟩, rcases exists_between au with ⟨v, hv⟩, exact ⟨v, hv.1, λx hx, as ⟨hx.1, lt_of_le_of_lt hx.2 hv.2⟩⟩ }
rcases exists_between au with ⟨v, hv⟩
exact ⟨v, hv.1, λx hx, as ⟨hx.1, lt_of_le_of_lt hx.2 hv.2⟩⟩
rintros ⟨u, au, as⟩
{ rintros ⟨u, au, as⟩, exact ⟨u, au, subset.trans Ico_subset_Icc_self as⟩ }
exact ⟨u, au, subset.trans Ico_subset_Icc_self as⟩
intros
rcases eq_empty_or_nonempty (Iio b) with (hb'|⟨a, ha⟩)
rw [filter_eq_bot_of_is_empty at_top, map_bot, hb', nhds_within_empty]
{ rw [filter_eq_bot_of_is_empty at_top, map_bot, hb', nhds_within_empty], exact ⟨λ x, hb'.subset (hb x.2)⟩ }
exact ⟨λ x, hb'.subset (hb x.2)⟩
rw [← comap_coe_nhds_within_Iio_of_Ioo_subset hb (λ _, hs a ha), map_comap_of_mem]
{ rw [← comap_coe_nhds_within_Iio_of_Ioo_subset hb (λ _, hs a ha), map_comap_of_mem], rw subtype.range_coe, exact (mem_nhds_within_Iio_iff_exists_Ioo_subset' ha).2 (hs a ha) }
rw subtype.range_coe
exact (mem_nhds_within_Iio_iff_exists_Ioo_subset' ha).2 (hs a ha)
intros
casesI is_empty_or_nonempty ι
exacts [tendsto_of_is_empty, tendsto_at_top_is_lub h_mono (is_lub_csupr hbdd)]
intros
rcases second_countable_topology.is_open_generated_countable β with ⟨b, hb, eq⟩
refine { is_open_generated_countable := ⟨preimage f '' b, hb.image _, _⟩ }
rw [eq, induced_generate_from_eq]
intros
by_cases p; simp *
by_cases p
simp *
simp *
intros
split
split; intro h
intro h
intros u v hu hv hs huv
{ intros u v hu hv hs huv, rw is_preconnected_closed_iff at h, specialize h u v hu hv hs, contrapose! huv, rw ne_empty_iff_nonempty, simp [not_subset] at huv, rcases huv with ⟨⟨x, hxs, hxu⟩, ⟨y, hys, hyv⟩⟩, have hxv : x ∈ v := or_iff_not_imp_left.mp (hs hxs) hxu, have hyu : y ∈ u := or_iff_not_imp_right.mp (hs hys) hyv, exact h ⟨y, hys, hyu⟩ ⟨x, hxs, hxv⟩ }
rw is_preconnected_closed_iff at h
specialize h u v hu hv hs
contrapose! huv
rw ne_empty_iff_nonempty
simp [not_subset] at huv
rcases huv with ⟨⟨x, hxs, hxu⟩, ⟨y, hys, hyv⟩⟩
have hxv : x ∈ v := or_iff_not_imp_left.mp (hs hxs) hxu
have hyu : y ∈ u := or_iff_not_imp_right.mp (hs hys) hyv
exact h ⟨y, hys, hyu⟩ ⟨x, hxs, hxv⟩
intro h
rw is_preconnected_closed_iff
{ rw is_preconnected_closed_iff, intros u v hu hv hs hsu hsv, rw ← ne_empty_iff_nonempty, intro H, specialize h u v hu hv hs H, contrapose H, apply ne_empty_iff_nonempty.mpr, cases h, { rcases hsv with ⟨x, hxs, hxv⟩, exact ⟨x, hxs, ⟨h hxs, hxv⟩⟩ }, { rcases hsu with ⟨x, hxs, hxu⟩, exact ⟨x, hxs, ⟨hxu, h hxs⟩⟩ } }
intros u v hu hv hs hsu hsv
rw ← ne_empty_iff_nonempty
intro H
specialize h u v hu hv hs H
contrapose H
apply ne_empty_iff_nonempty.mpr
cases h
{ rcases hsv with ⟨x, hxs, hxv⟩, exact ⟨x, hxs, ⟨h hxs, hxv⟩⟩ }
rcases hsv with ⟨x, hxs, hxv⟩
exact ⟨x, hxs, ⟨h hxs, hxv⟩⟩
{ rcases hsu with ⟨x, hxs, hxu⟩, exact ⟨x, hxs, ⟨hxu, h hxs⟩⟩ }
rcases hsu with ⟨x, hxs, hxu⟩
exact ⟨x, hxs, ⟨hxu, h hxs⟩⟩
intros
rw [is_open_iff_nhds]
simp_rw [le_principal_iff, prod.forall, ((nhds_basis_opens _).prod_nhds (nhds_basis_opens _)).mem_iff, prod.exists, exists_prop]
simp only [and_assoc, and.left_comm]
intros
rw polynomial_comp_attach_bound
apply set_like.coe_mem
intros
have : s = univ ∩ s
rw univ_inter
rw univ_inter
rwa [this, continuous_within_at_inter hs, continuous_within_at_univ] at h
intros
ext
{ ext, refl }
refl
intros
have := (e.coe_fst (e.to_local_equiv.map_target hx)).symm
rwa [← e.coe_coe, e.to_local_equiv.right_inv hx] at this
intros
apply continuous_of_le_add_edist 2 (by norm_num)
rintros ⟨x, y⟩ ⟨x', y'⟩
calc edist x y ≤ edist x x' + edist x' y' + edist y' y : edist_triangle4 _ _ _ _ ... = edist x' y' + (edist x x' + edist y y') : by simp [edist_comm]; cc ... ≤ edist x' y' + (edist (x, y) (x', y') + edist (x, y) (x', y')) : add_le_add_left (add_le_add (le_max_left _ _) (le_max_right _ _)) _ ... = edist x' y' + 2 * edist (x, y) (x', y') : by rw [← mul_two, mul_comm]
intros
refine ⟨λ h, _, λ h, tendsto.comp (ennreal.tendsto_to_real hx) h⟩
have h_eq : f = (λ n, ennreal.of_real (f n).to_real)
ext1 n
ext1 n
{ ext1 n, rw ennreal.of_real_to_real (hf n), }
{ ext1 n, rw ennreal.of_real_to_real (hf n), }
rw ennreal.of_real_to_real (hf n)
rw ennreal.of_real_to_real (hf n)
rw [h_eq, ← ennreal.of_real_to_real hx]
exact ennreal.tendsto_of_real h
intros
rw [trans_of_set, restr_source_inter]
intros
rw bInter_eq_Inter
haveI := hS.to_encodable
exact dense_Inter_of_Gδ (λ s, ho s s.2) (λ s, hd s s.2)
intros
{ rw [add_right_comm, dist_comm y₁], apply dist_triangle4 }
rw [add_right_comm, dist_comm y₁]
apply dist_triangle4
intros
simpa only [dist_nndist, nnreal.coe_eq] using dist_comm x y
intros
rw [continuous_within_at, tendsto_nhds_within_nhds]
intros
simp only [← tendsto_uniformly_on_univ, tendsto_uniformly_on_iff, mem_univ, forall_const]
intros
rw [sUnion_eq_bUnion, dimH_bUnion hS]
intros
rw continuous_def at h₁ h₂ ⊢
assume s h
exact ⟨h₁ s h, h₂ s h⟩
intros
simp
intros
constructor
rintros x - y - hxy
obtain ⟨u, v, hu, hv, xu, yv, disj⟩ := t2_separation hxy
obtain ⟨w, hw : is_clopen w, xw, wu⟩ := (is_topological_basis.mem_nhds_iff h).1 (is_open.mem_nhds hu xu)
refine ⟨w, wᶜ, hw.1, (is_clopen_compl_iff.2 hw).1, xw, _, _, set.inter_compl_self w⟩
intro h
{ intro h, have : y ∈ u ∩ v := ⟨wu h, yv⟩, rwa disj at this }
have : y ∈ u ∩ v := ⟨wu h, yv⟩
rwa disj at this
rw set.union_compl_self
intros
simpa only [inter_univ] using hf.finite_nonempty_inter_compact compact_univ
intros
rw [continuous_at, tendsto_nhds_left]
intros
rw [nhds_eq_comap_uniformity, mem_comap]
exact iff.rfl
intros
have : ∀ n, ∃ N, ∀ k ≥ N, ∀ l ≥ k, (u l, u k) ∈ V n
intro n
{ intro n, rw [cauchy_seq_iff] at hu, rcases hu _ (hV n) with ⟨N, H⟩, exact ⟨N, λ k hk l hl, H _ (le_trans hk hl) _ hk ⟩ }
rw [cauchy_seq_iff] at hu
rcases hu _ (hV n) with ⟨N, H⟩
exact ⟨N, λ k hk l hl, H _ (le_trans hk hl) _ hk ⟩
obtain ⟨φ : ℕ → ℕ, φ_extr : strict_mono φ, hφ : ∀ n, ∀ l ≥ φ n, (u l, u $ φ n) ∈ V n⟩ := extraction_forall_of_eventually' this
exact ⟨φ, φ_extr, λ n, hφ _ _ (φ_extr $ lt_add_one n).le⟩
intros
rw [complete_space_iff_is_complete_univ, ← is_complete_image_iff hf, image_univ]
intros
rw [nth_succ, tail_iterate]
intros
rw [congr_fun linear_order.max_def a, max_default]
intros
cases b; simp
cases b
simp
simp
intros
dunfold sub_nat_nat
rw [nat.sub_eq_zero_of_le]
dunfold sub_nat_nat._match_1
rw [nat.add_sub_cancel_left]
apply nat.le_add_right
intros
rw [h, int.sub_self]
intros
have h := int.add_le_add_right h (-b)
rwa int.add_right_neg at h
intros
have h := int.add_lt_add_left h (-b)
rwa int.neg_add_cancel_left at h
intros
rw [nat.mul_comm x z, nat.mul_comm y z, nat.mul_comm (x % y) z]
rw [nat.mul_comm x z, nat.mul_comm y z, nat.mul_comm (x % y) z]; apply mul_mod_mul_left
apply mul_mod_mul_left
intros
apply nat.sub_lt _ h₀
apply lt_of_lt_of_le h₀ h₁
intros
induction h; [refl, exact le_trans (pred_le _) h_ih]
induction h
refl
exact le_trans (pred_le _) h_ih
intros
by_cases p; simp [h]
by_cases p
simp [h]
simp [h]
intros
rw [vsub_vadd_eq_vsub_sub, vadd_vsub_assoc, vsub_self, add_zero]
intros
{ ext, refl }
ext
refl
intros
rw submodule.mul_le
intros m hm n hn
rw [submodule.mem_div_iff_forall_mul_mem] at hn
rw mul_comm
exact hn m hm
intros
{ ext, refl }
ext
refl
intros
split
rintro rfl
{ rintro rfl, apply not_lt_of_le _ hlt, apply dvd_zero }
apply not_lt_of_le _ hlt
apply dvd_zero
rcases hlt with ⟨⟨x, rfl⟩, ndvd⟩
refine ⟨x, _, rfl⟩
contrapose! ndvd
rcases ndvd with ⟨u, rfl⟩
simp
intros
simp only [card_eq_sum_ones, sum_fiberwise_of_maps_to H]
intros
rw [← prod_sdiff h, prod_eq_one hg, one_mul]
exact prod_congr rfl hfg
intros
split_ifs
exact finprod_eq_prod_of_mul_support_to_finset_subset _ h (finset.subset.refl _)
{ exact finprod_eq_prod_of_mul_support_to_finset_subset _ h (finset.subset.refl _) }
rw [finprod, dif_neg]
{ rw [finprod, dif_neg], rw [mul_support_comp_eq_preimage], exact mt (λ hf, hf.of_preimage equiv.plift.surjective) h}
rw [mul_support_comp_eq_preimage]
exact mt (λ hf, hf.of_preimage equiv.plift.surjective) h
intros
rw [← finprod_mem_inter_mul_diff' _ ht, inter_eq_self_of_subset_right hst]
intros
rw [mono_iff_ker_eq_bot, linear_map.ker_eq_bot]
intros
apply tensor_product.ext_threefold
intros x y z
refl
intros
simp [nth_cont_eq_succ_nth_cont_aux, (continuants_aux_recurrence nth_s_eq nth_conts_aux_eq succ_nth_conts_aux_eq)]
intros
refl
intros
{ rw gcd, split_ifs; simp only [h, zero_mod, gcd_zero_left] }
rw gcd
split_ifs
split_ifs; simp only [h, zero_mod, gcd_zero_left]
simp only [h, zero_mod, gcd_zero_left]
simp only [h, zero_mod, gcd_zero_left]
intros
rw [(mul_sub_left_distrib (1 / a)), (one_div_mul_cancel ha), mul_sub_right_distrib, one_mul, mul_assoc, (mul_one_div_cancel hb), mul_one]
intros
rw [← function.comp_app (lift R f) (of R) x, of_comp_lift]
intros
have := (h.sub_left (commute.refl y)).geom_sum₂_mul_add n
rw [sub_add_cancel] at this
rw [← this, add_sub_cancel]
intros
rw [div_eq_mul_inv, div_eq_mul_inv, mul_assoc _ _ _]
intros
rw [f.map_mul, f.map_inv]
intros
{ rcases h with ⟨⟨a, b, _, hba⟩, rfl⟩, exact ⟨b, hba⟩ }
rcases h with ⟨⟨a, b, _, hba⟩, rfl⟩
exact ⟨b, hba⟩
intros
ext x
{ ext x, rw [← mul_one x, ← smul_eq_mul R, f.map_smul, g.map_smul, h], }
rw [← mul_one x, ← smul_eq_mul R, f.map_smul, g.map_smul, h]
intros
ring
intros
induction k with k ih; [refl, rw [pow_succ', int.nat_abs_mul, pow_succ', ih]]
induction k with k ih
refl
rw [pow_succ', int.nat_abs_mul, pow_succ', ih]
intros
rw [sq, int.nat_abs_mul_self', sq]
intros
rw [←pow_abs, abs_neg, abs_one, one_pow]
intros
by_cases hc : c = 0; [simp [hc], simp [mul_left_inj', hc]]
by_cases hc : c = 0
simp [hc]
simp [mul_left_inj', hc]
intros
tidy
intros
have P : ∀ h : j' = j, C.d i j' ≫ eq_to_hom (congr_arg C.X h) = C.d i j
{ rintro rfl, simp }
rintro rfl
simp
apply P
intros
by_cases hij : c.rel i j
by_cases hjk : c.rel j k
{ by_cases hjk : c.rel j k, { exact C.d_comp_d' i j k hij hjk }, { rw [C.shape j k hjk, comp_zero] } }
{ exact C.d_comp_d' i j k hij hjk }
exact C.d_comp_d' i j k hij hjk
{ rw [C.shape j k hjk, comp_zero] }
rw [C.shape j k hjk, comp_zero]
{ rw [C.shape i j hij, zero_comp] }
rw [C.shape i j hij, zero_comp]
intros
{ simp [homology.π, homology.map], }
simp [homology.π, homology.map]
intros
by_cases hij : j = i
simp only [lie_of_of_eq R ι L hij x y, hij, dif_pos, not_false_iff, lie_algebra_of_apply]
{ simp only [lie_of_of_eq R ι L hij x y, hij, dif_pos, not_false_iff, lie_algebra_of_apply], }
simp only [lie_of_of_ne R ι L hij x y, hij, dif_neg, not_false_iff]
{ simp only [lie_of_of_ne R ι L hij x y, hij, dif_neg, not_false_iff], }
intros
suffices : ∀ (I J : lie_ideal R L), ⁅I, J⁆ ≤ ⁅J, I⁆
exact le_antisymm (this I J) (this J I)
{ exact le_antisymm (this I J) (this J I), }
clear I J
intros I J
rw [lie_ideal_oper_eq_span, lie_span_le]
rintros x ⟨y, z, h⟩
rw ← h
rw [← lie_skew, ← lie_neg, ← submodule.coe_neg]
apply lie_coe_mem_lie
intros
rw [is_ideal_morphism_def, f.ideal_range_eq_top_of_surjective h, f.range_eq_top.mpr h, lie_ideal.top_coe_lie_subalgebra]
intros
rw [neg_smul, smul_neg, neg_neg]
intros
rw [of, monoid_hom.coe_mk, ← finsupp.supported_eq_span_single, finsupp.mem_supported]
intros
{ ext a, exact distrib_mul_action_hom.congr_fun h a, }
ext a
exact distrib_mul_action_hom.congr_fun h a
intros
haveI := classical.dec; exact decidable.ne_iff_lt_iff_le
haveI := classical.dec
exact decidable.ne_iff_lt_iff_le
intros
rw [mul_comm, le_div_iff_of_neg hc]
intros
simpa using inv_lt ha hb
intros
contrapose! h
simpa only [and_comm ((0 : α) < _), lt_sub_iff_add_lt, gt_iff_lt] using exists_add_lt_and_pos_of_lt h
intros
rw [← mul_lt_mul_iff_right a, inv_mul_self, one_mul]
intros
rw [div_eq_mul_inv, div_eq_mul_inv, mul_comm b, mul_inv_le_inv_mul_iff, mul_comm]
exact mul_le_mul' hab hcd
intros
haveI := @linear_order.decidable_le α _; exact ⟨decidable.mul_self_le_mul_self h1, nonneg_le_nonneg_of_sq_le_sq h2⟩
haveI := @linear_order.decidable_le α _
exact ⟨decidable.mul_self_le_mul_self h1, nonneg_le_nonneg_of_sq_le_sq h2⟩
intros
rw [bit0, bit0, ← two_mul, ← two_mul, mul_lt_mul_left (zero_lt_two : 0 < (2:α))]
intros
rw [← image_mul_left', image_one, mul_one]
intros
rw nat_degree_multiset_prod'
simp_rw [ne.def, multiset.prod_eq_zero_iff, multiset.mem_map, leading_coeff_eq_zero]
rintro ⟨_, h, rfl⟩
contradiction
intros
ext
ext; simp; ring_exp
ext; simp
simp
simp
ring_exp
simp
ring_exp
simp
ring_exp
intros
rw [nontrivial_iff, not_iff_comm, is_right_regular_zero_iff_subsingleton, subsingleton_iff]
push_neg
exact iff.rfl
intros
simpa only [sub_eq_add_neg] using h.add_right h'.neg_right
intros
simp
intros
apply topological_space.is_topological_basis_of_open_of_nhds
rintros _ ⟨r, rfl⟩
{ rintros _ ⟨r, rfl⟩, exact is_open_basic_open }
exact is_open_basic_open
rintros p U hp ⟨s, hs⟩
{ rintros p U hp ⟨s, hs⟩, rw [← compl_compl U, set.mem_compl_eq, ← hs, mem_zero_locus, set.not_subset] at hp, obtain ⟨f, hfs, hfp⟩ := hp, refine ⟨basic_open f, ⟨f, rfl⟩, hfp, _⟩, rw [← set.compl_subset_compl, ← hs, basic_open_eq_zero_locus_compl, compl_compl], exact zero_locus_anti_mono (set.singleton_subset_iff.mpr hfs) }
rw [← compl_compl U, set.mem_compl_eq, ← hs, mem_zero_locus, set.not_subset] at hp
obtain ⟨f, hfs, hfp⟩ := hp
refine ⟨basic_open f, ⟨f, rfl⟩, hfp, _⟩
rw [← set.compl_subset_compl, ← hs, basic_open_eq_zero_locus_compl, compl_compl]
exact zero_locus_anti_mono (set.singleton_subset_iff.mpr hfs)
intros
dsimp [δ]
{ dsimp [δ], simp only [←X.map_comp, simplex_category.δ_comp_δ H], }
simp only [←X.map_comp, simplex_category.δ_comp_δ H]
intros
by_cases hK : K = 0
simp only [gronwall_bound_K0, hK, zero_mul, exp_zero, add_zero, mul_one]
{ simp only [gronwall_bound_K0, hK, zero_mul, exp_zero, add_zero, mul_one] }
simp only [gronwall_bound_of_K_ne_0 hK, zero_div, zero_mul, add_zero]
{ simp only [gronwall_bound_of_K_ne_0 hK, zero_div, zero_mul, add_zero] }
intros
convert (hf.tendsto_uniformly_on h).comp (λ y, y - x)
{ simp [(∘)] }
simp [(∘)]
{ ext z, simp [dist_eq_norm] }
ext z
simp [dist_eq_norm]
intros
have : {composition.ones 1} = (finset.univ : finset (composition 1)) := finset.eq_univ_of_card _ (by simp [composition_card])
simp only [formal_multilinear_series.comp, comp_along_composition_apply, ← this, finset.sum_singleton]
refine q.congr (by simp) (λ i hi1 hi2, _)
simp only [apply_composition_ones]
exact p.congr rfl (λ j hj1 hj2, by congr)
intros
refine ((h₁.norm_norm.mul h₂.norm_norm).congr rfl _ _).of_norm_norm
refine ((h₁.norm_norm.mul h₂.norm_norm).congr rfl _ _).of_norm_norm; by intros; simp only [norm_smul]
intros; simp only [norm_smul]
intros; simp only [norm_smul]
intros
intros
simp only [norm_smul]
simp only [norm_smul]
intros; simp only [norm_smul]
intros; simp only [norm_smul]
intros
intros
simp only [norm_smul]
simp only [norm_smul]
intros
unfold is_o
{ unfold is_o, exact forall_congr (λ c, forall_congr (λ hc, e.is_O_with_congr)) }
exact forall_congr (λ c, forall_congr (λ hc, e.is_O_with_congr))
intros
rw ← has_deriv_within_at_univ at *
exact hc.inv hx
intros
simpa only [sub_eq_add_neg] using hf.add_const (-c)
intros
simp only [← fderiv_within_univ, fderiv_within_add_const unique_diff_within_at_univ]
intros
symmetry
rw [tendsto_iff_norm_tendsto_zero]
refine tendsto_congr (λ x', _)
have : ∥x' - x∥⁻¹ ≥ 0
from inv_nonneg.mpr (norm_nonneg _)
simp [norm_smul, real.norm_eq_abs, abs_of_nonneg this]
intros
split
intro hfx
{ intro hfx, by_cases hx : differentiable_at 𝕜 f x, { exact or.inl ⟨hx, hfx⟩ }, { rw [fderiv_zero_of_not_differentiable_at hx] at hfx, exact or.inr ⟨hfx, hx⟩ } }
by_cases hx : differentiable_at 𝕜 f x
{ exact or.inl ⟨hx, hfx⟩ }
exact or.inl ⟨hx, hfx⟩
rw [fderiv_zero_of_not_differentiable_at hx] at hfx
{ rw [fderiv_zero_of_not_differentiable_at hx] at hfx, exact or.inr ⟨hfx, hx⟩ }
exact or.inr ⟨hfx, hx⟩
rintro (⟨hf, hf'⟩|⟨h₀, hx⟩)
{ rintro (⟨hf, hf'⟩|⟨h₀, hx⟩), { exact hf' }, { rwa [fderiv_zero_of_not_differentiable_at hx] } }
{ exact hf' }
exact hf'
{ rwa [fderiv_zero_of_not_differentiable_at hx] }
rwa [fderiv_zero_of_not_differentiable_at hx]
intros
refine ((nhds_basis_opens a).exists_iff _).1 _
exact (λ s t, approximates_linear_on.mono_set)
exact (hf.approximates_deriv_on_nhds $ f'.subsingleton_or_nnnorm_symm_pos.imp id $ λ hf', nnreal.half_pos $ nnreal.inv_pos.2 $ hf')
intros
have hdf : ∀ x ∈ Ioo a b, differentiable_at ℝ f x
from λ x hx, (hdf x hx).differentiable_at (Ioo_mem_nhds hx.1 hx.2)
have hdg : ∀ x ∈ Ioo a b, differentiable_at ℝ g x
from λ x hx, classical.by_contradiction (λ h, hg' x hx (deriv_zero_of_not_differentiable_at h))
exact has_deriv_at.lhopital_zero_right_on_Ioo hab (λ x hx, (hdf x hx).has_deriv_at) (λ x hx, (hdg x hx).has_deriv_at) hg' hfa hga hdiv
intros
rintros s t hst y ⟨c, d, hd, hc, hcd⟩
exact ⟨c, d, mem_of_superset hd $ λ h hn, hst hn, hc, hcd⟩
intros
simp [times_cont_diff_on_univ.symm, continuous_iff_continuous_on_univ, differentiable_on_univ.symm, iterated_fderiv_within_univ, times_cont_diff_on_iff_continuous_on_differentiable_on unique_diff_on_univ]
intros
rw ← times_cont_diff_within_at_univ at *; exact hf.neg
rw ← times_cont_diff_within_at_univ at *
exact hf.neg
intros
rw times_cont_diff_on_top_iff_deriv_within hs.unique_diff_on
congr' 2
rw ← iff_iff_eq
apply times_cont_diff_on_congr
assume x hx
exact deriv_within_of_open hs hx
intros
rw conformal_at_iff_is_conformal_map_fderiv
rw (h.has_fderiv_at.restrict_scalars ℝ).fderiv at ⊢ hf'
apply is_conformal_map_complex_linear
contrapose! hf' with w
simp [w]
intros
rw [open_segment_eq_image', open_segment_eq_image']
refine exists_congr (λ θ, and_congr iff.rfl _)
simp only [add_sub_add_left_eq_sub, add_assoc, add_right_inj]
intros
simp_rw le_antisymm_iff
exact (convex_halfspace_le h r).inter (convex_halfspace_ge h r)
intros
rw s.centroid_eq_center_mass hs
apply s.center_mass_id_mem_convex_hull
simp only [inv_nonneg, implies_true_iff, nat.cast_nonneg, finset.centroid_weights_apply]
{ simp only [inv_nonneg, implies_true_iff, nat.cast_nonneg, finset.centroid_weights_apply], }
have hs_card : (s.card : R) ≠ 0
{ have hs_card : (s.card : R) ≠ 0, { simp [finset.nonempty_iff_ne_empty.mp hs] }, simp only [hs_card, finset.sum_const, nsmul_eq_mul, mul_inv_cancel, ne.def, not_false_iff, finset.centroid_weights_apply, zero_lt_one] }
simp [finset.nonempty_iff_ne_empty.mp hs]
{ simp [finset.nonempty_iff_ne_empty.mp hs] }
simp only [hs_card, finset.sum_const, nsmul_eq_mul, mul_inv_cancel, ne.def, not_false_iff, finset.centroid_weights_apply, zero_lt_one]
intros
have hxz := hxy.trans hyz
rw ←sub_pos at hxy hxz hyz
suffices : f y / (y - x) + f y / (z - y) ≤ f x / (y - x) + f z / (z - y)
{ ring_nf at this ⊢, linarith }
ring_nf at this ⊢
linarith
set a := (z - y) / (z - x)
set b := (y - x) / (z - x)
have hy : a • x + b • z = y
field_simp
field_simp
{ field_simp, rw div_eq_iff; [ring, linarith] }
{ field_simp, rw div_eq_iff; [ring, linarith] }
rw div_eq_iff
rw div_eq_iff
rw div_eq_iff; [ring, linarith]
rw div_eq_iff; [ring, linarith]
ring
ring
linarith
linarith
have key
from hf.2 hx hz (show 0 ≤ a, by apply div_nonneg; linarith) (show 0 ≤ b, by apply div_nonneg; linarith) (show a + b = 1, by { field_simp, rw div_eq_iff; [ring, linarith] })
rw hy at key
replace key := mul_le_mul_of_nonneg_left key hxz.le
field_simp [hxy.ne', hyz.ne', hxz.ne', mul_comm (z - x) _] at key ⊢
rw div_le_div_right
{ linarith }
linarith
{ nlinarith }
nlinarith
intros
simp [← coe_inv_circle_eq_conj z]
intros
simp_rw [submodule.mem_orthogonal, inner_eq_zero_sym]
intros
rw [←inner_conj_sym, inner_add_left, ring_hom.map_add]
{ rw [←inner_conj_sym, inner_add_left, ring_hom.map_add], simp only [inner_conj_sym] }
simp only [inner_conj_sym]
intros
{ rw norm_add_mul_self, ring }
rw norm_add_mul_self
ring
intros
have := nnreal.coe_le_coe.2 (nnreal.inner_le_Lp_mul_Lq s (λ i, ⟨_, abs_nonneg (f i)⟩) (λ i, ⟨_, abs_nonneg (g i)⟩) hpq)
push_cast at this
refine le_trans (sum_le_sum $ λ i hi, _) this
simp only [← abs_mul, le_abs_self]
intros
simp [dist_eq_norm]
intros
simpa [dist_eq_norm] using dist_triangle g 0 h
intros
rw [← neg_sub, e.map_neg]
intros
{ ext, refl }
ext
refl
simpa only [inv_eq_one_div] using real.not_summable_nat_cast_inv
intros
simp only [exp_eq_exp_iff_exp_sub_eq_one, exp_eq_one_iff, sub_eq_iff_eq_add']
rw [← coe_comp_exp_order_iso, range_comp, exp_order_iso.range_eq, image_univ, subtype.range_coe]
intros
cases hx.lt_or_lt with hx hx
convert (has_strict_deriv_at_log_of_pos (neg_pos.mpr hx)).comp x (has_strict_deriv_at_neg x)
{ convert (has_strict_deriv_at_log_of_pos (neg_pos.mpr hx)).comp x (has_strict_deriv_at_neg x), { ext y, exact (log_neg_eq_log y).symm }, { field_simp [hx.ne] } }
{ ext y, exact (log_neg_eq_log y).symm }
ext y
exact (log_neg_eq_log y).symm
{ field_simp [hx.ne] }
field_simp [hx.ne]
{ exact has_strict_deriv_at_log_of_pos hx }
exact has_strict_deriv_at_log_of_pos hx
intros
field_simp [integral_sin_pow, add_sub_assoc]
intros
by_cases hP : 0 ≤ P.leading_coeff
exact tendsto_abs_at_top_at_top.comp (P.tendsto_at_top_of_leading_coeff_nonneg hdeg hP)
{ exact tendsto_abs_at_top_at_top.comp (P.tendsto_at_top_of_leading_coeff_nonneg hdeg hP)}
push_neg at hP
{ push_neg at hP, exact tendsto_abs_at_bot_at_top.comp (P.tendsto_at_bot_of_leading_coeff_nonpos hdeg hP.le)}
exact tendsto_abs_at_bot_at_top.comp (P.tendsto_at_bot_of_leading_coeff_nonpos hdeg hP.le)
intros
by_cases hx : x = 0
rcases le_iff_eq_or_lt.1 h with H|H
{ rcases le_iff_eq_or_lt.1 h with H|H, { simp [hx, H.symm] }, { simp [hx, zero_rpow_of_pos H, nnreal.zero_rpow (ne_of_gt H)] } }
{ simp [hx, H.symm] }
simp [hx, H.symm]
{ simp [hx, zero_rpow_of_pos H, nnreal.zero_rpow (ne_of_gt H)] }
simp [hx, zero_rpow_of_pos H, nnreal.zero_rpow (ne_of_gt H)]
{ exact coe_rpow_of_ne_zero hx _ }
exact coe_rpow_of_ne_zero hx _
intros
by_cases h : x = 0; simp [h, zero_le_one]
{ by_cases h : x = 0; simp [h, zero_le_one] }
by_cases h : x = 0
simp [h, zero_le_one]
simp [h, zero_le_one]
intros
rw [rpow_def_of_pos hx0]
repeat {rw [rpow_def_of_pos hx0]}
rw [rpow_def_of_pos hx0]
rw [rpow_def_of_pos hx0]
rw exp_lt_exp
exact mul_lt_mul_of_neg_left hyz (log_neg hx0 hx1)
intros
simp [cpow_def]; split_ifs; simp [exp_neg]
simp [cpow_def]; split_ifs
simp [cpow_def]
split_ifs
simp [exp_neg]
simp [exp_neg]
simp [exp_neg]
intros
rw [← not_exists, not_iff_not, cos_eq_zero_iff]
intros
rw [arccos, cos_pi_div_two_sub, sin_arcsin hx₁ hx₂]
intros
rw tsum_eq_zero_add (normed_ring.summable_geometric_of_norm_lt_1 x h)
simp only [pow_zero]
refine le_trans (norm_add_le _ _) _
have : ∥∑' b : ℕ, (λ n, x ^ (n + 1)) b∥ ≤ (1 - ∥x∥)⁻¹ - 1
refine tsum_of_norm_bounded _ (λ b, norm_pow_le' _ (nat.succ_pos b))
{ refine tsum_of_norm_bounded _ (λ b, norm_pow_le' _ (nat.succ_pos b)), convert (has_sum_nat_add_iff' 1).mpr (has_sum_geometric_of_lt_1 (norm_nonneg x) h), simp }
convert (has_sum_nat_add_iff' 1).mpr (has_sum_geometric_of_lt_1 (norm_nonneg x) h)
simp
linarith
intros
suffices : (of_right_adjoint i).unit.app A = h.get_iso.inv ≫ (of_right_adjoint i).unit.app (i.obj h.witness) ≫ (left_adjoint i ⋙ i).map h.get_iso.hom
rw this
{ rw this, apply_instance }
apply_instance
rw ← nat_trans.naturality
simp
intros
rw ←frobenius_morphism_mate F h at i
exact @@transfer_nat_trans_self_of_iso _ _ _ _ _ i
intros
simp
intros
subst h
intros
simp only [←category.assoc, cancel_mono]
intros
ext X b
simp
intros
apply (cancel_mono f).mp
simp [inv_hom_id]
intros
haveI : has_limit (e.inverse ⋙ e.functor ⋙ F) := limits.has_limit_equivalence_comp e.symm
apply has_limit_of_iso (e.inv_fun_id_assoc F)
intros
{ rw ← prod.lift_map, simp }
rw ← prod.lift_map
simp
intros
simp [is_iso.inv_comp_eq]
intros
rw [←image.fac f, w, has_zero_morphisms.comp_zero]
intros
apply (cancel_mono ((ρ_ X).hom ⊗ 𝟙 Y)).1
simp only [triangle_assoc_comp_right, assoc]
rw [←id_tensor_comp, iso.inv_hom_id, ←comp_tensor_id, iso.inv_hom_id]
intros
apply is_limit.hom_ext (ℬ _ _).is_limit
rintro ⟨⟩
rintro ⟨⟩; { dsimp [tensor_hom], simp, }
{ dsimp [tensor_hom], simp, }
{ dsimp [tensor_hom], simp, }
dsimp [tensor_hom]
simp
intros
rw covers_iff at h ⊢
simp [h, sieve.pullback_comp]
intros
{ cases f, congr, ext, }
cases f
congr
ext
intros
simp [of_mk_le, of_le_mk, of_le, ←functor.map_comp underlying]
intros
{ rw c.size_up_to_succ h, simp }
rw c.size_up_to_succ h
simp
intros
induction n using nat.strong_induction_on with n hyp
obtain (_|_|n) := n
refl
{ refl }
refl
{ refl }
rw [num_derangements_add_two, card_derangements_fin_add_two, mul_add, hyp _ (nat.lt_add_of_pos_right zero_lt_two), hyp _ (lt_add_one _)]
intros
ext x
simp only [mem_star, mem_supr, mem_pow]
split
{ rintro ⟨S, rfl, hS⟩, exact ⟨_, S, rfl, rfl, hS⟩ }
rintro ⟨S, rfl, hS⟩
exact ⟨_, S, rfl, rfl, hS⟩
{ rintro ⟨_, S, rfl, rfl, hS⟩, exact ⟨S, rfl, hS⟩ }
rintro ⟨_, S, rfl, rfl, hS⟩
exact ⟨S, rfl, hS⟩
intros
convert one_one_reducible.of_equiv _ h; funext; simp
convert one_one_reducible.of_equiv _ h; funext
convert one_one_reducible.of_equiv _ h
funext
simp
intros
induction k generalizing v; simp only [cont.eval, cont.then, bind_assoc, pure_bind, *]
induction k generalizing v
simp only [cont.eval, cont.then, bind_assoc, pure_bind, *]
simp only [cont.eval, cont.then, bind_assoc, pure_bind, *]
simp only [cont.eval, cont.then, bind_assoc, pure_bind, *]
simp only [cont.eval, cont.then, bind_assoc, pure_bind, *]
{ simp only [← k_ih] }
simp only [← k_ih]
simp only [cont.eval, cont.then, bind_assoc, pure_bind, *]
split_ifs; [refl, simp only [← k_ih, bind_assoc]]
{ split_ifs; [refl, simp only [← k_ih, bind_assoc]] }
split_ifs
refl
simp only [← k_ih, bind_assoc]
intros
suffices : ∀ i L, (tape.move dir.right)^[i] ((tape.move dir.left)^[i] L) = L
refine (eq.symm _).trans (this n _)
{ refine (eq.symm _).trans (this n _), simp only [tr_tape'_move_left, list_blank.cons_head_tail, list_blank.head_cons, list_blank.tail_cons] }
simp only [tr_tape'_move_left, list_blank.cons_head_tail, list_blank.head_cons, list_blank.tail_cons]
intros
induction i with i IH
refl
{refl}
rw [iterate_succ_apply, iterate_succ_apply', tape.move_left_right, IH]
intros
obtain ⟨c₁, h₁, rfl⟩ := (part.mem_map_iff _).1 H₁
obtain ⟨c₂, h₂, rfl⟩ := (part.mem_map_iff _).1 H₂
obtain ⟨_, ⟨q, v, S, L', hT⟩, h₃⟩ := tr_eval (tr_respects M) (tr_cfg_init M k L) h₂
cases part.mem_unique h₁ h₃
exact ⟨S, L', by simp only [tape.mk'_right₀], hT, rfl⟩
intros
simp only [tape.mk₂, tape.map_mk', list_blank.map_mk]
intros
cases x
cases x; refl
refl
intros
cases x; refl
cases x
refl
refl
intros
cases b; simp
cases b
simp
simp
intros
introI
cases h : p buffer.nil 0
{ simpa [lt_irrefl] using bounded.of_done h }
simpa [lt_irrefl] using bounded.of_done h
{ exact of_fail h }
exact of_fail h
intros
split
introI
{ introI, constructor, intros cb n n' a h, have : (@parser.decorate_errors α msgs p) cb n = done n' a := by simpa using h, exact of_done this }
constructor
intros cb n n' a h
have : (@parser.decorate_errors α msgs p) cb n = done n' a := by simpa using h
exact of_done this
introI
{ introI, constructor, intros _ _ _ _ h, rw decorate_errors_eq_done at h, exact of_done h }
constructor
intros _ _ _ _ h
rw decorate_errors_eq_done at h
exact of_done h
intros
simp [foldl, foldl_core_eq_done]
rw [sq, I_mul_I]
intros
haveI := classical.dec_eq γ; exact finset.induction_on s (by simp [abv_zero abv]) (λ a s has ih, by rw [sum_insert has, sum_insert has]; exact le_trans (abv_add abv _ _) (add_le_add_left ih _))
haveI := classical.dec_eq γ
exact finset.induction_on s (by simp [abv_zero abv]) (λ a s has ih, by rw [sum_insert has, sum_insert has]; exact le_trans (abv_add abv _ _) (add_le_add_left ih _))
intros
apply (@is_R_or_C.ext_iff K _ ((r + s : ℝ) : K) (r + s)).mpr
{ apply (@is_R_or_C.ext_iff K _ ((r + s : ℝ) : K) (r + s)).mpr, simp }
simp
intros
{ rw ← re_add_im a, simp [im_eq_zero_of_le h] }
rw ← re_add_im a
simp [im_eq_zero_of_le h]
intros
simp [(•)]
intros
rw [erase_single, if_pos rfl]
intros
ext i
ext i; by_cases h1 : p i; by_cases h2 : f i ≠ 0; simp at h2; simp [h1, h2]
ext i; by_cases h1 : p i; by_cases h2 : f i ≠ 0; simp at h2
ext i; by_cases h1 : p i; by_cases h2 : f i ≠ 0
ext i; by_cases h1 : p i
by_cases h1 : p i
by_cases h2 : f i ≠ 0
simp at h2
simp [h1, h2]
simp at h2
simp [h1, h2]
by_cases h2 : f i ≠ 0
simp at h2
simp [h1, h2]
simp at h2
simp [h1, h2]
intros
simp [perm.extend_domain, perm_congr_trans]
intros
conv_lhs { rw ←apply_symm_apply f y, }
rw apply_eq_iff_eq
intros
cases e; cases e'; refl
cases e; cases e'
cases e
cases e'
refl
intros
simp only [←succ_above_ne_zero_zero ha, order_embedding.eq_iff_eq]
intros
simp [cons]
intros
simp [pi.le_def, forall_iff_succ_above i]
intros
induction a with a ih
refl
{ refl }
ext
show (a+1) % (n+1) = subtype.val (a+1 : fin (n+1))
rw [val_add, ← ih, of_nat]
{ rw [val_add, ← ih, of_nat], exact add_mod _ _ _ }
exact add_mod _ _ _
intros
simp [piecewise, hi]
intros
rw [← supr_eq_supr_finset, ← equiv.plift.surjective.supr_comp]
rw [← supr_eq_supr_finset, ← equiv.plift.surjective.supr_comp]; refl
refl
intros
apply eq_of_veq
rw ← multiset.erase_dup_eq_self.2 (pi (insert a s) t).2
refine (λ s' (h : s' = a ::ₘ s.1), (_ : erase_dup (multiset.pi s' (λ a, (t a).1)) = erase_dup ((t a).1.bind $ λ b, erase_dup $ (multiset.pi s.1 (λ (a : α), (t a).val)).map $ λ f a' h', multiset.pi.cons s.1 a b f a' (h ▸ h')))) _ (insert_val_of_not_mem ha)
subst s'
rw pi_cons
congr
funext b
rw multiset.erase_dup_eq_self.2
exact multiset.nodup_map (multiset.pi_cons_injective ha) (pi s t).2
intros
transitivity
apply single_multiset_sum
rw [multiset.map_map]
refl
intros
{ ext, simp, }
ext
simp
intros
rw [split_support, mem_image, ne.def, ← support_eq_empty, ← ne.def, ← finset.nonempty_iff_ne_empty, split, comap_domain, finset.nonempty]
simp only [exists_prop, finset.mem_preimage, exists_and_distrib_right, exists_eq_right, mem_support_iff, sigma.exists, ne.def]
intros
intros a h
simp only [mul_apply, mem_support_iff] at h
simp only [mem_support_iff, mem_inter, ne.def]
rw ←not_or_distrib
intro w
apply h
cases w; { rw w, simp }
cases w
{ rw w, simp }
rw w
{ rw w, simp }
simp
intros
refine fintype.card_of_subtype _ _
simp
intros
obtain ⟨c, hcs : c ∈ s⟩ := h
have : well_founded (@has_lt.lt {x // x ∈ s} _) := fintype.well_founded_of_trans_of_irrefl _
obtain ⟨⟨m, hms : m ∈ s⟩, -, H⟩ := this.has_min set.univ ⟨⟨c, hcs⟩, trivial⟩
exact ⟨m, hms, λ x hx hxm, H ⟨x, hx⟩ trivial hxm⟩
intros
rw [fintype.card_pi, finset.prod_const]; refl
rw [fintype.card_pi, finset.prod_const]
refl
intros
rcases int.units_eq_one_or x with (rfl | rfl); simp
rcases int.units_eq_one_or x with (rfl | rfl)
simp
simp
intros
simp
intros
rw [odd_iff_not_even, even_sub, not_iff, not_iff_comm, odd_iff_not_even]
intros
simp only [update_nth_eq_modify_nth, modify_nth_length]
intros
induction l with l_ih l_tl l_ih
{ apply (hl rfl).elim }
apply (hl rfl).elim
cases l_tl
{ cases l_tl, { simp }, { simpa using l_ih } }
{ simp }
simp
{ simpa using l_ih }
simpa using l_ih
intros
rw nth_le_drop
intros
induction l with hd tl hl generalizing b i
symmetry
{ symmetry, simp only [option.bind_eq_none', nth, forall_2_true_iff, not_false_iff, option.map_none', scanl_nil, option.not_mem_none, forall_true_iff] }
simp only [option.bind_eq_none', nth, forall_2_true_iff, not_false_iff, option.map_none', scanl_nil, option.not_mem_none, forall_true_iff]
simp only [nth, scanl_cons, singleton_append]
{ simp only [nth, scanl_cons, singleton_append], cases i, { simp only [option.map_some', nth_zero_scanl, nth, option.some_bind'] }, { simp only [hl, nth] } }
cases i
{ simp only [option.map_some', nth_zero_scanl, nth, option.some_bind'] }
simp only [option.map_some', nth_zero_scanl, nth, option.some_bind']
{ simp only [hl, nth] }
simp only [hl, nth]
intros
{ induction l, simp, simp [l_ih] }
induction l
simp
simp [l_ih]
intros
simp [lookmap, h]
intros
cases p; simp only [nil_append, cons_append, eq_self_iff_true, true_and, false_and]
cases p
simp only [nil_append, cons_append, eq_self_iff_true, true_and, false_and]
simp only [nil_append, cons_append, eq_self_iff_true, true_and, false_and]
intros
{ rw inits_eq_tails l, simp [reverse_involutive.comp_self], }
rw inits_eq_tails l
simp [reverse_involutive.comp_self]
intros
simp only [diff_eq_foldl, foldl_append]
intros
cases as; refl
cases as
refl
refl
intros
by_cases h₁ : n < a
{ left, exact h₁ }
left
exact h₁
right
{ right, by_cases h₂ : n ∈ Ico a b, { right, exact h₂ }, { left, simp only [Ico.mem, not_and, not_lt] at *, exact h₂ h₁ }}
by_cases h₂ : n ∈ Ico a b
{ right, exact h₂ }
right
exact h₂
{ left, simp only [Ico.mem, not_and, not_lt] at *, exact h₂ h₁ }
left
simp only [Ico.mem, not_and, not_lt] at *
exact h₂ h₁
intros
rw [antidiagonal, length_map, length_range]
intros
rw sublist_iff_exists_order_embedding_nth_eq
split
rintro ⟨f, hf⟩
{ rintro ⟨f, hf⟩, have h : ∀ {i : ℕ} (h : i < l.length), f i < l'.length, { intros i hi, specialize hf i, rw [nth_le_nth hi, eq_comm, nth_eq_some] at hf, obtain ⟨h, -⟩ := hf, exact h }, refine ⟨order_embedding.of_map_le_iff (λ ix, ⟨f ix, h ix.is_lt⟩) _, _⟩, { simp }, { intro i, apply option.some_injective, simpa [←nth_le_nth] using hf _ } }
have h : ∀ {i : ℕ} (h : i < l.length), f i < l'.length
intros i hi
{ intros i hi, specialize hf i, rw [nth_le_nth hi, eq_comm, nth_eq_some] at hf, obtain ⟨h, -⟩ := hf, exact h }
specialize hf i
rw [nth_le_nth hi, eq_comm, nth_eq_some] at hf
obtain ⟨h, -⟩ := hf
exact h
refine ⟨order_embedding.of_map_le_iff (λ ix, ⟨f ix, h ix.is_lt⟩) _, _⟩
{ simp }
simp
intro i
{ intro i, apply option.some_injective, simpa [←nth_le_nth] using hf _ }
apply option.some_injective
apply option.some_injective
simpa [←nth_le_nth] using hf _
rintro ⟨f, hf⟩
{ rintro ⟨f, hf⟩, refine ⟨order_embedding.of_strict_mono (λ i, if hi : i < l.length then f ⟨i, hi⟩ else i + l'.length) _, _⟩, { intros i j h, dsimp only, split_ifs with hi hj hj hi, { simpa using h }, { rw add_comm, exact lt_add_of_lt_of_pos (fin.is_lt _) (i.zero_le.trans_lt h) }, { exact absurd (h.trans hj) hi }, { simpa using h } }, { intro i, simp only [order_embedding.coe_of_strict_mono], split_ifs with hi, { rw [nth_le_nth hi, nth_le_nth, ←hf], simp }, { rw [nth_len_le, nth_len_le], { simp }, { simpa using hi } } } }
refine ⟨order_embedding.of_strict_mono (λ i, if hi : i < l.length then f ⟨i, hi⟩ else i + l'.length) _, _⟩
intros i j h
{ intros i j h, dsimp only, split_ifs with hi hj hj hi, { simpa using h }, { rw add_comm, exact lt_add_of_lt_of_pos (fin.is_lt _) (i.zero_le.trans_lt h) }, { exact absurd (h.trans hj) hi }, { simpa using h } }
dsimp only
split_ifs with hi hj hj hi
{ simpa using h }
simpa using h
rw add_comm
{ rw add_comm, exact lt_add_of_lt_of_pos (fin.is_lt _) (i.zero_le.trans_lt h) }
exact lt_add_of_lt_of_pos (fin.is_lt _) (i.zero_le.trans_lt h)
{ exact absurd (h.trans hj) hi }
exact absurd (h.trans hj) hi
{ simpa using h }
simpa using h
intro i
{ intro i, simp only [order_embedding.coe_of_strict_mono], split_ifs with hi, { rw [nth_le_nth hi, nth_le_nth, ←hf], simp }, { rw [nth_len_le, nth_len_le], { simp }, { simpa using hi } } }
simp only [order_embedding.coe_of_strict_mono]
split_ifs with hi
rw [nth_le_nth hi, nth_le_nth, ←hf]
{ rw [nth_le_nth hi, nth_le_nth, ←hf], simp }
simp
rw [nth_len_le, nth_len_le]
{ rw [nth_len_le, nth_len_le], { simp }, { simpa using hi } }
simp
{ simp }
simpa using hi
{ simpa using hi }
intros
induction p with a l r p IH generalizing H
induction p with a l r p IH generalizing H; constructor
constructor
constructor
exact ball.imp_right (λ x h, H (mem_cons_self _ _) (mem_cons_of_mem _ h)) r
{ exact ball.imp_right (λ x h, H (mem_cons_self _ _) (mem_cons_of_mem _ h)) r }
exact IH (λ a b m m', H (mem_cons_of_mem _ m) (mem_cons_of_mem _ m'))
{ exact IH (λ a b m m', H (mem_cons_of_mem _ m) (mem_cons_of_mem _ m')) }
intros
rw ← filter_map_eq_filter; apply s.filter_map _
rw ← filter_map_eq_filter
apply s.filter_map _
intros
refine ⟨λ h x hx, subperm.count_le h x, λ h, _⟩
suffices : l₁ <+~ (l₂.diff l₁ ++ l₁)
refine this.trans (perm.subperm _)
{ refine this.trans (perm.subperm _), exact perm_append_comm.trans (subperm_append_diff_self_of_count_le h) }
exact perm_append_comm.trans (subperm_append_diff_self_of_count_le h)
convert (subperm_append_right _).mpr nil_subperm using 1
intros
simp only [iota_eq_reverse_range', length_reverse, length_range']
intros
induction n with n hn generalizing l
{ simp }
simp
cases l with hd tl
{ cases l with hd tl, { simp }, { simp [rotate_cons_succ, hn] } }
{ simp }
simp
{ simp [rotate_cons_succ, hn] }
simp [rotate_cons_succ, hn]
intros
simp [rotate']
intros
induction l₁ generalizing l₂
simp
case list.nil { simp }
case list.cons : s l₁ ih { by_cases h : a = s.1; [simp [h], simp [h, ih]] }
intros
simp only [map, sublists, sublists_aux_cons_append, map_eq_map, bind_eq_bind, cons_bind, map_id', append_nil, cons_append, map_id' (λ _, rfl)]
simp only [map, sublists, sublists_aux_cons_append, map_eq_map, bind_eq_bind, cons_bind, map_id', append_nil, cons_append, map_id' (λ _, rfl)]; split; refl
simp only [map, sublists, sublists_aux_cons_append, map_eq_map, bind_eq_bind, cons_bind, map_id', append_nil, cons_append, map_id' (λ _, rfl)]; split
split
refl
refl
intros
convert (zip_with_map f g id l l')
{ convert (zip_with_map f g id l l'), exact eq.symm (list.map_id _) }
exact eq.symm (list.map_id _)
intros
induction l with hd tl hl generalizing l'
{ simp }
simp
cases l' with hd' tl'
{ cases l' with hd' tl', { simp }, { simp only [add_left_inj, length] at h, have : tl.reverse.length = tl'.reverse.length := by simp [h], simp [hl _ h, zip_with_append _ _ _ _ _ this] } }
{ simp }
simp
simp only [add_left_inj, length] at h
{ simp only [add_left_inj, length] at h, have : tl.reverse.length = tl'.reverse.length := by simp [h], simp [hl _ h, zip_with_append _ _ _ _ _ this] }
have : tl.reverse.length = tl'.reverse.length := by simp [h]
simp [hl _ h, zip_with_append _ _ _ _ _ this]
intros
ext i j; refl
ext i j
refl
intros
ext i' j
rw [transpose_apply, update_row_apply, update_column_apply]
refl
intros
dsimp [algebra_map, algebra.to_ring_hom, matrix.scalar]
split_ifs with h; simp [h, matrix.one_apply_ne]
split_ifs with h
simp [h, matrix.one_apply_ne]
simp [h, matrix.one_apply_ne]
intros
ext i j
rcases i
rcases i; rcases j; refl
rcases i; rcases j
rcases j
refl
refl
rcases j
refl
refl
intros
{ ext, simp, }
ext
simp
intros
{ ext i j, refl }
ext i j
refl
intros
rcases multiset.exists_cons_of_mem h with ⟨s', hs'⟩
simp [hs', multiset.prod_cons]
intros
subst h
simp at hf
simp [bind_congr hf]
intros
simp [ne.def, count_eq_zero]
intros
rw [card.map_nsmul s n, nat.nsmul_eq_mul]
intros
{ ext, simp only [aeval_X, aeval_tower_X] }
ext
simp only [aeval_X, aeval_tower_X]
intros
{ ext, apply constant_coeff_C }
ext
apply constant_coeff_C
intros
simp [expand, map_bind₁]
intros
{ rw ← C_0, exact degrees_C 0 }
rw ← C_0
exact degrees_C 0
intros
conv_lhs { rw [←mod_add_div a n, ←mod_add_div' b n, right_distrib, left_distrib, left_distrib, mul_assoc, mul_assoc, ←left_distrib n _ _, add_mul_mod_self_left, ← mul_assoc, add_mul_mod_self_right] }
intros
{ convert bit1_lt_bit0_iff, refl, }
convert bit1_lt_bit0_iff
refl
intros
rw [succ_add, succ_sub_one]
intros
simp [lxor]
intros
cases n
cases n; refl
refl
refl
intros
induction L with d L ih
{ refl, }
refl
{ dsimp [of_digits], push_cast, rw ih, }
dsimp [of_digits]
push_cast
rw ih
intros
simp [dist.def, succ_sub_succ]
intros
classical; exact not_iff_comm.1 part.eq_none_iff'.symm
classical
exact not_iff_comm.1 part.eq_none_iff'.symm
intros
rw [← succ_pred_eq_of_pos ((zero_lt_two.trans (lt.base 2)).trans_le hi), factorial_succ]
exact lt_mul_of_one_lt_right ((pred n).succ_pos) ((one_lt_two.trans_le (le_pred_of_lt (succ_le_iff.mp hi))).trans_le (self_le_factorial _))
intros
split
split; intro h
intro h
rw [← not_lt, ← one_lt_factorial, h]
{ rw [← not_lt, ← one_lt_factorial, h], apply lt_irrefl }
apply lt_irrefl
intro h
cases h with h h
refl
cases h
refl
intros
simp [nat.lt_succ_iff_lt_or_eq, supr_or, supr_sup_eq]
intros
rw [nat.modeq, nat.add_mod_left]
intros
rw [even_iff_two_dvd, dvd_iff_mod_eq_zero, nat.div_mod_eq_mod_mul_div, mul_comm]
intros
rw [nat.div_eq_iff_eq_mul_left (pow_pos hx n) (pow_dvd_pow _ h), pow_sub_mul_pow _ h]
rw factors
intros
refine min_fac_helper_1 e _ h
refine mt _ (ne_of_gt c0)
intro e₁
rw [← nc, ← nat.dvd_iff_mod_eq_zero, ← e₁]
apply nat.min_fac_dvd
intros
simp
intros
linarith
intros
rw balance'; split_ifs; simp [all_node', all_rotate_l, all_rotate_r]
rw balance'; split_ifs
rw balance'
split_ifs
simp [all_node', all_rotate_l, all_rotate_r]
simp [all_node', all_rotate_l, all_rotate_r]
simp [all_node', all_rotate_l, all_rotate_r]
simp [all_node', all_rotate_l, all_rotate_r]
intros
split
split; intro h
intro h
intros a h' b
{ intros a h' b, replace h := h b, simp only [and_imp, exists_prop, bind_eq_bind, mem_bind_iff, exists_imp_distrib] at h, apply h _ h' }
replace h := h b
simp only [and_imp, exists_prop, bind_eq_bind, mem_bind_iff, exists_imp_distrib] at h
apply h _ h'
intro h
intros b h'
{ intros b h', simp only [exists_prop, bind_eq_bind, mem_bind_iff] at h', rcases h' with ⟨a,h₀,h₁⟩, apply h _ h₀ _ h₁ }
simp only [exists_prop, bind_eq_bind, mem_bind_iff] at h'
rcases h' with ⟨a,h₀,h₁⟩
apply h _ h₀ _ h₁
intros
cases x
simp! [comp.get,comp.mk]
intros
simp only [isubtree,ichildren_mk,pfunctor.obj.iget,dif_pos,isubtree,M.cases_on_mk']
simp only [isubtree,ichildren_mk,pfunctor.obj.iget,dif_pos,isubtree,M.cases_on_mk']; refl
refl
intros
change ((to_pnat' ((a : ℕ) - (b : ℕ)) : ℕ)) = ite ((a : ℕ) > (b : ℕ)) ((a : ℕ) - (b : ℕ)) 1
split_ifs with h
{ exact to_pnat'_coe (nat.sub_pos_of_lt h) }
exact to_pnat'_coe (nat.sub_pos_of_lt h)
rw [nat.sub_eq_zero_iff_le.mpr (le_of_not_gt h)]
{ rw [nat.sub_eq_zero_iff_le.mpr (le_of_not_gt h)], refl }
refl
intros
dsimp [gcd_a', gcd_x, gcd_w, xgcd_type.w]
{ dsimp [gcd_a', gcd_x, gcd_w, xgcd_type.w], rw [nat.succ_eq_add_one, nat.succ_eq_add_one, add_right_comm] }
rw [nat.succ_eq_add_one, nat.succ_eq_add_one, add_right_comm]
intros
simp
intros
rw [eq_neg_iff_add_eq_zero, ←monomial_add, neg_add_self, monomial_zero_right]
intros
simp [coeff_mul]
intros
simp [mul_sub]
intros
unfold leading_coeff
rw [nat_degree_mul' h, coeff_mul_degree_add_degree]
refl
intros
rw [leading_coeff, nat_degree_X_pow_sub_C, coeff_sub, coeff_X_pow_self, coeff_C, if_neg (pos_iff_ne_zero.mp hn), sub_zero]
intros
induction k with k ih generalizing p
{ simp, }
simp
simp [ih p.derivative, iterate_derivative_neg, derivative_comp, pow_succ]
{ simp [ih p.derivative, iterate_derivative_neg, derivative_comp, pow_succ], }
intros
rw [←C_eq_nat_cast, C_mul_comp, C_eq_nat_cast]
intros
rw [comp, p.as_sum_range]; simp [eval₂_finset_sum, eval₂_pow]
rw [comp, p.as_sum_range]
simp [eval₂_finset_sum, eval₂_pow]
intros
rw [integral_normalization_coeff, if_neg hi]
intros
{ rw sub_eq_add_neg, apply monic_add_of_left hp, rwa degree_neg }
rw sub_eq_add_neg
apply monic_add_of_left hp
rwa degree_neg
intros
rw ← sub_eq_zero
apply zero_of_eval_zero
intro x
rw [eval_sub, sub_eq_zero, ext]
intros
intros b₁ b₂ h
{ intros b₁ b₂ h, by simpa only [and_true, eq_self_iff_true, mk.inj_iff] using h }
simpa only [and_true, eq_self_iff_true, mk.inj_iff] using h
simpa only [and_true, eq_self_iff_true, mk.inj_iff] using h
intros
by_cases n = 0; simp [*, mk_nat]
by_cases n = 0
simp [*, mk_nat]
simp [*, mk_nat]
intros
cases q₁; cases q₂; refl
cases q₁; cases q₂
cases q₁
cases q₂
refl
intros
let S := {x : ℝ | const abs x < f}
have lb : ∃ x, x ∈ S := exists_lt f
have ub' : ∀ x, f < const abs x → ∀ y ∈ S, y ≤ x := λ x h y yS, le_of_lt $ const_lt.1 $ cau_seq.lt_trans yS h
have ub : ∃ x, ∀ y ∈ S, y ≤ x := (exists_gt f).imp ub'
refine ⟨Sup S, ((lt_total _ _).resolve_left (λ h, _)).resolve_right (λ h, _)⟩
rcases h with ⟨ε, ε0, i, ih⟩
{ rcases h with ⟨ε, ε0, i, ih⟩, refine (cSup_le lb (ub' _ _)).not_lt (sub_lt_self _ (half_pos ε0)), refine ⟨_, half_pos ε0, i, λ j ij, _⟩, rw [sub_apply, const_apply, sub_right_comm, le_sub_iff_add_le, add_halves], exact ih _ ij }
refine (cSup_le lb (ub' _ _)).not_lt (sub_lt_self _ (half_pos ε0))
refine ⟨_, half_pos ε0, i, λ j ij, _⟩
rw [sub_apply, const_apply, sub_right_comm, le_sub_iff_add_le, add_halves]
exact ih _ ij
rcases h with ⟨ε, ε0, i, ih⟩
{ rcases h with ⟨ε, ε0, i, ih⟩, refine (le_cSup ub _).not_lt ((lt_add_iff_pos_left _).2 (half_pos ε0)), refine ⟨_, half_pos ε0, i, λ j ij, _⟩, rw [sub_apply, const_apply, add_comm, ← sub_sub, le_sub_iff_add_le, add_halves], exact ih _ ij }
refine (le_cSup ub _).not_lt ((lt_add_iff_pos_left _).2 (half_pos ε0))
refine ⟨_, half_pos ε0, i, λ j ij, _⟩
rw [sub_apply, const_apply, add_comm, ← sub_sub, le_sub_iff_add_le, add_halves]
exact ih _ ij
intros
apply (summable_geometric_of_lt_1 h1 h2).summable_of_eq_zero_or_self
intro n
cases h : f n
cases h : f n; simp [h]
simp [h]
simp [h]
intros
cases classical.em (lim_zero f); simp *
cases classical.em (lim_zero f)
simp *
simp *
rcases abv_pos_of_not_lim_zero h with ⟨K, K0, hK⟩
rcases exists_forall_ge_and hK (f.cauchy₃ K0) with ⟨i, hi⟩
refine (le_total 0 (f i)).imp _ _; refine (λ h, ⟨K, K0, i, λ j ij, _⟩); have := (hi _ ij).1; cases hi _ (le_refl _) with h₁ h₂
refine (le_total 0 (f i)).imp _ _; refine (λ h, ⟨K, K0, i, λ j ij, _⟩); have := (hi _ ij).1
refine (le_total 0 (f i)).imp _ _; refine (λ h, ⟨K, K0, i, λ j ij, _⟩)
refine (le_total 0 (f i)).imp _ _
refine (λ h, ⟨K, K0, i, λ j ij, _⟩)
have := (hi _ ij).1
cases hi _ (le_refl _) with h₁ h₂
rwa abs_of_nonneg at this
{ rwa abs_of_nonneg at this, rw abs_of_nonneg h at h₁, exact (le_add_iff_nonneg_right _).1 (le_trans h₁ $ neg_le_sub_iff_le_add'.1 $ le_of_lt (abs_lt.1 $ h₂ _ ij).1) }
rw abs_of_nonneg h at h₁
exact (le_add_iff_nonneg_right _).1 (le_trans h₁ $ neg_le_sub_iff_le_add'.1 $ le_of_lt (abs_lt.1 $ h₂ _ ij).1)
refine (λ h, ⟨K, K0, i, λ j ij, _⟩)
have := (hi _ ij).1
cases hi _ (le_refl _) with h₁ h₂
rwa abs_of_nonpos at this
{ rwa abs_of_nonpos at this, rw abs_of_nonpos h at h₁, rw [← sub_le_sub_iff_right, zero_sub], exact le_trans (le_of_lt (abs_lt.1 $ h₂ _ ij).2) h₁ }
rw abs_of_nonpos h at h₁
rw [← sub_le_sub_iff_right, zero_sub]
exact le_trans (le_of_lt (abs_lt.1 $ h₂ _ ij).2) h₁
intros
rw [← real.to_nnreal_one, ← real.to_nnreal_div' h.nonneg, ← real.to_nnreal_div' h.symm.nonneg, ← real.to_nnreal_add h.one_div_nonneg h.symm.one_div_nonneg, h.inv_add_inv_conj]
intros
simp [div_eq_mul_inv]
intros
simp
intros
rw [← coe_eq_coe, coe_to_nnreal, coe_finset_sum, sum_congr rfl]
{ intros x hx, exact (coe_to_nnreal (hf x hx)).symm }
intros x hx
exact (coe_to_nnreal (hf x hx)).symm
{ exact (sum_lt_top hf).ne }
exact (sum_lt_top hf).ne
intros
rw iff_eq_eq
rw iff_eq_eq; refl
refl
intros
rintros ⟨⟨N, D, P, C⟩, rfl⟩
rw [← cast_pow] at hxr
have c1 : ((D : ℤ) : ℝ) ≠ 0
rw [int.cast_ne_zero, int.coe_nat_ne_zero]
{ rw [int.cast_ne_zero, int.coe_nat_ne_zero], exact ne_of_gt P }
exact ne_of_gt P
have c2 : ((D : ℤ) : ℝ) ^ n ≠ 0 := pow_ne_zero _ c1
rw [num_denom', cast_pow, cast_mk, div_pow, div_eq_iff_mul_eq c2, ← int.cast_pow, ← int.cast_pow, ← int.cast_mul, int.cast_inj] at hxr
have hdivn : ↑D ^ n ∣ N ^ n := dvd.intro_left m hxr
rw [← int.dvd_nat_abs, ← int.coe_nat_pow, int.coe_nat_dvd, int.nat_abs_pow, nat.pow_dvd_pow_iff hnpos] at hdivn
have hD : D = 1 := by rw [← nat.gcd_eq_right hdivn, C.gcd_eq_one]
subst D
refine hv ⟨N, _⟩
rw [num_denom', int.coe_nat_one, mk_eq_div, int.cast_one, div_one, cast_coe_int]
intros
simp [to_nnreal_one, bit1, hr]
intros
ext
{ ext, rw [nnreal.coe_nat_cast, int.cast_nat_abs, real.coe_nnabs] }
rw [nnreal.coe_nat_cast, int.cast_nat_abs, real.coe_nnabs]
intros
ext z
simp only [mem_image, comp]
split
rintros ⟨x, xt, y, rxy, syz⟩
{ rintros ⟨x, xt, y, rxy, syz⟩, exact ⟨y, ⟨x, xt, rxy⟩, syz⟩ }
exact ⟨y, ⟨x, xt, rxy⟩, syz⟩
rintros ⟨y, ⟨x, xt, rxy⟩, syz⟩
exact ⟨x, xt, y, rxy, syz⟩
intros
rw [head_eq_destruct, destruct_cons]; refl
rw [head_eq_destruct, destruct_cons]
refl
intros
rw add_comm; symmetry; apply dropn_add
rw add_comm; symmetry
rw add_comm
symmetry
apply dropn_add
intros
split_ifs with hb hb
{ split_ifs with hb hb, exacts [preimage_const_of_mem hb, preimage_const_of_not_mem hb] }
exacts [preimage_const_of_mem hb, preimage_const_of_not_mem hb]
intros
simp
intros
rw [compl_eq_univ_diff, ← pi_update_of_mem (mem_univ _)]
intros
ext
{ ext, split; rintro ⟨a, b, ha, hb, rfl⟩; refine ⟨b, a, hb, ha, rfl⟩ }
split
split; rintro ⟨a, b, ha, hb, rfl⟩; refine ⟨b, a, hb, ha, rfl⟩
split; rintro ⟨a, b, ha, hb, rfl⟩
rintro ⟨a, b, ha, hb, rfl⟩
refine ⟨b, a, hb, ha, rfl⟩
rintro ⟨a, b, ha, hb, rfl⟩
refine ⟨b, a, hb, ha, rfl⟩
intros
by_cases p; simp [h, ht]
by_cases p
simp [h, ht]
simp [h, ht]
intros
simp [surjective, surj_on, subset_def]
intros
{ rw ← image_univ, exact h.surj_on_image (ha.surj_on univ) }
rw ← image_univ
exact h.surj_on_image (ha.surj_on univ)
intros
{ ext x, simp [← e.le_iff_le] }
ext x
simp [← e.le_iff_le]
intros
rw [← Ico_diff_left, diff_union_self, union_eq_self_of_subset_right (singleton_subset_iff.2 $ left_mem_Ico.2 hab)]
intros
ext1 x
simp_rw [mem_union, mem_Iio, mem_Ico, lt_max_iff]
by_cases hc : c ≤ x
{ tauto }
tauto
have hxb : x < b := (lt_of_not_ge hc).trans_le h₁
{ have hxb : x < b := (lt_of_not_ge hc).trans_le h₁, tauto }
tauto
intros
simp [sub_eq_add_neg]
intros
simp [sub_eq_add_neg, image_comp (λ x, a + x) (λ x, -x)]
intros
simpa only [mul_comm] using preimage_mul_const_Iic_of_neg a h
intros
rintro z ⟨h₁, h₂⟩
refine (h₁ i₀ (mem_univ _)).2.not_lt _
simpa only [function.update_same] using (h₂ i₀ (mem_univ _)).1
intros
{ ext, simp }
ext
simp
intros
rw [Sup_eq_eqv_gen, Sup_image]
congr' with x y
simp only [supr_apply, supr_Prop_eq, exists_prop]
intros
rw [←string.as_string_inv_to_list s, list.to_list_inv_as_string, list.length_as_string]
intros
convert card_image_off_diag (univ : finset α)
rw [fintype.card_of_subtype, ←filter_image_quotient_mk_not_is_diag]
rintro x
rw [mem_filter, univ_product_univ, mem_image]
obtain ⟨a, ha⟩ := quotient.exists_rep x
exact and_iff_right ⟨a, mem_univ _, ha⟩
intros
ext i
ext i; induction i; [refl, apply i_ih]
ext i; induction i
induction i
refl
apply i_ih
intros
rw [← nth_zero, nth_of_fn]
intros
apply list.nth_le_repeat
intros
cases n
{ simp }
simp
simp only [coe_coe, fin.coe_add_eq_ite, int.nat_cast_eq_coe_nat, ← int.coe_nat_add, ← int.coe_nat_succ, int.coe_nat_le]
split_ifs with h
{ exact int.coe_nat_sub h }
exact int.coe_nat_sub h
{ refl }
refl
intros
rw [mem_ker]; exact one_iff_ker_inv hf _ _
rw [mem_ker]
exact one_iff_ker_inv hf _ _
intros
refl
intros
apply subfield.closure_le.mpr
rw set.union_subset_iff
exact ⟨HF, HS⟩
intros
suffices : set.range (algebra_map F E) = (⊥ : intermediate_field F E)
{ rw this, refl }
rw this
refl
change set.range (algebra_map F E) = subfield.closure (set.range (algebra_map F E) ∪ ∅)
{ change set.range (algebra_map F E) = subfield.closure (set.range (algebra_map F E) ∪ ∅), simp [←set.image_univ, ←ring_hom.map_field_closure] }
simp [←set.image_univ, ←ring_hom.map_field_closure]
intros
cases n
simp
{simp}
rw ← zmod.eq_iff_modeq_nat
let x' : units (zmod (n+1)) := zmod.unit_of_coprime _ h
have := zmod.pow_totient x'
apply_fun (coe : units (zmod (n+1)) → zmod (n+1)) at this
simpa only [-zmod.pow_totient, nat.succ_eq_add_one, nat.cast_pow, units.coe_one, nat.cast_one, coe_unit_of_coprime, units.coe_pow]
intros
{ rw [set_like.ext_iff, set_like.ext'_iff, set.ext_iff], refl }
rw [set_like.ext_iff, set_like.ext'_iff, set.ext_iff]
refl
intros
induction n with n ih; [refl, rw ← ih]; symmetry; apply quot.sound; have := r.intro n (0:K); rwa [frobenius_zero K p] at this
induction n with n ih; [refl, rw ← ih]; symmetry; apply quot.sound; have := r.intro n (0:K)
induction n with n ih; [refl, rw ← ih]; symmetry; apply quot.sound
induction n with n ih; [refl, rw ← ih]; symmetry
induction n with n ih; [refl, rw ← ih]
induction n with n ih
refl
rw ← ih
symmetry
apply quot.sound
have := r.intro n (0:K)
rwa [frobenius_zero K p] at this
intros
rcases angle_eq_pi_iff.1 h with ⟨hx, ⟨r, ⟨hr, rfl⟩⟩⟩
rw [angle_smul_left_of_neg x z hr, angle_neg_left, add_sub_cancel'_right]
intros
refine (triangle.eq_orthocenter_of_forall_mem_altitude hj₂₃ _ _).symm
rw altitude_replace_orthocenter_eq_affine_span hi₁₂ hi₁₃ hi₂₃ hj₁₂ hj₁₃ hj₂₃ h₁ h₂ h₃
{ rw altitude_replace_orthocenter_eq_affine_span hi₁₂ hi₁₃ hi₂₃ hj₁₂ hj₁₃ hj₂₃ h₁ h₂ h₃, exact mem_affine_span ℝ (set.mem_insert _ _) }
exact mem_affine_span ℝ (set.mem_insert _ _)
rw altitude_replace_orthocenter_eq_affine_span hi₁₃ hi₁₂ hi₂₃.symm hj₁₃ hj₁₂ hj₂₃.symm h₁ h₃ h₂
{ rw altitude_replace_orthocenter_eq_affine_span hi₁₃ hi₁₂ hi₂₃.symm hj₁₃ hj₁₂ hj₂₃.symm h₁ h₃ h₂, exact mem_affine_span ℝ (set.mem_insert _ _) }
exact mem_affine_span ℝ (set.mem_insert _ _)
intros
assume z hz
simp only with mfld_simps at hz
have : (chart_at H x).mdifferentiable I I := mdifferentiable_chart _ _
have T := (hs.unique_mdiff_on_preimage this) (I.symm z)
simp only [hz.left.left, hz.left.right, hz.right, unique_mdiff_within_at] with mfld_simps at ⊢ T
convert T using 1
rw @preimage_comp _ _ _ _ (chart_at H x).symm
mfld_set_tac
intros
rw ← mdifferentiable_within_at_univ at h
rw ← tangent_map_within_univ
exact tangent_map_within_subset (subset_univ _) hs h
intros
rw [← nhds_within_univ, ← ext_chart_at_symm_map_nhds_within' I x hy, preimage_univ, univ_inter]
intros
rw [times_cont_mdiff_within_at, times_cont_mdiff_within_at, lift_prop_within_at, lift_prop_within_at, ← and_assoc]
have cont : (continuous_within_at f s x ∧ continuous_within_at ((I' ∘ (chart_at H' (f x))) ∘ f) (s ∩ f ⁻¹' (chart_at H' (f x)).to_local_equiv.source) x) ↔ continuous_within_at f s x
refine ⟨λ h, h.1, λ h, ⟨h, _⟩⟩
{ refine ⟨λ h, h.1, λ h, ⟨h, _⟩⟩, have h₁ : continuous_within_at _ univ ((chart_at H' (f x)) (f x)), { exact (model_with_corners.continuous I').continuous_within_at }, have h₂ := (chart_at H' (f x)).continuous_to_fun.continuous_within_at (mem_chart_source _ _), convert (h₁.comp' h₂).comp' h, simp }
have h₁ : continuous_within_at _ univ ((chart_at H' (f x)) (f x))
{ exact (model_with_corners.continuous I').continuous_within_at }
exact (model_with_corners.continuous I').continuous_within_at
have h₂ := (chart_at H' (f x)).continuous_to_fun.continuous_within_at (mem_chart_source _ _)
convert (h₁.comp' h₂).comp' h
simp
simp [cont, times_cont_diff_within_at_prop]
intros
rw [←lift_apply_mk' f, ←lift_apply_mk' g]
congr' 1
exact monoid_hom.ext_iff.2 h
intros
{ classical, exact (of_left_inverse i).injective }
classical
exact (of_left_inverse i).injective
intros
rw [smul_smul, mul_right_inv, one_smul]
intros
erw [mul_assoc, is_unit.lift_right_inv_mul, mul_one]
intros
rw ← order_of_of_add_eq_add_order_of
exact order_of_dvd_card_univ
intros
obtain ⟨n, hn⟩ := cycle_type_prime_order h1
rw [←σ.sum_cycle_type, hn, multiset.sum_repeat, nsmul_eq_mul, nat.cast_id, mul_lt_mul_right (order_of_pos σ), nat.succ_lt_succ_iff, nat.lt_succ_iff, nat.le_zero_iff] at h2
rw [←card_cycle_type_eq_one, hn, card_repeat, h2]
intros
obtain ⟨a, b, ab, rfl⟩ := hσ
obtain ⟨c, d, cd, rfl⟩ := hτ
by_cases ac : a = c
subst ac
{ subst ac, exact swap_mul_swap_same_mem_closure_three_cycles ab cd }
exact swap_mul_swap_same_mem_closure_three_cycles ab cd
have h' : swap a b * swap c d = swap a b * swap a c * (swap c a * swap c d)
{ simp [swap_comm c a, mul_assoc] }
simp [swap_comm c a, mul_assoc]
rw h'
exact mul_mem _ (swap_mul_swap_same_mem_closure_three_cycles ab ac) (swap_mul_swap_same_mem_closure_three_cycles (ne.symm ac) cd)
intros
rw [←cycle_of_pow_apply_self f, ←cycle_of_pow_apply_self f, pow_eq_mod_order_of]
intros
rw [cycle_range_of_le h.le, if_pos h]
intros
induction n with n hn
{ simp [nat.mod_eq_of_lt hk] }
simp [nat.mod_eq_of_lt hk]
simp [pow_succ, mul_apply, hn, form_perm_apply_nth_le _ h, nat.succ_eq_add_one, ←nat.add_assoc]
{ simp [pow_succ, mul_apply, hn, form_perm_apply_nth_le _ h, nat.succ_eq_add_one, ←nat.add_assoc] }
intros
unfold sign_aux
conv { to_rhs, rw ← @finset.prod_const_one (units ℤ) _ (fin_pairs_lt n) }
exact finset.prod_congr rfl (λ a ha, if_neg (mem_fin_pairs_lt.1 ha).not_le)
intros
induction l with g l ih
{ exact disjoint_one_right _ }
exact disjoint_one_right _
rw list.prod_cons
{ rw list.prod_cons, exact (h _ (list.mem_cons_self _ _)).mul_right (ih (λ g hg, h g (list.mem_cons_of_mem _ hg))) }
exact (h _ (list.mem_cons_self _ _)).mul_right (ih (λ g hg, h g (list.mem_cons_of_mem _ hg)))
intros
intros x hx
rwa [mem_support, ←eq_on_support_mem_disjoint h hl _ hx, ←mem_support]
intros
rw is_solvable_def at *
cases h with n hn
use n
calc derived_series G' n = (derived_series G n).map f : eq.symm (map_derived_series_eq hf n) ... = (⊥ : subgroup G).map f : by rw hn ... = ⊥ : map_bot f
intros
change a ∈ set_of is_unit ↔ is_unit a
rw set.mem_set_of_eq
intros
symmetry
rw equiv.eq_image_iff_symm_image_eq
exact of_mul_image_powers_eq_multiples_of_mul
intros
rw [← fintype.card_prod, fintype.card_congr (preimage_mk_equiv_subgroup_times_set _ _)]
intros
rw coe_direction_eq_vsub_set ⟨p, hp⟩
refine le_antisymm _ _
rintros v ⟨p1, p2, hp1, hp2, rfl⟩
{ rintros v ⟨p1, p2, hp1, hp2, rfl⟩, exact ⟨p1 -ᵥ p2 +ᵥ p, vadd_mem_of_mem_direction (vsub_mem_direction hp1 hp2) hp, (vadd_vsub _ _)⟩ }
exact ⟨p1 -ᵥ p2 +ᵥ p, vadd_mem_of_mem_direction (vsub_mem_direction hp1 hp2) hp, (vadd_vsub _ _)⟩
rintros v ⟨p2, hp2, rfl⟩
{ rintros v ⟨p2, hp2, rfl⟩, exact ⟨p2, p, hp2, hp, rfl⟩ }
exact ⟨p2, p, hp2, hp, rfl⟩
intros
rw [vector_span_eq_span_vsub_set_right k (set.mem_range_self i0), ←set.range_comp]
intros
{ ext, simp }
ext
simp
intros
rw [ker, comap_cod_restrict, map_bot]; refl
rw [ker, comap_cod_restrict, map_bot]
refl
intros
{ rw is_skew_adjoint_iff_neg_self_adjoint, exact iff.rfl, }
rw is_skew_adjoint_iff_neg_self_adjoint
exact iff.rfl
intros
ext i j
simp only [bilin_form.to_matrix_apply, bilin_form.comp_apply, transpose_apply, matrix.mul_apply, linear_map.to_matrix', linear_equiv.coe_mk, sum_mul]
rw sum_comm
conv_lhs { rw ← sum_repr_mul_repr_mul b }
rw finsupp.sum_fintype
apply sum_congr rfl
{ apply sum_congr rfl, rintros i' -, rw finsupp.sum_fintype, { apply sum_congr rfl, rintros j' -, simp only [smul_eq_mul, linear_map.to_matrix_apply, basis.equiv_fun_apply, mul_assoc, mul_comm, mul_left_comm] }, { intros, simp only [zero_smul, smul_zero] } }
rintros i' -
rw finsupp.sum_fintype
apply sum_congr rfl
{ apply sum_congr rfl, rintros j' -, simp only [smul_eq_mul, linear_map.to_matrix_apply, basis.equiv_fun_apply, mul_assoc, mul_comm, mul_left_comm] }
rintros j' -
simp only [smul_eq_mul, linear_map.to_matrix_apply, basis.equiv_fun_apply, mul_assoc, mul_comm, mul_left_comm]
{ intros, simp only [zero_smul, smul_zero] }
intros
simp only [zero_smul, smul_zero]
{ intros, simp only [zero_smul, finsupp.sum_zero] }
intros
simp only [zero_smul, finsupp.sum_zero]
intros
simp [reverse]
intros
haveI := classical.dec_eq ι
{ haveI := classical.dec_eq ι, rw [← det_to_matrix b, linear_equiv.map_zero, det_zero], assumption }
rw [← det_to_matrix b, linear_equiv.map_zero, det_zero]
assumption
intros
simp only [le_rank_iff_exists_linear_independent, cardinal.lift_nat_cast, cardinal.lift_eq_nat_iff, cardinal.mk_eq_nat_iff_finset]
split
rintro ⟨s, ⟨t, rfl, rfl⟩, si⟩
{ rintro ⟨s, ⟨t, rfl, rfl⟩, si⟩, exact ⟨t, rfl, si⟩ }
exact ⟨t, rfl, si⟩
rintro ⟨s, rfl, si⟩
{ rintro ⟨s, rfl, si⟩, exact ⟨s, ⟨s, rfl, rfl⟩, si⟩ }
exact ⟨s, ⟨s, rfl, rfl⟩, si⟩
intros
{ ext, apply to_dual_apply_right }
ext
apply to_dual_apply_right
intros
have : module.rank F (⊥ : subalgebra F E) = 1 := subalgebra.dim_bot
rw ← finrank_eq_dim at this
norm_cast at *
simp *
intros
have : map_domain f l = emb_domain ⟨f, hf⟩ l
rw emb_domain_eq_map_domain ⟨f, hf⟩
{ rw emb_domain_eq_map_domain ⟨f, hf⟩, refl }
refl
rw this
apply total_emb_domain R ⟨f, hf⟩ l
intros
apply @linear_independent_Union_finite R _ _ _ _ ι φ (λ i x, single i (f i x))
assume i
{ assume i, have h_disjoint : disjoint (span R (range (f i))) (ker (lsingle i)), { rw ker_lsingle, exact disjoint_bot_right }, apply (hf i).map h_disjoint }
have h_disjoint : disjoint (span R (range (f i))) (ker (lsingle i))
rw ker_lsingle
{ rw ker_lsingle, exact disjoint_bot_right }
exact disjoint_bot_right
apply (hf i).map h_disjoint
intros i t ht hit
{ intros i t ht hit, refine (disjoint_lsingle_lsingle {i} t (disjoint_singleton_left.2 hit)).mono _ _, { rw span_le, simp only [supr_singleton], rw range_coe, apply range_comp_subset_range }, { refine supr_le_supr (λ i, supr_le_supr _), intros hi, rw span_le, rw range_coe, apply range_comp_subset_range } }
refine (disjoint_lsingle_lsingle {i} t (disjoint_singleton_left.2 hit)).mono _ _
rw span_le
{ rw span_le, simp only [supr_singleton], rw range_coe, apply range_comp_subset_range }
simp only [supr_singleton]
rw range_coe
apply range_comp_subset_range
refine supr_le_supr (λ i, supr_le_supr _)
{ refine supr_le_supr (λ i, supr_le_supr _), intros hi, rw span_le, rw range_coe, apply range_comp_subset_range }
intros hi
rw span_le
rw range_coe
apply range_comp_subset_range
intros
refine ⟨λ h n, λ f hf, _, λ h, ⟨λ n m f hf, _⟩⟩
letI : strong_rank_condition R := h
{ letI : strong_rank_condition R := h, exact nat.not_succ_le_self n (le_of_fin_injective R f hf) }
exact nat.not_succ_le_self n (le_of_fin_injective R f hf)
by_contra H
{ by_contra H, exact h m (f.comp (function.extend_by_zero.linear_map R (fin.cast_le (not_le.1 H)))) (hf.comp (function.extend_injective (rel_embedding.injective _) 0)) }
exact h m (f.comp (function.extend_by_zero.linear_map R (fin.cast_le (not_le.1 H)))) (hf.comp (function.extend_injective (rel_embedding.injective _) 0))
intros
let l : ι →₀ R := finsupp.single i c - finsupp.single j d
have h_total : finsupp.total ι M R v l = 0
simp_rw [linear_map.map_sub, finsupp.total_apply]
{ simp_rw [linear_map.map_sub, finsupp.total_apply], simp [h] }
simp [h]
have h_single_eq : finsupp.single i c = finsupp.single j d
rw linear_independent_iff at li
{ rw linear_independent_iff at li, simp [eq_add_of_sub_eq' (li l h_total)] }
simp [eq_add_of_sub_eq' (li l h_total)]
rcases (finsupp.single_eq_single_iff _ _ _ _).mp h_single_eq with ⟨this, _⟩ | ⟨hc, _⟩
{ exact this }
exact this
{ contradiction }
contradiction
intros
ext k i j
simp only [mat_poly_equiv_coeff_apply, coeff_sub, pi.sub_apply]
by_cases h : i = j
subst h
{ subst h, rw [charmatrix_apply_eq, coeff_sub], simp only [coeff_X, coeff_C], split_ifs; simp, }
rw [charmatrix_apply_eq, coeff_sub]
simp only [coeff_X, coeff_C]
split_ifs; simp
split_ifs
simp
simp
simp
simp
rw [charmatrix_apply_ne _ _ _ h, coeff_X, coeff_neg, coeff_C, coeff_C]
{ rw [charmatrix_apply_ne _ _ _ h, coeff_X, coeff_neg, coeff_C, coeff_C], split_ifs; simp [h], }
split_ifs; simp [h]
split_ifs
simp [h]
simp [h]
simp [h]
simp [h]
intros
simp [det_apply, units.smul_def]
intros
rw [←(inv_eq_right_inv h), ←(inv_eq_right_inv g)]
intros
{ ext, simp }
ext
simp
intros
rw [show (@has_mul.mul (M₁ →ₗ[R] M₁) _) = linear_map.comp, from rfl, linear_map.to_matrix_alg_equiv_comp v₁ f g]
{ rw [show (@has_mul.mul (M₁ →ₗ[R] M₁) _) = linear_map.comp, from rfl, linear_map.to_matrix_alg_equiv_comp v₁ f g] }
intros
simp [transvection, matrix.mul_add, hb]
intros
rw [associated_apply, map_add_self]
suffices : (⅟2) * (2 * Q x) = Q x
convert this
{ convert this, simp only [bit0, add_mul, one_mul], abel }
simp only [bit0, add_mul, one_mul]
abel
simp [← mul_assoc]
intros
rw [eq_bot_iff, map_le_iff_le_comap, comap_bot, ker_mkq]
rw [eq_bot_iff, map_le_iff_le_comap, comap_bot, ker_mkq]; exact le_refl _
exact le_refl _
intros
rw [smodeq.def, submodule.quotient.eq]
intros
rw [h]
intros
rw [cases_head_iff]; simp [h, eq_comm]
rw [cases_head_iff]
simp [h, eq_comm]
intros
refine lintegral_congr_ae _
filter_upwards [hf.prod_right_ae, hg.prod_right_ae]
intros x h2f h2g
simp [integral_sub h2f h2g]
intros
simp only [condexp_ind_L1, hs, dif_neg, not_false_iff, false_and]
intros
rw ← lintegral_add' (hf.edist hh) (hg.edist hh)
refine lintegral_mono (λ a, _)
apply edist_triangle_right
intros
simp_rw [snorm_ess_sup, pi.smul_apply, nnnorm_smul, ennreal.coe_mul, ennreal.ess_sup_const_mul]
intros
rw [mem_Lp_iff_snorm_lt_top, snorm_congr_ae (ae_eq_fun.coe_fn_smul _ _), snorm_const_smul, ennreal.mul_lt_top_iff]
exact or.inl ⟨ennreal.coe_lt_top, f.prop⟩
intros
convert zero_mem_ℒp
intros
haveI : nonempty s := ⟨⟨y₀, h₀⟩⟩
rw [← @subtype.range_coe _ s, ← image_univ, ← (dense_range_dense_seq s).closure_eq] at hx
simp only [approx_on, coe_comp]
refine tendsto_nearest_pt (closure_minimal _ is_closed_closure hx)
simp only [nat.range_cases_on, closure_union, range_comp coe]
exact subset.trans (image_closure_subset_closure_image continuous_subtype_coe) (subset_union_right _ _)
intros
simpa only [← pi.multiset_prod_apply] using s.measurable_prod' hs
intros
simp [interval_integral, h]
intros
simpa only [sub_eq_add_neg] using integral_comp_mul_add f hc (-d)
intros
simp only [← supr_apply]
exact (monotone_lintegral μ).le_map_supr
intros
rw [restrict_map hg hs, lintegral_map hf hg]
intros
{ rw ← singleton_prod_singleton, exact pair_preimage _ _ _ _ }
rw ← singleton_prod_singleton
exact pair_preimage _ _ _ _
intros
rw [measure.restrict_empty, integral_zero_measure]
intros
rw [Lp.norm_def, Lp.norm_def, ennreal.to_real_le_to_real (Lp.snorm_ne_top _) (Lp.snorm_ne_top _)]
refine (le_of_eq _).trans (snorm_mono_measure _ measure.restrict_le_self)
{ exact s, }
exact s
exact snorm_congr_ae (mem_ℒp.coe_fn_to_Lp _)
intros
simp_rw set_to_L1s
rw ← simple_func.set_to_simple_func_smul_real T h_add c (simple_func.integrable f)
refine simple_func.set_to_simple_func_congr T h_zero h_add (simple_func.integrable _) _
exact smul_to_simple_func c f
intros
assume s hs
rw [← bUnion_preimage_singleton]
refine measurable_set.Union (λ y, measurable_set.Union_Prop $ λ hy, _)
by_cases hyf : y ∈ range f
rcases hyf with ⟨y, rfl⟩
{ rcases hyf with ⟨y, rfl⟩, apply h }
apply h
simp only [preimage_singleton_eq_empty.2 hyf, measurable_set.empty]
{ simp only [preimage_singleton_eq_empty.2 hyf, measurable_set.empty] }
intros
let eval : (compacts G → ℝ) → ℝ := λ f, f K₂ - f K₁
have : continuous eval := (continuous_apply K₂).sub (continuous_apply K₁)
rw [← sub_nonneg]
show chaar K₀ ∈ eval ⁻¹' (Ici (0 : ℝ))
apply mem_of_subset_of_mem _ (chaar_mem_cl_prehaar K₀ ⟨set.univ, is_open_univ, mem_univ _⟩)
unfold cl_prehaar
rw is_closed.closure_subset_iff
rintro _ ⟨U, ⟨h1U, h2U, h3U⟩, rfl⟩
{ rintro _ ⟨U, ⟨h1U, h2U, h3U⟩, rfl⟩, simp only [mem_preimage, mem_Ici, eval, sub_nonneg], apply prehaar_mono _ h, rw h2U.interior_eq, exact ⟨1, h3U⟩ }
simp only [mem_preimage, mem_Ici, eval, sub_nonneg]
apply prehaar_mono _ h
rw h2U.interior_eq
exact ⟨1, h3U⟩
apply continuous_iff_is_closed.mp this
{ apply continuous_iff_is_closed.mp this, exact is_closed_Ici }
exact is_closed_Ici
intros
rcases eq_or_ne r 0 with rfl|h
simp only [← closed_ball_diff_ball, diff_empty, closed_ball_zero, ball_zero, measure_singleton]
{ simp only [← closed_ball_diff_ball, diff_empty, closed_ball_zero, ball_zero, measure_singleton] }
{ exact add_haar_sphere_of_ne_zero μ x h }
exact add_haar_sphere_of_ne_zero μ x h
intros
rw [← finset.sum_attach, finset.attach_eq_univ, ← tsum_fintype]
exact measure_bUnion s.countable_to_set hd hm
intros
simp_rw [spanning_sets, Union_accumulate, μ.to_finite_spanning_sets_in.spanning]
intros
split
assume h
{ assume h, exact (h.mono_measure measure.restrict_le_self).congr (indicator_ae_eq_restrict hs) }
exact (h.mono_measure measure.restrict_le_self).congr (indicator_ae_eq_restrict hs)
assume h
{ assume h, refine ⟨indicator s (h.mk f), h.measurable_mk.indicator hs, _⟩, have A : s.indicator f =ᵐ[μ.restrict s] s.indicator (ae_measurable.mk f h) := (indicator_ae_eq_restrict hs).trans (h.ae_eq_mk.trans $ (indicator_ae_eq_restrict hs).symm), have B : s.indicator f =ᵐ[μ.restrict sᶜ] s.indicator (ae_measurable.mk f h) := (indicator_ae_eq_restrict_compl hs).trans (indicator_ae_eq_restrict_compl hs).symm, have : s.indicator f =ᵐ[μ.restrict s + μ.restrict sᶜ] s.indicator (ae_measurable.mk f h) := ae_add_measure_iff.2 ⟨A, B⟩, simpa only [hs, measure.restrict_add_restrict_compl] using this }
refine ⟨indicator s (h.mk f), h.measurable_mk.indicator hs, _⟩
have A : s.indicator f =ᵐ[μ.restrict s] s.indicator (ae_measurable.mk f h) := (indicator_ae_eq_restrict hs).trans (h.ae_eq_mk.trans $ (indicator_ae_eq_restrict hs).symm)
have B : s.indicator f =ᵐ[μ.restrict sᶜ] s.indicator (ae_measurable.mk f h) := (indicator_ae_eq_restrict_compl hs).trans (indicator_ae_eq_restrict_compl hs).symm
have : s.indicator f =ᵐ[μ.restrict s + μ.restrict sᶜ] s.indicator (ae_measurable.mk f h) := ae_add_measure_iff.2 ⟨A, B⟩
simpa only [hs, measure.restrict_add_restrict_compl] using this
intros
rw [restrict_apply measurable_set.univ, set.univ_inter]
intros
rw [h₁, set.inter_assoc, set.union_inter_cancel_left, inter_diff_assoc, union_diff_cancel_left h]
intros
refine le_antisymm (le_of_forall_lt (λ r hr, _)) (bsupr_le $ λ K hK, supr_le $ λ _, μ.mono hK)
simpa only [lt_supr_iff, exists_prop] using H hU r hr
intros
split
split; intro h
intro h
refine mk (λ s hmeas hs, h _)
{ refine mk (λ s hmeas hs, h _), rw [← hs, ennreal_to_measure_apply hmeas] }
rw [← hs, ennreal_to_measure_apply hmeas]
intro h
intros s hs
{ intros s hs, by_cases hmeas : measurable_set s, { rw ennreal_to_measure_apply hmeas at hs, exact h hs }, { exact not_measurable v hmeas } }
by_cases hmeas : measurable_set s
rw ennreal_to_measure_apply hmeas at hs
{ rw ennreal_to_measure_apply hmeas at hs, exact h hs }
exact h hs
{ exact not_measurable v hmeas }
exact not_measurable v hmeas
intros
refine ⟨λ h, _, λ h, _⟩
ext1 i hi
{ ext1 i hi, have : μ.to_signed_measure i = ν.to_signed_measure i, { rw h }, rwa [to_signed_measure_apply_measurable hi, to_signed_measure_apply_measurable hi, ennreal.to_real_eq_to_real] at this; { exact measure_ne_top _ _ } }
have : μ.to_signed_measure i = ν.to_signed_measure i
{ rw h }
rw h
rwa [to_signed_measure_apply_measurable hi, to_signed_measure_apply_measurable hi, ennreal.to_real_eq_to_real] at this
rwa [to_signed_measure_apply_measurable hi, to_signed_measure_apply_measurable hi, ennreal.to_real_eq_to_real] at this; { exact measure_ne_top _ _ }
{ exact measure_ne_top _ _ }
{ exact measure_ne_top _ _ }
exact measure_ne_top _ _
{ congr, assumption }
congr
assumption
intros
cases m
rw [mem_divisors, zero_dvd_iff] at h
{ rw [mem_divisors, zero_dvd_iff] at h, rcases h with ⟨rfl, h⟩, exfalso, apply h rfl }
rcases h with ⟨rfl, h⟩
exfalso
apply h rfl
apply nat.succ_pos
intros
{ delta fermat_42, rw add_comm, tauto }
delta fermat_42
rw add_comm
tauto
intros
induction n
{ refl, }
refl
{ dsimp, simp only [add_left_inj], exact n_ih, }
dsimp
simp only [add_left_inj]
exact n_ih
intros
by_contra h
rw padic_val_nat_of_not_dvd h at hp
exact lt_irrefl 0 (lt_of_lt_of_le zero_lt_one hp)
intros
simp [cast_eq_of_rat]
intros
show _ = ring_hom.id _ z
rw @lift_unique p _ ℤ_[p] _ _ zmod_cast_comp_to_zmod_pow (ring_hom.id ℤ_[p])
intro
rw ring_hom.comp_id
intros
by_cases h0 : int.gcd x y = 0
have hx : x = 0
{ have hx : x = 0, { apply int.nat_abs_eq_zero.mp, apply nat.eq_zero_of_gcd_eq_zero_left h0 }, have hy : y = 0, { apply int.nat_abs_eq_zero.mp, apply nat.eq_zero_of_gcd_eq_zero_right h0 }, have hz : z = 0, { simpa only [pythagorean_triple, hx, hy, add_zero, zero_eq_mul, mul_zero, or_self] using h }, simp only [hx, hy, hz, int.zero_div], exact zero }
apply int.nat_abs_eq_zero.mp
{ apply int.nat_abs_eq_zero.mp, apply nat.eq_zero_of_gcd_eq_zero_left h0 }
apply nat.eq_zero_of_gcd_eq_zero_left h0
have hy : y = 0
apply int.nat_abs_eq_zero.mp
{ apply int.nat_abs_eq_zero.mp, apply nat.eq_zero_of_gcd_eq_zero_right h0 }
apply nat.eq_zero_of_gcd_eq_zero_right h0
have hz : z = 0
simpa only [pythagorean_triple, hx, hy, add_zero, zero_eq_mul, mul_zero, or_self] using h
{ simpa only [pythagorean_triple, hx, hy, add_zero, zero_eq_mul, mul_zero, or_self] using h }
simp only [hx, hy, hz, int.zero_div]
exact zero
rcases h.gcd_dvd with ⟨z0, rfl⟩
obtain ⟨k, x0, y0, k0, h2, rfl, rfl⟩ : ∃ (k : ℕ) x0 y0, 0 < k ∧ int.gcd x0 y0 = 1 ∧ x = x0 * k ∧ y = y0 * k := int.exists_gcd_one' (nat.pos_of_ne_zero h0)
have hk : (k : ℤ) ≠ 0
norm_cast
{ norm_cast, rwa pos_iff_ne_zero at k0 }
rwa pos_iff_ne_zero at k0
rw [int.gcd_mul_right, h2, int.nat_abs_of_nat, one_mul] at h ⊢
rw [mul_comm x0, mul_comm y0, mul_iff k hk] at h
rwa [int.mul_div_cancel _ hk, int.mul_div_cancel _ hk, int.mul_div_cancel_left _ hk]
intros
simp only [zsqrtd.ext, zsqrtd.conj_re, zsqrtd.conj_im, zsqrtd.one_im, neg_zero, eq_self_iff_true, and_self]
intros
rw [int.is_unit_iff_nat_abs_eq, norm_eq_one_iff]
intros
rw [inf_comm, sdiff_inf_self_right]
intros
{ rw h.upper_bounds_eq, refl }
rw h.upper_bounds_eq
refl
intros
simp only [Inf_eq_infi, compl_infi]
intros
rw [← Inf_image, ← Inf_image, ← image_comp]
intros
cases s.eq_empty_or_nonempty with hs hs
rw hs
{ rw hs, show is_lub ∅ (ite _ _ _), split_ifs, { cases h }, { rw [preimage_empty, cSup_empty], exact is_lub_empty }, { exfalso, apply h_1, use ⊥, rintro a ⟨⟩ } }
show is_lub ∅ (ite _ _ _)
split_ifs
{ cases h }
cases h
{ rw [preimage_empty, cSup_empty], exact is_lub_empty }
rw [preimage_empty, cSup_empty]
exact is_lub_empty
{ exfalso, apply h_1, use ⊥, rintro a ⟨⟩ }
exfalso
apply h_1
use ⊥
rintro a ⟨⟩
exact is_lub_Sup' hs
intros
nontriviality
rcases nontrivial_iff_nonempty.1 ‹_› with ⟨b, hb⟩
rw [← map_coe_at_top_of_Ici_subset (Ici_subset_Ioi.2 hb), comap_map subtype.coe_injective]
intros
simpa [frequently_at_top] using high_scores hu
intros
simp [← prod_at_bot_at_bot_eq, at_bot_basis.prod_self.eventually_iff]
intros
simp [filter.prod]
intros
simp [is_bounded, subset_def]
intros
induction n with n ih
{ simp }
simp
dsimp [partial_sups] at ih ⊢
{ dsimp [partial_sups] at ih ⊢, rw [finset.range_succ, finset.sup_insert, sup_comm, ih] }
rw [finset.range_succ, finset.sup_insert, sup_comm, ih]
intros
simp [←symm_diff_assoc]
intros
haveI : is_strict_order α (λ (a b : α), a < b ∧ a ∈ s ∧ b ∈ s) := { to_is_irrefl := ⟨λ x con, lt_irrefl x con.1⟩, to_is_trans := ⟨λ a b c ab bc, ⟨lt_trans ab.1 bc.1, ab.2.1, bc.2.2⟩⟩, }
rw [is_wf, well_founded_on_iff_no_descending_seq]
exact ⟨λ h f, h f.lt_embedding, λ h f, h (order_embedding.of_strict_mono f (λ _ _, f.map_rel_iff.2))⟩
intros
suffices : multiplicative.of_add m ∈ submonoid.closure (multiplicative.to_add ⁻¹' S)
{ simpa [← to_submonoid_closure] }
simpa [← to_submonoid_closure]
rw [set.image_congr' (show ∀ x, of' R M x = of R M x, from λ x, of'_eq_of x), ← monoid_hom.map_mclosure] at h
simpa using of'_mem_span.1 h
intros
ext x
by_cases h : x = a + b
rw [h, mul_single_coeff_add]
{ rw [h, mul_single_coeff_add], simp }
simp
rw [single_coeff_of_ne h, mul_coeff, sum_eq_zero]
{ rw [single_coeff_of_ne h, mul_coeff, sum_eq_zero], rintros ⟨y1, y2⟩ hy, obtain ⟨rfl, hy1, hy2⟩ := mem_add_antidiagonal.1 hy, rw [eq_of_mem_support_single hy1, eq_of_mem_support_single hy2] at h, exact (h rfl).elim }
rintros ⟨y1, y2⟩ hy
obtain ⟨rfl, hy1, hy2⟩ := mem_add_antidiagonal.1 hy
rw [eq_of_mem_support_single hy1, eq_of_mem_support_single hy2] at h
exact (h rfl).elim
intros
rw or_iff_not_imp_right
change _ ≠ _ → _
rw ideal.ne_top_iff_one
intro h1
rw eq_bot_iff
intros r hr
by_cases H : r = 0
simpa
{simpa}
simpa [H, h1] using I.mul_mem_left r⁻¹ hr
intros
rw [is_localization.coe_submodule, ideal.span, submodule.map_span]
{ rw [is_localization.coe_submodule, ideal.span, submodule.map_span], refl }
refl
intros
induction k with k hi
{ simp }
simp
rw [pow_succ, content_X_mul, hi]
intros
by_cases hzero : n = 0
simp only [hzero, ring_hom.map_one, splits_zero, pow_zero, sub_self]
{ simp only [hzero, ring_hom.map_one, splits_zero, pow_zero, sub_self] }
rw [splits_iff_card_roots, ← nth_roots, is_primitive_root.card_nth_roots h, nat_degree_X_pow_sub_C]
intros
simp only [cyclotomic', finset.prod_empty, is_primitive_root.primitive_roots_zero]
intros
haveI := classical.prop_decidable
by_cases hp : p = 0
{ rw [hp, zero_scale_roots] }
rw [hp, zero_scale_roots]
have := scale_roots_ne_zero hp s
refine le_antisymm (finset.sup_mono (support_scale_roots_le p s)) (degree_le_degree _)
rw coeff_scale_roots_nat_degree
intro h
have := leading_coeff_eq_zero.mp h
contradiction
intros
{ classical, split_ifs; simp *, }
classical
split_ifs
split_ifs; simp *
simp *
intros
ext (_ | n)
simp only [ring_hom.map_add, constant_coeff_C, constant_coeff_X, coeff_zero_eq_constant_coeff, zero_add, zero_mul, ring_hom.map_mul]
{ simp only [ring_hom.map_add, constant_coeff_C, constant_coeff_X, coeff_zero_eq_constant_coeff, zero_add, zero_mul, ring_hom.map_mul], }
simp only [coeff_succ_X_mul, coeff_mk, linear_map.map_add, coeff_C, n.succ_ne_zero, sub_zero, if_false, add_zero]
{ simp only [coeff_succ_X_mul, coeff_mk, linear_map.map_add, coeff_C, n.succ_ne_zero, sub_zero, if_false, add_zero], }
intros
ext (_|n)
{ simp }
simp
{ simp [n.succ_ne_zero, pow_succ] }
simp [n.succ_ne_zero, pow_succ]
intros
split
{ intro h, rw [← pow_one ζ, h.pow_eq_one] }
intro h
rw [← pow_one ζ, h.pow_eq_one]
{ rintro rfl, exact one }
rintro rfl
exact one
intros
{ ext, simp [base_change_tmul], }
ext
simp [base_change_tmul]
intros
simp
intros
map_fun_tac
intros
cases x
cases y
simp only at h
simp [function.funext_iff, h]
intros
simp only [witt_structure_rat, eval₂_hom_zero', h, bind₁, map_aeval, constant_coeff_rename, constant_coeff_witt_polynomial, constant_coeff_comp_algebra_map, ring_hom.id_apply, constant_coeff_X_in_terms_of_W]
intros
by_cases h : c = 0
{ by_cases h : c = 0, rw [h, power_zero], rw [zero_power h], apply zero_le }
rw [h, power_zero]
rw [zero_power h]
apply zero_le
intros
rw [quot_mul_comm, quot_mul_one x]
intros
simpa only [add_zero] using add_le_add_left (ordinal.zero_le b) a
intros
rw le_def
dsimp
simp [forall_pempty, exists_pempty]
intros
simp [funs, is_func]
intros
simp [left_distrib, *, sub_eq_add_neg]
intros
simp *
intros
rw [← h, ← hm, nat.add_mul_mod_self_right, nat.mod_eq_of_lt h₂]
intros
cases t1
cases t2
simp only [add_assoc, coeffs.val_sub, neg_add_rev, val, sub, add_comm, add_left_comm, sub_eq_add_neg]
intros
simp only [is_open_iff_of_mem' h, is_closed_compl_iff, and.comm]
intros
have H : ∀ n, m (⨆ b ∈ decode₂ γ n, s b) ≠ 0 → (decode₂ γ n).is_some
intros n h
{ intros n h, cases decode₂ γ n with b, { refine (h $ by simp [m0]).elim }, { exact rfl } }
cases decode₂ γ n with b
{ refine (h $ by simp [m0]).elim }
refine (h $ by simp [m0]).elim
{ exact rfl }
exact rfl
symmetry
refine tsum_eq_tsum_of_ne_zero_bij (λ a, option.get (H a.1 a.2)) _ _ _
rintros ⟨m, hm⟩ ⟨n, hn⟩ e
{ rintros ⟨m, hm⟩ ⟨n, hn⟩ e, have := mem_decode₂.1 (option.get_mem (H n hn)), rwa [← e, mem_decode₂.1 (option.get_mem (H m hm))] at this }
have := mem_decode₂.1 (option.get_mem (H n hn))
rwa [← e, mem_decode₂.1 (option.get_mem (H m hm))] at this
intros b h
{ intros b h, refine ⟨⟨encode b, _⟩, _⟩, { simp only [mem_support, encodek₂] at h ⊢, convert h, simp [set.ext_iff, encodek₂] }, { exact option.get_of_mem _ (encodek₂ _) } }
refine ⟨⟨encode b, _⟩, _⟩
simp only [mem_support, encodek₂] at h ⊢
{ simp only [mem_support, encodek₂] at h ⊢, convert h, simp [set.ext_iff, encodek₂] }
convert h
simp [set.ext_iff, encodek₂]
{ exact option.get_of_mem _ (encodek₂ _) }
exact option.get_of_mem _ (encodek₂ _)
rintros ⟨n, h⟩
{ rintros ⟨n, h⟩, dsimp only [subtype.coe_mk], transitivity, swap, rw [show decode₂ γ n = _, from option.get_mem (H n h)], congr, simp [ext_iff, -option.some_get] }
dsimp only [subtype.coe_mk]
transitivity
swap
rw [show decode₂ γ n = _, from option.get_mem (H n h)]
congr
simp [ext_iff, -option.some_get]
intros
induction n with n ih
{ simp [continuous_const] }
simp [continuous_const]
simp [nat.succ_eq_add_one, add_smul]
{ simp [nat.succ_eq_add_one, add_smul], exact ih.add continuous_id }
exact ih.add continuous_id
intros
convert continuous_fst.comp continuous_induced_dom
intros
refine ⟨λ h, _, λ h, _⟩
have hn : n = 0
{ have hn : n = 0, { by_contradiction hn, have hn : 1 ≤ n := nat.succ_le_iff.2 (lt_of_le_of_ne (zero_le _) (ne.symm hn)), by_cases hc' : 0 < c, { have := (tendsto_const_mul_pow_at_top_iff c n).2 ⟨hn, hc'⟩, exact not_tendsto_nhds_of_tendsto_at_top this d h }, { have := (tendsto_neg_const_mul_pow_at_top_iff c n).2 ⟨hn, lt_of_le_of_ne (not_lt.1 hc') hc⟩, exact not_tendsto_nhds_of_tendsto_at_bot this d h } }, have : (λ x : α, c * x ^ n) = (λ x : α, c), by simp [hn], rw [this, tendsto_const_nhds_iff] at h, exact ⟨hn, h⟩ }
by_contradiction hn
{ by_contradiction hn, have hn : 1 ≤ n := nat.succ_le_iff.2 (lt_of_le_of_ne (zero_le _) (ne.symm hn)), by_cases hc' : 0 < c, { have := (tendsto_const_mul_pow_at_top_iff c n).2 ⟨hn, hc'⟩, exact not_tendsto_nhds_of_tendsto_at_top this d h }, { have := (tendsto_neg_const_mul_pow_at_top_iff c n).2 ⟨hn, lt_of_le_of_ne (not_lt.1 hc') hc⟩, exact not_tendsto_nhds_of_tendsto_at_bot this d h } }
have hn : 1 ≤ n := nat.succ_le_iff.2 (lt_of_le_of_ne (zero_le _) (ne.symm hn))
by_cases hc' : 0 < c
have := (tendsto_const_mul_pow_at_top_iff c n).2 ⟨hn, hc'⟩
{ have := (tendsto_const_mul_pow_at_top_iff c n).2 ⟨hn, hc'⟩, exact not_tendsto_nhds_of_tendsto_at_top this d h }
exact not_tendsto_nhds_of_tendsto_at_top this d h
have := (tendsto_neg_const_mul_pow_at_top_iff c n).2 ⟨hn, lt_of_le_of_ne (not_lt.1 hc') hc⟩
{ have := (tendsto_neg_const_mul_pow_at_top_iff c n).2 ⟨hn, lt_of_le_of_ne (not_lt.1 hc') hc⟩, exact not_tendsto_nhds_of_tendsto_at_bot this d h }
exact not_tendsto_nhds_of_tendsto_at_bot this d h
have : (λ x : α, c * x ^ n) = (λ x : α, c)
simp [hn]
simp [hn]
rw [this, tendsto_const_nhds_iff] at h
exact ⟨hn, h⟩
obtain ⟨hn, hcd⟩ := h
{ obtain ⟨hn, hcd⟩ := h, simpa [hn, hcd] using tendsto_const_nhds }
simpa [hn, hcd] using tendsto_const_nhds
intros
rw [← map_coe_Ioo_at_top h, tendsto_map'_iff]
intros
simp only [nhds_top_order, tendsto_infi, tendsto_principal] at hf ⊢
intros x hx
filter_upwards [hf x hx, hg]
exact λ x, lt_of_lt_of_le
intros
rw [inter_comm, ← subset_compl_iff_disjoint]
exact subset.trans frontier_subset_closure (closure_minimal (λ _, disjoint_left.1 hd) (is_closed_compl_iff.2 ht))
intros
let F' : J ⥤ Top := F ⋙ Top.discrete
haveI : Π (j : J), fintype (F'.obj j) := hf
haveI : Π (j : J), nonempty (F'.obj j) := hne
obtain ⟨⟨u, hu⟩⟩ := Top.nonempty_limit_cone_of_compact_t2_cofiltered_system F'
exact ⟨u, λ _ _ f, hu f⟩
intros
split
intros h u v hu hv hss huv
{ intros h u v hu hv hss huv, apply is_preconnected_iff_subset_of_disjoint_closed.1 h u v hu hv hss, rw huv, exact inter_empty s }
apply is_preconnected_iff_subset_of_disjoint_closed.1 h u v hu hv hss
rw huv
exact inter_empty s
intro H
rw is_preconnected_iff_subset_of_disjoint_closed
intros u v hu hv hss huv
have H1 := H (u ∩ s) (v ∩ s)
rw [subset_inter_iff, subset_inter_iff] at H1
simp only [subset.refl, and_true] at H1
apply H1 (is_closed.inter hu hs) (is_closed.inter hv hs)
rw ←inter_distrib_right
{ rw ←inter_distrib_right, apply subset_inter_iff.2, exact ⟨hss, subset.refl s⟩ }
apply subset_inter_iff.2
exact ⟨hss, subset.refl s⟩
rw [inter_comm v s, inter_assoc, ←inter_assoc s, inter_self s, inter_comm, inter_assoc, inter_comm v u, huv]
{ rw [inter_comm v s, inter_assoc, ←inter_assoc s, inter_self s, inter_comm, inter_assoc, inter_comm v u, huv] }
intros
set fxg := (λ p : α × γ, (f p.1, g p.2))
have key1 : f ∘ (prod.fst : α × γ → α) = (prod.fst : β × δ → β) ∘ fxg
from rfl
have key2 : g ∘ (prod.snd : α × γ → γ) = (prod.snd : β × δ → δ) ∘ fxg
from rfl
unfold prod.topological_space
conv_lhs { rw [induced_compose, induced_compose, key1, key2], congr, rw ← induced_compose, skip, rw ← induced_compose, }
rw induced_inf
intros
rw [pi_def]; exact (is_open_bInter hi $ assume a ha, (hs _ ha).preimage (continuous_apply _))
rw [pi_def]
exact (is_open_bInter hi $ assume a ha, (hs _ ha).preimage (continuous_apply _))
intros
have w := mem_closure_iff_frequently.mp (continuous_map_mem_polynomial_functions_closure _ _ f)
rw metric.nhds_basis_ball.frequently_iff at w
obtain ⟨-, H, ⟨m, ⟨-, rfl⟩⟩⟩ := w ε pos
rw [metric.mem_ball, dist_eq_norm] at H
exact ⟨m, H⟩
intros
simp [ne_bot_iff, nhds_within_pi_eq_bot]
intros
rw continuous_iff_continuous_on_univ at h
exact h.mono (subset_univ _)
intros
tauto
intros
rw [← e.coe_fst ex, prod.mk.eta, ← e.coe_coe, e.to_local_equiv.left_inv ex]
intros
lift d to (ℕ → nnreal) using (λ i, ennreal.ne_top_of_tsum_ne_top hd i)
rw ennreal.tsum_coe_ne_top_iff_summable at hd
exact cauchy_seq_of_edist_le_of_summable d hf hd
intros
apply tendsto.mul hma _ (ennreal.tendsto_inv_iff.2 hmb) _; simp [ha, hb]
apply tendsto.mul hma _ (ennreal.tendsto_inv_iff.2 hmb) _
{ apply tendsto.mul hma _ (ennreal.tendsto_inv_iff.2 hmb) _; simp [ha, hb] }
simp [ha, hb]
simp [ha, hb]
intros
rw nnreal.summable_coe
exact tsum_coe_ne_top_iff_summable
intros
ext
{ ext, refl }
refl
intros
rw [tendsto, tendsto, hg.induced, nhds_induced, ← map_le_iff_le_comap, filter.map_map]
intros
rw [inter_eq_Inter]
apply dense_Inter_of_Gδ; simp [bool.forall_bool, *]
apply dense_Inter_of_Gδ
simp [bool.forall_bool, *]
simp [bool.forall_bool, *]
intros
simpa only [dist_edist] using congr_arg ennreal.to_real (edist_pi_const a b)
intros
rw [edist_dist, ennreal.to_real_of_real (dist_nonneg)]
intros
simp [continuous_on, continuous_within_at_iff]
intros
have : separated_space (completion α) := by apply_instance
refine separated_def.1 this x y (λs hs, _)
rcases (completion.mem_uniformity_dist s).1 hs with ⟨ε, εpos, hε⟩
rw ← h at εpos
exact hε εpos
intros
rw [union_eq_Union, dimH_Union, supr_bool_eq, cond, cond, ennreal.sup_eq_max]
intros
simp only [Hausdorff_edist_def, supr_image, inf_edist_image h]
intros
have r0 : 0 < r := lt_of_le_of_lt (Hausdorff_dist_nonneg) H
have : Hausdorff_edist s t < ennreal.of_real r
rwa [Hausdorff_dist, ← ennreal.to_real_of_real (le_of_lt r0), ennreal.to_real_lt_to_real fin (ennreal.of_real_ne_top)] at H
rwa [Hausdorff_dist, ← ennreal.to_real_of_real (le_of_lt r0), ennreal.to_real_lt_to_real fin (ennreal.of_real_ne_top)] at H
rcases exists_edist_lt_of_Hausdorff_edist_lt h this with ⟨y, hy, yr⟩
rw [edist_dist, ennreal.of_real_lt_of_real_iff r0] at yr
exact ⟨y, hy, yr⟩
intros
rw continuous_def
intros s hs
change continuous' (s ∘ f)
cases hs with hs hs'
cases hf with hf hf'
apply continuous.of_bundled
apply continuous_comp _ _ hf' hs'
intros
{ ext s, rw [mem_nhds_induced, mem_comap] }
ext s
rw [mem_nhds_induced, mem_comap]
intros
simp
intros
split
intro h
{ intro h, constructor, rintros x - y -, contrapose!, intros hyp, suffices : x ∈ connected_component y, by simpa [totally_disconnected_space_iff_connected_component_singleton.1 h y, mem_singleton_iff], rw [connected_component_eq_Inter_clopen, mem_Inter], rintro ⟨w : set α, hw : is_clopen w, hy : y ∈ w⟩, by_contra hx, simpa using hyp wᶜ w (is_open_compl_iff.mpr hw.2) hw.1 hx hy }
constructor
rintros x - y -
contrapose!
intros hyp
suffices : x ∈ connected_component y
simpa [totally_disconnected_space_iff_connected_component_singleton.1 h y, mem_singleton_iff]
simpa [totally_disconnected_space_iff_connected_component_singleton.1 h y, mem_singleton_iff]
rw [connected_component_eq_Inter_clopen, mem_Inter]
rintro ⟨w : set α, hw : is_clopen w, hy : y ∈ w⟩
by_contra hx
simpa using hyp wᶜ w (is_open_compl_iff.mpr hw.2) hw.1 hx hy
apply totally_separated_space.totally_disconnected_space
intros
simpa only [hne] using hf.finite_nonempty_of_compact
intros
rw [continuous_within_at, tendsto_nhds_left]
intros
rw uniform_space.mem_nhds_iff
exact ⟨V, V_in, subset.refl _⟩
intros
rw [complete_space_iff_is_complete_range he.to_uniform_inducing, e.range_eq_univ, complete_space_iff_is_complete_univ]
intros
induction n with n ihn generalizing c
simp only [approx, right_U, right_le_midpoint]
{ simp only [approx, right_U, right_le_midpoint], exact (approx_mem_Icc_right_left c 0 x).2 }
exact (approx_mem_Icc_right_left c 0 x).2
rw [approx, approx]
{ rw [approx, approx], exact midpoint_le_midpoint (ihn _) (ihn _) }
exact midpoint_le_midpoint (ihn _) (ihn _)
intros
unfold tails; rw [corec_eq]; refl
unfold tails; rw [corec_eq]
unfold tails
rw [corec_eq]
refl
intros
simp [read', h]
intros
cases b; simp
cases b
simp
simp
intros
unfold sub_nat_nat
rw h
unfold sub_nat_nat._match_1
intros
by_cases h : x % 2 = 1
{ simp! [*] }
simp! [*]
cases mod_two_eq_zero_or_one x; simp! [*, nat.zero_ne_one]
cases mod_two_eq_zero_or_one x
{ cases mod_two_eq_zero_or_one x; simp! [*, nat.zero_ne_one] }
simp! [*, nat.zero_ne_one]
simp! [*, nat.zero_ne_one]
intros
rw [nat.mul_comm, nat.mul_div_cancel' H]
intros
rw [nat.sub_sub, nat.sub_sub, add_succ, succ_sub_succ]
intros
rwa [←sub_eq_zero, vsub_sub_vsub_cancel_right, vsub_eq_zero_iff_eq] at h
intros
simp only [one_eq_range, linear_map.mem_range, algebra.linear_map_apply]
intros
ext
ext; simp
simp
intros
rw forall_associated
split
split; intros h a; have ha := h a; rw irreducible_mk at *; rw prime_mk at *; exact ha
split; intros h a; have ha := h a; rw irreducible_mk at *; rw prime_mk at *
split; intros h a; have ha := h a; rw irreducible_mk at *
split; intros h a; have ha := h a
split; intros h a
intros h a
have ha := h a
rw irreducible_mk at *
rw prime_mk at *
exact ha
intros h a
have ha := h a
rw irreducible_mk at *
rw prime_mk at *
exact ha
intros
simpa only [sub_eq_add_neg] using sum_add_distrib.trans (congr_arg _ sum_neg_distrib)
intros
{ convert prod_multiset_map_count s id, rw map_id }
convert prod_multiset_map_count s id
rw map_id
intros
{ classical, rw [finprod_def, dif_neg hf] }
classical
rw [finprod_def, dif_neg hf]
intros
{ rw ←cocone_naturality F f, refl }
rw ←cocone_naturality F f
refl
intros
apply (cancel_epi (α_ X Y Z).hom).1
apply tensor_product.ext_threefold
intros x y z
refl
intros
rw [eq_comm, ←sub_eq_zero, ←int.cast_sub, char_p.int_cast_eq_zero_iff R p, int.modeq_iff_dvd]
intros
rw [nth_cont_eq_succ_nth_cont_aux] at nth_conts_eq succ_nth_conts_eq
exact (continuants_recurrence_aux succ_nth_s_eq nth_conts_eq succ_nth_conts_eq)
intros
cases s_nth_eq : (g.s.nth n); simp [partial_numerators, s_nth_eq]
cases s_nth_eq : (g.s.nth n)
simp [partial_numerators, s_nth_eq]
simp [partial_numerators, s_nth_eq]
intros
rw gcd
{ rw gcd, split_ifs; [simp only [h, mod_zero, gcd_zero_right], refl]}
split_ifs
split_ifs; [simp only [h, mod_zero, gcd_zero_right], refl]
simp only [h, mod_zero, gcd_zero_right]
refl
intros
rw [← lift_symm_apply, equiv.apply_symm_apply]
intros
simp [mul_assoc]
intros
rw [sub_eq_add_neg, neg_neg]
intros
simp [is_unit_iff_exists_inv, mul_comm]
intros
induction n with n ih
{ rw [pow_zero, pow_zero, one_inv] }
rw [pow_zero, pow_zero, one_inv]
{ rw [pow_succ', pow_succ, ih, mul_inv_rev] }
rw [pow_succ', pow_succ, ih, mul_inv_rev]
intros
{ rw [← int.nat_abs_sq a, sq], norm_cast, apply nat.le_mul_self }
rw [← int.nat_abs_sq a, sq]
norm_cast
apply nat.le_mul_self
intros
{ rw pow_bit0, exact mul_self_nonneg _ }
rw pow_bit0
exact mul_self_nonneg _
intros
by_cases ha : a = 0; [simp [ha], simp [mul_right_inj', ha]]
by_cases ha : a = 0
simp [ha]
simp [mul_right_inj', ha]
intros
rw [one_div_mul_one_div_rev, mul_comm b]
intros
tidy
intros
refine ⟨_, by { introI, apply_instance }⟩
introI
have : exact ((f ≫ i.hom) ≫ i.inv) (i.hom ≫ i.inv ≫ g) := infer_instance
simpa using this
intros
have P : ∀ h : i = i', eq_to_hom (congr_arg C.X h) ≫ C.d i' j = C.d i j
{ rintro rfl, simp }
rintro rfl
simp
apply P
intros
dsimp [prev_d]
simp only [chain_complex.prev]
refl
intros
{ ext, simp, }
ext
simp
intros
rw [sup_eq_mul_pos_div, inf_comm, inf_eq_div_pos_div, div_eq_mul_inv]
nth_rewrite 1 div_eq_mul_inv
rw [mul_inv_rev, inv_inv, mul_comm, ← mul_assoc, inv_mul_cancel_right, pos_eq_neg_inv (a / b)]
nth_rewrite 1 div_eq_mul_inv
rw [mul_inv_rev, ← div_eq_mul_inv, inv_inv, ← pos_mul_neg]
intros
rw [lie_ideal_oper_eq_span, lie_span_le]
rintros m ⟨x, n, hn⟩
rw ← hn
exact N.lie_mem n.property
intros
split
split; intros h
intros h
{ exact le_Sup h, }
exact le_Sup h
intros h
{ apply le_solvable_ideal_solvable h, apply_instance, }
apply le_solvable_ideal_solvable h
apply_instance
intros
{ rw ← le_bot_iff, exact lie_ideal.map_le_iff_le_comap }
rw ← le_bot_iff
exact lie_ideal.map_le_iff_le_comap
intros
rw [← lie_submodule.coe_to_submodule_eq_iff, lie_submodule.top_coe_submodule]
exact infi_max_gen_zero_eigenspace_eq_top_of_nilpotent R L M
intros
rw [units.smul_def, units.coe_neg, neg_smul, units.smul_def]
intros
rw [of', ← finsupp.supported_eq_span_single, finsupp.mem_supported]
intros
{ ext a, exact mul_hom.congr_fun h a, }
ext a
exact mul_hom.congr_fun h a
intros
by_cases xy : x ≤ y; by_cases yx : y ≤ x; simp [cmp_le, *, ordering.swap]
by_cases xy : x ≤ y; by_cases yx : y ≤ x
by_cases xy : x ≤ y
by_cases yx : y ≤ x
simp [cmp_le, *, ordering.swap]
simp [cmp_le, *, ordering.swap]
by_cases yx : y ≤ x
simp [cmp_le, *, ordering.swap]
simp [cmp_le, *, ordering.swap]
cases not_or xy yx (total_of _ _ _)
intros
rw [mul_comm, div_lt_iff_of_neg hc]
intros
simpa using le_inv ha hb
intros
simp only [← not_lt, inv_pos]
intros
simpa only [div_eq_mul_inv] using mul_lt_mul_iff_right _
intros
rw [mul_comm b, mul_comm c, ha.mul_le_mul_iff_left]
intros
haveI := @linear_order.decidable_le α _; exact ((@decidable.strict_mono_on_mul_self α _ _).lt_iff_lt h1 h2).symm
haveI := @linear_order.decidable_le α _
exact ((@decidable.strict_mono_on_mul_self α _ _).lt_iff_lt h1 h2).symm
intros
{ rw [add_comm], apply lt_add_one }
rw [add_comm]
apply lt_add_one
intros
rw [bit1, le_add_iff_nonneg_left, bit0, ← two_mul, zero_le_mul_left (zero_lt_two : 0 < (2:α))]
intros
rw [← image_mul_right', image_one, one_mul]
intros
simp only [← image_smul, image_eta, zero_smul, h.image_const, singleton_zero]
intros
{ rw a.commute_self_conj.eq, exact a.conj_mul_eq_coe }
rw a.commute_self_conj.eq
exact a.conj_mul_eq_coe
intros
rintro rfl
rcases exists_pair_ne R with ⟨x, y, xy⟩
refine xy (la _)
rw [zero_mul, zero_mul]
intros
simpa only [sub_eq_add_neg] using ha.add_left hb.neg_left
intros
simp
intros
rw [sub_eq_add_neg, add_right_inj, neg_eq]
intros
{ cases x, exact stalk_to_fiber_ring_hom_germ' R U _ _ _ }
cases x
exact stalk_to_fiber_ring_hom_germ' R U _ _ _
intros
dsimp [δ]
{ dsimp [δ], simp only [←X.map_comp, simplex_category.δ_comp_δ_self] }
simp only [←X.map_comp, simplex_category.δ_comp_δ_self]
intros
simp only [gronwall_bound_ε0, zero_mul]
intros
have A : continuous_on (λ (y : E), y - x) (emetric.ball (x : E) r) := (continuous_id.sub continuous_const).continuous_on
convert (hf.tendsto_locally_uniformly_on).comp (λ (y : E), y - x) _ A
{ ext z, simp }
ext z
simp
assume z
{ assume z, simp [edist_eq_coe_nnnorm, edist_eq_coe_nnnorm_sub] }
simp [edist_eq_coe_nnnorm, edist_eq_coe_nnnorm_sub]
intros
ext v
simp only [formal_multilinear_series.comp, comp_along_composition, continuous_multilinear_map.comp_along_composition_apply, continuous_multilinear_map.sum_apply]
apply finset.sum_congr rfl (λ c hc, _)
rw remove_zero_of_pos _ (c.length_pos_of_pos hn)
intros
refine ((h₁.norm_norm.mul h₂.norm_norm).congr _ _).of_norm_norm
refine ((h₁.norm_norm.mul h₂.norm_norm).congr _ _).of_norm_norm; by intros; simp only [norm_smul]
intros; simp only [norm_smul]
intros; simp only [norm_smul]
intros
intros
simp only [norm_smul]
simp only [norm_smul]
intros; simp only [norm_smul]
intros; simp only [norm_smul]
intros
intros
simp only [norm_smul]
simp only [norm_smul]
intros
apply has_deriv_within_at.deriv_within _ hxs
exact has_deriv_within_at.scomp x (hg.has_deriv_within_at) (hh.has_deriv_within_at) hs
intros
convert hc.mul ((has_deriv_at_inv hx).comp_has_deriv_within_at x hd)
{ simp only [div_eq_mul_inv] }
simp only [div_eq_mul_inv]
{ field_simp, ring }
field_simp
ring
intros
simp only [has_deriv_within_at, nhds_within, diff_eq, inf_assoc.symm, inf_principal.symm]
exact has_deriv_at_filter_iff_tendsto_slope
intros
simp only [deriv_within, fderiv_within_sub_const hxs]
intros
simp [sub_eq_add_neg]
intros
apply hf.lim v
rw tendsto_at_top_at_top
exact λ b, ⟨b, λ a ha, le_trans ha (le_abs_self _)⟩
intros
refine lhopital_zero_right_on_Ioo hab hdf hg' _ _ hdiv
rw [← hfa, ← nhds_within_Ioo_eq_nhds_within_Ioi hab]
{ rw [← hfa, ← nhds_within_Ioo_eq_nhds_within_Ioi hab], exact ((hcf a $ left_mem_Ico.mpr hab).mono Ioo_subset_Ico_self).tendsto }
exact ((hcf a $ left_mem_Ico.mpr hab).mono Ioo_subset_Ico_self).tendsto
rw [← hga, ← nhds_within_Ioo_eq_nhds_within_Ioi hab]
{ rw [← hga, ← nhds_within_Ioo_eq_nhds_within_Ioi hab], exact ((hcg a $ left_mem_Ico.mpr hab).mono Ioo_subset_Ico_self).tendsto }
exact ((hcg a $ left_mem_Ico.mpr hab).mono Ioo_subset_Ico_self).tendsto
intros
simp [times_cont_diff_on_univ.symm, differentiable_on_univ.symm, fderiv_within_univ.symm, - fderiv_within_univ]
rw times_cont_diff_on_top_iff_fderiv_within unique_diff_on_univ
intros
simpa only [sub_eq_add_neg] using hf.add hg.neg
intros
split
rintro ⟨a, b, ha, hb, hab, hx⟩
{ rintro ⟨a, b, ha, hb, hab, hx⟩, refine smul_right_injective _ hb.ne' ((add_right_inj (a • x)).1 _), rw [hx, ←add_smul, hab, one_smul] }
refine smul_right_injective _ hb.ne' ((add_right_inj (a • x)).1 _)
rw [hx, ←add_smul, hab, one_smul]
rintro rfl
{ rintro rfl, rw open_segment_same, exact mem_singleton _ }
rw open_segment_same
exact mem_singleton _
intros
have h := (hs.smul c).translate z
rwa [←image_smul, image_image] at h
intros
refine subset.antisymm (convex_hull_min _ _) _
intros x hx
{ intros x hx, use [punit, {punit.star}, λ _, 1, λ _, x, λ _ _, zero_le_one, finset.sum_singleton, λ _ _, hx], simp only [finset.center_mass, finset.sum_singleton, inv_one, one_smul] }
use [punit, {punit.star}, λ _, 1, λ _, x, λ _ _, zero_le_one, finset.sum_singleton, λ _ _, hx]
simp only [finset.center_mass, finset.sum_singleton, inv_one, one_smul]
rintros x y ⟨ι, sx, wx, zx, hwx₀, hwx₁, hzx, rfl⟩ ⟨ι', sy, wy, zy, hwy₀, hwy₁, hzy, rfl⟩ a b ha hb hab
{ rintros x y ⟨ι, sx, wx, zx, hwx₀, hwx₁, hzx, rfl⟩ ⟨ι', sy, wy, zy, hwy₀, hwy₁, hzy, rfl⟩ a b ha hb hab, rw [finset.center_mass_segment' _ _ _ _ _ _ hwx₁ hwy₁ _ _ hab], refine ⟨_, _, _, _, _, _, _, rfl⟩, { rintros i hi, rw [finset.mem_union, finset.mem_map, finset.mem_map] at hi, rcases hi with ⟨j, hj, rfl⟩|⟨j, hj, rfl⟩; simp only [sum.elim_inl, sum.elim_inr]; apply_rules [mul_nonneg, hwx₀, hwy₀] }, { simp [finset.sum_sum_elim, finset.mul_sum.symm, *] }, { intros i hi, rw [finset.mem_union, finset.mem_map, finset.mem_map] at hi, rcases hi with ⟨j, hj, rfl⟩|⟨j, hj, rfl⟩; apply_rules [hzx, hzy] } }
rw [finset.center_mass_segment' _ _ _ _ _ _ hwx₁ hwy₁ _ _ hab]
refine ⟨_, _, _, _, _, _, _, rfl⟩
rintros i hi
{ rintros i hi, rw [finset.mem_union, finset.mem_map, finset.mem_map] at hi, rcases hi with ⟨j, hj, rfl⟩|⟨j, hj, rfl⟩; simp only [sum.elim_inl, sum.elim_inr]; apply_rules [mul_nonneg, hwx₀, hwy₀] }
rw [finset.mem_union, finset.mem_map, finset.mem_map] at hi
rcases hi with ⟨j, hj, rfl⟩|⟨j, hj, rfl⟩; simp only [sum.elim_inl, sum.elim_inr]; apply_rules [mul_nonneg, hwx₀, hwy₀]
rcases hi with ⟨j, hj, rfl⟩|⟨j, hj, rfl⟩; simp only [sum.elim_inl, sum.elim_inr]
rcases hi with ⟨j, hj, rfl⟩|⟨j, hj, rfl⟩
simp only [sum.elim_inl, sum.elim_inr]
apply_rules [mul_nonneg, hwx₀, hwy₀]
simp only [sum.elim_inl, sum.elim_inr]
apply_rules [mul_nonneg, hwx₀, hwy₀]
{ simp [finset.sum_sum_elim, finset.mul_sum.symm, *] }
simp [finset.sum_sum_elim, finset.mul_sum.symm, *]
intros i hi
{ intros i hi, rw [finset.mem_union, finset.mem_map, finset.mem_map] at hi, rcases hi with ⟨j, hj, rfl⟩|⟨j, hj, rfl⟩; apply_rules [hzx, hzy] }
rw [finset.mem_union, finset.mem_map, finset.mem_map] at hi
rcases hi with ⟨j, hj, rfl⟩|⟨j, hj, rfl⟩; apply_rules [hzx, hzy]
rcases hi with ⟨j, hj, rfl⟩|⟨j, hj, rfl⟩
apply_rules [hzx, hzy]
apply_rules [hzx, hzy]
rintros _ ⟨ι, t, w, z, hw₀, hw₁, hz, rfl⟩
{ rintros _ ⟨ι, t, w, z, hw₀, hw₁, hz, rfl⟩, exact t.center_mass_mem_convex_hull hw₀ (hw₁.symm ▸ zero_lt_one) hz }
exact t.center_mass_mem_convex_hull hw₀ (hw₁.symm ▸ zero_lt_one) hz
intros
rcases riesz_extension.exists_top s f nonneg dense with ⟨⟨g_dom, g⟩, ⟨hpg, hfg⟩, htop, hgs⟩
clear hpg
refine ⟨g ∘ₗ ↑(linear_equiv.of_top _ htop).symm, _, _⟩
refine ⟨g ∘ₗ ↑(linear_equiv.of_top _ htop).symm, _, _⟩; simp only [comp_apply, linear_equiv.coe_coe, linear_equiv.of_top_symm_apply]
simp only [comp_apply, linear_equiv.coe_coe, linear_equiv.of_top_symm_apply]
{ exact λ x, (hfg (submodule.coe_mk _ _).symm).symm }
exact λ x, (hfg (submodule.coe_mk _ _).symm).symm
simp only [comp_apply, linear_equiv.coe_coe, linear_equiv.of_top_symm_apply]
{ exact λ x hx, hgs ⟨x, _⟩ hx }
exact λ x hx, hgs ⟨x, _⟩ hx
intros
rw [←neg_le_neg_iff, ←neg_sub_neg (f x), ←neg_sub_neg (f y)]
simp_rw [←pi.neg_apply, ←neg_div, neg_sub]
exact convex_on.slope_mono_adjacent hf.neg hx hz hxy hyz
intros
rw [inner_eq_zero_sym]; exact submodule.inner_right_of_mem_orthogonal hu hv
rw [inner_eq_zero_sym]
exact submodule.inner_right_of_mem_orthogonal hu hv
intros
rw [←inner_conj_sym, conj_re]
intros
have h₁ : ⟪y, x⟫_ℝ = ⟪x, y⟫_ℝ := by rw [←inner_conj_sym]; refl
have h₂ := @inner_mul_inner_self_le ℝ F _ _ x y
dsimp at h₂
have h₃ := abs_mul_abs_self ⟪x, y⟫_ℝ
rw [h₁] at h₂
simpa [h₃] using h₂
intros
{ rw [norm_sub_mul_self], ring }
rw [norm_sub_mul_self]
ring
intros
rw [← complex.isometry_euclidean_symm_apply (complex.isometry_euclidean z), complex.isometry_euclidean.symm_apply_apply z]
intros
have := nnreal.coe_le_coe.2 (nnreal.Lp_add_le s (λ i, ⟨_, abs_nonneg (f i)⟩) (λ i, ⟨_, abs_nonneg (g i)⟩) hp)
push_cast at this
refine le_trans (rpow_le_rpow _ (sum_le_sum $ λ i hi, _) _) this
refine le_trans (rpow_le_rpow _ (sum_le_sum $ λ i hi, _) _) this; simp [sum_nonneg, rpow_nonneg_of_nonneg, abs_nonneg, le_trans zero_le_one hp, abs_add, rpow_le_rpow]
simp [sum_nonneg, rpow_nonneg_of_nonneg, abs_nonneg, le_trans zero_le_one hp, abs_add, rpow_le_rpow]
simp [sum_nonneg, rpow_nonneg_of_nonneg, abs_nonneg, le_trans zero_le_one hp, abs_add, rpow_le_rpow]
simp [sum_nonneg, rpow_nonneg_of_nonneg, abs_nonneg, le_trans zero_le_one hp, abs_add, rpow_le_rpow]
intros
rw [dist_comm, dist_center_homothety]
intros
choose C hC fsymm h using exists_preimage_norm_le _ (linear_map.range_eq_top.mp hsurj)
use { to_fun := fsymm, nnnorm := ⟨C, hC.lt.le⟩, bound' := λ y, (h y).2, right_inv' := λ y, (h y).1 }
exact hC
intros
rcases exists_one_lt_norm α with ⟨y, hy⟩
refine ⟨y⁻¹, _, _⟩
simp only [inv_eq_zero, ne.def, norm_pos_iff]
{ simp only [inv_eq_zero, ne.def, norm_pos_iff], rintro rfl, rw norm_zero at hy, exact lt_asymm zero_lt_one hy }
rintro rfl
rw norm_zero at hy
exact lt_asymm zero_lt_one hy
{ simp [inv_lt_one hy] }
simp [inv_lt_one hy]
intros
simp only [dist_eq_norm, (norm_smul _ _).symm, smul_sub]
intros
replace h := mem_cofinite.1 h
refine h.summable_compl_iff.mp _
refine summable_of_norm_bounded _ (h.summable_compl_iff.mpr hg) _
rintros ⟨a, h'⟩
simpa using h'
intros
simp only [norm_def, coe_restrict_scalars]
intros
refine le_antisymm (op_norm_le_bound _ (le_refl _) (λ x, _)) (norm_nonneg _)
have hker : x ∈ (S.normed_mk).ker.topological_closure
rw [S.ker_normed_mk]
{ rw [S.ker_normed_mk], exact set.mem_of_eq_of_mem h trivial }
exact set.mem_of_eq_of_mem h trivial
rw [ker_normed_mk] at hker
simp only [(quotient_norm_eq_zero_iff S x).mpr hker, normed_mk.apply, zero_mul]
rw ← not_summable_iff_tendsto_nat_at_top_of_nonneg
exact_mod_cast mt (summable_nat_add_iff 1).1 real.not_summable_one_div_nat_cast
{ exact_mod_cast mt (summable_nat_add_iff 1).1 real.not_summable_one_div_nat_cast }
exact λ i, div_nonneg zero_le_one i.cast_add_one_pos.le
{ exact λ i, div_nonneg zero_le_one i.cast_add_one_pos.le }
intros
have H := real.cosh_sq_sub_sinh_sq x
have G : cosh x ^ 2 - sinh x ^ 2 + sinh x ^ 2 = 1 + sinh x ^ 2 := by rw H
rw sub_add_cancel at G
rw [←G, sqrt_sq]
exact le_of_lt (cosh_pos x)
intros
refine ⟨λ hs, _, λ hs, _⟩
refine ((hs.image exp).insert 0).mono _
{ refine ((hs.image exp).insert 0).mono _, rw [image_preimage_eq_inter_range, range_exp, ← diff_eq, ← union_singleton, diff_union_self], exact subset_union_left _ _ }
rw [image_preimage_eq_inter_range, range_exp, ← diff_eq, ← union_singleton, diff_union_self]
exact subset_union_left _ _
rw ← bUnion_preimage_singleton
{ rw ← bUnion_preimage_singleton, refine hs.bUnion (λ z hz, _), rcases em (∃ w, exp w = z) with ⟨w, rfl⟩|hne, { simp only [preimage, mem_singleton_iff, exp_eq_exp_iff_exists_int, set_of_exists], exact countable_Union (λ m, countable_singleton _) }, { push_neg at hne, simp [preimage, hne] } }
refine hs.bUnion (λ z hz, _)
rcases em (∃ w, exp w = z) with ⟨w, rfl⟩|hne
simp only [preimage, mem_singleton_iff, exp_eq_exp_iff_exists_int, set_of_exists]
{ simp only [preimage, mem_singleton_iff, exp_eq_exp_iff_exists_int, set_of_exists], exact countable_Union (λ m, countable_singleton _) }
exact countable_Union (λ m, countable_singleton _)
{ push_neg at hne, simp [preimage, hne] }
push_neg at hne
simp [preimage, hne]
rw [← coe_comp_exp_order_iso, ← filter.map_map, order_iso.map_at_top, map_coe_Ioi_at_top]
intros
induction n with k ih
norm_num
{ norm_num }
rw [prod_range_succ_comm, mul_left_comm, ← ih, mul_succ, integral_sin_pow]
norm_cast
simp [-cast_add] with field_simps
intros
by_cases h : x = 0; simp [h, zero_le_one]
{ by_cases h : x = 0; simp [h, zero_le_one] }
by_cases h : x = 0
simp [h, zero_le_one]
simp [h, zero_le_one]
intros
rw [rpow_def_of_pos hx0]
repeat {rw [rpow_def_of_pos hx0]}
rw [rpow_def_of_pos hx0]
rw [rpow_def_of_pos hx0]
rw exp_le_exp
exact mul_le_mul_of_nonpos_left hyz (log_nonpos (le_of_lt hx0) hx1)
intros
rw [← cos_sub_pi_div_two, ← cos_sub_pi_div_two, ← cos_neg (x - _), ← cos_neg (y - _)]
rw [← cos_sub_pi_div_two, ← cos_sub_pi_div_two, ← cos_neg (x - _), ← cos_neg (y - _)]; apply cos_lt_cos_of_nonneg_of_le_pi; linarith
rw [← cos_sub_pi_div_two, ← cos_sub_pi_div_two, ← cos_neg (x - _), ← cos_neg (y - _)]; apply cos_lt_cos_of_nonneg_of_le_pi
apply cos_lt_cos_of_nonneg_of_le_pi
linarith
linarith
linarith
intros
exact_mod_cast @complex.cos_eq_cos_iff x y
intros
rw [arccos, ← sin_pi_div_two_sub, arcsin_sin]; simp [sub_eq_add_neg]; linarith
rw [arccos, ← sin_pi_div_two_sub, arcsin_sin]; simp [sub_eq_add_neg]
rw [arccos, ← sin_pi_div_two_sub, arcsin_sin]
simp [sub_eq_add_neg]
simp [sub_eq_add_neg]
linarith
simp [sub_eq_add_neg]
linarith
intros
simpa only [category.assoc] using (iso.comp_inv_eq p).mpr ((arrow.w_mk_right sq).symm)
intros
rw [conj_apply, iso.refl_inv, iso.refl_hom, category.id_comp, category.comp_id]
intros
{ cases f, cases f, cases f, refl }
cases f
cases f
cases f
refl
intros
subst h; simp
subst h
simp
intros
simp only [←category.assoc, cancel_mono]
intros
rw [←cancel_epi (limit_uncurry_iso_limit_comp_lim F).hom]
simp
intros
rw [h.hom_desc f, h.hom_desc f']; congr; exact funext w
rw [h.hom_desc f, h.hom_desc f']; congr
rw [h.hom_desc f, h.hom_desc f']
congr
exact funext w
intros
{ ext; simp }
ext
ext; simp
simp
simp
intros
simp [is_iso.inv_comp_eq]
intros
ext
simp only [map_pair_left, is_colimit.ι_map, is_limit.map_π, biprod.inl_fst_assoc, category.assoc, ←binary_bicone.to_cone_π_app_left, ←binary_biproduct.bicone_fst, ←binary_bicone.to_cocone_ι_app_left, ←binary_biproduct.bicone_inl]
{ simp only [map_pair_left, is_colimit.ι_map, is_limit.map_π, biprod.inl_fst_assoc, category.assoc, ←binary_bicone.to_cone_π_app_left, ←binary_biproduct.bicone_fst, ←binary_bicone.to_cocone_ι_app_left, ←binary_biproduct.bicone_inl], simp }
simp
simp only [map_pair_left, is_colimit.ι_map, is_limit.map_π, zero_comp, biprod.inl_snd_assoc, category.assoc, ←binary_bicone.to_cone_π_app_right, ←binary_biproduct.bicone_snd, ←binary_bicone.to_cocone_ι_app_left, ←binary_biproduct.bicone_inl]
{ simp only [map_pair_left, is_colimit.ι_map, is_limit.map_π, zero_comp, biprod.inl_snd_assoc, category.assoc, ←binary_bicone.to_cone_π_app_right, ←binary_biproduct.bicone_snd, ←binary_bicone.to_cocone_ι_app_left, ←binary_biproduct.bicone_inl], simp }
simp
simp only [map_pair_right, biprod.inr_fst_assoc, is_colimit.ι_map, is_limit.map_π, zero_comp, category.assoc, ←binary_bicone.to_cone_π_app_left, ←binary_biproduct.bicone_fst, ←binary_bicone.to_cocone_ι_app_right, ←binary_biproduct.bicone_inr]
{ simp only [map_pair_right, biprod.inr_fst_assoc, is_colimit.ι_map, is_limit.map_π, zero_comp, category.assoc, ←binary_bicone.to_cone_π_app_left, ←binary_biproduct.bicone_fst, ←binary_bicone.to_cocone_ι_app_right, ←binary_biproduct.bicone_inr], simp }
simp
simp only [map_pair_right, is_colimit.ι_map, is_limit.map_π, biprod.inr_snd_assoc, category.assoc, ←binary_bicone.to_cone_π_app_right, ←binary_biproduct.bicone_snd, ←binary_bicone.to_cocone_ι_app_right, ←binary_biproduct.bicone_inr]
{ simp only [map_pair_right, is_colimit.ι_map, is_limit.map_π, biprod.inr_snd_assoc, category.assoc, ←binary_bicone.to_cone_π_app_right, ←binary_biproduct.bicone_snd, ←binary_bicone.to_cocone_ι_app_right, ←binary_biproduct.bicone_inr], simp }
simp
intros
{ ext; simp [← G.map_comp] }
ext
ext; simp [← G.map_comp]
simp [← G.map_comp]
simp [← G.map_comp]
intros
rw [←tensor_left_iff, ←cancel_epi (α_ (𝟙_ C) (𝟙_ _) (𝟙_ _)).hom, ←cancel_mono (ρ_ (𝟙_ C)).hom, triangle, ←right_unitor_tensor, right_unitor_naturality]
intros
dsimp [tensor_hom]
apply is_limit.hom_ext (ℬ _ _).is_limit
rintro ⟨⟩
{ simp, }
simp
apply is_limit.hom_ext (ℬ _ _).is_limit
{ apply is_limit.hom_ext (ℬ _ _).is_limit, rintro ⟨⟩, { simp, }, apply is_limit.hom_ext (ℬ _ _).is_limit, rintro ⟨⟩, { simp, }, { simp, }, }
rintro ⟨⟩
{ simp, }
simp
apply is_limit.hom_ext (ℬ _ _).is_limit
rintro ⟨⟩
{ simp, }
simp
{ simp, }
simp
intros
simp only [cancel_epi]
intros
simp [of_mk_le, of_le_mk, of_le, of_mk_le_mk, ←functor.map_comp underlying]
intros
{ dsimp [factor_thru_kernel_subobject], simp, }
dsimp [factor_thru_kernel_subobject]
simp
intros
simp [kernel_subobject_iso]
intros
simp [boundary, fin.ext_iff]
intros
have : l'.length ∈ (l.split_wrt_composition c).map list.length := list.mem_map_of_mem list.length h
rw map_length_split_wrt_composition at this
exact c.blocks_pos this
intros
rw ←card_derangements_invariant (card_fin _)
exact card_derangements_fin_eq_num_derangements
intros
induction n with m hm m hm; unfold encode_pos_num decode_pos_num
induction n with m hm m hm
unfold encode_pos_num decode_pos_num
{ refl }
refl
unfold encode_pos_num decode_pos_num
rw hm
{ rw hm, exact if_neg (encode_pos_num_nonempty m) }
exact if_neg (encode_pos_num_nonempty m)
unfold encode_pos_num decode_pos_num
{ exact congr_arg pos_num.bit0 hm }
exact congr_arg pos_num.bit0 hm
intros
simp only [star_eq_supr_pow, mul_supr, supr_mul, ← pow_succ, ← pow_succ']
intros
induction x; simp [rmatch, match_epsilon, deriv, *]
induction x
simp [rmatch, match_epsilon, deriv, *]
simp [rmatch, match_epsilon, deriv, *]
intros
induction k generalizing v; simp only [cont.then, step_ret, cfg.then, *]
induction k generalizing v
simp only [cont.then, step_ret, cfg.then, *]
simp only [cont.then, step_ret, cfg.then, *]
{ rw ← step_normal_then, refl }
rw ← step_normal_then
refl
simp only [cont.then, step_ret, cfg.then, *]
simp only [cont.then, step_ret, cfg.then, *]
{ rw ← step_normal_then }
rw ← step_normal_then
simp only [cont.then, step_ret, cfg.then, *]
{ split_ifs, {rw ← k_ih}, {rw ← step_normal_then, refl} }
split_ifs
rw ← k_ih
{rw ← k_ih}
rw ← step_normal_then
{rw ← step_normal_then, refl}
refl
intros
simp only [(>=>)] with functor_norm
intros
rw ← comp_bitraverse; simp [tfst,map_comp_pure,has_pure.pure]
rw ← comp_bitraverse
simp [tfst,map_comp_pure,has_pure.pure]
intros
cases x with x; simp! [*] with functor_norm
cases x with x
simp! [*] with functor_norm
simp! [*] with functor_norm
intros
congr
congr; assumption
assumption
assumption
intros
cases hp : p cb n; simp [hp, ←bind_eq_bind, parser.bind, and_assoc]
cases hp : p cb n
simp [hp, ←bind_eq_bind, parser.bind, and_assoc]
simp [hp, ←bind_eq_bind, parser.bind, and_assoc]
intros
simp [foldl, foldl_core_succ_eq_fail]
intros
have : ch c [c].to_buffer 0 = done 1 ()
have : 0 < [c].to_buffer.size := dec_trivial
{ have : 0 < [c].to_buffer.size := dec_trivial, simp [ch_eq_done, this] }
simp [ch_eq_done, this]
exact not_of_ne this zero_ne_one
intros
rw [← of_real_tanh_of_real_re, of_real_im]
intros
refine @eq.rec_on (ℕ → α) _ (is_cau_seq abs) _ _ (-⟨_, @is_cau_of_decreasing_bounded _ _ _ (λ n, -f n) a m (by simpa) (by simpa)⟩ : cau_seq α abs).2
ext
exact neg_neg _
intros
simp [bit0]
intros
have h₂ : ∥z∥ = real.sqrt (∥z∥^2) := (real.sqrt_sq (norm_nonneg z)).symm
rw [h₂]
exact congr_arg real.sqrt (norm_sq_eq_def' z)
intros
simp [(•)]
intros
rw [erase_single, if_neg h]
intros
ext i
ext i; by_cases h : p i; simp [h]
ext i; by_cases h : p i
by_cases h : p i
simp [h]
simp [h]
intros
substs h h2
{ substs h h2, refl }
refl
intros
dsimp [fin_rotate]
simp [h, add_comm]
intros
rw [e.trans_source', e.symm_image_target_inter_eq]
intros
{ ext, simp only [succ_above_below, cast_succ_lt_last] }
ext
simp only [succ_above_below, cast_succ_lt_last]
intros
simp [cons]
intros
simp [pi.le_def, forall_iff_succ_above i]
intros
rw ←of_nat_eq_coe
exact nat.mod_eq_of_lt h
intros
simp [piecewise, hi]
intros
change (s.1.map f).erase_dup.card = s.1.card at H
have : (s.1.map f).erase_dup = s.1.map f
apply multiset.eq_of_le_of_card_le
{ apply multiset.eq_of_le_of_card_le, { apply multiset.erase_dup_le }, rw H, simp only [multiset.card_map] }
{ apply multiset.erase_dup_le }
apply multiset.erase_dup_le
rw H
simp only [multiset.card_map]
rw multiset.erase_dup_eq_self at this
apply inj_on_of_nodup_map this
intros
{ rw bUnion_singleton, exact image_id }
rw bUnion_singleton
exact image_id
intros
subst s
refine eq_of_forall_ge_iff (λ c, _)
simp only [sup'_le_iff, h₂] { contextual := tt }
intros
classical
convert fintype.card_le_of_embedding (subtype_or_left_embedding p q)
rw fintype.card_sum
intros
rw fintype.of_equiv_card; simp
rw fintype.of_equiv_card
simp
intros
rcases int.units_eq_one_or x with (rfl | rfl); simp
rcases int.units_eq_one_or x with (rfl | rfl)
simp
simp
intros
unfold sub_nat_nat
cases e : n - m
{ simp [sub_nat_nat, e, nat.le_of_sub_eq_zero e] }
simp [sub_nat_nat, e, nat.le_of_sub_eq_zero e]
rw [sub_nat_nat, cast_neg_succ_of_nat, ← nat.cast_succ, ← e, nat.cast_sub $ _root_.le_of_lt $ nat.lt_of_sub_eq_succ e, neg_sub]
{ rw [sub_nat_nat, cast_neg_succ_of_nat, ← nat.cast_succ, ← e, nat.cast_sub $ _root_.le_of_lt $ nat.lt_of_sub_eq_succ e, neg_sub] }
intros
rw_mod_cast [even_iff, nat.even_iff]
intros
cases l
cases l; refl
refl
refl
intros
simp only [nth_modify_nth, if_pos]
intros
cases l; refl
cases l
refl
refl
intros
induction i with i hi generalizing b l
cases l
{ cases l, { simp only [length, zero_add, scanl_nil] at h, exact absurd h (lt_irrefl 1) }, { simp only [scanl_cons, singleton_append, nth_le_zero_scanl, nth_le] } }
simp only [length, zero_add, scanl_nil] at h
{ simp only [length, zero_add, scanl_nil] at h, exact absurd h (lt_irrefl 1) }
exact absurd h (lt_irrefl 1)
{ simp only [scanl_cons, singleton_append, nth_le_zero_scanl, nth_le] }
simp only [scanl_cons, singleton_append, nth_le_zero_scanl, nth_le]
cases l
{ cases l, { simp only [length, add_lt_iff_neg_right, scanl_nil] at h, exact absurd h (not_lt_of_lt nat.succ_pos') }, { simp_rw scanl_cons, rw nth_le_append_right _, { simpa only [hi, length, succ_add_sub_one] }, { simp only [length, nat.zero_le, le_add_iff_nonneg_left] } } }
simp only [length, add_lt_iff_neg_right, scanl_nil] at h
{ simp only [length, add_lt_iff_neg_right, scanl_nil] at h, exact absurd h (not_lt_of_lt nat.succ_pos') }
exact absurd h (not_lt_of_lt nat.succ_pos')
simp_rw scanl_cons
{ simp_rw scanl_cons, rw nth_le_append_right _, { simpa only [hi, length, succ_add_sub_one] }, { simp only [length, nat.zero_le, le_add_iff_nonneg_left] } }
rw nth_le_append_right _
{ simpa only [hi, length, succ_add_sub_one] }
simpa only [hi, length, succ_add_sub_one]
{ simp only [length, nat.zero_le, le_add_iff_nonneg_left] }
simp only [length, nat.zero_le, le_add_iff_nonneg_left]
intros
simp [prod_inv_reverse]
intros
induction L generalizing i
simp
{ simp }
cases i
simp
{ simp }
simp [take_append, L_ih]
intros
simp [lookmap, h]
intros
{ rw tails_eq_inits l, simp [reverse_involutive.comp_self], }
rw tails_eq_inits l
simp [reverse_involutive.comp_self]
intros
simp [erasep_cons, h]
intros
simp only [diff_eq_foldl, foldl_map, map_foldl_erase finj]
intros
cases bs; refl
cases bs
refl
refl
intros
cases l; refl
cases l
refl
refl
intros
simp only [chain_cons, chain.nil, and_true]
intros
induction xs with y ys IH
{ cases x_mem }
cases x_mem
cases ys with z zs
{ simp at x_mem x_ne, contradiction }
simp at x_mem x_ne
contradiction
by_cases h : x = y
rw [h, next_or_self_cons_cons, next_or_self_cons_cons]
{ rw [h, next_or_self_cons_cons, next_or_self_cons_cons] }
rw [next_or, next_or, IH]; simpa [h] using x_mem
rw [next_or, next_or, IH]
{ rw [next_or, next_or, IH]; simpa [h] using x_mem }
simpa [h] using x_mem
simpa [h] using x_mem
intros
rw [Ico, nat.sub_zero, range_eq_range']
intros
simp only [antidiagonal, range_succ_eq_map, map_cons, true_and, nat.add_succ_sub_one, add_zero, id.def, eq_self_iff_true, nat.sub_zero, map_map, prod.map_mk]
apply congr (congr rfl _) rfl
ext
ext; simp
simp
simp
intros
classical
rw [duplicate_iff_two_le_count, le_count_iff_repeat_sublist, sublist_iff_exists_fin_order_embedding_nth_le_eq]
split
rintro ⟨f, hf⟩
{ rintro ⟨f, hf⟩, refine ⟨f ⟨0, by simp⟩, fin.is_lt _, f ⟨1, by simp⟩, fin.is_lt _, by simp, _, _⟩, { simpa using hf ⟨0, by simp⟩ }, { simpa using hf ⟨1, by simp⟩ } }
refine ⟨f ⟨0, by simp⟩, fin.is_lt _, f ⟨1, by simp⟩, fin.is_lt _, by simp, _, _⟩
{ simpa using hf ⟨0, by simp⟩ }
simpa using hf ⟨0, by simp⟩
{ simpa using hf ⟨1, by simp⟩ }
simpa using hf ⟨1, by simp⟩
rintro ⟨n, hn, m, hm, hnm, h, h'⟩
{ rintro ⟨n, hn, m, hm, hnm, h, h'⟩, refine ⟨order_embedding.of_strict_mono (λ i, if (i : ℕ) = 0 then ⟨n, hn⟩ else ⟨m, hm⟩) _, _⟩, { rintros ⟨⟨_|i⟩, hi⟩ ⟨⟨_|j⟩, hj⟩, { simp }, { simp [hnm] }, { simp }, { simp only [nat.lt_succ_iff, nat.succ_le_succ_iff, repeat, length, nonpos_iff_eq_zero] at hi hj, simp [hi, hj] } }, { rintros ⟨⟨_|i⟩, hi⟩, { simpa using h }, { simpa using h' } } }
refine ⟨order_embedding.of_strict_mono (λ i, if (i : ℕ) = 0 then ⟨n, hn⟩ else ⟨m, hm⟩) _, _⟩
rintros ⟨⟨_|i⟩, hi⟩ ⟨⟨_|j⟩, hj⟩
{ rintros ⟨⟨_|i⟩, hi⟩ ⟨⟨_|j⟩, hj⟩, { simp }, { simp [hnm] }, { simp }, { simp only [nat.lt_succ_iff, nat.succ_le_succ_iff, repeat, length, nonpos_iff_eq_zero] at hi hj, simp [hi, hj] } }
{ simp }
simp
{ simp [hnm] }
simp [hnm]
{ simp }
simp
simp only [nat.lt_succ_iff, nat.succ_le_succ_iff, repeat, length, nonpos_iff_eq_zero] at hi hj
{ simp only [nat.lt_succ_iff, nat.succ_le_succ_iff, repeat, length, nonpos_iff_eq_zero] at hi hj, simp [hi, hj] }
simp [hi, hj]
rintros ⟨⟨_|i⟩, hi⟩
{ rintros ⟨⟨_|i⟩, hi⟩, { simpa using h }, { simpa using h' } }
{ simpa using h }
simpa using h
{ simpa using h' }
simpa using h'
intros
induction l; [exact pairwise.nil, simp only [*, pairwise_cons, forall_2_true_iff, and_true]]
induction l
exact pairwise.nil
simp only [*, pairwise_cons, forall_2_true_iff, and_true]
intros
rw subperm_ext_iff at h ⊢
intros y hy
by_cases hy' : y = x
subst x
{ subst x, simpa using nat.succ_le_of_lt hx }
simpa using nat.succ_le_of_lt hx
rw count_cons_of_ne hy'
{ rw count_cons_of_ne hy', refine h y _, simpa [hy'] using hy }
refine h y _
simpa [hy'] using hy
intros
simp only [iota_eq_reverse_range', pairwise_reverse, pairwise_lt_range']
intros
rw [eq_comm, rotate_eq_nil_iff, eq_comm]
intros
rw [sublists_append, sublists_singleton, bind_eq_bind, cons_bind, cons_bind, nil_bind, map_eq_map, map_eq_map, map_id' (append_nil), append_nil]
intros
convert (list.zip_with_map f id g l l')
{ convert (list.zip_with_map f id g l l'), exact eq.symm (list.map_id _) }
exact eq.symm (list.map_id _)
intros
cases l; refl
cases l
refl
refl
intros
{ ext, refl }
ext
refl
intros
ext i' j
rw [transpose_apply, update_row_apply, update_column_apply]
refl
intros
rw [algebra_map_eq_diagonal, algebra_map_eq_diagonal, diagonal_map hf]
congr' 1 with x
simp only [hf₂, pi.algebra_map_apply]
intros
ext i j
rcases i
rcases i; rcases j; simp only [from_blocks, mul_apply, fintype.sum_sum_type, sum.elim_inl, sum.elim_inr, pi.add_apply]
rcases i; rcases j
rcases j
simp only [from_blocks, mul_apply, fintype.sum_sum_type, sum.elim_inl, sum.elim_inr, pi.add_apply]
simp only [from_blocks, mul_apply, fintype.sum_sum_type, sum.elim_inl, sum.elim_inr, pi.add_apply]
rcases j
simp only [from_blocks, mul_apply, fintype.sum_sum_type, sum.elim_inl, sum.elim_inr, pi.add_apply]
simp only [from_blocks, mul_apply, fintype.sum_sum_type, sum.elim_inl, sum.elim_inr, pi.add_apply]
intros
{ ext, simp [h], }
ext
simp [h]
intros
{ ext i j, refine fin.cases _ _ i, { refl }, simp [mul_val_succ] }
ext i j
refine fin.cases _ _ i
refl
{ refl }
simp [mul_val_succ]
intros
{ rcases s with ⟨l⟩, simp }
rcases s with ⟨l⟩
simp
intros
revert s u
refine multiset.induction_on t _ (λ a t IH, _)
refine multiset.induction_on t _ (λ a t IH, _); intros
intros
{ simp [h₁] }
simp [h₁]
intros
by_cases a ∈ u
rw [cons_inter_of_pos _ h, ← erase_le_iff_le_cons]
{ rw [cons_inter_of_pos _ h, ← erase_le_iff_le_cons], exact IH (erase_le_iff_le_cons.2 h₁) (erase_le_erase _ h₂) }
exact IH (erase_le_iff_le_cons.2 h₁) (erase_le_erase _ h₂)
rw cons_inter_of_neg _ h
{ rw cons_inter_of_neg _ h, exact IH ((le_cons_of_not_mem $ mt (mem_of_le h₂) h).1 h₁) h₂ }
exact IH ((le_cons_of_not_mem $ mt (mem_of_le h₂) h).1 h₁) h₂
intros
simp only [singleton_eq_cons, card_zero, eq_self_iff_true, zero_add, card_cons]
intros
simp [C_apply, monomial]
intros
simp [expand, bind₁_rename, rename_bind₁]
intros
simp
intros
rw nat.mod_two_of_bodd
{ rw nat.mod_two_of_bodd, simp }
simp
intros
simp [H]
intros
rw [subsingleton.elim mn (le_trans (le_succ m) smn), decreasing_induction_trans, decreasing_induction_succ']
{ rw [subsingleton.elim mn (le_trans (le_succ m) smn), decreasing_induction_trans, decreasing_induction_succ'] }
intros
simp [land]
intros
induction L with d L ih
{ refl, }
refl
{ dsimp [of_digits], push_cast, rw ih, }
dsimp [of_digits]
push_cast
rw ih
intros
split
{ rintro rfl n, exact coe_lt_top _ }
rintro rfl n
exact coe_lt_top _
contrapose!
{ contrapose!, rw ne_top_iff, rintro ⟨n, rfl⟩, exact ⟨n, irrefl _⟩ }
rw ne_top_iff
rintro ⟨n, rfl⟩
exact ⟨n, irrefl _⟩
intros
rw [←pochhammer_nat_eq_asc_factorial, pochhammer_eval_cast, nat.cast_add, nat.cast_one]
intros
{ rw ← sup_supr_nat_succ, simp }
rw ← sup_supr_nat_succ
simp
intros
rw [nat.modeq, nat.add_mod_right]
intros
rw [odd_iff_not_even, even_add, not_iff, odd_iff_not_even]
rw factors
intros
rw ← nat.dvd_iff_mod_eq_zero at hd; exact le_antisymm (nat.min_fac_le_of_dvd (nat.bit1_lt h.1) hd) h.2
rw ← nat.dvd_iff_mod_eq_zero at hd
exact le_antisymm (nat.min_fac_le_of_dvd (nat.bit1_lt h.1) hd) h.2
intros
cases m; cases n; refl
cases m; cases n
cases m
cases n
refl
refl
cases n
refl
refl
intros
linarith
intros
dsimp [restrict, mem_eq]
split
{ rintro ⟨h₀, h₁⟩, exact ⟨h₀, ⟨_, h₁⟩⟩ }
rintro ⟨h₀, h₁⟩
exact ⟨h₀, ⟨_, h₁⟩⟩
rintro ⟨h₀, h₁, h₂⟩
exact ⟨h₀, h₂⟩
intros
cases x
dsimp [comp.get,comp.mk]
ext : 2; intros
ext : 2
intros
refl
intros
refl
intros
congr
ext1
ext1; intros; refl
ext1; intros
intros
refl
intros
refl
ext : 2
congr
rcases x_1 with ⟨a,b,c⟩
rcases x_1 with ⟨a,b,c⟩; refl
refl
intros
refl
intros
apply prime_multiset.coe_nat_injective
rw [v.prod.coe_nat_factor_multiset, prime_multiset.coe_prod]
rcases v with ⟨l⟩
unfold_coes
dsimp [prime_multiset.to_nat_multiset]
rw [multiset.coe_prod]
let l' := l.map (coe : nat.primes → ℕ)
have : ∀ (p : ℕ), p ∈ l' → p.prime := λ p hp, by {rcases list.mem_map.mp hp with ⟨⟨p', hp'⟩, ⟨h_mem, h_eq⟩⟩, exact h_eq ▸ hp'}
exact multiset.coe_eq_coe.mpr (@nat.factors_unique _ l' rfl this).symm
intros
rw mul_comm
apply coprime.factor_eq_gcd_left cop am bn
intros
dsimp [gcd_b', gcd_y, gcd_z, xgcd_type.z]
{ dsimp [gcd_b', gcd_y, gcd_z, xgcd_type.z], rw [nat.succ_eq_add_one, nat.succ_eq_add_one, add_assoc] }
rw [nat.succ_eq_add_one, nat.succ_eq_add_one, add_assoc]
intros
{ convert coeff_monomial using 2, simp [eq_comm], }
convert coeff_monomial using 2
simp [eq_comm]
intros
by_cases hp : p = 0
{ rw [hp, nat_degree_zero, nat_trailing_degree_zero] }
rw [hp, nat_degree_zero, nat_trailing_degree_zero]
exact le_nat_degree_of_ne_zero (mt trailing_coeff_eq_zero.mp hp)
{ exact le_nat_degree_of_ne_zero (mt trailing_coeff_eq_zero.mp hp) }
intros
rw [← mod_by_monic_X_sub_C_eq_C_eval, C_0, sub_zero]
intros
rcases p
rcases q
simp only [coeff] at hf
simp only [mul_to_finsupp, eval₂_to_finsupp_eq_lift_nc]
exact lift_nc_mul _ _ p q (λ k n hn, (hf k).pow_right n)
intros
simp only [bit0, add_comp]
intros
rw [← C_1, eval₂_C, f.map_one]
intros
by_cases hf : f = 0
simp [hf]
{ simp [hf] }
ext i
refine ⟨λ h, integral_normalization_support h, _⟩
simp only [integral_normalization_coeff, mem_support_iff]
intro hfi
split_ifs with hi; simp [hfi, hi, pow_ne_zero _ (leading_coeff_ne_zero.mpr hf)]
split_ifs with hi
simp [hfi, hi, pow_ne_zero _ (leading_coeff_ne_zero.mpr hf)]
simp [hfi, hi, pow_ne_zero _ (leading_coeff_ne_zero.mpr hf)]
intros
{ ext, simp only [coeff_add, coeff_reflect], }
ext
simp only [coeff_add, coeff_reflect]
intros
rw [root_set_def, polynomial.map_zero, roots_zero, to_finset_zero, finset.coe_empty]
intros
rw [← @mk.eta _ _ p, ← @mk.eta _ _ q, mk.inj_iff]
intros
ext x
apply fix.ind_rec
intros x hyp'
rw [hyp, ←hyp', fix.rec_eq]
intros
cases n; simp [mk]
cases n
simp [mk]
simp [mk]
intros
cases q₁; cases q₂; refl
cases q₁; cases q₂
cases q₁
cases q₂
refl
intros
have := rat.nonneg_total (b - a); rwa neg_sub at this
have := rat.nonneg_total (b - a)
rwa neg_sub at this
intros
rw [cantor_function, tsum_eq_zero_add (summable_cantor_function f h1 h2)]
rw [cantor_function_aux_succ, tsum_mul_left, cantor_function_aux, pow_zero]
refl
intros
rw [← ennreal.of_real_one, ← ennreal.of_real_div_of_pos h.pos, ← ennreal.of_real_div_of_pos h.symm.pos, ← ennreal.of_real_add h.one_div_nonneg h.symm.one_div_nonneg, h.inv_add_inv_conj]
intros
simp [pos_iff_ne_zero, not_or_distrib]
intros
{ rw [ennreal.to_real, to_nnreal_sum hf, nnreal.coe_sum], refl }
rw [ennreal.to_real, to_nnreal_sum hf, nnreal.coe_sum]
refl
rw [fib_rec.geom_sol_iff_root_char_poly, fib_rec_char_poly_eq]
simp [sub_eq_zero]
intros
rcases nat.eq_zero_or_pos n with rfl | hnpos
rw [eq_comm, pow_zero, ← int.cast_one, int.cast_inj] at hxr
{ rw [eq_comm, pow_zero, ← int.cast_one, int.cast_inj] at hxr, simpa [hxr, multiplicity.one_right (mt is_unit_iff_dvd_one.1 (mt int.coe_nat_dvd.1 hp.1.not_dvd_one)), nat.zero_mod] using hv }
simpa [hxr, multiplicity.one_right (mt is_unit_iff_dvd_one.1 (mt int.coe_nat_dvd.1 hp.1.not_dvd_one)), nat.zero_mod] using hv
refine irrational_nrt_of_notint_nrt _ _ hxr _ hnpos
rintro ⟨y, rfl⟩
rw [← int.cast_pow, int.cast_inj] at hxr
subst m
have : y ≠ 0
rintro rfl
{ rintro rfl, rw zero_pow hnpos at hm, exact hm rfl }
rw zero_pow hnpos at hm
exact hm rfl
erw [multiplicity.pow' (nat.prime_iff_prime_int.1 hp.1) (finite_int_iff.2 ⟨hp.1.ne_one, this⟩), nat.mul_mod_right] at hv
exact hv rfl
intros
refine lt_of_lt_of_le (pi_lt_sqrt_two_add_series n) _
rw [← le_sub_iff_add_le, ← le_div_iff', sqrt_le_left, sub_le]
{ rwa [nat.cast_zero, zero_div] at h }
rwa [nat.cast_zero, zero_div] at h
exact div_nonneg (sub_nonneg.2 h₂) (pow_nonneg (le_of_lt zero_lt_two) _)
{ exact div_nonneg (sub_nonneg.2 h₂) (pow_nonneg (le_of_lt zero_lt_two) _) }
{ exact pow_pos zero_lt_two _ }
exact pow_pos zero_lt_two _
intros
rw [sq, mul_self_sqrt h]
intros
ext y
{ ext y, simp [mem_image, codom] }
simp [mem_image, codom]
intros
cases s with f al; apply subtype.eq; dsimp [tail, cons]; rw [stream.tail_cons]
cases s with f al; apply subtype.eq; dsimp [tail, cons]
cases s with f al; apply subtype.eq
cases s with f al
apply subtype.eq
dsimp [tail, cons]
rw [stream.tail_cons]
intros
dsimp [nth]; rw [dropn_of_seq, head_of_seq, seq.head_dropn]
dsimp [nth]
rw [dropn_of_seq, head_of_seq, seq.head_dropn]
intros
simpa only [exists_prop] using exists_range_iff
intros
rw [univ_pi_update i (λ j, (univ : set (α j))) s (λ j t, t), pi_univ, inter_univ, preimage]
intros
simp [nonempty_def.mp h, ext_iff]
intros
rw union_eq_Union; exact countable_Union (bool.forall_bool.2 ⟨h₂, h₁⟩)
rw union_eq_Union
exact countable_Union (bool.forall_bool.2 ⟨h₂, h₁⟩)
intros
ext x
refine ⟨λ hx, Union_Inter_subset hx, λ hx, _⟩
simp only [mem_Inter, mem_Union, mem_Inter] at hx ⊢
choose j hj using hx
obtain ⟨j₀⟩ := show nonempty ι', by apply_instance
refine ⟨finset.univ.fold max j₀ j, λ i, hs i _ (hj i)⟩
rw [finset.fold_op_rel_iff_or (@le_max_iff _ _)]
exact or.inr ⟨i, finset.mem_univ i, le_rfl⟩
intros
apply subset.antisymm
rintro _ ⟨x, ⟨h₁, h⟩, rfl⟩
{ rintro _ ⟨x, ⟨h₁, h⟩, rfl⟩, exact ⟨by rwa [mem_preimage, hf h], mem_image_of_mem _ h⟩ }
exact ⟨by rwa [mem_preimage, hf h], mem_image_of_mem _ h⟩
rintro _ ⟨h₁, ⟨x, h, rfl⟩⟩
{ rintro _ ⟨h₁, ⟨x, h, rfl⟩⟩, exact mem_image_of_mem _ ⟨by rwa ← hf h, h⟩ }
exact mem_image_of_mem _ ⟨by rwa ← hf h, h⟩
intros
rintros _ ⟨x, hx, rfl⟩ _ ⟨y, hy, rfl⟩ H
simp only [← h.eq] at H
exact congr_arg f (ha hx hy $ hf (mem_image_of_mem fa hx) (mem_image_of_mem fa hy) H)
intros
{ ext x, simp [← e.le_iff_le] }
ext x
simp [← e.le_iff_le]
intros
simp [sub_eq_add_neg]
intros
simp [sub_eq_add_neg, image_comp (λ x, a + x) (λ x, -x)]
intros
simpa only [mul_comm] using preimage_mul_const_Ici_of_neg a h
intros
simp [proj_Icc, hx, hx.trans h]
intros
simpa only [mul_comm] using image_mul_const_interval a b c
intros
simp [set.eq_empty_iff_forall_not_mem]
intros
rw [←fintype.card_congr (@equiv.sum_compl _ is_diag (sym2.is_diag.decidable_pred α)), fintype.card_sum, card_subtype_diag, card_subtype_not_diag, nat.choose_two_right, add_comm, ←nat.triangle_succ, nat.succ_sub_one, mul_comm]
intros
ext i
ext i; induction i; [refl, apply i_ih]
ext i; induction i
induction i
refl
apply i_ih
intros
simp [nth_zero]
intros
simp [nth_eq_nth_le]
intros
casesI n
{ exact int.cast_one }
exact int.cast_one
show ((1 % (n+1) : ℕ) : R) = 1
cases n
rw [nat.dvd_one] at h
{ rw [nat.dvd_one] at h, substI m, apply subsingleton.elim }
substI m
apply subsingleton.elim
rw nat.mod_eq_of_lt
{ exact nat.cast_one }
exact nat.cast_one
exact nat.lt_of_sub_eq_succ rfl
intros
rw [mem_ker]; exact one_iff_ker_inv' hf _ _
rw [mem_ker]
exact one_iff_ker_inv' hf _ _
intros
let b := is_noetherian.finset_basis K V
rw [module.card_fintype b, ← finite_dimensional.finrank_eq_card_basis b]
intros
subst H; induction m with m ih; [simp only [zero_add, iterate_zero_apply], rw [ih, nat.succ_add, iterate_succ']]; apply quot.sound; apply r.intro
subst H; induction m with m ih; [simp only [zero_add, iterate_zero_apply], rw [ih, nat.succ_add, iterate_succ']]; apply quot.sound
subst H; induction m with m ih; [simp only [zero_add, iterate_zero_apply], rw [ih, nat.succ_add, iterate_succ']]
subst H; induction m with m ih
subst H
induction m with m ih
simp only [zero_add, iterate_zero_apply]
rw [ih, nat.succ_add, iterate_succ']
apply quot.sound
apply r.intro
intros
refine alg_equiv.ext (λ x, (alg_hom.mem_equalizer σ.to_alg_hom τ.to_alg_hom x).mp ((set_like.ext_iff.mp _ x).mpr algebra.mem_top))
rwa [eq_top_iff, ←splitting_field.adjoin_roots, algebra.adjoin_le_iff]
intros
rw [←mem_coe, ←set.singleton_subset_iff, ←inter_eq_singleton_orthogonal_projection_fn]
exact set.inter_subset_left _ _
intros
rw cospherical_iff_exists_mem_of_finite_dimensional h at hc
rcases hc with ⟨c, hc, r, hcr⟩
use r
intros sx hsxps
have hsx : affine_span ℝ (set.range sx.points) = s
refine sx.independent.affine_span_eq_of_le_of_card_eq_finrank_add_one (span_points_subset_coe_of_subset_coe (hsxps.trans h)) _
{ refine sx.independent.affine_span_eq_of_le_of_card_eq_finrank_add_one (span_points_subset_coe_of_subset_coe (hsxps.trans h)) _, simp [hd] }
simp [hd]
have hc : c ∈ affine_span ℝ (set.range sx.points) := hsx.symm ▸ hc
exact (sx.eq_circumradius_of_dist_eq hc (λ i, hcr (sx.points i) (hsxps (set.mem_range_self i)))).symm
intros
ext f
{ ext f, rw [←left_invariant, apply_hfdifferential, apply_hfdifferential, L_mul, fdifferential_comp, apply_fdifferential, linear_map.comp_apply, apply_fdifferential, ←apply_hfdifferential, left_invariant] }
rw [←left_invariant, apply_hfdifferential, apply_hfdifferential, L_mul, fdifferential_comp, apply_fdifferential, linear_map.comp_apply, apply_fdifferential, ←apply_hfdifferential, left_invariant]
intros
simp only [atlas, mem_Union, mem_singleton_iff]
intros
have : unique_mdiff_on I (s ∩ f ⁻¹' (ext_chart_at I' y).source)
assume z hz
{ assume z hz, apply (hs z hz.1).inter', apply (hf z hz.1).preimage_mem_nhds_within, exact is_open.mem_nhds (ext_chart_at_open_source I' y) hz.2 }
apply (hs z hz.1).inter'
apply (hf z hz.1).preimage_mem_nhds_within
exact is_open.mem_nhds (ext_chart_at_open_source I' y) hz.2
exact this.unique_diff_on_target_inter _
intros
rwa [← ext_chart_at_symm_map_nhds_within' I x h, mem_map] at ht
intros
rw [times_cont_mdiff_at, times_cont_mdiff_within_at_iff]
refine ⟨(ext_chart_at_continuous_at _ _).continuous_within_at, _⟩
refine times_cont_diff_within_at_id.congr _ _
refine times_cont_diff_within_at_id.congr _ _; simp only with mfld_simps { contextual := tt }
simp only with mfld_simps { contextual := tt }
simp only with mfld_simps { contextual := tt }
intros
rw [inv_eq_iff_mul_eq_one, smul_mul_smul, mul_right_inv, mul_right_inv, one_smul]
intros
rw [mul_comm, lift_mul_right]
intros
apply minimal_period_eq_prime_pow; rwa is_periodic_pt_add_iff_nsmul_eq_zero
apply minimal_period_eq_prime_pow
rwa is_periodic_pt_add_iff_nsmul_eq_zero
rwa is_periodic_pt_add_iff_nsmul_eq_zero
intros
rw mem_cycle_factors_finset_iff at hf
rw [cycle_type_def, cycle_type_def, hf.left.cycle_factors_finset_eq_singleton]
refine map_le_map _
simpa [←finset.mem_def, mem_cycle_factors_finset_iff] using hf
intros
have hl : l.nodup := nodup_of_pairwise_disjoint_cycles h1 h2
rw cycle_type_eq' l.to_finset
{ simp [list.erase_dup_eq_self.mpr hl] }
simp [list.erase_dup_eq_self.mpr hl]
{ simpa using h1 }
simpa using h1
{ simpa [hl] using h0 }
simpa [hl] using h0
simpa [list.erase_dup_eq_self.mpr hl] using list.forall_of_pairwise disjoint.symmetric h2
{ simpa [list.erase_dup_eq_self.mpr hl] using list.forall_of_pairwise disjoint.symmetric h2 }
intros
split_ifs with h₁ h₂
{ exact cycle_range_of_lt h₁ }
exact cycle_range_of_lt h₁
{ exact cycle_range_of_eq h₂ }
exact cycle_range_of_eq h₂
exact cycle_range_of_gt (lt_of_le_of_ne (le_of_not_gt h₁) (ne.symm h₂))
{ exact cycle_range_of_gt (lt_of_le_of_ne (le_of_not_gt h₁) (ne.symm h₂)) }
intros
convert form_perm_pow_apply_nth_le _ h n 0 _; simp
{ convert form_perm_pow_apply_nth_le _ h n 0 _; simp }
convert form_perm_pow_apply_nth_le _ h n 0 _
simp
simp
intros
ext b
simp only [exists_prop, function.embedding.coe_fn_mk, to_embedding_apply, mem_map, ne.def, function.embedding.trans_apply, mem_support]
by_cases pb : p b
rw [extend_domain_apply_subtype _ _ pb]
{ rw [extend_domain_apply_subtype _ _ pb], split, { rintro h, refine ⟨f.symm ⟨b, pb⟩, _, by simp⟩, contrapose! h, simp [h] }, { rintro ⟨a, ha, hb⟩, contrapose! ha, obtain rfl : a = f.symm ⟨b, pb⟩, { rw eq_symm_apply, exact subtype.coe_injective hb }, rw eq_symm_apply, exact subtype.coe_injective ha } }
split
rintro h
{ rintro h, refine ⟨f.symm ⟨b, pb⟩, _, by simp⟩, contrapose! h, simp [h] }
refine ⟨f.symm ⟨b, pb⟩, _, by simp⟩
contrapose! h
simp [h]
rintro ⟨a, ha, hb⟩
{ rintro ⟨a, ha, hb⟩, contrapose! ha, obtain rfl : a = f.symm ⟨b, pb⟩, { rw eq_symm_apply, exact subtype.coe_injective hb }, rw eq_symm_apply, exact subtype.coe_injective ha }
contrapose! ha
obtain rfl : a = f.symm ⟨b, pb⟩
rw eq_symm_apply
{ rw eq_symm_apply, exact subtype.coe_injective hb }
exact subtype.coe_injective hb
rw eq_symm_apply
exact subtype.coe_injective ha
rw [extend_domain_apply_not_subtype _ _ pb]
{ rw [extend_domain_apply_not_subtype _ _ pb], simp only [not_exists, false_iff, not_and, eq_self_iff_true, not_true], rintros a ha rfl, exact pb (subtype.prop _) }
simp only [not_exists, false_iff, not_and, eq_self_iff_true, not_true]
rintros a ha rfl
exact pb (subtype.prop _)
intros
tactic.unfreeze_local_instances
obtain ⟨n, hn⟩ := hG''
suffices : ∀ k : ℕ, derived_series G (n + k) ≤ (derived_series G' k).map f
obtain ⟨m, hm⟩ := hG'
{ obtain ⟨m, hm⟩ := hG', use n + m, specialize this m, rwa [hm, map_bot, le_bot_iff] at this }
use n + m
specialize this m
rwa [hm, map_bot, le_bot_iff] at this
intro k
induction k with k hk
rw [add_zero, derived_series_zero, ←monoid_hom.range_eq_map]
{ rw [add_zero, derived_series_zero, ←monoid_hom.range_eq_map], refine le_trans _ hfg, rw [←map_eq_bot_iff, eq_bot_iff, ←hn], exact map_derived_series_le_derived_series g n }
refine le_trans _ hfg
rw [←map_eq_bot_iff, eq_bot_iff, ←hn]
exact map_derived_series_le_derived_series g n
rw [nat.add_succ, derived_series_succ, derived_series_succ]
{ rw [nat.add_succ, derived_series_succ, derived_series_succ], exact commutator_le_map_commutator hk hk }
exact commutator_le_map_commutator hk hk
intros
classical
by_cases h : ∀ x ∈ H, x = (1 : G)
left
{ left, exact H.eq_bot_iff_forall.mpr h }
exact H.eq_bot_iff_forall.mpr h
right
{ right, push_neg at h, simpa [nontrivial_iff_exists_ne_one] using h }
push_neg at h
simpa [nontrivial_iff_exists_ne_one] using h
intros
lift l to list S using hl
{ lift l to list S using hl, rw ← coe_list_prod, exact l.prod.coe_prop }
rw ← coe_list_prod
exact l.prod.coe_prop
intros
split
split; intros hf x y hxy
intros hf x y hxy
rw [← @vsub_eq_zero_iff_eq V1, ← @submodule.mem_bot k V1, ← linear_map.ker_eq_bot.mpr hf, linear_map.mem_ker, affine_map.linear_map_vsub, hxy, vsub_self]
{ rw [← @vsub_eq_zero_iff_eq V1, ← @submodule.mem_bot k V1, ← linear_map.ker_eq_bot.mpr hf, linear_map.mem_ker, affine_map.linear_map_vsub, hxy, vsub_self], }
intros hf x y hxy
obtain ⟨p⟩ := (by apply_instance : nonempty P1)
{ obtain ⟨p⟩ := (by apply_instance : nonempty P1), have hxy' : (f.linear x) +ᵥ f p = (f.linear y) +ᵥ f p, { rw hxy, }, rw [← f.map_vadd, ← f.map_vadd] at hxy', exact (vadd_right_cancel_iff _).mp (hf hxy'), }
have hxy' : (f.linear x) +ᵥ f p = (f.linear y) +ᵥ f p
rw hxy
{ rw hxy, }
rw [← f.map_vadd, ← f.map_vadd] at hxy'
exact (vadd_right_cancel_iff _).mp (hf hxy')
intros
ext v
rw [set_like.mem_coe, ←submodule.neg_mem_iff, ←set_like.mem_coe, coe_direction_eq_vsub_set_right hp, set.mem_image_iff_bex, set.mem_image_iff_bex]
conv_lhs { congr, funext, rw [←neg_vsub_eq_vsub_rev, neg_inj] }
intros
by_contradiction hne
change (affine_span k (p '' s1) : set P) ∩ affine_span k (p '' s2) ≠ ∅ at hne
rw set.ne_empty_iff_nonempty at hne
rcases hne with ⟨p0, hp0s1, hp0s2⟩
cases ha.exists_mem_inter_of_exists_mem_inter_affine_span hp0s1 hp0s2 with i hi
exact set.not_mem_empty i (hd ▸ hi)
intros
simp only [dom_coprod', tensor_product.lift.tmul, linear_map.mk₂_apply]
intros
rw [span_le, singleton_subset_iff, set_like.mem_coe]
intros
simpa only [range_eq_map] using map_cod_restrict _ _ _ _
intros
rw bilin_form.is_adjoint_pair_iff_comp_left_eq_comp_right
have h : ∀ (B B' : bilin_form R₃ (n → R₃)), B = B' ↔ (bilin_form.to_matrix' B) = (bilin_form.to_matrix' B')
intros B B'
{ intros B B', split; intros h, { rw h }, { exact bilin_form.to_matrix'.injective h } }
split; intros h
split
intros h
{ rw h }
rw h
intros h
{ exact bilin_form.to_matrix'.injective h }
exact bilin_form.to_matrix'.injective h
rw [h, bilin_form.to_matrix'_comp_left, bilin_form.to_matrix'_comp_right, linear_map.to_matrix'_to_lin', linear_map.to_matrix'_to_lin', bilin_form.to_matrix'_to_bilin', bilin_form.to_matrix'_to_bilin']
refl
intros
simp only [comp_left, bilin_form.to_matrix_comp b b, to_matrix_id, matrix.mul_one]
intros
simp [reverse]
intros
let b := basis.of_vector_space K V
split
intro hd
{ intro hd, rw [← b.mk_eq_dim'', cardinal.le_one_iff_subsingleton, subsingleton_coe] at hd, rcases eq_empty_or_nonempty (of_vector_space_index K V) with hb | ⟨⟨v₀, hv₀⟩⟩, { use 0, have h' : ∀ v : V, v = 0, { simpa [hb, submodule.eq_bot_iff] using b.span_eq.symm }, intro v, simp [h' v] }, { use v₀, have h' : (K ∙ v₀) = ⊤, { simpa [hd.eq_singleton_of_mem hv₀] using b.span_eq }, intro v, have hv : v ∈ (⊤ : submodule K V) := mem_top, rwa [←h', mem_span_singleton] at hv } }
rw [← b.mk_eq_dim'', cardinal.le_one_iff_subsingleton, subsingleton_coe] at hd
rcases eq_empty_or_nonempty (of_vector_space_index K V) with hb | ⟨⟨v₀, hv₀⟩⟩
use 0
{ use 0, have h' : ∀ v : V, v = 0, { simpa [hb, submodule.eq_bot_iff] using b.span_eq.symm }, intro v, simp [h' v] }
have h' : ∀ v : V, v = 0
simpa [hb, submodule.eq_bot_iff] using b.span_eq.symm
{ simpa [hb, submodule.eq_bot_iff] using b.span_eq.symm }
intro v
simp [h' v]
use v₀
{ use v₀, have h' : (K ∙ v₀) = ⊤, { simpa [hd.eq_singleton_of_mem hv₀] using b.span_eq }, intro v, have hv : v ∈ (⊤ : submodule K V) := mem_top, rwa [←h', mem_span_singleton] at hv }
have h' : (K ∙ v₀) = ⊤
simpa [hd.eq_singleton_of_mem hv₀] using b.span_eq
{ simpa [hd.eq_singleton_of_mem hv₀] using b.span_eq }
intro v
have hv : v ∈ (⊤ : submodule K V) := mem_top
rwa [←h', mem_span_singleton] at hv
rintros ⟨v₀, hv₀⟩
{ rintros ⟨v₀, hv₀⟩, have h : (K ∙ v₀) = ⊤, { ext, simp [mem_span_singleton, hv₀] }, rw [←dim_top, ←h], convert dim_span_le _, simp }
have h : (K ∙ v₀) = ⊤
{ ext, simp [mem_span_singleton, hv₀] }
ext
simp [mem_span_singleton, hv₀]
rw [←dim_top, ←h]
convert dim_span_le _
simp
intros
simpa using v.mk_eq_dim
intros
rw [b.equiv_fun_apply, to_dual_eq_repr]
intros
{ ext, refl }
ext
refl
intros
{ rw h, exact subalgebra.finrank_bot }
rw h
exact subalgebra.finrank_bot
intros
rw [equiv_map_domain_eq_map_domain, total_map_domain _ _ f.injective]
intros
refine ⟨λ H g, by simpa using linear_independent_iff'.1 H finset.univ g, λ H, linear_independent_iff''.2 $ λ s g hg hs i, H _ _ _⟩
rw ← hs
refine (finset.sum_subset (finset.subset_univ _) (λ i _ hi, _)).symm
rw [hg i hi, zero_smul]
intros
simp only [disjoint_def, finsupp.mem_span_image_iff_total]
rintros _ ⟨l₁, hl₁, rfl⟩ ⟨l₂, hl₂, H⟩
rw [hv.injective_total.eq_iff] at H
subst l₂
have : l₁ = 0 := finsupp.disjoint_supported_supported hs (submodule.mem_inf.2 ⟨hl₁, hl₂⟩)
simp [this]
intros
ext i j x
by_cases h : i = j
simp [h]
all_goals { simp [h] }
simp [h]
intros
rw [det_mul, det_mul, mul_comm]
intros
rw adjugate_def
{ rw adjugate_def, simp only, rw [cramer_apply, update_column_transpose, det_transpose], }
simp only
rw [cramer_apply, update_column_transpose, det_transpose]
intros
rw [←(inv_eq_right_inv h), ←(inv_eq_left_inv g)]
intros
rw [matrix.to_lin'_mul, linear_map.comp_apply]
intros
convert matrix.to_lin_mul v₁ v₁ v₁ A B
intros
rw [← update_row_eq_transvection i j, det_update_row_add_smul_self _ h, det_one]
intros
ext m
have : m = (λi, m i • 1)
ext j
ext j
{ ext j, simp }
{ ext j, simp }
simp
simp
conv_rhs { rw [this, f.map_smul_univ] }
refl
intros
dsimp only [ker]
rw [←prod_map_comap_prod, submodule.prod_bot]
intros
simp [comap_map_eq, sup_comm]
intros
rw [smodeq.def, submodule.quotient.eq, mem_bot, sub_eq_zero]
intros
let s : subalgebra R (tensor_algebra R M) := { carrier := C, mul_mem' := h_mul, add_mem' := h_add, algebra_map_mem' := h_grade0, }
let of : M →ₗ[R] s := (ι R).cod_restrict s.to_submodule h_grade1
have of_id : alg_hom.id R (tensor_algebra R M) = s.val.comp (lift R of)
ext
{ ext, simp [of], }
simp [of]
convert subtype.prop (lift R of a)
exact alg_hom.congr_fun of_id a
intros
{ subst hx, subst hy }
subst hx
subst hy
intros
rw iterate_add
intros
refine ⟨λ h, _, λ h, _⟩
cases h with c _ hac hcb
{ cases h with c _ hac hcb, { exact or.inl rfl }, { exact or.inr (trans_gen.tail' hac hcb) } }
{ exact or.inl rfl }
exact or.inl rfl
{ exact or.inr (trans_gen.tail' hac hcb) }
exact or.inr (trans_gen.tail' hac hcb)
{ rcases h with rfl | h, {refl}, {exact h.to_refl} }
rcases h with rfl | h
refl
{refl}
exact h.to_refl
{exact h.to_refl}
intros
{ rw ← pi_univ_Iic, exact pi_Iio_ae_eq_pi_Iic }
rw ← pi_univ_Iic
exact pi_Iio_ae_eq_pi_Iic
intros
induction n with m hm
refine ⟨_, _⟩
{ refine ⟨_, _⟩, { simp [(hf 0).1] }, { intros A hA, simp [(hf 0).2 A hA] } }
{ simp [(hf 0).1] }
simp [(hf 0).1]
{ intros A hA, simp [(hf 0).2 A hA] }
intros A hA
simp [(hf 0).2 A hA]
have : (λ (a : α), ⨆ (k : ℕ) (hk : k ≤ m + 1), f k a) = (λ a, f m.succ a ⊔ ⨆ (k : ℕ) (hk : k ≤ m), f k a)
{ have : (λ (a : α), ⨆ (k : ℕ) (hk : k ≤ m + 1), f k a) = (λ a, f m.succ a ⊔ ⨆ (k : ℕ) (hk : k ≤ m), f k a), { exact funext (λ _, supr_succ_eq_sup _ _ _) }, refine ⟨measurable_supr (λ n, measurable.supr_Prop _ (hf n).1), λ A hA, _⟩, rw this, exact (sup_mem_measurable_le (hf m.succ) hm).2 A hA }
{ exact funext (λ _, supr_succ_eq_sup _ _ _) }
exact funext (λ _, supr_succ_eq_sup _ _ _)
refine ⟨measurable_supr (λ n, measurable.supr_Prop _ (hf n).1), λ A hA, _⟩
rw this
exact (sup_mem_measurable_le (hf m.succ) hm).2 A hA
intros
simp_rw sub_eq_add_neg
exact (condexp_add hf hg.neg).trans (eventually_eq.rfl.add (condexp_neg g))
intros
rw indicator_const_Lp_eq_to_span_singleton_comp_Lp hs hμs x
have h_comp := condexp_L2_comp_continuous_linear_map ℝ 𝕜 hm (to_span_singleton ℝ x) (indicator_const_Lp 2 hs hμs (1 : ℝ))
refine h_comp.trans _
exact (to_span_singleton ℝ x).coe_fn_comp_Lp _
intros
apply Lp.norm_le_of_ae_bound (norm_nonneg f)
refine (f.to_continuous_map.coe_fn_to_ae_eq_fun μ).mono _
{ refine (f.to_continuous_map.coe_fn_to_ae_eq_fun μ).mono _, intros x hx, convert f.norm_coe_le_norm x }
intros x hx
convert f.norm_coe_le_norm x
{ apply_instance }
apply_instance
intros
dsimp only [approx_on, coe_comp, (∘)]
exact edist_nearest_pt_le _ _ ((nearest_pt_ind_le _ _ _).trans h)
intros
rw ← mem_ℒp_one_iff_integrable
{ rw ← mem_ℒp_one_iff_integrable, exact (Lp.simple_func.mem_ℒp f) }
exact (Lp.simple_func.mem_ℒp f)
intros
simpa only [← pi.multiset_prod_apply] using s.ae_measurable_prod' hs
intros
haveI : is_finite_measure (μ.restrict s) := ⟨by rwa [measure.restrict_apply_univ]⟩
haveI : is_finite_measure (μ.restrict s) := ⟨by rwa [measure.restrict_apply_univ]⟩; exact has_finite_integral_of_bounded hf
exact has_finite_integral_of_bounded hf
intros
simp only [interval_integral, neg_sub]
intros
by_cases hc : c = 0; simp [hc]
by_cases hc : c = 0
simp [hc]
simp [hc]
intros
convert (monotone_lintegral μ).le_map_supr2 f
{ convert (monotone_lintegral μ).le_map_supr2 f, ext1 a, simp only [supr_apply] }
ext1 a
simp only [supr_apply]
intros
ext
ext; simp
simp
intros
simp only [lintegral, ← H]
apply lintegral_eq_of_subset
simp only [H]
intros
exact mem_range_of_measure_ne_zero ‹_›
intros
rw [measure.restrict_univ]
intros
simp_rw set_to_L1s
rw ← simple_func.set_to_simple_func_smul T h_add h_smul c (simple_func.integrable f)
refine simple_func.set_to_simple_func_congr T h_zero h_add (simple_func.integrable _) _
exact smul_to_simple_func c f
intros
refine measurable_find_greatest' (λ k hk, _)
simp only [nat.find_greatest_eq_iff, set_of_and, set_of_forall, ← compl_set_of]
repeat { apply_rules [measurable_set.inter, measurable_set.const, measurable_set.Inter, measurable_set.Inter_Prop, measurable_set.compl, hN]; try { intros } }
apply_rules [measurable_set.inter, measurable_set.const, measurable_set.Inter, measurable_set.Inter_Prop, measurable_set.compl, hN]; try { intros }
apply_rules [measurable_set.inter, measurable_set.const, measurable_set.Inter, measurable_set.Inter_Prop, measurable_set.compl, hN]; try { intros }
apply_rules [measurable_set.inter, measurable_set.const, measurable_set.Inter, measurable_set.Inter_Prop, measurable_set.compl, hN]; try { intros }
apply_rules [measurable_set.inter, measurable_set.const, measurable_set.Inter, measurable_set.Inter_Prop, measurable_set.compl, hN]; try { intros }
apply_rules [measurable_set.inter, measurable_set.const, measurable_set.Inter, measurable_set.Inter_Prop, measurable_set.compl, hN]
apply_rules [measurable_set.inter, measurable_set.const, measurable_set.Inter, measurable_set.Inter_Prop, measurable_set.compl, hN]; try { intros }
intros
let eval : (compacts G → ℝ) → ℝ := λ f, f K₁ + f K₂ - f (K₁ ⊔ K₂)
have : continuous eval := ((@continuous_add ℝ _ _ _).comp ((continuous_apply K₁).prod_mk (continuous_apply K₂))).sub (continuous_apply (K₁ ⊔ K₂))
rw [← sub_nonneg]
show chaar K₀ ∈ eval ⁻¹' (Ici (0 : ℝ))
apply mem_of_subset_of_mem _ (chaar_mem_cl_prehaar K₀ ⟨set.univ, is_open_univ, mem_univ _⟩)
unfold cl_prehaar
rw is_closed.closure_subset_iff
rintro _ ⟨U, ⟨h1U, h2U, h3U⟩, rfl⟩
{ rintro _ ⟨U, ⟨h1U, h2U, h3U⟩, rfl⟩, simp only [mem_preimage, mem_Ici, eval, sub_nonneg], apply prehaar_sup_le, rw h2U.interior_eq, exact ⟨1, h3U⟩ }
simp only [mem_preimage, mem_Ici, eval, sub_nonneg]
apply prehaar_sup_le
rw h2U.interior_eq
exact ⟨1, h3U⟩
apply continuous_iff_is_closed.mp this
{ apply continuous_iff_is_closed.mp this, exact is_closed_Ici }
exact is_closed_Ici
intros
simp only [ae_iff, ← compl_set_of, restrict_apply_eq_zero' hs]
congr' with x
simp [and_comm]
intros
convert set.ext_iff.1 (preimage_spanning_sets_index_singleton μ n) x
intros
{ unfold trim, congr, funext s hs, exact H hs }
unfold trim
congr
funext s hs
exact H hs
intros
cases eq_or_ne (μ U) 0 with h₀ h₀
refine ⟨∅, empty_subset _, h0, _⟩
{ refine ⟨∅, empty_subset _, h0, _⟩, rwa [measure_empty, h₀, zero_add, pos_iff_ne_zero] }
rwa [measure_empty, h₀, zero_add, pos_iff_ne_zero]
rcases H hU _ (ennreal.sub_lt_self hμU h₀ hε) with ⟨K, hKU, hKc, hrK⟩
{ rcases H hU _ (ennreal.sub_lt_self hμU h₀ hε) with ⟨K, hKU, hKc, hrK⟩, exact ⟨K, hKU, hKc, ennreal.lt_add_of_sub_lt (or.inl hμU) hrK⟩ }
exact ⟨K, hKU, hKc, ennreal.lt_add_of_sub_lt (or.inl hμU) hrK⟩
intros
{ ext i hi, simp }
ext i hi
simp
intros
by_cases hi₁ : measurable_set i
exact (restrict_le_restrict_iff _ _ hi₁).1 hi₂ hi₁ set.subset.rfl
{ exact (restrict_le_restrict_iff _ _ hi₁).1 hi₂ hi₁ set.subset.rfl }
{ rw v.not_measurable hi₁ }
rw v.not_measurable hi₁
intros
ext n
simp only [mul_apply, smul_apply, sum_smul, mul_smul, smul_sum, finset.sum_sigma']
apply finset.sum_bij
swap 5
{ rintros ⟨⟨i,j⟩, ⟨k,l⟩⟩ H, exact ⟨(k, l*j), (l, j)⟩ }
rintros ⟨⟨i,j⟩, ⟨k,l⟩⟩ H
exact ⟨(k, l*j), (l, j)⟩
rintros ⟨⟨i,j⟩, ⟨k,l⟩⟩ H
{ rintros ⟨⟨i,j⟩, ⟨k,l⟩⟩ H, simp only [finset.mem_sigma, mem_divisors_antidiagonal] at H ⊢, rcases H with ⟨⟨rfl, n0⟩, rfl, i0⟩, refine ⟨⟨(mul_assoc _ _ _).symm, n0⟩, rfl, _⟩, rw mul_ne_zero_iff at *, exact ⟨i0.2, n0.2⟩, }
simp only [finset.mem_sigma, mem_divisors_antidiagonal] at H ⊢
rcases H with ⟨⟨rfl, n0⟩, rfl, i0⟩
refine ⟨⟨(mul_assoc _ _ _).symm, n0⟩, rfl, _⟩
rw mul_ne_zero_iff at *
exact ⟨i0.2, n0.2⟩
{ rintros ⟨⟨i,j⟩, ⟨k,l⟩⟩ H, simp only [mul_assoc] }
rintros ⟨⟨i,j⟩, ⟨k,l⟩⟩ H
simp only [mul_assoc]
rintros ⟨⟨a,b⟩, ⟨c,d⟩⟩ ⟨⟨i,j⟩, ⟨k,l⟩⟩ H₁ H₂
{ rintros ⟨⟨a,b⟩, ⟨c,d⟩⟩ ⟨⟨i,j⟩, ⟨k,l⟩⟩ H₁ H₂, simp only [finset.mem_sigma, mem_divisors_antidiagonal, and_imp, prod.mk.inj_iff, add_comm, heq_iff_eq] at H₁ H₂ ⊢, rintros rfl h2 rfl rfl, exact ⟨⟨eq.trans H₁.2.1.symm H₂.2.1, rfl⟩, rfl, rfl⟩ }
simp only [finset.mem_sigma, mem_divisors_antidiagonal, and_imp, prod.mk.inj_iff, add_comm, heq_iff_eq] at H₁ H₂ ⊢
rintros rfl h2 rfl rfl
exact ⟨⟨eq.trans H₁.2.1.symm H₂.2.1, rfl⟩, rfl, rfl⟩
rintros ⟨⟨i,j⟩, ⟨k,l⟩⟩ H
{ rintros ⟨⟨i,j⟩, ⟨k,l⟩⟩ H, refine ⟨⟨(i*k, l), (i, k)⟩, _, _⟩, { simp only [finset.mem_sigma, mem_divisors_antidiagonal] at H ⊢, rcases H with ⟨⟨rfl, n0⟩, rfl, j0⟩, refine ⟨⟨mul_assoc _ _ _, n0⟩, rfl, _⟩, rw mul_ne_zero_iff at *, exact ⟨n0.1, j0.1⟩ }, { simp only [true_and, mem_divisors_antidiagonal, and_true, prod.mk.inj_iff, eq_self_iff_true, ne.def, mem_sigma, heq_iff_eq] at H ⊢, rw H.2.1 } }
refine ⟨⟨(i*k, l), (i, k)⟩, _, _⟩
simp only [finset.mem_sigma, mem_divisors_antidiagonal] at H ⊢
{ simp only [finset.mem_sigma, mem_divisors_antidiagonal] at H ⊢, rcases H with ⟨⟨rfl, n0⟩, rfl, j0⟩, refine ⟨⟨mul_assoc _ _ _, n0⟩, rfl, _⟩, rw mul_ne_zero_iff at *, exact ⟨n0.1, j0.1⟩ }
rcases H with ⟨⟨rfl, n0⟩, rfl, j0⟩
refine ⟨⟨mul_assoc _ _ _, n0⟩, rfl, _⟩
rw mul_ne_zero_iff at *
exact ⟨n0.1, j0.1⟩
simp only [true_and, mem_divisors_antidiagonal, and_true, prod.mk.inj_iff, eq_self_iff_true, ne.def, mem_sigma, heq_iff_eq] at H ⊢
{ simp only [true_and, mem_divisors_antidiagonal, and_true, prod.mk.inj_iff, eq_self_iff_true, ne.def, mem_sigma, heq_iff_eq] at H ⊢, rw H.2.1 }
rw H.2.1
intros
revert h0
apply s.induction_on
simp
simp
intros a t h h0
rw [multiset.prod_cons, mul_ne_zero_iff] at h0
simp [h0, card_factors_mul, h]
intros
rw [mem_proper_divisors, and_iff_right (one_dvd _)]
intros
intro h
obtain ⟨a0, b0, c0, ⟨hf, h2, hp⟩⟩ := fermat_42.exists_pos_odd_minimal (and.intro ha (and.intro hb h))
apply fermat_42.not_minimal hf h2 hp
intros
induction n
{ refl, }
refl
{ dsimp, simp only [add_zero], exact n_ih, }
dsimp
simp only [add_zero]
exact n_ih
intros
simp [norm_def]
intros
apply le_antisymm
intros x hx
{ intros x hx, rw ideal.mem_span_singleton, simp only [local_ring.mem_maximal_ideal, mem_nonunits] at hx, rwa ← norm_lt_one_iff_dvd, }
rw ideal.mem_span_singleton
simp only [local_ring.mem_maximal_ideal, mem_nonunits] at hx
rwa ← norm_lt_one_iff_dvd
rw [ideal.span_le, set.singleton_subset_iff]
{ rw [ideal.span_le, set.singleton_subset_iff], exact p_nonnunit }
exact p_nonnunit
intros
cases nat.eq_zero_or_pos n with hn hn
{ rw hn, exact dvd_zero (p ^ padic_val_nat p 0) }
rw hn
exact dvd_zero (p ^ padic_val_nat p 0)
rw multiplicity.pow_dvd_iff_le_multiplicity
{ rw multiplicity.pow_dvd_iff_le_multiplicity, apply le_of_eq, rw padic_val_nat_def (ne_of_gt hn), { apply enat.coe_get }, { apply_instance } }
apply le_of_eq
rw padic_val_nat_def (ne_of_gt hn)
{ apply enat.coe_get }
apply enat.coe_get
{ apply_instance }
apply_instance
intros
simp [cast_eq_of_rat]
intros
obtain ⟨m, n, H⟩ := hp
use [1, m, n]
rcases H with ⟨⟨rfl, rfl⟩ | ⟨rfl, rfl⟩, co, pp⟩
rcases H with ⟨⟨rfl, rfl⟩ | ⟨rfl, rfl⟩, co, pp⟩; { apply and.intro _ co, rw one_mul, rw one_mul, tauto }
{ apply and.intro _ co, rw one_mul, rw one_mul, tauto }
{ apply and.intro _ co, rw one_mul, rw one_mul, tauto }
apply and.intro _ co
rw one_mul
rw one_mul
tauto
intros
simp only [ext, true_and, conj_re, eq_self_iff_true, neg_neg, conj_im]
intros
simp [bit1]
intros
{ rw h.lower_bounds_eq, refl }
rw h.lower_bounds_eq
refl
intros
simp only [Sup_eq_supr, compl_supr]
intros
finish
intros
rw [← map_coe_Ici_at_top a, comap_map subtype.coe_injective]
intros
simp [← prod_at_top_at_top_eq, at_top_basis.prod_self.eventually_iff]
intros
refine mt (λ h, hq.mp $ h.mono _) hp
exact λ x hpq hq hp, hpq ⟨hp, hq⟩
intros
simp only [eventually_eq, eventually_le, le_antisymm_iff, eventually_and]
intros
simpa only [filter.eventually, set_of_forall] using Inter_mem
intros
rw rtendsto_def
change (∀ (s : set β), s ∈ l₂.sets → r.core s ∈ l₁) ↔ l₁ ≤ rcomap r l₂
simp [filter.le_def, rcomap, rel.mem_image]
split
{ exact λ h s t tl₂, mem_of_superset (h t tl₂) }
exact λ h s t tl₂, mem_of_superset (h t tl₂)
{ exact λ h t tl₂, h _ t tl₂ set.subset.rfl }
exact λ h t tl₂, h _ t tl₂ set.subset.rfl
intros
{ rw ← h, simp }
rw ← h
simp
intros
ext
ext; refl
refl
intros
induction m with m ih
{ exact h 0 n hmn.ne, }
exact h 0 n hmn.ne
rw [partial_sups_succ, disjoint_sup_left]
{ rw [partial_sups_succ, disjoint_sup_left], exact ⟨ih (nat.lt_of_succ_lt hmn), h (m + 1) n hmn.ne⟩ }
exact ⟨ih (nat.lt_of_succ_lt hmn), h (m + 1) n hmn.ne⟩
intros
rw [symm_diff_comm, ←symm_diff_assoc, symm_diff_self, bot_symm_diff]
intros
rw [adjoin_eq_span, adjoin_eq_span, adjoin_eq_span, span_mul_span]
congr' 1 with z
simp [submonoid.closure_union, submonoid.mem_sup, set.mem_mul]
intros
{ rw mul_comm, exact h.add_mul_left_left z }
rw mul_comm
exact h.add_mul_left_left z
intros
refine λ f, induction_on f (λ m, _) _ _
have : m ∈ closure S := hS.symm ▸ mem_top _
{ have : m ∈ closure S := hS.symm ▸ mem_top _, refine closure_induction this (λ m hm, _) _ _, { exact ⟨mv_polynomial.X ⟨m, hm⟩, mv_polynomial.aeval_X _ _⟩ }, { exact ⟨1, alg_hom.map_one _⟩ }, { rintro m₁ m₂ ⟨P₁, hP₁⟩ ⟨P₂, hP₂⟩, exact ⟨P₁ * P₂, by rw [alg_hom.map_mul, hP₁, hP₂, of_apply, of_apply, of_apply, single_mul_single, one_mul]; refl⟩ } }
refine closure_induction this (λ m hm, _) _ _
{ exact ⟨mv_polynomial.X ⟨m, hm⟩, mv_polynomial.aeval_X _ _⟩ }
exact ⟨mv_polynomial.X ⟨m, hm⟩, mv_polynomial.aeval_X _ _⟩
{ exact ⟨1, alg_hom.map_one _⟩ }
exact ⟨1, alg_hom.map_one _⟩
rintro m₁ m₂ ⟨P₁, hP₁⟩ ⟨P₂, hP₂⟩
{ rintro m₁ m₂ ⟨P₁, hP₁⟩ ⟨P₂, hP₂⟩, exact ⟨P₁ * P₂, by rw [alg_hom.map_mul, hP₁, hP₂, of_apply, of_apply, of_apply, single_mul_single, one_mul]; refl⟩ }
exact ⟨P₁ * P₂, by rw [alg_hom.map_mul, hP₁, hP₂, of_apply, of_apply, of_apply, single_mul_single, one_mul]; refl⟩
rintro f g ⟨P, rfl⟩ ⟨Q, rfl⟩
{ rintro f g ⟨P, rfl⟩ ⟨Q, rfl⟩, exact ⟨P + Q, alg_hom.map_add _ _ _⟩ }
exact ⟨P + Q, alg_hom.map_add _ _ _⟩
rintro r f ⟨P, rfl⟩
{ rintro r f ⟨P, rfl⟩, exact ⟨r • P, alg_hom.map_smul _ _ _⟩ }
exact ⟨r • P, alg_hom.map_smul _ _ _⟩
intros
obtain ⟨d, J, h_nzd, rfl⟩ := exists_eq_span_singleton_mul I
apply is_noetherian_span_singleton_inv_to_map_mul
apply is_noetherian_coe_to_fractional_ideal
intros
rw [←canonical_equiv_symm, ring_equiv.symm_apply_apply]
intros
refine or_iff_not_imp_left.2 (λ ne_top, ⟨⟨λ h, ne_top h, λ J hJ, _⟩⟩)
refine (rel_iso_of_surjective f hf).injective (subtype.ext_iff.2 (eq.trans (H.1.2 (comap f J) (lt_of_le_of_ne _ _)) comap_top.symm))
{ refine (rel_iso_of_surjective f hf).injective (subtype.ext_iff.2 (eq.trans (H.1.2 (comap f J) (lt_of_le_of_ne _ _)) comap_top.symm)), { exact (map_le_iff_le_comap).1 (le_of_lt hJ) }, { exact λ h, hJ.right (le_map_of_comap_le_of_surjective f hf (le_of_eq h.symm)) } }
{ exact (map_le_iff_le_comap).1 (le_of_lt hJ) }
exact (map_le_iff_le_comap).1 (le_of_lt hJ)
exact λ h, hJ.right (le_map_of_comap_le_of_surjective f hf (le_of_eq h.symm))
{ exact λ h, hJ.right (le_map_of_comap_le_of_surjective f hf (le_of_eq h.symm)) }
intros
refine (quotient_map I f H).injective_iff.2 (λ a ha, _)
obtain ⟨r, rfl⟩ := quotient.mk_surjective a
rw [quotient_map_mk, quotient.eq_zero_iff_mem] at ha
exact (quotient.eq_zero_iff_mem).mpr (h ha)
intros
rw int.associated_iff_nat_abs
exact int.nat_abs_eq_nat_abs_iff
intros
rw [coe_submodule_span, set.image_singleton]
intros
{ ext n, simp [coeff_map] }
ext n
simp [coeff_map]
intros
{ rw [← mul_one X, content_X_mul, content_one] }
rw [← mul_one X, content_X_mul, content_one]
intros
rw [cyclotomic']
have prim_root_two : primitive_roots 2 R = {(-1 : R)}
apply finset.eq_singleton_iff_unique_mem.2
{ apply finset.eq_singleton_iff_unique_mem.2, split, { simp only [is_primitive_root.neg_one p hp, nat.succ_pos', mem_primitive_roots] }, { intros x hx, rw [mem_primitive_roots zero_lt_two] at hx, exact is_primitive_root.eq_neg_one_of_two_right hx } }
split
simp only [is_primitive_root.neg_one p hp, nat.succ_pos', mem_primitive_roots]
{ simp only [is_primitive_root.neg_one p hp, nat.succ_pos', mem_primitive_roots] }
intros x hx
{ intros x hx, rw [mem_primitive_roots zero_lt_two] at hx, exact is_primitive_root.eq_neg_one_of_two_right hx }
rw [mem_primitive_roots zero_lt_two] at hx
exact is_primitive_root.eq_neg_one_of_two_right hx
simp only [prim_root_two, finset.prod_singleton, ring_hom.map_neg, ring_hom.map_one, sub_neg_eq_add]
intros
ext
rw [finsupp.mem_supported, set.subset_def]
simp only [finsupp.mem_support_iff, finset.mem_coe]
refl
intros
simp only [nat_degree, degree_scale_roots]
intros
split_ifs with h
{ rw [h, order_eq_top, linear_map.map_zero] }
rw [h, order_eq_top, linear_map.map_zero]
rw [order_eq]
{ rw [order_eq], split; intros i hi, { rw [enat.coe_inj] at hi, rwa [hi, coeff_monomial_same] }, { rw [enat.coe_lt_coe] at hi, rw [coeff_monomial, if_neg], exact ne_of_lt hi } }
split
split; intros i hi
intros i hi
{ rw [enat.coe_inj] at hi, rwa [hi, coeff_monomial_same] }
rw [enat.coe_inj] at hi
rwa [hi, coeff_monomial_same]
intros i hi
rw [enat.coe_lt_coe] at hi
{ rw [enat.coe_lt_coe] at hi, rw [coeff_monomial, if_neg], exact ne_of_lt hi }
rw [coeff_monomial, if_neg]
exact ne_of_lt hi
intros
simp [mul_sub, sub_sub_cancel]
intros
use (X ^ n - 1)
split
{ exact (monic_X_pow_sub_C 1 (ne_of_lt hpos).symm) }
exact (monic_X_pow_sub_C 1 (ne_of_lt hpos).symm)
simp only [((is_primitive_root.iff_def μ n).mp h).left, eval₂_one, eval₂_X_pow, eval₂_sub, sub_self]
{ simp only [((is_primitive_root.iff_def μ n).mp h).left, eval₂_one, eval₂_X_pow, eval₂_sub, sub_self] }
intros
haveI : nonempty S := Sne.to_subtype
simp only [Sup_eq_supr', mem_supr_of_directed hS.directed_coe, set_coe.exists, subtype.coe_mk]
intros
{ ext, simp [base_change_eq_ltensor], }
ext
simp [base_change_eq_ltensor]
intros
apply eq_of_prod_eq_prod
rw associates.factors_prod
exact multiset.prod_zero
intros
rw sub_eq_add_neg
exact v.map_add_le hx (le_trans (le_of_eq (v.map_neg y)) hy)
intros
map_fun_tac
intros
have inj : function.injective (int.cast_ring_hom ℚ)
{ intros m n, exact int.cast_inj.mp, }
intros m n
exact int.cast_inj.mp
apply inj
rw [← constant_coeff_map, map_witt_structure_int, constant_coeff_witt_structure_rat_zero, constant_coeff_map]
rw ordinal.univ_id; exact quotient.sound ⟨aleph_idx.rel_iso⟩
rw ordinal.univ_id
exact quotient.sound ⟨aleph_idx.rel_iso⟩
intros
rw [add_comm a b, add_comm c b] at h
{ rw [add_comm a b, add_comm c b] at h, exact cardinal.eq_of_add_eq_add_left h hb }
exact cardinal.eq_of_add_eq_add_left h hb
intros
simp [mem_def, or_and_distrib_right, exists_or_distrib]
intros
rw [← not_le, ← not_le, ord_le]
intros
refine eq.trans _ (by rw [←quotient.out_eq o])
{ refine eq.trans _ (by rw [←quotient.out_eq o]), cases quotient.out o, refl }
cases quotient.out o
refl
intros
rw [← cardinal.ord_nat, ← cardinal.ord_nat, cardinal.ord_le_ord, cardinal.nat_cast_le]
intros
rw lt_def
dsimp
simp [forall_pempty, exists_pempty]
intros
simp *
intros
rw [← h, ← hm, int.add_mul_mod_self, int.mod_eq_of_lt h₁ h₂]
intros
cases t1
cases t2
simp only [coeffs.val_add, add, val, add_comm, add_left_comm]
intros
cc
intros
simp [is_open_def, h]
intros
{ rw ←nat.cofinite_eq_at_top, exact hf.tendsto_cofinite_zero }
rw ←nat.cofinite_eq_at_top
exact hf.tendsto_cofinite_zero
intros
rw [← supr_decode₂, ← tsum_supr_decode₂ _ m0 s]
{ rw [← supr_decode₂, ← tsum_supr_decode₂ _ m0 s], exact m_supr _ }
exact m_supr _
intros
simp [tsum, h]
intros
rcases hs with ⟨a', ha'⟩
intro h
rcases (ha.1 ha').eq_or_lt with (rfl|ha'a)
{ exact h.self_of_nhds_within le_rfl ha' }
exact h.self_of_nhds_within le_rfl ha'
rcases (mem_nhds_within_Iic_iff_exists_Ioc_subset' ha'a).1 h with ⟨b, hba, hb⟩
{ rcases (mem_nhds_within_Iic_iff_exists_Ioc_subset' ha'a).1 h with ⟨b, hba, hb⟩, rcases ha.exists_between hba with ⟨b', hb's, hb'⟩, exact hb hb' hb's }
rcases ha.exists_between hba with ⟨b', hb's, hb'⟩
exact hb hb' hb's
intros
rw [← map_coe_Ioo_at_bot h, tendsto_map'_iff]
intros
{ rw [← is_open_compl_iff, compl_empty], exact is_open_univ }
rw [← is_open_compl_iff, compl_empty]
exact is_open_univ
intros
{ rw [←frontier_compl, ←closure_compl], refl }
rw [←frontier_compl, ←closure_compl]
refl
intros
simp_rw [is_closed_iff_cluster_pt, cluster_pt, inf_principal_ne_bot_iff]
intros
rw [pi_def]; exact (is_closed_Inter $ λ a, is_closed_Inter $ λ ha, (hs _ ha).preimage (continuous_apply _))
rw [pi_def]
exact (is_closed_Inter $ λ a, is_closed_Inter $ λ ha, (hs _ ha).preimage (continuous_apply _))
intros
let f' : C(set.Icc a b, ℝ) := ⟨λ x, f x, continuous_on_iff_continuous_restrict.mp c⟩
obtain ⟨p, b⟩ := exists_polynomial_near_continuous_map a b f' ε pos
use p
rw norm_lt_iff _ pos at b
intros x m
exact b ⟨x, m⟩
intros
apply tendsto.piecewise; rwa ← nhds_within_inter'
apply tendsto.piecewise
rwa ← nhds_within_inter'
rwa ← nhds_within_inter'
intros
rw continuous_iff_continuous_on_univ at *
exact hg.comp hf (λ x _, hs x)
intros
ext ⟨⟩
{ ext ⟨⟩, refl }
refl
intros
refine inter_eq_right_iff_subset.mpr (λ x hx, _)
simp only [mem_preimage, local_equiv.inv_fun_as_coe, e.proj_symm_apply hx]
exact e.mem_target.mp hx
intros
refine le_antisymm (diam_le $ λ x hx y hy, _) (diam_mono subset_closure)
have : edist x y ∈ closure (Iic (diam s))
from map_mem_closure2 (@continuous_edist α _) hx hy (λ _ _, edist_le_diam_of_mem)
rwa closure_Iic at this
intros
apply tendsto.const_mul (ennreal.tendsto_inv_iff.2 hm)
{ apply tendsto.const_mul (ennreal.tendsto_inv_iff.2 hm), simp [hb] }
simp [hb]
intros
rw [← @not_not (∑' a, ↑(f a) = ⊤)]
exact not_congr tsum_coe_ne_top_iff_summable_coe
intros
rw [nhds_top', mem_infi_of_directed]
{ refl }
refl
exact λ x y, ⟨max x y, by simp [le_refl], by simp [le_refl]⟩
intros
rw [of_set_trans, restr_source_inter]
intros
ext
{ ext, refl }
refl
intros
simp [continuous_iff_continuous_at, continuous_at, inducing.tendsto_nhds_iff hg]
intros
rcases h with ⟨x, ⟨xs, xt⟩⟩
simpa using diam_union xs xt
intros
rw dist_comm
rw dist_comm; refl
refl
intros
ext s
rw mem_infi_of_directed
{ simp [completion.mem_uniformity_dist, subset_def] }
simp [completion.mem_uniformity_dist, subset_def]
rintro ⟨r, hr⟩ ⟨p, hp⟩
{ rintro ⟨r, hr⟩ ⟨p, hp⟩, use ⟨min r p, lt_min hr hp⟩, simp [lt_min_iff, (≥)] {contextual := tt} }
use ⟨min r p, lt_min hr hp⟩
simp [lt_min_iff, (≥)] {contextual := tt}
intros
rcases subset_countable_closure_of_compact hs with ⟨t, hts, htc, hsub⟩
exact ⟨t, hts, htc, subset.antisymm hsub (closure_minimal hts hs.is_closed)⟩
intros
rcases hs with ⟨x, xs⟩
rcases ht with ⟨y, yt⟩
refine Hausdorff_edist_le_of_mem_edist _ _
intros z hz
{ intros z hz, exact ⟨y, yt, edist_le_diam_of_mem (subset_union_left _ _ hz) (subset_union_right _ _ yt)⟩ }
exact ⟨y, yt, edist_le_diam_of_mem (subset_union_left _ _ hz) (subset_union_right _ _ yt)⟩
intros z hz
{ intros z hz, exact ⟨x, xs, edist_le_diam_of_mem (subset_union_right _ _ hz) (subset_union_left _ _ xs)⟩ }
exact ⟨x, xs, edist_le_diam_of_mem (subset_union_right _ _ hz) (subset_union_left _ _ xs)⟩
intros
rw Hausdorff_dist_comm at H
rw Hausdorff_edist_comm at fin
simpa [dist_comm] using exists_dist_lt_of_Hausdorff_dist_lt h H fin
intros
simp [path_connected_space_iff_univ, is_path_connected_iff_eq]
intros
refine ⟨is_open.inter h.1 ha, _⟩
have : is_closed (Z ∩ bᶜ) := is_closed.inter h.2 (is_closed_compl_iff.2 hb)
convert this using 1
apply subset.antisymm
exact inter_subset_inter_right Z (subset_compl_iff_disjoint.2 hab)
{ exact inter_subset_inter_right Z (subset_compl_iff_disjoint.2 hab) }
rintros x ⟨hx₁, hx₂⟩
{ rintros x ⟨hx₁, hx₂⟩, exact ⟨hx₁, by simpa [not_mem_of_mem_compl hx₂] using cover hx₁⟩ }
exact ⟨hx₁, by simpa [not_mem_of_mem_compl hx₂] using cover hx₁⟩
intros
rw [uniform_continuous₂_def, abstract_completion.extend₂, uncurry_curry]
apply uniform_continuous_extend
intros
simp [continuous_on, continuous_within_at_iff'_right]
intros
split
intros e s hs
{ intros e s hs, rcases Cauchy.mem_uniformity'.1 hs with ⟨t, tu, ts⟩, apply ts, rcases comp_mem_uniformity_sets tu with ⟨d, du, dt⟩, refine mem_prod_iff.2 ⟨_, f.2.le_nhds_Lim (mem_nhds_right (Lim f.1) du), _, g.2.le_nhds_Lim (mem_nhds_left (Lim g.1) du), λ x h, _⟩, cases x with a b, cases h with h₁ h₂, rw ← e at h₂, exact dt ⟨_, h₁, h₂⟩ }
rcases Cauchy.mem_uniformity'.1 hs with ⟨t, tu, ts⟩
apply ts
rcases comp_mem_uniformity_sets tu with ⟨d, du, dt⟩
refine mem_prod_iff.2 ⟨_, f.2.le_nhds_Lim (mem_nhds_right (Lim f.1) du), _, g.2.le_nhds_Lim (mem_nhds_left (Lim g.1) du), λ x h, _⟩
cases x with a b
cases h with h₁ h₂
rw ← e at h₂
exact dt ⟨_, h₁, h₂⟩
intros H
{ intros H, refine separated_def.1 (by apply_instance) _ _ (λ t tu, _), rcases mem_uniformity_is_closed tu with ⟨d, du, dc, dt⟩, refine H {p | (Lim p.1.1, Lim p.2.1) ∈ t} (Cauchy.mem_uniformity'.2 ⟨d, du, λ f g h, _⟩), rcases mem_prod_iff.1 h with ⟨x, xf, y, yg, h⟩, have limc : ∀ (f : Cauchy α) (x ∈ f.1), Lim f.1 ∈ closure x, { intros f x xf, rw closure_eq_cluster_pts, exact f.2.1.mono (le_inf f.2.le_nhds_Lim (le_principal_iff.2 xf)) }, have := dc.closure_subset_iff.2 h, rw closure_prod_eq at this, refine dt (this ⟨_, _⟩); dsimp; apply limc; assumption }
refine separated_def.1 (by apply_instance) _ _ (λ t tu, _)
rcases mem_uniformity_is_closed tu with ⟨d, du, dc, dt⟩
refine H {p | (Lim p.1.1, Lim p.2.1) ∈ t} (Cauchy.mem_uniformity'.2 ⟨d, du, λ f g h, _⟩)
rcases mem_prod_iff.1 h with ⟨x, xf, y, yg, h⟩
have limc : ∀ (f : Cauchy α) (x ∈ f.1), Lim f.1 ∈ closure x
intros f x xf
{ intros f x xf, rw closure_eq_cluster_pts, exact f.2.1.mono (le_inf f.2.le_nhds_Lim (le_principal_iff.2 xf)) }
rw closure_eq_cluster_pts
exact f.2.1.mono (le_inf f.2.le_nhds_Lim (le_principal_iff.2 xf))
have := dc.closure_subset_iff.2 h
rw closure_prod_eq at this
refine dt (this ⟨_, _⟩); dsimp; apply limc; assumption
refine dt (this ⟨_, _⟩); dsimp; apply limc
refine dt (this ⟨_, _⟩); dsimp
refine dt (this ⟨_, _⟩)
dsimp
apply limc
assumption
dsimp
apply limc
assumption
intros
rw [uniform_continuous, uniformity_prod_eq_prod, uniformity_quotient, uniformity_quotient, filter.prod_map_map_eq, filter.tendsto_map'_iff, filter.tendsto_map'_iff]
rwa [uniform_continuous, uniformity_prod_eq_prod, filter.tendsto_map'_iff] at hf
intros
simp only [CU.lim, approx_of_mem_C, h, csupr_const]
intros
simp [write', h]
intros
cases b; simp
cases b
simp
simp
intros
unfold sub_nat_nat
rw h
unfold sub_nat_nat._match_1
intros
rw [← int.add_zero (-a), ←h, ←int.add_assoc, int.add_left_neg, int.zero_add]
intros
have h := int.add_le_add_right h (-b)
rwa int.add_right_neg at h
intros
have h := int.add_lt_add_right h (-b)
rwa [int.add_comm b c, int.add_neg_cancel_right] at h
intros
unfold bitwise; rw [binary_rec_zero]
unfold bitwise
rw [binary_rec_zero]
intros
induction k with k
{ rw [nat.mul_zero, nat.sub_zero] }
rw [nat.mul_zero, nat.sub_zero]
have h₂ : n * k ≤ x
{ have h₂ : n * k ≤ x, { rw [mul_succ] at h₁, apply nat.le_trans _ h₁, apply nat.le_add_right _ n }, have h₄ : x - n * k ≥ n, { apply @nat.le_of_add_le_add_right (n*k), rw [nat.sub_add_cancel h₂], simp [mul_succ, nat.add_comm] at h₁, simp [h₁] }, rw [mul_succ, ← nat.sub_sub, ← mod_eq_sub_mod h₄, k_ih h₂] }
rw [mul_succ] at h₁
{ rw [mul_succ] at h₁, apply nat.le_trans _ h₁, apply nat.le_add_right _ n }
apply nat.le_trans _ h₁
apply nat.le_add_right _ n
have h₄ : x - n * k ≥ n
apply @nat.le_of_add_le_add_right (n*k)
{ apply @nat.le_of_add_le_add_right (n*k), rw [nat.sub_add_cancel h₂], simp [mul_succ, nat.add_comm] at h₁, simp [h₁] }
rw [nat.sub_add_cancel h₂]
simp [mul_succ, nat.add_comm] at h₁
simp [h₁]
rw [mul_succ, ← nat.sub_sub, ← mod_eq_sub_mod h₄, k_ih h₂]
intros
rw [nat.sub_sub, nat.sub_sub, nat.add_comm]
intros
refine vadd_left_cancel (p -ᵥ p2) _
rw [vsub_vadd, ← h, vsub_vadd]
intros
simp [bit0, add_smul]
intros
split
split; intros h
intros h
rw [← mul_one a, ← lmul_left_apply a 1, h, linear_map.zero_apply]
{ rw [← mul_one a, ← lmul_left_apply a 1, h, linear_map.zero_apply], }
intros h
{ rw h, exact lmul_left_zero_eq_zero, }
rw h
exact lmul_left_zero_eq_zero
intros
induction n with n ih
simp [h]
{ simp [h] }
convert h.mul_mul ih; rw pow_succ
convert h.mul_mul ih
rw pow_succ
rw pow_succ
intros
haveI := classical.dec_eq α
{ haveI := classical.dec_eq α, rw [←prod_erase_mul _ _ ha, h, mul_zero] }
rw [←prod_erase_mul _ _ ha, h, mul_zero]
intros
{ classical, rw [finprod_def, dif_pos hf] }
classical
rw [finprod_def, dif_pos hf]
intros
rw prod_nat_cast
cases le_or_lt k n with hkn hnk
exact prod_congr rfl (λ i hi, (nat.cast_sub $ (mem_range.1 hi).le.trans hkn).symm)
{ exact prod_congr rfl (λ i hi, (nat.cast_sub $ (mem_range.1 hi).le.trans hkn).symm) }
rw ← mem_range at hnk
{ rw ← mem_range at hnk, rw [prod_eq_zero hnk, prod_eq_zero hnk]; simp }
rw [prod_eq_zero hnk, prod_eq_zero hnk]; simp
rw [prod_eq_zero hnk, prod_eq_zero hnk]
simp
simp
intros
{ rw ←cocone_naturality F f, refl }
rw ←cocone_naturality F f
refl
intros
rw [epi_iff_range_eq_top, linear_map.range_eq_top]
intros
obtain ⟨ppredConts, nth_conts_eq, ⟨rfl⟩⟩ : ∃ conts, g.continuants n = conts ∧ conts.a = ppredA
from exists_conts_a_of_num nth_num_eq
obtain ⟨predConts, succ_nth_conts_eq, ⟨rfl⟩⟩ : ∃ conts, g.continuants (n + 1) = conts ∧ conts.a = predA
from exists_conts_a_of_num succ_nth_num_eq
rw [num_eq_conts_a, (continuants_recurrence succ_nth_s_eq nth_conts_eq succ_nth_conts_eq)]
intros
rw [terminated_at_iff_s_none, part_num_none_iff_s_none]
intros
rw [_root_.mul_comm, direct_limit.mul_inv_cancel G f hp]
intros
simp
intros
apply iff.trans multiset.dvd_gcd
simp only [multiset.mem_map, and_imp, exists_imp_distrib]
exact ⟨λ k b hb, k _ _ hb rfl, λ k a' b hb h, h ▸ k _ hb⟩
intros
rw [← mul_assoc, mul_right_inv, one_mul]
intros
{ dsimp [bit1], rw [add_mul, bit0_mul, one_mul], }
dsimp [bit1]
rw [add_mul, bit0_mul, one_mul]
intros
simpa only [sq] using abs_mul_abs_self x
intros
rw [mul_comm, div_mul_left ha]
intros
rw ←d_comp_eq_to_hom C r r'
apply kernel_subobject_comp_mono
intros
dsimp [mk_hom, mk_hom_aux]
induction n; congr
induction n
congr
congr
intros
dsimp [d_next]
simp only [chain_complex.next_nat_succ]
refl
intros
rw [← inf_mul_sup a b, ← sup_div_inf_eq_abs_div, div_eq_mul_inv, ← mul_assoc, mul_comm, mul_assoc, ← pow_two, inv_mul_cancel_left]
intros
{ rw lie_comm, exact lie_le_right I J, }
rw lie_comm
exact lie_le_right I J
intros
simp only [of_le, hom_of_le_apply, lie_hom.mem_range]
split
{ rintros ⟨y, rfl⟩, exact y.property, }
rintros ⟨y, rfl⟩
exact y.property
{ intros h, use ⟨(x : L), h⟩, simp, }
intros h
use ⟨(x : L), h⟩
simp
intros
let J : lie_ideal R L' := { lie_mem := λ x y hy, begin have hy' : ∃ (x : L), x ∈ I ∧ f x = y, { simpa [hy], }, obtain ⟨z₂, hz₂, rfl⟩ := hy', obtain ⟨z₁, rfl⟩ := h x, simp only [lie_hom.coe_to_linear_map, set_like.mem_coe, set.mem_image, lie_submodule.mem_coe_submodule, submodule.mem_carrier, submodule.map_coe], use ⁅z₁, z₂⁆, exact ⟨I.lie_mem hz₂, f.map_lie z₁ z₂⟩, end, ..(I : submodule R L).map (f : L →ₗ[R] L'), }
erw lie_submodule.coe_lie_span_submodule_eq_iff
use J
apply lie_submodule.coe_to_submodule_mk
intros
ext m
simp only [weight_space, lie_submodule.coe_to_submodule_mk, lie_subalgebra.coe_bracket_of_module, function.comp_app, mem_pre_weight_space]
split
split; intros h x
intros h x
obtain ⟨k, hk⟩ := h ⟨x, set.mem_univ x⟩
{ obtain ⟨k, hk⟩ := h ⟨x, set.mem_univ x⟩, use k, exact hk, }
use k
exact hk
intros h x
{ obtain ⟨k, hk⟩ := h x, use k, exact hk, }
obtain ⟨k, hk⟩ := h x
use k
exact hk
intros
simp
intros
{ ext, refl, }
ext
refl
intros
by_cases xy : x ≤ y; by_cases yx : y ≤ x; simp [cmp_le, lt_iff_le_not_le, *, cmp, cmp_using]
by_cases xy : x ≤ y; by_cases yx : y ≤ x
by_cases xy : x ≤ y
by_cases yx : y ≤ x
simp [cmp_le, lt_iff_le_not_le, *, cmp, cmp_using]
simp [cmp_le, lt_iff_le_not_le, *, cmp, cmp_using]
by_cases yx : y ≤ x
simp [cmp_le, lt_iff_le_not_le, *, cmp, cmp_using]
simp [cmp_le, lt_iff_le_not_le, *, cmp, cmp_using]
cases not_or xy yx (total_of _ _ _)
intros
rw [mul_comm, lt_div_iff_of_neg hc]
intros
simpa using lt_inv ha hb
intros
simpa only [div_eq_mul_inv] using hf.mul_const (inv_nonneg.2 hc)
intros
rw [← mul_lt_mul_iff_right b, one_mul, div_eq_mul_inv, inv_mul_cancel_right]
intros
haveI := @linear_order.decidable_le α _; exact (@decidable.strict_mono_on_mul_self α _ _).inj_on.eq_iff h1 h2
haveI := @linear_order.decidable_le α _
exact (@decidable.strict_mono_on_mul_self α _ _).inj_on.eq_iff h1 h2
intros
nontriviality
exact bit1_pos h.le
intros
rw [bit1, lt_add_iff_pos_left, bit0, ← two_mul, zero_lt_mul_left (zero_lt_two : 0 < (2:α))]
intros
rcases nat.even_or_odd n with ⟨k, rfl⟩ | ⟨k, rfl⟩
rcases nat.even_or_odd n with ⟨k, rfl⟩ | ⟨k, rfl⟩; have hk : (k : α) * (2 * c) = 2 * k * c := by rw [mul_left_comm, ← mul_assoc]
have hk : (k : α) * (2 * c) = 2 * k * c := by rw [mul_left_comm, ← mul_assoc]
{ simpa [hk, hi] using (h.nat_even_mul_periodic k).eq }
simpa [hk, hi] using (h.nat_even_mul_periodic k).eq
have hk : (k : α) * (2 * c) = 2 * k * c := by rw [mul_left_comm, ← mul_assoc]
simpa [add_mul, hk, hi] using (h.nat_odd_mul_antiperiodic k).eq
{ simpa [add_mul, hk, hi] using (h.nat_odd_mul_antiperiodic k).eq }
intros
simp
intros
simpa using degree_multiset_prod (s.1.map f)
intros
rintro rfl
rcases exists_pair_ne R with ⟨x, y, xy⟩
refine xy (ra (_ : x * 0 = y * 0))
rw [mul_zero, mul_zero]
intros
unfold bit0
intros
simp [div_eq_mul_inv]
intros
erw [← to_open_germ S ⊤ ⟨p, trivial⟩, ← to_open_germ R ⊤ ⟨prime_spectrum.comap f p, trivial⟩, category.assoc, PresheafedSpace.stalk_map_germ (Spec.SheafedSpace_map f) ⊤ ⟨p, trivial⟩, Spec.SheafedSpace_map_c_app, to_open_comp_comap_assoc]
refl
intros
erw [to_stalk, category.assoc, germ_comp_stalk_to_fiber_ring_hom]
{ erw [to_stalk, category.assoc, germ_comp_stalk_to_fiber_ring_hom], refl }
refl
intros
{ ext : 2, dsimp, apply subsingleton.elim }
ext : 2
dsimp
apply subsingleton.elim
intros
dsimp [δ, σ]
{ dsimp [δ, σ], simp only [←X.map_comp, simplex_category.δ_comp_σ_of_le H] }
simp only [←X.map_comp, simplex_category.δ_comp_σ_of_le H]
intros
by_cases hK : K = 0
simp only [gronwall_bound_K0, hK]
{ simp only [gronwall_bound_K0, hK], exact continuous_const.add (continuous_id.mul continuous_const) }
exact continuous_const.add (continuous_id.mul continuous_const)
simp only [gronwall_bound_of_K_ne_0 hK]
{ simp only [gronwall_bound_of_K_ne_0 hK], exact continuous_const.add ((continuous_id.mul continuous_const).mul continuous_const) }
exact continuous_const.add ((continuous_id.mul continuous_const).mul continuous_const)
intros
{ ext n, simp [formal_multilinear_series.comp] }
ext n
simp [formal_multilinear_series.comp]
intros
refine ((h₁.norm_norm.mul_is_o h₂.norm_norm).congr _ _).of_norm_norm
refine ((h₁.norm_norm.mul_is_o h₂.norm_norm).congr _ _).of_norm_norm; by intros; simp only [norm_smul]
intros; simp only [norm_smul]
intros; simp only [norm_smul]
intros
intros
simp only [norm_smul]
simp only [norm_smul]
intros; simp only [norm_smul]
intros; simp only [norm_smul]
intros
intros
simp only [norm_smul]
simp only [norm_smul]
intros
unfold is_O
{ unfold is_O, exact exists_congr (λ c, is_O_with_congr rfl hf hg) }
exact exists_congr (λ c, is_O_with_congr rfl hf hg)
intros
simp only [is_O_with, exists_prop, true_and, norm_zero, mul_zero, norm_le_zero_iff]
intros
apply has_deriv_at.deriv
exact has_deriv_at.scomp x hg.has_deriv_at hh.has_deriv_at
intros
rw ← has_deriv_within_at_univ at *
exact hc.div hd hx
intros
convert ← has_deriv_within_at_iff_tendsto_slope
exact diff_singleton_eq_self hs
intros
simp only [deriv, fderiv_sub_const]
intros
simp only [sub_eq_add_neg, fderiv_within_const_add, fderiv_within_neg, hxs]
intros
rintros v ⟨c, d, dtop, clim, cdlim⟩
refine ⟨c, (λn, f (x + d n) - f x), mem_of_superset dtop _, clim, h.lim at_top dtop clim cdlim⟩
simp [-mem_image, mem_image_of_mem] {contextual := tt}
intros
refine is_o_congr ((h.prod_mk_nhds h).mono _) (eventually_of_forall $ λ _, rfl)
rintros p ⟨hp₁, hp₂⟩
simp only [*]
intros
have := hf.local_inverse_apply_image hf' hn
apply (hf.to_local_homeomorph f hf' hn).times_cont_diff_at_symm (image_mem_to_local_homeomorph_target hf hf' hn)
{ convert hf' }
convert hf'
{ convert hf }
convert hf
intros
have hdf : ∀ x ∈ Ioo a b, differentiable_at ℝ f x
from λ x hx, (hdf x hx).differentiable_at (Ioo_mem_nhds hx.1 hx.2)
have hdg : ∀ x ∈ Ioo a b, differentiable_at ℝ g x
from λ x hx, classical.by_contradiction (λ h, hg' x hx (deriv_zero_of_not_differentiable_at h))
exact has_deriv_at.lhopital_zero_left_on_Ioo hab (λ x hx, (hdf x hx).has_deriv_at) (λ x hx, (hdg x hx).has_deriv_at) hg' hfb hgb hdiv
intros
refine univ_subset_iff.1 (λy hy, _)
rcases exists_one_lt_norm 𝕜 with ⟨w, hw⟩
refine ⟨λn, w^n, λn, (w^n)⁻¹ • y, univ_mem' (λn, mem_univ _), _, _⟩
simp only [norm_pow]
{ simp only [norm_pow], exact tendsto_pow_at_top_at_top_of_one_lt hw }
exact tendsto_pow_at_top_at_top_of_one_lt hw
convert tendsto_const_nhds
{ convert tendsto_const_nhds, ext n, have : w ^ n * (w ^ n)⁻¹ = 1, { apply mul_inv_cancel, apply pow_ne_zero, simpa [norm_eq_zero] using (ne_of_lt (lt_trans zero_lt_one hw)).symm }, rw [smul_smul, this, one_smul] }
ext n
have : w ^ n * (w ^ n)⁻¹ = 1
apply mul_inv_cancel
{ apply mul_inv_cancel, apply pow_ne_zero, simpa [norm_eq_zero] using (ne_of_lt (lt_trans zero_lt_one hw)).symm }
apply pow_ne_zero
simpa [norm_eq_zero] using (ne_of_lt (lt_trans zero_lt_one hw)).symm
rw [smul_smul, this, one_smul]
intros
have A : continuous (λq : (E →L[𝕜] F) × E, q.1 q.2) := is_bounded_bilinear_map_apply.continuous
have B : continuous (λp : E × E, (fderiv 𝕜 f p.1, p.2))
apply continuous.prod_mk _ continuous_snd
{ apply continuous.prod_mk _ continuous_snd, exact continuous.comp (h.continuous_fderiv hn) continuous_fst }
exact continuous.comp (h.continuous_fderiv hn) continuous_fst
exact A.comp B
intros
simpa only [sub_eq_add_neg] using hf.add hg.neg
intros
simp only [← times_cont_diff_on_univ, times_cont_diff_on_succ_iff_deriv_of_open, is_open_univ, differentiable_on_univ]
intros
have A : has_strict_fderiv_at (coe : ℝ → ℂ) of_real_clm z := of_real_clm.has_strict_fderiv_at
have B : has_strict_fderiv_at e ((continuous_linear_map.smul_right 1 e' : ℂ →L[ℂ] ℂ).restrict_scalars ℝ) (of_real_clm z) := h.has_strict_fderiv_at.restrict_scalars ℝ
have C : has_strict_fderiv_at re re_clm (e (of_real_clm z)) := re_clm.has_strict_fderiv_at
simpa using (C.comp z (B.comp z A)).has_strict_deriv_at
intros
rw [open_segment_symm, left_mem_open_segment_iff, eq_comm]
intros
have h : x + t • y = (1 - t) • x + t • (x + y)
rw [smul_add, ←add_assoc, ←add_smul, sub_add_cancel, one_smul]
{ rw [smul_add, ←add_assoc, ←add_smul, sub_add_cancel, one_smul] }
rw h
exact hs hx hy (sub_nonneg_of_le ht.2) ht.1 (sub_add_cancel _ _)
intros
rw [←inner_conj_sym, conj_im]
intros
{ rw [norm_add_mul_self, norm_sub_mul_self], ring }
rw [norm_add_mul_self, norm_sub_mul_self]
ring
intros
conv_rhs { rw ← complex.isometry_euclidean_proj_eq_self z }
{ conv_rhs { rw ← complex.isometry_euclidean_proj_eq_self z }, simp }
simp
intros
ext
{ ext, convert eq_orthogonal_projection_of_mem_orthogonal _ _; simp [hv] }
convert eq_orthogonal_projection_of_mem_orthogonal _ _
convert eq_orthogonal_projection_of_mem_orthogonal _ _; simp [hv]
simp [hv]
simp [hv]
intros
rw [homothety_eq_line_map, ← line_map_apply_one_sub, ← homothety_eq_line_map, dist_homothety_center, dist_comm]
intros
rw nonlinear_right_inverse_of_surjective
exact classical.some_spec (exists_nonlinear_right_inverse_of_surjective f hsurj)
intros
simp [dist_eq_norm]
intros
rw [norm_smul, real.norm_eq_abs, abs_of_nonneg ht]
intros
haveI : is_symm E (λ (x y : E), 1 ≤ ∥x - y∥)
constructor
{ constructor, assume x y hxy, rw ← norm_neg, simpa }
assume x y hxy
rw ← norm_neg
simpa
apply exists_seq_of_forall_finset_exists' (λ (x : E), ∥x∥ ≤ R) (λ (x : E) (y : E), 1 ≤ ∥x - y∥)
assume s hs
exact exists_norm_le_le_norm_sub_of_finset hc hR h s
intros
ext m x
simp only [tail_cons, continuous_linear_map.uncurry_left_apply, continuous_multilinear_map.curry_left_apply]
rw cons_zero
intros
cases f; cases g; congr'; exact funext H
cases f; cases g; congr'
cases f; cases g
cases f
cases g
congr'
intros
simp only [norm_def, neg_apply, norm_neg]
intros
have := bernstein_polynomial.sum ℝ n
apply_fun (λ p, polynomial.aeval (x : ℝ) p) at this
simp [alg_hom.map_sum, finset.sum_range] at this
exact this
rw [← map_exp_at_top, comap_map exp_injective, map_exp_at_top]
intros
suffices : times_cont_diff_on ℝ ⊤ log {0}ᶜ
from this.of_le le_top
refine (times_cont_diff_on_top_iff_deriv_of_open is_open_compl_singleton).2 _
simp [differentiable_on_log, times_cont_diff_on_inv]
intros
induction n with k ih
simp
{ simp }
rw [prod_range_succ_comm, mul_left_comm, ← ih, mul_succ, integral_sin_pow]
norm_cast
simp [-cast_add] with field_simps
intros
rw ← times_cont_diff_within_at_univ at *
{ rw ← times_cont_diff_within_at_univ at *, exact hf.rpow_const_of_le h }
exact hf.rpow_const_of_le h
intros
{ rw [← coe_one, coe_rpow_of_ne_zero one_ne_zero], simp }
rw [← coe_one, coe_rpow_of_ne_zero one_ne_zero]
simp
intros
rw [rpow_def_of_nonneg hx]; split_ifs; simp only [zero_le_one, le_refl, le_of_lt (exp_pos _)]
rw [rpow_def_of_nonneg hx]; split_ifs
rw [rpow_def_of_nonneg hx]
split_ifs
simp only [zero_le_one, le_refl, le_of_lt (exp_pos _)]
simp only [zero_le_one, le_refl, le_of_lt (exp_pos _)]
intros
rw [sub_eq_add_neg, cpow_add _ _ hx, cpow_neg, div_eq_mul_inv]
simpa only [sin_neg, sin_pi_div_two] using intermediate_value_Icc (neg_le_self pi_div_two_pos.le) continuous_sin.continuous_on
intros
exact_mod_cast @complex.sin_eq_sin_iff x y
simp [arccos]
intros
rcases ennreal.lt_iff_exists_coe.1 hr with ⟨r, rfl, hr'⟩
rw [← ennreal.coe_zero]
norm_cast at *
apply nnreal.tendsto_pow_at_top_nhds_0_of_lt_1 hr
intros
have := (normed_ring.summable_geometric_of_norm_lt_1 x h).has_sum.mul_left (1 - x)
refine tendsto_nhds_unique this.tendsto_sum_nat _
have : tendsto (λ (n : ℕ), 1 - x ^ n) at_top (nhds 1)
simpa using tendsto_const_nhds.sub (tendsto_pow_at_top_nhds_0_of_norm_lt_1 h)
{ simpa using tendsto_const_nhds.sub (tendsto_pow_at_top_nhds_0_of_norm_lt_1 h) }
convert ← this
ext n
rw [←mul_neg_geom_sum, geom_sum_def, finset.mul_sum]
intros
apply epi_fst_of_is_limit _ _ (pullback_cone.is_limit_of_factors f g g₂ f' g₁ hf hg t ht)
intros
simp only [iso.inv_hom_id_assoc, arrow.w, arrow.mk_hom]
intros
convert transfer_nat_trans_counit _ _ (prod_comparison_nat_iso F A).inv B
ext
simp
intros
rw [← trans_conj, α.self_symm_id, refl_conj]
intros
ext
ext; cases p; simp
ext; cases p
cases p
simp
intros
simp only [←category.assoc, cancel_mono]
intros
let E := (forget C).map_cone D
let hE : is_limit E := is_limit_of_preserves _ hD
let G := types.limit_cone (F ⋙ forget C)
let hG := types.limit_cone_is_limit (F ⋙ forget C)
let T : E.X ≅ G.X := hE.cone_point_unique_up_to_iso hG
change function.injective (T.hom ≫ (λ x j, G.π.app j x))
have h : function.injective T.hom
intros a b h
{ intros a b h, suffices : T.inv (T.hom a) = T.inv (T.hom b), by simpa, rw h }
suffices : T.inv (T.hom a) = T.inv (T.hom b)
simpa
simpa
rw h
suffices : function.injective (λ (x : G.X) j, G.π.app j x)
exact this.comp h
exact this.comp h
apply subtype.ext
intros
{ ext, simp }
ext
simp
intros
simp
intros
rw [is_iso.eq_comp_inv, category.assoc, is_iso.inv_comp_eq, prod_comparison_natural]
intros
simpa using B.ι_π j j
intros
simp
intros
tidy
intros
rw [←functor.as_equivalence_functor F, equivalence_preserves_zero_morphisms]
intros
{ slice_rhs 1 2 { rw right_unitor_inv_naturality }, simp }
slice_rhs 1 2 { rw right_unitor_inv_naturality }
simp
intros
dsimp [tensor_hom]
apply is_limit.hom_ext (ℬ _ _).is_limit
rintro ⟨⟩
rintro ⟨⟩; simp
simp
simp
intros
simp only [cancel_epi]
intros
rw [iso.inv_comp_eq, ←category.assoc, iso.eq_comp_inv, additive_obj_iso_biproduct_naturality]
intros
simpa [covers_iff] using and.intro hS hR
intros
change _ ↔ ∀ ⦃Y : C⦄ (f : Y ⟶ X) (h : S f), P.map f.op (yoneda_equiv g) = x.app (op Y) ⟨f, h⟩
split
rintro rfl Y f hf
{ rintro rfl Y f hf, rw yoneda_equiv_naturality, dsimp, simp }
rw yoneda_equiv_naturality
dsimp
simp
intro h
{ intro h, ext Y ⟨f, hf⟩, have : _ = x.app Y _ := h f hf, rw yoneda_equiv_naturality at this, rw ← this, dsimp, simp }
ext Y ⟨f, hf⟩
have : _ = x.app Y _ := h f hf
rw yoneda_equiv_naturality at this
rw ← this
dsimp
simp
intros
rintro Z _ ⟨g, rfl, hg⟩
exact ⟨_, g, f, h, hg, rfl⟩
intros
simp [of_mk_le, of_le_mk, of_le, of_mk_le_mk, ←functor.map_comp_assoc underlying]
intros
simp [kernel_subobject_iso]
intros
simp only [colex.lt_def, not_exists, mem_image, exists_prop, not_and]
split
rintro ⟨k, z, q, k', _, rfl⟩
{ rintro ⟨k, z, q, k', _, rfl⟩, exact ⟨k', λ x hx, by simpa [h₁.injective.eq_iff] using z (h₁ hx), λ t, q _ t rfl, ‹k' ∈ B›⟩ }
exact ⟨k', λ x hx, by simpa [h₁.injective.eq_iff] using z (h₁ hx), λ t, q _ t rfl, ‹k' ∈ B›⟩
rintro ⟨k, z, ka, _⟩
refine ⟨f k, λ x hx, _, _, k, ‹k ∈ B›, rfl⟩
split
{ split, any_goals { rintro ⟨x', hx', rfl⟩, refine ⟨x', _, rfl⟩, rwa ← z _ <|> rwa z _, rwa strict_mono.lt_iff_lt h₁ at hx } }
any_goals { rintro ⟨x', hx', rfl⟩, refine ⟨x', _, rfl⟩, rwa ← z _ <|> rwa z _, rwa strict_mono.lt_iff_lt h₁ at hx }
rintro ⟨x', hx', rfl⟩
refine ⟨x', _, rfl⟩
rwa ← z _
rwa strict_mono.lt_iff_lt h₁ at hx
rintro ⟨x', hx', rfl⟩
refine ⟨x', _, rfl⟩
rwa z _
rwa ← z _
rwa strict_mono.lt_iff_lt h₁ at hx
simp only [h₁.injective, function.injective.eq_iff]
{ simp only [h₁.injective, function.injective.eq_iff], exact λ x hx, ne_of_mem_of_not_mem hx ka }
exact λ x hx, ne_of_mem_of_not_mem hx ka
intros
simp [boundary, fin.ext_iff]
intros
{ congr, exact map_length_split_wrt_composition l c }
congr
exact map_length_split_wrt_composition l c
intros
convert (fintype.of_equiv_card f.to_equiv).symm
intros
rw [eval_from, ε_NFA.eval_from, step_set, ε_NFA.step_set, to_ε_NFA_ε_closure]
congr
ext S s
simp only [exists_prop, set.mem_Union, set.bind_def]
apply exists_congr
simp only [and.congr_right_iff]
intros t ht
rw M.to_ε_NFA_ε_closure
refl
intros
simp only [star_eq_supr_pow, mul_supr, ← pow_succ, ← pow_zero l]
exact sup_supr_nat_succ _
intros
induction x; simp [rmatch, match_epsilon, deriv, *]
induction x
simp [rmatch, match_epsilon, deriv, *]
simp [rmatch, match_epsilon, deriv, *]
intros
rw [h, ← bind_pure_comp_eq_map]
congr
funext v
exact part.eq_some_iff.2 (mem_eval.2 ⟨refl_trans_gen.single rfl, rfl⟩)
intros
simp only [(>=>)] with functor_norm
intros
rw ← comp_bitraverse; simp [tfst,tsnd]
rw ← comp_bitraverse
simp [tfst,tsnd]
intros
induction xs; simp! * with functor_norm; refl
induction xs; simp! * with functor_norm
induction xs
simp! * with functor_norm
refl
simp! * with functor_norm
refl
intros
rw [←rev_list_reverse, list.reverse_reverse]
intros
simp [pure_eq_done]
intros
have : cb.size - n = 0 := nat.sub_eq_zero_of_le hc
simp only [foldl, foldl_core_succ_eq_fail, this, and.left_comm, ne_iff_lt_iff_le, exists_eq_left, exists_and_distrib_right, and.congr_left_iff, exists_and_distrib_left, foldl_core_zero_eq_fail]
rintro (h | ⟨⟨a, h⟩, rfl⟩)
{ exact mono.of_fail h }
exact mono.of_fail h
{ exact mono.of_done h }
exact mono.of_done h
intros
rw [char.of_nat, dif_pos h]
cases c
simp [char.to_nat]
intros
induction n; simp [*, of_real_mul, pow_succ]
induction n
simp [*, of_real_mul, pow_succ]
simp [*, of_real_mul, pow_succ]
intros
rw [← mul_right_inj' (@two_ne_zero' ℂ _ _ _), mul_add, two_cosh, two_sinh, add_add_sub_cancel, two_mul]
intros
{ ext, simp }
ext
simp
intros
{ unfold swap_core, split_ifs; cc }
unfold swap_core
split_ifs
split_ifs; cc
cc
cc
intros
{ subst h, simp }
subst h
simp
intros
cases n
{ simp }
simp
rcases i.le_last.eq_or_lt with rfl|h
{ simp [fin_rotate_last] }
simp [fin_rotate_last]
cases i
{ cases i, simp only [fin.lt_iff_coe_lt_coe, fin.coe_last, fin.coe_mk] at h, simp [fin_rotate_of_lt h, fin.eq_iff_veq, fin.add_def, nat.mod_eq_of_lt (nat.succ_lt_succ h)] }
simp only [fin.lt_iff_coe_lt_coe, fin.coe_last, fin.coe_mk] at h
simp [fin_rotate_of_lt h, fin.eq_iff_veq, fin.add_def, nat.mod_eq_of_lt (nat.succ_lt_succ h)]
intros
rw [← @encode_list_nil α, of_nat_encode]
intros
rw succ_above_last
intros
simp only [mem_Icc, insert_nth_le_iff, le_insert_nth_iff, and.assoc, and.left_comm]
intros
{ rw fin.coe_nat_eq_last, exact fin.le_last i }
rw fin.coe_nat_eq_last
exact fin.le_last i
intros
simp [piecewise, h]
intros
simpa [←to_finset_eq hl, ←to_finset_eq hl'] using h
intros
simp [fin_range]
intros
rw [mem_erase, not_and] at hsa
exact not_imp_not.mp hsa hs
intros
simp
intros
induction hs : univ.sigma f using finset.strong_induction_on with s ihs generalizing f
subst s
cases eq_empty_or_nonempty (univ.sigma f) with he hne
{ convert h0, simpa [funext_iff] using he }
convert h0
simpa [funext_iff] using he
rcases sigma_nonempty.1 hne with ⟨i, -, hi⟩
{ rcases sigma_nonempty.1 hne with ⟨i, -, hi⟩, rcases H_ex i (f i) hi with ⟨x, x_mem, hr⟩, set g := update f i ((f i).erase x) with hg, clear_value g, have hx' : x ∉ g i, by { rw [hg, update_same], apply not_mem_erase }, obtain rfl : f = update g i (insert x (g i)), by rw [hg, update_idem, update_same, insert_erase x_mem, update_eq_self], clear hg, rw [update_same, erase_insert hx'] at hr, refine step _ _ _ hr (ihs (univ.sigma g) _ _ rfl), rw ssubset_iff_of_subset (sigma_mono (subset.refl _) _), exacts [⟨⟨i, x⟩, mem_sigma.2 ⟨mem_univ _, by simp⟩, by simp [hx']⟩, (@le_update_iff _ _ _ _ g g i _).2 ⟨subset_insert _ _, λ _ _, le_rfl⟩] }
rcases H_ex i (f i) hi with ⟨x, x_mem, hr⟩
set g := update f i ((f i).erase x) with hg
clear_value g
have hx' : x ∉ g i
rw [hg, update_same]
rw [hg, update_same]
{ rw [hg, update_same], apply not_mem_erase }
{ rw [hg, update_same], apply not_mem_erase }
apply not_mem_erase
apply not_mem_erase
obtain rfl : f = update g i (insert x (g i))
rw [hg, update_idem, update_same, insert_erase x_mem, update_eq_self]
rw [hg, update_idem, update_same, insert_erase x_mem, update_eq_self]
clear hg
rw [update_same, erase_insert hx'] at hr
refine step _ _ _ hr (ihs (univ.sigma g) _ _ rfl)
rw ssubset_iff_of_subset (sigma_mono (subset.refl _) _)
exacts [⟨⟨i, x⟩, mem_sigma.2 ⟨mem_univ _, by simp⟩, by simp [hx']⟩, (@le_update_iff _ _ _ _ g g i _).2 ⟨subset_insert _ _, λ _ _, le_rfl⟩]
intros
classical; rw [map_eq_image, image_subset_iff_subset_preimage]
classical
rw [map_eq_image, image_subset_iff_subset_preimage]
intros
simp only [finset.ext_iff, split_support, split, comap_domain, mem_image, mem_preimage, sigma.forall, mem_sigma]
simp only [finset.ext_iff, split_support, split, comap_domain, mem_image, mem_preimage, sigma.forall, mem_sigma]; tauto
tauto
intros
classical
convert fintype.card_congr (subtype_or_equiv p q h)
simp
intros
apply_instance
intros
convert fintype.card_unique
exact unique.subtype_eq _
intros
induction s using quotient.induction_on
simpa using perm_comm
intros
rcases int.units_eq_one_or x with (rfl | rfl); simp
rcases int.units_eq_one_or x with (rfl | rfl)
simp
simp
intros
{ cases n, cases h, simp, }
cases n
cases h
simp
intros
rw [← sub_sub, neg_succ_of_nat_coe, sub_sub (n:ℤ)]
apply eq_neg_of_eq_neg
rw [neg_sub, sub_sub_self, add_right_comm]
exact @congr_arg ℕ ℤ _ _ (λi, (i + 1 : ℤ)) (nat.mod_add_div _ _).symm
intros
apply multiplicative.of_add.injective
rw [of_add_nsmul, of_add_zero, pow_gcd_eq_one]
rw [of_add_nsmul, of_add_zero, pow_gcd_eq_one]; rwa [←of_add_nsmul, ←of_add_zero, equiv.apply_eq_iff_eq]
rwa [←of_add_nsmul, ←of_add_zero, equiv.apply_eq_iff_eq]
rwa [←of_add_nsmul, ←of_add_zero, equiv.apply_eq_iff_eq]
intros
rw [odd_iff_not_even, nat.odd_iff_not_even, even_coe_nat]
intros
induction xs with x xs generalizing i j
{ cases h₀ }
cases h₀
cases i; cases j
cases i
{ cases i; cases j, case nat.zero nat.zero { refl }, case nat.succ nat.succ { congr, cases h₁, apply xs_ih; solve_by_elim [lt_of_succ_lt_succ] }, iterate 2 { dsimp at h₂, cases h₁ with _ _ h h', cases h x _ rfl, rw mem_iff_nth, exact ⟨_, h₂.symm⟩ <|> exact ⟨_, h₂⟩ } }
cases j
case nat.zero nat.zero { refl }
refl
case nat.succ nat.succ { congr, cases h₁, apply xs_ih; solve_by_elim [lt_of_succ_lt_succ] }
iterate 2 { dsimp at h₂, cases h₁ with _ _ h h', cases h x _ rfl, rw mem_iff_nth, exact ⟨_, h₂.symm⟩ <|> exact ⟨_, h₂⟩ }
dsimp at h₂
cases h₁ with _ _ h h'
cases h x _ rfl
rw mem_iff_nth
exact ⟨_, h₂.symm⟩
cases j
dsimp at h₂
cases h₁ with _ _ h h'
cases h x _ rfl
rw mem_iff_nth
exact ⟨_, h₂.symm⟩
exact ⟨_, h₂⟩
congr
cases h₁
apply xs_ih; solve_by_elim [lt_of_succ_lt_succ]
apply xs_ih
solve_by_elim [lt_of_succ_lt_succ]
solve_by_elim [lt_of_succ_lt_succ]
solve_by_elim [lt_of_succ_lt_succ]
intros
simp only [nth_modify_nth, if_neg h, id_map']
intros
cases l; refl
cases l
refl
refl
intros
induction L generalizing i
simp only [length] at hi
{ simp only [length] at hi, exact (nat.not_succ_le_zero i hi).elim }
exact (nat.not_succ_le_zero i hi).elim
cases i
simp
{ simp }
have : i < L_tl.length
simp at hi
{ simp at hi, exact nat.lt_of_succ_lt_succ hi }
exact nat.lt_of_succ_lt_succ hi
simp [L_ih this]
refl
intros
intros x hx
rw [mem_filter] at hx ⊢
exact ⟨h hx.left, hx.right⟩
intros
induction l with x l IH
{ simp }
simp
{ simpa using IH }
simpa using IH
intros
simp [erasep_cons, h]
intros
cases as; refl
cases as
refl
refl
intros
simp
intros
induction l₁ with x l₁ IH generalizing a; simp only [*, nil_append, cons_append, chain.nil, chain_cons, and_true, and_assoc]
induction l₁ with x l₁ IH generalizing a
simp only [*, nil_append, cons_append, chain.nil, chain_cons, and_true, and_assoc]
simp only [*, nil_append, cons_append, chain.nil, chain_cons, and_true, and_assoc]
intros
rw length_subsingleton_iff
induction s using quotient.induction_on'
simp only [mk'_eq_coe, nodup_coe_iff] at h
simp [h, nat.succ_le_iff]
intros
dsimp [Ico]; simp only [length_range']
dsimp [Ico]
simp only [length_range']
intros
rw nodup_iff_nth_le_inj
simp only [exists_prop, exists_and_distrib_right, not_forall]
exact ⟨n, m, ⟨hn, hm, h⟩, hne⟩
intros
induction l with hd tl IH generalizing l' f
{ simp }
simp
have : some hd = _ := hf 0
rw [eq_comm, list.nth_eq_some] at this
obtain ⟨w, h⟩ := this
let f' : ℕ ↪o ℕ := order_embedding.of_map_le_iff (λ i, f (i + 1) - (f 0 + 1)) (λ a b, by simp [nat.sub_le_sub_right_iff, nat.succ_le_iff, nat.lt_succ_iff])
have : ∀ ix, tl.nth ix = (l'.drop (f 0 + 1)).nth (f' ix)
intro ix
{ intro ix, simp [list.nth_drop, nat.add_sub_of_le, nat.succ_le_iff, ←hf] }
simp [list.nth_drop, nat.add_sub_of_le, nat.succ_le_iff, ←hf]
rw [←list.take_append_drop (f 0 + 1) l', ←list.singleton_append]
apply list.sublist.append _ (IH _ this)
rw [list.singleton_sublist, ←h, l'.nth_le_take _ (nat.lt_succ_self _)]
apply list.nth_le_mem
intros
induction h with hd l₁ l₂ h₁₂ h_sz₁₂ a b l l₁ l₂ l₃ h₁₂ h₂₃ h_sz₁₂ h_sz₂₃
{ refl }
refl
{ simp only [list.sizeof, h_sz₁₂] }
simp only [list.sizeof, h_sz₁₂]
{ simp only [list.sizeof, add_left_comm] }
simp only [list.sizeof, add_left_comm]
{ simp only [h_sz₁₂, h_sz₂₃] }
simp only [h_sz₁₂, h_sz₂₃]
intros
simp only [iota_eq_reverse_range', nodup_reverse, nodup_range']
intros
induction n with n hn
{ simp }
simp
{ rwa [rotate_cons_succ] }
rwa [rotate_cons_succ]
intros
obtain ⟨n, rfl⟩ := h
rw map_rotate
use n
intros
induction l₁ generalizing l₂
simp only [nil_kunion, nd₂]
case list.nil { simp only [nil_kunion, nd₂] }
case list.cons : s l₁ ih { simp at nd₁, simp [not_or_distrib, nd₁.1, nd₂, ih nd₁.2 (kerase_nodupkeys s.1 nd₂)] }
intros
induction l with hd tl ih; [refl, simp only [reverse_cons, sublists_append, sublists'_cons, map_append, ih, sublists_singleton, map_eq_map, bind_eq_bind, map_map, cons_bind, append_nil, nil_bind, (∘)]]
induction l with hd tl ih
refl
simp only [reverse_cons, sublists_append, sublists'_cons, map_append, ih, sublists_singleton, map_eq_map, bind_eq_bind, map_map, cons_bind, append_nil, nil_bind, (∘)]
intros
ext
ext; simp
simp
intros
rw [conj_transpose, conj_transpose, transpose_map, transpose_map, update_row_transpose, map_update_column]
refl
intros
{ ext, refl, }
ext
refl
intros
ext i j
rcases i
rcases i; rcases j; simp [diagonal]
rcases i; rcases j
rcases j
simp [diagonal]
simp [diagonal]
rcases j
simp [diagonal]
simp [diagonal]
intros
rw [←sum_hadamard_eq, finset.sum_comm]
simp [dot_product, vec_mul, finset.sum_mul, mul_assoc]
intros
{ ext i, simp [vec_mul] }
ext i
simp [vec_mul]
intros
rw [←multiset.sum_repeat, ←multiset.map_const]
exact sum_map_le_sum _ h
intros
rw [strong_induction_on]
intros
rw [revzip, powerset_aux_eq_map_coe, ← map_reverse, zip_map, ← revzip] at h
simp at h
rcases h with ⟨l₁, l₂, h, rfl, rfl⟩
exact quot.sound (revzip_sublists _ _ _ h)
intros
simp [C_apply, monomial, single_mul_single]
intros
{ ext1 φ, simp only [rename_expand, alg_hom.comp_apply] }
ext1 φ
simp only [rename_expand, alg_hom.comp_apply]
intros
induction n with n ih
simp only [nat.nat_zero_eq_zero, zero_mul, pow_zero, total_degree_one]
{ simp only [nat.nat_zero_eq_zero, zero_mul, pow_zero, total_degree_one] }
rw pow_succ
calc total_degree (a * a ^ n) ≤ a.total_degree + (a^n).total_degree : total_degree_mul _ _ ... ≤ a.total_degree + n * a.total_degree : add_le_add_left ih _ ... = (n+1) * a.total_degree : by rw [add_mul, one_mul, add_comm]
intros
rw nat.mod_two_of_bodd
{ rw nat.mod_two_of_bodd, simp }
simp
intros
cases n; split; rintro ⟨⟩; refl
cases n; split; rintro ⟨⟩
cases n; split
cases n
split
rintro ⟨⟩
rintro ⟨⟩
split
rintro ⟨⟩
refl
rintro ⟨⟩
refl
intros
simp [lor]
intros
induction n; simp [*, choose, choose_eq_zero_of_lt (lt_succ_self _)]
induction n
simp [*, choose, choose_eq_zero_of_lt (lt_succ_self _)]
simp [*, choose, choose_eq_zero_of_lt (lt_succ_self _)]
intros
simp [dist.def, add_comm]
intros
cases hn
rw factorial_one
{ rw factorial_one, exact lt_factorial_self (succ_le_succ hi) }
exact lt_factorial_self (succ_le_succ hi)
exact add_factorial_succ_lt_factorial_add_succ _ hi
intros
rw [←pochhammer_eval_cast, pochhammer_nat_eq_desc_factorial]
cases b
{ simp_rw desc_factorial_zero }
simp_rw desc_factorial_zero
simp_rw [add_succ, succ_sub_one]
obtain h | h := le_total a b
rw [desc_factorial_of_lt (lt_succ_of_le h), desc_factorial_of_lt (lt_succ_of_le _)]
{ rw [desc_factorial_of_lt (lt_succ_of_le h), desc_factorial_of_lt (lt_succ_of_le _)], rw [nat.sub_eq_zero_of_le h, zero_add] }
rw [nat.sub_eq_zero_of_le h, zero_add]
{ rw nat.sub_add_cancel h }
rw nat.sub_add_cancel h
intros
rw mul_comm at H2; exact H1.dvd_of_dvd_mul_right H2
rw mul_comm at H2
exact H1.dvd_of_dvd_mul_right H2
intros
cases eq_empty_or_nonempty s
subst h
{ subst h, simp only [or_true, eq_self_iff_true, iff_true, Inf, has_Inf.Inf, mem_empty_eq, exists_false, dif_neg, not_false_iff] }
simp only [or_true, eq_self_iff_true, iff_true, Inf, has_Inf.Inf, mem_empty_eq, exists_false, dif_neg, not_false_iff]
have := ne_empty_iff_nonempty.mpr h
{ have := ne_empty_iff_nonempty.mpr h, simp only [this, or_false, nat.Inf_def, h, nat.find_eq_zero] }
simp only [this, or_false, nat.Inf_def, h, nat.find_eq_zero]
intros
rw [add_comm, odd_add]
intros
refine (nat.prime_def_min_fac.1 (nat.prime_def_le_sqrt.2 ⟨nat.bit1_lt h.n_pos, _⟩)).2
rw ← e at hd
intros m m2 hm md
have := le_trans h.2 (le_trans (nat.min_fac_le_of_dvd m2 md) hm)
rw nat.le_sqrt at this
exact not_le_of_lt hd this
intros
rcases exists_eq_succ_of_ne_zero (pos_iff_ne_zero.1 hn) with ⟨m, rfl⟩
rcases exists_eq_succ_of_ne_zero (pos_iff_ne_zero.1 hn) with ⟨m, rfl⟩; exact totient_prime_pow_succ hp _
exact totient_prime_pow_succ hp _
intros
rw [← int.nat_cast_eq_coe_nat, cast_to_nat]
intros
cases n
cases n; refl
refl
refl
refl
intros
cases x; simp
cases x
simp
simp
intros
by_cases p a; simp [option.guard, h]; intro; contradiction
by_cases p a; simp [option.guard, h]; intro
by_cases p a; simp [option.guard, h]
by_cases p a
simp [option.guard, h]
simp [option.guard, h]
intros
linarith
intros
simp [balanced_sz] { contextual := tt }
intros
rw [to_list, foldr, foldr_cons_eq_to_list]; refl
rw [to_list, foldr, foldr_cons_eq_to_list]
refl
intros
split
rintros ⟨y, hy⟩
{ rintros ⟨y, hy⟩, cases h : y with a f, refine ⟨a, λ i j, (f i j).val, _, λ i j, (f i j).property⟩, rw [←hy, h, map_eq], refl }
cases h : y with a f
refine ⟨a, λ i j, (f i j).val, _, λ i j, (f i j).property⟩
rw [←hy, h, map_eq]
refl
rintros ⟨a, f, xeq, pf⟩
use ⟨a, λ i j, ⟨f i j, pf i j⟩⟩
rw [xeq]
reflexivity
intros
simp only [iselect,isubtree_cons]
simp [factor_multiset, prime_multiset.of_nat_list, prime_multiset.of_nat_multiset]
intros
rw [coeff_C, if_neg h]
intros
simp [nat_degree]
intros
rw [C_mul_X_pow_eq_monomial, monomial_nat_degree_leading_coeff_eq_self h]
intros
induction n; [simp only [pow_zero, degree_one, zero_nsmul], simp only [*, pow_succ, succ_nsmul, degree_mul]]
induction n
simp only [pow_zero, degree_one, zero_nsmul]
simp only [*, pow_succ, succ_nsmul, degree_mul]
intros
have h0 : p ≠ 0
contrapose! hp
{ contrapose! hp, simp [hp] }
simp [hp]
apply le_antisymm
rw derivative_apply
{ rw derivative_apply, apply le_trans (degree_sum_le _ _) (sup_le (λ n hn, _)), apply le_trans (degree_C_mul_X_pow_le _ _) (with_bot.coe_le_coe.2 (nat.sub_le_sub_right _ _)), apply le_nat_degree_of_mem_supp _ hn }
apply le_trans (degree_sum_le _ _) (sup_le (λ n hn, _))
apply le_trans (degree_C_mul_X_pow_le _ _) (with_bot.coe_le_coe.2 (nat.sub_le_sub_right _ _))
apply le_nat_degree_of_mem_supp _ hn
refine le_sup _
{ refine le_sup _, rw [mem_support_derivative, nat.sub_add_cancel, mem_support_iff], { show ¬ leading_coeff p = 0, rw [leading_coeff_eq_zero], assume h, rw [h, nat_degree_zero] at hp, exact lt_irrefl 0 (lt_of_le_of_lt (zero_le _) hp), }, exact hp }
rw [mem_support_derivative, nat.sub_add_cancel, mem_support_iff]
show ¬ leading_coeff p = 0
{ show ¬ leading_coeff p = 0, rw [leading_coeff_eq_zero], assume h, rw [h, nat_degree_zero] at hp, exact lt_irrefl 0 (lt_of_le_of_lt (zero_le _) hp), }
rw [leading_coeff_eq_zero]
assume h
rw [h, nat_degree_zero] at hp
exact lt_irrefl 0 (lt_of_le_of_lt (zero_le _) hp)
exact hp
intros
rw [mod_by_monic_eq_sub_mul_div p hq, eval₂_sub, eval₂_mul, hx, zero_mul, sub_zero]
intros
refine trans (eval₂_mul_noncomm _ _ $ λ k, _) (by rw eval₂_X)
rcases em (k = 1) with (rfl|hk)
{ simp }
simp
{ simp [coeff_X_of_ne_one hk] }
simp [coeff_X_of_ne_one hk]
intros
simp only [bit1, add_comp, bit0_comp, one_comp]
intros
apply polynomial.induction_on' p
{ intros r s hr hs, simp [add_comp, hr, hs], }
intros r s hr hs
simp [add_comp, hr, hs]
{ intros n a, simp, }
intros n a
simp
intros
simp only [polynomial.ext_iff, f.map_eq_zero, coeff_map, coeff_zero]
intros
rw [hasse_deriv_apply, coeff_sum, sum_def, finset.sum_eq_single (n + k), coeff_monomial]
simp only [if_true, nat.add_sub_cancel, eq_self_iff_true]
{ simp only [if_true, nat.add_sub_cancel, eq_self_iff_true], }
intros i hi hink
{ intros i hi hink, rw [coeff_monomial], by_cases hik : i < k, { simp only [nat.choose_eq_zero_of_lt hik, if_t_t, nat.cast_zero, zero_mul], }, { push_neg at hik, rw if_neg, contrapose! hink, exact (nat.sub_eq_iff_eq_add hik).mp hink, } }
rw [coeff_monomial]
by_cases hik : i < k
simp only [nat.choose_eq_zero_of_lt hik, if_t_t, nat.cast_zero, zero_mul]
{ simp only [nat.choose_eq_zero_of_lt hik, if_t_t, nat.cast_zero, zero_mul], }
push_neg at hik
{ push_neg at hik, rw if_neg, contrapose! hink, exact (nat.sub_eq_iff_eq_add hik).mp hink, }
rw if_neg
contrapose! hink
exact (nat.sub_eq_iff_eq_add hik).mp hink
intro h
{ intro h, simp only [not_mem_support_iff.mp h, monomial_zero_right, mul_zero, coeff_zero] }
simp only [not_mem_support_iff.mp h, monomial_zero_right, mul_zero, coeff_zero]
intros
induction n with n ih
{ simp only [iterated_deriv_zero_right] }
simp only [iterated_deriv_zero_right]
{ simp only [iterated_deriv_succ, ih, derivative_neg] }
simp only [iterated_deriv_succ, ih, derivative_neg]
intros
{ ext, simp only [coeff_reflect, coeff_C_mul], }
ext
simp only [coeff_reflect, coeff_C_mul]
intros
split_ifs with hxy
rw hxy
{ rw hxy, exact root_multiplicity_X_sub_C_self }
exact root_multiplicity_X_sub_C_self
exact root_multiplicity_eq_zero (mt root_X_sub_C.mp (ne.symm hxy))
intros
rw [root_set_def, map_C, roots_C, multiset.to_finset_zero, finset.coe_empty]
intros
rw [mul_num, int.nat_abs_mul, nat.coprime.gcd_eq_one, int.coe_nat_one, int.div_one]
rw [mul_num, int.nat_abs_mul, nat.coprime.gcd_eq_one, int.coe_nat_one, int.div_one]; exact (q.cop.mul_right q.cop).mul (q.cop.mul_right q.cop)
exact (q.cop.mul_right q.cop).mul (q.cop.mul_right q.cop)
intros
have := eq_neg_of_add_eq_zero (rat.nonneg_antisymm hba $ by rwa [← sub_eq_add_neg, neg_sub])
{ have := eq_neg_of_add_eq_zero (rat.nonneg_antisymm hba $ by rwa [← sub_eq_add_neg, neg_sub]), rwa neg_neg at this }
rwa neg_neg at this
intros
have := pos_add_lim_zero gh (neg_lim_zero fg); rwa [← sub_eq_add_neg, sub_sub_sub_cancel_right] at this
have := pos_add_lim_zero gh (neg_lim_zero fg)
rwa [← sub_eq_add_neg, sub_sub_sub_cancel_right] at this
intros
simp
intros
simp [h]
intros
rw [of_real_eq_coe_nnreal hp, ← coe_pow, ← of_real_coe_nnreal, nnreal.coe_pow, nnreal.coe_mk]
intros
by_cases ha : a = ⊤
rw h ha
{ rw h ha, exact le_top, }
exact le_top
by_cases hb : b = ⊤
rw hb
{ rw hb, exact le_top, }
exact le_top
rw [←coe_to_nnreal hb, ←coe_to_nnreal ha, coe_le_coe]
exact h_nnreal ha hb
intros
simp_rw [ennreal.of_real, ←coe_finset_sum, coe_eq_coe]
exact real.to_nnreal_sum_of_nonneg hf
rw [fib_rec.geom_sol_iff_root_char_poly, fib_rec_char_poly_eq]
simp [sub_eq_zero]
intros
cases le_total 0 q with hq hq
apply nnreal.eq
{ apply nnreal.eq, simp [real.to_nnreal, hp, hq, max_eq_left, mul_nonneg] }
simp [real.to_nnreal, hp, hq, max_eq_left, mul_nonneg]
have hpq := mul_nonpos_of_nonneg_of_nonpos hp hq
{ have hpq := mul_nonpos_of_nonneg_of_nonpos hp hq, rw [to_nnreal_eq_zero.2 hq, to_nnreal_eq_zero.2 hpq, mul_zero] }
rw [to_nnreal_eq_zero.2 hq, to_nnreal_eq_zero.2 hpq, mul_zero]
intros
apply le_trans hz
rw sqrt_two_add_series_succ
apply sqrt_two_add_series_monotone_left
apply le_sqrt_of_sq_le
have hb' : 0 < (b:ℝ) := nat.cast_pos.2 hb
have hd' : 0 < (d:ℝ) := nat.cast_pos.2 hd
rw [div_pow, add_div_eq_mul_add_div _ _ (ne_of_gt hd'), div_le_div_iff (pow_pos hb' _) hd']
exact_mod_cast h
intros
rw [sq, sqrt_mul_self h]
intros
simp only [preimage, inv_id, image_id]
intros
apply eq_of_bisim (λc₁ c₂, (empty α <|> c₂) = c₁) _ rfl
intros s' s h
rw ←h
apply cases_on s; intros s; rw think_empty; simp
apply cases_on s; intros s; rw think_empty
apply cases_on s; intros s
apply cases_on s
intros s
rw think_empty
simp
intros s
rw think_empty
simp
rw ←think_empty
intros
induction n with n IH generalizing s
refl
{ refl }
rw [nat.succ_eq_add_one, ←nth_tail, ←dropn_tail]
apply IH
intros
ext ⟨⟨x, x_in⟩, ⟨y, y_in⟩⟩
simp [set.diagonal]
intros
simp only [subset_def, not_forall]
intros
simp [nonempty_def.mp h, ext_iff]
intros
exact (countable_singleton _).union h
intros
rw [← finset.coe_inj, h.coe_to_finset, finset.coe_empty]
intros
rw hf.image_inter'
refine subset.antisymm _ (inter_subset_inter_left _ (preimage_mono $ inter_subset_left _ _))
rintro _ ⟨h₁, x, hx, rfl⟩
exact ⟨⟨h₁, by rwa hf hx⟩, mem_image_of_mem _ hx⟩
intros
rw [← image_univ]
exact h.bij_on_image (bijective_iff_bij_on_univ.1 ha) (hf.inj_on univ)
intros
{ ext x, simp [← e.lt_iff_lt] }
ext x
simp [← e.lt_iff_lt]
intros
rw [← Icc_diff_left, diff_union_self, union_eq_self_of_subset_right (singleton_subset_iff.2 $ left_mem_Icc.2 hab)]
intros
ext1 x
simp_rw [mem_union, mem_Iic, mem_Ioc, le_max_iff]
by_cases hc : c < x
{ tauto }
tauto
have hxb : x ≤ b := (le_of_not_gt hc).trans h₁.le
{ have hxb : x ≤ b := (le_of_not_gt hc).trans h₁.le, tauto }
tauto
intros
simp [sub_eq_add_neg]
intros
simp [sub_eq_add_neg, image_comp (λ x, a + x) (λ x, -x)]
intros
simpa only [mul_comm] using preimage_mul_const_Ioo_of_neg a b h
intros
simp [proj_Icc, hx, h]
intros
simp only [div_eq_mul_inv, image_mul_const_interval]
intros
rw [diff_eq, compl_Union, inter_Inter]; refl
rw [diff_eq, compl_Union, inter_Inter]
refl
intros
simp [← ne_empty_iff_nonempty, Inter_eq_empty_iff]
intros
rw eqv_gen_eq; exact Inf_le h
rw eqv_gen_eq
exact Inf_le h
intros
rw [card_image_of_inj_on, diag_card]
rintro ⟨x₀, x₁⟩ hx _ _ h
cases quotient.eq.1 h
{ refl }
refl
simp only [mem_coe, mem_diag] at hx
{ simp only [mem_coe, mem_diag] at hx, rw hx.2 }
rw hx.2
intros
ext i
ext i; induction i; [refl, apply i_ih]
ext i; induction i
induction i
refl
apply i_ih
intros
convert nth_cons_zero x nil
intros
rw [nth_eq_nth_le, ← list.nth_le_of_fn f]; congr; apply to_list_of_fn
rw [nth_eq_nth_le, ← list.nth_le_of_fn f]; congr
rw [nth_eq_nth_le, ← list.nth_le_of_fn f]
congr
apply to_list_of_fn
intros
casesI n
{ apply int.cast_add }
apply int.cast_add
simp only [coe_coe]
symmetry
erw [fin.coe_add, ← nat.cast_add, ← sub_eq_zero, ← nat.cast_sub (nat.mod_le _ _), @char_p.cast_eq_zero_iff R _ _ m]
exact h.trans (nat.dvd_sub_mod _)
intros
rw [add_comm, map_add_one, add_comm]
intros
refine tendsto_nhds_unique ((tendsto_add_at_top_iff_nat 1).1 _) hy
simp only [iterate_succ' f]
exact hf.tendsto.comp hy
intros
refine ⟨λ h, _, λ h, _⟩
rw ← iterate_one f
{ rw ← iterate_one f, refine function.is_periodic_pt.is_fixed_pt _, rw ← h, exact is_periodic_pt_minimal_period f x }
refine function.is_periodic_pt.is_fixed_pt _
rw ← h
exact is_periodic_pt_minimal_period f x
exact ((h.is_periodic_pt 1).minimal_period_le nat.one_pos).antisymm (nat.succ_le_of_lt ((h.is_periodic_pt 1).minimal_period_pos nat.one_pos))
{ exact ((h.is_periodic_pt 1).minimal_period_le nat.one_pos).antisymm (nat.succ_le_of_lt ((h.is_periodic_pt 1).minimal_period_pos nat.one_pos)) }
intros
rw [adjoin_adjoin_left, adjoin_adjoin_left, set.union_comm]
intros
have hf2 : f ∣ minpoly G F x
{ rw ← hfg, exact dvd_mul_right _ _ }
rw ← hfg
exact dvd_mul_right _ _
have hg2 : g ∣ minpoly G F x
{ rw ← hfg, exact dvd_mul_left _ _ }
rw ← hfg
exact dvd_mul_left _ _
have := eval₂ G F x
rw [← hfg, polynomial.eval₂_mul, mul_eq_zero] at this
cases this
right
{ right, have hf3 : f = minpoly G F x, { exact polynomial.eq_of_monic_of_associated hf (monic G F x) (associated_of_dvd_dvd hf2 $ @of_eval₂ G _ F _ _ _ x f this) }, rwa [← mul_one (minpoly G F x), hf3, mul_right_inj' (monic G F x).ne_zero] at hfg }
have hf3 : f = minpoly G F x
exact polynomial.eq_of_monic_of_associated hf (monic G F x) (associated_of_dvd_dvd hf2 $ @of_eval₂ G _ F _ _ _ x f this)
{ exact polynomial.eq_of_monic_of_associated hf (monic G F x) (associated_of_dvd_dvd hf2 $ @of_eval₂ G _ F _ _ _ x f this) }
rwa [← mul_one (minpoly G F x), hf3, mul_right_inj' (monic G F x).ne_zero] at hfg
left
{ left, have hg3 : g = minpoly G F x, { exact polynomial.eq_of_monic_of_associated hg (monic G F x) (associated_of_dvd_dvd hg2 $ @of_eval₂ G _ F _ _ _ x g this) }, rwa [← one_mul (minpoly G F x), hg3, mul_left_inj' (monic G F x).ne_zero] at hfg }
have hg3 : g = minpoly G F x
exact polynomial.eq_of_monic_of_associated hg (monic G F x) (associated_of_dvd_dvd hg2 $ @of_eval₂ G _ F _ _ _ x g this)
{ exact polynomial.eq_of_monic_of_associated hg (monic G F x) (associated_of_dvd_dvd hg2 $ @of_eval₂ G _ F _ _ _ x g this) }
rwa [← one_mul (minpoly G F x), hg3, mul_left_inj' (monic G F x).ne_zero] at hfg
intros
obtain ⟨f, rfl⟩ := hgf
{ obtain ⟨f, rfl⟩ := hgf, exact (splits_of_splits_mul i hf0 hf).1 }
exact (splits_of_splits_mul i hf0 hf).1
intros
subst h
intros
simp [← cos_angle_mul_norm_mul_norm, h]
intros
rw [←mem_coe, ←set.singleton_subset_iff, ←inter_eq_singleton_orthogonal_projection_fn]
exact set.inter_subset_right _ _
intros
rcases exists_circumradius_eq_of_cospherical_subset h hd hc with ⟨r, hr⟩
rw [hr sx₁ hsx₁, hr sx₂ hsx₂]
intros
ext h
ext h; rw [times_cont_mdiff_map.comp_apply, L_apply, ←eval_at_apply, eval_at_mul, apply_hfdifferential, apply_fdifferential, eval_at_apply]
rw [times_cont_mdiff_map.comp_apply, L_apply, ←eval_at_apply, eval_at_mul, apply_hfdifferential, apply_fdifferential, eval_at_apply]
intros
simp only [chart_at] with mfld_simps
intros
simp [lift_prop_on, lift_prop, lift_prop_at]
intros
rw ← has_mfderiv_within_at_univ at ⊢ h
apply h.congr_of_eventually_eq _ (mem_of_mem_nhds h₁ : _)
rwa nhds_within_univ
intros
apply (ext_chart_continuous_at_symm I x).preimage_mem_nhds
rwa (ext_chart_at I x).left_inv (mem_ext_chart_source _ _)
intros
refine ((times_cont_diff_within_at_local_invariant_prop I I' n).lift_prop_within_at_indep_chart (structure_groupoid.chart_mem_maximal_atlas _ x) hx (structure_groupoid.chart_mem_maximal_atlas _ y) hy).trans _
rw [times_cont_diff_within_at_prop, iff_eq_eq]
congr' 2
mfld_set_tac
intros
haveI := classical.prop_decidable; simp [card_eq_card_quotient_mul_card_subgroup s]
haveI := classical.prop_decidable
simp [card_eq_card_quotient_mul_card_subgroup s]
intros
rw [lift_spec, ←g.map_mul]; exact f.eq_of_eq hg (by rw [sec_spec', f.to_map.map_mul])
rw [lift_spec, ←g.map_mul]
exact f.eq_of_eq hg (by rw [sec_spec', f.to_map.map_mul])
intros
split
refl
intros x n hxn g
exact general_commutator_containment _ _ hxn (subgroup.mem_top g)
intros
apply minimal_period_eq_prime_pow; rwa is_periodic_pt_mul_iff_pow_eq_one
apply minimal_period_eq_prime_pow
rwa is_periodic_pt_mul_iff_pow_eq_one
rwa is_periodic_pt_mul_iff_pow_eq_one
intros
apply multiplicative.of_add.injective
rw [of_add_nsmul, of_add_zero]
exact pow_card_eq_one
intros
rw [swap_mul_eq_mul_swap, perm.inv_apply_self, perm.inv_apply_self]
intros
simp [cycle_type_def, cycle_factors_finset_eq_empty_iff]
intros
ext j
refine fin.cases _ (λ j, _) j
{ simp }
simp
{ rw [cycle_range_of_gt (fin.succ_pos j), one_apply] }
rw [cycle_range_of_gt (fin.succ_pos j), one_apply]
intros
refine ⟨λ h, _, λ hr, form_perm_eq_of_is_rotated hd hr⟩
rw equiv.perm.ext_iff at h
have hx : x' ∈ (x :: y :: l)
have : x' ∈ {z | form_perm (x :: y :: l) z ≠ z}
{ have : x' ∈ {z | form_perm (x :: y :: l) z ≠ z}, { rw [set.mem_set_of_eq, h x', form_perm_apply_head _ _ _ hd'], simp only [mem_cons_iff, nodup_cons] at hd', push_neg at hd', exact hd'.left.left.symm }, simpa using support_form_perm_le' _ this }
rw [set.mem_set_of_eq, h x', form_perm_apply_head _ _ _ hd']
{ rw [set.mem_set_of_eq, h x', form_perm_apply_head _ _ _ hd'], simp only [mem_cons_iff, nodup_cons] at hd', push_neg at hd', exact hd'.left.left.symm }
simp only [mem_cons_iff, nodup_cons] at hd'
push_neg at hd'
exact hd'.left.left.symm
simpa using support_form_perm_le' _ this
obtain ⟨n, hn, hx'⟩ := nth_le_of_mem hx
have hl : (x :: y :: l).length = (x' :: y' :: l').length
rw [←erase_dup_eq_self.mpr hd, ←erase_dup_eq_self.mpr hd', ←card_to_finset, ←card_to_finset]
{ rw [←erase_dup_eq_self.mpr hd, ←erase_dup_eq_self.mpr hd', ←card_to_finset, ←card_to_finset], refine congr_arg finset.card _, rw [←finset.coe_inj, ←support_form_perm_of_nodup' _ hd (by simp), ←support_form_perm_of_nodup' _ hd' (by simp)], simp only [h] }
refine congr_arg finset.card _
rw [←finset.coe_inj, ←support_form_perm_of_nodup' _ hd (by simp), ←support_form_perm_of_nodup' _ hd' (by simp)]
simp only [h]
use n
apply list.ext_le
{ rw [length_rotate, hl] }
rw [length_rotate, hl]
intros k hk hk'
{ intros k hk hk', rw nth_le_rotate, induction k with k IH, { simp_rw [nat.zero_add, nat.mod_eq_of_lt hn], simpa }, { have : k.succ = (k + 1) % (x' :: y' :: l').length, { rw [←nat.succ_eq_add_one, nat.mod_eq_of_lt hk'] }, simp_rw this, rw [←form_perm_apply_nth_le _ hd' k (k.lt_succ_self.trans hk'), ←IH (k.lt_succ_self.trans hk), ←h, form_perm_apply_nth_le _ hd], congr' 1, have h1 : 1 = 1 % (x' :: y' :: l').length := by simp, rw [hl, nat.mod_eq_of_lt hk', h1, ←nat.add_mod, nat.succ_add] } }
rw nth_le_rotate
induction k with k IH
simp_rw [nat.zero_add, nat.mod_eq_of_lt hn]
{ simp_rw [nat.zero_add, nat.mod_eq_of_lt hn], simpa }
simpa
have : k.succ = (k + 1) % (x' :: y' :: l').length
{ have : k.succ = (k + 1) % (x' :: y' :: l').length, { rw [←nat.succ_eq_add_one, nat.mod_eq_of_lt hk'] }, simp_rw this, rw [←form_perm_apply_nth_le _ hd' k (k.lt_succ_self.trans hk'), ←IH (k.lt_succ_self.trans hk), ←h, form_perm_apply_nth_le _ hd], congr' 1, have h1 : 1 = 1 % (x' :: y' :: l').length := by simp, rw [hl, nat.mod_eq_of_lt hk', h1, ←nat.add_mod, nat.succ_add] }
{ rw [←nat.succ_eq_add_one, nat.mod_eq_of_lt hk'] }
rw [←nat.succ_eq_add_one, nat.mod_eq_of_lt hk']
simp_rw this
rw [←form_perm_apply_nth_le _ hd' k (k.lt_succ_self.trans hk'), ←IH (k.lt_succ_self.trans hk), ←h, form_perm_apply_nth_le _ hd]
congr' 1
have h1 : 1 = 1 % (x' :: y' :: l').length := by simp
rw [hl, nat.mod_eq_of_lt hk', h1, ←nat.add_mod, nat.succ_add]
intros
ext
ext; simp
simp
simp
intros
induction n with n ih
{ exact derived_series_one _ }
exact derived_series_one _
rw [derived_series_succ, ih]
cases (commutator.normal G).eq_bot_or_eq_top with h h
cases (commutator.normal G).eq_bot_or_eq_top with h h; simp [h]
simp [h]
simp [h]
intros
classical
apply card_order_of_eq_totient_aux₂ (λ n, is_cyclic.card_pow_eq_one_le) hd
intros
rw [f.mem_ker, f.map_mul, f.map_inv, inv_mul_eq_one, eq_comm]
intros
convert H.bot_or_nontrivial
rw nontrivial_iff_exists_ne_one
intros
simpa only [coe_pow] using ((⟨x, hx⟩ : S) ^ n).coe_prop
intros
simp [line_map_apply_module', smul_sub, sub_smul]
simp [line_map_apply_module', smul_sub, sub_smul]; abel
abel
intros
split
intro hs
{ intro hs, have h := affine_independent.exists_mem_inter_of_exists_mem_inter_affine_span ha hs (mem_affine_span k (set.mem_image_of_mem _ (set.mem_singleton _))), rwa [←set.nonempty_def, set.inter_singleton_nonempty] at h }
have h := affine_independent.exists_mem_inter_of_exists_mem_inter_affine_span ha hs (mem_affine_span k (set.mem_image_of_mem _ (set.mem_singleton _)))
rwa [←set.nonempty_def, set.inter_singleton_nonempty] at h
exact λ h, mem_affine_span k (set.mem_image_of_mem p h)
{ exact λ h, mem_affine_span k (set.mem_image_of_mem p h) }
intros
simp only [line_map_apply_module]
rw [← le_sub_iff_add_le, add_sub_assoc, ← sub_le_iff_le_add', ← sub_smul, ← sub_smul, sub_sub_sub_cancel_left, smul_le_smul_iff_of_pos (sub_pos.2 h)]
apply_instance
intros
simp_rw [←multilinear_map.dom_coprod'_apply, multilinear_map.alternatization_coe]
simp_rw [tensor_product.sum_tmul, tensor_product.tmul_sum, linear_map.map_sum, ←tensor_product.smul_tmul', tensor_product.tmul_smul, linear_map.map_smul_of_tower]
intros
rw complete_lattice.is_compact_element_iff_le_of_directed_Sup_le
intros d hemp hdir hsup
have : x ∈ Sup d
from (set_like.le_def.mp hsup) (mem_span_singleton_self x)
have : x ∈ Sup d
from (set_like.le_def.mp hsup) (mem_span_singleton_self x)
have : x ∈ Sup d
from (set_like.le_def.mp hsup) (mem_span_singleton_self x)
obtain ⟨y, ⟨hyd, hxy⟩⟩ := (mem_Sup_of_directed hemp hdir).mp this
exact ⟨y, ⟨hyd, by simpa only [span_le, singleton_subset_iff]⟩⟩
intros
rw [restrict_eq_cod_restrict_dom_restrict, ker_cod_restrict]
intros
have h₁ : f.comp (0 : f.ker →ₗ[R] M) = 0 := comp_zero _
rw [←submodule.range_subtype f.ker, ←h 0 f.ker.subtype (eq.trans h₁ (comp_ker_subtype f).symm)]
exact range_zero
intros
rw [sub_eq_add_neg, sub_eq_add_neg, add_right, neg_right]
intros
{ ext, refl }
ext
refl
intros
simp only [bilin_form.comp_right, bilin_form.to_matrix_comp b b, to_matrix_id, transpose_one, matrix.one_mul]
intros
convert reverse.commutes (1 : R); simp
convert reverse.commutes (1 : R)
simp
simp
simp
simp
intros
apply is_unit_det_of_left_inverse
simpa using (linear_map.to_matrix_comp v v' v f.symm f).symm
intros
rw [← mem_bot R, ← b.repr.ker, mem_ker, linear_equiv.coe_coe]
apply finsupp.ext
intro b
rw [← to_dual_eq_repr, a]
refl
intros
ext φ
split
split; intro hφ
intro hφ
rw mem_ker at hφ
{ rw mem_ker at hφ, rw submodule.mem_dual_annihilator, rintro y ⟨x, rfl⟩, rw [← dual_map_apply, hφ, zero_apply] }
rw submodule.mem_dual_annihilator
rintro y ⟨x, rfl⟩
rw [← dual_map_apply, hφ, zero_apply]
intro hφ
ext x
{ ext x, rw dual_map_apply, rw submodule.mem_dual_annihilator at hφ, exact hφ (f x) ⟨x, rfl⟩ }
rw dual_map_apply
rw submodule.mem_dual_annihilator at hφ
exact hφ (f x) ⟨x, rfl⟩
intros
{ unfold finrank, simp [dim_top] }
unfold finrank
simp [dim_top]
intros
rw [range_total, subtype.range_coe_subtype, set.set_of_mem_eq]
intros
classical
refine ⟨⟨finset.univ.image b, _⟩⟩
simp only [set.image_univ, finset.coe_univ, finset.coe_image, basis.span_eq]
intros
rw [quotient_quotient_equiv_quotient_aux_mk, mapq_apply, linear_map.id_apply]
intros
simp [fintype.linear_independent_iff, linear_map.ker_eq_bot', funext_iff]
intros
have h' : v x ∈ submodule.span R (v '' {x})
rw set.image_singleton
{ rw set.image_singleton, exact mem_span_singleton_self (v x), }
exact mem_span_singleton_self (v x)
intro w
apply linear_independent.ne_zero x hv
refine disjoint_def.1 (hv.disjoint_span_image _) (v x) h' w
simpa using h
intros
unfold matrix.charpoly
rw [charmatrix_reindex, matrix.det_reindex_self]
intros
rw [←matrix.mul_assoc, ←matrix.mul_assoc, det_mul, det_mul_comm M N, ←det_mul]
intros
rw det_apply'
refine (finset.sum_eq_single 1 _ _).trans _
intros σ h1 h2
{ intros σ h1 h2, cases not_forall.1 (mt equiv.ext h2) with x h3, convert mul_zero _, apply finset.prod_eq_zero, { change x ∈ _, simp }, exact if_neg h3 }
cases not_forall.1 (mt equiv.ext h2) with x h3
convert mul_zero _
apply finset.prod_eq_zero
{ change x ∈ _, simp }
change x ∈ _
simp
exact if_neg h3
{ simp }
simp
{ simp }
simp
intros
refine left_inv_eq_left_inv (mul_nonsing_inv _ h') _
rw h
refine mul_nonsing_inv _ _
rwa [←is_unit_nonsing_inv_det_iff, ←h, is_unit_nonsing_inv_det_iff]
intros
rw [linear_map.to_matrix_apply', lmul_apply]
intros
rw curry_fin_finset_symm_apply
congr
ext i
{ ext i, rw [fin_sum_equiv_of_finset_inl, finset.piecewise_eq_of_mem], apply finset.order_emb_of_fin_mem }
rw [fin_sum_equiv_of_finset_inl, finset.piecewise_eq_of_mem]
apply finset.order_emb_of_fin_mem
ext i
{ ext i, rw [fin_sum_equiv_of_finset_inr, finset.piecewise_eq_of_not_mem], exact finset.mem_compl.1 (finset.order_emb_of_fin_mem _ _ _) }
rw [fin_sum_equiv_of_finset_inr, finset.piecewise_eq_of_not_mem]
exact finset.mem_compl.1 (finset.order_emb_of_fin_mem _ _ _)
intros
simp
intros
{ rw [←one_smul R x, ←add_smul, map_smul], norm_num }
rw [←one_smul R x, ←add_smul, map_smul]
norm_num
intros
simp only [map_eq_top_iff p.range_mkq, sup_comm, ker_mkq]
intros
rw smodeq.def at hxy₁ hxy₂ ⊢
{ rw smodeq.def at hxy₁ hxy₂ ⊢, simp_rw [quotient.mk_add, hxy₁, hxy₂] }
simp_rw [quotient.mk_add, hxy₁, hxy₂]
intros
dsimp [tensor_product.lid]
simp
intros
{ have := @imp_not_self (¬a), rwa decidable.not_not at this }
have := @imp_not_self (¬a)
rwa decidable.not_not at this
intros
{ rw ← pi_univ_Ici, exact pi_Ioi_ae_eq_pi_Ici }
rw ← pi_univ_Ici
exact pi_Ioi_ae_eq_pi_Ici
intros
rw [← prod_swap, map_apply measurable_swap hs]
{ rw [← prod_swap, map_apply measurable_swap hs], simp only [prod_apply (measurable_swap hs)], refl }
simp only [prod_apply (measurable_swap hs)]
refl
intros
intros n m hnm x
simp only
refine bsupr_le (λ k hk, _)
have : k ≤ m := le_trans hk hnm
exact le_bsupr k this
intros
rw [restrict_le_restrict_iff s 0, restrict_le_restrict_iff 0 s] at hi' hj'
split
rw [symm_diff_def, set.diff_eq_compl_inter, set.diff_eq_compl_inter, set.sup_eq_union, of_union, le_antisymm (hi'.2 (hi.compl.inter hj) (set.inter_subset_left _ _)) (hj'.1 (hi.compl.inter hj) (set.inter_subset_right _ _)), le_antisymm (hj'.2 (hj.compl.inter hi) (set.inter_subset_left _ _)) (hi'.1 (hj.compl.inter hi) (set.inter_subset_right _ _)), zero_apply, zero_apply, zero_add]
{ rw [symm_diff_def, set.diff_eq_compl_inter, set.diff_eq_compl_inter, set.sup_eq_union, of_union, le_antisymm (hi'.2 (hi.compl.inter hj) (set.inter_subset_left _ _)) (hj'.1 (hi.compl.inter hj) (set.inter_subset_right _ _)), le_antisymm (hj'.2 (hj.compl.inter hi) (set.inter_subset_left _ _)) (hi'.1 (hj.compl.inter hi) (set.inter_subset_right _ _)), zero_apply, zero_apply, zero_add], { exact set.disjoint_of_subset_left (set.inter_subset_left _ _) (set.disjoint_of_subset_right (set.inter_subset_right _ _) (disjoint.comm.1 (is_compl.disjoint is_compl_compl))) }, { exact hj.compl.inter hi }, { exact hi.compl.inter hj } }
exact set.disjoint_of_subset_left (set.inter_subset_left _ _) (set.disjoint_of_subset_right (set.inter_subset_right _ _) (disjoint.comm.1 (is_compl.disjoint is_compl_compl)))
{ exact set.disjoint_of_subset_left (set.inter_subset_left _ _) (set.disjoint_of_subset_right (set.inter_subset_right _ _) (disjoint.comm.1 (is_compl.disjoint is_compl_compl))) }
{ exact hj.compl.inter hi }
exact hj.compl.inter hi
{ exact hi.compl.inter hj }
exact hi.compl.inter hj
rw [symm_diff_def, set.diff_eq_compl_inter, set.diff_eq_compl_inter, compl_compl, compl_compl, set.sup_eq_union, of_union, le_antisymm (hi'.2 (hj.inter hi.compl) (set.inter_subset_right _ _)) (hj'.1 (hj.inter hi.compl) (set.inter_subset_left _ _)), le_antisymm (hj'.2 (hi.inter hj.compl) (set.inter_subset_right _ _)) (hi'.1 (hi.inter hj.compl) (set.inter_subset_left _ _)), zero_apply, zero_apply, zero_add]
{ rw [symm_diff_def, set.diff_eq_compl_inter, set.diff_eq_compl_inter, compl_compl, compl_compl, set.sup_eq_union, of_union, le_antisymm (hi'.2 (hj.inter hi.compl) (set.inter_subset_right _ _)) (hj'.1 (hj.inter hi.compl) (set.inter_subset_left _ _)), le_antisymm (hj'.2 (hi.inter hj.compl) (set.inter_subset_right _ _)) (hi'.1 (hi.inter hj.compl) (set.inter_subset_left _ _)), zero_apply, zero_apply, zero_add], { exact set.disjoint_of_subset_left (set.inter_subset_left _ _) (set.disjoint_of_subset_right (set.inter_subset_right _ _) (is_compl.disjoint is_compl_compl)) }, { exact hj.inter hi.compl }, { exact hi.inter hj.compl } }
exact set.disjoint_of_subset_left (set.inter_subset_left _ _) (set.disjoint_of_subset_right (set.inter_subset_right _ _) (is_compl.disjoint is_compl_compl))
{ exact set.disjoint_of_subset_left (set.inter_subset_left _ _) (set.disjoint_of_subset_right (set.inter_subset_right _ _) (is_compl.disjoint is_compl_compl)) }
{ exact hj.inter hi.compl }
exact hj.inter hi.compl
{ exact hi.inter hj.compl }
exact hi.inter hj.compl
measurability
all_goals { measurability }
intros
rw [← add_subgroup.mem_carrier, Lp_meas_subgroup, set.mem_set_of_eq]
intros
rw [← integrable_mk, mk_coe_fn]
intros
simp_rw [snorm', pi.smul_apply', nnnorm_smul, ennreal.coe_mul]
exact ennreal.lintegral_Lp_mul_le_Lq_mul_Lr hp0_lt hpq hpqr μ hφ.ennnorm hf.ennnorm
intros
rw [norm_def, snorm_congr_ae (coe_fn_smul _ _), snorm_const_smul c, ennreal.to_real_mul, ennreal.coe_to_real, coe_nnnorm, norm_def]
intros
{ ext1 f, exact add_comp_Lp L L' f }
ext1 f
exact add_comp_Lp L L' f
intros
have := edist_approx_on_le hf h₀ x n
rw edist_comm y₀ at this
simp only [edist_nndist, nndist_eq_nnnorm] at this
exact_mod_cast this
intros
simp only [nearest_pt_ind, coe_piecewise, set.piecewise]
{ simp only [nearest_pt_ind, coe_piecewise, set.piecewise], congr, simp }
congr
simp
intros
simpa only [← finset.prod_apply] using s.measurable_prod' hf
intros
rw [integral_congr_ae (ae_eq_of_ae_eq_trim hf.ae_eq_mk), integral_congr_ae hf.ae_eq_mk]
exact integral_trim hm hf.measurable_mk
intros
simp [integrable_on, integrable_zero_measure]
intros
simp only [integral_symm b, integral_of_le h]
intros
simp only [sub_eq_add_neg, neg_mul_eq_neg_mul]
rw [integral_comp_add_mul f (neg_ne_zero.mpr hc) d, integral_symm]
simp only [inv_neg, smul_neg, neg_neg, neg_smul]
intros
simp only [← infi_apply]
{ simp only [← infi_apply], exact (monotone_lintegral μ).map_infi_le }
exact (monotone_lintegral μ).map_infi_le
intros
suffices : is_o (λ s, ∫ x in s, f x ∂μ - (μ s).to_real • b) (λ s, (μ s).to_real) (l.lift' powerset)
from (this.comp_tendsto hs).congr' (hsμ.mono $ λ a ha, ha ▸ rfl) hsμ
refine is_o_iff.2 (λ ε ε₀, _)
have : ∀ᶠ s in l.lift' powerset, ∀ᶠ x in μ.ae, x ∈ s → f x ∈ closed_ball b ε := eventually_lift'_powerset_eventually.2 (h.eventually $ closed_ball_mem_nhds _ ε₀)
filter_upwards [hμ.eventually, (hμ.integrable_at_filter_of_tendsto_ae hfm h).eventually, hfm.eventually, this]
simp only [mem_closed_ball, dist_eq_norm]
intros s hμs h_integrable hfm h_norm
rw [← set_integral_const, ← integral_sub h_integrable (integrable_on_const.2 $ or.inr hμs), real.norm_eq_abs, abs_of_nonneg ennreal.to_real_nonneg]
exact norm_set_integral_le_of_norm_le_const_ae' hμs h_norm (hfm.sub ae_measurable_const)
intros
refine measurable_to_nat (λ x, _)
rw [preimage_find_eq_disjointed]
exact measurable_set.disjointed hm _
intros
have := μ.inner_content_Sup_nat (λ i, ⟨U i, hU i⟩)
{ have := μ.inner_content_Sup_nat (λ i, ⟨U i, hU i⟩), rwa [opens.supr_def] at this }
rwa [opens.supr_def] at this
intros
simpa only [nnreal.coe_one, one_mul] using h.holder_on_with.hausdorff_measure_image_le zero_lt_one hd
intros
rw μ.trimmed; refl
rw μ.trimmed
refl
intros
intros U hU r hr
rw [map_apply hf (hB₂ _ hU)] at hr
rcases H (hAB U hU) r hr with ⟨K, hKU, hKc, hK⟩
refine ⟨f '' K, image_subset_iff.2 hKU, hAB' _ hKc, _⟩
rwa [map_apply hf (hB₁ _ $ hAB' _ hKc), f.preimage_image]
intros
refine ⟨s, hs, λ t hst, _, λ t hst, _⟩
refine ⟨s, hs, λ t hst, _, λ t hst, _⟩; by_cases ht : measurable_set t
by_cases ht : measurable_set t
{ exact h₁ t hst ht }
exact h₁ t hst ht
{ exact not_measurable v ht }
exact not_measurable v ht
by_cases ht : measurable_set t
{ exact h₂ t hst ht }
exact h₂ t hst ht
{ exact not_measurable w ht }
exact not_measurable w ht
intros
ext i hi
rw [to_signed_measure_apply_measurable hi, add_apply, ennreal.to_real_add (ne_of_lt (measure_lt_top _ _ )) (ne_of_lt (measure_lt_top _ _)), vector_measure.add_apply, to_signed_measure_apply_measurable hi, to_signed_measure_apply_measurable hi]
apply_instance
all_goals { apply_instance }
apply_instance
intros
by_cases hi₁ : measurable_set i
exact (restrict_le_restrict_iff _ _ hi₁).1 hi₂ hi₁ set.subset.rfl
{ exact (restrict_le_restrict_iff _ _ hi₁).1 hi₂ hi₁ set.subset.rfl }
{ rw v.not_measurable hi₁ }
rw v.not_measurable hi₁
intros
rw [mem_divisors_antidiagonal, mul_comm] at h
simp [h.1, h.2]
intros
intro heq
apply @not_fermat_42 _ _ (c ^ 2) ha hb
rw heq
ring
intros
induction n; simp
{ induction n; simp, }
induction n
simp
simp
intros
rw [← ideal.span_singleton_prime, ← maximal_ideal_eq_span_p]
{ apply_instance }
apply_instance
{ exact_mod_cast hp_prime.1.ne_zero }
exact_mod_cast hp_prime.1.ne_zero
intros
rw multiplicity.pow_dvd_iff_le_multiplicity
{ rw multiplicity.pow_dvd_iff_le_multiplicity, rw padic_val_nat_def (ne_of_gt hn), { rw [nat.cast_add, enat.coe_get], simp only [nat.cast_one, not_le], apply enat.lt_add_one (ne_top_iff_finite.2 (finite_nat_iff.2 ⟨hp.elim.ne_one, hn⟩)) }, { apply_instance } }
rw padic_val_nat_def (ne_of_gt hn)
rw [nat.cast_add, enat.coe_get]
{ rw [nat.cast_add, enat.coe_get], simp only [nat.cast_one, not_le], apply enat.lt_add_one (ne_top_iff_finite.2 (finite_nat_iff.2 ⟨hp.elim.ne_one, hn⟩)) }
simp only [nat.cast_one, not_le]
apply enat.lt_add_one (ne_top_iff_finite.2 (finite_nat_iff.2 ⟨hp.elim.ne_one, hn⟩))
{ apply_instance }
apply_instance
intros
split
intro hg
{ intro hg, ext x : 1, apply ext_of_to_zmod_pow.mp, intro n, show (to_zmod_pow n).comp g x = (to_zmod_pow n).comp g' x, rw hg n }
ext x : 1
apply ext_of_to_zmod_pow.mp
intro n
show (to_zmod_pow n).comp g x = (to_zmod_pow n).comp g' x
rw hg n
{ rintro rfl _, refl }
rintro rfl _
refl
intros
subst x
change nat.gcd 0 (int.nat_abs y) = 1 at hc
rw [nat.gcd_zero_left (int.nat_abs y)] at hc
cases int.nat_abs_eq y with hy hy
{ use [1, 0], rw [hy, hc, int.gcd_zero_right], norm_num }
use [1, 0]
rw [hy, hc, int.gcd_zero_right]
norm_num
{ use [0, 1], rw [hy, hc, int.gcd_zero_left], norm_num }
use [0, 1]
rw [hy, hc, int.gcd_zero_left]
norm_num
intros
induction n; simp *
induction n
simp *
simp *
intros
rw [←norm_eq_one_iff, ←int.coe_nat_inj', int.nat_abs_of_nonneg (norm_nonneg hd z), int.coe_nat_one]
intros
rw [← int.cast_coe_nat, coe_nat_abs_norm]
intros
rcases eq_Sup_atoms b with ⟨s, rfl, hs⟩
exact le_antisymm (Sup_le (λ _, and.right)) (Sup_le_Sup (λ a ha, ⟨hs a ha, le_Sup ha⟩))
intros
simp [lt_iff_le_not_le, pi.le_def] {contextual := tt}
intros
conv_rhs { rw [←sup_inf_sdiff x y, h.eq_bot, bot_sup_eq] }
intros
simp [is_least, lower_bounds_union, or_and_distrib_right, and_comm (a ∈ t), and_assoc]
intros
simpa only [sup_comm] using @sup_Inf_eq α _ b s
intros
rw set.eq_singleton_iff_nonempty_unique_mem
{ rw set.eq_singleton_iff_nonempty_unique_mem, rw Inf_eq_top at h_inf, exact ⟨hne, h_inf⟩, }
rw Inf_eq_top at h_inf
exact ⟨hne, h_inf⟩
intros
by_cases hs : bdd_below s
{ exact is_glb_Inf' hs }
exact is_glb_Inf' hs
{ exfalso, apply hs, use ⊥, intros _ _, exact bot_le }
exfalso
apply hs
use ⊥
intros _ _
exact bot_le
intros
rw [at_top_Ioi_eq, tendsto_comap_iff]
intros
rw filter.eventually_at_bot_prod_self
apply exists_congr
tauto
intros
simp only [← principal_singleton, hl.sup_principal]
intros
by_contradiction H
replace H : ∀ᶠ x in f, ¬ p x
from eventually_of_forall (not_exists.1 H)
exact hp H
intros
simp [comap_ne_bot_iff, frequently_iff, ← exists_and_distrib_left, and.comm]
intros
simpa only [filter.eventually, set_of_forall] using bInter_mem hI
intros
ext
ext; refl
refl
intros
rw [partial_sups_eq_sup_range, finset.sup_eq_supr]
congr
ext a
exact supr_congr_Prop (by rw [finset.mem_range, nat.lt_succ_iff]) (λ _, rfl)
intros
split
split; intro h
intro h
have H1 := congr_arg ((Δ) a) h
{ have H1 := congr_arg ((Δ) a) h, rwa [symm_diff_symm_diff_self, symm_diff_symm_diff_self] at H1, }
rwa [symm_diff_symm_diff_self, symm_diff_symm_diff_self] at H1
intro h
{ rw h, }
rw h
intros
rw [is_artinian_ring_iff, is_artinian_iff_well_founded] at H ⊢
exact order_embedding.well_founded (ideal.order_embedding_of_surjective f hf) H
intros
{ rw is_coprime_comm, exact h.symm.add_mul_left_left z }
rw is_coprime_comm
exact h.symm.add_mul_left_left z
intros
refine or_iff_not_imp_left.2 (λ h', _)
apply is_coprime_of_dvd
rintro ⟨rfl, rfl⟩
{ unfreezingI { rintro ⟨rfl, rfl⟩ }, simpa using h }
unfreezingI { rintro ⟨rfl, rfl⟩ }
simpa using h
rintro z nu nz ⟨w, rfl⟩ dy
unfreezingI { rintro z nu nz ⟨w, rfl⟩ dy }
{ unfreezingI { rintro z nu nz ⟨w, rfl⟩ dy }, refine h' (dvd_trans _ dy), simpa using mul_dvd_mul_left z (is_unit_iff_dvd_one.1 $ (of_irreducible_mul h).resolve_left nu) }
refine h' (dvd_trans _ dy)
simpa using mul_dvd_mul_left z (is_unit_iff_dvd_one.1 $ (of_irreducible_mul h).resolve_left nu)
intros
rw (show a * c - b * d = (a - b) * c + b * (c - d), by {rw [sub_mul, mul_sub], abel})
exact I.add_mem (I.mul_mem_right _ h1) (I.mul_mem_left _ h2)
intros
refine ⟨⟨comap_ne_top _ H.1.1, λ J hJ, _⟩⟩
suffices : map f J = ⊤
replace this := congr_arg (comap f) this
{ replace this := congr_arg (comap f) this, rw [comap_top, comap_map_of_surjective _ hf, eq_top_iff] at this, rw eq_top_iff, exact le_trans this (sup_le (le_of_eq rfl) (le_trans (comap_mono (bot_le)) (le_of_lt hJ))) }
rw [comap_top, comap_map_of_surjective _ hf, eq_top_iff] at this
rw eq_top_iff
exact le_trans this (sup_le (le_of_eq rfl) (le_trans (comap_mono (bot_le)) (le_of_lt hJ)))
refine H.1.2 (map f J) (lt_of_le_of_ne (le_map_of_comap_le_of_surjective _ hf (le_of_lt hJ)) (λ h, ne_of_lt hJ (trans (congr_arg (comap f) h) _)))
rw [comap_map_of_surjective _ hf, sup_eq_left]
exact le_trans (comap_mono bot_le) (le_of_lt hJ)
intros
rw ideal.span_singleton_eq_span_singleton
{ rw ideal.span_singleton_eq_span_singleton, exact (associated_nat_abs _).symm }
exact (associated_nat_abs _).symm
intros
rcases h with ⟨p, ⟨hp, hp'⟩⟩
refine ⟨p.map (algebra_map R A), ⟨monic_map (algebra_map R A) hp, _⟩⟩
rw [is_scalar_tower.algebra_map_eq R A B, ← eval₂_map] at hp'
exact hp'
intros
refine is_jacobson_iff.trans ⟨λ h I hI, h I (is_prime.radical hI), _⟩
refine λ h I hI, le_antisymm (λ x hx, _) (λ x hx, mem_Inf.mpr (λ _ hJ, hJ.left hx))
rw [← hI, radical_eq_Inf I, mem_Inf]
intros P hP
rw set.mem_set_of_eq at hP
erw mem_Inf at hx
erw [← h P hP.right, mem_Inf]
exact λ J hJ, hx ⟨le_trans hP.left hJ.left, hJ.right⟩
intros
rw [algebra.smul_def, algebra.smul_def, ring_hom.map_mul, map_eq]
intros
have hx0 : x ≠ 0 := mt (by { rintro rfl, rw zero_mul }) hxy0
have hy0 : y ≠ 0 := mt (by { rintro rfl, rw mul_zero }) hxy0
obtain ⟨r, rfl⟩ := ideal.quotient.mk_surjective x
obtain ⟨s, rfl⟩ := ideal.quotient.mk_surjective y
rw ← ring_hom.map_mul at hxy0 ⊢
rw [pre_val_mk hx0, pre_val_mk hy0, pre_val_mk hxy0, ring_hom.map_mul, v.map_mul]
intros
simp only [of_subring, coeff_monomial, finset_sum_coeff, mem_support_iff, finset.sum_ite_eq', ite_eq_right_iff, ne.def, ite_not, not_not, ite_eq_left_iff]
assume h
rw h
refl
intros
simp only [int.coe_nat_eq_zero, bernstein_polynomial.iterate_derivative_at_0, ne.def, nat.cast_eq_zero]
simp only [←pochhammer_eval_cast]
norm_cast
apply ne_of_gt
obtain rfl|h' := nat.eq_zero_or_pos ν
{ simp, }
simp
rw ← nat.succ_pred_eq_of_pos h' at h
{ rw ← nat.succ_pred_eq_of_pos h' at h, exact pochhammer_pos _ _ (nat.sub_pos_of_lt (nat.lt_of_succ_le h)) }
exact pochhammer_pos _ _ (nat.sub_pos_of_lt (nat.lt_of_succ_le h))
intros
by_cases h0 : r = 0
simp [h0]
{ simp [h0] }
rw content
rw content
rw ← finset.gcd_mul_left
refine congr (congr rfl _) _; ext; simp [h0, mem_support_iff]
refine congr (congr rfl _) _; ext
refine congr (congr rfl _) _
ext
simp [h0, mem_support_iff]
ext
simp [h0, mem_support_iff]
intros
induction m with m ih
{ simp, }
simp
rw [pochhammer_succ_right, polynomial.mul_X_add_nat_cast_comp, ←mul_assoc, ih, nat.succ_eq_add_one, ←add_assoc, pochhammer_succ_right, nat.cast_add, add_assoc]
{ rw [pochhammer_succ_right, polynomial.mul_X_add_nat_cast_comp, ←mul_assoc, ih, nat.succ_eq_add_one, ←add_assoc, pochhammer_succ_right, nat.cast_add, add_assoc], }
intros
rw mem_span_pow'
split
split; { rintros ⟨f, h, hy⟩, refine ⟨f, _, hy⟩, by_cases hf : f = 0, { simp only [hf, nat_degree_zero, degree_zero] at h ⊢, exact lt_of_le_of_ne (nat.zero_le d) hd.symm <|> exact with_bot.bot_lt_coe d }, simpa only [degree_eq_nat_degree hf, with_bot.coe_lt_coe] using h }
{ rintros ⟨f, h, hy⟩, refine ⟨f, _, hy⟩, by_cases hf : f = 0, { simp only [hf, nat_degree_zero, degree_zero] at h ⊢, exact lt_of_le_of_ne (nat.zero_le d) hd.symm <|> exact with_bot.bot_lt_coe d }, simpa only [degree_eq_nat_degree hf, with_bot.coe_lt_coe] using h }
{ rintros ⟨f, h, hy⟩, refine ⟨f, _, hy⟩, by_cases hf : f = 0, { simp only [hf, nat_degree_zero, degree_zero] at h ⊢, exact lt_of_le_of_ne (nat.zero_le d) hd.symm <|> exact with_bot.bot_lt_coe d }, simpa only [degree_eq_nat_degree hf, with_bot.coe_lt_coe] using h }
rintros ⟨f, h, hy⟩
refine ⟨f, _, hy⟩
by_cases hf : f = 0
simp only [hf, nat_degree_zero, degree_zero] at h ⊢
{ simp only [hf, nat_degree_zero, degree_zero] at h ⊢, exact lt_of_le_of_ne (nat.zero_le d) hd.symm <|> exact with_bot.bot_lt_coe d }
exact with_bot.bot_lt_coe d
exact lt_of_le_of_ne (nat.zero_le d) hd.symm
simpa only [degree_eq_nat_degree hf, with_bot.coe_lt_coe] using h
intros
rw [← pow_one (X : power_series R), X_pow_dvd_iff, ← coeff_zero_eq_constant_coeff_apply]
split
split; intro h
intro h
{ exact h 0 zero_lt_one }
exact h 0 zero_lt_one
intro h
intros m hm
{ intros m hm, rwa nat.eq_zero_of_le_zero (nat.le_of_succ_le_succ hm) }
rwa nat.eq_zero_of_le_zero (nat.le_of_succ_le_succ hm)
intros
{ ext, simp [base_change_eq_ltensor], }
ext
simp [base_change_eq_ltensor]
intros
haveI := classical.dec_eq ι
haveI := classical.dec_eq κ
rw [trace_eq_matrix_trace (b.smul c), trace_eq_matrix_trace b, trace_eq_matrix_trace c, matrix.trace_apply, matrix.trace_apply, matrix.trace_apply, ← finset.univ_product_univ, finset.sum_product]
refine finset.sum_congr rfl (λ i _, _)
simp only [alg_hom.map_sum, smul_left_mul_matrix, finset.sum_apply, finset.sum_apply i _ (λ y, left_mul_matrix b (left_mul_matrix c x y y))]
intros
induction k with n h
{ rw [zero_nsmul, pow_zero], exact factors_one }
rw [zero_nsmul, pow_zero]
exact factors_one
{ rw [pow_succ, succ_nsmul, factors_mul, h] }
rw [pow_succ, succ_nsmul, factors_mul, h]
intros
norm_cast
intros
suffices : ¬v (x + y) < max (v x) (v y)
from or_iff_not_imp_right.1 (le_iff_eq_or_lt.1 (v.map_add x y)) this
intro h'
wlog vyx : v y < v x using x y
{ apply lt_or_gt_of_ne h.symm }
apply lt_or_gt_of_ne h.symm
rw max_eq_left_of_lt vyx at h'
{ rw max_eq_left_of_lt vyx at h', apply lt_irrefl (v x), calc v x = v ((x+y) - y) : by simp ... ≤ max (v $ x + y) (v y) : map_sub _ _ _ ... < v x : max_lt h' vyx }
apply lt_irrefl (v x)
calc v x = v ((x+y) - y) : by simp ... ≤ max (v $ x + y) (v y) : map_sub _ _ _ ... < v x : max_lt h' vyx
apply this h.symm
{ apply this h.symm, rwa [add_comm, max_comm] at h' }
rwa [add_comm, max_comm] at h'
intros
map_fun_tac
intros
{ rw [frobenius_poly_aux, ← fin.sum_univ_eq_sum_range] }
rw [frobenius_poly_aux, ← fin.sum_univ_eq_sum_range]
intros
unfreezingI { obtain ⟨φ, hf⟩ := hf, obtain ⟨ψ, hg⟩ := hg }
obtain ⟨φ, hf⟩ := hf
obtain ⟨ψ, hg⟩ := hg
use (λ n, bind₁ φ (ψ n))
intros
simp only [aeval_bind₁, function.comp, hg, hf]
intros
have inj : function.injective (int.cast_ring_hom ℚ)
{ intros m n, exact int.cast_inj.mp, }
intros m n
exact int.cast_inj.mp
apply inj
rw [← constant_coeff_map, map_witt_structure_int, constant_coeff_witt_structure_rat, ring_hom.map_zero]
rw [constant_coeff_map, h, ring_hom.map_zero]
intros
rw [verschiebung_fun, coeff_mk]
intros
{ rw [sUnion_eq_Union], apply mk_Union_le }
rw [sUnion_eq_Union]
apply mk_Union_le
intros
by_cases ha : a = 0
simp [ha, zero_power_le]
exact le_trans (power_le_power_left ha h) (le_max_left _ _)
intros
induction n; simp [pow_succ', -_root_.add_comm, power_add, *]
induction n
simp [pow_succ', -_root_.add_comm, power_add, *]
simp [pow_succ', -_root_.add_comm, power_add, *]
simpa only [card_type, card_univ] using congr_arg card type_cardinal
intros
apply le_antisymm
apply le_trans (power_le_power_right $ le_of_lt $ cantor c)
{ apply le_trans (power_le_power_right $ le_of_lt $ cantor c), rw [← power_mul, mul_eq_self h] }
rw [← power_mul, mul_eq_self h]
{ convert power_le_power_right (le_trans (le_of_lt $ nat_lt_omega 2) h), apply nat.cast_two.symm }
convert power_le_power_right (le_trans (le_of_lt $ nat_lt_omega 2) h)
apply nat.cast_two.symm
intros
simp [← bit1_zero]
intros
have k : _root_.infinite (range f)
rw infinite_coe_iff
{ rw infinite_coe_iff, apply mt (union_finset_finite_of_range_finite f), rw w, exact infinite_univ, }
apply mt (union_finset_finite_of_range_finite f)
rw w
exact infinite_univ
by_contradiction h
simp only [not_le] at h
let u : Π b, ∃ a, b ∈ f a := λ b, by simpa using (w.ge : _) (set.mem_univ b)
let u' : β → range f := λ b, ⟨f (u b).some, by simp⟩
have v' : ∀ a, u' ⁻¹' {⟨f a, by simp⟩} ≤ f a
rintros a p m
begin rintros a p m, simp at m, rw ←m, apply (λ b, (u b).some_spec), end
simp at m
rw ←m
apply (λ b, (u b).some_spec)
obtain ⟨⟨-, ⟨a, rfl⟩⟩, p⟩ := exists_infinite_fiber u' h k
exact (@infinite.of_injective _ _ p (inclusion (v' a)) (inclusion_injective _)).false
intros
simpa only [zero_add] using add_le_add_right (ordinal.zero_le b) a
intros
rw lt_def
dsimp
simp [forall_pempty, exists_pempty]
intros
rw two_nsmul
apply quotient.sound
exact pgame.add_pow_half_succ_self_eq_pow_half
intros
rw [mul_lt_mul_left, ←ha, ←hb, ←mul_assoc, ←mul_assoc, mul_comm bd, mul_lt_mul_left]
exact mul_pos had hbd
exact one_div_pos.2 hgcd
intros
cases t
simp only [mul, mul_add, add_mul, list.length_map, coeffs.val, coeffs.val_between_map_mul, val, list.map]
intros
cc
intros
cc
intros
rw ← nhds_within_univ
exact tendsto_nhds_within_mono_right (subset_univ _) (tendsto_floor_left n)
intros
rw [show f = f⁻¹⁻¹, by { ext, simp }]
apply filter.tendsto.inv_tendsto_zero
apply tendsto_nhds_within_of_tendsto_nhds_of_eventually_within _ (summable.tendsto_at_top_zero hf)
rw eventually_iff_exists_mem
refine ⟨set.Ioi 0, Ioi_mem_at_top _, λ _ _, _⟩
rw [set.mem_Ioi, inv_eq_one_div, one_div, pi.inv_apply, _root_.inv_pos]
exact hf' _
intros
cases t.nonempty_encodable
{ cases t.nonempty_encodable, rw [supr_subtype'], convert rel_supr_tsum m m0 R m_supr _, rw [← finset.tsum_subtype], assumption }
rw [supr_subtype']
convert rel_supr_tsum m m0 R m_supr _
rw [← finset.tsum_subtype]
assumption
intros
convert @mem_nhds_within_Ici_iff_exists_Icc_subset' (order_dual α) _ _ _ _ _ _ _
simp_rw (show ∀ u : order_dual α, @Icc (order_dual α) _ a u = @Icc α _ u a, from λ u, dual_Icc)
refl
intros
rw [← map_coe_Ioi_at_bot, tendsto_map'_iff]
intros
split
split; intro h
intro h
{ exact h.comp hg }
exact h.comp hg
intro h
rcases tendsto_of_monotone hf with h' | ⟨l', hl'⟩
{ rcases tendsto_of_monotone hf with h' | ⟨l', hl'⟩, { exact (not_tendsto_at_top_of_tendsto_nhds h (h'.comp hg)).elim }, { rwa tendsto_nhds_unique h (hl'.comp hg) } }
{ exact (not_tendsto_at_top_of_tendsto_nhds h (h'.comp hg)).elim }
exact (not_tendsto_at_top_of_tendsto_nhds h (h'.comp hg)).elim
{ rwa tendsto_nhds_unique h (hl'.comp hg) }
rwa tendsto_nhds_unique h (hl'.comp hg)
intros
simp only [continuous_within_at, nhds_within_Ico_eq_nhds_within_Iio h]
intros
have : is_topological_basis (⋃ i, image (coe : U i → α) '' (countable_basis (U i)))
from is_topological_basis_of_cover Uo hc (λ i, is_basis_countable_basis (U i))
exact this.second_countable_topology (countable_Union $ λ i, (countable_countable_basis _).image _)
intros
rw frontier_eq_inter_compl_interior
simp only [compl_inter, compl_compl]
intros
tactic.unfreeze_local_instances
by_cases h : nonempty J
{ apply nonempty_sections_of_fintype_cofiltered_system, }
apply nonempty_sections_of_fintype_cofiltered_system
rw not_nonempty_iff_imp_false at h
{ rw not_nonempty_iff_imp_false at h, exact ⟨λ j, false.elim (h j.unop), λ j, false.elim (h j.unop)⟩, }
exact ⟨λ j, false.elim (h j.unop), λ j, false.elim (h j.unop)⟩
intros
tidy
intros
simpa [nhds_prod_eq, (nhds_basis_opens x).prod_self.mem_iff, and.assoc, and.left_comm] using hx
intros
{ cases f, cases g, congr, ext, exact H x, }
cases f
cases g
congr
ext
exact H x
apply eq_top_iff.mpr
rintros f -
refine filter.frequently.mem_closure _
refine filter.tendsto.frequently (bernstein_approximation_uniform f) _
apply frequently_of_forall
intro n
simp only [set_like.mem_coe]
apply subalgebra.sum_mem
rintro n -
apply subalgebra.smul_mem
dsimp [bernstein, polynomial_functions]
simp
intros
rw [comap_principal, set.preimage_image_eq _ subtype.coe_injective]
intros
simpa only [exists_prop, and_assoc, and_comm] using (nhds_within_basis_open a s).mem_iff
intros
simp
intros
refine subset.antisymm_iff.mpr ⟨(λ x hx, _), (λ x hx, mem_inter _ _)⟩
rw [←e.target_eq] at hx
{ rw [←e.target_eq] at hx, simp only [mem_inter_iff, mem_preimage, e.proj_symm_apply hx.2] at hx, simp only [mem_inter_eq, and_true, mem_univ, mem_prod], exact ⟨hx.1, e.mem_target.mp hx.2⟩, }
simp only [mem_inter_iff, mem_preimage, e.proj_symm_apply hx.2] at hx
simp only [mem_inter_eq, and_true, mem_univ, mem_prod]
exact ⟨hx.1, e.mem_target.mp hx.2⟩
simp only [mem_inter_eq, and_true, mem_univ, mem_prod, e.mem_target.symm] at hx
{ simp only [mem_inter_eq, and_true, mem_univ, mem_prod, e.mem_target.symm] at hx, simp only [mem_preimage, e.proj_symm_apply hx.2], exact hx.1, }
simp only [mem_preimage, e.proj_symm_apply hx.2]
exact hx.1
rw [←inter_univ univ, ←prod_inter_prod, mem_inter_eq] at hx
{ rw [←inter_univ univ, ←prod_inter_prod, mem_inter_eq] at hx, exact hx.2, }
exact hx.2
intros
simp only [metric.diam, emetric.diam_closure]
intros
{ apply tendsto.mul_const hm, simp [ha] }
apply tendsto.mul_const hm
simp [ha]
intros
simp only [nhds_top', mem_Ioi, tendsto_infi, tendsto_principal]
intros
simp [mem_closure_iff_nhds_basis nhds_basis_ball, real.dist_eq]
intros
rw (of_set s hs).trans_of_set hs'
ext
ext; simp [hs'.interior_eq]
simp [hs'.interior_eq]
simp [hs'.interior_eq]
simp [hs'.interior_eq]
intros
{ ext x, rw [set.mem_preimage, ← closure_induced, hf.induced] }
ext x
rw [set.mem_preimage, ← closure_induced, hf.induced]
intros
{ rw [nndist_pi_def], exact finset.le_sup (finset.mem_univ b) }
rw [nndist_pi_def]
exact finset.le_sup (finset.mem_univ b)
intros
simpa [infi_subtype] using @completion.uniformity_dist' α _
intros
have := not_congr (@diam_eq_zero_iff _ _ s)
dunfold set.subsingleton at this
push_neg at this
simpa only [pos_iff_ne_zero, exists_prop] using this
intros
rw Hausdorff_edist_def
simp only [sup_le_iff, supr_le_iff]
split
show ∀x ∈ s, inf_edist x u ≤ Hausdorff_edist s t + Hausdorff_edist t u
from λx xs, calc inf_edist x u ≤ inf_edist x t + Hausdorff_edist t u : inf_edist_le_inf_edist_add_Hausdorff_edist ... ≤ Hausdorff_edist s t + Hausdorff_edist t u : add_le_add_right (inf_edist_le_Hausdorff_edist_of_mem xs) _
show ∀x ∈ u, inf_edist x s ≤ Hausdorff_edist s t + Hausdorff_edist t u
from λx xu, calc inf_edist x s ≤ inf_edist x t + Hausdorff_edist t s : inf_edist_le_inf_edist_add_Hausdorff_edist ... ≤ Hausdorff_edist u t + Hausdorff_edist t s : add_le_add_right (inf_edist_le_Hausdorff_edist_of_mem xu) _ ... = Hausdorff_edist s t + Hausdorff_edist t u : by simp [Hausdorff_edist_comm, add_comm]
intros
simp [Hausdorff_dist, Hausdorff_edist_image h]
intros
cases (univ : set α).eq_empty_or_nonempty with h h
use (λ_, 0)
{ use (λ_, 0), assume x, exact absurd h (nonempty.ne_empty ⟨x, mem_univ x⟩) }
assume x
exact absurd h (nonempty.ne_empty ⟨x, mem_univ x⟩)
rcases h with ⟨basepoint⟩
{ rcases h with ⟨basepoint⟩, haveI : inhabited α := ⟨basepoint⟩, have : ∃s:set α, countable s ∧ dense s := exists_countable_dense α, rcases this with ⟨S, ⟨S_countable, S_dense⟩⟩, rcases countable_iff_exists_surjective.1 S_countable with ⟨x, x_range⟩, exact ⟨embedding_of_subset x, embedding_of_subset_isometry x (S_dense.mono x_range)⟩ }
haveI : inhabited α := ⟨basepoint⟩
have : ∃s:set α, countable s ∧ dense s := exists_countable_dense α
rcases this with ⟨S, ⟨S_countable, S_dense⟩⟩
rcases countable_iff_exists_surjective.1 S_countable with ⟨x, x_range⟩
exact ⟨embedding_of_subset x, embedding_of_subset_isometry x (S_dense.mono x_range)⟩
intros
rw [nhds_induced, map_comap_of_surjective hf]
intros
ext
simp only [path.trans, if_t_t, one_div, path.refl_extend]
refl
intros
contrapose! hf
simp only [not_mem_iff_inf_principal_compl, compl_compl, inf_assoc, ← exists_prop] at hf ⊢
exact @hs _ hf inf_le_right
intros
simp [continuous_on, continuous_within_at_iff'_left]
intros
simp [mem_closure_iff_nhds_basis (has_basis_nhds x)]
tauto
intros
assume f hf _
rcases complete_space.complete hf with ⟨x, hx⟩
exact ⟨x, mem_univ x, hx⟩
intros
simp only [CU.lim, approx_of_nmem_U c _ h, csupr_const]
intros
cases b; simp
cases b
simp
simp
intros
have h := int.add_le_add_right h b
rwa [int.sub_add_cancel, int.zero_add] at h
intros
have h := int.add_lt_add_right h c
rwa int.sub_add_cancel at h
intros
rw [sub_eq_add_neg, neg_vsub_eq_vsub_rev, add_comm, vsub_add_vsub_cancel]
intros
simp [bit0, add_smul, smul_add]
intros
split
split; intros h
intros h
rw [← one_mul a, ← lmul_right_apply a 1, h, linear_map.zero_apply]
{ rw [← one_mul a, ← lmul_right_apply a 1, h, linear_map.zero_apply], }
intros h
{ rw h, exact lmul_right_zero_eq_zero, }
rw h
exact lmul_right_zero_eq_zero
intros
simpa only [one_eq_span, span_le, set.singleton_subset_iff]
intros
subst T; exact set.Union_lift_inclusion _ _
subst T
exact set.Union_lift_inclusion _ _
intros
split_ifs
apply prod_eq_one
{ apply prod_eq_one, intros i hi, rw if_pos (h i hi) }
intros i hi
rw if_pos (h i hi)
push_neg at h
{ push_neg at h, rcases h with ⟨i, hi, hq⟩, apply prod_eq_zero hi, rw [if_neg hq] }
rcases h with ⟨i, hi, hq⟩
apply prod_eq_zero hi
rw [if_neg hq]
intros
set s := {x | p x}
have : mul_support (s.mul_indicator f) ⊆ t
rw [set.mul_support_mul_indicator]
{ rw [set.mul_support_mul_indicator], intros x hx, exact (h hx.2).1 hx.1 }
intros x hx
exact (h hx.2).1 hx.1
erw [finprod_mem_def, finprod_eq_prod_of_mul_support_subset _ this]
refine finset.prod_congr rfl (λ x hx, mul_indicator_apply_eq_self.2 $ λ hxs, _)
contrapose! hxs
exact (h hxs).2 hx
intros
letI := classical.dec_eq R; exact classical.by_cases (assume H : ∀ p:ℕ, (p:R) = 0 → p = 0, ⟨0, ⟨λ x, by rw [zero_dvd_iff]; exact ⟨H x, by rintro rfl; refl⟩⟩⟩) (λ H, ⟨nat.find (not_forall.1 H), ⟨λ x, ⟨λ H1, nat.dvd_of_mod_eq_zero (by_contradiction $ λ H2, nat.find_min (not_forall.1 H) (nat.mod_lt x $ nat.pos_of_ne_zero $ not_of_not_imp $ nat.find_spec (not_forall.1 H)) (not_imp_of_and_not ⟨by rwa [← nat.mod_add_div x (nat.find (not_forall.1 H)), nat.cast_add, nat.cast_mul, of_not_not (not_not_of_not_imp $ nat.find_spec (not_forall.1 H)), zero_mul, add_zero] at H1, H2⟩)), λ H1, by rw [← nat.mul_div_cancel' H1, nat.cast_mul, of_not_not (not_not_of_not_imp $ nat.find_spec (not_forall.1 H)), zero_mul]⟩⟩⟩)
letI := classical.dec_eq R
exact classical.by_cases (assume H : ∀ p:ℕ, (p:R) = 0 → p = 0, ⟨0, ⟨λ x, by rw [zero_dvd_iff]; exact ⟨H x, by rintro rfl; refl⟩⟩⟩) (λ H, ⟨nat.find (not_forall.1 H), ⟨λ x, ⟨λ H1, nat.dvd_of_mod_eq_zero (by_contradiction $ λ H2, nat.find_min (not_forall.1 H) (nat.mod_lt x $ nat.pos_of_ne_zero $ not_of_not_imp $ nat.find_spec (not_forall.1 H)) (not_imp_of_and_not ⟨by rwa [← nat.mod_add_div x (nat.find (not_forall.1 H)), nat.cast_add, nat.cast_mul, of_not_not (not_not_of_not_imp $ nat.find_spec (not_forall.1 H)), zero_mul, add_zero] at H1, H2⟩)), λ H1, by rw [← nat.mul_div_cancel' H1, nat.cast_mul, of_not_not (not_not_of_not_imp $ nat.find_spec (not_forall.1 H)), zero_mul]⟩⟩⟩)
intros
obtain ⟨ppredConts, nth_conts_eq, ⟨rfl⟩⟩ : ∃ conts, g.continuants n = conts ∧ conts.b = ppredB
from exists_conts_b_of_denom nth_denom_eq
obtain ⟨predConts, succ_nth_conts_eq, ⟨rfl⟩⟩ : ∃ conts, g.continuants (n + 1) = conts ∧ conts.b = predB
from exists_conts_b_of_denom succ_nth_denom_eq
rw [denom_eq_conts_b, (continuants_recurrence succ_nth_s_eq nth_conts_eq succ_nth_conts_eq)]
intros
cases s_nth_eq : (g.s.nth n); simp [partial_denominators, s_nth_eq]
cases s_nth_eq : (g.s.nth n)
simp [partial_denominators, s_nth_eq]
simp [partial_denominators, s_nth_eq]
intros
by_cases h : b ∈ s
rw [insert_eq_of_mem h, (gcd_eq_right_iff (f b) (s.gcd f) (multiset.normalize_gcd (s.1.map f))).2 (gcd_dvd h)]
{ rw [insert_eq_of_mem h, (gcd_eq_right_iff (f b) (s.gcd f) (multiset.normalize_gcd (s.1.map f))).2 (gcd_dvd h)] ,}
apply fold_insert h
intros
have := (commute.one_right x).geom_sum₂_mul n
rw [one_pow, geom_sum₂_with_one] at this
exact this
intros
rw [sub_eq_add_neg, add_comm _ _]
intros
{ dsimp [bit1], rw [mul_add, mul_bit0, mul_one], }
dsimp [bit1]
rw [mul_add, mul_bit0, mul_one]
intros
simpa only [sq] using abs_mul_self x
intros
{ ext, refl }
ext
refl
intros
rw [mul_comm, mul_div_cancel_of_imp h]
intros
simp [single_map_homological_complex]
intros
rw ←eq_to_hom_comp_d C r r'
apply image_subobject_iso_comp
intros
dsimp [d_next]
simp only [chain_complex.next_nat_zero]
refl
intros
{ ext, simp [image_to_kernel'], }
ext
simp [image_to_kernel']
intros
{ rw le_inf_iff, exact ⟨lie_le_left I J, lie_le_right J I⟩, }
rw le_inf_iff
exact ⟨lie_le_left I J, lie_le_right J I⟩
intros
rw abelian_iff_derived_succ_eq_bot
let s := {k | derived_series_of_ideal R L k I = ⊥}
change Inf s = k + 1 ↔ k + 1 ∈ s ∧ k ∉ s
have hs : ∀ (k₁ k₂ : ℕ), k₁ ≤ k₂ → k₁ ∈ s → k₂ ∈ s
intros k₁ k₂ h₁₂ h₁
{ intros k₁ k₂ h₁₂ h₁, suffices : derived_series_of_ideal R L k₂ I ≤ ⊥, { exact eq_bot_iff.mpr this, }, change derived_series_of_ideal R L k₁ I = ⊥ at h₁, rw ← h₁, exact derived_series_of_ideal_antitone I h₁₂, }
suffices : derived_series_of_ideal R L k₂ I ≤ ⊥
exact eq_bot_iff.mpr this
{ exact eq_bot_iff.mpr this, }
change derived_series_of_ideal R L k₁ I = ⊥ at h₁
rw ← h₁
exact derived_series_of_ideal_antitone I h₁₂
exact nat.Inf_upward_closed_eq_succ_iff hs k
intros
{ ext, rw mem_of_le, refl, }
ext
rw mem_of_le
refl
intros
rw [← lie_submodule.mem_coe_submodule, coe_map_of_surjective h₁, submodule.mem_map] at h₂
obtain ⟨x, hx, rfl⟩ := h₂
use ⟨x, hx⟩
refl
intros
rw [is_weight, lie_hom.coe_zero, zero_weight_space_eq_top_of_nilpotent]
{ rw [is_weight, lie_hom.coe_zero, zero_weight_space_eq_top_of_nilpotent], exact top_ne_bot, }
exact top_ne_bot
intros
simp [add_smul, sub_eq_add_neg]
intros
rcases eq_or_lt_of_le hb with rfl|hb'
{ rcases eq_or_lt_of_le hb with rfl|hb', simp [hc], rwa [div_le_iff hb'] }
simp [hc]
rwa [div_le_iff hb']
intros
simpa using inv_le_of_neg ha hb
intros
simpa only [div_eq_mul_inv] using hf.mul_const (inv_pos.2 hc)
intros
{ rw [← mul_le_mul_iff_left a], simp }
rw [← mul_le_mul_iff_left a]
simp
intros
rw [← mul_lt_mul_iff_right b, inv_mul_cancel_right]
intros
rw [← mul_lt_mul_iff_right b, div_eq_mul_inv, inv_mul_cancel_right]
intros
haveI := @linear_order.decidable_le α _; exact ⟨le_imp_le_of_lt_imp_lt $ λ h', mul_lt_mul_of_neg_left h' h, λ h', decidable.mul_le_mul_of_nonpos_left h' h.le⟩
haveI := @linear_order.decidable_le α _
exact ⟨le_imp_le_of_lt_imp_lt $ λ h', mul_lt_mul_of_neg_left h' h, λ h', decidable.mul_le_mul_of_nonpos_left h' h.le⟩
intros
nontriviality
exact (one_mul (1 : α)) ▸ decidable.mul_lt_mul' ha hb zero_le_one (zero_lt_one.trans_le ha)
intros
rw [bit0, ← two_mul, zero_le_mul_left (zero_lt_two : 0 < (2:α))]
intros
rcases int.even_or_odd n with ⟨k, rfl⟩ | ⟨k, rfl⟩
rcases int.even_or_odd n with ⟨k, rfl⟩ | ⟨k, rfl⟩; have hk : (k : α) * (2 * c) = 2 * k * c := by rw [mul_left_comm, ← mul_assoc]
have hk : (k : α) * (2 * c) = 2 * k * c := by rw [mul_left_comm, ← mul_assoc]
{ simpa [hk, hi] using (h.int_even_mul_periodic k).eq }
simpa [hk, hi] using (h.int_even_mul_periodic k).eq
have hk : (k : α) * (2 * c) = 2 * k * c := by rw [mul_left_comm, ← mul_assoc]
simpa [add_mul, hk, hi] using (h.int_odd_mul_antiperiodic k).eq
{ simpa [add_mul, hk, hi] using (h.int_odd_mul_antiperiodic k).eq }
intros
simp
intros
simp only [← image_smul, mem_image, inv_smul_eq_iff, exists_eq_right]
intros
rw [← leading_coeff_hom_apply, monoid_hom.map_multiset_prod]
{ rw [← leading_coeff_hom_apply, monoid_hom.map_multiset_prod], refl }
refl
intros
refine iff.trans _ is_regular_mul_and_mul_iff
refine ⟨λ ab, ⟨ab, by rwa mul_comm⟩, λ rab, rab.1⟩
intros
rw mul_support_subset_iff'
simp only [mem_Union, not_exists, nmem_mul_support]
exact λ x, finset.prod_eq_one
intros
{ ext x, exact (submodule.gi R R).gc s x.as_ideal }
ext x
exact (submodule.gi R R).gc s x.as_ideal
intros
rw [← as_ideal_le_as_ideal, ← zero_locus_vanishing_ideal_eq_closure, mem_zero_locus, vanishing_ideal_singleton, set_like.coe_subset_coe]
intros
dsimp [δ, σ]
simp only [←X.map_comp, simplex_category.δ_comp_σ_self, X.map_id]
intros
cases (zero_le p.radius).eq_or_lt with h h
{ simp [← h, continuous_on_empty] }
simp [← h, continuous_on_empty]
{ exact (p.has_fpower_series_on_ball h).continuous_on }
exact (p.has_fpower_series_on_ball h).continuous_on
intros
subst n
apply id_apply_one
intros
refine ((h₁.norm_norm.mul_is_O h₂.norm_norm).congr _ _).of_norm_norm
refine ((h₁.norm_norm.mul_is_O h₂.norm_norm).congr _ _).of_norm_norm; by intros; simp only [norm_smul]
intros; simp only [norm_smul]
intros; simp only [norm_smul]
intros
intros
simp only [norm_smul]
simp only [norm_smul]
intros; simp only [norm_smul]
intros; simp only [norm_smul]
intros
intros
simp only [norm_smul]
simp only [norm_smul]
intros
unfold is_o
{ unfold is_o, exact ball_congr (λ c hc, is_O_with_congr (eq.refl c) hf hg) }
exact ball_congr (λ c hc, is_O_with_congr (eq.refl c) hf hg)
intros
unfold is_O_with
apply univ_mem'
intro x
rw [mem_set_of_eq, div_mul_cancel]
rwa [ne.def, norm_eq_zero]
intros
simp [has_deriv_at_filter]
intros
simp_rw [has_deriv_within_at, nhds_within_eq_nhds_within' hu h]
intros
simpa only [sub_eq_add_neg] using hf.neg.const_add c
intros
simp only [← fderiv_within_univ, fderiv_within_const_sub unique_diff_within_at_univ]
intros
refine ⟨h'.dense_of_maps_to f'.continuous hs.1 _, h.continuous_within_at.mem_closure_image hs.2⟩
show submodule.span 𝕜 (tangent_cone_at 𝕜 s x) ≤ (submodule.span 𝕜 (tangent_cone_at 𝕜 (f '' s) (f x))).comap ↑f'
rw [submodule.span_le]
exact h.maps_to_tangent_cone.mono (subset.refl _) submodule.subset_span
intros
{ ext x, simp [iterated_deriv_within] }
ext x
simp [iterated_deriv_within]
intros
have hdf : ∀ x ∈ Ioi a, differentiable_at ℝ f x
from λ x hx, (hdf x hx).differentiable_at (Ioi_mem_nhds hx)
have hdg : ∀ x ∈ Ioi a, differentiable_at ℝ g x
from λ x hx, classical.by_contradiction (λ h, hg' x hx (deriv_zero_of_not_differentiable_at h))
exact has_deriv_at.lhopital_zero_at_top_on_Ioi (λ x hx, (hdf x hx).has_deriv_at) (λ x hx, (hdg x hx).has_deriv_at) hg' hftop hgtop hdiv
intros
rintros y ⟨c, d, ds, ctop, clim⟩
exact ⟨c, d, mem_of_superset ds (λn hn, h hn), ctop, clim⟩
intros
induction n with n IH
{ ext m, simp }
ext m
simp
ext x m
{ ext x m, rw [iterated_fderiv_succ_apply_left, IH], change (fderiv 𝕜 (λ (x : E), (0 : (E [×n]→L[𝕜] F))) x : E → (E [×n]→L[𝕜] F)) (m 0) (tail m) = _, rw fderiv_const, refl }
rw [iterated_fderiv_succ_apply_left, IH]
change (fderiv 𝕜 (λ (x : E), (0 : (E [×n]→L[𝕜] F))) x : E → (E [×n]→L[𝕜] F)) (m 0) (tail m) = _
rw fderiv_const
refl
intros
simpa only [sub_eq_add_neg] using hf.add hg.neg
intros
simp [is_R_or_C.norm_sq, complex.norm_sq]
intros
have A : has_fderiv_at (coe : ℝ → ℂ) of_real_clm z := of_real_clm.has_fderiv_at
have B : has_fderiv_at e ((continuous_linear_map.smul_right 1 e' : ℂ →L[ℂ] ℂ).restrict_scalars ℝ) (of_real_clm z) := h.has_fderiv_at.restrict_scalars ℝ
have C : has_fderiv_at re re_clm (e (of_real_clm z)) := re_clm.has_fderiv_at
simpa using (C.comp z (B.comp z A)).has_deriv_at
intros
rintro z ⟨a, b, ha, hb, hab, rfl⟩
split
calc x = a • x + b • x : by rw [←add_smul, hab, one_smul] ... ≤ a • x + b • y : add_le_add_left (smul_le_smul_of_nonneg h hb) _
calc a • x + b • y ≤ a • y + b • y : add_le_add_right (smul_le_smul_of_nonneg h ha) _ ... = y : by rw [←add_smul, hab, one_smul]
intros
simpa using hs.add_smul_mem zero_mem (by simpa using hx) ht
intros
simpa only [set.finite.coe_to_finset, set.finite.mem_to_finset, exists_prop] using hs.to_finset.convex_hull_eq
intros
refine λ x y hx hy a b ha hb hab, ⟨hf.1 hx.1 hy.1 ha hb hab, _⟩
obtain rfl | ha' := ha.eq_or_lt
rw zero_add at hab
{ rw zero_add at hab, rw [hab, zero_smul, one_smul, zero_add], exact hy.2 }
rw [hab, zero_smul, one_smul, zero_add]
exact hy.2
calc f (a • x + b • y) ≤ a • f x + b • f y : hf.2 hx.1 hy.1 ha hb hab ... < a • r + b • r : add_lt_add_of_lt_of_le (smul_lt_smul_of_pos hx.2 ha') (smul_le_smul_of_nonneg hy.2.le hb) ... = r : convex.combo_self hab _
{ calc f (a • x + b • y) ≤ a • f x + b • f y : hf.2 hx.1 hy.1 ha hb hab ... < a • r + b • r : add_lt_add_of_lt_of_le (smul_lt_smul_of_pos hx.2 ha') (smul_le_smul_of_nonneg hy.2.le hb) ... = r : convex.combo_self hab _ }
intros
rw ←neg_convex_on_iff
refine convex_on_of_slope_mono_adjacent hs (λ x y z hx hz hxy hyz, _)
rw ←neg_le_neg_iff
simp_rw [←neg_div, neg_sub, pi.neg_apply, neg_sub_neg]
exact hf hx hz hxy hyz
intros
rw [norm_add_mul_self, add_right_cancel_iff, add_right_eq_self, mul_eq_zero]
norm_num
intros
simp [disjoint_iff, K.inf_orthogonal_eq_bot]
intros
{ rw [inner_smul_left, conj_of_real, algebra.smul_def], refl }
rw [inner_smul_left, conj_of_real, algebra.smul_def]
refl
intros
split
intros hv i j
{ intros hv i j, split_ifs, { simp [h, inner_self_eq_norm_sq_to_K, hv.1] }, { exact hv.2 h } }
split_ifs
{ simp [h, inner_self_eq_norm_sq_to_K, hv.1] }
simp [h, inner_self_eq_norm_sq_to_K, hv.1]
{ exact hv.2 h }
exact hv.2 h
intros h
{ intros h, split, { intros i, have h' : ∥v i∥ ^ 2 = 1 ^ 2 := by simp [norm_sq_eq_inner, h i i], have h₁ : 0 ≤ ∥v i∥ := norm_nonneg _, have h₂ : (0:ℝ) ≤ 1 := zero_le_one, rwa sq_eq_sq h₁ h₂ at h' }, { intros i j hij, simpa [hij] using h i j } }
split
intros i
{ intros i, have h' : ∥v i∥ ^ 2 = 1 ^ 2 := by simp [norm_sq_eq_inner, h i i], have h₁ : 0 ≤ ∥v i∥ := norm_nonneg _, have h₂ : (0:ℝ) ≤ 1 := zero_le_one, rwa sq_eq_sq h₁ h₂ at h' }
have h' : ∥v i∥ ^ 2 = 1 ^ 2 := by simp [norm_sq_eq_inner, h i i]
have h₁ : 0 ≤ ∥v i∥ := norm_nonneg _
have h₂ : (0:ℝ) ≤ 1 := zero_le_one
rwa sq_eq_sq h₁ h₂ at h'
intros i j hij
{ intros i j hij, simpa [hij] using h i j }
simpa [hij] using h i j
intros
simp only [norm_add_mul_self, norm_sub_mul_self, inner_smul_right, I_mul_re]
{ simp only [norm_add_mul_self, norm_sub_mul_self, inner_smul_right, I_mul_re], ring }
ring
intros
conv_rhs { rw ← complex.isometry_euclidean_proj_eq_self z }
{ conv_rhs { rw ← complex.isometry_euclidean_proj_eq_self z }, simp }
simp
intros
simp [reflection_apply, orthogonal_projection_mem_subspace_orthogonal_complement_eq_zero hv]
intros
rw [dist_comm, dist_homothety_self]
intros
simp only [lipschitz_on_with_iff_dist_le_mul, dist_eq_norm]
intros
simp [metric.mem_closure_iff, dist_eq_norm]
intros
change summable (norm ∘ _)
rw ← exp_series_apply_eq'
exact norm_exp_series_summable_of_mem_ball x hx
intros
obtain ⟨c, hc⟩ : ∃ (c : 𝕜), 1 < ∥c∥ := normed_field.exists_one_lt_norm 𝕜
have A : ∥c∥ < ∥c∥ + 1
linarith
linarith
rcases exists_seq_norm_le_one_le_norm_sub' hc A h with ⟨f, hf⟩
exact ⟨∥c∥ + 1, f, hc.trans A, hf.1, hf.2⟩
intros
replace hyp : ∀ h ∈ j.range, ∃ g, f g = h ∧ ∥g∥ ≤ C*∥h∥
intros h h_in
{ intros h h_in, rcases (j.mem_range _).mp h_in with ⟨k, rfl⟩, rw hj, exact hyp k }
rcases (j.mem_range _).mp h_in with ⟨k, rfl⟩
rw hj
exact hyp k
exact controlled_closure_of_complete hC hε hyp
intros
rw [← tendsto_comap_iff, comap_exp_at_top]
intros
rw div_eq_inv_mul
exact (has_deriv_at_log hx).comp_has_deriv_within_at x hf
intros
rcases even_or_odd' n with ⟨k, (rfl | rfl)⟩
rcases even_or_odd' n with ⟨k, (rfl | rfl)⟩; simp only [integral_sin_pow_even, integral_sin_pow_odd]; refine mul_pos (by norm_num [pi_pos]) (prod_pos (λ n hn, div_pos _ _)); norm_cast; linarith
rcases even_or_odd' n with ⟨k, (rfl | rfl)⟩; simp only [integral_sin_pow_even, integral_sin_pow_odd]; refine mul_pos (by norm_num [pi_pos]) (prod_pos (λ n hn, div_pos _ _)); norm_cast
rcases even_or_odd' n with ⟨k, (rfl | rfl)⟩; simp only [integral_sin_pow_even, integral_sin_pow_odd]; refine mul_pos (by norm_num [pi_pos]) (prod_pos (λ n hn, div_pos _ _))
rcases even_or_odd' n with ⟨k, (rfl | rfl)⟩; simp only [integral_sin_pow_even, integral_sin_pow_odd]
simp only [integral_sin_pow_even, integral_sin_pow_odd]
refine mul_pos (by norm_num [pi_pos]) (prod_pos (λ n hn, div_pos _ _))
norm_cast
linarith
norm_cast
norm_cast
linarith
linarith
simp only [integral_sin_pow_even, integral_sin_pow_odd]
refine mul_pos (by norm_num [pi_pos]) (prod_pos (λ n hn, div_pos _ _))
norm_cast
norm_cast
linarith
linarith
norm_cast
linarith
intros
convert (hf.has_fderiv_within_at.rpow hg.has_fderiv_within_at h).has_deriv_within_at using 1
dsimp
ring
intros
{ rw ← one_rpow z, exact rpow_lt_rpow hx1 hx2 hz }
rw ← one_rpow z
exact rpow_lt_rpow hx1 hx2 hz
intros
simpa using cpow_neg x 1
simp [two_mul, sin_add]
simpa only [cos_zero, cos_pi] using intermediate_value_Icc' pi_pos.le continuous_cos.continuous_on
intros
have h : (exp (θ * I) + exp (-θ * I)) / 2 = 0 ↔ exp (2 * θ * I) = -1
rw [@div_eq_iff _ _ (exp (θ * I) + exp (-θ * I)) 2 0 two_ne_zero', zero_mul, add_eq_zero_iff_eq_neg, neg_eq_neg_one_mul, ← div_eq_iff (exp_ne_zero _), ← exp_sub]
{ rw [@div_eq_iff _ _ (exp (θ * I) + exp (-θ * I)) 2 0 two_ne_zero', zero_mul, add_eq_zero_iff_eq_neg, neg_eq_neg_one_mul, ← div_eq_iff (exp_ne_zero _), ← exp_sub], field_simp only, congr' 3, ring }
congr' 3
field_simp only
ring
rw [cos, h, ← exp_pi_mul_I, exp_eq_exp_iff_exists_int, mul_right_comm]
refine exists_congr (λ x, _)
refine (iff_of_eq $ congr_arg _ _).trans (mul_right_inj' $ mul_ne_zero two_ne_zero' I_ne_zero)
ring
simp [arccos]
intros
apply squeeze_zero_norm' (eventually_norm_pow_le x)
exact tendsto_pow_at_top_nhds_0_of_lt_1 (norm_nonneg _) h
intros
by_cases hr₀ : 0 ≤ r
rw eventually_at_top at h
{ rw eventually_at_top at h, rcases h with ⟨N, hN⟩, rw ← @summable_nat_add_iff α _ _ _ _ N, refine summable_of_norm_bounded (λ n, ∥f N∥ * r^n) (summable.mul_left _ $ summable_geometric_of_lt_1 hr₀ hr₁) (λ n, _), conv_rhs {rw [mul_comm, ← zero_add N]}, refine le_geom hr₀ n (λ i _, _), convert hN (i + N) (N.le_add_left i) using 3, ac_refl }
rcases h with ⟨N, hN⟩
rw ← @summable_nat_add_iff α _ _ _ _ N
refine summable_of_norm_bounded (λ n, ∥f N∥ * r^n) (summable.mul_left _ $ summable_geometric_of_lt_1 hr₀ hr₁) (λ n, _)
conv_rhs {rw [mul_comm, ← zero_add N]}
refine le_geom hr₀ n (λ i _, _)
convert hN (i + N) (N.le_add_left i) using 3
ac_refl
push_neg at hr₀
{ push_neg at hr₀, refine summable_of_norm_bounded_eventually 0 summable_zero _, rw nat.cofinite_eq_at_top, filter_upwards [h], intros n hn, by_contra h, push_neg at h, exact not_lt.mpr (norm_nonneg _) (lt_of_le_of_lt hn $ mul_neg_of_neg_of_pos hr₀ h) }
refine summable_of_norm_bounded_eventually 0 summable_zero _
rw nat.cofinite_eq_at_top
filter_upwards [h]
intros n hn
by_contra h
push_neg at h
exact not_lt.mpr (norm_nonneg _) (lt_of_le_of_lt hn $ mul_neg_of_neg_of_pos hr₀ h)
intros
simp
intros
apply exponential_ideal.mk'
intros B A
exact ⟨_, ⟨(h A).app B⟩⟩
intros
subst h; refl
subst h
refl
intros
{ cases E, congr, }
cases E
congr
intros
ext
{ ext, simp, }
simp
intros
simp [limit_iso_limit_curry_comp_lim, is_limit.cone_point_unique_up_to_iso, is_limit.unique_up_to_iso]
intros
tidy
intros
simp
intros
rw [coprod_comparison, coprod_comparison, coprod.map_desc, ← F.map_comp, ← F.map_comp, coprod.desc_comp, ← F.map_comp, coprod.inl_map, ← F.map_comp, coprod.inr_map]
intros
rw biprod.map_eq_map'
exact is_colimit.ι_map (binary_biproduct.is_colimit W X) _ _ walking_pair.left
intros
simp
intros
tidy
intros
{ rw [←left_unitor_tensor, left_unitor_naturality], simp, }
rw [←left_unitor_tensor, left_unitor_naturality]
simp
intros
{ slice_rhs 1 2 { rw left_unitor_inv_naturality }, simp }
slice_rhs 1 2 { rw left_unitor_inv_naturality }
simp
intros
dsimp [tensor_hom]
simp
intros
simp only [cancel_mono]
intros
fsplit
intro h
{ intro h, rw finrank_eq_one_iff' at h, obtain ⟨f, nz, -⟩ := h, rw ←is_iso_iff_nonzero at nz, exactI ⟨as_iso f⟩, }
rw finrank_eq_one_iff' at h
obtain ⟨f, nz, -⟩ := h
rw ←is_iso_iff_nonzero at nz
exactI ⟨as_iso f⟩
rintro ⟨f⟩
{ rintro ⟨f⟩, have le_one := finrank_hom_simple_simple_le_one 𝕜 X Y, have zero_lt : 0 < finrank 𝕜 (X ⟶ Y) := finrank_pos_iff_exists_ne_zero.mpr ⟨f.hom, (is_iso_iff_nonzero f.hom).mp infer_instance⟩, linarith, }
have le_one := finrank_hom_simple_simple_le_one 𝕜 X Y
have zero_lt : 0 < finrank 𝕜 (X ⟶ Y) := finrank_pos_iff_exists_ne_zero.mpr ⟨f.hom, (is_iso_iff_nonzero f.hom).mp infer_instance⟩
linarith
intros
rw [is_sheaf_for, yoneda_sheaf_condition]
simp_rw [extension_iff_amalgamation]
rw equiv.forall_congr_left' nat_trans_equiv_compatible_family
rw subtype.forall
apply ball_congr
intros x hx
rw equiv.exists_unique_congr_left _
simp
intros
rw ← galois_connection f
apply pushforward_le_bind_of_mem
intros
{ rw eq_mk f, simp, }
rw eq_mk f
simp
intros
simp [of_mk_le, of_le_mk, of_le, of_mk_le_mk, ←functor.map_comp underlying]
intros
rw [←kernel_subobject_arrow]
{ rw [←kernel_subobject_arrow], simp only [category.assoc, kernel.condition, comp_zero], }
simp only [category.assoc, kernel.condition, comp_zero]
intros
simp [boundaries]
intros
simp only [option.get_or_else_none, h, l.apply]
intros
rw [accepts, ε_NFA.accepts, eval, ε_NFA.eval, to_ε_NFA_eval_from_match]
refl
intros
rw [mul_self_star_comm, one_add_self_mul_star_eq_star]
intros
cases x with _ x
dec_trivial
cases x
rw [rmatch, deriv]
split_ifs; tauto
split_ifs
tauto
tauto
rw [rmatch, deriv]
split_ifs
rw one_rmatch_iff
tauto
rw zero_rmatch
tauto
intros
induction c generalizing k v
exact ⟨_, _, rfl⟩
iterate 3 { exact ⟨_, _, rfl⟩ }
exact ⟨_, _, rfl⟩
exact ⟨_, _, rfl⟩
case cons : f fs IHf IHfs { apply IHf }
case comp : f g IHf IHg { apply IHg }
case case : f g IHf IHg { rw step_normal, cases v.head; simp only [nat.elim]; [apply IHf, apply IHg] }
case fix : f IHf { apply IHf }
intros
conv {to_lhs, rw [← list_blank.cons_head_tail l]}
exact quotient.induction_on' l.tail (λ l, rfl)
intros
simp only [(>=>)] with functor_norm
intros
rw ← comp_bitraverse; simp [tfst,tsnd]
rw ← comp_bitraverse
simp [tfst,tsnd]
intros
ext
ext; apply h
{ ext; apply h }
apply h
intros
induction x; simp! * with functor_norm; refl
induction x; simp! * with functor_norm
induction x
simp! * with functor_norm
refl
simp! * with functor_norm
refl
intros
cases b; refl
cases b
refl
refl
intros
simp [pure_eq_done]
intros
simp [many, foldr_eq_done]
intros
rw [add_comm, cosh_add_sinh]
intros
rw [← of_real_nat_cast, abs_of_nonneg (nat.cast_nonneg n)]
intros
ext j
rcases eq_or_ne i j with rfl|hi
{ simp }
simp
{ simp [hi.symm] }
simp [hi.symm]
intros
{ unfold swap_core, split_ifs; cc }
unfold swap_core
split_ifs
split_ifs; cc
cc
cc
cc
cc
intros
rw [fin_rotate_succ_apply, zero_add]
intros
simp [succ_above, h.not_lt]
intros
ext j
by_cases h : j = 0
{ rw h, simp }
rw h
simp
simp only [h, update_noteq, ne.def, not_false_iff]
{ simp only [h, update_noteq, ne.def, not_false_iff], let j' := pred j h, have : j'.succ = j := succ_pred j h, rw [← this, cons_succ, cons_succ] }
let j' := pred j h
have : j'.succ = j := succ_pred j h
rw [← this, cons_succ, cons_succ]
intros
cases n
{ exact absurd h (nat.not_lt_zero _) }
exact absurd h (nat.not_lt_zero _)
rw [lt_iff_coe_lt_coe, coe_last, ←add_lt_add_iff_right 1] at h
{ rw [lt_iff_coe_lt_coe, coe_last, ←add_lt_add_iff_right 1] at h, rw [lt_iff_coe_lt_coe, coe_add, coe_zero, coe_one, nat.mod_eq_of_lt h], exact nat.zero_lt_succ _ }
rw [lt_iff_coe_lt_coe, coe_add, coe_zero, coe_one, nat.mod_eq_of_lt h]
exact nat.zero_lt_succ _
intros
simp [eq_iff_veq]
intros
rw [list.to_finmap, lookup_to_finmap, lookup_to_alist]
intros
classical
rw [← piecewise_coe, ← piecewise_coe, ← set.piecewise_insert, ← coe_insert j s]
congr
intros
rw [singleton_eq_cons, to_finset_cons, to_finset_zero, is_lawful_singleton.insert_emptyc_eq]
intros
simp only [subset_def, image_val, subset_erase_dup', erase_dup_subset', multiset.map_subset_map h]
intros
simp [finset.subtype]
intros
ext
{ ext, simp only [finset.mem_bUnion, iff_self, exists_and_distrib_left, finset.mem_erase] }
simp only [finset.mem_bUnion, iff_self, exists_and_distrib_left, finset.mem_erase]
intros
{ intros x hx, rw finset.mem_union at hx ⊢, tauto }
intros x hx
rw finset.mem_union at hx ⊢
tauto
intros
classical
apply finset.induction_on s
simp
{ simp }
clear s
intros a s ha IH
rw [finset.fold_insert ha, hr, IH, ← or_assoc, or_comm (r c (f a)), or_assoc]
apply or_congr iff.rfl
split
rintro (h₁|⟨x, hx, h₂⟩)
{ rintro (h₁|⟨x, hx, h₂⟩), { use a, simp [h₁] }, { refine ⟨x, by simp [hx], h₂⟩ } }
{ use a, simp [h₁] }
use a
simp [h₁]
{ refine ⟨x, by simp [hx], h₂⟩ }
refine ⟨x, by simp [hx], h₂⟩
rintro ⟨x, hx, h⟩
{ rintro ⟨x, hx, h⟩, rw mem_insert at hx, cases hx, { left, rwa hx at h }, { right, exact ⟨x, hx, h⟩ } }
rw mem_insert at hx
cases hx
{ left, rwa hx at h }
left
rwa hx at h
{ right, exact ⟨x, hx, h⟩ }
right
exact ⟨x, hx, h⟩
intros
subst hs; exact finset.fold_congr hfg
subst hs
exact finset.fold_congr hfg
intros
simp
intros
simp [to_finset]
intros
ext a
by_cases a ∈ set.range f
rcases h with ⟨a', rfl⟩
{ rcases h with ⟨a', rfl⟩, rw [map_range_apply, emb_domain_apply, emb_domain_apply, map_range_apply] }
rw [map_range_apply, emb_domain_apply, emb_domain_apply, map_range_apply]
rw [map_range_apply, emb_domain_notin_range, emb_domain_notin_range, ← hg]
rw [map_range_apply, emb_domain_notin_range, emb_domain_notin_range, ← hg]; assumption
{ rw [map_range_apply, emb_domain_notin_range, emb_domain_notin_range, ← hg]; assumption }
assumption
assumption
assumption
assumption
intros
simp [compl_eq_univ_sdiff]
intros
convert fintype.card_unique
exact unique.subtype_eq' _
intros
have := le_trans (le_abs_self _) (abs_div_le_abs a b)
have := le_trans (le_abs_self _) (abs_div_le_abs a b); rwa [abs_of_nonneg Ha] at this
rwa [abs_of_nonneg Ha] at this
intros
simp [xgcd_aux]
intros
rw [odd_iff_not_even, nat.odd_iff_not_even, nat_abs_even]
intros
rw [insert_entries, kerase_of_not_mem_keys h]
intros
simp only [update_nth_eq_modify_nth, nth_modify_nth_eq]
intros
simp only [scanr, scanr_aux_cons, foldr_cons]; split; refl
simp only [scanr, scanr_aux_cons, foldr_cons]; split
simp only [scanr, scanr_aux_cons, foldr_cons]
split
refl
refl
intros
have : (L.map length).take i = ((L.take (i+1)).map length).take i
simp [map_take, take_take]
simp [map_take, take_take]
simp [take_sum_join, this, drop_sum_join, drop_take_succ_eq_cons_nth_le _ hi]
intros
simp only [subset_def, mem_cons_iff, or_imp_distrib, forall_and_distrib, forall_eq]
intros
induction l with a l ih
{ exact iff_of_true rfl (forall_mem_nil _) }
exact iff_of_true rfl (forall_mem_nil _)
rw forall_mem_cons
by_cases p a
rw [filter_cons_of_pos _ h, cons_inj, ih, and_iff_right h]
{ rw [filter_cons_of_pos _ h, cons_inj, ih, and_iff_right h] }
rw [filter_cons_of_neg _ h]
{ rw [filter_cons_of_neg _ h], refine iff_of_false _ (mt and.left h), intro e, have := filter_sublist l, rw e at this, exact not_lt_of_ge (length_le_of_sublist this) (lt_succ_self _) }
refine iff_of_false _ (mt and.left h)
intro e
have := filter_sublist l
rw e at this
exact not_lt_of_ge (length_le_of_sublist this) (lt_succ_self _)
intros
simp [inits_eq_tails]
intros
induction l with _ _ ih; [refl, simp [h _ (or.inl rfl), ih (forall_mem_of_forall_mem_cons h)]]
induction l with _ _ ih
refl
simp [h _ (or.inl rfl), ih (forall_mem_of_forall_mem_cons h)]
intros
simp only [concat_eq_append, length_append, length]
intros
{induction s, contradiction, refl}
induction s
contradiction
refl
intros
induction l generalizing b; simp only [map, chain.nil, chain_cons, *]
induction l generalizing b
simp only [map, chain.nil, chain_cons, *]
simp only [map, chain.nil, chain_cons, *]
intros
induction s using quotient.induction_on'
rw [lists, quotient.lift_on'_mk']
simp
intros
dsimp [Ico]; simp only [pairwise_lt_range']
dsimp [Ico]
simp only [pairwise_lt_range']
intros
simp only [iota_eq_reverse_range', mem_reverse, mem_range', add_comm, lt_succ_iff]
intros
induction n with n hn generalizing l
{ simp }
simp
cases l with hd tl
{ cases l with hd tl, { simp }, { simp [rotate_cons_succ, hn, append_eq_cons_iff, and_comm] } }
{ simp }
simp
{ simp [rotate_cons_succ, hn, append_eq_cons_iff, and_comm] }
simp [rotate_cons_succ, hn, append_eq_cons_iff, and_comm]
intros
obtain ⟨hd, tl, rfl⟩ := exists_cons_of_ne_nil h
exact cyclic_permutations_cons _ _
intros
rw [← sublists_reverse, reverse_reverse]
intros
induction l with hd tl hl generalizing l'
{ simp }
simp
cases l'
{ cases l', { simp }, { simp [hl] } }
{ simp }
simp
{ simp [hl] }
simp [hl]
intros
ext i j; simp
ext i j
simp
intros
rw [conj_transpose, conj_transpose, transpose_map, transpose_map, update_column_transpose, map_update_row]
refl
intros
simp [dot_product]
intros
{ ext, refl, }
ext
refl
intros
{ ext i j, rcases i; rcases j; simp [one_apply] }
ext i j
rcases i
rcases i; rcases j; simp [one_apply]
rcases i; rcases j
rcases j
simp [one_apply]
simp [one_apply]
rcases j
simp [one_apply]
simp [one_apply]
intros
{ ext, by_cases h : i = j; simp [h] }
ext
by_cases h : i = j
by_cases h : i = j; simp [h]
simp [h]
simp [h]
intros
{ ext i, simp [vec_mul] }
ext i
simp [vec_mul]
intros
rw [union_comm, eq_union_left h]
intros
rw strong_downward_induction
intros
simp [nodup_ext]
intros
funext; simp [functor.map]
funext
simp [functor.map]
intros
rw [revzip, powerset_aux', ← map_reverse, zip_map, ← revzip] at h
simp at h
rcases h with ⟨l₁, l₂, h, rfl, rfl⟩
exact quot.sound (revzip_sublists' _ _ _ h)
intros
induction n; simp [pow_succ, *]
induction n
simp [pow_succ, *]
simp [pow_succ, *]
intros
rw [mul_comm n m, mul_comm k m] at H; exact nat.eq_of_mul_eq_mul_left Hm H
rw [mul_comm n m, mul_comm k m] at H
exact nat.eq_of_mul_eq_mul_left Hm H
intros
{ cases n, cases h, apply succ_pos, }
cases n
cases h
apply succ_pos
intros
rw [← nat.sub_one, nat.sub_sub, one_add]; refl
rw [← nat.sub_one, nat.sub_sub, one_add]
refl
intros
simp [lor]
intros
induction n; simp [*, choose, add_comm]
induction n
simp [*, choose, add_comm]
simp [*, choose, add_comm]
intros
induction L with d L ih
{ dsimp [of_digits], simp }
dsimp [of_digits]
simp
dsimp [of_digits]
{ dsimp [of_digits], replace w₂ := w₂ (by simp), rw digits_add b h, { rw ih, { simp, }, { intros l m, apply w₁, exact list.mem_cons_of_mem _ m, }, { intro h, { rw [list.last_cons _ h] at w₂, convert w₂, }}}, { convert w₁ d (list.mem_cons_self _ _), simp, }, { by_cases h' : L = [], { rcases h' with rfl, simp at w₂, left, apply nat.pos_of_ne_zero, convert w₂, simp, }, { right, apply nat.pos_of_ne_zero, contrapose! w₂, apply digits_zero_of_eq_zero _ w₂, { rw list.last_cons _ h', exact list.last_mem h', }, { exact le_of_lt h, }, }, }, }
replace w₂ := w₂ (by simp)
rw digits_add b h
rw ih
{ rw ih, { simp, }, { intros l m, apply w₁, exact list.mem_cons_of_mem _ m, }, { intro h, { rw [list.last_cons _ h] at w₂, convert w₂, }}}
{ simp, }
simp
{ intros l m, apply w₁, exact list.mem_cons_of_mem _ m, }
intros l m
apply w₁
exact list.mem_cons_of_mem _ m
intro h
{ intro h, { rw [list.last_cons _ h] at w₂, convert w₂, }}
rw [list.last_cons _ h] at w₂
{ rw [list.last_cons _ h] at w₂, convert w₂, }
convert w₂
{ convert w₁ d (list.mem_cons_self _ _), simp, }
convert w₁ d (list.mem_cons_self _ _)
simp
by_cases h' : L = []
{ by_cases h' : L = [], { rcases h' with rfl, simp at w₂, left, apply nat.pos_of_ne_zero, convert w₂, simp, }, { right, apply nat.pos_of_ne_zero, contrapose! w₂, apply digits_zero_of_eq_zero _ w₂, { rw list.last_cons _ h', exact list.last_mem h', }, { exact le_of_lt h, }, }, }
rcases h' with rfl
{ rcases h' with rfl, simp at w₂, left, apply nat.pos_of_ne_zero, convert w₂, simp, }
simp at w₂
left
apply nat.pos_of_ne_zero
convert w₂
simp
right
{ right, apply nat.pos_of_ne_zero, contrapose! w₂, apply digits_zero_of_eq_zero _ w₂, { rw list.last_cons _ h', exact list.last_mem h', }, { exact le_of_lt h, }, }
apply nat.pos_of_ne_zero
contrapose! w₂
apply digits_zero_of_eq_zero _ w₂
rw list.last_cons _ h'
{ rw list.last_cons _ h', exact list.last_mem h', }
exact list.last_mem h'
exact le_of_lt h
{ exact le_of_lt h, }
intros
simp [dist.def, nat.sub_self]
intros
rw [←zero_asc_factorial, cast_asc_factorial, cast_zero, zero_add]
intros
induction n with n ih
{ simp }
simp
simp only [succ_eq_add_one, multiplicity.mul, hp, prime_iff.mp hp, ih, multiplicity_factorial_mul_succ, ←add_assoc, nat.cast_one, nat.cast_add, factorial_succ]
{ simp only [succ_eq_add_one, multiplicity.mul, hp, prime_iff.mp hp, ih, multiplicity_factorial_mul_succ, ←add_assoc, nat.cast_one, nat.cast_add, factorial_succ], congr' 1, rw [add_comm, add_assoc] }
congr' 1
rw [add_comm, add_assoc]
intros
induction n; simp [shiftl', bit_ne_zero, *]
induction n
simp [shiftl', bit_ne_zero, *]
simp [shiftl', bit_ne_zero, *]
intros
refine prime_def_lt.mpr ⟨h1, λ m mlt mdvd, _⟩
have hm : m ≠ 0
rintro rfl
{ rintro rfl, rw zero_dvd_iff at mdvd, exact mlt.ne' mdvd }
rw zero_dvd_iff at mdvd
exact mlt.ne' mdvd
exact (h m mlt hm).symm.eq_one_of_dvd mdvd
intros
rw [← pow_one p, totient_prime_pow hp]; simp
rw [← pow_one p, totient_prime_pow hp]
simp
simp
intros
cases a; refl
cases a
refl
refl
refl
intros
cases n
cases n; refl
refl
refl
refl
intros
cases x; simp only [map_none, map_some, eq_self_iff_true]
{ cases x; simp only [map_none, map_some, eq_self_iff_true] }
cases x
simp only [map_none, map_some, eq_self_iff_true]
simp only [map_none, map_some, eq_self_iff_true]
intros
unfold emem; induction t; simp [any, *, or_assoc]
unfold emem; induction t
unfold emem
induction t
simp [any, *, or_assoc]
simp [any, *, or_assoc]
intros
linarith
intros
cases f
cases f; refl
refl
intros
simp only [liftp_iff, sigma.mk.inj_iff]
simp only [liftp_iff, sigma.mk.inj_iff]; split; intro
simp only [liftp_iff, sigma.mk.inj_iff]; split
split
intro
{ casesm* [Exists _, _ ∧ _], subst_vars, assumption }
casesm* [Exists _, _ ∧ _]
subst_vars
assumption
intro
constructor
repeat { constructor <|> assumption }
constructor
constructor
constructor
constructor
constructor
constructor
assumption
intros
dsimp only [M.corec,M.mk]
congr' with n
cases n with n
{ dsimp only [s_corec,approx.s_mk], refl, }
dsimp only [s_corec,approx.s_mk]
refl
dsimp only [s_corec,approx.s_mk]
{ dsimp only [s_corec,approx.s_mk], cases h : (f x₀), dsimp only [(<$>),pfunctor.map], congr, }
cases h : (f x₀)
dsimp only [(<$>),pfunctor.map]
congr
intros
let u := factor_multiset n
have : n = u.prod := (prod_factor_multiset n).symm
rw[this, ← prime_multiset.prod_smul]
rw[prime_multiset.factor_multiset_prod]
repeat {rw[prime_multiset.factor_multiset_prod]}
rw[prime_multiset.factor_multiset_prod]
intros
simp
intros
split
intro H
{ intro H, rwa ← degree_eq_iff_nat_degree_eq, rintro rfl, rw degree_zero at H, exact option.no_confusion H }
rwa ← degree_eq_iff_nat_degree_eq
rintro rfl
rw degree_zero at H
exact option.no_confusion H
{ intro H, rwa degree_eq_iff_nat_degree_eq, rintro rfl, rw nat_degree_zero at H, rw H at hn, exact lt_irrefl _ hn }
intro H
rwa degree_eq_iff_nat_degree_eq
rintro rfl
rw nat_degree_zero at H
rw H at hn
exact lt_irrefl _ hn
intros
simp only [←C_eq_int_cast, nat_degree_C]
intros
by_cases hp : p = 0
{ simp only [hp, zero_mul, leading_coeff_zero] }
simp only [hp, zero_mul, leading_coeff_zero]
by_cases hq : q = 0
{ by_cases hq : q = 0, { simp only [hq, mul_zero, leading_coeff_zero] }, { rw [leading_coeff_mul'], exact mul_ne_zero (mt leading_coeff_eq_zero.1 hp) (mt leading_coeff_eq_zero.1 hq) } }
{ simp only [hq, mul_zero, leading_coeff_zero] }
simp only [hq, mul_zero, leading_coeff_zero]
rw [leading_coeff_mul']
{ rw [leading_coeff_mul'], exact mul_ne_zero (mt leading_coeff_eq_zero.1 hp) (mt leading_coeff_eq_zero.1 hq) }
exact mul_ne_zero (mt leading_coeff_eq_zero.1 hp) (mt leading_coeff_eq_zero.1 hq)
intros
by_cases hf : f = 0
{ exact (congr_arg polynomial.nat_degree hf).trans rfl }
exact (congr_arg polynomial.nat_degree hf).trans rfl
rw nat_degree_eq_zero_iff_degree_le_zero
{ rw nat_degree_eq_zero_iff_degree_le_zero, by_contra absurd, have f_nat_degree_pos : 0 < f.nat_degree, { rwa [not_le, ←nat_degree_pos_iff_degree_pos] at absurd }, let m := f.nat_degree - 1, have hm : m + 1 = f.nat_degree := nat.sub_add_cancel f_nat_degree_pos, have h2 := coeff_derivative f m, rw polynomial.ext_iff at h, rw [h m, coeff_zero, zero_eq_mul] at h2, cases h2, { rw [hm, ←leading_coeff, leading_coeff_eq_zero] at h2, exact hf h2, }, { norm_cast at h2 } }
by_contra absurd
have f_nat_degree_pos : 0 < f.nat_degree
{ rwa [not_le, ←nat_degree_pos_iff_degree_pos] at absurd }
rwa [not_le, ←nat_degree_pos_iff_degree_pos] at absurd
let m := f.nat_degree - 1
have hm : m + 1 = f.nat_degree := nat.sub_add_cancel f_nat_degree_pos
have h2 := coeff_derivative f m
rw polynomial.ext_iff at h
rw [h m, coeff_zero, zero_eq_mul] at h2
cases h2
rw [hm, ←leading_coeff, leading_coeff_eq_zero] at h2
{ rw [hm, ←leading_coeff, leading_coeff_eq_zero] at h2, exact hf h2, }
exact hf h2
{ norm_cast at h2 }
norm_cast at h2
intros
rw [X_mul, eval₂_mul_X]
intros
rw mem_roots (show p.map f ≠ 0, by exact map_ne_zero hp)
dsimp only [is_root]
rw polynomial.eval_map
intros
simp only [hasse_deriv_apply, nat.sub_zero, nat.choose_zero_right, nat.cast_one, one_mul, sum_monomial_eq]
intros
rw [sub_eq_add_neg, iterated_deriv_add, iterated_deriv_neg, ←sub_eq_add_neg]
intros
rw [← one_mul (X ^ n), ← one_mul (X ^ (rev_at N n)), ← C_1, reflect_C_mul_X_pow]
intros
induction n with n hn
refine root_multiplicity_eq_zero _
{ refine root_multiplicity_eq_zero _, simp only [eval_one, is_root.def, not_false_iff, one_ne_zero, pow_zero] }
simp only [eval_one, is_root.def, not_false_iff, one_ne_zero, pow_zero]
have hzero := (ne_zero_of_monic (monic_pow (monic_X_sub_C a) n.succ))
rw pow_succ (X - C a) n at hzero ⊢
simp only [root_multiplicity_mul hzero, root_multiplicity_X_sub_C_self, hn, nat.one_add]
intros
revert h
apply q.P.W_cases _ x
intros a₀ f'₀ f₀
apply q.P.W_cases _ y
intros a₁ f'₁ f₁
apply Wequiv.abs
intros
rw [rat.mul_denom, int.nat_abs_mul, nat.coprime.gcd_eq_one, nat.div_one]
rw [rat.mul_denom, int.nat_abs_mul, nat.coprime.gcd_eq_one, nat.div_one]; exact (q.cop.mul_right q.cop).mul (q.cop.mul_right q.cop)
exact (q.cop.mul_right q.cop).mul (q.cop.mul_right q.cop)
intros
cases a with n; exact or.imp_right neg_nonneg_of_nonpos (le_total 0 n)
cases a with n
exact or.imp_right neg_nonneg_of_nonpos (le_total 0 n)
intros
{ simp only [lt_top_iff_ne_top, inv_ne_top, pos_iff_ne_zero] }
simp only [lt_top_iff_ne_top, inv_ne_top, pos_iff_ne_zero]
intros
simp [ennreal.to_real, ennreal.of_real, h]
intros
rw [ennreal.of_real, ennreal.of_real, ←@coe_inv (real.to_nnreal x) (by simp [hx]), coe_eq_coe, real.to_nnreal_inv.symm]
intros
simp [upper_bounds, ball_image_iff, -mem_image, *] {contextual := tt}
rw fib_rec.sol_eq_of_eq_init
intros i hi
{ intros i hi, fin_cases hi, { simp }, { simp only [golden_ratio, golden_conj], ring_exp, rw mul_inv_cancel; norm_num } }
fin_cases hi
{ simp }
simp
simp only [golden_ratio, golden_conj]
{ simp only [golden_ratio, golden_conj], ring_exp, rw mul_inv_cancel; norm_num }
ring_exp
rw mul_inv_cancel
rw mul_inv_cancel; norm_num
norm_num
norm_num
{ exact fib_is_sol_fib_rec }
exact fib_is_sol_fib_rec
ring_nf
{ ring_nf, exact (@fib_rec ℝ _).sol_space.sub_mem (submodule.smul_mem fib_rec.sol_space (real.sqrt 5)⁻¹ geom_gold_is_sol_fib_rec) (submodule.smul_mem fib_rec.sol_space (real.sqrt 5)⁻¹ geom_gold_conj_is_sol_fib_rec) }
exact (@fib_rec ℝ _).sol_space.sub_mem (submodule.smul_mem fib_rec.sol_space (real.sqrt 5)⁻¹ geom_gold_is_sol_fib_rec) (submodule.smul_mem fib_rec.sol_space (real.sqrt 5)⁻¹ geom_gold_conj_is_sol_fib_rec)
intros
rw [infinite_pos_iff_infinite_and_pos]; exact ⟨λ hI, hI.1, λ hI, ⟨hI, hp⟩⟩
rw [infinite_pos_iff_infinite_and_pos]
exact ⟨λ hI, hI.1, λ hI, ⟨hI, hp⟩⟩
intros
rcases le_iff_exists_add.mp mn with ⟨k, rfl⟩
rw [← mul_one (a ^ m), pow_add]
refine mul_le_mul rfl.le (pow_le_one _ (zero_le a) a1) _ _
refine mul_le_mul rfl.le (pow_le_one _ (zero_le a) a1) _ _; exact pow_nonneg (zero_le _) _
exact pow_nonneg (zero_le _) _
exact pow_nonneg (zero_le _) _
pi_lower_bound [23/16]
intros
rw [sq, sqrt_eq_iff_mul_self_eq hx hy]
intros
simp only [preimage, inv_comp, image_comp]
intros
apply eq_of_bisim (λc₁ c₂, (c₂ <|> empty α) = c₁) _ rfl
intros s' s h
rw ←h
apply cases_on s; intros s; rw think_empty; simp
apply cases_on s; intros s; rw think_empty
apply cases_on s; intros s
apply cases_on s
intros s
rw think_empty
simp
intros s
rw think_empty
simp
rw←think_empty
intros
apply subtype.eq
funext n
dsimp [to_seq]
apply get_eq_of_mem
rw nth_of_seq
apply ret_mem
intros
simp
intros
cases hs with a ha
{ cases hs with a ha, cases ht with b hb, exact ⟨f a b, ⟨a, b, ha, hb, rfl⟩⟩ }
cases ht with b hb
exact ⟨f a b, ⟨a, b, ha, hb, rfl⟩⟩
intros
rw [image_image, image_congr hf, image_id']
intros
{ ext x, simp [← e.lt_iff_lt] }
ext x
simp [← e.lt_iff_lt]
intros
simp [sub_eq_add_neg]
intros
simp [sub_eq_add_neg, image_comp (λ x, a + x) (λ x, -x)]
intros
simpa only [mul_comm] using preimage_mul_const_Ioc_of_neg a b h
intros
simp [proj_Icc, hx.1, hx.2]
intros
rw [interval, min_eq_left h, max_eq_right h]
intros
{ ext, simp }
ext
simp
intros
rw [diff_eq, compl_Inter, inter_Union]; refl
rw [diff_eq, compl_Inter, inter_Union]
refl
intros
{ cases s, refl }
cases s
refl
intros
rw [card_eq_sum_card_fiberwise (λ x, mem_image_of_mem _ : ∀ x ∈ s.off_diag, quotient.mk x ∈ s.off_diag.image quotient.mk), sum_const_nat (quotient.ind _), mul_comm]
rintro ⟨x, y⟩ hxy
simp_rw [mem_image, exists_prop, mem_off_diag, quotient.eq] at hxy
obtain ⟨a, ⟨ha₁, ha₂, ha⟩, h⟩ := hxy
obtain ⟨hx, hy, hxy⟩ : x ∈ s ∧ y ∈ s ∧ x ≠ y
cases h; have := ha.symm; exact ⟨‹_›, ‹_›, ‹_›⟩
cases h; have := ha.symm
{ cases h; have := ha.symm; exact ⟨‹_›, ‹_›, ‹_›⟩ }
cases h
have := ha.symm
exact ⟨‹_›, ‹_›, ‹_›⟩
have := ha.symm
exact ⟨‹_›, ‹_›, ‹_›⟩
have hxy' : y ≠ x := hxy.symm
have : s.off_diag.filter (λ z, ⟦z⟧ = ⟦(x, y)⟧) = ({(x, y), (y, x)} : finset _)
ext ⟨x₁, y₁⟩
{ ext ⟨x₁, y₁⟩, rw [mem_filter, mem_insert, mem_singleton, sym2.eq_iff, prod.mk.inj_iff, prod.mk.inj_iff, and_iff_right_iff_imp], rintro (⟨rfl, rfl⟩ | ⟨rfl, rfl⟩); rw mem_off_diag; exact ⟨‹_›, ‹_›, ‹_›⟩ }
rw [mem_filter, mem_insert, mem_singleton, sym2.eq_iff, prod.mk.inj_iff, prod.mk.inj_iff, and_iff_right_iff_imp]
rintro (⟨rfl, rfl⟩ | ⟨rfl, rfl⟩); rw mem_off_diag; exact ⟨‹_›, ‹_›, ‹_›⟩
rintro (⟨rfl, rfl⟩ | ⟨rfl, rfl⟩); rw mem_off_diag
rintro (⟨rfl, rfl⟩ | ⟨rfl, rfl⟩)
rw mem_off_diag
exact ⟨‹_›, ‹_›, ‹_›⟩
rw mem_off_diag
exact ⟨‹_›, ‹_›, ‹_›⟩
rw [this, card_insert_of_not_mem, card_singleton]
simp only [not_and, prod.mk.inj_iff, mem_singleton]
exact λ _, hxy'
intros
{ rw quotient.eq, apply rel.swap }
rw quotient.eq
apply rel.swap
intros
ext i
ext i; induction i; [refl, apply i_ih]
ext i; induction i
induction i
refl
apply i_ih
intros
rw [← nth_tail_succ, tail_cons]
intros
rcases v with ⟨l, rfl⟩
apply to_list_injective
change nth ⟨l, eq.refl _⟩ with λ i, nth ⟨l, rfl⟩ i
simpa only [to_list_of_fn] using list.of_fn_nth_le _
intros
rw ring_hom.injective_iff
intro x
obtain ⟨k, rfl⟩ := zmod.int_cast_surjective x
rw [ring_hom.map_int_cast, char_p.int_cast_eq_zero_iff R n, char_p.int_cast_eq_zero_iff (zmod n) n]
exact id
intros
fin_cases a; ext; simp [fin.coe_neg, int.nat_mod]; norm_num
fin_cases a; ext; simp [fin.coe_neg, int.nat_mod]
fin_cases a; ext
fin_cases a
ext
simp [fin.coe_neg, int.nat_mod]
ext
simp [fin.coe_neg, int.nat_mod]
intros
refine {..}; simp [hs.one_mem, hs.mul_mem, hs.inv_mem, hf.map_mul, hf.map_one, hf.map_inv, @inv_mem H _ s] {contextual := tt}
refine {..}
{ refine {..}; simp [hs.one_mem, hs.mul_mem, hs.inv_mem, hf.map_mul, hf.map_one, hf.map_inv, @inv_mem H _ s] {contextual := tt} }
simp [hs.one_mem, hs.mul_mem, hs.inv_mem, hf.map_mul, hf.map_one, hf.map_inv, @inv_mem H _ s] {contextual := tt}
simp [hs.one_mem, hs.mul_mem, hs.inv_mem, hf.map_mul, hf.map_one, hf.map_inv, @inv_mem H _ s] {contextual := tt}
simp [hs.one_mem, hs.mul_mem, hs.inv_mem, hf.map_mul, hf.map_one, hf.map_inv, @inv_mem H _ s] {contextual := tt}
intros
simp_rw [is_periodic_pt_iff_minimal_period_dvd, dvd_right_iff_eq]
intros
ext x
show x ∈ (subfield.closure (set.range (algebra_map F E) ∪ S)).map (f : E →+* E') ↔ x ∈ subfield.closure (set.range (algebra_map F E') ∪ f '' S)
rw [ring_hom.map_field_closure, set.image_union, ← set.range_comp, ← ring_hom.coe_comp, f.comp_algebra_map]
refl
intros
obtain ⟨x : lifts F E K, hx⟩ := zorn.zorn_partial_order lifts.exists_upper_bound
refine ⟨alg_hom.mk (λ s, x.2 ⟨s, adjoin_le_iff.mpr (λ s hs, _) s.mem⟩) x.2.map_one (λ s t, x.2.map_mul ⟨s, _⟩ ⟨t, _⟩) x.2.map_zero (λ s t, x.2.map_add ⟨s, _⟩ ⟨t, _⟩) x.2.commutes⟩
rcases (x.exists_lift_of_splits (hK s hs).1 (hK s hs).2) with ⟨y, h1, h2⟩
rwa hx y h1 at h2
intros
{ ext a, rw [frobenius_def, zmod.pow_card, ring_hom.id_apply] }
ext a
rw [frobenius_def, zmod.pow_card, ring_hom.id_apply]
intros
apply (is_primitive.dvd_iff_fraction_map_dvd_fraction_map K (monic.is_primitive (monic hx)) hprim).2
rw ← gcd_domain_eq_field_fractions K hx
refine dvd _ _ _
rwa ← is_scalar_tower.aeval_apply
intros
split
intro H
{ intro H, replace H := quot.exact _ H, induction H, case eqv_gen.rel : x y H { cases H with n x, exact ⟨0, rfl⟩ }, case eqv_gen.refl : H { exact ⟨0, rfl⟩ }, case eqv_gen.symm : x y H ih { cases ih with w ih, exact ⟨w, ih.symm⟩ }, case eqv_gen.trans : x y z H1 H2 ih1 ih2 { cases ih1 with z1 ih1, cases ih2 with z2 ih2, existsi z2+(y.1+z1), rw [← add_assoc, iterate_add_apply, ih1], rw [← iterate_add_apply, add_comm, iterate_add_apply, ih2], rw [← iterate_add_apply], simp only [add_comm, add_left_comm] } }
replace H := quot.exact _ H
induction H
case eqv_gen.rel : x y H { cases H with n x, exact ⟨0, rfl⟩ }
case eqv_gen.refl : H { exact ⟨0, rfl⟩ }
exact ⟨0, rfl⟩
case eqv_gen.symm : x y H ih { cases ih with w ih, exact ⟨w, ih.symm⟩ }
case eqv_gen.trans : x y z H1 H2 ih1 ih2 { cases ih1 with z1 ih1, cases ih2 with z2 ih2, existsi z2+(y.1+z1), rw [← add_assoc, iterate_add_apply, ih1], rw [← iterate_add_apply, add_comm, iterate_add_apply, ih2], rw [← iterate_add_apply], simp only [add_comm, add_left_comm] }
intro H
cases x with m x
cases y with n y
cases H with z H
dsimp only at H
rw [r.sound K p (n+z) m x _ rfl, r.sound K p (m+z) n y _ rfl, H]
rw [add_assoc, add_comm, add_comm z]
intros
simp [splits, polynomial.map_map]
intros
simp [← cos_angle_mul_norm_mul_norm, h]
intros
haveI : nonempty (⊤ : affine_subspace ℝ P) := set.univ.nonempty
rw [←finrank_top, ←direction_top ℝ V P] at hd
refine exists_circumradius_eq_of_cospherical_subset _ hd hc
exact set.subset_univ _
intros
rcases ho with ⟨t, hto, hst⟩
rw hst at hps
rcases exists_dist_eq_circumradius_of_subset_insert_orthocenter hto hps hpi with ⟨c, hcs, hc⟩
exact cospherical.affine_independent ⟨c, t.circumradius, hc⟩ set.subset.rfl hpi
intros
simp only [chart_at] with mfld_simps
intros
unfold unique_mdiff_within_at
simp only [preimage_univ, univ_inter]
exact I.unique_diff _ (mem_range_self _)
intros
split
assume h
{ assume h, apply h.congr_of_eventually_eq h₁ hx }
apply h.congr_of_eventually_eq h₁ hx
assume h
{ assume h, apply h.congr_of_eventually_eq _ hx.symm, apply h₁.mono, intro y, apply eq.symm }
apply h.congr_of_eventually_eq _ hx.symm
apply h₁.mono
intro y
apply eq.symm
intros
rw [← image_univ, ← I.source_eq]
{ rw [← image_univ, ← I.source_eq], exact (I.to_local_equiv.image_source_eq_target).symm }
exact (I.to_local_equiv.image_source_eq_target).symm
intros
mfld_set_tac
intros
split
assume h
{ assume h, refine ⟨λ x hx, (h x hx).1, λ x y z hz, _⟩, simp only with mfld_simps at hz, let w := (ext_chart_at I x).symm z, have : w ∈ s, by simp only [w, hz] with mfld_simps, specialize h w this, have w1 : w ∈ (chart_at H x).source, by simp only [w, hz] with mfld_simps, have w2 : f w ∈ (chart_at H' y).source, by simp only [w, hz] with mfld_simps, convert (((times_cont_diff_within_at_local_invariant_prop I I' n).lift_prop_within_at_indep_chart (structure_groupoid.chart_mem_maximal_atlas _ x) w1 (structure_groupoid.chart_mem_maximal_atlas _ y) w2).1 h).2 using 1, { mfld_set_tac }, { simp only [w, hz] with mfld_simps } }
refine ⟨λ x hx, (h x hx).1, λ x y z hz, _⟩
simp only with mfld_simps at hz
let w := (ext_chart_at I x).symm z
have : w ∈ s
simp only [w, hz] with mfld_simps
simp only [w, hz] with mfld_simps
specialize h w this
have w1 : w ∈ (chart_at H x).source
simp only [w, hz] with mfld_simps
simp only [w, hz] with mfld_simps
have w2 : f w ∈ (chart_at H' y).source
simp only [w, hz] with mfld_simps
simp only [w, hz] with mfld_simps
convert (((times_cont_diff_within_at_local_invariant_prop I I' n).lift_prop_within_at_indep_chart (structure_groupoid.chart_mem_maximal_atlas _ x) w1 (structure_groupoid.chart_mem_maximal_atlas _ y) w2).1 h).2 using 1
{ mfld_set_tac }
mfld_set_tac
{ simp only [w, hz] with mfld_simps }
simp only [w, hz] with mfld_simps
rintros ⟨hcont, hdiff⟩ x hx
{ rintros ⟨hcont, hdiff⟩ x hx, refine ⟨hcont x hx, _⟩, have Z := hdiff x (f x) (ext_chart_at I x x) (by simp only [hx] with mfld_simps), dsimp [times_cont_diff_within_at_prop], convert Z using 1, mfld_set_tac }
refine ⟨hcont x hx, _⟩
have Z := hdiff x (f x) (ext_chart_at I x x) (by simp only [hx] with mfld_simps)
dsimp [times_cont_diff_within_at_prop]
convert Z using 1
mfld_set_tac
intros
let ϕ : H →* H := { to_fun := λ h, ⟨g * h * g⁻¹, hH.conj_mem h.1 h.2 g⟩, map_one' := subtype.ext (by rw [coe_mk, coe_one, mul_one, mul_inv_self]), map_mul' := λ h₁ h₂, subtype.ext (by rw [coe_mk, coe_mul, coe_mul, coe_mk, coe_mk, mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc, inv_mul_cancel_left]) }
refine eq.trans (finset.prod_bij' (λ q _, (↑g)⁻¹ * q) (λ _ _, finset.mem_univ _) (λ q _, subtype.ext _) (λ q _, ↑g * q) (λ _ _, finset.mem_univ _) (λ q _, mul_inv_cancel_left g q) (λ q _, inv_mul_cancel_left g q)) (ϕ.map_prod _ _).symm
change _ * _ = g * (_ * _) * g⁻¹
simp_rw [smul_symm_apply_eq_mul_symm_apply_inv_smul, mul_inv_rev, mul_assoc]
refl
intros
simp [card_eq_card_quotient_mul_card_subgroup s]
intros
rw [lift_mk', lift_mk', mul_inv hg]
intros
rw [pow_eq_mod_order_of, ←nat.mod_mod_of_dvd n order_of_dvd_card_univ, ← pow_eq_mod_order_of]
intros
rw [mul_swap_eq_swap_mul, mul_inv_cancel_right]
intros
rw [card_eq_zero, cycle_type_eq_zero]
intros
cases (disjoint_iff_eq_or_eq.mp h) x with hfx hgx
simp [h.commute.eq, cycle_of_mul_of_apply_right_eq_self h.symm.commute, hfx]
{ simp [h.commute.eq, cycle_of_mul_of_apply_right_eq_self h.symm.commute, hfx] }
simp [cycle_of_mul_of_apply_right_eq_self h.commute, hgx]
{ simp [cycle_of_mul_of_apply_right_eq_self h.commute, hgx] }
intros
{ ext i, rw [coe_cycle_range_of_le (le_last _), coe_fin_rotate] }
ext i
rw [coe_cycle_range_of_le (le_last _), coe_fin_rotate]
intros
obtain ⟨k, hk, rfl⟩ := nth_le_of_mem hx
rw [form_perm_apply_nth_le _ hl, hl.nth_le_inj_iff]
cases hn : l.length
{ exact absurd k.zero_le (hk.trans_le hn.le).not_le }
exact absurd k.zero_le (hk.trans_le hn.le).not_le
rw hn at hk
{ rw hn at hk, cases (nat.le_of_lt_succ hk).eq_or_lt with hk' hk', { simp [←hk', nat.succ_le_succ_iff, eq_comm] }, { simpa [nat.mod_eq_of_lt (nat.succ_lt_succ hk'), nat.succ_lt_succ_iff] using k.zero_le.trans_lt hk' } }
cases (nat.le_of_lt_succ hk).eq_or_lt with hk' hk'
{ simp [←hk', nat.succ_le_succ_iff, eq_comm] }
simp [←hk', nat.succ_le_succ_iff, eq_comm]
simpa [nat.mod_eq_of_lt (nat.succ_lt_succ hk'), nat.succ_lt_succ_iff] using k.zero_le.trans_lt hk'
{ simpa [nat.mod_eq_of_lt (nat.succ_lt_succ hk'), nat.succ_lt_succ_iff] using k.zero_le.trans_lt hk' }
intros
simp
intros
rw [← monoid_hom.map_inv, inl_aut, inv_inv]
intros
rw [line_map_apply, vadd_vsub]
intros
rw [weighted_vsub_of_point_apply, weighted_vsub_of_point_apply]
apply sum_erase
rw [vsub_self, smul_zero]
intros
rw coe_reindex_repr
intros
simp [basis.singleton, unique.eq_default i]
intros
rw bilin_form.is_adjoint_pair_iff_comp_left_eq_comp_right
have h : ∀ (B B' : bilin_form R₃ M₃), B = B' ↔ (bilin_form.to_matrix b B) = (bilin_form.to_matrix b B')
intros B B'
{ intros B B', split; intros h, { rw h }, { exact (bilin_form.to_matrix b).injective h } }
split; intros h
split
intros h
{ rw h }
rw h
intros h
{ exact (bilin_form.to_matrix b).injective h }
exact (bilin_form.to_matrix b).injective h
rw [h, bilin_form.to_matrix_comp_left, bilin_form.to_matrix_comp_right, linear_map.to_matrix_to_lin, linear_map.to_matrix_to_lin, bilin_form.to_matrix_to_bilin, bilin_form.to_matrix_to_bilin]
refl
intros
{ ext, refl }
ext
refl
intros
rw [← linear_map.to_matrix_id_eq_basis_to_matrix, ← bilin_form.to_matrix_comp, bilin_form.comp_id_id]
intros
haveI := classical.dec_eq M; exact (f : M →ₗ[A] M).det_cases (λ s b, f.is_unit_det _ _) is_unit_one
haveI := classical.dec_eq M
exact (f : M →ₗ[A] M).det_cases (λ s b, f.is_unit_det _ _) is_unit_one
intros
dsimp [module.rank]
fapply cardinal.lift_sup_le_lift_sup'
rintro ⟨s, li⟩
{ rintro ⟨s, li⟩, use f '' s, convert (li.map' f (linear_map.ker_eq_bot.mpr i)).comp (equiv.set.image ⇑f s i).symm (equiv.injective _), ext ⟨-, ⟨x, ⟨h, rfl⟩⟩⟩, simp, }
use f '' s
convert (li.map' f (linear_map.ker_eq_bot.mpr i)).comp (equiv.set.image ⇑f s i).symm (equiv.injective _)
ext ⟨-, ⟨x, ⟨h, rfl⟩⟩⟩
simp
rintro ⟨s, li⟩
{ rintro ⟨s, li⟩, exact cardinal.lift_mk_le'.mpr ⟨(equiv.set.image f s i).to_embedding⟩, }
exact cardinal.lift_mk_le'.mpr ⟨(equiv.set.image f s i).to_embedding⟩
intros
rw eq_top_iff'
intro f
rw linear_map.mem_range
let lin_comb : ι →₀ R := finsupp.on_finset fin.elems (λ i, f.to_fun (b i)) _
use finsupp.total ι M R b lin_comb
{ use finsupp.total ι M R b lin_comb, apply b.ext, { intros i, rw [b.to_dual_eq_repr _ i, repr_total b], { refl } } }
apply b.ext
intros i
{ intros i, rw [b.to_dual_eq_repr _ i, repr_total b], { refl } }
rw [b.to_dual_eq_repr _ i, repr_total b]
{ refl }
refl
intros a _
{ intros a _, apply fin.complete }
apply fin.complete
intros
dunfold eval
rw [linear_map.flip_apply, linear_map.id_apply]
intros
haveI : finite_dimensional F S := finite_dimensional_of_dim_eq_one h
rw ← finrank_eq_dim at h
norm_cast at h
exact subalgebra.eq_bot_of_finrank_one h
intros
apply span_eq_of_le
intros x hx
{ intros x hx, rw set.mem_image at hx, apply exists.elim hx, intros i hi, exact ⟨_, finsupp.single_mem_supported R 1 hi.1, by simp [hi.2]⟩ }
rw set.mem_image at hx
apply exists.elim hx
intros i hi
exact ⟨_, finsupp.single_mem_supported R 1 hi.1, by simp [hi.2]⟩
refine map_le_iff_le_comap.2 (λ z hz, _)
{ refine map_le_iff_le_comap.2 (λ z hz, _), have : ∀i, z i • v i ∈ span R (v '' s), { intro c, haveI := classical.dec_pred (λ x, x ∈ s), by_cases c ∈ s, { exact smul_mem _ _ (subset_span (set.mem_image_of_mem _ h)) }, { simp [(finsupp.mem_supported' R _).1 hz _ h] } }, refine sum_mem _ _, simp [this] }
have : ∀i, z i • v i ∈ span R (v '' s)
intro c
{ intro c, haveI := classical.dec_pred (λ x, x ∈ s), by_cases c ∈ s, { exact smul_mem _ _ (subset_span (set.mem_image_of_mem _ h)) }, { simp [(finsupp.mem_supported' R _).1 hz _ h] } }
haveI := classical.dec_pred (λ x, x ∈ s)
by_cases c ∈ s
{ exact smul_mem _ _ (subset_span (set.mem_image_of_mem _ h)) }
exact smul_mem _ _ (subset_span (set.mem_image_of_mem _ h))
{ simp [(finsupp.mem_supported' R _).1 hz _ h] }
simp [(finsupp.mem_supported' R _).1 hz _ h]
refine sum_mem _ _
simp [this]
intros
replace h : x ∉ (f.support : set ι) := h
have p := hv.not_mem_span_image h
intro w
rw ←w at p
rw finsupp.span_image_eq_map_total at p
simp only [not_exists, not_and, mem_map] at p
exact p f (f.mem_supported_support R) rfl
intros
simpa only [smul_mul_assoc] using det_sum_le s (λ k i j, calc abv (c k * A k i j) = abv (c k) * abv (A k i j) : abv.map_mul _ _ ... ≤ y * x : mul_le_mul (hy k) (hx k i j) (abv.nonneg _) ((abv.nonneg _).trans (hy k)))
intros
rw [matrix.mul_assoc, matrix.mul_assoc, det_mul, det_mul_comm N P, ←det_mul]
intros
rw [← diagonal_one]; simp [-diagonal_one]
rw [← diagonal_one]
simp [-diagonal_one]
intros
casesI (subsingleton_or_nontrivial α) with ht ht
{ simp }
simp
cases (fintype.card n).zero_le.eq_or_lt with hc hc
rw [eq_comm, fintype.card_eq_zero_iff] at hc
{ rw [eq_comm, fintype.card_eq_zero_iff] at hc, haveI := hc, ext i, exact (is_empty.false i).elim }
haveI := hc
ext i
exact (is_empty.false i).elim
have hn : nonempty n := fintype.card_pos_iff.mp hc
{ have hn : nonempty n := fintype.card_pos_iff.mp hc, refine nonsing_inv_apply_not_is_unit _ _, simp [hn] }
refine nonsing_inv_apply_not_is_unit _ _
simp [hn]
intros
simp [module.algebra_map_End_eq_smul_id]
intros
rw [linear_map.to_matrix_apply', algebra.lsmul_coe, linear_equiv.map_smul, finsupp.smul_apply, b.repr_self_apply, smul_eq_mul, mul_boole]
{ rw [linear_map.to_matrix_apply', algebra.lsmul_coe, linear_equiv.map_smul, finsupp.smul_apply, b.repr_self_apply, smul_eq_mul, mul_boole], congr' 1; simp only [eq_comm] }
congr' 1; simp only [eq_comm]
congr' 1
simp only [eq_comm]
intros
induction L with t L IH
{ simp }
simp
{ simp [IH], }
simp [IH]
intros
refine (curry_fin_finset_symm_apply_piecewise_const hk hl _ _ _).symm.trans _
rw linear_equiv.symm_apply_apply
intros
have C0 : C 0
have h₁ := @C1 0 0
{ have h₁ := @C1 0 0, rwa [zero_tprod_coeff] at h₁ }
rwa [zero_tprod_coeff] at h₁
refine add_con.induction_on z (λ x, free_add_monoid.rec_on x C0 _)
simp_rw add_con.coe_add
refine λ f y ih, Cp _ ih
convert @C1 f.1 f.2
simp only [prod.mk.eta]
intros
simp
intros
dsimp [tailing, tunnel_aux]
rw [submodule.map_comp, submodule.map_comp]
apply submodule.map_subtype_le
intros
rw [←@zero_smul R _ _ _ _ (0 : M), map_smul, zero_mul, zero_mul]
intros
simp only [anisotropic, not_forall, exists_prop, and_comm]
intros
{ rw smodeq.def at hxy ⊢, simp_rw [quotient.mk_smul, hxy] }
rw smodeq.def at hxy ⊢
simp_rw [quotient.mk_smul, hxy]
intros
simp [to_tensor]
intros
dsimp [tensor_product.rid, tensor_product.comm, tensor_product.lid]
simp
intros
simp [decidable.not_not]
intros
induction hab
exact ⟨c, hac, refl⟩
case refl_trans_gen.refl { exact ⟨c, hac, refl⟩ }
case refl_trans_gen.tail : d e had hde ih { clear hac had a, rcases ih with ⟨b, hdb, hcb⟩, have : ∃ a, refl_trans_gen r e a ∧ refl_gen r b a, { clear hcb, induction hdb, case refl_trans_gen.refl { exact ⟨e, refl, refl_gen.single hde⟩ }, case refl_trans_gen.tail : f b hdf hfb ih { rcases ih with ⟨a, hea, hfa⟩, cases hfa with _ hfa, { exact ⟨b, hea.tail hfb, refl_gen.refl⟩ }, { rcases h _ _ _ hfb hfa with ⟨c, hbc, hac⟩, exact ⟨c, hea.trans hac, hbc⟩ } } }, rcases this with ⟨a, hea, hba⟩, cases hba with _ hba, { exact ⟨b, hea, hcb⟩ }, { exact ⟨a, hea, hcb.tail hba⟩ } }
intros
{ rw ← pi_univ_Icc, exact pi_Ioo_ae_eq_pi_Icc }
rw ← pi_univ_Icc
exact pi_Ioo_ae_eq_pi_Icc
intros
rw [← set_like.mem_coe, ← submodule.mem_carrier, Lp_meas, set.mem_set_of_eq]
intros
split
assume h
{ assume h, simpa only [smul_smul, inv_mul_cancel hc, one_smul] using h.smul c⁻¹ }
simpa only [smul_smul, inv_mul_cancel hc, one_smul] using h.smul c⁻¹
exact has_finite_integral.smul _
intros
rw [← integrable_coe_fn, ← mem_ℒp_one_iff_integrable, Lp.mem_Lp_iff_mem_ℒp]
intros
suffices : f =ᵐ[μ] 0 ∧ g =ᵐ[μ] 0
simp [snorm_congr_ae this.1, snorm_congr_ae this.2]
simp [snorm_congr_ae this.1, snorm_congr_ae this.2]
refine ⟨h.mono $ λ x hx, _, h.mono $ λ x hx, _⟩
refine norm_le_zero_iff.1 (hx.trans _)
{ refine norm_le_zero_iff.1 (hx.trans _), exact mul_nonpos_of_nonpos_of_nonneg hc.le (norm_nonneg _) }
exact mul_nonpos_of_nonpos_of_nonneg hc.le (norm_nonneg _)
refine norm_le_zero_iff.1 (nonpos_of_mul_nonneg_right _ hc)
{ refine norm_le_zero_iff.1 (nonpos_of_mul_nonneg_right _ hc), exact (norm_nonneg _).trans hx }
exact (norm_nonneg _).trans hx
intros
{ ext1 f, exact smul_comp_Lp c L f }
ext1 f
exact smul_comp_Lp c L f
intros
simp [snorm', hq_pos]
intros
rw @snorm_smul_measure_of_ne_top _ _ _ μ _ 1 (@ennreal.coe_ne_top 1) f c
{ rw @snorm_smul_measure_of_ne_top _ _ _ μ _ 1 (@ennreal.coe_ne_top 1) f c, simp, }
simp
intros
have := edist_approx_on_y0_le hf h₀ x n
rw [edist_comm y₀, edist_eq_coe_nnnorm_sub] at this
repeat { rw [edist_comm y₀, edist_eq_coe_nnnorm_sub] at this }
rw [edist_comm y₀, edist_eq_coe_nnnorm_sub] at this
rw [edist_comm y₀, edist_eq_coe_nnnorm_sub] at this
exact_mod_cast this
intros
simpa only [← finset.prod_apply] using s.ae_measurable_prod' hf
intros
rwa [eventually_eq, ae_iff, trim_measurable_set_eq hm _]
exact (@measurable_set.compl β _ m (@measurable_set_eq_fun β m γ _ _ _ _ _ _ hf hg))
intros
{ simp only [mul_comm], exact integral_mul_left r f }
simp only [mul_comm]
exact integral_mul_left r f
intros
rw [integrable_on, measure.restrict_univ]
intros
by_cases hc : c = 0; simp [hc]
by_cases hc : c = 0
simp [hc]
simp [hc]
intros
simp only [h]
intros
have : measurable_set {a : α | ε ≤ f a }
from hf measurable_set_Ici
rw [← simple_func.restrict_const_lintegral _ this, ← simple_func.lintegral_eq_lintegral]
refine lintegral_mono (λ a, _)
simp only [restrict_apply _ this]
exact indicator_apply_le id
intros
simp [lintegral_congr_ae (ae_eq_dirac' hf)]
intros
rw ← finset.not_nonempty_iff_eq_empty
by_contra
obtain ⟨y, hy_mem⟩ := h
rw [simple_func.mem_range, set.mem_range] at hy_mem
obtain ⟨x, hxy⟩ := hy_mem
rw is_empty_iff at hα
exact hα x
intros
refine supr_congr _ ((compacts.equiv f).surjective) _
intro K
refine supr_congr_Prop image_subset_iff _
intro hK
simp only [equiv.coe_fn_mk, subtype.mk_eq_mk, ennreal.coe_eq_coe, compacts.equiv]
apply h
intros
classical
let M := f.to_matrix'
have A : f.det = det M
simp only [linear_map.det_to_matrix']
simp only [linear_map.det_to_matrix']
have B : f = M.to_lin'
simp only [to_lin'_to_matrix']
simp only [to_lin'_to_matrix']
rw [A, B]
apply map_matrix_volume_pi_eq_smul_volume_pi
rwa A at hf
intros
{ congr, ext1 n, exact h n }
congr
ext1 n
exact h n
intros
rw [mem_map, mem_ae_iff, measure.restrict_apply' hs]
intros
rw [measure_eq_trim, outer_measure.trim_eq_infi]
rw [measure_eq_trim, outer_measure.trim_eq_infi]; refl
refl
intros
simp only [le_antisymm_iff, trim_le_trim_iff, forall_and_distrib]
intros
intros U hU r hr
rw [smul_apply, H.measure_eq_supr hU] at hr
simpa only [ennreal.mul_supr, lt_supr_iff, exists_prop] using hr
intros
rw [← coe_injective.eq_iff, function.funext_iff]
intros
ext i hi
rw [to_signed_measure_apply_measurable hi, vector_measure.smul_apply, to_signed_measure_apply_measurable hi, coe_nnreal_smul, pi.smul_apply, ennreal.to_real_smul]
simp
intros
rw mem_divisors_antidiagonal at h
simp [dvd.intro _ h.1, h.2]
intros
delta fermat_42
split
intro f42
{ intro f42, split, { exact mul_ne_zero hk0 f42.1 }, split, { exact mul_ne_zero hk0 f42.2.1 }, { calc (k * a) ^ 4 + (k * b) ^ 4 = k ^ 4 * (a ^ 4 + b ^ 4) : by ring ... = k ^ 4 * c ^ 2 : by rw f42.2.2 ... = (k ^ 2 * c) ^ 2 : by ring }}
split
exact mul_ne_zero hk0 f42.1
{ exact mul_ne_zero hk0 f42.1 }
split
exact mul_ne_zero hk0 f42.2.1
{ exact mul_ne_zero hk0 f42.2.1 }
calc (k * a) ^ 4 + (k * b) ^ 4 = k ^ 4 * (a ^ 4 + b ^ 4) : by ring ... = k ^ 4 * c ^ 2 : by rw f42.2.2 ... = (k ^ 2 * c) ^ 2 : by ring
{ calc (k * a) ^ 4 + (k * b) ^ 4 = k ^ 4 * (a ^ 4 + b ^ 4) : by ring ... = k ^ 4 * c ^ 2 : by rw f42.2.2 ... = (k ^ 2 * c) ^ 2 : by ring }
intro f42
{ intro f42, split, { exact right_ne_zero_of_mul f42.1 }, split, { exact right_ne_zero_of_mul f42.2.1 }, apply (mul_right_inj' (pow_ne_zero 4 hk0)).mp, { calc k ^ 4 * (a ^ 4 + b ^ 4) = (k * a) ^ 4 + (k * b) ^ 4 : by ring ... = (k ^ 2 * c) ^ 2 : by rw f42.2.2 ... = k ^ 4 * c ^ 2 : by ring }}
split
exact right_ne_zero_of_mul f42.1
{ exact right_ne_zero_of_mul f42.1 }
split
exact right_ne_zero_of_mul f42.2.1
{ exact right_ne_zero_of_mul f42.2.1 }
apply (mul_right_inj' (pow_ne_zero 4 hk0)).mp
calc k ^ 4 * (a ^ 4 + b ^ 4) = (k * a) ^ 4 + (k * b) ^ 4 : by ring ... = (k ^ 2 * c) ^ 2 : by rw f42.2.2 ... = k ^ 4 * c ^ 2 : by ring
{ calc k ^ 4 * (a ^ 4 + b ^ 4) = (k * a) ^ 4 + (k * b) ^ 4 : by ring ... = (k ^ 2 * c) ^ 2 : by rw f42.2.2 ... = k ^ 4 * c ^ 2 : by ring }
intros
induction n; simp
{ induction n; simp, }
induction n
simp
simp
intros
convert int.mod_lt _ _
{ simp }
simp
{ exact_mod_cast hp_prime.1.ne_zero }
exact_mod_cast hp_prime.1.ne_zero
intros
induction n; simp *
induction n
simp *
simp *
intros
split
intro h
{ intro h, rw [ext, zero_re, zero_im], rw [norm_def, sub_eq_add_neg, mul_assoc] at h, have left := mul_self_nonneg z.re, have right := neg_nonneg.mpr (mul_nonpos_of_nonpos_of_nonneg hd.le (mul_self_nonneg z.im)), obtain ⟨ha, hb⟩ := (add_eq_zero_iff' left right).mp h, split; apply eq_zero_of_mul_self_eq_zero, { exact ha }, { rw [neg_eq_zero, mul_eq_zero] at hb, exact hb.resolve_left hd.ne } }
rw [ext, zero_re, zero_im]
rw [norm_def, sub_eq_add_neg, mul_assoc] at h
have left := mul_self_nonneg z.re
have right := neg_nonneg.mpr (mul_nonpos_of_nonpos_of_nonneg hd.le (mul_self_nonneg z.im))
obtain ⟨ha, hb⟩ := (add_eq_zero_iff' left right).mp h
split; apply eq_zero_of_mul_self_eq_zero
split
apply eq_zero_of_mul_self_eq_zero
{ exact ha }
exact ha
apply eq_zero_of_mul_self_eq_zero
rw [neg_eq_zero, mul_eq_zero] at hb
{ rw [neg_eq_zero, mul_eq_zero] at hb, exact hb.resolve_left hd.ne }
exact hb.resolve_left hd.ne
{ rintro rfl, exact norm_zero }
rintro rfl
exact norm_zero
intros
refine eq.trans (congr rfl (set.ext (λ x, _))) (Sup_atoms_le_eq ⊤)
exact (and_iff_left le_top).symm
intros
simp [update_le_iff] {contextual := tt}
intros
simpa only [compl_compl] using compl_le_compl h
intros
rw [←c.closure_eq_self_of_mem_closed hy, ←le_closure_iff]
intros
simpa only [inf_comm] using @inf_Sup_eq α _ b s
intros
rw set.eq_singleton_iff_nonempty_unique_mem
{ rw set.eq_singleton_iff_nonempty_unique_mem, rw Sup_eq_bot at h_sup, exact ⟨hne, h_sup⟩, }
rw Sup_eq_bot at h_sup
exact ⟨hne, h_sup⟩
intros
rw [at_bot_Iio_eq, tendsto_comap_iff]
intros
simp only [tendsto_at_bot, neg_le]
exact λ b, eventually_ge_at_top _
intros
rw filter.eventually_at_top_prod_self
apply exists_congr
tauto
intros
casesI is_empty_or_nonempty β
rw [filter_eq_bot_of_is_empty (f.comap _), ← not_iff_not]
rw [filter_eq_bot_of_is_empty (f.comap _), ← not_iff_not]; [simp *, apply_instance]
{ rw [filter_eq_bot_of_is_empty (f.comap _), ← not_iff_not]; [simp *, apply_instance] }
simp *
apply_instance
{ simp [comap_ne_bot_iff_frequently, h] }
simp [comap_ne_bot_iff_frequently, h]
intros
simp
intros
simp only [← filter.mem_sets, infi_sets_eq h, mem_Union]
intros
rw [filter.lift, infi_subtype', infi_ne_bot_iff_of_directed', subtype.forall']
rintros ⟨s, hs⟩ ⟨t, ht⟩
{ rintros ⟨s, hs⟩ ⟨t, ht⟩, exact ⟨⟨s ∩ t, inter_mem hs ht⟩, hm (inter_subset_left s t), hm (inter_subset_right s t)⟩ }
exact ⟨⟨s ∩ t, inter_mem hs ht⟩, hm (inter_subset_left s t), hm (inter_subset_right s t)⟩
intros
unfold rtendsto' rcomap'
simp [le_def, rel.mem_image]
split
{ exact λ h s hs, h _ _ hs set.subset.rfl }
exact λ h s hs, h _ _ hs set.subset.rfl
{ exact λ h s t ht, mem_of_superset (h t ht) }
exact λ h s t ht, mem_of_superset (h t ht)
intros
ext
ext; refl
refl
intros
refine (supr_le $ λ n, _).antisymm (supr_le_supr $ le_partial_sups f)
rw partial_sups_eq_bsupr
exact bsupr_le_supr _ _
intros
rw [symm_diff_comm a b, symm_diff_comm c b, symm_diff_right_inj]
intros
obtain ⟨g, h1 | h2⟩ := exists_increasing_or_nonincreasing_subseq r f
refine ⟨g, λ m n hle, _⟩
{ refine ⟨g, λ m n hle, _⟩, obtain hlt | heq := lt_or_eq_of_le hle, { exact h1 m n hlt, }, { rw [heq], apply refl_of r } }
obtain hlt | heq := lt_or_eq_of_le hle
{ exact h1 m n hlt, }
exact h1 m n hlt
rw [heq]
{ rw [heq], apply refl_of r }
apply refl_of r
exfalso
{ exfalso, obtain ⟨m, n, hlt, hle⟩ := h (f ∘ g) (subset.trans (range_comp_subset_range _ _) hf), exact h2 m n hlt hle }
obtain ⟨m, n, hlt, hle⟩ := h (f ∘ g) (subset.trans (range_comp_subset_range _ _) hf)
exact h2 m n hlt hle
intros
simp [is_max_chain, not_and_distrib, not_forall_not] at hc₂
cases hc₂.neg_resolve_left hc₁ with c' hc'
exact succ_spec ⟨c', hc₁, hc'⟩
intros
{ rw is_coprime_comm, exact h.symm.add_mul_right_left z }
rw is_coprime_comm
exact h.symm.add_mul_right_left z
intros
refine ⟨λ h, _, λ h, @add_monoid_algebra.finite_type_of_fg _ _ _ _ h⟩
obtain ⟨S, hS⟩ := @exists_finset_adjoin_eq_top R M _ _ h
refine add_monoid.fg_def.2 ⟨S, (eq_top_iff' _).2 (λ m, _)⟩
have hm : of' R M m ∈ (adjoin R (of' R M '' ↑S)).to_submodule
{ simp only [hS, top_to_submodule, submodule.mem_top], }
simp only [hS, top_to_submodule, submodule.mem_top]
rw [adjoin_eq_span] at hm
exact mem_closure_of_mem_span_closure hm
intros
use [1, S.one_mem]
intros b hb
rw one_smul
obtain ⟨b', b'_mem, rfl⟩ := h hb
exact set.mem_range_self b'
intros
rw ← coe_to_fractional_ideal_bot
{ rw ← coe_to_fractional_ideal_bot, exact coe_ideal_injective.eq_iff }
exact coe_ideal_injective.eq_iff
intros
simp [← ring_equiv.to_ring_hom_eq_coe, map_map]
intros
rw hp.multiset_prod_le (mt multiset.map_eq_zero.mp hne)
simp_rw [exists_prop, multiset.mem_map, exists_exists_and_eq_and]
intros
apply ideal.ext
rintro ⟨r, s⟩
rw [mem_prod, mem_map_iff_of_surjective (ring_hom.fst R S) prod.fst_surjective, mem_map_iff_of_surjective (ring_hom.snd R S) prod.snd_surjective]
refine ⟨λ h, ⟨⟨_, ⟨h, rfl⟩⟩, ⟨_, ⟨h, rfl⟩⟩⟩, _⟩
rintro ⟨⟨⟨r, s'⟩, ⟨h₁, rfl⟩⟩, ⟨⟨r', s⟩, ⟨h₂, rfl⟩⟩⟩
simpa using I.add_mem (I.mul_mem_left (1, 0) h₁) (I.mul_mem_left (0, 1) h₂)
intros
rintros ⟨x⟩
obtain ⟨p, ⟨p_monic, hpx⟩⟩ := hf x
refine ⟨p.map (ideal.quotient.mk _), ⟨monic_map _ p_monic, _⟩⟩
simpa only [hom_eval₂, eval₂_map] using congr_arg (ideal.quotient.mk I) hpx
intros
simp only [coeff_integer_normalization, h, mem_support_iff, eq_self_iff_true, not_true, ne.def, dif_neg, not_false_iff]
intros
simp [to_fun_alg_hom, alg_hom_of_linear_map_tensor_product, to_fun_linear]
refl
intros
by_cases hx0 : x = 0
rw [hx0, zero_add]
{ rw [hx0, zero_add], exact le_max_right _ _ }
exact le_max_right _ _
by_cases hy0 : y = 0
rw [hy0, add_zero]
{ rw [hy0, add_zero], exact le_max_left _ _ }
exact le_max_left _ _
by_cases hxy0 : x + y = 0
rw [hxy0, pre_val_zero]
{ rw [hxy0, pre_val_zero], exact zero_le _ }
exact zero_le _
obtain ⟨r, rfl⟩ := ideal.quotient.mk_surjective x
obtain ⟨s, rfl⟩ := ideal.quotient.mk_surjective y
rw ← ring_hom.map_add at hxy0 ⊢
rw [pre_val_mk hx0, pre_val_mk hy0, pre_val_mk hxy0, ring_hom.map_add]
exact v.map_add _ _
intros
assume i hi
simp only [frange, set.mem_image, mem_support_iff, ne.def, finset.mem_coe, finset.coe_image] at hi
rcases hi with ⟨n, hn, h'n⟩
rw [← h'n, coeff_of_subring]
exact subtype.mem (coeff p n : T)
intros
rw [monomial_eq_C_mul_X, content_C_mul, content_X_pow, mul_one]
{ rw [monomial_eq_C_mul_X, content_C_mul, content_X_pow, mul_one] }
intros
simp [coeff_mul_of_lt_order h, mul_sub]
intros
{ rw [← coeff_zero_eq_constant_coeff_apply, coeff_exp], simp }
rw [← coeff_zero_eq_constant_coeff_apply, coeff_exp]
simp
intros
refine ⟨_, h.pow_of_coprime i⟩
intro hi
obtain ⟨a, ha⟩ := i.gcd_dvd_left k
obtain ⟨b, hb⟩ := i.gcd_dvd_right k
suffices : b = k
rwa [this, ← one_mul k, nat.mul_left_inj h0, eq_comm] at hb { occs := occurrences.pos [1] }
{ rwa [this, ← one_mul k, nat.mul_left_inj h0, eq_comm] at hb { occs := occurrences.pos [1] } }
rw [ha] at hi
rw [mul_comm] at hb
apply nat.dvd_antisymm ⟨i.gcd k, hb⟩ (hi.dvd_of_pow_eq_one b _)
rw [← pow_mul', ← mul_assoc, ← hb, pow_mul, h.pow_eq_one, one_pow]
intros
ext
{ ext, rw [linear_map.comp_apply, linear_map.restrict_scalars_apply, trace_trace_of_basis b c] }
rw [linear_map.comp_apply, linear_map.restrict_scalars_apply, trace_trace_of_basis b c]
intros
have := valuation.map_add_of_distinct_val v (ne_of_gt h).symm
rw max_eq_right (le_of_lt h) at this
simpa using this
intros
rw witt_structure_rat
intros x hx
simp only [finset.mem_product, true_and, finset.mem_univ, finset.mem_range]
obtain ⟨k, hk, hx'⟩ := mem_vars_bind₁ _ _ hx
obtain ⟨i, -, hx''⟩ := mem_vars_bind₁ _ _ hx'
obtain ⟨j, hj, rfl⟩ := mem_vars_rename _ _ hx''
rw [witt_polynomial_vars, finset.mem_range] at hj
replace hk := X_in_terms_of_W_vars_subset p _ hk
rw finset.mem_range at hk
exact lt_of_lt_of_le hj hk
intros
rw [verschiebung_fun_coeff, if_pos rfl]
intros
{ rw [bUnion_eq_Union], apply mk_Union_le }
rw [bUnion_eq_Union]
apply mk_Union_le
rw [← nonpos_iff_eq_zero, ← aleph'_aleph_idx 0, aleph'_le]
rw [← nonpos_iff_eq_zero, ← aleph'_aleph_idx 0, aleph'_le]; apply ordinal.zero_le
apply ordinal.zero_le
intros
simp [← bit1_zero]
intros
{ apply sup_lt_ord _ _ H2, rw [hc.2], exact H1 }
apply sup_lt_ord _ _ H2
rw [hc.2]
exact H1
intros
induction l₁
exact subset.nil
{exact subset.nil}
refine subset.cons (lists.equiv.refl _) _ (l₁_ih (list.subset_of_cons_subset h))
simp at h
simp [h]
intros
{ rw [lt_ord], apply cardinal.lt_succ_self }
rw [lt_ord]
apply cardinal.lt_succ_self
intros
simpa only [zero_add] using add_sub_cancel 0 a
intros
rw [mul_le_mul_left, ←ha, ←hb, ←mul_assoc, ←mul_assoc, mul_comm bd, mul_le_mul_left]
exact mul_pos had hbd
exact one_div_pos.2 hgcd
intros
simp *
intros
rw ← h
rw ← h; simp
simp
intros
simp
simp; cc
cc
intros
cc
intros
induction xs with x xs generalizing k
{ cases hk' }
cases hk'
cases k
{ cases hk }
cases hk
have : sizeof xs < sizeof (x :: xs)
{ unfold_wf, linarith }
unfold_wf
linarith
cases k
{ simp only [this, list.drop] }
simp only [this, list.drop]
simp only [list.drop]
{ simp only [list.drop], transitivity, { solve_by_elim [xs_ih, lt_of_succ_lt_succ hk', zero_lt_succ] }, { assumption } }
transitivity
{ solve_by_elim [xs_ih, lt_of_succ_lt_succ hk', zero_lt_succ] }
solve_by_elim [xs_ih, lt_of_succ_lt_succ hk', zero_lt_succ]
{ assumption }
assumption
intros
rw [← is_open_compl_iff, is_open_iff_of_mem (mem_compl h), ← preimage_compl, compl_compl]
intros
rw ← nhds_within_univ
exact tendsto_nhds_within_mono_right (subset_univ _) (tendsto_ceil_right n)
intros
convert rel_supr_tsum m m0 R m_supr (λ b, cond b s₁ s₂)
{ simp only [supr_bool_eq, cond] }
simp only [supr_bool_eq, cond]
{ rw [tsum_fintype, fintype.sum_bool, cond, cond] }
rw [tsum_fintype, fintype.sum_bool, cond, cond]
intros
by_cases hf : summable f
{ exact tsum_le_of_sum_le hf h }
exact tsum_le_of_sum_le hf h
rw tsum_eq_zero_of_not_summable hf
{ rw tsum_eq_zero_of_not_summable hf, exact ha₂ }
exact ha₂
intros
simp only [coe_sum', finset.sum_apply]
intros
simp only [← finprod_subtype_eq_finprod_cond]
exact continuous_finprod (λ i, hc i i.2) (hf.comp_injective subtype.coe_injective)
intros
rw mem_nhds_within_Ici_iff_exists_Ico_subset
split
rintros ⟨u, au, as⟩
{ rintros ⟨u, au, as⟩, rcases exists_between au with ⟨v, hv⟩, exact ⟨v, hv.1, λx hx, as ⟨hx.1, lt_of_le_of_lt hx.2 hv.2⟩⟩ }
rcases exists_between au with ⟨v, hv⟩
exact ⟨v, hv.1, λx hx, as ⟨hx.1, lt_of_le_of_lt hx.2 hv.2⟩⟩
rintros ⟨u, au, as⟩
{ rintros ⟨u, au, as⟩, exact ⟨u, au, subset.trans Ico_subset_Icc_self as⟩ }
exact ⟨u, au, subset.trans Ico_subset_Icc_self as⟩
intros
{ rw [←closure_le_eq hf hg], exact closure_mono (λ b, le_of_lt) }
rw [←closure_le_eq hf hg]
exact closure_mono (λ b, le_of_lt)
intros
rw [← comap_coe_Ioo_nhds_within_Iio, tendsto_comap_iff]
intros
haveI : nonempty β := nonempty.intro b
exact ge_of_tendsto ha ((eventually_ge_at_top b).mono (λ _ hxy, hf hxy))
intros
simp only [continuous_within_at, nhds_within_Ioo_eq_nhds_within_Iio h]
intros
rw nhds
intros
simpa only [inter_comm] using closure_inter_open h
intros
refine le_antisymm (continuous_at_fst.mono_left inf_le_left) (λ s hs, _)
rcases x with ⟨x, y⟩
rw [mem_map, nhds_within, mem_inf_principal, mem_nhds_prod_iff] at hs
rcases hs with ⟨u, hu, v, hv, H⟩
simp only [prod_subset_iff, mem_singleton_iff, mem_set_of_eq, mem_preimage] at H
exact mem_of_superset hu (λ z hz, H _ hz _ (mem_of_mem_nhds hv) rfl)
intros
rw [pi_def, bInter_mem hi]
{ rw [pi_def, bInter_mem hi], exact λ a ha, (continuous_apply a).continuous_at (hs a ha) }
exact λ a ha, (continuous_apply a).continuous_at (hs a ha)
intros
simpa only [hs.closure_eq] using mem_closure_iff_nhds_within_ne_bot.2 hx
intros
ext ⟨⟩
{ ext ⟨⟩, refl }
refl
intros
rw [e.source_eq, mem_preimage]
intros
rcases eq_empty_or_nonempty s with rfl|hne
simp
{ simp }
refine le_antisymm (metric.ediam_le_of_forall_dist_le $ λ x hx y hy, _) _
have := real.subset_Icc_Inf_Sup_of_bounded h
{ have := real.subset_Icc_Inf_Sup_of_bounded h, exact real.dist_le_of_mem_Icc (this hx) (this hy) }
exact real.dist_le_of_mem_Icc (this hx) (this hy)
apply ennreal.of_real_le_of_le_to_real
{ apply ennreal.of_real_le_of_le_to_real, rw [← metric.diam, ← metric.diam_closure], have h' := real.bounded_iff_bdd_below_bdd_above.1 h, calc Sup s - Inf s ≤ dist (Sup s) (Inf s) : le_abs_self _ ... ≤ diam (closure s) : dist_le_diam_of_mem h.closure (cSup_mem_closure hne h'.2) (cInf_mem_closure hne h'.1) }
rw [← metric.diam, ← metric.diam_closure]
have h' := real.bounded_iff_bdd_below_bdd_above.1 h
calc Sup s - Inf s ≤ dist (Sup s) (Inf s) : le_abs_self _ ... ≤ diam (closure s) : dist_le_diam_of_mem h.closure (cSup_mem_closure hne h'.2) (cInf_mem_closure hne h'.1)
intros
by_cases h : summable f
{ rw [← ennreal.coe_tsum h, ennreal.to_nnreal_coe] }
rw [← ennreal.coe_tsum h, ennreal.to_nnreal_coe]
have A := tsum_eq_zero_of_not_summable h
{ have A := tsum_eq_zero_of_not_summable h, simp only [← ennreal.tsum_coe_ne_top_iff_summable, not_not] at h, simp only [h, ennreal.top_to_nnreal, A] }
simp only [← ennreal.tsum_coe_ne_top_iff_summable, not_not] at h
simp only [h, ennreal.top_to_nnreal, A]
intros
rw [nhds_list, list.traverse_nil _]; apply_instance
rw [nhds_list, list.traverse_nil _]
intros
ext
{ ext, refl }
refl
intros
rw [hf.induced, is_closed_induced_iff]
intros
simp only [dist_nndist, nnreal.coe_le_coe, nndist_le_pi_nndist f g b]
intros
refine filter.has_basis_cocompact.ge_iff.2 (λ s hs, mem_comap.2 _)
rcases hs.bounded.subset_ball x with ⟨r, hr⟩
exact ⟨Ioi r, Ioi_mem_at_top r, λ y hy hys, (mem_closed_ball.1 $ hr hys).not_lt hy⟩
intros
rw [ball_eq_empty]
intros
simp [continuous_on, continuous_within_at_iff']
intros
rw [mul_comm, ← div_eq_mul_inv]
exact ennreal.div_le_of_le_mul' (h x y)
intros
rw [nhds_induced, filter.map_comap, nhds_within]
intros
rw path.trans
apply eq_of_subset_of_subset
rintros x ⟨⟨t, ht0, ht1⟩, hxt⟩
{ rintros x ⟨⟨t, ht0, ht1⟩, hxt⟩, by_cases h : t ≤ 1/2, { left, use [2*t, ⟨by linarith, by linarith⟩], rw ← γ₁.extend_extends, unfold_coes at hxt, simp only [h, comp_app, if_true] at hxt, exact hxt }, { right, use [2*t-1, ⟨by linarith, by linarith⟩], rw ← γ₂.extend_extends, unfold_coes at hxt, simp only [h, comp_app, if_false] at hxt, exact hxt } }
by_cases h : t ≤ 1/2
left
{ left, use [2*t, ⟨by linarith, by linarith⟩], rw ← γ₁.extend_extends, unfold_coes at hxt, simp only [h, comp_app, if_true] at hxt, exact hxt }
use [2*t, ⟨by linarith, by linarith⟩]
rw ← γ₁.extend_extends
unfold_coes at hxt
simp only [h, comp_app, if_true] at hxt
exact hxt
right
{ right, use [2*t-1, ⟨by linarith, by linarith⟩], rw ← γ₂.extend_extends, unfold_coes at hxt, simp only [h, comp_app, if_false] at hxt, exact hxt }
use [2*t-1, ⟨by linarith, by linarith⟩]
rw ← γ₂.extend_extends
unfold_coes at hxt
simp only [h, comp_app, if_false] at hxt
exact hxt
rintros x (⟨⟨t, ht0, ht1⟩, hxt⟩ | ⟨⟨t, ht0, ht1⟩, hxt⟩)
{ rintros x (⟨⟨t, ht0, ht1⟩, hxt⟩ | ⟨⟨t, ht0, ht1⟩, hxt⟩), { use ⟨t/2, ⟨by linarith, by linarith⟩⟩, unfold_coes, have : t/2 ≤ 1/2 := by linarith, simp only [this, comp_app, if_true], ring_nf, rwa γ₁.extend_extends }, { by_cases h : t = 0, { use ⟨1/2, ⟨by linarith, by linarith⟩⟩, unfold_coes, simp only [h, comp_app, if_true, le_refl, mul_one_div_cancel (@two_ne_zero ℝ _ _)], rw γ₁.extend_one, rwa [← γ₂.extend_extends, h, γ₂.extend_zero] at hxt }, { use ⟨(t+1)/2, ⟨by linarith, by linarith⟩⟩, unfold_coes, change t ≠ 0 at h, have ht0 := lt_of_le_of_ne ht0 h.symm, have : ¬ (t+1)/2 ≤ 1/2 := by {rw not_le, linarith}, simp only [comp_app, if_false, this], ring_nf, rwa γ₂.extend_extends } } }
use ⟨t/2, ⟨by linarith, by linarith⟩⟩
{ use ⟨t/2, ⟨by linarith, by linarith⟩⟩, unfold_coes, have : t/2 ≤ 1/2 := by linarith, simp only [this, comp_app, if_true], ring_nf, rwa γ₁.extend_extends }
unfold_coes
have : t/2 ≤ 1/2 := by linarith
simp only [this, comp_app, if_true]
ring_nf
rwa γ₁.extend_extends
by_cases h : t = 0
{ by_cases h : t = 0, { use ⟨1/2, ⟨by linarith, by linarith⟩⟩, unfold_coes, simp only [h, comp_app, if_true, le_refl, mul_one_div_cancel (@two_ne_zero ℝ _ _)], rw γ₁.extend_one, rwa [← γ₂.extend_extends, h, γ₂.extend_zero] at hxt }, { use ⟨(t+1)/2, ⟨by linarith, by linarith⟩⟩, unfold_coes, change t ≠ 0 at h, have ht0 := lt_of_le_of_ne ht0 h.symm, have : ¬ (t+1)/2 ≤ 1/2 := by {rw not_le, linarith}, simp only [comp_app, if_false, this], ring_nf, rwa γ₂.extend_extends } }
use ⟨1/2, ⟨by linarith, by linarith⟩⟩
{ use ⟨1/2, ⟨by linarith, by linarith⟩⟩, unfold_coes, simp only [h, comp_app, if_true, le_refl, mul_one_div_cancel (@two_ne_zero ℝ _ _)], rw γ₁.extend_one, rwa [← γ₂.extend_extends, h, γ₂.extend_zero] at hxt }
unfold_coes
simp only [h, comp_app, if_true, le_refl, mul_one_div_cancel (@two_ne_zero ℝ _ _)]
rw γ₁.extend_one
rwa [← γ₂.extend_extends, h, γ₂.extend_zero] at hxt
use ⟨(t+1)/2, ⟨by linarith, by linarith⟩⟩
{ use ⟨(t+1)/2, ⟨by linarith, by linarith⟩⟩, unfold_coes, change t ≠ 0 at h, have ht0 := lt_of_le_of_ne ht0 h.symm, have : ¬ (t+1)/2 ≤ 1/2 := by {rw not_le, linarith}, simp only [comp_app, if_false, this], ring_nf, rwa γ₂.extend_extends }
unfold_coes
change t ≠ 0 at h
have ht0 := lt_of_le_of_ne ht0 h.symm
have : ¬ (t+1)/2 ≤ 1/2 := by {rw not_le, linarith}
simp only [comp_app, if_false, this]
ring_nf
rwa γ₂.extend_extends
intros
have : is_path_connected (univ : set X) := path_connected_space_iff_univ.mp (by apply_instance)
rcases this.exists_path_through_family p (λ i, true.intro) with ⟨γ, -, h⟩
exact ⟨γ, h⟩
intros
split
introI h
{ introI h, exact tot_sep_of_zero_dim loc_compact_Haus_tot_disc_of_zero_dim, }
exact tot_sep_of_zero_dim loc_compact_Haus_tot_disc_of_zero_dim
apply totally_separated_space.totally_disconnected_space
intros
{ rw find, split_ifs, exacts [h.some_spec.fst, ne.some_spec] }
rw find
split_ifs
exacts [h.some_spec.fst, ne.some_spec]
intros
rw (filter.has_basis_cocompact.comap f).le_basis_iff filter.has_basis_cocompact
intros t ht
refine ⟨f '' t, ht.image hf, _⟩
simpa using t.subset_preimage_image f
intros
refine tendsto_nhds_unique (c.tendsto_approx_at_top x) ((tendsto_add_at_top_iff_nat 1).1 _)
simp only [approx]
exact (c.left.tendsto_approx_at_top x).midpoint (c.right.tendsto_approx_at_top x)
intros
rw [corec_def, map_eq, head_iterate, tail_iterate]
refl
intros
unfold inits_core corec_on
rw [corec_eq]
refl
contradiction
intros
{cases a with n n, cases n; refl, refl}
cases a with n n
cases n
cases n; refl
refl
refl
refl
intros
have h := int.add_lt_add_right h (-b)
rwa int.add_right_neg at h
intros
have h := int.add_lt_add_right h (-c)
rwa int.add_neg_cancel_right at h
intros
induction s; simp [*, or_assoc]
induction s
simp [*, or_assoc]
simp [*, or_assoc]
intros
cases nat.eq_zero_or_pos n with h₀ h₀
{ rw [h₀, nat.div_zero, nat.div_zero, nat.zero_sub] }
rw [h₀, nat.div_zero, nat.div_zero, nat.zero_sub]
induction p with p
{ induction p with p, { rw [nat.mul_zero, nat.sub_zero, nat.sub_zero] }, { have h₂ : n*p ≤ x, { transitivity, { apply nat.mul_le_mul_left, apply le_succ }, { apply h₁ } }, have h₃ : x - n * p ≥ n, { apply nat.le_of_add_le_add_right, rw [nat.sub_add_cancel h₂, nat.add_comm], rw [mul_succ] at h₁, apply h₁ }, rw [sub_succ, ← p_ih h₂], rw [@div_eq_sub_div (x - n*p) _ h₀ h₃], simp [add_one, pred_succ, mul_succ, nat.sub_sub] } }
{ rw [nat.mul_zero, nat.sub_zero, nat.sub_zero] }
rw [nat.mul_zero, nat.sub_zero, nat.sub_zero]
have h₂ : n*p ≤ x
{ have h₂ : n*p ≤ x, { transitivity, { apply nat.mul_le_mul_left, apply le_succ }, { apply h₁ } }, have h₃ : x - n * p ≥ n, { apply nat.le_of_add_le_add_right, rw [nat.sub_add_cancel h₂, nat.add_comm], rw [mul_succ] at h₁, apply h₁ }, rw [sub_succ, ← p_ih h₂], rw [@div_eq_sub_div (x - n*p) _ h₀ h₃], simp [add_one, pred_succ, mul_succ, nat.sub_sub] }
transitivity
{ transitivity, { apply nat.mul_le_mul_left, apply le_succ }, { apply h₁ } }
apply nat.mul_le_mul_left
{ apply nat.mul_le_mul_left, apply le_succ }
apply le_succ
apply h₁
{ apply h₁ }
have h₃ : x - n * p ≥ n
apply nat.le_of_add_le_add_right
{ apply nat.le_of_add_le_add_right, rw [nat.sub_add_cancel h₂, nat.add_comm], rw [mul_succ] at h₁, apply h₁ }
rw [nat.sub_add_cancel h₂, nat.add_comm]
rw [mul_succ] at h₁
apply h₁
rw [sub_succ, ← p_ih h₂]
rw [@div_eq_sub_div (x - n*p) _ h₀ h₃]
simp [add_one, pred_succ, mul_succ, nat.sub_sub]
intros
rw [nat.mul_comm m k, nat.mul_comm n k] at H; exact dvd_of_mul_dvd_mul_left kpos H
rw [nat.mul_comm m k, nat.mul_comm n k] at H
exact dvd_of_mul_dvd_mul_left kpos H
intros
rw [nat.add_comm, nat.add_sub_of_le h]
intros
rw [nat.mul_comm, mul_pred_left, nat.mul_comm]
intros
rw [vsub_vadd_eq_vsub_sub, vadd_vsub_assoc, add_sub_cancel']
intros
simp [bit0, add_smul, smul_add]
intros
ext
ext; simp
simp
intros
induction n with k hk
{ simp only [h0, finset.prod_range_zero] }
simp only [h0, finset.prod_range_zero]
{ simp only [hk, finset.prod_range_succ, h, mul_comm] }
simp only [hk, finset.prod_range_succ, h, mul_comm]
intros
lift s to finset α using hs
lift t to finset β using ht
simp only [finprod_mem_coe_finset]
exact finset.prod_comm
intros
exact_mod_cast n.succ_ne_zero
intros
change s.nth (n + 1) = none at terminated_at_succ_n
cases s_nth_eq : (s.nth n); simp only [*, squash_seq]
cases s_nth_eq : (s.nth n)
simp only [*, squash_seq]
simp only [*, squash_seq]
intros
rw [terminated_at_iff_s_none, part_denom_none_iff_s_none]
intros
rw [← mul_div_mul_right _ b hd, ← mul_div_mul_left c d hb, div_add_div_same]
intros
simp [gcd_def]
intros
simp [h]
intros
rw [sub_eq_add_neg, neg_add a b]
intros
rw [← powers_hom_symm_apply, ← powers_hom_apply, equiv.apply_symm_apply]
intros
simpa only [sq_abs] using pow_lt_pow_of_lt_left h (abs_nonneg x) (1:ℕ).succ_pos
intros
rw [div_eq_mul_inv, mul_inv_cancel h]
intros
rw [mul_comm, div_mul_cancel_of_imp h]
intros
simp [single_map_homological_complex, h]
intros
{ dsimp [of], rw [if_pos rfl, category.comp_id] }
dsimp [of]
rw [if_pos rfl, category.comp_id]
intros
{ ext, simp [image_to_kernel'], }
ext
simp [image_to_kernel']
intros
rw [← mul_indicator_mul_indicator, mul_indicator_mul_support]
intros
simp
intros
rw ← f.ker_eq_bot at h₁
change comap f ⊥ = ⊥ at h₁
rw [eq_bot_iff, map_le_iff_le_comap, h₁] at h₂
rw eq_bot_iff
exact h₂
intros
ext x
let f : H → module.End R L := λ y, to_endomorphism R H L y - (χ y) • 1
let g : H → module.End R H := λ y, to_endomorphism R H H y - (χ y) • 1
suffices : (∀ (y : H), ∃ (k : ℕ), ((f y)^k).comp (H.incl : H →ₗ[R] L) x = 0) ↔ ∀ (y : H), ∃ (k : ℕ), (H.incl : H →ₗ[R] L).comp ((g y)^k) x = 0
simp only [lie_hom.coe_to_linear_map, lie_subalgebra.coe_incl, function.comp_app, linear_map.coe_comp, submodule.coe_eq_zero] at this
{ simp only [lie_hom.coe_to_linear_map, lie_subalgebra.coe_incl, function.comp_app, linear_map.coe_comp, submodule.coe_eq_zero] at this, simp only [mem_weight_space, mem_pre_weight_space, lie_subalgebra.coe_incl', lie_submodule.mem_comap, this], }
simp only [mem_weight_space, mem_pre_weight_space, lie_subalgebra.coe_incl', lie_submodule.mem_comap, this]
have hfg : ∀ (y : H), (f y).comp (H.incl : H →ₗ[R] L) = (H.incl : H →ₗ[R] L).comp (g y)
rintros ⟨y, hz⟩
{ rintros ⟨y, hz⟩, ext ⟨z, hz⟩, simp only [submodule.coe_sub, to_endomorphism_apply_apply, lie_hom.coe_to_linear_map, linear_map.one_apply, lie_subalgebra.coe_incl, lie_subalgebra.coe_bracket_of_module, lie_subalgebra.coe_bracket, linear_map.smul_apply, function.comp_app, submodule.coe_smul_of_tower, linear_map.coe_comp, linear_map.sub_apply], }
ext ⟨z, hz⟩
simp only [submodule.coe_sub, to_endomorphism_apply_apply, lie_hom.coe_to_linear_map, linear_map.one_apply, lie_subalgebra.coe_incl, lie_subalgebra.coe_bracket_of_module, lie_subalgebra.coe_bracket, linear_map.smul_apply, function.comp_app, submodule.coe_smul_of_tower, linear_map.coe_comp, linear_map.sub_apply]
simp_rw [linear_map.commute_pow_left_of_commute (hfg _)]
intros
{ ext, rw [single_one_mul_apply, mul_single_one_apply, mul_comm] }
ext
rw [single_one_mul_apply, mul_single_one_apply, mul_comm]
intros
rintro ⟨f, _⟩ ⟨g, _⟩ ⟨h⟩; congr
rintro ⟨f, _⟩ ⟨g, _⟩ ⟨h⟩
congr
intros
simpa using inv_lt_of_neg ha hb
intros
rw [← mul_lt_mul_iff_right c, div_eq_mul_inv, inv_mul_cancel_right]
intros
norm_cast
intros
rw [mul_comm, ha.le_mul_iff_one_le_right]
intros
haveI := @linear_order.decidable_le α _; exact ⟨le_imp_le_of_lt_imp_lt $ λ h', mul_lt_mul_of_neg_right h' h, λ h', decidable.mul_le_mul_of_nonpos_right h' h.le⟩
haveI := @linear_order.decidable_le α _
exact ⟨le_imp_le_of_lt_imp_lt $ λ h', mul_lt_mul_of_neg_right h' h, λ h', decidable.mul_le_mul_of_nonpos_right h' h.le⟩
intros
lift a to α using ne_bot_of_gt ha
lift b to α using ne_bot_of_gt hb
simp only [← coe_mul, bot_lt_coe]
intros
rw [bit0, ← two_mul, zero_lt_mul_left (zero_lt_two : 0 < (2:α))]
intros
simp only [eq_neg_iff_eq_neg.mp (h (x - c)), sub_add_cancel]
intros
simp only [← image2_mul, image2_swap _ s, mul_comm]
intros
simpa using leading_coeff_multiset_prod (s.1.map f)
intros
simp [right_distrib]
intros
ext f
rw [vanishing_ideal, set_like.mem_coe, submodule.mem_infi]
apply forall_congr
intro x
rw [submodule.mem_infi]
intros
{ cases x, refl }
cases x
refl
intros
dsimp [δ, σ]
simp only [←X.map_comp, simplex_category.δ_comp_σ_succ, X.map_id]
intros
{ cases n, { refl }, cases n, { contradiction }, refl }
cases n
refl
{ refl }
cases n
contradiction
{ contradiction }
refl
intros
refine ((h₁.norm_norm.mul h₂.norm_norm).congr _ _).of_norm_norm
refine ((h₁.norm_norm.mul h₂.norm_norm).congr _ _).of_norm_norm; by intros; simp only [norm_smul]
intros; simp only [norm_smul]
intros; simp only [norm_smul]
intros
intros
simp only [norm_smul]
simp only [norm_smul]
intros; simp only [norm_smul]
intros; simp only [norm_smul]
intros
intros
simp only [norm_smul]
simp only [norm_smul]
intros
{ unfold is_O_with, exact mem_map }
unfold is_O_with
exact mem_map
intros
rw is_O_with
rw is_O_with; refl
refl
intros
rw has_strict_deriv_at at hh₁
{ rw has_strict_deriv_at at hh₁, convert hh₁.comp x hf, ext x, simp [mul_comm] }
convert hh₁.comp x hf
ext x
simp [mul_comm]
intros
simp [div_eq_inv_mul, differentiable_within_at.const_mul, hc]
intros
simp only [has_deriv_within_at_iff_tendsto_slope, sdiff_idem]
intros
simpa only [sub_eq_add_neg] using hf.neg.const_add c
intros
rw [← e.image_symm_eq_preimage, e.symm.unique_diff_on_image_iff]
intros
simp [iterated_deriv_within, iterated_fderiv_within_one_apply hs hx]
{ simp [iterated_deriv_within, iterated_fderiv_within_one_apply hs hx], refl }
refl
intros
have hdf : ∀ x ∈ Iio a, differentiable_at ℝ f x
from λ x hx, (hdf x hx).differentiable_at (Iio_mem_nhds hx)
have hdg : ∀ x ∈ Iio a, differentiable_at ℝ g x
from λ x hx, classical.by_contradiction (λ h, hg' x hx (deriv_zero_of_not_differentiable_at h))
exact has_deriv_at.lhopital_zero_at_bot_on_Iio (λ x hx, (hdf x hx).has_deriv_at) (λ x hx, (hdg x hx).has_deriv_at) hg' hfbot hgbot hdiv
intros
apply (f_aux_deriv n x (ne_of_gt hx)).congr_of_eventually_eq
filter_upwards [lt_mem_nhds hx]
assume y hy
simp [f_aux, hy.not_le]
intros
apply times_cont_diff_of_differentiable_iterated_fderiv (λm hm, _)
rw iterated_fderiv_within_zero_fun
apply differentiable_const (0 : (E [×m]→L[𝕜] F))
intros
simpa only [sub_eq_add_neg] using hf.add hg.neg
intros
intros m hm
rcases h m hm with ⟨u, u_mem, p', hp'⟩
exact ⟨u, u_mem, _, hp'.restrict_scalars _⟩
intros
simp [is_R_or_C.abs, complex.abs]
intros
simpa only [nat.cast_one, one_div] using is_primitive_root_exp_of_coprime 1 n h0 n.coprime_one_left
intros
rintro z ⟨a, b, ha, hb, hab, rfl⟩
split
calc x = a • x + b • x : by rw [←add_smul, hab, one_smul] ... < a • x + b • y : add_lt_add_left (smul_lt_smul_of_pos h hb) _
calc a • x + b • y < a • y + b • y : add_lt_add_right (smul_lt_smul_of_pos h ha) _ ... = y : by rw [←add_smul, hab, one_smul]
intros
apply h.segment_subset hx hy
rw segment_eq_image'
exact mem_image_of_mem _ ht
intros
refl
intros
refine ⟨hf.left, λ x y hx hy a b ha hb hab, sup_le _ _⟩
calc f (a • x + b • y) ≤ a • f x + b • f y : hf.right hx hy ha hb hab ... ≤ a • (f x ⊔ g x) + b • (f y ⊔ g y) : add_le_add (smul_le_smul_of_nonneg le_sup_left ha) (smul_le_smul_of_nonneg le_sup_left hb)
{ calc f (a • x + b • y) ≤ a • f x + b • f y : hf.right hx hy ha hb hab ... ≤ a • (f x ⊔ g x) + b • (f y ⊔ g y) : add_le_add (smul_le_smul_of_nonneg le_sup_left ha) (smul_le_smul_of_nonneg le_sup_left hb) }
calc g (a • x + b • y) ≤ a • g x + b • g y : hg.right hx hy ha hb hab ... ≤ a • (f x ⊔ g x) + b • (f y ⊔ g y) : add_le_add (smul_le_smul_of_nonneg le_sup_right ha) (smul_le_smul_of_nonneg le_sup_right hb)
{ calc g (a • x + b • y) ≤ a • g x + b • g y : hg.right hx hy ha hb hab ... ≤ a • (f x ⊔ g x) + b • (f y ⊔ g y) : add_le_add (smul_le_smul_of_nonneg le_sup_right ha) (smul_le_smul_of_nonneg le_sup_right hb) }
intros
have A : deriv (λ (x : ℝ), x ^ p) = λ x, p * x^(p-1)
ext x
ext x
{ ext x, simp [hp] }
{ ext x, simp [hp] }
simp [hp]
simp [hp]
apply convex_on_of_deriv2_nonneg (convex_Ici 0)
exact continuous_on_id.rpow_const (λ x _, or.inr (zero_le_one.trans hp))
{ exact continuous_on_id.rpow_const (λ x _, or.inr (zero_le_one.trans hp)) }
exact (differentiable_rpow_const hp).differentiable_on
{ exact (differentiable_rpow_const hp).differentiable_on }
rw A
{ rw A, assume x hx, replace hx : x ≠ 0, by { simp at hx, exact ne_of_gt hx }, simp [differentiable_at.differentiable_within_at, hx] }
assume x hx
replace hx : x ≠ 0
simp at hx
simp at hx
{ simp at hx, exact ne_of_gt hx }
{ simp at hx, exact ne_of_gt hx }
exact ne_of_gt hx
exact ne_of_gt hx
simp [differentiable_at.differentiable_within_at, hx]
assume x hx
{ assume x hx, replace hx : 0 < x, by simpa using hx, suffices : 0 ≤ p * ((p - 1) * x ^ (p - 1 - 1)), by simpa [ne_of_gt hx, A], apply mul_nonneg (le_trans zero_le_one hp), exact mul_nonneg (sub_nonneg_of_le hp) (rpow_nonneg_of_nonneg (le_of_lt hx) _) }
replace hx : 0 < x
simpa using hx
simpa using hx
suffices : 0 ≤ p * ((p - 1) * x ^ (p - 1 - 1))
simpa [ne_of_gt hx, A]
simpa [ne_of_gt hx, A]
apply mul_nonneg (le_trans zero_le_one hp)
exact mul_nonneg (sub_nonneg_of_le hp) (rpow_nonneg_of_nonneg (le_of_lt hx) _)
intros
rw [norm_add_mul_self, add_right_cancel_iff, add_right_eq_self, mul_eq_zero]
apply or.inr
simp only [h, zero_re']
intros
apply le_antisymm
rw le_infi_iff
{ rw le_infi_iff, rintros ⟨v, hv⟩ w hw, simpa using hw _ hv }
rintros ⟨v, hv⟩ w hw
simpa using hw _ hv
intros v hv w hw
{ intros v hv w hw, simp only [submodule.mem_infi] at hv, exact hv ⟨w, hw⟩ }
simp only [submodule.mem_infi] at hv
exact hv ⟨w, hw⟩
intros
rw [←inner_conj_sym, inner_smul_left, ring_hom.map_mul, conj_conj, inner_conj_sym]
intros
rw orthonormal_iff_ite
split
intros h v hv w hw
{ intros h v hv w hw, convert h ⟨v, hv⟩ ⟨w, hw⟩ using 1, simp }
convert h ⟨v, hv⟩ ⟨w, hw⟩ using 1
simp
rintros h ⟨v, hv⟩ ⟨w, hw⟩
{ rintros h ⟨v, hv⟩ ⟨w, hw⟩, convert h v hv w hw using 1, simp }
convert h v hv w hw using 1
simp
intros
obtain ⟨y, hy, z, hz, hwyz⟩ := K.exists_sum_mem_mem_orthogonal w
convert hwyz
exact eq_orthogonal_projection_of_mem_orthogonal' hy hz hwyz
{ exact eq_orthogonal_projection_of_mem_orthogonal' hy hz hwyz }
rw add_comm at hwyz
{ rw add_comm at hwyz, refine eq_orthogonal_projection_of_mem_orthogonal' hz _ hwyz, simp [hy] }
refine eq_orthogonal_projection_of_mem_orthogonal' hz _ hwyz
simp [hy]
intros
rw [midpoint, ← homothety_eq_line_map, dist_center_homothety, inv_of_eq_inv, ← normed_field.norm_inv]
intros
ext
{ ext, refl }
refl
intros
simpa [dist_eq_norm] using abs_dist_sub_le g h 0
intros
simp only [lipschitz_with_iff_dist_le_mul, dist_eq_norm]
intros
rcases h.bound with ⟨C, Cpos : 0 < C, hC⟩
refine is_linear_map.with_bound ⟨λ p₁ p₂, _, λ c p, _⟩ (C + C) (λ p, _)
{ ext; simp [h.add_left, h.add_right]; abel }
ext
ext; simp [h.add_left, h.add_right]; abel
ext; simp [h.add_left, h.add_right]
simp [h.add_left, h.add_right]
abel
simp [h.add_left, h.add_right]
abel
{ ext; simp [h.smul_left, h.smul_right, smul_add] }
ext
ext; simp [h.smul_left, h.smul_right, smul_add]
simp [h.smul_left, h.smul_right, smul_add]
simp [h.smul_left, h.smul_right, smul_add]
refine continuous_linear_map.op_norm_le_bound _ (mul_nonneg (add_nonneg Cpos.le Cpos.le) (norm_nonneg _)) (λ q, _)
{ refine continuous_linear_map.op_norm_le_bound _ (mul_nonneg (add_nonneg Cpos.le Cpos.le) (norm_nonneg _)) (λ q, _), calc ∥f (p.1, q.2) + f (q.1, p.2)∥ ≤ C * ∥p.1∥ * ∥q.2∥ + C * ∥q.1∥ * ∥p.2∥ : norm_add_le_of_le (hC _ _) (hC _ _) ... ≤ C * ∥p∥ * ∥q∥ + C * ∥q∥ * ∥p∥ : by apply_rules [add_le_add, mul_le_mul, norm_nonneg, Cpos.le, le_refl, le_max_left, le_max_right, mul_nonneg] ... = (C + C) * ∥p∥ * ∥q∥ : by ring }
calc ∥f (p.1, q.2) + f (q.1, p.2)∥ ≤ C * ∥p.1∥ * ∥q.2∥ + C * ∥q.1∥ * ∥p.2∥ : norm_add_le_of_le (hC _ _) (hC _ _) ... ≤ C * ∥p∥ * ∥q∥ + C * ∥q∥ * ∥p∥ : by apply_rules [add_le_add, mul_le_mul, norm_nonneg, Cpos.le, le_refl, le_max_left, le_max_right, mul_nonneg] ... = (C + C) * ∥p∥ * ∥q∥ : by ring
intros
change summable (norm ∘ _)
rw ← exp_series_apply_eq_field'
exact norm_exp_series_summable_of_mem_ball x hx
intros
apply coe_inj
intros
refine le_antisymm _ (norm_nonneg _)
apply op_norm_le_bound _ rfl.ge
intros x
simp [subsingleton.elim x 0]
intros
convert add_le_add_left (le_sum_condensed' hf n) (f 0)
rw [← sum_range_add_sum_Ico _ n.one_le_two_pow, sum_range_succ, sum_range_zero, zero_add]
intros
simp [bernstein_approximation]
intros
rw [← tendsto_map'_iff, map_exp_at_top]
intros
rw ← has_deriv_within_at_univ at *
exact hf.log hx
intros
rw ← has_deriv_within_at_univ at *
exact hf.rpow hg h
intros
{ rw ← one_rpow z, exact rpow_le_rpow hx1 hx2 hz }
rw ← one_rpow z
exact rpow_le_rpow hx1 hx2 hz
intros
rcases ne_or_eq x 0 with hx | rfl
exact (has_strict_deriv_at_rpow_const_of_ne hx _).has_deriv_at
{ exact (has_strict_deriv_at_rpow_const_of_ne hx _).has_deriv_at }
replace h : 1 ≤ p := h.neg_resolve_left rfl
apply has_deriv_at_of_has_deriv_at_of_ne (λ x hx, (has_strict_deriv_at_rpow_const_of_ne hx p).has_deriv_at)
exacts [continuous_at_id.rpow_const (or.inr (zero_le_one.trans h)), continuous_at_const.mul (continuous_at_id.rpow_const (or.inr (sub_nonneg.2 h)))]
simp [two_mul, cos_add]
{ rw real.range_cos, exact Icc.infinite (by norm_num) }
rw real.range_cos
exact Icc.infinite (by norm_num)
rw [tan_eq_sin_div_cos, cos_pi_div_four, sin_pi_div_four]
have h : (sqrt 2) / 2 > 0 := by cancel_denoms
exact div_self (ne_of_gt h)
intros
rw [← not_exists, not_iff_not, cos_eq_zero_iff]
simp [arccos, add_halves]
intros
rcases exists_between hl₁ with ⟨r, hr₀, hr₁⟩
refine summable_of_ratio_norm_eventually_le hr₁ _
filter_upwards [eventually_le_of_tendsto_lt hr₀ h, hf]
intros n h₀ h₁
rwa ← div_le_iff (norm_pos_iff.mpr h₁)
intros
simp
intros
{ convert cancel_epi f, simp, }
convert cancel_epi f
simp
intros
{ rw [α.naturality_assoc], simp }
rw [α.naturality_assoc]
simp
intros
{ cases E, congr, }
cases E
congr
intros
ext
{ ext, simp, }
simp
intros
rw [←cancel_epi (limit_iso_limit_curry_comp_lim G).hom]
simp
intros
ext
simp only [whisker_right_app, lim_map_π, assoc, limit.post_π_assoc, limit.post_π, ← H.map_comp]
intros
simp
intros
simp
intros
rw biprod.map_eq_map'
exact is_colimit.ι_map (binary_biproduct.is_colimit W X) _ _ walking_pair.right
intros
rw [(has_zero_object.unique_from X).uniq f, (has_zero_object.unique_from X).uniq g]
intros
rw [←tensor_comp, f.hom_inv_id]
intros
{ cases f, cases g, congr, exact w, }
cases f
cases g
congr
exact w
intros
dsimp [tensor_hom]
apply is_limit.hom_ext (ℬ _ _).is_limit
rintro ⟨⟩
{ simp, }
simp
apply is_limit.hom_ext (ℬ _ _).is_limit
{ apply is_limit.hom_ext (ℬ _ _).is_limit, rintro ⟨⟩, { simp, }, { simp, }, }
rintro ⟨⟩
{ simp, }
simp
{ simp, }
simp
intros
simp only [cancel_mono]
intros
rw [← not_nonempty_iff, ← not_congr (finrank_hom_simple_simple_eq_one_iff 𝕜 X Y)]
refine ⟨λ h, by { rw h, simp, }, λ h, _⟩
have := finrank_hom_simple_simple_le_one 𝕜 X Y
interval_cases finrank 𝕜 (X ⟶ Y) with h'
{ exact h', }
exact h'
{ exact false.elim (h h'), }
exact false.elim (h h')
intros
classical
by_contradiction h
haveI := is_iso_of_epi_of_nonzero h
exact w (eq_zero_of_mono_cokernel f)
intros
rw [is_separated_for, ←forall_and_distrib]
apply forall_congr
intro x
split
intros z hx
{ intros z hx, exact exists_unique_of_exists_of_unique (z.2 hx) z.1 }
exact exists_unique_of_exists_of_unique (z.2 hx) z.1
intros h
{ intros h, refine ⟨_, (exists_of_exists_unique ∘ h)⟩, intros t₁ t₂ ht₁ ht₂, apply (h _).unique ht₁ ht₂, exact is_compatible_of_exists_amalgamation x ⟨_, ht₂⟩ }
refine ⟨_, (exists_of_exists_unique ∘ h)⟩
intros t₁ t₂ ht₁ ht₂
apply (h _).unique ht₁ ht₂
exact is_compatible_of_exists_amalgamation x ⟨_, ht₂⟩
intros
{ rw eq_mk h, simp, }
rw eq_mk h
simp
intros
simp [of_mk_le, of_le_mk, of_le, of_mk_le_mk, ←functor.map_comp_assoc underlying]
intros
convert underlying_iso_hom_comp_eq_mk (𝟙 B)
{ convert underlying_iso_hom_comp_eq_mk (𝟙 B), simp only [comp_id], }
simp only [comp_id]
intros
simp [kernel_subobject_map]
intros
rw [l.apply, option.get_or_else_of_ne_none h]
intros
ext x
rw [accepts, NFA.accepts, eval, NFA.eval, ←to_NFA_eval_from_match]
refl
intros
simp only [mjoin, (∘), id.def, (bind_pure_comp_eq_map _ _).symm, bind_assoc, map_bind, pure_bind]
intros
rw ← comp_bitraverse; simp [tsnd]; refl
rw ← comp_bitraverse; simp [tsnd]
rw ← comp_bitraverse
simp [tsnd]
refl
intros
induction x; simp! * with functor_norm; refl
induction x; simp! * with functor_norm
induction x
simp! * with functor_norm
refl
simp! * with functor_norm
refl
intros
rw [of_fin,to_nat_of_nat,nat.mod_eq_of_lt]; apply i.is_lt
rw [of_fin,to_nat_of_nat,nat.mod_eq_of_lt]
apply i.is_lt
intros
induction l with hd tl hl generalizing b
{ simp }
simp
{ simp [append_list, hl, add_comm, add_assoc] }
simp [append_list, hl, add_comm, add_assoc]
intros
have : char_buf cb' cb' 0 = done cb'.size () := by simp [char_buf_eq_done]
split
introI
{ introI, simpa using of_done this }
simpa using of_done this
intro h
{ intro h, constructor, intros cb n n' _, rw [char_buf_eq_done, h], rintro ⟨rfl, -⟩, refl }
constructor
intros cb n n' _
rw [char_buf_eq_done, h]
rintro ⟨rfl, -⟩
refl
intros
simp [many, foldr_eq_done, and.comm, and.assoc, and.left_comm]
intros
rw [sub_eq_add_neg, norm_sq_add]; simp [-mul_re, add_comm, add_left_comm, sub_eq_add_neg]
rw [sub_eq_add_neg, norm_sq_add]
simp [-mul_re, add_comm, add_left_comm, sub_eq_add_neg]
intros
simp only [← tan_mul_cos hx, mul_pow, ← inv_one_add_tan_sq hx, div_eq_mul_inv, one_mul]
intros
rw [← mul_right_inj' (@two_ne_zero' ℂ _ _ _), mul_sub, two_cosh, two_sinh, add_sub_sub_cancel, two_mul]
intros
rw [← of_real_cos_of_real_re, of_real_im]
intros
rw ext_iff
by_cases r = 0
simp [h]
{ simp [h] }
{ simp; field_simp [h, norm_sq] }
simp
simp; field_simp [h, norm_sq]
field_simp [h, norm_sq]
intros
{ unfold swap_core, split_ifs; cc }
unfold swap_core
split_ifs
split_ifs; cc
cc
cc
cc
cc
intros
cases e
{ cases e, refl }
refl
intros
rw fin_rotate_succ_apply
have : (i : ℕ) < n := lt_of_le_of_ne (nat.succ_le_succ_iff.mp i.2) (fin.coe_injective.ne h)
exact fin.coe_add_one_of_lt this
intros
refine iff.intro _ _
intro h
{ intro h, cases succ_above_lt_ge p i with H H, { exact H }, { rw succ_above_above _ _ H at h, exact lt_trans (cast_succ_lt_succ i) h } }
cases succ_above_lt_ge p i with H H
{ exact H }
exact H
rw succ_above_above _ _ H at h
{ rw succ_above_above _ _ H at h, exact lt_trans (cast_succ_lt_succ i) h }
exact lt_trans (cast_succ_lt_succ i) h
intro h
{ intro h, rw succ_above_below _ _ h, exact h }
rw succ_above_below _ _ h
exact h
intros
ext j
by_cases h : j = 0
{ rw h, simp }
rw h
simp
let j' := pred j h
{ let j' := pred j h, have : j'.succ = j := succ_pred j h, rw [← this, tail, cons_succ] }
have : j'.succ = j := succ_pred j h
rw [← this, tail, cons_succ]
intros
simp [← cast_add_nat]
intros
rw [disjoint.symm_iff, disjoint_union_left, disjoint.symm_iff _ x, disjoint.symm_iff _ x]
intros
classical
{ classical, rw ← piecewise_coe, exact set.piecewise_mem_pi ↑s hf hg }
rw ← piecewise_coe
exact set.piecewise_mem_pi ↑s hf hg
intros
simp [finset.nonempty, ← exists_and_distrib_left, @exists_swap α]
intros
{ ext, simp }
ext
simp
intros
apply finset.induction_on s
{ simp only [fold_empty], }
simp only [fold_empty]
intros a s has ih
{ intros a s has ih, rw [fold_insert has, ih, insert_eq], }
rw [fold_insert has, ih, insert_eq]
intros
simp
intros
simp [to_finset]
intros
ext x
ext x; refl
refl
intros
convert rfl
intros
simp [single_eq_indicator]
intros
{ext, refl}
ext
refl
intros
{ rw ← subtype_card s H, congr }
rw ← subtype_card s H
congr
intros
simp only [finset.prod_attach_univ, prod_sum, finset.sum_univ_pi]
intros
change sub_nat_nat _ _ = _
have h' : n.succ - m = 0
apply nat.sub_eq_zero_of_le h
simp [*, sub_nat_nat]
intros
simpa only [bit0_zero] using bit1_ne_bit0 m 0
intros
induction i
induction i
{ induction i, { exact hz }, { exact hp _ i_ih } }
{ exact hz }
exact hz
{ exact hp _ i_ih }
exact hp _ i_ih
have : ∀ n:ℕ, p (- n)
{ have : ∀ n:ℕ, p (- n), { intro n, induction n, { simp [hz] }, { convert hn _ n_ih using 1, simp [sub_eq_neg_add] } }, exact this (i + 1) }
intro n
{ intro n, induction n, { simp [hz] }, { convert hn _ n_ih using 1, simp [sub_eq_neg_add] } }
induction n
{ simp [hz] }
simp [hz]
{ convert hn _ n_ih using 1, simp [sub_eq_neg_add] }
convert hn _ n_ih using 1
simp [sub_eq_neg_add]
exact this (i + 1)
intros
{ rw mul_comm, exact mod_add_div _ _ }
rw mul_comm
exact mod_add_div _ _
intros
induction k
apply int.coe_nat_dvd.2
{ apply int.coe_nat_dvd.2, apply pow_dvd_of_le_of_pow_dvd hmn, apply int.coe_nat_dvd.1 hdiv }
apply pow_dvd_of_le_of_pow_dvd hmn
apply int.coe_nat_dvd.1 hdiv
change -[1+k] with -(↑(k+1) : ℤ)
apply dvd_neg_of_dvd
apply int.coe_nat_dvd.2
apply pow_dvd_of_le_of_pow_dvd hmn
apply int.coe_nat_dvd.1
apply dvd_of_dvd_neg
exact hdiv
intros
refine nat.dvd_antisymm _ (int.coe_nat_dvd.1 (int.dvd_gcd h₁ h₂))
rw [← int.coe_nat_dvd, ← h₃]
apply dvd_add
{ exact (int.gcd_dvd_left _ _).mul_right _ }
exact (int.gcd_dvd_left _ _).mul_right _
{ exact (int.gcd_dvd_right _ _).mul_right _ }
exact (int.gcd_dvd_right _ _).mul_right _
intros
unfold modeq nat.modeq; rw ← int.coe_nat_eq_coe_nat_iff; simp [coe_nat_mod]
unfold modeq nat.modeq; rw ← int.coe_nat_eq_coe_nat_iff
unfold modeq nat.modeq
rw ← int.coe_nat_eq_coe_nat_iff
simp [coe_nat_mod]
intros
cases mod_two_eq_zero_or_one n with h h; simp [h]
cases mod_two_eq_zero_or_one n with h h
simp [h]
simp [h]
intros
{ congr, exact h}
congr
exact h
intros
rw [nth_update_nth_eq, nth_le_nth h]; refl
rw [nth_update_nth_eq, nth_le_nth h]
refl
intros
simp [hi, sum_take_succ, hj]
intros
rw [← map_id (l.lookmap f), lookmap_map_eq, map_id]
rw [← map_id (l.lookmap f), lookmap_map_eq, map_id]; exact h
exact h
intros
simp only [eq_nil_iff_forall_not_mem, mem_filter, not_and]
intros
rw ← reverse_suffix; simp only [reverse_reverse]
rw ← reverse_suffix
simp only [reverse_reverse]
intros
induction l with x l IH generalizing n
{ simp }
simp
cases n
{ cases n, { simp }, { simpa using IH n _ } }
{ simp }
simp
{ simpa using IH n _ }
simpa using IH n _
intros
induction l with b l IH
cases al
{cases al}
by_cases pb : p b
{ exact ⟨b, [], l, forall_mem_nil _, pb, by simp [pb]⟩ }
exact ⟨b, [], l, forall_mem_nil _, pb, by simp [pb]⟩
rcases al with rfl | al
{ rcases al with rfl | al, {exact pb.elim pa}, rcases IH al with ⟨c, l₁, l₂, h₁, h₂, h₃, h₄⟩, exact ⟨c, b::l₁, l₂, forall_mem_cons.2 ⟨pb, h₁⟩, h₂, by rw h₃; refl, by simp [pb, h₄]⟩ }
exact pb.elim pa
{exact pb.elim pa}
rcases IH al with ⟨c, l₁, l₂, h₁, h₂, h₃, h₄⟩
exact ⟨c, b::l₁, l₂, forall_mem_cons.2 ⟨pb, h₁⟩, h₂, by rw h₃; refl, by simp [pb, h₄]⟩
intros
rw map_const at h; exact eq_of_mem_repeat h
rw map_const at h
exact eq_of_mem_repeat h
intros
simp
intros
{ induction l, contradiction, rw [tail,cons_append,tail], }
induction l
contradiction
rw [tail,cons_append,tail]
intros
induction l with lh lt l_ih generalizing a
{ simp }
simp
simp [H _ _ _ _ (rel_of_chain_cons hl₁), l_ih _ (chain_of_chain_cons hl₁)]
{ simp [H _ _ _ _ (rel_of_chain_cons hl₁), l_ih _ (chain_of_chain_cons hl₁)] }
intros
rw [sub, nil_pointwise]
congr' with x
have : @default α ⟨0⟩ = 0 := rfl
have : @default α ⟨0⟩ = 0 := rfl
have : @default α ⟨0⟩ = 0 := rfl
rw [this, zero_sub]
intros
dsimp [Ico]; simp only [nodup_range']
dsimp [Ico]
simp only [nodup_range']
intros
simp only [nodup, pairwise_append, disjoint_iff_ne]
intros
simp only [mem_of_fn, set.forall_range_iff]
intros
induction hlu generalizing v
cases huv
case perm.nil { cases huv, exact ⟨[], forall₂.nil, perm.nil⟩ }
exact ⟨[], forall₂.nil, perm.nil⟩
case perm.cons : a l u hlu ih { cases huv with _ b _ v hab huv', rcases ih huv' with ⟨l₂, h₁₂, h₂₃⟩, exact ⟨b::l₂, forall₂.cons hab h₁₂, h₂₃.cons _⟩ }
case perm.swap : a₁ a₂ l₁ l₂ h₂₃ { cases h₂₃ with _ b₁ _ l₂ h₁ hr_₂₃, cases hr_₂₃ with _ b₂ _ l₂ h₂ h₁₂, exact ⟨b₂::b₁::l₂, forall₂.cons h₂ (forall₂.cons h₁ h₁₂), perm.swap _ _ _⟩ }
case perm.trans : la₁ la₂ la₃ _ _ ih₁ ih₂ { rcases ih₂ huv with ⟨lb₂, hab₂, h₂₃⟩, rcases ih₁ hab₂ with ⟨lb₁, hab₁, h₁₂⟩, exact ⟨lb₁, hab₁, perm.trans h₁₂ h₂₃⟩ }
intros
rw [eq_comm, rotate_eq_singleton_iff, eq_comm]
intros
simp [cyclic_permutations_of_ne_nil]
intros
have := nodup_of_sublist ((lookup_all_sublist a l).map _) h
have := nodup_of_sublist ((lookup_all_sublist a l).map _) h; rw map_map at this; rwa [← nodup_repeat, ← map_const _ a]
have := nodup_of_sublist ((lookup_all_sublist a l).map _) h; rw map_map at this
rw map_map at this
rwa [← nodup_repeat, ← map_const _ a]
intros
induction l₁ with s _ ih generalizing l₂
induction l₁ with s _ ih generalizing l₂; simp at h; cases h; cases s with a'
induction l₁ with s _ ih generalizing l₂; simp at h; cases h
induction l₁ with s _ ih generalizing l₂; simp at h
simp at h
cases h
simp at h
cases h
cases s with a'
{ subst h, simp }
subst h
simp
cases s with a'
rw kunion_cons
{ rw kunion_cons, by_cases h' : a = a', { subst h', simp }, { simp [h', ih h] } }
by_cases h' : a = a'
{ subst h', simp }
subst h'
simp
{ simp [h', ih h] }
simp [h', ih h]
intros
simp only [sublists_eq_sublists', map_map, map_id' (reverse_reverse)]
intros
{ rw [length_zip_with, lt_min_iff] at h, exact h.left }
rw [length_zip_with, lt_min_iff] at h
exact h.left
intros
simp [conj_transpose]
intros
simp [dot_product]
intros
{ cases ik, cases jk, refl }
cases ik
cases jk
refl
intros
ext ⟨i₁, i₂⟩ ⟨j₁, j₂⟩
simp [diagonal, apply_ite f, ite_and, ite_apply, apply_ite (f (a i₁)), hf₁, hf₂]
intros
{ ext i, refine fin.cases _ _ i; simp [mul_vec] }
ext i
refine fin.cases _ _ i
refine fin.cases _ _ i; simp [mul_vec]
simp [mul_vec]
simp [mul_vec]
intros
dunfold strong_downward_induction_on
{ dunfold strong_downward_induction_on, rw strong_downward_induction }
rw strong_downward_induction
intros
simp [erase_dup_ext]
intros
induction n; simp [nat.succ_eq_add_one, *]
induction n
simp [nat.succ_eq_add_one, *]
simp [nat.succ_eq_add_one, *]
intros
simp [eval₂_monomial, f.map_one, X, prod_single_index, pow_one]
intros
funext i
{ funext i, simp only [comap, alg_hom.id_apply, id.def, aeval_X], }
simp only [comap, alg_hom.id_apply, id.def, aeval_X]
intros
refine quotient.induction_on s (assume l, _)
rw [multiset.quot_mk_to_coe, multiset.coe_prod, multiset.coe_map, multiset.coe_sum]
exact total_degree_list_prod l
intros
bitwise_assoc_tac
intros
{ rw [←coe_nat n], apply coe_ne_top }
rw [←coe_nat n]
apply coe_ne_top
intros
rw [← add_mul_div_left, mul_comm 2 n, ← mul_add, nat.add_sub_cancel, mul_comm]
cases n; refl
cases n
refl
refl
apply zero_lt_succ
intros
rw [h, dist_self]
intros
cases n1 with h
{ exact self_le_factorial _ }
exact self_le_factorial _
exact add_factorial_succ_le_factorial_add_succ i h
intros
rw cast_desc_factorial
cases a
rw [nat.zero_sub, cast_zero, pochhammer_ne_zero_eval_zero _ (two_ne_zero), zero_mul]
{ rw [nat.zero_sub, cast_zero, pochhammer_ne_zero_eval_zero _ (two_ne_zero), zero_mul] }
rw [succ_sub_succ, nat.sub_zero, cast_succ, add_sub_cancel, pochhammer_succ_right, pochhammer_one, polynomial.X_mul, polynomial.eval_mul_X, polynomial.eval_add, polynomial.eval_X, cast_one, polynomial.eval_one]
{ rw [succ_sub_succ, nat.sub_zero, cast_succ, add_sub_cancel, pochhammer_succ_right, pochhammer_one, polynomial.X_mul, polynomial.eval_mul_X, polynomial.eval_add, polynomial.eval_X, cast_one, polynomial.eval_one] }
intros
rw [mul_comm m k, H.gcd_mul_left_cancel m]
intros
rw [hp.multiplicity_factorial (lt_succ_self _), enat.coe_le_coe]
exact nat.geom_sum_Ico_le hp.two_le _ _
intros
rw [odd_iff_not_even, even_sub h, not_iff, odd_iff_not_even]
simp [size]
intros
unfold divmod_aux
have : ∀ {r₂}, num.of_znum' (num.sub' r (num.pos d)) = some r₂ ↔ (r : ℕ) = r₂ + d
intro r₂
{ intro r₂, apply num.mem_of_znum'.trans, rw [← znum.to_int_inj, num.cast_to_znum, num.cast_sub', sub_eq_iff_eq_add, ← int.coe_nat_inj'], simp }
apply num.mem_of_znum'.trans
rw [← znum.to_int_inj, num.cast_to_znum, num.cast_sub', sub_eq_iff_eq_add, ← int.coe_nat_inj']
simp
cases e : num.of_znum' (num.sub' r (num.pos d)) with r₂
cases e : num.of_znum' (num.sub' r (num.pos d)) with r₂; simp [divmod_aux]
simp [divmod_aux]
refine ⟨h₁, lt_of_not_ge (λ h, _)⟩
{ refine ⟨h₁, lt_of_not_ge (λ h, _)⟩, cases nat.le.dest h with r₂ e', rw [← num.to_of_nat r₂, add_comm] at e', cases e.symm.trans (this.2 e'.symm) }
cases nat.le.dest h with r₂ e'
rw [← num.to_of_nat r₂, add_comm] at e'
cases e.symm.trans (this.2 e'.symm)
simp [divmod_aux]
have := this.1 e
{ have := this.1 e, split, { rwa [_root_.bit1, add_comm _ 1, mul_add, mul_one, ← add_assoc, ← this] }, { rwa [this, two_mul, add_lt_add_iff_right] at h₂ } }
split
rwa [_root_.bit1, add_comm _ 1, mul_add, mul_one, ← add_assoc, ← this]
{ rwa [_root_.bit1, add_comm _ 1, mul_add, mul_one, ← add_assoc, ← this] }
{ rwa [this, two_mul, add_lt_add_iff_right] at h₂ }
rwa [this, two_mul, add_lt_add_iff_right] at h₂
intros
cases a; refl
cases a
refl
refl
refl
intros
cases x; simp only [map_none', map_some', eq_self_iff_true]
{ cases x; simp only [map_none', map_some', eq_self_iff_true] }
cases x
simp only [map_none', map_some', eq_self_iff_true]
simp only [map_none', map_some', eq_self_iff_true]
intros
induction t
exact H0
{exact H0}
rw hl.eq_node'
exact H1 _ _ _ (t_ih_l hl.2.1) (t_ih_r hl.2.2)
intros
refine or_iff_not_imp_left.2 (λ h, _)
refine ⟨_, h₂.resolve_left h⟩
cases H
cases r₂
{ cases r₂, { cases h (le_trans (nat.add_le_add_left (nat.zero_le _) _) H) }, { exact le_trans (le_trans (nat.le_add_right _ _) H) (nat.le_add_left 1 _) } }
{ cases h (le_trans (nat.add_le_add_left (nat.zero_le _) _) H) }
cases h (le_trans (nat.add_le_add_left (nat.zero_le _) _) H)
exact le_trans (le_trans (nat.le_add_right _ _) H) (nat.le_add_left 1 _)
{ exact le_trans (le_trans (nat.le_add_right _ _) H) (nat.le_add_left 1 _) }
{ exact le_trans H.1 (nat.mul_le_mul_left _ h₁) }
exact le_trans H.1 (nat.mul_le_mul_left _ h₁)
intros
linarith
intros
simp only [eq_none_iff_forall_not_mem, mem_trans, imp_iff_not_or.symm]
push_neg
tauto
intros
ext
ext; simp [mem_preimage, mem_dom]
simp [mem_preimage, mem_dom]
intros
split
rintros ⟨u, xeq, yeq⟩
{ rintros ⟨u, xeq, yeq⟩, cases h : u with a f, use [a, λ i j, (f i j).val.fst, λ i j, (f i j).val.snd], split, { rw [←xeq, h], refl }, split, { rw [←yeq, h], refl }, intros i j, exact (f i j).property }
cases h : u with a f
use [a, λ i j, (f i j).val.fst, λ i j, (f i j).val.snd]
split
rw [←xeq, h]
{ rw [←xeq, h], refl }
refl
split
rw [←yeq, h]
{ rw [←yeq, h], refl }
refl
intros i j
exact (f i j).property
rintros ⟨a, f₀, f₁, xeq, yeq, h⟩
use ⟨a, λ i j, ⟨(f₀ i j, f₁ i j), h i j⟩⟩
dsimp
split
{ rw [xeq], refl }
rw [xeq]
refl
rw [yeq]
refl
intros
ext
ext; dsimp [v, vp, w, z, a, b, succ₂]; repeat { rw [nat.succ_eq_add_one] }; ring
ext; dsimp [v, vp, w, z, a, b, succ₂]; repeat { rw [nat.succ_eq_add_one] }
ext; dsimp [v, vp, w, z, a, b, succ₂]
{ ext; dsimp [v, vp, w, z, a, b, succ₂]; repeat { rw [nat.succ_eq_add_one] }; ring }
dsimp [v, vp, w, z, a, b, succ₂]
repeat { rw [nat.succ_eq_add_one] }
ring
dsimp [v, vp, w, z, a, b, succ₂]
rw [nat.succ_eq_add_one]
repeat { rw [nat.succ_eq_add_one] }
rw [nat.succ_eq_add_one]
rw [nat.succ_eq_add_one]
rw [nat.succ_eq_add_one]
rw [nat.succ_eq_add_one]
ring
intros
change (⟨1⟩ : polynomial R) = monomial_fun 0 (1 : R)
rw [monomial_fun]
refl
intros
rw next_coeff
{ rw next_coeff, simp }
simp
intros
simp [nat_trailing_degree]
intros
rw [eval₂_mul_noncomm, eval₂_C]
intro k
by_cases hk : k = 0
{ simp only [hk, h, coeff_C_zero, coeff_C_ne_zero] }
simp only [hk, h, coeff_C_zero, coeff_C_ne_zero]
simp only [coeff_C_ne_zero hk, ring_hom.map_zero, commute.zero_left]
{ simp only [coeff_C_ne_zero hk, ring_hom.map_zero, commute.zero_left] }
intros
apply polynomial.induction_on φ; { intros, simp only [add_comp, mul_comp, C_comp, X_comp, pow_succ', ← mul_assoc, *] at * }
apply polynomial.induction_on φ
{ intros, simp only [add_comp, mul_comp, C_comp, X_comp, pow_succ', ← mul_assoc, *] at * }
{ intros, simp only [add_comp, mul_comp, C_comp, X_comp, pow_succ', ← mul_assoc, *] at * }
intros
{ intros, simp only [add_comp, mul_comp, C_comp, X_comp, pow_succ', ← mul_assoc, *] at * }
simp only [add_comp, mul_comp, C_comp, X_comp, pow_succ', ← mul_assoc, *] at *
intros
rw [←C_mul_X_pow_eq_monomial, root_set_C_mul_X_pow hn ha]
intros
obtain ⟨q, hq⟩ := exists_eq_mul_right_of_dvd h
rw hq at hzero
simp only [hq, root_multiplicity_mul hzero, root_multiplicity_X_sub_C_pow, ge_iff_le, _root_.zero_le, le_add_iff_nonneg_right]
intros
conv in (0) { rw [← nat_degree_coe_units u] }
rw [← leading_coeff, ne.def, leading_coeff_eq_zero]
exact units.ne_zero _
intros
apply q.P.W_cases _ x; intros a f' f; exact Wequiv.abs a f' f a f' f rfl
apply q.P.W_cases _ x; intros a f' f
apply q.P.W_cases _ x
intros a f' f
exact Wequiv.abs a f' f a f' f rfl
intros
by_cases b0 : b = 0
subst b0
{ subst b0, simp }
simp
apply (mk_eq (mul_ne_zero b0 c0) b0).2
simp [mul_comm, mul_assoc]
intros
simp
intros
rw [div_eq_inv_mul, div_eq_mul_inv, of_real_mul (inv_nonneg.2 hy.le), of_real_inv_of_pos hy, mul_comm]
intros
simp [ennreal.to_real, to_nnreal_eq_zero_iff]
intros
simpa only [bit0_zero] using @bit0_inj a 0
intros
induction z using ereal.rec
{ simpa only using hz }
simpa only using hz
calc x + z < y + z : add_lt_add_right_coe h _ ... ≤ y + t : add_le_add (le_refl _) h'
{ calc x + z < y + z : add_lt_add_right_coe h _ ... ≤ y + t : add_le_add (le_refl _) h' }
{ exact (ht (top_le_iff.1 h')).elim }
exact (ht (top_le_iff.1 h')).elim
simpa using nat.prime_two.irrational_sqrt
pi_lower_bound [99/70, 874/473, 1940/989, 1447/727]
intros
rw [← abs_mul_abs_self x, sqrt_mul_self (abs_nonneg _)]
intros
{ rw [preimage, image_univ, codom_inv] }
rw [preimage, image_univ, codom_inv]
intros
{ casesI h, cases h with a' h, rw p h, exact h }
casesI h
cases h with a' h
rw p h
exact h
intros
have := h
revert this
generalize e : append s₁ s₂ = ss
intro h
revert s₁
apply mem_rec_on h _
intros b s' o s₁
apply s₁.cases_on _ (λ c t₁, _); intros m e; have := congr_arg destruct e
apply s₁.cases_on _ (λ c t₁, _); intros m e
apply s₁.cases_on _ (λ c t₁, _)
intros m e
have := congr_arg destruct e
{ apply or.inr, simpa using m }
apply or.inr
simpa using m
intros m e
have := congr_arg destruct e
cases (show a = c ∨ a ∈ append t₁ s₂, by simpa using m) with e' m
{ cases (show a = c ∨ a ∈ append t₁ s₂, by simpa using m) with e' m, { rw e', exact or.inl (mem_cons _ _) }, { cases (show c = b ∧ append t₁ s₂ = s', by simpa) with i1 i2, cases o with e' IH, { simp [i1, e'] }, { exact or.imp_left (mem_cons_of_mem _) (IH m i2) } } }
{ rw e', exact or.inl (mem_cons _ _) }
rw e'
exact or.inl (mem_cons _ _)
cases (show c = b ∧ append t₁ s₂ = s', by simpa) with i1 i2
{ cases (show c = b ∧ append t₁ s₂ = s', by simpa) with i1 i2, cases o with e' IH, { simp [i1, e'] }, { exact or.imp_left (mem_cons_of_mem _) (IH m i2) } }
cases o with e' IH
{ simp [i1, e'] }
simp [i1, e']
{ exact or.imp_left (mem_cons_of_mem _) (IH m i2) }
exact or.imp_left (mem_cons_of_mem _) (IH m i2)
intros
subst hT'
cases set.mem_Union.1 x.prop with i hi
cases set.mem_Union.1 y.prop with j hj
rcases dir i j with ⟨k, hik, hjk⟩
rw [Union_lift_of_mem x (hik hi), Union_lift_of_mem y (hjk hj), ← h k]
have hx : x = (set.inclusion (set.subset_Union S k) ⟨x, hik hi⟩)
cases x
{ cases x, refl }
refl
have hy : y = (set.inclusion (set.subset_Union S k) ⟨y, hjk hj⟩)
cases y
{ cases y, refl }
refl
have hxy : (set.inclusion (set.subset_Union S k) (opi k ⟨x, hik hi⟩ ⟨y, hjk hj⟩) : α) ∈ S k
from (opi k ⟨x, hik hi⟩ ⟨y, hjk hj⟩).prop
conv_lhs { rw [hx, hy, ← hopi, Union_lift_of_mem _ hxy] }
simp only [coe_inclusion, subtype.coe_eta]
intros
safe [ext_iff, iff_def]
intros
{ ext, simp }
ext
simp
intros
{ intro s, use f '' s, rw hf.preimage_image }
intro s
use f '' s
rw hf.preimage_image
intros
split_ifs; simp [h]
{ split_ifs; simp [h] }
split_ifs
simp [h]
simp [h]
intros
ext x
{ ext x, simp [@forall_update_iff _ (λ i, set (α i)) _ _ _ _ (λ i' y, x i' ∈ y)] }
simp [@forall_update_iff _ (λ i, set (α i)) _ _ _ _ (λ i' y, x i' ∈ y)]
intros
simp only [set.nonempty, eq_empty_iff_forall_not_mem, not_exists]
intros
letI : fintype s := hs.fintype
convert finite_range (λ x : s, F x x.2)
simp only [set_coe.exists, subtype.coe_mk, eq_comm]
intros
intros x hx y hy H
have := congr_arg f H
rw [h.eq, h.eq] at this
exact hf hx hy (hb hx hy this)
intros
simp [← Ici_inter_Iic]
intros
rw [mem_Icc, le_iff_lt_or_eq, le_iff_lt_or_eq] at hmem
rcases hmem with ⟨hxa | hxa, hxb | hxb⟩
{ exact or.inr (or.inr ⟨hxa, hxb⟩) }
exact or.inr (or.inr ⟨hxa, hxb⟩)
{ exact or.inr (or.inl hxb) }
exact or.inr (or.inl hxb)
exact or.inl hxa.symm
all_goals { exact or.inl hxa.symm }
exact or.inl hxa.symm
intros
ext x
cases lt_or_le x b with hba hba
{ simp [hba, h₁] }
simp [hba, h₁]
simp only [mem_Iio, mem_union_eq, mem_Ioo, lt_max_iff]
{ simp only [mem_Iio, mem_union_eq, mem_Ioo, lt_max_iff], refine or_congr iff.rfl ⟨and.right, _⟩, exact λ h₂, ⟨h₁.trans_le hba, h₂⟩ }
refine or_congr iff.rfl ⟨and.right, _⟩
exact λ h₂, ⟨h₁.trans_le hba, h₂⟩
intros
simp [sub_eq_add_neg]
intros
simp [sub_eq_add_neg, image_comp (λ x, a + x) (λ x, -x)]
intros
refine ⟨λ _ h, ⟨add_lt_add_right h.1 _, add_lt_add_right h.2 _⟩, λ _ _ _ _ h, add_right_cancel h, λ _ h, _⟩
obtain ⟨c, rfl⟩ := exists_add_of_le h.1.le
rw [mem_Ioo, add_right_comm, add_lt_add_iff_right, add_lt_add_iff_right] at h
exact ⟨a + c, h, by rw add_right_comm⟩
intros
{ cases x, apply proj_Icc_of_mem }
cases x
apply proj_Icc_of_mem
intros
{ rw [interval, min_eq_right h, max_eq_left h] }
rw [interval, min_eq_right h, max_eq_left h]
intros
ext ⟨z, w⟩
simp only [mem_prod, mem_Union, exists_imp_distrib, and_imp, iff_def]
split
{ intros x hz hw, exact ⟨⟨x, hz⟩, x, hw⟩ }
intros x hz hw
exact ⟨⟨x, hz⟩, x, hw⟩
intros x hz x' hw
{ intros x hz x' hw, exact ⟨x ⊔ x', hs le_sup_left hz, ht le_sup_right hw⟩ }
exact ⟨x ⊔ x', hs le_sup_left hz, ht le_sup_right hw⟩
intros
simp [← ne_empty_iff_nonempty, sInter_eq_empty_iff]
intros
rw [nat.choose_two_right, nat.mul_sub_left_distrib, mul_one, ←off_diag_card, nat.div_eq_of_eq_mul_right zero_lt_two (two_mul_card_image_off_diag s).symm]
intros
split; intro h
{ split; intro h, { rw quotient.eq at h, cases h; refl }, rw h }
split
intro h
rw quotient.eq at h
{ rw quotient.eq at h, cases h; refl }
cases h
cases h; refl
refl
refl
intro h
rw h
intros
induction i; [refl, erw [repeat_eq,@i_ih (drop α) x y]]
induction i
refl
erw [repeat_eq,@i_ih (drop α) x y]
intros
have : 0 = v.to_list.length - 1 - n
simp only [nat.add_succ_sub_one, add_zero, to_list_length, nat.sub_self, list.length_reverse]
{ simp only [nat.add_succ_sub_one, add_zero, to_list_length, nat.sub_self, list.length_reverse] }
rw [←nth_zero, last_def, nth_eq_nth_le, nth_eq_nth_le]
simp_rw [to_list_reverse, fin.val_eq_coe, fin.coe_last, fin.coe_zero, this]
rw list.nth_le_reverse
intros
rcases x with ⟨_|_, h⟩; refl
{ rcases x with ⟨_|_, h⟩; refl, }
rcases x with ⟨_|_, h⟩
refl
refl
intros
haveI : fact (0 < n) := ⟨begin rw [pos_iff_ne_zero], intro hn, rw hn at h, exact (fintype.card_eq_zero_iff.mp h).elim' 0 end⟩
rw [fintype.bijective_iff_injective_and_card, zmod.card, h, eq_self_iff_true, and_true]
apply zmod.cast_hom_injective
intros
cases a
simp only [int.nat_abs_of_nat, int.cast_coe_nat, int.of_nat_eq_coe]
{ simp only [int.nat_abs_of_nat, int.cast_coe_nat, int.of_nat_eq_coe] }
simp only [neg_eq_self_mod_two, nat.cast_succ, int.nat_abs, int.cast_neg_succ_of_nat]
{ simp only [neg_eq_self_mod_two, nat.cast_succ, int.nat_abs, int.cast_neg_succ_of_nat] }
intros
rw [← is_periodic_pt_iff_minimal_period_dvd, is_periodic_pt, h.comp_iterate]
refine is_fixed_pt.comp _ _; rw [← is_periodic_pt, is_periodic_pt_iff_minimal_period_dvd]; exact nat.dvd_lcm_left _ _ <|> exact dvd_lcm_right _ _
refine is_fixed_pt.comp _ _; rw [← is_periodic_pt, is_periodic_pt_iff_minimal_period_dvd]
refine is_fixed_pt.comp _ _
rw [← is_periodic_pt, is_periodic_pt_iff_minimal_period_dvd]
exact nat.dvd_lcm_left _ _
rw [← is_periodic_pt, is_periodic_pt_iff_minimal_period_dvd]
exact dvd_lcm_right _ _
exact nat.dvd_lcm_left _ _
intros
apply to_subalgebra_injective
rw h
refine (adjoin_eq_algebra_adjoin _ _ _).symm
intros x
convert K.inv_mem
rw ← h
refl
intros
cases alg_hom_mk_adjoin_splits hK with ϕ
rw hS at ϕ
exact ⟨ϕ.comp top_equiv.symm.to_alg_hom⟩
intros
simpa only [add_zero, C_0, sub_eq_add_neg, neg_zero, ring_hom.map_zero] using eq_X_sub_C B (0:A)
intros
induction n with n ih
induction x with x ih
{ induction x with x ih, {refl}, rw [nat.cast_succ, nat.cast_succ, ih], refl }
refl
{refl}
rw [nat.cast_succ, nat.cast_succ, ih]
refl
rw ih
apply quot.sound
conv {congr, skip, skip, rw ← frobenius_nat_cast K p x}
apply r.intro
intros
rcases is_empty_or_nonempty (fintype F) with F_inf|⟨⟨F_finite⟩⟩
let P : intermediate_field F E → Prop := λ K, ∃ α : E, F⟮α⟯ = K
{ let P : intermediate_field F E → Prop := λ K, ∃ α : E, F⟮α⟯ = K, have base : P ⊥ := ⟨0, adjoin_zero⟩, have ih : ∀ (K : intermediate_field F E) (x : E), P K → P ↑K⟮x⟯, { intros K β hK, cases hK with α hK, rw [←hK, adjoin_simple_adjoin_simple], haveI : infinite F := is_empty_fintype.mp F_inf, cases primitive_element_inf_aux F α β with γ hγ, exact ⟨γ, hγ.symm⟩ }, exact induction_on_adjoin P base ih ⊤ }
have base : P ⊥ := ⟨0, adjoin_zero⟩
have ih : ∀ (K : intermediate_field F E) (x : E), P K → P ↑K⟮x⟯
intros K β hK
{ intros K β hK, cases hK with α hK, rw [←hK, adjoin_simple_adjoin_simple], haveI : infinite F := is_empty_fintype.mp F_inf, cases primitive_element_inf_aux F α β with γ hγ, exact ⟨γ, hγ.symm⟩ }
cases hK with α hK
rw [←hK, adjoin_simple_adjoin_simple]
haveI : infinite F := is_empty_fintype.mp F_inf
cases primitive_element_inf_aux F α β with γ hγ
exact ⟨γ, hγ.symm⟩
exact induction_on_adjoin P base ih ⊤
{ exactI exists_primitive_element_of_fintype_bot F E }
exactI exists_primitive_element_of_fintype_bot F E
intros
rw [splits_map_iff, ring_hom.id_comp]
intros
{ ext, rw ← (reflection s).injective.eq_iff, simp }
ext
rw ← (reflection s).injective.eq_iff
simp
intros
refine ⟨λ h, _, inner_eq_mul_norm_of_angle_eq_zero⟩
have h₁ : (∥x∥ * ∥y∥) ≠ 0 := (mul_pos (norm_pos_iff.mpr hx) (norm_pos_iff.mpr hy)).ne'
rw [angle, h, div_self h₁, real.arccos_one]
intros
rcases exists_circumradius_eq_of_cospherical hd hc with ⟨r, hr⟩
rw [hr sx₁ hsx₁, hr sx₂ hsx₂]
intros
have ha := ho.affine_independent hps hpi
rcases ho with ⟨t, hto, hts⟩
have hs : affine_span ℝ s = affine_span ℝ (set.range t.points)
rw [hts, affine_span_insert_eq_affine_span ℝ t.orthocenter_mem_affine_span]
{ rw [hts, affine_span_insert_eq_affine_span ℝ t.orthocenter_mem_affine_span] }
refine ext_of_direction_eq _ ⟨p 0, mem_affine_span ℝ (set.mem_range_self _), mem_affine_span ℝ (hps (set.mem_range_self _))⟩
have hfd : finite_dimensional ℝ (affine_span ℝ s).direction
rw hs
{ rw hs, apply_instance }
apply_instance
haveI := hfd
refine eq_of_le_of_finrank_eq (direction_le (affine_span_mono ℝ hps)) _
rw [hs, direction_affine_span, direction_affine_span, ha.finrank_vector_span (fintype.card_fin _), t.independent.finrank_vector_span (fintype.card_fin _)]
intros
apply unique_diff_within_at_congr
rw [nhds_within_inter, nhds_within_inter, nhds_within_ext_chart_target_eq]
intros
{ refine I.left_inv' _, simp }
refine I.left_inv' _
simp
intros
simp only with mfld_simps
intros
classical; calc card α = card (f.range : subgroup H) : card_congr (equiv.of_injective f hf) ...∣ card H : card_subgroup_dvd_card _
classical
calc card α = card (f.range : subgroup H) : card_congr (equiv.of_injective f hf) ...∣ card H : card_subgroup_dvd_card _
intros
{ symmetry, rw [← mk_one, mk_eq_mk_iff], exact one_rel a }
symmetry
rw [← mk_one, mk_eq_mk_iff]
exact one_rel a
intros
ext
ext; exact f.lift_eq hg _
exact f.lift_eq hg _
intros
induction n with d hd
{ simp }
simp
rw [lower_central_series_succ, lower_central_series_succ, monoid_hom.map_closure]
{ rw [lower_central_series_succ, lower_central_series_succ, monoid_hom.map_closure], apply subgroup.closure_mono, rintros x1 ⟨x2, ⟨x3, hx3, x4, hx4, rfl⟩, rfl⟩, exact ⟨x3, (hd (mem_map.mpr ⟨x3, hx3, rfl⟩)), x4, by simp⟩ }
apply subgroup.closure_mono
rintros x1 ⟨x2, ⟨x3, hx3, x4, hx4, rfl⟩, rfl⟩
exact ⟨x3, (hd (mem_map.mpr ⟨x3, hx3, rfl⟩)), x4, by simp⟩
intros
rw [←mul_assoc, swap_mul_self, one_mul]
intros
simp only [cycle_type_def, ←finset.mem_def, function.comp_app, multiset.mem_map, mem_cycle_factors_finset_iff] at h
obtain ⟨_, ⟨hc, -⟩, rfl⟩ := h
exact hc.two_le_card_support
intros
simp
intros
cases n with n
{ cases h }
cases h
exact cycle_range_zero n
intros
rw [ne.def, form_perm_apply_mem_eq_self_iff _ hl x hx, not_le]
exact ⟨nat.succ_le_of_lt, nat.lt_of_succ_le⟩
intros
rw ← sign_aux_inv g
unfold sign_aux
rw ← prod_mul_distrib
refine prod_bij (λ a ha, sign_bij_aux g a) sign_bij_aux_mem _ sign_bij_aux_inj sign_bij_aux_surj
rintros ⟨a, b⟩ hab
rw [sign_bij_aux, mul_apply, mul_apply]
rw mem_fin_pairs_lt at hab
by_cases h : g b < g a
rw dif_pos h
{ rw dif_pos h, simp only [not_le_of_gt hab, mul_one, perm.inv_apply_self, if_false] }
simp only [not_le_of_gt hab, mul_one, perm.inv_apply_self, if_false]
rw [dif_neg h, inv_apply_self, inv_apply_self, if_pos hab.le]
{ rw [dif_neg h, inv_apply_self, inv_apply_self, if_pos hab.le], by_cases h₁ : f (g b) ≤ f (g a), { have : f (g b) ≠ f (g a), { rw [ne.def, f.injective.eq_iff, g.injective.eq_iff], exact ne_of_lt hab }, rw [if_pos h₁, if_neg (h₁.lt_of_ne this).not_le], refl }, { rw [if_neg h₁, if_pos (lt_of_not_ge h₁).le], refl } }
by_cases h₁ : f (g b) ≤ f (g a)
have : f (g b) ≠ f (g a)
{ have : f (g b) ≠ f (g a), { rw [ne.def, f.injective.eq_iff, g.injective.eq_iff], exact ne_of_lt hab }, rw [if_pos h₁, if_neg (h₁.lt_of_ne this).not_le], refl }
rw [ne.def, f.injective.eq_iff, g.injective.eq_iff]
{ rw [ne.def, f.injective.eq_iff, g.injective.eq_iff], exact ne_of_lt hab }
exact ne_of_lt hab
rw [if_pos h₁, if_neg (h₁.lt_of_ne this).not_le]
refl
rw [if_neg h₁, if_pos (lt_of_not_ge h₁).le]
{ rw [if_neg h₁, if_pos (lt_of_not_ge h₁).le], refl }
refl
intros
rw [finset.card_eq_zero, support_eq_empty_iff]
intros
ext
ext; simp
simp
simp
intros
introI h
have key : nonempty (fin 5 ↪ X)
rwa [←cardinal.lift_mk_le, cardinal.mk_fin, cardinal.lift_nat_cast, nat.cast_bit1, nat.cast_bit0, nat.cast_one, cardinal.lift_id]
{ rwa [←cardinal.lift_mk_le, cardinal.mk_fin, cardinal.lift_nat_cast, nat.cast_bit1, nat.cast_bit0, nat.cast_one, cardinal.lift_id] }
exact equiv.perm.fin_5_not_solvable (solvable_of_solvable_injective (equiv.perm.via_embedding_hom_injective (nonempty.some key)))
intros
{ ext, simp [mem_ker] }
ext
simp [mem_ker]
intros
simp [mem_center_iff]
intros
simp [line_map_apply]
intros
rw mem_direction_iff_eq_vsub_right hp
simp
intros
rw [weighted_vsub_of_point_apply, weighted_vsub_of_point_apply]
apply sum_insert_zero
rw [vsub_self, smul_zero]
intros
simp [weighted_vsub_of_point, linear_map.sum_apply]
intros
rcases s.eq_empty_or_nonempty with rfl | ⟨p₁, hp₁⟩
have p₁ : P := add_torsor.nonempty.some
{ have p₁ : P := add_torsor.nonempty.some, let hsv := basis.of_vector_space k V, have hsvi := hsv.linear_independent, have hsvt := hsv.span_eq, rw basis.coe_of_vector_space at hsvi hsvt, have h0 : ∀ v : V, v ∈ (basis.of_vector_space_index _ _) → v ≠ 0, { intros v hv, simpa using hsv.ne_zero ⟨v, hv⟩ }, rw linear_independent_set_iff_affine_independent_vadd_union_singleton k h0 p₁ at hsvi, exact ⟨{p₁} ∪ (λ v, v +ᵥ p₁) '' _, set.empty_subset _, hsvi, affine_span_singleton_union_vadd_eq_top_of_span_eq_top p₁ hsvt⟩ }
let hsv := basis.of_vector_space k V
have hsvi := hsv.linear_independent
have hsvt := hsv.span_eq
rw basis.coe_of_vector_space at hsvi hsvt
have h0 : ∀ v : V, v ∈ (basis.of_vector_space_index _ _) → v ≠ 0
{ intros v hv, simpa using hsv.ne_zero ⟨v, hv⟩ }
intros v hv
simpa using hsv.ne_zero ⟨v, hv⟩
rw linear_independent_set_iff_affine_independent_vadd_union_singleton k h0 p₁ at hsvi
exact ⟨{p₁} ∪ (λ v, v +ᵥ p₁) '' _, set.empty_subset _, hsvi, affine_span_singleton_union_vadd_eq_top_of_span_eq_top p₁ hsvt⟩
rw affine_independent_set_iff_linear_independent_vsub k hp₁ at h
{ rw affine_independent_set_iff_linear_independent_vsub k hp₁ at h, let bsv := basis.extend h, have hsvi := bsv.linear_independent, have hsvt := bsv.span_eq, rw basis.coe_extend at hsvi hsvt, have hsv := h.subset_extend (set.subset_univ _), have h0 : ∀ v : V, v ∈ (h.extend _) → v ≠ 0, { intros v hv, simpa using bsv.ne_zero ⟨v, hv⟩ }, rw linear_independent_set_iff_affine_independent_vadd_union_singleton k h0 p₁ at hsvi, refine ⟨{p₁} ∪ (λ v, v +ᵥ p₁) '' h.extend (set.subset_univ _), _, _⟩, { refine set.subset.trans _ (set.union_subset_union_right _ (set.image_subset _ hsv)), simp [set.image_image] }, { use [hsvi, affine_span_singleton_union_vadd_eq_top_of_span_eq_top p₁ hsvt] } }
let bsv := basis.extend h
have hsvi := bsv.linear_independent
have hsvt := bsv.span_eq
rw basis.coe_extend at hsvi hsvt
have hsv := h.subset_extend (set.subset_univ _)
have h0 : ∀ v : V, v ∈ (h.extend _) → v ≠ 0
{ intros v hv, simpa using bsv.ne_zero ⟨v, hv⟩ }
intros v hv
simpa using bsv.ne_zero ⟨v, hv⟩
rw linear_independent_set_iff_affine_independent_vadd_union_singleton k h0 p₁ at hsvi
refine ⟨{p₁} ∪ (λ v, v +ᵥ p₁) '' h.extend (set.subset_univ _), _, _⟩
refine set.subset.trans _ (set.union_subset_union_right _ (set.image_subset _ hsv))
{ refine set.subset.trans _ (set.union_subset_union_right _ (set.image_subset _ hsv)), simp [set.image_image] }
simp [set.image_image]
use [hsvi, affine_span_singleton_union_vadd_eq_top_of_span_eq_top p₁ hsvt]
{ use [hsvi, affine_span_singleton_union_vadd_eq_top_of_span_eq_top p₁ hsvt] }
intros
rw [multilinear_map.dom_coprod_alternization, coe_alternatization, coe_alternatization, mul_smul, ←dom_coprod'_apply, ←dom_coprod'_apply, ←tensor_product.smul_tmul', tensor_product.tmul_smul, linear_map.map_smul_of_tower dom_coprod', linear_map.map_smul_of_tower dom_coprod']
apply_instance
apply_instance
apply_instance
apply_instance
intros
simp [f.range_cod_restrict _]
intros
rw [range_comp, equiv.range_eq_univ, set.image_univ]
intros
{ ext, refl }
ext
refl
intros
simp only [B.to_matrix_comp b c, to_matrix_to_lin, transpose_transpose]
intros
ext m
simp only [linear_map.id_apply, linear_map.comp_apply]
induction m using clifford_algebra.induction
rw [reverse.commutes, reverse.commutes]
case h_grade0 : { rw [reverse.commutes, reverse.commutes] }
rw [reverse_ι, reverse_ι]
case h_grade1 : { rw [reverse_ι, reverse_ι] }
case h_mul : a b ha hb { rw [reverse.map_mul, reverse.map_mul, ha, hb], }
case h_add : a b ha hb { rw [reverse.map_add, reverse.map_add, ha, hb], }
intros
rw dim_submodule_le_one_iff
split
rintros ⟨v₀, hv₀, h⟩
{ rintros ⟨v₀, hv₀, h⟩, exact ⟨v₀, h⟩ }
exact ⟨v₀, h⟩
rintros ⟨v₀, h⟩
{ rintros ⟨v₀, h⟩, by_cases hw : ∃ w : V, w ∈ s ∧ w ≠ 0, { rcases hw with ⟨w, hw, hw0⟩, use [w, hw], rcases mem_span_singleton.1 (h hw) with ⟨r', rfl⟩, have h0 : r' ≠ 0, { rintro rfl, simpa using hw0 }, rwa span_singleton_smul_eq _ h0 }, { push_neg at hw, rw ←submodule.eq_bot_iff at hw, simp [hw] } }
by_cases hw : ∃ w : V, w ∈ s ∧ w ≠ 0
rcases hw with ⟨w, hw, hw0⟩
{ rcases hw with ⟨w, hw, hw0⟩, use [w, hw], rcases mem_span_singleton.1 (h hw) with ⟨r', rfl⟩, have h0 : r' ≠ 0, { rintro rfl, simpa using hw0 }, rwa span_singleton_smul_eq _ h0 }
use [w, hw]
rcases mem_span_singleton.1 (h hw) with ⟨r', rfl⟩
have h0 : r' ≠ 0
rintro rfl
{ rintro rfl, simpa using hw0 }
simpa using hw0
rwa span_singleton_smul_eq _ h0
push_neg at hw
{ push_neg at hw, rw ←submodule.eq_bot_iff at hw, simp [hw] }
rw ←submodule.eq_bot_iff at hw
simp [hw]
intros
rw [← @set_of_mem_eq _ s, ← subtype.range_coe_subtype]
{ rw [← @set_of_mem_eq _ s, ← subtype.range_coe_subtype], exact dim_span hs }
exact dim_span hs
intros
rw [finsupp.total_apply, finsupp.sum_fintype, linear_map.sum_apply]
simp_rw [linear_map.smul_apply, smul_eq_mul, dual_basis_apply_self, mul_boole, finset.sum_ite_eq, if_pos (finset.mem_univ i)]
{ simp_rw [linear_map.smul_apply, smul_eq_mul, dual_basis_apply_self, mul_boole, finset.sum_ite_eq, if_pos (finset.mem_univ i)] }
{ intro, rw zero_smul }
intro
rw zero_smul
intros
simp [to_exterior]
intros
rw [← dim_top, ← subalgebra_top_dim_eq_submodule_top_dim] at h
exact eq.symm (subalgebra.eq_bot_of_dim_one h)
intros
obtain ⟨f, sum, total, nonzero⟩ := exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card h
exact ⟨f, sum, total, exists_pos_of_sum_zero_of_exists_nonzero f total nonzero⟩
intros
have := finrank_range_add_finrank_ker f
rw [← ker_eq_bot, ← range_eq_top]
refine ⟨λ h, _, λ h, _⟩
rw [h, finrank_bot, add_zero, H] at this
{ rw [h, finrank_bot, add_zero, H] at this, exact eq_top_of_finrank_eq this }
exact eq_top_of_finrank_eq this
rw [h, finrank_top, H] at this
{ rw [h, finrank_top, H] at this, exact finrank_eq_zero.1 (add_right_injective _ this) }
exact finrank_eq_zero.1 (add_right_injective _ this)
intros
{ rw span_image_eq_map_total, simp, }
rw span_image_eq_map_total
simp
intros
refine submodule.mem_map.trans ⟨_, _⟩
refine submodule.mem_map.trans ⟨_, _⟩; simp_rw submodule.mem_comap
simp_rw submodule.mem_comap
rintro ⟨⟨y, yO⟩, (yN : y ∈ N), h⟩
{ rintro ⟨⟨y, yO⟩, (yN : y ∈ N), h⟩, exact ⟨y, yO, yN, h⟩ }
exact ⟨y, yO, yN, h⟩
simp_rw submodule.mem_comap
rintro ⟨y, yO, yN, h⟩
{ rintro ⟨y, yO, yN, h⟩, exact ⟨⟨y, yO⟩, yN, h⟩ }
exact ⟨⟨y, yO⟩, yN, h⟩
intros
rw [linear_independent_iff, finsupp.total_comp]
intros l hl
have h_map_domain : ∀ x, (finsupp.map_domain f l) (f x) = 0
rw linear_independent_iff.1 h (finsupp.map_domain f l) hl; simp
rw linear_independent_iff.1 h (finsupp.map_domain f l) hl; simp
rw linear_independent_iff.1 h (finsupp.map_domain f l) hl
rw linear_independent_iff.1 h (finsupp.map_domain f l) hl
simp
simp
ext x
convert h_map_domain x
rw [finsupp.map_domain_apply hf]
intros
rw [det_mul_right_comm, ←mul_eq_mul, ←mul_eq_mul, units.mul_inv, one_mul]
intros
simp [det_apply]
intros
rcases t
{ rcases t, simp [to_matrix, transvection_mul_transvection_same, t_hij] }
simp [to_matrix, transvection_mul_transvection_same, t_hij]
intros
rw [←@neg_one_smul R _ _ _ _ x, map_smul, neg_one_mul, neg_neg, one_mul]
intros
intros x hx
refine hB _ _
rw ← hx x
exact (associated_eq_self_apply _ _ x).symm
intros
ext x
ext x; refl
refl
intros
rw [smodeq.def, submodule.quotient.eq, sub_zero]
intros
simp
intros
dunfold update
congr
funext
rw eq_rec_constant
intros
induction n with n ihn generalizing k
{ rw [nat.zero_add], exact id_left }
rw [nat.zero_add]
exact id_left
rw [nat.succ_eq_add_one, nat.add_right_comm, nat.add_assoc]
{ rw [nat.succ_eq_add_one, nat.add_right_comm, nat.add_assoc], exact (H k).comp_left (ihn (k + 1)) }
exact (H k).comp_left (ihn (k + 1))
intros
induction h' with b c hab hbc ih
{ exact hr _ }
exact hr _
{ exact ht ih (h _ _ hbc) }
exact ht ih (h _ _ hbc)
intros
{ rw ← pi_univ_Icc, exact pi_Ioc_ae_eq_pi_Icc }
rw ← pi_univ_Icc
exact pi_Ioc_ae_eq_pi_Icc
intros
simp_rw [← integral_prod_swap f hf.ae_measurable]
{ simp_rw [← integral_prod_swap f hf.ae_measurable], exact integral_prod _ hf.swap }
exact integral_prod _ hf.swap
intros
have hf_Lp : mem_ℒp f 1 μ
from mem_ℒp_one_iff_integrable.mpr hf
let f_Lp := hf_Lp.to_Lp f
have hf_f_Lp : f =ᵐ[μ] f_Lp
from (mem_ℒp.coe_fn_to_Lp hf_Lp).symm
refine hf_f_Lp.trans _
refine Lp.ae_eq_zero_of_forall_set_integral_eq_zero f_Lp one_ne_zero ennreal.coe_ne_top _ _
exact λ s hs hμs, integrable.integrable_on (L1.integrable_coe_fn _)
{ exact λ s hs hμs, integrable.integrable_on (L1.integrable_coe_fn _), }
intros s hs hμs
{ intros s hs hμs, rw integral_congr_ae (ae_restrict_of_ae hf_f_Lp.symm), exact hf_zero s hs hμs, }
rw integral_congr_ae (ae_restrict_of_ae hf_f_Lp.symm)
exact hf_zero s hs hμs
intros
have hf : ae_measurable' m f μ
from (mem_Lp_meas_subgroup_iff_ae_measurable'.mp hf_meas)
let g := hf.some
obtain ⟨hg, hfg⟩ := hf.some_spec
change mem_ℒp g p (μ.trim hm)
refine ⟨hg.ae_measurable, _⟩
have h_snorm_fg : snorm g p (μ.trim hm) = snorm f p μ
rw snorm_trim hm hg
rw snorm_trim hm hg
{ rw snorm_trim hm hg, exact snorm_congr_ae hfg.symm, }
{ rw snorm_trim hm hg, exact snorm_congr_ae hfg.symm, }
exact snorm_congr_ae hfg.symm
exact snorm_congr_ae hfg.symm
rw h_snorm_fg
exact Lp.snorm_lt_top f
intros
refine lintegral_le_of_forall_fin_meas_le' hm (μ s * ∥x∥₊) _ (λ t ht hμt, _)
rw Lp_meas_coe
{ rw Lp_meas_coe, exact (Lp.ae_measurable _).nnnorm.coe_nnreal_ennreal, }
exact (Lp.ae_measurable _).nnnorm.coe_nnreal_ennreal
refine (set_lintegral_nnnorm_condexp_L2_indicator_le hm hs hμs x ht hμt).trans _
refine ennreal.mul_le_mul _ le_rfl
exact measure_mono (set.inter_subset_left _ _)
intros
simp_rw [mul_comm, h.const_mul _]
intros
simp
intros
cases le_or_lt 0 c with hc hc
{ exact snorm_le_mul_snorm_aux_of_nonneg h hc p }
exact snorm_le_mul_snorm_aux_of_nonneg h hc p
{ simp [snorm_le_mul_snorm_aux_of_neg h hc p] }
simp [snorm_le_mul_snorm_aux_of_neg h hc p]
intros
ext1
refine indicator_const_Lp_coe_fn.trans _
have h_comp_Lp := (continuous_linear_map.to_span_singleton ℝ x).coe_fn_comp_Lp (indicator_const_Lp 2 hs hμs (1 : ℝ))
rw ← eventually_eq at h_comp_Lp
refine eventually_eq.trans _ h_comp_Lp.symm
refine (@indicator_const_Lp_coe_fn _ _ _ 2 μ _ _ s hs hμs (1 : ℝ) _ _).mono (λ y hy, _)
dsimp only
rw hy
simp_rw [continuous_linear_map.to_span_singleton_apply]
by_cases hy_mem : y ∈ s; simp [hy_mem, continuous_linear_map.lsmul_apply]
by_cases hy_mem : y ∈ s
simp [hy_mem, continuous_linear_map.lsmul_apply]
simp [hy_mem, continuous_linear_map.lsmul_apply]
intros
induction N with N ihN
simp
{ simp }
simp only [nearest_pt_ind_succ]
split_ifs
exacts [le_rfl, ihN.trans N.le_succ]
intros
split
introI h
{ introI h, rw ←μ.inv_inv, exact measure.regular.inv }
rw ←μ.inv_inv
exact measure.regular.inv
introI h
{ introI h, exact measure.regular.inv }
exact measure.regular.inv
intros
simp_rw [integral_eq_lintegral_of_nonneg_ae (eventually_of_forall (λ x, (f x).coe_nonneg)) hfi.ae_measurable, ← ennreal.coe_nnreal_eq]
rw [ennreal.of_real_to_real]
rw [← lt_top_iff_ne_top]
convert hfi.has_finite_integral
ext1 x
rw [nnreal.nnnorm_eq]
intros
simp [weighted_smul]
intros
have := integral_sub_integral_sub_linear_is_o_of_tendsto_ae hf hmeas_a hmeas_b ha hb ((continuous_fst.comp continuous_snd).tendsto ((a, b), (a, b))) ((continuous_fst.comp continuous_fst).tendsto ((a, b), (a, b))) ((continuous_snd.comp continuous_snd).tendsto ((a, b), (a, b))) ((continuous_snd.comp continuous_fst).tendsto ((a, b), (a, b)))
refine (this.congr_left _).trans_is_O _
{ intro x, simp [sub_smul] }
intro x
simp [sub_smul]
exact is_O_fst_prod.norm_left.add is_O_snd_prod.norm_left
{ exact is_O_fst_prod.norm_left.add is_O_snd_prod.norm_left }
intros
cases le_total a b with hab hab; simp only [integral_of_le, integral_of_ge, hab, neg_eq_zero]; refine integral_undef (not_imp_not.mpr integrable.integrable_on' _); simpa [hab] using not_and_distrib.mp h
cases le_total a b with hab hab; simp only [integral_of_le, integral_of_ge, hab, neg_eq_zero]; refine integral_undef (not_imp_not.mpr integrable.integrable_on' _)
cases le_total a b with hab hab; simp only [integral_of_le, integral_of_ge, hab, neg_eq_zero]
cases le_total a b with hab hab
simp only [integral_of_le, integral_of_ge, hab, neg_eq_zero]
refine integral_undef (not_imp_not.mpr integrable.integrable_on' _)
simpa [hab] using not_and_distrib.mp h
simp only [integral_of_le, integral_of_ge, hab, neg_eq_zero]
refine integral_undef (not_imp_not.mpr integrable.integrable_on' _)
simpa [hab] using not_and_distrib.mp h
intros
simp [lintegral_congr_ae (ae_eq_dirac f)]
intros
convert μ.inner_content_comap (homeomorph.mul_left g) (λ K, h g) U
intros
simp_rw [← ennreal.coe_one, haar_content_apply, ennreal.coe_eq_coe, chaar_self]
{ simp_rw [← ennreal.coe_one, haar_content_apply, ennreal.coe_eq_coe, chaar_self], refl }
refl
intros
simp only [hausdorff_measure, ← outer_measure.coe_mk_metric, ← outer_measure.comap_apply]
rw [outer_measure.isometry_comap_mk_metric _ hf (hd.imp_left _)]
exact λ hd x y hxy, ennreal.rpow_le_rpow hxy hd
intros
rcases h.exists_Ioo_subset with ⟨l, u, hx, hs⟩
refine lt_of_lt_of_le _ (measure_mono hs)
simpa [-mem_Ioo] using hx.1.trans hx.2
intros
ext1 s hs
simp only [add_apply, sum_apply _ hs, pi.add_apply, coe_add, tsum_add ennreal.summable ennreal.summable]
intros
simp [ae_iff, hc]
intros
rw [restrict_apply ht]
intros
simp_rw [infi_subtype, infi_and, subtype.coe_mk, ← measure_eq_infi]
intros
simp only [infi_comm] {single_pass := tt}
{ simp only [infi_comm] {single_pass := tt}, exact induced_outer_measure_eq_infi measurable_set.Union (λ f _, m.Union_nat f) (λ _ _ _ _ h, m.mono h) s }
exact induced_outer_measure_eq_infi measurable_set.Union (λ f _, m.Union_nat f) (λ _ _ _ _ h, m.mono h) s
intros
rcases outer_regular.outer_regular (measurable_set_to_measurable μ A) r (by rwa measure_to_measurable) with ⟨U, hAU, hUo, hU⟩
exact ⟨U, (subset_to_measurable _ _).trans hAU, hUo, hU⟩
intros
rw [squarefree_iff_nodup_factors h0, card_distinct_factors_apply]
split
split; intro h
intro h
rw ← list.eq_of_sublist_of_length_eq n.factors.erase_dup_sublist h
{ rw ← list.eq_of_sublist_of_length_eq n.factors.erase_dup_sublist h, apply list.nodup_erase_dup }
apply list.nodup_erase_dup
intro h
rw list.erase_dup_eq_self.2 h
{ rw list.erase_dup_eq_self.2 h, refl }
refl
intros
rw mem_divisors_antidiagonal at h
simp [dvd.intro_left _ h.1, h.2]
intros
apply ne_zero_pow (dec_trivial : 2 ≠ 0)
apply ne_of_gt
rw [← h.2.2, (by ring : a ^ 4 + b ^ 4 = (a ^ 2) ^ 2 + (b ^ 2) ^ 2)]
exact add_pos (sq_pos_of_ne_zero _ (pow_ne_zero 2 h.1)) (sq_pos_of_ne_zero _ (pow_ne_zero 2 h.2.1))
intros
{ ext; simp; ring }
ext
ext; simp; ring
ext; simp
simp
simp
intros
simp [cast_eq_of_rat, of_rat_eq]
intros
ring
intros
cases n; simp [*, int.of_nat_eq_coe, int.neg_succ_of_nat_eq]
cases n
simp [*, int.of_nat_eq_coe, int.neg_succ_of_nat_eq]
simp [*, int.of_nat_eq_coe, int.neg_succ_of_nat_eq]
intros
obtain ⟨u, rfl⟩ := h
rw [norm_mul, (norm_eq_one_iff' hd _).mpr u.is_unit, mul_one]
intros
rw [sdiff_eq_self_iff_disjoint, disjoint.comm]
intros
simpa only [compl_compl] using compl_le_compl h
intros
rw [sup_comm, closure_sup_closure_left, sup_comm]
intros
rw [supr, Sup_inf_eq, supr_range]
intros
rw [at_top_Ici_eq, tendsto_comap_iff]
intros
refine tendsto_at_top_mono' _ _ hg
filter_upwards [hg.eventually (eventually_ge_at_top 0), hf.eventually (eventually_ge_at_top 1)]
exact λ x, le_mul_of_one_le_left
intros
refine le_antisymm (hf.tendsto_at_top_at_top $ λ b, ⟨g (b ⊔ b'), le_sup_left.trans $ hgi _ le_sup_right⟩) _
rw [@map_at_top_eq _ _ ⟨g b'⟩]
refine le_infi (λ a, infi_le_of_le (f a ⊔ b') $ principal_mono.2 $ λ b hb, _)
rw [mem_Ici, sup_le_iff] at hb
exact ⟨g b, (gc _ _ hb.2).1 hb.1, le_antisymm ((gc _ _ hb.2).2 (le_refl _)) (hgi _ hb.2)⟩
intros
rw frequently_iff_forall_eventually_exists_and
split
split ; intro h
intro h
intros U U_in
{ intros U U_in, simpa [exists_prop, and_comm] using h U_in }
simpa [exists_prop, and_comm] using h U_in
intro h
intros H H'
{ intros H H', simpa [and_comm] using h H' }
simpa [and_comm] using h H'
intros
casesI is_empty_or_nonempty α with hα hα
rw [filter_eq_bot_of_is_empty (f.comap _), ← not_iff_not]
rw [filter_eq_bot_of_is_empty (f.comap _), ← not_iff_not]; [simpa using hα.elim, apply_instance]
{ rw [filter_eq_bot_of_is_empty (f.comap _), ← not_iff_not]; [simpa using hα.elim, apply_instance] }
simpa using hα.elim
apply_instance
{ simp [comap_ne_bot_iff_frequently, hα] }
simp [comap_ne_bot_iff_frequently, hα]
intros
rw [tendsto, ← map_compose]
{ rw [tendsto, ← map_compose], simp only [(∘), map_comap_of_mem h, tendsto] }
simp only [(∘), map_comap_of_mem h, tendsto]
intros
split
intro h
{ intro h, rcases mem_prod_iff.1 (empty_mem_iff_bot.2 h) with ⟨s, hs, t, ht, hst⟩, rw [subset_empty_iff, set.prod_eq_empty_iff] at hst, cases hst with s_eq t_eq, { left, exact empty_mem_iff_bot.1 (s_eq ▸ hs) }, { right, exact empty_mem_iff_bot.1 (t_eq ▸ ht) } }
rcases mem_prod_iff.1 (empty_mem_iff_bot.2 h) with ⟨s, hs, t, ht, hst⟩
rw [subset_empty_iff, set.prod_eq_empty_iff] at hst
cases hst with s_eq t_eq
{ left, exact empty_mem_iff_bot.1 (s_eq ▸ hs) }
left
exact empty_mem_iff_bot.1 (s_eq ▸ hs)
{ right, exact empty_mem_iff_bot.1 (t_eq ▸ ht) }
right
exact empty_mem_iff_bot.1 (t_eq ▸ ht)
rintro (rfl | rfl)
{ rintro (rfl | rfl), exact bot_prod, exact prod_bot }
exact bot_prod
exact prod_bot
intros
haveI : nonempty {x // x ∈ s} := ne.to_subtype
haveI : nonempty {x // x ∈ s} := ne.to_subtype; erw [infi_subtype', mem_infi_of_directed h.directed_coe, subtype.exists]; refl
haveI : nonempty {x // x ∈ s} := ne.to_subtype; erw [infi_subtype', mem_infi_of_directed h.directed_coe, subtype.exists]
erw [infi_subtype', mem_infi_of_directed h.directed_coe, subtype.exists]
refl
intros
simp only [or_comm _ q, eventually_or_distrib_left]
intros
rw [abs_def, map_const]
intros
simp only [filter.lift, infi_inf_eq, eq_self_iff_true]
intros
simp [tendsto_def, function.graph, rtendsto_def, rel.core, set.preimage]
{ simp [tendsto_def, function.graph, rtendsto_def, rel.core, set.preimage] }
intros
rw [← compl_not_mem_iff, compl_compl]
intros
rw [←supr_partial_sups_eq f, ←supr_partial_sups_eq g]
exact supr_le_supr h
intros
rw [symm_diff_comm, symm_diff_eq_left]
intros
haveI : is_strict_order α (λ a b, r a b ∧ a ≠ b) := { to_is_irrefl := ⟨λ a con, con.2 rfl⟩, to_is_trans := ⟨λ a b c ab bc, ⟨trans ab.1 bc.1, λ ac, ab.2 (antisymm ab.1 (ac.symm ▸ bc.1))⟩⟩ }
rw well_founded_on_iff_no_descending_seq
intros f con
obtain ⟨m, n, hlt, hle⟩ := h f con
exact (f.map_rel_iff.2 hlt).2 (antisymm hle (f.map_rel_iff.2 hlt).1).symm
intros
{ rw add_comm, exact h.add_mul_left_left z }
rw add_comm
exact h.add_mul_left_left z
intros
rw [←mul_one r, ring_hom.map_mul, ring_hom.map_one, ←smul_def, map_smul, map_one_eq_zero, smul_zero]
intros
simpa [add_group.fg_iff_add_monoid.fg] using finite_type_iff_fg
intros
conv {to_rhs, rw ← sub_zero a }; exact quotient.eq'
conv {to_rhs, rw ← sub_zero a }
exact quotient.eq'
intros
refine le_trans (λ x hx, _) bot_le
rw [mem_comap, submodule.mem_bot, ← ring_hom.map_zero f] at hx
exact eq.symm (hf hx) ▸ (submodule.zero_mem ⊥)
intros
ext
rw mem_map_iff_of_surjective (ring_hom.fst R S) prod.fst_surjective
exact ⟨by { rintro ⟨x, ⟨h, rfl⟩⟩, exact h.1 }, λ h, ⟨⟨x, 0⟩, ⟨⟨h, ideal.zero_mem _⟩, rfl⟩⟩⟩
intros
let g := ideal.quotient.mk (I.comap f)
have := ideal.quotient_map_comp_mk le_rfl
refine ⟨λ h, _, λ h, ring_hom.is_integral_tower_top_of_is_integral g _ (this ▸ h)⟩
refine this ▸ ring_hom.is_integral_trans g (ideal.quotient_map I f le_rfl) _ h
exact ring_hom.is_integral_of_surjective g ideal.quotient.mk_surjective
intros
contrapose h
rw [ne.def, not_not, coeff_integer_normalization, dif_neg h]
intros
by_cases triv : (1 : Rₘ) = 0
exact ⟨0, ⟨trans leading_coeff_zero triv.symm, eval₂_zero _ _⟩⟩
{ exact ⟨0, ⟨trans leading_coeff_zero triv.symm, eval₂_zero _ _⟩⟩ }
haveI : nontrivial Rₘ := nontrivial_of_ne 1 0 triv
obtain ⟨b, hb⟩ := is_unit_iff_exists_inv.mp (map_units Rₘ ⟨p.leading_coeff, hM⟩)
refine ⟨(p.map (algebra_map R Rₘ)) * C b, ⟨_, _⟩⟩
refine monic_mul_C_of_leading_coeff_mul_eq_one _
{ refine monic_mul_C_of_leading_coeff_mul_eq_one _, rwa leading_coeff_map_of_leading_coeff_ne_zero (algebra_map R Rₘ), refine λ hfp, zero_ne_one (trans (zero_mul b).symm (hfp ▸ hb) : (0 : Rₘ) = 1) }
rwa leading_coeff_map_of_leading_coeff_ne_zero (algebra_map R Rₘ)
refine λ hfp, zero_ne_one (trans (zero_mul b).symm (hfp ▸ hb) : (0 : Rₘ) = 1)
refine eval₂_mul_eq_zero_of_left _ _ _ _
{ refine eval₂_mul_eq_zero_of_left _ _ _ _, erw [eval₂_map, is_localization.map_comp, ← hom_eval₂ _ f (algebra_map S Sₘ) x], exact trans (congr_arg (algebra_map S Sₘ) hf) (ring_hom.map_zero _) }
erw [eval₂_map, is_localization.map_comp, ← hom_eval₂ _ f (algebra_map S Sₘ) x]
exact trans (congr_arg (algebra_map S Sₘ) hf) (ring_hom.map_zero _)
intros
simp [inv_fun]
intros
split
intros hf
{ intros hf, apply submodule.span_induction hf, { intros f hf n, cases (set.mem_image _ _ _).mp hf with x hx, rw [← hx.right, coeff_C], by_cases (n = 0), { simpa [h] using hx.left }, { simp [h] } }, { simp }, { exact λ f g hf hg n, by simp [I.add_mem (hf n) (hg n)] }, { refine λ f g hg n, _, rw [smul_eq_mul, coeff_mul], exact I.sum_mem (λ c hc, I.smul_mem (f.coeff c.fst) (hg c.snd)) } }
apply submodule.span_induction hf
intros f hf n
{ intros f hf n, cases (set.mem_image _ _ _).mp hf with x hx, rw [← hx.right, coeff_C], by_cases (n = 0), { simpa [h] using hx.left }, { simp [h] } }
cases (set.mem_image _ _ _).mp hf with x hx
rw [← hx.right, coeff_C]
by_cases (n = 0)
{ simpa [h] using hx.left }
simpa [h] using hx.left
{ simp [h] }
simp [h]
{ simp }
simp
{ exact λ f g hf hg n, by simp [I.add_mem (hf n) (hg n)] }
exact λ f g hf hg n, by simp [I.add_mem (hf n) (hg n)]
refine λ f g hg n, _
{ refine λ f g hg n, _, rw [smul_eq_mul, coeff_mul], exact I.sum_mem (λ c hc, I.smul_mem (f.coeff c.fst) (hg c.snd)) }
rw [smul_eq_mul, coeff_mul]
exact I.sum_mem (λ c hc, I.smul_mem (f.coeff c.fst) (hg c.snd))
intros hf
{ intros hf, rw ← sum_monomial_eq f, refine (I.map C : ideal (polynomial R)).sum_mem (λ n hn, _), simp [monomial_eq_C_mul_X], rw mul_comm, exact (I.map C : ideal (polynomial R)).mul_mem_left _ (mem_map_of_mem _ (hf n)) }
rw ← sum_monomial_eq f
refine (I.map C : ideal (polynomial R)).sum_mem (λ n hn, _)
simp [monomial_eq_C_mul_X]
rw mul_comm
exact (I.map C : ideal (polynomial R)).mul_mem_left _ (mem_map_of_mem _ (hf n))
intros
rw flip' _ _ _ h
simp [polynomial.eval_comp, h]
obtain rfl | h' := h.eq_or_lt
{ simp, }
simp
congr
{ congr, norm_cast, rw [nat.sub_sub, nat.sub_sub_self (nat.succ_le_iff.mpr h')] }
norm_cast
rw [nat.sub_sub, nat.sub_sub_self (nat.succ_le_iff.mpr h')]
intros
rw [content, finset.gcd_eq_zero_iff]
split
split; intro h
intro h
ext n
{ ext n, by_cases h0 : n ∈ p.support, { rw [h n h0, coeff_zero], }, { rw mem_support_iff at h0, push_neg at h0, simp [h0] } }
by_cases h0 : n ∈ p.support
{ rw [h n h0, coeff_zero], }
rw [h n h0, coeff_zero]
rw mem_support_iff at h0
{ rw mem_support_iff at h0, push_neg at h0, simp [h0] }
push_neg at h0
simp [h0]
intro h
intros x h0
{ intros x h0, simp [h] }
simp [h]
intros
obtain ⟨P, hP⟩ := int_coeff_of_cyclotomic' h
refine ⟨P, hP.1, λ Q hQ, _⟩
apply (map_injective (int.cast_ring_hom K) int.cast_injective)
rw [hP.1, hQ]
intros
rw dickson_one_one_eq_chebyshev_T
simp only [comp_assoc, mul_comp, C_comp, X_comp, ← mul_assoc, ← C_1, ← C_bit0, ← C_mul]
rw [inv_of_mul_self, C_1, one_mul, one_mul, comp_X]
intros
cases b
rw [nat.desc_factorial_zero, pochhammer_zero, polynomial.eval_one]
{ rw [nat.desc_factorial_zero, pochhammer_zero, polynomial.eval_one] }
rw [nat.add_succ, nat.succ_sub_succ, nat.sub_zero]
cases a
rw [pochhammer_ne_zero_eval_zero _ b.succ_ne_zero, zero_add, nat.desc_factorial_of_lt b.lt_succ_self]
{ rw [pochhammer_ne_zero_eval_zero _ b.succ_ne_zero, zero_add, nat.desc_factorial_of_lt b.lt_succ_self] }
rw [nat.succ_add, ←nat.add_succ, nat.add_desc_factorial_eq_asc_factorial, pochhammer_nat_eq_asc_factorial]
{ rw [nat.succ_add, ←nat.add_succ, nat.add_desc_factorial_eq_asc_factorial, pochhammer_nat_eq_asc_factorial] }
intros
rw [esymm, (map f).map_sum]
refine sum_congr rfl (λ x hx, _)
rw (map f).map_prod
simp
intros
nontriviality S
obtain ⟨f, _, hf⟩ := exists_eq_aeval pb y
exact ⟨f, hf⟩
intros
ext
simp only [function.comp_app, ring_hom.coe_comp, rescale, ring_hom.coe_mk, power_series.coeff_mk _ _, coeff_C]
split_ifs
simp only [h, one_mul, coeff_zero_eq_constant_coeff, pow_zero]
{ simp only [h, one_mul, coeff_zero_eq_constant_coeff, pow_zero], }
{ rw [zero_pow' n h, zero_mul], }
rw [zero_pow' n h, zero_mul]
intros
simp [X]
intros
ext
{ ext, simp }
simp
intros
have h0 : C 0 := add_neg_self (1:R) ▸ ha h1 hneg1
rcases exists_list_of_mem_closure hx with ⟨L, HL, rfl⟩
clear hx
induction L with hd tl ih
exact h0
{ exact h0 }
rw list.forall_mem_cons at HL
suffices : C (list.prod hd)
rw [list.map_cons, list.sum_cons]
{ rw [list.map_cons, list.sum_cons], exact ha this (ih HL.2) }
exact ha this (ih HL.2)
replace HL := HL.1
clear ih tl
suffices : ∃ L : list R, (∀ x ∈ L, x ∈ s) ∧ (list.prod hd = list.prod L ∨ list.prod hd = -list.prod L)
rcases this with ⟨L, HL', HP | HP⟩
{ rcases this with ⟨L, HL', HP | HP⟩, { rw HP, clear HP HL hd, induction L with hd tl ih, { exact h1 }, rw list.forall_mem_cons at HL', rw list.prod_cons, exact hs _ HL'.1 _ (ih HL'.2) }, rw HP, clear HP HL hd, induction L with hd tl ih, { exact hneg1 }, rw [list.prod_cons, neg_mul_eq_mul_neg], rw list.forall_mem_cons at HL', exact hs _ HL'.1 _ (ih HL'.2) }
rw HP
{ rw HP, clear HP HL hd, induction L with hd tl ih, { exact h1 }, rw list.forall_mem_cons at HL', rw list.prod_cons, exact hs _ HL'.1 _ (ih HL'.2) }
clear HP HL hd
induction L with hd tl ih
exact h1
{ exact h1 }
rw list.forall_mem_cons at HL'
rw list.prod_cons
exact hs _ HL'.1 _ (ih HL'.2)
rw HP
clear HP HL hd
induction L with hd tl ih
exact hneg1
{ exact hneg1 }
rw [list.prod_cons, neg_mul_eq_mul_neg]
rw list.forall_mem_cons at HL'
exact hs _ HL'.1 _ (ih HL'.2)
induction hd with hd tl ih
{ exact ⟨[], list.forall_mem_nil _, or.inl rfl⟩ }
exact ⟨[], list.forall_mem_nil _, or.inl rfl⟩
rw list.forall_mem_cons at HL
rcases ih HL.2 with ⟨L, HL', HP | HP⟩
rcases ih HL.2 with ⟨L, HL', HP | HP⟩; cases HL.1 with hhd hhd
cases HL.1 with hhd hhd
exact ⟨hd :: L, list.forall_mem_cons.2 ⟨hhd, HL'⟩, or.inl $ by rw [list.prod_cons, list.prod_cons, HP]⟩
{ exact ⟨hd :: L, list.forall_mem_cons.2 ⟨hhd, HL'⟩, or.inl $ by rw [list.prod_cons, list.prod_cons, HP]⟩ }
exact ⟨L, HL', or.inr $ by rw [list.prod_cons, hhd, neg_one_mul, HP]⟩
{ exact ⟨L, HL', or.inr $ by rw [list.prod_cons, hhd, neg_one_mul, HP]⟩ }
cases HL.1 with hhd hhd
exact ⟨hd :: L, list.forall_mem_cons.2 ⟨hhd, HL'⟩, or.inr $ by rw [list.prod_cons, list.prod_cons, HP, neg_mul_eq_mul_neg]⟩
{ exact ⟨hd :: L, list.forall_mem_cons.2 ⟨hhd, HL'⟩, or.inr $ by rw [list.prod_cons, list.prod_cons, HP, neg_mul_eq_mul_neg]⟩ }
exact ⟨L, HL', or.inl $ by rw [list.prod_cons, hhd, HP, neg_one_mul, neg_neg]⟩
{ exact ⟨L, HL', or.inl $ by rw [list.prod_cons, hhd, HP, neg_one_mul, neg_neg]⟩ }
intros
apply tensor_product.induction_on x
{ simp, }
simp
apply tensor_product.induction_on y
{ simp, }
simp
apply tensor_product.induction_on z
{ simp, }
simp
{ intros, simp [h], }
intros
simp [h]
{ intros, simp [linear_map.map_add, *], }
intros
simp [linear_map.map_add, *]
{ intros, simp [linear_map.map_add, *], }
intros
simp [linear_map.map_add, *]
{ intros, simp [linear_map.map_add, *], }
intros
simp [linear_map.map_add, *]
intros
ext
{ ext, rw [linear_map.comp_apply, linear_map.restrict_scalars_apply, trace_trace] }
rw [linear_map.comp_apply, linear_map.restrict_scalars_apply, trace_trace]
intros
rw count_pow ha hp
{ rw count_pow ha hp, apply dvd_mul_right }
apply dvd_mul_right
intros
{ subst h }
subst h
intros
apply (zmod_equiv_trunc p n).injective
rw ← commutes'
simp
intros
unfreezingI { obtain ⟨φ, hf⟩ := hf, obtain ⟨ψ, hg⟩ := hg, obtain ⟨χ, hh⟩ := hh }
obtain ⟨φ, hf⟩ := hf
obtain ⟨ψ, hg⟩ := hg
obtain ⟨χ, hh⟩ := hh
refine ⟨⟨(λ n, bind₁ (uncurry $ ![λ k, rename (prod.mk (0 : fin 2)) (φ k), λ k, rename (prod.mk (1 : fin 2)) (ψ k)]) (χ n)), _⟩⟩
intros
funext n
simp only [peval, aeval_bind₁, function.comp, hh, hf, hg, uncurry]
apply eval₂_hom_congr rfl _ rfl
ext ⟨i, n⟩
fin_cases i; simp only [aeval_eq_eval₂_hom, eval₂_hom_rename, function.comp, matrix.cons_val_zero, matrix.head_cons, matrix.cons_val_one]
fin_cases i
simp only [aeval_eq_eval₂_hom, eval₂_hom_rename, function.comp, matrix.cons_val_zero, matrix.head_cons, matrix.cons_val_one]
simp only [aeval_eq_eval₂_hom, eval₂_hom_rename, function.comp, matrix.cons_val_zero, matrix.head_cons, matrix.cons_val_one]
intros
have : function.injective (int.cast_ring_hom ℚ) := int.cast_injective
rw [← vars_map_of_injective _ this, map_witt_structure_int]
apply witt_structure_rat_vars
intros
rw [ghost_component_apply, aeval_witt_polynomial, finset.range_one, finset.sum_singleton, verschiebung_fun_coeff_zero, pow_zero, pow_zero, pow_one, one_mul]
intros
{ rw [lt_omega_iff_fintype], exact ⟨finset.subtype.fintype s⟩ }
rw [lt_omega_iff_fintype]
exact ⟨finset.subtype.fintype s⟩
intros
simp [lt_iff_le_not_le, -not_le]
intros
{ apply sup_lt _ _ H2, rwa [hc.2] }
apply sup_lt _ _ H2
rwa [hc.2]
intros
rw ← lists'.of_to_list l; exact of_list_subset (list.subset.refl _)
rw ← lists'.of_to_list l
exact of_list_subset (list.subset.refl _)
intros
simp only [lt_ord, card_ord]
intros
simpa only [one_mul] using mul_div_cancel a ordinal.one_ne_zero
intros
simp [scale_eq_mul]
intros
simp [h]
intros
simp only [int.to_nat_of_nonpos, h.le, neg_nonpos]
intros
simp [horner]
intros
cc
intros
unfold_wf; assumption
unfold_wf
assumption
intros
rw [is_open_iff_of_not_mem infty_not_mem_image_coe, preimage_image_eq _ coe_injective]
intros
convert (tendsto_nhds_within_of_tendsto_nhds tendsto_id).sub (tendsto_floor_left' n)
convert (tendsto_nhds_within_of_tendsto_nhds tendsto_id).sub (tendsto_floor_left' n); [{norm_cast, ring}, apply_instance, apply_instance]
norm_cast
ring
apply_instance
apply_instance
intros
{ ext, simp }
ext
simp
intros
rw mem_nhds_within_Iic_iff_exists_Ioc_subset
split
rintros ⟨l, la, as⟩
{ rintros ⟨l, la, as⟩, rcases exists_between la with ⟨v, hv⟩, refine ⟨v, hv.2, λx hx, as ⟨lt_of_lt_of_le hv.1 hx.1, hx.2⟩⟩, }
rcases exists_between la with ⟨v, hv⟩
refine ⟨v, hv.2, λx hx, as ⟨lt_of_lt_of_le hv.1 hx.1, hx.2⟩⟩
rintros ⟨l, la, as⟩
{ rintros ⟨l, la, as⟩, exact ⟨l, la, subset.trans Ioc_subset_Icc_self as⟩ }
exact ⟨l, la, subset.trans Ioc_subset_Icc_self as⟩
intros
rw [← comap_coe_Ioo_nhds_within_Ioi, tendsto_comap_iff]
intros
have := @continuous_on_Ico_extend_from_Ioo (order_dual α) _ _ _ _ _ _ _ f _ _ _ hab
erw [dual_Ico, dual_Ioi, dual_Ioo] at this
exact this hf hb
intros
rw [←is_open_compl_iff, compl_compl]
intros
split
intros h x
{ intros h x, apply h.1, { exact subset_univ _ }, exact is_preconnected_connected_component }
apply h.1
{ exact subset_univ _ }
exact subset_univ _
exact is_preconnected_connected_component
intro h
constructor
intros s s_sub hs
rcases eq_empty_or_nonempty s with rfl | ⟨x, x_in⟩
{ exact subsingleton_empty }
exact subsingleton_empty
{ exact (h x).mono (hs.subset_connected_component x_in) }
exact (h x).mono (hs.subset_connected_component x_in)
intros
refine le_antisymm (continuous_at_snd.mono_left inf_le_left) (λ s hs, _)
rcases x with ⟨x, y⟩
rw [mem_map, nhds_within, mem_inf_principal, mem_nhds_prod_iff] at hs
rcases hs with ⟨u, hu, v, hv, H⟩
simp only [prod_subset_iff, mem_singleton_iff, mem_set_of_eq, mem_preimage] at H
exact mem_of_superset hv (λ z hz, H _ (mem_of_mem_nhds hu) _ hz rfl)
intros
{ rw algebra.algebra_map_eq_smul_one, refl, }
rw algebra.algebra_map_eq_smul_one
refl
intros
change continuous (comp_right_continuous_map R f)
continuity
intros
rw polynomial_functions_closure_eq_top _ _
simp
intros
simp only [mem_closure_iff_nhds_within_ne_bot, nhds_within_pi_ne_bot]
intros
simpa only [nhds_within_univ, image_univ] using (h.left_inv_on univ).map_nhds_within_eq (h x) (by rwa image_univ) hg.continuous_within_at
intros
simp
intros
rw [← e.coe_fst ex, ← map_congr (e.coe_fst_eventually_eq_proj ex), ← map_map, ← e.coe_coe, e.to_local_homeomorph.map_nhds_eq ex, map_fst_nhds]
intros
rw [metric.diam, real.ediam_eq h, ennreal.to_real_of_real]
rw real.bounded_iff_bdd_below_bdd_above at h
exact sub_nonneg.2 (real.Inf_le_Sup s h.1 h.2)
intros
rw [Sup_eq_supr, bsupr_add hs]
intros
rw [nhds_list, list.traverse_cons _, ← nhds_list]
rw [nhds_list, list.traverse_cons _, ← nhds_list]; apply_instance
intros
ext
{ ext, refl }
refl
intros
{ ext p, simp [dist_pi_lt_iff hr] }
ext p
simp [dist_pi_lt_iff hr]
intros
simpa only [dist_comm _ x] using comap_dist_right_at_top_le_cocompact x
intros
{ rw dist_comm, refl }
rw dist_comm
refl
intros
apply induction_on x
refine is_closed_eq _ continuous_const
{ refine is_closed_eq _ continuous_const, exact (completion.uniform_continuous_dist.continuous.comp (continuous.prod_mk continuous_id continuous_id : _) : _) }
exact (completion.uniform_continuous_dist.continuous.comp (continuous.prod_mk continuous_id continuous_id : _) : _)
assume a
{ assume a, rw [completion.dist_eq, dist_self] }
rw [completion.dist_eq, dist_self]
intros
rw ← image_univ
refine dimH_image_le_of_locally_holder_on hr (λ x _, _)
simpa only [exists_prop, nhds_within_univ] using hf x
intros
rw [Hausdorff_edist_zero_iff_closure_eq_closure, closure_closure]
intros
rw Hausdorff_edist_comm at fin
have I : Hausdorff_dist u s ≤ Hausdorff_dist u t + Hausdorff_dist t s := Hausdorff_dist_triangle fin
simpa [add_comm, Hausdorff_dist_comm] using I
intros
{ rw [(@gc α _).l_Sup, set.sUnion_image], refl }
rw [(@gc α _).l_Sup, set.sUnion_image]
refl
intros
rw [nhds_induced, filter.map_comap_of_mem h]
intros
have : is_path_connected (univ : set X) := path_connected_space_iff_univ.mp (by apply_instance)
rcases this.exists_path_through_family' p (λ i, true.intro) with ⟨γ, t, -, h⟩
exact ⟨γ, t, h⟩
intros
rintros u v hu hv ⟨_, ⟨⟨x, hx, rfl⟩, hxu⟩⟩ ⟨_, ⟨⟨y, hy, rfl⟩, hyv⟩⟩
rw ← mem_preimage at hxu hyv
rcases continuous_on_iff'.1 hf u hu with ⟨u', hu', u'_eq⟩
rcases continuous_on_iff'.1 hf v hv with ⟨v', hv', v'_eq⟩
have := H u' v' hu' hv'
rw [inter_comm s u', ← u'_eq] at this
rw [inter_comm s v', ← v'_eq] at this
rcases this ⟨x, hxu, hx⟩ ⟨y, hyv, hy⟩ with ⟨z, hzs, hzu', hzv'⟩
refine ⟨f z, mem_image_of_mem f hzs, _, _⟩
all_goals { rw ← mem_preimage, apply mem_of_mem_inter_left, show z ∈ _ ∩ s, simp [*] }
rw ← mem_preimage
apply mem_of_mem_inter_left
show z ∈ _ ∩ s
simp [*]
rw ← mem_preimage
apply mem_of_mem_inter_left
show z ∈ _ ∩ s
simp [*]
intros
rw ← image_univ; exact compact_univ.image hf
rw ← image_univ
exact compact_univ.image hf
intros
ext p
ext p; cases p; simp only [mem_comp_rel]; tauto
ext p; cases p; simp only [mem_comp_rel]
ext p; cases p
cases p
simp only [mem_comp_rel]
tauto
intros
unfold inits
rw inits_core_eq
refl
contradiction
intros
rw [← h]
apply int.nat_abs_bit0
intros
have h := int.add_lt_add_right h b
rwa [int.sub_add_cancel, int.zero_add] at h
intros
rw int.add_comm at h
exact int.lt_add_of_sub_left_lt h
intros
funext m n
revert n
dsimp [function.swap]
apply binary_rec _ (λ a m' IH, _) m; intro n
apply binary_rec _ (λ a m' IH, _) m
intro n
{ rw [bitwise_zero_left, bitwise_zero_right], exact h }
rw [bitwise_zero_left, bitwise_zero_right]
exact h
intro n
apply bit_cases_on n; intros b n'
apply bit_cases_on n
intros b n'
rw [bitwise_bit, bitwise_bit, IH]; exact h
rw [bitwise_bit, bitwise_bit, IH]
exact h
exact h
exact h
exact h
intros
by_cases hba : b ≤ a
simp [le_antisymm hba h₁]
{ simp [le_antisymm hba h₁] }
by_cases hc0 : c ≤ 0
simp [le_antisymm hc0 c.zero_le, nat.zero_mul]
{ simp [le_antisymm hc0 c.zero_le, nat.zero_mul] }
exact (le_not_le_of_lt (nat.mul_lt_mul_of_pos_left (lt_of_le_not_le h₁ hba) (lt_of_le_not_le c.zero_le hc0))).left
intros
rw [←@vsub_eq_zero_iff_eq G, vadd_vsub_assoc, vsub_vadd_eq_vsub_sub]
simp
intros
simp [bit0, add_smul, smul_add]
intros
subst hT; exact set.Union_lift_mk x hx
subst hT
exact set.Union_lift_mk x hx
intros
induction n with n ih
rw pow_zero at h
{ rw pow_zero at h, have := is_unit_of_dvd_one _ h, have := not_unit hp, contradiction }
have := is_unit_of_dvd_one _ h
have := not_unit hp
contradiction
rw pow_succ at h
cases dvd_or_dvd hp h with dvd_a dvd_pow
{ assumption }
assumption
exact ih dvd_pow
intros
haveI := classical.dec_eq α; from classical.by_cases (assume : a ∈ s, prod_eq_single_of_mem a this h₀) (assume : a ∉ s, (prod_congr rfl $ λ b hb, h₀ b hb $ by rintro rfl; cc).trans $ prod_const_one.trans (h₁ this).symm)
haveI := classical.dec_eq α
from classical.by_cases (assume : a ∈ s, prod_eq_single_of_mem a this h₀) (assume : a ∉ s, (prod_congr rfl $ λ b hb, h₀ b hb $ by rintro rfl; cc).trans $ prod_const_one.trans (h₁ this).symm)
intros
{ rw [sum_product, sum_mul, sum_congr rfl], intros, rw mul_sum }
rw [sum_product, sum_mul, sum_congr rfl]
intros
rw mul_sum
intros
cases char_p.char_is_prime_or_zero R p with h h
{ exact h, }
exact h
{ contradiction, }
contradiction
intros
by_cases hn : n = 0
subst hn
{ subst hn, simp }
simp
{ exact cast_dvd n_dvd (cast_ne_zero.mpr hn), }
exact cast_dvd n_dvd (cast_ne_zero.mpr hn)
intros
simp [*, squash_seq, (seq.zip_with_nth_some (seq.nats_nth n) s_nth_eq _)]
intros
simp [partial_numerators, s_nth_eq]
intros
{ conv {to_lhs, rw [xgcd_aux]}, exact if_neg h}
conv {to_lhs, rw [xgcd_aux]}
exact if_neg h
intros
rw [div_add_div _ _ ha hb, one_mul, mul_one, add_comm]
intros
rw [of_mul_assoc, of_mul_assoc, of_mul_assoc, of_mul_assoc_left]
intros
simp
intros
rw [sub_add_eq_sub_sub_swap]; simp
rw [sub_add_eq_sub_sub_swap]
simp
intros
simp [sub_eq_neg_add, add_comm]
intros
simpa only [sq_abs] using pow_le_pow_of_le_left (abs_nonneg x) h 2
intros
simp [div_eq_mul_inv a 1]
intros
rw [mul_comm, (div_mul_cancel _ hb)]
intros
simp [single_map_homological_complex]
intros
{ dsimp [of], rw [dif_neg h] }
dsimp [of]
rw [dif_neg h]
intros
rcases i with (_|_|i); { dsimp, simp, }
rcases i with (_|_|i)
{ dsimp, simp, }
{ dsimp, simp, }
dsimp
{ dsimp, simp, }
simp
intros
{ simp only [mul_indicator], split_ifs; refl }
simp only [mul_indicator]
split_ifs
split_ifs; refl
refl
refl
intros
rw is_semisimple_iff_no_solvable_ideals
split
split; intros h₁ I h₂
intros h₁ I h₂
haveI : is_lie_abelian I := h₂
{ haveI : is_lie_abelian I := h₂, apply h₁, exact lie_algebra.of_abelian_is_solvable R I, }
apply h₁
exact lie_algebra.of_abelian_is_solvable R I
intros h₁ I h₂
haveI : is_solvable R I := h₂
{ haveI : is_solvable R I := h₂, rw ← abelian_of_solvable_ideal_eq_bot_iff, apply h₁, exact abelian_derived_abelian_of_ideal I, }
rw ← abelian_of_solvable_ideal_eq_bot_iff
apply h₁
exact abelian_derived_abelian_of_ideal I
intros
dunfold derived_abelian_of_ideal
cases h : derived_length_of_ideal R L I with k
{ exact is_lie_abelian_bot R L, }
exact is_lie_abelian_bot R L
rw derived_series_of_derived_length_succ at h
{ rw derived_series_of_derived_length_succ at h, exact h.1, }
exact h.1
intros
{ intros m hm, erw mem_lie_span, intros K hK, exact hK hm, }
intros m hm
erw mem_lie_span
intros K hK
exact hK hm
intros
{ intros m hm, erw mem_lie_span, intros N hN, exact hN hm, }
intros m hm
erw mem_lie_span
intros N hN
exact hN hm
intros
apply lie_module.weight_vector_multiplication H L M M ((to_module_hom R L M).restrict_lie H) χ₁ χ₂
simp only [lie_module_hom.coe_to_linear_map, function.comp_app, linear_map.coe_comp, tensor_product.map_incl, linear_map.mem_range]
use [⟨x, hx⟩ ⊗ₜ ⟨m, hm⟩]
simp only [submodule.subtype_apply, to_module_hom_apply, submodule.coe_mk, lie_module_hom.coe_restrict_lie, tensor_product.map_tmul]
intros
induction n with n ih
{ rw [nat.cast_zero, zero_smul, zero_smul] }
rw [nat.cast_zero, zero_smul, zero_smul]
rw [nat.succ_eq_add_one, nat.cast_succ, add_smul, add_smul, one_smul, ih, one_smul]
{ rw [nat.succ_eq_add_one, nat.cast_succ, add_smul, add_smul, one_smul, ih, one_smul], }
intros
rwa [← one_div a, le_div_iff' ha, ← div_eq_mul_inv, div_le_iff (ha.trans_le h), one_mul]
intros
simpa using le_inv_of_neg ha hb
intros
rw [abs_div, abs_one]
intros
rw [← mul_lt_mul_iff_right b, inv_mul_cancel_right, one_mul]
intros
rw [div_eq_mul_inv, div_eq_mul_inv, ← mul_lt_mul_iff_left a⁻¹, inv_mul_cancel_left, inv_mul_cancel_left, inv_lt_inv_iff]
intros
norm_cast
intros
rw [mul_comm, ha.mul_le_iff_le_one_right]
intros
by_cases ba : b ≤ a
simp [ba.antisymm h₁]
{ simp [ba.antisymm h₁] }
by_cases c0 : c ≤ 0
simp [c0.antisymm h₂]
{ simp [c0.antisymm h₂] }
exact (mul_lt_mul_of_pos_right (h₁.lt_of_not_le ba) (h₂.lt_of_not_le c0)).le
intros
simpa only [sub_eq_neg_add] using h (-x)
intros
rw [←left_cancel x, right_inv]
exact ((h x).left_inverse y).symm
intros
rcases ua with ⟨a, rfl⟩
exact units.is_regular a
intros
simp
intros
rw [sub_eq_add_neg, mul_support_one_add', support_neg']
intros
rw [← set_like.mem_coe, coe_vanishing_ideal, set.mem_set_of_eq]
intros
{ cases x, refl }
cases x
refl
intros
ext j
suffices : ite (fin.cast_succ i < ite (j < i) (fin.cast_succ j) j.succ) (ite (j < i) (j:ℕ) (j + 1) - 1) (ite (j < i) j (j + 1)) = j
dsimp [δ, σ, fin.succ_above, fin.pred_above]
{ dsimp [δ, σ, fin.succ_above, fin.pred_above], simpa [fin.pred_above] with push_cast }
simpa [fin.pred_above] with push_cast
rcases i with ⟨i, _⟩
rcases j with ⟨j, _⟩
dsimp
simp only [if_congr, subtype.mk_lt_mk]
split_ifs; { simp at *; linarith, }
split_ifs
{ simp at *; linarith, }
{ simp at *; linarith, }
{ simp at *; linarith, }
simp at *
simp at *; linarith
{ simp at *; linarith, }
linarith
intros
dsimp [δ, σ]
{ dsimp [δ, σ], simp only [←X.map_comp, simplex_category.σ_comp_σ H] }
simp only [←X.map_comp, simplex_category.σ_comp_σ H]
intros
simp only [change_origin_series_term, linear_isometry_equiv.norm_map]
intros
ext1 n
dsimp [formal_multilinear_series.comp]
rw finset.sum_eq_single (composition.ones n)
show comp_along_composition p (id 𝕜 E) (composition.ones n) = p n
ext v
{ ext v, rw comp_along_composition_apply, apply p.congr (composition.ones_length n), intros, rw apply_composition_ones, refine congr_arg v _, rw [fin.ext_iff, fin.coe_cast_le, fin.coe_mk, fin.coe_mk], }
rw comp_along_composition_apply
apply p.congr (composition.ones_length n)
intros
rw apply_composition_ones
refine congr_arg v _
rw [fin.ext_iff, fin.coe_cast_le, fin.coe_mk, fin.coe_mk]
show ∀ (b : composition n), b ∈ finset.univ → b ≠ composition.ones n → comp_along_composition p (id 𝕜 E) b = 0
assume b _ hb
{ assume b _ hb, obtain ⟨k, hk, lt_k⟩ : ∃ (k : ℕ) (H : k ∈ composition.blocks b), 1 < k := composition.ne_ones_iff.1 hb, obtain ⟨i, i_lt, hi⟩ : ∃ (i : ℕ) (h : i < b.blocks.length), b.blocks.nth_le i h = k := nth_le_of_mem hk, let j : fin b.length := ⟨i, b.blocks_length ▸ i_lt⟩, have A : 1 < b.blocks_fun j := by convert lt_k, ext v, rw [comp_along_composition_apply, continuous_multilinear_map.zero_apply], apply continuous_multilinear_map.map_coord_zero _ j, dsimp [apply_composition], rw id_apply_ne_one _ _ (ne_of_gt A), refl }
obtain ⟨k, hk, lt_k⟩ : ∃ (k : ℕ) (H : k ∈ composition.blocks b), 1 < k := composition.ne_ones_iff.1 hb
obtain ⟨i, i_lt, hi⟩ : ∃ (i : ℕ) (h : i < b.blocks.length), b.blocks.nth_le i h = k := nth_le_of_mem hk
let j : fin b.length := ⟨i, b.blocks_length ▸ i_lt⟩
have A : 1 < b.blocks_fun j := by convert lt_k
ext v
rw [comp_along_composition_apply, continuous_multilinear_map.zero_apply]
apply continuous_multilinear_map.map_coord_zero _ j
dsimp [apply_composition]
rw id_apply_ne_one _ _ (ne_of_gt A)
refl
{ simp }
simp
intros
rw left_inv
intros
rw is_o
intros
simp only [is_O, is_O_with_map]
intros
rw is_O_iff
rw is_O_iff; refl
refl
intros
simpa only [div_eq_mul_inv] using (hc.has_deriv_at.mul_const d⁻¹).differentiable_at
intros
simp [deriv_within, fderiv_within_const_sub hxs]
intros
simpa only [add_comm] using fderiv_within_add_const hxs c
intros
rw differentiable_at.fderiv_within (h.differentiable_at p) hxs
exact h.fderiv p
intros
rw [has_fderiv_at, has_fderiv_at_filter, ← map_add_left_nhds_zero x, is_o_map]
simp [(∘)]
intros
apply filter.eventually_eq.fderiv_within_eq hs _ hx
apply mem_of_superset self_mem_nhds_within
exact hL
intros
{ rw ← nat.succ_pred_eq_of_pos h, refl }
rw ← nat.succ_pred_eq_of_pos h
refl
intros
rw times_cont_diff_on_succ_iff_fderiv_within hs.unique_diff_on
congr' 2
rw ← iff_iff_eq
apply times_cont_diff_on_congr
assume x hx
exact fderiv_within_of_open hs hx
intros
have := (h.cont 0 bot_le).congr (λ x hx, (h.zero_eq' hx).symm)
rwa linear_isometry_equiv.comp_continuous_on_iff at this
intros
split
assume h
{ assume h, exact ⟨h.of_le (with_top.coe_le_coe.2 (nat.le_succ n)), h.fderiv_within _ (with_top.coe_lt_coe.2 (lt_add_one n)), h.cont (n + 1) (le_refl _)⟩ }
exact ⟨h.of_le (with_top.coe_le_coe.2 (nat.le_succ n)), h.fderiv_within _ (with_top.coe_lt_coe.2 (lt_add_one n)), h.cont (n + 1) (le_refl _)⟩
assume h
{ assume h, split, { exact h.1.zero_eq }, { assume m hm, by_cases h' : m < n, { exact h.1.fderiv_within m (with_top.coe_lt_coe.2 h') }, { have : m = n := nat.eq_of_lt_succ_of_not_lt (with_top.coe_lt_coe.1 hm) h', rw this, exact h.2.1 } }, { assume m hm, by_cases h' : m ≤ n, { apply h.1.cont m (with_top.coe_le_coe.2 h') }, { have : m = (n + 1) := le_antisymm (with_top.coe_le_coe.1 hm) (not_le.1 h'), rw this, exact h.2.2 } } }
split
{ exact h.1.zero_eq }
exact h.1.zero_eq
assume m hm
{ assume m hm, by_cases h' : m < n, { exact h.1.fderiv_within m (with_top.coe_lt_coe.2 h') }, { have : m = n := nat.eq_of_lt_succ_of_not_lt (with_top.coe_lt_coe.1 hm) h', rw this, exact h.2.1 } }
by_cases h' : m < n
{ exact h.1.fderiv_within m (with_top.coe_lt_coe.2 h') }
exact h.1.fderiv_within m (with_top.coe_lt_coe.2 h')
have : m = n := nat.eq_of_lt_succ_of_not_lt (with_top.coe_lt_coe.1 hm) h'
{ have : m = n := nat.eq_of_lt_succ_of_not_lt (with_top.coe_lt_coe.1 hm) h', rw this, exact h.2.1 }
rw this
exact h.2.1
assume m hm
{ assume m hm, by_cases h' : m ≤ n, { apply h.1.cont m (with_top.coe_le_coe.2 h') }, { have : m = (n + 1) := le_antisymm (with_top.coe_le_coe.1 hm) (not_le.1 h'), rw this, exact h.2.2 } }
by_cases h' : m ≤ n
{ apply h.1.cont m (with_top.coe_le_coe.2 h') }
apply h.1.cont m (with_top.coe_le_coe.2 h')
have : m = (n + 1) := le_antisymm (with_top.coe_le_coe.1 hm) (not_le.1 h')
{ have : m = (n + 1) := le_antisymm (with_top.coe_le_coe.1 hm) (not_le.1 h'), rw this, exact h.2.2 }
rw this
exact h.2.2
intros
rintro z ⟨hxz, hyz⟩
obtain rfl | h := (hxz.trans hyz).eq_or_lt
rw segment_same
{ rw segment_same, exact hyz.antisymm hxz }
exact hyz.antisymm hxz
rw ←sub_nonneg at hxz hyz
rw ←sub_pos at h
refine ⟨(y - z) / (y - x), (z - x) / (y - x), div_nonneg hyz h.le, div_nonneg hxz h.le, _, _⟩
{ rw [←add_div, sub_add_sub_cancel, div_self h.ne'] }
rw [←add_div, sub_add_sub_cancel, div_self h.ne']
rw [smul_eq_mul, smul_eq_mul, ←mul_div_right_comm, ←mul_div_right_comm, ←add_div, div_eq_iff h.ne', add_comm, sub_mul, sub_mul, mul_comm x, sub_add_sub_cancel, mul_sub]
{ rw [smul_eq_mul, smul_eq_mul, ←mul_div_right_comm, ←mul_div_right_comm, ←add_div, div_eq_iff h.ne', add_comm, sub_mul, sub_mul, mul_comm x, sub_add_sub_cancel, mul_sub] }
intros
simp only [convex.combo_eq_vadd h, ← vsub_eq_sub]
exact f.apply_line_map _ _ _
intros
rw [norm_sub_mul_self, add_right_cancel_iff, sub_eq_add_neg, add_right_eq_self, neg_eq_zero, mul_eq_zero]
norm_num
intros
{ rw [inner_smul_right, algebra.smul_def], refl }
rw [inner_smul_right, algebra.smul_def]
refl
intros
simp [inner_eq_sum_norm_sq_div_four, ← f.norm_map]
intros
rw [pi_Lp.norm_eq_of_nat 2]; simp [sqrt_eq_rpow]
{ rw [pi_Lp.norm_eq_of_nat 2]; simp [sqrt_eq_rpow] }
rw [pi_Lp.norm_eq_of_nat 2]
simp [sqrt_eq_rpow]
simp [sqrt_eq_rpow]
intros
ext w
{ ext w, exact eq_sum_orthogonal_projection_self_orthogonal_complement K w }
exact eq_sum_orthogonal_projection_self_orthogonal_complement K w
intros
rw [dist_comm, dist_left_midpoint]
intros
rw [← mem_closure_iff_nhds_within_ne_bot, metric.mem_closure_iff]
rintros ε ε0
rcases normed_field.exists_norm_lt α ε0 with ⟨b, hb0, hbε⟩
refine ⟨x + b, mt (set.mem_singleton_iff.trans add_right_eq_self).1 $ norm_pos_iff.1 hb0, _⟩
rwa [dist_comm, dist_eq_norm, add_sub_cancel']
intros
rw [frontier, closure_ball x hr, is_open_ball.interior_eq]
ext x
exact (@eq_iff_le_not_lt ℝ _ _ _).symm
intros
have : bounded (f '' s) := (hs.image_of_continuous_on hf).bounded
rcases bounded_iff_forall_norm_le.1 this with ⟨C, hC⟩
exact ⟨C, λ x hx, hC _ (set.mem_image_of_mem _ hx)⟩
intros
conv_rhs { rw ← norm_le_zero_iff' }
split
split ; intro h
intro h
{ rw h }
rw h
intro h
{ exact le_antisymm h (norm_nonneg g) }
exact le_antisymm h (norm_nonneg g)
intros
rw ← exp_series_apply_eq'
exact exp_series_has_sum_exp_of_mem_ball x hx
intros
apply multilinear_map.mk_continuous_norm_le
exact mul_nonneg (norm_nonneg _) (pow_nonneg (norm_nonneg _) _)
intros
ext x
rw [normed_group_hom.completion_def, normed_group_hom.coe_id, completion.map_id]
refl
intros
obtain ⟨m, rfl⟩ := hquot.surjective n
have nonemp : ((λ m', ∥m + m'∥) '' f.ker).nonempty
rw set.nonempty_image_iff
{ rw set.nonempty_image_iff, exact ⟨0, f.ker.zero_mem⟩ }
exact ⟨0, f.ker.zero_mem⟩
rcases real.lt_Inf_add_pos nonemp hε with ⟨_, ⟨⟨x, hx, rfl⟩, H : ∥m + x∥ < Inf ((λ (m' : M), ∥m + m'∥) '' f.ker) + ε⟩⟩
exact ⟨m+x, by rw [f.map_add,(normed_group_hom.mem_ker f x).mp hx, add_zero], by rwa hquot.norm⟩
intros
simp [norm_eq, h, real.sqrt_eq_rpow, ←real.rpow_nat_cast]
intros
apply f.dist_lt_of_dist_lt_modulus (ε/2) (half_pos h)
simpa [S] using m
rw [← coe_comp_exp_order_iso, ← filter.map_map, exp_order_iso.map_at_bot, ← map_coe_Ioi_at_bot]
intros
rw div_eq_inv_mul
exact (has_strict_deriv_at_log hx).comp x hf
intros
have : (n : ℝ) + 2 ≠ 0 := by exact_mod_cast succ_ne_zero n.succ
field_simp
convert eq_sub_iff_add_eq.mp (integral_cos_pow_aux n)
ring
intros
convert (has_deriv_at_rpow_const hx).comp_has_deriv_within_at x hf using 1
ring
intros
simp [rpow_eq_top_iff, hy, asymm hy]
intros
rw [ennreal.to_real, ennreal.to_real, ←nnreal.coe_rpow, ennreal.to_nnreal_rpow]
intros
convert rpow_lt_rpow_of_exponent_lt hx hz
{ convert rpow_lt_rpow_of_exponent_lt hx hz, exact (rpow_zero x).symm }
exact (rpow_zero x).symm
simp [sin_add]
{ rw real.range_sin, exact Icc.infinite (by norm_num) }
rw real.range_sin
exact Icc.infinite (by norm_num)
simp [tan_eq_sin_div_cos]
intros
rw [← complex.cos_sub_pi_div_two, cos_eq_zero_iff]
split
rintros ⟨k, hk⟩
{ rintros ⟨k, hk⟩, use k + 1, field_simp [eq_add_of_sub_eq hk], ring }
use k + 1
field_simp [eq_add_of_sub_eq hk]
ring
rintros ⟨k, rfl⟩
{ rintros ⟨k, rfl⟩, use k - 1, field_simp, ring }
use k - 1
field_simp
ring
intros
simp [arccos, sub_eq_zero]
convert has_sum_geometric_of_lt_1 _ _; norm_num
convert has_sum_geometric_of_lt_1 _ _
norm_num
norm_num
norm_num
intros
rw eventually_at_top at h
rcases h with ⟨N₀, hN₀⟩
rw frequently_at_top at hf
rcases hf N₀ with ⟨N, hNN₀ : N₀ ≤ N, hN⟩
rw ← @summable_nat_add_iff α _ _ _ _ N
refine mt summable.tendsto_at_top_zero (λ h', not_tendsto_at_top_of_tendsto_nhds (tendsto_norm_zero.comp h') _)
convert tendsto_at_top_of_geom_le _ hr _
refine lt_of_le_of_ne (norm_nonneg _) _
{ refine lt_of_le_of_ne (norm_nonneg _) _, intro h'', specialize hN₀ N hNN₀, simp only [comp_app, zero_add] at h'', exact hN h''.symm }
intro h''
specialize hN₀ N hNN₀
simp only [comp_app, zero_add] at h''
exact hN h''.symm
intro i
{ intro i, dsimp only [comp_app], convert (hN₀ (i + N) (hNN₀.trans (N.le_add_left i))) using 3, ac_refl }
dsimp only [comp_app]
convert (hN₀ (i + N) (hNN₀.trans (N.le_add_left i))) using 3
ac_refl
intros
rw [cokernel.condition_assoc, zero_comp]
intros
simp only [←mk_hom g, lift.fac_right]
intros
{ convert cancel_mono f, simp, }
convert cancel_mono f
simp
intros
simp only [category.id_comp, eq_to_hom_refl, category.comp_id]
intros
erw [nat_iso.naturality_2]
refl
intros
cases f; cases g
cases f
cases g
congr
dsimp at w_base
induction w_base
refl
dsimp at w_base
induction w_base
simpa using w_fiber
intros
ext
{ ext, simp, }
simp
intros
{ rw c.ι.naturality f, apply comp_id }
rw c.ι.naturality f
apply comp_id
intros
dsimp [limit_curry_swap_comp_lim_iso_limit_curry_comp_lim]
simp only [iso.refl_hom, braiding_counit_iso_hom_app, limits.has_limit.iso_of_equivalence_hom_π, iso.refl_inv, limit_iso_limit_curry_comp_lim_hom_π_π, eq_to_iso_refl, category.assoc]
erw [nat_trans.id_app]
dsimp
simp
intros
simp
intros
simp
intros
simp [is_iso.inv_comp_eq]
intros
simpa [h] using B.ι_π j j'
intros
tidy
intros
rw [←cofork.left_app_one, cokernel_cofork.condition]
intros
letI := is_reflexive_pair.mk' r rf rg
apply_instance
intros
rw [(has_zero_object.unique_to X).uniq f, (has_zero_object.unique_to X).uniq g]
intros
{ ext, simp [←tensor_comp], }
ext
simp [←tensor_comp]
intros
rw [←tensor_comp, f.inv_hom_id]
intros
simp only [←category.assoc, cancel_mono]
intros
haveI : mono f := preadditive.mono_of_kernel_zero (kernel_zero_of_nonzero_from_simple w)
exact is_iso_of_mono_of_nonzero w
intros
classical
by_contradiction h
apply w
exact is_iso_of_epi_of_nonzero h
intros
{ apply (cancel_mono X.arrow).mp, simp }
apply (cancel_mono X.arrow).mp
simp
intros
{ ext, simp, dsimp, simp, }
ext
simp
dsimp
simp
intros
refine (finset.order_emb_of_fin_unique' _ _).symm
exact λ i, (finset.mem_map' _).2 (finset.mem_univ _)
intros
simp only [eq_self_iff_true, and_self, eq_iff_join_eq, join_split_wrt_composition, map_length_split_wrt_composition, h]
intros
simp only [line.apply, line.map, option.get_or_else_map]
intros
ext d
simp only [mem_image, true_and, mem_filter, set_coe.exists, mem_univ, exists_prop_of_true]
split
rintro rfl
{ rintro rfl, exact ⟨_, d.is_adj, dart.ext _ _ rfl rfl⟩, }
exact ⟨_, d.is_adj, dart.ext _ _ rfl rfl⟩
rintro ⟨e, he, rfl⟩
{ rintro ⟨e, he, rfl⟩, refl, }
refl
intros
rw ←to_NFA_correct at hx ⊢
exact M.to_NFA.pumping_lemma hx hlen
intros
induction x with a x ih generalizing P Q
rw [rmatch, match_epsilon]
{ rw [rmatch, match_epsilon], split, { intro h, refine ⟨ [], [], rfl, _ ⟩, rw [rmatch, rmatch], rwa band_coe_iff at h }, { rintro ⟨ t, u, h₁, h₂ ⟩, cases list.append_eq_nil.1 h₁.symm with ht hu, subst ht, subst hu, repeat {rw rmatch at h₂}, finish } }
split
intro h
{ intro h, refine ⟨ [], [], rfl, _ ⟩, rw [rmatch, rmatch], rwa band_coe_iff at h }
refine ⟨ [], [], rfl, _ ⟩
rw [rmatch, rmatch]
rwa band_coe_iff at h
rintro ⟨ t, u, h₁, h₂ ⟩
{ rintro ⟨ t, u, h₁, h₂ ⟩, cases list.append_eq_nil.1 h₁.symm with ht hu, subst ht, subst hu, repeat {rw rmatch at h₂}, finish }
cases list.append_eq_nil.1 h₁.symm with ht hu
subst ht
subst hu
rw rmatch at h₂
repeat {rw rmatch at h₂}
rw rmatch at h₂
rw rmatch at h₂
finish
rw [rmatch, deriv]
{ rw [rmatch, deriv], split_ifs with hepsilon, { rw [add_rmatch_iff, ih], split, { rintro (⟨ t, u, _ ⟩ | h), { exact ⟨ a :: t, u, by tauto ⟩ }, { exact ⟨ [], a :: x, rfl, hepsilon, h ⟩ } }, { rintro ⟨ t, u, h, hP, hQ ⟩, cases t with b t, { right, rw list.nil_append at h, rw ←h at hQ, exact hQ }, { left, refine ⟨ t, u, by finish, _, hQ ⟩, rw rmatch at hP, convert hP, finish } } }, { rw ih, split; rintro ⟨ t, u, h, hP, hQ ⟩, { exact ⟨ a :: t, u, by tauto ⟩ }, { cases t with b t, { contradiction }, { refine ⟨ t, u, by finish, _, hQ ⟩, rw rmatch at hP, convert hP, finish } } } }
split_ifs with hepsilon
rw [add_rmatch_iff, ih]
{ rw [add_rmatch_iff, ih], split, { rintro (⟨ t, u, _ ⟩ | h), { exact ⟨ a :: t, u, by tauto ⟩ }, { exact ⟨ [], a :: x, rfl, hepsilon, h ⟩ } }, { rintro ⟨ t, u, h, hP, hQ ⟩, cases t with b t, { right, rw list.nil_append at h, rw ←h at hQ, exact hQ }, { left, refine ⟨ t, u, by finish, _, hQ ⟩, rw rmatch at hP, convert hP, finish } } }
split
rintro (⟨ t, u, _ ⟩ | h)
{ rintro (⟨ t, u, _ ⟩ | h), { exact ⟨ a :: t, u, by tauto ⟩ }, { exact ⟨ [], a :: x, rfl, hepsilon, h ⟩ } }
exact ⟨ a :: t, u, by tauto ⟩
{ exact ⟨ a :: t, u, by tauto ⟩ }
exact ⟨ [], a :: x, rfl, hepsilon, h ⟩
{ exact ⟨ [], a :: x, rfl, hepsilon, h ⟩ }
rintro ⟨ t, u, h, hP, hQ ⟩
{ rintro ⟨ t, u, h, hP, hQ ⟩, cases t with b t, { right, rw list.nil_append at h, rw ←h at hQ, exact hQ }, { left, refine ⟨ t, u, by finish, _, hQ ⟩, rw rmatch at hP, convert hP, finish } }
cases t with b t
right
{ right, rw list.nil_append at h, rw ←h at hQ, exact hQ }
rw list.nil_append at h
rw ←h at hQ
exact hQ
left
{ left, refine ⟨ t, u, by finish, _, hQ ⟩, rw rmatch at hP, convert hP, finish }
refine ⟨ t, u, by finish, _, hQ ⟩
rw rmatch at hP
convert hP
finish
rw ih
{ rw ih, split; rintro ⟨ t, u, h, hP, hQ ⟩, { exact ⟨ a :: t, u, by tauto ⟩ }, { cases t with b t, { contradiction }, { refine ⟨ t, u, by finish, _, hQ ⟩, rw rmatch at hP, convert hP, finish } } }
split; rintro ⟨ t, u, h, hP, hQ ⟩
split
rintro ⟨ t, u, h, hP, hQ ⟩
{ exact ⟨ a :: t, u, by tauto ⟩ }
exact ⟨ a :: t, u, by tauto ⟩
rintro ⟨ t, u, h, hP, hQ ⟩
cases t with b t
{ cases t with b t, { contradiction }, { refine ⟨ t, u, by finish, _, hQ ⟩, rw rmatch at hP, convert hP, finish } }
contradiction
{ contradiction }
refine ⟨ t, u, by finish, _, hQ ⟩
{ refine ⟨ t, u, by finish, _, hQ ⟩, rw rmatch at hP, convert hP, finish }
rw rmatch at hP
convert hP
finish
intros
induction c; intros k v; rw step_normal
induction c; intros k v
induction c
intros k v
rw step_normal
simp only [code.eval, pure_bind]
iterate 3 { simp only [code.eval, pure_bind] }
intros k v
rw step_normal
simp only [code.eval, pure_bind]
intros k v
rw step_normal
simp only [code.eval, pure_bind]
intros k v
rw step_normal
case cons : f fs IHf IHfs { rw [code.eval, IHf], simp only [bind_assoc, cont.eval, pure_bind], congr, funext v, rw [reaches_eval], swap, exact refl_trans_gen.single rfl, rw [step_ret, IHfs], congr, funext v', refine eq.trans _ (eq.symm _); try {exact reaches_eval (refl_trans_gen.single rfl)} }
intros k v
rw step_normal
case comp : f g IHf IHg { rw [code.eval, IHg], simp only [bind_assoc, cont.eval, pure_bind], congr, funext v, rw [reaches_eval], swap, exact refl_trans_gen.single rfl, rw [step_ret, IHf] }
intros k v
rw step_normal
case case : f g IHf IHg { simp only [code.eval], cases v.head; simp only [nat.elim, code.eval]; [apply IHf, apply IHg] }
intros k v
rw step_normal
case fix : f IHf { rw cont_eval_fix IHf }
intros
induction n with n IH generalizing i L
cases i; simp only [list_blank.nth_zero, if_true, list_blank.head_cons, list_blank.modify_nth, eq_self_iff_true, list_blank.nth_succ, if_false, list_blank.tail_cons]
cases i
{ cases i; simp only [list_blank.nth_zero, if_true, list_blank.head_cons, list_blank.modify_nth, eq_self_iff_true, list_blank.nth_succ, if_false, list_blank.tail_cons] }
simp only [list_blank.nth_zero, if_true, list_blank.head_cons, list_blank.modify_nth, eq_self_iff_true, list_blank.nth_succ, if_false, list_blank.tail_cons]
simp only [list_blank.nth_zero, if_true, list_blank.head_cons, list_blank.modify_nth, eq_self_iff_true, list_blank.nth_succ, if_false, list_blank.tail_cons]
cases i
{ cases i, { rw if_neg (nat.succ_ne_zero _).symm, simp only [list_blank.nth_zero, list_blank.head_cons, list_blank.modify_nth] }, { simp only [IH, list_blank.modify_nth, list_blank.nth_succ, list_blank.tail_cons], congr } }
rw if_neg (nat.succ_ne_zero _).symm
{ rw if_neg (nat.succ_ne_zero _).symm, simp only [list_blank.nth_zero, list_blank.head_cons, list_blank.modify_nth] }
simp only [list_blank.nth_zero, list_blank.head_cons, list_blank.modify_nth]
simp only [IH, list_blank.modify_nth, list_blank.nth_succ, list_blank.tail_cons]
{ simp only [IH, list_blank.modify_nth, list_blank.nth_succ, list_blank.tail_cons], congr }
intros
simp only [mjoin, (∘), id.def, map_bind, (bind_pure_comp_eq_map _ _).symm, bind_assoc, pure_bind]
intros
induction x; simp! * with functor_norm
induction x
simp! * with functor_norm
simp! * with functor_norm
intros
induction l with hd tl hl
{ simpa }
simpa
rw [to_buffer_cons]
{ rw [to_buffer_cons], have : [hd].to_buffer.size = 1 := rfl, simp [add_comm, this] }
have : [hd].to_buffer.size = 1 := rfl
simp [add_comm, this]
intros
introI h
have : (failure : parser α) buffer.nil 0 = fail 0 dlist.empty := by simp
exact of_fail this
intros
simp [str_eq_char_buf, char_buf_iff, ←string.to_list_inj, buffer.ext_iff]
intros
cases hp : p cb n; simp [←is_lawful_monad.bind_pure_comp_eq_map, hp, and_assoc, pure_eq_done]
cases hp : p cb n
simp [←is_lawful_monad.bind_pure_comp_eq_map, hp, and_assoc, pure_eq_done]
simp [←is_lawful_monad.bind_pure_comp_eq_map, hp, and_assoc, pure_eq_done]
intros
simp [many_char, many_eq_done_nil, map_eq_done, list.as_string_eq]
intros
simp
intros
simp [inv_def, division_def]
intros
rw [← of_real_nat_cast, abs_of_nonneg (nat.cast_nonneg n)]
intros
rw [← sqrt_sq hx.le, ← sqrt_inv, inv_one_add_tan_sq hx.ne']
intros
rw [sq_sub_sq, cosh_add_sinh, cosh_sub_sinh, ← exp_add, add_neg_self, exp_zero]
intros
{ simp_rw [← smul_eq_mul, of_real_alg r], simp, }
simp_rw [← smul_eq_mul, of_real_alg r]
simp
intros
rw [← of_real_zero, ← of_real_inv, inv_zero]
intros
ext i
ext i; simp
simp
intros
by_cases h : b = a; simp [swap_apply_def, h]
{ by_cases h : b = a; simp [swap_apply_def, h], }
by_cases h : b = a
simp [swap_apply_def, h]
simp [swap_apply_def, h]
intros
cases e
{ cases e, refl }
refl
intros
rw [fin_rotate_succ_apply, fin.coe_add_one i]
intros
refine iff.intro _ _
intro h
{ intro h, cases succ_above_lt_ge p i with H H, { rw succ_above_below _ _ H at h, exact le_of_lt h }, { exact H } }
cases succ_above_lt_ge p i with H H
rw succ_above_below _ _ H at h
{ rw succ_above_below _ _ H at h, exact le_of_lt h }
exact le_of_lt h
{ exact H }
exact H
intro h
{ intro h, rw succ_above_above _ _ h, exact lt_of_le_of_lt h (cast_succ_lt_succ i) }
rw succ_above_above _ _ h
exact lt_of_le_of_lt h (cast_succ_lt_succ i)
intros
{ ext j, simp [tail, fin.succ_ne_zero] }
ext j
simp [tail, fin.succ_ne_zero]
intros
rw [eq_comm, zero_eq_one_iff]
intros
cases i; refl
cases i
refl
intros
rw [← insert_emptyc_eq, piecewise_insert, piecewise_empty]
intros
{ ext, simp [-finset.mem_map, -equiv.trans_to_embedding] }
ext
simp [-finset.mem_map, -equiv.trans_to_embedding]
intros
show _ ≥ _ ↔ _
apply fold_op_rel_iff_or
intros x y z
show _ ≤ _ ↔ _
exact min_le_iff
intros
simp [to_finset]
intros
{ ext x, simp [and_comm] }
ext x
simp [and_comm]
intros
ext x
ext x; refl
refl
intros
{ ext, refl }
ext
refl
intros
rw ←card_of_finset s H; congr
rw ←card_of_finset s H
congr
intros
simpa using fintype.sum_pow_mul_eq_add_pow (fin n) a b
intros
rw [to_nat_eq_max, max_eq_left h]
intros
{ rw mul_comm, exact div_add_mod _ _ }
rw mul_comm
exact div_add_mod _ _
intros
have := mod_add_div a b; rwa [H, zero_add] at this
have := mod_add_div a b
rwa [H, zero_add] at this
intros
rw ←pow_one p; exact pow_dvd_of_le_of_pow_dvd hk hpk
rw ←pow_one p
exact pow_dvd_of_le_of_pow_dvd hk hpk
intros
rw [modeq, zero_mod, dvd_iff_mod_eq_zero]
intros
cases mod_two_eq_zero_or_one n with h h; simp [h]
cases mod_two_eq_zero_or_one n with h h
simp [h]
simp [h]
intros
simp only [insert_entries]; exact p.kinsert s₁.nodupkeys
simp only [insert_entries]
exact p.kinsert s₁.nodupkeys
intros
simp only [update_nth_eq_modify_nth, nth_modify_nth_ne _ _ h]
intros
rw [modify_nth_eq_take_drop, drop_eq_nth_le_cons h]
rw [modify_nth_eq_take_drop, drop_eq_nth_le_cons h]; refl
refl
intros
apply ext_le h (λ i h₁ h₂, _)
have : (L.take (i + 1)).sum = (L'.take (i + 1)).sum := h' _ (nat.succ_le_of_lt h₁)
rw [sum_take_succ L i h₁, sum_take_succ L' i h₂, h' i (le_of_lt h₁)] at this
exact add_left_cancel this
intros
convert lt_of_lt_of_le (sum_take_map_length_lt1 L hi hj) (monotone_sum_take _ hi)
have : L.length = (L.map length).length
simp
simp
simp [this, -length_map]
intros
rw [← length_map, lookmap_map_eq _ (λ _, ()), length_map]
rw [← length_map, lookmap_map_eq _ (λ _, ()), length_map]; simp
simp
intros
rw [eq_comm, append_eq_nil]
intros
induction l with x l IH generalizing n
{ simp }
simp
cases n
{ cases n, { simp }, { simpa using IH n _ } }
{ simp }
simp
{ simpa using IH n _ }
simpa using IH n _
intros
by_cases h : ∃ a ∈ l, p a
rcases h with ⟨a, ha, pa⟩
{ rcases h with ⟨a, ha, pa⟩, exact or.inr (exists_of_erasep ha pa) }
exact or.inr (exists_of_erasep ha pa)
{ simp at h, exact or.inl (erasep_of_forall_not h) }
simp at h
exact or.inl (erasep_of_forall_not h)
intros
revert hd
suffices : ∀ (xs' : list α) (h : ∀ x ∈ xs, x ∈ xs') (hd : d ∈ xs'), next_or xs x d ∈ xs'
{ exact this xs (λ _, id) }
exact this xs (λ _, id)
intros xs' hxs' hd
induction xs with y ys ih
{ exact hd }
exact hd
cases ys with z zs
{ exact hd }
exact hd
rw next_or
split_ifs with h
{ exact hxs' _ (mem_cons_of_mem _ (mem_cons_self _ _)) }
exact hxs' _ (mem_cons_of_mem _ (mem_cons_self _ _))
{ exact ih (λ _ h, hxs' _ (mem_cons_of_mem _ h)) }
exact ih (λ _ h, hxs' _ (mem_cons_of_mem _ h))
intros
generalize eq : f a = b
cases b
{ rw filter_map_cons_none _ _ eq }
rw filter_map_cons_none _ _ eq
{ rw filter_map_cons_some _ _ _ eq }
rw filter_map_cons_some _ _ _ eq
intros
simp only [nodup_append, and.left_comm, disjoint_comm]
intros
rw [fin_range, length_pmap, length_range]
intros
simp [cyclic_permutations_of_ne_nil _ h]
intros
induction l₁ generalizing l₂
simp
case list.nil { simp }
case list.cons : _ _ ih { simp [not_or_distrib] at h, simp [h.1, ih h.2] }
intros
rw [← sublists'_reverse, reverse_reverse]
intros
{ rw [length_zip_with, lt_min_iff] at h, exact h.right }
rw [length_zip_with, lt_min_iff] at h
exact h.right
intros
ext i j
ext i j; simp
simp
intros
simp [matrix.mul_apply, ring_hom.map_sum]
intros
simp [sub_eq_add_neg]
intros
ext
simp only [map_apply, block_diagonal_apply, eq_comm]
rw [apply_ite f, hf]
intros
{ ext i, refine fin.cases _ _ i; simp [vec_mul_vec] }
ext i
refine fin.cases _ _ i
refine fin.cases _ _ i; simp [vec_mul_vec]
simp [vec_mul_vec]
simp [vec_mul_vec]
intros
rw [add_comm, union_add_distrib, add_comm s, add_comm s]
intros
ext a
by_cases h : a ∈ s; simp [h,h0]
by_cases h : a ∈ s
simp [h,h0]
simp [h,h0]
intros
haveI := classical.dec_eq α
rw [revzip_powerset_aux_lemma l revzip_powerset_aux, revzip_powerset_aux_lemma l revzip_powerset_aux']
exact powerset_aux_perm_powerset_aux'.map _
intros
{ funext x, exact comap_id_apply x }
funext x
exact comap_id_apply x
intros
refine le_trans (total_degree_multiset_prod _) _
rw [multiset.map_map]
refl
intros
rw [←nat.div_mul_cancel w, h, one_mul]
intros
bitwise_assoc_tac
intros
{ rw [←coe_nat n], apply top_ne_coe }
rw [←coe_nat n]
apply top_ne_coe
intros
induction n with n ih
simp
rw triangle_succ n
{rw triangle_succ n, simp [choose, ih], rw add_comm}
simp [choose, ih]
rw add_comm
intros
rw [dist.def, nat.sub_eq_zero_of_le h, zero_add]
intros
rw [add_comm z, add_comm z, enat.add_lt_add_iff_right hz]
intros
induction k with t ht
refl
unfold asc_factorial
rw [ht, zero_add, nat.factorial_succ]
intros
rw [gcd_comm m n, gcd_comm m (k * n), H.gcd_mul_left_cancel n]
intros
rw even_mul
convert n.even_or_odd
simp with parity_simps
intros
rw size
conv { to_lhs, rw [binary_rec], simp [h] }
rw div2_bit
intros
rw nat.div_mod_unique (pos_num.cast_pos _)
induction n with n IH n IH
exact divmod_to_nat_aux (by simp; refl) (nat.mul_le_mul_left 2 (pos_num.cast_pos d : (0 : ℕ) < d))
{ exact divmod_to_nat_aux (by simp; refl) (nat.mul_le_mul_left 2 (pos_num.cast_pos d : (0 : ℕ) < d)) }
unfold divmod
{ unfold divmod, cases divmod d n with q r, simp only [divmod] at IH ⊢, apply divmod_to_nat_aux; simp, { rw [_root_.bit1, _root_.bit1, add_right_comm, bit0_eq_two_mul ↑n, ← IH.1, mul_add, ← bit0_eq_two_mul, mul_left_comm, ← bit0_eq_two_mul] }, { rw ← bit0_eq_two_mul, exact nat.bit1_lt_bit0 IH.2 } }
cases divmod d n with q r
simp only [divmod] at IH ⊢
apply divmod_to_nat_aux; simp
apply divmod_to_nat_aux
simp
rw [_root_.bit1, _root_.bit1, add_right_comm, bit0_eq_two_mul ↑n, ← IH.1, mul_add, ← bit0_eq_two_mul, mul_left_comm, ← bit0_eq_two_mul]
{ rw [_root_.bit1, _root_.bit1, add_right_comm, bit0_eq_two_mul ↑n, ← IH.1, mul_add, ← bit0_eq_two_mul, mul_left_comm, ← bit0_eq_two_mul] }
simp
rw ← bit0_eq_two_mul
{ rw ← bit0_eq_two_mul, exact nat.bit1_lt_bit0 IH.2 }
exact nat.bit1_lt_bit0 IH.2
unfold divmod
{ unfold divmod, cases divmod d n with q r, simp only [divmod] at IH ⊢, apply divmod_to_nat_aux; simp, { rw [bit0_eq_two_mul ↑n, ← IH.1, mul_add, ← bit0_eq_two_mul, mul_left_comm, ← bit0_eq_two_mul] }, { rw ← bit0_eq_two_mul, exact nat.bit0_lt IH.2 } }
cases divmod d n with q r
simp only [divmod] at IH ⊢
apply divmod_to_nat_aux; simp
apply divmod_to_nat_aux
simp
rw [bit0_eq_two_mul ↑n, ← IH.1, mul_add, ← bit0_eq_two_mul, mul_left_comm, ← bit0_eq_two_mul]
{ rw [bit0_eq_two_mul ↑n, ← IH.1, mul_add, ← bit0_eq_two_mul, mul_left_comm, ← bit0_eq_two_mul] }
simp
rw ← bit0_eq_two_mul
{ rw ← bit0_eq_two_mul, exact nat.bit0_lt IH.2 }
exact nat.bit0_lt IH.2
intros
rw [← size_eq_nat_size, size_to_nat]
intros
cases x; simp only [map_none', map_some', h, mem_def]
{ cases x; simp only [map_none', map_some', h, mem_def] }
cases x
simp only [map_none', map_some', h, mem_def]
simp only [map_none', map_some', h, mem_def]
intros
cases b; refl
cases b
refl
refl
intros
refine valid'.dual_iff.2 _
rw dual_rotate_r
refine hr.dual.rotate_l hl.dual _ _ _
{ rwa [size_dual, size_dual, add_comm] }
rwa [size_dual, size_dual, add_comm]
{ rwa [size_dual, size_dual] }
rwa [size_dual, size_dual]
{ rwa [size_dual, size_dual] }
rwa [size_dual, size_dual]
intros
rw [length_to_list', size_eq_real_size h]
intros
linarith
intros
ext
ext; dsimp [pequiv.trans]; refl
ext; dsimp [pequiv.trans]
dsimp [pequiv.trans]
refl
intros
simp [mem_core, mem_res]
intros
ext
simp only [supp, image_univ, mem_range, mem_set_of_eq]
split
split; intro h
intro h
apply @h (λ i x, ∃ (y : P.B a i), f i y = x)
{ apply @h (λ i x, ∃ (y : P.B a i), f i y = x), rw liftp_iff', intros, refine ⟨_,rfl⟩ }
rw liftp_iff'
intros
refine ⟨_,rfl⟩
intro h
simp only [liftp_iff']
{ simp only [liftp_iff'], cases h, subst x, tauto }
cases h
subst x
tauto
intros
{ cases n with n h, cases n; [exact absurd h dec_trivial, refl] }
cases n with n h
cases n
cases n; [exact absurd h dec_trivial, refl]
exact absurd h dec_trivial
refl
intros
let h := @factor_multiset_le_iff m v.prod
{ let h := @factor_multiset_le_iff m v.prod, rw [v.factor_multiset_prod] at h, exact h }
rw [v.factor_multiset_prod] at h
exact h
intros
rw [← with_bot.coe_le_coe, ← degree_eq_nat_degree]
exact le_degree_of_ne_zero h
{ assume h, subst h, exact h rfl }
assume h
subst h
exact h rfl
intros
{ rw [next_coeff, if_neg], contrapose! hp, simpa }
rw [next_coeff, if_neg]
contrapose! hp
simpa
intros
simp only [←C_eq_int_cast, nat_trailing_degree_C]
intros
simp [multiplicity, root_multiplicity, part.dom]
simp [multiplicity, root_multiplicity, part.dom]; congr; funext; congr
simp [multiplicity, root_multiplicity, part.dom]; congr; funext
simp [multiplicity, root_multiplicity, part.dom]; congr
congr
funext
congr
intros
induction ps using list.reverse_rec_on with ps p ihp
{ simp }
simp
simp only [list.forall_mem_append, list.forall_mem_singleton] at hf
{ simp only [list.forall_mem_append, list.forall_mem_singleton] at hf, simp [eval₂_mul_noncomm _ _ hf.2, ihp hf.1] }
simp [eval₂_mul_noncomm _ _ hf.2, ihp hf.1]
intros
rw [bit0, eval₂_add, bit0]
intros
rw [← monomial_zero_left, hasse_deriv_monomial, nat.choose_eq_zero_of_lt hk, nat.cast_zero, zero_mul, monomial_zero_right]
intros
rw [leading_coeff, trailing_coeff, mirror_nat_trailing_degree, coeff_mirror, rev_at_le (nat.le_add_left _ _), nat.add_sub_cancel]
intros
rw [reverse, coeff_reflect]
intros
refine root_multiplicity_of_dvd hzero _
have hdivp : (X - C a) ^ root_multiplicity a p ∣ p := pow_root_multiplicity_dvd p a
have hdivq : (X - C a) ^ root_multiplicity a q ∣ q := pow_root_multiplicity_dvd q a
exact min_pow_dvd_add hdivp hdivq
intros
rw [corecF, pfunctor.M.dest_corec]
intros
rw [bit1, cast_add, cast_one, cast_bit0]; refl
rw [bit1, cast_add, cast_one, cast_bit0]
refl
intros
simp [ennreal.of_real]
intros
assume x y hxy
obtain ⟨n, rfl⟩ := nat.exists_eq_succ_of_ne_zero hn
induction n with n IH
{ simp only [hxy, pow_one] }
simp only [hxy, pow_one]
simp only [pow_succ _ n.succ, mul_lt_mul hxy (IH (nat.succ_pos _).ne')]
{ simp only [pow_succ _ n.succ, mul_lt_mul hxy (IH (nat.succ_pos _).ne')] }
intros
rw [bit0, add_eq_top, or_self]
intros
simpa [add_comm] using add_lt_add_right_coe h z
have : 1 + real.sqrt 5 ≠ 0
from ne_of_gt (add_pos (by norm_num) $ real.sqrt_pos.mpr (by norm_num))
field_simp [sub_mul, mul_add]
norm_num
intros
rw [infinite_neg_iff_infinite_and_neg]; exact ⟨λ hI, hI.1, λ hI, ⟨hI, hn⟩⟩
rw [infinite_neg_iff_infinite_and_neg]
exact ⟨λ hI, hI.1, λ hI, ⟨hI, hn⟩⟩
pi_upper_bound [140/99, 279/151, 51/26, 412/207]
intros
rw [sq, sqrt_mul_self_eq_abs]
intros
rw ←get_eq_of_mem _ h; apply results_of_terminates
rw ←get_eq_of_mem _ h
apply results_of_terminates
intros
simp only [terminates_iff, exists_congr h]
intros
finish [subset_def, mem_image_eq]
intros
{ ext, simp }
ext
simp
intros
{ intro s, use f ⁻¹' s, rw hf.image_preimage }
intro s
use f ⁻¹' s
rw hf.image_preimage
intros
split_ifs; simp [h]
{ split_ifs; simp [h] }
split_ifs
simp [h]
simp [h]
intros
{ ext, simp }
ext
simp
intros
rw [←not_forall, ←eq_univ_iff_forall]
intros
{ rw ← image_prod, exact (hs.prod ht).image _ }
rw ← image_prod
exact (hs.prod ht).image _
intros
simp [←finset.coe_inj]
intros
rw [restrict, image_comp, image_preimage_eq_inter_range, subtype.range_coe]
intros
ext1 x
simp_rw [mem_union, mem_Ioc, min_lt_iff, le_max_iff]
by_cases hc : c < x; by_cases hd : x ≤ d
by_cases hc : c < x
by_cases hd : x ≤ d
{ tauto }
tauto
have hax : a < x := h₂.trans_lt (lt_of_not_ge hd)
{ have hax : a < x := h₂.trans_lt (lt_of_not_ge hd), tauto }
tauto
by_cases hd : x ≤ d
have hxb : x ≤ b := (le_of_not_gt hc).trans h₁
{ have hxb : x ≤ b := (le_of_not_gt hc).trans h₁, tauto }
tauto
{ tauto }
tauto
intros
simp [← Ioi_inter_Iic]
intros
rw [mem_Ico, le_iff_lt_or_eq] at hmem
rcases hmem with ⟨hxa | hxa, hxb⟩
{ exact or.inr ⟨hxa, hxb⟩ }
exact or.inr ⟨hxa, hxb⟩
{ exact or.inl hxa.symm }
exact or.inl hxa.symm
intros
simp [sub_eq_add_neg]
intros
simp [sub_eq_add_neg, image_comp (λ x, a + x) (λ x, -x)]
intros
simpa only [mul_comm] using preimage_mul_const_Ico_of_neg a b h
intros
ext y
{ ext y, split; simp only [mem_Union]; rintro ⟨a, ha, x, hx, ax⟩; exact ⟨a, x, ha, hx, ax⟩ }
split
split; simp only [mem_Union]; rintro ⟨a, ha, x, hx, ax⟩; exact ⟨a, x, ha, hx, ax⟩
split; simp only [mem_Union]; rintro ⟨a, ha, x, hx, ax⟩
split; simp only [mem_Union]
simp only [mem_Union]
rintro ⟨a, ha, x, hx, ax⟩
exact ⟨a, x, ha, hx, ax⟩
simp only [mem_Union]
rintro ⟨a, ha, x, hx, ax⟩
exact ⟨a, x, ha, hx, ax⟩
intros
rintro x ⟨_, ⟨i, rfl⟩, xs, xt⟩
{ rintro x ⟨_, ⟨i, rfl⟩, xs, xt⟩, exact ⟨⟨_, ⟨i, rfl⟩, xs⟩, _, ⟨i, rfl⟩, xt⟩ }
exact ⟨⟨_, ⟨i, rfl⟩, xs⟩, _, ⟨i, rfl⟩, xt⟩
intros
rw ←eqv_gen_of_setoid (map_of_surjective r f h hf)
rw ←eqv_gen_of_setoid (map_of_surjective r f h hf); refl
refl
intros
convert card_image_diag (univ : finset α)
rw [fintype.card_of_subtype, ←filter_image_quotient_mk_is_diag]
rintro x
rw [mem_filter, univ_product_univ, mem_image]
obtain ⟨a, ha⟩ := quotient.exists_rep x
exact and_iff_right ⟨a, mem_univ _, ha⟩
intros
split; intro h
{ split; intro h, { rw quotient.eq at h, cases h; refl }, rw h }
split
intro h
rw quotient.eq at h
{ rw quotient.eq at h, cases h; refl }
cases h
cases h; refl
refl
refl
intro h
rw h
intros
convert zmod.int_coe_eq_int_coe_iff a b c
simp [nat.modeq_iff_dvd, int.modeq_iff_dvd]
intros
intros a₁ a₂ hfa
simp [ext_iff, ker, is_subgroup.trivial] at h
have ha : a₁ * a₂⁻¹ = 1
rw ←h
rw ←h
rw ←h; exact hf.inv_ker_one hfa
rw ←h; exact hf.inv_ker_one hfa
exact hf.inv_ker_one hfa
exact hf.inv_ker_one hfa
rw [eq_inv_of_mul_eq_one ha, inv_inv a₂]
intros
simp only [← units_coe, ← mul_apply, f.inv_mul, coe_one, id]
intros
conv_rhs { rw ← adjoin_simple.algebra_map_gen F α }
{ conv_rhs { rw ← adjoin_simple.algebra_map_gen F α }, rw is_integral_algebra_map_iff (algebra_map F⟮α⟯ E).injective, apply_instance }
rw is_integral_algebra_map_iff (algebra_map F⟮α⟯ E).injective
apply_instance
intros
{ have h := pow_card_sub_one_eq_one a ha, rwa zmod.card p at h }
have h := pow_card_sub_one_eq_one a ha
rwa zmod.card p at h
intros
simpa only [ring_hom.map_one, C_1, sub_eq_add_neg] using eq_X_sub_C B (1:A)
intros
induction x; simp only [int.cast_of_nat, int.cast_neg_succ_of_nat, nat_cast K p 0]; refl
induction x; simp only [int.cast_of_nat, int.cast_neg_succ_of_nat, nat_cast K p 0]
induction x
simp only [int.cast_of_nat, int.cast_neg_succ_of_nat, nat_cast K p 0]
simp only [int.cast_of_nat, int.cast_neg_succ_of_nat, nat_cast K p 0]
refl
intros
rw ← sq_eq_sq (norm_nonneg (x - y)) (add_nonneg (norm_nonneg x) (norm_nonneg y))
rw [norm_sub_pow_two_real, inner_eq_neg_mul_norm_of_angle_eq_pi h]
ring
intros
rw cospherical_iff_exists_mem_of_finite_dimensional h at hc
rcases hc with ⟨c, hc, r, hcr⟩
use c
intros sx hsxps
have hsx : affine_span ℝ (set.range sx.points) = s
refine sx.independent.affine_span_eq_of_le_of_card_eq_finrank_add_one (span_points_subset_coe_of_subset_coe (hsxps.trans h)) _
{ refine sx.independent.affine_span_eq_of_le_of_card_eq_finrank_add_one (span_points_subset_coe_of_subset_coe (hsxps.trans h)) _, simp [hd] }
simp [hd]
have hc : c ∈ affine_span ℝ (set.range sx.points) := hsx.symm ▸ hc
exact (sx.eq_circumcenter_of_dist_eq hc (λ i, hcr (sx.points i) (hsxps (set.mem_range_self i)))).symm
intros
rcases ho with ⟨t, hto, hts⟩
use t.circumradius
intros t₂ ht₂
have ht₂s := ht₂
rw hts at ht₂
rcases exists_dist_eq_circumradius_of_subset_insert_orthocenter hto ht₂ t₂.independent.injective with ⟨c, hc, h⟩
rw set.forall_range_iff at h
have hs : set.range t.points ⊆ s
rw hts
{ rw hts, exact set.subset_insert _ _ }
exact set.subset_insert _ _
rw [affine_span_of_orthocentric_system ⟨t, hto, hts⟩ hs t.independent.injective, ←affine_span_of_orthocentric_system ⟨t, hto, hts⟩ ht₂s t₂.independent.injective] at hc
exact (t₂.eq_circumradius_of_dist_eq hc h).symm
intros
refine structure_groupoid.le_iff.2 (λ e he, _)
rw mem_groupoid_of_pregroupoid at he ⊢
exact ⟨h _ _ he.1, h _ _ he.2⟩
intros
rw [unique_mdiff_within_at, ext_chart_preimage_inter_eq]
exact unique_diff_within_at.inter' hs (ext_chart_preimage_mem_nhds_within I x ht)
intros
simp only [tangent_map_within, h p.fst hp, true_and, eq_self_iff_true, heq_iff_eq, sigma.mk.inj_iff]
congr' 1
exact mfderiv_within_congr hs h (h _ hp)
intros
refine (I.to_local_equiv.image_eq_target_inter_inv_preimage _).trans _
{ rw I.source_eq, exact subset_univ _ }
rw I.source_eq
exact subset_univ _
rw [inter_comm, I.target_eq, I.to_local_equiv_coe_symm]
{ rw [inter_comm, I.target_eq, I.to_local_equiv_coe_symm] }
intros
simp only [times_cont_mdiff_within_at, lift_prop_within_at, times_cont_diff_within_at_prop, iff_def] with mfld_simps {contextual := tt}
exact times_cont_diff_within_at.continuous_within_at
intros
simp [← times_cont_mdiff_on_univ, times_cont_mdiff_on_iff, continuous_iff_continuous_on_univ]
intros
rw [rcons, dif_neg]
{ rw [rcons, dif_neg], refl, exact h1 ⟨i, m⟩ (ls.mem_cons_self _) }
refl
exact h1 ⟨i, m⟩ (ls.mem_cons_self _)
intros
rw [mul_comm, sec_spec]
intros
ext
rw lift_spec
show j _ = j _ * _
erw [←j.map_mul, sec_spec']
intros
rw [mul_assoc, swap_mul_self, mul_one]
intros
apply cycle_induction_on _ g
rw [extend_domain_one, cycle_type_one, cycle_type_one]
{ rw [extend_domain_one, cycle_type_one, cycle_type_one] }
intros σ hσ
{ intros σ hσ, rw [(hσ.extend_domain f).cycle_type, hσ.cycle_type, card_support_extend_domain] }
rw [(hσ.extend_domain f).cycle_type, hσ.cycle_type, card_support_extend_domain]
intros σ τ hd hc hσ hτ
{ intros σ τ hd hc hσ hτ, rw [hd.cycle_type, ← extend_domain_mul, (hd.extend_domain f).cycle_type, hσ, hτ] }
rw [hd.cycle_type, ← extend_domain_mul, (hd.extend_domain f).cycle_type, hσ, hτ]
intros
intros f g h
rw ←cycle_factors_finset_noncomm_prod f
simpa [h] using cycle_factors_finset_noncomm_prod g
intros
by_cases hx : f x = x
rw [pow_apply_eq_self_of_apply_eq_self hx, pow_apply_eq_self_of_apply_eq_self hx]
{ rw [pow_apply_eq_self_of_apply_eq_self hx, pow_apply_eq_self_of_apply_eq_self hx] }
rw [←cycle_of_pow_apply_self, ←cycle_of_pow_apply_self f, ←order_of_is_cycle (is_cycle_cycle_of f hx), ←pow_eq_mod_order_of]
{ rw [←cycle_of_pow_apply_self, ←cycle_of_pow_apply_self f, ←order_of_is_cycle (is_cycle_cycle_of f hx), ←pow_eq_mod_order_of] }
intros
simp [cycle_range]
intros
suffices : x ∈ {y | form_perm l y ≠ y}
rw ←mem_to_finset
{ rw ←mem_to_finset, exact support_form_perm_le' _ this }
exact support_form_perm_le' _ this
simpa using h
intros
refine ⟨λ h, _, λ h, by rw [mul_apply, h.2, h.1]⟩
cases hστ a with hσ hτ
{ exact ⟨hσ, σ.injective (h.trans hσ.symm)⟩ }
exact ⟨hσ, σ.injective (h.trans hσ.symm)⟩
{ exact ⟨(congr_arg σ hτ).symm.trans h, hτ⟩ }
exact ⟨(congr_arg σ hτ).symm.trans h, hτ⟩
intros
simp_rw [one_lt_card_iff, mem_support, ←not_or_distrib]
contrapose! h
ext a
specialize h (f a) a
rwa [apply_eq_iff_eq, or_self, or_self] at h
intros
ext
ext; simp
simp
simp
intros
split
intros h x y hxy
{ intros h x y hxy, rwa [←mul_inv_eq_one, ←map_inv, ←map_mul, ←mem_ker, h, mem_bot, mul_inv_eq_one] at hxy }
rwa [←mul_inv_eq_one, ←map_inv, ←map_mul, ←mem_ker, h, mem_bot, mul_inv_eq_one] at hxy
exact λ h, le_bot_iff.mp (λ x hx, h (hx.trans f.map_one.symm))
{ exact λ h, le_bot_iff.mp (λ x hx, h (hx.trans f.map_one.symm)) }
intros
simp only [infi, mem_Inf, set.forall_range_iff]
intros
simp [mem_center_iff]
intros
simp [line_map_apply]
intros
rw mem_direction_iff_eq_vsub_left hp
simp
intros
rw [weighted_vsub_of_point_apply, weighted_vsub_of_point_apply]
exact set.sum_indicator_subset_of_eq_zero w (λ i wi, wi • (p i -ᵥ b : V)) h (λ i, zero_smul k _)
intros
split
{ exact eq_affine_combination_of_mem_affine_span }
exact eq_affine_combination_of_mem_affine_span
rintros ⟨s, w, hw, rfl⟩
{ rintros ⟨s, w, hw, rfl⟩, exact affine_combination_mem_affine_span hw p }
exact affine_combination_mem_affine_span hw p
intros
rw [← span_singleton_le_iff_mem, le_supr_iff]
simp only [span_singleton_le_iff_mem]
intros
simpa only [range_eq_map] using submodule.map_zero _
intros
{ext, refl}
ext
refl
intros
rintros x ⟨m, hm, rfl⟩
exact add_mem_sup (mem_map_of_mem hm) (mem_map_of_mem hm)
intros
rw [coe_reindex, range_reindex']
intros
simp [basis.equiv_fun, finsupp.total_apply, finsupp.sum_fintype]
intros
{ erw mem_pair_self_adjoint_matrices_submodule, refl, }
erw mem_pair_self_adjoint_matrices_submodule
refl
intros
{ ext, refl }
ext
refl
intros
rw [B.to_matrix_comp_left b, to_matrix_to_lin, transpose_transpose]
intros
apply cardinal.sup_le.mpr
rintro ⟨s, li⟩
exact linear_independent_bounded_of_finset_linear_independent_bounded H _ li
intros
rw [←cardinal.lift_inj, ← (basis.singleton punit R).mk_eq_dim, cardinal.mk_punit]
intros
rw [← total_dual_basis b, basis.total_repr b.dual_basis l]
intros
refine eq_of_le_of_finrank_eq f.range_dual_map_le_dual_annihilator_ker _
have := submodule.finrank_quotient_add_finrank f.ker
rw (subspace.quot_equiv_annihilator f.ker).finrank_eq at this
refine add_left_injective (finrank K f.ker) _
simp_rw [this, finrank_range_dual_map_eq_finrank_range]
exact finrank_range_add_finrank_ker f
intros
erw [←alg_hom.map_mul, ring_quot.mk_alg_hom_rel R (rel.of m), alg_hom.map_zero _]
intros
rw [← finrank_top, ← subalgebra_top_finrank_eq_submodule_top_finrank] at h
exact eq.symm (subalgebra.eq_bot_of_finrank_one h)
intros
rw [range_eq_top, ker_eq_bot, injective_iff_surjective_of_finrank_eq_finrank H]
intros
rw [total_apply, sum_option_index_smul, total_apply]
intros
refine linear_map.mem_submodule_image.trans ⟨_, _⟩
rintro ⟨y, yO, yN, h⟩
{ rintro ⟨y, yO, yN, h⟩, exact ⟨y, yN, h⟩ }
exact ⟨y, yN, h⟩
rintro ⟨y, yN, h⟩
{ rintro ⟨y, yN, h⟩, exact ⟨y, hNO yN, yN, h⟩ }
exact ⟨y, hNO yN, yN, h⟩
intros
simp [of_le_apply]
intros
simpa using i.comp _ (range_splitting_injective v)
intros
rw [det_apply', det_apply']
refine fintype.sum_bijective _ inv_involutive.bijective _ _ _
intros σ
rw sign_inv
congr' 1
apply fintype.prod_equiv σ
intros
simp
intros
haveI : is_empty n := fintype.card_eq_zero_iff.mp h
exact det_is_empty
intros
simp [linear_map.to_matrix_alg_equiv']
intros
rcases t
{ rcases t, simp [to_matrix, transvection_mul_transvection_same, t_hij] }
simp [to_matrix, transvection_mul_transvection_same, t_hij]
intros
have : (0 : R) • (0 : M₁ i) = 0
simp
simp
rw [← update_eq_self i m, h, ← this, f.map_smul, zero_smul]
intros
split
rintros ⟨_, _⟩ ⟨⟨x, hx⟩, ⟨y, hy⟩⟩
{ rintros ⟨_, _⟩ ⟨⟨x, hx⟩, ⟨y, hy⟩⟩, simp only [prod.ext_iff, inl_apply, inr_apply, mem_bot] at hx hy ⊢, exact ⟨hy.1.symm, hx.2.symm⟩ }
simp only [prod.ext_iff, inl_apply, inr_apply, mem_bot] at hx hy ⊢
exact ⟨hy.1.symm, hx.2.symm⟩
rintros ⟨x, y⟩ -
{ rintros ⟨x, y⟩ -, simp only [mem_sup, mem_range, exists_prop], refine ⟨(x, 0), ⟨x, rfl⟩, (0, y), ⟨y, rfl⟩, _⟩, simp }
simp only [mem_sup, mem_range, exists_prop]
refine ⟨(x, 0), ⟨x, rfl⟩, (0, y), ⟨y, rfl⟩, _⟩
simp
intros
rw [smodeq.def] at h ⊢
show ideal.quotient.mk I (f.eval x) = ideal.quotient.mk I (f.eval y)
change ideal.quotient.mk I x = ideal.quotient.mk I y at h
rw [← polynomial.eval₂_at_apply, ← polynomial.eval₂_at_apply, h]
intros
simp [xor, and_comm, or_comm]
intros
simp [and_comm]
intros
rw [← not_nontrivial_iff_subsingleton, or_comm]
{ rw [← not_nontrivial_iff_subsingleton, or_comm], exact classical.em _ }
exact classical.em _
intros
have : ν = ν.restrict set.univ := measure.restrict_univ.symm
have : ν = ν.restrict set.univ := measure.restrict_univ.symm
rwa [this, measure.prod_restrict, ← this]
intros
{ rw [real_smul_def, ← smul_pos_part, dif_pos hr] }
rw [real_smul_def, ← smul_pos_part, dif_pos hr]
intros
rwa [← f.mk_coe_fn, ← g.mk_coe_fn, mk_eq_mk]
intros
let hf_mem_ℒp := mem_ℒp_of_mem_ℒp_trim hm (Lp.mem_ℒp f)
rw mem_Lp_meas_subgroup_iff_ae_measurable'
refine ae_measurable'.congr _ (mem_ℒp.coe_fn_to_Lp hf_mem_ℒp).symm
refine ae_measurable'_of_ae_measurable'_trim hm _
exact (Lp.ae_measurable f)
intros
have : ae_measurable (λ (x : α), c) μ := measurable_const.ae_measurable
rw [integrable, and_iff_right this, has_finite_integral_const_iff]
intros
{ rw ← mem_ℒp_one_iff_integrable, exact Lp.mem_ℒp f }
rw ← mem_ℒp_one_iff_integrable
exact Lp.mem_ℒp f
intros
simp only [mem_ℒp, hf, true_and]
apply lt_of_le_of_lt (snorm_le_mul_snorm_of_ae_le_mul hfg p)
simp [lt_top_iff_ne_top, hg.snorm_ne_top]
intros
simp [snorm']
intros
rw [lintegral_coe_eq_integral f hfi, ennreal.of_real, ennreal.coe_le_coe, real.to_nnreal_le_iff_le_coe]
intros
{ ext1, simp [weighted_smul], }
ext1
simp [weighted_smul]
intros
simp only [← L1.integral_eq_integral]
{ simp only [← L1.integral_eq_integral], exact L1.continuous_integral }
exact L1.continuous_integral
intros
simpa only [← integral_symm] using (integral_has_strict_deriv_at_of_tendsto_ae_right hf.symm hmeas ha).neg
intros
by_cases hc : c = 0; simp [hc]
by_cases hc : c = 0
simp [hc]
simp [hc]
intros
rw lintegral_congr_ae
{ rw lintegral_congr_ae, rw eventually_eq, rwa ae_restrict_iff' hs, }
rw eventually_eq
rwa ae_restrict_iff' hs
intros
conv_lhs { rw [← sum_smul_dirac μ, lintegral_sum_measure] }
congr' 1 with a : 1
rw [lintegral_smul_measure, lintegral_dirac, mul_comm]
intros
rw ← funext L.integral_comp_Lp
{ rw ← funext L.integral_comp_Lp, exact continuous_integral.comp (L.comp_LpL 1 μ).continuous, }
exact continuous_integral.comp (L.comp_LpL 1 μ).continuous
intros
rw [set_to_L1_eq_set_to_L1' hT h_smul, set_to_L1_eq_set_to_L1' hT h_smul]
exact continuous_linear_map.map_smul _ _ _
intros
intros u hu
convert (hs.subtype_image (hc hu)).union (ht.subtype_image (hd hu))
change f ⁻¹' u = coe '' (coe ⁻¹' (f ⁻¹' u) : set s) ∪ coe '' (coe ⁻¹' (f ⁻¹' u) : set t)
rw [image_preimage_eq_inter_range, image_preimage_eq_inter_range, subtype.range_coe, subtype.range_coe, ← inter_distrib_left, univ_subset_iff.1 h, inter_univ]
intros
simpa only [ennreal.coe_eq_coe, ←nnreal.coe_eq, haar_content_apply] using is_left_invariant_chaar g K
intros
ext1 s hs
rw [map_apply hf.continuous.measurable hs, restrict_apply hs, hf.hausdorff_measure_preimage hd]
intros
simpa only [prod_univ, region_between, set.preimage, set_of_subset_set_of] using λ a, and.left
intros
ext1 s hs
have : ∀ y ∈ s, measurable_set (f ⁻¹' {y})
from λ y _, hf (measurable_set_singleton _)
simp [← tsum_measure_preimage_singleton (countable_encodable s) this, *, tsum_subtype s (λ b, μ (f ⁻¹' {b})), ← indicator_mul_right s (λ b, μ (f ⁻¹' {b}))]
intros
refine ⟨λ h, h.mono (λ x hx, _), λ h, h.mono (λ x hx, _)⟩
{ rwa [pi.sub_apply, pi.zero_apply, sub_eq_zero] at hx, }
rwa [pi.sub_apply, pi.zero_apply, sub_eq_zero] at hx
{ rwa [pi.sub_apply, pi.zero_apply, sub_eq_zero], }
rwa [pi.sub_apply, pi.zero_apply, sub_eq_zero]
intros
refine ⟨measure_inter_eq_zero_of_restrict, λ h, _⟩
rcases exists_measurable_superset_of_null h with ⟨t', htt', ht', ht'0⟩
apply measure_mono_null ((inter_subset _ _ _).1 htt')
rw [restrict_apply (hs.compl.union ht'), union_inter_distrib_right, compl_inter_self, set.empty_union]
exact measure_mono_null (inter_subset_left _ _) ht'0
intros
simpa only [← measure_eq_trim] using outer_measure.exists_measurable_superset_forall_eq_trim (λ i, (μ i).to_outer_measure) s
intros
simp [infi_subtype, infi_and, trim_eq_infi]
intros
refine le_antisymm (le_binfi $ λ s hs, le_infi $ λ h2s, μ.mono hs) _
refine le_of_forall_lt' (λ r hr, _)
simpa only [infi_lt_iff, exists_prop] using A.exists_is_open_lt_of_lt r hr
intros
obtain ⟨u, hmu, hu₁, hu₂⟩ := h
refine ⟨u, hmu, λ s hs, _, hu₂⟩
rw [neg_apply v s, neg_eq_zero]
exact hu₁ s hs
intros
{ ext i hi, simp }
ext i hi
simp
intros
have hi₁ : measurable_set i := measurable_of_not_restrict_le_zero _ hi
rw [restrict_le_restrict_iff _ _ hi₁] at hi
push_neg at hi
obtain ⟨j, hj₁, hj₂, hj⟩ := hi
exact ⟨j, hj₁, hj₂, hj⟩
intros
ext1 b
simp only [ennreal.coe_eq_coe.symm, coe_bind_apply, ennreal.tsum_mul_left.symm, ennreal.tsum_mul_right.symm]
rw [ennreal.tsum_comm]
simp [mul_assoc, mul_left_comm, mul_comm]
intros
let e := fintype.equiv_fin ι
obtain ⟨i₀, i₁, ne, h⟩ := h.exists_approx_aux (fintype.card ι) hε hb (λ x y, A x (e.symm y))
refine ⟨i₀, i₁, ne, λ k, _⟩
convert h (e k); simp only [e.symm_apply_apply]
convert h (e k)
simp only [e.symm_apply_apply]
simp only [e.symm_apply_apply]
simp only [e.symm_apply_apply]
simp only [e.symm_apply_apply]
intros
ext
simp only [exists_prop, mem_divisors_antidiagonal, finset.mem_map, function.embedding.coe_fn_mk, ne.def, prod.swap_prod_mk, prod.exists]
split
rintros ⟨x, y, ⟨⟨rfl, h⟩, rfl⟩⟩
{ rintros ⟨x, y, ⟨⟨rfl, h⟩, rfl⟩⟩, simp [mul_comm, h], }
simp [mul_comm, h]
rintros ⟨rfl, h⟩
{ rintros ⟨rfl, h⟩, use [a.snd, a.fst], rw mul_comm, simp [h] }
use [a.snd, a.fst]
rw mul_comm
simp [h]
intros
{ ext; simp, }
ext
ext; simp
simp
simp
intros
simp [norm_def]
intros
simp [padic_val_nat_def (fact.out p.prime).ne_zero]
intros
change fin 4 at z
fin_cases z; norm_num [fin.ext_iff, fin.coe_bit0, fin.coe_bit1]
fin_cases z
norm_num [fin.ext_iff, fin.coe_bit0, fin.coe_bit1]
norm_num [fin.ext_iff, fin.coe_bit0, fin.coe_bit1]
norm_num [fin.ext_iff, fin.coe_bit0, fin.coe_bit1]
norm_num [fin.ext_iff, fin.coe_bit0, fin.coe_bit1]
intros
cases n; simp *
cases n
simp *
simp *
intros
refine sdiff_le.lt_of_ne (λ h, hy _)
rw [sdiff_eq_self_iff_disjoint', disjoint_iff] at h
rw [←h, inf_eq_right.mpr hx]
intros
rw [closure_sup_closure_left, closure_sup_closure_right]
intros
simpa only [inf_comm] using supr_inf_eq f a
intros
obtain ⟨c, hct⟩ : ∃ c, c ∈ t := ht
obtain ⟨B, hB⟩ : ∃ B, B ∈ upper_bounds t := h_bdd
refine hs.out c.2 B.2 ⟨_, _⟩
{ exact (subtype.mono_coe s).le_cSup_image hct ⟨B, hB⟩ }
exact (subtype.mono_coe s).le_cSup_image hct ⟨B, hB⟩
{ exact (subtype.mono_coe s).cSup_image_le ⟨c, hct⟩ hB }
exact (subtype.mono_coe s).cSup_image_le ⟨c, hct⟩ hB
intros
rw [supr, gc.l_cSup (range_nonempty _) hf, supr_range']
intros
rw [at_bot_Iic_eq, tendsto_comap_iff]
intros
refine tendsto_at_top_mono' _ ((eventually_ge_at_top 1).mono $ λ x hx, _) tendsto_id
simpa only [pow_one] using pow_le_pow hx hn
intros
simp [filter.frequently]
intros
split
split ; intro h
intro h
rcases h with ⟨t, t_in, ht⟩
{ rcases h with ⟨t, t_in, ht⟩, apply mem_of_superset t_in, rintro y y_in _ rfl, apply ht y_in }
apply mem_of_superset t_in
rintro y y_in _ rfl
apply ht y_in
intro h
{ exact ⟨_, h, λ _ x_in, x_in _ rfl⟩ }
exact ⟨_, h, λ _ x_in, x_in _ rfl⟩
intros
rw tendsto_iff_comap at hfg ⊢
calc a ≤ comap (g ∘ f) c : hfg ... ≤ comap f b : by simpa [comap_comap] using comap_mono hg
intros
simp only [ne_bot_iff, ne, prod_eq_bot, not_or_distrib]
intros
simp only [imp_iff_not_or, eventually_or_distrib_left]
intros
simp [tendsto_def, function.graph, rtendsto'_def, rel.preimage_def, set.preimage]
{ simp [tendsto_def, function.graph, rtendsto'_def, rel.preimage_def, set.preimage] }
intros
apply lt_of_le_of_ne le_sup_left
intro h
simp at h
exact hx h
intros
apply le_antisymm; simp
apply le_antisymm
simp
simp
intros
rw [disjoint, ← h.eq_bot, sup_comm]
apply le_inf inf_le_left
apply (inf_le_inf_right (c ⊔ b) le_sup_right).trans
rw [sup_comm, is_modular_lattice.sup_inf_sup_assoc, hsup.eq_bot, bot_sup_eq]
intros
simp_rw [←supr_partial_sups_eq f, ←supr_partial_sups_eq g, h]
intros
rw [← e.map_rel_iff, e.apply_symm_apply]
intros
rw [is_wf]
convert h.well_founded_on
ext x y
rw lt_iff_le_and_ne
intros
{ rw add_comm, exact h.add_mul_right_left z }
rw add_comm
exact h.add_mul_right_left z
intros
suffices : span R (of R M '' f.support) ≤ (adjoin R (of R M '' f.support)).to_submodule
{ exact this (mem_span_support f) }
exact this (mem_span_support f)
rw submodule.span_le
exact subset_adjoin
intros
ext g
by_cases hg : g ∈ set.range f
obtain ⟨a, rfl⟩ := hg
{ obtain ⟨a, rfl⟩ := hg, simp }
simp
{ simp [emb_domain_notin_range, hg] }
simp [emb_domain_notin_range, hg]
intros
simp
intros
refine or_iff_not_imp_left.1 (map_eq_top_or_is_maximal_of_surjective f hf.right H) (λ h, H.1.1 _)
refine or_iff_not_imp_left.1 (map_eq_top_or_is_maximal_of_surjective f hf.right H) (λ h, H.1.1 _); calc I = comap f (map f I) : ((rel_iso_of_bijective f hf).right_inv I).symm ... = comap f ⊤ : by rw h ... = ⊤ : by rw comap_top
calc I = comap f (map f I) : ((rel_iso_of_bijective f hf).right_inv I).symm ... = comap f ⊤ : by rw h ... = ⊤ : by rw comap_top
intros
ext
rw mem_map_iff_of_surjective (ring_hom.snd R S) prod.snd_surjective
exact ⟨by { rintro ⟨x, ⟨h, rfl⟩⟩, exact h.2 }, λ h, ⟨⟨0, x⟩, ⟨⟨ideal.zero_mem _, h⟩, rfl⟩⟩⟩
intros
simp [integer_normalization, coeff_monomial, coeff_integer_normalization_of_not_mem_support] {contextual := tt}
intros
simp_rw [algebra.smul_def, mul_comm _ a]
{ simp_rw [algebra.smul_def, mul_comm _ a], apply exists_integer_multiple' }
apply exists_integer_multiple'
intros
simp [inv_fun, add_tmul, finset.sum_add_distrib]
intros
apply dvd_antisymm_of_normalize_eq normalize_content finset.normalize_gcd
rw finset.dvd_gcd_iff
{ rw finset.dvd_gcd_iff, intros i hi, apply content_dvd_coeff _ }
intros i hi
apply content_dvd_coeff _
apply finset.gcd_mono
{ apply finset.gcd_mono, intro i, simp only [nat.lt_succ_iff, mem_support_iff, ne.def, finset.mem_range], contrapose!, intro h1, apply coeff_eq_zero_of_nat_degree_lt (lt_of_lt_of_le h h1), }
intro i
simp only [nat.lt_succ_iff, mem_support_iff, ne.def, finset.mem_range]
contrapose!
intro h1
apply coeff_eq_zero_of_nat_degree_lt (lt_of_lt_of_le h h1)
intros
simp only [cyclotomic, h, dif_neg, not_false_iff]
ext i
simp only [coeff_map, int.cast_id, ring_hom.eq_int_cast]
intros
rw [pochhammer_succ_right, polynomial.eval_mul, polynomial.eval_add, polynomial.eval_X, polynomial.eval_nat_cast]
intros
ext x
obtain ⟨f, rfl⟩ := pb.exists_eq_aeval' x
rw [← polynomial.aeval_alg_hom_apply, ← polynomial.aeval_alg_hom_apply, h]
intros
simp
intros
simpa using order_monomial_of_ne_zero 0 (1:R) one_ne_zero
intros
ext
{ ext, simp [sin, apply_ite f] }
simp [sin, apply_ite f]
intros
rw [bilin_form.to_matrix_apply, trace_form_apply]
intros
{ dunfold count, split_ifs, refl }
dunfold count
split_ifs
refl
intros
ext
ext; apply commutes_symm'
apply commutes_symm'
intros
unfreezingI { obtain ⟨φ, hf⟩ := hf, obtain ⟨ψ, hg⟩ := hg }
obtain ⟨φ, hf⟩ := hf
obtain ⟨ψ, hg⟩ := hg
use (λ n, bind₁ φ (ψ n))
intros
simp only [peval, aeval_bind₁, function.comp, hg, hf]
intros
simp only [ghost_component_apply, aeval_witt_polynomial]
rw [finset.sum_range_succ', verschiebung_fun_coeff, if_pos rfl, zero_pow (pow_pos hp.1.pos _), mul_zero, add_zero, finset.mul_sum, finset.sum_congr rfl]
rintro i -
simp only [pow_succ, mul_assoc, verschiebung_fun_coeff, if_neg (nat.succ_ne_zero i), nat.succ_sub_succ, nat.sub_zero]
norm_cast
intros
intro hf
apply not_injective_of_ordinal (equiv_shrink α ∘ f)
exact (equiv_shrink _).injective.comp hf
intros
simpa only [add_zero] using add_sub_cancel a 0
intros
simpa only [mul_one] using mul_div_cancel 1 h
intros
{ cases y, rw mk_lt_mk, tauto }
cases y
rw mk_lt_mk
tauto
intros
{ cases x, cases y, refl, }
cases x
cases y
refl
intros
simp [h]
intros
rw ← h
rw ← h; simp
simp
intros
simp only [update, if_pos rfl]
intros
simp [h.symm, horner, pow_add, mul_assoc]
intros
cc
intros
unfold_wf; assumption
unfold_wf
assumption
intros
rw [is_open_iff_of_mem, ← preimage_compl, compl_compl, preimage_image_eq _ coe_injective]
exact infty_not_mem_image_coe
intros
convert (tendsto_nhds_within_of_tendsto_nhds tendsto_id).sub (tendsto_floor_right' n)
convert (tendsto_nhds_within_of_tendsto_nhds tendsto_id).sub (tendsto_floor_right' n); [exact (sub_self _).symm, apply_instance, apply_instance]
exact (sub_self _).symm
apply_instance
apply_instance
intros
let W : G → set G := λ x, (λ y, x * y) ⁻¹' U
have h1W : ∀ x, is_open (W x) := λ x, hU.preimage (continuous_mul_left x)
have h2W : ∀ x ∈ K, (1 : G) ∈ W x := λ x hx, by simp only [mem_preimage, mul_one, hKU hx]
choose V hV using λ x : K, exists_open_nhds_one_mul_subset ((h1W x).mem_nhds (h2W x.1 x.2))
let X : K → set G := λ x, (λ y, (x : G)⁻¹ * y) ⁻¹' (V x)
obtain ⟨t, ht⟩ : ∃ t : finset ↥K, K ⊆ ⋃ i ∈ t, X i
refine hK.elim_finite_subcover X (λ x, (hV x).1.preimage (continuous_mul_left x⁻¹)) _
{ refine hK.elim_finite_subcover X (λ x, (hV x).1.preimage (continuous_mul_left x⁻¹)) _, intros x hx, rw [mem_Union], use ⟨x, hx⟩, rw [mem_preimage], convert (hV _).2.1, simp only [mul_left_inv, subtype.coe_mk] }
intros x hx
rw [mem_Union]
use ⟨x, hx⟩
rw [mem_preimage]
convert (hV _).2.1
simp only [mul_left_inv, subtype.coe_mk]
refine ⟨⋂ x ∈ t, V x, is_open_bInter (finite_mem_finset _) (λ x hx, (hV x).1), _, _⟩
{ simp only [mem_Inter], intros x hx, exact (hV x).2.1 }
simp only [mem_Inter]
intros x hx
exact (hV x).2.1
rintro _ ⟨x, y, hx, hy, rfl⟩
simp only [mem_Inter] at hy
have := ht hx
simp only [mem_Union, mem_preimage] at this
rcases this with ⟨z, h1z, h2z⟩
have : (z : G)⁻¹ * x * y ∈ W z := (hV z).2.2 (mul_mem_mul h2z (hy z h1z))
rw [mem_preimage] at this
convert this using 1
simp only [mul_assoc, mul_inv_cancel_left]
intros
{ rw ← tsum_zero, exact tsum_lt_tsum hg hi summable_zero hsum }
rw ← tsum_zero
exact tsum_lt_tsum hg hi summable_zero hsum
intros
simp only [continuous_iff_continuous_at, continuous_at_const_smul_iff]
intros
simp only [le_antisymm_iff, nhds_eq_order, le_inf_iff, le_infi_iff, le_principal_iff, mem_Ioi, mem_Iio, abs_sub_lt_iff, @sub_lt_iff_lt_add _ _ _ _ _ _ a, @sub_lt _ _ _ _ a, set_of_and]
refine ⟨_, _, _⟩
intros ε ε0
{ intros ε ε0, exact inter_mem_inf (mem_infi_of_mem (a - ε) $ mem_infi_of_mem (sub_lt_self a ε0) (mem_principal_self _)) (mem_infi_of_mem (ε + a) $ mem_infi_of_mem (by simpa) (mem_principal_self _)) }
exact inter_mem_inf (mem_infi_of_mem (a - ε) $ mem_infi_of_mem (sub_lt_self a ε0) (mem_principal_self _)) (mem_infi_of_mem (ε + a) $ mem_infi_of_mem (by simpa) (mem_principal_self _))
intros b hb
{ intros b hb, exact mem_infi_of_mem (a - b) (mem_infi_of_mem (sub_pos.2 hb) (by simp [Ioi])) }
exact mem_infi_of_mem (a - b) (mem_infi_of_mem (sub_pos.2 hb) (by simp [Ioi]))
intros b hb
{ intros b hb, exact mem_infi_of_mem (b - a) (mem_infi_of_mem (sub_pos.2 hb) (by simp [Iio])) }
exact mem_infi_of_mem (b - a) (mem_infi_of_mem (sub_pos.2 hb) (by simp [Iio]))
intros
haveI := ha.nhds_within_ne_bot hs
exact ⟨ha.mem_upper_bounds_of_tendsto hf hb, λ b' hb', le_of_tendsto hb (mem_of_superset self_mem_nhds_within $ λ x hx, hb' $ mem_image_of_mem _ hx)⟩
intros
rw [← comap_coe_Ioi_nhds_within_Ioi, tendsto_comap_iff]
intros
rw continuous_on_iff_continuous_restrict at hf hg
obtain ⟨b, h⟩ := @intermediate_value_univ₂_eventually₁ _ _ _ _ _ _ (subtype.preconnected_space hs) ⟨a, ha⟩ _ (comap_coe_ne_bot_of_le_principal hl) _ _ hf hg ha' (eventually_comap' he)
exact ⟨b, b.prop, h⟩
intros
simp only [continuous_within_at, nhds_within_Icc_eq_nhds_within_Ici h]
intros
rw [← is_open_compl_iff] at *
{ rw [← is_open_compl_iff] at *, rw compl_inter, exact is_open.union h₁ h₂ }
rw compl_inter
exact is_open.union h₁ h₂
intros
simp [nhds_def]
intros
{ convert continuous_curry' ⟨_, h⟩, ext, refl }
convert continuous_curry' ⟨_, h⟩
ext
refl
intros
rw totally_disconnected_space_iff_connected_component_subsingleton
apply forall_congr (λ x, _)
rw set.subsingleton_iff_singleton
exact mem_connected_component
intros
letI := topological_space.coinduced (λ x : t, π x) subtype.topological_space
rcases mem_nhds_iff.mp hs with ⟨V, hVs, V_op, mem_V⟩
refine mem_nhds_within_iff_exists_mem_nhds_inter.mpr ⟨π ⁻¹' V, mem_nhds_iff.mpr ⟨t ∩ π ⁻¹' V, inter_subset_right t (π ⁻¹' V), _, mem_sep h mem_V⟩, subset.trans (inter_subset_left _ _) (preimage_mono hVs)⟩
obtain ⟨u, hu1, hu2⟩ := is_open_induced_iff.mp (is_open_coinduced.1 V_op)
rw [preimage_comp] at hu2
rw [set.inter_comm, ←(subtype.preimage_coe_eq_preimage_coe_iff.mp hu2)]
exact hu1.inter ht
intros
simp only [dense_iff_closure_eq, closure_pi_set, pi_congr rfl (λ i hi, (hs i hi).closure_eq), pi_univ]
intros
rw [continuous_within_at, hx, tendsto_congr' h, continuous_within_at]
intros
ext
{ ext, exact quotient.sound' (B.refl _) }
exact quotient.sound' (B.refl _)
intros
rcases le_or_lt b a with h|h
{ simp [h] }
simp [h]
rw [real.ediam_eq (bounded_Ioo _ _), cSup_Ioo h, cInf_Ioo h]
{ rw [real.ediam_eq (bounded_Ioo _ _), cSup_Ioo h, cInf_Ioo h] }
intros
rw ennreal.Ico_eq_Iio
{ rw ennreal.Ico_eq_Iio, exact is_open_Iio}
exact is_open_Iio
intros
simp only [nhds_bot', mem_Iio, tendsto_infi, tendsto_principal]
intros
rw [nhds_cons, tendsto, map_prod]; exact le_refl _
rw [nhds_cons, tendsto, map_prod]
exact le_refl _
intros
simp_rw [continuous_within_at, ← @tendsto_map'_iff _ _ _ _ e, e.map_nhds_within_preimage_eq (e.map_target h), (∘), e.right_inv h]
intros
rw sUnion_eq_bUnion at hU; exact dense_bUnion_interior_of_closed hc hS hU
rw sUnion_eq_bUnion at hU
exact dense_bUnion_interior_of_closed hc hS hU
intros
simpa using h.holder_on_with.dimH_image_le zero_lt_one
intros
refine le_antisymm _ _
calc _ ≤ Hausdorff_edist (closure s) s + Hausdorff_edist s t : Hausdorff_edist_triangle ... = Hausdorff_edist s t : by simp [Hausdorff_edist_comm]
{ calc _ ≤ Hausdorff_edist (closure s) s + Hausdorff_edist s t : Hausdorff_edist_triangle ... = Hausdorff_edist s t : by simp [Hausdorff_edist_comm] }
calc _ ≤ Hausdorff_edist s (closure s) + Hausdorff_edist (closure s) t : Hausdorff_edist_triangle ... = Hausdorff_edist (closure s) t : by simp
{ calc _ ≤ Hausdorff_edist s (closure s) + Hausdorff_edist (closure s) t : Hausdorff_edist_triangle ... = Hausdorff_edist (closure s) t : by simp }
intros
simp [Hausdorff_dist]
intros
apply emetric.diam_le
rintros _ ⟨x, hx, rfl⟩ _ ⟨y, hy, rfl⟩
calc edist (f x) (f y) ≤ ↑K * edist x y : hf.edist_le_mul x y ... ≤ ↑K * emetric.diam s : ennreal.mul_left_mono (emetric.edist_le_diam_of_mem hx hy)
intros
ext
{ ext, simp only [supr, opens.Sup_s, sUnion_image, bUnion_range], refl }
simp only [supr, opens.Sup_s, sUnion_image, bUnion_range]
refl
intros
simp only [mem_closure_iff_frequently, nhds_induced, frequently_comap, mem_image, and_comm]
intros
{ ext t, refl }
ext t
refl
intros
constructor
intro x
apply (h x).to_has_basis
intros i pi
{ intros i pi, exact ⟨s x i, ⟨(h x).mem_of_mem pi, h' x i pi⟩, by refl⟩ }
exact ⟨s x i, ⟨(h x).mem_of_mem pi, h' x i pi⟩, by refl⟩
rintros U ⟨U_in, hU⟩
{ rintros U ⟨U_in, hU⟩, rcases (h x).mem_iff.mp U_in with ⟨i, pi, hi⟩, tauto }
rcases (h x).mem_iff.mp U_in with ⟨i, pi, hi⟩
tauto
intros
ext u ; dsimp [uniform_space.comap] ; rw [prod.id_prod, filter.comap_id]
ext u ; dsimp [uniform_space.comap]
ext u
dsimp [uniform_space.comap]
rw [prod.id_prod, filter.comap_id]
intros
unfold unfolds
rw [corec_eq]
intros
cases a; cases b; congr; exact funext h
cases a; cases b; congr
cases a; cases b
cases a
cases b
congr
exact funext h
intros
cases b; simp
cases b
simp
simp
intros
have h := int.add_lt_add_right h (-b)
rwa int.add_right_neg at h
intros
rw int.add_comm
exact int.sub_left_lt_of_lt_add h
intros
induction l; intros
{induction l; intros, refl, contradiction}
induction l
refl
contradiction
intros
revert m n; induction k with k IH; intros m n; apply bit_cases_on m; intros a m'; apply bit_cases_on n; intros b n'; rw bitwise_bit h
revert m n; induction k with k IH; intros m n; apply bit_cases_on m; intros a m'; apply bit_cases_on n; intros b n'
revert m n; induction k with k IH; intros m n; apply bit_cases_on m; intros a m'; apply bit_cases_on n
revert m n; induction k with k IH; intros m n; apply bit_cases_on m; intros a m'
revert m n; induction k with k IH; intros m n; apply bit_cases_on m
revert m n; induction k with k IH; intros m n
revert m n; induction k with k IH
revert m n
induction k with k IH
intros m n
apply bit_cases_on m
intros a m'
apply bit_cases_on n
intros b n'
rw bitwise_bit h
{ simp [test_bit_zero] }
simp [test_bit_zero]
intros m n
apply bit_cases_on m
intros a m'
apply bit_cases_on n
intros b n'
rw bitwise_bit h
{ simp [test_bit_succ, IH] }
simp [test_bit_succ, IH]
intros
rw [div_eq_sub_div H (nat.le_add_left _ _), nat.add_sub_cancel]
intros
by_cases hba : b ≤ a
simp [le_antisymm hba h₁]
{ simp [le_antisymm hba h₁] }
by_cases hc0 : c ≤ 0
simp [le_antisymm hc0 c.zero_le, nat.mul_zero]
{ simp [le_antisymm hc0 c.zero_le, nat.mul_zero] }
exact (le_not_le_of_lt (nat.mul_lt_mul_of_pos_right (lt_of_le_not_le h₁ hba) (lt_of_le_not_le c.zero_le hc0))).left
intros
rw [nat.mul_comm, nat.mul_sub_right_distrib, nat.mul_comm m n, nat.mul_comm n k]
intros
tactic.mk_inj_eq
intros
rw [vadd_eq_vadd_iff_neg_add_eq_vsub, neg_add_eq_sub]
intros
simp [bit1, bit0, add_smul, smul_add]
intros
subst hT; exact set.Union_lift_of_mem x hx
subst hT
exact set.Union_lift_of_mem x hx
intros
haveI := classical.dec_eq α; let s' := ({a, b} : finset α)
haveI := classical.dec_eq α
let s' := ({a, b} : finset α)
have hu : s' ⊆ s
refine insert_subset.mpr _
{ refine insert_subset.mpr _, apply and.intro ha, apply singleton_subset_iff.mpr hb }
apply and.intro ha
apply singleton_subset_iff.mpr hb
have hf : ∀ c ∈ s, c ∉ s' → f c = 1
intros c hc hcs
{ intros c hc hcs, apply h₀ c hc, apply not_or_distrib.mp, intro hab, apply hcs, apply mem_insert.mpr, rw mem_singleton, exact hab }
apply h₀ c hc
apply not_or_distrib.mp
intro hab
apply hcs
apply mem_insert.mpr
rw mem_singleton
exact hab
rw ←prod_subset hu hf
exact finset.prod_pair hn
intros
simp
intros
rw abelian.exact_iff' f g (kernel_is_limit _) (cokernel_is_colimit _)
exact ⟨λ h, le_antisymm (range_le_ker_iff.2 h.1) (ker_le_range_iff.2 h.2), λ h, ⟨range_le_ker_iff.1 $ le_of_eq h, ker_le_range_iff.1 $ le_of_eq h.symm⟩⟩
intros
rcases (exists_rat_eq_nth_numerator v n) with ⟨Aₙ, nth_num_eq⟩
rcases (exists_rat_eq_nth_denominator v n) with ⟨Bₙ, nth_denom_eq⟩
use (Aₙ / Bₙ)
simp [nth_num_eq, nth_denom_eq, convergent_eq_num_div_denom]
intros
cases s_succ_nth_eq : s.nth (n + 1)
rw (squash_seq_eq_self_of_terminated s_succ_nth_eq)
case option.none { rw (squash_seq_eq_self_of_terminated s_succ_nth_eq) }
case option.some { obtain ⟨gp_n, s_nth_eq⟩ : ∃ gp_n, s.nth n = some gp_n, from s.ge_stable n.le_succ s_succ_nth_eq, obtain ⟨gp_m, s_mth_eq⟩ : ∃ gp_m, s.nth m = some gp_m, from s.ge_stable (le_of_lt m_lt_n) s_nth_eq, simp [*, squash_seq, (seq.zip_with_nth_some (seq.nats_nth m) s_mth_eq _), (ne_of_lt m_lt_n)] }
obtain ⟨gp_n, s_nth_eq⟩ : ∃ gp_n, s.nth n = some gp_n
from s.ge_stable n.le_succ s_succ_nth_eq
obtain ⟨gp_m, s_mth_eq⟩ : ∃ gp_m, s.nth m = some gp_m
from s.ge_stable (le_of_lt m_lt_n) s_nth_eq
simp [*, squash_seq, (seq.zip_with_nth_some (seq.nats_nth m) s_mth_eq _), (ne_of_lt m_lt_n)]
intros
simp [partial_denominators, s_nth_eq]
intros
{ unfold gcd_a, rw [xgcd, xgcd_zero_left] }
unfold gcd_a
rw [xgcd, xgcd_zero_left]
intros
simp only [sub_eq_add_neg]
rw [neg_eq_neg_one_mul, ← mul_div_assoc, div_add_div _ _ hb hd, ← mul_assoc, mul_comm b, mul_assoc, ← neg_eq_neg_one_mul]
intros
{ subst hs, exact finset.fold_congr hfg }
subst hs
exact finset.fold_congr hfg
intros
simp [h.symm]
intros
simp [← h]
intros
rw [eq_sub_iff_add_eq, add_comm]
intros
rintros ⟨⟩ ⟨⟩ h
congr'
congr'; injection h
injection h
injection h
injection h
intros
cases ha with a ha; rw [←ha, units.mul_right_inj]
cases ha with a ha
rw [←ha, units.mul_right_inj]
intros
rw [div_eq_mul_inv, zero_mul]
intros
refine ⟨by simp, _⟩
apply @is_iso.epi_of_iso _ _ _ _ _ _
exact ⟨⟨factor_thru_image_subobject _, by { ext, simp, }, by { ext, simp, }⟩⟩
intros
change ite (1 = 0 + 1) (d₀ ≫ 𝟙 X₁) 0 = d₀
{ change ite (1 = 0 + 1) (d₀ ≫ 𝟙 X₁) 0 = d₀, rw [if_pos rfl, category.comp_id] }
rw [if_pos rfl, category.comp_id]
intros
funext
simp only [mul_indicator]
split_ifs; simp [*]
split_ifs
simp [*]
simp [*]
intros
rw is_semisimple_iff_no_abelian_ideals at h
{ rw is_semisimple_iff_no_abelian_ideals at h, apply h, apply_instance, }
apply h
apply_instance
intros
let s := {k | derived_series_of_ideal R L k I = ⊥}
change Inf s = 0 ↔ _
have hne : s ≠ ∅
rw set.ne_empty_iff_nonempty
{ rw set.ne_empty_iff_nonempty, tactic.unfreeze_local_instances, obtain ⟨k, hk⟩ := hI, use k, rw [derived_series_def, lie_ideal.derived_series_eq_bot_iff] at hk, exact hk, }
obtain ⟨k, hk⟩ := hI
tactic.unfreeze_local_instances
use k
rw [derived_series_def, lie_ideal.derived_series_eq_bot_iff] at hk
exact hk
simp [hne]
intros
{ rw submodule.span_le, apply subset_lie_span, }
rw submodule.span_le
apply subset_lie_span
intros
{ rw submodule.span_le, apply subset_lie_span, }
rw submodule.span_le
apply subset_lie_span
intros
suffices : lie_ideal.map f (I ⊔ f.ker) ≤ lie_ideal.map f I
exact le_antisymm this (lie_ideal.map_mono le_sup_left)
{ exact le_antisymm this (lie_ideal.map_mono le_sup_left), }
apply lie_submodule.lie_span_mono
rintros x ⟨y, hy₁, hy₂⟩
rw ← hy₂
erw lie_submodule.mem_sup at hy₁
obtain ⟨z₁, hz₁, z₂, hz₂, hy⟩ := hy₁
rw ← hy
rw [f.coe_to_linear_map, f.map_add, f.mem_ker.mp hz₂, add_zero]
exact ⟨z₁, hz₁, rfl⟩
intros
rw [nsmul_eq_smul_cast ℕ n x, nat.cast_id]
intros
rw [← set_like.mem_coe, infi_coe, set.mem_Inter]
rw [← set_like.mem_coe, infi_coe, set.mem_Inter]; refl
refl
intros
simp
intros
{ ext, refl, }
ext
refl
intros
rw [← one_div, div_le_iff ha, ← div_eq_inv_mul, le_div_iff hb, one_mul]
intros
simpa using lt_inv_of_neg ha hb
intros
refine (one_div_le_one_div _ _).mpr (pow_le_pow a1 mn)
refine (one_div_le_one_div _ _).mpr (pow_le_pow a1 mn); exact pow_pos (zero_lt_one.trans_le a1) _
exact pow_pos (zero_lt_one.trans_le a1) _
exact pow_pos (zero_lt_one.trans_le a1) _
intros
{ rw ← mul_le_mul_iff_left a, simp }
rw ← mul_le_mul_iff_left a
simp
intros
rw [← mul_lt_mul_iff_right b, one_mul, inv_mul_cancel_right]
intros
rw [div_eq_mul_inv, lt_mul_inv_iff_mul_lt, inv_mul_lt_iff_lt_mul]
intros
norm_cast
intros
haveI := @linear_order.decidable_le α _; exact lt_of_not_ge (λ ha, absurd h (decidable.mul_nonneg_of_nonpos_of_nonpos ha hb).not_lt)
haveI := @linear_order.decidable_le α _
exact lt_of_not_ge (λ ha, absurd h (decidable.mul_nonneg_of_nonpos_of_nonpos ha hb).not_lt)
intros
simpa only [sub_eq_add_neg, antiperiodic] using h.sub_eq
intros
induction n with n ih
rw pow_zero
{ rw pow_zero, exact set.mem_singleton 1 }
exact set.mem_singleton 1
rw pow_succ
{ rw pow_succ, exact set.mul_mem_mul ha ih }
exact set.mul_mem_mul ha ih
intros
{ simp only [finset.mem_mul], exact ⟨x, y, hx, hy, rfl⟩ }
simp only [finset.mem_mul]
exact ⟨x, y, hx, hy, rfl⟩
intros
refine λ x y xy, ab (_ : x * (b * a) = y * (b * a))
rw [← mul_assoc, ← mul_assoc]
exact congr_fun (congr_arg has_mul.mul xy) a
intros
split_ifs; refl
split_ifs
refl
refl
intros
simp
intros
rw [mul_support_comp_eq_preimage f g, image_inter_preimage]
intros
intros s t h_eq
obtain ⟨a, ⟨b, hb⟩, rfl⟩ := is_localization.mk'_surjective (submonoid.powers f) s
obtain ⟨c, ⟨d, hd⟩, rfl⟩ := is_localization.mk'_surjective (submonoid.powers f) t
simp only [to_basic_open_mk'] at h_eq
rw is_localization.eq
let I : ideal R := { carrier := {r : R | a * d * r = c * b * r}, zero_mem' := by simp only [set.mem_set_of_eq, mul_zero], add_mem' := λ r₁ r₂ hr₁ hr₂, by { dsimp at hr₁ hr₂ ⊢, simp only [mul_add, hr₁, hr₂] }, smul_mem' := λ r₁ r₂ hr₂, by { dsimp at hr₂ ⊢, simp only [mul_comm r₁ r₂, ← mul_assoc, hr₂] }}
suffices : f ∈ I.radical
cases this with n hn
{ cases this with n hn, exact ⟨⟨f ^ n, n, rfl⟩, hn⟩ }
exact ⟨⟨f ^ n, n, rfl⟩, hn⟩
rw [← vanishing_ideal_zero_locus_eq_radical, mem_vanishing_ideal]
intros p hfp
contrapose hfp
rw [mem_zero_locus, set.not_subset]
have := congr_fun (congr_arg subtype.val h_eq) ⟨p,hfp⟩
rw [const_apply, const_apply, is_localization.eq] at this
cases this with r hr
exact ⟨r.1, hr, r.2⟩
intros
ext j
rcases i with ⟨i, _⟩
rcases j with ⟨j, _⟩
dsimp [δ, σ, fin.succ_above, fin.pred_above]
simp [fin.pred_above] with push_cast
split_ifs; { simp at *; linarith, }
split_ifs
{ simp at *; linarith, }
{ simp at *; linarith, }
{ simp at *; linarith, }
simp at *
simp at *; linarith
{ simp at *; linarith, }
linarith
intros
simp only [change_origin_series_term, linear_isometry_equiv.nnnorm_map]
intros
ext1 n
by_cases hn : n = 0
rw [hn, h]
{ rw [hn, h], ext v, rw [comp_coeff_zero', id_apply_ne_one _ _ zero_ne_one], refl }
ext v
rw [comp_coeff_zero', id_apply_ne_one _ _ zero_ne_one]
refl
dsimp [formal_multilinear_series.comp]
{ dsimp [formal_multilinear_series.comp], have n_pos : 0 < n := bot_lt_iff_ne_bot.mpr hn, rw finset.sum_eq_single (composition.single n n_pos), show comp_along_composition (id 𝕜 F) p (composition.single n n_pos) = p n, { ext v, rw [comp_along_composition_apply, id_apply_one' _ _ (composition.single_length n_pos)], dsimp [apply_composition], refine p.congr rfl (λ i him hin, congr_arg v $ _), ext, simp }, show ∀ (b : composition n), b ∈ finset.univ → b ≠ composition.single n n_pos → comp_along_composition (id 𝕜 F) p b = 0, { assume b _ hb, have A : b.length ≠ 1, by simpa [composition.eq_single_iff_length] using hb, ext v, rw [comp_along_composition_apply, id_apply_ne_one _ _ A], refl }, { simp } }
have n_pos : 0 < n := bot_lt_iff_ne_bot.mpr hn
rw finset.sum_eq_single (composition.single n n_pos)
show comp_along_composition (id 𝕜 F) p (composition.single n n_pos) = p n
ext v
{ ext v, rw [comp_along_composition_apply, id_apply_one' _ _ (composition.single_length n_pos)], dsimp [apply_composition], refine p.congr rfl (λ i him hin, congr_arg v $ _), ext, simp }
rw [comp_along_composition_apply, id_apply_one' _ _ (composition.single_length n_pos)]
dsimp [apply_composition]
refine p.congr rfl (λ i him hin, congr_arg v $ _)
ext
simp
show ∀ (b : composition n), b ∈ finset.univ → b ≠ composition.single n n_pos → comp_along_composition (id 𝕜 F) p b = 0
assume b _ hb
{ assume b _ hb, have A : b.length ≠ 1, by simpa [composition.eq_single_iff_length] using hb, ext v, rw [comp_along_composition_apply, id_apply_ne_one _ _ A], refl }
have A : b.length ≠ 1
simpa [composition.eq_single_iff_length] using hb
simpa [composition.eq_single_iff_length] using hb
ext v
rw [comp_along_composition_apply, id_apply_ne_one _ _ A]
refl
{ simp }
simp
intros
rw left_inv
intros
simp only [is_o, is_O_with_map]
intros
simp [div_eq_inv_mul, differentiable_on.const_mul, hc]
intros
simp [deriv_within]
intros
simp only [← deriv_within_univ, deriv_within_const_sub unique_diff_within_at_univ]
intros
simp only [add_comm c, fderiv_add_const]
intros
rw add_comm
exact (is_bounded_bilinear_map_comp.has_strict_fderiv_at (d x, c x)).comp x (hd.prod hc)
intros
{ rw ← H at h, exact h }
rw ← H at h
exact h
intros
have A : f₁ x = f x := hL.eq_of_nhds
rw [← fderiv_within_univ, ← fderiv_within_univ]
rw ← nhds_within_univ at hL
exact hL.fderiv_within_eq unique_diff_within_at_univ A
intros
{ cases h1, congr' with ⟨i, hi⟩, exact h2 i hi hi }
cases h1
congr' with ⟨i, hi⟩
exact h2 i hi hi
intros
have A : has_deriv_within_at (f_aux n) (0 : ℝ) (Iic 0) 0
apply (has_deriv_at_const (0 : ℝ) (0 : ℝ)).has_deriv_within_at.congr
{ apply (has_deriv_at_const (0 : ℝ) (0 : ℝ)).has_deriv_within_at.congr, { assume y hy, simp at hy, simp [f_aux, hy] }, { simp [f_aux, le_refl] } }
assume y hy
{ assume y hy, simp at hy, simp [f_aux, hy] }
simp at hy
simp [f_aux, hy]
{ simp [f_aux, le_refl] }
simp [f_aux, le_refl]
have B : has_deriv_within_at (f_aux n) (0 : ℝ) (Ici 0) 0
have diff : differentiable_on ℝ (f_aux n) (Ioi 0) := λx hx, (f_aux_deriv_pos n x hx).differentiable_at.differentiable_within_at
{ have diff : differentiable_on ℝ (f_aux n) (Ioi 0) := λx hx, (f_aux_deriv_pos n x hx).differentiable_at.differentiable_within_at, apply has_deriv_at_interval_left_endpoint_of_tendsto_deriv diff _ self_mem_nhds_within, { refine (f_aux_limit (n+1)).congr' _, apply mem_of_superset self_mem_nhds_within (λx hx, _), simp [(f_aux_deriv_pos n x hx).deriv] }, { have : f_aux n 0 = 0, by simp [f_aux, le_refl], simp only [continuous_within_at, this], refine (f_aux_limit n).congr' _, apply mem_of_superset self_mem_nhds_within (λx hx, _), have : ¬(x ≤ 0), by simpa using hx, simp [f_aux, this] } }
apply has_deriv_at_interval_left_endpoint_of_tendsto_deriv diff _ self_mem_nhds_within
refine (f_aux_limit (n+1)).congr' _
{ refine (f_aux_limit (n+1)).congr' _, apply mem_of_superset self_mem_nhds_within (λx hx, _), simp [(f_aux_deriv_pos n x hx).deriv] }
apply mem_of_superset self_mem_nhds_within (λx hx, _)
simp [(f_aux_deriv_pos n x hx).deriv]
have : f_aux n 0 = 0
{ have : f_aux n 0 = 0, by simp [f_aux, le_refl], simp only [continuous_within_at, this], refine (f_aux_limit n).congr' _, apply mem_of_superset self_mem_nhds_within (λx hx, _), have : ¬(x ≤ 0), by simpa using hx, simp [f_aux, this] }
simp [f_aux, le_refl]
simp [f_aux, le_refl]
simp only [continuous_within_at, this]
refine (f_aux_limit n).congr' _
apply mem_of_superset self_mem_nhds_within (λx hx, _)
have : ¬(x ≤ 0)
simpa using hx
simpa using hx
simp [f_aux, this]
simpa using A.union B
intros
{ rw [subsingleton.elim f (λ _, 0)], exact times_cont_diff_const }
rw [subsingleton.elim f (λ _, 0)]
exact times_cont_diff_const
intros
cases le_total x y
{ rw [segment_eq_Icc h, max_eq_right h, min_eq_left h] }
rw [segment_eq_Icc h, max_eq_right h, min_eq_left h]
rw [segment_symm, segment_eq_Icc h, max_eq_left h, min_eq_right h]
{ rw [segment_symm, segment_eq_Icc h, max_eq_left h, min_eq_right h] }
intros
rintro x y ⟨x', ⟨hx', hx'f⟩⟩ ⟨y', ⟨hy', hy'f⟩⟩ a b ha hb hab
refine ⟨a • x' + b • y', ⟨hs hx' hy' ha hb hab, _⟩⟩
rw [convex.combo_affine_apply hab, hx'f, hy'f]
intros
rw [← convex_hull_basis_eq_std_simplex, ← linear_map.convex_hull_image, ← set.range_comp, (∘)]
apply congr_arg
convert subtype.range_coe.symm
ext x
simp [linear_map.sum_apply, ite_smul, finset.filter_eq]
intros
cases S; cases T; congr'
cases S; cases T
cases S
cases T
congr'
intros
ext
rw [submodule.mem_bot, submodule.mem_orthogonal]
exact ⟨λ h, inner_self_eq_zero.mp (h x submodule.mem_top), by { rintro rfl, simp }⟩
intros
convert inner_sum l.support (λ a, l a • v a) x
{ convert inner_sum l.support (λ a, l a • v a) x, simp [inner_smul_right, finsupp.sum] }
simp [inner_smul_right, finsupp.sum]
intros
rw [← inner_conj_sym, hv.inner_right_finsupp]
intros
{ rw [(hf.has_fderiv_at.inner hg.has_fderiv_at).fderiv], refl }
rw [(hf.has_fderiv_at.inner hg.has_fderiv_at).fderiv]
refl
intros
nth_rewrite 0 eq_sum_orthogonal_projection_self_orthogonal_complement K v
nth_rewrite 1 eq_sum_orthogonal_projection_self_orthogonal_complement K u
rw [inner_add_left, inner_add_right, submodule.inner_right_of_mem_orthogonal (submodule.coe_mem (orthogonal_projection K u)) (submodule.coe_mem (orthogonal_projection Kᗮ v)), submodule.inner_left_of_mem_orthogonal (submodule.coe_mem (orthogonal_projection K v)) (submodule.coe_mem (orthogonal_projection Kᗮ u))]
intros
rw [midpoint_comm, dist_midpoint_left, dist_comm]
intros
simpa only [is_unit_iff_ne_zero] using punctured_nhds_ne_bot (0:α)
intros
refine set.subset.antisymm _ ball_subset_interior_closed_ball
intros y hy
rcases le_iff_lt_or_eq.1 (mem_closed_ball.1 $ interior_subset hy) with hr|rfl
exact hr
{ exact hr }
set f : ℝ → E := λ c : ℝ, c • (y - x) + x
suffices : f ⁻¹' closed_ball x (dist y x) ⊆ set.Icc (-1) 1
have hfc : continuous f := (continuous_id.smul continuous_const).add continuous_const
{ have hfc : continuous f := (continuous_id.smul continuous_const).add continuous_const, have hf1 : (1:ℝ) ∈ f ⁻¹' (interior (closed_ball x $ dist y x)), by simpa [f], have h1 : (1:ℝ) ∈ interior (set.Icc (-1:ℝ) 1) := interior_mono this (preimage_interior_subset_interior_preimage hfc hf1), contrapose h1, simp }
have hf1 : (1:ℝ) ∈ f ⁻¹' (interior (closed_ball x $ dist y x))
simpa [f]
simpa [f]
have h1 : (1:ℝ) ∈ interior (set.Icc (-1:ℝ) 1) := interior_mono this (preimage_interior_subset_interior_preimage hfc hf1)
contrapose h1
simp
intros c hc
rw [set.mem_Icc, ← abs_le, ← real.norm_eq_abs, ← mul_le_mul_right hr]
simpa [f, dist_eq_norm, norm_smul] using hc
intros
simp_rw ← sum_antidiagonal_eq_sum_range_succ (λ k l, f k * g l)
exact summable_norm_sum_mul_antidiagonal_of_summable_norm hf hg
intros
simp only [isometry_emetric_iff_metric, dist_eq_norm, ← f.map_sub]
refine ⟨λ h x, _, λ h x y, h _⟩
simpa using h x 0
intros
rw lt_iff_le_and_ne
simp only [norm_nonneg, true_and]
rw [ne_comm]
exact not_iff_not_of_iff (norm_eq_zero_iff')
intros
rw ← exp_series_apply_eq_field'
exact exp_series_has_sum_exp_of_mem_ball x hx
intros
by_cases hc : c = 0
{ simp_rw [hc, smul_zero], exact is_closed_map_const }
simp_rw [hc, smul_zero]
exact is_closed_map_const
{ exact (closed_embedding_smul_left hc).is_closed_map }
exact (closed_embedding_smul_left hc).is_closed_map
intros
refine norm_id_of_nontrivial_seminorm V _
obtain ⟨x, hx⟩ := exists_ne (0 : V)
exact ⟨x, ne_of_gt (norm_pos_iff.2 hx)⟩
intros
ext x
rw [normed_group_hom.coe_comp, normed_group_hom.completion_def, normed_group_hom.completion_coe_to_fun, normed_group_hom.completion_coe_to_fun, completion.map_comp (normed_group_hom.uniform_continuous _) (normed_group_hom.uniform_continuous _)]
refl
intros
rw hquot.norm
apply cInf_le
use 0
{ use 0, rintros _ ⟨m', hm', rfl⟩, apply norm_nonneg }
rintros _ ⟨m', hm', rfl⟩
apply norm_nonneg
{ exact ⟨0, f.ker.zero_mem, by simp⟩ }
exact ⟨0, f.ker.zero_mem, by simp⟩
intros
simpa only [log, arg_eq_pi_iff.2 ⟨hre, him⟩] using (continuous_within_at_log_of_re_neg_of_im_zero hre him).tendsto
rw [← map_exp_at_bot, comap_map exp_injective]
intros
field_simp [integral_cos_pow, add_sub_assoc]
intros
rw ← has_deriv_within_at_univ at *
exact hf.rpow_const hx
intros
simp_rw ennreal.of_real
rw [coe_rpow_of_ne_zero, coe_eq_coe, real.to_nnreal_rpow_of_nonneg hx_pos.le]
simp [hx_pos]
intros
convert rpow_le_rpow_of_exponent_le hx hz
{ convert rpow_le_rpow_of_exponent_le hx hz, exact (rpow_zero x).symm }
exact (rpow_zero x).symm
intros
induction n with n ihn generalizing p
exact times_cont_diff_zero.2 (continuous_id.rpow_const (λ x, or.inr h))
{ exact times_cont_diff_zero.2 (continuous_id.rpow_const (λ x, or.inr h)) }
have h1 : 1 ≤ p
{ have h1 : 1 ≤ p, from le_trans (by simp) h, rw [nat.cast_succ, ← le_sub_iff_add_le] at h, simpa [times_cont_diff_succ_iff_deriv, differentiable_rpow_const, h1, deriv_rpow_const'] using times_cont_diff_const.mul (ihn h) }
from le_trans (by simp) h
rw [nat.cast_succ, ← le_sub_iff_add_le] at h
simpa [times_cont_diff_succ_iff_deriv, differentiable_rpow_const, h1, deriv_rpow_const'] using times_cont_diff_const.mul (ihn h)
simp [cos_add]
intros
cases le_or_gt x 1 with h' h'
have hx : abs x = x := abs_of_nonneg (le_of_lt h)
{ have hx : abs x = x := abs_of_nonneg (le_of_lt h), have : abs x ≤ 1, rwa [hx], have := sin_bound this, rw [abs_le] at this, have := this.2, rw [sub_le_iff_le_add', hx] at this, apply lt_of_le_of_lt this, rw [sub_add], apply lt_of_lt_of_le _ (le_of_eq (sub_zero x)), apply sub_lt_sub_left, rw [sub_pos, div_eq_mul_inv (x ^ 3)], apply mul_lt_mul', { rw [pow_succ x 3], refine le_trans _ (le_of_eq (one_mul _)), rw mul_le_mul_right, exact h', apply pow_pos h }, norm_num, norm_num, apply pow_pos h }
have : abs x ≤ 1
rwa [hx]
have := sin_bound this
rw [abs_le] at this
have := this.2
rw [sub_le_iff_le_add', hx] at this
apply lt_of_le_of_lt this
rw [sub_add]
apply lt_of_lt_of_le _ (le_of_eq (sub_zero x))
apply sub_lt_sub_left
rw [sub_pos, div_eq_mul_inv (x ^ 3)]
apply mul_lt_mul'
rw [pow_succ x 3]
{ rw [pow_succ x 3], refine le_trans _ (le_of_eq (one_mul _)), rw mul_le_mul_right, exact h', apply pow_pos h }
refine le_trans _ (le_of_eq (one_mul _))
rw mul_le_mul_right
exact h'
apply pow_pos h
apply pow_pos h
norm_num
norm_num
apply pow_pos h
apply pow_pos h
exact lt_of_le_of_lt (sin_le_one x) h'
intros
rw tan_eq_sin_div_cos; exact div_pos (sin_pos_of_pos_of_lt_pi h0x (by linarith)) (cos_pos_of_mem_Ioo ⟨by linarith, hxp⟩)
rw tan_eq_sin_div_cos
exact div_pos (sin_pos_of_pos_of_lt_pi h0x (by linarith)) (cos_pos_of_mem_Ioo ⟨by linarith, hxp⟩)
intros
rw [← not_exists, not_iff_not, sin_eq_zero_iff]
intros
rw [arccos, sub_eq_iff_eq_add, ← sub_eq_iff_eq_add', div_two_sub_self, neg_pi_div_two_eq_arcsin]
intros
have : ∀ i, 0 ≤ (1 / (2 : ℝ)) ^ i
{ intro i, apply pow_nonneg, norm_num }
intro i
apply pow_nonneg
norm_num
convert sum_le_tsum (range n) (λ i _, this i) summable_geometric_two
exact tsum_geometric_two.symm
intros
rw [←category.assoc, is_iso.hom_inv_id]
intros
{ rw [pseudo_zero_def, pseudo_apply_mk], simp }
rw [pseudo_zero_def, pseudo_apply_mk]
simp
intros
simp only [←mk_hom f, lift.fac_left]
intros
split
intros Z a b w
apply (cancel_epi g).1
apply (cancel_epi f).1
simpa using w
intros
erw [nat_iso.naturality_1]
refl
intros
ext
{ ext, simp, }
simp
intros
{ dsimp [cocone_of_cone_left_op], simp }
dsimp [cocone_of_cone_left_op]
simp
intros
dsimp [limit_curry_swap_comp_lim_iso_limit_curry_comp_lim]
simp only [iso.refl_hom, braiding_counit_iso_hom_app, limits.has_limit.iso_of_equivalence_inv_π, iso.refl_inv, limit_iso_limit_curry_comp_lim_hom_π_π, eq_to_iso_refl, category.assoc]
erw [nat_trans.id_app]
dsimp
simp
intros
simp
intros
simp
intros
simp [is_iso.inv_comp_eq]
intros
tidy
intros
letI := is_coreflexive_pair.mk' r fr gr
apply_instance
intros
haveI := t.split_mono_from f; apply_instance
haveI := t.split_mono_from f
apply_instance
intros
apply (colimit_equiv_quot F).symm.injective
simp
intros
{ rw ←tensor_comp, simp }
rw ←tensor_comp
simp
intros
rw [←tensor_comp, f.inv_hom_id]
intros
simp only [←category.assoc, cancel_mono]
intros
{ rw [← app_hom_apply, add_monoid_hom.map_sum], refl }
rw [← app_hom_apply, add_monoid_hom.map_sum]
refl
intros
classical
by_contradiction h
haveI := is_iso_of_mono_of_nonzero h
exact w (eq_zero_of_epi_kernel f)
intros
refine @is_glb.of_image _ _ _ _ sieves _ _ _ _
{ intros, refl }
intros
refl
{ exact is_glb_Inf _ }
exact is_glb_Inf _
intros
intros x hx
refine ⟨x _ (presieve.singleton_self _), _, _⟩
rintro _ _ ⟨rfl, rfl⟩
{ rintro _ _ ⟨rfl, rfl⟩, simp }
simp
intros t ht
{ intros t ht, simpa using ht _ (presieve.singleton_self _) }
simpa using ht _ (presieve.singleton_self _)
intros
ext Z g
split
rintro ⟨_, h, k, hk, rfl⟩
{ rintro ⟨_, h, k, hk, rfl⟩, cases hk with W g hg, change (sieve.generate R).pullback f (h ≫ pullback.snd), rw [sieve.pullback_apply, assoc, ← pullback.condition, ← assoc], exact sieve.downward_closed _ (sieve.le_generate R W hg) (h ≫ pullback.fst)}
cases hk with W g hg
change (sieve.generate R).pullback f (h ≫ pullback.snd)
rw [sieve.pullback_apply, assoc, ← pullback.condition, ← assoc]
exact sieve.downward_closed _ (sieve.le_generate R W hg) (h ≫ pullback.fst)
rintro ⟨W, h, k, hk, comm⟩
{ rintro ⟨W, h, k, hk, comm⟩, exact ⟨_, _, _, presieve.pullback_arrows.mk _ _ hk, pullback.lift_snd _ _ comm⟩ }
exact ⟨_, _, _, presieve.pullback_arrows.mk _ _ hk, pullback.lift_snd _ _ comm⟩
intros
{ apply (cancel_mono f).mp, simp }
apply (cancel_mono f).mp
simp
intros
{ ext, simp, }
ext
simp
intros
have n_pos : 0 < n := lt_of_le_of_lt (zero_le j) h
have : 0 < c.blocks.sum
rwa [← c.blocks_sum] at n_pos
rwa [← c.blocks_sum] at n_pos
have length_pos : 0 < c.blocks.length := length_pos_of_sum_pos (blocks c) this
refine ⟨c.length.pred, _, nat.pred_lt (ne_of_gt length_pos)⟩
have : c.length.pred.succ = c.length := nat.succ_pred_eq_of_pos length_pos
simp [this, h]
intros
{ funext i, cases i; refl }
funext i
cases i
cases i; refl
refl
refl
intros
simp [incidence_set]
intros
haveI h : decidable_eq V
classical
{ classical, apply_instance }
apply_instance
simp only [←card_univ, ←dart_fst_fiber_card_eq_degree]
exact card_eq_sum_card_fiberwise (by simp)
intros
refl
intros
induction k generalizing v
case halt : { simp only [mem_eval, cont.eval, map_pure], exact part.eq_some_iff.2 (mem_eval.2 ⟨refl_trans_gen.refl, rfl⟩) }
simp only [mem_eval, cont.eval, map_pure]
exact part.eq_some_iff.2 (mem_eval.2 ⟨refl_trans_gen.refl, rfl⟩)
case cons₁ : fs as k IH { rw [cont.eval, step_ret, code_is_ok], simp only [← bind_pure_comp_eq_map, bind_assoc], congr, funext v', rw [reaches_eval], swap, exact refl_trans_gen.single rfl, rw [step_ret, IH, bind_pure_comp_eq_map] }
case cons₂ : ns k IH { rw [cont.eval, step_ret], exact IH }
case comp : f k IH { rw [cont.eval, step_ret, code_is_ok], simp only [← bind_pure_comp_eq_map, bind_assoc], congr, funext v', rw [reaches_eval], swap, exact refl_trans_gen.single rfl, rw [IH, bind_pure_comp_eq_map] }
case fix : f k IH { rw [cont.eval, step_ret], simp only [bind_pure_comp_eq_map], split_ifs, { exact IH }, simp only [← bind_pure_comp_eq_map, bind_assoc, cont_eval_fix (code_is_ok _)], congr, funext, rw [bind_pure_comp_eq_map, ← IH], exact reaches_eval (refl_trans_gen.single rfl) }
intros
cases l; [exact (pointed_map.map_pt f).symm, refl]
cases l
exact (pointed_map.map_pt f).symm
refl
intros
simp only [mjoin, (∘), id.def, map_bind, (bind_pure_comp_eq_map _ _).symm, bind_assoc, pure_bind, bind_pure]
intros
simpa [equiv_functor.map_equiv]
intros
ext
ext;rw traverse_eq_map_id
rw traverse_eq_map_id
intros
rw [list.foldr_reverse, flip]; refl
rw [list.foldr_reverse, flip]
refl
intros
rw [←to_buffer_to_list b, to_list_to_buffer, size_to_buffer]
intros
cases h : p cb n; simp [decorate_errors, h]
cases h : p cb n
simp [decorate_errors, h]
simp [decorate_errors, h]
intros
simp [←bind_pure_comp_eq_map, pure_eq_done]
intros
simp [many_char, list.as_string_eq, string.to_list_nonempty h, many_eq_done]
intros
simp
intros
simp [inv_def, division_def]
intros
rw [← of_real_int_cast, abs_of_real, int.cast_abs]
intros
rw [← tan_mul_cos hx.ne', ← inv_sqrt_one_add_tan_sq hx, div_eq_mul_inv]
intros
rw [← mul_right_inj' (exp_ne_zero x), ← exp_add]
rw [← mul_right_inj' (exp_ne_zero x), ← exp_add]; simp [mul_inv_cancel (exp_ne_zero x)]
simp [mul_inv_cancel (exp_ne_zero x)]
intros
rw ← cosh_sq_sub_sinh_sq x
ring
intros
rw [tan_eq_sin_div_cos, div_mul_cancel _ hx]
intros
simp only [mul_re, of_real_im, zero_mul, of_real_re, sub_zero]
intros
rw [inv_def, ←mul_assoc, mul_conj, ←of_real_mul, ←norm_sq_eq_def', mul_inv_cancel (mt norm_sq_eq_zero.1 h), of_real_one]
intros
ext ⟨x, y⟩
simp only [mk_eq_add_mul_I, alg_hom.map_add, alg_hom.map_coe_real_complex, alg_hom.map_mul, h]
intros
simp only [filter_apply, if_pos h]
intros
refine ⟨λ h, (equiv.refl _).injective _, λ h, h ▸ (swap_self _)⟩
rw [←h, swap_apply_left, h, refl_apply]
intros
cases e
{ cases e, refl }
refl
intros
by_cases h : p a; simp [perm.subtype_congr, h]
{ by_cases h : p a; simp [perm.subtype_congr, h] }
by_cases h : p a
simp [perm.subtype_congr, h]
simp [perm.subtype_congr, h]
intros
intro eq
by_cases H : i.cast_succ < p
simpa [lt_irrefl, ←succ_above_below _ _ H, eq] using H
{ simpa [lt_irrefl, ←succ_above_below _ _ H, eq] using H }
simpa [←succ_above_above _ _ (le_of_not_lt H), eq] using cast_succ_lt_succ i
{ simpa [←succ_above_above _ _ (le_of_not_lt H), eq] using cast_succ_lt_succ i }
intros
ext j
by_cases h : j = i
{ rw h, simp [tail] }
rw h
simp [tail]
{ simp [tail, (fin.succ_injective n).ne h, h] }
simp [tail, (fin.succ_injective n).ne h, h]
intros
cases j; simp [fin.succ]
cases j
simp [fin.succ]
intros
ext j
rcases em (j = i) with (rfl|hj); by_cases hs : j ∈ s; simp *
rcases em (j = i) with (rfl|hj); by_cases hs : j ∈ s
rcases em (j = i) with (rfl|hj)
by_cases hs : j ∈ s
simp *
simp *
by_cases hs : j ∈ s
simp *
simp *
intros
classical
{ classical, simp_rw [product_eq_bUnion, bUnion_bUnion, image_bUnion] }
simp_rw [product_eq_bUnion, bUnion_bUnion, image_bUnion]
intros
rw finset.disjoint_iff_ne
split
intro h
{ intro h, intros a ha1 ha2, rw ← multiset.mem_to_finset at ha1 ha2, exact h _ ha1 _ ha2 rfl }
intros a ha1 ha2
rw ← multiset.mem_to_finset at ha1 ha2
exact h _ ha1 _ ha2 rfl
rintros h a ha b hb rfl
{ rintros h a ha b hb rfl, rw multiset.mem_to_finset at ha hb, exact h ha hb }
rw multiset.mem_to_finset at ha hb
exact h ha hb
intros
show _ > _ ↔ _
apply fold_op_rel_iff_or
intros x y z
show _ < _ ↔ _
exact min_lt_iff
intros
simp [supr_or, supr_sup_eq]
intros
rw [antidiagonal, mem_def, multiset.nat.mem_antidiagonal]
intros
simp [pimage]
intros
simp only [set.subset_def, mem_coe, mem_support_iff]
simp only [set.subset_def, mem_coe, mem_support_iff]; exact forall_congr (assume a, not_imp_comm)
exact forall_congr (assume a, not_imp_comm)
intros
rw [finsupp.curry]
transitivity
exact sum_sum_index (assume a, sum_zero_index) (assume a b₀ b₁, sum_add_index (assume a, hg₀ _ _) (assume c d₀ d₁, hg₁ _ _ _ _))
{ exact sum_sum_index (assume a, sum_zero_index) (assume a b₀ b₁, sum_add_index (assume a, hg₀ _ _) (assume c d₀ d₁, hg₁ _ _ _ _)) }
congr
funext p c
transitivity
{ exact sum_single_index sum_zero_index }
exact sum_single_index sum_zero_index
exact sum_single_index (hg₀ _ _)
intros
{ ext, simp [finsupp.single_apply, dfinsupp.single_apply] }
ext
simp [finsupp.single_apply, dfinsupp.single_apply]
intros
ext ⟨b, h⟩
apply hf
simp [hf.left_inv_of_inv_of_mem_range, @inv_fun_eq _ _ _ f b (set.mem_range.mp h)]
intros
simp
intros
have hk' := int.coe_nat_ne_zero.mpr (ne_of_gt (lt_of_le_of_lt (zero_le (gcd n k)) hk))
have key := congr_arg (λ m, int.nat_mod m k) (gcd_eq_gcd_ab n k)
simp_rw int.nat_mod at key
rw [int.add_mul_mod_self_left, ←int.coe_nat_mod, int.to_nat_coe_nat, mod_eq_of_lt hk] at key
refine ⟨(n.gcd_a k % k).to_nat, eq.trans (int.coe_nat_inj _) key.symm⟩
rw [int.coe_nat_mod, int.coe_nat_mul, int.to_nat_of_nonneg (int.mod_nonneg _ hk'), int.to_nat_of_nonneg (int.mod_nonneg _ hk'), int.mul_mod, int.mod_mod, ←int.mul_mod]
intros
rw [modeq, eq_comm]; simp [mod_eq_mod_iff_mod_sub_eq_zero, dvd_iff_mod_eq_zero, -euclidean_domain.mod_eq_zero]
rw [modeq, eq_comm]
simp [mod_eq_mod_iff_mod_sub_eq_zero, dvd_iff_mod_eq_zero, -euclidean_domain.mod_eq_zero]
intros
{ cases L, cases h, simp, }
cases L
cases h
simp
intros
rw [← option.some_inj, ← nth_le_nth, nth_update_nth_eq, nth_le_nth]
rw [← option.some_inj, ← nth_le_nth, nth_update_nth_eq, nth_le_nth]; simp * at *
simp * at *
simp * at *
intros
rw ← h; apply take_left
rw ← h
apply take_left
intros
rw [update_nth_eq_modify_nth, modify_nth_eq_take_cons_drop _ h]
intros
apply monotone_nat_of_le_succ (λ n, _)
by_cases h : n < L.length
rw sum_take_succ _ _ h
{ rw sum_take_succ _ _ h, exact le_self_add }
exact le_self_add
push_neg at h
{ push_neg at h, simp [take_all_of_le h, take_all_of_le (le_trans h (nat.le_succ _))] }
simp [take_all_of_le h, take_all_of_le (le_trans h (nat.le_succ _))]
intros
rw [nth_le_take L.join (sum_take_map_length_lt2 L hi hj) (sum_take_map_length_lt1 L hi hj), nth_le_drop, nth_le_of_eq (drop_take_succ_join_eq_nth_le L hi)]
intros
simp only [filter_map, h]; split; refl
simp only [filter_map, h]; split
simp only [filter_map, h]
split
refl
refl
intros
rw [← filter_map_eq_map, filter_filter_map, filter_map_filter]
rw [← filter_map_eq_map, filter_filter_map, filter_map_filter]; refl
refl
intros
cases a; simp only [and_assoc, @eq_comm _ c, nil_append, cons_append, eq_self_iff_true, true_and, false_and, exists_false, false_or, or_false, exists_and_distrib_left, exists_eq_left']
cases a
simp only [and_assoc, @eq_comm _ c, nil_append, cons_append, eq_self_iff_true, true_and, false_and, exists_false, false_or, or_false, exists_and_distrib_left, exists_eq_left']
simp only [and_assoc, @eq_comm _ c, nil_append, cons_append, eq_self_iff_true, true_and, false_and, exists_false, false_or, or_false, exists_and_distrib_left, exists_eq_left']
intros
rcases exists_of_erasep al pa with ⟨_, l₁, l₂, _, _, e₁, e₂⟩
rcases exists_of_erasep al pa with ⟨_, l₁, l₂, _, _, e₁, e₂⟩; rw e₂; simp [-add_comm, e₁]; refl
rcases exists_of_erasep al pa with ⟨_, l₁, l₂, _, _, e₁, e₂⟩; rw e₂; simp [-add_comm, e₁]
rcases exists_of_erasep al pa with ⟨_, l₁, l₂, _, _, e₁, e₂⟩; rw e₂
rw e₂
simp [-add_comm, e₁]
refl
intros
simp only [enum, enum_from_nth, zero_add]; intros; refl
simp only [enum, enum_from_nth, zero_add]; intros
simp only [enum, enum_from_nth, zero_add]
intros
cases bs; refl
cases bs
refl
refl
intros
induction l₁ generalizing l₂; [refl, simp only [*, reverse_core, reverse_cons, append_assoc]]; refl
induction l₁ generalizing l₂; [refl, simp only [*, reverse_core, reverse_cons, append_assoc]]
induction l₁ generalizing l₂
refl
simp only [*, reverse_core, reverse_cons, append_assoc]
refl
intros
simp [Ico, nat.sub_eq_zero_of_le h]
intros
simp only [nodup_append, not_or_distrib, and.left_comm, and_assoc, nodup_cons, mem_append, disjoint_cons_right]
intros
{ apply of_reverse_eq, rw [reverse_append, reverse_reverse] }
apply of_reverse_eq
rw [reverse_append, reverse_reverse]
intros
induction l generalizing n
{ cases n, refl, cases h }
cases n
refl
cases h
cases n
{ simp [insert_nth] }
simp [insert_nth]
simp only [insert_nth, modify_nth_tail]
{ simp only [insert_nth, modify_nth_tail], transitivity, { apply perm.cons, apply l_ih, apply nat.le_of_succ_le_succ h }, { apply perm.swap } }
transitivity
apply perm.cons
{ apply perm.cons, apply l_ih, apply nat.le_of_succ_le_succ h }
apply l_ih
apply nat.le_of_succ_le_succ h
{ apply perm.swap }
apply perm.swap
intros
rw [← length_eq_zero, length_fin_range]
intros
rw lookup_all_eq_lookup a h; apply option.to_list_nodup
rw lookup_all_eq_lookup a h
apply option.to_list_nodup
intros
induction l₁ generalizing l₂
simp
case list.nil { simp }
case list.cons : s _ ih { cases s with a', by_cases h₁ : a = a', { subst h₁, simp }, { let h₂ := @ih (kerase a' l₂), simp [h₁] at h₂, simp [h₁, h₂] } }
intros
rw [← reverse_sublist_iff, ← mem_sublists', sublists'_reverse, mem_map_of_injective reverse_injective]
intros
rw unzip; cases unzip l; refl
rw unzip; cases unzip l
rw unzip
cases unzip l
refl
intros
ext i j; simp [mul_comm]
ext i j
simp [mul_comm]
intros
simp only [matrix.dot_product, f.map_sum, f.map_mul]
intros
simp [sub_eq_add_neg]
intros
simp only [dot_product, vec_mul, mul_vec, finset.mul_sum, finset.sum_mul, mul_assoc]
simp only [dot_product, vec_mul, mul_vec, finset.mul_sum, finset.sum_mul, mul_assoc]; exact finset.sum_comm
exact finset.sum_comm
intros
ext
simp only [transpose_apply, block_diagonal_apply, eq_comm]
split_ifs with h
{ rw h }
rw h
{ refl }
refl
intros
{ ext ⟨i, i'⟩ ⟨j, j'⟩, refl }
ext ⟨i, i'⟩ ⟨j, j'⟩
refl
intros
simpa using add_union_distrib (a ::ₘ 0) s t
intros
simp [subset_iff, or_imp_distrib, forall_and_distrib]
intros
simp [le_erase_dup, hno]
intros
rw [← inf_erase_dup, erase_dup_ext.2, inf_erase_dup, inf_add]
rw [← inf_erase_dup, erase_dup_ext.2, inf_erase_dup, inf_add]; simp
simp
intros
haveI := classical.dec_eq α
simp [λ l:list α, revzip_powerset_aux_lemma l revzip_powerset_aux, coe_eq_coe.2 p]
exact (powerset_aux_perm p).map _
intros
funext i
transitivity (aeval x (aeval (λ i, g (X i)) (f (X i))))
apply eval₂_hom_congr rfl rfl
{ apply eval₂_hom_congr rfl rfl, rw alg_hom.comp_apply, suffices : g = aeval (λ i, g (X i)), { rw ← this, }, exact aeval_unique g }
rw alg_hom.comp_apply
suffices : g = aeval (λ i, g (X i))
rw ← this
{ rw ← this, }
exact aeval_unique g
simp only [comap, aeval_eq_eval₂_hom, map_eval₂_hom, alg_hom.comp_apply]
{ simp only [comap, aeval_eq_eval₂_hom, map_eval₂_hom, alg_hom.comp_apply], refine eval₂_hom_congr _ rfl rfl, ext r, apply aeval_C }
refine eval₂_hom_congr _ rfl rfl
ext r
apply aeval_C
intros
{ ext1 i, simp }
ext1 i
simp
intros
by_cases n0 : n = 0
{ rw [n0, nat.div_zero, nat.div_zero] }
rw [n0, nat.div_zero, nat.div_zero]
rw [← mod_add_div m n] { occs := occurrences.pos [2] }
{ rw [← mod_add_div m n] { occs := occurrences.pos [2] }, rw [nat.add_sub_cancel_left, mul_div_right _ (nat.pos_of_ne_zero n0)] }
rw [nat.add_sub_cancel_left, mul_div_right _ (nat.pos_of_ne_zero n0)]
{ ext n, cases n; simp }
ext n
cases n
cases n; simp
simp
simp
intros
bitwise_assoc_tac
intros
rw [dist_comm]
apply dist_eq_sub_of_le h
intros
{ conv_rhs { rw [← enat.add_lt_add_iff_left hx] }, rw [add_zero] }
conv_rhs { rw [← enat.add_lt_add_iff_left hx] }
rw [add_zero]
intros
rw [mul_comm n k, H.gcd_mul_left_cancel_right n]
intros
rw factors
norm_num
simp [totient]
intros
cases n; apply nat.succ_pos
cases n
apply nat.succ_pos
apply nat.succ_pos
apply nat.succ_pos
intros
cases x; simp only [map_none', map_some']
{ cases x; simp only [map_none', map_some'] }
cases x
simp only [map_none', map_some']
simp only [map_none', map_some']
intros
cases a; refl
cases a
refl
refl
intros
rw balance'
split_ifs
{ exact hl.node' hr (or.inl h) }
exact hl.node' hr (or.inl h)
{ exact hl.rotate_l hr h h_1 H₁ }
exact hl.rotate_l hr h h_1 H₁
{ exact hl.rotate_r hr h h_2 H₂ }
exact hl.rotate_r hr h h_2 H₂
exact hl.node' hr (or.inr ⟨not_lt.1 h_2, not_lt.1 h_1⟩)
{ exact hl.node' hr (or.inr ⟨not_lt.1 h_2, not_lt.1 h_1⟩) }
intros
simp [node', add_comm]
intros
ext
ext; dsimp [pequiv.trans]; simp
ext; dsimp [pequiv.trans]
dsimp [pequiv.trans]
simp
intros
ext x
ext x; simp [core_def]
simp [core_def]
intros
{ cases x, refl }
cases x
refl
intros
rw ← coprime_coe at *
simp only [pow_coe]
apply nat.coprime.pow
apply h
intros
{ rcases p, rcases q, simp [coeff, finsupp.ext_iff] }
rcases p
rcases q
simp [coeff, finsupp.ext_iff]
intros
by_cases hp : p = 0
{ rw hp, exact bot_le }
rw hp
exact bot_le
rw degree_eq_nat_degree hp
{ rw degree_eq_nat_degree hp, exact le_degree_of_ne_zero h }
exact le_degree_of_ne_zero h
intros
apply nat_degree_le_of_degree_le
apply le_trans (degree_mul_le p q)
rw with_bot.coe_add
refine add_le_add _ _; apply degree_le_nat_degree
refine add_le_add _ _
apply degree_le_nat_degree
apply degree_le_nat_degree
intros
rw next_coeff_up
{ rw next_coeff_up, simp }
simp
intros
induction k with k ih
{ simp, }
simp
{ simp [ih], }
simp [ih]
intros
rw eval₂_mul f x
exact mul_eq_zero_of_left hp (q.eval₂ f x)
intros
intros x
simp only [mem_support_iff]
contrapose!
rw coeff_map
intro hx
rw hx
exact ring_hom.map_zero f
intros
rw [←one_mul (X ^ n : polynomial R), ←C_1, root_set_C_mul_X_pow hn]
{ rw [←one_mul (X ^ n : polynomial R), ←C_1, root_set_C_mul_X_pow hn], exact one_ne_zero }
exact one_ne_zero
intros
ext m
rw [coeff_iterated_deriv_as_prod_range, coeff_zero, coeff_eq_zero_of_nat_degree_lt, zero_mul]
linarith
intros
rw [←p.mirror_mirror, mirror_trailing_coeff, p.mirror_mirror]
intros
apply hf
rw [← leading_coeff_of_injective hf, hp.leading_coeff, f.map_one]
intros
rw [coeff_reverse, rev_at_le (zero_le f.nat_degree), nat.sub_zero, leading_coeff]
intros
rw [supp]
dsimp
split
intros h a f haf
{ intros h a f haf, have : liftp (λ i u, u ∈ f i '' univ) x, { rw liftp_iff, refine ⟨a, f, haf.symm, _⟩, intros i u, exact mem_image_of_mem _ (mem_univ _) }, exact h this }
have : liftp (λ i u, u ∈ f i '' univ) x
rw liftp_iff
{ rw liftp_iff, refine ⟨a, f, haf.symm, _⟩, intros i u, exact mem_image_of_mem _ (mem_univ _) }
refine ⟨a, f, haf.symm, _⟩
intros i u
exact mem_image_of_mem _ (mem_univ _)
exact h this
intros h p
rw liftp_iff
rintros ⟨a, f, xeq, h'⟩
rcases h a f xeq.symm with ⟨i, _, hi⟩
rw ←hi
apply h'
intros
rw [Wrepr, recF_eq', q.P.W_dest'_W_mk]; refl
rw [Wrepr, recF_eq', q.P.W_dest'_W_mk]
intros
simp only [mk_eq_div, cast_div, cast_coe_int]
intros
show rat.nonneg _ ↔ _
rw ← sub_nonneg
simp [sub_eq_add_neg, ne_of_gt b0, ne_of_gt d0, mul_pos d0 b0]
simpa only [div_eq_mul_inv, one_mul] using sub_half one_ne_top
intros
simp [ennreal.to_real]
intros
simp [ennreal.of_real]
intros
induction y using ereal.rec
{ exact (lt_irrefl _ (bot_le.trans_lt h1)).elim }
exact (lt_irrefl _ (bot_le.trans_lt h1)).elim
calc x + z ≤ y + z : add_le_add h1.le (le_refl _) ... < y + t : add_lt_add_left_coe h2 _
{ calc x + z ≤ y + z : add_le_add h1.le (le_refl _) ... < y + t : add_lt_add_left_coe h2 _ }
simp [lt_top_iff_ne_top, with_top.add_eq_top, h1.ne, (h2.trans_le le_top).ne]
{ simp [lt_top_iff_ne_top, with_top.add_eq_top, h1.ne, (h2.trans_le le_top).ne] }
rw [inv_eq_iff, ← neg_inv, neg_eq_iff_neg_eq]
exact inv_gold.symm
intros
rw [← nnreal.coe_zero, nnreal.coe_eq]
intros
simp only [div_eq_mul_inv, finset.sum_mul]
pi_lower_bound [ 11482/8119, 5401/2923, 2348/1197, 11367/5711, 25705/12868, 23235/11621]
simp [sqrt]
intros
haveI := h1.terminates; haveI := h2.terminates; rw [←h1.length, h2.length]
haveI := h1.terminates; haveI := h2.terminates
haveI := h1.terminates
haveI := h2.terminates
rw [←h1.length, h2.length]
intros
cases x with x hx; exact hf _ _ _ _ _
cases x with x hx
exact hf _ _ _ _ _
intros
ext
{ ext, simp }
simp
intros
{ ext, simp [image, range] }
ext
simp [image, range]
intros
rw [← nonempty_image_iff, hf.image_preimage]
intros
rw [← mk_preimage_prod_left_eq_if, prod_preimage_left, preimage_preimage]
intros
ext
{ ext, simp_rw [mem_univ_pi], apply forall_congr, intro i, split_ifs; simp [h] }
simp_rw [mem_univ_pi]
apply forall_congr
intro i
split_ifs
split_ifs; simp [h]
simp [h]
simp [h]
intros
simp [subset_def]
intros
contrapose! ht
exact infinite_of_inj_on_maps_to (λ x hx y hy, not_imp_not.1 (ht x hx y hy)) hf hs
intros
simp
intros
refine h.inv_on_inv_fun_on.bij_on _ (maps_to_image _ _)
rintros _ ⟨y, hy, rfl⟩
rwa [h.right_inv_on_inv_fun_on hy]
intros
simp [← Ioi_inter_Iio]
intros
ext1 x
simp_rw [mem_union, mem_Iic, mem_Icc, le_max_iff]
by_cases hc : c ≤ x
{ tauto }
tauto
have hxb : x ≤ b := (le_of_not_ge hc).trans h₁
{ have hxb : x ≤ b := (le_of_not_ge hc).trans h₁, tauto }
tauto
intros
simp [sub_eq_add_neg]
intros
simp [sub_eq_add_neg, image_comp (λ x, a + x) (λ x, -x)]
intros
simpa only [mul_comm] using preimage_mul_const_Icc_of_neg a b h
intros
simp only [interval, min_le_iff, le_max_iff, nonempty_Icc]
{ simp only [interval, min_le_iff, le_max_iff, nonempty_Icc], left, left, refl }
left
left
refl
intros
ext y
{ ext y, split; simp only [mem_Union]; rintro ⟨a, b, c, d, e⟩, exact ⟨c, a, d, b, e⟩, exact ⟨b, d, a, c, e⟩ }
split
split; simp only [mem_Union]; rintro ⟨a, b, c, d, e⟩
split; simp only [mem_Union]
simp only [mem_Union]
rintro ⟨a, b, c, d, e⟩
exact ⟨c, a, d, b, e⟩
simp only [mem_Union]
rintro ⟨a, b, c, d, e⟩
exact ⟨b, d, a, c, e⟩
intros
ext x
refine ⟨λ hx, Union_inter_subset hx, _⟩
rintro ⟨⟨_, ⟨i, rfl⟩, xs⟩, _, ⟨j, rfl⟩, xt⟩
exact ⟨_, ⟨i ⊔ j, rfl⟩, hs le_sup_left xs, ht le_sup_right xt⟩
intros
rw [←compl_compl (⋃₀ S), compl_sUnion]
intros
refl
intros
simpa only [scanl, to_list_cons]
intros
change (a : zmod b) = ((0 : ℤ) : zmod b) ↔ (b : ℤ) ∣ a
rw [zmod.int_coe_eq_int_coe_iff, int.modeq_zero_iff_dvd]
intros
rw [val_nat_cast, nat.mod_eq_of_lt h]
intros
simp [sub_eq_add_neg, hf.map_add, hf.map_neg]
intros
rw set.ext_iff; simp [ker]; exact ⟨λ h x hx, (h x).1 hx, λ h x, ⟨h x, λ hx, by rw [hx, hf.map_one]⟩⟩
rw set.ext_iff; simp [ker]
rw set.ext_iff
simp [ker]
exact ⟨λ h x hx, (h x).1 hx, λ h x, ⟨h x, λ hx, by rw [hx, hf.map_one]⟩⟩
intros
simp only [← units_coe, ← mul_apply, f.mul_inv, coe_one, id]
intros
simp_rw [is_invariant, maps_to']
intros
{ rw [is_periodic_pt, iterate_add], exact hn.comp hm }
rw [is_periodic_pt, iterate_add]
exact hn.comp hm
intros
apply adjoin_eq_algebra_adjoin
intros x hx
by_cases x = 0
rw [h, inv_zero]
{ rw [h, inv_zero], exact subalgebra.zero_mem (algebra.adjoin F {α}) }
exact subalgebra.zero_mem (algebra.adjoin F {α})
let ϕ := alg_equiv.adjoin_singleton_equiv_adjoin_root_minpoly F α
haveI := minpoly.irreducible hα
suffices : ϕ ⟨x, hx⟩ * (ϕ ⟨x, hx⟩)⁻¹ = 1
convert subtype.mem (ϕ.symm (ϕ ⟨x, hx⟩)⁻¹)
{ convert subtype.mem (ϕ.symm (ϕ ⟨x, hx⟩)⁻¹), refine (eq_inv_of_mul_right_eq_one _).symm, apply_fun ϕ.symm at this, rw [alg_equiv.map_one, alg_equiv.map_mul, alg_equiv.symm_apply_apply] at this, rw [←subsemiring.coe_one, ←this, subsemiring.coe_mul, subtype.coe_mk] }
refine (eq_inv_of_mul_right_eq_one _).symm
apply_fun ϕ.symm at this
rw [alg_equiv.map_one, alg_equiv.map_mul, alg_equiv.symm_apply_apply] at this
rw [←subsemiring.coe_one, ←this, subsemiring.coe_mul, subtype.coe_mk]
rw mul_inv_cancel (mt (λ key, _) h)
rw ← ϕ.map_zero at key
change ↑(⟨x, hx⟩ : algebra.adjoin F {α}) = _
rw [ϕ.injective key, subalgebra.coe_zero]
intros
rw [← cardinal.nat_cast_le, finrank_eq_dim]
apply dim_le_card
intros
haveI : fintype E := fintype_of_fintype F E
exact exists_primitive_element_of_fintype_top F E
intros
rw [←finset.card_range n, ←finset.prod_const]
exact splits_prod i (λ j hj, hf)
intros
rw ← sq_eq_sq (norm_nonneg (x + y)) (add_nonneg (norm_nonneg x) (norm_nonneg y))
rw [norm_add_pow_two_real, inner_eq_mul_norm_of_angle_eq_zero h]
ring
intros
split
{ exact λ h, h ▸ orthogonal_projection_mem p }
exact λ h, h ▸ orthogonal_projection_mem p
intro h
{ intro h, have hp : p ∈ ((s : set P) ∩ mk' p s.directionᗮ) := ⟨h, self_mem_mk' p _⟩, rw [inter_eq_singleton_orthogonal_projection p] at hp, symmetry, exact hp }
have hp : p ∈ ((s : set P) ∩ mk' p s.directionᗮ) := ⟨h, self_mem_mk' p _⟩
rw [inter_eq_singleton_orthogonal_projection p] at hp
symmetry
exact hp
intros
rcases exists_circumcenter_eq_of_cospherical_subset h hd hc with ⟨r, hr⟩
rw [hr sx₁ hsx₁, hr sx₂ hsx₂]
intros
rcases ho with ⟨t₀, ht₀o, ht₀s⟩
rw ht₀s at ht
rcases exists_of_range_subset_orthocentric_system ht₀o ht t.independent.injective with ⟨i₁, i₂, i₃, j₂, j₃, h₁₂, h₁₃, h₂₃, h₁₂₃, h₁, hj₂₃, h₂, h₃⟩ | hs
obtain ⟨j₁, hj₁₂, hj₁₃, hj₁₂₃⟩ : ∃ j₁ : fin 3, j₁ ≠ j₂ ∧ j₁ ≠ j₃ ∧ ∀ j : fin 3, j = j₁ ∨ j = j₂ ∨ j = j₃
{ obtain ⟨j₁, hj₁₂, hj₁₃, hj₁₂₃⟩ : ∃ j₁ : fin 3, j₁ ≠ j₂ ∧ j₁ ≠ j₃ ∧ ∀ j : fin 3, j = j₁ ∨ j = j₂ ∨ j = j₃, { clear h₂ h₃, dec_trivial! }, suffices h : t₀.points j₁ = t.orthocenter, { have hui : (set.univ : set (fin 3)) = {i₁, i₂, i₃}, { ext x, simpa using h₁₂₃ x }, have huj : (set.univ : set (fin 3)) = {j₁, j₂, j₃}, { ext x, simpa using hj₁₂₃ x }, rw [←h, ht₀s, ←set.image_univ, huj, ←set.image_univ, hui], simp_rw [set.image_insert_eq, set.image_singleton, h₁, ←h₂, ←h₃], rw set.insert_comm }, exact (triangle.orthocenter_replace_orthocenter_eq_point hj₁₂ hj₁₃ hj₂₃ h₁₂ h₁₃ h₂₃ h₁ h₂.symm h₃.symm).symm }
{ clear h₂ h₃, dec_trivial! }
clear h₂ h₃
dec_trivial!
suffices h : t₀.points j₁ = t.orthocenter
have hui : (set.univ : set (fin 3)) = {i₁, i₂, i₃}
{ have hui : (set.univ : set (fin 3)) = {i₁, i₂, i₃}, { ext x, simpa using h₁₂₃ x }, have huj : (set.univ : set (fin 3)) = {j₁, j₂, j₃}, { ext x, simpa using hj₁₂₃ x }, rw [←h, ht₀s, ←set.image_univ, huj, ←set.image_univ, hui], simp_rw [set.image_insert_eq, set.image_singleton, h₁, ←h₂, ←h₃], rw set.insert_comm }
ext x
{ ext x, simpa using h₁₂₃ x }
simpa using h₁₂₃ x
have huj : (set.univ : set (fin 3)) = {j₁, j₂, j₃}
ext x
{ ext x, simpa using hj₁₂₃ x }
simpa using hj₁₂₃ x
rw [←h, ht₀s, ←set.image_univ, huj, ←set.image_univ, hui]
simp_rw [set.image_insert_eq, set.image_singleton, h₁, ←h₂, ←h₃]
rw set.insert_comm
exact (triangle.orthocenter_replace_orthocenter_eq_point hj₁₂ hj₁₃ hj₂₃ h₁₂ h₁₃ h₂₃ h₁ h₂.symm h₃.symm).symm
rw hs
{ rw hs, convert ht₀s using 2, exact triangle.orthocenter_eq_of_range_eq hs }
convert ht₀s using 2
exact triangle.orthocenter_eq_of_range_eq hs
intros
rw ← he'.1
exact PG.congr e.open_source he'.eq_on.symm he
intros
convert hs.unique_mdiff_on_preimage (h.to_local_homeomorph_mdifferentiable hn)
simp [h.image_eq_preimage]
intros
have : s = univ ∩ s
rw univ_inter
rw univ_inter
rwa [this, hG.lift_prop_within_at_inter hs] at h
intros
rw [unique_mdiff_within_at, ext_chart_preimage_inter_eq]
exact unique_diff_within_at.inter hs (ext_chart_preimage_mem_nhds I x ht)
intros
have A : f₁ x = f x := (mem_of_mem_nhds hL : _)
rw [← mfderiv_within_univ, ← mfderiv_within_univ]
rw ← nhds_within_univ at hL
exact hL.mfderiv_within_eq (unique_mdiff_within_at_univ I) A
intros
rw [← I.map_nhds_eq, map_map, I.symm_comp_self, map_id]
intros
rw [← times_cont_mdiff_on_univ, times_cont_mdiff_on_iff_target]
simp [continuous_iff_continuous_on_univ]
intros
rw [← fintype.card_prod, fintype.card_congr (orbit_prod_stabilizer_equiv_group α b)]
intros
rw ← neg_one_smul R
{ rw ← neg_one_smul R, exact p.smul_mem _ hx }
exact p.smul_mem _ hx
intros
rw mul_comm; convert units.inv_mul_eq_iff_eq_mul _; exact (is_unit.coe_lift_right (f.mrestrict S) h _).symm
rw mul_comm; convert units.inv_mul_eq_iff_eq_mul _
rw mul_comm
convert units.inv_mul_eq_iff_eq_mul _
exact (is_unit.coe_lift_right (f.mrestrict S) h _).symm
intros
rw [←f.lift_of_comp j, ←f.lift_of_comp k]
congr' 1 with x
exact h x
intros
induction n with d hd
{ simp }
simp
rintros _ ⟨x, hx : x ∈ upper_central_series G d.succ, rfl⟩ y'
{ rintros _ ⟨x, hx : x ∈ upper_central_series G d.succ, rfl⟩ y', rcases (h y') with ⟨y, rfl⟩, simpa using hd (mem_map_of_mem f (hx y)) }
rcases (h y') with ⟨y, rfl⟩
simpa using hd (mem_map_of_mem f (hx y))
intros
refine (H ⊓ K).eq_bot_iff_forall.mpr (λ x hx, _)
rw [←order_of_eq_one_iff, ←nat.dvd_one, ←h.gcd_eq_one, nat.dvd_gcd_iff]
exact ⟨(congr_arg (∣ fintype.card H) (order_of_subgroup ⟨x, hx.1⟩)).mpr order_of_dvd_card_univ, (congr_arg (∣ fintype.card K) (order_of_subgroup ⟨x, hx.2⟩)).mpr order_of_dvd_card_univ⟩
intros
rw disjoint_iff_disjoint_support at h
intros x hx
simp only [mem_cycle_factors_finset_iff, inf_eq_inter, mem_inter, mem_support] at hx
obtain ⟨⟨⟨a, ha, -⟩, hf⟩, -, hg⟩ := hx
refine h (_ : a ∈ f.support ∩ g.support)
simp [ha, ←hf a ha, ←hg a ha]
intros
obtain ⟨x, y, hxy, rfl⟩ := hf
exact is_cycle_swap hxy
intros
cases n
{ rcases j with ⟨_, ⟨⟩⟩ }
rcases j with ⟨_, ⟨⟩⟩
rcases lt_trichotomy j i with hlt | heq | hgt
have : (j + 1).cast_succ = j.succ
{ have : (j + 1).cast_succ = j.succ, { ext, rw [coe_cast_succ, coe_succ, fin.coe_add_one_of_lt (lt_of_lt_of_le hlt i.le_last)] }, rw [fin.cycle_range_of_lt hlt, fin.succ_above_below, this, swap_apply_of_ne_of_ne], { apply fin.succ_ne_zero }, { exact (fin.succ_injective _).ne hlt.ne }, { rw fin.lt_iff_coe_lt_coe, simpa [this] using hlt } }
ext
{ ext, rw [coe_cast_succ, coe_succ, fin.coe_add_one_of_lt (lt_of_lt_of_le hlt i.le_last)] }
rw [coe_cast_succ, coe_succ, fin.coe_add_one_of_lt (lt_of_lt_of_le hlt i.le_last)]
rw [fin.cycle_range_of_lt hlt, fin.succ_above_below, this, swap_apply_of_ne_of_ne]
{ apply fin.succ_ne_zero }
apply fin.succ_ne_zero
{ exact (fin.succ_injective _).ne hlt.ne }
exact (fin.succ_injective _).ne hlt.ne
rw fin.lt_iff_coe_lt_coe
{ rw fin.lt_iff_coe_lt_coe, simpa [this] using hlt }
simpa [this] using hlt
rw [heq, fin.cycle_range_self, fin.succ_above_below, swap_apply_right, fin.cast_succ_zero]
{ rw [heq, fin.cycle_range_self, fin.succ_above_below, swap_apply_right, fin.cast_succ_zero], { rw fin.cast_succ_zero, apply fin.succ_pos } }
{ rw fin.cast_succ_zero, apply fin.succ_pos }
rw fin.cast_succ_zero
apply fin.succ_pos
rw [fin.cycle_range_of_gt hgt, fin.succ_above_above, swap_apply_of_ne_of_ne]
{ rw [fin.cycle_range_of_gt hgt, fin.succ_above_above, swap_apply_of_ne_of_ne], { apply fin.succ_ne_zero }, { apply (fin.succ_injective _).ne hgt.ne.symm }, { simpa [fin.le_iff_coe_le_coe] using hgt } }
{ apply fin.succ_ne_zero }
apply fin.succ_ne_zero
{ apply (fin.succ_injective _).ne hgt.ne.symm }
apply (fin.succ_injective _).ne hgt.ne.symm
{ simpa [fin.le_iff_coe_le_coe] using hgt }
simpa [fin.le_iff_coe_le_coe] using hgt
intros
cases l with hd tl
{ simp }
simp
rw ←form_perm_apply_mem_eq_self_iff _ hl hd (mem_cons_self _ _)
{ rw ←form_perm_apply_mem_eq_self_iff _ hl hd (mem_cons_self _ _), split, { simp {contextual := tt} }, { intro h, simp only [(hd :: tl).form_perm_apply_mem_eq_self_iff hl hd (mem_cons_self hd tl), add_le_iff_nonpos_left, length, nonpos_iff_eq_zero, length_eq_zero] at h, simp [h] } }
split
{ simp {contextual := tt} }
simp {contextual := tt}
intro h
{ intro h, simp only [(hd :: tl).form_perm_apply_mem_eq_self_iff hl hd (mem_cons_self hd tl), add_le_iff_nonpos_left, length, nonpos_iff_eq_zero, length_eq_zero] at h, simp [h] }
simp only [(hd :: tl).form_perm_apply_mem_eq_self_iff hl hd (mem_cons_self hd tl), add_le_iff_nonpos_left, length, nonpos_iff_eq_zero, length_eq_zero] at h
simp [h]
intros
rw [le_iff_lt_or_eq, nat.lt_succ_iff, nat.le_zero_iff, card_support_eq_zero, or_iff_not_imp_right, imp_iff_right f.card_support_ne_one]
intros
ext
ext; simp [right_hom]
simp [right_hom]
intros
rw [←comap_bot, ←comap_bot, ←comap_bot, ←prod_map_comap_prod, bot_prod_bot]
intros
simp only [infi, coe_Inf, set.bInter_range]
intros
simp [line_map_apply]
intros
simp_rw [weighted_vsub_of_point_apply]
exact finset.sum_map _ _ _
intros
cases s1
cases s2
congr' with i
exact h i
intros
rw [map_le_line_map_iff_slope_le_slope_left (mul_pos h₀ (sub_pos.2 hab)), ← line_map_slope_line_map_slope_line_map f a b r, right_le_line_map_iff_le h₁]
apply_instance
apply_instance
apply_instance
apply_instance
intros
rw [range_le_iff_comap]; exact ker_eq_top
rw [range_le_iff_comap]
exact ker_eq_top
intros
conv_rhs { rw ← b.total_repr u }
simp [finsupp.total_apply, finsupp.sum_fintype, b.equiv_fun_apply]
intros
erw mem_pair_self_adjoint_matrices_submodule
simp [matrix.is_skew_adjoint, matrix.is_adjoint_pair]
intros
{ ext, refl }
ext
refl
intros
dsimp [module.rank]
apply cardinal.lift_sup_le
rintro ⟨s, li⟩
apply le_trans
swap 2
apply cardinal.lift_le.mpr
refine (cardinal.le_sup _ ⟨range_splitting f '' s, _⟩)
apply linear_independent.of_comp f.range_restrict
{ apply linear_independent.of_comp f.range_restrict, convert li.comp (equiv.set.range_splitting_image_equiv f s) (equiv.injective _) using 1, }
convert li.comp (equiv.set.range_splitting_image_equiv f s) (equiv.injective _) using 1
exact (cardinal.lift_mk_eq'.mpr ⟨equiv.set.range_splitting_image_equiv f s⟩).ge
{ exact (cardinal.lift_mk_eq'.mpr ⟨equiv.set.range_splitting_image_equiv f s⟩).ge, }
intros
rw [basis.equiv_fun_apply, dual_basis_repr]
intros
rw polynomial.eq_C_of_degree_eq_zero (degree_coe_units c)
simp only [aeval_def, eval₂_C]
apply ker_algebra_map_End
apply coeff_coe_units_zero_ne_zero c
intros
rw [←alg_hom.map_mul, ι_sq_zero, alg_hom.map_zero]
intros
rw [set.range_unique, basis_singleton_apply]
intros
{ ext i, apply fin_zero_elim i }
ext i
apply fin_zero_elim i
intros
rw [linear_map.submodule_image, linear_map.range_comp, range_of_le]
intros
rw [disjoint, ← set.image_univ, finsupp.span_image_eq_map_total, map_inf_eq_map_inf_comap, map_le_iff_le_comap, comap_bot, finsupp.supported_univ, top_inf_eq] at hf_inj
unfold linear_independent at hv ⊢
rw [hv, le_bot_iff] at hf_inj
haveI : inhabited M := ⟨0⟩
rw [finsupp.total_comp, @finsupp.lmap_domain_total _ _ R _ _ _ _ _ _ _ _ _ _ f, linear_map.ker_comp, hf_inj]
exact λ _, rfl
intros
rw [basis_to_matrix_mul_linear_map_to_matrix, linear_map_to_matrix_mul_basis_to_matrix]
intros
rw [polynomial.eval, ← coe_eval₂_ring_hom, ring_hom.map_det]
apply congr_arg det
ext
symmetry
convert mat_poly_equiv_eval _ _ _ _
intros
ext j
ext j; simp [mul_vec_diagonal]
simp [mul_vec_diagonal]
intros
{ ext, simp [matrix.one_apply, std_basis_apply] }
ext
simp [matrix.one_apply, std_basis_apply]
intros
rw [left_mul_matrix_apply, to_matrix_lmul' b x i j]
intros
obtain ⟨i, _⟩ : ∃i:ι, i ∈ set.univ := set.exists_mem_of_nonempty ι
exact map_coord_zero f i rfl
intros
have : z = z • (1 : R) := by simp only [mul_one, algebra.id.smul_eq_mul]
conv_lhs { rw this }
rw ←smul_tprod_coeff'
refl
intros
simp [disjoint_def, @eq_comm M 0, @eq_comm M₂ 0] {contextual := tt}
simp [disjoint_def, @eq_comm M 0, @eq_comm M₂ 0] {contextual := tt}; intros; refl
simp [disjoint_def, @eq_comm M 0, @eq_comm M₂ 0] {contextual := tt}; intros
intros
simp [tailings]
intros
rw [←neg_one_smul R x, polar_smul_left, neg_one_mul]
intros
{ rw g.det_coe, norm_num }
rw g.det_coe
norm_num
intros
simp [xor]
intros
simp [@eq_comm _ a']
intros
{ rw [← and_forall_ne a, update_same], simp { contextual := tt } }
rw [← and_forall_ne a, update_same]
simp { contextual := tt }
intros
refine is_compact.induction_on h _ _ _ _
{ use ∅, simp [superset] }
use ∅
simp [superset]
rintro s t hst ⟨U, htU, hUo, hU⟩
{ rintro s t hst ⟨U, htU, hUo, hU⟩, exact ⟨U, hst.trans htU, hUo, hU⟩ }
exact ⟨U, hst.trans htU, hUo, hU⟩
rintro s t ⟨U, hsU, hUo, hU⟩ ⟨V, htV, hVo, hV⟩
{ rintro s t ⟨U, hsU, hUo, hU⟩ ⟨V, htV, hVo, hV⟩, refine ⟨U ∪ V, union_subset_union hsU htV, hUo.union hVo, (measure_union_le _ _).trans_lt $ ennreal.add_lt_top.2 ⟨hU, hV⟩⟩ }
refine ⟨U ∪ V, union_subset_union hsU htV, hUo.union hVo, (measure_union_le _ _).trans_lt $ ennreal.add_lt_top.2 ⟨hU, hV⟩⟩
intros x hx
{ intros x hx, rcases (hμ x hx).exists_mem_basis (nhds_basis_opens _) with ⟨U, ⟨hx, hUo⟩, hU⟩, exact ⟨U, nhds_within_le_nhds (hUo.mem_nhds hx), U, subset.rfl, hUo, hU⟩ }
rcases (hμ x hx).exists_mem_basis (nhds_basis_opens _) with ⟨U, ⟨hx, hUo⟩, hU⟩
exact ⟨U, nhds_within_le_nhds (hUo.mem_nhds hx), U, subset.rfl, hUo, hU⟩
intros
{ rw [real_smul_def, ← smul_neg_part, dif_pos hr] }
rw [real_smul_def, ← smul_neg_part, dif_pos hr]
intros
let s := dense_seq E
have hs : dense_range s := dense_range_dense_seq E
have hf' : ∀ᵐ x ∂μ, ∀ n : ℕ, inner (s n) (f x) = (0 : 𝕜)
from ae_all_iff.mpr (λ n, hf (s n))
refine hf'.mono (λ x hx, _)
rw [pi.zero_apply, ← inner_self_eq_zero]
have h_closed : is_closed {c : E | inner c (f x) = (0 : 𝕜)}
from is_closed_eq (continuous_id.inner continuous_const) continuous_const
exact @is_closed_property ℕ E _ s (λ c, inner c (f x) = (0 : 𝕜)) hs h_closed (λ n, hx n) _
intros
haveI : normed_space ℝ E := restrict_scalars.normed_space ℝ 𝕜 E
rw dense_range_iff_closure_range
suffices : (to_Lp p μ 𝕜 : _ →L[𝕜] Lp E p μ).range.to_add_subgroup.topological_closure = ⊤
{ exact congr_arg coe this }
exact congr_arg coe this
simp [range_to_Lp p μ, measure_theory.Lp.bounded_continuous_function_dense E hp]
intros
simp [integrable, hg, hg.comp_measurable hf, has_finite_integral, lintegral_map' hg.ennnorm hf]
intros
have : ∀ x, ∥is_R_or_C.re (f x)∥ ≤ 1 * ∥f x∥
intro x
intro x
{ intro x, rw one_mul, exact is_R_or_C.norm_re_le_norm (f x), }
{ intro x, rw one_mul, exact is_R_or_C.norm_re_le_norm (f x), }
rw one_mul
rw one_mul
exact is_R_or_C.norm_re_le_norm (f x)
exact is_R_or_C.norm_re_le_norm (f x)
exact hf.of_le_mul hf.1.re (eventually_of_forall this)
intros
rw neg_part
filter_upwards [coe_fn_pos_part (-f), coe_fn_neg f]
assume a h₁ h₂
rw [h₁, h₂, pi.neg_apply]
intros
simp [snorm', hq_neg]
intros
rw [snorm'_congr_ae hf_zero, snorm'_zero hq0_lt]
intros
by_cases hf : integrable (λ a, (f a : ℝ)) μ
{ exact (lintegral_coe_le_coe_iff_integral_le hf).1 h }
exact (lintegral_coe_le_coe_iff_integral_le hf).1 h
{ rw integral_undef hf, exact b.2 }
rw integral_undef hf
exact b.2
intros
{ ext1 x, rw [weighted_smul_apply], simp, }
ext1 x
rw [weighted_smul_apply]
simp
intros
simpa only [← integral_symm] using (integral_has_strict_deriv_at_right hf.symm hmeas ha).neg
intros
rw [count, lintegral_sum_measure]
congr
exact funext (λ a, lintegral_dirac' a hf)
intros
rw f.support_eq
{ rw f.support_eq, exact finset.measurable_set_bUnion _ (λ y hy, measurable_set_fiber _ _), }
exact finset.measurable_set_bUnion _ (λ y hy, measurable_set_fiber _ _)
intros
refine integral_eq_zero_of_ae _
rw [eventually_eq, ae_restrict_iff (measurable_set_eq_fun hf measurable_zero)]
refine eventually_of_forall (λ x hx, _)
rw pi.zero_apply
exact ht_eq x hx
intros
rw [content.outer_measure, induced_outer_measure_eq_infi]
exact le_infi (λ U, le_infi $ λ hU, le_infi $ μ.le_inner_content K ⟨U, hU⟩)
{ exact le_infi (λ U, le_infi $ λ hU, le_infi $ μ.le_inner_content K ⟨U, hU⟩) }
{ exact μ.inner_content_Union_nat }
exact μ.inner_content_Union_nat
{ exact μ.inner_content_mono }
exact μ.inner_content_mono
intros
simp only [lintegral_eq_supr_eapprox_lintegral, hf, simple_func.lintegral]
refine measurable_supr (λ n, finset.measurable_sum _ (λ i _, _))
refine measurable.const_mul _ _
exact measurable_coe ((simple_func.eapprox f n).measurable_set_preimage _)
intros
apply ennreal.zero_lt_one.trans_le
rw [content.outer_measure_eq_infi]
refine le_binfi _
intros U hU
refine le_infi _
intros h2U
refine le_trans (le_of_eq _) (le_bsupr ⟨K₀.1, K₀.2.1⟩ h2U)
exact haar_content_self.symm
intros
rw [← e.image_symm, e.symm.hausdorff_measure_image]
intros
simpa using (map_eq_sum μ id measurable_id).symm
intros
rw [← measure_univ_eq_zero, restrict_apply_univ]
intros
split
{ rintro rfl _ _, refl }
rintro rfl _ _
refl
rw ext_iff'
{ rw ext_iff', intros h i, by_cases hi : measurable_set i, { exact h i hi }, { simp_rw [not_measurable _ hi] } }
intros h i
by_cases hi : measurable_set i
{ exact h i hi }
exact h i hi
{ simp_rw [not_measurable _ hi] }
simp_rw [not_measurable _ hi]
intros
refine measure_theory.vector_measure.ext (λ i hi, _)
rw [to_ennreal_vector_measure_apply_measurable hi, add_apply, vector_measure.add_apply, to_ennreal_vector_measure_apply_measurable hi, to_ennreal_vector_measure_apply_measurable hi]
intros
intros s hs
by_cases hmeas : measurable_set s
{ exact h hmeas hs }
exact h hmeas hs
{ exact not_measurable v hmeas }
exact not_measurable v hmeas
intros
ext1 b
simp only [ennreal.coe_eq_coe.symm, coe_bind_apply, ennreal.tsum_mul_left.symm, ennreal.tsum_mul_right.symm]
rw [ennreal.tsum_comm]
simp [mul_assoc, mul_left_comm, mul_comm]
intros
split
split; intro h
intro h
contrapose! h
{ contrapose! h, simp [h] }
simp [h]
intro h
{ simp [h, pow_ne_zero] }
simp [h, pow_ne_zero]
intros
let e := fintype.equiv_fin ι
obtain ⟨t, ht⟩ := h.exists_partition' (fintype.card ι) hε hb (A ∘ e.symm)
refine ⟨t ∘ e, λ i₀ i₁ h, _⟩
convert ht (e i₀) (e i₁) h; simp only [e.symm_apply_apply]
convert ht (e i₀) (e i₁) h
simp only [e.symm_apply_apply]
simp only [e.symm_apply_apply]
intros
cases n
{ simp }
simp
rw [divisors_eq_proper_divisors_insert_self_of_pos (nat.succ_pos _), finset.sum_insert (proper_divisors.not_self_mem), add_comm]
{ rw [divisors_eq_proper_divisors_insert_self_of_pos (nat.succ_pos _), finset.sum_insert (proper_divisors.not_self_mem), add_comm] }
intros
simp [norm_def]
intros
simp only [padic.cast_eq_of_rat]
change ∃ N, ∀ i ≥ N, (f - const _ (f i)).norm < ε
by_contradiction h
cases cauchy₂ f hε with N hN
have : ∀ N, ∃ i ≥ N, ε ≤ (f - const _ (f i)).norm
simpa only [not_forall, not_exists, not_lt] using h
simpa only [not_forall, not_exists, not_lt] using h
rcases this N with ⟨i, hi, hge⟩
have hne : ¬ (f - const (padic_norm p) (f i)) ≈ 0
intro h
{ intro h, unfold padic_seq.norm at hge; split_ifs at hge, exact not_lt_of_ge hge hε }
unfold padic_seq.norm at hge
unfold padic_seq.norm at hge; split_ifs at hge
split_ifs at hge
exact not_lt_of_ge hge hε
unfold padic_seq.norm at hge; split_ifs at hge
unfold padic_seq.norm at hge
split_ifs at hge
apply not_le_of_gt _ hge
cases decidable.em (N ≤ stationary_point hne) with hgen hngen
apply hN; assumption
{ apply hN; assumption }
apply hN
assumption
assumption
have := stationary_point_spec hne (le_refl _) (le_of_not_le hngen)
{ have := stationary_point_spec hne (le_refl _) (le_of_not_le hngen), rw ←this, apply hN, apply le_refl, assumption }
rw ←this
apply hN
apply le_refl
assumption
intros
rw [ideal.mem_span_singleton] at ha hb
rw [← sub_eq_zero, ← int.cast_sub, zmod.int_coe_zmod_eq_zero_iff_dvd, int.coe_nat_pow]
rw [← dvd_neg, neg_sub] at ha
have := dvd_add ha hb
rwa [sub_eq_add_neg, sub_eq_add_neg, add_assoc, neg_add_cancel_left, ← sub_eq_add_neg, ← int.cast_sub, pow_p_dvd_int_iff] at this
intros
simp [ext]
intros
rw [sdiff_eq, top_inf_eq]
intros
{ cases x, simpa using h, refl, }
cases x
simpa using h
refl
intros
rw [supr, subtype.range_coe]
intros
obtain ⟨c, hct⟩ : ∃ c, c ∈ t := ht
obtain ⟨B, hB⟩ : ∃ B, B ∈ lower_bounds t := h_bdd
refine hs.out B.2 c.2 ⟨_, _⟩
{ exact (subtype.mono_coe s).le_cInf_image ⟨c, hct⟩ hB }
exact (subtype.mono_coe s).le_cInf_image ⟨c, hct⟩ hB
{ exact (subtype.mono_coe s).cInf_image_le hct ⟨B, hB⟩ }
exact (subtype.mono_coe s).cInf_image_le hct ⟨B, hB⟩
intros
haveI := hne.to_subtype
{ haveI := hne.to_subtype, rw image_eq_range at hf, exact gc.l_csupr hf }
rw image_eq_range at hf
exact gc.l_csupr hf
intros
rw [← map_coe_Ioi_at_top a, tendsto_map'_iff]
intros
refine not_iff_not.1 ((inf_principal_ne_bot_iff.trans _).symm.trans ne_bot_iff)
exact ⟨λ h hs, by simpa [empty_not_nonempty] using h s hs, λ hs t ht, inter_compl_nonempty_iff.2 $ λ hts, hs $ mem_of_superset ht hts⟩
intros
simp only [filter.frequently, not_not]
intros
classical
erw [← not_iff_not, not_not, not_not, filter.eventually_comap]
simp only [not_exists, not_and]
intros
simp [comap_eval_ne_bot_iff', *]
intros
refine ((comap_mono $ map_le_iff_le_comap.1 hψ).trans _).antisymm (map_le_iff_le_comap.1 hφ)
rw [comap_comap, eq, comap_id]
exact le_rfl
intros
simp only [tendsto_def, mem_prod_iff, prod_sub_preimage_iff, exists_prop, iff_self]
intros
rw [← infi_sets_eq_finite, ← equiv.plift.surjective.infi_comp]
{ rw [← infi_sets_eq_finite, ← equiv.plift.surjective.infi_comp], refl }
refl
ext s
simp only [mem_cofinite, mem_at_top_sets]
split
assume hs
{ assume hs, use (hs.to_finset.sup id) + 1, assume b hb, by_contradiction hbs, have := hs.to_finset.subset_range_sup_succ (hs.mem_to_finset.2 hbs), exact not_lt_of_le hb (finset.mem_range.1 this) }
use (hs.to_finset.sup id) + 1
assume b hb
by_contradiction hbs
have := hs.to_finset.subset_range_sup_succ (hs.mem_to_finset.2 hbs)
exact not_lt_of_le hb (finset.mem_range.1 this)
rintros ⟨N, hN⟩
{ rintros ⟨N, hN⟩, apply (finite_lt_nat N).subset, assume n hn, change n < N, exact lt_of_not_ge (λ hn', hn $ hN n hn') }
apply (finite_lt_nat N).subset
assume n hn
change n < N
exact lt_of_not_ge (λ hn', hn $ hN n hn')
intros
ext t
simp only [pfun.core_res, mem_pmap, mem_map, mem_inf_principal, imp_iff_not_or]
refl
intros
apply le_antisymm; simp
apply le_antisymm
simp
simp
intros
rw [disjoint.comm, sup_comm]
apply disjoint.disjoint_sup_right_of_disjoint_sup_left h.symm
rwa [sup_comm, disjoint.comm] at hsup
intros
rw [forall_swap,forall_forall_merge]
intros
induction n with n ih
{ cases h, apply le_refl, }
cases h
apply le_refl
cases h with h h
{ cases h with h h, { exact le_sup_right, }, { exact (ih h).trans le_sup_left, } }
{ exact le_sup_right, }
exact le_sup_right
{ exact (ih h).trans le_sup_left, }
exact (ih h).trans le_sup_left
intros
rw [← e.map_rel_iff, e.apply_symm_apply]
intros
rw symm_diff_eq_sup_sdiff_inf
exact (ha.sup_left hb).disjoint_sdiff_left
intros
{ rw add_comm, exact h.add_mul_left_right z }
rw add_comm
exact h.add_mul_left_right z
intros
simp_rw [irreducible_iff_uniformizer]
{simp_rw [irreducible_iff_uniformizer], exact (is_principal_ideal_ring.principal $ maximal_ideal R).principal}
exact (is_principal_ideal_ring.principal $ maximal_ideal R).principal
intros
{ rw div_nonzero h, exact submodule.mem_div_iff_forall_mul_mem }
rw div_nonzero h
exact submodule.mem_div_iff_forall_mul_mem
intros
ext g
simp only [hsum_coeff, add_coeff, add_apply]
exact finsum_add_distrib (s.finite_co_support _) (t.finite_co_support _)
intros
refine trans (ideal_prod_eq _) _
simp [map_map]
intros
suffices : is_integral R (show S, from ⟨x, hx⟩)
{ rcases this with ⟨p, hpm, hpx⟩, replace hpx := congr_arg S.val hpx, refine ⟨p, hpm, eq.trans _ hpx⟩, simp only [aeval_def, eval₂, sum_def], rw S.val.map_sum, refine finset.sum_congr rfl (λ n hn, _), rw [S.val.map_mul, S.val.map_pow, S.val.commutes, S.val_apply, subtype.coe_mk], }
rcases this with ⟨p, hpm, hpx⟩
replace hpx := congr_arg S.val hpx
refine ⟨p, hpm, eq.trans _ hpx⟩
simp only [aeval_def, eval₂, sum_def]
rw S.val.map_sum
refine finset.sum_congr rfl (λ n hn, _)
rw [S.val.map_mul, S.val.map_pow, S.val.commutes, S.val_apply, subtype.coe_mk]
refine is_integral_of_noetherian H ⟨x, hx⟩
intros
let leval : (polynomial R →ₗ[R] A) := (aeval x).to_linear_map
let D : ℕ → submodule R A := λ n, (degree_le R n).map leval
let M := well_founded.min (is_noetherian_iff_well_founded.1 H) (set.range D) ⟨_, ⟨0, rfl⟩⟩
have HM : M ∈ set.range D := well_founded.min_mem _ _ _
cases HM with N HN
have HM : ¬M < D (N+1) := well_founded.not_lt_min (is_noetherian_iff_well_founded.1 H) (set.range D) _ ⟨N+1, rfl⟩
rw ← HN at HM
have HN2 : D (N+1) ≤ D N := classical.by_contradiction (λ H, HM (lt_of_le_not_le (map_mono (degree_le_mono (with_bot.coe_le_coe.2 (nat.le_succ N)))) H))
have HN3 : leval (X^(N+1)) ∈ D N
exact HN2 (mem_map_of_mem (mem_degree_le.2 (degree_X_pow_le _)))
{ exact HN2 (mem_map_of_mem (mem_degree_le.2 (degree_X_pow_le _))) }
rcases HN3 with ⟨p, hdp, hpe⟩
refine ⟨X^(N+1) - p, monic_X_pow_sub (mem_degree_le.1 hdp), _⟩
show leval (X ^ (N + 1) - p) = 0
rw [linear_map.map_sub, hpe, sub_self]
intros
cases mem_jacobson_iff.1 h 1 with s hs
use s
simpa [sub_mul] using hs
intros
intro x
by_cases triv : (1 : R) = 0
have : (1 : Rₘ) = 0 := by convert congr_arg (algebra_map R Rₘ) triv; simp
{ have : (1 : Rₘ) = 0 := by convert congr_arg (algebra_map R Rₘ) triv; simp, exact ⟨0, ⟨trans leading_coeff_zero this.symm, eval₂_zero _ _⟩⟩ }
exact ⟨0, ⟨trans leading_coeff_zero this.symm, eval₂_zero _ _⟩⟩
haveI : nontrivial R := nontrivial_of_ne 1 0 triv
{ haveI : nontrivial R := nontrivial_of_ne 1 0 triv, obtain ⟨⟨s, ⟨u, hu⟩⟩, hx⟩ := surj (algebra.algebra_map_submonoid S M) x, obtain ⟨v, hv⟩ := hu, obtain ⟨v', hv'⟩ := is_unit_iff_exists_inv'.1 (map_units Rₘ ⟨v, hv.1⟩), refine @is_integral_of_is_integral_mul_unit Rₘ _ _ _ (localization_algebra M S) x (algebra_map S Sₘ u) v' _ _, { replace hv' := congr_arg (@algebra_map Rₘ Sₘ _ _ (localization_algebra M S)) hv', rw [ring_hom.map_mul, ring_hom.map_one, ← ring_hom.comp_apply _ (algebra_map R Rₘ)] at hv', erw is_localization.map_comp at hv', exact hv.2 ▸ hv' }, { obtain ⟨p, hp⟩ := H s, exact hx.symm ▸ is_integral_localization_at_leading_coeff p hp.2 (hp.1.symm ▸ M.one_mem) } }
obtain ⟨⟨s, ⟨u, hu⟩⟩, hx⟩ := surj (algebra.algebra_map_submonoid S M) x
obtain ⟨v, hv⟩ := hu
obtain ⟨v', hv'⟩ := is_unit_iff_exists_inv'.1 (map_units Rₘ ⟨v, hv.1⟩)
refine @is_integral_of_is_integral_mul_unit Rₘ _ _ _ (localization_algebra M S) x (algebra_map S Sₘ u) v' _ _
replace hv' := congr_arg (@algebra_map Rₘ Sₘ _ _ (localization_algebra M S)) hv'
{ replace hv' := congr_arg (@algebra_map Rₘ Sₘ _ _ (localization_algebra M S)) hv', rw [ring_hom.map_mul, ring_hom.map_one, ← ring_hom.comp_apply _ (algebra_map R Rₘ)] at hv', erw is_localization.map_comp at hv', exact hv.2 ▸ hv' }
rw [ring_hom.map_mul, ring_hom.map_one, ← ring_hom.comp_apply _ (algebra_map R Rₘ)] at hv'
erw is_localization.map_comp at hv'
exact hv.2 ▸ hv'
obtain ⟨p, hp⟩ := H s
{ obtain ⟨p, hp⟩ := H s, exact hx.symm ▸ is_integral_localization_at_leading_coeff p hp.2 (hp.1.symm ▸ M.one_mem) }
exact hx.symm ▸ is_integral_localization_at_leading_coeff p hp.2 (hp.1.symm ▸ M.one_mem)
intros
simp [inv_fun,finset.mul_sum]
intros
rw fg_def
split
rintros ⟨S, Sfin, hS⟩
{ rintros ⟨S, Sfin, hS⟩, obtain ⟨n, f, rfl⟩ := Sfin.fin_embedding, exact ⟨n, f, hS⟩, }
obtain ⟨n, f, rfl⟩ := Sfin.fin_embedding
exact ⟨n, f, hS⟩
rintros ⟨n, s, hs⟩
{ rintros ⟨n, s, hs⟩, refine ⟨range s, finite_range s, hs⟩ }
refine ⟨range s, finite_range s, hs⟩
intros
conv { congr, congr, skip, funext, dsimp [bernstein_polynomial], rw [mul_assoc, mul_comm], }
rw ←add_pow
simp
intros
by_cases h : p = 0
{ simp [h] }
simp [h]
rw [← leading_coeff_eq_zero, leading_coeff, ← ne.def, ← mem_support_iff] at h
rw [content, ← finset.insert_erase h, finset.gcd_insert, leading_coeff, content, erase_lead_support]
refine congr rfl (finset.gcd_congr rfl (λ i hi, _))
rw finset.mem_erase at hi
rw [erase_lead_coeff, if_neg hi.1]
intros
rw [← dickson_one_one_mul, mul_comm, dickson_one_one_mul]
intros
induction n with n ih
simp only [nat.nat_zero_eq_zero, pochhammer_zero, eval_one]
{ simp only [nat.nat_zero_eq_zero, pochhammer_zero, eval_one], exact zero_lt_one, }
exact zero_lt_one
rw [pochhammer_succ_right, mul_add, eval_add, ←nat.cast_comm, eval_nat_cast_mul, eval_mul_X, nat.cast_comm, ←mul_add]
{ rw [pochhammer_succ_right, mul_add, eval_add, ←nat.cast_comm, eval_nat_cast_mul, eval_mul_X, nat.cast_comm, ←mul_add], exact mul_pos ih (lt_of_lt_of_le h ((le_add_iff_nonneg_right _).mpr (nat.cast_nonneg n))), }
exact mul_pos ih (lt_of_lt_of_le h ((le_add_iff_nonneg_right _).mpr (nat.cast_nonneg n)))
intros
{ intro, rw rename_esymm }
intro
rw rename_esymm
intros
unfold minpoly_gen
rw degree_sub_eq_left_of_degree_lt; rw degree_X_pow
rw degree_sub_eq_left_of_degree_lt
rw degree_X_pow
rw degree_X_pow
apply degree_sum_fin_lt
intros
ext
{ ext, simp only [ring_hom.id_apply, rescale, one_pow, coeff_mk, one_mul, ring_hom.coe_mk], }
simp only [ring_hom.id_apply, rescale, one_pow, coeff_mk, one_mul, ring_hom.coe_mk]
intros
simpa only [nat.cast_one] using order_monomial_of_ne_zero 1 (1:R) one_ne_zero
intros
change (mv_power_series.map σ (algebra_map R A)).comp (C σ R) r = _
simp
intros
ext
{ ext, simp [cos, apply_ite f] }
simp [cos, apply_ite f]
intros
apply tensor_product.induction_on x; simp {contextual := tt}
apply tensor_product.induction_on x
simp {contextual := tt}
simp {contextual := tt}
simp {contextual := tt}
intros
ext
{ ext, rw [trace_form_to_matrix, pow_add, h.basis_eq_pow, h.basis_eq_pow] }
rw [trace_form_to_matrix, pow_add, h.basis_eq_pow, h.basis_eq_pow]
intros
{ dunfold count, split_ifs, refl }
dunfold count
split_ifs
refl
intros
simpa only [le_antisymm_iff] using and_congr (h r s) (h s r)
intros
rw [frobenius_poly, ring_hom.map_add, ring_hom.map_pow, ring_hom.map_mul, map_X, map_C]
simp only [int.cast_coe_nat, add_zero, ring_hom.eq_int_cast, zmod.nat_cast_self, zero_mul, C_0]
intros
obtain ⟨φ, hf⟩ := hf
unfreezingI {obtain ⟨φ, hf⟩ := hf}
refine ⟨⟨λ n, bind₁ (uncurry ![X, X]) (φ n), _⟩⟩
intros
funext n
simp only [hf, peval, uncurry, aeval_bind₁]
apply eval₂_hom_congr rfl _ rfl
ext ⟨i, k⟩
fin_cases i
fin_cases i; simp only [matrix.head_cons, aeval_X, matrix.cons_val_zero, matrix.cons_val_one]
simp only [matrix.head_cons, aeval_X, matrix.cons_val_zero, matrix.cons_val_one]
simp only [matrix.head_cons, aeval_X, matrix.cons_val_zero, matrix.cons_val_one]
intros
cases n
simp only [verschiebung_poly, verschiebung_fun_coeff_zero, if_pos rfl, alg_hom.map_zero]
{ simp only [verschiebung_poly, verschiebung_fun_coeff_zero, if_pos rfl, alg_hom.map_zero] }
rw [verschiebung_poly, verschiebung_fun_coeff_succ, if_neg (n.succ_ne_zero), aeval_X, nat.succ_eq_add_one, nat.add_sub_cancel]
{ rw [verschiebung_poly, verschiebung_fun_coeff_succ, if_neg (n.succ_ne_zero), aeval_X, nat.succ_eq_add_one, nat.add_sub_cancel] }
intros
cases min_eq _ _ with s e; rw [succ, e]; exact s.2
cases min_eq _ _ with s e; rw [succ, e]
cases min_eq _ _ with s e
rw [succ, e]
exact s.2
intros
refine lt_succ.1 (lt_of_not_ge $ λ hn, _)
rw [← cardinal.nat_succ, ← cardinal.lift_mk_fin n.succ] at hn
cases hn with f
refine not_lt_of_le (H $ finset.univ.map f) _
rw [finset.card_map, ← fintype.card, fintype.card_ulift, fintype.card_fin]
exact n.lt_succ_self
intros
induction s with _ a a' l l' e m s IH
cases h
{cases h}
simp at h
rcases h with rfl|h
exacts [⟨_, m, e⟩, IH h]
intros
cases e : split' o with a n
rw split_eq_scale_split' e at h
injection h
subst o'
cases NF_repr_split' e
resetI
simp
intros
{ cases x, cases y, refl, }
cases x
cases y
refl
intros
rw ← h
rw ← h; simp
simp
intros
simp [h.symm, horner]; cc
simp [h.symm, horner]
cc
intros
cases xs; unfold_wf; linarith
cases xs; unfold_wf
cases xs
unfold_wf
unfold_wf
linarith
intros
rw [← is_open_compl_iff, is_open_compl_image_coe]
intros
simpa only using h.map (-add_monoid_hom.id α) continuous_neg
intros
{ ext, simp }
ext
simp
intros
{ ext m, refl }
ext m
refl
intros
refine ⟨eq_of_nhds_eq_nhds $ λ a, _⟩
rw [h_nhds]
letI := preorder.topology α
letI : order_topology α := ⟨rfl⟩
exact (nhds_eq_infi_abs_sub a).symm
intros
rw [← comap_coe_Iio_nhds_within_Iio, tendsto_comap_iff]
intros
simp only [continuous_within_at, nhds_within_Ico_eq_nhds_within_Ici h]
intros
rw nhds_def; exact infi_le_of_le s (infi_le_of_le ⟨h, o⟩ sf)
rw nhds_def
exact infi_le_of_le s (infi_le_of_le ⟨h, o⟩ sf)
intros
apply continuous_of_continuous_uncurry
apply continuous_of_continuous_uncurry
rw ←homeomorph.comp_continuous_iff' (homeomorph.prod_assoc _ _ _).symm
convert continuous_ev; tidy
convert continuous_ev
tidy
intros
fsplit
intros s₁ s₂
by_cases n : nonempty α
obtain ⟨x⟩ := n
{ obtain ⟨x⟩ := n, ext f, have h : f = algebra_map R C(α, R) (f x), { ext x', simp only [mul_one, algebra.id.smul_eq_mul, algebra_map_apply], congr, }, rw h, simp only [subalgebra.algebra_map_mem], }
ext f
have h : f = algebra_map R C(α, R) (f x)
ext x'
{ ext x', simp only [mul_one, algebra.id.smul_eq_mul, algebra_map_apply], congr, }
simp only [mul_one, algebra.id.smul_eq_mul, algebra_map_apply]
congr
rw h
simp only [subalgebra.algebra_map_mem]
ext f
{ ext f, have h : f = 0, { ext x', exact false.elim (n ⟨x'⟩), }, subst h, simp only [subalgebra.zero_mem], }
have h : f = 0
{ ext x', exact false.elim (n ⟨x'⟩), }
ext x'
exact false.elim (n ⟨x'⟩)
subst h
simp only [subalgebra.zero_mem]
intros
simp
intros
classical
simp only [is_open_iff_continuous_mem, set.ite] at *
convert continuous_piecewise (λ x hx, propext (ht x hx)) hs.continuous_on hs'.continuous_on
ext x
by_cases hx : x ∈ t
by_cases hx : x ∈ t; simp [hx]
simp [hx]
simp [hx]
intros
rw [nhds_within, nhds_subtype, principal_subtype, ←comap_inf, ←nhds_within]
intros
rw continuous_on_iff'
split
assume h t ht
{ assume h t ht, rcases h t ht with ⟨u, u_open, hu⟩, rw [inter_comm, hu], apply is_open.inter u_open hs }
rcases h t ht with ⟨u, u_open, hu⟩
rw [inter_comm, hu]
apply is_open.inter u_open hs
assume h t ht
{ assume h t ht, refine ⟨s ∩ f ⁻¹' t, h t ht, _⟩, rw [@inter_comm _ s (f ⁻¹' t), inter_assoc, inter_self] }
refine ⟨s ∩ f ⁻¹' t, h t ht, _⟩
rw [@inter_comm _ s (f ⁻¹' t), inter_assoc, inter_self]
intros
change (of_le h ∘ A.proj) x = _
{ change (of_le h ∘ A.proj) x = _, simp }
simp
intros
rw continuous_iff_continuous_at
assume x
rcases h (proj x) with ⟨e, ex⟩
apply e.continuous_at_proj
rwa e.source_eq
intros
rw ← image_symm; exact h.symm.compact_image
rw ← image_symm
exact h.symm.compact_image
intros
rcases le_or_lt a b with h|h
rw [real.ediam_eq (bounded_Icc _ _), cSup_Icc h, cInf_Icc h]
{ rw [real.ediam_eq (bounded_Icc _ _), cSup_Icc h, cInf_Icc h] }
{ simp [h, h.le] }
simp [h, h.le]
intros
simp only [continuous_at, nhds_coe_coe, ← coe_add, tendsto_map'_iff, (∘), tendsto_coe, tendsto_add]
intros
rw [← continuous_within_at_univ, e.continuous_within_at_iff_continuous_within_at_comp_right h, preimage_univ, continuous_within_at_univ]
intros
ext
{ ext, simp only [continuous_id, id.def, function.comp.right_id, coe_comap] }
simp only [continuous_id, id.def, function.comp.right_id, coe_comap]
intros
rw ← bUnion_univ
apply dense_bUnion_interior_of_closed
{ simp [hc] }
simp [hc]
{ apply countable_encodable }
apply countable_encodable
{ rwa ← bUnion_univ at hU }
rwa ← bUnion_univ at hU
intros
refine tendsto.mono_right _ (comap_dist_right_at_top_le_cocompact x)
{ refine tendsto.mono_right _ (comap_dist_right_at_top_le_cocompact x), rwa tendsto_comap_iff }
rwa tendsto_comap_iff
intros
rw [← not_nonempty_iff_eq_empty, nonempty_closed_ball, not_le]
intros
simp [is_open_iff, subset_singleton_iff, mem_ball]
intros
apply induction_on₃ x y z
refine is_closed_le _ (continuous.add _ _)
{ refine is_closed_le _ (continuous.add _ _), { have : continuous (λp : completion α × completion α × completion α, (p.1, p.2.2)) := continuous.prod_mk continuous_fst (continuous.comp continuous_snd continuous_snd), exact (completion.uniform_continuous_dist.continuous.comp this : _) }, { have : continuous (λp : completion α × completion α × completion α, (p.1, p.2.1)) := continuous.prod_mk continuous_fst (continuous_fst.comp continuous_snd), exact (completion.uniform_continuous_dist.continuous.comp this : _) }, { have : continuous (λp : completion α × completion α × completion α, (p.2.1, p.2.2)) := continuous.prod_mk (continuous_fst.comp continuous_snd) (continuous.comp continuous_snd continuous_snd), exact (continuous.comp completion.uniform_continuous_dist.continuous this : _) } }
have : continuous (λp : completion α × completion α × completion α, (p.1, p.2.2)) := continuous.prod_mk continuous_fst (continuous.comp continuous_snd continuous_snd)
{ have : continuous (λp : completion α × completion α × completion α, (p.1, p.2.2)) := continuous.prod_mk continuous_fst (continuous.comp continuous_snd continuous_snd), exact (completion.uniform_continuous_dist.continuous.comp this : _) }
exact (completion.uniform_continuous_dist.continuous.comp this : _)
have : continuous (λp : completion α × completion α × completion α, (p.1, p.2.1)) := continuous.prod_mk continuous_fst (continuous_fst.comp continuous_snd)
{ have : continuous (λp : completion α × completion α × completion α, (p.1, p.2.1)) := continuous.prod_mk continuous_fst (continuous_fst.comp continuous_snd), exact (completion.uniform_continuous_dist.continuous.comp this : _) }
exact (completion.uniform_continuous_dist.continuous.comp this : _)
have : continuous (λp : completion α × completion α × completion α, (p.2.1, p.2.2)) := continuous.prod_mk (continuous_fst.comp continuous_snd) (continuous.comp continuous_snd continuous_snd)
{ have : continuous (λp : completion α × completion α × completion α, (p.2.1, p.2.2)) := continuous.prod_mk (continuous_fst.comp continuous_snd) (continuous.comp continuous_snd continuous_snd), exact (continuous.comp completion.uniform_continuous_dist.continuous this : _) }
exact (continuous.comp completion.uniform_continuous_dist.continuous this : _)
assume a b c
{ assume a b c, rw [completion.dist_eq, completion.dist_eq, completion.dist_eq], exact dist_triangle a b c }
rw [completion.dist_eq, completion.dist_eq, completion.dist_eq]
exact dist_triangle a b c
intros
simp [edist_comm]
intros
simp [@Hausdorff_edist_comm _ _ s _]
intros
simp [Hausdorff_dist]
intros
refine emetric.uniform_continuous_iff.2 (λε εpos, _)
use [ε / K, ennreal.div_pos_iff.2 ⟨ne_of_gt εpos, ennreal.coe_ne_top⟩]
assume x y Dxy
apply lt_of_le_of_lt (hf.edist_le_mul x y)
rw [mul_comm]
exact ennreal.mul_lt_of_lt_div Dxy
intros
{ rw supr_def, simp }
rw supr_def
simp
intros
refine ha.elim (λ x, _)
have : is_open ((finset.univ : finset α) : set α)
simp
{ simp }
rcases exists_open_singleton_of_open_finset _ ⟨x, finset.mem_univ x⟩ this with ⟨x, _, hx⟩
exact ⟨x, hx⟩
intros
dsimp [presheaf.germ, stalk_to_fiber]
cases x
simp
refl
intros
rw filter.has_basis_cocompact.tendsto_iff filter.has_basis_cocompact
intros K hK
refine ⟨f ⁻¹' (K ∩ (set.range f)), _, λ x hx, by simpa using hx⟩
apply hf.to_embedding.is_compact_iff_is_compact_image.mpr
rw set.image_preimage_eq_of_subset (set.inter_subset_right _ _)
exact hK.inter_right hf.closed_range
intros
ext
ext ; dsimp [uniform_space.comap] ; rw filter.comap_comap
ext ; dsimp [uniform_space.comap]
dsimp [uniform_space.comap]
rw filter.comap_comap
intros
simp [symmetric_rel, symmetrize_rel, preimage_inter, inter_comm, ← preimage_comp]
intros
rw [nhds_prod_eq, nhds_nhds_eq_uniformity_uniformity_prod, lift_lift'_same_eq_lift']
intro s
{ intro s, exact monotone_prod monotone_const monotone_preimage }
exact monotone_prod monotone_const monotone_preimage
intro t
{ intro t, exact monotone_prod monotone_preimage monotone_const }
exact monotone_prod monotone_preimage monotone_const
intros
cases x
{ cases x, refl }
refl
intros
cases a
cases b
congr
funext i
cases i
apply h
intros
cases a; cases b; simp
cases a; cases b
cases a
cases b
simp
simp
cases b
simp
simp
intros
rw [← h₂]
apply int.nat_abs_bit1_nonneg h₁
intros
have h := int.add_lt_add_right h b
rwa [int.sub_add_cancel, int.zero_add] at h
intros
rw int.add_comm at h
exact int.lt_add_of_sub_right_lt h
intros
induction l; intros; contradiction
induction l; intros
induction l
contradiction
contradiction
intros
unfold bodd bodd_div2; cases bodd_div2 n; cases fst; refl
unfold bodd bodd_div2; cases bodd_div2 n; cases fst
unfold bodd bodd_div2; cases bodd_div2 n
unfold bodd bodd_div2
cases bodd_div2 n
cases fst
refl
refl
intros
rw [nat.add_comm, add_div_right x H]
intros
{cases n, exact or.inl rfl, exact or.inr (succ_pos _)}
cases n
exact or.inl rfl
exact or.inr (succ_pos _)
intros
rw [nat.mul_sub_left_distrib, nat.right_distrib, nat.right_distrib, nat.mul_comm b a, nat.add_comm (a*a) (a*b), nat.add_sub_add_left]
intros
tactic.mk_inj_eq
intros
simp [bit1, add_smul, smul_add]
intros
cases exists_nat_gt (y - x)⁻¹ with n nh
cases exists_floor (x * n) with z zh
refine ⟨(z + 1 : ℤ) / n, _⟩
have n0' := (inv_pos.2 (sub_pos.2 h)).trans nh
have n0 := nat.cast_pos.1 n0'
rw [rat.cast_div_of_ne_zero, rat.cast_coe_nat, rat.cast_coe_int, div_lt_iff n0']
refine ⟨(lt_div_iff n0').2 $ (lt_iff_lt_of_le_iff_le (zh _)).1 (lt_add_one _), _⟩
rw [int.cast_add, int.cast_one]
refine lt_of_le_of_lt (add_le_add_right ((zh _).1 (le_refl _)) _) _
rwa [← lt_sub_iff_add_lt', ← sub_mul, ← div_lt_iff' (sub_pos.2 h), one_div]
rw [rat.coe_int_denom, nat.cast_one]
{ rw [rat.coe_int_denom, nat.cast_one], exact one_ne_zero }
exact one_ne_zero
exact one_ne_zero
intro H
{ intro H, rw [rat.coe_nat_num, ← coe_coe, nat.cast_eq_zero] at H, subst H, cases n0 }
rw [rat.coe_nat_num, ← coe_coe, nat.cast_eq_zero] at H
subst H
cases n0
rw [rat.coe_nat_denom, nat.cast_one]
{ rw [rat.coe_nat_denom, nat.cast_one], exact one_ne_zero }
exact one_ne_zero
exact one_ne_zero
intros
simpa only [← div_eq_mul_inv] using @sum_range_sub (additive M) _ f n
intros
simp
intros
casesI hq with q hq_one hq_prime
{ refl }
refl
exact false.elim (lt_irrefl _ ((hp.eq R hq_hchar).symm ▸ hq_prime : (0 : ℕ).prime).pos)
{ exact false.elim (lt_irrefl _ ((hp.eq R hq_hchar).symm ▸ hq_prime : (0 : ℕ).prime).pos) }
intros
cases s_succ_succ_nth_eq : s.nth (n + 2) with gp_succ_succ_n
case option.none { have : squash_seq s (n + 1) = s, from squash_seq_eq_self_of_terminated s_succ_succ_nth_eq, cases s_succ_nth_eq : (s.nth (n + 1)); simp only [squash_seq, seq.nth_tail, s_succ_nth_eq, s_succ_succ_nth_eq] }
have : squash_seq s (n + 1) = s
from squash_seq_eq_self_of_terminated s_succ_succ_nth_eq
cases s_succ_nth_eq : (s.nth (n + 1)); simp only [squash_seq, seq.nth_tail, s_succ_nth_eq, s_succ_succ_nth_eq]
cases s_succ_nth_eq : (s.nth (n + 1))
simp only [squash_seq, seq.nth_tail, s_succ_nth_eq, s_succ_succ_nth_eq]
simp only [squash_seq, seq.nth_tail, s_succ_nth_eq, s_succ_succ_nth_eq]
case option.some { obtain ⟨gp_succ_n, s_succ_nth_eq⟩ : ∃ gp_succ_n, s.nth (n + 1) = some gp_succ_n, from s.ge_stable (n + 1).le_succ s_succ_succ_nth_eq, ext m, cases decidable.em (m = n) with m_eq_n m_ne_n, { have : s.tail.nth n = some gp_succ_n, from (s.nth_tail n).trans s_succ_nth_eq, simp [*, squash_seq, seq.nth_tail, (seq.zip_with_nth_some (seq.nats_nth n) this), (seq.zip_with_nth_some (seq.nats_nth (n + 1)) s_succ_nth_eq)] }, { have : s.tail.nth m = s.nth (m + 1), from s.nth_tail m, cases s_succ_mth_eq : s.nth (m + 1), all_goals { have s_tail_mth_eq, from this.trans s_succ_mth_eq }, { simp only [*, squash_seq, seq.nth_tail, (seq.zip_with_nth_none' s_succ_mth_eq), (seq.zip_with_nth_none' s_tail_mth_eq)] }, { simp [*, squash_seq, seq.nth_tail, (seq.zip_with_nth_some (seq.nats_nth (m + 1)) s_succ_mth_eq), (seq.zip_with_nth_some (seq.nats_nth m) s_tail_mth_eq)] } } }
obtain ⟨gp_succ_n, s_succ_nth_eq⟩ : ∃ gp_succ_n, s.nth (n + 1) = some gp_succ_n
from s.ge_stable (n + 1).le_succ s_succ_succ_nth_eq
ext m
cases decidable.em (m = n) with m_eq_n m_ne_n
have : s.tail.nth n = some gp_succ_n
{ have : s.tail.nth n = some gp_succ_n, from (s.nth_tail n).trans s_succ_nth_eq, simp [*, squash_seq, seq.nth_tail, (seq.zip_with_nth_some (seq.nats_nth n) this), (seq.zip_with_nth_some (seq.nats_nth (n + 1)) s_succ_nth_eq)] }
from (s.nth_tail n).trans s_succ_nth_eq
simp [*, squash_seq, seq.nth_tail, (seq.zip_with_nth_some (seq.nats_nth n) this), (seq.zip_with_nth_some (seq.nats_nth (n + 1)) s_succ_nth_eq)]
have : s.tail.nth m = s.nth (m + 1)
{ have : s.tail.nth m = s.nth (m + 1), from s.nth_tail m, cases s_succ_mth_eq : s.nth (m + 1), all_goals { have s_tail_mth_eq, from this.trans s_succ_mth_eq }, { simp only [*, squash_seq, seq.nth_tail, (seq.zip_with_nth_none' s_succ_mth_eq), (seq.zip_with_nth_none' s_tail_mth_eq)] }, { simp [*, squash_seq, seq.nth_tail, (seq.zip_with_nth_some (seq.nats_nth (m + 1)) s_succ_mth_eq), (seq.zip_with_nth_some (seq.nats_nth m) s_tail_mth_eq)] } }
from s.nth_tail m
cases s_succ_mth_eq : s.nth (m + 1)
have s_tail_mth_eq
all_goals { have s_tail_mth_eq, from this.trans s_succ_mth_eq }
from this.trans s_succ_mth_eq
simp only [*, squash_seq, seq.nth_tail, (seq.zip_with_nth_none' s_succ_mth_eq), (seq.zip_with_nth_none' s_tail_mth_eq)]
{ simp only [*, squash_seq, seq.nth_tail, (seq.zip_with_nth_none' s_succ_mth_eq), (seq.zip_with_nth_none' s_tail_mth_eq)] }
have s_tail_mth_eq
from this.trans s_succ_mth_eq
simp [*, squash_seq, seq.nth_tail, (seq.zip_with_nth_some (seq.nats_nth (m + 1)) s_succ_mth_eq), (seq.zip_with_nth_some (seq.nats_nth m) s_tail_mth_eq)]
{ simp [*, squash_seq, seq.nth_tail, (seq.zip_with_nth_some (seq.nats_nth (m + 1)) s_succ_mth_eq), (seq.zip_with_nth_some (seq.nats_nth m) s_tail_mth_eq)] }
intros
simpa [partial_numerators, seq.map_nth] using nth_part_num_eq
intros
{congr, ext, simp [to_add_monoid, of]}
congr
ext
simp [to_add_monoid, of]
intros
{ unfold gcd_b, rw [xgcd, xgcd_zero_left] }
unfold gcd_b
rw [xgcd, xgcd_zero_left]
intros
rw [inv_eq_one_div, inv_eq_one_div, one_div_add_one_div ha hb]
intros
rw [gcd_def, multiset.gcd_eq_zero_iff]
split
split; intro h
intro h
intros b bs
{ intros b bs, apply h (f b), simp only [multiset.mem_map, mem_def.1 bs], use b, simp [mem_def.1 bs] }
apply h (f b)
simp only [multiset.mem_map, mem_def.1 bs]
use b
simp [mem_def.1 bs]
intro h
intros a as
{ intros a as, rw multiset.mem_map at as, rcases as with ⟨b, ⟨bs, rfl⟩⟩, apply h b (mem_def.1 bs) }
rw multiset.mem_map at as
rcases as with ⟨b, ⟨bs, rfl⟩⟩
apply h b (mem_def.1 bs)
intros
simp [h.symm]
intros
simp [h]
intros
rw [sub_eq_iff_eq_add, add_comm]
intros
rintros ⟨⟩ ⟨⟩ h
congr'
congr'; injection h
injection h
injection h
injection h
intros
ext
{ ext, simp only [function.comp_app, inv_apply, map_inv, coe_comp] }
simp only [function.comp_app, inv_apply, map_inv, coe_comp]
intros
induction n with n ih
{ simp, }
simp
{ simp [pow_succ, ih], }
simp [pow_succ, ih]
intros
cases ha with a ha; rw [←ha, units.mul_left_inj]
cases ha with a ha
rw [←ha, units.mul_left_inj]
intros
rw [← multiples_hom_symm_apply, ← multiples_hom_apply, equiv.apply_symm_apply]
intros
rw [div_eq_mul_inv, inv_zero, mul_zero]
intros
rw [mul_comm c, mul_comm c, mul_div_mul_right _ _ hc]
intros
rw [←kernel_subobject_arrow', exact_iso_comp]
{ rw [←kernel_subobject_arrow', exact_iso_comp], exact exact_kernel_subobject_arrow }
exact exact_kernel_subobject_arrow
intros
change ite (1 = 0 + 1) (d₀ ≫ 𝟙 X₁) 0 = d₀
{ change ite (1 = 0 + 1) (d₀ ≫ 𝟙 X₁) 0 = d₀, rw [if_pos rfl, category.comp_id] }
rw [if_pos rfl, category.comp_id]
intros
simp [mul_indicator_preimage, pi.one_def, set.preimage_const_of_not_mem ht]
intros
{ rw [←sub_eq_zero, sub_neg_eq_add, ←add_lie], simp, }
rw [←sub_eq_zero, sub_neg_eq_add, ←add_lie]
simp
intros
dunfold derived_abelian_of_ideal
cases h : derived_length_of_ideal R L I with k
{ rw derived_length_zero at h, rw h, refl, }
rw derived_length_zero at h
rw h
refl
obtain ⟨h₁, h₂⟩ := (derived_series_of_derived_length_succ R L I k).mp h
{ obtain ⟨h₁, h₂⟩ := (derived_series_of_derived_length_succ R L I k).mp h, have h₃ : I ≠ ⊥, { intros contra, apply h₂, rw contra, apply derived_series_of_bot_eq_bot, }, change derived_series_of_ideal R L k I = ⊥ ↔ I = ⊥, split; contradiction, }
have h₃ : I ≠ ⊥
intros contra
{ intros contra, apply h₂, rw contra, apply derived_series_of_bot_eq_bot, }
apply h₂
rw contra
apply derived_series_of_bot_eq_bot
change derived_series_of_ideal R L k I = ⊥ ↔ I = ⊥
split; contradiction
split
contradiction
contradiction
intros
split
{ exact set.subset.trans subset_lie_span, }
exact set.subset.trans subset_lie_span
{ intros hs m hm, rw mem_lie_span at hm, exact hm _ hs, }
intros hs m hm
rw mem_lie_span at hm
exact hm _ hs
intros
split
{ exact subset.trans subset_lie_span, }
exact subset.trans subset_lie_span
{ intros hs m hm, rw mem_lie_span at hm, exact hm _ hs, }
intros hs m hm
rw mem_lie_span at hm
exact hm _ hs
intros
refine is_linear_map.mk (smul_add c) _
intros _ _
simp only [smul_smul, mul_comm]
intros
simp
intros
refine ⟨h, λ ho, _⟩
cases lt_trichotomy a b with hab hab
change compares ordering.lt a b at hab
{ change compares ordering.lt a b at hab, rwa [ho.inj (h hab)] }
rwa [ho.inj (h hab)]
cases hab with hab hab
{ cases hab with hab hab, { change compares ordering.eq a b at hab, rwa [ho.inj (h hab)] }, { change compares ordering.gt a b at hab, rwa [ho.inj (h hab)] } }
change compares ordering.eq a b at hab
{ change compares ordering.eq a b at hab, rwa [ho.inj (h hab)] }
rwa [ho.inj (h hab)]
change compares ordering.gt a b at hab
{ change compares ordering.gt a b at hab, rwa [ho.inj (h hab)] }
rwa [ho.inj (h hab)]
intros
rcases lt_trichotomy b 0 with (hb|rfl|hb)
{ simp [hb, hb.not_lt, one_lt_div_of_neg] }
simp [hb, hb.not_lt, one_lt_div_of_neg]
{ simp [lt_irrefl, zero_le_one] }
simp [lt_irrefl, zero_le_one]
{ simp [hb, hb.not_lt, one_lt_div] }
simp [hb, hb.not_lt, one_lt_div]
intros
refine (one_div_lt_one_div _ _).mpr (pow_lt_pow a1 mn)
refine (one_div_lt_one_div _ _).mpr (pow_lt_pow a1 mn); exact pow_pos (trans zero_lt_one a1) _
exact pow_pos (trans zero_lt_one a1) _
exact pow_pos (trans zero_lt_one a1) _
intros
simpa only [div_eq_mul_inv] using mul_inv_lt_mul_inv_iff'
intros
norm_cast
intros
haveI := @linear_order.decidable_le α _; exact lt_of_not_ge (λ hb, absurd h (decidable.mul_nonneg_of_nonpos_of_nonpos ha hb).not_lt)
haveI := @linear_order.decidable_le α _
exact lt_of_not_ge (λ hb, absurd h (decidable.mul_nonneg_of_nonpos_of_nonpos ha hb).not_lt)
intros
nontriviality
calc 1 = 1 * 1 : by rw one_mul ... < a * b : decidable.mul_lt_mul' ha hb zero_le_one (zero_lt_one.trans_le ha)
intros
simpa only [zero_add] using h.neg 0
intros
rw [←nat.sub_add_cancel (nat.pos_of_ne_zero hn), pow_succ, empty_mul]
intros
convert finset.card_image_le
{ convert finset.card_image_le, rw [finset.card_product, mul_comm] }
rw [finset.card_product, mul_comm]
intros
simpa using nat_degree_multiset_sum_le (s.val.map f)
intros
simp only [is_left_regular, ← mul_left_iterate, rla.iterate n]
intros
split_ifs; refl
split_ifs
refl
refl
intros
simp
intros
obtain ⟨V, (hxV : x.1 ∈ V.1), iVU, f, g, (hVDg : V ⊆ basic_open g), s_eq⟩ := exists_const R U s x.1 x.2
obtain ⟨_, ⟨h, rfl⟩, hxDh, (hDhV : basic_open h ⊆ V)⟩ := is_topological_basis_basic_opens.exists_subset_of_mem_open hxV V.2
cases (basic_open_le_basic_open_iff h g).mp (set.subset.trans hDhV hVDg) with n hn
replace hn := ideal.mul_mem_left (ideal.span {g}) h hn
rw [← pow_succ, ideal.mem_span_singleton'] at hn
cases hn with c hc
have basic_opens_eq := basic_open_pow h (n+1) (by linarith)
have i_basic_open := eq_to_hom basic_opens_eq ≫ hom_of_le hDhV
use [f * c, h ^ (n+1), i_basic_open ≫ iVU, (basic_opens_eq.symm.le : _) hxDh]
rw [op_comp, functor.map_comp, comp_apply, ← s_eq, res_const]
swap
intros y hy
{ intros y hy, rw basic_opens_eq at hy, exact (set.subset.trans hDhV hVDg : _) hy }
rw basic_opens_eq at hy
exact (set.subset.trans hDhV hVDg : _) hy
apply const_ext
rw [mul_assoc f c g, hc]
intros
rcases ((tfae_exists_lt_is_o_pow (λ n, ∥p n∥ * r ^ n) 1).out 1 5).mp (p.is_o_of_lt_radius h) with ⟨a, ha, C, hC, H⟩
exact ⟨a, ha, C, hC, λ n, (le_abs_self _).trans (H n)⟩
intros
rw [← p.nnnorm_change_origin_series_term k l s hs, ← fin.prod_const, ← fin.prod_const]
apply continuous_multilinear_map.le_of_op_nnnorm_le
apply continuous_multilinear_map.le_op_nnnorm
intros
ext1 n
induction n using nat.strong_rec' with n IH
cases n
simp
{ simp }
cases n
simp
{ simp }
simp only [left_inv, neg_inj]
refine finset.sum_congr rfl (λ c cuniv, _)
rcases c with ⟨c, hc⟩
ext v
dsimp
simp [IH _ hc]
intros
unfold is_O_with at *
filter_upwards [hfg, hgk]
assume x hx hx'
calc ∥f x∥ ≤ c * ∥g x∥ : hx ... ≤ c * (c' * ∥k x∥) : mul_le_mul_of_nonneg_left hx' hc ... = c * c' * ∥k x∥ : (mul_assoc _ _ _).symm
intros
rw is_O_with; refl
rw is_O_with
refl
intros
simp [div_eq_inv_mul, differentiable.const_mul, hc]
intros
{ unfold deriv_within deriv, rw h.fderiv_within hxs }
unfold deriv_within deriv
rw h.fderiv_within hxs
intros
rw add_comm
exact (is_bounded_bilinear_map_comp.has_fderiv_at (d x, c x)).comp_has_fderiv_within_at x (hd.prod hc)
intros
{ rw ← H at h, exact h }
rw ← H at h
exact h
intros
simp [iterated_deriv_within_eq_equiv_comp, continuous_linear_equiv.comp_continuous_on_iff, -coe_fn_coe_base]
exact h.continuous_on_iterated_fderiv_within hmn hs
intros
refine is_o_iff.mpr (λ c hc, metric.eventually_nhds_iff_ball.mpr _)
rcases metric.mem_nhds_iff.mp (inter_mem hder (hcont $ ball_mem_nhds _ hc)) with ⟨ε, ε0, hε⟩
refine ⟨ε, ε0, _⟩
rintros ⟨a, b⟩ h
rw [← ball_prod_same, prod_mk_mem_set_prod_eq] at h
have hf' : ∀ x' ∈ ball x ε, ∥f' x' - f' x∥ ≤ c
intros x' H'
{ intros x' H', rw ← dist_eq_norm, exact le_of_lt (hε H').2 }
rw ← dist_eq_norm
exact le_of_lt (hε H').2
letI : normed_space ℝ G := restrict_scalars.normed_space ℝ 𝕜 G
letI : is_scalar_tower ℝ 𝕜 G := restrict_scalars.is_scalar_tower _ _ _
refine (convex_ball _ _).norm_image_sub_le_of_norm_has_fderiv_within_le' _ hf' h.2 h.1
exact λ y hy, (hε hy).1.has_fderiv_within_at
intros
rcases lt_trichotomy x 0 with hx|hx|hx
have : f_aux (n+1) x = 0
{ have : f_aux (n+1) x = 0, by simp [f_aux, le_of_lt hx], rw this, apply (has_deriv_at_const x (0 : ℝ)).congr_of_eventually_eq, filter_upwards [gt_mem_nhds hx], assume y hy, simp [f_aux, hy.le] }
simp [f_aux, le_of_lt hx]
simp [f_aux, le_of_lt hx]
rw this
apply (has_deriv_at_const x (0 : ℝ)).congr_of_eventually_eq
filter_upwards [gt_mem_nhds hx]
assume y hy
simp [f_aux, hy.le]
have : f_aux (n + 1) 0 = 0
{ have : f_aux (n + 1) 0 = 0, by simp [f_aux, le_refl], rw [hx, this], exact f_aux_deriv_zero n }
simp [f_aux, le_refl]
simp [f_aux, le_refl]
rw [hx, this]
exact f_aux_deriv_zero n
have : f_aux (n+1) x = (P_aux (n+1)).eval x * exp (-x⁻¹) / x^(2 * (n+1))
{ have : f_aux (n+1) x = (P_aux (n+1)).eval x * exp (-x⁻¹) / x^(2 * (n+1)), by simp [f_aux, not_le_of_gt hx], rw this, exact f_aux_deriv_pos n x hx }
simp [f_aux, not_le_of_gt hx]
simp [f_aux, not_le_of_gt hx]
rw this
exact f_aux_deriv_pos n x hx
intros
rw times_cont_diff_on_top_iff_fderiv_within hs.unique_diff_on
congr' 2
rw ← iff_iff_eq
apply times_cont_diff_on_congr
assume x hx
exact fderiv_within_of_open hs hx
intros
rw [subsingleton.elim f (λ _, 0)]
{ rw [subsingleton.elim f (λ _, 0)], exact times_cont_diff_within_at_const }
exact times_cont_diff_within_at_const
intros
rw [← times_cont_diff_within_at_univ] at *; exact times_cont_diff_within_at.sum h
rw [← times_cont_diff_within_at_univ] at *
exact times_cont_diff_within_at.sum h
intros
rw [norm_int, _root_.abs_of_nonneg]; exact int.cast_nonneg.2 hn
rw [norm_int, _root_.abs_of_nonneg]
exact int.cast_nonneg.2 hn
intros
rw [smul_aux', complex.div_im]
set NsqBot := (denom g z).norm_sq
have : NsqBot ≠ 0
simp only [denom_ne_zero g z, monoid_with_zero_hom.map_eq_zero, ne.def, not_false_iff]
{ simp only [denom_ne_zero g z, monoid_with_zero_hom.map_eq_zero, ne.def, not_false_iff], }
field_simp [smul_aux']
convert congr_arg (λ x, x * z.im * NsqBot ^ 2) g.det_coe using 1
rw det_fin_two ↑g
{ rw det_fin_two ↑g, ring }
ring
{ ring }
ring
intros
cases hxy.lt_or_lt
rw [open_segment_eq_Ioo h, max_eq_right h.le, min_eq_left h.le]
{ rw [open_segment_eq_Ioo h, max_eq_right h.le, min_eq_left h.le] }
rw [open_segment_symm, open_segment_eq_Ioo h, max_eq_left h.le, min_eq_right h.le]
{ rw [open_segment_symm, open_segment_eq_Ioo h, max_eq_left h.le, min_eq_right h.le] }
intros
simp only [center_mass, sum_empty, smul_zero]
intros
obtain hB | hB := B.eq_empty_or_nonempty
refine ⟨0, 1, _⟩
{ refine ⟨0, 1, _⟩, rw [hB, eq_comm, eq_empty_iff_forall_not_mem], rintro x ⟨-, h⟩, rw continuous_linear_map.zero_apply at h, linarith }
rw [hB, eq_comm, eq_empty_iff_forall_not_mem]
rintro x ⟨-, h⟩
rw continuous_linear_map.zero_apply at h
linarith
obtain ⟨l, rfl⟩ := hAB hB
obtain ⟨w, hw⟩ := hB
exact ⟨l, l w, subset.antisymm (λ x hx, ⟨hx.1, hx.2 w hw.1⟩) (λ x hx, ⟨hx.1, λ y hy, (hw.2 y hy).trans hx.2⟩)⟩
intros
rw [← submodule.top_orthogonal_eq_bot, eq_top_iff]
exact submodule.le_orthogonal_orthogonal ⊤
intros
simp only [inner_zero_left, add_monoid_hom.map_zero]
intros
simp only [sq, ← inner_self_eq_norm_sq]
exact (re_clm : 𝕜 →L[ℝ] ℝ).times_cont_diff.comp (times_cont_diff_id.inner times_cont_diff_id)
intros
rw ←@ennreal.le_rpow_one_div_iff _ _ (1/p) (by simp [lt_of_lt_of_le zero_lt_one hp1])
rw one_div_one_div
exact add_rpow_le_rpow_add _ _ hp1
intros
rw [dist_comm, dist_midpoint_right]
intros
haveI : complete_space G := complete_space_coe_iff_is_complete.2 hG.is_complete
let g := coprod_subtypeL_equiv_of_is_compl f h hker
rw congr_arg coe (range_eq_map_coprod_subtypeL_equiv_of_is_compl f h hker )
apply g.to_homeomorph.is_closed_image.2
exact is_closed_univ.prod is_closed_singleton
intros
simp only [dist_eq_norm, neg_sub_neg, norm_sub_rev]
intros
rw [frontier, closure_closed_ball, interior_closed_ball x hr, closed_ball_diff_ball]
intros
simp_rw ← sum_antidiagonal_eq_sum_range_succ (λ k l, f k * g l)
exact tsum_mul_tsum_eq_tsum_sum_antidiagonal_of_summable_norm hf hg
intros
by_cases h : (exp_series 𝕂 𝔸).radius = 0
{ rw h at hx, exact (ennreal.not_lt_zero hx).elim }
rw h at hx
exact (ennreal.not_lt_zero hx).elim
have h := pos_iff_ne_zero.mpr h
{ have h := pos_iff_ne_zero.mpr h, exact (has_fpower_series_on_ball_exp_of_radius_pos h).analytic_at_of_mem hx }
exact (has_fpower_series_on_ball_exp_of_radius_pos h).analytic_at_of_mem hx
intros
refine ⟨summable_of_summable_norm, λ hf, _⟩
suffices : ∀ {N : ℕ} {g : α → fin N → ℝ}, summable g → summable (λ x, ∥g x∥)
obtain v := fin_basis ℝ E
{ obtain v := fin_basis ℝ E, set e := v.equiv_funL, have : summable (λ x, ∥e (f x)∥) := this (e.summable.2 hf), refine summable_of_norm_bounded _ (this.mul_left ↑(nnnorm (e.symm : (fin (finrank ℝ E) → ℝ) →L[ℝ] E))) (λ i, _), simpa using (e.symm : (fin (finrank ℝ E) → ℝ) →L[ℝ] E).le_op_norm (e $ f i) }
set e := v.equiv_funL
have : summable (λ x, ∥e (f x)∥) := this (e.summable.2 hf)
refine summable_of_norm_bounded _ (this.mul_left ↑(nnnorm (e.symm : (fin (finrank ℝ E) → ℝ) →L[ℝ] E))) (λ i, _)
simpa using (e.symm : (fin (finrank ℝ E) → ℝ) →L[ℝ] E).le_op_norm (e $ f i)
clear_dependent E
unfreezingI { clear_dependent E }
intros N g hg
have : ∀ i, summable (λ x, ∥g x i∥) := λ i, (pi.summable.1 hg i).abs
refine summable_of_norm_bounded _ (summable_sum (λ i (hi : i ∈ finset.univ), this i)) (λ x, _)
rw [norm_norm, pi_norm_le_iff]
refine λ i, finset.single_le_sum (λ i hi, _) (finset.mem_univ i)
{ refine λ i, finset.single_le_sum (λ i hi, _) (finset.mem_univ i), exact norm_nonneg (g x i) }
exact norm_nonneg (g x i)
{ exact finset.sum_nonneg (λ _ _, norm_nonneg _) }
exact finset.sum_nonneg (λ _ _, norm_nonneg _)
intros
ext m x
simp only [snoc_last, continuous_multilinear_map.curry_right_apply, continuous_multilinear_map.uncurry_right_apply]
rw init_snoc
intros
rw div_eq_inv_mul
{ rw div_eq_inv_mul, exact (has_strict_deriv_at_log h₂).comp x h₁ }
exact (has_strict_deriv_at_log h₂).comp x h₁
intros
rw [← map_exp_at_bot, tendsto_map'_iff]
intros
rw tendsto_at_top_at_top
intro b
use (max b 0) ^ (1/y)
intros x hx
exact le_of_max_le_left (by { convert rpow_le_rpow (rpow_nonneg_of_nonneg (le_max_right b 0) (1/y)) hx (le_of_lt hy), rw [← rpow_mul (le_max_right b 0), (eq_div_iff (ne_of_gt hy)).mp rfl, rpow_one] })
intros
by_cases hp0 : p = 0
{ simp [hp0], }
simp [hp0]
by_cases hx0 : x = 0
rw ← ne.def at hp0
{ rw ← ne.def at hp0, have hp_pos : 0 < p := lt_of_le_of_ne hp_nonneg hp0.symm, simp [hx0, hp_pos, hp_pos.ne.symm], }
have hp_pos : 0 < p := lt_of_le_of_ne hp_nonneg hp0.symm
simp [hx0, hp_pos, hp_pos.ne.symm]
rw ← ne.def at hx0
exact of_real_rpow_of_pos (hx_nonneg.lt_of_ne hx0.symm)
intros
simp [real.rpow_def_of_nonneg hx, complex.cpow_def]
simp [real.rpow_def_of_nonneg hx, complex.cpow_def]; split_ifs; simp [complex.of_real_log hx]
simp [real.rpow_def_of_nonneg hx, complex.cpow_def]; split_ifs
split_ifs
simp [complex.of_real_log hx]
simp [complex.of_real_log hx]
simp [complex.of_real_log hx]
intros
{ rw ← one_rpow z, exact rpow_lt_rpow zero_le_one hx hz }
rw ← one_rpow z
exact rpow_lt_rpow zero_le_one hx hz
intros
simpa only [cos_zero] using (cos_periodic.nat_mul n).add_antiperiod_eq cos_antiperiodic
intros
have hx : abs x = x := abs_of_nonneg (le_of_lt h)
have : abs x ≤ 1
rwa [hx]
have := sin_bound this
rw [abs_le] at this
have := this.1
rw [le_sub_iff_add_le, hx] at this
refine lt_of_lt_of_le _ this
rw [add_comm, sub_add, sub_neg_eq_add]
apply sub_lt_sub_left
apply add_lt_of_lt_sub_left
rw (show x ^ 3 / 4 - x ^ 3 / 6 = x ^ 3 * 12⁻¹, by simp [div_eq_mul_inv, ← mul_sub]; norm_num)
apply mul_lt_mul'
rw [pow_succ x 3]
{ rw [pow_succ x 3], refine le_trans _ (le_of_eq (one_mul _)), rw mul_le_mul_right, exact h', apply pow_pos h }
refine le_trans _ (le_of_eq (one_mul _))
rw mul_le_mul_right
exact h'
apply pow_pos h
apply pow_pos h
norm_num
norm_num
apply pow_pos h
apply pow_pos h
intros
have h := (sin_two_mul θ).symm
rw mul_assoc at h
rw [tan, div_eq_zero_iff, ← mul_eq_zero, ← zero_mul ((1/2):ℂ), mul_one_div, cancel_factors.cancel_factors_eq_div h two_ne_zero', mul_comm]
simpa only [zero_div, zero_mul, ne.def, not_false_iff] with field_simps using sin_eq_zero_iff
intros
convert has_sum.mul_left (a / 2) (has_sum_geometric_of_lt_1 (le_of_lt one_half_pos) one_half_lt_one)
{ funext n, simp, refl, }
funext n
simp
refl
{ norm_num }
norm_num
intros
have key : ∀ᶠ n in at_top, ∥f n∥ ≠ 0
filter_upwards [eventually_ge_of_tendsto_gt hl h]
{ filter_upwards [eventually_ge_of_tendsto_gt hl h], intros n hn hc, rw [hc, div_zero] at hn, linarith }
intros n hn hc
rw [hc, div_zero] at hn
linarith
rcases exists_between hl with ⟨r, hr₀, hr₁⟩
refine not_summable_of_ratio_norm_eventually_ge hr₀ key.frequently _
filter_upwards [eventually_ge_of_tendsto_gt hr₁ h, key]
intros n h₀ h₁
rwa ← le_div_iff (lt_of_le_of_ne (norm_nonneg _) h₁.symm)
intros
apply mono_inl_of_is_colimit _ _ (pushout_cocone.is_colimit_of_factors _ _ _ _ _ hf hg t ht)
intros
simp
intros
simp only [←arrow.mk_hom f, lift.fac_left, arrow.hom_mk'_left]
intros
split
intros Z a b w
apply (cancel_mono f).1
apply (cancel_mono g).1
simpa using w
intros
{ cases p, cases q, simp, }
cases p
cases q
simp
intros
ext
{ ext, simp, }
simp
intros
dsimp [colimit.iso_colimit_cocone, is_colimit.cocone_point_unique_up_to_iso]
{ dsimp [colimit.iso_colimit_cocone, is_colimit.cocone_point_unique_up_to_iso], tidy, }
tidy
intros
{ ext; simp }
ext
ext; simp
simp
simp
intros
rw [is_iso.eq_comp_inv, category.assoc, is_iso.inv_comp_eq, coprod_comparison_natural]
intros
rw [←colimit.w _ f, ←colimit.w _ f']
rw [types_comp_apply, types_comp_apply, w]
intros
{ rw ←tensor_comp, simp }
rw ←tensor_comp
simp
intros
have pent := pentagon W X Y Z
rw ←iso.comp_inv_eq at pent
rw [iso.eq_inv_comp, ←pent]
simp only [tensor_hom_inv_id, iso.inv_hom_id_assoc, tensor_id, category.comp_id, category.assoc]
intros
rw [naturality, ←category.assoc, ←nat_trans.comp_app, α.inv_hom_id, id_app, category.id_comp]
intros
classical
by_contradiction h
apply w
exact is_iso_of_mono_of_nonzero h
intros
rw [is_iso_iff_mk_eq_top, mk_arrow]
intros
rw [le_iff_le_iff_lt_iff_lt, hom_lt_iff h₁]
intros
by_contradiction H
set i := c.index j with hi
push_neg at H
have i_pos : (0 : ℕ) < i
by_contradiction i_pos
{ by_contradiction i_pos, push_neg at i_pos, revert H, simp [nonpos_iff_eq_zero.1 i_pos, c.size_up_to_zero] }
push_neg at i_pos
revert H
simp [nonpos_iff_eq_zero.1 i_pos, c.size_up_to_zero]
let i₁ := (i : ℕ).pred
have i₁_lt_i : i₁ < i := nat.pred_lt (ne_of_gt i_pos)
have i₁_succ : i₁.succ = i := nat.succ_pred_eq_of_pos i_pos
have := nat.find_min (c.index_exists j.2) i₁_lt_i
simp [lt_trans i₁_lt_i (c.index j).2, i₁_succ] at this
exact nat.lt_le_antisymm H this
intros
have : fintype.card (finset (fin (n-1))) = 2 ^ (n - 1)
simp
simp
rw ← this
exact fintype.card_congr (composition_as_set_equiv n)
intros
{ funext i, cases i; refl }
funext i
cases i
cases i; refl
refl
refl
intros
simp only [mem_incidence_set, mem_neighbor_set]
intros
refine quotient.ind (λ p h, _) e h
cases p with v w
let d : G.dart := ⟨v, w, h⟩
convert congr_arg card d.edge_fiber
rw [card_insert_of_not_mem, card_singleton]
rw [mem_singleton]
exact d.rev_ne.symm
intros
simp [add_def]
intros
cases q; apply_rules [finset.mem_insert_self, finset.mem_singleton_self]
cases q
apply_rules [finset.mem_insert_self, finset.mem_singleton_self]
apply_rules [finset.mem_insert_self, finset.mem_singleton_self]
apply_rules [finset.mem_insert_self, finset.mem_singleton_self]
apply_rules [finset.mem_insert_self, finset.mem_singleton_self]
apply_rules [finset.mem_insert_self, finset.mem_singleton_self]
apply_rules [finset.mem_insert_self, finset.mem_singleton_self]
apply_rules [finset.mem_insert_self, finset.mem_singleton_self]
intros
simp [guard]
intros
cases x
cases x; cases x'; congr; apply h
cases x; cases x'; congr
cases x; cases x'
cases x'
congr
apply h
intros
ext
ext; simp [traverse_map]
simp [traverse_map]
intros
cases F
cases F; refl
refl
intros
suffices : v.to_nat + 1 ≤ 2 ^ n
simpa
{ simpa }
rw to_nat_eq_foldr_reverse
cases v with xs h
dsimp [bitvec.to_nat,bits_to_nat]
rw ← list.length_reverse at h
generalize_hyp : xs.reverse = ys at ⊢ h
clear xs
induction ys generalizing n
{ simp [← h] }
simp [← h]
simp only [←h, pow_add, flip, list.length, list.foldr, pow_one]
{ simp only [←h, pow_add, flip, list.length, list.foldr, pow_one], rw [add_lsb_eq_twice_add_one], transitivity 2 * list.foldr (λ (x : bool) (y : ℕ), add_lsb y x) 0 ys_tl + 2 * 1, { ac_mono, rw two_mul, mono, cases ys_hd; simp }, { rw ← left_distrib, ac_mono, norm_num, apply ys_ih, refl } }
rw [add_lsb_eq_twice_add_one]
transitivity 2 * list.foldr (λ (x : bool) (y : ℕ), add_lsb y x) 0 ys_tl + 2 * 1
{ ac_mono, rw two_mul, mono, cases ys_hd; simp }
ac_mono
rw two_mul
mono
cases ys_hd
cases ys_hd; simp
simp
simp
rw ← left_distrib
{ rw ← left_distrib, ac_mono, norm_num, apply ys_ih, refl }
ac_mono
norm_num
apply ys_ih
refl
intros
induction l with hd tl hl generalizing b
{ refl }
refl
have hb : i < ((b.push_back hd).append_list tl).size := by convert h using 1
{ have hb : i < ((b.push_back hd).append_list tl).size := by convert h using 1, have hb' : i < (b.push_back hd).size := by { convert nat.lt_succ_of_lt h', simp }, have : (append_list b (hd :: tl)).read ⟨i, h⟩ = read ((push_back b hd).append_list tl) ⟨i, hb⟩ := rfl, simp [this, hl _ hb hb', read_push_back_left _ _ h'] }
have hb' : i < (b.push_back hd).size := by { convert nat.lt_succ_of_lt h', simp }
have : (append_list b (hd :: tl)).read ⟨i, h⟩ = read ((push_back b hd).append_list tl) ⟨i, hb⟩ := rfl
simp [this, hl _ hb hb', read_push_back_left _ _ h']
intros
cases p cb n; simp
cases p cb n
simp
simp
apply not_step_of_static_done
simp only [eof_eq_done, exists_eq_left', exists_const]
use [buffer.nil, 0]
simp
intros
simp [many_char, list.as_string_eq]
intros
rw ← of_real_inj; simp [cos_three_mul]
rw ← of_real_inj
simp [cos_three_mul]
intros
simp [sub_eq_add_neg, exp_add, exp_neg, div_eq_mul_inv]
intros
rw ← cosh_sq_sub_sinh_sq x
ring
intros
simp only [add_zero, of_real_im, zero_mul, of_real_re, mul_im]
intros
simp [div_eq_mul_inv, mul_assoc, sub_eq_add_neg, add_comm]
intros
rw [map_range_def]
refine (finset.prod_subset support_mk_subset _).trans _
intros i h1 h2
{ intros i h1 h2, dsimp, simp [h1] at h2, dsimp at h2, simp [h1, h2, h0] }
dsimp
simp [h1] at h2
dsimp at h2
simp [h1, h2, h0]
refine finset.prod_congr rfl _
{ refine finset.prod_congr rfl _, intros i h1, simp [h1] }
intros i h1
simp [h1]
intros
simp only [filter_apply, if_neg h]
intros
{ cases π, refl }
cases π
refl
intros
simp [perm.subtype_congr.apply, h]
intros
simp_rw [set.range, set.mem_set_of_eq, ne.def, option.eq_none_iff_forall_not_mem, encodable.mem_decode₂, not_forall, not_not]
intros
{ ext j, simp [tail] }
ext j
simp [tail]
intros
simp [lt_iff_coe_lt_coe]
intros
cases i; refl
cases i
refl
intros
cases s₁; cases s₂; simp [alist.to_finmap]
cases s₁; cases s₂
cases s₁
cases s₂
simp [alist.to_finmap]
intros
rw update_piecewise
refine s.piecewise_congr (λ _ _, rfl) (λ j hj, update_noteq _ _ _)
exact λ h, hj (h.symm ▸ hi)
intros
ext
ext; simp
simp
intros
classical
calc card s = card (s.image f) : by rw [card_image_of_inj_on f_inj] ... ≤ card t : card_le_of_subset $ image_subset_iff.2 hf
intros
simp only [insert_eq, union_assoc]
intros
show _ ≥ _ ↔ _
apply fold_op_rel_iff_and
intros x y z
show _ ≤ _ ↔ _
exact max_le_iff
intros
simp [antidiagonal]
intros
{ ext, simp [eq_comm] }
ext
simp [eq_comm]
intros
ext x
ext x; refl
refl
intros
simp [single_apply_eq_zero, not_or_distrib]
intros
{ ext, simp, }
ext
simp
intros
simp
intros
simp
intros
rw [(coe_nat_le_coe_nat_iff _ _).symm, to_nat_eq_max, max_le_iff]
rw [(coe_nat_le_coe_nat_iff _ _).symm, to_nat_eq_max, max_le_iff]; exact and_iff_left (coe_zero_le _)
exact and_iff_left (coe_zero_le _)
intros
{ rw [sub_eq_add_neg, ← int.nat_abs_neg b], apply nat_abs_add_le }
rw [sub_eq_add_neg, ← int.nat_abs_neg b]
apply nat_abs_add_le
intros
rw [mul_comm, add_mul_mod_self]
intros
cases r; [exact absurd h (lt_irrefl _), {simp only [xgcd_aux], refl}]
cases r
exact absurd h (lt_irrefl _)
simp only [xgcd_aux]
refl
intros
rw [even_iff, mod_two_ne_zero]
intros
rw [← option.some_inj, ← list.nth_le_nth, list.nth_update_nth_ne _ _ h, list.nth_le_nth]
intros
induction xs generalizing n; simp only [reverse_cons, drop, reverse_nil, nat.zero_sub, length, take_nil]
induction xs generalizing n
simp only [reverse_cons, drop, reverse_nil, nat.zero_sub, length, take_nil]
simp only [reverse_cons, drop, reverse_nil, nat.zero_sub, length, take_nil]
cases h.lt_or_eq_dec with h' h'
replace h' := le_of_succ_le_succ h'
{ replace h' := le_of_succ_le_succ h', rwa [take_append_of_le_length, xs_ih _ h'], rw [show xs_tl.length + 1 - n = succ (xs_tl.length - n), from _, drop], { rwa [succ_eq_add_one, nat.sub_add_comm] }, { rwa length_reverse } }
rwa [take_append_of_le_length, xs_ih _ h']
rw [show xs_tl.length + 1 - n = succ (xs_tl.length - n), from _, drop]
{ rwa [succ_eq_add_one, nat.sub_add_comm] }
rwa [succ_eq_add_one, nat.sub_add_comm]
{ rwa length_reverse }
rwa length_reverse
subst h'
{ subst h', rw [length, nat.sub_self, drop], suffices : xs_tl.length + 1 = (xs_tl.reverse ++ [xs_hd]).length, by rw [this, take_length, reverse_cons], rw [length_append, length_reverse], refl }
rw [length, nat.sub_self, drop]
suffices : xs_tl.length + 1 = (xs_tl.reverse ++ [xs_hd]).length
rw [this, take_length, reverse_cons]
rw [this, take_length, reverse_cons]
rw [length_append, length_reverse]
refl
intros
induction l with hd tl ih
{ simp }
simp
rw prod_cons
exact one_le_mul (hl₁ hd (mem_cons_self hd tl)) (ih (λ x h, hl₁ x (mem_cons_of_mem hd h)))
intros
refine ⟨λ H, by simp [H], _⟩
rintros ⟨join_eq, length_eq⟩
apply ext_le
have : length (map length L) = length (map length L')
{ have : length (map length L) = length (map length L'), by rw length_eq, simpa using this }
rw length_eq
rw length_eq
simpa using this
assume n h₁ h₂
{ assume n h₁ h₂, rw [← drop_take_succ_join_eq_nth_le, ← drop_take_succ_join_eq_nth_le, join_eq, length_eq] }
rw [← drop_take_succ_join_eq_nth_le, ← drop_take_succ_join_eq_nth_le, join_eq, length_eq]
intros
refine ⟨_, map_subset f⟩
intros h2 x hx
rcases mem_map.1 (h2 (mem_map_of_mem f hx)) with ⟨x', hx', hxx'⟩
cases h hxx'
exact hx'
intros
induction ys generalizing f; simp *
induction ys generalizing f
simp *
simp *
intros
simp only [reverse_cons, concat_eq_append]
intros
have h' := mem_cons_self l.head l.tail
rwa cons_head_tail h at h'
intros
rw [next, next_or, if_pos hx]
intros
induction bs generalizing start a
{ refl }
refl
simp [foldl_with_index_aux, foldl_with_index_aux_spec_cons, *]
{ simp [foldl_with_index_aux, foldl_with_index_aux_spec_cons, *] }
intros
rw [Ico, Ico, map_add_range', nat.add_sub_add_right, add_comm n k]
intros
rw [range_succ, map_append, map_singleton, prod_append, prod_cons, prod_nil, mul_one]
intros
induction n with n hn generalizing l k
have hk' : k < l.length := by simpa using hk
{ have hk' : k < l.length := by simpa using hk, simp [nat.mod_eq_of_lt hk'] }
simp [nat.mod_eq_of_lt hk']
simp [nat.succ_eq_add_one, ←rotate_rotate, nth_le_rotate_one, hn l, add_comm, add_left_comm]
{ simp [nat.succ_eq_add_one, ←rotate_rotate, nth_le_rotate_one, hn l, add_comm, add_left_comm] }
intros
cases l with x l
{ simp }
simp
rw mem_iff_nth_le
{ rw mem_iff_nth_le, refine ⟨0, by simp, _⟩, simp }
refine ⟨0, by simp, _⟩
simp
intros
simp [lookup_all_eq_lookup, nd₁, nd₂, perm_lookup a nd₁ nd₂ p]
intros
simp [keys, nodupkeys]
intros
simp only [sublists_eq_sublists', length_map, length_sublists', length_reverse]
intros
ext i j
ext i j; simp [mul_apply]
simp [mul_apply]
intros
simp only [matrix.vec_mul, matrix.map_apply, ring_hom.map_dot_product]
intros
simp [dot_product, finset.smul_sum, smul_mul_assoc]
intros
{ ext, simp [mul_vec] }
ext
simp [mul_vec]
intros
simp only [conj_transpose, block_diagonal_transpose]
rw block_diagonal_map _ star (star_zero α)
intros
simp [vec_cons]
intros
{ ext i, refine fin.cases _ _ i; simp }
ext i
refine fin.cases _ _ i
refine fin.cases _ _ i; simp
simp
simp
intros
rw [add_comm, inter_add_distrib, add_comm s, add_comm s]
intros
rw [← inf_erase_dup, erase_dup_ext.2, inf_erase_dup, inf_add]
rw [← inf_erase_dup, erase_dup_ext.2, inf_erase_dup, inf_add]; simp
simp
intros
rw [powerset_len_aux, sublists_len_aux_eq, append_nil]
intros
rw [← zero_add (single s n), monomial_add_single, C_apply]
intros
{ funext x, exact comap_comp_apply _ _ _ }
funext x
exact comap_comp_apply _ _ _
intros
rw [aeval_eq_bind₁, bind₁_X_left]
intros
cases nat.eq_zero_or_pos n with n0 h
{ rw [n0, zero_mul], exact m.zero_le }
rw [n0, zero_mul]
exact m.zero_le
{ rw [mul_comm, ← nat.le_div_iff_mul_le' h] }
rw [mul_comm, ← nat.le_div_iff_mul_le' h]
intros
rw [← image_singleton, range_comp, ← image_union, zero_union_range_succ, image_univ]
intros
rw add_comm; apply dist_tri_left
rw add_comm
apply dist_tri_left
intros
rw [coprime_iff_gcd_eq_one, gcd_div (gcd_dvd_left m n) (gcd_dvd_right m n), nat.div_self H]
intros
split
intro H
{ intro H, rw [eq_Ici_of_nonempty_of_upward_closed (nonempty_of_Inf_eq_succ H) hs, H, mem_Ici, mem_Ici], exact ⟨le_refl _, k.not_succ_le_self⟩, }
rw [eq_Ici_of_nonempty_of_upward_closed (nonempty_of_Inf_eq_succ H) hs, H, mem_Ici, mem_Ici]
exact ⟨le_refl _, k.not_succ_le_self⟩
rintro ⟨H, H'⟩
{ rintro ⟨H, H'⟩, rw [Inf_def (⟨_, H⟩ : s.nonempty), find_eq_iff], exact ⟨H, λ n hnk hns, H' $ hs n k (lt_succ_iff.mp hnk) hns⟩, }
rw [Inf_def (⟨_, H⟩ : s.nonempty), find_eq_iff]
exact ⟨H, λ n hnk hns, H' $ hs n k (lt_succ_iff.mp hnk) hns⟩
intros
simp
intros
cases n; refl
cases n
refl
refl
intros
rw [← to_nat_to_int, int.cast_coe_nat, cast_to_nat]
intros
rw [← num.succ'_to_nat, n.succ'_pred']
intros
cases o; refl
cases o
refl
refl
intros
suffices : @size α r ≤ 3 * (size l + 1)
cases nat.eq_zero_or_pos (size l) with l0 l0
{ cases nat.eq_zero_or_pos (size l) with l0 l0, { apply or.inr, rwa l0 at this }, change 1 ≤ _ at l0, apply or.inl, linarith }
{ apply or.inr, rwa l0 at this }
apply or.inr
rwa l0 at this
change 1 ≤ _ at l0
apply or.inl
linarith
rcases H2 with ⟨hl, rfl⟩ | ⟨hr, rfl⟩; rcases H1 with h | ⟨h₁, h₂⟩
rcases H2 with ⟨hl, rfl⟩ | ⟨hr, rfl⟩
rcases H1 with h | ⟨h₁, h₂⟩
exact le_trans (nat.le_add_left _ _) (le_trans h (nat.le_add_left _ _))
{ exact le_trans (nat.le_add_left _ _) (le_trans h (nat.le_add_left _ _)) }
exact le_trans h₂ (nat.mul_le_mul_left _ $ le_trans (nat.dist_tri_right _ _) (nat.add_le_add_left hl _))
{ exact le_trans h₂ (nat.mul_le_mul_left _ $ le_trans (nat.dist_tri_right _ _) (nat.add_le_add_left hl _)) }
rcases H1 with h | ⟨h₁, h₂⟩
exact le_trans (nat.dist_tri_left' _ _) (le_trans (add_le_add hr (le_trans (nat.le_add_left _ _) h)) dec_trivial)
{ exact le_trans (nat.dist_tri_left' _ _) (le_trans (add_le_add hr (le_trans (nat.le_add_left _ _) h)) dec_trivial) }
rw nat.mul_succ
{ rw nat.mul_succ, exact le_trans (nat.dist_tri_right' _ _) (add_le_add h₂ (le_trans hr dec_trivial)) }
exact le_trans (nat.dist_tri_right' _ _) (add_le_add h₂ (le_trans hr dec_trivial))
intros
simp [node3_l, node3_r, dual_node']
intros
{ cases t, { contradiction }, { simp [h.1] } }
cases t
contradiction
{ contradiction }
simp [h.1]
{ simp [h.1] }
intros
rw ← mem_iff_mem at *; cases h : f.symm b; simp * at *
rw ← mem_iff_mem at *; cases h : f.symm b
rw ← mem_iff_mem at *
cases h : f.symm b
simp * at *
simp * at *
intros
rw [preimage_eq, set.union_distrib_right, set.union_comm (dom f), set.compl_union_self, set.inter_univ, set.union_eq_self_of_subset_right (f.compl_dom_subset_core s)]
intros
refl
intros
cases x; refl
cases x
refl
intros
let h₀ := nat.mod_add_div (m : ℕ) (k : ℕ)
have : ¬ ((m : ℕ) % (k : ℕ) = 0 ∧ (m : ℕ) / (k : ℕ) = 0)
rintro ⟨hr, hq⟩
rintro ⟨hr, hq⟩
{ rintro ⟨hr, hq⟩, rw [hr, hq, mul_zero, zero_add] at h₀, exact (m.ne_zero h₀.symm).elim }
{ rintro ⟨hr, hq⟩, rw [hr, hq, mul_zero, zero_add] at h₀, exact (m.ne_zero h₀.symm).elim }
rw [hr, hq, mul_zero, zero_add] at h₀
rw [hr, hq, mul_zero, zero_add] at h₀
exact (m.ne_zero h₀.symm).elim
exact (m.ne_zero h₀.symm).elim
have := mod_div_aux_spec k ((m : ℕ) % (k : ℕ)) ((m : ℕ) / (k : ℕ)) this
exact (this.trans h₀)
intros
let h := @pnat.factor_multiset_le_iff' u.prod v
{ let h := @pnat.factor_multiset_le_iff' u.prod v, rw [u.factor_multiset_prod] at h, exact h.symm }
rw [u.factor_multiset_prod] at h
exact h.symm
intros
simp only [monomial, monomial_fun, linear_map.coe_mk, mul_to_finsupp, add_monoid_algebra.single_mul_single]
intros
set f' : add_monoid_algebra R ℕ →+ M := f.comp (to_finsupp_iso R).symm with hf'
set g' : add_monoid_algebra R ℕ →+ M := g.comp (to_finsupp_iso R).symm with hg'
have : ∀ n a, f' (single n a) = g' (single n a) := λ n, by simp [hf', hg', h n]
have A : f' = g' := finsupp.add_hom_ext this
have B : f = f'.comp (to_finsupp_iso R)
rw [hf', add_monoid_hom.comp_assoc]
rw [hf', add_monoid_hom.comp_assoc]
{ rw [hf', add_monoid_hom.comp_assoc], ext x, simp only [ring_equiv.symm_apply_apply, add_monoid_hom.coe_comp, function.comp_app, ring_hom.coe_add_monoid_hom, ring_equiv.coe_to_ring_hom, coe_coe]}
{ rw [hf', add_monoid_hom.comp_assoc], ext x, simp only [ring_equiv.symm_apply_apply, add_monoid_hom.coe_comp, function.comp_app, ring_hom.coe_add_monoid_hom, ring_equiv.coe_to_ring_hom, coe_coe]}
ext x
ext x
simp only [ring_equiv.symm_apply_apply, add_monoid_hom.coe_comp, function.comp_app, ring_hom.coe_add_monoid_hom, ring_equiv.coe_to_ring_hom, coe_coe]
simp only [ring_equiv.symm_apply_apply, add_monoid_hom.coe_comp, function.comp_app, ring_hom.coe_add_monoid_hom, ring_equiv.coe_to_ring_hom, coe_coe]
have C : g = g'.comp (to_finsupp_iso R)
rw [hg', add_monoid_hom.comp_assoc]
rw [hg', add_monoid_hom.comp_assoc]
{ rw [hg', add_monoid_hom.comp_assoc], ext x, simp only [ring_equiv.symm_apply_apply, add_monoid_hom.coe_comp, function.comp_app, ring_hom.coe_add_monoid_hom, ring_equiv.coe_to_ring_hom, coe_coe]}
{ rw [hg', add_monoid_hom.comp_assoc], ext x, simp only [ring_equiv.symm_apply_apply, add_monoid_hom.coe_comp, function.comp_app, ring_hom.coe_add_monoid_hom, ring_equiv.coe_to_ring_hom, coe_coe]}
ext x
ext x
simp only [ring_equiv.symm_apply_apply, add_monoid_hom.coe_comp, function.comp_app, ring_hom.coe_add_monoid_hom, ring_equiv.coe_to_ring_hom, coe_coe]
simp only [ring_equiv.symm_apply_apply, add_monoid_hom.coe_comp, function.comp_app, ring_hom.coe_add_monoid_hom, ring_equiv.coe_to_ring_hom, coe_coe]
rw [B, C, A]
intros
simp
intros
rw [monic.def, leading_coeff_zero] at h; exact ⟨λ p q, by rw [← mul_one p, ← mul_one q, ← C_1, ← h, C_0, mul_zero, mul_zero], λ a b, by rw [← mul_one a, ← mul_one b, ← h, mul_zero, mul_zero]⟩
rw [monic.def, leading_coeff_zero] at h
exact ⟨λ p q, by rw [← mul_one p, ← mul_one q, ← C_1, ← h, C_0, mul_zero, mul_zero], λ a b, by rw [← mul_one a, ← mul_one b, ← h, mul_zero, mul_zero]⟩
intros
simp only [coeff_nat_degree, coeff_mul_degree_add_degree]
intros
rw [derivative_apply, sum_monomial_index, C_mul_X_pow_eq_monomial]
{ rw [derivative_apply, sum_monomial_index, C_mul_X_pow_eq_monomial], simp }
simp
intros
rw eval₂_mul f x
exact mul_eq_zero_of_right (p.eval₂ f x) hq
intros
rw [bit1, eval₂_add, eval₂_bit0, eval₂_one, bit1]
intros
simpa only [monic, leading_coeff_zero] using (zero_ne_one : (0 : R) ≠ 1)
intros
simp [reverse]
intros
rw [← with_bot.coe_eq_coe, ← degree_eq_nat_degree (mul_ne_zero hp hq), with_bot.coe_add, ← degree_eq_nat_degree hp, ← degree_eq_nat_degree hq, degree_mul]
intros
ext
ext; apply mem_supp
apply mem_supp
intros
by_cases d0 : d = 0
simp [d0, div_zero]
{simp [d0, div_zero]}
simp [division_def, coe_int_eq_mk, mul_def one_ne_zero d0]
intros
by_cases h : a = 0
{ rw [h, zero_mul, zero_to_nnreal] }
rw [h, zero_mul, zero_to_nnreal]
{ rw [mul_top, if_neg h, top_to_nnreal] }
rw [mul_top, if_neg h, top_to_nnreal]
intros
simp [bit1]
intros
unfold bit1; simp
unfold bit1
simp
intros
induction x using ereal.rec; induction y using ereal.rec; simp [← ereal.coe_add]
induction x using ereal.rec; induction y using ereal.rec
induction x using ereal.rec
induction y using ereal.rec
simp [← ereal.coe_add]
simp [← ereal.coe_add]
simp [← ereal.coe_add]
induction y using ereal.rec
simp [← ereal.coe_add]
simp [← ereal.coe_add]
simp [← ereal.coe_add]
induction y using ereal.rec
simp [← ereal.coe_add]
simp [← ereal.coe_add]
simp [← ereal.coe_add]
{field_simp, rw ← sq_sub_sq, norm_num}
field_simp
rw ← sq_sub_sq
norm_num
intros
rw [←infinite_pos_iff_infinite_of_nonneg (abs_nonneg _), infinite_iff_infinite_pos_abs]
intros
rw [← nnreal.coe_one, nnreal.coe_eq]
intros
simp [pos_iff_ne_zero]
pi_upper_bound [ 4756/3363, 101211/54775, 505534/257719, 83289/41846, 411278/205887, 438142/219137, 451504/225769, 265603/132804, 849938/424971]
intros
rw [sqrt, sqrt, nnreal.coe_le_coe, nnreal.sqrt_le_sqrt_iff, real.to_nnreal_le_to_nnreal_iff hy]
intros
simp [core]
intros
haveI := terminates_of_mem h; exact ⟨_, results_of_terminates' s h⟩
haveI := terminates_of_mem h
exact ⟨_, results_of_terminates' s h⟩
intros
refine eq_of_bisim (λ s1 s2, ∃ s, s1 = f s ∧ s2 = g s) _ ⟨s, rfl, rfl⟩
intros s1 s2 h
rcases h with ⟨s, h1, h2⟩
rw [h1, h2]
apply H
intros
apply coinduction2 s; intro s; apply cases_on s; simp [ret]
apply coinduction2 s; intro s; apply cases_on s
apply coinduction2 s; intro s
apply coinduction2 s
intro s
apply cases_on s
simp [ret]
simp [ret]
intros
rw ← image_univ; exact image_subset _ (subset_univ _)
rw ← image_univ
exact image_subset _ (subset_univ _)
intros
intros s t h
{ intros s t h, rw [←preimage_image_eq s hf, ←preimage_image_eq t hf, h] }
rw [←preimage_image_eq s hf, ←preimage_image_eq t hf, h]
intros
rw [← mk_preimage_prod_right_eq_if, prod_preimage_right, preimage_preimage]
intros
{ cases x, refl }
cases x
refl
intros
simp [diagonal]
intros
rw [←image_univ, infinite_image_iff (inj_on_of_injective hi _)]
{ rw [←image_univ, infinite_image_iff (inj_on_of_injective hi _)], exact infinite_univ }
exact infinite_univ
intros
split
intros h x
{ intros h x, rw [←finite.mem_to_finset hs, ←finite.mem_to_finset ht], exact λ hx, h hx }
rw [←finite.mem_to_finset hs, ←finite.mem_to_finset ht]
exact λ hx, h hx
intros h x
{ intros h x, rw [finite.mem_to_finset hs, finite.mem_to_finset ht], exact λ hx, h hx }
rw [finite.mem_to_finset hs, finite.mem_to_finset ht]
exact λ hx, h hx
intros
split
rcases eq_empty_or_nonempty t with rfl|ht
{ rcases eq_empty_or_nonempty t with rfl|ht, { exact λ _, ⟨∅, empty_subset _, bij_on_empty f⟩ }, { assume h, haveI : nonempty α := ⟨classical.some (h.comap_nonempty ht)⟩, exact ⟨_, h.maps_to_inv_fun_on.image_subset, h.bij_on_subset⟩ }}
{ exact λ _, ⟨∅, empty_subset _, bij_on_empty f⟩ }
exact λ _, ⟨∅, empty_subset _, bij_on_empty f⟩
assume h
{ assume h, haveI : nonempty α := ⟨classical.some (h.comap_nonempty ht)⟩, exact ⟨_, h.maps_to_inv_fun_on.image_subset, h.bij_on_subset⟩ }
haveI : nonempty α := ⟨classical.some (h.comap_nonempty ht)⟩
exact ⟨_, h.maps_to_inv_fun_on.image_subset, h.bij_on_subset⟩
rintros ⟨s', hs', hfs'⟩
{ rintros ⟨s', hs', hfs'⟩, exact hfs'.surj_on.mono hs' (subset.refl _) }
exact hfs'.surj_on.mono hs' (subset.refl _)
intros
ext1 x
simp_rw [mem_union, mem_Icc, min_le_iff, le_max_iff]
by_cases hc : c ≤ x; by_cases hd : x ≤ d
by_cases hc : c ≤ x
by_cases hd : x ≤ d
{ tauto }
tauto
have hax : a ≤ x := h₂.trans (le_of_not_ge hd)
{ have hax : a ≤ x := h₂.trans (le_of_not_ge hd), tauto }
tauto
by_cases hd : x ≤ d
have hxb : x ≤ b := (le_of_not_ge hc).trans h₁
{ have hxb : x ≤ b := (le_of_not_ge hc).trans h₁, tauto }
tauto
{ tauto }
tauto
intros
rw [e.image_eq_preimage, e.symm.preimage_Iic, e.symm_symm]
intros
simp [← Ici_inter_Iic]
intros
simp [lt_irrefl]
intros
simp [← Ici_inter_Iic, inter_comm]
intros
simp [sub_eq_neg_add]
intros
intros p hp
rw [mem_Ici, le_iff_lt_or_eq] at hp
rcases hp with hp'|hp'
cases (surj_on_Ioi_of_monotone_surjective h_mono h_surj a hp') with x hx
{ cases (surj_on_Ioi_of_monotone_surjective h_mono h_surj a hp') with x hx, exact ⟨x, Ioi_subset_Ici_self hx.1, hx.2⟩ }
exact ⟨x, Ioi_subset_Ici_self hx.1, hx.2⟩
rw ← hp'
{ rw ← hp', refine ⟨a, left_mem_Ici, rfl⟩ }
refine ⟨a, left_mem_Ici, rfl⟩
intros
simp only [← image_prod, Union_prod_const, image_Union]
intros
rintro x ⟨_, ⟨i, rfl⟩, hx⟩ _ ⟨j, rfl⟩
{ rintro x ⟨_, ⟨i, rfl⟩, hx⟩ _ ⟨j, rfl⟩, exact ⟨_, ⟨i, rfl⟩, hx _ ⟨j, rfl⟩⟩ }
exact ⟨_, ⟨i, rfl⟩, hx _ ⟨j, rfl⟩⟩
intros
rw [sUnion_eq_compl_sInter_compl, compl_compl_image]
intros
refl
intros
rw [←cons_head_tail v]
simp only [scanl_cons, scanl_nil, cons_head, singleton_tail]
intros
dsimp only [vector.zip_with, vector.nth]
cases x
cases y
simp only [list.nth_le_zip_with, subtype.coe_mk]
congr
intros
change (a : zmod b) = ((0 : ℕ) : zmod b) ↔ b ∣ a
rw [zmod.nat_coe_eq_nat_coe_iff, nat.modeq_zero_iff_dvd]
intros
refine {..}
refine {..}; intros; refl
refine {..}; intros
intros
refl
intros
refl
intros
refl
intros
simp only [omega_limit, image2_image_right]
intros
rw [is_periodic_pt, iterate_add] at hn
{ rw [is_periodic_pt, iterate_add] at hn, exact hn.left_of_comp hm }
exact hn.left_of_comp hm
intros
{ rw [eq_bot_iff, adjoin_le_iff], refl, }
rw [eq_bot_iff, adjoin_le_iff]
refl
intros
letI := classical.dec_eq R; exact suffices ¬ disjoint (univ.image (λ x : R, eval x f)) (univ.image (λ x : R, eval x (-g))), begin simp only [disjoint_left, mem_image] at this, push_neg at this, rcases this with ⟨x, ⟨a, _, ha⟩, ⟨b, _, hb⟩⟩, exact ⟨a, b, by rw [ha, ← hb, eval_neg, neg_add_self]⟩ end, assume hd : disjoint _ _, lt_irrefl (2 * ((univ.image (λ x : R, eval x f)) ∪ (univ.image (λ x : R, eval x (-g)))).card) $ calc 2 * ((univ.image (λ x : R, eval x f)) ∪ (univ.image (λ x : R, eval x (-g)))).card ≤ 2 * fintype.card R : nat.mul_le_mul_left _ (finset.card_le_univ _) ... = fintype.card R + fintype.card R : two_mul _ ... < nat_degree f * (univ.image (λ x : R, eval x f)).card + nat_degree (-g) * (univ.image (λ x : R, eval x (-g))).card : add_lt_add_of_lt_of_le (lt_of_le_of_ne (card_image_polynomial_eval (by rw hf2; exact dec_trivial)) (mt (congr_arg (%2)) (by simp [nat_degree_eq_of_degree_eq_some hf2, hR]))) (card_image_polynomial_eval (by rw [degree_neg, hg2]; exact dec_trivial)) ... = 2 * (univ.image (λ x : R, eval x f) ∪ univ.image (λ x : R, eval x (-g))).card : by rw [card_disjoint_union hd]; simp [nat_degree_eq_of_degree_eq_some hf2, nat_degree_eq_of_degree_eq_some hg2, bit0, mul_add]
letI := classical.dec_eq R
exact suffices ¬ disjoint (univ.image (λ x : R, eval x f)) (univ.image (λ x : R, eval x (-g))), begin simp only [disjoint_left, mem_image] at this, push_neg at this, rcases this with ⟨x, ⟨a, _, ha⟩, ⟨b, _, hb⟩⟩, exact ⟨a, b, by rw [ha, ← hb, eval_neg, neg_add_self]⟩ end, assume hd : disjoint _ _, lt_irrefl (2 * ((univ.image (λ x : R, eval x f)) ∪ (univ.image (λ x : R, eval x (-g)))).card) $ calc 2 * ((univ.image (λ x : R, eval x f)) ∪ (univ.image (λ x : R, eval x (-g)))).card ≤ 2 * fintype.card R : nat.mul_le_mul_left _ (finset.card_le_univ _) ... = fintype.card R + fintype.card R : two_mul _ ... < nat_degree f * (univ.image (λ x : R, eval x f)).card + nat_degree (-g) * (univ.image (λ x : R, eval x (-g))).card : add_lt_add_of_lt_of_le (lt_of_le_of_ne (card_image_polynomial_eval (by rw hf2; exact dec_trivial)) (mt (congr_arg (%2)) (by simp [nat_degree_eq_of_degree_eq_some hf2, hR]))) (card_image_polynomial_eval (by rw [degree_neg, hg2]; exact dec_trivial)) ... = 2 * (univ.image (λ x : R, eval x f) ∪ univ.image (λ x : R, eval x (-g))).card : by rw [card_disjoint_union hd]; simp [nat_degree_eq_of_degree_eq_some hf2, nat_degree_eq_of_degree_eq_some hg2, bit0, mul_add]
intros
rw fintype.bijective_iff_injective_and_card
split
{ exact mul_semiring_action.to_alg_hom_injective _ F }
exact mul_semiring_action.to_alg_hom_injective _ F
apply le_antisymm
{ apply le_antisymm, { exact fintype.card_le_of_injective _ (mul_semiring_action.to_alg_hom_injective _ F) }, { rw ← finrank_eq_card G F, exact has_le.le.trans_eq (finrank_alg_hom _ F) (finrank_linear_map' _ _ _) } }
exact fintype.card_le_of_injective _ (mul_semiring_action.to_alg_hom_injective _ F)
{ exact fintype.card_le_of_injective _ (mul_semiring_action.to_alg_hom_injective _ F) }
rw ← finrank_eq_card G F
{ rw ← finrank_eq_card G F, exact has_le.le.trans_eq (finrank_alg_hom _ F) (finrank_linear_map' _ _ _) }
exact has_le.le.trans_eq (finrank_alg_hom _ F) (finrank_linear_map' _ _ _)
intros
{ contrapose! h, simpa only [hx, coeff_zero_eq_zero] using h }
contrapose! h
simpa only [hx, coeff_zero_eq_zero] using h
intros
conv_lhs { rw ←reflection_reflection s p₁ }
exact (reflection s).dist_map _ _
intros
rw [← sq_eq_sq (norm_nonneg (x - y)) (abs_nonneg (∥x∥ - ∥y∥)), norm_sub_pow_two_real, inner_eq_mul_norm_of_angle_eq_zero h, sq_abs (∥x∥ - ∥y∥)]
ring
intros
haveI : nonempty (⊤ : affine_subspace ℝ P) := set.univ.nonempty
rw [←finrank_top, ←direction_top ℝ V P] at hd
refine exists_circumcenter_eq_of_cospherical_subset _ hd hc
exact set.subset_univ _
intros
simp only [← unique_mdiff_on_iff_unique_diff_on, unique_mdiff_on_image, hn]
intros
have : s = univ ∩ s
rw univ_inter
rw univ_inter
rwa [this, hG.lift_prop_within_at_inter hs]
intros
refine and_congr iff.rfl (exists_congr $ λ f', _)
rw [inter_comm]
simp only [has_fderiv_within_at, nhds_within_inter, nhds_within_ext_chart_target_eq]
intros
apply @filter.mem_of_superset _ _ ((f ∘ (ext_chart_at I x).symm)⁻¹' (ext_chart_at I' (f x)).source) _ (ext_chart_preimage_mem_nhds_within I x (h.preimage_mem_nhds_within (ext_chart_at_source_mem_nhds _ _)))
mfld_set_tac
intros
rw inter_comm
{ rw inter_comm, exact I.unique_diff.inter (hs.preimage I.continuous_inv_fun) }
exact I.unique_diff.inter (hs.preimage I.continuous_inv_fun)
intros
rw [← times_cont_mdiff_within_at_univ, times_cont_mdiff_within_at_iff_times_cont_diff_within_at, times_cont_diff_within_at_univ]
intros
suffices h : mdifferentiable_within_at I I' f (s ∩ (f ⁻¹' (ext_chart_at I' (f x)).source)) x
rwa mdifferentiable_within_at_inter' at h
{ rwa mdifferentiable_within_at_inter' at h, apply (hf.1).preimage_mem_nhds_within, exact is_open.mem_nhds (ext_chart_at_open_source I' (f x)) (mem_ext_chart_source I' (f x)) }
apply (hf.1).preimage_mem_nhds_within
exact is_open.mem_nhds (ext_chart_at_open_source I' (f x)) (mem_ext_chart_source I' (f x))
rw mdifferentiable_within_at_iff
exact ⟨hf.1.mono (inter_subset_left _ _), (hf.2.differentiable_within_at hn).mono (by mfld_set_tac)⟩
intros
simp [left_coset, right_coset, (image_comp _ _ _).symm, function.comp, mul_assoc]
intros
{ ext, simp [quotient_group.eq] }
ext
simp [quotient_group.eq]
intros
rw [eq_comm, mul_inv_left h, mul_comm, eq_comm]
intros
ext
rw [lift_spec, ←hj, ←hj, ←j.map_mul]
apply congr_arg
rw ←sec_spec'
intros
rw [lower_central_series_succ, closure_eq_bot_iff, set.subset_singleton_iff]
rintro x ⟨y, hy1, z, ⟨⟩, rfl⟩
symmetry
rw [eq_mul_inv_iff_mul_eq, eq_mul_inv_iff_mul_eq, one_mul]
exact mem_center_iff.mp (h hy1) z
intros
obtain ⟨c, g', rfl, hd, hc, rfl⟩ := mem_cycle_type_iff.1 hng
by_cases g'1 : g' = 1
rw [hd.cycle_type, hc.cycle_type, multiset.singleton_eq_cons, multiset.singleton_coe, g'1, cycle_type_one, add_zero]
{ rw [hd.cycle_type, hc.cycle_type, multiset.singleton_eq_cons, multiset.singleton_coe, g'1, cycle_type_one, add_zero] }
contrapose! hn2
apply le_trans _ (c * g').support.card_le_univ
rw [hd.card_support_mul]
exact add_le_add_left (two_le_card_support_of_ne_one g'1) _
intros
rw cycle_factors_finset_eq_finset
split
simp only [mem_cycle_factors_finset_iff, mem_union]
{ simp only [mem_cycle_factors_finset_iff, mem_union], rintro _ (⟨h, -⟩ | ⟨h, -⟩); exact h }
rintro _ (⟨h, -⟩ | ⟨h, -⟩); exact h
rintro _ (⟨h, -⟩ | ⟨h, -⟩)
exact h
exact h
exact h
exact h
refine ⟨_, _⟩
{ refine ⟨_, _⟩, { simp_rw mem_union, rintros x (hx | hx) y (hy | hy) hxy, { exact cycle_factors_finset_pairwise_disjoint _ _ hx _ hy hxy }, { exact h.mono (mem_cycle_factors_finset_support_le hx) (mem_cycle_factors_finset_support_le hy) }, { exact h.symm.mono (mem_cycle_factors_finset_support_le hx) (mem_cycle_factors_finset_support_le hy) }, { exact cycle_factors_finset_pairwise_disjoint _ _ hx _ hy hxy } }, { rw noncomm_prod_union_of_disjoint h.disjoint_cycle_factors_finset, rw [cycle_factors_finset_noncomm_prod, cycle_factors_finset_noncomm_prod] } }
simp_rw mem_union
{ simp_rw mem_union, rintros x (hx | hx) y (hy | hy) hxy, { exact cycle_factors_finset_pairwise_disjoint _ _ hx _ hy hxy }, { exact h.mono (mem_cycle_factors_finset_support_le hx) (mem_cycle_factors_finset_support_le hy) }, { exact h.symm.mono (mem_cycle_factors_finset_support_le hx) (mem_cycle_factors_finset_support_le hy) }, { exact cycle_factors_finset_pairwise_disjoint _ _ hx _ hy hxy } }
rintros x (hx | hx) y (hy | hy) hxy
{ exact cycle_factors_finset_pairwise_disjoint _ _ hx _ hy hxy }
exact cycle_factors_finset_pairwise_disjoint _ _ hx _ hy hxy
exact h.mono (mem_cycle_factors_finset_support_le hx) (mem_cycle_factors_finset_support_le hy)
{ exact h.mono (mem_cycle_factors_finset_support_le hx) (mem_cycle_factors_finset_support_le hy) }
exact h.symm.mono (mem_cycle_factors_finset_support_le hx) (mem_cycle_factors_finset_support_le hy)
{ exact h.symm.mono (mem_cycle_factors_finset_support_le hx) (mem_cycle_factors_finset_support_le hy) }
{ exact cycle_factors_finset_pairwise_disjoint _ _ hx _ hy hxy }
exact cycle_factors_finset_pairwise_disjoint _ _ hx _ hy hxy
rw noncomm_prod_union_of_disjoint h.disjoint_cycle_factors_finset
{ rw noncomm_prod_union_of_disjoint h.disjoint_cycle_factors_finset, rw [cycle_factors_finset_noncomm_prod, cycle_factors_finset_noncomm_prod] }
rw [cycle_factors_finset_noncomm_prod, cycle_factors_finset_noncomm_prod]
intros
rcases l with (_ | ⟨x, _ | ⟨y, l⟩⟩)
suffices : l'.length ≤ 1 ↔ l' = nil ∨ l'.length ≤ 1
{ suffices : l'.length ≤ 1 ↔ l' = nil ∨ l'.length ≤ 1, { simpa [eq_comm, form_perm_eq_one_iff, hl, hl', length_eq_zero] }, refine ⟨λ h, or.inr h, _⟩, rintro (rfl | h), { simp }, { exact h } }
{ simpa [eq_comm, form_perm_eq_one_iff, hl, hl', length_eq_zero] }
simpa [eq_comm, form_perm_eq_one_iff, hl, hl', length_eq_zero]
refine ⟨λ h, or.inr h, _⟩
rintro (rfl | h)
{ simp }
simp
{ exact h }
exact h
suffices : l'.length ≤ 1 ↔ [x] ~r l' ∨ l'.length ≤ 1
{ suffices : l'.length ≤ 1 ↔ [x] ~r l' ∨ l'.length ≤ 1, { simpa [eq_comm, form_perm_eq_one_iff, hl, hl', length_eq_zero, le_rfl] }, refine ⟨λ h, or.inr h, _⟩, rintro (h | h), { simp [←h.perm.length_eq] }, { exact h } }
{ simpa [eq_comm, form_perm_eq_one_iff, hl, hl', length_eq_zero, le_rfl] }
simpa [eq_comm, form_perm_eq_one_iff, hl, hl', length_eq_zero, le_rfl]
refine ⟨λ h, or.inr h, _⟩
rintro (h | h)
{ simp [←h.perm.length_eq] }
simp [←h.perm.length_eq]
{ exact h }
exact h
rcases l' with (_ | ⟨x', _ | ⟨y', l'⟩⟩)
{ rcases l' with (_ | ⟨x', _ | ⟨y', l'⟩⟩), { simp [form_perm_eq_one_iff, hl, -form_perm_cons_cons] }, { suffices : ¬ (x :: y :: l) ~r [x'], { simp [form_perm_eq_one_iff, hl, -form_perm_cons_cons] }, intro h, simpa using h.perm.length_eq }, { simp [-form_perm_cons_cons, form_perm_ext_iff hl hl'] } }
{ simp [form_perm_eq_one_iff, hl, -form_perm_cons_cons] }
simp [form_perm_eq_one_iff, hl, -form_perm_cons_cons]
suffices : ¬ (x :: y :: l) ~r [x']
{ suffices : ¬ (x :: y :: l) ~r [x'], { simp [form_perm_eq_one_iff, hl, -form_perm_cons_cons] }, intro h, simpa using h.perm.length_eq }
{ simp [form_perm_eq_one_iff, hl, -form_perm_cons_cons] }
simp [form_perm_eq_one_iff, hl, -form_perm_cons_cons]
intro h
simpa using h.perm.length_eq
{ simp [-form_perm_cons_cons, form_perm_ext_iff hl hl'] }
simp [-form_perm_cons_cons, form_perm_ext_iff hl hl']
intros
ext
ext; simp [right_hom]
simp [right_hom]
intros
simp [line_map_apply]
intros
tidy
intros
simp [weighted_vsub, linear_map.sum_apply]
intros
{ ext, simp [face_points] }
ext
simp [face_points]
intros
rw [slope, sub_self, inv_zero, zero_smul]
intros
rw [← range_le_bot_iff, le_bot_iff]
intros
rw [finsupp.sum_smul_index', finsupp.smul_sum]
{ simp only [linear_map.map_smul], }
simp only [linear_map.map_smul]
{ intro i, exact (h i).map_zero }
intro i
exact (h i).map_zero
intros
split
split; intros h
intros h
ext
{ ext, cases hₗ x with x' hx, subst hx, cases hᵣ y with y' hy, subst hy, rw [←comp_apply, ←comp_apply, h], }
cases hₗ x with x' hx
subst hx
cases hᵣ y with y' hy
subst hy
rw [←comp_apply, ←comp_apply, h]
intros h
{ subst h, }
subst h
intros
{ rw [←@zero_smul R _ _ _ _ (0 : M), smul_left, zero_mul] }
rw [←@zero_smul R _ _ _ _ (0 : M), smul_left, zero_mul]
intros
simp [e.det_apply]
intros
simpa using lift_dim_range_le f
intros
refine b.ext (λ i, b.dual_basis.ext (λ j, _))
rw [linear_map.comp_apply, to_dual_apply_left, coe_to_dual_self, ← coe_dual_basis, dual.eval_apply, basis.repr_self, finsupp.single_apply, dual_basis_apply_self]
intros
apply p.induction_on
{ intro a, simp [module.algebra_map_End_apply] }
intro a
simp [module.algebra_map_End_apply]
{ intros p q hp hq, simp [hp, hq, add_smul] }
intros p q hp hq
simp [hp, hq, add_smul]
intros n a hna
{ intros n a hna, rw [mul_comm, pow_succ, mul_assoc, alg_hom.map_mul, linear_map.mul_apply, mul_comm, hna], simp [algebra_map_End_apply, mem_eigenspace_iff.1 h.1, smul_smul, mul_comm] }
rw [mul_comm, pow_succ, mul_assoc, alg_hom.map_mul, linear_map.mul_apply, mul_comm, hna]
simp [algebra_map_End_apply, mem_eigenspace_iff.1 h.1, smul_smul, mul_comm]
intros
refine supr_le (assume a₁, supr_le $ assume h₁, range_le_iff_comap.2 _)
simp only [(ker_comp _ _).symm, eq_top_iff, set_like.le_def, mem_ker, comap_infi, mem_infi]
assume b hb a₂ h₂
have : a₁ ≠ a₂ := assume eq, h ⟨h₁, eq.symm ▸ h₂⟩
exact single_eq_of_ne this
intros
rw [finsupp.total_on, linear_map.range_eq_map, linear_map.map_cod_restrict, ← linear_map.range_le_iff_comap, range_subtype, map_top, linear_map.range_comp, range_subtype]
exact (span_image_eq_map_total _ _).le
intros
rw submodule.eq_bot_iff
intros x hx
refine congr_arg coe (show (⟨x, hNO hx⟩ : O) = 0, from b.ext_elem (λ i, _))
rw (eq_bot_iff_generator_eq_zero _).mpr hgen at hϕ
rw [linear_equiv.map_zero, finsupp.zero_apply]
refine (submodule.eq_bot_iff _).mp (hϕ ((finsupp.lapply i) ∘ₗ ↑b.repr) bot_le) _ _
exact (linear_map.mem_submodule_image_of_le hNO).mpr ⟨x, hx, rfl⟩
intros
haveI := classical.dec_eq ι'
{ haveI := classical.dec_eq ι', rw [←@basis_to_matrix_mul_linear_map_to_matrix _ _ ι, to_matrix_id, matrix.mul_one] }
rw [←@basis_to_matrix_mul_linear_map_to_matrix _ _ ι, to_matrix_id, matrix.mul_one]
intros
rw [coeff_zero_eq_eval_zero, charpoly, eval_det, mat_poly_equiv_charmatrix, ← det_smul]
simp
intros
rw [det_apply', det_apply']
apply fintype.sum_equiv (equiv.perm_congr e)
intro σ
rw equiv.perm.sign_perm_congr e σ
congr' 1
apply fintype.prod_equiv e
intro i
rw [equiv.perm_congr_apply, equiv.symm_apply_apply, minor_apply]
intros
ext j
simp_rw [linear_map.comp_apply, to_lin'_apply, mul_vec_diagonal, linear_map.smul_apply, pi.smul_apply, algebra.id.smul_eq_mul]
by_cases i = j
{ subst h }
subst h
rw [std_basis_ne R (λ_:n, R) _ _ (ne.symm h), _root_.mul_zero, _root_.mul_zero]
{ rw [std_basis_ne R (λ_:n, R) _ _ (ne.symm h), _root_.mul_zero, _root_.mul_zero] }
intros
simp only [one_div, inv_pow']
intros
ext i j
simp [subsingleton.elim i j, adjugate_apply, det_eq_elem_of_subsingleton _ i]
intros
refine inv_eq_left_inv _
rw [smul_mul, mul_adjugate, units.smul_def, smul_smul, h.coe_inv_mul, one_smul]
intros
ext
{ ext, rw [matrix.one_apply, linear_map.to_matrix_alg_equiv'_apply, id_apply] }
rw [matrix.one_apply, linear_map.to_matrix_alg_equiv'_apply, id_apply]
intros
simp_rw ←tprod_coeff_eq_smul_tprod at C1
exact pi_tensor_product.induction_on' z @C1 @Cp
intros
refine le_antisymm _ (sup_le (map_le_iff_le_comap.2 _) (map_le_iff_le_comap.2 _))
rw set_like.le_def
{ rw set_like.le_def, rintro _ ⟨x, ⟨h₁, h₂⟩, rfl⟩, exact mem_sup.2 ⟨_, ⟨_, h₁, rfl⟩, _, ⟨_, h₂, rfl⟩, rfl⟩ }
rintro _ ⟨x, ⟨h₁, h₂⟩, rfl⟩
exact mem_sup.2 ⟨_, ⟨_, h₁, rfl⟩, _, ⟨_, h₂, rfl⟩, rfl⟩
{ exact λ x hx, ⟨(x, 0), by simp [hx]⟩ }
exact λ x hx, ⟨(x, 0), by simp [hx]⟩
{ exact λ x hx, ⟨(0, x), by simp [hx]⟩ }
exact λ x hx, ⟨(0, x), by simp [hx]⟩
intros
simp [tailings]
intros
rw [sub_eq_add_neg, sub_eq_add_neg, polar_add_left, polar_neg_left]
intros
simpa only [range_eq_map] using map_liftq _ _ _ _
intros
simp only [and.left_comm, and.comm]
intros
simp only [← @forall_eq _ p a, ← forall_and_distrib, ← or_imp_distrib, classical.em, forall_const]
intros
by_cases h : j = i
{ subst j, simp }
subst j
simp
{ simp [h] }
simp [h]
intros
rcases exists_pair_ne α with ⟨x₁, x₂, hx⟩
by_cases h : f x₂ = y
{ exact ⟨x₁, (hf.ne_iff' h).2 hx⟩ }
exact ⟨x₁, (hf.ne_iff' h).2 hx⟩
{ exact ⟨x₂, h⟩ }
exact ⟨x₂, h⟩
intros
by_cases hxy : x = y
{ exact hxy ▸ h x }
exact hxy ▸ h x
{ exact hr hxy }
exact hr hxy
intros
haveI : encodable s := hs.to_encodable
{ haveI : encodable s := hs.to_encodable, simp only [supr_subtype'], exact measurable_supr (λ i, hf i) }
simp only [supr_subtype']
exact measurable_supr (λ i, hf i)
intros
rw [prod_dirac, map_dirac measurable_prod_mk_right]
intros
rw [real_smul_def, ← smul_neg_part, dif_neg (not_le.2 hr), neg_pos_part]
{ rw [real_smul_def, ← smul_neg_part, dif_neg (not_le.2 hr), neg_pos_part] }
intros
apply (ae_measurable.ae_eq_mk _).symm.trans
exact @quotient.mk_out' _ (μ.ae_eq_setoid β) (⟨f, hf⟩ : {f // ae_measurable f μ})
intros
have h_ss : ae_seq_set hf p ⊆ {a : α | ∀ i, ae_seq hf p i a = (hf i).mk (f i) a}
from λ x hx i, by simp only [ae_seq, hx, if_true]
exact le_antisymm (le_trans (measure_mono (set.compl_subset_compl.mpr h_ss)) (le_of_eq (measure_compl_ae_seq_set_eq_zero hf hp))) (zero_le _)
intros
refine eventually_eq.trans _ (condexp_ind_L1_fin_ae_eq_condexp_ind_smul hm hs hμs x)
simp [condexp_ind, condexp_ind_L1, hs, hμs]
intros
haveI : normed_space ℝ E := restrict_scalars.normed_space ℝ 𝕜 E
rw dense_range_iff_closure_range
suffices : (to_Lp p μ 𝕜 : _ →L[𝕜] Lp E p μ).range.to_add_subgroup.topological_closure = ⊤
{ exact congr_arg coe this }
exact congr_arg coe this
simp [range_to_Lp p μ, measure_theory.Lp.bounded_continuous_function_dense E hp]
intros
simp only [integrable, ae_measurable_map_equiv_iff, has_finite_integral, lintegral_map_equiv]
intros
simp [Lp.dist_def, snorm, snorm']
{ simp [Lp.dist_def, snorm, snorm'], simp [edist_eq_coe_nnnorm_sub] }
simp [edist_eq_coe_nnnorm_sub]
intros
have : ∀ x, ∥is_R_or_C.im (f x)∥ ≤ 1 * ∥f x∥
intro x
intro x
{ intro x, rw one_mul, exact is_R_or_C.norm_im_le_norm (f x), }
{ intro x, rw one_mul, exact is_R_or_C.norm_im_le_norm (f x), }
rw one_mul
rw one_mul
exact is_R_or_C.norm_im_le_norm (f x)
exact is_R_or_C.norm_im_le_norm (f x)
exact hf.of_le_mul hf.1.im (eventually_of_forall this)
intros
refine ess_sup_mono_ae (eventually_of_forall (λ x, _))
rw [ennreal.coe_le_coe, nnnorm_indicator_eq_indicator_nnnorm]
exact set.indicator_le_self s _ x
intros
rw [snorm'_congr_ae hf_zero, snorm'_zero' hq0_ne hμ]
intros
simp [Lp.tendsto_Lp_iff_tendsto_ℒp'', tendsto_approx_on_univ_Lp_snorm hp_ne_top fmeas hf.2]
intros
ext1 x
push_cast
simp_rw [pi.add_apply, weighted_smul_apply]
push_cast
rw [pi.add_apply, ennreal.to_real_add hμs hνs, add_smul]
intros
simp_rw [← of_real_norm_eq_coe_nnnorm]
{ simp_rw [← of_real_norm_eq_coe_nnnorm], apply ennreal.of_real_le_of_le_to_real, exact norm_integral_le_lintegral_norm f }
apply ennreal.of_real_le_of_le_to_real
exact norm_integral_le_lintegral_norm f
intros
by_cases hc : c = 0; simp [hc]
by_cases hc : c = 0
simp [hc]
simp [hc]
intros
rw [f.sum_measure_preimage_singleton, coe_range, preimage_range]
intros
rw [count, lintegral_sum_measure]
congr
exact funext (λ a, lintegral_dirac a f)
intros
by_cases h : integrable φ μ
{ exact integral_comp_comm L h }
exact integral_comp_comm L h
have : ¬ (integrable (L ∘ φ) μ)
rwa lipschitz_with.integrable_comp_iff_of_antilipschitz L.lipschitz hL (L.map_zero)
rwa lipschitz_with.integrable_comp_iff_of_antilipschitz L.lipschitz hL (L.map_zero)
simp [integral_undef, h, this]
intros
rw [set_to_fun_eq hT (L1.integrable_coe_fn f), integrable.to_L1_coe_fn]
intros
letI : fintype s := finite.fintype hs
exact measurable_of_measurable_union_cover s sᶜ hs.measurable_set hs.measurable_set.compl (by simp only [union_compl_self]) (measurable_of_fintype _) hf
intros
rw ← encodable.Union_decode₂
exact ‹measurable_space α›.measurable_set_Union _ (measurable_set.bUnion_decode₂ h)
intros
rw [μ.outer_measure_opens] at hU ⊢
rcases μ.inner_content_exists_compact hU hε with ⟨K, h1K, h2K⟩
exact ⟨K, h1K, le_trans h2K $ add_le_add_right (μ.le_outer_measure_compacts K) _⟩
intros
change (((haar_content K₀).outer_measure) K₀.val)⁻¹ * (haar_content K₀).measure s = _
simp only [hs, div_eq_mul_inv, mul_comm, content.measure_apply]
intros
rw measure_Inter_eq_infi hs (directed_of_sup hm) hf
exact tendsto_at_top_infi (assume n m hnm, measure_mono $ hm hnm)
intros
simp only [measure.restrict_eq_zero, h]
intros
haveI := hs.to_encodable
rw [bUnion_eq_Union]
apply measure_Union_le
intros
apply of_function_caratheodory
intro t
cases t.eq_empty_or_nonempty with h h
{ simp [h, empty_not_nonempty] }
simp [h, empty_not_nonempty]
convert le_trans _ (hs t)
{ convert le_trans _ (hs t), { simp [h] }, exact add_le_add supr_const_le supr_const_le }
simp [h]
{ simp [h] }
exact add_le_add supr_const_le supr_const_le
intros
refine ⟨λ A hA r hr, _⟩
rw [map_apply f.measurable hA, ← f.image_symm] at hr
rcases set.exists_is_open_lt_of_lt _ r hr with ⟨U, hAU, hUo, hU⟩
have : is_open (f.symm ⁻¹' U)
from hUo.preimage f.symm.continuous
refine ⟨f.symm ⁻¹' U, image_subset_iff.1 hAU, this, _⟩
rwa [map_apply f.measurable this.measurable_set, f.preimage_symm, f.preimage_image]
intros
rw [vector_measure.sub_apply, to_signed_measure_apply_measurable hi, measure.to_signed_measure_apply_measurable hi, sub_eq_add_neg]
intros
refine nnreal.summable_of_le (assume a, _) p.summable_coe
split_ifs
{ refine (mul_zero (p a)).symm ▸ le_of_eq h.symm }
refine (mul_zero (p a)).symm ▸ le_of_eq h.symm
suffices : p a * f a h b ≤ p a * 1
{ suffices : p a * f a h b ≤ p a * 1, { simpa }, exact mul_le_mul_of_nonneg_left ((f a h).coe_le_one _) (p a).2 }
simpa
{ simpa }
exact mul_le_mul_of_nonneg_left ((f a h).coe_le_one _) (p a).2
intros
haveI : fact (1 < (q:ℕ)) := ⟨w⟩
convert card_units_lt (X q)
rw X_card
intros
rw maximal_ideal_eq_span_p at hm hn
have := zmod_congr_of_sub_mem_span_aux 1 x m n
simp only [pow_one] at this
specialize this hm hn
apply_fun zmod.cast_hom (show p ∣ p ^ 1, by rw pow_one) (zmod p) at this
simpa only [ring_hom.map_int_cast]
intros
rw [two_mul, add_assoc, xn_add, add_assoc, ←zero_add 0]
refine (dvd_mul_right (xn a1 n) (xn a1 (n + j))).modeq_zero_nat.add _
rw [yn_add, left_distrib, add_assoc, ←zero_add 0]
exact ((dvd_mul_right _ _).mul_left _).modeq_zero_nat.add (xn_modeq_x2n_add_lem _ _ _).modeq_zero_nat
intros
simp [ext, of_int_re, of_int_im]
intros
rw [norm_sq_apply, norm_sq_apply, ← _root_.abs_mul_self, _root_.abs_mul, ← _root_.abs_mul_self y.re, _root_.abs_mul y.re, ← _root_.abs_mul_self x.im, _root_.abs_mul x.im, ← _root_.abs_mul_self y.im, _root_.abs_mul y.im]
rw [norm_sq_apply, norm_sq_apply, ← _root_.abs_mul_self, _root_.abs_mul, ← _root_.abs_mul_self y.re, _root_.abs_mul y.re, ← _root_.abs_mul_self x.im, _root_.abs_mul x.im, ← _root_.abs_mul_self y.im, _root_.abs_mul y.im]; exact (add_le_add (mul_self_le_mul_self (abs_nonneg _) hre) (mul_self_le_mul_self (abs_nonneg _) him))
exact (add_le_add (mul_self_le_mul_self (abs_nonneg _) hre) (mul_self_le_mul_self (abs_nonneg _) him))
intros
intros A B h
cases A
cases B
injection h
obtain rfl : A_le = B_le := ‹_›
obtain rfl : A_lt = B_lt := ‹_›
obtain rfl : A_decidable_le = B_decidable_le := subsingleton.elim _ _
obtain rfl : A_max = B_max := A_max_def.trans B_max_def.symm
obtain rfl : A_min = B_min := A_min_def.trans B_min_def.symm
congr
intros
rw [sdiff_eq, compl_top, inf_bot_eq]
intros
simp [(<)]
intros
rw [Sup_eq_supr]; exact hf.le_map_supr2 _
rw [Sup_eq_supr]
exact hf.le_map_supr2 _
intros
apply le_antisymm
refine (finset.sup'_le _ _ $ λ a ha, _)
{ refine (finset.sup'_le _ _ $ λ a ha, _), refine le_cSup ⟨s.sup' H f, _⟩ ⟨a, ha, rfl⟩, rintros i ⟨j, hj, rfl⟩, exact finset.le_sup' _ hj }
refine le_cSup ⟨s.sup' H f, _⟩ ⟨a, ha, rfl⟩
rintros i ⟨j, hj, rfl⟩
exact finset.le_sup' _ hj
apply cSup_le ((coe_nonempty.mpr H).image _)
{ apply cSup_le ((coe_nonempty.mpr H).image _), rintros _ ⟨a, ha, rfl⟩, exact finset.le_sup' _ ha, }
rintros _ ⟨a, ha, rfl⟩
exact finset.le_sup' _ ha
intros
rw [← map_coe_Ici_at_top a, tendsto_map'_iff]
intros
simpa only [inf_ne_bot_iff, frequently_iff, exists_prop, and_comm]
intros
simp [filter.frequently, -not_eventually, eventually_false_iff_eq_bot, ne_bot_iff]
intros
refine ⟨compl_compl s ▸ mt mem_of_eq_bot _⟩
rintro ⟨t, ht, hts⟩
rcases hf.nonempty_of_mem (inter_mem hs ht) with ⟨_, ⟨x, hxs, rfl⟩, hxt⟩
exact absurd hxs (hts hxt)
intros
simp [filter.coprod]
intros
simp only [← nat.cofinite_eq_at_top, frequently_cofinite_iff_infinite]
intros
simp only [lt_iff_le_not_le, eventually_and, coe_le, eventually_not, eventually_le]
intros
simp only [filter.lift', tendsto_lift, tendsto_principal]
intros
simp only [tendsto, ptendsto, pmap_res]
intros
obtain ⟨a, ha⟩ : ∃ a : P, ∀ I : ideal P, a ∈ I := ideal_Inter_nonempty.exists_all_mem
exact ⟨a, by simp [ha]⟩
intros
rw [sup_comm, @sup_comm _ _ a, sup_assoc]
intros
simp [is_cobounded]
intros
induction n with n ih
{ apply w 0 le_rfl, }
apply w 0 le_rfl
exact sup_le (ih (λ m p, w m (nat.le_succ_of_le p))) (w (n + 1) le_rfl)
{ exact sup_le (ih (λ m p, w m (nat.le_succ_of_le p))) (w (n + 1) le_rfl) }
intros
simp [symm_diff_eq]
intros
suffices : set.range (algebra_map D E) = set.range (algebra_map ((⊤ : subalgebra C D).map (is_scalar_tower.to_alg_hom C D E)) E)
ext x
{ ext x, change x ∈ subsemiring.closure (_ ∪ S) ↔ x ∈ subsemiring.closure (_ ∪ S), rw this }
change x ∈ subsemiring.closure (_ ∪ S) ↔ x ∈ subsemiring.closure (_ ∪ S)
rw this
ext x
split
rintros ⟨y, hy⟩
{ rintros ⟨y, hy⟩, exact ⟨⟨algebra_map D E y, ⟨y, ⟨algebra.mem_top, rfl⟩⟩⟩, hy⟩ }
exact ⟨⟨algebra_map D E y, ⟨y, ⟨algebra.mem_top, rfl⟩⟩⟩, hy⟩
rintros ⟨⟨y, ⟨z, ⟨h0, h1⟩⟩⟩, h2⟩
{ rintros ⟨⟨y, ⟨z, ⟨h0, h1⟩⟩⟩, h2⟩, exact ⟨z, eq.trans h1 h2⟩ }
exact ⟨z, eq.trans h1 h2⟩
intros
{ rw add_comm, exact h.add_mul_right_right z }
rw add_comm
exact h.add_mul_right_right z
intros
cases exists_mul_sub_mem_of_sub_one_mem_jacobson r h with s hs
rw [mem_bot, sub_eq_zero] at hs
exact is_unit_of_mul_eq_one _ _ hs
intros
dsimp [inv_fun]
simp only [algebra.algebra_map_eq_smul_one, smul_tmul, ←tmul_sum, mul_boole]
congr
conv_rhs {rw matrix_eq_sum_std_basis M}
convert finset.sum_product
simp
intros
rw [eq_coe_iff]
{ rw [eq_coe_iff], use dvd_rfl, rw [pow_dvd_pow_iff h0 hu], apply nat.not_succ_le_self }
use dvd_rfl
rw [pow_dvd_pow_iff h0 hu]
apply nat.not_succ_le_self
intros
rw C_dvd_iff_dvd_coeff
split
intros h i
{ intros h i, apply h.trans (content_dvd_coeff _) }
apply h.trans (content_dvd_coeff _)
intro h
{ intro h, rw [content, finset.dvd_gcd_iff], intros i hi, apply h i }
rw [content, finset.dvd_gcd_iff]
intros i hi
apply h i
intros
rw_mod_cast [pochhammer_nat_eq_asc_factorial, nat.zero_asc_factorial]
intros
apply monic_sub_of_left (monic_pow (monic_X) _)
rw degree_X_pow
exact degree_sum_fin_lt _
intros
{ rw [X_pow_eq, order_monomial_of_ne_zero], exact one_ne_zero }
rw [X_pow_eq, order_monomial_of_ne_zero]
exact one_ne_zero
intros
{ refine ⟨_, λ h, inv h⟩, intro h, rw [← inv_inv ζ], exact inv h }
refine ⟨_, λ h, inv h⟩
intro h
rw [← inv_inv ζ]
exact inv h
intros
simp only [← nsmul_one, nsmul_mem, one_mem]
intros
apply tensor_product.induction_on x; simp {contextual := tt}
apply tensor_product.induction_on x
simp {contextual := tt}
simp {contextual := tt}
simp {contextual := tt}
intros
have d_pos : 0 < pb.dim := power_basis.dim_pos pb
have d_pos' : 0 < (minpoly K pb.gen).nat_degree
simpa
{ simpa }
haveI : nonempty (fin pb.dim) := ⟨⟨0, d_pos⟩⟩
rw [trace_eq_matrix_trace pb.basis, trace_eq_neg_charpoly_coeff, charpoly_left_mul_matrix, ring_hom.map_neg, ← pb.nat_degree_minpoly, fintype.card_fin, ← next_coeff_of_pos_nat_degree _ d_pos', ← next_coeff_map (algebra_map K F).injective]
conv_lhs { rw eq_prod_roots_of_splits hf }
rw [monic.next_coeff_mul, next_coeff_C_eq_zero, zero_add, monic.next_coeff_multiset_prod]
simp_rw [next_coeff_X_sub_C, multiset.sum_map_neg, neg_neg]
{ intros, apply monic_X_sub_C }
intros
intros
apply monic_X_sub_C
apply monic_X_sub_C
convert monic_one
{ convert monic_one, simp [(minpoly.monic pb.is_integral_gen).leading_coeff] }
simp [(minpoly.monic pb.is_integral_gen).leading_coeff]
apply monic_multiset_prod_of_monic
{ apply monic_multiset_prod_of_monic, intros, apply monic_X_sub_C }
{ intros, apply monic_X_sub_C }
intros
intros
apply monic_X_sub_C
apply monic_X_sub_C
intros
dunfold has_mem.mem
dunfold factor_set_mem
split_ifs
exact trivial
intros
have : v₁ r ≠ v₁ 0 ↔ v₂ r ≠ v₂ 0 := not_iff_not_of_iff h.val_eq
rwa [v₁.map_zero, v₂.map_zero] at this
intros
rw [← ring_hom.comp_assoc, commutes, ring_hom.comp_assoc, padic_int.zmod_cast_comp_to_zmod_pow]
intros
apply mv_polynomial.map_injective (int.cast_ring_hom ℚ) int.cast_injective
simp only [map_bind₁, map_frobenius_poly, bind₁_frobenius_poly_rat_witt_polynomial, map_witt_polynomial]
intros
use verschiebung_poly
simp only [aeval_verschiebung_poly', eq_self_iff_true, forall_3_true_iff]
intros
rw [← succ_le, (by norm_cast : succ 1 = 2)] at hb
rw [← succ_le, (by norm_cast : succ 1 = 2)] at hb; exact lt_of_lt_of_le (cantor _) (power_le_power_right hb)
exact lt_of_lt_of_le (cantor _) (power_le_power_right hb)
intros
dsimp [cof, strict_order.cof, order.cof, type, quotient.mk, quot.lift_on]
dsimp [cof, strict_order.cof, order.cof, type, quotient.mk, quot.lift_on]; rw [cardinal.le_min, subtype.forall]; refl
dsimp [cof, strict_order.cof, order.cof, type, quotient.mk, quot.lift_on]; rw [cardinal.le_min, subtype.forall]
rw [cardinal.le_min, subtype.forall]
refl
intros
have b0 : b ≠ 0 := ne_of_gt (lt_trans zero_lt_one b1)
apply lt_imp_lt_of_le_imp_le (power_le_power_left $ power_ne_zero a b0)
rw [← power_mul, mul_eq_self ha]
exact lt_power_cof (le_trans ha $ le_of_lt $ cantor' _ b1)
intros
simp [of_list, of']
intros
rw [←card_type c.ord.out.r, type_out, card_ord]
intros
induction x with xl xr xL xR IHxl IHxr generalizing y
induction y with yl yr yL yR IHyl IHyr
classical
simp only [mk_le_mk, mk_lt_mk, not_and_distrib, not_or_distrib, not_forall, not_exists, and_comm, or_comm, IHxl, IHxr, IHyl, IHyr, iff_self, and_self]
intros
{ cases x, cases y, refl, }
cases x
cases y
refl
intros
delta choice
rw [map_fval yx, Class.mem_hom_left, Class.mem_hom_right]
exact choice_mem_aux x h y yx
intros
rw [← h₂, ← h₁, int.nat_cast_eq_coe_nat]
rw [← h₂, ← h₁, int.nat_cast_eq_coe_nat]; refl
refl
intros
simp [h.symm, horner, add_assoc]
intros
cc
intros
rw [← compl_range_coe, is_closed_compl_iff]
{ rw [← compl_range_coe, is_closed_compl_iff], exact is_open_range_coe }
exact is_open_range_coe
intros
{ ext, refl }
ext
refl
intros
refine le_of_tendsto (tendsto_const_nhds.dist ha) (eventually_at_top.2 ⟨n, λ m hnm, _⟩)
refine le_trans (dist_le_Ico_sum_of_dist_le hnm (λ k _ _, hf k)) _
rw [sum_Ico_eq_sum_range]
refine sum_le_tsum (range _) (λ _ _, le_trans dist_nonneg (hf _)) _
exact hd.comp_injective (add_right_injective n)
intros
simpa only [neg_neg] using hf.neg
intros
rw [ne.def, tsum_eq_zero_iff hf, not_forall]
intros
simp [nhds_eq_infi_abs_sub, abs_sub_comm a]
intros
cases s.eq_empty_or_nonempty with h h
{ simp [h, fbot] }
simp [h, fbot]
{ exact map_Sup_of_continuous_at_of_monotone' Cf Mf h }
exact map_Sup_of_continuous_at_of_monotone' Cf Mf h
intros
revert hf
refine degree_pos_induction_on p hd _ _ _
refine degree_pos_induction_on p hd _ _ _; clear hd p
clear hd p
rintros c - hc
{ rintros c - hc, rw [leading_coeff_mul_X, leading_coeff_C] at hc, simpa [abv_mul abv] using hz.const_mul_at_top ((abv_pos abv).2 hc) }
rw [leading_coeff_mul_X, leading_coeff_C] at hc
simpa [abv_mul abv] using hz.const_mul_at_top ((abv_pos abv).2 hc)
clear hd p
intros p hpd ihp hf
{ intros p hpd ihp hf, rw [leading_coeff_mul_X] at hf, simpa [abv_mul abv] using (ihp hf).at_top_mul_at_top hz }
rw [leading_coeff_mul_X] at hf
simpa [abv_mul abv] using (ihp hf).at_top_mul_at_top hz
clear hd p
{ intros p a hd ihp hf, rw [add_comm, leading_coeff_add_of_degree_lt (degree_C_le.trans_lt hd)] at hf, refine tendsto_at_top_of_add_const_right (abv (-f a)) _, refine tendsto_at_top_mono (λ _, abv_add abv _ _) _, simpa using ihp hf }
intros p a hd ihp hf
rw [add_comm, leading_coeff_add_of_degree_lt (degree_C_le.trans_lt hd)] at hf
refine tendsto_at_top_of_add_const_right (abv (-f a)) _
refine tendsto_at_top_mono (λ _, abv_add abv _ _) _
simpa using ihp hf
intros
let S := f.discrete_quotient
let ff : S → α := f.lift
casesI is_empty_or_nonempty S
suffices : ∃ j, is_empty (F.obj j)
{ suffices : ∃ j, is_empty (F.obj j), { refine this.imp (λ j hj, _), refine ⟨⟨hj.elim, λ A, _⟩, _⟩, { convert is_open_empty, exact @set.eq_empty_of_is_empty _ hj _ }, { ext x, exact hj.elim' (C.π.app j x) } }, simp only [← not_nonempty_iff, ← not_forall], intros h, haveI : ∀ j : J, nonempty ((F ⋙ Profinite.to_Top).obj j) := h, haveI : ∀ j : J, t2_space ((F ⋙ Profinite.to_Top).obj j) := λ j, (infer_instance : t2_space (F.obj j)), haveI : ∀ j : J, compact_space ((F ⋙ Profinite.to_Top).obj j) := λ j, (infer_instance : compact_space (F.obj j)), have cond := Top.nonempty_limit_cone_of_compact_t2_cofiltered_system (F ⋙ Profinite.to_Top), suffices : nonempty C.X, from is_empty.false (S.proj this.some), let D := Profinite.to_Top.map_cone C, have hD : is_limit D := is_limit_of_preserves Profinite.to_Top hC, have CD := (hD.cone_point_unique_up_to_iso (Top.limit_cone_is_limit _)).inv, exact cond.map CD }
refine this.imp (λ j hj, _)
{ refine this.imp (λ j hj, _), refine ⟨⟨hj.elim, λ A, _⟩, _⟩, { convert is_open_empty, exact @set.eq_empty_of_is_empty _ hj _ }, { ext x, exact hj.elim' (C.π.app j x) } }
refine ⟨⟨hj.elim, λ A, _⟩, _⟩
convert is_open_empty
{ convert is_open_empty, exact @set.eq_empty_of_is_empty _ hj _ }
exact @set.eq_empty_of_is_empty _ hj _
ext x
{ ext x, exact hj.elim' (C.π.app j x) }
exact hj.elim' (C.π.app j x)
simp only [← not_nonempty_iff, ← not_forall]
intros h
haveI : ∀ j : J, nonempty ((F ⋙ Profinite.to_Top).obj j) := h
haveI : ∀ j : J, t2_space ((F ⋙ Profinite.to_Top).obj j) := λ j, (infer_instance : t2_space (F.obj j))
haveI : ∀ j : J, compact_space ((F ⋙ Profinite.to_Top).obj j) := λ j, (infer_instance : compact_space (F.obj j))
have cond := Top.nonempty_limit_cone_of_compact_t2_cofiltered_system (F ⋙ Profinite.to_Top)
suffices : nonempty C.X
from is_empty.false (S.proj this.some)
let D := Profinite.to_Top.map_cone C
have hD : is_limit D := is_limit_of_preserves Profinite.to_Top hC
have CD := (hD.cone_point_unique_up_to_iso (Top.limit_cone_is_limit _)).inv
exact cond.map CD
let f' : locally_constant C.X S := ⟨S.proj, S.proj_is_locally_constant⟩
{ let f' : locally_constant C.X S := ⟨S.proj, S.proj_is_locally_constant⟩, obtain ⟨j, g', hj⟩ := exists_locally_constant_fintype_nonempty _ hC f', refine ⟨j, ⟨ff ∘ g', g'.is_locally_constant.comp _⟩,_⟩, ext1 t, apply_fun (λ e, e t) at hj, rw locally_constant.coe_comap _ _ (C.π.app j).continuous at hj ⊢, dsimp at hj ⊢, rw ← hj, refl }
obtain ⟨j, g', hj⟩ := exists_locally_constant_fintype_nonempty _ hC f'
refine ⟨j, ⟨ff ∘ g', g'.is_locally_constant.comp _⟩,_⟩
ext1 t
apply_fun (λ e, e t) at hj
rw locally_constant.coe_comap _ _ (C.π.app j).continuous at hj ⊢
dsimp at hj ⊢
rw ← hj
refl
intros
simp [norm_def, bounded_continuous_function.dist_eq]
intros
simpa only [subtype.range_coe] using (embedding_subtype_coe.map_nhds_eq ⟨a, h⟩).symm
intros
convert (continuous_on_open_iff hs).mp h t ht
rw [inter_comm, inter_eq_self_of_subset_left hp]
intros
refine is_open_map_iff_nhds_le.2 (λ x, _)
rcases h (proj x) with ⟨e, ex⟩
refine (e.map_proj_nhds _).ge
rwa e.source_eq
intros
rw [add_comm, supr_add]; simp [add_comm]
rw [add_comm, supr_add]
simp [add_comm]
intros
simp only [← e.symm_image_eq_source_inter_preimage h, continuous_on, ball_image_iff]
refine forall_congr (λ x, forall_congr $ λ hx, _)
rw [e.continuous_within_at_iff_continuous_within_at_comp_right (h hx), e.symm_image_eq_source_inter_preimage h, inter_comm, continuous_within_at_inter]
exact is_open.mem_nhds e.open_source (e.map_target (h hx))
intros
{ ext, simp only [hf, hg, hg.comp hf, coe_comap] }
ext
simp only [hf, hg, hg.comp hf, coe_comap]
intros
by_contradiction h
simp only [not_exists, not_nonempty_iff_eq_empty] at h
have := calc ∅ = closure (⋃s, interior (f s)) : by simp [h] ... = univ : (dense_Union_interior_of_closed hc hU).closure_eq
exact univ_nonempty.ne_empty this.symm
intros
apply hs.elim_finite_subcover_image
{ simp [is_open_ball] }
simp [is_open_ball]
intros x xs
{ intros x xs, simp, exact ⟨x, ⟨xs, by simpa⟩⟩ }
simp
exact ⟨x, ⟨xs, by simpa⟩⟩
intros
rw disjoint_left
assume a ax ay
apply lt_irrefl (dist x y)
calc dist x y ≤ dist x a + dist a y : dist_triangle _ _ _ ... < rx + ry : add_lt_add (mem_ball'.1 ax) (mem_ball.1 ay) ... ≤ dist x y : h
intros
convert hf.apriori_edist_iterate_efixed_point_le hx 0
{ convert hf.apriori_edist_iterate_efixed_point_le hx 0, simp only [pow_zero, mul_one] }
simp only [pow_zero, mul_one]
intros
simp
intros
simp [Hausdorff_dist]
intros
simp [supr_def]
intros
rw [is_connected_iff_connected_space, is_path_connected_iff_path_connected_space]
haveI := loc_path_connected_of_is_open U_op
exact path_connected_space_iff_connected_space
intros
rw [continuous_on, ← and_forall_ne x, and_comm]
refine and_congr ⟨λ H z hz, _, λ H z hzx hzs, _⟩ (forall_congr $ λ hxs, _)
specialize H z hz.2 hz.1
{ specialize H z hz.2 hz.1, rw continuous_within_at_update_of_ne hz.2 at H, exact H.mono (diff_subset _ _) }
rw continuous_within_at_update_of_ne hz.2 at H
exact H.mono (diff_subset _ _)
rw continuous_within_at_update_of_ne hzx
{ rw continuous_within_at_update_of_ne hzx, refine (H z ⟨hzs, hzx⟩).mono_of_mem (inter_mem_nhds_within _ _), exact is_open_ne.mem_nhds hzx }
refine (H z ⟨hzs, hzx⟩).mono_of_mem (inter_mem_nhds_within _ _)
exact is_open_ne.mem_nhds hzx
{ exact continuous_within_at_update_same }
exact continuous_within_at_update_same
intros
simp only [prod_subset_compl_diagonal_iff_disjoint.symm] at ⊢ hst
simp only [prod_subset_compl_diagonal_iff_disjoint.symm] at ⊢ hst; exact generalized_tube_lemma hs ht is_closed_diagonal.is_open_compl hst
exact generalized_tube_lemma hs ht is_closed_diagonal.is_open_compl hst
intros
intros x y h
have : {x} ∈ (pure x : ultrafilter α) := singleton_mem_pure
have : {x} ∈ (pure x : ultrafilter α) := singleton_mem_pure
have : {x} ∈ (pure x : ultrafilter α) := singleton_mem_pure
have : {x} ∈ (pure x : ultrafilter α) := singleton_mem_pure
rw h at this
exact (mem_singleton_iff.mp (mem_pure.mp this)).symm
intros
split
all_goals { intros h t₁ t₂ ht₁ ht₂, specialize h t₁ᶜ t₂ᶜ, simp only [is_open_compl_iff, is_closed_compl_iff] at h, specialize h ht₁ ht₂ }
intros h t₁ t₂ ht₁ ht₂
specialize h t₁ᶜ t₂ᶜ
simp only [is_open_compl_iff, is_closed_compl_iff] at h
specialize h ht₁ ht₂
contrapose!
{ contrapose!, simp only [not_subset], rintro ⟨⟨x, hx, hx'⟩, ⟨y, hy, hy'⟩⟩, rcases h ⟨x, hx, hx'⟩ ⟨y, hy, hy'⟩ with ⟨z, hz, hz'⟩, rw ← compl_union at hz', exact ⟨z, hz, hz'⟩ }
simp only [not_subset]
rintro ⟨⟨x, hx, hx'⟩, ⟨y, hy, hy'⟩⟩
rcases h ⟨x, hx, hx'⟩ ⟨y, hy, hy'⟩ with ⟨z, hz, hz'⟩
rw ← compl_union at hz'
exact ⟨z, hz, hz'⟩
intros h t₁ t₂ ht₁ ht₂
specialize h t₁ᶜ t₂ᶜ
simp only [is_open_compl_iff, is_closed_compl_iff] at h
specialize h ht₁ ht₂
rintro ⟨x, hx, hx'⟩ ⟨y, hy, hy'⟩
{ rintro ⟨x, hx, hx'⟩ ⟨y, hy, hy'⟩, rw ← compl_inter at h, delta set.nonempty, rw imp_iff_not_or at h, contrapose! h, split, { intros z hz hz', exact h z ⟨hz, hz'⟩ }, { split; intro H; refine H _ ‹_›; assumption } }
rw ← compl_inter at h
delta set.nonempty
rw imp_iff_not_or at h
contrapose! h
split
{ intros z hz hz', exact h z ⟨hz, hz'⟩ }
intros z hz hz'
exact h z ⟨hz, hz'⟩
split; intro H; refine H _ ‹_›; assumption
split; intro H; refine H _ ‹_›
split; intro H
{ split; intro H; refine H _ ‹_›; assumption }
split
intro H
refine H _ ‹_›
assumption
intro H
refine H _ ‹_›
assumption
intros
rw [compact_iff_compact_in_subtype, image_univ, subtype.range_coe]
rw [compact_iff_compact_in_subtype, image_univ, subtype.range_coe]; refl
intros
rw [@nhds_eq_uniformity α u₁ a, @nhds_eq_uniformity α u₂ a]
rw [@nhds_eq_uniformity α u₁ a, @nhds_eq_uniformity α u₂ a]; exact (lift'_mono h le_rfl)
exact (lift'_mono h le_rfl)
intros
intros V V_in
rcases h _ (symmetrize_mem_uniformity V_in) (symmetric_symmetrize_rel V) with ⟨t, tfin, h⟩
refine ⟨t, tfin, subset.trans h _⟩
mono
intros x x_in z z_in
exact z_in.right
intros
unfold interleave corec_on
rw corec_eq
dsimp
rw corec_eq
refl
intros
cases a; cases b; simp
cases a; cases b
cases a
cases b
simp
simp
cases b
simp
simp
intros
have h := int.add_le_add_left h a
rwa int.add_neg_cancel_left at h
intros
rw int.add_comm at h
exact int.neg_add_lt_left_of_lt_add h
intros
induction n with n IH
{ simp, cases bodd m; refl }
simp
cases bodd m
cases bodd m; refl
refl
refl
{ simp [add_succ, IH], cases bodd m; cases bodd n; refl }
simp [add_succ, IH]
cases bodd m
cases bodd m; cases bodd n; refl
cases bodd m; cases bodd n
cases bodd n
refl
refl
cases bodd n
refl
refl
intros
induction n; simp [*, mul_succ, nat.mul_zero]
{induction n; simp [*, mul_succ, nat.mul_zero] }
induction n
simp [*, mul_succ, nat.mul_zero]
simp [*, mul_succ, nat.mul_zero]
intros
rw [← add_one, ← add_one]
simp [nat.right_distrib, nat.left_distrib, nat.add_left_comm, nat.mul_one, nat.one_mul, nat.add_assoc]
intros
tactic.mk_inj_eq
intros
{ simp only [bit0, bit1, add_smul, smul_add, one_smul], abel }
simp only [bit0, bit1, add_smul, smul_add, one_smul]
abel
intros
{ ext c, exact (mul_assoc a c b).symm, }
ext c
exact (mul_assoc a c b).symm
intros
induction n with n ih
{ simp, }
simp
{ simp [pow_succ, ih], }
simp [pow_succ, ih]
intros
cases exists_nat_gt (1/ε) with n hn
use n
rw [div_lt_iff, ← div_lt_iff' hε]
apply hn.trans
{ apply hn.trans, simp [zero_lt_one] }
simp [zero_lt_one]
{ exact n.cast_add_one_pos }
exact n.cast_add_one_pos
intros
rw [piecewise, prod_ite, filter_mem_eq_inter, ← sdiff_eq_filter]
{ rw [piecewise, prod_ite, filter_mem_eq_inter, ← sdiff_eq_filter], }
intros
conv_lhs { erw ←prod_map (s.subtype p) (function.embedding.subtype _) f }
exact prod_congr (subtype_map _) (λ x hx, rfl)
intros
simpa only [← div_eq_mul_inv] using @sum_range_sub' (additive M) _ f n
intros
simp only [finset.coe_image, set.mem_image, finset.mem_coe, function.support_subset_iff]
intros b h
suffices : (s.filter (λ (a : α), g a = b)).nonempty
simpa only [s.fiber_nonempty_iff_mem_image g b, finset.mem_image, exists_prop]
{ simpa only [s.fiber_nonempty_iff_mem_image g b, finset.mem_image, exists_prop], }
exact finset.nonempty_of_prod_ne_one h
intros
simp only [div_eq_mul_inv, sum_mul]
intros
cases s_succ_nth_eq : (s.nth $ n + 1) with gp_succ_n
case option.none { rw [(squash_seq_eq_self_of_terminated s_succ_nth_eq), (convergents'_aux_stable_step_of_terminated s_succ_nth_eq)] }
rw [(squash_seq_eq_self_of_terminated s_succ_nth_eq), (convergents'_aux_stable_step_of_terminated s_succ_nth_eq)]
case option.some { induction n with m IH generalizing s gp_succ_n, case nat.zero { obtain ⟨gp_head, s_head_eq⟩ : ∃ gp_head, s.head = some gp_head, from s.ge_stable zero_le_one s_succ_nth_eq, have : (squash_seq s 0).head = some ⟨gp_head.a, gp_head.b + gp_succ_n.a / gp_succ_n.b⟩, from squash_seq_nth_of_not_terminated s_head_eq s_succ_nth_eq, simp [*, convergents'_aux, seq.head, seq.nth_tail] }, case nat.succ { obtain ⟨gp_head, s_head_eq⟩ : ∃ gp_head, s.head = some gp_head, from s.ge_stable (m + 2).zero_le s_succ_nth_eq, suffices : gp_head.a / (gp_head.b + convergents'_aux s.tail (m + 2)) = convergents'_aux (squash_seq s (m + 1)) (m + 2), by simpa only [convergents'_aux, s_head_eq], have : convergents'_aux s.tail (m + 2) = convergents'_aux (squash_seq s.tail m) (m + 1), by { refine (IH gp_succ_n _), simpa [seq.nth_tail] using s_succ_nth_eq }, have : (squash_seq s (m + 1)).head = some gp_head, from (squash_seq_nth_of_lt m.succ_pos).trans s_head_eq, simp only [*, convergents'_aux, squash_seq_succ_n_tail_eq_squash_seq_tail_n] } }
induction n with m IH generalizing s gp_succ_n
case nat.zero { obtain ⟨gp_head, s_head_eq⟩ : ∃ gp_head, s.head = some gp_head, from s.ge_stable zero_le_one s_succ_nth_eq, have : (squash_seq s 0).head = some ⟨gp_head.a, gp_head.b + gp_succ_n.a / gp_succ_n.b⟩, from squash_seq_nth_of_not_terminated s_head_eq s_succ_nth_eq, simp [*, convergents'_aux, seq.head, seq.nth_tail] }
obtain ⟨gp_head, s_head_eq⟩ : ∃ gp_head, s.head = some gp_head
from s.ge_stable zero_le_one s_succ_nth_eq
have : (squash_seq s 0).head = some ⟨gp_head.a, gp_head.b + gp_succ_n.a / gp_succ_n.b⟩
from squash_seq_nth_of_not_terminated s_head_eq s_succ_nth_eq
simp [*, convergents'_aux, seq.head, seq.nth_tail]
case nat.succ { obtain ⟨gp_head, s_head_eq⟩ : ∃ gp_head, s.head = some gp_head, from s.ge_stable (m + 2).zero_le s_succ_nth_eq, suffices : gp_head.a / (gp_head.b + convergents'_aux s.tail (m + 2)) = convergents'_aux (squash_seq s (m + 1)) (m + 2), by simpa only [convergents'_aux, s_head_eq], have : convergents'_aux s.tail (m + 2) = convergents'_aux (squash_seq s.tail m) (m + 1), by { refine (IH gp_succ_n _), simpa [seq.nth_tail] using s_succ_nth_eq }, have : (squash_seq s (m + 1)).head = some gp_head, from (squash_seq_nth_of_lt m.succ_pos).trans s_head_eq, simp only [*, convergents'_aux, squash_seq_succ_n_tail_eq_squash_seq_tail_n] }
obtain ⟨gp_head, s_head_eq⟩ : ∃ gp_head, s.head = some gp_head
from s.ge_stable (m + 2).zero_le s_succ_nth_eq
suffices : gp_head.a / (gp_head.b + convergents'_aux s.tail (m + 2)) = convergents'_aux (squash_seq s (m + 1)) (m + 2)
simpa only [convergents'_aux, s_head_eq]
simpa only [convergents'_aux, s_head_eq]
have : convergents'_aux s.tail (m + 2) = convergents'_aux (squash_seq s.tail m) (m + 1)
refine (IH gp_succ_n _)
refine (IH gp_succ_n _)
{ refine (IH gp_succ_n _), simpa [seq.nth_tail] using s_succ_nth_eq }
{ refine (IH gp_succ_n _), simpa [seq.nth_tail] using s_succ_nth_eq }
simpa [seq.nth_tail] using s_succ_nth_eq
simpa [seq.nth_tail] using s_succ_nth_eq
have : (squash_seq s (m + 1)).head = some gp_head
from (squash_seq_nth_of_lt m.succ_pos).trans s_head_eq
simp only [*, convergents'_aux, squash_seq_succ_n_tail_eq_squash_seq_tail_n]
intros
simpa [partial_denominators, seq.map_nth] using nth_part_denom_eq
intros
{ rw [from_add_monoid, to_add_monoid_of], refl }
rw [from_add_monoid, to_add_monoid_of]
refl
intros
rw [inv_eq_one_div, inv_eq_one_div, div_sub_div _ _ ha hb, one_mul, mul_one]
intros
simp [norm_unit, h0]
intros
simp [h]
intros
simp [← h]
intros
rw [sub_eq_neg_add, neg_add_cancel_left]
intros
rintros ⟨⟩ ⟨⟩ h
congr'
congr'; injection h
injection h
injection h
injection h
intros
convert units.mul_inv _
simp [h.unit_spec]
intros
rw [div_mul_eq_mul_div, ← one_mul c, ← div_mul_div, div_one, one_mul]
intros
dsimp [d_to, X_prev_iso]
rw c.prev_eq_some r
refl
intros
simp [image_to_kernel]
intros
simp [mul_indicator, ite_eq_iff, exists_or_distrib, eq_univ_iff_forall, and_comm, or_comm, @eq_comm _ r 1]
intros
{ rw [←sub_eq_zero, sub_neg_eq_add, ←lie_add], simp, }
rw [←sub_eq_zero, sub_neg_eq_add, ←lie_add]
simp
intros
ext m
simp only [module.End.mem_maximal_generalized_eigenspace, submodule.mem_top, sub_zero, iff_true, zero_smul, submodule.mem_infi]
intros x
obtain ⟨k, hk⟩ := nilpotent_endo_of_nilpotent_module R L M
use k
rw hk
exact linear_map.zero_apply m
intros
{ rw is_semisimple.semisimple, exact is_lie_abelian_bot R L, }
rw is_semisimple.semisimple
exact is_lie_abelian_bot R L
intros
induction k with k ih
{ rw [zero_add, derived_series_of_ideal_zero], }
rw [zero_add, derived_series_of_ideal_zero]
rw [nat.succ_add k l, derived_series_of_ideal_succ, derived_series_of_ideal_succ, ih]
{ rw [nat.succ_add k l, derived_series_of_ideal_succ, derived_series_of_ideal_succ, ih], }
intros
{ rw lie_span_le, exact set.subset.trans h subset_lie_span, }
rw lie_span_le
exact set.subset.trans h subset_lie_span
intros
{ rw lie_span_le, exact subset.trans h subset_lie_span, }
rw lie_span_le
exact subset.trans h subset_lie_span
intros
rw [← lie_submodule.coe_to_submodule_eq_iff, comap_coe_submodule, I.map_coe_submodule f h, lie_submodule.sup_coe_to_submodule, f.ker_coe_submodule, submodule.comap_map_eq]
intros
simp only [root_space_product_def, coe_root_space_weight_space_product_tmul]
intros
{ intros f g h, ext, exact linear_map.congr_fun h x }
intros f g h
ext
exact linear_map.congr_fun h x
intros
have h := (set_like.lt_iff_le_and_exists.1 bot_lt).2
tidy
intros
cases o₁; try {refl}; cases o₂; refl
cases o₁; try {refl}; cases o₂
cases o₁; try {refl}
cases o₁
try {refl}
try {refl}
try {refl}
refl
intros
rcases lt_trichotomy b 0 with (hb|rfl|hb)
{ simp [hb, hb.not_lt, one_le_div_of_neg] }
simp [hb, hb.not_lt, one_le_div_of_neg]
{ simp [lt_irrefl, zero_lt_one.not_le, zero_lt_one] }
simp [lt_irrefl, zero_lt_one.not_le, zero_lt_one]
{ simp [hb, hb.not_lt, one_le_div] }
simp [hb, hb.not_lt, one_le_div]
intros
simp [division_def, mul_pos_iff]
intros
{ rw [← mul_le_mul_iff_left a, ← mul_le_mul_iff_right b], simp }
rw [← mul_le_mul_iff_left a, ← mul_le_mul_iff_right b]
simp
intros
rw [lt_div_iff_mul_lt, mul_comm]
intros
cases a
cases a; refl
refl
refl
intros
ext x
simp only [mem_smul_set, algebra.id.smul_eq_mul, mem_Iio]
split
rintro ⟨a_w, a_h_left, rfl⟩
{ rintro ⟨a_w, a_h_left, rfl⟩, exact (mul_lt_mul_left hr).mpr a_h_left, }
exact (mul_lt_mul_left hr).mpr a_h_left
rintro h
{ rintro h, use x / r, split, exact (div_lt_iff' hr).mpr h, exact mul_div_cancel' _ (ne_of_gt hr), }
use x / r
split
exact (div_lt_iff' hr).mpr h
exact mul_div_cancel' _ (ne_of_gt hr)
intros
rw [add_eq_zero_iff', mul_self_eq_zero, mul_self_eq_zero]
rw [add_eq_zero_iff', mul_self_eq_zero, mul_self_eq_zero]; apply mul_self_nonneg
apply mul_self_nonneg
apply mul_self_nonneg
intros
simpa only [mul_one] using decidable.mul_le_mul h₂ h₄ h₃ h₁
intros
by_cases H₁ : c = 0
{ simp [H₁, zero_smul] }
simp [H₁, zero_smul]
by_cases H₂ : a = b
{ by_cases H₂ : a = b, { rw H₂ }, { exact le_of_lt (smul_lt_smul_of_pos (lt_of_le_of_ne h₁ H₂) (lt_of_le_of_ne h₂ (ne.symm H₁))), } }
{ rw H₂ }
rw H₂
exact le_of_lt (smul_lt_smul_of_pos (lt_of_le_of_ne h₁ H₂) (lt_of_le_of_ne h₂ (ne.symm H₁)))
{ exact le_of_lt (smul_lt_smul_of_pos (lt_of_le_of_ne h₁ H₂) (lt_of_le_of_ne h₂ (ne.symm H₁))), }
intros
simpa only [mul_zero, mul_one] using mul_le_mul_left' (@zero_le_one' α _) a
intros
by_cases h : l.sum = 0
{ simp [h] }
simp [h]
rw degree_eq_nat_degree h
{ rw degree_eq_nat_degree h, suffices : (l.map nat_degree).maximum = ((l.map nat_degree).foldr max 0 : ℕ), { rw this, simpa [this] using nat_degree_list_sum_le l }, rw list.maximum_eq_coe_foldr_max_of_ne_nil, { congr }, contrapose! h, rw [list.map_eq_nil] at h, simp [h] }
suffices : (l.map nat_degree).maximum = ((l.map nat_degree).foldr max 0 : ℕ)
rw this
{ rw this, simpa [this] using nat_degree_list_sum_le l }
simpa [this] using nat_degree_list_sum_le l
rw list.maximum_eq_coe_foldr_max_of_ne_nil
{ congr }
congr
contrapose! h
rw [list.map_eq_nil] at h
simp [h]
intros
simp only [norm_sq_def, sq, ← neg_mul_eq_mul_neg, sub_neg_eq_add, mul_re, conj_re, conj_im_i, conj_im_j, conj_im_k]
intros
rw [is_right_regular, ← mul_right_iterate]
{ rw [is_right_regular, ← mul_right_iterate], exact rra.iterate n }
exact rra.iterate n
intros
simp
intros
simp [mk_ring_hom, quot.sound (rel.of w)]
intros
ext
simp only [mem_singleton_iff, ne.def, function.mem_support]
split
contrapose!
{ contrapose!, exact λ h', single_eq_of_ne h' b }
exact λ h', single_eq_of_ne h' b
rintro rfl
{ rintro rfl, rw single_eq_same, exact h }
rw single_eq_same
exact h
intros
rw [← zero_locus_span {f}, ← zero_locus_span {g}, zero_locus_subset_zero_locus_iff, ideal.span_le, set.singleton_subset_iff, set_like.mem_coe]
intros
rw [nnreal.tsum_mul_right, ← fin.prod_const]
exact (p.change_origin_series k l).le_of_op_nnnorm_le _ (p.nnnorm_change_origin_series_le_tsum _ _)
intros
refine le_radius_of_bound_nnreal _ (∑' i : (Σ n, composition n), nnnorm (comp_along_composition q p i.snd) * r ^ i.fst) (λ n, _)
calc nnnorm (formal_multilinear_series.comp q p n) * r ^ n ≤ ∑' (c : composition n), nnnorm (comp_along_composition q p c) * r ^ n : begin rw [tsum_fintype, ← finset.sum_mul], exact mul_le_mul' (nnnorm_sum_le _ _) le_rfl end ... ≤ ∑' (i : Σ (n : ℕ), composition n), nnnorm (comp_along_composition q p i.snd) * r ^ i.fst : nnreal.tsum_comp_le_tsum_of_inj hr sigma_mk_injective
intros
unfold is_o at *
intros c' c'pos
have : 0 < c' / c
from div_pos c'pos hc
exact ((hfg this).trans hgk (le_of_lt this)).congr_const (div_mul_cancel _ (ne_of_gt hc))
intros
rw is_O_iff; refl
rw is_O_iff
refl
intros
simp [div_eq_inv_mul, deriv_within_const_mul, hc, hxs]
intros
{ ext, unfold deriv_within deriv, rw fderiv_within_univ }
ext
unfold deriv_within deriv
rw fderiv_within_univ
intros
rw add_comm
exact (is_bounded_bilinear_map_comp.has_fderiv_at (d x, c x)).comp x (hd.prod hc)
intros
split
rintros ⟨g', hg'⟩
{ rintros ⟨g', hg'⟩, exact ⟨g', hs.eq (hg'.restrict_scalars 𝕜) hf.has_fderiv_within_at⟩, }
exact ⟨g', hs.eq (hg'.restrict_scalars 𝕜) hf.has_fderiv_within_at⟩
rintros ⟨f', hf'⟩
{ rintros ⟨f', hf'⟩, exact ⟨f', has_fderiv_within_at_of_restrict_scalars 𝕜 hf.has_fderiv_within_at hf'⟩, }
exact ⟨f', has_fderiv_within_at_of_restrict_scalars 𝕜 hf.has_fderiv_within_at hf'⟩
intros
have := φ.has_strict_fderiv_at.to_local_inverse
simp only [prod_fun] at this
convert this.comp (φ.right_fun φ.pt) ((has_strict_fderiv_at_const _ _).prod (has_strict_fderiv_at_id _))
simp only [continuous_linear_map.ext_iff, continuous_linear_map.coe_comp', function.comp_app] at hg'inv hg'invf ⊢
simp [continuous_linear_equiv.eq_symm_apply, *]
intros
apply @lhopital_zero_nhds' _ _ _ f' _ g'
apply @lhopital_zero_nhds' _ _ _ f' _ g'; apply eventually_nhds_within_of_eventually_nhds <|> apply tendsto_nhds_within_of_tendsto_nhds; assumption
apply @lhopital_zero_nhds' _ _ _ f' _ g'; apply eventually_nhds_within_of_eventually_nhds <|> apply tendsto_nhds_within_of_tendsto_nhds
apply eventually_nhds_within_of_eventually_nhds
assumption
apply eventually_nhds_within_of_eventually_nhds
assumption
apply eventually_nhds_within_of_eventually_nhds
assumption
apply eventually_nhds_within_of_eventually_nhds
apply tendsto_nhds_within_of_tendsto_nhds
assumption
apply eventually_nhds_within_of_eventually_nhds
apply tendsto_nhds_within_of_tendsto_nhds
assumption
apply eventually_nhds_within_of_eventually_nhds
apply tendsto_nhds_within_of_tendsto_nhds
assumption
intros
induction n with n IH
{ simp }
simp
simp [iterated_deriv_succ, IH]
{ simp [iterated_deriv_succ, IH], ext x, exact (f_aux_has_deriv_at n x).deriv }
ext x
exact (f_aux_has_deriv_at n x).deriv
intros
simp [← times_cont_diff_on_univ] at *; exact times_cont_diff_on.sum h
simp [← times_cont_diff_on_univ] at *
exact times_cont_diff_on.sum h
intros
rcases h 0 bot_le with ⟨u, hu, p, H⟩
rw [mem_nhds_within_insert] at hu
exact (H.continuous_on.continuous_within_at hu.1).mono_of_mem hu.2
intros
rintro ⟨w, hwB, hwC⟩
obtain ⟨l₁, rfl⟩ := hB ⟨w, hwB⟩
obtain ⟨l₂, rfl⟩ := hC ⟨w, hwC⟩
refine ⟨l₁ + l₂, subset.antisymm _ _⟩
rintro x ⟨⟨hxA, hxB⟩, ⟨-, hxC⟩⟩
{ rintro x ⟨⟨hxA, hxB⟩, ⟨-, hxC⟩⟩, exact ⟨hxA, λ z hz, add_le_add (hxB z hz) (hxC z hz)⟩ }
exact ⟨hxA, λ z hz, add_le_add (hxB z hz) (hxC z hz)⟩
rintro x ⟨hxA, hx⟩
refine ⟨⟨hxA, λ y hy, _⟩, hxA, λ y hy, _⟩
exact (add_le_add_iff_right (l₂ x)).1 ((add_le_add (hwB.2 y hy) (hwC.2 x hxA)).trans (hx w hwB.1))
{ exact (add_le_add_iff_right (l₂ x)).1 ((add_le_add (hwB.2 y hy) (hwC.2 x hxA)).trans (hx w hwB.1)) }
exact (add_le_add_iff_left (l₁ x)).1 (le_trans (add_le_add (hwB.2 x hxA) (hwC.2 y hy)) (hx w hwB.1))
{ exact (add_le_add_iff_left (l₁ x)).1 (le_trans (add_le_add (hwB.2 x hxA) (hwC.2 y hy)) (hx w hwB.1)) }
intros
obtain ⟨a, b, ha, hb, hab, rfl⟩ := hz
exact hf.le_right_of_left_le' hx hy ha.le hb hab hxz
intros
apply convex_on_of_deriv2_nonneg (convex_Ici _) (continuous_pow n).continuous_on differentiable_on_pow
simp only [deriv_pow']
{ simp only [deriv_pow'], exact (@differentiable_on_pow ℝ _ _ _).const_mul (n : ℝ) }
exact (@differentiable_on_pow ℝ _ _ _).const_mul (n : ℝ)
intros x hx
{ intros x hx, rw [iter_deriv_pow, finset.prod_range_cast_nat_sub], exact mul_nonneg (nat.cast_nonneg _) (pow_nonneg (interior_subset hx) _) }
rw [iter_deriv_pow, finset.prod_range_cast_nat_sub]
exact mul_nonneg (nat.cast_nonneg _) (pow_nonneg (interior_subset hx) _)
intros
refine ⟨_, by { rintro rfl, exact submodule.bot_orthogonal_eq_top }⟩
intro h
have : K ⊓ Kᗮ = ⊥ := K.orthogonal_disjoint.eq_bot
rwa [h, inf_comm, top_inf_eq] at this
intros
rw [←inner_conj_sym, inner_zero_left, ring_hom.map_zero]
intros
rw ← add_right_inj (finrank 𝕜 K₁)
{ rw ← add_right_inj (finrank 𝕜 K₁), simp [submodule.finrank_add_inf_finrank_orthogonal h, h_dim] }
simp [submodule.finrank_add_inf_finrank_orthogonal h, h_dim]
intros
simpa using dist_midpoint_midpoint_le' p₁ p₂ p₃ p₄
intros
simp only [← dist_zero_right, dist_pi_le_iff hr, pi.zero_apply]
intros
simpa only [sub_eq_add_neg, dist_neg_neg] using dist_add_add_le g₁ (-g₂) h₁ (-h₂)
intros
convert (has_fpower_series_at_exp_zero_of_radius_pos h).has_strict_fderiv_at
ext x
change x = exp_series 𝕂 𝔸 1 (λ _, x)
simp [exp_series_apply_eq]
intros
{ ext m, simp }
ext m
simp
intros
simp only [norm_def, coe_neg, norm_neg, pi.neg_apply]
intros
ext x
change f.completion x = _
simpa
intros
nontriviality R
rw [eventually_iff, metric.mem_nhds_iff]
have hinv : 0 < ∥(↑x⁻¹ : R)∥⁻¹
cancel_denoms
cancel_denoms
use [∥(↑x⁻¹ : R)∥⁻¹, hinv]
intros t ht
simp only [mem_ball, dist_zero_right] at ht
have ht' : ∥-↑x⁻¹ * t∥ < 1
refine lt_of_le_of_lt (norm_mul_le _ _) _
{ refine lt_of_le_of_lt (norm_mul_le _ _) _, rw norm_neg, refine lt_of_lt_of_le (mul_lt_mul_of_pos_left ht x⁻¹.norm_pos) _, cancel_denoms }
rw norm_neg
refine lt_of_lt_of_le (mul_lt_mul_of_pos_left ht x⁻¹.norm_pos) _
cancel_denoms
have hright := inverse_one_sub (-↑x⁻¹ * t) ht'
have hleft := inverse_unit (x.add t ht)
simp only [← neg_mul_eq_neg_mul, sub_neg_eq_add] at hright
simp only [units.coe_add] at hleft
simp [hleft, hright, units.add]
intros
simp only [norm_eq_sqrt_real_inner, inner_self, norm_sq.map_mul]
exact real.sqrt_mul norm_sq_nonneg _
intros
dsimp [bernstein, polynomial.to_continuous_map_on, polynomial.to_continuous_map, bernstein_polynomial]
simp
intros
rw div_eq_inv_mul
{ rw div_eq_inv_mul, exact (has_strict_deriv_at_log h₂).has_deriv_at.comp x h₁ }
exact (has_strict_deriv_at_log h₂).has_deriv_at.comp x h₁
intros
{ rw [log_of_ne_zero hx.ne'], congr, exact abs_of_pos hx }
rw [log_of_ne_zero hx.ne']
congr
exact abs_of_pos hx
intros
simpa using integral_sin_pow_mul_cos_pow_odd 1 0
intros
refine tendsto.congr' _ ((tendsto_exp_nhds_0_nhds_1.comp (by simpa only [mul_zero, pow_one] using ((@tendsto_const_nhds _ _ _ a _).mul (tendsto_div_pow_mul_exp_add_at_top b c 1 hb (by norm_num))))).comp (tendsto_log_at_top))
apply eventually_eq_of_mem (Ioi_mem_at_top (0:ℝ))
intros x hx
simp only [set.mem_Ioi, function.comp_app] at hx ⊢
rw [exp_log hx, ← exp_log (rpow_pos_of_pos hx (a / (b * x + c))), log_rpow hx (a / (b * x + c))]
field_simp
intros
cases x
rcases lt_trichotomy y 0 with H|H|H; simp [top_rpow_of_pos, top_rpow_of_neg, H, neg_pos.mpr]
rcases lt_trichotomy y 0 with H|H|H
{ rcases lt_trichotomy y 0 with H|H|H; simp [top_rpow_of_pos, top_rpow_of_neg, H, neg_pos.mpr] }
simp [top_rpow_of_pos, top_rpow_of_neg, H, neg_pos.mpr]
simp [top_rpow_of_pos, top_rpow_of_neg, H, neg_pos.mpr]
simp [top_rpow_of_pos, top_rpow_of_neg, H, neg_pos.mpr]
by_cases h : x = 0
{ by_cases h : x = 0, { rcases lt_trichotomy y 0 with H|H|H; simp [h, zero_rpow_of_pos, zero_rpow_of_neg, H, neg_pos.mpr] }, { have A : x ^ y ≠ 0, by simp [h], simp [coe_rpow_of_ne_zero h, ← coe_inv A, nnreal.rpow_neg] } }
rcases lt_trichotomy y 0 with H|H|H; simp [h, zero_rpow_of_pos, zero_rpow_of_neg, H, neg_pos.mpr]
rcases lt_trichotomy y 0 with H|H|H
{ rcases lt_trichotomy y 0 with H|H|H; simp [h, zero_rpow_of_pos, zero_rpow_of_neg, H, neg_pos.mpr] }
simp [h, zero_rpow_of_pos, zero_rpow_of_neg, H, neg_pos.mpr]
simp [h, zero_rpow_of_pos, zero_rpow_of_neg, H, neg_pos.mpr]
simp [h, zero_rpow_of_pos, zero_rpow_of_neg, H, neg_pos.mpr]
have A : x ^ y ≠ 0
{ have A : x ^ y ≠ 0, by simp [h], simp [coe_rpow_of_ne_zero h, ← coe_inv A, nnreal.rpow_neg] }
simp [h]
simp [h]
simp [coe_rpow_of_ne_zero h, ← coe_inv A, nnreal.rpow_neg]
intros
{ rw ← one_rpow z, exact rpow_le_rpow zero_le_one hx hz }
rw ← one_rpow z
exact rpow_le_rpow zero_le_one hx hz
intros
simpa only [cos_zero] using (cos_periodic.int_mul n).add_antiperiod_eq cos_antiperiodic
intros
simp
intros
simp only [cos, div_eq_mul_inv]
convert ((((has_strict_deriv_at_id x).neg.mul_const I).cexp.sub ((has_strict_deriv_at_id x).mul_const I).cexp).mul_const I).mul_const (2:ℂ)⁻¹
simp only [function.comp, id]
rw [sub_mul, mul_assoc, mul_assoc, I_mul_I, neg_one_mul, neg_neg, mul_one, one_mul, mul_assoc, I_mul_I, mul_neg_one, sub_neg_eq_add, add_comm]
intros
rw [← not_exists, not_iff_not, tan_eq_zero_iff]
intros
rw [arccos_eq_pi_div_two_sub_arcsin, sin_pi_div_two_sub, cos_arcsin hx₁ hx₂]
intros
apply nnreal.has_sum_coe.1
push_cast
rw [nnreal.coe_sub (le_of_lt hr)]
exact has_sum_geometric_of_lt_1 r.coe_nonneg hr
intros
simp only [←arrow.mk_hom g, lift.fac_right, arrow.hom_mk'_right]
intros
split
intros Z a b w
replace w := congr_arg (λ k, k ≫ g) w
dsimp at w
rw [category.assoc, category.assoc] at w
exact (cancel_mono _).1 w
intros
{ cases p, simp, }
cases p
simp
intros
injection (constant_of_preserves_morphisms (λ k, ulift.up (k ∈ p)) (λ j₁ j₂ f, _) j j₀) with i
rwa i
dsimp
exact congr_arg ulift.up (propext (h1 f))
intros
apply (cancel_epi (inv f)).1
erw [inv_hom_id, p, inv_hom_id]
intros
ext1
rw [←category.assoc]
simp
intros
simp
intros
rw ←is_image.e_iso_ext_hom F.to_mono_is_image hF'
{ rw ←is_image.e_iso_ext_hom F.to_mono_is_image hF', apply strong_epi_comp }
apply strong_epi_comp
intros
apply quot.eq.1
simpa using congr_arg (colimit_equiv_quot F) w
intros
{ rw [←tensor_comp], simp }
rw [←tensor_comp]
simp
intros
have pent := pentagon W X Y Z
rw ←iso.inv_comp_eq at pent
rw [←pent]
simp only [tensor_id, assoc, id_comp, comp_id, hom_inv_id, tensor_hom_inv_id_assoc]
intros
rw [naturality, ←category.assoc, ←nat_trans.comp_app, α.hom_inv_id, id_app, category.id_comp]
intros
rw [covers_iff, bot_covering, ← sieve.pullback_eq_top_iff_mem]
intros
rw ← is_separated_for_and_exists_is_amalgamation_iff_sheaf_for
split
intros x t₁ t₂ ht₁ ht₂
{ intros x t₁ t₂ ht₁ ht₂, exact hS.is_separated_for _ _ _ (is_amalgamation_restrict h x t₁ ht₁) (is_amalgamation_restrict h x t₂ ht₂) }
exact hS.is_separated_for _ _ _ (is_amalgamation_restrict h x t₁ ht₁) (is_amalgamation_restrict h x t₂ ht₂)
intros x hx
{ intros x hx, use hS.amalgamate _ (hx.restrict h), intros W j hj, apply (trans hj).ext, intros Y f hf, rw [←functor_to_types.map_comp_apply, ←op_comp, hS.valid_glue (hx.restrict h) _ hf, family_of_elements.restrict, ←hx (𝟙 _) f _ _ (id_comp _)], simp }
use hS.amalgamate _ (hx.restrict h)
intros W j hj
apply (trans hj).ext
intros Y f hf
rw [←functor_to_types.map_comp_apply, ←op_comp, hS.valid_glue (hx.restrict h) _ hf, family_of_elements.restrict, ←hx (𝟙 _) f _ _ (id_comp _)]
simp
intros
apply quotient.induction_on' x
intro f
apply quotient.sound
exact ⟨mono_over.pullback_id.app f⟩
intros
simp [types_comp]
intros
{ rw c.card_boundaries_eq_succ_length, exact lt_add_one _ }
rw c.card_boundaries_eq_succ_length
exact lt_add_one _
intros
{ funext i, cases i; refl }
funext i
cases i
cases i; refl
refl
refl
intros
rw ←card_univ
rw @card_eq_sum_card_fiberwise _ _ _ dart.edge _ G.edge_finset (λ d h, by { rw mem_edge_finset, apply dart.edge_mem })
rw [←mul_comm, sum_const_nat]
intros e h
apply G.dart_edge_fiber_card e
rwa ←mem_edge_finset
intros
simp [mul_def]
intros
conv {to_lhs, rw [← list_blank.cons_head_tail l]}
exact quotient.induction_on' l (λ a, rfl)
intros
simp [guard]
intros
ext
ext; simp [map_traverse]
simp [map_traverse]
intros
cases F; subst f; simp
cases F; subst f
cases F
subst f
simp
intros
cases b; simp only [nat.add_mul_div_left, add_lsb, ←two_mul, add_comm, nat.succ_pos', nat.mul_div_right, gt_iff_lt, zero_add, cond]; norm_num
cases b; simp only [nat.add_mul_div_left, add_lsb, ←two_mul, add_comm, nat.succ_pos', nat.mul_div_right, gt_iff_lt, zero_add, cond]
cases b
simp only [nat.add_mul_div_left, add_lsb, ←two_mul, add_comm, nat.succ_pos', nat.mul_div_right, gt_iff_lt, zero_add, cond]
simp only [nat.add_mul_div_left, add_lsb, ←two_mul, add_comm, nat.succ_pos', nat.mul_div_right, gt_iff_lt, zero_add, cond]
norm_num
intros
introI
have : (pure a : parser α) buffer.nil 0 = done 0 a := by simp [pure_eq_done]
exact absurd (bounded.of_done this) (lt_irrefl _)
intros
obtain ⟨np, a, hp⟩ := p.exists_done cb n
simpa [hp] using h
intros
simp [map_const_eq]
intros
by_cases hn : n = n'
{ simp [hn, pure_eq_done] }
simp [hn, pure_eq_done]
{ simp [orelse_eq_fail_of_mono_ne, hn] }
simp [orelse_eq_fail_of_mono_ne, hn]
intros
simp only [many', eps_eq_done, many, foldr, and_then_eq_bind, exists_and_distrib_right, bind_eq_done, exists_eq_right]
split
rintro ⟨_ | ⟨hd, tl⟩, hl⟩
{ rintro ⟨_ | ⟨hd, tl⟩, hl⟩, { exact or.inl hl }, { have hl2 := hl, simp only [foldr_core_eq_done, or_false, exists_and_distrib_left, and_false, false_and, exists_eq_right_right] at hl, obtain ⟨np, hp, h⟩ := hl, refine or.inr ⟨np, _, _, hl2, hp, h⟩ } }
{ exact or.inl hl }
exact or.inl hl
have hl2 := hl
{ have hl2 := hl, simp only [foldr_core_eq_done, or_false, exists_and_distrib_left, and_false, false_and, exists_eq_right_right] at hl, obtain ⟨np, hp, h⟩ := hl, refine or.inr ⟨np, _, _, hl2, hp, h⟩ }
simp only [foldr_core_eq_done, or_false, exists_and_distrib_left, and_false, false_and, exists_eq_right_right] at hl
obtain ⟨np, hp, h⟩ := hl
refine or.inr ⟨np, _, _, hl2, hp, h⟩
rintro (h | ⟨np, a, l, hp, h⟩)
{ rintro (h | ⟨np, a, l, hp, h⟩), { exact ⟨[], h⟩ }, { refine ⟨a :: l, hp⟩ } }
{ exact ⟨[], h⟩ }
exact ⟨[], h⟩
{ refine ⟨a :: l, hp⟩ }
refine ⟨a :: l, hp⟩
rw [← of_real_zero, ← of_real_inv, inv_zero]
intros
rw ← of_real_inj; simp [sin_three_mul]
rw ← of_real_inj
simp [sin_three_mul]
intros
rw [two_mul, cosh_add, sq, sq]
intros
rw algebra.smul_def
{ rw algebra.smul_def, apply of_real_mul_re }
apply of_real_mul_re
intros
by_cases h : r = 0
{ simp [h, of_real_zero] }
simp [h, of_real_zero]
change r ≠ 0 at h
{ change r ≠ 0 at h, rw [div_eq_mul_inv, ←of_real_inv, div_eq_mul_inv], simp [norm_sq, div_mul_eq_div_mul_one_div, div_self h] }
rw [div_eq_mul_inv, ←of_real_inv, div_eq_mul_inv]
simp [norm_sq, div_mul_eq_div_mul_one_div, div_self h]
intros
by_cases h : b ≠ 0
{ simp [dfinsupp.prod, support_single_ne_zero h] }
simp [dfinsupp.prod, support_single_ne_zero h]
rw [not_not] at h
{ rw [not_not] at h, simp [h, prod_zero_index, h_zero], refl }
simp [h, prod_zero_index, h_zero]
refl
intros
refine quotient.induction_on f (λ x, _)
cases x with f s H
revert f H
apply multiset.induction_on s
intros f H
{ intros f H, convert h0, ext i, exact (H i).resolve_left id }
convert h0
ext i
exact (H i).resolve_left id
intros i s ih f H
by_cases H1 : i ∈ s
have H2 : ∀ j, j ∈ s ∨ f j = 0
{ have H2 : ∀ j, j ∈ s ∨ f j = 0, { intro j, cases H j with H2 H2, { cases multiset.mem_cons.1 H2 with H3 H3, { left, rw H3, exact H1 }, { left, exact H3 } }, right, exact H2 }, have H3 : (⟦{to_fun := f, pre_support := i ::ₘ s, zero := H}⟧ : Π₀ i, β i) = ⟦{to_fun := f, pre_support := s, zero := H2}⟧, { exact quotient.sound (λ i, rfl) }, rw H3, apply ih }
intro j
{ intro j, cases H j with H2 H2, { cases multiset.mem_cons.1 H2 with H3 H3, { left, rw H3, exact H1 }, { left, exact H3 } }, right, exact H2 }
cases H j with H2 H2
cases multiset.mem_cons.1 H2 with H3 H3
{ cases multiset.mem_cons.1 H2 with H3 H3, { left, rw H3, exact H1 }, { left, exact H3 } }
left
{ left, rw H3, exact H1 }
rw H3
exact H1
left
{ left, exact H3 }
exact H3
right
exact H2
have H3 : (⟦{to_fun := f, pre_support := i ::ₘ s, zero := H}⟧ : Π₀ i, β i) = ⟦{to_fun := f, pre_support := s, zero := H2}⟧
{ exact quotient.sound (λ i, rfl) }
exact quotient.sound (λ i, rfl)
rw H3
apply ih
have H2 : p (erase i ⟦{to_fun := f, pre_support := i ::ₘ s, zero := H}⟧)
dsimp only [erase, quotient.map_mk]
{ dsimp only [erase, quotient.map_mk], have H2 : ∀ j, j ∈ s ∨ ite (j = i) 0 (f j) = 0, { intro j, cases H j with H2 H2, { cases multiset.mem_cons.1 H2 with H3 H3, { right, exact if_pos H3 }, { left, exact H3 } }, right, split_ifs; [refl, exact H2] }, have H3 : (⟦{to_fun := λ (j : ι), ite (j = i) 0 (f j), pre_support := i ::ₘ s, zero := _}⟧ : Π₀ i, β i) = ⟦{to_fun := λ (j : ι), ite (j = i) 0 (f j), pre_support := s, zero := H2}⟧ := quotient.sound (λ i, rfl), rw H3, apply ih }
have H2 : ∀ j, j ∈ s ∨ ite (j = i) 0 (f j) = 0
intro j
{ intro j, cases H j with H2 H2, { cases multiset.mem_cons.1 H2 with H3 H3, { right, exact if_pos H3 }, { left, exact H3 } }, right, split_ifs; [refl, exact H2] }
cases H j with H2 H2
cases multiset.mem_cons.1 H2 with H3 H3
{ cases multiset.mem_cons.1 H2 with H3 H3, { right, exact if_pos H3 }, { left, exact H3 } }
right
{ right, exact if_pos H3 }
exact if_pos H3
left
{ left, exact H3 }
exact H3
right
split_ifs
split_ifs; [refl, exact H2]
refl
exact H2
have H3 : (⟦{to_fun := λ (j : ι), ite (j = i) 0 (f j), pre_support := i ::ₘ s, zero := _}⟧ : Π₀ i, β i) = ⟦{to_fun := λ (j : ι), ite (j = i) 0 (f j), pre_support := s, zero := H2}⟧ := quotient.sound (λ i, rfl)
rw H3
apply ih
have H3 : single i _ + _ = (⟦{to_fun := f, pre_support := i ::ₘ s, zero := H}⟧ : Π₀ i, β i) := single_add_erase _ _
rw ← H3
change p (single i (f i) + _)
cases classical.em (f i = 0) with h h
{ rw [h, single_zero, zero_add], exact H2 }
rw [h, single_zero, zero_add]
exact H2
refine ha _ _ _ _ h H2
rw erase_same
intros
{ ext1 x, cases x, refl }
ext1 x
cases x
refl
intros
{ convert perm.subtype_congr.left_apply _ _ a.property, simp }
convert perm.subtype_congr.left_apply _ _ a.property
simp
intros
{ rw [succ_above_below, cast_succ_cast_lt], exact h }
rw [succ_above_below, cast_succ_cast_lt]
exact h
intros
rw [← not_exists, ← is_some_find_iff]; cases (find p); simp
rw [← not_exists, ← is_some_find_iff]; cases (find p)
rw [← not_exists, ← is_some_find_iff]
cases (find p)
simp
simp
intros
{ rw [lt_iff_coe_lt_coe, coe_zero], exact nat.succ_pos i }
rw [lt_iff_coe_lt_coe, coe_zero]
exact nat.succ_pos i
intros
cases i; refl
cases i
refl
refl
intros
rw update_piecewise
refine s.piecewise_congr (λ j hj, update_noteq _ _ _) (λ _ _, rfl)
exact λ h, hi (h ▸ hj)
intros
simp only [finset.subset_iff, multiset.subset_iff, multiset.mem_to_finset]
intros
classical
by_contra hz
push_neg at hz
refine hc.not_le (card_le_card_of_inj_on f hf _)
intros x hx y hy
contrapose
exact hz x hx y hy
intros
{ rw nonempty_iff_ne_empty, exact not_not, }
rw nonempty_iff_ne_empty
exact not_not
intros
simp only [insert_eq, union_left_comm]
intros
show _ > _ ↔ _
apply fold_op_rel_iff_and
intros x y z
show _ < _ ↔ _
exact max_lt_iff
intros
rw [← supr_coe, coe_image, supr_image, supr_coe]
intros
apply iff.trans multiset.sup_le
simp only [multiset.mem_map, and_imp, exists_imp_distrib]
exact ⟨λ k b hb, k _ _ hb rfl, λ k a' b hb h, h ▸ k _ hb⟩
intros
apply eq_of_veq
rw [insert_val_of_not_mem, map_val]
{apply multiset.nat.antidiagonal_succ}
apply multiset.nat.antidiagonal_succ
intro con
{ intro con, rcases mem_map.1 con with ⟨⟨a,b⟩, ⟨h1, h2⟩⟩, simp only [prod.mk.inj_iff, function.embedding.coe_prod_map, prod.map_mk] at h2, apply nat.succ_ne_zero a h2.1, }
rcases mem_map.1 con with ⟨⟨a,b⟩, ⟨h1, h2⟩⟩
simp only [prod.mk.inj_iff, function.embedding.coe_prod_map, prod.map_mk] at h2
apply nat.succ_ne_zero a h2.1
intros
{ subst s, ext y, simp [h₂] { contextual := tt } }
subst s
ext y
simp [h₂] { contextual := tt }
intros
simp [order_emb_of_fin, set.range_comp coe (s.order_iso_of_fin h)]
intros
ext x
ext x; refl
refl
intros
{ ext, simp }
ext
simp
intros
ext ⟨b, h⟩
apply f.injective
simp [f.left_inv_of_inv_of_mem_range, @inv_fun_eq _ _ _ f b (set.mem_range.mp h)]
intros
simp
intros
rw to_nat_le; exact le_trans h (le_to_nat b)
rw to_nat_le
exact le_trans h (le_to_nat b)
intros
cases a; cases b; simp only [← int.mul_def, int.mul, nat_abs_neg_of_nat, eq_self_iff_true, int.nat_abs]
cases a; cases b
cases a
cases b
simp only [← int.mul_def, int.mul, nat_abs_neg_of_nat, eq_self_iff_true, int.nat_abs]
simp only [← int.mul_def, int.mul, nat_abs_neg_of_nat, eq_self_iff_true, int.nat_abs]
cases b
simp only [← int.mul_def, int.mul, nat_abs_neg_of_nat, eq_self_iff_true, int.nat_abs]
simp only [← int.mul_def, int.mul, nat_abs_neg_of_nat, eq_self_iff_true, int.nat_abs]
intros
rw [add_comm, add_mod_self]
intros
rw [abs_eq_nat_abs]; refl
rw [abs_eq_nat_abs]
refl
intros
cases (nat.eq_zero_or_pos (nat_abs b))
rw eq_zero_of_nat_abs_eq_zero h
{rw eq_zero_of_nat_abs_eq_zero h, simp [int.div_zero]}
simp [int.div_zero]
calc nat_abs (a / b) = nat_abs (a / b) * 1 : by rw mul_one ... = nat_abs (a / b) * (nat_abs b / nat_abs b) : by rw nat.div_self h ... = nat_abs (a / b) * nat_abs b / nat_abs b : by rw (nat.mul_div_assoc _ dvd_rfl) ... = nat_abs (a / b * b) / nat_abs b : by rw (nat_abs_mul (a / b) b) ... = nat_abs a / nat_abs b : by rw int.div_mul_cancel H
intros
rwa [← hx, ← hy, int.coe_nat_gcd]
intros
rw [mul_comm a, mul_comm b, mul_comm n]; exact h.mul_left' hc
rw [mul_comm a, mul_comm b, mul_comm n]
exact h.mul_left' hc
intros
rw [odd_iff, mod_two_ne_one]
intros
ext : 1; simp only [alist.insert_entries, list.kerase_cons_eq]; constructor_matching* [_ ∧ _]; refl
ext : 1; simp only [alist.insert_entries, list.kerase_cons_eq]; constructor_matching* [_ ∧ _]
ext : 1; simp only [alist.insert_entries, list.kerase_cons_eq]
ext : 1
simp only [alist.insert_entries, list.kerase_cons_eq]
constructor_matching* [_ ∧ _]
refl
refl
refl
intros
rw [remove_nth_eq_nth_tail, insert_nth, modify_nth_tail_modify_nth_tail_same]
rw [remove_nth_eq_nth_tail, insert_nth, modify_nth_tail_modify_nth_tail_same]; from modify_nth_tail_id _ _
from modify_nth_tail_id _ _
intros
cases l; cases n; simp only [update_nth]
cases l; cases n
cases l
cases n
simp only [update_nth]
simp only [update_nth]
cases n
simp only [update_nth]
simp only [update_nth]
intros
rw [insert_neg, singleton_eq]
{ rw [insert_neg, singleton_eq], rwa [singleton_eq, mem_singleton] }
rwa [singleton_eq, mem_singleton]
intros
funext l
induction l with a l IH
refl
{refl}
simp only [filter_map_cons_some (some ∘ f) _ _ rfl, IH, map_cons]
split
split; refl
refl
refl
intros
induction ys generalizing f
{ simp }
simp
{ simp [ys_ih (λ xs, f (ys_hd :: xs))] }
simp [ys_ih (λ xs, f (ys_hd :: xs))]
intros
simp only [map₂_right, map₂_right', map₂_left_eq_map₂_left']
intros
induction s; [rw [nil_append, reverse_nil, append_nil], simp only [*, cons_append, reverse_cons, append_assoc]]
induction s
rw [nil_append, reverse_nil, append_nil]
simp only [*, cons_append, reverse_cons, append_assoc]
intros
cases l
cases l; refl
refl
refl
intros
rw [next, next_or_concat]
{ refl }
refl
{ simp [hy, hx] }
simp [hy, hx]
intros
induction s using quot.induction_on
exact next_mem _ _ _
intros
simp only [foldl_with_index, foldl_with_index_aux_spec, foldl_with_index_aux_eq_foldl_with_index_aux_spec, enum]
intros
obtain ⟨xs, hp, h⟩ := h
exact ⟨_, hp.filter p, h.filter p⟩
intros
induction l; simp [*, perm.insert]
induction l
simp [*, perm.insert]
simp [*, perm.insert]
intros
obtain ⟨k, hk, rfl⟩ := nth_le_of_mem h
simp
intros
cases nd.eq_of_fst_eq h h' rfl; refl
cases nd.eq_of_fst_eq h h' rfl
refl
intros
simp only [unzip_eq_map]
intros
{ ext, apply dot_product_add }
ext
apply dot_product_add
intros
ext i j
ext i j; simp
simp
intros
simp only [matrix.mul_vec, matrix.map_apply, ring_hom.map_dot_product]
intros
simp [dot_product, finset.smul_sum, mul_smul_comm]
intros
{ ext, simp [vec_mul] }
ext
simp [vec_mul]
intros
{ ext, simp [block_diagonal_apply] }
ext
simp [block_diagonal_apply]
intros
simp only [vec_cons, fin.cons, fin.cases_succ']
intros
{ ext i, refine fin.cases _ _ i; simp }
ext i
refine fin.cases _ _ i
refine fin.cases _ _ i; simp
simp
simp
intros
simp
intros
ext
ext; simp
simp
intros
rw [← inf_erase_dup, erase_dup_ext.2, inf_erase_dup, inf_cons]
rw [← inf_erase_dup, erase_dup_ext.2, inf_erase_dup, inf_cons]; simp
simp
intros
simp [powerset_len_aux_eq_map_coe]; refl
simp [powerset_len_aux_eq_map_coe]
refl
intros
{ convert comap_id_apply x, ext1 φ, rw [hf, alg_hom.id_apply] }
convert comap_id_apply x
ext1 φ
rw [hf, alg_hom.id_apply]
intros
rw [aeval_eq_bind₁, bind₁_X_left, alg_hom.id_apply]
intros
dsimp only [degrees]
apply multiset.subset_of_le
apply finset.sup_mono
apply mv_polynomial.support_map_subset
intros
rw [mul_comm, ← nat.div_lt_iff_lt_mul' n0]
exact lt_succ_self _
intros
convert (range_of_succ _).symm
ext n
induction n with n ihn
{ refl }
refl
dsimp at ihn ⊢
{ dsimp at ihn ⊢, rw ihn }
rw ihn
intros
rw [lxor_comm n m, lxor_comm n' m] at h
{ rw [lxor_comm n m, lxor_comm n' m] at h, exact lxor_right_inj h }
exact lxor_right_inj h
intros
have A : ∀n:ℕ, P n := λ n, nat.rec_on n h0 hsuc
cases a
{ exact htop A }
exact htop A
{ exact A a }
exact A a
intros
induction l with hd tl IH
{ simp [of_digits], }
simp [of_digits]
rw [of_digits, list.length_cons, pow_succ]
{ rw [of_digits, list.length_cons, pow_succ], have : (of_digits (b + 2) tl + 1) * (b+2) ≤ (b + 2) ^ tl.length * (b+2) := mul_le_mul (IH (λ x hx, hl _ (list.mem_cons_of_mem _ hx))) (by refl) dec_trivial (nat.zero_le _), suffices : ↑hd < b + 2, { linarith }, norm_cast, exact hl hd (list.mem_cons_self _ _) }
have : (of_digits (b + 2) tl + 1) * (b+2) ≤ (b + 2) ^ tl.length * (b+2) := mul_le_mul (IH (λ x hx, hl _ (list.mem_cons_of_mem _ hx))) (by refl) dec_trivial (nat.zero_le _)
suffices : ↑hd < b + 2
{ linarith }
linarith
norm_cast
exact hl hd (list.mem_cons_self _ _)
intros
rw dist_comm; apply dist_tri_left
rw dist_comm
apply dist_tri_left
intros
cases le_or_lt b 1 with hb hb
{ rw log_of_left_le_one hb, exact zero_le _ }
rw log_of_left_le_one hb
exact zero_le _
{ cases nat.eq_zero_or_pos n with hn hn, { rw [hn, log_zero_right], exact zero_le _ }, { rw ←pow_le_iff_le_log hb (hn.trans_le h), exact (pow_log_le_self hb hn).trans h } }
cases nat.eq_zero_or_pos n with hn hn
{ rw [hn, log_zero_right], exact zero_le _ }
rw [hn, log_zero_right]
exact zero_le _
rw ←pow_le_iff_le_log hb (hn.trans_le h)
{ rw ←pow_le_iff_le_log hb (hn.trans_le h), exact (pow_log_le_self hb hn).trans h }
exact (pow_log_le_self hb hn).trans h
intros
rw [← add_mod_add_ite, if_neg (not_le_of_lt hc), add_zero]
intros
rw [← one_shiftl]
have : ∀ {n}, n = 0 → n < shiftl 1 (size n)
simp
{ simp }
apply binary_rec _ _ n
apply this rfl
{apply this rfl}
intros b n IH
by_cases bit b n = 0
apply this h
{apply this h}
rw [size_bit h, shiftl_succ]
exact bit_lt_bit0 _ IH
intros
apply iff.intro
intro h
{ intro h, exact ⟨min_fac (gcd m n), min_fac_prime h, ((min_fac_dvd (gcd m n)).trans (gcd_dvd_left m n)), ((min_fac_dvd (gcd m n)).trans (gcd_dvd_right m n))⟩ }
exact ⟨min_fac (gcd m n), min_fac_prime h, ((min_fac_dvd (gcd m n)).trans (gcd_dvd_left m n)), ((min_fac_dvd (gcd m n)).trans (gcd_dvd_right m n))⟩
intro h
{ intro h, cases h with p hp, apply nat.not_coprime_of_dvd_of_dvd (prime.one_lt hp.1) hp.2.1 hp.2.2 }
cases h with p hp
apply nat.not_coprime_of_dvd_of_dvd (prime.one_lt hp.1) hp.2.1 hp.2.2
intros
rw [← n.to_nat_to_int, to_nat_eq_succ_pred]; refl
rw [← n.to_nat_to_int, to_nat_eq_succ_pred]
refl
intros
cases x; simp
{ cases x; simp }
cases x
simp
simp
intros
cases o; refl
cases o
refl
refl
intros
cases m; simp [node4_l, node4_r, dual_node3_l, dual_node']
cases m
simp [node4_l, node4_r, dual_node3_l, dual_node']
simp [node4_l, node4_r, dual_node3_l, dual_node']
intros
rw [← find_min'_dual, dual_dual]
intros
split
rw [ne, eq_none_iff', not_not]
{ rw [ne, eq_none_iff', not_not], exact λ h, ⟨o.get h, eq_some_iff.2 (get_mem h)⟩ }
exact λ h, ⟨o.get h, eq_some_iff.2 (get_mem h)⟩
{ rintro ⟨x, rfl⟩, apply some_ne_none }
rintro ⟨x, rfl⟩
apply some_ne_none
intros
{ cases x, dsimp [const.get,const.mk], congr' with _ ⟨ ⟩ }
cases x
dsimp [const.get,const.mk]
congr' with _ ⟨ ⟩
intros
{ rw mul_comm, exact mod_add_div _ _ }
rw mul_comm
exact mod_add_div _ _
intros
let h := @prod_dvd_iff u n.factor_multiset
{ let h := @prod_dvd_iff u n.factor_multiset, rw [n.prod_factor_multiset] at h, exact h }
rw [n.prod_factor_multiset] at h
exact h
intros
induction k with k ih
{ simp [pow_zero, monomial_zero_one], }
simp [pow_zero, monomial_zero_one]
simp [pow_succ, ih, monomial_mul_monomial, nat.succ_eq_add_one, mul_add, add_comm]
{ simp [pow_succ, ih, monomial_mul_monomial, nat.succ_eq_add_one, mul_add, add_comm] }
intros
rw [←one_smul R p, ←h, zero_smul]
intros
rw [degree, ← monomial_zero_left, support_monomial 0 _ ha, sup_singleton]
{ rw [degree, ← monomial_zero_left, support_monomial 0 _ ha, sup_singleton], refl }
refl
intros
by_cases hp : p = 0
simp [hp]
{ simp [hp], rw bot_lt_iff_ne_bot, intro hq, simpa [hp, degree_eq_bot.mp hq, lt_irrefl] using h }
rw bot_lt_iff_ne_bot
intro hq
simpa [hp, degree_eq_bot.mp hq, lt_irrefl] using h
rw [degree_eq_nat_degree hp, degree_eq_nat_degree $ ne_zero_of_nat_degree_gt h]
{ rw [degree_eq_nat_degree hp, degree_eq_nat_degree $ ne_zero_of_nat_degree_gt h], exact_mod_cast h }
exact_mod_cast h
intros
rw [C_mul_X_pow_eq_monomial, C_mul_X_pow_eq_monomial, derivative_monomial]
intros
simp [eval₂_eq_sum]
intros
simp only [←C_eq_int_cast, eval_C]
intros
rw [ne.def, ← leading_coeff_eq_zero, ← ne.def, ← is_unit_iff_ne_zero] at hp0
rw [monic, leading_coeff_normalize, normalize_eq_one]
apply hp0
intros
rw [iterated_deriv, iterated_deriv, function.iterate_succ']
intros
rw [←C_mul', ←C_mul', mirror_mul_of_domain, mirror_C]
intros
by_cases h : p = 1
{ simpa [h] }
simpa [h]
rw [ne.def, ←degree_eq_bot, hp.degree_mul, with_bot.add_eq_bot, not_or_distrib, degree_eq_bot]
refine ⟨hq, _⟩
rw [←hp.degree_le_zero_iff_eq_one, not_le] at h
refine (lt_trans _ h).ne'
simp
intros
rw [nat_degree_le_iff_degree_le, degree_le_iff_coeff_zero]
intros n hn
rw with_bot.coe_lt_coe at hn
rw [coeff_reverse, rev_at, function.embedding.coe_fn_mk, if_neg (not_le_of_gt hn), coeff_eq_zero_of_nat_degree_lt hn]
intros
have dz := degree_eq_zero_of_is_unit H
rw degree_map_eq_of_leading_coeff_ne_zero at dz
rw eq_C_of_degree_eq_zero dz
{ rw eq_C_of_degree_eq_zero dz, refine is_unit.map (C.to_monoid_hom : R →* polynomial R) _, convert hf, rw (degree_eq_iff_nat_degree_eq _).1 dz, rintro rfl, simpa using H, }
refine is_unit.map (C.to_monoid_hom : R →* polynomial R) _
convert hf
rw (degree_eq_iff_nat_degree_eq _).1 dz
rintro rfl
simpa using H
intro h
{ intro h, have u : is_unit (φ f.leading_coeff) := is_unit.map φ.to_monoid_hom hf, rw h at u, simpa using u, }
have u : is_unit (φ f.leading_coeff) := is_unit.map φ.to_monoid_hom hf
rw h at u
simpa using u
intros
split
intros h
{ intros h, have : liftp (supp x) x, by { rw h, introv, exact id, }, rw liftp_iff at this, rcases this with ⟨a, f, xeq, h'⟩, refine ⟨a, f, xeq.symm, _⟩, intros a' f' h'', rintros hu u ⟨j, h₂, hfi⟩, have hh : u ∈ supp x a', by rw ←hfi; apply h', refine (mem_supp x _ u).mp hh _ _ hu, }
have : liftp (supp x) x
rw h
rw h
{ rw h, introv, exact id, }
{ rw h, introv, exact id, }
introv
introv
exact id
exact id
rw liftp_iff at this
rcases this with ⟨a, f, xeq, h'⟩
refine ⟨a, f, xeq.symm, _⟩
intros a' f' h''
rintros hu u ⟨j, h₂, hfi⟩
have hh : u ∈ supp x a'
rw ←hfi
rw ←hfi
rw ←hfi; apply h'
rw ←hfi; apply h'
apply h'
apply h'
refine (mem_supp x _ u).mp hh _ _ hu
rintros ⟨a, f, xeq, h⟩ p
rw liftp_iff
split
rintros ⟨a', f', xeq', h'⟩ i u usuppx
{ rintros ⟨a', f', xeq', h'⟩ i u usuppx, rcases (mem_supp x _ u).mp @usuppx a' f' xeq'.symm with ⟨i, _, f'ieq⟩, rw ←f'ieq, apply h' }
rcases (mem_supp x _ u).mp @usuppx a' f' xeq'.symm with ⟨i, _, f'ieq⟩
rw ←f'ieq
apply h'
intro h'
refine ⟨a, f, xeq.symm, _⟩
intros j y
apply h'
rw mem_supp
intros a' f' xeq'
apply h _ a' f' xeq'
apply mem_image_of_mem _ (mem_univ _)
intros
rw [← int.cast_coe_nat, ← mk_eq_div, num_denom]
intros
rw [← sub_nonneg, ← cast_sub, cast_nonneg, sub_nonneg]
intros
rw [sqrt, mul_self_num, mul_self_denom, int.sqrt_eq, nat.sqrt_eq, abs_def]
intros
rw [mul_comm, to_nnreal_mul_top]
norm_cast
intros
simpa only [bit1_zero] using @bit1_inj a 0
intros
simp [lt_top_iff_ne_top, not_or_distrib]
intros
norm_cast
pi_lower_bound [ 11482/8119, 7792/4217, 54055/27557, 949247/476920, 3310126/1657059, 2635492/1318143, 1580265/790192, 1221775/610899, 3612247/1806132, 849943/424972]
intros
rw [sqrt, sqrt, nnreal.coe_lt_coe, nnreal.sqrt_lt_sqrt_iff, to_nnreal_lt_to_nnreal_iff hy]
intros
ext x
simp [core, comp]
split
{ exact λ h y rxy z, h z y rxy }
exact λ h y rxy z, h z y rxy
{ exact λ h z y rzy, h y rzy z }
exact λ h z y rzy, h y rzy z
intros
refine ⟨swap (lift_rel R), h, λ s t (h : lift_rel R t s), _⟩
rw [←lift_rel_o.swap, computation.lift_rel.swap]
apply lift_rel_destruct h
intros
revert s
induction n with n IH
induction n with n IH; intros s h
intros s h
rcases exists_of_mem_map h with ⟨o, h1, h2⟩
{ rcases exists_of_mem_map h with ⟨o, h1, h2⟩, cases o with o; injection h2 with h', cases o with a' s', exact (eq_or_mem_iff_mem h1).2 (or.inl h'.symm) }
cases o with o; injection h2 with h'
cases o with o
injection h2 with h'
injection h2 with h'
cases o with a' s'
exact (eq_or_mem_iff_mem h1).2 (or.inl h'.symm)
intros s h
have := @IH (tail s)
{ have := @IH (tail s), rw nth_tail at this, exact mem_of_mem_tail (this h) }
rw nth_tail at this
exact mem_of_mem_tail (this h)
intros
rw range_comp; apply image_subset_range
rw range_comp
apply image_subset_range
intros
apply preimage_subset_preimage_iff
{ apply preimage_subset_preimage_iff, rw [hf.range_eq], apply subset_univ }
rw [hf.range_eq]
apply subset_univ
intros
rw [image_swap_eq_preimage_swap, preimage_swap_prod]
intros
{ cases x, refl }
cases x
refl
intros
simp only [← subset_empty_iff]; exact union_subset_iff
simp only [← subset_empty_iff]
exact union_subset_iff
intros
rw ←range_subset_iff at hf
{ rw ←range_subset_iff at hf, exact (infinite_range_of_injective hi).mono hf }
exact (infinite_range_of_injective hi).mono hf
intros
rw [← finset.coe_subset, ht.coe_to_finset]
intros
ext x
rcases em (x ∈ range f) with ⟨a, rfl⟩|hx
{ simp [left_inverse_inv_fun hf _, hf.mem_set_image] }
simp [left_inverse_inv_fun hf _, hf.mem_set_image]
{ simp [mem_preimage, inv_fun_neg hx, h, hx] }
simp [mem_preimage, inv_fun_neg hx, h, hx]
intros
rw [e.image_eq_preimage, e.symm.preimage_Iio, e.symm_symm]
intros
simp [← Ioi_inter_Iic]
intros
simp [← Ioi_inter_Iic, ← Ici_inter_Iio, inter_comm]
intros
simp [sub_eq_neg_add]
intros
convert image_mul_right_Icc' b c h using 1; simp only [mul_comm _ a]
convert image_mul_right_Icc' b c h using 1
{ convert image_mul_right_Icc' b c h using 1; simp only [mul_comm _ a] }
simp only [mul_comm _ a]
simp only [mul_comm _ a]
intros
classical
intros p hp
rcases h_surj p with ⟨x, rfl⟩
refine ⟨x, mem_Ioo.2 _, rfl⟩
by_contra h
cases not_and_distrib.mp h with ha hb
exact has_lt.lt.false (lt_of_lt_of_le hp.1 (h_mono (not_lt.mp ha)))
{ exact has_lt.lt.false (lt_of_lt_of_le hp.1 (h_mono (not_lt.mp ha))) }
exact has_lt.lt.false (lt_of_le_of_lt (h_mono (not_lt.mp hb)) hp.2)
{ exact has_lt.lt.false (lt_of_le_of_lt (h_mono (not_lt.mp hb)) hp.2) }
intros
simp only [← image_prod, prod_Union, image_Union]
intros
simp [← ne_empty_iff_nonempty]
intros
tidy
intros
ext i
ext i; induction i; [refl, apply i_ih]
ext i; induction i
induction i
refl
apply i_ih
intros
cases n
have : v = nil := by simp only [eq_iff_true_of_subsingleton]
{ have : v = nil := by simp only [eq_iff_true_of_subsingleton], simp only [this, scanl_nil, cons_head] }
simp only [this, scanl_nil, cons_head]
rw ←cons_head_tail v
{ rw ←cons_head_tail v, simp only [←nth_zero, nth_eq_nth_le, to_list_scanl, to_list_cons, list.scanl, fin.val_zero', list.nth_le] }
simp only [←nth_zero, nth_eq_nth_le, to_list_scanl, to_list_cons, list.scanl, fin.val_zero', list.nth_le]
intros
{ ext, simp [nth_tail], }
ext
simp [nth_tail]
intros
rw zmod.int_coe_eq_int_coe_iff
apply int.mod_modeq
intros
rw neg_val'
by_cases h : a = 0
rw [if_pos h, h, val_zero, nat.sub_zero, nat.mod_self]
{ rw [if_pos h, h, val_zero, nat.sub_zero, nat.mod_self] }
rw if_neg h
apply nat.mod_eq_of_lt
apply nat.sub_lt (fact.out (0 < n))
contrapose! h
rwa [nat.le_zero_iff, val_eq_zero] at h
intros
simp_rw [frequently_iff, omega_limit_def, mem_Inter, mem_closure_iff_nhds]
split
intros h _ hn _ hu
{ intros h _ hn _ hu, rcases h _ hu _ hn with ⟨_, _, _, _, ht, hx, hϕtx⟩, exact ⟨_, ht, _, hx, by rwa [mem_preimage, hϕtx]⟩, }
rcases h _ hu _ hn with ⟨_, _, _, _, ht, hx, hϕtx⟩
exact ⟨_, ht, _, hx, by rwa [mem_preimage, hϕtx]⟩
intros h _ hu _ hn
{ intros h _ hu _ hn, rcases h _ hn hu with ⟨_, ht, _, hx, hϕtx⟩, exact ⟨_, hϕtx, _, _, ht, hx, rfl⟩ }
rcases h _ hn hu with ⟨_, ht, _, hx, hϕtx⟩
exact ⟨_, hϕtx, _, _, ht, hx, rfl⟩
intros
{ rw add_comm at hn, exact hn.left_of_add hm }
rw add_comm at hn
exact hn.left_of_add hm
intros
{ rw adjoin_eq_bot_iff, exact set.singleton_subset_iff }
rw adjoin_eq_bot_iff
exact set.singleton_subset_iff
intros
ext
{ ext, rw [mem_to_subalgebra, iff_true_right algebra.mem_top], exact mem_top }
rw [mem_to_subalgebra, iff_true_right algebra.mem_top]
exact mem_top
intros
simp only [frobenius_def]
cases x with n x
dsimp only
suffices : ∀ p':ℕ, mk K p (n, x) ^ p' = mk K p (n, x ^ p')
{ apply this }
apply this
intro p
induction p with p ih
apply r.sound
case nat.zero { apply r.sound, rw [(frobenius _ _).iterate_map_one, pow_zero] }
rw [(frobenius _ _).iterate_map_one, pow_zero]
case nat.succ { rw [pow_succ, ih], symmetry, apply r.sound, simp only [pow_succ, (frobenius _ _).iterate_map_mul] }
rw [pow_succ, ih]
symmetry
apply r.sound
simp only [pow_succ, (frobenius _ _).iterate_map_mul]
intros
unfold angle
rw [real_inner_comm, mul_comm]
intros
refine ⟨λ h, _, norm_sub_eq_add_norm_of_angle_eq_pi⟩
rw ← inner_eq_neg_mul_norm_iff_angle_eq_pi hx hy
obtain ⟨hxy₁, hxy₂⟩ := ⟨norm_nonneg (x - y), add_nonneg (norm_nonneg x) (norm_nonneg y)⟩
rw [← sq_eq_sq hxy₁ hxy₂, norm_sub_pow_two_real] at h
calc inner x y = (∥x∥ ^ 2 + ∥y∥ ^ 2 - (∥x∥ + ∥y∥) ^ 2) / 2 : by linarith ... = -(∥x∥ * ∥y∥) : by ring
intros
change orthogonal_projection_fn s p = orthogonal_projection_fn s' p
congr
exact h
intros
rcases exists_circumcenter_eq_of_cospherical hd hc with ⟨r, hr⟩
rw [hr sx₁ hsx₁, hr sx₂ hsx₂]
intros
rw [←to_derivation_eq_coe]; exact left_invariant'' X g
rw [←to_derivation_eq_coe]
exact left_invariant'' X g
intros
simp only [range_comp e, e.image_eq_preimage, preimage_preimage] with mfld_simps
intros
assume x hx
rcases h x hx with ⟨u, u_open, xu, hu⟩
have := hu x ⟨hx, xu⟩
rwa hG.lift_prop_within_at_inter at this
exact is_open.mem_nhds u_open xu
intros
simp only [mfderiv_within, h, dif_neg, not_false_iff]
intros
refine ⟨λ h m hm, h.of_le hm, λ h, _⟩
cases n
exact times_cont_mdiff_within_at_top.2 (λ n, h n le_top)
{ exact times_cont_mdiff_within_at_top.2 (λ n, h n le_top) }
{ exact h n (le_refl _) }
exact h n (le_refl _)
intros
simp [left_coset, right_coset, (image_comp _ _ _).symm, function.comp, mul_assoc]
intros
simp only [h, subgroup.closure_le]
intros
rw [mul_inv_right h, mul_assoc, mul_comm _ (f y₂), ←mul_assoc, mul_inv_left h, mul_comm x₂, f.map_mul, f.map_mul]
intros
rw nilpotent_iff_lower_central_series at *
rcases hH with ⟨n, hn⟩
refine ⟨n + 1, lower_central_series_succ_eq_bot (le_trans ((map_eq_bot_iff _).mp _) hf1)⟩
exact eq_bot_iff.mpr (hn ▸ (lower_central_series.map f n))
intros
by_cases hx : x = 1
rw [←order_of_eq_one_iff, h] at hx
{ rw [←order_of_eq_one_iff, h] at hx, contradiction }
contradiction
rw [order_of_eq_zero_iff, is_of_fin_order_iff_pow_eq_one] at h
push_neg at h
induction n with n IH generalizing m
cases m
{ cases m, { simp }, { simpa [eq_comm] using h m.succ m.zero_lt_succ } }
{ simp }
simp
{ simpa [eq_comm] using h m.succ m.zero_lt_succ }
simpa [eq_comm] using h m.succ m.zero_lt_succ
cases m
{ cases m, { simpa using h n.succ n.zero_lt_succ }, { simp [pow_succ, IH] } }
{ simpa using h n.succ n.zero_lt_succ }
simpa using h n.succ n.zero_lt_succ
{ simp [pow_succ, IH] }
simp [pow_succ, IH]
intros
rw [nat.modeq_iff_dvd' σ.supportᶜ.card_le_univ, ←finset.card_compl, compl_compl]
refine (congr_arg _ σ.sum_cycle_type).mp (multiset.dvd_sum (λ k hk, _))
obtain ⟨m, -, hm⟩ := (nat.dvd_prime_pow hp.out).mp (order_of_dvd_of_pow_eq_one hσ)
obtain ⟨l, -, rfl⟩ := (nat.dvd_prime_pow hp.out).mp ((congr_arg _ hm).mp (dvd_of_mem_cycle_type hk))
exact dvd_pow_self _ (λ h, (one_lt_of_mem_cycle_type hk).ne $ by rw [h, pow_zero])
intros
rw mem_cycle_factors_finset_iff at h
intro x
by_cases hx : f x = x
{ exact or.inr hx }
exact or.inr hx
refine or.inl _
{ refine or.inl _, rw [mul_apply, ←h.right, apply_inv_self], rwa [←support_inv, apply_mem_support, support_inv, mem_support] }
rw [mul_apply, ←h.right, apply_inv_self]
rwa [←support_inv, apply_mem_support, support_inv, mem_support]
intros
suffices : σ.is_cycle → (σ ∈ l ↔ ∀ (a : α) (h4 : σ a ≠ a), σ a = l.prod a)
exact ⟨λ hσ, ⟨h1 σ hσ, (this (h1 σ hσ)).mp hσ⟩, λ hσ, (this hσ.1).mpr hσ.2⟩
{ exact ⟨λ hσ, ⟨h1 σ hσ, (this (h1 σ hσ)).mp hσ⟩, λ hσ, (this hσ.1).mpr hσ.2⟩ }
intro h3
classical
split
intros h a ha
{ intros h a ha, exact eq_on_support_mem_disjoint h h2 _ (mem_support.mpr ha) }
exact eq_on_support_mem_disjoint h h2 _ (mem_support.mpr ha)
intros h
{ intros h, have hσl : σ.support ⊆ l.prod.support, { intros x hx, rw mem_support at hx, rwa [mem_support, ←h _ hx] }, obtain ⟨a, ha, -⟩ := id h3, rw ←mem_support at ha, obtain ⟨τ, hτ, hτa⟩ := exists_mem_support_of_mem_support_prod (hσl ha), have hτl : ∀ (x ∈ τ.support), τ x = l.prod x := eq_on_support_mem_disjoint hτ h2, have key : ∀ (x ∈ σ.support ∩ τ.support), σ x = τ x, { intros x hx, rw [h x (mem_support.mp (mem_of_mem_inter_left hx)), hτl x (mem_of_mem_inter_right hx)] }, convert hτ, refine h3.eq_on_support_inter_nonempty_congr (h1 _ hτ) key _ ha, exact key a (mem_inter_of_mem ha hτa) }
have hσl : σ.support ⊆ l.prod.support
intros x hx
{ intros x hx, rw mem_support at hx, rwa [mem_support, ←h _ hx] }
rw mem_support at hx
rwa [mem_support, ←h _ hx]
obtain ⟨a, ha, -⟩ := id h3
rw ←mem_support at ha
obtain ⟨τ, hτ, hτa⟩ := exists_mem_support_of_mem_support_prod (hσl ha)
have hτl : ∀ (x ∈ τ.support), τ x = l.prod x := eq_on_support_mem_disjoint hτ h2
have key : ∀ (x ∈ σ.support ∩ τ.support), σ x = τ x
intros x hx
{ intros x hx, rw [h x (mem_support.mp (mem_of_mem_inter_left hx)), hτl x (mem_of_mem_inter_right hx)] }
rw [h x (mem_support.mp (mem_of_mem_inter_left hx)), hτl x (mem_of_mem_inter_right hx)]
convert hτ
refine h3.eq_on_support_inter_nonempty_congr (h1 _ hτ) key _ ha
exact key a (mem_inter_of_mem ha hτa)
intros
simp [equiv.perm.decompose_fin, equiv.perm_congr_def]
intros
simp only [swap_apply_def, mul_apply, f.injective.eq_iff] at *
by_cases h : f y = x
split; intro; simp only [*, if_true, eq_self_iff_true, not_true, ne.def] at *
split; intro
split
{ split; intro; simp only [*, if_true, eq_self_iff_true, not_true, ne.def] at * }
intro
simp only [*, if_true, eq_self_iff_true, not_true, ne.def] at *
intro
simp only [*, if_true, eq_self_iff_true, not_true, ne.def] at *
split_ifs at hy; cc
{ split_ifs at hy; cc }
split_ifs at hy
cc
cc
intros
simp [hxy]
intros
simp [right_hom]
intros
rw [general_commutator, general_commutator, monoid_hom.map_closure]
apply le_antisymm; apply closure_mono
apply le_antisymm
apply closure_mono
rintros _ ⟨x, ⟨p, hp, q, hq, rfl⟩, rfl⟩
{ rintros _ ⟨x, ⟨p, hp, q, hq, rfl⟩, rfl⟩, refine ⟨f p, mem_map.mpr ⟨p, hp, rfl⟩, f q, mem_map.mpr ⟨q, hq, rfl⟩, by simp *⟩, }
refine ⟨f p, mem_map.mpr ⟨p, hp, rfl⟩, f q, mem_map.mpr ⟨q, hq, rfl⟩, by simp *⟩
apply closure_mono
rintros x ⟨_, ⟨p, hp, rfl⟩, _, ⟨q, hq, rfl⟩, rfl⟩
{ rintros x ⟨_, ⟨p, hp, rfl⟩, _, ⟨q, hq, rfl⟩, rfl⟩, refine ⟨p * q * p⁻¹ * q⁻¹, ⟨p, hp, q, hq, rfl⟩, by simp *⟩, }
refine ⟨p * q * p⁻¹ * q⁻¹, ⟨p, hp, q, hq, rfl⟩, by simp *⟩
intros
split
introI h
{ introI h, exact ⟨is_simple_group.is_cyclic, is_simple_group.prime_card⟩ }
exact ⟨is_simple_group.is_cyclic, is_simple_group.prime_card⟩
rintro ⟨hc, hp⟩
{ rintro ⟨hc, hp⟩, haveI : fact (fintype.card α).prime := ⟨hp⟩, exact is_simple_group_of_prime_card rfl }
haveI : fact (fintype.card α).prime := ⟨hp⟩
exact is_simple_group_of_prime_card rfl
intros
cases P; cases Q; congr'
cases P; cases Q
cases P
cases Q
congr'
intros
{ rw [comp_line_map], simp }
rw [comp_line_map]
simp
intros
ext p
have hq1 := set.mem_of_mem_inter_left hn.some_mem
have hq2 := set.mem_of_mem_inter_right hn.some_mem
split
intro hp
{ intro hp, rw ←vsub_vadd p hn.some, refine vadd_mem_of_mem_direction _ hq2, rw ←hd, exact vsub_mem_direction hp hq1 }
rw ←vsub_vadd p hn.some
refine vadd_mem_of_mem_direction _ hq2
rw ←hd
exact vsub_mem_direction hp hq1
intro hp
{ intro hp, rw ←vsub_vadd p hn.some, refine vadd_mem_of_mem_direction _ hq1, rw hd, exact vsub_mem_direction hp hq2 }
rw ←vsub_vadd p hn.some
refine vadd_mem_of_mem_direction _ hq1
rw hd
exact vsub_mem_direction hp hq2
intros
simp [weighted_vsub_apply]
intros
rw [face_points', set.range_comp, finset.range_order_emb_of_fin]
intros
rw [slope, smul_eq_zero, inv_eq_zero, sub_eq_zero, vsub_eq_zero_iff_eq] at h
exact h.elim (λ h, h ▸ rfl) eq.symm
intros
rw [f.map_span, span_le, set.image_subset_iff]
exact iff.rfl
intros
ext
ext; simp
simp
intros
{ rcases x with ⟨bi, ⟨i, rfl⟩⟩, exact b.reindex_range_self i, }
rcases x with ⟨bi, ⟨i, rfl⟩⟩
exact b.reindex_range_self i
ext1
dsimp only [alg_hom.comp_apply, subtype.coe_mk, alg_hom.id_apply]
rw [of_complex_I, to_complex_ι, one_smul]
intros
split
rintro ⟨hli, hspan⟩
{ rintro ⟨hli, hspan⟩, set v' := basis.mk hli hspan with v'_eq, rw e.det_apply, convert linear_equiv.is_unit_det (linear_equiv.refl _ _) v' e using 2, ext i j, simp }
set v' := basis.mk hli hspan with v'_eq
rw e.det_apply
convert linear_equiv.is_unit_det (linear_equiv.refl _ _) v' e using 2
ext i j
simp
intro h
{ intro h, rw [basis.det_apply, basis.to_matrix_eq_to_matrix_constr] at h, set v' := basis.map e (linear_equiv.of_is_unit_det h) with v'_def, have : ⇑ v' = v, { ext i, rw [v'_def, basis.map_apply, linear_equiv.of_is_unit_det_apply, e.constr_basis] }, rw ← this, exact ⟨v'.linear_independent, v'.span_eq⟩ }
rw [basis.det_apply, basis.to_matrix_eq_to_matrix_constr] at h
set v' := basis.map e (linear_equiv.of_is_unit_det h) with v'_def
have : ⇑ v' = v
ext i
{ ext i, rw [v'_def, basis.map_apply, linear_equiv.of_is_unit_det_apply, e.constr_basis] }
rw [v'_def, basis.map_apply, linear_equiv.of_is_unit_det_apply, e.constr_basis]
rw ← this
exact ⟨v'.linear_independent, v'.span_eq⟩
intros
have h := lift_dim_range_le (f.comp (submodule.subtype p))
rwa [linear_map.range_comp, range_subtype] at h
intros
rw ker_eq_bot'
intros m hm
simp_rw [linear_map.ext_iff, dual.eval_apply, zero_apply] at hm
exact (basis.forall_coord_eq_zero_iff _).mp (λ i, hm (b.coord i))
intros
rcases (submodule.ne_bot_iff _).1 h with ⟨w, ⟨H, ne0⟩⟩
refine or.resolve_right (smul_eq_zero.1 _) ne0
simp [← aeval_apply_of_has_eigenvector ⟨H, ne0⟩, minpoly.aeval K f]
intros
obtain ⟨k, h_k_le, hk⟩ : ∃ k, k ≤ finrank K V ∧ linear_map.ker (f ^ k) = linear_map.ker (f ^ k.succ) := exists_ker_pow_eq_ker_pow_succ f
calc (f ^ m).ker = (f ^ (k + (m - k))).ker : by rw nat.add_sub_of_le (h_k_le.trans hm) ... = (f ^ k).ker : by rw ker_pow_constant hk _ ... = (f ^ (k + (finrank K V - k))).ker : ker_pow_constant hk (finrank K V - k) ... = (f ^ finrank K V).ker : by rw nat.add_sub_of_le h_k_le
intros
simp only [set_like.le_def, mem_infi, mem_ker, mem_bot, lapply_apply]
exact assume a h, finsupp.ext h
intros
rw finsupp.total_apply; refl
rw finsupp.total_apply
refl
intros
rw [linear_independent.repr, linear_equiv.ker]
intros
ext
{ ext, simp only [basis.to_matrix_apply, basis.reindex_repr, matrix.reindex_alg_equiv_apply, matrix.reindex_apply, matrix.minor_apply, function.comp_app, e.apply_symm_apply] }
simp only [basis.to_matrix_apply, basis.reindex_repr, matrix.reindex_alg_equiv_apply, matrix.reindex_apply, matrix.minor_apply, function.comp_app, e.apply_symm_apply]
intros
ext m
rw [coeff_sub, coeff_C, mat_poly_equiv_coeff_apply, ring_hom.map_matrix_apply, matrix.map_apply, alg_hom.coe_to_ring_hom, dmatrix.sub_apply, coeff_X_pow]
by_cases hij : i = j
rw [hij, charmatrix_apply_eq, alg_hom.map_sub, expand_C, expand_X, coeff_sub, coeff_X_pow, coeff_C]
{ rw [hij, charmatrix_apply_eq, alg_hom.map_sub, expand_C, expand_X, coeff_sub, coeff_X_pow, coeff_C], split_ifs with mp m0; simp only [matrix.one_apply_eq, dmatrix.zero_apply] }
split_ifs with mp m0; simp only [matrix.one_apply_eq, dmatrix.zero_apply]
split_ifs with mp m0
simp only [matrix.one_apply_eq, dmatrix.zero_apply]
simp only [matrix.one_apply_eq, dmatrix.zero_apply]
simp only [matrix.one_apply_eq, dmatrix.zero_apply]
simp only [matrix.one_apply_eq, dmatrix.zero_apply]
rw [charmatrix_apply_ne _ _ _ hij, alg_hom.map_neg, expand_C, coeff_neg, coeff_C]
{ rw [charmatrix_apply_ne _ _ _ hij, alg_hom.map_neg, expand_C, coeff_neg, coeff_C], split_ifs with m0 mp; simp only [hij, zero_sub, dmatrix.zero_apply, sub_zero, neg_zero, matrix.one_apply_ne, ne.def, not_false_iff] }
split_ifs with m0 mp; simp only [hij, zero_sub, dmatrix.zero_apply, sub_zero, neg_zero, matrix.one_apply_ne, ne.def, not_false_iff]
split_ifs with m0 mp
simp only [hij, zero_sub, dmatrix.zero_apply, sub_zero, neg_zero, matrix.one_apply_ne, ne.def, not_false_iff]
simp only [hij, zero_sub, dmatrix.zero_apply, sub_zero, neg_zero, matrix.one_apply_ne, ne.def, not_false_iff]
simp only [hij, zero_sub, dmatrix.zero_apply, sub_zero, neg_zero, matrix.one_apply_ne, ne.def, not_false_iff]
simp only [hij, zero_sub, dmatrix.zero_apply, sub_zero, neg_zero, matrix.one_apply_ne, ne.def, not_false_iff]
intros
rw [←matrix.mul_one (σ.to_pequiv.to_matrix : matrix n n R), pequiv.to_pequiv_mul_matrix, det_permute, det_one, mul_one]
intros
ext v j; simp [mul_vec_diagonal]
ext v j
simp [mul_vec_diagonal]
intros
by_cases h : is_unit A.det
{ rw [nonsing_inv_nonsing_inv _ h] }
rw [nonsing_inv_nonsing_inv _ h]
{ simp [nonsing_inv_apply_not_is_unit _ h] }
simp [nonsing_inv_apply_not_is_unit _ h]
intros
{ ext, simp }
ext
simp
intros
simp only [left_mul_matrix_apply, linear_map.to_matrix_apply, mul_comm, basis.smul_apply, basis.smul_repr, finsupp.smul_apply, algebra.lmul_apply, id.smul_eq_mul, linear_equiv.map_smul, mul_smul_comm]
intros
refine linear_map.ext _
refine λ z, (pi_tensor_product.induction_on' z _ (λ x y hx hy, by rw [φ₁.map_add, φ₂.map_add, hx, hy]))
intros r f
{ intros r f, rw [tprod_coeff_eq_smul_tprod, φ₁.map_smul, φ₂.map_smul], apply _root_.congr_arg, exact multilinear_map.congr_fun H f }
rw [tprod_coeff_eq_smul_tprod, φ₁.map_smul, φ₂.map_smul]
apply _root_.congr_arg
exact multilinear_map.congr_fun H f
intros
rw [← map_coprod_prod, coprod_inl_inr, map_id]
intros
induction n with n ih
simp only [tailings_zero]
{ simp only [tailings_zero], apply tailing_disjoint_tunnel_succ, }
apply tailing_disjoint_tunnel_succ
simp only [tailings_succ]
{ simp only [tailings_succ], refine disjoint.disjoint_sup_left_of_disjoint_sup_right _ _, apply tailing_disjoint_tunnel_succ, apply disjoint.mono_right _ ih, apply tailing_sup_tunnel_succ_le_tunnel, }
refine disjoint.disjoint_sup_left_of_disjoint_sup_right _ _
apply tailing_disjoint_tunnel_succ
apply disjoint.mono_right _ ih
apply tailing_sup_tunnel_succ_le_tunnel
intros
simp [polar]
intros
simp [discr, mul_left_comm, mul_comm]
intros
ext i j
refine fin.cases (by simp) (λ i, _) i
refine fin.cases (by simp) (λ j, _) j
simp [pow_succ]
intros
simp only [and.left_comm, and.comm]
intros
simp only [or_imp_distrib, forall_and_distrib, forall_eq]
intros
funext c
simp only [update]
by_cases h₁ : c = b; by_cases h₂ : c = a; try {simp [h₁, h₂]}
by_cases h₁ : c = b; by_cases h₂ : c = a
by_cases h₁ : c = b
by_cases h₂ : c = a
try {simp [h₁, h₂]}
cases h (h₂.symm.trans h₁)
try {simp [h₁, h₂]}
by_cases h₂ : c = a
try {simp [h₁, h₂]}
try {simp [h₁, h₂]}
simp [h₁, h₂]
intros
classical; exact (function.update_injective (λ i, classical.choice (inst i)) i').nontrivial
classical
exact (function.update_injective (λ i, classical.choice (inst i)) i').nontrivial
intros
haveI : encodable s := hs.to_encodable
simp only [supr_subtype']
exact ae_measurable_supr (λ i, hf i)
intros
rw [real_smul_def, ← smul_pos_part, dif_neg (not_le.2 hr), neg_neg_part]
{ rw [real_smul_def, ← smul_pos_part, dif_neg (not_le.2 hr), neg_neg_part] }
intros
refine (eq_singular_part 0 0 vector_measure.mutually_singular.zero_left _).symm
rw [zero_add, with_densityᵥ_zero]
intros
rw [← comp_mk g hg f f.ae_measurable, mk_coe_fn]
intros
have h_ss : {a : α | ¬∀ (i : ι), ae_seq hf p i a = f i a} ⊆ (ae_seq_set hf p)ᶜ
from λ x, mt (λ hx i, (ae_seq_eq_fun_of_mem_ae_seq_set hf hx i))
exact measure_mono_null h_ss (measure_compl_ae_seq_set_eq_zero hf hp)
intros
ext1
ext1
refine (condexp_ind_ae_eq_condexp_ind_smul hm measurable_set.empty (by simp) x).trans _
rw condexp_ind_smul_empty
refine (Lp.coe_fn_zero G 2 μ).trans _
refine eventually_eq.trans _ (Lp.coe_fn_zero G 1 μ).symm
refl
intros
refine order_iso.limsup_apply g _ _ _ _
is_bounded_default
all_goals { is_bounded_default, }
is_bounded_default
is_bounded_default
is_bounded_default
intros
{ simp [Lp.norm_def, snorm, snorm'] }
simp [Lp.norm_def, snorm, snorm']
intros
by_cases hμ0 : μ = 0
rw [hμ0, snorm_ess_sup_measure_zero, ennreal.coe_nonneg]
{ rw [hμ0, snorm_ess_sup_measure_zero, ennreal.coe_nonneg], exact zero_le', }
exact zero_le'
exact (snorm_ess_sup_indicator_le s (λ x, c)).trans (snorm_ess_sup_const c hμ0).le
{ exact (snorm_ess_sup_indicator_le s (λ x, c)).trans (snorm_ess_sup_const c hμ0).le, }
intros
simp [snorm_ess_sup]
intros
rw [snorm', ennreal.rpow_eq_zero_iff] at h
cases h
rw lintegral_eq_zero_iff' (hf.ennnorm.pow_const q) at h
{ rw lintegral_eq_zero_iff' (hf.ennnorm.pow_const q) at h, refine h.left.mono (λ x hx, _), rw [pi.zero_apply, ennreal.rpow_eq_zero_iff] at hx, cases hx, { cases hx with hx _, rwa [←ennreal.coe_zero, ennreal.coe_eq_coe, nnnorm_eq_zero] at hx, }, { exact absurd hx.left ennreal.coe_ne_top, }, }
refine h.left.mono (λ x hx, _)
rw [pi.zero_apply, ennreal.rpow_eq_zero_iff] at hx
cases hx
cases hx with hx _
{ cases hx with hx _, rwa [←ennreal.coe_zero, ennreal.coe_eq_coe, nnnorm_eq_zero] at hx, }
rwa [←ennreal.coe_zero, ennreal.coe_eq_coe, nnnorm_eq_zero] at hx
{ exact absurd hx.left ennreal.coe_ne_top, }
exact absurd hx.left ennreal.coe_ne_top
exfalso
{ exfalso, rw [one_div, inv_lt_zero] at h, exact hq0.not_lt h.right }
rw [one_div, inv_lt_zero] at h
exact hq0.not_lt h.right
intros
simpa [snorm_one_eq_lintegral_nnnorm] using tendsto_approx_on_Lp_snorm hf h₀ one_ne_top hμ (by simpa [snorm_one_eq_lintegral_nnnorm] using hi)
intros
simp_rw [integral_eq_lintegral_of_nonneg_ae hf hfi.1, ennreal.to_real_eq_zero_iff, lintegral_eq_zero_iff' (ennreal.measurable_of_real.comp_ae_measurable hfi.1), ← ennreal.not_lt_top, ← has_finite_integral_iff_of_real hf, hfi.2, not_true, or_false, ← hf.le_iff_eq, filter.eventually_eq, filter.eventually_le, (∘), pi.zero_apply, ennreal.of_real_eq_zero]
intros
{ ext1 x, simp_rw weighted_smul_apply, congr' 2, }
ext1 x
simp_rw weighted_smul_apply
congr' 2
intros
rw [tendsto_zero_iff_norm_tendsto_zero]
simp_rw [← coe_nnnorm, ← nnreal.coe_zero, nnreal.tendsto_coe, ← ennreal.tendsto_coe, ennreal.coe_zero]
exact tendsto_of_tendsto_of_tendsto_of_le_of_le tendsto_const_nhds (tendsto_set_lintegral_zero (ne_of_lt hf) hs) (λ i, zero_le _) (λ i, ennnorm_integral_le_lintegral_ennnorm _)
intros
simpa only [zero_sub] using integral_comp_sub_left f 0
intros
have : ∫⁻ a, f a ∂μ = ∫⁻ a, hf.mk f a ∂μ := lintegral_congr_ae hf.ae_eq_mk
rw [this, lintegral_eq_zero_iff hf.measurable_mk]
exact ⟨λ H, hf.ae_eq_mk.trans H, λ H, hf.ae_eq_mk.symm.trans H⟩
intros
{ rw [add_eq_map₂], exact hf.map₂ hg (zero_add 0) }
rw [add_eq_map₂]
exact hf.map₂ hg (zero_add 0)
intros
rw set_to_fun_eq hT
simp only [integrable.to_L1_zero, continuous_linear_map.map_zero]
{ simp only [integrable.to_L1_zero, continuous_linear_map.map_zero], }
{ exact integrable_zero _ _ _, }
exact integrable_zero _ _ _
intros
rw bUnion_eq_Union
haveI := hs.to_encodable
exact measurable_set.Union (by simpa using h)
intros
rcases induced_outer_measure_exists_set _ _ μ.inner_content_mono hA (ennreal.coe_ne_zero.2 hε) with ⟨U, hU, h2U, h3U⟩
exact ⟨⟨U, hU⟩, h2U, h3U⟩
swap
exact μ.inner_content_Union_nat
intros
simp only [prehaar, compacts.bot_val, index_empty, nat.cast_zero, zero_div]
{ simp only [prehaar, compacts.bot_val, index_empty, nat.cast_zero, zero_div] }
intros
simp [← measure_congr Iio_ae_eq_Iic]
intros
intros t ht
suffices : μ (⋃ i, t ∩ s i) ≤ ∑' i, μ (t ∩ s i)
simpa [ht, inter_Union]
simpa [ht, inter_Union]
apply measure_Union_le
intros
by_cases a ∈ s; simp [mem_ae_iff, dirac_apply', hs.compl, indicator_apply, *]
by_cases a ∈ s
simp [mem_ae_iff, dirac_apply', hs.compl, indicator_apply, *]
simp [mem_ae_iff, dirac_apply', hs.compl, indicator_apply, *]
intros
rw [← finset.sum_attach, finset.attach_eq_univ, ← tsum_fintype]
exact measure_bUnion_le s.countable_to_set f
intros
rcases eq_or_ne x 0 with rfl|h0
{ rw zero_smul, exact outer_regular.zero }
rw zero_smul
exact outer_regular.zero
refine ⟨λ A hA r hr, _⟩
{ refine ⟨λ A hA r hr, _⟩, rw [smul_apply, A.measure_eq_infi_is_open] at hr, simpa only [ennreal.mul_infi_of_ne h0 hx, gt_iff_lt, infi_lt_iff, exists_prop] using hr }
rw [smul_apply, A.measure_eq_infi_is_open] at hr
simpa only [ennreal.mul_infi_of_ne h0 hx, gt_iff_lt, infi_lt_iff, exists_prop] using hr
intros
rw [ennreal_to_measure, of_measurable_apply _ hs]
intros
have ha : 0 < a := lt_of_le_of_lt (absolute_value.nonneg _ _) hxy
by_cases hxy' : x = y
{ rwa hxy' }
rwa hxy'
by_cases hyz' : y = z
{ rwa ← hyz' }
rwa ← hyz'
by_cases hxz' : x = z
{ rwa [hxz', sub_self, absolute_value.map_zero] }
rwa [hxz', sub_self, absolute_value.map_zero]
rw [← ne.def, ← sub_ne_zero] at hxy' hyz' hxz'
refine lt_of_le_of_lt _ (max_lt hxy hyz)
rw [card_pow_degree_nonzero _ hxz', card_pow_degree_nonzero _ hxy', card_pow_degree_nonzero _ hyz']
have : (1 : ℤ) ≤ fintype.card Fq
exact_mod_cast (@fintype.one_lt_card Fq _ _).le
{ exact_mod_cast (@fintype.one_lt_card Fq _ _).le }
simp only [int.cast_pow, int.cast_coe_nat, le_max_iff]
refine or.imp (pow_le_pow this) (pow_le_pow this) _
rw [nat_degree_le_iff_degree_le, nat_degree_le_iff_degree_le, ← le_max_iff, ← degree_eq_nat_degree hxy', ← degree_eq_nat_degree hyz']
convert degree_add_le (x - y) (y - z) using 2
exact (sub_add_sub_cancel _ _ _).symm
intros
rw [mem_divisors, nat.dvd_prime_pow pp, and_iff_left (ne_of_gt (pow_pos pp.pos k))]
intros
simp [l_series_summable, summable_zero]
intros
dsimp [ω, ωb]
ext
ext; simp; ring
ext; simp
simp
ring
simp
intros
simp [padic_norm]
intros
simp [ext]
intros
rcases nonneg_cases ha with ⟨x, y, rfl|rfl|rfl⟩
rcases nonneg_cases ha with ⟨x, y, rfl|rfl|rfl⟩; rcases nonneg_cases hb with ⟨z, w, rfl|rfl|rfl⟩; dsimp [add, nonneg] at ha hb ⊢
rcases nonneg_cases ha with ⟨x, y, rfl|rfl|rfl⟩; rcases nonneg_cases hb with ⟨z, w, rfl|rfl|rfl⟩
rcases nonneg_cases hb with ⟨z, w, rfl|rfl|rfl⟩
dsimp [add, nonneg] at ha hb ⊢
{ trivial }
trivial
dsimp [add, nonneg] at ha hb ⊢
refine nonnegg_cases_right (λi h, sq_le_of_le _ _ (nonnegg_pos_neg.1 hb))
{ refine nonnegg_cases_right (λi h, sq_le_of_le _ _ (nonnegg_pos_neg.1 hb)), { exact int.coe_nat_le.1 (le_of_neg_le_neg (@int.le.intro _ _ y (by simp [add_comm, *]))) }, { apply nat.le_add_left } }
exact int.coe_nat_le.1 (le_of_neg_le_neg (@int.le.intro _ _ y (by simp [add_comm, *])))
{ exact int.coe_nat_le.1 (le_of_neg_le_neg (@int.le.intro _ _ y (by simp [add_comm, *]))) }
{ apply nat.le_add_left }
apply nat.le_add_left
dsimp [add, nonneg] at ha hb ⊢
refine nonnegg_cases_left (λi h, sq_le_of_le _ _ (nonnegg_neg_pos.1 hb))
{ refine nonnegg_cases_left (λi h, sq_le_of_le _ _ (nonnegg_neg_pos.1 hb)), { exact int.coe_nat_le.1 (le_of_neg_le_neg (@int.le.intro _ _ x (by simp [add_comm, *]))) }, { apply nat.le_add_left } }
exact int.coe_nat_le.1 (le_of_neg_le_neg (@int.le.intro _ _ x (by simp [add_comm, *])))
{ exact int.coe_nat_le.1 (le_of_neg_le_neg (@int.le.intro _ _ x (by simp [add_comm, *]))) }
{ apply nat.le_add_left }
apply nat.le_add_left
rcases nonneg_cases hb with ⟨z, w, rfl|rfl|rfl⟩
dsimp [add, nonneg] at ha hb ⊢
refine nonnegg_cases_right (λi h, sq_le_of_le _ _ (nonnegg_pos_neg.1 ha))
{ refine nonnegg_cases_right (λi h, sq_le_of_le _ _ (nonnegg_pos_neg.1 ha)), { exact int.coe_nat_le.1 (le_of_neg_le_neg (@int.le.intro _ _ w (by simp *))) }, { apply nat.le_add_right } }
exact int.coe_nat_le.1 (le_of_neg_le_neg (@int.le.intro _ _ w (by simp *)))
{ exact int.coe_nat_le.1 (le_of_neg_le_neg (@int.le.intro _ _ w (by simp *))) }
{ apply nat.le_add_right }
apply nat.le_add_right
dsimp [add, nonneg] at ha hb ⊢
simpa [add_comm] using nonnegg_pos_neg.2 (sq_le_add (nonnegg_pos_neg.1 ha) (nonnegg_pos_neg.1 hb))
{ simpa [add_comm] using nonnegg_pos_neg.2 (sq_le_add (nonnegg_pos_neg.1 ha) (nonnegg_pos_neg.1 hb)) }
dsimp [add, nonneg] at ha hb ⊢
{ exact nonneg_add_lem ha hb }
exact nonneg_add_lem ha hb
rcases nonneg_cases hb with ⟨z, w, rfl|rfl|rfl⟩
dsimp [add, nonneg] at ha hb ⊢
refine nonnegg_cases_left (λi h, sq_le_of_le _ _ (nonnegg_neg_pos.1 ha))
{ refine nonnegg_cases_left (λi h, sq_le_of_le _ _ (nonnegg_neg_pos.1 ha)), { exact int.coe_nat_le.1 (le_of_neg_le_neg (int.le.intro h)) }, { apply nat.le_add_right } }
{ exact int.coe_nat_le.1 (le_of_neg_le_neg (int.le.intro h)) }
exact int.coe_nat_le.1 (le_of_neg_le_neg (int.le.intro h))
{ apply nat.le_add_right }
apply nat.le_add_right
dsimp [add, nonneg] at ha hb ⊢
rw [add_comm, add_comm ↑y]
{ rw [add_comm, add_comm ↑y], exact nonneg_add_lem hb ha }
exact nonneg_add_lem hb ha
dsimp [add, nonneg] at ha hb ⊢
simpa [add_comm] using nonnegg_neg_pos.2 (sq_le_add (nonnegg_neg_pos.1 ha) (nonnegg_neg_pos.1 hb))
{ simpa [add_comm] using nonnegg_neg_pos.2 (sq_le_add (nonnegg_neg_pos.1 ha) (nonnegg_neg_pos.1 hb)) }
intros
rw [sup_comm, sup_inf_sdiff]
intros
rw [←le_bot_iff, sdiff_le_iff, sup_bot_eq]
intros
rw [← sdiff_eq, sup_inf_sdiff _ _]
intros
simp only [Ici_inter_Iic.symm, subset_inter_iff, bdd_below_iff_subset_Ici, bdd_above_iff_subset_Iic, exists_and_distrib_left, exists_and_distrib_right]
intros
simp_rw [←set_like.mem_coe, ←set.singleton_subset_iff, ←l.le_iff_subset]
{ simp_rw [←set_like.mem_coe, ←set.singleton_subset_iff, ←l.le_iff_subset], exact ⟨λ h S, h.trans, λ h, h _ le_rfl⟩ }
exact ⟨λ h S, h.trans, λ h, h _ le_rfl⟩
intros
rw [supr, bool.range_eq, Sup_pair, sup_comm]
intros
simp only [supr, hf.range_comp]
intros
{ rw ← Sup_image', exact is_lub_cSup (Hne.image _) H }
rw ← Sup_image'
exact is_lub_cSup (Hne.image _) H
intros
rw [sup'_eq_cSup_image s H, set.image_id]
intros
rw [← map_coe_Iio_at_bot a, tendsto_map'_iff]
intros
erw [h.filter_basis.mem_filter_iff]
simp only [mem_filter_basis_iff h, exists_prop]
split
rintros ⟨_, ⟨i, pi, rfl⟩, h⟩
{ rintros ⟨_, ⟨i, pi, rfl⟩, h⟩, tauto }
tauto
{ tauto }
tauto
intros
simp
intros
simp only [tendsto, le_inf_iff, iff_self]
intros
simp [filter.coprod]
intros
rcases em (∃ y ∈ s, ∃ x, f y < x) with ⟨y, hys, x, hx⟩|not_all_top
have : finite {y | ¬x ≤ f y} := (filter.eventually_cofinite.mp (tendsto_at_top.1 hf x))
{ have : finite {y | ¬x ≤ f y} := (filter.eventually_cofinite.mp (tendsto_at_top.1 hf x)), simp only [not_le] at this, obtain ⟨a₀, ⟨ha₀ : f a₀ < x, ha₀s⟩, others_bigger⟩ := exists_min_image _ f (this.inter_of_left s) ⟨y, hx, hys⟩, refine ⟨a₀, ha₀s, λ a has, (lt_or_le (f a) x).elim _ (le_trans ha₀.le)⟩, exact λ h, others_bigger a ⟨h, has⟩ }
simp only [not_le] at this
obtain ⟨a₀, ⟨ha₀ : f a₀ < x, ha₀s⟩, others_bigger⟩ := exists_min_image _ f (this.inter_of_left s) ⟨y, hx, hys⟩
refine ⟨a₀, ha₀s, λ a has, (lt_or_le (f a) x).elim _ (le_trans ha₀.le)⟩
exact λ h, others_bigger a ⟨h, has⟩
push_neg at not_all_top
{ push_neg at not_all_top, obtain ⟨a₀, ha₀s⟩ := hs, exact ⟨a₀, ha₀s, λ a ha, not_all_top a ha (f a₀)⟩ }
obtain ⟨a₀, ha₀s⟩ := hs
exact ⟨a₀, ha₀s, λ a ha, not_all_top a ha (f a₀)⟩
intros
{ ext ⟨f⟩ ⟨g⟩, exact coe_lt }
ext ⟨f⟩ ⟨g⟩
exact coe_lt
intros
{ rw ← tendsto_iff_ptendsto, simp [principal_univ] }
rw ← tendsto_iff_ptendsto
simp [principal_univ]
intros
obtain ⟨a, ha⟩ : ∃ a : P, ∀ I : ideal P, a ∈ I := ideal_Inter_nonempty.exists_all_mem
exact ⟨a, by simp [ha]⟩
intros
rw [sup_assoc, sup_idem]
intros
simp [is_cobounded, eq_univ_iff_forall, exists_true_iff_nonempty] {contextual := tt}
intros
ext n
induction n with n ih
{ refl }
refl
rw [partial_sups_succ, ih, sup_eq_right.2 (hf (nat.le_succ _))]
{ rw [partial_sups_succ, ih, sup_eq_right.2 (hf (nat.le_succ _))] }
intros
rw [symm_diff_comm, symm_diff_top]
intros
obtain ⟨a, b, h⟩ := h
use [-a, b]
rwa neg_mul_neg
intros
rw irreducible_iff_uniformizer at ha hb
rw [←span_singleton_eq_span_singleton, ←ha, hb]
intros
suffices : of R M '' (⋃ f ∈ S, (f.support : set M)) = ⋃ f ∈ S, (of R M '' (f.support : set M))
rw this
{ rw this, exact support_gen_of_gen hS }
exact support_gen_of_gen hS
simp only [set.image_Union]
intros
rw [coe_one_eq_coe_submodule_top, coe_submodule_top]
intros
{ ext, simp }
ext
simp
intros
simp only [←ideal_prod_equiv_symm_apply, ideal_prod_equiv.symm.injective.eq_iff, prod.mk.inj_iff]
intros
split_ifs with h h
{ simp [h, card_univ] }
simp [h, card_univ]
{ exact sum_hom_units_eq_zero f h }
exact sum_hom_units_eq_zero f h
intros
use λ hI, ⟨{J : ideal R | I ≤ J ∧ J.is_maximal}, ⟨λ _ hJ, or.inl hJ.right, hI.symm⟩⟩
rintros ⟨M, hM, hInf⟩
refine le_antisymm (λ x hx, _) le_jacobson
rw [hInf, mem_Inf]
intros I hI
cases hM I hI with is_max is_top
exact (mem_Inf.1 hx) ⟨le_Inf_iff.1 (le_of_eq hInf) I hI, is_max⟩
{ exact (mem_Inf.1 hx) ⟨le_Inf_iff.1 (le_of_eq hInf) I hI, is_max⟩ }
{ exact is_top.symm ▸ submodule.mem_top }
exact is_top.symm ▸ submodule.mem_top
intros
rw [localization.mk_eq_mk', is_fraction_ring.mk'_eq_div]
intros
simp only [inv_fun, alg_hom.map_sum, std_basis_matrix, apply_ite ⇑(algebra_map R A), mul_boole, to_fun_alg_hom_apply, ring_hom.map_zero, ring_hom.map_one]
convert finset.sum_product
apply matrix_eq_sum_std_basis
intros
rw [multiplicity_le_multiplicity_iff] at hle
rw [← nonpos_iff_eq_zero, ← not_lt, enat.pos_iff_one_le, ← nat.cast_one, ← pow_dvd_iff_le_multiplicity]
assume h
have := nat.dvd_gcd h (hle _ h)
rw [coprime.gcd_eq_one hab, nat.dvd_one, pow_one] at this
exact hp this
intros
rw [←normalize_content, normalize_eq_one, is_primitive]
simp_rw [←dvd_content_iff_C_dvd]
exact ⟨λ h, h p.content (dvd_refl p.content), λ h r hdvd, is_unit_of_dvd_unit hdvd h⟩
intros
apply map_injective (int.cast_ring_hom ℂ) int.cast_injective
rw [h, (int_cyclotomic_spec n).1]
intros
rw_mod_cast [pochhammer_nat_eq_asc_factorial, nat.factorial_mul_asc_factorial]
intros
rw support_esymm''
congr
funext
exact finsupp.support_single_ne_zero one_ne_zero
intros
simp_rw [minpoly_gen, alg_hom.map_sub, alg_hom.map_sum, alg_hom.map_mul, alg_hom.map_pow, aeval_C, ← algebra.smul_def, aeval_X]
refine sub_eq_zero.mpr ((pb.basis.total_repr (pb.gen ^ pb.dim)).symm.trans _)
rw [finsupp.total_apply, finsupp.sum_fintype]
rw [finsupp.total_apply, finsupp.sum_fintype]; simp only [pb.coe_basis, zero_smul, eq_self_iff_true, implies_true_iff]
simp only [pb.coe_basis, zero_smul, eq_self_iff_true, implies_true_iff]
simp only [pb.coe_basis, zero_smul, eq_self_iff_true, implies_true_iff]
intros
ext
{ ext, simp [coeff_coe, power_series.coeff_monomial, polynomial.coeff_monomial, eq_comm] }
simp [coeff_coe, power_series.coeff_monomial, polynomial.coeff_monomial, eq_comm]
intros
rcases mul_eq_mul_prime_prod (λ _ _, hp) (show x * y = a * (range n).prod (λ _, p), by simpa) with ⟨t, u, b, c, htus, htu, rfl, rfl, rfl⟩
exact ⟨t.card, u.card, b, c, by rw [← card_disjoint_union htu, htus, card_range], by simp⟩
intros
induction n with n ih
{ simp, }
simp
{ simp [pow_succ, ih], }
simp [pow_succ, ih]
intros
rw [trace_eq_zero_of_not_exists_basis, linear_map.zero_apply]
contrapose! hx
obtain ⟨s, ⟨b⟩⟩ := hx
refine is_integral_of_mem_of_fg (K⟮x⟯).to_subalgebra _ x _
exact (submodule.fg_iff_finite_dimensional _).mpr (finite_dimensional.of_finset_basis b)
{ exact (submodule.fg_iff_finite_dimensional _).mpr (finite_dimensional.of_finset_basis b) }
{ exact subset_adjoin K _ (set.mem_singleton x) }
exact subset_adjoin K _ (set.mem_singleton x)
intros
dunfold has_mem.mem
dunfold factor_set_mem
split_ifs
refl
intros
rw ← padic_int.to_zmod_pow_eq_iff_ext
intro n
rw [← ring_hom.comp_assoc, to_padic_int, padic_int.lift_spec]
simp only [from_padic_int, to_zmod_pow, ring_hom.comp_id]
rw [ring_hom.comp_assoc, truncate_comp_lift, ← ring_hom.comp_assoc]
simp only [ring_equiv.symm_to_ring_hom_comp_to_ring_hom, ring_hom.id_comp]
intros
rw [frobenius_fun, coeff_mk]
intros
{ rw [←pos_iff_ne_zero, lt_succ], apply zero_le }
rw [←pos_iff_ne_zero, lt_succ]
apply zero_le
intros
rw [← succ_zero, succ_le]
intros
rw [aleph, ordinal.add_succ, aleph'_succ]; refl
rw [aleph, ordinal.add_succ, aleph'_succ]
refl
intros
rw [←ord_lt_ord, h]
{ rw [←ord_lt_ord, h], refine lt_of_le_of_lt (ord_card_le _) (typein_lt_type r x) }
refine lt_of_le_of_lt (ord_card_le _) (typein_lt_type r x)
intros
split
split; intro h
intro h
by_cases h' : b = 0
{ by_cases h' : b = 0, { rw [h', add_zero] at h, right, exact ⟨h', h⟩ }, left, rw [←add_sub_cancel a b], apply sub_is_limit h, suffices : a + 0 < a + b, simpa only [add_zero], rwa [add_lt_add_iff_left, ordinal.pos_iff_ne_zero] }
{ rw [h', add_zero] at h, right, exact ⟨h', h⟩ }
rw [h', add_zero] at h
right
exact ⟨h', h⟩
left
rw [←add_sub_cancel a b]
apply sub_is_limit h
suffices : a + 0 < a + b
simpa only [add_zero]
rwa [add_lt_add_iff_left, ordinal.pos_iff_ne_zero]
intro h
rcases h with h|⟨rfl, h⟩
exact add_is_limit a h
simpa only [add_zero]
intros
cases o; cases n; refl
cases o; cases n
cases o
cases n
refl
refl
cases n
refl
refl
intros
{ cases x, cases y, refl, }
cases x
cases y
refl
intros
cases n; refl
cases n
refl
refl
intros
apply mul_le_mul_of_nonneg_right; assumption
apply mul_le_mul_of_nonneg_right
assumption
assumption
intros
rwa zero_add
intros
simp [h₂.symm, h₃.symm, h₁.symm, horner, pow_add, mul_add, mul_comm, mul_left_comm]
simp [h₂.symm, h₃.symm, h₁.symm, horner, pow_add, mul_add, mul_comm, mul_left_comm]; cc
cc
intros
cc
intros
cc
intros
simpa only [zero_add] using dist_le_tsum_of_dist_le_of_tendsto d hf hd ha 0
intros
{ simp only [sub_eq_add_neg], exact hf.add hg.neg }
simp only [sub_eq_add_neg]
exact hf.add hg.neg
intros
ext
ext; simp [← continuous_linear_map.map_smul_of_tower]
simp [← continuous_linear_map.map_smul_of_tower]
intros
rw [supr, map_Sup_of_continuous_at_of_monotone' Cf Mf (range_nonempty g), ← range_comp, supr]
intros
simpa only [inv_inv] using @tendsto_inv_nhds_within_Ioi _ _ _ _ (a⁻¹)
intros
by_cases p; simp *
by_cases p
simp *
simp *
intros
convert nhds_basis_opens a
ext s
split
rintros ⟨s_in, s_op⟩
{ rintros ⟨s_in, s_op⟩, exact ⟨mem_of_mem_nhds s_in, s_op⟩ }
exact ⟨mem_of_mem_nhds s_in, s_op⟩
rintros ⟨a_in, s_op⟩
{ rintros ⟨a_in, s_op⟩, exact ⟨is_open.mem_nhds s_op a_in, s_op⟩ }
exact ⟨is_open.mem_nhds s_op a_in, s_op⟩
intros
obtain ⟨U, V, hU, hV, Ux, Vy, f, disj⟩ := totally_separated_space.is_totally_separated_univ α x (set.mem_univ x) y (set.mem_univ y) hxy
have clopen_U := is_clopen_inter_of_disjoint_cover_clopen (is_clopen_univ) f hU hV disj
rw set.univ_inter _ at clopen_U
rw [←set.subset_compl_iff_disjoint, set.subset_compl_comm] at disj
exact ⟨U, clopen_U, Ux, disj Vy⟩
intros
simp only [frontier, closure_prod_eq, interior_prod_eq, prod_diff_prod]
intros
constructor
erw induced_infi
congr' 1
funext
erw induced_compose
intros
cases le_total x y with h h; field_simp [h, abs_of_nonneg, abs_of_nonpos, mul_two]; abel
cases le_total x y with h h; field_simp [h, abs_of_nonneg, abs_of_nonpos, mul_two]
cases le_total x y with h h
field_simp [h, abs_of_nonneg, abs_of_nonpos, mul_two]
abel
field_simp [h, abs_of_nonneg, abs_of_nonpos, mul_two]
intros
rw [closure_eq_self_union_frontier, inter_union_distrib_left, inter_union_distrib_left, ite_inter_self, ite_inter_of_inter_eq _ ht]
intros
rw [nhds_within_eq_map_subtype_coe a.coe_prop, mem_map, preimage_image_eq _ subtype.coe_injective, subtype.coe_eta]
intros
rcases continuous_on_iff_is_closed.1 hf t ht with ⟨u, hu⟩
rw [inter_comm, hu.2]
apply is_closed.inter hu.1 hs
intros
tauto
intros
refine le_of_tendsto (tendsto_const_nhds.edist ha) (mem_at_top_sets.2 ⟨n, λ m hnm, _⟩)
refine le_trans (edist_le_Ico_sum_of_edist_le hnm (λ k _ _, hf k)) _
rw [finset.sum_Ico_eq_sum_range]
exact sum_le_tsum _ (λ _ _, zero_le _) ennreal.summable
intros
rw [← not_iff_not, not_not, not_summable_iff_tendsto_nat_at_top]
intros
change continuous_at ((λ (p : ereal × ereal), p.2 + p.1) ∘ prod.swap) (a, ⊤)
apply continuous_at.comp _ continuous_swap.continuous_at
simp_rw add_comm
exact continuous_at_add_top_coe a
intros
rw [real.ball_eq_Ioo, ← sub_div, add_comm, ← sub_add, add_sub_cancel', add_self_div_two, ← add_div, add_assoc, add_sub_cancel'_right, add_self_div_two]
intros
simp only [subtype_restr_def] with mfld_simps
intros
refine ⟨(e.continuous_at hx).tendsto.comp, λ fe_cont, _⟩
rw [← continuous_within_at_inter' h] at fe_cont ⊢
have : continuous_within_at (e.symm ∘ (e ∘ f)) (s ∩ f ⁻¹' e.source) x
have : continuous_within_at e.symm univ (e (f x)) := (e.continuous_at_symm (e.map_source hx)).continuous_within_at
{ have : continuous_within_at e.symm univ (e (f x)) := (e.continuous_at_symm (e.map_source hx)).continuous_within_at, exact continuous_within_at.comp this fe_cont (subset_univ _) }
exact continuous_within_at.comp this fe_cont (subset_univ _)
exact this.congr (λy hy, by simp [e.left_inv hy.2]) (by simp [e.left_inv hx])
intros
ext
rw coe_comap
{ simp only [h, coe_mk, function.comp_app] }
simp only [h, coe_mk, function.comp_app]
rw show f = λ x, y, by ext; apply h
{ rw show f = λ x, y, by ext; apply h, exact continuous_const }
exact continuous_const
intros
simpa only [sub_zero] using real.dist_le_of_mem_Icc hx hy
intros
rw [eq_comm, dist_eq_zero]
intros
rw [union_comm, ball_union_sphere]
intros
rw [← e.image_symm, e.symm.dimH_image]
intros
rw [Hausdorff_edist_zero_iff_closure_eq_closure, hs.closure_eq, ht.closure_eq]
intros
simp [Hausdorff_dist]
intros
rintros ⟨a₁, b₁⟩ ⟨a₂, b₂⟩
simp only [function.uncurry, ennreal.coe_add, add_mul]
apply le_trans (edist_triangle _ (f a₂ b₁) _)
exact add_le_add (le_trans (hα _ _ _) $ ennreal.mul_left_mono $ le_max_left _ _) (le_trans (hβ _ _ _) $ ennreal.mul_left_mono $ le_max_right _ _)
intros
{ rw [←mem_coe], simp, }
rw [←mem_coe]
simp
intros
simp [lower_semicontinuous_within_at, lower_semicontinuous_at, nhds_within_univ]
intros
simp [coclosed_compact, cocompact, infi_and', and_iff_right_of_imp is_compact.is_closed]
intros
letI : topological_space α := ⊥; exact ⟨⟨induced_topology_pure.symm⟩, dense_range_pure⟩
letI : topological_space α := ⊥
exact ⟨⟨induced_topology_pure.symm⟩, dense_range_pure⟩
intros
refine (forall_ne_bot_le_iff _).trans _
rintro f g hle ⟨a, has, haf⟩
{ rintro f g hle ⟨a, has, haf⟩, exact ⟨a, has, haf.mono hle⟩ }
exact ⟨a, has, haf.mono hle⟩
{ simp only [ultrafilter.cluster_pt_iff] }
simp only [ultrafilter.cluster_pt_iff]
intros
refine hs.compl_mem_sets (λ a ha, _)
rcases hf a ha with ⟨t, ht, hst⟩
replace ht := mem_inf_principal.1 ht
apply mem_inf_of_inter ht hst
rintros x ⟨h₁, h₂⟩ hs
exact h₂ (h₁ hs)
intros
casesI is_empty_or_nonempty ι
rw [infi_of_empty, infi_of_empty, to_topological_space_top]
{ rw [infi_of_empty, infi_of_empty, to_topological_space_top] }
refine (eq_of_nhds_eq_nhds $ assume a, _)
{ refine (eq_of_nhds_eq_nhds $ assume a, _), rw [nhds_infi, nhds_eq_uniformity], change (infi u).uniformity.lift' (preimage $ prod.mk a) = _, rw [infi_uniformity, lift'_infi], { simp only [nhds_eq_uniformity], refl }, { exact assume a b, rfl } }
rw [nhds_infi, nhds_eq_uniformity]
change (infi u).uniformity.lift' (preimage $ prod.mk a) = _
rw [infi_uniformity, lift'_infi]
{ simp only [nhds_eq_uniformity], refl }
simp only [nhds_eq_uniformity]
refl
{ exact assume a b, rfl }
exact assume a b, rfl
intros
unfold interleave corec_on
rw corec_eq
refl
intros
apply bind_ext_congr; intro a; cases a; simp [state_t.bind, state_t.run]
apply bind_ext_congr; intro a; cases a
apply bind_ext_congr; intro a
apply bind_ext_congr
intro a
cases a
simp [state_t.bind, state_t.run]
intros
cases a; simp
cases a
simp
simp
intros
have h := int.add_le_add_left h (-a)
rwa int.neg_add_cancel_left at h
intros
have h := int.lt_neg_add_of_add_lt (int.sub_left_lt_of_lt_add h)
rwa int.add_comm at h
intros
induction n with n IH
{ simp, cases bodd m; refl }
simp
cases bodd m
cases bodd m; refl
refl
refl
{ simp [mul_succ, IH], cases bodd m; cases bodd n; refl }
simp [mul_succ, IH]
cases bodd m
cases bodd m; cases bodd n; refl
cases bodd m; cases bodd n
cases bodd n
refl
refl
cases bodd n
refl
refl
intros
rw [nat.mul_comm, mul_div_right _ H]
intros
rw [sub_eq_sub_min, nat.sub_add_cancel (min_le_left n m)]
intros
tactic.mk_inj_eq
intros
simp only [algebra.lmul', tensor_product.lift.tmul, alg_hom.to_linear_map_apply, lmul_apply]
intros
simpa only [sub_eq_add_neg] using S.add_mem hx (S.neg_mem hy)
intros
simpa only [rat.cast_pos] using exists_rat_btwn x0
intros
{ convert (s.prod_piecewise t f f).symm, simp [finset.piecewise] }
convert (s.prod_piecewise t f f).symm
simp [finset.piecewise]
intros
haveI : unique α := unique_of_subsingleton a
convert prod_unique f
intros
simp_rw [prod_subtype_eq_prod_filter, filter_true_of_mem h]
intros
rw finprod_mem_def
apply finprod_of_infinite_mul_support
rwa [← mul_support_mul_indicator] at hs
intros
classical
rcases Hlt with ⟨i, hi, hlt⟩
rw [← insert_erase hi, prod_insert (not_mem_erase _ _), prod_insert (not_mem_erase _ _)]
exact mul_lt_mul_of_lt_of_le hlt (prod_le_prod'' $ λ j hj, Hle j $ mem_of_mem_erase hj)
intros
casesI hq
{ exact char_p.eq R hp infer_instance, }
exact char_p.eq R hp infer_instance
{ exact false.elim (char_p.char_ne_one R 1 rfl), }
exact false.elim (char_p.char_ne_one R 1 rfl)
intros
funext n
{ funext n, exact (int_fract_pair.coe_stream_nth_rat_eq v_eq_q n) }
exact (int_fract_pair.coe_stream_nth_rat_eq v_eq_q n)
intros
cases n
case nat.zero { change g.s.nth 0 = none at terminated_at_n, simp only [convergents', squash_gcf, convergents'_aux, terminated_at_n] }
change g.s.nth 0 = none at terminated_at_n
simp only [convergents', squash_gcf, convergents'_aux, terminated_at_n]
case nat.succ { cases g, simp [(squash_seq_eq_self_of_terminated terminated_at_n), squash_gcf] }
cases g
simp [(squash_seq_eq_self_of_terminated terminated_at_n), squash_gcf]
intros
simpa
intros
rw [from_add_monoid_of, add_monoid_hom.coe_comp]
intros
{ rw mul_comm, apply mul_right_dvd }
rw mul_comm
apply mul_right_dvd
intros
rw [xgcd, ← xgcd_aux_fst x y 1 0 0 1, prod.mk.eta]
intros
simpa using div_add_div b a one_ne_zero hc
intros
classical
apply s.induction_on
{ simp }
simp
intros b t hbt h
rw [gcd_insert, gcd_insert, h, ← gcd_mul_left]
apply ((normalize_associated a).mul_right _).gcd_eq_right
intros
simp [h]
intros
simp [h]
intros
rw [← add_sub_assoc, add_sub_cancel']
intros
rintros ⟨⟩ ⟨⟩ h
congr'
congr'; injection h
injection h
injection h
injection h
intros
induction m with m ih
{ rw [pow_zero, pow_zero, int.cast_one] }
rw [pow_zero, pow_zero, int.cast_one]
{ rw [pow_succ, pow_succ, int.cast_mul, ih] }
rw [pow_succ, pow_succ, int.cast_mul, ih]
intros
rw [← mul_one (a*d), mul_assoc, mul_comm d, ← mul_assoc, ← div_self hb, ← div_mul_eq_mul_div_comm, h, div_mul_eq_mul_div, div_mul_cancel _ hd]
intros
cases i; refl
{ cases i; refl, }
cases i
refl
refl
intros
dsimp [d_to]
rw h
refl
intros
dsimp [mk_hom, mk_hom_aux]
induction n; congr
induction n
congr
congr
intros
{ ext, simp, }
ext
simp
intros
simp only [mul_indicator]
{ simp only [mul_indicator], split_ifs with has has, exacts [ha has, h1] }
split_ifs with has has
exacts [ha has, h1]
intros
simp [sub_eq_add_neg]
intros
revert l
induction k with k ih
induction k with k ih; intros l h₂
intros l h₂
rw nat.le_zero_iff at h₂
{ rw nat.le_zero_iff at h₂, rw [h₂, derived_series_of_ideal_zero], exact h₁, }
rw [h₂, derived_series_of_ideal_zero]
exact h₁
intros l h₂
have h : l = k.succ ∨ l ≤ k
{ have h : l = k.succ ∨ l ≤ k, by rwa [le_iff_eq_or_lt, nat.lt_succ_iff] at h₂, cases h, { rw [h, derived_series_of_ideal_succ, derived_series_of_ideal_succ], exact lie_submodule.mono_lie _ _ _ _ (ih (le_refl k)) (ih (le_refl k)), }, { rw derived_series_of_ideal_succ, exact le_trans (lie_submodule.lie_le_left _ _) (ih h), }, }
rwa [le_iff_eq_or_lt, nat.lt_succ_iff] at h₂
rwa [le_iff_eq_or_lt, nat.lt_succ_iff] at h₂
cases h
rw [h, derived_series_of_ideal_succ, derived_series_of_ideal_succ]
{ rw [h, derived_series_of_ideal_succ, derived_series_of_ideal_succ], exact lie_submodule.mono_lie _ _ _ _ (ih (le_refl k)) (ih (le_refl k)), }
exact lie_submodule.mono_lie _ _ _ _ (ih (le_refl k)) (ih (le_refl k))
rw derived_series_of_ideal_succ
{ rw derived_series_of_ideal_succ, exact le_trans (lie_submodule.lie_le_left _ _) (ih h), }
exact le_trans (lie_submodule.lie_le_left _ _) (ih h)
intros
rw p.exists_lie_subalgebra_coe_eq_iff
split
split; intros h
intros h
intros x m hm
{ intros x m hm, rw [← h, mem_coe_submodule], exact lie_mem _ (subset_lie_span hm), }
rw [← h, mem_coe_submodule]
exact lie_mem _ (subset_lie_span hm)
intros h
rw [← coe_to_submodule_mk p h, coe_to_submodule, coe_to_submodule_eq_iff, lie_span_eq]
{ rw [← coe_to_submodule_mk p h, coe_to_submodule, coe_to_submodule_eq_iff, lie_span_eq], }
intros
rw p.exists_lie_submodule_coe_eq_iff L
split
split; intros h
intros h
intros x m hm
{ intros x m hm, rw [← h, mem_coe_submodule], exact lie_mem _ (subset_lie_span hm), }
rw [← h, mem_coe_submodule]
exact lie_mem _ (subset_lie_span hm)
intros h
rw [← coe_to_submodule_mk p h, coe_to_submodule, coe_to_submodule_eq_iff, lie_span_eq]
{ rw [← coe_to_submodule_mk p h, coe_to_submodule, coe_to_submodule_eq_iff, lie_span_eq], }
intros
rw ← lie_submodule.coe_to_submodule_eq_iff
{ rw ← lie_submodule.coe_to_submodule_eq_iff, exact submodule.comap_subtype_self _, }
exact submodule.comap_subtype_self _
intros
{ intros f g h, ext, exact linear_map.congr_fun h x }
intros f g h
ext
exact linear_map.congr_fun h x
intros
simp
intros
cases o₁; cases o₂; exact dec_trivial
cases o₁; cases o₂
cases o₁
cases o₂
exact dec_trivial
exact dec_trivial
exact dec_trivial
cases o₂
exact dec_trivial
exact dec_trivial
exact dec_trivial
cases o₂
exact dec_trivial
exact dec_trivial
exact dec_trivial
intros
rw [← one_div, div_le_iff_of_neg ha, ← div_eq_inv_mul, div_le_iff_of_neg hb, one_mul]
intros
rcases lt_trichotomy b 0 with (hb|rfl|hb)
{ simp [hb, hb.not_lt, hb.ne, div_le_one_of_neg] }
simp [hb, hb.not_lt, hb.ne, div_le_one_of_neg]
{ simp [zero_le_one], }
simp [zero_le_one]
{ simp [hb, hb.not_lt, div_le_one, hb.ne.symm] }
simp [hb, hb.not_lt, div_le_one, hb.ne.symm]
intros
simp [division_def, mul_neg_iff]
intros
rw [← mul_le_mul_iff_left d, ← mul_le_mul_iff_right b, mul_inv_cancel_left, mul_assoc, inv_mul_cancel_right]
intros
rw [div_lt_iff_lt_mul, mul_comm]
intros
{ rw [mul_comm], exact self_le_mul_right a b }
rw [mul_comm]
exact self_le_mul_right a b
intros
ext x
simp only [mem_smul_set, algebra.id.smul_eq_mul, mem_Ioi]
split
rintro ⟨a_w, a_h_left, rfl⟩
{ rintro ⟨a_w, a_h_left, rfl⟩, exact (mul_le_mul_left hr).mpr a_h_left, }
exact (mul_le_mul_left hr).mpr a_h_left
rintro h
{ rintro h, use x / r, split, exact (le_div_iff' hr).mpr h, exact mul_div_cancel' _ (ne_of_gt hr), }
use x / r
split
exact (le_div_iff' hr).mpr h
exact mul_div_cancel' _ (ne_of_gt hr)
intros
nontriviality
calc 1 = 1 * 1 : by rw one_mul ... < a * b : decidable.mul_lt_mul ha hb zero_lt_one $ zero_le_one.trans ha.le
intros
simp_rw [zero_lt_iff, pow_ne_zero_iff hn]
intros
simpa only [inv_inv] using h.const_smul a⁻¹
intros
induction n with n ih
rw pow_zero
{ rw pow_zero, exact subset.rfl }
exact subset.rfl
rw [pow_succ, pow_succ]
{ rw [pow_succ, pow_succ], exact mul_subset_mul hst ih }
exact mul_subset_mul hst ih
intros
rintro _ ⟨p, q, hp, hq, rfl⟩
{ rintro _ ⟨p, q, hp, hq, rfl⟩, exact submonoid.mul_mem _ (hs hp) (ht hq) }
exact submonoid.mul_mem _ (hs hp) (ht hq)
intros
induction l with hd tl IH
{ simp }
simp
simpa using nat_degree_mul_le.trans (add_le_add_left IH _)
{ simpa using nat_degree_mul_le.trans (add_le_add_left IH _) }
intros
{ rw ←left_cancel x, simp }
rw ←left_cancel x
simp
intros
refine ⟨_, is_left_regular.pow n⟩
rw [← nat.succ_pred_eq_of_pos n0, pow_succ']
exact is_left_regular.of_mul
intros
simp
intros
{ rw [← ring_hom.comp_apply, comp_eq], simp }
rw [← ring_hom.comp_apply, comp_eq]
simp
intros
{ dsimp [mk_ring_hom], rintro ⟨⟨⟩⟩, simp, }
dsimp [mk_ring_hom]
rintro ⟨⟨⟩⟩
simp
intros
rw [finset.sum_eq_multiset_sum, divisors_filter_squarefree h0, multiset.map_map, finset.sum_eq_multiset_sum]
intros
split_ifs with h
split_ifs with h; simp [h]
{ split_ifs with h; simp [h] }
simp [h]
simp [h]
intros
rw [image_of_Df, set_of_exists (λ i (x : prime_spectrum R), coeff f i ∉ x.val)]
exact is_open_Union (λ i, is_open_basic_open)
intros
simpa using (gc R).u_top
intros
unfold is_o at *
intros c' c'pos
have : 0 < c' / c
from div_pos c'pos hc
exact (hfg.trans (hgk this) (le_of_lt hc)).congr_const (mul_div_cancel' _ (ne_of_gt hc))
intros
refine (is_O_with_const_const c _ l).congr_const _
{ rw [norm_one, div_one] }
rw [norm_one, div_one]
{ exact one_ne_zero }
exact one_ne_zero
intros
have := (hc.has_strict_fderiv_at.clm_comp hd.has_strict_fderiv_at).has_strict_deriv_at
rwa [add_apply, comp_apply, comp_apply, smul_right_apply, smul_right_apply, one_apply, one_smul, one_smul, add_comm] at this
intros
{ unfold deriv_within, rw fderiv_within_inter ht hs }
unfold deriv_within
rw fderiv_within_inter ht hs
intros
simp only [has_strict_fderiv_at, continuous_linear_map.coe_pi]
exact is_o_pi
intros
simpa only [smul_zero, zero_add] using hc.smul (has_strict_fderiv_at_const f x)
intros
rw [← differentiable_within_at_univ, ← fderiv_within_univ]
exact differentiable_within_at_iff_restrict_scalars 𝕜 hf.differentiable_within_at unique_diff_within_at_univ
intros
rw differentiable_at.fderiv_within (differentiable_at_id) hxs
exact fderiv_id
intros
simp only [implicit_to_local_homeomorph_of_complemented_apply, add_sub_cancel, classical.some_spec hker]
intros
rw eventually_iff_exists_mem at *
rcases hff' with ⟨s₁, hs₁, hff'⟩
rcases hgg' with ⟨s₂, hs₂, hgg'⟩
rcases hg' with ⟨s₃, hs₃, hg'⟩
let s := s₁ ∩ s₂ ∩ s₃
have hs : s ∈ at_top := inter_mem (inter_mem hs₁ hs₂) hs₃
rw mem_at_top_sets at hs
rcases hs with ⟨l, hl⟩
have hl' : Ioi l ⊆ s := λ x hx, hl x (le_of_lt hx)
refine lhopital_zero_at_top_on_Ioi _ _ (λ x hx, hg' x $ (hl' hx).2) hftop hgtop hdiv
refine lhopital_zero_at_top_on_Ioi _ _ (λ x hx, hg' x $ (hl' hx).2) hftop hgtop hdiv; intros x hx; apply_assumption; exact (hl' hx).1.1 <|> exact (hl' hx).1.2
refine lhopital_zero_at_top_on_Ioi _ _ (λ x hx, hg' x $ (hl' hx).2) hftop hgtop hdiv; intros x hx; apply_assumption
refine lhopital_zero_at_top_on_Ioi _ _ (λ x hx, hg' x $ (hl' hx).2) hftop hgtop hdiv; intros x hx
intros x hx
apply_assumption
exact (hl' hx).1.1
intros x hx
apply_assumption
exact (hl' hx).1.2
exact (hl' hx).1.1
intros
rw ← f_aux_zero_eq
apply times_cont_diff_of_differentiable_iterated_deriv (λ m hm, _)
rw f_aux_iterated_deriv m
exact λ x, (f_aux_has_deriv_at m x).differentiable_at
intros
rw [← times_cont_diff_within_at_univ] at *; exact hf.mul hg
rw [← times_cont_diff_within_at_univ] at *
exact hf.mul hg
intros
assume m hm
rcases h m hm with ⟨u, hu, p, H⟩
exact ⟨u, nhds_within_le_of_mem (insert_mem_nhds_within_insert hst) hu, p, H⟩
simpa [mul_self_abs] using tendsto_abs_cocompact_at_top.at_top_mul_at_top tendsto_abs_cocompact_at_top
intros
rw ←open_segment_eq_Ioo h
simp_rw [←exists_prop]
refl
intros
split
rintro ⟨hconv, h⟩
{ rintro ⟨hconv, h⟩, refine ⟨hconv, λ x y hx hy a b ha hb hab, _⟩, simp [neg_apply, neg_le, add_comm] at h, exact h hx hy ha hb hab }
refine ⟨hconv, λ x y hx hy a b ha hb hab, _⟩
simp [neg_apply, neg_le, add_comm] at h
exact h hx hy ha hb hab
rintro ⟨hconv, h⟩
{ rintro ⟨hconv, h⟩, refine ⟨hconv, λ x y hx hy a b ha hb hab, _⟩, rw ←neg_le_neg_iff, simp_rw [neg_add, pi.neg_apply, smul_neg, neg_neg], exact h hx hy ha hb hab }
refine ⟨hconv, λ x y hx hy a b ha hb hab, _⟩
rw ←neg_le_neg_iff
simp_rw [neg_add, pi.neg_apply, smul_neg, neg_neg]
exact h hx hy ha hb hab
intros
rw [←inner_conj_sym, inner_add_left, ring_hom.map_add]
rw [←inner_conj_sym, inner_add_left, ring_hom.map_add]; simp only [inner_conj_sym]
simp only [inner_conj_sym]
intros
simp only [inner_zero_right, add_monoid_hom.map_zero]
intros
simp only [dist_eq_norm]
{ simp only [dist_eq_norm], exact (hf.sub hg).norm (sub_ne_zero.2 hne) }
exact (hf.sub hg).norm (sub_ne_zero.2 hne)
intros
convert submodule.finrank_add_inf_finrank_orthogonal (le_top : K ≤ ⊤) using 1
{ rw inf_top_eq }
rw inf_top_eq
{ simp }
simp
intros
simp only [← dist_zero_right, dist_pi_lt_iff hr, pi.zero_apply]
intros
{ rw norm_sub_rev, exact norm_le_insert v u }
rw norm_sub_rev
exact norm_le_insert v u
intros
rw [edist_dist, dist_eq_norm, of_real_norm_eq_coe_nnnorm]
intros
{ ext, refl }
ext
refl
intros
simp only [eventually_iff, metric.mem_nhds_iff]
use [1, by norm_num]
intros t ht
simp only [mem_ball, dist_zero_right] at ht
simp only [inverse_one_sub t ht, set.mem_set_of_eq]
have h : 1 = ((range n).sum (λ i, t ^ i)) * (units.one_sub t ht) + t ^ n
simp only [units.coe_one_sub]
{ simp only [units.coe_one_sub], rw [← geom_sum, geom_sum_mul_neg], simp }
rw [← geom_sum, geom_sum_mul_neg]
simp
rw [← one_mul ↑(units.one_sub t ht)⁻¹, h, add_mul]
congr
rw [mul_assoc, (units.one_sub t ht).mul_inv]
{ rw [mul_assoc, (units.one_sub t ht).mul_inv], simp }
simp
simp only [units.coe_one_sub]
{ simp only [units.coe_one_sub], rw [← add_mul, ← geom_sum, geom_sum_mul_neg], simp }
rw [← add_mul, ← geom_sum, geom_sum_mul_neg]
simp
intros
rw [norm_eq_sqrt_real_inner, inner_self, norm_sq_coe, real.sqrt_sq_eq_abs, real.norm_eq_abs]
intros
simp only [bernstein_apply]
exact mul_nonneg (mul_nonneg (nat.cast_nonneg _) (pow_nonneg (by unit_interval) _)) (pow_nonneg (by unit_interval) _)
intros
simp [log]
intros
rw [log_of_ne_zero hx, ← coe_exp_order_iso_apply, order_iso.apply_symm_apply, subtype.coe_mk]
intros
simpa using integral_sin_pow_mul_cos_pow_odd 2 0
convert tendsto_rpow_div_mul_add (1:ℝ) _ (0:ℝ) zero_ne_one
{ convert tendsto_rpow_div_mul_add (1:ℝ) _ (0:ℝ) zero_ne_one, ring_nf }
ring_nf
intros
rw ← abs_cpow_real; simp [-abs_cpow_real]
rw ← abs_cpow_real
simp [-abs_cpow_real]
intros
convert rpow_lt_rpow_of_exponent_gt hx1 hx2 hz
{ convert rpow_lt_rpow_of_exponent_gt hx1 hx2 hz, exact (rpow_zero x).symm }
exact (rpow_zero x).symm
intros
simpa only [cos_zero] using (cos_periodic.int_mul n).sub_antiperiod_eq cos_antiperiodic
simp
intros
rw [arcsin, function.comp_app, Icc_extend_coe, function.comp_app, Icc_extend]
intros
obtain ⟨g, hg⟩ := cokernel_cofork.is_colimit.desc' is_colimit_σ (limits.prod.map f f ≫ σ) (by simp)
suffices hfg : f = g
{ rw [←hg, cofork.π_of_π, hfg] }
rw [←hg, cofork.π_of_π, hfg]
calc f = f ≫ prod.lift (𝟙 Y) 0 ≫ σ : by rw [lift_σ, category.comp_id] ... = prod.lift (𝟙 X) 0 ≫ limits.prod.map f f ≫ σ : by rw lift_map_assoc ... = prod.lift (𝟙 X) 0 ≫ σ ≫ g : by rw [←hg, cokernel_cofork.π_of_π] ... = g : by rw [←category.assoc, lift_σ, category.id_comp]
intros
rw [hom_equiv_counit, F.map_comp, assoc, adj.hom_equiv_counit.symm]
intros
{ substI h, exact mono_of_mono f g, }
substI h
exact mono_of_mono f g
intros
{ cases q, simp, }
cases q
simp
intros
apply (cancel_epi f.hom).mp
simp [hom_inv_id]
intros
{ rw ← c.π.naturality f, apply id_comp }
rw ← c.π.naturality f
apply id_comp
intros
dsimp [limit_obj_iso_limit_comp_evaluation]
simp
intros
{ ext; simp }
ext
ext; simp
simp
simp
intros
simp
intros
tidy
intros
let y' : punit ⟶ Y := λ _, y
have hy' : y' ≫ g = y' ≫ h := funext (λ _, hy)
refine ⟨(fork.is_limit.lift' t _ hy').1 ⟨⟩, congr_fun (fork.is_limit.lift' t y' _).2 ⟨⟩, _⟩
intros x' hx'
suffices : (λ (_ : punit), x') = (fork.is_limit.lift' t y' hy').1
rw ← this
apply fork.is_limit.hom_ext t
ext ⟨⟩
apply hx'.trans (congr_fun (fork.is_limit.lift' t _ hy').2 ⟨⟩).symm
intros
suffices : (λ (x : t.X), ulift.up (∃ j y, t.ι.app j y = x)) = (λ _, ulift.up true)
have := congr_fun this x
{ have := congr_fun this x, have H := congr_arg ulift.down this, dsimp at H, rwa eq_true at H }
have H := congr_arg ulift.down this
dsimp at H
rwa eq_true at H
refine h.hom_ext _
intro j
ext y
erw iff_true
exact ⟨j, y, rfl⟩
intros
{ rw [←tensor_comp], simp }
rw [←tensor_comp]
simp
intros
{ rw ←pentagon W X Y Z, simp }
rw ←pentagon W X Y Z
simp
intros
{ ext, rw ←nat_trans.comp_app, simp, }
ext
rw ←nat_trans.comp_app
simp
intros
simp [covers_iff]
intros
split
intros PJ X R hR
{ intros PJ X R hR, rw is_sheaf_for_iff_generate, apply PJ (sieve.generate R) ⟨_, hR, le_generate R⟩ }
rw is_sheaf_for_iff_generate
apply PJ (sieve.generate R) ⟨_, hR, le_generate R⟩
rintro PK X S ⟨R, hR, RS⟩
{ rintro PK X S ⟨R, hR, RS⟩, have gRS : ⇑(generate R) ≤ S, { apply gi_generate.gc.monotone_u, rwa sets_iff_generate }, apply is_sheaf_for_subsieve P gRS _, intros Y f, rw [← pullback_arrows_comm, ← is_sheaf_for_iff_generate], exact PK (pullback_arrows f R) (K.pullbacks f R hR) }
have gRS : ⇑(generate R) ≤ S
apply gi_generate.gc.monotone_u
{ apply gi_generate.gc.monotone_u, rwa sets_iff_generate }
rwa sets_iff_generate
apply is_sheaf_for_subsieve P gRS _
intros Y f
rw [← pullback_arrows_comm, ← is_sheaf_for_iff_generate]
exact PK (pullback_arrows f R) (K.pullbacks f R hR)
intros
ext
simp only [functor_inclusion_app, sieve_of_subfunctor_apply, subtype.val_eq_coe]
split
rintro ⟨⟨f, hf⟩, rfl⟩
{ rintro ⟨⟨f, hf⟩, rfl⟩, exact hf }
exact hf
intro hf
{ intro hf, exact ⟨⟨_, hf⟩, rfl⟩ }
exact ⟨⟨_, hf⟩, rfl⟩
intros
apply quotient.induction_on' x
intro t
apply quotient.sound
refine ⟨(mono_over.pullback_comp _ _).app t⟩
intros
{ simp [kernel_subobject_iso_comp], }
simp [kernel_subobject_iso_comp]
intros
simp [types_id]
intros
simp only [lt_def, mem_singleton, ←and_assoc, exists_eq_right]
split
intros t x hx
{ intros t x hx, rw ←not_le, intro h, rcases lt_or_eq_of_le h with h₁ | rfl, { exact ne_of_irrefl h₁ ((t.1 h₁).1 hx).symm }, { exact t.2 hx } }
rw ←not_le
intro h
rcases lt_or_eq_of_le h with h₁ | rfl
{ exact ne_of_irrefl h₁ ((t.1 h₁).1 hx).symm }
exact ne_of_irrefl h₁ ((t.1 h₁).1 hx).symm
{ exact t.2 hx }
exact t.2 hx
exact λ h, ⟨λ z hz, ⟨λ i, (asymm hz (h _ i)).elim, λ i, (hz.ne' i).elim⟩, by simpa using h r⟩
{ exact λ h, ⟨λ z hz, ⟨λ i, (asymm hz (h _ i)).elim, λ i, (hz.ne' i).elim⟩, by simpa using h r⟩ }
intros
rw [boundary, finset.order_emb_of_fin_zero rfl c.card_boundaries_pos]
exact le_antisymm (finset.min'_le _ _ c.zero_mem) (fin.zero_le _)
intros
simp_rw [line.apply, line.diagonal, option.get_or_else_none]
intros
ext v w
cases h.zero_or_one v w with h h; by_cases hvw : v = w; simp [matrix.compl, h, hvw]
cases h.zero_or_one v w with h h; by_cases hvw : v = w
cases h.zero_or_one v w with h h
by_cases hvw : v = w
simp [matrix.compl, h, hvw]
simp [matrix.compl, h, hvw]
by_cases hvw : v = w
simp [matrix.compl, h, hvw]
simp [matrix.compl, h, hvw]
intros
ext w
have h := @ne_of_adj _ G
simp_rw [set.mem_union, mem_neighbor_set, compl_adj, set.mem_compl_eq, set.mem_singleton_iff]
tauto
intros
conv {to_lhs, rw [← list_blank.cons_head_tail l]}
exact quotient.induction_on' l (λ a, rfl)
intros
{ cases η, cases η', congr, exact h }
cases η
cases η'
congr
exact h
intros
ext
ext; simp [naturality]
simp [naturality]
intros
cases b; simp only [to_bool_iff, nat.add_mul_mod_self_left, add_lsb, ←two_mul, add_comm, bool.to_bool_false, nat.mul_mod_right, zero_add, cond, zero_ne_one]; norm_num
cases b; simp only [to_bool_iff, nat.add_mul_mod_self_left, add_lsb, ←two_mul, add_comm, bool.to_bool_false, nat.mul_mod_right, zero_add, cond, zero_ne_one]
cases b
simp only [to_bool_iff, nat.add_mul_mod_self_left, add_lsb, ←two_mul, add_comm, bool.to_bool_false, nat.mul_mod_right, zero_add, cond, zero_ne_one]
simp only [to_bool_iff, nat.add_mul_mod_self_left, add_lsb, ←two_mul, add_comm, bool.to_bool_false, nat.mul_mod_right, zero_add, cond, zero_ne_one]
norm_num
intros
induction l with hd tl hl generalizing b i
{ exact absurd i.zero_le (not_le_of_lt h) }
exact absurd i.zero_le (not_le_of_lt h)
convert_to ((b.push_back hd).append_list tl).read _ = _
{ convert_to ((b.push_back hd).append_list tl).read _ = _, cases i, { convert read_append_list_left _ _ _; simp }, { rw [list.length, nat.succ_lt_succ_iff] at h, have : b.size + i.succ = (b.push_back hd).size + i, { simp [add_comm, add_left_comm, nat.succ_eq_add_one] }, convert hl (b.push_back hd) h using 1, simpa [nat.add_succ, nat.succ_add] } }
cases i
convert read_append_list_left _ _ _; simp
convert read_append_list_left _ _ _
{ convert read_append_list_left _ _ _; simp }
simp
simp
rw [list.length, nat.succ_lt_succ_iff] at h
{ rw [list.length, nat.succ_lt_succ_iff] at h, have : b.size + i.succ = (b.push_back hd).size + i, { simp [add_comm, add_left_comm, nat.succ_eq_add_one] }, convert hl (b.push_back hd) h using 1, simpa [nat.add_succ, nat.succ_add] }
have : b.size + i.succ = (b.push_back hd).size + i
simp [add_comm, add_left_comm, nat.succ_eq_add_one]
{ simp [add_comm, add_left_comm, nat.succ_eq_add_one] }
convert hl (b.push_back hd) h using 1
simpa [nat.add_succ, nat.succ_add]
intros
simp only [map_const_eq, map_eq_fail]
intros
simp_rw [any_char]
split_ifs with h; simp [h, eq_comm]
split_ifs with h
simp [h, eq_comm]
simp [h, eq_comm]
intros
simp [many1, seq_eq_done]
intros
rw [inv_def, ← mul_assoc, mul_conj, ← of_real_mul, mul_inv_cancel (mt norm_sq_eq_zero.1 h), of_real_one]
intros
simp [le_def]
intros
have hxc : complex.abs x ≤ 1
exact_mod_cast hx
exact_mod_cast hx
convert exp_bound hxc hn; norm_cast
convert exp_bound hxc hn
norm_cast
norm_cast
intros
have h1 : x + 2 * x = 3 * x
ring
ring
rw [← h1, cosh_add x (2 * x)]
simp only [cosh_two_mul, sinh_two_mul]
have h2 : sinh x * (2 * sinh x * cosh x) = 2 * cosh x * sinh x ^ 2
ring
ring
rw [h2, sinh_sq]
ring
intros
rw algebra.smul_def
{ rw algebra.smul_def, apply of_real_mul_im }
apply of_real_mul_im
intros
by_cases h : (I : K) = 0; field_simp [h]
{ by_cases h : (I : K) = 0; field_simp [h] }
by_cases h : (I : K) = 0
field_simp [h]
field_simp [h]
intros
{ ext, simp only [map_range_apply, id.def] }
ext
simp only [map_range_apply, id.def]
intros
{ ext, simp }
ext
simp
intros
rw [swap_eq_update, comp_update, comp_update, comp.right_id]
intros
simp [perm.subtype_congr.apply, h]
intros
{ cases k, refl, }
cases k
refl
intros
simp only [← image_source_eq_target, ← h.source_eq, h.2.image_eq]
intros
rw [succ_above_above, succ_pred]
{ rw [succ_above_above, succ_pred], simpa [le_iff_coe_le_coe] using nat.le_pred_of_lt h }
simpa [le_iff_coe_le_coe] using nat.le_pred_of_lt h
intros
ext y
simp only [set.mem_range, set.mem_insert_iff]
split
rintros ⟨i, rfl⟩
{ rintros ⟨i, rfl⟩, refine cases (or.inl (cons_zero _ _)) (λ i, or.inr ⟨i, _⟩) i, rw cons_succ }
refine cases (or.inl (cons_zero _ _)) (λ i, or.inr ⟨i, _⟩) i
rw cons_succ
rintros (rfl | ⟨i, hi⟩)
{ rintros (rfl | ⟨i, hi⟩), { exact ⟨0, fin.cons_zero _ _⟩ }, { refine ⟨i.succ, _⟩, rw [cons_succ, hi] } }
{ exact ⟨0, fin.cons_zero _ _⟩ }
exact ⟨0, fin.cons_zero _ _⟩
refine ⟨i.succ, _⟩
{ refine ⟨i.succ, _⟩, rw [cons_succ, hi] }
rw [cons_succ, hi]
intros
cases s
cases s; refl
refl
intros
simp only [insert_eq, image_singleton, image_union]
intros
rw strong_induction
intros
simp only [←finset.coe_subset, set.not_subset, exists_prop, finset.mem_coe]
intros
rw [← coe_empty, coe_inj]
intros
simp only [insert_union, union_insert, insert_idem]
intros
{ dunfold fold, rw [cons_val, map_cons, fold_cons_left], }
dunfold fold
rw [cons_val, map_cons, fold_cons_left]
intros
classical
induction s using finset.induction_on with a s' ha ih
induction s using finset.induction_on with a s' ha ih; simp *
simp *
simp *
intros
ext
simp only [exists_prop, mem_map, mem_antidiagonal, prod.exists]
rw add_comm
split
rintro ⟨b, c, ⟨rfl, rfl⟩⟩
{ rintro ⟨b, c, ⟨rfl, rfl⟩⟩, simp }
simp
rintro rfl
{ rintro rfl, use [a.snd, a.fst], simp }
use [a.snd, a.fst]
simp
intros
{ ext x, simp [part.mem_eq, and.exists, -exists_prop] }
ext x
simp [part.mem_eq, and.exists, -exists_prop]
intros
simp only [order_emb_of_fin_apply, subtype.coe_mk, sorted_zero_eq_min']
intros
rw ← finset.bUnion_singleton
refine finset.subset.trans support_sum _
refine finset.bUnion_mono (assume a _, support_single_subset)
intros
ext s
by_cases hs : s = a
{ rw [hs, erase_same], refl }
rw [hs, erase_same]
refl
{ rw [erase_ne hs], exact single_eq_of_ne (ne.symm hs) }
rw [erase_ne hs]
exact single_eq_of_ne (ne.symm hs)
intros
{ ext, simp, }
ext
simp
intros
classical
by_contra hf
push_neg at hf
apply not_injective_infinite_fintype f
intros x y
contrapose
apply hf
intros
rw [← fin.prod_univ_eq_prod_range, finset.prod_congr rfl]
rintros ⟨i, hi⟩ _
simp only [fin.coe_eq_val, hi, dif_pos]
intros
rw [← nat_abs_mul, h, nat_abs_of_nat]
intros
rcases nat_abs_eq z with eq | eq; rw eq; simp [coe_nat_dvd]
rcases nat_abs_eq z with eq | eq; rw eq
rcases nat_abs_eq z with eq | eq
rw eq
simp [coe_nat_dvd]
rw eq
simp [coe_nat_dvd]
intros
rw [← int.div_mul_cancel H2]; exact decidable.mul_le_mul_of_nonneg_right H3 H1
rw [← int.div_mul_cancel H2]
exact decidable.mul_le_mul_of_nonneg_right H3 H1
intros
rw int.gcd at h ⊢; rwa int.nat_abs_neg
rw int.gcd at h ⊢
rwa int.nat_abs_neg
intros
rw [not_odd_iff, even_iff]
intros
simp only [insert_entries]; rw [kerase_cons_ne,kerase_cons_ne,kerase_comm]; [apply perm.swap, exact h, exact h.symm]
simp only [insert_entries]; rw [kerase_cons_ne,kerase_cons_ne,kerase_comm]
simp only [insert_entries]
rw [kerase_cons_ne,kerase_cons_ne,kerase_comm]
apply perm.swap
exact h
exact h.symm
intros
induction l₁ generalizing n
simp
{ simp }
cases n
simp
{ simp }
simp *
intros
funext l
induction l with a l IH
refl
{refl}
by_cases pa : p a
simp only [filter_map, option.guard, IH, if_pos pa, filter_cons_of_pos _ pa]
{ simp only [filter_map, option.guard, IH, if_pos pa, filter_cons_of_pos _ pa], split; refl }
split
split; refl
refl
refl
simp only [filter_map, option.guard, IH, if_neg pa, filter_cons_of_neg _ pa]
{ simp only [filter_map, option.guard, IH, if_neg pa, filter_cons_of_neg _ pa] }
intros
convert filter_eq_self.2 (λ _ _, trivial)
intros
convert map_permutations_aux2' id _ _ _ _ _ _ _ _
convert map_permutations_aux2' id _ _ _ _ _ _ _ _; simp only [map_id, id.def]
simp only [map_id, id.def]
simp only [map_id, id.def]
simp only [map_id, id.def]
exact (λ _, rfl)
intros
rcases exists_or_eq_self_of_erasep p l with h | ⟨c, l₁, l₂, h₁, h₂, h₃, h₄⟩
rcases exists_or_eq_self_of_erasep p l with h | ⟨c, l₁, l₂, h₁, h₂, h₃, h₄⟩; [rw h, {rw [h₄, h₃], simp}]
rw h
rw [h₄, h₃]
simp
intros
simp only [product, mem_bind, mem_map, prod.ext_iff, exists_prop, and.left_comm, exists_and_distrib_left, exists_eq_left, exists_eq_right]
intros
have : (λ a b, flip f a (some b)) = (flip (λ a b, f (some a) b)) := rfl
simp only [map₂_right, map₂_left_eq_map₂, map₂_flip, *]
intros
rw [concat_eq_append, reverse_append, reverse_singleton, singleton_append]
intros
cases l
{ contradiction }
contradiction
{ simp }
simp
intros
rw [next, nth_le, ←init_append_last (cons_ne_nil y l), hx, next_or_concat]
subst hx
intro H
obtain ⟨_ | k, hk, hk'⟩ := nth_le_of_mem H
{ simpa [init_eq_take, nth_le_take', hy.symm] using hk' }
simpa [init_eq_take, nth_le_take', hy.symm] using hk'
suffices : k.succ = l.length
{ simpa [this] using hk }
simpa [this] using hk
cases l with hd tl
{ simpa using hk }
simpa using hk
rw nodup_iff_nth_le_inj at hl
{ rw nodup_iff_nth_le_inj at hl, rw [length, nat.succ_inj'], apply hl, simpa [init_eq_take, nth_le_take', last_eq_nth_le] using hk' }
rw [length, nat.succ_inj']
apply hl
simpa [init_eq_take, nth_le_take', last_eq_nth_le] using hk'
intros
funext a b
apply propext
split
intro h
{ intro h, induction h, {refl}, simp only [*]; split; refl }
induction h
refl
{refl}
simp only [*]
simp only [*]; split; refl
simp only [*]; split
split
refl
refl
{ intro h, subst h, exact forall₂_refl _ }
intro h
subst h
exact forall₂_refl _
intros
simp only [mfoldr_with_index, mfoldr_eq_foldr, foldr_with_index_eq_foldr_enum, uncurry]
intros
simp only [slice_eq]
have : n ≤ n + m := nat.le_add_right _ _
have := h.nodup_iff.2 h'
apply perm.trans _ (perm.inter_append _).symm
apply perm.trans _ (perm.inter_append _).symm; solve_by_elim [perm.append, perm.drop_inter, perm.take_inter, disjoint_take_drop, h, h'] { max_depth := 7 }
solve_by_elim [perm.append, perm.drop_inter, perm.take_inter, disjoint_take_drop, h, h'] { max_depth := 7 }
solve_by_elim [perm.append, perm.drop_inter, perm.take_inter, disjoint_take_drop, h, h'] { max_depth := 7 }
intros
rw [countp_eq_length_filter, countp_eq_length_filter]
rw [countp_eq_length_filter, countp_eq_length_filter]; exact (s.filter _).length_eq
exact (s.filter _).length_eq
intros
{ dsimp [(∩), list.inter], congr, funext a, rw [p.mem_iff] }
dsimp [(∩), list.inter]
congr
funext a
rw [p.mem_iff]
intros
simp only [enum, enum_from_map_fst, range_eq_range']
intros
rintros l l' (h : l.rotate n = l'.rotate n)
have hle : l.length = l'.length := (l.length_rotate n).symm.trans (h.symm ▸ l'.length_rotate n)
rw [rotate_eq_drop_append_take_mod, rotate_eq_drop_append_take_mod] at h
obtain ⟨hd, ht⟩ := append_inj h _
{ rw [←take_append_drop _ l, ht, hd, take_append_drop] }
rw [←take_append_drop _ l, ht, hd, take_append_drop]
{ rw [length_drop, length_drop, hle] }
rw [length_drop, length_drop, hle]
intros
simp [nodupkeys, keys_kreplace]
intros
simp only [unzip_eq_map]
intros
{ ext, apply add_dot_product }
ext
apply add_dot_product
intros
simp [dot_product]
intros
{ ext, simp [vec_mul] }
ext
simp [vec_mul]
intros
ext ⟨i, k⟩ ⟨j, k'⟩
simp only [block_diagonal_apply, diagonal]
split_ifs; finish
split_ifs
finish
finish
finish
finish
finish
finish
intros
{ ext, simp [vec_tail] }
ext
simp [vec_tail]
intros
{ ext i, refine fin.cases _ _ i; simp [vec_head, vec_tail] }
ext i
refine fin.cases _ _ i
refine fin.cases _ _ i; simp [vec_head, vec_tail]
simp [vec_head, vec_tail]
simp [vec_head, vec_tail]
intros
apply le_antisymm
rw union_add_distrib
{ rw union_add_distrib, refine union_le (add_le_add_left (inter_le_right _ _) _) _, rw add_comm, exact add_le_add_right (inter_le_left _ _) _ }
refine union_le (add_le_add_left (inter_le_right _ _) _) _
rw add_comm
exact add_le_add_right (inter_le_left _ _) _
rw [add_comm, add_inter_distrib]
{ rw [add_comm, add_inter_distrib], refine le_inter (add_le_add_right (le_union_right _ _) _) _, rw add_comm, exact add_le_add_right (le_union_left _ _) _ }
refine le_inter (add_le_add_right (le_union_right _ _) _) _
rw add_comm
exact add_le_add_right (le_union_left _ _) _
intros
simp [ndinter, h]
intros
apply mv_polynomial.ring_hom_ext
intro r
{ intro r, rw [ring_hom.comp_apply, eval₂_hom_C, eval₂_hom_C, ring_hom.comp_apply] }
rw [ring_hom.comp_apply, eval₂_hom_C, eval₂_hom_C, ring_hom.comp_apply]
intro i
{ intro i, rw [ring_hom.comp_apply, eval₂_hom_X', eval₂_hom_X'] }
rw [ring_hom.comp_apply, eval₂_hom_X', eval₂_hom_X']
intros
{ ext i, simp only [rename_X, comap_apply, aeval_X] }
ext i
simp only [rename_X, comap_apply, aeval_X]
intros
cases n
{ exact (m % 0).div_zero }
exact (m % 0).div_zero
{ exact nat.div_eq_zero (m.mod_lt n.succ_pos) }
exact nat.div_eq_zero (m.mod_lt n.succ_pos)
intros
simp [or_imp_distrib] {contextual := tt}
intros
rw [cast_choose K (le_add_right le_rfl), nat.add_sub_cancel_left]
intros
rw dist_comm; apply dist_tri_right
rw dist_comm
apply dist_tri_right
intros
rw [← add_mod_add_ite, if_pos hc]
intros
by_cases h₁ : a₁ < b; simp [mkpair, h₁, add_assoc]
by_cases h₁ : a₁ < b
simp [mkpair, h₁, add_assoc]
by_cases h₂ : a₂ < b; simp [mkpair, h₂, h]
by_cases h₂ : a₂ < b
{ by_cases h₂ : a₂ < b; simp [mkpair, h₂, h], simp at h₂, apply add_lt_add_of_le_of_lt, exact mul_self_le_mul_self h₂, exact lt_add_right _ _ _ h }
simp [mkpair, h₂, h]
simp [mkpair, h₂, h]
simp at h₂
apply add_lt_add_of_le_of_lt
exact mul_self_le_mul_self h₂
exact lt_add_right _ _ _ h
simp [mkpair, h₁, add_assoc]
simp at h₁
{ simp at h₁, simp [not_lt_of_gt (lt_of_le_of_lt h₁ h)], apply add_lt_add, exact mul_self_lt_mul_self h, apply add_lt_add_right; assumption }
simp [not_lt_of_gt (lt_of_le_of_lt h₁ h)]
apply add_lt_add
exact mul_self_lt_mul_self h
apply add_lt_add_right; assumption
apply add_lt_add_right
assumption
intros
rcases x with _ | _ | x; simp
{ rcases x with _ | _ | x; simp }
rcases x with _ | _ | x
simp
simp
simp
intros
rw balance_eq_balance' hl.3 hr.3 hl.2 hr.2; exact hl.balance' hr H
rw balance_eq_balance' hl.3 hr.3 hl.2 hr.2
exact hl.balance' hr H
intros
cases m; simp [node4_l, node4_r, dual_node3_r, dual_node']
cases m
simp [node4_l, node4_r, dual_node3_r, dual_node']
simp [node4_l, node4_r, dual_node3_r, dual_node']
intros
rw [← find_min_dual, dual_dual]
intros
induction n generalizing x y; cases x; cases y
induction n generalizing x y; cases x
induction n generalizing x y
cases x
cases y
{ refl }
refl
cases x
cases y
{ cases h with _ _ _ _ _ h₀ h₁, cases h, simp only [truncate, function.comp, true_and, eq_self_iff_true, heq_iff_eq], ext y, apply n_ih, apply h₁ }
cases h with _ _ _ _ _ h₀ h₁
cases h
simp only [truncate, function.comp, true_and, eq_self_iff_true, heq_iff_eq]
ext y
apply n_ih
apply h₁
intros
{ rw mul_comm, exact div_add_mod _ _ }
rw mul_comm
exact div_add_mod _ _
intros
apply le_antisymm
rw[← prime_multiset.prod_dvd_iff, prod_factor_multiset]
{ rw[← prime_multiset.prod_dvd_iff, prod_factor_multiset], apply lcm_dvd; rw[← factor_multiset_le_iff'], exact le_sup_left, exact le_sup_right}
apply lcm_dvd; rw[← factor_multiset_le_iff']
apply lcm_dvd
rw[← factor_multiset_le_iff']
exact le_sup_left
rw[← factor_multiset_le_iff']
exact le_sup_right
apply sup_le_iff.mpr; split; apply factor_multiset_le_iff.mpr
apply sup_le_iff.mpr; split
apply sup_le_iff.mpr
{ apply sup_le_iff.mpr; split; apply factor_multiset_le_iff.mpr, exact dvd_lcm_left m n, exact dvd_lcm_right m n }
split
apply factor_multiset_le_iff.mpr
exact dvd_lcm_left m n
apply factor_multiset_le_iff.mpr
exact dvd_lcm_right m n
intros
rw [aeval_def, eval₂_map, ←is_scalar_tower.algebra_map_eq, ←aeval_def]
intros
simp [monomial, monomial_fun, smul_to_finsupp]
intros
rcases p
{ rcases p, simp only [C, monomial, monomial_fun, mul_to_finsupp, ring_hom.coe_mk, coeff, add_monoid_algebra.single_zero_mul_apply p a n] }
simp only [C, monomial, monomial_fun, mul_to_finsupp, ring_hom.coe_mk, coeff, add_monoid_algebra.single_zero_mul_apply p a n]
intros
by_cases h : a = 0; [rw [h, C_0], rw [degree_C h]]; [exact bot_le, exact le_refl _]
by_cases h : a = 0; [rw [h, C_0], rw [degree_C h]]
by_cases h : a = 0
rw [h, C_0]
exact bot_le
rw [degree_C h]
exact le_refl _
intros
by_cases h : p = 0
{ simp [h] }
simp [h]
rw [degree_eq_nat_degree h, with_bot.coe_lt_coe]
intros
convert derivative_C_mul_X_pow (1 : R) n; simp
convert derivative_C_mul_X_pow (1 : R) n
simp
simp
intros
rw [eval₂_eq_sum, p.sum_over_range' _ _ hn]
intro i
rw [f.map_zero, zero_mul]
intros
rw [eq_neg_iff_add_eq_zero, ←eval₂_add, add_left_neg, eval₂_zero]
intros
simp [hp]
intros
induction n with n hn
{ exact iterated_deriv_zero_right _ }
exact iterated_deriv_zero_right _
{ rw [iterated_deriv_succ, hn, derivative_zero] }
rw [iterated_deriv_succ, hn, derivative_zero]
intros
rw [mirror, mirror, reverse_neg, nat_trailing_degree_neg, neg_mul_eq_neg_mul]
intros
by_cases h : p = 1
{ simpa [h] }
simpa [h]
rw [ne.def, ←degree_eq_bot, hp.degree_mul_comm, hp.degree_mul, with_bot.add_eq_bot, not_or_distrib, degree_eq_bot]
refine ⟨hq, _⟩
rw [←hp.degree_le_zero_iff_eq_one, not_le] at h
refine (lt_trans _ h).ne'
simp
intros
ext u
rw [mem_supp]
split
{ intro h', apply h' _ _ rfl }
intro h'
apply h' _ _ rfl
intros h' a' f' e
rw [←h _ _ _ _ e.symm]
apply h'
intros
have : ((n : ℚ) / d) = rat.mk n d
rw [←rat.mk_eq_div]
rw [←rat.mk_eq_div]
exact rat.num_denom_mk n_ne_zero d_ne_zero this
intros
simpa [-cast_le] using not_congr (@cast_le α _ n m)
intros
simp [ennreal.to_real, ennreal.of_real, real.coe_to_nnreal _ h]
intros
rw [ennreal.to_real, to_nnreal_mul_top, nnreal.coe_zero]
intros
rw [infi_subtype', cinfi_ne_top]
intros
unfold bit1; rw add_eq_top; simp
unfold bit1; rw add_eq_top
unfold bit1
rw add_eq_top
simp
change ((-0 : ℝ) : ereal) = 0
{ change ((-0 : ℝ) : ereal) = 0, simp }
simp
rw [golden_ratio, golden_conj]
{rw [golden_ratio, golden_conj], ring}
ring
pi_upper_bound [ 27720/19601, 56935/30813, 49359/25163, 258754/130003, 113599/56868, 1101994/551163, 8671537/4336095, 3877807/1938940, 52483813/26242030, 56946167/28473117, 23798415/11899211]
intros
rw [sqrt, sqrt, nnreal.coe_le_coe, nnreal.sqrt_le_sqrt_iff]
{ rw [sqrt, sqrt, nnreal.coe_le_coe, nnreal.sqrt_le_sqrt_iff], exact to_nnreal_le_to_nnreal h }
exact to_nnreal_le_to_nnreal h
intros
simp [set.image, function.graph, rel.image]
intros
apply le_antisymm
exact nat.find_min' _ (nat.find_spec ((terminates_def _).1 h))
{ exact nat.find_min' _ (nat.find_spec ((terminates_def _).1 h)) }
have : (option.is_some ((think s).val (length (think s))) : Prop) := nat.find_spec ((terminates_def _).1 s.think_terminates)
{ have : (option.is_some ((think s).val (length (think s))) : Prop) := nat.find_spec ((terminates_def _).1 s.think_terminates), cases length (think s) with n, { contradiction }, { apply nat.succ_le_succ, apply nat.find_min', apply this } }
cases length (think s) with n
{ contradiction }
contradiction
{ apply nat.succ_le_succ, apply nat.find_min', apply this }
apply nat.succ_le_succ
apply nat.find_min'
apply this
intros
apply mem_rec_on h
intros a' s' h
{ intros a' s' h, cases h with h h, { existsi 0, simp [nth], rw h, apply ret_mem }, { cases h with n h, existsi n+1, simp [nth], exact h } }
cases h with h h
{ existsi 0, simp [nth], rw h, apply ret_mem }
existsi 0
simp [nth]
rw h
apply ret_mem
cases h with n h
{ cases h with n h, existsi n+1, simp [nth], exact h }
existsi n+1
simp [nth]
exact h
intros s' h
{ intros s' h, cases h with n h, existsi n, simp [nth], apply think_mem h }
cases h with n h
existsi n
simp [nth]
apply think_mem h
intros
{ ext, simp [image, eq_comm] }
ext
simp [image, eq_comm]
intros
rw [← not_nonempty_iff, ← range_nonempty_iff_nonempty, not_nonempty_iff_eq_empty]
intros
rw [← ne_empty_iff_nonempty, ← h2, ← ne_empty_iff_nonempty, hf.ne_iff]
intros
{ cases x, refl }
cases x
refl
intros
rw [←lt_eq_ssubset, ←finset.lt_iff_ssubset, lt_iff_le_and_ne, lt_iff_le_and_ne]
simp
intros
ext x
rcases em (x ∈ range f) with ⟨a, rfl⟩|hx
rw [mem_preimage, left_inverse_inv_fun hf, hf.mem_set_image]
{ rw [mem_preimage, left_inverse_inv_fun hf, hf.mem_set_image] }
have : x ∉ f '' s
{ have : x ∉ f '' s, from λ h', hx (image_subset_range _ _ h'), simp only [mem_preimage, inv_fun_neg hx, h, this] }
from λ h', hx (image_subset_range _ _ h')
simp only [mem_preimage, inv_fun_neg hx, h, this]
intros
ext1 x
simp_rw [mem_union, mem_Ioo, min_lt_iff, lt_max_iff]
by_cases hc : c < x; by_cases hd : x < d
by_cases hc : c < x
by_cases hd : x < d
{ tauto }
tauto
have hax : a < x := h₂.trans_le (le_of_not_lt hd)
{ have hax : a < x := h₂.trans_le (le_of_not_lt hd), tauto }
tauto
by_cases hd : x < d
have hxb : x < b := (le_of_not_lt hc).trans_lt h₁
{ have hxb : x < b := (le_of_not_lt hc).trans_lt h₁, tauto }
tauto
{ tauto }
tauto
intros
rw [e.image_eq_preimage, e.symm.preimage_Ioc, e.symm_symm]
intros
simp [← Ici_inter_Iic]
intros
simp [le_refl]
intros
simp [← Ioi_inter_Iio, inter_comm]
intros
simp [sub_eq_neg_add]
intros
obtain hab | hab := lt_or_le a b
intros p hp
{ intros p hp, rcases mem_Ioo_or_eq_left_of_mem_Ico hp with hp'|hp', { rw hp', exact ⟨a, left_mem_Ico.mpr hab, rfl⟩ }, { have := surj_on_Ioo_of_monotone_surjective h_mono h_surj a b hp', cases this with x hx, exact ⟨x, Ioo_subset_Ico_self hx.1, hx.2⟩ } }
rcases mem_Ioo_or_eq_left_of_mem_Ico hp with hp'|hp'
rw hp'
{ rw hp', exact ⟨a, left_mem_Ico.mpr hab, rfl⟩ }
exact ⟨a, left_mem_Ico.mpr hab, rfl⟩
have := surj_on_Ioo_of_monotone_surjective h_mono h_surj a b hp'
{ have := surj_on_Ioo_of_monotone_surjective h_mono h_surj a b hp', cases this with x hx, exact ⟨x, Ioo_subset_Ico_self hx.1, hx.2⟩ }
cases this with x hx
exact ⟨x, Ioo_subset_Ico_self hx.1, hx.2⟩
rw Ico_eq_empty (h_mono hab).not_lt
{ rw Ico_eq_empty (h_mono hab).not_lt, exact surj_on_empty f _ }
exact surj_on_empty f _
intros
{ assume x h, rwa interval_of_le, exact le_trans h.1 h.2 }
assume x h
rwa interval_of_le
exact le_trans h.1 h.2
intros
simp only [Union_and, @Union_comm _ ι']
intros
{ subst h, subst h', rw [heq_iff_eq, heq_iff_eq, ext_iff] }
subst h
subst h'
rw [heq_iff_eq, heq_iff_eq, ext_iff]
intros
tidy
intros
have : { i | i ∈ l} = univ
ext i
{ ext i, simp [h] }
simp [h]
rw [← this, ← mk_preimage_tprod, preimage_preimage]
convert preimage_id
simp [tprod.mk_elim hnd h, id_def]
intros
ext i a
induction i
{ cases a, refl }
cases a
refl
{ apply i_ih }
apply i_ih
intros
cases n
{ exact fin_zero_elim i }
exact fin_zero_elim i
induction n with n hn generalizing b
have i0 : i = 0 := by simp only [eq_iff_true_of_subsingleton]
{ have i0 : i = 0 := by simp only [eq_iff_true_of_subsingleton], simpa only [scanl_singleton, i0, nth_zero] }
simpa only [scanl_singleton, i0, nth_zero]
rw [←cons_head_tail v, scanl_cons, nth_cons_succ]
{ rw [←cons_head_tail v, scanl_cons, nth_cons_succ], refine fin.cases _ _ i, { simp only [nth_zero, scanl_head, fin.cast_succ_zero, cons_head] }, { intro i', simp only [hn, fin.cast_succ_fin_succ, nth_cons_succ] } }
refine fin.cases _ _ i
{ simp only [nth_zero, scanl_head, fin.cast_succ_zero, cons_head] }
simp only [nth_zero, scanl_head, fin.cast_succ_zero, cons_head]
intro i'
{ intro i', simp only [hn, fin.cast_succ_fin_succ, nth_cons_succ] }
simp only [hn, fin.cast_succ_fin_succ, nth_cons_succ]
intros
rintros _ ⟨p, hp, q, hq, hq0, rfl⟩; exact hT.div_mem (ring.closure_subset hT.to_is_subring H hp) (ring.closure_subset hT.to_is_subring H hq)
rintros _ ⟨p, hp, q, hq, hq0, rfl⟩
exact hT.div_mem (ring.closure_subset hT.to_is_subring H hp) (ring.closure_subset hT.to_is_subring H hq)
intros
have := (f^n).translation_number_of_eq_add_int h
rwa [translation_number_pow, mul_comm, ← eq_div_iff] at this
exact nat.cast_ne_zero.2 (ne_of_gt hn)
intros
simp_rw [mem_omega_limit_iff_frequently, image_inter_nonempty_iff]
intros
cases le_total n m with h h
refine left_of_add _ hn
{ refine left_of_add _ hn, rwa [nat.sub_add_cancel h] }
rwa [nat.sub_add_cancel h]
rw [nat.sub_eq_zero_of_le h]
{ rw [nat.sub_eq_zero_of_le h], apply is_periodic_pt_zero }
apply is_periodic_pt_zero
intros
rw [← to_subalgebra_eq_iff, ← dim_eq_dim_subalgebra, subalgebra.dim_eq_one_iff, bot_to_subalgebra]
intros
let b := is_noetherian.finset_basis (zmod p) (galois_field p n)
rw [module.card_fintype b, ← finite_dimensional.finrank_eq_card_basis b, zmod.card, finrank p h]
intros
rw [ideal.ne_top_iff_one, span_eval, ideal.span, ← set.image_univ, finsupp.mem_span_image_iff_total]
rintros ⟨v, _, hv⟩
replace hv := congr_arg (to_splitting_field k v.support) hv
rw [alg_hom.map_one, finsupp.total_apply, finsupp.sum, alg_hom.map_sum, finset.sum_eq_zero] at hv
{ exact zero_ne_one hv }
exact zero_ne_one hv
intros j hj
rw [smul_eq_mul, alg_hom.map_mul, to_splitting_field_eval_X_self k hj, mul_zero]
intros
delta minpoly
split_ifs with hx
{ exact (well_founded.min_mem degree_lt_wf _ hx).2 }
exact (well_founded.min_mem degree_lt_wf _ hx).2
{ exact aeval_zero _ }
exact aeval_zero _
intros
refine ⟨λ h, _, norm_add_eq_add_norm_of_angle_eq_zero⟩
rw ← inner_eq_mul_norm_iff_angle_eq_zero hx hy
obtain ⟨hxy₁, hxy₂⟩ := ⟨norm_nonneg (x + y), add_nonneg (norm_nonneg x) (norm_nonneg y)⟩
rw [← sq_eq_sq hxy₁ hxy₂, norm_add_pow_two_real] at h
calc inner x y = ((∥x∥ + ∥y∥) ^ 2 - ∥x∥ ^ 2 - ∥y∥ ^ 2)/ 2 : by linarith ... = ∥x∥ * ∥y∥ : by ring
intros
obtain ⟨-, k₁, _, hab⟩ := angle_eq_pi_iff.mp hapb
obtain ⟨-, k₂, _, hcd⟩ := angle_eq_pi_iff.mp hcpd
exact mul_dist_eq_mul_dist_of_cospherical h ⟨k₁, (by linarith), hab⟩ ⟨k₂, (by linarith), hcd⟩
intros
rw ← lift_prop_on_univ
apply hG.lift_prop_on_of_locally_lift_prop_on (λ x hx, _)
simp [h x]
intros
simp only [mfderiv, h, dif_neg, not_false_iff]
intros
rw ← has_mfderiv_within_at_univ at *
exact has_mfderiv_within_at.comp x (hg.mono (subset_univ _)) hf subset_preimage_univ
intros
rcases u with ⟨⟨x⟩, ⟨y⟩, h₁, h₂⟩
exact H x y (c.eq.1 h₁) (c.eq.1 h₂)
intros
rw [cons_eq_rcons, of_smul_def, equiv_pair_eq_of_fst_idx_ne _]
rw [cons_eq_rcons, of_smul_def, equiv_pair_eq_of_fst_idx_ne _]; simp only [mul_one]
simp only [mul_one]
intros
rw [←mul_one (f y), eq_comm, ←mul_inv_left hf y (f z) 1, h]
rw [←mul_one (f y), eq_comm, ←mul_inv_left hf y (f z) 1, h]; convert units.inv_mul _; exact (is_unit.coe_lift_right (f.mrestrict S) hf _).symm
rw [←mul_one (f y), eq_comm, ←mul_inv_left hf y (f z) 1, h]; convert units.inv_mul _
convert units.inv_mul _
exact (is_unit.coe_lift_right (f.mrestrict S) hf _).symm
intros
split
intros H v
{ intros H v, obtain ⟨z, hz⟩ := H v, obtain ⟨x, hx⟩ := f.surj z, use x, rw [←hz, f.eq_mk'_iff_mul_eq.2 hx, lift_mk', mul_assoc, mul_comm _ (g ↑x.2)], erw [is_unit.mul_lift_right_inv (g.mrestrict S) hg, mul_one] }
obtain ⟨z, hz⟩ := H v
obtain ⟨x, hx⟩ := f.surj z
use x
rw [←hz, f.eq_mk'_iff_mul_eq.2 hx, lift_mk', mul_assoc, mul_comm _ (g ↑x.2)]
erw [is_unit.mul_lift_right_inv (g.mrestrict S) hg, mul_one]
intros H v
{ intros H v, obtain ⟨x, hx⟩ := H v, use f.mk' x.1 x.2, rw [lift_mk', mul_inv_left hg, mul_comm, ←hx] }
obtain ⟨x, hx⟩ := H v
use f.mk' x.1 x.2
rw [lift_mk', mul_inv_left hg, mul_comm, ←hx]
intros
cases (order_of x).zero_le.eq_or_lt with hx hx
{ simp [pow_inj_iff_of_order_of_eq_zero, hx.symm] }
simp [pow_inj_iff_of_order_of_eq_zero, hx.symm]
rw [pow_eq_mod_order_of, @pow_eq_mod_order_of _ _ _ m]
exact ⟨pow_injective_of_lt_order_of _ (nat.mod_lt _ hx) (nat.mod_lt _ hx), λ h, congr_arg _ h⟩
intros
classical
contrapose! hα
simp_rw ← mem_support at hα
exact nat.modeq_zero_iff_dvd.mp ((congr_arg _ (finset.card_eq_zero.mpr (compl_eq_bot.mpr (finset.eq_univ_iff_forall.mpr hα)))).mp (card_compl_support_modeq hσ).symm)
intros
rw [← same_cycle_inv, same_cycle_apply, same_cycle_inv]
intros
ext x
simp only [set.mem_set_of_eq, ne.def]
rw [inv_def, symm_apply_eq, eq_comm]
intros
split
split; intro h
intro h
obtain ⟨x, t, hmem, hins, ht⟩ := card_eq_succ.1 h
{ obtain ⟨x, t, hmem, hins, ht⟩ := card_eq_succ.1 h, obtain ⟨y, rfl⟩ := card_eq_one.1 ht, rw mem_singleton at hmem, refine ⟨x, y, hmem, _⟩, ext a, have key : ∀ b, f b ≠ b ↔ _ := λ b, by rw [←mem_support, ←hins, mem_insert, mem_singleton], by_cases ha : f a = a, { have ha' := not_or_distrib.mp (mt (key a).mpr (not_not.mpr ha)), rw [ha, swap_apply_of_ne_of_ne ha'.1 ha'.2] }, { have ha' := (key (f a)).mp (mt f.apply_eq_iff_eq.mp ha), obtain rfl | rfl := ((key a).mp ha), { rw [or.resolve_left ha' ha, swap_apply_left] }, { rw [or.resolve_right ha' ha, swap_apply_right] } } }
obtain ⟨y, rfl⟩ := card_eq_one.1 ht
rw mem_singleton at hmem
refine ⟨x, y, hmem, _⟩
ext a
have key : ∀ b, f b ≠ b ↔ _ := λ b, by rw [←mem_support, ←hins, mem_insert, mem_singleton]
by_cases ha : f a = a
have ha' := not_or_distrib.mp (mt (key a).mpr (not_not.mpr ha))
{ have ha' := not_or_distrib.mp (mt (key a).mpr (not_not.mpr ha)), rw [ha, swap_apply_of_ne_of_ne ha'.1 ha'.2] }
rw [ha, swap_apply_of_ne_of_ne ha'.1 ha'.2]
have ha' := (key (f a)).mp (mt f.apply_eq_iff_eq.mp ha)
{ have ha' := (key (f a)).mp (mt f.apply_eq_iff_eq.mp ha), obtain rfl | rfl := ((key a).mp ha), { rw [or.resolve_left ha' ha, swap_apply_left] }, { rw [or.resolve_right ha' ha, swap_apply_right] } }
obtain rfl | rfl := ((key a).mp ha)
{ rw [or.resolve_left ha' ha, swap_apply_left] }
rw [or.resolve_left ha' ha, swap_apply_left]
{ rw [or.resolve_right ha' ha, swap_apply_right] }
rw [or.resolve_right ha' ha, swap_apply_right]
intro h
obtain ⟨x, y, hxy, rfl⟩ := h
{ obtain ⟨x, y, hxy, rfl⟩ := h, exact card_support_swap hxy }
exact card_support_swap hxy
intros
simp [right_hom]
intros
rw map_commutator_eq_commutator_map
{ rw map_commutator_eq_commutator_map, exact general_commutator_mono h₁ h₂ }
exact general_commutator_mono h₁ h₂
intros
rw eq_bot_iff
split
{ exact λ h x hx, h ⟨x, hx, rfl⟩ }
exact λ h x hx, h ⟨x, hx, rfl⟩
intros h x hx
{ intros h x hx, obtain ⟨y, hy, rfl⟩ := hx, exact h hy }
obtain ⟨y, hy, rfl⟩ := hx
exact h hy
intros
ext
simp only [coe_inf, set.inf_eq_inter, set.mem_mul, set.mem_inter_iff]
split
rintros ⟨y, z, hy, ⟨hzB, hzC⟩, rfl⟩
{ rintros ⟨y, z, hy, ⟨hzB, hzC⟩, rfl⟩, refine ⟨_, mul_mem C (h hy) hzC⟩, exact ⟨y, z, hy, hzB, rfl⟩ }
refine ⟨_, mul_mem C (h hy) hzC⟩
exact ⟨y, z, hy, hzB, rfl⟩
rintros ⟨⟨y, z, hy, hz, rfl⟩, hyz⟩
refine ⟨y, z, hy, ⟨hz, _⟩, rfl⟩
suffices : y⁻¹ * (y * z) ∈ C
simpa
{ simpa }
exact mul_mem C (inv_mem C (h hy)) hyz
intros
{ rw [← le_bot_iff], exact closure_le _}
rw [← le_bot_iff]
exact closure_le _
intros
rw [line_map_symm p₀, comp_apply]
{ rw [line_map_symm p₀, comp_apply], congr, simp [line_map_apply] }
congr
simp [line_map_apply]
intros
convert (finset.univ.centroid_map k (fs.order_emb_of_fin h).to_embedding s.points).symm
rw [← finset.coe_inj, finset.coe_map, finset.coe_univ, set.image_univ]
simp
intros
ext a
change (equiv_fun_on_fintype (single x m)) a = _
convert _root_.congr_fun (equiv_fun_on_fintype_single x m) a
intros
ext ⟨x, y⟩; simp [prod.zero_eq_mk]
ext ⟨x, y⟩
simp [prod.zero_eq_mk]
intros
induction n with n ih
{ refl, }
refl
simp only [function.comp_app, function.iterate_succ, linear_map.mul_apply, pow_succ, ih]
{ simp only [function.comp_app, function.iterate_succ, linear_map.mul_apply, pow_succ, ih], exact (function.commute.iterate_self _ _ m).symm, }
exact (function.commute.iterate_self _ _ m).symm
intros
nontriviality
subst h
refine (b.repr_apply_eq (λ x i, b.reindex_range.repr x ⟨b i, _⟩) _ _ _ x i).symm
intros x y
{ intros x y, ext i, simp only [pi.add_apply, linear_equiv.map_add, finsupp.coe_add] }
ext i
simp only [pi.add_apply, linear_equiv.map_add, finsupp.coe_add]
intros c x
{ intros c x, ext i, simp only [pi.smul_apply, linear_equiv.map_smul, finsupp.coe_smul] }
ext i
simp only [pi.smul_apply, linear_equiv.map_smul, finsupp.coe_smul]
intros i
{ intros i, ext j, simp only [reindex_range_repr_self], refine @finsupp.single_apply_left _ _ _ _ (λ i, (⟨b i, _⟩ : set.range b)) _ _ _ _, exact λ i j h, b.injective (subtype.mk.inj h) }
ext j
simp only [reindex_range_repr_self]
refine @finsupp.single_apply_left _ _ _ _ (λ i, (⟨b i, _⟩ : set.range b)) _ _ _ _
exact λ i j h, b.injective (subtype.mk.inj h)
intros
simp [b.constr_apply, b.equiv_fun_apply, finsupp.sum_fintype]
intros
ext B x y
{ ext B x y, simp only [congr_apply, linear_equiv.symm_symm], refl }
simp only [congr_apply, linear_equiv.symm_symm]
refl
ext
dsimp only [linear_map.comp_apply, subtype.coe_mk, alg_hom.id_apply, alg_hom.to_linear_map_apply, alg_hom.comp_apply]
rw [to_complex_ι, one_smul, of_complex_I]
intros
rw [basis.det_apply, basis.det_apply, ← f.det_to_matrix e, ← matrix.det_mul, e.to_matrix_eq_to_matrix_constr (f ∘ v), e.to_matrix_eq_to_matrix_constr v, ← to_matrix_comp, e.constr_comp]
{ rw [basis.det_apply, basis.det_apply, ← f.det_to_matrix e, ← matrix.det_mul, e.to_matrix_eq_to_matrix_constr (f ∘ v), e.to_matrix_eq_to_matrix_constr v, ← to_matrix_comp, e.constr_comp] }
intros
have : (⊤ : submodule R M) ≃ₗ[R] M := linear_equiv.of_top ⊤ rfl
rw this.dim_eq
intros
classical
rw [← b.to_dual_to_dual, range_comp, b.to_dual_range, map_top, to_dual_range _]
apply_instance
intros
convert finrank_eq_dim K V
rw h
norm_cast
intros
refine (eq_top_iff.2 $ set_like.le_def.2 $ assume f _, _)
rw [← sum_single f]
exact sum_mem _ (assume a ha, submodule.mem_supr_of_mem a ⟨_, rfl⟩)
intros
simp only [finsupp.total_apply, finsupp.sum, finsupp.on_finset_apply, finsupp.support_on_finset]
rw finset.sum_filter_of_ne
intros x hx h
contrapose! h
simp [h]
intros
rw [linear_independent.repr, linear_equiv.range]
intros
have := classical.dec_eq ι
have := classical.dec_eq ι'
haveI := classical.dec_eq ι''
ext i j
simp only [matrix.mul_apply, basis.to_matrix_apply, basis.sum_repr_mul_repr]
intros
rw [smul_eq_diagonal_mul]
simp [card_univ]
intros
rw [← comap_bot, ← infi_ker_proj, comap_infi]
have := λ i : m, ker_comp (to_lin' (diagonal w)) (proj i)
simp only [comap_infi, ← this, proj_diagonal, ker_smul']
have : univ ⊆ {i : m | w i = 0} ∪ {i : m | w i = 0}ᶜ
rw set.union_compl_self
{ rw set.union_compl_self }
exact (supr_range_std_basis_eq_infi_ker_proj K (λi:m, K) disjoint_compl_right this (finite.of_fintype _)).symm
intros
ext ⟨i, k⟩ ⟨j, k'⟩
rw [smul_left_mul_matrix, alg_hom.commutes, block_diagonal_apply, algebra_map_matrix_apply]
split_ifs with h; simp [h]
split_ifs with h
simp [h]
simp [h]
intros
cases t
ext a b
cases a; cases b
cases a
cases b
by_cases h : a = b; simp [transvection_struct.sum_inl, transvection, h, std_basis_matrix]
by_cases h : a = b
{ by_cases h : a = b; simp [transvection_struct.sum_inl, transvection, h, std_basis_matrix], }
simp [transvection_struct.sum_inl, transvection, h, std_basis_matrix]
simp [transvection_struct.sum_inl, transvection, h, std_basis_matrix]
{ simp [transvection_struct.sum_inl, transvection] }
simp [transvection_struct.sum_inl, transvection]
cases b
{ simp [transvection_struct.sum_inl, transvection] }
simp [transvection_struct.sum_inl, transvection]
by_cases h : a = b; simp [transvection_struct.sum_inl, transvection, h]
by_cases h : a = b
{ by_cases h : a = b; simp [transvection_struct.sum_inl, transvection, h] }
simp [transvection_struct.sum_inl, transvection, h]
simp [transvection_struct.sum_inl, transvection, h]
intros
ext m x
simp only [tail_cons, linear_map.uncurry_left_apply, multilinear_map.curry_left_apply]
rw cons_zero
intros
rw [span_union, prod_eq_sup_map, ← span_image, ← span_image]
intros
rw [←neg_one_smul R y, polar_smul_right, neg_one_mul]
intros
conv_lhs { rw [← fin.cons_self_tail v, vandermonde_cons] }
simp only [fin.tail]
intros
rw [@iff.comm p, and_iff_left_iff_imp]
intros
{funext b, by_cases b = a; simp [update, h]}
funext b
by_cases b = a
by_cases b = a; simp [update, h]
simp [update, h]
simp [update, h]
intros
simp only [nontrivial_iff_exists_ne x, subtype.exists, ne.def, subtype.ext_iff, subtype.coe_mk]
intros
haveI : encodable s := hs.to_encodable
{ haveI : encodable s := hs.to_encodable, simp only [infi_subtype'], exact measurable_infi (λ i, hf i) }
simp only [infi_subtype']
exact measurable_infi (λ i, hf i)
intros
{ rw [comp_eq_mk], apply coe_fn_mk }
rw [comp_eq_mk]
apply coe_fn_mk
intros
simp_rw [filter.eventually_eq, ae_iff, supr_apply]
have h_ss : ae_seq_set hf p ⊆ {a : α | (⨆ (i : ι), ae_seq hf p i a) = ⨆ (i : ι), f i a}
intros x hx
{ intros x hx, congr, exact funext (λ i, ae_seq_eq_fun_of_mem_ae_seq_set hf hx i), }
congr
exact funext (λ i, ae_seq_eq_fun_of_mem_ae_seq_set hf hx i)
exact measure_mono_null (set.compl_subset_compl.mpr h_ss) (measure_compl_ae_seq_set_eq_zero hf hp)
intros
ext1
{ ext1, push_cast, exact condexp_ind_disjoint_union_apply hs ht hμs hμt hst x, }
push_cast
exact condexp_ind_disjoint_union_apply hs ht hμs hμt hst x
intros
rw [sub_eq_add_neg, sub_eq_add_neg, Lp_meas_subgroup_to_Lp_trim_add, Lp_meas_subgroup_to_Lp_trim_neg]
intros
refine limsup_le_limsup_of_le (measure.ae_le_iff_absolutely_continuous.mpr hμν) _ _
is_bounded_default
all_goals { is_bounded_default, }
is_bounded_default
intros
simp [integrable, measurable_const.ae_measurable]
intros
rw [norm_def]
congr' 1
rw lintegral_congr_ae
filter_upwards [Lp.coe_fn_sub f g]
assume a ha
simp only [ha, pi.sub_apply]
intros
simp [hfp.2]
intros
refine le_antisymm (snorm_ess_sup_indicator_const_le s c) _
by_contra h
push_neg at h
have h' := ae_iff.mp (ae_lt_of_ess_sup_lt h)
push_neg at h'
refine hμs (measure_mono_null (λ x hx_mem, _) h')
rw [set.mem_set_of_eq, set.indicator_of_mem hx_mem]
exact le_rfl
intros
rw ← mem_ℒp_one_iff_integrable at hf hi₀ ⊢
exact mem_ℒp_approx_on fmeas hf h₀ hi₀ n
intros
rcases hf with ⟨fs, hT_lt_top, h_approx⟩
let T := λ n, support (fs n)
have hT_meas : ∀ n, measurable_set (T n)
from λ n, simple_func.measurable_set_support (fs n)
let t := ⋃ n, T n
refine ⟨t, measurable_set.Union hT_meas, _, _⟩
have h_fs_zero : ∀ n, ∀ x ∈ tᶜ, fs n x = 0
{ have h_fs_zero : ∀ n, ∀ x ∈ tᶜ, fs n x = 0, { intros n x hxt, rw [set.mem_compl_iff, set.mem_Union, not_exists] at hxt, simpa using (hxt n), }, refine λ x hxt, tendsto_nhds_unique (h_approx x) _, rw funext (λ n, h_fs_zero n x hxt), exact tendsto_const_nhds, }
intros n x hxt
{ intros n x hxt, rw [set.mem_compl_iff, set.mem_Union, not_exists] at hxt, simpa using (hxt n), }
rw [set.mem_compl_iff, set.mem_Union, not_exists] at hxt
simpa using (hxt n)
refine λ x hxt, tendsto_nhds_unique (h_approx x) _
rw funext (λ n, h_fs_zero n x hxt)
exact tendsto_const_nhds
refine ⟨⟨⟨λ n, tᶜ ∪ T n, λ n, trivial, λ n, _, _⟩⟩⟩
{ refine ⟨⟨⟨λ n, tᶜ ∪ T n, λ n, trivial, λ n, _, _⟩⟩⟩, { rw [measure.restrict_apply' (measurable_set.Union hT_meas), set.union_inter_distrib_right, set.compl_inter_self t, set.empty_union], exact (measure_mono (set.inter_subset_left _ _)).trans_lt (hT_lt_top n), }, { rw ← set.union_Union tᶜ T, exact set.compl_union_self _ } }
rw [measure.restrict_apply' (measurable_set.Union hT_meas), set.union_inter_distrib_right, set.compl_inter_self t, set.empty_union]
{ rw [measure.restrict_apply' (measurable_set.Union hT_meas), set.union_inter_distrib_right, set.compl_inter_self t, set.empty_union], exact (measure_mono (set.inter_subset_left _ _)).trans_lt (hT_lt_top n), }
exact (measure_mono (set.inter_subset_left _ _)).trans_lt (hT_lt_top n)
rw ← set.union_Union tᶜ T
{ rw ← set.union_Union tᶜ T, exact set.compl_union_self _ }
exact set.compl_union_self _
intros
simp_rw [(integral_nonneg_of_ae hf).lt_iff_ne, pos_iff_ne_zero, ne.def, @eq_comm ℝ 0, integral_eq_zero_iff_of_nonneg_ae hf hfi, filter.eventually_eq, ae_iff, pi.zero_apply, function.support]
intros
{ ext1 x, rw [weighted_smul_apply, h_zero], simp, }
ext1 x
rw [weighted_smul_apply, h_zero]
simp
intros
simp only [interval_integral, integral_add hf.1 hg.1, integral_add hf.2 hg.2]
{ simp only [interval_integral, integral_add hf.1 hg.1, integral_add hf.2 hg.2], abel }
abel
intros
cases le_or_lt a b with hab hab
have : Icc a b = Icc a a ∪ Ioc a b := (Icc_union_Ioc_eq_Icc le_rfl hab).symm
{ have : Icc a b = Icc a a ∪ Ioc a b := (Icc_union_Ioc_eq_Icc le_rfl hab).symm, rw [this, integrable_on_union], simp [lt_top_iff_ne_top.2 ha] }
rw [this, integrable_on_union]
simp [lt_top_iff_ne_top.2 ha]
{ simp [hab, hab.le] }
simp [hab, hab.le]
intros
have : monotone (λ n, ∫⁻ x, f n x ∂μ) := λ i j hij, lintegral_mono_ae (h_mono.mono $ λ x hx, hx hij)
suffices key : ∫⁻ x, F x ∂μ = ⨆n, ∫⁻ x, f n x ∂μ
rw key
{ rw key, exact tendsto_at_top_supr this }
exact tendsto_at_top_supr this
rw ← lintegral_supr' hf h_mono
refine lintegral_congr_ae _
filter_upwards [h_mono, h_tendsto]
exact λ x hx_mono hx_tendsto, tendsto_nhds_unique hx_tendsto (tendsto_at_top_supr hx_mono)
intros
simp [pos_iff_ne_zero, hf, filter.eventually_eq, ae_iff, function.support]
intros
simp only [f.coe_restrict hs]
intros
{ rw [mul_eq_map₂], exact hf.map₂ hg (zero_mul 0) }
rw [mul_eq_map₂]
exact hf.map₂ hg (zero_mul 0)
intros
rw [set_to_fun_eq hT (hf.add hg), set_to_fun_eq hT hf, set_to_fun_eq hT hg, integrable.to_L1_add, (L1.set_to_L1 hT).map_add]
intros
{ rw sUnion_eq_bUnion, exact measurable_set.bUnion hs h }
rw sUnion_eq_bUnion
exact measurable_set.bUnion hs h
intros
refine induced_outer_measure_preimage _ μ.inner_content_Union_nat μ.inner_content_mono _ (λ s, f.is_open_preimage) _
intros s hs
convert μ.inner_content_comap f h ⟨s, hs⟩
intros
apply div_nonneg; norm_cast; apply zero_le
apply div_nonneg; norm_cast
apply div_nonneg
norm_cast
apply zero_le
norm_cast
apply zero_le
intros
rw @borel_space.measurable_eq X _ _
{ rw @borel_space.measurable_eq X _ _, exact hm.borel_le_caratheodory }
exact hm.borel_le_caratheodory
intros
simp [volume_val]
intros
simp only [count, sum_apply, hs, dirac_apply', ← tsum_subtype s 1, pi.one_apply]
intros
{ ext s, simp [mem_ae_iff, imp_false] }
ext s
simp [mem_ae_iff, imp_false]
intros
rw [← measure.measure_univ_eq_zero, to_measure_apply _ _ measurable_set.univ, outer_measure.coe_zero, pi.zero_apply]
intros
split_ifs; simp [h]
{ split_ifs; simp [h] }
split_ifs
simp [h]
simp [h]
intros
rcases exists_measurable_superset_eq_trim m s with ⟨t, hst, ht, hm⟩
exact ⟨t, hst, ht, h ▸ hm⟩
intros
simp only [infi, mem_Inf, set.forall_range_iff]
intros
obtain ⟨t, ht⟩ := exists_partition_polynomial_aux n hε hb A
exact ⟨t, λ i₀ i₁ hi, (ht i₀ i₁).mp hi⟩
intros
refine congr_arg dioph (set.ext $ λv, _); exact pfun.lift_graph.symm
refine congr_arg dioph (set.ext $ λv, _)
exact pfun.lift_graph.symm
intros
suffices h : ∀ n : ℕ, complex.abs (f n) / complex.abs (↑n ^ w) = complex.abs (f n) / complex.abs (↑n ^ z)
simp [l_series_summable, ← summable_norm_iff, h, complex.norm_eq_abs]
{ simp [l_series_summable, ← summable_norm_iff, h, complex.norm_eq_abs] }
intro n
cases n
simp
{ simp }
apply congr rfl
have h0 : (n.succ : ℂ) ≠ 0
rw [ne.def, nat.cast_eq_zero]
{ rw [ne.def, nat.cast_eq_zero], apply n.succ_ne_zero }
apply n.succ_ne_zero
rw [complex.cpow_def, complex.cpow_def, if_neg h0, if_neg h0, complex.abs_exp_eq_iff_re_eq]
simp only [h, complex.mul_re, mul_eq_mul_left_iff, sub_right_inj]
right
rw [complex.log_im, ← complex.of_real_nat_cast]
exact complex.arg_of_real_of_nonneg (le_of_lt (cast_pos.2 n.succ_pos))
intros
dsimp [ω, ωb]
ext
ext; simp; ring
ext; simp
simp
ring
simp
intros
simp [padic_norm, (show p ≠ 0, by linarith), padic_val_rat.padic_val_rat_self hp]
intros
rw ←(padic_norm_e.neg); simp
rw ←(padic_norm_e.neg)
simp
intros
simp [ext]
intros
rw [inf_comm, inf_inf_sdiff]
intros
rw [sdiff_le_iff, sup_comm, sdiff_le_iff]
intros
rw [is_greatest_univ.upper_bounds_eq, Ici_top]
intros
{ ext x, refl }
ext x
refl
intros
rw [supr_bool_eq, bool.cond_tt, bool.cond_ff]
intros
{ convert h1.supr_comp g, exact (funext h2).symm }
convert h1.supr_comp g
exact (funext h2).symm
intros
rw [← map_coe_Iic_at_bot a, tendsto_map'_iff]
intros
simpa only [mul_comm] using hf.const_mul_at_top hr
intros
erw h.filter_basis.generate ; refl
erw h.filter_basis.generate
refl
intros
simpa only [infi_true] using h.eq_binfi
intros
simp only [filter.frequently, ← not_and_distrib, not_or_distrib, eventually_and]
intros
simp only [ne_bot_iff, ne, map_eq_bot_iff]
intros
simp only [tendsto, iff_self, le_infi_iff]
intros
rw [filter.coprod, comap_principal, comap_principal, sup_principal]
congr
ext x
simp
simp ; tauto
tauto
intros
rw [sup_assoc, sup_assoc, @sup_comm _ _ b]
intros
simp [is_cobounded, subset_def]
intros
rw [inf_comm, sup_comm, ← sup_inf_assoc_of_le y h, inf_comm, sup_comm]
intros
rintro f g h n
induction n with n ih
{ exact h 0 }
exact h 0
{ exact sup_le_sup ih (h _) }
exact sup_le_sup ih (h _)
intros
simp only [←top_sdiff, sdiff_symm_diff, top_inf_eq]
intros
classical
obtain ⟨t, rfl⟩ := S.fg_of_noetherian
refine finset.induction_on t _ _
{ simpa using base }
simpa using base
intros x t hxt h
convert ih _ x h using 1
rw [finset.coe_insert, algebra.adjoin_insert_adjoin]
intros
rcases hR with ⟨ϖ, hϖ, hR⟩
suffices : ∀ {p : R} (hp : irreducible p), associated p ϖ
{ apply associated.trans (this hp) (this hq).symm, }
apply associated.trans (this hp) (this hq).symm
clear hp hq p q
intros p hp
obtain ⟨n, hn⟩ := hR hp.ne_zero
have : irreducible (ϖ ^ n) := hn.symm.irreducible hp
rcases lt_trichotomy n 1 with (H|rfl|H)
obtain rfl : n = 0
{ obtain rfl : n = 0, { clear hn this, revert H n, exact dec_trivial }, simpa only [not_irreducible_one, pow_zero] using this, }
clear hn this
{ clear hn this, revert H n, exact dec_trivial }
revert H n
exact dec_trivial
simpa only [not_irreducible_one, pow_zero] using this
{ simpa only [pow_one] using hn.symm, }
simpa only [pow_one] using hn.symm
obtain ⟨n, rfl⟩ : ∃ k, n = 1 + k + 1 := nat.exists_eq_add_of_lt H
{ obtain ⟨n, rfl⟩ : ∃ k, n = 1 + k + 1 := nat.exists_eq_add_of_lt H, rw pow_succ at this, rcases this.is_unit_or_is_unit rfl with H0|H0, { exact (hϖ.not_unit H0).elim, }, { rw [add_comm, pow_succ] at H0, exact (hϖ.not_unit (is_unit_of_mul_is_unit_left H0)).elim } }
rw pow_succ at this
rcases this.is_unit_or_is_unit rfl with H0|H0
{ exact (hϖ.not_unit H0).elim, }
exact (hϖ.not_unit H0).elim
rw [add_comm, pow_succ] at H0
{ rw [add_comm, pow_succ] at H0, exact (hϖ.not_unit (is_unit_of_mul_is_unit_left H0)).elim }
exact (hϖ.not_unit (is_unit_of_mul_is_unit_left H0)).elim
intros
split
rintro ⟨s, hs⟩
{ rintro ⟨s, hs⟩, use [s, mv_polynomial.aeval coe], intro x, have hrw : (↑s : set A) = (λ (x : A), x ∈ s.val) := rfl, rw [← set.mem_range, ← alg_hom.coe_range, ← adjoin_eq_range, ← hrw, hs], exact set.mem_univ x }
use [s, mv_polynomial.aeval coe]
intro x
have hrw : (↑s : set A) = (λ (x : A), x ∈ s.val) := rfl
rw [← set.mem_range, ← alg_hom.coe_range, ← adjoin_eq_range, ← hrw, hs]
exact set.mem_univ x
rintro ⟨s, ⟨f, hsur⟩⟩
{ rintro ⟨s, ⟨f, hsur⟩⟩, exact finite_type.of_surjective (finite_type.mv_polynomial R {x // x ∈ s}) f hsur }
exact finite_type.of_surjective (finite_type.mv_polynomial R {x // x ∈ s}) f hsur
intros
obtain ⟨S, hS⟩ := h
unfreezingI { obtain ⟨S, hS⟩ := h }
letI : decidable_eq M := classical.dec_eq M
use finset.bUnion S (λ f, f.support)
have : (finset.bUnion S (λ f, f.support) : set M) = ⋃ f ∈ S, (f.support : set M)
{ simp only [finset.set_bUnion_coe, finset.coe_bUnion] }
simp only [finset.set_bUnion_coe, finset.coe_bUnion]
rw [this]
exact support_gen_of_gen' hS
intros
rw div_nonzero hJ'
convert submodule.le_div_iff_mul_le using 1
rw [← coe_mul, coe_le_coe]
intros
ext
{ ext, simp [sub_eq_add_neg] }
simp [sub_eq_add_neg]
intros
split
contrapose! h
unfreezingI { contrapose! h }
{ unfreezingI { contrapose! h }, simp [is_prime_iff, h] }
simp [is_prime_iff, h]
intros x y hxy
{ intros x y hxy, have : (⟨x, 1⟩ : R × S) * ⟨y, 1⟩ ∈ prod I ⊤, { rw [prod.mk_mul_mk, mul_one, mem_prod], exact ⟨hxy, trivial⟩ }, simpa using h.mem_or_mem this }
have : (⟨x, 1⟩ : R × S) * ⟨y, 1⟩ ∈ prod I ⊤
rw [prod.mk_mul_mk, mul_one, mem_prod]
{ rw [prod.mk_mul_mk, mul_one, mem_prod], exact ⟨hxy, trivial⟩ }
exact ⟨hxy, trivial⟩
simpa using h.mem_or_mem this
intros
split
intros h x hx
{ intros h x hx, erw [← h, mem_Inf] at hx, push_neg at hx, exact hx }
erw [← h, mem_Inf] at hx
push_neg at hx
exact hx
refine λ h, le_antisymm (λ x hx, _) le_jacobson
{ refine λ h, le_antisymm (λ x hx, _) le_jacobson, contrapose hx, erw mem_Inf, push_neg, exact h x hx }
contrapose hx
erw mem_Inf
push_neg
exact h x hx
intros
rw [aeval_def, is_scalar_tower.algebra_map_eq R S R', integer_normalization_eval₂_eq_zero _ _ _ hx]
intros
rw [mul_comm, sec_spec]
intros
apply tensor_product.induction_on M
{ simp, }
simp
{ intros a m, simp, }
intros a m
simp
{ intros x y hx hy, simp [alg_hom.map_sum, hx, hy], }
intros x y hx hy
simp [alg_hom.map_sum, hx, hy]
intros
refine classical.by_contradiction (λ hx0, hI.ne_top ((eq_top_iff_one I).2 _))
obtain ⟨y, hy⟩ := hR.mul_inv_cancel hx0
convert I.smul_mem (C y) hx
rw [smul_eq_mul, ← C.map_mul, mul_comm y x, hy, ring_hom.map_one]
intros
simp [bernstein_polynomial, nat.choose_eq_zero_of_lt h]
intros
rw [←map_cyclotomic_int n R, ←map_cyclotomic_int n S]
ext i
simp only [coeff_map, ring_hom.eq_int_cast, ring_hom.map_int_cast]
intros
simp only [dickson, sq]
intros
{ rw support_esymm', exact bUnion_singleton }
rw support_esymm'
exact bUnion_singleton
intros
refine le_of_not_lt (λ hlt, ne_zero _)
let p_coeff : fin (h.dim) → A := λ i, p.coeff i
suffices : ∀ i, p_coeff i = 0
ext i
{ ext i, by_cases hi : i < h.dim, { exact this ⟨i, hi⟩ }, exact coeff_eq_zero_of_nat_degree_lt (lt_of_lt_of_le hlt (le_of_not_gt hi)) }
by_cases hi : i < h.dim
{ exact this ⟨i, hi⟩ }
exact this ⟨i, hi⟩
exact coeff_eq_zero_of_nat_degree_lt (lt_of_lt_of_le hlt (le_of_not_gt hi))
intro i
refine linear_independent_iff'.mp h.basis.linear_independent _ _ _ i (finset.mem_univ _)
rw aeval_eq_sum_range' hlt at root
rw finset.sum_fin_eq_sum_range
convert root
ext i
split_ifs with hi
{ simp_rw [coe_basis, p_coeff, fin.coe_mk] }
simp_rw [coe_basis, p_coeff, fin.coe_mk]
rw [coeff_eq_zero_of_nat_degree_lt (lt_of_lt_of_le hlt (le_of_not_gt hi)), zero_smul]
{ rw [coeff_eq_zero_of_nat_degree_lt (lt_of_lt_of_le hlt (le_of_not_gt hi)), zero_smul] }
intros
erw [coeff, ← h, ← finsupp.unique_single s]
intros
{ ext, simp }
ext
simp
intros
induction k with k ih
{ simp [one_def], }
simp [one_def]
{ simp [pow_succ, ih], }
simp [pow_succ, ih]
intros
rw to_padic_int_comp_from_padic_int
intros
rw [← aeval_eq_bind₁, aeval_zero, constant_coeff_witt_polynomial, ring_hom.map_zero]
intros
rw [out, witt_vector.coeff_mk, dif_pos i.is_lt, fin.eta]
intros
simp only [witt_polynomial, ring_hom.map_sum, constant_coeff_monomial]
rw [sum_eq_zero]
rintro i hi
rw [if_neg]
rw [finsupp.single_eq_zero]
exact ne_of_gt (pow_pos hp.1.pos _)
intros
rw ← quotient.out_eq (f i); exact ⟨⟨λ a, ⟨i, a⟩, λ a b h, eq_of_heq $ by injection h⟩⟩
rw ← quotient.out_eq (f i)
exact ⟨⟨λ a, ⟨i, a⟩, λ a b h, eq_of_heq $ by injection h⟩⟩
intros
rw [one_le_iff_pos, pos_iff_ne_zero]
simp only [aleph, add_zero, aleph'_omega]
intros
convert card_typein_lt c.ord.out.r x _
{ convert card_typein_lt c.ord.out.r x _, rw [mk_ord_out], rw [type_out, mk_ord_out] }
rw [mk_ord_out]
rw [type_out, mk_ord_out]
intros
simp only [le_antisymm_iff, card_le_nat, nat_le_card]
intros
cases n; refl
cases n
refl
refl
intros
rwa add_zero
intros
simp [h₂.symm, h₃.symm, h₁.symm, horner, pow_add, mul_add, mul_comm, mul_left_comm]
simp [h₂.symm, h₃.symm, h₁.symm, horner, pow_add, mul_add, mul_comm, mul_left_comm]; cc
cc
intros
cases t; unfold_wf; linarith
cases t; unfold_wf
cases t
unfold_wf
unfold_wf
linarith
intros
rw [← set.indicator_range_comp, subtype.range_coe, has_sum_subtype_iff_of_support_subset set.support_indicator_subset]
intros
simpa only [sub_add_cancel] using hfg.add hg
intros
simp only [ext_ring_iff, smul_right_apply, one_apply, one_smul]
intros
rw [supr, map_Sup_of_continuous_at_of_monotone Cf Mf fbot, ← range_comp, supr]
intros
simpa only [inv_inv] using @tendsto_inv_nhds_within_Iio _ _ _ _ (a⁻¹)
intros
simp only [continuous_within_at, nhds_within_Icc_eq_nhds_within_Iic h]
intros
rw [@ring_sep_rel α r]; refl
rw [@ring_sep_rel α r]
refl
intros
simp [frontier_prod_eq]
intros
cases le_total x y with h h; field_simp [h, abs_of_nonneg, abs_of_nonpos, mul_two]; abel
cases le_total x y with h h; field_simp [h, abs_of_nonneg, abs_of_nonpos, mul_two]
cases le_total x y with h h
field_simp [h, abs_of_nonneg, abs_of_nonpos, mul_two]
abel
field_simp [h, abs_of_nonneg, abs_of_nonpos, mul_two]
intros
have h' : ∀ (C : ℝ) (x : α), ∥f x∥ ≤ C
intros
{ intros, exfalso, apply h.false, use x, }
exfalso
apply h.false
use x
simp only [norm_eq, h', and_true, implies_true_iff]
exact cInf_Ici
intros
rw [← ite_compl, ite_inter_closure_eq_of_inter_frontier_eq]
{ rw [← ite_compl, ite_inter_closure_eq_of_inter_frontier_eq], rwa [frontier_compl, eq_comm] }
rwa [frontier_compl, eq_comm]
intros
simp only [mem_nhds_subtype_iff_nhds_within, subtype.image_preimage_coe, inter_mem_iff, self_mem_nhds_within, and_true]
intros
ext ⟨⟩
{ ext ⟨⟩, refl }
refl
intros
rw [← preimage_symm, is_open_preimage]
intros
simpa using edist_le_tsum_of_edist_le_of_tendsto d hf ha 0
intros
apply summable_iff_not_tendsto_nat_at_top.2 (λ H, _)
rcases exists_lt_of_tendsto_at_top H 0 c with ⟨n, -, hn⟩
exact lt_irrefl _ (hn.trans_le (h n))
intros
simp only [continuous_at, tendsto_nhds_bot_iff_real, nhds_prod_eq, bot_add_coe]
assume r
rw eventually_prod_iff
refine ⟨λ z, z < ((r - (a + 1): ℝ) : ereal), Iio_mem_nhds (bot_lt_coe _), λ z, z < ((a + 1 : ℝ) : ereal), Iio_mem_nhds (by simp [-coe_add, zero_lt_one]), λ x hx y hy, _⟩
dsimp
convert add_lt_add hx hy
dsimp
ring
intros
simp only [subtype_restr_def, trans_symm_eq_symm_trans_symm]
have openness₁ : is_open (f.target ∩ f.symm ⁻¹' s) := f.preimage_open_of_open_symm s.2
rw [← of_set_trans _ openness₁, ← trans_assoc, ← trans_assoc]
refine eq_on_source.trans' _ (eq_on_source_refl _)
have sets_identity : f.symm.source ∩ (f.target ∩ (f.symm) ⁻¹' s) = f.symm.source ∩ f.symm ⁻¹' s
{ mfld_set_tac }
mfld_set_tac
have openness₂ : is_open (s : set α) := s.2
rw [of_set_trans', sets_identity, ← trans_of_set' _ openness₂, trans_assoc]
refine eq_on_source.trans' (eq_on_source_refl _) _
refine setoid.trans (trans_symm_self s.local_homeomorph_subtype_coe) _
simp only with mfld_simps
intros
simpa only [dist_comm] using tendsto_dist_right_cocompact_at_top x
intros
simpa only [not_iff_not] using dist_eq_zero
intros
rw [← ball_union_sphere, set.union_diff_cancel_right sphere_disjoint_ball.symm]
intros
ext y
simp only [emetric.mem_ball, mem_ball, edist_dist]
exact ennreal.of_real_lt_of_real_iff_of_nonneg dist_nonneg
intros
haveI := hsc.complete_space_coe
rcases hf.exists_fixed_point ⟨x, hxs⟩ hx with ⟨y, hfy, h_tendsto, hle⟩
refine ⟨y, y.2, subtype.ext_iff_val.1 hfy, _, λ n, _⟩
convert (continuous_subtype_coe.tendsto _).comp h_tendsto
{ convert (continuous_subtype_coe.tendsto _).comp h_tendsto, ext n, simp only [(∘), maps_to.iterate_restrict, maps_to.coe_restrict_apply, subtype.coe_mk] }
ext n
simp only [(∘), maps_to.iterate_restrict, maps_to.coe_restrict_apply, subtype.coe_mk]
convert hle n
{ convert hle n, rw [maps_to.iterate_restrict, eq_comm, maps_to.coe_restrict_apply, subtype.coe_mk] }
rw [maps_to.iterate_restrict, eq_comm, maps_to.coe_restrict_apply, subtype.coe_mk]
intros
rw [emetric.ball_eq_empty_iff]
intros
rcases ne with ⟨x, xs⟩
have : inf_edist x ∅ ≤ Hausdorff_edist s ∅ := inf_edist_le_Hausdorff_edist_of_mem xs
simpa using this
intros
simp [Hausdorff_edist_zero_iff_closure_eq_closure.symm, Hausdorff_dist, ennreal.to_real_eq_zero_iff, fin]
intros
rw ← γ.extend_range
simp only [range_subset_iff, set_coe.exists, set_coe.forall]
intros x hx
simp only [has_coe_to_fun.coe, coe_fn, path.truncate, mem_range_self]
intros
simp [lower_semicontinuous_on, lower_semicontinuous, lower_semicontinuous_within_at_univ_iff]
intros
rcases compact_compact_separated (hK.diff hU) (hK.diff hV) (by rwa [diff_inter_diff, diff_eq_empty]) with ⟨O₁, O₂, h1O₁, h1O₂, h2O₁, h2O₂, hO⟩
refine ⟨_, _, hK.diff h1O₁, hK.diff h1O₂, by rwa [diff_subset_comm], by rwa [diff_subset_comm], by rw [← diff_inter, hO, diff_empty]⟩
intros
letI : topological_space α := ⊥ ; exact { inj := ultrafilter_pure_injective, ..dense_inducing_pure }
letI : topological_space α := ⊥
exact { inj := ultrafilter_pure_injective, ..dense_inducing_pure }
intros
ext ⟨x, y⟩
simp_rw [mem_closure_iff_nhds_basis (uniform_space.has_basis_nhds_prod x y), mem_Inter, mem_set_of_eq]
apply forall_congr
intro V
apply forall_congr
rintros ⟨V_in, V_symm⟩
simp_rw [mem_comp_comp V_symm, inter_comm, exists_prop]
exact iff.rfl
intros
split
rintro ⟨⟨h⟩, h'⟩
{ rintro ⟨⟨h⟩, h'⟩, rw [eq_comm, filter.ext_iff] at h, simp [*, subset_def] }
rw [eq_comm, filter.ext_iff] at h
simp [*, subset_def]
rintro ⟨h, h'⟩
{ rintro ⟨h, h'⟩, refine uniform_embedding.mk ⟨_⟩ h, rw [eq_comm, filter.ext_iff], simp [*, subset_def] }
refine uniform_embedding.mk ⟨_⟩ h
rw [eq_comm, filter.ext_iff]
simp [*, subset_def]
intros
rw [interleave_eq s₁ s₂]
refl
intros
rw ← bind_pure_comp_eq_map _ (x.run st)
change (x >>= pure ∘ f).run st = _
simp
intros
cases a; cases b; simp
cases a; cases b
cases a
cases b
simp
simp
cases b
simp
simp
intros
rw [int.add_comm a c, int.add_comm b c]
exact (int.add_lt_add_left h c)
intros
have h := int.add_le_add_left h a
rwa [← int.add_sub_assoc, int.add_comm a c, int.add_sub_cancel] at h
intros
have := congr_arg bodd (mod_add_div n 2)
simp [bnot] at this
rw [show ∀ b, ff && b = ff, by intros; cases b; refl, show ∀ b, bxor b ff = b, by intros; cases b; refl] at this
rw [← this]
cases mod_two_eq_zero_or_one n with h h; rw h; refl
cases mod_two_eq_zero_or_one n with h h; rw h
cases mod_two_eq_zero_or_one n with h h
rw h
refl
rw h
refl
intros
rw [nat.mul_comm, nat.mul_one]
intros
rw [nat.add_comm n k, nat.add_comm m k]
apply nat.add_le_add_left h
intros
tactic.mk_inj_eq
intros
ext
{ ext, simp only [linear_map.id_coe, one_mul, id.def, lmul_left_apply] }
simp only [linear_map.id_coe, one_mul, id.def, lmul_left_apply]
intros
{ ext, simp, }
ext
simp
intros
simp only [sum_eq_multiset_sum, multiset.sum_map_singleton]
intros
classical
let s := {x | p x}.to_finset
rw [← finset.prod_subtype s, ← finset.prod_subtype sᶜ]
{ exact finset.prod_mul_prod_compl _ _ }
exact finset.prod_mul_prod_compl _ _
{ simp }
simp
{ simp }
simp
intros
rw finset.prod_map
exact finset.prod_congr rfl h
intros
haveI := classical.dec_eq α; exact finset.induction_on s (by simp) (λ a s has ih, by rw [prod_insert has, card_insert_of_not_mem has, pow_succ, ih])
haveI := classical.dec_eq α
exact finset.induction_on s (by simp) (λ a s has ih, by rw [prod_insert has, card_insert_of_not_mem has, pow_succ, ih])
intros
rw [finprod_mem_def, finprod_mem_def, mul_indicator_inter_mul_support]
intros
{ classical, rw finprod_mem_finset_product', simp, }
classical
rw finprod_mem_finset_product'
simp
intros
simp only [div_eq_mul_inv, csupr_mul hf]
intros
apply coevaluation_apply_one K V
intros
apply G.mk_eq
obtain ⟨k, f, g, hfg⟩ := h
use [k, f, g]
rw [monoid_hom.map_inv, monoid_hom.map_inv, inv_inj]
exact hfg
intros
simp only [squash_gcf, (squash_seq_nth_of_lt m_lt_n)]
intros
simpa
intros
rcases hu with ⟨u, rfl⟩
{ rcases hu with ⟨u, rfl⟩, apply units.coe_dvd, }
apply units.coe_dvd
intros
simpa using div_sub_div b a one_ne_zero hc
intros
classical
revert h
apply s.induction_on
{ simp }
simp
intros b s bs hi h
rw [gcd_insert, gcd_insert, gcd_comm (f b), ← gcd_assoc, hi (λ x hx, h _ (mem_insert_of_mem hx)), gcd_comm a, gcd_assoc, gcd_comm a (gcd_monoid.gcd _ _), gcd_comm (g b), gcd_assoc _ _ a, gcd_comm _ a]
exact congr_arg _ (gcd_eq_of_dvd_sub_right (h _ (mem_insert_self _ _)))
intros
simp [h.symm]
intros
{ rw [sub_eq_add_neg, sub_eq_add_neg], exact add_left_inj _ }
rw [sub_eq_add_neg, sub_eq_add_neg]
exact add_left_inj _
intros
rw [← sub_eq_add_neg, add_sub_cancel'_right a b]
intros
rintros ⟨⟩ ⟨⟩ h
congr'
congr'; injection h
injection h
injection h
injection h
intros
rw [←units.coe_one, eq_iff]
intros
rw [div_eq_mul_one_div, one_div_div, ← mul_div_assoc]
intros
{ rw C.shape, simpa using i.succ_succ_ne_one.symm }
rw C.shape
simpa using i.succ_succ_ne_one.symm
intros
rw ←kernel_subobject_arrow'
{ rw ←kernel_subobject_arrow', simp [kernel_subobject_arrow_eq_zero_of_exact_zero_left A], }
simp [kernel_subobject_arrow_eq_zero_of_exact_zero_left A]
intros
dsimp [d_from, X_next_iso]
rw c.next_eq_some r
refl
intros
{ dsimp [cycles], simp, }
dsimp [cycles]
simp
intros
dsimp [homology_functor]
apply eq_of_sub_eq_zero
apply eq_of_sub_eq_zero
ext
simp only [homology.π_map, comp_zero, preadditive.comp_sub]
dsimp [kernel_subobject_map]
simp_rw [h.comm i]
simp only [zero_add, zero_comp, d_next_eq_d_from_from_next, kernel_subobject_arrow_comp_assoc, preadditive.comp_add]
rw [←preadditive.sub_comp]
simp only [category_theory.subobject.factor_thru_add_sub_factor_thru_right]
erw [subobject.factor_thru_of_le (D.boundaries_le_cycles i)]
{ simp, }
simp
rw [prev_d_eq_to_prev_d_to, ←category.assoc]
{ rw [prev_d_eq_to_prev_d_to, ←category.assoc], apply image_subobject_factors_comp_self, }
apply image_subobject_factors_comp_self
intros
{ ext, simp }
ext
simp
intros
by_cases hs : a ∈ s; by_cases ht : a ∈ t; simp *
by_cases hs : a ∈ s; by_cases ht : a ∈ t
by_cases hs : a ∈ s
by_cases ht : a ∈ t
simp *
simp *
by_cases ht : a ∈ t
simp *
simp *
intros
rw [←mul_assoc, inv_of_mul_self, one_mul]
intros
simp [sub_eq_add_neg]
intros
ext x
simpa only [lie_subalgebra.mem_normalizer_iff, lie_subalgebra.mem_top, iff_true] using λ y hy, I.lie_mem hy
intros
simp [skew_adjoint_matrices_lie_subalgebra_equiv]
intros
rw [← lie_submodule.coe_to_submodule_eq_iff, I.incl.ker_coe_submodule, lie_submodule.bot_coe_submodule, incl_coe, submodule.ker_subtype]
intros
simp only [zero_root_subalgebra, mem_weight_space, mem_pre_weight_space, pi.zero_apply, sub_zero, set_like.mem_coe, zero_smul, lie_submodule.mem_coe_submodule, submodule.mem_carrier, lie_subalgebra.mem_mk_iff]
intros
{ intros f g h, ext, exact linear_map.congr_fun h x }
intros f g h
ext
exact linear_map.congr_fun h x
intros
rcases x with ⟨x, xm⟩
rcases y with ⟨y, ym⟩
congr
rw (submodule.eq_bot_iff _).mp rfl x xm
rw (submodule.eq_bot_iff _).mp rfl y ym
intros
simp
intros
unfold cmp cmp_using
by_cases a < b; simp [h]
by_cases a < b
simp [h]
simp [h]
by_cases h₂ : b < a; simp [h₂, gt]
by_cases h₂ : b < a
simp [h₂, gt]
simp [h₂, gt]
exact (decidable.lt_or_eq_of_le (le_of_not_gt h₂)).resolve_left h
intros
rwa [lt_div_iff' ha, ← div_eq_mul_one_div, div_lt_one (ha.trans h)]
intros
simp [division_def, mul_nonneg_iff]
intros
simp [div_eq_mul_inv]
intros
rw [div_eq_mul_inv, div_eq_mul_inv, mul_comm b, mul_inv_lt_inv_mul_iff, mul_comm]
exact mul_lt_mul_of_lt_of_lt hab hcd
intros
obtain ⟨c, hc⟩ := le_iff_exists_mul.1 h.le
refine ⟨c, one_lt_iff_ne_one.2 _, hc.symm⟩
rintro rfl
simpa [hc, lt_irrefl] using h
intros
ext x
simp only [mem_smul_set, algebra.id.smul_eq_mul, mem_Iio]
split
rintro ⟨a_w, a_h_left, rfl⟩
{ rintro ⟨a_w, a_h_left, rfl⟩, exact (mul_le_mul_left hr).mpr a_h_left, }
exact (mul_le_mul_left hr).mpr a_h_left
rintro h
{ rintro h, use x / r, split, exact (div_le_iff' hr).mpr h, exact mul_div_cancel' _ (ne_of_gt hr), }
use x / r
split
exact (div_le_iff' hr).mpr h
exact mul_div_cancel' _ (ne_of_gt hr)
intros
have : ∀x, ∃a b : α, a * b = x := λx, ⟨x, ⟨1, mul_one x⟩⟩
simpa only [mem_mul, eq_univ_iff_forall, mem_univ, true_and]
intros
ext x
refine ⟨_, λ h, ⟨x, 1, h, s.one_mem, mul_one x⟩⟩
rintros ⟨a, b, ha, hb, rfl⟩
exact s.mul_mem ha hb
intros
rw [← polynomial.coeff_smul, prod_X_sub_smul.smul]
intros
refine ⟨_, is_right_regular.pow n⟩
rw [← nat.succ_pred_eq_of_pos n0, pow_succ]
exact is_right_regular.of_mul
intros
by_cases h : P; simp [h]
{ by_cases h : P; simp [h], }
by_cases h : P
simp [h]
simp [h]
intros
ext
rcases mk_ring_hom_surjective r x with ⟨x, rfl⟩
exact (ring_hom.congr_fun w x : _)
intros
let S := {s ∈ finset.range (n + 1) | s ∣ n ∧ ∃ x, s = x ^ 2}
have hSne : S.nonempty
use 1
{ use 1, have h1 : 0 < n ∧ ∃ (x : ℕ), 1 = x ^ 2 := ⟨hn, ⟨1, (one_pow 2).symm⟩⟩, simpa [S] }
have h1 : 0 < n ∧ ∃ (x : ℕ), 1 = x ^ 2 := ⟨hn, ⟨1, (one_pow 2).symm⟩⟩
simpa [S]
let s := finset.max' S hSne
have hs : s ∈ S := finset.max'_mem S hSne
simp only [finset.sep_def, S, finset.mem_filter, finset.mem_range] at hs
obtain ⟨hsn1, ⟨a, hsa⟩, ⟨b, hsb⟩⟩ := hs
rw hsa at hn
obtain ⟨hlts, hlta⟩ := canonically_ordered_comm_semiring.mul_pos.mp hn
rw hsb at hsa hn hlts
refine ⟨a, b, hlta, (pow_pos_iff zero_lt_two).mp hlts, hsa.symm, _⟩
rintro x ⟨y, hy⟩
rw nat.is_unit_iff
by_contra hx
refine lt_le_antisymm _ (finset.le_max' S ((b * x) ^ 2) _)
simp_rw [S, hsa, finset.sep_def, finset.mem_filter, finset.mem_range]
{ simp_rw [S, hsa, finset.sep_def, finset.mem_filter, finset.mem_range], refine ⟨lt_succ_iff.mpr (le_of_dvd hn _), _, ⟨b * x, rfl⟩⟩; use y; rw hy; ring }
refine ⟨lt_succ_iff.mpr (le_of_dvd hn _), _, ⟨b * x, rfl⟩⟩
refine ⟨lt_succ_iff.mpr (le_of_dvd hn _), _, ⟨b * x, rfl⟩⟩; use y; rw hy; ring
refine ⟨lt_succ_iff.mpr (le_of_dvd hn _), _, ⟨b * x, rfl⟩⟩; use y; rw hy
refine ⟨lt_succ_iff.mpr (le_of_dvd hn _), _, ⟨b * x, rfl⟩⟩; use y
use y
use y
rw hy
rw hy
ring
ring
use y
use y
rw hy
rw hy
ring
ring
convert lt_mul_of_one_lt_right hlts (one_lt_pow 2 x zero_lt_two (one_lt_iff_ne_zero_and_ne_one.mpr ⟨λ h, by simp * at *, hx⟩))
{ convert lt_mul_of_one_lt_right hlts (one_lt_pow 2 x zero_lt_two (one_lt_iff_ne_zero_and_ne_one.mpr ⟨λ h, by simp * at *, hx⟩)), rw mul_pow }
rw mul_pow
intros
simpa [support_single, hb, hb'] using ne_comm
intros
refine ext (λ x, ⟨λ hx, ⟨⟨map C x.val, (is_prime_map_C_of_is_prime x.property)⟩, ⟨_, _⟩⟩, _⟩)
rw [mem_compl_eq, mem_zero_locus, singleton_subset_iff]
{ rw [mem_compl_eq, mem_zero_locus, singleton_subset_iff], cases hx with i hi, exact λ a, hi (mem_map_C_iff.mp a i) }
cases hx with i hi
exact λ a, hi (mem_map_C_iff.mp a i)
refine subtype.ext (ext (λ x, ⟨λ h, _, λ h, subset_span (mem_image_of_mem C.1 h)⟩))
{ refine subtype.ext (ext (λ x, ⟨λ h, _, λ h, subset_span (mem_image_of_mem C.1 h)⟩)), rw ← @coeff_C_zero R x _, exact mem_map_C_iff.mp h 0 }
rw ← @coeff_C_zero R x _
exact mem_map_C_iff.mp h 0
rintro ⟨xli, complement, rfl⟩
{ rintro ⟨xli, complement, rfl⟩, exact comap_C_mem_image_of_Df complement }
exact comap_C_mem_image_of_Df complement
intros
rw set.eq_empty_iff_forall_not_mem
intros x hx
rw mem_zero_locus at hx
have x_prime : x.as_ideal.is_prime := by apply_instance
have eq_top : x.as_ideal = ⊤
rw ideal.eq_top_iff_one
{ rw ideal.eq_top_iff_one, exact hx h }
exact hx h
apply x_prime.ne_top eq_top
intros
rw [← stalk_map.congr α β h x x rfl, eq_to_hom_refl, category.comp_id]
intros
rw mem_emetric_ball_zero_iff at hx
refine summable_of_nonneg_of_le (λ _, norm_nonneg _) (λ n, ((p n).le_op_norm _).trans_eq _) (p.summable_norm_mul_pow hx)
simp
intros
rw ← change_origin_index_equiv.symm.summable_iff
dsimp only [(∘), change_origin_index_equiv_symm_apply_fst, change_origin_index_equiv_symm_apply_snd_fst]
have : ∀ n : ℕ, has_sum (λ s : finset (fin n), ∥p (n - s.card + s.card)∥₊ * r ^ s.card * r' ^ (n - s.card)) (∥p n∥₊ * (r + r') ^ n)
intro n
{ intro n, convert_to has_sum (λ s : finset (fin n), ∥p n∥₊ * (r ^ s.card * r' ^ (n - s.card))) _, { ext1 s, rw [nat.sub_add_cancel (card_finset_fin_le _), mul_assoc] }, rw ← fin.sum_pow_mul_eq_add_pow, exact (has_sum_fintype _).mul_left _ }
convert_to has_sum (λ s : finset (fin n), ∥p n∥₊ * (r ^ s.card * r' ^ (n - s.card))) _
{ ext1 s, rw [nat.sub_add_cancel (card_finset_fin_le _), mul_assoc] }
ext1 s
rw [nat.sub_add_cancel (card_finset_fin_le _), mul_assoc]
rw ← fin.sum_pow_mul_eq_add_pow
exact (has_sum_fintype _).mul_left _
refine nnreal.summable_sigma.2 ⟨λ n, (this n).summable, _⟩
simp only [(this _).tsum_eq]
exact p.summable_nnnorm_mul_pow hr
intros
have := (hc.has_fderiv_within_at.clm_comp hd.has_fderiv_within_at).has_deriv_within_at
rwa [add_apply, comp_apply, comp_apply, smul_right_apply, smul_right_apply, one_apply, one_smul, one_smul, add_comm] at this
intros
{ unfold deriv_within, rw fderiv_within_of_open hs hx, refl }
unfold deriv_within
rw fderiv_within_of_open hs hx
refl
intros
rcases eq_or_ne y x with rfl|hne
{ exact has_deriv_at_of_has_deriv_at_of_ne f_diff hf hg }
exact has_deriv_at_of_has_deriv_at_of_ne f_diff hf hg
{ exact f_diff y hne }
exact f_diff y hne
intros
simp only [has_fderiv_at_filter, continuous_linear_map.coe_pi]
exact is_o_pi
intros
simpa only [smul_zero, zero_add] using hc.smul (has_fderiv_within_at_const f x s)
intros
{ simp only [has_fderiv_within_at, nhds_within_univ], refl }
simp only [has_fderiv_within_at, nhds_within_univ]
refl
intros
simpa only [implicit_to_local_homeomorph_of_complemented_self] using ((hf.implicit_to_local_homeomorph_of_complemented f f' hf' hker).map_source $ (hf.mem_implicit_to_local_homeomorph_of_complemented_source hf' hker))
intros
rw eventually_iff_exists_mem at *
rcases hff' with ⟨s₁, hs₁, hff'⟩
rcases hgg' with ⟨s₂, hs₂, hgg'⟩
rcases hg' with ⟨s₃, hs₃, hg'⟩
let s := s₁ ∩ s₂ ∩ s₃
have hs : s ∈ at_bot := inter_mem (inter_mem hs₁ hs₂) hs₃
rw mem_at_bot_sets at hs
rcases hs with ⟨l, hl⟩
have hl' : Iio l ⊆ s := λ x hx, hl x (le_of_lt hx)
refine lhopital_zero_at_bot_on_Iio _ _ (λ x hx, hg' x $ (hl' hx).2) hfbot hgbot hdiv
refine lhopital_zero_at_bot_on_Iio _ _ (λ x hx, hg' x $ (hl' hx).2) hfbot hgbot hdiv; intros x hx; apply_assumption; exact (hl' hx).1.1 <|> exact (hl' hx).1.2
refine lhopital_zero_at_bot_on_Iio _ _ (λ x hx, hg' x $ (hl' hx).2) hfbot hgbot hdiv; intros x hx; apply_assumption
refine lhopital_zero_at_bot_on_Iio _ _ (λ x hx, hg' x $ (hl' hx).2) hfbot hgbot hdiv; intros x hx
intros x hx
apply_assumption
exact (hl' hx).1.1
intros x hx
apply_assumption
exact (hl' hx).1.2
exact (hl' hx).1.1
intros
simp [exp_neg_inv_glue, hx]
intros
rw ← h.zero_eq x
{ rw ← h.zero_eq x, symmetry, exact continuous_multilinear_map.uncurry0_curry0 _ }
symmetry
exact continuous_multilinear_map.uncurry0_curry0 _
intros
simpa only [div_eq_mul_inv] using hf.mul times_cont_diff_at_const
intros
rcases h 1 hn with ⟨u, hu, p, H⟩
rcases mem_nhds_within.1 hu with ⟨t, t_open, xt, tu⟩
rw inter_comm at tu
have := ((H.mono tu).differentiable_on (le_refl _)) x ⟨mem_insert x s, xt⟩
exact (differentiable_within_at_inter (is_open.mem_nhds t_open xt)).1 this
intros
split
rintro hz
{ rintro hz, obtain ⟨a, b, ha, hb, hab, rfl⟩ := (convex.mem_Icc h.le).1 (Ioc_subset_Icc_self hz), obtain rfl | hb' := hb.eq_or_lt, { rw add_zero at hab, rw [hab, one_mul, zero_mul, add_zero] at hz, exact (hz.1.ne rfl).elim }, { exact ⟨a, b, ha, hb', hab, rfl⟩ } }
obtain ⟨a, b, ha, hb, hab, rfl⟩ := (convex.mem_Icc h.le).1 (Ioc_subset_Icc_self hz)
obtain rfl | hb' := hb.eq_or_lt
rw add_zero at hab
{ rw add_zero at hab, rw [hab, one_mul, zero_mul, add_zero] at hz, exact (hz.1.ne rfl).elim }
rw [hab, one_mul, zero_mul, add_zero] at hz
exact (hz.1.ne rfl).elim
{ exact ⟨a, b, ha, hb', hab, rfl⟩ }
exact ⟨a, b, ha, hb', hab, rfl⟩
rintro ⟨a, b, ha, hb, hab, rfl⟩
{ rintro ⟨a, b, ha, hb, hab, rfl⟩, obtain rfl | ha' := ha.eq_or_lt, { rw zero_add at hab, rwa [hab, one_mul, zero_mul, zero_add, right_mem_Ioc] }, { exact Ioo_subset_Ioc_self ((convex.mem_Ioo h).2 ⟨a, b, ha', hb, hab, rfl⟩) } }
obtain rfl | ha' := ha.eq_or_lt
rw zero_add at hab
{ rw zero_add at hab, rwa [hab, one_mul, zero_mul, zero_add, right_mem_Ioc] }
rwa [hab, one_mul, zero_mul, zero_add, right_mem_Ioc]
exact Ioo_subset_Ioc_self ((convex.mem_Ioo h).2 ⟨a, b, ha', hb, hab, rfl⟩)
{ exact Ioo_subset_Ioc_self ((convex.mem_Ioo h).2 ⟨a, b, ha', hb, hab, rfl⟩) }
intros
rw [center_mass, sum_singleton, sum_singleton, ← mul_smul, inv_mul_cancel hw, one_smul]
intros
rw [← neg_convex_on_iff, neg_neg f]
intros
rcases hn with ⟨n, rfl⟩
induction n with n ihn
simp
{ simp }
rw [nat.succ_eq_add_one, mul_add, mul_one, bit0, ← add_assoc, finset.prod_range_succ, finset.prod_range_succ, mul_assoc]
refine mul_nonneg ihn _
generalize : (1 + 1) * n = k
cases le_or_lt m k with hmk hmk
have : m ≤ k + 1
{ have : m ≤ k + 1, from hmk.trans (lt_add_one ↑k).le, exact mul_nonneg_of_nonpos_of_nonpos (sub_nonpos.2 hmk) (sub_nonpos.2 this) }
from hmk.trans (lt_add_one ↑k).le
exact mul_nonneg_of_nonpos_of_nonpos (sub_nonpos.2 hmk) (sub_nonpos.2 this)
exact mul_nonneg (sub_nonneg.2 hmk.le) (sub_nonneg.2 hmk)
{ exact mul_nonneg (sub_nonneg.2 hmk.le) (sub_nonneg.2 hmk) }
intros
rw ext_iff
exact ⟨by simp only [of_real_re]; refl, by simp only [inner_self_nonneg_im, of_real_im]⟩
intros
rw [←norm_sq_eq_inner]; exact pow_nonneg (norm_nonneg x) 2
rw [←norm_sq_eq_inner]
exact pow_nonneg (norm_nonneg x) 2
intros
simp only [dist_eq_norm]
{ simp only [dist_eq_norm], exact (hf.sub hg).norm (sub_ne_zero.2 hne) }
exact (hf.sub hg).norm (sub_ne_zero.2 hne)
intros
rw ← add_right_inj (finrank 𝕜 K)
{ rw ← add_right_inj (finrank 𝕜 K), simp [submodule.finrank_add_finrank_orthogonal, h_dim] }
simp [submodule.finrank_add_finrank_orthogonal, h_dim]
intros
rw [dist_eq_norm_vsub V, dist_eq_norm_vsub V, vadd_vsub_vadd_cancel_left]
intros
simpa only [← dist_zero_right] using dist_pi_const a 0
intros
rw [edist_eq_coe_nnnorm_sub, _root_.sub_zero]
intros
rwa [← sub_eq_zero, ← norm_le_zero_iff]
intros
obtain ⟨q, hq⟩ : ∃ q, is_compl p q := p.exists_is_compl
haveI : finite_dimensional 𝕜 q := (p.quotient_equiv_of_is_compl q hq).finite_dimensional
exact closed_complemented_of_closed_compl hq hp q.closed_of_finite_dimensional
intros
simp only [coe_sum, finset.sum_apply]
intros
intros a h
replace h : ∃ y : f.ker, to_compl (y : G) = a
simpa using h
simpa using h
rcases h with ⟨⟨g, g_in : g ∈ f.ker⟩, rfl⟩
rw f.mem_ker at g_in
change f.completion (g : completion G) = 0
simp [normed_group_hom.mem_ker, f.completion_coe g, g_in, completion.coe_zero]
intros
ext
ext; simp
simp
simp
simp
simp
intros
rw div_eq_inv_mul
{ rw div_eq_inv_mul, exact (has_strict_deriv_at_log h₂).has_deriv_at.comp_has_deriv_within_at x h₁ }
exact (has_strict_deriv_at_log h₂).has_deriv_at.comp_has_deriv_within_at x h₁
intros
{ rw exp_log_eq_abs hx.ne', exact abs_of_pos hx }
rw exp_log_eq_abs hx.ne'
exact abs_of_pos hx
intros
simpa using integral_sin_pow_mul_cos_pow_odd 0 1
convert tendsto_rpow_div_mul_add (-(1:ℝ)) _ (0:ℝ) zero_ne_one
{ convert tendsto_rpow_div_mul_add (-(1:ℝ)) _ (0:ℝ) zero_ne_one, ring_nf }
ring_nf
intros
cases x
rcases lt_trichotomy y 0 with Hy|Hy|Hy; rcases lt_trichotomy z 0 with Hz|Hz|Hz; simp [Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos, mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg]
rcases lt_trichotomy y 0 with Hy|Hy|Hy; rcases lt_trichotomy z 0 with Hz|Hz|Hz
rcases lt_trichotomy y 0 with Hy|Hy|Hy
{ rcases lt_trichotomy y 0 with Hy|Hy|Hy; rcases lt_trichotomy z 0 with Hz|Hz|Hz; simp [Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos, mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg] }
rcases lt_trichotomy z 0 with Hz|Hz|Hz
simp [Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos, mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg]
simp [Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos, mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg]
simp [Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos, mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg]
rcases lt_trichotomy z 0 with Hz|Hz|Hz
simp [Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos, mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg]
simp [Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos, mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg]
simp [Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos, mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg]
rcases lt_trichotomy z 0 with Hz|Hz|Hz
simp [Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos, mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg]
simp [Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos, mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg]
simp [Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos, mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg]
by_cases h : x = 0
{ by_cases h : x = 0, { rcases lt_trichotomy y 0 with Hy|Hy|Hy; rcases lt_trichotomy z 0 with Hz|Hz|Hz; simp [h, Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos, mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg] }, { have : x ^ y ≠ 0, by simp [h], simp [coe_rpow_of_ne_zero h, coe_rpow_of_ne_zero this, nnreal.rpow_mul] } }
rcases lt_trichotomy y 0 with Hy|Hy|Hy; rcases lt_trichotomy z 0 with Hz|Hz|Hz; simp [h, Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos, mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg]
rcases lt_trichotomy y 0 with Hy|Hy|Hy; rcases lt_trichotomy z 0 with Hz|Hz|Hz
rcases lt_trichotomy y 0 with Hy|Hy|Hy
{ rcases lt_trichotomy y 0 with Hy|Hy|Hy; rcases lt_trichotomy z 0 with Hz|Hz|Hz; simp [h, Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos, mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg] }
rcases lt_trichotomy z 0 with Hz|Hz|Hz
simp [h, Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos, mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg]
simp [h, Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos, mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg]
simp [h, Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos, mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg]
rcases lt_trichotomy z 0 with Hz|Hz|Hz
simp [h, Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos, mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg]
simp [h, Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos, mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg]
simp [h, Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos, mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg]
rcases lt_trichotomy z 0 with Hz|Hz|Hz
simp [h, Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos, mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg]
simp [h, Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos, mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg]
simp [h, Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos, mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg]
have : x ^ y ≠ 0
{ have : x ^ y ≠ 0, by simp [h], simp [coe_rpow_of_ne_zero h, coe_rpow_of_ne_zero this, nnreal.rpow_mul] }
simp [h]
simp [h]
simp [coe_rpow_of_ne_zero h, coe_rpow_of_ne_zero this, nnreal.rpow_mul]
intros
convert rpow_le_rpow_of_exponent_ge hx1 hx2 hz
{ convert rpow_le_rpow_of_exponent_ge hx1 hx2 hz, exact (rpow_zero x).symm }
exact (rpow_zero x).symm
intros
simpa only [(∘), div_eq_inv_mul, mul_one] using (has_deriv_at_sqrt hx).comp x hf
simp
intros
rw [tan_eq_sin_div_cos, tan_eq_sin_div_cos]
exact div_lt_div (sin_lt_sin_of_lt_of_le_pi_div_two (by linarith) (le_of_lt hy₂) hxy) (cos_le_cos_of_nonneg_of_le_pi hx₁ (by linarith) (le_of_lt hxy)) (sin_nonneg_of_nonneg_of_le_pi (by linarith) (by linarith)) (cos_pos_of_mem_Ioo ⟨by linarith, hy₂⟩)
intros
simp only [sin, div_eq_mul_inv, neg_mul_eq_neg_mul]
convert (((has_strict_deriv_at_id x).mul_const I).cexp.add ((has_strict_deriv_at_id x).neg.mul_const I).cexp).mul_const (2:ℂ)⁻¹
simp only [function.comp, id]
ring
intros
simpa only [mul_zero] using tendsto_const_nhds.mul tendsto_inverse_at_top_nhds_0_nat
intros
rw sub_def
conv_lhs { congr, congr, rw ←category.comp_id a, skip, rw (show 0 = a ≫ (0 : Y ⟶ Y), by simp)}
rw [← prod.comp_lift, category.assoc, lift_σ, category.comp_id]
intros
rw [← equiv.eq_symm_apply]; simp [-hom_equiv_unit]
rw [← equiv.eq_symm_apply]
simp [-hom_equiv_unit]
intros
split
intros Z a b w
replace w := congr_arg (λ k, f ≫ k) w
dsimp at w
rw [←category.assoc, ←category.assoc] at w
exact (cancel_epi _).1 w
intros
{ symmetry, ext, assumption, }
symmetry
ext
assumption
intros
dsimp [limit_obj_iso_limit_comp_evaluation]
rw iso.inv_comp_eq
simp
intros
simp [has_colimit.iso_of_equivalence, is_colimit.cocone_points_iso_of_equivalence_inv]
dsimp
simp
intros
rw [h.hom_lift f, h.hom_lift f']; congr; exact funext w
rw [h.hom_lift f, h.hom_lift f']; congr
rw [h.hom_lift f, h.hom_lift f']
congr
exact funext w
intros
{ rw ← coprod.map_desc, simp }
rw ← coprod.map_desc
simp
intros
tidy
intros
{ ext, simp, }
ext
simp
intros
apply (cancel_mono (λ_ X').hom).1
simp only [assoc, comp_id, iso.inv_hom_id]
rw [left_unitor_naturality, ←category.assoc, iso.inv_hom_id, category.id_comp]
intros
simp [of_components]
intros
apply quotient.induction_on' x
intro f
apply quotient.sound
exact ⟨mono_over.map_id.app f⟩
intros
{ simp [kernel_subobject_iso_comp], }
simp [kernel_subobject_iso_comp]
intros
{ ext, dsimp, simp }
ext
dsimp
simp
intros
{ rw ←not_lt, simp [lt_singleton_iff_mem_lt] }
rw ←not_lt
simp [lt_singleton_iff_mem_lt]
intros
convert finset.order_emb_of_fin_last rfl c.card_boundaries_pos
exact le_antisymm (finset.le_max' _ _ c.last_mem) (fin.le_last _)
intros
{ ext, simp [adj_comm] }
ext
simp [adj_comm]
intros
simp [common_neighbors]
intros
ext x
split
rintro ⟨S, rfl, h⟩
{ rintro ⟨S, rfl, h⟩, refine ⟨S.filter (λ l, ¬list.empty l), by simp, λ y hy, _⟩, rw [list.mem_filter, list.empty_iff_eq_nil] at hy, exact ⟨h y hy.1, hy.2⟩ }
refine ⟨S.filter (λ l, ¬list.empty l), by simp, λ y hy, _⟩
rw [list.mem_filter, list.empty_iff_eq_nil] at hy
exact ⟨h y hy.1, hy.2⟩
rintro ⟨S, hx, h⟩
{ rintro ⟨S, hx, h⟩, exact ⟨S, hx, λ y hy, (h y hy).1⟩ }
exact ⟨S, hx, λ y hy, (h y hy).1⟩
intros
refine (list_blank.cons_head_tail _).symm.trans _
simp only [list_blank.head_map, list_blank.head_cons, list_blank.tail_map, list_blank.tail_cons]
intros
rw [← pure_seq_eq_map, η.preserves_seq]; simp with functor_norm
rw [← pure_seq_eq_map, η.preserves_seq]
simp with functor_norm
intros
delta of_equiv
delta of_equiv; simp
simp
intros
cases v with xs h
ext1
change vector.to_list _ = xs
dsimp [bitvec.to_nat,bits_to_nat]
rw ← list.length_reverse at h
rw [← list.reverse_reverse xs,list.foldl_reverse]
generalize_hyp : xs.reverse = ys at ⊢ h
clear xs
induction ys generalizing n
{ cases h, simp [bitvec.of_nat] }
cases h
simp [bitvec.of_nat]
simp only [←nat.succ_eq_add_one, list.length] at h
{ simp only [←nat.succ_eq_add_one, list.length] at h, subst n, simp only [bitvec.of_nat, vector.to_list_cons, vector.to_list_nil, list.reverse_cons, vector.to_list_append, list.foldr], erw [add_lsb_div_two, to_bool_add_lsb_mod_two], congr, apply ys_ih, refl }
subst n
simp only [bitvec.of_nat, vector.to_list_cons, vector.to_list_nil, list.reverse_cons, vector.to_list_append, list.foldr]
erw [add_lsb_div_two, to_bool_add_lsb_mod_two]
congr
apply ys_ih
refl
intros
cases l with hd tl
{ simpa using h' }
simpa using h'
have hi : i < ([hd].to_buffer.append_list tl).size := by simpa [add_comm] using h
{ have hi : i < ([hd].to_buffer.append_list tl).size := by simpa [add_comm] using h, convert_to ([hd].to_buffer.append_list tl).read ⟨i, hi⟩ = _, cases i, { convert read_append_list_left _ _ _, simp }, { rw list.nth_le, convert read_append_list_right _ _ _, simp [nat.succ_eq_add_one, add_comm] } }
convert_to ([hd].to_buffer.append_list tl).read ⟨i, hi⟩ = _
cases i
convert read_append_list_left _ _ _
{ convert read_append_list_left _ _ _, simp }
simp
rw list.nth_le
{ rw list.nth_le, convert read_append_list_right _ _ _, simp [nat.succ_eq_add_one, add_comm] }
convert read_append_list_right _ _ _
simp [nat.succ_eq_add_one, add_comm]
intros
cases p cb n; simp
cases p cb n
simp
simp
intros
simp_rw [any_char]
split_ifs with h; simp [←not_lt, h, eq_comm]
split_ifs with h
simp [←not_lt, h, eq_comm]
simp [←not_lt, h, eq_comm]
intros
simp [many1, seq_eq_fail]
intros
simp [lt_def]
intros
simp [exp_near]
intros
have h1 : x + 2 * x = 3 * x
ring
ring
rw [← h1, sinh_add x (2 * x)]
simp only [cosh_two_mul, sinh_two_mul]
have h2 : cosh x * (2 * sinh x * cosh x) = 2 * sinh x * cosh x ^ 2
ring
ring
rw [h2, cosh_sq]
ring
intros
rw [← of_real_tan_of_real_re, of_real_im]
intros
rw [mul_comm, I_im _]
intros
{ ext, simp [ite_add_zero] }
ext
simp [ite_add_zero]
intros
{ ext ⟨a, b⟩ : 1, simp }
ext ⟨a, b⟩ : 1
simp
intros
ext
{ ext, refl }
refl
intros
{ convert perm.subtype_congr.right_apply _ _ a.property, simp }
convert perm.subtype_congr.right_apply _ _ a.property
simp
intros
{ cases k, refl, }
cases k
refl
intros
refine ⟨h.target_eq, eq_on_of_left_inv_on_of_right_inv_on e.left_inv_on _ _⟩
refine ⟨h.target_eq, eq_on_of_left_inv_on_of_right_inv_on e.left_inv_on _ _⟩; simp only [symm_source, h.target_eq, h.source_eq, e'.symm_maps_to]
simp only [symm_source, h.target_eq, h.source_eq, e'.symm_maps_to]
exact e'.right_inv_on.congr_right e'.symm_maps_to (h.source_eq ▸ h.eq_on.symm)
simp only [symm_source, h.target_eq, h.source_eq, e'.symm_maps_to]
intros
simp only [succ_above_below _ _ h, cast_lt_cast_succ]
intros
rw [reverse_induction]; simp
rw [reverse_induction]
simp
intros
{ dunfold strong_induction_on, rw strong_induction }
dunfold strong_induction_on
rw strong_induction
intros
simp [finset.nonempty]
intros
{ ext, simp }
ext
simp
intros
rw [← infi_coe, coe_image, infi_image, infi_coe]
intros
refine ⟨congr_arg prod.fst, (λ h, prod.ext h ((add_right_inj q.fst).mp _))⟩
rw mem_antidiagonal at hp hq
rw [hq, ← h, hp]
intros
simp [order_emb_of_fin_apply, max'_eq_sorted_last, h]
intros
ext x
ext x; simp only [equiv_map_domain_apply, coe_zero, pi.zero_apply]
simp only [equiv_map_domain_apply, coe_zero, pi.zero_apply]
intros
refine ⟨λ h, h.symm ▸ ⟨support_single_subset, single_eq_same⟩, _⟩
rintro ⟨h, rfl⟩
ext x
by_cases hx : a = x; simp only [hx, single_eq_same, single_eq_of_ne, ne.def, not_false_iff]
by_cases hx : a = x
simp only [hx, single_eq_same, single_eq_of_ne, ne.def, not_false_iff]
simp only [hx, single_eq_same, single_eq_of_ne, ne.def, not_false_iff]
exact not_mem_support_iff.1 (mt (λ hx, (mem_singleton.1 (h hx)).symm) hx)
intros
ext s
by_cases hs : s = a
{ rw [hs, erase_same, single_eq_of_ne (h.symm)] }
rw [hs, erase_same, single_eq_of_ne (h.symm)]
{ rw [erase_ne hs] }
rw [erase_ne hs]
intros
{ ext, simp [finsupp.single_apply, dfinsupp.single_apply] }
ext
simp [finsupp.single_apply, dfinsupp.single_apply]
intros
{ ext y, simp [eq_or_ne] }
ext y
simp [eq_or_ne]
intros
{ rw ← finset.prod_subtype, simp }
rw ← finset.prod_subtype
simp
intros
rw [foldl, as_list, list.foldl_join, ← array.to_list_foldl]
intros
subst eq; refl
subst eq
refl
intros
lift a to ℕ using ha
lift b to ℕ using hb
norm_cast
intros
rw [← int.coe_nat_mul, nat_abs_mul_self]
intros
rcases nat_abs_eq z with eq | eq; rw eq; simp [coe_nat_dvd]
rcases nat_abs_eq z with eq | eq; rw eq
rcases nat_abs_eq z with eq | eq
rw eq
simp [coe_nat_dvd]
rw eq
simp [coe_nat_dvd]
intros
rw [abs_eq_nat_abs, sign_mul_nat_abs]
intros
rw int.gcd at h ⊢; rwa int.nat_abs_neg
rw int.gcd at h ⊢
rwa int.nat_abs_neg
intros
rw [not_even_iff, odd_iff]
intros
rw ← h; apply take'_left
rw ← h
apply take'_left
intros
rw [split_on_p, split_on_p_aux_nil]
suffices : ∀ xs, join (zip_with (++) (split_on_p_aux' p as xs) ((as.filter p).map(λ x, [x]) ++ [[]])) = xs ++ as
{ rw this, refl }
rw this
refl
induction as; intro; simp! only [split_on_p_aux', append_nil]
induction as; intro
induction as
intro
simp! only [split_on_p_aux', append_nil]
intro
simp! only [split_on_p_aux', append_nil]
split_ifs; simp [zip_with, join, *]
split_ifs
simp [zip_with, join, *]
simp [zip_with, join, *]
intros
induction l with a l IH
refl
{refl}
cases h : f a with b
rw [filter_map_cons_none _ _ h, filter_map_cons_none, IH]
{ rw [filter_map_cons_none _ _ h, filter_map_cons_none, IH], simp only [h, option.none_bind'] }
simp only [h, option.none_bind']
rw filter_map_cons_some _ _ _ h
cases h' : g b with c; [ rw [filter_map_cons_none _ _ h', filter_map_cons_none, IH], rw [filter_map_cons_some _ _ _ h', filter_map_cons_some, IH] ]; simp only [h, h', option.some_bind']
cases h' : g b with c; [ rw [filter_map_cons_none _ _ h', filter_map_cons_none, IH], rw [filter_map_cons_some _ _ _ h', filter_map_cons_some, IH] ]
cases h' : g b with c
rw [filter_map_cons_none _ _ h', filter_map_cons_none, IH]
simp only [h, h', option.some_bind']
rw [filter_map_cons_some _ _ _ h', filter_map_cons_some, IH]
simp only [h, h', option.some_bind']
intros
convert filter_eq_nil.2 (λ _ _, id)
intros
induction s
refl
case list.sublist.slnil { refl }
case list.sublist.cons : l₁ l₂ a s IH { by_cases h : p a; simp [h], exacts [IH.trans (erasep_sublist _), IH.cons _ _ _] }
case list.sublist.cons2 : l₁ l₂ a s IH { by_cases h : p a; simp [h], exacts [s, IH.cons2 _ _ _] }
intros
induction l₁ with x l₁ IH; [exact (zero_mul _).symm, simp only [length, product_cons, length_append, IH, right_distrib, one_mul, length_map, add_comm]]
induction l₁ with x l₁ IH
exact (zero_mul _).symm
simp only [length, product_cons, length_append, IH, right_distrib, one_mul, length_map, add_comm]
intros
cases as; refl
cases as
refl
refl
intros
induction l; [refl, simp only [*, reverse_cons, reverse_append]]; refl
induction l; [refl, simp only [*, reverse_cons, reverse_append]]
induction l
refl
simp only [*, reverse_cons, reverse_append]
refl
intros
cases l
{ cases h, }
cases h
{ simpa }
simpa
intros
cases l; simp [prev, hx]
cases l
simp [prev, hx]
simp [prev, hx]
intros
induction xs with y ys IH
{ simpa using h }
simpa using h
cases ys with z zs
{ simpa using h }
simpa using h
by_cases hx : x = y
{ by_cases hx : x = y, { simp [hx] }, { rw [next_or_cons_of_ne _ _ _ _ hx] at h, simpa [hx] using IH h } }
{ simp [hx] }
simp [hx]
rw [next_or_cons_of_ne _ _ _ _ hx] at h
{ rw [next_or_cons_of_ne _ _ _ _ hx] at h, simpa [hx] using IH h }
simpa [hx] using IH h
intros
rw [mfoldl_with_index, mfoldl_eq_foldl, foldl_with_index_eq_foldl_enum]
intros
dunfold Ico
convert range'_append _ _ _
{ exact (nat.add_sub_of_le hnm).symm }
exact (nat.add_sub_of_le hnm).symm
{ rwa [← nat.add_sub_assoc hnm, nat.sub_add_cancel] }
rwa [← nat.add_sub_assoc hnm, nat.sub_add_cancel]
intros
induction l
case list.nil { simp }
simp
case list.cons : x xs l_ih { by_cases h₁ : x ∈ t₁, { have h₂ : x ∉ t₂ := h h₁, simp * }, by_cases h₂ : x ∈ t₂, { simp only [*, inter_cons_of_not_mem, false_or, mem_append, inter_cons_of_mem, not_false_iff], transitivity, { apply perm.cons _ l_ih, }, change [x] ++ xs ∩ t₁ ++ xs ∩ t₂ ~ xs ∩ t₁ ++ ([x] ++ xs ∩ t₂), rw [← list.append_assoc], solve_by_elim [perm.append_right, perm_append_comm] }, { simp * } }
intros
simp only [enum_eq_zip_range, unzip_zip, length_range]
intros
refine ⟨λ h, _, λ h, by simp [h]⟩
rw [eq_comm, ←is_rotated_nil_iff', ←mem_cyclic_permutations_iff, h, mem_singleton]
intros
rw [sublists_len, ← sublists_len_aux_append]; refl
rw [sublists_len, ← sublists_len_aux_append]
refl
intros
simp only [unzip_eq_map, map_map]; split; refl
simp only [unzip_eq_map, map_map]; split
simp only [unzip_eq_map, map_map]
split
intros
{ ext, apply dot_product_add }
ext
apply dot_product_add
intros
simp [diagonal]
intros
simp [dot_product]
intros
{ ext i j, simp [vec_mul_vec, mul_apply], refl }
ext i j
simp [vec_mul_vec, mul_apply]
refl
intros
refine fin.cases _ _ i; simp
{ refine fin.cases _ _ i; simp }
refine fin.cases _ _ i
simp
simp
intros
{ ext i, refine fin.cases _ _ i; simp [vec_head, vec_tail] }
ext i
refine fin.cases _ _ i
refine fin.cases _ _ i; simp [vec_head, vec_tail]
simp [vec_head, vec_tail]
simp [vec_head, vec_tail]
intros
rw [inter_comm]
revert s
refine multiset.induction_on t (by simp) (λ a t IH s, _)
by_cases a ∈ s
rw [cons_inter_of_pos _ h, sub_cons, add_cons, IH, cons_erase h]
{ rw [cons_inter_of_pos _ h, sub_cons, add_cons, IH, cons_erase h] }
rw [cons_inter_of_neg _ h, sub_cons, erase_of_not_mem h, IH]
{ rw [cons_inter_of_neg _ h, sub_cons, erase_of_not_mem h, IH] }
intros
rw [add_comm, erase_add_left_pos s h, add_comm]
intros
simp [ndinter, h]
intros
{ rw ← comp_eval₂_hom, refl }
rw ← comp_eval₂_hom
refl
intros
ext : 2; simp
{ ext : 2; simp }
ext : 2
simp
simp
intros
simp only [degrees, mv_polynomial.support_map_of_injective _ hf]
intros
split
rintro ⟨k, h1k, h2k⟩ ⟨l, rfl⟩
{ rintro ⟨k, h1k, h2k⟩ ⟨l, rfl⟩, rw [mul_lt_mul_left hn] at h1k h2k, rw [lt_succ_iff, ← not_lt] at h2k, exact h2k h1k }
rw [mul_lt_mul_left hn] at h1k h2k
rw [lt_succ_iff, ← not_lt] at h2k
exact h2k h1k
intro h
{ intro h, rw [dvd_iff_mod_eq_zero, ← ne.def, ← pos_iff_ne_zero] at h, simp only [← mod_add_div m n] {single_pass := tt}, refine ⟨m / n, lt_add_of_pos_left _ h, _⟩, rw [add_comm _ 1, left_distrib, mul_one], exact add_lt_add_right (mod_lt _ hn) _ }
rw [dvd_iff_mod_eq_zero, ← ne.def, ← pos_iff_ne_zero] at h
simp only [← mod_add_div m n] {single_pass := tt}
refine ⟨m / n, lt_add_of_pos_left _ h, _⟩
rw [add_comm _ 1, left_distrib, mul_one]
exact add_lt_add_right (mod_lt _ hn) _
intros
rw [eq_comm, nat.mul_eq_zero]
intros
conv {to_lhs, rw [← one_mul(m)]}
exact decidable.mul_le_mul_of_nonneg_right (nat.succ_le_of_lt h) dec_trivial
intros
set v := lxor a (lxor b c) with hv
have hab : lxor a b = lxor c v
{ rw hv, conv_rhs { rw lxor_comm, simp [lxor_assoc] } }
rw hv
conv_rhs { rw lxor_comm, simp [lxor_assoc] }
have hac : lxor a c = lxor b v
rw hv
{ rw hv, conv_rhs { congr, skip, rw lxor_comm }, rw [←lxor_assoc, ←lxor_assoc, lxor_self, zero_lxor, lxor_comm] }
conv_rhs { congr, skip, rw lxor_comm }
rw [←lxor_assoc, ←lxor_assoc, lxor_self, zero_lxor, lxor_comm]
have hbc : lxor b c = lxor a v
{ simp [hv, ←lxor_assoc] }
simp [hv, ←lxor_assoc]
obtain ⟨i, ⟨hi, hi'⟩⟩ := exists_most_significant_bit h
have : test_bit a i = tt ∨ test_bit b i = tt ∨ test_bit c i = tt
contrapose! hi
{ contrapose! hi, simp only [eq_ff_eq_not_eq_tt, ne, test_bit_lxor] at ⊢ hi, rw [hi.1, hi.2.1, hi.2.2, bxor_ff, bxor_ff] }
simp only [eq_ff_eq_not_eq_tt, ne, test_bit_lxor] at ⊢ hi
rw [hi.1, hi.2.1, hi.2.2, bxor_ff, bxor_ff]
rcases this with h|h|h; [{ left, rw hbc }, { right, left, rw hac }, { right, right, rw hab }]; exact lt_of_test_bit i (by simp [h, hi]) h (λ j hj, by simp [hi' _ hj])
rcases this with h|h|h; [{ left, rw hbc }, { right, left, rw hac }, { right, right, rw hab }]
rcases this with h|h|h
left
rw hbc
exact lt_of_test_bit i (by simp [h, hi]) h (λ j hj, by simp [hi' _ hj])
right
left
rw hac
exact lt_of_test_bit i (by simp [h, hi]) h (λ j hj, by simp [hi' _ hj])
right
right
rw hab
exact lt_of_test_bit i (by simp [h, hi]) h (λ j hj, by simp [hi' _ hj])
intros
{ ext, rw pi.nat_apply }
ext
rw pi.nat_apply
intros
rw [←cast_desc_factorial_two, desc_factorial_eq_factorial_mul_choose, factorial_two, mul_comm, cast_mul, cast_two, eq_div_iff_mul_eq (two_ne_zero' : (2 : K) ≠ 0)]
intros
convert of_digits_lt_base_pow_length' (λ _, digits_lt_base')
rw of_digits_digits (b+2) m
intros
rw pow_succ
exact nat.mul_lt_mul (nat.add_lt_add_right (nat.lt_add_of_pos_right succ_pos') 1) (pow_succ_le_asc_factorial n _) (pow_pos succ_pos' _)
intros
wlog h : m ≤ n using [n m, m n]
exact le_total m n
apply gcd.induction m n
{ apply gcd.induction m n, { simp }, intros m n mpos h, rw ← gcd_rec m n at h, conv_rhs { rw ← mod_add_div' n m }, rwa [gcd_fib_add_mul_self m (n % m) (n / m), gcd_comm (fib m) _] }
{ simp }
simp
intros m n mpos h
rw ← gcd_rec m n at h
conv_rhs { rw ← mod_add_div' n m }
rwa [gcd_fib_add_mul_self m (n % m) (n / m), gcd_comm (fib m) _]
rwa [gcd_comm, gcd_comm (fib m)]
intros
by_cases a_split : (a = 0)
subst a_split
{ subst a_split, rw zero_dvd_iff at dvd, simpa [dvd] using cmn, }
rw zero_dvd_iff at dvd
simpa [dvd] using cmn
rcases dvd with ⟨k, rfl⟩
{ rcases dvd with ⟨k, rfl⟩, rw nat.mul_div_cancel_left _ (nat.pos_of_ne_zero a_split), exact coprime.coprime_mul_left cmn, }
rw nat.mul_div_cancel_left _ (nat.pos_of_ne_zero a_split)
exact coprime.coprime_mul_left cmn
intros
rw [clog, if_neg (λ h : 1 < b ∧ 1 < n, h.2.not_le hn)]
intros
rw [← nat.mul_right_inj hc0, ← @add_left_cancel_iff _ _ ((a + b) % c + a % c + b % c)]
suffices : (a + b) % c + c * ((a + b) / c) + a % c + b % c = a % c + c * (a / c) + (b % c + c * (b / c)) + c * (if c ≤ a % c + b % c then 1 else 0) + (a + b) % c
simpa only [mul_add, add_comm, add_left_comm, add_assoc]
{ simpa only [mul_add, add_comm, add_left_comm, add_assoc] }
rw [mod_add_div, mod_add_div, mod_add_div, mul_ite, add_assoc, add_assoc]
conv_lhs { rw ← add_mod_add_ite }
simp
ac_refl
intros
by_cases h₁ : a < b₁; simp [mkpair, h₁, add_assoc]
by_cases h₁ : a < b₁
simp [mkpair, h₁, add_assoc]
simp [mkpair, lt_trans h₁ h, h]
{ simp [mkpair, lt_trans h₁ h, h], exact mul_self_lt_mul_self h }
exact mul_self_lt_mul_self h
simp [mkpair, h₁, add_assoc]
by_cases h₂ : a < b₂; simp [mkpair, h₂, h]
by_cases h₂ : a < b₂
{ by_cases h₂ : a < b₂; simp [mkpair, h₂, h], simp at h₁, rw [add_comm, add_comm _ a, add_assoc, add_lt_add_iff_left], rwa [add_comm, ← sqrt_lt, sqrt_add_eq], exact le_trans h₁ (nat.le_add_left _ _) }
simp [mkpair, h₂, h]
simp at h₁
rw [add_comm, add_comm _ a, add_assoc, add_lt_add_iff_left]
rwa [add_comm, ← sqrt_lt, sqrt_add_eq]
exact le_trans h₁ (nat.le_add_left _ _)
simp [mkpair, h₂, h]
intros
cases mod_two_eq_zero_or_one n with h h; simp [h]
cases mod_two_eq_zero_or_one n with h h
simp [h]
simp [h]
intros
rw [← not_lt, decidable.iff_not_comm, not_lt, size_le]
intros
induction n with n IH; [exact pp.not_dvd_one.elim h, by { rw pow_succ at h, exact (pp.dvd_mul.1 h).elim id IH } ]
induction n with n IH
exact pp.not_dvd_one.elim h
rw pow_succ at h
rw pow_succ at h
{ rw pow_succ at h, exact (pp.dvd_mul.1 h).elim id IH }
{ rw pow_succ at h, exact (pp.dvd_mul.1 h).elim id IH }
exact (pp.dvd_mul.1 h).elim id IH
exact (pp.dvd_mul.1 h).elim id IH
intros
rcases x with _ | _ | _ | x; simp
{ rcases x with _ | _ | _ | x; simp }
rcases x with _ | _ | _ | x
simp
simp
simp
simp
intros
cases t; [simp, simp [ht.1]]
cases t
simp
simp [ht.1]
intros
cases r; simp [rotate_l, rotate_r, dual_node']; split_ifs; simp [dual_node3_l, dual_node4_l]
cases r; simp [rotate_l, rotate_r, dual_node']; split_ifs
cases r; simp [rotate_l, rotate_r, dual_node']
cases r
simp [rotate_l, rotate_r, dual_node']
simp [rotate_l, rotate_r, dual_node']
split_ifs
simp [dual_node3_l, dual_node4_l]
simp [dual_node3_l, dual_node4_l]
intros
{ congr, exact h }
congr
exact h
intros
dsimp [of_set]; split_ifs; simp *
dsimp [of_set]; split_ifs
dsimp [of_set]
split_ifs
simp *
simp *
intros
induction n with n generalizing i
constructor
cases h : f i with y g
constructor
introv
apply n_ih
intros
ext x
apply bisim' (λ x, true) _ _ _ _ trivial
clear x
intros x _
cases gxeq : g x with a f'
have h₀ : M.dest (f x) = ⟨a, f ∘ f'⟩
{ rw [hyp, gxeq, pfunctor.map_eq] }
rw [hyp, gxeq, pfunctor.map_eq]
have h₁ : M.dest (M.corec g x) = ⟨a, M.corec g ∘ f'⟩
{ rw [dest_corec, gxeq, pfunctor.map_eq], }
rw [dest_corec, gxeq, pfunctor.map_eq]
refine ⟨_, _, _, h₀, h₁, _⟩
intro i
exact ⟨f' i, trivial, rfl, rfl⟩
intros
dsimp [mod, mod_div]
cases (m : ℕ) % (k : ℕ)
{ rw [if_pos rfl], refl }
rw [if_pos rfl]
refl
{ rw [if_neg n.succ_ne_zero], refl }
rw [if_neg n.succ_ne_zero]
refl
intros
rw pnat.dvd_iff
{ rw pnat.dvd_iff, rw nat.dvd_prime pp, simp }
rw nat.dvd_prime pp
simp
intros
apply polynomial.induction_on p
{ intro r, rw eval₂_C, exact φ.commutes r }
intro r
rw eval₂_C
exact φ.commutes r
intros f g ih1 ih2
{ intros f g ih1 ih2, rw [φ.map_add, ih1, ih2, eval₂_add] }
rw [φ.map_add, ih1, ih2, eval₂_add]
intros n r ih
{ intros n r ih, rw [pow_succ', ← mul_assoc, φ.map_mul, eval₂_mul_noncomm (algebra_map R A) _ (λ k, algebra.commutes _ _), eval₂_X, ih] }
rw [pow_succ', ← mul_assoc, φ.map_mul, eval₂_mul_noncomm (algebra_map R A) _ (λ k, algebra.commutes _ _), eval₂_X, ih]
intros
simp [to_finsupp_iso, monomial, monomial_fun]
intros
rcases p
{ rcases p, simp only [C, monomial, monomial_fun, mul_to_finsupp, ring_hom.coe_mk, coeff, add_monoid_algebra.mul_single_zero_apply p a n] }
simp only [C, monomial, monomial_fun, mul_to_finsupp, ring_hom.coe_mk, coeff, add_monoid_algebra.mul_single_zero_apply p a n]
intros
rw [← C_1]; exact degree_C_le
rw [← C_1]
exact degree_C_le
intros
ext (_|n)
simp
{ simp }
rw [coeff_C, if_neg (nat.succ_ne_zero _), coeff_eq_zero_of_degree_lt]
exact h.trans_lt (with_bot.some_lt_some.2 n.succ_pos)
intros
by_cases p0 : p = 0
{ rw [p0, zero_mul] }
rw [p0, zero_mul]
exact nat_degree_mul_C_eq_of_mul_ne_zero (mul_ne_zero (leading_coeff_ne_zero.mpr p0) a0)
{ exact nat_degree_mul_C_eq_of_mul_ne_zero (mul_ne_zero (leading_coeff_ne_zero.mpr p0) a0) }
intros
simp [derivative_apply]
intros
by_cases f0 : f = 0
rw [← fc, f0, erase_lead_zero, support_zero, card_empty]
{ rw [← fc, f0, erase_lead_zero, support_zero, card_empty] }
rw [erase_lead_support, card_erase_of_mem (nat_degree_mem_support_of_nonzero f0), fc]
{ rw [erase_lead_support, card_erase_of_mem (nat_degree_mem_support_of_nonzero f0), fc], exact c.pred_eq_sub_one }
exact c.pred_eq_sub_one
intros
{ rw [eval_eq_sum, sum_over_range], simp }
rw [eval_eq_sum, sum_over_range]
simp
intros
rw [is_root.def, eval_sub, eval_X, eval_C, sub_eq_zero, eq_comm]
intros
simp [h]
intros
induction n with n ih
{ simp only [iterated_deriv_zero_right], }
simp only [iterated_deriv_zero_right]
{ simp only [iterated_deriv_succ, ih, derivative_add] }
simp only [iterated_deriv_succ, ih, derivative_add]
intros
split
{ exact h1 }
exact h1
intros g h fgh
{ intros g h fgh, let k := g * h.mirror, have key : f * f.mirror = k * k.mirror, { rw [fgh, mirror_mul_of_domain, mirror_mul_of_domain, mirror_mirror, mul_assoc, mul_comm h, mul_comm g.mirror, mul_assoc, ←mul_assoc] }, have g_dvd_f : g ∣ f, { rw fgh, exact dvd_mul_right g h }, have h_dvd_f : h ∣ f, { rw fgh, exact dvd_mul_left h g }, have g_dvd_k : g ∣ k, { exact dvd_mul_right g h.mirror }, have h_dvd_k_rev : h ∣ k.mirror, { rw [mirror_mul_of_domain, mirror_mirror], exact dvd_mul_left h g.mirror }, have hk := h2 k key, rcases hk with hk | hk | hk | hk, { exact or.inr (h3 h h_dvd_f (by rwa ← hk)) }, { exact or.inr (h3 h h_dvd_f (by rwa [eq_neg_iff_eq_neg.mp hk, mirror_neg, dvd_neg])) }, { exact or.inl (h3 g g_dvd_f (by rwa ← hk)) }, { exact or.inl (h3 g g_dvd_f (by rwa [eq_neg_iff_eq_neg.mp hk, dvd_neg])) } }
let k := g * h.mirror
have key : f * f.mirror = k * k.mirror
rw [fgh, mirror_mul_of_domain, mirror_mul_of_domain, mirror_mirror, mul_assoc, mul_comm h, mul_comm g.mirror, mul_assoc, ←mul_assoc]
{ rw [fgh, mirror_mul_of_domain, mirror_mul_of_domain, mirror_mirror, mul_assoc, mul_comm h, mul_comm g.mirror, mul_assoc, ←mul_assoc] }
have g_dvd_f : g ∣ f
rw fgh
{ rw fgh, exact dvd_mul_right g h }
exact dvd_mul_right g h
have h_dvd_f : h ∣ f
rw fgh
{ rw fgh, exact dvd_mul_left h g }
exact dvd_mul_left h g
have g_dvd_k : g ∣ k
{ exact dvd_mul_right g h.mirror }
exact dvd_mul_right g h.mirror
have h_dvd_k_rev : h ∣ k.mirror
rw [mirror_mul_of_domain, mirror_mirror]
{ rw [mirror_mul_of_domain, mirror_mirror], exact dvd_mul_left h g.mirror }
exact dvd_mul_left h g.mirror
have hk := h2 k key
rcases hk with hk | hk | hk | hk
{ exact or.inr (h3 h h_dvd_f (by rwa ← hk)) }
exact or.inr (h3 h h_dvd_f (by rwa ← hk))
exact or.inr (h3 h h_dvd_f (by rwa [eq_neg_iff_eq_neg.mp hk, mirror_neg, dvd_neg]))
{ exact or.inr (h3 h h_dvd_f (by rwa [eq_neg_iff_eq_neg.mp hk, mirror_neg, dvd_neg])) }
{ exact or.inl (h3 g g_dvd_f (by rwa ← hk)) }
exact or.inl (h3 g g_dvd_f (by rwa ← hk))
{ exact or.inl (h3 g g_dvd_f (by rwa [eq_neg_iff_eq_neg.mp hk, dvd_neg])) }
exact or.inl (h3 g g_dvd_f (by rwa [eq_neg_iff_eq_neg.mp hk, dvd_neg]))
intros
by_cases hq : q = 0
suffices : 0 < p.nat_degree ↔ p.nat_degree ≠ 0
{ suffices : 0 < p.nat_degree ↔ p.nat_degree ≠ 0, { simpa [hq, ←h.nat_degree_eq_zero_iff_eq_one] }, exact ⟨λ h, h.ne', λ h, lt_of_le_of_ne (nat.zero_le _) h.symm ⟩ }
{ simpa [hq, ←h.nat_degree_eq_zero_iff_eq_one] }
simpa [hq, ←h.nat_degree_eq_zero_iff_eq_one]
exact ⟨λ h, h.ne', λ h, lt_of_le_of_ne (nat.zero_le _) h.symm ⟩
{ simp [h.nat_degree_mul', hq] }
simp [h.nat_degree_mul', hq]
intros
rw [f.nat_degree_eq_reverse_nat_degree_add_nat_trailing_degree, nat.add_sub_cancel]
intros
rw coe_int_eq_of_int; refl
rw coe_int_eq_of_int
refl
intros
rw [← cast_zero, cast_le]
intros
{ rw mul_comm, exact to_real_mul_top _ }
rw mul_comm
exact to_real_mul_top _
intros
simp
linarith [gold_add_gold_conj]
intros
rw [←nnreal.coe_eq, nnreal.coe_sum, real.coe_to_nnreal _ (finset.sum_nonneg hf)]
exact finset.sum_congr rfl (λ x hxs, by rw real.coe_to_nnreal _ (hf x hxs))
intros
rw [← mul_le_mul_left (pos_iff_ne_zero.2 h), mul_inv_cancel h]
intros
rw [sqrt, ← real.le_to_nnreal_iff_coe_le hy, nnreal.sqrt_le_iff, ← real.to_nnreal_mul hy, real.to_nnreal_le_to_nnreal_iff (mul_self_nonneg y), sq]
intros
simp [set.preimage, function.graph, rel.preimage, rel.inv, flip, rel.image]
intros
haveI := h.terminates; exact ⟨think_mem h.mem, by rw [length_think, h.length]⟩
haveI := h.terminates
exact ⟨think_mem h.mem, by rw [length_think, h.length]⟩
intros
rw [←diff_singleton_subset_iff]
intros
rw [← image_union, ← image_univ, ← union_compl_self]
intros
ext y
rcases em (y ∈ range f) with ⟨x, rfl⟩|hx
{ simp [hf.eq_iff] }
simp [hf.eq_iff]
rw [mem_range, not_exists] at hx
{ rw [mem_range, not_exists] at hx, simp [hx] }
simp [hx]
intros
{ ext ⟨x, hx⟩, simp [inclusion] }
ext ⟨x, hx⟩
simp [inclusion]
intros
simp only [subset_def, or_imp_distrib, forall_and_distrib, forall_eq, mem_insert_iff]
intros
{ ext i, simp [piecewise] }
ext i
simp [piecewise]
intros
rw [e.image_eq_preimage, e.symm.preimage_Ico, e.symm_symm]
intros
simp [← Ici_inter_Iio]
intros
simp [le_refl]
intros
simp [add_comm]
intros
simp [sub_eq_neg_add]
intros
convert image_mul_right_Ioo b c h using 1; simp only [mul_comm _ a]
convert image_mul_right_Ioo b c h using 1
{ convert image_mul_right_Ioo b c h using 1; simp only [mul_comm _ a] }
simp only [mul_comm _ a]
simp only [mul_comm _ a]
intros
simp only [Union_and, @Union_comm _ ι]
intros
{ convert setoid.eqv_class_mem H, ext, rw setoid.comm' }
convert setoid.eqv_class_mem H
ext
rw setoid.comm'
intros
tidy
intros
refine funext (λj, j.cases' _ _); intros; refl
refine funext (λj, j.cases' _ _); intros
refine funext (λj, j.cases' _ _)
intros
refl
intros
refl
intros
ext
{ ext, rw [ideal.mem_span_singleton, ring_hom.mem_ker, int.coe_cast_ring_hom, int_coe_zmod_eq_zero_iff_dvd] }
rw [ideal.mem_span_singleton, ring_hom.mem_ker, int.coe_cast_ring_hom, int_coe_zmod_eq_zero_iff_dvd]
intros
rw zmod.val_min_abs_def_pos
split_ifs with h
exact h
{ exact h }
have : (x.val - n : ℤ) ≤ 0
{ rw [sub_nonpos, int.coe_nat_le], exact x.val_le, }
rw [sub_nonpos, int.coe_nat_le]
exact x.val_le
rw [← int.coe_nat_le, int.of_nat_nat_abs_of_nonpos this, neg_sub]
conv_lhs { congr, rw [← nat.mod_add_div n 2, int.coe_nat_add, int.coe_nat_mul, int.coe_nat_bit0, int.coe_nat_one] }
suffices : ((n % 2 : ℕ) + (n / 2) : ℤ) ≤ (val x)
rw ← sub_nonneg at this ⊢
{ rw ← sub_nonneg at this ⊢, apply le_trans this (le_of_eq _), ring_nf, ring }
apply le_trans this (le_of_eq _)
ring_nf
ring
norm_cast
calc (n : ℕ) % 2 + n / 2 ≤ 1 + n / 2 : nat.add_le_add_right (nat.le_of_lt_succ (nat.mod_lt _ dec_trivial)) _ ... ≤ x.val : by { rw add_comm, exact nat.succ_le_of_lt (lt_of_not_ge h) }
intros
rw div_eq_mul_inv
{ rw div_eq_mul_inv, exact hS.to_is_subring.to_is_submonoid.mul_mem hx (hS.inv_mem hy) }
exact hS.to_is_subring.to_is_submonoid.mul_mem hx (hS.inv_mem hy)
intros
simpa only [div_eq_mul_inv] using hs.mul_mem hx (hs.inv_mem hy)
intros
rw [← units_coe, ← coe_pow, ← units.coe_pow, translate_pow, units_coe]
intros
obtain ⟨x, xmem, hx⟩ : ∃ x ∈ Icc (0:ℝ) 1, ∀ y ∈ Icc (0:ℝ) 1, f y - y ≤ f x - x
from is_compact_Icc.exists_forall_ge (nonempty_Icc.2 zero_le_one) (hf.sub continuous_id).continuous_on
refine lt_of_le_of_lt _ (sub_lt_iff_lt_add'.2 $ hz x)
apply translation_number_le_of_le_add
simp only [← sub_le_iff_le_add']
exact f.forall_map_sub_of_Icc (λ a, a ≤ f x - x) hx
intros
simp_rw [mem_omega_limit_iff_frequently, map_cluster_pt_iff, singleton_inter_nonempty, mem_preimage]
intros
rw [← to_subalgebra_eq_iff, ← finrank_eq_finrank_subalgebra, subalgebra.finrank_eq_one_iff, bot_to_subalgebra]
intros
{ ext, refl }
ext
refl
intros
cases field.exists_primitive_element F E with α hα
let iso : F⟮α⟯ ≃ₐ[F] E := { to_fun := λ e, e.val, inv_fun := λ e, ⟨e, by { rw hα, exact intermediate_field.mem_top }⟩, left_inv := λ _, by { ext, refl }, right_inv := λ _, rfl, map_mul' := λ _ _, rfl, map_add' := λ _ _, rfl, commutes' := λ _, rfl }
have H : is_integral F α := is_galois.integral F α
have h_sep : (minpoly F α).separable := is_galois.separable F α
have h_splits : (minpoly F α).splits (algebra_map F E) := is_galois.splits F α
replace h_splits : polynomial.splits (algebra_map F F⟮α⟯) (minpoly F α)
convert polynomial.splits_comp_of_splits (algebra_map F E) iso.symm.to_alg_hom.to_ring_hom h_splits
{ convert polynomial.splits_comp_of_splits (algebra_map F E) iso.symm.to_alg_hom.to_ring_hom h_splits }
rw ← linear_equiv.finrank_eq iso.to_linear_equiv
rw ← intermediate_field.adjoin_simple.card_aut_eq_finrank F E H h_sep h_splits
apply fintype.card_congr
apply equiv.mk (λ ϕ, iso.trans (trans ϕ iso.symm)) (λ ϕ, iso.symm.trans (trans ϕ iso))
intro ϕ
{ intro ϕ, ext1, simp only [trans_apply, apply_symm_apply] }
ext1
simp only [trans_apply, apply_symm_apply]
intro ϕ
{ intro ϕ, ext1, simp only [trans_apply, symm_apply_apply] }
ext1
simp only [trans_apply, symm_apply_apply]
intros
have h : is_integral A x
by_contra h
{ by_contra h, rw [eq_zero h, degree_zero, ←with_bot.coe_one] at hx, exact (ne_of_lt (show ⊥ < ↑1, from with_bot.bot_lt_coe 1) hx) }
rw [eq_zero h, degree_zero, ←with_bot.coe_one] at hx
exact (ne_of_lt (show ⊥ < ↑1, from with_bot.bot_lt_coe 1) hx)
have key := minpoly.aeval A x
rw [eq_X_add_C_of_degree_eq_one hx, (minpoly.monic h).leading_coeff, C_1, one_mul, aeval_add, aeval_C, aeval_X, ←eq_neg_iff_add_eq_zero, ←ring_hom.map_neg] at key
exact ⟨-(minpoly A x).coeff 0, key.symm⟩
intros
apply orthogonal_projection_mem_subspace_orthogonal_complement_eq_zero
intros c hc
rw [← neg_vsub_eq_vsub_rev, inner_neg_right, (orthogonal_projection_vsub_mem_direction_orthogonal s p c hc), neg_zero]
intros
rcases h₁.exists_mem with ⟨t, t_nhd, ht⟩
rw ← hG.lift_prop_within_at_inter' t_nhd at h ⊢
exact hG.lift_prop_within_at_congr h (λ y hy, ht hy.2) hx
intros
simp only [has_mfderiv_within_at, has_mfderiv_at, continuous_within_at_univ] with mfld_simps
intros
rw ← has_mfderiv_within_at_univ at *
exact has_mfderiv_within_at.comp x (hg.mono (subset_univ _)) hf subset_preimage_univ
intros
simp [left_coset, right_coset, (image_comp _ _ _).symm, function.comp, mul_assoc]
intros
simpa only [h₁.left_id, h₁.right_id, h₂.left_id, h₂.right_id] using distrib e₂ e₁ e₁ e₂
intros
cases w with ls h1 h2
induction ls with l ls ih
{ exact h_empty }
exact h_empty
cases l with i m
rw cons_eq_smul
exact h_smul _ _ _ (ih _ _)
intros
rw [←one_mul ↑(_)⁻¹, mul_inv_left, ←H]
intros
split
intros H x y
{ intros H x y, split, { exact f.eq_of_eq hg }, { intro h, rw [←f.lift_eq hg, ←f.lift_eq hg] at h, exact H h }}
split
exact f.eq_of_eq hg
{ exact f.eq_of_eq hg }
intro h
{ intro h, rw [←f.lift_eq hg, ←f.lift_eq hg] at h, exact H h }
rw [←f.lift_eq hg, ←f.lift_eq hg] at h
exact H h
intros H z w h
{ intros H z w h, obtain ⟨x, hx⟩ := f.surj z, obtain ⟨y, hy⟩ := f.surj w, rw [←f.mk'_sec z, ←f.mk'_sec w], exact (mul_inv f.map_units).2 ((H _ _).2 $ (mul_inv hg).1 h) }
obtain ⟨x, hx⟩ := f.surj z
obtain ⟨y, hy⟩ := f.surj w
rw [←f.mk'_sec z, ←f.mk'_sec w]
exact (mul_inv f.map_units).2 ((H _ _).2 $ (mul_inv hg).1 h)
intros
obtain ⟨k, hk, rfl⟩ := nth_le_of_mem hx
rw [next_nth_le _ hl, form_perm_apply_nth_le _ hl]
intros
classical
have h : ∀ b : α, b ∈ σ.supportᶜ ↔ σ b = b := λ b, by rw [finset.mem_compl, mem_support, not_not]
obtain ⟨b, hb1, hb2⟩ := finset.exists_ne_of_one_lt_card (lt_of_lt_of_le hp.out.one_lt (nat.le_of_dvd (finset.card_pos.mpr ⟨a, (h a).mpr ha⟩) (nat.modeq_zero_iff_dvd.mp ((card_compl_support_modeq hσ).trans (nat.modeq_zero_iff_dvd.mpr hα))))) a
exact ⟨b, (h b).mp hb1, hb2⟩
intros
revert f
apply cycle_induction_on _ g
{ simp }
simp
intros σ hσ f hf
{ intros σ hσ f hf, simp only [cycle_factors_finset_eq_singleton_self_iff.mpr hσ, mem_singleton] at hf ⊢, simp [hf] }
simp only [cycle_factors_finset_eq_singleton_self_iff.mpr hσ, mem_singleton] at hf ⊢
simp [hf]
intros σ τ hd hc hσ hτ f
{ intros σ τ hd hc hσ hτ f, simp_rw [hd.cycle_factors_finset_mul_eq_union, mem_union], rintro (hf | hf), { rw [hd.commute.eq, union_comm, union_sdiff_distrib, sdiff_singleton_eq_erase, erase_eq_of_not_mem, mul_assoc, disjoint.cycle_factors_finset_mul_eq_union, hσ hf], { rw mem_cycle_factors_finset_iff at hf, intro x, cases hd.symm x with hx hx, { exact or.inl hx }, { refine or.inr _, by_cases hfx : f x = x, { rw ←hfx, simpa [hx] using hfx.symm }, { rw mul_apply, rw ←hf.right _ (mem_support.mpr hfx) at hx, contradiction } } }, { exact λ H, hd.disjoint_cycle_factors_finset (mem_inter_of_mem hf H) } }, { rw [union_sdiff_distrib, sdiff_singleton_eq_erase, erase_eq_of_not_mem, mul_assoc, disjoint.cycle_factors_finset_mul_eq_union, hτ hf], { rw mem_cycle_factors_finset_iff at hf, intro x, cases hd x with hx hx, { exact or.inl hx }, { refine or.inr _, by_cases hfx : f x = x, { rw ←hfx, simpa [hx] using hfx.symm }, { rw mul_apply, rw ←hf.right _ (mem_support.mpr hfx) at hx, contradiction } } }, { exact λ H, hd.disjoint_cycle_factors_finset (mem_inter_of_mem H hf) } } }
simp_rw [hd.cycle_factors_finset_mul_eq_union, mem_union]
rintro (hf | hf)
rw [hd.commute.eq, union_comm, union_sdiff_distrib, sdiff_singleton_eq_erase, erase_eq_of_not_mem, mul_assoc, disjoint.cycle_factors_finset_mul_eq_union, hσ hf]
{ rw [hd.commute.eq, union_comm, union_sdiff_distrib, sdiff_singleton_eq_erase, erase_eq_of_not_mem, mul_assoc, disjoint.cycle_factors_finset_mul_eq_union, hσ hf], { rw mem_cycle_factors_finset_iff at hf, intro x, cases hd.symm x with hx hx, { exact or.inl hx }, { refine or.inr _, by_cases hfx : f x = x, { rw ←hfx, simpa [hx] using hfx.symm }, { rw mul_apply, rw ←hf.right _ (mem_support.mpr hfx) at hx, contradiction } } }, { exact λ H, hd.disjoint_cycle_factors_finset (mem_inter_of_mem hf H) } }
rw mem_cycle_factors_finset_iff at hf
{ rw mem_cycle_factors_finset_iff at hf, intro x, cases hd.symm x with hx hx, { exact or.inl hx }, { refine or.inr _, by_cases hfx : f x = x, { rw ←hfx, simpa [hx] using hfx.symm }, { rw mul_apply, rw ←hf.right _ (mem_support.mpr hfx) at hx, contradiction } } }
intro x
cases hd.symm x with hx hx
exact or.inl hx
{ exact or.inl hx }
refine or.inr _
{ refine or.inr _, by_cases hfx : f x = x, { rw ←hfx, simpa [hx] using hfx.symm }, { rw mul_apply, rw ←hf.right _ (mem_support.mpr hfx) at hx, contradiction } }
by_cases hfx : f x = x
rw ←hfx
{ rw ←hfx, simpa [hx] using hfx.symm }
simpa [hx] using hfx.symm
rw mul_apply
{ rw mul_apply, rw ←hf.right _ (mem_support.mpr hfx) at hx, contradiction }
rw ←hf.right _ (mem_support.mpr hfx) at hx
contradiction
{ exact λ H, hd.disjoint_cycle_factors_finset (mem_inter_of_mem hf H) }
exact λ H, hd.disjoint_cycle_factors_finset (mem_inter_of_mem hf H)
rw [union_sdiff_distrib, sdiff_singleton_eq_erase, erase_eq_of_not_mem, mul_assoc, disjoint.cycle_factors_finset_mul_eq_union, hτ hf]
{ rw [union_sdiff_distrib, sdiff_singleton_eq_erase, erase_eq_of_not_mem, mul_assoc, disjoint.cycle_factors_finset_mul_eq_union, hτ hf], { rw mem_cycle_factors_finset_iff at hf, intro x, cases hd x with hx hx, { exact or.inl hx }, { refine or.inr _, by_cases hfx : f x = x, { rw ←hfx, simpa [hx] using hfx.symm }, { rw mul_apply, rw ←hf.right _ (mem_support.mpr hfx) at hx, contradiction } } }, { exact λ H, hd.disjoint_cycle_factors_finset (mem_inter_of_mem H hf) } }
rw mem_cycle_factors_finset_iff at hf
{ rw mem_cycle_factors_finset_iff at hf, intro x, cases hd x with hx hx, { exact or.inl hx }, { refine or.inr _, by_cases hfx : f x = x, { rw ←hfx, simpa [hx] using hfx.symm }, { rw mul_apply, rw ←hf.right _ (mem_support.mpr hfx) at hx, contradiction } } }
intro x
cases hd x with hx hx
exact or.inl hx
{ exact or.inl hx }
refine or.inr _
{ refine or.inr _, by_cases hfx : f x = x, { rw ←hfx, simpa [hx] using hfx.symm }, { rw mul_apply, rw ←hf.right _ (mem_support.mpr hfx) at hx, contradiction } }
by_cases hfx : f x = x
rw ←hfx
{ rw ←hfx, simpa [hx] using hfx.symm }
simpa [hx] using hfx.symm
rw mul_apply
{ rw mul_apply, rw ←hf.right _ (mem_support.mpr hfx) at hx, contradiction }
rw ←hf.right _ (mem_support.mpr hfx) at hx
contradiction
{ exact λ H, hd.disjoint_cycle_factors_finset (mem_inter_of_mem H hf) }
exact λ H, hd.disjoint_cycle_factors_finset (mem_inter_of_mem H hf)
intros
obtain ⟨⟨l', hp', hc', hd'⟩, hl⟩ := trunc.exists_rep σ.trunc_cycle_factors
have ht : cycle_factors_finset σ = l'.to_finset
{ rw [cycle_factors_finset, ←hl, trunc.lift_mk] }
rw [cycle_factors_finset, ←hl, trunc.lift_mk]
rw ht
split
intro h
{ intro h, have hn' : l'.nodup := nodup_of_pairwise_disjoint_cycles hc' hd', have hperm : l ~ l' := list.perm_of_nodup_nodup_to_finset_eq hn hn' h.symm, refine ⟨_, _, _⟩, { exact λ _ h, hc' _ (hperm.subset h)}, { rwa list.perm.pairwise_iff disjoint.symmetric hperm }, { rw [←hp', hperm.symm.prod_eq'], refine hd'.imp _, exact λ _ _, disjoint.commute } }
have hn' : l'.nodup := nodup_of_pairwise_disjoint_cycles hc' hd'
have hperm : l ~ l' := list.perm_of_nodup_nodup_to_finset_eq hn hn' h.symm
refine ⟨_, _, _⟩
{ exact λ _ h, hc' _ (hperm.subset h)}
exact λ _ h, hc' _ (hperm.subset h)
{ rwa list.perm.pairwise_iff disjoint.symmetric hperm }
rwa list.perm.pairwise_iff disjoint.symmetric hperm
rw [←hp', hperm.symm.prod_eq']
{ rw [←hp', hperm.symm.prod_eq'], refine hd'.imp _, exact λ _ _, disjoint.commute }
refine hd'.imp _
exact λ _ _, disjoint.commute
rintro ⟨hc, hd, hp⟩
{ rintro ⟨hc, hd, hp⟩, refine list.to_finset_eq_of_perm _ _ _, refine list_cycles_perm_list_cycles _ hc' hc hd' hd, rw [hp, hp'] }
refine list.to_finset_eq_of_perm _ _ _
refine list_cycles_perm_list_cycles _ hc' hc hd' hd
rw [hp, hp']
intros
cases i with i hi
cases i
{ exact (h0 rfl).elim }
exact (h0 rfl).elim
exact is_cycle_fin_rotate.extend_domain _
intros
cases l with y l
{ simp }
simp
induction l with z l IH generalizing x y
{ simp }
simp
specialize IH x z (mt (mem_cons_of_mem y) h)
{ specialize IH x z (mt (mem_cons_of_mem y) h), simp only [not_or_distrib, mem_cons_iff] at h, simp [IH, swap_apply_of_ne_of_ne, h] }
simp only [not_or_distrib, mem_cons_iff] at h
simp [IH, swap_apply_of_ne_of_ne, h]
intros
simp
intros
rw ←finset.card_disjoint_union
congr
{ congr, ext, simp [h.support_mul] }
ext
simp [h.support_mul]
{ simpa using h.disjoint_support }
simpa using h.disjoint_support
intros
rw [map_eq_bot_iff, f.ker_eq_bot_iff.mpr hf, le_bot_iff]
intros
ext
simp only [coe_inf, set.inf_eq_inter, set.mem_mul, set.mem_inter_iff]
split
rintros ⟨y, z, ⟨hyA, hyB⟩, hz, rfl⟩
{ rintros ⟨y, z, ⟨hyA, hyB⟩, hz, rfl⟩, refine ⟨mul_mem A hyA (h hz), _⟩, exact ⟨y, z, hyB, hz, rfl⟩ }
refine ⟨mul_mem A hyA (h hz), _⟩
exact ⟨y, z, hyB, hz, rfl⟩
rintros ⟨hyz, y, z, hy, hz, rfl⟩
refine ⟨y, z, ⟨_, hy⟩, hz, rfl⟩
suffices : (y * z) * z⁻¹ ∈ A
simpa
{ simpa }
exact mul_mem A hyz (inv_mem A (h hz))
intros
rw [← neg_vsub_eq_vsub_rev, line_map_vsub_left, ← smul_neg, neg_vsub_eq_vsub_rev]
intros
rintros p ⟨p1, hp1, v, hv, hp⟩
rw hp
have hp1s1 : p1 ∈ (s1 : set P) := set.mem_of_mem_of_subset hp1 h
refine vadd_mem_of_mem_direction _ hp1s1
have hs : vector_span k s ≤ s1.direction := vector_span_mono k h
rw set_like.le_def at hs
rw ←set_like.mem_coe
exact set.mem_of_mem_of_subset hv hs
intros
rw [←vadd_eq_add, affine_map.map_vadd, affine_combination_linear]
intros
split
intro h
{ intro h, rw [finset.centroid_eq_affine_combination_fintype, finset.centroid_eq_affine_combination_fintype] at h, have ha := (affine_independent_iff_indicator_eq_of_affine_combination_eq k s.points).1 s.independent _ _ _ _ (fs₁.sum_centroid_weights_indicator_eq_one_of_card_eq_add_one k h₁) (fs₂.sum_centroid_weights_indicator_eq_one_of_card_eq_add_one k h₂) h, simp_rw [finset.coe_univ, set.indicator_univ, function.funext_iff, finset.centroid_weights_indicator_def, finset.centroid_weights, h₁, h₂] at ha, ext i, replace ha := ha i, split, all_goals { intro hi, by_contradiction hni, simp [hi, hni] at ha, norm_cast at ha } }
rw [finset.centroid_eq_affine_combination_fintype, finset.centroid_eq_affine_combination_fintype] at h
have ha := (affine_independent_iff_indicator_eq_of_affine_combination_eq k s.points).1 s.independent _ _ _ _ (fs₁.sum_centroid_weights_indicator_eq_one_of_card_eq_add_one k h₁) (fs₂.sum_centroid_weights_indicator_eq_one_of_card_eq_add_one k h₂) h
simp_rw [finset.coe_univ, set.indicator_univ, function.funext_iff, finset.centroid_weights_indicator_def, finset.centroid_weights, h₁, h₂] at ha
ext i
replace ha := ha i
split
all_goals { intro hi, by_contradiction hni, simp [hi, hni] at ha, norm_cast at ha }
intro hi
by_contradiction hni
simp [hi, hni] at ha
norm_cast at ha
intro hi
by_contradiction hni
simp [hi, hni] at ha
norm_cast at ha
intro h
{ intro h, have hm : m₁ = m₂, { subst h, simpa [h₁] using h₂ }, subst hm, congr, exact h }
have hm : m₁ = m₂
subst h
{ subst h, simpa [h₁] using h₂ }
simpa [h₁] using h₂
subst hm
congr
exact h
intros
field_simp [sub_ne_zero.2 h.symm, ← sub_div_sub_smul_slope_add_sub_div_sub_smul_slope f a b c, line_map_apply_module]
intros
{ rw [span_le, comap_coe], exact preimage_mono (subset_span), }
rw [span_le, comap_coe]
exact preimage_mono (subset_span)
intros
have : disjoint ⊤ f.ker
rw [disjoint_ker, ← map_zero f]
rw [disjoint_ker, ← map_zero f]
{ rw [disjoint_ker, ← map_zero f], exact λ x hx H, hf H }
{ rw [disjoint_ker, ← map_zero f], exact λ x hx H, hf H }
exact λ x hx H, hf H
exact λ x hx H, hf H
simpa [disjoint]
intros
{ ext, refl }
ext
refl
intros
rw [← nat.sub_add_cancel hk, pow_add, mul_apply, hm, map_zero]
intros
ext y
simp_rw [mem_orthogonal_iff, linear_map.mem_ker, submodule.mem_span_singleton ]
split
{ exact λ h, h x ⟨1, one_smul _ _⟩ }
exact λ h, h x ⟨1, one_smul _ _⟩
rintro h _ ⟨z, rfl⟩
{ rintro h _ ⟨z, rfl⟩, rw [is_ortho, smul_left, mul_eq_zero], exact or.intro_right _ h }
rw [is_ortho, smul_left, mul_eq_zero]
exact or.intro_right _ h
intros
induction x using clifford_algebra.induction
case h_grade0 : r { exact reverse.commutes _}
rw [reverse_ι]
case h_grade1 : x { rw [reverse_ι] }
case h_mul : x₁ x₂ hx₁ hx₂ { rw [reverse.map_mul, mul_comm, hx₁, hx₂] }
case h_add : x₁ x₂ hx₁ hx₂ { rw [reverse.map_add, hx₁, hx₂] }
intros
rw [basis.det_apply, basis.to_matrix_reindex', det_reindex_alg_equiv, basis.det_apply]
intros
rw [linear_map.range_eq_top.2 h, dim_top]
intros
haveI := classical.dec_eq ι
{ haveI := classical.dec_eq ι, rw [← coe_dual_basis, total_dual_basis] }
rw [← coe_dual_basis, total_dual_basis]
intros
rw ← @finrank_top K V at lt
exact lt_of_le_of_finrank_lt_finrank le_top lt
intros
by_cases h_cases: m < finrank K V
rw [←nat.add_sub_of_le (nat.le_of_lt h_cases), add_comm, pow_add]
{ rw [←nat.add_sub_of_le (nat.le_of_lt h_cases), add_comm, pow_add], apply linear_map.ker_le_ker_comp }
apply linear_map.ker_le_ker_comp
rw [ker_pow_eq_ker_pow_finrank_of_le (le_of_not_lt h_cases)]
{ rw [ker_pow_eq_ker_pow_finrank_of_le (le_of_not_lt h_cases)], exact le_refl _ }
exact le_refl _
intros
refine disjoint.mono (lsingle_range_le_ker_lapply _ _ $ disjoint_compl_right) (lsingle_range_le_ker_lapply _ _ $ disjoint_compl_right) (le_trans (le_infi $ assume i, _) infi_ker_lapply_le_bot)
classical
by_cases his : i ∈ s
by_cases hit : i ∈ t
{ by_cases hit : i ∈ t, { exact (hs ⟨his, hit⟩).elim }, exact inf_le_of_right_le (infi_le_of_le i $ infi_le _ hit) }
{ exact (hs ⟨his, hit⟩).elim }
exact (hs ⟨his, hit⟩).elim
exact inf_le_of_right_le (infi_le_of_le i $ infi_le _ hit)
exact inf_le_of_left_le (infi_le_of_le i $ infi_le _ his)
intros
rw [basis, ← coe_eval_ring_hom, (eval_ring_hom y).map_prod, coe_eval_ring_hom, finset.prod_eq_zero (finset.mem_erase.2 ⟨h2, h1⟩)]
simp_rw [eval_mul, eval_sub, eval_C, eval_X, sub_self, mul_zero]
intros
apply hv.repr_eq
simp [finsupp.total_single, hx]
intros
rw [basis.to_matrix_mul_to_matrix, basis.to_matrix_self]
intros
have h := finite_field.matrix.charpoly_pow_card M
{ have h := finite_field.matrix.charpoly_pow_card M, rwa zmod.card at h, }
rwa zmod.card at h
intros
dsimp only [mem_set_of_eq]
rw [← map_top, ← supr_range_std_basis, map_supr]
congr
funext i
rw [← linear_map.range_comp, diagonal_comp_std_basis, ← range_smul']
intros
rw [←nat.sub_add_cancel h, pow_add, mul_eq_mul, matrix.mul_assoc, mul_nonsing_inv, nat.sub_add_cancel h, matrix.mul_one]
simpa using ha.pow n
intros
rw [smul_left_mul_matrix_algebra_map, block_diagonal_apply_eq]
intros
induction L with t L IH
{ simp }
simp
simp [matrix.mul_assoc, IH, to_matrix_sum_inl, from_blocks_multiply]
{ simp [matrix.mul_assoc, IH, to_matrix_sum_inl, from_blocks_multiply], }
intros
{ ext m, simp, }
ext m
simp
intros
simp only [lift_aux, lift_add_hom, tprod, multilinear_map.coe_mk, tprod_coeff, free_add_monoid.lift_eval_of, one_smul, add_con.lift_mk']
intros
rw [ker, ← prod_bot, comap_prod_prod]; refl
rw [ker, ← prod_bot, comap_prod_prod]
refl
intros
ext
ext; refl
refl
intros
rw [sub_eq_add_neg, sub_eq_add_neg, polar_add_right, polar_neg_right]
intros
rw [←range_le_ker_iff, submodule.ker_mkq, submodule.range_subtype]
intros
simp only [vandermonde_apply, matrix.mul_apply, matrix.transpose_apply, mul_pow]
intros
rw [and_comm, iff_self_and]
intros
{ rw forall_swap, simp }
rw forall_swap
simp
intros
{ unfold extend, congr }
unfold extend
congr
intros
fsplit
rintro ⟨S, ⟨f⟩⟩
{ rintro ⟨S, ⟨f⟩⟩, exact small.mk' (e.symm.trans f), }
exact small.mk' (e.symm.trans f)
rintro ⟨S, ⟨f⟩⟩
{ rintro ⟨S, ⟨f⟩⟩, exact small.mk' (e.trans f), }
exact small.mk' (e.trans f)
intros
rcases h with ⟨S, hSo, hSc, rfl⟩
exact measurable_set.sInter hSc (λ t ht, (hSo t ht).measurable_set)
intros
haveI : encodable s := hs.to_encodable
simp only [infi_subtype']
exact ae_measurable_infi (λ i, hf i)
intros
have : (s.singular_part μ).to_jordan_decomposition = ⟨s.to_jordan_decomposition.pos_part.singular_part μ, s.to_jordan_decomposition.neg_part.singular_part μ, singular_part_mutually_singular s μ⟩
refine jordan_decomposition.to_signed_measure_injective _
{ refine jordan_decomposition.to_signed_measure_injective _, rw to_signed_measure_to_jordan_decomposition, refl }
rw to_signed_measure_to_jordan_decomposition
refl
{ rw [total_variation, this] }
rw [total_variation, this]
intros
simp only [← pair_mk_mk, mk_coe_fn]
intros
have h_ss : ae_seq_set hf p ⊆ {x | ∀ i, f i x = (hf i).mk (f i) x}
rw [ae_seq_set, ←compl_compl {x | ∀ i, f i x = (hf i).mk (f i) x}, set.compl_subset_compl]
{ rw [ae_seq_set, ←compl_compl {x | ∀ i, f i x = (hf i).mk (f i) x}, set.compl_subset_compl], refine set.subset.trans (set.compl_subset_compl.mpr (λ x h, _)) (subset_to_measurable _ _), exact h.1, }
refine set.subset.trans (set.compl_subset_compl.mpr (λ x h, _)) (subset_to_measurable _ _)
exact h.1
exact (h_ss hx i).symm
intros
ext1
refine eventually_eq.trans _ indicator_const_Lp_coe_fn.symm
refine (condexp_ind_ae_eq_condexp_ind_smul hm (hm s hs) hμs c).trans _
refine (condexp_ind_smul_ae_eq_smul hm (hm s hs) hμs c).trans _
rw [Lp_meas_coe, condexp_L2_indicator_of_measurable hm hs hμs (1 : ℝ)]
refine (@indicator_const_Lp_coe_fn α _ _ 2 μ _ _ s (hm s hs) hμs (1 : ℝ) _ _).mono (λ x hx, _)
dsimp only
rw hx
by_cases hx_mem : x ∈ s; simp [hx_mem]
by_cases hx_mem : x ∈ s
simp [hx_mem]
simp [hx_mem]
intros
refine liminf_le_liminf_of_le (measure.ae_le_iff_absolutely_continuous.mpr hμν) _ _
is_bounded_default
all_goals { is_bounded_default, }
is_bounded_default
intros
simp_rw [of_real_norm_eq_lintegral, ← edist_eq_coe_nnnorm]
apply lintegral_congr_ae
filter_upwards [Lp.coe_fn_sub f g]
assume a ha
simp only [ha, pi.sub_apply]
intros
refine snorm_mono_ae (eventually_of_forall (λ x, _))
suffices : ∥s.indicator f x∥₊ ≤ ∥f x∥₊
{ exact nnreal.coe_mono this }
exact nnreal.coe_mono this
rw nnnorm_indicator_eq_indicator_nnnorm
exact s.indicator_le_self _ x
intros
rw [snorm_exponent_top, snorm_ess_sup]
refine ess_sup_congr_ae (h_lim.mono (λ x hx, _))
rw tendsto.liminf_eq
rw ennreal.tendsto_coe
exact (continuous_nnnorm.tendsto (f_lim x)).comp hx
intros
rw [snorm', lintegral_const, ennreal.mul_rpow_of_nonneg _ _ (by simp [hq_pos.le] : 0 ≤ 1 / q)]
congr
rw ←ennreal.rpow_mul
suffices hq_cancel : q * (1/q) = 1
rw [hq_cancel, ennreal.rpow_one]
rw [hq_cancel, ennreal.rpow_one]
rw [one_div, mul_inv_cancel (ne_of_lt hq_pos).symm]
intros
simp only [snorm, snorm', ennreal.one_to_real, ennreal.rpow_one, Lp.norm_def, if_false, ennreal.one_ne_top, one_ne_zero, _root_.div_one]
rw integral_eq_lintegral_of_nonneg_ae (eventually_of_forall (by simp [norm_nonneg])) (continuous_norm.measurable.comp_ae_measurable (Lp.ae_measurable f))
simp [of_real_norm_eq_coe_nnnorm]
intros
simp only [integral_symm b]
{ simp only [integral_symm b], exact (integral_has_deriv_within_at_of_tendsto_ae_right hf.symm hmeas ha).neg }
exact (integral_has_deriv_within_at_of_tendsto_ae_right hf.symm hmeas ha).neg
intros
{ simp only [interval_integral, integral_neg], abel }
simp only [interval_integral, integral_neg]
abel
intros
rw [← finset.mem_coe, coe_range, coe_restrict _ hs, mem_range_indicator]
intros
rw [integral_const, measure.restrict_apply_univ]
intros
by_cases hf : integrable f μ
rw [set_to_fun_eq hT hf, set_to_fun_eq hT hf.neg, integrable.to_L1_neg, (L1.set_to_L1 hT).map_neg]
{ rw [set_to_fun_eq hT hf, set_to_fun_eq hT hf.neg, integrable.to_L1_neg, (L1.set_to_L1 hT).map_neg], }
rw [set_to_fun_undef hT hf, set_to_fun_undef hT, neg_zero]
{ rw [set_to_fun_undef hT hf, set_to_fun_undef hT, neg_zero], rwa [← integrable_neg_iff] at hf, }
rwa [← integrable_neg_iff] at hf
intros
by_cases p; simp [h, hf, measurable_set.empty]
{ by_cases p; simp [h, hf, measurable_set.empty] }
by_cases p
simp [h, hf, measurable_set.empty]
simp [h, hf, measurable_set.empty]
intros
rcases exists_compact_superset hK with ⟨F, h1F, h2F⟩
calc μ.outer_measure K ≤ μ.outer_measure (interior F) : outer_measure.mono' _ h2F ... ≤ μ ⟨F, h1F⟩ : by apply μ.outer_measure_le ⟨interior F, is_open_interior⟩ ⟨F, h1F⟩ interior_subset ... < ⊤ : μ.lt_top _
intros
simp only [haar_product, pi, forall_prop_of_true, mem_univ, mem_set_of_eq]
intros
have h : g - f =ᵐ[μ.restrict s] (λ x, real.to_nnreal (g x - f x))
from hfg.mono (λ x hx, (real.coe_to_nnreal _ $ sub_nonneg.2 hx).symm)
rw [volume_region_between_eq_lintegral f_int.ae_measurable g_int.ae_measurable hs, integral_congr_ae h, lintegral_congr_ae, lintegral_coe_eq_integral _ ((integrable_congr h).mp (g_int.sub f_int))]
simpa only
intros
simp [filter.eventually_eq]
intros
simp [measure.trim]
intros
choose t hst ht hμt using λ i, (μ i).exists_measurable_superset_eq_trim s
replace hst := subset_Inter hst
replace ht := measurable_set.Inter ht
refine ⟨⋂ i, t i, hst, ht, λ i, le_antisymm _ _⟩
exacts [hμt i ▸ (μ i).mono (Inter_subset _ _), (mono' _ hst).trans_eq ((μ i).trim_eq ht)]
intros
simp only [bind_on_support_apply, ennreal.coe_tsum (bind_on_support.summable p f b), dite_cast, ennreal.coe_mul, ennreal.coe_zero]
intros
simp only [infi, coe_Inf, set.bInter_range]
intros
set f : fin m.succ → (fin d → Fq) := λ i j, (A i).coeff j
have : fintype.card (fin d → Fq) < fintype.card (fin m.succ)
{ simpa using lt_of_le_of_lt hm (nat.lt_succ_self m) }
simpa using lt_of_le_of_lt hm (nat.lt_succ_self m)
obtain ⟨i₀, i₁, i_ne, i_eq⟩ := fintype.exists_ne_map_eq_of_card_lt f this
use [i₀, i₁, i_ne]
ext j
by_cases hbj : degree b ≤ j
rw [coeff_eq_zero_of_degree_lt (lt_of_lt_of_le (hA _) hbj), coeff_eq_zero_of_degree_lt (lt_of_lt_of_le (hA _) hbj)]
{ rw [coeff_eq_zero_of_degree_lt (lt_of_lt_of_le (hA _) hbj), coeff_eq_zero_of_degree_lt (lt_of_lt_of_le (hA _) hbj)] }
rw not_le at hbj
apply congr_fun i_eq.symm ⟨j, _⟩
exact lt_of_lt_of_le (coe_lt_degree.mp hbj) hb
intros
refine of_no_dummies _ ((p.remap some - poly.proj none) * (p.remap some + poly.proj none)) (λv, _)
refine of_no_dummies _ ((p.remap some - poly.proj none) * (p.remap some + poly.proj none)) (λv, _); apply int.eq_nat_abs_iff_mul
apply int.eq_nat_abs_iff_mul
intros
rw [← erase_insert (proper_divisors.not_self_mem), ← divisors_eq_proper_divisors_insert_self_of_pos pp.pos, pp.divisors, insert_singleton_comm, erase_insert (λ con, pp.ne_one (mem_singleton.1 con))]
intros
rw ← l_series_summable_iff_of_re_eq_re (complex.of_real_re z.re)
apply l_series_summable_of_bounded_of_one_lt_real h
exact hz
intros
induction i with i ih
dsimp [s, ω, ωb]
{ dsimp [s, ω, ωb], ext; { simp; refl, }, }
ext
ext; { simp; refl, }
{ simp; refl, }
simp
simp; refl
{ simp; refl, }
calc (s (i + 1) : X q) = ((s i)^2 - 2 : ℤ) : rfl ... = ((s i : X q)^2 - 2) : by push_cast ... = (ω^(2^i) + ωb^(2^i))^2 - 2 : by rw ih ... = (ω^(2^i))^2 + (ωb^(2^i))^2 + 2*(ωb^(2^i)*ω^(2^i)) - 2 : by ring ... = (ω^(2^i))^2 + (ωb^(2^i))^2 : by rw [←mul_pow ωb ω, ωb_mul_ω, one_pow, mul_one, add_sub_cancel] ... = ω^(2^(i+1)) + ωb^(2^(i+1)) : by rw [←pow_mul, ←pow_mul, pow_succ']
{ calc (s (i + 1) : X q) = ((s i)^2 - 2 : ℤ) : rfl ... = ((s i : X q)^2 - 2) : by push_cast ... = (ω^(2^i) + ωb^(2^i))^2 - 2 : by rw ih ... = (ω^(2^i))^2 + (ωb^(2^i))^2 + 2*(ωb^(2^i)*ω^(2^i)) - 2 : by ring ... = (ω^(2^i))^2 + (ωb^(2^i))^2 : by rw [←mul_pow ωb ω, ωb_mul_ω, one_pow, mul_one, add_sub_cancel] ... = ω^(2^(i+1)) + ωb^(2^(i+1)) : by rw [←pow_mul, ←pow_mul, pow_succ'] }
intros
unfold padic_val_rat; split_ifs; simp [*, nat.one_lt_iff_ne_zero_and_ne_one] at *
unfold padic_val_rat; split_ifs
unfold padic_val_rat
split_ifs
simp [*, nat.one_lt_iff_ne_zero_and_ne_one] at *
simp [*, nat.one_lt_iff_ne_zero_and_ne_one] at *
intros
have p : padic_val_rat p q = 0
exact_mod_cast @padic_val_nat_primes p q p_prime q_prime neq
{ exact_mod_cast @padic_val_nat_primes p q p_prime q_prime neq }
simp [padic_norm, p, q_prime.1.1, q_prime.1.ne_zero]
intros
simp [ext]
intros
conv_rhs at s { rw [←sup_inf_sdiff x y, sup_comm] }
rw sup_comm at s
conv_rhs at i { rw [←inf_inf_sdiff x y, inf_comm] }
rw inf_comm at i
exact (eq_of_inf_eq_sup_eq i s).symm
intros
rw [disjoint, disjoint, inf_comm]
intros
simp only [upper_bounds, eq_univ_iff_forall, mem_set_of_eq, ball_empty_iff, forall_true_iff]
intros
rw [Inf_eq_infi]; exact hf.map_infi2_le _
rw [Inf_eq_infi]
exact hf.map_infi2_le _
intros
simpa only [div_eq_mul_inv] using hf.at_top_mul_const (inv_pos.2 hr)
intros
simp
intros
ext x
suffices : (∀ (A : set α) (B : set β), B ∈ F → f ⁻¹' B ⊆ A → x ∈ A) ↔ ∀ (B : set β), B ∈ F → f x ∈ B
simp only [mem_sInter, mem_Inter, filter.mem_sets, mem_comap, this, and_imp, exists_prop, mem_preimage, exists_imp_distrib]
simp only [mem_sInter, mem_Inter, filter.mem_sets, mem_comap, this, and_imp, exists_prop, mem_preimage, exists_imp_distrib]
split
intros h U U_in
{ intros h U U_in, simpa only [subset.refl, forall_prop_of_true, mem_preimage] using h (f ⁻¹' U) U U_in }
simpa only [subset.refl, forall_prop_of_true, mem_preimage] using h (f ⁻¹' U) U U_in
intros h V U U_in f_U_V
{ intros h V U U_in f_U_V, exact f_U_V (h U U_in) }
exact f_U_V (h U U_in)
intros
simp only [tendsto, map_sup, sup_le_iff]
intros
ext ⟨f⟩
{ ext ⟨f⟩, refl }
refl
intros
{ change x ∈ (⋂ (I ∈ s), (I : set P)) ↔ ∀ I ∈ s, x ∈ I, simp }
change x ∈ (⋂ (I ∈ s), (I : set P)) ↔ ∀ I ∈ s, x ∈ I
simp
intros
have := partial_order.ext H
have ss := funext (λ x, funext $ semilattice_sup.ext_sup H x)
casesI A
casesI B
injection this; congr'
injection this
congr'
intros
ext x
{ ext x, refl }
refl
intros
rw [set.well_founded_on_iff_no_descending_seq]
intros g con
apply set.infinite_of_injective_forall_mem g.injective (set.range_subset_iff.1 con)
exact f.finite_to_set
intros
rcases hz with ⟨p, p_ne_zero, px⟩
set a := p.leading_coeff with a_def
have a_ne_zero : a ≠ 0 := mt polynomial.leading_coeff_eq_zero.mp p_ne_zero
have y_integral : is_integral R (algebra_map R S a) := is_integral_algebra_map
have x_integral : is_integral R (z * algebra_map R S a) := ⟨p.integral_normalization, monic_integral_normalization p_ne_zero, integral_normalization_aeval_eq_zero px inj⟩
exact ⟨⟨_, x_integral⟩, a, a_ne_zero, rfl⟩
intros
rw ← monoid_hom.map_mclosure at h
simpa using of_mem_span_of_iff.1 h
intros
rcases I.is_fractional with ⟨aI, haI, hI⟩
rcases J.is_fractional with ⟨aJ, haJ, hJ⟩
use aI * aJ
use S.mul_mem haI haJ
intros b hb
rcases mem_sup.mp hb with ⟨bI, hbI, bJ, hbJ, rfl⟩
rw smul_add
apply is_integer_add
rw [mul_smul, smul_comm]
{ rw [mul_smul, smul_comm], exact is_integer_smul (hI bI hbI), }
exact is_integer_smul (hI bI hbI)
rw mul_smul
{ rw mul_smul, exact is_integer_smul (hJ bJ hbJ) }
exact is_integer_smul (hJ bJ hbJ)
intros
split_ifs with h; simp [h]
{ split_ifs with h; simp [h] }
split_ifs with h
simp [h]
simp [h]
intros
simp
intros
simp
intros
rw [ker, ideal.mem_comap, submodule.mem_bot]
intros
rcases h with ⟨f, hf, hx⟩
use [f, hf]
rw [is_scalar_tower.algebra_map_eq R A B, ← hom_eval₂, hx, ring_hom.map_zero]
intros
rw ← (algebra_map R S).map_zero
split
split; intro h
intro h
cases (eq_iff_exists M S).mp h with c hc
{ cases (eq_iff_exists M S).mp h with c hc, rw zero_mul at hc, exact hM c.2 x hc }
rw zero_mul at hc
exact hM c.2 x hc
intro h
{ rw h }
rw h
intros
have t : ∀ (p : n × n), (i = p.1 ∧ j = p.2) ↔ (p = (i, j)) := by tidy
simp [ite_tmul, t, std_basis_matrix]
intros
obtain ⟨X, rfl⟩ := hfin
use X
exact submodule.span_eq_restrict_scalars R S M X h
intros
simp [bernstein_polynomial]
intros
simp only [cyclotomic, dif_pos]
intros
rw dickson
intros
exact_mod_cast congr_arg nat.cast (pochhammer_nat_eval_succ r n)
intros
rw [degree_eq_nat_degree ne_zero, with_bot.coe_le_coe]
{ rw [degree_eq_nat_degree ne_zero, with_bot.coe_le_coe], exact h.dim_le_nat_degree_of_root ne_zero root }
exact h.dim_le_nat_degree_of_root ne_zero root
intros
{ ext, simp }
ext
simp
intros
simpa only [srange_eq_map] using (⊤ : subsemiring R).map_map g f
intros
have aux : ∀ a s, v s = 0 → v (a + s) ≤ v a
intros a' s' h'
{ intros a' s' h', refine le_trans (v.map_add a' s') (max_le (le_refl _) _), simp [h'], }
refine le_trans (v.map_add a' s') (max_le (le_refl _) _)
simp [h']
apply le_antisymm (aux a s h)
calc v a = v (a + s + -s) : by simp ... ≤ v (a + s) : aux (a + s) (-s) (by rwa ←ideal.neg_mem_iff at h)
intros
apply witt_vector.hom_ext
intro n
rw [from_padic_int, ← ring_hom.comp_assoc, truncate_comp_lift, ring_hom.comp_assoc]
simp only [to_padic_int, to_zmod_pow, ring_hom.comp_id, padic_int.lift_spec, ring_hom.id_comp, ← ring_hom.comp_assoc, ring_equiv.to_ring_hom_comp_symm_to_ring_hom]
intros
simp only [ghost_component_apply, frobenius_fun, coeff_mk, ← bind₁_frobenius_poly_witt_polynomial, aeval_bind₁]
intros
rw [witt_polynomial_eq_sum_C_mul_X_pow, alg_hom.map_sum, finset.sum_eq_single 0]
simp only [one_poly, one_pow, one_mul, alg_hom.map_pow, C_1, pow_zero, bind₁_X_right, if_true, eq_self_iff_true]
{ simp only [one_poly, one_pow, one_mul, alg_hom.map_pow, C_1, pow_zero, bind₁_X_right, if_true, eq_self_iff_true], }
intros i hi hi0
{ intros i hi hi0, simp only [one_poly, if_neg hi0, zero_pow (pow_pos hp.1.pos _), mul_zero, alg_hom.map_pow, bind₁_X_right, alg_hom.map_mul], }
simp only [one_poly, if_neg hi0, zero_pow (pow_pos hp.1.pos _), mul_zero, alg_hom.map_pow, bind₁_X_right, alg_hom.map_mul]
{ rw finset.mem_range, dec_trivial }
rw finset.mem_range
dec_trivial
intros
intros x y h
ext i
rw [witt_vector.ext_iff] at h
simpa only [coeff_out] using h ↑i
intros
simp only [witt_polynomial, X, sum_singleton, range_one, pow_zero]
intros
rw [← aleph'_omega, aleph'_le]
rw [← two_power_omega, ← power_mul, mul_eq_left le_rfl le_rfl omega_ne_zero]
intros
simp [←move_left_card h, lt_add_one]
{ intros c c' h, rw [←card_ord c, ←card_ord c', h] }
intros c c' h
rw [←card_ord c, ←card_ord c', h]
intros
rw [← card_eq_nat, card_type, mk_fin]
intros
cases h with _ _ _ _ eb _ h₁ h₂ h₃; exact ⟨⟨_, h₁⟩⟩
cases h with _ _ _ _ eb _ h₁ h₂ h₃
exact ⟨⟨_, h₁⟩⟩
intros
cases n; cases i; refl
cases n; cases i
cases n
cases i
refl
cases i
refl
intros
cases a
cases b
refl
intros
classical
by_contradiction h''
revert h
apply not_le_of_lt
apply lt_of_mul_lt_mul_neg_right _ h'
apply lt_of_not_ge h''
intros
rwa add_comm
intros
simp only [inv_eq_one_div, one_div_div]
intros
simp [h₂.symm, h₁.symm, horner]; cc
simp [h₂.symm, h₁.symm, horner]
cc
intros
conv_lhs { rw [rec_shrink_with, well_founded.fix_eq], }
congr
ext ⟨y, h⟩
refl
intros
simpa only [zero_add] using dist_le_tsum_dist_of_tendsto h ha 0
intros
{ ext, refl }
ext
refl
intros
{ ext, simp [mul_smul] }
ext
simp [mul_smul]
intros
erw [nhds_prod_eq, filter.mem_prod_iff] at hU
rcases hU with ⟨U₁, hU₁, U₂, hU₂, h⟩
cases is_nonarchimedean _ hU₁ with V hV
cases is_nonarchimedean _ hU₂ with W hW
use V
use W
rw set.prod_subset_iff
intros x hX y hY
exact set.subset.trans (set.prod_mono hV hW) h (set.mem_sep hX hY)
intros
rcases (is_lub_cSup hS hS').exists_seq_monotone_tendsto hS with ⟨u, hu⟩
exact ⟨u, hu.1, hu.2.2⟩
intros
simp_rw [← is_closed_compl_iff, compl_set_of, not_lt]
{ simp_rw [← is_closed_compl_iff, compl_set_of, not_lt], exact is_closed_le continuous_snd continuous_fst }
exact is_closed_le continuous_snd continuous_fst
intros
simp only [continuous_within_at, nhds_within_Ioc_eq_nhds_within_Iic h]
intros
convert is_closed_closure
intros
simp only [interior, mem_set_of_eq, exists_prop, and_assoc, and.left_comm]
intros
haveI := CompHaus.is_iso_of_bijective (Profinite_to_CompHaus.map f) bij
exact is_iso_of_fully_faithful Profinite_to_CompHaus _
intros
tidy
intros
rintros u v hu hv hs ⟨z, zs, zu⟩ ⟨y, ys, yv⟩
have xs : x ∈ s
rcases H y ys with ⟨t, ts, xt, yt, ht⟩
rcases H y ys with ⟨t, ts, xt, yt, ht⟩
{ rcases H y ys with ⟨t, ts, xt, yt, ht⟩, exact ts xt }
{ rcases H y ys with ⟨t, ts, xt, yt, ht⟩, exact ts xt }
exact ts xt
exact ts xt
wlog xu : x ∈ u := hs xs using [u v y z, v u z y]
rcases H y ys with ⟨t, ts, xt, yt, ht⟩
have := ht u v hu hv(subset.trans ts hs) ⟨x, xt, xu⟩ ⟨y, yt, yv⟩
exact this.imp (λ z hz, ⟨ts hz.1, hz.2⟩)
intros
simp [frontier_prod_eq]
intros
simp only [is_open_supr_iff, is_open_coinduced]
intros
{ ext, simp [polynomial_functions], }
ext
simp [polynomial_functions]
intros
apply continuous_on.piecewise
{ rwa ite_inter_of_inter_eq _ H }
rwa ite_inter_of_inter_eq _ H
{ rwa ite_inter_closure_eq_of_inter_frontier_eq H }
rwa ite_inter_closure_eq_of_inter_frontier_eq H
{ rwa ite_inter_closure_compl_eq_of_inter_frontier_eq H }
rwa ite_inter_closure_compl_eq_of_inter_frontier_eq H
intros
simp only [tendsto, nhds_within_eq_map_subtype_coe h, filter.map_map, restrict]
intros
assume x xs
rcases h x xs with ⟨t, open_t, xt, ct⟩
have := ct x ⟨xs, xt⟩
rwa [continuous_within_at, ← nhds_within_restrict _ xt open_t] at this
intros
ext ⟨⟩
{ ext ⟨⟩, refl }
refl
intros
refine prod.ext _ rfl
rw [e₂.coe_fst', ← e₁.coe_fst', e₁.apply_symm_apply' h₁]
{ rwa [e₁.proj_symm_apply' h₁] }
rwa [e₁.proj_symm_apply' h₁]
{ rwa [e₁.proj_symm_apply' h₁] }
rwa [e₁.proj_symm_apply' h₁]
intros
simp only [← is_open_compl_iff, ← preimage_compl, is_open_preimage]
intros
change continuous_at ((λ (p : ereal × ereal), p.2 + p.1) ∘ prod.swap) (a, ⊥)
apply continuous_at.comp _ continuous_swap.continuous_at
simp_rw add_comm
exact continuous_at_add_bot_coe a
intros
rw real.ball_eq_Ioo; apply totally_bounded_Ioo
rw real.ball_eq_Ioo
apply totally_bounded_Ioo
intros
{ cases e, subst e', refl }
cases e
subst e'
refl
intros
tfae_have : 1 → 4
from λ h y, h {y}
tfae_have : 4 → 3
from λ h x, h (f x)
tfae_have : 3 → 2
from λ h x, is_open.mem_nhds (h x) rfl
tfae_have : 2 → 5
intros h x
{ intros h x, rcases mem_nhds_iff.1 (h x) with ⟨U, eq, hU, hx⟩, exact ⟨U, hU, hx, eq⟩ }
rcases mem_nhds_iff.1 (h x) with ⟨U, eq, hU, hx⟩
exact ⟨U, hU, hx, eq⟩
tfae_have : 5 → 1
intros h s
{ intros h s, refine is_open_iff_forall_mem_open.2 (λ x hx, _), rcases h x with ⟨U, hU, hxU, eq⟩, exact ⟨U, λ x' hx', mem_preimage.2 $ (eq x' hx').symm ▸ hx, hU, hxU⟩ }
refine is_open_iff_forall_mem_open.2 (λ x hx, _)
rcases h x with ⟨U, hU, hxU, eq⟩
exact ⟨U, λ x' hx', mem_preimage.2 $ (eq x' hx').symm ▸ hx, hU, hxU⟩
tfae_finish
intros
simpa only [not_le] using not_congr dist_le_zero
intros
rw [← ball_union_sphere, set.union_diff_cancel_left sphere_disjoint_ball.symm]
intros
{ convert metric.emetric_closed_ball ε.2, simp }
convert metric.emetric_closed_ball ε.2
simp
intros
convert hf.apriori_edist_iterate_efixed_point_le' hsc hsf hxs hx 0
{ convert hf.apriori_edist_iterate_efixed_point_le' hsc hsf hxs hx 0, rw [pow_zero, mul_one] }
rw [pow_zero, mul_one]
intros
rw [← e.image_symm_eq_preimage, e.symm.dimH_image]
intros
simp [inf_dist]
intros
rw [iterate_succ, mul_comm]
simpa only [ennreal.coe_pow] using (hf.iterate n) x (f x)
intros
simp [← is_open_compl_iff, is_open_supr_iff]
intros
assume x z hz
by_cases h : x ∈ s; simp [h] at hz
by_cases h : x ∈ s
simp [h] at hz
filter_upwards [hs.mem_nhds h]
{ filter_upwards [hs.mem_nhds h], simp [hz] { contextual := tt} }
simp [hz] { contextual := tt}
simp [h] at hz
apply filter.eventually_of_forall (λ x', _)
{ apply filter.eventually_of_forall (λ x', _), by_cases h' : x' ∈ s; simp [h', hz.trans_le hy, hz] }
by_cases h' : x' ∈ s; simp [h', hz.trans_le hy, hz]
by_cases h' : x' ∈ s
simp [h', hz.trans_le hy, hz]
simp [h', hz.trans_le hy, hz]
intros
classical
induction t using finset.induction with x t hx ih generalizing U hU s hs hsC
refine ⟨λ _, ∅, λ i, is_compact_empty, λ i, empty_subset _, _⟩
{ refine ⟨λ _, ∅, λ i, is_compact_empty, λ i, empty_subset _, _⟩, simpa only [subset_empty_iff, Union_false, Union_empty] using hsC }
simpa only [subset_empty_iff, Union_false, Union_empty] using hsC
simp only [finset.set_bUnion_insert] at hsC
simp only [finset.mem_insert] at hU
have hU' : ∀ i ∈ t, is_open (U i) := λ i hi, hU i (or.inr hi)
rcases hs.binary_compact_cover (hU x (or.inl rfl)) (is_open_bUnion hU') hsC with ⟨K₁, K₂, h1K₁, h1K₂, h2K₁, h2K₂, hK⟩
rcases ih U hU' h1K₂ h2K₂ with ⟨K, h1K, h2K, h3K⟩
refine ⟨update K x K₁, _, _, _⟩
intros i
{ intros i, by_cases hi : i = x, { simp only [update_same, hi, h1K₁] }, { rw [← ne.def] at hi, simp only [update_noteq hi, h1K] }}
by_cases hi : i = x
{ simp only [update_same, hi, h1K₁] }
simp only [update_same, hi, h1K₁]
{ rw [← ne.def] at hi, simp only [update_noteq hi, h1K] }
rw [← ne.def] at hi
simp only [update_noteq hi, h1K]
intros i
{ intros i, by_cases hi : i = x, { simp only [update_same, hi, h2K₁] }, { rw [← ne.def] at hi, simp only [update_noteq hi, h2K] }}
by_cases hi : i = x
{ simp only [update_same, hi, h2K₁] }
simp only [update_same, hi, h2K₁]
{ rw [← ne.def] at hi, simp only [update_noteq hi, h2K] }
rw [← ne.def] at hi
simp only [update_noteq hi, h2K]
{ simp only [set_bUnion_insert_update _ hx, hK, h3K] }
simp only [set_bUnion_insert_update _ hx, hK, h3K]
intros
{ dsimp [comp], tidy, }
dsimp [comp]
tidy
intros
rw [to_topological_space_Inf, infi_pair]
intros
refine filter.has_basis_self.2 (λ t h, _)
rcases comp_comp_symm_mem_uniformity_sets h with ⟨w, w_in, w_symm, r⟩
refine ⟨closure w, mem_of_superset w_in subset_closure, is_closed_closure, _⟩
refine subset.trans _ r
rw closure_eq_uniformity
apply Inter_subset_of_subset
apply Inter_subset
exact ⟨w_in, w_symm⟩
intros
simp [uniform_continuous, hf.comap_uniformity.symm, tendsto_comap]
intros
cases a; cases b; simp
cases a; cases b
cases a
cases b
simp
simp
cases b
simp
simp
intros
have h := int.add_le_add_right h (-a)
rwa [int.add_comm a b, int.add_neg_cancel_right] at h
intros
unfold bodd div2 bodd_div2; cases bodd_div2 n; cases fst; refl
unfold bodd div2 bodd_div2; cases bodd_div2 n; cases fst
unfold bodd div2 bodd_div2; cases bodd_div2 n
unfold bodd div2 bodd_div2
cases bodd_div2 n
cases fst
refl
refl
intros
tactic.mk_inj_eq
intros
rw [mul_sub, ←commutes, sub_mul]
intros
ext
{ ext, simp only [linear_map.id_coe, mul_one, id.def, lmul_right_apply] }
simp only [linear_map.id_coe, mul_one, id.def, lmul_right_apply]
intros
{ ext, rw [set_like.mem_coe, mem_range], refl }
ext
rw [set_like.mem_coe, mem_range]
refl
intros
rw [algebra_map_apply R S A r, f.commutes, ← algebra_map_apply R S B]
intros
{ convert (s.prod_inter_mul_prod_diff {i} f).symm, simp [h] }
convert (s.prod_inter_mul_prod_diff {i} f).symm
simp [h]
intros
simp
intros
rw [← finprod_mem_inter_mul_support, h, finprod_mem_inter_mul_support]
intros
classical
{ classical, rw finprod_mem_finset_product', simp_rw finprod_mem_finset_product', simp, }
rw finprod_mem_finset_product'
simp_rw finprod_mem_finset_product'
simp
intros
split
rintro rfl
unfreezingI {rintro rfl}
{ unfreezingI {rintro rfl}, exact char_zero_of_exp_char_one R p, }
exact char_zero_of_exp_char_one R p
rintro rfl
unfreezingI {rintro rfl}
{ unfreezingI {rintro rfl}, exact exp_char_one_of_char_zero R q, }
exact exp_char_one_of_char_zero R q
intros
{ cases g, cases g', simp }
cases g
cases g'
simp
intros
cases n
case nat.zero { cases g_s_head_eq : (g.s.nth 0); simp [g_s_head_eq, squash_gcf, convergents', convergents'_aux, seq.head] }
cases g_s_head_eq : (g.s.nth 0); simp [g_s_head_eq, squash_gcf, convergents', convergents'_aux, seq.head]
cases g_s_head_eq : (g.s.nth 0)
simp [g_s_head_eq, squash_gcf, convergents', convergents'_aux, seq.head]
simp [g_s_head_eq, squash_gcf, convergents', convergents'_aux, seq.head]
case nat.succ { simp only [succ_succ_nth_convergent'_aux_eq_succ_nth_convergent'_aux_squash_seq, convergents', squash_gcf] }
simp only [succ_succ_nth_convergent'_aux_eq_succ_nth_convergent'_aux_squash_seq, convergents', squash_gcf]
intros
refine ⟨λ h a b c bc, _, λ h a b c bc, _⟩
rw [← inv_mul_cancel_left a b, ← inv_mul_cancel_left a c]
{ rw [← inv_mul_cancel_left a b, ← inv_mul_cancel_left a c], exact h a⁻¹ bc }
exact h a⁻¹ bc
rw [← inv_mul_cancel_left a b, ← inv_mul_cancel_left a c] at bc
{ rw [← inv_mul_cancel_left a b, ← inv_mul_cancel_left a c] at bc, exact h a⁻¹ bc }
exact h a⁻¹ bc
intros
rw [add_submonoid.supr_eq_mrange_dfinsupp_sum_add_hom, add_monoid_hom.mrange_top_iff_surjective]
exact function.bijective.surjective h
intros
{ rcases hu with ⟨u, rfl⟩, apply units.mul_right_dvd, }
rcases hu with ⟨u, rfl⟩
apply units.mul_right_dvd
intros
rwa [add_comm, add_div', add_comm]
intros
apply iff.trans multiset.lcm_dvd
simp only [multiset.mem_map, and_imp, exists_imp_distrib]
exact ⟨λ k b hb, k _ _ hb rfl, λ k a' b hb h, h ▸ k _ hb⟩
intros
simp [h.symm, mul_inv_cancel_left]
intros
rw [← add_sub_assoc, sub_add_cancel]
intros
{ rw [←h, u.inv_mul], }
rw [←h, u.inv_mul]
intros
split_ifs with h
{ rw [h, pow_zero], }
rw [h, pow_zero]
{ rw [zero_pow (nat.pos_of_ne_zero h)] }
rw [zero_pow (nat.pos_of_ne_zero h)]
intros
rw [← nat.mod_add_div n 2, pow_add, pow_mul]; simp [sq]
rw [← nat.mod_add_div n 2, pow_add, pow_mul]
simp [sq]
intros
rw [div_eq_mul_one_div, div_mul_div, mul_one]
intros
dsimp [d_from]
rw h
refl
intros
{ ext, simp }
ext
simp
intros
rw [← mul_indicator_union_mul_inter_apply f s t, mul_indicator_of_not_mem h, mul_one]
intros
rw [←mul_assoc, mul_inv_of_self, one_mul]
intros
rw [leibniz_lie, add_sub_cancel]
intros
induction h
case rel.lie_self : a' { simp only [lift_aux_map_mul, non_unital_alg_hom.map_zero, lie_self], }
case rel.leibniz_lie : a' b' c' { simp only [lift_aux_map_mul, lift_aux_map_add, sub_add_cancel, lie_lie], }
case rel.smul : t a' b' h₁ h₂ { simp only [lift_aux_map_smul, h₂], }
case rel.add_right : a' b' c' h₁ h₂ { simp only [lift_aux_map_add, h₂], }
case rel.mul_left : a' b' c' h₁ h₂ { simp only [lift_aux_map_mul, h₂], }
case rel.mul_right : a' b' c' h₁ h₂ { simp only [lift_aux_map_mul, h₂], }
intros
have h' : (⊤ : lie_ideal R L).map f = ⊤
rw ←f.ideal_range_eq_map
{ rw ←f.ideal_range_eq_map, exact f.ideal_range_eq_top_of_surjective h, }
exact f.ideal_range_eq_top_of_surjective h
induction k with k ih
simp only [lie_module.lower_central_series_zero]
{ simp only [lie_module.lower_central_series_zero], exact h', }
exact h'
simp only [lie_module.lower_central_series_succ, lie_ideal.map_bracket_eq f h, ih, h']
{ simp only [lie_module.lower_central_series_succ, lie_ideal.map_bracket_eq f h, ih, h'], }
intros
rw [lie_hom.ideal_range_eq_lie_span_range, ← lie_subalgebra.coe_to_submodule, ← lie_submodule.coe_to_submodule_eq_iff, incl_range, coe_to_lie_subalgebra_to_submodule, lie_submodule.coe_lie_span_submodule_eq_iff]
use I
intros
rw [←neg_neg c, neg_smul, neg_smul (-c), neg_le_neg_iff]
exact smul_le_smul_iff_of_pos (neg_pos_of_neg hc)
intros
haveI := classical.prop_decidable
{ haveI := classical.prop_decidable, simp_rw [ne.def, p.eq_bot_iff, not_forall] }
simp_rw [ne.def, p.eq_bot_iff, not_forall]
intros
rw [lift_def, lift_nc_single, algebra.smul_def, ring_hom.coe_add_monoid_hom]
intros
refine finsupp.induction_linear f _ (λ f g hf hg, hadd f g hf hg) (λ g r, _)
{ simpa using hsmul 0 (of k G 1) (hM 1) }
simpa using hsmul 0 (of k G 1) (hM 1)
convert hsmul r (of k G g) (hM g)
{ convert hsmul r (of k G g) (hM g), simp only [mul_one, smul_single', of_apply] }
simp only [mul_one, smul_single', of_apply]
intros
split
{ split, rw [←cmp_swap _ y, ←cmp_swap _ y'], cc, rw [←cmp_swap _ x, ←cmp_swap _ x'], cc, }
rw [←cmp_swap _ y, ←cmp_swap _ y']
cc
rw [←cmp_swap _ x, ←cmp_swap _ x']
cc
intros
rwa [inv_lt ((@zero_lt_one α _ _).trans ha) zero_lt_one, inv_one]
intros
rwa [div_le_iff_of_neg' hb, ← div_eq_mul_one_div, div_le_one_of_neg (h.trans_lt hb)]
intros
simp [division_def, mul_nonpos_iff]
intros
rw [← mul_le_mul_iff_left b, mul_inv_cancel_left]
intros
{ rw [← mul_lt_mul_iff_left a, ← mul_lt_mul_iff_right b], simp }
rw [← mul_lt_mul_iff_left a, ← mul_lt_mul_iff_right b]
simp
intros
ext x
simp only [mem_smul_set, algebra.id.smul_eq_mul, mem_Ioo]
split
rintro ⟨a, ⟨a_h_left_left, a_h_left_right⟩, rfl⟩
{ rintro ⟨a, ⟨a_h_left_left, a_h_left_right⟩, rfl⟩, split, exact (mul_lt_mul_left hr).mpr a_h_left_left, exact (mul_lt_mul_left hr).mpr a_h_left_right, }
split
exact (mul_lt_mul_left hr).mpr a_h_left_left
exact (mul_lt_mul_left hr).mpr a_h_left_right
rintro ⟨a_left, a_right⟩
{ rintro ⟨a_left, a_right⟩, use x / r, refine ⟨⟨(lt_div_iff' hr).mpr a_left, (div_lt_iff' hr).mpr a_right⟩, _⟩, rw mul_div_cancel' _ (ne_of_gt hr), }
use x / r
refine ⟨⟨(lt_div_iff' hr).mpr a_left, (div_lt_iff' hr).mpr a_right⟩, _⟩
rw mul_div_cancel' _ (ne_of_gt hr)
intros
simpa only [abs_one, one_mul] using @abs_le_iff_mul_self_le α _ a 1
intros
haveI := @linear_order.decidable_le α _; exact assume b c b_le_c, decidable.mul_le_mul_of_nonneg_left b_le_c ha
haveI := @linear_order.decidable_le α _
exact assume b c b_le_c, decidable.mul_le_mul_of_nonneg_left b_le_c ha
intros
simpa only [div_eq_mul_inv] using h.mul_const a
intros
simpa only [div_eq_mul_inv] using h.mul_const ha
intros
dsimp
split
intro h
repeat { intro h, conv_rhs { rw eq_mul_inv_of_mul_eq (eq_mul_inv_of_mul_eq h) }, simp, }
conv_rhs { rw eq_mul_inv_of_mul_eq (eq_mul_inv_of_mul_eq h) }
simp
intro h
conv_rhs { rw eq_mul_inv_of_mul_eq (eq_mul_inv_of_mul_eq h) }
simp
intros
rw [← a.commute_self_conj.eq, self_mul_conj]
intros
refine ⟨_, _⟩
rintros ⟨ab, ba⟩
{ rintros ⟨ab, ba⟩, refine ⟨ba.of_mul, ab.of_mul⟩ }
refine ⟨ba.of_mul, ab.of_mul⟩
rintros ⟨ha, hb⟩
{ rintros ⟨ha, hb⟩, exact ⟨ha.mul hb, hb.mul ha⟩ }
exact ⟨ha.mul hb, hb.mul ha⟩
intros
{ ext x, simp [even, eq_comm] }
ext x
simp [even, eq_comm]
intros
{ rw sub_eq_add_neg, exact dvd_add h₁ (dvd_neg_of_dvd h₂) }
rw sub_eq_add_neg
exact dvd_add h₁ (dvd_neg_of_dvd h₂)
intros
obtain ⟨a₁, b₁, ha₁, hb₁, hab₁, hab₂⟩ := sq_mul_squarefree_of_pos h
refine ⟨a₁.pred, b₁.pred, _, _⟩; simpa only [add_one, succ_pred_eq_of_pos, ha₁, hb₁]
refine ⟨a₁.pred, b₁.pred, _, _⟩
simpa only [add_one, succ_pred_eq_of_pos, ha₁, hb₁]
simpa only [add_one, succ_pred_eq_of_pos, ha₁, hb₁]
intros
simp_rw [← subset_empty_iff, mul_support_subset_iff', funext_iff]
{ simp_rw [← subset_empty_iff, mul_support_subset_iff', funext_iff], simp }
simp
intros
rintros U ⟨s, z⟩
rw [← compl_compl U, ← z, ← Union_of_singleton_coe s, zero_locus_Union, compl_Inter, image_Union]
simp_rw [← image_of_Df_eq_comap_C_compl_zero_locus]
exact is_open_Union (λ f, is_open_image_of_Df)
intros
rw stalk_map.congr α α rfl x x' h
intros
rw ← nnreal.summable_coe
{ rw ← nnreal.summable_coe, push_cast, exact p.summable_norm_mul_pow h }
push_cast
exact p.summable_norm_mul_pow h
intros
rcases i with ⟨k, blocks_fun⟩
dsimp [comp_change_of_variables]
simp only [composition.length, map_of_fn, length_of_fn]
intros
simp only [is_o, is_O_with]
intros
simp only [is_O_with, norm_norm]
intros
rw is_o_const_iff hc
refine ⟨λ h, tendsto_nhds_unique tendsto_const_nhds h, _⟩
rintros rfl
exact tendsto_const_nhds
intros
have := hf.iterate hL hx n
rwa [continuous_linear_map.smul_right_one_pow] at this
intros
rw [← has_deriv_within_at_univ] at *
exact hc.clm_comp hd
intros
simpa only [smul_zero, zero_add] using hc.smul (has_fderiv_at_const f x)
intros
have := hf.add_is_O_with (f'.is_O_with_comp _ _) hK
simp only [sub_add_cancel, is_O_with] at this
rcases exists_nhds_square this with ⟨U, Uo, xU, hU⟩
exact ⟨U, Uo.mem_nhds xU, lipschitz_on_with_iff_norm_sub_le.2 $ λ x hx y hy, hU (mk_mem_prod hx hy)⟩
intros
convert (hf.implicit_to_local_homeomorph_of_complemented f f' hf' hker).left_inv (hf.mem_implicit_to_local_homeomorph_of_complemented_source hf' hker)
exact congr_arg prod.snd (hf.implicit_to_local_homeomorph_of_complemented_self hf' hker).symm
intros
induction n with n IH generalizing x
{ simp }
simp
rw [iterated_deriv_within_succ (hs x hx), function.iterate_succ']
{ rw [iterated_deriv_within_succ (hs x hx), function.iterate_succ'], exact deriv_within_congr (hs x hx) (λ y hy, IH hy) (IH hx) }
exact deriv_within_congr (hs x hx) (λ y hy, IH hy) (IH hx)
intros
simpa only [sub_zero, mul_one] using norm_image_sub_le_of_norm_deriv_le_segment' hf bound 1 (right_mem_Icc.2 zero_le_one)
intros
simp [exp_neg_inv_glue, not_le.2 hx, exp_pos]
intros
split
assume H
{ assume H, split, { exact λ x, H.zero_eq x (mem_univ x) }, { assume m hm x, rw ← has_fderiv_within_at_univ, exact H.fderiv_within m hm x (mem_univ x) }, { assume m hm, rw continuous_iff_continuous_on_univ, exact H.cont m hm } }
split
{ exact λ x, H.zero_eq x (mem_univ x) }
exact λ x, H.zero_eq x (mem_univ x)
assume m hm x
{ assume m hm x, rw ← has_fderiv_within_at_univ, exact H.fderiv_within m hm x (mem_univ x) }
rw ← has_fderiv_within_at_univ
exact H.fderiv_within m hm x (mem_univ x)
assume m hm
{ assume m hm, rw continuous_iff_continuous_on_univ, exact H.cont m hm }
rw continuous_iff_continuous_on_univ
exact H.cont m hm
assume H
{ assume H, split, { exact λ x hx, H.zero_eq x }, { assume m hm x hx, rw has_fderiv_within_at_univ, exact H.fderiv m hm x }, { assume m hm, rw ← continuous_iff_continuous_on_univ, exact H.cont m hm } }
split
{ exact λ x hx, H.zero_eq x }
exact λ x hx, H.zero_eq x
assume m hm x hx
{ assume m hm x hx, rw has_fderiv_within_at_univ, exact H.fderiv m hm x }
rw has_fderiv_within_at_univ
exact H.fderiv m hm x
assume m hm
{ assume m hm, rw ← continuous_iff_continuous_on_univ, exact H.cont m hm }
rw ← continuous_iff_continuous_on_univ
exact H.cont m hm
intros
assume m hm
rcases hf m hm with ⟨u, hu, p, hp⟩
exact ⟨u, hu, _, hp.continuous_linear_map_comp g⟩
intros
refine ⟨λ H, ⟨H.continuous_on, H.zero_eq⟩, λ H, ⟨H.2, λ m hm, false.elim (not_le.2 hm bot_le), _⟩⟩
assume m hm
obtain rfl : m = 0
exact_mod_cast (hm.antisymm (zero_le _))
exact_mod_cast (hm.antisymm (zero_le _))
have : ∀ x ∈ s, p x 0 = (continuous_multilinear_curry_fin0 𝕜 E F).symm (f x)
assume x hx
assume x hx
{ assume x hx, rw ← H.2 x hx, symmetry, exact continuous_multilinear_map.uncurry0_curry0 _ }
{ assume x hx, rw ← H.2 x hx, symmetry, exact continuous_multilinear_map.uncurry0_curry0 _ }
rw ← H.2 x hx
rw ← H.2 x hx
symmetry
symmetry
exact continuous_multilinear_map.uncurry0_curry0 _
exact continuous_multilinear_map.uncurry0_curry0 _
rw [continuous_on_congr this, linear_isometry_equiv.comp_continuous_on_iff]
exact H.1
intros
split
rintro hz
{ rintro hz, obtain ⟨a, b, ha, hb, hab, rfl⟩ := (convex.mem_Icc h.le).1 (Ico_subset_Icc_self hz), obtain rfl | ha' := ha.eq_or_lt, { rw zero_add at hab, rw [hab, one_mul, zero_mul, zero_add] at hz, exact (hz.2.ne rfl).elim }, { exact ⟨a, b, ha', hb, hab, rfl⟩ } }
obtain ⟨a, b, ha, hb, hab, rfl⟩ := (convex.mem_Icc h.le).1 (Ico_subset_Icc_self hz)
obtain rfl | ha' := ha.eq_or_lt
rw zero_add at hab
{ rw zero_add at hab, rw [hab, one_mul, zero_mul, zero_add] at hz, exact (hz.2.ne rfl).elim }
rw [hab, one_mul, zero_mul, zero_add] at hz
exact (hz.2.ne rfl).elim
{ exact ⟨a, b, ha', hb, hab, rfl⟩ }
exact ⟨a, b, ha', hb, hab, rfl⟩
rintro ⟨a, b, ha, hb, hab, rfl⟩
{ rintro ⟨a, b, ha, hb, hab, rfl⟩, obtain rfl | hb' := hb.eq_or_lt, { rw add_zero at hab, rwa [hab, one_mul, zero_mul, add_zero, left_mem_Ico] }, { exact Ioo_subset_Ico_self ((convex.mem_Ioo h).2 ⟨a, b, ha, hb', hab, rfl⟩) } }
obtain rfl | hb' := hb.eq_or_lt
rw add_zero at hab
{ rw add_zero at hab, rwa [hab, one_mul, zero_mul, add_zero, left_mem_Ico] }
rwa [hab, one_mul, zero_mul, add_zero, left_mem_Ico]
exact Ioo_subset_Ico_self ((convex.mem_Ioo h).2 ⟨a, b, ha, hb', hab, rfl⟩)
{ exact Ioo_subset_Ico_self ((convex.mem_Ioo h).2 ⟨a, b, ha, hb', hab, rfl⟩) }
intros
intros x y hx hy a b ha hb hab
obtain hxy | hyx := h.total_of_refl hx hy
refine hs.out hx hy (mem_Icc.2 ⟨_, _⟩)
{ refine hs.out hx hy (mem_Icc.2 ⟨_, _⟩), calc x = a • x + b • x : by rw [←add_smul, hab, one_smul] ... ≤ a • x + b • y : add_le_add_left (smul_le_smul_of_nonneg hxy hb) _, calc a • x + b • y ≤ a • y + b • y : add_le_add_right (smul_le_smul_of_nonneg hxy ha) _ ... = y : by rw [←add_smul, hab, one_smul] }
calc x = a • x + b • x : by rw [←add_smul, hab, one_smul] ... ≤ a • x + b • y : add_le_add_left (smul_le_smul_of_nonneg hxy hb) _
calc a • x + b • y ≤ a • y + b • y : add_le_add_right (smul_le_smul_of_nonneg hxy ha) _ ... = y : by rw [←add_smul, hab, one_smul]
refine hs.out hy hx (mem_Icc.2 ⟨_, _⟩)
{ refine hs.out hy hx (mem_Icc.2 ⟨_, _⟩), calc y = a • y + b • y : by rw [←add_smul, hab, one_smul] ... ≤ a • x + b • y : add_le_add_right (smul_le_smul_of_nonneg hyx ha) _, calc a • x + b • y ≤ a • x + b • x : add_le_add_left (smul_le_smul_of_nonneg hyx hb) _ ... = x : by rw [←add_smul, hab, one_smul] }
calc y = a • y + b • y : by rw [←add_smul, hab, one_smul] ... ≤ a • x + b • y : add_le_add_right (smul_le_smul_of_nonneg hyx ha) _
calc a • x + b • y ≤ a • x + b • x : add_le_add_left (smul_le_smul_of_nonneg hyx hb) _ ... = x : by rw [←add_smul, hab, one_smul]
intros
simp only [finset.center_mass, hw, inv_one, one_smul]
intros
rw inter_comm
exact hC.inter_left hCA
intros
rw [←inner_conj_sym, conj_re]
intros
rw finsupp.mem_supported' at hl
simp [hv.inner_left_finsupp, hl i hi]
intros
simp only [dist_eq_norm]
{ simp only [dist_eq_norm], exact (hf.sub hg).norm (sub_ne_zero.2 hne) }
exact (hf.sub hg).norm (sub_ne_zero.2 hne)
intros
rw [dist_eq_norm_vsub V, dist_eq_norm, vadd_vsub_vadd_cancel_right]
intros
{ rw [← of_real_norm_eq_coe_nnnorm, norm_of_nonneg hx] }
rw [← of_real_norm_eq_coe_nnnorm, norm_of_nonneg hx]
intros
rcases eq_or_ne c 0 with rfl|hc
simp [hr, zero_smul_set, set.singleton_zero, ← nonempty_closed_ball]
{ simp [hr, zero_smul_set, set.singleton_zero, ← nonempty_closed_ball] }
{ exact smul_closed_ball' hc x r }
exact smul_closed_ball' hc x r
intros
rw [mem_ball, dist_eq_norm]
intros
rw [emetric.mem_ball, edist_eq_coe_nnnorm]
intros
set f' : E →L[𝕜] f.range := f.cod_restrict _ (f : E →ₗ[𝕜] F).mem_range_self
rcases f'.exists_right_inverse_of_surjective (f : E →ₗ[𝕜] F).range_range_restrict with ⟨g, hg⟩
simpa only [ker_cod_restrict] using f'.closed_complemented_ker_of_right_inverse g (ext_iff.1 hg)
intros
simpa using (has_strict_fderiv_at_exp_of_mem_ball hx).has_strict_deriv_at
intros
{ ext m, simp [(subsingleton.elim _ _ : x = m)] }
ext m
simp [(subsingleton.elim _ _ : x = m)]
intros
cases n; [exact hn.false.elim, exact norm_mk_pi_algebra_fin_succ_le]
cases n
exact hn.false.elim
exact norm_mk_pi_algebra_fin_succ_le
intros
rcases h.exists_pos with ⟨C', C'_pos, hC'⟩
apply le_antisymm
intros hatg hatg_in
{ intros hatg hatg_in, rw semi_normed_group.mem_closure_iff, intros ε ε_pos, have hCf : 0 ≤ C'*∥f∥ := (zero_le_mul_left C'_pos).mpr (norm_nonneg f), have ineq : 0 < 1 + C'*∥f∥, by linarith, set δ := ε/(1 + C'*∥f∥), have δ_pos : δ > 0, from div_pos ε_pos ineq, obtain ⟨_, ⟨g : G, rfl⟩, hg : ∥hatg - g∥ < δ⟩ := semi_normed_group.mem_closure_iff.mp (completion.dense_inducing_coe.dense hatg) δ δ_pos, obtain ⟨g' : G, hgg' : f g' = f g, hfg : ∥g'∥ ≤ C' * ∥f g∥⟩ := hC' (f g) (mem_range_self g), have mem_ker : g - g' ∈ f.ker, by rw [f.mem_ker, f.map_sub, sub_eq_zero.mpr hgg'.symm], have : ∥f g∥ ≤ ∥f∥*∥hatg - g∥, calc ∥f g∥ = ∥f.completion g∥ : by rw [f.completion_coe, completion.norm_coe] ... = ∥f.completion g - 0∥ : by rw [sub_zero _] ... = ∥f.completion g - (f.completion hatg)∥ : by rw [(f.completion.mem_ker _).mp hatg_in] ... = ∥f.completion (g - hatg)∥ : by rw [f.completion.map_sub] ... ≤ ∥f.completion∥ * ∥(g :completion G) - hatg∥ : f.completion.le_op_norm _ ... = ∥f∥ * ∥hatg - g∥ : by rw [norm_sub_rev, f.norm_completion], have : ∥(g' : completion G)∥ ≤ C'*∥f∥*∥hatg - g∥, calc ∥(g' : completion G)∥ = ∥g'∥ : completion.norm_coe _ ... ≤ C' * ∥f g∥ : hfg ... ≤ C' * ∥f∥ * ∥hatg - g∥ : by { rw mul_assoc, exact (mul_le_mul_left C'_pos).mpr this }, refine ⟨g - g', _, _⟩, { norm_cast, rw normed_group_hom.comp_range, apply add_subgroup.mem_map_of_mem, simp only [incl_range, mem_ker] }, { calc ∥hatg - (g - g')∥ = ∥hatg - g + g'∥ : by abel ... ≤ ∥hatg - g∥ + ∥(g' : completion G)∥ : norm_add_le _ _ ... < δ + C'*∥f∥*∥hatg - g∥ : by linarith ... ≤ δ + C'*∥f∥*δ : add_le_add_left (mul_le_mul_of_nonneg_left hg.le hCf) δ ... = (1 + C'*∥f∥)*δ : by ring ... = ε : mul_div_cancel' _ ineq.ne.symm } }
rw semi_normed_group.mem_closure_iff
intros ε ε_pos
have hCf : 0 ≤ C'*∥f∥ := (zero_le_mul_left C'_pos).mpr (norm_nonneg f)
have ineq : 0 < 1 + C'*∥f∥
linarith
linarith
set δ := ε/(1 + C'*∥f∥)
have δ_pos : δ > 0
from div_pos ε_pos ineq
obtain ⟨_, ⟨g : G, rfl⟩, hg : ∥hatg - g∥ < δ⟩ := semi_normed_group.mem_closure_iff.mp (completion.dense_inducing_coe.dense hatg) δ δ_pos
obtain ⟨g' : G, hgg' : f g' = f g, hfg : ∥g'∥ ≤ C' * ∥f g∥⟩ := hC' (f g) (mem_range_self g)
have mem_ker : g - g' ∈ f.ker
rw [f.mem_ker, f.map_sub, sub_eq_zero.mpr hgg'.symm]
rw [f.mem_ker, f.map_sub, sub_eq_zero.mpr hgg'.symm]
have : ∥f g∥ ≤ ∥f∥*∥hatg - g∥
calc ∥f g∥ = ∥f.completion g∥ : by rw [f.completion_coe, completion.norm_coe] ... = ∥f.completion g - 0∥ : by rw [sub_zero _] ... = ∥f.completion g - (f.completion hatg)∥ : by rw [(f.completion.mem_ker _).mp hatg_in] ... = ∥f.completion (g - hatg)∥ : by rw [f.completion.map_sub] ... ≤ ∥f.completion∥ * ∥(g :completion G) - hatg∥ : f.completion.le_op_norm _ ... = ∥f∥ * ∥hatg - g∥ : by rw [norm_sub_rev, f.norm_completion]
have : ∥(g' : completion G)∥ ≤ C'*∥f∥*∥hatg - g∥
calc ∥(g' : completion G)∥ = ∥g'∥ : completion.norm_coe _ ... ≤ C' * ∥f g∥ : hfg ... ≤ C' * ∥f∥ * ∥hatg - g∥ : by { rw mul_assoc, exact (mul_le_mul_left C'_pos).mpr this }
refine ⟨g - g', _, _⟩
norm_cast
{ norm_cast, rw normed_group_hom.comp_range, apply add_subgroup.mem_map_of_mem, simp only [incl_range, mem_ker] }
rw normed_group_hom.comp_range
apply add_subgroup.mem_map_of_mem
simp only [incl_range, mem_ker]
calc ∥hatg - (g - g')∥ = ∥hatg - g + g'∥ : by abel ... ≤ ∥hatg - g∥ + ∥(g' : completion G)∥ : norm_add_le _ _ ... < δ + C'*∥f∥*∥hatg - g∥ : by linarith ... ≤ δ + C'*∥f∥*δ : add_le_add_left (mul_le_mul_of_nonneg_left hg.le hCf) δ ... = (1 + C'*∥f∥)*δ : by ring ... = ε : mul_div_cancel' _ ineq.ne.symm
{ calc ∥hatg - (g - g')∥ = ∥hatg - g + g'∥ : by abel ... ≤ ∥hatg - g∥ + ∥(g' : completion G)∥ : norm_add_le _ _ ... < δ + C'*∥f∥*∥hatg - g∥ : by linarith ... ≤ δ + C'*∥f∥*δ : add_le_add_left (mul_le_mul_of_nonneg_left hg.le hCf) δ ... = (1 + C'*∥f∥)*δ : by ring ... = ε : mul_div_cancel' _ ineq.ne.symm }
rw ← f.completion.is_closed_ker.closure_eq
{ rw ← f.completion.is_closed_ker.closure_eq, exact closure_mono f.ker_le_ker_completion }
exact closure_mono f.ker_le_ker_completion
intros
ext
ext; simp
simp
simp
simp
simp
intros
simp [log]
intros
{ rw exp_log_eq_abs (ne_of_lt hx), exact abs_of_neg hx }
rw exp_log_eq_abs (ne_of_lt hx)
exact abs_of_neg hx
intros
cases x
cases n; simp [top_rpow_of_pos (nat.cast_add_one_pos _), top_pow (nat.succ_pos _)]
cases n
{ cases n; simp [top_rpow_of_pos (nat.cast_add_one_pos _), top_pow (nat.succ_pos _)] }
simp [top_rpow_of_pos (nat.cast_add_one_pos _), top_pow (nat.succ_pos _)]
simp [top_rpow_of_pos (nat.cast_add_one_pos _), top_pow (nat.succ_pos _)]
{ simp [coe_rpow_of_nonneg _ (nat.cast_nonneg n)] }
simp [coe_rpow_of_nonneg _ (nat.cast_nonneg n)]
intros
rw [rpow_def_of_pos hx, exp_lt_one_iff, mul_neg_iff, log_pos_iff hx, log_neg_iff hx]
intros
simpa only [(∘), div_eq_inv_mul, mul_one] using (has_strict_deriv_at_sqrt hx).comp x hf
intros
simp only [← complex.cos_sub_pi_div_two, cos_eq_cos_iff, sub_eq_iff_eq_add]
refine exists_congr (λ k, or_congr _ _)
refine exists_congr (λ k, or_congr _ _); refine eq.congr rfl _; field_simp; ring
refine exists_congr (λ k, or_congr _ _); refine eq.congr rfl _; field_simp
refine exists_congr (λ k, or_congr _ _); refine eq.congr rfl _
refine eq.congr rfl _
field_simp
ring
refine eq.congr rfl _
field_simp
ring
intros
rcases exists_between (pos_iff_ne_zero.2 hε) with ⟨r, h0r, hrε⟩
rcases lt_iff_exists_coe.1 hrε with ⟨x, rfl, hx⟩
rcases nnreal.exists_pos_sum_of_encodable (coe_pos.1 h0r).ne' ι with ⟨ε', hp, c, hc, hcr⟩
exact ⟨ε', hp, (ennreal.tsum_coe_eq hc).symm ▸ lt_trans (coe_lt_coe.2 hcr) hrε⟩
intros
rw [sub_def, ←category.comp_id a, ← prod.comp_lift, category.assoc, diag_σ, comp_zero]
intros
rw [hom_equiv_unit, G.map_comp, ← assoc, ←hom_equiv_unit]
intros
substI h; exact epi_of_epi f g
substI h
exact epi_of_epi f g
intros
dsimp only [functor.left_derived, functor.left_derived_obj_iso]
dsimp
simp only [category.comp_id, category.id_comp]
rw [←homology_functor_map, homotopy_category.homology_functor_map_factors]
simp only [←functor.map_comp]
congr' 1
apply homotopy_category.eq_of_homotopy
apply functor.map_homotopy
apply homotopy.trans
exact homotopy_category.homotopy_out_map _
apply ProjectiveResolution.lift_homotopy f
{ simp, }
simp
{ simp [w], }
simp [w]
intros
ext
ext; simp
simp
intros
unfold preimage; obviously
unfold preimage
obviously
intros
simp only [cancel_epi]
intros
apply (cancel_mono (limit_obj_iso_limit_comp_evaluation H k).hom).1
ext
simpa using w j
intros
simp [has_colimit.iso_of_equivalence, is_colimit.cocone_points_iso_of_equivalence_inv]
dsimp
simp
intros
{ ext; simp }
ext
ext; simp
simp
simp
intros
ext
intros
apply (cancel_mono (ρ_ X').hom).1
simp only [assoc, comp_id, iso.inv_hom_id]
rw [right_unitor_naturality, ←category.assoc, iso.inv_hom_id, category.id_comp]
intros
tidy
intros
simp [biprod.of_components]
intros
split
rintro ⟨a, rfl⟩
{ rintro ⟨a, rfl⟩, refl }
refl
rintro rfl
{ rintro rfl, apply singleton.mk, }
apply singleton.mk
intros
{ ext, dsimp, simp }
ext
dsimp
simp
intros
simp [lt_singleton_iff_mem_lt]
intros
have : c.embedding (c.index j) (c.inv_embedding j) ∈ set.range (c.embedding (c.index j)) := set.mem_range_self _
rwa c.embedding_comp_inv j at this
intros
cases d with f s h
simp only [dart.rev, not_and, ne.def]
rintro rfl
exact false.elim (G.loopless _ h)
intros
obtain ⟨f, hf, rfl⟩ := computable_iff.1 hp; exact ⟨by apply_instance, (cond hf (const ff) (const tt)).of_eq (λ n, by {dsimp, cases f n; refl})⟩
obtain ⟨f, hf, rfl⟩ := computable_iff.1 hp
exact ⟨by apply_instance, (cond hf (const ff) (const tt)).of_eq (λ n, by {dsimp, cases f n; refl})⟩
intros
refine ⟨λ h, _, λ h, _⟩
rcases h with ⟨n, ⟨_x, h₁⟩, h₂⟩
{ rcases h with ⟨n, ⟨_x, h₁⟩, h₂⟩, have : ∀ m a' (_: sum.inr a' ∈ F a m) (_: b ∈ pfun.fix f a'), b ∈ pfun.fix f a, { intros m a' am ba, induction m with m IH generalizing a'; simp [F] at am, { rwa ← am }, rcases am with ⟨a₂, am₂, fa₂⟩, exact IH _ am₂ (pfun.mem_fix_iff.2 (or.inr ⟨_, fa₂, ba⟩)) }, cases n; simp [F] at h₂, {cases h₂}, rcases h₂ with h₂ | ⟨a', am', fa'⟩, { cases h₁ (nat.lt_succ_self _) with a' h, injection mem_unique h h₂ }, { exact this _ _ am' (pfun.mem_fix_iff.2 (or.inl fa')) } }
have : ∀ m a' (_: sum.inr a' ∈ F a m) (_: b ∈ pfun.fix f a'), b ∈ pfun.fix f a
intros m a' am ba
{ intros m a' am ba, induction m with m IH generalizing a'; simp [F] at am, { rwa ← am }, rcases am with ⟨a₂, am₂, fa₂⟩, exact IH _ am₂ (pfun.mem_fix_iff.2 (or.inr ⟨_, fa₂, ba⟩)) }
induction m with m IH generalizing a'; simp [F] at am
induction m with m IH generalizing a'
simp [F] at am
{ rwa ← am }
rwa ← am
simp [F] at am
rcases am with ⟨a₂, am₂, fa₂⟩
exact IH _ am₂ (pfun.mem_fix_iff.2 (or.inr ⟨_, fa₂, ba⟩))
cases n; simp [F] at h₂
cases n
simp [F] at h₂
cases h₂
{cases h₂}
simp [F] at h₂
rcases h₂ with h₂ | ⟨a', am', fa'⟩
cases h₁ (nat.lt_succ_self _) with a' h
{ cases h₁ (nat.lt_succ_self _) with a' h, injection mem_unique h h₂ }
injection mem_unique h h₂
{ exact this _ _ am' (pfun.mem_fix_iff.2 (or.inl fa')) }
exact this _ _ am' (pfun.mem_fix_iff.2 (or.inl fa'))
suffices : ∀ a' (_: b ∈ pfun.fix f a') k (_: sum.inr a' ∈ F a k), ∃ n, sum.inl b ∈ F a n ∧ ∀ (m < n) (_ : k ≤ m), ∃ a₂, sum.inr a₂ ∈ F a m
{ suffices : ∀ a' (_: b ∈ pfun.fix f a') k (_: sum.inr a' ∈ F a k), ∃ n, sum.inl b ∈ F a n ∧ ∀ (m < n) (_ : k ≤ m), ∃ a₂, sum.inr a₂ ∈ F a m, { rcases this _ h 0 (by simp [F]) with ⟨n, hn₁, hn₂⟩, exact ⟨_, ⟨⟨_, hn₁⟩, λ m mn, hn₂ m mn (nat.zero_le _)⟩, hn₁⟩ }, intros a₁ h₁, apply pfun.fix_induction h₁, intros a₂ h₂ IH k hk, rcases pfun.mem_fix_iff.1 h₂ with h₂ | ⟨a₃, am₃, fa₃⟩, { refine ⟨k.succ, _, λ m mk km, ⟨a₂, _⟩⟩, { simp [F], exact or.inr ⟨_, hk, h₂⟩ }, { rwa le_antisymm (nat.le_of_lt_succ mk) km } }, { rcases IH _ fa₃ am₃ k.succ _ with ⟨n, hn₁, hn₂⟩, { refine ⟨n, hn₁, λ m mn km, _⟩, cases km.lt_or_eq_dec with km km, { exact hn₂ _ mn km }, { exact km ▸ ⟨_, hk⟩ } }, { simp [F], exact ⟨_, hk, am₃⟩ } } }
rcases this _ h 0 (by simp [F]) with ⟨n, hn₁, hn₂⟩
{ rcases this _ h 0 (by simp [F]) with ⟨n, hn₁, hn₂⟩, exact ⟨_, ⟨⟨_, hn₁⟩, λ m mn, hn₂ m mn (nat.zero_le _)⟩, hn₁⟩ }
exact ⟨_, ⟨⟨_, hn₁⟩, λ m mn, hn₂ m mn (nat.zero_le _)⟩, hn₁⟩
intros a₁ h₁
apply pfun.fix_induction h₁
intros a₂ h₂ IH k hk
rcases pfun.mem_fix_iff.1 h₂ with h₂ | ⟨a₃, am₃, fa₃⟩
refine ⟨k.succ, _, λ m mk km, ⟨a₂, _⟩⟩
{ refine ⟨k.succ, _, λ m mk km, ⟨a₂, _⟩⟩, { simp [F], exact or.inr ⟨_, hk, h₂⟩ }, { rwa le_antisymm (nat.le_of_lt_succ mk) km } }
{ simp [F], exact or.inr ⟨_, hk, h₂⟩ }
simp [F]
exact or.inr ⟨_, hk, h₂⟩
{ rwa le_antisymm (nat.le_of_lt_succ mk) km }
rwa le_antisymm (nat.le_of_lt_succ mk) km
rcases IH _ fa₃ am₃ k.succ _ with ⟨n, hn₁, hn₂⟩
{ rcases IH _ fa₃ am₃ k.succ _ with ⟨n, hn₁, hn₂⟩, { refine ⟨n, hn₁, λ m mn km, _⟩, cases km.lt_or_eq_dec with km km, { exact hn₂ _ mn km }, { exact km ▸ ⟨_, hk⟩ } }, { simp [F], exact ⟨_, hk, am₃⟩ } }
refine ⟨n, hn₁, λ m mn km, _⟩
{ refine ⟨n, hn₁, λ m mn km, _⟩, cases km.lt_or_eq_dec with km km, { exact hn₂ _ mn km }, { exact km ▸ ⟨_, hk⟩ } }
cases km.lt_or_eq_dec with km km
exact hn₂ _ mn km
{ exact hn₂ _ mn km }
exact km ▸ ⟨_, hk⟩
{ exact km ▸ ⟨_, hk⟩ }
{ simp [F], exact ⟨_, hk, am₃⟩ }
simp [F]
exact ⟨_, hk, am₃⟩
intros
letI := primcodable.subtype hp
refine (primcodable.prim (subtype p)).of_eq (λ n, _)
rcases decode (subtype p) n with _|⟨a,h⟩
rcases decode (subtype p) n with _|⟨a,h⟩; refl
refl
refl
intros
rw list_blank.nth_map; refl
rw list_blank.nth_map
refl
intros
induction ab with c₂ d₂ ac cd IH
exact ⟨_, _, refl_trans_gen.refl, aa, refl_trans_gen.refl⟩
{ exact ⟨_, _, refl_trans_gen.refl, aa, refl_trans_gen.refl⟩ }
rcases IH with ⟨e₁, e₂, ce, ee, ae⟩
{ rcases IH with ⟨e₁, e₂, ce, ee, ae⟩, rcases refl_trans_gen.cases_head ce with rfl | ⟨d', cd', de⟩, { have := H ee, revert this, cases eg : f₁ e₁ with g₁; simp only [respects, and_imp, exists_imp_distrib], { intro c0, cases cd.symm.trans c0 }, { intros g₂ gg cg, rcases trans_gen.head'_iff.1 cg with ⟨d', cd', dg⟩, cases option.mem_unique cd cd', exact ⟨_, _, dg, gg, ae.tail eg⟩ } }, { cases option.mem_unique cd cd', exact ⟨_, _, de, ee, ae⟩ } }
rcases refl_trans_gen.cases_head ce with rfl | ⟨d', cd', de⟩
have := H ee
{ have := H ee, revert this, cases eg : f₁ e₁ with g₁; simp only [respects, and_imp, exists_imp_distrib], { intro c0, cases cd.symm.trans c0 }, { intros g₂ gg cg, rcases trans_gen.head'_iff.1 cg with ⟨d', cd', dg⟩, cases option.mem_unique cd cd', exact ⟨_, _, dg, gg, ae.tail eg⟩ } }
revert this
cases eg : f₁ e₁ with g₁; simp only [respects, and_imp, exists_imp_distrib]
cases eg : f₁ e₁ with g₁
simp only [respects, and_imp, exists_imp_distrib]
{ intro c0, cases cd.symm.trans c0 }
intro c0
cases cd.symm.trans c0
simp only [respects, and_imp, exists_imp_distrib]
intros g₂ gg cg
{ intros g₂ gg cg, rcases trans_gen.head'_iff.1 cg with ⟨d', cd', dg⟩, cases option.mem_unique cd cd', exact ⟨_, _, dg, gg, ae.tail eg⟩ }
rcases trans_gen.head'_iff.1 cg with ⟨d', cd', dg⟩
cases option.mem_unique cd cd'
exact ⟨_, _, dg, gg, ae.tail eg⟩
cases option.mem_unique cd cd'
{ cases option.mem_unique cd cd', exact ⟨_, _, de, ee, ae⟩ }
exact ⟨_, _, de, ee, ae⟩
intros
dsimp [part.fix]; rw assert_neg h'
dsimp [part.fix]
rw assert_neg h'
intros
by_cases hh : ∃ i b, b ∈ approx f i x
rcases hh with ⟨i,b,hb⟩
{ rcases hh with ⟨i,b,hb⟩, existsi i, intros b' h', have hb' := approx_le_fix f i _ _ hb, have hh := part.mem_unique h' hb', subst hh, exact hb }
existsi i
intros b' h'
have hb' := approx_le_fix f i _ _ hb
have hh := part.mem_unique h' hb'
subst hh
exact hb
{ simp only [not_exists] at hh, existsi 0, intros b' h', simp only [mem_iff f] at h', cases h' with i h', cases hh _ _ h' }
simp only [not_exists] at hh
existsi 0
intros b' h'
simp only [mem_iff f] at h'
cases h' with i h'
cases hh _ _ h'
intros
{ ext y, exact preserves_map η x y }
ext y
exact preserves_map η x y
intros
rw @map_eq_traverse_id t _ _ _ _ f
refine (comp_traverse (id.mk ∘ f) g x).symm.trans _
congr
apply comp.applicative_comp_id
intros
rw [to_fin, fin.coe_of_nat_eq_mod', nat.mod_eq_of_lt]
rw [to_fin, fin.coe_of_nat_eq_mod', nat.mod_eq_of_lt]; apply to_nat_lt
apply to_nat_lt
intros
convert read_to_buffer' _ _ _
{ convert read_to_buffer' _ _ _, { simp }, { simpa using i.property } }
simp
{ simp }
simpa using i.property
{ simpa using i.property }
intros
cases h : p cb n; simp [decorate_errors, h, eq_comm]
cases h : p cb n
simp [decorate_errors, h, eq_comm]
simp [decorate_errors, h, eq_comm]
intros
cases hp : p cb n with np resp np errp
{ simp [hp, ←orelse_eq_orelse, parser.orelse] }
simp [hp, ←orelse_eq_orelse, parser.orelse]
by_cases hn : np = n
{ by_cases hn : np = n, { cases hq : q cb n with nq resq nq errq, { simp [hp, hn, hq, ←orelse_eq_orelse, parser.orelse] }, { rcases lt_trichotomy nq n with H|rfl|H; simp [hp, hn, hq, H, not_lt_of_lt H, lt_irrefl, ←orelse_eq_orelse, parser.orelse] <|> simp [hp, hn, hq, lt_irrefl, ←orelse_eq_orelse, parser.orelse] } }, { simp [hp, hn, ←orelse_eq_orelse, parser.orelse] } }
cases hq : q cb n with nq resq nq errq
{ cases hq : q cb n with nq resq nq errq, { simp [hp, hn, hq, ←orelse_eq_orelse, parser.orelse] }, { rcases lt_trichotomy nq n with H|rfl|H; simp [hp, hn, hq, H, not_lt_of_lt H, lt_irrefl, ←orelse_eq_orelse, parser.orelse] <|> simp [hp, hn, hq, lt_irrefl, ←orelse_eq_orelse, parser.orelse] } }
{ simp [hp, hn, hq, ←orelse_eq_orelse, parser.orelse] }
simp [hp, hn, hq, ←orelse_eq_orelse, parser.orelse]
rcases lt_trichotomy nq n with H|rfl|H; simp [hp, hn, hq, H, not_lt_of_lt H, lt_irrefl, ←orelse_eq_orelse, parser.orelse] <|> simp [hp, hn, hq, lt_irrefl, ←orelse_eq_orelse, parser.orelse]
rcases lt_trichotomy nq n with H|rfl|H
{ rcases lt_trichotomy nq n with H|rfl|H; simp [hp, hn, hq, H, not_lt_of_lt H, lt_irrefl, ←orelse_eq_orelse, parser.orelse] <|> simp [hp, hn, hq, lt_irrefl, ←orelse_eq_orelse, parser.orelse] }
simp [hp, hn, hq, H, not_lt_of_lt H, lt_irrefl, ←orelse_eq_orelse, parser.orelse]
simp [hp, hn, hq, H, not_lt_of_lt H, lt_irrefl, ←orelse_eq_orelse, parser.orelse]
simp [hp, hn, hq, lt_irrefl, ←orelse_eq_orelse, parser.orelse]
simp [hp, hn, hq, H, not_lt_of_lt H, lt_irrefl, ←orelse_eq_orelse, parser.orelse]
{ simp [hp, hn, ←orelse_eq_orelse, parser.orelse] }
simp [hp, hn, ←orelse_eq_orelse, parser.orelse]
intros
dsimp only [sat]
split_ifs; simp [*, eq_comm]
split_ifs
simp [*, eq_comm]
simp [*, eq_comm]
simp [*, eq_comm]
intros
simp [many_char1, ←string.nil_as_string_eq_empty]
intros
simp [div_eq_mul_inv, mul_assoc, sub_eq_add_neg]
intros
rw [le_def, not_and_distrib, not_le]
intros
rw [← of_real_exp_of_real_re, of_real_im]
intros
rw [← cosh_add_sinh, sinh_mul_I, cosh_mul_I]
intros
simp only [I_re, zero_sub, I_im', zero_mul, mul_re]
intros
{ ext, simp [smul_ite] }
ext
simp [smul_ite]
intros
refine add_monoid_hom.eq_of_eq_on_mdense add_closure_Union_range_single (λ f hf, _)
simp only [set.mem_Union, set.mem_range] at hf
rcases hf with ⟨x, y, rfl⟩
apply H
intros
ext
{ ext, refl }
refl
intros
{ ext x, by_cases h : p x; simp [h] }
ext x
by_cases h : p x
by_cases h : p x; simp [h]
simp [h]
simp [h]
intros
split
{ simp [he.1] }
simp [he.1]
assume x hx
{ assume x hx, simp only [mem_inter_eq, restr_source] at hx, exact he.2 hx.1 }
simp only [mem_inter_eq, restr_source] at hx
exact he.2 hx.1
intros
ext i
have h' := fin.cast_lt_cast_succ i i.is_lt
simp [init, snoc, i.is_lt, h']
convert cast_eq rfl (p i)
intros
simp [fin.eq_iff_veq]
intros
rw [reverse_induction, dif_neg (ne_of_lt (fin.cast_succ_lt_last i))]
cases i
refl
intros
cases s₁; cases s₂; refl
cases s₁; cases s₂
cases s₁
cases s₂
refl
intros
ext
ext; simp
simp
intros
simp [finset.ext_iff, perm_ext (nodup_erase_dup _) (nodup_erase_dup _)]
intros
simp only [← not_nonempty_iff_eq_empty, sigma_nonempty, not_exists]
intros
split
split; intro t
intro t
rw t
refine ⟨finset.mem_singleton_self _, λ _, finset.mem_singleton.1⟩
intro t
ext
rw finset.mem_singleton
refine ⟨t.right _, λ r, r.symm ▸ t.left⟩
intros
rw [← union_eq_left_iff_subset, eq_comm]
intros
simp only [finset.supr_insert, update_same]
rcongr i hi
apply update_noteq
rintro rfl
exact hx hi
intros
rw le_iff_exists_add
use kl.2
rwa [mem_antidiagonal, eq_comm] at hlk
intros
ext
{ ext, simp }
simp
intros
rw [subsingleton.elim i ⟨0, zero_lt_one⟩, order_emb_of_fin_zero _ zero_lt_one, min'_singleton]
intros
ext x
ext x; simp [map_domain_equiv_apply]
simp [map_domain_equiv_apply]
intros
split
intro h
{ intro h, exact ⟨h.1, card_congr (equiv.of_bijective f h)⟩ }
exact ⟨h.1, card_congr (equiv.of_bijective f h)⟩
rintro ⟨hf, h⟩
{ rintro ⟨hf, h⟩, refine ⟨hf, _⟩, rwa ←injective_iff_surjective_of_equiv (equiv_of_card_eq h) }
refine ⟨hf, _⟩
rwa ←injective_iff_surjective_of_equiv (equiv_of_card_eq h)
intros
let q
swap
change quotient.lift_on q _ _ = _
have : q = ⟦λ i h, f i⟧
dsimp [q]
{ dsimp [q], exact quotient.induction_on (@finset.univ ι _).1 (λ l, quotient.fin_choice_aux_eq _ _) }
exact quotient.induction_on (@finset.univ ι _).1 (λ l, quotient.fin_choice_aux_eq _ _)
simp [this]
exact setoid.refl _
intros
classical
by_contra hf
push_neg at hf
haveI := λ y, fintype_of_not_infinite $ hf y
let key : fintype α := { elems := univ.bUnion (λ (y : β), (f ⁻¹' {y}).to_finset), complete := by simp }
exact key.false
intros
rw ← of_equiv_card f; congr
rw ← of_equiv_card f
congr
intros
simp only [prod_dite, attach_eq_univ]
congr' 1
convert (equiv.subtype_equiv_right _).prod_comp (λ x : {x // p x}, f x x.2)
{ convert (equiv.subtype_equiv_right _).prod_comp (λ x : {x // p x}, f x x.2), simp }
simp
convert (equiv.subtype_equiv_right _).prod_comp (λ x : {x // ¬p x}, g x x.2)
{ convert (equiv.subtype_equiv_right _).prod_comp (λ x : {x // ¬p x}, g x x.2), simp }
simp
intros
lift a to ℕ using ha
norm_cast
intros
simp [neg_succ_of_nat_eq, sub_eq_neg_add]
intros
rw [mul_comm i k, mul_comm j k] at H; exact dvd_of_mul_dvd_mul_left k_non_zero H
rw [mul_comm i k, mul_comm j k] at H
exact dvd_of_mul_dvd_mul_left k_non_zero H
intros
rwa [← hx, ← hy, int.coe_nat_lcm]
intros
{ rw [add_comm a, add_comm b] at h₂, exact h₁.add_left_cancel h₂ }
rw [add_comm a, add_comm b] at h₂
exact h₁.add_left_cancel h₂
simp [← set.compl_set_of, is_compl_compl]
intros
induction l with hd tl IH
intros n hn m hm h
{ intros n hn m hm h, simp only [set.mem_singleton_iff, set.set_of_eq_eq_singleton, length, nonpos_iff_eq_zero] at hn hm, simp [hn, hm] }
simp only [set.mem_singleton_iff, set.set_of_eq_eq_singleton, length, nonpos_iff_eq_zero] at hn hm
simp [hn, hm]
intros n hn m hm h
{ intros n hn m hm h, simp only [length, set.mem_set_of_eq] at hn hm, simp only [mem_cons_iff, not_or_distrib] at hx, cases n; cases m, { refl }, { simpa [hx.left] using h }, { simpa [ne.symm hx.left] using h }, { simp only [true_and, eq_self_iff_true, insert_nth_succ_cons] at h, rw nat.succ_inj', refine IH hx.right _ _ h, { simpa [nat.succ_le_succ_iff] using hn }, { simpa [nat.succ_le_succ_iff] using hm } } }
simp only [length, set.mem_set_of_eq] at hn hm
simp only [mem_cons_iff, not_or_distrib] at hx
cases n; cases m
cases n
cases m
{ refl }
refl
{ simpa [hx.left] using h }
simpa [hx.left] using h
cases m
{ simpa [ne.symm hx.left] using h }
simpa [ne.symm hx.left] using h
simp only [true_and, eq_self_iff_true, insert_nth_succ_cons] at h
{ simp only [true_and, eq_self_iff_true, insert_nth_succ_cons] at h, rw nat.succ_inj', refine IH hx.right _ _ h, { simpa [nat.succ_le_succ_iff] using hn }, { simpa [nat.succ_le_succ_iff] using hm } }
rw nat.succ_inj'
refine IH hx.right _ _ h
{ simpa [nat.succ_le_succ_iff] using hn }
simpa [nat.succ_le_succ_iff] using hn
{ simpa [nat.succ_le_succ_iff] using hm }
simpa [nat.succ_le_succ_iff] using hm
intros
simp [take_append_eq_append_take, take_all_of_le le_self_add]
intros
induction l with hd tl ih
refl
{refl}
simp only [mem_cons_iff, or_imp_distrib, forall_and_distrib, forall_eq] at H
simp only [foldr, ih H.2, H.1]
intros
rw [foldl_cons, hc.comm, foldl_assoc]
intros
{ cases L, { simp at h, cases h, }, { simp, }, }
cases L
simp at h
{ simp at h, cases h, }
cases h
simp
{ simp, }
intros
rw [← filter_map_eq_map, filter_map_filter_map]
rw [← filter_map_eq_map, filter_map_filter_map]; refl
refl
intros
rw [eq_comm, append_eq_cons_iff]
intros
rw [← permutations_aux2_append, map_permutations_aux2, permutations_aux2_comp_append]
intros
cases n; refl
cases n
refl
refl
intros
simp only [concat_eq_append, reverse_cons, reverse_reverse]
intros
rw [prev, dif_pos hx]
intros
induction xs with z zs IH
{ simp }
simp
obtain ⟨hz, hzs⟩ := not_or_distrib.mp (mt (mem_cons_iff _ _ _).mp h)
{ obtain ⟨hz, hzs⟩ := not_or_distrib.mp (mt (mem_cons_iff _ _ _).mp h), rw [cons_append, next_or_cons_of_ne _ _ _ _ hz, IH hzs] }
rw [cons_append, next_or_cons_of_ne _ _ _ _ hz, IH hzs]
intros
induction as generalizing start
{ refl }
refl
simp [mmap_with_index_aux, mmap_with_index_aux_spec_cons, *]
{ simp [mmap_with_index_aux, mmap_with_index_aux_spec_cons, *] }
intros
induction d with b l m d IH
refl
{refl}
by_cases b = a
subst h
{ subst h, rw [erase_cons_head, filter_cons_of_neg], symmetry, rw filter_eq_self, simpa only [ne.def, eq_comm] using m, exact not_not_intro rfl }
rw [erase_cons_head, filter_cons_of_neg]
symmetry
rw filter_eq_self
simpa only [ne.def, eq_comm] using m
exact not_not_intro rfl
rw [erase_cons_tail _ h, filter_cons_of_pos, IH]
{ rw [erase_cons_tail _ h, filter_cons_of_pos, IH], exact h }
exact h
intros
simp only [enum_from_eq_zip_range', unzip_zip, length_range']
intros
refine ⟨λ h, _, λ h, by simp [cyclic_permutations, h, init_eq_take]⟩
rw [eq_comm, ←is_rotated_singleton_iff', ←mem_cyclic_permutations_iff, h, mem_singleton]
intros
simp [kerase, h]
intros
cases l
cases l; refl
refl
refl
intros
{ ext, apply add_dot_product }
ext
apply add_dot_product
intros
{ ext, simp [h], }
ext
simp [h]
intros
simp [diagonal, h]
intros
simp [dot_product]
intros
{ ext, apply smul_dot_product, }
ext
apply smul_dot_product
intros
ext
simp only [block_diagonal_apply, pi.add_apply]
split_ifs; simp
split_ifs
simp
simp
intros
{ ext, simp [vec_tail] }
ext
simp [vec_tail]
intros
{ ext i, refine fin.cases _ _ i; simp [vec_head, vec_tail] }
ext i
refine fin.cases _ _ i
refine fin.cases _ _ i; simp [vec_head, vec_tail]
simp [vec_head, vec_tail]
simp [vec_head, vec_tail]
intros
rw [add_comm, erase_add_right_neg s h, add_comm]
intros
rw [← sup_erase_dup, erase_dup_ext.2, sup_erase_dup, sup_add]
rw [← sup_erase_dup, erase_dup_ext.2, sup_erase_dup, sup_add]; simp
simp
intros
{ ext, exacts [hC _, hX _] }
ext
exacts [hC _, hX _]
intros
simp only [monomial_eq, ring_hom.map_mul, eval₂_hom_C, finsupp.prod, ring_hom.map_prod, ring_hom.map_pow, eval₂_hom_X']
intros
rw ←vars_neg q at hpq
convert vars_add_of_disjoint hpq using 2
convert vars_add_of_disjoint hpq using 2; simp [sub_eq_add_neg]
simp [sub_eq_add_neg]
simp [sub_eq_add_neg]
intros
simp only [join₂, bind₂, eval₂_hom_map_hom, ring_hom.id_comp]
intros
rw [vars, degrees_zero, multiset.to_finset_zero]
intros
conv {to_lhs, rw [← mul_one(m)]}
exact decidable.mul_le_mul_of_nonneg_left (nat.succ_le_of_lt h) dec_trivial
intros
cases b; norm_num [bit0_eq_zero, nat.bit1_ne_zero]
{ cases b; norm_num [bit0_eq_zero, nat.bit1_ne_zero] }
cases b
norm_num [bit0_eq_zero, nat.bit1_ne_zero]
norm_num [bit0_eq_zero, nat.bit1_ne_zero]
intros
split_ifs; refl
{ split_ifs; refl, }
split_ifs
refl
refl
intros
rw [add_comm k n, add_comm k m]
apply dist_add_add_right
intros
apply enat.cases_on a; apply enat.cases_on b; simp; simp only [(nat.cast_add _ _).symm, enat.coe_ne_top]; simp
apply enat.cases_on a; apply enat.cases_on b; simp; simp only [(nat.cast_add _ _).symm, enat.coe_ne_top]
apply enat.cases_on a; apply enat.cases_on b; simp
apply enat.cases_on a; apply enat.cases_on b
apply enat.cases_on a
apply enat.cases_on b
simp
simp
apply enat.cases_on b
simp
simp
simp only [(nat.cast_add _ _).symm, enat.coe_ne_top]
simp
intros
rwa [gcd_eq_left_iff_dvd, ← fib_gcd, gcd_eq_left_iff_dvd.mp]
intros
rw [clog, if_pos (⟨hb, hn⟩ : 1 < b ∧ 1 < n)]
intros
rw [← (supr_prod : (⨆ i : ℕ × ℕ, f i.1 i.2) = _), ← nat.surjective_unpair.supr_comp]
intros
rw lt_size; refl
rw lt_size
refl
intros
rw ← not_lt; exact not_congr cast_lt
rw ← not_lt
exact not_congr cast_lt
intros
cases x; simp only [pbind, none_bind', some_bind']
{ cases x; simp only [pbind, none_bind', some_bind'] }
cases x
simp only [pbind, none_bind', some_bind']
simp only [pbind, none_bind', some_bind']
intros
cases x; [contradiction, rw get_or_else_some]
cases x
contradiction
rw get_or_else_some
intros
rw [balance_l_eq_balance hl.2 hr.2 H₁ H₂, balance_eq_balance' hl.3 hr.3 hl.2 hr.2]
refine hl.balance'_aux hr (or.inl _) H₃
cases nat.eq_zero_or_pos (size r) with r0 r0
{ rw r0, exact nat.zero_le _ }
rw r0
exact nat.zero_le _
cases nat.eq_zero_or_pos (size l) with l0 l0
rw l0
{ rw l0, exact le_trans (nat.mul_le_mul_left _ (H₁ l0)) dec_trivial }
exact le_trans (nat.mul_le_mul_left _ (H₁ l0)) dec_trivial
replace H₂ : _ ≤ 3 * _ := H₂ l0 r0
linarith
intros
rw [← dual_dual (rotate_l _ _ _), dual_rotate_l, dual_dual, dual_dual]
intros
rw [← dual_dual (erase_min _), dual_erase_min, dual_dual]
intros
dsimp [of_set]
split_ifs
simp only [iff_self_and, option.mem_def, eq_comm]
{ simp only [iff_self_and, option.mem_def, eq_comm], rintro rfl, exact h, }
rintro rfl
exact h
simp only [false_iff, not_and, option.not_mem_none]
{ simp only [false_iff, not_and, option.not_mem_none], rintro rfl, exact h, }
rintro rfl
exact h
intros
cases h₁.symm.trans h₂; refl
cases h₁.symm.trans h₂
refl
intros
{ constructor }
constructor
intros
dsimp [div, mod_div]
cases (m : ℕ) % (k : ℕ)
{ rw [if_pos rfl], refl }
rw [if_pos rfl]
refl
{ rw [if_neg n.succ_ne_zero], refl }
rw [if_neg n.succ_ne_zero]
refl
intros
simp [to_finsupp_iso, monomial, monomial_fun]
intros
induction n with n hn
{ rw [pow_zero, monomial_zero_one] }
rw [pow_zero, monomial_zero_one]
{ rw [pow_succ', hn, X, monomial_mul_monomial, one_mul] }
rw [pow_succ', hn, X, monomial_mul_monomial, one_mul]
intros
by_cases ha : a = 0
have : C a = 0
{ have : C a = 0, { rw [ha, C_0] }, rw [nat_degree, degree_eq_bot.2 this], refl }
rw [ha, C_0]
{ rw [ha, C_0] }
rw [nat_degree, degree_eq_bot.2 this]
refl
{ rw [nat_degree, degree_C ha], refl }
rw [nat_degree, degree_C ha]
refl
intros
rw [ne.def, leading_coeff_eq_zero]
intros
rw [← nonpos_iff_eq_zero, nat_degree_le_iff_degree_le, with_bot.coe_zero]
intros
by_cases p0 : p = 0
{ rw [p0, mul_zero] }
rw [p0, mul_zero]
exact nat_degree_C_mul_eq_of_mul_ne_zero (mul_ne_zero a0 (leading_coeff_ne_zero.mpr p0))
{ exact nat_degree_C_mul_eq_of_mul_ne_zero (mul_ne_zero a0 (leading_coeff_ne_zero.mpr p0)) }
intros
rw [trailing_degree_eq_nat_trailing_degree hp, with_top.coe_eq_coe]
intros
ext
exact P.eval_eq_finset_sum x
intros
have A : p.nat_degree < p.nat_degree.succ := nat.lt_succ_self _
have B : (s • p).nat_degree < p.nat_degree.succ := (nat_degree_smul_le _ _).trans_lt A
rw [eval₂_eq_sum, eval₂_eq_sum, sum_over_range' _ _ _ A, sum_over_range' _ _ _ B]
rw [eval₂_eq_sum, eval₂_eq_sum, sum_over_range' _ _ _ A, sum_over_range' _ _ _ B]; simp [mul_sum, mul_assoc]
simp [mul_sum, mul_assoc]
simp [mul_sum, mul_assoc]
simp [mul_sum, mul_assoc]
simp [mul_sum, mul_assoc]
simp [mul_sum, mul_assoc]
intros
induction n with n ih
{ simp only [iterated_deriv_zero_right] }
simp only [iterated_deriv_zero_right]
{ simp only [iterated_deriv_succ, ih, derivative_smul] }
simp only [iterated_deriv_succ, ih, derivative_smul]
intros
simp [mirror]
intros
by_cases hq : q = 0; simp [h.mul_right_ne_zero, hq]
by_cases hq : q = 0
simp [h.mul_right_ne_zero, hq]
simp [h.mul_right_ne_zero, hq]
intros
rw [leading_coeff, reverse_nat_degree, ←rev_at_le f.nat_trailing_degree_le_nat_degree, coeff_reverse, rev_at_invol, trailing_coeff]
intros
simp_rw [is_root, eval_mul, mul_eq_zero]
intros
rw ←abs_repr x
cases repr x with a f
rw [←abs_map, mvpfunctor.map_eq]
rw [supp_eq_of_is_uniform h, supp_eq_of_is_uniform h, ← image_comp]
refl
intros
rw coe_int_eq_of_int; refl
rw coe_int_eq_of_int
refl
intros
rw [← cast_zero, cast_lt]
linarith [gold_add_gold_conj]
intros
rw [← and_iff_right_of_imp (λ h, (sqrt_nonneg x).trans h), and.congr_right_iff]
exact sqrt_le_left
intros
simp [set.preimage, function.graph, rel.core]
intros
haveI := of_think_terminates h.terminates
have := results_of_terminates' _ (of_think_mem h.mem)
exact ⟨_, this, results.len_unique h (results_think this)⟩
intros
rw [lift_rel.swap, lift_rel_return_left]
intros
cases s with st
have : st n = some a
from s_nth_eq_some
cases s' with st'
have : st' n = some b
from s_nth_eq_some'
simp only [zip_with, seq.nth, *]
intros
{ ext, split; simp [or_imp_distrib, h] {contextual := tt} }
ext
split
split; simp [or_imp_distrib, h] {contextual := tt}
simp [or_imp_distrib, h] {contextual := tt}
simp [or_imp_distrib, h] {contextual := tt}
intros
suffices : ∀ x, xᶜ = t ↔ tᶜ = x
simp [this]
{ simp [this] }
intro x
split
split; { intro e, subst e, simp }
{ intro e, subst e, simp }
intro e
{ intro e, subst e, simp }
subst e
simp
intros
rw [← image_comp, h.comp_eq_id, image_id]
intros
rw [← range_iff_surjective, range_inclusion, eq_univ_iff_forall] at h_surj
exact set.subset.antisymm h (λ x hx, h_surj ⟨x, hx⟩)
intros
simp only [insert_subset, exists_and_distrib_right, ssubset_def, not_subset]
simp only [exists_prop, and_comm]
intros
letI : encodable s := countable.to_encodable hc
letI : nonempty s := hs.to_subtype
have : countable (univ : set s) := countable_encodable _
rcases countable_iff_exists_surjective.1 this with ⟨g, hg⟩
have : range g = univ := univ_subset_iff.1 hg
use coe ∘ g
simp only [range_comp, this, image_univ, subtype.range_coe]
intros
{ ext i, simp [piecewise] }
ext i
simp [piecewise]
intros
{ ext x, simp [Iic] }
ext x
simp [Iic]
intros
rw [e.image_eq_preimage, e.symm.preimage_Icc, e.symm_symm]
intros
rw [diff_eq, compl_Ici, Ici_inter_Iio]
intros
simp [lt_irrefl]
intros
simp [add_comm]
intros
simp [sub_eq_neg_add]
intros
rcases lt_or_eq_of_le hab with hab|hab
intros p hp
{ intros p hp, rcases mem_Ioo_or_eq_endpoints_of_mem_Icc hp with hp'|⟨hp'|hp'⟩, { rw hp', refine ⟨a, left_mem_Icc.mpr (le_of_lt hab), rfl⟩ }, { rw hp', refine ⟨b, right_mem_Icc.mpr (le_of_lt hab), rfl⟩ }, { have := surj_on_Ioo_of_monotone_surjective h_mono h_surj a b hp', cases this with x hx, exact ⟨x, Ioo_subset_Icc_self hx.1, hx.2⟩ } }
rcases mem_Ioo_or_eq_endpoints_of_mem_Icc hp with hp'|⟨hp'|hp'⟩
rw hp'
{ rw hp', refine ⟨a, left_mem_Icc.mpr (le_of_lt hab), rfl⟩ }
refine ⟨a, left_mem_Icc.mpr (le_of_lt hab), rfl⟩
rw hp'
{ rw hp', refine ⟨b, right_mem_Icc.mpr (le_of_lt hab), rfl⟩ }
refine ⟨b, right_mem_Icc.mpr (le_of_lt hab), rfl⟩
have := surj_on_Ioo_of_monotone_surjective h_mono h_surj a b hp'
{ have := surj_on_Ioo_of_monotone_surjective h_mono h_surj a b hp', cases this with x hx, exact ⟨x, Ioo_subset_Icc_self hx.1, hx.2⟩ }
cases this with x hx
exact ⟨x, Ioo_subset_Icc_self hx.1, hx.2⟩
simp only [hab, Icc_self]
{ simp only [hab, Icc_self], intros _ hp, exact ⟨b, mem_singleton _, (mem_singleton_iff.mp hp).symm⟩ }
intros _ hp
exact ⟨b, mem_singleton _, (mem_singleton_iff.mp hp).symm⟩
intros
refine set.ext (λ c, iff.intro _ _)
rintro ⟨f, hfs, b, ⟨g, hg, a, hau, rfl⟩, rfl⟩
{ rintro ⟨f, hfs, b, ⟨g, hg, a, hau, rfl⟩, rfl⟩, exact ⟨f ∘ g, ⟨(∘) f, mem_image_of_mem _ hfs, g, hg, rfl⟩, a, hau, rfl⟩ }
exact ⟨f ∘ g, ⟨(∘) f, mem_image_of_mem _ hfs, g, hg, rfl⟩, a, hau, rfl⟩
rintro ⟨fg, ⟨fc, ⟨f, hfs, rfl⟩, g, hgt, rfl⟩, a, ha, rfl⟩
{ rintro ⟨fg, ⟨fc, ⟨f, hfs, rfl⟩, g, hgt, rfl⟩, a, ha, rfl⟩, exact ⟨f, hfs, g a, ⟨g, hgt, a, ha, rfl⟩, rfl⟩ }
exact ⟨f, hfs, g a, ⟨g, hgt, a, ha, rfl⟩, rfl⟩
intros
simp only [Inter_and, @Inter_comm _ ι']
intros
simp [set.ext_iff]
intros
intros z z'
refine quotient.ind₂ (λ z z', _) z z'
cases z with x y
cases z' with x' y'
rw [map_pair_eq, eq_iff]
repeat { rw [map_pair_eq, eq_iff] }
rw [map_pair_eq, eq_iff]
rw [map_pair_eq, eq_iff]
rintro (h|h); simp [hinj h.1, hinj h.2]
rintro (h|h)
simp [hinj h.1, hinj h.2]
simp [hinj h.1, hinj h.2]
intros
simp [tprod.elim]
intros
{ ext i : 2, induction i; simp [drop_fun,*]; refl }
ext i : 2
induction i
induction i; simp [drop_fun,*]; refl
induction i; simp [drop_fun,*]
simp [drop_fun,*]
refl
simp [drop_fun,*]
refl
intros
simp only [closure_eq_mclosure, monoid.mem_closure_union_iff, exists_prop, preimage_union]
split
rintro ⟨_, ⟨ys, hys, yt, hyt, rfl⟩, _, ⟨zs, hzs, zt, hzt, rfl⟩, rfl⟩
{ rintro ⟨_, ⟨ys, hys, yt, hyt, rfl⟩, _, ⟨zs, hzs, zt, hzt, rfl⟩, rfl⟩, refine ⟨_, ⟨_, hys, _, hzs, rfl⟩, _, ⟨_, hyt, _, hzt, rfl⟩, _⟩, rw [mul_assoc, mul_assoc, mul_left_comm zs] }
refine ⟨_, ⟨_, hys, _, hzs, rfl⟩, _, ⟨_, hyt, _, hzt, rfl⟩, _⟩
rw [mul_assoc, mul_assoc, mul_left_comm zs]
rintro ⟨_, ⟨ys, hys, zs, hzs, rfl⟩, _, ⟨yt, hyt, zt, hzt, rfl⟩, rfl⟩
{ rintro ⟨_, ⟨ys, hys, zs, hzs, rfl⟩, _, ⟨yt, hyt, zt, hzt, rfl⟩, rfl⟩, refine ⟨_, ⟨ys, hys, yt, hyt, rfl⟩, _, ⟨zs, hzs, zt, hzt, rfl⟩, _⟩, rw [mul_assoc, mul_assoc, mul_left_comm yt] }
refine ⟨_, ⟨ys, hys, yt, hyt, rfl⟩, _, ⟨zs, hzs, zt, hzt, rfl⟩, _⟩
rw [mul_assoc, mul_assoc, mul_left_comm yt]
intros
simpa only [nsmul_one, add_left_iterate] using function.commute.iterate_right f.map_one_add n
intros
obtain ⟨x, xmem, hx⟩ : ∃ x ∈ Icc (0:ℝ) 1, ∀ y ∈ Icc (0:ℝ) 1, f x - x ≤ f y - y
from is_compact_Icc.exists_forall_le (nonempty_Icc.2 zero_le_one) (hf.sub continuous_id).continuous_on
refine lt_of_lt_of_le (lt_sub_iff_add_lt'.2 $ hz x) _
apply le_translation_number_of_add_le
simp only [← le_sub_iff_add_le']
exact f.forall_map_sub_of_Icc _ hx
intros
by_cases ha : a = 0
rw [ha, C_0, sub_zero]
{ rw [ha, C_0, sub_zero], exact gal_X_pow_is_solvable n }
exact gal_X_pow_is_solvable n
have ha' : algebra_map F (X ^ n - C a).splitting_field a ≠ 0 := mt ((ring_hom.injective_iff _).mp (ring_hom.injective _) a) ha
by_cases hn : n = 0
rw [hn, pow_zero, ←C_1, ←C_sub]
{ rw [hn, pow_zero, ←C_1, ←C_sub], exact gal_C_is_solvable (1 - a) }
exact gal_C_is_solvable (1 - a)
have hn' : 0 < n := pos_iff_ne_zero.mpr hn
have hn'' : X ^ n - C a ≠ 0 := λ h, one_ne_zero ((leading_coeff_X_pow_sub_C hn').symm.trans (congr_arg leading_coeff h))
have hn''' : (X ^ n - 1 : polynomial F) ≠ 0 := λ h, one_ne_zero ((leading_coeff_X_pow_sub_one hn').symm.trans (congr_arg leading_coeff h))
have mem_range : ∀ {c}, c ^ n = 1 → ∃ d, algebra_map F (X ^ n - C a).splitting_field d = c := λ c hc, ring_hom.mem_range.mp (minpoly.mem_range_of_degree_eq_one F c (or.resolve_left h hn''' (minpoly.irreducible ((splitting_field.normal (X ^ n - C a)).is_integral c)) (minpoly.dvd F c (by rwa [map_id, alg_hom.map_sub, sub_eq_zero, aeval_X_pow, aeval_one]))))
apply is_solvable_of_comm
intros σ τ
ext b hb
rw [mem_root_set hn'', alg_hom.map_sub, aeval_X_pow, aeval_C, sub_eq_zero] at hb
have hb' : b ≠ 0
intro hb'
{ intro hb', rw [hb', zero_pow hn'] at hb, exact ha' hb.symm }
rw [hb', zero_pow hn'] at hb
exact ha' hb.symm
have key : ∀ σ : (X ^ n - C a).gal, ∃ c, σ b = b * algebra_map F _ c
intro σ
{ intro σ, have key : (σ b / b) ^ n = 1 := by rw [div_pow, ←σ.map_pow, hb, σ.commutes, div_self ha'], obtain ⟨c, hc⟩ := mem_range key, use c, rw [hc, mul_div_cancel' (σ b) hb'] }
have key : (σ b / b) ^ n = 1 := by rw [div_pow, ←σ.map_pow, hb, σ.commutes, div_self ha']
obtain ⟨c, hc⟩ := mem_range key
use c
rw [hc, mul_div_cancel' (σ b) hb']
obtain ⟨c, hc⟩ := key σ
obtain ⟨d, hd⟩ := key τ
rw [σ.mul_apply, τ.mul_apply, hc, τ.map_mul, τ.commutes, hd, σ.map_mul, σ.commutes, hc]
rw [mul_assoc, mul_assoc, mul_right_inj' hb', mul_comm]
intros
{ rw dim_adjoin_eq_one_iff, exact set.singleton_subset_iff }
rw dim_adjoin_eq_one_iff
exact set.singleton_subset_iff
intros
split
introI h
{ introI h, exact is_galois.tower_top_of_is_galois (⊥ : intermediate_field F E) F E }
exact is_galois.tower_top_of_is_galois (⊥ : intermediate_field F E) F E
{ introI h, apply_instance }
introI h
apply_instance
intros
delta minpoly
split_ifs with hx
exact le_of_not_lt (well_founded.not_lt_min degree_lt_wf _ hx ⟨pmonic, hp⟩)
{ exact le_of_not_lt (well_founded.not_lt_min degree_lt_wf _ hx ⟨pmonic, hp⟩) }
{ simp only [degree_zero, bot_le] }
simp only [degree_zero, bot_le]
intros
simp_rw [monomial_eq_smul_X, alg_hom.map_smul, alg_hom.map_pow, expand_X, mul_comm, pow_mul]
intros
have h := vsub_orthogonal_projection_mem_direction_orthogonal s (v +ᵥ p)
rw [vadd_vsub_assoc, submodule.add_mem_iff_right _ hv] at h
refine (eq_of_vsub_eq_zero _).symm
ext
refine submodule.disjoint_def.1 s.direction.orthogonal_disjoint _ _ h
exact (_ : s.direction).2
intros
simp_rw [monge_point_eq_smul_vsub_vadd_circumcenter, centroid_eq_of_range_eq h, circumcenter_eq_of_range_eq h]
intros
rw div_eq_mul_inv
{ rw div_eq_mul_inv, exact ((smooth_mul I).comp_smooth_on (hf.prod_mk hg.inv) : _), }
exact ((smooth_mul I).comp_smooth_on (hf.prod_mk hg.inv) : _)
intros
split
introsI _i
{ introsI _i, apply structure_groupoid.le_iff.mpr, rintros e ⟨s, hs, hes⟩, refine G.eq_on_source _ hes, convert closed_under_restriction' G.id_mem hs, change s = _ ∩ _, rw hs.interior_eq, simp only with mfld_simps }
apply structure_groupoid.le_iff.mpr
rintros e ⟨s, hs, hes⟩
refine G.eq_on_source _ hes
convert closed_under_restriction' G.id_mem hs
change s = _ ∩ _
rw hs.interior_eq
simp only with mfld_simps
intros h
{ intros h, split, intros e he s hs, rw ← of_set_trans (e : local_homeomorph H H) hs, refine G.trans _ he, apply structure_groupoid.le_iff.mp h, exact id_restr_groupoid_mem hs }
split
intros e he s hs
rw ← of_set_trans (e : local_homeomorph H H) hs
refine G.trans _ he
apply structure_groupoid.le_iff.mp h
exact id_restr_groupoid_mem hs
intros
apply hG.lift_prop_within_at_congr_of_eventually_eq h _ h₁.eq_of_nhds
convert h₁
rw nhds_within_univ
intros
rw ← has_mfderiv_within_at_univ at h₀ h₁
exact (unique_mdiff_within_at_univ I).eq h₀ h₁
intros
rcases hf.2 with ⟨f', hf'⟩
have F : has_mfderiv_within_at I I' f s x f' := ⟨hf.1, hf'⟩
rcases hg.2 with ⟨g', hg'⟩
have G : has_mfderiv_within_at I' I'' g u (f x) g' := ⟨hg.1, hg'⟩
exact (has_mfderiv_within_at.comp x G F h).mdifferentiable_within_at
intros
rw ← times_cont_mdiff_on_univ at hf hg ⊢
exact hg.comp hf subset_preimage_univ
intros
simp [left_coset]
intros
funext a b
calc m₁ a b = m₁ (m₂ a e₁) (m₂ e₁ b) : by simp only [one h₁ h₂ distrib, h₁.left_id, h₁.right_id, h₂.left_id, h₂.right_id] ... = m₂ a b : by simp only [distrib, h₁.left_id, h₁.right_id, h₂.left_id, h₂.right_id]
intros
rw ←sub_eq_zero
refine h _ _
rw [smul_sub, h', sub_self]
intros
classical
exact ⟨fintype.card H, H.index_mul_card.symm⟩
intros
rw [f.to_map.map_mul, f.to_map.map_mul] at h
cases f.map_units c with u hu
rw ←hu at h
exact (units.mul_right_inj u).1 h
intros
rwa [order_of, minimal_period, dif_neg]
intros
classical
exact is_cycle_of_prime_order h1 (lt_of_le_of_lt σ.support.card_le_univ h2)
intros
have : f.support = g.support
refine le_antisymm h _
{ refine le_antisymm h _, intros z hz, obtain ⟨x, hx, hf'⟩ := id hf, have hx' : g x ≠ x, { rwa [←h' x (mem_support.mpr hx)] }, obtain ⟨m, hm⟩ := hg.exists_pow_eq hx' (mem_support.mp hz), have h'' : ∀ (x ∈ f.support ∩ g.support), f x = g x, { intros x hx, exact h' x (mem_of_mem_inter_left hx) }, rwa [←hm, ←pow_eq_on_of_mem_support h'' _ x (mem_inter_of_mem (mem_support.mpr hx) (mem_support.mpr hx')), pow_apply_mem_support, mem_support] }
intros z hz
obtain ⟨x, hx, hf'⟩ := id hf
have hx' : g x ≠ x
{ rwa [←h' x (mem_support.mpr hx)] }
rwa [←h' x (mem_support.mpr hx)]
obtain ⟨m, hm⟩ := hg.exists_pow_eq hx' (mem_support.mp hz)
have h'' : ∀ (x ∈ f.support ∩ g.support), f x = g x
intros x hx
{ intros x hx, exact h' x (mem_of_mem_inter_left hx) }
exact h' x (mem_of_mem_inter_left hx)
rwa [←hm, ←pow_eq_on_of_mem_support h'' _ x (mem_inter_of_mem (mem_support.mpr hx) (mem_support.mpr hx')), pow_apply_mem_support, mem_support]
refine support_congr h _
simpa [←this] using h'
intros
cases i with i hi
cases i
{ exact (h0 rfl).elim }
exact (h0 rfl).elim
rw [cycle_range, cycle_type_extend_domain]
exact cycle_type_fin_rotate
intros
cases l with y l
{ simpa }
simpa
induction l with z l IH generalizing x y
{ simpa using h }
simpa using h
by_cases hx : x ∈ z :: l
{ by_cases hx : x ∈ z :: l, { rw [form_perm_cons_cons, mul_apply, swap_apply_def], split_ifs; simp [IH _ _ hx] }, { replace h : x = y := or.resolve_right h hx, simp [form_perm_apply_of_not_mem _ _ hx, ←h] } }
rw [form_perm_cons_cons, mul_apply, swap_apply_def]
{ rw [form_perm_cons_cons, mul_apply, swap_apply_def], split_ifs; simp [IH _ _ hx] }
split_ifs; simp [IH _ _ hx]
split_ifs
simp [IH _ _ hx]
simp [IH _ _ hx]
simp [IH _ _ hx]
replace h : x = y := or.resolve_right h hx
{ replace h : x = y := or.resolve_right h hx, simp [form_perm_apply_of_not_mem _ _ hx, ←h] }
simp [form_perm_apply_of_not_mem _ _ hx, ←h]
intros
induction l with a t ih
{ exact card_support_eq_zero.mpr rfl, }
exact card_support_eq_zero.mpr rfl
obtain ⟨ha, ht⟩ := list.pairwise_cons.1 h
{ obtain ⟨ha, ht⟩ := list.pairwise_cons.1 h, rw [list.prod_cons, list.map_cons, list.sum_cons, ←ih ht], exact (disjoint_prod_right _ ha).card_support_mul }
rw [list.prod_cons, list.map_cons, list.sum_cons, ←ih ht]
exact (disjoint_prod_right _ ha).card_support_mul
intros
simp [eq_bot_iff_forall, mem_closure_singleton]
intros
rw [← line_map_apply_one_sub, line_map_vsub_left]
intros
apply le_antisymm
refine submodule.span_le.2 _
{ refine submodule.span_le.2 _, rintros v ⟨p1, p3, ⟨p2, hp2, v1, hv1, hp1⟩, ⟨p4, hp4, v2, hv2, hp3⟩, rfl⟩, rw [hp1, hp3, vsub_vadd_eq_vsub_sub, vadd_vsub_assoc, set_like.mem_coe], exact (vector_span k s).sub_mem ((vector_span k s).add_mem hv1 (vsub_mem_vector_span k hp2 hp4)) hv2 }
rintros v ⟨p1, p3, ⟨p2, hp2, v1, hv1, hp1⟩, ⟨p4, hp4, v2, hv2, hp3⟩, rfl⟩
rw [hp1, hp3, vsub_vadd_eq_vsub_sub, vadd_vsub_assoc, set_like.mem_coe]
exact (vector_span k s).sub_mem ((vector_span k s).add_mem hv1 (vsub_mem_vector_span k hp2 hp4)) hv2
{ exact vector_span_mono k (subset_span_points k s) }
exact vector_span_mono k (subset_span_points k s)
intros
rw [←affine_map.linear_map_vsub, affine_combination_linear, vsub_eq_sub]
intros
rw [face_centroid_eq_centroid, face_centroid_eq_centroid]
exact s.centroid_eq_iff h₁ h₂
intros
refine eq.symm (add_submonoid.closure_eq_of_le subset_span _)
apply add_submonoid.to_nat_submodule.symm.to_galois_connection.l_le _
rw span_le
exact add_submonoid.subset_closure
intros
refine bot_unique (set_like.le_def.2 $ assume b hb, (submodule.mem_bot R).2 _)
rw [← p.mk_eq_zero hb, ← e.map_eq_zero_iff]
apply submodule.eq_zero_of_bot_submodule
intros
induction k with k ih
{ simpa only [pow_zero], }
simpa only [pow_zero]
rw [pow_succ, pow_succ, linear_map.mul_eq_comp, linear_map.comp_assoc, ih, ← linear_map.comp_assoc, h, linear_map.comp_assoc, linear_map.mul_eq_comp]
{ rw [pow_succ, pow_succ, linear_map.mul_eq_comp, linear_map.comp_assoc, ih, ← linear_map.comp_assoc, h, linear_map.comp_assoc, linear_map.mul_eq_comp], }
intros
rw [reindex_finset_range, reindex_apply, reindex_range_apply]
{ rw [reindex_finset_range, reindex_apply, reindex_range_apply], refl }
refl
intros
conv_rhs { rw [← b'.sum_repr x] }
simp_rw [linear_equiv.map_sum, linear_equiv.map_smul, finset.sum_apply']
refine finset.sum_congr rfl (λ j _, _)
rw [finsupp.smul_apply, smul_eq_mul, mul_comm]
intros
rw orthogonal_span_singleton_eq_to_lin_ker
exact linear_map.span_singleton_sup_ker_eq_top _ hx
intros
dunfold is_ortho
split
split; intro H
intro H
rw [smul_left, mul_eq_zero] at H
{ rw [smul_left, mul_eq_zero] at H, cases H, { trivial }, { exact H }}
cases H
{ trivial }
trivial
{ exact H }
exact H
intro H
{ rw [smul_left, H, mul_zero] }
rw [smul_left, H, mul_zero]
intros
rw [basis.det_reindex, function.comp.assoc, e.self_comp_symm, function.comp.right_id]
intros
rw ←dim_top R M
exact dim_le_of_submodule _ _ le_top
intros
rw ←not_iff_not
simpa using dim_zero_iff_forall_zero
intros
rw linear_equiv.finrank_eq (comap_subtype_equiv_of_le (le_of_lt hst)).symm
refine finrank_lt (lt_of_le_of_ne le_top _)
intro h_eq_top
rw comap_subtype_eq_top at h_eq_top
apply not_le_of_lt hst h_eq_top
intros
apply_fun to_nat at h
rw to_nat_cast at h
exact_mod_cast h
intros
rw ← span_image; refl
rw ← span_image
refl
intros
simp [finsupp.dom_lcongr, finsupp.dom_congr, equiv_map_domain_single]
intros
haveI := classical.dec_eq ι
haveI := classical.dec_eq ι'
let e := fintype.equiv_fin ι
let e' := fintype.equiv_fin ι'
let b := b.reindex e
have hv := (linear_independent_equiv e'.symm).mpr hv
have hv := hv.map' _ b.equiv_fun.ker
exact basis.card_le_card_of_linear_independent_aux (fintype.card ι) _ hv
intros
split_ifs with H
{ split_ifs with H, { subst H, apply eval_basis_self }, { exact eval_basis_ne s x y h H } }
subst H
{ subst H, apply eval_basis_self }
apply eval_basis_self
exact eval_basis_ne s x y h H
{ exact eval_basis_ne s x y h H }
intros
ext
{ ext, simp only [basis.to_matrix_apply, basis.reindex_repr, matrix.minor_apply, id.def] }
simp only [basis.to_matrix_apply, basis.reindex_repr, matrix.minor_apply, id.def]
intros
rw [matrix.trace_eq_neg_charpoly_coeff, matrix.trace_eq_neg_charpoly_coeff, finite_field.matrix.charpoly_pow_card, finite_field.pow_card]
intros
have hu : univ ⊆ {i : m | w i = 0}ᶜ ∪ {i : m | w i = 0}
rw set.compl_union_self
{ rw set.compl_union_self }
have hd : disjoint {i : m | w i ≠ 0} {i : m | w i = 0} := disjoint_compl_left
have B₁ := supr_range_std_basis_eq_infi_ker_proj K (λi:m, K) hd hu (finite.of_fintype _)
have B₂ := @infi_ker_proj_equiv K _ _ (λi:m, K) _ _ _ _ (by simp; apply_instance) hd hu
rw [rank, range_diagonal, B₁, ←@dim_fun' K]
apply linear_equiv.dim_eq
apply B₂
intros
split
intros B C h
{ intros B C h, refine hA.matrix _, rw [←matrix.one_mul B, ←matrix.one_mul C, ←matrix.smul_mul, ←matrix.smul_mul, ←adjugate_mul, matrix.mul_assoc, matrix.mul_assoc, ←mul_eq_mul A, h, mul_eq_mul] }
refine hA.matrix _
rw [←matrix.one_mul B, ←matrix.one_mul C, ←matrix.smul_mul, ←matrix.smul_mul, ←adjugate_mul, matrix.mul_assoc, matrix.mul_assoc, ←mul_eq_mul A, h, mul_eq_mul]
intros B C h
{ intros B C h, simp only [mul_eq_mul] at h, refine hA.matrix _, rw [←matrix.mul_one B, ←matrix.mul_one C, ←matrix.mul_smul, ←matrix.mul_smul, ←mul_adjugate, ←matrix.mul_assoc, ←matrix.mul_assoc, h] }
simp only [mul_eq_mul] at h
refine hA.matrix _
rw [←matrix.mul_one B, ←matrix.mul_one C, ←matrix.mul_smul, ←matrix.mul_smul, ←mul_adjugate, ←matrix.mul_assoc, ←matrix.mul_assoc, h]
intros
rw [← matrix.to_lin_symm, linear_equiv.apply_symm_apply]
intros
rw [smul_left_mul_matrix_algebra_map, block_diagonal_apply_ne _ _ _ h]
intros
induction L with t L IH generalizing M N
{ simp }
simp
{ simp [IH, to_matrix_sum_inl, from_blocks_multiply], }
simp [IH, to_matrix_sum_inl, from_blocks_multiply]
intros
simp [lift_aux, lift_add_hom, tprod_coeff, free_add_monoid.lift_eval_of]
intros
simp only [set_like.le_def, prod_apply, mem_range, set_like.mem_coe, mem_prod, exists_imp_distrib]
rintro _ x rfl
exact ⟨⟨x, rfl⟩, ⟨x, rfl⟩⟩
intros
ext
ext; refl
refl
intros
rw [polar, map_add_self, sub_sub, sub_eq_iff_eq_add, ←two_mul, ←two_mul, ←mul_assoc]
norm_num
intros
{ simp only [polar, pi.add_apply], abel }
simp only [polar, pi.add_apply]
abel
intros
simp only [vandermonde_apply, matrix.mul_apply, matrix.transpose_apply, pow_add]
intros
simp [@eq_comm _ _ (f _)]
intros
simp_rw [hu.to_has_basis.limsup_eq_infi_supr]
refine measurable_binfi _ hu.countable _
exact λ i, measurable_bsupr _ (hs i) hf
intros
rw [comp₂_eq_pair, pair_eq_mk, comp_mk]; refl
rw [comp₂_eq_pair, pair_eq_mk, comp_mk]
refl
intros
simp only [ae_seq, hx, if_true]
intros
rw isometry_emetric_iff_metric
intros f g
rw [dist_eq_norm, ← Lp_meas_subgroup_to_Lp_trim_sub, Lp_meas_subgroup_to_Lp_trim_norm_map, dist_eq_norm]
intros
simp_rw ess_sup
suffices h_smul : (c • μ).ae = μ.ae
rw h_smul
rw h_smul
ext1
simp_rw mem_ae_iff
simp [hc]
intros
simp [integrable.to_L1]
intros
simp [to_Lp]
intros
simp [snorm]
intros
rw [snorm', lintegral_const, ennreal.mul_rpow_of_ne_top _ (measure_ne_top μ set.univ)]
congr
{ congr, rw ←ennreal.rpow_mul, suffices hp_cancel : q * (1/q) = 1, by rw [hp_cancel, ennreal.rpow_one], rw [one_div, mul_inv_cancel hq_ne_zero], }
rw ←ennreal.rpow_mul
suffices hp_cancel : q * (1/q) = 1
rw [hp_cancel, ennreal.rpow_one]
rw [hp_cancel, ennreal.rpow_one]
rw [one_div, mul_inv_cancel hq_ne_zero]
rw [ne.def, ennreal.rpow_eq_top_iff, auto.not_or_eq, auto.not_and_eq, auto.not_and_eq]
{ rw [ne.def, ennreal.rpow_eq_top_iff, auto.not_or_eq, auto.not_and_eq, auto.not_and_eq], split, { left, rwa [ennreal.coe_eq_zero, nnnorm_eq_zero], }, { exact or.inl ennreal.coe_ne_top, }, }
split
left
{ left, rwa [ennreal.coe_eq_zero, nnnorm_eq_zero], }
rwa [ennreal.coe_eq_zero, nnnorm_eq_zero]
{ exact or.inl ennreal.coe_ne_top, }
exact or.inl ennreal.coe_ne_top
intros
refine le_trans (ess_sup_mono_ae (eventually_of_forall (λ x, _))) (ennreal.ess_sup_add_le _ _)
simp_rw [pi.add_apply, ←ennreal.coe_add, ennreal.coe_le_coe]
exact nnnorm_add_le _ _
intros
rcases hf with ⟨g, hg, hfg⟩
obtain ⟨t, ht, hgt_zero, htμ⟩ := hg.exists_set_sigma_finite
refine ⟨t, ht, _, htμ⟩
refine eventually_eq.trans (ae_restrict_of_ae hfg) _
rw [eventually_eq, ae_restrict_iff' ht.compl]
exact eventually_of_forall hgt_zero
intros
by_cases hfm : ae_measurable f μ
refine integral_mono_ae ⟨hfm, _⟩ hgi h
{ refine integral_mono_ae ⟨hfm, _⟩ hgi h, refine (hgi.has_finite_integral.mono $ h.mp $ hf.mono $ λ x hf hfg, _), simpa [real.norm_eq_abs, abs_of_nonneg hf, abs_of_nonneg (le_trans hf hfg)] }
refine (hgi.has_finite_integral.mono $ h.mp $ hf.mono $ λ x hf hfg, _)
simpa [real.norm_eq_abs, abs_of_nonneg hf, abs_of_nonneg (le_trans hf hfg)]
rw [integral_non_ae_measurable hfm]
{ rw [integral_non_ae_measurable hfm], exact integral_nonneg_of_ae (hf.trans h) }
exact integral_nonneg_of_ae (hf.trans h)
intros
{ simp_rw [weighted_smul_apply, smul_comm], }
simp_rw [weighted_smul_apply, smul_comm]
intros
simp_rw ae_interval_oc_iff
rw [ae_restrict_eq, eventually_inf_principal, ae_restrict_eq, eventually_inf_principal]
rw [ae_restrict_eq, eventually_inf_principal, ae_restrict_eq, eventually_inf_principal] ; exact measurable_set_Ioc
exact measurable_set_Ioc
exact measurable_set_Ioc
intros
simpa only [sub_eq_add_neg] using (integral_add hf hg.neg).trans (congr_arg _ integral_neg)
intros
rw [interval_integrable_iff_integrable_Ioc_of_le hab, integrable_on_Icc_iff_integrable_on_Ioc]
intros
refine measure.ext (λ s hs, _)
rw [with_density_apply _ hs, measure.coe_add, pi.add_apply, with_density_apply _ hs, with_density_apply _ hs, ← lintegral_add hf hg]
refl
intros
rw [integral_indicator s_meas, ← set_integral_const]
intros
specialize hf_int (∫ x, f x ∂μ)
{ specialize hf_int (∫ x, f x ∂μ), rwa [integral_inner hf, inner_self_eq_zero] at hf_int }
rwa [integral_inner hf, inner_self_eq_zero] at hf_int
intros
rw [sub_eq_add_neg, sub_eq_add_neg, set_to_fun_add hT hf hg.neg, set_to_fun_neg hT g]
intros
convert μ.outer_measure_preimage (homeomorph.mul_left g) (λ K, h g) A
intros
rcases compact_covered_by_mul_left_translates hK hV with ⟨t, ht⟩
{ rcases compact_covered_by_mul_left_translates hK hV with ⟨t, ht⟩, exact ⟨t.card, t, ht, rfl⟩ }
exact ⟨t.card, t, ht, rfl⟩
intros
simp [volume_val]
intros
rw [← count_apply_finset, finite.coe_to_finset]
intros
simpa only [exists_prop, and.assoc] using (μ.finite_at_nhds x).exists_mem_basis (nhds_basis_opens x)
intros
rw [measure.trim, to_measure_to_outer_measure]
intros
by_contra
push_neg at h
simp_rw nonpos_iff_eq_zero at h
exact hs (measure_Union_null h)
intros
rcases exists_measurable_superset_forall_eq_trim (![m₁, m₂, m₃]) s with ⟨t, hst, ht, htm⟩
simp only [fin.forall_fin_succ, matrix.cons_val_zero, matrix.cons_val_succ] at htm
rw [← htm.1, ← htm.2.1, ← htm.2.2.1, h]
intros
ext
{ ext, simp [mem_divisors_prime_pow, pp, nat.lt_succ_iff, @eq_comm _ a] }
simp [mem_divisors_prime_pow, pp, nat.lt_succ_iff, @eq_comm _ a]
intros
have me0 : 0 < max (1 / ε) M := lt_max_iff.mpr (or.inl (one_div_pos.mpr e0))
refine ⟨max (1 / ε) M, me0, λ z a, _⟩
by_cases dm1 : 1 ≤ (dist α (j z a) * max (1 / ε) M)
{ exact one_le_mul_of_one_le_of_one_le (d0 a) dm1 }
exact one_le_mul_of_one_le_of_one_le (d0 a) dm1
have : j z a ∈ closed_ball α ε
{ have : j z a ∈ closed_ball α ε, { refine mem_closed_ball'.mp (le_trans _ ((one_div_le me0 e0).mpr (le_max_left _ _))), exact ((le_div_iff me0).mpr (not_le.mp dm1).le) }, refine (L this).trans _, refine mul_le_mul_of_nonneg_left ((B this).trans _) (zero_le_one.trans (d0 a)), exact mul_le_mul_of_nonneg_left (le_max_right _ M) dist_nonneg }
refine mem_closed_ball'.mp (le_trans _ ((one_div_le me0 e0).mpr (le_max_left _ _)))
{ refine mem_closed_ball'.mp (le_trans _ ((one_div_le me0 e0).mpr (le_max_left _ _))), exact ((le_div_iff me0).mpr (not_le.mp dm1).le) }
exact ((le_div_iff me0).mpr (not_le.mp dm1).le)
refine (L this).trans _
refine mul_le_mul_of_nonneg_left ((B this).trans _) (zero_le_one.trans (d0 a))
exact mul_le_mul_of_nonneg_left (le_max_right _ M) dist_nonneg
intros
by_contradiction H
simp at H
interval_cases q (p'+2); clear H
interval_cases q (p'+2)
clear H
dsimp [q] at h
{ dsimp [q] at h, injection h with h', clear h, simp [mersenne] at h', exact lt_irrefl 2 (calc 2 ≤ p'+2 : nat.le_add_left _ _ ... < 2^(p'+2) : nat.lt_two_pow _ ... = 2 : nat.pred_inj (nat.one_le_two_pow _) dec_trivial h'), }
injection h with h'
clear h
simp [mersenne] at h'
exact lt_irrefl 2 (calc 2 ≤ p'+2 : nat.le_add_left _ _ ... < 2^(p'+2) : nat.lt_two_pow _ ... = 2 : nat.pred_inj (nat.one_le_two_pow _) dec_trivial h')
clear H
dsimp [q] at h
{ dsimp [q] at h, injection h with h', clear h, rw [mersenne, pnat.one_coe, nat.min_fac_eq_two_iff, pow_succ] at h', exact nat.two_not_dvd_two_mul_sub_one (nat.one_le_two_pow _) h', }
injection h with h'
clear h
rw [mersenne, pnat.one_coe, nat.min_fac_eq_two_iff, pow_succ] at h'
exact nat.two_not_dvd_two_mul_sub_one (nat.one_le_two_pow _) h'
intros
rw [padic_val_rat, dif_pos]; simp *; refl
rw [padic_val_rat, dif_pos]; simp *
rw [padic_val_rat, dif_pos]
simp *
refl
simp *
intros
rw [padic_norm_p hp, div_lt_iff, one_mul]
{ exact_mod_cast hp }
exact_mod_cast hp
{ exact_mod_cast zero_lt_one.trans hp }
exact_mod_cast zero_lt_one.trans hp
intros
convert sub_zmod_repr_mem z using 2
dsimp [to_zmod, to_zmod_hom]
rcases (exists_eq_add_of_lt (hp_prime.1.pos)) with ⟨p', rfl⟩
unfreezingI { rcases (exists_eq_add_of_lt (hp_prime.1.pos)) with ⟨p', rfl⟩ }
change ↑(zmod.val _) = _
simp only [zmod.val_nat_cast, add_zero, add_def, nat.cast_inj, zero_add]
apply mod_eq_of_lt
simpa only [zero_add] using zmod_repr_lt_p z
intros
apply (iff_congr _ (by simp [units.ext_iff])).mp (euler_criterion_units p (units.mk0 a ha))
simp only [units.ext_iff, sq, units.coe_mk0, units.coe_mul]
split
rintro ⟨y, hy⟩
{ rintro ⟨y, hy⟩, exact ⟨y, hy⟩ }
exact ⟨y, hy⟩
rintro ⟨y, rfl⟩
{ rintro ⟨y, rfl⟩, have hy : y ≠ 0, { rintro rfl, simpa [zero_pow] using ha, }, refine ⟨units.mk0 y hy, _⟩, simp, }
have hy : y ≠ 0
rintro rfl
{ rintro rfl, simpa [zero_pow] using ha, }
simpa [zero_pow] using ha
refine ⟨units.mk0 y hy, _⟩
simp
intros
simp [ext]
intros
rw [norm_mul, int.nat_abs_mul]; exact le_mul_of_one_le_right (nat.zero_le _) (int.coe_nat_le.1 (by rw [coe_nat_abs_norm]; exact int.add_one_le_of_lt (norm_pos.2 hy)))
rw [norm_mul, int.nat_abs_mul]
exact le_mul_of_one_le_right (nat.zero_le _) (int.coe_nat_le.1 (by rw [coe_nat_abs_norm]; exact int.add_one_le_of_lt (norm_pos.2 hy)))
intros
rw inf_assoc
rw [sup_inf_right, sup_inf_sdiff]
rw [inf_sup_right, inf_sdiff_left]
intros
simp [disjoint]
intros
simp only [bdd_above, upper_bounds_empty, univ_nonempty]
intros
simpa only [range_comp, subtype.range_coe, infi_subtype'] using @is_glb_infi α s _ (f ∘ coe)
intros
by_cases p; simp [h]
by_cases p
simp [h]
simp [h]
intros
simpa only [(∘), neg_mul_eq_neg_mul, neg_neg] using tendsto_neg_at_top_at_bot.comp (hf.const_mul_at_top (neg_pos.2 hr))
intros
refine ⟨λ U, (mem_infi_finite _).trans _⟩
simp only [infi_principal_finset, mem_Union, mem_principal, exists_prop, exists_finite_iff_finset, finset.set_bInter_coe]
intros
simp
intros
ext W
suffices : ∃ t ∈ f, (λ (y : α), x) ⁻¹' t ⊆ W
simpa
simpa
use [V, hV]
simp [preimage_const_of_not_mem hx]
intros
simp only [tendsto, map_supr, supr_le_iff]
intros
simp [sup_comm, ← infi_sup_left]
intros
simp only [filter.frequently, filter.eventually, mem_cofinite, compl_set_of, not_not, set.infinite]
intros
rw [← principal_singleton, lift'_principal hh]
intros
{ use [nonempty, directed], exact λ _ _ _ _, mem_of_le ‹_› ‹_› }
use [nonempty, directed]
exact λ _ _ _ _, mem_of_le ‹_› ‹_›
intros
ext x
{ ext x, refl }
refl
intros
simp only [symm_diff_eq, compl_compl, inf_idem, compl_sup_eq_top]
intros
rw ← h.coe_to_finset
exact h.to_finset.is_pwo
intros
obtain ⟨c, d, d_ne, hx⟩ := exists_integral_multiple (h (algebra_map _ L a / algebra_map _ L b)) ((ring_hom.injective_iff _).mp inj)
refine ⟨is_integral_closure.mk' S (c : L) c.2, d, d_ne, is_integral_closure.algebra_map_injective S R L _⟩
simp only [algebra.smul_def, ring_hom.map_mul, is_integral_closure.algebra_map_mk', ← hx, ← is_scalar_tower.algebra_map_apply]
rw [← mul_assoc _ (_ / _), mul_div_cancel' (algebra_map S L a), mul_comm]
exact mt ((ring_hom.injective_iff _).mp (is_integral_closure.algebra_map_injective S R L) _) hb
intros
obtain ⟨a, b, h⟩ := H
rw [← mul_one z, ← h, mul_add]
apply dvd_add
rw [mul_comm z, mul_assoc]
{ rw [mul_comm z, mul_assoc], exact (mul_dvd_mul_left _ H2).mul_left _ }
exact (mul_dvd_mul_left _ H2).mul_left _
rw [mul_comm b, ← mul_assoc]
{ rw [mul_comm b, ← mul_assoc], exact (mul_dvd_mul_right H1 _).mul_right _ }
exact (mul_dvd_mul_right H1 _).mul_right _
intros
obtain ⟨p, hp⟩ := h₁
refine ⟨p, hp, _⟩
intros x hx
cases wf_dvd_monoid.exists_factors x hx with fx hfx
refine ⟨fx.card, _⟩
have H := hfx.2
rw ← associates.mk_eq_mk_iff_associated at H ⊢
rw [← H, ← associates.prod_mk, associates.mk_pow, ← multiset.prod_repeat]
congr' 1
symmetry
rw multiset.eq_repeat
simp only [true_and, and_imp, multiset.card_map, eq_self_iff_true, multiset.mem_map, exists_imp_distrib]
rintros _ q hq rfl
rw associates.mk_eq_mk_iff_associated
apply h₂ (hfx.1 _ hq) hp
intros
rcases I.is_fractional with ⟨aI, haI, hI⟩
use aI
use haI
intros b hb
rcases mem_inf.mp hb with ⟨hbI, hbJ⟩
exact hI b hbI
intros
rw [← lsum_apply, linear_map.map_sub, lsum_apply, lsum_apply]
intros
rw [←set.singleton_zero, span_singleton_eq_bot]
intros
rw [set_like.ext'_iff, ker_eq, set.ext_iff]
{ rw [set_like.ext'_iff, ker_eq, set.ext_iff], exact f.injective_iff' }
exact f.injective_iff'
intros
simp_rw ←hh
exact ((f.lift_of_right_inverse f_inv hf).apply_symm_apply _).symm
intros
refine ⟨_, λ h, h.algebra_map⟩
rintros ⟨f, hf, hx⟩
use [f, hf]
exact is_scalar_tower.aeval_eq_zero_of_aeval_algebra_map_eq_zero R A B hAB hx
intros
rcases hx with ⟨x, rfl⟩
rcases hy with ⟨y, rfl⟩
refine card_congr (λ g _, g * x⁻¹ * y) _ _ (λ g hg, ⟨g * y⁻¹ * x, _⟩)
simp only [mem_filter, one_mul, monoid_hom.map_mul, mem_univ, mul_right_inv, eq_self_iff_true, monoid_hom.map_mul_inv, and_self, forall_true_iff] {contextual := tt}
{ simp only [mem_filter, one_mul, monoid_hom.map_mul, mem_univ, mul_right_inv, eq_self_iff_true, monoid_hom.map_mul_inv, and_self, forall_true_iff] {contextual := tt} }
simp only [mul_left_inj, imp_self, forall_2_true_iff]
{ simp only [mul_left_inj, imp_self, forall_2_true_iff], }
simp only [true_and, mem_filter, mem_univ] at hg
{ simp only [true_and, mem_filter, mem_univ] at hg, simp only [hg, mem_filter, one_mul, monoid_hom.map_mul, mem_univ, mul_right_inv, eq_self_iff_true, exists_prop_of_true, monoid_hom.map_mul_inv, and_self, mul_inv_cancel_right, inv_mul_cancel_right], }
simp only [hg, mem_filter, one_mul, monoid_hom.map_mul, mem_univ, mul_right_inv, eq_self_iff_true, exists_prop_of_true, monoid_hom.map_mul_inv, and_self, mul_inv_cancel_right, inv_mul_cancel_right]
intros
rw ring_hom.injective_iff (algebra_map R S)
intros a ha
rwa to_map_eq_zero_iff S hM at ha
intros
rw [hx, (algebra_map R S).map_zero] at h
{ rw [hx, (algebra_map R S).map_zero] at h, exact (is_unit.mul_left_eq_zero (is_localization.map_units S y)).1 h}
exact (is_unit.mul_left_eq_zero (is_localization.map_units S y)).1 h
intros
simp only [degree_le, submodule.mem_infi, degree_le_iff_coeff_zero, linear_map.mem_ker]
simp only [degree_le, submodule.mem_infi, degree_le_iff_coeff_zero, linear_map.mem_ker]; refl
refl
intros
rw [←flip _ _ _ h, polynomial.comp_assoc]
simp
intros
by_cases h : C p.content = 0
{ rw [C_eq_zero, content_eq_zero_iff] at h, simp [h] }
rw [C_eq_zero, content_eq_zero_iff] at h
simp [h]
conv_rhs { rw [p.eq_C_content_mul_prim_part, nat_degree_mul h p.prim_part_ne_zero, nat_degree_C, zero_add] }
intros
obtain ⟨n, rfl⟩ := nat.exists_eq_add_of_le h
rw add_comm
exact dickson_add_two k a n
intros
simp [pochhammer]
intros
refine le_antisymm _ (dim_le_nat_degree_of_root pb (minpoly.ne_zero pb.is_integral_gen) (minpoly.aeval _ _))
rw ← nat_degree_minpoly_gen
apply nat_degree_le_of_degree_le
rw ← degree_eq_nat_degree (minpoly_gen_monic pb).ne_zero
exact minpoly.min _ _ (minpoly_gen_monic pb) (aeval_minpoly_gen pb)
intros
rintros _ ⟨ζ, h, rfl⟩
simp only [←monoid_hom.map_pow, *, mem_roots_of_unity, set_like.mem_coe, monoid_hom.map_one] at *
intros
rw [trace_eq_trace_adjoin K x, algebra.smul_def, ring_hom.map_mul, ← algebra.smul_def, intermediate_field.adjoin_simple.trace_gen_eq_sum_roots _ hF, is_scalar_tower.algebra_map_smul]
intros
simp_rw ← unique_factorization_monoid.irreducible_iff_prime at h₃
exact wf_dvd_monoid.induction_on_irreducible a h₁ h₂ h₃
intros
rw [coeff_frobenius]
calc aeval (λ k, x.coeff k) (frobenius_poly p n) = aeval (λ k, x.coeff k) (mv_polynomial.map (int.cast_ring_hom (zmod p)) (frobenius_poly p n)) : _ ... = aeval (λ k, x.coeff k) (X n ^ p : mv_polynomial ℕ (zmod p)) : _ ... = (x.coeff n) ^ p : _
conv_rhs { rw [aeval_eq_eval₂_hom, eval₂_hom_map_hom] }
{ conv_rhs { rw [aeval_eq_eval₂_hom, eval₂_hom_map_hom] }, apply eval₂_hom_congr (ring_hom.ext_int _ _) rfl rfl }
apply eval₂_hom_congr (ring_hom.ext_int _ _) rfl rfl
{ rw frobenius_poly_zmod }
rw frobenius_poly_zmod
{ rw [alg_hom.map_pow, aeval_X] }
rw [alg_hom.map_pow, aeval_X]
intros
rw [truncate_fun, truncated_witt_vector.coeff_mk]
intros
simp [witt_polynomial, alg_hom.map_sum, aeval_monomial, finsupp.prod_single_index]
intros
rw [image_eq_range] at h
{ rw [image_eq_range] at h, convert mk_preimage_of_subset_range_lift _ _ h using 1, rw [mk_sep], refl }
convert mk_preimage_of_subset_range_lift _ _ h using 1
rw [mk_sep]
refl
simpa using nat_lt_omega 1
intros
rw [aleph, omega_le_aleph']; apply ordinal.le_add_right
rw [aleph, omega_le_aleph']
apply ordinal.le_add_right
rw [← two_power_omega, lift_two_power, lift_omega, two_power_omega]
intros
simp [←move_right_card h, lt_add_one]
intros
simp only [log, dif_neg b1]
intros
cases h with _ _ _ _ eb _ h₁ h₂ h₃; exact h₂
cases h with _ _ _ _ eb _ h₁ h₂ h₃
exact h₂
intros
cases n; cases i; refl
cases n; cases i
cases n
cases i
refl
cases i
refl
intros
simp [h.symm, term]
simp [h.symm, term]; ac_refl
ac_refl
intros
have : z ≤ y
{ transitivity, assumption, apply le_of_lt h, }
transitivity
assumption
apply le_of_lt h
apply @nat.lt_of_add_lt_add_left z
rw [nat.add_sub_of_le,nat.add_sub_of_le]
rw [nat.add_sub_of_le,nat.add_sub_of_le]; solve_by_elim
solve_by_elim
solve_by_elim
solve_by_elim
intros
rwa [ ← hb, ← div_eq_mul_inv] at h
intros
simp [h₂.symm, h₁.symm, horner, mul_add, mul_assoc]
intros
rw [← nhds_within_compl_infty_eq, nhds_within_compl_singleton_sup_pure]
intros
simpa only [div_eq_mul_inv] using is_open_map_mul_right (a⁻¹)
intros
convert ((has_sum_ite_eq b _).add hf)
ext b'
by_cases h : b' = b
rw [h, update_same]
{ rw [h, update_same], simp only [eq_self_iff_true, if_true, sub_add_cancel] }
simp only [eq_self_iff_true, if_true, sub_add_cancel]
simp only [h, update_noteq, if_false, ne.def, zero_add, not_false_iff]
intros
{ ext, refl }
ext
refl
intros
convert nhds_basis_Ioo_pos a
ext ε
{ ext ε, change abs (x - a) < ε ↔ a - ε < x ∧ x < a + ε, simp [abs_lt, sub_lt_iff_lt_add, add_comm ε a, add_comm x ε] }
change abs (x - a) < ε ↔ a - ε < x ∧ x < a + ε
simp [abs_lt, sub_lt_iff_lt_add, add_comm ε a, add_comm x ε]
intros
refine ((is_lub_cSup (ne.image f) (Mf.map_bdd_above H)).unique _).symm
refine (is_lub_cSup ne H).is_lub_of_tendsto (λx hx y hy xy, Mf xy) ne _
exact Cf.mono_left inf_le_left
intros
rw [frontier_eq_closure_inter_closure, closure_le_eq hf hg]
rintros b ⟨hb₁, hb₂⟩
refine le_antisymm hb₁ (closure_lt_subset_le hg hf _)
convert hb₂ using 2
simp only [not_le.symm]
refl
intros
intro x
rcases hf x with ⟨s, hsx, hsf⟩
refine ⟨interior s, interior_mem_nhds.2 hsx, hsf.subset $ λ i hi, _⟩
exact (hi.mono (closure_inter_open' is_open_interior)).of_closure.mono (inter_subset_inter_right _ interior_subset)
intros
simp only [interior_eq_iff_open.symm, subset.antisymm_iff, interior_subset, true_and]
intros
tidy
intros
simp [← is_open_compl_iff, is_open_sigma_iff]
intros
{ ext, simp, }
ext
simp
intros
simpa using @dist_le _ _ _ _ f 0 _ C0
intros
rw [continuous_at, continuous_within_at, nhds_within_univ]
intros
ext ⟨⟩
{ ext ⟨⟩, refl }
refl
intros
rw [coord_change, e₁.symm_apply_mk_proj (e₁.mem_source.2 h)]
intros
rw [← preimage_symm, is_closed_preimage]
intros
rw [← Sup_range, mul_Sup, supr_range]
intros
split
simp only [← nnreal.summable_coe, nnreal.coe_tsum]
{ simp only [← nnreal.summable_coe, nnreal.coe_tsum], exact λ h, ⟨h.sigma_factor, h.sigma⟩ }
exact λ h, ⟨h.sigma_factor, h.sigma⟩
rintro ⟨h₁, h₂⟩
{ rintro ⟨h₁, h₂⟩, simpa only [← ennreal.tsum_coe_ne_top_iff_summable, ennreal.tsum_sigma', ennreal.coe_tsum, h₁] using h₂ }
simpa only [← ennreal.tsum_coe_ne_top_iff_summable, ennreal.tsum_sigma', ennreal.coe_tsum, h₁] using h₂
simp only [continuous_at, tendsto_nhds_bot_iff_real, nhds_prod_eq, bot_add_bot]
assume r
rw eventually_prod_iff
refine ⟨λ z, z < r, Iio_mem_nhds (bot_lt_coe _), λ z, z < 0, Iio_mem_nhds (bot_lt_coe _), λ x hx y hy, _⟩
dsimp
convert add_lt_add hx hy
simp
intros
{ cases e, cases e', cases h, refl }
cases e
cases e'
cases h
refl
intros
apply open_embedding_of_continuous_injective_open
apply continuous_iff_continuous_on_univ.mpr
{ apply continuous_iff_continuous_on_univ.mpr, rw ← h, exact e.continuous_to_fun }
rw ← h
exact e.continuous_to_fun
apply set.injective_iff_inj_on_univ.mpr
{ apply set.injective_iff_inj_on_univ.mpr, rw ← h, exact e.inj_on }
rw ← h
exact e.inj_on
intros U hU
{ intros U hU, simpa only [h, subset_univ] with mfld_simps using e.image_open_of_open hU}
simpa only [h, subset_univ] with mfld_simps using e.image_open_of_open hU
intros
rw [hf.induced, is_open_induced_iff]
intros
rw inter_comm at h
rw [add_comm, dist_comm]
exact dist_lt_add_of_nonempty_closed_ball_inter_ball h
intros
letI : pseudo_metric_space (X ⊕ Y) := glue_premetric hΦ hΨ
funext
simp only [comp, to_glue_l, to_glue_r, quotient.eq]
exact glue_dist_glued_points Φ Ψ 0 x
intros
rw [← e.dimH_preimage, preimage_univ]
intros
simp [inf_dist]
intros
split
split; intro h
intro h
rintros ⟨sU, hU⟩ x hx
{ rintros ⟨sU, hU⟩ x hx, rcases h.mem_nhds_iff.mp (is_open.mem_nhds hU hx) with ⟨sV, ⟨⟨V, H₁, H₂⟩, hsV⟩⟩, refine ⟨V, H₁, _⟩, cases V, dsimp at H₂, subst H₂, exact hsV }
rcases h.mem_nhds_iff.mp (is_open.mem_nhds hU hx) with ⟨sV, ⟨⟨V, H₁, H₂⟩, hsV⟩⟩
refine ⟨V, H₁, _⟩
cases V
dsimp at H₂
subst H₂
exact hsV
intro h
refine is_topological_basis_of_open_of_nhds _ _
{ refine is_topological_basis_of_open_of_nhds _ _, { rintros sU ⟨U, ⟨H₁, H₂⟩⟩, subst H₂, exact U.property }, { intros x sU hx hsU, rcases @h (⟨sU, hsU⟩ : opens α) x hx with ⟨V, hV, H⟩, exact ⟨V, ⟨V, hV, rfl⟩, H⟩ } }
{ rintros sU ⟨U, ⟨H₁, H₂⟩⟩, subst H₂, exact U.property }
rintros sU ⟨U, ⟨H₁, H₂⟩⟩
subst H₂
exact U.property
intros x sU hx hsU
{ intros x sU hx hsU, rcases @h (⟨sU, hsU⟩ : opens α) x hx with ⟨V, hV, H⟩, exact ⟨V, ⟨V, hV, rfl⟩, H⟩ }
rcases @h (⟨sU, hsU⟩ : opens α) x hx with ⟨V, hV, H⟩
exact ⟨V, ⟨V, hV, rfl⟩, H⟩
intros
assume x z hz
by_cases h : x ∈ s; simp [h] at hz
by_cases h : x ∈ s
simp [h] at hz
apply filter.eventually_of_forall (λ x', _)
{ apply filter.eventually_of_forall (λ x', _), by_cases h' : x' ∈ s; simp [h', hz, hz.trans_le hy], }
by_cases h' : x' ∈ s; simp [h', hz, hz.trans_le hy]
by_cases h' : x' ∈ s
simp [h', hz, hz.trans_le hy]
simp [h', hz, hz.trans_le hy]
simp [h] at hz
filter_upwards [hs.is_open_compl.mem_nhds h]
{ filter_upwards [hs.is_open_compl.mem_nhds h], simp [hz] { contextual := tt } }
simp [hz] { contextual := tt }
intros
apply is_closed_map.of_nonempty
intros s hs h2s
simp_rw [h2s.image_const, is_closed_singleton]
intros
{ dsimp [comp], tidy, }
dsimp [comp]
tidy
intros
letI : topological_space α := ⊥
haveI : discrete_topology α := ⟨rfl⟩
exact funext (dense_inducing_pure.extend_eq continuous_of_discrete_topology)
intros
unfold uniform_continuous_on set.restrict uniform_continuous tendsto
rw [show (λ x : s × s, (f x.1, f x.2)) = prod.map f f ∘ coe, by ext x; cases x; refl, uniformity_comap rfl, show prod.map subtype.val subtype.val = (coe : s × s → α × α), by ext x; cases x; refl]
conv in (map _ (comap _ _)) { rw ← filter.map_map }
rw subtype_coe_map_comap_prod
refl
intros
refine le_trans (le_lift' $ λ s hs, mem_map.2 _) comp_le_uniformity
filter_upwards [h₁₂ hs, h₂₃ hs]
exact λ x hx₁₂ hx₂₃, ⟨_, hx₁₂, hx₂₃⟩
intros
refine ⟨λ hs f, f.cauchy_of_totally_bounded hs, λ H, totally_bounded_iff_filter.2 _⟩
introsI f hf hfs
exact ⟨ultrafilter.of f, ultrafilter.of_le f, H _ ((ultrafilter.of_le f).trans hfs)⟩
intros
split
assume h
{ assume h, exact ⟨separated_of_uniform_continuous uniform_continuous_fst h, separated_of_uniform_continuous uniform_continuous_snd h⟩ }
exact ⟨separated_of_uniform_continuous uniform_continuous_fst h, separated_of_uniform_continuous uniform_continuous_snd h⟩
rintros ⟨eqv_α, eqv_β⟩ r r_in
{ rintros ⟨eqv_α, eqv_β⟩ r r_in, rw uniformity_prod at r_in, rcases r_in with ⟨t_α, ⟨r_α, r_α_in, h_α⟩, t_β, ⟨r_β, r_β_in, h_β⟩, rfl⟩, let p_α := λ(p : (α × β) × (α × β)), (p.1.1, p.2.1), let p_β := λ(p : (α × β) × (α × β)), (p.1.2, p.2.2), have key_α : p_α ((a₁, b₁), (a₂, b₂)) ∈ r_α, { simp [p_α, eqv_α r_α r_α_in] }, have key_β : p_β ((a₁, b₁), (a₂, b₂)) ∈ r_β, { simp [p_β, eqv_β r_β r_β_in] }, exact ⟨h_α key_α, h_β key_β⟩ }
rw uniformity_prod at r_in
rcases r_in with ⟨t_α, ⟨r_α, r_α_in, h_α⟩, t_β, ⟨r_β, r_β_in, h_β⟩, rfl⟩
let p_α := λ(p : (α × β) × (α × β)), (p.1.1, p.2.1)
let p_β := λ(p : (α × β) × (α × β)), (p.1.2, p.2.2)
have key_α : p_α ((a₁, b₁), (a₂, b₂)) ∈ r_α
simp [p_α, eqv_α r_α r_α_in]
{ simp [p_α, eqv_α r_α r_α_in] }
have key_β : p_β ((a₁, b₁), (a₂, b₂)) ∈ r_β
simp [p_β, eqv_β r_β r_β_in]
{ simp [p_β, eqv_β r_β r_β_in] }
exact ⟨h_α key_α, h_β key_β⟩
intros
dsimp only [uniform_continuous, tendsto]
{ dsimp only [uniform_continuous, tendsto], rw [← hg.comap_uniformity, ← map_le_iff_le_comap, filter.map_map] }
rw [← hg.comap_uniformity, ← map_le_iff_le_comap, filter.map_map]
intros
cases a; simp
cases a
simp
simp
intros
rw [lt_iff_add_one_le, ← int.coe_nat_succ, coe_nat_le_coe_nat_iff]
reflexivity
intros
apply le_trans
apply int.add_le_add
apply int.add_le_add
assumption'
apply le_refl
intros
induction z with z ih
{ rw [nat.mul_zero, nat.add_zero, nat.add_zero] }
rw [nat.mul_zero, nat.add_zero, nat.add_zero]
rw [mul_succ, ← nat.add_assoc, add_div_right _ H, ih]
{ rw [mul_succ, ← nat.add_assoc, add_div_right _ H, ih], refl }
refl
intros
rw mod_def
have h' : ¬(0 < b ∧ b ≤ a)
simp [not_le_of_gt h]
simp [if_neg, h']
intros
rw nat.sub_sub
apply nat.sub_lt
apply lt_of_lt_of_le (nat.zero_lt_succ _) h
rw nat.add_comm
apply nat.zero_lt_succ
intros
tactic.mk_inj_eq
intros
rw [point_reflection_apply, eq_comm, eq_vadd_iff_vsub_eq, ← neg_vsub_eq_vsub_rev, neg_eq_iff_add_eq_zero, ← bit0, ← bit0_zero, h.eq_iff, vsub_eq_zero_iff_eq, eq_comm]
intros
induction n with n ih
{ simp }
simp
rw [pow_succ, ←mul_assoc, mul_sub_algebra_map_commutes, mul_assoc, ih, ←mul_assoc]
{ rw [pow_succ, ←mul_assoc, mul_sub_algebra_map_commutes, mul_assoc, ih, ←mul_assoc], }
intros
ext
{ ext, simp only [lmul_right_apply, linear_map.comp_apply, mul_assoc] }
simp only [lmul_right_apply, linear_map.comp_apply, mul_assoc]
intros
split
{ rintro ⟨c, rfl⟩, simp [subsingleton.elim c 1] }
rintro ⟨c, rfl⟩
simp [subsingleton.elim c 1]
{ rintro rfl, refl }
rintro rfl
refl
intros
{ rw [prod_eq_mul_prod_diff_singleton h, mul_comm] }
rw [prod_eq_mul_prod_diff_singleton h, mul_comm]
intros
{ dunfold finset.sum, rw count_sum }
dunfold finset.sum
rw count_sum
intros
simp [prod_apply_dite _ _ (λ x, x)]
intros
haveI := classical.dec_eq α; exact finset.induction_on s (by simp) (by simp [mul_pow] {contextual := tt})
haveI := classical.dec_eq α
exact finset.induction_on s (by simp) (by simp [mul_pow] {contextual := tt})
intros
apply finprod_mem_inter_mul_support_eq
ext x
exact and_congr_left (h x)
intros
contrapose! Hlt with Hle
exact prod_le_prod'' Hle
intros
apply contract_left_apply f x
intros
rw [← ring_char.spec, ← ne.def]
exact nonzero_of_invertible (t : K)
intros
{ ext n, rw ←(coe_of_s_nth_rat_eq v_eq_q), refl }
ext n
rw ←(coe_of_s_nth_rat_eq v_eq_q)
refl
intros
apply dfinsupp.induction x H_zero
intros i b f h1 h2 ih
solve_by_elim
intros
{ rcases hu with ⟨u, rfl⟩, apply units.dvd_mul_left, }
rcases hu with ⟨u, rfl⟩
apply units.dvd_mul_left
intros
simpa using div_sub_div a b hc one_ne_zero
intros
by_cases h : b ∈ s
rw [insert_eq_of_mem h, (lcm_eq_right_iff (f b) (s.lcm f) (multiset.normalize_lcm (s.1.map f))).2 (dvd_lcm h)]
{ rw [insert_eq_of_mem h, (lcm_eq_right_iff (f b) (s.lcm f) (multiset.normalize_lcm (s.1.map f))).2 (dvd_lcm h)] }
apply fold_insert h
intros
rw [sum_Ico_eq_sub _ hmn, ← geom_sum_def, ← geom_sum_def, sub_mul, geom_sum_mul, geom_sum_mul, sub_sub_sub_cancel_right]
intros
rw [h, mul_inv_cancel_left]
intros
rw [← neg_sub c b, sub_neg_eq_add, sub_add_sub_cancel]
intros
rw [add_assoc, add_sub_cancel'_right]
intros
{ rw [←h, u.mul_inv], }
rw [←h, u.mul_inv]
intros
induction n with n ih; [rw [nat.add_zero, pow_zero, mul_one], rw [pow_succ', ← mul_assoc, ← ih, ← pow_succ', nat.add_assoc]]
induction n with n ih
rw [nat.add_zero, pow_zero, mul_one]
rw [pow_succ', ← mul_assoc, ← ih, ← pow_succ', nat.add_assoc]
intros
rw [← nat.sub_add_cancel hn, pow_add, hx, mul_zero]
intros
rcases nat.exists_eq_succ_of_ne_zero hk with ⟨l, rfl⟩
clear hk
induction l with l IH
{ simpa using ha }
simpa using ha
rw pow_succ
{ rw pow_succ, exact one_lt_mul' ha IH }
exact one_lt_mul' ha IH
intros
rw [div_div_eq_mul_div, div_mul_eq_mul_div, div_div_eq_div_mul]
intros
simp [C.d_to_eq r]
intros
{ simp, }
simp
intros
{ ext, simp }
ext
simp
intros
funext
{ funext, simp only [mul_indicator], split_ifs, { refl }, rw mul_one }
simp only [mul_indicator]
split_ifs
refl
{ refl }
rw mul_one
intros
simp [mul_assoc]
intros
rw [← neg_neg ⁅x, y⁆, lie_neg z, lie_skew y x, ← lie_skew, lie_lie]
{ rw [← neg_neg ⁅x, y⁆, lie_neg z, lie_skew y x, ← lie_skew, lie_lie], abel, }
abel
intros
rw [lie_hom.map_lie, lie_ring.of_associative_ring_bracket, mul_comm, sub_self]
intros
change A ∈ skew_adjoint_matrices_submodule (u • J) ↔ A ∈ skew_adjoint_matrices_submodule J
simp only [mem_skew_adjoint_matrices_submodule, matrix.is_skew_adjoint, matrix.is_adjoint_pair]
split
split; intros h
intros h
{ simpa using congr_arg (λ B, u⁻¹ • B) h, }
simpa using congr_arg (λ B, u⁻¹ • B) h
intros h
{ simp [h], }
simp [h]
intros
{ cases p, refl, }
cases p
refl
intros
rw [I.incl.is_ideal_morphism_def, incl_ideal_range]
exact (I : lie_subalgebra R L).incl_range.symm
intros
rw [← lie_subalgebra.coe_submodule_le_coe_submodule, ← H.coe_to_lie_submodule, coe_zero_root_subalgebra, lie_submodule.coe_submodule_le_coe_submodule]
exact to_lie_submodule_le_root_space_zero R L H
intros
rw [←neg_neg c, ←neg_neg a, neg_smul_neg, inv_neg, neg_smul _ b, neg_lt_neg_iff]
exact smul_lt_iff_of_pos (neg_pos_of_neg hc)
intros
rw [←cmp_eq_lt_iff, ←cmp_eq_lt_iff, h]
intros
rwa [lt_inv (@zero_lt_one α _ _) h₁, inv_one]
intros
rwa [div_lt_iff_of_neg' hb, ← div_eq_mul_one_div, div_lt_one_of_neg (h.trans hb)]
intros
cases le_total a b; simp [h, hf h]
cases le_total a b
simp [h, hf h]
simp [h, hf h]
intros
rw [← inv_lt_inv_iff, inv_inv]
intros
rw [div_eq_mul_inv, mul_inv_le_inv_mul_iff]
exact ⟨λ h, not_lt.mp (λ k, not_lt.mpr h (mul_lt_mul''' k k)), λ h, mul_le_mul' h h⟩
intros
ext x
simp only [mem_smul_set, algebra.id.smul_eq_mul, mem_Icc]
split
rintro ⟨a, ⟨a_h_left_left, a_h_left_right⟩, rfl⟩
{ rintro ⟨a, ⟨a_h_left_left, a_h_left_right⟩, rfl⟩, split, exact (mul_le_mul_left hr).mpr a_h_left_left, exact (mul_le_mul_left hr).mpr a_h_left_right, }
split
exact (mul_le_mul_left hr).mpr a_h_left_left
exact (mul_le_mul_left hr).mpr a_h_left_right
rintro ⟨a_left, a_right⟩
{ rintro ⟨a_left, a_right⟩, use x / r, refine ⟨⟨(le_div_iff' hr).mpr a_left, (div_le_iff' hr).mpr a_right⟩, _⟩, rw mul_div_cancel' _ (ne_of_gt hr), }
use x / r
refine ⟨⟨(le_div_iff' hr).mpr a_left, (div_le_iff' hr).mpr a_right⟩, _⟩
rw mul_div_cancel' _ (ne_of_gt hr)
intros
haveI := @linear_order.decidable_le α _; exact assume b c b_le_c, decidable.mul_le_mul_of_nonneg_right b_le_c ha
haveI := @linear_order.decidable_le α _
exact assume b c b_le_c, decidable.mul_le_mul_of_nonneg_right b_le_c ha
intros
simpa only [div_eq_mul_inv] using h.mul_const_inv a
intros
simpa only [div_eq_mul_inv] using h.mul_const_inv ha
intros
suffices : distrib_mul_action.to_add_monoid_hom (polynomial R) m = (map_ring_hom (mul_semiring_action.to_ring_hom M R m)).to_add_monoid_hom
{ ext1 r, exact add_monoid_hom.congr_fun this r, }
ext1 r
exact add_monoid_hom.congr_fun this r
ext n r : 2
change m • monomial n r = map (mul_semiring_action.to_ring_hom M R m) (monomial n r)
simpa only [polynomial.map_monomial, polynomial.smul_monomial]
intros
simp [← self_mul_conj, mul_add, add_mul, add_assoc]
intros
induction n with n hn
{ simp only [one, pow_zero] }
simp only [one, pow_zero]
{ rw pow_succ, exact (ra.smul_iff (a ^ n)).mpr hn }
rw pow_succ
exact (ra.smul_iff (a ^ n)).mpr hn
intros
{ ext, simp [h], }
ext
simp [h]
intros
cases n
{ exact ⟨1, 0, (by simp), squarefree_one⟩ }
exact ⟨1, 0, (by simp), squarefree_one⟩
obtain ⟨a, b, -, -, h₁, h₂⟩ := sq_mul_squarefree_of_pos (succ_pos n)
{ obtain ⟨a, b, -, -, h₁, h₂⟩ := sq_mul_squarefree_of_pos (succ_pos n), exact ⟨a, b, h₁, h₂⟩ }
exact ⟨a, b, h₁, h₂⟩
intros
{ ext x, simp [hc] }
ext x
simp [hc]
intros
{ rw zero_locus_inf, simp }
rw zero_locus_inf
simp
intros
refine nnreal.summable_of_le (λ n, _) (nnreal.summable_sigma.1 $ p.change_origin_series_summable_aux₂ hr k).2
simp only [nnreal.tsum_mul_right]
exact mul_le_mul' (p.nnnorm_change_origin_series_le_tsum _ _) le_rfl
intros
rcases i with ⟨n, f⟩
dsimp [composition.blocks_fun, composition.blocks, comp_change_of_variables]
simp only [map_of_fn, nth_le_of_fn', function.comp_app]
apply congr_arg
exact fin.eta _ _
intros
refine ⟨is_equivalent.is_O, λ h, _⟩
rw [is_equivalent_zero_iff_eventually_zero, eventually_eq_iff_exists_mem]
exact ⟨{x : α | u x = 0}, is_O_zero_right_iff.mp h, λ x hx, hx⟩
intros
unfold is_O_with
refine h.symm.rw (λ x a, ∥a∥ ≤ c * ∥v x∥) (hφ.mono $ λ x hx, _)
simp only [normed_field.norm_mul, pi.mul_apply]
exact mul_le_mul_of_nonneg_right hx (norm_nonneg _)
intros
{ unfold is_O, exact exists_congr (λ _, is_O_with_norm_right) }
unfold is_O
exact exists_congr (λ _, is_O_with_norm_right)
intros
have := has_fderiv_at.iterate hf hx n
rwa [continuous_linear_map.smul_right_one_pow] at this
intros
have := (hc.has_strict_fderiv_at.clm_apply hu.has_strict_fderiv_at).has_strict_deriv_at
rwa [add_apply, comp_apply, flip_apply, smul_right_apply, smul_right_apply, one_apply, one_smul, one_smul, add_comm] at this
intros
{ unfold deriv_within, rw hL.fderiv_within_eq hs hx }
unfold deriv_within
rw hL.fderiv_within_eq hs hx
intros
{ convert hc.mul' hd, ext z, apply mul_comm }
convert hc.mul' hd
ext z
apply mul_comm
intros
refine (has_fderiv_within_at_univ.2 hf).lim _ (univ_mem' (λ _, trivial)) hc _
assume U hU
refine (eventually_ne_of_tendsto_norm_at_top hc (0:𝕜)).mono (λ y hy, _)
convert mem_of_mem_nhds hU
dsimp only
rw [← mul_smul, mul_inv_cancel hy, one_smul]
intros
{ ext m, rw fderiv_const_apply, refl }
ext m
rw fderiv_const_apply
refl
intros
rw [iterated_deriv_within_eq_iterate hxs hx, iterated_deriv_within_eq_iterate hxs hx]
{ rw [iterated_deriv_within_eq_iterate hxs hx, iterated_deriv_within_eq_iterate hxs hx], refl }
refl
intros
simpa only [sub_zero, mul_one] using norm_image_sub_le_of_norm_deriv_le_segment hf bound 1 (right_mem_Icc.2 zero_le_one)
intros
cases le_or_gt x 0
{ exact ge_of_eq (zero_of_nonpos h) }
exact ge_of_eq (zero_of_nonpos h)
{ exact le_of_lt (pos_of_pos h) }
exact le_of_lt (pos_of_pos h)
intros
rw ← has_ftaylor_series_up_to_on_univ_iff at h ⊢
{ rw ← has_ftaylor_series_up_to_on_univ_iff at h ⊢, exact h.of_le hmn }
exact h.of_le hmn
intros
split
assume H
{ assume H, have : f = e.symm ∘ (e ∘ f), by { ext y, simp only [function.comp_app], rw e.symm_apply_apply (f y) }, rw this, exact H.continuous_linear_map_comp _ }
have : f = e.symm ∘ (e ∘ f)
ext y
ext y
{ ext y, simp only [function.comp_app], rw e.symm_apply_apply (f y) }
{ ext y, simp only [function.comp_app], rw e.symm_apply_apply (f y) }
simp only [function.comp_app]
simp only [function.comp_app]
rw e.symm_apply_apply (f y)
rw e.symm_apply_apply (f y)
rw this
exact H.continuous_linear_map_comp _
assume H
{ assume H, exact H.continuous_linear_map_comp _ }
exact H.continuous_linear_map_comp _
intros
simpa only [div_eq_mul_inv] using hf.mul times_cont_diff_on_const
intros
rcases h m hm with ⟨u, u_nhd, p, hp⟩
refine ⟨u ∩ insert x s, filter.inter_mem u_nhd self_mem_nhds_within, inter_subset_right _ _, _⟩
assume y hy m' hm'
refine ⟨u ∩ insert x s, _, p, (hp.mono (inter_subset_left _ _)).of_le hm'⟩
convert self_mem_nhds_within
exact insert_eq_of_mem hy
ext
{ ext, simp }
simp
intros
refine ⟨λ h x y hx hy a b ha hb hab, h hx hy ha.le hb.le hab, _⟩
intros h x y hx hy a b ha hb hab
cases ha.eq_or_lt with ha ha
{ subst a, rw [zero_add] at hab, simp [hab, hy] }
subst a
rw [zero_add] at hab
simp [hab, hy]
cases hb.eq_or_lt with hb hb
{ subst b, rw [add_zero] at hab, simp [hab, hx] }
subst b
rw [add_zero] at hab
simp [hab, hx]
exact h hx hy ha hb hab
intros
simp only [finset.center_mass, finset.smul_sum, (mul_smul _ _ _).symm, mul_comm c, mul_assoc]
intros
rw [hs.convex_hull_eq_image]
apply (compact_std_simplex _).image
haveI := hs.fintype
apply linear_map.continuous_on_pi
intros
rw [←inner_conj_sym, conj_im]
intros
simp only [dist_eq_norm]
{ simp only [dist_eq_norm], exact (hf.sub hg).norm (sub_ne_zero.2 hne) }
exact (hf.sub hg).norm (sub_ne_zero.2 hne)
intros
simp [dist_eq_norm_vsub V _ x]
intros
by_cases hx : 0 ≤ x
{ rw real.ennnorm_eq_of_real hx, refl' }
rw real.ennnorm_eq_of_real hx
refl'
rw [ennreal.of_real_eq_zero.2 (le_of_lt (not_le.1 hx))]
{ rw [ennreal.of_real_eq_zero.2 (le_of_lt (not_le.1 hx))], exact bot_le }
exact bot_le
intros
rw [mem_ball_iff_norm, add_sub_cancel']
intros
intros w
rcases exists_ne (0 : M') with ⟨a, ha⟩
have : f' a = f' 0
{ simp_rw [w, continuous_linear_map.zero_apply], }
simp_rw [w, continuous_linear_map.zero_apply]
exact ha (hf'.injective this)
intros
simp
intros
refine le_antisymm (multilinear_map.mk_continuous_norm_le _ (norm_nonneg _) _) _
convert ratio_le_op_norm _ (λ _, 1); [simp, apply_instance]
convert ratio_le_op_norm _ (λ _, 1)
simp
apply_instance
intros
{ rw h, exact norm_comp_le_of_le hg hf }
rw h
exact norm_comp_le_of_le hg hf
intros
ext
ext; simp
simp
simp
simp
simp
intros
simp only [log_im, neg_pi_lt_arg]
intros
rw has_deriv_at_iff_is_o_nhds_zero
have : (1 : ℕ) < 2 := by norm_num
refine (is_O.of_bound (∥exp x∥) _).trans_is_o (is_o_pow_id this)
filter_upwards [metric.ball_mem_nhds (0 : ℂ) zero_lt_one]
simp only [metric.mem_ball, dist_zero_right, normed_field.norm_pow]
intros z hz
calc ∥exp (x + z) - exp x - z * exp x∥ = ∥exp x * (exp z - 1 - z)∥ : by { congr, rw [exp_add], ring } ... = ∥exp x∥ * ∥exp z - 1 - z∥ : normed_field.norm_mul _ _ ... ≤ ∥exp x∥ * ∥z∥^2 : mul_le_mul_of_nonneg_left (abs_exp_sub_one_sub_id_le (le_of_lt hz)) (norm_nonneg _)
intros
simpa using integral_sin_pow_odd_mul_cos_pow 0 1
intros
rcases eq_or_ne z 0 with rfl|hz
simp
{ simp }
replace hz := hz.lt_or_lt
wlog hxy : x ≤ y := le_total x y using [x y, y x] tactic.skip
rcases eq_or_ne x 0 with rfl|hx0
{ rcases eq_or_ne x 0 with rfl|hx0, { induction y using with_top.rec_top_coe; cases hz with hz hz; simp [*, hz.not_lt] }, rcases eq_or_ne y 0 with rfl|hy0, { exact (hx0 (bot_unique hxy)).elim }, induction x using with_top.rec_top_coe, { cases hz with hz hz; simp [hz, top_unique hxy] }, induction y using with_top.rec_top_coe, { cases hz with hz hz; simp * }, simp only [*, false_and, and_false, false_or, if_false], norm_cast at *, rw [coe_rpow_of_ne_zero (mul_ne_zero hx0 hy0), nnreal.mul_rpow] }
induction y using with_top.rec_top_coe; cases hz with hz hz; simp [*, hz.not_lt]
induction y using with_top.rec_top_coe; cases hz with hz hz
induction y using with_top.rec_top_coe
{ induction y using with_top.rec_top_coe; cases hz with hz hz; simp [*, hz.not_lt] }
cases hz with hz hz
simp [*, hz.not_lt]
simp [*, hz.not_lt]
cases hz with hz hz
simp [*, hz.not_lt]
simp [*, hz.not_lt]
rcases eq_or_ne y 0 with rfl|hy0
exact (hx0 (bot_unique hxy)).elim
{ exact (hx0 (bot_unique hxy)).elim }
induction x using with_top.rec_top_coe
cases hz with hz hz
cases hz with hz hz; simp [hz, top_unique hxy]
{ cases hz with hz hz; simp [hz, top_unique hxy] }
simp [hz, top_unique hxy]
simp [hz, top_unique hxy]
induction y using with_top.rec_top_coe
cases hz with hz hz
cases hz with hz hz; simp *
{ cases hz with hz hz; simp * }
simp *
simp *
simp only [*, false_and, and_false, false_or, if_false]
norm_cast at *
rw [coe_rpow_of_ne_zero (mul_ne_zero hx0 hy0), nnreal.mul_rpow]
convert this using 2; simp only [mul_comm, and_comm, or_comm]
convert this using 2
{ convert this using 2; simp only [mul_comm, and_comm, or_comm] }
simp only [mul_comm, and_comm, or_comm]
simp only [mul_comm, and_comm, or_comm]
simp only [mul_comm, and_comm, or_comm]
intros
rcases le_iff_eq_or_lt.1 hx with H|pos
by_cases h : y + z = 0
{ by_cases h : y + z = 0, { simp only [H.symm, h, rpow_zero], calc (0 : ℝ) ^ y * 0 ^ z ≤ 1 * 1 : mul_le_mul (zero_rpow_le_one y) (zero_rpow_le_one z) (zero_rpow_nonneg z) zero_le_one ... = 1 : by simp }, { simp [rpow_add', ← H, h] } }
simp only [H.symm, h, rpow_zero]
{ simp only [H.symm, h, rpow_zero], calc (0 : ℝ) ^ y * 0 ^ z ≤ 1 * 1 : mul_le_mul (zero_rpow_le_one y) (zero_rpow_le_one z) (zero_rpow_nonneg z) zero_le_one ... = 1 : by simp }
calc (0 : ℝ) ^ y * 0 ^ z ≤ 1 * 1 : mul_le_mul (zero_rpow_le_one y) (zero_rpow_le_one z) (zero_rpow_nonneg z) zero_le_one ... = 1 : by simp
{ simp [rpow_add', ← H, h] }
simp [rpow_add', ← H, h]
{ simp [rpow_add pos] }
simp [rpow_add pos]
intros
rcases hx.eq_or_lt with (rfl|hx)
rcases em (y = 0) with (rfl|hy); simp [*, lt_irrefl, zero_lt_one]
rcases em (y = 0) with (rfl|hy)
{ rcases em (y = 0) with (rfl|hy); simp [*, lt_irrefl, zero_lt_one] }
simp [*, lt_irrefl, zero_lt_one]
simp [*, lt_irrefl, zero_lt_one]
{ simp [rpow_lt_one_iff_of_pos hx, hx.ne.symm] }
simp [rpow_lt_one_iff_of_pos hx, hx.ne.symm]
intros
simp [sin_add]
simpa only [function.periodic, tan_eq_sin_div_cos] using sin_antiperiodic.div cos_antiperiodic
rw [real.pi, mul_div_cancel_left _ (@two_ne_zero' ℝ _ _ _)]
rw [real.pi, mul_div_cancel_left _ (@two_ne_zero' ℝ _ _ _)]; exact (classical.some_spec exists_cos_eq_zero).1.1
exact (classical.some_spec exists_cos_eq_zero).1.1
intros
cases le_total x (-1) with hx₁ hx₁
rw [arcsin_of_le_neg_one hx₁, neg_neg, arcsin_of_one_le (le_neg.2 hx₁)]
{ rw [arcsin_of_le_neg_one hx₁, neg_neg, arcsin_of_one_le (le_neg.2 hx₁)] }
cases le_total 1 x with hx₂ hx₂
rw [arcsin_of_one_le hx₂, arcsin_of_le_neg_one (neg_le_neg hx₂)]
{ rw [arcsin_of_one_le hx₂, arcsin_of_le_neg_one (neg_le_neg hx₂)] }
refine arcsin_eq_of_sin_eq _ _
{ rw [sin_neg, sin_arcsin hx₁ hx₂] }
rw [sin_neg, sin_arcsin hx₁ hx₂]
exact ⟨neg_le_neg (arcsin_le_pi_div_two _), neg_le.2 (neg_pi_div_two_le_arcsin _)⟩
{ exact ⟨neg_le_neg (arcsin_le_pi_div_two _), neg_le.2 (neg_pi_div_two_le_arcsin _)⟩ }
rw ← nnreal.tendsto_coe
{ rw ← nnreal.tendsto_coe, convert tendsto_inverse_at_top_nhds_0_nat, simp }
convert tendsto_inverse_at_top_nhds_0_nat
simp
intros
rw [equiv.symm_apply_eq]; simp [-hom_equiv_counit]
rw [equiv.symm_apply_eq]
simp [-hom_equiv_counit]
intros
{ erw functor.map_comp, simp }
erw functor.map_comp
simp
intros
{ simp [nat_trans.left_derived], refl, }
simp [nat_trans.left_derived]
refl
intros
{ cases h, refl, }
cases h
refl
intros
simp only [cancel_epi]
intros
dsimp [colimit_obj_iso_colimit_comp_evaluation]
simp
intros
{ erw is_colimit.fac, refl, }
erw is_colimit.fac
refl
intros
simp
intros
simp
intros
simp
intros
ext
intros
rw [right_unitor_naturality, ←category.assoc, iso.inv_hom_id, category.id_comp]
intros
tidy
intros
simp [biprod.of_components]
intros
simp [exact.lift]
conv_lhs { congr, skip, rw ← image_subobject_arrow_comp f, }
rw [←category.assoc, factor_thru_comp, ←image_to_kernel_arrow, ←category.assoc, category_theory.projective.factor_thru_comp, factor_thru_kernel_subobject_comp_arrow]
intros
ext W h
split
rintro ⟨W, _, _, _⟩
{ rintro ⟨W, _, _, _⟩, exact singleton.mk }
exact singleton.mk
rintro ⟨_⟩
{ rintro ⟨_⟩, exact pullback_arrows.mk Z g singleton.mk }
exact pullback_arrows.mk Z g singleton.mk
intros
revert g
apply quotient.ind
intro g'
apply quotient.sound
exact ⟨(mono_over.pullback_map_self f).app _⟩
intros
rw [le_iff_le_iff_lt_iff_lt, singleton_lt_iff_lt]
intros
split
rw ← not_imp_not
{ rw ← not_imp_not, assume h, exact set.disjoint_right.1 (c.disjoint_range h) (c.mem_range_embedding j) }
assume h
exact set.disjoint_right.1 (c.disjoint_range h) (c.mem_range_embedding j)
assume h
{ assume h, rw h, exact c.mem_range_embedding j }
rw h
exact c.mem_range_embedding j
intros
ext
simp only [is_adj_matrix.to_graph_adj, adj_matrix_apply, ite_eq_left_iff, zero_ne_one]
apply not_not
intros
cases d₁ with s₁ t₁ h₁
cases d₂ with s₂ t₂ h₂
simp only [dart.edge, dart.rev_edge, dart.rev]
rw sym2.eq_iff
intros
letI := primcodable.subtype hp
refine ⟨λ h, _, λ hf, subtype_val.comp hf⟩
refine nat.primrec.of_eq h (λ n, _)
cases decode α n with a
refl
{refl}
simp
cases f a; refl
cases f a
refl
intros
cases q; apply_rules [finset.mem_insert_self, finset.mem_singleton_self]
cases q
apply_rules [finset.mem_insert_self, finset.mem_singleton_self]
apply_rules [finset.mem_insert_self, finset.mem_singleton_self]
apply_rules [finset.mem_insert_self, finset.mem_singleton_self]
apply_rules [finset.mem_insert_self, finset.mem_singleton_self]
apply_rules [finset.mem_insert_self, finset.mem_singleton_self]
apply_rules [finset.mem_insert_self, finset.mem_singleton_self]
intros
induction n with n IH generalizing L; simp only [*, list_blank.head_map, list_blank.modify_nth, list_blank.map_cons, list_blank.tail_map]
induction n with n IH generalizing L
simp only [*, list_blank.head_map, list_blank.modify_nth, list_blank.map_cons, list_blank.tail_map]
simp only [*, list_blank.head_map, list_blank.modify_nth, list_blank.map_cons, list_blank.tail_map]
intros
cases mem_eval.1 ab with ab b0
rcases tr_reaches H aa ab with ⟨b₂, bb, ab⟩
refine ⟨_, bb, mem_eval.2 ⟨ab, _⟩⟩
have := H bb
rwa b0 at this
intros
revert hx
simp [(∈)]
intros i hx
subst x
apply approx_mono'
intros
rw @map_eq_traverse_id t _ _ _ _ g
refine (comp_traverse f (id.mk ∘ g) x).symm.trans _
congr
apply comp.applicative_id_comp
intros
refine eq_of_nhds_eq_nhds (λ x, _)
ext s
rw [mem_nhds_to_topsp, H]
intros
have : b.to_list.to_buffer.read ⟨i, (by simpa using h')⟩ = b.read ⟨i, h'⟩
congr' 1; simp [fin.heq_ext_iff]
{ congr' 1; simp [fin.heq_ext_iff] }
congr' 1
simp [fin.heq_ext_iff]
simp [fin.heq_ext_iff]
simp [←this]
intros
introI h
have : (pure a : parser α) buffer.nil 0 = done 0 a := by simp [pure_eq_done]
replace this : 0 < 0 := prog.of_done this
exact (lt_irrefl _) this
intros
cases hp : p cb n with np resp np errp
{ simp [hp, ←orelse_eq_orelse, parser.orelse] }
simp [hp, ←orelse_eq_orelse, parser.orelse]
by_cases hn : np = n
{ by_cases hn : np = n, { cases hq : q cb n with nq resq nq errq, { simp [hp, hn, hq, ←orelse_eq_orelse, parser.orelse] }, { rcases lt_trichotomy nq n with H|rfl|H; simp [hp, hq, hn, ←orelse_eq_orelse, parser.orelse, H, ne_of_gt H, ne_of_lt H, not_lt_of_lt H] <|> simp [hp, hq, hn, ←orelse_eq_orelse, parser.orelse, lt_irrefl] } }, { simp [hp, hn, ←orelse_eq_orelse, parser.orelse] } }
cases hq : q cb n with nq resq nq errq
{ cases hq : q cb n with nq resq nq errq, { simp [hp, hn, hq, ←orelse_eq_orelse, parser.orelse] }, { rcases lt_trichotomy nq n with H|rfl|H; simp [hp, hq, hn, ←orelse_eq_orelse, parser.orelse, H, ne_of_gt H, ne_of_lt H, not_lt_of_lt H] <|> simp [hp, hq, hn, ←orelse_eq_orelse, parser.orelse, lt_irrefl] } }
{ simp [hp, hn, hq, ←orelse_eq_orelse, parser.orelse] }
simp [hp, hn, hq, ←orelse_eq_orelse, parser.orelse]
rcases lt_trichotomy nq n with H|rfl|H; simp [hp, hq, hn, ←orelse_eq_orelse, parser.orelse, H, ne_of_gt H, ne_of_lt H, not_lt_of_lt H] <|> simp [hp, hq, hn, ←orelse_eq_orelse, parser.orelse, lt_irrefl]
rcases lt_trichotomy nq n with H|rfl|H
{ rcases lt_trichotomy nq n with H|rfl|H; simp [hp, hq, hn, ←orelse_eq_orelse, parser.orelse, H, ne_of_gt H, ne_of_lt H, not_lt_of_lt H] <|> simp [hp, hq, hn, ←orelse_eq_orelse, parser.orelse, lt_irrefl] }
simp [hp, hq, hn, ←orelse_eq_orelse, parser.orelse, H, ne_of_gt H, ne_of_lt H, not_lt_of_lt H]
simp [hp, hq, hn, ←orelse_eq_orelse, parser.orelse, H, ne_of_gt H, ne_of_lt H, not_lt_of_lt H]
simp [hp, hq, hn, ←orelse_eq_orelse, parser.orelse, lt_irrefl]
simp [hp, hq, hn, ←orelse_eq_orelse, parser.orelse, H, ne_of_gt H, ne_of_lt H, not_lt_of_lt H]
{ simp [hp, hn, ←orelse_eq_orelse, parser.orelse] }
simp [hp, hn, ←orelse_eq_orelse, parser.orelse]
intros
simp [eps, pure_eq_done]
intros
simp [many_char1, list.as_string_eq, string.to_list_nonempty h, many1_eq_done, many_char_eq_many_of_to_list]
intros
rw [pow_bit0', I_mul_I]
intros
simp [div_eq_mul_inv, mul_assoc, sub_eq_add_neg, add_comm]
intros
simp [exp_near, mul_sub]
intros
rw [← neg_mul_eq_neg_mul, ← cosh_sub_sinh, sinh_mul_I, cosh_mul_I]
intros
rw ext_iff
{ rw ext_iff, simp only [of_real_im, conj_im, eq_self_iff_true, conj_re, and_self, neg_zero] }
simp only [of_real_im, conj_im, eq_self_iff_true, conj_re, and_self, neg_zero]
intros
rw [← of_real_nat_cast, of_real_re]
intros
letI : normed_space ℝ E := restrict_scalars.normed_space ℝ K E
letI : is_scalar_tower ℝ K E := restrict_scalars.is_scalar_tower _ _ _
letI : finite_dimensional ℝ E := finite_dimensional.trans ℝ K E
apply_instance
intros
{ ext ⟨a, b⟩ : 1, simp }
ext ⟨a, b⟩ : 1
simp
intros
by_cases hi : k = i
rw [hi, swap_apply_left, hv]
{ rw [hi, swap_apply_left, hv] }
by_cases hj : k = j
rw [hj, swap_apply_right, hv]
{ rw [hj, swap_apply_right, hv] }
rw swap_apply_of_ne_of_ne hi hj
intros
{ ext, refl }
ext
refl
intros
ext x
by_cases h : p x
have : p (ep.symm ⟨x, h⟩) := subtype.property _
{ have : p (ep.symm ⟨x, h⟩) := subtype.property _, simp [perm.subtype_congr.apply, h, symm_apply_eq, this] }
simp [perm.subtype_congr.apply, h, symm_apply_eq, this]
have : ¬ p (en.symm ⟨x, h⟩) := subtype.property (en.symm _)
{ have : ¬ p (en.symm ⟨x, h⟩) := subtype.property (en.symm _), simp [perm.subtype_congr.apply, h, symm_apply_eq, this] }
simp [perm.subtype_congr.apply, h, symm_apply_eq, this]
intros
simp [fin_succ_equiv']
intros
have A : (e.trans e.symm).source = e.source
mfld_set_tac
mfld_set_tac
refine ⟨by simp [A], λx hx, _⟩
rw A at hx
simp only [hx] with mfld_simps
intros
cases h.lt_or_lt with hlt hlt
exacts [⟨_, succ_above_cast_lt hlt⟩, ⟨_, succ_above_pred hlt⟩]
intros
have : i.cast_succ.val < n := i.is_lt
have h' := fin.cast_lt_cast_succ i i.is_lt
simp [snoc, this, h']
convert cast_eq rfl (p i)
intros
{ ext, refl }
ext
refl
intros
rcases s with ⟨⟨a⟩, h⟩; exact H ⟨a, h⟩
rcases s with ⟨⟨a⟩, h⟩
exact H ⟨a, h⟩
intros
rw ←multiset.coe_eq_coe
exact multiset.nodup.to_finset_inj hl hl' h
intros
{ ext ⟨x, y⟩, simp [and.left_comm] }
ext ⟨x, y⟩
simp [and.left_comm]
intros
split
{ intros h, subst h, simp, }
intros h
subst h
simp
rintros ⟨hne, h_uniq⟩
{ rintros ⟨hne, h_uniq⟩, rw eq_singleton_iff_unique_mem, refine ⟨_, h_uniq⟩, rw ← h_uniq hne.some hne.some_spec, apply hne.some_spec, }
rw eq_singleton_iff_unique_mem
refine ⟨_, h_uniq⟩
rw ← h_uniq hne.some hne.some_spec
apply hne.some_spec
intros
rw le_iff_exists_add
use kl.1
rwa [mem_antidiagonal, eq_comm, add_comm] at hlk
intros
simp [subset_iff, @forall_swap _ β]
intros
apply fin.strict_mono_unique hmono (s.order_emb_of_fin h).strict_mono
rw [range_order_emb_of_fin, ← set.image_univ, ← coe_fin_range, ← coe_image, coe_inj]
refine eq_of_subset_of_card_le (λ x hx, _) _
{ rcases mem_image.1 hx with ⟨x, hx, rfl⟩, exact hfs x }
rcases mem_image.1 hx with ⟨x, hx, rfl⟩
exact hfs x
rw [h, card_image_of_injective _ hmono.injective, fin_range_card]
{ rw [h, card_image_of_injective _ hmono.injective, fin_range_card] }
intros
rw [← coe_zero, coe_fn_inj]
intros
rw [single_eq_indicator, ← set.piecewise_eq_indicator, set.piecewise_singleton]
intros
split
intro h
{ intro h, exact ⟨h.2, card_congr (equiv.of_bijective f h)⟩, }
exact ⟨h.2, card_congr (equiv.of_bijective f h)⟩
rintro ⟨hf, h⟩
{ rintro ⟨hf, h⟩, refine ⟨_, hf⟩, rwa injective_iff_surjective_of_equiv (equiv_of_card_eq h) }
refine ⟨_, hf⟩
rwa injective_iff_surjective_of_equiv (equiv_of_card_eq h)
intros
{ classical, rw [univ_sum_type, prod_sum_elim] }
classical
rw [univ_sum_type, prod_sum_elim]
intros
unfold contains_aux
cases h : find_aux a l with b; simp
cases h : find_aux a l with b
simp
assume (b : β a) (m : sigma.mk a b ∈ l)
{ assume (b : β a) (m : sigma.mk a b ∈ l), rw (find_aux_iff nd).2 m at h, contradiction }
rw (find_aux_iff nd).2 m at h
contradiction
simp
show ∃ (b : β a), sigma.mk a b ∈ l
{ show ∃ (b : β a), sigma.mk a b ∈ l, exact ⟨_, (find_aux_iff nd).1 h⟩ }
exact ⟨_, (find_aux_iff nd).1 h⟩
intros
simp [cast_heq, mul_assoc0, assoc_left]
intros
rw [← int.coe_nat_zero, coe_nat_lt]
intros
apply @nat.prime.dvd_of_dvd_pow _ _ 2 hp
rwa [sq, ← nat_abs_mul, ← coe_nat_dvd_left, ← sq]
intros
rw int.lcm at h ⊢; rwa int.nat_abs_neg
rw int.lcm at h ⊢
rwa int.nat_abs_neg
intros
cases even_or_odd n with h
{ exact or.inl ⟨h, even_iff_not_odd.mp h⟩ }
exact or.inl ⟨h, even_iff_not_odd.mp h⟩
{ exact or.inr ⟨h, odd_iff_not_even.mp h⟩ }
exact or.inr ⟨h, odd_iff_not_even.mp h⟩
intros
simp [extract]; split; refl
simp [extract]; split
simp [extract]
split
refl
refl
intros
induction l with hd tl IH generalizing n
cases n
{ cases n, { simpa using h }, { simp } }
{ simpa using h }
simpa using h
{ simp }
simp
cases n
{ cases n, { simpa using h }, { simp only [nat.succ_lt_succ_iff, length] at h, simpa using IH _ h } }
{ simpa using h }
simpa using h
simp only [nat.succ_lt_succ_iff, length] at h
{ simp only [nat.succ_lt_succ_iff, length] at h, simpa using IH _ h }
simpa using IH _ h
intros
rw nth_le_of_eq (take_append_drop j L).symm hi
{ rw nth_le_of_eq (take_append_drop j L).symm hi, exact nth_le_append _ _ }
exact nth_le_append _ _
intros
induction l; simp *
induction l
simp *
simp *
intros
induction L with j L IH h
simp
{ simp }
rw [sum_cons, length, add_comm]
exact add_le_add (h _ (set.mem_insert _ _)) (IH (λ i hi, h i (set.mem_union_right _ hi)))
intros
rw [← filter_map_eq_map, filter_map_filter_map]
rw [← filter_map_eq_map, filter_map_filter_map]; refl
refl
intros
rw ← drop_one
rw ← drop_one; apply drop_suffix
apply drop_suffix
intros
induction ts with a ts ih; [refl, {simp [← ih], refl}]
induction ts with a ts ih
refl
simp [← ih]
refl
intros
simp only [list.sigma, mem_bind, mem_map, exists_prop, exists_and_distrib_left, and.left_comm, exists_eq_left, heq_iff_eq, exists_eq_right]
intros
simp only [zip_left, zip_left', map₂_left_eq_map₂_left']
intros
induction l; [refl, simp only [*, reverse_cons, length_append, length]]
induction l
refl
simp only [*, reverse_cons, length_append, length]
intros
cases l
{ simp [prev, hy, hz] }
simp [prev, hy, hz]
{ rw [prev, dif_neg hy, if_pos hz] }
rw [prev, dif_neg hy, if_pos hz]
intros
induction as generalizing start; simp [mmap_with_index'_aux, mmap_with_index_aux, *, seq_right_eq, const, -comp_const] with functor_norm
induction as generalizing start
simp [mmap_with_index'_aux, mmap_with_index_aux, *, seq_right_eq, const, -comp_const] with functor_norm
simp [mmap_with_index'_aux, mmap_with_index_aux, *, seq_right_eq, const, -comp_const] with functor_norm
intros
induction p with a l₁ l₂ p IH a b l l₁ l₂ l₃ p₁ p₂ IH₁ IH₂
simp
{simp}
{ simp, exact IH.append_left _ }
simp
exact IH.append_left _
simp
{ simp, rw [← append_assoc, ← append_assoc], exact perm_append_comm.append_right _ }
rw [← append_assoc, ← append_assoc]
exact perm_append_comm.append_right _
{ exact IH₁.trans IH₂ }
exact IH₁.trans IH₂
intros
cases l with x l
{ simp }
simp
rw nodup_iff_nth_le_inj
intros i j hi hj h
simp only [length_cyclic_permutations_cons] at hi hj
rw [←mod_eq_of_lt hi, ←mod_eq_of_lt hj, ←length_cons x l]
apply hn.rotate_congr
{ simp }
simp
{ simpa using h }
simpa using h
intros
simp [kerase, h]
intros
rw [(L.perm_ordered_insert r b).count_eq, count_cons]
split_ifs; simp only [nat.succ_eq_add_one, add_zero]
split_ifs
simp only [nat.succ_eq_add_one, add_zero]
simp only [nat.succ_eq_add_one, add_zero]
intros
rw [sublists_len, sublists_len_aux, sublists_len_aux_eq, sublists_len_aux_eq, map_id, append_nil]
rw [sublists_len, sublists_len_aux, sublists_len_aux_eq, sublists_len_aux_eq, map_id, append_nil]; refl
refl
intros
ext i
{ ext i, simp only [vec_mul, dot_product, finset.smul_sum, pi.smul_apply, smul_mul_assoc] }
simp only [vec_mul, dot_product, finset.smul_sum, pi.smul_apply, smul_mul_assoc]
intros
{ ext i j, apply dot_product_zero }
ext i j
apply dot_product_zero
intros
{ simp only [std_basis_matrix, and_imp, ite_eq_right_iff], tauto }
simp only [std_basis_matrix, and_imp, ite_eq_right_iff]
tauto
intros
ext
simp only [block_diagonal_apply, pi.neg_apply]
split_ifs; simp
split_ifs
simp
simp
intros
{ ext i j, refine fin.cases _ _ i, { refl }, simp }
ext i j
refine fin.cases _ _ i
refl
{ refl }
simp
intros
simp [h]
intros
rw [← sup_erase_dup, erase_dup_ext.2, sup_erase_dup, sup_add]
rw [← sup_erase_dup, erase_dup_ext.2, sup_erase_dup, sup_add]; simp
simp
intros
convert rfl
intros
apply mv_polynomial.induction_on p; simp [ eval₂_add, k.map_add, eval₂_mul, k.map_mul] {contextual := tt}
apply mv_polynomial.induction_on p
simp [ eval₂_add, k.map_add, eval₂_mul, k.map_mul] {contextual := tt}
simp [ eval₂_add, k.map_add, eval₂_mul, k.map_mul] {contextual := tt}
simp [ eval₂_add, k.map_add, eval₂_mul, k.map_mul] {contextual := tt}
intros
rw [aeval_rename, function.comp.left_id]
intros
rw [vars, degrees_monomial_eq _ _ h, finsupp.to_finset_to_multiset]
intros
split
intro h
{ intro h, cases le_total n m with H H, { simpa [H] using or.inr h }, { simpa [H] using or.inl h } }
cases le_total n m with H H
{ simpa [H] using or.inr h }
simpa [H] using or.inr h
{ simpa [H] using or.inl h }
simpa [H] using or.inl h
rintro (rfl|rfl); simp
rintro (rfl|rfl)
{ rintro (rfl|rfl); simp }
simp
simp
intros
induction n using nat.binary_rec with b n hn
{ refl }
refl
have : b = ff := by simpa using h 0
{ have : b = ff := by simpa using h 0, rw [this, bit_ff, bit0_val, hn (λ i, by rw [←h (i + 1), test_bit_succ]), mul_zero] }
rw [this, bit_ff, bit0_val, hn (λ i, by rw [←h (i + 1), test_bit_succ]), mul_zero]
intros
have r : k + (p - k) = p
rw [← nat.add_sub_assoc (nat.le_of_lt hkp) k, nat.add_sub_cancel_left]
rw [← nat.add_sub_assoc (nat.le_of_lt hkp) k, nat.add_sub_cancel_left]
have e : p ∣ choose (k + (p - k)) k
exact dvd_choose_add hkp (nat.sub_lt (hk.trans hkp) hk) (by rw r) hp
exact dvd_choose_add hkp (nat.sub_lt (hk.trans hkp) hk) (by rw r) hp
rwa r at e
intros
rw [of_digits_append, of_digits_digits, of_digits_digits]
intros
rcases ne_top_iff.1 hc with ⟨c, rfl⟩
apply enat.cases_on a; apply enat.cases_on b; simp [add_eq_top_iff, coe_ne_top, @eq_comm _ (⊤ : enat)]; simp only [(nat.cast_add _ _).symm, add_left_cancel_iff, enat.coe_inj, add_comm]; tauto
apply enat.cases_on a; apply enat.cases_on b; simp [add_eq_top_iff, coe_ne_top, @eq_comm _ (⊤ : enat)]; simp only [(nat.cast_add _ _).symm, add_left_cancel_iff, enat.coe_inj, add_comm]
apply enat.cases_on a; apply enat.cases_on b; simp [add_eq_top_iff, coe_ne_top, @eq_comm _ (⊤ : enat)]
apply enat.cases_on a; apply enat.cases_on b
apply enat.cases_on a
apply enat.cases_on b
simp [add_eq_top_iff, coe_ne_top, @eq_comm _ (⊤ : enat)]
simp [add_eq_top_iff, coe_ne_top, @eq_comm _ (⊤ : enat)]
apply enat.cases_on b
simp [add_eq_top_iff, coe_ne_top, @eq_comm _ (⊤ : enat)]
simp [add_eq_top_iff, coe_ne_top, @eq_comm _ (⊤ : enat)]
simp only [(nat.cast_add _ _).symm, add_left_cancel_iff, enat.coe_inj, add_comm]
tauto
intros
simpa only [coprime_comm] using coprime_mul_iff_left
intros
{ rw clog_of_two_le hb hn, exact zero_lt_succ _ }
rw clog_of_two_le hb hn
exact zero_lt_succ _
intros
rw [← Union_prod]
{ rw [← Union_prod], convert surjective_unpair.Union_comp _, refl }
convert surjective_unpair.Union_comp _
refl
intros
have := @size_pos n; simp [pos_iff_ne_zero] at this; exact decidable.not_iff_not.1 this
have := @size_pos n; simp [pos_iff_ne_zero] at this
have := @size_pos n
simp [pos_iff_ne_zero] at this
exact decidable.not_iff_not.1 this
intros
induction k; simp [*, add_succ, bind_assoc]
induction k
simp [*, add_succ, bind_assoc]
simp [*, add_succ, bind_assoc]
intros
cases b; refl
cases b
refl
refl
intros
simp_rw [←map_eq_map, ←bind_pure_comp_eq_map,is_lawful_monad.bind_assoc]
intros
rw balance_l_eq_balance' hl.3 hr.3 hl.2 hr.2 H
refine hl.balance' hr _
rcases H with ⟨l', e, H⟩ | ⟨r', e, H⟩
{ exact ⟨_, _, H, or.inl ⟨e.dist_le', rfl⟩⟩ }
exact ⟨_, _, H, or.inl ⟨e.dist_le', rfl⟩⟩
{ exact ⟨_, _, H, or.inr ⟨e.dist_le, rfl⟩⟩ }
exact ⟨_, _, H, or.inr ⟨e.dist_le, rfl⟩⟩
intros
simp [balance', add_comm]
split_ifs
split_ifs; simp [dual_node', dual_rotate_l, dual_rotate_r]
simp [dual_node', dual_rotate_l, dual_rotate_r]
simp [dual_node', dual_rotate_l, dual_rotate_r]
cases delta_lt_false h_1 h_2
simp [dual_node', dual_rotate_l, dual_rotate_r]
simp [dual_node', dual_rotate_l, dual_rotate_r]
simp [dual_node', dual_rotate_l, dual_rotate_r]
intros
transitivity
apply M.dest_corec'
cases g x with a f
dsimp
congr
conv { to_rhs, rw [←split_drop_fun_last_fun f, append_fun_comp_split_fun] }
refl
intros
cases h₁ with _ _ _ _ _ _ hagree
cases h₀
apply hagree
intros
change ((mod m k) : ℕ) ≤ (m : ℕ) ∧ ((mod m k) : ℕ) ≤ (k : ℕ)
rw [mod_coe]
split_ifs
have hm : (m : ℕ) > 0 := m.pos
{ have hm : (m : ℕ) > 0 := m.pos, rw [← nat.mod_add_div (m : ℕ) (k : ℕ), h, zero_add] at hm ⊢, by_cases h' : ((m : ℕ) / (k : ℕ)) = 0, { rw [h', mul_zero] at hm, exact (lt_irrefl _ hm).elim}, { let h' := nat.mul_le_mul_left (k : ℕ) (nat.succ_le_of_lt (nat.pos_of_ne_zero h')), rw [mul_one] at h', exact ⟨h', le_refl (k : ℕ)⟩ } }
rw [← nat.mod_add_div (m : ℕ) (k : ℕ), h, zero_add] at hm ⊢
by_cases h' : ((m : ℕ) / (k : ℕ)) = 0
{ rw [h', mul_zero] at hm, exact (lt_irrefl _ hm).elim}
rw [h', mul_zero] at hm
exact (lt_irrefl _ hm).elim
let h' := nat.mul_le_mul_left (k : ℕ) (nat.succ_le_of_lt (nat.pos_of_ne_zero h'))
{ let h' := nat.mul_le_mul_left (k : ℕ) (nat.succ_le_of_lt (nat.pos_of_ne_zero h')), rw [mul_one] at h', exact ⟨h', le_refl (k : ℕ)⟩ }
rw [mul_one] at h'
exact ⟨h', le_refl (k : ℕ)⟩
exact ⟨nat.mod_le (m : ℕ) (k : ℕ), (nat.mod_lt (m : ℕ) k.pos).le⟩
{ exact ⟨nat.mod_le (m : ℕ) (k : ℕ), (nat.mod_lt (m : ℕ) k.pos).le⟩ }
intros
simp [coeff_zero_eq_eval_zero]
intros
convert (to_finsupp_iso R).symm.injective.comp (single_injective n)
ext
simp
intros
rw X_pow_eq_monomial
simp [monomial, monomial_fun, smul_to_finsupp]
intros
rw [coeff_mul, sum_eq_single (d,n), coeff_X_pow, if_pos rfl, mul_one]
rintros ⟨i,j⟩ h1 h2
{ rintros ⟨i,j⟩ h1 h2, rw [coeff_X_pow, if_neg, mul_zero], rintro rfl, apply h2, rw [nat.mem_antidiagonal, add_right_cancel_iff] at h1, subst h1 }
rw [coeff_X_pow, if_neg, mul_zero]
rintro rfl
apply h2
rw [nat.mem_antidiagonal, add_right_cancel_iff] at h1
subst h1
{ exact λ h1, (h1 (nat.mem_antidiagonal.2 rfl)).elim }
exact λ h1, (h1 (nat.mem_antidiagonal.2 rfl)).elim
intros
simp only [←C_eq_nat_cast, nat_degree_C]
intros
rw [leading_coeff_eq_zero, degree_eq_bot]
intros
split
intro H
{ intro H, rwa ← trailing_degree_eq_iff_nat_trailing_degree_eq, rintro rfl, rw trailing_degree_zero at H, exact option.no_confusion H }
rwa ← trailing_degree_eq_iff_nat_trailing_degree_eq
rintro rfl
rw trailing_degree_zero at H
exact option.no_confusion H
intro H
{ intro H, rwa trailing_degree_eq_iff_nat_trailing_degree_eq, rintro rfl, rw nat_trailing_degree_zero at H, rw H at hn, exact lt_irrefl _ hn }
rwa trailing_degree_eq_iff_nat_trailing_degree_eq
rintro rfl
rw nat_trailing_degree_zero at H
rw H at hn
exact lt_irrefl _ hn
intros
simp [bit0]
intros
rw [X_pow_eq_monomial, erase_lead_monomial]
intros
simp [polynomial.ext_iff, coeff_map]
intros
cases i; simp
cases i
simp
simp
intros
simp
intros
simp only [iterated_deriv_zero_right]
intros
split
intros q r h
{ intros q r h, rw [←sub_eq_zero, ←hp.mul_right_eq_zero_iff, mul_sub, h, sub_self] }
rw [←sub_eq_zero, ←hp.mul_right_eq_zero_iff, mul_sub, h, sub_self]
intros q r h
{ intros q r h, simp only at h, rw [←sub_eq_zero, ←hp.mul_left_eq_zero_iff, sub_mul, h, sub_self] }
simp only at h
rw [←sub_eq_zero, ←hp.mul_left_eq_zero_iff, sub_mul, h, sub_self]
intros
by_cases hf : f = 0
{ rw [hf, reverse_zero, nat_trailing_degree_zero] }
rw [hf, reverse_zero, nat_trailing_degree_zero]
rw ← nat.le_zero_iff
{ rw ← nat.le_zero_iff, apply nat_trailing_degree_le_of_ne_zero, rw [coeff_zero_reverse], exact mt leading_coeff_eq_zero.mp hf }
apply nat_trailing_degree_le_of_ne_zero
rw [coeff_zero_reverse]
exact mt leading_coeff_eq_zero.mp hf
intros
split
intros h α a a' f f' h' i
{ intros h α a a' f f' h' i, rw [← mvpfunctor.supp_eq,← mvpfunctor.supp_eq,← h,h',h] }
rw [← mvpfunctor.supp_eq,← mvpfunctor.supp_eq,← h,h',h]
rintros h α ⟨a,f⟩
{ rintros h α ⟨a,f⟩, ext, rwa [supp_eq_of_is_uniform,mvpfunctor.supp_eq], }
ext
rwa [supp_eq_of_is_uniform,mvpfunctor.supp_eq]
intros
ext x
apply fix.ind_rec
intros x hyp'
rw [hyp, ←hyp', fix.rec_eq]
intros
rw [← cast_zero, cast_lt]
intros
rw [lt_top_iff_ne_top, not_not]
rw [golden_ratio, golden_conj]
{rw [golden_ratio, golden_conj], ring}
ring
intros
rw [← mul_le_mul_left (pos_iff_ne_zero.2 h), mul_inv_cancel h, mul_comm]
intros
refine lt_of_le_of_lt _ (pi_gt_sqrt_two_add_series n)
rw [mul_comm]
refine (div_le_iff (pow_pos (by norm_num) _ : (0 : ℝ) < _)).mp (le_sqrt_of_sq_le _)
rwa [le_sub, show (0:ℝ) = (0:ℕ)/(1:ℕ), by rw [nat.cast_zero, zero_div]]
intros
rw [sqrt, ← nnreal.coe_mk x hx.le, nnreal.coe_le_coe, nnreal.le_sqrt_iff, real.le_to_nnreal_iff_coe_le', sq, nnreal.coe_mul]
{ rw [sqrt, ← nnreal.coe_mk x hx.le, nnreal.coe_le_coe, nnreal.le_sqrt_iff, real.le_to_nnreal_iff_coe_le', sq, nnreal.coe_mul], exact mul_pos hx hx }
exact mul_pos hx hx
intros
ext x y
{ ext x y, reflexivity }
reflexivity
intros
cases s with st
have : st n = none
from s_nth_eq_none
cases s' with st'
cases st'_nth_eq : st' n; simp only [zip_with, seq.nth, *]
cases st'_nth_eq : st' n
simp only [zip_with, seq.nth, *]
simp only [zip_with, seq.nth, *]
intros
rw [lift_rel_destruct_iff]; simp
rw [lift_rel_destruct_iff]
simp
intros
classical
ext x
by_cases h' : x ∈ t
have : x ≠ a
{ have : x ≠ a, { assume H, rw H at h', exact h h' }, simp [h, h', this] }
assume H
{ assume H, rw H at h', exact h h' }
rw H at h'
exact h h'
simp [h, h', this]
{ simp [h, h'] }
simp [h, h']
intros
ext
{ ext, simp }
simp
intros
rw [image_preimage_eq_inter_range, inter_eq_self_of_subset_left hs]
intros
rw [← preimage_comp, h.comp_eq_id, preimage_id]
intros
refine ⟨λ h x x' hx, _, injective.preimage_surjective⟩
cases h {x} with s hs
have := mem_singleton x
rwa [← hs, mem_preimage, hx, ← mem_preimage, hs, mem_singleton_iff, eq_comm] at this
intros
simp only [set.nonempty, mem_inter_eq, mem_singleton_iff, exists_eq_left]
intros
rw sUnion_eq_Union; haveI := finite.fintype h; apply finite_Union; simpa using H
rw sUnion_eq_Union; haveI := finite.fintype h; apply finite_Union
rw sUnion_eq_Union; haveI := finite.fintype h
rw sUnion_eq_Union
haveI := finite.fintype h
apply finite_Union
simpa using H
intros
simp [←finset.coe_inj]
intros
simp [piecewise]
intros
{ ext x, simp [Iio] }
ext x
simp [Iio]
intros
rw [diff_eq, compl_Ioi, Ici_inter_Iic]
intros
simp
intros
simp [add_comm]
intros
simp [sub_eq_neg_add]
intros
suffices : (λ x, x + b) '' ((λ x, a * x) '' Icc c d) = Icc (a * c + b) (a * d + b)
{ rwa set.image_image at this, }
rwa set.image_image at this
rw [image_mul_left_Icc' h, image_add_const_Icc]
intros
classical
intros p hp
rcases h_surj p with ⟨x, rfl⟩
refine ⟨x, _, rfl⟩
simp only [mem_Ioi]
by_contra h
exact has_lt.lt.false (lt_of_lt_of_le hp (h_mono (not_lt.mp h)))
intros
rw [← singleton_seq, ← singleton_seq, seq_seq, image_singleton]
intros
simp only [Inter_and, @Inter_comm _ ι]
intros
ext x
simp only [mem_Union, mem_image, mem_preimage]
split
{ rintro ⟨i, a, h, rfl⟩, exact h }
rintro ⟨i, a, h, rfl⟩
exact h
{ intro h, cases x with i a, exact ⟨i, a, h, rfl⟩ }
intro h
cases x with i a
exact ⟨i, a, h, rfl⟩
intros
rw ← update_inl_comp_inl
intros
simp [tprod.elim, hji]
intros
{ ext i : 2, induction i; simp [drop_fun,*]; refl }
ext i : 2
induction i
induction i; simp [drop_fun,*]; refl
induction i; simp [drop_fun,*]
simp [drop_fun,*]
refl
simp [drop_fun,*]
refl
intros
casesI n
{ exfalso, exact nat.not_lt_zero 0 (fact.out _) }
exfalso
exact nat.not_lt_zero 0 (fact.out _)
assume a b h
ext
exact h
intros
cases n
simp
{ simp }
split
simp only [val_min_abs_def_pos, int.coe_nat_succ]
{ simp only [val_min_abs_def_pos, int.coe_nat_succ], split_ifs with h h; assume h0, { apply val_injective, rwa [int.coe_nat_eq_zero] at h0, }, { apply absurd h0, rw sub_eq_zero, apply ne_of_lt, exact_mod_cast x.val_lt } }
split_ifs with h h; assume h0
split_ifs with h h
assume h0
{ apply val_injective, rwa [int.coe_nat_eq_zero] at h0, }
apply val_injective
rwa [int.coe_nat_eq_zero] at h0
assume h0
apply absurd h0
{ apply absurd h0, rw sub_eq_zero, apply ne_of_lt, exact_mod_cast x.val_lt }
rw sub_eq_zero
apply ne_of_lt
exact_mod_cast x.val_lt
{ rintro rfl, rw val_min_abs_zero }
rintro rfl
rw val_min_abs_zero
intros
simp only [add_comm _ (n:ℝ), f.commute_nat_add n]
intros
rw Union_subset_iff
{ rw Union_subset_iff, exact λ i, omega_limit_mono_right _ _ (subset_Union _ _)}
exact λ i, omega_limit_mono_right _ _ (subset_Union _ _)
intros
{ rw [finrank_adjoin_eq_one_iff], exact set.singleton_subset_iff }
rw [finrank_adjoin_eq_one_iff]
exact set.singleton_subset_iff
intros
use [1, (X ^ q - X - 1)]
rw [← char_p.cast_eq_zero_iff (polynomial K) p] at h
rw [derivative_sub, derivative_pow, derivative_X, h]
ring
intros
refine (ring_hom.injective_iff _).2 (λ x hx, _)
rw [ring_hom.comp_apply, ideal.quotient.eq_zero_iff_mem] at hx
refine classical.by_contradiction (λ hx0, absurd (I.eq_top_iff_one.2 _) hI)
have := I.mul_mem_left (mv_polynomial.C x⁻¹) hx
rwa [← mv_polynomial.C.map_mul, inv_mul_cancel hx0, mv_polynomial.C_1] at this
intros
rintro ⟨x, y, h⟩
simpa only [derivative_zero, mul_zero, add_zero, zero_ne_one] using h
intros
rcases hc with ⟨c, r, hcr⟩
exact ⟨c, r, λ p hp, hcr p (hs hp)⟩
intros
rw [pseudo_metric_space.dist_comm p2 _, dist_eq_norm_vsub V p1 _, dist_eq_norm_vsub V p1 _, dist_eq_norm_vsub V _ p2, ← vsub_add_vsub_cancel p1 (orthogonal_projection s p2) p2, norm_add_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero]
exact submodule.inner_right_of_mem_orthogonal (vsub_orthogonal_projection_mem_direction p2 hp1) (orthogonal_projection_vsub_mem_direction_orthogonal s p2)
intros
ext
{ ext, simp only [times_cont_mdiff_map.comp_apply, L_apply, mul_assoc] }
simp only [times_cont_mdiff_map.comp_apply, L_apply, mul_assoc]
intros
{ unfold_coes, simp only with mfld_simps }
unfold_coes
simp only with mfld_simps
intros
refine ⟨h.1.mono hst, _⟩
apply mono (λ y hy, _) h.2
simp only with mfld_simps at hy
simp only [hy, hst _] with mfld_simps
intros
rw [has_mfderiv_within_at, has_mfderiv_within_at, ext_chart_preimage_inter_eq, has_fderiv_within_at_inter', continuous_within_at_inter' h]
exact ext_chart_preimage_mem_nhds_within I x h
intros
apply has_mfderiv_within_at.mfderiv_within _ hxs
exact has_mfderiv_within_at.comp x hg.has_mfderiv_within_at hf.has_mfderiv_within_at h
intros
rw [times_cont_diff_groupoid, times_cont_diff_groupoid]
apply groupoid_of_pregroupoid_le
assume f s hfs
exact times_cont_diff_on.of_le hfs h
intros
have : times_cont_mdiff_on I.tangent I'.tangent 0 (tangent_map_within I I' f s) ((tangent_bundle.proj I M) ⁻¹' s) := hf.times_cont_mdiff_on_tangent_map_within hmn hs
exact this.continuous_on
intros
assume x
refine ⟨continuous_within_at_const, _⟩
simp only [times_cont_diff_within_at_prop, (∘)]
exact times_cont_diff_within_at_const
intros
simp [right_coset]
intros
ext
simp only [add_monoid_hom.coe_comp, finsupp.single_add_hom_apply, function.comp_app, one_smul, to_free_abelian_group, finsupp.lift_add_hom_apply_single]
intros
refine le_antisymm (λ g hg, equiv.perm.ext (λ q, quotient_group.induction_on q (λ g', (mul_action.quotient.smul_mk H g g').trans (quotient_group.eq.mpr _)))) (subgroup.normal_le_normal_core.mpr (λ g hg, _))
rw [mul_inv_rev, ←inv_inv g', inv_inv]
{ rw [mul_inv_rev, ←inv_inv g', inv_inv], exact H.normal_core.inv_mem hg g'⁻¹ }
exact H.normal_core.inv_mem hg g'⁻¹
rw [←H.inv_mem_iff, ←mul_one g⁻¹, ←quotient_group.eq, ←mul_one g]
{ rw [←H.inv_mem_iff, ←mul_one g⁻¹, ←quotient_group.eq, ←mul_one g], exact (mul_action.quotient.smul_mk H g 1).symm.trans (equiv.perm.ext_iff.mp hg (1 : G)) }
exact (mul_action.quotient.smul_mk H g 1).symm.trans (equiv.perm.ext_iff.mp hg (1 : G))
intros
rw [mul_comm, f.map_mul_right]
intros
induction s using quot.induction_on
simp only [form_perm_coe, mk_eq_coe]
simp only [length_subsingleton_iff, length_coe, mk_eq_coe] at h
cases s with hd tl
{ simp }
simp
simp only [length_eq_zero, add_le_iff_nonpos_left, list.length, nonpos_iff_eq_zero] at h
{ simp only [length_eq_zero, add_le_iff_nonpos_left, list.length, nonpos_iff_eq_zero] at h, simp [h] }
simp [h]
intros
have hx'' : x ∈ g.support
{ rwa [mem_support, ←hx, ←mem_support] }
rwa [mem_support, ←hx, ←mem_support]
have : f.support ⊆ g.support
intros y hy
{ intros y hy, obtain ⟨k, rfl⟩ := hf.exists_pow_eq (mem_support.mp hx') (mem_support.mp hy), rwa [pow_eq_on_of_mem_support h _ _ (mem_inter_of_mem hx' hx''), pow_apply_mem_support] }
obtain ⟨k, rfl⟩ := hf.exists_pow_eq (mem_support.mp hx') (mem_support.mp hy)
rwa [pow_eq_on_of_mem_support h _ _ (mem_inter_of_mem hx' hx''), pow_apply_mem_support]
rw (inter_eq_left_iff_subset _ _).mpr this at h
exact hf.support_congr hg this h
intros
obtain ⟨l, hl, rfl⟩ := s.exists_list_nodup_eq
rw cycle_factors_finset_eq_list_to_finset hl
simp only [noncomm_prod_to_finset, hl, exists_prop, list.mem_to_finset, and.congr_left_iff, and.congr_right_iff, list.map_id, ne.def]
intros
exact ⟨list.forall_of_pairwise disjoint.symmetric, hl.pairwise_of_forall_ne⟩
intros
refine fin.cases _ _ p
{ simp [equiv.perm.decompose_fin, equiv_functor.map] }
simp [equiv.perm.decompose_fin, equiv_functor.map]
intros i
{ intros i, by_cases h : i = e x, { simp [h, equiv.perm.decompose_fin, equiv_functor.map] }, { have h' : some (e x) ≠ some i := λ H, h (option.some_injective _ H).symm, have h'' : (e x).succ ≠ i.succ := λ H, h (fin.succ_injective _ H).symm, simp [h, h'', fin.succ_ne_zero, equiv.perm.decompose_fin, equiv_functor.map, swap_apply_of_ne_of_ne, swap_apply_of_ne_of_ne (option.some_ne_none (e x)) h'] } }
by_cases h : i = e x
{ simp [h, equiv.perm.decompose_fin, equiv_functor.map] }
simp [h, equiv.perm.decompose_fin, equiv_functor.map]
have h' : some (e x) ≠ some i := λ H, h (option.some_injective _ H).symm
{ have h' : some (e x) ≠ some i := λ H, h (option.some_injective _ H).symm, have h'' : (e x).succ ≠ i.succ := λ H, h (fin.succ_injective _ H).symm, simp [h, h'', fin.succ_ne_zero, equiv.perm.decompose_fin, equiv_functor.map, swap_apply_of_ne_of_ne, swap_apply_of_ne_of_ne (option.some_ne_none (e x)) h'] }
have h'' : (e x).succ ≠ i.succ := λ H, h (fin.succ_injective _ H).symm
simp [h, h'', fin.succ_ne_zero, equiv.perm.decompose_fin, equiv_functor.map, swap_apply_of_ne_of_ne, swap_apply_of_ne_of_ne (option.some_ne_none (e x)) h']
intros
induction xs with z xs IH generalizing x y
{ simp }
simp
{ simp [IH] }
simp [IH]
intros
intro x
simp only [perm.coe_mul, function.comp_app, ne.def, set.mem_union_eq, set.mem_set_of_eq]
by_cases hq : q x = x; simp [hq]
by_cases hq : q x = x
simp [hq]
simp [hq]
intros
refine ⟨λ h, _, λ h, h.symm ▸ disjoint_one_left 1⟩
ext x
cases h x with hx hx; simp [hx]
cases h x with hx hx
simp [hx]
simp [hx]
simp [hx]
simp [hx]
intros
ext
ext; simp
simp
intros
refine le_antisymm _ (sup_le (le_comap_map _ _) (ker_le_comap _ _))
intros x hx
simp only [exists_prop, mem_map, mem_comap] at hx
rcases hx with ⟨y, hy, hy'⟩
have : y⁻¹ * x ∈ f.ker
rw mem_ker
{ rw mem_ker, simp [hy'] }
simp [hy']
convert mul_mem _ (mem_sup_left hy) (mem_sup_right this)
simp
intros
intros s hs
rw [set_like.mem_coe, ←subgroup.inv_mem_iff]
exact subset_closure (mem_inv.mp hs)
intros
rw [div_eq_mul_inv]
exact mul_mem_center ha (inv_mem_center hb)
intros
ext
ext; simp
simp
intros
rw [← line_map_apply_one_sub, left_vsub_line_map]
intros
rw [lt_iff_le_not_le, not_le_iff_exists]
intros
rw [←set.image_univ, ←set.image_univ, ←finset.coe_univ] at h
exact finset.univ.centroid_eq_of_inj_on_of_image_eq k _ (λ _ _ _ _ he, affine_independent.injective s₁.independent he) (λ _ _ _ _ he, affine_independent.injective s₂.independent he) h
intros
rw [span_nat_eq_add_submonoid_closure, s.closure_eq]
intros
rw mem_span_insert
split
rintro ⟨a, z, hz, rfl⟩
{ rintro ⟨a, z, hz, rfl⟩, exact ⟨-a, by simp [hz, add_assoc]⟩ }
exact ⟨-a, by simp [hz, add_assoc]⟩
rintro ⟨a, h⟩
{ rintro ⟨a, h⟩, exact ⟨-a, _, h, by simp [add_comm, add_left_comm]⟩ }
exact ⟨-a, _, h, by simp [add_comm, add_left_comm]⟩
intros
refine le_antisymm _ (sup_le (le_comap_map _ _) (comap_mono bot_le))
rintro x ⟨y, hy, e⟩
exact mem_sup.2 ⟨y, hy, x - y, by simpa using sub_eq_zero.2 e.symm, by simp⟩
intros
ext m
have hg : N.subtype.comp (g^k) m = 0
rw [← commute_pow_left_of_commute h, hG, zero_comp, zero_apply]
{ rw [← commute_pow_left_of_commute h, hG, zero_comp, zero_apply], }
simp only [submodule.subtype_apply, comp_app, submodule.coe_eq_zero, coe_comp] at hg
rw [hg, linear_map.zero_apply]
intros
rw [coe_extend, subtype.range_coe_subtype, set_of_mem_eq]
intros
dunfold is_ortho
split
split; intro H
intro H
rw [smul_right, mul_eq_zero] at H
{ rw [smul_right, mul_eq_zero] at H, cases H, { trivial }, { exact H }}
cases H
{ trivial }
trivial
{ exact H }
exact H
intro H
{ rw [smul_right, H, mul_zero] }
rw [smul_right, H, mul_zero]
intros
{ rw [basis.det_apply, basis.to_matrix_map, basis.det_apply] }
rw [basis.det_apply, basis.to_matrix_map, basis.det_apply]
intros
apply le_trans
exact cardinal.lift_mk_le.mpr ⟨(equiv.of_injective _ hv.injective).to_embedding⟩
{ exact cardinal.lift_mk_le.mpr ⟨(equiv.of_injective _ hv.injective).to_embedding⟩, }
simp only [cardinal.lift_le]
{ simp only [cardinal.lift_le], apply le_trans, swap, exact cardinal.le_sup _ ⟨range v, hv.coe_range⟩, exact le_refl _, }
apply le_trans
swap
exact cardinal.le_sup _ ⟨range v, hv.coe_range⟩
exact le_refl _
intros
{ classical, exact (basis.of_vector_space K V).eval_ker }
classical
exact (basis.of_vector_space K V).eval_ker
intros
rintro rfl
exact h linear_map.ker_id
intros
rw [← submodule.dim_sup_add_dim_inf_eq, top_le_iff.1 h.2, le_bot_iff.1 h.1, finrank_bot, add_zero]
exact finrank_top
intros
{ contrapose h, simp [finrank_of_infinite_dimensional h] }
contrapose h
simp [finrank_of_infinite_dimensional h]
intros
convert finrank_eq_dim K (⊥ : submodule K V)
rw dim_bot
norm_cast
intros
let f : t.map (embedding.subtype s) → s := λ x, ⟨x.1, begin obtain ⟨x, h⟩ := x, rw [finset.mem_map] at h, obtain ⟨a, ha, rfl⟩ := h, simp only [subtype.coe_prop, embedding.coe_subtype], end⟩
convert linear_independent.comp li f _
rintros ⟨x, hx⟩ ⟨y, hy⟩
rw [finset.mem_map] at hx hy
obtain ⟨a, ha, rfl⟩ := hx
obtain ⟨b, hb, rfl⟩ := hy
simp only [imp_self, subtype.mk_eq_mk]
intros
let indep : set ι → Prop := λ I, linear_independent R (s ∘ coe : I → M)
let X := { I : set ι // indep I }
let r : X → X → Prop := λ I J, I.1 ⊆ J.1
have key : ∀ c : set X, zorn.chain r c → indep (⋃ (I : X) (H : I ∈ c), I)
intros c hc
{ intros c hc, dsimp [indep], rw [linear_independent_comp_subtype], intros f hsupport hsum, rcases eq_empty_or_nonempty c with rfl | ⟨a, hac⟩, { simpa using hsupport }, haveI : is_refl X r := ⟨λ _, set.subset.refl _⟩, obtain ⟨I, I_mem, hI⟩ : ∃ I ∈ c, (f.support : set ι) ⊆ I := finset.exists_mem_subset_of_subset_bUnion_of_directed_on hac hc.directed_on hsupport, exact linear_independent_comp_subtype.mp I.2 f hI hsum }
dsimp [indep]
rw [linear_independent_comp_subtype]
intros f hsupport hsum
rcases eq_empty_or_nonempty c with rfl | ⟨a, hac⟩
{ simpa using hsupport }
simpa using hsupport
haveI : is_refl X r := ⟨λ _, set.subset.refl _⟩
obtain ⟨I, I_mem, hI⟩ : ∃ I ∈ c, (f.support : set ι) ⊆ I := finset.exists_mem_subset_of_subset_bUnion_of_directed_on hac hc.directed_on hsupport
exact linear_independent_comp_subtype.mp I.2 f hI hsum
have trans : transitive r := λ I J K, set.subset.trans
obtain ⟨⟨I, hli : indep I⟩, hmax : ∀ a, r ⟨I, hli⟩ a → r a ⟨I, hli⟩⟩ := @zorn.exists_maximal_of_chains_bounded _ r (λ c hc, ⟨⟨⋃ I ∈ c, (I : set ι), key c hc⟩, λ I, set.subset_bUnion_of_mem⟩) trans
exact ⟨I, hli, λ J hsub hli, set.subset.antisymm hsub (hmax ⟨J, hli⟩ hsub)⟩
intros
ext
{ ext, simp only [basis.to_matrix_apply, basis.map, linear_equiv.trans_apply] }
simp only [basis.to_matrix_apply, basis.map, linear_equiv.trans_apply]
intros
{ have h := finite_field.trace_pow_card M, rwa zmod.card at h, }
have h := finite_field.trace_pow_card M
rwa zmod.card at h
intros
rw [dot_product, finset.sum_eq_single i, linear_map.std_basis_same]
exact λ _ _ hb, by rw [linear_map.std_basis_ne _ _ _ _ hb, mul_zero]
exact λ hi, false.elim (hi $ finset.mem_univ _)
intros
rw [← matrix.to_lin_symm, linear_equiv.symm_apply_apply]
intros
refine pi_tensor_product.induction_on' x _ _
intros z f
{ intros z f, rw [smul_tprod_coeff' r z f, lift_aux_tprod_coeff, lift_aux_tprod_coeff, smul_assoc] }
rw [smul_tprod_coeff' r z f, lift_aux_tprod_coeff, lift_aux_tprod_coeff, smul_assoc]
intros z y ihz ihy
{ intros z y ihz ihy, rw [smul_add, (lift_aux φ).map_add, ihz, ihy, (lift_aux φ).map_add, smul_add] }
rw [smul_add, (lift_aux φ).map_add, ihz, ihy, (lift_aux φ).map_add, smul_add]
intros
{ rintros ⟨y, z⟩, simp {contextual := tt} }
rintros ⟨y, z⟩
simp {contextual := tt}
intros
ext
ext; refl
refl
refl
intros
rw [←is_scalar_tower.algebra_map_smul R a x, polar_smul_left, algebra.smul_def]
intros
simp [or_comm, decidable.forall_or_distrib_left]
intros
simp only [and.comm, ← and.congr_right_iff]
intros
{ rw forall_swap, simp }
rw forall_swap
simp
intros
{ rw [nontrivial_iff, subsingleton_iff], push_neg, refl }
rw [nontrivial_iff, subsingleton_iff]
push_neg
refl
intros
rw small_congr (equiv.of_injective f hf)
apply_instance
intros
apply measurable_of_is_open
intros s hs
rw [← measurable_set.compl_iff, ← preimage_compl]
apply hf
rw [is_closed_compl_iff]
exact hs
intros
cases eq_empty_or_nonempty s with h2s h2s
{ simp [h2s, measurable_const] }
simp [h2s, measurable_const]
apply measurable_of_Iic
{ apply measurable_of_Iic, intro y, simp_rw [preimage, mem_Iic, cSup_le_iff (bdd _) (h2s.image _), ball_image_iff, set_of_forall], exact measurable_set.bInter hs (λ i hi, measurable_set_le (hf i) measurable_const) }
intro y
simp_rw [preimage, mem_Iic, cSup_le_iff (bdd _) (h2s.image _), ball_image_iff, set_of_forall]
exact measurable_set.bInter hs (λ i hi, measurable_set_le (hf i) measurable_const)
intros
choose s h1s h2s using hC
haveI := fintype.encodable ι
let e : ℕ → (ι → ℕ) := λ n, (decode (ι → ℕ) n).iget
refine ⟨λ n, pi univ (λ i, s i (e n i)), λ n, mem_image_of_mem _ (λ i _, h1s i _), _⟩
simp_rw [(surjective_decode_iget (ι → ℕ)).Union_comp (λ x, pi univ (λ i, s i (x i))), Union_univ_pi s, h2s, pi_univ]
intros
{ rw measure.prod, exact bind_zero_left _ }
rw measure.prod
exact bind_zero_left _
intros
refine (eq_singular_part _ (s.rn_deriv μ + t.rn_deriv μ) ((mutually_singular_singular_part s μ).add_left (mutually_singular_singular_part t μ)) _).symm
erw [with_densityᵥ_add (integrable_rn_deriv s μ) (integrable_rn_deriv t μ)]
rw [add_assoc, add_comm (t.singular_part μ), add_assoc, add_comm _ (t.singular_part μ), singular_part_add_with_density_rn_deriv_eq, ← add_assoc, singular_part_add_with_density_rn_deriv_eq]
intros
{ rw comp₂_eq_mk, apply coe_fn_mk }
rw comp₂_eq_mk
apply coe_fn_mk
intros
simp only [ae_seq_eq_mk_of_mem_ae_seq_set hf hx i, mk_eq_fun_of_mem_ae_seq_set hf hx i]
intros
refine le_antisymm _ (Limsup_le_Limsup_of_le (map_restrict_ae_le_map_indicator_ae hs) (by is_bounded_default) (by is_bounded_default))
refine Limsup_le_Limsup (by is_bounded_default) (by is_bounded_default) (λ c h_restrict_le, _)
rw eventually_map at h_restrict_le ⊢
rw ae_restrict_iff' hs at h_restrict_le
have hc : 0 ≤ c
suffices : ∃ x, 0 ≤ f x ∧ f x ≤ c
{ suffices : ∃ x, 0 ≤ f x ∧ f x ≤ c, by { obtain ⟨x, hx⟩ := this, exact hx.1.trans hx.2, }, refine frequently.exists _, { exact μ.ae, }, rw [eventually_le, ae_restrict_iff' hs] at hf, have hs' : ∃ᵐ x ∂μ, x ∈ s, { contrapose! hs_not_null, rw [not_frequently, ae_iff] at hs_not_null, suffices : {a : α | ¬a ∉ s} = s, by rwa ← this, simp, }, refine hs'.mp (hf.mp (h_restrict_le.mono (λ x hxs_imp_c hxf_nonneg hxs, _))), rw pi.zero_apply at hxf_nonneg, exact ⟨hxf_nonneg hxs, hxs_imp_c hxs⟩, }
obtain ⟨x, hx⟩ := this
obtain ⟨x, hx⟩ := this
{ obtain ⟨x, hx⟩ := this, exact hx.1.trans hx.2, }
{ obtain ⟨x, hx⟩ := this, exact hx.1.trans hx.2, }
exact hx.1.trans hx.2
exact hx.1.trans hx.2
refine frequently.exists _
{ exact μ.ae, }
exact μ.ae
rw [eventually_le, ae_restrict_iff' hs] at hf
have hs' : ∃ᵐ x ∂μ, x ∈ s
contrapose! hs_not_null
{ contrapose! hs_not_null, rw [not_frequently, ae_iff] at hs_not_null, suffices : {a : α | ¬a ∉ s} = s, by rwa ← this, simp, }
rw [not_frequently, ae_iff] at hs_not_null
suffices : {a : α | ¬a ∉ s} = s
rwa ← this
rwa ← this
simp
refine hs'.mp (hf.mp (h_restrict_le.mono (λ x hxs_imp_c hxf_nonneg hxs, _)))
rw pi.zero_apply at hxf_nonneg
exact ⟨hxf_nonneg hxs, hxs_imp_c hxs⟩
refine h_restrict_le.mono (λ x hxc, _)
by_cases hxs : x ∈ s
{ simpa [hxs] using hxc hxs, }
simpa [hxs] using hxc hxs
{ simpa [hxs] using hc, }
simpa [hxs] using hc
intros
simp only [pi.neg_apply, nnnorm_neg]
intros
cases f
cases g
simp only [subtype.mk_eq_mk]
exact ae_eq_fun.ext h
intros
simp_rw [snorm_ess_sup, nnnorm_indicator_eq_indicator_nnnorm, ennreal.coe_indicator]
by_cases hs_null : μ s = 0
rw measure.restrict_zero_set hs_null
{ rw measure.restrict_zero_set hs_null, simp only [ess_sup_measure_zero, ennreal.ess_sup_eq_zero_iff, ennreal.bot_eq_zero], have hs_empty : s =ᵐ[μ] (∅ : set α), by { rw ae_eq_set, simpa using hs_null, }, refine (indicator_ae_eq_of_ae_eq_set hs_empty).trans _, rw set.indicator_empty, refl, }
simp only [ess_sup_measure_zero, ennreal.ess_sup_eq_zero_iff, ennreal.bot_eq_zero]
have hs_empty : s =ᵐ[μ] (∅ : set α)
rw ae_eq_set
rw ae_eq_set
{ rw ae_eq_set, simpa using hs_null, }
{ rw ae_eq_set, simpa using hs_null, }
simpa using hs_null
simpa using hs_null
refine (indicator_ae_eq_of_ae_eq_set hs_empty).trans _
rw set.indicator_empty
refl
rw ess_sup_indicator_eq_ess_sup_restrict (eventually_of_forall (λ x, _)) hs hs_null
rw pi.zero_apply
exact zero_le _
intros
rw [snorm_ess_sup, ess_sup_const _ hμ]
intros
simp_rw [ae_fin_strongly_measurable, ae_measurable, fin_strongly_measurable_iff_measurable]
intros
ext
{ ext, rw [map_apply, real.norm_eq_abs, abs_of_nonneg], exact le_max_right _ _ }
rw [map_apply, real.norm_eq_abs, abs_of_nonneg]
exact le_max_right _ _
intros
rw integral_eq_lintegral_of_nonneg_ae _ hf.1.norm
simp_rw [of_real_norm_eq_coe_nnnorm, ennreal.of_real_to_real (lt_top_iff_ne_top.mp hf.2)]
{ simp_rw [of_real_norm_eq_coe_nnnorm, ennreal.of_real_to_real (lt_top_iff_ne_top.mp hf.2)], }
{ refine ae_of_all _ _, simp, }
refine ae_of_all _ _
simp
intros
simp only [interval_integral, integral_smul, smul_sub]
intros
refine measure.ext (λ s hs, _)
rw [with_density_apply _ hs, measure.coe_smul, pi.smul_apply, with_density_apply _ hs, smul_eq_mul, ← lintegral_const_mul r hf]
refl
intros
refine fin_meas_supp_iff.2 (λ b hb, _)
rw [f.lintegral_eq_of_subset' (finset.subset_insert b _)] at h
refine ennreal.lt_top_of_mul_ne_top_right _ hb
exact (lt_top_of_sum_ne_top h (finset.mem_insert_self _ _)).ne
intros
by_cases hf : integrable f μ
rw [set_to_fun_eq hT hf, set_to_fun_eq hT, integrable.to_L1_smul', L1.set_to_L1_smul hT h_smul c _]
{ rw [set_to_fun_eq hT hf, set_to_fun_eq hT, integrable.to_L1_smul', L1.set_to_L1_smul hT h_smul c _], }
by_cases hr : c = 0
{ by_cases hr : c = 0, { rw hr, simp, }, { have hf' : ¬ integrable (c • f) μ, by rwa [integrable_smul_iff hr f], rw [set_to_fun_undef hT hf, set_to_fun_undef hT hf', smul_zero], }, }
{ rw hr, simp, }
rw hr
simp
have hf' : ¬ integrable (c • f) μ
{ have hf' : ¬ integrable (c • f) μ, by rwa [integrable_smul_iff hr f], rw [set_to_fun_undef hT hf, set_to_fun_undef hT hf', smul_zero], }
rwa [integrable_smul_iff hr f]
rwa [integrable_smul_iff hr f]
rw [set_to_fun_undef hT hf, set_to_fun_undef hT hf', smul_zero]
intros
dsimp [opens]
rw subtype.forall
apply induced_outer_measure_caratheodory
apply inner_content_Union_nat
apply inner_content_mono'
intros
have := nat.Inf_mem (index_defined hK hV)
{ have := nat.Inf_mem (index_defined hK hV), rwa [mem_image] at this }
rwa [mem_image] at this
intros
refine (tendsto_pre m s).comp (tendsto_inf.2 ⟨ennreal.tendsto_inv_nat_nhds_zero, _⟩)
refine tendsto_principal.2 (eventually_of_forall $ λ n, _)
simp
intros
simp [volume_val]
intros
simp [measure.trim, outer_measure.to_measure_zero]
intros
rw [map_top, hf.range_eq, restrict_univ]
intros
simp only [bind_on_support_apply, tsum_eq_zero_iff (bind_on_support.summable p f b), mul_eq_zero, or_iff_not_imp_left]
exact ⟨λ h a ha, trans (dif_neg ha).symm (h a ha), λ h a ha, trans (dif_neg ha) (h a ha)⟩
intros
obtain ⟨_, ⟨b, b_mem, b_ne_zero, rfl⟩, min⟩ := @int.exists_least_of_bdd (λ a, ∃ b ∈ (I : ideal S), b ≠ (0 : S) ∧ abv (algebra.norm R b) = a) _ _
refine ⟨b, b_mem, b_ne_zero, _⟩
{ refine ⟨b, b_mem, b_ne_zero, _⟩, intros c hc lt, contrapose! lt with c_ne_zero, exact min _ ⟨c, hc, c_ne_zero, rfl⟩ }
intros c hc lt
contrapose! lt with c_ne_zero
exact min _ ⟨c, hc, c_ne_zero, rfl⟩
use 0
{ use 0, rintros _ ⟨b, b_mem, b_ne_zero, rfl⟩, apply abv.nonneg }
rintros _ ⟨b, b_mem, b_ne_zero, rfl⟩
apply abv.nonneg
obtain ⟨b, b_mem, b_ne_zero⟩ := (I : ideal S).ne_bot_iff.mp (non_zero_divisors.coe_ne_zero I)
{ obtain ⟨b, b_mem, b_ne_zero⟩ := (I : ideal S).ne_bot_iff.mp (non_zero_divisors.coe_ne_zero I), exact ⟨_, ⟨b, b_mem, b_ne_zero, rfl⟩⟩ }
exact ⟨_, ⟨b, b_mem, b_ne_zero, rfl⟩⟩
intros
dsimp [lucas_lehmer_residue] at h
rw s_zmod_eq_s p' at h
simp [zmod.int_coe_zmod_eq_zero_iff_dvd] at h
cases h with k h
use k
replace h := congr_arg (λ (n : ℤ), (n : X (q (p'+2)))) h
dsimp at h
rw closed_form at h
replace h := congr_arg (λ x, ω^2^p' * x) h
dsimp at h
have t : 2^p' + 2^p' = 2^(p'+1) := by ring_exp
rw [mul_add, ←pow_add ω, t, ←mul_pow ω ωb (2^p'), ω_mul_ωb, one_pow] at h
rw [mul_comm, coe_mul] at h
rw [mul_comm _ (k : X (q (p'+2)))] at h
replace h := eq_sub_of_add_eq h
exact_mod_cast h
intros
unfold padic_val_rat
split_ifs
{ simp, }
simp
intros
ext x
rw ring_hom.mem_ker
split
intro h
{ intro h, simpa only [h, zmod.cast_zero, sub_zero] using to_zmod_spec x, }
simpa only [h, zmod.cast_zero, sub_zero] using to_zmod_spec x
intro h
{ intro h, rw ← sub_zero x at h, dsimp [to_zmod, to_zmod_hom], convert zmod_congr_of_sub_mem_max_ideal x _ 0 _ h, apply sub_zmod_repr_mem, }
rw ← sub_zero x at h
dsimp [to_zmod, to_zmod_hom]
convert zmod_congr_of_sub_mem_max_ideal x _ 0 _ h
apply sub_zmod_repr_mem
intros
have hz : z ≠ 0
apply ne_of_gt hzpos
have h2 : y = m ^ 2 - n ^ 2 ∧ z = m ^ 2 + n ^ 2
apply rat.div_int_inj hzpos hm2n2 (h.coprime_of_coprime hc) H
{ apply rat.div_int_inj hzpos hm2n2 (h.coprime_of_coprime hc) H, rw [hw2], norm_cast }
rw [hw2]
norm_cast
use [m, n]
apply and.intro _ (and.intro co pp)
right
refine ⟨_, h2.left⟩
rw [← rat.coe_int_inj _ _, ← div_left_inj' ((mt (rat.coe_int_inj z 0).mp) hz), hv2, h2.right]
norm_cast
intros
cases nat.prime.eq_two_or_odd (fact.out p.prime) with hp2 hp_odd
{ substI p, exact dec_trivial }
substI p
exact dec_trivial
haveI := fact.mk hp_odd
have neg_one_ne_zero : (-1 : zmod p) ≠ 0
from mt neg_eq_zero.1 one_ne_zero
rw [euler_criterion p neg_one_ne_zero, neg_one_pow_eq_pow_mod_two]
cases mod_two_eq_zero_or_one (p / 2) with p_half_even p_half_odd
rw [p_half_even, pow_zero, eq_self_iff_true, true_iff]
{ rw [p_half_even, pow_zero, eq_self_iff_true, true_iff], contrapose! p_half_even with hp, rw [← nat.mod_mul_right_div_self, show 2 * 2 = 4, from rfl, hp], exact dec_trivial }
contrapose! p_half_even with hp
rw [← nat.mod_mul_right_div_self, show 2 * 2 = 4, from rfl, hp]
exact dec_trivial
rw [p_half_odd, pow_one, iff_false_intro (ne_neg_self p one_ne_zero).symm, false_iff, not_not]
{ rw [p_half_odd, pow_one, iff_false_intro (ne_neg_self p one_ne_zero).symm, false_iff, not_not], rw [← nat.mod_mul_right_div_self, show 2 * 2 = 4, from rfl] at p_half_odd, rw [← nat.mod_mul_left_mod _ 2, show 2 * 2 = 4, from rfl] at hp_odd, have hp : p % 4 < 4, from nat.mod_lt _ dec_trivial, revert hp hp_odd p_half_odd, generalize : p % 4 = k, dec_trivial! }
rw [← nat.mod_mul_right_div_self, show 2 * 2 = 4, from rfl] at p_half_odd
rw [← nat.mod_mul_left_mod _ 2, show 2 * 2 = 4, from rfl] at hp_odd
have hp : p % 4 < 4
from nat.mod_lt _ dec_trivial
revert hp hp_odd p_half_odd
generalize : p % 4 = k
dec_trivial!
intros
{ simp [ext], ring }
simp [ext]
ring
intros
rw [inf_of_le_right (@sdiff_le _ x y _)]
intros
rw [inf_sup_left, inf_sdiff_left, sup_inf_self]
intros
{ intro h, rw [←h, disjoint_self] at hab, exact ha hab }
intro h
rw [←h, disjoint_self] at hab
exact ha hab
intros
simp only [bdd_below, lower_bounds_empty, univ_nonempty]
intros
classical
rw is_compact_element_iff_le_of_directed_Sup_le
intros d hemp hdir hsup
change f with id ∘ f
rw ←finset.sup_finset_image
apply finset.sup_le_of_le_directed d hemp hdir
rintros x hx
obtain ⟨p, ⟨hps, rfl⟩⟩ := finset.mem_image.mp hx
specialize h p hps
rw is_compact_element_iff_le_of_directed_Sup_le at h
specialize h d hemp hdir (le_trans (finset.le_sup hps) hsup)
simpa only [exists_prop]
intros
rw [infi_inf_eq, infi_const]
intros
rw [← tendsto_map'_iff, map_add_at_top_eq_nat]
intros
simpa only [mul_comm] using hf.neg_const_mul_at_top hr
intros
ext t
rw [hl.mem_iff, hl'.mem_iff]
intros
simp [imp_iff_not_or, not_eventually, frequently_or_distrib]
intros
ext W
suffices : (∃ (t : set α), t ∈ f ∧ (λ (y : α), x) ⁻¹' t ⊆ W) ↔ W = univ
simpa
simpa
split
rintro ⟨V, V_in, hW⟩
{ rintro ⟨V, V_in, hW⟩, simpa [preimage_const_of_mem (h V V_in), univ_subset_iff] using hW }
simpa [preimage_const_of_mem (h V V_in), univ_subset_iff] using hW
rintro rfl
{ rintro rfl, use univ, simp [univ_mem] }
use univ
simp [univ_mem]
intros
haveI := nonempty_subtype.2 ne
simp only [infi_subtype']
exact map_infi_eq h.directed_coe
intros
simp only [tendsto, le_principal_iff, mem_map', filter.eventually]
intros
rw [principal_coprod_principal, map_principal]
congr
ext ⟨b', i'⟩
split
rintro ⟨⟨a'', i''⟩, h₁, h₂, h₃⟩
{ rintro ⟨⟨a'', i''⟩, h₁, h₂, h₃⟩, simp }
simp
rintro ⟨h₁, h₂⟩
{ rintro ⟨h₁, h₂⟩, use (a, i'), simpa using h₁.symm }
use (a, i')
simpa using h₁.symm
intros
rw [infi_subtype', infi_sup_right, infi_subtype']
intros
ext S
simp only [mem_coprod_iff, exists_prop, mem_comap, mem_cofinite]
split
rintro ⟨⟨A, hAf, hAS⟩, B, hBf, hBS⟩
{ rintro ⟨⟨A, hAf, hAS⟩, B, hBf, hBS⟩, rw [← compl_subset_compl, ← preimage_compl] at hAS hBS, exact (hAf.prod hBf).subset (subset_inter hAS hBS) }
rw [← compl_subset_compl, ← preimage_compl] at hAS hBS
exact (hAf.prod hBf).subset (subset_inter hAS hBS)
intro hS
{ intro hS, refine ⟨⟨(prod.fst '' Sᶜ)ᶜ, _, _⟩, ⟨(prod.snd '' Sᶜ)ᶜ, _, _⟩⟩, { simpa using hS.image prod.fst }, { simpa [compl_subset_comm] using subset_preimage_image prod.fst Sᶜ }, { simpa using hS.image prod.snd }, { simpa [compl_subset_comm] using subset_preimage_image prod.snd Sᶜ } }
refine ⟨⟨(prod.fst '' Sᶜ)ᶜ, _, _⟩, ⟨(prod.snd '' Sᶜ)ᶜ, _, _⟩⟩
{ simpa using hS.image prod.fst }
simpa using hS.image prod.fst
{ simpa [compl_subset_comm] using subset_preimage_image prod.fst Sᶜ }
simpa [compl_subset_comm] using subset_preimage_image prod.fst Sᶜ
{ simpa using hS.image prod.snd }
simpa using hS.image prod.snd
{ simpa [compl_subset_comm] using subset_preimage_image prod.snd Sᶜ }
simpa [compl_subset_comm] using subset_preimage_image prod.snd Sᶜ
intros
rw [← principal_empty, lift'_principal hh]
intros
{ rw ← h, simp }
rw ← h
simp
intros
simp [Limsup]; exact cInf_upper_bounds_eq_cSup h hs
simp [Limsup]
exact cInf_upper_bounds_eq_cSup h hs
intros
rw [symm_diff_comm, compl_symm_diff_self]
intros
classical
revert hf
apply f.induction_on
intro h
{ intro h, simp [set.is_pwo_empty.is_wf], }
simp [set.is_pwo_empty.is_wf]
intros s f sf hf hsf
{ intros s f sf hf hsf, rw finset.sup_insert, exact (hsf s (finset.mem_insert_self _ _)).union (hf (λ s' s'f, hsf _ (finset.mem_insert_of_mem s'f))) }
rw finset.sup_insert
exact (hsf s (finset.mem_insert_self _ _)).union (hf (λ s' s'f, hsf _ (finset.mem_insert_of_mem s'f)))
intros
rw [inv_eq_iff, inv_div, div_eq_iff, sub_eq_iff_eq_add, mul_comm]
conv_lhs { rw ← div_X_mul_X_add p }
rw [alg_hom.map_add, alg_hom.map_mul, aeval_X, aeval_C]
exact aeval_ne
intros
simpa [group.fg_iff_monoid.fg] using finite_type_iff_fg
intros
rcases I with ⟨I, aI, haI, hI⟩
rcases J with ⟨J, aJ, haJ, hJ⟩
use aI * aJ
use S.mul_mem haI haJ
intros b hb
apply submodule.mul_induction_on hb
intros m hm n hn
{ intros m hm n hn, obtain ⟨n', hn'⟩ := hJ n hn, rw [mul_smul, mul_comm m, ← smul_mul_assoc, ← hn', ← algebra.smul_def], apply hI, exact submodule.smul_mem _ _ hm }
obtain ⟨n', hn'⟩ := hJ n hn
rw [mul_smul, mul_comm m, ← smul_mul_assoc, ← hn', ← algebra.smul_def]
apply hI
exact submodule.smul_mem _ _ hm
intros x y hx hy
{ intros x y hx hy, rw smul_add, apply is_integer_add hx hy }
rw smul_add
apply is_integer_add hx hy
intros
rw [←set.singleton_one, span_singleton_one]
intros
{ ext x, rw [ring_hom.comp_apply, factor_mk] }
ext x
rw [ring_hom.comp_apply, factor_mk]
intros
{ rw [← f.injective_iff, injective_iff_ker_eq_bot] }
rw [← f.injective_iff, injective_iff_ker_eq_bot]
intros
simp only [mk_ker, sup_idem, sup_comm, quot_left_to_quot_sup, quotient.factor, ker_quotient_lift, map_eq_iff_sup_ker_eq_of_surjective I^.quotient.mk quotient.mk_surjective, ← sup_assoc]
intros
split
split; intro hr
intro hr
rcases hr with ⟨p, hmp, hpr⟩
{ rcases hr with ⟨p, hmp, hpr⟩, refine ⟨_, set.finite_mem_finset _, p.restriction, monic_restriction.2 hmp, _⟩, erw [← aeval_def, is_scalar_tower.aeval_apply _ R, map_restriction, aeval_def, hpr] }
refine ⟨_, set.finite_mem_finset _, p.restriction, monic_restriction.2 hmp, _⟩
erw [← aeval_def, is_scalar_tower.aeval_apply _ R, map_restriction, aeval_def, hpr]
intro hr
rcases hr with ⟨s, hs, hsr⟩
exact is_integral_of_subring _ hsr
intros
refine eq_bot_iff.trans _
split
rw is_integrally_closed_iff K
{ rw is_integrally_closed_iff K, intros h x hx, exact set.mem_range.mp (algebra.mem_bot.mp (h hx)), assumption }
intros h x hx
exact set.mem_range.mp (algebra.mem_bot.mp (h hx))
assumption
{ intros h x hx, rw [algebra.mem_bot, set.mem_range], exactI is_integral_iff.mp hx }
intros h x hx
rw [algebra.mem_bot, set.mem_range]
exactI is_integral_iff.mp hx
intros
rintros x y hxy
obtain ⟨a, b, rfl⟩ := mk'_surjective M x
obtain ⟨c, d, rfl⟩ := mk'_surjective M y
rw [map_mk' _ a b, map_mk' _ c d, mk'_eq_iff_eq] at hxy
refine mk'_eq_iff_eq.2 (congr_arg (algebra_map _ _) (hg _))
convert is_localization.injective _ hM hxy
convert is_localization.injective _ hM hxy; simp
simp
simp
intros
split
split; intro h
intro h
rw [← mk'_spec S x y, mul_comm]
{ rw [← mk'_spec S x y, mul_comm], exact I.mul_mem_left ((algebra_map R S) y) h }
exact I.mul_mem_left ((algebra_map R S) y) h
intro h
rw ← mk'_spec S x y at h
{ rw ← mk'_spec S x y at h, obtain ⟨b, hb⟩ := is_unit_iff_exists_inv.1 (map_units S y), have := I.mul_mem_left b h, rwa [mul_comm, mul_assoc, hb, mul_one] at this }
obtain ⟨b, hb⟩ := is_unit_iff_exists_inv.1 (map_units S y)
have := I.mul_mem_left b h
rwa [mul_comm, mul_assoc, hb, mul_one] at this
intros
classical
let sp : M → submodule R M := λ a, span R {a}
have supr_rw : ∀ t : finset M, (⨆ x ∈ t, sp x) = (⨆ x ∈ (↑t : set M), sp x)
from λ t, by refl
split
rintro ⟨t, rfl⟩
{ rintro ⟨t, rfl⟩, rw [span_eq_supr_of_singleton_spans, ←supr_rw, ←(finset.sup_eq_supr t sp)], apply complete_lattice.finset_sup_compact_of_compact, exact λ n _, singleton_span_is_compact_element n, }
rw [span_eq_supr_of_singleton_spans, ←supr_rw, ←(finset.sup_eq_supr t sp)]
apply complete_lattice.finset_sup_compact_of_compact
exact λ n _, singleton_span_is_compact_element n
intro h
{ intro h, have sSup : s = Sup (sp '' ↑s), by rw [Sup_eq_supr, supr_image, ←span_eq_supr_of_singleton_spans, eq_comm, span_eq], obtain ⟨u, ⟨huspan, husup⟩⟩ := h (sp '' ↑s) (le_of_eq sSup), have ssup : s = u.sup id, { suffices : u.sup id ≤ s, from le_antisymm husup this, rw [sSup, finset.sup_id_eq_Sup], exact Sup_le_Sup huspan, }, obtain ⟨t, ⟨hts, rfl⟩⟩ := finset.subset_image_iff.mp huspan, rw [finset.sup_finset_image, function.comp.left_id, finset.sup_eq_supr, supr_rw, ←span_eq_supr_of_singleton_spans, eq_comm] at ssup, exact ⟨t, ssup⟩, }
have sSup : s = Sup (sp '' ↑s)
rw [Sup_eq_supr, supr_image, ←span_eq_supr_of_singleton_spans, eq_comm, span_eq]
rw [Sup_eq_supr, supr_image, ←span_eq_supr_of_singleton_spans, eq_comm, span_eq]
obtain ⟨u, ⟨huspan, husup⟩⟩ := h (sp '' ↑s) (le_of_eq sSup)
have ssup : s = u.sup id
suffices : u.sup id ≤ s
{ suffices : u.sup id ≤ s, from le_antisymm husup this, rw [sSup, finset.sup_id_eq_Sup], exact Sup_le_Sup huspan, }
from le_antisymm husup this
rw [sSup, finset.sup_id_eq_Sup]
exact Sup_le_Sup huspan
obtain ⟨t, ⟨hts, rfl⟩⟩ := finset.subset_image_iff.mp huspan
rw [finset.sup_finset_image, function.comp.left_id, finset.sup_eq_supr, supr_rw, ←span_eq_supr_of_singleton_spans, eq_comm] at ssup
exact ⟨t, ssup⟩
intros
{ rw [norm_apply, linear_map.det], split_ifs with h, refl }
rw [norm_apply, linear_map.det]
split_ifs with h
refl
intros
by_cases hf0 : f = 0
rw hf0
{ rw hf0, exact iff_of_true (valuation.map_zero _) rfl }
exact iff_of_true (valuation.map_zero _) rfl
obtain ⟨n, hn⟩ : ∃ n, coeff _ _ n f ≠ 0 := not_forall.1 (λ h, hf0 $ perfection.ext h)
show val_aux K v O hv p f = 0 ↔ f = 0
refine iff_of_false (λ hvf, hn _) hf0
rw val_aux_eq hn at hvf
replace hvf := pow_eq_zero hvf
rwa mod_p.pre_val_eq_zero at hvf
intros
dsimp [bernstein_polynomial]
split_ifs
{ subst h, simp, }
subst h
simp
{ simp [zero_pow (nat.pos_of_ne_zero h)], }
simp [zero_pow (nat.pos_of_ne_zero h)]
intros
rw pochhammer
intros
by_cases hq : q = 0
rw [hq, degree_zero] at hpq
{ rw [hq, degree_zero] at hpq, have := not_lt_bot hpq, contradiction }
have := not_lt_bot hpq
contradiction
rwa [degree_eq_nat_degree hp, degree_eq_nat_degree hq, with_bot.coe_lt_coe] at hpq
intros
have := coe_monomial 0 a
rwa power_series.monomial_zero_eq_C_apply at this
intros
rw [← range_eq_top, ← range_eq_bot, or_comm]
apply eq_bot_or_eq_top
intros
have hx' : _root_.is_integral L x := is_integral_of_is_scalar_tower _ hx
rw [← is_integral_algebra_map_iff (algebra_map L (algebraic_closure F)).injective, trace_eq_sum_roots]
refine (is_integral.multiset_sum _).nsmul _
{ refine (is_integral.multiset_sum _).nsmul _, intros y hy, rw mem_roots_map (minpoly.ne_zero hx') at hy, use [minpoly R x, minpoly.monic hx], rw ← aeval_def at ⊢ hy, exact minpoly.aeval_of_is_scalar_tower R x y hy }
intros y hy
rw mem_roots_map (minpoly.ne_zero hx') at hy
use [minpoly R x, minpoly.monic hx]
rw ← aeval_def at ⊢ hy
exact minpoly.aeval_of_is_scalar_tower R x y hy
{ apply is_alg_closed.splits_codomain }
apply is_alg_closed.splits_codomain
{ apply_instance }
apply_instance
intros
rw [card, zmod.card]
intros
ext x n
simp only [coeff_frobenius_char_p, map_coeff, frobenius_def]
intros
simp only [witt_polynomial_eq_sum_C_mul_X_pow]
rw [sum_range_succ, ← nat.cast_pow, char_p.cast_eq_zero (zmod (p^(n+1))) (p^(n+1)), C_0, zero_mul, add_zero, alg_hom.map_sum, sum_congr rfl]
intros k hk
rw [alg_hom.map_mul, alg_hom.map_pow, expand_X, alg_hom_C, ← pow_mul, ← pow_succ]
congr
rw mem_range at hk
rw [add_comm, nat.add_sub_assoc (nat.lt_succ_iff.mp hk), ← add_comm]
intros
transitivity _
{ transitivity _, rw [←quotient.out_eq c, ←quotient.out_eq c'], refl }
rw [←quotient.out_eq c, ←quotient.out_eq c']
refl
intros
simpa using cof_le_card c.ord
simp
intros
simp only [log, dif_pos b1]
intros
cases h with _ _ _ _ eb _ h₁ h₂ h₃; exact h₃
cases h with _ _ _ _ eb _ h₁ h₂ h₃
exact h₃
intros
simp only [eq_self_iff_true, pow_half_move_left]
intros
simp [h.symm, termg]
simp [h.symm, termg]; ac_refl
ac_refl
intros
have h'' : y ≤ z
{ transitivity, apply le_of_lt h, assumption }
transitivity
apply le_of_lt h
assumption
apply @nat.lt_of_add_lt_add_right _ x
rw [nat.sub_add_cancel h']
apply @lt_of_le_of_lt _ _ _ (z - y + y)
rw [nat.sub_add_cancel h'']
apply nat.add_lt_add_left h
intros
rwa [← hb, ← sub_eq_add_neg] at h
intros
simp [h₂.symm, h₁.symm, horner, add_mul, mul_right_comm]
intros
rw nhds_infty_eq
exact (has_basis_coclosed_compact.map _).sup_pure _
intros
rw ← singletons_open_iff_discrete
intro g
suffices : {g} = (λ (x : G), g⁻¹ * x) ⁻¹' {1}
rw this
{ rw this, exact (continuous_mul_left (g⁻¹)).is_open_preimage _ h, }
exact (continuous_mul_left (g⁻¹)).is_open_preimage _ h
simp only [mul_one, set.preimage_mul_left_singleton, eq_self_iff_true, inv_inv, set.singleton_eq_singleton_iff]
intros
simpa only [div_eq_mul_inv] using is_closed_map_mul_right (a⁻¹)
intros
refine ⟨λ h, hf.add_compl h, λ h, _⟩
rw [has_sum_subtype_iff_indicator] at hf ⊢
rw [set.indicator_compl]
simpa only [add_sub_cancel'] using h.sub hf
intros
{ ext x, exact symm_apply_apply e x }
ext x
exact symm_apply_apply e x
intros
apply is_open_compl_iff.1
refine is_open_iff_forall_mem_open.2 (λ x hx, ⟨(λ y, y * x⁻¹) ⁻¹' U, _, _, _⟩)
{ intros u hux, simp only [set.mem_preimage, set.mem_compl_iff, mem_coe] at hux hx ⊢, refine mt (λ hu, _) hx, convert U.mul_mem (U.inv_mem hux) hu, simp }
intros u hux
simp only [set.mem_preimage, set.mem_compl_iff, mem_coe] at hux hx ⊢
refine mt (λ hu, _) hx
convert U.mul_mem (U.inv_mem hux) hu
simp
{ exact U.is_open.preimage (continuous_mul_right _) }
exact U.is_open.preimage (continuous_mul_right _)
{ simp [U.one_mem] }
simp [U.one_mem]
intros
simpa using nhds_basis_abs_sub_lt (0 : α)
intros
rw [supr, map_cSup_of_continuous_at_of_monotone Cf Mf (range_nonempty _) H, ← range_comp, supr]
intros
simpa only [inv_inv] using @tendsto_inv_nhds_within_Ici _ _ _ _ (a⁻¹)
intros
rw ← frontier_compl; convert frontier_le_subset_eq hg hf; simp [ext_iff, eq_comm]
rw ← frontier_compl; convert frontier_le_subset_eq hg hf
rw ← frontier_compl
convert frontier_le_subset_eq hg hf
simp [ext_iff, eq_comm]
simp [ext_iff, eq_comm]
intros
let m := (add_monoid_hom.mul : α →+ α →+ α).compr₂ to_compl
have : continuous (λ p : α × α, m p.1 p.2)
from (continuous_coe α).comp continuous_mul
have di : dense_inducing (to_compl : α → completion α)
from dense_inducing_coe
convert di.extend_Z_bilin di this
ext ⟨x, y⟩
refl
intros
rw [rtendsto'_def]
{ rw [rtendsto'_def], apply all_mem_nhds_filter, apply rel.preimage_mono }
apply all_mem_nhds_filter
apply rel.preimage_mono
intros
split
introsI hf x₁ x₂ h
{ introsI hf x₁ x₂ h, let g₁ : of punit ⟶ X := ⟨λ _, x₁, continuous_of_discrete_topology⟩, let g₂ : of punit ⟶ X := ⟨λ _, x₂, continuous_of_discrete_topology⟩, have : g₁ ≫ f = g₂ ≫ f, by { ext, exact h }, rw cancel_mono at this, apply_fun (λ e, e punit.star) at this, exact this }
let g₁ : of punit ⟶ X := ⟨λ _, x₁, continuous_of_discrete_topology⟩
let g₂ : of punit ⟶ X := ⟨λ _, x₂, continuous_of_discrete_topology⟩
have : g₁ ≫ f = g₂ ≫ f
ext
ext
{ ext, exact h }
{ ext, exact h }
exact h
exact h
rw cancel_mono at this
apply_fun (λ e, e punit.star) at this
exact this
rw ← category_theory.mono_iff_injective
{ rw ← category_theory.mono_iff_injective, apply faithful_reflects_mono (forget CompHaus) }
apply faithful_reflects_mono (forget CompHaus)
intros
simp
intros
intros s hs
rw is_open_sigma_iff
intro j
classical
by_cases h : i = j
subst j
{ subst j, convert hs, exact set.preimage_image_eq _ sigma_mk_injective }
convert hs
exact set.preimage_image_eq _ sigma_mk_injective
convert is_open_empty
{ convert is_open_empty, apply set.eq_empty_of_subset_empty, rintro x ⟨y, _, hy⟩, have : i = j, by cc, contradiction }
apply set.eq_empty_of_subset_empty
rintro x ⟨y, _, hy⟩
have : i = j
cc
cc
contradiction
intros
unfold continuous_within_at at *
rw [nhds_within_prod_eq, prod.map, nhds_prod_eq]
exact hf.prod_map hg
intros
rcases mem_nhds_within_iff_exists_mem_nhds_inter.mp h2 with ⟨_, Hw, hw⟩
exact (nhds a).sets_of_superset ((nhds a).inter_sets Hw h1) hw
intros
rcases a
{ rcases a, refl }
refl
intros
rw [coord_change, e.apply_symm_apply' h]
intros
rw [h.embedding.closure_eq_preimage_closure_image, h.image_preimage]
intros
simp only [nhds_top', tendsto_infi, tendsto_principal, mem_Ioi]
intros
rw [mul_comm, mul_supr]; congr; funext; rw [mul_comm]
rw [mul_comm, mul_supr]; congr; funext
rw [mul_comm, mul_supr]; congr
rw [mul_comm, mul_supr]
congr
funext
rw [mul_comm]
intros
refine nnreal.summable_of_le (λ a, le_trans (le_of_eq (s.indicator_apply f a)) _) hf
split_ifs
exact le_refl (f a)
exact zero_le_coe
intros
rcases p with ⟨x, y⟩
induction x using ereal.rec; induction y using ereal.rec
induction x using ereal.rec
induction y using ereal.rec
{ exact continuous_at_add_bot_bot }
exact continuous_at_add_bot_bot
{ exact continuous_at_add_bot_coe _ }
exact continuous_at_add_bot_coe _
{ simpa using h' }
simpa using h'
induction y using ereal.rec
{ exact continuous_at_add_coe_bot _ }
exact continuous_at_add_coe_bot _
{ exact continuous_at_add_coe_coe _ _ }
exact continuous_at_add_coe_coe _ _
{ exact continuous_at_add_coe_top _ }
exact continuous_at_add_coe_top _
induction y using ereal.rec
{ simpa using h }
simpa using h
{ exact continuous_at_add_top_coe _ }
exact continuous_at_add_top_coe _
{ exact continuous_at_add_top_top }
exact continuous_at_add_top_top
intros
haveI : nonempty α := ⟨x⟩
convert (((hf.to_local_homeomorph f).continuous_at_iff_continuous_at_comp_right) _).symm
apply (local_homeomorph.left_inv _ _).symm
{ apply (local_homeomorph.left_inv _ _).symm, simp, }
simp
{ simp, }
simp
intros
ext s
{ ext s, simp [mem_uniformity_dist, (nhds_basis_ball.comap _).mem_iff, subset_def, real.dist_0_eq_abs] }
simp [mem_uniformity_dist, (nhds_basis_ball.comap _).mem_iff, subset_def, real.dist_0_eq_abs]
intros
rcases eq_empty_or_nonempty s with rfl|hne
unfreezingI { rcases eq_empty_or_nonempty s with rfl|hne }
exact ⟨r / 2, ⟨half_pos hr, half_lt_self hr⟩, empty_subset _⟩
{ exact ⟨r / 2, ⟨half_pos hr, half_lt_self hr⟩, empty_subset _⟩ }
have : is_compact s
from compact_of_is_closed_subset (proper_space.is_compact_closed_ball x r) hs (subset.trans h ball_subset_closed_ball)
obtain ⟨y, hys, hy⟩ : ∃ y ∈ s, s ⊆ closed_ball x (dist y x)
from this.exists_forall_ge hne (continuous_id.dist continuous_const).continuous_on
have hyr : dist y x < r
from h hys
rcases exists_between hyr with ⟨r', hyr', hrr'⟩
exact ⟨r', ⟨dist_nonneg.trans_lt hyr', hrr'⟩, subset.trans hy $ closed_ball_subset_ball hyr'⟩
intros
simp only [← nnreal.eq_iff, ← dist_nndist, imp_self, nnreal.coe_zero, dist_eq_zero]
intros
apply emetric.complete_of_convergent_controlled_sequences (λn, ennreal.of_real (B n))
{ simp [hB] }
simp [hB]
assume u Hu
{ assume u Hu, apply H, assume N n m hn hm, rw [← ennreal.of_real_lt_of_real_iff (hB N), ← edist_dist], exact Hu N n m hn hm }
apply H
assume N n m hn hm
rw [← ennreal.of_real_lt_of_real_iff (hB N), ← edist_dist]
exact Hu N n m hn hm
intros
rcases h with ⟨y, hy⟩
apply lt_top_iff_ne_top.1
calc inf_edist x s ≤ edist x y : inf_edist_le_edist_of_mem hy ... < ⊤ : lt_top_iff_ne_top.2 (edist_ne_top _ _)
intros
ext
{ ext, refl }
refl
intros
rcases precise_refinement (λ i, option.elim i sᶜ u) (option.forall.2 ⟨is_open_compl_iff.2 hs, uo⟩) _ with ⟨v, vo, vc, vf, vu⟩
refine ⟨v ∘ some, λ i, vo _, _, vf.comp_injective (option.some_injective _), λ i, vu _⟩
simp only [Union_option, ← compl_subset_iff_union] at vc
{ simp only [Union_option, ← compl_subset_iff_union] at vc, exact subset.trans (subset_compl_comm.1 $ vu option.none) vc }
exact subset.trans (subset_compl_comm.1 $ vu option.none) vc
simpa only [Union_option, option.elim, ← compl_subset_iff_union, compl_compl]
{ simpa only [Union_option, option.elim, ← compl_subset_iff_union, compl_compl] }
intros
convert γ.truncate_self 0; exact γ.extend_zero.symm
convert γ.truncate_self 0
exact γ.extend_zero.symm
exact γ.extend_zero.symm
exact γ.extend_zero.symm
exact γ.extend_zero.symm
exact γ.extend_zero.symm
exact γ.extend_zero.symm
exact γ.extend_zero.symm
exact γ.extend_zero.symm
exact γ.extend_zero.symm
intros
assume y hy
by_cases h : ∃ l, l < f x
obtain ⟨z, zlt, hz⟩ : ∃ z < f x, Ioc z (f x) ⊆ g ⁻¹' (Ioi y) := exists_Ioc_subset_of_mem_nhds (hg (Ioi_mem_nhds hy)) h
{ obtain ⟨z, zlt, hz⟩ : ∃ z < f x, Ioc z (f x) ⊆ g ⁻¹' (Ioi y) := exists_Ioc_subset_of_mem_nhds (hg (Ioi_mem_nhds hy)) h, filter_upwards [hf z zlt], assume a ha, calc y < g (min (f x) (f a)) : hz (by simp [zlt, ha, le_refl]) ... ≤ g (f a) : gmon (min_le_right _ _) }
filter_upwards [hf z zlt]
assume a ha
calc y < g (min (f x) (f a)) : hz (by simp [zlt, ha, le_refl]) ... ≤ g (f a) : gmon (min_le_right _ _)
simp only [not_exists, not_lt] at h
{ simp only [not_exists, not_lt] at h, exact filter.eventually_of_forall (λ a, hy.trans_le (gmon (h (f a)))) }
exact filter.eventually_of_forall (λ a, hy.trans_le (gmon (h (f a))))
intros
rcases exists_compact_mem_nhds x with ⟨K, hKc, hxK⟩
rcases mem_nhds_iff.1 hxK with ⟨t, h1t, h2t, h3t⟩
exact ⟨t, h2t, h3t, compact_closure_of_subset_compact hKc h1t⟩
intros
simp only [← ne_empty_iff_nonempty] at hsZ ⊢
apply mt (hs.elim_finite_subfamily_closed Z hZc)
push_neg
exact hsZ
intros
rw [(@map_nhds_subtype_coe_eq α _ s a (mem_of_mem_nhds ha) ha).symm]
rw [(@map_nhds_subtype_coe_eq α _ s a (mem_of_mem_nhds ha) ha).symm]; exact tendsto_map' (continuous_iff_continuous_at.mp hf.continuous _)
exact tendsto_map' (continuous_iff_continuous_at.mp hf.continuous _)
intros
rw [map_swap_eq_comap_swap]; from map_le_iff_le_comap.1 tendsto_swap_uniformity
rw [map_swap_eq_comap_swap]
from map_le_iff_le_comap.1 tendsto_swap_uniformity
intros
rw uniform_continuous_iff
exact infi_le (λ j, uniform_space.comap (λ (a : Π (i : ι), α i), a j) (U j)) i
intros
assume u hu
apply (h u hu).mono (λ n hn, _)
exact λ x, hn _
